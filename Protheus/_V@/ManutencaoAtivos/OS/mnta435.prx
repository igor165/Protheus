#INCLUDE "mnta435.ch"
#INCLUDE "Protheus.ch"
#INCLUDE "FONT.CH"
#INCLUDE "COLORS.CH"

Static cMVPAR01   := '' // Váriavel utilizada para controle do filtro de etapas não executadas da O.S.
Static lPEMNTA435 := ExistBlock( "MNTA435N" )
Static lHasMNTREQ := !Empty( SuperGetMV( 'MV_MNTREQ', .F., '' ) ) // Param. utilizado para realizar requisições ao estoque.

//-------------------------------------------------------------------
/*/{Protheus.doc} MNTA435
Retorno de O.S. Modelo 2

VERSAO 2
-Reporte por Tarefa ou Tarefa/Etapa
-facilitar busca por OS
-melhor opcoes da etapa

@author  Denis Hyroshi de Souza
@since   23/06/2008
@version P12
@param strChave, caracter, Chave de Pesquisa
@param numIndice, numérico, Indice do STJ
/*/
//-------------------------------------------------------------------
Function MNTA435(strChave,numIndice)

	// Guarda conteudo e declara variaveis padroes
	Local aNGBEGINPRM := NGBEGINPRM(,,,,.T.)

	// Declaracao das Variaveis dos componentes
	Local cOrdIx
	Local nControl  := 0
	Local aPages    := {}
	Local aTitles   := {}
	Local aLegend 	:= {}
	Local aDadosInd := fMontInd("STJ")
	Local lRetTela  := .F.
	Local lRetTmp   := .F.
	Local nLinGet   := 3000

	Private lArvoreLogica := ( ValType( StrChave ) == "C" .And. ValType( numIndice ) == "N" )
	Private cChave435     := Space(255)
	Private nOrdem435     := 1

	If lArvoreLogica
		nOrdem435 := numIndice
	EndIf

	SetKey( VK_F5 , { || fF4KEY() } )
	SetKey( VK_F10, { || MNT435RLOC( 1 ) } )
	SetKey( VK_F11, { || MNT435RLOC( 2 ) } )
	SetKey( VK_F12, { || fPerg435() } )

	Private oOrdem
	Private oBtnBuscar
	Private oFolder435
	Private aChave435    := aDadosInd[1]
	Private aOrdIx435    := aDadosInd[2]
	Private aBlockInd    := {}
	Private cPrograma    := "MNTA400"
	Private oOk          := LoadBitmap( GetResources(), "ENABLE" )
	Private oVerde       := LoadBitmap( GetResources(), "br_verde" )
	Private oRed         := LoadBitmap( GetResources(), "br_vermelho" )
	Private oLaranja     := LoadBitmap( GetResources(), "br_laranja" )
	Private oAzul        := LoadBitmap( GetResources(), "br_azul" )
	Private oBranco      := LoadBitmap( GetResources(), "LBNO" )
	Private oChecked     := LoadBitmap( GetResources(), "LBOK" )
	Private aSize	     := MsAdvSize(,.F.,420), aObjects := {}
	Private cMARCA       := GetMark()
	Private lFoiAlterado := .F.
	Private lCamposSA	 := If(STJ->(FieldPos("TL_NUMSA")) > 0 .And. STJ->(FieldPos("TL_ITEMSA")) > 0, .T., .F.)
	Private Inclui		 := .T.
	Private Altera		 := .T.
	Private lFocusBrw3	 := .F.
	Private aCoBrw2		 := {}
	Private aCoBrw3		 := {}
	Private aCoBrw4		 := {}
	Private aCoBrw6		 := {}
	Private aCols        := {}
	Private aHoBrw2      := {}
	Private aHoBrw3      := {}
	Private aHoBrw4      := {}
	Private aHoBrw6      := {}
	Private aHeader      := {}
	Private aInsSub      := {}
	Private aCores2      := {}
	Private aTRBK        := {}
	Private aCores       := {} // Cores dos Insumos previstos
	Private noBrw2       := 0
	Private noBrw3       := 0
	Private noBrw4       := 0

	// Flags
	Private lRet435	:= .T. // Flag para indicar se grava os dados ou nao

	// Tamanho de Campos
	Private nLenST1	:= If( Len(ST1->T1_CODFUNC) > 0, Len(ST1->T1_CODFUNC), 6)

	// Tabelas Temporarias
	Private aVETINR := {}
	Private oTmpTbl1
	Private oTmpTbl2
	Private oTmpTbl3
	Private oTmpTbl4
	Private oTmpTbl5
	Private oTmpTbl6

	// Dados Temporarios
	Private aNewSC     := {} // Utilizado no processo de produto alternativo
	Private aOS        := {} // OS do browse principal
	Private aDadosOS   := {} // Espelho do aOS, com dados de insumos, etapas, etc...
	Private aDadosTPZ  := {} // Garantia de Insumos Temporario
	Private aDadosSA   := {} // Registros de S.A.
	Private aVetorCan  := {} // OS canceladas
	Private aVetorFin  := {} // OS finalizadas
	Private aProd435   := {} // PRODUTOS atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
	Private aLote435   := {} // LOTE atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
	Private aSubL435   := {} // SUB-LOTE atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
	Private aEnde435   := {} // ENDERECAMENTO atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
	Private aNovoSTL   := Nil
	Private aTRBQ      := {} // Layout TRB Etapas
	Private aTRBIP     := {} // Layout TRB Insumos Previstos
	Private aNgBtn     := {}
	Private aCampStj   := {} // Campos exibidos da tabela STJ
	Private aVisuStj   := {} // Propriedade Visualizar dos Campos exibidos da tabela STJ
	Private aTxtCampo  := {} // Titulo dos campos exibidos da STJ
	Private cDefLista  := "" // Define Array para listbox oOS
	Private cOrdemTJ   := Space( Len( STJ->TJ_ORDEM ))
	Private cPlanoTJ   := Space( Len( STJ->TJ_PLANO ))
	Private cCdBemTJ   := Space( Len( STJ->TJ_CODBEM ))
	Private nPosOS	   := 2 // Posição do campo TJ_ORDEM no browse
	Private nPosPL	   := 3 // Posição do campo TJ_PLANO no browse
	Private cFiltSTJ   := "" // Filtro do browse STJ
	Private lChkEtaAnt := .T.

	// Variaveis Utilizadas para o Botao de Conhecimento
	Private cCadastro  := Oemtoansi(STR0001) // "Retorno de Ordem de Serviço"
	Private cCadTemp   := cCadastro
	Private bSalvar	   := {|| If(fValidOK(@lRetTmp,.T.,@oChv435),Processa({|| fGrava435(,.T.) } , STR0002 ),lRetTmp := .F.) } // "Gravando as informações"

	// Variaveis de campo
	Private M->TJ_ORDEM   := cOrdemTJ
	Private M->TJ_PLANO   := cPlanoTJ
	Private M->TJ_CODBEM  := cCdBemTJ
	Private M->TL_TIPOREG := " "
	Private M->TL_DESTINO := " "
	Private M->TL_CODIGO  := Space(Len(stl->tl_codigo))
	Private M->TL_UNIDADE := Space(03)
	Private M->TL_LOCAL   := "  "
	Private M->TL_DTINICI := StoD("")
	Private M->TL_HOINICI := Space(5)
	Private M->TL_DTFIM   := StoD("")
	Private M->TL_HOFIM   := Space(5)
	Private M->TL_QUANTID := 0
	Private M->TL_NUMLOTE := Space(6)
	Private M->TL_LOTECTL := Space(10)
	Private M->TL_LOCALIZ := Space(15)
	Private M->TL_NUMSERI := Space(20)
	Private M->TL_GARANTI := Space(1)
	Private M->TL_TAREFA  := "0     "
	Private M->TL_USACALE := "N"
	Private M->TL_SEQRELA := "0  "

	// Parametros
	Private aARTAR     := {}
	Private lRETORNO   := .F.
	Private cLocaliz   := Space(Len(TPS->TPS_CODLOC))  // Codigo de Localizacao
	Private lNumSeq2   := NGCADICBASE("TL_NUMSEQ2","A","STL",.F.)
	Private aTROCAF3   := {}
	Private cUSAINT1   := AllTrim( GETMv( "MV_NGMNTPC" )) // Integração PCP
	Private cUsaInt2   := AllTrim( GetMv( "MV_NGMNTCM" )) // Integração Compras
	Private cUsaInt3   := AllTrim( GetMv( "MV_NGMNTES" )) // Integração Estoque
	Private cUIntHis   := AllTrim( GetMv( "MV_NGHISES" ))
	Private cUsaGeRe   := " "
	Private lESTNEGA   := If(AllTrim(GETMV("MV_ESTNEG")) == "S",.T.,.F.)
	Private cTENDFLAHA := AllTrim(GETMv("MV_NGTNDFL"))
	Private cGERAPREV  := AllTrim(GETMv("MV_NGGERPR"))
	Private lCUSTO     := If(cUsaInt3 == "N",.T.,.F.)
	Private cVALPECRE  := AllTrim(GETMv("MV_NGCOQPR"))
	Private cParSX6Ret := SuperGetMv("MV_NGREPRE",.F.," ")
	Private cRet400    := SuperGetMv("MV_NGUSUAL",.F.," ")
	Private dDtUlMes   := SuperGetMv('MV_ULMES', .F., " " )
	Private oMenu
	Private cNGINSPREA := "R" // Indica se o insumo e realizado ou previsto, nao deve ser retirado
	Private lCpoPerc   := If( STQ->(FieldPos("TQ_PERCENT")) > 0 , .T. , .F. )
	Private lOrPai435  := .F. // Indica se apresenta indices de Ordem e Bem Pai
	Private lIntSFC    := FindFunction("NGINTSFC") .And. NGINTSFC() // Verifica se ha integracao com modulo Chao de Fabrica [SIGASFC]
	Private lMMoeda    := NGCADICBASE("TL_MOEDA","A","STL",.F.) // Multi-Moeda

	// Declaracao das Variaveis dos Objetos
	Private lStartVar := .F.
	Private oDlg1
	Private oSay1
	Private oSay2
	Private oSay3
	Private oGet1
	Private oBrw1
	Private oBtn1
	Private oBtn2
	Private oBtn3
	Private oBtn4
	private oBtn5
	Private oChv435
	Private oBrw2
	Private oGrp2
	private oBrw3
	Private oGrp3
	private oBrw4
	Private oBrw5
	Private oBrw6
	Private oBrw7
	Private oGrp4
	Private oGrp5
	Private oSay4
	Private oSay5
	Private oSay6
	Private oSay7
	Private oSay8
	Private oSay9
	Private oGet3
	Private oGet4
	Private oGet5
	Private oGet6
	Private oGet7
	Private oMenuFil
	Private asMenu1	  := 	{{STR0003,"FilSTJ435(nOrdem435,1)"},; // "Mostrar todas as O.S. abertas"
							{STR0004,"FilSTJ435(nOrdem435,2)"},; // "Filtrar as O.S. pela chave de pesquisa"
							{STR0005,"FilSTJ435(nOrdem435,3)"}}  // "Montar filtro manualmente"
	Private bOSLine1
	Private oFont1	  := TFont():New( "Arial",0,-19,,.F.,0,,400,.F.,.F.,,,,,, )
	Private oFont2	  := TFont():New( "Arial",0,-13,,.F.,0,,400,.F.,.F.,,,,,, )
	Private oFont3	  := TFont():New( "Arial",0,-11,,.T.,0,,400,.F.,.F.,,,,,, )
	Private lCORRET	  := .T. // Indica que a OS é corretiva
	Private nControGD := 0   // Variavel para controle da ultima GETDADOS editada devido ao problema de que quando se esta editando a getdados
	// e depois clica direto no OK nao e executado o CODBLOCK de LOSTFOCUS da GETDADOS.

	// Variaveis de Posicionamento  Objetos
	Private nTipoVert
	Private nTipoHorz
	Private nPorcVert
	Private nPorcHorz
	Private nFolIniI
	Private nFolColI
	Private nFolLarg
	Private nFolAltu
	Private nBOSIniI
	Private nBOSColI
	Private nBOSLarg
	Private nBOSAltu
	Private nIPrIniI
	Private nIPrColI
	Private nIPrLarg
	Private nIPrAltu
	Private nFO1IniI
	Private nFO1ColI
	Private nFO1Larg
	Private nFO1Altu
	Private nFO2IniI
	Private nFO2ColI
	Private nFO2Larg
	Private nFO2Altu
	private nFO3IniI
	Private nFO3ColI
	Private nFO3Larg
	Private nFO3Altu
	Private nFO4IniI
	Private nFO4ColI
	Private nFO4Larg
	Private nFO4Altu
	Private nBtCeLin
	Private nBtCeCol
	Private nBtEtLin
	Private nBtEtCol
	Private nSalBtn
	Private nLaToLin
	Private nLaToCol
	Private nBtDista
	Private nFZ2ColI
	Private nFZ2Larg
	Private nTamBotao

	Private lPendInput := .T.
	Private lPartInput := .T.
	Private lTotInput := .T.

	// Variaveis para Ponto de Entrada
	Private aInsNaoGra := {}	//Utilizada no Ponto de Entrada MNTA4353 e MNTA4354
	Private aNBaixaEst := {}	//Ponto de Entrada MNT4356 - Variável para bloqueio de movimentação do estoque
	Private lVldExcG   := .T.	//Flag utilizada em P.E. para que a validação da exclusao do insumo não seja executado duas vezes.
	Private cCodFunc   := ""	//De acordo com a utilização do Ponto de Entrada MNTA435G para gravação do código do funcionário padrão
	Private nIndStq435 := 3  // Índice utilizado para ordenação de etapas

	//Botões da Barra de botões a ser declarado na funcao MNTA435BAR
	Private oBtCalc
	Private oBtSpl
	Private oBtAjd
	Private oBtVsl
	Private oBtImp
	Private oBtRdz
	private oBtRto
	Private oBtCOS
	Private oBtFOS
	Private oBtLgd
	Private oBtBCn
	Private oBtGrv
	Private oBtPEt
	Private oBtRMR
	Private oBtOK
	Private oBtCan

	//Otimização da tela principal
	Private oPanelPrin
	Private oPanelUP1
	Private oPanelUP2
	Private oPanelUP12
	Private oPanelUP3
	Private oPanelUP31
	Private oPanelUP32
	Private oPanelUP33
	Private oPnlUP34
	Private oPnlUP342
	Private oPnlUP343
	Private oPanelUP4
	Private oPanelUP41
	Private oPanelUP42
	Private oPanelUP43
	Private oPanelUP44
	Private oPnlUP442
	Private oPnlUP443
	Private oPnlUP4431
	Private oPanelUP5
	Private oPanelUP6
	Private oBtnFiltOS
	Private oPnlInput
	Private oPending
	Private oPartially
	Private oTotally

	Private lIntRM := AllTrim(GetNewPar("MV_NGINTER","N")) == "M"

	/*----------------------------------------------------------------+
	| Valor padrão das perguntas de parametrização da rotina MNTA435. |
	+----------------------------------------------------------------*/
	Pergunte( 'MNT435', .F. )
	
	/*--------------------------------------------------+
	| Atribuição da váriavel de controle das perguntas. |
	+--------------------------------------------------*/
	cMVPAR01 := cValToChar( MV_PAR01 )

	If ExistBlock( "MNTA4357" )
		MsgInfo( STR0386, STR0037 ) // "Foi identificada a existência do Ponto de Entrada MNTA4357 compilado neste ambiente."
									// "Informamos que este ponto de entrada foi descontinuado.
									// Para validações adicionais utilize o PE MNTA435N."
	EndIf

	If !NGCADICBASE("TB0_FILORD","A","TB0",.F.) .And. NGFUNCRPO("SgaMntEst",.F.) .And. GetMv("MV_SGAMNT") == "S" .And. GetMv("MV_NGSGAES") <> "N"
		If !NGINCOMPDIC("UPDSGA01","00000015391/2010")
			Return
		EndIf
	EndIf

	If !AMiIN(19,56) //Somente autorizado para o MNT/SGA
		Return
	EndIf

	// Declaracao das Variaveis de dimensionamento de tela
	aAdd(aObjects,{050,050,.T.,.T.})
	aAdd(aObjects,{100,100,.T.,.F.})
	aAdd(aObjects,{100,100,.T.,.F.})

	aInfo := {aSize[1],aSize[2],aSize[3],aSize[4],0,0}
	aPosObj := MsObjSize(aInfo, aObjects,.T.)

	// Cores dos insumos previstos
	aAdd(aCores,{"(cTRBIP)->STATUS == '0'","BR_VERMELHO"  })
	aAdd(aCores,{"(cTRBIP)->STATUS == '1'","BR_LARANJA"})
	aAdd(aCores,{"(cTRBIP)->STATUS == '2'","BR_VERDE"   })

	If ExistBlock("MNTA4355") // ponto de entrada para retornar um array de condicoes e cores, para serem usadas em uma nova coluna como sendo uma segunda legenda
		aCores2 := ExecBlock("MNTA4355",.F.,.F.)
	EndIf

	// Alias Tabelas Temporárias
	Private cTRBZ400 := GetNextAlias()
	Private cTRBK400 := GetNextAlias()
	Private cTRBQ400 := GetNextAlias()
	Private cTRBTAR	 := GetNextAlias()
	Private cTRB3400 := GetNextAlias()
	Private cTRBIP	 := GetNextAlias()

	// Define posicionamento dos objetos
	fPosObjet()

	// Carrega o titulo e nome dos campos do browse STJ
	LoadInfSTJ()

	// Carrega a variavel aOS (sem informacoes)
	LoadRegAOS(,1,.F.,.F.,0)

	// Cabecalho e linha vazia para Motivo Atraso
	aHoBrw4 := NGHeader("TPL", {"TPL_FILIAL","TPL_ORDEM"}, .F. )

	nPosDtF := aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_DTFIM" })

	aCoBrw4 := BLANKGETD(aHoBrw4)

	// Cabecalho e linha vazia para Ocorrencias
	aHoBrw3 := NGHeader("STN", {"TN_FILIAL", "TN_TAREFA","TN_NOMETAR","TN_ORDEM","TN_PLANO","TN_SEQRELA", "TN_SEQUENC"}, .F. )

	aCoBrw3 := BLANKGETD(aHoBrw3)

	// Monta Arq para Insumos
	PutFileInEof("STL")
	fTrbInsPre()

	// Monta Arq para Etapas da OS
	fTrbEtapa()

	Private nTpRg435 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})

	// Variáveis do F3 de Ocorrências (Cauxa X Problema X Solução)
	Private aHeaderSTN := {}

	If aScan( aHeader, { |x| Trim( Upper( x[2] ) ) == "TN_CODOCOR" } ) > 0
		aHeaderSTN := aHeader
	Else
		aHeaderSTN := aHoBrw3
	EndIf

	// Variáveis do F3 de Ocorrências (Cauxa X Problema X Solução)
	Private nCodOcor := aScan( aHeaderSTN, { |x| Trim( Upper( x[2] ) ) == "TN_CODOCOR" })

	// Criação da Tela Principal
	DEFINE MSDIALOG oDlg1 Title OemToAnsi(cCadastro) From aSize[7],0 To aSize[6],aSize[5] Of oMainWnd COLOR CLR_BLACK,CLR_WHITE Pixel
	oDlg1:lMaximized := .T.

	// Monta Tela Principal
	oPanelPrin := TPanel():New(aSize[6],aSize[5],,oDlg1,,,,,,10,10,.F.,.F.)
		oPanelPrin:Align := CONTROL_ALIGN_ALLCLIENT

	// Monta Parte Superior - Tela dividida em duas (superior e inferior)
	oPanelUP1 := TPanel():New(0,0,,oPanelPrin,,,,,,10,10,.F.,.F.)
		oPanelUP1:nHeight := (aSize[6]/1.1)
		oPanelUP1:nWidth := (aSize[5]/2)
		oPanelUP1:Align := CONTROL_ALIGN_ALLCLIENT

	// Monta Parte Superior Busca
	oPanelUP12 := TPanel():New(0,0,,oPanelPrin,,,,,,10,10,.F.,.F.)
		oPanelUP12:nHeight := (aSize[6]/19)
		oPanelUP12:nWidth  := (aSize[5]/2)
		oPanelUP12:Align   := CONTROL_ALIGN_TOP

	// Monta Parte Inferior - Tela dividida em duas (superior e inferior)
	oPanelUP2 := TPanel():New(0,0,,oPanelPrin,,,,,,10,10,.F.,.F.)
		oPanelUP2:nHeight := (aSize[6]/2.37)
		oPanelUP2:nWidth := (aSize[5]/2)
		oPanelUP2:Align := CONTROL_ALIGN_BOTTOM

	// Pesquisa do Browse de Ordem de Servico
	NGPOPUP( aSMenu1, @oMenuFil )
	@ 002, 001 Combobox oOrdem Var cOrdIx Items aOrdIx435 Size 200,08 Pixel Of oPanelUP12 On Change ( nOrdem435 := oOrdem:nAt, fAlterInd( nOrdem435 ) )
	@ 002, 206 MsGet oChv435 Var cChave435 Picture '@!' Size 110,08 Of oPanelUP12 Pixel
	@ 002, 321 Button oBtnBuscar Prompt STR0006 Of oPanelUP12 Size 37,11 Pixel Action LoadRegAOS( RTrim( cChave435 ), nOrdem435, .F., .T., 0 ) // Buscar
	@ 002, 361 Button oBtnFiltOS Prompt STR0007 Of oPanelUP12 Size 37,11 Pixel Action { |o,x,y| oMenuFil:Activate( 677, 24, oPanelUP12 ) } // Filtrar O.S.

	If lArvoreLogica //Se Chamada for pela arvore logica não poderá filtrar/buscar
		oDlg1:LESCCLOSE := .F.
		oBtnFiltOS:Disable()
	EndIf

	// Montagem das Ordens de Servico
	oOS:= TWBrowse():New( 0, 0, 0, 0,,aTxtCampo,,oPanelUP1,,,,,,,,,,,,.F.,,.T.,,.F.,,,)
	oOS:SetArray(aOS)
	oOS:Align     := CONTROL_ALIGN_ALLCLIENT
	bOSLine1      := { || &(cDefLista)}
	oOS:bLine     := bOSLine1
	oOS:GoTop()
	oOS:Refresh()
	oOS:bChange   := { || fCallRef( oOs:nAt ), oOS:Refresh() }

	// Montagem dos FOLDERS
	aTitles  := {STR0087,STR0017,STR0018,STR0019} // "Insumos"###"Etapas"###"Ocorrências"###"Motivo de Atraso"
	aPages   := {"HEADER 1","HEADER 2","HEADER 3","HEADER 4"}
	nControl := 4

	oFolder435 := TFolder():New( 0, 0, aTitles,aPages,oPanelUP2,,,,.F.,.F.,0 ,0 ,)
	oFolder435:Align := CONTROL_ALIGN_ALLCLIENT
	// Folder de Insumos
	oFolder435:aDialogs[1]:oFont := oPanelUP2:oFont
	// Folder de Etapas
	oFolder435:aDialogs[2]:oFont := oPanelUP2:oFont
	// Folder de Ocorrências
	oFolder435:aDialogs[3]:oFont := oPanelUP2:oFont
	// Folder de Motivo de Atraso
	oFolder435:aDialogs[4]:oFont := oPanelUP2:oFont

	// Folder 1 - Insumos
	oPanelUP3 := TPanel():New(0,0,,oFolder435:aDialogs[1],,,,,,10,10,.F.,.F.)
		oPanelUP3:Align := CONTROL_ALIGN_ALLCLIENT
		oPanelUP3:nWidth := (aSize[5]/2)

	// Folder 1 - Parte 1 Insumos previstos (Dividida em três, insumos previstos/botões/realizados)
	oPanelUP31 := TPanel():New(0,0,,oPanelUP3,,,,,,10,10,.F.,.F.)
		oPanelUP31:Align := CONTROL_ALIGN_LEFT
		oPanelUP31:nWidth := (aSize[5]/2.15)

	// Folder 1 - Parte 2 Botões (Dividida em três, insumos previstos/realizados/botões)
	oPanelUP32 := TPanel():New(0,0,,oPanelUP3,,,,,,10,10,.F.,.F.)
		oPanelUP32:Align := CONTROL_ALIGN_ALLCLIENT
		oPanelUP32:nWidth := (aSize[5]/12)

	// Contorno Folder 1 - Parte 2 Botões
	oGrp2 := TGroup():New( 0, 0, 0, 0,,oPanelUP32,,,.T.,.F. )
		oGrp2:Align := CONTROL_ALIGN_ALLCLIENT

	// Folder 1 - Parte 3 Insumos Realizados (Dividida em três, insumos previstos/botões/realizados)
	oPanelUP33 := TPanel():New(0,0,,oPanelUP3,,,,,,10,10,.F.,.F.)
		oPanelUP33:Align := CONTROL_ALIGN_RIGHT
		oPanelUP33:nWidth := (aSize[5]/2.15)

	// Folder 1 - Parte 4 Superior (Descrição dos insumos)
	oPnlUP34 := TPanel():New(0,0,,oPanelUP3,,,,,,10,10,.F.,.F.)
		oPnlUP34:Align := CONTROL_ALIGN_TOP
		oPnlUP34:nHeight := (aSize[6]/26)
		oPnlUP34:nWidth := aSize[5]

	// Folder 1 - Parte 4 Superior (Insumos Previstos)
	oPnlUP342 := TPanel():New(0,0,STR0008,oPnlUP34,,,,,,10,10,.F.,.F.) // "Insumos Previstos"
		oPnlUP342:Align := CONTROL_ALIGN_LEFT
		oPnlUP342:nWidth := (aSize[5]/12)

	// Painel com os Checkbox de aplicação de insumos
	oPnlInput := TPanel():New(01, 10,, oPnlUP34,,,,,, 0, 80, .F., .F.)
	oPnlInput:Align := CONTROL_ALIGN_LEFT
	oPnlInput:nWidth := (oPnlUP34:nWidth / 2) - oPnlUP342:nWidth
	oPnlInput:Disable()

	TSay():New(02, 00, {|| STR0267 + ":"}, oPnlInput,,,,,, .T.) // "Exibir:"

	oPending := TCheckBox():New(02, 20, STR0353,, oPnlInput, 60, 7,,,,,,,, .T.,,,) // "Não aplicado"
	oPending:bSetGet   := {|u| If(PCount() == 0 , lPendInput , lPendInput := u)}
	oPending:bLClicked := {|u| fUpdInput()}

	oPartially := TCheckBox():New(02, 70, STR0354,, oPnlInput, 70, 7,,,,,,,, .T.,,,) // "Parcialmente Aplicado"
	oPartially:bSetGet   := {|u| If(PCount() == 0 , lPartInput , lPartInput := u)}
	oPartially:bLClicked := {|u| fUpdInput()}

	oTotally := TCheckBox():New(02, 143, STR0355,, oPnlInput, 60, 7,,,,,,,, .T.,,,) // "Totalmente aplicado"
	oTotally:bSetGet   := {|u| If(PCount() == 0 , lTotInput , lTotInput := u)}
	oTotally:bLClicked := {|u| fUpdInput()}

	//Folder 1 - Parte 4 Superior (Insumos Realizados)
	oPnlUP343 := TPanel():New(0,0,STR0009,oPnlUP34,,,,,,10,10,.F.,.F.) //"Insumos Realizados"
		oPnlUP343:Align := CONTROL_ALIGN_RIGHT
		oPnlUP343:nWidth := (aSize[5]/2.15)

	// Montagem dos Insumos previstos e realizados.

	// Insumos Previstos da Ordem de Servico
	oGrp1:= TGroup():New( 0, 0, 0, 0, STR0008,oPanelUP31,,,.T.,.F. ) //"Insumos Previstos"
	oGrp1:Align := CONTROL_ALIGN_ALLCLIENT
	oBrw2:= MsSelect():New( (cTRBIP),"TL_OK","",aTRBIP,.F.,@cMARCA,{0, 0, 0, 0},,, oPanelUP31,, aCores)
	oBrw2:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
	oBrw2:bMark              := {|| MNT435SEL()}
	oBrw2:oBrowse:bAllMark	 := {|| MNT435ALL() }
	oBrw2:oBrowse:bGotFocus	 := {|| SetKey(VK_F4,{|| MntViewSB2((cTRBIP)->TL_TIPOREG, (cTRBIP)->TL_CODIGO ) })}
	oBrw2:oBrowse:bLostFocus := {|| SETKEY( VK_F4,Nil)}
	oBrw2:oBrowse:Disable()

	// Indice para listar os insumos por ordem de aplicação
	IndRegua((cTRBIP),CriaTrab(Nil, .F.),"STATUS",,.F.)

	// Insumos Realizados da Ordem de Servico
	dbSelectArea("STL")
	oGrp5 := TGroup():New( 0, 0, 0, 0, STR0009,oPanelUP33,,,.T.,.F. ) //"Insumos Realizados"
	oGrp5:Align := CONTROL_ALIGN_ALLCLIENT
	aCols := aClone(aCoBrw6)

	nTipR := aScan(aHoBrw6,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	cVal3 := x3valid("TL_TIPOREG")

	aHoBrw6[nTipR,6] := StrTran(cVal3,'NGCLEARSTL()','MNTA435TR() .And. NGCLEARSTL()')

	nNumS   := aScan(aHoBrw6,{|x| Trim(Upper(x[2])) == "TL_NUMSEQ"})
	aHeader := aClone(aHoBrw6)
	oBrw6   := MsGetDados():New(0, 0, 0, 0, 4, "LinOkTL435()","TudOkTL435()","",.T.,,,,nLinGet,"fValDel435(.T.)",,,"fValDel435(.T.,,,.T.)" ,oPanelUP33)
	oBrw6:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
	oBrw6:oBrowse:lDisablePaint := .T.
	oBrw6:oBrowse:bGotFocus     := {|| Fd_Entra(1)}
	oBrw6:oBrowse:bLostFocus    := {|| Fd_Sai( 1 )}
	oBrw6:oBrowse:bChange       := {|| fLoadSTL(.F.)}
	oBrw6:oBrowse:Disable()
	oBrw6:oBrowse:Default()
	oBrw6:oBrowse:Refresh()

	// Botoes para transformar o insumo previsto em realizado
	@ 001, 15 BTNBMP oBtAllNext Resource "NG_ICO_RETORNO02" Size 34,34 Pixel Of oPanelUP32 Noborder Pixel Action MNT435CALLB( 1,@oChv435 ) // fPrgNext(@oChv435)
	@ 041, 15 BTNBMP oBtNext    Resource "NG_ICO_RETORNO01" Size 34,34 Pixel Of oPanelUP32 Noborder Pixel Action MNT435CALLB( 2,@oChv435 ) // f435Next(@oChv435)
	@ 081, 15 BTNBMP oBtPrev    Resource "NG_ICO_RETORNO04" Size 34,34 Pixel Of oPanelUP32 Noborder Pixel Action MNT435CALLB( 3 ) // f435Prev()
	@ 121, 15 BTNBMP oBtAllPrev Resource "NG_ICO_RETORNO03" Size 34,34 Pixel Of oPanelUP32 Noborder Pixel Action MNT435CALLB( 4 ) // fPrgPrev()
	@ 201, 15 BTNBMP oBtFilIns  Resource "FILTRO" 		  	Size 32,32 Pixel Of oPanelUP32 Noborder Pixel Action fFiltroS()
	@ 241, 15 BTNBMP oBtGeraSA  Resource "SOLICITA" 		Size 34,34 Pixel Of oPanelUP32 Noborder Pixel Action Processa({|lEND| fGerarSA()},STR0010) //"Gerando Solicitação ao Armazém..."

	oBtAllNext:cToolTip		:= STR0011 // "Incluir todos os insumos previstos"
	oBtAllNext:lCanGotFocus	:= .T.     // Força a perda do focus
	oBtNext:cToolTip		:= STR0012 // "Incluir o insumo previsto"
	oBtNext:lCanGotFocus	:= .T.     // Força a perda do focus
	oBtPrev:cToolTip		:= STR0013 // "Excluir o insumo realizado"
	oBtAllPrev:cToolTip		:= STR0014 // "Excluir todos os insumos realizados"
	oBtFilIns:cToolTip		:= STR0015 // "Filtro por tarefa para os insumos previstos e etapas da ordem de serviço"
	oBtGeraSA:cToolTip		:= STR0016 // "Gerar SA (Solicitação ao Armazém) para os itens selecionados"

	If ExistBlock( "MNTA435C" )
		oBtAllNext:Hide()
		oBtNext:Hide()
		oBtPrev:Hide()
		oBtAllPrev:Hide()
		oBtFilIns:Hide()
		oBtGeraSA:Hide()
	Else
		oBtAllNext:Disable()
		oBtNext:Disable()
		oBtPrev:Disable()
		oBtAllPrev:Disable()
		oBtFilIns:Hide()
		oBtGeraSA:Hide()
	EndIf

	// Folder 2
	oPanelUP4 := TPanel():New(0,0,,oFolder435:aDialogs[2],,,,,,10,10,.F.,.F.)
		oPanelUP4:Align := CONTROL_ALIGN_ALLCLIENT
		oPanelUP4:nWidth := (aSize[5]/2)

	// Folder 2 - Parte 1 Etapas da OS (Dividida em três, etapas da OS/botões/Etapas não realizadas)
	oPanelUP41 := TPanel():New(0,0,,oPanelUP4,,,,,,10,10,.F.,.F.)
		oPanelUP41:Align := CONTROL_ALIGN_LEFT
		oPanelUP41:nWidth := (aSize[5]/2.20)

	// Folder 2 - Parte 2 Botões (Dividida em três, etapas da OS/botões/Etapas não realizadas)
	oPanelUP42 := TPanel():New(0,0,,oPanelUP4,,,,,,10,10,.F.,.F.)
		oPanelUP42:Align := CONTROL_ALIGN_ALLCLIENT
		oPanelUP42:nWidth := (aSize[5]/12)

	// Folder 2 - Parte 3 Etapas Não Realizadas (Dividida em três, etapas da OS/botões/Etapas não realizadas)
	oPanelUP43 := TPanel():New(0,0,,oPanelUP4,,,,,,10,10,.F.,.F.)
		oPanelUP43:Align := CONTROL_ALIGN_RIGHT
		oPanelUP43:nWidth := (aSize[5]/2.20)

	// Folder 2 - Parte 4 Superior (Descrição das etapas)
	oPanelUP44 := TPanel():New(0,0,,oPanelUP4,,,,,,10,10,.F.,.F.)
		oPanelUP44:Align := CONTROL_ALIGN_TOP
		oPanelUP44:nHeight := (aSize[6]/26)
		oPanelUP44:nWidth := aSize[5]

	// Folder 2 - Parte 4 Superior (Etapas da Ordem de Serviço)
	oPnlUP442 := TPanel():New(0,0,STR0020,oPanelUP44,,,,,,10,10,.F.,.F.) //"Etapas da Ordem de Serviço"
		oPnlUP442:Align := CONTROL_ALIGN_ALLCLIENT
		oPnlUP442:nWidth := (aSize[5]/12)

	// Folder 2 - Parte 4 Superior (Etapas não executadas de O.S. anteriores)
	oPnlUP443 := TPanel():New(0,0,,oPanelUP44,,,,,,10,10,.F.,.F.)
		oPnlUP443:Align := CONTROL_ALIGN_RIGHT
		oPnlUP443:nWidth := (aSize[5]/2.20)

	// Folder 2 - Parte 4 Superior Direita (Texto à esquerda)
	oPnlUP4431 := TPanel():New(0,0,,oPnlUP443,,,,,,10,10,.F.,.F.)
		oPnlUP4431:Align := CONTROL_ALIGN_LEFT
		oPnlUP4431:nWidth := (aSize[5]/2)

	aAdd(aLegend,{"(cTRBQ400)->STATUS == '1'"	,"BR_VERDE"	  }) //EXECUTADA
	aAdd(aLegend,{"(cTRBQ400)->STATUS == '2'"	,"BR_VERMELHO"}) //NÃO EXECUTADA
	aAdd(aLegend,{"(cTRBQ400)->STATUS == '3'"	,"BR_AMARELO" }) //EM EXECUÇÃO
	aAdd(aLegend,{"(cTRBQ400)->STATUS == '4'"	,"BR_LARANJA" }) //EXECUTADO > 100%

	// Montagem das Etapas da Ordem de Servico.
	@ nFO2IniI,nFO2ColI+10 Say STR0020 of oPanelUP41 Pixel //"Etapas da Ordem de Serviço"
    oBrw4 := MsSelect():New(cTRBQ400,"TQ_OK","",aTRBQ,.F.,@cMARCA,{0, 0, 0, 0},,,oPanelUP41,,aLegend)

	// Ponto de Entrada para selecionar o executante padrão das etapas de O.S.
	If ExistBlock("MNTA435G")
		cCodFunc := ExecBlock("MNTA435G",.F.,.F.)
	EndIf
	oBrw4:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
	oBrw4:oBrowse:bLostFocus := {|| Fd_Sai( 4 ) }
	oBrw4:oBrowse:bGotFocus  := {|| Fd_Entra(4) }
	oBrw4:oBrowse:Disable()
	oBrw4:bMark              := {|| Mnt435Mark() }
	oBrw4:oBrowse:bAllMark   := {|| MNT435ETAL() }

	@ 0,0 Say STR0021 of oPnlUP4431 Pixel // "Etapas não executadas de O.S. anteriores"

	dbSelectArea(cTRBTAR)
	@ 0,0 ListBox oBrw7 Fields (cTRBTAR)->DTMPINI,(cTRBTAR)->TAREFA, (cTRBTAR)->NOMETAR, (cTRBTAR)->ETAPA, (cTRBTAR)->NOMEETA, (cTRBTAR)->ORDEM ;
	COLSIZES 22,20,60,20,200,40 Size 0, 0; // nFO2Larg-nFO2ColI,nFO2Altu-(nFO2IniI+11)
	HEADERS STR0022,STR0023, STR0024, STR0025, STR0026, STR0027 ; // "Dt.Prevista"###"Tarefa"###"Nome Tarefa"###"Etapa"###"Descr. Etapa"###"Ordem"
	Of oPanelUP43 Pixel
	oBrw7:Align := CONTROL_ALIGN_ALLCLIENT
	oBrw7:Disable()

	@ 001 , 05 Button oBtEtInc PROMPT STR0028 of oPanelUP42 Size 34,nTamBotao Action (fCadEtapa(1)) Pixel // "Incluir"
	@ 014 , 05 Button oBtEtAlt PROMPT STR0029 of oPanelUP42 Size 34,nTamBotao Action (fCadEtapa(3)) Pixel // "Alterar"
	@ 027 , 05 Button oBtEtExc PROMPT STR0030 of oPanelUP42 Size 34,nTamBotao Action (fCadEtapa(2)) Pixel // "Excluir"
	@ 040 , 05 Button oBtEtAdd PROMPT "<< " + STR0031 of oPanelUP42 Size 34,nTamBotao Action fAddEtap() Pixel // "Adicionar"
	@ 053 , 05 Button oBtEtFil PROMPT STR0032 of oPanelUP42 Size 34,nTamBotao Action fFiltroS() Pixel // "Filtro"

	oBtEtInc:cToolTip := STR0033 // "Incluir uma nova etapa para a ordem de serviço"
	oBtEtAlt:cToolTip := STR0034 // "Alterar a etapa selecionada"
	oBtEtExc:cToolTip := STR0035 // "Excluir a etapa selecionada"
	oBtEtFil:cToolTip := STR0015 // "Filtro por tarefa para os insumos previstos e etapas da ordem de serviço"
	oBtEtAdd:cToolTip := STR0036 // "Transfere a etapa não executada de uma ordem de serviço antiga para a atual"

	oBtEtInc:Disable()
	oBtEtAlt:Disable()
	oBtEtExc:Disable()
	oBtEtFil:Hide()
	oBtEtAdd:Disable()

	// Folder 3
	oPanelUP5 := TPanel():New(0,0,,oFolder435:aDialogs[3],,,,,,10,10,.F.,.F.)
		oPanelUP5:Align := CONTROL_ALIGN_ALLCLIENT
		oPanelUP5:nWidth := (aSize[5]/2)

	// Montagem das Ocorrencias da Ordem de Servico.
	aCols   := aClone(aCoBrw3)
	aHeader := aClone(aHoBrw3)
	oBrw3   := MsGetDados():New(0,0,0,0,4,"LinOkTN435()","TudOkTN435()","",.T.,,,,nLinGet,,,,,oPanelUP5)
	oBrw3:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
	oBrw3:oBrowse:lDisablePaint := .T.
	oBrw3:oBrowse:bGotFocus     := {|| Fd_Entra(2) }
	oBrw3:oBrowse:bLostFocus    := {|| Fd_Sai( 2 ) }
	oBrw3:oBrowse:Disable()
	oBrw3:oBrowse:Default()
	oBrw3:oBrowse:Refresh()

	// Folder 4
	oPanelUP6 := TPanel():New(0,0,,oFolder435:aDialogs[4],,,,,,10,10,.F.,.F.)
		oPanelUP6:Align := CONTROL_ALIGN_ALLCLIENT
		oPanelUP6:nWidth := (aSize[5]/2)

	// Montagem do Motivo de Atraso da Ordem de Servico
	aCols   := aClone(aCoBrw4)
	aHeader := aClone(aHoBrw4)
	oBrw5   := MsGetDados():New(0, 0, 0, 0, 4   ,"LinOk435PL()","TudOk435PL()","",.T.,,,,nLinGet,,,,,oPanelUP6)
	oBrw5:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
	oBrw5:oBrowse:lDisablePaint := .T.
	oBrw5:oBrowse:bGotFocus     := {|| Fd_Entra(3) }
	oBrw5:oBrowse:bLostFocus    := {|| Fd_Sai( 3 ) }
	oBrw5:oBrowse:Disable()
	oBrw5:oBrowse:Default()
	oBrw5:oBrowse:Refresh()

	// Fim da montagem dos folders

	aCols   := aClone(aCoBrw6)
	aHeader := aClone(aHoBrw6)

	lStartVar := .T.

	If lArvoreLogica // Se Chamada for pela arvore logica abre apenas a OS corrente
		LoadRegAOS(strChave,nOrdem435,.F.,.F.,0)
	EndIf

	oChv435:SetFocus()

	NGPOPUP(aSMenu,@oMenu)
	oDlg1:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDlg1)}

    Activate MsDialog oDlg1 ON INIT MNTA435BAR(@oDlg1,;
		{|| If(fValidOK(@lRetTela,.T.,@oChv435),(Processa({|| fGrava435(,.F.,.F.) } , STR0002),oDlg1:End()),lRetTela := .F.) },; //Ok
			{|| oDlg1:End()}) Centered //Cancelar

	// Deleção de Tabelas Temporárias
	oTmpTbl3:Delete()
	oTmpTbl6:Delete()
	oTmpTbl4:Delete()
	oTmpTbl5:Delete()

	NGRETURNPRM(aNGBEGINPRM)

	aRet := {lRetTela,aClone(aVetorCan),aClone(aVetorFin)}

Return aRet
//---------------------------------------------------------------------
/*/{Protheus.doc} fGrava435
Gravar registros

@type Static function
@source MNTA435.prx
@author Denis
@since 06/08/2001
@param nIniOS, Numérico, posição da OS.
@param lRefBrow, Lógico, Indica se atualizará o browse.
@param lLoadIns, Lógico, Indica se os insumos da ordem selecioanda devem ser carregados.
@obs o parâmetro lLoadIns deve ser passado falso para os seguintes casos: botões
oBtOK (grava tabelas e fecha);
oBtCOS (grava cancelamento e fecha);
oBtFOS (grava e a ordem não será mais apresentada)

@return boolean, se houve sucesso na operação
/*/
//---------------------------------------------------------------------
Static Function fGrava435( nIniOS, lRefBrow, lLoadIns )

    Local nIndOS 		:= 0
	Local nIndTL 		:= 0
	Local nNoSeqSTL 	:= 0
	Local nX			:= 0
	Local nErro         := 0
	Local nIndTPL		:= 0
	Local nYtmp			:= 0
    Local nIndSTN		:= 0
	Local nIndOS2		:= 0
	Local nxSA			:= 0
	Local nXX			:= 0
	Local i				:= 0
	Local nXtmp			:= 0
	Local nPosArray 	:= 0
	Local nCopy         := 0
	Local nOrdemIni 	:= IIf( ValType(nIniOS) == "N", nIniOS,1)
	Local nOrdemFim 	:= IIf( ValType(nIniOS) == "N", nIniOS, Len(aOS))
	Local nItemSA   	:= 0
	Local nPosAux   	:= 0
	Local nPos01    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPos02 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DESTINO"})
	Local nPos03   	 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPos05    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"  })
	Local nPos06    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI"})
	Local nPos08    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM"  })
	Local nPos10    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANTID"})
	Local nPos11    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMLOTE"})
	Local nPos12    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOTECTL"})
	Local nPos13    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCALIZ"})
	Local nPos14    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSERI"})
	Local nPos15    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_GARANTI"})
	Local nPos16    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TAREFA" })
	Local nPos18    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
	Local nPos19    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_OBSERVA"})
	Local nPos20    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_ETAPA"})
	Local nPos21    	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CUSTO"})
	Local nPosGrt   	:= aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_GARANTI"}) //Verifica se esta focado no browse de insumos realizados
	Local nMotCo    	:= aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_CODMOT"})
	Local nMotDI    	:= aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_DTINIC"})
	Local nMotHI    	:= aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_HOINIC"})
	Local nMotDF    	:= aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_DTFIM" })
	Local nMotHF    	:= aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_HOFIM" })
	Local nOcoCo    	:= aScan(aHoBrw3,{|x| Trim(Upper(x[2])) == "TN_CODOCOR"})
	Local nOcoCa    	:= aScan(aHoBrw3,{|x| Trim(Upper(x[2])) == "TN_CAUSA"  })
	Local nOcoSo    	:= aScan(aHoBrw3,{|x| Trim(Upper(x[2])) == "TN_SOLUCAO"})
	Local nEtaTa    	:= aScan(aTRBQ  ,{|x| Trim(Upper(x[1])) == "TQ_TAREFA" })
	Local nEtapa    	:= aScan(aTRBQ  ,{|x| Trim(Upper(x[1])) == "TQ_ETAPA"  })
	Local nEtSeq        := aScan(aTRBQ  ,{|x| Trim(Upper(x[1])) == "TQ_SEQETA" })
	Local nEtSTar        := aScan(aTRBQ  ,{|x| Trim(Upper(x[1])) == "TQ_SEQTARE" })
    Local lDelGarant	:= .F.
	Local lAltGarant	:= .F.
	Local lTpGeraOS		:= .F.
	Local lTPGeraSS		:= .F.
	Local lCondicao		:= .F.
	Local lMNTB4354		:= ExistBlock("MNTB4354")
	Local lMNTA4353		:= ExistBlock("MNTA4353")
	Local lMNTA435I		:= ExistBlock("MNTA435I")
	Local lMNTA435M     := ExistBlock("MNTA435M")
	Local lProcSTL  	:= .T.
	Local lRet          := .T.
    Local lOSHESTO  	:= .F. //Variavel que indica se terá integração com o estoque quando TJ_SERVICO = 'HISTOR'
	Local lSerRef		:= .F.
    Local cOrdem		:= ""
	Local cPlano		:= ""
	Local cForm			:= ""
	Local cResp			:= ""
	Local cServCar		:= ""
	Local cTipoMan		:= ""
	Local cNGUNIDT		:= AllTrim(GETMV("MV_NGUNIDT"))
	Local cNGMNTAS		:= SuperGetMV("MV_NGMNTAS",.F.,"2")
	Local cMsgSS		:= ""
	Local cNumSA    	:= Space(TAMSX3("CP_NUM")[1])
	Local cNumCP    	:= Space( TAMSX3('CP_NUM')[1] )
	Local cTpcMark  	:= ''
    Local aReqSD3   	:= {}
	Local aTRBZ435  	:= {}
	Local aTempAux  	:= {}
	Local aSolic    	:= {}
	Local aLogRM        := {}
	Local aLogNoCanc    := {}
	Local aNoCopy       := {}
	Local aRollBack     := {}
	Local aRetSD3       := {}

	//--inicio--SS 024720//
	Local lPrimVez  	:= .T.
	Local lOSRepet  	:= .F.
	Local cChavAnt  	:= ""
	//---fim----SS 024720//

	Private aTRBZ   	:= {}

	Default lLoadIns 	:= .T.

	Store .F. To lTpGeraOS, lTPGeraSS, lCondicao

	//Ordena S.A. pelo campo Ordem + Plano
	aSort( aDadosSA,,,{|x,y| x[1]+x[2] < y[1]+y[2] })

	//Ordena Garantia pelo campo Ordem + Plano
	aSort( aDadosTPZ,,,{|x,y| x[5]+x[6] < y[5]+y[6] })

	aArray  := {}
	aArray2 := {}
	fCriaOsGer(@aTRBZ435)

	CursorWait()

	aInsNaoGra := {}
	aReqSD3    := {} //Salva requisicoes para executar no final da gravacao
	ProcRegua(Len(aOS))

	Begin Transaction

		For nX := nOrdemIni To nOrdemFim

			IncProc()
			cOrdem := aOS[nX,nPosOS]
			cPlano := aOS[nX,nPosPL]

			//Se o numero da OS nao existir
			dbSelectArea("STJ")
			dbSetOrder(1)
			If !dbSeek( xFilial("STJ") + cOrdem + cPlano )
				Loop
			EndIf

			If STJ->TJ_SITUACA == 'C'
				aAdd( aLogNoCanc, { STJ->TJ_ORDEM, STJ->TJ_PLANO } )
				Loop
			EndIf

			lOSHESTO := .F.

			If cUsaInt3 == 'S' .And. cUIntHis == "N" .And. STJ->TJ_SERVICO == "HISTOR"
				lOSHESTO := .T.
			EndIf

			cCodBem := STJ->TJ_CODBEM

			//Se o numero da OS nao existir no array
			nLineOS := aScan(aDadosOS, {|x|x[1]+x[2] == cOrdem+cPlano })

			If nLineOS == 0
				Loop
			EndIf

			//Gravacao Motivos de Atraso
			If ValType( aDadosOS[nLineOS,7] ) == "A"

				//Excluindo os motivos que foram retirados da tela
				dbSelectArea("TPL")
				dbSetOrder(1)
				dbSeek( xFilial("TPL") + cOrdem )
				While !EoF() .And. xFilial("TPL")+cOrdem == TPL->TPL_FILIAL+TPL->TPL_ORDEM
					If aScan(aDadosOS[nLineOS,7], {|x| x[nMotCo]          == TPL->TPL_CODMOT .And.;
					x[nMotDI] == TPL->TPL_DTINIC .And. x[nMotHI] == TPL->TPL_HOINIC .And.;
					x[nMotDF] == TPL->TPL_DTFIM  .And. x[nMotHF] == TPL->TPL_HOFIM  .And. !ATail(x) }) == 0

						RecLock("TPL", .F.)
						dbDelete()
						TPL->(MsUnLock())
					EndIf

					dbSelectArea("TPL")
					dbSkip()
				EndDo

				//Os registros deletados serão os primeiros da lista
				aSort(aDadosOS[nLineOS,7],,,{|x,y| ATail(x) .And. !ATail(y) })

				For nIndOS := 1 To Len(aDadosOS[nLineOS,7])

					If Empty( aDadosOS[nLineOS,7,nIndOS,nMotCo] ) //Nao validar se codigo vazio
						Loop
					EndIf

					cKeyTPL := xFilial("TPL") + cOrdem
					cKeyTPL += aDadosOS[nLineOS,7,nIndOS,nMotCo] + DtoS(aDadosOS[nLineOS,7,nIndOS,nMotDI])
					cKeyTPL += aDadosOS[nLineOS,7,nIndOS,nMotHI] + DtoS(aDadosOS[nLineOS,7,nIndOS,nMotDF])
					cKeyTPL += aDadosOS[nLineOS,7,nIndOS,nMotHF]

					//Se nao for deletado
					If !aDadosOS[nLineOS,7][nIndOS][Len(aDadosOS[nLineOS,7][nIndOS])]

						lTPL_Lock := .T.
						dbSelectArea("TPL")
						dbSetOrder(1) // TPL_FILIAL+TPL_ORDEM+TPL_CODMOT+DTOS(TPL_DTINIC)+TPL_HOINIC+DTOS(TPL_DTFIM)+TPL_HOFIM
						lTPL_Lock := !dbSeek(cKeyTPL)
						RecLock("TPL",lTPL_Lock)

						For nIndTPL := 1 To FCount()
							If Alltrim(FieldName(nIndTPL)) $ "TPL_FILIAL/TPL_ORDEM"
								Loop
							EndIf

							nPosTmp := aScan(aHoBrw4, {|x| AllTrim(Upper(X[2])) == FieldName(nIndTPL) })
							y  := "TPL->" + FieldName(nIndTPL)

							If nPosTmp > 0
								x  := "M->" + FieldName(nIndTPL)
								&x.:= aDadosOS[nLineOS,7,nIndOS,nPosTmp]
								&y := &x
							ElseIf lTPL_Lock
								&y := CriaVar(FieldName(nIndTPL))
							EndIf
						Next nIndTPL

						TPL->TPL_FILIAL := xFilial("TPL")
						TPL->TPL_ORDEM  := cOrdem
						TPL->(MsUnLock())
					Else

						dbSelectArea("TPL")
						dbSetOrder(1)
						//TPL_FILIAL + TPL_ORDEM + TPL_CODMOT + DTOS(TPL_DTINIC) + TPL_HOINIC + DTOS(TPL_DTFIM) + TPL_HOFIM
						If dbSeek( cKeyTPL )
							RecLock( "TPL", .F. )
							dbDelete()
							TPL->(MsUnLock())
						EndIf
					EndIf
				Next nIndOS
			EndIf //Fim Gravacao Motivos

			//Gravacao dos Insumo
			lAlteraSTL := .F.
			
			If ValType( aDadosOS[nLineOS,5] ) == "A"
				//Verifica se algo foi alterado
				nTemGar := aScan(aDadosTPZ, {|x| x[5]+x[6] == cOrdem+cPlano })

				If Len(aDadosOS[nLineOS,4]) <> Len( aDadosOS[nLineOS,5] ) .Or. nTemGar > 0
					lAlteraSTL := .T.
				Else
					For nXtmp := 1 to Len(aDadosOS[nLineOS,5])
						If Len(aDadosOS[nLineOS,4,nXtmp]) <> Len(aDadosOS[nLineOS,5,nXtmp])
							lAlteraSTL := .T.
							Exit
						EndIf
						If  Empty(aDadosOS[nLineOS,4,nXtmp,1]) .And. Empty(aDadosOS[nLineOS,4,nXtmp,3]) .And. Empty(aDadosOS[nLineOS,4,nXtmp,5]) .And. ;
						Empty(aDadosOS[nLineOS,5,nXtmp,1]) .And. Empty(aDadosOS[nLineOS,5,nXtmp,3]) .And. Empty(aDadosOS[nLineOS,5,nXtmp,5])
							Loop
						EndIf

						For nYtmp := 1 to Len(aDadosOS[nLineOS,5,nXtmp])
							If nYtmp == Len(aDadosOS[nLineOS,5,nXtmp]) - 1
								Loop
							EndIf

							If ValType(aDadosOS[nLineOS,5,nXtmp,nYtmp]) <> ValType(aDadosOS[nLineOS,4,nXtmp,nYtmp])
								lAlteraSTL := .T.
								Exit
							EndIf

							If aDadosOS[nLineOS,5,nXtmp,nYtmp] <> aDadosOS[nLineOS,4,nXtmp,nYtmp]
								lAlteraSTL := .T.
								Exit
							EndIf
						Next nYtmp

						If lAlteraSTL
							Exit
						EndIf
					Next nXtmp
				EndIf
			EndIf

			If lAlteraSTL

				lSerRef := AllTrim( STJ->TJ_SERVICO ) == SuperGetMV("MV_NGSERPN", .F., "")

				//Excluindo os insumos que foram retirados da tela
				dbSelectArea("STL")
				dbSetOrder(1)
				dbSeek(xFilial("STL")+cOrdem+cPlano)
				While !EoF() .And. xFilial("STL")+cOrdem+cPlano == STL->(TL_FILIAL+TL_ORDEM+TL_PLANO)
					If !Empty(STL->TL_SEQRELA) .And. Val(STL->TL_SEQRELA) > 0         .And. ;
					aScan(aDadosOS[nLineOS,5] ,{|x| x[nPos16]   == STL->TL_TAREFA  .And. x[nPos01]    == STL->TL_TIPOREG .And. ;
					x[nPos03] == STL->TL_CODIGO .And. x[nPos18] == STL->TL_SEQRELA .And. !ATail(x) }) == 0

						//Verificar se o insumo foi gerado atraves de uma requisicao do estoque e nao deleta
						If !lIntRM .And. STL->TL_ORIGNFE == "SD3" .Or. STL->TL_ORIGNFE == "SD1"
							dbSelectArea("STL")
							dbSkip()
							Loop
						ElseIf cUsaInt3 == 'S' .And. ; // integração com estoque
								lSerRef .And.; // serviço mov. pneu
								( nPosDOS := aScan(aDadosOS,{|x| Trim(Upper(x[1])) == cOrdemTJ}) ) > 0 .And.; // posição da ordem
								( nPosSav := aScan(aDadosOS[nPosDOS,4] ,{|x| ; // posição do insumo
											x[nPos01] == aCols[n][nPos01] .And.;
											x[nPos03] == aCols[n][nPos03] .And.;
											x[nPos18] == aCols[n][nPos18] }) ) > 0 .And.;
								aDadosOs[nPosDOS,4,nPosSav,nPos01] == 'P' .And. ; // insumo produto
								Val( aDadosOs[nPosDOS,4,nPosSav,nPos18] ) .And.; // insumo realizado
								ProdutoPn( aDadosOs[nPosDOS,4,nPosSav,nPos03],; // é um pneu
											aDadosOs[nPosDOS,4,nPosSav,nPos05], STJ->TJ_ORDEM )

							dbSelectArea("STL")
							dbSkip()
							Loop

						EndIf

						If !Empty(STL->TL_NUMSEQ)
							//Faz devoulucao para o estoque
							dbSelectArea("SD3")
							dbSetOrder(4)
							If dbSeek( xFilial( 'SD3' ) + STL->TL_NUMSEQ )

								aRetSD3 := MntGeraD3( 'DE1', , , .T., .F., .T. )

								If aRetSD3[2]

									If NGPRODESP( SD3->D3_COD, .F., 'M' )
										NGAtuErp( 'SD3', 'INSERT' )
									EndIf

								Else

									aAdd( aLogRM, { aRetSD3[3], STL->TL_ORDEM, STL->TL_PLANO, STL->TL_TAREFA,;
										STL->TL_TIPOREG, STL->TL_CODIGO, STL->TL_SEQRELA, STL->TL_NUMSEQ } )

									STL->( dbSkip() )
									Loop

								EndIf

							EndIf
						EndIf

						If STL->TL_TIPOREG == "P"
							//MOSTRA OS REGISTROS DO HISTORICO PARA EXECLUIR
							NGDELINSLAN( STJ->TJ_CODBEM, STL->TL_DTINICI, STL->TL_HOINICI )
						EndIf

						fNgGarDelete(cOrdem,cPlano,STL->TL_SEQRELA)

						dbSelectArea("STN")
						dbSetOrder(1)
						dbSeek( xFilial("STN") + STL->(TL_ORDEM+TL_PLANO+TL_TAREFA+TL_SEQRELA) )
						While !EoF() .And. STL->(TL_ORDEM + TL_PLANO + TL_TAREFA + TL_SEQRELA ) == STN->( TN_ORDEM + TN_PLANO + TN_TAREFA + TN_SEQRELA ) .And. ;
						xFilial("STN") == STN->TN_FILIAL

							RecLock("STN",.F.)
							dbDelete()
							STL->(MsUnLock())

							dbSelectArea("STN")
							dbSkip()
						EndDo

						dbSelectArea("STL")
						RecLock("STL",.F.)
						dbDelete()
						STL->(MsUnLock())
						If lMNTB4354
							ExecBlock("MNTB4354")
						EndIf
					EndIf

					dbSelectArea("STL")
					dbSetOrder(1)
					STL->(dbSkip())
				EndDo

				//Ordena pelo campo TL_SEQRELA
				aSort(aDadosOS[nLineOS,5],,,{|x,y| x[nPos18] < y[nPos18] })

				//Os registros deletados serão os primeiros da lista
				aSort(aDadosOS[nLineOS,5],,,{|x,y| x[Len(x)] .And. !y[Len(y)] })

				//Ultima Sequencia
				M->TL_ORDEM := cOrdem
				M->TL_PLANO := cPlano
				nNoSeqSTL   := ULTSEQ(RECNO())

				For nIndOS := 1 to Len(aDadosOS[nLineOS,5])
					//Verifica se o insumo foi gerado atraves do estoque e altera a tarefa
					dbSelectArea( "STL" )
					dbSetOrder( 02 ) //TL_FILIAL+TL_TIPOREG+TL_SEQRELA+TL_CODIGO+TL_ORDEM+TL_PLANO
					If dbSeek( xFilial( "STL" )+aDadosOS[nLineOS,5,nIndOS,nPos01]+aDadosOS[nLineOS,5,nIndOS,nPos18]+aDadosOS[nLineOS,5,nIndOS,nPos03]+cOrdem+cPlano)
						If ( STL->TL_ORIGNFE == "SD3" .Or. STL->TL_ORIGNFE == "SD1" ) .And. aDadosOS[nLineOS,5,nIndOS,nPos16] <> STL->TL_TAREFA
							RecLock( "STL",.F. )
							STL->TL_TAREFA := aDadosOS[nLineOS,5,nIndOS,nPos16]
							MsUnLock( "STL" )
							Loop
						ElseIf cUsaInt3 == 'S' .And. ; // integração com estoque
								lSerRef .And.; // serviço mov. pneu
								( nPosDOS := aScan(aDadosOS,{|x| Trim(Upper(x[1])) == cOrdemTJ}) ) > 0 .And.; // posição da ordem
								( nPosSav := aScan(aDadosOS[nPosDOS,4] ,{|x| ; // posição do insumo
											x[nPos01] == aCols[n][nPos01] .And.;
											x[nPos03] == aCols[n][nPos03] .And.;
											x[nPos18] == aCols[n][nPos18] }) ) > 0 .And.;
								aDadosOs[nPosDOS,4,nPosSav,nPos01] == 'P' .And. ; // insumo produto
								Val( aDadosOs[nPosDOS,4,nPosSav,nPos18] ) .And.; // insumo realizado
								ProdutoPn( aDadosOs[nPosDOS,4,nPosSav,nPos03],; // é um pneu
											aDadosOs[nPosDOS,4,nPosSav,nPos05], STJ->TJ_ORDEM )

							RecLock( "STL",.F. )
							STL->TL_TAREFA := aDadosOS[nLineOS,5,nIndOS,nPos16]
							STL->TL_DESTINO := aDadosOS[nLineOS,5,nIndOS,nPos02]
							MsUnLock( "STL" )
							Loop
						
						EndIf

						RecLock( "STL",.F. )
						STL->TL_ETAPA := aDadosOS[nLineOS,5,nIndOS,nPos20]
						MsUnLock( "STL" )
					EndIf

					If Empty(aDadosOS[nLineOS,5,nIndOS,nPos03]) //Nao validar se codigo vazio
						Loop
					EndIf

					cTIPOMAN := IIf( Val(STJ->TJ_PLANO) == 0, "C", "P")

					cKeySTL  := xFilial("STL")+cOrdem+cPlano
					cKeySTL  += aDadosOS[nLineOS,5,nIndOS,nPos16] + aDadosOS[nLineOS,5,nIndOS,nPos01]
					cKeySTL  += aDadosOS[nLineOS,5,nIndOS,nPos03] + aDadosOS[nLineOS,5,nIndOS,nPos18]

					//Se nao for deletado
					If !aDadosOS[nLineOS,5][nIndOS][Len(aDadosOS[nLineOS,5][nIndOS])]

						lProcSTL := .T.

						If lMNTA4353
							aTempAux := aClone(ExecBlock("MNTA4353",.F.,.F.,{.F.,aHoBrw6,aDadosOS[nLineOS,5][nIndOS]}))
							If aTempAux[1]
								nPosAux := aScan(aInsNaoGra, {|x| AllTrim(x[1])+AllTrim(x[2]) == AllTrim(aDadosOS[nLineOS][1])+AllTrim(aDadosOS[nLineOS][2])})
								If nPosAux == 0
									aAdd(aInsNaoGra,{aDadosOS[nLineOS][1], aDadosOS[nLineOS][2], {aTempAux[2]}})
								Else
									aAdd(aInsNaoGra[nPosAux][3], aTempAux[2])
								EndIf
								lProcSTL := .F.
							EndIf
						EndIf

						If lProcSTL
							lDelGarant := .F. //Indica se foi retirada a garantia
							lAltGarant := .F. //Indica se foi alterada a data da garantia
							lSTL_Lock  := .T.
							dbSelectArea("STL")
							dbSetOrder(1) //TL_FILIAL+TL_ORDEM+TL_PLANO+TL_TAREFA+TL_TIPOREG+TL_CODIGO+TL_SEQRELA
							If !Empty(aDadosOS[nLineOS,5,nIndOS,nPos18]) .And. Val(aDadosOS[nLineOS,5,nIndOS,nPos18]) > 0 //Se nao vazio TL_SEQRELA
								lSTL_Lock := !dbSeek(cKeySTL)
							EndIf

							RecLock("STL",lSTL_Lock)

							If !lSTL_Lock //Verifica se foi retirada a garantia na alteração do STL
								If STL->TL_GARANTI == "S" .And. aDadosOS[nLineOS,5,nIndOS,nPos15] == "N"
									lDelGarant := .T.
								EndIf
								dDtTmp01 := If(Empty(STL->TL_DTFIM),STL->TL_DTINICI,STL->TL_DTFIM)
								dDtTmp02 := If(Empty(aDadosOS[nLineOS,5,nIndOS,nPos08]),aDadosOS[nLineOS,5,nIndOS,nPos06],aDadosOS[nLineOS,5,nIndOS,nPos08])
								If dDtTmp01 <> dDtTmp02
									lAltGarant := .T.
								EndIf
							EndIf

							For nIndTL := 1 TO FCount()
								If Alltrim(FieldName(nIndTL)) $ "TL_FILIAL/TL_ORDEM/TL_PLANO/TL_REPFIM/TL_NUMSEQ/TL_SEQRELA/TL_OBSERVA/TL_USERLGI/TL_USERLGA"
									Loop
								EndIf

								nPosTmp := aScan(aHoBrw6, {|x| AllTrim(Upper(X[2])) == FieldName(nIndTL) })
								y  := "STL->" + FieldName(nIndTL)
								If nPosTmp > 0
									x  := "M->" + FieldName(nIndTL)
									&x.:= aDadosOS[nLineOS,5,nIndOS,nPosTmp]
									&y := &x
								ElseIf lSTL_Lock
									&y := CriaVar(FieldName(nIndTL))
								EndIf
							Next nIndTL

							STL->TL_FILIAL  := xFilial("STL")
							STL->TL_ORDEM   := cOrdem
							STL->TL_PLANO   := cPlano
							STL->TL_SEQRELA := aDadosOS[nLineOS,5,nIndOS,nPos18]
							STL->TL_REPFIM  := "S"
							STL->TL_USACALE := If(STL->TL_USACALE <> "S","N",STL->TL_USACALE)
							If STL->TL_TIPOREG <> "P"
								STL->TL_TIPOHOR := If(STL->TL_USACALE == "S","S", cNGUNIDT)
							Else
								STL->TL_TIPOHOR := cNGUNIDT
								STL->TL_DTFIM   := STL->TL_DTINICI
								STL->TL_HOFIM   := STL->TL_HOINICI
							EndIf

							If nPos19 > 0
								STL->TL_OBSERVA := aDadosOS[nLineOS,5,nIndOS,nPos19]
							EndIf

							// Caso o campo não esteja em tela, persiste o calculo e gravação.
							If nPos21 == 0
								STL->TL_CUSTO := Round( NGCALCUSTI( STL->TL_CODIGO, STL->TL_TIPOREG, STL->TL_QUANTID, STL->TL_LOCAL, , , , STL->TL_QUANREC, '1' ), 2 )
							EndIf

							STL->(MsUnLock())

							//PE para que seja possível alterar um insumo após a gravação da STL
							If lMNTA435I
								ExecBlock("MNTA435I",.F.,.F.)
							EndIf

							If STL->TL_GARANTI == "S" //Grava garantia
								nLineSA := aScan(aDadosTPZ, {|x| x[2] + x[3] == STL->TL_TIPOREG + STL->TL_CODIGO .And. ;
								x[5] + x[6] == STL->TL_ORDEM   + STL->TL_PLANO  .And. ;
								x[7]        == STL->TL_SEQRELA })

								If nLineSA > 0
									fNgGarInsert(nLineSA,cOrdem,cPlano,STL->TL_SEQRELA, If(Empty(STL->TL_DTFIM),STL->TL_DTINICI,STL->TL_DTFIM) )
								EndIf
							EndIf

							If lSTL_Lock //Incluir
								If cUsaInt3 == "S" .And. !lOSHESTO
									If STL->TL_TIPOREG $ "PM"
										If MNT435CANB() // Caso não haja bloqueio para a movimentação no estoque
											aAdd( aReqSD3 , { STL->(Recno()) , .F. } )
										EndIf
									EndIf
								EndIf
							Else
								If lDelGarant //Retira Garantia
									fNgGarDelete(cOrdem,cPlano,STL->TL_SEQRELA)
								EndIf
								If lAltGarant //Altera data da garantia
									fNgGarUpdate(cOrdem,cPlano,STL->TL_SEQRELA, If(Empty(STL->TL_DTFIM),STL->TL_DTINICI,STL->TL_DTFIM) )
								EndIf
								
								If cUsaInt3 == "S" .And. STL->TL_TIPOREG $ "PM" .And. !lOSHESTO
									
									nPosSav := aScan(aDadosOS[nLineOS,4] ,{|x|  x[nPos16] == aDadosOS[nLineOS,5,nIndOS,nPos16] .And. ;
									x[nPos01] == aDadosOS[nLineOS,5,nIndOS,nPos01] .And. ;
									x[nPos03] == aDadosOS[nLineOS,5,nIndOS,nPos03] .And. ;
									x[nPos18] == aDadosOS[nLineOS,5,nIndOS,nPos18] })
									lProSD3 := .T.
									If nPosSav > 0
										lProSD3 := .F.
										If aDadosOS[nLineOS,4,nPosSav,nPos10] <> STL->TL_QUANTID .Or. aDadosOS[nLineOS,4,nPosSav,nPos06] <> STL->TL_DTINICI .Or. ;
										aDadosOS[nLineOS,4,nPosSav,nPos05] <> STL->TL_LOCAL   .Or. aDadosOS[nLineOS,4,nPosSav,nPos12] <> STL->TL_LOTECTL .Or. ;
										aDadosOS[nLineOS,4,nPosSav,nPos11] <> STL->TL_NUMLOTE .Or. aDadosOS[nLineOS,4,nPosSav,nPos14] <> STL->TL_NUMSERI .Or. ;
										aDadosOS[nLineOS,4,nPosSav,nPos13] <> STL->TL_LOCALIZ

											lProSD3 := .T.
										EndIf
									EndIf

									If lProSD3
										If !Empty(STL->TL_NUMSEQ)
											//Faz devoulucao para o estoque
											dbSelectArea("SD3")
											dbSetOrder(4)
											If dbSeek( xFilial( 'SD3' ) + STL->TL_NUMSEQ )

												aRetSD3 := MntGeraD3( 'DE1', , , .T., .F., .T. )

												If aRetSD3[2]

													If NGPRODESP( SD3->D3_COD, .F., 'M' )
														NGAtuErp( 'SD3', 'INSERT' )
													EndIf

												Else

													aAdd( aLogRM, { aRetSD3[3], STL->TL_ORDEM, STL->TL_PLANO, STL->TL_TAREFA,;
														STL->TL_TIPOREG, STL->TL_CODIGO, STL->TL_SEQRELA, STL->TL_NUMSEQ } )
													Loop

												EndIf

											EndIf
										EndIf

										If MNT435CANB() // Caso não haja bloqueio para a movimentação no estoque
											aAdd( aReqSD3 , { STL->(Recno()) , nil } ) //Faz uma nova requisicao no estoque - MNTGERAD3("RE0")
										Else
											If !Empty(STL->TL_NUMSEQ)
												Reclock("STL", .F.)
												STL->TL_NUMSEQ := Space(Len(STL->TL_NUMSEQ))
												MsUnlock()
											EndIf
										EndIf

									EndIf
								
								EndIf
								
							EndIf
						EndIf
					Else
						If !Empty(aDadosOS[nLineOS,5,nIndOS,nPos18]) .And. Val(aDadosOS[nLineOS,5,nIndOS,nPos18]) > 0 //Se nao vazio TL_SEQRELA

							lProcSTL := .T.

							If lMNTA4353
								aTempAux := aClone(ExecBlock("MNTA4353",.F.,.F.,{.T.,aHoBrw6,aDadosOS[nLineOS,5][nIndOS]}))
								If aTempAux[1]
									nPosAux := aScan(aInsNaoGra, {|x| AllTrim(x[1])+AllTrim(x[2]) == AllTrim(aDadosOS[nLineOS][1])+AllTrim(aDadosOS[nLineOS][2]) })
									If nPosAux == 0
										aAdd(aInsNaoGra, { aDadosOS[nLineOS][1], aDadosOS[nLineOS][2], {aTempAux[2]} })
									Else
										aAdd(aInsNaoGra[nPosAux][3], aTempAux[2])
									EndIf
									lProcSTL := .F.
								EndIf
							EndIf

							//Excluir Registro
							If lProcSTL
								dbSelectArea("STL")
								dbSetOrder(1) //TL_FILIAL+TL_ORDEM+TL_PLANO+TL_TAREFA+TL_TIPOREG+TL_CODIGO+TL_SEQRELA
								If dbSeek(cKeySTL)
									If !Empty(STL->TL_NUMSEQ)
										//Faz devoulucao para o estoque
										dbSelectArea("SD3")
										dbSetOrder(4)
										If dbSeek(xFilial("SD3")+STL->TL_NUMSEQ)

											aRetSD3 := MntGeraD3( 'DE1', , , .T., .F., .T. )

											If aRetSD3[2]

												If NGPRODESP( SD3->D3_COD, .F., 'M' )
													NGAtuErp( 'SD3', 'INSERT' )
												EndIf

											Else

												aAdd( aLogRM, { aRetSD3[3], STL->TL_ORDEM, STL->TL_PLANO, STL->TL_TAREFA,;
													STL->TL_TIPOREG, STL->TL_CODIGO, STL->TL_SEQRELA, STL->TL_NUMSEQ } )
												Loop

											EndIf

										EndIf
									EndIf
									If STL->TL_TIPOREG == "P"
										//MOSTRA OS REGISTROS DO HISTORICO PARA EXECLUIR
										NGDELINSLAN(STJ->TJ_CODBEM,STL->TL_DTINICI,STL->TL_HOINICI)
									EndIf
									fNgGarDelete(cOrdem,cPlano,STL->TL_SEQRELA)

									dbSelectArea("STN")
									dbSetOrder(1)
									dbSeek( xFilial("STN") + STL->(TL_ORDEM+TL_PLANO+TL_TAREFA+TL_SEQRELA) )
									While !EoF() .And. STL->(TL_ORDEM+TL_PLANO+TL_TAREFA+TL_SEQRELA) == STN->(TN_ORDEM+TN_PLANO+TN_TAREFA+TN_SEQRELA) .And. ;
									xFilial("STN") == STN->TN_FILIAL

										RecLock("STN",.F.)
										dbDelete()
										STL->(MsUnLock())
										dbSkip()
									EndDo

									dbSelectArea("STL")
									RecLock("STL",.F.)
									dbDelete()
									STL->(MsUnLock())
									If lMNTB4354
										ExecBlock("MNTB4354")
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf

				Next nIndOS

				//Retoma a ordenção pelo campo TL_SEQRELA
				aSort( aDadosOS[nLineOS,5],,,{ |x,y| x[nPos18] < y[nPos18] } )

			EndIf //Fim gravacao insumos

			//Gravacao das Ocorrencias
			If ValType(aDadosOS[nLineOS,5]) == "A"

				For nIndOS := 1 to Len(aDadosOS[nLineOS,5])
					aArrayTmp := aDadosOS[ nLineOS,5,nIndOS, Len(aDadosOS[nLineOS,5,nIndOS])-1  ]
					If Valtype(aArrayTmp) <> "A" .Or. aDadosOS[ nLineOS,5,nIndOS, Len(aDadosOS[nLineOS,5,nIndOS]) ]
						Loop
					EndIf

					//Excluindo os motivos que foram retirados da tela
					//TN_FILIAL+TN_ORDEM+TN_PLANO+TN_TAREFA+TN_SEQRELA+TN_CODOCOR+TN_CAUSA+TN_SOLUCAO
					dbSelectArea("STN")
					dbSetOrder(1)
					dbSeek(xFilial("STN")+cOrdem+cPlano+aDadosOS[nLineOS,5,nIndOS,nPos16]+aDadosOS[nLineOS,5,nIndOS,nPos18])
					While !EoF() .And. xFilial("STN")+cOrdem+cPlano      == STN->(TN_FILIAL+TN_ORDEM+TN_PLANO) .And. ;
					aDadosOS[nLineOS,5,nIndOS,nPos16] == STN->TN_TAREFA .And. ;
					aDadosOS[nLineOS,5,nIndOS,nPos18] == STN->TN_SEQRELA

						If aScan(aArrayTmp ,{|x| x[nOcoCo] == STN->TN_CODOCOR .And. x[nOcoCa] == STN->TN_CAUSA .And. ;
						x[nOcoSo] == STN->TN_SOLUCAO .And. !x[Len(x)] }) == 0
							RecLock("STN",.F.)
							dbDelete()
							STN->(MsUnLock())
						EndIf

						dbSelectArea("STN")
						dbSkip()
					EndDo

					//Os registros deletados serão os primeiros da lista
					aSort(aArrayTmp,,,{|x,y| x[Len(x)] .And. !y[Len(y)] })
					For nIndOS2 := 1 to Len(aArrayTmp)

						If Empty(aArrayTmp[nIndOS2,nOcoCo]) //Nao validar se codigo vazio
							Loop
						EndIf

						cKeySTN := xFilial("STN")+cOrdem+cPlano+aDadosOS[nLineOS,5,nIndOS,nPos16]+aDadosOS[nLineOS,5,nIndOS,nPos18]
						cKeySTN += aArrayTmp[nIndOS2,nOcoCo] + aArrayTmp[nIndOS2,nOcoCa] + aArrayTmp[nIndOS2,nOcoSo]

						//Se nao for deletado
						If !aArrayTmp[nIndOS2][Len(aArrayTmp[nIndOS2])]

							lSTN_Lock := .T.
							dbSelectArea("STN")
							dbSetOrder(1)
							lSTN_Lock := !dbSeek(cKeySTN)
							RecLock("STN",lSTN_Lock)

							For nIndSTN := 1 TO FCount()
								If Alltrim(FieldName(nIndSTN)) $ "TN_FILIAL/TN_ORDEM/TN_PLANO/TN_TAREFA/TN_SEQRELA"
									Loop
								EndIf
								nPosTmp := aScan(aHoBrw3, {|x| AllTrim(Upper(X[2])) == FieldName(nIndSTN) })
								y  := "STN->" + FieldName(nIndSTN)
								If nPosTmp > 0
									x  := "M->" + FieldName(nIndSTN)
									&x.:= aArrayTmp[nIndOS2,nPosTmp]
									&y := &x
								ElseIf lSTN_Lock
									&y := CriaVar(FieldName(nIndSTN))
								EndIf
							Next nIndSTN
							STN->TN_FILIAL  := xFilial("STN")
							STN->TN_ORDEM   := cOrdem
							STN->TN_PLANO   := cPlano
							STN->TN_TAREFA  := aDadosOS[nLineOS,5,nIndOS,nPos16]
							STN->TN_SEQRELA := aDadosOS[nLineOS,5,nIndOS,nPos18]
							STN->(MsUnLock())
						Else

							dbSelectArea("STN")
							dbSetOrder(1)
							If dbSeek(cKeySTN)
								RecLock("STN",.F.)
								dbDelete()
								STN->(MsUnLock())
							EndIf

						EndIf

					Next nIndOS2
				Next nIndOS

			EndIf//Fim Gravacao das Ocorrencias

			//Gerar SA
			If Len(aDadosSA) > 0
				nLineSA := aScan(aDadosSA, {|x|x[1]+x[2] == cOrdem+cPlano })
				If nLineSA > 0
					For nxSA := nLineSA To Len(aDadosSA)
						//Se terminar as SA da OS
						If aDadosSA[nxSA,1]+aDadosSA[nxSA,2] != cOrdem+cPlano
							Exit
						EndIf

						//Se estiver deletado
						If !aDadosSA[nxSA,13]
							Loop
						EndIf

						nItemSA++

						dbSelectArea("SCP")
						If nItemSA > 99
							nItemSA := 1
							cNumSA  := " "
						EndIf

						RecLock("SCP",.T.)
						SCP->CP_FILIAL  := xFilial("SCP")

						If Empty(cNumSA)
							cNumSA := GetSxeNum("SCP","CP_NUM")
							ConfirmSX8()
						EndIf
						SCP->CP_NUM     := cNumSA
						SCP->CP_ITEM    := StrZero(nItemSA,2)
						SCP->CP_PRODUTO := aDadosSA[nxSA,03]
						SCP->CP_UM      := aDadosSA[nxSA,04]
						SCP->CP_QUANT   := aDadosSA[nxSA,05]
						SCP->CP_DATPRF  := aDadosSA[nxSA,06]
						SCP->CP_LOCAL   := aDadosSA[nxSA,07]
						SCP->CP_OP      := aDadosSA[nxSA,08]
						SCP->CP_CC      := aDadosSA[nxSA,09]
						SCP->CP_EMISSAO := aDadosSA[nxSA,10]
						SCP->CP_DESCRI  := aDadosSA[nxSA,11]
						SCP->CP_SOLICIT := aDadosSA[nxSA,12]

						SCP->(MsUnLock())

						//Mensagem Unica
						If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"
							If cNGMNTAS == "1"
								cNumCP := SCP->CP_NUM
							Else
								NGMUReques(SCP->(RecNo()),"SCP",.F.,3)
							EndIf
						EndIf

					Next nxSA
				Endif

				If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"
					If cNGMNTAS == "1"
						If !Empty(cNumCP) .And. NGIFDBSEEK( "SCP",cNumCP,01,.F. )
							NGMUReques( SCP->( RecNo()),"SCP",.F.,3 )
						EndIf
					EndIf
				EndIf
			EndIf//Fim Geracao SA

			//Gravacao das Etapas
			If ValType(aDadosOS[nLineOS,8]) == "A"

				//Excluindo as etapas que foram retirados da tela
				dbSelectArea("STQ")
				dbSetOrder(1)
				dbSeek( xFilial("STQ") + cOrdem + cPlano )
				While !EoF() .And. xFilial("STQ") + cOrdem + cPlano == STQ->( TQ_FILIAL + TQ_ORDEM + TQ_PLANO )

					If aScan(aDadosOS[nLineOS,8] ,{|x| x[nEtaTa] == STQ->TQ_TAREFA .And. x[nEtapa] == STQ->TQ_ETAPA }) == 0
						dbSelectArea("TPQ")
						dbSetOrder(1)
						If dbSeek( xFilial("TPQ") + cOrdem + cPlano + STQ->TQ_TAREFA + STQ->TQ_ETAPA )
							While !EoF() .And. TPQ->TPQ_FILIAL == xFilial("TPQ") .And.;
							TPQ->TPQ_ORDEM == cOrdem .And. TPQ->TPQ_PLANO == cPlano .And.;
							TPQ->TPQ_TAREFA == STQ->TQ_TAREFA .And. TPQ->TPQ_ETAPA  == STQ->TQ_ETAPA

								RecLock("TPQ", .F.)
								dbDelete()
								TPQ->( MsUnLock() )

								dbSelectArea("TPQ")
								dbSkip()
							EndDo
						EndIf

						RecLock("STQ",.F.)
						dbDelete()
						STQ->(MsUnLock())
					EndIf

					dbSelectArea("STQ")
					dbSkip()
				EndDo

				For nIndOS := 1 to Len(aDadosOS[nLineOS,8])
					aVetTemp := aDadosOS[nLineOS,8,nIndOS]
					nPosArray := aScan(aVetTemp, {|x| ValType(x) == "A" })
					If Empty(aVetTemp[nEtaTa]) .And. Empty(aVetTemp[nEtapa])
						Loop
					EndIf

					cORDSTJ := STJ->TJ_ORDEM
					cPLASTJ := STJ->TJ_PLANO
					cBEMSTJ := STJ->TJ_CODBEM
					cSERSTJ := STJ->TJ_SERVICO
					nSEQSTJ := STJ->TJ_SEQRELA
					nSEQOLD := STJ->TJ_SEQRELA
					cBEMOLD := STJ->TJ_CODBEM
					cSEROLD := STJ->TJ_SERVICO

					nSEQSTJ := nSEQOLD
					dbSelectArea("STQ")
					dbSetOrder(1)
					If !dbSeek(xFilial("STQ")+cOrdem+cPlano+aVetTemp[nEtaTa]+aVetTemp[nEtapa] + aVetTemp[nEtSTar])
						RecLock("STQ",.T.)

						For i := 2 To Len(aTRBQ)
							If !( Alltrim(aTRBQ[i][1]) $ "TQ_FILIAL/TQ_ORDEM/TQ_PLANO/TQ_TAREFA/TQ_ETAPA/TQ_OK" ) .And. Posicione("SX3",2,aTRBQ[i, 1] ,"X3_CONTEXT") != "V"
								xx := Alltrim(aTRBQ[i][1])
								&("STQ->"+xx) := aVetTemp[i]
							EndIf
						Next i

						STQ->TQ_FILIAL  := xFilial("STQ")
						STQ->TQ_ORDEM   := cOrdem
						STQ->TQ_PLANO   := cPlano
						STQ->TQ_TAREFA  := aVetTemp[nEtaTa]
						STQ->TQ_ETAPA   := aVetTemp[nEtapa]
						STQ->TQ_OK      := aVetTemp[1]
						STQ->(MsUnLock())
					Else
						RecLock("STQ",.F.)
						For i := 2 To Len(aTRBQ)

							If !( Alltrim(aTRBQ[i][1]) $ "TQ_FILIAL/TQ_ORDEM/TQ_PLANO/TQ_TAREFA/TQ_ETAPA/TQ_OK" ) .And. Posicione("SX3",2,aTRBQ[i, 1] ,"X3_CONTEXT") != "V"
								xx := Alltrim(aTRBQ[i][1])
								&("STQ->"+xx) := aVetTemp[i]
							EndIf
						Next i
						STQ->TQ_OK      := aVetTemp[1]
						STQ->(MsUnLock())
					EndIf

					fLegendEt(STQ->TQ_TAREFA+STQ->TQ_ETAPA+STQ->TQ_SEQETA)
					oBrw4:oBrowse:Refresh()
					oBrw4:oBrowse:Refresh()

					//Opções de resposta das etapas. Verifica se house marcação anteriormente
					aArray  := {}
					aArray2 := {}
					If Empty(aVetTemp[1])
						dbSelectArea("TPQ")
						dbSetOrder(1)
						dbSeek(xFilial("TPQ")+cOrdem+cPlano+aVetTemp[nEtaTa]+aVetTemp[nEtapa])
						While !EoF() .And. TPQ->TPQ_FILIAL == xFilial("TPQ") .And.;
						TPQ->TPQ_ORDEM == cOrdem .And. TPQ->TPQ_PLANO == cPlano .And. ;
						TPQ->TPQ_TAREFA == aVetTemp[nEtaTa] .And. TPQ->TPQ_ETAPA  == aVetTemp[nEtapa]

							RecLock("TPQ",.F.)
							dbDelete()
							TPQ->(MsUnLock())
							dbSelectArea("TPQ")
							dbSkip()
						EndDo
					Else

						//Excluindo as opções retiradas da tela
						dbSelectArea("TPQ")
						dbSetOrder(1)
						dbSeek(xFilial("TPQ") + cOrdem + cPlano + aVetTemp[nEtaTa] + aVetTemp[nEtapa])
						While !EoF() .And. TPQ->TPQ_FILIAL == xFilial("TPQ") .And.;
						TPQ->TPQ_ORDEM == cOrdem .And. TPQ->TPQ_PLANO == cPlano .And. ;
						TPQ->TPQ_TAREFA == aVetTemp[nEtaTa] .And. TPQ->TPQ_ETAPA  == aVetTemp[nEtapa]

							If aScan(aVetTemp[nPosArray] ,{|x| !Empty(x[1]) .And. x[2] == TPQ->TPQ_OPCAO }) == 0
								dbSelectArea("TPQ")

								RecLock("TPQ",.F.)
								dbDelete()
								TPQ->(MsUnLock())
							EndIf

							dbSelectArea("TPQ")
							dbSkip()
						EndDo

						lPrimVez := .T.
						For nXX := 1 To Len(aVetTemp[nPosArray])

							If Empty( aVetTemp[nPosArray , nXX , 1] )
								Loop
							EndIf

							nSEQSTF   := nSEQOLD
							cBEMSTJ   := cBEMOLD
							lTpGeraOS := .F.
							lTPGeraSS := .F.

							cTpcMark   := aVetTemp[nPosArray,nXX,1]
							cTpcRespos := aVetTemp[nPosArray,nXX,3]
							cTpcOpcao  := aVetTemp[nPosArray,nXX,2]

							dbSelectArea("TPC")
							dbSetOrder(1)
							If !dbSeek(xFilial("TPC") + aVetTemp[nEtapa] + cTpcOpcao )
								Loop
							EndIf

							lAltTPQ := .F. //Indica se a Resposta da Etapa é nova ou foi modificada
							lTPQ_OS := .F. //Indica se a Resposta da Etapa que está sendo modificada, já tinha gerado OS antes
							lGerTPQ := .F. //Indica se a Resposta da Etapa que está sendo modificada não deve gerar OS

							dbSelectArea("TPQ")
							dbSetOrder(1)
							If !dbSeek(xFilial("TPQ")+ cOrdem+ cPlano+ aVetTemp[nEtaTa]+ aVetTemp[nEtapa]+ cTpcOpcao )
								RecLock("TPQ",.T.)
								TPQ->TPQ_FILIAL := xFilial("TPQ")
								TPQ->TPQ_ORDEM  := cOrdem
								TPQ->TPQ_PLANO  := cPlano
								TPQ->TPQ_TAREFA := aVetTemp[nEtaTa]
								TPQ->TPQ_ETAPA  := aVetTemp[nEtapa]
								TPQ->TPQ_OPCAO  := cTpcOpcao
								TPQ->TPQ_RESPOS := cTpcRespos
								TPQ->TPQ_OK     := cTpcMark
								TPQ->(MsUnLock())
								lAltTPQ := .T.
							Else
								RecLock("TPQ",.F.)
								If Alltrim(TPQ->TPQ_RESPOS) <> Alltrim(cTpcRespos)
									lAltTPQ := .T.
									If !Empty(TPQ->TPQ_ORDEMG)
										lTPQ_OS := .T.
									EndIf
								EndIf
								TPQ->TPQ_RESPOS := cTpcRespos
								TPQ->TPQ_OK     := cTpcMark
								TPQ->(MsUnLock())
							EndIf

							cSerSTJ := TPC->TPC_SERVIC

							If TPC->TPC_TPMANU == '1'
								lTpGeraOS := .T.
								cTipoMan  := NGSEEK( "ST4", TPC->TPC_SERVIC, 1, "T4_TIPOMAN")
								cServCar  := NGSEEK( "STE", cTipoMan, 1, "TE_CARACTE")

							ElseIf TPC->TPC_TPMANU == '2'
								lTPGeraSS := .T.
							EndIf

							//Identificação da geração da Ordem
							If TPC->TPC_PORBEM == '2'
								cBemOr := Space( TAMSX3("T9_CODBEM")[1] )

								If !Empty(TPC->TPC_DESCRI)

									cBemOr := SubStr( TPC->TPC_DESCRI, 1, TAMSX3("T9_CODBEM")[1] )

									dbSelectArea("ST9")
									dbSetOrder(1)
									If !dbSeek(xFilial("ST9") + cBEMOR)
										cBemOr := Space( TAMSX3("T9_CODBEM")[1] )
									Else
										If lTpGeraOS
											If cServCar == 'P' // O.S. Preventiva
												nSeqSTJ := IIf( Alltrim(nSeqSTJ) == "0", "1  ", nSeqSTJ )
												dbSelectArea("STF")
												dbSetOrder(1)
												If !dbSeek(xFilial("STF") + cBemOr + cSerSTJ + nSeqSTJ)
													cBemOr := Space( TAMSX3("T9_CODBEM")[1] )
												EndIf
											EndIf
										EndIf
									EndIf
								EndIf
								cBemSTJ := IIf( Empty(cBemOr), cBemSTJ, cBemOr )
							EndIf

							//Processa a geração de O.S.
							If !NG400VALOS(,TPC->TPC_SERVIC, .T.)
								If TPC->TPC_TIPRES == '2' .And. lAltTPQ // INFORMADA
									If !Empty(cTpcRespos)

										dbSelectArea("TPC")
										dbSetOrder(1)
										If dbSeek( xFilial("TPC") + aVetTemp[nEtapa] + cTPCOpcao )

											lCondicao := .F.

											Do Case
												Case TPC->TPC_TIPCAM == "L"
												cResp := AllTrim( cTpcRespos )
												Case TPC->TPC_TIPCAM == "N"
												cResp := cValToChar( Val( cTpcRespos ) )
												Case TPC->TPC_TIPCAM == "D"
												cResp := "'" + DToS( cToD( cTpcRespos ) ) + "'"
												Case TPC->TPC_TIPCAM == "C"
												cResp := "'" + AllTrim( cTpcRespos ) + "'"
											EndCase

											cForm := StrTran( TPC->TPC_FORMUL, '#RESP#', cResp )

											lCondicao := &( cForm )
										EndIf
									EndIf
								EndIf

								If lCondicao .Or. ( TPC->TPC_TIPRES == '1' .And. lAltTPQ )
									xx := aScan(aArray, {|x|(x[1]+x[2]) == cTpcOpcao + aVetTemp[nEtaTa] })
									xy := aScan(aArray2,{|x|(x[1]+x[2]) == cTpcRespos + aVetTemp[nEtaTa] })

									If lTPGeraOs
										If cServCar $ "P/O" .And. xx == 0  .And. xy == 0

											//--inicio--OS 024720 //
											/*
											Verifica se é a primeira que está passando por esse for.
											Caso for, lPrimVez se torna false para o proximo loop, assim como
											cChavAnt recebe a chave atual do OS. (Codigo do Bem e Serviço).
											Caso não seja a primeira vez, irá verificar se a chave atual é a mesma
											que a chave anterior, caso seja, considerará que está repetindo a OS, setando
											para True a váriavel lOSRepet, para que não faça a inclusão de uma nova OS
											para a mesma chave.
											Casa não seja a mesma chave a ser gerada, lOSRepet recebe False, para fazer
											uma nova inclusão de OS. E a chave atual se torna a chave anterior.
											Logica feita tanto para OSs Preventivas, quanto para Corretivas.
											SS: 024720
											Autor: Maicon André Pinheiro
											Data 11/02/2016
											*/
											If lPrimVez
												lPrimVez := .F.
												cChavAnt := STJ->TJ_CODBEM+STJ->TJ_SERVICO
											Else

												If STJ->TJ_CODBEM+STJ->TJ_SERVICO == cChavAnt
													lOSRepet := .T.
												Else
													lOSRepet := .F.
													cChavAnt := STJ->TJ_CODBEM+STJ->TJ_SERVICO
												EndIf
											EndIf
											//---fim----OS 024720 //

											//Deve gerar OS
											lGerTPQ := .T.

											//Se nao tinha gerado OS
											If !lTPQ_OS .And. lOSRepet == .F.
												cVPREVEN := fNG435GPRE( '2', cOrdem, nEtaTa, nEtapa, cServCar)
												If cVPREVEN[1]
													dbSelectArea("TPQ")
													dbSetOrder(1)
													If dbSeek(xFilial("TPQ") + cOrdem + cPlano + aVetTemp[nEtaTa] + aVetTemp[nEtapa] + cTpcOpcao )
														RecLock("TPQ", .F.)
														TPQ->TPQ_ORDEMG := cVPREVEN[2]
														TPQ->(MsUnLock())
													EndIf
												EndIf
											EndIf
										ElseIf cServCar == "C" .And. xx == 0  .And. xy == 0

											//--inicio--OS 024720 //
											If lPrimVez
												lPrimVez := .F.
												cChavAnt := STJ->TJ_CODBEM+STJ->TJ_SERVICO
											Else

												If STJ->TJ_CODBEM+STJ->TJ_SERVICO == cChavAnt
													lOSRepet := .T.
												Else
													lOSRepet := .F.
													cChavAnt := STJ->TJ_CODBEM+STJ->TJ_SERVICO
												EndIf
											EndIf
											//---fim----OS 024720 //

											//Deve gerar OS
											lGerTPQ := .T.

											//Se não tinha gerado OS
											If !lTPQ_OS .And. lOSRepet == .F.
												cVOSCORR := fNG435GCOR( '2', cOrdem, nEtaTa, nEtapa, cServCar)
												If cVOSCORR[1]
													dbSelectArea("TPQ")
													dbSetOrder(1)
													If dbSeek(xFilial("TPQ") + cOrdem + cPlano + aVetTemp[nEtaTa] + aVetTemp[nEtapa]+ cTpcOpcao )
														RecLock("TPQ", .F.)
														TPQ->TPQ_ORDEMG := cVOSCORR[2]
														TPQ->(MsUnLock())
													EndIf
												EndIf
											EndIf
										EndIf
									ElseIf lTPGeraSS

										cMsgSS := STR0044 + ": " + STJ->TJ_ORDEM + Chr(13) + Chr(10)		//"O.S. Origem"
										cMsgSS += STR0025 + ": " + aVetTemp[nEtapa] + Chr(13) + Chr(10)	//"Etapa"
										cMsgSS += STR0045 + ": " + cTpcOpcao + Chr(13) + Chr(10)			//"Opção"

										If TPC->TPC_TIPRES == '2'
											cMsgSS += STR0047 + ": " + cTpcRespos //"Resposta"
										Else
											cMsgSS += STR0048 + ": " + STR0049 //"Marcou" ## "Sim"
										EndIf

										If lMNTA435M
											cMsgSS += ExecBlock( "MNTA435M",.F.,.F.,{ cMsgSS, STJ->TJ_CODBEM, STJ->TJ_ORDEM, STJ->TJ_PLANO, ;
																					aVetTemp[nEtaTa], aVetTemp[nEtapa], aVetTemp[nEtSeq] } )
										EndIf

										// aSolic := { Código do Bem, Ramal, Descrição da Solicitação, Serviço }
										aSolic := { { "TQB_CODBEM", cBemSTJ, Nil },;
										{ "TQB_RAMAL" , "0000", Nil },;
										{ "TQB_DESCSS", cMsgSS, Nil },;
										{ "TQB_CDSERV", TPC->TPC_SERVIC, Nil } }

										lMSHelpAuto := .T. // Não apresenta erro em tela
										lMSErroAuto := .F. // Caso a variável torne-se .T. apos MsExecAuto, apresenta erro em tela

										MSExecAuto( {|x,z,y,w| MNTA280(x,z,y,w)},,, aSolic )

										If lMsErroAuto
											MostraErro()

										ElseIf !Empty( TQB->TQB_SOLICI )
											MsgInfo( STR0271 ) //"Foi gerada uma S.S. conforme a resposta da etapa!"

											dbSelectArea("TPQ")
											dbSetOrder(01)
											If dbSeek( xFilial("TPQ") + cOrdem + cPlano + aVetTemp[nEtaTa] + aVetTemp[nEtapa] + cTpcOpcao )
												RecLock( "TPQ", .F.)
												TPQ->TPQ_ORDEMG := TQB->TQB_SOLICI
												MsUnlock("TPQ")
											EndIf
										EndIf
									EndIf
								EndIf
							EndIf

							If !lGerTPQ //Se esta Resposta não deve gerar OS
								If lTPQ_OS //Se esta Resposta gerou OS anteriormente
									dbSelectArea("TPQ")
									dbSetOrder(01)
									If dbSeek(xFilial("TPQ") + cOrdem + cPlano + aVetTemp[nEtaTa] + aVetTemp[nEtapa] + cTpcOpcao )
										RecLock("TPQ",.F.)
										TPQ->TPQ_ORDEMG := Space( TAMSX3("TPQ_ORDEMG")[1] )
										TPQ->(MsUnLock())
									EndIf
								EndIf
							EndIf

						Next nXX //Fim laço das opções da etapa/tarefa
					EndIf //Fim se estiver concluido etapa/tarefa
				Next nIndOS //Fim laço etapa/tarefa
			EndIf

			//Retira da getdados os registros deletados
			If lRefBrow .And. ValType(aDadosOS[nLineOS,5]) == "A"

				aTmpCol := aClone( aDadosOS[nLineOS, 5] )
				aDadosOS[nLineOS,5] := {}

				//Inclue no array de insumos, somente os que não estão deletados
				For nIndOS := 1 to Len( aTmpCol )

					If !aTmpCol[nIndOS, Len( aTmpCol[nIndOS] )]
						aAdd( aDadosOS[nLineOS,5] , aClone( aTmpCol[nIndOS] ) )
					EndIf

				Next nIndOS

				//Caso algum insumo tenha apresentado erro ao ser deletado, este será mantido no array de insumos.
				If !Empty( aLogRM )

					For nErro := 1 to Len( aLogRM )

						If aDadosOS[nLineOS, 1] == aLogRM[nErro, 2] .And. aDadosOS[nLineOS, 2] == aLogRM[nErro, 3]

							nFound  := aScan( aTmpCol, { |x| x[nPos18] == aLogRM[nErro, 7] } )

							If nFound > 0 .And. aScan( aDadosOS[nLineOS,5], { |x| x[nPos18] == aLogRM[nErro, 7] } ) == 0

								//Armazena posição do insumo e o array do insumo para que este não seja copiado para o array de insumos já gravados
								aNoCopy := { nFound, aDadosOS[nLineOS, 4, nFound] }

								aAdd( aDadosOS[nLineOS,5] , aClone( aTmpCol[nFound] ) )

							EndIf

						EndIf

					Next nErro

				EndIf

				// Reordena aCols conforme TL_SEQRELA
				If nPos18 > 0
					aSort( aDadosOS[nLineOS,5],,, { |x,y| x[nPos18] < y[nPos18] } )
				EndIf

				//Faz a copia do conteudo do Array de insumos alterados [5] para o array de insumos já gravados [4]
				If Len(aDadosOS[nLineOS,5]) > 0

					/*-----------------------------------------------------------------------------------+
					| Em caso de inconsitência nos processos a seguir, o array de controle é restaurado. |
					+-----------------------------------------------------------------------------------*/
					aAdd( aRollBack, { nLineOS, aClone( aDadosOS[nLineOS] ) } )

					aDadosOS[nLineOS,4] := aClone(aDadosOS[nLineOS,5])

					//Caso tenha algum que não pode ser gavado efetivamente, retorna o backup da posição correta do insumo.
					If !Empty( aNoCopy )

						//Importante que para o funcionamento os arrays estejam ordenados por TL_SEQRELA.
						For nCopy := 1 To Len( aNoCopy )

							aDadosOS[nLineOS, 4, aNoCopy[1]] := aClone( aNoCopy[2] )

						Next nCopy

					EndIf

				Else
					
					/*-----------------------------------------------------------------------------------+
					| Em caso de inconsitência nos processos a seguir, o array de controle é restaurado. |
					+-----------------------------------------------------------------------------------*/
					aAdd( aRollBack, { nLineOS, aDadosOS[nLineOS] } )

					If Valtype(aNovoSTL) == "A"
						aDadosOS[nLineOS,4] := aClone(aNovoSTL)
					Else
						aDadosOS[nLineOS,4] := BLANKGETD(aHoBrw6)
					EndIf
					aDadosOS[nLineOS,5] := Nil
				EndIf

			EndIf

			dbSelectArea("STJ")
			dbSetOrder(01)
			If dbSeek(xFilial("STJ")+cOrdem+cPlano)
				NG400PROC(cOrdem+cPlano)
				vVetRCor := NGCOROSLENG()
				aOS[nX,1] := vVetRCor[1]
			EndIf

		Next nX

		//Executa as requisicoes de uma so vez
		For nX := 1 To Len(aReqSD3)
			dbSelectArea("STL")
			dbSetOrder(1)
			dbGoTo(aReqSD3[nX,1])
			If !EoF() .And. !Bof()
				// Posicionamento na STJ exigido, devido ao processo de gravacao da função MNTGERAD3
				If NGIFDBSEEK("STJ",STL->TL_ORDEM + STL->TL_PLANO,1)

					aRetSD3 := MntGeraD3( 'RE0', aReqSD3[nX,2], , .T., .F., .T. )

					If aRetSD3[2]

						dbSelectArea( 'STL' )
						RecLock( 'STL', .F. )

							STL->TL_NUMSEQ := aRetSD3[1]
							STL->TL_CUSTO  := SD3->D3_CUSTO1

							If lMMoeda
								STL->TL_MOEDA := '1'
							EndIf

						STL->( MsUnLock() )

						If NGPRODESP( SD3->D3_COD, .F., 'M' )
							NGAtuErp( 'SD3', 'INSERT' )
						EndIf

					Else

						aAdd( aLogRM, { aRetSD3[3], STL->TL_ORDEM, STL->TL_PLANO, STL->TL_TAREFA,;
										STL->TL_TIPOREG, STL->TL_CODIGO, STL->TL_SEQRELA, STL->TL_NUMSEQ } )

						If lRefBrow
							
							nPosArr := aScan( aRollBack, { |x| x[2,1] == STL->TL_ORDEM } )

							aDadosOS[aRollBack[nPosArr,1],4] := aClone( aRollBack[nPosArr,2,4] )
						
						EndIf

						Loop

					EndIf

				EndIf
			EndIf
		Next nX

		//Retira da getdados os registros deletados
		If lRefBrow

			aTmpCol := aClone( aCoBrw6 )
			aCoBrw6 := {}

			For nX := 1 To Len( aTmpCol )

				If !aTmpCol[nX,Len(aTmpCol[nX])]
					aAdd( aCoBrw6, aClone( aTmpCol[nX] ) )
				EndIf

			Next nX

			//Caso algum registro não pode ser deletado, ele retorno com a mesma condição.
			If !Empty( aLogRM )

				For nErro := 1 to Len( aLogRM )

					If cOrdem == aLogRM[nErro, 2] .And. cPlano == aLogRM[nErro, 3]

						nFound := aScan( aTmpCol, { |x| x[nPos18] == aLogRM[nErro, 7] } )

						If nFound > 0
							aAdd( aCoBrw6 , aClone( aTmpCol[nFound] ) )
						EndIf

					EndIf

				Next nErro

			EndIf

			// Reordena aCols conforme TL_SEQRELA
			If nPos18 > 0
				aSort( aCoBrw6,,, { |x,y| x[nPos18] < y[nPos18] } )
			EndIf

			If Len(aCoBrw6) == 0
				If Valtype(aNovoSTL) == "A"
					aCoBrw6 := aClone(aNovoSTL)
				Else
					aCoBrw6 := BLANKGETD(aHoBrw6)
				EndIf
				// propriedade que valida se foi alterado utilizada no linok
				oBrw6:lModified := .F.
			EndIf

			If oBrw6:lModified .And. Len( aCoBrw6 ) != Len( aTmpCol )
				// propriedade que valida se foi alterado utilizada no linok
				oBrw6:lModified := .F.
			EndIf

			If nPosGrt > 0 .And. Len(aCols) > 0

				If Len(aCols[1]) >= nPosGrt

					aTmpCol := aClone( aCols )
					aCols   := {}

					For nX := 1 To Len( aTmpCol )

						If !aTmpCol[nX,Len( aTmpCol[nX] )]
							aAdd( aCols , aClone( aTmpCol[nX] ) )
						EndIf
					Next nX

					//Caso algum registro não pode ser deletado, ele retorno com a mesma condição.
					If !Empty( aLogRM )

						For nErro := 1 to Len( aLogRM )

							If cOrdem == aLogRM[nErro, 2] .And. cPlano == aLogRM[nErro, 3]

								nFound := aScan( aTmpCol, { |x| x[nPos18] == aLogRM[nErro, 7] } )

								If nFound > 0
									aAdd( aCols , aClone( aTmpCol[nFound] ) )
								EndIf

							EndIf

						Next nErro

					EndIf

					// Reordena aCols conforme TL_SEQRELA
					If nPos18 > 0
						aSort( aCols,,, { |x,y| x[nPos18] < y[nPos18] } )
					EndIf

					If Len(aCols) == 0
						If Valtype(aNovoSTL) == "A"
							aCols := aClone(aNovoSTL)
						Else
							aCols := BLANKGETD(aHoBrw6)
						EndIf
						// propriedade que valida se foi alterado utilizada no linok
						oBrw6:lModified := .F.
					EndIf

					If oBrw6:lModified .And. Len( aCols ) != Len( aTmpCol )
						// propriedade que valida se foi alterado utilizada no linok
						oBrw6:lModified := .F.
					EndIf

				EndIf
			EndIf

			oBrw6:oBrowse:nAt := 1
			oBrw6:oBrowse:Refresh()
			oBrw6:oBrowse:SetFocus()
		EndIf

		// Apresentação em lote de inconsitências encontradas.
		If !Empty( aLogRM ) .Or. !Empty( aLogNoCanc )
			
			MNTA435Log( aLogRM, aLogNoCanc )

			DisarmTransaction()
			lRet := .F.

		EndIf

	End Transaction

	If ExistBlock("MNTA4354")
		ExecBlock("MNTA4354",.F.,.F.,{aHoBrw6,aInsNaoGra})
	EndIf

	CursorArrow()

	/*-----------------------------------------------------
	Mostra browse com as OS geradas atraves das etapas
	-----------------------------------------------------*/
	dbSelectArea(cTRBZ400)
	dbGoTop()
	If !EoF()
		aTRBZ := aClone(aTRBZ435)
		NGMOSTTRBZ()
	EndIf

	dbSelectArea(cTRBK400)
	dbGotop()
	If Reccount() > 0
		NGTRBKMOST()
	EndIf

	//Deleção Tabela Temporária
	oTmpTbl1:Delete()
	oTmpTbl2:Delete()

	lFoiAlterado := .F.

	aProd435   := {} //Produtos atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
	aLote435   := {} //LOTE atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
	aSubL435   := {} //SUB-LOTE atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
	aEnde435   := {} //ENDERECAMENTO atualizados na rotina. Array utilizado para verificação final do estoque antes de gravar
	aDadosTPZ  := {} //Garantia de Insumos Temporario
	aNBaixaEst := {} //Insumos que não efetuarão baixa no estoque - Ponto de Entrada MNT4356

	PutFileInEof("STL")
	PutFileInEof("STN")
	PutFileInEof("TPL")

	//Não deve carregar os insumos quando clicado nos botões 'oBtOK', 'oBtCOS', 'oBtFOS'
	If lLoadIns
		LoadInsum(M->TJ_ORDEM, M->TJ_PLANO, aScan(aDadosOS, {|x| x[1] + x[2] == M->TJ_ORDEM + M->TJ_PLANO }), oBrw6:oBrowse:nAt)
	EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³fNG435GPRE³ Autor ³ Denis                 ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Consiste e gera O.S. preventiva                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA400                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fNG435GPRE( cTipoEta, cOrdem, nEtaTa, nEtapa, cServCar)

	Local cVINCLUIOS := { .F., Space( TAMSX3("TJ_ORDEM")[1] ) }
	Local nSEQTP1    := nSEQSTJ
	Local nSEQPOS    := nSEQSTJ
	Local aAreaXXX   := GetArea()
	Local aAreaSTJ   := STJ->(GetArea())
	Local aSeqSTF    := {}
	Local aRegSTF    := {}

	dbSelectArea("TP1")
	dbSetOrder(1)
	If dbSeek(xFilial("TP1") + cBemSTJ + TPC->TPC_SERVIC + nSeqPOS + aVetTemp[nEtaTa] + aVetTemp[nEtapa] + cTpcOpcao)
		nSeqTP1 := TP1->TP1_SEQRMN
	EndIf

	//Tenta encontrar a Manutenção, com a sequencia da tabela TP1
	dbSelectArea("STF")
	dbSetOrder(1)
	If dbSeek(xFilial("STF") + cBemSTJ + TPC->TPC_SERVIC + nSeqTP1)
		aSeqSTF := STF->(GetArea())
	Else
		//Se não encontrar, verifica as manutenções ativas
		dbSelectArea("STF")
		dbSetOrder(1)
		If dbSeek(xFilial("STF") + cBemSTJ + TPC->TPC_SERVIC)
			While !EoF() .And. xFilial("STF")+cBEMSTJ+TPC->TPC_SERVIC == STF->(TF_FILIAL+TF_CODBEM+TF_SERVICO)
				If STF->TF_ATIVO <> "N"
					aSeqSTF := STF->(GetArea())

					aAdd( aRegSTF , { 	.F.,;                //Marcado S/N
					STF->TF_SEQRELA,;  //Sequencia
					STF->TF_NOMEMAN,;  //Nome Manutenção
					STF->TF_DTULTMA,;  //Data Ultima Manutenção
					NGSEEK("STD",STF->TF_CODAREA,1,"STD->TD_NOME"),; //Area
					NGSEEK("STE",STF->TF_TIPO,1,"STE->TE_NOME") } ) //Tipo
				EndIf

				dbSelectArea("STF")
				dbSkip()
			EndDo
		EndIf

		//Se encontrar mais do que 1 manutenção, abre tela para o usuario selecionar qual sequencia da manutenção deseja gerar
		If Len(aRegSTF) > 1
			aSeqSTF := {}
			nRetTmp := MNT400STF(aRegSTF,cOrdem,cBEMOLD,cBEMSTJ,cSEROLD,TPC->TPC_SERVIC,aVetTemp[nEtapa])
			If nRetTmp > 0 .And. Len(aRegSTF) >= nRetTmp
				dbSelectArea("STF")
				dbSetOrder(1)
				If dbSeek(xFilial("STF")+cBEMSTJ+TPC->TPC_SERVIC+aRegSTF[nRetTmp,2])
					aSeqSTF := STF->(GetArea())
				EndIf
			EndIf
		ElseIf Len(aRegSTF) == 0
			cDessEta := Alltrim( Upper( NGSEEK( "TPA", aVetTemp[nEtapa], 1, "TPA->TPA_DESCRI") ) )

			ShowHelpDlg( STR0037, {STR0038 + " '" + cDessEta + "', " + STR0039 }, 3, ;
			{ STR0040 + " " + Alltrim(cBEMSTJ) + STR0041 + STR0042 + " " +;
			Alltrim(TPC->TPC_SERVIC) + STR0043 }, 2);

			//"Atenção" ## "Houve a necessidade de gerar uma O.S. Preventiva a partir da resposta da etapa"
			//"porém não existe manutenção cadastrada para o Bem e Serviço."
			//"Cadastrar uma manutenção para o Bem" ## " com o " ## "Serviço" ## " na rotina MNTA120."
		EndIf
	EndIf

	If Len(aSeqSTF) > 0
		RestArea(aSeqSTF)
		nSEQTP1 := STF->TF_SEQRELA

		lRETORNA := NGGERAOS( cServCar, dDataBase, cBemSTJ, TPC->TPC_SERVIC, nSeqTP1, "N", "N", "N",, NG400VPAR())
		If lRETORNA[1][1]= "S" .And. Empty(lRETORNA[1][2])
			dbSelectArea("STJ")
			nINDGEOS := IndexOrd()
			nREGGEOS := Recno()

			If cTipoEta <> Nil .And. cMODULO <> "MNT"
				dbSelectArea("TPC")
				dbSetOrder(01)
				If dbSeek(xFilial("TPC") + aVetTemp[nEtapa] + cTpcOpcao) .And. !Empty(TPC->TPC_OBSERV)
					dbSelectArea("STJ")
					dbSetOrder(01)
					If dbSeek(xFilial("STJ") + lRETORNA[1][3] + "000001")
						RecLock("STJ",.F.)
						If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
							MsMM(,80,,TPC->TPC_OBSERV,1,,,"STJ","TJ_MMSYP")
						Else
							STJ->TJ_OBSERVA := TPC->TPC_OBSERV
						EndIf
						MsUnlock("STJ")
					EndIf
				EndIf
			EndIf

			dbSelectArea("STJ")
			dbSetOrder(01)
			If dbSeek(xFilial("STJ") + lRETORNA[1][3] + "000001")

				dbSelectArea("ST9")
				dbSetOrder(1)
				dbSeek(xFilial("ST9") + STJ->TJ_CODBEM)
				dbSelectArea("ST4")
				dbSetOrder(1)
				dbSeek(xFilial("ST4") + STJ->TJ_SERVICO)

				dbSelectArea(cTRBZ400)
				RecLock(cTRBZ400,.T.)
				(cTRBZ400)->ORDEM   := STJ->TJ_ORDEM
				(cTRBZ400)->PLANO   := STJ->TJ_PLANO
				(cTRBZ400)->CODBEM  := STJ->TJ_CODBEM
				(cTRBZ400)->NOMBEM  := ST9->T9_NOME
				(cTRBZ400)->SERVICO := STJ->TJ_SERVICO
				(cTRBZ400)->NOMSER  := ST4->T4_NOME
				(cTRBZ400)->SEQRELA := STJ->TJ_SEQRELA
				(cTRBZ400)->ETAPA   := aVetTemp[nEtapa]
				(cTRBZ400)->OPCAO   := cTpcOpcao
				(cTRBZ400)->TIPOET  := If( cTipoEta <> Nil, cTipoEta, TPC->TPC_TIPRES )
				(cTRBZ400)->RESPOS  := cTpcRespos
				(cTRBZ400)->OSORIG  := cOrdem
				(cTRBZ400)->(MsUnLock())

				If !(cTipoEta <> Nil .And. cMODULO <> "MNT")
					cMsgObs := STR0044 + ": " + (cTRBZ400)->OSORIG + Chr(13) + Chr(10) //"O.S. Origem"
					cMsgObs += STR0025 + ": " + (cTRBZ400)->ETAPA + " - " + NGSEEK("TPA",(cTRBZ400)->ETAPA,1,"SubStr(TPA_DESCRI,1,30)") + Chr(13) + Chr(10) //"Etapa"
					cMsgObs += STR0045 + ": " + (cTRBZ400)->OPCAO + Chr(13) + Chr(10) //"Opção"
					If (cTRBZ400)->TIPOET == '2'
						cMsgObs += STR0046 + ": " + NGSEEK("TPC",(cTRBZ400)->ETAPA+(cTRBZ400)->OPCAO,1,"TPC_CONDIN") + Chr(13) + Chr(10) //"Limite"
						cMsgObs += STR0047 + ": " + (cTRBZ400)->RESPOS //"Informou"
					Else
						cMsgObs += STR0048 + ": " + STR0049 //"Marcou"###"Sim"
					EndIf

					RecLock("STJ",.F.)
					If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
						MsMM(,80,,cMsgObs,1,,,"STJ","TJ_MMSYP")
					Else
						STJ->TJ_OBSERVA := cMsgObs
					EndIf
					MsUnlock("STJ")
				EndIf
			EndIf

			dbSelectArea("STJ")
			dbSetOrder(nINDGEOS)
			dbGoto(nREGGEOS)
			cVINCLUIOS := {.T.,lRETORNA[1][3]}
		EndIf
	EndIf

	RestArea(aAreaSTJ)
	RestArea(aAreaXXX)

Return cVINCLUIOS

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³fNG435GCOR³ Autor ³ Denis                 ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Consiste e gera O.S. corretiva                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA400                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fNG435GCOR(cTipoEta,cOrdem,nEtaTa,nEtapa, cServCar)

	Local cVINCLUIOS := {.F., Space( TAMSX3("TJ_ORDEM")[1] )}

	If !Empty(TPC->TPC_SERVIC)
		lRETORNA := NGGERAOS( cServCar, dDataBase, cBemSTJ, TPC->TPC_SERVIC, 0, "N", "N", "N",, NG400VPAR())

		If lRETORNA[1][1]= "S" .And. Empty(lRETORNA[1][2])
			cXORDEM := STJ->TJ_ORDEM
			cXPLANO := STJ->TJ_PLANO

			dbSelectArea("TPE")
			dbSetOrder(1)
			If dbSeek(xFilial("TPE") + STJ->TJ_CODBEM)
				dbSelectArea( "STJ" )
				RecLock("STJ", .F.)
				STJ->TJ_POSCON2 := TPE->TPE_POSCON
				MsUnlock("STJ")
			EndIf

			If cTipoEta <> Nil .And. cMODULO <> "MNT"
				dbSelectArea("TPC")
				dbSetOrder(01)
				If dbSeek(xFilial("TPC")+aVetTemp[nEtapa]+cTpcOpcao)
					If !Empty(TPC->TPC_OBSERV)
						dbSelectArea("STJ")
						RecLock("STJ",.F.)

						If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
							MsMM(,80,,TPC->TPC_OBSERV,1,,,"STJ","TJ_MMSYP")
						Else
							STJ->TJ_OBSERVA := TPC->TPC_OBSERV
						EndIf
						MsUnlock("STJ")
					EndIf
				EndIf
			EndIf

			dbSelectArea("ST9")
			dbSetOrder(1)
			dbSeek(xFilial("ST9") + STJ->TJ_CODBEM)

			dbSelectArea("ST4")
			dbSetOrder(1)
			dbSeek(xFilial("ST4") + STJ->TJ_SERVICO)

			dbSelectArea(cTRBZ400)
			RecLock(cTRBZ400,.T.)
			(cTRBZ400)->ORDEM   := STJ->TJ_ORDEM
			(cTRBZ400)->PLANO   := STJ->TJ_PLANO
			(cTRBZ400)->CODBEM  := STJ->TJ_CODBEM
			(cTRBZ400)->NOMBEM  := ST9->T9_NOME
			(cTRBZ400)->SERVICO := STJ->TJ_SERVICO
			(cTRBZ400)->NOMSER  := ST4->T4_NOME
			(cTRBZ400)->SEQRELA := STJ->TJ_SEQRELA
			(cTRBZ400)->ETAPA   := aVetTemp[nEtapa]
			(cTRBZ400)->OPCAO   := cTpcOpcao
			(cTRBZ400)->TIPOET  := If( cTipoEta <> Nil, cTipoEta, TPC->TPC_TIPRES )
			(cTRBZ400)->RESPOS  := cTpcRespos
			(cTRBZ400)->OSORIG  := cOrdem
			(cTRBZ400)->(MsUnLock())

			dbSelectArea("STJ")
			dbSetOrder(01)
			If dbSeek(xFilial("STJ")+lRETORNA[1][3]+"000000")
				If !(cTipoEta <> Nil .And. cMODULO <> "MNT")
					cMsgObs := STR0044 + ": " + (cTRBZ400)->OSORIG + Chr(13) + Chr(10) //"O.S. Origem"
					cMsgObs += STR0025 + ": " + (cTRBZ400)->ETAPA + " - " + NGSEEK("TPA",(cTRBZ400)->ETAPA,1,"SubStr(TPA_DESCRI,1,30)") + Chr(13) + Chr(10) //"Etapa"
					cMsgObs += STR0045 + ": " + (cTRBZ400)->OPCAO + Chr(13) + Chr(10) //"Opção"

					If (cTRBZ400)->TIPOET == '2'
						cMsgObs += STR0046 + ": " + NGSEEK("TPC",(cTRBZ400)->ETAPA+(cTRBZ400)->OPCAO,1,"TPC_CONDIN") + Chr(13) + Chr(10) //"Limite"
						cMsgObs += STR0047 + ": " + (cTRBZ400)->RESPOS //"Informou"
					Else
						cMsgObs += STR0048 + ": " + STR0049 //"Marcou"###"Sim"
					EndIf

					RecLock("STJ", .F.)
					If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
						MsMM(,80,,cMsgObs,1,,,"STJ","TJ_MMSYP")
					Else
						STJ->TJ_OBSERVA := cMsgObs
					EndIf
					MsUnlock("STJ")
				EndIf
			EndIf

			cVINCLUIOS := {.T., lRETORNA[1][3]}
		EndIf
	EndIf

Return cVINCLUIOS

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³fCriaOsGer³ Autor ³Denis Hyroshi de Souza ³ Data ³06/06/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Cria arquivo temporarios O.S. geradas e Mensagens tolerancia³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fCriaOsGer(aTRBZ435)

	Local aDBFZ := {}
	Local aDBFK := {}

	aAdd(aDBFZ,{"ORDEM"  ,"C", 06, 0 })
	aAdd(aDBFZ,{"PLANO"  ,"C", 06, 0 })
	aAdd(aDBFZ,{"CODBEM" ,"C", 16, 0 })
	aAdd(aDBFZ,{"NOMBEM" ,"C", 30, 0 })
	aAdd(aDBFZ,{"SERVICO","C", 06, 0 })
	aAdd(aDBFZ,{"NOMSER" ,"C", 30, 0 })
	aAdd(aDBFZ,{"SEQRELA","C", 03, 0 })
	aAdd(aDBFZ,{"ETAPA"  ,"C", 06, 0 })
	aAdd(aDBFZ,{"OPCAO"  ,"C", 15, 0 })
	aAdd(aDBFZ,{"TIPOET" ,"C", 01, 0 })
	aAdd(aDBFZ,{"RESPOS" ,"C", 10, 0 })
	aAdd(aDBFZ,{"OSORIG" ,"C", 06, 0 })

	aAdd(aTRBZ435,{STR0027, "ORDEM"  , "C", 06, 0,"@!"}) //"Ordem"
	aAdd(aTRBZ435,{STR0050, "PLANO"  , "C", 06, 0,"@!"}) //"Plano"
	aAdd(aTRBZ435,{STR0051, "CODBEM" , "C", 16, 0,"@!"}) //"Bem"
	aAdd(aTRBZ435,{STR0052, "NOMBEM" , "C", 30, 0,"@!"}) //"Nome Bem"
	aAdd(aTRBZ435,{STR0053, "SERVICO", "C", 06, 0,"@!"}) //"Servico"
	aAdd(aTRBZ435,{STR0054, "NOMSER" , "C", 30, 0,"@!"}) //"Nome Servico"
	aAdd(aTRBZ435,{STR0055, "SEQRELA", "C", 03, 0,"@!"}) //"Sequen"

	//Criação Tabela Temporária
	oTmpTbl1 := NGFwTmpTbl(cTRBZ400,aDBFZ,{{ "ORDEM" }})

	aAdd(aDBFK,{"ORDEM"   , "C", TamSx3("TJ_ORDEM")[1], 0 })
	aAdd(aDBFK,{"PLANO"   , "C", TamSx3("TJ_PLANO")[1], 0 })
	aAdd(aDBFK,{"BEM"     , "C", 16, 0 })
	aAdd(aDBFK,{"ETAPA"   , "C", 06, 0 })
	aAdd(aDBFK,{"OPCAO"   , "C", 15, 0 })
	aAdd(aDBFK,{"RESPOSTA", "C", 10, 0 })
	aAdd(aDBFK,{"INFORMOU", "C", 10, 0 })
	aAdd(aDBFK,{"PERCENTO", "N", 06, 2 })
	aAdd(aDBFK,{"VLRMENOR", "N", 12, 2 })
	aAdd(aDBFK,{"VLRMAIOR", "N", 12, 2 })
	aAdd(aDBFK,{"OBSERVA" , "C", 50, 0 })

	aAdd(aTRBK,{STR0027, "ORDEM"   , "C", TamSx3("TJ_ORDEM")[1],0,"@!"})				//"Ordem"
	aAdd(aTRBK,{STR0050, "PLANO"   , "C", TamSx3("TJ_PLANO")[1],0,"@!"})				//"Plano"
	aAdd(aTRBK,{STR0051, "BEM"     , "C", 16,0,"@!"}) //"Bem"
	aAdd(aTRBK,{STR0025, "ETAPA"   , "C", 06,0,"@!"}) //"Etapa"
	aAdd(aTRBK,{STR0057, "OPCAO"   , "C", 15,0,"@!"}) //"Opcao"
	aAdd(aTRBK,{STR0058, "INFORMOU", "C", 10,0,"@!"}) //"Informado"
	aAdd(aTRBK,{STR0059, "RESPOSTA", "C", 10,0,"@!"}) //"Resposta"
	aAdd(aTRBK,{STR0060, "OBSERVA" , "C", 40,0,"@!"}) //"Observacao"
	aAdd(aTRBK,{STR0061, "PERCENTO", "N", 06,2,"@E 999.99"}) //"Percent."
	aAdd(aTRBK,{STR0062, "VLRMENOR", "N", 12,2,"@E 999,999,999.99"}) //"Vlr Menor"
	aAdd(aTRBK,{STR0063, "VLRMAIOR", "N", 12,2,"@E 999,999,999.99"}) //"Vlr Maior"

	//Criação Tabela Temporária
	oTmpTbl2 := NGFwTmpTbl(cTRBK400,aDBFK,{{ "BEM","ETAPA" }})

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ Mnt435F12³ Autor ³Denis Hyroshi de Souza ³ Data ³ 23/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Descrio ³ Funcao para buscar pecas de reposicao (F12)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Mnt435F12()

	NGINSUF12("M->TL_CODIGO",cCdBemTJ,aCOLS[n,nTpRg435],.T.,,"TL_NOMCODI",oBrw6)

Return

//--------------------------------------------------------------
/*/{Protheus.doc} Fd_Entra
Ações ao selecionar determinado objeto

@author Denis Hyroshi de Souza
@since 23/06/08

@param nE, numerico, indica o objeto selecionado
	1 - Browse insumos realizados
	2 - Browse ocorrências
	3 - Browse motivo de atraso
	4 - Browse etapas
@return Nil
/*/
//--------------------------------------------------------------
Static Function Fd_Entra(nE)
	Local nPos := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPox := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	n := 1
	lFocusBrw3 := .F.

	If nE == 1

		aHeader := aClone( aHoBrw6 )
		aCols   := aClone( aCoBrw6 )
		oBrw6:oBrowse:lDisablePaint := .F.
		oBrw6:oBrowse:Refresh()
		fLoadSTL(.F.)

		oBrw3:oBrowse:lDisablePaint := .T.
		oBrw5:oBrowse:lDisablePaint := .T.
		SetKey(VK_F4,{|| MntViewSB2(aCols[n,nPos], aCols[n,nPox] ) })
		SetKey(VK_F12,{|| Mnt435F12() })

		//Verifica se o parâmetro MV_NGHISES está como "N" para permitir a alteração do custo do insumo
		If STJ->TJ_SERVICO == "HISTOR"
			If cUIntHis == "N" .And. cUsaInt3 == 'S' .And. aCols[n,nPos] $ ("P\M")
				lCusto := .T.
			Else
				lCusto := .F.
			EndIf
		ElseIf cUsaInt3 == 'S'
			lCusto := .F.
		EndIf

	ElseIf nE == 2
		lFocusBrw3 := .T.
		aHeader := aClone( aHoBrw3 )
		aCols   := aClone( aCoBrw3 )
		oBrw3:oBrowse:lDisablePaint := .F.
		oBrw3:oBrowse:Refresh()

		//-----------------------------------------------
		//Valida insumo selecionado para as ocorrências
		//-----------------------------------------------
		If !fValInsOco( oBrw6:oBrowse:nAt, nPos, nPox )

			oFolder435:nOption := 1 //Posiciona no folder de Insumos
			oBrw6:oBrowse:SetFocus() //volta foco no browse insumos
			Return

		EndIf

		oBrw6:oBrowse:lDisablePaint := .T.
		oBrw5:oBrowse:lDisablePaint := .T.
	ElseIf nE == 3
		aHeader := aClone( aHoBrw4 )
		aCols   := aClone( aCoBrw4 )
		oBrw5:oBrowse:lDisablePaint := .F.
		oBrw5:oBrowse:Refresh()

		oBrw6:oBrowse:lDisablePaint := .T.
		oBrw3:oBrowse:lDisablePaint := .T.
	EndIf
	nControGD := nE

Return

//--------------------------------------------------------------
/*/{Protheus.doc} Fd_Sai
Ações ao perder o foco de determinado objeto

@author Denis Hyroshi de Souza
@since 23/06/08

@param nE, numerico, indica o objeto que perde o foco
	1 - Browse insumos realizados
	2 - Browse ocorrências
	3 - Browse motivo de atraso
	4 - Browse etapas
@return Nil
/*/
//--------------------------------------------------------------
Static Function Fd_Sai( nE )

	Local aAreaOld := GetArea()
	Local nXX,nYY,i,aTemp
	Local nPosOld := oOS:nAt
	Local nLineOS := aScan(aDadosOS, {|x|x[1]+x[2] == cOrdemTJ+cPlanoTJ })
	Local nPosSTL := nil
	Local nPosSTN := nil
	Local nPosTPL := nil
	Local nSTLlin := oBrw6:oBrowse:nAt
	Local nTmpOld

	lFocusBrw3 := .F.

	Set Key VK_F12 To
	Set Key VK_F4 To
	// 1-Ordem / 2-Plano / 3-Previstos SALVO[] / 4-Realizados SALVO[] / 5-Realizados NOVO[]
	// 6-Motivos Atraso SALVO[] / 7-Motivos Atraso NOVO[] / 8-Etapas NOVO[] / 9-Etapas Outras OS[]

	If nE == 1 .And. Len(aHoBrw6) == Len(aHeader) //Insumos realizados

		//Apaga ultima linha caso vazia
		If oBrw6:lNewLine

			aDel( aCols, nSTLlin )
			aSize( aCols, nSTLlin - 1 )
			oBrw6:lNewLine := .F.

		EndIf

		aCoBrw6 := aClone(aCols)
		aHoBrw6 := aClone(aHeader)
		If Len(aCoBrw6) == 0
			If Valtype(aNovoSTL) == "A"
				aCoBrw6 := aClone(aNovoSTL)
			Else
				aCoBrw6 := BlankGetD(aHoBrw6)
			EndIf
		EndIf

		//Transferi as alteracoes para o arquivo temporario
		If nLineOS > 0
			aDadosOS[nLineOS,5] := aClone(aCols)
		EndIf

		If !TudOkTL435(@nPosSTL)

			//Posiciona na OS anterior
			oOS:nAt		:= nPosOld
			M->TJ_ORDEM	:= aOS[oOS:nAt,nPosOS]
			M->TJ_PLANO	:= aOS[oOS:nAt,nPosPL]
			cOrdemTJ	:= M->TJ_ORDEM
			cPlanoTJ	:= M->TJ_PLANO
			fRefreshOS( cOrdemTJ , cPlanoTJ , oOS:nAt, 1)
			oOS:Refresh()

			//------------------------------------------------
			//Posiciona no folder de Insumos
			//------------------------------------------------
			oFolder435:nOption := 1

			//Posiciona na Insumo anterior
			oBrw6:oBrowse:SetFocus()
			If ValType(nPosSTL) == "N"
				oBrw6:oBrowse:nAt := nPosSTL
			EndIf
			lRet435 := .F. //Retorna falso para cancelar a gravacao
			Return .F.
		Else

			If lIntRM
				fRefreshOS( aOS[oOS:nAt,nPosOS], aOS[oOS:nAt,nPosPL] , oOS:nAt, 1 )
				oOS:Refresh()
			EndIf

		EndIf

		//Verifica se algo foi alterado
		If nLineOS > 0 .And. !lFoiAlterado
			If ValType(aDadosOS[nLineOS,4]) <> ValType(aDadosOS[nLineOS,5]) .Or. ValType(aDadosOS[nLineOS,5]) != "A"
				lFoiAlterado := .T.
			ElseIf Len(aDadosOS[nLineOS,4]) <> Len(aDadosOS[nLineOS,5])
				lFoiAlterado := .T.
			Else
				For nXX := 1 to Len(aDadosOS[nLineOS,5])
					If Len(aDadosOS[nLineOS,4,nXX]) <> Len(aDadosOS[nLineOS,5,nXX])
						lFoiAlterado := .T.
						Exit
					EndIf
					If  Empty(aDadosOS[nLineOS,4,nXX,1]) .And. Empty(aDadosOS[nLineOS,4,nXX,3]) .And. Empty(aDadosOS[nLineOS,4,nXX,5]) .And. ;
					Empty(aDadosOS[nLineOS,5,nXX,1]) .And. Empty(aDadosOS[nLineOS,5,nXX,3]) .And. Empty(aDadosOS[nLineOS,5,nXX,5])
						Loop
					EndIf

					For nYY := 1 to Len(aDadosOS[nLineOS,5,nXX])
						If nYY == Len(aDadosOS[nLineOS,5,nXX])-1 .Or. ;
						(Len(aHeader) >= nYY .And. Len(aHeader[nYY]) >= 10 .And. AllTrim(aHeader[nYY,10]) == "V") // Não considera campos virtuais
							Loop
						EndIf
						If ValType(aDadosOS[nLineOS,5,nXX,nYY]) <> ValType(aDadosOS[nLineOS,4,nXX,nYY])
							lFoiAlterado := .T.
							Exit
						EndIf
						If aDadosOS[nLineOS,5,nXX,nYY] <> aDadosOS[nLineOS,4,nXX,nYY]
							lFoiAlterado := .T.
							Exit
						EndIf
					Next nYY
					If lFoiAlterado
						Exit
					EndIf
				Next nXX
			EndIf
		EndIf

		oBrw6:oBrowse:lDisablePaint := .T.

	ElseIf nE == 2 .And. Len(aHoBrw3) == Len(aHeader) //Ocorrencias nos Insumos
		aCoBrw3 := aClone(aCols)
		aHoBrw3 := aClone(aHeader)
		If Len(aCoBrw3) == 0
			aCoBrw3 := BlankGetD(aHoBrw3)
		EndIf

		//Transferi as alteracoes para o arquivo temporario
		nTmpOld := oBrw6:oBrowse:nAt
		If nTmpOld <= Len(aCoBrw6)
			aCoBrw6[nTmpOld , Len(aCoBrw6[nTmpOld])-1 ] := aClone(aCoBrw3)
			If nLineOS > 0
				aDadosOS[nLineOS,5] := aClone(aCoBrw6)
			EndIf
		EndIf

		If !TudOkTN435(@nPosSTN)

			//Posiciona na OS anterior
			oOS:nAt := nPosOld
			M->TJ_ORDEM := aOS[oOS:nAt,nPosOS]
			M->TJ_PLANO := aOS[oOS:nAt,nPosPL]
			cOrdemTJ    := M->TJ_ORDEM
			cPlanoTJ    := M->TJ_PLANO
			fRefreshOS( cOrdemTJ , cPlanoTJ , oOS:nAt, nSTLlin )
			oOS:Refresh()

			//------------------------------------------------
			//Posiciona no folder de ocorrências
			//------------------------------------------------
			oFolder435:nOption := 3

			oBrw3:oBrowse:SetFocus()
			aHeader := aClone( aHoBrw3 )
			aCols   := aClone( aCoBrw3 )
			If ValType(nPosSTN) == "N"
				oBrw3:ForceRefresh()
				oBrw3:oBrowse:nAt := nPosSTN
				oBrw3:oBrowse:nRowPos := 3
			Else
				oBrw3:ForceRefresh()
			EndIf
			lRet435 := .F. //Retorna falso para cancelar a gravacao
			Return .F.
		EndIf

		If nTmpOld <= Len(aCoBrw6)
			aCoBrw6[nTmpOld , Len(aCoBrw6[nTmpOld])-1 ] := aClone(aCoBrw3)
			If nLineOS > 0
				aDadosOS[nLineOS,5] := aClone(aCoBrw6)
			EndIf
		EndIf

		//Verifica se algo foi alterado
		If nLineOS > 0 .And. !lFoiAlterado

			If nTmpOld > Len(aDadosOS[nLineOS,4])
				lFoiAlterado := .T.
			Else
				aTemp := aClone( aDadosOS[nLineOS,4,nTmpOld, Len(aDadosOS[nLineOS,4,nTmpOld])-1 ] )
				If ValType(aTemp) <> ValType(aCols) .Or. ValType(aTemp) != "A"
					lFoiAlterado := .T.
				ElseIf Len(aTemp) <> Len(aCols)
					lFoiAlterado := .T.
				Else
					For nXX := 1 to Len(aCols)
						If Len(aTemp[nXX]) <> Len(aCols[nXX])
							lFoiAlterado := .T.
							Exit
						EndIf
						For nYY := 1 to Len(aCols[nXX])
							If ValType(aCols[nXX,nYY]) <> ValType(aTemp[nXX,nYY])
								lFoiAlterado := .T.
								Exit
							EndIf
							If aCols[nXX,nYY] <> aTemp[nXX,nYY]
								lFoiAlterado := .T.
								Exit
							EndIf
						Next nYY
						If lFoiAlterado
							Exit
						EndIf
					Next nXX
				EndIf
			EndIf
		EndIf

		oBrw3:oBrowse:lDisablePaint := .T.

	ElseIf nE == 3 .And. Len(aHoBrw4) == Len(aHeader) //Motivos de Atraso

		aCoBrw4 := aClone(aCols)
		aHoBrw4 := aClone(aHeader)

		If Len(aCoBrw4) == 0
			aCoBrw4 := BlankGetD(aHoBrw4)
		EndIf

		//Transferi as alteracoes para o arquivo temporario
		If nLineOS > 0
			aDadosOS[nLineOS,7] := aClone(aCols)
		EndIf

		If !TudOk435PL(@nPosTPL)

			//Posiciona na OS anterior
			oOS:nAt := nPosOld
			M->TJ_ORDEM := aOS[oOS:nAt,nPosOS]
			M->TJ_PLANO := aOS[oOS:nAt,nPosPL]
			cOrdemTJ    := M->TJ_ORDEM
			cPlanoTJ    := M->TJ_PLANO
			fRefreshOS( cOrdemTJ , cPlanoTJ , oOS:nAt, 1)
			oOS:Refresh()

			//------------------------------
			//Posiciona no folder de Motivo
			//------------------------------
			oFolder435:nOption := 4


			oBrw5:oBrowse:SetFocus()
			If ValType(nPosSTL) == "N"
				oBrw5:oBrowse:nAt := nPosSTL
			EndIf
			lRet435 := .F. //Retorna falso para cancelar a gravacao

			Return .F.
		EndIf

		//Verifica se algo foi alterado
		If nLineOS > 0 .And. !lFoiAlterado
			If ValType(aDadosOS[nLineOS,6]) <> ValType(aCols) .Or. ValType(aDadosOS[nLineOS,6]) != "A"
				lFoiAlterado := .T.
			ElseIf Len(aDadosOS[nLineOS,6]) <> Len(aCols)
				lFoiAlterado := .T.
			Else
				For nXX := 1 to Len(aCols)
					If Len(aDadosOS[nLineOS,6,nXX]) <> Len(aCols[nXX])
						lFoiAlterado := .T.
						Exit
					EndIf
					For nYY := 1 to Len(aCols[nXX])
						If ValType(aCols[nXX,nYY]) <> ValType(aDadosOS[nLineOS,6,nXX,nYY])
							lFoiAlterado := .T.
							Exit
						EndIf
						If aCols[nXX,nYY] <> aDadosOS[nLineOS,6,nXX,nYY]
							lFoiAlterado := .T.
							Exit
						EndIf
					Next nYY
					If lFoiAlterado
						Exit
					EndIf
				Next nXX
			EndIf
		EndIf

	ElseIf nE == 4 //Etapas
		nRecTrb := (cTRBQ400)->(Recno())
		aTempCab := {}
		dbSelectArea(cTRBQ400)
		dbSetOrder(1)
		dbGoTop()
		While !EoF()
			aTemp := {}
			aAdd( aTemp , (cTRBQ400)->TQ_OK )

			For i := 2 To Len(aTRBQ)
				//De acordo com a utilização do Ponto de Entrada MNTA435G inclui o executante padrão
				If i == aScan(aTRBQ, {|x| Alltrim(x[1]) == "TQ_CODFUNC" }) .And. !Empty(cCodFunc) .And. !Empty((cTRBQ400)->TQ_OK)
					(cTRBQ400)->TQ_CODFUNC := cCodFunc
				EndIf

				aAdd( aTemp , &(cTRBQ400 + "->" + aTRBQ[i,1]) )
			Next i

			aOpcEtapa := {}
			dbSelectArea(cTRB3400)
			dbSetOrder(1)
			dbGoTop()
			dbSeek((cTRBQ400)->TQ_ETAPA+(cTRBQ400)->TQ_TAREFA)
			While !EoF() .And. (cTRB3400)->TPC_ETAPA == (cTRBQ400)->TQ_ETAPA .And. (cTRB3400)->TPC_TAREFA == (cTRBQ400)->TQ_TAREFA
				If !Empty( (cTRB3400)->TPC_OK )
					aAdd( aOpcEtapa , {;
					(cTRB3400)->TPC_OK		,;
					(cTRB3400)->TPC_OPCAO	,;
					(cTRB3400)->TPC_RESPOS	 ;
					})
				EndIf
				dbSkip()
		EndDo
			aAdd( aTemp , aOpcEtapa )
		aAdd( aTemp, (cTRBQ400)->STATUS)
			aAdd( aTempCab , aTemp )
			dbSelectArea(cTRBQ400)
			dbSkip()
		End
		dbSelectArea(cTRBQ400)
		dbGoTo(nRecTrb)
		dbSelectArea(cTRB3400)
		dbGoTop()
		dbSeek((cTRBQ400)->TQ_ETAPA+(cTRBQ400)->TQ_TAREFA+(cTRBQ400)->TQ_SEQETA)
		If nLineOS > 0
			aDadosOS[nLineOS,8] := aClone(aTempCab)
		EndIf

		nRecTrb := (cTRBTAR)->(Recno())
		aTempCab := {}

		If cMVPAR01 == '1'

			dbSelectArea(cTRBTAR)
			dbSetOrder(1)
			dbGoTop()
			While !EoF()
				aAdd( aTempCab , {	(cTRBTAR)->TAREFA,;
				(cTRBTAR)->NOMETAR,;
				(cTRBTAR)->ETAPA,;
				(cTRBTAR)->NOMEETA,;
				(cTRBTAR)->ORDEM,;
				(cTRBTAR)->DTMPINI } )
				dbSkip()
			End

		EndIf
		dbSelectArea(cTRBTAR)
		dbGoTo(nRecTrb)
		If nLineOS > 0

			If cMVPAR01 == '1'
				aDadosOS[nLineOS,9] := aClone(aTempCab)
			Else
				aDadosOS[nLineOS,9] := Nil
			EndIf

		EndIf

	EndIf

	n := 1
	nControGD := 0

	RestArea(aAreaOld)

return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fRefreshOS³ Autor ³Denis Hyroshi de Souza ³ Data ³ 01/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Atualiza informacoes ao alterar a OS no browse             |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fRefreshOS(cTJ_ORDEM, cTJ_PLANO , nLinBwOS, nLinSTL)

	Local lRet		:= .T.
	Local nLinOS	:= 0

	//Controle dos parâmetros MV_PAR01, MV_PAR02 e MV_PAR05
	Private cPar01 := Space(6)
	Private cPar02 := Space(6)
	Private cPar05 := Space(3)

	If !( IsIncallStack("NGMUStoLvl") .Or. IsIncallStack("NGMUGetSit") )

		//Se o número da OS nao existir no array
		nLinOS := aScan(aDadosOS, {|x| x[1]+x[2] == cTJ_ORDEM+cTJ_PLANO })
		If nLinOS == 0
			Return .T.
		EndIf

		If !lStartVar
			Return .T.
		EndIf

		If Empty(cTJ_ORDEM)
			Return .T.
		EndIf

		dbSelectArea("STJ")
		dbSetOrder(01)
		dbSeek(xFilial("STJ")+cTJ_ORDEM+cTJ_PLANO)
		dbSelectArea("STF")
		dbSetOrder(01)
		dbSeek(xFilial("STF")+STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA)
		M->TF_CODBEM  := STJ->TJ_CODBEM
		M->TF_SERVICO := STJ->TJ_SERVICO
		M->TF_SEQRELA := STJ->TJ_SEQRELA
		M->TJ_ORDEM   := STJ->TJ_ORDEM
		M->TJ_PLANO   := STJ->TJ_PLANO
		M->TJ_CODBEM  := STJ->TJ_CODBEM
		cOrdemTJ      := M->TJ_ORDEM
		cPlanoTJ      := M->TJ_PLANO
		cCdBemTJ      := M->TJ_CODBEM
		M->TL_TIPOREG := Space(01)
		MV_PAR01      := STJ->TJ_CODBEM
		MV_PAR02      := STJ->TJ_SERVICO
		MV_PAR05      := STJ->TJ_SEQRELA
		cPar01			:= MV_PAR01
		cPar02 		:= MV_PAR02
		cPar05 		:= MV_PAR05
		lCORRET       := If( Val(STJ->TJ_PLANO) == 0 , .T. , .F. )  //Indica que a OS é corretiva ou nao

		If STJ->TJ_TIPOOS == "B"
			If !NGBEMATIV(STJ->TJ_CODBEM)
				lRet := .F.
			EndIf
			If !NGMANATIV(STJ->TJ_CODBEM,STJ->TJ_SERVICO,STJ->TJ_SEQRELA)
				lRet := .F.
			EndIf
		EndIf

		If !lRet
			oBrw2:oBrowse:Disable()
			oBrw6:oBrowse:Disable()
			oBrw3:oBrowse:Disable()
			oBrw4:oBrowse:Disable()
			oBrw7:Disable()
			oBrw5:oBrowse:Disable()
			oBtAllNext:Disable()
			oBtNext:Disable()
			oBtPrev:Disable()
			oBtAllPrev:Disable()
			oBtEtInc:Disable()
			oBtEtAlt:Disable()
			oBtEtExc:Disable()
			oBtEtAdd:Disable()
		Else
			If ExistBlock( "MNTA435C" )
				oBrw6:oBrowse:Disable()
				oBrw2:oBrowse:Disable()
			Else
				oBrw6:oBrowse:Enable()
				oBrw2:oBrowse:Enable()
			EndIf
			oBrw3:oBrowse:Enable()
			oBrw4:oBrowse:Enable()
			oBrw7:Enable()
			oBrw5:oBrowse:Enable()
			oBtAllNext:Enable()
			oBtNext:Enable()
			oBtPrev:Enable()
			oBtAllPrev:Enable()
			oBtEtInc:Enable()
			oBtEtAlt:Enable()
			oBtEtExc:Enable()
			oBtEtAdd:Enable()
		EndIf

		oBrw3:oBrowse:lDisablePaint := .F.
		oBrw5:oBrowse:lDisablePaint := .F.
		oBrw6:oBrowse:lDisablePaint := .F.

		//Carrega Etapas
		LoadEtapas(cTJ_ORDEM, cTJ_PLANO, nLinOS)
		//Carrega Motivos Atraso
		LoadMotAtr(cTJ_ORDEM, cTJ_PLANO, nLinOS)
		//Carrega Insumos
		LoadInsum(cTJ_ORDEM, cTJ_PLANO, nLinOS, nLinSTL)
		//Atualiza texto do cabecalho
		cCadastro := cCadTemp + STR0065+cTJ_ORDEM //" O.S.: "
		//oTxtOS:SetText(cTJ_ORDEM)
		oDlg1:cTitle := cCadastro

		//Verifica se o parâmetro MV_NGHISES está como "N" para permitir a alteração do custo do insumo
		dbSelectArea("STJ")
		dbSetOrder(1)
		If dbSeek(xFilial("STJ") + cTJ_ORDEM + cTJ_PLANO)
			If STJ->TJ_SERVICO == "HISTOR"
				If cUIntHis == "N" .And. cUsaInt3 == 'S'
					lCusto := .T.
				Else
					lCusto := .F.
				EndIf
			ElseIf cUsaInt3 == 'S'
				lCusto := .F.
			EndIf
		EndIf

		oBrw3:oBrowse:lDisablePaint := .T.
		oBrw5:oBrowse:lDisablePaint := .T.
		oBrw6:oBrowse:lDisablePaint := .T.
	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³LoadInsum ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 23/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Monta aHeader e aCols com os insumos da OS selecionada      |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function LoadInsum(cTJ_ORDEM, cTJ_PLANO, nLinOS, nLinSTL)

	Local aTemp     := {}
	Local cKEY      := ''
	Local cGETWHILE := ''
	Local cAlsOrd   := ''
	Local nG        := 0
	Local i         := 0
	Local nX2       := 0
	Local nPsDtIni  := GDFIELDPOS( "TL_DTINICI" , aHoBrw2 )
	Local lTemIns   := .T.
	Local lTemAlt   := .T.
	Local lMNTA435P	:= ExistBlock("MNTA435P")

	n:=1

	If Len(aDadosOS) == 0
		Return .T.
	ElseIf nLinOS == 0
		nLinOS := 1
	EndIf

	// [aDadosOS]
	// 1-Ordem / 2-Plano / 3-Previstos SALVO[] / 4-Realizados SALVO[] / 5-Realizados NOVO[]
	// 6-Motivos Atraso SALVO[] / 7-Motivos Atraso NOVO[] / 8-Etapas NOVO[] / 9-Etapas Outras OS[]

	If Type("aDadosOS["+Alltrim(Str(nLinOS))+",3]") <> "A" .Or. Type("aDadosOS["+Alltrim(Str(nLinOS))+",4]") <> "A"
		lTemIns := .F.
	EndIf
	If Type("aDadosOS["+Alltrim(Str(nLinOS))+",5]") <> "A"
		lTemAlt := .F.
	EndIf

	dbSelectArea(cTRBIP)
	Zap

	dbSelectArea("STJ")
	dbSetOrder(1)
	dbSeek(xFilial("STJ")+cTJ_ORDEM+cTJ_PLANO,.T.)

	If !Empty(cTJ_ORDEM)

		//Carrega Insumos Previstos
		aCoBrw2 := {}
		If lTemIns
			aCoBrw2 := aClone(aDadosOS[nLinOS,3])
			For nX2 := 1 To Len(aCoBrw2)
				(cTRBIP)->(DbAppend())
				(cTRBIP)->TL_OK      := "  "
				(cTRBIP)->STATUS := "2"
				For i := 1 To Len(aHoBrw2)
					xx := aHoBrw2[i][2]
					(cTRBIP)->(&xx.) := aCoBrw2[nX2,i]
				Next i
				(cTRBIP)->XX_USACAL := If((cTRBIP)->TL_USACALE=="S","Sim",If((cTRBIP)->TL_USACALE=="N","Nao",(cTRBIP)->TL_USACALE))
				(cTRBIP)->XX_DESTIN := If((cTRBIP)->TL_DESTINO=="A","Apoio",If((cTRBIP)->TL_DESTINO=="S","Substituicao",If((cTRBIP)->TL_DESTINO=="T","Troca",(cTRBIP)->TL_DESTINO)))
				(cTRBIP)->XX_TEMGAR := If((cTRBIP)->TL_GARANTI=="S","Sim",If((cTRBIP)->TL_GARANTI=="N","Nao",(cTRBIP)->TL_GARANTI))
				(cTRBIP)->XX_NOMINS := GetNomeTip((cTRBIP)->TL_TIPOREG)
			Next nX2
		Else
			
			cAlsOrd := GetNextAlias()
			Inclui  := .F.

			BeginSQL Alias cAlsOrd

				SELECT
					STL.R_E_C_N_O_
				FROM
					%table:STL% STL
				WHERE
					STL.TL_FILIAL  = %xFilial:STL%       AND
					STL.TL_ORDEM   = %exp:cTJ_ORDEM%     AND
					STL.TL_PLANO   = %exp:cTJ_PLANO%     AND
					STL.TL_SEQRELA = '0  '               AND
					STL.%NotDel%
				ORDER BY
					STL.TL_SEQTARE

			EndSQL
			
			While (cAlsOrd)->( !EoF() )

				dbSelectArea( 'STL' )
				dbGoTo( (cAlsOrd)->R_E_C_N_O_ )

				(cTRBIP)->(DbAppend())
				(cTRBIP)->TL_OK  := "  "
				(cTRBIP)->STATUS := "2"
				aTemp := {}
				For i := 1 To Len(aHoBrw2)
					xx := aHoBrw2[i][2]
					If Posicione("SX3",2,xx ,"X3_CONTEXT") == "V"
						(cTRBIP)->(&xx.) := CriaVar( AllTrim(xx) )
					Else
						If xx == "TL_GARANTI"
							Inclui := .T.
							(cTRBIP)->(&xx.) := CriaVar( AllTrim(xx) )
							Inclui := .F.
						ElseIf Posicione("SX3",2,xx ,"X3_CONTEXT") != "V"
							(cTRBIP)->(&xx.) := STL->(&xx.)
						EndIf
					EndIf
					aAdd( aTemp , (cTRBIP)->(&xx.) )
				Next i
				(cTRBIP)->XX_USACAL := If((cTRBIP)->TL_USACALE=="S","Sim",If((cTRBIP)->TL_USACALE=="N","Nao",(cTRBIP)->TL_USACALE))
				(cTRBIP)->XX_DESTIN := If((cTRBIP)->TL_DESTINO=="A","Apoio",If((cTRBIP)->TL_DESTINO=="S","Substituicao",If((cTRBIP)->TL_DESTINO=="T","Troca",(cTRBIP)->TL_DESTINO)))
				(cTRBIP)->XX_TEMGAR := If((cTRBIP)->TL_GARANTI=="S","Sim",If((cTRBIP)->TL_GARANTI=="N","Nao",(cTRBIP)->TL_GARANTI))
				(cTRBIP)->XX_NOMINS := GetNomeTip((cTRBIP)->TL_TIPOREG)
				aAdd( aTemp , .F. )
				aAdd( aCoBrw2 , aTemp )

				(cAlsOrd)->( dbSkip() )

			End

			(cAlsOrd)->( dbCloseArea() )

			Inclui := .T.
			For NG := 1 To Len(aCoBrw2)
				xx := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
				M->TL_TIPOREG := If(xx > 0, aCoBrw2[nG][xx], " ")
				xx := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO"})
				M->TL_CODIGO := If(xx > 0, aCoBrw2[nG][xx], Space(Len(stl->tl_codigo)))
				xx := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NOMCODI"})
				If xx > 0
					aCoBrw2[nG][xx] := VirtInsumo(M->TL_TIPOREG, M->TL_CODIGO)
				EndIf
			Next
		EndIf

		cGETWHILE := "TL_FILIAL == xFilial('STL') .And. "
		cGETWHILE += "TL_ORDEM  == '"+cTJ_ORDEM+"' .And. "
		cGETWHILE += "TL_PLANO  == '"+cTJ_PLANO+"'"
		cKEY      := cTJ_ORDEM + cTJ_PLANO

		//Carrega Insumos Realizados
		aCoBrw6 := {}
		If lTemAlt
			aCoBrw6 := aClone(aDadosOS[nLinOS,5])
		ElseIf lTemIns
			aCoBrw6 := aClone(aDadosOS[nLinOS,4])
		Else
			Inclui := .F.
			dbSelectArea("STL")
			dbSetOrder(1)
			dbSeek(xFilial("STL")+cKEY)
			While !EoF() .And. &cGETWHILE.
				If !Empty(STL->TL_SEQRELA) .And. Val(STL->TL_SEQRELA) > 0
					aTemp := {}
					For i := 1 To Len(aHoBrw6)
						xx := aHoBrw6[i][2]
						If Posicione("SX3",2,xx ,"X3_CONTEXT") == "V"
							aAdd( aTemp , CriaVar( AllTrim(aHoBrw6[i][2]) ) )
						Else
							aAdd( aTemp , STL->(&xx.) )
						EndIf
					Next i
					aAdd( aTemp , {} )
					aAdd( aTemp , .F. )
					aAdd( aCoBrw6 , aTemp )
				EndIf
				dbSelectArea("STL")
				dbSkip()
			End
			Inclui := .T.

			//Ponto de Entrada customizar ordenamento dos insumos
			If lMNTA435P
				aCoBrw6 := ExecBlock("MNTA435P",.F.,.F., {aCoBrw6,aHoBrw2})
			Else
				//Ordena pelo campo TL_SEQRELA
				nPos18 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
				If nPos18 > 0
					aSort(aCoBrw6,,,{|x,y| x[nPos18] < y[nPos18] })
				EndIf
			EndIf
		EndIf

		If Len(aCoBrw6) == 0
			aCoBrw6 := BLANKGETD(aHoBrw6)
			If ValType( aCoBrw6[1, Len(aCoBrw6[1])-1 ] ) <> "A"
				aCoBrw6[1, Len(aCoBrw6[1]) ] := {}
				aAdd( aCoBrw6[1] , .F. )
			EndIf
			PutFileInEof("STL")
			For i := 1 To Len(aHoBrw6)
				aCoBrw6[1, i ] := CriaVar( AllTrim(aHoBrw6[i][2]) )
			Next i
			If nPsDtIni > 0
				aCoBrw6[1, nPsDtIni ] := dDataBase
			EndIf
			If Valtype(aNovoSTL) <> "A"
				aNovoSTL := aClone(aCoBrw6)
			EndIf
		EndIf

		//Atualiza Insumos Previstos
		(cTRBIP)->(dbGoTop())
		oBrw2:oBrowse:Refresh()

		//----------------------------------------------
		//Atualiza legenda/status dos insumos previstos
		//----------------------------------------------
		fStatus()

		If (cTRBIP)->(RecCount()) > 0
			oPnlInput:Enable()
		Else
			oPnlInput:Disable()
		EndIf

		//Atualiza Insumos Previstos
		(cTRBIP)->(dbGoTop())
		oBrw2:oBrowse:Refresh()

		//Atualiza Insumos Realizados e aCols de Ocorrencias
		aCols   := aClone(aCoBrw6)
		aHeader := aClone(aHoBrw6)
		fLoadSTL(.F.,nLinSTL)

		If !lTemIns
			aDadosOS[nLinOS,3] := aClone(aCoBrw2)
			aDadosOS[nLinOS,4] := aClone(aCoBrw6)
		EndIf
		PutFileInEof("STL")

	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³LoadMotAtr³ Autor ³Denis Hyroshi de Souza ³ Data ³ 23/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Carrega os Motivos de Atrasos - TPL                         |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function LoadMotAtr(_cOrdem,_cPlano, nLinOS)
	Local cGETWHILE := "TPL_ORDEM == '"+  cOrdemTJ  +"'"
	Local lTemIns := .T.
	Local lTemAlt := .T.

	// [aDadosOS]
	// 1-Ordem / 2-Plano / 3-Previstos SALVO[] / 4-Realizados SALVO[] / 5-Realizados NOVO[]
	// 6-Motivos Atraso SALVO[] / 7-Motivos Atraso NOVO[] / 8-Etapas NOVO[] / 9-Etapas Outras OS[]

	If Type("aDadosOS["+Alltrim(Str(nLinOS))+",6]") <> "A"
		lTemIns := .F.
	EndIf
	If Type("aDadosOS["+Alltrim(Str(nLinOS))+",7]") <> "A"
		lTemAlt := .F.
	EndIf

	If lTemAlt
		aCoBrw4 := aClone(aDadosOS[nLinOS,7])
	Else
		dbSelectArea("TPL")
		dbSetOrder(1)
		Inclui := .F.
		aCoBrw4 := MAKEGETD("TPL", _cOrdem,  aHoBrw4, cGETWHILE,,.F.)

		If Len(aCoBrw4) == 0
			aCoBrw4 := BLANKGETD(aHoBrw4)
		EndIf

		Inclui := .T.
		aDadosOS[nLinOS,7] := aClone(aCoBrw4)
	EndIf

	If !lTemIns
		aDadosOS[nLinOS,6] := aClone(aCoBrw4)
	EndIf

	PutFileInEof("TPL")

	n:=1
	aCols   := aClone(aCoBrw4)
	aHeader := aClone(aHoBrw4)
	oBrw5:oBrowse:Default()
	oBrw5:oBrowse:Refresh()

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fTrbEtapa ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 23/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Monta o Markbrowse do STQ                                   |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fTrbEtapa()

	Local aHoBrws  	:= NGHeader("STQ", {"TQ_FILIAL","TQ_NOMSITU", "TQ_OK"}, .F.)
	Local nXX      	:= 0
	Local nInd     	:= 0
	Local nTot     	:= 0
	Local nTamanho 	:= 0
	Local nDecimal 	:= 0
	Local cCampo   	:= ""
	Local cArquivo 	:= ""
	Local cTipo    	:= ""
	Local aInd435a  := {}

	aDBF  := {}
	aTRBQ := {}

	aAdd(aDBF, {"TQ_OK","C",02, 0 })
	aAdd(aTRBQ,{"TQ_OK",Nil," ",,,,,,,})

	lTemExec := .F.
	lCpo001	 := .T.
	lCpo002	 := .T.
	lCpo003	 := .T.
	lCpo004	 := .T.
	lCpo005	 := .T.
	lCpo006	 := .T.
	lCpo007 := .T.

	For nXX := 1 To Len(aHoBrws)

		If Alltrim(aHoBrws[nXX,2]) == "TQ_TAREFA"
			lCpo001 := .F.
		ElseIf Alltrim(aHoBrws[nXX,2]) == "TQ_NOMTARE"
			lCpo002 := .F.
		ElseIf Alltrim(aHoBrws[nXX,2]) == "TQ_ETAPA"
			lCpo003 := .F.
		ElseIf Alltrim(aHoBrws[nXX,2]) == "TQ_NOMETAP"
			aHoBrws[nXX,4] := 40
			lCpo004 := .F.
		ElseIf Alltrim(aHoBrws[nXX,2]) == "TQ_SEQETA"
			lCpo005 := .F.
		ElseIf Alltrim(aHoBrws[nXX,2]) == "TQ_PERCENT"
			lCpo006 := .F.
		ElseIf Alltrim(aHoBrws[nXX,2]) == "TQ_CODFUNC"
			aHoBrws[nXX,1] := STR0066 //"Executante"
			lTemExec := .T.
		ElseIf Alltrim(aHoBrws[nXX,2]) == "TQ_ORDEM" .Or.  Alltrim(aHoBrws[nXX,2]) == "TQ_PLANO"
			aAdd(aDBF, {Alltrim(aHoBrws[nXX,2]),aHoBrws[nXX,8],aHoBrws[nXX,4], aHoBrws[nXX,5] })
			Loop
		ElseIf Alltrim(aHoBrws[nXX,2]) == "TQ_OBSERVA"
			lCpo007 := .F.
		EndIf

		aAdd(aDBF, {Alltrim(aHoBrws[nXX,2]),aHoBrws[nXX,8],aHoBrws[nXX,4], aHoBrws[nXX,5] })
		aAdd(aTRBQ,{Alltrim(aHoBrws[nXX,2]),Nil,aHoBrws[nXX,1],,,,,,,  aHoBrws[nXX,10] })

	Next nXX

	If !lTemExec
		aAdd(aDBF, {"TQ_CODFUNC","C",6, 0 })
		aAdd(aTRBQ,{"TQ_CODFUNC",Nil,STR0066,,,,,,,  " " }) //"Executante"
	EndIf

	If lCpo001
		aAdd(aDBF, {"TQ_TAREFA","C",6, 0 })
		aAdd(aTRBQ,{"TQ_TAREFA",Nil,STR0023,,,,,,,  " " }) //"Tarefa"
	EndIf

	If lCpo002
		aAdd(aDBF, {"TQ_NOMTARE","C",20, 0 })
		aAdd(aTRBQ,{"TQ_NOMTARE",Nil,STR0024,,,,,,,  "V" }) //"Nome Tarefa"
	EndIf

	If lCpo003
		aAdd(aDBF, {"TQ_ETAPA","C",20, 0 })
		aAdd(aTRBQ,{"TQ_ETAPA",Nil,STR0025,,,,,,,  " " }) //"Etapa"
	EndIf

	If lCpo004
		aAdd(aDBF, {"TQ_NOMETAP","C",40, 0 })
		aAdd(aTRBQ,{"TQ_NOMETAP",Nil,STR0026,,,,,,,  "V" }) //"Descr. Etapa"
	EndIf

	If lCpo005
		aAdd(aDBF, {"TQ_SEQETA","C",03, 0 })
		aAdd(aTRBQ,{"TQ_SEQETA",Nil,STR0067,,,,,,,  " " }) //"Seq. Etapa"
	EndIf

	If lCpoPerc
		aAdd(aDBF, {"TQ_PER_OLD","N",03, 0 })
		If lCpo006
			aAdd(aDBF, {"TQ_PERCENT","N",03, 0 })
			aAdd(aTRBQ,{"TQ_PERCENT",Nil,STR0068,,,,,,,  " " }) //"% Concluida"
		EndIf
	EndIf

	If lCpo007
		aAdd(aDBF, {"TQ_OBSERVA","M",10, 0 })
		aAdd(aTRBQ,{"TQ_OBSERVA",Nil,STR0060,,,,,,,  " " }) //"Observação"
	EndIf
	//Campos de uso exclusivo da Legenda
	aAdd(aDBF, {"CODBEM"	,"C",16, 0 })
	aAdd(aDBF, {"SEQRELA"	,"N",03, 0 })
	aAdd(aDBF, {"QUANTID"	,"N",09, 0 })
	aAdd(aDBF, {"STATUS"	,"C",01, 0 })

	aInd435a := {{ 'TQ_TAREFA', 'TQ_SEQETA', 'TQ_ETAPA' },;
				{ 'TQ_TAREFA', 'TQ_ETAPA', 'TQ_SEQETA' },;
				{ 'TQ_SEQTARE', 'TQ_SEQETA', 'TQ_TAREFA', 'TQ_ETAPA' }}

	//Criação Tabela Temporária
	oTmpTbl3 := NGFwTmpTbl( cTRBQ400, aDBF, aInd435a )

	aDBFTar := {}
	aAdd(aDBFTar,{"TAREFA" ,"C",06,0})
	aAdd(aDBFTar,{"NOMETAR","C",20,0})
	aAdd(aDBFTar,{"ETAPA"  ,"C",06,0})
	aAdd(aDBFTar,{"NOMEETA","C",40,0})
	aAdd(aDBFTar,{"ORDEM"  ,"C",06,0})
	aAdd(aDBFTar,{"DTMPINI","D",08,0})

	//Indice Tabela Temporária
	aInd435d := {{"DTMPINI","TAREFA","ETAPA","ORDEM"},{"TAREFA","ETAPA"}}
	//Criação Tabela Temporária
	oTmpTbl4 := NGFwTmpTbl(cTRBTAR,aDBFTar,aInd435d)

	aDBF3 := TPC->( dbStruct() )

	aAdd(aDBF3,{"TPC_RESPOS","C",10,0})
	aAdd(aDBF3,{"TPC_OK"    ,"C",2,0})
	aAdd(aDBF3,{"TPC_TAREFA","C",6,0})

	aCposAlTPQ := {}
	If ExistBlock("NG405CPU")
		aCposAlTPQ := ExecBlock("NG405CPU",.F.,.F.)
	EndIf

	//--------------------------------------------------------
	//Agrega no array aHeader os campos de Usuarios...
	//--------------------------------------------------------
	nTot := Len(aCposAlTPQ)
	For nInd := 1 To nTot

		cCampo   := aCposAlTPQ[nInd]
		cArquivo := Posicione("SX3",2,cCampo,"X3_ARQUIVO")
		If (cArquivo)->(FieldPos(cCampo)) > 0

			cTipo    := Posicione("SX3",2,cCampo,"X3_TIPO")
			nTamanho := TAMSX3(cCampo)[1]
			nDecimal := TAMSX3(cCampo)[2]

			aAdd(aDBF3,{cCampo,cTipo,nTamanho,nDecimal})

		EndIf

	Next nInd


	//Criação Tabela Temporária
	oTmpTbl5 := NGFwTmpTbl(cTRB3400,aDBF3,{{ "TPC_ETAPA","TPC_TAREFA","TPC_OPCAO" }})

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} LoadEtapas
Carrega as etapas da OS - STQ

@author  Denis Hyroshi de Souza
@since   23/06/08
@version P11/P12
@param   _cOrdem, Caracter, Código da O.S.
@param   _cPlano, Caracter, Plano
@param   nLisOS , Numérico, Linha posicionada na grid de O.S.
/*/
//-------------------------------------------------------------------
Static Function LoadEtapas(_cOrdem,_cPlano, nLinOS)

	Local i,xx,nXXX
	Local cAliasQry := ''
	Local lTemTb8   := Type("aDadosOS["+Alltrim(Str(nLinOS))+",8]") != "A"
	Local lTemTb9   := Type("aDadosOS["+Alltrim(Str(nLinOS))+",9]") != "A"
	Local aTempCab

	// [aDadosOS]
	// 1-Ordem / 2-Plano / 3-Previstos SALVO[] / 4-Realizados SALVO[] / 5-Realizados NOVO[]
	// 6-Motivos Atraso SALVO[] / 7-Motivos Atraso NOVO[] / 8-Etapas NOVO[] / 9-Etapas Outras OS[]

	dbSelectArea(cTRBQ400)
	Zap
	dbSelectArea(cTRB3400)
	Zap
	dbSelectArea(cTRBTAR)
	Zap

	dbSelectArea("STJ")
	dbSetOrder(1)
	dbSeek(xFilial("STJ")+_cOrdem+_cPlano)

	Inclui := .F.

	//+----------------------------------+
	//| Carregando etapas de outras OS   |
	//+----------------------------------+
	If lTemTb9

		If cMVPAR01 $ '1/3'
			
			cAliasQry := GetNextAlias()
			
			If cMVPAR01 == '1'

				cQuery := " SELECT STQ.TQ_TAREFA, STQ.TQ_ETAPA, STQ.TQ_ORDEM, STJ.TJ_CODBEM,"
				cQuery += " STJ.TJ_SERVICO, STJ.TJ_SEQRELA,STJ.TJ_DTMPINI, STJ.TJ_PLANO, TPA.TPA_DESCRI,"
				cQuery += " CASE WHEN STJ.TJ_PLANO = '000000' THEN
				cQuery += "    ( SELECT TT9_DESCRI FROM " + RetSqlName( 'TT9' ) + " WHERE TT9_FILIAL = " + ValToSql( xFilial( 'TT9' ) )
				cQuery += "            AND TT9_TAREFA = STQ.TQ_TAREFA AND D_E_L_E_T_ <> '*' )
				cQuery += " ELSE
				cQuery += "    ( SELECT T5_DESCRIC FROM " + RetSqlName( 'ST5' ) + " WHERE T5_FILIAL = " + ValToSql( xFilial( 'ST5' ) )
				cQuery += "            AND T5_CODBEM = STJ.TJ_CODBEM AND T5_TAREFA = STQ.TQ_TAREFA "
				cQuery += "            AND T5_SERVICO = STJ.TJ_SERVICO AND T5_SEQRELA = STJ.TJ_SEQRELA AND D_E_L_E_T_ <> '*' )"
				cQuery += " END AS TARDESCRI "
				cQuery += " FROM " + RetSQLName("STQ") + " STQ"
				cQuery += " INNER JOIN "+RetSqlName("STJ")+" STJ"
				cQuery += " ON (STQ.TQ_ORDEM = STJ.TJ_ORDEM) "
				cQuery += " INNER JOIN " + RetSQLName( "TPA" ) + " TPA "
				cQuery += " ON ( TPA.TPA_ETAPA = STQ.TQ_ETAPA )
				cQuery += " WHERE STJ.TJ_CODBEM = '"+STJ->TJ_CODBEM+"'"
				cQuery += " AND STQ.TQ_OK = ''"
				cQuery += " AND (STQ.TQ_TAREFA <> '' OR STQ.TQ_ETAPA <> '') "
				cQuery += " AND STJ.TJ_ORDEM <> '"+_cOrdem+"' AND STJ.TJ_TERMINO = 'S' "
				cQuery += " AND STQ.TQ_FILIAL = '"+xFilial("STQ")+"' AND STQ.D_E_L_E_T_<>'*' "
				cQuery += " AND STJ.TJ_FILIAL = '"+xFilial("STJ")+"' AND STJ.D_E_L_E_T_<>'*' "
				cQuery += " AND TPA.TPA_FILIAL = " + ValToSQL( xFilial( 'TPA' ) ) + " AND TPA.D_E_L_E_T_ <> '*' "
				cQuery := ChangeQuery(cQuery)
				dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)
		
			Else
				BeginSQL Alias cAliasQry

					SELECT  STQ.TQ_TAREFA,
							STQ.TQ_ETAPA,
							STQ.TQ_ORDEM,
							STJ.TJ_CODBEM,
							STJ.TJ_SERVICO,
							STJ.TJ_SEQRELA,
							STJ.TJ_DTMPINI,
							STJ.TJ_PLANO,
							TPA.TPA_DESCRI,
							CASE
								WHEN STJ.TJ_PLANO = '000000' THEN ( SELECT TT9_DESCRI
																	FROM   %table:TT9%
																	WHERE  TT9_FILIAL = %xFilial:TT9%
																	AND TT9_TAREFA = STQ.TQ_TAREFA
																	AND %NotDel% )
								ELSE ( SELECT T5_DESCRIC
									FROM   %table:ST5%
									WHERE  T5_FILIAL = %xFilial:ST5%
											AND T5_CODBEM  = STJ.TJ_CODBEM
											AND T5_TAREFA  = STQ.TQ_TAREFA
											AND T5_SERVICO = STJ.TJ_SERVICO
											AND T5_SEQRELA = STJ.TJ_SEQRELA
											AND %NotDel% )
							END AS TARDESCRI
							FROM   %table:STJ% STJ
								INNER JOIN %table:STQ% STQ
										ON ( STJ.TJ_FILIAL = STQ.TQ_FILIAL
												AND STJ.TJ_ORDEM  = STQ.TQ_ORDEM
												AND STJ.TJ_CODBEM = %exp:STJ->TJ_CODBEM% )
								INNER JOIN %table:TPA% TPA
										ON ( TPA.TPA_ETAPA = STQ.TQ_ETAPA )
							WHERE  STQ.TQ_OK = ' '
								AND STJ.TJ_TERMINO = 'S'
								AND STJ.TJ_ORDEM  != %exp:_cOrdem%
								AND STQ.TQ_FILIAL  = %xFilial:STQ%
								AND STQ.%NotDel%
								AND STJ.TJ_FILIAL  = %xFilial:STJ%
								AND STJ.%NotDel%
								AND STJ.TJ_DTMRFIM || STJ.TJ_HOMRFIM = ( SELECT Max( STJ1.TJ_DTMRFIM || STJ1.TJ_HOMRFIM )
																		FROM  %table:STQ% STQ1
									INNER JOIN %table:STJ% STJ1
											ON ( STQ1.TQ_FILIAL = STJ1.TJ_FILIAL
													AND STQ1.TQ_ORDEM = STJ1.TJ_ORDEM )
									WHERE  STQ1.TQ_OK = ' '
										AND STQ1.TQ_FILIAL  = %xFilial:STQ%
										AND STQ1.%NotDel%
										AND STJ1.TJ_FILIAL  = %xFilial:STJ%
										AND STJ1.%NotDel%
										AND STJ1.TJ_TERMINO = 'S'
										AND STJ1.TJ_CODBEM  = %exp:STJ->TJ_CODBEM%
										AND STJ1.TJ_DTMRFIM || STJ1.TJ_HOMRFIM < %exp:DToS( dDataBase ) + SubStr( Time(), 1, 5 )%
										AND STQ1.TQ_TAREFA  = STQ.TQ_TAREFA
										AND STQ1.TQ_ETAPA   = STQ.TQ_ETAPA )
										AND STQ.TQ_TAREFA NOT IN ( SELECT STQ2.TQ_TAREFA
															FROM   %table:STQ% STQ2
																	INNER JOIN %table:STJ% STJ2
																			ON ( STQ2.TQ_FILIAL = STJ2.TJ_FILIAL
																				AND STQ2.TQ_ORDEM = STJ2.TJ_ORDEM )
															WHERE  STQ2.TQ_OK != ' '
																	AND STJ2.TJ_DTMRFIM || STJ2.TJ_HOMRFIM >=
																		STJ.TJ_DTMRFIM  || STJ.TJ_HOMRFIM
																	AND STQ2.TQ_FILIAL  = %xFilial:STQ%
																	AND STQ2.%NotDel%
																	AND STJ2.TJ_FILIAL  = %xFilial:STJ%
																	AND STJ2.%NotDel%
																	AND STJ2.TJ_TERMINO = 'S'
																	AND STJ2.TJ_CODBEM  = %exp:STJ->TJ_CODBEM%
																	AND STQ2.TQ_TAREFA  = STQ.TQ_TAREFA
																	AND STQ2.TQ_ETAPA   = STQ.TQ_ETAPA  )

								AND STQ.TQ_ETAPA NOT IN (SELECT STQ2.TQ_ETAPA
															FROM   %table:STQ% STQ2
																INNER JOIN %table:STJ% STJ2
																		ON ( STQ2.TQ_FILIAL = STJ2.TJ_FILIAL
																				AND STQ2.TQ_ORDEM = STJ2.TJ_ORDEM )
															WHERE  STQ2.TQ_OK != ' '
																AND STJ2.TJ_DTMRFIM || STJ2.TJ_HOMRFIM >= STJ.TJ_DTMRFIM || STJ.TJ_HOMRFIM
																AND STQ2.TQ_FILIAL  = %xFilial:STQ%
																AND STQ2.%NotDel%
																AND STJ2.TJ_FILIAL  = %xFilial:STJ%
																AND STJ2.%NotDel%
																AND STJ2.TJ_TERMINO = 'S'
																AND STJ2.TJ_CODBEM  = %exp:STJ->TJ_CODBEM%
																AND STQ2.TQ_TAREFA  = STQ.TQ_TAREFA
																AND STQ2.TQ_ETAPA   = STQ.TQ_ETAPA  )

								AND TPA.TPA_FILIAL = %xFilial:TPA%
								AND TPA.%NotDel%
				EndSQL
			EndIf

			aTempCab := {}
			dbSelectArea(cTRBTAR)
			(cAliasQry)->( dbGoTop() )
			While (cAliasQry)->( !EoF() )

				(cTRBTAR)->(DbAppend())
				(cTRBTAR)->TAREFA  := (cAliasQry)->TQ_TAREFA
				(cTRBTAR)->NOMETAR := (cAliasQry)->TARDESCRI
				(cTRBTAR)->ETAPA   := (cAliasQry)->TQ_ETAPA
				(cTRBTAR)->NOMEETA := (cAliasQry)->TPA_DESCRI
				(cTRBTAR)->ORDEM   := (cAliasQry)->TQ_ORDEM
				(cTRBTAR)->DTMPINI := STOD( (cAliasQry)->TJ_DTMPINI )

				aAdd( aTempCab, {   (cTRBTAR)->TAREFA,;
									(cTRBTAR)->NOMETAR,;
									(cTRBTAR)->ETAPA,;
									(cTRBTAR)->NOMEETA,;
									(cTRBTAR)->ORDEM,;
									(cTRBTAR)->DTMPINI } )

				(cAliasQry)->( dbSkip() )
			EndDo

			(cAliasQry)->( dbCloseArea() )

			If Len(aTempCab) == 0
				aAdd( aTempCab , { " ",;
				" ",;
				" ",;
				" ",;
				" ",;
				StoD("") } )
			EndIf

		EndIf

		If Type("aTempCab") == "A"
			aDadosOS[nLinOS,9] := aClone(aTempCab)
		Else
			aDadosOS[nLinOS,9] := Nil
		EndIf
	Else
		dbSelectArea(cTRBTAR)
		For i := 1 to Len(aDadosOS[nLinOS,9])
			(cTRBTAR)->(DbAppend())
			(cTRBTAR)->TAREFA  := aDadosOS[nLinOS,9,i,1]
			(cTRBTAR)->NOMETAR := aDadosOS[nLinOS,9,i,2]
			(cTRBTAR)->ETAPA   := aDadosOS[nLinOS,9,i,3]
			(cTRBTAR)->NOMEETA := aDadosOS[nLinOS,9,i,4]
			(cTRBTAR)->ORDEM   := aDadosOS[nLinOS,9,i,5]
			(cTRBTAR)->DTMPINI := aDadosOS[nLinOS,9,i,6]
		Next i
	EndIf

	//+---------------------------------------+
	//| Carregando etapas previstas desta OS  |
	//+---------------------------------------+
	If lTemTb8

		aTempCab := {}
		dbSelectArea("STQ")
		dbSetOrder(1)
		dbSeek(xFilial("STQ")+_cOrdem+_cPlano)
		While !EoF() .And. STQ->TQ_FILIAL == xFilial("STQ") .And. STQ->TQ_ORDEM == _cOrdem .And. STQ->TQ_PLANO == _cPlano

			If Empty(STQ->TQ_TAREFA) .And. Empty(STQ->TQ_ETAPA)
				dbSelectArea("STQ")
				dbSkip()
				Loop
			EndIf

			aTemp := {}
			aAdd( aTemp , If(Empty(STQ->TQ_OK),"  ",cMARCA) )

			(cTRBQ400)->(DbAppend())
			For i := 2 To Len(aTRBQ)

				xx := aTRBQ[i,1]

				If aTRBQ[i,10] == 'V'
					(cTRBQ400)->(&xx.) := CriaVar( AllTrim( xx ) )
				ElseIf Posicione( 'SX3', 2, xx , 'X3_CONTEXT' ) != 'V'
					(cTRBQ400)->( &xx. ) := STQ->( &xx. )
				EndIf

				aAdd( aTemp , (cTRBQ400)->( &xx. ) )

			Next i
			(cTRBQ400)->TQ_OK    := If(Empty(STQ->TQ_OK),"  ",cMARCA)
			(cTRBQ400)->TQ_ORDEM := _cOrdem
			(cTRBQ400)->TQ_PLANO := _cPlano
			(cTRBQ400)->CODBEM		:= STJ->TJ_CODBEM
			cTarefa := STQ->TQ_TAREFA

			//Adicionando opcoes da etapa
			aOpcEtapa := {}
			dbSelectArea("TPQ")
			dbSetOrder(1)
			dbSeek(xFilial("TPQ") + _cOrdem +_cPlano + STQ->TQ_TAREFA + STQ->TQ_ETAPA )
			While !EoF() .And. TPQ->TPQ_FILIAL == xFilial("TPQ") .And.;
			TPQ->TPQ_ORDEM == _cOrdem .And. TPQ->TPQ_PLANO == _cPlano .And. ;
			TPQ->TPQ_TAREFA == STQ->TQ_TAREFA .And. TPQ->TPQ_ETAPA == STQ->TQ_ETAPA

				aAdd( aOpcEtapa , { "XX" , TPQ->TPQ_OPCAO , TPQ->TPQ_RESPOS } )

				dbSelectArea(cTRB3400)
				(cTRB3400)->(DbAppend())
				(cTRB3400)->TPC_ETAPA  := STQ->TQ_ETAPA
				(cTRB3400)->TPC_TAREFA := STQ->TQ_TAREFA
				(cTRB3400)->TPC_OK     := "XX"
				(cTRB3400)->TPC_OPCAO  := TPQ->TPQ_OPCAO
				(cTRB3400)->TPC_RESPOS := TPQ->TPQ_RESPOS

				dbSelectArea("TPQ")
				dbSkip()
			EndDo

			fLegendEt(cTarefa+(cTRBQ400)->TQ_ETAPA+(cTRBQ400)->TQ_SEQETA) //Define as cores para legenda de etapas
			aAdd( aTemp , aOpcEtapa )
			aAdd( aTemp , (cTRBQ400)->STATUS )//STATUS#//MANTER A CRIAÇÃO DO CAMPO STATUS SEMPRE COMO ULTIMO NA TRB
			aAdd( aTempCab , aTemp )

			dbSelectArea("STQ")
			dbSkip()
		EndDo

		aDadosOS[nLinOS,8] := aClone(aTempCab)

	Else
		dbSelectArea(cTRBQ400)
		For nXXX := 1 to Len(aDadosOS[nLinOS,8])

			(cTRBQ400)->(DbAppend())
			For i := 2 To Len(aTRBQ)

				xx := aTRBQ[i,1]
				
				(cTRBQ400)->( &xx. ) := aDadosOS[nLinOS,8,nXXX,i]

			Next i

			(cTRBQ400)->TQ_OK  := aDadosOS[nLinOS,8,nXXX,1]
			(cTRBQ400)->STATUS := aDadosOs[nLinOS,8,nXXX,Len(aDadosOS[nLinOS,8,nXXX])]
			(cTRBQ400)->TQ_ORDEM := _cOrdem
			(cTRBQ400)->TQ_PLANO := _cPlano

		Next nXXX
	EndIf


	If cMVPAR01 == '3'

		dbSelectArea(cTRBQ400)
		dbSetOrder(1)
		dbGotop()
		While !EoF()
			dbSelectArea(cTRBTAR)
			dbSetOrder(2)
			If dbSeek( (cTRBQ400)->TQ_TAREFA + (cTRBQ400)->TQ_ETAPA )
				RecLock((cTRBTAR),.F.)
				dbDelete()
				(cTRBTAR)->(MsUnLock())
			EndIf

			dbSelectArea(cTRBQ400)
			dbSkip()
		EndDo

	EndIf

	Inclui := .T.

	dbSelectArea(cTRBQ400)
	dbSetOrder(3) // ordena visualização das etapas pela sequencia tarefa + etapa
	dbGotop()
	oBrw4:oBrowse:Refresh()
	oBrw4:oBrowse:Refresh()

	dbSelectArea(cTRBTAR)
	dbSetOrder(1)
	dbGotop()

	oBrw7:Refresh()

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ FilSTJ435³ Autor ³Denis Hyroshi de Souza ³ Data ³ 23/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Filtragem da tabela STJ                                    |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FilSTJ435(nOrdem435,nTipoFil)

	Local cOldFil := cFiltSTJ

	If nTipoFil == 1
		LoadRegAOS("",nOrdem435,.T.,.F.,nTipoFil)
	ElseIf nTipoFil == 2
		LoadRegAOS(RTrim(cChave435),nOrdem435,.T.,.F.,nTipoFil)
	ElseIf nTipoFil == 3
		oDlg1:LESCCLOSE := .F.
		cFiltSTJ := BuildExpr("STJ")
		Set Filter to &cFiltSTJ
		If cOldFil <> cFiltSTJ
			LoadRegAOS("",nOrdem435,.T.,.F.,nTipoFil)
		EndIf
	EndIf

	If !Empty(aOS) .And. aOS[1][1] > 0 //Habilita ou desabilita a de seleção de índice, o campo e o botão de busca, e alguns botões da barra de botões

	If ValType(oBtRdz) == "O"
		oBtRdz:Enable()
	EndIf
	If ValType(oBtCOS) == "O"
		oBtCOS:Enable()
	EndIf
	If ValType(oBtFOS) == "O"
		oBtFOS:Enable()
	EndIf
	If ValType(oBtBCn) == "O"
		oBtBCn:Enable()
	EndIf
	If ValType(oBtGrv) == "O"
		oBtGrv:Enable()
	EndIf

Else

	If ValType(oBtRdz) == "O"
		oBtRdz:Disable()
	EndIf
	If ValType(oBtCOS) == "O"
		oBtCOS:Disable()
	EndIf
	If ValType(oBtFOS) == "O"
		oBtFOS:Disable()
	EndIf
	If ValType(oBtBCn) == "O"
		oBtBCn:Disable()
	EndIf
	If ValType(oBtGrv) == "O"
		oBtGrv:Disable()
	EndIf

EndIf
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³LoadRegAOS³ Autor ³Denis Hyroshi de Souza ³ Data ³ 23/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Cria arquivo de trabalho para O.S.                          |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function LoadRegAOS(cChave435,nOrdem435,lAltFiltro,lLocalizar,TipoCham)

	Local nX,aTemp,nPos
	Local lRetTmp    := .F.
	Local lEntrou    := .F.
	Local cAliasFil	 := ""
	Local cSerefor  := Alltrim(GETMV("MV_NGSEREF"))
	Local cSercons  := Alltrim(GETMV("MV_NGSECON"))
	Local aAreaTRBTJ := {}

	Private cCond_PE := ""

	If ExistBlock("MNTA4006")
		cCondxPE := ExecBlock("MNTA4006",.F.,.F.)
		If ValType(cCondxPE) == "C" .And. !Empty(cCondxPE)
			If Substr(Alltrim(cCondxPE),1,5) == ".And."
				cCond_PE := SubStr(Alltrim(cCondxPE),6)
			ElseIf Substr(Alltrim(cCondxPE),1,4) == ".Or."
				cCond_PE := SubStr(Alltrim(cCondxPE),5)
			Else
				cCond_PE := Alltrim(cCondxPE)
			EndIf
		EndIf
	EndIf

	If ValType(cChave435) == "U"

		fEmptyOS(.F.)

	ElseIf Len(aChave435) >= nOrdem435 .And. nOrdem435 > 0

		oDlg1:LESCCLOSE := .F.

		If lAltFiltro
			If lFoiAlterado
				nRetAviso := Aviso(STR0037,STR0069, ; //"Atenção"###"Existem alterações que ainda não foram processadas. Deseja gravá-las ou desfazê-las?"
				{STR0070,STR0071,STR0072}) //"Gravar"###"Desfazer"###"Cancelar"
				If nRetAviso == 1
					If fValidOK(@lRetTmp,.F.)
						Processa({|| fGrava435(,.T.) } , STR0002 ) //"Gravando as informações"
					Else
						Return .T.
					EndIf
				ElseIf nRetAviso == 3
					Return .F.
				EndIf
				lFoiAlterado := .F.
			EndIf
		ElseIf lLocalizar
			lFlagMsg := .F.
			If Len(aOS) > 0 .And. Len(aBlockInd) >= nOrdem435
				If Len(aOS) > 1 .Or. !Empty(aOS[1,nPosOS])
					If !Empty(cChave435)
						nPos := aScan(aOS , &("{|x| Substr("+aBlockInd[nOrdem435,2]+",1,"+Str(Len(cChave435),3)+") == '"+cChave435+"' }") )
						If nPos > 0
							oOS:nAt := nPos
							oOS:Refresh()
							M->TJ_ORDEM := aOS[oOS:nAt,nPosOS]
							M->TJ_PLANO := aOS[oOS:nAt,nPosPL]
							cOrdemTJ    := M->TJ_ORDEM
							cPlanoTJ    := M->TJ_PLANO
							fRefreshOS( cOrdemTJ , cPlanoTJ , oOS:nAt, 1 )
							oOS:Refresh()
							lFlagMsg := .T.
						Else
							Help("",1,"PESQ01")
						EndIf
					Else
						MsgInfo(STR0073,STR0037) //"Campo de busca está vazio!"###"Atenção"
						Return .F.
					EndIf
					Return .T.
				EndIf
			EndIf

			If !lFlagMsg
				MsgInfo(STR0074+Chr(13)+STR0075,STR0037) //"A lista de O.S. está vazia."###"Clique no botão Filtrar O.S. para selecionar ordens de serviço."###"Atenção"
			EndIf

		EndIf

		If !lLocalizar

			If TipoCham == 2 .And. Empty(cChave435)
				MsgInfo(STR0073,STR0037) //"Campo de busca está vazio!"###"Atenção"
				Return .F.
			EndIf

			CursorWait()

			lPrimSTJ := .T.

			If TipoCham == 3
				dbSelectArea("STJ")
				dbSetOrder(nOrdem435)
				If dbSeek(xFilial("STJ"),.T.)
					While !EoF() .And. xFilial("STJ") == STJ->TJ_FILIAL

						Inclui     := .F.
						lEntrou    := .T.
						aAreaTRBTJ := STJ->(GetArea())

						If STJ->TJ_SITUACA == "L" .And. STJ->TJ_TERMINO == "N" .And. Empty(STJ->TJ_ORDEPAI) .And.;
							STJ->TJ_SERVICO <> cSerefor .And. STJ->TJ_SERVICO <> cSercons .And. STJ->TJ_LUBRIFI <> 'S'

							If !Empty(cCond_PE)
								If &(cCond_PE) == .F.
									RestArea(aAreaTRBTJ)
									dbSelectArea("STJ")
									dbSkip()
									Loop
								EndIf
							EndIf

							If lPrimSTJ
								aOS       := {}
								aDadosOS  := {}
								cTJ_ORDEM := STJ->TJ_ORDEM
								cTJ_PLANO := STJ->TJ_PLANO
								lPrimSTJ  := .F.
							EndIf

							M->TJ_ORDEM   := STJ->TJ_ORDEM
							M->TJ_PLANO   := STJ->TJ_PLANO
							M->TJ_TIPOOS  := STJ->TJ_TIPOOS
							M->TJ_CODBEM  := STJ->TJ_CODBEM
							M->TJ_SERVICO := STJ->TJ_SERVICO
							M->TJ_NOMBEM  := NGSEEK("ST9",STJ->TJ_CODBEM,1,"ST9->T9_NOME")
							aTemp := {}
							For nX := 1 To Len(aCampStj)
								If nX == 1
									vVetRCor := NGCOROSLENG()
									aAdd(aTemp,vVetRCor[1])
								ElseIf nX == 2 .And. Len(aCores2) > 0
									If AllTrim(STJ->TJ_PRIORID) = '1'
										aAdd(aTemp,'1')
									ElseIf AllTrim(STJ->TJ_PRIORID) = '2'
										aAdd(aTemp,'2')
									ElseIf AllTrim(STJ->TJ_PRIORID) = '3'
										aAdd(aTemp,'3')
									Else
										aAdd(aTemp,'0')
									EndIf
								ElseIf !Empty(aCampStj[nX])
									If aVisuStj[nX] == "V"
										aAdd(aTemp,CriaVar(AllTrim(aCampStj[nX])))
									Else
										aAdd(aTemp,&("STJ->"+aCampStj[nX]))
									EndIf
								Else
									aAdd(aTemp," ")
								EndIf
							Next nX
							aAdd(aOS,aTemp)
							// 1-Ordem / 2-Plano / 3-Previstos SALVO[] / 4-Realizados SALVO[] / 5-Realizados NOVO[]
							// 6-Motivos Atraso SALVO[] / 7-Motivos Atraso NOVO[] / 8-Etapas NOVO[] / 9-Etapas Outras OS[]
							aAdd(aDadosOS,{STJ->TJ_ORDEM,STJ->TJ_PLANO,NIL,NIL,NIL,NIL,NIL,NIL,NIL})
						EndIf
						dbSelectArea("STJ")
						dbSkip()
					End
				EndIf
			Else

				cAliasFil := fRetQuery(aChave435[nOrdem435],cChave435)
				
				dbSelectArea(cAliasFil)
				dbGoTop()
				While !EoF()

					Inclui     := .F.
					lEntrou    := .T.
					aAreaTRBTJ := (cAliasFil)->(GetArea())
					dbSelectArea("STJ")
					dbGoTo((cAliasFil)->R_E_C_N_O_)

					If !Empty(cCond_PE)
						If &(cCond_PE) == .F.
							RestArea(aAreaTRBTJ)
							dbSelectArea(cAliasFil)
							dbSkip()
							Loop
						EndIf
					EndIf

					//Valida permissao do usuario quando esta' na Arvore Logica ou Planta Grafica
					If IsInCallStack("MNTA902") .Or. IsInCallStack("MNTA907")
						If !NGValidTUA("STJ")
							RestArea(aAreaTRBTJ)
							dbSelectArea(cAliasFil)
							dbSkip()
							Loop
						EndIf
					EndIf

					If lPrimSTJ
						aOS       := {}
						aDadosOS  := {}
						cTJ_ORDEM := STJ->TJ_ORDEM
						cTJ_PLANO := STJ->TJ_PLANO
						lPrimSTJ  := .F.
					EndIf

					M->TJ_ORDEM   := STJ->TJ_ORDEM
					M->TJ_PLANO   := STJ->TJ_PLANO
					M->TJ_TIPOOS  := STJ->TJ_TIPOOS
					M->TJ_CODBEM  := STJ->TJ_CODBEM
					M->TJ_SERVICO := STJ->TJ_SERVICO
					M->TJ_NOMBEM  := NGSEEK("ST9",STJ->TJ_CODBEM,1,"ST9->T9_NOME")
					aTemp := {}
					For nX := 1 To Len(aCampStj)
						If nX == 1
							vVetRCor := NGCOROSLENG()
							aAdd(aTemp,vVetRCor[1])
						ElseIf nX == 2 .And. Len(aCores2) > 0
							If AllTrim(STJ->TJ_PRIORID) = '1'
								aAdd(aTemp,'1')
							ElseIf AllTrim(STJ->TJ_PRIORID) = '2'
								aAdd(aTemp,'2')
							ElseIf AllTrim(STJ->TJ_PRIORID) = '3'
								aAdd(aTemp,'3')
							Else
								aAdd(aTemp,'0')
							EndIf
						ElseIf !Empty(aCampStj[nX])
							If aVisuStj[nX] == "V"
								aAdd(aTemp,CriaVar(AllTrim(aCampStj[nX])))
							Else
								aAdd(aTemp,&("STJ->"+aCampStj[nX]))
							EndIf
						Else
							aAdd(aTemp," ")
						EndIf
					Next nX
					aAdd(aOS,aTemp)
					// 1-Ordem / 2-Plano / 3-Previstos SALVO[] / 4-Realizados SALVO[] / 5-Realizados NOVO[]
					// 6-Motivos Atraso SALVO[] / 7-Motivos Atraso NOVO[] / 8-Etapas NOVO[] / 9-Etapas Outras OS[]
					aAdd(aDadosOS,{STJ->TJ_ORDEM,STJ->TJ_PLANO,NIL,NIL,NIL,NIL,NIL,NIL,NIL})
					RestArea(aAreaTRBTJ)
					dbSelectArea(cAliasFil)
					dbSkip()
				End

			EndIf

			If lEntrou
				If !lPrimSTJ
					M->TJ_ORDEM := cTJ_ORDEM
					M->TJ_PLANO := cTJ_PLANO
					cOrdemTJ    := M->TJ_ORDEM
					cPlanoTJ    := M->TJ_PLANO
					fRefreshOS( cTJ_ORDEM , cTJ_PLANO , 1 , 1 )

					ASort(aOS, , , {|x,y|x[2] < y[2]})
					oOS:SetArray(aOS)
					bOSLine1  := { || &(cDefLista)}
					oOS:GoTop()
					oOS:bLine := bOSLine1
					oOS:Refresh()
				EndIf
				Inclui := .T.
			Else
				MsgInfo( STR0382 , STR0037 ) //"Não foram encontradas O.S. abertas para essa pesquisa."###"Atenção"
			EndIf
			CursorArrow()
			oOS:SetFocus()
		EndIf
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fPFiltro ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 23/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Cria a tela de funcionarios da especialidade                |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fPFiltro(cCod_Esp,nQtRec,dDtIniTL)

	Local oDlg2,oOS2,aOS2 := {},oSayEspe
	Local lOutraEsp := .F.
	Local aTemp
	Local nXX
	Local cPesquisar := Space( 200 )
	Local aDescIdx	:= {"Código","Nome"}

	Private cCodEspec := Padr(cCod_Esp,Len(ST2->T2_ESPECIA))
	Private cQtdEspec := If(Valtype(nQtRec)=="N",If(nQtRec>0,nQtRec,1),1)
	Private nPosCpo1 := 0

	Private aCbxPesq //ComboBox com indices de pesquisa
	Private cCbxPesq   := ""
	Private oCbxPesq //ComboBox de Pesquisa

	dbSelectArea("ST0")
	dbSetOrder(1)
	dbSeek(xFilial("ST0")+cCodEspec)

	nOpcFun := 0
	Define MsDialog oDlg2 Title OemToAnsi(STR0076) From 089,232 To 407,619 Of oMainWnd Pixel //"Funcionários"

	aCbxPesq := aClone( aDescIdx )
	cCbxPesq := aCbxPesq[ 1 ]

	@ 002,004 Say STR0077 of oDlg2 Font oFont2 Pixel COLOR CLR_BLUE  //"Especialidade:"
	@ 002,070 Say oSayEspe Prompt ST0->T0_NOME of oDlg2 Font oFont2 Pixel COLOR CLR_BLACK
	@ 013,004 Say STR0078 of oDlg2 Font oFont2 Pixel COLOR CLR_BLUE  //"Quantidade:"
	@ 013,070 Say nQtRec of oDlg2 Font oFont2 Pixel COLOR CLR_BLACK

	oPesquisar := TGet():New( 024 , 004 , { | u | If( PCount() > 0 , cPesquisar := u , cPesquisar ) } , oDlg2 , 110 , 008 , "" , { | | .T. } , CLR_BLACK , CLR_WHITE , ,;
	.F. , , .T. /*lPixel*/ , , .F. , { | | cCbxPesq <> aCbxPesq[ Len( aCbxPesq ) ] }/*bWhen*/ , .F. , .F. , , .F. /*lReadOnly*/ , .F. , "" , "cPesquisar" , , , , .F. /*lHasButton*/ )

	oBtnPesq := TButton():New( 024 , 127 , STR0181 , oDlg2 , { | | fPesqEsp( @aOS2 , @oOS2, cPesquisar ) } , ;
	60 , 10 , , , .F. , .T. , .F. , , .F. , , , .F. )

	@ 035,004 ListBox oOS2 Fields;
	Header  " ",;
	STR0079,; //"Código"
	STR0080; //"Nome"
	Size    184,094 Of oDlg2 Pixel

	bOS2Line1 := { || { If(aOS2[oOS2:nAt,1]==1,oChecked,oBranco),aOS2[oOS2:nAt,2],aOS2[oOS2:nAt,3] } }
	bOS2Line2 := { || { oBranco, Space(6), Space(40) } }
	oOS2:SetArray( aOS2 )
	IIF(Len(aOS2)>0,oOS2:bLine:= bOS2Line1,oOS2:bLine:= bOS2Line2)
	oOS2:bLDblClick := {|| fMarkFunc(@oOS2,@aOS2) , oOS2:DrawSelect() }
	oOS2:GoTop()
	oOS2:Refresh()

	fShowFunc(@oOS2,@aOS2,@oSayEspe,lOutraEsp,dDtIniTL)

	@ 142, 004 CheckBox oCBox1 Var lOutraEsp Prompt STR0081 Of oDlg2 On Change fShowFunc(@oOS2,@aOS2,@oSayEspe,lOutraEsp,dDtIniTL) Pixel SIZE 80,09 //"Outra Especialidade?"

	Define sButton oBtOk  from 142, 126 type 1 enable of oDlg2 pixel Action ( nOpcFun:=1,If(fVldMkFun(@oOS2,@aOS2,nQtRec),oDlg2:End(),nOpcFun:=2) )
	Define sButton oBtCan from 142, 156 type 2 enable of oDlg2 pixel Action (nOpcFun:=2,oDlg2:End())

	oDlg2:Activate(,,,.T.)

	If nOpcFun == 1
		aTemp := {}
		For nXX := 1 To Len(aOS2)
			If aOS2[nXX,1] == 1
				aAdd( aTemp , aOS2[nXX,2] )
			EndIf
		Next aOS2
		Return aTemp
	EndIf

Return nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fVldMkFun³ Autor ³Denis Hyroshi de Souza ³ Data ³ 23/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Valida tela de selecao dos funcionarios                    |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fVldMkFun(oOS2,aOS2,nQtRec)
	Local nXX,nCont := 0

	For nXX := 1 To Len(aOS2)
		If aOS2[nXX,1] == 1
			nCont++
		EndIf
	Next aOS2

	If nCont <> nQtRec
		If !MsgYesNo(STR0082+; //"A quantidade de funcionários selecionados não corresponde à quantidade prevista. Deseja continuar?"
		Chr(13)+Chr(10)+STR0083+Alltrim(Str(nQtRec,6))+; //"Qtde. Prevista: "
		Chr(13)+Chr(10)+STR0084+Alltrim(Str(nCont,6)) ) //"Qtde. Selecionada: "
			Return .F.
		EndIf
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fMarkFunc³ Autor ³Denis Hyroshi de Souza ³ Data ³ 23/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Mostra um funcionario                                       |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fMarkFunc(oOS2,aOS2)
	If aOS2[oOS2:nAt][1] == 0
		aOS2[oOS2:nAt][1] := 1
	Else
		aOS2[oOS2:nAt][1] := 0
	EndIf
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fShowFunc³ Autor ³Denis Hyroshi de Souza ³ Data ³ 23/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Mostra todos os funcionarios                                |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fShowFunc(oOS2,aOS2,oSayEspe,lOutraEsp,dDtIniTL)
	Local dDtIni2 := If( Valtype(dDtIniTL)<>"D" .Or. Empty(dDtIniTL) , dDataBase , dDtIniTL )

	aOS2 := {}

	IF lOutraEsp

		dbSelectArea("ST1")
		dbSetOrder(1)
		dbSeek(xFilial("ST1"))
		While !EoF() .And. xFilial("ST1") == ST1->T1_FILIAL
			If !NGFUNCRH(ST1->T1_CODFUNC,.F.,dDtIni2)
				dbSelectArea("ST1")
				dbSkip()
				Loop
			EndIf
			If ST1->T1_DISPONI <> "N"
				aAdd(aOS2,{0,ST1->T1_CODFUNC, ST1->T1_NOME })
			EndIf
			dbSkip()
		End

		oSayEspe:SetText(STR0085) //"TODAS"

	Else

		dbSelectArea("ST2")
		dbSetOrder(2)
		dbSeek(xFilial("ST2")+cCodEspec)
		While !EoF() .And. xFilial("ST2") == ST2->T2_FILIAL .And. cCodEspec == ST2->T2_ESPECIA
			dbSelectArea("ST1")
			dbSetOrder(1)
			dbSeek(xFilial("ST1")+ST2->T2_CODFUNC)
			If !NGFUNCRH(ST2->T2_CODFUNC,.F.,dDtIni2)
				dbSelectArea("ST2")
				dbSkip()
				Loop
			EndIf
			If ST1->T1_DISPONI <> "N"
				aAdd(aOS2,{0,ST1->T1_CODFUNC, ST1->T1_NOME })
			EndIf
			dbSelectArea("ST2")
			dbSkip()
		End

		oSayEspe:SetText(ST0->T0_NOME)

	EndIf

	oOS2:SetArray( aOS2 )
	IIF(Len(aOS2)>0,oOS2:bLine:= bOS2Line1,oOS2:bLine:= bOS2Line2)
	oOS2:GoTop()
	oOS2:Refresh()

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fPrgNext ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 30/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Adiciona todos os insumos previstos em Realizados          |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fPrgNext(oChv435)

	Local aCodFunc 	:= {}
	Local cProdBloq := ''
	Local cTypeHr   := ''
	Local cCodInsum := ''
	Local cNGMNTES	:= SuperGetMv( 'MV_NGMNTES', .F., 'N' )
	Local cLocPad := SuperGetMV( 'MV_NGLOCPA', .F., '01' )
	Local lTemSC1 	:= .F.
	Local nYY 		:= 0
	Local nZZZ 		:= 0
	Local nQtdCvrt  := 0
	Local nSeqTmp 	:= 0
	Local nLenBrw6	:= 0
	Local lMNTA435O	:= ExistBlock( 'MNTA435O' )
	Local lMNTA435R := ExistBlock( 'MNTA435R' )

	Local nPos 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPox 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPoZ 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NOMCODI"})
	Local nPoQ 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANREC"})
	Local nPoY 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TAREFA" })
	Local nPos18 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
	Local nDtIni 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI"})
	Local nDtFim 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM"  })
	Local nCpoGar 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_GARANTI"})
	Local nNumSa  	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSA"  })
	Local nITEMSa  	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_ITEMSA" })
	Local nQuanti  	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANTID"})
	Local nTypeHr   := aScan( aHoBrw2, {|x| Trim( Upper( x[2] ) ) == 'TL_TIPOHOR' } )

	lRet435 := .T.
	oChv435:SetFocus()
	If !lRet435 //Problema encontrado em alguma rotina de validacao da LinhaOK
		Return .F.
	EndIf

	nLenBr6 := Len(aCoBrw6)
	If nLenBr6 == 1
		If Empty(aCoBrw6[1,nPox])
			aCoBrw6 := {}
		EndIf
	ElseIf nLenBr6 > 1
		If Empty(aCoBrw6[nLenBr6,nPox])
			aDel(aCoBrw6,nLenBr6)
			aSize(aCoBrw6,nLenBr6-1)
			oBrw6:lNewLine := .F.
		EndIf
	EndIf

	lFirstMsg := .T.
	dbSelectArea(cTRBIP)
	dbGoTop()
	While !EoF()
		nYY := (cTRBIP)->(Recno())
		If nYY > Len(aCoBrw2)
			dbSelectArea(cTRBIP)
			dbSkip()
			Loop
		EndIf

		lTemSC1 := .F.

		//Verifica se o Insumo possui Solicitação de Armazem
		If aCoBrw2[nYY,nPos] $ "PT" .And. cUsaInt2 == "S" .And. cUsaInt3 == "S"

			If nNumSa > 0 .And. nITEMSa > 0
				dbSelectArea("SCP")
				dbSetOrder(2) //CP_FILIAL+CP_PRODUTO+CP_NUM+CP_ITEM
				If dbSeek( xFilial("SCP") + aCoBrw2[nYY,nPox] + aCoBrw2[nYY,nNumSa] + aCoBrw2[nYY,nITEMSa])

					ShowHelpDlg(STR0174, {STR0344 + Alltrim(aCoBrw2[nYY,nPoZ]) + STR0345+; //"ATENCAO" ## "O insumo " ## "esta relacionado a Solicitação "
					STR0346 + SCP->CP_NUM},1,; //"ao Armazem numero "
					{STR0347+; //"Realizar a aplicação do insumo utilizando a rotina de Baixa Pré-Requisição(MATA185)."
					STR0348},1) //" Excluir/Alterar a Solicitação ao Armazem"
					dbSelectArea(cTRBIP)
					dbSkip()
					Loop

				EndIf
			EndIf

			dbSelectArea("SC1")
			dbSetOrder(4) //C1_FILIAL+C1_OP+C1_NUM+C1_ITEM
			If dbSeek( xFilial("SC1") + cOrdemTJ+"OS001")
				While !Eof() .And. SC1->C1_FILIAL == xFilial("SC1") .And. Alltrim(SC1->C1_OP) == cOrdemTJ+"OS001"

					If SC1->C1_PRODUTO == aCoBrw2[nYY,nPox] .And. aCoBrw2[nYY,nQuanti] == SC1->C1_QUANT

						If !MsgYesNo(STR0344 +Alltrim(aCoBrw2[nYY,nPoZ])+ STR0349+; //"O insumo " ## " está relacionado a Solicitação de Compra numero "
						SC1->C1_NUM +STR0350) //". Deseja incluir como realizado ? "

							lTemSC1 := .T.
							Exit

						EndIf

					EndIf

					dbSelectArea("SC1")
					dbSkip()

				End

			EndIf

			If lTemSC1
				dbSelectArea(cTRBIP)
				dbSkip()
				Loop
			EndIf

		EndIf

		If aCoBrw2[nYY,nPos] == "P"
			//Verificar os produtos que estao bloqueados
			dbSelectArea("SB1")
			dbSetOrder(1)
			If dbSeek(xFilial("SB1")+aCoBrw2[nYY,nPox])
				If SB1->B1_MSBLQL == "1"
					If !Empty(cProdBloq)
						cProdBloq += ", "
					EndIf
					cProdBloq += Alltrim(aCoBrw2[nYY,nPox])
					dbSelectArea(cTRBIP)
					dbSkip()
					Loop
				EndIf
			EndIf

			M->TL_SEQRELA := aCoBrw2[nYY,nPos18]
			M->TL_TIPOREG := aCoBrw2[nYY,nPos]
			M->TL_CODIGO  := aCoBrw2[nYY,nPox]
			MNT400CHKGAR()
			MNT400PCKGAR()
		EndIf
		If cUsaGeRe == "EST" .And. aCoBrw2[nYY,nPos] == "P"
			If lFirstMsg
				MsgInfo(STR0086) //"Para insumo produto somente poderá ser gerado SA (Solicitação ao Armazém)."
				lFirstMsg := .F.
			EndIf
			dbSelectArea(cTRBIP)
			dbSkip()
			Loop
		Else
			If aCoBrw2[nYY,nPos] == "E"
				aCodFunc := fPFiltro(aCoBrw2[nYY,nPox], aCoBrw2[nYY,nPoQ], aCoBrw2[nYY,nDtFim])
				If ValType(aCodFunc) <> "A"
					dbSelectArea(cTRBIP)
					dbSkip()
					Loop
				EndIf
				For nZZZ := 1 to Len(aCodFunc)
					nPosBrw := aScan(aCoBrw6 ,{|x| x[nPoY] == aCoBrw2[nYY,nPoY] .And. x[nPos] == "M" .And. ;
					x[nPox] == aCodFunc[nZZZ] .And. !x[Len(x)] })
					If nPosBrw > 0
						fInsChange(aCoBrw2[nYY],nPosBrw,@nSeqTmp,nPos18)
					Else
						aAdd(aCoBrw6 , aClone(aCoBrw2[nYY]) )
						nLenBrw6 := Len(aCoBrw6)
						aCoBrw6[ nLenBrw6 , nPos ] := "M"
						aCoBrw6[ nLenBrw6 , nPox ] := aCodFunc[nZZZ]

						dbSelectArea("ST1")
						dbSetOrder(1)
						dbSeek(xFilial("ST1") + aCodFunc[nZZZ])

						GDFieldPut( 'TL_NOMCODI', ST1->T1_NOME             , nLenBrw6, aHoBrw2, aCoBrw6 )
						GDFieldPut( 'TL_QUANREC', 0                        , nLenBrw6, aHoBrw2, aCoBrw6 )
						GDFieldPut( 'TL_SEQRELA', MNT435SEQ( aCoBrw6, .T. ), nLenBrw6, aHoBrw2, aCoBrw6 )

						// Quando não está integrado ao Estoque, pega o salário do Funcionário da Manutenção (T1_SALARIO)
						// multiplicado pela quantidade de insumo (TL_QUANTID) para apresentar em tela.
						If cNGMNTES <> "S" .And. !Empty(ST1->T1_SALARIO)

							GDFieldPut( 'TL_CUSTO', ( ST1->T1_SALARIO * GDFieldGet( 'TL_QUANTID', nLenBrw6, .F.,;
								aHoBrw2, aCoBrw6 ) ), nLenBrw6, aHoBrw2, aCoBrw6 )

						Else
							DbSelectArea("ST2")
							DbSetOrder(1)
							If DbSeek(xFilial("ST2")+aCodFunc[nZZZ])
								DbSelectArea("ST0")
								DbSetOrder(1)
								If DbSeek(xFilial("ST0")+ST2->T2_ESPECIA)

									GDFieldPut( 'TL_CUSTO', ( ST0->T0_SALARIO * GDFieldGet( 'TL_QUANTID', nLenBrw6, .F.,;
										aHoBrw2, aCoBrw6 ) ), nLenBrw6, aHoBrw2, aCoBrw6 )

								EndIf
								//Integrado ao estoque
								If cNGMNTES == 'S'

									cCodInsum := IIf( FindFunction( 'MntGetPrdM' ), MntGetPrdM(), PadR( 'MOD' + ST1->T1_CCUSTO, TamSX3( 'B1_COD' )[1] ) )

									If lIntRM

										NGMUStoLvl( cCodInsum, cLocPad, .T., 'M', ST1->T1_CODFUNC )

									EndIf

									cTypeHr  := IIf( nTypeHr > 0, aCoBrw2[nYY,nTypeHr], cTypeHr )
									nQtdCvrt := NGCONVERHORA( aCoBrw2[nYY,nQuanti], cTypeHr, 'D' )

									GDFieldPut( 'TL_CUSTO', ( ST0->T0_SALARIO * Round( NGCALCUSTI( cCodInsum, 'P',;
										nQtdCvrt, , , , , aCoBrw2[nYY,nPoQ], 1 ), 2 ), nLenBrw6, aHoBrw2, aCoBrw6 ) )

								EndIf
							EndIf
						EndIf
					EndIf
				Next nZZZ
			Else
				If aCoBrw2[nYY,nPos] == "T"
					If !NGVALTERC("T",cUsaInt3)
						dbSelectArea(cTRBIP)
						dbSkip()
						Loop
					EndIf
				EndIf
				nPosBrw := aScan(aCoBrw6 ,{|x| x[nPoY] == aCoBrw2[nYY,nPoY] .And. x[nPos] == aCoBrw2[nYY,nPos] .And. ;
				x[nPox] == aCoBrw2[nYY,nPox] .And. !x[Len(x)] })
				If nPosBrw > 0
					fInsChange(aCoBrw2[nYY],nPosBrw,@nSeqTmp,nPos18)
				Else
					If !Empty( aCoBrw2[nYY,1] )

						aAdd( aCoBrw6, aClone( aCoBrw2[nYY] ) )

						nTempXX := Len(aCoBrw6)

						If lMNTA435R
		
							/*------------------------------------+
							| P.E. para alterar conteudo do aCols |
							+------------------------------------*/
							aCoBrw6 := aClone( ExecBlock( 'MNTA435R', .F., .F.,;
								{ aHoBrw2, aCoBrw6, nTempXX } ) )

						EndIf

						aCoBrw6[ nTempXX ,nPos18] := MNT435SEQ(aCoBrw6,.T.)

						If aCoBrw6[nTempXX,nPos] == "P"
							M->TL_CODIGO  := aCoBrw6[nTempXX,nPox]
							M->TL_GARANTI := aCoBrw6[nTempXX,nCpoGar]
							strDescIns    := aCoBrw6[nTempXX,nPoZ]
							tmpSeqRela    := aCoBrw6[nTempXX,nPos18]
							tmpDtInic     := aCoBrw6[nTempXX,nDtIni]
							tmpDtFim      := aCoBrw6[nTempXX,nDtFim]
							fNgGar435("S",.T.,M->TL_GARANTI,strDescIns,tmpSeqRela,tmpDtInic,tmpDtFim) //Verifica se tem garantia de peça de reposição
							aCoBrw6[nTempXX,nCpoGar] := M->TL_GARANTI
						EndIf
					EndIf
					//Se possuir o PE e integração ao estoque deverá validar
					If lMNTA435O .And. cUsaInt3 == 'S' .And. aCoBrw6[nTempXX,nPos] == "M"

						//Se o P.E. retornar .F. e se a chave atual nao esteja relacionada como bloqueio.
						//não deverá realizar a baixa no estoque, sendo assim deverá ser adicionada no aNBaixaEst
						If !ExecBlock("MNTA435O",.F.,.F.,{ aCoBrw6[nTempXX], aHoBrw2 }) .And. ;
								MNT435CANB(cOrdemTJ + cPlanoTJ + aCoBrw6[nTempXX,nPos18] + aCoBrw6[nTempXX,nPoY] + aCoBrw6[nTempXX,nPos] + aCoBrw6[nTempXX,nPox])
							aAdd(aNBaixaEst,{cOrdemTJ,;  //TL_ORDEM
							cPlanoTJ,;			         //TL_PLANO
							aCoBrw6[nTempXX,nPos18] ,;	 //TL_SEQRELA
							aCoBrw6[nTempXX,nPoY] ,;	 //TL_TAREFA
							aCoBrw6[nTempXX,nPos] ,;	 //TL_TIPOREG
							aCoBrw6[nTempXX,nPox] })	 //TL_CODIGO
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf

		dbSelectArea(cTRBIP)
		dbSkip()
	End

	If ExistBlock("MNTB4351")
		ExecBlock("MNTB4351")
	EndIf

	dbSelectArea(cTRBIP)
	dbGoTop()

	If Len(aCoBrw6) == 0
		If Valtype(aNovoSTL) == "A"
			aCoBrw6 := aClone(aNovoSTL)
		Else
			aCoBrw6 := BLANKGETD(aHoBrw6)
		EndIf
	Else
		oBrw6:lModified := .T.
	EndIf
	aCols := aClone(aCoBrw6)
	oBrw6:oBrowse:Refresh()
	oBrw6:oBrowse:SetFocus()


	//Mostra os Produtos bloqueados
	If !Empty(cProdBloq)
		MsgInfo(STR0259 + cProdBloq  )  //"Produto(s) blqueado(s) : "
	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ f435Next ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 30/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Adiciona um insumo previsto em Realizados                  |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function f435Next(oChv435)

	Local aCodFunc 	:= {}
	Local cProdBloq := ''
	Local cCodInsum := ''
	Local cTypeHr   := ''
	Local cNGMNTES	:= SuperGetMv("MV_NGMNTES", .F., "N")
	Local cLocPad   := SuperGetMV( 'MV_NGLOCPA', .F., '01' )
	Local lTemSC1 	:= .F.
	Local lMNTA435O	:= ExistBlock("MNTA435O")
	Local lMNTA435R := ExistBlock( 'MNTA435R' )
    Local nSeqTmp 	:= 0
    Local nYY  		:= 0
	Local nZZZ 		:= 0
	Local nLenBrw6 	:= 0
	Local nQtdCvrt  := 0
	Local nPos 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPox 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPoZ 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NOMCODI"})
	Local nPoQ 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANREC"})
	Local nPoY 		:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TAREFA" })
	Local nPos18 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
	Local nDtIni 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI"})
	Local nDtFim 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM"  })
	Local nCpoGar 	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_GARANTI"})
	Local nNumSa  	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSA"  })
	Local nITEMSa  	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_ITEMSA" })
	Local nQuanti  	:= aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANTID"})
	Local nTypeHr   := aScan( aHoBrw2, {|x| Trim( Upper( x[2] ) ) == 'TL_TIPOHOR' } )

	lRet435 := .T.
	oChv435:SetFocus()
	If !lRet435 //Problema encontrado em alguma rotina de validacao da LinhaOK
		Return .F.
	EndIf

	nLenBr6 := Len(aCoBrw6)
	If nLenBr6 == 1
		If Empty(aCoBrw6[1,nPox])
			aCoBrw6 := {}
		EndIf
	ElseIf nLenBr6 > 1
		If Empty(aCoBrw6[nLenBr6,nPox])
			aDel(aCoBrw6,nLenBr6)
			aSize(aCoBrw6,nLenBr6-1)
			oBrw6:lNewLine := .F.
		EndIf
	EndIf
	lFirstMsg := .T.
	dbSelectArea(cTRBIP)
	dbGoTop()
	While !EoF()
		nYY := (cTRBIP)->(Recno())
		If nYY > Len(aCoBrw2) .Or. Empty((cTRBIP)->TL_OK)
			dbSelectArea(cTRBIP)
			dbSkip()
			Loop
		EndIf

		lTemSC1 := .F.

		//Verifica se o Insumo possui Solicitação de Armazem ou Solicitacao de Compras
		If aCoBrw2[nYY,nPos] $ "PT" .And. cUsaInt2 == "S" .And. cUsaInt3 == "S"

			If nNumSa > 0 .And. nITEMSa > 0
				dbSelectArea("SCP")
				dbSetOrder(2) //CP_FILIAL+CP_PRODUTO+CP_NUM+CP_ITEM
				If dbSeek( xFilial("SCP") + aCoBrw2[nYY,nPox] + aCoBrw2[nYY,nNumSa] + aCoBrw2[nYY,nITEMSa])

					ShowHelpDlg(STR0174, {STR0344 + Alltrim(aCoBrw2[nYY,nPoZ]) + STR0345+; //"ATENCAO" ## "O insumo " ## "esta relacionado a Solicitação "
					STR0346 + SCP->CP_NUM},1,; //"ao Armazem numero "
					{STR0347+; //"Realizar a aplicação do insumo utilizando a rotina de Baixa Pré-Requisição(MATA185)."
					STR0348},1) //" Excluir/Alterar a Solicitação ao Armazem"
					dbSelectArea(cTRBIP)
					dbSkip()
					Loop

				EndIf
			EndIf

			dbSelectArea("SC1")
			dbSetOrder(4) //C1_FILIAL+C1_OP+C1_NUM+C1_ITEM
			If dbSeek( xFilial("SC1") + cOrdemTJ+"OS001")
				While !Eof() .And. SC1->C1_FILIAL == xFilial("SC1") .And. Alltrim(SC1->C1_OP) == cOrdemTJ+"OS001"

					If SC1->C1_PRODUTO == aCoBrw2[nYY,nPox] .And. aCoBrw2[nYY,nQuanti] == SC1->C1_QUANT

						If !MsgYesNo(STR0344 +Alltrim(aCoBrw2[nYY,nPoZ])+ STR0349+; //"O insumo " ## " está relacionado a Solicitação de Compra numero "
						SC1->C1_NUM +STR0350) //". Deseja incluir como realizado ? "

							lTemSC1 := .T.
							Exit

						EndIf

					EndIf

					dbSelectArea("SC1")
					dbSkip()

				End

			EndIf

			If lTemSC1
				dbSelectArea(cTRBIP)
				dbSkip()
				Loop
			EndIf

		EndIf

		If aCoBrw2[nYY,nPos] == "P"
			//Verificar se o Produto esta bloqueado
			dbSelectArea("SB1")
			dbSetOrder(1)
			If dbSeek(xFilial("SB1")+aCoBrw2[nYY,nPox])
				If SB1->B1_MSBLQL == "1"
					If !Empty(cProdBloq)
						cProdBloq += ", "
					EndIf
					cProdBloq += Alltrim(aCoBrw2[nYY,nPox])
					dbSelectArea(cTRBIP)
					dbSkip()
					Loop
				EndIf
			EndIf
			M->TL_SEQRELA := aCoBrw2[nYY,nPos18]
			M->TL_TIPOREG := aCoBrw2[nYY,nPos]
			M->TL_CODIGO  := aCoBrw2[nYY,nPox]
			MNT400CHKGAR()
			MNT400PCKGAR()
		EndIf
		If cUsaGeRe == "EST" .And. aCoBrw2[nYY,nPos] == "P"
			If lFirstMsg
				MsgInfo(STR0086) //"Para insumo produto somente poderá ser gerado SA (Solicitação ao Armazém)."
				lFirstMsg := .F.
			EndIf
			dbSelectArea(cTRBIP)
			dbSkip()
			Loop
		Else
			If aCoBrw2[nYY,nPos] == "E"
				aCodFunc := fPFiltro(aCoBrw2[nYY,nPox], aCoBrw2[nYY,nPoQ], aCoBrw2[nYY,nDtFim])
				If ValType(aCodFunc) <> "A"
					dbSelectArea(cTRBIP)
					dbSkip()
					Loop
				EndIf
				For nZZZ := 1 to Len(aCodFunc)
					nPosBrw := aScan(aCoBrw6 ,{|x| x[nPoY] == aCoBrw2[nYY,nPoY] .And. x[nPos] == "M" .And. ;
					x[nPox] == aCodFunc[nZZZ] .And. !x[Len(x)] })
					If nPosBrw > 0
						fInsChange(aCoBrw2[nYY],nPosBrw,@nSeqTmp,nPos18)
					Else
						aAdd(aCoBrw6 , aClone(aCoBrw2[nYY]) )
						nLenBrw6 := Len(aCoBrw6)
						aCoBrw6[nLenBrw6 , nPos ] := "M"
						aCoBrw6[nLenBrw6 , nPox ] := aCodFunc[nZZZ]

						dbSelectArea("ST1")
						dbSetOrder(1)
						dbSeek(xFilial("ST1") + aCodFunc[nZZZ])

						GDFieldPut( 'TL_NOMCODI', ST1->T1_NOME             , nLenBrw6, aHoBrw2, aCoBrw6 )
						GDFieldPut( 'TL_QUANREC', 0                        , nLenBrw6, aHoBrw2, aCoBrw6 )
						GDFieldPut( 'TL_SEQRELA', MNT435SEQ( aCoBrw6, .T. ), nLenBrw6, aHoBrw2, aCoBrw6 )

						If cNGMNTES <> "S" .And. !Empty(ST1->T1_SALARIO)

							GDFieldPut( 'TL_CUSTO', ( ST1->T1_SALARIO * GDFieldGet( 'TL_QUANTID', nLenBrw6, .F.,;
								aHoBrw2, aCoBrw6 ) ), nLenBrw6, aHoBrw2, aCoBrw6 )


						Else
							DbSelectArea("ST2")
							DbSetOrder(1)
							If DbSeek(xFilial("ST2")+aCodFunc[nZZZ])
								DbSelectArea("ST0")
								DbSetOrder(1)
								If DbSeek(xFilial("ST0")+ST2->T2_ESPECIA)

									GDFieldPut( 'TL_CUSTO', ( ST0->T0_SALARIO * GDFieldGet( 'TL_QUANTID', nLenBrw6, .F.,;
										aHoBrw2, aCoBrw6 ) ), nLenBrw6, aHoBrw2, aCoBrw6 )

								EndIf
								//Integrado ao estoque
								If cNGMNTES == 'S'
									cCodInsum := IIf( FindFunction( 'MntGetPrdM' ), MntGetPrdM(), PadR( 'MOD' + ST1->T1_CCUSTO, TamSX3( 'B1_COD' )[1] ) )

									//Atualiza saldo e custo do produto relacionado a mão de obra
									If lIntRM

										NGMUStoLvl( cCodInsum, cLocPad, .T., 'M', ST1->T1_CODFUNC )

									EndIf

									cTypeHr  := IIf( nTypeHr > 0, aCoBrw2[nYY,nTypeHr], cTypeHr )
									nQtdCvrt := NGCONVERHORA( aCoBrw2[nYY,nQuanti], cTypeHr, 'D' )
									
									GDFieldPut( 'TL_CUSTO', ( ST0->T0_SALARIO * Round( NGCALCUSTI( cCodInsum, 'P', nQtdCvrt, , , , , aCoBrw2[nYY,nPoQ], 1 ), 2 ) ),;
										nLenBrw6, aHoBrw2, aCoBrw6 )

								EndIf
							EndIf
						EndIf
					EndIf
				Next nZZZ
			Else
				If aCoBrw2[nYY,nPos] == "T"
					If !NGVALTERC("T",cUsaInt3)
						dbSelectArea(cTRBIP)
						dbSkip()
						Loop
					EndIf
				EndIf
				nPosBrw := aScan(aCoBrw6 ,{|x| x[nPoY] == aCoBrw2[nYY,nPoY] .And. x[nPos] == aCoBrw2[nYY,nPos] .And. ;
				x[nPox] == aCoBrw2[nYY,nPox] .And. !x[Len(x)] })
				
				If nPosBrw > 0
					fInsChange(aCoBrw2[nYY],nPosBrw,@nSeqTmp,nPos18)
				Else

					If !Empty(aCoBrw2[nYY,1])

						aAdd(aCoBrw6 , aClone( aCoBrw2[nYY] ) )

						nTempXX := Len(aCoBrw6)

						If lMNTA435R
		
							/*------------------------------------+
							| P.E. para alterar conteudo do aCols |
							+------------------------------------*/
							aCoBrw6 := aClone( ExecBlock( 'MNTA435R', .F., .F.,;
								{ aHoBrw2, aCoBrw6, nTempXX } ) )

						EndIf

						aCoBrw6[ nTempXX ,nPos18] := MNT435SEQ(aCoBrw6,.T.)

						If aCoBrw6[nTempXX,nPos] == "P"
							M->TL_CODIGO  := aCoBrw6[nTempXX,nPox]
							M->TL_GARANTI := aCoBrw6[nTempXX,nCpoGar]
							strDescIns    := aCoBrw6[nTempXX,nPoZ]
							tmpSeqRela    := aCoBrw6[nTempXX,nPos18]
							tmpDtInic     := aCoBrw6[nTempXX,nDtIni]
							tmpDtFim      := aCoBrw6[nTempXX,nDtFim]
							fNgGar435("S",.T.,M->TL_GARANTI,strDescIns,tmpSeqRela,tmpDtInic,tmpDtFim) //Verifica se tem garantia de peça de reposição
							aCoBrw6[nTempXX,nCpoGar] := M->TL_GARANTI
						EndIf

						//Se possuir o PE e integração ao estoque deverá validar
						If lMNTA435O .And. cUsaInt3 == 'S' .And. aCoBrw6[nTempXX,nPos] == "M"

							//Se o P.E. retornar .F. e se a chave atual nao esteja relacionada como bloqueio.
							//não deverá realizar a baixa no estoque, sendo assim deverá ser adicionada no aNBaixaEst
							If !ExecBlock("MNTA435O",.F.,.F.,{ aCoBrw6[nTempXX], aHoBrw2 }) .And. ;
									MNT435CANB(cOrdemTJ + cPlanoTJ + aCoBrw6[nTempXX,nPos18] + aCoBrw6[nTempXX,nPoY] + aCoBrw6[nTempXX,nPos] + aCoBrw6[nTempXX,nPox])
								aAdd(aNBaixaEst,{cOrdemTJ,; //TL_ORDEM
								cPlanoTJ,;			        //TL_PLANO
								aCoBrw6[nTempXX,nPos18] ,;	//TL_SEQRELA
								aCoBrw6[nTempXX,nPoY] ,;	//TL_TAREFA
								aCoBrw6[nTempXX,nPos] ,;	//TL_TIPOREG
								aCoBrw6[nTempXX,nPox] })	//TL_CODIGO
							EndIf
						EndIf

					EndIf
				EndIf
			EndIf
		EndIf

		dbSelectArea(cTRBIP)
		dbSkip()
	End

	If ExistBlock("MNTB4352")
		ExecBlock("MNTB4352")
	EndIf

	dbSelectArea(cTRBIP)
	dbGoTop()

	If Len(aCoBrw6) == 0
		If Valtype(aNovoSTL) == "A"
			aCoBrw6 := aClone(aNovoSTL)
		Else
			aCoBrw6 := BLANKGETD(aHoBrw6)
		EndIf
	Else
		oBrw6:lModified := .T.
	EndIf
	//aCols := aClone(aCoBrw6)
	oBrw6:oBrowse:Refresh()
	oBrw6:oBrowse:SetFocus()

	//Mostra os Produtos bloqueados
	If !Empty(cProdBloq)
		MsgInfo(STR0259 + cProdBloq  )  //"Produto(s) blqueado(s) : "
	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fInsChange³ Autor ³Denis Hyroshi de Souza ³ Data ³ 30/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Exclui um insumo realizado                                 |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fInsChange(aColsTmp,nLinPos,nSeqTmp,nPos18)
	Local aTemp := aClone(aColsTmp)
	Local oDlg2,oRadOp
	Local nModelo := 1
	Local nOpcFun := 0
	Local nPos10 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANTID"})
	Local nPos := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPox := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPoZ := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NOMCODI"})
	Local nPoQ := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANREC"})
	Local nCpoGar := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_GARANTI" })
	Local nDtIni := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI" })
	Local nDtFim := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM" })

	Private cCpoTarefa := Alltrim((cTRBIP)->TL_TAREFA) + " - " + Alltrim((cTRBIP)->TL_NOMTAR )
	Private cCpoTipoIn := GetNomeTip((cTRBIP)->TL_TIPOREG)
	Private cCpoInsumo := Alltrim((cTRBIP)->TL_CODIGO) + " - " + Alltrim(NOMINSBRW((cTRBIP)->TL_TIPOREG, (cTRBIP)->TL_CODIGO))
	Private nCpoQtdade := (cTRBIP)->TL_QUANTID
	Private cCpoUnidad := (cTRBIP)->TL_UNIDADE
	Private oCpoTarefa,oCpoTipoIn,oCpoInsumo,oCpoQtdade,oCpoUnidad
	Private nQtdTemp   := aCoBrw6[nLinPos,nPos10]

	Define MsDialog oDlg2 Title OemToAnsi(STR0087) From 089,232 To 390,619 Of oMainWnd Pixel //"Insumos"

	@ 002,004 Say STR0088 of oDlg2 Font oFont3 Pixel //"Este insumo já foi utilizado nesta ordem de serviço."
	@ 013,004 Say STR0089 of oDlg2 Font oFont3 Pixel //"Selecione a opção desejada:"
	@ 028,004 Radio oRadOp Var nModelo Items STR0090,; //"Não adicionar o insumo."
	STR0091,; //"Adicionar o insumo novamente."
	STR0092,; //"Adicionar o insumo novamente, informando outra quantidade."
	STR0093; //"Alterar a quantidade do insumo já utilizado."
	Size 180,13 Pixel On Change fOnChIns(nModelo) OF oDlg2

	@ 072,004 Say STR0023     of oDlg2 Pixel //"Tarefa"
	@ 072,080 MsGet oCpoTarefa Var cCpoTarefa Size 60,08 Of oDlg2 Pixel
	oCpoTarefa:Disable()
	@ 083,004 Say STR0094       of oDlg2 Pixel //"Tipo"
	@ 083,080 MsGet oCpoTipoIn Var cCpoTipoIn Size 60,08 Of oDlg2 Pixel
	oCpoTipoIn:Disable()
	@ 094,004 Say STR0079     of oDlg2 Pixel //"Código"
	@ 094,080 MsGet oCpoInsumo Var cCpoInsumo Size 80,08 Of oDlg2 Pixel
	oCpoInsumo:Disable()
	@ 105,004 Say STR0095 of oDlg2 Pixel //"Quantidade"
	@ 105,080 MsGet oCpoQtdade Var nCpoQtdade Picture "999,999.99" Valid (Positivo(nCpoQtdade) .And. NGVALQUANT((cTRBIP)->TL_TIPOREG,(cTRBIP)->TL_UNIDADE,nCpoQtdade)) Size 60,08 Of oDlg2 Pixel HASBUTTON
	oCpoQtdade:Disable()
	@ 116,004 Say STR0096 of oDlg2 Pixel //"Unidade"
	@ 116,080 MsGet oCpoUnidad Var cCpoUnidad Size 30,08 Of oDlg2 Pixel
	oCpoUnidad:Disable()

	Define sButton oBtOk  from 134, 126 type 1 enable of oDlg2 pixel Action (nOpcFun:=1,If(.T.,oDlg2:End(),nOpcFun:=2))
	Define sButton oBtCan from 134, 156 type 2 enable of oDlg2 pixel Action (nOpcFun:=2,oDlg2:End())

	oDlg2:Activate(,,,.T.)

	If nOpcFun == 1
		If nModelo == 2
			aAdd(aCoBrw6 , aClone(aTemp) )
			nLen := Len(aCoBrw6)
			aCoBrw6[ nLen ,nPos18] := MNT435SEQ(aCoBrw6,.T.)

			aCoBrw6[ nLen , nPos ] := aCoBrw6[ nLinPos , nPos ]
			aCoBrw6[ nLen , nPox ] := aCoBrw6[ nLinPos , nPox ]
			aCoBrw6[ nLen , nPoZ ] := aCoBrw6[ nLinPos , nPoZ ]
			aCoBrw6[ nLen , nPoQ ] := aCoBrw6[ nLinPos , nPoQ ]
			If aCoBrw6[nLen,nPos] == "P"
				M->TL_CODIGO  := aCoBrw6[nLen,nPox]
				M->TL_GARANTI := aCoBrw6[nLen,nCpoGar]
				strDescIns    := aCoBrw6[nLen,nPoZ]
				tmpSeqRela    := aCoBrw6[nLen,nPos18]
				tmpDtInic     := aCoBrw6[nLen,nDtIni]
				tmpDtFim      := aCoBrw6[nLen,nDtFim]
				fNgGar435("S",.T.,M->TL_GARANTI,strDescIns,tmpSeqRela,tmpDtInic,tmpDtFim) //Verifica se tem garantia de peça de reposição
				aCoBrw6[nLen,nCpoGar] := M->TL_GARANTI
			EndIf

		ElseIf nModelo == 3
			aAdd(aCoBrw6 , aClone(aTemp) )
			nLen := Len(aCoBrw6)
			aCoBrw6[nLen,nPos10] := nCpoQtdade
			aCoBrw6[ nLen ,nPos18] := MNT435SEQ(aCoBrw6,.T.)

			aCoBrw6[ nLen , nPos ] := aCoBrw6[ nLinPos , nPos ]
			aCoBrw6[ nLen , nPox ] := aCoBrw6[ nLinPos , nPox ]
			aCoBrw6[ nLen , nPoZ ] := aCoBrw6[ nLinPos , nPoZ ]
			aCoBrw6[ nLen , nPoQ ] := aCoBrw6[ nLinPos , nPoQ ]
			If aCoBrw6[nLen,nPos] == "P"
				M->TL_CODIGO  := aCoBrw6[nLen,nPox]
				M->TL_GARANTI := aCoBrw6[nLen,nCpoGar]
				strDescIns    := aCoBrw6[nLen,nPoZ]
				tmpSeqRela    := aCoBrw6[nLen,nPos18]
				tmpDtInic     := aCoBrw6[nLen,nDtIni]
				tmpDtFim      := aCoBrw6[nLen,nDtFim]
				fNgGar435("S",.T.,M->TL_GARANTI,strDescIns,tmpSeqRela,tmpDtInic,tmpDtFim) //Verifica se tem garantia de peça de reposição
				aCoBrw6[nLen,nCpoGar] := M->TL_GARANTI
			EndIf
		ElseIf nModelo == 4
			aCoBrw6[nLinPos,nPos10] := nCpoQtdade
			aCols[n,nPos10] := nCpoQtdade
			//Atualiza os campos de data inicio e fim do insumo
			NGCALDTHO()
			aCoBrw6   := aClone(aCols)
		EndIf
	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fOnChIns ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 30/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Funcao chamada ao alterar o Radio da tela de insumos       |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fOnChIns(nModelo)

	oCpoTarefa:Disable()
	oCpoTipoIn:Disable()
	oCpoInsumo:Disable()
	oCpoQtdade:Disable()
	oCpoUnidad:Disable()

	If nModelo == 3
		oCpoQtdade:Enable()
		nCpoQtdade := (cTRBIP)->TL_QUANTID
		oCpoQtdade:Refresh()
	ElseIf nModelo == 4
		oCpoQtdade:Enable()
		nCpoQtdade := nQtdTemp
		oCpoQtdade:Refresh()
	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ f435Prev ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 30/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Exclui um insumo realizado                                 |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function f435Prev()

	If Len(aHeader) == Len(aHoBrw6)
		aCoBrw6 := aClone(aCols)
	EndIf

	If !fValDel435(.F., aCoBrw6[oBrw6:oBrowse:nAt] , oBrw6:oBrowse:nAt )
		Return .F.
	EndIf

	aDel(aCoBrw6,oBrw6:oBrowse:nAt)
	aSize(aCoBrw6,Len(aCoBrw6)-1)
	If Len(aCoBrw6) == 0
		If Valtype(aNovoSTL) == "A"
			aCoBrw6 := aClone(aNovoSTL)
		Else
			aCoBrw6 := BlankGetD(aHoBrw6)
		EndIf
		oBrw6:oBrowse:nAt := 1
		// Atribui ao objeto a identificação de que não houve alteração
		// para que não seja validado uma linha em branco no LinOkTL435
		oBrw6:lModified := .F.
	Else
		If oBrw6:oBrowse:nAt > Len(aCoBrw6)
			oBrw6:oBrowse:nAt := Len(aCoBrw6)
		EndIf
	EndIf
	n := oBrw6:oBrowse:nAt
	aCols := aClone(aCoBrw6)
	oBrw6:oBrowse:Refresh()
	fLoadSTL(.F.)
	oBrw4:oBrowse:Refresh()
	oBrw4:oBrowse:GoTop()

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fPrgPrev ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 30/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Exclui todos os insumos realizados                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fPrgPrev()
	Local nTmp

	If Len(aHeader) == Len(aHoBrw6)
		aCoBrw6 := aClone(aCols)
	EndIf

	For nTmp := 1 To Len(aCoBrw6)
		If !fValDel435(.F., aCoBrw6[nTmp] , nTmp )
			Return .F.
		EndIf
	Next nTmp

	If Valtype(aNovoSTL) == "A"
		aCoBrw6 := aClone(aNovoSTL)
	Else
		aCoBrw6 := BlankGetD(aHoBrw6)
	EndIf

	// Atribui ao objeto a identificação de que não houve alteração
	// para que não seja validado uma linha em branco no LinOkTL435
	oBrw6:lModified := .F.

	aCols := aClone(aCoBrw6)
	oBrw6:oBrowse:nAt := 1
	n := 1
	oBrw6:oBrowse:Refresh()
	fLoadSTL(.F.)
	oBrw4:oBrowse:Refresh()
	oBrw4:oBrowse:GoTop()

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fFiltroS ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 30/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Filtro do browse de Insumos Previstos                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fFiltroS()
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fGerarSA ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 30/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Gerar temporariamente a SA                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fGerarSA()
	Local cCodProd
	Local nTamB1 := Len(SCP->CP_PRODUTO)
	Local lNoCheck := .F.
	Local cNumOP   := cOrdemTJ+"OS001"

	If !MsgYesNo(STR0097) //"Confirma a Geração de Solicitação ao Armazém?"
		Return .F.
	EndIf

	dbSelectArea(cTRBIP)
	dbGoTop()
	ProcRegua(RecCount())
	While !EoF()

		IncProc()
		If (cTRBIP)->TL_TIPOREG <> "P"
			dbSelectArea(cTRBIP)
			dbSkip()
			Loop
		EndIf

		cCodProd := PadR((cTRBIP)->TL_CODIGO,nTamB1)
		dbSelectArea("SB1")
		dbSetOrder(1)
		If !dbSeek(xFilial("SB1")+cCodProd)
			dbSelectArea(cTRBIP)
			dbSkip()
			Loop
		EndIf

		dbSelectArea("STJ")
		dbSetOrder(1)
		dbSeek(xFilial("STJ")+cOrdemTJ + cPlanoTJ)

		dbSelectArea("ST9")
		dbSetOrder(1)
		dbSeek(xFilial("ST9")+STJ->TJ_CODBEM)

		If !Empty((cTRBIP)->TL_OK) .And. (cTRBIP)->XTL_SA == 0
			lNoCheck := .T.
			nLineSA := aScan(aDadosSA, {|x| x[1]+x[2]+x[3]+x[4] == cOrdemTJ+cPlanoTJ+cCodProd+Dtos((cTRBIP)->TL_DTINICI) })
			If nLineSA == 0
				//Chave: Ordem + Plano + Produto + Data Necessidade
				aAdd( aDadosSA ,{cOrdemTJ						,; //Ordem
				cPlanoTJ						,; //Plano
				cCodProd						,; //CP_PRODUTO
				SB1->B1_UM						,; //CP_UM
				(cTRBIP)->TL_QUANTID				,; //CP_QUANT
				(cTRBIP)->TL_DTINICI				,; //CP_DATPRF
				SB1->B1_LOCPAD					,; //CP_LOCAL
				cNumOP							,; //CP_OP
				ST9->T9_CCUSTO					,; //CP_CC
				dDataBase						,; //CP_EMISSAO
				SB1->B1_DESC					,; //CP_DESCRI
				cUserName						,; //CP_SOLICIT
				.T.								 ; //ATIVO/INATIVO
				};
				)
				nLineSA := Len(aDadosSA)
			Else
				aDadosSA[ nLineSA , 5 ] += (cTRBIP)->TL_QUANTID
			EndIf
			(cTRBIP)->XTL_SA := nLineSA

		ElseIf Empty((cTRBIP)->TL_OK) .And. (cTRBIP)->XTL_SA > 0

			If Len(aDadosSA) >= (cTRBIP)->XTL_SA
				aDadosSA[(cTRBIP)->XTL_SA , 5] := aDadosSA[(cTRBIP)->XTL_SA , 5] - (cTRBIP)->TL_QUANTID
				If aDadosSA[(cTRBIP)->XTL_SA , 5] <= 0
					aDadosSA[(cTRBIP)->XTL_SA , 13] := .F. //INATIVO
				EndIf
			EndIf

		EndIf

		dbSelectArea(cTRBIP)
		dbSkip()
	End
	dbSelectArea(cTRBIP)
	dbGoTop()

	If !lNoCheck
		MsgInfo(STR0098) //"Nenhum produto foi selecionado para gerar Solicitação ao Armazém (S.A.)."
		Return .F.
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Mnt435bCon³ Autor ³Denis Hyroshi de Souza ³ Data ³ 30/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Funcionalidade do botao do conhecimento                     |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Mnt435bCon()

	Local cOrdem, cPlano
	If Len(aOS) > 0
		cOrdem := aOS[oOS:nAt,nPosOS]
		cPlano := aOS[oOS:nAt,nPosPL]
		dbSelectArea("STJ")
		dbSetOrder(01)
		If dbSeek(xFilial("STJ")+cOrdem+cPlano)
			MsDocument("STJ",Recno(),4)
		Else
			MsgInfo(STR0099) //"Nenhuma ordem de serviço foi selecionada."
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} LoadInfSTJ()
Monta a array dos campos da OS conforme campos usados do SX3
e que X3_BROWSE esteja = "S"
@type static

@author Denis Hyroshi de Souza
@since 30/06/2008
/*/
//---------------------------------------------------------------------
Static Function LoadInfSTJ()

	Local i			 := 0
	Local nPos		 := 0
	Local nPos1		 := 0
	Local nPos2		 := 0
	Local nPosCor	 := 0
	Local nPos3		 := 0
	Local nXX		 := 0
	Local nPosXX	 := 0
	Local nInd       := 0
	Local nTot       := 0
	Local cBlockI	 := ""
	Local cTxtTmp	 := ""
	Local cTxtInd	 := ""
	Local cDfLstAux  := ""
	Local cBrowse    := ""
	Local cContext   := ""
	Local lMNTA435H	 := ExistBlock ("MNTA435H")
	Local aHeaderSTJ := {}
	Local aFieldForc := { 'TJ_ORDEM', 'TJ_PLANO' } //Campos que são obrigatorios há apresentação em tela

	aAdd(aTxtCampo ,"  " )
	aAdd(aCampStj,"  " )
	aAdd(aVisuStj," " )

	If Len(aCores2) > 0
		aAdd(aTxtCampo,"  " )
		aAdd(aCampStj,"  " )
		aAdd(aVisuStj," " )
	EndIf

	aHeaderSTJ := NGHeader("STJ",,.F.)

	nTot := Len(aHeaderSTJ)

	For nInd := 1 To nTot

		cCampo  := AllTrim( aHeaderSTJ[nInd,2] )
		cBrowse := Posicione("SX3",2,cCampo,"X3_BROWSE")
		If cBrowse == 'S' .Or. ( aScan( aFieldForc, { |x| x == cCampo } ) > 0 )
			aAdd(aTxtCampo, Alltrim(aHeaderSTJ[nInd,1]) )
			aAdd( aCampStj, cCampo )
			aAdd(aVisuStj , Alltrim(aHeaderSTJ[nInd,10]))
		EndIf

	Next nInd

	//Ponto de Entrada para eliminar ou adicionar campos da STJ ao mostrar na Tela Inicial
	If lMNTA435H
		aTxtCampo := ExecBlock("MNTA435H",.F.,.F.,aTxtCampo)
	EndIf

	For i := 1 To Len(aTxtCampo)
		If i == 1
			cDefLista := "If(aOS[oOS:nAt,1]==1,oVerde,If(aOS[oOS:nAt,1]==2,oAzul,If(aOS[oOS:nAt,1]==3,oRed,If(aOS[oOS:nAt,1]==4,oLaranja,oBranco))))"
		ElseIf i == 2 .And. Len(aCores2) > 0
			For nPosCor := 1 To Len(aCores2)
				If aCores2[nPosCor][1] <> ""
					cDfLstAux += ",If("+aCores2[nPosCor][1]+","+aCores2[nPosCor][2]
				Else
					cDfLstAux += ","+aCores2[nPosCor][2]
				EndIf
			next nPosCor
			For nPosCor := 1 To Len(aCores2)-1
				cDfLstAux += ")"
			next nPosCor
			cDefLista += cDfLstAux
		Else
			cDefLista += ",aOS[oOS:nAt,"+Alltrim(Str(i,3))+"]"
		EndIf
	Next i
	cDefLista :=  "{"+cDefLista+"}"

	nPosXX := aScan(aCampStj,{|x| x == "TJ_ORDEM" })
	If nPosXX > 0
		nPosOS := nPosXX
	EndIf
	nPosXX := aScan(aCampStj,{|x| x == "TJ_PLANO" })
	If nPosXX > 0
		nPosPL := nPosXX
	EndIf

	For nXX := 1 To Len(aChave435)
		cTxtInd := Alltrim(aChave435[nXX])
		cBlockI := ""
		While !Empty(cTxtInd)
			nPos := At("+",cTxtInd)
			cTxtTmp := ""
			If nPos > 0
				cTxtTmp := Alltrim(Substr(cTxtInd,1,nPos-1))
				cTxtInd := Alltrim(Substr(cTxtInd,nPos+1))
			Else
				cTxtTmp := Alltrim(cTxtInd)
				cTxtInd := ""
			EndIf
			nPos1 := At("(",cTxtTmp)
			nPos2 := At(")",cTxtTmp)
			nPos3 := At(",",cTxtTmp)
			If nPos1 > 0 .And. nPos2 > 0
				If nPos3 > 0
					nPos2 := nPos3
				EndIf
				cCampoTmp := Alltrim( Substr(cTxtTmp,nPos1+1,nPos2-nPos1-1) )
				nPosXX := aScan(aCampStj,{|x| x == cCampoTmp })
				If nPosXX == 0 .And. cCampoTmp <> "TJ_FILIAL"

					cTabela := FWTabPref(cCampoTmp)
					If (cTabela)->(FieldPos(cCampoTmp)) > 0
						cContext := Alltrim(Posicione("SX3",2,cCampoTmp,"X3_CONTEXT"))
						aAdd(aCampStj, Alltrim(cCampoTmp) )
						aAdd(aVisuStj, cContext)
						nPosXX := Len(aCampStj)
					EndIf

				EndIf
				If nPosXX > 0
					If !Empty(cBlockI)
						cBlockI += "+"
					EndIf
					cBlockI += Substr(cTxtTmp,1,nPos1)
					cBlockI += "x["+Alltrim(Str(nPosXX,3))+"]"
					cBlockI += Substr(cTxtTmp,nPos2)
				EndIf
			Else
				nPosXX := aScan(aCampStj,{|x| x == cTxtTmp })
				If nPosXX == 0 .And. cTxtTmp <> "TJ_FILIAL"

					cTabela := FWTabPref(cTxtTmp)
					If (cTabela)->(FieldPos(cTxtTmp)) > 0
						cContext := Alltrim(Posicione("SX3",2,cTxtTmp,"X3_CONTEXT"))
						aAdd(aCampStj, Alltrim(cTxtTmp))
						aAdd(aVisuStj, cContext)
						nPosXX := Len(aCampStj)
					EndIf

				EndIf
				If nPosXX > 0
					If !Empty(cBlockI)
						cBlockI += "+"
					EndIf
					cBlockI += "x["+Alltrim(Str(nPosXX,3))+"]"
				EndIf
			EndIf
		End
		If Empty(cBlockI)
			cBlockI := "x[2]"
		EndIf
		cBlockR := StrTran(cBlockI,"x[","y[")
		cBlockF := cBlockI + " < " + cBlockR
		aAdd( aBlockInd , {cBlockF, cBlockI} )
	Next nXX

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Funo   ³fAlterInd ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 01/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descrio³Altera indice das OS                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA435                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fAlterInd(nOrdem435)
	Local nPos
	If nOrdem435 <= Len(aBlockInd)
		aSort(aOS,,, &("{|x,y| "+aBlockInd[nOrdem435,1]+" }") )
		oOS:SetArray(aOS)
		bOSLine1  := { || &(cDefLista)}
		oOS:bLine := bOSLine1
		nPos := aScan(aOS , {|x| x[nPosOS] == cOrdemTJ } )
		If nPos > 0
			oOS:nAt := nPos
		EndIf
		oOS:Refresh()
	EndIf
Return

/*/{Proteus.doc} MNT435LEG
	Cria uma janela contendo a legenda da mBrowse
	@param
	@return
	@author Alexandre Santos
	@since 23/10/2017
/*/
Static Function Mnt435Leg()

	Local oDlgLeg

	Define MsDialog oDlgLeg Title OemToAnsi(STR0100) From 0,0 To 25.5,38.5

	// LEGENDA DE ORDENS DE SERVIÇO
	@ 008,005 To 65,150 LABEL Oemtoansi(STR0337) OF oDlgLeg PIXEL
	@ 017,020 BitMap Resource "BR_VERDE"    Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 029,020 BitMap Resource "BR_AZUL"     Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 041,020 BitMap Resource "BR_VERMELHO" Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 053,020 BitMap Resource "BR_LARANJA" 	Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 017,032 Say Oemtoansi(STR0101)  Of oDlgLeg Pixel //COM INSUMO
	@ 029,032 Say Oemtoansi(STR0102)  Of oDlgLeg Pixel //SEM INSUMO
	@ 041,032 Say STR0103+" "+STR0102 Of oDlgLeg Pixel //ATRASADA SEM INSUMO
	@ 053,032 Say STR0103+" "+STR0101 Of oDlgLeg Pixel //ATRASADA COM INSUMO
	// LEGENDA DE INSUMOS
	@ 73,005 To 119, 150 LABEL Oemtoansi(STR0087) OF oDlgLeg PIXEL
	@ 082,020 BitMap Resource "BR_VERMELHO"   Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 094,020 BitMap Resource "BR_LARANJA" Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 106,020 BitMap Resource "BR_VERDE"    Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 082,032 Say Oemtoansi(STR0353) Of oDlgLeg Pixel // Não aplicado
	@ 094,032 Say Oemtoansi(STR0354) Of oDlgLeg Pixel // Parcialmente Aplicado
	@ 106,032 Say Oemtoansi(STR0355) Of oDlgLeg Pixel // Totalmente aplicado
	// LEGENDA DE ETAPAS
	@ 126,005 To 186, 150 LABEL Oemtoansi(STR0017) OF oDlgLeg PIXEL
	@ 138,020 BitMap Resource "BR_VERDE"    Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 150,020 BitMap Resource "BR_AMARELO"  Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 162,020 BitMap Resource "BR_LARANJA"  Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 174,020 BitMap Resource "BR_VERMELHO" Size 17,17 of oDlgLeg Pixel Noborder Design
	@ 138,032 Say Oemtoansi(STR0358) Of oDlgLeg Pixel //EXECUTADA
	@ 150,032 Say Oemtoansi(STR0359) Of oDlgLeg Pixel //EM EXECUÇÃO
	@ 162,032 Say Oemtoansi(STR0360) Of oDlgLeg Pixel //EM EXECUÇÃO ACIMA DO TEMPO PREVISTO
	@ 174,032 Say Oemtoansi(STR0361) Of oDlgLeg Pixel //NÃO EXECUTADA

	Activate MsDialog oDlgLeg Centered

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Mnt435Rel ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 01/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Funcionalidade do botao de imprimir OS                      |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Mnt435Rel()
	Local cOrdem, cPlano

	If Len(aOS) > 0
		cOrdem := aOS[oOS:nAt,nPosOS]
		cPlano := aOS[oOS:nAt,nPosPL]
		dbSelectArea("STJ")
		dbSetOrder(01)
		If dbSeek(xFilial("STJ")+cOrdem+cPlano)
			U_IMP675(cOrdem,cPlano,.F.,,STJ->(RECNO()))
		Else
			MsgInfo(STR0099) //"Nenhuma ordem de serviço foi selecionada."
		EndIf
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Mnt435Vis ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 01/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Funcionalidade do botao de visualizar OS                    |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Mnt435Vis()
	Local cOrdem, cPlano

	aChoice := {}

	If Len(aOS) > 0
		cOrdem := aOS[oOS:nAt,nPosOS]
		cPlano := aOS[oOS:nAt,nPosPL]
		dbSelectArea("STJ")
		dbSetOrder(01)
		If dbSeek(xFilial("STJ")+cOrdem+cPlano)
			NGCAD01("STJ",Recno(),2)
		Else
			MsgInfo(STR0099) //"Nenhuma ordem de serviço foi selecionada."
		EndIf
	EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} Mnt435Fin
Funcionalidade do botao de finalizar OS
@author	Denis Hyroshi de Souza
@since	01/06/08
@return	- lRet, Lógico, Retorna se a OS pode ser finalizada ou não
/*/
//-------------------------------------------------------------------
Static Function Mnt435Fin()

	Local nXX,nYY
	Local dMINSTL,dMAXSTL,dMAXF,hMINSTL,hMAXSTL,hMAXF
	Local cOrdem
	Local cPlano
	Local nPox      := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO"  })
	Local nPos      := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG" })
	Local nPoY      := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TAREFA"  })
	Local nPoQ      := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANTID" })
	Local nDtI      := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI" })
	Local nHoI      := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOINICI" })
	Local nDtF      := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM" })
	Local nHoF      := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOFIM" })
	Local aFin2P    := {}
	Local aFinTmp   := {}
	Local lTemIReal := .F. //indica se tem insumo realizado
	Local lSemIns   := .F.
	Local lRet 		:= .T.
	Local lSoProd	:= .T. //Indica que só tem insumo do tipo Produto

	Local nDatFim   := aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_DTFIM"})
	Local nHorFim   := aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_HOFIM"})
	Local nJ        := 0

	Local nNumSa    := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSA" })
	Local nDataPos  := 0

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ponto de entrada que indica se a O.S ³
	//³podera ser finalizada sem insumos    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock("NGSEMINS")
		lSemIns := ExecBlock("NGSEMINS",.F.,.F.)
		lSemIns := If(ValType(lSemIns) == "L",lSemIns,.F.)
	EndIf

	If !Empty(aCoBrw4)
		For nJ := 1 To Len(aCoBrw4)
			If lRet .And. !Empty(aCoBrw4[nJ][1]) .And. (Empty(aCoBrw4[nJ][nDatFim]) .Or. Empty(aCoBrw4[nJ][nHorFim]))
				ShowHelpDlg("ATENCAO", {STR0342}, 2,;	//"Existe(m) motivo(s) de atraso(s) reportado(s) para a ordem de serviço sem a data ou a hora final informados."
				{STR0343}, 2)	//"Favor, informar uma data fim/hora fim para o(s) motivo(s) em questão para proceder com a finalização da O.S."
				lRet := .F.
			EndIf
		Next nJ
	EndIf

	If lRet .And. Len(aOS) > 0

		cOrdem := aOS[oOS:nAt,nPosOS]
		cPlano := aOS[oOS:nAt,nPosPL]
		dbSelectArea("STJ")
		dbSetOrder(01)
		If dbSeek(xFilial("STJ")+cOrdem+cPlano)
			If NGFUNCRPO("NGRESPETAEX",.F.)
				If !NGRESPETAEX( STJ->TJ_ORDEM, .T., oTmpTbl3:GetRealName(), .F. )
					lRet := .F.
				EndIf
			EndIf

			//Valida se o usuario tem permissão
			If lRet .And. !Empty(cRet400)
				If !(Upper(AllTrim(cUsername)) $ Upper(AllTrim(cRet400)))
					MsgStop(STR0104,STR0037) //"Usuário não autorizado para encerrar a O.S."###"ATENÇÃO"
					lRet := .F.
				EndIf
			EndIf

			//Valida se existir ponto de entrada
			If lRet .And. ExistBlock("MNT40011")
				lRet := ExecBlock("MNT40011",.F.,.F.)
			EndIf

			//Valida se tem ordem de producao
			If lRet .And. cUsaInt3 == "S"
				dbSelectArea("SC2")
				dbSetOrder(01)
				If !dbSeek(xFilial("SC2")+STJ->TJ_ORDEM+"OS001")
					MsgInfo(STR0105+STJ->TJ_ORDEM+STR0106 + ; //"A Ordem de Serviço  "###" não poderá ser finalizada, pois"
					chr(13)+chr(10)+STR0107,STR0037) //"não existe Ordem de Produção para a mesma."###"ATENÇÃO"
					lRet := .F.
				EndIf
			EndIf


			If lRet .And. !lSemIns // Verifica se pode finalizar a O.S. sem insumo //Nao tem insumo
				//Valida se tem algum insumo reportado
				nPDR := aScan(aCoBrw6 ,{|x| !Empty(x[nPoY]) .And. !Empty(x[nPos]) .And. !Empty(x[nPox]) .And. !x[Len(x)] })
				If nPDR == 0
					MsgInfo(STR0108+STJ->TJ_ORDEM+STR0106+; //"A Ordem de Serviço "###" não poderá ser finalizada, pois"
					chr(13)+chr(10)+STR0109,STR0037) //"não existe insumo realizado."###"ATENÇÃO"
					lRet := .F.
				EndIf
			EndIf

			If lRet
				//Se MV_NGREPRE = S, verifica se tem algum insumo faltando reportar a quantidade prevista
				lRetNgRep := If(cParSX6Ret == Nil .Or. Empty(cParSX6Ret) .Or. Alltrim(cParSX6Ret) == "N",.F.,.T.)
				If lRetNgRep
					lINSUSRET := .F.
					For nYY := 1 To Len(aCoBrw2)
						nQUATINS := 0
						If aCoBrw2[nYY,nPos] != "E"
							For nXX := 1 To Len(aCoBrw6)
								If ((nNumSa > 0 .And. !Empty(aCoBrw2[nYY,nNumSa])) .Or. aCoBrw6[nXX,nPoY] == aCoBrw2[nYY,nPoY]) .And.;
									aCoBrw6[nXX,nPos] == aCoBrw2[nYY,nPos] .And. aCoBrw6[nXX,nPox] == aCoBrw2[nYY,nPox]  .And.;
									!aCoBrw6[nXX, Len(aCoBrw6[nXX])]

									nQUATINS += aCoBrw6[nXX,nPoQ]
								EndIf
							Next nXX
						EndIf
						If nQUATINS < aCoBrw2[nYY,nPoQ] .And. aCoBrw2[nYY,nPos] != "E"
							lINSUSRET := .T.
							Exit
						EndIf
					Next nYY
					If lINSUSRET //Nao reportou tudo que foi previsto
						If !MsgYesNo(STR0110+;                       //"Para alguns insumos não foram reportadas a quantidade prevista."
						chr(13)+chr(10)+STR0111,STR0037) //"Deseja finalizar assim mesmo?"###"ATENÇÃO"
							lRet := .F.
						EndIf
					EndIf
				EndIf
			EndIf

			If lRet
				//Localiza Data/Hora fim da OS
				lSEQUEN0 := .T.
				For nXX := 1 To Len(aCoBrw6)
					If aCoBrw6[nXX, Len(aCoBrw6[nXX]) ]
						Loop
					EndIf
					lTemIReal := .T.
					If aCoBrw6[nXX,nPos] == "P"
						If Len(aFin2P) == 0
							aFin2P := {aCoBrw6[nXX,nDtI],aCoBrw6[nXX,nHoI],aCoBrw6[nXX,nDtI],aCoBrw6[nXX,nHoI]}
						Else
							If DtoS(aCoBrw6[nXX,nDtI]) + aCoBrw6[nXX,nHoI] > DtoS(aFin2P[3])+aFin2P[4]
								aFin2P[3] := aCoBrw6[nXX,nDtI]
								aFin2P[4] := aCoBrw6[nXX,nHoI]
							EndIf
							If DtoS(aCoBrw6[nXX,nDtI]) + aCoBrw6[nXX,nHoI] < DtoS(aFin2P[1])+aFin2P[2]
								aFin2P[1] := aCoBrw6[nXX,nDtI]
								aFin2P[2] := aCoBrw6[nXX,nHoI]
							EndIf
						EndIf
						Loop
					Else //Se possuir insumo diferente de produto atribui .F. para a variavel
						lSoProd := .F.
					EndIf
					If lSEQUEN0
						dMINSTL := aCoBrw6[nXX,nDtI]
						hMINSTL := aCoBrw6[nXX,nHoI]
						dMAXSTL := aCoBrw6[nXX,nDtF]
						hMAXSTL := aCoBrw6[nXX,nHoF]
						lSEQUEN0 := .F.
					EndIf
					If aCoBrw6[nXX,nDtI] < dMINSTL
						dMINSTL := aCoBrw6[nXX,nDtI]
						hMINSTL := aCoBrw6[nXX,nHoI]
					ElseIf aCoBrw6[nXX,nDtI] = dMINSTL
						hMINSTL := If(aCoBrw6[nXX,nHoI] < hMINSTL,aCoBrw6[nXX,nHoI],hMINSTL)
					EndIf
					dMAXF := aCoBrw6[nXX,nDtF]
					hMAXF := aCoBrw6[nXX,nHoF]
					If dMAXF > dMAXSTL
						dMAXSTL := dMAXF
						hMAXSTL := hMAXF
					ElseIf dMAXF = dMAXSTL
						dMAXSTL := If(dMAXF > dMAXSTL,dMAXF,dMAXSTL)
						hMAXSTL := If(hMAXF > hMAXSTL,hMAXF,hMAXSTL)
					EndIf
				Next nXX
			EndIf

			//Se possuir vários tipos de insumos deve validar com o produto, pois os produtos estão no array aFin2P
			If Len( aFin2P ) > 0

				//Verifica se a data do produto é menor a do outro insumo, se for deve pegar a data e horário desse produto
				If aFin2P[1] < dMINSTL

					dMINSTL := aFin2P[1]
					hMINSTL := aFin2P[2]

				//Se a data do produto for igual ao do outro insumo, deve verificar qual possui o menor horário para ser considerado
				ElseIf aFin2P[1] == dMINSTL .And. aFin2P[2] <= hMINSTL

					hMINSTL := aFin2P[2]

				EndIf

				//Verifica se a data do produto é menor a do outro insumo, se for deve pegar a data e horário desse produto
				If aFin2P[3] > dMAXSTL

					dMAXSTL := aFin2P[3]
					hMAXSTL := aFin2P[4]

				//Se a data do produto for igual ao do outro insumo, deve verificar qual possui o menor horário para ser considerado
				ElseIf aFin2P[3] == dMAXSTL .And. aFin2P[4] >= hMAXSTL

						hMAXSTL := aFin2P[4]

				EndIf

			EndIf

			//Valida se tem Data/Hora FIM OS
			If lRet .And. !lSemIns .And. !lTemIReal
				MsgInfo(STR0108+stj->tj_ordem+STR0106+; //"A Ordem de Serviço "###" não poderá ser finalizada, pois"
				chr(13)+chr(10)+STR0109,STR0037) //"não existe insumo realizado."###"ATENÇÃO"
				lRet := .F.
			EndIf

			// Se estiver integrado ao SIGASFC
			// Verifica se é possível finalizar a O.S.
			If lRet .And. lIntSFC .And. !NGSFCATPRD(STJ->TJ_ORDEM,{{"CZ2_LGMN",.F.}},.F.,.F.)
				NGSFCSNDML(4, {{STJ->TJ_ORDEM}})
				lRet := .F.
			EndIf

			If lRet
				nRET := 0
				//Finaliza OS
				aFinTmp := {dMINSTL,hMINSTL,dMAXSTL,hMAXSTL,lSoProd}
				fFina435("STJ",Recno(),4, aFinTmp,oOS:nAt, aFin2P)
				oBrw6:oBrowse:nAt := 1
				oBrw6:oBrowse:Refresh()
				oBrw6:oBrowse:SetFocus()
				If nRET == 1
					nPosAnt := oOS:nAt
					aAdd( aVetorFin , {cOrdem,cPlano} )
					aDel(aOS,oOS:nAt)
					aSize(aOS,Len(aOS)-1)
					If Len(aOS) == 0
						fEmptyOS(.T.)
					ElseIf ( nDataPos := aScan( aDadosOS, {|x|x[1] + x[2] == cOrdem + cPlano }) ) > 0

						aDel( aDadosOS, nDataPos )
						aSize( aDadosOS, Len( aDadosOS ) - 1 )

					EndIf
					If nPosAnt > Len(aOS)
						nPosAnt := Len(aOS)
					EndIf
					oOS:nAt := nPosAnt
					fRefreshOS( aOS[oOS:nAt,nPosOS], aOS[oOS:nAt,nPosPL] , oOS:nAt, 1 )
					If lArvoreLogica //Se for chamada atraves da Arvore Logica, a tela sera fechada, pois não ficará nenhuma OS listada no browse
						oDlg1:End()
						lRet := .T.
					EndIf
				EndIf
			EndIf

		Else
			MsgInfo(STR0099) //"Nenhuma ordem de serviço foi selecionada."
		EndIf
	EndIf

	If lRet .And. !lArvoreLogica
		PutFileInEof("STN")
		PutFileInEof("TPL")
		PutFileInEof("STL")
	EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Mnt435Can ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 01/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Funcionalidade do botao de cancelar  OS                      ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Mnt435Can()
	Local cOrdem, cPlano, nPosAnt, nLineOS
	Local nPos03 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local aAreaSTJ := {}

	If GetNewPar("MV_NGMNTCC","N") == "S"
		aAreaSTJ := GetArea()
		dbSelectArea("TV9")
		dbSetOrder(1)
		If dbSeek(xFilial("TV9")+STJ->TJ_CODBEM+STJ->TJ_ORDEM)
			MsgStop(STR0351,STR0312)
			Return .F.
		EndIf
		RestArea(aAreaSTJ)
	EndIf

	If Len(aOS) > 0
		cOrdem := aOS[oOS:nAt,nPosOS]
		cPlano := aOS[oOS:nAt,nPosPL]
		nLineOS := aScan(aDadosOS, {|x|x[1]+x[2] == cOrdem+cPlano })
		dbSelectArea("STJ")
		dbSetOrder(01)
		If dbSeek(xFilial("STJ")+cOrdem+cPlano)

			/* Ponto de entrada executado antes do cancelamento da O.S, como parâmetro
			o código da ordem a ser cancelada. */
			If ExistBlock( "MNTA435F" )
				If !ExecBlock( "MNTA435F",.F.,.F., {cOrdem})
					Return .F.
				EndIf
			EndIf

			//Verifica se a OS tem insumo realizado na tela
			If nPos03 > 0 .And. nLineOS > 0
				If aScan(aDadosOS[nLineOS,5], {|x| !x[Len(x)] .And. !Empty(x[nPos03]) }) > 0
					Help(" ",1,"HAREPORT")
					Return .F.
				EndIf
			EndIf

			// Caso integrado ao modulo SIGASFC, e o bem for uma maquina
			// Verifica se será possivel cancelar a parada programada relacionada a O.S.
			If lIntSFC .And. !Empty(NGVRFMAQ(STJ->TJ_CODBEM)) .And. ;
			!NGSFCDELPP(STJ->TJ_ORDEM,.F.,.F.)
				NGSFCSNDML(3, {{STJ->TJ_ORDEM}}) // Envia e-mail ao responsavel no SIGASFC
				Return .F.
			EndIf

			nPosAnt := oOS:nAt
			fGrava435(nPosAnt,.F.,.F.)
			If NG400EXC("STJ",Recno(),5) == 2
				aAdd( aVetorCan , {cOrdem,cPlano} )
				aDel(aOS,oOS:nAt)
				aSize(aOS,Len(aOS)-1)
				If Len(aOS) == 0
					fEmptyOS(.T.)
				EndIf
				If nPosAnt > Len(aOS)
					nPosAnt := Len(aOS)
				EndIf
				oOS:nAt := nPosAnt
				fRefreshOS( aOS[oOS:nAt,nPosOS], aOS[oOS:nAt,nPosPL] , oOS:nAt, 1 )
				If lArvoreLogica //Se for chamada atraves da Arvore Logica, a tela sera fechada, pois não ficará nenhuma OS listada no browse
					oDlg1:End()
					Return .T.
				EndIf
				/* Ponto de entrada executado no cancelamento da O.s, passa o por parâmetro
				o código da ordem a ser cancelada. */
				If ExistBlock( "MNTA435B" )
					ExecBlock( "MNTA435B",.F.,.F., {cOrdem})
				EndIf
			EndIf
		Else
			MsgInfo(STR0099) //"Nenhuma ordem de serviço foi selecionada."
		EndIf
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fMontInd ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 01/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Monta array com o titulo dos indices                        |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fMontInd(cAliasInd)
	Local aRet := { {} , {} }

	dbSelectArea("SIX")
	dbSetOrder(1)
	dbSeek(cAliasInd)
	While !EoF() .And. SIX->INDICE == cAliasInd
		aAdd(aRet[2], Alltrim(SIX->DESCRICAO) )
		aAdd(aRet[1], Alltrim(SIX->CHAVE) )
		dbSkip()
	End

Return aRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fTrbInsPre³ Autor ³Denis Hyroshi de Souza ³ Data ³ 01/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Cria arquivo temporario para Insumos Previstos             |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fTrbInsPre()

	Local nXX
	Local aNAO := {"TL_FILIAL","TL_ORDEM", "TL_PLANO", "TL_REPFIM",;
		"TL_NUMOP", "TL_ITEMOP", "TL_SEQUEOP", "TL_CODBEM",;
	  	"TL_SERVICO", "TL_SEQMAN", "TL_POSCONT", "TL_POSCON2", "TL_TIPOHOR", "TL_SEQUENC", "TL_SEQRMAN",;
	  	"TL_DOC", "TL_ITEM", "TL_ORIGNFE", "TL_SDOC", "TL_HREXTRA ", "TL_NOMTREG", "TL_NOMSEQ "}

	//Ponto de entrada utilizado para Inibir campos da tabela STL na GetDados.
	If ExistBlock ( "MNTA435E" )
		aNAO := ExecBlock("MNTA435E",.F.,.F.,aNAO)
	EndIf

	aHoBrw2 := NGHeader("STL", aNAO, .F.)

	nPosXXX := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
	If nPosXXX > 0
		aTemp := aClone(aHoBrw2[nPosXXX])
		aDel(aHoBrw2,nPosXXX)
		aSize(aHoBrw2,Len(aHoBrw2)-1)
		aAdd(aHoBrw2 , aClone(aTemp) )
	EndIf
	aCoBrw2 := BLANKGETD(aHoBrw2)

	aDBF   := {}
	aTRBIP := {}
	aAdd(aDBF,  {"TL_OK"     ,"C",02, 0 })
	aAdd(aDBF,  {"STATUS","C",01,0})
	aAdd(aTRBIP,{"TL_OK"     ,Nil," "    ,})
	For nXX := 1 To Len(aHoBrw2)
		aAdd(aDBF,  {Alltrim(aHoBrw2[nXX,2]),aHoBrw2[nXX,8],aHoBrw2[nXX,4], aHoBrw2[nXX,5] })
		If aHoBrw2[nXX,8] == "N"
			aAdd(aTRBIP,{Alltrim(aHoBrw2[nXX,2]),Nil,aHoBrw2[nXX,1],aHoBrw2[nXX,3] })
		Else
			If "TL_USACALE" == Alltrim(aHoBrw2[nXX,2])
				aAdd(aTRBIP,{"XX_USACAL",Nil,aHoBrw2[nXX,1],})
			ElseIf "TL_DESTINO" == Alltrim(aHoBrw2[nXX,2])
				aAdd(aTRBIP,{"XX_DESTIN",Nil,aHoBrw2[nXX,1],})
			ElseIf "TL_GARANTI" == Alltrim(aHoBrw2[nXX,2])
				aAdd(aTRBIP,{"XX_TEMGAR",Nil,aHoBrw2[nXX,1],})
			ElseIf "TL_TIPOREG" == Alltrim(aHoBrw2[nXX,2])
				aAdd(aTRBIP,{"XX_NOMINS",Nil,aHoBrw2[nXX,1],})
			Else
				aAdd(aTRBIP,{Alltrim(aHoBrw2[nXX,2]),Nil,aHoBrw2[nXX,1],})
			EndIf
		EndIf

		If "TL_CODIGO" == Alltrim(aHoBrw2[nXX,2])
			nPosTReg := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
			nPosTReg := Alltrim(Str(nPosTReg,6))
			nPosDTF := Alltrim(Str(aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM"}) ,6))
			nPosCOD := Alltrim(Str(aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO"}) ,6))
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NGPROD435() .And. ' +;
			"If(aCOLS[n]["+nPosTReg+"] = 'M' .And. !Empty(aCOLS[n]["+nPosDTF+"]) ,NGFUNCRH(M->TL_CODIGO,.T.,aCOLS[n]["+nPosDTF+"],.F.),.T.) .And. MNT435CUS()"
		ElseIf "TL_QUANTID" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NGQUANT435() .And. MNT435CUS()'
		ElseIf "TL_DTINICI" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NG435DTINI() .And. ' +;
			"If(aCOLS[n]["+nPosTReg+"] = 'M' ,NGFUNCRH(aCOLS[n]["+nPosCOD+"],.T.,M->TL_DTINICI,.F.),.T.) .And. MNT435CUS()"
		ElseIf "TL_HOINICI" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NG435HOINI() .And. MNT435CUS()'
		ElseIf "TL_DTFIM"   == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NG435DTFIM() .And. ' +;
			"If(aCOLS[n]["+nPosTReg+"] = 'M' ,NGFUNCRH(aCOLS[n]["+nPosCOD+"],.T.,M->TL_DTFIM,.F.),.T.) .And. MNT435CUS()"
		ElseIf "TL_HOFIM"   == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NG435HOFIM() .And. MNT435CUS()'
		ElseIf "TL_LOTECTL" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NG435LOTCT()'
		ElseIf "TL_NUMLOTE" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NG435NUMLO()'
		ElseIf "TL_LOCALIZ" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NG435LOCAL()'
		ElseIf "TL_GARANTI" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := "fValDel435( .T. ) .And. PERTENCE( 'SN' ) .And. fNgGar435( 'S' )"
		ElseIf "TL_TIPOREG" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NGRETNO435( M->TL_TIPOREG ) .And. MNT435CUS()'
		ElseIf "TL_QUANREC" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := If( Empty( aHoBrw2[nXX,6] ) , "MNT435CUS()" , Alltrim(aHoBrw2[nXX,6]) + " .And. MNT435CUS()" )
		ElseIf "TL_LOCAL" == Alltrim(aHoBrw2[nXX,2])
			aHoBrw2[nXX,6] := 'fValDel435( .T. ) .And. NGVALALMOX() .And. MNT435CUS()'
		EndIf
	Next nXX
	aAdd(aDBF,  {"XTL_SA"  ,"N",6, 0 }) //Tem SA
	aAdd(aDBF,  {"XX_USACAL"  ,"C",3, 0 })
	aAdd(aDBF,  {"XX_DESTIN"  ,"C",12, 0 })
	aAdd(aDBF,  {"XX_TEMGAR"  ,"C",3, 0 })
	aAdd(aDBF,  {"XX_NOMINS"  ,"C",15, 0 })

	oTmpTbl6 := NGFwTmpTbl(cTRBIP,aDBF,{{ "TL_TAREFA","TL_TIPOREG","TL_CODIGO","TL_SEQRELA" }})
	aHoBrw6 := aClone(aHoBrw2)
	aCoBrw6 := aClone(aCoBrw2)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ fAddEtap ³ Autor ³ Denis                 ³ Data ³ 17-09-99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Adiciona etapa de OS antiga nas etapas da OS corrente      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fAddEtap()

	Local aAreaXXXX := GetArea()
	Local aAreaTRBQ := (cTRBQ400)->(GetArea())

	If Empty((cTRBTAR)->TAREFA) .And. Empty((cTRBTAR)->ETAPA)
		Return .F.
	EndIf

	If (cTRBTAR)->(EoF())
		MsgInfo(STR0112) //"Não contém registro na tabela de etapas não realizadas."
		Return .F.
	EndIf

	dbSelectArea(cTRBQ400)
	dbSetOrder(2)
	dbGoTop()
	If !dbSeek( (cTRBTAR)->TAREFA + (cTRBTAR)->ETAPA + (cTRBQ400)->TQ_SEQETA)
		lFoiAlterado := .T.

		lInc435 := .T.
		If (cTRBQ400)->( LastRec() ) == 1
			(cTRBQ400)->(dbGoTop())
			If (cTRBQ400)->(!EoF()) .And. Empty((cTRBQ400)->TQ_ETAPA) .And. Empty((cTRBQ400)->TQ_TAREFA)
				lInc435 := .F.
			EndIf
		EndIf
		RecLock(cTRBQ400,lInc435)
		(cTRBQ400)->TQ_TAREFA  := (cTRBTAR)->TAREFA
		(cTRBQ400)->TQ_NOMTARE := (cTRBTAR)->NOMETAR
		(cTRBQ400)->TQ_ETAPA   := (cTRBTAR)->ETAPA
		(cTRBQ400)->TQ_NOMETAP := (cTRBTAR)->NOMEETA
		(cTRBQ400)->TQ_OK      := "  "
		(cTRBQ400)->TQ_ORDEM   := cOrdemTJ
		(cTRBQ400)->TQ_PLANO   := cPlanoTJ
		(cTRBQ400)->(MsUnlock())

		dbSelectArea(cTRBTAR)
		dbSetOrder(1)
		RecLock((cTRBTAR),.F.)
		dbDelete()
		(cTRBTAR)->(MsUnLock())

		If (cTRBTAR)->(EoF())
			dbSelectArea(cTRBTAR)
			dbGoTop()
		EndIf

		dbSelectArea(cTRBTAR)
		oBrw7:Refresh()
		dbSelectArea(cTRBQ400)
		oBrw4:oBrowse:Refresh()
		oBrw4:oBrowse:Refresh()
		oBrw4:oBROWSE:SetFocus()
	Else
		MsgInfo(STR0113) //"Esta tarefa/etapa já existe para a Ordem de Serviço."
	EndIf

	RestArea(aAreaTRBQ)
	RestArea(aAreaXXXX)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³Mnt435Mark³ Autor ³ Denis                 ³ Data ³ 17-09-99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Inclui/Exclui Uma etapa                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Mnt435Mark()

	Local aAreaTRB := (cTRBQ400)->(GetArea())

	lFoiAlterado := .T.
	dbSelectarea(cTRBQ400)
	dbSetOrder(2)
	dbSeek((cTRBQ400)->TQ_TAREFA+(cTRBQ400)->TQ_ETAPA+(cTRBQ400)->TQ_SEQETA)
	RecLock(cTRBQ400, .F.)

	If lCpoPerc
		If !Empty((cTRBQ400)->TQ_OK)

			(cTRBQ400)->TQ_PER_OLD := (cTRBQ400)->TQ_PERCENT
			(cTRBQ400)->TQ_PERCENT := 100
		Else
			If (cTRBQ400)->TQ_PER_OLD == 100
				(cTRBQ400)->TQ_PER_OLD := 0
			EndIf

			(cTRBQ400)->TQ_PERCENT := (cTRBQ400)->TQ_PER_OLD
		EndIf
	EndIf

	If Empty((cTRBQ400)->TQ_OK)
		(cTRBQ400)->TQ_CODFUNC := Space( TamSX3('TQ_CODFUNC')[1] )
	EndIf

	(cTRBQ400)->(MsUnlock())
	fMNTA405()
	fLegendEt((cTRBQ400)->TQ_TAREFA+(cTRBQ400)->TQ_ETAPA+(cTRBQ400)->TQ_SEQETA) //Define as cores para legenda de etapas

	RestArea(aAreaTRB)
Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fCadEtapa
Cadastro de etapas

@param nOpcx, string, operação: 1=incluir;2=excluir;3=alterar
@author Denis
@since 17/09/99
@return bollean, se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function fCadEtapa(nOPCX)

	Local cAreaXXX   := Alias()
	Local aAreaSTJ   := STJ->(GetArea())
	Local aAreaTRB   := (cTRBQ400)->(GetArea())
	Local cCadOld    := cCadastro
	Local nOldPerc   := 0
	Local lUSATARL   := NGUSATARPAD()
	Local lCORRET    := If(Val(STJ->TJ_PLANO) == 0,.T.,.F.)
	// [LGPD] Caso o usuário não possua acesso ao(s) campo(s), deve-se ofuscá-lo(s)
	Local lOfuscar := FindFunction( 'FWPDCanUse' ) .And. FwPdCanUse( .T. );
						.And. Len( FwProtectedDataUtil():UsrAccessPDField( __CUSERID, { 'T1_NOME' } ) ) == 0
	Local oldHead
	Local oldCols
	Local lIncOpc    := .F.
	Local lTemOsG    := .F.
	Local lRet       := .F.
	Local cVldEtapa  := 'NGSTQETA(M->TQ_ETAPA) '
	Local cVldTarefa := 'If(FindFunction("NGGTARPADRA") .And. cF3T=="TT9",NGSTLTAR(STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA,M->TQ_TAREFA),NGSTQTAR(M->TQ_TAREFA))'
	Local cValidUser := ""

	Private lCheckEta := .F.
	Private lCheckFun := .F.
	Private oGetExeSRA, oGetExeNom, oGetSeqEta
	If ExistBlock( "MNTA4359" )
		lRet := ExecBlock( "MNTA4359",.F.,.F.,{ nOPCX,(cTRBQ400) } )
		If !lRet
			Return .F.
		EndIf
	EndIf

	nOPCA   := 0
	aCOLS   := {}

	M->TQ_TAREFA  := Space(TamSX3('TQ_TAREFA')[1])
	M->TQ_NOMTARE := Space(TamSX3('TQ_NOMTARE')[1])
	M->TQ_ETAPA   := Space(TamSX3('TQ_ETAPA')[1])
	M->TQ_NOMETAP := Space(TamSX3('TQ_NOMETAP')[1])
	M->TQ_SEQETA  := Space(TamSX3('TQ_SEQETA')[1])
	M->TQ_PERCENT := 0
	M->TQ_CODFUNC := Space( TamSX3('TQ_CODFUNC')[1] )
	M->TQ_OBSERVA := Space(TamSX3('TQ_OBSERVA')[1])
	cNOMFUNC      := Space(30)
	M->TQ_SEQTARE := Space(TamSX3('TQ_SEQTARE')[1])

	//Nao pode desmarcar Etapa, caso a resposta desta etapa gerou uma OS e esta OS nao esta com situação cancelada
	If !Empty((cTRBQ400)->TQ_OK) .And. nOPCx <> 1
		//Verifica se foi gerada OS para esta etapa, e a OS gerada nao esta cancelada
		If nOPCx == 2 //Se Exclusão
			If !MNT400OSG( (cTRBQ400)->TQ_ORDEM , (cTRBQ400)->TQ_PLANO , (cTRBQ400)->TQ_TAREFA , (cTRBQ400)->TQ_ETAPA , .T. ,  .T.  )
				Return .F.
			ElseIf !MNT400SSG( (cTRBQ400)->TQ_ORDEM, (cTRBQ400)->TQ_PLANO, (cTRBQ400)->TQ_TAREFA, (cTRBQ400)->TQ_ETAPA )
				Return .F.
			EndIf
		Else //Se Alteracao
			If !MNT400OSG( (cTRBQ400)->TQ_ORDEM , (cTRBQ400)->TQ_PLANO , (cTRBQ400)->TQ_TAREFA , (cTRBQ400)->TQ_ETAPA , .F. ,  .F.  )
				lTemOsG := .T.
			EndIf
		EndIf
	EndIf

	dbSelectArea("STJ")
	dbSetOrder(1)
	dbSeek( xFilial("STJ") + cOrdemTJ + cPlanoTJ )
	If nOPCX != 1
		dbSelectArea("ST5")
		dbSetOrder(1)
		dbSeek(xFilial("ST5")+STJ->TJ_CODBEM + STJ->TJ_SERVICO + STJ->TJ_SEQRELA + (cTRBQ400)->TQ_TAREFA)
		M->TQ_TAREFA  := (cTRBQ400)->TQ_TAREFA
		M->TQ_NOMTARE := NGNOMETAR( STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA , (cTRBQ400)->TQ_TAREFA )
		dbSelectArea("TPA")
		dbSetOrder(1)
		dbSeek(xFilial("TPA") + (cTRBQ400)->TQ_ETAPA)
		M->TQ_ETAPA   := (cTRBQ400)->TQ_ETAPA
		M->TQ_NOMETAP := TPA->TPA_DESCRI
		M->TQ_SEQETA  := (cTRBQ400)->TQ_SEQETA
		M->TQ_SEQTARE := (cTRBQ400)->TQ_SEQTARE
		M->TQ_OBSERVA := (cTRBQ400)->TQ_OBSERVA
		M->TQ_CODFUNC := (cTRBQ400)->TQ_CODFUNC
		M->TQ_OBSERVA := (cTRBQ400)->TQ_OBSERVA

		dbSelectArea("ST1")
		dbSetOrder(1)
		dbSeek(xFilial("ST1")+M->TQ_CODFUNC)
		cNOMFUNC      := ST1->T1_NOME
		If lCpoPerc
			M->TQ_PERCENT := (cTRBQ400)->TQ_PERCENT
			If !Empty((cTRBQ400)->TQ_OK)
				M->TQ_PERCENT := 100
				nOldPerc      := 100
			Else
				nOldPerc := M->TQ_PERCENT
			EndIf
		Else
			If !Empty((cTRBQ400)->TQ_OK)
				lCheckEta := .T.
				nOldPerc  := 100
			EndIf
		EndIf
	EndIf

	If nOPCx <> 1
		If Empty(M->TQ_ETAPA)
			Return
		EndIf
	EndIf

	//Busca as validações de usuário no campo de etapa e tarefa.
	cValidUser := Posicione("SX3",2,"TQ_TAREFA","X3_VLDUSER")
	If !Empty(cValidUser)
		cVldTarefa += " .And. " + cValidUser
	EndIf

	cValidUser := Posicione("SX3",2,"TQ_TAREFA","X3_VLDUSER")
	If !Empty(cValidUser)
		cVldEtapa += " .And. " + cValidUser
	EndIf

	oldHead := aClone(aHeader)
	oldCols := aClone(aCols)
	aHeader := nil
	aCols   := {}

	cF3T := "ST5"
	If (( lUSATARL .And. lCORRET ) .Or. AllTrim( STJ->TJ_SERVICO ) == "HISTOR" )
		cF3T := "TT9"
	EndIf
	cCadastro := STR0114 //"Etapas da O.S."


	DEFINE MSDIALOG oDlg5 TITLE cCadastro+"  "+Alltrim(cOrdemTJ)+" - "+If(nOPCX=1,STR0028,If(nOPCX=3,STR0029,STR0030)) From 15,20 To 35,78 OF oMainWnd //"Incluir"###"Alterar"###"Excluir"

		oPanel := TPanel():New( 00,00,,oDlg5,,,,,CLR_WHITE,18,12,.F.,.F. )
		oPanel:Align := CONTROL_ALIGN_ALLCLIENT

		@ 10.5,5 Say OemToAnsi(STR0023) SIZE 37,7 OF oPanel PIXEL //"Tarefa"
		@ 10,040 MsGet M->TQ_TAREFA  SIZE 025,7 OF oPanel PIXEL F3 cF3T ;
		VALID &(cVldTarefa)  WHEN (nOPCX == 1) HASBUTTON
		@ 10,075 MsGet M->TQ_NOMTARE SIZE 150,7 OF oPanel PIXEL When .F.

		@ 25.5,5 Say OemToAnsi(STR0025) SIZE 37,7 OF oPanel PIXEL    //"Etapa"
		@ 25,040 MsGet M->TQ_ETAPA   SIZE 025,7 OF oPanel PIXEL F3 "MNTTAR" VALID &(cVldEtapa) WHEN (nOPCX == 1) HASBUTTON
		@ 25,075 MsGet M->TQ_NOMETAP SIZE 150,7 OF oPanel PIXEL When .F.

		@ 40.5,5 Say OemToAnsi(STR0115) SIZE 37,7 OF oPanel PIXEL //"Seq.Etapa"
		@ 40,040 MsGet oGetSeqEta Var M->TQ_SEQETA  SIZE 025,7 OF oPanel PIXEL WHEN (nOPCX != 2)

		If lCpoPerc
			@ 40.5,075 Say OemToAnsi(STR0068) SIZE 37,7 OF oPanel PIXEL    //"% Concluida"
			@ 40,110   MsGet M->TQ_PERCENT SIZE 025,7 Picture "999" Valid ValEtaFun(1) OF oPanel PIXEL WHEN (nOPCX != 2 .And. !lTemOsG) HASBUTTON
		Else
			@ 40.5,075 CheckBox oCBox3 Var lCheckEta Prompt STR0116 OF oPanel On Change ValEtaFun(2) Pixel SIZE 80,09 WHEN (nOPCX != 2 .And. !lTemOsG) //"Etapa Concluída?"
		EndIf

		@ 55.5,5 Say OemToAnsi(STR0060) SIZE 37,7 OF oPanel PIXEL //Observação
		@ 55,040 GET oMemo VAR M->TQ_OBSERVA MEMO SIZE 185,25 OF oPanel PIXEL

		@ 87.5,5 Say Oemtoansi(STR0066) OF oPanel PIXEL //"Executante"
		If lCpoPerc
			@ 87,040 MsGet oGetExeSRA Var M->TQ_CODFUNC  Picture "@!" Size 025,7 F3 "ST1" Valid ValFunExe(M->TQ_CODFUNC) OF oPanel PIXEL WHEN (nOPCX != 2 .And. M->TQ_PERCENT == 100) HASBUTTON
		Else
			@ 87,040 MsGet oGetExeSRA Var M->TQ_CODFUNC  Picture "@!" Size 025,7 F3 "ST1" Valid ValFunExe(M->TQ_CODFUNC) OF oPanel PIXEL WHEN (nOPCX != 2 .And. lCheckEta) HASBUTTON
		EndIf
		@ 87,075 MsGet oGetExeNom Var cNOMFUNC When .F. Size 150,7 OF oPanel PIXEL
		If lOfuscar
			oGetExeNom:lObfuscate := .T.
			oGetExeNom:bWhen := {|| .F. }
		EndIf

		@ 102,5 CheckBox oCBoxF Var lCheckFun Prompt STR0117 OF oPanel Pixel SIZE 200,09 WHEN (nOPCX != 2 .And. !Empty(M->TQ_CODFUNC)) //"Deseja replicar este executante nas demais etapas concluídas?"

	ACTIVATE MSDIALOG oDlg5 ON INIT EnchoiceBar(oDlg5,{||nOpca:=1,oDlg5:End()},{||oDlg5:End()}) CENTERED

	If nOPCA == 1
		lFoiAlterado := .T.
		If nOPCx == 1
			dbSelectArea(cTRBQ400)
			dbSetOrder(2)
			lInc435 := .T.
			If (cTRBQ400)->(Reccount()) == 1
				(cTRBQ400)->(dbGoTop())
				If (cTRBQ400)->(!EoF()) .And. Empty((cTRBQ400)->TQ_ETAPA) .And. Empty((cTRBQ400)->TQ_TAREFA)
					lInc435 := .F.
				EndIf
			EndIf
			If !dbSeek(M->TQ_TAREFA + M->TQ_ETAPA) //Não permitirá tarefa/etapa igual
				RecLock(cTRBQ400,lInc435)
				(cTRBQ400)->TQ_TAREFA  := M->TQ_TAREFA
				(cTRBQ400)->TQ_NOMTARE := M->TQ_NOMTARE
				(cTRBQ400)->TQ_ETAPA   := M->TQ_ETAPA
				(cTRBQ400)->TQ_NOMETAP := M->TQ_NOMETAP
				(cTRBQ400)->TQ_SEQETA  := M->TQ_SEQETA
				(cTRBQ400)->TQ_SEQTARE := M->TQ_SEQTARE
				(cTRBQ400)->TQ_CODFUNC := M->TQ_CODFUNC
				(cTRBQ400)->TQ_OBSERVA := M->TQ_OBSERVA
				(cTRBQ400)->CODBEM     := STJ->TJ_CODBEM

				If lCpoPerc
					(cTRBQ400)->TQ_PERCENT := M->TQ_PERCENT
					If M->TQ_PERCENT == 100
						(cTRBQ400)->TQ_OK := cMarca
						lIncOpc := .T.
					Else
						(cTRBQ400)->TQ_OK := "  "
					EndIf
				Else
					If lCheckEta
						(cTRBQ400)->TQ_OK := cMarca
						lIncOpc := .T.
					Else
						(cTRBQ400)->TQ_OK := "  "
					EndIf
				EndIf
				(cTRBQ400)->TQ_ORDEM   := cOrdemTJ
				(cTRBQ400)->TQ_PLANO   := cPlanoTJ
				(cTRBQ400)->(MsUnlock())

				fLegendEt((cTRBQ400)->TQ_TAREFA+(cTRBQ400)->TQ_ETAPA+(cTRBQ400)->TQ_SEQETA) //Define as cores para legenda de etapas
				
			Else
				MsgAlert(STR0113, STR0037)
			EndIf
			aAreaTRB := (cTRBQ400)->(GetArea())
		ElseIf nOPCx == 2
			dbSelectArea(cTRBQ400)
			dbSetOrder(2)
			dbSeek((cTRBQ400)->TQ_TAREFA + (cTRBQ400)->TQ_ETAPA + (cTRBQ400)->TQ_SEQETA)
			RecLock(cTRBQ400,.F.)
			dbDelete()
			MsUnLock()
			RestArea(aAreaTRB)
			Pack
		ElseIf nOPCx == 3
			RestArea(aAreaTRB)
			RecLock(cTRBQ400,.F.)
			(cTRBQ400)->TQ_SEQETA  := M->TQ_SEQETA
			(cTRBQ400)->TQ_SEQTARE := M->TQ_SEQTARE
			(cTRBQ400)->TQ_CODFUNC := M->TQ_CODFUNC
			(cTRBQ400)->TQ_OBSERVA := M->TQ_OBSERVA
			If lCpoPerc
				(cTRBQ400)->TQ_PERCENT := M->TQ_PERCENT
				If M->TQ_PERCENT == 100
					If nOldPerc < 100
						lIncOpc := .T.
					EndIf
					(cTRBQ400)->TQ_OK := cMarca
					(cTRBQ400)->TQ_PER_OLD := 0
				Else
					(cTRBQ400)->TQ_OK := "  "
					(cTRBQ400)->TQ_PER_OLD := nOldPerc
				EndIf
			Else
				If lCheckEta
					If nOldPerc == 0
						lIncOpc := .T.
					EndIf
					(cTRBQ400)->TQ_OK := cMarca
				Else
					(cTRBQ400)->TQ_OK := "  "
				EndIf
			EndIf
			
			(cTRBQ400)->(MsUnlock())

			fLegendEt((cTRBQ400)->TQ_TAREFA+(cTRBQ400)->TQ_ETAPA+(cTRBQ400)->TQ_SEQETA) //Define as cores para legenda de etapas
			
		EndIf

		If nOPCx != 2 .And. lIncOpc
			fMNTA405()
		EndIf

		//--------------------------------------------------
		//Replica executante nas demais etapas concluidas
		//somente nas etapas que não estão gravadas no banco
		//--------------------------------------------------
		If lCheckFun .And. !Empty(M->TQ_CODFUNC)
			dbSelectArea(cTRBQ400)
			dbGoTop()
			While !(cTRBQ400)->( EoF() )
				If !Empty( (cTRBQ400)->TQ_OK ) .And. ( Empty( (cTRBQ400)->TQ_CODFUNC ) .Or.;
					!fRecord( cTRBQ400 ) )

					(cTRBQ400)->TQ_CODFUNC := M->TQ_CODFUNC
				EndIf
				(cTRBQ400)->( dbSkip() )
			EndDo
		EndIf

		//Atualiza tabelas temporárias/arrays com as alterações de etapas
		Fd_Sai( 4 )

		//Chama ponto de entrada para imprimir a O.S.
		If nOPCx == 1
			If ExistBlock ( "MNTA435K" )
				ExecBlock("MNTA435K",.F.,.F.,{ cOrdemTJ, cTRBQ400 } )
			EndIf
		EndIf

	EndIf

	aHeader := aClone(oldHead)
	aCols   := aClone(oldCols)

	cCadastro := cCadOld
	RestArea(aAreaSTJ)

	dbSelectArea(cTRBQ400)
	dbSetOrder(3) 
	oBrw4:oBrowse:Refresh()
	oBrw4:oBrowse:Refresh()
	oBrw4:oBROWSE:SetFocus()
	dbSelectArea(cAreaXXX)

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ ValFunExe³ Autor ³ Denis                 ³ Data ³29/06/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Valida funcionario executante da etapa                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function ValFunExe(cTQ_CODFUNC)
	Local lRet := NG400FUN(cTQ_CODFUNC)

	If ValType(lRet) == "L"
		If !lRet
			Return .F.
		EndIf
	EndIf

	If Empty(cTQ_CODFUNC)
		lCheckFun := .F.
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ ValEtaFun³ Autor ³ Denis                 ³ Data ³29/06/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Valida se habilita campo Executante ou nao                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function ValEtaFun(nTipo)
	If nTipo == 1

		If !Positivo(M->TQ_PERCENT)
			Return .F.
		EndIf

		If M->TQ_PERCENT > 100

			MsgInfo(STR0118) //"Porcentagem não pode ser maior que 100%"
			Return .F.

		ElseIf M->TQ_PERCENT != 100

			If M->TQ_PERCENT == 0
				//De acordo com a utilização do Ponto de Entrada MNTA435G para gravação do código do funcionário padrão
				If Empty(cCodFunc)
					M->TQ_CODFUNC	:= Space( TamSX3('TQ_CODFUNC')[1] )
					cNOMFUNC		:= Space(30)
				Else
					M->TQ_CODFUNC	:= cCodFunc
					dbSelectArea("ST1")
					dbSetOrder(1)
					If dbSeek(xFilial("ST1")+M->TQ_CODFUNC)
						cNOMFUNC		:= ST1->T1_NOME
					EndIf
				EndIf
				lCheckFun     := .F.
			EndIf

		EndIf
	Else
		If !lCheckEta
			//De acordo com a utilização do Ponto de Entrada MNTA435G para gravação do código do funcionário padrão
			If Empty(cCodFunc)
				M->TQ_CODFUNC	:= Space( TamSX3('TQ_CODFUNC')[1] )
				cNOMFUNC		:= Space(30)
			Else
				M->TQ_CODFUNC	:= cCodFunc
				dbSelectArea("ST1")
				dbSetOrder(1)
				If dbSeek(xFilial("ST1")+M->TQ_CODFUNC)
					cNOMFUNC		:= ST1->T1_NOME
				EndIf
			EndIf
			lCheckFun     := .F.
		EndIf
	EndIf

	oGetExeSRA:Refresh()
	oGetExeNom:Refresh()
	oGetSeqEta:SetFocus()

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³TudOkTL435³ Autor ³ Denis Hyroshi         ³ Data ³17/07/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Validacao completa do insumo realizado                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function TudOkTL435(nPosSTL)

	Local nInd
	Local nOld 		:= n

	For nInd := 1 to Len(aCols)
		n := nInd
		If !LinOkTL435()
			nPosSTL := nInd
			Return .F.
		EndIf
	Next nInd

	// caso tudo correto, reiniciar propriedade que valida se foi alterado utilizada no linok
	oBrw6:lModified := .F.
	n := nOld

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³LinOkTL435³ Autor ³ Denis Hyroshi         ³ Data ³17/07/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Validacao da linha do insumo realizado                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LinOkTL435()

	Local nXX, nPosSav, nZZ
	Local cOLDALI := ALIAS()
	Local lPROPLSTL := .F.

	Local nLineOS   := aScan(aDadosOS, {|x|x[1]+x[2] == cOrdemTJ+cPlanoTJ })
	Local nOperacao := 1 //1-Incluir, 2-Alterar ou 3-Visualizar
	Local nPosTL    := n //oBrw6:oBrowse:nAt
	Local lAltGara  := .F.
	Local lBaixaEst := .T. // Variável para bloqueio de movimentação do estoque - Ponto de Entrada MNT4356
	Local lMNTA435O	:= ExistBlock("MNTA435O")
	Local aVetSTL 	:= {}
	Local lVerDt    := !(STJ->TJ_SERVICO == 'HISTOR' .And. cUIntHis == 'N')

	nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	nPos02 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DESTINO"})
	nPos03 := aScan(aHeader,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	nPos04 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_UNIDADE"})
	nPos05 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"  })
	nPos06 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI"})
	nPos07 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOINICI"})
	nPos08 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM"  })
	nPos09 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOFIM"  })
	nPos10 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANTID"})
	nPos11 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMLOTE"})
	nPos12 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOTECTL"})
	nPos13 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCALIZ"})
	nPos14 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSERI"})
	nPos15 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_GARANTI"})
	nPos16 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TAREFA" })
	nPos18 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
	nPos19 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSEQ" })
	nPos20 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_MOEDA"  })
	nPos21 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CUSTO"  })
	nPos22 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANREC"})
	nPos23 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NOMTAR" })
	nPos24 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_ETAPA"  })
	nPos26 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAPLI"})
	nPos27 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NOTFIS"})
	nPos28 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SERIE"})
	nPos29 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_FORNEC"})
	nPos30 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOJA"})

	If aCols[n, nPos18] != Padr('0', TamSx3('TL_SEQRELA')[1], ' ') .And. Val(aCols[n, nPos18]) == 0
		Help( NIL, 1, STR0174, NIL, STR0398, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0399} ) // "ATENÇÃO"###"A ordem de serviço chegou ao limite temporário de 999 insumos realizados, para continuar reportando insumos realizados crie uma nova ordem de serviço."###"Estamos atuando em melhorias para aumentar o limite de insumos realizados."
		Return .F.
	EndIf

	If nPos03 == 0
		n := oBrw6:oBrowse:nAt
		aHeader := aClone( aHoBrw6 )
		aCols   := aClone( aCoBrw6 )
		Return .T.
	EndIf

	// Não realiza processo de validação, caso não possua registro alterado.
	If !oBrw6:lModified
		Return .T.
	EndIf

	If aCols[n,Len(aCols[n])] //Nao validar se deletado
		Return .T.
	EndIf

	If Empty(aCols[n,nPos01])
		MsgInfo(STR0119,STR0037) //"O campo Tipo Insumo é obrigatório."###"ATENÇÃO"
		Return .F.
	EndIf
	If Empty(aCols[n,nPos03])
		MsgInfo(STR0120,STR0037) //"O campo Código Insumo é obrigatório."###"ATENÇÃO"
		Return .F.
	EndIf
	If Empty(aCols[n,nPos16])
		MsgInfo(STR0121,STR0037) //"O campo Tarefa é obrigatório."###"ATENÇÃO"
		Return .F.
	EndIf
	If aCols[n,nPos01] == 'F' .AND. aCols[n,nPos22] == 0
		MsgInfo(STR0381,STR0037) //"O campo Quant. Rec. é obrigatório."###"ATENÇÃO"
		Return .F.
	Endif
	If Empty(aCols[n,nPos06])
		MsgInfo(STR0123,STR0037) //"O campo Data Início é obrigatório."###"ATENÇÃO"
		Return .F.
	EndIf
	If Empty(aCols[n,nPos07])
		MsgInfo(STR0124,STR0037) //"O campo Hora Início é obrigatório."###"ATENÇÃO"
		Return .F.
	EndIf
	If aCols[n,nPos06] > dDataBase
		MsgInfo(STR0125,STR0037) //"O campo Data Início não pode ser maior do que a data atual."###"ATENÇÃO"
		Return .F.
	EndIf
	If aCols[n,nPos08] > dDataBase
		MsgInfo(STR0126,STR0037) //"O campo Data Fim não pode ser maior do que a data atual."###"ATENÇÃO"
		Return .F.
	EndIf

	//Validação do preenchimento do campo TL_LOCAPLI, quando obrigatório
	If nPos26 > 0 .And. Empty(aCols[n,nPos26]) .And. X3Obrigat(aHoBrw2[nPos26][2])
		MsgInfo(STR0357,STR0037) //"O campo Local de Aplicação é obrigatório."###"ATENÇÃO"
		Return .F.
	EndIf

	// Valida obrigatoriedade do campo GARANTIA
	If nPos15 > 0 .And. Empty( aCols[ n, nPos15 ] ) .And. X3Obrigat( aHoBrw2[ nPos15, 2 ] )
		MsgInfo( STR0385 , STR0037) //###"ATENÇÃO" // "O campo 'Tem Garantia é obrigatório."
		Return .F.
	EndIf

	// Valida se a data de baixa de estoque é maior que a data de bloqueio de estoque (LinOkTL435)
	If nLineOS > 0
		nOperacao := 3 //1-Incluir, 2-Alterar ou 3-Visualizar
		nLinTmp := nPosTL
		nPosSav := aScan(aDadosOS[nLineOS,4] ,{|x|  x[nPos01] == aCols[nLinTmp,nPos01]  .And. ;
		x[nPos03] == aCols[nLinTmp,nPos03] .And. ;
		x[nPos18] == aCols[nLinTmp,nPos18] })
		If nPosSav > 0//Len(aDadosOS[nLineOS,4]) >= nLinTmp
			lAlterou := .F.
			For nZZ := 1 To Len(aDadosOS[nLineOS,4,nPosSav])-2
				//Posições que pode haver alteração sem validação do linha OK , campos Código da tarefa,nome tarefa, destino, garantia e Local de aplicação
				If aCols[ nLinTmp , nZZ ] != aDadosOS[nLineOS,4,nPosSav,nZZ] .And. ;
				( nZZ <> nPos16 .And. nZZ <> nPos23 .And. nZZ <> nPos02 .And. nZZ <> nPos15 .And. nZZ <> nPos26)

					lAlterou := .T.

					Exit
				EndIf
			Next nZZ

			If lAlterou

				nOperacao := 2 //1-Incluir, 2-Alterar ou 3-Visualizar

				// Valida se a data de baixa de estoque é maior que a data de bloqueio de estoque (LinOkTL435)
				If aCols[nLinTmp,nPos01] $ 'P/M' .And. ;
					( aCols[nLinTmp,nPos03] <> aDadosOS[nLineOS,4,nPosSav,nPos03] .Or. ;
					aCols[nLinTmp,nPos10] <> aDadosOS[nLineOS,4,nPosSav,nPos10] .Or. ;
					aCols[nLinTmp,nPos06] <> aDadosOS[nLineOS,4,nPosSav,nPos06] ) .And.;
					lVerDt .And. !MNTValDBl(aCols[n,nPos06])

					Return .F.

				EndIf
			EndIf
		Else
			nOperacao := 1 //1-Incluir, 2-Alterar ou 3-Visualizar
			If aCols[nLinTmp,nPos01] $ 'P/M' .And. lVerDt .And. !MNTValDBl(aCols[n,nPos06])
				Return .F.
			EndIf
		EndIf
	EndIf

	If nPos20 > 0 .And. !( aCols[n,nPos20] $ "1/2/3/4/5" )
		MsgInfo(STR0252,STR0037) //"O campo Moeda é obrigatório."###"ATENÇÃO"
		Return .F.
	EndIf

	dbSelectArea('SD1')
	dbSetOrder(1)
	If aCols[n,nPos01] == "P" .And. aCols[n,nPos08] == dDataBase .And. aCols[n,nPos09] > SubS(Time(),1,5) .And. ;
	!dbSeek( xFilial('SD1') + aCols[ n, nPos27 ] + aCols[ n, nPos28 ] + aCols[ n, nPos29 ] + aCols[ n, nPos30 ] + ;
	IIF( aCols[ n, nPos01 ] == 'T', NGProdMNT('T')[1], aCols[ n, nPos03 ] ) )
		MsgInfo(STR0245,STR0037)
		Return .F.
	EndIf
	//verifica qual é a operação da linha nOperacao := 1-Incluir, 2-Alterar ou 3-Visualizar
	If nLineOS > 0
		nOperacao := 3 //1-Incluir, 2-Alterar ou 3-Visualizar
		nLinTmp := nPosTL
		nPosSav := aScan(aDadosOS[nLineOS,4] ,{|x|  x[nPos01] == aCols[nLinTmp,nPos01]  .And. ;
		x[nPos03] == aCols[nLinTmp,nPos03] .And. ;
		x[nPos18] == aCols[nLinTmp,nPos18] })
		If nPosSav > 0//Len(aDadosOS[nLineOS,4]) >= nLinTmp
			lAlterou := .F.
			For nXX := 1 To Len(aDadosOS[nLineOS,4,nPosSav])-2
				//Posições que pode haver alteração sem validação do linha OK , campos Código da tarefa,nome tarefa, destino e garantia
				If aCols[ nLinTmp , nXX ] != aDadosOS[nLineOS,4,nPosSav,nXX] .And. ;
				( nXX <> nPos16 .And. nXX <> nPos23 .And. nXX <> nPos02 .And. nXX <> nPos15)

					lAlterou := .T.

					Exit
				EndIf
			Next nXX
			If lAlterou
				nOperacao := 2 //1-Incluir, 2-Alterar ou 3-Visualizar
				If aCols[nLinTmp,nPos01] <> aDadosOS[nLineOS,4,nPosSav,nPos01] .Or. aCols[nLinTmp,nPos03] <> aDadosOS[nLineOS,4,nPosSav,nPos03]
					lAltGara := .T.
				EndIf
			EndIf
		Else
			nOperacao := 1 //1-Incluir, 2-Alterar ou 3-Visualizar
		EndIf
	EndIf

	cOrdem2 := Space(Len(STL->TL_ORDEM))
	cPlano1 := Space(Len(STL->TL_PLANO))
	nSequen := Space(3)
	lRET    := .T.

	M->TL_TIPOREG := aCols[ nPosTL , nPos01 ]
	M->TL_DESTINO := aCols[ nPosTL , nPos02 ]
	M->TL_CODIGO  := aCols[ nPosTL , nPos03 ]
	M->TL_UNIDADE := aCols[ nPosTL , nPos04 ]
	M->TL_LOCAL   := aCols[ nPosTL , nPos05 ]
	M->TL_DTINICI := aCols[ nPosTL , nPos06 ]
	M->TL_HOINICI := aCols[ nPosTL , nPos07 ]
	M->TL_DTFIM   := aCols[ nPosTL , nPos08 ]
	M->TL_HOFIM   := aCols[ nPosTL , nPos09 ]
	M->TL_QUANTID := aCols[ nPosTL , nPos10 ]
	M->TL_NUMLOTE := aCols[ nPosTL , nPos11 ]
	M->TL_LOTECTL := aCols[ nPosTL , nPos12 ]
	M->TL_LOCALIZ := aCols[ nPosTL , nPos13 ]
	M->TL_NUMSERI := aCols[ nPosTL , nPos14 ]
	M->TL_GARANTI := aCols[ nPosTL , nPos15 ]
	M->TL_TAREFA  := aCols[ nPosTL , nPos16 ]
	//Para evitar inconsistência sem o campo "em uso"
	If nPos19 > 0
		M->TL_NUMSEQ := aCols[ nPosTL , nPos19 ]
	Else
		M->TL_NUMSEQ := Space(Len(STL->TL_NUMSEQ))
	EndIf
	M->TL_ETAPA   := aCols[ nPosTL , nPos24 ]

	If nOperacao <> 1
		aVetSTL:= {cOrdemTJ, ;//Ordem
		aDadosOS[nLineOS,4,n,nPos03],;//Funcionário banco
		aDadosOS[nLineOS,4,n,nPos16],;//Tarefa no banco
		aDadosOS[nLineOS,4,n,nPos24],;//Etapa no banco
		aDadosOS[nLineOS,4,n,nPos06],;//Data Inicial banco
		aDadosOS[nLineOS,4,n,nPos07],;//Hora Inicial banco
		aDadosOS[nLineOS,4,n,nPos08],;//Data Final banco
		aDadosOS[nLineOS,4,n,nPos09],;// Hora Final banco
		M->TL_CODIGO,;		//Código do Funcionário memória
		M->TL_TAREFA,;		//Código da Tarefa na memória
		M->TL_ETAPA,;		//Código da Etapa memória
		M->TL_DTINICI,;		//Data Inicial na memória
		M->TL_HOINICI,;		//Hora Inicial na memória
		M->TL_DTFIM,;		//Data Final na memória
		M->TL_HOFIM}		//Hora Final na memória
	EndIf

	//Critica se houve alteração da data ou hora e o se apontamento foi realizado pelo apontamento de MDO - MNTA422
	If nOperacao <> 1 	.And. aDadosOS[nLineOS,4,n,nPos01] == "M" ;
	.And. !NGVLDSTL2(aVetSTL)
		Return .f.
	EndIf

	//Validação do campo quantidade vazio
	If Empty(aCols[n,nPos10])
		//Nao validar se datainicio+horainicio e datafim+horafim são iguais (quando a inclusão foi realizada pelo apontamento de MDO - MNTA422)
		If .Not. (nOperacao <> 1 .And. aDadosOS[nLineOS,4,n,nPos01] == "M" ;
		.And. DtoS(aVetSTL[5]) + aVetSTL[6] == DtoS(aVetSTL[7]) + aVetSTL[8]; //verifica se DtInicio+Hrinicio e DataFim+HrFim são iguais
		.And. DtoS(aVetSTL[5]) + aVetSTL[6] == DtoS(aVetSTL[12]) + aVetSTL[13]; //Verifica se DtInicio+HrInicio getDados são iguais a DtInicio+HrInicio do banco
		.And. DtoS(aVetSTL[7]) + aVetSTL[8] == DtoS(aVetSTL[14]) + aVetSTL[15] )  // //Verifica se DtFim+HrFim getDados são iguais a DtFim+HrFim do banco

			MsgInfo(STR0122,STR0037) //"O campo Quantidade é obrigatório."###"ATENÇÃO"
			Return .F.
		EndIf
	EndIf

	If M->TL_TIPOREG == "P"

		If Empty(M->TL_DESTINO)
			Help("",1,"DESTINO")
			Return .F.
		EndIf

		cUNPROD := NGSEEK("SB1",M->TL_CODIGO,1,"B1_UM")
		If Alltrim(cUNPROD) <> Alltrim(M->TL_UNIDADE)
			Help("",1,"UNIDADE")
			Return .F.
		EndIf

		// QUANDO INTEGRADO COM O MÓDULO DE ESTOQUE.
		If cUsaInt3  == "S"

			//Verifica se o produto tem no almoxarifado
			If !NGPROALM(M->TL_CODIGO,M->TL_LOCAL)
				Return .F.
			EndIf

			//Verifica data de fechamento do estoque
			//1-Incluir, 2-Alterar ou 3-Visualizar
			If ( nOperacao == 1 .Or. nOperacao == 2 ) .And. lVerDt .And. !NGCHKMESFE(M->TL_DTINICI,M->TL_TIPOREG) 
				Return .F.
			EndIf

			// VALIDA SE O PRODUTO NO LOCAL INFORMADO ENCONTRA-SE EM PROCESSO DE INVENTÁRIO.
			If BlqInvent( M->TL_CODIGO, M->TL_LOCAL )

				Help( '', 1, 'BLQINVENT' )
				Return .F.

			EndIf

		EndIf
	Else
		If M->TL_TIPOREG == "M"

			If !NGFUNCRH(M->TL_CODIGO,.T.,M->TL_DTFIM)
				Return .F.
			EndIf

			//Verifica data de fechamento do estoque
			If nOperacao == 1 .Or. nOperacao == 2 //1-Incluir, 2-Alterar ou 3-Visualizar

				If lVerDt .And. !NGCHKMESFE(M->TL_DTINICI,M->TL_TIPOREG)
					Return .F.
				EndIf

				//Se possuir o PE e integração ao estoque deverá validar
				If lMNTA435O .And. cUsaInt3 == 'S'

					//Se o P.E. retornar .F. e se a chave atual nao esteja relacionada como bloqueio.
					//não deverá realizar a baixa no estoque, sendo assim deverá ser adicionada no aNBaixaEst
					If !ExecBlock("MNTA435O",.F.,.F.,{ aCols[n], aHoBrw2 }) .And. ;
							MNT435CANB(cOrdemTJ + cPlanoTJ + aCols[n,nPos18] + aCols[n,nPos16] + aCols[n,nPos01] + aCols[n,nPos03])
						aAdd(aNBaixaEst,{cOrdemTJ,; 		 //TL_ORDEM
						cPlanoTJ,;			 //TL_PLANO
						aCols[n,nPos18] ,;	 //TL_SEQRELA
						aCols[n,nPos16] ,;	 //TL_TAREFA
						aCols[n,nPos01] ,;	 //TL_TIPOREG
						aCols[n,nPos03] })	 //TL_CODIGO
					EndIf
				EndIf
			EndIf
		EndIf
		If !Empty( M->TL_UNIDADE ) .And. !( Alltrim(M->TL_UNIDADE) $ "MHDS" )
			Help("",1,"UNIDADE")
			Return .F.
		EndIf

		//Validação para que não permita que seja 'gatilhado' Hora Fim superior à Hora atual
		dbSelectArea('SD1')
		dbSetOrder(1)
		If dDataBase == aCols[ nPosTL , nPos08 ] .And. !Empty(M->TL_HOFIM) .And. !Empty(aCols[ nPosTL , nPos07 ]) .And. ;
		 HTOM(aCols[ nPosTL , nPos09 ]) > HTOM(Substr(Time(),1,5)) .And. !dbSeek( xFilial('SD1') + aCols[ n, nPos27 ] + ;
		 aCols[ n, nPos28 ] + aCols[ n, nPos29 ] + aCols[ n, nPos30 ] + IIF( aCols[ n, nPos01 ] == 'T', ;
		 NGProdMNT('T')[1], aCols[ n, nPos03 ] ) )
			MsgStop(STR0352) //"Hora fim não pode ser maior que a hora atual."
			Return .F.
		EndIf
	EndIf

	If nOperacao == 1 .Or. nOperacao == 2 //1-Incluir, 2-Alterar ou 3-Visualizar
		If M->TL_TIPOREG $ "M/F"
			lPROPLSTL := !f435VlFun(M->TL_CODIGO,cOrdemTJ,cPlanoTJ,M->TL_DTINICI,M->TL_HOINICI,M->TL_DTFIM,M->TL_HOFIM,nLineOS,n,M->TL_TIPOREG,.T.)
			If lPROPLSTL
				Return .F.
			EndIf
		EndIf
	EndIf

	// Verifica se o estoque(SB2) podera ficar negativo
	dbSelectArea("STL")
	If M->TL_TIPOREG == "P"  .And. (nOperacao == 1 .Or. nOperacao == 2) //1-Incluir, 2-Alterar ou 3-Visualizar

		If !NG435VLIM()
			Return .F.
		EndIf

		If cUsaInt3  == "S"

			If cUIntHis == 'N' .And. Alltrim(NGSEEK( "STJ", cOrdemTJ + cPlanoTJ, 1, "TJ_SERVICO")) == 'HISTOR'
				lBaixaEst := .F.
			EndIf
			// Ponto de Entrada destinado ao possivel bloqueio da baixa do estoque
			If ExistBlock("MNTA4356")
				lBaixaEst := ExecBlock("MNTA4356",.F.,.F.)
			EndIf

			If lBaixaEst
				If !lESTNEGA
					dbSelectArea("SB2")
					dbSetOrder(1)
					If !dbSeek(xFilial("SB2") + M->TL_CODIGO + M->TL_LOCAL)
						MsgInfo(STR0127+M->TL_CODIGO+STR0128+M->TL_LOCAL,STR0037) //"Produto "###" não cadastrado no almoxarifado "###"ATENÇÃO"
						dbSelectArea(cOLDALI)
						Return .F.
					EndIf

					If !NGSALDOES(M->TL_CODIGO,M->TL_LOCAL,M->TL_QUANTID,.T.,nLineOS,1,,,,,M->TL_DTINICI)
						dbSelectArea(cOLDALI)
						Return .F.
					EndIf
					
					//Adiciona o Produto+Local na lista para checar o estoque na gravacao dos dados
					If aScan( aProd435 ,{|x| x[1]+x[2] == M->TL_CODIGO+M->TL_LOCAL }) == 0
						aAdd( aProd435 , { M->TL_CODIGO , M->TL_LOCAL , M->TL_DTINICI } )
					EndIf

				EndIf
				//Valida saldo(SB8) de controle de rastreabilidade por lote do produto
				If Rastro(M->TL_CODIGO)
					If Rastro(M->TL_CODIGO,"S")
						If !NGIFDBSEEK( "SD1" , M->TL_NUMSEQ , 4 , .F. )
							//Valida o sub-lote
							If Empty(M->TL_NUMLOTE)
								Help(" ",1,"NGATENCAO",,STR0129,3,1) //"Numero do sub-lote não informado"
								Return .F.
							Else
								
								If !NGSALDOES(M->TL_CODIGO,M->TL_LOCAL,M->TL_QUANTID,.T.,nLineOS,2,M->TL_LOTECTL,M->TL_NUMLOTE,nil,nil,M->TL_DTINICI)
									dbSelectArea(cOLDALI)
									Return .F.
								EndIf
								
								//Adiciona no Array para validar saldo de Sub-Lote
								If aScan( aSubL435 ,{|x| x[1]+x[2]+x[3]+x[4] == M->TL_CODIGO+M->TL_LOCAL+M->TL_LOTECTL+M->TL_NUMLOTE }) == 0
									aAdd( aSubL435 , { M->TL_CODIGO , M->TL_LOCAL , M->TL_LOTECTL , M->TL_NUMLOTE } )
								EndIf
							EndIf
						EndIf
					ElseIf Rastro( M->TL_CODIGO , "L" ) //Valida saldo(SB8) de controle de rastreabilidade por lote do produto
						If !NGIFDBSEEK( "SD1" , M->TL_NUMSEQ , 4 , .F. )
							//Valida o lote
							If Empty(M->TL_LOTECTL)
								Help(" ",1,"NGATENCAO",,STR0130,3,1) //"Numero do lote não informado"
								Return .F.
							Else
								
								If !NGSALDOES(M->TL_CODIGO,M->TL_LOCAL,M->TL_QUANTID,.T.,nLineOS,3,M->TL_LOTECTL,M->TL_NUMLOTE,nil,nil,M->TL_DTINICI)
									dbSelectArea(cOLDALI)
									Return .F.
								EndIf
								
								//Adiciona no Array para validar saldo de Lote
								If aScan( aLote435 ,{|x| x[1]+x[2]+x[3] == M->TL_CODIGO+M->TL_LOCAL+M->TL_LOTECTL }) == 0
									aAdd( aLote435 , { M->TL_CODIGO , M->TL_LOCAL , M->TL_LOTECTL } )
								EndIf

							EndIf

						EndIf
					EndIf

					//Validacao do LOCALIZACAO
					//Verifica se ha problema na habilitacao do controle por enderecamento fisico
					If !Empty(M->TL_LOCALIZ) .Or. !Empty(M->TL_NUMSERI)
						If !LOCALIZA( Padr( M->TL_CODIGO, TAMSX3("B1_COD")[1] ) ) //LOCALIZA(Trim(M->TL_CODIGO))
							MsgInfo(STR0131+chr(13)+STR0132,; //"O parâmetro MV_LOCALIZ esta desativado ou o campo"###" B1_LOCALIZ do produto esta preenchido com N."
							STR0133) //"NAO CONFORMIDADE"
							Return .F.
						EndIf
					EndIf

				Else
					// Se não existir rastreabilidade e existir endereçamento para o campo.
					If Rastro( M->TL_CODIGO , "N" ) .And. RetFldProd(SB1->B1_COD,"B1_LOCALIZ") == "S"
						If Empty( M->TL_NUMSEQ )
							If Empty(M->TL_LOCALIZ) .And. Empty(M->TL_NUMSERI)
								Help(" ",1,"LOCALIZOBR")
								Return .F.
							ElseIf Empty(M->TL_LOCALIZ)
								Help(" ",1,"LOCALIZOBR")
								Return .F.
							EndIf
						EndIf
					EndIf
				EndIf
			Else
				// Caso a chave atual nao esteja relacionada como bloqueio. Adiciona a mesma ao array correspondente.
				If MNT435CANB(cOrdemTJ + cPlanoTJ + aCols[n,nPos18] + aCols[n,nPos16] + aCols[n,nPos01] + aCols[n,nPos03])
					aAdd(aNBaixaEst,{cOrdemTJ,; 		 //TL_ORDEM
					cPlanoTJ,;			 //TL_PLANO
					aCols[n,nPos18] ,;	 //TL_SEQRELA
					aCols[n,nPos16] ,;	 //TL_TAREFA
					aCols[n,nPos01] ,;	 //TL_TIPOREG
					aCols[n,nPos03] })	 //TL_CODIGO
				EndIf
			EndIf

			If LOCALIZA( Padr( M->TL_CODIGO, TAMSX3("B1_COD")[1] ) ) .And. !lESTNEGA //LOCALIZA(M->TL_CODIGO)
				//Valida a obrigatoriedade de informar o enderecamento fisico se o produto tem o controle
				dbSelectArea( "SD1" ) //Itens das NF de Entrada.
				dbSetOrder( 09 ) //D1_FILIAL+D1_ORDEM+D1_COD
				If !dbSeek( xFilial( "SD1" )+ cOrdemTJ + M->TL_CODIGO ) //Se não vier do documento de Entrada - (Compras)
					If Empty(M->TL_LOCALIZ) .And. Empty(M->TL_NUMSERI)
						Help(" ",1,"LOCALIZOBR")
						Return .F.
					ElseIf Empty(M->TL_LOCALIZ)
						Help(" ",1,"LOCALIZOBR")
						Return .F.
					EndIf
				EndIf

				If !Empty(M->TL_LOCALIZ)
					If !EXISTCPO("SBE",M->TL_LOCAL+M->TL_LOCALIZ)
						Return .F.
					EndIf
				EndIf
				//Verifica a obrigatoriedade da quantidade do insumo quando informado a serie
				If !MtAvlNSer(M->TL_CODIGO,M->TL_NUMSERI,M->TL_QUANTID)
					Return .F.
				EndIf
				If !Empty(M->TL_LOCALIZ) .Or. !Empty(M->TL_NUMSERI)

					If !NGSALDOES(M->TL_CODIGO,M->TL_LOCAL,M->TL_QUANTID,.T.,nLineOS,4,M->TL_LOTECTL,M->TL_NUMLOTE,M->TL_LOCALIZ,M->TL_NUMSERI)
						dbSelectArea(cOLDALI)
						Return .F.
					EndIf
	
					//Adiciona no Array para validar saldo de Enderecamento
					If aScan( aEnde435 ,{|x| x[1]+x[2]+x[3]+x[4]+x[5]+x[6] == M->TL_CODIGO+M->TL_LOCAL+;
					M->TL_LOCALIZ+M->TL_NUMSERI+M->TL_LOTECTL+M->TL_NUMLOTE }) == 0
						aAdd( aEnde435 , { M->TL_CODIGO , M->TL_LOCAL , M->TL_LOCALIZ , M->TL_NUMSERI , M->TL_LOTECTL , M->TL_NUMLOTE } )
					EndIf
					
				EndIf
			EndIf
		EndIf
	EndIf

	If nOperacao == 2
		If lAltGara
			fNgGar435("A")
		EndIf
	EndIf

	If M->TL_GARANTI == "S" .And. nOperacao <> 5
		fChkGaran()
	EndIf

	If M->TL_TIPOREG == "M"
		//Ao executar a mensagem unica é zerado o aCols e a memoria da STL
		aColsSave := aCols

		//Verifica se a mao de obra possui afastamentos no RH
		If !NGFRHAFAST(M->TL_CODIGO,M->TL_DTINICI,M->TL_DTFIM,.T.) .And. (nOperacao == 1 .Or. nOperacao == 2) //1-Incluir, 2-Alterar ou 3-Visualizar
			Return .F.
		EndIf

		//Atualiza saldo e custo do produto relacionado a mão de obra
		If lIntRM

			cProdMDO := MntGetPrdM( M->TL_CODIGO )
			cLocPad  := SuperGetMV( 'MV_NGLOCPA', .F., '01' )
			NGMUStoLvl( cProdMDO, cLocPad, .T., 'M', M->TL_CODIGO )

		EndIf

		aCols := aColsSave

	EndIf

	If nPos21 == 0
		M->TL_CUSTO := Round( NGCALCUSTI( aCols[ nPosTL , nPos03 ] ,aCols[ nPosTL , nPos01 ], aCols[ nPosTL , nPos10 ] , aCols[ nPosTL , nPos05 ] , , , , aCols[ nPosTL ,  nPos22 ], "1" ) , 2 )//Atribui o custo ja tratado, passando sempre ele como 'realizado'
	Else
		If lIntRM .And. ( dDTULMES < aCols[ nPosTL , nPos06 ] ) 
			aCols[ nPosTL , nPos21 ] := Round( NGCALCUSTI( aCols[ nPosTL , nPos03 ], aCols[ nPosTL , nPos01 ], aCols[ nPosTL , nPos10 ] , aCols[ nPosTL , nPos05 ] , , , , aCols[ nPosTL ,  nPos22 ], "1" ) , 2 )//Atribui o custo ja tratado, passando sempre ele como 'realizado'
		EndIf
		M->TL_CUSTO   := aCols[ nPosTL , nPos21 ]
	EndIf

	/*Ponto de entrada que realiza automaticamente alterações junto aos campos Data/Hora da STL (após o processo de validações).*/
	If ExistBlock( "MNTA435D" )
		ExecBLock( "MNTA435D",.F.,.F.,{ @aCols,aHeader } )
	EndIf
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fChkGaran ³ Autor ³ Denis                 ³ Data ³17/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Checa a garantia                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fChkGaran()

	dbSelectArea("STJ")
	dbSetOrder(1)
	dbSeek( xFilial("STJ") + cOrdemTJ + cPlanoTJ )

	cOrdem := aOS[oOS:nAt,nPosOS]
	cPlano := aOS[oOS:nAt,nPosPL]
	MNT400CHKGAR()



Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fNgGar435 ³ Autor ³ Denis                 ³ Data ³17/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Inclusao de garantia para insumo diferente de produto chama³±±
±±³          ³ da a partir do campo garantia                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fNgGar435(cUsa,lValPrev,cGarAnt,strDescIns,strSeqrel,dtTmpIni,dtTmpFim)
	Local nOPGA2 := 0
	Local nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPos02 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_GARANTI"})
	Local nDTI   := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI" })
	Local nDTF   := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM" })
	Local nPos03 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPos18 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
	Local lGrava := .T.
	Local cTitGaran := STR0143 //"Garantia"
	Local cTmpLocal 	:= "" // Usado no ponto de entrada MNTA435A
	Local nTmpQnt	 	:= 0  // Usado no ponto de entrada MNTA435A
	Local cTmpUni		:= "" // Usado no ponto de entrada MNTA435A

	Private nQtde  := 0, nQtdeC := 0
	Private cUni   := " ",cCont := " "
	Default lValPrev := .F.

	lTemCG1 := If(NGSEEK("ST9",cCdBemTJ,1,"T9_TEMCONT") <> "N",.T.,.F.)
	lTemCG2 := If(NGIFDBSEEK("TPE",cCdBemTJ,1,.F.),.T.,.F.)

	aUni     := {" ",STR0144,STR0145,STR0146} //"Dia"###"Semana"###"Mes"
	aCont    := {" ",STR0147,STR0148} //"Contador 1"###"Contador 2"
	cLocaliz := Space(Len(TPS->TPS_CODLOC))
	cNomLoc  := Space(20)

	If lValPrev
		dbSelectArea("TPY")
		dbSetOrder(1)
		If dbSeek(xFilial("TPY")+cCdBemTJ+M->TL_CODIGO)
			cLocaliz := If(Empty(TPY->TPY_LOCGAR),Space(Len(TPS->TPS_CODLOC)),TPY->TPY_LOCGAR)
			M->TL_GARANTI := "S"
			nQtde  := TPY->TPY_QTDGAR
			nQtdeC := If(Empty(TPY->TPY_QTDCON),0,TPY->TPY_QTDCON)

			cUni1  := TPY->TPY_UNIGAR
			If cUni1 == "D"
				cUni := aUni[2]
			ElseIf cUni1 == "S"
				cUni := aUni[3]
			Else
				cUni := aUni[4]
			EndIf
			If !Empty(TPY->TPY_CONGAR)
				If TPY->TPY_CONGAR == "1"
					cCont := aCont[2]
				Else
					cCont := aCont[1]
				EndIf
			EndIf
			If Empty(TPY->TPY_CONGAR) .And. Empty(TPY->TPY_UNIGAR)
				lGrava := .F.
			EndIf
		Else
			lGrava := .F.
		EndIf
		cTitGaran += STR0149 + strDescIns //" - Produto: "
	EndIf

	If M->TL_GARANTI == "S" .And. lGrava

		If aCols[n][nPos01] == "P" .And. ExistBlock("MNTA435A") // Verifica se p insumo e produto e se existe o ponto de entrada
			cTmpLocal	:= ExecBlock("MNTA435A",.F.,.F.,{"L"}) // Retorna o codigo da localizacao
			nTmpQnt	:= ExecBlock("MNTA435A",.F.,.F.,{"Q"}) // Retorna a quantidade - Garantia por Tempo
			cTmpUni	:= ExecBlock("MNTA435A",.F.,.F.,{"U"}) // Retorna a unidade de tempo
			If ValType(cTmpLocal) == "C" // Verifica se o retorno do ponto de entrada e caracter
				If NGLOCGAR(cTmpLocal) // Se existir a localização
					cLocaliz	:= cTmpLocal // Preenche com o codigo retornado pelo ponto de entrada
					cNomLoc	:= NGSeek('TPS',cLocaliz,1,'TPS_NOME') // Preenche com a descricao da localizacao
				EndIf
			EndIf
			If ValType(nTmpQnt) == "N" // Verifica se o retorno do ponto de entrada e numerico
				nQtde := nTmpQnt // Preenche com a quantidade retornada pelo ponto de entrada
			EndIf

			If Valtype(cTmpUni) == "C" // Verifica se o retorno do ponto de entrada e caracter
				cUni	:= cTmpUni // Preenche com a unidade retornada pelo ponto de entrada
			EndIf
		EndIf

			Define Msdialog oDlgTZ From  000,000 To 280,550 Title cTitGaran Pixel

				oPanelGar := TPanel():New(0,0,,oDlgTZ,,,,,,10,10,.F.,.F.)
				oPanelGar:Align := CONTROL_ALIGN_ALLCLIENT

					@ 0.5,.5 To 2.5,34 LABEL STR0153 OF oPanelGar //"Localização"
					@ 20,008 Say Oemtoansi(STR0150) Size 47,07 Of oPanelGar Pixel //"Local"
					@ 20,040 MsGet cLocaliz Size 38,08 Of oPanelGar Pixel Picture "@!" F3 "TPS" Valid NGLOCGAR(cLocaliz) HASBUTTON
					@ 20,100 MsGet oNomLoc Var cNomLoc Of oPanelGar Pixel Picture "@!" When .F. Size 90,08

					@ 3.0,.5 To 5.0,34 LABEL STR0154 OF oPanelGar //"Garantia por Tempo"
					@ 55,008 Say Oemtoansi(STR0151) Size 47,07 Of oPanelGar Pixel //"Qde"
					@ 55,040 MsGet nQtde Size 38,08 Of oPanelGar Pixel Valid Positivo(nQtde) Picture "@E 999,999,999" HASBUTTON
					@ 55,100 Say Oemtoansi(STR0096) Size 47,07 Of oPanelGar Pixel //"Unidade"
					@ 55,132 Combobox cUni Items aUni Size 40,12 OF oPanelGar Pixel Valid NG400CON(cUni,cCont,1,nQtde)

					@ 5.5,.5 To 7.5,34 LABEL STR0155 OF oPanelGar //"Garantia por Contador"
					@ 90,008 Say Oemtoansi(STR0151) Size 47,07 Of oPanelGar Pixel //"Qde"
					@ 90,040 MsGet nQtdeC Size 38,08 Of oPanelGar Pixel Valid positivo(nQtdeC) Picture "@E 999,999,999" When lTemCG1 .Or. lTemCG2  HASBUTTON
					@ 90,100 Say OemtoAnSi(STR0152) Size 47,07 Of oPanelGar Pixel //"Tp Contador"
					@ 90,132 Combobox cCont Items aCont Size 40,12 Of oPanelGar Pixel Valid NG400CON(cUni,cCont,2,nQtdeC) When lTemCG1 .Or. lTemCG2

			Activate MsDialog oDlgTZ On Init EnchoiceBar(oDlgTZ,{||nOPGA2 := 2,If(!MNT400GF(lTemCG1,lTemCG2),nOPGA2 := 1,oDlgTZ:End())},{||oDlgTZ:End()}) CENTERED

		If lValPrev
			If nOPGA2 == 2 .And. ( !Empty(cUni) .Or. !Empty(cCont) )
				fNgGarGrava(cLocaliz,nQtde,cUni,cCont,nQtdeC, "P" , M->TL_CODIGO, strSeqrel, dtTmpIni, dtTmpFim)
			Else
				M->TL_GARANTI := cGarAnt
			EndIf
		Else
			If nOPGA2 == 2 .And. ( !Empty(cUni) .Or. !Empty(cCont) )
				fNgGarGrava(cLocaliz,nQtde,cUni,cCont,nQtdeC, aCols[n][nPos01], aCols[n][nPos03], aCols[n][nPos18], aCols[n][nDTI], aCols[n][nDTF])
			Else
				M->TL_GARANTI := aCols[n][nPos02]
			EndIf
		EndIf
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fNgGarGrava³ Autor ³Denis Hyroshi de Souza³Data ³17/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Grava a garantia na tabela TPZ                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fNgGarGrava(cLocaliz,nQtde,cUni1,cCont,nQtdeC,cTmpTreg,cTmpCodigo,cTmpSeqrel,dTmpIdt,dTmpFdt)
	Local cSeq_Rel := If(Empty(cTmpSeqrel),"1",cTmpSeqrel)
	Local dDtiniga := If(Empty(dTmpFdt),dTmpIdt,dTmpFdt)
	Local nLineSA

	If cUni1 == STR0144 //"Dia"
		cUni := "D"
	ElseIf cUni1 == STR0145 //"Semana"
		cUni := "S"
	ElseIf cUni1 == STR0146 //"Mes"
		cUni := "M"
	Else
		cUni := " "
	EndIf

	cTmpCG := " "
	If cCont=STR0147 //"Contador 1"
		cTmpCG := "1"
	ElseIf cCont=STR0148 //"Contador 2"
		cTmpCG := "2"
	EndIf

	nLineSA := aScan(aDadosTPZ, {|x| x[2]+x[3]+x[4]+x[5]+x[6] == cTmpTreg+cTmpCodigo+cLocaliz+cOrdemTJ+cPlanoTJ })
	If nLineSA > 0
		If dDtiniga >= aDadosTPZ[nLineSA,10]
			aDadosTPZ[nLineSA,07] := cSeq_Rel
			aDadosTPZ[nLineSA,08] := nQtde
			aDadosTPZ[nLineSA,09] := cuni
			aDadosTPZ[nLineSA,10] := dDtiniga
			aDadosTPZ[nLineSA,11] := cTmpCG
			aDadosTPZ[nLineSA,12] := nQtdeC
		EndIf
	Else
		nLineSA := aScan(aDadosTPZ, {|x| x[2]+x[3]+x[5]+x[6] == cTmpTreg+cTmpCodigo+cOrdemTJ+cPlanoTJ .And. x[7] == cSeq_Rel })
		If nLineSA > 0
			aDadosTPZ[nLineSA,04] := cLocaliz
			aDadosTPZ[nLineSA,08] := nQtde
			aDadosTPZ[nLineSA,09] := cuni
			aDadosTPZ[nLineSA,10] := dDtiniga
			aDadosTPZ[nLineSA,11] := cTmpCG
			aDadosTPZ[nLineSA,12] := nQtdeC
		Else
			aAdd(aDadosTPZ, {;
			cCdBemTJ,; 													//01. TPZ_CODBEM
			cTmpTreg,;		 											//02. TPZ->TPZ_TIPORE
			cTmpCodigo,;	 											//03. TPZ->TPZ_CODIGO
			cLocaliz,; 													//04. TPZ->TPZ_LOCGAR
			cOrdemTJ,; 													//05. TPZ->TPZ_ORDEM
			cPlanoTJ,; 													//06. TPZ->TPZ_PLANO
			cSeq_Rel,;		   											//07. TPZ->TPZ_SEQREL
			nQtde,; 													//08. TPZ->TPZ_QTDGAR
			cuni,; 														//09. TPZ->TPZ_UNIGAR
			dDtiniga,;							 						//10. TPZ->TPZ_DTGARA
			cTmpCG,; 													//11. TPZ->TPZ_CONGAR
			nQtdeC; 													//12. TPZ->TPZ_QTDCON
			})
		EndIf
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fNgGarDelete| Autor ³ Denis               ³ Data ³17/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Deleta a garantia se nao confirmada a inclusao do insumo   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fNgGarDelete(cOrdem,cPlano,cTL_SEQRELA)

	dbSelectArea("TPZ")
	dbSetOrder(2)
	If dbSeek(xFilial("TPZ")+cOrdem+cPlano+cTL_SEQRELA)
		While !EoF() .And. TPZ->(TPZ_FILIAL+TPZ_ORDEM+TPZ_PLANO+TPZ_SEQREL) == xFilial("TPZ")+cOrdem+cPlano+cTL_SEQRELA
			RecLock("TPZ",.F.)
			DbDelete()
			TPZ->(MsUnLock())
			TPZ->(dbSkip())
		End
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fNgGarUpdate| Autor ³ Denis               ³ Data ³17/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Altera a data da garantia                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fNgGarUpdate(cOrdem,cPlano,cTL_SEQRELA,dTL_DTINICI)

	dbSelectArea("TPZ")
	dbSetOrder(2)
	If dbSeek(xFilial("TPZ")+cOrdem+cPlano+cTL_SEQRELA) .And. !Empty(dTL_DTINICI)
		While !EoF() .And. TPZ->(TPZ_FILIAL+TPZ_ORDEM+TPZ_PLANO+TPZ_SEQREL) == xFilial("TPZ")+cOrdem+cPlano+cTL_SEQRELA
			RecLock("TPZ",.F.)
			TPZ->TPZ_DTGARA := dTL_DTINICI
			TPZ->(MsUnLock())
			TPZ->(dbSkip())
		End
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fNgGarInsert| Autor ³ Denis               ³ Data ³17/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Cadastra garantia para o insumo                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fNgGarInsert(nLineSA,cOrdem,cPlano,cTL_SEQRELA,dTL_DTINICI)

	Local lGrava  := .T.
	Local nRecTPZ := 0

	If nLineSA == 0
		Return
	EndIf

	dbSelectArea("TPZ")
	dbSetOrder(1)
	lAchou := dbSeek(xFilial("TPZ")+aDadosTPZ[nLineSA,1]+aDadosTPZ[nLineSA,2]+aDadosTPZ[nLineSA,3]+aDadosTPZ[nLineSA,4]+;
	aDadosTPZ[nLineSA,5]+aDadosTPZ[nLineSA,6])
	If lAchou
		If dTL_DTINICI < TPZ->TPZ_DTGARA
			lGrava := .F.
			nRecTPZ := TPZ->(Recno())
		EndIf
	EndIf
	If lGrava
		RecLock("TPZ",!lAchou)
		If !lAchou
			TPZ->TPZ_FILIAL := xFilial("TPZ")
			TPZ->TPZ_CODBEM := aDadosTPZ[nLineSA,1]
			TPZ->TPZ_TIPORE := aDadosTPZ[nLineSA,2]
			TPZ->TPZ_CODIGO := aDadosTPZ[nLineSA,3]
			TPZ->TPZ_LOCGAR := aDadosTPZ[nLineSA,4]
			TPZ->TPZ_ORDEM  := aDadosTPZ[nLineSA,5]
			TPZ->TPZ_PLANO  := aDadosTPZ[nLineSA,6]
		EndIf
		TPZ->TPZ_SEQREL := aDadosTPZ[nLineSA,7]
		TPZ->TPZ_QTDGAR := aDadosTPZ[nLineSA,8]
		TPZ->TPZ_UNIGAR := aDadosTPZ[nLineSA,9]
		TPZ->TPZ_DTGARA := dTL_DTINICI //aDadosTPZ[nLineSA,10]
		TPZ->TPZ_CONGAR := aDadosTPZ[nLineSA,11]
		TPZ->TPZ_QTDCON := aDadosTPZ[nLineSA,12]
		TPZ->(MsUnLock())
		nRecTPZ := TPZ->(Recno())
	EndIf

	dbSelectArea("TPZ")
	dbSetOrder(2)
	If dbSeek(xFilial("TPZ")+cOrdem+cPlano+cTL_SEQRELA)
		While !EoF() .And. TPZ->(TPZ_FILIAL+TPZ_ORDEM+TPZ_PLANO+TPZ_SEQREL) == xFilial("TPZ")+cOrdem+cPlano+cTL_SEQRELA
			If TPZ->(Recno()) <> nRecTPZ
				RecLock("TPZ",.F.)
				dbDelete()
				TPZ->(MsUnLock())
			EndIf
			TPZ->(dbSkip())
		End
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuno    ³TudOk435PLºAutor  ³ Denis Hyroshi Souzaº Data ³  03/10/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Testa os intervalos aceitaveis de datas e hora para a in-   º±±
±±º          ³clusao de motivos de atraso da O.S                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³MNTA435( )                                                  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function TudOk435PL(nPosTPL)
	Local vx

	For vx := 1 To Len(aCols)
		If !LinOk435PL(vx)
			nPosTPL := vx
			Return .F.
		EndIf
	Next vx

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} LinOk435PL
Testa os intervalos aceitaveis de datas e hora para a inclusao de
motivos de atraso da O.S
@author  Denis Hyroshi Souza
@since   03/10/08
@version P12
@use mnta435
/*/
//-------------------------------------------------------------------
Function LinOk435PL(nLinTPL)

    Local nXZ
	Local aVRET     := {}
	Local cMENS     := Space(1)
	Local cMENA     := STR0158 //"nao informada"
    Local cHrIniOs  := STJ->TJ_HORACO1
    Local dDtIniOs  := STJ->TJ_DTORIGI
    Local cOrdem    := STJ->TJ_ORDEM

	Local nPos01 := aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_CODMOT"})
	Local nPos02 := aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_DTINIC"})
	Local nPos03 := aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_HOINIC"})
	Local nPos04 := aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_DTFIM" })
	Local nPos05 := aScan(aHoBrw4,{|x| Trim(Upper(x[2])) == "TPL_HOFIM" })
	Local cMOTIVO, dVDTINI, cVHINI, dVDTFIM, cVHFIM

	Local nRowTPL := n

	If ValType(nLinTPL) == "N"
		nRowTPL := nLinTPL
	EndIf

	cMOTIVO := aCols[nRowTPL,nPos01]
	dVDTINI := aCols[nRowTPL,nPos02]
	cVHINI  := aCols[nRowTPL,nPos03]
	dVDTFIM := aCols[nRowTPL,nPos04]
	cVHFIM  := aCols[nRowTPL,nPos05]

	If aCols[nRowTPL,Len(aCols[nRowTPL])] .Or. Empty(aCols[nRowTPL,nPos01]) //Nao validar se deletado ou codigo vazio
		Return .T.
	EndIf

	If Empty(cMENS) .And. Empty(cMOTIVO)
		cMENS := STR0159+cMENA //"Motivo "
	EndIf

	If Empty(cMENS) .And. Empty(dVDTINI)
		cMENS := STR0160+cMENA //"Data Inicio "
	EndIf

	If Empty(cMENS) .And. (Empty(cVHINI) .Or. AllTrim(cVHIni) == ":")
		cMENS := STR0161+cMENA //"Hora inicio "
	EndIf

	If Empty(dVDTFim) .And. AllTrim(cVHFim) <> ":"  .And. Empty(cMens)
		cMens := STR0162 + cMena //"Data Fim"
	EndIf

	If !Empty(dVDTFim) .And. Empty(cVHFim) .And. Empty(cMens)
		cMens := STR0163 + cMena //"Hora Fim"
	EndIf

    If Empty(cMens) .And. dVDTIni < dDtIniOs
        If cVHIni < cHrIniOs
            cMens := STR0363 + cOrdem
        EndIf
        cMens := STR0364 + cOrdem
    EndIf

	If Empty(cMENS) .And. !Empty(dVDTINI) .And. !Empty(dVDTFIM)
		If dVDTFIM < dVDTINI
			cMENS := STR0240  //"Data Inicio devera ser menor ou igual a Data Fim "
		ElseIf dVDTFIM = dVDTINI .And. cVHFIM <= cVHINI
			cMENS := STR0165 //"Hora fim devera ser maior que a hora inicio "
		EndIf
	EndIf

	If Empty(cMENS) .And. !Empty(dVDTINI) .And. !Empty(dVDTFIM)
		If dVDTFIM == dDataBase .And. cVHFIM > SubStr(Time(),1,5)
			cMENS := STR0243
		EndIf
	EndIf

	If !Empty(dVDTFim) .And. !Empty(cVHFim)

		If dVDTFim > dDataBase
			Help(" ", 1, "NGATENCAO",, STR0244, 3, 1)	//"A Data Fim é maior que a Data Atual."
			Return .F.
		EndIf

		If dVDTFim < dVDTINI
			Help(" ", 1, "NGATENCAO",, STR0156 + Chr(13) + Chr(10) + STR0157, 3, 1)	//"A Data Fim não pode ser menor"###" do que a Data Início."
			Return .F.
		EndIf

	EndIf

	If !Empty(cMENS)
		aVRET := {.F.,cMENS}
	Else
		aVRET := {.T.,STR0166} //"Data e hora de avaliacao estao fora do Intervalo"
		For nXZ := 1 To Len(aCols)
			If nXZ == nRowTPL .Or. aCols[nXZ,Len(aCols[nXZ])]
				Loop
			EndIf
			If aCols[nXZ,nPos01] == cMOTIVO .And. aCols[nXZ,nPos02] == dVDTINI .And. ;
			aCols[nXZ,nPos03] == cVHINI .And. aCols[nXZ,nPos04] == dVDTFIM .And. ;
			aCols[nXZ,nPos05] == cVHFIM

				aVRET := {.F.,STR0167} //"Registro informado ja existe"
				Exit
			Else
				If aCols[nXZ,nPos01] == cMOTIVO
					If DtoS(dVDTINI)+cVHINI <= DtoS(aCols[nXZ,nPos04])+aCols[nXZ,nPos05] .And.;
					DtoS(dVDTFIM)+cVHFIM >= DtoS(aCols[nXZ,nPos02])+aCols[nXZ,nPos03]

						aVRET := {.F.,STR0168} //"Ja existe registro dentro do periodo informado"
						Exit
					EndIf
				EndIf
			EndIf
		Next nXZ

	EndIf

	If !aVRET[1]
		MsgInfo(aVRET[2],STR0133) //"NAO CONFORMIDADE"
		Return .F.
	Else
		Return .T.
	EndIf

Return aVRET

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fValidOK   ³ Autor ³ Denis               ³ Data ³17/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Valida confirmacao da tela                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fValidOK(lRetTela,lSetFocBt,oChv435)

	Local nXX, nYY, nZZZ, nEE
	Local lRet := .T.
	Local nPosTip := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPosCod := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPosLoc := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"  })
	Local nPosQtd := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANTID"})
	Local nPos02  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI"})
	Local nPos03  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOINICI"})
	Local nPos04  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM" })
	Local nPos05  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOFIM" })
	Local nPosSub := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMLOTE"})
	Local nPosLot := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOTECTL"})
	Local nPosEnd := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCALIZ"})
	Local nPosNuS := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSERI"})
	Local cTmpCod,cTmpOrdem,cTmpPlano
	Local cPosAnt := ""
	Local aVRET  := {.F.," "}

	If lSetFocBt
		If !NGLostFocus()
			Return .F.
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Valida estoque dos produtos              ³
	//ÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//variavel nDiffoS representa, nesse ponto, a diferenca do que havia sido aplicado antes da alteracao
	//e o que está sendo aplicado após alteração
	nDiffOS := 0

	/*-------------------------------------------------------------------------------------------------+
	| Quando existir o param. MV_MNTREQ as validações de estoque são realizadas pelo ExecAuto MATA241. |
	+-------------------------------------------------------------------------------------------------*/
	If Len(aProd435) > 0 .And. !lESTNEGA .And. cUsaInt3  == "S" .And. !lHasMNTREQ

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Valida Saldo Lote                        ³
		//ÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lRet
			cChvPrAlm := "Nil"
			For nZZZ := 1 To Len(aLote435)
				nDiffOS := 0
				cChvPrAlm := aLote435[nZZZ,1] + aLote435[nZZZ,2] + aLote435[nZZZ,3]
				For nXX := 1 To Len(aDadosOS)
					If ValType(aDadosOS[nXX,4]) == "A" .And. ValType(aDadosOS[nXX,5]) == "A"
						For nYY := 1 To Len(aDadosOS[nXX,4])
							If aDadosOS[nXX,4,nYY,nPosTip] == "P"
								If aDadosOS[nXX,4,nYY,nPosCod]+aDadosOS[nXX,4,nYY,nPosLoc]+aDadosOS[nXX,4,nYY,nPosLot] == cChvPrAlm
									nDiffOS -= aDadosOS[nXX,4,nYY,nPosQtd]
								EndIf
							EndIf
						Next nYY
						For nYY := 1 To Len(aDadosOS[nXX,5])
							If aDadosOS[nXX,5,nYY,Len(aDadosOS[nXX,5,nYY])]
								Loop //Deletado
							EndIf
							If aDadosOS[nXX,5,nYY,nPosTip] == "P"
								If aDadosOS[nXX,5,nYY,nPosCod]+aDadosOS[nXX,5,nYY,nPosLoc]+aDadosOS[nXX,5,nYY,nPosLot] == cChvPrAlm
									nDiffOS += aDadosOS[nXX,5,nYY,nPosQtd]
									cPosAnt := aDadosOS[nXX,1]+aDadosOS[nXX,2]
								EndIf
							EndIf
						Next nYY
					EndIf
				Next nXX

				//Analisa se existe retiradas do estoque na tela e desconta do saldo atual.
				If nDiffOS > 0
					dbSelectArea("SB8")
					dbSetOrder(03)
					If dbSeek(xFilial("SB8")+cChvPrAlm)
						nSaldo:=SaldoLote(aLote435[nZZZ,1],aLote435[nZZZ,2],aLote435[nZZZ,3],NIL,.F.,.T.,NIL,dDataBase)
						If QtdComp(nSaldo) < QtdComp(nDiffOS)
							cHelp:=STR0127+AllTrim(aLote435[nZZZ,1])+chr(13)+STR0169+aLote435[nZZZ,2]+chr(13)+STR0170; //"Produto "###"Local "###"Saldo Disponível "
							+Alltrim(Transform(nSaldo,PesqPictQt("B8_SALDO", 14)))+chr(13)+STR0171+Alltrim(aLote435[nZZZ,3]) //"Lote "
							Help(" ",1,"A240LOTENE",,cHelp,4,1)
							lRet := .F.
						EndIf
					EndIf
				EndIf
				If !lRet
					Exit
				EndIf
			Next nZZZ
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Valida Saldo Sub-Lote                    ³
		//ÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lRet
			cChvPrAlm := "Nil"
			For nZZZ := 1 To Len(aSubL435)
				nDiffOS := 0
				cChvPrAlm := aSubL435[nZZZ,1] + aSubL435[nZZZ,2] + aSubL435[nZZZ,3] + aSubL435[nZZZ,4]
				For nXX := 1 To Len(aDadosOS)
					If ValType(aDadosOS[nXX,4]) == "A" .And. ValType(aDadosOS[nXX,5]) == "A"
						For nYY := 1 To Len(aDadosOS[nXX,4])
							If aDadosOS[nXX,4,nYY,nPosTip] == "P"
								If aDadosOS[nXX,4,nYY,nPosCod]+aDadosOS[nXX,4,nYY,nPosLoc]+aDadosOS[nXX,4,nYY,nPosLot]+aDadosOS[nXX,4,nYY,nPosSub] == cChvPrAlm
									nDiffOS -= aDadosOS[nXX,4,nYY,nPosQtd]
								EndIf
							EndIf
						Next nYY
						For nYY := 1 To Len(aDadosOS[nXX,5])
							If aDadosOS[nXX,5,nYY,Len(aDadosOS[nXX,5,nYY])]
								Loop //Deletado
							EndIf
							If aDadosOS[nXX,5,nYY,nPosTip] == "P"
								If aDadosOS[nXX,5,nYY,nPosCod]+aDadosOS[nXX,5,nYY,nPosLoc]+aDadosOS[nXX,5,nYY,nPosLot]+aDadosOS[nXX,5,nYY,nPosSub] == cChvPrAlm
									nDiffOS += aDadosOS[nXX,5,nYY,nPosQtd]
									cPosAnt := aDadosOS[nXX,1]+aDadosOS[nXX,2]
								EndIf
							EndIf
						Next nYY
					EndIf
				Next nXX

				//Analisa se existe retiradas do estoque na tela e desconta do saldo atual.
				If nDiffOS > 0
					dbSelectArea("SB8")
					dbSetOrder(02)
					If dbSeek(xFilial("SB8")+aSubL435[nZZZ,4]+aSubL435[nZZZ,3]+aSubL435[nZZZ,1]+aSubL435[nZZZ,2])
						nSaldoLote := SB8Saldo(.F.,.T.,NIL,NIL,NIL,NIL,NIL,dDataBase)
						If QtdComp(nSaldoLote) < QtdComp(nDiffOS)
							cHelp:=STR0127+AllTrim(aSubL435[nZZZ,1])+chr(13)+STR0169+aSubL435[nZZZ,2]+chr(13)+STR0170; //"Produto "###"Local "###"Saldo Disponível "
							+Alltrim(Transform(nSaldoLote,PesqPictQt("B8_SALDO", 14)))+chr(13)+STR0171+Alltrim(aSubL435[nZZZ,3]); //"Lote "
							+chr(13)+STR0172+Alltrim(aSubL435[nZZZ,4]) //"Sub-lote "
							Help(" ",1,"A240LOTENE",,cHelp,4,1)
							lRet := .F.
						EndIf
					EndIf
				EndIf
				If !lRet
					Exit
				EndIf
			Next nZZZ
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Valida Saldo Enderecamento               ³
		//ÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lRet
			cChvPrAlm := "Nil"
			For nZZZ := 1 To Len(aEnde435)
				nDiffOS := 0
				nEmpenho:= 0
				cChvPrAlm := aEnde435[nZZZ,1] + aEnde435[nZZZ,2] + aEnde435[nZZZ,3] + aEnde435[nZZZ,4] + aEnde435[nZZZ,5] + aEnde435[nZZZ,6]
				For nXX := 1 To Len(aDadosOS)
					If ValType(aDadosOS[nXX,3]) == "A" .And. ValType(aDadosOS[nXX,5]) == "A"
						For nEE := 1 To Len(aDadosOS[nXX,3])
							If aDadosOS[nXX,3,nEE,nPosTip] == "P"
								If aDadosOS[nXX,3,nEE,nPosCod] + aDadosOS[nXX,3,nEE,nPosLoc] == aEnde435[nZZZ,1] + aEnde435[nZZZ,2]
									nEmpenho += aDadosOS[nXX,3,nEE,nPosQtd]
									cOPEMP := aDadosOS[nXX,1]+"OS001"
									cOPCOD := aDadosOS[nXX,3,nEE,nPosCod]
								EndIf
							EndIf
						Next nEE
					EndIf
					If ValType(aDadosOS[nXX,4]) == "A" .And. ValType(aDadosOS[nXX,5]) == "A"
						For nYY := 1 To Len(aDadosOS[nXX,4])
							If aDadosOS[nXX,4,nYY,nPosTip] == "P"
								If aDadosOS[nXX,4,nYY,nPosCod]+aDadosOS[nXX,4,nYY,nPosLoc]+aDadosOS[nXX,4,nYY,nPosEnd]+;
								aDadosOS[nXX,4,nYY,nPosNuS]+aDadosOS[nXX,4,nYY,nPosLot]+aDadosOS[nXX,4,nYY,nPosSub] == cChvPrAlm

									nDiffOS -= aDadosOS[nXX,4,nYY,nPosQtd]
								EndIf
							EndIf
						Next nYY
						For nYY := 1 To Len(aDadosOS[nXX,5])
							If aDadosOS[nXX,5,nYY,Len(aDadosOS[nXX,5,nYY])]
								Loop //Deletado
							EndIf
							If aDadosOS[nXX,5,nYY,nPosTip] == "P"
								If aDadosOS[nXX,5,nYY,nPosCod]+aDadosOS[nXX,5,nYY,nPosLoc]+aDadosOS[nXX,5,nYY,nPosEnd]+;
								aDadosOS[nXX,5,nYY,nPosNuS]+aDadosOS[nXX,5,nYY,nPosLot]+aDadosOS[nXX,5,nYY,nPosSub] == cChvPrAlm

									nDiffOS += aDadosOS[nXX,5,nYY,nPosQtd]
									cPosAnt := aDadosOS[nXX,1]+aDadosOS[nXX,2]
								EndIf
							EndIf
						Next nYY
					EndIf
				Next nXX

				//Analisa se existe retiradas do estoque na tela e desconta do saldo atual.
				If nDiffOS > 0
					If QtdComp(SaldoSBF(aEnde435[nZZZ,2],aEnde435[nZZZ,3],aEnde435[nZZZ,1],aEnde435[nZZZ,4],aEnde435[nZZZ,5],;
					aEnde435[nZZZ,6],.F.)) + nEmpenho < QtdComp(nDiffOS)
						Help(" ",1,"SALDOLOCLZ")
						lRet := .F.
					EndIf
				EndIf
				If !lRet
					Exit
				EndIf
			Next nZZZ
		EndIf

	EndIf

	//Valida as etapas
	If lRet
		lRet := MNTA435EFI()
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Valida mao de obra alocada no mesmo horario
	//ÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRet
		For nXX := 1 To Len(aDadosOS)
			If aVRET[1]
				Exit
			EndIf
			If ValType(aDadosOS[nXX,5]) == "A" //Se [insumos realizados] foi editado pelo usuario
				For nYY := 1 To Len(aDadosOS[nXX,5])
					If aVRET[1]
						Exit
					EndIf
					If aDadosOS[nXX,5][nYY,Len(aDadosOS[nXX,5][nYY])]
						Loop //Deletado
					EndIf
					cTmpCod   := aDadosOS[nXX,5,nYY,nPosCod]
					cTmpOrdem := aDadosOS[nXX,1]
					cTmpPlano := aDadosOS[nXX,2]
					cTmpTipoR := aDadosOS[nXX,5,nYY,nPosTip]
					lPROPLSTL := f435VlFun(cTmpCod,cTmpOrdem,cTmpPlano,aDadosOS[nXX,5][nYY,nPos02],aDadosOS[nXX,5][nYY,nPos03],;
					aDadosOS[nXX,5][nYY,nPos04],aDadosOS[nXX,5][nYY,nPos05],nXX,nYY,cTmpTipoR,.F.)
					If !lPROPLSTL
						aVRET := {.T.,STR0167} //"Registro informado ja existe"
						cPosAnt := aDadosOS[nXX,1]+aDadosOS[nXX,2]
					EndIf
				Next nYY
			EndIf
		Next nXX
		If aVRET[1]
			lRet := .F.
			PutFileInEof("STL")
		EndIf
	EndIf

	//---------------------------------------------------------------
	//Realiza chamada do ponto de entrada para validações adicionais
	//---------------------------------------------------------------
	If lRet .And. lPEMNTA435
		lRet := ExecBlock( "MNTA435N", .F., .F., { "VALID_CONFIRM", aDadosOS } )
	EndIF

	If !lRet
		nPosAnt := aScan(aOS,{|x| x[nPosOS]+x[nPosPL] == cPosAnt })
		If nPosAnt > Len(aOS) .Or. nPosAnt == 0
			nPosAnt := Len(aOS)
		EndIf
		oOS:nAt := nPosAnt
		fRefreshOS( aOS[oOS:nAt,nPosOS], aOS[oOS:nAt,nPosPL] , oOS:nAt, 1 )
		oOS:Refresh()
	EndIf

	lRetTela := .T.

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NG435VLIM ³ Autor ³Denis                  ³ Data ³02/12/2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Valida a quantidade limite do produto referente a pecas de  ³±±
±±³          ³reposicao do bem                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG435VLIM()
	Local nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG" })
	Local nPos02 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO"  })

	If cVALPECRE == "S"
		If aCols[n][nPos01] == "P"
			If !NGCHKLIMP(STJ->TJ_CODBEM,aCols[n][nPos02],M->TL_QUANTID)
				Return .F.
			EndIf
		EndIf
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NGPROD435 ³ Autor ³ Denis                 ³ Data ³ 06.09.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Busca a unidade do insumo                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGPROD435()
	Local nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPos04 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_UNIDADE"})
	Local nPos05 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"  })
	Local nPos11 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMLOTE"})
	Local nPos12 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOTECTL"})
	Local nPos13 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCALIZ"})
	Local nPos14 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSERI"})
	Local nPos99 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTVALID"})
	Local nPos98 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NOMCODI"})
	Local aAINSUMO := NGNOMINSUMO(aCOLS[n][nPos01],M->TL_CODIGO,20)
	Local cCodTer := ''
	Local _RET := .T. ,cHelp
	Local OldAli := Alias()
	Local cCODSTL
	Local nDesLoja := 0

	// Tratativa para valor default quando não informado o campo TL_TIPOREG.
	aCols[n,nPos01] := IIf( Empty( aCols[n,nPos01] ), 'M', aCols[n,nPos01] )

	// Repasse do valor default para a memória do campo.
	M->TL_TIPOREG   := aCols[n,nPos01]

	// Testa o tamanho do campo para nao permitir informar codigo invalido
	If aCOLS[n][nPos01] == "M"  //Mao de obra
		If Len(Alltrim(M->TL_CODIGO)) > Len(ST1->T1_CODFUNC)
			_RET  := .F.
			cHelp := "FUNCNEXIST"
		EndIf
	ElseIf aCOLS[n][nPos01] == "T"  //Terceiros
		If Len(Alltrim(M->TL_CODIGO)) > Len(SA2->A2_COD)
			_RET := .F.
			cHelp := "TERCNEXIST"
		EndIf
	ElseIf aCOLS[n][nPos01] == "F"  //Ferramenta
		If Len(Alltrim(M->TL_CODIGO)) > Len(SH4->H4_CODIGO)
			_RET := .F.
			cHelp := "FERRNEXIS"
		EndIf
	ElseIf aCOLS[n][nPos01] == "P"  //Produto
		If Len(Alltrim(M->TL_CODIGO)) > Len(SB1->B1_COD)
			_RET := .F.
			cHelp := "PRODNEXIST"
		EndIf
	EndIf

	If !_RET
		Help(" ",1,cHelp)
		dbSelectArea(OldAli)
		Return .F.
	EndIf

	If aCOLS[n][nPos01] == "P"  //Produto
		cCODSTL := Substr(M->TL_CODIGO,1,Len(SB1->B1_COD))
		If !NGPRODESP( cCODSTL )
			Return .F.
		EndIf

		//Não permite selecionar um produto 'bloqueado'
		If !Empty(M->TL_CODIGO)
			If !EXISTCPO("SB1",M->TL_CODIGO)
				Return .F.
			EndIf
		EndIf
	EndIf

	//Devido ao fato de não existir na tabela STL um campo correspondente a A2_LOJA, as validações abaixo devem ser feitas
	//para diferenciar Fornecedores com o mesmo código e lojas diferentes.
	cCodTer := Padr( M->TL_CODIGO, Len( SA2->A2_COD ) )
	If aCOLS[n][nPos01] == 'T' .AND. !Empty( M->TL_CODIGO )
		If cCodTer == SA2->A2_COD //Quando é acionado o F3
			If !ExistCpo( "SA2", cCodTer + SA2->A2_LOJA ) //Terceiros
				Return .F.
			ElseIf dbSeek( xFilial('SA2') + cCodTer + SA2->A2_LOJA )
				aCols[n][nPos98] := SA2->A2_NOME
				nDesLoja := 1
			EndIf
		Else //Quando é digitado
			DbSelectArea('SA2')
			DbSetOrder(1)
			DbSeek( xFilial('SA2') + cCodTer )
			If !ExistCpo( "SA2", cCodTer + SA2->A2_LOJA )
				Return .F.
			Endif
		Endif
	Endif

	If Empty(aAINSUMO[1][2])
		MsgInfo(STR0173,STR0174) //"Insumo nao cadastrado"###"ATENCAO"
		Return .F.
	Else
		If nDesLoja == 0
			aCols[n][nPos98] := aAINSUMO[1][2]
		Endif
		If acols[n][nPos01] = "P"
			aCols[n][nPos04] := NGSEEK("SB1",M->TL_CODIGO,1,"B1_UM")
			dbSelectArea("STJ")
			dbSetOrder(1)
			dbSeek(xFilial("STJ")+cOrdemTJ+cPlanoTJ)
			aCols[n][nPos05] := NGALMOXA(STJ->TJ_CODBEM,M->TL_CODIGO,aCols[n][nPos01],.T.)
			//Zera os campos de controle de rastreabilidade quando for trocado o codigo do produto
			If nPos12 > 0 .And. nPos11  > 0 .And. nPos99 > 0
				If !Empty(aCOLS[n][nPos12]) .Or. !Empty(aCOLS[n][nPos11]) .Or. !Empty(aCOLS[n][nPos99]);
				.Or. !Empty(aCOLS[n][nPos13]) .Or. !Empty(aCOLS[n][nPos14])
					aCOLS[n][nPos12] := Space(Len(STL->TL_LOTECTL))
					aCOLS[n][nPos11] := Space(Len(STL->TL_NUMLOTE))
					aCOLS[n][nPos99] := CTOD("  /  /  ")
					aCOLS[n][nPos13] := Space(Len(STL->TL_LOCALIZ))
					aCOLS[n][nPos14] := Space(Len(STL->TL_NUMSERI))
				EndIf
			Else
				If !Empty(M->TL_LOTECTL) .Or. !Empty(M->TL_NUMLOTE) .Or. !Empty(M->TL_DTVALID);
				.Or. !Empty(M->TL_LOCALIZ) .Or. !Empty(M->TL_NUMSERI)
					M->TL_LOTECTL := Space(Len(STL->TL_LOTECTL))
					M->TL_NUMLOTE := Space(Len(STL->TL_NUMLOTE))
					M->TL_DTVALID := CTOD("  /  /  ")
					M->TL_LOCALIZ := Space(Len(STL->TL_LOCALIZ))
					M->TL_NUMSERI := Space(Len(STL->TL_NUMSERI))
				EndIf
			EndIf
		Else
			aCols[n][nPos04] := "H"
			lTipo := .F.
		EndIf
	EndIf
	MV_PAR01      := STJ->TJ_CODBEM
	MV_PAR02      := STJ->TJ_SERVICO
	MV_PAR05      := STJ->TJ_SEQRELA
	cPar01 		  := MV_PAR01
	cPar02 		  := MV_PAR02
	cPar05 		  := MV_PAR05
Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³NGQUANTCHK ³ Autor ³Denis Hyroshi de Souza ³Data ³10/02/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Pre-consistencia da quantidade do insumo                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA400                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGQUANT435()
	Local nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG" })
	Local nPos02 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_UNIDADE" })

	If !NAOVAZIO(M->TL_QUANTID) .Or. !POSITIVO()
		Return .F.
	EndIf

	If !NGVALQUANT(aCols[n,nPos01],aCols[n,nPos02],M->TL_QUANTID)
		Return .F.
	EndIf

	If !NG435VLIM()
		Return .F.
	EndIf

	If !NGCALDTHO()
		Return .F.
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NG435DTINI³ Autor ³ Denis                 ³ Data ³ 06.09.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Valida a data inicio                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG435DTINI()
	
	Local nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG" })
	Local nPos02 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM"   })
	Local nPos03 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI" })
	Local nPos04 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOINICI" })
	Local lVerDt := !(STJ->TJ_SERVICO == 'HISTOR' .And. cUIntHis == 'N') 

	If !MNTA435MC()
		Return .F.
	EndIf

	If(M->TL_DTINICI > dDataBase)
		HELP(" ",1,"DATAINVAL")
		Return .F.
	EndIf
	If !NGDTINIC()
		Return .F.
	EndIf

	//Verifica data de fechamento do estoque
	If lVerDt .And. !NGCHKMESFE(M->TL_DTINICI,Acols[n,nPos01])
		Return .F.
	EndIf

	If !NGCALDTHO()
		Return .F.
	EndIf

	If aCols[n][nPos01] == "P"
		aCols[n][nPos02] := M->TL_DTINICI
		If !Empty(aCOls[n][nPos04]) .And. !Empty(aCOls[n][nPos03])
			MNT400CHKGAR()
			MNT400PCKGAR()
		EndIf
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NG435HOINI³ Autor ³ Denis                 ³ Data ³16/04/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Valida e mostra a hora inicio                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG435HOINI()
	Local nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG" })
	Local nPos02 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM"   })
	Local nPos03 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOFIM"   })
	Local nPos04 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI" })
	Local nPos05 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_USACALE" })

	If !NGVALHORA(M->TL_HOINICI,.T.)
		Return .F.
	EndIf

	If !MNTA435MC()
		Return .F.
	EndIf

	If !NGCALDTHO()
		Return .F.
	EndIf

	If aCols[n][nPos01] == "P"
		aCols[n][nPos02] := aCols[n][nPos04]
		aCols[n][nPos03] := M->TL_HOINICI
		If aCols[n,nPos04] = dDataBase .And. M->TL_HOINICI > SubS(Time(),1,5)
			MsgInfo(STR0245,STR0133)
			Return .F.
		EndIf
		If !Empty(aCOls[n][nPos04]) .And. !Empty(M->TL_HOINICI)
			MNT400CHKGAR()
			MNT400PCKGAR()
		EndIf
	Else
		M->TL_USACALE := If(aCols[n][nPos05] <> "S","N",aCols[n][nPos05])
		If !NGSTLHORIN()
			Return .F.
		EndIf
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NG435DTFIM³ Autor ³ Denis                 ³ Data ³ 06.09.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Valida a data fim                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG435DTFIM()
	Local nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI" })
	Local nPos02 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOFIM" })
	If !NaoVazio(M->TL_DTFIM)
		Return .F.
	EndIf
	If M->TL_DTFIM < aCols[n][nPos01]
		MsgInfo(STR0241,STR0133)
		Return .F.
	EndIf
	If !NGCPDIAATU(M->TL_DTFIM,"<=",.T.,,.T.)
		Return .F.
	EndIf

	If !MNTA435MC()
		Return .F.
	EndIf

	If M->TL_DTFIM = dDataBase .And. !Empty(aCols[n,nPos02]) .And. aCols[n,nPos02] > SubS(Time(),1,5)
		MsgInfo(STR0202+" "+STR0246+" "+STR0247+" "+STR0248+" "+STR0249+" "+STR0203+" "+STR0250+" "+STR0251+" "+STR0248,STR0133)
		Return .F.
	EndIf

	If !NGCALDTHO()
		Return .F.
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NG435HOFIM³ Autor ³ Denis                 ³ Data ³ 06.09.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Atualiza hora fim quando digitado qtde de horas.           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG435HOFIM()
	Local nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG" })
	Local nPos02 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM"   })
	Local nPos03 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOINICI" })
	Local nPos04 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI" })
	Local nPos05 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_USACALE" })

	If !NGVALHORA(M->TL_HOFIM,.T.)
		Return .F.
	EndIf

	If !MNTA435MC()
		Return .F.
	EndIf

	If aCols[n][nPos01] <> "P"
		If aCols[n][nPos04] = aCols[n][nPos02] .And. M->TL_HOFIM < aCols[n][nPos03]
			MsgInfo(STR0242,STR0133)
			Return .F.
		ElseIf  aCols[n][nPos02] = dDataBase .And. M->TL_HOFIM > SubS(Time(),1,5)
			MsgInfo(STR0243,STR0133)
			Return .F.
		EndIf
		M->TL_TIPOREG := aCols[n][nPos01]
		M->TL_USACALE := If(aCols[n][nPos05] <> "S","N",aCols[n][nPos05])
		M->TL_DTINICI := aCols[n][nPos04]
		M->TL_HOINICI := aCols[n][nPos03]
		M->TL_DTFIM   := aCols[n][nPos02]
		If !NGSTLHORFI()
			Return .F.
		EndIf
		NGCALQUANT()
	EndIf

	If !NGCALDTHO()
		Return .F.
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fLoadSTL ³ Autor ³ Denis                 ³ Data ³ 06.09.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Carrega aCols do STL nos campos temporarios M->            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fLoadSTL(lFocusSet,nLinSTL)

	Local cKEY,cGETWHILE
	Local lTemIns := .F.
	Local nOld
	Local oldaCols
	Local oldaHeader
	Local nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPos02 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DESTINO"})
	Local nPos03 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPos04 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_UNIDADE"})
	Local nPos05 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"  })
	Local nPos06 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI"})
	Local nPos07 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOINICI"})
	Local nPos08 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM"  })
	Local nPos09 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOFIM"  })
	Local nPos10 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANTID"})
	Local nPos11 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMLOTE"})
	Local nPos12 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOTECTL"})
	Local nPos13 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCALIZ"})
	Local nPos14 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSERI"})
	Local nPos15 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_GARANTI"})
	Local nPos16 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TAREFA" })
	Local nPos17 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_USACALE"})
	Local nPos18 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
	Local nPosTp := oBrw6:oBrowse:nAt

	If Valtype(nLinSTL) == "N"
		If Len(aCols) >= nLinSTL
			nPosTp := nLinSTL
		EndIf
	EndIf

	If !lStartVar
		Return .T.
	EndIf

	If nPos01 > 0
		M->TL_TIPOREG := aCols[ nPosTp , nPos01 ]
	EndIf
	If nPos02 > 0
		M->TL_DESTINO := aCols[ nPosTp , nPos02 ]
	EndIf
	If nPos03 > 0
		M->TL_CODIGO  := aCols[ nPosTp , nPos03 ]
	EndIf
	If nPos04 > 0
		M->TL_UNIDADE := aCols[ nPosTp , nPos04 ]
	EndIf
	If nPos05 > 0
		M->TL_LOCAL   := aCols[ nPosTp , nPos05 ]
	EndIf
	If nPos06 > 0
		M->TL_DTINICI := aCols[ nPosTp , nPos06 ]
	EndIf
	If nPos07 > 0
		M->TL_HOINICI := aCols[ nPosTp , nPos07 ]
	EndIf
	If nPos08 > 0
		M->TL_DTFIM   := aCols[ nPosTp , nPos08 ]
	EndIf
	If nPos09 > 0
		M->TL_HOFIM   := aCols[ nPosTp , nPos09 ]
	EndIf
	If nPos10 > 0
		M->TL_QUANTID := aCols[ nPosTp , nPos10 ]
	EndIf
	If nPos11 > 0
		M->TL_NUMLOTE := aCols[ nPosTp , nPos11 ]
	EndIf
	If nPos12 > 0
		M->TL_LOTECTL := aCols[ nPosTp , nPos12 ]
	EndIf
	If nPos13 > 0
		M->TL_LOCALIZ := aCols[ nPosTp , nPos13 ]
	EndIf
	If nPos14 > 0
		M->TL_NUMSERI := aCols[ nPosTp , nPos14 ]
	EndIf
	If nPos15 > 0
		M->TL_GARANTI := aCols[ nPosTp , nPos15 ]
	EndIf
	If nPos16 > 0
		M->TL_TAREFA  := aCols[ nPosTp , nPos16 ]
	EndIf
	If nPos17 > 0
		M->TL_USACALE := aCols[ nPosTp , nPos17 ]
	EndIf

	If nPos18 > 0
		aCols[ nPosTp , nPos18 ] := MNT435SEQ(aCols,.F.)
		M->TL_SEQRELA := aCols[ nPosTp , nPos18 ]
	EndIf

	oBrw3:oBrowse:lDisablePaint := .F.
	oldaCols   := aClone(aCols)
	oldaHeader := aClone(aHeader)

	If !Empty(cOrdemTJ)
		dbSelectArea("STJ")
		dbSetOrder(01)
		dbSeek(xFilial("STJ")+cOrdemTJ+cPlanoTJ)

		If ValType(oldaCols[ nPosTp , Len(oldaCols[nPosTp])-1 ]) == "A"
			If Len( oldaCols[ nPosTp , Len(oldaCols[nPosTp])-1 ] ) > 0
				lTemIns := .T.
			EndIf
		Else
			aAdd( oldaCols[nPosTp] , oldaCols[ nPosTp , Len(oldaCols[nPosTp]) ] )
			oldaCols[ nPosTp , Len(oldaCols[nPosTp])-1 ] := {}
		EndIf

		aCoBrw3 := {}
		If lTemIns
			aCoBrw3 := aClone( oldaCols[ nPosTp , Len(oldaCols[nPosTp])-1 ] )
		Else
			If !Empty(M->TL_SEQRELA)
				cKEY  := cOrdemTJ + cPlanoTJ + M->TL_TAREFA + M->TL_SEQRELA
				cGETWHILE := "TN_ORDEM   == '"+  cOrdemTJ  +"' .And. "
				cGETWHILE += "TN_PLANO   == '"+  cPlanoTJ  +"' .And. "
				cGETWHILE += "TN_TAREFA  == '"+M->TL_TAREFA +"' .And. "
				cGETWHILE += "TN_SEQRELA == '"+M->TL_SEQRELA+"'"
				dbSelectArea("STN")
				dbSetOrder(1)
				Inclui := .F.
				aHoBrw3 := NGHeader("STN", {"TN_FILIAL", "TN_TAREFA","TN_NOMETAR","TN_ORDEM","TN_PLANO","TN_SEQRELA", "TN_SEQUENC"}, .F. )
				aCoBrw3 := MAKEGETD("STN", cKEY,  aHoBrw3, cGETWHILE,,.F.)
				Inclui := .T.
			EndIf
		EndIf

		If Len(aCoBrw3) == 0
			aCoBrw3 := BLANKGETD(aHoBrw3)
		EndIf
		nOld := n

		aCols   := aClone(aCoBrw3)
		aHeader := aClone(aHoBrw3)
		n := 1
		oBrw3:oBrowse:Default()
		oBrw3:oBrowse:Refresh()

		n := nOld
		aCols   := aClone(oldaCols)
		aHeader := aClone(oldaHeader)
		oBrw6:oBrowse:Default()
		oBrw6:oBrowse:Refresh()
		If !lTemIns
			aCols[ nPosTp , Len(aCols[nPosTp])-1 ] := aClone(aCoBrw3)
		EndIf
		If Valtype(nLinSTL) == "N"
			If Len(aCols) >= nLinSTL
				oBrw6:oBrowse:nAt := nLinSTL
			EndIf
		EndIf
		If lFocusSet
			oBrw6:oBrowse:SetFocus()
		EndIf
		PutFileInEof("STN")
	EndIf

	oBrw3:oBrowse:lDisablePaint := .T.

	dbSelectArea("STJ")
	dbSetOrder(01)
	dbSeek(xFilial("STJ")+cOrdemTJ+cPlanoTJ)
	If STJ->TJ_SERVICO == "HISTOR"
		If cUIntHis == "N" .And. cUsaInt3 == 'S' .And. aCols[ nPosTp , nPos01 ] $ ("P/M")
			lCusto := .T.
		Else
			lCusto := .F.
		EndIf
	ElseIf cUsaInt3 == 'S'
		lCusto := .F.
	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NG435LOTCT³ Autor ³ Denis                 ³ Data ³ 13/03/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Valida o campo TL_LOTECTL                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG435LOTCT()
	Local nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPos02 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"  })
	Local nPos03 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMLOTE"})

Return If(!Empty(M->TL_LOTECTL),NGVRASTSB8(aCols[n][nPos01],aCols[n][nPos02],M->TL_LOTECTL,aCols[n][nPos03]),.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NG435NUMLO³ Autor ³ Denis                 ³ Data ³ 13/03/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Valida o campo TL_NUMLOTE                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG435NUMLO()
	Local nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPos02 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"  })
	Local nPos03 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOTECTL"})

Return If(!Empty(M->TL_NUMLOTE),NGVRASTSB8(aCols[n][nPos01],aCols[n][nPos02],aCols[n][nPos03],M->TL_NUMLOTE),.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NG435LOCAL³ Autor ³ Denis                 ³ Data ³ 13/03/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Valida o campo TL_LOCALIZ                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NG435LOCAL()
	Local nPos01 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"  })

Return If(!Empty(M->TL_LOCALIZ),ExistCpo("SBE",aCols[n][nPos01]+M->TL_LOCALIZ),.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³NGRETNO435³ Autor ³Denis                  ³ Data ³06/08/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Mostra o nome do tipo de insumo                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA400                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGRETNO435(cTipo)

	If cUsaGeRe == "EST" .And. cTipo == "P"
		MsgInfo(STR0086) //"Para insumo produto somente poderá ser gerado SA (Solicitação ao Armazém)."
		Return .F.
	EndIf

	If !NGVALTERC(cTipo)
		Return .F.
	EndIf

	If cTipo == "P"
		If ExistBlock("MNTA4009")
			If !ExecBlock("MNTA4009",.F.,.F.)
				Return .F.
			EndIf
		EndIf
	ElseIf cTipo == "E"
		MsgInfo(STR0175+chr(13)+chr(10)+STR0176,STR0133) //"Tipo de insumo invalido.."###"Informe um tipo de insumo diferente de especialidade"###"NAO CONFORMIDADE"
		Return .F.
	EndIf

	NGCLEARSTL()

	If NGFUNCRPO("NGMDOEXECU",.F.)
		nColPe := GDFIELDPOS("TL_PERMDOE")
		nColTi  := GDFIELDPOS("TL_TIPOREG")
		If nColPe > 0  .And. nColTi > 0 .And.  (aCOLS[n,nColTi ] <> "M" .Or.  aCOLS[n,nColTi] <> M->TL_TIPOREG)
			aCOLS[n,nColPe] := 0.00
		EndIf
	EndIf
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ fMNTA405 ³ Autor ³ Denis                 ³ Data ³24/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Retorno das Opcoes da Etapa da manutencao                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Objetivo  ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fMNTA405()

	Local aCposAlter := {}, nI := 0
	Local aPosCpo    := {}
	Local aAlterCpos := { "TX_OK", "TPQ_RESPOS" }
	Local aOldHea    := aClone(aHeader)
	Local aOldRot    := aClone(aRotina)
	Local aOldCol    := aClone(aCols)
	Local nLineOS    := aScan(aDadosOS, {|x|x[1] + x[2] == cOrdemTJ + cPlanoTJ })
	Local aTempDad   := Nil
	Local cTOpcao, lOk
	Local oPnlAll
	Local lPE4351L   := ExistBlock("MNTA435L")
	Local nTot       := 0
	Local nInd       := 0
	Local nTamanho   := 0
	Local nDecimal   := 0
	Local nDscOpt    := 0
	Local cCampo     := ""
	Local cArquivo   := ""
	Local cTitulo    := ""
	Local cPicture   := ""
	Local cValid     := ""
	Local cUsado     := ""
	Local cTipo      := ""
	Local cContext   := ""
	Local cX3Nivel   := ""

	Private oDlg3, oGet, cCodAnt

	nItens := 0

	/*--------------------------------------------------------------------------------------
	| Caso a etapa esteja marcada, verifica se esta etapa gerou alguma OS/SS que não está	|
	| cancelada. Caso exista alguma OS/SS não cancelada não permitirá desmarcá-la.			|
	| 																						|
	| MNT400OSG - Verifica se existem OS's													|
	| MNT400SSG - Verifica se existem OS's													|
	---------------------------------------------------------------------------------------*/
	If Empty((cTRBQ400)->TQ_OK)
		If !MNT400OSG( (cTRBQ400)->TQ_ORDEM , (cTRBQ400)->TQ_PLANO , (cTRBQ400)->TQ_TAREFA , (cTRBQ400)->TQ_ETAPA )
			(cTRBQ400)->TQ_OK := cMarca
			Return .F.
		ElseIf !MNT400SSG( (cTRBQ400)->TQ_ORDEM, (cTRBQ400)->TQ_PLANO, (cTRBQ400)->TQ_TAREFA, (cTRBQ400)->TQ_ETAPA )
			(cTRBQ400)->TQ_OK := cMarca
			Return .F.
		EndIf
	EndIf

	ccAlias := Alias()

	//Carrega informações da ordem de serviço da etapa etapa selecionada
	dbSelectArea("STJ")
	dbSetOrder(1)
	dbSeek( xFilial("STJ") + (cTRBQ400)->TQ_ORDEM + (cTRBQ400)->TQ_PLANO )

	cOrdem   := STJ->TJ_ORDEM
	cPlano   := STJ->TJ_PLANO
	cBem     := STJ->TJ_CODBEM
	cServico := STJ->TJ_SERVICO
	nSequenc := STJ->TJ_SEQRELA
	cTarefa  := (cTRBQ400)->TQ_TAREFA
	cEtapa   := (cTRBQ400)->TQ_ETAPA

	//Verifica se a etapa existe na TPA (Etapas Genéricas)
	dbSelectArea("TPA")
	dbSetOrder(1)
	If !dbSeek(xFilial("TPA") + cEtapa) .Or. TPA->TPA_OPCOES == '0'

		//Atualiza tabelas temporárias/arrays com as alterações de etapas
		Fd_Sai( 4 )

		dbSelectArea(ccALIAS)
		Return Nil
	EndIf

	//Verifica se a etapa existe na TPC (Opções da Etapa Genérica)
	dbSelectArea("TPC")
	dbSetOrder(1)
	If !dbSeek(xFilial("TPC") + cEtapa)
		dbSelectArea(ccALIAS)
		Return Nil
	EndIf

	aRotina := {{STR0181, "AxPesqui",0,1},; //"Pesquisar"
				{STR0182, "NGCAD02" ,0,2},; //"Visualizar"
				{STR0028, "MNTA405" ,0,3}}  //"Incluir"

	If !Empty( (cTRBQ400)->TQ_OK )

		aCols := {}
		If Type("aDadosOS[" + Alltrim( Str(nLineOS) ) + ",8]") == "A"

			nPosTar := aScan(aTRBQ, {|x| Alltrim(x[1]) == "TQ_TAREFA" })
			nPosEta := aScan(aTRBQ, {|x| Alltrim(x[1]) == "TQ_ETAPA" })
			If nPosTar > 0 .And. nPosEta > 0
				If (nPosCol := aScan(aDadosOS[nLineOS,8] , {|x| x[nPosTar] == cTarefa .And. x[nPosEta] == cEtapa })) > 0

					aTemp := aDadosOS[nLineOS,8,nPosCol, Len(aDadosOS[nLineOS,8,nPosCol])]
					If ValType(aTemp) == "A"
						aTempDad := aClone(aTemp)
					EndIf
				EndIf
			EndIf
		EndIf

		cTOpcao  := IIf( TPA->TPA_OPCOES == '1', STR0183, STR0272) //"Exclusiva" ## "Múltiplas"

		lTpOpcao := IIf( TPA->TPA_OPCOES == '1', '1', '2' )
		cNomEta := SubStr(TPA->TPA_DESCRI, 1, 70)
		cNomTar := NGNOMETAR( cBem + cServico + nSequenc, cTarefa )

		M->TP1_TPMANU := '0'
		M->TP1_TIPRES := "X"
		M->TPQ_RESPOS := Space( TAMSX3("TPQ_RESPOS")[1] )
		lEOpcao       := .F.
		nOpcx         := 3


		nUsado  := 0
		aHeader := {}
		fMntCabec() // Montagem do aHeader

		// Preenche o array auxiliar aCposAlter...
		If ExistBlock("NG405CPU")
			aCposAlter := ExecBlock("NG405CPU", .F., .F.)
		EndIf

		// Agrega no array aHeader os campos de Usuarios...
		nTot := Len(aCposAlter)
		For nInd := 1 To nTot

			cCampo   := aCposAlter[nInd]
			cArquivo := Posicione("SX3",2,cCampo,"X3_ARQUIVO")
			If TPQ->(FieldPos(cCampo)) > 0

				cTitulo  := AllTrim(Posicione("SX3",2,cCampo,"X3Titulo()"))
				cPicture := X3Picture(cCampo)
				nTamanho := TAMSX3(cCampo)[1]
				nDecimal := TAMSX3(cCampo)[2]
				cValid   := Posicione("SX3",2,cCampo,"X3_VALID")
				cUsado   := Posicione("SX3",2,cCampo,"X3_USADO")
				cTipo    := Posicione("SX3",2,cCampo,"X3_TIPO")
				cContext := Posicione("SX3",2,cCampo,"X3_CONTEXT")
				cX3Nivel := Posicione("SX3",2,cCampo,"X3_NIVEL")

				If X3USO(cUsado) .And. cNivel >= cX3Nivel
					nUsado++
					aAdd(aHeader,{cTitulo,cCampo,cPicture,nTamanho,nDecimal,cValid,cUsado,cTipo,cArquivo,cContext})
				EndIf

			EndIf

		Next nInd

		nOk     := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TX_OK" })
		nnOPCA  := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TP1_OPCAO" })
		nBEMIMN := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TP1_BEMIMN" })
		nTIPCAM := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TP1_TIPCAM" })
		nRESPOS := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TPQ_RESPOS" })
		nDscOpt := GdFieldPos( 'TPC_DESOPC', aHeader )

		//Conta o número de opções que a etapa possui
		dbSelectArea("TPC")
		dbSetOrder(1) //TPC_FILIAL+TPC_ETAPA+TPC_OPCAO
		If dbSeek( xFilial("TPC") + cEtapa )
			nCnt   := 0
			nItens := 0

			While !EoF() .And. TPC->TPC_FILIAL == xFilial("TPC") .And. cEtapa == TPC->TPC_ETAPA
				nCnt++
				dbSkip()
			EndDo
		EndIf

		//---------------------------------------------------------------
		// Início -> Montagem do aCols
		//---------------------------------------------------------------
		If nCnt > 0
			aCols := Array(nCnt, nUsado + 1)

			dbSelectArea("TPC")
			dbSetOrder(1)
			If dbSeek(xFilial("TPC") + cEtapa)
				nCnt   := 0
				nUsado := 0
				While !EoF() .And. TPC->TPC_FILIAL == xFilial("TPC") .And. cEtapa == TPC->TPC_ETAPA
					nCnt++
					nUsado++

					cRes := " "
					If ValType(aTempDad) == "A"
						nPosCpo := aScan(aTempDad ,{|x| x[2] == TPC->TPC_OPCAO })
						If nPosCpo > 0
							cRes := aTempDad[nPosCpo][3]
						EndIf
					Else
						dbSelectArea("TPQ")
						dbSetOrder(1) //TPQ_FILIAL+TPQ_ORDEM+TPQ_PLANO+TPQ_TAREFA+TPQ_ETAPA+TPQ_OPCAO
						If dbSeek( xFilial("TPQ") + cOrdem + cPlano + cTarefa + cEtapa + TPC->TPC_OPCAO )
							cRes := TPQ->TPQ_RESPOS
						EndIf
					EndIf

					aCOLS[nCnt,nnOPCA]  := TPC->TPC_OPCAO
					aCOLS[nCnt,nDscOpt] := TPC->TPC_DESOPC
					aCOLS[nCnt,nOK]     := Space(01)

					If TPC->TPC_TIPRES == '1'
						aCOLS[nCnt][nBEMIMN] := STR0186 //"MARCAR"
						If ValType(aTempDad) == "A"
							nPosCpo := aScan(aTempDad ,{|x| x[2] == TPC->TPC_OPCAO })
							If nPosCpo > 0
								aCOLS[nCnt][nOK] := "X"
							EndIf
						Else
							dbSelectArea("TPQ")
							dbSetOrder(2)
							If dbSeek( xFilial("TPQ") + cOrdem + cEtapa + TPC->TPC_OPCAO )
								aCOLS[nCnt][nOK] := "X"
							EndIf
						EndIf
					Else
						aCOLS[nCnt][nBEMIMN] := STR0187 //"INFORMAR"
					EndIf

					aCOLS[nCnt][nTIPCAM] := TPC->TPC_TIPCAM

					If !Empty(cRes)
						aCOLS[nCnt][nOK]     := "X"
						aCOLS[nCnt][nRESPOS] := cRes
					Else
						aCOLS[nCnt][nRESPOS] := Space(10)
					EndIf

					If Len(aCposAlter) > 0
						For nI := 1 To Len(aCposAlter)
							nPosCpo := aScan(aHeader,{|x| AllTrim(x[2]) == aCposAlter[nI]})

							aAdd( aPosCpo, { aCposAlter[nI], nPosCpo })

							aCOLS[nCnt][nPosCpo] := CriaVar(aCposAlter[nI])
						Next nI
					EndIf

					ATail(aCOLS[nCnt]) := .F.
					nItens++
					lRefresh := .T.

					If lPE4351L
						aCOLS := ExecBlock("MNTA435L",.F.,.F.,{aHEADER,aCOLS,nCnt})
					EndIf

					dbSelectArea("TPC")
					dbSkip()
				EndDo
			EndIf
		EndIf
		//---------------------------------------------------------------
		// Fim -> Montagem do aCols
		//---------------------------------------------------------------

		DEFINE MSDIALOG oDlg3 TITLE OemToAnsi(STR0188) From 6.5,10 To 27,90 OF oMainWnd

		oPnlAll := TPanel():New( 00,00,,oDlg3,,,,,CLR_WHITE,12,12,.F.,.F. )
		oPnlAll:Align := CONTROL_ALIGN_ALLCLIENT

		oPnlCabec := TPanel():New( 00,00,,oPnlAll,,,,,CLR_WHITE,12,12,.F.,.F. )
		oPnlCabec:Align := CONTROL_ALIGN_TOP
		oPnlCabec:nHeight := 95

		oPnlGetD := TPanel():New( 00,00,,oPnlAll,,,,,CLR_WHITE,10,10,.F.,.F. )
		oPnlGetD:Align := CONTROL_ALIGN_ALLCLIENT

		@ 0.7,1  Say OemToAnsi(STR0027) Of oPnlCabec //"Ordem"
		@ 0.7,4  MsGet cOrdem When .F. Of oPnlCabec

		@ 0.7,9  Say OemToAnsi(STR0050) Of oPnlCabec //"Plano"
		@ 0.7,12 MsGet cPlano  When .F. Of oPnlCabec

		@ 0.7,17 Say OemToAnsi(STR0057) Of oPnlCabec//"Opcao"
		@ 0.7,20 MsGet cTOpcao When .F. Of oPnlCabec

		@ 1.7,1  Say OemToAnsi(STR0023) Of oPnlCabec //"Tarefa"
		@ 1.7,4  MsGet cTarefa When .F. Of oPnlCabec

		@ 1.7,9  Say OemToAnsi(STR0080) Of oPnlCabec//"Nome"
		@ 1.7,12 MsGet cNomTar SIZE 150,10 When .F. Of oPnlCabec

		@ 2.7,1  Say OemToAnsi(STR0025) Of oPnlCabec //"Etapa"
		@ 2.7,4  MsGet cEtapa  When .F. Of oPnlCabec

		@ 2.7,9  Say OemToAnsi(STR0080) Of oPnlCabec //"Nome"
		@ 2.7,12 MsGet cNomEta SIZE 200,10 When .F. Of oPnlCabec

		oGet := MsGetDados():New( 2, 6, 70, 310, nOpcx, "fE405LINOK", "fE405TUDO", "", .F., aAlterCpos,,, nItens,,,,, oPnlGetD )

		ACTIVATE MSDIALOG oDlg3 ON INIT EnchoiceBar(oDlg3,{|| lOk := .T., IIf( !fE405TUDO(), lOk := .F., oDlg3:End())},;
		{|| lOk := .F., oDlg3:End()}) CENTERED

		If lOk
			dbSelectArea(cTRB3400)
			dbSetOrder(1)
			dbGoTop()
			If dbSeek((cTRBQ400)->TQ_ETAPA+(cTRBQ400)->TQ_TAREFA)
				While !EoF() .And. (cTRB3400)->TPC_ETAPA == (cTRBQ400)->TQ_ETAPA;
				.And. (cTRB3400)->TPC_TAREFA == (cTRBQ400)->TQ_TAREFA

					RecLock(cTRB3400,.F.)
					DbDelete()
					(cTRB3400)->(MsUnLock())
					dbSkip()
				EndDo
			EndIf

			//Salva as respostas das etapas na tabela temporária (cTRB3400)
			fSaveResp( cEtapa, cTarefa, aCposAlter)
		Else
			//Desmarca a etapa caso a tela de resposta das opções seja fechada
			dbSelectArea(cTRBQ400)
			(cTRBQ400)->TQ_OK := ""
		EndIf

	Else
		dbSelectArea(cTRB3400)
		dbSetOrder(1)
		dbGoTop()
		If dbSeek( (cTRBQ400)->TQ_ETAPA + (cTRBQ400)->TQ_TAREFA )
			While !EoF() .And. (cTRB3400)->TPC_ETAPA == (cTRBQ400)->TQ_ETAPA .And.;
			(cTRB3400)->TPC_TAREFA == (cTRBQ400)->TQ_TAREFA

				RecLock(cTRB3400,.F.)
				dbDelete()
				(cTRB3400)->(MsUnLock())

				dbSelectArea(cTRB3400)
				dbSkip()
			EndDo
		EndIf
	EndIf

	//Atualiza tabelas temporárias/arrays com as alterações de etapas
	Fd_Sai( 4 )

	dbSelectArea(ccALIAS)
	aHeader := aClone(aOldHea)
	aCols   := aClone(aOldCol)
	aRotina := aClone(aOldRot)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ fE405TUDO³ Autor ³ Denis                 ³ Data ³24/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Consistencia final                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Objetivo  ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fE405Tudo()

	Local nI
	Local cOpcao
	Local lNaoMarca  := .F.

	For nI := 1 To nItens

		cOpcao := IIf( SubStr( aCols[nI][nBEMIMN], 1, 1 ) == "M", '1', '2' )

		If !Empty(aCols[nI][nOk]) .And. cOpcao == '2' .And. Empty(aCols[nI][nRESPOS])
			Help(" ",1,"OPSEMINFO")
			Return .F.
		EndIf

		If !lNaoMarca
			If !Empty(aCols[nI][nOk])
				lNaoMarca := .T.
			EndIf
		EndIf
	Next nI

	If !lNaoMarca
		dbSelectArea(cTRBQ400)
		(cTRBQ400)->TQ_OK := "   "
		ShowHelpDlg( "NGATENCAO", { STR0273 }, 1,; //"Não há opções marcadas e/ou respondidas para esta etapa."
		{ STR0274 }, 1)				 //"É necessário marcar e/ou informar pelo menos uma opção para etapas que possuem opção 'Exclusiva' ou 'Múltiplas'."
		Return .F.
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³FE405TPVAR³ Autor ³ Denis                 ³ Data ³24/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Consistencia campo de resposta                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Objetivo  ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FE405TPVAR()

	If findfunction("NGTPCONTCAR")
		dbSelectArea("TPC")
		dbSetOrder(1)
		If dbSeek(xFilial("TPC")+cEtapa+aCOLS[n,nnOPCA])
			If !NGTPCONTCAR(TPC->TPC_TIPCAM,M->TPQ_RESPOS)
				Return .F.
			EndIf
		EndIf
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³fE405LINOK³ Autor ³ Denis                 ³ Data ³24/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Consistencia da linha                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Objetivo  ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fE405LINOK()
	If n > nItens
		Return .F.
	EndIf
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ fEmptyOS ³ Autor ³ Denis                   Data ³24/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Cria tela de OS vazia                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Objetivo  ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fEmptyOS(lRef)

	Local nX
	Local cTipo := ""

	aOS      := {}
	aDadosOS := {}
	aTemp    := {}
	For nX := 1 To Len(aCampStj)
		If nX == 1
			aAdd( aTemp , 0 )
		ElseIf !Empty(aCampStj[nX])
			xValTemp := " "
			cTipo    := Posicione("SX3",2,aCampStj[nX],"X3_TIPO")
			If !Empty(cTipo)
				If cTipo == "D"
					xValTemp := StoD("")
				ElseIf cTipo == "N"
					xValTemp := 0
				ElseIf cTipo == "L"
					xValTemp := .F.
				EndIf
			EndIf
			aAdd( aTemp , xValTemp )
		Else
			aAdd( aTemp , " " )
		EndIf
	Next nX
	M->TJ_ORDEM := Space(Len(STJ->TJ_ORDEM))
	M->TJ_PLANO := Space(Len(STJ->TJ_PLANO))
	cOrdemTJ    := M->TJ_ORDEM
	cPlanoTJ    := M->TJ_PLANO
	aAdd( aOS , aTemp )

	If lRef
		//Etapas
		dbSelectArea(cTRBQ400)
		Zap
		dbSelectArea(cTRB3400)
		Zap
		dbSelectArea(cTRBTAR)
		Zap

		//Insumos
		dbSelectArea(cTRBIP)
		Zap
		aCoBrw2 := BLANKGETD(aHoBrw2)
		oBrw2:oBrowse:Refresh()

		oBrw6:oBrowse:lDisablePaint := .T.
		oBrw3:oBrowse:lDisablePaint := .T.
		oBrw5:oBrowse:lDisablePaint := .T.

		If Valtype(aNovoSTL) == "A"
			aCoBrw6 := aClone(aNovoSTL)
		Else
			aCoBrw6 := BLANKGETD(aHoBrw6)
		EndIf
		aCols   := aClone(aCoBrw6)
		aHeader := aClone(aHoBrw6)
		n := 1
		oBrw6:oBrowse:lDisablePaint := .F.
		oBrw6:oBrowse:Refresh()
		oBrw6:oBrowse:lDisablePaint := .T.

		//Ocorrencias
		aCoBrw3 := BLANKGETD(aHoBrw3)
		aCols   := aClone(aCoBrw3)
		aHeader := aClone(aHoBrw3)
		n := 1
		oBrw3:oBrowse:lDisablePaint := .F.
		oBrw3:oBrowse:Refresh()
		oBrw3:oBrowse:lDisablePaint := .T.

		//Motivos Atraso
		n:=1
		aCoBrw4 := BLANKGETD(aHoBrw4)
		aCols   := aClone(aCoBrw4)
		aHeader := aClone(aHoBrw4)
		oBrw5:oBrowse:lDisablePaint := .F.
		oBrw5:oBrowse:Refresh()
		oBrw5:oBrowse:lDisablePaint := .T.

		oOS:Refresh()
		oOS:SetFocus()
	EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ fFina435 ³ Autor ³ Denis                 ³ Data ³ 13/06/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Programa para finalizacao OS de servico de Manutencao      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MNTA400                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fFina435(cALIAS,nREG,nOPCX,aVetData,nOSnAt,_aFin2P)

	Local nRecnSTJ, nCont
	Local cTipoCon   := " "
	Local lSoProduto := aVetData[5]
	Local cLanex     := IIf(FindFunction('NGUSELANEX'), NGUSELANEX( STJ->TJ_CODBEM ) , ;
						AllTrim( SuperGetMv( 'MV_NGLANEX', .F., '' ) )  )
	
	Local lSemIns := ExistBlock("NGSEMINS")

	Private bNGGRAVA, aCHKDEL     := {}
	Private TipoAcom, TipoAcom2, lFimOsWhen  := Nil

	Store .F. To TipoAcom, TipoAcom2

	nRET := 0

	dDTMRINI := STJ->TJ_DTMRINI
	dDTMRFIM := STJ->TJ_DTMRFIM
	cHOMRINI := STJ->TJ_HOMRINI
	cHOMRFIM := STJ->TJ_HOMRFIM
	nCONTOL1 := STJ->TJ_POSCONT
	nCONTOL2 := STJ->TJ_POSCON2

	dbSelectArea("STJ")
	dbSetOrder(1)
	dbSeek( xFilial("STJ") + cOrdemTJ + cPlanoTJ )

	nINDSTJ  := IndexOrd()
	nRECSTJ  := Recno()
	nREGFIM  := Recno()

	cBemRet  := Space( TAMSX3("TJ_CODBEM")[1] )
	cBemRet  := NGTBEMPAI( STJ->TJ_CODBEM, cBemRet)
	cBemRet  := IIf( Empty(cBEMRET), STJ->TJ_CODBEM, cBemRet )

	cTIPOCON := NGSEEK("ST9",cBEMRET,1,"T9_TEMCONT")
	TIPOACOM := ( cTIPOCON == "S" )
	nCONTBEM := ST9->T9_POSCONT
	nCONTSTJ := 0
	//FindFunction remover na release GetRPORelease() >= '12.1.027'
	If FindFunction("MNTCont2")
		TipoAcom2 := MNTCont2(xFilial("TPE"), cBemRet )
	Else
		dbSelectArea("TPE")
		dbSetOrder( 1 )
		TipoAcom2 := ( dbSeek( xFilial("TPE") + cBemRet ) )
	EndIf

	dbSelectArea("STJ")
	//VERIFICA A DATA E HORA FINAL PARA O.S. COM INSUMOS REAL
	dDTINI := aVetData[1]
	hORINI := aVetData[2]
	dDTFIM := aVetData[3]
	hORFIM := aVetData[4]

	If lSoProduto
		If Len(_aFin2P) == 0
			dDTFIM := dDataBase
			hORFIM := Time()
		EndIf
	EndIf

	vCONLA := NGACUMEHIS(cBEMRET,dDTFIM,hORFIM,1,IIf( !Empty(cLanex), "E", "P" ) )
	aCHOICE := {"TJ_ORDEM", "TJ_DTPRINI", "TJ_DTPRFIM", "TJ_HOPRINI", "TJ_HOPRFIM", "TJ_POSCONT",;
	"TJ_HORACO1", "TJ_POSCON2", "TJ_HORACO2", "TJ_DTMRINI", "TJ_HOMRINI", "TJ_DTMRFIM",;
	"TJ_HOMRFIM", "TJ_OBSERVA"}

	If ExistBlock("MNT40017")
		ExecBlock("MNT40017",.F.,.F.)
	EndIf

	If lSoProduto .Or. lSemIns //Verifica se existe só insumo do tipo produto ou utilizar o P.E. NGSEMINS
		lFimOsWhen := .T.
	EndIf

	aRELAC  := { { "TJ_POSCONT", "vCONLA[1]" },;
					( IIf( TipoAcom, { "TJ_HORACO1", "hORFIM" }, { "TJ_HORACO1", "''" } ) ),;
					{ "TJ_DTMRINI", "dDTINI" },;
					{ "TJ_HOMRINI", "hORINI" },;
					{ "TJ_DTMRFIM", "dDTFIM" },;
					{ "TJ_HOMRFIM", "hORFIM" },;
					( IIf( TipoAcom2, { "TJ_HORACO2", "hORFIM" }, { "TJ_HORACO2", "''" } ) ) }

	If cTENDFLAHA <> "N" .And. STJ->TJ_PLANO == "000000" //os corretiva
		aAdd( aCHOICE, "TJ_IRREGU" )
		aAdd( aCHOICE, "TJ_NIRREGU" )
	EndIf

	If ExistBlock("MNT40012")
		aRelacPE := ExecBlock("MNT40012",.F.,.F.,{aHoBrw6, aCoBrw6})
	EndIf

	If(Type("aRelacPE") == "A")
		If Len(aRelacPE) > 0
			For nCont := 1 To Len(aRelacPE)
				aAdd(aRELAC,aRelacPE[nCont])
			Next
		EndIf
	EndIf

	dbSelectArea("STJ")
	bNGGRAVA := { || NG435CHK( nOSnAt, lSoProduto ) .And. fInteg( cOrdemTJ ) }

	Inclui      := .F.
	nRet        :=  NGCAD01("STJ",nREG,4)
	Inclui      := .T.
	bNGGRAVA    := {}

	dbSelectArea("STJ")
	nRECNSTJ := Recno()
	If nRET == 1
		/*Ponto de entrada disponível para customização específica na Finalização do Retorno da Ordem de Serviço. SS: 021345*/
		If ExistBlock("MNTA4352")
			nRet := ExecBlock("MNTA4352",.F.,.F., { nRET })
		EndIf
	EndIf

	If nRET == 1
		cAORDEM   := STJ->TJ_ORDEM
		cAPLANO   := STJ->TJ_PLANO
		cACODBEM  := STJ->TJ_CODBEM
		cASERVICO := STJ->TJ_SERVICO
		nASEQUENC := STJ->TJ_SEQRELA
		nCONTSTJ  := STJ->TJ_POSCONT
		nDIFX     := nCONTSTJ - nCONTBEM
		nDIF      := IIf( nDIFX > 0, nDIFX, 0 )

		NGFINAL( STJ->TJ_ORDEM, STJ->TJ_PLANO, STJ->TJ_DTPRINI, STJ->TJ_HOPRINI,;
		STJ->TJ_DTPRFIM, STJ->TJ_HOPRFIM, STJ->TJ_POSCONT, STJ->TJ_POSCON2,;
		cBEMRET, STJ->TJ_HORACO1, STJ->TJ_HORACO2, nDIF)

		lSTJAchou := A400STJBUS(cACODBEM)
		dbSelectArea("ST9")
		dbSetOrder(1)
		If dbSeek(xFilial("ST9")+cACODBEM)
			RecLock("ST9",.F.)
			If lSTJAchou = .F.
				ST9->T9_TERCEIR := "1"
			EndIf
			ST9->(MsUnlock())
		EndIf

		lOSPOST := ( AllTrim( GetMv("MV_NGREPRO") ) == "S" )
		If STJ->TJ_DTMRFIM <> STJ->TJ_DTMPFIM .And. Val(STJ->TJ_PLANO) > 0 .And. lOSPost
			NGOSREPROG( STJ->TJ_CODBEM, STJ->TJ_SERVICO, STJ->TJ_SEQRELA, STJ->TJ_DTMRFIM, STJ->TJ_DTMPFIM )
		EndIf

		dbSelectArea("STJ")
		dbGoto(nRECSTJ)
		If ExistBlock("NG400FI1")
			ExecBlock("NG400FI1",.F.,.F.)
		EndIf

		dbSelectArea("STJ")
		nREGFIM := Recno()
		dbGoto(nRECSTJ)

		//Fechamento de solicitacao de servico
		NGFECHASS(stj->tj_ordem)
	EndIf

	dbSelectArea("STJ")
	dbSetOrder(nINDSTJ)
	lREFRESH := .T.

Return (nRet == 1)

//-----------------------------------------------------------------------
/*/{Protheus.doc} NG435CHK
Valida tela de finalizacao de OS e aciona gravação da ordem

@author Denis Hyroshi de Souza
@since 01/06/08

@param nOSnAt, numérico, posição da ordem que está sendo finalizada
@param lSoProduto, boolean, indica se há somente insumos tipo produto
@return boolean, se houve sucesso na operação
/*/
//-----------------------------------------------------------------------
Function NG435CHK( nOSnAt, lSoProduto )

	Local lRet := .T.

	If !NG400CHKFIM(lSoProduto)
		Return .F.
	EndIf

	If FindFunction("NGVLDSTL") .And. !NGVLDSTL(STJ->TJ_ORDEM) // verifica se não existe insumo com data e hora inicial igual a data e hora final
		Return .F.
	EndIf
	Inclui := .T.
	lRet := fGrava435( nOSnAt, .F., .F. )
	Inclui := .F.

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fPosObjet ³ Autor ³Denis Hyroshi de Souza ³ Data ³ 01/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ1ÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Define posicionamento dos objetos                           |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fPosObjet()
	Local lFlatMode := If(FindFunction("FLATMODE"),FlatMode(),SetMDIChild())

	nTipoVert := 1 //1024
	nTipoHorz := 1 //1280
	nPorcVert := 1 //% em relação a resolucao maxima
	nPorcHorz := 1 //% em relação a resolucao maxima
	//Verifica resolução Vertical
	If aSize[6] >= 934
		nTipoVert := 1 //1024          1
		nPorcVert := 1
	ElseIf aSize[6] >= 870
		nTipoVert := 2 //960
		nPorcVert := 0.93
	ElseIf aSize[6] >= 774
		nTipoVert := 3 //864
		nPorcVert := 0.82
	ElseIf aSize[6] >= 678
		nTipoVert := 4 //768
		nPorcVert := 0.70 //678/934
	ElseIf aSize[6] >= 630
		nTipoVert := 5 //720
		nPorcVert := 0.65
	ElseIf aSize[6] >= 510
		nTipoVert := 6 //600
		nPorcVert := 0.62
	Else
		nTipoVert := 6 //600
		nPorcVert := 0.42
	EndIf
	//Verifica resolução Horizontal
	If aSize[5] >= 1272
		nTipoHorz := 1 //1280
		nPorcHorz := 1
	ElseIf aSize[5] >= 1144
		nTipoHorz := 2 //1152
		nPorcHorz := 0.9
	ElseIf aSize[5] >= 1016
		nTipoHorz := 3 //1024
		nPorcHorz := 0.8
	Else	//If aSize[5] >= 792
		nTipoHorz := 4 //800
		nPorcHorz := 0.62
	EndIf

	// ------------- Folder -----------------
	nFolIniI := 11 * nPorcVert  //Linha Inicio
	nFolColI := 0.7             //Coluna Inicio (FIXO)
	nFolLarg := 616 * nPorcHorz //Largura
	nFolAltu := 320 * nPorcVert //Altura
	If lFlatMode .And. nTipoVert <= 4
		nFolAltu := 320 * (nPorcVert * 0.9) //Altura
	EndIf
	// ------------- Browse OS --------------
	nBOSIniI := 28              //Linha Inicio (FIXO)
	nBOSColI := 4               //Coluna Inicio (FIXO)
	nBOSLarg := 616 * nPorcHorz //Largura
	nBOSAltu := 110 * nPorcVert //Altura
	If nTipoVert == 2
		nBOSAltu := nBOSAltu * 0.98
	ElseIf nTipoVert == 3
		nBOSAltu := nBOSAltu * 0.94
	ElseIf nTipoVert == 4
		nBOSAltu := nBOSAltu * 0.90
	ElseIf nTipoVert == 5
		nBOSAltu := nBOSAltu * 0.85
	ElseIf nTipoVert == 6
		nBOSAltu := nBOSAltu * 0.80
	EndIf
	// ---------- Folder1 - Insumos ----------

	// ---------- Insumos Previstos ---------
	nIPrIniI := 1/*40 * nPorcVert*/ //Linha Inicio
	nIPrColI := 1//4               //Coluna Inicio (FIXO)
	nIPrLarg := 298 * nPorcHorz //Largura
	nIPrAltu := nFolAltu - 26   //Altura

	// --------- Insumos Realizados ---------
	nFO1IniI := 1/*40 * nPorcVert*/ //Linha Inicio
	nFO1ColI := 326 * nPorcHorz //Coluna Inicio
	nFO1Larg := 615 * nPorcHorz //Largura
	nFO1Altu := nFolAltu - 26   //Altura

	// ---------- Folder2 - Etapas ----------
	nFO2IniI := 1               //Linha Inicio (FIXO)
	nFO2ColI := 1               //Coluna Inicio (FIXO)
	nFO2Larg := 284 * nPorcHorz //Largura
	nFO2Altu := nFolAltu - 26   //Altura
	If nTipoHorz == 4
		nFO2Larg := nFO2Larg * 0.95
	EndIf
	nFZ2ColI := 328 * nPorcHorz //Coluna Inicio (FIXO)
	nFZ2Larg := nFO2Larg
	If nTipoHorz == 2
		nFZ2ColI := nFZ2ColI * 1.017
		nFZ2Larg := nFO2Larg * 0.98
	ElseIf nTipoHorz == 3
		nFZ2ColI := nFZ2ColI * 1.02
		nFZ2Larg := nFO2Larg * 0.97
	ElseIf nTipoHorz == 4
		nFZ2ColI := nFZ2ColI * 1.03
		nFZ2Larg := nFO2Larg
	EndIf
	// ------- Folder3 - Ocorrrencias -------
	nFO3IniI := 1               //Linha Inicio (FIXO)
	nFO3ColI := 1               //Coluna Inicio (FIXO)
	nFO3Larg := 612 * nPorcHorz //Largura
	nFO3Altu := nFolAltu - 26   //Altura
	// ------- Folder4 - Mot. Atrasos -------
	nFO4IniI := 1               //Linha Inicio (FIXO)
	nFO4ColI := 1               //Coluna Inicio (FIXO)
	nFO4Larg := 612 * nPorcHorz //Largura
	nFO4Altu := nFolAltu - 26   //Altura
	// ----------- Botões Centrais ----------
	nBtCeLin := 135 * nPorcVert //Linha
	nBtDista := 35
	nBtCeCol := 612 * nPorcHorz //Coluna
	If nTipoVert == 2
		nBtCeLin := nBtCeLin * 0.98
	ElseIf nTipoVert == 3
		nBtCeLin := nBtCeLin * 0.96
	ElseIf nTipoVert == 4
		nBtCeLin := nBtCeLin * 0.93
	ElseIf nTipoVert == 5
		nBtCeLin := nBtCeLin * 0.90
	ElseIf nTipoVert == 6
		nBtCeLin := nBtCeLin * 0.87
		nBtDista := 31
		nBtCeCol := nBtCeCol - 5
	EndIf

	// ----------- Botões Etapas ------------
	nBtEtLin := 11 //Linha
	nBtEtCol := 289 * nPorcHorz //Coluna
	nSalBtn  := 16
	nTamBotao := 11
	If nTipoVert == 6
		If lFlatMode .And. aSize[6] >= 600
			nSalBtn   := 10
			nTamBotao := 10
		Else
			nSalBtn   := 10
			nBtEtLin  := 2 //Linha
			nTamBotao := 9
		EndIf
	ElseIf nTipoVert == 4 .Or. nTipoVert == 5
		nSalBtn := 12
	EndIf
	If nTipoHorz == 4
		nBtEtCol := nBtEtCol * 0.96
	EndIf
	// ----------- Label TOTAL ------------
	nLaToLin := 285 * nPorcVert //Linha
	nLaToCol := 480 * nPorcHorz //Coluna

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³TudOkTN435 ³ Autor ³ Denis                ³ Data ³13/08/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Valida todos os itens da getdados de Ocorrencias            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA400                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function TudOkTN435(nPosSTN)
	Local vx := 0
	Local nOCORRE, nCAUSA, nSOLUCAO

	If aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_CODOCOR"}) == 0
		aHeader := aClone( aHoBrw3 )
		aCols   := aClone( aCoBrw3 )
	EndIf

	nOCORRE  := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_CODOCOR"})
	nCAUSA   := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_CAUSA"})
	nSOLUCAO := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_SOLUCAO"})

	If nOCORRE > 0 .And. nCAUSA > 0 .And. nSOLUCAO > 0

		For vx := 1 To Len(aCols)
			If !M400GETDO(vx)
				nPosSTN := vx
				Return .F.
			EndIf
		Next vx

	EndIf

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³LinOkTN435 ³ Autor ³ Denis                ³ Data ³13/08/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Valida a linha da getdados das ocorrencias                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA400                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LinOkTN435()
	Local nOCORRE, nCAUSA, nSOLUCAO

	If aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_CODOCOR"}) == 0
		aHeader := aClone( aHoBrw3 )
		aCols   := aClone( aCoBrw3 )
	EndIf

	nOCORRE  := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_CODOCOR"})
	nCAUSA   := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_CAUSA"})
	nSOLUCAO := aScan(aHEADER, {|x| AllTrim(Upper(X[2])) == "TN_SOLUCAO"})

	If nOCORRE > 0 .And. nCAUSA > 0 .And. nSOLUCAO > 0

		If !M400GETDO(n)
			Return .F.
		EndIf

	EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} NGSALDOES
Verifica o saldo do produto em estoque

@author Denis Hyroshi de Souza
@since 04/09/2001
@param cVcod, string, código do Produto
@param cAlmox, string, código do Almoxifado
@param nQuant, string, quantidade solicitada
@param lMensa, boolean, se mostra msg de erro
@param nLineOS, numeric, linha da Matriz aDadosOS
@param nTipoVal, numeric, tipo de verificação
		1-Saldo SB2;
		2-Saldo Sub-Lote
		3-Saldo Lote
		4-Saldo Enderecamento
@param cLoteclt, string, código do lote
@param cNumLote, string, código do SubLote
@param cLocaliz, string, código do Endereco
@param cNumseri, string, código do Numero de Serie
/*/
//-------------------------------------------------------------------
Static Function NGSALDOES(cVCOD,cALMOX,nQUANT,lMENSA,nLineOS,nTipoVal,cLOTECTL,cNUMLOTE,cLOCALIZ,cNUMSERI,dDTINICI)

	Local cALIASOLD := ALIAS()
	Local nOLDKEY   := INDEXORD()
	Local cALMOXAF  := If(Empty(cALMOX),"01",cALMOX)
	Local lOk       := .T.
	Local nXX, nYY
	Local cChvPrAlm := ""
	Local nInicial  := 0 // quant itens da O.S antes de alterações
	Local nQFinal   := 0 // quant itens da após alterações (outras linhas)
	Local nOutras   := 0 // quant itens outras O.S
	Local nSobra    := 0
	Local nQntEmp   := 0
	Local nEmpenho  := 0
	Local lVerEmp   := .T.
	Local cTpSaldo   := SuperGetMv('MV_TPSALDO', .F., 'S' )

	Private nP435Tar := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TAREFA"})
	Private nP435Tip := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Private nP435Cod := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Private nP435Loc := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"  })
	Private nP435Qtd := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_QUANTID"})
	Private nP435Sub := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMLOTE"})
	Private nP435Lot := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOTECTL"})
	Private nP435End := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCALIZ"})
	Private nP435NuS := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSERI"})
	Private nP435SqR := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
	Private nP435SqT := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQTARE"})
	Private nForXX,nForYY
	Private bChv1Alm := "''"
	Private bChv2Alm := "''"
	Private bChv3Alm := "''"

	/*-------------------------------------------------------------------------------------------------+
	| Quando existir o param. MV_MNTREQ as validações de estoque são realizadas pelo ExecAuto MATA241. |
	+-------------------------------------------------------------------------------------------------*/
	If nP435Cod == 0 .Or. nP435Tip == 0 .Or. nP435Qtd == 0 .Or. !lHasMNTREQ
		Return .T.
	EndIf

	If nTipoVal == 1 //Saldo SB2
		cChvPrAlm := cVCOD+cALMOXAF
		bChv1Alm  := "aDadosOS[nForXX,4,nForYY,nP435Cod]+aDadosOS[nForXX,4,nForYY,nP435Loc]"
		bChv2Alm  := "aDadosOS[nForXX,5,nForYY,nP435Cod]+aDadosOS[nForXX,5,nForYY,nP435Loc]"
		bChv3Alm  := "aCols[nForYY,nP435Cod]+aCols[nForYY,nP435Loc]"
	ElseIf nTipoVal == 2 //Saldo SubLote
		cChvPrAlm := cVCOD+cALMOXAF+cLOTECTL+cNUMLOTE
		bChv1Alm  := "aDadosOS[nForXX,4,nForYY,nP435Cod]+aDadosOS[nForXX,4,nForYY,nP435Loc]+aDadosOS[nForXX,4,nForYY,nP435Lot]"+;
		"+aDadosOS[nForXX,4,nForYY,nP435Sub]"
		bChv2Alm  := "aDadosOS[nForXX,5,nForYY,nP435Cod]+aDadosOS[nForXX,5,nForYY,nP435Loc]+aDadosOS[nForXX,5,nForYY,nP435Lot]"+;
		"+aDadosOS[nForXX,5,nForYY,nP435Sub]"
		bChv3Alm  := "aCols[nForYY,nP435Cod]+aCols[nForYY,nP435Loc]+aCols[nForYY,nP435Lot]+aCols[nForYY,nP435Sub]"
	ElseIf nTipoVal == 3 //Saldo Lote
		cChvPrAlm := cVCOD+cALMOXAF+cLOTECTL
		bChv1Alm  := "aDadosOS[nForXX,4,nForYY,nP435Cod]+aDadosOS[nForXX,4,nForYY,nP435Loc]+aDadosOS[nForXX,4,nForYY,nP435Lot]"
		bChv2Alm  := "aDadosOS[nForXX,5,nForYY,nP435Cod]+aDadosOS[nForXX,5,nForYY,nP435Loc]+aDadosOS[nForXX,5,nForYY,nP435Lot]"
		bChv3Alm  := "aCols[nForYY,nP435Cod]+aCols[nForYY,nP435Loc]+aCols[nForYY,nP435Lot]"
	ElseIf nTipoVal == 4 //Saldo Enderecamento
		cChvPrAlm := cVCOD+cALMOXAF+cLOCALIZ+cNUMSERI+cLOTECTL+cNUMLOTE
		bChv1Alm  := "aDadosOS[nForXX,4,nForYY,nP435Cod]+aDadosOS[nForXX,4,nForYY,nP435Loc]+aDadosOS[nForXX,4,nForYY,nP435End]"+;
		"+aDadosOS[nForXX,4,nForYY,nP435NuS]+aDadosOS[nForXX,4,nForYY,nP435Lot]+aDadosOS[nForXX,4,nForYY,nP435Sub]"
		bChv2Alm  := "aDadosOS[nForXX,5,nForYY,nP435Cod]+aDadosOS[nForXX,5,nForYY,nP435Loc]+aDadosOS[nForXX,5,nForYY,nP435End]"+;
		"+aDadosOS[nForXX,5,nForYY,nP435NuS]+aDadosOS[nForXX,5,nForYY,nP435Lot]+aDadosOS[nForXX,5,nForYY,nP435Sub]"
		bChv3Alm  := "aCols[nForYY,nP435Cod]+aCols[nForYY,nP435Loc]+aCols[nForYY,nP435End]+aCols[nForYY,nP435NuS]+"+;
		"aCols[nForYY,nP435Lot]+aCols[nForYY,nP435Sub]"
	EndIf

	nEmpenho:= 0

	//Analisa se existe retiradas do estoque na tela e desconta do saldo atual.
	//aqui nDiffOS corresponde a diferenca entre o que havia sido baixado antes de acessar a rotina e o atual
	nDiffOS := 0
	For nXX := 1 To Len(aDadosOS)
		nForXX := nXX
		If nLineOS != nXX
			If ValType(aDadosOS[nXX,4]) == "A" .And. ValType(aDadosOS[nXX,5]) == "A"
				For nYY := 1 To Len(aDadosOS[nXX,4])
					nForYY := nYY
					If aDadosOS[nXX,4,nYY,nP435Tip] == "P"
						If &(bChv1Alm) == cChvPrAlm
							nDiffOS += aDadosOS[nXX,4,nYY,nP435Qtd]
							nOutras-= aDadosOS[nXX,4,nYY,nP435Qtd]
						EndIf
					EndIf
				Next nYY
				For nYY := 1 To Len(aDadosOS[nXX,5])
					nForYY := nYY
					If aDadosOS[nXX,5,nYY,Len(aDadosOS[nXX,5,nYY])]
						Loop //Deletado
					EndIf
					If aDadosOS[nXX,5,nYY,nP435Tip] == "P"
						If &(bChv2Alm) == cChvPrAlm
							nDiffOS -= aDadosOS[nXX,5,nYY,nP435Qtd]
							nOutras += aDadosOS[nXX,5,nYY,nP435Qtd]
						EndIf
					EndIf
				Next nYY
			EndIf
		Else
			If ValType(aDadosOS[nXX,4]) == "A"
				For nYY := 1 To Len(aDadosOS[nXX,4])
					nForYY := nYY
					If aDadosOS[nXX,4,nYY,nP435Tip] == "P"
						If &(bChv1Alm) == cChvPrAlm
							nDiffOS += aDadosOS[nXX,4,nYY,nP435Qtd]
							nInicial -= aDadosOS[nXX,4,nYY,nP435Qtd]
						EndIf
					EndIf
				Next nYY
			EndIf
			For nYY := 1 To Len(aCols)
				nForYY := nYY
				If aCols[nYY,Len(aCols[nYY])]
					Loop //Deletado
				EndIf
				If aCols[nYY,nP435Tip] == "P" .And. nYY <> n
					If &(bChv3Alm) == cChvPrAlm
						nDiffOS -= aCols[nYY,nP435Qtd]
						nEmpenho+= aCols[nYY,nP435Qtd]
						nQFinal +=aCols[nYY,nP435Qtd]
					EndIf
				EndIf
			Next nYY
		EndIf
	Next nXX

	If nTipoVal == 1 //Saldo SB2

		//--------------------------------------------
		// Verifica se há necessidade de ver empenho
		//--------------------------------------------
		If lIntRM .Or. cTpSaldo != 'S' .Or. ( nQuant + nQFinal ) <= nInicial

			lVerEmp := .F.

		EndIf

		nQFinal := nQFinal + nInicial // itens da O.S sem a linha posicionada

		nQuant+= nQFinal + nOutras // quantidade real

		//------------------------------------------------------------------
		// Verifica se saldo físico do estoque atende a quantidade de itens
		//------------------------------------------------------------------
		lOk := NGSALSB2( cVCOD, cALMOX, nQuant,,, dDTINICI )

		//---------------------------------------------------------------------------------------------------------
		// Trecho abaixo verifica se tem saldo dísponível para a ordem de serviço ( se possui reserva de empenho )
		//---------------------------------------------------------------------------------------------------------
		If lOk .And. lVerEmp

			nQuant -= nOutras // total de itens da O.S
			nQntEmp := fQntEmp( cVCOD, cAlmox, aDadosOS[nLineOS,1] ) // quant. empenhada para a O.S

			//--------------------------------------------
			// Verifica se possui quantidade disponível
			//--------------------------------------------
			If nQuant > nQntEmp

				DbSelectArea('SB2')
				DbSetOrder(1)
				If !Dbseek( xFilial('SB2') + cVCOD + cAlmox )
					CriaSB2( cVCOD, cAlmox )
				EndIf

				nAmais := nQuant - nQntEmp // quantid. a mais
				nSobra := SaldoSB2( .F., .T. , dDataBase+3650, .F. ) // Saldo que está sobrando

				lOk := nSobra >= nAmais // Verifica se estoque não ficará negativo

				// ajusta valores para mostrar na msg
				If nQntEmp > 0 .And. nSobra < 0
					nSobra := nQntEmp
				ElseIf nSobra > 0
					nSobra+= nQntEmp					
				EndIf

				nAmais+= nQntEmp

				If !lOk
					//'Saldo indisponível para a ordem de serviço' #'Disponível'#Entrada#
					Help( '', 1,'NGATENCAO',, STR0395 + CRLF + STR0396 + ':' + cValToChar( nSobra ) + CRLF + STR0397 + ':' + cValToChar( nAmais ) ,4,1)

				EndIf

			EndIf

 		EndIf

	ElseIf nTipoVal == 2 //Saldo SubLote

		dbSelectArea("SB8")
		dbSetOrder(02)
		If dbSeek(xFilial("SB8")+cNUMLOTE+cLOTECTL+cVCOD+cALMOX)
			nSaldoLote := SB8Saldo(.F.,!Empty(cLOTECTL+cNUMLOTE),NIL,NIL,NIL,NIL,NIL,dDTINICI)
			nSaldoLote := nSaldoLote + nDiffOS
			If QtdComp(nSaldoLote) < QtdComp(nQUANT)
				cHelp:=STR0127+AllTrim(cVCOD)+Chr(13)+STR0169+cALMOX+Chr(13)+STR0170; //"Produto "###"Local "###"Saldo Disponível "
				+Alltrim(Transform(nSaldoLote,PesqPictQt("B8_SALDO", 14)))+Chr(13)+STR0171+Alltrim(cLOTECTL); //"Lote "
				+Chr(13)+STR0172+Alltrim(cNUMLOTE) //"Sub-lote "
				Help(" ",1,"A240LOTENE",,cHelp,4,1)
				lOk := .F.
			EndIf
		Else
			Help(" ",1,"NGATENCAO",,STR0195+Chr(13)+Chr(10)+; //"Numero do sub-lote não corresponde ao produto que foi "
			STR0196,3,1) //" informado. Digite um sub-lote correspondente."
			lOk := .F.
		EndIf

	ElseIf nTipoVal == 3 //Saldo Lote

		dbSelectArea("SB8")
		dbSetOrder(03)
		If dbSeek(xFilial("SB8")+cVCOD+cALMOX+cLOTECTL)
			nSaldoLote := SaldoLote(cVCOD,cALMOX,cLOTECTL,NIL,.F.,!Empty(cLOTECTL+cNUMLOTE),NIL,dDTINICI)
			nSaldoLote := nSaldoLote + nDiffOS
			If QtdComp(nSaldoLote) < QtdComp(nQUANT)
				cHelp:=STR0127+AllTrim(cVCOD)+Chr(13)+STR0169+cALMOX+Chr(13)+STR0170; //"Produto "###"Local "###"Saldo Disponível "
				+Alltrim(Transform(nSaldoLote,PesqPictQt("B8_SALDO", 14)))+Chr(13)+STR0171+Alltrim(cLOTECTL) //"Lote "
				Help(" ",1,"A240LOTENE",,cHelp,4,1)
				lOk := .F.
			EndIf
		Else
			Help(" ",1,"NGATENCAO",,STR0197+Chr(13)+Chr(10)+; //"Numero do lote não corresponde ao produto que foi "
			STR0198,3,1) //" informado. Digite um lote correspondente."
			lOk := .F.
		EndIf

	ElseIf nTipoVal == 4 //Saldo Enderecamento
		If (aCols[n,nP435Cod] + aCols[n,nP435Loc] + aCols[n,nP435End] + aCols[nForYY,nP435NuS]+aCols[nForYY,nP435Lot]+aCols[nForYY,nP435Sub] == cChvPrAlm);
		.And. aCols[n,nP435SqR] > "0"
			nEmpenho += aCols[n,nP435Qtd]
		EndIf
		nSaldoLote := SaldoSBF(cALMOX,cLOCALIZ,cVCOD,cNUMSERI,cLOTECTL,cNUMLOTE,.F.)
		nSaldoLote := nSaldoLote + nDiffOS + nEmpenho
		If QtdComp(nSaldoLote) < QtdComp(nQUANT)
			Help(" ",1,"SALDOLOCLZ")
			lOk := .F.
		EndIf
	EndIf

	dbSelectArea(cALIASOLD)
	dbSetOrder(nOLDKEY)

Return lOk

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³GetNomeTip ³ Autor ³ Denis                ³ Data ³13/08/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Retorna nome do tipo de insumo                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA400                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function GetNomeTip(cTIPREG)
	Local cRet := Space(15)

	If cTIPREG == "M"
		cRet := "Mao de obra"
	ElseIf cTIPREG == "P"
		cRet := "Produto"
	ElseIf cTIPREG == "F"
		cRet := "Ferramenta"
	ElseIf cTIPREG == "T"
		cRet := "Terceiros"
	ElseIf cTIPREG == "E"
		cRet := "Especialidade"
	EndIf

Return cRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ f435VlFun ³ Autor ³ Denis                ³ Data ³13/08/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Valida intervalo dos insumos Mao de Obra temporario        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA400                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function f435VlFun(cTmpCod,cTmpOrdem,cTmpPlano,dTmpDtIni,cTmpHoIni,dTmpDtFim,cTmpHoFim,nLineOS,nPosCols,cTipoSTL,lRowCall)
	Local lRet := .T.
	Local nYY, nXX, nXArq
	Local nPosTip := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPosCod := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPos02 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTINICI"})
	Local nPos03 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOINICI"})
	Local nPos04 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_DTFIM" })
	Local nPos05 := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_HOFIM" })
	Local aVRET  := {.F.," "}
	Local vARQSTL := {}
	Local nQUATISH4 := 0
	Local nQUATFEU  := 1
	Local cOldAlias := Alias()
	Local cAlsTTL   := ''
	Local aAreaSTJ  := STJ->(GetArea())

	Local cAliasQry := ''

	aAdd( vARQSTL , {"STL",8,"STL->TL_FILIAL","STL->TL_CODIGO",;
	"STL->TL_SEQRELA","STL->TL_ORDEM",;
	"STL->TL_PLANO","STL->TL_DTINICI",;
	"STL->TL_DTFIM","STL->TL_HOINICI",;
	"STL->TL_HOFIM","STL->TL_TIPOREG","STL->TL_QUANREC"} )
	aAdd( vARQSTL , {"STT",3,"STT->TT_FILIAL","STT->TT_CODIGO",;
	"STT->TT_SEQRELA","STT->TT_ORDEM",;
	"STT->TT_PLANO","STT->TT_DTINICI",;
	"STT->TT_DTFIM","STT->TT_HOINICI",;
	"STT->TT_HOFIM","STT->TT_TIPOREG","STT->TT_QUANREC"})

	If cTipoSTL == "F"
		dbSelectArea("SH4")
		dbSetOrder(1)
		If dbSeek(xFilial("SH4")+SubStr(cTmpCod,1,6))
			nQUATISH4 := SH4->H4_QUANT
		EndIf

	ElseIf cTipoSTL == 'M'

		cAlsTTL := GetNextAlias()

		BeginSql Alias cAlsTTL

			SELECT
				TTL.TTL_DTINI,
				TTL.TTL_HRINI,
				TTL.TTL_DTFIM,
				TTL.TTL_HRFIM
			FROM
				%table:TTL% TTL
			WHERE
				TTL.TTL_CODFUN = %exp:cTmpCod% AND
				( ( %exp:dToS( dTmpDtIni )% || %exp:cTmpHoIni% <= TTL.TTL_DTFIM || TTL.TTL_HRFIM ) AND
				  ( %exp:dToS( dTmpDtFim )% || %exp:cTmpHoFim% >= TTL.TTL_DTINI || TTL.TTL_HRINI ) ) AND
				TTL.TTL_FILIAL = %xFilial:TTL% AND
				%NotDel%

		EndSql

		If (cAlsTTL)->( !EoF() )

			cHelpMsg := STR0204 + Chr( 13 ) + Chr( 13 ) +; // Já existe aplicação de insumo no intervalo de Data/Hora informada.
						STR0205 + ': ' + cTmpCod + Chr( 13 ) +; // Código Insumo
						STR0206 + '....: ' + cTmpOrdem + Chr( 13 ) +; // Ordem Serv
						STR0050 + '..............: ' + cTmpPlano + Chr( 13 ) +; // Plano
						STR0200 + '......: ' + dToC( dTmpDtIni ) + Chr( 13 ) +; // Data Inicio
						STR0201 + '......: ' + SubStr( cTmpHoIni, 1, 5 ) + Chr( 13 ) +; // Hora Inicio
						STR0202 + '.........: ' + dToC( dTmpDtFim ) + Chr( 13 ) +; // Data Fim
						STR0203 + '.........: ' + SubStr( cTmpHoFim, 1, 5 ) + Chr( 13 ) + Chr( 13 ) +; // Hora Fim
						STR0387 + Chr( 13 ) + Chr( 13 ) +; // Aplicação do insumo já existente:
						STR0200 + '.....: ' + dToC( sToD( (cAlsTTL)->TTL_DTINI ) ) + Chr( 13 ) +; // Data Inicio
						STR0201 + '.....: ' + SubStr( (cAlsTTL)->TTL_HRINI, 1, 5 ) + Chr( 13 ) +; // Hora Inicio
						STR0202 + '........: ' + dToC( sToD( (cAlsTTL)->TTL_DTFIM ) ) + Chr( 13 ) +; // Data Fim
						STR0203 + '........: ' + SubStr( (cAlsTTL)->TTL_HRFIM, 1, 5 ) // Hora Fim

			aVRet := { .T., cHelpMsg }

		EndIf

		(cAlsTTL)->( dbCloseArea() )

	EndIf

	If !aVRET[1]

		For nXX := 1 To Len(aDadosOS)

			If nLineOS != nXX .Or. !lRowCall
				If ValType(aDadosOS[nXX,5]) == "A"
					For nYY := 1 To Len(aDadosOS[nXX,5])
						If aDadosOS[nXX,5][nYY,Len(aDadosOS[nXX,5][nYY])]
							Loop //Deletado
						EndIf
						If !lRowCall
							If nLineOS == nXX .And. nPosCols == nYY
								Loop
							EndIf
						EndIf
						If aDadosOS[nXX,5,nYY,nPosTip] == cTipoSTL .And. PadR(aDadosOS[nXX,5,nYY,nPosCod],nLenST1) == Padr(cTmpCod,nLenST1)
							If aDadosOS[nXX,5][nYY,nPos02] == dTmpDtIni .And. aDadosOS[nXX,5][nYY,nPos03] == cTmpHoIni .And. ;
							aDadosOS[nXX,5][nYY,nPos04] == dTmpDtFim .And. aDadosOS[nXX,5][nYY,nPos05] == cTmpHoFim

								If cTipoSTL == "M"
									aVRET := {.T.,STR0167} //"Registro informado ja existe"
									Exit
								ElseIf cTipoSTL == "F"
									nQUATFEU++
									If nQUATFEU > nQUATISH4
										cHelpMsg := STR0199 + chr(13)+chr(13); //"Não há disponibilidade da ferramenta no intervalo:"
										+STR0200 + ".....: " + dtoc(dTmpDtIni)+chr(13); //"Data Inicio"
										+STR0201 + ".....: " + Substr(cTmpHoIni,1,5)+chr(13); //"Hora Inicio"
										+STR0202 + "........: " + dtoc(dTmpDtFim)+chr(13); //"Data Fim"
										+STR0203 + "........: " + Substr(cTmpHoFim,1,5) //"Hora Fim"
										aVRET := {.T.,cHelpMsg}
										Exit
									EndIf
								EndIf

							ElseIf DtoS(dTmpDtIni)+cTmpHoIni < DtoS(aDadosOS[nXX,5][nYY,nPos04])+aDadosOS[nXX,5][nYY,nPos05] .And.;
							DtoS(dTmpDtFim)+cTmpHoFim > DtoS(aDadosOS[nXX,5][nYY,nPos02])+aDadosOS[nXX,5][nYY,nPos03]

								If cTipoSTL == "M"
									cHelpMsg := STR0204+ chr(13)+chr(13); //"Já existe aplicação de insumo no intervalo de Data/Hora informada."
									+ STR0205 + ": " + cTmpCod + chr(13); //"Código Insumo"
									+ STR0206 + "....: " + cTmpOrdem + chr(13); //"Ordem Serv"
									+ STR0050 + "..............: " + cTmpPlano + chr(13); //"Plano"
									+ STR0200 + "......: " + dtoc(dTmpDtIni) + chr(13); //"Data Inicio"
									+ STR0201 + "......: " + Substr(cTmpHoIni,1,5) + chr(13); //"Hora Inicio"
									+ STR0202 + ".........: " + dtoc(dTmpDtFim) + chr(13); //"Data Fim"
									+ STR0203 + ".........: " + Substr(cTmpHoFim,1,5) + chr(13)+chr(13); //"Hora Fim"
									+ STR0207 + chr(13)+chr(13); //"Aplicação do insumo já existente:"
									+ STR0206 + "....: " + aDadosOS[nXX,1] + chr(13); //"Ordem Serv"
									+ STR0050 + ".............: " + aDadosOS[nXX,2] + chr(13); //"Plano"
									+ STR0200 + ".....: " + dtoc(aDadosOS[nXX,5][nYY,nPos02]) + chr(13); //"Data Inicio"
									+ STR0201 + ".....: " + Substr(aDadosOS[nXX,5][nYY,nPos03],1,5) + chr(13); //"Hora Inicio"
									+ STR0202 + "........: " + dtoc(aDadosOS[nXX,5][nYY,nPos04]) + chr(13); //"Data Fim"
									+ STR0203 + "........: " + Substr(aDadosOS[nXX,5][nYY,nPos05],1,5) //"Hora Fim"
									aVRET := {.T.,cHelpMsg}
									Exit
								ElseIf cTipoSTL == "F"
									nQUATFEU++
									If nQUATFEU > nQUATISH4
										cHelpMsg := STR0199 + chr(13)+chr(13); //"Não há disponibilidade da ferramenta no intervalo:"
										+STR0200 + ".....: " + dtoc(dTmpDtIni)+chr(13); //"Data Inicio"
										+STR0201 + ".....: " + Substr(cTmpHoIni,1,5)+chr(13); //"Hora Inicio"
										+STR0202 + "........: " + dtoc(dTmpDtFim)+chr(13); //"Data Fim"
										+STR0203 + "........: " + Substr(cTmpHoFim,1,5) //"Hora Fim"
										aVRET := {.T.,cHelpMsg}
										Exit
									EndIf
								EndIf
							EndIf
						EndIf
					Next nYY
				ElseIf ValType(aDadosOS[nXX,4]) == "A" .And. lRowCall
					For nYY := 1 To Len(aDadosOS[nXX,4])
						If aDadosOS[nXX,4][nYY,Len(aDadosOS[nXX,4][nYY])]
							Loop //Deletado
						EndIf
						If aDadosOS[nXX,4,nYY,nPosTip] == cTipoSTL .And. PadR(aDadosOS[nXX,4,nYY,nPosCod],nLenST1) == PadR(cTmpCod,nLenST1)
							If aDadosOS[nXX,4][nYY,nPos02] == dTmpDtIni .And. aDadosOS[nXX,4][nYY,nPos03] == cTmpHoIni .And. ;
							aDadosOS[nXX,4][nYY,nPos04] == dTmpDtFim .And. aDadosOS[nXX,4][nYY,nPos05] == cTmpHoFim

								If cTipoSTL == "M"
									aVRET := {.T.,STR0167} //"Registro informado ja existe"
									Exit
								ElseIf cTipoSTL == "F"
									nQUATFEU++
									If nQUATFEU > nQUATISH4
										cHelpMsg := STR0199 + chr(13)+chr(13); //"Não há disponibilidade da ferramenta no intervalo:"
										+STR0200 + ".....: " + dtoc(dTmpDtIni)+chr(13); //"Data Inicio"
										+STR0201 + ".....: " + Substr(cTmpHoIni,1,5)+chr(13); //"Hora Inicio"
										+STR0202 + "........: " + dtoc(dTmpDtFim)+chr(13); //"Data Fim"
										+STR0203 + "........: " + Substr(cTmpHoFim,1,5) //"Hora Fim"
										aVRET := {.T.,cHelpMsg}
										Exit
									EndIf
								EndIf

							ElseIf DtoS(dTmpDtIni)+cTmpHoIni < DtoS(aDadosOS[nXX,4][nYY,nPos04])+aDadosOS[nXX,4][nYY,nPos05] .And.;
							DtoS(dTmpDtFim)+cTmpHoFim > DtoS(aDadosOS[nXX,4][nYY,nPos02])+aDadosOS[nXX,4][nYY,nPos03]

								If cTipoSTL == "M"
									cHelpMsg := STR0204+ chr(13)+chr(13); //"Já existe aplicação de insumo no intervalo de Data/Hora informada."
									+ STR0205 + ": " + cTmpCod + chr(13); //"Código Insumo"
									+ STR0206 + "....: " + cTmpOrdem + chr(13); //"Ordem Serv"
									+ STR0050 + "..............: " + cTmpPlano + chr(13); //"Plano"
									+ STR0200 + "......: " + dtoc(dTmpDtIni) + chr(13); //"Data Inicio"
									+ STR0201 + "......: " + Substr(cTmpHoIni,1,5) + chr(13); //"Hora Inicio"
									+ STR0202 + ".........: " + dtoc(dTmpDtFim) + chr(13); //"Data Fim"
									+ STR0203 + ".........: " + Substr(cTmpHoFim,1,5) + chr(13)+chr(13); //"Hora Fim"
									+ STR0207 + chr(13)+chr(13); //"Aplicação do insumo já existente:"
									+ STR0206 + "....: " + aDadosOS[nXX,1] + chr(13); //"Ordem Serv"
									+ STR0050 + ".............: " + aDadosOS[nXX,2] + chr(13); //"Plano"
									+ STR0200 + ".....: " + dtoc(aDadosOS[nXX,4][nYY,nPos02]) + chr(13); //"Data Inicio"
									+ STR0201 + ".....: " + Substr(aDadosOS[nXX,4][nYY,nPos03],1,5) + chr(13); //"Hora Inicio"
									+ STR0202 + "........: " + dtoc(aDadosOS[nXX,4][nYY,nPos04]) + chr(13); //"Data Fim"
									+ STR0203 + "........: " + Substr(aDadosOS[nXX,4][nYY,nPos05],1,5) //"Hora Fim"
									aVRET := {.T.,cHelpMsg}
									Exit
								ElseIf cTipoSTL == "F"
									nQUATFEU++
									If nQUATFEU > nQUATISH4
										cHelpMsg := STR0199 + chr(13)+chr(13); //"Não há disponibilidade da ferramenta no intervalo:"
										+STR0200 + ".....: " + dtoc(dTmpDtIni)+chr(13); //"Data Inicio"
										+STR0201 + ".....: " + Substr(cTmpHoIni,1,5)+chr(13); //"Hora Inicio"
										+STR0202 + "........: " + dtoc(dTmpDtFim)+chr(13); //"Data Fim"
										+STR0203 + "........: " + Substr(cTmpHoFim,1,5) //"Hora Fim"
										aVRET := {.T.,cHelpMsg}
										Exit
									EndIf
								EndIf
							EndIf
						EndIf
					Next nYY
				EndIf
			Else
				For nYY := 1 To Len(aCols)
					If aCols[nYY,Len(aCols[nYY])]
						Loop //Deletado
					EndIf
					If aCols[nYY,nPosTip] == cTipoSTL .And. nYY <> nPosCols .And. PadR(aCols[nYY,nPosCod],nLenST1) == PadR(cTmpCod,nLenST1)
						If aCols[nYY,nPos02] == dTmpDtIni .And. aCols[nYY,nPos03] == cTmpHoIni .And. ;
						aCols[nYY,nPos04] == dTmpDtFim .And. aCols[nYY,nPos05] == cTmpHoFim

							If cTipoSTL == "M"
								aVRET := {.T.,STR0167} //"Registro informado ja existe"
								Exit
							ElseIf cTipoSTL == "F"
								nQUATFEU++
								If nQUATFEU > nQUATISH4
									cHelpMsg := STR0199 + chr(13)+chr(13); //"Não há disponibilidade da ferramenta no intervalo:"
									+STR0200 + ".....: " + dtoc(dTmpDtIni)+chr(13); //"Data Inicio"
									+STR0201 + ".....: " + Substr(cTmpHoIni,1,5)+chr(13); //"Hora Inicio"
									+STR0202 + "........: " + dtoc(dTmpDtFim)+chr(13); //"Data Fim"
									+STR0203 + "........: " + Substr(cTmpHoFim,1,5) //"Hora Fim"
									aVRET := {.T.,cHelpMsg}
									Exit
								EndIf
							EndIf

						ElseIf DtoS(dTmpDtIni)+cTmpHoIni < DtoS(aCols[nYY,nPos04])+aCols[nYY,nPos05] .And.;
						DtoS(dTmpDtFim)+cTmpHoFim > DtoS(aCols[nYY,nPos02])+aCols[nYY,nPos03]

							If cTipoSTL == "M"
								cHelpMsg := STR0204+ chr(13)+chr(13); //"Já existe aplicação de insumo no intervalo de Data/Hora informada."
								+ STR0205 + ": " + cTmpCod + chr(13); //"Código Insumo"
								+ STR0206 + "....: " + cTmpOrdem + chr(13); //"Ordem Serv"
								+ STR0050 + "..............: " + cTmpPlano + chr(13); //"Plano"
								+ STR0200 + "......: " + dtoc(dTmpDtIni) + chr(13); //"Data Inicio"
								+ STR0201 + "......: " + Substr(cTmpHoIni,1,5) + chr(13); //"Hora Inicio"
								+ STR0202 + ".........: " + dtoc(dTmpDtFim) + chr(13); //"Data Fim"
								+ STR0203 + ".........: " + Substr(cTmpHoFim,1,5) + chr(13)+chr(13); //"Hora Fim"
								+ STR0207 + chr(13)+chr(13); //"Aplicação do insumo já existente:"
								+ STR0206 + "....: " + cTmpOrdem + chr(13); //"Ordem Serv"
								+ STR0050 + ".............: " + cTmpPlano + chr(13); //"Plano"
								+ STR0200 + ".....: " + dtoc(aCols[nYY,nPos02]) + chr(13); //"Data Inicio"
								+ STR0201 + ".....: " + Substr(aCols[nYY,nPos03],1,5) + chr(13); //"Hora Inicio"
								+ STR0202 + "........: " + dtoc(aCols[nYY,nPos04]) + chr(13); //"Data Fim"
								+ STR0203 + "........: " + Substr(aCols[nYY,nPos05],1,5) //"Hora Fim"
								aVRET := {.T.,cHelpMsg}
								Exit
							ElseIf cTipoSTL == "F"
								nQUATFEU++
								If nQUATFEU > nQUATISH4
									cHelpMsg := STR0199 + chr(13)+chr(13); //"Não há disponibilidade da ferramenta no intervalo:"
									+STR0200 + ".....: " + dtoc(dTmpDtIni)+chr(13); //"Data Inicio"
									+STR0201 + ".....: " + Substr(cTmpHoIni,1,5)+chr(13); //"Hora Inicio"
									+STR0202 + "........: " + dtoc(dTmpDtFim)+chr(13); //"Data Fim"
									+STR0203 + "........: " + Substr(cTmpHoFim,1,5) //"Hora Fim"
									aVRET := {.T.,cHelpMsg}
									Exit
								EndIf
							EndIf
						EndIf
					EndIf
				Next nYY
			EndIf

			If aVRET[1]
				Exit
			EndIf
		Next nXX

	EndIf

	If !aVRET[1]
		For nXArq := 1 to 2
			If nXArq == 1

				cAliasQry	:= GetNextAlias()
				cQuery		:= " SELECT STL.TL_ORDEM,"
				cQuery		+= "	STL.TL_PLANO, "
				cQuery		+= "    STL.TL_DTINICI, "
				cQuery		+= "    STL.TL_HOINICI, "
				cQuery		+= "    STL.TL_DTFIM, "
				cQuery		+= "    STL.TL_HOFIM, "
				cQuery		+= "    STL.TL_TIPOREG "	
				cQuery		+= " FROM " +RetSqlName("STL")+ " STL "
				cQuery		+= " JOIN " + RetSqlName("STJ")+" STJ ON  STL.TL_ORDEM = STJ.TJ_ORDEM "
				cQuery		+= " AND STL.TL_PLANO = STJ.TJ_PLANO AND STJ.D_E_L_E_T_ <> '*' "
				cQuery		+= " WHERE STL.TL_FILIAL = '" +xFilial("STL")+ "' "
				cQuery		+= " AND (STL.TL_TIPOREG = 'M' OR  STL.TL_TIPOREG = 'F') "
				cQuery		+= " AND STL.TL_CODIGO = '"+cTmpCod+ "'"
				cQuery		+= " AND ( '" +DtoS(dTmpDtIni)+cTmpHoIni+ "' < (STL.TL_DTFIM || STL.TL_HOFIM)
				cQuery		+= "	AND  '"+DtoS(dTmpDtFim)+cTmpHoFim+ "' >  (STL.TL_DTINICI || STL.TL_HOINICI) )
				cQuery		+= " AND STJ.TJ_SITUACA <> 'C'
				cQuery		+= " AND STL.TL_SEQRELA <> '0'
				cQuery		+= " AND STL.D_E_L_E_T_<> '*' "

			Else

				cAliasQry	:= GetNextAlias()

				cQuery		:= " SELECT STT.TT_ORDEM TL_ORDEM,"
				cQuery		+= "	STT.TT_PLANO TL_PLANO, "
				cQuery		+= "    STT.TT_DTINICI TL_DTINICI, "
				cQuery		+= "    STT.TT_HOINICI TL_HOINICI, "
				cQuery		+= "    STT.TT_DTFIM TL_DTFIM, "
				cQuery		+= "    STT.TT_HOFIM TL_HOFIM, "
				cQuery		+= "    STT.TT_TIPOREG TL_TIPOREG "	
				cQuery		+= " FROM " +RetSqlName("STT")+ " STT "
				cQuery		+= " JOIN " + RetSqlName("STS")+" STS ON  STT.TT_ORDEM = STS.TS_ORDEM "
				cQuery		+= " AND STT.TT_PLANO = STS.TS_PLANO AND STT.D_E_L_E_T_ <> '*' "
				cQuery		+= " WHERE STT.TT_FILIAL = '" +xFilial("STT")+ "' "
				cQuery		+= " AND (STT.TT_TIPOREG = 'M' OR  STT.TT_TIPOREG = 'F') "
				cQuery		+= " AND STT.TT_CODIGO = '"+cTmpCod+ "'"
				cQuery		+= " AND ( '" +DtoS(dTmpDtIni)+cTmpHoIni+ "' < (STT.TT_DTFIM || STT.TT_HOFIM)
				cQuery		+= "	AND  '"+DtoS(dTmpDtFim)+cTmpHoFim+ "' >  (STT.TT_DTINICI || STT.TT_HOINICI) )
				cQuery		+= " AND STS.TS_SITUACA <> 'C'
				cQuery		+= " AND STT.TT_SEQRELA <> '0'
				cQuery		+= " AND STT.D_E_L_E_T_<> '*' "

			EndIf

			cQuery		:= ChangeQuery( cQuery )
			dbUseArea(	.T., "TOPCONN", TCGENQRY( , , cQuery ), cAliasQry, .F., .T. )

			While !Eof()

				nLineTmp := aScan(aDadosOS, {|x| x[1]+x[2] == (cAliasQry)->TL_ORDEM+(cAliasQry)->TL_PLANO })
				If nLineTmp > 0
					If lRowCall
						If ValType(aDadosOS[nLineTmp,4]) == "A" .Or. ValType(aDadosOS[nLineTmp,5]) == "A" .Or. nLineOS == nLineTmp
							dbSelectArea(cAliasQry)
							dbSkip()
							Loop
						EndIf
					Else
						If ValType(aDadosOS[nLineTmp,5]) == "A" .Or. nLineOS == nLineTmp
							dbSelectArea(cAliasQry)
							dbSkip()
							Loop
						EndIf
					EndIf
				EndIf

				If (cAliasQry)->TL_TIPOREG == "M"

					cHelpMsg := STR0204+ chr(13)+chr(13); //"Já existe aplicação de insumo no intervalo de Data/Hora informada."
					+ STR0205 + ": " + cTmpCod + chr(13); //"Código Insumo"
					+ STR0206 + "....: " + cTmpOrdem + chr(13); //"Ordem Serv"
					+ STR0050 + "..............: " + cTmpPlano + chr(13); //"Plano"
					+ STR0200 + "......: " + dtoc(dTmpDtIni) + chr(13); //"Data Inicio"
					+ STR0201 + "......: " + Substr(cTmpHoIni,1,5) + chr(13); //"Hora Inicio"
					+ STR0202 + ".........: " + dtoc(dTmpDtFim) + chr(13); //"Data Fim"
					+ STR0203 + ".........: " + Substr(cTmpHoFim,1,5) + chr(13)+chr(13); //"Hora Fim"
					+ STR0207 + chr(13)+chr(13); //"Aplicação do insumo já existente:"
					+ STR0206 + "....: " + (cAliasQry)->TL_ORDEM + chr(13); //"Ordem Serv"
					+ STR0050 + ".............: " + (cAliasQry)->TL_PLANO + chr(13); //"Plano"
					+ STR0200 + ".....: " + dtoc(StoD((cAliasQry)->TL_DTINICI)) + chr(13); //"Data Inicio"
					+ STR0201 + ".....: " + Substr((cAliasQry)->TL_HOINICI,1,5) + chr(13); //"Hora Inicio"
					+ STR0202 + "........: " + dtoc(StoD((cAliasQry)->TL_DTFIM)) + chr(13); //"Data Fim"
					+ STR0203 + "........: " + Substr((cAliasQry)->TL_HOFIM,1,5) //"Hora Fim"
					aVRET := {.T.,cHelpMsg}
					Exit
				ElseIf (cAliasQry)->TL_TIPOREG == "F"
					nQUATFEU++
					If nQUATFEU > nQUATISH4
						cHelpMsg := STR0199 + chr(13)+chr(13); //"Não há disponibilidade da ferramenta no intervalo:"
						+STR0200 + ".....: " + dtoc(dTmpDtIni)+chr(13); //"Data Inicio"
						+STR0201 + ".....: " + Substr(cTmpHoIni,1,5)+chr(13); //"Hora Inicio"
						+STR0202 + "........: " + dtoc(dTmpDtFim)+chr(13); //"Data Fim"
						+STR0203 + "........: " + Substr(cTmpHoFim,1,5) //"Hora Fim"
						aVRET := {.T.,cHelpMsg}
						Exit
					EndIf
				EndIf

				dbSelectArea( cAliasQry )
				dbSkip()
			End

			If aVRET[1]
				Exit
			EndIf

			(cAliasQry)->( DbCloseArea() )

		Next nXArq
	EndIf

	If aVRET[1]
		MsgInfo(aVRET[2],STR0037) //"Atenção"
		lRet := .F.
	EndIf

	PutFileInEof("STL")
	RestArea(aAreaSTJ)
	dbSelectArea(cOldAlias)
Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ Mnt435Rod ³ Autor ³ Denis Hyroshi        ³ Data ³22/06/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Abre programa de rodizio da estrutura                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA400                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Mnt435Rod()
	Local cBEMPAI := cCdBemTJ
	Local aOldHea := aClone(aHeader)
	Local aOldRot := aClone(aRotina)
	Local aOldCol := aClone(aCols)
	Local cOrdem, cPlano

	If Len(aOS) > 0
		cOrdem := aOS[oOS:nAt,nPosOS]
		cPlano := aOS[oOS:nAt,nPosPL]
		dbSelectArea("STJ")
		dbSetOrder(01)
		If dbSeek(xFilial("STJ")+cOrdem+cPlano)
			dbSelectarea("STC")
			dbSetOrder(1)
			If !dbSeek(xFilial("STC")+cBEMPAI)
				Help(" ",1,"NGMBNEXEST")
			Else
				MNTA098(cBEMPAI)
			EndIf
		Else
			MsgInfo(STR0099) //"Nenhuma ordem de serviço foi selecionada."
		EndIf
	EndIf

	aHeader := aClone(aOldHea)
	aRotina := aClone(aOldRot)
	aCols   := aClone(aOldCol)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA435BAR
Altera o menu de opções

@return

@sample MNTA435BAR(oDlg,bOk,bCancel)
@param 	oDlg	, Objeto			, Tela principal
		bOk		, Bloco de código	, Ações a serem realizadas ao acionar o botão Ok
		bCancel	, Bloco de código	, Ações a serem realizadas ao acionar o botão Cancelar

@author Alexandre Santos
@since 05/07/2017
/*/
//---------------------------------------------------------------------
Static Function MNTA435BAR(oDlg,bOk,bCancel)
	Local oBar
	Local lPyme 	:= Iif(Type("__lPyme") <> "U",__lPyme,.F.)
	Local aButton 	:= {}
	Local aBtn 		:= {}
	Local aTemp 	:= {}
	Local nX 		:= 0
	Local lCCivil	:= GetNewPar("MV_NGMNTCC","N") == "S"
	Local bValidFin := {|| IIf( fValidOk(.F.,.T.), ( NGLostFocus(), Mnt435Fin() ), )} // Bloco de código para validar isumos ao finalizar O.S.

	DEFINE BUTTONBAR oBar SIZE 40,40 TOP OF oDlg

	/*
		aButton[x][1] = Resource
		aButton[x][2] = Bloco de código definindo ação do botão
		aButton[x][3] = Descrição do botão
		aButton[x][4] = Nome do objeto botão
		aButton[x][5] = Visivel/Invisivel
	*/
	aButton := {;
					{"S4WB008N"			, {||Calculadora()}				, STR0209,			"oBtCalc", .T.},; //"Calc"###"Calculadora"
					{"S4WB010N"			, {||OurSpool()}				, STR0210,			"oBtSpl" , "" },; //Spool
					{"S4WB016N"			, {||HelProg()}					, STR0211,			"oBtAjd" , "" },; //Ajuda
					{"BMPVISUAL"		, {||NGLostFocus(), Mnt435Vis()}, STR0212,			"oBtVsl" , "" },; //"Visualizar"###"Visualizar Ordem de Serviço"
					{"PMSPRINT"			, {||NGLostFocus(), Mnt435rel()}, STR0214,			"oBtImp" , "" },; //"Imprimir"###"Imprimir Ordem de Serviço"
					{"DESTINOS" 		, {||NGLostFocus(), Mnt435Rod()}, STR0216,			"oBtRdz" , "" },; //"Rodízio"###"Rodízio da Estrutura"
					{"AVGARMAZEM"		, {||NGLostFocus(), Mnt435Rat()}, STR0218,			"oBtRto", lArvoreLogica},; //"Rateio"###"Rateio de Insumos"
					{"BPMSDOCE"			, {||NGLostFocus(), Mnt435Can()}, STR0220,			"oBtCOS" , "" },; //"Canc. O.S"###"Cancelar Ordem de Serviço"
					{"SDUSETDEL"		, {||Eval(bValidFin)		   }, STR0222,			"oBtFOS" , "" },; //"Finaliz. O.S"###"Finalizar Ordem de Serviço"
					{"NG_ICO_LEGENDA"	, {||NGLostFocus(), Mnt435Leg()}, STR0223,			"oBtLgd" , "" },; //"Legenda"###"Legenda das Ordens de Serviço"
					{"SSFONTES"			, {||Mnt435bCon()}				, STR0225,			"oBtBCn", lPyme},; //"Conhecim."###"Banco de Conhecimento da Ordem de Serviço"
					{"SALVAR"			, {||Eval(bSalvar)}				, STR0226,			"oBtGrv", lArvoreLogica},; //"Gravar"###"Grava as informações"
					{"NG_ICO_ALTBEMM"	, {||NGLostFocus(), MNT435MR()}	, STR0329,			"oBtRMR", lCCivil},; //"Medição Material Rodante"
					{"OK"				, {||Eval(bOk)}					, "Ok - <Ctrl-O>",	"oBtOK"	 , "" },;
					{"CANCEL"			, {||Eval(bCancel)}				, STR0227,			"oBtCan" , "" }; //"Cancelar"###"Cancelar - <Ctrl-X>"
				}

	//Ponto de Entrada para adicionar um botão especifico na EnchoiceBar
	If ExistBlock("MNTA4351")
		aBtn := ExecBlock("MNTA4351",.F.,.F.)
		If Len(aBtn) > 0

			//Adiciona o botão especifico antes do botão OK
			AAdd(aButton, {aBtn[1], {||NGLostFocus(), Eval(aBtn[2])}, aBtn[4], "oBtPEt", ""})
			aTemp := ATail(aButton)
			AIns(aButton, 13)
			aButton[13] := aTemp

		EndIf
	EndIf

	//Ponto de entrada para selecionar os botões que iram ser apresentados na EnchoiceBar
	If ExistBlock("MNTA435J")
		aButton := aClone(ExecBlock("MNTA435J",.F.,.F.,{aButton}))
	EndIf

	For nX := 1 To Len(aButton)

		//Define propriedades de cada botão informado no aButton
		DEFINE BUTTON &(aButton[nX][4]) RESOURCE aButton[nX,1] OF oBar PROMPT "" TOOLTIP aButton[nX,3]
		&(aButton[nX][4]):bLClicked := aButton[nX][2]
		&(aButton[nX][4]):lVisible := If(!Empty(aButton[nX][5]), aButton[nX][5], .T.)

		If !lArvoreLogica .And. (aButton[nX][4] == "oBtRdz" .Or. aButton[nX][4] == "oBtCOS" .Or. aButton[nX][4] == "oBtFOS" .Or.;
			aButton[nX][4] == "oBtBCn" .Or.	aButton[nX][4] == "oBtGrv")
			&(aButton[nX][4]):Disable()
		EndIf

		If aButton[nX][4] == "oBtOk"
			SetKEY(15,oBtOk:bAction)
		EndIf

		If aButton[nX][4] == "oBtCan"
			SetKEY(24,oBtCan:bAction)
		EndIf
	Next nX

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNT435RAT ³ Autor ³Vitor Emanuel Batista  ³ Data ³31/07/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Faz a chamada para o Rateio de insumos                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA435                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Mnt435Rat()

	Local aArea := GetArea()

	If LoadRegAOS("",1,.T.,.T.,0) //LoadRegAOS("",nOrdem435+1,.T.,.T.,0)
		MNTA402()
		If(oOS:ColPos > 0)
			LoadRegAOS("",nOrdem435,.T.,.F.,1)
			LoadRegAOS(RTrim(cChave435), nOrdem435, .F., .F., 0)
			FilSTJ435(nOrdem435,1)
		EndIf
		//	FilSTJ435(nOrdem435,1)
	EndIF

	RestArea(aArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³NGLostFocus³Autor ³Vitor Emanuel Batista  ³ Data ³31/07/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Forca a saida de do objeto para executar validacoes         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA435                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NGLostFocus()

	lRet435 := .T.
	oChv435:SetFocus()
	If !lRet435 //Problema encontrado em alguma rotina de validacao da LinhaOK
		Return .F.
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³fValDel435 ³Autor ³Vitor Emanuel Batista  ³ Data ³31/07/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Valida exclusao do Insumo Realizado                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA435                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fValDel435( lGetDados , aArrTmp , nLinErro,lDel )

	Local cOLDALI:= ALIAS()
	Local aAreaTL:= STL->(GetArea())
	Local nPos01  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TIPOREG"})
	Local nPos03  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_CODIGO" })
	Local nPos16  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_TAREFA" })
	Local nPos18  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_SEQRELA"})
	Local nPosNS  := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSEQ"})
	Local nPosNSA := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_NUMSA"})
	Local nPosISA := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_ITEMSA"})
	Local nPosLoc := aScan(aHoBrw2,{|x| Trim(Upper(x[2])) == "TL_LOCAL"})
	Local cKeySTL := "",nPosSav
	Local cNumSeq  := ''
	Local aTemp   := {},lTestaNF := .T.
	Local nPosTp  := oBrw6:oBrowse:nAt
	Local lVerDt  := !(STJ->TJ_SERVICO == 'HISTOR' .And. cUIntHis == 'N') 

	If !lGetDados
		aTemp := aClone(aArrTmp)
	Else
		aTemp := aClone(aCols[n])
	EndIf

	If nPosNS > 0
		cNumSeq := aCols[ nPosTp, nPosNS ]
	Else
		dbSelectArea('STL')
		dbSetOrder(1)
		If dbSeek( xFilial('STL') + cOrdemTJ + cPlanoTJ + aCols[ nPosTp, nPos16 ] + aCols[ nPosTp, nPos01 ] + ;
		aCols[ nPosTp, nPos03 ] + aCols[ nPosTp, nPos18 ] )
			cNumSeq := STL->TL_NUMSEQ
		Endif
	Endif

	//-----------------------------------------------------------------------
	// Valida alteração ou exclusão de insumo pneu que entrou na estrutura
	//-----------------------------------------------------------------------
	If cUsaInt3 == 'S' .And. ; // integração com estoque
		Alltrim( STJ->TJ_SERVICO ) == SuperGetMv( 'MV_NGSERPN', .F., '' ) .And.; // serviço mov. pneu
		!( Readvar()  $( "M->TL_DESTINO/M->TL_TAREFA" ) ) .AND.; // Não é tarefa nem destino
		( nPosDOS := aScan(aDadosOS,{|x| Trim(Upper(x[1])) == cOrdemTJ}) ) > 0 .And.; // posição da ordem
		( nPosSav := aScan(aDadosOS[nPosDOS,4] ,{|x| ; // posição do insumo
					x[nPos01] == aTemp[nPos01] .And.;
					x[nPos03] == aTemp[nPos03] .And.;
					x[nPos18] == aTemp[nPos18] }) ) > 0 .And.;
		aDadosOs[nPosDOS,4,nPosSav,nPos01] == 'P' .And. ; // insumo produto
		Val( aDadosOs[nPosDOS,4,nPosSav,nPos18] ) .And.; // insumo realizado
		ProdutoPn( aDadosOs[nPosDOS,4,nPosSav,nPos03],; // é um pneu
					aDadosOs[nPosDOS,4,nPosSav,nPosLoc], STJ->TJ_ORDEM )
		// "Este produto está relacionado a movimentação de pneu e não é permitido alterar\excluir por meio desta rotina."
		// "Utilize a rotina de rodados para esta finalidade."
		HELP( ' ', 1, "NGATENCAO",, STR0391, 2, 0,,,,,, { STR0394 } ) 
		Return .F.

	EndIf

	If Readvar() == "M->TL_LOTECTL" .Or. Readvar() == "M->TL_NUMLOTE" .Or. Readvar() == "M->TL_GARANTI"
		lTestaNF := .F.
	EndIf

	If lTestaNF
		If ( cUsaInt3 == "S" .Or. cUsaInt2 == "S" ) .And. aTemp[nPos01] $ "P/M/T" .And. !aTemp[Len(aTemp)] .And. Val( aTemp[nPos18] ) > 0
			nPosDOS := aScan(aDadosOS,{|x| Trim(Upper(x[1])) == cOrdemTJ})
			If nPosDOS > 0 .And. !Empty( cNumSeq )
				nPosSav := aScan(aDadosOS[nPosDOS,4] ,{|x|  /*x[nPos16] == aTemp[nPos16] .And.*/ ;
				x[nPos01] == aTemp[nPos01] .And. ;
				x[nPos03] == aTemp[nPos03] .And. ;
				x[nPos18] == aTemp[nPos18] })
				If nPosSav > 0
					cMsgErro := STR0037 //"Atenção"
					If ValType(nLinErro) == "N"
						cMsgErro += STR0228 + Alltrim(Str(nLinErro,9)) //" - Linha:"
					EndIf
					If NGIFDBSEEK("SD1",cNumSeq,4,.F.) ;
							.And. !(Readvar()  $("M->TL_DESTINO/M->TL_TAREFA/M->TL_ETAPA/M->TL_LOCAPLI"))
						MSGINFO(STR0229+chr(13); //"Esse insumo não pode ser alterado ou excluído, pois está vinculado à uma"
						+STR0230+chr(13); //"NF de Entrada. Para que essa alocação seja modificada, é necessário executar"
						+STR0231+chr(13); //"o acerto na NF de entrada através da transação Documento de Entrada."
						+STR0232+chr(13); //"Alertamos que, se o estoque já estiver fechado e a NF já tenha sido"
						+STR0233+chr(13); //"contabilizada, essa alteracão não será possível. Outra situação a ser"
						+STR0234+chr(13); //"considerada, é que a NF de entrada somente poderá ser modificada"
						+STR0235+chr(13); //"se a O.S vinculada a mesma ainda estiver em aberto. Se a OS estiver"
						+STR0236,cMsgErro) //"fechada, será necessário a reabertura da mesma."
						If Readvar() = "M->TL_TAREFA"
							NGSTLTAR( STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA,aTemp[nPos16] ) //Função que faz a consistência da tarefa;
						EndIf
						dbSelectArea(cOLDALI)
						Return .F.
					ElseIf NGIFDBSEEK("SD3",cNumSeq,4,.F.) .And. Readvar() <> "M->TL_DESTINO"

						//------------------------------------
						// Valida data de fechamento do mês
						//------------------------------------
						If !NGCHKMESFE( SD3->D3_EMISSAO, aDadosOs[nPosDOS,4,nPosSav,nPos01], .F. )
							// 'Não é permitido alterar ou deletar um insumo com data menor que o fechamento do mês. Data de fechamento: '
							Help( '', 1, 'NGATENCAO',, STR0392  + CRLF + STR0393 + ': ' + Dtoc( dDtUlMes ),3,1)
							Return .F.
						EndIf

						//------------------------------------
						// Valida data de bloqueio do mês
						//------------------------------------
						If aDadosOs[nPosDOS,4,nPosSav,nPos01] $ 'P/M' .And. lVerDt .And. !MNTValDBl( SD3->D3_EMISSAO )
							Return .F.
						EndIf

						If NGCADICBASE("TL_ORIGNFE","A","STL",.F.)
							cTempONFE := ""
							cKeySTL := xFilial("STL") + cOrdemTJ + cPlanoTJ + aDadosOs[nPosDOS,4,nPosSav,nPos16] + aTemp[nPos01] + aTemp[nPos03] + aTemp[nPos18]
							dbSelectArea("STL")
							dbSetOrder(1) //TL_FILIAL+TL_ORDEM+TL_PLANO+TL_TAREFA+TL_TIPOREG+TL_CODIGO+TL_SEQRELA
							If dbSeek(cKeySTL)
								cTempONFE := STL->TL_ORIGNFE
							EndIf
							RestArea(aAreaTL)

							// Verifica se não está integrado com o BackOffice RM
							If AllTrim( SuperGetMV( 'MV_NGINTER', .F., 'N' ) ) != 'M'

								If !( Readvar()  $( 'M->TL_DESTINO/M->TL_TAREFA/M->TL_ETAPA/M->TL_LOCAPLI' ) ) .Or.;
									lDel == Nil

									If cTempONFE == "SD3"
										MSGINFO(STR0237+chr(13)+; //"Esse insumo nao pode ser alterado ou excluido porque esta vinculado a uma"
										STR0238+Chr(13)+Chr(13)+; //"movimentacao originaria de um movimento interno do estoque."
										STR0239,; //"Operacao somente permitida pelo modulo Estoque/Custos."
										cMsgErro)
										If Readvar() = "M->TL_TAREFA"
											NGSTLTAR( STJ->TJ_CODBEM+STJ->TJ_SERVICO+STJ->TJ_SEQRELA,aTemp[nPos16] ) //Função que faz a consistência da tarefa;
										EndIf
										dbSelectArea(cOLDALI)
										Return .F.
									ElseIf ( nPosNSA > 0 .And. !Empty(aDadosOs[nPosDOS,4,nPosSav,nPosNSA]) ) .Or.;
										( nPosISA > 0 .And. !Empty(aDadosOs[nPosDOS,4,nPosSav,nPosISA]) )
										//Verifica se tem o campo NUMSA ou ITEMSA preenchidos, se preenchido indica que veio de baixa/pré-requisição de SA
										MSGINFO(STR0237+space(1)+; //"Esse insumo não pode ser alterado ou excluído porque está vinculado a uma"
										STR0238+Chr(10)+Chr(10)+; //"movimentação originária de um movimento interno do estoque."
										STR0239) //"Operação somente permitida pelo módulo Estoque/Custos."
										dbSelectArea(cOLDALI)
										Return .F.
									EndIf

								EndIf

							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
		If ExistBlock("MNTB4353")
			ExecBlock("MNTB4353",.F.,.F.,{aArrTmp,lDel})
		EndIf
	EndIf

	dbSelectArea(cOLDALI)
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNTA435TR  ³Autor ³Inacio Luiz Kolling    ³ Data ³30/04/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Valida a alteracao dos dados do insumo (Novo X3_VALID)     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA435                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTA435TR()
Return fValDel435(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNTA435MC  ³Autor ³Inacio Luiz Kolling    ³ Data ³30/03/2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Valida insumo MDO com calendario                    )     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA435                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTA435MC()

	Local nPos01 := GDFIELDPOS( "TL_TIPOREG", aHoBrw2 )
	Local nPos02 := GDFIELDPOS( "TL_CODIGO", aHoBrw2 )
	Local nPos03 := GDFIELDPOS( "TL_USACALE", aHoBrw2 )

	If aCols[n,nPos01] = "M" .And. aCols[n,nPos03] = "S" .And. Empty(aCols[n,nPos02])
		Help( " ", 1, "OBRIGAT", , + Chr(13) + NGRETTITULO("TL_CODIGO") + Space(35), 3 )
		Return .F.
	EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MNTA435   ºAutor  ³Taina A. Carodoso   º Data ³  06/06/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Validacao para incremento do seqrela                        º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MNTA435                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function MNT435SEQ( aColsSqe, lChange )

	Local nFor
	Local oldaCols, oldaHeader
	Local lPRIMLO := .T.
	Local nPos18  := aScan( aHoBrw2,{|x| Trim( Upper(x[2]) ) == "TL_SEQRELA" })
	Local nPosTp  := oBrw6:oBrowse:nAt
	Local cSeqAtu := "0  "

	If lChange .Or. (  Len(aColsSqe) >= nPosTp .And. ;
	( AllTrim(aColsSqe[ nPosTp , nPos18 ]) == "0" .Or. Empty(aColsSqe[ nPosTp , nPos18 ]) ))
		//Define maior sequencia atual
		For nFor := 1 To Len(aColsSqe)
			If Empty(aColsSqe[nFor,nPos18])
				Loop
			EndIf
			If Val(aColsSqe[nFor,nPos18]) > 0
				If Val(aColsSqe[nFor,nPos18]) > Val(cSeqAtu)
					cSeqAtu := aColsSqe[nFor,nPos18]
				EndIf
			ElseIf !IsDigit(Substr(aColsSqe[nFor,nPos18],1,1))
				cSeqAtu := If(lPRIMLO,aColsSqe[nFor,nPos18],If(aColsSqe[nFor,nPos18] > cSeqAtu,aColsSqe[nFor,nPos18],cSeqAtu))
				lPRIMLO := .F.
			EndIf
		Next nFor

		//Adiciona 1 à sequencia atual
		If Alltrim(cSeqAtu) == "0" .Or. Empty(cSeqAtu)
			cSeqAtu := PADR("1",3)
		Else
			If !lPRIMLO
				If FindFunction("Soma1Old")
					cSeqAtu := PADR(Soma1Old(cSeqAtu),3)
				Else
					cSeqAtu := PADR(Soma1(cSeqAtu),3)
				EndIf
			Else
				If FindFunction("Soma1Old")
					cSeqAtu := IIf( Val( cSeqAtu ) == 0,PADR( "1", 3),PADR( Soma1Old( cSeqAtu ), 3 ))
				Else
					cSeqAtu := IIf( Val( cSeqAtu ) == 0,PADR( "1", 3),PADR( Soma1( cSeqAtu ), 3 ))
				EndIf
			EndIf
		EndIf
	ElseIf Len(aColsSqe) >= nPosTp
		cSeqAtu := aColsSqe[ nPosTp , nPos18 ]
	EndIf

	oBrw3:oBrowse:lDisablePaint := .F.
	oldaCols   := aClone(aColsSqe)
	oldaHeader := aClone(aHeader)

Return cSeqAtu

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fF4KEY    ºAutor  ³Robson Pereira      º Data ³  11/01/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Faz os campos receberem o valor apos o F4                  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MNTA435                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function fF4KEY()

	Local cVar			:= ReadVar()
	Local nTLLOCALIZ	:= aScan(aHoBrw6,{|x| Trim( Upper(x[2]) ) == "TL_LOCALIZ" })
	Local nTLNUMSERI	:= aScan(aHoBrw6,{|x| Trim( Upper(x[2]) ) == "TL_NUMSERI" })

	ShowF4MNT()

	If cVar == "M->TL_LOCALIZ" .Or. cVar == "M->TL_NUMSERI"
		M->TL_LOCALIZ := If(nTLLOCALIZ > 0, aCols[n][nTLLOCALIZ], Space(TAMSX3("TL_LOCALIZ")[1]))
		M->TL_NUMSERI := If(nTLNUMSERI > 0, aCols[n][nTLNUMSERI], Space(TAMSX3("TL_NUMSERI")[1]))
	EndIf
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNT435CANB ³Autor ³Hugo Rizzo Pereira     ³ Data ³20/03/2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Verifica se existe bloqueio para a baixa no estoque.       ³±±
±±³          ³ Caso exista, a movimencao nao deve ser efetuada.           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cKeySTL - Chave de pesquisa. (STL)                         ³±±
±±³          ³ Ordem + Plano + Seq. + Tarefa + TipoReg + Codigo           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ lRet - Retorna se existe um bloqueio para a movimentacao.  ³±±
±±³          ³        .T. - Nao existe bloqueio. Movimentacao permitida.  ³±±
±±³          ³        .F. - Existe bloqueio. Movimentacao cancelada.      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Variaveis ³ lCanScan - Verifica se deve ou nao validar possiveis       ³±±
±±³          ³ bloqueios gerados. Caso a mesma seja falsa, define que     ³±±
±±³          ³ nao bloqueios a serem considerados.                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA435                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MNT435CANB(cKeySTL)

	Local lCanScan := Type("aNBaixaEst") == "A" .And. Len( aNBaixaEst ) > 0
	Local lRet     := .T.

	Default cKeySTL := STL->TL_ORDEM + STL->TL_PLANO + STL->TL_SEQRELA + STL->TL_TAREFA + STL->TL_TIPOREG + STL->TL_CODIGO

	lRet := !lCanScan .Or. ( aScan( aNBaixaEst,{|x| x[1]+x[2]+x[3]+x[4]+x[5]+x[6] == cKeySTL }) == 0)

Return lRet

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} MNT435CALLB
Função utilizada para chamar Funções dos botões de Insumo na tela de retorno de O.S..

@author André Felipe Joriatti
@since 06/12/2012
@version MP11
@param nOp: Indica a função a ser chamada.
oChv435: Objeto passado por referencia para funções fPrgNext( @oChv435 ) e fPrgNext( @oChv435 )
@return Nil
/*/
//---------------------------------------------------------------------------------------
Static Function MNT435CALLB( nOp,oChv435 )

	Local lRet  := .F.

	If ExistBlock( "MNTA4358" )
		lRet := ExecBlock( "MNTA4358",.F.,.F., { nOp,(cTRBIP) } )
		If !lRet
			Return .F.
		EndIf
	EndIf

	If nOp == 1 // "Incluir todos os insumos previstos."
		fPrgNext( @oChv435 )
	ElseIf nOp == 2 // "Incluir o insumo previsto."
		f435Next( @oChv435 )
	ElseIf nOp == 3 // "Excluir o insumo realizado."
		f435Prev()
	ElseIf nOp == 4 // "Excluir todos os insumos realizados."
		fPrgPrev()
	EndIf

Return

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} MNT435RLOC()
Chama funÃ§Ã£o NGRELOCORRC de acordo com o parametro nOpc.

@author Felipe Helio dos Santos
@since 08/03/2013
@version MP10/MP11
@param nOpc: 1 = F10 2 = F11
/*/
//---------------------------------------------------------------------------------------
Static Function MNT435RLOC(nOpc)

	If Type("lFocusBrw3") == "L" .And. lFocusBrw3
		If nOpc == 1 //F10
			NGRELOCORRC("M->TN_CAUSA",aCOLS[n,1],"P",.T., ,"TN_NOMCAUS",oBrw3)
		ElseIf nOpc == 2 //F11
			NGRELOCORRC("M->TN_SOLUCAO",aCOLS[n,3],"C",.T., ,"TN_NOMSOLU",oBrw3)
		EndIf
	EndIf

Return
//---------------------------------------------------------------------------------------
/*/{Protheus.doc} MNT435CUS()
Retorna o Custo de acordo com o Tipo

@author Jackson Machado
@since 30/04/2013

@return .T.
/*/
//---------------------------------------------------------------------------------------
Function MNT435CUS()

	Local nQtd    := 0 //Define a Quantidade
	Local nQtdRec := 0 //Define a Quantidade Recurso

	//Define as posicoes no array
	Local nPosTip	:= aScan( aHoBrw2 , { | x | Trim( Upper( x[ 2 ] ) ) == "TL_TIPOREG"	} )
	Local nPosPrd	:= aScan( aHoBrw2 , { | x | Trim( Upper( x[ 2 ] ) ) == "TL_CODIGO"	} )
	Local nPosQtd	:= aScan( aHoBrw2 , { | x | Trim( Upper( x[ 2 ] ) ) == "TL_QUANTID"	} )
	Local nPosCus	:= aScan( aHoBrw2 , { | x | Trim( Upper( x[ 2 ] ) ) == "TL_CUSTO"	} )
	Local nPosRec	:= aScan( aHoBrw2 , { | x | Trim( Upper( x[ 2 ] ) ) == "TL_QUANREC"	} )
	Local nPosLoc	:= aScan( aHoBrw2 , { | x | Trim( Upper( x[ 2 ] ) ) == "TL_LOCAL"	} )
	Local cInsumo	:= "" // Define o Codigo do Insumo
	Local cTipIns	:= "" // Define o Tipo de Insumo

	//Verifica integracao com o estoque
	Local cIntEst	:= AllTrim( GetMv( "MV_NGMNTES" ) )
	Local cUIntHis  := AllTrim( GetMv( "MV_NGHISES" ))
	Local cLocal    := ""

	If "TL_CODIGO" $ ReadVar()
		nQtd		:= aCols[ n , nPosQtd ]
		cInsumo	:= M->TL_CODIGO
		cTipIns	:= aCols[ n , nPosTip ]
		nQtdRec	:= aCols[ n , nPosRec ]
		cLocal  := aCols[ n , nPosLoc ]
	ElseIf "TL_QUANTID" $ ReadVar()
		nQtd		:= M->TL_QUANTID
		cInsumo	:= aCols[ n , nPosPrd ]
		cTipIns	:= aCols[ n , nPosTip ]
		nQtdRec	:= aCols[ n , nPosRec ]
		cLocal  := aCols[ n , nPosLoc ]
	ElseIf "TL_QUANREC" $ ReadVar()
		nQtd    := aCols[ n , nPosQtd ]
		cInsumo	:= aCols[ n , nPosPrd ]
		cTipIns	:= aCols[ n , nPosTip ]
		nQtdRec	:= M->TL_QUANREC
		cLocal  := aCols[ n , nPosLoc ]
	Else
		nQtd		:= aCols[ n , nPosQtd ]
		cInsumo	:= aCols[ n , nPosPrd ]
		cTipIns	:= aCols[ n , nPosTip ]
		nQtdRec	:= aCols[ n , nPosRec ]
		cLocal  := aCols[ n , nPosLoc ]
	EndIf
	//Verifica se o campo TL_CUSTO está contido no aHoBrw2 para validar Custo da M.O. (Verificar PE MNTA435E).
	If nPosCus > 0
		If cIntEst == "S" // Atribui o valor apenas quando tiver integração com o Estoque

			// Define os valores de acordo com o campo que esta sendo alterado
			If ( "TL_TIPOREG" $ ReadVar() .And. aCols[ n , nPosTip ] <> M->TL_TIPOREG ) .Or. nQtd == 0
				aCols[ n , nPosCus ] := 0 // Caso altere o Tipo de Insumo, zera o custo
			Else
				If STJ->TJ_SERVICO <> "HISTOR"
					aCols[ n , nPosCus ] := Round( NGCALCUSTI( cInsumo, cTipIns, nQtd, cLocal, , , , nQtdRec , "1" ) , 2 )//Atribui o custo ja tratado, passando sempre ele como 'realizado'
				ElseIf STJ->TJ_SERVICO == "HISTOR" .And. cUIntHis == "N" .And. cTipIns <> "P"
					aCols[ n , nPosCus ] := Round( NGCALCUSTI( cInsumo, cTipIns, nQtd, cLocal, , , , nQtdRec , "1" ) , 2 )//Atribui o custo ja tratado, passando sempre ele como 'realizado'
				ElseIf cUIntHis == "S"
					aCols[ n , nPosCus ] := Round( NGCALCUSTI( cInsumo, cTipIns, nQtd, cLocal, , , , nQtdRec , "1" ) , 2 )//Atribui o custo ja tratado, passando sempre ele como 'realizado'
				EndIf
			EndIf

		ElseIf cTipIns == "M"
			// Define os valores de acordo com o campo que esta sendo alterado
			If ( "TL_TIPOREG" $ ReadVar() .And. aCols[ n , nPosTip ] <> M->TL_TIPOREG ) .Or. nQtd == 0
				aCols[ n , nPosCus ] := 0 // Caso altere o Tipo de Insumo, zera o custo
			Else
				aCols[ n , nPosCus ] := Round( NGCALCUSTI( cInsumo , cTipIns , nQtd , , , , , nQtdRec , "1", , aCols[ n , nPosCus ]  ) , 2 )//Atribui o custo ja tratado, passando sempre ele como 'realizado'
			EndIf
		EndIf
	EndIf
	oBrw3:oBrowse:Refresh() // Atualiza o Objeto

Return .T.

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} MNT435SEL()
Marca os insumos previstos.

@author Pedro Henrique Soares de Souza
@since 25/11/2013
/*/
//---------------------------------------------------------------------------------------
Static Function MNT435SEL()

	RecLock((cTRBIP),.F.)

	If Marked("TL_OK")
		(cTRBIP)->TL_OK := cMARCA
	Else
		(cTRBIP)->TL_OK := ""
	EndIf

	(cTRBIP)->(MSUNLOCK())

	oBrw2:oBrowse:Refresh()

Return

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} MNT435ALL()
Marca todos os insumos previstos.

@author Pedro Henrique Soares de Souza
@since 25/11/2013
/*/
//---------------------------------------------------------------------------------------
Static Function MNT435ALL()

	Local aArea     := GetArea()
	Local aAreTRBIP := (cTRBIP)->(GetArea())

	dbSelectArea(cTRBIP)
	dbGoTop()
	While !EoF()

		Reclock((cTRBIP), .F.)
		(cTRBIP)->TL_OK := If( Empty( (cTRBIP)->TL_OK ), cMarca, Space( TAMSX3('TQ_OK')[1]) )
		(cTRBIP)->(MsUnLock())

		dbSelectArea(cTRBIP)
		dbSkip()
	EndDo

	oBrw2:oBrowse:Refresh()

	RestArea(aAreTRBIP)
	RestArea(aArea)

Return
//---------------------------------------------------------------------------------------
/*/{Protheus.doc} MNT435ETAL()
Marca todas as etapas.

@author Tainã Alberto Cardoso
@since 07/05/2014
/*/
//---------------------------------------------------------------------------------------
Static Function MNT435ETAL()

	Local aArea := GetArea()
	Local aAreaTrb := (cTRBQ400)->( GetArea() )

	dbSelectArea(cTRBQ400)
	dbGoTop()
	While !EoF()

		Reclock( cTRBQ400, .F. )

		If Empty( (cTRBQ400)->TQ_OK )

			(cTRBQ400)->TQ_OK := oBrw4:cCodMarca //cMarca

			fMNTA405() //Mostra tela de resposta da etapa (se etapa for de responder)

		Else
			(cTRBQ400)->TQ_OK			:= Space( TAMSX3('TQ_OK')[1] )
			(cTRBQ400)->TQ_CODFUNC	:= Space( TamSX3('TQ_CODFUNC')[1] )
		EndIf

		MsUnLock(cTRBQ400)
		fLegendEt((cTRBQ400)->TQ_TAREFA+(cTRBQ400)->TQ_ETAPA+(cTRBQ400)->TQ_SEQETA) //Define as cores para legenda de etapas

		dbSelectArea(cTRBQ400)
		dbSkip()
	EndDo

	oBrw4:oBrowse:Refresh()
	oBrw4:oBrowse:Refresh()

	RestArea(aAreaTrb)
	RestArea(aArea)

Return
//---------------------------------------------------------------------------------------
/*/{Protheus.doc} MNTA435EFI ()
Consistencia final das etapas e respostas

@author Tainã Alberto Cardoso
@since 07/05/2014
/*/
//---------------------------------------------------------------------------------------
Static Function MNTA435EFI()

	Local aAreaTRB := (cTRBQ400)->( GetArea() )
	Local aAreaTPA := TPA->( GetArea() )
	Local aAreaTPQ := TPQ->( GetArea() )

	dbSelectArea(cTRBQ400)
	dbGotop()
	While !EoF()
		If !Empty((cTRBQ400)->TQ_OK)

			dbSelectArea("TPA")
			dbSetOrder(1)
			If dbSeek(xFilial("TPA")+(cTRBQ400)->TQ_ETAPA)

				If TPA->TPA_OPCOES <> '0'

					dbSelectArea(cTRB3400)
					dbSetOrder(1)
					If dbSeek((cTRBQ400)->TQ_ETAPA)

						lREPOS := .F.

						While !EoF() .And. (cTRB3400)->TPC_ETAPA = (cTRBQ400)->TQ_ETAPA
							If !Empty((cTRB3400)->TPC_OK)
								lREPOS := .T.
								Exit
							EndIf
							dbSkip()
						End

						If !lREPOS
							MsgInfo( STR0260 + " " + (cTRBQ400)->TQ_ETAPA + "  " + STR0023 + " " + (cTRBQ400)->TQ_TAREFA, STR0261 ) //"Não foi selecionado as respostas das opcões da etapa" ## "Tarefa" ## "NÃO CONFORMIDADE"
							Return .F.
						EndIf
					Else
						dbSelectArea("TPQ")
						dbSetOrder(1)
						If !dbSeek( xFilial("TPQ") + STJ->TJ_ORDEM + STJ->TJ_PLANO + (cTRBQ400)->TQ_TAREFA + (cTRBQ400)->TQ_ETAPA )
							MsgInfo( STR0260 + " " + (cTRBQ400)->TQ_ETAPA + "  " + STR0023 + " " + (cTRBQ400)->TQ_TAREFA, STR0261 ) //"Não foi selecionado as respostas das opcões da etapa" ## "Tarefa"  "NÃO CONFORMIDADE"
							Return .F.
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
		dbSelectArea(cTRBQ400)
		dbSkip()
	EndDo

	RestArea(aAreaTPQ)
	RestArea(aAreaTPA)
	RestArea(aAreaTRB)

Return .T.

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} fSaveResp()
Salva as respostas das etapas na tabela temporária (cTRB3400)

@author Pedro Henrique Soares de Souza
@since 03/12/2014

@param cEtapa		- Etapa genérica respondida
@param cTarefa		- Tarefa correspondente a etapa
@param aCposAlter	- Campos utilizados para gravação

@return Nil Nulo
/*/
//---------------------------------------------------------------------------------------
Function fSaveResp( cEtapa, cTarefa, aCposAlter )
	//Armazena área da tabela TPC antes de posicionar na tabela para gravação da TRB
	Local aAreaTPC := TPC->(GetArea())
	Local nX, nI, i, x, y
	For nX := 1 To nItens
		dbSelectArea("TPC")
		dbSetOrder(1)
		If !dbSeek(xFilial("TPC") + cEtapa + aCols[nx][nnOPCA]) .Or. Empty(aCols[nX][nOK])
			Loop
		EndIf
		dbSelectArea(cTRB3400)
		dbSetOrder(1)
		dbGoTop()
		If !dbSeek( cEtapa + cTarefa + aCols[nX][nnOPCA] )
			RecLock(cTRB3400, .T.)
			dbSelectArea("TPC")
			dbSetOrder(1)
			If dbSeek(xFilial("TPC") + cEtapa + aCols[nX][nnOPCA])
				For i := 1 To FCount()
					x  := "TPC->" + FieldName(i)
					y  := cTRB3400 + "->" + FieldName(i)
					Replace &y. with &x.
				Next i
				If Len(aCposAlter) > 0
					For nI := 1 To Len(aCposAlter)
						nPosCpo := aScan(aHeader,{|x| AllTrim(x[2]) == aCposAlter[nI]})
						If nPosCpo > 0
							(cTRB3400)->(FieldPut(FieldPos(aCposAlter[nI]),aCols[nx][nPosCpo]))
						EndIf
					Next nI
				EndIf
				(cTRB3400)->TPC_RESPOS := aCols[nx][nRESPOS]
				(cTRB3400)->TPC_OK     := "XX"
				(cTRB3400)->TPC_TAREFA := cTarefa
				(cTRB3400)->TPC_ETAPA  := cEtapa
				(cTRB3400)->(MsUnLock())
			EndIf
		EndIf
	Next nX
	//Restaura área da tabela TPC
	RestArea(aAreaTPC)
	Return Nil

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} fPesqEsp()
Pesquisa por codigo ou nome na tela de funcionarios da especialidade

@author Thiago Olis Machado
@since 08/06/2016

@return Nil
/*/
//---------------------------------------------------------------------------------------
Static Function fPesqEsp( aOS2 , oOS2, cPesquisar )

	Local nPos := 0

	nPos := aScan( aOS2, { |x| AllTrim(x[2]) == AllTrim(cPesquisar) } )

	If nPos > 0
		oOS2:nAt := nPos
		oOS2:Refresh()
	Else
		nPos := aScan( aOS2, { |x| AllTrim(cPesquisar) $ AllTrim(x[3]) } )
		If nPos > 0
			oOS2:nAt := nPos
			oOS2:Refresh()
		EndIf
	EndIf

Return Nil

//---------------------------------------------------------------------------------------
/*/{Proteus.doc} MNT435LEG
Atualiza o status da etapa conforme legenda definida.
@static

@author Alexandre Santos
@since 23/10/2017

fLegendEt("cChave")

@param  cChave, Caracter, Chave de busca para a TRB
@return Nil
/*/
//---------------------------------------------------------------------------------------
Static Function fLegendEt(cChave)

	Local cCodFam	:= ""
	Local cTempMed	:= ""
	Local aAreaSTQ  := STQ->(GetArea())
	Local aAreaSTL  := STL->(GetArea())
	Local aAreaTRB  := (cTRBQ400)->(GetArea())

	dbSelectarea(cTRBQ400)
	dbSetOrder(2)
	dbSeek(cChave)
	cCodFam  := NGSEEK("ST9", STJ->TJ_CODBEM, 1, "T9_CODFAMI")
	cTempMed := NGSEEK("TVT", cCodFam + (cTRBQ400)->TQ_ETAPA, 2, "TVT_TEMPO")
	cTempMed := Val(cTempMed)

	RecLock(cTRBQ400, .F.)
	dbSelectArea("STL")
	dbSetOrder(1)
	If dbSeek(xFilial("STL")+(cTRBQ400)->TQ_ORDEM + (cTRBQ400)->TQ_PLANO + (cTRBQ400)->TQ_TAREFA + "M")
		(cTRBQ400)->QUANTID := 0
		(cTRBQ400)->SEQRELA := 0
		While !EoF() .And. STL->TL_FILIAL == xFilial("STL") .And. STL->TL_ORDEM == (cTRBQ400)->TQ_ORDEM .And. STL->TL_PLANO == (cTRBQ400)->TQ_PLANO;
				.And. STL->TL_TAREFA == (cTRBQ400)->TQ_TAREFA .And. STL->TL_TIPOREG == "M"
			If STL->TL_ETAPA != (cTRBQ400)->TQ_ETAPA .Or. STL->TL_SEQRELA == '0'
				dbSelectArea("STL")
				dbSkip()
				Loop
			EndIf
			dbSelectArea(cTRBQ400)
			dbSetOrder(2)
			If dbSeek(STL->TL_TAREFA + STL->TL_ETAPA + (cTRBQ400)->TQ_SEQETA)
				(cTRBQ400)->QUANTID	+= STL->TL_QUANTID
			Else
			(cTRBQ400)->QUANTID	:= STL->TL_QUANTID
			EndIf
			(cTRBQ400)->SEQRELA	:= Val(STL->TL_SEQRELA)
			dbSelectArea("STL")
			dbSkip()
		EndDo
		If !Empty((cTRBQ400)->TQ_OK)
			(cTRBQ400)->STATUS := '1'
		ElseIf Empty((cTRBQ400)->TQ_OK) .And. (cTRBQ400)->SEQRELA != 0 .And. !Empty(cTempMed)
			If (cTRBQ400)->QUANTID	<= cTempMed
				(cTRBQ400)->STATUS := '3'
			Else
				(cTRBQ400)->STATUS := '4'
			EndIf
		ElseIf Empty((cTRBQ400)->TQ_OK) .And. (cTRBQ400)->SEQRELA != 0 .And. Empty(cTempMed)
			(cTRBQ400)->STATUS := '2'
		ElseIf Empty((cTRBQ400)->TQ_OK)
			(cTRBQ400)->STATUS := '2'
		EndIf
	Else
		dbSelectArea(cTRBQ400)
		dbSetOrder(2)
		If dbSeek(cChave)
			If !Empty((cTRBQ400)->TQ_OK)
				(cTRBQ400)->STATUS := '1'
			ElseIf Empty((cTRBQ400)->TQ_OK)
				(cTRBQ400)->STATUS := '2'
			EndIf
		EndIf
	EndIf
	(cTRBQ400)->(MsUnlock())

	RestArea(aAreaTRB)
	RestArea(aAreaSTL)
	RestArea(aAreaSTQ)

	dbSelectarea(cTRBQ400)
	dbSetOrder(3)

Return Nil

//---------------------------------------------------------------------------------------
/*/{Proteus.doc} fMntCabec

@author Maicon André Pinheiro
@since  04/05/2018
/*/
//---------------------------------------------------------------------------------------
Static Function fMntCabec()

	Local nInd     := 0
	Local nTot     := 0
	Local nTamanho := 0
	Local nDecimal := 0
	Local aCampos  := { 'TX_OK', 'TP1_OPCAO', 'TPC_DESOPC', 'TP1_BEMIMN', 'TP1_TIPCAM', 'TPQ_RESPOS' }
	Local cCampo   := ""
	Local cArquivo := ""
	Local cTitulo  := ""
	Local cPicture := ""
	Local cValid   := ""
	Local cUsado   := ""
	Local cTipo    := ""
	Local cContext := ""
	Local cF3      := ""
	Local cWhen    := ""

	nTot := Len(aCampos)
	For nInd := 1 To nTot

		cCampo   := aCampos[nInd]
		cArquivo := Posicione("SX3",2,cCampo,"X3_ARQUIVO")
		If (cArquivo)->(FieldPos(cCampo)) > 0

			cTitulo  := AllTrim(Posicione("SX3",2,cCampo,"X3Titulo()"))
			cPicture := X3Picture(cCampo)
			nTamanho := TAMSX3(cCampo)[1]
			nDecimal := TAMSX3(cCampo)[2]
			cValid   := Posicione("SX3",2,cCampo,"X3_VALID")
			cUsado   := Posicione("SX3",2,cCampo,"X3_USADO")
			cTipo    := Posicione("SX3",2,cCampo,"X3_TIPO")
			cContext := Posicione("SX3",2,cCampo,"X3_CONTEXT")
			cF3      := Posicione("SX3",2,cCampo,"X3_F3")
			cWhen    := Posicione("SX3",2,cCampo,"X3_WHEN")

			If cCampo == "TX_OK"
				cTitulo := ""
			ElseIf cCampo $ 'TP1_OPCAO/TP1_TIPCAM/TPC_DESOPC
				cWhen := ".F."
			ElseIf cCampo == "TP1_BEMIMN"
				cTitulo := STR0185 // "Tp. Respost."
				cWhen   := ".F."
			ElseIf cCampo == "TPQ_RESPOS"
				cTitulo := STR0059 // "Resposta"
				cValid  := "FE405TPVAR()"
			EndIf

			nUsado++
			aAdd(aHeader,{cTitulo,cCampo,cPicture,nTamanho,nDecimal,cValid,cUsado,cTipo,cArquivo,cContext,cF3,cWhen})

		EndIf

	Next nInd

Return

//------------------------------------------------------------------------------
/*/{Protheus.doc} fRetQuery

Retorna query para buscar as ordens de serviço conforme parâmetros passados

@author Maicon André Pinheiro
@since 07/12/2016
@sample MNTA080
@param cIndice - Posição do indice que realizará a consulta
       cChave  - Chave que será utilizado no indice.
@return cALIASQRY, Caractere, Alias do select
/*/
//------------------------------------------------------------------------------
Static Function fRetQuery(cIndice, cChave)

	Local cALIASQRY := GetNextAlias()
	Local cCondicao := "%"
	Local cSerefor  := Alltrim(GETMV("MV_NGSEREF"))
	Local cSercons  := Alltrim(GETMV("MV_NGSECON"))
	Local cCodPai   := Space(TamSX3("TJ_ORDEPAI")[1])

	If !Empty(cChave)
		
		// Tratamento para campos do tipo data serem inclusos na query.
		cIndice := StrTran( StrTran( cIndice, 'DTOS(' ), ')' )                                                           

		cCondicao := "%" + StrTran(cIndice,"+","||") + " LIKE " + ValToSQL(cChave + "%") + " AND"
		If Substr(Alltrim(cIndice) ,1,9) == "TJ_FILIAL"
			cCondicao := "%" + StrTran(cIndice,"+","||") + " LIKE " + ValToSQL(xFilial("STJ") + cChave + "%") + " AND"
		EndIf
		
	EndIf

	If !lArvoreLogica
		cCondicao += " TJ_LUBRIFI <> 'S' AND"
	EndIf

	cCondicao += "%"

	BeginSQL Alias cALIASQRY

	SELECT R_E_C_N_O_
	  FROM %table:STJ% STJ
	 WHERE TJ_FILIAL = %exp:xFilial("STJ")%
	   AND %exp:cCondicao%
		   TJ_SITUACA = 'L'
	   AND TJ_TERMINO = 'N'
	   AND TJ_ORDEPAI = %exp:cCodPai%
	   AND TJ_SERVICO NOT IN(%exp:cSerefor%,%exp:cSercons%)
	   AND %NotDel%

	EndSQL

Return cALIASQRY

//------------------------------------------------------------------------------
/*/{Protheus.doc} fStatus
Define o status dos insumos previstos de acordo com os insumos realizados
	'0' - Não aplicado
	'1' - Parcialmente Aplicado
	'2' - Totalmente aplicado

@author Wexlei Silveira
@autor Maria Elisandra de Paula
@since 11/12/2018
@return Nil
/*/
//------------------------------------------------------------------------------
Static Function fStatus()

	Local nIndex     := 0
	Local nPCodigo   := aScan( aHoBrw6, { | x | Trim( Upper( x[ 2 ] ) ) == "TL_CODIGO" } )
	Local nPTarefa   := aScan( aHoBrw6, { | x | Trim( Upper( x[ 2 ] ) ) == "TL_TAREFA" } )
	Local nPTiporeg  := aScan( aHoBrw6, { | x | Trim( Upper( x[ 2 ] ) ) == "TL_TIPOREG" } )
	Local nPQuantid  := aScan( aHoBrw6, { | x | Trim( Upper( x[ 2 ] ) ) == "TL_QUANTID" } )
	Local nNSA       := GDFieldPos( 'TL_NUMSA' , aHoBrw6 )
	Local nISA       := GDFieldPos( 'TL_ITEMSA', aHoBrw6 )
	Local nNSC       := GDFieldPos( 'TL_NUMSC' , aHoBrw6 )
	Local nISC       := GDFieldPos( 'TL_ITEMSC' , aHoBrw6 )
	Local nLine      := 0
	Local nQuantid   := 0 //quantidade do insumo realizado
	Local cCodigo    := "" //código do insumo realizado
	Local cTiporeg   := "" //tipo do insumo realizado
	Local nSizeField := TamSx3( "T2_CODFUNC" )[ 1 ]
	Local cStatus    := ""

	dbSelectArea( cTRBIP )
	dbGoTop()
	While !(cTRBIP)->( EoF() )

		nQuantid := 0


		// Somente para insumos do tipo Produto e que possuam vinculo com uma S.A.
		If (cTRBIP)->TL_TIPOREG == 'P' .And. ( nNSA > 0 .And. !Empty( (cTRBIP)->TL_NUMSA ) ) .And.;
			( nISA .And. !Empty( (cTRBIP)->TL_ITEMSA ) )

			nLine := 0

			// Considera a quantidade somente de insumos aplicados vinculados a mesma S.A.
			If nNSA > 0 .And. nISA > 0 .And. ( ( nLine := aScan( aCoBrw6, { |x| x[nNSA] == (cTRBIP)->TL_NUMSA .And.;
				x[nISA] == (cTRBIP)->TL_ITEMSA } ) ) > 0 )

				nQuantid := aCoBrw6[nLine,nPQuantid]

			EndIf

		ElseIf lIntRM .And. (cTRBIP)->TL_TIPOREG $ 'P\T' .And. ( nNSC > 0 .And. !Empty( (cTRBIP)->TL_NUMSC ) ) .And.;
			( nISC .And. !Empty( (cTRBIP)->TL_ITEMSC ) )

			// Considera a quantidade somente de insumos aplicados vinculados a mesma S.C.
			If nNSC > 0 .And. nISC > 0 .And. ( ( nLine := aScan( aCoBrw6, { |x| x[nNSC] == (cTRBIP)->TL_NUMSC .And.;
				x[nISC] == (cTRBIP)->TL_ITEMSC } ) ) > 0 )

				nQuantid := aCoBrw6[nLine,nPQuantid]

			EndIf

		Else

			For nIndex := 1 To Len( aCoBrw6 )

				cTiporeg := aCoBrw6[ nIndex, nPTiporeg ]
				cCodigo  := aCoBrw6[ nIndex, nPCodigo ]

				//----------------------------------------------------
				//Comparação de insumos previstos x insumos realizados
				//----------------------------------------------------
				If AllTrim( (cTRBIP)->TL_TAREFA ) == AllTrim( aCoBrw6[ nIndex, nPTarefa ] ) ;
					.And. ( ( Alltrim( (cTRBIP)->TL_TIPOREG ) == "E" .And. AllTrim( cTiporeg ) == "M" ;
					.And. NGIFDBSEEK( "ST2", Padr( cCodigo, nSizeField )  + Alltrim( (cTRBIP)->TL_CODIGO ), 1 ) ) ;
					.Or. ( AllTrim( (cTRBIP)->TL_TIPOREG ) == AllTrim( cTiporeg ) ;
					.And. AllTrim( (cTRBIP)->TL_CODIGO ) == AllTrim( cCodigo ) ) )

					//Soma a quantidade de insumos que já foram aplicados
					nQuantid += aCoBrw6[ nIndex, nPQuantid ]
				EndIf
			Next nIndex

		EndIf

		If nQuantid == 0
			cStatus := "0" //'0' - Não aplicado
		ElseIf nQuantid < (cTRBIP)->TL_QUANTID
			cStatus := "1" //'1' - Parcialmente Aplicado
		ElseIf nQuantid >= (cTRBIP)->TL_QUANTID
			cStatus := "2" //'2' - Totalmente aplicado
		EndIf

		//----------------------------------------------
		//Atualiza legenda/status dos insumos previstos
		//----------------------------------------------
		RecLock( (cTRBIP), .F. )
		(cTRBIP)->STATUS := cStatus
		MsUnLock()

		(cTRBIP)->( dbSkip() )

	EndDo

Return

//------------------------------------------------------------------------------
/*/{Protheus.doc} fUpdInput
Filtra os insumos previstos.

@author Wexlei Silveira
@since 13/12/2018
@return nil
/*/
//------------------------------------------------------------------------------
Static Function fUpdInput()

	LoadInsum(M->TJ_ORDEM, M->TJ_PLANO, aScan(aDadosOS, {|x| x[1] + x[2] == M->TJ_ORDEM + M->TJ_PLANO }), oBrw6:oBrowse:nAt)

	dbSelectArea(cTRBIP)
	dbGoTop()
	While !EoF()

		RecLock((cTRBIP),.F.)

		If (cTRBIP)->STATUS == "1" .And. !lPartInput
			DbDelete()
		ElseIf (cTRBIP)->STATUS == "2" .And. !lTotInput
			DbDelete()
		ElseIf (cTRBIP)->STATUS == "0" .And. !lPendInput
			DbDelete()
		EndIf

		MsUnLock()

		dbSelectArea(cTRBIP)
		DbSkip()
	End

	//Atualiza Insumos Previstos
	(cTRBIP)->(dbGoTop())
	oBrw2:oBrowse:Refresh()
	oPnlInput:Enable()

Return nil

//--------------------------------------------------------------
/*/{Protheus.doc} MNTA435Log
Apresenta log com inconsistências no processo de gravação das O.S .
@type function

@author Alexandre Santos
@since 06/02/2019

@param aMsgRM    , array, Ordens que não podem ser canceladas
@param aMsgCancel, array, Lista de registros que não puderam ser
gravados pois já estavam cancelados.
							[1] - Ordem de Serviço
							[2] - Plano de Manutenção
@return
/*/
//--------------------------------------------------------------
Function MNTA435Log( aMsgRM, aMsgCancel )

	Local nX       := 0
	Local cText    := ''
	Local cOrder   := ''
	Local cPlano   := ''
	Local cFile    := ''
	Local cTipReg  := ''
	Local cDescIns := ''
	Local cDescTar := ''
	Local oPnl     := Nil
	Local oDlg     := Nil
	Local bSave    := { || ( cFile := cGetFile( STR0372, STR0373 ), If( cFile == '', .T., MemoWrite( IIf( '.txt' $ cFile, cFile, AllTrim( cFile ) + '.txt' ), cText ) ), oDlg:End() ) }

	Default aMsgRM     := {}
	Default aMsgCancel := {}

	DEFINE MSDIALOG oDlg TITLE STR0375 From 3,0 TO 340,417 COLOR CLR_BLACK,CLR_WHITE PIXEL // Inconsistências de gravação

		oPnl := TPanel():New( ,,, oDlg,,,,,,,, .F., .F. )
			oPnl:Align := CONTROL_ALIGN_ALLCLIENT

			oMemo := tMultiGet():New( 5 , 5 , {|u| If( Pcount() > 0 , cText := u , cText )} , oDlg , 200 , 145,,,,,,.T.,,,,,, .T. )
			oMemo:bRClicked := { || AllwaysTrue() }
			oMemo:lReadOnly := .T.

			SButton():New( 153, 145, 13, bSave, oDlg, .T. ) //Salvar Como
			SButton():New( 153, 175, 01, { || oDlg:End() }, oPnl, .T. ) // OK

			// Montagem da estrutura da mensagem de LOG para inconsitêsncias no processo de gravação de insumos.
			If !Empty( aMsgRM )

				oMemo:AppendText( '#######################################################' + CRLF )

				// Foram encontradas inconsistências no processo de integração.
				oMemo:AppendText( CRLF + STR0390 + CRLF + CRLF )

				For nX := 1 To Len( aMsgRM )

					cTipReg := IIf( aMsgRM[nX, 5] == 'P', STR0127, STR0365 ) //Produto # Mão de Obra

					If aMsgRM[nX, 5] == 'P'
						cDescIns := Posicione( 'SB1', 1, xFilial( 'SB1' ) + aMsgRM[nX, 6], 'B1_DESC' )
					Else
						cDescIns := Posicione( 'ST1', 1, xFilial( 'ST1' ) + aMsgRM[nX, 6], 'T1_NOME' )
					EndIf

					cDescTar := Posicione( 'TT9', 1, xFilial( 'TT9' ) + aMsgRM[nX, 4], 'TT9_DESCRI' )

					If cPlano != aMsgRM[nX, 3] .Or. cOrder != aMsgRM[nX, 2]

						oMemo:AppendText( '-------------------------------------' + CRLF )

						oMemo:AppendText( STR0366 + aMsgRM[nX, 2] + CRLF ) // Ordem de Serviço
						oMemo:AppendText( STR0367 + aMsgRM[nX, 3] + CRLF + CRLF ) // Plano Manutenção

					EndIf

					oMemo:AppendText( STR0376 + Trim( aMsgRM[nX, 4] ) + ' - ' + cDescTar + CRLF ) //Tarefa:
					oMemo:AppendText( STR0368 + cTipReg          + CRLF ) // Tipo Insumo
					oMemo:AppendText( STR0374 + Trim( aMsgRM[nX, 6] ) + ' - ' + cDescIns + CRLF ) //Código:
					oMemo:AppendText( STR0369 + aMsgRM[nX, 7] + CRLF ) //Seq. Insumo
					oMemo:AppendText( STR0370 + aMsgRM[nX, 8] + CRLF ) //Seq. SD3
					oMemo:AppendText( STR0371 + aMsgRM[nX, 1] + CRLF ) //Inconsistência

					cOrder := aMsgRM[nX, 2]
					cPlano := aMsgRM[nX, 3]

				Next nX

			EndIf

			// Montagem da estrutura da mensagem de LOG para inconsitêsncias no processo de alteração de O.S.
			If !Empty( aMsgCancel )

				oMemo:AppendText( CRLF + '#######################################################' + CRLF + CRLF )

				// Algumas alterações não foram gravadas, pois as ordens de serviço listadas a seguir foram canceladas por meio de outra rotina ou usuário.
				oMemo:AppendText( STR0388 + CRLF + CRLF )

				For nX := 1 To Len( aMsgCancel )

					oMemo:AppendText( '---------------------------------' + CRLF )
					oMemo:AppendText( STR0366 + aMsgCancel[nX,1] + CRLF ) // Ordem de Serviço
					oMemo:AppendText( STR0367 + aMsgCancel[nX,2] + CRLF ) // Plano Manutenção

				Next Nx

				oMemo:AppendText( '---------------------------------' + CRLF )

				// Atualize a listagem de ordens de serviço no browse principal da rotina ou realize a reabertura das ordens de serviço listadas pela rotina MNTA260.
				oMemo:AppendText( CRLF + STR0389 + CRLF )

			EndIf

			oMemo:GoTop()

	ACTIVATE MSDIALOG oDlg CENTERED

Return

//--------------------------------------------------------------
/*/{Protheus.doc} fValInsOco
Valida o insumo selecionado ao mudar para folder de ocorrências

@author Maria Elisandra de Paula
@since 10/06/2019

@param nPosInsumo, numerico, posição do insumo no acols
@param nPos, numerico, posição do campo tiporeg no acols de insumos
@param nPox, numerico, posição do campo código no acols de insumos

@return boolean
/*/
//--------------------------------------------------------------
Static Function fValInsOco( nPosInsumo, nPos, nPox )

	Local lOkOcor := .T.

	If Len( aCoBrw6 ) == 1 .And. Empty( aCoBrw6[ 1, nPos ] ) .And. Empty( aCoBrw6[ 1, nPox ] )
		//"As Ocorrências devem ser relacionadas aos insumos realizados" # "mas no momento não existe nenhum insumo realizado."
		MsgInfo( STR0377 + Space( 1 ) + STR0378 )
		lOkOcor := .F.
	EndIf

	//-------------------------------------
	//O insumo selecionado está deletado
	//-------------------------------------
	If lOkOcor .And. ( nPosInsumo > Len( aCoBrw6 ) .Or. ;
		aCoBrw6[ nPosInsumo, Len( aCoBrw6[ nPosInsumo ] ) ] )
		//"As Ocorrências estão relacionadas aos insumos realizados mas o insumo selecionado está deletado."
		MsgInfo( STR0377 + Space( 1 ) + STR0380 )
		lOkOcor := .F.
	EndIf

	If lOkOcor .And. Empty( aCoBrw6[ nPosInsumo, nPos ] ) .And. Empty( aCoBrw6[ nPosInsumo, nPox ] )
		//"As Ocorrências estão relacionadas aos insumos realizados mas o insumo selecionado não está preenchido."
		MsgInfo( STR0377 + Space( 1 ) + STR0379 )
		lOkOcor := .F.
	EndIf

Return lOkOcor

//-----------------------------------------------------------------------
/*/{Protheus.doc} fRecord
Verifica se a etapa já está gravada no banco com funcionário preenchido

@author Maria Elisandra de Paula
@since 10/06/2019

@param cTRBQ400, string, tabela temporária de etapas
@return boolean
/*/
//-----------------------------------------------------------------------
Static Function fRecord( cTRBQ400 )

	Local lRecorded := .F.
	Local cAliasQry := GetNextAlias()

	BeginSQL Alias cAliasQry

		SELECT TQ_OK
		FROM %table:STQ% STQ
		WHERE TQ_FILIAL = %xFilial:STQ%
			AND TQ_ORDEM = %exp:(cTRBQ400)->TQ_ORDEM%
			AND TQ_PLANO = %exp:(cTRBQ400)->TQ_PLANO%
			AND TQ_TAREFA = %exp:(cTRBQ400)->TQ_TAREFA%
			AND TQ_ETAPA = %exp:(cTRBQ400)->TQ_ETAPA%
			AND TQ_CODFUNC <> %exp:' '%
			AND %NotDel%

	EndSQL

	lRecorded := !( cAliasQry )->( Eof() )

	( cAliasQry )->( dbCloseArea() )

Return lRecorded

//-------------------------------------------------------------------
/*/{Protheus.doc} fCallRef
Verifica se possui O.S. para atualizar a grid para evitar dupla
chamada da função fRefreshOS.

@author Eduardo Mussi
@since  04/02/2020
@Param  nLinePos, Numérico, Linha posicionada na grid de O.S.
/*/
//-------------------------------------------------------------------
Static Function fCallRef( nLinePos )

	If Type( 'aOS' ) == 'A' .And. Len( aOS ) > 1
		fRefreshOS( aOS[ nLinePos, nPosOS], aOS[ nLinePos, nPosPL ], nLinePos, 1 )
	EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} ProdutoPn
Verifica se insumo é um pneu

@author Maria Elisandra de Paula
@since 09/06/2021
@param cProduto, string, código do produto
@param cLocal, string, código do almxarifado
@param cOrdem, string, código da ordem de serviço
@return logic, se insumo é um pneu
/*/
//-------------------------------------------------------------------
Static Function ProdutoPn( cProduto, cLocal, cOrdem )

	Local lRet      := .F.
	Local cAliasQry := GetNextAlias()

	BeginSQL Alias cAliasQry
		SELECT COUNT( TQZ.TQZ_CODBEM ) QNT
		FROM %table:TQZ% TQZ
		JOIN %table:STZ% STZ
			ON STZ.TZ_FILIAL = %xFilial:STZ%
			AND STZ.TZ_ORDEM = %exp:cOrdem%
			AND STZ.TZ_CODBEM = TQZ.TQZ_CODBEM
			AND TQZ.TQZ_DTSTAT || TQZ.TQZ_HRSTAT <= STZ.TZ_DATAMOV || STZ.TZ_HORAENT
			AND STZ.%NotDel%
		WHERE TQZ.%NotDel%
			AND TQZ.TQZ_PRODUT = %exp:cProduto%
			AND TQZ.TQZ_ALMOX = %exp:cLocal%
			AND TQZ.TQZ_FILIAL = %xFilial:TQZ%

	EndSql

	lRet := (cAliasQry)->QNT > 0

	(cAliasQry)->( dbCloseArea() )

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fQntEmp
Retorna a quantidade de produtos empenhada para a ordem de serviço

@author Maria Elisandra de Paula
@since 27/04/2021
@param cProduto, string, código do produto
@param cAlmox, string, código do almoxarifado
@param cOrdem, string, código da ordem de serviço
/*/
//-------------------------------------------------------------------
Static Function fQntEmp( cProduto, cAlmox, cOrdem )

	Local nReturn   := 0
	Local cAliasQry := GetNextAlias()
	Local cCodProd  := Padr( cProduto, TamSx3('D4_COD')[1] )
	Local cOPD4     := Padr( cOrdem + 'OS001', TamSx3('D4_OP')[1] )

	BeginSql Alias cAliasQry

		SELECT ISNULL( SUM ( SD4.D4_QUANT ), 0 ) QUANT
		FROM %Table:SD4% SD4
		WHERE SD4.%NotDel%
			AND SD4.D4_OP = %Exp:cOPD4%
			AND SD4.D4_COD = %Exp:cCodProd%
			AND SD4.D4_LOCAL = %Exp:cAlmox%
			AND SD4.D4_FILIAL = %xFilial:SD4%

	EndSql

	nReturn += (cAliasQry)->QUANT

	(cAliasQry)->( dbCloseArea() )

Return nReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} fQntEmp
Apresenta perguntas para parametrização da rotina.
@type function

@author Alexandre Santos
@since 18/04/2022
/*/
//-------------------------------------------------------------------
Static Function fPerg435()

	/*-------------------------------------------------+
	| Perguntas para parametrização da rotina MNTA435. |
	+-------------------------------------------------*/
	Pergunte( 'MNT435', .T. )

	/*--------------------------------------------------+
	| Atribuição da váriavel de controle das perguntas. |
	+--------------------------------------------------*/
	cMVPAR01 := cValToChar( MV_PAR01 )

	/*--------------------------------------------------------------------+
	| Recarrega informações da O.S. posicionada conforme novas definições |
	+--------------------------------------------------------------------*/
	fRefreshOS( aOS[oOS:nAt,nPosOS], aOS[oOS:nAt,nPosPL] , oOS:nAt, 1 )

	/*-------------------------------------------------------+
	| Atualiza objeto de controle da lista principal de O.S. |
	+-------------------------------------------------------*/
	oOS:Refresh()
	
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fInteg
Realiza o processo de integração com estoque ao finalizar a O.S.
@type function

@author Alexandre Santos
@since 19/08/2022

@param cOServ  , string, O.S. que está sendo finalizada.

@return boolean, Indica se o processo foi realizado com êxito.
/*/
//-------------------------------------------------------------------
Static Function fInteg( cOServ )

	Local cOProd   := PadR( cOServ + 'OS001', FwTamSX3( 'D4_OP' )[1] )
	Local lRet     := .T.

	/*-------------------------------------------------------------------------+
	| Consiste se o dicionário e RPO estão atualizados para o uso do ExecAuto. |
	+-------------------------------------------------------------------------*/
	If NgVldRpo( { { 'MNTUTIL.prx', SToD( '20220825' ), '08:00' } } ) .And. MntUseExec()
	
		BEGIN TRANSACTION

			dbSelectArea( 'SD4' )
			dbSetOrder( 2 ) // D4_FILIAL + D4_OP + D4_COD + D4_LOCAL
			If dbSeek( FWxFilial( 'SD4' ) + cOProd )

				/*--------------------------------------------------------+
				| ExecAuto MATA381 para zerar os espenhos não utilizados. |
				+--------------------------------------------------------*/
				lRet := MntExecSD4( cOProd )[1]

				If !lRet

					DisarmTransaction()

					BREAK

				EndIf

			EndIf

		END TRANSACTION

	EndIf

Return lRet
