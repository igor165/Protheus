#INCLUDE "PROTHEUS.CH"
#INCLUDE "LOJXFUNE.CH"
#INCLUDE "FILEIO.CH"
#INCLUDE "DIRECTRY.CH"

Static lCalcCab		:= .T.
Static lCenVenda 	:= SuperGetMv("MV_LJCNVDA",,.F.)
Static aUltTab		:= {}
Static aUltTabCli 	:= {}
Static aDesProCom	:= {} 
Static aTabXPreco	:= {}
Static aTabelas		:= {}
Static lNovRegDesc	:= SuperGetMv("MV_LJRGDES",,.F.) .AND. RGVldTable()		// Validacao da Nova Regra de Desconto Ativa
Static lRgAcumul	:= .T.													// Regra de Desconto acumulativa
Static lLJ7108      := ExistBlock("LJ7108") 								// PE para customizar a tabela de preco
Static cMvLjTGar	:= SuperGetMV("MV_LJTPGAR",,"GE")						// Tipo de Garantia Estendida
Static cMvLjRetVl	:= SuperGetMV("MV_LJRETVL",,"3") 						// 1=Retorna o menor preco de uma tabela | 2=Retorna o maior preco de uma tabela | 3=Considera preco da tabela configurada no parametro MV_TABPAD
Static lSFinanc		:= SuperGetMV("MV_LJCSF",,.F.)							// Valida็ใo do Conceito Servico Financeiro
Static cMvLjTSF		:= SuperGetMV("MV_LJTPSF",,"SF")						// Tipo de servico financeiro
Static cMV_TABPAD 	:= SuperGetMv("MV_TABPAD")								// C๓digo da Tabela de Pre็o Padr?o
Static lLjCnVB0		:= SuperGetMv("MV_LJCNVB0",,.F.)						// Retorna pre็o da SB0 na aus๊ncia do pre็o do Produto na DA0 e DA1
Static lMVLJECOMM 	:= SuperGetMV("MV_LJECOMM",,.F.)						// Integra็?o com e-commerce
Static cMV_CLIPAD	:= SuperGetMV("MV_CLIPAD")       					 	// Cliente padrao
Static cMV_LOJAPAD	:= SuperGetMV("MV_LOJAPAD")       						// Loja do cliente padrao
Static cNumCaixa	:= xNumCaixa()											// Numero do Caixa Logado no sistema
Static aPeLJ7108	:= {}													// Controla o retorno do PE LJ7108 para nใo executแ-lo diversas vezes. Deve executar apenas 1 vez para cada item da venda.
Static aRetMTabPr	:= {}													// Controla o retorno da fun็ใo MaTabPrVen para nใo executแ-la diversas vezes para resgatar o pre็o do mesmo produto.

/*
ฑฑบPrograma  ณLjRgrDesc บAutor  ณVendas CRM          บ Data ณ  27/10/08   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณAvaliacao das regras de desconto para utilizacao na venda   บฑฑ
ฑฑบ          ณassistida e venda balcao                                    บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบParametrosณExpC1: Produto                                              บฑฑ
ฑฑบ          ณExpC2: Cliente                                              บฑฑ
ฑฑบ          ณExpC3: Loja                                                 บฑฑ
ฑฑบ          ณExpC4: Tabela                                               บฑฑ
ฑฑบ          ณExpN5: Faixa de desconto                                    บฑฑ
ฑฑบ          ณExpN6: Tipo de Desconto                                     บฑฑ
ฑฑบ          ณ       1 - Desconto por Item                                บฑฑ
ฑฑบ          ณ       2 - Desconto por Total                               บฑฑ
ฑฑบ          ณExpA7: Array contendo a seguinte estrutura :                บฑฑ
ฑฑบ          ณ       [n][1] : Codigo do produto                           บฑฑ
ฑฑบ          ณ       [n][2] : Grupo  do produto                           บฑฑ
ฑฑบ          ณ       [n][3] : Quantidade                                  บฑฑ
ฑฑบ          ณ       Devem ser passados tods os produtos e as suas Qtdes. บฑฑ
ฑฑบ          ณ       para ocalculo de descontos escalaveis.               บฑฑ
ฑฑบ          ณExpA8: Array contendo as regras que NAO devem ser considera-บฑฑ
ฑฑบ          ณ       das.                                                 บฑฑ
ฑฑณ          ณExpC9: Codigo da Regra de Desconto usada.	    			  บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบRetorno   ณExpN1: Percentual de Desconto da Regra                      บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณLOJA701                                                     บฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿*/
Function LjRgrDesc(cProduto,cCliente,cLoja,cTabPreco,nFaixa,nTipo,aProds,aExc,cCodRegDe,nVlrItem,cTipoProd, lPrdRegDes)

Local aArea			:= GetArea()
Local nDesc			:= 0   
Local dDatTerm      := ""
Local aAreaACO		:= {}
Local nPosCpoIt     := 0
Local nPosItem      := 0
Local nVlrIt		:= 0
Local nPosVlItem    := 0
Local lDesProCom    := 0
Local nUnitario		:=0 	//Valor Unitario do item
Local nPosUnit		:=0 	//posicao do campo UNITARIO
Local cCondPg		:= ""

Default cProduto	:= "" 	// Produto que serแ realizada a busca do desconto
Default cCliente	:= ""	// Informacoes do Cliente
Default cLoja		:= ""	// Loja.
Default cTabPreco	:= ""	// Tabela de Pre็o.
Default cCodRegDe	:= ""	// Codigo da Regra de Desconto.
Default aProds		:= {}	// Produtos.                  
Default aExc		:= {}	// Execu็ใo.
Default nFaixa		:= 0	// Faixa.
Default nTipo		:= 0	// Tipo.
Default nVlrItem	:= 0	// Valor do Item caso seja Front Loja.
Default cTipoProd 	:= ""	// Tipo de produto na venda, Saldao ou Mostruario
Default lPrdRegDes	:= .F.	// Indica se o produto possui alguma Regra de Desconto, independente da quantidade       

//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
//ณQuando o desconto for por item, precisa do valor unitario ณ 
//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
If (nTipo == 1)
	If nModulo == 23 //se vier do Front Loja
		nUnitario := nVlrItem / nFaixa
	Else
		nPosUnit := aScan(aHeader,{|x| AllTrim(x[2]) == "LR_VRUNIT"   })  //posicao do campo UNITARIO
		nUnitario 	:= aCols[n][nPosUnit]
	EndIf
EndIf

//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
//ณNao serao consideradas as condicoes e formas de pagamento.ณ
//ณPor serem definidas somente no final do processo da venda ณ
//ณconcomitante, nos modulos SIGALOJA e SIGAFRT, estes       ณ
//ณcampos nao serao considerados nos criterios para aplicacaoณ
//ณdas Regras de Desconto.                                   ณ
//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
If (lNovRegDesc .And. lCenVenda)      
	
	If nTipo == 1  // Desconto Item
	
		//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
		//ณValidacao do modulo para verificar o tipo de produto      ณ
		//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู	
		If nModulo == 12 .Or. nModulo == 5		//Venda Assistida
			cTipoProd := IIF( "LR_VDMOST" $ ReadVar(), M->LR_VDMOST, GdFieldGet("LR_VDMOST",n) )
		EndIf

		nDesc := RGDesIte(cProduto, cCliente, cTipoProd, cLoja, , nFaixa, , @lPrdRegDes)				
		
	Else    // Desconto Total  

		// Guardar a variแvel de Regra Acumulativa para processar as regras de desconto por total,
		// depois devolver
		nDesc := RGDesTol(.F., aTotais[1,2], Nil, Nil, cCliente, cLoja)

	EndIf			
Else
	If nModulo == 12 .Or. nModulo == 5
		cCondPg := M->LQ_CONDPG
	EndIf

	nDesc := MaRgrDesc(cProduto,cCliente,cLoja,cTabPreco,nFaixa,cCondPg,/*cFormPg*/,nTipo,aProds,aExc, @cCodRegDe, nUnitario) 	
	//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
	//ณRotina responsแvel por alimentar o Array "ADesProcom"ณ
	//ณcom informa็๕es dos Produtos que fazem parte     	ณ
	//ณda regra de negocio, como: Codigo +        			ณ
	//ณvalor do desconto + Data Validade do Desconto.   	ณ
	//ณSomente realiza, caso o Cliente nao seja o Padrao    ณ
	If lCenVenda .AND. !Empty(nDesc)  

	    aAreaACO := ACO->(GetArea())
	    DbSelectArea("ACO")                     //TABELA ACO - REGRA DE DESCONTO
	    ACO->(DbSetOrder(1)) 							//ACO_FILIAL+ACO_CODREG
	    If ACO->(DbSeek(xFilial("ACO")+cCodRegDe))
			//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
			//ณRealiza a Rotina de Desconto na Proxima Venda, somente     ณ
			//ณcaso esteja selecionada no Lan็amento da Regra de          ณ
			//ณDesconto e Se o Cliente Utilizado no Momento for Diferente ณ
			//ณdo Cliente Padrใo                                          ณ
			//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
			lDesProCom 		:= ACO->ACO_DESCPR 
			If lDesProCom .AND. (cCliente+cLoja <> cMV_CLIPAD+cMV_LOJAPAD )
				dDatTerm	:= ACO->ACO_DATATE
				//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
				//ณBusca a ordem de lancamento do Item caso seja Loja atrav้s do LR_Item no aCols  ณ
				//ณe caso seja Front, atrav้s do L2_Item, para armazenamento no array com as infos ณ
				//ณdos produtos e posteriormente seja utilizado no momento para Dele็ใo do Item.   ณ
	 			//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
				If nModulo <> 23
					nPosCpoIt	:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_ITEM"})][2]		// Numero da Posicao do item.	
					nPosVlItem	:= aScan(aHeader,{|x| AllTrim(x[2]) == "LR_VLRITEM"}) 						// Numero da Posicao do Valor do item.
					nPosItem    := aCols[n][nPosCpoIt]                                                     // Posicao de Lancamento do item.
					nVlrIt	    := aCols[n][nPosVlItem]                                                    // Valor do Item para o Calculo.
				Else
					nVlrIt      := nVlrItem  // Valor do Item do Front Loja
				EndIf
				//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
				//ณPreenche no array aDesProCom os Produtos com as infos:      ณ
				//ณValor do Desconto, Data Limite, Posi็ao do Item, somente se ณ
				//ณeste item esteja com desconto atribuํdo atrav้s da Regra de ณ
				//ณDesconconto do Cenแrio de Vendas.                           ณ
				//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
				If !Empty(nDesc)    
					AAdd(aDesProCom, {cProduto,nVlrIt,nDesc,dDatTerm,nPosItem} )
	   		 		nDesc := 0
				EndIf
	    	EndIf
	    EndIf
	EndIf
EndIf
RestArea(aArea)

Return nDesc

/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัออออออออออหอออออออัออออออออออออออออออออหออออออัอออออออออออออปฑฑ
ฑฑบPrograma  ณLjGetCVar บ Autor ณ	Vendas & Crm     บ Data ณ  20/12/10   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณTransporta o valor da variavel aDesProCom.				  บฑฑ
ฑฑบ          ณ                                                            บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบParametrosณ Nil                                                        บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณ LOJA701                                                    บฑฑ
ฑฑศออออออออออฯออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function LjGetCVar()
Return aDesProCom

/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออหออออออออออหอออออออหออออออออออออออออออออหออออออหอออออออออออออปฑฑ
ฑฑบPrograma  บLjSetCVar บ Autor บ	Vendas & Crm     บ Data บ  24/12/10   บฑฑ
ฑฑฬออออออออออสออออออออออสอออออออสออออออออออออออออออออสออออออสอออออออออออออนฑฑ
ฑฑบDesc.     ณ															  บฑฑ
ฑฑบ			 ณAtualiza o valor da variavel aDesProCom enviado por outros  บฑฑ
ฑฑบ			 ณfontes				  									  บฑฑ
ฑฑบ          ณ                                                            บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบParametrosณ Nil                                                        บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณ LOJA701                                                    บฑฑ
ฑฑศออออออออออฯออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function LjSetCVar(aSetVal)
Default aSetVal:= {}

aDesProCom := aClone(aSetVal)

Return

/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัออออออออออหอออออออัออออออออออออออออออออหออออออัอออออออออออออปฑฑ
ฑฑบPrograma  ณLOJXFUNE  บAutor  ณMicrosiga           บ Data ณ  28/10/08   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณAplica o desconto no item de acordo com a regra de negocios บฑฑ
ฑฑบ          ณ                                                            บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบParametrosณExpC1 - Codigo do produto                                   บฑฑ
ฑฑบ          ณExpC2 - Codigo do cliente                                   บฑฑ
ฑฑบ          ณExpC3 - Loja do cliente                                     บฑฑ
ฑฑบ          ณExpN4 - Quantidade vendida                                  บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณ LOJA701                                                    บฑฑ
ฑฑศออออออออออฯออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function LjDescItem( cProduto , cCliente	, cLoja, nQuant,; 
					 cCodRegDe, nVlDesReg	, lScCsPreco)
Local cBkReadV		:= ""								   			    	// Backup da variavel __ReadVar
Local nRegDesc		:= 0								  			     	// Valor do desconto calculado pela regra
Local nPosDesc		:= Ascan(aHeader,{|x| AllTrim((x[2]))=="LR_DESC"})  	// Posicao do percentual de desconto
Local lVAssConc	 	:= SuperGetMV("MV_LJVACC", ,.F.) .Or. LjVassConc(1)    	// Indica se o cliente utiliza a Vda Assistida Concomitante
Local lRet			:= .F.												    // Indica se houve desconto atraves da regra 
Local cTabPreco		:= LjXETabPre(cCliente,cLoja) 						    // Parametro da tabela de preco padrao

Default nQuant      := 0    
Default cCodRegDe   := ""													// Codigo da Regra de desconto usada
Default nVlDesReg   := 0													// Valor de desconto consedido pela regra de desconto
Default lScCsPreco	:= .F.													// Usado na integracao Protheus x SIAC. Indica se o Protheus 
																			//utiliza a consulta WS para consultar o preco no SIAC Store

If !IsInCallStack("LJ7VALCLI")
	//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
	//ณCalcula o desconto a partir da regra de descontos - ITENSณ
	//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
	nRegDesc := LjRgrDesc(cProduto,cCliente,cLoja,cTabPreco,nQuant,1,/*aProds*/,/*aExc*/, @cCodRegDe)
EndIf

nVlDesReg := nRegDesc

//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
//ณSe houver desconto, aciona a rotina Lj7VlItem() novamente,ณ
//ณpara executar o calculo do desconto, a partir do campo    ณ
//ณM->LR_DESC.                                               ณ
//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
If nRegDesc > 0
	
	cBkReadV			:= __ReadVar
	__ReadVar			:= "M->LR_DESC"
	M->LR_DESC			:= nRegDesc
	
	//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
	//ณNa venda concomitante, o valor de desconto deve ser ณ
	//ณregistrado apos a funcao Lj7VlItem().               ณ
	//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
	If !lVAssConc
		aCols[n][nPosDesc]	:= nRegDesc
	Else
		aCols[n][nPosDesc]	:= 0
	EndIf
	
	Lj7VlItem(3,.T.)

	If lVAssConc
		aCols[n][nPosDesc]	:= nRegDesc
	EndIf
	
	__ReadVar	:= cBkReadV
	lRet		:= .T.  
	
EndIf

Return lRet

/*
ฑฑบPrograma  ณLjDescCab บAutor  ณVendas CRM          บ Data ณ  10/28/08   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณCalcula o desconto a partir da regra de descontos - TOTAL   บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณLOJA701                                                     บฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿*/
Function LjDescCab(	cProduto, cCliente	, cLoja		, aCols		,;
					aHeader	, nFaixa	, lConsulta	, nRegDesc )

Local aProds		:= {}
Local lRegDesc      := .F. 
Local nX			:= 0
Local nPosProd		:= aScan(aHeader,{|x| AllTrim(x[2]) == "LR_PRODUTO"})	// Posicao do codigo do produto
Local nPosQuant		:= aScan(aHeader,{|x| AllTrim(x[2]) == "LR_QUANT"})	// Posicao da Quantidade
Local nPosVlItem	:= aScan(aHeader,{|x| AllTrim(x[2]) == "LR_VLRITEM"})	// Posicao do Valor do item
Local cTabPreco		:= LjXETabPre(cCliente,cLoja) 							//parametro da tabela de preco padrao

Default lConsulta	:= .F.

nRegDesc := 0 

LjGrvLog( NIL, " Inicio da fun็ใo LjDescCab - Regra de Desconto no Total")

//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
//ณSe o desconto no total foi ajustado manualmente, nao havera    ณ
//ณmais controle de desconto por regra nos totais para esta venda.ณ
//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
If !lCalcCab
	lRegDesc := Nil
	LjGrvLog( NIL, " Desconto foi ajustado manualmente - nใo pode aplicar a Regra de Desconto",lCalcCab)
Else
	/*Cria lista de produtos da venda para a rotina 
	de regra de	descontos na estrutura:                                   
	{{cProduto,cGrupo,nQuantidade};                           
	{cProduto,cGrupo,nQuantidade}}*/	
	SB1->( DbSetOrder(1) )
	For nX := 1 to Len(aCols)
		If !aTail(aCols[nX])
			SB1->( DbSeek(xFilial("SB1")+aCols[nX][nPosProd]) )
			AAdd(aProds,{aCols[nX][nPosProd],;
						SB1->B1_GRUPO,;
						aCols[nX][nPosQuant]})
		EndIf
	Next nX
	
	//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
	//ณVerifica se ha desconto para toda a venda e aplica-oณ
	//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
	If Len(aProds) > 0
		
		nRegDesc := LjRgrDesc(cProduto,cCliente,cLoja,cTabPreco,nFaixa,2,aProds,/*aExc*/)
		
		If nRegDesc > 0 .OR. ( (!lNovRegDesc .Or. nRegDesc == 0) .AND. Lj7T_DescV(2) > 0 )
			If !lConsulta
				/***** Aplica o desconto *******/
				LJ7VldDesc( Nil, nRegDesc)
			EndIf
			                                                 
			lRegDesc := .T.
		EndIf		
	EndIf
EndIf

LjGrvLog( NIL, " Regra de Desconto no Total - Valor ",nRegDesc)
LjGrvLog( NIL, " Regra de Desconto no Total - Tem Regra?",lRegDesc)
LjGrvLog( NIL, " Regra de Desconto no Total - Consulta de Regra?", lConsulta)
LjGrvLog( NIL, " Final da fun็ใo LjDescCab - Regra de Desconto no Total")

Return lRegDesc

/*
ฑฑบPrograma  ณLjDescRst บAutor  ณVendas CRM          บ Data ณ  28/10/08   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณReinicia as variaveis estaticas de controle das funcoes paraบฑฑ
ฑฑบ          ณmanipulacao de regras de desconto.                          บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณLOJA701                                                     บฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿*/
Function LjDescRst()

lCalcCab	:= .T.
LjSetRAcumul(.T.)  // Reinicia como .T. ao (re)come็ar a venda assistida 

Return Nil

/*
ฑฑบPrograma  ณLjDescOff บAutor  ณVendas CRM          บ Data ณ  28/10/08   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณDesabilita o calculo de descontos para o total da venda     บฑฑ
ฑฑบ          ณatraves das regras de desconto para a venda atual           บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณLOJA701                                                     บฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿*/
Function LjDescOff()
lCalcCab	:= .F.
Return Nil

/*
ฑฑบPrograma  ณLjxeTPrecoบAutor	ณVendas CRM			 บ Data ณ  30/10/08   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณRetorna o preco de venda da tabela de precos padrao		  บฑฑ
ฑฑบ          ณ                                                            บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบParametrosณExpC1: Produto                                              บฑฑ
ฑฑบ          ณExpC2: Codigo do Cliente                                    บฑฑ
ฑฑบ          ณExpC3: Codigo da Loja                                       บฑฑ
ฑฑบ          ณExpN4: Moeda                                                บฑฑ
ฑฑบ          ณExpN5: Quantidade do Item                                   บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบRetorno   ณExpN1: Valor de venda do produto encontrado na tabela       บฑฑ
ฑฑบUso       ณLOJA701 e FRTA271                                           บฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿*/
Function LjxeTPreco(cProduto, cCliente, cLoja, nMoeda, ;
							nQtdade, cTabPadIn)

Local nRet 			:= 0							// Variavel de retorno do preco
Local cTabPrecos    := LjXETabPre(cCliente,cLoja)	// Parametro da tabela de preco padrao
Local nPosQuant		:= 0							// Posicao da Quantidade
Local nPosVlUnit	:= 0							// Posicao do Valor unitario do item
Local nPosProd		:= 0							// Posicao do Codigo do Produto
Local nPosItCob		:= 0
Local nPosEnvelo    := 0                            // Posicao do codigo do envelope
Local nX			:= 0							// Variavel de controle de For
Local aValores		:= {}
Local lGE			:= LjUP104ok() 					// Valida็ใo do Conceito Garantia Estendida
Local aRet			:= {} 							// Retorno preco servico
Local cTabPad		:= IIF(!lLJ7108, Alltrim(cMV_TABPAD),cTabPrecos)	//Para manter o legado foi realizado protecao para uso do PE, porem, rotina LjXETabPre ja retorna MV_TABPAD quando nao utiliza o PE


Default nQtdade 	:= 1 
Default cTabPadIn	:= IIF(nModulo == 23,cMV_TABPAD,Lj7DefTab())
                            
//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
//ณSigaPhoto e produto for uma revelacao, o valor unitario |
//ณvira das funcoes especificas do SigaPhoto.              |
//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
If nModulo == 72
	nPosVlUnit	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_VRUNIT"})][2]
	nPosEnvelo	:= Ascan(aPosCpoDet, { |x| Upper (Alltrim (x[1])) == "LR_ENVELO"})
	
	If SB1->(FieldPos("B1_ESPECIF")) > 0  .AND. nPosEnvelo > 0
		If ALLTRIM(SB1->B1_ESPECIF) == "R"
			nRet := aCols[n][nPosVlUnit]
		EndIf
	Else
		Conout(STR0010) //"Para utiliza็ใo do modulo SIGAPHOTO ้ necessario a cria็ใo dos campos B1_ESPECIF e LR_ENVELO."
	EndIf
EndIf

//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
//ณVerifica pre็o do produto de Garantia ou Servi็o.ณ
//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
If nRet == 0 
	If lGE .AND. (nModulo == 12) .AND. (SB1->B1_TIPO == cMvLjTGar)
		nRet   := Lj7ImpVlr(cProduto,NIL,NIL, cCliente, cLoja, nMoeda) 				          
	ElseIf lSFinanc .AND. (nModulo == 12) .AND. (SB1->B1_TIPO == cMvLjTSF)
		MG8->(DbSetOrder(2))
		 
		If (MG8->(DbSeek(xFilial("MG8")+cProduto)) .AND. MG8->MG8_TPXPRD == "1")
			nPosQuant	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_QUANT"})][2]	// Posicao da Quantidade
			nPosVlUnit	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_VRUNIT"})][2]	// Posicao do Valor unitario do item
			nPosProd	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_PRODUTO"})][2]	// Posicao do Codigo do Produto
			nPosItCob	:= IIf(SLR->(FieldPos("LR_ITEMCOB")) > 0, aScan(aPosCpo,{|x| Upper(Alltrim(x[1])) == "LR_ITEMCOB"}) ,0)
					
			//Servico financeiro - Carrega Preco									
			If aCols[n][nPosVlUnit] == 0 .AND. nPosItCob > 0 .AND. !Empty(aCols[n][nPosItCob]) 				 				
				nRet:= LjSfVl(cProduto,0,aCols[Val(aCols[n][nPosItCob])][nPosVlUnit], @aRet, .F., aCols[Val(aCols[n][nPosItCob])][nPosProd])				
			Else
				nRet:= aCols[n][nPosVlUnit]*aCols[n][nPosQuant]
			EndIf					
		EndIf						          
	EndIf
	
	If nRet == 0
		//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
		//ณVerifica o se esta ativo o Cenario de Vendasณ
		//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
		If lCenVenda	
			//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
			//ณConsiderada sempre a quantidade 1                           ณ
			//ณretorna o valor convertido pela moeda da tabela de preco DA1ณ
			//ณse nao encontrar tabela de preco, retorna valor do B0_PRN   ณ
			//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
			If cMvLjRetVl == "3"
				nRet := GetMaTabPr(cTabPad, cProduto, 1, cCliente, cLoja, nMoeda)
			EndIf						
			
			If cMvLjRetVl <> "3" .OR. nRet == 0
				nRet := GetMaTabPr(cTabPrecos, cProduto, 1, cCliente, cLoja, nMoeda)
			EndIf		
		Else                      
			nRet := GetAdvFVal("SB0", "B0_PRV" + cTabPadIn, xFilial("SB0") + cProduto, 1, 0)
		EndIf 
	   

		//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
		//ณApos verificar a variavel estatica, analisa se existe mais de ณ
		//ณuma tabela de preco ativa. Agora, verifica no MaTabPrVen      ณ
		//ณse existe preco para esse produto                             ณ
		// Chama a fun็ใo ljFilTab para filtrar e processar somente as
		// ativas. Havia situa็๕es onde havia 300 tabelas de preco, mas apenas
		// 20 ativas, o que gerava demora na busca do pre็o
		//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
		If lCenVenda .And. !lLJ7108
			If Len(aTabelas) > 0
				aTabXPreco := aClone(aTabelas)
				ljFilTab(@aTabXPreco,cProduto,nQtdade)
			EndIf
			
			For nX := 1 To Len(aTabXPreco)
				nRet := GetMaTabPr(aTabXPreco[nX], cProduto, nQtdade, cCliente, cLoja, nMoeda)
				//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
				//ณArmazena no array aValores os possiveis valores para ser ณ
				//ณpraticado para um produto. Esse array sera utilizado paraณ
				//ณavaliar, caso o produto pertenca a mais de uma tabela de ณ
				//ณpreco, para saber qual sera praticada.                   ณ
				//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
				If nRet > 0
					aAdd(aValores,nRet)
				EndIf
			Next nX	
			
			//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
			//ณSendo o aValores maior que um, significa que existe mais de ณ
			//ณum preco possivel para um unico produto na venda            ณ
			//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
			If Len(aValores) > 0
				//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
				//ณRetornando os valores, ordena do menor para o maior para ณ
				//ณser tomada a decisao posteriormente                      ณ
				//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
				aSort(aValores)
				//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
				//ณVerifica o parametro MV_LJRETVL e caso esteja "1"      ณ
				//ณsigniifca que utilizara o menor preco encontrado. Caso ณ
				//ณcontrario, utiliza o maior preco.                      ณ
				//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
				If cMvLjRetVl == "1"
					nRet := aValores[1]
				Else
					nRet := aValores[Len(aValores)]	  				
				EndIf
			EndIf
		EndIf
	
	EndIf 
Else                                                      
	nRet := Posicione("SB0",1,xFilial("SB0")+cProduto,"SB0->B0_PRV"+cTabPadIn) 
EndIf

Return nRet


/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัออออออออออหอออออออัออออออออออออออออออออหออออออัอออออออออออออปฑฑ
ฑฑบPrograma  ณLjxeValPreบAutor	ณVendas CRM			 บ Data ณ  30/10/08   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณValida se a tabela de preco existe e se o valor e maior	  บฑฑ
ฑฑบ          ณdo que zero.                                                บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบParametrosณExpC1: Codigo da tabela de preco padrao                     บฑฑ
ฑฑบ          ณExpC2: Codigo do Produto                                    บฑฑ
ฑฑบ          ณExpC3: Codigo do Cliente                                    บฑฑ
ฑฑบ          ณExpC4: Codigo da Loja                                   	  บฑฑ
ฑฑบ          ณExpN5: Moeda                                                บฑฑ
ฑฑบ          ณExpN6: Quantidade do Item                                   บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบRetorno   ณExpL1: Retorno logico para a validacao do preco             บฑฑ
ฑฑบUso       ณ                                                            บฑฑ
ฑฑศออออออออออฯออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function LjxeValPre(nPrecoTab, cProduto, cCliente, cLoja,;
					nMoeda   , nQtdade , lProdON, nValIpiEC, ;
					lTabIPI)

Local lRet 			:= .T.  	// Variavel de retorno
Local aArea			:= {}		// Armazena area atual (alias, order e recno)
Local aAreaDA0		:= {}		// Armazena area do DA0 (alias, order e recno)
Local cTabPrecos    := ""		// Parametro da tabela de preco padrao
Local lFtvdVer12	:= LjFTVD() // Verficar se a chamada foi realizada pelo Venda Direta
Local cMsgPdZero 	:= ""  		// Mensagem a ser apresentada qdo. produto estiver com preco zerado
Local lECommerce 	:= lMVLJECOMM .And. LJ862ECAuto() //Funcao auto pela Exportacao.
Local lECCia		:= lMVLJECOMM .And. SuperGetMV("MV_LJECOMO",,.F.) .AND. Lj901Auto()
Local aAreaSB1		:= {}
Local aAreaSF4		:= {}
Local nValIPIEn    	:= 0    
Local cTabPad		:= ""
Local nIteracao 	:= 1     
Local lAutoExC		:= IsBlind() .OR. If(Type("lAutoExec") == "L", lAutoExec, .F.)

Default nPrecoTab 	:= 0
Default cProduto    := ""
Default cCliente	:= cMV_CLIPAD
Default cLoja		:= cMV_LOJAPAD
Default nMoeda		:= 1
Default nQtdade 	:= 1
DEFAULT lProdON 	:= .F.   
DEFAULT nValIpiEC	:= 0 
DEFAULT lTabIPI		:= .F.

// Nใo deve validar tabela de pre็o quando integra็ใo EAI
// Pois deve respeitar o preco recebido
If IsInCallStack("LOJI701")
	Return .T.
EndIf

aArea		:= GetArea()
cTabPrecos  := LjXETabPre(cCliente,cLoja) 

If lCenVenda
       	
	aAreaDA0 := DA0->(GetArea())
	
	DbSelectArea("DA1")
	DA1->(DbSetOrder(1))  //DA1_FILIAL+DA1_CODTAB  

	If DA1->(DbSeek(xFilial("DA1")+cTabPrecos))          	
        If lECCia
        
        	lRet := Lj901APrc( @nPrecoTab)
			LjGrvLog("", "Validando pre็o Cenario de Vendas " + cValToChar(nPrecoTab) + " Retorno " + cValToChar(lRet))

		ElseIf (lNovRegDesc .And. nModulo <> 23)

			// Se o produto for garantia e houver faixa de preco 
			If SB1->B1_TIPO == cMvLjTGar
				nPrecoTab := LjxeTPreco(cProduto, cCliente, cLoja, nMoeda, nQtdade, cTabPrecos) 
			Endif	

			If nPrecoTab == 0
				nPrecoTab := RGDesIteVlProd(cProduto, , ,cCliente, cLoja)
			EndIf 
			
			//Se nใo atender nenhuma condi็ใo e o lLjCnVB0 estiver configurado para buscar o pre็o na tabela SB0    
			If lLjCnVB0 .AND. nPrecoTab == 0
				nPrecoTab := LjPrecoSB0(cProduto)
			EndIf 

			If nPrecoTab == 0 
				//STR0011 - "Para regra de desconto ser aplicada, deve constar o produto "
				//STR0012 - " na tabela de pre็o: "
				If !lAutoExC					
					MsgAlert(STR0011 + cProduto + CRLF + STR0012 + cTabPrecos)						
				Else
					Help( " ", 1, "Help",, STR0011 + cProduto + STR0012 + cTabPrecos, 1, 0 )	
				EndIf				
				lRet := .F.
			EndIf			
		Else
			If nQtdade == 0
				nQtdade := 1
			EndIf
			
			//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
			//ณRealiza a busca do preco do produto na Tabela de Precosณ
			//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู               
			nPrecoTab := LjXETPreco(cProduto, cCliente, cLoja, nMoeda, nQtdade, cTabPrecos)

			//Se nใo atender nenhuma condi็ใo e o lLjCnVB0 estiver configurado para buscar o pre็o na tabela SB0    
			If lLjCnVB0 .AND. nPrecoTab == 0
				nPrecoTab := LjPrecoSB0(cProduto)
			EndIf 
	
		  	If nPrecoTab == 0 
				//"Pre็o do produto zerado ou nใo cadastrado na tabela de pre็os "
				cMsgPdZero := STR0007 + If(cMvLjRetVl=="3",cTabPrecos,"")
				
				If !lAutoExC					
					MsgAlert(cMsgPdZero)					
				Else
					Help( " ", 1, "Help",, cMsgPdZero, 1, 0 )	
				EndIf				
				lRet := .F.
			EndIf
	
			//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
			//ณCaso o preco retorne zero, atualiza o valor default de ณ
			//ณacordo com o produto cadastro                          ณ
			//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
			If nPrecoTab == 0 .AND. nModulo == 23
				DbSelectArea("SBI")
				DbSetOrder(1)
				If DbSeek(xFilial("SBI")+cProduto)
					nPrecoTab := SBI->BI_PRV
				EndIf
			ElseIf nPrecoTab == 0 .AND. (nModulo == 12 .OR. nModulo == 72)
					//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
					//ณVerifica se retorna o valor default do SB1 (conforme rangeณ
					//ณa regra do Cenario de Vendas), ou do SB0                  ณ
					//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
					If lLjCnVB0
						DbSelectArea("SB0") 
						DbSetOrder(1)
						If DbSeek(xFilial("SB0")+cProduto)
							If  lECommerce
								cTabPrecos := AllTrim(SuperGetMV("MV_LJECOMT",,cMV_TABPAD))
								nPrecoTab  := SB0->(&("B0_PRV"+AllTrim(cTabPrecos)))
							Else
								nPrecoTab := SB0->B0_PRV1
							EndIf	
						EndIf
					Else
						DbSelectArea("SB1") 
						DbSetOrder(1)
						If MsSeek(xFilial("SB1")+cProduto)
							nPrecoTab := SB1->B1_PRV1
						EndIf						
					EndIf 
			EndIf
		EndIf
	Else  
		//Se nใo atender nenhuma condi็ใo e o lLjCnVB0 estiver configurado para buscar o pre็o na tabela SB0    	
		If lLjCnVB0 .AND. nPrecoTab == 0
			nPrecoTab := LjPrecoSB0(cProduto)
		Endif	

		If nPrecoTab == 0
			If !lAutoExC
				MsgAlert(STR0001) //"Tabela de preco invalida no parametro MV_TABPAD"
			Else 
				ConOut(STR0001)//"Tabela de preco invalida no parametro MV_TABPAD"
				Help( " ", 1, "Help",, STR0001, 1, 0 )			
			EndIf
			lRet := .F.
		EndIf 	
    EndIf  

	If nPrecoTab == 0 .And. Empty(cMsgPdZero)
		//"Pre็o do produto zerado ou nใo cadastrado na tabela de pre็os "
		cMsgPdZero := STR0007 + If(cMvLjRetVl=="3",cTabPrecos,"")
		If !lAutoExC
			MsgAlert(cMsgPdZero)
		Else
			ConOut(cMsgPdZero)
			Help( " ", 1, "Help",, cMsgPdZero, 1, 0 )
		EndIf
		lRet := .F.
	EndIf		  

	RestArea(aAreaDA0)		

Else            
	If (nModulo <> 23 .AND. !IsInCallStack("Crd240Criterio") .AND. !IsInCallStack("Frt080Prod") .AND. !lFtvdVer12) .OR. ;
		(nModulo <> 23 .AND. !IsInCallStack("Crd240Criterio") .AND. lFtvdVer12)
			
		//Faz 2 iteracoes para tentar buscar o preco do produto.
		//A primeira vez tenta buscar o pre็o considerando a tabela selecionado pelo usuario na tela caso ele altera a tabela de preco atrav้s das teclas [Ctrl + C] 
		//Na segunda vez tenta buscar o pre็o considerando a tabela padrao MV_TABPAD
		While nIteracao <= 2
					
			If lECCia
        		lRet := Lj901APrc( @nPrecoTab)
        		LjGrvLog("", "Validando pre็o sem cenแrio de vendas 1 " + cValToChar(nPrecoTab) + " Retorno " + cValToChar(lRet))        		       		
        		Exit
        	EndIf
			
			DbSelectArea( "SB0" )
			DbSetOrder( 1 )  
			
	        If lTabIPI 
	        	cTabPad := AllTrim(SuperGetMV("MV_LJECOMT",,cMV_TABPAD))
	        Else
	        	If nIteracao == 2
	        		cTabPad := cMV_TABPAD
	        	Else
					cTabPad := Lj7DefTab()						        	
	        	EndIf
	        EndIf
			
			If SB0->(FieldPos("B0_PRV" + cTabPad)) > 0		
				nPrecoTab := LjXETPreco(cProduto, cCliente, cLoja, nMoeda, Nil, cTabPad) 
			Else         
				If !lAutoExC
					MsgAlert(STR0001) //"Tabela de preco invalida no parametro MV_TABPAD"
				Else
					Help( " ", 1, "Help",, STR0001, 1, 0 )
				EndIf
				lRet := .F.
				Exit
			EndIf
	
			If lRet .And. nPrecoTab == 0
				DbSelectArea("SB0")
				DbSetOrder(1)
				If !(DbSeek( xFilial("SB0") + cProduto) )
					Help( " ", 1, "NOPRECO" )
					lRet := .F.
					Exit
			        //ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
			        //ณValida para alguns estados se aceita produto sem precoณ
			        //ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
				Else
					If LjAnalisaLeg(2)[1] .AND. lRet .AND. &("SB0->B0_PRV"+ cTabPad) == 0 
						If !LjProdGar(cProduto,cTabPad) // verifica se a garantia, caso sim,cadastra o preco e libera
							If nIteracao == 2												
						    	LjMsgLeg(LjAnalisaLeg(2))	   
						    	lRet := .F.
						    Else
								nIteracao++
								Loop
						    EndIf
		                EndIf
					Else
						Exit
					EndIf
				EndIf
			Else
				Exit
			EndIf
		
		End
		
	Else
		If nModulo = 12
			DbSelectArea("SB1")
			SB1->( DbSetOrder(1) )	//B1_FILIAL + B1_COD
			If SB1->( DbSeek(xFilial("SB1") + cProduto) )
				If lECCia
        
        			lRet := Lj901APrc( @nPrecoTab)
        			LjGrvLog("", "Validando pre็o sem cenแrio de vendas 2 " + cValToChar(nPrecoTab) + " Retorno " + cValToChar(lRet))
				
				ElseIf  lECommerce .AND. !lECCia  //Obter o preco da Tabela e-Commerce
				    SB0->( DbSetOrder(1) )  //B0_FILIAL+B0_COD
				    If  SB0->( DbSeek(xFilial("SB0")+cProduto) )
						cTabPrecos := AllTrim(SuperGetMV("MV_LJECOMT",,cMV_TABPAD))
						nPrecoTab  := SB0->(&("B0_PRV"+AllTrim(cTabPrecos)))
					EndIf	
				Else
					nPrecoTab := SB1->B1_PRV1
					If nPrecoTab == 0
					    nPrecoTab := LjGetB0Prv(cProduto, cTabPrecos)
					EndIf
				EndIf	
			EndIf
		Else
			lProdON := lProdON .Or. SuperGetMV("MV_LJPRDON", ,.F.)
			DbSelectArea("SBI")
			DbSetOrder(1)
			If DbSeek(xFilial("SBI")+cProduto)
				nPrecoTab := SBI->BI_PRV
			ElseIf nModulo == 23 .And. lProdON	//Verifica se esta ativa no Front, a Consulta on-line de Produtos direto na retaguarda
				cTabPrecos := AllTrim(cMV_TABPAD)
				DbSelectArea("SB0")
				DbSetOrder(1)
				If DbSeek(xFilial("SB0")+cProduto)
					If  lECommerce //Obter o preca da Tabela e-Commerce
						cTabPrecos := AllTrim(SuperGetMV("MV_LJECOMT",,cMV_TABPAD))
						nPrecoTab  := SB0->(&("B0_PRV"+AllTrim(cTabPrecos)))
					Else
						nPrecoTab := SB0->(&("B0_PRV"+AllTrim(cTabPrecos))) 
					EndIf	
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

If ( nPrecoTab > 0 .And. ( (lECommerce .and. SuperGetMV("MV_LJIPENP",, .F.) .AND. !lECCia)  .Or. lTabIPI)) .And. !IsInCallStack("LJ861JBPC")
	aAreaSB1 := SB1->(GetArea())                                                                                                                                         
	
		If SB1->(DbSeek(xFilial("SB1")+cProduto ) ) .AND. SB1->B1_IPI > 0 
			//Busca na TES de pedido se estแ sinalizado para calcular IPI				
			aAreaSF4 := SF4->(GetArea())
			//Busca a TES do Item		 				
			   
			SF4->(DbSetOrder(1)	)
			If SF4->(DbSeek(xFilial("SF4") + SuperGetMV("MV_LJTESPE", NIL, "501") ))  .AND. SF4->(!Empty(F4_IPI) .AND. F4_IPI <> "N") 

				//Abate o IPI do Preco Cheio do Produto
           						
        			nValIPIEn := ljfnEGetIpi(nPrecoTab, SLR->(TamSX3("LR_VALIPI")[2]), SuperGetMV("MV_RNDIPI",,.F.))
        			
        			nPrecoTab -=  nValIPIEn
					
					nValIpiEC :=  nValIPIEn								
			
			EndIf				
			
			RestArea(aAreaSF4)   
			
		EndIf			
	RestArea(aAreaSB1)	
	
EndIf   

RestArea(aArea)
	
Return lRet

/*/{Protheus.doc} LjPrecoSB0
	Funcao para retornar o pre็o dos produtos da tabela SB0
	@author SIGALOJA
	@since date 05/05/2020
	@version P12.1.25
	@param Codigo do Produto
	@return Pre็o do Produto
/*/
 Function LjPrecoSB0(cProduto)
Local lECommerce 	:= lMVLJECOMM .And. LJ862ECAuto() //Funcao auto pela Exportacao.
Local cTabPrecos	:= ""
Local nPrecoTab		:= 0

DbSelectArea("SB0") 
DbSetOrder(1)
If DbSeek(xFilial("SB0")+cProduto)
	If  lECommerce
		cTabPrecos := AllTrim(SuperGetMV("MV_LJECOMT",,cMV_TABPAD))
		nPrecoTab  := SB0->(&("B0_PRV"+AllTrim(cTabPrecos)))
	Else
		nPrecoTab := SB0->B0_PRV1
	EndIf	
EndIf
Return(nPrecoTab)

//==============================================================================
/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัออออออออออหอออออออัออออออออออออออออออออหออออออัอออออออออออออปฑฑ
ฑฑบPrograma  ณLjxeRBonusบAutor  ณVendas CRM          บ Data ณ  05/11/08   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณEncapsulamento da funcao de regra de descontos do cenario deบฑฑ
ฑฑบ          ณvendas                                                      บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบParametrosณExpA1: aCols da GetDados                                    บฑฑ
ฑฑบ          ณExpA2: [1] Posicao do codigo do produto                     บฑฑ
ฑฑบ          ณ       [2] Posicao da Quantidade                            บฑฑ
ฑฑบ          ณ       [3] Posicao da TES                                   บฑฑ
ฑฑบ          ณExpC3: Cliente                                              บฑฑ
ฑฑบ          ณExpC4: Loja                                                 บฑฑ
ฑฑบ          ณExpC5: Tabela                                               บฑฑ
ฑฑบ          ณExpC6: Condicao de Pagamento                                บฑฑ 
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ 
ฑฑบRetorno   ณExpA1: Array com a seguinte estrutura:                      บฑฑ 
ฑฑบ          ณ       [1] Codigo do Produto                                บฑฑ 
ฑฑบ          ณ       [2] Quantidade                                       บฑฑ 
ฑฑบ          ณ       [3] TES                                              บฑฑ 
ฑฑบ          ณ       [4] Regra aplicada                                   บฑฑ 
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ 
ฑฑบUso       ณSIGALOJA                                                    บฑฑ
ฑฑศออออออออออฯออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function LjxeRBonus(aPar1,aPar2,cCliente,cLoja,cTabPreco,cCondPg)

Local aArea	:= GetArea()
Local aRet	:= {}

aRet := FtRgrBonus(aPar1,aPar2,cCliente,cLoja,cTabPreco,cCondPg,/*cFormPg*/,/*aRecACQ*/)

RestArea(aArea)

Return aRet

/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัออออออออออหอออออออัออออออออออออออออออออหออออออัอออออออออออออปฑฑ
ฑฑบPrograma  ณLjTelaBon บAutor  ณVendas CRM          บ Data ณ  18/11/08   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณApresenta a tela com os produtos bonificados para conferen- บฑฑ
ฑฑบ          ณcia do caixa.                                               บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบParametrosณExpA1: Lista dos produtos bonificados                       บฑฑ
ฑฑบ          ณ       1 - Codigo do produto                                บฑฑ
ฑฑบ          ณ       2 - Descricao do produto                             บฑฑ
ฑฑบ          ณ       3 - Quantidade bonificada                            บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณSIGALOJA                                                    บฑฑ
ฑฑศออออออออออฯออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function LjTelaBon(aBonus)

Local aArea		:= GetArea()				// Armazena o posicionamento atual do alias corrente
Local aAreaPRD	:= {}						// Armazena o posicionamento atual do alias de produtos
Local aLbx 		:= {}						// Array associado ao ListBox
Local nX		:= 0						// Auxiliar de Loop
Local cFilPRD	:= ""						// Codigo da filial corrente
Local cCpoDesc	:= ""						// Nome do campo que contem a descricao
Local cAliasPRD	:= ""						// Alias da tabela de produtos
Local oDlg		:= Nil						// Objeto da tela
Local oLbx		:= Nil						// Objeto do ListBox
Local oOk 		:= Nil						// Objeto do botao OK
Local oFont1	:= Nil						// Objeto da fonte do dialog

If Len(aBonus) == 0
	Return Nil
EndIf

//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
//ณDefine qual tabela contem dados do produto de acordo comณ
//ณo modulo utilizado                                      ณ
//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
If nModulo == 23
	cAliasPRD	:= "SBI"
	cCpoDesc	:= "BI_DESC"
Else
	cAliasPRD	:= "SB1"
	cCpoDesc	:= "B1_DESC"
EndIf

aAreaPRD	:= (cAliasPRD)->(GetArea())
cFilPRD		:= xFilial(cAliasPRD)

(cAliasPRD)->(DbSetOrder(1))

//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
//ณMonta a lista de produtos exibidosณ
//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
For nX := 1 to Len(aBonus)
	(cAliasPRD)->(DbSeek(cFilPRD+aBonus[nX][1]))
	Aadd(aLbx,{	AllTrim(aBonus[nX][1]),;
				AllTrim(Capital((cAliasPRD)->&(cCpoDesc))),;
				Transform(aBonus[nX][2],X3Picture('L2_QUANT'))})
Next nX	

//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
//ณCriacao da interfaceณ
//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
DEFINE FONT oFont1 NAME "Arial" SIZE 10,17 BOLD

DEFINE MSDIALOG oDlg TITLE STR0002 FROM 0,0 TO 328,386 PIXEL //"Bonifica็ใo"

	@ 004,004 Say STR0003 Size 179,012 COLOR CLR_BLUE PIXEL OF oDlg FONT oFont1	//"Produtos bonificados para esta venda:"

	@ 017,004 TO 147,191 LABEL "" PIXEL OF oDlg

	@ 025,009 ListBox oLbx Fields HEADER STR0004,STR0005,STR0006 COLSIZES 25,25,15 Size 177,115 Of oDlg Pixel //"Produto"###"Descri็ใo"###"Quantidade"

	oLbx:SetArray(aLbx)
	oLbx:bLine	:= {||{	aLbx[oLbx:nAT,01],;
						aLbx[oLbx:nAT,02],;
						aLbx[oLbx:nAT,03]}}

	DEFINE SBUTTON oOk FROM 150,164 TYPE 1 Action(oDlg:End()) ENABLE OF oDlg
	oOk:SetFocus()

ACTIVATE MSDIALOG oDlg CENTERED

RestArea(aAreaPRD)
RestArea(aArea)

Return Nil

/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัออออออออออหอออออออัออออออออออออออออออออหออออออัอออออออออออออปฑฑ
ฑฑบPrograma  ณLjOpcDesc บAutor  ณVendas CRM          บ Data ณ  27/03/09   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณVerifica se o caixa pode conceder descontos quando o cenarioบฑฑ
ฑฑบ          ณde vendas esta ativo                                        บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณSIGALOJA                                                    บฑฑ
ฑฑศออออออออออฯออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function LjOpcDesc(cCaixa)

Local lRet		:= .T.
Local aArea		:= GetArea()
Local aAreaSLF	:= SLF->(GetArea())

Default cCaixa 	:= cNumCaixa

If lCenVenda

	DbSelectArea("SLF")
	SLF->(DbSetOrder(1)) //LF_FILIAL+LF_COD  
	
	If SLF->(MsSeek(xFilial("SLF")+cCaixa))
		lRet := SLF->LF_OPCDESC <> 1 
	EndIf

EndIf

RestArea(aAreaSLF)
RestArea(aArea)

Return lRet
                  
/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัออออออออออหอออออออัออออออออออออออออออออหออออออัอออออออออออออปฑฑ
ฑฑบPrograma  ณLjXEMoeda บAutor  ณVendas CRM          บ Data ณ  27/03/09   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณCarrega a moeda 											  บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณSIGALOJA                                                    บฑฑ
ฑฑศออออออออออฯออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
//
Function LjXEMoeda(cProduto, nQtde, cCliente, cLoja)
Local nRet 		:=  1

	If lCenVenda	                
		//nRet	:= DA1->DA1_MOEDA		
	Else
		nRet	:=	Max(&("SB0->B0_MOEDA" + Lj7DefTab()),1)
	EndIf

Return nRet

/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัออออออออออหอออออออัออออออออออออออออออออหออออออัอออออออออออออปฑฑ
ฑฑบPrograma  ณLJ7Bonus  บAutor  ณVendas CRM          บ Data ณ  05/11/08   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณExecuta o processamento das regras de bonificacao do cena-  บฑฑ
ฑฑบ          ณrio de vendas                                               บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณLOJA701                                                     บฑฑ
ฑฑศออออออออออฯออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function LJ7Bonus(nOpc,lTefPendCS,aTefBKPCS,aBonus)

Local aArea		:= GetArea()	   		 							// Armazena o posicionamento atual
Local nX		:= 0			   		 							// Auxiliar de loop 
Local aColsBon	:= {}					  							// aCols enviado a funcao de regra de descontos
Local aPosCpos	:= {1,2,3}											// Posicao dos campos codigo, quant. e TES no aColsBon
Local nPItem	:= aScan(aHeader,{|x|AllTrim(x[2])=="LR_ITEM"})	// Posicao do campo Item
Local nPProduto	:= aScan(aHeader,{|x|AllTrim(x[2])=="LR_PRODUTO"})	// Posicao do campo Codigo
Local nPQuant	:= aScan(aHeader,{|x|AllTrim(x[2])=="LR_QUANT"})	// Posicao do campo Quantidade
Local nPTotItem	:= aScan(aHeader,{|x|AllTrim(x[2])=="LR_VLRITEM"})	// Posicao do campo Total do item
Local nPTES		:= aScan(aHeaderDet,{|x|AllTrim(x[2])=="LR_TES"})	// Posicao do campo TES
Local nPos		:= 0												// Indice de pesquisa no aColsBon
Local cCondPg	:= M->LQ_CONDPG										// Condicao de pagamento utilizada
Local cTabPreco	:= LjXETabPre(M->LQ_CLIENTE,M->LQ_LOJA)			// Tabela de precos utilizada
Local nTamItem	:= TamSX3("LR_ITEM")[1]								// Tamanho do campo LR_ITEM
Local cItem		:= StrZero(0,nTamItem)								// Item do aCols para controle dos novos itens
Local cCampo	:= ""												// Nome do campo do aCols
Local cBkReadVar:= __ReadVar										// Backup da variavel __ReadVar
Local nValDesc	:= 0												// Valor de desconto do item
Local cTesOri	:= ""												// TES original do produto
Local nAnt		:= N												// Armazena em qual linha a getdados estava posicionada
Local nValDscAnt:= Lj7T_DescV(2)									// Valor do desconto atual aplicado ao total da venda
//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
//ณSintetiza os produtos validos em um acols simplificado para aณ
//ณrotina de regra de bonificacao                               ณ
//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
For nX := 1 to Len(aCols)
	If !aTail(aCols[nX]) .AND. !Empty(aCols[nX][nPProduto])
		If (nPos:= aScan(aColsBon,{|x|x[1] == aCols[nX][nPProduto] .AND. x[3] == aColsDet[nX][nPTES]})) == 0
			AAdd(aColsBon,{aCols[nX][nPProduto],aCols[nX][nPQuant],aColsDet[nX][nPTES],.F.})
		Else
			aColsBon[nPos][2] += aCols[nX][nPQuant]
		EndIf
	EndIf
Next nX

//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
//ณProcessa a regra de bonificacaoณ
//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
If Len(aColsBon) > 0
	aBonus	:= LjxeRBonus(aColsBon,aPosCpos,M->LQ_CLIENTE,M->LQ_LOJA,cTabPreco,cCondPg)
EndIf

//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
//ณSe nao houver bonus, aborta o processamentoณ
//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
If Len(aBonus) == 0
	RestArea(aArea)
	Return .F.
EndIf

//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
//ณVerifica qual o maior item da vendaณ
//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
For nX := 1 to Len(aCols)
	If aCols[nX][nPItem] > cItem
		cItem := aCols[nX][nPItem]
	EndIf
Next nX

//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
//ณ'Clona' uma linha em branco do aCols, limpando seus valores.   ณ
//ณEsta linha sera usada para referencia ao adicionar novos itens.ณ
//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
aLinRef	:= aClone(aCols[1])

For nX := 1 to Len(aHeader)  

	cCampo	:= AllTrim(aHeader[nX][2])
	
	If !(cCampo $ "L2_REC_WT/L2_ALI_WT")
		aLinRef[nX] := CriaVar(cCampo,.F.)
	ElseIf cCampo == "L2_ALI_WT"
		aLinRef[nX] := "SL2"
	ElseIf cCampo == "L2_REC_WT"
		aLinRef[nX] := 0
	EndIf      
	
Next nX

//Limpa a marca de linha deletada
aLinRef[Len(aHeader)+1] := .F.

//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
//ณAdiciona os produtos bonificados na vendaณ
//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
For nX := 1 to Len(aBonus)

	cItem := Soma1(cItem)
	
	AAdd(aCols,aClone(aLinRef)) 
	
	N := Len(aCols)     
	
	oGetVA:oBrowse:nAt := N
	oGetVA:oBrowse:Refresh()
	
	aCols[N][nPItem]	:= cItem

	//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
	//ณProcessa a acao de digitacao do campo quantidadeณ
	//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
	aCols[N][nPQuant]	:= aBonus[nX][2]
	M->LR_QUANT			:= aBonus[nX][2]
	__ReadVar			:= "M->LR_QUANT" 
	
	Lj7VlItem( 1 , .T. )

	//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
	//ณProcessa a acao de digitacao do campo quantidadeณ
	//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู

	aCols[N][nPProduto]	:= aBonus[nX][1]	
	M->LR_PRODUTO		:= aBonus[nX][1]
	__ReadVar			:= "M->LR_PRODUTO" 
	
	Lj7Prod(,.T.)

	//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
	//ณAjusta a TES do produtoณ
	//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
	cTesOri	:= aColsDet[n][nPTES]

	If cPaisLoc <> "MEX"
		Lj7AltTes(aBonus[nX][3], @lTefPendCS, @aTefBKPCS)
	EndIf

	If cPaisLoc <> "BRA" .AND. cTesOri <> aColsDet[n][nPTES]
		Lj7RecalImp(n,2,"IT_TES",Nil,cTesOri)
	EndIf
	
	//Tratar totalizacao para desconto no total
	nValDesc	+= aCols[N][nPTotItem]

Next nX

oGetVA:oBrowse:Refresh()

If nValDesc > 0
	LJ7VldDesc( Nil, Nil, nValDesc + nValDscAnt )
EndIf

__ReadVar	:= cBkReadVar 

N := nAnt
oGetVa:oBrowse:nAt := N
oGetVa:oBrowse:Refresh()

RestArea(aArea)

Return .T.

/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัออออออออออหอออออออัออออออออออออออออออออหออออออัอออออออออออออปฑฑ
ฑฑบPrograma  ณLjXETabPreบAutor  ณMicrosiga           บ Data ณ  07/01/10   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณRetorna a tabela de precos utilizada para o cliente         บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบParametrosณExpC1 - Codigo do cliente                                   บฑฑ
ฑฑบ          ณExpC2 - Loja do cliente                                     บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณLOJXFUNE                                                    บฑฑ
ฑฑศออออออออออฯออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function LjXETabPre(cCliente,cLoja)

Local aArea			:= {}		// Posicionamento atual
Local aAreaSA1		:= {}		// Posicionamento atual da SA1
Local aAreaDA0		:= {}		// Posicionamento atual da SA1
Local cTabRet		:= ""		// Parametro da tabela de preco padrao
Local lTabEspCli	:= .F.		// Indica se utiliza a tabela do cliente  
Local lECCia		:= lMVLJECOMM .And. SuperGetMV("MV_LJECOMO",,.F.) .AND. ( IsInCallStack("LOJA901A") )//Funcao auto pela Exportacao.
Local cChvCtrlPE 	:= "" 		// Chave de Controle para execu็ใo do PE LJ7108
Local nPosCtrlPE	:= 0
Local cRetLJ7108	:= Nil
Local nPosCpoIte 	:= 0
Local nPosCpoPrd 	:= 0
Local nPosCpoTab 	:= 0
Local cItem 		:= ""
Local cCodProd		:= ""
Local lLRTABELA		:= IsInCallStack("Lj7LinOk") .Or. IsInCallStack("Lj7PrepDel") //Se a chamada ้ da troca de linha da Getdados ou dele็ใo do item, considera a tabela do item

Default cCliente 	:= ""
Default cLoja		:= ""

If lECCia  .And. ValType( M->LQ_TABELA ) == "C"
	cTabRet :=  M->LQ_TABELA
Else
	// Otimiza busca, retornando o valor ja conhecido
	If lLRTABELA .And. Type("aPosCpoDet") == "A" .And. Type("aColsDet") == "A"
		nPosCpoTab 	:= Ascan(aPosCpoDet,{|x| AllTrim(Upper(x[1])) == "LR_TABELA"})
		cTabRet 	:= aColsDet[n][nPosCpoTab]
	EndIf
	
	If Empty(cTabRet)
		lLRTABELA := .F.
		// Otimiza busca, retornando o valor ja conhecido
		If Len(aUltTab) >= 3 .AND. aUltTab[1] == cCliente .AND. aUltTab[2] == cLoja
			cTabRet := aUltTab[3]
		Else

			cTabRet		:= Pad(cMV_TABPAD,TamSx3("DA0_CODTAB")[1])	 			// Parametro da tabela de preco padrao	
			lTabEspCli	:= SuperGetMv("MV_CONFCLI",,"N")=="S"	// Indica se utiliza a tabela do cliente

			aUltTabCli := {}
			
			//Localiza o cliente se permitir utilizar a tabela definida no cliente (MV_CONFCLI)
			If lCenVenda 
				
				If lTabEspCli

					aArea		:= GetArea()
					aAreaSA1	:= SA1->(Getarea())
					aAreaDA0	:= DA0->(Getarea())
					
					DbSelectArea("SA1")
					SA1->(DbSetOrder(1))
					
					DbSelectArea("DA0")
					DA0->(DbSetOrder(1))

					If SA1->(DbSeek(xFilial("SA1")+cCliente+cLoja)) .AND. !Empty(SA1->A1_TABELA)
						//Localiza a tabela
						If 	DA0->(DbSeek(xFilial("DA0")+SA1->A1_TABELA))
							//Valida a tabela
							If 	(DA0->DA0_ATIVO == "2") .Or.;
								(DA0->DA0_TPHORA == "1" .And. !(SubtHoras(dDataBase,Time(),If(Empty(DA0->DA0_DATATE),dDataBase,DA0->DA0_DATATE),DA0->DA0_HORATE) >= 0 .And.;
								SubtHoras(DA0->DA0_DATDE,DA0->DA0_HORADE,dDataBase,Time()) >= 0)) .Or.;
								(DA0->DA0_TPHORA == "2" .And. !(dDataBase >= DA0->DA0_DATDE .And. dDataBase <= If(Empty(DA0->DA0_DATATE),dDataBase,DA0->DA0_DATATE) .And.;
								(SubStr(Time(),1,5) >= DA0->DA0_HORADE .And. SubStr(Time(),1,5) <= DA0->DA0_HORATE)))
							
								MsgStop(STR0008+" (" + AllTrim(SA1->A1_TABELA) + ") "+STR0009) //"A tabela de pre็os definida para este cliente"###"estแ fora de vig๊ncia"
							Else
								cTabRet := Pad(SA1->A1_TABELA,TamSx3("DA0_CODTAB")[1])		
								aUltTabCli := {cCliente, cLoja, cTabRet}
							EndIf
						EndIf
					EndIf

					RestArea(aAreaDA0)
					RestArea(aAreaSA1)
					RestArea(aArea)

				EndIf

				If Empty(cTabRet)
					cTabRet	:= cMV_TABPAD
					cTabRet	:= Pad(cTabRet,TamSx3("DA0_CODTAB")[1])
				EndIf
			EndIf

		EndIf
	EndIf
EndIf

If lLJ7108
	If Type("aPosCpo") == "A" .And. !lLRTABELA
		If !IsInCallStack("LOJPESQ") //Verifica se nao foi chamada da tela de pesquisa unificada de produto 
			//Verifica se jแ foi chamado o PE LJ7108. Caso positivo, somente retorna a mesma informa็ใo jแ retornada anteriormente pelo PE.
			nPosCpoIte 	:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_ITEM"})][2]	 // Posicao do item
			nPosCpoPrd 	:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_PRODUTO"})][2] // Posicao do Codigo do Produto
			cItem 		:= IIf(Len(aCols)>=n,aCols[n][nPosCpoIte],cItem)
			If "LR_PRODUTO" $ ReadVar()
				cCodProd := M->LR_PRODUTO
			Else
				cCodProd := IIf(Len(aCols)>=n,aCols[n][nPosCpoPrd],cCodProd)
			EndIf
		EndIf

		cChvCtrlPE := xFilial("SL1") + M->LQ_NUM + M->LQ_CLIENTE + M->LQ_LOJA

		//Verifica se ainda ้ ou nใo a mesma venda e mesmo cliente
		If Len(aPeLJ7108) > 0 .And. aPeLJ7108[1] == cChvCtrlPE
			//Se encontrar informa็ใo jแ retornada do PE LJ7108 para o mesmo item da venda e produto, apenas retorna o conte๚do para nใo executar novamente o PE.
			If !Empty(cItem) .And. !Empty(cCodProd) .And. ( nPosCtrlPE := aScan( aPeLJ7108[2], {|x| x[1] == cItem + cCodProd } ) ) > 0
				cRetLJ7108 := aPeLJ7108[2][nPosCtrlPE][2]
				LjGrvLog(M->LQ_NUM,"Considera o retorno do Ponto de Entrada LJ7108 executado anteriormente. Tabela Retornada:", cRetLJ7108)
			EndIf
		Else
			aPeLJ7108 := {cChvCtrlPE, {}}
		EndIf
		
		If cRetLJ7108 == Nil
			LjGrvLog(M->LQ_NUM,"Antes da Chamada do Ponto de Entrada LJ7108. Tabela de pre็o:", cTabRet)
			cRetLJ7108 := ExecBlock( "LJ7108", .F., .F., {cTabRet, aPosCpo} )
			LjGrvLog(M->LQ_NUM,"Apos a Chamada do Ponto de Entrada LJ7108. Tabela de pre็o retornada:", cRetLJ7108)
			If !Empty(cItem) .And. !Empty(cCodProd) .And. !Empty(cRetLJ7108)
				aAdd( aPeLJ7108[2], { cItem + cCodProd, cRetLJ7108 } )
			EndIf
		EndIf

		If ValType(cRetLJ7108) == "C"
			cTabRet	:= Pad(cRetLJ7108,TamSx3("DA0_CODTAB")[1])
		EndIf
	EndIf
EndIf

//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
//ณArmazena valor retornado para possivel consulta posteriorณ
//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
aUltTab := {cCliente, cLoja, cTabRet}
LjGrvLog( Nil,"Tabela de pre็o utilizada:", cTabRet)
Return cTabRet

/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัออออออออออหอออออออัออออออออออออออออออออหออออออัอออออออออออออปฑฑ
ฑฑบPrograma  ณLjxFindTabบAutor  ณMicrosiga           บ Data ณ  15/06/11   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณFuncao que valida se existe tabela de preco ativa para o diaบฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบParametrosณNIL                                                         บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบRetorno   ณNIL                                                         บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณFRTA271A,                                                   บฑฑ
ฑฑศออออออออออฯออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function LjxFindTab(cCliente, cLoja)

Local lContinua := .T.	// Se continua a rotina apos validacao do IndexKey() do DA0 
Local cTabClient:= ""
Local cSeekDA0 	:= ""
Local cFilDA0 	:= ""

Default cCliente:= ""
Default cLoja 	:= ""

If Len(aUltTabCli) > 0 .AND. aUltTabCli[1] == cCliente .AND. aUltTabCli[2] == cLoja
	cTabClient := aUltTabCli[3]
ElseIf cMvLjRetVl == "3" //Considera tabela configurada no parametro MV_TABPAD
	lContinua := .F.
	//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
	//ณSe nao existir o indice, retorna o MV_TABPADณ
	//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
	Aadd(aTabelas,Pad(cMV_TABPAD,TamSx3("DA0_CODTAB")[1]))
EndIf
//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
//ณExistindo o indice "2" realiza as validacoes necessariasณ
//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
If lContinua
	DbSelectArea("DA0")
	
	cFilDA0 := xFilial("DA0")

	If !Empty(cTabClient)
		//Neste caso foi definida uma tabela especifica configurada para o cliente no campo A1_TABELA
		DA0->(DbSetOrder(1)) //DA0_FILIAL+DA0_CODTAB
		cSeekDA0 := cTabClient
	Else
		DA0->(DbSetOrder(2)) //DA0_FILIAL+DA0_ATIVO+DA0_DATDE+DA0_DATATE
		cSeekDA0 := "1"
	EndIf
	
	//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
	//ณBusca as tabelas ativas ณ
	//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
	If DA0->( DbSeek(cFilDA0 + cSeekDA0) )
		//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
		//ณVerifica se existes tabelas ativas para a data atualณ
		//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
		While DA0->( !EOF() ) .AND. DA0->DA0_FILIAL == cFilDA0 .AND. DA0->DA0_ATIVO == "1"
			If (dDataBase >= DA0->DA0_DATDE) .AND. (dDataBase <= If(Empty(DA0->DA0_DATATE),dDataBase,DA0->DA0_DATATE))
				//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
				//ณAvalia efetivamente se existe tabela de preco ativa paraณ
				//ณa data e hora atual, considerando se o DA0_TPHORA       ณ
				//ณeh igual a "1" ou "2"                                   ณ
				//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
				If 	(DA0->DA0_TPHORA == "1" 																					.AND.	;
					(SubtHoras(dDataBase,Time(),If(Empty(DA0->DA0_DATATE),dDataBase,DA0->DA0_DATATE),DA0->DA0_HORATE) >= 0 	.AND.	;
					 SubtHoras(DA0->DA0_DATDE,DA0->DA0_HORADE,dDataBase,Time()) >= 0)) 										.OR.	;
					(DA0->DA0_TPHORA == "2" 																					.AND.	;
					(dDataBase >= DA0->DA0_DATDE .And. dDataBase <= If(Empty(DA0->DA0_DATATE),dDataBase,DA0->DA0_DATATE) 		.AND.	;
					(SubStr(Time(),1,5) >= DA0->DA0_HORADE .And. SubStr(Time(),1,5) <= DA0->DA0_HORATE)))
					//ฺฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฟ
					//ณSe entrou a(s) tabela(s) alimenta o array staticณ
					//ภฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤู
					Aadd(aTabelas,DA0->DA0_CODTAB)
				EndIf
			EndIf
			
			//Neste caso existe uma tabela especifica configurada para o cliente no campo A1_TABELA, entao abandona o laco
			If !Empty(cTabClient)
				Exit
			EndIf
			DA0->(DbSkip())
		End
	EndIf
EndIf

Return NIL
/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัออออออออออหอออออออัออออออออออออออออออออหออออออัอออออออออออออปฑฑ
ฑฑบPrograma  ณLjxClFindTบAutor  ณMicrosiga           บ Data ณ  15/06/11   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณFuncao que limpa o array estatico aTabXPreco e aTabelas     บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบParametrosณNIL                                                         บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบRetorno   ณNIL                                                         บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณFRTA271A,                                                   บฑฑ
ฑฑศออออออออออฯออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function LjxClFindT()
aTabXPreco 	:= {}
aTabelas	:= {}
Return NIL

/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัออออออออออหอออออออัออออออออออออออออออออหออออออัอออออออออออออปฑฑ
ฑฑบPrograma  ณLjxEMod   บAutor  ณVendas CRM          บ Data ณ  29/06/11   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณFuncao que verifica se a tabela e exclusiva ou compartilhadaบฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบParametrosณcTab = Alias da tabela                                      บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบRetorno   ณlRet = Retorna .T. para tabela compartilhada                บฑฑ
ฑฑบ          ณ       Retorna .F. para tabela exclusiva                    บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณLOJXFUNE                                                    บฑฑ
ฑฑศออออออออออฯออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function LjxEMod(cTab)
Local lRet := .F. //Retorno

Default cTab 	:= ""

//Verifica o modo de acesso por unidade de neg๓cio e filial
If FWModeAccess(cTab,2) == "C" .And. FWModeAccess(cTab,3) == "C"
	lRet := .T.
Else              
	lRet := .F.	
EndIf

Return lRet

/*
ฑฑบPrograma  ณLjxEDtoC   บAutor  ณVendas CRM          บ Data ณ  31/05/13 บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณ 																	บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบRetorno   ณcRet : retorna data transformada em tipo caracter           บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณLOJXFUNB                                                    บฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿*/
Function LjxEDtoC( xValor )
Local cValor := ""

 If ValType(xValor) == "D"
 	cValor :=	Dtos(xValor)
ElseIf ValType(xValor) == "C"
 	If Empty(AllTrim(xValor))
 		cValor := ""
 	Else
 		cValor := Dtos(stod(xValor))
 	EndIf
EndIf

Return cValor

/*
ฑฑบPrograma  ณLjxELeCria  บAutor  ณVendas CRM          บ Data ณ  12/04/13 บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณCria e le arquivo contando infos ECF							บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบRetorno   ณlRet = cria arquivo que guarda informa็๕es do ECF           บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณLOJXFUNB                                                    บฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿*/
Function LjxELeCria( lCria , aConteudoTXT)
Local cPathSmart	:= "" 
Local cNomeArq	:= "DTECF.LOJ"
Local nHandleTXT	:= 0
Local nX			:= 0
Local cConteudo	:= ""
Local cVarTXT		:= ""
Local cDadoTXT	:= ""
Local aTXT			:= {}
Local lRet			:= .T.

DEFAULT lCria			:=	.F.
DEFAULT aConteudoTXT	:=	{}

cPathSmart := GetClientDir()

If lCria .AND. Len(aConteudoTXT) > 0	
	If File(cPathSmart + cNomeArq)
		FErase(cPathSmart + cNomeArq)
	EndIf
	nHandleTXT := FCREATE( cPathSmart + "Dado.TXT", FC_NORMAL )
	
	If nHandleTXT < 0
		Conout(" LOJXFUNE -> Erro ao criar arquivo " + cPathSmart + cNomeArq) //"Erro ao criar arquivo "			
	Else
		cConteudo := ""
		For nX := 1 to Len(aConteudoTXT)
			If aConteudoTXT[nX][1] == "PDV" //Campo numerico
				cConteudo += aConteudoTXT[nX][1] + "|" + IIf(empty(AllTrim(aConteudoTXT[nX][2])), "0" ,aConteudoTXT[nX][2]) + CHR(10)	 
			Else
				cConteudo += aConteudoTXT[nX][1] + "|" + IIf(empty(AllTrim(aConteudoTXT[nX][2])), "  " ,aConteudoTXT[nX][2]) + CHR(10)
			EndIf	
		Next nX		
		FWRITE( nHandleTXT, cConteudo, LEN( cConteudo ) )
		FCLOSE( nHandleTXT )
		FRENAME(cPathSmart + "Dado.TXT" ,cPathSmart + cNomeArq)
		FERASE(cPathSmart + "Dado.TXT")
		Conout(" LOJXFUNE - LjxELeCria -> Arquivo " + cPathSmart + cNomeArq + " Gerado com Sucesso")
	EndIf

ElseIf !lCria
	
	aTXT := LjxReadFile( cPathSmart , cNomeArq, 0, .F. ) //Pega conteudo de cFile , no caminho cPathDLLArq com indice 0 e permite a dele็ใo do arquivo 

	If ValType(aTXT) == "A" .AND. Len(aTXT) > 1
		aConteudoTXT := {}
		For nX := 1 To Len(aTXT)
			If !Empty(AllTrim(aTXT[nX]))				
				cVarTXT	:= Substr(aTXT[nX] ,1,At("|",aTXT[nX])-1)
				cDadoTXT	:= Substr(aTXT[nX] ,At("|",aTXT[nX])+1,Len(aTXT[nX]))
				If cVarTXT == "PDV" //Campo numerico
					Aadd( aConteudoTXT , {cVarTXT,Val(cDadoTXT)})
				Else				
					Aadd( aConteudoTXT , {cVarTXT,cDadoTXT} )
				EndIf	
			EndIf							
		Next nX				
	EndIf
EndIf	

Return lRet

/*
ฑฑบPrograma  ณLjxER04PDV   บAutor  ณVendas CRM          บ Data ณ  31/05/13บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณ 																	บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบRetorno   ณcRet =  cabe็alho da venda cancelada no PDV                 บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณLOJXFUNB                                                    บฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿*/
Function LjxER04PDV(lReducao, cSeriePDV , cMfAdic ,cModelo, nUsuEcf, dDataIni, dDataFim)
Local cConteudo	:=	""
Local cModeloAux	:= cModelo
Local nAcrescimo 	:= 0

DbSelectArea("SA1")
SA1->(DbSetOrder(1))

DbSelectArea("SL1")
SL1->(DbSetOrder(1)) //L1_FILIAL+L1_NUM

DbSelectArea("MDZ")
MDZ->(DbSetOrder(1)) //MDZ_FILIAL+DtoS(MDZ_DATA)
MDZ->(DbSeek(xFilial("MDZ")+DtoS(dDataIni),.T.))
			
While !MDZ->(Eof()) .AND. MDZ->MDZ_FILIAL == xFilial("MDZ") .AND. MDZ->MDZ_DATA <= dDataFim
	If AllTrim(MDZ->MDZ_SIMBOL) == "R4" 
		If (MDZ->MDZ_SITUA == "OK") .AND. !Empty(AllTrim(MDZ->MDZ_TIPO)) .AND. ;
			SL1->(DbSeek(xFilial("SL1")+AllTrim(MDZ->MDZ_TIPO))) //Colocado para armazenar no campo MDZ_TIPO o num do orcamento

			cConteudo += "R04"						 								// 01 - Tipo
			cConteudo += PADR( cSeriePDV , 20 ) 									// 02 - Numero de fabricacao do ECF
			cConteudo += PADR( cMfAdic	 , 01 )	   								// 03 - Letra indicativa de MF adicional
			
			cModeloAux := PADR( cModelo, 20)			// Modelo do ECF				
			nAcrescimo := SL1->L1_VLRTOT - SL1->L1_VALBRUT
			
			cConteudo += cModeloAux										// 04 - Modelo do ECF	
			cConteudo += StrZero( nUsuEcf		   	   	   		, 02 ) // 05 - No. de ordem do usuario do ECF relativo a respectiva Reducao Z 
			cConteudo += StrZero(Val(MDZ->MDZ_CCF) , 06 )				// 06 - CCF, CVC ou CBP, conforme o documento
			cConteudo += StrZero(Val(MDZ->MDZ_COO) , 06 )  			// 07 - COO (Contador de Ordem de Operacao) 
			cConteudo += PADR(DtoS(SL1->L1_EMISSAO)	, 08 ) 	   	// 08 - Data de inicio da emissao 
			cConteudo += StrTran(StrZero(0,15,2),'.')					// 09 - Subtotal do Documento 
			cConteudo += StrTran(StrZero(SL1->L1_DESCONT,14,2),'.')	// 10 - Desconto sobre subtotal 
			cConteudo += PADR( IIf(SL1->L1_DESCONT > 0, "V", " "), 01 )		// 11 - Indicador do Tipo de Desconto sobre subtotal
			cConteudo += StrTran(StrZero(nAcrescimo,14,2),'.')				// 12 - Acrescimo sobre subtotal 
			cConteudo += PADR(IIf(nAcrescimo > 0, "V" , " "), 01 )	   		// 13 - Indicador do Tipo de Acrescimo sobre subtotal 
			cConteudo += StrTran(StrZero(0,15,2),'.')							//14 - Valor Total Liquido
			cConteudo += PADR(If(SL1->L1_STORC == "C","S","N"), 01 ) 		// 15 - Indicador de Cancelamento 
			cConteudo += StrTran(StrZero(0,14,2),'.')							//16 - Cancelamento de Acrescimo no Subtotal 
			cConteudo += PADR( IIf(nAcrescimo > 0, "A" , IIf(SL1->L1_DESCONT > 0, "D", " ")) , 01 )		// 17 - Ordem de aplicacao de Desconto e Acrescimo 
			cConteudo += PADR( MDZ->MDZ_NOMCLI, 40 )					// 18 - Nome do adquirente
			cConteudo += StrZero(Val(MDZ->MDZ_CGCCLI),14)				// 19 - CPF/CNPJ do adquirente
			cConteudo += CHR(13) + CHR(10)
		EndIf	
	EndIf
	MDZ->(DbSkip())
EndDo

//*******************************************************************************************************
//Efetua pesquisa na SL1- caso qdo or็amentos vieram da retaguarda,foram impressos e cancelados no PDV
//*******************************************************************************************************
SL1->(DbSetOrder(4)) //L1_FILIAL+DtoS(L1_EMISSAO)
SL1->(DbSeek(xFilial("SL1")+DtoS(dDataIni),.T.))
While !SL1->(Eof()) .AND. SL1->L1_FILIAL == xFilial("SL1") .AND. SL1->L1_EMISSAO <= dDataFim
	If (SL1->L1_STORC == "C") .AND. !Empty(AllTrim(SL1->L1_NUMORC))
		
		cConteudo += "R04"						 								// 01 - Tipo
		cConteudo += PADR( cSeriePDV , 20 ) 									// 02 - Numero de fabricacao do ECF
		cConteudo += PADR( cMfAdic	 , 01 )	   								// 03 - Letra indicativa de MF adicional			
		
		cModeloAux := PADR( cModelo, 20)			// Modelo do ECF
		nAcrescimo := SL1->L1_VLRTOT - SL1->L1_VALBRUT
		cConteudo += cModeloAux							// 04 - Modelo do ECF	
		cConteudo += StrZero( nUsuEcf		   	   	   		, 02 )	// 05 - No. de ordem do usuario do ECF relativo a respectiva Reducao Z		
		cConteudo += StrZero(Val(SL1->L1_CONTDOC) , 06 )			// 06 - CCF, CVC ou CBP, conforme o documento
		cConteudo += StrZero(Val(SL1->L1_DOC) , 06 )  			// 07 - COO (Contador de Ordem de Operacao) 
		cConteudo += PADR(DtoS(SL1->L1_EMISSAO)	, 08 ) 	   		// 08 - Data de inicio da emissao 
		cConteudo += StrTran(StrZero(SL1->L1_VALBRUT,15,2),'.')	// 09 - Subtotal do Documento 
		cConteudo += StrTran(StrZero(SL1->L1_DESCONT,14,2),'.')	// 10 - Desconto sobre subtotal
		 
		cConteudo += PADR( IIf(SL1->L1_DESCONT > 0, "V", " "), 01 )	   				// 11 - Indicador do Tipo de Desconto sobre subtotal
		cConteudo += StrTran(StrZero(nAcrescimo,14,2),'.')	// 12 - Acrescimo sobre subtotal 
		cConteudo += PADR(IIf(nAcrescimo > 0, "V" , " "), 01 )	   				// 13 - Indicador do Tipo de Acrescimo sobre subtotal 
		cConteudo += StrTran(StrZero(0,15,2),'.')//14 - Valor Total Liquido
		cConteudo += PADR("S", 01 )	     // 15 - Indicador de Cancelamento 
		cConteudo += StrTran(StrZero(0,14,2),'.')//16 - Cancelamento de Acrescimo no Subtotal 
		cConteudo += PADR( IIf(nAcrescimo > 0, "A" , IIf(SL1->L1_DESCONT > 0, "D", " ")) , 01 )				// 17 - Ordem de aplicacao de Desconto e Acrescimo		
		
		If SA1->(MsSeek(xFilial("SA1")+SL1->L1_CLIENTE+SL1->L1_LOJA))		 
			cConteudo += PADR( AllTrim(SA1->A1_NOME), 40 )				// 18 - Nome do adquirente
			cConteudo += StrZero(Val(AllTrim(SA1->A1_CGC)),14)			// 19 - CPF/CNPJ do adquirente
		Else
			cConteudo += PADR( " ", 40 )				// 18 - Nome do adquirente
			cConteudo += StrZero(0,14)			// 19 - CPF/CNPJ do adquirente
		EndIf
			
		cConteudo += CHR(13) + CHR(10)		
	EndIf
	SL1->(DbSkip())
EndDo

//***********************************************************************************************************************************
//Efetua pesquisa na SL1- caso qdo or็amentos vieram da retaguarda,foram impressos e cancelados no PDV, como cancelar o ๚tlimo cupom
//***********************************************************************************************************************************
SET DELETED OFF
SL1->(DbSetOrder(4)) //L1_FILIAL+DtoS(L1_EMISSAO)
SL1->(DbSeek(xFilial("SL1")+DtoS(dDataIni),.T.))
While !SL1->(Eof()) .AND. SL1->L1_FILIAL == xFilial("SL1") .AND. SL1->L1_EMISSAO <= dDataFim
	If (SL1->(Deleted())) .AND. !Empty(AllTrim(SL1->L1_DOC)) .AND. !Empty(AllTrim(SL1->L1_NUMCFIS))
		
		cConteudo += "R04"						 								// 01 - Tipo
		cConteudo += PADR( cSeriePDV , 20 ) 									// 02 - Numero de fabricacao do ECF
		cConteudo += PADR( cMfAdic	 , 01 )	   								// 03 - Letra indicativa de MF adicional			
		
		cModeloAux := PADR( cModelo, 20)			// Modelo do ECF
		nAcrescimo := SL1->L1_VLRTOT - SL1->L1_VALBRUT
		cConteudo += cModeloAux							// 04 - Modelo do ECF	
		cConteudo += StrZero( nUsuEcf		   	   	   		, 02 )	// 05 - No. de ordem do usuario do ECF relativo a respectiva Reducao Z		
		cConteudo += StrZero(Val(SL1->L1_CONTDOC) , 06 )			// 06 - CCF, CVC ou CBP, conforme o documento
		cConteudo += StrZero(Val(SL1->L1_DOC) , 06 )  			// 07 - COO (Contador de Ordem de Operacao) 
		cConteudo += PADR(DtoS(SL1->L1_EMISSAO)	, 08 ) 	   		// 08 - Data de inicio da emissao 
		cConteudo += StrTran(StrZero(SL1->L1_VALBRUT,15,2),'.')	// 09 - Subtotal do Documento 
		cConteudo += StrTran(StrZero(SL1->L1_DESCONT,14,2),'.')	// 10 - Desconto sobre subtotal
		cConteudo += PADR( IIf(SL1->L1_DESCONT > 0, "V", " "), 01 )	   				// 11 - Indicador do Tipo de Desconto sobre subtotal
		cConteudo += StrTran(StrZero(nAcrescimo,14,2),'.')	// 12 - Acrescimo sobre subtotal 
		cConteudo += PADR(IIf(nAcrescimo > 0, "V" , " "), 01 )	   				// 13 - Indicador do Tipo de Acrescimo sobre subtotal 
		cConteudo += StrTran(StrZero(0,15,2),'.')//14 - Valor Total Liquido
		cConteudo += PADR("S", 01 )	     // 15 - Indicador de Cancelamento 
		cConteudo += StrTran(StrZero(0,14,2),'.')//16 - Cancelamento de Acrescimo no Subtotal 
		cConteudo += PADR( IIf(nAcrescimo > 0, "A" , IIf(SL1->L1_DESCONT > 0, "D", " ")) , 01 )				// 17 - Ordem de aplicacao de Desconto e Acrescimo		
		
		If SA1->(MsSeek(xFilial("SA1")+SL1->L1_CLIENTE+SL1->L1_LOJA))		 
			cConteudo += PADR( AllTrim(SA1->A1_NOME), 40 )				// 18 - Nome do adquirente
			cConteudo += StrZero(Val(AllTrim(SA1->A1_CGC)),14)			// 19 - CPF/CNPJ do adquirente
		Else
			cConteudo += PADR( " ", 40 )				// 18 - Nome do adquirente
			cConteudo += StrZero(0,14)			// 19 - CPF/CNPJ do adquirente
		EndIf
			
		cConteudo += CHR(13) + CHR(10)		
	EndIf
	SL1->(DbSkip())
EndDo
SET DELETED ON

Return cConteudo


/*
ฑฑบPrograma  ณLjxER05PDV   บAutor  ณVendas CRM         บ Data ณ  31/05/13 บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณ 																	 บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบRetorno   ณcRet = itens da venda para o mov por ECF	                  บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณLOJXFUNB                                                    บฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿*/
Function LjxER05PDV(lReducao, cSeriePDV , cMfAdic ,cModelo, nUsuEcf, dDataIni, dDataFim)
Local cConteudo	:= ""
Local cModeloAux	:= ""
Local cRet			:= ""
Local lCancelado	:= .F.

DbSelectArea("SL2")
SL2->(DbSetOrder(1)) //L2_FILIAL+L2_NUM+L2_ITEM+L2_PRODUTO

DbSelectArea("MDZ")
MDZ->(DbSetOrder(1)) //MDZ_FILIAL+DtoS(MDZ_DATA)
MDZ->(DbSeek(xFilial("MDZ")+DtoS(dDataIni),.T.))
	
While !MDZ->(Eof()) .AND. MDZ->MDZ_FILIAL == xFilial("MDZ") .AND. MDZ->MDZ_DATA <= dDataFim
	If AllTrim(MDZ->MDZ_SIMBOL) == "R4"
		If (MDZ->MDZ_SITUA == "OK") .AND. !Empty(AllTrim(MDZ->MDZ_TIPO)) .AND. ;
			SL2->(DbSeek(xFilial("SL2")+AllTrim(MDZ->MDZ_TIPO))) //Colocado para armazenar no campo MDZ_TIPO o num do orcamento
			
			While !SL2->(Eof()) .AND. (SL2->L2_FILIAL+AllTrim(SL2->L2_NUM) == xFilial("SL2")+AllTrim(MDZ->MDZ_TIPO))
				
				cModeloAux := PADR( cModelo, 20)			// Modelo do ECF
				cConteudo += "R05"											 								// 01 - Tipo
				cConteudo += PADR( cSeriePDV		  	  	   		, 20 ) 									// 02 - Numero de fabricacao do ECF
				cConteudo += PADR( cMfAdic			  	  	   		, 01 )	   								// 03 - Letra indicativa de MF adicional			
				cConteudo += cModeloAux							// 04 - Modelo do ECF	
				cConteudo += StrZero( nUsuEcf	, 02 ) 					// 05 - No. de ordem do usuario do ECF relativo a respectiva Reducao Z 
				cConteudo += StrZero(Val(MDZ->MDZ_COO)	,06 )				// 06 - COO (Contador de Ordem de Operacao) 
				cConteudo += StrZero(Val(MDZ->MDZ_CCF),06 )				// 07 - CCF, CVC ou CBP, conforme o documento
				cConteudo += StrZero(Val(SL2->L2_ITEM)	,03 )				// 08 - Numero do item
				cConteudo += PADR( SL2->L2_PRODUTO	,14 )				// 09 - Codigo do Produto ou Servico
				cConteudo += PADR( SL2->L2_DESCRI	,100)				// 10 - Descricao
				cConteudo += StrZero(SL2->L2_QUANT * &("1" + Replicate("0",TamSx3("L2_VRUNIT")[2])),07 )				// 11 - Quantidade
				cConteudo += PADR( SL2->L2_UM	,03 )				// 12 - Unidade
				cConteudo += StrZero(SL2->L2_PRCTAB * &("1" + Replicate("0",TamSX3("L2_QUANT")[2]))	,08 )				// 13 - Valor unitario
				cConteudo += StrTran(StrZero(SL2->L2_VALDESC,9,2),'.')	// 14 - Desconto sobre item 
				cConteudo += StrTran(StrZero(0,9,2),'.')	// 15 - Acrescimo sobre item 
				cConteudo += StrTran(StrZero(SL2->L2_VLRITEM,15,2),'.')		// 16 - Valor total liquido
				cRet	:= AllTrim(SL2->L2_SITTRIB)
				LjBuscaTot( @cRet )
				cConteudo += PADR( cRet ,07 )				// 17 - Totalizador parcial 
				
				lCancelado := (SL2->L2_VENDIDO == "N")
				
				cConteudo += PADR(IIf(lCancelado,"S","N"), 01 )		// 18 - Indicador de cancelamento 
				cConteudo += StrZero(0,07 )	// 19 - Quantidade cancelada somente cancelado parcial
				cConteudo += StrTran(StrZero(0,14,2),'.')	// 20 - Valor cancelado somente se cancelado parcial
				cConteudo += StrTran(StrZero(0,14,2),'.')	// 21 - Cancelamento de acrescimo no item 
				cConteudo += PADR("A"	,01 )	   			// 22 - Indicador de Arredondamento ou Truncamento(IAT) 
				cConteudo += PADR("T"   	,01 )	   			// 23 - Indicador de Producao Propria ou de Terceiro(IPPT) 
				cConteudo += StrZero(TamSX3("L2_QUANT")[2]	,01 )				// 24 - Casas decimais da quantidade
				cConteudo += StrZero(TamSx3("L2_VRUNIT")[2]	,01 )				// 25 - Casas decimais de valor unitario
				cConteudo += CHR(13) + CHR(10)
				SL2->(DbSkip())
			EndDo
		EndIf	
	EndIf
	MDZ->(DbSkip())
EndDo


DbSelectArea("SL1")
SL1->(DbSetOrder(4)) //L1_FILIAL+DtoS(L1_EMISSAO)
SL1->(DbSeek(xFilial("SL1")+DtoS(dDataIni),.T.))

SL2->(DbSetOrder(1))

While !SL1->(Eof()) .AND. SL1->L1_FILIAL == xFilial("SL1") .AND. SL1->L1_EMISSAO <= dDataFim
	If (SL1->L1_STORC == "C") .AND. !Empty(AllTrim(SL1->L1_NUMORC))
		If SL2->(MsSeek(xFilial("SL2")+AllTrim(SL1->L1_NUM)))
			While !SL2->(Eof()) .AND. (SL2->L2_FILIAL+AllTrim(SL2->L2_NUM) == xFilial("SL2")+AllTrim(SL1->L1_NUM))
				
				cModeloAux := PADR( cModelo, 20)			// Modelo do ECF
				cConteudo += "R05"											 								// 01 - Tipo
				cConteudo += PADR( cSeriePDV	, 20 ) 									// 02 - Numero de fabricacao do ECF
				cConteudo += PADR( cMfAdic		, 01 )	   								// 03 - Letra indicativa de MF adicional			
				cConteudo += cModeloAux							// 04 - Modelo do ECF	
				cConteudo += StrZero( nUsuEcf	, 02 ) 					// 05 - No. de ordem do usuario do ECF relativo a respectiva Reducao Z 
				cConteudo += StrZero(0,06 )				// 06 - COO (Contador de Ordem de Operacao) 
				cConteudo += StrZero(0,06 )				// 07 - CCF, CVC ou CBP, conforme o documento
				cConteudo += StrZero(Val(SL2->L2_ITEM)	,03 )				// 08 - Numero do item
				cConteudo += PADR( SL2->L2_PRODUTO	,14 )				// 09 - Codigo do Produto ou Servico
				cConteudo += PADR( SL2->L2_DESCRI	,100)				// 10 - Descricao
				cConteudo += StrZero(SL2->L2_QUANT * &("1" + Replicate("0",TamSx3("L2_VRUNIT")[2])),07 )				// 11 - Quantidade
				cConteudo += PADR( SL2->L2_UM	,03 )				// 12 - Unidade
				cConteudo += StrZero(SL2->L2_PRCTAB * &("1" + Replicate("0",TamSX3("L2_QUANT")[2]))	,08 )				// 13 - Valor unitario
				cConteudo += StrTran(StrZero(SL2->L2_VALDESC,9,2),'.')	// 14 - Desconto sobre item 
				cConteudo += StrTran(StrZero(0,9,2),'.')	// 15 - Acrescimo sobre item 
				cConteudo += StrTran(StrZero(SL2->L2_VLRITEM,15,2),'.')		// 16 - Valor total liquido
				cRet	:= AllTrim(SL2->L2_SITTRIB)
				LjBuscaTot( @cRet )
				cConteudo += PADR(cRet							,07 )				// 17 - Totalizador parcial 
				cConteudo += PADR(IIf(SL2->L2_VENDIDO == "N","S","N"), 01 )		// 18 - Indicador de cancelamento 
				cConteudo += StrZero(0,07 )				// 19 - Quantidade cancelada
				cConteudo += StrTran(StrZero(0,14,2),'.')	// 20 - Valor cancelado
				cConteudo += StrTran(StrZero(0,14,2),'.')	// 21 - Cancelamento de acrescimo no item 
				cConteudo += PADR("A"	,01 )	   			// 22 - Indicador de Arredondamento ou Truncamento(IAT) 
				cConteudo += PADR("T"   		,01 )	   			// 23 - Indicador de Producao Propria ou de Terceiro(IPPT) 
				cConteudo += StrZero(TamSX3("L2_QUANT")[2]	,01 )				// 24 - Casas decimais da quantidade
				cConteudo += StrZero(TamSx3("L2_VRUNIT")[2]	,01 )				// 25 - Casas decimais de valor unitario
				cConteudo += CHR(13) + CHR(10)
				
				SL2->(DbSkip())
			EndDo
		EndIf
	EndIf
	SL1->(DbSkip())
EndDo

//***********************************************************************************************************************************
//Efetua pesquisa na SL1 e SL2 - caso qdo or็amentos vieram da retaguarda,foram impressos e cancelados no PDV, como cancelar o ๚tlimo cupom
//***********************************************************************************************************************************
SET DELETED OFF
DbSelectArea("SL1")
SL1->(DbSetOrder(4)) //L1_FILIAL+DtoS(L1_EMISSAO)
SL1->(DbSeek(xFilial("SL1")+DtoS(dDataIni),.T.))

DbSelectArea("SL2")
SL2->(DbSetOrder(1))

While !SL1->(Eof()) .AND. SL1->L1_FILIAL == xFilial("SL1") .AND. SL1->L1_EMISSAO <= dDataFim
	If (SL1->(Deleted())) .AND. !Empty(AllTrim(SL1->L1_DOC)) .AND. !Empty(AllTrim(SL1->L1_NUMCFIS))
		If SL2->(MsSeek(xFilial("SL2")+AllTrim(SL1->L1_NUM)))
			While !SL2->(Eof()) .AND. (SL2->L2_FILIAL+AllTrim(SL2->L2_NUM) == xFilial("SL2")+AllTrim(SL1->L1_NUM))
				
				If AllTrim(SL2->L2_VENDIDO) == "S" .AND. !Empty(SL2->L2_DOC) .AND. !Empty(SL2->L2_SERIE) .AND. !Empty(SL2->L2_PDV)
					cModeloAux := PADR( cModelo, 20)			// Modelo do ECF
					cConteudo += "R05"											 								// 01 - Tipo
					cConteudo += PADR( cSeriePDV	, 20 ) 									// 02 - Numero de fabricacao do ECF
					cConteudo += PADR( cMfAdic		, 01 )	   								// 03 - Letra indicativa de MF adicional			
					cConteudo += cModeloAux							// 04 - Modelo do ECF	
					cConteudo += StrZero( nUsuEcf	, 02 ) 					// 05 - No. de ordem do usuario do ECF relativo a respectiva Reducao Z 
					cConteudo += StrZero(0,06 )				// 06 - COO (Contador de Ordem de Operacao) 
					cConteudo += StrZero(0,06 )				// 07 - CCF, CVC ou CBP, conforme o documento
					cConteudo += StrZero(Val(SL2->L2_ITEM)	,03 )				// 08 - Numero do item
					cConteudo += PADR( SL2->L2_PRODUTO	,14 )				// 09 - Codigo do Produto ou Servico
					cConteudo += PADR( SL2->L2_DESCRI	,100)				// 10 - Descricao
					cConteudo += StrZero(SL2->L2_QUANT * &("1" + Replicate("0",TamSx3("L2_VRUNIT")[2])),07 )				// 11 - Quantidade
					cConteudo += PADR( SL2->L2_UM	,03 )				// 12 - Unidade
					cConteudo += StrZero(SL2->L2_PRCTAB * &("1" + Replicate("0",TamSX3("L2_QUANT")[2]))	,08 )				// 13 - Valor unitario
					cConteudo += StrTran(StrZero(SL2->L2_VALDESC,9,2),'.')	// 14 - Desconto sobre item 
					cConteudo += StrTran(StrZero(0,9,2),'.')	// 15 - Acrescimo sobre item 
					cConteudo += StrTran(StrZero(SL2->L2_VLRITEM,15,2),'.')		// 16 - Valor total liquido
					cRet	:= AllTrim(SL2->L2_SITTRIB)
					LjBuscaTot( @cRet )
					cConteudo += PADR(cRet							,07 )				// 17 - Totalizador parcial 
					cConteudo += PADR(IIf(SL2->L2_VENDIDO == "N","S","N"), 01 )		// 18 - Indicador de cancelamento 
					cConteudo += StrZero(0,07 )				// 19 - Quantidade cancelada
					cConteudo += StrTran(StrZero(0,14,2),'.')	// 20 - Valor cancelado
					cConteudo += StrTran(StrZero(0,14,2),'.')	// 21 - Cancelamento de acrescimo no item 
					cConteudo += PADR("A"	,01 )	   			// 22 - Indicador de Arredondamento ou Truncamento(IAT) 
					cConteudo += PADR("T"   		,01 )	   			// 23 - Indicador de Producao Propria ou de Terceiro(IPPT) 
					cConteudo += StrZero(TamSX3("L2_QUANT")[2]	,01 )				// 24 - Casas decimais da quantidade
					cConteudo += StrZero(TamSx3("L2_VRUNIT")[2]	,01 )				// 25 - Casas decimais de valor unitario
					cConteudo += CHR(13) + CHR(10)
				EndIf
				
				SL2->(DbSkip())
			EndDo
		EndIf
	EndIf
	SL1->(DbSkip())
EndDo	
SET DELETED ON


Return cConteudo

/*
ฑฑบPrograma  ณLjxER07PDV   บAutor  ณVendas CRM         บ Data ณ  31/05/13 บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณ 																	 บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบRetorno   ณcRet = valor da venda para o mov por ECF	                  บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณLOJXFUNB                                                    บฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿*/
Function LjxER07PDV(lReducao, cSeriePDV , cMfAdic ,cModelo, nUsuEcf, dDataIni, dDataFim) 
Local cConteudo	:=	""
Local cModeloAux	:= cModelo
Local cRet			:= ""

//*****************************************************************************************
//Efetua pesquisa na SL1 - caso qdo or็amentos vieram e foram impressos e cancelados no PDV
//*****************************************************************************************
DbSelectArea("SL1")
SL1->(DbSetOrder(4)) //L1_FILIAL+DtoS(L1_EMISSAO)
SL1->(DbSeek(xFilial("SL1")+DtoS(dDataIni),.T.))

DbSelectArea("SL4")
SL4->(DbSetOrder(1)) //L4_FILIAL+L4_NUM+L4_ORIGEM

While !SL1->(Eof()) .AND. SL1->L1_FILIAL == xFilial("SL1") .AND. SL1->L1_EMISSAO <= dDataFim
	If (SL1->L1_STORC == "C") .AND. !Empty(AllTrim(SL1->L1_NUMORC)) .AND. Empty(AllTrim(SL1->L1_NUMCFIS))	
		If SL4->(MsSeek(xFilial("SL4")+AllTrim(SL1->L1_NUM)))
			While !SL4->(Eof()) .AND. (SL4->L4_FILIAL+SL4->L4_NUM == xFilial("SL4")+SL1->L1_NUM)
				
				cModeloAux := PADR( cModelo, 20)			// Modelo do ECF
				
				If Empty(AllTrim(SL4->L4_INSTITU))					
					cRet := Posicione("SX5", 1, xFilial("SX5")+ "24" + SubStr(AllTrim(SL4->L4_FORMA), 1, 2), "X5_DESCRI")
				Else					
					cRet := Posicione("SX5", 1, xFilial("SX5")+ "24" +( AllTrim(SL4->L4_FORMA) + "-" + AllTrim(SL4->L4_INSTITU), 1, 2), "X5_DESCRI")
				Endif	
							 
				cConteudo += "R07"							// 01 - Tipo
				cConteudo += PADR( cSeriePDV 		, 20 )	// 02 - Numero de fabrica็ใo do ECF
				cConteudo += PADR( cMfAdic	  		, 01 )	// 03 - Letra indicativa de MF adicional				
				cConteudo += cModeloAux						// 04 - Modelo do ECF	
				cConteudo += StrZero( nUsuEcf , 02 )		// 05 - No. de ordem do usuario do ECF relativo a respectiva Reducao Z 
				cConteudo += StrZero( Val(SL1->L1_DOC) , 06 )		// 06 - COO (Contador de Ordem de Operacao) 
				cConteudo += StrZero( Val(SL1->L1_DOC), 06 )	// 07 - Numero do Contador de Cupom Fiscal relativo ao respectivo Cupom Fiscal emitido
				cConteudo += StrZero( Val(SL1->L1_CONTONF), 06 )			// 08 - Numero do Contador Geral Nใo Fiscal relativo ao respectivo Comprovante Nใo Fiscal emitido
				cConteudo += PADR( cRet	, 15 )		   						// 09 - Descricao do totalizador parcial de meio de pagamento
				cConteudo += StrTran(StrZero( SL4->L4_VALOR, 14, 2),'.')	// 10 - Valor do pagamento efetuado, com duas casas decimais
				cConteudo += PADR("S", 01 )   // 11 - Informar "S" ou "N", conforme tenha ocorrido ou nใo, o estorno do pagamento, ou P para estorno parcial do pagamento
				cConteudo += StrZero( 0	, 13 ) 	  							// 12 - Valor do estorno efetuado, com duas casas decimais				
				cConteudo += CHR(13) + CHR(10)
				
				SL4->(DbSkip())			
			EndDo
		Endif			
	EndIf
	SL1->(DbSkip())
EndDo


//***********************************************************************************************************************************
//Efetua pesquisa na SL1 e SL2 - caso qdo or็amentos vieram da retaguarda,foram impressos e cancelados no PDV, como cancelar o ๚tlimo cupom
//***********************************************************************************************************************************
SET DELETED OFF
DbSelectArea("SL1")
SL1->(DbSetOrder(4)) //L1_FILIAL+DtoS(L1_EMISSAO)
SL1->(DbSeek(xFilial("SL1")+DtoS(dDataIni),.T.))

DbSelectArea("SL4")
SL4->(DbSetOrder(1)) //L4_FILIAL+L4_NUM+L4_ORIGEM

While !SL1->(Eof()) .AND. SL1->L1_FILIAL == xFilial("SL1") .AND. SL1->L1_EMISSAO <= dDataFim
	If (SL1->(Deleted())) .AND. !Empty(AllTrim(SL1->L1_DOC)) .AND. !Empty(AllTrim(SL1->L1_NUMCFIS))
		If SL4->(MsSeek(xFilial("SL4")+AllTrim(SL1->L1_NUM)))
			While !SL4->(Eof()) .AND. (SL4->L4_FILIAL+SL4->L4_NUM == xFilial("SL4")+SL1->L1_NUM)
				
				cModeloAux := PADR( cModelo, 20)			// Modelo do ECF
				
				If Empty(AllTrim(SL4->L4_INSTITU))					
					cRet := Posicione("SX5", 1, xFilial("SX5")+ "24" + SubStr(AllTrim(SL4->L4_FORMA), 1, 2), "X5_DESCRI")
				Else					
					cRet := Posicione("SX5", 1, xFilial("SX5")+ "24" +( AllTrim(SL4->L4_FORMA) + "-" + AllTrim(SL4->L4_INSTITU), 1, 2), "X5_DESCRI")
				Endif	
							 
				cConteudo += "R07"							// 01 - Tipo
				cConteudo += PADR( cSeriePDV 		, 20 )	// 02 - Numero de fabrica็ใo do ECF
				cConteudo += PADR( cMfAdic	  		, 01 )	// 03 - Letra indicativa de MF adicional				
				cConteudo += cModeloAux						// 04 - Modelo do ECF	
				cConteudo += StrZero( nUsuEcf , 02 )		// 05 - No. de ordem do usuario do ECF relativo a respectiva Reducao Z 
				cConteudo += StrZero( Val(SL1->L1_DOC) , 06 )		// 06 - COO (Contador de Ordem de Operacao) 
				cConteudo += StrZero( Val(SL1->L1_DOC), 06 )	// 07 - Numero do Contador de Cupom Fiscal relativo ao respectivo Cupom Fiscal emitido
				cConteudo += StrZero( Val(SL1->L1_CONTONF), 06 )			// 08 - Numero do Contador Geral Nใo Fiscal relativo ao respectivo Comprovante Nใo Fiscal emitido
				cConteudo += PADR( cRet	, 15 )		   						// 09 - Descricao do totalizador parcial de meio de pagamento
				cConteudo += StrTran(StrZero( SL4->L4_VALOR, 14, 2),'.')	// 10 - Valor do pagamento efetuado, com duas casas decimais
				cConteudo += PADR("S", 01 )   //*Uso como padrใo o "S" pois trata-se de um registro deletado* -> 11 - Informar "S" ou "N", conforme tenha ocorrido ou nใo, o estorno do pagamento, ou P para estorno parcial do pagamento
				cConteudo += StrZero( 0	, 13 ) 	  							// 12 - Valor do estorno efetuado, com duas casas decimais				
				cConteudo += CHR(13) + CHR(10)
				
				SL4->(DbSkip())			
			EndDo
		Endif			
	EndIf
	SL1->(DbSkip())
EndDo
SET DELETED ON

Return cConteudo

/*
ฑฑบPrograma  ณLjxEPItDel   บAutor  ณVendas CRM         บ Data ณ  31/05/13 บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณ 																	 บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบRetorno   ณcRet = item cancelado na venda do PDV	                  	บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณLOJXFUNB                                                    บฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿*/
Function LjxEPItDel(cSeriePDV ,cCooDoc,lReducao, cMfAdic ,cModelo, nUsuEcf)
Local cIndice		:= ""
Local cConteudo	:= ""
Local cRet			:= ""
Local cSerie		:= AllTrim(LjGetStation("LG_SERIE"))
Local cModeloAux	:= cModelo
Local nCount		:= 0

SET DELETED OFF

DbSelectArea("SL1")
DbSelectArea("SL2")
SL2->(dbsetorder(3))
SL1->(dbsetorder(1))

cIndice := xFilial('SL2')+AllTrim(cSerie)+AllTrim(cCooDoc)
SL2->(MsSeek(cIndice))

//Aqui somente selecione itens que foram deletados e o cupom finalizado
While !SL2->(Eof()) .AND. (SL2->(L2_FILIAL+AllTrim(L2_SERIE)+AllTrim(L2_DOC)) == cIndice)	 
	If (SL1->(MsSeek(xFilial("SL1")+SL2->L2_NUM))) .AND. !(SL1->(Deleted())) .AND. !(SL1->L1_STORC == "C") ; 
		.AND. (!Empty(AllTrim(SL1->L1_DOC))) .AND. AllTrim(SL2->L2_DOC) == AllTrim(cCooDoc) .AND. SL2->L2_VENDIDO == "N"
		
		cModeloAux := PADR( cModelo, 20)			// Modelo do ECF
		
		cConteudo := "R05"								// 01 - Tipo
		cConteudo += PADR( cSeriePDV 	   		, 20 ) // 02 - Numero de fabricacao do ECF
		cConteudo += PADR( cMfAdic			  	, 01 )	// 03 - Letra indicativa de MF adicional		
		cConteudo += cModeloAux							// 04 - Modelo do ECF	
		cConteudo += StrZero( nUsuEcf	, 02 ) 									// 05 - No. de ordem do usuario do ECF relativo a respectiva Reducao Z
		cConteudo += StrZero(Val(SL2->L2_DOC)	,06 )				// 06 - COO (Contador de Ordem de Operacao) 
		cConteudo += StrZero(Val(SL1->L1_CONTDOC),06 )				// 07 - CCF, CVC ou CBP, conforme o documento
		cConteudo += StrZero(Val(SL2->L2_ITEM)	,03 )				// 08 - Numero do item
		cConteudo += PADR( SL2->L2_PRODUTO		,14 )				// 09 - Codigo do Produto ou Servico
		cConteudo += PADR( SL2->L2_DESCRI	,100)				// 10 - Descricao
		cConteudo += StrZero(SL2->L2_QUANT * &("1" + Replicate("0",TamSX3("L2_QUANT")[2])),07 )				// 11 - Quantidade
		cConteudo += PADR( SL2->L2_UM	,03 )				// 12 - Unidade
		cConteudo += StrZero(SL2->L2_PRCTAB * &("1" + Replicate("0",TamSX3("L2_VRUNIT")[2]))	,08 )				// 13 - Valor unitario
		cConteudo += StrTran(StrTran(StrZero(SL2->L2_VALDESC,9,2),'-','0'),'.')	// 14 - Desconto sobre item 
		cConteudo += StrTran(StrTran(StrZero(0,9,2),'-','0'),'.')	// 15 - Acrescimo sobre item 
		cConteudo += StrTran(StrTran(StrZero(SL2->L2_VLRITEM,15,2),'-','0'),'.')		// 16 - Valor total liquido
		
		cRet := AllTrim(SL2->L2_SITTRIB)
		LjBuscaTot( @cRet )
		
		cConteudo += PADR( cRet	,07 )				// 17 - Totalizador parcial 
		cConteudo += PADR(IIf(AllTrim(SL2->L2_VENDIDO) == "N","S","N"), 01 )		// 18 - Indicador de cancelamento 
		cConteudo += StrZero(0,07 )				// 19 - Quantidade cancelada
		cConteudo += StrTran(StrTran(StrZero(0,14,2),'-','0'),'.')	// 20 - Valor cancelado
		cConteudo += StrTran(StrZero(0,14,2),'.')	// 21 - Cancelamento de acrescimo no item 
		cConteudo += PADR("A"	,01 )	   			// 22 - Indicador de Arredondamento ou Truncamento(IAT) 
		cConteudo += PADR("T"	,01 )	   			// 23 - Indicador de Producao Propria ou de Terceiro(IPPT) 
		cConteudo += StrZero(TamSX3("L2_QUANT")[2]	,01 )				// 24 - Casas decimais da quantidade
		cConteudo += StrZero(TamSx3("L2_VRUNIT")[2]	,01 )				// 25 - Casas decimais de valor unitario		
		
		cConteudo += CHR(13) + CHR(10)			
	EndIf
	nCount := Val( SL2->L2_ITEM )
	SL2->(DbSkip())
EndDo	

SET DELETED ON

Return cConteudo


/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัอออออออออออหอออออออัอออออออออออออออออออออออออหออออออัออออออออออปฑฑ
ฑฑบPrograma  ณGetRgAcumul บAutor  ณ Vendas Clientes        บ Data ณ 02/09/13 บฑฑ
ฑฑฬออออออออออุอออออออออออสอออออออฯอออออออออออออออออออออออออสออออออฯออออออออออนฑฑ
ฑฑบDescricao ณ Retorna a variavel logica (static) lRgAcumul						บฑฑ
ฑฑฬออออออออออุอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบRetorno   ณ Logico											             บฑฑ
ฑฑศออออออออออฯอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function LjGetRAcumul()
Return lRgAcumul

/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัอออออออออออหอออออออัอออออออออออออออออออออออออหออออออัออออออออออปฑฑ
ฑฑบPrograma  ณSetRgAcumulบ Autor  ณ Vendas Clientes        บ Data ณ 02/09/13 บฑฑ
ฑฑฬออออออออออุอออออออออออสอออออออฯอออออออออออออออออออออออออสออออออฯออออออออออนฑฑ
ฑฑบDescricao ณ Atribui valor a variavel logica (static) lRgAcumul			 บฑฑ
ฑฑฬออออออออออุอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบRetorno   ณ 													             บฑฑ
ฑฑศออออออออออฯอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function LjSetRAcumul(lAlterado)
	lRgAcumul := lAlterado
Return Nil


/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัอออออออออออหอออออออัอออออออออออออออออออออออออหออออออัออออออออออปฑฑ
ฑฑบPrograma  ณLjfnEGetIpi บAutor  ณ Vendas Clientes        บ Data ณ 02/09/13 บฑฑ
ฑฑฬออออออออออุอออออออออออสอออออออฯอออออออออออออออออออออออออสออออออฯออออออออออนฑฑ
ฑฑบDescricao ณ Calcula o Valor do IPI a ser descontado do pre็o de venda    บฑฑ
ฑฑฬออออออออออุอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบRetorno   ณ 													            บฑฑ
ฑฑศออออออออออฯอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function LjfnEGetIpi(nPrecoTab, nCasasIPI, lMVRNDIPI, nAliquota)
	
Local nValIPIEn := 0

Default nAliquota := SB1->B1_IPI

nValIPIEn	:= (nPrecoTab  /(1 +(nAliquota/100) )) * ( nAliquota/100)	//Apura a Base do IPI

If lMVRNDIPI		
	nValIPIEn := Round(nValIPIEn,nCasasIPI)     //Trabalha com arredondamento
Else
	nValIPIEn := NoRound(nValIPIEn,nCasasIPI)   //Trabalha com truncamento
EndIf
           						

Return(nValIPIEn)
/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัอออออออออออหอออออออัอออออออออออออออออออออออหออออออัออออออออออปฑฑ
ฑฑบPrograma  ณLjProdGar  บAutor  ณ Vendas Clientes       บ Data ณ 16/01/14 บฑฑ
ฑฑฬออออออออออุอออออออออออสอออออออฯอออออออออออออออออออออออสออออออฯออออออออออนฑฑ
ฑฑบDescricao ณ Caso o produto garantia nao tenha preco ele inclui          บฑฑ
ฑฑศออออออออออฯอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function LjProdGar(cProduto,cTabPad)
Local lRet 		:= .F.

DEFAULT cProduto:= ""
DEFAULT cTabPad	:= "1"

SB1->(dbSetorder(1))
If SB1->(dbSeek(xFilial("SB1")+cProduto)) .AND. AllTrim(SB1->B1_TIPO) == AllTrim(cMvLjTGar)
	// Caso seja um produto garantia e nao possua preco, preenche com um valor qualquer para nao exigir 
	// que tenha SB0 cadastrado , pois a garantia nao pega o preco do SB0
	RecLock("SB0",.F.)	
	REPLACE &("SB0->B0_PRV"+cTabPad)	WITH 1
	SB0->(MsUnlock())
	lRet := .T.
EndIf
	
Return(lRet)



/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัอออออออออออหอออออออัอออออออออออออออออออออออหออออออัออออออออออปฑฑ
ฑฑบPrograma  ณljFilTab  บAutor  ณ Vendas Clientes       บ Data ณ 16/10/15  บฑฑ
ฑฑฬออออออออออุอออออออออออสอออออออฯอออออออออออออออออออออออสออออออฯออออออออออนฑฑ
ฑฑบDescricao ณ Filta as tabela de pre็o ativas                            บฑฑ
ฑฑศออออออออออฯอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function ljFilTab(aTabXPreco,cProduto,nQtdade)

Local aArea  		:= GetArea() // Salva a area atual
Local cQuery 		:=  ""       // Texto SQL que ้ enviado para o comando TCGenQry
Local cAliasDA1 	:= "DA1"
Local _aTabsPrecos 	:= {}

DEFAULT aTabXPreco	:= {}
DEFAULT cProduto	:= "1"
DEFAULT nQtdade		:= 0 

#IFDEF TOP

	cAliasDA1 := GetNextAlias()

	cQuery := " SELECT DA1_CODTAB FROM  " + RetSqlName("DA1")+ " DA1" + ; 
			  " WHERE DA1.DA1_FILIAL = '" + xFilial("DA1") + "'" +;
			  " AND DA1.DA1_CODPRO   = '" + cProduto + "'" +; 
			  " AND DA1.DA1_QTDLOT >=  "  + Alltrim(Str(nQtdade)) +;
			  " AND DA1.DA1_ATIVO = '1' AND DA1.D_E_L_E_T_ = ' ' ORDER BY  DA1_CODTAB "

	cQuery := ChangeQuery(cQuery)
		
	DbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasDA1, .F., .T.)

	If !Empty(Alltrim((cAliasDA1)->DA1_CODTAB))
		While (cAliasDA1)->(!EOf()) 
			If Ascan(aTabXPreco,{|x| x == Alltrim((cAliasDA1)->DA1_CODTAB)} ) > 0 
				aAdd(_aTabsPrecos, Alltrim((cAliasDA1)->DA1_CODTAB) )
			EndIf	
		(cAliasDA1)->(dbSkip())
		End	

		aTabXPreco := _aTabsPrecos

	EndIF
    (cAliasDA1)->(DbCloseArea())
    

#ENDIF
    	
RestArea(aArea)

Return 

/*

ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
ฑฑษออออออออออัออออออออออหอออออออัออออออออออออออออออออหออออออัอออออออออออออปฑฑ
ฑฑบPrograma  ณLJValCenVdบAutor  ณVendas CRM          บ Data ณ  24/12/09   บฑฑ
ฑฑฬออออออออออุออออออออออสอออออออฯออออออออออออออออออออสออออออฯอออออออออออออนฑฑ
ฑฑบDesc.     ณFaz a validacao dos campos que nao sao necessarios para o   บฑฑ
ฑฑบ          ณmodulo de loja.                                             บฑฑ
ฑฑฬออออออออออุออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออนฑฑ
ฑฑบUso       ณCENARIO DE VENDAS                                           บฑฑ
ฑฑศออออออออออฯออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผฑฑ
ฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑฑ
฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿฿
*/
Function LJValCenVd()  
/*Fun็ใo foi mantida pois ้ chamada em fontes do faturamento para nใo gerar
erro e por conta do Projeto SOYUZ o conte๚do da rotina nใo pode mais ser 
executado, pois atualizava o dicionแrio com o sistema em execu็ใo.*/
Return Nil


/*/{Protheus.doc} LjxValEst
	fun็ใo responsavel por validar se o faturamento devera validar o estoque mesmo com reserva.
	Obs: essa fun็ใo foi criada pelo motivo do loja permitir a reserva negativa
	@type  Function
	@author Lucas Novais	
	@since 18/01/2018
	@version 12.1.17
	@param 
	@return lValida
	@example
	If LjxValEst(SC5->S5_ORCRES)
		//Executa comando
	Endif 
/*/
Function LjxValEst(cC5OrcRes)
Local lValida	:= .F.
Local cLJPVLIB	:= SuperGetMV("MV_LJPVLIB",,"1")
Local cESTNEG	:= SuperGetMV("MV_ESTNEG",,"N")

Default cC5OrcRes  := ""

lValida :=  !Empty(cC5OrcRes) .AND. cLJPVLIB == "2" .AND. cESTNEG == "N"

Return lValida

//-----------------------------------------------------------
/*/{Protheus.doc} LjADLSeek
@type Function
@description Realiza a busca na tabela ADL, utilizada durante a Workarea, onde o filtro na tabela ADL impede a busca completa.
             Obs.: Essa Fun็ใo foi clonada do fonte fata520B pelo fato do faturamento estar retirando o tratamento do Ifdef top 
             Fun็ใo original ADLSeek
@param cFilADL 		- Filial da ADL
       cCodVend 	- Codigo do vendedor
       cFilEnt 		- Filial da entidade
       cEnt 		- Alias da entidade
       cCodigo 		- Codigo da entidade
       cLoja 		- Loja da entidade
@author Rene Julian
@return	nRec - Retorno do registro encontrado na tabela ADL.
@since 25/07/2018
@version P12.1.17
/*/
//-----------------------------------------------------------
Function LjADLSeek(cFilADL	, cCodVend	, cFilEnt	, cEnt	,;
						cCodigo	, cLoja		)

Local aArea		:= GetArea()
Local cQuery	:= ""
Local cAliasTmp	:= "ADLSEE" 
Local nRec		:= 0


#IFDEF TOP
	If Select(cAliasTmp) > 0
		(cAliasTmp)->(DbCloseArea())	
	EndIf
	
	cQuery	:= "SELECT R_E_C_N_O_ AS RECN FROM "+RetSqlName("ADL")
	cQuery	+= " WHERE ADL_FILIAL ='"+cFilADL+"' AND ADL_VEND = '"+cCodVend+"' AND ADL_FILENT = '"+cFilEnt+"'"
	cQuery	+= " AND ADL_ENTIDA = '"+cEnt+"' AND ADL_CODENT = '"+cCodigo+"' AND ADL_LOJENT = '"+cLoja+"' AND D_E_L_E_T_ = ' '"
	
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTmp,.F.,.T.)
	dbGoTop()	                 
	
	If !Eof()
		nRec :=(cAliasTmp)->RECN
	End	

	(cAliasTmp)->(DbCloseArea())
#ELSE
	DbSelectarea("ADL")
	DbSetOrder(5)
	If DbSeek(xFilial("ADL")+cCodVend)
		While !ADL->(Eof()) 
			If ADL->ADL_FILIAL == cFilADL  .And. ADL->ADL_VEND == cCodVend .And. ADL->ADL_FILENT == cFilEnt .And. ;
		       ADL->ADL_ENTIDA ==  cEnt .And. ADL->ADL_CODENT ==  cCodigo .And. ADL->ADL_LOJENT == cLoja
			
				nRec := ADL->(Recno())
				Exit 
			EndIf
			
			DbSkip()
		End	
	EndIf
	
#ENDIF
	
RestArea(aArea)

Return nRec

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} GetMaTabPr
Executa a fun็ใo MaTabPrVen para busca do pre็o do produto na tabela de Pre็o DA0/DA1.

@type       Function
@author     Alberto Deviciente
@since      17/01/2022
@version    12

@param cCodTab, Caractere, C๓digo da Tabela de Pre็o
@param cProduto, Caractere, C๓digo do Produto
@param nQtdade, Num้rico, Quantidade
@param cCliente, Caractere, C๓digo do Cliente
@param cLoja, Caractere, Loja do Cliente
@param nMoeda, Num้rico, C๓digo da Moeda a ser considerada

@return nRet, Num้rico, Pre็o do Produto retornado da fun็ใo MaTabPrVen.
/*/
//-------------------------------------------------------------------------------------
Static Function GetMaTabPr(cCodTab, cProduto, nQtdade, cCliente, cLoja, nMoeda)
Local nRet 			:= 0
Local cChvCtrPrc	:= "" // Chave de Controle para nใo executar a fun็ใo MaTabPrVen para buscar o pre็o do mesmo produto diversas vezes.
Local nPosCtrl		:= 0
Local nPosCpoIte	:= 0
Local nPosCpoQtd	:= 0
Local cItem 		:= ""
Local nQtdAtu 		:= nQtdade //Quantidade Atual do Item
Local lIsVenda 		:= Type("M->LQ_NUM") == "C" //Identifica se foi chamado da Venda Assistida/Venda Direta

If lIsVenda
	If Type("aPosCpo") == "A"
		nPosCpoIte 	:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_ITEM"})][2]	 // Posicao do item
		nPosCpoQtd 	:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_QUANT"})][2]	 // Posicao da Quantidade
		cItem     	:= aCols[n][nPosCpoIte]
		nQtdAtu     := aCols[n][nPosCpoQtd]
		If "LR_QUANT" $ ReadVar()
			nQtdAtu := M->LR_QUANT //Considera a Quantidade Atual lan็ada para fazer o controle de chamada da fun็ใo MaTabPrVen. Caso seja igual, nใo chama novamente.
		EndIf
	EndIf

	cChvCtrPrc := xFilial("SL1") + M->LQ_NUM + cCliente + cLoja

	//Verifica se jแ foi chamada a fun็ใo MaTabPrVen. Caso positivo, somente retorna a mesma informa็ใo jแ retornada anteriormente.
	If Len(aRetMTabPr) > 0 .And. aRetMTabPr[1] == cChvCtrPrc //Verifica se ainda ้ ou nใo a mesma venda e mesmo cliente
		//Se encontrar informa็ใo jแ retornada da fun็ใo MaTabPrVen para os mesmos parโmetros jแ enviados anteriormente, apenas retorna o conte๚do jแ conhecido para nใo executar a fun็ใo novamente. Melhorando assim a performance do sistema.
		If ( nPosCtrl := aScan( aRetMTabPr[2], {|x| x[1] == cCodTab + cItem + cProduto + cCliente + cLoja } ) ) > 0
			If aRetMTabPr[2][nPosCtrl][2] == nQtdAtu
				nRet := aRetMTabPr[2][nPosCtrl][3]
			EndIf
		EndIf
	Else
		aRetMTabPr := {cChvCtrPrc, {}}
	EndIf
EndIf

If nRet == 0
	LjGrvLog(Nil ,"Antes da Chamada da Funcao MaTabPrVen")
	nRet := MaTabPrVen( cCodTab, cProduto, nQtdade, cCliente, cLoja, nMoeda )
	LjGrvLog(Nil ,"Apos a Chamada da Funcao MaTabPrVen. Retorno:",nRet)

	If lIsVenda
		If nPosCtrl > 0 //Se o item/produto jแ estแ no array de controle, atualiza a quantidade e o pre็o.
			aRetMTabPr[2][nPosCtrl][2] := nQtdAtu
			aRetMTabPr[2][nPosCtrl][3] := nRet
		Else
			aAdd( aRetMTabPr[2], { cCodTab + cItem + cProduto + cCliente + cLoja, nQtdAtu, nRet } )
		EndIf
	EndIf
EndIf

Return nRet
