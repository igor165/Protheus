#INCLUDE "LOJA140.CH"
#INCLUDE "PROTHEUS.Ch"
#INCLUDE "TBICONN.CH"
#INCLUDE "FWADAPTEREAI.CH" 

#DEFINE TEF_NAO_USADO				"1"		//Nao Utiliza TEF
#DEFINE TEF_SEMCLIENT_DEDICADO  	"2"     //Utiliza TEF Dedicado Troca de Arquivos
#DEFINE TEF_COMCLIENT_DEDICADO  	"3"		//Utiliza TEF Dedicado com o Client
#DEFINE TEF_DISCADO             	"4"		//Utiliza TEF Discado 
#DEFINE TEF_LOTE                	"5"		//Utiliza TEF em Lote
#DEFINE TEF_CLISITEF				"6"		//Utiliza a DLL CLISITEF
#DEFINE CANCEL_SAT					"CF-e-SAT Cancelado"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Release 11.5 - Cartao Fidelidade³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
#DEFINE MOVFID_ESTPGTO				"3"		//Codigo do tipo de movimento para cancelamento de venda paga com cartão fidelidade
#DEFINE MOVFID_ESTREC 				"4"		//Codigo do tipo de movimento para cancelamento de venda de produto do tipo recarga de cartão fidelidade

STATIC oIntCVenda 	:= Nil									// Objeto da integracao
STATIC oProcOff 	:= Nil									// Objeto de OffLine
Static lMvLjPdvPa   := LjxBGetPaf()[2] //Indica se é pdv  
Static lIsVendaVP 	:= .F.
Static lIsVdRecCP 	:= .F.
Static lExcAuto		:= IsBlind()
Static cNFisCanc	:= "" //nota de cancelamento sat
Static lIntDefPro	:= .F. //processamento Por Eai
Static lCancTef     := .F. // Informa se o Cancelamento TEF foi efetuado ou não
Static lLxIteracao	:= .F.
Static cPedSFat		:= "" //Numero do pedido de simples faturamento
Static aNfSFat		:= {} //Numero da nota e serie de outra filial para realizar o cancelamento da SF2/SD2 - SFT/SF3

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³ Loja140  ³ Autor ³ Vendas Clientes       ³ Data ³ 02.01.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Exclus„o de Notas Fiscais                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaLoja                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³           ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS/FNC  ³  Motivo da Alteracao                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Marco A.  ³06/03/18³DMINA-726  ³Se replican para V12.1.17, issues:   ³±±
±±³            ³        ³           ³ DMINA-64, DMINA-445, DMINA-871,     ³±±
±±³            ³        ³           ³ DMINA-817, DMINA-1082 y DMINA-1337; ³±±
±±³            ³        ³           ³ para Esquema CFDI 3.3 (MEX)         ³±±
±±³LuisEnriquez?9/01/19?MINA-5533   ³ Se agregan parametros correctos pa- ³±±
±±³            ³        ³           ³llamado de funci? CaBxAutSE1. (MEX)  ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LOJA140()
Local cLabelOpcao   := STR0003  	// "Exclus„o NF/Orc."
Local cLock 		:= cUserName + cEstacao
Local aCores 		:= Lj140DefLeg()  
Local cFiltro	    := NIL									// Filtro da mBrowse (personalizado)
Local lLj7069       := ExistBlock("LJ7069")				// Verifica se existe o PE LJ7069
Local lIsMDI 		:= Iif(ExistFunc("LjIsMDI"),LjIsMDI(),SetMDIChild(0)) //Verifica se acessou via SIGAMDI

lCancTef     := .F. // Informa se o Cancelamento TEF foi efetuado ou não

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Faz o controle via LockByName para evitar que um usuário acesse       ³
//³ 2 vezes uma rotina que use os periféricos de automação, evitando assim³
//³ a concorrência dos mesmos.                                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lIsMDI .AND. !LockByName( cLock )
	Return Nil
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso for modulo loja e determinados estados, não vai ser possivel     ³
//³ cancelamento de notas e orçamento pelo siga loja                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If LjNfPafEcf(SM0->M0_CGC) .And. nModulo <> 5 .And. lMvLjPdvPa
	MsgAlert(STR0091) //"Nao e permitido exclusao de DAV - PAF-ECF REQUISITO XI "
	Return Nil	
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define Variaveis 										     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Private cCadastro    := STR0001	  	// Exclus„o N.F./Orcam.
Private aTefDados    := {}
Private lVendaRapida := .F.
Private aRotina      := {}

If cPaisLoc <> "BRA"
	Private lNFManual  := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Carrega as variaveis e perfil de caixa no primeiro acesso³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nModulo == 5
	If !lIsMDI
		OpenLoja()
	EndIf 
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define Array contendo as Rotinas a executar do programa 	 ³
//³ ----------- Elementos contidos por dimensao ------------	 ³
//³ 1. Nome a aparecer no cabecalho 							 ³
//³ 2. Nome da Rotina associada									 ³
//³ 3. Usado pela rotina										 ³
//³ 4. Tipo de Transa‡„o a ser efetuada							 ³
//³	 1 - Pesquisa e Posiciona em um Banco de Dados				 ³
//³	 2 - Exclui a nota fiscal/orcamento/pedido                   ³
//³	 3 - Anula nota fiscal (localizacoes)                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//|  Pesquisa / Exclus„o NF/Orc.                                          |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPaisLoc == "BRA"
	aRotina := MenuDef()
Else
	If cPaisLoc == "SAL"
		cCadastro   := STR0061  // "Exclus„o Doc.Saida/Orcam."
		cLabelOpcao := STR0062  // "Exclus„o Doc/Orc."
	ElseIf cPaisLoc == "GUA"
		cLabelOpcao := STR0065  // "Cancelar NF(NCC)"
	EndIf
	aRotina := MenuDef()
EndIf

DbSelectArea("SL1")
SL1->(DbSetOrder(1))

//Ponto de Entrada LJ7069 - que permite a alteração do mBrowser com o filtro retornado
If lLj7069
	LjGrvLog( NIL, " Antes de executar o P.E. LJ7069")
	xRet := ExecBlock("LJ7069",.F.,.F.)
	LjGrvLog( NIL, " Depois de executar o P.E. LJ7069",xRet)
	If ValType(xRet) == "C"
	    cFiltro  := xRet
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Endere‡a a fun‡„o de BROWSE									 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
mBrowse(,,,,"SL1",,,,,, aCores,,,,,,,,cFiltro )

// Zerar as váriaveis referentes ao TEF
// Quando sair e retornar, as variaveis serao reinicializadas
// Ajustando a impressao na impressora nao fiscal
If nModulo == 5
	FinishLoja()
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Recupera a Integridade dos dados						     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
msUnlockAll()
Return Nil


/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    |MenuDef	³ Autor ³ Vendas Clientes       ³ Data ³28/12/06  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Funcao de definição do aRotina                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ aRotina   retorna a array com lista de aRotina             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ SIGALOJA                                                   ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function MenuDef() 

Local cLabelOpcao   := STR0003  	// "Exclus„o NF/Orc."
Local aRotina	:= {}
Local lVldExc   := GetAPOInfo("loja701.prw")[4] >= Ctod("05/09/2019") 

If cPaisLoc == "BRA"
	aRotina := {	{ STR0002  		,"AxPesqui"   	, 0 , 1 , , .F.},;     		//pesquisar
				 	{ STR0003  		,IIf(lVldExc,"Lj7140Exc","Lj140Exc")	, 0 , 5 , , .T.},;	    	//excluir
					{ STR0222		,"Lj140CCanc()"	, 0 , 5 , , .T.} }			//"Interromper Canc."
Else
	If cPaisLoc == "SAL"
		cLabelOpcao := STR0062  // "Exclus„o Doc/Orc."
	ElseIf cPaisLoc == "GUA"
		cLabelOpcao := STR0065  // "Cancelar NF(NCC)"
	EndIf
	aRotina := { 	{ STR0002     	, "AxPesqui"  , 0 , 1 , , .F. }, ;  //Pesquisa
				 	{ cLabelOpcao 	, "lj140Exc"  , 0 , 5 , , .T. }, ;  //"Exclus„o NF/Orc."
					{ STR0031     	, "lj140Anul" , 0 , 5 , , .T. } }   //"Cancelar"
	
EndIf

AAdd(aRotina,{"Legenda","Lj140Leg",0,8 , , .T. })      //legenda
							
Return ARotina

/*/{Protheus.doc} lj140Exc
Programa de exclusao de notas fiscais
@type  Function
@author Vendas Clientes
@since 02.01.95
@param	ExpC1 = Alias do arquivo
		ExpN2 = Numero do registro
		ExpN3 = Opcao selecionada
		ExpA4 = Reservado
		ExpL5 = Rotina Automatica
		ExpC6 = Filial do Orcamento
		ExpC7 = Numero do Orcamento
		ExpL11= Forca exclusão
@example
lj140Exc(ExpC1,ExpN2,ExpN3,ExpA4,ExpL5,ExpC6,ExpC7)
/*/
Function lj140Exc(	cAlias  , nReg      , nOpcx     , aReserv   ,;
 					lAuto   , cFilOrc   , cNumOrc   , cNotaCanc ,;
 					lFinCanc, cProtoNfce, lForceExc , lVendaInt ,;
					lRecpVenda)
Local nCnt       	:= 0											// Contador
Local nTamL1Cup  	:= TamSX3("L1_NUMCFIS")[1]    					// Tamanho do campo L1_NUMCFIS
Local lVendido   	:= .F.											// Valida o L2_VENDIDO
Local nOpca			:= 0							   				// Variavel com a opcao da tela
Local cNumPdv    	:= Space(10)									// Numero do PDV
Local cNumPdvAtu 	:= Space(4)						   				// Numero do PDV atual
Local oDlg															// Objeto Dialog
Local oCheckNFMan									   				// Objeto CheckBox se gera NF Manual
Local lLj140CanT 	:= (ExistTemplate("LJ140CAN"))					// Valida a existencia do Template
Local lLj140Can  	:= (ExistBlock("LJ140CAN"))		   				// Valida a existencia do Ponto de Entrada
Local lLj140DelT	:= (HasTemplate("DRO") .AND. ExistTemplate("LJ140DEL")) // Valida a existencia da função de delecao do template de drogarias
Local cNumCupFis 	:= Space(nTamL1Cup)				   				// Numero do cupom fiscal
Local nDecs      	:= 0	   										// Casas decimais
Local nPosVlrTot 	:= 0											// Posicao do Valor Total
Local nPosDescPro	:= 0									   		// Posicao do Desconto do produto
Local nPosVlrUni 	:= 0											// Posicao do valor unitario
Local nPosQuant  	:= 0											// Posicao da quantidade
Local nPosQtd  	    := 0											// Posicao da quantidade
Local nPosTesPro	:= 0											// Posicao do Tes
Local nY           	:= 0											// Contador utilizado no For
Local nImpostos  	:= 0											// Impostos
Local nImpsInc   	:= 0											// Valor dos impostos
Local aPropImp   	:= {}											// Array com impostos proporcionais
Local cSerie     	:= AllTrim(ljGetStation("LG_SERIE"))				// Serie da estacao
Local cDescMot      := ""											// Descricao do motivo
Local xRet															// Retorno da funcao
Local nAbatimentos  := 0											// Abatimentos
Local lUsafd    	:= SuperGetMV("MV_LJUSAFD",,.F.) 				// Utiliza Fidelizacao de cliente ??
Local cTpOper		:= "3"											// Indica que e uma operacao de exclusao de pontos
Local nPosProd   	:= 0                           					// Posicao do codigo do produto 
Local nPosVlItem 	:= 0                          					// Posicao do valor do item            
Local cGrupoProd 	:= ""											// Indica o grupo do produto
Local aProdCri		:= {}											// Array com os produtos a serem excluidos
Local cNumAnt		:= ""											// Numero anterior
Local lGeraNCC   	:= 0											// Numero da Ncc gerada
Local cNumNFDev  	:= ""											// Numero da nota fiscal de devolucao
Local cSerieDev  	:= ""											// Serie de devolucao
Local cMotivo    	:= "" 											// Motivo da devolucao
Local nX			:= 0											// Contador de For
Local lRetorno		:= .F.											// Retorno do ValType(xRet)   
Local aVales		:= {}											// Vetor com os vales            
Local cPdv     		:= AllTrim(LjGetStation("LG_PDV"))				// PDV da estacao
Local cOper		    := ""											// codigo da operacao
Local cNum			:= ""                              				// numero do orçamento
Local cFilSL1		:= ""											// Filial da Reserva
Local aAreMt		:= {}											// Bk do area
Local aChaveCHRe 	:= {}											// Chave de busca para deletar os cheques na venda com reserva
Local nVlrOrc		:= 0											// Soma dos valores dos itens (L2_VLRITEM)
Local aOrcamento	:= {}											// armazena os orcamentos que deverao ser excluidos
Local lSubClosed	:= .F.											// verifica se existe algum suborcamento finalizado
Local aArea			:= {}											// armazena a area do orcamento principal(orcamento pai) em caso de reservas
Local lLastOrc		:= .F.											// verifica se e o ultimo orcamento a ser excluido
Local lIntGC		:= .F.  										// Integracao com Gestao de Concessionarias
Local lAmbPAF		:= LjNfPafEcf(SM0->M0_CGC)						// verifica se o ambiente está em modo PAF
Local lNota			:= .F. 											// Controla se existe nota fiscal
Local cAuxDoc		:= ""
Local cAuxSerie		:= ""
Local lNFCe			:= ExistFunc("LjEmitNFCe") .AND.  LjEmitNFCe() .AND. ColumnPos("L1_KEYNFCE") > 0
Local lCliRecIss	:= .F.											// Cliente Recolhe ISS ?
Local lLstPre	 	:= .F.											// indica contem um item de Lista de Presente
Local aAuxRet		:= {.F.,.F.,"",{},"","",0,"",.F.,.F.,.F.,{},{},.T.}
Local lTEFCanc		:= .f.
Local nPosNumcFi	:= 0									// Posicao do Numero do cartao fidelidade
//³Tratamento para e-Commerce
Local lECommerce	:= SuperGetMV("MV_LJECOMM",,.F.) .And. ( ((ExistFunc("LJ861ECAuto") .And. LJ861ECAuto() .Or. ExistFunc("LJ862ECAuto") .And. LJ862ECAuto()) ) .OR.;
  						( SuperGetMv("MV_LJECOMO", .T., .F.) .AND. ( IsInCallStack("Lj907OrEx") .OR. ( SL1->(ColumnPos("L1_ECFLAG")) > 0 .AND. SL1->L1_ECFLAG == "1") ) )  )
Local lECCia 		:= !Empty(SL1->L1_ECPEDEC)  
Local aAreaMF5		:= {} 
Local lLjcFid	 	:= SuperGetMv("MV_LJCFID",,.F.) .AND. CrdxInt()				//Indica se a recarga de cartao fidelidade esta ativa
Local lAmbOffLn 	:= SuperGetMv("MV_LJOFFLN", Nil, .F.)						//Identifica se o ambiente esta operando em offline
Local cMvLjPref		:= SuperGetMV("MV_LJPREF")									//Regra para gravacao do SF2->F2_PREFIXO
Local cPrefE1		:= ""														//elemento que sera utilizado como SE1->E1_PREFIXO, na busca do titulo
Local cModDoc		:= ""
Local cDocNFCe 		:= ""
Local cSerieNFCe 	:= ""
Local cPrefixo		:= "" //Prefixo do título
Local aChaveSL1		:= {} //Chave do SL1
Local aAreaSL1		:= {} //WorkAreaSL1
Local lVendaSAT		:= !IsBlind() .AND. IIF(SL1->(ColumnPos("L1_SERSAT")) > 0,!Empty(SL1->L1_SERSAT),.T.) .And. !Empty(SL1->L1_KEYNFCE)
Local lIntegDef 	:= .F. 
Local nTamSx3E1P 	:= TamSX3("E1_PREFIXO")[1] //Tamanho do campo E!_PREFIXO definido no dicionário de ados SX3
Local lIsMDI 		:= Iif(ExistFunc("LjIsMDI"),LjIsMDI(),SetMDIChild(0)) //Verifica se acessou via SIGAMDI
Local lTemNFCup 	:= .F.						// Informa se existem Nota Sobre Cupom para esta venda
Local aDadosNFCp	:= {}						// Dados para a exclusão da Nota Sobre Cupom
Local cNFCupom   	:= ""						// Numero da Nota Sobre Cupom
Local lCancNFCup	:= .T.						// Informar se cancelou NF sobre Cupom
Local lIsNFeDen		:= .F.						// Informa se é nota Denegada
Local aPagDigPix 	:= {} 											//Informações de Pagamentos Digitais da venda

Private aHeader[0]
Private aCols[0]
Private aCampos		:=	{}
Private N			:= 1 //Variavel relacionada a linha da GetDados

Default cFilOrc		:= ""	   								   		// Filial do orcamento
Default cNumOrc 	:= ""	  										// Numero do orcamento
Default lAuto		:= .F.
Default cNotaCanc	:= ""
Default lFinCanc	:= .F.
Default cProtoNfce  := ""
Default lForceExc	:= .F.
Default lVendaInt	:= .F.
Default lRecpVenda	:= .F. 											// Indica se foi chamado pela recuperação de venda

//Seta a variável que indica que é um cancelamento via Integração
If lVendaInt
	Lj140StInD(.T.)

    SL1->(DbSetOrder(1))//L1_FILIAL+L1_NUM
    If SL1->(DbSeeK(xFilial("SL1")+Alltrim(cNumOrc)))

        SF2->(dbSetOrder(1))//F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA+F2_FORMUL+F2_TIPO			
        If !( SF2->(dbSeek(xFilial("SF2") + SL1->L1_DOC + SL1->L1_SERIE + SL1->L1_CLIENTE + SL1->L1_LOJA)) )
            Help(" ","1",STR0224 + "SF2")//"Nota de saída não encontrada na SF2" 
            Return(.F.)
        EndIf
    Else
        Help(" ","1",STR0224 + "SL1")//"Nota de saída não encontrada na SL1" 
        Return(.F.)
    EndIf    

EndIf

lIntegDef := Lj140GtInD() //Integracao via Mensagem Unica

If !Empty(cNotaCanc)
	cNfisCanc := cNotaCanc
EndIf

If !Type("aTefDados") == "A"
	Private aTefDados := {}
Endif

lCancTef := .F.

//Atualiza Static
lExcAuto	:= lAuto // Rotina automatica

LjGrvLog( SL1->L1_NUM, "Vai iniciar a exclusao do orcamento")

//Instancia o objeto oProcOff para Loja Offline.(Variavel Static)
If lAmbOffLn
	oProcOff := LJCProcessoOffLine():New("006") 
EndIf

If ExistFunc("LjSatVldSX") .And. LjUseSat() .And. !LjSatVldSX()
	LjGrvLog(Nil,"Cancelamento de venda SAT não efetuado")
	Return Nil
EndIf

If SuperGetMv("MV_LJVALEP",,.F.) .And. AliasIndic("MDD")

	aArea := GetArea()
	
	DbSelectArea("SL2")
	DbSetOrder(1)
	
	DbSelectArea("MDD")
	DbSetOrder(1)
	
	DbSelectArea("SE1")
	DbSetOrder(1)// E1_FILIAL + E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO 

	/* Validação para não execluir a venda caso possua vale presente utilizado */			
	If SL2->(DbSeek( xFilial("SL2") + SL1->L1_NUM ))
		While SL2->(!EOF()) .And. xFilial("SL2") == SL2->L2_FILIAL .AND. SL2->L2_NUM == SL1->L1_NUM
			If !Empty(SL2->L2_VALEPRE)
				If MDD->(DbSeek( xFilial("MDD") + SL2->L2_VALEPRE )) 
					
                    //Vale Crédito
                    If MDD->MDD_TIPO == 'C'
						If SE1->(DbSeek(xFilial("SE1") + SL1->L1_SERPED + SL1->L1_DOCPED)) 
							While SE1->(!EOF()) .And.  SL1->( L1_FILIAL + L1_SERPED + L1_DOCPED) == SE1->(E1_FILIAL +  E1_PREFIXO + E1_NUM)
								If  SE1->E1_TIPO == "NCC" .AND. (SE1->E1_SALDO <> SE1->E1_VALOR)
									MsgAlert(STR0201)//Não é possível fazer o cancelamento da venda de vale crédito, pois o mesmo já foi utilizado.	
									LjGrvLog( SL1->L1_NUM, STR0201)
									Return( Nil )
								EndIf
								SE1->(dbSkip())	 
							EndDo
						EndIf
                    
                    //TIPO=P Vale Presente                        
					Else
						If MDD->( ColumnPos("MDD_SALDO") ) > 0 .And. ( !Empty(SL1->L1_DOCPED) .Or. !Empty(SL1->L1_DOC) )
							If MDD->MDD_SALDO <> MDD->MDD_VALOR
								MsgAlert(STR0139) //Não é possível fazer o cancelamento da venda pois existe um vale presente já utilizado.
								LjGrvLog( SL1->L1_NUM, STR0139) //Não é possível fazer o cancelamento da venda pois existe um vale presente já utilizado.
								Return( Nil )
							EndIf
						EndIf
					EndIf
				EndIf

			EndIf
			SL2->(DbSkip())	
		EndDo
	EndIf
	
	RestArea(aArea)
EndIf

//Caso seja Orçamento e-Commerce nao pode excluir via browser.
If ( lECommerce ) .AND.  SL1->(ColumnPos("L1_ECFLAG") > 0) .AND. (SL1->L1_ECFLAG == "1")  
	If !lECCia 
	
		aAreaMF5 := MF5->(GetArea())    
		MF5->( DbSetOrder(1) ) 
		//Pedidos e-commerce, verifica se foi processado o pagamento
		If  MF5->(DbSeek(xFilial("MF5") + "SL1" + SL1->L1_FILIAL+ SL1->L1_NUM)) .AND. (MF5->MF5_ECPAGO = "1" .AND. MF5->MF5_ECFLAG = "1")
			Help(" ",1,"NO140CANC",,STR0187,3,1)  //"E-Commerce - Esse pedido possui documento fiscal emitido pelo modulo de Faturamento realize o cancelamento pelo Faturamento em seguida realize a exclusão do orçamento por essa rotina." 
			LjGrvLog( SL1->L1_NUM, STR0187) //"E-Commerce - Esse pedido possui documento fiscal emitido pelo modulo de Faturamento realize o cancelamento pelo Faturamento em seguida realize a exclusão do orçamento por essa rotina." 
			Return( Nil )
		EndIf
		RestArea(aAreaMF5)          
	Else    
		If !Empty(SL1->L1_DOC) .AND. !Empty(SL1->L1_SERIE)     .AND. !Empty(SL1->L1_EMISNF)
			//Pedidos e-commerce, verifica se foi realizada a venda             
			Help(" ",1,"NO140CANC", ,STR0187,3,1, )  //"E-Commerce - Esse pedido possui documento fiscal emitido pelo modulo de Faturamento realize o cancelamento pelo Faturamento em seguida realize a exclusão do orçamento por essa rotina." 
			LjGrvLog( SL1->L1_NUM, STR0187) //"E-Commerce - Esse pedido possui documento fiscal emitido pelo modulo de Faturamento realize o cancelamento pelo Faturamento em seguida realize a exclusão do orçamento por essa rotina." 
			Return( Nil )
		EndIf
	EndIf
EndIf

//Carrega a variável Inclui, utilizada no inicializador padrão do campo L2_REVLPRE
If Type("INCLUI") <> "L"
	Private INCLUI := (nOpcx <> 3)
EndIf

If lExcAuto .AND. !lForceExc

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Carrega as variaveis e perfil de caixa no primeiro acesso³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("lFTStartSilenc") == "U" .AND. nModulo == 5 .And. !lIntegDef
		If !lIsMDI
			OpenLoja(lExcAuto)
		EndIf 
	EndIf

	If !Empty(cNumOrc)
		
		DbSelectArea("SL1")
		SL1->( DbSetOrder(1) )
		
		If !SL1->( DbSeek(cFilOrc + cNumOrc) )
			LjGrvLog("", STR0116, cFilOrc + "|" + cNumOrc)	//"FILIAL|ORCAMENTO NAO localizado para ser excluido: "			
			Return .F.
		EndIf
	Else
		LjGrvLog("", STR0104)	//"Nenhum ORCAMENTO foi informado para exclusao"
		Return .F.
	EndIf
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
|aOrcamento:                                                                                                 	|
|	Atraves dos itens do orcamento principal, identificamos quais sao os sub-orcamentos(quando tiver reservas)	|
|	 e adicioanamos a esse array. Quando o orcamento nao possuir reservas, ele mesmo sera adicionado.		  	|
|	Estrutura do array aOrcamento																				|
|	[01] Filial do sub-orcamento L2_FILRES																	  	|
|	[02] Numero do sub-orcamento L2_ORCRES																	  	|
|	[03] indica se o orcamento em questao foi finalizado													  	|
|	[04] indica se o orcamento em questao foi possui algum pedido de venda amarrado								|
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/
If cPaisLoc <> "BRA"
	Private lAnulaSF3  := AtIsRotina("LJ140ANUL")
	If cPaisLoc == "GUA"
		cNumNFDev  := CriaVar("L1_DOC") //Numero da Nota de Credito a ser gerada
		cSerieDev  := AllTrim(SuperGetMV("MV_LJNFTRO"))
		cMotivo    := Space(6)
		lGeraNCC   := !lAnulaSF3
		lAnulaSF3  := .T.
	EndIf
EndIf

//Verifica se eh venda de Vale Presente
lIsVendaVP := If( ExistFunc("Lj7VPNew") .And. Lj7VPNew(), Lj7VdaIsVP(SL1->L1_NUM), .F.)

//-------------------------------------------------------------------------
// Carrega as variaveis estaticas referente ao "Cartao Presente" (Gift Card).
//-------------------------------------------------------------------------
lIsVdRecCP := .F.
If ExistFunc("Lj7CP_OK")
	If Lj7CP_OK()
		Lj7CP_Load()
		lIsVdRecCP := Lj7VdIsRCP(SL1->L1_NUM) //Verifica se eh venda de Recarga de Cartao Presente (Gift Card)
	Else
		lIsVdRecCP := .F.
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Carregamos aOrcamento com todos os orcamentos que serao excluidos.	|
//| A variavel lSubClosed, indica se algum sub-orcamento foi finalizado	|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aOrcamento := LJ140Fill(@lSubClosed)
LjGrvLog( SL1->L1_NUM, "Carrega todos os orcamentos que serao excluidos",aOrcamento)

//verifica se aOrcamento possui algum orcamento finalizado, seja ele pai ou filho
lVendido := aScan( aOrcamento, {|x| x[3] == .T.} ) > 0

//verifica se ha itens de Lista de Presente LOJA846
If ExistFunc("Lj8EstCC")
	lLstPre := aScan( aOrcamento, {|x| x[5] == .T.} ) > 0
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se a venda pode ser cancelada³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Lj140VlVend(@lFiscal	, @cNumCupFis	, @cNumPdvAtu	, @cSerie	, ;
			    @cAlias		, @nOpcA		, @lGeraNCC		, @lLj140Can, ;
			    nTamL1Cup	, aOrcamento	, lSubClosed	, lECommerce .AND. lECCia ,;
			    lForceExc   , lRecpVenda )
	LjGrvLog( , "venda nao pode ser cancelada")
	Return .F.		
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//|  Ponto de Entrada para uso de Template          |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lLj140CanT	// Executa um ponto de entrada para outras verifica‡”es
	lLj140CanT := ExecTemplate("LJ140CAN",.F.,.F.)
	If ValType(lLj140CanT) <> "L" .OR. !lLj140CanT
		Return Nil
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//|  Ponto de Entrada      							|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lLj140Can	// Executa um ponto de entrada para outras verifica‡”es
	LjGrvLog( NIL, " Antes da execução do P.E. LJ140CAN ")
	lLj140Can := ExecBlock("LJ140CAN",.F.,.F.)
	LjGrvLog( NIL, " Depois da execução do P.E. LJ140CAN ",lLj140Can)
	If ValType(lLj140Can) <> "L" .OR. !lLj140Can
		Return Nil
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Pontos de Entrada LJ140 utilizado pelo Template de Drogarias ³
//³ para delecao dos registros da tabela LK9-Logs Anvisa  		³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lLj140DelT
	ExecTemplate("LJ140DEL",.F.,.F., {lExcAuto})
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se a venda ja foi devolvida³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Lj140VlDev(@lVendido, @nCnt, aOrcamento, lSubClosed)
	LjGrvLog( , "Verifica se a venda ja foi devolvida")
	Return .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Avisa o usuario sobre a geracao ou nao da Nota de Credito - Loc. Guatemala  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPaisLoc == "GUA" .AND. lVendido
	If lGeraNCC
		If !lExcAuto
			If !MsgYesNo( STR0066 )					// "Esta operacao de cancelamento vai gerar uma Nota de Credito ao Cliente. Confirma?"
				Return NIL
			EndIf
		EndIf	
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//|     "Esta operacao de cancelamento nao gera Nota de Credito."                                           |
		//|     "Deve ser utilizada quando o pagamento da Nota Fiscal nao foi efetuado ou "                         |
		//|     "na ocorrencia de erro na impressao do documento. Confirma?"                                        |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lExcAuto
			If !MsgYesNo( STR0067 + chr(13) + STR0068 + chr(13) + STR0069 )
				Return NIL
			EndIf
		EndIf	
	EndIf
EndIf

If !lExcAuto
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se o cupom foi impresso na impressora atual³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Lj140VlImp(	lVendido	, cNumPdv	, lFiscal	, cNumPdvAtu, ;
					cNumAnt		, nTamL1Cup	, aOrcamento, lSubClosed, ;
					lLstPre)
		Return .F.
	EndIf
EndIf

If lVendido	//verifica se trata de um orcamento finalizado
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se tiver algum sub-orcamento finalizado, deve-se posicionar nele para que seja feitas as validacoes|
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lSubClosed
		aArea := SL1->( GetArea() )
		If !Lj140Pos(aOrcamento)
			LjGrvLog( , "Retorno da funcao Lj140Pos", .F.)
			Return .F.
		EndIf
	Endif

	If !Empty(SL1->L1_DOC)
		// Verifica a existência de NF sobre Cupom
		If !Empty( SF2->F2_NFCUPOM )
				lTemNFCup	:= .T.
				cNFCupom	:= SF2->F2_NFCUPOM
				aDadosNFCp	:= {SF2->F2_DOC, SF2->F2_SERIE, SF2->F2_CLIENTE, SF2->F2_LOJA}
		EndIf
	EndIf

	//retorno a area do orcamento principal
	If lSubClosed
		SL1->( RestArea(aArea) )
	EndIf

EndIf

LJ140FillGet( 5 )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Salva a integridade dos campos de Bancos de Dados 			 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX := 1 To Len(aHeader)
	Do Case
		Case AllTrim(aHeader[nX][2])	==	"L2_VRUNIT"
			nPosVlrUni := nX
		Case AllTrim(aHeader[nX][2])	==	"L2_VLRITEM"
			nPosVlrTot := nX
		Case AllTrim(aHeader[nX][2])	==	"L2_QUANT"
			nPosQuant  := nX
		Case AllTrim(aHeader[nX][2])	==	"L2_DESCPRO"
			nPosDescPro:= nX
		Case AllTrim(aHeader[nX][2])	==	"L2_TES"
			nPosTesPro := nX			
	EndCase
Next nX 

While .T.
	nImpostos := 0
	nImpsInc  := 0
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica nivel do desconto.							 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea( "SX3" )
	DbSetOrder( 2 )
	DbSeek( "L1_DESCONT" )
	DbSetOrder( 1 )
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Aceita o cabeçalho do Orcamento 					³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	M->L1_NUM		:= SPACE( TamSX3( "L1_NUM" )[1] )
	M->L1_DOC		:= SL1->L1_DOC
	M->L1_NROPCLI	:= SPACE( TamSX3( "L1_NROPCLI" )[1] )
	M->L1_VLRTOT	:= 0
	M->L1_CLIENTE	:= SuperGetMv( "MV_CLIPAD" )
	M->L1_DESCONT	:= 0
	M->L1_VEND		:= SuperGetMv( "MV_VENDPAD" )
	M->L1_DTLIM		:= dDataBase
	M->L1_VLRLIQ	:= 0
	M->L2_VALDESC	:= 0
	M->L2_DESC		:= 0
	
	DbSelectArea( "SL1" )
	cNum 			:= SL1->L1_NUM
	cFilSL1			:= SL1->L1_FILIAL
	M->L1_NUM		:= SL1->L1_NUM
	M->L1_NUMORC	:= SL1->L1_NUMORC
	M->L1_NROPCLI	:= SL1->L1_NROPCLI
	M->L1_VLRTOT	:= SL1->L1_VLRTOT
	M->L1_CLIENTE	:= SL1->L1_CLIENTE
	M->L1_DESCONT	:= SL1->L1_DESCONT
	M->L1_VEND		:= SL1->L1_VEND
	M->L1_DTLIM		:= SL1->L1_DTLIM
	M->L1_VLRLIQ	:= SL1->L1_VLRLIQ
	M->L1_LOJA		:= SL1->L1_LOJA
	M->L1_VALISS	:= SL1->L1_VALISS

	If SL1->( ColumnPos( "L1_ABTOPCC" ) ) > 0
		M->L1_ABTOPCC := SL1->L1_ABTOPCC
	EndIf
	
	nDecs	:= MsDecimais(SL1->L1_MOEDA)
	
	For nX := 1 To (Len(aCols) - 3)
		If cPaisLoc <> "BRA"
			If nPosDescPro > 0
				aCols[nX][nPosVlrTot] += aCols[nX][nPosDescPro]
			EndIf
			aCols[nX][nPosVlrUni] := Round( aCols[nX][nPosVlrTot] / aCols[nX][nPosQuant], nDecs )
			aPropImp :=	TesImpInf( aCols[nX][nPosTesPro])

			For nY := 1	To Len( aPropImp )
				If ( aPropImp[nY][3]=="1" )
					nImpostos += SL2->( FieldGet( ColumnPos( "L2_" + Substr( aPropImp[nY][2],4,7 ) ) ) )
				ElseIf ( aPropImp[nY][3]=="3" )
					nImpsInc  += SL2->( FieldGet( ColumnPos( "L2_" + Substr( aPropImp[nY][2],4,7 ) ) ) )
				EndIf
			Next nY
		EndIf
	Next nX
	
	If Len(aCols) == 0 
		If !lExcAuto 
			Help(" ","1","TROCADO")
			SetCursor(0)
			Return( Nil )
		Else
		  	//"Este orcamento contem um ou mais produtos trocados, por isso nao podera ser utilizado."
			Conout(STR0105)
			LjGrvLog( , STR0105)
			SetCursor(0)
			Return( Nil ) 		
		EndIf	
	EndIf
	
	nOpca := 0
	If cPaisloc <> "BRA"
		M->L1_VLRLIQ := M->L1_VLRTOT - nImpostos + M->L1_DESCONT
	EndIf	

    
	If !lExcAuto .AND. !lForceExc
		
				
		DEFINE MSDIALOG oDlg TITLE cCadastro From 3,0 TO 25,80 OF oMainWnd

			@1,01 Say STR0011		// Or‡amento:
			@1,05 MSGet M->L1_NUM When .F.

			@1,10 Say STR0023		// 'Documento    :'
			@1,15 MSGet M->L1_DOC When .F.

			//"NCC Manual?"
			If cPaisLoc == "GUA" .AND. lGeraNCC
				@5,220 CHECKBOX oCheckNFMan VAR lNFManual PROMPT STR0072 OF oDlg SIZE 60,08
			EndIf

			//Conferencia de caixa
			oGet := MSGetDados():New(30,5,100,315,nOpcx,,,"")

			@ 105, 005 TO 147, 110 OF oDlg PIXEL
			@ 105, 112 TO 147, 225 OF oDlg PIXEL
			@ 105, 227 TO 147, 315 OF oDlg PIXEL
		
			@ 110, 008 SAY xPadL( STR0012, 36 )		 SIZE 30, 07	OF oDlg PIXEL	// Seu Pedido:
			@ 110, 038 MSGET M->L1_NROPCLI When .F.	 SIZE 30, 08	OF oDlg PIXEL

			@ 122, 008 SAY xPadL( STR0013, 24 )		 SIZE 30, 07	OF oDlg PIXEL	// Cliente:
			@ 122, 038 MSGET M->L1_CLIENTE When .F.	 SIZE 30, 08	OF oDlg PIXEL

			@ 134, 008 SAY xPadL( STR0014, 31 )		 SIZE 30, 07	OF oDlg PIXEL	// Vendedor:
			@ 134, 038 MSGET M->L1_VEND When .F.	 SIZE 30, 08	OF oDlg PIXEL

			@ 110, 115 SAY xPadL( STR0015, 66 ) SIZE 66, 7 OF oDlg PIXEL	// Total de Mercadorias:

			@ 122, 115 SAY xPadL( STR0016, 36 ) SIZE 36, 7 OF oDlg PIXEL	// Desconto:
			If cPaisLoc == "BRA"
				@ 122, 170 MSGET M->L1_DESCONT When .F. Picture "@E 999,999.99" SIZE 46, 08 OF oDlg PIXEL
			Else
				@ 122, 170 MSGET M->L1_DESCONT When .F. Picture PesqPict("SL1","L1_DESCONT") SIZE 46, 08 OF oDlg PIXEL
			EndIf

			If cPaisLoc == "BRA"
			
				@ 110, 230 SAY xPadL( STR0017, 25 ) SIZE 25, 7 OF oDlg PIXEL	// L¡quido:
				@ 110, 260 MSGET M->L1_VLRLIQ When .F. Picture "@E 999,999.99"	SIZE 46, 08 OF oDlg PIXEL
				
				@ 122, 230 SAY xPadL( STR0018, 28 ) SIZE 25, 7 OF oDlg PIXEL	// Validade:
				@ 122, 260 MSGET M->L1_DTLIM  When .F.							SIZE 46, 08 OF oDlg PIXEL

				@ 110, 170 MSGET M->L1_VLRTOT When .F. Picture "@E 999,999.99"	SIZE 46, 08 OF oDlg PIXEL

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³bloco responsavel pelo Abatimento³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				@ 134, 115 SAY xPadL( STR0076, 66 ) SIZE 66, 07 OF oDlg PIXEL   // Abatimentos:
				nAbatimentos := 0			
				If SL1->( ColumnPos( "L1_ABTOPCC" ) ) > 0
					M->L1_VLRLIQ -= M->L1_ABTOPCC
					nAbatimentos += M->L1_ABTOPCC
				EndIf				
				// Verifica se esta usando a nova configuracao para confirmar se o cliente recolhera o iss.
				If SuperGetMV("MV_LJRECIS",,.F.) .AND. SL1->(ColumnPos("L1_RECISS")) > 0   
					lCliRecIss := SL1->L1_RECISS == "1" .AND. GetNewPar("MV_DESCISS", .F.)  					
				Else
					lCliRecIss := (Posicione("SA1",1,xFilial("SA1")+M->L1_CLIENTE+M->L1_LOJA,"SA1->A1_RECISS") == "1" .AND.;
									GetNewPar("MV_DESCISS", .F.) )
				EndIf					
					
				If lCliRecIss
					M->L1_VLRLIQ -= M->L1_VALISS
					nAbatimentos += M->L1_VALISS
				EndIf
				@ 134, 170 MSGET nAbatimentos When .F. Picture "@E 999,999.99"	SIZE 46, 08 OF oDlg PIXEL
			
			Else
			
				@ 110, 230 SAY xPadL( STR0018, 28) 			SIZE 28, 7 	OF oDlg PIXEL	// Validade:
				@ 110, 260 MSGET M->L1_DTLIM	When .F.	SIZE 46, 08	OF oDlg PIXEL

				//o valor liquido e valor de mercadoria sao invertidos ?
				@ 110, 170 MSGET M->L1_VLRLIQ	When .F. Picture PesqPict("SL1","L1_VLRLIQ") 	SIZE 46, 08 OF oDlg PIXEL
								
				@ 134, 115 SAY xPadL( STR0017, 25) SIZE 25, 7 OF oDlg PIXEL	// L¡quido:				
				@ 134, 170 MSGET M->L1_VLRTOT	When .F. Picture PesqPict("SL1","L1_VLRTOT") 	SIZE 46, 08 OF oDlg PIXEL
				
				@ 122, 230 SAY xPadL( STR0027, 28 ) SIZE 28, 7 OF oDlg PIXEL	// Imp. Inc.:
				@ 122, 260 MSGET nImpsInc When .F. /*Picture PesqPict("SL1","L1_VALIMP1")*/			SIZE 46, 08 OF oDlg PIXEL
					
				@ 134, 230 SAY xPadL( STR0028, 28 ) SIZE 28, 7 OF oDlg PIXEL 	// Imp. Disc.:
				@ 134, 260 MSGET nImpostos When .F. /*Picture PesqPict("SL1","L1_VALIMP1")*/ 		SIZE 46, 08 OF oDlg PIXEL
				
			EndIf

		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| nOpca := 1,oDlg:End()},{|| nOpca := 2,oDlg:End()}) CENTERED
		
		//Quando é finalização de cancelamento não pode executar outra ação alem de cancelar efetivamente a venda
		If lFinCanc .And. nOpca <> 1
			nOpca := 1
		EndIf
	Else
		//Rotina Automatica
		nOpcA := 1			
	EndIf
	
	If nOpcA == 1
	
		aArea := SL1->(GetArea())

		//se for filho UNICO finalizado, add o orcamento pai ao aOrcamento, pois se somente existir um filho, o orcamento pai nao sera excluido
		If lSubClosed .AND. Len(aOrcamento) == 1
			AADD(aOrcamento, {SL1->L1_FILIAL, SL1->L1_NUM, .F.})
		EndIf

		// Verifica se eh venda com NFC-e		
		cModDoc := LjGetMDoc(aOrcamento, @cDocNFCe, @cSerieNFCe, Nil, @lIsNFeDen)
		
		If cModDoc $ "55|65" .OR. Lj7VdNoFis(aOrcamento)

			If AllTrim(Upper(cMvLjPref)) <> "SF2->F2_SERIE"
				cPrefixo := &(cMvLjPref) //como o conteudo do parametro nao e padrao, ele e macro executado.
				cPrefixo := Substr(PAdr(AllTrim(cPrefixo),nTamSx3E1P),1,nTamSx3E1P)
			Else
				cPrefixo:= LJPREFIXO()
			EndIf

			If ExistFunc("LJ7NumTit") 
				aAuxRet[3] := { xFilial("SE1"), cPrefixo, LJ7NumTit() }
			ElseIf lLstPre
				aAuxRet[3] := { xFilial("SE1"), cPrefixo, Iif(!Empty(SL1->L1_DOC),SL1->L1_DOC,SL1->L1_DOCPED) }
			Else
				aAuxRet[3] := { xFilial("SE1"), cPrefixo, SL1->L1_DOC }
			EndIf 
			
			aAreaSL1 := SL1->(GetArea())
			//Busca o orçamento finalizado
			If !Empty(aOrcamento[1][1]) .AND. !Empty(aOrcamento[1][2]) .AND. aOrcamento[1][3]				
				Lj140Pos(aOrcamento)
			EndIf
			If lLstPre
				aChaveSL1 := { xFilial("SE1"), Iif(!Empty(SL1->L1_SERIE), SL1->L1_SERIE, SL1->L1_SERPED), Iif(!Empty(SL1->L1_DOC), SL1->L1_DOC, SL1->L1_DOCPED), SL1->L1_CLIENTE, SL1->L1_LOJA }
			Else
				aChaveSL1 := { xFilial("SE1"), SL1->L1_SERIE, SL1->L1_DOC, SL1->L1_CLIENTE, SL1->L1_LOJA }
			EndIf			
			RestArea(aAreaSL1)
			
		   	/*Array criado para que seja usado ao inves de declarar cada variavel*/
			aAuxRet[1]	:= .F.
			aAuxRet[7]	:= TamSx3("F2_DOC")[1]
			aAuxRet[8]	:= cDocNFCe
			aAuxRet[11]	:= .F. // lTefOk
			aAuxRet[12]	:= {}
			aAuxRet[13]	:= {}
				
			aAuxRet[14] := Lj140Valida( aAuxRet[1]/*lJob*/, @aAuxRet[2]/*lVendTef*/,aAuxRet[3]/*aChave*/,@aAuxRet[4]/*aCheques*/,;
										@aAuxRet[5]/*cSerNfCup*/,@aAuxRet[6]/*cNumNfCup*/,aAuxRet[7]/*nTamDoc*/,aAuxRet[8]/*cNumNota*/,;
										@aAuxRet[9]/*lAchouSF2*/,aAuxRet[10]/*lLstPre*/, , aChaveSL1)

			LjGrvLog( SL1->L1_NUM, "Retorno da funcao Lj140Valida", aAuxRet[14] )

			If aAuxRet[14]
				If !isBlind()                      
					/*
						Validação para exclusão da Venda NFC-e quando tiver TEF
					*/
					If  aAuxRet[2]
						Lj140TlCTef(aAuxRet[1]		,	@aAuxRet[2]	, Iif( Type("oTef") == "U" , Nil, @oTef ), @aAuxRet[11],;
									@aAuxRet[12]	,	@aAuxRet[13])
						
						//Se o cancelamento do TEF não teve sucesso , não permito prosseguir com o cancelamento da NFCE
						lTEFCanc := aAuxRet[11]
						If !lTEFCanc
							If  cModDoc $ "55|65" 
								Alert(STR0145) //"Operação de cancelamento do TEF não realizada, portanto NFC-e não poderá ser cancelada"
							Else
								Alert(STR0170)//"Operação de cancelamento do TEF não realizada, portanto a venda não poderá ser cancelada"						
							EndIf
							Return .F.
						EndIf
					EndIf

					//Cancela transações de Pagamento Digital.
					If ExistFunc("LjPDGtPGrv") .And. ExistFunc("LjPDCanTrn")
						//Busca informações de Pagamentos Digitais gravados na venda.
						aPagDigPix	:= LjPDGtPGrv(SL1->L1_NUM, .T.)

						If Len(aPagDigPix) > 0 .And. !LjPDCanTrn(@aPagDigPix)
							//Se o cancelamento de Pagamento Digital não teve sucesso, não permito prosseguir com o cancelamento da venda
							Help( 	" ", 1, "TOTVSTDP", ,STR0228, 1, 0 ) // "Operação de cancelamento de Pagamento Digital/PIX não realizada, portanto a venda não poderá ser cancelada."
							Return .F.
						EndIf
					EndIf

				EndIf
			Else
				Return .F.
			Endif

			If !aAuxRet[14] .Or. (cModDoc $ "55|65" .And. !Lj140DOCe(aOrcamento)) .AND. !lIsNFeDen
				Return .F.
			EndIf

		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ primeiro cancelaremos os filhos finalizados(aVendido[3]) e soh por ultimo o orcamento pai ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If lTemNFCup .AND. !Empty(aDadosNFCp)
			//se houver NF sobre Cupom, executamos a sua exclusao
			Help( 	" ", 1, "EXCNFCUP", ,;
							STR0225 + CHR(13)+CHR(10) +;
							STR0227 + SubSTR(cNFCupom,4,Len(cNFCupom)) + CHR(13)+CHR(10) +;
							STR0226 + SubSTR(cNFCupom,1,3), 1, 0 ) 
			// "Esta venda possui Nota Fiscal atrelada, e será cancelada." " Nota:" " Serie: "

			If !LojR130( {aDadosNFCp} )
					Help( 	" ", 1, "NOEXCNFCUP", ,;
							STR0078 + Subs(SF2->F2_NFCUPOM,1,3) + " " + Subs( SF2->F2_NFCUPOM,4 ) + STR0079 + SL1->L1_SERIE + " " + SL1->L1_DOC,;
							1, 0 )
					//"Não foi possível excluir a nota fiscal XXX XXXXXX" #" que foi relacionada ao cupom XXX XXXXXX"
				lCancNFCup := .F.
			EndIf

		EndIf

		If lCancNFCup

			// Inicio de Transacao em Banco
			// Para quando for transaco TEF e ecorrer algum erro, nao cancela os orcamentos filhos
			BeginTran()
			
			aAreaSL1 := SL1->(GetArea())
			SL1->( RestArea(aArea) )	//posiciona no orcamento pai ou no orcamento unico, caso nao tenha sub-orcamentos 
			Lj140DelNCC()				//estorna NCC somente na exclusao do orcamento pai ou orcamento unico finalizado
			RestArea(aAreaSL1)

			For nCnt := 1 To Len(aOrcamento)	
			
				//verifica se eh um orcamento filho finalizado
				If !Empty(aOrcamento[nCnt][1]) .AND. !Empty(aOrcamento[nCnt][2]) .AND. aOrcamento[nCnt][3]
					lVendido := aOrcamento[nCnt][3]
					If !Lj140Pos(aOrcamento)
						Return .F.
					Endif
				Else
					lLastOrc := .T.				//utilizado no final do FOR para que saia do Loop
					lVendido := aOrcamento[nCnt][3]
					SL1->( RestArea(aArea) )	//posiciona no orcamento pai ou no orcamento unico, caso nao tenha sub-orcamentos 
					Lj140DelNCC()				//estorna NCC somente na exclusao do orcamento pai ou orcamento unico finalizado
					If lLstPre
						Lj140LstP(SL1->L1_FILIAL, SL1->L1_NUM)	//estorna os lancamentos na conta corrente e quantidade da Lista de Presente
					EndIf
				EndIf

				cNum	:= SL1->L1_NUM
				cFilSL1	:= SL1->L1_FILIAL
				
				If (ExistTemplate("LJ140EXC"))
					ExecTemplate("LJ140EXC",.F.,.F.,{lVendido})
				EndIf
				
				 If (ExistBlock("LJ140EXC"))
					LjGrvLog(Nil, "Antes da Execução do P.E. LJ140EXC")
					ExecBlock("LJ140EXC",.F.,.F.)
					LjGrvLog(Nil, "Depois da Execução do P.E. LJ140EXC")
				EndIf
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Funcao para zerar os pontos obtidos na venda                              ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If CRDXInt() .AND. lUsaFD
					
					If !Empty( SL1->L1_DOC )
						
						nPosProd   	:= aScan(aHeader,{|x| Alltrim(Upper(x[2]))=="L2_PRODUTO"})	// Posicao do codigo do item
						nPosVlItem 	:= aScan(aHeader,{|x| Alltrim(Upper(x[2]))=="L2_VLRITEM"})	// Posicao do Valor Total do Item
						nPosQtd 	:= aScan(aHeader,{|x| Alltrim(Upper(x[2]))=="L2_QUANT"})	// Posicao do Valor Total do Item				
										
						For nY := 1 to Len( aCols )
							cGrupoProd :=  Posicione("SB1",1,xFilial("SB1") + aCols[nY][nPosProd],"SB1->B1_GRUPO")
								AADD ( aProdCri, { aCols[nY][nPosProd], cGrupoProd , aCols[nY][nPosVlItem] , aCols[nY][nPosQtd] } )
						
						Next nY
						
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Funcao para debitar os pontos                 ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !Crd240_002(cTpOper			,;	//01 Exclusao
										M->L1_CLIENTE	,;	//02 Codigo do cliente
										M->L1_LOJA		,;	//03 Loja do clinte
										aProdCri		,;	//04 Array com os produtos para analise dos pontos
										M->L1_VLRLIQ	,;	//05 Total da Venda
										SL1->L1_DOC		,;	//06 Numero do documento
										SL1->L1_SERIE	,;	//07 Serie
										SL1->L1_DOC		,;	//08 Numero da venda original
										SL1->L1_SERIE	,;	//09 Serie da venda original
										Nil				,;	//10 Identifica se e do Loja ou do Televendas
										Nil				,;	//11 Indica se grava MAX ou somente calcula pontos
										Nil				,;	//12 Total de pontos
										Nil				 )	//13 Pagamento com Vale-Compra calcular sobre a dif.
							If !lExcAuto
								Aviso( STR0006,STR0077,{STR0048} )
								Return NIL
							Else 
								//"Falha no cancelamento dos pontos referente a campanha de fidelizacao." 
								Conout(STR0106)
								LjGrvLog( SL1->L1_NUM, STR0106 )
								Return NIL
							EndIf	
						Else
						
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Retorna status do vale compra                ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If AliasIndic( "MB1" )
								dbSelectArea("MB1")
								dbSetOrder(2) // MB1_FILIAL+MB1_SERIE+MB1_NF+MB1_CODIGO
								dbSeek(xFilial("MB1") + SL1->L1_SERIE + SL1->L1_DOC)
								
								While !EOF() .AND. MB1_FILIAL + MB1_SERIE + MB1_NF == xFilial("MB1") + SL1->L1_SERIE + SL1->L1_DOC
									aVales := {{MB1->MB1_CODIGO,Nil,Nil,MB1->MB1_CODIGO,.F.}}
									
									If MB1->MB1_OPER == 2
										cOper := "4"
									ElseIf MB1->MB1_OPER == 3 	  
										cOper := "2"
									EndIf	
									
									If !Crd240UpdMAV( aVales, cOper )
										If !lExcAuto		
											Aviso( STR0006,STR0077,{STR0048} )
										Else 
											//"Falha no cancelamento dos pontos referente a campanha de fidelizacao." 
											Conout(STR0106)
										EndIf	
									Else
										aVales := {MB1->MB1_CODIGO,Nil,Nil,MB1->MB1_CODIGO,.F.}
										CRDA270Log( aVales, cOper, SL1->L1_DOC, cPdv, SL1->L1_SERIE )			 	
									EndIf	
									
									dbSelectArea("MB1")
									dbSkip()
								EndDo
							EndIf			
						EndIf
					EndIf
				EndIf
				
				If AliasIndic('MDU')
				
					aAreMt := GetArea()
					
					DbSelectArea('MDU')
					MDU->( DbSetOrder(2) )		
					MDU->( DbSeek(xFilial( "SL2" )+SL1->L1_DOC+SL1->L1_SERIE) )
					
					While !EOF() .AND. (MDU->MDU_DOC == SL1->L1_DOC) .AND. (MDU_SERIE == SL1->L1_SERIE)
						
						RecLock('MDU',.F.)  
							MDU->( DbDelete() )
						MDU->( MsUnLock() )

						MDU->( DbSkip() )
					End	
					
					RestArea(aAreMt)		
				
				EndIf	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Determinar a numeracao e o motivo da NCC - Loc. Guatemala                 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If cPaisLoc == "GUA" .AND. lVendido
					If lGeraNCC .AND. !Lj140Manual()
						Return NIL
					EndIf
					If !Lj021MotDev(@cDescMot)
						Return NIL
					EndIf
					If lGeraNCC
						If !LJ021Nota(.T.)
							Return NIL
						EndIf
					EndIf
				EndIf
				
				If !lVendido
					
					If AllTrim(Upper(cMvLjPref)) <> "SF2->F2_SERIE"
						cPrefE1 := &(cMvLjPref) //como o conteudo do parametro nao e padrao, ele e macro executado.
						cPrefE1 := Substr(PAdr(AllTrim(cPrefE1),nTamSx3E1P),1,nTamSx3E1P)
					Else
						cPrefE1 := LJPREFIXO()
					EndIf
					
					If ExistFunc("LJ7NumTit")
						aChaveCHRe := { xFilial("SE1"), cPrefE1, LJ7NumTit() }
					Else
						aChaveCHRe := { xFilial("SE1"), cPrefE1, SL1->L1_DOCPED }
					EndIf
				EndIf

				If !Lj140ChkRes(lVendido, aChaveCHRe)
					Return Nil
				EndIf

				lNota := nModulo == 5 .And. !Empty(SL1->L1_DOC) .And. !Empty(SL1->L1_SERIE)
				cAuxDoc := SL1->L1_DOC
				cAuxSerie := SL1->L1_SERIE

				LjGrvLog( SL1->L1_NUM, "lj140Exc | Antes de enviar para Lj140Grava",)
				xRet  := Lj140Grava(Nil, cDescMot, lGeraNCC, cNumNFDev, cSerieDev, cMotivo, cNum, lNFCe, lLstPre, cProtoNfce)
				LjGrvLog( SL1->L1_NUM, "lj140Exc | Apos de enviar para Lj140Grava | xRet: " + cValToChar( xRet ) , )

				cNfisCanc := ""
				
				lRetorno := xRet
				
				//Se deu erro na gravação, sai do loop
				If !lRetorno
					Exit
				EndIf

				If lRetorno .And. FwHasEai("LOJI701A",.T.,,.T.)
					aAreaSL1 := SL1->(GetArea()) 
					//Efetua o envio da mensagem do registro do pedido cancelado
					LjGrvLog("LOJA140", "Gera mensagem de Rastreio se venda contiver itens do tipo Retira. Pedido Cancelado (LOJI701A)")
					FwIntegDef("LOJI701A",,,, "LOJI701A")	
					RestArea(aAreaSL1)
				EndIf

				If (SL1->L1_ORIGEM = 'N' .AND. !Empty(SL1->L1_UMOV)) .AND. ExistFunc("RmiExeGat") .AND. ExistFunc("SHPStatus")					
					SHPStatus("canceled")
				EndIf

				//------------------------------------------------------------------------------------------------
				//|Avalia se o orcamento contem reservas, nesse caso sera necessario limpar as tabelas SL1 e SL2 |
				//------------------------------------------------------------------------------------------------
				If	lRetorno .AND.  ( IIf(!lAmbPAF, Empty(L1_DOC), .T.) .AND. SL1->L1_TIPO == "P" .AND. !Empty(SL1->L1_DOCPED) .AND. ;
					SL1->L1_STATUS<>"D" .AND. ( SL1->(ColumnPos("L1_STATUES")) = 0 .OR. Empty(SL1->L1_STATUES) )	) //Pedidos encerrados
					
					Lj140LpSL2(cNum, @nVlrOrc)
					Lj140LpSL1(CrdxInt(), cNum, nVlrOrc)
				EndIf		
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//|    Verifica se o orcamento foi gerado pela integracao com Gestao de Concessionarias  |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If (SuperGetMV("MV_VEICULO",,"N")) == "S" .AND. SL1->(ColumnPos("L1_ORIGEM")) > 0 .AND. ;
					SL1->L1_ORIGEM == "V" .and. !SL1->L1_VEICTIP $ "1/2"
					lIntGC  := .T.
				EndIf
						
				If lRetorno .And. !lVendido .Or. AllTrim( FunName() ) == "LOJA220" .Or. lIntGC .Or. nModulo == 5 .Or. lECommerce .Or. lForceExc

					If ( (lAmbPAF .AND. nModulo <> 5) .OR. (IIf((LjAnalisaLeg(6)[1] .AND. !lNFCe), LjEmiteNF(SM0->M0_CGC), .T.) .AND. nModulo <> 5) );
						.OR. FunName() = "LOJA220" .OR. cPaisLoc <> "BRA" ;
						.OR. ( !LjMPreVend(SM0->M0_CGC) .AND. LjNVCC(SM0->M0_CGC) .AND. nModulo <> 5 );
						.OR. ( nModulo == 5 .And. !(lNota) );
						.OR. SL1->L1_TPORC == "E"

						lj140ExcOrc()

					ElseIf (!lFiscal .And. lIntGC .And. nModulo == 5) .Or. lECommerce .Or. lForceExc
						lj140ExcOrc()

					ElseIf nModulo <> 5 
						If lFiscal
							If !lExcAuto
								MsgStop(STR0050 + Chr(10)+ Chr(13) + ; 				//"Esse cupom sera cancelado de forma "
								STR0051 + Chr(10)+ Chr(13) + ; 						//"automatica. Conforme lei estadual  "
								STR0052)												//"vigente que regulamenta pre-venda. " 
							Else 
								Conout(STR0050+STR0051+" "+STR0052)
							EndIf	

							If Lj140ICOrc()
								lj140ExcOrc()
							Else
								If !lExcAuto
									MsgStop( 	STR0030 + Chr(10)+ Chr(13) + ; 	//"Existem problemas com a impressora fiscal"
												STR0059, STR0047 ) 					//"Não foi possível imprimir e cancelar o orçamento!" //Atenção
								Else 
									Conout(STR0030)
									Conout(STR0059)
								EndIf				
							EndIf

						Else 
							If !lExcAuto
								MsgStop(STR0060 + Chr(10)+ Chr(13) + ;				//"Para cancelar o orcamento o usuario deve ser fiscal"
										STR0063 + Chr(10)+ Chr(13) + ;				//"Por exigencia da Legislação Vigente no Estado, para todo orçamento cancelado, "
										STR0064, STR0047)							//"deve ser impresso um cupom fiscal e seu cancelamento"
							Else 
								Conout(STR0060)
								Conout(STR0063+STR0064)	
							EndIf			
						EndIf
					EndIf
				EndIf
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//|     Verifica se o Siga Loja esta integrado com o Gestão Hospitalar                                      |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lRetorno .AND. GetNewPar("MV_LOJAHSP",.F.)
					HS_ExclRAt(M->L1_NUM, aOrcamento[nCnt][3])
				EndIf		
				
				//trecho retirado dédito técnico funções não compiladas
			
				If cPaisLoc == "GUA" .AND. lGeraNCC .AND. lRetorno
					Lj021Imprime()
					
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//| "Aten‡„o"###"Foi gerada a Nota de Credito "###"Ok"  |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !lExcAuto
						Aviso( STR0006,STR0070 + AllTrim( cSerieDev ) + "-" + cNumNFDev,{STR0048} )
					Else 
						Conout(STR0070 + AllTrim( cSerieDev ) + "-" + cNumNFDev)
					EndIf		
				EndIf

				// Atualiza os campos F3_DTCANC e FT_DTCANC
				If lRetorno .AND. lIsNFeDen .AND. Len(aChaveSL1) > 0
					Lj140CancSF3(aChaveSL1[02], aChaveSL1[03], aChaveSL1[04], aChaveSL1[05], , , .T., lIsNFeDen) 
				EndIf
						
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Caso seja o orcamento pai ou orcamento unico, exclui o cartão fidelidade e sai do Loop³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lLastOrc
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Release 11.5 - Cartao Fidelidade³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
					If lRetorno .AND. lLjcFid .AND. xRet
						nPosProd   	:= aScan(aHeader,{|x| Alltrim(Upper(x[2]))=="L2_PRODUTO"})		// Posicao do codigo do item
						nPosNumcFi 	:= aScan(aHeader,{|x| AllTrim(Upper(x[2])) == "L2_NUMCFID"})	// Posicao do Numero do cartao fidelidade
						For nY := 1 to Len( aCols )
							//Cancelamento de venda de recarga de cartao fidelidade
							If LaFunhProd(aCols[nY][nPosProd])
								Ca280Exec("CA280ESLD",aCols[nY][nPosNumcFi],,,M->L1_DOC,cSerie,M->L1_LOJA,MOVFID_ESTREC)
							Else
								//Cancelamento de venda paga com cartao fidelidade
								DbSelectArea("SL4")
								DbSetOrder (1)
								If DbSeek (xFilial("SL4")+M->L1_NUM)
									While SL4->(!Eof()) .AND. SL4->L4_NUM == M->L1_NUM
										If Alltrim(SL4->L4_FORMA) == "FID"
											//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
											//³Se a venda foi paga com cartao fidelidade, entao o ³
											//³movimento de saida sera estornado da tabela MBN    ³
											//³e o valor devolvido ao respectivo saldo.           ³
											//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
											Ca280Exec("CA280ESLD",SL4->L4_NUMCFID,,,M->L1_DOC,cSerie,M->L1_LOJA,MOVFID_ESTPGTO)
											Exit
										EndIf
										SL4->(DbSkip())
									End
								EndIf
			
							Endif
						Next nY		
					EndIf
					
					Exit //saida do For nCnt
				EndIf
			Next nCnt

		EndIf
		
	Else
		DbSelectArea("SL1")
	End
	Exit
End
 
EndTran()
              
// Destravar todos os registros que estejam eventualmente locados
MsUnLockAll() 

aNfSFat := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se existe SC gerada pelo orcamente. se tiver cancela		       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ    
If lRetorno .And. nOpcA == 1 .AND. ( (AllTrim(Str(SuperGetMv("MV_LJGERSC",,1))) $ "2|3")  .OR. lECommerce )
	If  ExistFunc("LA590CncSC")
    	LA590CncSC(cNum,cFilSL1)
    Endif	
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se for orçamento e-commerce realiza a sinalização do cancelanmento para ser enviado para o site³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRetorno .And. !( lECommerce ) .AND.  SL1->(ColumnPos("L1_ECFLAG") > 0) .AND. (SL1->L1_ECFLAG == "1")
   	aAreaMF5 := MF5->(GetArea())    
	MF5->( DbSetOrder(1) ) 
	//Pedidos e-commerce, verifica se foi processado o pagamento
	If  MF5->(DbSeek(xFilial("MF5") + "SL1" + SL1->L1_FILIAL+ SL1->L1_NUM))

		    If  MF5->( RecLock("MF5") )
		        MF5->MF5_ECFLAG := "2"  //Inativo
		        MF5->MF5_ECDTEX := " "
		    	MF5->MF5_ECSTAT := "5"  // 5-Status e-commerce para cancelado
		    	MF5->( MsUnLock() )
		    EndIf   
	EndIf
	RestArea(aAreaMF5)
EndIf

If lRetorno .AND. lVendaSAT .AND. ExistFunc("LjSaCtrCnc")
	LjSaCtrCnc(.F.,.T.,.F.,.F.,"") //Apaga o arquivo sinal de recuperação de cancelamento
EndIf

//Para o Venda Direta, fecha a comunicação com o periférico neste ponto apenas se tiver chamando o Cancelamento de Venda de outro ponto que não seja pelas rotinas LOJA701 ou LOJA140
If nModulo == 5 .And. !(FunName() $ "LOJA701|LOJA140")
	FinishLoja()
EndIf

If !lRetorno
	nOpca := 0
EndIf

//Se é um cancelamento de integração e a variável estática (lIntDefPro) da integração está como .T., é necessário voltar para .F.
If lVendaInt .And. Lj140GtInD()
	Lj140StInD(.F.)
EndIf

LjGrvLog( SL1->L1_NUM, "Retorno da funcao lj140Exc", nOpca)

Return nOpca

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³lj140Grava³ Autor ³ Vendas Clientes       ³ Data ³ 02/01/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Atualiza‡„o de arquivos.                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³lj140Grava( )                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                     ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LJ140Grava(lJob	 , 	cDescMot, 	lGeraNCC, cNumNFDev	,;
					cSerieDev, 	cMotivo ,	cNum	, lNFCe		,;
					lLstPre, cProtoNfce)

Local lVendTef 	   	:= .F.							// Venda com TEF
Local lValido		:= .F.				            // se os dados estao validos	
Local lCancECF		:= .F.							// se foi cancelado na impressora fiscal
Local lDataBase		:= .F.							// se foi cancelado no banco de dados
Local lAchouSF2	   	:= .F.						  	// Variavel de retorno se encontrou o SF2 ou nao
Local lRet			:= .F.							// Variavel de Retorno
Local aChave										// Chave de busca
Local cSerNfCup    	:= ""							// Serie cupom
Local cNumNfCup    	:= ""							// Nf cupom
Local cNumNota     	:= SL1->L1_DOC					// Nota da venda
Local nTamDoc      	:= TamSx3("F2_DOC")[1]         	// Tamanho do campo F2_DOC
Local aCheques 	   	:= {}							// Informacoes do cheque
Local cSupervisor   := "" 							// Supervisor/msg mostrada no cancelamento
Local lUseSAT		:= .F.		//Usa SAT				//Usa SAT
Local lGerInte		:= SuperGetMV("MV_LJGRINT",.F.,.F.)	// Verifica se a integracao esta habilitada
Local lAmbOffLn 	:= SuperGetMv("MV_LJOFFLN", Nil, .F.)	//Identifica se o ambiente esta operando em offline
Local lBordero		:= .F.//Verifica se possui Bordero
Local lEntrega		:= Empty(SL1->L1_DOC) .And. !Empty(SL1->L1_DOCPED)	// Verifica se é item com entrega ou retira posterior 
Local lL1_DOCCCF 	:= SL1->(ColumnPos("L1_DOCCCF")) > 0
Local cPrefixo		:= "" //Prefixo do título-Pai
Local aChaveSL1		:= {} //Chave do orçamento atual
Local cL1_NUM		:= "" //Numero do Orcamento
Local cMvLjPref		:= SuperGetMV("MV_LJPREF")		//Regra para gravacao do SF2->F2_PREFIXO
Local nTamSx3E1P 	:= TamSX3("E1_PREFIXO")[1] 		//Tamanho do campo E!_PREFIXO definido no dicionário de ados SX3
Local lL1Tel 		:= SL1->(ColumnPos("L1_TEL")) > 0 //Variavel para verificar a existencia do campo L1_TEL
Local cMsgBorder	:= ""

Default lJob 		:= .F.							// Fala se é via Job ou nao
Default cDescMot	:= ""                                       
Default lGeraNCC	:= .F.
Default cNumNFDev	:= ""
Default cSerieDev	:= ""
Default cMotivo		:= ""
Default cNum		:= ""
Default lNFCe		:= .F.
Default lLstPre		:= .F.
Default cProtoNfce := ""

// Verifica se utiliza SAT
lUseSAT 	:= IIF(ExistFunc("LjUseSat"),LjUseSat(),.F.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Instacia Objeto para faze Offline. (Variavel statica)³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lAmbOffLn
	oProcOff := LJCProcessoOffLine():New("006")
Endif

If Type("LANULASF3")=="U"
	Private lAnulaSF3 := .F.
EndIf

If AllTrim(Upper(cMvLjPref)) <> "SF2->F2_SERIE"
	cPrefixo := &(cMvLjPref) //como o conteudo do parametro nao e padrao, ele e macro executado.
	cPrefixo := Substr(PAdr(AllTrim(cPrefixo),nTamSx3E1P),1,nTamSx3E1P)
Else
	cPrefixo:= LJPREFIXO()
EndIf

If ExistFunc("LJ7NumTit")
	aChave := { xFilial("SE1"), cPrefixo, LJ7NumTit() }
ElseIf lLstPre .Or. lEntrega
	aChave := { xFilial("SE1"), cPrefixo, Iif(!Empty(SL1->L1_DOC), SL1->L1_DOC, SL1->L1_DOCPED) }
Else
	aChave := { xFilial("SE1"), cPrefixo, SL1->L1_DOC }
EndIf

If lLstPre .Or. lEntrega
	aChaveSL1 := { xFilial("SE1"), Iif(!Empty(SL1->L1_SERIE), SL1->L1_SERIE, SL1->L1_SERPED), Iif(!Empty(SL1->L1_DOC), SL1->L1_DOC, SL1->L1_DOCPED), SL1->L1_CLIENTE, SL1->L1_LOJA }
Else
	aChaveSL1 := { xFilial("SE1"), SL1->L1_SERIE, SL1->L1_DOC, SL1->L1_CLIENTE, SL1->L1_LOJA }
EndIf

aSE1Found := Lj140Seek( "SE1", 1, aChave, "E1_FILORIG" )
If aSE1Found[1]
	While SE1->(!Eof()) .AND. aChave[1] == SE1->E1_FILIAL .AND. aChave[2] == SE1->E1_PREFIXO .AND. aChave[3] == SE1->E1_NUM
		If aSE1Found[2]
			aSE1Found[1] := SE1->E1_FILORIG == CFILANT
		EndIf
	
		If aSE1Found[1]
			If !Empty(SE1->E1_NUMBOR) .And. !Empty(SE1->E1_DATABOR)
				cMsgBorder += 	STR0180 + SE1->E1_PREFIXO 	+ " | " +; 		//"Prefixo: "
								STR0181 + SE1->E1_NUM		+ " | " +; 		//"Número: "
								STR0182 + SE1->E1_PARCELA + CHR(10)+Chr(13)	//"Parcela: "
				lBordero := .T.
			EndIf
		EndIf
		SE1->( DbSkip() )
	End
EndIf	

iRet := 0

If !lBordero// Caso tenha bordero, não podera excluir a Nf/Orc/Ped, logo a variavel lValido continua Falso
	lValido :=  Lj140Valida(lJob		, @lVendTef		, aChave	, @aCheques,;
							@cSerNfCup	, @cNumNfCup	, nTamDoc	, cNumNota,;
							@lAchouSF2, lLstPre		, lEntrega	, aChaveSL1)
Else
	If !Empty(cMsgBorder)
		cMsgBorder := STR0147 + " " + STR0148 + CHR(10)+Chr(13) + cMsgBorder //"Não é possível excluir a venda." ### "Existe Borderô para o(s) Título(s):"
		Conout(cMsgBorder)
		LjGrvLog(Nil,cMsgBorder)
		If !IsBlind()
			Aviso(STR0006, cMsgBorder, {"OK"}, 2) //"Atençäo" ### 
		EndIf
	EndIf
EndIf

If lValido .AND. !lNFCe .AND. !lUseSAT
	cSupervisor:= " |"+cNumNota
	lCancECF := Lj140CancCupom(lAchouSF2,cSupervisor)
EndIf
				
If lValido .AND. (lNFCe .OR. lCancECF .OR. lUseSAT)

	If lGerInte
		oIntCVenda := LJCAdapXMLEnvVenda():New()
		Lj140AddIn()
	EndIf

	//Realiza o cancelamento do SAT
	If !isBlind() .AND. IIF(SL1->(ColumnPos("L1_SERSAT")) > 0,!Empty(SL1->L1_SERSAT),.T.) .And. !Empty(SL1->L1_KEYNFCE)
		If ExistFunc("LJSatxCanc") .AND. (!lL1_DOCCCF .OR. Empty(SL1->L1_DOCCCF)) .AND. !LJSatxCanc(.F., @cNFisCanc)
			Return .F.
		ElseIf lL1_DOCCCF  .AND. !Empty(cNFisCanc) .AND. Empty(SL1->L1_DOCCCF)
			//Grava o numero do cupom de cancelamento
			SL1->(RecLock("SL1", .F.))
			SL1->L1_DOCCCF := cNFisCanc
			SL1->(MsUnLock())
		EndIf
	EndIf
	
	cL1_NUM := SL1->L1_NUM
	
	Begin Transaction
	
		lDataBase := Lj140CancDB(aCheques, 	lVendTef, 	aChave, 	@cSerNfCup,;
							   @cNumNfCup, 	nTamDoc, 	cNumNota, 	lAchouSF2,;
							   lJob		 , 	cDescMot, 	lGeraNCC, 	cNumNFDev, ;
							   cSerieDev , 	cMotivo, 	cNum	,   aChaveSL1,;
							   cProtoNfce,	lCancECF,	lValido	)

		If !lDataBase
			LjGrvLog( cL1_NUM , STR0193)//"Lj140CancDB - Falha ao cancelar o Orçamento"
		EndIf
	End Transaction
EndIf		                                 

lRet := lValido .AND. lDataBase .AND. (lNFCe .OR. lUseSAT .OR. lCancECF)

//Envia os dados de cancelamento para integracao
If lRet

	If lGerInte 
		Lj140Integ()
	EndIf 
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Faz integração offline³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lAmbOffLn
		Lj140EvInt()
	Endif
	
	//------------------------------------------------------------------
	// Verifica se a venda foi paga com Vale Presente e estorna o mesmo.
	//------------------------------------------------------------------
	LjGrvLog( SL1->L1_NUM, "lj140Exc | Antes de enviar para Lj140EstVP" , )
	Lj140EstVP( cNum )

    //Cancela o bonus de uma venda cancelada    
    If ExistFunc("LjxRaasInt") .And. LjxRaasInt() .And. SL1->L1_FIDCORE

        Lj7FidCanc(SL1->L1_FILIAL + SL1->L1_NUM, SL1->L1_ESTACAO, IIF(lL1Tel,AllTrim(SL1->L1_TEL),"")) 

        RecLock("SL1", .F.)
            SL1->L1_DESCONT := SL1->L1_DESCONT - SL1->L1_DESCFID
            SL1->L1_DESCFID := 0
            SL1->L1_FIDCORE := .F.
        SL1->( MsUnLock() )
    EndIf
EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ lj140Exc ³ Autor ³ Vendas Clientes       ³ Data ³ 04.04.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Programa de exclusao de Orcamentos                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ lj140ExcOrc(ExpC1)                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 - Filial utilizada para exclusao (reservas)          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LJ140ExcOrc(cFilRes, aChaveCHRe, cProtoNfce , lAtStEC, cMsgErro)

Local cFilL2    := SL2->( xFilial( "SL2" ) )
Local cFilE1    := SE1->( xFilial( "SE1" ) )
Local cFilL4    := SL4->( xFilial( "SL4" ) )
Local cFilE5	:= SE5->( xFilial( "SE5" ) )
Local aRetCrd   := {}                       	//Array  de retorno do cancelamento do contrato - integracao SIGACRD
Local lCrdxInt  := CrdxInt()                	//Controla se tem integracao com SIGACRD
Local cParcela  := "" 							//Define tipo da duplicata	
Local aDadosOri	:= {}							//Dados do orcamento original
Local nTamE1Parc:= TamSX3("E1_PARCELA")[1]		//Tamanho do campo
Local aClientes	:= {}
Local cMvLjPref := SuperGetMV("MV_LJPREF")
Local cPrefE1	:= ""							//elemento que sera utilizado como SE1->E1_PREFIXO, na busca do titulo
Local cNumE1	:= ""							//elemento que sera utilizado como SE1->E1_NUM, na busca do titulo
Local lIntGC	:= .F.
Local cCompFil  := "" 							//Verifica se a tabela SE1 e compartilhada por FILIAL. 
Local lLjChkNFS := ExistFunc("LjChkNFS") .And. LjChkNFS()
Local aPedidos	:= {}
Local nX		:= 0 							//Verifica se a tabela SE1 e compartilhada por FILIAL.
Local lECommerce  :=  (SuperGetMV("MV_LJECOMM",,.F.) .And. ExistFunc("LJ862ECAuto") .And. LJ862ECAuto())
Local lECCia      :=  !Empty(SL1->L1_ECPEDEC)
Local cNumReserva := ""                   //Codigo da Reserva no Orcamento    
Local cLogPath    :=  SuperGetMV("MV_LOGPATH",,"LOGS")     
Local lLiberOk	:= .T.
Local lResidOk	:= .T.
Local lFaturOk	:= .F.
Local lECCiaRes := lECCia .AND. SuperGetMv("MV_LJECOM0", , .F.)
Local aSE1Found := {}	//[1]-indica se achou o registro na SE1 [2]-indica se a Filial esta compartilhada
Local nRecSE5   := 0      // RECNO da SE5
Local lIntegDef := Lj140GtInD()
Local cPedRes		:= "" //Recebe o numero do pedido
Local lMvLjVfNfs 	:= SuperGetMv("MV_LJVFNFS",,.F.) //Verifica se a nota de simples faturamento esta ativa
Local nTamSx3E1P 	:= TamSX3("E1_PREFIXO")[1] //Tamanho do campo E!_PREFIXO definido no dicionário de ados SX3
Local cFilAntBkp 	:= ""
Local aAreaSM0		:= {}
Local lFoundSE3		:= .F. 						// Guarda se existe Comissão de Vendedores
Local aAreaSE3		:= {} 						//WorkAreaSE3

DEFAULT cFilRes 	:= cFilAnt
DEFAULT aChaveCHRe 	:= {}
DEFAULT cProtoNfce	:= ""
Default lAtStEC		:= .F.
Default cMsgErro	:= ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Verifica se o orcamento foi gerado pela integracao com Gestao de Concessionarias  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 
If (SuperGetMV("MV_VEICULO",,"N")) == "S" .AND. SL1->(ColumnPos("L1_ORIGEM")) > 0 .AND. SL1->L1_ORIGEM == "V" .and. !SL1->L1_VEICTIP $ "1/2"
	lIntGC  := .T.
EndIf

If SuperGetMV("MV_1DUP")=="1"
	cParcela := "1"
Else
	cParcela := "A"
EndIf

cParcela	:= PadR( cParcela , nTamE1Parc)		// Ajusta de acordo com o tamanho do E1_PARCELA
If !Empty( cFilL2 )
	cFilL2 := cFilRes
EndIf
If !Empty( cFilL4 )
	cFilL4 := cFilRes
EndIf

If lECCia .AND. !Empty(SL1->L1_DOCPED) .and. !Empty(SL1->L1_SERPED)
	If !Lj140ExR(cLogPath, SL1->L1_DOCPED , SL1->L1_SERPED, @cMsgErro)
		Return .F.
	EndIf  
EndIf

Begin Transaction    

	If lLjChkNFS  .And. !Empty(SL1->L1_DOCPED) .and. !Empty(SL1->L1_SERPED)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Efetua a exclusão da SD2 e SF2³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	  	aPedidos := {}
		DbSelectArea("SD2")
		SD2->(DbSetOrder(3))
		If SD2->(DbSeek(xFilial("SD2")+SL1->L1_DOCPED+SL1->L1_SERPED))

			While !SD2->(Eof()) .AND.	(xFilial("SD2")	== SD2->D2_FILIAL) 	.AND. ;
								(SD2->D2_DOC 		== SL1->L1_DOCPED 	.AND. ;
								SD2->D2_SERIE 		== SL1->L1_SERPED)
				
	        	nPos := ascan( aPedidos, SD2->D2_PEDIDO )
	        	If nPos == 0
	        		aadd(aPedidos, SD2->D2_PEDIDO )
	        	EndIf
	        	SD2->( dbSkip() )
	        End
		  	If Lj140CnSD2(SL1->L1_DOCPED,SL1->L1_SERPED,.T.)
				Lj140CnSF2(SL1->L1_DOCPED,SL1->L1_SERPED)
			EndIf
		EndIf

		//Cancelamento da SF2/SD2 em outra filial devido a funcionalidade de simples faturamento estar ativa
		If lMvLjVfNfs .AND. Len(aNfSFat) > 0
			If Lj140CnSD2(aNfSFat[1][2],aNfSFat[1][3],.T.,,aNfSFat[1][1])
				Lj140CnSF2(aNfSFat[1][2],aNfSFat[1][3],,,,,,,aNfSFat[1][1])
			EndIf			
		EndIf		
		
		If lECCia 
			aadd(aPedidos, SL1->L1_PEDRES )
		EndIf
        
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Apaga Pedido de vendas quando for "Entrega"    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
		If Len( aPedidos ) > 0
			For nX := 1 to len(aPedidos)
				DbSelectArea("SC5")
				SC5->(DbSetOrder(1)) //C5_FILIAL+C5_NUM 
			   	If SC5->(DbSeek(xFilial("SC5")+ aPedidos[nX] ))
		    		DbSelectArea("SC6")
					SC6->(DbSetOrder(1)) //C6_FILIAL+C6_NUM
					If SC6->(DbSeek(xFilial("SC6")+SC5->(C5_NUM)))
						While !SC6->(Eof()) .AND. SC6->C6_NUM == SC5->(C5_NUM)
				    		RecLock('SC6',.F.)  
							If lECCia .AND. Empty(SC6->C6_RESERVA)
								MaAvalSC6("SC6",2,"SC5",.T.,.F.,@lLiberOk,@lResidOk,@lFaturOk, .f.)	
							EndIf
							
							SC6->(DbDelete())
							SC6->(MsUnLock())
							SC6->(dbSkip())
						End
					EndIf
					
					//Exclui liberação
					DbSelectArea("SC9")
					SC9->(DbSetOrder(1)) //C9_FILIAL+C9_Pedido
					If SC9->(DbSeek(xFilial("SC9")+ SC5->(C5_NUM) ))
						While !SC9->(Eof()) .AND. SC9->C9_PEDIDO == SC5->(C5_NUM)
				    		RecLock('SC9',.F.)  
							SC9->(DbDelete())
							SC9->(MsUnLock())
							SC9->(dbSkip())
						End
					EndIf	
					
					RecLock("SC5", .F.)
						SC5->C5_STATUS  := "90"	//Cancelado
						SC5->C5_VOLTAPS := ""
					SC5->( MsUnLock() )
					
					//Mensagem de rastreio de pedido
					If FwHasEai("MATA410B", .T., , .T.)
						FwIntegDef("MATA410B")
					EndIf

					If lECCia
						If lAtStEC
							RecLock("SL1", .F.)
								SL1->L1_ECSTATU := SC5->C5_STATUS
								SL1->L1_ECRASTR := SC5->C5_RASTR
							SL1->( MsUnLock() )
						EndIf
					EndIf
					
					RecLock("SC5", .F.)
						SC5->( DbDelete() )   
					SC5->( MsUnLock() )
			  	EndIf
			Next nX
		EndIf 
		
		DbSelectArea( "SL2" )
		SL2->(DbSetOrder(1)) //L2_FILIAL+L2_NUM+L2_ITEM+L2_PRODUTO
		If SL2->(DbSeek( cFilL2+SL1->L1_NUM ))
			While !SL2->(Eof()) .AND. cFilL2==SL2->L2_FILIAL .AND. SL2->L2_NUM == SL1->L1_NUM
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Excluir a reserva de Estoque                                ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !( Empty(SL2->L2_RESERVA) )

					cNumReserva := SL2->L2_RESERVA

					dbSelectArea("SC0")
					SC0->(dbSetOrder(1))
					SC0->(DbSeek(xFilial("SC0")+cNumReserva))  // Atenção caso altere este trecho, faça a manutenção tbm na função: A430DelMvc
					While ( !SC0->(Eof()) ) .And. (SC0->(C0_FILIAL+C0_NUM) == xFilial("SC0")+cNumReserva)
						SC0->(RecLock("SC0",.F.))  //Ajuste para estornar o B2_RESERVA
						//Item Liberado tem que voltar o SC0->C0_QTDPED para a quantidade do item
						If lECCiaRes .AND. SC0->C0_TIPO  = "LB" .AND. SC0->C0_QTDPED = 0
						
							LjGrvLog( SL1->L1_NUM, "Voltando a quantidade em Pedido")
							SC0->C0_QTDPED := SL2->L2_QUANT
						EndIf
						SC0->C0_QUANT  += SC0->C0_QTDPED
						SC0->C0_QTDPED -= SC0->C0_QUANT
						SC0->(MsUnlock())
					
						a430Reserv({3,C0_TIPO,C0_DOCRES,C0_SOLICIT,C0_FILRES},;
							cNumReserva,;
							SC0->C0_PRODUTO,;
							SC0->C0_LOCAL,;
							SC0->C0_QUANT,;
							{	SC0->C0_NUMLOTE,;
							SC0->C0_LOTECTL,;
							SC0->C0_LOCALIZ,;
							SC0->C0_NUMSERI})
						SC0->(MsUnLock())
						SC0->(dbSkip())
					EndDo
					
					DbSelectArea( "SL2" )
				EndIf
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Nao excluo o orcamento quando se tratar de uma venda com reserva, apenas limpo os campos da reserva ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Reclock( "SL2" ,.F.)
				Replace SL2->L2_FILRES		with	SPACE(TamSx3("L2_FILRES")[1])
				Replace SL2->L2_ORCRES		with	SPACE(TamSx3("L2_ORCRES")[1]) 
				Replace SL2->L2_VENDIDO		with	SPACE(TamSx3("L2_VENDIDO")[1]) 
				Replace SL2->L2_SERIE		with	SPACE(TamSx3("L2_SERIE")[1]) 
				Replace SL2->L2_PDV			with	SPACE(TamSx3("L2_PDV")[1]) 
				Replace SL2->L2_SITUA		with	SPACE(TamSx3("L2_SITUA")[1]) 
				Replace SL2->L2_RESERVA		with	SPACE(TamSx3("L2_RESERVA")[1]) 
				Replace SL2->L2_NUMORIG		with	SPACE(TamSx3("L2_NUMORIG")[1]) 
				Replace SL2->L2_SITTRIB		with	SPACE(TamSx3("L2_SITTRIB")[1]) 
				Replace SL2->L2_VDMOST		with	SPACE(TamSx3("L2_VDMOST")[1]) 
				Replace SL2->L2_SOLCOM		with	SPACE(TamSx3("L2_SOLCOM")[1]) 

				SL2->(MsUnlock())
				SL2->(dbSkip())
			End
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Recupera os dados do tiulo a partir do orcamento original³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aDadosOri := Lj140OrcOrig()
		
		If Len(aDadosOri) > 0
			
			cCompFil := FWModeAccess("SE1", 3) //Verifica se a filial da SE1 e compartilhada. 
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Filial do titulo³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Alltrim(cCompFil) <> "C" 
				cFilE1 := aDadosOri[1]
			EndIf
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Prefixo do Titulo - quando o campo SL1->L1_SERPED for diferente do campo SE1->E1_PREFIXO,				  |
			³devemos montar a chave de busca com o parametro MV_LJPREF. Quando o conteudo do parametro nao for padrao,|
			|ele devera ser macro executado assim como ocorre na funcao LOJXFUNC (responsavel pela gravacao).		  |
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			*/
			//Compoe o Prefixo do titulo
			If AllTrim(Upper(cMvLjPref)) <> "SF2->F2_SERIE"
				cPrefE1 := &(cMvLjPref) //como o conteudo do parametro nao e padrao, ele e macro executado.
				cPrefE1 := Substr(PAdr(AllTrim(cPrefE1),nTamSx3E1P),1,nTamSx3E1P)
			Else
				cPrefE1 := aDadosOri[4]	//SL1->L1_SERPED
			EndIf

			//Compoe o Numero do titulo
			If ExistFunc("LJ7NumTit")
				cNumE1 := LJ7NumTit()
			Else
				cNumE1  := aDadosOri[5] //SL1->L1_DOCPED
			EndIf
			
			aAdd( aClientes , {aDadosOri[2] , aDadosOri[3]} )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Busca se houve pagamentos do tipo que o cliente sao adms  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SL4")
			SL4->( DbSetOrder(1) )	//L4_FILIAL+L4_NUM+L4_ORIGEM
			If SL4->( DbSeek(cFilL4 + SL1->L1_NUM) )
				While SL4->(!Eof()) .AND. cFilL4 == SL4->L4_FILIAL .AND. SL4->L4_NUM == SL1->L1_NUM
					If AllTrim(SL4->L4_FORMA) $ "CC|VA|CO|CD|FI"
						If AScan(aClientes,{|x| x[1] == Left(L4_ADMINIS,3)}) == 0
							aAdd( aClientes , {Left(L4_ADMINIS,3) , "01"} )
						EndIf	
					EndIf				
					SL4->( DbSkip() )
				End
			EndIf
			                                                             
			//---
			//Apaga os cheques quando utilizada reserva
			//---
			aSE1Found := LJ140Seek( "SE1", 1, {cFilE1, cPrefE1, cNumE1}, "E1_FILORIG" )

			If aSE1Found[1] 
				While SE1->(!Eof()) .AND. SE1->E1_FILIAL == cFilE1 .AND. SE1->E1_PREFIXO == cPrefE1 .AND. SE1->E1_NUM == cNumE1
					If aSE1Found[2]
						aSE1Found[1] := SE1->E1_FILORIG == CFILANT
					EndIf

					If aSE1Found[1]
						If AScan(aClientes,{|x| AllTrim(x[1]) == AllTrim(SE1->E1_CLIENTE) .AND. AllTrim(x[2]) == AllTrim(SE1->E1_LOJA)}) > 0

							If Len(aChaveCHRe) > 0
								Lj140CHDelReserva( aChaveCHRe )
							EndIf
						EndIf
					EndIf

					SE1->( DbSkip() )
				End			
			EndIf

			// ---
			// Apaga os titulos do SE1 relacionados ao orcamento excluido
			// ---
			aSE1Found := LJ140Seek( "SE1", 1, {cFilE1, cPrefE1, cNumE1}, "E1_FILORIG" )

			If aSE1Found[1] 
				While SE1->(!Eof()) .AND. SE1->E1_FILIAL == cFilE1 .AND. SE1->E1_PREFIXO == cPrefE1 .AND. SE1->E1_NUM == cNumE1
					If aSE1Found[2]
						aSE1Found[1] := SE1->E1_FILORIG == CFILANT
					EndIf

					If aSE1Found[1]
						If AScan(aClientes,{|x| AllTrim(x[1]) == AllTrim(SE1->E1_CLIENTE) .AND. AllTrim(x[2]) == AllTrim(SE1->E1_LOJA)}) > 0
						
                            If SE1->E1_SALDO <> SE1->E1_VALOR 
                                
                                DbSelectArea("SE5")
                                SE5->(dbSetOrder(7))//E5_FILIAL, E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_CLIFOR, E5_LOJA, E5_SEQ
                                If SE5->( dbSeek(cFilE5 + cPrefE1 + cNumE1) )
                    
                                    While SE5->(!Eof()) .AND. SE5->E5_FILIAL == cFilE5 .AND. SE5->E5_PREFIXO == cPrefE1 .AND.;
                                          SE5->E5_NUMERO  == cNumE1 .AND. Empty(SE5->E5_DTCANBX) 
                    
                                        // Verifica cliente e loja da movimentacao
                                        If SE5->E5_CLIFOR + SE5->E5_LOJA <> aDadosOri[2] + aDadosOri[3]
                                            SE5->(DbSkip())
                                            Loop
                                        EndIf

                                        //Alteracao do registro de entrada na SE5
                                        SE5->(RecLock("SE5", .F.))
                                        SE5->E5_DTCANBX := dDatabase
                                        SE5->(MsUnlock())   
                    
                                        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                        //³ Apaga os titulos do SE1 relacionados ao orcamento excluido ³
                                        //³ e faz a gravacao do estorno do pagamento na SE5  e FKs     ³
                                        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                        LjGrvLog(SE1->E1_NUM, " Enviando para geracao de estorno de movimentacao bancaria pela Lj140GEsPg." )
                                        nRecSE5 := SE5->(Recno())
                                        Lj140GEsPg(nRecSE5)

                                        SE5->(DbSkip())
                                    EndDo
                                EndIf
                                
                            Else
                                //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                //³Apaga a movimentacao bancaria relacionados ao orcamento excluido³
                                //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                LjGrvLog(SE1->E1_NUM, " Deleta titulo da venda SE1.",  )
                                Reclock("SE1",.F.)
                                SE1->( dbDelete() )
                                SE1->( MsUnlock() )
                            EndIf

						EndIf
					EndIf

					SE1->( DbSkip() )
				End			
			EndIf
			

			cCompFil := FWModeAccess("SE5", 3) //Verifica se a filial da SE1 e compartilhada. 
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Filial da Movimentacao³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Alltrim(cCompFil) <> "C" 
				cFilE5 := aDadosOri[1]
			EndIf
            
		EndIf

		//---
		//Limpar os campos do orçamento  para possibilitar sua reutilização se for necessário.
		//---
		Reclock( "SL1" ,.F.)

		Replace SL1->L1_PDV		with SPACE(TamSx3("L1_PDV")[1])
		Replace SL1->L1_EMISNF	with CTOD("")
		Replace SL1->L1_TIPO	with SPACE(TamSx3("L1_TIPO")[1])
		Replace SL1->L1_OPERADO	with SPACE(TamSx3("L1_OPERADO")[1])
		Replace SL1->L1_DOCPED	with SPACE(TamSx3("L1_DOCPED")[1])
		Replace SL1->L1_SERPED	with SPACE(TamSx3("L1_SERPED")[1])
		Replace SL1->L1_DOC		with SPACE(TamSx3("L1_DOC")[1])
		Replace SL1->L1_SERIE	with SPACE(TamSx3("L1_SERIE")[1])
		Replace SL1->L1_RESERVA	with SPACE(TamSx3("L1_RESERVA")[1])
		Replace SL1->L1_IMPRIME	with '1N'
		Replace SL1->L1_STATUS	with SPACE(TamSx3("L1_STATUS")[1])
		Replace SL1->L1_OPERACA	with SPACE(TamSx3("L1_OPERACA")[1])
		Replace SL1->L1_SITUA	with SPACE(TamSx3("L1_SITUA")[1])
		Replace SL1->L1_NUMORIG	with SPACE(TamSx3("L1_NUMORIG")[1])
		Replace SL1->L1_TIPODES	with SPACE(TamSx3("L1_TIPODES")[1])

		SL1->( MsUnlock() )

	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Apaga Pedido de vendas quando for "Entrega"    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
        If lECCia .Or. lIntegDef .Or. ( Empty( SL1->L1_DOCPED ) .AND. !Empty( SL1->L1_FILRES ) .AND. Empty(SL1->L1_DOC) )
        
			DbSelectArea("SC5")
			SC5->(DbSetOrder(1)) //C5_FILIAL+C5_NUM 

			//Quando a funcionalidade de simples faturamento esta ativa, deve-se pegar sempre o numero do pedido no campos L1_PEDPRS,
			//isso porque o pedido que esta no campo L1_PEDRES sempre nascera faturado pois eh o pedido de simples faturamento e o
			//pedido que esta no campo L1_PEDPRS eh o pedido de simples remessa que sera faturado quando for enviar a mercadoria
			//para o cliente.
			If lMvLjVfNfs .AND. !Empty(SL1->L1_PEDPRS)
				cPedRes := SL1->L1_PEDPRS
			Else
				cPedRes := SL1->L1_PEDRES
			EndIf

		   	If SC5->(DbSeek(xFilial("SC5")+ cPedRes))

                RecLock("SC5", .F.)
					SC5->C5_STATUS  := "90"	//Cancelado
					SC5->C5_VOLTAPS := ""
				SC5->( MsUnLock() )

				//Mensagem de rastreio de pedido
				If FwHasEai("MATA410B", .T., , .T.)
					FwIntegDef("MATA410B")
				EndIf

	    		DbSelectArea("SC6")
				SC6->(DbSetOrder(1)) //C6_FILIAL+C6_NUM
				If SC6->(DbSeek(xFilial("SC6")+SC5->(C5_NUM)))
					While !SC6->(Eof()) .AND. SC6->C6_NUM == SC5->(C5_NUM)
			    		RecLock('SC6',.F.)  
						If lECCia .AND. Empty(SC6->C6_RESERVA)
							MaAvalSC6("SC6",2,"SC5",.T.,.F.,@lLiberOk,@lResidOk,@lFaturOk, .f.)	
						EndIf

						SC6->(DbDelete())
						SC6->(MsUnLock())
						SC6->(dbSkip())
					End
				EndIf
				
				//Exclui liberação
				DbSelectArea("SC9")
				SC9->(DbSetOrder(1)) //C9_FILIAL+C9_Pedido
				If SC9->(DbSeek(xFilial("SC9")+ cPedRes))
					While !SC9->(Eof()) .AND. SC9->C9_PEDIDO == SC5->(C5_NUM)
			    		RecLock('SC9',.F.)  
						SC9->(DbDelete())
						SC9->(MsUnLock())
						SC9->(dbSkip())
					End

					If lMvLjVfNfs .AND. SC9->(DbSeek(xFilial("SC9")+ SL1->L1_PEDRES))
						While !SC9->(Eof()) .AND. SC9->C9_PEDIDO == SL1->L1_PEDRES
							RecLock('SC9',.F.)  
							SC9->(DbDelete())
							SC9->(MsUnLock())
							SC9->(dbSkip())
						End
					EndIf

				EndIf									
				
				If lAtStEC
					RecLock("SL1", .F.)
						SL1->L1_ECSTATU := SC5->C5_STATUS
						SL1->L1_ECRASTR := SC5->C5_RASTR
					SL1->( MsUnLock() )
				EndIf
				
				If !lECCia
		  			RecLock("SL1", .F.)
		  				SL1->L1_PEDRES := Space( TamSx3("L1_PEDRES")[1] )
		  			SL1->( MsUnlock() )
				EndIf
				
				RecLock("SC5", .F.)
					SC5->( DbDelete() )
				SC5->( MsUnLock() )
			
			Else
				If lMvLjVfNfs
					//Exclui liberação
					DbSelectArea("SC9")
					SC9->(DbSetOrder(1)) //C9_FILIAL+C9_Pedido
					If SC9->(DbSeek(cFilRes + cPedSFat))
						While !SC9->(Eof()) .AND. SC9->C9_FILIAL + SC9->C9_PEDIDO == cFilRes + cPedSFat
							RecLock('SC9',.F.)  
							SC9->(DbDelete())
							SC9->(MsUnLock())
							SC9->(dbSkip())
						End
					EndIf
					cPedSFat := ""
				EndIf
		  	EndIf
		EndIf
	
		DbSelectArea( "SL2" )
		SL2->(DbSetOrder(1)) //L2_FILIAL+L2_NUM+L2_ITEM+L2_PRODUTO
		If SL2->(DbSeek( cFilL2+SL1->L1_NUM ))
			// Altera a Filial atual para Filial que foi reservado o produto
			// Guarda na variavel a cFilAntBkp a Filial atual
			// Guarda a area do SM0
			If cFilAnt != cFilRes
				cFilAntBkp 	:= cFilAnt
				cFilAnt 	:= cFilRes
				aAreaSM0	:= SM0->(GetArea())	
			Endif	

			While !SL2->(Eof()) .AND. cFilL2==SL2->L2_FILIAL .AND. SL2->L2_NUM == SL1->L1_NUM
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Excluir a reserva de Estoque quando e-commerce.             ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If  lECommerce  .Or. !( Empty(SL2->L2_RESERVA) )
				
					cNumReserva := SL2->L2_RESERVA
				
					dbSelectArea("SC0")
					SC0->(dbSetOrder(1))
					SC0->(DbSeek(xFilial("SC0")+cNumReserva))  // Atenção caso altere este trecho, faça a manutenção tbm na função: A430DelMvc
					While ( !SC0->(Eof()) ) .And. (SC0->(C0_FILIAL+C0_NUM) == xFilial("SC0")+cNumReserva)
						SC0->(RecLock("SC0",.F.))  //Ajuste para estornar o B2_RESERVA
						
						If lECCiaRes .AND. SC0->C0_TIPO  = "LB" .AND. SC0->C0_QTDPED == 0
							LjGrvLog( SL1->L1_NUM, "Voltando a quantidade em Pedido")
							SC0->C0_QTDPED := SL2->L2_QUANT
						EndIf						
						
						SC0->C0_QUANT  += SC0->C0_QTDPED
						SC0->C0_QTDPED -= SC0->C0_QUANT
						SC0->( MsUnlock() )
					
						a430Reserv(	{3,C0_TIPO,C0_DOCRES,C0_SOLICIT,C0_FILRES},;
									cNumReserva		,;
									SC0->C0_PRODUTO	,;
									SC0->C0_LOCAL	,;
									SC0->C0_QUANT	,;
									{SC0->C0_NUMLOTE, SC0->C0_LOTECTL, SC0->C0_LOCALIZ, SC0->C0_NUMSERI};
								   )
						SC0->( MsUnLock() )
						SC0->( dbSkip() )
					EndDo
					
					DbSelectArea( "SL2" )
				EndIf
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Excluo o orcamento quando se tratar de uma venda com reserva³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				IF Empty(SL1->L1_DOCPED) .Or. lIntGC .Or. lECommerce  .Or. lECCia .Or. lIntegDef
                 	Reclock( "SL2" ,.F.)
					SL2->(dbDelete())
					SL2->(MsUnlock())
				Else
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Nao excluo o orcamento quando se tratar de uma venda com reserva, apenas limpo os campos da reserva ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					Reclock( "SL2" ,.F.)
					Replace SL2->L2_FILRES		with	SPACE(TamSx3("L2_FILRES")[1])
					Replace SL2->L2_ORCRES		with	SPACE(TamSx3("L2_ORCRES")[1])
					Replace SL2->L2_LOJARES		with	SPACE(TamSx3("L2_LOJARES")[1])					
					SL2->(MsUnlock())
				EndIf
				SL2->(dbSkip())
			End
			// Se a Variavel cFilAntBkp foi preeenchida,  cFilAnt recebe cFilAntBkp
			If !Empty(cFilAntBkp)
				cFilAnt := cFilAntBkp
				RestArea(aAreaSM0)
			Endif				

		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Efetua a exclusão da SD2 e SF2³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		// Aqui é passado o parâmetro SL1->L1_FILIAL pois, na exclusão procurava pela Filial corrente, onde foi gerado o Orçamento Pai.
		// Nas Lj140CnSD2 e Lj140CnSF2, já existia o tratamento para este parâmetro.
	  	If Empty(SL1->L1_PEDRES) .And. !Empty(SL1->L1_DOC)
		  	If Lj140CnSD2(SL1->L1_DOC,SL1->L1_SERIE,.F.,,SL1->L1_FILIAL)			
				Lj140CnSF2(SL1->L1_DOC,SL1->L1_SERIE,,,,,, cProtoNfce,SL1->L1_FILIAL)				
			EndIf
		EndIf		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Recupera os dados do tiulo a partir do orcamento original³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aDadosOri := Lj140OrcOrig()
		
		If Len(aDadosOri) > 0
			
			cCompFil := FWModeAccess("SE1", 3) //Verifica se a filial da SE1 e compartilhada. 
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Filial do titulo³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Alltrim(cCompFil) <> "C" 
				cFilE1 := aDadosOri[1]
			EndIf
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Prefixo do Titulo - quando o campo SL1->L1_SERPED for diferente do campo SE1->E1_PREFIXO,				  |
			³devemos montar a chave de busca com o parametro MV_LJPREF. Quando o conteudo do parametro nao for padrao,|
			|ele devera ser macro executado assim como ocorre na funcao LOJXFUNC (responsavel pela gravacao).		  |
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			*/
			//Compoe o Prefixo do titulo
			If AllTrim(Upper(cMvLjPref)) <> "SF2->F2_SERIE"
				cPrefE1 := &(cMvLjPref) //como o conteudo do parametro nao e padrao, ele e macro executado.
				cPrefE1 := Substr(PAdr(AllTrim(cPrefE1),nTamSx3E1P),1,nTamSx3E1P)
			Else
				cPrefE1 := aDadosOri[4]	//SL1->L1_SERPED
			EndIf

			//Compoe o Numero do titulo
			If ExistFunc("LJ7NumTit")
				cNumE1 := LJ7NumTit()
			Else
				cNumE1  := aDadosOri[5] //SL1->L1_DOCPED
			EndIf
			
			aAdd( aClientes , {aDadosOri[2] , aDadosOri[3]} )
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Busca se houve pagamentos do tipo que o cliente sao adms  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SL4")
			SL4->( DbSetOrder(1) )
			If SL4->( DbSeek(cFilL4 + SL1->L1_NUM) )
				While SL4->(!EoF()) .AND. cFilL4 == SL4->L4_FILIAL .AND. SL4->L4_NUM == SL1->L1_NUM
					If AllTrim(SL4->L4_FORMA) $ "CC|VA|CO|CD|FI"
						If AScan(aClientes,{|x| x[1] == Left(L4_ADMINIS,3)}) == 0
							aAdd( aClientes , {Left(L4_ADMINIS,3) , "01"} )
						EndIf	
					EndIf				
					SL4->( DbSkip() )
				End
			EndIf
			                                                             
			//---
			//Apaga os cheques quando utilizada reserva
			//---
			aSE1Found := LJ140Seek( "SE1", 1, {cFilE1, cPrefE1, cNumE1}, "E1_FILORIG" )

			If aSE1Found[1] 
				While SE1->(!Eof()) .AND. SE1->E1_FILIAL == cFilE1 .AND. SE1->E1_PREFIXO == cPrefE1 .AND. SE1->E1_NUM == cNumE1
					If aSE1Found[2]
						aSE1Found[1] := SE1->E1_FILORIG == CFILANT
					EndIf

					If aSE1Found[1]
						If AScan(aClientes,{|x| AllTrim(x[1]) == AllTrim(SE1->E1_CLIENTE) .AND. AllTrim(x[2]) == AllTrim(SE1->E1_LOJA)}) > 0

							// Apaga os cheques quando utilizada reserva
							If Len(aChaveCHRe) > 0
								Lj140CHDelReserva( aChaveCHRe )
							EndIf
						EndIf
					EndIf

					SE1->( DbSkip() )
				End			
			EndIf

			//Verifica se a filial da SE5 e compartilhada
			cCompFil := FWModeAccess("SE5", 3)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Filial da Movimentacao³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Alltrim(cCompFil) <> "C" 
				cFilE5 := aDadosOri[1]
			EndIf
			
            aSE1Found := aSE1Found := LJ140Seek( "SE1", 1, {cFilE1, cPrefE1, cNumE1}, "E1_FILORIG" )
            
            If aSE1Found[1]
                
                If SE1->E1_SALDO <> SE1->E1_VALOR
                    
                    DbSelectArea("SE5")
                    DbSetOrder(7)//E5_FILIAL, E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_CLIFOR, E5_LOJA, E5_SEQ
                    If DbSeek(cFilE5 + cPrefE1 + cNumE1)
        
                        While !Eof() .AND. SE5->E5_FILIAL == cFilE5 .AND. SE5->E5_PREFIXO == cPrefE1 .AND.;
                              SE5->E5_NUMERO  == cNumE1 .AND. Empty(SE5->E5_DTCANBX) 
        
                            // Verifica cliente e loja da movimentacao
                            If SE5->E5_CLIFOR + SE5->E5_LOJA <> aDadosOri[2] + aDadosOri[3]
                                SE5->(DbSkip())
                                Loop
                            EndIf
                           
                            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                            //³ Altero o registro de entrada SE5 ³
                            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                            SE5->(RecLock("SE5", .F.))
                            SE5->E5_DTCANBX := dDatabase
                            SE5->(MsUnlock())   
                            
                            cRecSE5 := SE5->(Recno())
                            
                            //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                            //³ Apaga os titulos do SE1 relacionados ao orcamento excluido ³
                            //³ e faz a gravacao do estorno do pagamento na SE5  e FKs     ³
                            //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                            LjGrvLog(SE1->E1_NUM, " Enviado para geracao de estorno de movimentacao bancaria pela Lj140GEsPg. ", )
                            Lj140GEsPg(cRecSE5)
                            
                            SE5->(DbSkip())
                        EndDo
                     
                    EndIf
                Else
                    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                    //³Apaga a movimentacao bancaria relacionados ao orcamento excluido³
                    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                    LjGrvLog(SE1->E1_NUM, " Deleta titulo da venda SE1.",  )
					// Verifica se existe Comissão de Vendedores
					// Se existir comissão para o Vendedor o SE1 será apagado em outro momento 
					DbSelectArea( "SE3" )					
					aAreaSE3 := SE3->( GetArea() )					
					SE3->(dbSetOrder(1)) //E3_FILIAL+E3_PREFIXO+E3_NUM
					lFoundSE3 := SE3->(DbSeek( cFilE1 + SE1->E1_PREFIXO + SE1->E1_NUM ))
					If !lFoundSE3
						Reclock("SE1",.F.)
						SE1->( dbDelete() )
						SE1->( MsUnlock() )                    
					EndIf	
					RestArea(aAreaSE3)

                EndIf
            EndIf
			
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//|     Se usar os modulos de gestao de concessionarias chama a funcao que grava os relacionamentos.        |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SuperGetMv("MV_VEICULO") == "S"
			If !Empty(SL1->L1_VEICTIP) .AND. !Empty(SL1->L1_VEIPESQ)
				FG_DEVLOJA( SL1->L1_VEICTIP, SL1->L1_VEIPESQ, "", "", .T. )
			EndIf
		EndIf
		
		If lCrdxInt .AND. SL1->(ColumnPos("L1_CONTRA")) > 0
			If !Empty(SL1->L1_CONTRA)
				aRetCrd      := aClone(CrdxVenda( "3"  ,{"",""}  ,SL1->L1_CONTRA  ,.F.  ,;
				NIL  ,NIL ))
			EndIf
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Nao excluo o orcamento quando se trata de uma venda com reserva                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        If Empty(SL1->L1_DOCPED) .Or. lIntGC .Or. lIntegDef
			DbSelectArea( "SL4" )
			SL4->(dbSetOrder(1)) //L4_FILIAL+L4_NUM+L4_ORIGEM
			If DbSeek( cFilL4+SL1->L1_NUM )
				While !Eof() .AND. cFilL4==L4_FILIAL .AND. L4_NUM == SL1->L1_NUM
					Reclock("SL4",.F.)
					SL4->( dbDelete() )
					SL4->( MsUnlock() )
					SL4->( dbSkip() )
				End
			EndIf
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Nao excluo o orcamento quando se trata de uma venda com reserva                           ³
		//³ Apenas retorno seus campos ao conteudo original para permitir a reutilizacao do orcamento ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea( "SL1" )
        If Empty(SL1->L1_DOCPED) .Or. lIntGC .Or. lECCia .Or. lIntegDef

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ??
			//?Verifica se existe SC gerada pelo orcamento. se tiver cancela		          ?
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ??   
			If (AllTrim(Str(SuperGetMv("MV_LJGERSC",,1))) $ "2|3")
				If  ExistFunc("LA590CncSC")
    				LA590CncSC(SL1->L1_NUM,SL1->L1_FILIAL)
    			Endif	
			Endif

			Reclock( "SL1" ,.F.)
			Replace SL1->L1_NUMORC With Space(TamSx3("L1_NUMORC")[1])
			Replace SL1->L1_RESERVA With Space(TamSx3("L1_RESERVA")[1])
			SL1->( dbDelete() )
			SL1->( MsUnlock() )
			If lExcAuto
				//"Orcamento excluido com sucesso."
				Conout(STR0117)
			EndIf
		ElseIf FunName() <> "STBORCCANCEL"
			Reclock( "SL1" ,.F.)
			Replace SL1->L1_PDV		with SPACE(TamSx3("L1_PDV")[1])
			Replace SL1->L1_EMISNF	with CTOD("")
			Replace SL1->L1_TIPO	with SPACE(TamSx3("L1_TIPO")[1])
			Replace SL1->L1_OPERADO	with SPACE(TamSx3("L1_OPERADO")[1])
			Replace SL1->L1_DOCPED	with SPACE(TamSx3("L1_DOCPED")[1])
			Replace SL1->L1_SERPED	with SPACE(TamSx3("L1_SERPED")[1])
			MsUnlock()
		EndIf

	EndIf
End Transaction 

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inclusao de chamada de Ponto de Entrada - Template.                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If ExistTemplate("LJ140FIM") 
     ExecTemplate("LJ140FIM",.F.,.F.) 
EndIf
     
If ExistBlock("LJ140FIM")   
     ExecBlock("LJ140FIM",.F.,.F.) 
EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³lj140chkresºAutor ³ Vendas Clientes    º Data ³  09/04/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³No cancelamento da venda verifica se ha reservas em aberto  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP6                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function lj140chkres(lVendido, aChaveCHRe)
Local nX                                                                               	// Aux do For
Local aReservas 	:= {}                                                              	// Array com dados da Reserva 
Local nPosProduto 	:= aScan(aHeader,{|x| Alltrim(Upper(x[2]))=="L2_PRODUTO"})			// Posicao de cabecalho
Local nPosDescPro 	:= aScan(aHeader,{|x| Alltrim(Upper(x[2]))=="L2_DESCRI"})			// Posicao de cabecalho
Local nPosLocal  	:= aScan(aHeader,{|x| Alltrim(Upper(x[2]))=="L2_LOCAL"})			// Posicao de cabecalho
Local nPosReserva  	:= aScan(aHeader,{|x| Alltrim(Upper(x[2]))=="L2_RESERVA"})			// Posicao de cabecalho		
Local nPosLojaRes  	:= aScan(aHeader,{|x| Alltrim(Upper(x[2]))=="L2_LOJARES"})			// Posicao de cabecalho
Local nPosQtdeDev  	:= aScan(aHeader,{|x| Alltrim(Upper(x[2]))=="L2_QUANT"})			// Posicao de cabecalho
Local cLojaLocal	:= ""																// Loja Local
Local cLojaReserva	:= ""																// Loja Reserva
Local lRet	 		:= .T.																// Retorno da funcao
Local cTexto 		:= If(lVendido,STR0032,STR0033) 									// "do orçamento"###"da venda"
Local nRegs         := Len(aCols)														// Qunantidade de registros
Local cOrcPai       := ""                                                        		// Orcamento Pai
Local cOrigemPai    := ""
Local nCntRes       := 0																// Contador de reserva
Local lLjPrdRes		:= ExistBlock("LJPRDRES")											// Se existe ponto de entrada
Local lLjPrdResT	:= ExistTemplate("LJPRDRES")										// Template
Local aLjPrdRes		:= {}  																// Retorno do P.E. LJPRDRES
Local lPedVen		:= SL1->(ColumnPos("L1_PEDRES")) > 0								// Verifica se o campo L1_PEDRES existe
Local lMvLjVfNfs 	:= SuperGetMv("MV_LJVFNFS",,.F.) //Verifica se a nota de simples faturamento esta ativa

Default aChaveCHRe 	:= {}
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de entrada para tratamento do código e descricao do produto             ³
//³ Retorno a posicao da aCols que contem o codigo e a descricao do produto       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lLjPrdResT
	aLjPrdRes := ExecTemplate("LJPRDRES",.F.,.F.,{nPosProduto,nPosDescPro} )
	If ValType(aLjPrdRes) == "A" .AND. Len(aLjPrdRes) >= 2
		nPosProduto	:= aLjPrdRes[1]
		nPosDescPro	:= aLjPrdRes[2]
	EndIf
EndIf

If lLjPrdRes
	aLjPrdRes := ExecBlock("LJPRDRES",.F.,.F.,{nPosProduto,nPosDescPro} )
	If ValType(aLjPrdRes) == "A" .AND. Len(aLjPrdRes) >= 2
		nPosProduto	:= aLjPrdRes[1]
		nPosDescPro	:= aLjPrdRes[2]
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Pega o codigo da loja local               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SLJ")
SLJ->( DbSetOrder(3) )
If DbSeek(xFilial("SLJ")+SM0->M0_CODIGO+FWGETCODFILIAL)
	cLojaLocal := SLJ->LJ_CODIGO
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se o foi feito Reserva para este orcamento, e se o mesmo veio pela venda assistida ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If !Empty( SL1->L1_DOCPED )
	
	cOrcPai    := SL1->L1_NUM
    cOrigemPai := SL1->L1_ORIGEM
	SL1->( DbSetOrder( 1 ) )
	
	For nX := 1 to nRegs
		If !Empty( GDFieldGet("L2_ORCRES",nX) )
			nCntRes := aScan(aReservas,{|ExpA1| ExpA1[1]+ExpA1[2] == GDFieldGet("L2_FILRES",nX) + GDFieldGet("L2_ORCRES",nX)})
			If nCntRes == 0
				AAdd( aReservas, {GDFieldGet("L2_FILRES",nX), GDFieldGet("L2_ORCRES",nX)} )
			EndIf
		EndIf
	Next nX
	
	If lRet
		For nX := 1 to Len( aReservas )
			If SL1->( DbSeek( aReservas[nX][1]+aReservas[nX][2] ))

				If lMvLjVfNfs .AND. Empty(cPedSFat) .AND. !(aReservas[nX][1] == xFilial("SL1"))
					cPedSFat := SL1->L1_PEDRES
				EndIf

				If lPedVen .AND. !Empty(SL1->L1_PEDRES) .AND. Alltrim(cOrigemPai) <> "N" .AND. !LjCancPed(aReservas[nX][1], SL1->L1_PEDRES)
					lRet := .F.
					Exit
				EndIf

				//Verifica se possui habilitado o processo de Simples Faturamento e se o campo com o nro do pedido está preenchido
				If lMvLjVfNfs .AND. lPedVen .AND.  !Empty(SL1->L1_PEDPRS) .AND. !LjCancPed(aReservas[nX][1], SL1->L1_PEDPRS)
					lRet := .F.
					Exit
				EndIf

				LJ140ExcOrc( aReservas[nX][1], aChaveCHRe )

			EndIf
		Next nX
	EndIf
	
	SL1->( DbSeek(xFilial( "SL1" ) + cOrcPai) )
Else
	For nX := 1 to nRegs
		If nPosReserva > 0 .AND. nPosLojaRes > 0 .AND. nPosProduto > 0 .AND. nPosLocal > 0 .AND. nPosQtdeDev > 0
			If !Empty(aCols[nX][nPosReserva])
				If Empty(aCols[nX][nPosLojaRes] )
					cLojaReserva := cLojaLocal
				Else
					cLojaReserva := aCols[nX][nPosLojaRes]
				EndIf
				aAdd(aReservas, {aCols[nX][nPosReserva], cLojaReserva, aCols[nX][nPosProduto], aCols[nX][nPosLocal]} )
			EndIf 
		EndIf
	Next nX
	
	If !Empty(aReservas)
		If !(LjCancRes(aReservas))
			lRet := MsgYesNo(STR0034 + cTexto + "?") //"Não foi possível cancelar a reserva. Deseja continuar a exclusão "
		EndIf
	EndIf
EndIf
        
Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ lj140Anul³ Autor ³ Vendas Clientes       ³ Data ³ 03.12.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Programa de anulacao de notas fiscais                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ lj140Anul(ExpC1,ExpN1,ExpN2)                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Opcao selecionada                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function lj140Anul(cAlias,nReg,nOpcx)

Lj140Exc(cAlias, nReg, nOpcx)

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ Lj140Leg  ³ Autor ³ Vendas Clientes       ³ Data ³ 05.03.04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Funcao de legenda da tela								   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Lj140Leg()		                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Lj140Leg()

Local aLegenda	:= {}
 
Aadd( aLegenda, {"BR_VERDE"			, STR0039} ) //"Orçamentos em aberto"
Aadd( aLegenda, {"BR_VERMELHO"		, STR0040} ) //"Vendas efetuadas"
Aadd( aLegenda, {"BR_AMARELO"		, STR0041} ) //"Orcamentos com reservas"
Aadd( aLegenda, {"BR_AZUL"			, STR0042} ) //"Pedidos encerrados"
Aadd( aLegenda, {"BR_PRETO"			, STR0043} ) //"Orcamentos em aberto vencidos"
Aadd( aLegenda, {"BR_MARROM"		, STR0044} ) //"Devoluções pendentes"
Aadd( aLegenda, {"BR_LARANJA"		, STR0082} ) //"Orçamentos com Pedidos de Venda"
Aadd( aLegenda, {"BR_CINZA"			, STR0084} ) //"Orçamentos Cancelados"
Aadd( aLegenda, {"BPMSEDT1"			, STR0096} ) //"Vendas estornadas"
aAdd( aLegenda,	{"BPMSEDT2"		, STR0140} )	//"Cancelamento com processamento pendente"
aAdd( aLegenda,	{"BR_PRETO_0"	, STR0141} )	//"Cancelamento não enviado ao TSS"
aAdd( aLegenda,	{"BR_PRETO_1"	, STR0142} )	//"Cancelamento aguardando autorização do SEFAZ"
aAdd( aLegenda,	{"BR_PRETO_2"	, STR0143} )	//"Cancelamento autorizado pela SEFAZ"
aAdd( aLegenda,	{"BR_PRETO_3"	, STR0144} )	//"Cancelamento não autorizado pela SEFAZ"


BrwLegenda(STR0045, STR0046, aLegenda) //"Orcamentos"###"Legenda"

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ lj140ICOrc³ Autor ³ Vendas Clientes       ³ Data ³ 05.03.04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Programa de impressao e cancelamento de orçamentos		   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ lj140ICOrc()		                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Lj140ICOrc()
Local cMensagem 	:= ""
Local lPreVenda		:= SuperGetMv("MV_LJPRVEN",,.T.) 	// Define se o cliente trata o orcamento como pre-venda
Local lImprime		:= .T.                         		// Controle para verificar se a impressao foi bem sucedida 
Local lImpOK 		:= .T.								// Status da Impressao	
Local lPafEcf		:= LjNfPafEcf(SM0->M0_CGC)


//³ Mensagem promocional, exigencia do PAF-ECF apresentar o numero da Pré Venda cancelada ³
If lPafEcf .AND. lPreVenda .AND. SL1->(ColumnPos("L1_NUMORC")) > 0
	cMensagem := STR0092 + SL1->L1_NUMORC + Chr(10)+ Chr(13) 		//"PV:"
	cMensagem += STR0050 + Chr(10)+ Chr(13) + ; 					//"Esse cupom sera cancelado de forma "
				 STR0122 + Chr(10)+ Chr(13)  						//"automatica. Requisito V do Ato Cotepe/ICMS 0608(PAF-ECF)"	
Else 
	cMensagem := STR0011 + SL1->L1_NUM + Chr(10)+ Chr(13)  			//"Or‡amento:"
	cMensagem +=	STR0050 + Chr(10)+ Chr(13) + ; 					//"Esse cupom sera cancelado de forma "
					STR0051 + Chr(10)+ Chr(13) + ; 					//"automatica. Conforme lei estadual  "
					STR0052											//"vigente que regulamenta pre-venda. "		
EndIf


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Imprime o cupom fiscal³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lImpOK := Lj140ImpOrc(cMensagem)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza SL1  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RecLock( "SL1" ,.F.)
SL1->L1_STORC	:= "C"
If lPafEcf .And. lPreVenda .And. lImpOK //Atualiza a data da impressão para que apareça no registro R04 do PAF
	SL1->L1_EMISSAO := dDatabase
EndIf
SL1->(MsUnLock())

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Cancela o cupom conforme previsto no Ato Cotepe 0608(PAF-ECF) ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lImprime := .T.
While lImprime .AND. lImpOK
	If !Lj7CaUlCup(.F.) 
		If Aviso(STR0006,STR0058 + CHR(10) + Chr(13) +; //"Atencao ## "Falha no cancelamento do cupom."
				 STR0087, {STR0088,STR0089}) = 2 	 	//"Executa a impressão novamente? # Sim # Não "
			lImprime 	:= .F.
			lImpOK 	:= .F.
		EndIf
	Else
		lImprime := .F.
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//|     Se usar os modulos de gestao de concessionarias chama a funcao que grava os relacionamentos.        |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SuperGetMv("MV_VEICULO") == "S"
			If !Empty(SL1->L1_VEICTIP) .AND. !Empty(SL1->L1_VEIPESQ)
				FG_DEVLOJA(SL1->L1_VEICTIP,SL1->L1_VEIPESQ,"","",.t.)
			EndIf
		EndIf
   	EndIf
End

Return(lImpOK)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Lj140GeraNC³ Autor ³ Vendas Clientes       ³ Data ³ 03.05.04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Gerar Nota de Credito para o cancelamento - Loc. Guatemala  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Lj140GeraNCC(ExpA1,ExpA2,ExpN1)                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = array com os dados da NF cancelada                  ³±±
±±³Parametros³ ExpA2 = array com os dados dos itens da NF cancelada        ³±±
±±³Parametros³ ExpN1 = iteracao                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Lj140GeraNCC(aItensSF2,	aItensSD2,	nI, cNumNFDev, ;
							 cSerieDev, cMotivo)

Local cEstado  := ""							//Variavel que recebe o Estado  	
Local cItem    := ""							//Variavel que recebe Item 
Local cCampo   := ""							//Variavel que recebe o campo para validação
Local cTESNCC  := ""							//Variavel que recebe TES da NCC
Local nX, nY									//Variavel contador
Local nItem    := 0								//Variavel numerica que recebe item 
Local nTamItem := TamSX3("D1_ITEM")[1]			//Variavel que recebe tamanho do compo D1_ITEM
Local nTotItens:= 0								//Variavel que recebe total de itens
Local nPosCols := 1								//Variavel que recebe posição da coluna
Local nPosRow  := 0								//Variavel que recebe posição da linha
Local nPosCpo  := 0								//Variavel que recebe posição do campo 
Local nValImps := 0								//Variavel que recebe valor dos impostos 
Local aCustoDev:= {}							//Array contendo informações do Custo
Local aGetBook := {}							//Array que recebe informaçõrs sobre o registro do Livro Fiscal 
Local aLivro   := {}							//Array que recebe informações sobre o livro fiscal
Local aImpVarSF1 := {}							//Array contendo informações para gerar os impostos variaveis para gravar no cabecalho da NCC

Private aImpVarSD1 := {0,0,0,0,0,{}}

SA1->(DbSetOrder(1))
If SA1->(DbSeek(xFilial("SA1")+aItensSF2[nI][3]+aItensSF2[nI][4]))
	cEstado  := SA1->A1_EST
EndIf

RecLock("SF1",.T.)
Replace SF1->F1_FILIAL		with xFilial("SF1")
Replace SF1->F1_DOC   		with cNumNFDev
Replace SF1->F1_SERIE		with cSerieDev
Replace SF1->F1_FORNECE 	with aItensSF2[nI][3]
Replace SF1->F1_LOJA	 	with aItensSF2[nI][4]
Replace SF1->F1_EMISSAO 	with dDataBase
Replace SF1->F1_DTDIGIT 	with dDataBase
Replace SF1->F1_TIPO	 	with "D"
Replace SF1->F1_ESPECIE 	with "NCC"
Replace SF1->F1_EST 	 	with cEstado
Replace SF1->F1_FORMUL  	with "S"
Replace SF1->F1_MOEDA  		with aItensSF2[nI][7]
Replace SF1->F1_TXMOEDA 	with aItensSF2[nI][8]
Replace SF1->F1_TIPODOC 	with "04"
Replace SF1->F1_VALMERC 	with aItensSF2[nI][6]
Replace SF1->F1_VALBRUT 	with aItensSF2[nI][5]

If cPaisLoc == "GUA"
	Replace SF1->F1_MOTIVO 	with cMotivo
	If ColumnPos("F1_MANUAL") > 0          
		If lNFManual
    		REPLACE SF1->F1_MANUAL WITH "S"
	    Else                               
	    	REPLACE SF1->F1_MANUAL WITH "N"
		EndIf
	EndIf
EndIf

For nX := 1 to Len(aItensSD2)
	nTotItens  += aItensSD2[nX][7]
Next nX

nItem  := 1
While aItensSD2[nItem][15] == aItensSF2[nI][1] .AND. ;
	aItensSD2[nItem][16] == aItensSF2[nI][2]
	
	cItem  :=  StrZero(nItem,nTamItem)
	
	SB1->(DbSetOrder(1))
	SB1->(DbSeek(xFilial("SB1")+aItensSD2[nItem][2]))
	
	SF4->(DbSetOrder(1))
	SF4->(DbSeek(xFilial("SF4")+aItensSD2[nItem][9]))
	cTESNCC  := IIf(!Empty(SF4->F4_TESNCC),SF4->F4_TESNCC,SuperGetMV("MV_TESTROC"))
	SF4->(DbSeek(xFilial("SF4")+cTESNCC))
	
	aCustoDev := {aItensSD2[nItem][17]/aItensSD2[nItem][5],;
	aItensSD2[nItem][18]/aItensSD2[nItem][5],;
	aItensSD2[nItem][19]/aItensSD2[nItem][5],;
	aItensSD2[nItem][20]/aItensSD2[nItem][5],;
	aItensSD2[nItem][21]/aItensSD2[nItem][5]}
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcular os impostos variaveis                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aImpVarSD1 := {0,0,0,0,0,{}}
	aImpVarSD1[1] := aItensSD2[nItem][5]
	aImpVarSD1[2] := aItensSD2[nItem][6]
	aImpVarSD1[3] := aItensSD2[nItem][7]
	nPosRow  := nItem
	CalcTesxIp("E",nTotItens,aItensSD2[nItem][14],aItensSD2[nItem][2],nPosCols,nPosRow,"RAPIDA")
	
	Reclock("SD1",.T.)
	Replace SD1->D1_FILIAL  	with xFilial("SD1")
	Replace SD1->D1_COD 	 	with aItensSD2[nItem][2]
	Replace SD1->D1_UM			with aItensSD2[nItem][3]
	Replace SD1->D1_SEGUM		with aItensSD2[nItem][4]
	Replace SD1->D1_GRUPO	    with aItensSD2[nItem][13]
	Replace SD1->D1_TIPO	 	with "D"
	Replace SD1->D1_ORIGLAN		with "LO"
	Replace SD1->D1_TP			with SB1->B1_TIPO
	Replace SD1->D1_NUMSEQ  	with ProxNum()
	Replace SD1->D1_QUANT	    with aItensSD2[nItem][5]
	Replace SD1->D1_VUNIT	    with aItensSD2[nItem][6]
	Replace SD1->D1_TOTAL	    with aItensSD2[nItem][7]
	Replace SD1->D1_TES 	 	with cTESNCC
	Replace SD1->D1_FORNECE 	with aItensSD2[nItem][11]
	Replace SD1->D1_LOJA	 	with aItensSD2[nItem][12]
	Replace SD1->D1_DOC 	 	with cNumNFDev
	Replace SD1->D1_SERIE	    with cSerieDev
	Replace SD1->D1_EMISSAO 	with dDataBase
	Replace SD1->D1_DTDIGIT 	with dDataBase
	Replace SD1->D1_NFORI	    with aItensSD2[nItem][15]
	Replace SD1->D1_SERIORI 	with aItensSD2[nItem][16]
	Replace SD1->D1_ITEMORI   	with aItensSD2[nItem][1]
	Replace SD1->D1_NUMCQ   	with xNumCaixa()
	Replace SD1->D1_LOCAL	    with aItensSD2[nItem][8]
	Replace SD1->D1_ITEM	 	with cItem
	Replace SD1->D1_CF			with aItensSD2[nItem][10]
	Replace SD1->D1_ESPECIE   	with "NCC"
	Replace SD1->D1_FORMUL  	with "S"
	Replace SD1->D1_TIPODOC 	with "04"
	Replace SD1->D1_CUSTO     	with aCustoDev[1]
	Replace SD1->D1_CUSTO2    	with aCustoDev[2]
	Replace SD1->D1_CUSTO3    	with aCustoDev[3]
	Replace SD1->D1_CUSTO4    	with aCustoDev[4]
	Replace SD1->D1_CUSTO5    	with aCustoDev[5]
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gravar os impostos variaveis no detalhe da Nota de Credito  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nX := 1 To Len(aImpVarSD1[6])
		If Substr(aImpVarSD1[6,nX,7],3,7) == "_BASIMP"
			cCampo   := "D1"+Substr(aImpVarSD1[6,nX,7],3,8)
			nPosCpo  := ColumnPos(cCampo)
			FieldPut(nPosCpo,aImpVarSD1[6,nX,3])
		EndIf
		
		If Substr(aImpVarSD1[6,nX,6],3,7) == "_VALIMP"
			cCampo   := "D1"+Substr(aImpVarSD1[6,nX,6],3,8)
			nPosCpo  := ColumnPos(cCampo)
			FieldPut(nPosCpo,aImpVarSD1[6,nX,4])
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//|    Soma os impostos discriminados                                                                       |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Substr(aImpVarSD1[6,nX,5],2,1) == "1"
				nValImps  += aImpVarSD1[6,nX,4]
			EndIf
		EndIf
	Next nX
	MsUnlock()
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gerar os impostos variaveis para gravar no cabecalho da NCC ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nX := 1 To Len( aImpVarSD1[6] )
		If (nY := aScan( aImpVarSF1,{|x| x[1] == aImpVarSD1[6,nX,8] } )) == 0
			AAdd( aImpVarSF1, { aImpVarSD1[6,nX,8], 0.00, aImpVarSD1[6,nX,2], aImpVarSD1[6,nX,1] } )
			nY := Len( aImpVarSF1 )
		EndIf
		aImpVarSF1[ nY,2 ] += aImpVarSD1[6,nX,4]
		
		If (nY := aScan( aImpVarSF1,{|x| x[1] == aImpVarSD1[6,nX,9] } )) == 0
			AAdd( aImpVarSF1, { aImpVarSD1[6,nX,9], 0.00, aImpVarSD1[6,nX,2], aImpVarSD1[6,nX,1] } )
			nY := Len( aImpVarSF1 )
		EndIf
		aImpVarSF1[ nY,2 ] += aImpVarSD1[6,nX,3]
	Next nX
	
	SA1->(DbSetOrder(1))
	SA1->(DbSeek(xFilial("SA1")+SF1->F1_FORNECE+SF1->F1_LOJA))
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gerar o registro do Livro Fiscal                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aLivro := GetBook(@aGetBook, aImpVarSD1, "V", aItensSF2[nI][8], aLivro, "E" )
	
	nItem++
	If nItem > Len(aItensSD2)
		Exit
	EndIf
End

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Gravar os impostos variaveis no cabecalho da Nota de Credito³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX := 1 To Len(aImpVarSF1)
	aImpVarSF1[nX,1] := "F1"+Substr(aImpVarSF1[nX,1],3,8)
Next nX
RecLock("SF1",.F.)
For nX := 1 To Len(aImpVarSF1)
	If (aImpVarSF1[nX,2] > 0)
		nPosCpo := FieldGet(ColumnPos(aImpVarSF1[nX,1]))+aImpVarSF1[nX,2]
		SF1->( FieldPut( ColumnPos( aImpVarSF1[nX,1] ),nPosCpo ) )
	EndIf
Next nX
SF1->F1_VALBRUT  := nTotItens + nValImps
MsUnLock()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Gravar Registro nos Livros Fiscais...			           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX := 2 To Len( aLivro )
	RecLock( "SF3",.T. )
	For nY := 1 To Len( aLivro[1] )
		SF3->( FieldPut(ColumnPos(aLivro[1,nY]),aLivro[nX,nY]) )
	Next nY
	SF3->F3_FILIAL 		:= xFilial("SF3")
	SF3->F3_FORMUL 		:= "S"
	SF3->F3_ESPECIE		:= "NCC"
	SF3->F3_TIPO   		:= "D"
	SF3->F3_CLIEFOR		:= aItensSF2[nI][3]
	SF3->F3_LOJA		:= aItensSF2[nI][4]
	MsUnLock()
Next nX

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Lj140Manual³ Autor ³ Vendas Clientes       ³ Data ³ 22.06.04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Pede confirmacao para NCC Manual                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Lj140Manual()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Lj140Manual()

Local lRet   := .T.								//Retorno da funcao
Local nOpcao := 1								//Opcao escolhida

If cPaisLoc == "GUA" .AND. lNFManual
	nOpcao := Aviso(STR0006,STR0073,{STR0074,STR0075}) //"Aten‡„o"###"Sera gravada uma Nota de Credito MANUAL. Confirma a operacao?"###"Confirma"###"Cancela"
	If nOpcao == 2
		lRet  := .F.
	EndIf
EndIf

Return lRet


/*/{Protheus.doc} Lj140Valida
Verifica se a venda pode ser cancelada 
@type  Static Function
@author Vendas Clientes
@since 21/11/06
/*/
Static Function Lj140Valida(lJob		, lVendTef	, aChave	, aCheques,;
							cSerNfCup	, cNumNfCup	, nTamDoc	, cNumNota,;
							lAchouSF2	, lLstPre 	, lEntrega  , aChaveSL1,;
							lValido)

Local lBaixaAut    	:= .F.									// Baixa automatica
Local lMvFisNota   	:= SuperGetMv("MV_FISNOTA")				// Conteudo parametro MV_FISNOTA
Local nTamF2_DOC   	:= TamSx3("F2_DOC")[1]          	// Tamanho Nota Fiscal
Local lUsaFD       	:= SuperGetMV("MV_LJUSAFD",,.F.) 		// Conteudo parametro MV_LJUSAFD
Local lValeCompra  	:= .F. 									// Variavel qu controle se o Titulo e Vale compra
Local nHoras		:= 0                            		// Quantidade de horas da hora atual
Local dDtDigit 		:= dDataBase							// Data da emissao da nota
Local nSpedExc 		:= SuperGetMV("MV_SPEDEXC",,72)			// Indica a quantidade de horas q a NFe pode ser cancelada
Local lHrVerao		:= SuperGetMv("MV_HVERAO",.F.,.F.) 		// Verifica se esta em horario de verão
Local cHoraRMT		:= SuperGetMV("MV_HORARMT",,"1")		// 1 - Considera a hora do SmartCient | 2 - Considera a hora do Servidor | 3 - Fuso horário da filial corrente
Local nNfceExc      := SuperGetMV("MV_NFCEEXC",, 0)         // Indica a quantidade de horas q a NFCe pode ser cancelada
Local lECCia 		:= SuperGetMv("MV_LJECOMO", .T., .F.)  .AND.  (SL1->L1_ECFLAG == "1")
Local lLj140VLC		:= .T.
Local lRet			:= .T.
Local cTipTef       := LjGetStation("LG_TIPTEF")			// Tipo do TEf
Local aCart			:= {}									// Array de Cartões
Local aSitua		:= {.F.,"  "}							// [1] - se atualiza o SIUTA [2] - novo valor do SITUA
Local lEndFis   	:= SuperGetMv("MV_SPEDEND",, .F.)		// Se estiver como F refere-se ao endereço de Cobrança se estiver T  ao  endereço de Entrega.
Local cEstSM0		:= IIf(!lEndFis, SM0->M0_ESTCOB, SM0->M0_ESTENT)
Local cHoraUF 		:= FwTimeUF(cEstSM0)[2]
Local lTemTefMan	:= Empty(SL1->L1_HORATEF) 				//Indica se na venda teve TEF Manual (via POS)
Local dHVeraoI		:= SuperGetMV("MV_HVERAOI",.F.,CTOD('  /  /    '))
Local dHVeraoF		:= SuperGetMV("MV_HVERAOF",.F.,CTOD('  /  /    '))
Local lRETSFZ		:= SL1->(ColumnPos("L1_RETSFZ")) > 0
Local aRetTSS 		:= IIF(lRETSFZ,StrToKarr2(SL1->L1_RETSFZ,"|"),{"",""})
Local cRetSfz 		:= iif( Len(aRetTSS) > 2, aRetTSS[02], aRetTSS[01] )
Local lDenegada 	:= cRetSfz $ RetCodDene()				//função no SPEDNFE
Local nMvLjTpCan	:= SuperGetMV("MV_LJTPCAN",,1)  		//Parametro que indica se utiliza o novo processo de cancelamento

Default lLstPre		:= .F.
Default lEntrega	:= .F.

LjGrvLog(Nil,"Lj140Valida | Inicio")

If Empty(cHoraUF)
	cHoraUF := Time()
EndIf

LjGrvLog(Nil,"Lj140Valida | Horario do UF ", cHoraUF)
LjGrvLog(Nil,"Lj140Valida | MV_HORARMT ", cHoraRMT)
LjGrvLog(Nil,"Lj140Valida | MV_HVERAO ", lHrVerao)

cNumNota := PadR(cNumNota,nTamF2_DOC)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Nos casos de JOB e EXECAUTO, a variavel publica cEstacao possui um valor default, sendo assim,	|
//| nao podemos usa-la como chave(LG_COD) para atribuir um valor as seguintes variaveis de sistema: |
//| - lFiscal, pois dependendo do campo LG_IMPFISC                                                  |
//|	- lUsaTef, pois depende do valor do campo LG_TIPTEF												|
//|Portanto essas validacoes devem ser feitas antes da chamada dessa funcao							|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !isBlind() .ANd. !lIsVendaVP .And. !lIsVdRecCP .And. !lLstPre .And. !lEntrega //verifica se ha interface com o usuario e nao eh venda de "Vale Presente" e nem "Recarga de Cartao Presente (Gift Card)"
	If lFiscal
		If Empty( SL1->L1_PDV ) .AND. !lMvFisNota  .AND. !lECCia .AND. !Empty(SL1->L1_DOC) //eh usuario fiscal
			If !IsBlind()
				MsgInfo( STR0035 ) //'Usuário não autorizado a excluir NF'
			Else 
				Conout(STR0035)				
			EndIf
			lRet := .F.
		EndIf
	Else
		If !Empty( SL1->L1_PDV ) .AND. !lECCia
			If !lExcAuto
				MsgInfo( STR0036 ) //'Usuário não autorizado a excluir Documento Fiscal'
			Else 
				Conout( STR0036 )
			EndIf
			lRet := .F.	
		EndIf
	EndIf
EndIf

If lRet
	If !isBlind() .AND. SL1->L1_VENDTEF == "S" .AND. (SL1->L1_CARTAO > 0 .OR. SL1->L1_VLRDEBI > 0)
		If lUsaTef .Or. lTemTefMan
			//Verifica se a venda TEF já foi cancelada  no Sl4
			lVendTef := .T.
			If cTipTef $ TEF_CLISITEF //Somente o cancelamento SITEF grava no SL4 o cancelamento 
				aCart := Lj140Cart() 
				lVendTef := Len(aCart) > 0
			EndIf
			
		Else
			lVendTef := .F.
			If !lExcAuto
				Help(" ",1,"NOUSERTEF")
				lRet := .F.
			Else
				//"O usuario atual nao e habilitado a utilizar as rotinas do TEF (Transferencia  Eletronica de Fundos), nao podera excluir esta venda, pois foi realizada via TEF." 
				Conout(STR0107)
			EndIf
		EndIf
	EndIf
	
	If lRet .And. !Lj140CHCarrega(aChave, @aCheques, @lValeCompra, @lBaixaAut, @lUsaFD)
		lRet := .F.
	EndIf
	
	//Verifica se Existem baixas para os títulos associados às guias
	If lRet .AND. Lj140BxCp(aChave, aChaveSL1)
		lRet := .F.
	EndIf
		
	If lRet
		DbSelectArea( "SF2" )
		SF2->( DbSetOrder(1) )
		lAchouSF2 := SF2->( DbSeek(xFilial("SF2") + cNumNota + SL1->L1_SERIE) )
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Verifica se existe NF para o cupom. Caso exista armazena o numero e a serie para futura exclusao...     |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( (lJob .OR. lExcAuto .OR. lFiscal) .AND. (SF2->F2_ECF == "S") ) .AND. !Empty(SF2->F2_NFCUPOM) .AND. lAchouSF2
			cSerNfCup := SubStr(SF2->F2_NFCUPOM,1,TamSx3("F2_SERIE")[1])
			cNumNfCup := SubStr(SF2->F2_NFCUPOM,4,nTamDoc)
		EndIf
		
		/* Verifica se cheque ja' foi depositado
		Posicao de Aceitacao de Numero de Cheque*/
		If Substr(SL1->L1_CONFVEN,1,1)  <> "N" 
			If !Lj140CHDepositado(@aCheques)
				lRet := .F.
			EndIf
		EndIf
		
		If lRet
			If lAchouSF2 .and. !lDenegada
				/* Verifica se eh uma NF-e, pois neste caso deve respeitar o MV_SPEDEXC, que indica qual o prazo max para cancelamento */
				If "SPED" $ SF2->F2_ESPECIE .AND. SF2->F2_FIMP $ "TS" .AND. AllTrim(SL1->L1_SITUA) <> 'X2'

					If cHoraRMT == "1" // Horario do SmartClient
						cHoraUF := SubStr(GetRmtTime(),1,8)
					ElseIf cHoraRMT == "3" // Fuso horário do estado
						//Verifica se é horário de verão (compatibilidade com os demais modulos)
						If !Empty(dHVeraoI) .And. !Empty(dHVeraoF) .And. dDataBase >= dHVeraoI .And. dDataBase <= dHVeraoF
							lHrVerao := .T.
						EndIf
						cHoraUF := FwTimeUF(SM0->M0_ESTENT,,lHrVerao)[2]
					Else // 2- Default - Horario do Server
						cHoraUF := SubStr(Time(),1,8)
					EndIf

					LjGrvLog(Nil,"Lj140Valida | NF-e - Horario do UF ", cHoraUF)

					If !Empty(SF2->F2_DAUTNFE) .AND. !Empty(SF2->F2_HAUTNFE)
						dDtdigit := SF2->F2_DAUTNFE
						nHoras   := SubtHoras( dDtdigit, SF2->F2_HAUTNFE, dDATABASE, SubStr(cHoraUF,1,2) + ":" + SubStr(cHoraUF,4,2) )
					Else
						dDtdigit := SF2->F2_EMISSAO
						nHoras   := SubtHoras( dDtdigit, SF2->F2_HORA, dDATABASE, SubStr(cHoraUF,1,2) + ":" + SubStr(cHoraUF,4,2) )
					Endif	

					//Devido ao cancelamento on-line, agora a nota pode 
					//chegar neste ponto e ja estar cancelada na SEFAZ
			    	If nMvLjTpCan == 2 .and. SL1->L1_SITUA $ "X0/X1"
			    		aSitua := Lj140AtuSit(SL1->L1_SITUA, SF2->F2_SERIE, SF2->F2_DOC)			
			    	Endif

					//Devido ao cancelamento on-line
					//Asseguro de que nao houve retorno ok do TSS, 
					//caso L1_SITUA está como X1 (enviado para o TSS)
					If nHoras > nSpedExc .AND. (len(aSitua) > 0 .and. !aSitua[2] == "X2")

						If !lExcAuto
							MsgAlert("[" + SF2->F2_FILIAL + "/" + SF2->F2_DOC+SF2->F2_SERIE + "]" + STR0094 + " " + cValToChar(nSpedExc) + STR0095)//"Não foi possivel excluir a nota, pois o prazo para o cancelamento do documento de saída é de"#" horas. Conforme configurado no parâmetro MV_SPEDEXC " 
						Else
						    Conout( STR0094 + " " + cValToChar(nSpedExc) + STR0095 + ;
						    		CRLF + STR0179 + "["+SF2->F2_FILIAL+"] / " + STR0181 + "["+SF2->F2_DOC+"] / " + STR0047 + " ["+SF2->F2_SERIE+"]" ) //#"Filial: " #"Número: " #"Série:"
							RecLock( "SL1", .F. )
								Replace SL1->L1_SITUA with "X3"
							SL1->( MsUnlock() )
							LjGrvLog(Nil,"L1_SITUA alterado para X3. Prazo configurado no parametro MV_SPEDEXC expirado.")			
						EndIf
						lRet := .F.	
				   	EndIf

				ElseIf "NFCE" $ AllTrim(SF2->F2_ESPECIE)
					
					dDtdigit := IIf(SF2->(FieldPos('F2_DTDIGIT'))>0 .AND. !Empty(SF2->F2_DTDIGIT), SF2->F2_DTDIGIT, SF2->F2_EMISSAO)
					nHoras   := SubtHoras( dDtdigit, SF2->F2_HORA, dDataBase, SubStr(cHoraUF,1,2)+":"+SubStr(cHoraUF,4,2) )

				    //Tratamento para manter o legado do parametro MV_SPEDEXC 
				    If nNfceExc <= 0
				        nNfceExc := nSpedExc
				    EndIf
				    
				    If nHoras > nNfceExc .AND. !SL1->L1_SITUA == "X2"
						//Devido ao cancelamento on-line, agora a nota pode chegar neste ponto e ja estar cancelada na SEFAZ
				    	If nMvLjTpCan == 2 .and. SL1->L1_SITUA $ "X0/X1"				   
				    		aSitua := Lj140AtuSit(SL1->L1_SITUA, SL1->L1_SERIE, SL1->L1_DOC)			
				    	Endif
						
                        If (len(aSitua) > 0 .and. !aSitua[1] .AND. !aSitua[2] == "X2") //me asseguro de que não houve retorno ok do TSS, caso L1_SITUA está como X1 (enviado para o TSS)
							If !lExcAuto
								MsgAlert(STR0094 + " " + Alltrim(STR(nNfceExc))+STR0186)//"Não foi possivel excluir a nota, pois o prazo para o cancelamento do documento de saída é de"#" horas. Conforme configurado no parâmetro MV_NFCEEXC " 
							Else
								Conout( NoAcento( STR0094 + " " + cValToChar(nNfceExc) + STR0186 + ;		//"Nao foi possivel excluir a nota, pois o prazo para o cancelamento do documento de saída e de"#" horas. Conforme configurado no parametro MV_NFCEEXC "
										CRLF + STR0179 + "["+SF2->F2_FILIAL+"] / " + STR0181 + "["+SF2->F2_DOC+"] / " + STR0047 + " ["+SF2->F2_SERIE+"]" )) //#"Filial: " #"Numero: " #"Serie:"
								RecLock( "SL1", .F. )
									Replace SL1->L1_SITUA with "X3"
								SL1->( MsUnlock() )
								LjGrvLog(Nil,"L1_SITUA alterado para X3. Prazo configurado no parametro MV_NFCEEXC expirado.")			
							EndIf
							lRet := .F. 
						Endif	
                    EndIf    
				EndIf
			EndIf
			
			// Ponto de Entrada - Validação final para o Cancelamento da Venda
			// Esse Ponto de Entrada deverá ser executado sempre por último nesta função
			If lRet .And. ExistBlock("LJ140VLC")
				LjGrvLog(Nil,"Ponto de Entrada LJ140VLC sera executado")			
				lLj140VLC := ExecBlock("LJ140VLC",.F.,.F.)
				Conout("Executou o Ponto de Entrada LJ140VLC.")
				LjGrvLog(Nil,"Executou o Ponto de Entrada LJ140VLC")
				
				If ValType(lLj140VLC) == "L"
					lRet := lLj140VLC
					LjGrvLog(Nil,"Retorno do Ponto de Entrada LJ140VLC", lLj140VLC)
				Else
					Conout("Retorno do PE LJ140VLC invalido")
					LjGrvLog(Nil,"Retorno do PE LJ140VLC invalido")
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

LjGrvLog(Nil,"Lj140Valida | Fim | Retorno ", lRet)

Return lRet
          
/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³Lj140CancCupom³ Autor ³ Vendas Clientes       ³ Data ³ 21.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Cancela o Cupom fiscal                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                         ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Lj140CancCupom(lAchouSF2,cSupervisor)
Local nRet			:= 0			// Retorno do cupom
Local cAntNumCup	:= ""
Local lCancela		:= .T.
Local lTryCanECF	:= .T.									//Valida se já foi cancelado documento no ECF
Local lL1_DOCCCF	:= SL1->(ColumnPos("L1_DOCCCF")) > 0	//Contem o DOC de cancelamento do ECF
Local cMsgPBM		:= ""									//Mensagem para exibição de informações para o PBM funcional card

DEFAULT cSupervisor := ""
  
If lFiscal .AND. lAchouSF2
    
	//Quando efetuo um cancelamento de uma nota também passa por aqui
	//portanto verifico se a venda se a refere a uma venda de cupom
	IF !Empty(AllTrim(SL1->L1_NUMCFIS))
		/*
			Tratamento para permitir a continuação do cancelamento caso
			o ECF tenha cancelado o documento mas o processo não foi finalizado
			pelo Protheus			
		*/		
		IF lL1_DOCCCF 
			If Empty(AllTrim(SL1->L1_DOCCCF))
				lTryCanECF := .T.
			Else
				lTryCanECF := .F.
			EndIf
		Else
			lTryCanECF	:= .T.
		EndIf
		
		If lTryCanECF
			nRet := IFPegCupom( nHdlECF,@cAntNumCup )
			If (AllTrim(cAntNumCup) <> AllTrim(SL1->L1_NUMCFIS)) .AND. ExistFunc("IFEstornVinc")
				nRet := IFEstornVinc(	nHdlECF,If(SL1->(ColumnPos("L1_CGCCLI")) > 0 ,SL1->L1_CGCCLI, ""),"","",;
										STR0130 ,cAntNumCup) //"Cancelamento de Comprovante de Crédito e Débito"
		
				If nRet <> 0
					MsgAlert(STR0131)
					//"Não foi possível efetuar o cancelamento do cupom vinculado. Verifique se o último
					//impresso foi um relatório gerencial caso seja não é permitido o cancelamento "
					
					If nModulo == 23 
						FR271BGeraSL("SL1", {{"L1_SITUA",	"00"}}) // Retira a 'solicitação de cancelamento
					EndIf

					If ExistTemplate("DROVLGet")
						cMsgPBM	:= STR0189 //"Por favor, efetue o procedimento de Troca/Devolução se for o caso de uma venda PBM Funcional Card."
					EndIf

					// "O Cupom fiscal nº "+cNumCup+", não pode ser cancelado."
					MsgStop(STR0132 + SL1->L1_NUMCFIS+ STR0133 + cMsgPBM)//"O Cupom fiscal nº "  ", não pode ser cancelado."

					lCancela := .F.
				EndIf
			EndIf
		EndIf
	EndIf
	
	/* Cancelamento do £ltimo Cupom Fiscal*/
	If lCancela .And. SF2->F2_ECF == "S" .AND. lTryCanECF
		nRet := IFCancCup(nhdlECF,cSupervisor)
		
		If nRet <> 0
			/*  "N„o foi possível efetuar a exclus„o"
			    "Existem problemas com a impressora fiscal" */
			If !lExcAuto
				MsgInfo( ( STR0029 ) + Chr(10) + Chr(13) + STR0030 )
			Else
				Conout( STR0029 )
				Conout( STR0030 )	
			EndIf
		
			lCancela := .F.
		Else
			If lL1_DOCCCF
				IFPegCupom( nHdlECF,@cAntNumCup )
				FR271BGeraSL("SL1", {{"L1_DOCCCF",	AllTrim(cAntNumCup)}}) //Preenche com o numero do DOC de cancelamento do ECF(numero do ultimo cupom)
			EndIf
		EndIf	
	EndIf
EndIf             

/* Se usar os modulos de gestao de concessionarias chama a funcao que grava os relacionamentos. */
If lCancela .And. SuperGetMv("MV_VEICULO") == "S"
	If !Empty(SL1->L1_VEICTIP) .AND. !Empty(SL1->L1_VEIPESQ)
		FG_DEVLOJA(SL1->L1_VEICTIP,SL1->L1_VEIPESQ,SL1->L1_DOC,SL1->L1_SERIE,.T.)
		If IsBlind()
			// Segunda chamada da função do DMS para excluir o orçamento no DMS , isso pq no PAF nao permite excluir da base o orçamento
			// Essa funcao eh chamada novamente para excluir do DMS
			FG_DEVLOJA(SL1->L1_VEICTIP,SL1->L1_VEIPESQ,"","",.T.)
		EndIf	
	EndIf
EndIf

Return lCancela

/*/{Protheus.doc} Lj140CancDB
Cancela o Cupom na base de dados
@type  Static Function
@author Vendas Clientes
@since 21.11.06
/*/
Static Function Lj140CancDB(aCheques	,lVendTef	,aChave		,cSerNfCup,;
							cNumNfCup	,nTamDoc	,cNumNota	,lAchouSF2,;
							lJob		,cDescMot	,lGeraNCC	,cNumNFDev,;
							cSerieDev	,cMotivo	,cNum		,aChaveSL1,;
							cProtoNfce	,lCancECF	,lValido)

Local lTefOk       	:= .F.							// Verificacao TEF
Local cSerNota    	:= SL1->L1_SERIE				// Serie da Venda
Local lExisteFT	   	:= AliasInDic("SFT")			// Se existe o SFT

Local lNfCup       	:= .F.                          // Controla se eh NF sobre cupom          
Local lCrdxInt     	:= CrdxInt()                    // Controla se tem integracao com SIGACRD

Local aItensSD2    	:= {}							// Itens SD2
Local aItensSF2    	:= {}							// Itens SF2
Local aRetCrd      	:= {}                          	// Array  de retorno do cancelamento do contrato - integracao SIGACRD

Local cCliNota 	   	:= ""							// Cliente da Nota
Local cCliLoja		:= ""							// Loja da Nota         
Local aRetCartao 	:= {}							//Variavel para guardar as informacoes do array "oTef:aRetCartao" caso estiver configurado a CLISITEF
Local aCartaoSL4	:= {}							//Variavel para guardar as informacoes do cancelamento do cartao para atualizar campos na tabela SL4

Local lContinua 	:= .T.
Local aPagDigPix 	:= {} 							//Informações de Pagamentos Digitais da venda

Default cProtoNfce	:= ""
Default lCancECF	:= .F.

If Substr(SL1->L1_CONFVEN,1,1)  <> "N" // Posicao de Aceitacao de Numero de Cheque
	Lj140CHSEFDel(@aCheques)
EndIf

If !lCancTef // So chama se ainda nao tiver efetuado o estorno do Cartao
    Lj140TlCTef(	@lJob		, @lVendTef		, Iif( Type("oTef") == "U" , Nil, @oTef ), @lTefOk,;
    				@aRetCartao	, @aCartaoSL4	, lCancECF	)
Else
	// Seta como .T. pois na função Lj140CnAdm foi efetuado a verificação da transação e
	// a variavel estatica lCancTef foi atualizada como .T.
	lTefOk := .T.				
EndIf 				

/*Re-abre o pedido, caso tenha seja nativo de SC5 - DAV */
If SL2->(ColumnPos("L2_PEDSC5")) > 0 .And. SL2->(ColumnPos("L2_ITESC6")) > 0 .And. SL2->(ColumnPos("L2_SEQUEN")) > 0
	If ExistFunc("MT461DvCN")
		MT461DvCN(SL1->L1_DOC, SL1->L1_SERIE, SL1->L1_NUM)
	EndIf
Endif

If !lVendTef .OR. (lVendTef .AND. lTefOk)
	//Cancela transações de Pagamento Digital.
	If ExistFunc("LjPDGtPGrv") .And. ExistFunc("LjPDCanTrn")
		//Busca informações de Pagamentos Digitais gravados na venda.
		aPagDigPix	:= LjPDGtPGrv(SL1->L1_NUM, .T.)

		If Len(aPagDigPix) > 0
			lContinua := LjPDCanTrn(@aPagDigPix)
		EndIf
	EndIf
EndIf

If lContinua
	/* Cancela o TEF na base de dados */
	Lj140CnTEF(@lTefOk		, @lJob			, @lVendTef		, @aChave	,;
			   @cNumNota	, @cSerNota		, @cCliNota		, @cCliLoja	,; 
			   @cDescMot	, @lAchouSF2	, @lExisteFT	, @lNfCup	,;	
			   @aItensSD2	, @cNumNfCup	, @cSerNfCup	, @nTamDoc	,;
			   @lCrdxInt	, @aRetCrd		, @lGeraNCC		, @aItensSF2,;
			   @aItensSD2	, cNumNFDev		, cSerieDev		, cMotivo	,;
			    cNum	 	, aRetCartao	, aCartaoSL4	, aChaveSL1 ,;
				cProtoNfce	, lValido)
EndIf

Return .T.

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³Lj140CnSD2    ³ Autor ³ Vendas Clientes       ³ Data ³ 24.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Cancela o SD2                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                         ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Lj140CnSD2(cNumNota, cSerNota, lNfCup, aItensSD2, cFilSD2)
Local cTESSaida    	:= ""							// TES saida
Local lLjD1TesT    	:= (ExistBlock("LJD1TesT"))		// Verifica a existencia do PE para tratamento de TES
Local cTESTroca	   	:= SuperGetMv("MV_TESTROCA")	// TES padrao para o processo de troca
Local nTamD2_DOC   	:= TamSx3("D2_DOC")[1]         	// Tamanho Nota Fiscal
Local cAuxChave	   	:= ""							// Variavel auxiliar para guardar a chave do SB2
Local lCAT83		:= SD2->(ColumnPos("D2_CODLAN")) > 0 .AND. ExistFunc("FISA023") .AND. SuperGetMV("MV_CAT8309",,.F.)
Local lAmbOffLn 	:= SuperGetMv("MV_LJOFFLN", Nil, .F.)	//Identifica se o ambiente esta operando em offline
Local cD2TESBkp		:=	""								// Backup do valor da SD2 (D2_TES) antes do replace
Local lIntegHtl		:= SuperGetMv("MV_INTHTL",, .F.) .And. Lj140GtInD() //Integracao via Mensagem Unica - Hotelaria
Local cProcesso		:= "000405"         //Codigo Processo PCO
Local cCodItem		:= "01"             //Item PCO
Local lIntegDef 	:= Lj140GtInD()     //Integracao via Mensagem Unica
Local lRet			:= .T.
Local lWmsNew   	:= SuperGetMV("MV_WMSNEW",.F.,.F.)	// Parâmetro para NOVO WMS
Local oEstEnder 	:= nil								// Objeto para consulta de estoque de endereçamento para novo WMS
Local cFilBkp		:= cFilAnt				//Guarda a Filial atual 
Local aAreaSM0		:= {}					//Guarda a area da SM0 

Default cFilSD2 := "" 

cNumNota := PadR(cNumNota,nTamD2_DOC)
LjGrvLog( "LOJA140", "Inicio Lj140CnSD2 " ) 
        
If !Empty(cFilSD2) 
	aAreaSM0 := SM0->(GetArea())
	cFilAnt := cFilSD2
EndIf

DbSelectArea("SD2")
SD2->(DbSetOrder(3))

LjGrvLog( "LOJA140", "Antes de entrar no If do DBSEEK do SD2", cNumNota+cSerNota )
If SD2->(DbSeek(xFilial("SD2")+cNumNota+cSerNota))
	LjGrvLog( "LOJA140", "Entrou no If do DBSEEK do SD2", cNumNota+cSerNota )
	//Inicia lancamento PCO - Hotelaria
	If lIntegHtl		
		PcoIniLan(cProcesso)
	EndIf
	LjGrvLog( "LOJA140", "Antes do WHILE do SD2", cNumNota+cSerNota )
	While lRet .And. !SD2->(Eof()) .AND.	(xFilial("SD2")	== SD2->D2_FILIAL) 	.AND. ;
								(SD2->D2_DOC 		== cNumNota 	.AND. ;
								 SD2->D2_SERIE 		== cSerNota)
		LjGrvLog( "LOJA140", "Entrou no WHILE do SD2", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )
			
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//|    Considerar somente os itens de NF                                                                    |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cPaisLoc <> "BRA"
			If SD2->D2_TIPODOC <> "01"
				SD2->(DbSkip())
				Loop
			EndIf
		EndIf
		
		If lNfCup .Or. (SD2->D2_PDV == SL1->L1_PDV) .Or. lIntegDef
			LjGrvLog( "LOJA140", "Entrou no IF do lNfCup .OR. (SD2->D2_PDV == SL1->L1_PDV)", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )
			cTESSaida  := SD2->D2_TES
			If !lNfCup .AND. SF4->(DbSeek(xFilial("SF4") + SD2->D2_TES))
				LjGrvLog( "LOJA140", "Entrou no IF do !lNfCup .AND. SF4->(DbSeek(xFilial('SF4') + SD2->D2_TES))", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza CAT/83						  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lCAT83
					FISA023("SD2",SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM,"E")
				EndIf
				If SF4->F4_ESTOQUE == "S"
					LjGrvLog( "LOJA140", "Entrou no IF do SF4->F4_ESTOQUE == 'S'", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )
					If SB2->( DbSeek(cFilial + SD2->D2_COD + SD2->D2_LOCAL ) )
						LjGrvLog( "LOJA140", "Entrou no IF do SB2", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//|     Verifica se o cliente utiliza tratamento específico para o controle de TES         |
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ				
						If lLjD1TesT
							aRet := ExecBlock("LJD1TesT",.F.,.F.,{cTESTroca,SD2->D2_COD,0})
							If ValType(aRet) == "A"
								cTESTroca := aRet[1]
							EndIf
						EndIf
						
						If RecLock("SD2",.F.)
							cD2TESBkp := SD2->D2_TES
							Replace SD2->D2_TES with cTESTroca
							LjGrvLog( "LOJA140", "Antes da rotina PegaCusD2", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )
							aCMSaida := PegaCusD2()
							LjGrvLog( "LOJA140", "Depois da rotina PegaCusD2 e antes da rotina B2AtuComD2", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )
							B2AtuComD2( aCMSaida, 1,,.F.)
							LjGrvLog( "LOJA140", "Depois da rotina B2AtuComD2", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )
							Replace SD2->D2_TES with cD2TESBkp		// Retorna a TES original para o campo D2_TES para não perder o histórico do campo.
							SB2->(MsUnLock())
							If lWmsNew .AND. IntWms(SD2->D2_COD)									//Efetua baixa das partes no novo Wms
								If GetApoInfo("WMSDTCEstoqueEndereco.PRW")[4] >= Ctod("01/11/2018")	//Não há ExistFunc() para métodos: utilizei GetApoInfo para verificar se tem o método oEstEnder:UndoFatLoj()
									If oEstEnder = nil
										oEstEnder := WMSDTCEstoqueEndereco():New()
									EndIf
									LjGrvLog( "LOJA140", " Antes da Execução do Método UndoFatLoj() - Recno da SD2: ", Alltrim( Str(SD2->(Recno()))) )
									oEstEnder:UndoFatLoj( SD2->(Recno()) )
									LjGrvLog( "LOJA140", " Depois da Execução do Método UndoFatLoj() - Recno da SD2: ", Alltrim( Str(SD2->(Recno()))) )
								EndIf
							Endif
						Else
							LjGrvLog( "LOJA140", "Não conseguiu reservar o SD2 para B2AtuComD2.", lRet ) 
							lRet := .F.	
							If lIntegDef
								Help( " ", 1, "Help",, "Não foi possível fazer Lock na tabela SD2 para fazer B2AtuComD2.", 1, 0 )
							EndIf
						EndIf
						If lRet .And. !( SD2->D2_TIPO $ "DBCIP" )
							DbSelectArea("SB3")
							SB3->(DbSetOrder(1))
							LjGrvLog( "LOJA140", "Antes do IF do SB3", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )
							If SB3->(DbSeek(xFilial("SB3") + SD2->D2_COD))
								LjGrvLog( "LOJA140", "Entrou no IF do SB3", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )
								RecLock("SB3")
							Else
								LjGrvLog( "LOJA140", "Else do SB3", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )
								RecLock("SB3",.T.)
								Replace SB3->B3_FILIAL with xFilial("SB3")
								Replace SB3->B3_COD    with SD2->D2_COD
							EndIf
							FieldPut(ColumnPos("B3_Q"+StrZero(Month(SD2->D2_EMISSAO),2)),FieldGet(ColumnPos("B3_Q"+StrZero(Month(SD2->D2_EMISSAO),2)))-SD2->D2_QUANT)
							SB3->B3_MES := SD2->D2_EMISSAO
							SB3->(MsUnLock())
						EndIf
						
					EndIf
				EndIf
			EndIf
			
			DbSelectArea( "SD2" )
			
			If lRet .And. cPaisLoc == "GUA"
				Aadd(aItensSD2,{	SD2->D2_ITEM	, SD2->D2_COD	 	, SD2->D2_UM		, SD2->D2_SEGUM , ;
									SD2->D2_QUANT	, SD2->D2_PRCVEN	, SD2->D2_TOTAL		, SD2->D2_LOCAL , ;
									cTESSaida		, SD2->D2_CF		, SD2->D2_CLIENTE	, SD2->D2_LOJA  , ;
									SD2->D2_GRUPO	, SD2->D2_PRUNIT	, SD2->D2_DOC		, SD2->D2_SERIE , ;
									SD2->D2_CUSTO1	, SD2->D2_CUSTO2	, SD2->D2_CUSTO3	, SD2->D2_CUSTO4,;
									SD2->D2_CUSTO5 } )
			EndIf
			
			//Efetua estorno PCO para SD2 - Hotelaria
			LjGrvLog( "LOJA140", "Antes da integração Hotelaria", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )
			If lRet .And. lIntegHtl
				LjGrvLog( "LOJA140", "Entrou na integração Hotelaria", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )
				//Posiciona no cliente
				SA1->(dbSetOrder(1)) //A1_FILIAL+A1_COD+A1_LOJA
				SA1->(dbSeek(xFilial("SA1") + SD2->D2_CLIENTE + SD2->D2_LOJA))
									
				//Posiciona no produto
				SB1->(dbSetOrder(1)) //B1_FILIAL+B1_COD
				SB1->(dbSeek(xFilial("SB1") + SD2->D2_COD))
						
				//Chamada estorno do PCO para SD2	
				PCODetLan(cProcesso, cCodItem, "LOJXFUNC", .T.)
			EndIf
			
			LjGrvLog( "LOJA140", "Antes do reclock do delete da SD2", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )
			If lRet .And. RecLock("SD2",.F.,.T.)
				LjGrvLog( "LOJA140", "Entrou no reclock do delete da SD2", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )
				SD2->( dbDelete() )
				
				LjGrvLog( "LOJA140", "Antes do estorno saldo poder de terceiro", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )
				If lIntegDef
					//Estorna Saldo Porder de terceiros
					TrfSldPoder3(SD2->D2_TES,"SD2",SD2->D2_COD,.T.)	
					LjGrvLog( "LOJA140", "Depois do estorno saldo poder de terceiro", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )			
				EndIf
				
				//Adiciona a tabela para exclusao no processo off-line
				If lAmbOffLn
					oProcOff:Inserir("SD2", xFilial("SD2") + SD2->D2_DOC + SD2->D2_SERIE + SD2->D2_CLIENTE + SD2->D2_LOJA + SD2->D2_COD + SD2->D2_ITEM, 3, "DELETE")
				EndIf
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Envia alteração de estoque OffLine³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
				cAuxChave := xFilial("SD2") + SD2->D2_COD + SD2->D2_LOCAL 
				If lAmbOffLn				
					oProcOff:Inserir("SB2", cAuxChave, 1, "UPDATE")						
				EndIf
				SD2->(MsUnlock())
				LjGrvLog( "LOJA140", "MsUnLock do SD2", SD2->D2_FILIAL+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD+SD2->D2_ITEM )
			Else
				lRet := .F.
				LjGrvLog( "LOJA140", "Não foi possível fazer Lock na tabela SD2 para delecao. Retorno do lRet", lRet ) 
				If lIntegDef
					Help( " ", 1, "Help",, "Não foi possível fazer Lock na tabela SD2 para delecao.", 1, 0 )
				EndIf	
			EndIf

		EndIf
		SD2->(dbSkip())
	EndDo
	
	//Finaliza lancamento PCO - Hotelaria
	If lRet .And. lIntegHtl
		LjGrvLog( "LOJA140", "Finaliza processo hotelaria", cProcesso )
		PcoFinLan(cProcesso)
	EndIf
EndIf

LjGrvLog( "LOJA140", "Retorno do lRet", lRet )

If !Empty(cFilSD2)
	cFilAnt := cFilBkp
	RestArea(aAreaSM0)
EndIf

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³Lj140CnSF2    ³ Autor ³ Vendas Clientes       ³ Data ³ 24.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Cancela o SF2                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                         ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Lj140CnSF2(cNumNota, 	cSerNota, 	cNumNfCup, 	cSerNfCup, ;
							 lNfCup, 	aItensSF2, 	nTamDoc, cProtoNfce, cFilSD2)
 
Local lFoundNF     	:= .F.									            //Se achou NF
Local lFisLivro		:= (SuperGetMV("MV_LJLVFIS",,1) == 2)	            //Utiliza novo conceito para geracao do SF3
Local lAmbOffLn 	:= SuperGetMv("MV_LJOFFLN", Nil, .F.)	            //Identifica se o ambiente esta operando em offline
Local lIntegDef		:= SL1->L1_ORIGEM == "N" .Or. Lj140GtInD()          //Integracao via Mensagem Unica
Local aAreaSF2		:= {}
Local lIntegHtl		:= lIntegDef .And. SuperGetMv("MV_INTHTL",, .F.)    //Integracao Hotelaria
Local cProcesso		:= "000405"											//Codigo Processo PCO
Local cCodItem		:= "02"												//Item PCO
Local nControle		:= 0												//Controle While
Local lContinua		:= .T.												//Flag do While
Local lRet			:= .T.
Local cFilBkp		:= cFilAnt											//Guarda a Filial atual 
Local aAreaSM0		:= {}												//Guarda a area da SM0 
Local lIsNFeDen		:=	.F.												// Informa se é Nota Denegada

Default nTamDoc		:= TamSx3("F2_DOC")[1]         						// Tamanho do campo F2_DOC
Default cProtoNfce	:= ""
Default cFilSD2 	:= "" 

LjGetMDoc( , , , , @lIsNFeDen )

cNumNota := PadR(cNumNota, nTamDoc)

LjGrvLog( "LOJA140", "Inicio Lj140CnSF2" )

If !Empty(cFilSD2)
	aAreaSM0 := SM0->(GetArea())
	cFilAnt := cFilSD2
EndIf

DbSelectArea("SF2")
SF2->( DbSetOrder(1) )
If SF2->( DbSeek(xFilial("SF2") + cNumNota + cSerNota) )
	If cPaisLoc <> "BRA"
		lFoundNF  := .F.
		While !Eof() .AND. xFilial("SF2") 	== SF2->F2_FILIAL 	.AND. cNumNota == SF2->F2_DOC .AND.  cSerNota 	== SF2->F2_SERIE .AND. ;
							!lFoundNF
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//|    Verifica se eh NF                                                                                    |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SF2->F2_TIPODOC <> "01"
				DbSkip()
				Loop
			EndIf
			
			lFoundNF  := .T.
		End
	EndIf
	cNumNota := SF2->F2_NEXTDOC
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//|    Exclui a Nf gerada para um determinado cupom, caso a mesma exista...                                 |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Empty(cNumNota) .AND. !Empty(cNumNfCup)
		cNumNota := cNumNfCup
		cSerNota := cSerNfCup
		cNumNfCup:= ""
		cSerNfCup:= ""
		lNfCup   := .T.
	EndIf
	If cPaisLoc <> "BRA"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//|     Armazenar os dados dos itens para gerar a NCC - Loc. Guatemala                                      |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		
		Aadd(aItensSF2,{ 	SF2->F2_DOC		, SF2->F2_SERIE		, SF2->F2_CLIENTE	, SF2->F2_LOJA	  , ;
							SF2->F2_VALBRUT	, SF2->F2_VALMERC	, SF2->F2_MOEDA		, SF2->F2_TXMOEDA	} )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cancela a baixa dos titulos com pagamento a vista.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SE4->(DbSetOrder(1))
		SE4->(DbSeek(xFilial("SE4")+SF2->F2_COND))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//|     Estornar a baixa dos titulos baixados automaticamente                                           |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		CaBxAutSE1("SE1",SF2->F2_COND,"SF2")
	EndIf
	
	//Estorna lancamentos fiscais
    MAFISCDA(,,.T.,SF2->("S"+F2_ESPECIE+"S"+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA),"S","SF2")
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Gera SF3 de acordo com a MATXFIS³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If lFisLivro .AND. !lIsNFeDen
		MaFisAtuSF3(2,"S",SF2->(Recno()),"SF2",,,,,,,cNfisCanc)
		MaFisEnd()
	EndIf	
	
	//Integracao Mensagem Unica, se NFCE altera status SF3 para nao enviar para Sefaz
	If lIntegDef												
		If AllTrim(SL1->L1_ESPECIE) == "NFCE|SPED" .And. !Empty(SL1->L1_KEYNFCE) //NFCe			
			SF3->(DbSetOrder(6)) //F3_FILIAL+F3_NFISCAL+F3_SERIE				
			If SF3->( DbSeek(xFilial("SF3") + SF2->F2_DOC + SF2->F2_SERIE) )
				While !Eof() .And. xFilial("SF3") 	== SF3->F3_FILIAL .And. SF2->F2_DOC == SF3->F3_NFISCAL .And. SF3->F3_SERIE == SF2->F2_SERIE
					SF3->(RecLock("SF3", .F.))
					SF3->F3_CODRSEF := "101"
					SF3->F3_DESCRET := STR0160 //#"Cancelamento de NF-e homologado"
					SF3->F3_CODRET  := "M"
					SF3->F3_PROTOC  := cProtoNfce //Verificar como chega essa informacao
					SF3->(MsUnlock())
					SF3->(dbSkip())
				EndDo	
			EndIf				
		EndIf											
	EndIf
	
	If lIntegHtl //Tratamentos hotelaria - PCO	
		//Inicia PCO		
		PcoIniLan(cProcesso)		
		
		//Posiciona no cliente
		SA1->(dbSetOrder(1)) //A1_FILIAL+A1_COD+A1_LOJA
		SA1->(dbSeek(xFilial("SA1") + SF2->F2_CLIENTE + SF2->F2_LOJA))				
			
		While lContinua .And. nControle <= 5				
			If RecLock("SF2",.F.,.T.)
				//Chamada estorno do PCO para SF2									
				aAreaSF2 := SF2->(GetArea()) //Salva area SF2
				PCODetLan(cProcesso, cCodItem, "LOJXFUNC", .T.)
				RestArea(aAreaSF2) //Restaura area SF2								
				
				SF2->(dbDelete())
				//Adiciona a tabela para exclusao no processo off-line
				If lAmbOffLn
					oProcOff:Inserir("SF2", xFilial("SF2") + SF2->F2_DOC + SF2->F2_SERIE + SF2->F2_CLIENTE + SF2->F2_LOJA, 1, "DELETE")
				Endif
				
				SF2->(MsUnlock())	
				lContinua := .F.
			Else
				Sleep(5000) //Aguarda 5 segundos para tentar novamente
				nControle ++
			EndIf												
		EndDo															
		
		//Finaliza processo PCO		
		PcoFinLan(cProcesso)						
		
		//Se registro locado, retorna mensagem de erro
		If lContinua
			lMsErroAuto := .T.
			Help(" ",1,"NO140CANC",,STR0161,3,1) //#"Nao foi possivel cancelar venda, registro em uso"
		EndIf
	Else
		SD2->(dbsetorder(3))
		//Só deleta se realmente exclui os registros da SD2
		If SD2->(DbSeek(xFilial("SD2")+SF2->F2_DOC + SF2->F2_SERIE))
			LjGrvLog( "LOJA140", "Não foi possível excluir SF2 pois algum registro na SD2 não foi excluído.", cProcesso )
			lRet := .F.
			If lIntegDef
				Help( " ", 1, "Help",, "Não foi possível excluir SF2 pois algum registro na SD2 não foi excluído.", 1, 0 )
			EndIf
		Else
			If RecLock("SF2",.F.,.T.)
				SF2->( dbDelete() )
				//Adiciona a tabela para exclusao no processo off-line
				If lAmbOffLn
					oProcOff:Inserir("SF2", xFilial("SF2") + SF2->F2_DOC + SF2->F2_SERIE + SF2->F2_CLIENTE + SF2->F2_LOJA, 1, "DELETE")
				Endif
				MsUnlock()
			Else
				lRet := .F.
			EndIf
		EndIf
	EndIf
Else
	cNumNota := Space(nTamDoc)
EndIf

LjGrvLog( "LOJA140", "Final Lj140CnSF2 do lRet" , lRet)

If !Empty(cFilSD2)
	cFilAnt := cFilBkp
	RestArea(aAreaSM0)
EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Lj140DtSFT    ³ Autor ³ Vendas Clientes       ³ Data ³ 24.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Altera a data da tabela SFT                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Static Function Lj140DtSFT(cSerNota, cNumNota, cCliNota, cCliLoja, lExisteFT, lIsNFeDen)
Local nTamFT_NFISCAL := TamSx3("FT_NFISCAL")[1] //Tamanho Nota Fiscal

Default lIsNFeDen := .F. // Nota Denegada

cNumNota := PadR(cNumNota,nTamFT_NFISCAL)                  

If (cPaisLoc == "BRA" .AND. lExisteFT)
	DbSelectArea("SFT")
	DbSetOrder(1)
	If DbSeek( xFilial("SFT") + "S" + cSerNota + cNumNota + cCliNota + cCliLoja)
		While !Eof() .AND. xFilial("SFT")+cSerNota+cNumNota+cCliNota+cCliLoja == SFT->FT_FILIAL ;
							+ SFT->FT_SERIE+SFT->FT_NFISCAL+SFT->FT_CLIEFOR+SFT->FT_LOJA
			RecLock("SFT",.F.)
			Replace SFT->FT_DTCANC	With dDatabase
			If !lIsNFeDen
				Replace SFT->FT_OBSERV	With "NF CANCELADA"
			EndIf
			MsUnLock()
			dbSkip()
			Loop
		End
	EndIf
EndIf
    
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Lj140CancSF3  ³ Autor ³ Vendas Clientes       ³ Data ³ 24.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Cancela o SF3                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Lj140CancSF3(cSerNota, 	cNumNota, 	cCliNota, 	cCliLoja, ;
							 cDescMot, 	lAchouSF2, 	lExisteFT, lIsNFeDen)

Local aOtimizacao  		:= {}						  	  		// Array utilizada na MATXFIS
Local lPais				:= .T.							 		// Variavel logica que recebe que testa se o pais e <> de Brasil
Local nTamF3_NFISCAL 	:= TamSx3("F3_NFISCAL")[1]        		// Tamanho Nota Fiscal
Local lFieldA1Mod 		:= SA1->(ColumnPos("A1_MODCFD")) > 0 	// Verifica se existe o campo A1_MODCFD
Local lFieldStatus		:= SF3->(ColumnPos("F3_STATUS")) > 0	// Verifica se existe o campo F3_STATUS
Local aCposZerar		:= {}									// Lista de campos a zerar ao anular NF (bolivia)
Local nX				:= 0									// Auxiliar de loop
Local nCpo				:= 0									// Auxiliar de loop
Local cCampo			:= ""									// Nome do campo F3_VALIMP?
Local aCposImp			:= {}									// Prefixos de campos de impostos a serem zerados
Local cSufixo			:= ""									// Final do nome do campo

Default lIsNFeDen := .F.										// NF Denegada

cNumNota := PadR(cNumNota,nTamF3_NFISCAL) 

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Lista de campos a serem zerados ao anular a NF (Bolivia),³
//³para integracao com DaVinci                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPaisLoc == "BOL" .AND. !lIsNFeDen

	aCposZerar := {"F3_VALCONT","F3_DESPESA","F3_VALOBSE","F3_VALMERC"}
	aCposImp   := {"F3_VALIMP","F3_ALQIMP","F3_BASIMP","F3_RETIMP"}

	For nX := 1 to 35

		If nX <= 9
			cSufixo := Str(nX,1,0)
		Else
			cSufixo := Chr(55+nX)
		EndIf
		
		For nCpo := 1 to Len(aCposImp)
			cCampo := aCposImp[nCpo] + cSufixo
			If SF3->(ColumnPos(cCampo)) > 0
				AAdd(aCposZerar,cCampo)
			EndIf
		Next nCpo

	Next nX

EndIf

DbSelectArea("SF3")
DbSetOrder(5)
If DbSeek( xFilial("SF3") + cSerNota + cNumNota )

	While !Eof() .AND. xFilial("SF3") + cSerNota + cNumNota == SF3->F3_FILIAL + SF3->F3_SERIE + SF3->F3_NFISCAL
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Excluir apenas Nota Fiscal de Saida	    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !(Substr(SF3->F3_CFO,1,1) >= "5")
			dbSkip()         
			Loop
		EndIf
		RecLock("SF3",.F.)

		If lIsNFeDen
			SF3->F3_DTCANC := dDatabase
		Else
			If cPaisLoc<>"BRA"
				lPais := lAnulaSF3
			Else
				lPais := .T.
			EndIf	
			
			If lPais
				Replace SF3->F3_DTCANC with dDatabase
				Replace SF3->F3_OBSERV with "NF CANCELADA"
				If cPaisLoc == "GUA"
					Replace SF3->F3_OBSERV   with cDescMot
				EndIf
				If cPaisLoc == "BOL" .AND. lFieldStatus
					Replace SF3->F3_STATUS with "A"
					For nX := 1 to Len(aCposZerar)
						Replace SF3->&(aCposZerar[nX]) With 0
					Next nX
				EndIf
			Else
				If cPaisLoc == "MEX" .AND. AliasIndic("MDL") .AND. lFieldA1Mod
					CFDExcXML(SF2->F2_ESPECIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_DOC,SF2->F2_SERIE,.T.)		
				EndIf		
				DbDelete()
			EndIf
		EndIf
		MsUnLock()
		dbSkip()
	End
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Preenche a Data de Cancelamento da venda³
	//³no campo FT_DTCANC para a tabela SFT    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Lj140DtSFT(cSerNota, cNumNota, cCliNota, cCliLoja, lExisteFT, lIsNFeDen)
	
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Caso nao tenha sido gerado F3, deve registrar o cancelmento desta NF, sempre que o MV_MAPARES == "N"  |
	//| para cupom fiscal  																					  |			
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 If !Empty(SL1->L1_DOC+SL1->L1_SERIE) .AND. lAchouSF2 .AND. ;
    ( Empty(SL1->L1_PDV) .OR. (!Empty(SL1->L1_PDV) .AND. ( LjNfPafEcf(SM0->M0_CGC) .OR. SuperGetMV("MV_MAPARES") == "N" .OR. cPaisLoc <> "BRA" )))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Carrega a Nota Fiscal SF3 referente a Notas Fiscais de Entrada³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		MaFisIniNF(2,SF2->(Recno()),@aOtimizacao,"SF2",.T.)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Inicializa a gravacao nas funcoes Fiscais               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		MaFisWrite()
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Efetua a gravacao dos registros referente a Nota no SF3 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea("SF2")
		
		MaFisAtuSF3(1,"S",SF2->(Recno()),"SF2")
		
		DbSelectArea("SF3")
		DbSetOrder(5)
		If DbSeek( xFilial("SF3") + cSerNota + cNumNota )
			While !Eof() .AND. xFilial("SF3")+cSerNota+cNumNota == SF3->F3_FILIAL+SF3->F3_SERIE+SF3->F3_NFISCAL
		
				RecLock("SF3",.F.)
				Replace SF3->F3_DTCANC	with dDatabase
				Replace SF3->F3_OBSERV	with "NF CANCELADA"
				SF3->(MsUnLock())
				MaFisEnd()
				MsUnLock()
				SF3->(dbSkip())
			End
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Preenche a Data de Cancelamento da venda³
		//³no campo FT_DTCANC para a tabela SFT    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (cPaisLoc == "BRA" .AND. lExisteFT)
			DbSelectArea("SFT")
			DbSetOrder(1)
			If DbSeek( 	xFilial("SFT") 	+ "S" + cSerNota + cNumNota + ;
						cCliNota 		+ cCliLoja)
				While !Eof() .AND. xFilial("SFT") 	+ cSerNota + cNumNota + ;
									cCliNota 		+ cCliLoja == SFT->FT_FILIAL 	+ SFT->FT_SERIE + ;
									SFT->FT_NFISCAL	+ SFT->FT_CLIEFOR				+ SFT->FT_LOJA
			
					RecLock("SFT",.F.)
					Replace SFT->FT_DTCANC	With dDatabase
					Replace SFT->FT_OBSERV	With "NF CANCELADA"
					MsUnLock()
					dbSkip()
					Loop
				End
			EndIf
	    EndIf
	EndIf
	If cPaisLoc == "MEX" .AND. AliasIndic("MDL") .AND. lFieldA1Mod
		CFDExcXML(SF2->F2_ESPECIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_DOC,SF2->F2_SERIE,.T.)							
	EndIf	
EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Lj140LpSL2    ³ Autor ³ Vendas Clientes       ³ Data ³ 24.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ LImpa SL2                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Lj140LpSl2(cNum, nVlrOrc)

Local nMvLjTpDes	:= SuperGetMv( "MV_LJTPDES", , 0 )
Local lAtuMds		:= SuperGetMv("MV_LJIPECF",,.F.) .And. AliasInDic("MDS") .And. IsInCallStack("LJ140CNTEF")
Local cCpoBas		:= ""
Local aAreaMDS		:= MDS->(GetArea())
Local lAmbOffLn 	:= SuperGetMv("MV_LJOFFLN", Nil, .F.)	//Identifica se o ambiente esta operando em offline

DEFAULT nVlrOrc   	:= 0	// Valor Total do Orcamento
DEFAULT cNum	  	:= ""

If FunName() <> "STBORCCANCEL"
	DbSelectArea( "SL2" )
	SL2->( DbSetOrder(1) )
	SL2->( DbSeek( xFilial("SL2")+ cNum ) )
	
	While SL2->(!Eof()) .AND. xFilial("SL2") == SL2->L2_FILIAL .AND. SL2->L2_NUM == cNum

		//Tratamento para cancelamento de cupom fiscal para atualização da tabela MDS
		If lAtuMds .And. !Empty(SL2->L2_DOC) .And. Left(SL2->L2_SITTRIB,1) $ "T|S" //Situacao Tributaria (T=ICMS ou S=ISS)

			cCpoBas	:= "MDS_BA" + Right(AllTrim(SL2->L2_SITTRIB),Len(AllTrim(SL2->L2_SITTRIB))-1)

			If MDS->(ColumnPos(cCpoBas) ) > 0
				If MDS->( DbSeek(xFilial("MDS") + DTOS(SL1->L1_EMISNF) + SL2->L2_PDV ) )
					RecLock("MDS",.F.)
		       	    REPLACE MDS->(&cCpoBas) WITH MDS->(&cCpoBas) - (SL2->L2_VLRITEM + SL2->L2_VALFRE)
				    MDS->(MsUnlock())
			    EndIf
			EndIf

		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se o orcamento possui reserva³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea("SC0")
		SC0->( DbSetOrder(1) ) //C0_FILIAL + C0_NUM + C0_PRODUTO + C0_LOCAL
		Reclock( "SL2",.F.,.T.)	
		If !SC0->( DbSeek(SL2->L2_FILIAL + SL2->L2_RESERVA + SL2->L2_PRODUTO + SL2->L2_LOCAL) )		
			Reclock( "SL2",.F.,.T.)	
				REPLACE SL2->L2_RESERVA		WITH ""
			SL2->( MsUnlock() )
		EndIf
	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Restaura os valores anteriores ao fechamento da venda,  ³
		//³para que durante a proxima finalizacao, os valores sejam³
		//³recalculados.                                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea("SL2")
		//PAF-ECF: Não deve limpar, movimento deverá constar no Movimento por ECF do menu Fiscal
		If !LjNfPafEcf(SM0->M0_CGC) 

			Reclock( "SL2",.F.,.T.)
			REPLACE SL2->L2_VENDIDO	WITH " "
			REPLACE SL2->L2_DOC		WITH ""
			REPLACE SL2->L2_SERIE	WITH ""
			REPLACE SL2->L2_PDV		WITH ""
			REPLACE SL2->L2_VENDIDO	WITH " "
			REPLACE SL2->L2_SOLCOM	WITH ""			
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se houve desconto no total da venda, reaplica o valor³
			//³descontado porporcionalmente                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF cPaisLoc == 'BRA'
				If SL2->L2_DESCPRO > 0 
					REPLACE SL2->L2_VLRITEM	WITH SL2->(L2_VLRITEM + L2_DESCPRO)
					If  nMvLjTpDes == 2
						REPLACE SL2->L2_VRUNIT	WITH (SL2->L2_PRCTAB - ( SL2->L2_PRCTAB * (SL2->L2_DESC / 100)) )
					Else
						REPLACE SL2->L2_VRUNIT	WITH SL2->(L2_VLRITEM / L2_QUANT)
					End
				EndIf
		
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Se houve acrescimo na venda, retira o valor do acrescimo³
				//³dos itens.                                              ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SL1->L1_JUROS > 0 .OR. AllTrim( SL1->L1_CONDPG ) == "CN"
					REPLACE SL2->L2_VLRITEM WITH SL2->((L2_PRCTAB * L2_QUANT) - L2_VALDESC)
					If  nMvLjTpDes == 2	
						REPLACE SL2->L2_VRUNIT  WITH (SL2->L2_PRCTAB	- ( SL2->L2_PRCTAB * (SL2->L2_DESC / 100)  )	 )
					Else
						REPLACE SL2->L2_VRUNIT  WITH SL2->(L2_VLRITEM/L2_QUANT)
					EndIf	
					REPLACE SL2->L2_VALACRS WITH 0
				EndIf
			
				REPLACE SL2->L2_VALICM	WITH 0
				REPLACE SL2->L2_BASEICM	WITH SL2->(L2_PRCTAB * L2_QUANT)
				REPLACE SL2->L2_DESCPRO WITH 0
			EndIf 
				
			SL2->( MsUnlock() )
		EndIf
	
		If lAmbOffLn
			oProcOff:Inserir("SL2", xFilial("SL2") + SL2->L2_NUM + SL2->L2_ITEM +SL2->L2_PRODUTO, 1, "DELETE")
		Endif
	
		nVlrOrc += SL2->L2_VLRITEM	
		SL2->( DbSkip() )
	End
EndIf

RestArea(aAreaMDS)
Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Lj140LpSL1    ³ Autor ³ Vendas Clientes       ³ Data ³ 24.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ LImpa SL1                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1 = Controla se tem integracao com SIGACRD                 ³±±
±±³          ³ ExpC2 = Numero do orcamento                                    ³±±
±±³          ³ ExpN2 = Valor liquido do Orcamento                             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Static Function Lj140LpSL1(lCrdxInt, cNum, nVlrOrc)

Local nI			:= 0								// Contador de For
Local cCpoTroco		:= ""								// Campo troco
Local nVlrTot		:= 0								// Valor com desconto sobre o total aplicado
Local nVlrDescFi	:= 0								// Valor com Desconto Financeiro
Local nDescont		:= 0								// Valor do Desconto sobre o Total
Local nValFrete    	:= 0								// Valor do Frete
Local cMvTmkLoj     := SuperGetMV("MV_TMKLOJ",,.F. )   // verIfica se ha integracao com o Callcenter
Local aSL1Area		:= {}
Local lAmbOffLn 	:= SuperGetMv("MV_LJOFFLN", Nil, .F.)	//Identifica se o ambiente esta operando em offline
Local lCentPDV      := IIf( ExistFunc("LjGetCPDV"), LjGetCPDV()[1] , .F. ) // Eh Central de PDV

DEFAULT cNum		:= ""

If FunName() <> "STBORCCANCEL"

	DbSelectArea("SL1")
	SL1->( DbSetOrder(1) )
	SL1->( DbSeek(xFilial("SL1")+ cNum) )
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Aplica novamente o desconto sobre o total.³
	//³O desconto financeiro sera calculado      ³
	//³novamente na finalizacao da Venda.        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nVlrTot 	:= (nVlrOrc - SL1->L1_DESCONT)	//Valor com desconto sobre o total aplicado
	nVlrDescFi	:=	IIF(SL1->( ColumnPos( "L1_DESCFIN" )) > 0,SL1->L1_DESCFIN , 0  ) // Retira o desc Financeiro,será recalculado na finalizacao da venda
	nDescont	:= SL1->L1_DESCONT				//Valor do desconto sobre o total
	nValFrete   := SL1->L1_FRETE				//Valor do Frete
	
	Reclock( "SL1" ,.F.,.T.)
	
	REPLACE SL1->L1_DOC 		WITH ""
	REPLACE SL1->L1_SERIE 		WITH ""
	REPLACE SL1->L1_PDV 		WITH ""
	REPLACE SL1->L1_EMISNF 		WITH Ctod(" ")
	REPLACE SL1->L1_TIPO 		WITH ""

	If SL1->( ColumnPos("L1_DOCRPS") ) > 0
		Replace SL1->L1_DOCRPS	with ""
		Replace SL1->L1_SERRPS	with ""
	EndIf

	If cPaisLoc == "BRA"
		REPLACE SL1->L1_DESCONT		WITH nDescont - nVlrDescFi
		REPLACE SL1->L1_VLRTOT		WITH nVlrTot
		REPLACE SL1->L1_VLRLIQ		WITH nVlrTot + nValFrete 
		REPLACE SL1->L1_VALBRUT  	WITH nVlrTot + nValFrete
		REPLACE SL1->L1_SITUA		WITH ""

		//Limpa chave da NFCe
		If SL1->(ColumnPos("L1_KEYNFCE")) > 0                
			REPLACE SL1->L1_KEYNFCE	WITH ""
			REPLACE SL1->L1_SITUA	WITH ""
		EndIf			
	Else
		REPLACE SL1->L1_VALBRUT		WITH SL1->L1_VLRTOT
	EndIf

	REPLACE SL1->L1_DINHEIR 	With 0
	REPLACE SL1->L1_CHEQUES  	With 0
	REPLACE SL1->L1_CARTAO   	With 0
	REPLACE SL1->L1_CONVENI  	With 0
	REPLACE SL1->L1_VALES    	With 0
	REPLACE SL1->L1_FINANC   	With 0
	REPLACE SL1->L1_OUTROS   	With 0
	REPLACE SL1->L1_ENTRADA		With 0
	REPLACE SL1->L1_VLRDEBI  	With 0
	REPLACE SL1->L1_VENDTEF  	With ""
	REPLACE SL1->L1_NUMCFIS  	With ""
	REPLACE SL1->L1_OPERADO  	With ""
	REPLACE SL1->L1_BLCRED   	With ""
	REPLACE SL1->L1_VALICM		With 0
	
	If AllTrim( SL1->L1_CONDPG ) == "CN"
		REPLACE SL1->L1_JUROS	With 0
	EndIf
	
	If SL1->(ColumnPos("L1_VLRPGDG")) > 0 .AND. SL1->(ColumnPos("L1_VLRPGPX")) > 0
		REPLACE SL1->L1_VLRPGDG  With 0
		REPLACE SL1->L1_VLRPGPX  With 0
	EndIf

	If lCrdxInt .AND. SL1->(ColumnPos("L1_CONTRA")) > 0
		REPLACE SL1->L1_CONTRA  With ""
	EndIf
	          
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//   Zera os campos de troco...                                                                             |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPaisLoc <> "BRA"
		For nI := 1 To MoedFin()
			cCpoTroco := "L1_TROCO"+AllTrim(Str(nI))
			If SL1->(ColumnPos(cCpoTroco)) > 0
				SL1->(FieldPut(ColumnPos(cCpoTroco),0))
			EndIf
		Next nI
	EndIf
	
    If lCentPDV //CentralPdv limpa orcamento para reutilizacao
        REPLACE SL1->L1_STORC WITH ""
    EndIf
    
	//PAF-ECF: Não deve limpar todos os dados, apenas sinalizar 
	If !LjNfPafEcf(SM0->M0_CGC) 
		REPLACE SL1->L1_PDV 		WITH ""
		REPLACE SL1->L1_NUMCFIS  	With ""
		REPLACE SL1->L1_TPORC		WITH ""

		If cPaisLoc == "BRA"
			REPLACE SL1->L1_DESCONT		WITH nDescont	- nVlrDescFi
			REPLACE SL1->L1_VLRTOT		WITH nVlrTot	+ nVlrDescFi
			REPLACE SL1->L1_VLRLIQ		WITH nVlrTot + nValFrete
			REPLACE SL1->L1_VALBRUT  	WITH nVlrTot + nValFrete
		Else
			REPLACE SL1->L1_VALBRUT		WITH SL1->L1_VLRTOT	
		EndIf
	ElseIf SL1->L1_TPORC == "D"
		//se for DAV, nao e permitido reutilizar o orcamento
		REPLACE SL1->L1_STORC WITH "C"
	Else
	 	// pendente: verificar para Pre-Venda é o mesmo tratamento	
		REPLACE SL1->L1_TPORC WITH ""		
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//|Verifica se existe o numero da reserva no item, caso nao, limpa a reserva do cabecalho|
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SL1->L1_RESERVA == 'S'
		aSL1Area := SL1->( GetArea() )
		DbSelectArea("SL2")
		SL2->( DbSetOrder(1) )
		If SL2->( DbSeek(SL1->L1_FILIAL + SL1->L1_NUM) ) .AND. Empty(SL2->L2_RESERVA)
			REPLACE SL1->L1_RESERVA  With ""
		EndIf
		SL1->( RestArea(aSL1Area) )
	EndIf
	
	SL1->( MsUnlock() )
	
	//Adiciona a tabela para exclusao no processo off-line
	If lAmbOffLn
		oProcOff:Inserir("SL1", xFilial("SL1") + SL1->L1_NUM, 1, "DELETE")
	
		
		DbSelectArea("SL4")
			
		If (SL4->(DbSeek(xFilial("SL4") + SL1->L1_NUM)))
		
			While !SL4->(EOF()) .AND. SL4->L4_FILIAL + SL4->L4_NUM == xFilial("SL4") + SL1->L1_NUM
				//Adiciona a tabela para exclusao no processo off-line
				oProcOff:Inserir("SL4", xFilial("SL4") + SL4->L4_NUM + SL4->L4_ITEM, 2, "DELETE")	
				SL4->(DbSkip())
			End	
		
		EndIf
	Endif	
	
	If cMvTmkLoj == "S" .And. !Empty(SL1->L1_NUMATEN)
		DbSelectArea("SUA")
		DbSetOrder(1)
		If DbSeek(xFilial("SUA") + SL1->L1_NUMATEN) 
			RecLock("SUA",.F.) 
			Replace SUA->UA_OPER   WITH "2"	   
			Replace SUA->UA_STATUS WITH "SUP"
			Replace SUA->UA_EMISNF WITH Ctod(" ")
			Replace SUA->UA_SERIE  WITH SPACE(TamSx3("UA_SERIE")[1])
			Replace SUA->UA_DOC    WITH SPACE(TamSx3("UA_DOC")[1])
			SUA->( MsUnlock() )
		EndIF
	Endif
EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Lj140CnFin    ³ Autor ³ Vendas Clientes       ³ Data ³ 24.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Cancela venda no financeiro                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Lj140CnFin( aChave, lCrdxInt, aRetCrd, aChaveSL1, lReserva )

Local aParc        	:= {}							                //Parcelas
Local cChaveSE1    	:= ""							                //Chave para SE1
Local cChvSemPar    := ""							                //Chave para SE1 sem a parcela
Local lDelSE5      	:= .F. 						                	//Variavel que verificara se o SE5 foi excluido                               
Local lCancelouCRD	:= .F.                                          //Indica se o contrato ja foi cancelado
Local lTroco		:= .F.						                    //Troco Ativo ?
Local lAmbOffLn		:= SuperGetMv("MV_LJOFFLN", Nil, .F.)			//Identifica se o ambiente esta operando em offline
Local cMV_LJPGTRO	:= AllTrim(SuperGetMV("MV_LJPGTRO",NIL, ""))	//Formas de pagamento que permitem troco
Local lFinProp		:= .F.						                    //Adm. com Financiamento proprio
Local aSE1Found		:= {}	                                        //[1]-indica se achou o registro na SE1 [2]-indica se a Filial esta compartilhada
Local lIntegHtl		:= SuperGetMv("MV_INTHTL",, .F.) .And. ( SL1->L1_ORIGEM == "N" .Or. Lj140GtInD() )
Local aTitExc		:= {} 						
Local cCodCli 		:= ""
Local cCodLoj 		:= ""

If Substr(SL1->L1_CONFVEN,6,1) <> "N"
	
	aSE1Found := LJ140Seek( "SE1", 1, aChave, "E1_FILORIG" )

	If aSE1Found[1]
		
		If cPaisLoc <> "BRA"
			lTroco := SuperGetMV("MV_LJTRLOC")  //Rotina de Troco localizada ativa
		Else
			lTroco := SuperGetMV("MV_LJTROCO") .AND. IIF( Empty(cMV_LJPGTRO) .OR. (AllTrim(SE1->E1_TIPO) $ cMV_LJPGTRO), .T., .F. )
		EndIf
		
		//Seta o índice da tabela SAE para que nao seja feito dentro do While
		SAE->( DbSetOrder(1) )	//AE_FILIAL + AE_COD

		While SE1->(!Eof()) .AND. aChave[1] == SE1->E1_FILIAL .AND. aChave[2] == SE1->E1_PREFIXO .AND. aChave[3] == SE1->E1_NUM

			If aSE1Found[2]
				aSE1Found[1] := SE1->E1_FILORIG == CFILANT
			EndIf
			
			If aSE1Found[1]
				
				// Se a origem for pelo financeiro, nao efetua a exclusao do titulo		
				If SubStr(SE1->E1_ORIGEM,1,3) $ "FIN" .OR. SE1->E1_TIPO $ "NCC/RA"
					SE1->( DbSkip() )
					Loop									
				EndIf

				//Tratamento Hotelaria 		
				If lIntegHtl
				
					If !AllTrim(SE1->E1_TIPO) $ MVABATIM //Nao trata titulos de abatimento de impostos											
						If IsMoney(AllTrim(SE1->E1_TIPO)) .And. ExistFunc("Lj140ExRAComp") 
							LjGravaLog(.F., SL1->L1_DOC, "Lj140CnFin -01) antes da funcao Lj140ExRAComp") 
							Lj140ExRAComp() //Cancela compensacao dos RAs	
							LjGravaLog(.F., SL1->L1_DOC, "Lj140CnFin -02) depois da funcao Lj140ExRAComp") 
						EndIf
						
						If ExistFunc("Lj140CancRat")
							LjGravaLog(.F., SL1->L1_DOC, "Lj140CnFin -03) antes da funcao Lj140CancRat") 													
							Lj140CancRat() //Cancela rateio
							LjGravaLog(.F., SL1->L1_DOC, "Lj140CnFin -04) depois da funcao Lj140CancRat") 
						EndIf																				
					EndIf
				EndIf

				//---
				// É necessario armazenar as parcelas para o tratamento do SE5
				//---
				AAdd( aParc,{SE1->E1_PARCELA,SE1->E1_TIPO} )

				If lTroco  //Rotina de Troco está ativa
					
					cChaveSE1	:= ""
					lFinProp	:= .F.

					//Exclusão de troco para CC e CD quando financiamento proprio = "N"
					If SL1->L1_CLIENTE + SL1->L1_LOJA <> SE1->E1_CLIENTE + SE1->E1_LOJA
						If SAE->(DbSeek(xFilial("SAE") + SubStr(SE1->E1_CLIENTE,1,3))) .And. SAE->AE_FINPRO == "N"
							lFinProp := .T.
						EndIf
					EndIf 

					//-----------------------------------------------
					//Tratamento de exclusao de troco em dinheiro
					//-----------------------------------------------
					cChaveSE1   := SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + Space( Len(SE5->E5_TIPO) )
                    cChvSemPar  := SE1->E1_PREFIXO + SE1->E1_NUM + Space( Len(SE5->E5_PARCELA) ) + Space( Len(SE5->E5_TIPO) )
					If lFinProp
						cCodCli := SL1->L1_CLIENTE
						cCodLoj := SL1->L1_LOJA
					Else
						cCodCli := SE1->E1_CLIENTE
						cCodLoj := SE1->E1_LOJA
					EndIf

					//Excluir os registros de troco correspondentes
					Lj140ExTr(cChaveSE1, @lDelSE5, Nil, cCodCli, cCodLoj, cChvSemPar)
				EndIf
			
				If cPaisLoc == "BRA"
					//------------------------------------------------------------------------------------------------
					//|    Excluir os registros de movimentação bancaria - Integridade Referencial                   |
					//------------------------------------------------------------------------------------------------
					lj140ExBan(@lDelSE5)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//|    Excluir registro do Contas a Pagar (quando houver Taxas)                                      |
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					Lj140CnCP(.T., aChaveSL1)
				EndIf 
			
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Exclui registro do contas a pagar (Quando usar o conceito ³
				//³ de gerar contas a receber com valor bruto e contas a      ³
				//³ pagar com a taxa adminstrativa. parametro MV_LJGERTX = .T.³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SuperGetMV("MV_LJGERTX",,.F.)				
					Lj140ExCap()	
				Endif
			
				If lCrdxInt .AND. !lCancelouCRD .AND. SE1->(ColumnPos("E1_NUMCRD")) > 0
					If !Empty(SE1->E1_NUMCRD)
						aRetCrd      := aClone(CrdxVenda( "3"  ,{"",""}  ,SE1->E1_NUMCRD  ,.F.  ,;
						NIL  ,NIL ))
						lCancelouCRD := .T.
					EndIf
				EndIf
	
				If oIntCVenda <> Nil
					oIntCVenda:Inserir("SE1", xFilial("SE1") + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO, "1", "5")
					oIntCVenda:Gerar()
				EndIf
				
				//Adiciona a tabela para exclusao no processo off-line
				If lAmbOffLn
					oProcOff:Inserir("SE1", xFilial("SE1") + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO, 1, "DELETE")
				Endif

				aTitExc := {}
				//chama execauto do fina040 para excluir
				aAdd( aTitExc, {"E1_PREFIXO", SE1->E1_PREFIXO 	, Nil} )
				aAdd( aTitExc, {"E1_NUM"	, SE1->E1_NUM		, Nil} )
				aAdd( aTitExc, {"E1_PARCELA", SE1->E1_PARCELA	, Nil} )
				aAdd( aTitExc, {"E1_TIPO"	, SE1->E1_TIPO		, Nil} )
				
				MSExecAuto({|x,y| FINA040(x,y) },aTitExc,5)				
				

			EndIf
		
			SE1->( dbSkip() )
		End
	
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//|    Excluir registro do Contas a Pagar (quando houver Taxas)                                       |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cPaisLoc == "BRA"
			Lj140CnCP(.F., aChaveSL1)
		EndIf	

	EndIf
    
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se for Dinheiro, nao tiver reserva e SE5 nao estiver sido excluido acima³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	LjGrvLog( , " Verificacao antes de deletar SE5 pela Lj140ExDin -> lReserva", lReserva )
    If !lReserva
	   Lj140ExDin(lDelSE5, aChave, aParc)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Realiza a exclusao do SE1 apos o SE5 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Lj140CnSE5(aChave)
	
EndIf

Return .T.

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} Lj140ExTr
Excluir os registros de troco correspondentes.

@type       Function
@author     Varejo
@since      24/11/2006
@version    11

@param cChaveSE1, Caractere, Chave para busca do registro na tabela SE5.
@param lDelSE5, Lógico, Parâmetro de referência para indicar que o SE5 foi excluido.
@param cSEQ, Caractere, Sequencia referente ao movimento da SE5 que deseja considerar.
@param cCodCli, Caractere, Código do Cliente.
@param cCodLoj, Caractere, Código da loja do Cliente.

@return lRet, Lógico, Retorna se excluiu o movimento de Troco com sucesso (.T.) ou não (.F.)
/*/
//-------------------------------------------------------------------------------------
Static Function Lj140ExTr(cChaveSE1, lDelSE5, cSEQ, cCodCli, cCodLoj, cChvSemPar)
                    
Local aAreaAtu 		:= GetArea()
Local aAreaSE5 		:= GetArea("SE5")  
Local lAmbOffLn		:= SuperGetMv("MV_LJOFFLN", Nil, .F.)	        //Identifica se o ambiente esta operando em offline
Local lNewGrvTC 	:= ExistFunc("LjNewGrvTC") .And. LjNewGrvTC() 	//Verifica se o sistema está atualizado para executar o novo procedimento para gravação dos movimentos de troco.
Local cMsgErro 		:= ""
Local lRet 	   		:= .T.
Local lAchouSE5		:= .F.
Local nTamE1Cli		:= TamSx3("E1_CLIENTE")[1]
Local nTamE1Loj		:= TamSx3("E1_LOJA")[1]

Default cSEQ 		:= StrZero(1,TamSX3("E5_SEQ")[1])
Default cCodCli 	:= Space(nTamE1Cli)
Default cCodLoj 	:= Space(nTamE1Loj)
Default cChvSemPar  := ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//|   Excluir os registros de troco correspondentes                                                 |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SE5")
SE5->( DbSetOrder(7) ) //E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ
If !( lAchouSE5 := SE5->( DbSeek(xFilial("SE5") + cChaveSE1 + cCodCli + cCodLoj ) ) )

    //Tenta localizar sem a parcela
    If !Empty(cChvSemPar)
        lAchouSE5 := SE5->( DbSeek(xFilial("SE5") + cChvSemPar + cCodCli + cCodLoj ) )

        If lAchouSE5
            cChaveSE1 := cChvSemPar
        EndIf
    EndIf
	
	//Se o sistema estiver atualizado com o novo tratamento de gravacao do troco, o troco não é mais gravado com informações do codigo do cliente e loja (os campos ficam em branco)
	If lNewGrvTC .And. !lAchouSE5
		//Faz a busca considerando o codigo do cliente e loja em branco
		cCodCli := Space(nTamE1Cli)
		cCodLoj := Space(nTamE1Loj)
		lAchouSE5 := SE5->( DbSeek(xFilial("SE5") + cChaveSE1 + cCodCli + cCodLoj) )

        //Tenta localizar sem a parcela
        If !lAchouSE5 .And. !Empty(cChvSemPar)
            lAchouSE5 := SE5->( DbSeek(xFilial("SE5") + cChvSemPar + cCodCli + cCodLoj ) )

            If lAchouSE5
                cChaveSE1 := cChvSemPar
            EndIf
        EndIf
	EndIf
EndIf

If lAchouSE5
	cChaveSE1 := cChaveSE1 + cCodCli + cCodLoj
	While SE5->(!Eof()) .AND. xFilial("SE5") == SE5->E5_FILIAL .AND.;
		cChaveSE1 == SE5->E5_PREFIXO + SE5->E5_NUMERO + SE5->E5_PARCELA + SE5->E5_TIPO + SE5->E5_CLIFOR + SE5->E5_LOJA
		
		If SE5->E5_MOEDA <> "TC" .OR. SE5->E5_TIPODOC <> "VL" .OR.;
			SE5->E5_RECPAG <> "P" .OR. SE5->E5_SEQ <> cSEQ
			SE5->( DbSkip() )

			Loop
		EndIf

		If lNewGrvTC
			lRet := LjTrocoExc(SE5->(Recno()), 5, @cMsgErro )
			If !lRet
				Help(" ", "1", cMsgErro)
				If InTransaction()
					Disarmtransaction() //Desfaz a transação
					Break //Executa o Break, para que o fluxo seja desviado para depois do próximo comando END TRANSACTION
				EndIf
			EndIf
			lDelSE5:= .T.
		Else

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se for dinheiro devera atualizar o Saldo Bancario³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ								
			If IsMoney(AllTrim(SE1->E1_TIPO)) 		
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza saldo do BANCO Caixa ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				AtuSalBco(SE5->E5_BANCO, SE5->E5_AGENCIA, SE5->E5_CONTA, dDataBase, SE5->E5_VALOR, "-")
				lDelSE5:= .T.
			EndIf	                                  

			If oIntCVenda <> Nil
				oIntCVenda:Inserir("SE5", xFilial("SE5") + SE5->E5_NATUREZ + SE5->E5_PREFIXO + SE5->E5_NUMERO + SE5->E5_PARCELA + SE5->E5_TIPO + DTOS(dDatabase), "4", "5")
				oIntCVenda:Gerar()		   	
			EndIf
			
			//Adiciona a tabela para exclusao no processo off-line
			If lAmbOffLn .And. (oProcOff <> Nil)
				oProcOff:Inserir("SE5", xFilial("SE5") + SE5->E5_NATUREZ + SE5->E5_PREFIXO + SE5->E5_NUMERO + SE5->E5_PARCELA + SE5->E5_TIPO + DTOS(dDatabase), 4, "DELETE")
			Endif

			RecLock("SE5",.F.)
			SE5->( DbDelete() )
			SE5->( MsUnlock() )		
		EndIf
		SE5->( DbSkip() )
	End
EndIf

RestArea(aAreaSE5)
RestArea(aAreaAtu)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³lj140ExBan    ³ Autor ³ Vendas Clientes       ³ Data ³ 24.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Excluir os registros de movimentação bancaria                   ³±±
±±³          ³ Integridade Referencial                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function lj140ExBan(lDelSE5)

Local aE5Docum 	:= {}   // Array com os numeros do SE5 das NCC que deverão ser excluidas
Local nI 		:= 0	// Contador de For 
Local nTamChave := (TamSx3("E5_PREFIXO")[1]) + (TamSx3("E5_NUMERO")[1]) + (TamSx3("E5_PARCELA")[1]) + (TamSx3("E5_TIPO")[1]) // 16
Local cChvSe5	:= Space(nTamChave)  
Local lAmbOffLn	:= SuperGetMv("MV_LJOFFLN", Nil, .F.)	//Identifica se o ambiente esta operando em offline
Local lTemEst	:= .F. //Variável que verifica se a movimentação já tem estorno
Local aRecSE5	:= {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//|    Excluir os registros de movimentação bancaria - Integridade Referencial                   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

cChaveSE1 := SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO+SE1->E1_CLIENTE+SE1->E1_LOJA

DbSelectArea("SE5")
DbSetOrder(7) // E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ                                                                                      
If DbSeek(xFilial("SE5")+cChaveSE1)
	While !Eof() .AND. xFilial("SE5") == SE5->E5_FILIAL .AND. ;
		cChaveSE1 == 	SE5->E5_PREFIXO	+ SE5->E5_NUMERO + SE5->E5_PARCELA + ;
						SE5->E5_TIPO  	+ SE5->E5_CLIFOR + SE5->E5_LOJA

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se a baixa estiver cancelada, ignora a movimentação para evitar erro no execauto³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SE5->E5_SITUACA == "C" .OR. !Empty(SE5->E5_DTCANBX) .OR. SE5->E5_TIPODOC == "ES"
			lTemEst := .T.
			SE5->( DbSkip() )
			Loop
		Endif
						
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se for dinheiro devera atualizar o Saldo Bancario antes de excluir o registro do SE5³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ					
		If IsMoney(AllTrim(SE1->E1_TIPO))
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza saldo do BANCO Caixa ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			//Saldo atualizado automaticamente pela ExecAuto
			//AtuSalBco(SE5->E5_BANCO, SE5->E5_AGENCIA, SE5->E5_CONTA, dDataBase, SE5->E5_VALOR, "-")
			lDelSE5:= .T.
        EndIf

		If oIntCVenda <> Nil
			oIntCVenda:Inserir("SE5", xFilial("SE5") + SE5->E5_NATUREZ + SE5->E5_PREFIXO + SE5->E5_NUMERO + SE5->E5_PARCELA + SE5->E5_TIPO + DTOS(dDatabase), "4", "5")
			oIntCVenda:Gerar()
		EndIf

		//Adiciona a tabela para exclusao no processo off-line
		If lAmbOffLn
			oProcOff:Inserir("SE5", xFilial("SE5") + SE5->E5_NATUREZ + SE5->E5_PREFIXO + SE5->E5_NUMERO + SE5->E5_PARCELA + SE5->E5_TIPO + DTOS(dDatabase), 4, "DELETE")
		Endif
		SE5->( MsUnlock() )

		If !Empty(SE5->E5_DOCUMEN) .AND. "CR" $ SE5->E5_TIPO         // Somente adiciona os CR que foram usados para comp as NCCs
			aAdd(aE5Docum,{ SubStr(SE5->E5_DOCUMEN,1,nTamChave),SE5->E5_DATA, SE5->E5_VALOR } )
		EndIf
       
		aAdd(aRecSE5,{SE5->(RECNO())})
			
		SE5->( DbSkip() )
	End
EndIf

If !lTemEst
	For nI := 1 to Len(aRecSE5)	

		LjExclE5(aRecSE5[nI][1])

	Next
Endif

// Se for Vale Presente faz o estorno da utilização
If AllTrim( SE1->E1_TIPO ) == "VP"
	LjGrvLog( SE1->E1_NUM + SE1->E1_PREFIXO + SE1->E1_PARCELA, "lj140ExBan | Estorno do Vale Presente", SE1->E1_NUMCART )
	STDEstorVP( AllTrim( SE1->E1_NUMCART ) , SE1->E1_VALOR )  
EndIf

//Tratamento para Troco de NCC:
If Len(aE5Docum) > 0 .And. SuperGetMV("MV_LJCPNCC",,1) == 4
	cChvSe5 := SE1->E1_PREFIXO+SE1->E1_NUM
	SE5->(DbSetOrder(7))
	If SE5->(DbSeek(xFilial("SE5")+cChvSe5))
		While SE5->(!Eof()) .AND. xFilial("SE5") == SE5->E5_FILIAL .AND. cChvSe5 == SE5->E5_PREFIXO+SE5->E5_NUMERO
							
			If SE5->E5_MOEDA <> "TC" .OR. SE5->E5_TIPODOC <> "VL" .OR. SE5->E5_RECPAG <> "P"
				SE5->(DbSkip())
				Loop
			EndIf

			SE5->(RecLock("SE5",.F.))
			SE5->( DbDelete() )
			//Adiciona a tabela para exclusao no processo off-line
			If lAmbOffLn .And. (oProcOff <> Nil)
				oProcOff:Inserir("SE5", xFilial("SE5") + SE5->E5_NATUREZ + SE5->E5_PREFIXO + SE5->E5_NUMERO + SE5->E5_PARCELA + SE5->E5_TIPO + DTOS(dDatabase), 4, "DELETE")
			Endif
			SE5->( MsUnlock() )
			SE5->( DbSkip() )
		End
	EndIf
EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Lj140CnCP     ³ Autor ³ Vendas Clientes       ³ Data ³ 24.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Excluir registro do Contas a Pagar (quando houver Taxa de ISS) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Lj140CnCP(lAchouSE1, aChaveSL1)

Local nI			:= 0
Local aRetSE2		:= {} //Array dos Títulos
Local cChaveSF6		:= "" // Chave do Título
Local aAreaSE2 		:= {} //WorkArea SE2

//Localiza os títulos a serem excluídos mais as chaves
aRetSE2 := Lj140RtCp(@cChaveSF6, lAchouSE1, aChaveSL1)

If !Empty(cChaveSF6)
	SF6->( DbSetOrder(3) )	//F6_FILIAL + F6_OPERNF + F6_TIPODOC + F6_DOC + F6_SERIE + F6_CLIFOR + F6_LOJA
	If SF6->( DbSeek(cChaveSF6) )
	
		While SF6->(!EoF()) .AND. ;
			SF6->(F6_FILIAL + F6_OPERNF + F6_TIPODOC + F6_DOC + F6_SERIE + F6_CLIFOR + F6_LOJA) == ;
			cChaveSF6
			//Exclui Complemento da Guia 
			CDC->(dbSetOrder(2)) //CDC_FILIAL+CDC_GUIA+CDC_UF
			If CDC->(dbSeek(xFilial("CDC") + SF6->F6_NUMERO + SF6->F6_EST))
                While CDC->(!EoF()) .And.;
                    CDC->CDC_FILIAL + CDC->CDC_GUIA + CDC->CDC_UF == xFilial("CDC") + SF6->F6_NUMERO + SF6->F6_EST
                    
                    If RecLock("CDC", .F.)
                        CDC->(dbDelete())
                        CDC->(MsUnlock())
                    Else
                        LjGrvLog(Nil, "Não foi possível alocar o registro da CDC", CDC->(Recno()))
                    EndIf
                         
                    CDC->(dbSkip())
                EndDo 
			EndIf		
			If RecLock("SF6", .F.)
				SF6->( DbDelete() )
				SF6->( MsUnlock() )
			Else
				LjGrvLog(Nil, "Não foi possível alocar o registro da SF6", SF6->(Recno()))
			EndIf
			
			SF6->( DbSkip() )
		End
	EndIf

	SF6->( DbCloseArea() )
EndIf

aAreaSE2 := SE2->(GetArea())
For nI := 1 to Len( aRetSE2 )
	SE2->(DbGoTo(aRetSE2[nI, 1]))
	If RecLock("SE2",.F.)
		SE2->( DbDelete() )
		SE2->( MsUnlock() )
	Else
		LjGrvLog( Nil, "Não foi possível alocar o registro da SE2", SE2->(Recno()) )
	EndIf			
Next
RestArea(aAreaSE2)

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³lj140ExDin    ³ Autor ³ Vendas Clientes       ³ Data ³ 24.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Se for Dinheiro e SE5 nao estiver sido excluido acima          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function LJ140ExDin(lDelSE5, aChave, aParc)

Local nI		:= 0								// Contador de For
Local lAmbOffLn := SuperGetMv("MV_LJOFFLN", Nil, .F.)	//Identifica se o ambiente esta operando em offline
Local aAreaSE5	:= {}								// Guarda area

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se for Dinheiro e SE5 nao estiver sido excluido acima³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
If SL1->L1_DINHEIR <> 0 .AND. !lDelSE5
	DbSelectArea("SE5")
	SE5->( DbSetOrder(2) )	//E5_FILIAL, E5_TIPODOC, E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_DATA, E5_CLIFOR, E5_LOJA, E5_SEQ
	If cPaisLoc == "BRA"
		If SE5->( DbSeek(xFilial() + "LJ" + aChave[2] + aChave[3] + Space(TamSX3("E5_PARCELA")[1]) + SuperGetMv("MV_SIMB1") + " ") )

			If oIntCVenda <> Nil
                aAreaSE5 := SE5->(GetArea())
				oIntCVenda:Inserir("SE5", xFilial("SE5") + SE5->E5_NATUREZ + SE5->E5_PREFIXO + SE5->E5_NUMERO + SE5->E5_PARCELA + SE5->E5_TIPO + DTOS(dDatabase), "4", "5")
				oIntCVenda:Gerar()
				RestArea(aAreaSE5)
			EndIf

			//Adiciona a tabela para exclusao no processo off-line
			If lAmbOffLn
				oProcOff:Inserir("SE5", xFilial("SE5") + SE5->E5_NATUREZ + SE5->E5_PREFIXO + SE5->E5_NUMERO + SE5->E5_PARCELA + SE5->E5_TIPO + DTOS(dDatabase), 4, "DELETE")
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza saldo do BANCO Caixa ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			AtuSalBco(SE5->E5_BANCO, SE5->E5_AGENCIA, SE5->E5_CONTA, dDataBase, SE5->E5_VALOR, "-")
			
			RecLock("SE5",.F.,.T.)
			SE5->( dbDelete() )
			SE5->( MsUnlock() )
			
		EndIf
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//|Devido ao tratamento de multi-moeda uma venda pode gerar mais de um registro em Mov. Bancario p/ dinheiro|
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nI := 1 To Len(aParc)
			If SE5->( DbSeek(xFilial() + "LJ" + aChave[2] + aChave[3] + aParc[nI,1] + aParc[nI,2]) )
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza saldo do BANCO Caixa ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				AtuSalBco(SE5->E5_BANCO,SE5->E5_AGENCIA,SE5->E5_CONTA,dDataBase,SE5->E5_VALOR,"-")

				If oIntCVenda <> Nil
					oIntCVenda:Inserir("SE5", xFilial("SE5") + SE5->E5_NATUREZ + SE5->E5_PREFIXO + SE5->E5_NUMERO + SE5->E5_PARCELA + SE5->E5_TIPO + DTOS(dDatabase), "4", "5")
					oIntCVenda:Gerar()
				EndIf

				//Adiciona a tabela para exclusao no processo off-line
				If lAmbOffLn
					oProcOff:Inserir("SE5", xFilial("SE5") + SE5->E5_NATUREZ + SE5->E5_PREFIXO + SE5->E5_NUMERO + SE5->E5_PARCELA + SE5->E5_TIPO + DTOS(dDatabase), 4, "DELETE")
				Endif

				RecLock("SE5",.F.,.T.)
				SE5->( dbDelete() )				
				SE5->( MsUnlock() )
			EndIf
		Next nI
	EndIf
	DbSetOrder(1)
EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Lj140CnSE5    ³ Autor ³ Vendas Clientes       ³ Data ³ 24.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Realiza a exclusao do SE1 apos o SE5                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Lj140CnSE5(aChave)

Local aSE1Found := {}	//[1]-indica se achou o registro na SE1 [2]-indica se a Filial esta compartilhada
Local lMvLjVfNfs:= SuperGetMv("MV_LJVFNFS",,.F.) //Verifica se a nota de simples faturamento esta ativa

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Realiza a exclusao do SE1 apos o SE5 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lMvLjVfNfs .AND. Len(aChave) > 1 .AND. Empty(aChave[2])
	aChave[2] := PadR(SuperGetMv("MV_LJVFSER",,""),TamSx3("E1_PREFIXO")[1])
EndIf

aSE1Found := LJ140Seek( "SE1", 1, aChave, "E1_FILORIG" )

If aSE1Found[1]
	While SE1->(!Eof()) .AND. SE1->E1_FILIAL == aChave[1] .AND. SE1->E1_PREFIXO == aChave[2] .AND. SE1->E1_NUM == aChave[3]
		If aSE1Found[2]
			aSE1Found[1] := SE1->E1_FILORIG == CFILANT
		EndIf

		If aSE1Found[1]
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se a origem for pelo financeiro, nao efetua a exclusao do titulo    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If "FIN" $ SE1->E1_ORIGEM .OR. SE1->E1_TIPO $ "NCC/RA"
				SE1->( DbSkip() )
				Loop
			EndIf
	
			If oIntCVenda <> Nil
				oIntCVenda:Inserir("SE1", xFilial("SE1") + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO, "1", "5")
				oIntCVenda:Gerar()
			EndIf

			Reclock("SE1",.F.)
			SE1->( dbDelete() )
			SE1->( MSUnlock() )
		EndIf

		SE1->( DbSkip() )
	End
EndIf

Return .T.

/*/{Protheus.doc} Lj140CnTEF
Cancela caso o tef Esteja Ok
@type  Static Function
@author Vendas Clientes
@since 24.11.06
/*/
Static Function Lj140CnTEF(lTefOk	, lJob		, lVendTef	, aChave	,;
						   cNumNota	, cSerNota	, cCliNota	, cCliLoja	,;
						   cDescMot	, lAchouSF2	, lExisteFT	, lNfCup	,;	
						   aItensSD2, cNumNfCup	, cSerNfCup	, nTamDoc	,;
						   lCrdxInt	, aRetCrd	, lGeraNCC	, aItensSF2	,;
						   aItensSD2, cNumNFDev	, cSerieDev	, cMotivo	,;
						   cNum 	, aRetCartao, aCartaoSL4, aChaveSL1 ,;
						   cProtoNfce, lValido)
						   
Local nI		 	:= 0							// Contador de For
Local nVlrOrc	 	:= 0							// Valor original do orcamento com o desconto sobre os itens aplicado
Local nTamL1_DOC	:= TamSx3("L1_DOC")[1]		    // Tamanho Nota Fiscal
Local cPadrao		:= "701"                       	// Codigo Padrao
Local cPadraoIt		:= "705"						// Codigo Padrao Item
Local lPadrao  		:= VerPadrao(cPadrao)			// verifica padrao
Local lPadraoIt		:= VerPadrao(cPadraoIt)			// verifica padrao Item
Local nHdlPrv  		:= 0							// Contabilizacao
Local nTotal   		:= 0							// Contabilizacao
Local cArquivo 		:= ""							// Contabilizacao
Local lAglutina 	:= .T.							// Contabilizacao
Local lMVLJPRDSV   	:= SuperGetMv("MV_LJPRDSV",.F.,.F.)					// Verifica se esta ativa a implementacao de venda com itens de "produto" e itens de "servico" em Notas Separadas
Local lDelNfRPS   	:= .T.
Local lFisLivro		:= (SuperGetMV("MV_LJLVFIS",,1) == 2)	            //Utiliza novo conceito para geracao do SF3
Local aDocRps		:= {} 									            //Array para controlar as NFS's geradas
Local aSl2Area		:= {}									            //Variavel para guardar a area da SL2
Local lIntegHtl		:= SuperGetMv("MV_INTHTL",, .F.) .And. Lj140GtInD() //Integracao via Mensagem Unica - Hotelaria
Local cLote			:= LoteCont("LOJA")
Local cLoteCtb		:= ""
Local lReserva		:= .F.
Local aAreasTab		:= {}
Local cGerente   	:= ""												// Guarda o codigo do Gerente do Vendedor
Local lTemGerent 	:= .F.												// Guarda se o o Gerente recebe comissão
Local nRecVend		:= 0												// Guarda o recno do Vendedor da tabela SA3	
Local nRecnoSE3		:= 0												// Guarda o recno da comissão do Vendedor na tabela SE3
Local lIsNFeDen		:=	.F.												// Informa se é Nota Denegada
Local lTpComisOn  	:= SuperGETMV("MV_TPCOMIS") == "O"					//Define se a comissão será online ou offline

Default cProtoNfce := ""
					
cNumNota := PadR(cNumNota,nTamL1_DOC)

LjGetMDoc( , , , , @lIsNFeDen )

If (!lVendTef .AND. lValido) .OR. ( lVendTef .AND. lTefOk .AND. lValido)
	
	//--------------------------------------------------------------------------------------
	// Antes de Excluir Comissao - Verifica o Parametro de Geracao de Comissao - 19/12/95  |
	//--------------------------------------------------------------------------------------
	If Substr(SL1->L1_CONFVEN,11,1) <> "N" .AND. !lTpComisOn // Posicao do Parametro de Geracao de Comissao		
		DbSelectArea("SE3")   
		SE3->( DbSetOrder(1) )	
		If SE3->( DbSeek(xFilial("SE3")+ aChave[2] + aChave[3]) )			
			While SE3->(!Eof()) .AND. !Empty(SL1->L1_VEND) .AND.;
				aChave[2] == SE3->E3_PREFIXO .AND. aChave[3] == SE3->E3_NUM
				
				If !Empty( SE3->E3_DATA )
					If !lExcAuto
						Help( " ",1,"A140COMIS")
					Else 
						//"A Comissao referente a esta Nota ja foi PAGA, portanto ela nao sera excluida. As demais rotinas de exclusao desta Nota continuarao normalmente." 
						Conout(STR0108)  
					EndIf

					SE3->( dbSkip() )
					Loop
				EndIf

				cGerente   := ""
				lTemGerent := .F.				
				nRecVend := SA3->(Recno()) //Guarda o Recno da SA3 antes de verificar se o Vendedor tem Gerente

				// Verifica se o Vendedor tem configurado Gerente Comissionado
				DbSelectarea("SA3")
				DbSetOrder(1) // A3_FILIAL + A3_COD
				If DbSeek(xFilial("SA3") + AllTrim(SE3->E3_VEND))
					If !Empty(SA3->A3_GEREN) .AND. SA3->A3_COMIS > 0
						lTemGerent := .T.
						cGerente := SA3->A3_GEREN
					EndIf
					SA3->(DbGoTo(nRecVend))  //Volta para o Recno que estava posicionado
				Endif	

				//Se o Vendedor tiver configurado Gerente Comissiona, apaga a comissão do Gerente
				If lTemGerent
					nRecnoSE3 = SE3->(Recno())  //Guarda o Recno antes de alterar para o Recno do Gerente
					SE3->( DbSetOrder(2) )
					If SE3->( DbSeek(xFilial("SE3")+ cGerente + aChave[2] + aChave[3] ))
						RecLock("SE3",.F.,.T.)
						SE3->( dbDelete() )     
						SE3->( MSUnLock() )  
					EndIF
					SE3->( DbSetOrder(1) )
					SE3->(DbGoTo(nRecnoSE3))  //Retorna para o Recno do Vendedor
				EndIf 									

				//---
				//  Apaga as comissoes
				// Seguindo o padrao do modulo Financeiro, 
				//---
				RecLock("SE3",.F.,.T.)
				SE3->( dbDelete() )     
				SE3->( MSUnLock() )  
				SE3->( dbSkip() )
			End
		EndIf
	EndIf
	
	cNumNota := SL1->L1_DOC
	cSerNota := SL1->L1_SERIE
	cCliNota := SL1->L1_CLIENTE
	cCliLoja := SL1->L1_LOJA
	
	//Tratamento para cancelar multiplas NFS's(Nota Fiscal Serviço) geradas pela venda em questão 
	If SL1->( ColumnPos("L1_DOCRPS") ) > 0
		If lMVLJPRDSV .And. !Empty(SL1->L1_DOCRPS) .And. SL1->L1_DOC <> SL1->L1_DOCRPS
		
			aSl2Area	:= SL2->(GetArea())
			DbSelectArea("SL2")
			DbSetOrder(1)
			SL2->( DbSeek( xFilial("SL2")+ SL1->L1_NUM ) )
			
			While SL2->(!Eof()) .AND. xFilial("SL2") + SL2->L2_NUM == SL2->L2_FILIAL + SL1->L1_NUM
				
				If !Empty(SL2->L2_CODISS) .And. (aScan( aDocRps,{|x| Alltrim(x[3]) == Alltrim(SL2->L2_CODISS)}) == 0)		
					
					aAdd(aDocRps, {SL2->L2_DOC, SL2->L2_SERIE, SL2->L2_CODISS })
				EndIf	
				SL2->(dbSkip())
			EndDo
			RestArea(aSl2Area)
		EndIf
	EndIf
	
	While .T.
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza‡„o dos Arquivos do Faturamento ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Pontos de Entrada  						³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistTemplate("LJ140DEL")
			ExecTemplate("LJ140DEL",.F.,.F., {lJob})
		EndIf
		
		If ExistBlock("LJ140DEL")
			LjGrvLog(cNumNota, " Antes da Execução do PE LJ140DEL")
			ExecBlock("LJ140DEL",.F.,.F.)
			LjGrvLog(cNumNota, " Depois da Execução do PE LJ140DEL")
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza o saldo do cliente                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		Lj140AtuSald( aChave )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Executa o cancelamento da NF/CF pelo modo antigo,³
		//³caso o parametro MV_LJLVFIS esteja como 1        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lFisLivro .AND. !lIsNFeDen
			Lj140CancSF3(@cSerNota, 	@cNumNota, 		@cCliNota, 		@cCliLoja, ;
			             @cDescMot, 	@lAchouSF2, 	@lExisteFT)
		EndIf
							 		
		If oIntCVenda <> Nil
			
			DbSelectArea("SF2")
			DbSetOrder(1)
			
			If DbSeek(xFilial("SF2")+cNumNota+cSerNota)
				oIntCVenda:Inserir("SF2", xFilial("SF2") + SF2->F2_DOC + SF2->F2_SERIE + SF2->F2_CLIENTE + SF2->F2_LOJA, "1", "5")
				oIntCVenda:Gerar()
			EndIf		
		EndIf
		
		If lPadrao .AND. cPaisLoc == "MEX"
			
			nHdlPrv:=HeadProva("","LOJA140",Substr(cUsername,1,6),@cArquivo)
				
			If  nHdlPrv > 0
				nTotal+=DetProva(nHdlPrv,cPadrao,"LOJA140","")
			EndIf
						
			If  nTotal > 0
				RodaProva(nHdlPrv,nTotal)
				cA100Incl(cArquivo,nHdlPrv,3,"",.F.,lAglutina)
			EndIf
				
		EndIf
		
		//Contabilizacao hotelaria
		If lIntegHtl
			If lPadrao .Or. lPadraoIt
				SF2->(dbSetOrder(1)) //F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA+F2_FORMUL+F2_TIPO
												
				If SF2->(dbSeek(xFilial("SF2") + cNumNota + cSerNota + cCliNota + cCliLoja)) .And.;										
					!Empty(SF2->F2_DTLANC) //Contabiliza exclusao somente se venda foi contabilizada					
					
					nHdlPrv := HeadProva(cLote,"LOJA140",Substr(cUsername,1,6),@cArquivo)										
					nTotal  := 0
					
					If lPadrao //LP 701																																		
						//Posiciona no cliente
						SA1->(dbSetOrder(1)) //A1_FILIAL+A1_COD+A1_LOJA
						SA1->(dbSeek(xFilial("SA1") + SF2->F2_CLIENTE + SF2->F2_LOJA))
						
						//Posiciona no primeiro item de venda
						SD2->(dbSetOrder(3)) //D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA+D2_COD+D2_ITEM 
						SD2->(dbSeek(SF2->F2_FILIAL + SF2->F2_DOC + SF2->F2_SERIE + SF2->F2_CLIENTE + SF2->F2_LOJA))												
									
						If nHdlPrv > 0
							nTotal += DetProva(nHdlPrv, cPadrao, "LOJA140", cLoteCtb)
						EndIf																					
					EndIf										
					
					If lPadraoIt //LP 705																																																																	
						SD2->(dbSetOrder(3)) //D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA+D2_COD+D2_ITEM 
	
						If SD2->(dbSeek(SF2->F2_FILIAL + SF2->F2_DOC + SF2->F2_SERIE + SF2->F2_CLIENTE + SF2->F2_LOJA))																																											
							While SD2->(!EOF()) .AND. SD2->D2_FILIAL == SF2->F2_FILIAL .AND. SD2->D2_DOC == SF2->F2_DOC .AND.;
								SD2->D2_SERIE == SF2->F2_SERIE .AND. SD2->D2_CLIENTE == SF2->F2_CLIENTE .AND.; 
								SD2->D2_LOJA == SF2->F2_LOJA 				
								
								//Posiciona no cliente
								SA1->(dbSetOrder(1)) //A1_FILIAL+A1_COD+A1_LOJA
								SA1->(dbSeek(xFilial("SA1") + SF2->F2_CLIENTE + SF2->F2_LOJA))
								
								//Posiciona no produto
								SB1->(dbSetOrder(1)) //B1_FILIAL+B1_COD
								SB1->(dbSeek(xFilial("SB1") + SD2->D2_COD))
								
								If nHdlPrv > 0																			
									nTotal += DetProva(nHdlPrv, cPadraoIt, "LOJA140", cLoteCtb)																								
								EndIf														
																										
								SD2->(dbSkip())
							EndDo																																					
						EndIf																																		
					EndIf								
				
					If nTotal > 0						
						RodaProva(nHdlPrv, nTotal)
						cA100Incl(cArquivo, nHdlPrv, 3, cLoteCtb, .F., lAglutina)							
					EndIf
				EndIf
			EndIf
		EndIf
		
		If Lj140CnSD2(@cNumNota	,@cSerNota	,@lNfCup	,@aItensSD2	)
			Lj140CnSF2( @cNumNota	,@cSerNota	,@cNumNfCup	,@cSerNfCup	, ;
				 		@lNfCup		,@aItensSF2	,@nTamDoc	, cProtoNfce)					 
		EndIf
					 				
		If SL1->( ColumnPos("L1_DOCRPS") ) > 0
			If Len(aDocRps) > 0 .And. lMVLJPRDSV .And. Empty(cNumNota) .And. !Empty(SL1->L1_DOCRPS) .And. SL1->L1_DOC <> SL1->L1_DOCRPS .And. lDelNfRPS
				//após o aDel a linha fica como NIL no array
				
				cNumNota := aDocRps[1][1]
				cSerNota := aDocRps[1][2]
				aDel(aDocRps,1)			
				aSize(aDocRps,(Len(aDocRps)-1))
				
			EndIf
		EndIf
		If !Empty(cNumNota)
			Loop
		EndIf
		Exit
	End
	
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³Identifica se e orcamento com reserva, caso for não exclui SE5   ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If SL1->( ColumnPos("L1_RESERVA") ) > 0 .AND. ! Empty(GetAdvFVal( "SL1" , "L1_RESERVA" , XFILIAL("SL1") + cNum , 1 , "" , .T. ))
        lReserva := .T.
    EndIf
	
	Lj140CnFin( aChave, lCrdxInt, @aRetCrd, aChaveSL1, lReserva )
	
	If lIntegHtl .And. ExistFunc("Lj140ExcTro")
		LjGravaLog(.F., cNumNota, "Lj140CnTEF -03) antes da funcao Lj140ExcTro") 
		Lj140ExcTro() //Cancela baixas de troco hotelaria
		LjGravaLog(.F., cNumNota, "Lj140CnTEF -04) depois da funcao Lj140ExcTro")	 								
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se existe amarracao com lay-away e faz a reabertura se necessario³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPaisLoc $ "EUA|POR|MEX"
		DbSelectArea("SL2")
		DbSelectArea("SLP")
		
		Aadd(aAreasTab,SL2->(GetArea()))
		Aadd(aAreasTab,SLP->(GetArea()))
		
		SL2->(DbSetOrder(1))
		SL2->(DbSeek( xFilial("SL2")+SL1->L1_NUM ))
		
		SLP->(DbSetOrder(4))
		
		While xFilial("SL2")+SL1->L1_NUM == SL2->L2_FILIAL+SL2->L2_NUM
			If SLP->(DbSeek(xFilial("SLP")+SL2->L2_NUM+SL2->L2_ITEM))
				a800AbreLW(SL2->L2_NUM,SL2->L2_ITEM)
			EndIf
			SL2->(dbSkip())
		End
		
		For nI := 1 to Len(aAreasTab)
			RestArea(aAreasTab[nI])
		Next nI
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Gerar Nota de Credito ao Cliente - Loc. Guatemala                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPaisLoc == "GUA" .AND. lGeraNCC
		For nI := 1 to Len(aItensSF2)
			Lj140GeraNCC(aItensSF2, aItensSD2, nI, cNumNFDev, ;
						 cSerieDev, cMotivo)
		Next nI
	EndIf

	Lj140LpSl2(cNum, @nVlrOrc)
	Lj140LpSL1(lCrdxInt, cNum, nVlrOrc)
	Lj140LpSL4(cNum)
	
	SEF->(DbSetOrder(1))
	SE1->(DbSetOrder(1))
	dbCommitAll()
	                 
	If ExistBlock("LOJA140")
		LjGrvLog(cNumNota," Antes da Execução do PE LOJA140 ")
		ExecBlock("LOJA140",.F.,.F.)
		LjGrvLog(cNumNota," Depois da Execução do PE LOJA140")
	EndIf
Else
	If lVendTef 
		If !lJob
			Alert(STR0169) //"Transação TEF não foi cancelada e por isso a venda não foi cancelada. Realize o cancelamento novamente"		
		EndIf
		LjGrvLog( Nil, STR0169 )
	EndIf
EndIf

Return .T.

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³Lj140CnAdm    ³ Autor ³ Vendas Clientes       ³ Data ³ 24.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Cancela caso o tef na Adm                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                         ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Lj140CnAdm(lJob, lVendTef, oTEF, lTefOk, aRetCartao, aCartaoSL4, lTemTefMan)
Local cTipTef      	:= LjGetStation("LG_TIPTEF")		// Tipo do TEF selecionado no cadastro de estacao
Local aPagtoCart   	:= {}
Local aDocTef	   	:= {}
Local lContinua    	:= .T.
Local nInd		   	:= 0
Local cNSUTef	   	:= ""
Local cDOCTef	   	:= ""
Local cTpCanc	   	:= ""
Local cMsgCanc	   	:= ""
Local dDtTef		:= Nil
Local nPosPgCart 	:= 0
Local lIsTEFMan 	:= .F.
Local lTemSitef		:= .F.
Local cAdmFinan		:= ""
Local cFormaPgto 	:= ""
Local nVlrTrans		:= 0
Local cTEFDocCan	:= ""
Local cTEFDtCanc	:= ""
Local cTEFHrCanc	:= ""
Local dDtCancTef	:= StoD(FwTimeUF(SM0->M0_ESTENT,,SuperGetMv("MV_HVERAO",.F.,.F.))[1])

Default aRetCartao := {}
Default aCartaoSL4 := {}
Default lTemTefMan := .F.

/*  Se usar o Tef ira excluir a venda na administradora antes  */
/*
	Segundo a software express (12/04/2016):"Precisa verificar o numero do documento que é impresso no cupom Tef,
	geralmente a Rede utiliza o NSU Host (L4_DOCTEF) e a Cielo o NSU Sitef (L4_NSUTEF)."
	
	Portanto mando as duas numerações para serem tratadas 
*/
If !lJob .AND. lVendTef
	
	If cTipTef $ TEF_SEMCLIENT_DEDICADO + ";" + TEF_COMCLIENT_DEDICADO + ";" + TEF_DISCADO
		LjGrvLog(Nil, "Cancelamento TEF Discado antes de executar a funcao LOJA010T")	
		lTefOk := LOJA010T( "X" )
		LjGrvLog(Nil, "Cancelamento TEF Discado apos executar a funcao LOJA010T - lTefOk:", lTefOk)		
	EndIf
	
	If (cTipTef $ TEF_CLISITEF + ";" + TEF_NAO_USADO)

		If cTipTef == TEF_CLISITEF .AND.  ValType(oTEF) <> "O" 
			LjGrvLog(Nil, "Cancelamento TEF - Objeto oTEF nao inicializado.", cTipTef)	
			lContinua	:= .F.
			lTefOk		:= .F.
		Else
			aPagtoCart	:= Lj140Cart() //Verifica a qtde de cartoes utilizados no pagamento da venda		
			LjGrvLog("aPagtoCart", "Foram encontradas " + cValToChar(Len(aPagtoCart)) + " transacoes TEF para serem canceladas", aPagtoCart)
			nInd		:= 1
			lContinua	:= .T.
			
			If Len(aPagtoCart) == 0
				LjGrvLog(Nil,"Informações da venda com cartão não encontradas")
				cMsgCanc	:= "Esta venda já possui o TEF cancelado nas tabelas de pagamento. Verifique os campos L4_DOCCANC/L4_HORCANC/L4_DATCANC"
				MsgInfo(cMsgCanc,STR0086) 
				lTefOk		:= .F.
				lContinua	:= .F.
			EndIf
		EndIf

		While lContinua
		    nPosPgCart 	:= 0
			cTEFDocCan	:= ""
			cTEFDtCanc	:= ""
			cTEFHrCanc	:= ""
		    lIsTEFMan	:= IIf(Len(aPagtoCart[nInd])>= 9,Empty(aPagtoCart[nInd][9]), .T.)   //Verifica se a transacao TEF da venda foi realizada Manualmente (atraves do POS)
		    nVlrTrans	:= aPagtoCart[nInd][2]
		    cFormaPgto 	:= aPagtoCart[nInd][4]
		    cAdmFinan	:= aPagtoCart[nInd][5]
			
			If cFormaPgto == "CC"
				cTpCanc := "CANCEL_CREDITO"
			ElseIf cFormaPgto == "CD"
				cTpCanc := "CANCEL_DEBITO"
			Else
				cTpCanc := "CANCEL_VENDA"
			EndIf
			
			If lIsTEFMan
				cMsgCanc := STR0086 +CHR(10)+Chr(13)+CHR(10)+Chr(13)+ STR0188 +CHR(10)+Chr(13)+CHR(10)+Chr(13) //"Atenção"###"Foi realizada transação manualmente via equipamento POS. Favor cancelar manualmente a transação."
			Else
				cMsgCanc := STR0150 +CHR(10)+Chr(13)+CHR(10)+Chr(13) //"Transação TEF a ser cancelada:"
			EndIf
			cMsgCanc += "- " + STR0151 + ": " + cAdmFinan 						+Chr(13)	//"Administradora Financeira"
			cMsgCanc += "- " + STR0152 + ": " + cFormaPgto						+Chr(13)	//"Forma de Pagamento" STR0152
			cMsgCanc += "- " + STR0153 + ": " + AllTrim(Str(nVlrTrans,12,2)) 				//"Valor" STR0153
			
			LjGrvLog(Nil, cMsgCanc )
			MsgInfo(cMsgCanc)
			
			If lIsTEFMan
				nPosPgCart 	:= nInd
				lTefOk 		:= .T. //Para transacao TEF Manual feita na venda, seta TEF OK como .T., pois deve ser cancelado manualmente
				lTemTefMan	:= .T.
			Elseif (cTipTef $ TEF_NAO_USADO)
				lContinua	:= .F.
				lTefOk		:= .F.
			Else 

				LjGrvLog(Nil, "- Operação de Cancelamento TEF -> Tipo de Cancelamento :'" + cTpCanc + "' / Dados:", aPagtoCart[nInd])
				oTEF:Operacoes(cTpCanc, {} , , , , , , , , , ,aPagtoCart[nInd])
				lTefOk := oTef:lTefOk
				LjGrvLog(Nil, "- Cancelamento TEF <- lTefOk : ", lTefOk)
				lTemSitef := .T.
				
				If lTefOk
					//Primeiro procura pelo Numero do NSU
					nPosPgCart := Ascan( aPagtoCart, {|x| x[6] == AllTrim(oTef:aRetCartao[1]:cDocCanRei)} )
					//Se nao achou, entao tenta procurar pelo Numero do DOCTEF
					If nPosPgCart == 0
						nPosPgCart := Ascan( aPagtoCart, {|x| x[1] == AllTrim(oTef:aRetCartao[1]:cDocCanRei)} )
					EndIf
					
					If nPosPgCart == 0
						cMsgCanc :=	STR0154 +; //" Numero de Documento de Cancelamento para venda n? se refere aos n?ero(s) "
									STR0155 +; //" registrado(s) nos campos L4_DOCTEF e L4_NSUTEF da tabela SL4, portanto essa venda"
									STR0156 + CHR(10) + ; //" n? poder?ser cancelada."
									STR0157 + CHR(10) +; //" Dados da Operação TEF Cancelada : "
									STR0158 + AllTrim(oTef:aRetCartao[1]:cDocCanRei) //" Numero do Documento "
						MsgInfo(cMsgCanc,STR0086) //"ATENÇÃO"
						LjGrvLog(cMsgCanc)
						lContinua	:= .F.
						lTefOk		:= .F.
					Else

						If !Empty(oTef:aRetCartao[1]:dDataCanRei)
							dDtCancTef := oTef:aRetCartao[1]:dDataCanRei
						Else
							oTef:aRetCartao[1]:dDataCanRei := dDtCancTef
						EndIf
					
						/*Faz uma copia o array "oTef:aRetCartao" para utilizar as informacoes mais adiante, 
						pois o array "oTef:aRetCartao" sera limpado dentro do metodo "oTEF:ImpCupTef()" */
						aRetCartao := aClone(oTef:aRetCartao)
						
						If nModulo <> 12 .Or. !LjNfUsaTef(SM0->M0_CGC) //12=SIGALOJA
							oTEF:ImpCupTef()
						Else 
							oTEF:FinalTrn(1, .T.)  //Confirma transações pendentes
						EndIf
						
						// Aqui lTefOk eh forcado VERDADEIRO, pois a confirmacao ja foi enviada ao SITEF
						lTefOk := .T. 						
						
						cTEFDocCan	:= aRetCartao[1]:cDocCanRei
						cTEFDtCanc	:= StrTran(DToC(dDtCancTef),"/","")
						cTEFHrCanc	:= aRetCartao[1]:cHoraTrans
					EndIf
				Else
					lContinua := .F.
				EndIf
			EndIf
			
			If lContinua
				
				If lTefOk
					//Atualiza campos (L4_DOCCANC, L4_DATCANC, L4_HORCANC) com informacoes do cancelamento.
					dbSelectArea("SL4")
					SL4->(dbSetOrder(3)) 	//L4_FILIAL + L4_DATATEF + L4_NSUTEF
					
					SL4->( dbGoto( aPagtoCart[nPosPgCart][7]))
					dDtTef	:= SL4->L4_DATATEF
					cDOCTef := SL4->L4_DOCTEF
					cNSUTef := SL4->L4_NSUTEF
					
					If lIsTEFMan
						cTEFDocCan	:= SL4->L4_DOCTEF
						cTEFDtCanc	:= StrTran(DToC(dDataBase),"/","")
						cTEFHrCanc	:= SubStr(Time(), 1, 5)
					EndIf
														
 					While SL4->(!Eof()) .And. SL4->L4_DATATEF == dDtTef .And. (SL4->L4_DOCTEF == cDOCTef  .Or. SL4->L4_NSUTEF == cNSUTef)
						RecLock("SL4",.F.)
						Replace SL4->L4_DOCCANC with cTEFDocCan
						Replace SL4->L4_DATCANC with cTEFDtCanc
						Replace SL4->L4_HORCANC with cTEFHrCanc
						SL4->( MsUnLock() )
						
						If aScan( aDocTef,{|x| Alltrim(x[1]) == Alltrim(SL4->L4_DOCTEF)}) == 0 //Tratamento para mais de uma parcela do mesmo cartao. 
							aAdd( aDocTef , { SL4->L4_DOCTEF, SL4->(Recno()) } )							
							nInd += 1
					   	EndIf

						SL4->(dbSkip())
					EndDo
				Else
					MsgInfo(STR0159, STR0086) //#"Os dados referentes ao cancelamento do TEF não foram gravados na tabela SL4"
					LjGrvLog(Nil, "Cancelamento TEF - Dados da tabela SL4 não encontrada com venda cancelada na operadora")
				EndIf
				
					//				  RECNO da tabela SL4     , Doc. Canc., Data Canc.,  Hora Canc.
				aAdd( aCartaoSL4, { aPagtoCart[nPosPgCart][7], cTEFDocCan, cTEFDtCanc, cTEFHrCanc } )
				
				lContinua := Len(aDocTef) < Len(aPagtoCart)
			EndIf
			
		End
	EndIf

	If !Valtype(lTefOK) == "L"
		lTefOK := .F.
	EndIf
	
	If !lTefOk
		If IsInCallStack("Lj7CaUlCup") .OR. IsInCallStack("FR271FCancCup") .OR. !lExcAuto
	   		Help(" ",1,"TEFOK") 
	   	Else 
	   		//"O sistema nao conseguiu comunicacao com a Rede TEF, as alteracoes nao serao gravadas." 
			Conout(STR0109)
			LjGrvLog(Nil, STR0109)
	   	EndIf
	   	
		If cTipTef $ TEF_CLISITEF
			If lTemSitef
				oTef:FinalTrn(1)
			EndIf
		Else
			LOJA010T( "F", "N" )
		EndIf
		
	EndIf
EndIf

lCancTef := lTefOk /// Alimenta variavel Static para informar que o Cancelamento TEF foi efetuado.

Return lTefOk

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³Lj140VlVend   ³ Autor ³ Vendas Clientes       ³ Data ³ 24.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica se a venda pode ser cancelada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                         ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Lj140VlVend(lFiscal	, cNumCupFis, cNumPdvAtu	, cSerie	,;
					cAlias		, nOpcA		, lGeraNCC 		, lLj140Can	,;
					nTamL1Cup	, aOrcamento, lSubClosed	, lECCia	,;
					lForceExc   , lRecpVenda )  

Local cRet  	:= Space(10)	// Retorno utilizado status do cupom
Local nRet		:= 0			// Retorno do cupom
Local aAreaSL1	:= {}			// armazena a area do orcamento principal(orcamento pai) em caso de reservas
Local aAreaSF2	:= {}			// armazena a area do documento fiscal vinculado ao orcamento principal (orcamento pai)
Local nI		:= 1			// contador
Local cL1Doc	:= ""			// armazena o numero do cupom fiscal
Local cL1_SITUA := ""
Local lVendaFutura := SuperGetMv("MV_LJVFNFS",Nil, .F.) //Venda Futura {Nota de simples faturamento)
Local cModDoc	:= ""
Local lCentPDV  := IIf( ExistFunc("LjGetCPDV"), LjGetCPDV()[1] , .F. )  //Eh Central de PDV
Local lIntegDef := Lj140GtInD()                                         //Integracao via Mensagem Unica
Local nIndexOrd	:= 0													//DbSetOrder() de SL1

Default aOrcamento	:= {}
Default lSubClosed	:= .F. 
Default lECCia 		:= .F.
Default lForceExc	:= .F. 												//Forca Exclusão
Default lRecpVenda	:= .F. 												// Indica se foi chamado pela recuperação de venda

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tratamento para orcamentos com filho										³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty( SL1->L1_FILRES ) .AND. !Empty( SL1->L1_ORCRES ) .AND. !lForceExc
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//|  "Este orcamento não poderá ser excluido porque se trata de um orçamento com reserva."|
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lExcAuto
		MsgStop( STR0037 , STR0006 )
		Return .F.
	Else 
		Conout(STR0037)
		Return .F.
	EndIf	
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se foi chamada pela venda rapida³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If FunName()='LOJA220'

	If !lFiscal
		Return .F.
	EndIf

	nRet := IFStatus( nHdlECF, '5', @cRet )				// Verifica se o cupom está aberto
	If nRet == 7
		If !lExcAuto 
			MsgInfo( STR0024 )								//'Cupom nao foi finalizado'
			Return .F.
		Else 
			Conout( STR0024 )
			Return ( .F. )	
		EndIf	
	EndIf

	nRet := IFPegCupom( nHdlECF, @cNumCupFis)
	nRet := IFPegPDV( nHdlECF, @cNumPdvAtu )
	If Empty(cNumPdvatu) .OR. Empty(cNumCupFis)
		If !lExcAuto
	   		MsgInfo( STR0025 )								//'Erro de comunicacao com a impressora fiscal'
	   		Return .F.
	   	Else 
	   		Conout( STR0025 )
			Return ( .F. )
	   	EndIf	
	EndIf

	cNumCupFis := Repl('0',nTamL1Cup - Len( Alltrim( cNumCupFis ) ) ) + Alltrim( cNumCupFis )
	cSerie     := cSerie + Space( TamSX3("L1_SERIE")[1] - Len( cSerie ) )
	DbSelectArea("SL1")
	DbSetOrder(2)
	If !DbSeek( xFilial("SL1") + cSerie + cNumCupFis + cNumPdvAtu )
		If !lExcAuto 
			MsgInfo( STR0026 + cNumCupFis )					//Nao foi encontrado registro do cupom :
			Return .F.
		Else
			Conout( STR0026 + cNumCupFis )
			Return ( .F. )
		EndIf		
	EndIf

EndIf

If !lExcAuto
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ A ocorrencia 42 (ACS), verifica se o usu rio poder  ou n„o  ³
	//³ efetuar a exclusÆo da nota fiscal. 						    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !ChkPsw( 42 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Restaura a integridade da janela ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea(cAlias)
		Return .F.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Confere a configuracao do caixa, verificando se o mesmo     ³
	//³ possui permissao para o cancelamento do cupom.              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !FWIsAdmin() .AND. !LJProFile(8,,,,, .T. )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Restaura a integridade da janela ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea(cAlias)
		Return .F.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se Caixa esta Aberto  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lRecpVenda .AND. lFiscal .AND. !ljCxAberto()
		Return .F.
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³verifica se o orcamento possui algum Pedido de Venda e se ele esta faturado|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !LJ140VldPV(aOrcamento)
	Return .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³validacao: verifica se existem sub-orcamentos finalizados com cupons fiscais diferentes|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lSubClosed
	aAreaSL1 := SL1->( GetArea() )
	nIndexOrd := SL1->(IndexOrd())	//Guardo o IndexOrd()
	SL1->(DbSetOrder(1))

	For nI := 1 To Len(aOrcamento)

		If !Empty(aOrcamento[nI][1]) .AND. !Empty(aOrcamento[nI][2]) .AND. aOrcamento[nI][3] 	//verifica se eh um sub-orcamento finalizado
			If SL1->( DbSeek(aOrcamento[nI][1] + aOrcamento[nI][2]) ) 							//posiciona no sub-orcamento
				If Empty(cL1Doc)
					cL1Doc := AllTrim(SL1->L1_DOC)												//guardo o numero do cupom fiscal do sub-orcamento
					SL1->( RestArea(aAreaSL1) )
				ElseIf !Empty(SL1->L1_DOC) .AND. cL1Doc <> AllTrim(SL1->L1_DOC)  				//comparacao de cupons fiscais
					lRet := .F.
					MsgStop( STR0120, STR0006 )
					//"Nao e permitido excluir um orcamento aglutinador quando mais de um sub-orcamento estiver finalizado." | "Atencao"
					Exit
				Else				
					SL1->( RestArea(aAreaSL1) )
				EndIf
			Else
				lRet := .F.
				MsgStop(STR0119 + AllTrim(aOrcamento[nI][2]), STR0006)
				//"Nao foi possivel localizar o sub-orcamento:" | "Atencao"
				Exit
			EndIf
		EndIf
	Next
	SL1->(DbSetOrder(nIndexOrd))
EndIf

nOpcA := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se tiver algum sub-orcamento finalizado, deve-se posicionar nele para que seja feitas as validacoes|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lSubClosed
	aAreaSL1 := SL1->( GetArea() )
	aAreaSF2 := SF2->( GetArea() )
	If !Lj140Pos(aOrcamento)
		Return .F.
	EndIf
EndIf

cModDoc := LjGetMDoc(aOrcamento, Nil, Nil, @cL1_SITUA)
If IsBlind() .AND. cModDoc $ "55|65" 
	If cL1_SITUA == "X0"
		LJ140DocE( aOrcamento )
		Return .F.
	EndIf
EndIf

//---
// Verifica se a data da nota é menor que a database, caso seja, deve-se fazer a devolucao da nota
//---
If !Empty(SL1->L1_DOC) .AND. !lIsVendaVP .AND. !lIsVdRecCP .AND. !lCentPDV .AND. !lIntegDef
	If GetNewPar("MV_LJRMBAC", .F.) //Verifica integracao RM ativa
		//Na Integracao com RM, nao gera SF2, por isso verifica se o SL1 da venda ja foi processada pelo Job LJISENDEAI
		If AllTrim(SL1->L1_SITUA) == "RX"
			//#"Cancelamento não poderá ser realizado." #"Processo de Integração (Job LJISENDEAI) não foi realizado para essa venda."
			conout( (STR0125 + STR0200 + " - DOC: " + SL1->L1_DOC) )
			Help( ,, "NO140CANC",, STR0125 + STR0200 + " - DOC: " + SL1->L1_DOC, 1, 0 )
			Return .F.
		EndIf
	Else
		SF2->( DbSetOrder(1) )
		If SF2->( DbSeek( xFilial("SF2") + SL1->L1_DOC + SL1->L1_SERIE ) )
			If !lExcAuto .AND. (SF2->F2_EMISSAO) < (dDataBase) .AND. Alltrim(SF2->F2_ECF) == "S" .AND. nModulo <> 5 .AND. FunName() <> "STBORCCANCEL"
				//"Esta nota fiscal nao pode ser excluida. A data de emissao da nota fiscal nao pode ser menor que a database." 
				Help(" ", 1, "LJ140EXC", Nil, STR0110)
				Return .F.
			EndIf
		Else
			//Avisa quando venda nao foi processada no GrvBatch
			If AllTrim(SL1->L1_SITUA) == "RX"
				//#"Cancelamento não poderá ser realizado." #"Processo de Integração ERP(Job GravaBatch) não foi realizado para essa venda."
				conout( (STR0125 + STR0126) )
				Help( ,, "NO140CANC",, STR0125 + STR0126, 1, 0 )
			Else
				//"Nao foi possivel localizar a NF(SF2) (FILIAL|DOC|SERIE), portanto a venda não poderá ser excluida"
				Help( ,, "NO140CANC",, STR0123 + SL1->(L1_FILIAL+"|"+L1_DOC+"|"+L1_SERIE), 1, 0 )			
				LjGrvLog( SL1->L1_NUM, STR0123, SL1->(L1_FILIAL+"|"+L1_DOC+"|"+L1_SERIE) )
			EndIf
			Return .F.
		EndIf
	EndIf
ElseIf cPaisLoc == "GUA" .AND. lGeraNCC
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//|    "Aten‡„o"###"Nao e permitido gerar Nota de Credito para cancelamento de orcamento."###"OK"           |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lExcAuto
		Aviso(STR0006, STR0071, {STR0048} )
		Return .F.
	Else 
		Conout( STR0071 )
		Return ( .F. )
	EndIf	
EndIf

If Empty(SL1->L1_NUM)	// Verifica se Nao ‚ Devolucao
	If !lExcAuto
		Help(" ",1,"NFDEVOL")
		Return .F.
	Else
		//"Este registro refere-se a devolucao de produtos para fornecedores, portanto somente podera ser excluido na rotina de Devolucao de Compras."
		Conout(STR0111)
		Return ( .F. )
	EndIf		
Else
	If !lIsVendaVP .And. !lIsVdRecCP .and. !lIntegDef
		If !Empty(SL1->L1_DOC) .And. AllTrim(SF2->F2_ECF) == "S"
			If Month( SF2->F2_EMISSAO ) <> Month( dDataBase ) .OR. Year( SF2->F2_EMISSAO ) <> Year( dDataBase )
				If !lExcAuto
					Help(" ",1,"FORA_MES")
					Return .F.
				Else
					//"Nao se pode excluir uma nota fiscal quando o mes ou ano de sua emissao for diferente da database do sistema."  
					Conout(STR0112+" ("+STR0047+SF2->F2_SERIE+STR0128+SF2->F2_DOC+")")
					Return ( .F. )
				EndIf	
			EndIf
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o caixa pode excluir a Nota Fiscal ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty( SL1->L1_DOC )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ponto de Entrada para n„o considerar tais condi‡oes³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lLj140Can
		If __cUserID <> "000000" 		 //Se Administrador, pode excluir a nota
			If xNumCaixa() <> SL1->L1_OPERADO
				If !ChkPsw(42)
					If !lExcAuto
						Help(" ",1,"OUTROCAIXA")
						Return .F.
					Else
						//"Esta operacao foi realizada por outro caixa, por isso so podera ser desfeita pelo caixa de origem, Administrador ou Usuario com autorizacao definida na senha." 
						Conout(STR0113)
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

If LjAnalisaLeg(6)[1]
	If SL1->(ColumnPos("L1_STORC")) > 0
		If SL1->L1_STORC == 'C' .AND. Alltrim(SL1->L1_SITUA) <> "OK"
			If !lExcAuto
				MsgStop(STR0085, STR0086) //"Este orçamento já foi Cancelado" ### "Atenção"
				Return(.F.)
			Else 
				Conout( STR0085 )
				Return( .F. )
			EndIf
		EndIf
	EndIf
EndIf

IF SL1->(ColumnPos("L1_STATUES")) > 0    //Estorno
   If !Empty(SL1->L1_STATUES)
	  If !lExcAuto
		  MsgStop(STR0097, STR0006) //"Esta venda já foi estornada." ### "Atenção"
		  Return.F.
	  	Else	
	      Conout( STR0097 )
	      Return( .F. )
	 	EndIf
   Endif
Endif

If cPaisLoc $ "MEX" .AND.  !Empty(SF2->F2_NFORI)
	MsgAlert(STR0090 , STR0086)			// #"Nao foi possivel Cancelar pois ja existe uma Fatura Global para esta venda!"	# "Atencion"
	Return .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Release 11.5 - Chile - F2CHI                                ³
//³Nao se cancela venda no Chile.Para qualquer venda que       ³
//³precise ser cancelada e necessario criar uma nota de credito³
//³atraves do processo de devolucao.                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPaisLoc == "CHI"
	If !Empty(SL1->L1_DOC) .AND. !Empty(SL1->L1_SERIE)
		MsgAlert(STR0099 , STR0086)// #"Cancelamento de venda não permitido.Você deve gerar uma nota de crédito através da rotina de Troca/Devolução."# "Atencion"	
		Return .F.
	EndIf
EndIf

//Verificação rferente a venda futura:
If lVendaFutura .AND. !lECCia
	If !Empty(SL1->L1_DOC) .And. !Empty(SL1->L1_DOCPED) .And. SL1->L1_DOC == SL1->L1_DOCPED
		MsgAlert(STR0129 , STR0086)// #Venda ja finalizada no PDV." # "Atencion"
		Return .F.
	EndIf
EndIf

If lECCia   
	If !Lj140VlEC()
		Return .F.
	EndIf
EndIf

//retorno a area do orcamento principal
If lSubClosed
	SL1->( RestArea(aAreaSL1) )
	SF2->( RestArea(aAreaSF2) )	
EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Lj140VlDev    ³ Autor ³ Vendas Clientes       ³ Data ³ 24.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica se a venda ja foi devolvida                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Lj140VlDev(lVendido, nCnt, aOrcamento, lSubClosed)
        
Local lRet		:= .T.	//variavel de retorno
Local aArea		:= {}	// armazena a area do orcamento principal(orcamento pai) em caso de reservas

Default lSubClosed	:= .F.
Default aOrcamento	:= {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se tiver algum sub-orcamento finalizado, deve-se posicionar nele para que sejao feitas as validacoes|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lSubClosed
	aArea := SL1->( GetArea() )
	If !Lj140Pos(aOrcamento)
		Return .F.
	EndIf
EndIf

If !Empty( SL1->L1_DOC ) .AND. lRet
	SD2->( dbSetOrder( 3 ) )
	SD2->( dbSeek( xFilial( "SD2" ) + SL1->L1_DOC + SL1->L1_SERIE ) )
	While SD2->(!EoF() .AND. SD2->D2_DOC == SL1->L1_DOC .AND. SD2->D2_SERIE == SL1->L1_SERIE )
		If SD2->D2_QTDEDEV > 0
			If !lExcAuto
				Help(" ","1","JATROCADO")
				lRet  := .F.
				Exit
			Else 
				//"Esta Nota Fiscal ja sofreu troca e nao pode mais ser excluida."
				LjGrvLog(SL1->L1_NUM, STR0114 + "FILIAL|DOC|SERIE", SL1->(L1_FILIAL + "|" + L1_DOC + "|" + L1_SERIE) )
				lRet := .F.
				Exit
			EndIf
		Endif

		SD2->( dbSkip() )
	End
EndIf
             
//retorno a area do orcamento principal
If lSubClosed
	SL1->( RestArea(aArea) )
EndIf

Return (lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Lj140VlImp    ³ Autor ³ Vendas Clientes       ³ Data ³ 24.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica se a venda foi cancelada na impressora atual          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA140                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Lj140VlImp( lVendido, cNumPdv	, lFiscal	, cNumPdvAtu,;
							cNumAnt	, nTamL1Cup	, aOrcamento, lSubClosed,;
							lLstPre )

Local iRet 			:= 0	//Retorno da impressora
Local cL1Numcfis	:= ""   //Recebe o Valor do L1_NUMCFIS
Local aArea			:= {}	//armazena a area do orcamento principal(orcamento pai) em caso de reservas
Local lLiberaCan 	:= .T. 	//Controla se Libera o cancelamento da venda
Local lEmitNfce		:= ExistFunc("LjEmitNFCe") .AND.  LjEmitNFCe() // Sinaliza se utiliza NFC-e   
Local lVendaNfce	:= .F. //Sinaliza venda com emissao de NFCe
Local nLenAnt		:= 0
Local lECCia 		:= SuperGetMv("MV_LJECOMO", .T., .F.)  .AND.  SL1->(ColumnPos("L1_ECFLAG") > 0) .AND. (SL1->L1_ECFLAG == "1")
Local lRet 			:= .T.  


Default aOrcamento 	:= {}
Default lSubClosed	:= .F.
Default lLstPre		:= .F.

//Sinaliza que venda emitiu NFC-e para nao validar venda via ECF 
lVendaNfce := IIF(lEmitNfce .AND. SL1->(ColumnPos("L1_KEYNFCE")) > 0 .AND. !Empty(SL1->L1_KEYNFCE), .T., .F.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se foi cupom fiscal e se ‚ a impressora que o emitiu ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty( SL1->L1_PDV ) .AND. lVendido .AND. FunName()<>'LOJA220' .AND. !lVendaNfce .And. !lIsVendaVP .And. !lIsVdRecCP .And. !lLstPre
	cNumPdv := SL1->L1_PDV

	If !lFiscal  .AND. !lECCia
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//|    Esta venda s¢ poder  ser exclu¡da pela impressora fiscal                                             |
		//|    que efetuou a mesma. Numero da impressora que registrou a venda:                                     |
		//|    Aten‡„o                                                                                              |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
		If FWIsAdmin()
			//
			lRet := MsgYesNo(	STR0163 + Chr(13) + ; 				//"Esta venda deve ser exclu?a na Impressora Fiscal (ECF) que realizou a mesma."
								STR0164 + cNumPdv + Chr(13) + ; 	//"Numero do PDV (L1_PDV) que realizou a venda:"
								STR0165 + cHR(13) + ;				//"Se o cancelamento n? tiver ocorrido na Impressora Fiscal(FI_CANCEL), impactar?nas entregas fiscais (SPEDFISCAL)"
								STR0166, STR0167) 					//"CONFIRMA CONTINUAR COM O CANCELAMENTO ?" ## //"ATENÇÃO - Acesso restrito para perfil Administrador" 
								
			LjGrvLog( SL1->L1_NUM, "Cancelamento da venda ECF na Retaguarda via usu?io administrador. Confirma?",lRet)
									 
		Else 	
			lRet := .F.	
			If !lExcAuto
				MsgStop( STR0004 + STR0005 + cNumPdv, STR0006 )
			Else 
				Conout( STR0004 + STR0005 + cNumPdv )
			EndIf	
		EndIf 
			
	Else
		
		cNumPdvAtu := Space(10)
		iRet := IFPegPDV( nHdlECF, @cNumPdvAtu )
		
		
		If AllTrim( cNumPdv ) <> AllTrim( cNumPdvAtu )	.AND. !lECCia		
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//|   Esta venda foi efetuada por outro caixa                                                               |
			//|   O PDV que efetuou a venda foi:                                                                        |
			//|   Aten‡„o                                                                                               |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lExcAuto 
		   		MsgStop( STR0007 + STR0008 + cNumPdv, STR0006 )
		   		Return .F.
		   	Else
		   		Conout ( STR0007 + STR0008 + cNumPdv )
				Return ( .F. )
			EndIf		
		EndIf

	EndIf
	
	If lFiscal
	
		cNumAnt := Space(10)
		If cPaisLoc == "ARG"
			If !lExcAuto
				Aviso( STR0047,STR0049,{ STR0048 } )	//"Atencao"###"Para cancelar um cupom fiscal gerar uma Nota de Credito."###"OK"
				Return .F.
			Else 
				Conout ( STR0049 )
			    Return ( .F. )
			EndIf	
		Else
			iRet := IFPegCupom( nHdlECF, @cNumAnt, "T" )
			nLenAnt	 := Len(AllTrim(cNumAnt))
			cNumAnt := StrZero(Val(cNumAnt),nTamL1Cup)
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se tiver algum sub-orcamento finalizado, deve-se posicionar nele para que seja feitas as validacoes|
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lSubClosed
			aArea := SL1->( GetArea() )
			If !Lj140Pos(aOrcamento)
				Return .F.
			EndIf
		EndIf

		cL1Numcfis  := StrZero(Val(SL1->L1_NUMCFIS),nTamL1Cup) 

		//Caso nao seja o ultimo cupom, verifica se eh uma venda apenas de "Servico" (RPS)
		If SL1->( ColumnPos("L1_DOCRPS") ) > 0
			If cL1Numcfis <> cNumAnt
				If !Empty(SL1->L1_DOCRPS) .And. SL1->L1_DOC+SL1->L1_SERIE == SL1->L1_DOCRPS+SL1->L1_SERRPS
					//Verifica se pode excluir
					lLiberaCan := Lj140LbRPS()
				EndIf
			EndIf
		EndIf
		
		//Valida se e' o ultimo cupom fiscal, antes de prosseguir com a exclusao
		If cL1Numcfis  <> cNumAnt  .AND. Lj140LibCanc() .And. !lLiberaCan .AND. FunName() <> "STBORCCANCEL" 
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//|   Por se tratar de impressora fiscal, s¢ poder  ser excluido o £ltimo                                   |
			//|   Cupom vendido. (Vide convˆnio ICMS - 156/96)                                                          |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SL1->(DbSetOrder(1))
			If !lExcAuto
				MsgStop( STR0009 + STR0010 )
				Return .F.
			Else 
				Conout ( STR0009 + STR0010 )
				Return ( .F. )
			EndIf	
		EndIf

		//retorno a area do orcamento principal
		If lSubClosed
			SL1->( RestArea(aArea) )
		EndIf

	EndIf
EndIf

Return .T.

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±º Programa ³ LJ110FillGetº Autor ³ Vendas Clientes   º Data ³ 09/01/2007 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º Desc.    ³ Montagem do aHeader e aCols pelo Protheus 9.                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³ Void LJ110FillGet(ExpN1,ExpC2)                              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ ExpN1 = Operacao                                    		   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ Nil                                                 		   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ LOJA110                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LJ140FillGet( nOpc )

Local cSeek		:= 	NIL								// Variavel de busca
Local cWhile	:= 	NIL								// Enquanto
Local aNoFields	:= {}								// Campos que não seram mostrados
Local bCond		:= {|| SL2->L2_STATUS <> "D" }		// Condicao para While
Local bAction1	:= {|| .T. }						// Condicao para While
Local bAction2	:= {|| .F. }						// Condicao para While
Local lInclusao	:= .T. 									// Se eh inclusao

If nOpc <> 3
	lInclusao := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se for inclusao, nao alimenta as variaveis³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lInclusao
	cSeek := xFilial("SL2") + SL1->L1_NUM
	cWhile := "SL2->L2_FILIAL + SL2->L2_NUM"
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Campo que não sera apresentado³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aAdd(aNoFields,"L2_NUM")
If cPaisLoc <> "BRA"
	aAdd(aNoFields,"L2_ICMSRET")
	aAdd(aNoFields,"L2_BRICMS")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Montagem aHeader, aCols³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aHeader) == 0 .AND. Len(aCols) == 0
	FillGetDados(	nOpc			,	"SL2"							,	1				,	cSeek			,;
					{|| &cWhile}	,	{{bCond,bAction1,bAction2}}		,	aNoFields		,	/*aYesFields*/	,; 
					/*lOnlyYes*/	,	/*cQuery*/						,	/*BuildAcols*/	, 	lInclusao 		,;
					/*aHeaderAux*/	,	/*aColsAux*/					,	/*bAfterCols*/	, 	/*bBeforCols*/ 	)
EndIf
 
Return Nil


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj140OrcOrigº Autor ³ Vendas Clientes  º Data ³  25/10/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna os dados do orcamento que originou o titulo no SE1  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Loja140                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Lj140OrcOrig()

Local aArea		:= GetArea()			// Armazena posicionamento atual
Local aAreaSL1	:= SL1->(GetArea())	// Armazena o posicionamento da tabela SL1
Local aDados	:= {}					// Array de retorno

DbSelectArea("SL1")
DbSetOrder(1)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Busca os dados para localizacao do titulo no orcamento³
//³original somente se os campos estiviverem preeenchidos³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty( SL1->L1_FILRES + SL1->L1_ORCRES )
	If DbSeek( SL1->L1_FILRES + SL1->L1_ORCRES )
	
		aDados	:=	{	SL1->L1_FILIAL	,;
						SL1->L1_CLIENTE	,;
						SL1->L1_LOJA	,;
						SL1->L1_SERPED	,;
						SL1->L1_DOCPED	}
	EndIf
EndIf

RestArea(aAreaSL1)
RestArea(aArea)

Return aDados

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LOJA140   ºAutor  ³Vendas Clientes     º Data ³  28/01/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Efetua o Cancelamento do Pedido de Venda gerado atraves da º±±
±±º          ³ rotina de Reservas / Entrega.                              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Loja140                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function LjCancPed(cFilRes, cPedVen)
Local aCabPed	:= {}					//Cabecalho do Pedido
Local aItensPed	:= {}					//Itens do Pedido
Local aLinhaPed	:= {}					//Itens do Pedido
Local cFilBkp	:= cFilAnt				//Guarda a Filial atual
Local lRet		:= .T.					//Variavel de Retorno da Funcao
Local lMvLjVfNfs:= SuperGetMv("MV_LJVFNFS",,.F.) //Verifica se a nota de simples faturamento esta ativa

DEFAULT	cFilRes	:= cFilAnt				//Atribui a Filial Atual
DEFAULT cPedVen	:= ""					//Pedido de Venda

PRIVATE lMsErroAuto	:= .F.				//Determina se houve algum tipo de erro durante a execucao do ExecAuto

If Empty(cPedVen)
	lRet := .F.
EndIf

If lRet
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Altera para a Filial do Pedido.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFilAnt	:= cFilRes

	DbSelectArea("SC5")
	DbSetOrder(1)	//Filial + Pedido
	If DbSeek(cFilRes + cPedVen)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Guarda o Cabecalho do Pedido³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Aadd(aCabPed,{ "C5_FILIAL",		SC5->C5_FILIAL			,NIL })
		Aadd(aCabPed,{ "C5_NUM",		SC5->C5_NUM				,NIL })

		If lMvLjVfNfs .AND. !(cFilBkp == cFilRes) .AND. !Empty(SC5->C5_NOTA) .AND. !Empty(SC5->C5_SERIE)
			Aadd(aNfSFat,{ cFilRes, SC5->C5_NOTA, SC5->C5_SERIE })
		EndIf

		//Caso esteja posicionado no pedido do simples faturamento, é preciso limpar os campos do SC9 
		//Esse procedimento é necessário para que seja feito o estorno corretamente
		If lMvLjVfNfs
			SC9->(DbSetOrder(1))	//Filial + Pedido
			If SC9->(DbSeek(SC5->C5_FILIAL + SC5->C5_NUM))
				If SC9->C9_BLCRED == "10" .And. SC9->C9_BLEST == "10"
					SC9->(RecLock("SC9",.F.))
					SC9->C9_BLCRED	:= "" 
					SC9->C9_BLEST	:= ""
					SC9->(MsUnLock())
				EndIf
			EndIf
		EndIf

		DbSelectArea("SC6")
		DbSetOrder(1)	//Filial + Pedido
		If DbSeek(SC5->C5_FILIAL + SC5->C5_NUM)

			While !SC6->(Eof()) .AND. SC5->C5_FILIAL + SC5->C5_NUM == SC6->C6_FILIAL + SC6->C6_NUM
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Estorno da Liberacao do Pedido de Venda.³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				MaAvalSC6(	NIL,		4,			NIL,		.F.,;
							.F.,		.F.,		.F.,		.F.,;
							.F.,		0,			NIL,		NIL,;
							NIL)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Guarda os Itens do Pedido   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Aadd(aLinhaPed,{ "C6_FILIAL",	SC6->C6_FILIAL	 				,NIL })
				Aadd(aLinhaPed,{ "C6_ITEM",		SC6->C6_ITEM					,NIL })
				Aadd(aLinhaPed,{ "C6_PRODUTO",	SC6->C6_PRODUTO		  			,NIL })
				Aadd(aItensPed, aLinhaPed)
				aLinhaPed := {}

				SC6->(DbSkip())
			End
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Apos o Estorno da Liberacao,³
	//³exclui o Pedido de Venda.   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea("SC5")
	DbSetOrder(1)	//Filial + Pedido
	If DbSeek(cFilRes + cPedVen)
		MSExecAuto( {|x,y,z| Mata410(x,y,z)} , aCabPed, aItensPed, 5)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se houveram erros durante a exclusao do Pedido.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lMsErroAuto
			lRet := !lMsErroAuto
		EndIf
		If lMsErroAuto
			DisarmTransaction()
			MostraErro()
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Restaura a Filial Original³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFilAnt	:= cFilBkp
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj7DefLeg ºAutor  ³Vendas Clientes     º Data ³  24/01/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Define as cores das Legendas                               º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ LOJA701                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Lj140DefLeg()

Local cFiltro	:= ""
Local aCores	:= {}
Local lLjPedVe	:= SuperGetMV("MV_LJPEDVE", NIL, .F.)
Local lPosPed	:= SL1->(ColumnPos("L1_PEDRES") ) > 0
Local lEmitNFCe	:= ExistFunc("LjEmitNFCe") .AND.  LjEmitNFCe()

If lEmitNFCe
	cFiltro := '( !Empty(L1_DOC) .AND. !Empty(L1_SERIE) .AND. L1_STORC <> "A" .AND. !(L1_SITUA $ "X0|X1|X2|X3") .AND. !(L1_STATUS $ "D|F") .AND. (ColumnPos("L1_STATUES")=0 .OR. Empty(L1_STATUES)) ) .OR. ( !Empty(L1_DOCPED) .AND. !Empty(L1_SERPED) )'
	Aadd( aCores, {cFiltro, "BR_VERMELHO"} )	//"Vendas efetuadas"
	
	cFiltro := '!Empty(L1_DOC) .AND. L1_TPORC == "E" .AND. L1_SITUA == "RX" .AND. L1_STORC == "A"'
	Aadd( aCores, {cFiltro, "BPMSEDT2"	} )		//"Cancelamento com processamento pendente"
Else
	cFiltro := '( !Empty(L1_DOC) .AND. !Empty(L1_SERIE) .AND. L1_STATUS <> "D" .AND. !(L1_SITUA $ "X0|X1|X2|X3") .AND. (ColumnPos("L1_STATUES")=0 .OR. Empty(L1_STATUES)) ) .OR.  ( !Empty(L1_DOCPED) .AND. !Empty(L1_SERPED) )'
	Aadd( aCores, {cFiltro, "BR_VERMELHO"})		// "Vendas efetuadas"
EndIf
	
cFiltro := '!Empty(L1_DOC) .AND. (L1_TPORC == "E" .OR. L1_IMPNF) .AND. L1_SITUA $ "X0|RY"'
	Aadd( aCores, {cFiltro, "BR_PRETO_0"} )		//"Cancelamento n? enviado ao TSS"
	
cFiltro := '!Empty(L1_DOC) .AND. (L1_TPORC == "E" .OR. L1_IMPNF) .AND. L1_SITUA == "X1"'
	Aadd( aCores, {cFiltro, "BR_PRETO_1"} )		//"Cancelamento aguardando autorização do SEFAZ"
	
cFiltro := '!Empty(L1_DOC) .AND. (L1_TPORC == "E" .OR. L1_IMPNF) .AND. L1_SITUA == "X2"'	
	Aadd( aCores, {cFiltro, "BR_PRETO_2"} )		//"Cancelamento autorizado pela SEFAZ"
	
cFiltro := '!Empty(L1_DOC) .AND. (L1_TPORC == "E" .OR. L1_IMPNF) .AND. L1_SITUA == "X3"'
	Aadd( aCores, {cFiltro, "BR_PRETO_3"} )		//"Cancelamento n? autorizado pela SEFAZ"

cFiltro := '!Empty(L1_DOC) .AND. !Empty(L1_SERIE) .AND. L1_STATUS == "T" .AND. (ColumnPos("L1_STATUES")=0 .OR. Empty(L1_STATUES))'
Aadd( aCores, {cFiltro, "BR_BRANCO"		} ) 	// "Transação TEF desfeita"

cFiltro := 'ColumnPos("L1_STATUES")>0 .AND. !Empty(L1_STATUES)'
Aadd( aCores, {cFiltro, "BPMSEDT1"		} )		// "Vendas estornadas" - estorno

cFiltro := 'Empty(L1_DOC) .AND. Empty(L1_RESERVA) .AND. DDATABASE <= L1_DTLIM .AND. L1_STATUS <> "D" .AND. IIf(ColumnPos("L1_STORC")>0, L1_STORC <> "C", .T.) .AND. ( ColumnPos("L1_STATUES")=0 .OR. Empty(L1_STATUES) ) .AND. ( Empty(L1_DOCPED) .AND. Empty(L1_SERPED) ) '
Aadd( aCores, {cFiltro, "BR_VERDE"		} )		// "Orçamentos em aberto"

If lLjPedVe .AND. lPosPed
	cFiltro := 'Empty(L1_DOC) .AND. !Empty(L1_RESERVA) .AND. Empty(L1_DOCPED) .AND. L1_STATUS <> "D" .AND. Empty(L1_PEDRES) .AND. (ColumnPos("L1_STATUES")=0 .OR. Empty(L1_STATUES))'
	Aadd( aCores, {cFiltro, "BR_AMARELO"} )		// "Orcamentos com reservas"
	
	cFiltro := 'Empty(L1_DOC) .AND. !Empty(L1_RESERVA) .AND. Empty(L1_DOCPED) .AND. L1_STATUS <> "D" .AND. !Empty(L1_PEDRES) .AND. (ColumnPos("L1_STATUES")=0 .OR. Empty(L1_STATUES))'
	Aadd( aCores, {cFiltro, "BR_LARANJA"} ) 	// "Orcamentos com Pedidos de Venda"
Else
	cFiltro := 'Empty(L1_DOC) .AND. !Empty(L1_RESERVA) .AND. Empty(L1_DOCPED) .AND. L1_STATUS <> "D" .AND. (ColumnPos("L1_STATUES")=0 .OR. Empty(L1_STATUES))'
	Aadd( aCores, {cFiltro, "BR_AMARELO"} ) 	// "Orcamentos com reservas"
EndIf

cFiltro := 'Empty(L1_DOC) .AND. L1_TIPO == "P" .AND. !Empty(L1_DOCPED) .AND. L1_STATUS <> "D" .AND. (ColumnPos("L1_STATUES")=0 .OR. Empty(L1_STATUES))'
Aadd( aCores, {cFiltro, "BR_AZUL"	} )		//"Pedidos encerrados"

cFiltro := 'Empty(L1_DOC) .AND.  Empty(L1_RESERVA) .AND. DDATABASE > L1_DTLIM .AND. L1_STATUS <> "D" .AND. (ColumnPos("L1_STATUES")=0 .OR. Empty(L1_STATUES))'
Aadd( aCores, {cFiltro, "BR_PRETO"	} )		//"Orcamentos em aberto vencidos"

cFiltro := 'L1_STATUS == "D" .AND. (ColumnPos("L1_STATUES")=0 .OR. Empty(L1_STATUES))'
Aadd( aCores, {cFiltro, "BR_MARROM"	} ) 	//"Devoluções pendentes"

cFiltro := 'Empty(L1_DOC) .AND. IIf(ColumnPos("L1_STORC")>0, L1_STORC == "C", .T.)'
Aadd( aCores, {cFiltro, "BR_CINZA"	} )		//"Orçamentos Cancelados"

Return aCores

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj140AtuSaldºAutor  ³ Vendas Clientes  º Data ³  16/07/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Atualiza o saldo do cliente.                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Loja140                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Lj140AtuSald( aChave )

Local lCartao := .T.	// Se utiliza cartao
Local aSE1Found := {}	//[1]-indica se achou o registro na SE1 [2]-indica se a Filial esta compartilhada

If Substr(SL1->L1_CONFVEN,6,1) <> "N"
	
	aSE1Found := LJ140Seek("SE1", 1, aChave, "E1_FILORIG")
	If aSE1Found[1]

		//Seta o índice da tabela SAE para que nao seja feito dentro do While
		SAE->( DbSetOrder(1) )	//AE_FILIAL + AE_COD

		While SE1->(!Eof()) .AND. aChave[1] == SE1->E1_FILIAL .AND. aChave[2] == SE1->E1_PREFIXO .AND. aChave[3] == SE1->E1_NUM
			
			If aSE1Found[2]
				aSE1Found[1] := SE1->E1_FILORIG == CFILANT
			EndIf

			If aSE1Found[1]
				lCartao := .F.
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Se a origem for pelo financeiro, nao efetua a exclusao do titulo    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If "FIN" $ SE1->E1_ORIGEM
					SE1->( DbSkip() )
					Loop
				EndIf
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//|    Se o título não for do cliente verifica se é de alguma administradora financeira,                    |
				//|    se for não roda a rotina de atualização do calso do cliente e pula para o próximo registro.          |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If (SL1->L1_CLIENTE + SL1->L1_LOJA) <> (SE1->E1_CLIENTE + SE1->E1_LOJA)
					If SAE->( DbSeek(xFilial("SAE") + SubStr(SE1->E1_CLIENTE,1,3)) )
						lCartao := .T.
					EndIf
				EndIf
	
				If !IsMoney(AllTrim(SE1->E1_TIPO)) .AND. !lCartao .AND. !(SuperGetMv("MV_CLIPAD") + SuperGetMv("MV_LOJAPAD") == SL1->L1_CLIENTE + SL1->L1_LOJA)
					SA1->( DbSetOrder(1) )	//A1_FILIAL + A1_COD
					SA1->( DbSeek(xFilial("SA1") + SL1->L1_CLIENTE + SL1->L1_LOJA) )
					AtuSaldup("-", SE1->E1_VALOR, SE1->E1_MOEDA, SE1->E1_TIPO, Nil, SE1->E1_EMISSAO)
				EndIf			
			EndIf

			SE1->( DbSkip() )
		End
	EndIf

EndIf

Return NIL

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj140IntegºAutor  ³Vendas Clientes     º Data ³  27/03/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Responsavel em enviar os dados do cancelamento a integracao º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³LOJA140                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Lj140Integ()
	
//Finaliza - Envia EAI
oIntCVenda:Finalizar()	

oIntCVenda := Nil

Return Nil

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³LjAdicInt   ³ Autor ³ Vendas Clientes       ³ Data ³ 28/07/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Buscar os itens cancelados da venda (SLX) para integracao   	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³LOJA140	                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Lj140AddIn()
	
Local aArea		:= {}							//Guarda a area atual
Local aAreaSLX 	:= {}							//Guarda a area do SLX
Local cChave 	:= ""							//Chave

aArea 		:= GetArea()
aAreaSLX 	:= SLX->(GetArea())	

//Itens cancelados na venda
cChave := xFilial("SLX") + SL1->L1_PDV + SL1->L1_DOC + SL1->L1_SERIE

DbSelectArea("SLX")

DbSetOrder(1)	//LX_FILIAL + LX_PDV + LX_CUPOM + LX_SERIE + LX_ITEM + LX_HORA

If DbSeek(cChave)
	
	While !Eof() .AND. (cChave) == (SLX->LX_FILIAL + SLX->LX_PDV + SLX->LX_CUPOM + SLX->LX_SERIE)
		If AllTrim(SLX->LX_TPCANC) == "I"
			oIntCVenda:Inserir("SLX", xFilial("SLX") + SLX->LX_PDV + SLX->LX_CUPOM + SLX->LX_SERIE + SLX->LX_ITEM + SLX->LX_HORA, "1", "3")		
		EndIf
		SLX->(DbSkip())
	End   	
EndIf

RestArea(aArea)	
RestArea(aAreaSLX)

Return(NIL)       


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj140EvIntºAutor  ³Vendas Clientes     º Data ³  27/03/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Responsavel em enviar os dados do cancelamento a integracao º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ LOJA140                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Lj140EvInt()
	                
	//Considera os registros deletados
	SET DELETED OFF
	
	//Processa os dados 
	oProcOff:Processar()	
	
	//Desconsidera os registros deletados
	SET DELETED ON
		
Return Nil


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj140LibCancºAutor  ³ Vendas Clientes  º Data ³  18/05/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Faz a liberacao do Cancelamento da venda Fiscal.            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Loja140                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/      

Static Function Lj140LibCanc()
Local lRet := .T.

If cPaisLoc == "MEX" .AND. DtoS(SL1->L1_EMISNF) == DtoS(dDataBase )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Pela Legislacao do Mexico pode-se cancelar qualquer cupom do mesmo dia   |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lRet := .F.	
EndIf
Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj140ExCap  º Autor ³ Vendas Clientes  º Data ³  20/04/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Exclui registro do contas a pagar (Quando usar o conceito   º±±
±±º          ³de gerar contas a receber com valor bruto e contas a        º±±
±±º          ³pagar com a taxa adminstrativa. parametro MV_LJGERTX = .T.  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³ Lj140ExCap()					                              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ Nil			                                    	      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ Nil                                                 	      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Loja140                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß 
*/
Function Lj140ExCap()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Excluir registro do Contas a Pagar    |
//| vinculado ao Contas a Receber         |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
DbSelectArea("SE2")
DbSetOrder(1) //E2_FILIAL+E2_PREFIXO
If DbSeek(xFilial("SE2")+SE1->E1_PREFIXO,.T.)
	While (!Eof() .AND. SE2->E2_PREFIXO == SE1->E1_PREFIXO)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Busca titulos em abertos relacionados atraves do campo ³
		//³historico(E2_HIST) com a mesma sequencia de parcela    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If AllTrim(SE2->E2_HIST) == AllTrim(SE1->E1_NUM) .AND. AllTrim(SE2->E2_PARCELA) == AllTrim(SE1->E1_PARCELA)   
			RecLock("SE2",.F.)
			DbDelete()
			MsUnlock()
		Endif			
		DbSkip()
	End 
EndIf

Return (Nil)  

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj140CHCarreºAutor  ³ Vendas Clientes  º Data ³  14/04/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Carrega o array aCheques	              				      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Loja140                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/      
Function Lj140CHCarrega(aChave	, aCheques	, lValeCompra	, lBaixaAut	,;
						lUsaFD	)
						
Local cCheq		   	:= ""	//Variavel que recebe parametro MV_CHEQUE ou MV_CHEQUES
Local cCondPag		:= ""	//Condicao de pagamento
Local aSE1Found 	:= {}	//[1]-indica se achou o registro na SE1 [2]-indica se a Filial esta compartilhada
Local lIntegDef     := Lj140GtInD()
Local lRet 			:= .T.
Local cMsgBorder	:= ""

Default aChave 		:= {}	// Chave para dbSeek na SE1
Default aCheques 	:= {}	// Array de cheques
Default lValeCompra := .F.	// Vale compra?                                       
Default lBaixaAut 	:= .F.	// Baixa automatica
Default lUsaFD		:= .F.	// Usa fidelizacao

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza‡„o de Contas a Receber e Saldo de Caixa			 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posicao de Geracao Titulo Financeiro³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Substr(SL1->L1_CONFVEN,6,1) <> "N"  

	cCondPag  := AllTrim(SL1->L1_CONDPG)
	If cPaisLoc <> "BRA" .AND. cCondPag <> "CN"
		SE4->(DbSetOrder(1))
		If SE4->(DbSeek(xFilial("SE4")+cCondPag))
			If SE4->(ColumnPos( "E4_BXTITAV" )) > 0
				lBaixaAut := SE4->E4_BXTITAV == "1"
			EndIf
		EndIf
	EndIf

	aSE1Found := Lj140Seek( "SE1", 1, aChave, "E1_FILORIG" )
	If aSE1Found[1]

		While SE1->(!Eof()) .AND. aChave[1] == SE1->E1_FILIAL .AND. aChave[2] == SE1->E1_PREFIXO .AND. aChave[3] == SE1->E1_NUM

			If aSE1Found[2]
				aSE1Found[1] := SE1->E1_FILORIG == CFILANT
			EndIf

			If aSE1Found[1] .AND. AllTrim(Upper(SE1->E1_ORIGEM)) $ "LOJA010/LOJA220/LOJA701/RPC/LOJA720/FATA701"
			  	
			  	lValeCompra := .F.
				If lUsaFD .AND. ALLTRIM(SE1->E1_TIPO) == "VA"
					lValeCompra := .T.
				EndIf

				If !Empty(SE1->E1_NUMBOR) .And. !Empty(SE1->E1_DATABOR)
					cMsgBorder += 	STR0180 + SE1->E1_PREFIXO 	+ " | " +; 		//"Prefixo: "
									STR0181 + SE1->E1_NUM		+ " | " +; 		//"Número: "
									STR0182 + SE1->E1_PARCELA + CHR(10)+Chr(13)	//"Parcela: "
				EndIf
				
				If Round(NoRound(SE1->E1_VALOR,3),2) <> Round(NoRound(SE1->E1_SALDO,3),2) .AND. !lIntegDef .AND. ;
					!IsMoney(AllTrim(SE1->E1_TIPO)) .AND. !lBaixaAut .AND. !(AllTrim(SE1->E1_TIPO) $ MVABATIM)
					If !( SL1->L1_CREDITO > 0 .and. (Alltrim(Upper(SE1->E1_TIPO)) $ "CR/NCC")) .AND. Alltrim(Upper(SE1->E1_TIPO)) <> "VP"//Pagamento nçao realizado em nota de Crédito     				
						If Alltrim(Upper(SE1->E1_TIPO)) $ "CR/NCC"
							If !lExcAuto
						  		MsgStop(STR0081)  // "Para esta nota utilize o processo de Troca/Devolução" 
						  	Else 
						  		Conout(STR0081)
						  	EndIf	
						Else
							If !lExcAuto
						   		Help(" ",1,"TITULOBAIXADO")
						    EndIf	
							LjGrvLog(SE1->E1_NUM,STR0190)// "Esta operação não é válida sobre um título baixado, Cancele a baixa do título."
						EndIf 
						Return .F.
					EndIf
				EndIf

				If Type('MVCHEQUES')=='C'
					cCheq := MVCHEQUES
				Else
					cCheq := MVCHEQUE
				EndIf
		
				If AllTrim(SE1->E1_TIPO) $ cCheq
					Aadd( aCheques , SE1->E1_PREFIXO+SE1->E1_NUM )
				EndIf
			EndIf
			SE1->( DbSkip() )		
		End
	EndIf
EndIf

If !Empty(cMsgBorder)
	cMsgBorder := STR0147 + " " + STR0148 + CHR(10)+Chr(13) + cMsgBorder //"Não é possível excluir a venda." ### "Existe Borderô para o(s) Título(s):"
	Conout(cMsgBorder)
	LjGrvLog(Nil,cMsgBorder)
	If !IsBlind()
		Aviso(STR0006, cMsgBorder, {"OK"}, 2) //"Atençäo" ### 
	EndIf
	lRet := .F.
EndIf

Return lRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj140CHDeposºAutor  ³ Vendas Clientes  º Data ³  14/04/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Verifica se os cheques foram depositado      				  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Loja140                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/      
Function Lj140CHDepositado(aCheques)
Local lRet := .T.    	// Retorno da funcao
Local nContador := 0	// Contator
Default aCheques := {}	// Array de cheques
                      
DbSelectArea("SEF")
SEF->( DbSetOrder(3) ) //EF_FILIAL + EF_PREFIXO + EF_TITULO + EF_PARCELA + EF_TIPO + EF_NUM + EF_SEQUENC
If Len(aCheques) > 0  
	If !Empty(SL1->L1_CHEQUES) .AND. DbSeek(xFilial("SL1")+aCheques[1])
		nContador := 1
		While !Eof() .AND. xFilial("SEF")==SEF->EF_FILIAL .AND. nContador <= Len(aCheques)
			If !Empty(SEF->EF_DEPOSIT)
			   	If !lExcAuto
			   		Help(" ",1,"CHEQUEMOV")
					Return ( .F. )
				Else
					//"Esta Nota Fiscal nao podera ser excluida pois foi paga por um cheque que ja foi depositado."
					Conout(STR0115)
					Return ( .F. )  
				EndIf	
			EndIf
			nContador++
			SEF->( DbSkip() )
		End
	EndIf
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj140CHDelReºAutor  ³ Vendas Clientes  º Data ³  14/04/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Rotina de deleção de cheques no cancelamento de vendas com º±±
±±º          ³ reserva      				  							  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Loja140                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj140CHDelReserva( aChaveCHRe )

Local aCheques		:= {}	// Array de cheques

Default aChaveCHRe	:= {}	// Chave de busca para deletar os cheques na venda com reserva

Lj140CHCarrega(aChaveCHRe, @aCheques)

If Len(aCheques) > 0
	If Lj140CHDepositado(@aCheques)
		Lj140CHSEFDel(@aCheques)
	EndIf
EndIf

Return Nil


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj140CHSEFDeºAutor  ³ Vendas Clientes  º Data ³  14/04/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Faz a deleção da SEF de acordo com o aCheques	              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Loja140                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/      
Function Lj140CHSEFDel(aCheques)
Local nContador	   	:= 0	// Contador
Local lAmbOffLn 	:= SuperGetMv("MV_LJOFFLN", Nil, .F.)	//Identifica se o ambiente esta operando em offline
Local lTemCheque 	:= SL1->L1_CHEQUES > 0
Local aAreaSL1 		:= {}

Default aCheques := {}		// Array de cheques

//Verifica se ha a necessidade de posicionar no orcamento pai para verificar o campo L1_CHEQUES
If !Empty(SL1->L1_ORCRES)
	aAreaSL1 := SL1->(GetArea())
	SL1->(DbSetOrder(1)) //L1_FILIAL + L1_NUM
	SL1->(DbSeek(SL1->L1_FILRES+SL1->L1_ORCRES))
	lTemCheque := SL1->L1_CHEQUES > 0
	RestArea(aAreaSL1)
EndIf

If Len(aCheques) > 0
	DbSelectArea("SEF")
	DbSetOrder(3)          		
	If (lTemCheque .OR. ProcName(1) == 'LJ140CHDELRESERVA') .AND. DbSeek(xFilial("SEF")+aCheques[1])
		nContador := 1
		While !Eof() .AND. xFilial("SEF")==SEF->EF_FILIAL .AND. nContador <= len(aCheques)
			If AllTrim(SEF->EF_CART) == "R"

				If oIntCVenda <> Nil
					oIntCVenda:Inserir("SEF", xFilial("SEF") + SEF->EF_BANCO + SEF->EF_AGENCIA + SEF->EF_CONTA + SEF->EF_NUM, "1", "5")
					oIntCVenda:Gerar()
				EndIf

				Reclock( "SEF",.F.,.T.)
				SEF->( dbDelete() )

				//Adiciona a tabela para exclusao no processo off-line
				If lAmbOffLn
					Conout("Cancelamento - oProcOff:Inserir SEF")
					oProcOff:Inserir("SEF", xFilial("SEF") + SEF->EF_BANCO + SEF->EF_AGENCIA + SEF->EF_CONTA + SEF->EF_NUM, 1, "DELETE")
				EndIf
				
				SEF->( MsUnlock() )
				SEF->( DbSkip() )
			EndIf
			nContador++
		End
	EndIf
EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj140Fill	 ºAutor  ³Vendas & CRM		 º Data ³  11/21/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Valida os itens do orcamento e alimenta o array aOrcam     º±±
±±º          ³ que contera os orcamentos que serao excluidos			  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Lj140Exc                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj140Fill(lSubClosed)

Local lRet		:= .T.													//verifica se o item ja foi devolvido
Local lAmbPaf	:= LjNfPafEcf(SM0->M0_CGC)								//verifica se esta em ambiente PAF-ECF
Local lPedido	:= .F.													//verifica se o orcamento possui pedido de venda amarrado
Local lIsOrcam	:= Empty(SL1->L1_DOC) .And. Empty(SL1->L1_RESERVA) .And. SL1->L1_STATUS <> "D" .And.;
			 		Iif(SL1->(ColumnPos("L1_STORC")) > 0, SL1->L1_STORC <> "C", .T.) .And. (ColumnPos("L1_STATUES") == 0 .Or. Empty(SL1->L1_STATUES))//Verifica se é orçamento
Local aArea		:= {}													//armazena a area do orcamento principal(orcamento pai) em caso de reservas
Local aOrcamento:= {}													//array com todos os orcamentos a serem excluidos
Local lUpd78Ok	:= IIf(ExistFunc("LjUpd78Ok"),LjUpd78Ok(),.F.)		//indica que o sistema está preparado para utilizar a Lista de Presentes
Local lLstPre 	:= .F.													//indica contem um item de Lista de Presente

Default lSubClosed	:= .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Criado a variavel lIsOrcam para especificar que eh apenas um orcamento nao  ³
//³ finalizado pois nao se pode contar somente com o campo L2_VENDIDO.			³
//³ Isto porque para quando existir venda com Retira e Reserva juntos, somente  ³
//³ eh preenchido L2_VENDIDO com "S" na Venda Filho faturado.  					³
//³ Jah quando ocorre importacao para o PDV como em caso de PAF-ECF, todos os 	³
//³ campos sao preenchido com "S" (Tanto Pai quanto Filhos).					³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

SL2->( DbSetOrder( 1 ) )
SL2->( DbSeek( xFilial( "SL2" ) + SL1->L1_NUM ) )

While !SL2->( Eof() ) .AND. xFilial("SL2") + SL2->L2_NUM == xFilial("SL1") + SL1->L1_NUM

	lPedido := (!Empty(SL2->L2_RESERVA) .AND. ( SL2->L2_ENTREGA == '1' .OR. SL2->L2_ENTREGA == '3' .OR. SL2->L2_ENTREGA == '4' )) .Or. ; //1=Retira Posterior; 3=Entrega; 4=Retira Posterior c/ Nota
		(!Empty(SL2->L2_FILRES) .AND. ( SL2->L2_ENTREGA == '5' )) //5=Entrega c/ Pedido s/ Reserva
	
	If lUpd78Ok .AND. !Empty(SL2->L2_CODLPRE)
		lLstPre := .T.
	EndIf

	If (  lAmbPaf .AND. SL2->L2_VENDIDO == "S" .AND. !lPedido ) .OR. ;
	   ( !lAmbPaf .AND. !lPedido .AND. !lIsOrcam .AND. IIf(SL2->(ColumnPos("L2_DOCPED")) > 0,Empty(SL2->L2_DOCPED),.T.) )

		//Verificamos se o orcamento em questao possui sub-orcamentos reservados (filhos)
		If lRet .AND. !Empty( SL2->L2_FILRES ) .AND. !Empty( SL2->L2_ORCRES )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se for Retira Posterior, posiciono no orcamento "filho" para verificar se o mesmo ja foi finalizado|
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SL2->L2_ENTREGA == "1"
				aArea := SL1->( GetArea() )
				If SL1->( DbSeek(SL2->L2_FILRES + SL2->L2_ORCRES) ) .AND. Empty(SL1->L1_DOC)
					//se nao foi finalizado, ele e adicionado como orcamento
					Aadd( aOrcamento, {SL2->L2_FILRES, SL2->L2_ORCRES, .F., lPedido, lLstPre} )
					SL1->( RestArea(aArea) )
					SL2->( DbSkip() )
					Loop    
				EndIf
				SL1->( RestArea(aArea) )
			EndIf
			
			lSubClosed := .T. //indica que algum sub-orcamento esta finalizado
		EndIf

		//Adicionamos o orcamento ao array aOrcamento, mesmo que os campos	|
		//	L2_FILRES e L2_ORCRES estejam vazios, ou seja, nao ha reservas	|
		If ( aScan(aOrcamento, {|x| x[1] + x[2] == SL2->L2_FILRES + SL2->L2_ORCRES}) ) == 0
			Aadd( aOrcamento, {SL2->L2_FILRES, SL2->L2_ORCRES, .T., lPedido, lLstPre} )
		EndIf

	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Adicionamos o orcamento ao array aOrcamento, mesmo que os campos	|
		//³	L2_FILRES e L2_ORCRES estejam vazios, ou seja, nao ha reservas	|
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( aScan(aOrcamento, {|x| x[1] + x[2] == SL2->L2_FILRES + SL2->L2_ORCRES}) ) == 0				
			Aadd( aOrcamento, {SL2->L2_FILRES, SL2->L2_ORCRES, .F., lPedido, lLstPre} )
		EndIf
	EndIf
	
	SL2->( dbSkip() )
End

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//|aOrcamento eh ordenado em ordem descrescente(TRUE(1), FALSE(0)),          |
//| para que no momento do loop ele exclua primeiro os orcamentos finalizados|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aSort( aOrcamento, /*nInicio*/, /*nItens*/, { |x,y| x[3] > y[3] } )

Return aOrcamento


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj140Pos  ºAutor  ³Vendas & CRM        º Data ³  11/25/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Posiciona no sub-orcamento( filho) finalizado			  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Lj140Exc / Lj140VlVend / Lj140VlDev / Lj140VlImp			  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Lj140Pos(aOrcamento)

Local nPos			:= 0					//posicao do orcamento finalizado no array aOrcam
Local aSL1Area		:= SL1->( GetArea() )	//armazeno a area do orcamento pai
Local lRet			:= .F.

Default aOrcamento	:= {}

nPos := aScan(aOrcamento, {|x|x[3] == .T.})	//procura o orcamento finalizado no array aOrcam

DbSelectArea("SL1")
SL1->( DbSetOrder(1) )
If nPos > 0 .AND. SL1->( DbSeek(aOrcamento[nPos][1] + aOrcamento[nPos][2]) )
	lRet := .T.	
Else
	If !lExcAuto
		MsgStop(STR0119 + AllTrim(aOrcamento[nPos][2]), STR0006) // "Nao foi possivel localizar o sub-orcamento:" | "Atencao"
	Else 
		Conout(STR0119 + AllTrim(aOrcamento[nPos][2]))
	EndIf	
	SL1->( RestArea(aSL1Area) )
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj140DelNcc ºAutor  ³Vendas & CRM        º Data ³  11/28/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Cancela a NCC na Base de Dados                                º±±
±±º          ³                                                            	º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Lj140Exc														º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Lj140DelNcc()

Local cBxDoc		:= ""					// Documento da NCC
Local cBxSerie      := ""					// Série da NCC           
Local cParcela 		:= ""
Local cMvLjPref     := SuperGetMV("MV_LJPREF")
Local aSE1Found		:= {}	//[1]-indica se achou o registro na SE1 [2]-indica se a Filial esta compartilhada
Local aSE1			:= {}
Local aEstorno		:= {}
Local aAreaSE5		:= SE5->(GetArea())
Local nX			:= 0	// Contador do For

If SL1->L1_CREDITO > 0
	LjGrvLog( SL1->L1_NUM, "Foi utilizada NCC nesta venda. Será realizado o Estorno da NCC.")

	//Compoe o Numero do titulo
	If ExistFunc("LJ7NumTit")
		cBxDoc := LJ7NumTit()
	Else
		If Empty(SL1->L1_DOC)
			cBxDoc := SL1->L1_DOCPED
		Else 
			cBxDoc := SL1->L1_DOC
		Endif
	EndIf

	//Compoe o Prefixo do titulo
	If AllTrim(Upper(cMvLjPref)) <> "SF2->F2_SERIE"
		cBxSerie := &(cMvLjPref)
	Else
		If Empty(SL1->L1_SERIE)
			cBxSerie := SL1->L1_SERPED
		Else 
			cBxSerie := SL1->L1_SERIE
		Endif
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	//³Ajusta o tamanho dos campos. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ?
	cParcela	:= SuperGetMV("MV_1DUP")
	cParcela	:= PadR( cParcela	, TamSX3("E1_PARCELA")[1])
	cTipoSE1	:= PadR( 'CR '		, TamSX3("E1_TIPO")[1])
	cBxDoc 		:= PadR( cBxDoc		, TamSX3("L1_DOC")[1])
	cBxSerie 	:= PadR( cBxSerie 	, TamSX3("E1_PREFIXO")[1])
	
	LjGrvLog( SL1->L1_NUM, "Chave de busca do titulo da venda: E1_FILIAL: ["+xFilial("SE1")+"] E1_PREFIXO: ["+cBxSerie+"] E1_NUM: ["+cBxDoc+"] E1_PARCELA: ["+cParcela+"] E1_TIPO: ["+cTipoSE1+"]" )
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Posiciona no SE1 antes de executar o FINA330³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aSE1Found := Lj140Seek( "SE1", 1, {xFilial("SE1"), cBxSerie, cBxDoc, cParcela, cTipoSE1}, "E1_FILORIG" )
	If aSE1Found[1]

		LjGrvLog( SL1->L1_NUM, "O título foi encontrado na tabela SE1.")
		
	    If SE1->E1_SALDO <> SE1->E1_VALOR
			aSE1			:= {SE1->(Recno())}

			SE5->(dbSetOrder(7)) // E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ
			If SE5->(dbSeek(xFilial("SE5") + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + cTipoSE1 + SE1->E1_CLIENTE + SE1->E1_LOJA ))

				While SE5->E5_PREFIXO 	== SE1->E1_PREFIXO .AND.;
					SE5->E5_NUMERO		== SE1->E1_NUM .AND.;
					SE5->E5_PARCELA 	== SE1->E1_PARCELA .AND.;
					SE5->E5_TIPO 		== cTipoSE1 .AND.;
					SE5->E5_CLIFOR 		== SE1->E1_CLIENTE .AND.;
					SE5->E5_LOJA 		== SE1->E1_LOJA

					If !Empty(SE5->E5_DOCUMEN)		
						aAdd(aEstorno, {{SE5->E5_DOCUMEN},SE5->E5_SEQ})
					EndIf

					SE5->(dbSkip())
				EndDo

				For nX := 1 To Len(aEstorno)			
					// Chama o cancelamento da baixa
					If !MaIntBxCR(3 ,aSE1, , , , , ,aEstorno[nX], , , , , , , , , , , ) 									
						lRet := .F.
						cMsgRet := "Não foi possível cancelar a compensação."
					EndIf
				Next nX
				
			EndIf
			LjGrvLog( SL1->L1_NUM, "Após a execução do estorno da compensação de título.")
	    EndIf

	Else
		LjGrvLog( SL1->L1_NUM, "Atenção, o título não foi encontrado na tabela SE1.")
	EndIf    

Else
	LjGrvLog( SL1->L1_NUM, "Não foi utilizada NCC nesta venda.")
EndIf

RestArea(aAreaSE5)

Return Nil


/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³ Lj140Cart  ºAutor  ³ Vendas Clientes  º Data ³ 12/12/2011  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna array com informacoes de pagamentos realizados com º±±
±±º          ³ cartoes (Debito e Credito).                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Loja140                                                     º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Lj140Cart()
Local aRet 		:= {}
Local aArea 	:= GetArea()
Local nInd		:= 0
Local cFormas 	:= "CC|CD"

//Considera registros Deletados para cancelamento do TEF.
SET DELETED OFF

DbSelectArea("SL4")
SL4->( DbSetOrder(1) )	//L4_FILIAL, L4_NUM, L4_ORIGEM
If SL4->( DbSeek(xFilial("SL4") + SL1->L1_NUM ) )
	/*Segundo a software express (12/04/2016): 
	"Precisa verificar o numero do documento que é impresso no cupom Tef,
	geralmente a Rede utiliza o NSU Host e a Cielo o NSU Sitef."
	
	Portanto mando as duas numerações para tratar mais acima */	
	While !SL4->( Eof() ) .AND. xFilial("SL4") + SL1->L1_NUM == SL4->L4_FILIAL + SL4->L4_NUM
		If AllTrim(SL4->L4_FORMA) $ cFormas .And. Empty(SL4->L4_DATCANC) .And. SL4->L4_SITUA != "**"
			//Tratamento para mais de uma parcela do mesmo cartao
			nInd := aScan( aRet, { |x| x[1] == Alltrim(SL4->L4_DOCTEF)})
			If nInd == 0
				aAdd( aRet		, { AllTrim(SL4->L4_DOCTEF)	,; 	//01-Numero do DOCTEF
									SL4->L4_VALOR			,; 	//02-Valor
									SL4->L4_DATATEF			,; 	//03-Data da Transacao
									AllTrim(SL4->L4_FORMA)	,; 	//04-Forma de pagamento (CC ou CD)
									AllTrim(SL4->L4_ADMINIS),;	//05-Administradora
									AllTrim(SL4->L4_NSUTEF)	,; 	//06-Numero do NSU
									SL4->(Recno()) 			,; 	//07-Recno da SL4
									SL4->L4_AUTORIZ 		,;	//08-Numero da Autorizacao TEF
									AllTrim(SL4->L4_HORATEF)})	//09-Hora da Autorização do TEF
			Else
				aRet[nInd][2] += SL4->L4_VALOR
			EndIf
		EndIf				
		SL4->( DbSkip() )
	End
EndIf

//Desconsidera os registros deletados
SET DELETED ON

RestArea(aArea)

Return aRet


/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³Lj140LbRPSºAutor  ³Vendas & CRM        º Data ³ 15/Ago/2012 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica se libera a exclusao quando for venda apenas de   º±±
±±ºDesc.     ³ servico (RPS).                                             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ LOJA140 - Lj140VlImp	 									  º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Lj140LbRPS()
Local aArea			:= SL1->( GetArea() )	//armazeno a area do orcamento pai
Local lRet			:= .T.
Local cFilialSL1	:= SL1->L1_FILIAL
Local cNumSL1 		:= SL1->L1_NUM

DbSelectArea("SL1")
SL1->( DbSetOrder(1) ) //Ordem: L1_FILIAL + L1_NUM
While SL1->(!EoF()) .And. SL1->L1_FILIAL == cFilialSL1
	If cNumSL1 <> SL1->L1_NUM .And. !Empty(SL1->L1_DOC)
		lRet := .F. //Nao permite excluir, pois a ultima nota ou cupom gerado nao esta relacionado ao orcamento que deseja excluir
		Exit
	EndIf
	SL1->( DbSkip() )
End

SL1->( RestArea(aArea) )

Return lRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ Lj140VldPV ºAutor³Vendas Clientes ºData³ 14/08/2012  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica se o orcamento possui algum Pedido de venda.º±±
±±º          ³ Se possuir, verifica se o mesmo ja foi faturado		º±±
±±º			 | Observacao: validacao retirada da funcao LJ140Fill	º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Lj140VlVend                                           º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LJ140VldPV(aOrcamento)

Local lRet		:= .T.	//retorno da funcao
Local aArea 	:= {}	//armazena a area
Local nPos		:= 1	//elemento do array aOrcamento que possui um pedido de venda
Local cPrefixo	:= PadR("LJ", TamSx3("E1_PREFIXO")[1])
Local cNumTit	:= ""
Local cPedRes		:= "" //Recebe o numero do pedido
Local lMvLjVfNfs 	:= SuperGetMv("MV_LJVFNFS",,.F.) //Verifica se a nota de simples faturamento esta ativa

Default aOrcamento := {}

aArea	:= SL1->( GetArea() )
nPos	:= AScan(aOrcamento, {|x| x[4] == .T.} )

DbSelectArea("SL1")
SL1->( DbSetOrder(1) ) //L1_FILIAL + L1_NUM

While nPos > 0

	If SL1->( DbSeek(aOrcamento[nPos][1] + aOrcamento[nPos][2]) )
		If !Empty(SL1->L1_PEDRES)
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³verificamos na tabela SC5, se o pedido de vendas ja foi faturado³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			//Quando a funcionalidade de simples faturamento esta ativa, deve-se pegar sempre o numero do pedido no campos L1_PEDPRS,
			//isso porque o pedido que esta no campo L1_PEDRES sempre nascera faturado pois eh o pedido de simples faturamento e o
			//pedido que esta no campo L1_PEDPRS eh o pedido de simples remessa que sera faturado quando for enviar a mercadoria
			//para o cliente.
			If lMvLjVfNfs .AND. !Empty(SL1->L1_PEDPRS)
				cPedRes := SL1->L1_PEDPRS
			Else
				cPedRes := SL1->L1_PEDRES
			EndIf

			DbSelectArea("SC5")
			SC5->( DbSetOrder(1) ) //C5_FILIAL + C5_NUM
			If SC5->( DbSeek(aOrcamento[nPos][1] + cPedRes) )

				If !Empty(SC5->C5_NOTA) .AND. !Empty(SC5->C5_SERIE)
					If !lExcAuto
				   		MsgStop(STR0083, STR0047)
				   		//"Este Pedido possui Pedidos de Venda finalizados, nao sera possivel efetuar o cancelamento."###"Atencao"
					Else 
						Conout(STR0083)
					EndIf
					lRet := .F.
					Exit
				Else
					cNumTit := PadR(SL1->L1_PEDRES, TamSx3("E1_NUM")[1])
					DbSelectArea("SE1")
					SE1->(DbSetOrder(1)) // E1_FILIAL + E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO
					If SE1->(DbSeek(FwxFilial("SE1", aOrcamento[nPos][1]) + cPrefixo + cNumTit) .And. AllTrim(SE1->E1_TIPO) == "NCC")
						If !lExcAuto
							MsgStop(STR0173 + SL1->L1_PEDRES + STR0174 + SL1->L1_PEDRES + STR0175 + CHR(10) + Chr(13) + STR0176, STR0047)
							//"Esta venda não pode ser excluída, pois existe NCC (Nota de Crédito ao Consumidor) de número: XXXXX, prefixo: 'LJ' relacionada ao pedido: XXXXX originado desta venda. 
							//"Obs.: Possivelmente esta NCC pode ter sido gerada através da rotina 'Eliminar Resíduos'." ### "Atencao"  
						Else
							LjGrvLog(SL1->L1_NUM, STR0173 + SL1->L1_PEDRES + STR0174 + SL1->L1_PEDRES + STR0175 + STR0176)
						Endif
						
						lRet := .F.
						Exit
					EndIf 
				EndIf
			EndIf
		ElseIf !Empty(SL1->L1_DOC) .AND. !Empty(SL1->L1_ORCRES) .AND. AllTrim(L1_TIPO) = "P"
			If !lExcAuto
		   		MsgStop(STR0083, STR0047)
		   		//"Este Pedido possui Pedidos de Venda finalizados, nao sera possivel efetuar o cancelamento."###"Atencao"
			Else 
				Conout(STR0083)
			EndIf
			lRet := .F.
			Exit
		EndIf		
	EndIf

	//procuramos por um novo elemento a partir do (ultimo encontrado + 1), para que nao haja repeticao
	nPos := AScan(aOrcamento, {|x| x[4] == .T.}, nPos + 1 )
End

SL1->( RestArea(aArea) )

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³Lj140ImpOrc³ Autor ³ Vendas Clientes      ³ Data ³15/Out/2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Programa de impressao de orcamentos						   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Lj140ImpOrc()		                                       ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Lj140ImpOrc(cMensagem, cCliente, cLoja, cCliCGC, lRetPos)
Local cCodProd										//Variavel que recebe codigo do produto	                                              
Local cDescriProd									//Variavel que recebe descrição do produto
Local cQuant										//Variavel que recebe quantidade 
Local cVrUnit										//Variavel que recebe Valor unitario
Local cDesconto										//Variavel que recebe desconto
Local cVlrItem										//Variavel que recebe valor do item 
Local cSitTrib										//Variavel que recebe Situação tributaria 
Local cFormaPgtos									//Variavel que recebe formas de pagamento
Local cNomeForma									//Variavel que recebe nome das formas de pagamento
Local nAliquota										//Variavel que recebe aliquotas
Local nRet											//Variavel que recebe retorno 
Local cTpSolCf 		:= SuperGetMV("MV_TPSOLCF")		//Parametro para validacao do tipo de cliente para o calculo do solidario
Local cUnidMed 		:= " "							//Variavel que recebe unidade de medida
Local nAliqIss 		:= 0							//Recebe o campo B1_ALIQISS ou o parametro MV_ALIQISS
Local nPosItECF		:= 0	
Local aAreaSA1 		:= SA1->(GetArea())             //Guarda a area do SA1
Local lImprime		:= .T.                         	// Controle de para verificar se a impressao foi bem sucedida 
Local lStatusImp	:= .T.							// Status da Impressao	
Local aLjExcecao	:= {}
Local lExcecaoFcl	:= .F.
Local cNumCupom     := Space(TamSx3("L1_DOC")[1])	// Numero do cupom fiscal
Local cNumPdv 		:= Space(TamSx3("L1_PDV")[1])	// Numero do PDV  
Local cSerie 		:= ""							// Serie do documento
Local cOrcRes	  	:= "" 							// Codigo do orcamento da reserva
Local cPedRes	  	:= "" 							// Codigo do pedido da reserva
Local lCFRetPos 	:= .F.    						// Verifica se eh orcamento (com itens de RETIRA POSTERIOR) apenas para finalizacao (impressao do Cupom Fiscal)
Local aArrayFormas  := {}
Local nI			:= 0
Local nPosForm		:= 0
Local nPICMRet		:= 0
Local lFormaRetira	:= .F.							//Considera a Forma de pagamento para itens do tipo retira posterior
Local cFormaRetira	:= SuperGetMv("MV_LJFORRET",,"")//Forma de pagamento para itens do tipo retira posterior

Default cMensagem	:= ""							//Mensagem promocional do cupom
Default cCliente	:= Nil
Default cLoja 		:= Nil
Default lRetPos		:= .F.

DbSelectArea("SA1")
SA1->(DbSetOrder(1))
SA1->(DbSeek(xFilial("SA1")+SL1->L1_CLIENTE+SL1->L1_LOJA))

//Pega numero do cupom
While lImprime
	nRet := IfPegCupom( nHdlECF, @cNumCupom )
	If nRet == 1
		If Aviso(STR0006,STR0054 + CHR(10) + Chr(13) +; //"Atencao ## "Problemas na abertura do cupom."
					STR0087, {STR0088,STR0089}) = 2 	//"Executa a impressão novamente? # Sim # Não "
			lImprime 	:= .F.
			lStatusImp	:= .F.
   		EndIf
	Else
		lImprime := .F.
		cNumCupom := PadR( StrZero(Val(cNumCupom)+1,Len(cNumCupom)) , TamSx3("L1_DOC")[1] )
    EndIf   
End

//Pega numero do PDV   
lImprime := .T.
While lImprime
	nRet := IfPegPDV( nHdlECF, @cNumPdv )
	If nRet == 1
		If Aviso(STR0006,STR0054 + CHR(10) + Chr(13) +; //"Atencao ## "Problemas na abertura do cupom."
					STR0087, {STR0088,STR0089}) = 2 	//"Executa a impressão novamente? # Sim # Não "
			lImprime 	:= .F.
			lStatusImp	:= .F.
   		EndIf
	Else
		lImprime := .F.
    EndIf   
End

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Abre o cupom fiscal                                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lImprime := .T.
While lImprime
	nRet :=IFAbreCup( nHdlEcf, @cCliCGC, cCliente, cLoja )
	If nRet == 1
		If Aviso(STR0006,STR0054 + CHR(10) + Chr(13) +; //"Atencao ## "Problemas na abertura do cupom."
					STR0087, {STR0088,STR0089}) = 2 	//"Executa a impressão novamente? # Sim # Não "
			lImprime 	:= .F.
			lStatusImp	:= .F.
   		EndIf
	Else
		lImprime := .F.
    EndIf
End
   
//Serie
cSerie   := LjGetStation("LG_SERIE")
/* Atualiza SL1 com informações do Cupom Fiscal */
RECLOCK( "SL1" ,.F.)
SL1->L1_DOC		:= cNumCupom
SL1->L1_PDV		:= cNumPdv
SL1->L1_SERIE	:= cSerie
If lRetPos .And. SL1->L1_OPERACA != "C"
	SL1->L1_OPERACA	:= "C"
EndIf

SL1->(MSUNLOCK())

cOrcRes	  :=  SL1->L1_ORCRES 	// Codigo do orcamento da reserva
cPedRes	  :=  SL1->L1_PEDRES 	// Codigo do pedido da reserva
lCFRetPos :=  Empty(cPedRes) .And. !Empty(cOrcRes) .And. ExistFunc("Lj140ImpOrc") //Verifica se eh orcamento (com itens de RETIRA POSTERIOR) apenas para finalizacao (impressao do Cupom Fiscal)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Imprime os itens   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nRet == 0
	nPosItECF := 0
	DbSelectArea("SL2")
	DbSetOrder(1)
	DbSeek(xFilial("SL2")+SL1->L1_NUM)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Varre SL2 para imprimir os itens ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	While (SL2->(!EOF())).AND. ((xFilial("SL2") + SL2->L2_NUM) == (xFilial("SL2")+SL1->L1_NUM))
		
		If lRetPos .And. SL2->L2_VENDIDO <> "S"
			RecLock("SL2",.F.)
			SL2->L2_VENDIDO := "S"
			SL2->(MsUnlock())	
		EndIf
		
		If nModulo == 12	 	// SIGALOJA	
			SB1->(DbSeek(xFilial("SB1")+SL2->L2_PRODUTO))
		ElseIf nModulo == 23	// FRONTLOJA
			SBI->(DbSeek(xFilial("SBI")+SL2->L2_PRODUTO))					                                                            
		Endif                                                       
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Posiciona o SF4   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SF4->(DbSeek(xFilial("SF4")+SL2->L2_TES))
		
		aLjExcecao := LjxExcecao(.T.)
		lExcecaoFcl:= Len(aLjExcecao) > 0
		LjGrvLog( SL1->L1_NUM , " TES " + AllTrim(SF4->F4_CODIGO) + " - Verificação de exceção fiscal ", aLjExcecao)
		
		nPICMRet := IIf(nModulo == 12, SB1->B1_PICMRET, SBI->BI_PICMRET)
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica a situacao tributaria do item                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SF4->F4_ISS == "S"					// Servico
		
		    If nModulo == 12 .AND. SB1->B1_ALIQISS > 0
				nAliqIss:= SB1->B1_ALIQISS  
			ElseIf nModulo == 23 .AND. SBI->BI_ALIQISS > 0 
				nAliqIss:= SBI->BI_ALIQISS  				
		    Else
				nAliqIss:= SuperGetMv("MV_ALIQISS")
		    EndIf
		
			cSitTrib := "S" + AllTrim(Str(nAliqIss,5,2))
		
		ElseIf If(SF4->(ColumnPos("F4_MKPSOL"))>0,SF4->F4_MKPSOL<>"1",.T.) .And.;
		 		( nPICMRet > 0 .OR. (lExcecaoFcl .AND. (aLjExcecao[3] > 0 .OR. aLjExcecao[16] > 0 )) );
				.AND. SA1->A1_TIPO $ cTpSolCf .AND. SF4->F4_BSICMST <> 100
				
			cSitTrib := "F"						// Substituicao tributaria (Icms Solidario)

		ElseIf (SF4->F4_BASEICM > 0 .AND. SF4->F4_BASEICM < 100)  .Or. ;
				(lExcecaoFcl .AND. (aLjExcecao[14] > 0) .AND. (aLjExcecao[14] < 100))
			
			If nModulo == 23
			 	cSitTrib := "T" + Alltrim(Str( SBI->BI_ALIQRED,5,2 ))		  // com reducao de Icms na Base
			Else
				cSitTrib := "T" + Alltrim(Str( SB0->B0_ALIQRED,5,2 ))		  // com reducao de Icms na Base
			EndIf
			
			If lExcecaoFcl
				LjGrvLog( SL1->L1_NUM, " Redução de Alíquota configurada como exceção fiscal " +;
							"[ se campo estiver zerado preencha a redução no campo " + IIF(nModulo == 23 ,"BI_ALIQRED","B0_ALIQRED") + " ] " , cSitTrib) 		
			Else
				LjGrvLog( SL1->L1_NUM, " Redução de Alíquota configurada pela TES " +;
						"[campo F4_BASEICM - se alíquota estiver zerada preencha a redução no campo " + IIF(nModulo == 23 ,"BI_ALIQRED","B0_ALIQRED") + " ] " , cSitTrib)
			EndIf
			
		ElseIf SF4->F4_LFICM == "I"			// Isento
			cSitTrib := "I"
			
		ElseIf SF4->F4_LFICM == "N"			// N„o sujeito a ICMS
			cSitTrib := "N"
			
		Else									// Com ICMS
			nAliquota := AliqIcms("N","S",SA1->A1_TIPO,"I")
			cSitTrib := "T" + Alltrim(Str(nAliquota,5,2))			
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Trata as variaveis para o registro do item                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cCodProd 		:= SL2->L2_PRODUTO
		cDescriProd		:= SubStr(SL2->L2_DESCRI + Space(30),1,30)
		cQuant 			:= StrZero(SL2->L2_QUANT,7,2)
		cVrUnit			:= Str(SL2->L2_VRUNIT,10,4)
		cDesconto		:= Iif(!lCFRetPos,Str(SL2->L2_VALDESC,8,2),"0")  // Neste ponte se for cupom fiscal de "Retira Posterior", nao aplica desconto, pois ja foi aplicado
		cVlrItem		:= Str(Val(cVrUnit) * Val(cQuant),11,2)
		If nModulo == 12
			cUnidMed    := SB1->B1_UM
		Elseif nModulo == 23	
			cUnidMed    := SBI->BI_UM
		Endif
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Imprime o item                                               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        lImprime := .T.
		While lImprime
			nRet := IFRegItem( 	nHdlECF, cCodProd	, cDescriProd	, cQuant	, ;
								cVrUnit, cDesconto 	, cSitTrib		, cVlrItem	, ;
								cUnidMed )
			If nRet == 1
				If Aviso(STR0006,STR0053 + CHR(10) + Chr(13) +; //"Atencao ## "Falha em registrar item."
						 STR0087, {STR0088,STR0089}) == 2 	 	//"Executa a impressão novamente? # Sim # Não "
					lImprime 	:= .F.
					lStatusImp 	:= .F.
   				EndIf
			Else
				lImprime := .F.
				nPosItECF++
    		EndIf
		End
		
		//Se vendido igual a "N" significa produto cancelado no orçamento, devo cancelar no CF
		If lStatusImp .And. SL2->L2_VENDIDO == "N"
			lImprime := .T.
			While lImprime
				nRet := IFCancItem(nHdlECF,Str(nPosItECF,3),cCodProd,cDescriProd,cQuant,cVrUnit,cDesconto,cSitTrib)
				
				If nRet == 1
					If Aviso(STR0006,"Falha no cancelamento do item" + CHR(10) + Chr(13) +; //"Atencao ## "Falha em registrar item."
							 STR0087, {STR0088,STR0089}) == 2 	 	//"Executa a impressão novamente? # Sim # Não "
						lImprime 	:= .F.
						lStatusImp 	:= .F.
	   				EndIf
				Else
					lImprime := .F.
	    		EndIf
	    	End
		EndIf

		DbSelectArea("SL2")
		SL2->(dbSkip())
	End
EndIf

If SL1->L1_DESCONT > 0 .AND. lStatusImp
	lImprime := .T.
	While lImprime
		nRet := IfDescTot( nHdlECF, Alltrim(Str(SL1->L1_DESCONT,10,2)))
		If nRet == 1
			If Aviso(STR0006,STR0055 + CHR(10) + Chr(13) +; //"Atencao ## "Falha no registro do desconto no total."
					 STR0087, {STR0088,STR0089}) = 2 	 	//"Executa a impressão novamente? # Sim # Não "
				lImprime 	:= .F.
				lStatusImp 	:= .F.
			EndIf
		Else
			lImprime := .F.
		EndIf
	End
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona o SL4   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
SL4->(DbSeek(xFilial("SL4")+SL1->L1_NUM))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Monta a string cFormaPgtos para enviar para o ECF                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cFormaPgtos := ''
nTotalPgtos := 0
lFormaRetira := !Empty(cFormaRetira) .And. AllTrim(SL1->L1_TIPO) == "P" .And. !Empty(SL1->L1_FILRES) .And. (!Empty(SL1->L1_ORCRES) .Or. !Empty(SL1->L1_DOCPED))
While (nTotalPgtos < SL1->L1_VLRLIQ) .AND. (SL4->L4_NUM == SL1->L1_NUM)

	//Para que ao emitir o cupom fiscal o mesmo nao apresente a forma de pagamento mas sim o definido no parametro
	If lFormaRetira
		cNomeForma := cFormaRetira

	ElseIf Trim(SL4->l4_FORMA) == ''
		cNomeForma := Alltrim(Tabela("24",SuperGetMV("MV_SIMB1"),.F.))
	ElseIf Trim(SL4->L4_FORMA) == 'R$'
		cNomeForma := Alltrim(Tabela("24",AllTrim(SL4->L4_FORMA),.F.))
		
	ElseIf Trim(SL4->L4_FORMA) == 'CH'
		cNomeForma := Alltrim(Tabela("24",AllTrim(SL4->L4_FORMA),.F.))
		
	ElseIf SuperGetMv("MV_LJPAGTO") == 1									//Busca da Tabela 24 do SX5
		cNomeForma := Alltrim(Tabela("24",AllTrim(SL4->L4_FORMA),.F.))
		
	Else
		cNomeForma := Trim(Substr(SL4->L4_ADMINIS,7,14))		
	EndIf
	                              
	// Verifica se a forma ja esta adicionada no array
	nPosForm := Ascan( aArrayFormas, { |x| Trim(x[1]) == Trim(cNomeForma) } )
	
	If nPosForm == 0           	   
		Aadd(aArrayFormas,{ Trim(cNomeForma), SL4->L4_VALOR } )
	Else                       
		// Soma o valor a forma ja existente no array
		aArrayFormas[nPosForm][2] += SL4->L4_VALOR 
	Endif	
	
	SL4->(dbSkip())
End Do

For nI := 1 to Len(aArrayFormas)
	// Monta string com formas e valores
	cFormaPgtos +=  aArrayFormas[nI][1] + "|" + Alltrim(Str(aArrayFormas[nI][2])) + "|"

Next nI

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Envia as formas de pagamento para o ECF                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lImprime := .T.
While lImprime .AND. lStatusImp 
	nRet := IFPagto( nHdlECF, cFormaPgtos  )
	If nRet == 1
		If Aviso(STR0006,STR0056 + CHR(10) + Chr(13) +; //"Atencao ## "Falha no registro de pagamento."
				 STR0087, {STR0088,STR0089}) = 2 	 	//"Executa a impressão novamente? # Sim # Não "
			lImprime 	:= .F.
			lStatusImp 	:= .F.
		EndIf
	Else
		lImprime := .F.
	EndIf
End

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Fecha o cupom e imprime a mensagem promocional ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  
lImprime := .T.
While lImprime .AND. lStatusImp
	nRet := IFFechaCup( nHdlECF, cMensagem )
	If nRet == 1
		If Aviso(STR0006,STR0057 + CHR(10) + Chr(13) +; //"Atencao ## "Falha no fechamento do cupom."
				 STR0087, {STR0088,STR0089}) = 2 	 	//"Executa a impressão novamente? # Sim # Não "
			lImprime 	:= .F.
			lStatusImp 	:= .F.
		EndIf
	Else
		lImprime := .F.
	EndIf
End

RestArea(aAreaSA1)

Return lStatusImp

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ Lj140EstVP ºAutor³Vendas Clientes ºData³ 18/06/2013  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica se a venda foi paga com Vale Presente e     º±±
±±º          ³ estorna o mesmo.                              		º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ LOJA140                                              º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Lj140EstVP( cNumOrc )
Local aArea 		:= GetArea()
Local aAreaSL4 		:= SL4->( GetArea() )
Local aAreaSL2 		:= SL2->( GetArea() )
Local aValePre 		:= {}
Local lL2VALEPRE 	:= SL2->(ColumnPos("L2_VALEPRE")) > 0
Local aChave		:= {} 			// Chave para estorno do título
Local lCrdxInt     	:= CrdxInt() 	// Controla se tem integracao com SIGACRD
Local aChaveSL1		:=  {} 			//Chave do SL1
Local aRetCrd		:= {} 			//Array  de retorno do cancelamento do contrato - integracao SIGACRD

LjGrvLog( SL1->L1_NUM, "Lj140EstVP | Verifica se a venda foi paga com Vale Presente e estorna o mesmo -> Inicio" , )

If ExistFunc("LjVpAtiva")
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se foi utilizado VP na venda como forma de pagamento ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea("SL4")
	SL4->( DbSetOrder(1) )

	If SL4->( DbSeek(xFilial("SL4")+cNumOrc) )
    
		While !SL4->(Eof()) .AND. SL4->L4_FILIAL+SL4->L4_NUM == xFilial("SL4")+cNumOrc

			If AllTrim(SL4->L4_FORMA) == "VP"

                    If Empty(SL4->L4_CODVP)
                        aAdd(aValePre,{AllTrim(SL4->L4_NUMCART) ,"2"}) //Atualizar Vale Presente para "2=Vendido"
                    Else                        
				        aAdd(aValePre,{AllTrim(SL4->L4_CODVP)   ,"2"}) //Atualizar Vale Presente para "2=Vendido"
                    EndIf                        

				    LjGrvLog( SL1->L1_NUM, "Lj140EstVP | SL4 -> Vale Presente utilizado: " + AllTrim(SL4->L4_CODVP) , )
			EndIf
			SL4->( DbSkip() )
		End
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se foi vendido algum VP na venda ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lL2VALEPRE
		DbSelectArea("SL2")
		SL2->( DbSetOrder(1) )

		If SL2->( DbSeek(xFilial("SL2")+cNumOrc) )
			While !SL2->(Eof()) .AND. SL2->L2_FILIAL+SL2->L2_NUM == xFilial("SL2")+cNumOrc
				If !Empty(SL2->L2_VALEPRE)
		   			aAdd(aValePre,{AllTrim(SL2->L2_VALEPRE),"1"}) //Atualizar Vale Presente para "1=Ativo"
					LjGrvLog( SL1->L1_NUM, "Lj140EstVP | SL2->L2_VALEPRE -> Vale Presente utilizado: " + AllTrim(SL2->L2_VALEPRE) , )
				EndIf
				SL2->( DbSkip() )
			End
		EndIf
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorna os Vales Presentes ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	If Len(aValePre) > 0
		//Executa funcao para voltar o status do Vale Presente 

		LjGrvLog( SL1->L1_NUM, "Lj140EstVP | Inicio exclusão da venda não fiscal",)

		If lCrdxInt .AND. SL1->(ColumnPos("L1_CONTRA")) > 0
			If !Empty(SL1->L1_CONTRA)
				aRetCrd      := aClone(CrdxVenda( "3"  ,{"",""}  ,SL1->L1_CONTRA  ,.F.  ,;
				NIL  ,NIL ))
			EndIf
		EndIf

		aChave		:= { xFilial("SE1"), SL1->L1_SERPED, SL1->L1_DOCPED }
		aChaveSL1	:= { SL1->L1_FILIAL, SL1->L1_SERIE, SL1->L1_DOC, SL1->L1_CLIENTE, SL1->L1_LOJA }

		LjGrvLog( SL1->L1_NUM, "Lj140EstVP | Antes de enviar para LjVpAtiva " , )

		If LjVpAtiva(aValePre) 
			SL1->( RecLock( "SL1" ) )
				SL1->L1_DOCPED := ''
				SL1->L1_SERPED := ''
			SL1->( MsUnlock() )

			LjGrvLog( SL1->L1_NUM, "Lj140EstVP | Antes de enviar para o estorno no financeiro",)
			Lj140CnFin( aChave, lCrdxInt, @aRetCrd, aChaveSL1, .F. )
			LjGrvLog( SL1->L1_NUM, "Lj140EstVP | Após enviar para o estorno no financeiro", )

		Else
			LjGrvLog( SL1->L1_NUM, "Lj140EstVP | Falha na exclusão da venda não fiscal - LjVpAtiva -> .F.",)
		EndIf

	EndIf
EndIf

RestArea( aAreaSL2 )
RestArea( aAreaSL4 )
RestArea( aArea )

Return

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³ Lj140NFCe  ºAutor³ VAREJO		 ºData³ 28/01/2014  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Envia o cancelamento da NFC-e ao SEFAZ				º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ LOJA140                                              º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Lj140DocE(aOrcamento)
Local cModDoc	:= ""
Local nI		:= 0	//contador
Local lRet		:= .T.	//indica se o cancelamento foi recebido pelo SEFAZ
Local lRetAux	:= .F.
Local aArea		:= {}
Local aSF2Area	:= {}
Local nF2Recno	:= 0
Local aSitua	:= {}	//[1] - se atualiza o SITA [2] - novo valor do SITUA
Local lFisLivro := (SuperGetMV("MV_LJLVFIS",,1) == 2)		// Utiliza novo conceito para geracao do SF3
Local lL1RETSFZ	:= SL1->(ColumnPos("L1_RETSFZ")) > 0	//campo o qual será gravado as informações de retorno da SEFAZ
Local lL1SERSAT := SL1->(ColumnPos("L1_SERSAT")) > 0
Local lIsBlind	:= IsBlind()
Local nMvLjTpCan:= SuperGetMV("MV_LJTPCAN",,1)  		//Parametro que indica se utiliza o novo processo de cancelamento
Local oCancNfce	:= Nil									//Armazena o objeto CancNfce
Local oLOJGNFCE	:= Nil									//Armazena a Classe LOJGNFCE
Local lCreateSLX:= .T.									//Indica se deve criar a tabela SLX
Local lInteract	:= Iif(ExistFunc("LOJGNFCE"),GetApoInfo("LOJGNFCE.PRW")[4] >= CtoD("31/07/2019"),.F.)										//Indica se o fonte LOJGNFCE esta atualizado
Local lLxIteracao:= SLX->(ColumnPos("LX_ITERACA") ) > 0 .And. SLX->(ColumnPos("LX_DULTPRC") ) > 0 .And. SLX->(ColumnPos("LX_HULTPRC") ) > 0  //indica se os campos estão presentes 
Local aRetTSS	:= StrToKarr2(SL1->L1_RETSFZ,"|")
Local cRetSfz	:= iif( len(aRetTSS) > 2, aRetTSS[02], aRetTSS[01] )
Local lDenegada	:= cRetSfz $ RetCodDene()

Default aOrcamento := {}

//armazena a area do orcamento pai/principal
aArea := SL1->(GetArea())

For nI := 1 To Len(aOrcamento)
	
	//verifica se algum orcamento filho foi finalizado
	If !Empty(aOrcamento[nI][1]) .AND. !Empty(aOrcamento[nI][2])
		If SL1->( DbSeek(aOrcamento[nI][1] + aOrcamento[nI][2]) ) .And. !Empty(SL1->L1_DOC) .And. !Empty(SL1->L1_SERIE)	//posiciona no sub-orcamento (Filho, com DOC e SERIE preenchido)
			Exit
		EndIf
	EndIf
Next

If SL1->L1_TPORC == 'E' .AND. (!Empty(SL1->L1_KEYNFCE) .OR. SL1->L1_STORC == "A") .AND. IIF(lL1SERSAT,Empty(AllTrim(SL1->L1_SERSAT)),.T.)
	lRetAux := .T.
	cModDoc := "65" // NFC-e
ElseIf SL1->L1_TPORC == 'E' .AND. (!Empty(SL1->L1_KEYNFCE) .OR. SL1->L1_STORC == "A") .AND. IIF(lL1SERSAT,!Empty(AllTrim(SL1->L1_SERSAT)),.T.)
	lRetAux := .T.
	cModDoc := "59"	// SAT
ElseIf SL1->L1_IMPNF	
	cModDoc := "55" // NF-e
	
	//armazena a area, pois a funcao FATComTSS exige que o registro j?esteja posicionada
	aSF2Area := SF2->( GetArea() )

	DbSelectArea("SF2")
	SF2->( DbSetOrder(1) )	//F2_FILIAL, F2_DOC, F2_SERIE, F2_CLIENTE, F2_LOJA
	If SF2->( MsSeek(xFilial("SF2") + SL1->L1_DOC + SL1->L1_SERIE + SL1->L1_CLIENTE + SL1->L1_LOJA) )
		lRetAux := .T.
		nF2Recno := SF2->( Recno() )
	EndIf		
EndIf

If lRetAux

	// se for NFC-e
	If cModDoc == "65"
		
		LjGrvLog( SL1->L1_NUM, "SL1.L1_SITUA da venda com NFC-e", SL1->L1_SITUA )	

		//se for exclusao de uma venda, marcamos ela para ser cancelada, preenchendo o campo L1_SITUA = 'X0'
		If SL1->L1_SITUA == 'OK' .AND. SL1->L1_STORC <> 'A'
			
			// -- Se o cancelamento online estiver ativo tentamos cancelar online
			If lRet .AND. (nMvLjTpCan == 2 .OR. nMvLjTpCan == 3) .AND. !IsInCallStack("STDCancRec")
				oCancNfce := LOJCNFCE():New()
			
				//Tenta realizar o cancelamento Online
				LjMsgRun(STR0219 + SL1->(L1_SERIE+L1_DOC),, {|| oCancNfce:LjCancOnline(SL1->(L1_SERIE+L1_DOC))} ) //"Aguarde, Cancelando documento: "
				
				If oCancNfce:aResultCancelamento[1]
					
					//Grava log informando que a venda foi cancelada online
					LjGrvLog( "NumOrc: "+SL1->L1_NUM, "NFC-e cancelada ONLINE, Id: " +  SL1->(L1_SERIE+L1_DOC) ) 
					
					RecLock("SL1")
						Replace SL1->L1_SITUA with "X2"
					SL1->( MsUnlock() )
					
					If lInteract .AND. lLxIteracao
						oLOJGNFCE := LOJGNFCE():New()
						oLOJGNFCE:LjClearInteractSLX(SL1->L1_PDV,SL1->L1_DOC,SL1->L1_SERIE)
					EndIf 

					// -- Gravação da tabela SLX para vendas NFC-E Canceladas.
					lCreateSLX := .T.
					
					lRet := .F.

					If IsBlind()
						Conout("Cancelamento realizado com sucesso.")//"Cancelamento realizado com sucesso."
					Else
						MsgAlert(STR0216)//"Cancelamento realizado com sucesso."
					Endif 

				ElseIf oCancNfce:aResultMetodo[1] .AND. oCancNfce:aResultTSS[1] //Nota transmitida porem com rejeição (Online ou Offline Barra cancelamento)
					lRet := .F. //Avisa que a nota foi rejeitada e printa na tela o motivo da rejeição.
					LjGrvLog( "NumOrc: "+SL1->L1_NUM,  "Não foi possivel realizar o cancelamento. Motivo: " + oCancNfce:aResultCancelamento[3]) 

					If IsBlind()
						Conout("Não foi possivel realizar o cancelamento. Motivo:" + oCancNfce:aResultCancelamento[3])//"Cancelamento realizado com sucesso."
					Else
						MsgAlert(STR0217 + oCancNfce:aResultCancelamento[3])//"Cancelamento realizado com sucesso."
					Endif 
				Else
					If nMvLjTpCan == 3 .And. !oCancNfce:aResultTSS[1]
						LjGrvLog( "NumOrc: "+SL1->L1_NUM,  "Não foi possivel realizar o cancelamento. Motivo: Sem comunicação com TSS / Sefaz.")
						LjGrvLog( "NumOrc: "+SL1->L1_NUM,  "Retorno do TSS: " + oCancNfce:aResultTSS[3])
						
						If IsBlind()
							Conout("Não foi possivel realizar o cancelamento. Motivo: Sem comunicação com TSS / Sefaz.")//"Cancelamento realizado com sucesso."
						Else
							MsgAlert(STR0218)//"Cancelamento realizado com sucesso."
						Endif 

						lRet := .F.
					ElseIf (nMvLjTpCan == 3 .AND. !oCancNfce:aResultMetodo[1] .AND. oCancNfce:aResultTSS[1]) .OR. nMvLjTpCan == 2
						If oCancNfce:LjCancOffLine(SL1->L1_SERIE,SL1->L1_DOC)
							LjGrvLog( "NumOrc: "+SL1->L1_NUM,  "Envio de cancelamento para o TSS realizado com sucesso!")
							
							RecLock( "SL1" )
								Replace SL1->L1_SITUA with "X1"
							SL1->( MsUnlock() )

							// -- Gravação da tabela SLX para vendas NFC-E Canceladas.
							lCreateSLX := .T.
							
							lRet := .F.
						Else
							LjGrvLog( "NumOrc: "+SL1->L1_NUM,  "Não foi possivel realizar o envio do cancelamento para o TSS, o cancelamento devera ser realizado pelo job LJCANCNFCE")
							RecLock( "SL1" )
								Replace SL1->L1_SITUA with "X0"
							SL1->( MsUnlock() )

							// -- Gravação da tabela SLX para vendas NFC-E Canceladas.
							lCreateSLX := .T.

							lRet := .F. 
						EndIf 
					EndIf
				EndIf
			Else
				// -- Legado Cancelamento online desabilitado 
				RecLock( "SL1" )
				Replace SL1->L1_SITUA with "X0"
				SL1->( MsUnlock() )
				
				// -- Gravação da tabela SLX para vendas NFC-E Canceladas.
				lCreateSLX := .T.

				lRet := .F.
				// -- Legado Cancelamento online desabilitado 
			Endif

			If lInteract .And. lCreateSLX
				// -- Gravação da tabela SLX para vendas NFC-E Canceladas.
				Lj7SLXDocE(	""				, SL1->L1_DOC	, SL1->L1_SERIE	, SL1->L1_PDV	,;
 							SL1->L1_OPERADO	, "RX"			, ""			, ""			,;
							SL1->L1_NUM		, "A"			, "  "			)
			EndIf 
					
		//se o cancelamento foi autorizado pelo SEFAZ, entao permitimos o cancelamento prosseguir no ERP
		ElseIf SL1->L1_SITUA == 'X2' .or. lDenegada
			if lDenegada
				RecLock( "SL1" , .F. )
					SL1->L1_SITUA := "X2"
				SL1->( MsUnlock() )
			endif

			lRet := .T.
		
		//se o status da nota for (cancelamento nao enviado para o TSS, cancelamento pendente no SEFAZ ou 
		// cancelamento nao autorizado entao a nota devera ter sua SITUAcao avaliada novamente 
		ElseIf SL1->L1_SITUA $ "X0|X1|X3"				
			If !lIsBlind
				MsgInfo(STR0171 + AllTrim(SL1->L1_DOC) + "/" + SL1->L1_SERIE + STR0172) //"A venda: " #" encontra-se em processo de exclusão, atualizando status"
			EndIf
			
			aSitua := Lj140AtuSit(SL1->L1_SITUA, SL1->L1_SERIE, SL1->L1_DOC)
			If aSitua[1]
				RecLock( "SL1", .F. )
				Replace SL1->L1_SITUA with aSitua[2]
				SL1->( MsUnlock() )
			EndIf
		
			lRet := .F.
	
		Else
			lRet := .F.
			LjGrvLog( SL1->L1_NUM, "SITUA invalido para enviar cancelamento: " + SL1->L1_SITUA )
		EndIf

	// Se for SAT
	ElseIf cModDoc == "59"

		If LJSatxCanc(.F.) // Envia para cancelamento
			//Grava log informando que a venda foi cancelada
			LjGrvLog( "NumOrc: " + SL1->L1_NUM, " Documento SAT cancelado, Id: " + SL1->(L1_SERIE+L1_DOC) ) 	
		EndIf

	// se for NF-e
	ElseIf cModDoc == "55"		
		LjGrvLog( SL1->L1_NUM, "SL1.L1_SITUA da venda com NF-e", SL1->L1_SITUA )		
		LjGrvLog( SL1->L1_NUM, "Doc + Serie da NF-e", SF2->F2_DOC+ SF2->F2_SERIE )
		LjGrvLog( SL1->L1_NUM, "SF2.F2_STATUS da NF-e", SF2->F2_STATUS )		

		If SL1->L1_SITUA == "OK" .AND. !lDenegada

			RecLock( "SL1" )
			Replace SL1->L1_SITUA with "X0"
			SL1->( MsUnlock() )

			lRet := .F.
		
		ElseIf SL1->L1_SITUA $ "X0|X1"
			
			If lIsBlind
				if !lDenegada
					lRetAux := FATComTSS( Nil, lIsBlind, .F. /*lIsNotLOJA: indica que foi chamado pelo LOJA*/ )
					LjGrvLog( SL1->L1_NUM, "SF2.F2_STATUS da NF-e apos atualizacao", SF2->F2_STATUS )
				endif

				//posiciona na nota fiscal (SF2)
				SF2->( DbGoTo(nF2Recno) )
				
				//os valores de F2_FIMP foram copiados da função FatMonTSS() MATA521.PRW
				Do Case
					Case lDenegada
						aSitua := {.T. /*atualiza*/, "X2"}
					Case SF2->F2_STATUS == "025"
						aSitua := {.T. /*atualiza*/, "X1"}
					Case SF2->F2_STATUS $ "015|030|036"
						aSitua := {.T. /*atualiza*/, "X2"}
					Case SF2->F2_STATUS == "026"
						aSitua := {.T. /*atualiza*/, "X3"}
					Otherwise
						aSitua := {.F. /* nao atualiza*/, Nil}										
				EndCase
	
				If aSitua[1]
					RecLock( "SL1" )
					Replace SL1->L1_SITUA with aSitua[2]
					SL1->( MsUnlock() )
				EndIf

				lRet := .F.

			ElseIf !lDenegada
				MsgAlert(STR0168 + " [LJCANCNFCE]")	//"O status de cancelamento s?pode ser atualizado pelo job"
				lRet := .F. 
			EndIf

		ElseIf lDenegada
			lRet := .T.	
		ElseIf SL1->L1_SITUA == "X2"
			lRet := .T.
			
		ElseIf SL1->L1_SITUA == "X3"
			lRet := .F.
			
			//"A SEFAZ n? autorizou esse cancelamento na solicitação anterior. Deseja reenvia-lo?"
			If !lIsBlind .AND. MsgYesNo(STR0162, "Exclusao NF/Orc/Ped")
				RecLock( "SL1" )
				Replace SL1->L1_SITUA with "X0"
				SL1->( MsUnlock() )		
			EndIf
		EndIf
		
		//restaura a ?ea da SF2
		RestArea(aSF2Area)
	EndIf

Else
	lRet := .F.
EndIf

/* Grava SF3 online*/
If lRet .And. lFisLivro .And. cPaisLoc == "BRA" .And. lL1RETSFZ
	//Atualiza dados de Cancelamento de Documento Eletronico nas tabelas SL1, SF3, SFT.
	LjAtuCanc( "SL1", SL1->(Recno()) )
EndIf

RestArea(aArea)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Lj140VlEC  ³ Autor ³ Vendas Clientes      ³ Data ³28/jan/2015³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Programa de validação da exclusão de orçamento de venda EC  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Lj140VlEC()   		                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Lj140VlEC()	    
Local lRet 		:= .T.  //Retorno da rotina
Local cFormaPg 	:= ""	//Forma de Pagamento
Local lBaixa 	:= .F. //Exite baixa para o título
Local cParcela 	:= ""	//Parcela do Título
Local cPrefixo 	:= ""	//Prefixo do Título
Local cNum 		:= ""	//Numero do Título
Local cTipo 	:= ""	//Tipo do Título
Local cFornece 	:= ""	//Fornecedor
Local cLojaForn	:= ""	//Loja do Fornecedor
Local lGeraTaxa := SuperGetMV("MV_LJGERTX",,.F.) .AND. ExistFunc("L070IncSA2") //Gera Taxa   
Local cDocPed 	:= "" 	//Numero do Título associado no orçamento
Local cSerPed 	:= ""	//Serie do Pedido
Local aArea 	:= GetArea()  //WorkArea Ativa
Local aAreaSL1 	:= SL1->(GetArea()) //WorkArea do orçamento
Local aAreaSE2	:= SE2->(GetArea()) //WorkArea do Contas a Pagar
Local aAreaSE1	:= SE1->(GetArea()) //WorkArea do Contas a Receber
Local aSE1Found := {}	//[1]-indica se achou o registro na SE1 [2]-indica se a Filial esta compartilhada

cFormaPg := SL1->L1_FORMPG
cDocPed := SL1->L1_DOCPED
cSerPed := SL1->L1_SERPED
cFilRes := SL1->L1_FILRES
cPedRes := SL1->L1_PEDRES  

Lj140AdmSA2(@cFornece, @cLojaForn)
	
If !Empty(cDocPed+cSerPed) .AND. Empty(SL1->L1_DOC) .AND. Empty(SL1->L1_SERIE)
	//Exclui o título
	//verificar baixas	
		lBaixa := .F.

		aSE1Found := Lj140Seek( "SE1", 1, {xFilial("SE1"), cSerPed, cDocPed}, "E1_FILORIG" )
		If aSE1Found[1]
	
			While !lBaixa .AND. SE1->(!Eof()) .AND. (SE1->E1_FILIAL + SE1->E1_PREFIXO + SE1->E1_NUM) == (xFilial("SE1") + cSerPed + cDocPed) .AND.;
			AllTrim(SE1->E1_TIPO) == AllTrim(cFormaPg)
			
				If aSE1Found[2]
					aSE1Found[1] := SE1->E1_FILORIG == CFILANT
				EndIf
				
				If aSE1Found[1]
					cPrefixo 	:= SE1->E1_PREFIXO
					cNum 		:= SE1->E1_NUM
					cParcela 	:= SE1->E1_PARCELA
		 			cTipo		:= SE1->E1_TIPO
	
					lBaixa := SE1->(Round(E1_SALDO,2)) == 0  .OR. ;
					SE1->(ROUND(E1_SALDO,2) # ROUND(E1_VALOR,2) .AND. !FXAtuTitCo()) //Baixa do título parcial?
				EndIf
	
				SE1->( DbSkip() )                                                            
		    EndDo

		EndIf
	    
	    If lBaixa
    		//Já foi realizado baixa para uma das parcelas!
	   		If !lExcAuto
				MsgStop( STR0134 , STR0006 ) //"Já foi realizado baixa para uma das parcelas de contas a receber! " #"Atenção"
				lRet := .f.
			Else 
				LjGrvLog( SL1->L1_NUM , "Lj140VlEC " + STR0134 + cSerPed + "/" + cDocPed ) //"Já foi realizado baixa para uma das parcelas de contas a receber! "
				lRet := .F.
			EndIf 
		EndIf
		
	 	If lRet
			//Verifica baixa do SE2, caso exista
			If lGeraTaxa .AND.  RTrim(cTipo) $ "CC/CD"  .AND. !Empty(cFornece) .AND. !Empty(cLojaForn)
				SE2->(DbSetOrder(1))  //E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA                                                                                               
				lBaixa := .F.
				If SE2->(DbSeek(xFilial("SE2")+ cPrefixo + cNum + cParcela + cTipo + cFornece + cLojaForn))   
				
					Do While !lBaixa .And. SE2->(!Eof() .And. ;
										E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA  == xFilial("SE2")+ cPrefixo + cNum + cParcela + cTipo + cFornece + cLojaForn)
						lBaixa := SE2->(Round(E2_SALDO,2)) == 0  .Or. ;
								SE2->(ROUND(E2_SALDO,2) # ROUND(E2_VALOR,2) )  //Baixa do título parcial?
						SE2->(DbSkip())                                                            
				    EndDo
				EndIf
			    If lBaixa
		    		//Já foi realizado baixa para uma das parcelas!
			   		If !lExcAuto
						MsgStop( STR0135 , STR0006 ) //"Já foi realizado baixa para uma das parcelas de contas a pagar da Taxa Administrativa! "
						lRet :=  .f.
					Else 
						LjGrvLog( SL1->L1_NUM ,"Lj140VlEC " + STR0135 + cSerPed + "/" + cDocPed)    //"Já foi realizado baixa para uma das parcelas de contas a pagar da Taxa Administrativa! "
						lRet := .F.
					EndIf 
				EndIf
							
			EndIf
	 	EndIf
				
EndIf                  

RestArea(aAreaSL1)       
RestArea(aAreaSE1)
RestArea(aAreaSE2)    
RestArea(aArea)

Return lRet                

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Lj140ExR ³ Autor ³ Vendas Clientes      ³ Data ³28/jan/2015  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Programa de realização da exclusão de registros da enda EC  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Lj140ExR (cLogPath, cDocPed , cSerPed)                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Lj140ExR(cLogPath, cDocPed , cSerPed, cMsgErro)  
Local lRet 		:= .T.  //Retorno da rotina
Local aTitulo	:= {}   //Array do Título
Local cParcela 	:= ""  	//Parcela do Título
Local lGeraTaxa := SuperGetMV("MV_LJGERTX",,.F.) .AND. ExistFunc("L070IncSA2")  					// Verifica se ira gerar um Contas a Pagar quando existir taxa na admistradora do cartao.
Local cPrefixo 	:= ""	//Prefixo do Título
Local cNum 		:= "" 	//Numero do Título
Local cTipo 	:= "" 	//Tipo do Título
Local cFornece 	:= "" 	//Codigo do Fornecedor
Local cLojaForn	:= ""	//Loja do Fornecedor
Local aAreaSE1 := SE1->(GetArea())   //WorkAreaSE1
Local aAreaSE2 := SE2->(GetArea())	//WorkAreaSe2 
Local aSE1Found := {}	//[1]-indica se achou o registro na SE1 [2]-indica se a Filial esta compartilhada
Local cChaveSE1 := "" //Chave do título Processado
Local lErro		:= .F. //Erro na rotina


Default cLogPath :=  SuperGetMV("MV_LOGPATH",,"LOGS")     
Default cSerPed := ""
Default cDocPed := ""   
Default cMsgErro := ""


Private lMsHelpAuto := .T.

//Busca o fornecedor
Lj140AdmSA2(@cFornece, @cLojaForn) 

If !Empty(cDocPed) .AND. !Empty(cSerPed)
		
	//
	//Exclui o título e verifica as baixas
	//
 	aSE1Found := Lj140Seek( "SE1", 1, {xFilial("SE1"), cSerPed, cDocPed}, "E1_FILORIG" )
 	
 	Do While aSE1Found[1] .AND. lRet .AND. SE1->( !Eof() .AND. E1_FILIAL + E1_PREFIXO + E1_NUM == xFilial("SE1") + cSerPed + cDocPed )
		lErro := .F. 
		cMsgErro := ""

 		If aSE1Found[2]
 			 aSE1Found[1] := E1_FILORIG == CFILANT
		EndIf

		If aSE1Found[1]
 
			cPrefixo 	:= SE1->E1_PREFIXO
			cNum 		:= SE1->E1_NUM
			cParcela 	:= SE1->E1_PARCELA
	 		cTipo		:= SE1->E1_TIPO   
	 			 	
	 		cChaveSE1 := SE1->(E1_FILIAL + E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO)
	 			 	
			lMsErroAuto  := .F.
				
	 		aTitulo := {}
	 		
			aAdd( aTitulo, {"E1_PREFIXO", SE1->E1_PREFIXO 	, Nil} )
			aAdd( aTitulo, {"E1_NUM"	, SE1->E1_NUM		, Nil} )
			aAdd( aTitulo, {"E1_PARCELA", SE1->E1_PARCELA	, Nil} )
			aAdd( aTitulo, {"E1_TIPO"	, SE1->E1_TIPO		, Nil} )
			
	    	lECLJAUTO := .T.  //Seta para execauto do ecommerce
		    
			MSExecAuto({|x,y| FINA040(x,y) },aTitulo,5)
			
			If  lMsErroAuto
				lErro := .T.
				cMsgErro := MostraErro("\")
				
				cMsgErro := STR0136 + cSerPed + " - " + cDocPed + " - " + cParcela + CRLF + cMsgErro //"Problema na exclusão do Título de Contas a Receber: "
			Else 
				aSE1Found := Lj140Seek( "SE1", 1, {xFilial("SE1"), cPrefixo, cNum, cParcela, cTipo}, "E1_FILORIG" )
				If aSE1Found[1]
					aSE1Found[1] := E1_FILORIG == CFILANT
				EndIf
				If  aSE1Found[1]
					lErro := cChaveSE1 == SE1->(E1_FILIAL + E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO)
				EndIf
				If lErro
					cMsgErro := STR0194 + STR0197   + " [" + SE1->(E1_PREFIXO + E1_NUM + "/" + E1_PARCELA + "-" + E1_TIPO) + "]" //"Problemas na rotina de cancelamento de baixa do título vinculado ao Orçamento  " ## ". Chave do título "  
				EndIf
			EndIf
			
			
			If  lErro
				lRet := .F.
 			   	If !lExcAuto
					MsgStop( cMsgErro  , STR0006 ) //""Problema na exclusão do Título de Contas a Receber: "#"Atenção"
					lRet := .F.
				EndIf 
				LjGrvLog(SL1->L1_NUM,  cMsgErro )  //"Problema na exclusão do Título de Contas a Receber: "
	  
				Exit
				
			Else
				ConfirmSX8()
				
				//Deleta o Contas a pagar, caso exista
				//Verifica baixa do SE2, caso exista
				If lGeraTaxa .AND.  RTrim(cTipo) $ "CC/CD"  .AND. !Empty(cFornece) .AND. !Empty(cLojaForn)
					SE2->(DbSetOrder(1))  //E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA                                                                                               
					If SE2->(DbSeek(xFilial("SE2")+ cPrefixo + cNum + cParcela + cTipo + cFornece + cLojaForn))   
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Busca titulos em abertos relacionados atraves do campo 
						//³historico(E2_HIST) com a mesma sequencia de parcela    ³ 
						// VIDE Lj140ExCap 										  ³ 
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If AllTrim(SE2->E2_HIST) == AllTrim(cNum) .AND. AllTrim(SE2->E2_PARCELA) == AllTrim(cParcela)   
							RecLock("SE2",.F.)
							SE2->(DbDelete() )
							SE2->(MsUnlock() )
						Endif
					EndIf
				EndIf 
			EndIf                           

			aSE1Found := Lj140Seek( "SE1", 1, {xFilial("SE1"), cSerPed, cDocPed}, "E1_FILORIG" )

		EndIf			
	EndDo

EndIf

RestArea(aAreaSE1)
RestArea(aAreaSE2)  

Return lRet


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Lj140AdmSA2³ Autor ³ Vendas Clientes    ³ Data ³28/jan/2015  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Programa que inclui/retorna o fornecedor associado a Adm Fin³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Lj140AdmSA2(cFornece, cLojaForn)                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Lj140AdmSA2(cFornece, cLojaForn)     
Local lGeraTaxa 	:= SuperGetMV("MV_LJGERTX",,.F.) .AND. ExistFunc("L070IncSA2")  					// Verifica se ira gerar um Contas a Pagar quando existir taxa na admistradora do cartao.
Local cAdmFin := "" //Campo Administradora Financeira 
Local aAreaSL4 := SL4->(GetArea())
Local aAreaSA2 := SA2->(GetArea()) 

Default cFornece := "" 
Default cLojaForn := "" 

If lGeraTaxa
	SL4->(DbSetOrder(1)) //L4_FILIAL+L4_NUM+L4_ORIGEM   
	SL4->(DbSeek(SL1->L1_FILIAL + SL1->L1_NUM ))
	Do While SL4->(!Eof() .AND. L4_FILIAL+L4_NUM ==   SL1->L1_FILIAL + SL1->L1_NUM )   
	
		If Rtrim(SL4->L4_FORMA) $ "CC/CD"
			cAdmFin := Left( SL4->L4_ADMINIS, TamSx3("AE_COD")[1])				
			Exit
		EndIf
		SL4->(DbSkip(1))
	EndDo 
	If !Empty(cAdmFin)
			SAE->( DbSetOrder(1) ) //AE_FILIAL + AE_COD
			SAE->( Dbseek(xFilial("SAE") + cAdmFin) )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Inclui o Fornecedor caso nao tenha sido cadastrado,³
			//³e retorna com o codigo para gerar SE2              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cFornece := L070IncSA2()
			If RTrim(SA2->A2_COD) == RTrim(cFornece) 
				cLojaForn := SA2->A2_LOJA
			Else 	
				cLojaForn := "01"	 
			EndIf

	EndIf

EndIf

RestArea(aAreaSL4)
RestArea(aAreaSA2)

Return

//----------------------------------------------------------------
/*/{Protheus.doc} Lj140LstP
Realiza os estornos de Conta Corrente e Itens da Lista de Presente
@param	 cFilOrc - Filial do orçamento
@param	 cNumOrc - numero do orçamento
@author  Varejo
@version P11.8
@since   02/03/2015
@return  lRet - indica se os estornos foram realizados com sucesso
/*/
//----------------------------------------------------------------
Static Function Lj140LstP(cFilOrc, cNumOrc)

Local aSubOrc	:= {}
Local lRet		:= .F.
Local aSL1Area	:= SL1->( GetArea() )
Local aSL2Area	:= SL2->( GetArea() )
Local aDocs		:= {}
Local aL2Num	:= {}

DbSelectArea("SL1")
SL1->( DbSetOrder(1) )
If SL1->( DbSeek(cFilOrc + cNumOrc) )

	If !Empty(SL1->L1_DOC)
		aAdd(aDocs	,{SL1->L1_DOC,SL1->L1_SERIE}  )
	EndIf

	If !Empty(SL1->L1_DOCPED)
		aAdd(aDocs	,{SL1->L1_DOCPED,SL1->L1_SERPED}  )
	EndIf

	DbSelectArea("SL2")
	SL2->( DbSetOrder(1) )
	If SL2->( DbSeek(cFilOrc + cNumOrc) )
	
		While SL2->( !Eof() ) .AND. SL2->L2_FILIAL + SL2->L2_NUM == cFilOrc + cNumOrc	
			If !Empty(SL2->L2_FILRES) .AND. !Empty(SL2->L2_ORCRES)
				Aadd( aSubOrc, SL2->L2_ORCRES )
			EndIf

			If !Empty(SL2->L2_NUM)
				aAdd(aL2Num, SL2->L2_NUM)
			EndIf

			//estorna as quantidades dos itens da Lista de Presente
			If !Empty(SL2->L2_CODLPRE) .AND. !Empty( SL2->L2_ITLPRE )
				lRet := Lj8EstQtd( SL2->L2_CODLPRE, SL2->L2_ITLPRE, SL2->L2_QUANT )
			EndIf
			
			SL2->( DbSkip() )			
		EndDo
		
		//lança as contrapartidas da Conta Corrente da Lista de Presente
		If Len(aSubOrc) > 0
			lRet := Lj8EstCC( SL1->L1_FILIAL, aSubOrc, SL1->L1_CLIENTE, SL1->L1_LOJA )
		Else
			lRet := Lj8EstCC( SL1->L1_FILIAL, {SL1->L1_NUM}, SL1->L1_CLIENTE, SL1->L1_LOJA )
		EndIf

		//Informativo da operação de cancelamento no obs ou exclusao dos registros.
		//isso dependen do parametros na função.
		If ExistFunc("Lj8SetObs")
			lRet := Lj8SetObs(	SL1->L1_FILIAL	, iIf(Len(aSubOrc) > 0, aSubOrc, aL2Num), aDocs,;
									SL1->L1_CLIENTE	, SL1->L1_LOJA	)
		EndIf

	Else
		lRet := .F.
	EndIf    
Else
	lRet := .F.
EndIf

RestArea(aSL1Area)
RestArea(aSL2Area)

Return lRet


//----------------------------------------------------------------
/*/{Protheus.doc} LJ140Seek
Posiciona no registro correto da tabela, pois pode acontecer dela ser 
compartilhada e ter dois registros iguais (E1_NUM + E1_PREFIXO,
caso a SLG seja exclusiva), porém originados de filiais diferentes.
@param	 cTable - Tabela que sera usada
@param	 nIdxOrd - Indice que sera usado na busca
@param	 aKey - chave que sera utilizada na busca
@param	 cCpoFilOri - campo que identifica qual a Filial de Origem

@author  Varejo
@version P11.8
@since   13/04/2015
@return  aRet - [1]indica se posicionou no registro correto [2]indica se a Filial compartilhada
/*/
//----------------------------------------------------------------
Static Function LJ140Seek( cTable, nIdxOrd, aKey, cCpoFilOri )

Local cIndexKey		:= ""		//campos da chave do indice
Local cKey			:= ""		//valores da chave do indice
Local nI			:= 0		//contador
Local nFieldsIdx	:= 0		//quantidade de campos do indice que serao usados
Local lFound		:= .F.		//indica se achou o registro
Local lSeekAlt		:= .F.		//indica se a pesquisa sera baseada na filial de origem
Local aRet			:= {}		//[1] Se ACHOU o registro [2] se a Filial é COMPARTILHADA
Local lContinua 	:= .F.

Default cTable		:= ""		//alias da tabela
Default nIdxOrd		:= 0		//indice da tabela utilizado para pesquisa
Default aKey		:= {}		//vetor com os valores da chave do indice
Default cCpoFilOri	:= ""		//campo que indica a filial de origem

lSeekAlt := AllTrim(FWModeAccess(cTable)) == "C" .AND. AllTrim(FWModeAccess("SLG")) == "E" 

//obtem a quantidade de campos que serao utilizados para pesquisa
nFieldsIdx := Len(aKey)

//obtem os VALORES da chave que será pesquisado
For nI := 1 to nFieldsIdx
	cKey += aKey[nI]
Next

DbSelectArea(cTable)
DbSetOrder(nIdxOrd)
lContinua := &(cTable)->( DbSeek(cKey) )

If lContinua
	//Verifica se é o titulo pai (se tiver com o campo E1_TITPAI preenchido, é um título complementar de abatimento por exemplo: IS-, IR- PI- CS-, etc..)
	If !Empty(SE1->E1_TITPAI)
		//Ajusta a chave de busca para posicionar no título correto
		cKey := aKey[1]+SE1->E1_TITPAI
		lContinua := &(cTable)->( DbSeek(cKey) )
	EndIf
EndIf

If lContinua
	If lSeekAlt

		//obtem os campos da chave que serao utilizados, pois nem sempre o Seek usara todos os campos
		aIndexKey := StrTokArr( IndexKey(), '+' )
		For nI := 1 to nFieldsIdx
			cIndexKey += aIndexKey[nI]
			If nI <> nFieldsIdx
				cIndexKey += '+'
			EndIf		
		Next

		While &(cTable)->(!EoF()) .AND. &(cIndexKey) $ cKey
			If &(cCpoFilOri) == CFILANT
				lFound := .T.
				Exit
			Else
				&(cTable)->( DbSkip() )
				Loop
			EndIf
		End

	Else
		lFound := .T.
	EndIf
EndIf

Aadd(aRet, lFound)
Aadd(aRet, lSeekAlt)

Return aRet


//----------------------------------------------------------------
/*/{Protheus.doc} LJCANCNFCE
Funcao que devera ser executada em Job.
Faz o monitoramento das NFC-e que estao com cancelamento pendente,
sendo que se o cancelamento for autorizado, ela fará a exclusão da nota no ERP. 
@param	 cEmp - Grupo de Empresa
@param	 cFiliais - Filiais (se for mais de uma, deve-se separar por ;
@param	 cSleep - intervalo entre cada execução
@author  Varejo
@version P11.8
@since   08/09/2015
/*/
//----------------------------------------------------------------
Function LJCancNFCe( cEmp, cFiliais , cSleep )

Local nSleep		:= 0						//intervalo de execucao em milisegundos
Local nFilial		:= 1						//posicao do array que indica qual filial esta sendo processada
Local nTotFil		:= 0						//total de filiais a serem processadas
Local nVezes 		:= 0
Local lTrocaFil		:= .T.						//indica se deve haver a troca de filial a cada execucao do job
Local lAmbOk		:= .F.						//indica se o ambiente esta aberto
Local lFinaliza		:= .F.
Local lLjNFCeClr	:= ExistFunc("LJNFCECLR")	//funcao presente no LOJNFCE.PRW (depois da versao 4.0)
Local aFiliais		:= {}						//array com as filiais que serao processadas

Default cEmp		:= ""
Default cFiliais	:= ""
Default cSleep		:= "180"					//em segundos, pois sera convertido em milisegundos

/*
	Intervalo de processamento entre cada filial (também se aplica a uma unica filial)
	Multiplicamos por 1000, pois o parametro da funcao Sleep é em milisegundos
*/
nSleep := Val(cSleep) * 1000	

/*
	Obtem as filiais a serem processadas
*/
aFiliais := StrTokArr ( cFiliais, "," )
nTotFil	:= Len(aFiliais)

While !KillApp()

	While nFilial <= nTotFil
		
		/*
			Realiza a ABERTURA do ambiente
		*/
		If lTrocaFil
			
			RPCSetType(3) //Nao faz consumo de licença

			//realizamos a abertura do ambiente
			lAmbOk := RPCSetEnv(cEmp, aFiliais[nFilial], Nil, Nil, "LOJA")
			
			//Seta nModulo para 12 para garantir execucao via Loja
			nModulo := 12
			
			If !lAmbOk
				LjGrvLog( Nil, "Falha ao abrir o ambiente - Empresa: " + cEmp + " Filial: " + aFiliais[nFilial] )
				Exit
			Else
				LjGrvLog( Nil, "Aberto o ambiente - Empresa: " + cEmpAnt + " Filial: " + cFilAnt )
			EndIf
			
			//nova funcao para resetar as variaveis estaticas do LOJNFCE
			If lLjNFCeClr
				LjNFCeClr(1)
			EndIf
			
		EndIf

		lLxIteracao := SLX->(ColumnPos("LX_ITERACA") ) > 0 .And. SLX->(ColumnPos("LX_DULTPRC") ) > 0 .And. SLX->(ColumnPos("LX_HULTPRC") ) > 0

		//----------------------------------------------------
		// Faz o cancelamento da NFC-e com base na tabela SL1
		//----------------------------------------------------
		LjCanComL1()

		//-----------------------------------------------------------------
		// Faz o cancelamento/Inutilizacao da NFC-e com base na tabela SLX
		//-----------------------------------------------------------------
		LjCanComLX()

		If nFilial == nTotFil
			//Controle de vezes que o laco eh executado para cada filial
			nVezes++
		EndIf
		
		//Numero de vezes que executara o laco e depois derruba o JOB para desalocar memoria do server
		//Apos derrubar o JOB ele ira iniciar novamente conforme o tempo configurado no RefreshRate no ini do Server 
		If nVezes >= 10 .Or. dDataBase <> Date() //Varifica se a variavel dDatabase esta atualizada com a data atual (no caso do Job ficar em execucao por mais de um dia o dDataBase nao eh atualizado)
			LjGrvLog("","Finaliza o JOB (LJCancNFCe) de Cancelamento/Inutilizacao de NFC-e para que seja iniciado novamente.")
			lFinaliza := .T.
		EndIf
		
		/*
			Se FILIAL unica, nao e necessario abrir o ambiente a cada execucao
		*/
		If nTotFil == 1
			lTrocaFil := .F.
		Else
			lTrocaFil := .T.
			If nFilial < nTotFil
				nFilial += 1
			Else
				nFilial := 1
			EndIf
			
			RESET ENVIRONMENT
			
			lAmbOk := .F.
		EndIf
		
		If lFinaliza //Finaliza o JOB
			Exit
		EndIf
		
		/*
			EXECUTA O INTERVALO A CADA PROCESSAMENTO
		*/
		If nSleep > 0			
			Sleep(nSleep)
		EndIf	
	EndDo
	
	If lFinaliza //Finaliza o JOB
		Exit
	EndIf

EndDo

If lAmbOk
	//fecha o ambiente antes de sair da funcao
	RESET ENVIRONMENT
EndIf

Return Nil


//----------------------------------------------------------------
/*/{Protheus.doc} LJ140ATUSIT
Função responsavel em atualizar a situação de uma nota que deverá 
ser cancelada. Para NFC-e, nos baseamos no status da venda no TSS,
onde usamos os campos STATUS e STATUSCANC da tabela SPED050. 
@param	 cNum - numero do orcamento
@author  Varejo
@version P11.8
@since   08/09/2015
/*/
//----------------------------------------------------------------
Static Function Lj140AtuSit( cSitua, cSerie, cDoc, lInutiliza )
Local cNovoSitua	:= ""	//novo valor do campo L1_SITUA, baseado no STATUSCANC do TSS
Local lAtuSitua		:= .F.	//indica se o campo L1_SITUA devera ser atualizado
Local aNFCeID		:= {}	//vetor de NFEID (L1_SERIE+L1_DOC) que serao consultados no TSS
Local aNFCeDados	:= {}	//vetor retornado pelo TSS com o status de cada nota que foi consultado
Local lNFCeDll 		:= .F.  //Transmissao de NFCe por DLL
Local aRet			:= {}	//[1] indica se a venda tera o SITUA atualizado [2] novo valor do SITUA
Local oLOJGNFCE		:= Nil
Local lInteract		:= Iif(ExistFunc("LOJGNFCE"),GetApoInfo("LOJGNFCE.PRW")[4] >= CtoD("31/07/2019"),.F.)	
Local lLxIteracao   := SLX->(ColumnPos("LX_ITERACA") ) > 0 .And. SLX->(ColumnPos("LX_DULTPRC") ) > 0 .And. SLX->(ColumnPos("LX_HULTPRC") ) > 0  //indica se os campos estão presentes
Local cModDoc		:= Substr(SL1->L1_KEYNFCE,21,2)
Local aRetTSS		:= StrToKarr2(SL1->L1_RETSFZ,"|")
Local cRetSfz		:= iif( len(aRetTSS) > 2, aRetTSS[02], aRetTSS[01] )
Local lDenegada		:= .F.

Default cSitua		:= ""
Default cSerie		:= ""
Default cDoc		:= ""
Default lInutiliza	:= .F.

lNFCeDll := !lInutiliza .And. SL1->(ColumnPos("L1_TPTNFCE")) > 0 .AND. AllTrim(SL1->L1_TPTNFCE) == "0"  //Transmissao de NFCe por DLL

If lNFCeDll
	cNovoSitua := "X2"
	LjGrvLog( SL1->L1_NUM, "NFCe Cancelada pela DLL. So sera cancelada a nota no ERP ", cNovoSitua)
Else

	If cSitua == "X0" //Documento nao enviado ainda ao TSS para Cancelamento/Inutilizacao
		
		//Se Denegado, ja mudar para X2
		If cRetSfz $ RetCodDene()
			cNovoSitua 	:= "X2"	//-- Confirma Cancelamento	
			lAtuSitua	:= .T.
			lDenegada	:= .T.

		elseIf IsBlind()
			lAtuSitua := LjNFCeCanc( cSerie, cDoc, ,cModDoc )
		Else
			LjMsgRun( STR0127 + SL1->L1_NUM + STR0128 + SL1->L1_DOC,, {|| lAtuSitua := LjNFCeCanc(SL1->L1_SERIE, SL1->L1_DOC, ,cModDoc)} )
			//"Aguarde... Cancelamento da NFC-e sendo processado via TSS. Orcamento:"  #" - Doc.:"				
		EndIf

		If lAtuSitua .and. !lDenegada
			cNovoSitua := "X1" //Documento enviado ao TSS para Cancelamento/Inutilização
		EndIf
	
	ElseIf cSitua == "X1" //Documento ja enviado ao TSS para Cancelamento/Inutilizacao
		
		//obtemos somente as NFEID (L1_SERIE+L1_DOC)
		Aadd( aNFCeID, cSerie + cDoc )
	
		// obtemos os status da nota no TSS
		aNFCeDados := LjNFCeGtID(aNFCeID)

		LjGrvLog(SL1->L1_NUM, "Dados da NFC-e: ", aNFCeDados)
	
		If Len(aNFCeDados) > 0
		
			Do Case
				// CANCELAMENTO PENDENTE - mantemos o valor do L1_SITUA
				Case aNFCeDados[1][4] == "7" .AND. aNFCeDados[1][5] == "1"

				// CANCELAMENTO PROCESSADO - atualizamos o valor do L1_SITUA
				Case aNFCeDados[1][4] == "7" .AND. aNFCeDados[1][5] == "2"
					cNovoSitua := "X2"
					lAtuSitua := .T.
					/* Zerar quantidade de interações */
					If lInteract .AND. lLxIteracao
						oLOJGNFCE := LOJGNFCE():New()
						oLOJGNFCE:LjClearInteractSLX(SL1->L1_PDV,SL1->L1_DOC,SL1->L1_SERIE)
					EndIf 
				// CANCELAMENTO COM FALHA - atualizamos o valor do L1_SITUA
				Case aNFCeDados[1][4] == "7" .AND. aNFCeDados[1][5] == "3"
					cNovoSitua := "X3"
					lAtuSitua := .T.
					LjGrvLog( SL1->L1_NUM, STR0100 ) //"Cancelamento NAO AUTORIZADO pelo SEFAZ. Verifique o status da nota no TSS"
				
				// retornou STATUS e/ou STATUSCANC invalidos para cancelamento
				Otherwise
					LjGrvLog( SL1->L1_NUM, STR0124, aNFCeDados )	//"Retorno INVALIDO para cancelamento"
					
			End Case
	
		Else
			lAtuSitua := .F.	
			LjGrvLog( SL1->L1_NUM, "Falha ao obter o status da NFC-e no TSS")
		EndIf

	ElseIf cSitua == "X3"  //Ocorreu algum problema (Cancelamento/Inutilizacao nao autorizado pelo SEFAZ)
		cNovoSitua := "X0"
		lAtuSitua := .T.
	EndIf

EndIf

Aadd(aRet, lAtuSitua)	//indica se o _SITUA sera atualizado (SL1 ou SLX)
Aadd(aRet, cNovoSitua)	//novo valor do _SITUA

Return aRet


//----------------------------------------------------------------
/*/{Protheus.doc} Lj140TlCTef
Função responsavel por abrir a tela de cancelamento do TEF

@param1	 lJob		- é job?
@param2	 lVendtef	- pago em TEF
@param3  oTef		- objeto do TEF
@Param4  lTefOk		- retorna status do cancelamento TEF
@param5  aRetCartao - array com o retorno do cartão
@param6  aCartaoSL4 - array com o conteudo do SL4
@author  Varejo
@version P11.8
@since   21/12/2015
/*/
//----------------------------------------------------------------
Function Lj140TlCTef(	lJob		, lVendTef	, oTef		, lTefOk,;
						aRetCartao	, aCartaoSL4, lCancECF 	)

Local lTemTefMan:= Empty(SL1->L1_HORATEF) //Indica se na venda teve TEF Manual (via POS)
Local lTry		:= .T.
Local lProssegue:= .F.
Local lProsNoCan:= .F.
Local nTry		:= 0
Local cMsg		:= ""

Default lCancECF	:= .F.

/*Cancela o TEF na Administradora*/
If lUsaTEF .Or. (lTemTefMan .AND. !isBlind())
	While lTry
		/*Se estiver configurado a CLISITEF, passa o objeto oTEF.*/
		If (cTipTef $ TEF_CLISITEF + ";" + TEF_NAO_USADO)
			Lj140CnAdm(@lJob, @lVendTef, @oTEF		, @lTefOk, @aRetCartao		, @aCartaoSL4		, @lTemTefMan	)
		ElseIf (cTipTef $ TEF_SEMCLIENT_DEDICADO + ";" + TEF_COMCLIENT_DEDICADO + ";" + TEF_DISCADO)
			Lj140CnAdm(@lJob, @lVendTef, /*@oTEF*/	, @lTefOk, /*@aRetCartao*/	, /*@aCartaoSL4*/	, @lTemTefMan	)
		EndIf
		
		If lCancECF .And. !lJob .AND. lVendTef .AND. !lTefOk
			
			If nTry <= 4
				nTry++
				cMsg := STR0202 + cValToChar(nTry) + " de 5 " //#" Conexão com o Gerenciador do TEF - Tentativa "
				MsgAlert(STR0203 + CHR(10)+ ; //#"O Cancelamento do TEF não ocorreu com sucesso, portanto"
						 STR0204 + CHR(10) +; //#"não será possível prosseguir pois os documentos fiscais"
						 STR0205 + CHR(10) +; //#"da venda já foram cancelados. O sistema tentará cancelar"
						 STR0206 + CHR(10) + CHR(13) +; //#"novamente."
						 STR0207 + CHR(10) + ; //#" Por favor, verifique o Gerenciador do TEF e/ou a conexão com o servidor."
						 STR0208 + CHR(10) + ; //#" Para que seja possível cancelar a transação!"
						 cMsg)
				
				LjGrvLog(Nil," Cancelamento de Venda -> " + cMsg)
				Sleep(1000)
			Else
				lProssegue := MsgYesNo(	Upper(STR0006) + CHR(10) + ; //#"Atenção"
										STR0209 + '5' + STR0210 + CHR(10) +; //#" Foram efetuadas " / #" tentativas de conexão com o TEF"
										STR0211 + CHR(10) +; //#" para cancelamento da transação e todas sem sucesso"
										STR0212 + CHR(10) + CHR(13) +; //#" Deseja prosseguir sem cancelar o TEF ?"
										STR0213 + CHR(10) + CHR(13) +; //#" Se Sim: o TEF, DEVERÁ SER CANCELADO MANUALMENTE posteriormente pelo menu Rotinas TEF"
										STR0214 +; //#" Se Não: será efetuada outras tentativas de conexão, pois o CF já foi cancelado"
										STR0215 ) //#" não tendo possibilidade de retornar ao status aberto"
				
				cMsg := "Tentativa de Cancelamento de TEF - Usuário (" + xNumCaixa() + ") Selecionou: " + CHR(10) + CHR(13)
				If lProssegue
					lTry	 := .F.
					lProsNoCan:= .T.
					cMsg += "o TEF deverá ser cancelado posteriormente pelo menu Rotinas TEF e o processo de cancelamento" +;
							" vai continuar - havendo pendência de cancelar a transação TEF" + CHR(10) +;
							" Dados da transação pendente -> L1_FILIAL (" + SL1->L1_FILIAL + ") " +;
							" + L1_NUM (" + SL1->L1_NUM + ") + L1_DOC (" + SL1->L1_DOC + ")" 
					Conout(cMsg)
				Else
					nTry := 0
					cMsg += "será efetuada outras tentativas de conexão, pois o CF já foi cancelado " +;
							"não tendo possibilidade de retornar ao status aberto" +;
							" Variavel nTry zerada, serão efetuadas 5 (novas) tentativas de cancelamento da transação TEF"
				EndIf
				
				LjGrvLog( Nil, cMsg)
			EndIf
		Else
			lTry := .F.
		EndIf
	End
	
	If !lJob .AND. lVendTef .AND. lTefOk .AND. !lProsNoCan

		RecLock("SL1",.F.)
		If cTipTEF == TEF_NAO_USADO .Or. lTemTefMan
			Replace SL1->L1_DOCCANC with SL1->L1_DOCTEF
			Replace SL1->L1_DATCANC with StrTran(DToC(dDataBase),"/","")
			Replace SL1->L1_HORCANC with SubStr(Time(), 1, 5)			
		ElseIf cTipTef $ TEF_CLISITEF
			Replace SL1->L1_DOCCANC with aRetCartao[1]:cDocCanRei
			Replace SL1->L1_DATCANC with StrTran(DToC(aRetCartao[1]:dDataCanRei),"/","")
			Replace SL1->L1_HORCANC with aRetCartao[1]:cHoraTrans
		ElseIf (cTipTef $ TEF_SEMCLIENT_DEDICADO + ";" + TEF_COMCLIENT_DEDICADO + ";" + TEF_DISCADO)
			If Len(aTefDados) > 0
				Replace SL1->L1_DOCCANC with aTefDados[1][6]
				Replace SL1->L1_DATCANC with aTefDados[1][12]
				Replace SL1->L1_HORCANC with aTefDados[1][7]
			EndIf 
		EndIf
		MsUnLock()
	Else
		If lProsNoCan
			cMsg := "Prosseguiu com o cancelamento sem cancelar a transação de cartão" + CHR(10) + CHR(13)
			cMsg += "TEF deverá ser CANCELADO MANUALMENTE via Rotinas TEF !!!!"
			lTefOk := .T.
			LjGrvLog( Nil,cMsg)
			Conout(cMsg)
		EndIf
	EndIf
EndIf

Return Nil						

//----------------------------------------------------------------
/*/{Protheus.doc} Lj7SLXDocE
Inclui na SLX a nota que ser enviada para cancelamento via JOB.

@author  Varejo
@version P11.8
@since   08/09/2015
/*/
//----------------------------------------------------------------
Function Lj7SLXDocE(cModDoc		, cDoc		, cSerie	, cPDV			,;
 					cOperador	, cSitua	, cMsgErro	, cSupervisor	,;
					cNumOrc		, cTpCanc	, cSituaca  , cUUID			,;
                    cProtoc     , cChvNfce  , cDtInut   , cRetSfz       )

Default cDoc		:= ""
Default cSerie		:= ""
Default cPDV		:= ""
Default cOperador	:= ""
Default cSitua		:= "OK"
Default cMsgErro	:= ""
Default cSupervisor	:= ""
Default cTpCanc 	:= "X"
Default cSituaca	:= "00"
Default cUUID		:= ""
Default cProtoc		:= ""
Default cChvNfce	:= ""
Default cDtInut		:= ""
Default cRetSfz		:= ""


If SLX->(ColumnPos("LX_MODDOC")) > 0

	DbSelectArea("SLX")
	SLX->( DbSetOrder(1) )	//LX_FILIAL + LX_PDV + LX_CUPOM + LX_SERIE + LX_ITEM + LX_HORA
	If !SLX->( DbSeek(xFilial("SLX") + cPDV + cDoc + cSerie) )
		
		RecLock("SLX", .T.)	
		
		Replace SLX->LX_FILIAL  with xFilial("SLX")
		Replace SLX->LX_PDV     with cPDV
		Replace SLX->LX_CUPOM   with cDoc
		Replace SLX->LX_SERIE   with cSerie
		Replace SLX->LX_HORA    with Time()
	
		Replace SLX->LX_OPERADO with cOperador		//SL1->L1_OPERADO
		Replace SLX->LX_DTMOVTO with DDATABASE
		Replace SLX->LX_TPCANC  with cTpCanc		// inutilizacao NFC-e
		Replace SLX->LX_SITUA   with cSitua
		Replace SLX->LX_MODDOC	with cModDoc		// novo campo
		Replace SLX->LX_SITUACA with cSituaca		
		
		If SLX->(ColumnPos("LX_MOTIVO")) > 0
			Replace SLX->LX_MOTIVO	with cMsgErro
		EndIf
		
		If !Empty(cSupervisor)
			Replace SLX->LX_SUPERVI with cSupervisor
		EndIf
		
		If SLX->(ColumnPos("LX_NUMORC")) > 0
			Replace SLX->LX_NUMORC with cNumOrc
		EndIf

		If SLX->(ColumnPos("LX_UUID")) > 0
			REPLACE SLX->LX_UUID WITH cUUID
		EndIf

        If SLX->(ColumnPos("LX_PRINUT")) > 0
            REPLACE SLX->LX_PRINUT WITH cProtoc 
        EndIf

        If SLX->(ColumnPos("LX_CHVNFCE")) > 0
            REPLACE SLX->LX_CHVNFCE WITH cChvNfce
        EndIf

        If SLX->(ColumnPos("LX_DTINUTI")) > 0
            cDtInut := Iif(Empty(cDtInut), DDATABASE, cDtInut)
            REPLACE SLX->LX_DTINUTI WITH cDtInut
        EndIf

        If SLX->(ColumnPos("LX_RETSFZ")) > 0
            REPLACE SLX->LX_RETSFZ WITH cRetSfz
        EndIf

		SLX->( MsUnlock() )
	EndIf

EndIf

Return Nil


//----------------------------------------------------------------
/*/{Protheus.doc} LjIncExcDoc
Efetua a inclusao e em seguida a exclusao da nota via rotina MATA920.
@param	 
@author  Varejo
@version P11.8
@since   08/09/2015
/*/
Function LjIncExcDoc(aSF2, aSD2)

Local lRet			:= .T.
Local cNumDoc		:= ""
Local cNumSerie 	:= ""
Local nPosDoc 		:= 0
Local nPosSerie		:= 0
Local lContinua 	:= .T.
Local cErro 		:= ""
Local oErrorBlock 	:= Nil
Local lErrorBlock	:= .F.

Default aSF2		:= {}
Default aSD2		:= {}

//variaveis ja declaradas no LOJA140
Private lMsHelpAuto := .T.
Private lMsErroAuto := .F.

If Len(aSF2) > 0 .AND. Len(aSD2) > 0
	
	nPosDoc		:= aScan(aSF2, {|x| x[1] == "F2_DOC"	} )
	nPosSerie	:= aScan(aSF2, {|x| x[1] == "F2_SERIE"	} )
	
	If nPosDoc > 0 .And. nPosSerie > 0
		cNumDoc		:= aSF2[nPosDoc][2]
		cNumSerie 	:= aSF2[nPosSerie][2]
		
		cNumDoc 	:= PadR(cNumDoc, TamSx3("FT_NFISCAL")[1])
		cNumSerie 	:= PadR(cNumSerie, TamSx3("FT_SERIE")[1])
		
		//Faz verificacao de protecao para ver se ja existe a nota cancelada.
		DbSelectArea("SFT")
		SFT->(DbSetOrder(1)) //FT_FILIAL+FT_TIPOMOV+FT_SERIE+FT_NFISCAL+FT_CLIEFOR+FT_LOJA+FT_ITEM+FT_PRODUTO
		If SFT->(DbSeek(xFilial("SFT")+"S"+cNumSerie+cNumDoc))
			If !Empty(SFT->FT_DTCANC)
				lContinua := .F. //Nao continua o processo de cancelamento da nota, pois a nota ja esta cancelada.
				lRet := .T. //Retorna .T. para indicar que esse processo ja foi realizado (a nota ja esta cancelada na SFT).
			EndIf
		EndIf
	EndIf
	
	If lContinua
		LjGrvLog( Nil, "Realizando a inclusao do DOC: [" + cNumDoc + "] Serie: [" + cNumSerie + "] para ser cancelado.")
		
		oErrorBlock := ErrorBlock( {|x| LjVerifErro(x, @lErrorBlock) } ) // muda code-block de erro

		Begin Transaction 

			BEGIN SEQUENCE

				// inclusao da nota pela rotina automatica MATA920
				MSExecAuto( {|x,y,z| MATA920(x,y,z)}, aSF2, aSD2, 3 )		// 3 - INCLUSAO

				//Verifica se ocorreu algum erro na INCLUSAO
				If lMsErroAuto
					cErro := MostraErro("\")
					conout(cErro)
					LjGrvLog( Nil, "Problema na inclusao do DOC: [" + cNumDoc + "] Serie: [" + cNumSerie + "]" + Chr(13) + cErro )
					DisarmTransaction()
					lRet := .F.
				ElseIf lErrorBlock
					BREAK
				Else
					LjGrvLog( Nil, "Inclusao do DOC: [" + cNumDoc + "] Serie: [" + cNumSerie + "] realizada com sucesso.")

					LjGrvLog( Nil, "Realizando a exclusao do DOC: [" + cNumDoc + "] Serie: [" + cNumSerie + "]")
					// exclui a nota na base pela rotina automatica MATA920
					MSExecAuto( {|x,y,z| MATA920(x,y,z)}, aSF2, aSD2, 5 )	// 5 - EXCLUSAO
					
					//Verifica se ocorreu algum erro na EXCLUSAO
					If lMsErroAuto
						cErro := MostraErro("\")
						conout( cErro )
						LjGrvLog( Nil, "Problema na exclusao do DOC: [" + cNumDoc + "] Serie: [" + cNumSerie + "]" + Chr(13) + cErro )
						DisarmTransaction()
						lRet := .F.
					ElseIf lErrorBlock
						BREAK
					Else
						LjGrvLog( Nil, "Exclusao do DOC: [" + cNumDoc + "] Serie: [" + cNumSerie + "] realizada com sucesso.")
					EndIf
				EndIf

			RECOVER
				
				LjGrvLog( Nil, "Ocorreu problema ao tentar efetuar o cancelamento do DOC: [" + cNumDoc + "] Serie: [" + cNumSerie + "]" )
				DisarmTransaction()
				lRet := .F.
				
			END SEQUENCE

		End Transaction

		ErrorBlock(oErrorBlock)

	EndIf
Else
	lRet := .F.
EndIf

LjGrvLog( Nil, "Retorno da funcao LjIncExcDoc (variavel lRet)", lRet )

Return lRet

//----------------------------------------------------------------
/*/{Protheus.doc} LJNOTA2920
Retorna o cabecalho (SF2) e os itens (SD2) da nota fiscal.
@param	 
@author  Varejo
@version P11.8
@since   08/09/2015
/*/
Static Function LJNOTA2920(cModelo, cDoc, cSerie, cChave, lVldDados, dDTMovto )

Local cMvInutCli 	:= ""
Local cMvInutPro 	:= ""
Local cMvInutTES 	:= ""
Local cMvInutLoj	:= ""
Local cEspecie		:= ""
Local nTamA1Cod	 	:= 0
Local nTamB1Cod		:= 0
Local nTamF4Cod		:= 0
Local lRetAux		:= .T.
Local aSF2			:= {}
Local aSD2			:= {}
Local aSD2Aux		:= {}
Local aRet			:= {}

Default cModelo		:= "65"
Default cDoc		:= ""
Default cSerie		:= ""
Default cChave		:= ""
Default lVldDados	:= .T.
Default dDTMovto	:= dDatabase

//
//parametros para geração da Nota Fiscal de Saida a ser inutilizada
//
cMvInutCli := SuperGetMV("MV_INUTCLI", .F., "")
cMvInutPro := SuperGetMV("MV_INUTPRO", .F., "")
cMvInutTES := SuperGetMV("MV_INUTTES", .F., "")
cMvInutLoj := SuperGetMV("MV_INUTLOJ", .F., "")

If Empty(cMvInutLoj)
	cMvInutLoj := "01"
EndIf

LjGrvLog( Nil, "Configuracao do parametro MV_INUTCLI", cMvInutCli )
LjGrvLog( Nil, "Configuracao do parametro MV_INUTPRO", cMvInutPro )
LjGrvLog( Nil, "Configuracao do parametro MV_INUTTES", cMvInutTES )
LjGrvLog( Nil, "Configuracao do parametro MV_INUTLOJ", cMvInutLoj )

//
//tratamento do tamanho dos campos para busca e insercao dos dados
//
nTamA1Cod	:= TamSX3("A1_COD")[1]
nTamB1Cod	:= TamSX3("B1_COD")[1]
nTamF4Cod	:= TamSX3("F4_CODIGO")[1]
nTamA1Loj	:= TamSX3("A1_LOJA")[1]

cMvInutCli	:= PadR(cMvInutCli, nTamA1Cod)
cMvInutPro	:= PadR(cMvInutPro, nTamB1Cod)
cMvInutTES	:= PadR(cMvInutTES, nTamF4Cod)
cMvInutLoj	:= PadR(cMvInutLoj, nTamA1Loj)
//
// tratamento para obter a especie da nota
//
If cModelo == "65"
	cEspecie := "NFCE"
ElseIf cModelo == "55"
	cEspecie := "SPED"
ElseIf cModelo == "59"
	cEspecie := "SATCE"
Else		
	lRetAux := .F.
	LjGrvLog( Nil, "modelo de documento invalido", cModelo )
EndIf

If lRetAux
	// montagem do cabecalho da nota
	Aadd( aSF2, {"F2_TIPO"		, "N"			, Nil} )
	Aadd( aSF2, {"F2_FORMUL"	, " "			, Nil} )
	Aadd( aSF2, {"F2_DOC"		, cDoc			, Nil} )
	Aadd( aSF2, {"F2_SERIE"		, cSerie		, Nil} )
	Aadd( aSF2, {"F2_EMISSAO"	, dDTMovto		, Nil} )
	Aadd( aSF2, {"F2_CLIENTE"	, cMvInutCli	, Nil} )
	Aadd( aSF2, {"F2_LOJA"		, cMvInutLoj	, Nil} )
	Aadd( aSF2, {"F2_ESPECIE"	, cEspecie		, Nil} )
	Aadd( aSF2, {"F2_COND"		, "1"			, Nil} )
	Aadd( aSF2, {"F2_DESCONT"	, 0				, Nil} )
	Aadd( aSF2, {"F2_FRETE"		, 0				, Nil} )
	Aadd( aSF2, {"F2_SEGURO"	, 0				, Nil} )
	Aadd( aSF2, {"F2_DESPESA"	, 0				, Nil} )
	
	If cModelo == "59"
		Aadd( aSF2, {"F2_CHVNFE" , cChave		, Nil} )
	EndIf

	// montagem do item a ser inserido no detalhe da nota
	Aadd( aSD2Aux, {"D2_COD"	, cMvInutPro	, Nil} )
	Aadd( aSD2Aux, {"D2_QUANT"	, 1				, Nil} )
	Aadd( aSD2Aux, {"D2_PRCVEN"	, 1				, Nil} )
	Aadd( aSD2Aux, {"D2_TOTAL"	, 1				, Nil} )
	Aadd( aSD2Aux, {"D2_TES"	, cMvInutTES	, Nil} )

	//inclui um item (aSD2Aux) no aSD2
	Aadd( aSD2, aSD2Aux )
	
	LjGrvLog( Nil, "Dados montados para prosseguir com inutilizacao/cancelamento do DOC: " + cDoc + " Serie: " + cSerie )
EndIf

aRet := { aClone(aSF2), aClone(aSD2) }

//resetamos os vetores
aSize( aSF2,0 )
aSize( aSD2,0 )
aSize( aSD2Aux, 0 )

lVldDados := lRetAux

Return aRet

//----------------------------------------------------------------
/*/{Protheus.doc} LjGetMDoc
Certificar se a venda eh com NFC-e ou NF-e.
@param	 aOrcamento - Orcamentos relacionados a venda.
@author  Varejo
@version P11.8
@since   02/06/2016
@return  lRet - indica se eh venda eh com NFC-e.
/*/
//----------------------------------------------------------------
Static Function LjGetMDoc( aOrcamento, cDoc, cSerie, cSitua, lIsNFeDen )

Local cModDoc	:= ""
Local nX		:= 0
Local aArea		:= GetArea() 			//guarda a area corrente
Local aAreaSL1	:= SL1->( GetArea() ) 	//guarda a Area do SL1 Atual
Local aAreaSF2	:= {}					//guarda a Area do SF2 Atual
Local aAreaSF3	:= {}					//guarda a Area do SF3 Atual
Local lMvCancNFe:= SuperGetMV("MV_CANCNFE", .F., .F.)
Local lL1SERSAT := SL1->(ColumnPos("L1_SERSAT")) > 0
Local cCodRetSEF	:= ""					// Codigo de retorno do SEFAZ

Default aOrcamento := {}
Default cDoc		:= ""
Default cSerie		:= ""
Default cSitua		:= ""
Default lIsNFeDen	:= .F.

//Percorre os orcamentos FILHOS
For nX := 1 To Len(aOrcamento)
	If !Empty(aOrcamento[nX][1]) .AND. !Empty(aOrcamento[nX][2])
		If SL1->( DbSeek(aOrcamento[nX][1] + aOrcamento[nX][2]) ) .AND. !Empty(SL1->L1_DOC) .And. !Empty(SL1->L1_SERIE)	//posiciona no sub-orcamento (Filho, com DOC e SERIE preenchido)
			Exit
		EndIf
	EndIf
Next nX

//
// obtem o modelo do documento
//
If SL1->L1_TPORC == 'E' .AND. ( !Empty(SL1->L1_KEYNFCE) .OR. SL1->L1_STORC == "A" ) .AND. IIF(lL1SERSAT, Empty(AllTrim(SL1->L1_SERSAT)),.T.)
	cModDoc := "65" // NFC-e
	
	cDoc 	:= SL1->L1_DOC
	cSerie	:= SL1->L1_SERIE 
	cSitua	:= SL1->L1_SITUA
	
ElseIf SL1->L1_TPORC == 'E' .AND. ( !Empty(SL1->L1_KEYNFCE) .OR. SL1->L1_STORC == "A" ) .AND. IIF(lL1SERSAT, !Empty(AllTrim(SL1->L1_SERSAT)),.T.)		
	cModDoc := "59" // SAT
	
	cDoc 	:= SL1->L1_DOC
	cSerie	:= SL1->L1_SERIE 
	cSitua	:= SL1->L1_SITUA

//somente verifica se NF-e, caso o Cancelamento por Etapas da NF-e estiver habilitado
ElseIf SL1->L1_IMPNF 
	
	/*
	TRATAMENTO PARA NOTA DENEGADA
	o processo de Cancelamento não funciona e 
	não vai para o TSS, portanto deve permitir 
	prosseguir como uma exclusão convencional de nota 
	*/
	LjGrvLog( NIL, "Parâmetro MV_CANCNFE [cancelamento automatico de NF-e] ", lMvCancNFe )
	
	DbSelectArea("SF3")
	aAreaSF3 := SF3->(GetArea())
	SF3->(DbSetOrder(5)) //F3_FILIAL+F3_SERIE+F3_NFISCAL+F3_CLIEFOR+F3_LOJA+F3_IDENTFT
	If SF3->(DbSeek(xFilial("SF3")+SL1->L1_SERIE+SL1->L1_DOC)) .And. SF3->F3_CODRSEF $ RetCodDene()
		lIsNFeDen := .T.
		LjGrvLog( NIL, "Cancelamento de NF-e Denegada - [Série | Nota Fiscal No.]", {SL1->L1_SERIE,SL1->L1_DOC} )
	EndIf
	cCodRetSEF := SF3->F3_CODRSEF
	RestArea(aAreaSF3)
	
	If !lIsNFeDen .AND. lMvCancNFe .AND. !Empty(cCodRetSEF)
		
		aAreaSF2 := SF2->( GetArea() )
	
		If SF2->( MsSeek(xFilial("SF2") + SL1->L1_DOC + SL1->L1_SERIE + SL1->L1_CLIENTE + SL1->L1_LOJA) )
			If "SPED" $ SF2->F2_ESPECIE
				cModDoc := "55"
				cDoc 	:= SL1->L1_DOC
				cSerie	:= SL1->L1_SERIE				
			EndIf
		EndIf
	
		//restaura a area do SF2
		RestArea(aAreaSF2)	
	
	ElseIf lIsNFeDen
		cModDoc := "55"
		cDoc 	:= SL1->L1_DOC
		cSerie	:= SL1->L1_SERIE
	EndIf
EndIf

//restaura a area do SL1
RestArea(aAreaSL1)
//restaura a area corrente
RestArea(aArea)

Return cModDoc

//----------------------------------------------------------
/*/{Protheus.doc} Lj140CXML
Converte um XML no formato string para um objeto da classe TXMLManager

@type function

@author  Varejo
@version P11.8
@since   20/10/2016

@param	cXML XML no formato string que será convertido	 
@return cStatus		Status da NFC-e
/*/
//----------------------------------------------------------
Static Function Lj140CXML(cXML)

Local lRetAux		:= .F.
Local oXMLAux		:= Nil
Local cStatus 		:= ""

Default cXML		:= ""

If !Empty(cXML)
	//instancia um objeto da classe TXML Manager
	oXMLAux := TXMLManager():New()

	// -- Realizo o encode para UTF-8 para evitar erros no Parse do XML.
	cXML := EncodeUtf8(cXML)

	//executa o PARSE na string XML
	lRetAux := oXMLAux:Parse( cXML )

	//registramos o NAMESPACE do arquivo XML
	If lRetAux
		lRetAux :=  oXMLAux:XPathRegisterNS( "ns", "http://www.portalfiscal.inf.br/nfe" )
		If !lRetAux
			LJGrvLog(Nil, "ERRO AO REGISTRAR O NAMESPACE", oXMLAux:Error() )
		EndIf
	Else
		If !Empty( oXMLAux:Error() )
			LJGrvLog(Nil, "ERRO AO EXECUTAR O METODO PARSE: ", oXMLAux:Error() )
		ElseIf !Empty( oXMLAux:Warning() )
			LJGrvLog(Nil, "ADVERTENCIA AO EXECUTAR O METODO PARSE: ", oXMLAux:Warning() )
		EndIf
	EndIf
	
	If oXMLAux:XPathHasNode( "/ns:retCancNFe" ) // Verifica se eh cancelamento
        cStatus := oXMLAux:XPathGetNodeValue( "/ns:retCancNFe/ns:infCanc/ns:nProt" ) + "|"  // Número do Protocolo da NFC-e
        cStatus += oXMLAux:XPathGetNodeValue( "/ns:retCancNFe/ns:infCanc/ns:cStat" ) + "|"  // Código do status da resposta
        cStatus += oXMLAux:XPathGetNodeValue( "/ns:retCancNFe/ns:infCanc/ns:xMotivo" )      // Descrição literal do status da resposta
    ElseIf oXMLAux:XPathHasNode( "/ns:retInutNFe" ) // Verifica se eh inutilizacao
        cStatus := oXMLAux:XPathGetNodeValue( "/ns:retInutNFe/ns:infInut/ns:nProt" ) + "|"  // Número do Protocolo da NFC-e
        cStatus += oXMLAux:XPathGetNodeValue( "/ns:retInutNFe/ns:infInut/ns:cStat" ) + "|"  // Código do status da resposta
        cStatus += oXMLAux:XPathGetNodeValue( "/ns:retInutNFe/ns:infInut/ns:xMotivo") + "|" // Descrição literal do status da resposta
        cStatus += StrTran(SubStr(oXMLAux:XPathGetNodeValue( "/ns:retInutNFe/ns:infInut/ns:dhRecbto"),1,10),"-","") // Data do retorno da Sefaz 
    EndIf
EndIf
	
Return cStatus
//----------------------------------------------------------
/*/{Protheus.doc} LJCancSAT
Efetua o cancelamento das tabelas fiscais para uma venda recuperada
no Protheus e cancelada no SAT.

@type function

@author  Varejo
@version P11.8
@since   29/11/2016

@param	cDoc - Documento fiscal
		cSerie - Serie do documento
		cFisCancel - Numero fiscal do cancelamento
@return lRet	-> .T. - Tabelas canceladas com sucesso
				-> .F. - Tabelas não canceladas
/*/
//----------------------------------------------------------
Function LJCancSAT(cDoc, cSerie, cFisCancel)
Local lRet			:= .T.
Local aNota		:= {}
Local aArea		:= GetArea()
Local aSF2Area	:= SF2->(GetArea())
Local aSF3Area	:= SF3->(GetArea())
Local aSFTArea	:= SFT->(GetArea())

Default cDoc			:= "" 
Default cSerie		:= ""
Default cFisCancel	:= ""

cNFisCanc := cFisCancel

lRet := LjVlParInu() //Valida se as configuracoes estao corretas para prosseguir

If lRet
	aNota := LjNota2920( "59", cDoc, cSerie , SL1->L1_KEYNFCE )

	//Realiza a inclusao
	lRet := LjIncExcDoc( aNota[1], aNota[2])
EndIf

SF2->(DBSetorder(1)) //F2_FILIAL + F2_DOC + F2_SERIE
If lRet .And. SF2->(Dbseek(xFilial("SF2")+cDoc+cSerie)) .And. SF2->(RecLock("SF2", .F.))
	SF2->F2_SERSAT := SL1->L1_SERSAT
	SF2->(MSUnlock())
EndIf

SF3->(DBSetOrder(6)) //F3_FILIAL + F3_NFISCAL + F3_SERIE
If lRet .And. SF3->(DBSeek(xFilial("SF3")+cDoc+cSerie))
	While	SF3->(!EOF()) .And.;
		SF3->(F3_FILIAL + F3_NFISCAL + F3_SERIE) == xFilial("SF3")+cDoc+cSerie

		If SF3->(RecLock("SF3", .F.))
			SF3->F3_OBSERV	:= CANCEL_SAT
			SF3->F3_SERSAT	:= SL1->L1_SERSAT
			If SF3->(ColumnPos("F3_NFISCAN")) > 0
				SF3->F3_NFISCAN	:= cNfisCanc
			EndIf
			SF3->(MSUnlock())
		Else
			lRet := .F.
		EndIf

		SF3->(DBSkip())
	End
Else
	lRet := .F.
EndIf

SFT->(DBSetOrder(6)) //FT_FILIAL + FT_TIPOMOV + FT_NFISCAL + FT_SERIE
If lRet .And. SFT->(DBSeek(xFilial("SFT")+"S"+cDoc+cSerie))
	While	SFT->(!EOF()) .And.;
		SFT->(FT_FILIAL + FT_TIPOMOV + FT_NFISCAL + FT_SERIE) == xFilial("SFT")+"S"+cDoc+cSerie

		If SFT->(RecLock("SFT", .F.))
			SFT->FT_OBSERV	:= CANCEL_SAT
			SFT->FT_SERSAT	:= SL1->L1_SERSAT
			If SFT->(ColumnPos("FT_NFISCAN")) > 0
				SFT->FT_NFISCAN	:= cNfisCanc
			EndIf
			SFT->(MSUnlock())
		Else
			lRet := .F.
		EndIf
		SFT->(DBSkip())
	End
Else
	lRet := .F.
EndIf

cNFisCanc := ""

RestArea(aSF2Area)
RestArea(aSF3Area)
RestArea(aSFTArea)
RestArea(aArea)

Return lRet
//----------------------------------------------------------
/*/{Protheus.doc} Lj7VdNoFis
Verifica se é uma venda sem documento fiscal (com itens itens Retira Posterior - não finalizada -  ou Entrega)
@type function
@param aOrcamento  - Array de orçamento onde
	[1] - Filial do orçamento-filho
	[2] - Numero do orçamento-filho
	[3] - Venda finalizada
	[4] - Existe Pedido amarrado
	[5] - Pedido com lista de Presente
@author  fabiana.silva
@version P11.8
@since   15/02/2017
@return lIsVdNoFis	-> .T.- É venda não-fiscal
				-> .F. - Não é venda não-fiscal
/*/
//-------------------------------------------------
Function Lj7VdNoFis(aOrcamento)
Local lIsVdNoFis := .F.
Local nC := 0 //contador de Pedido


For nC := 1 to Len(aOrcamento)

	If aOrcamento[nC][03] .Or. Empty(aOrcamento[nC, 02])
		//Já existe venda finalizada ou não é Pedido
		lIsVdNoFis := .F.
		Exit	
	ElseIf !aOrcamento[nC][03] .AND. !Empty(aOrcamento[nC, 02]) .AND. aOrcamento[nC][04]
		//Orçamento não Faturado com orçamento -filho e com pedido
		lIsVdNoFis := .T.		
	EndIf
Next nC


Return lIsVdNoFis

//----------------------------------------------------------
/*/{Protheus.doc} Lj140RtCp
Retorna os títulos de contas a Pagar da Guia associados ao título de contas a receber
@type function
@param cChaveSF6  - Chave da Tabela SF6, caso exista o registro
@param lFoundSE1  - Localizado o título na SE1
@param aChaveSL1 - Chave do Título Original
@author  fabiana.silva
@version P12.1.16
since   05/05/2017
@return aSE2Dados - Array com os títulos da Guia onde
aSE2Dados[1] - Recno do registro SE2
aSE2Dados[2] - Chave do Registro Se2
aSE2Dados[2] - Indice do Registro Se2
/*/
//-------------------------------------------------
Static Function Lj140RtCp(cChaveSF6, lFoundSE1, aChaveSL1)
//Retorna um array com os títulos de contas a pagar
Local cTipoDoc		:= ""
Local cPref			:= "" //prefixo do título
Local cNum			:= "" //numero do título
Local cE2Tipo		:= ""
Local cE2Parc		:= ""
Local lTemGuia		:= .F.	//indica que há guias geradas, logo podem haver títulos a pagar
Local cMVRECST		:= ""	//Parametro que será macro-executado para obter FORNECEDOR;LOJA
Local aMVRECST		:= {}	//array que armazena Fornecedor e Loja obtido do parametro MV_RECST+UF (F2_EST)
Local aRetSE2		:= {} //Contem o Prefixo, o Numero do Título, o Tipo a Parcela e o Fornecedor
Local nTamE2Pref	:= 0 //Tamanho do Campo E2_PREFIXO
Local nTamE2Num		:= 0 //Tamanho do Campo E2_NUM
Local cF2_Doc		:= "" // Campo F2_Doc
Local cF2_Serie		:= "" // Campo F2_Serie
Local cF2_Cliente	:= "" // Campo F2_Cliente
Local cF2_Loja		:= "" // Campo F2_Loja
Local aAreaSF2		:= {} //WorArea SF2
Local cEstNF		:= "" //Estado da nota
Local cNatISS	   	:= &(SuperGetMv("MV_ISS",,"")) // Guarda Natureza configurada para ISS

Default cChaveSF6	:= "" //Chave do título SF6
Default lFoundSE1	:= .F. //Achou o SE1

cE2Tipo := PadR( "TX", GetSX3Cache("E2_TIPO", "X3_TAMANHO") )

If lFoundSE1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//|    Localiza o registro do Contas a Pagar (quando houver Taxa de ISS)                                       |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	// Priemiro faz a busca pelo campo E2_TITPAI
	SE2->( DbSetOrder(17) )	//E2_FILIAL+E2_TITPAI  ( Campo E2_TITPAI composto de -> E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA )

	If SE2->( DbSeek( xFilial("SE2") + SE1->(E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO + E1_CLIENTE + E1_LOJA )) )

		While SE2->(!EOF()) .AND. AllTrim(SE2->E2_TITPAI) == AllTrim( SE1->(E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO + E1_CLIENTE + E1_LOJA) )
			
			If Alltrim(SE2->E2_NATUREZ) == Alltrim(cNatISS)
				aAdd(aRetSE2, { SE2->(Recno()), SE2->(E2_FILIAL + E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA)})
			EndIf			
			SE2->(DbSkip(1))
			
		EndDo

	Else

		SE2->( DbSetOrder(1) ) //E2_FILIAL + E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA

		If SE2->( DbSeek( xFilial("SE2") + SE1->E1_PREFIXO + SE1->E1_NUM ) )
			
			If SE2->E2_PREFIXO == cE2Tipo	

				Do While SE2->(!Eof() .AND. E2_FILIAL =  xFilial("SE2") .And. E2_PREFIXO = SE1->E1_PREFIXO .And.  E2_NUM  = SE1->E1_NUM  .And. E2_PARCELA = SE1->E1_PARCELA  .And.  E2_TIPO = cE2Tipo)

					If Alltrim(SE2->E2_NATUREZ) == "ISS"					
						aAdd(aRetSE2, { SE2->(Recno()), SE2->(E2_FILIAL + E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA)})
					EndIf
					SE2->(DbSkip(1))

				EndDo
			EndIf
			
		EndIf

	EndIf

EndIf

If AliasIndic("SF6")
	/*
		O campo F6_OPERNF da chave de busca está com o valor "2", pois se refere a operação de saída 
	*/
	cTipoDoc	:= PadR( AllTrim(SF2->F2_TIPO), GetSX3Cache("F6_TIPODOC", "X3_TAMANHO")  )	
	cF2_Doc		:= PadR( aChaveSL1[3], GetSX3Cache("F2_DOC", "X3_TAMANHO")  )
	cF2_Serie	:= PadR( aChaveSL1[2], GetSX3Cache("F2_SERIE", "X3_TAMANHO")  )
	cF2_Cliente	:= PadR( aChaveSL1[4], GetSX3Cache("F2_CLIENTE", "X3_TAMANHO")  )
	cF2_Loja	:= PadR( aChaveSL1[5], GetSX3Cache("F2_LOJA", "X3_TAMANHO")  )
	 
	SF6->( DbSetOrder(3) )	//F6_FILIAL + F6_OPERNF + F6_TIPODOC + F6_DOC + F6_SERIE + F6_CLIFOR + F6_LOJA
	If SF6->( DbSeek(xFilial('SF6') + '2' + cTipoDoc + cF2_Doc + cF2_Serie + cF2_Cliente + cF2_Loja) )
		
		lTemGuia	:= .T.
		cChaveSF6	:= xFilial('SF6') + '2' + cTipoDoc + cF2_Doc + cF2_Serie + cF2_Cliente + cF2_Loja
		nTamE2Pref	:= GetSX3Cache("E2_PREFIXO", "X3_TAMANHO")
		nTamE2Num	:= GetSX3Cache("E2_NUM", "X3_TAMANHO")
		
		If SF2->(Eof()) .OR. cF2_Doc + cF2_Serie + cF2_Cliente + cF2_Loja <> SF2->(F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA)
			aAreaSF2 := SF2->(GetArea())
			SF2->(DbSetOrder(1))
			If SF2->(DbSeek(xFilial("SF2") +  cF2_Doc + cF2_Serie + cF2_Cliente + cF2_Loja ))
				cEstNF :=  AllTrim(SF2->F2_EST)
			EndIf
			RestArea(aAreaSF2)	
		Else
			cEstNF :=  AllTrim(SF2->F2_EST)
		EndIf
		
		If !Empty(AllTrim(cEstNF))
			//obtem o FORNECEDOR e LOJA usados para criação dos titulos a pagar
			cMVRECST := '"MV_RECST' +  cEstNF + '"'
			cMVRECST := SuperGetMv(&cMVRECST)
	
			aMVRECST := StrToKarr(cMVRECST, ";")
			
			If Len(aMVRECST) >= 2
	
				aMVRECST[1] := PadR( aMVRECST[1], GetSX3Cache("E2_FORNECE", "X3_TAMANHO") )
				aMVRECST[2] := PadR( aMVRECST[2], GetSX3Cache("E2_LOJA", "X3_TAMANHO") )
				cE2Parc := Space( GetSX3Cache("E2_PARCELA", "X3_TAMANHO") )
	
				While SF6->(!EoF()) .AND. ;
				SF6->(F6_FILIAL + F6_OPERNF + F6_TIPODOC + F6_DOC + F6_SERIE + F6_CLIFOR + F6_LOJA) == cChaveSF6
	
					cPref := PadR( AllTrim(SubStr(SF6->F6_NUMERO, 1, 3)),  nTamE2Pref)
					cNum := PadR( AllTrim(SubStr(SF6->F6_NUMERO, 4)), nTamE2Num )
					
					//Adiciona dos dados do título a pagar que será excluído
					If SE2->( DbSeek(xFilial("SE2") + cPref + cNum + cE2Parc + cE2Tipo + aMVRECST[1] + aMVRECST[2]) )
						
						aAdd(aRetSE2, { SE2->(Recno()), SE2->(E2_FILIAL + E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA), 1})
					EndIf
					
					SF6->( DbSkip() )
				End
			Else
				LjGrvLog(Nil, "MV_RECST" + SF2->F2_EST + " com valor inválido:", aMVRECST)
			EndIf
		EndIf
	EndIf

	SF6->( DbCloseArea() )
EndIf

Return aRetSE2

//----------------------------------------------------------
/*/{Protheus.doc} LJ140BxCp
Localiza e verifica se existem baixas de Contas a Pagar associadas ao título ou ao orçamento excluído
@type function
@param aChave  - Chave do SL1Pai
@param aChaveSL1  - Chave do Orçamento Corrente
@author  fabiana.silva
@version P12.1.16
@since   05/05/2017
@return lRet - .t. -> Existem / .F. -> Não Existem
/*/
//-------------------------------------------------
Static Function LJ140BxCp(aChave, aChaveSL1)
Local lRet 		:= .F.
Local aAreaSE1 	:= {} //WorkArea SE1
Local aSE1Found := {} //SE1 Localizado
Local aArea 	:= GetArea()
Local cChaveSF6 := "" //Chave da tabela SF6

If cPaisLoc == "BRA" .And. Substr(SL1->L1_CONFVEN,6,1) <> "N"
	aAreaSE1 := SE1->(GetArea())
	aSE1Found := LJ140Seek( "SE1", 1, aChave, "E1_FILORIG" )	
	If aSE1Found[1]

		While !lRet .AND. SE1->(!Eof()) .AND. aChave[1] == SE1->E1_FILIAL .AND. aChave[2] == SE1->E1_PREFIXO .AND. aChave[3] == SE1->E1_NUM
			If aSE1Found[2]
				aSE1Found[1] := SE1->E1_FILORIG == cFilAnt
			EndIf
			
			If aSE1Found[1]
				aRetSE2 := Lj140RtCp(@cChaveSF6, .T., aChaveSL1)
				
				lRet := Lj140CpBx(aRetSE2) 
			EndIf
			SE1->(DbSkip(1))
		EndDo
	Else
		aRetSE2 := Lj140RtCp(@cChaveSF6, .F., aChaveSL1)
		lRet := Lj140CpBx(aRetSE2) 
	EndIf
	

	RestArea(aAreaSE1)
EndIf

RestArea(aArea)

Return lRet 
//----------------------------------------------------------
/*/{Protheus.doc} Lj140CpBx
Verifica se existem baixas para o título de Contas a Pagar
@type function
@param aRetSE2  - Titulos de Contas a Pagar

@author  fabiana.silva
@version P11.8
@since  05/05/2017
@return lRet - .t. -> Existem Baixas / .F. -> Não Existem Baixas
/*/
//-------------------------------------------------
Static Function Lj140CpBx(aRetSE2)
Local nI 		:= 0		
Local lRet 		:= .F.	
Local cMsg  	:= ""	
Local aAreaSE2 	:= SE2->(GetArea())
				
For nI := 1 to Len(aRetSE2)
	SE2->(DbGoTo(aRetSE2[nI, 1]))
	If !Empty(SE2->E2_BAIXA) .And. SE2->E2_VALOR != SE2->E2_SALDO
	    cMsg := STR0178 + CRLF + ; //"Já existe(m) baixa(s) para o(s) título de Contas a Pagar associado(s) a(s) guia(s) chave do título: "
	    STR0179 + SE2->E2_FILIAL + CRLF +; //Filial
	    STR0180 + SE2->E2_PREFIXO + CRLF +; //Prefixo
	    STR0181 + SE2->E2_NUM + CRLF +; //Número
	    STR0182 + SE2->E2_PARCELA + CRLF +; //Parcela
	    STR0183 + SE2->E2_TIPO + CRLF +; //Tipo
	    STR0184 + SE2->E2_FORNECE + CRLF +;//Fornecedor
	    STR0185 + SE2->E2_LOJA //Loja
	   	Help(,1,"NO140CANC",,cMsg, 1,0) 
		LjGrvLog(SL1->L1_NUM, cMsg)	
		lRet := .T.
	EndIf 			
Next
RestArea(aAreaSE2)	
				
Return lRet			

//--------------------------------------------------------
/*/{Protheus.doc} IntegDef()
Rotina para Definicao de Integracao via Mensagem Unica                
@param cXml		Conteudo da mensagem (XML)
@param cTypeTran	Tipo da transacao 
@param cTypeMsg	Tipo da mensagem

@author  alessandrosantos
@version P12.17
@since   14/09/2016
@return  aRet  Aray com resultado da execucao e a mensagem Xml de retorno
				aRet[1]-(boolean) Indica o resultado da execução da função
				aRet[2]-(caracter) Mensagem Xml para envio                                                                    
/*/
//--------------------------------------------------------
Static Function IntegDef( xEnt, nTypeTrans, cTypeMessage , cVersion, cTransaction, lJSon )
Local aRet := {}

Lj140StInD( .T. ) //Seta processamento EAI para .T.
aRet := LOJI140(xEnt, nTypeTrans, cTypeMessage,lJSon)
Lj140StInD( .F. )  //Seta processamento EAI para .F.

Return aRet

//--------------------------------------------------------
/*/{Protheus.doc} Lj140StInD()
Rotina para Setup de processamento de mensagem única              
@author  fabiana.silva
@version P12.17
@since   14/11/2017
@return  lIntDefPro  Indicativo de processamento de mensagem única                                                                    
/*/
//--------------------------------------------------------
Function Lj140StInD( lProc)
    lIntDefPro := lProc
Return lIntDefPro

//--------------------------------------------------------
/*/{Protheus.doc} Lj140GtInD()
Rotina para Get de processamento de mensagem única              
@author  fabiana.silva
@version P12.17
@since   14/11/2017
@return  lIntDefPro  Indicativo de processamento de mensagem única                                                                    
/*/
//--------------------------------------------------------
Function Lj140GtInD()
Return lIntDefPro

//--------------------------------------------------------
/*/{Protheus.doc} LjExclE5
Realiza a exclusao da baixa do contas a receber criado pelo loja
	
@author  Leandro Kenji
@version P12.1.17
@since   16/11/2017
@return  lRet	Informa se a baixa ocorreu com sucesso
/*/
//--------------------------------------------------------
Static Function LjExclE5(nRecSE5)

Local aArea			:= GetArea()
Local aFina070		:= {}
Local lRet			:= .T.
Local cLog			:= ""
Local lAutomato := If(Type("lAutomatoX")<>"L",.F.,lAutomatoX) 
Local lE1Baixado	:= If(Empty(SE1->E1_BAIXA),.T.,.F.)	// Verifica se o título está baixado

Private lMSErroAuto	:= .F.
Private lAutoErrNoFile := .F.
//Posiciona na SE5
DbSelectArea("SE5")
SE5->( dbGoTo(nRecSE5) )

//Posiciona na SA6
DbSelectArea("SA6")
SA6->( DbSetOrder(1) )
SA6->( DbSeek(xFilial("SA6")+SE5->E5_BANCO) )

If !lE1Baixado

	//Monta array para a ExecAuto
	aFina070 := {	{"E1_PREFIXO"  ,SE5->E5_PREFIXO        ,Nil    	},;
					{"E1_NUM"      ,SE5->E5_NUMERO         ,Nil    	},;
					{"E1_PARCELA"  ,SE5->E5_PARCELA        ,Nil    	},;
					{"E1_TIPO"     ,SE5->E5_TIPO           ,Nil    	},;
					{"AUTMOTBX"    ,"NOR"                  ,Nil    	},;
					{"AUTBANCO"    ,SE5->E5_BANCO	       ,Nil    	},;
					{"AUTAGENCIA"  ,SE5->E5_AGENCIA        ,Nil   	},;
					{"AUTCONTA"    ,SE5->E5_CONTA	       ,Nil    	},;
					{"AUTDTBAIXA"  ,SE5->E5_DATA   		   ,Nil    	},;
					{"AUTDTCREDITO",SE5->E5_DTDISPO        ,Nil   	},;
					{"AUTHIST"     ,SE5->E5_HISTOR	       ,Nil   	},;
					{"AUTJUROS"    ,0                      ,Nil		},;
					{"AUTVALREC"   ,SE5->E5_VALOR          ,Nil    	}}

	If !VerSenha(52)
		//Usuario não tem permissão para excluir movimento bancario
		If lAutomato .OR. IsBlind()
			Conout("O Movimento bancário não será excluído pois o usuário não tem permissão. Acesso de usuário Nº52")
			LjGrvLog( SL1->L1_NUM , "O Movimento bancário não será excluído pois o usuário não tem permissão. Acesso de usuário Nº52")
		Else
			MsgAlert(STR0198)//"O Movimento bancário não será excluído pois o usuário não tem permissão. Acesso de usuário Nº52"
		Endif 
	Endif 

	//Chama ExecAuto FINA070 para baixa automatica do titulo	
	MSExecAuto({|x,y| Fina070(x,y)},aFina070,6) 

	If !lMsErroAuto
		
		//Altera campos para compatibilizar com o padrao do Loja
		LjCompFKs()
	Else
		lRet := .F.
		
		cLog := MostraErro(IIF( lAutomato .or. IsBlind(), "\", ""))
		LjGrvLog( SL1->L1_NUM , STR0194 + CRLF + cLog) //"Problemas na rotina de cancelamento de baixa do título vinculado ao Orçamento"
		If !(lAutomato .or. IsBlind())
			Final(STR0195) //"Ocorreu uma falha ao cancelar o orçamento, o sistema será finalizado"
		EndIf
	EndIf

Else
	//Altera campos para compatibilizar com o padrao do Loja
	LjCompFKs()
EndIf

RestArea(aArea)

Return lRet

//--------------------------------------------------------
/*/{Protheus.doc} LjCompFKs
Altera os campos para utilizar o padrao do SigaLoja
	
@author  Leandro Kenji
@version P12.1.17
@since   13/11/2017
// @return  n/a
/*/
//--------------------------------------------------------
Static Function LjCompFKs()

Local aArea			:= GetArea()
Local aAreaFKA		:= FKA->( GetArea() )
Local cProcFKA		:= FKA->FKA_IDPROC
Local cRotBx		:= "LOJA140"

//Atualiza campos das FKs
dbSelectArea("FKA")
FKA->( dbSetOrder(2) )
FKA->( dbSeek( xFilial("FKA") + cProcFKA ) )
While FKA->( !EOF() ) .AND. ( xFilial("FKA") + cProcFKA == FKA->FKA_FILIAL + FKA->FKA_IDPROC )

	If FKA->FKA_TABORI == "FK1" .AND. ( FK1->FK1_TPDOC == "ES" )
	
		//Posiciona na tabela e altera os campos
		DbSelectArea("FK1")
		FK1->( dbSetOrder(1) )
		If FK1->( dbSeek( xFilial("FK1") + FKA->FKA_IDORIG ) )

			RecLock("FK1",.F.)
			FK1->FK1_ORIGEM := cRotBx
			FK1->( MsUnLock() )

		EndIf

	ElseIf FKA->FKA_TABORI == "FK5" .AND. ( FK5->FK5_TPDOC == "ES" )

		//Posiciona na tabela e altera os campos
		DbSelectArea("FK5")
		FK5->( dbSetOrder(1) )
		If FK5->( dbSeek( xFilial("FK5") + FKA->FKA_IDORIG ) )

			RecLock("FK5",.F.)
			FK5->FK5_ORIGEM := cRotBx
			FK5->( MsUnLock() )

		EndIf

	EndIf

	FKA->( dbSkip() )

End

RestArea(aAreaFKA)
RestArea(aArea)

Return

/*/{Protheus.doc} Lj140GEsPg
Gera Estorno de Pagamento
Deleta Titulo da venda na SE1 e grava registros na SE5 e tabelas FKs referente a Estorno de Pagamento.
Utilizado Model FINM010 o mesmo utilizado pelo módulo Financeiro.

@type       Function
@author     João Marcos Martins
@since      10/04/2018
@version    12.1.17
@param      cRecnoSE5 - RECNO da SE5
@return 
/*/
    
Function Lj140GEsPg(cRecnoSE5)
Local cCamposE5 := {}
Local oModel    := Nil  // Model da FINM010
Local oSubFKA   := Nil
Local cLog      := ""   // Log caso ocorra erro na gravacao
Local aAreaE5   := SE5->(GetArea())

LjGrvLog(SE1->E1_NUM, " Gerando estorno de movimentacao bancaria.",  ) 

SE5->(dbGoTo(cRecnoSE5))
   
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Obtem os dados do registro da baixa do titulo  ³
//³ para gerar um registro de estorno              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cCamposE5 := "{"                                              
cCamposE5 += "{'E5_KEY'     ,E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIENTE+E5_LOJA } "        
cCamposE5 += ",{'E5_PREFIXO', '' }"
cCamposE5 += ",{'E5_NUMERO' , '' }"
cCamposE5 += ",{'E5_PARCELA', '' }"
cCamposE5 += ",{'E5_TIPO'   , '' }"
cCamposE5 += "}"
                            
oModel :=  FWLoadModel('FINM010') 
oModel:SetOperation( 4 ) 
oModel:Activate()
oSubFKA := oModel:GetModel( "FKADETAIL" )
oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )
oSubFKA:SeekLine( { {"FKA_TABORI", "FK1" } } )

oModel:SetValue( "MASTER", "E5_GRV"     , .T. )         //Habilita gravação de SE5 
oModel:SetValue( "MASTER", "E5_CAMPOS"  , cCamposE5 )   //Informa os campos da SE5 que serão gravados indepentes de FK1
oModel:SetValue( "MASTER", "E5_OPERACAO", 2 )           //E5_OPERACAO 2 = Altera E5_TIPODOC da SE5 para 'ES' e gera estorno na FK1
oModel:SetValue( "MASTER", "HISTMOV"    , OemToAnsi(STR0196)) //"Cancelamento de baixa"
        
//Dados do movimento
oSubFK5 := oModel:GetModel( "FK1DETAIL" )
oSubFK5:SetValue( "FK1_LA"      , "N" )
oSubFK5:SetValue( "FK1_RECPAG"  , "P" )
oSubFK5:SetValue( "FK1_HISTOR"  , STR0196 ) // "Cancelamento de baixa"

If oModel:VldData()
    oModel:CommitData()
    oModel:DeActivate()
    
    FKCOMMIT() 
    LjGrvLog(SE1->E1_NUM, " Fim da geracao do estorno de movimentacao bancaria.", )       
Else
    cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
    cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
    cLog += cValToChar(oModel:GetErrorMessage()[6])             
    LjGrvLog(SE1->E1_NUM, " Falha na geracao do estorno de movimentacao bancaria.", cLog )
Endif

RestArea(aAreaE5)

Return 

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} LjVerifErro
Funcao de tratamento de bloco de erro. Substitui o bloco de erro padrao do sistema para que nao seja derrubada a Execucao do JOB.

@type       Function
@author     Alberto Deviciente
@since      08/10/2018
@version    12
@param      e - Objeto contendo os detalhes do error.log
@param      lErrorBlock - Parametro passado por referencia para setar quando ocorre erro.
@return 	Lógico
/*/
//---------------------------------------------------------------------------------------
Static Function LjVerifErro(e, lErrorBlock)
Local lRet 			:= .F.
Local cDescErro 	:= ""

IF e <> Nil .And. e:gencode > 0

	lErrorBlock := .T.

	cDescErro := "DESCRIPTION: " + e:DESCRIPTION + Chr(13)+Chr(10)
    cDescErro += "ERRORSTACK:" + Chr(13)+Chr(10)
    cDescErro += e:ERRORSTACK

	LjGrvLog( Nil, "Ocorreu um erro nao esperado:", cDescErro, .T. )
	ConOut("Ocorreu um erro nao esperado: " + cDescErro)

EndIf

Return lRet

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} LjCanComL1
Faz o cancelamento da NFC-e ou NF-e com base na tabela SL1.

@type       Function
@author     Alberto Deviciente
@since      22/10/2018
@version    12
@return 	Nil, Nulo
/*/
//---------------------------------------------------------------------------------------
Function LjCanComL1()
Local nMVLJRECNR	:= SuperGetMv("MV_LJRECNR",,1)	//Quando o cancelamento for rejeitado(X3), indica se deve reenviar(1) ou nao(2)
Local aArea			:= {}
Local aRecnos 		:= {}
Local nI			:= 0
Local xRet140		:= Nil
Local cId			:= "" 								//Id do documento no TSS
Local oLOJCNFCE		:= Nil								//Constroi o objeto LOJCNFCE
Local nMvLjTpCan	:= SuperGetMV("MV_LJTPCAN",,1) 		//Parametro que indica se utiliza o novo processo de cancelamento
Local oLOJGNFCE		:= Nil								//Constroi a classe LOJGNFCE
Local lInteract		:= Iif(ExistFunc("LOJGNFCE"),GetApoInfo("LOJGNFCE.PRW")[4] >= CtoD("31/07/2019"),.F.)	
Local lLxIteracao   := SLX->(ColumnPos("LX_ITERACA") ) > 0 .And. SLX->(ColumnPos("LX_DULTPRC") ) > 0 .And. SLX->(ColumnPos("LX_HULTPRC") ) > 0  //indica se os campos estão presentes 
Local cPdv			:= ""								//Armazena o numero do PDV
Local cDoc 			:= ""								//Armazena o numero do Documento
Local cSerie		:= ""								//Armazena o numero da Serie 

LjGrvLog( Nil, "INICIO - Processo de cancelamento dos documentos eletronicos com base na tabela SL1." )

DbSelectArea("SL1")
SL1->( DbSetOrder(9) )	//L1_FILIAL + L1_SITUA + L1_PDV + L1_DOC
If SL1->( DbSeek(xFilial("SL1") + "X") )

	//-----------------------------------------------------------------
	// Obtemos os dados das vendas que estao com cancelamento pendente
	//-----------------------------------------------------------------
	While SL1->(!Eof()) .AND. SL1->L1_FILIAL + SubStr(SL1->L1_SITUA,1,1) == xFilial("SL1") + "X"
		If lInteract .AND. lLxIteracao
			oLOJGNFCE  := LOJGNFCE():NEW()
			nMVLJRECNR := 1 //Inicialmente realizaremos a alteração somente para clientes que tenham os fontes atualizados. 
		EndIf 
		//Valida se Reenvia notas canceladas já rejeitadas ao SEFAZ ou se execedeu o numero de tentativas
		If !( nMVLJRECNR == 2 .AND. SL1->L1_SITUA == "X3" .AND. Empty(SL1->L1_STORC) ) .AND. (lInteract .AND. lLxIteracao .AND. oLOJGNFCE:LjCheckInteractSLX(SL1->L1_PDV,SL1->L1_DOC,SL1->L1_SERIE,SL1->L1_SITUA) .Or. (!lInteract .OR. !lLxIteracao ) ) 
		
			//Se for um orcamento filho, posicionamos no orcamento pai (L1_ORCRES)
			If !Empty(SL1->L1_FILRES) .AND. !Empty(SL1->L1_ORCRES)
				
				aArea := SL1->( GetArea() )

				SL1->( DbSetOrder(1) )
				If SL1->( DbSeek( SL1->L1_FILRES + SL1->L1_ORCRES) )
					/* Se For X2 atualizo o numero de tentativas */
					If lInteract .AND. lLxIteracao 
						oLOJGNFCE:LjAddInteractSLX(SL1->L1_PDV,SL1->L1_DOC,SL1->L1_SERIE,SL1->L1_SITUA)
					EndIf 
					Aadd( aRecnos, SL1->(Recno()) )
				Else
					conout("Job LJCancNFCe - orcamento filho nao localizado")
				EndIf

				RestArea(aArea)
			Else
				/* Se For X2 atualizo o numero de tentativas */
				If lInteract .AND. lLxIteracao 
					oLOJGNFCE:LjAddInteractSLX(SL1->L1_PDV,SL1->L1_DOC,SL1->L1_SERIE,SL1->L1_SITUA)
				EndIf 
				Aadd( aRecnos, SL1->(Recno()) )
			EndIf
		
		EndIf	

		SL1->( DbSkip() )
	EndDo

EndIf

LjGrvLog( Nil, "Quantidade de registros na tabela SL1 pendentes para cancelamento: " + AllTrim(Str(Len(aRecnos))) )

//--------------------------------------------------------------------------------------------
// Chama a funcao padrao de exclusao, onde ela fara a validacao se a venda pode ser cancelada
//--------------------------------------------------------------------------------------------
If Len(aRecnos) > 0
	For nI := 1 to Len(	aRecnos )
		SL1->( DbGoTo(aRecnos[nI]) )
		
		If (nMvLjTpCan == 2 .OR. nMvLjTpCan == 3)
			
			oLOJCNFCE := LOJCNFCE():New()
			cId := SL1->(L1_SERIE+L1_DOC)
			
			If !Empty(cId)
				//----------------------------------------------------
				//Monitora as notas e atualiza o status na tabela SL1.
				//----------------------------------------------------
				oLOJCNFCE:LjAtualizaL1Situa(cId,aRecnos[nI])
			EndIf

		EndIf 

		//------------------------------------------------------------------
		// Reposicionamos a estação, quando executado o cancelamento via Job
		//------------------------------------------------------------------
		cEstacao  := SL1->L1_ESTACAO

		/* Armazeno PDV Doc e Serie para ser usada para limpar SLX  */
		cPdv    := SL1->L1_PDV
		cDoc    := SL1->L1_DOC
		cSerie  := SL1->L1_SERIE

		xRet140 := Lj140Exc( "SL1", aRecnos[nI], 2, Nil, .T., SL1->L1_FILIAL, SL1->L1_NUM )
		If ValType(xRet140) == "N"
			If xRet140 <> 1 
				LjGrvLog(SL1->L1_NUM, "Falha ao efetuar o cancelamento" )
			Else
				/* Caso tenha conseguido cancelar Limpo as interações e removo e Status de ERRO */
				If lInteract .AND. lLxIteracao
					oLOJGNFCE:LjClearInteractSLX(cPdv,cDoc,cSerie)
				EndIf 
			EndIf
		Else
			LjGrvLog( SL1->L1_NUM, "Retorno desconhecido do cancelamento: ", xRet140 )
		EndIf
	Next
EndIf

LjGrvLog( Nil, "FIM - Processo de cancelamento dos documentos eletronicos com base na tabela SL1." )

Return

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} LjIncDocCan
Inclui o DOC no Protheus como "Cancelado".

@type       Function
@author     Alberto Deviciente
@since      23/10/2018
@version    12
@return 	Nil
/*/
//---------------------------------------------------------------------------------------
Function LjIncDocCan()
Local aRecnos 		:= {}
Local nX 			:= 0
Local lVldNota2920 	:= .T.
Local lRet 			:= .T.
Local aNota 		:= {}
Local aDadoInut		:= {}
Local lRMIDadoInu	:= ExistFunc("RMIDadoInu")
Local lLXUUID		:= SLX->(ColumnPos("LX_UUID")) > 0

//Busca por registros LX_SITUA = "X2" (Doc de cancelamento/inutilização autorizado pelo SEFAZ)
aRecnos := LjFilterLX( {"X2"} )

LjGrvLog( "", "Quantidade de DOCs de Inutilizacao na tabela SLX (LX_SITUA = X2) autorizado pelo SEFAZ: " + AllTrim(Str(Len(aRecnos))) )

For nX := 1 to Len(	aRecnos )
	SLX->( DbGoTo(aRecnos[nX]) )

	LjGrvLog( SLX->LX_CUPOM, "INICIO - Cancelamento do DOC : [" + SLX->LX_CUPOM + "] Serie: [" + SLX->LX_SERIE + "] nas tabelas fiscais do Protheus (SFT, SF3)." )

	//Reinicialização das variáveis
	lVldNota2920 := .T.
	lRet		 := .T.
	aDadoInut	 := {}
	
	//Efetua a pesquisa dos dados da inutilização recebida via Integração
	If lRMIDadoInu .And. lLXUUID .And. !Empty(SLX->LX_UUID)
		aDadoInut := RMIDadoInu(AllTrim(SLX->LX_UUID))
        If Empty(aDadoInut)
            lRet := .F.
            LjAtualSLX("ER") //Muda o Status como: Ocorreu erro ao tentar Incluir a Documento e Cancelar nas tabelas do Protheus (SF2, SD2, SFT, SF3).
            LjGrvLog( SLX->LX_CUPOM, "Falha ao gerar os registros fiscais do Doc [" + SLX->LX_CUPOM + "] Serie: [" + SLX->LX_SERIE + "]" )
            Return
        EndIF
	EndIf

	//--------------------------------------------------------------
	// Inclui os registros fiscais das notas que foram inutilizadas
	//--------------------------------------------------------------
	  
    //Retorna o cabecalho (SF2) e os itens (SD2) da nota fiscal
    aNota := LjNota2920( SLX->LX_MODDOC, SLX->LX_CUPOM, SLX->LX_SERIE, Nil, @lVldNota2920, SLX->LX_DTMOVTO )
    
    If lVldNota2920
        //realiza a inclusao e exclusao da nota fiscal
        lRet := LjIncExcDoc( aNota[1], aNota[2] )

        LjGrvLog( SLX->LX_CUPOM, "Inutilizacao - Retorno LjIncExcDoc - (Realizou a inclusao e exclusao da nota fiscal?)", lRet )
        If lRet
            LjAtualSLX("  ") //Muda o Status como: Documento cancelado no Protheus (SFT, SF3). Processo de Cancelamento/Inutilização concluído por completo.
            LjGrvLog( SLX->LX_CUPOM, "Doc [" + SLX->LX_CUPOM + "] Serie: [" + SLX->LX_SERIE + "] cancelado/inutilizado com sucesso." )
        Else
            LjAtualSLX("ER") //Muda o Status como: Ocorreu erro ao tentar Incluir a Documento e Cancelar nas tabelas do Protheus (SF2, SD2, SFT, SF3).
            LjGrvLog( SLX->LX_CUPOM, "Falha ao gerar os registros fiscais do Doc [" + SLX->LX_CUPOM + "] Serie: [" + SLX->LX_SERIE + "]" )
        EndIf

    Else
        lRet := .F.
        LjGrvLog( SLX->LX_CUPOM, "As informações para a Validação dos Dados da Inutilização da venda NFC-e não estão corretas. Verifique:" + CHR(10) + CHR(13)+;
                        " Mensagens anteriores do Log / Configuração dos Parâmetros / Consistência das informações/dados dos parâmetros.")
    EndIf
    
    If lRet
        LjGrvLog( SLX->LX_CUPOM, "Atualiza dados de Inutilizacao de Documento Eletronico nas tabelas SF3 e SFT. DOC: [" +;
                SLX->LX_CUPOM + "] Serie: [" + SLX->LX_SERIE + "] Modelo: [" + SLX->LX_MODDOC + "]" )

        //Atualiza dados de Inutilizacao de Documento Eletronico nas tabelas SF3, SFT.
        LjAtuCanc( "SLX", SLX->(Recno()) , aDadoInut)
    EndIf

    LjGrvLog( SLX->LX_CUPOM, "FIM - Cancelamento do DOC : [" + SLX->LX_CUPOM + "] Serie: [" + SLX->LX_SERIE + ;
                                "] nas tabelas fiscais do Protheus (SFT, SF3)." )

Next nX

Return

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} LjAtuCanc
Atualiza dados de Cancelamento ou Inutilizacao de Documento Eletronico nas tabelas SL1, SF3, SFT.

@type       Function
@author     Alberto Deviciente
@since      23/10/2018
@version    12
@param      cTabela, Caracter, Alias da tabela de Origem que solicitou o Cancelamento (SL1) ou Inutilizacao (SLX)
@param      nRecnoReg, Numerico, Recno do Registro da tabela passada no primeiro parametro
@param		aDadoInut, array, contem as informações de Inutilização quando for Integracao
@return 	Nil
/*/
//---------------------------------------------------------------------------------------
Function LjAtuCanc( cTabela, nRecnoReg , aDadoInut)
Local aArea 		:= GetArea()
Local aAreaTab 		:= (cTabela)->(GetArea())
Local cDocNum 		:= ""
Local cDocSer 		:= ""
Local dDocData 		:= Nil
Local cXmlProt		:= ""
Local cRetSEFAZ		:= ""
Local aRetTSS		:= {}
Local aRetSEFAZ		:= {}

//[1][1] = Data, [1][2] = Protocolo, [1][3] = RetornoSefaz (da INUTILIZAÇÃO), [1][4] = ChaveNFCeCancelada, [1][5] SituacaoNFCe
Default aDadoInut	:= {}

DBSelectArea(cTabela)
(cTabela)->(DbGoTo(nRecnoReg))

If cTabela == "SL1"
	cDocNum 	:= SL1->L1_DOC
	cDocSer 	:= SL1->L1_SERIE
	dDocData	:= SL1->L1_EMISNF
ElseIf cTabela == "SLX"
	cDocNum 	:= SLX->LX_CUPOM
	cDocSer 	:= SLX->LX_SERIE
	dDocData	:= SLX->LX_DTMOVTO
EndIf
//Caso seja uma inutilização SmartConector Integração
If Len(aDadoInut) > 0 //Se contiver os dados da Inutilização não se comunica com o TSS
	Lj140AtuSF3({}, aDadoInut, cTabela,	cDocSer, cDocNum, "" )
Else
	LjGrvLog( cDocNum, "Atualiza dados de Cancelamento ou Inutilizacao de Documento Eletronico nas tabelas " +;
			"SF3 e SFT. Tabela Origem do cancelamento: ["+cTabela+"] Doc: [" + cDocNum + "] Serie: [" + cDocSer + "]")

	//Retorna um array com o XML da NFCe via conexao com TSS
	aRetTSS := LjRetNFCe(dDocData, dDocData, cDocSer, cDocSer, cDocNum, cDocNum)

	LjGrvLog( cDocNum, "Retorno da consulta no TSS do Documento Eletronico. Doc: [" + cDocNum +;
			 "] Serie: [" + cDocSer + "]", aRetTSS)

	// Convertemos o XML
	If Len(aRetTSS) > 0 .AND.  Valtype(aRetTSS[1]) == "O" .AND. aRetTSS[1]:OWSNFECANCELADA <> Nil

		cXMLProt := aRetTSS[1]:oWSNFECANCELADA:cXMLProt

		// Retorna a situacao da nota
		cRetSEFAZ := Lj140CXML(cXMLProt)

		LjGrvLog( cDocNum, "Doc: [" + cDocNum + "] Serie: [" + cDocSer + "] - Retorno do Sefaz", cRetSEFAZ )
		
		If !Empty(cRetSEFAZ)
			
			If cTabela == "SL1"
				//Atualizamos o campo L1_RETSFZ para manter o legado
				LjGrvLog( "L1_NUM: " + SL1->L1_NUM, "Cancelamento do Doc: [" + cDocNum + "] Serie: [" + cDocSer + "]. Atualiza o campo L1_RETSFZ", cRetSEFAZ )
				If RecLock( "SL1", .F. )
					Replace SL1->L1_RETSFZ with cRetSEFAZ
					SL1->( MsUnlock() )
				Else
					LjGrvLog( "L1_NUM: " + SL1->L1_NUM, "Falha ao reservar o registro para gravacao do campo L1_RETSFZ ref. cancelamento" )
				EndIf
			EndIf

			aRetSEFAZ := StrTokArr(AllTrim(cRetSEFAZ), "|")

			If Len(aRetSEFAZ) == 4
				aRetSEFAZ := { .T., aRetSEFAZ }
			ElseIf Len(aRetSEFAZ) == 3
				aRetSEFAZ := { .T., aRetSEFAZ }
			Else
				aRetSEFAZ := { .F., {'','','',''} }
			EndIf
			
			LjGrvLog( ,"Inutilização - atualiza o livro fiscal (SFT/SF3) ",aRetSEFAZ[1])
			/*Atualizamos o SF3 para que nao seja necessario o usuario utilizar a rotina Monitor para preenchimento deles*/
			If aRetSEFAZ[1]
				Lj140AtuSF3(aRetSEFAZ, {}, cTabela,	cDocSer, cDocNum, cXMLProt )
			EndIf
		Else
			LjGrvLog( cDocNum, "Falha ao retornar a situação do Documento: [" + cDocNum + "] Serie: [" + cDocSer + "]. Os campos F3_PROTOC,F3_CODRSEF, F3_DESCRET e FT_DTCANC não serão atualizados.")
		EndIf
	Else
		If Len(aRetTSS) >= 2
			LjGrvLog( cDocNum, "Falha ao retornar a situação do Documento: [" + cDocNum + "] Serie: [" + cDocSer + "]. ERRO: " + aRetTSS[2])
		Else
			LjGrvLog( cDocNum, "Falha ao retornar a situação do Documento: [" + cDocNum + "] Serie: [" + cDocSer + "]." )
		EndIf
	EndIf

	RestArea(aArea)
	RestArea(aAreaTab)
EndIf

Return

/*/{Protheus.doc} Lj140AtuSF3
Função que efetua a atualização da SF3/SFT	
@author Julio.Nery
@since 05/11/2020
@version P12
@param aRetSEFAZ, array, retorno da SEFAZ
@param aDadoInut, array, dados da inutilização
@param cTabela, string, tabela utilizada
@param cDocSer, string, Doc e Serie a ser utilizada
@param cDocNum, string, NUm do Doc
@param cXMLProt, string, XML 
@return NIL
/*/
Function Lj140AtuSF3(aRetSEFAZ, aDadoInut, cTabela,	cDocSer,;
					 cDocNum, cXMLProt )
Local cChave	:= ""
Local aAreaAux	:= {}

aAreaAux := SF3->( GetArea() )
SF3->( DbSetOrder(5) )	//F3_FILIAL + F3_SERIE + F3_NFISCAL + F3_CLIEFOR + F3_LOJA + F3_IDENTFT
If SF3->( DbSeek(xFilial("SF3") + cDocSer + cDocNum) )
	While SF3->( !EoF() ) .AND. xFilial("SF3") + cDocSer + cDocNum == SF3->(F3_FILIAL+F3_SERIE+F3_NFISCAL)
		If RecLock("SF3", .F.)
			If Len(aRetSEFAZ) > 0
				Replace SF3->F3_PROTOC 	with aRetSEFAZ[2][1]			//Protocolo de autorizcao da NFC-e
				Replace SF3->F3_CODRSEF with aRetSEFAZ[2][2] 			//Codigo do retorno da SEFAZ
				Replace SF3->F3_DESCRET with aRetSEFAZ[2][3] 			//Descricao do retorno da SEFAZ
				If Len(aRetSEFAZ[2]) > 3 .And. !Empty(aRetSEFAZ[2][4])
					Replace SF3->F3_DTCANC with STOD(aRetSEFAZ[2][4]) 	//Data do retorno da SEFAZ
				EndIf
				If cTabela == "SLX" .And. aRetSEFAZ[2][2] == "101"
					cChave	:=  LjxBChvTss(cXMLProt,,cDocNum,cDocSer)
					Replace SF3->F3_CHVNFE with cChave
				EndIf
			ElseIf Len(aDadoInut) > 0//Integração Smart Atualizado na função RMIDadoInu
				Replace SF3->F3_PROTOC 	with aDadoInut[1][2]			//Protocolo de autorizcao da NFC-e
				Replace SF3->F3_CODRSEF with aDadoInut[1][3] 			//Codigo do retorno da SEFAZ
				Replace SF3->F3_DESCRET with aDadoInut[1][5] 			//Descricao do retorno da SEFAZ
				Replace SF3->F3_DTCANC  with aDadoInut[1][1] 		//Data do retorno da SEFAZ
				Replace SF3->F3_ENTRADA with aDadoInut[1][1] 			//Data do retorno da SEFAZ
				Replace SF3->F3_EMISSAO with aDadoInut[1][1] 			//Data do retorno da SEFAZ
				Replace SF3->F3_OBSERV  with "NF Inutilizada"
				
				If AllTrim(aDadoInut[1][3]) == "101"
					cChave := aDadoInut[1][4]
					Replace SF3->F3_CHVNFE with aDadoInut[1][4]
				EndIf
			EndIf
			SF3->( MsUnlock() )
		Else
			LjGrvLog( cDocNum , "Doc: [" + cDocNum + "] Serie [" + cDocSer +;
								 "]. Falha ao alocar o registro da tabela SF3. R_E_C_N_O_: ", SF3->(Recno()) )
		EndIf
		SF3->( DbSkip() )
	EndDo
EndIf
RestArea( aAreaAux )

// Atualiza o SFT com a data do retorno do SEFAZ
aAreaAux := SFT->( GetArea() )
SFT->( DbSetOrder(6) )	//FT_FILIAL + FT_TIPOMOV + FT_NFISCAL + FT_SERIE
If SFT->( DbSeek(xFilial("SFT") + "S" + cDocNum + cDocSer) )
	While SFT->( !EoF() ) .AND. xFilial("SFT") + "S" + cDocNum + cDocSer == SFT->(FT_FILIAL+FT_TIPOMOV+FT_NFISCAL+FT_SERIE)
		If RecLock("SFT", .F.)
			If Len(aRetSEFAZ) > 0
				If Len(aRetSEFAZ[2]) > 3 .And. !Empty(aRetSEFAZ[2][4])
					Replace SFT->FT_DTCANC with STOD(aRetSEFAZ[2][4]) //Data do retorno da SEFAZ
				EndIf 
				If cTabela == "SLX" .And. aRetSEFAZ[2][2] == "101" .AND. !Empty(cChave)
					Replace SFT->FT_CHVNFE with cChave
				EndIf
			ElseIf Len(aDadoInut) > 0 //Integração Smart Atualizado na função RMIDadoInu
				Replace SFT->FT_DTCANC with aDadoInut[1][1] //Data do retorno da SEFAZ
				Replace SFT->FT_ENTRADA with aDadoInut[1][1] //Data do retorno da SEFAZ
				Replace SFT->FT_EMISSAO with aDadoInut[1][1] //Data do retorno da SEFAZ
				Replace SFT->FT_OBSERV  with "NF Inutilizada"
				Replace SFT->FT_CHVNFE with cChave
			EndIf
			SFT->( MsUnlock() )
		Else
			LjGrvLog( cDocNum , "Doc: [" + cDocNum + "] Serie [" + cDocSer + "]. Falha ao alocar o registro da tabela SFT. R_E_C_N_O_: ", SFT->(Recno()) )
		EndIf
		SFT->( DbSkip() )
	EndDo
EndIf
RestArea( aAreaAux )

Return 

//----------------------------------------------------------------------
/*/{Protheus.doc} LjMonitDoc
Chama a funcao de monitoramento do documento no TSS e atualiza o STATUS do documento nas tabelelas do TSS.

@param   cDoc	 Número do Documento Fiscal
@param   cSerie	 Série do Documento Fiscal
@param   cModelo Modelo do Documento Fiscal
@author  Alberto Deviciente
@since   26/10/2018
@version P12
@return  Lógico, Indica se executou com sucesso o Monitoramento do Documento Eletronico
/*/
//----------------------------------------------------------------------
Function LjMonitDoc( cDoc, cSerie, cModelo )
Local lRet 		:= .T.
Local lMonitora := .F.
Local cHora1	:= ""
Local cHora2	:= ""
Local nDifHoras	:= 0
Local cDifHoras := ""

If lLxIteracao .And. ExistFunc("LjMonitora") //Verifica se a funcao existe no fonte LOJNFCE

	If Empty(SLX->LX_DULTPRC)
		lMonitora := .T.
	Else
		cHora1 := SLX->LX_HULTPRC + ":00"
		cHora2 := Left(Time(),5)  + ":00"
		
		cDifHoras := Left( ElapTime(cHora1, cHora2), 5)

		nDifHoras := Hrs2Min(cDifHoras) //Converte Horas para Minutos

		If nDifHoras > 60 //60 minutos (1 hora) de tolerancia para nao ocorrer problema de "Consumo Indevido" do SEFAZ
			lMonitora := .T.

			//Limpa os campos para que possa fazer o monitoramento do Doc novamente no SEFAZ
			RecLock("SLX", .F.)
			SLX->LX_ITERACA := 0
			SLX->LX_DULTPRC := cToD("  /  /  ")
			SLX->LX_HULTPRC := ""
			SLX->(MsUnLock())
		ElseIf SLX->LX_ITERACA < 3 //Faz ate 3 solicitacoes de Monitoramento do Documento no TSS no periodo estipulado dentro de 1 hora para nao ocorrer problema de "Consumo Indevido" do SEFAZ
			lMonitora := .T.
		EndIf
	EndIf

	If lMonitora
		
		lRet := LjMonitora( cDoc, cSerie, cModelo )

		LjGrvLog( cDoc, "Monitoramento do Documento no TSS. DOC: [" + cDoc + "] Serie: [" + cSerie + "] Modelo: [" + cModelo + "]. Retorno:", lRet )

		If lRet
			RecLock("SLX", .F.)
			SLX->LX_ITERACA := SLX->LX_ITERACA + 1
			If Empty(SLX->LX_DULTPRC)
				SLX->LX_DULTPRC := dDataBase
				SLX->LX_HULTPRC := Left(Time(),5)
			EndIf
			SLX->(MsUnLock())
		EndIf
	EndIf
EndIf

Return lRet

//----------------------------------------------------------------------
/*/{Protheus.doc} Lj140LpSL4
Limpa informações da SL4.

@author 	Alberto Deviciente
@since 		03/03/2022
@version	P12

@param 		cNumOrc, Caractere, Numero do Orçamento
@return 	Nil, Nulo
/*/
//----------------------------------------------------------------------
Function Lj140LpSL4(cNumOrc)
Local lL4ACRCART	:= SL4->(ColumnPos("L4_ACRCART")) > 0

If lL4ACRCART
	DbSelectArea("SL4")
	SL4->( DbSetOrder(1) )	//L4_FILIAL+L4_NUM+L4_ORIGEM
	If SL4->( DbSeek(xFilial("SL4") + cNumOrc) )
		While SL4->(!Eof()) .AND. xFilial("SL4") + cNumOrc == SL4->L4_FILIAL + SL4->L4_NUM
			If SL4->L4_ACRCART > 0
				RecLock("SL4",.F.)
				//Subtrai o valor de Juros/Acréscimo do Cartão
				SL4->L4_VALOR 	:= SL4->L4_VALOR - SL4->L4_ACRCART
				SL4->L4_ACRCART := 0
				SL4->( MsUnLock() )
			EndIf
			SL4->( DbSkip() )
		Enddo
	EndIf
EndIf

Return Nil
