#INCLUDE "MATA265.CH"
#INCLUDE "PROTHEUS.CH"
/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё MATA265  Ё Autor Ё Rodrigo de a. SartorioЁ Data Ё 05/11/97 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Distribuicao de Produtos.                                  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Generico                                                   Ё╠╠
╠╠цддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠

*/
Function MATA265(xAutoCab,xAutoItens,nOpcAuto)
//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//ЁSimula a variavel aAlter onde ira validar somente os campos que forem informadosЁ
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
Local aAltAuto := {"DB_ESTORNO"}
Local nX       := 0
//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Define Variaveis                                            Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
Local lRetPE   	:= .T.
Local cFiltro  	:= ""
Local cCampo   	:= ""
Local nPos     	:= 0
Local nPosProd 	:= 0
Local nPosNseq 	:= 0
Local nCt      	:= 0
Local nI       	:= 0
Local nY       	:= 0
Local nPoxLotCtl:= 0
Local nPoxNumlot:= 0	
Local aKey1    	:= {}

PRIVATE	lMovimento:=.F.

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Define Array contendo as Rotinas a executar do programa      Ё
//Ё ----------- Elementos contidos por dimensao ------------     Ё
//Ё 1. Nome a aparecer no cabecalho                              Ё
//Ё 2. Nome da Rotina associada                                  Ё
//Ё 3. Usado pela rotina                                         Ё
//Ё 4. Tipo de Transa┤└o a ser efetuada                          Ё
//Ё    1 -Pesquisa e Posiciona em um Banco de Dados              Ё
//Ё    2 -Simplesmente Mostra os Campos                          Ё
//Ё    3 -Inclui registros no Bancos de Dados                    Ё
//Ё    4 -Altera o registro corrente                             Ё
//Ё    5 -Estorna registro selecionado gerando uma contra-partidaЁ
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
PRIVATE aRotina := MenuDef()
//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//ЁDefine variaveis para executar em processo de rotina automaticaЁ
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
PRIVATE l265Auto := ( xAutoCab <> NIL  .and. xAutoItens <> NIL )

If ( l265Auto )
	Private aAutoCab:={} , aAutoItens :={},aValidGet:={}
EndIf
nOpcAuto := If (nOpcAuto == nil, 3, nOpcAuto)
//здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//ЁSe o processo for automatico deve montar um novo aRotinaЁ
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If ( l265Auto )
	aRotina := {	{STR0001,"AxPesqui"  , 0 , 1},; //"Pesquisar"
						{STR0002,"A265Visual", 0 , 2},; //"Visualizar"
						{STR0003,"A265Inclui", 0 , 3},; //"EnDerecar"
						{STR0004,"A265Exclui", 0 , 4} } //"Estornar"
EndIf
//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Define o cabecalho da tela de atualizacoes                   Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
PRIVATE cCadastro := OemToAnsi(STR0005)	//"Distribui┤└o de Produtos"

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Inicializa perguntas deste programa                          Ё
//Ё mv_par01 - Bloqueia Data Validade Vencida   1 - Sim 2 - Nao  Ё
//Ё mv_par02 - Sugere Localizacoes              1 - Sim 2 - Nao  Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
Pergunte("MTA265",.F.)

If !l265Auto
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Ativa tecla F12 para acionar perguntas                         Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	SetKey( VK_F12, {|| Pergunte("MTA265",.T.)})

	If (ExistBlock("M265FIL"))
		ExecBlock("M265FIL",.F.,.F.)
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Ponto de entrada para verificacao de filtros na Mbrowse      Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If  ExistBlock("M265FILB")
		cFiltro := ExecBlock("M265FILB",.F.,.F.)
		If Valtype(cFiltro) <> "C"
			cFiltro := ""
		EndIf
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Endereca a funcao de BROWSE                                  Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
    mBrowse(6,1,22,75,"SDA",,,,"QtdComp(SDA->DA_SALDO,.T.) > QtdComp(0,.T.)",,,,,,,,,, IF(!Empty(cFiltro),cFiltro, NIL))

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Desativa tecla que aciona perguntas                            Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Set Key VK_F12 TO
Else
	//Posiciona a Tabela SDA de acordo com o NumSeq recebido //
	
	nPosProd := Ascan(xAutoCab,{|x| x[1]== "DA_PRODUTO"})
	nPosNseq := Ascan(xAutoCab,{|x| x[1]== "DA_NUMSEQ"})
	
	If nPosProd > 0 .And. Rastro(xAutoCab[nPosProd][2])
		nPoxLotCtl := Ascan(xAutoCab,{|x| x[1]== "DA_LOTECTL"})
		nPoxNumlot := Ascan(xAutoCab,{|x| x[1]== "DA_NUMLOTE"})
	EndIf
	
	nCt := 0
	If nPosProd>0 .And. nPosNseq>0
		dbSelectArea("SDA")
		DbSetOrder(1)
		MsSeek(xFilial('SDA')+xAutoCab[nPosProd][2])

		//-- Avalia se existe registro com o DA_NUMSEQ informado
		cQuery := "SELECT ISNULL(MAX(R_E_C_N_O_),0) RECSDA"
		cQuery += " FROM " +RetSqlName("SDA") +" SDA"
		cQuery += " WHERE (SDA.DA_FILIAL = '"+xFilial("SDA")+"')"
		cQuery += " AND (SDA.DA_PRODUTO = '"+Trim(xAutoCab[nPosProd,2])+"' AND SDA.DA_NUMSEQ = '"+xAutoCab[nPosnSeq,2]+"'
		If nPoxLotCtl > 0 
			cQuery +=	" AND SDA.DA_LOTECTL = '"+xAutoCab[nPoxLotCtl,2]+"'
		EndIf
		If nPoxNumlot > 0 
			cQuery +=	" AND SDA.DA_NUMLOTE = '"+xAutoCab[nPoxNumlot,2]+"'
		EndIf
		cQuery += " )"
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"QRYSDA",.T.,.T.)
		If (nCt := QRYSDA->RECSDA) > 0
			SDA->(dbGoTo(nCt))
		EndIf
		QRYSDA->(DbCloseArea())
	EndIf

	If nCt==0
		lMsErroAuto:=.T.
		Help(" ",1,STR0040)
		Return .F.
	EndIf

	//Verifica se os campos adcionais na chave do SDB existem no xAutoItens, se nЦo existir, complementa o Array //
	DbSelectArea("SIX")
	DbSetOrder(1)
	DbSeek("SDB"+"1")
	aKey1:={}
	If !EOF()
		aKey1:=STRTOKARR(SIX->CHAVE,"+")
	EndIf
	If Len(aKey1)==0
		lMsErroAuto:=.T.
		Help(" ",1,STR0041)
		Return NIL
	EndIf

	For nY=1 to Len(xAutoItens)
		For nI=1 to Len(aKey1)
			nPos:=Ascan(xAutoItens[nY],{|x| Trim(x[1])==Trim(aKey1[nI])})
			cCampo:="DA_"+Substr(aKey1[nI],4,Len(aKey1[nI]))
			If nPos==0 .And. SDA->(FieldPos(cCampo)) > 0
				AAdd(xAutoItens[nY],{Trim(aKey1[nI]),SDA->&cCampo,Nil})
			EndIf
		Next nI
	Next nY

	If nOpcAuto == 3
		aAltAuto := NIL
	EndIf

	For nX := 1 To Len(xAutoItens)
		aadd(aAutoItens,SDB->(MSArrayXDB(xAutoItens[nX],.F.,nOpcAuto,,aAltAuto)))
	Next
	dbSelectArea("SDA")
	nPos := Ascan(aRotina,{|x| x[4]== nOpcAuto})
	If ( nPos # 0 )
		bBlock := &( "{ |x,y,z,k| " + aRotina[ nPos,2 ] + "(x,y,z,k) }" )
		Eval( bBlock, Alias(), (Alias())->(Recno()),nOpcAuto)
	EndIf
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Inicializa novamente as perguntas do programa                Ё
//Ё Evita o erro que ocorre apos exportar para Excel onde as     Ё
//Ё variaveis mv_par01 e mv_par02 sao desconfiguradas            Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If Type("mv_par01") != "N"
	Pergunte("MTA265",.F.)
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Verifica se lotes estao com validade vencida                         Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If lMovimento .And. mv_par01 == 1 .And. SuperGETMV("MV_LOTVENC") == "N" ;
	.And. SuperGETMV("MV_RASTRO") == "S" .And. !IsInCallStack( 'NewAddress' )
	lRetPE := .T.
	If (ExistBlock("MA265BLOT"))
		//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё MA265BLOT - Ponto de Entrada para definir se executa a funcao BloqData()  Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		lRetPE := ExecBlock( "MA265BLOT", .F., .F., {l265Auto} )
		lRetPE := If(ValType(lRetPE)=="L",lRetPE,.T.)
	EndIf
	If lRetPE
		If l265Auto
			BloqData(.T., .T.)
		Else
			Processa({|lEnd| BloqData(.T.)},OemToAnsi(STR0007),OemToAnsi(STR0008),.F.)	//"Verificando Data de Validade dos Lotes"###"Verificando Lotes com data de validade vencida ..."
		EndIf
	EndIf
EndIf

If (ExistBlock("M265END"))
	ExecBlock("M265END",.F.,.F.)
EndIf

Return NIL

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA265VisualЁ Autor Ё Rodrigo de A. SartorioЁ Data Ё 07/11/97 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Visualizacao da distribuicao de produtos                   Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A265Visual(ExpC1,ExpN1,ExpN2)                              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpC1 = Alias do arquivo                                   Ё╠╠
╠╠Ё          Ё ExpN1 = Numero do registro                                 Ё╠╠
╠╠Ё          Ё ExpN2 = Numero da opcao selecionada                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA265                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A265Visual(cAlias,nReg,nOpc)
Local i          := 0
Local nX         := 0
Local cSeek      := ''
Local cLoteSDA   := ''
Local lRastro    := .F.
Local aObjects   := {}
Local aPosObj    := {}
Local aNoFields  := {}
Local aSize      := MsAdvSize()
Local aInfo      := {aSize[1],aSize[2],aSize[3],aSize[4],3,3}
Local bSeekWhile := { || SDB->DB_FILIAL+SDB->DB_PRODUTO+SDB->DB_LOCAL+SDB->DB_NUMSEQ+SDB->DB_DOC+SDB->DB_SERIE+SDB->DB_CLIFOR+SDB->DB_LOJA } //Condicao While para montar o aCols
Local bSeekFor   := { || SDB->DB_TM <= "500" .And. SDB->DB_TIPO == "D" .And. If(lRastro,cLoteSDA==SDB->DB_LOTECTL,.T.) }

PRIVATE aButtons  := {}
PRIVATE nCounter  :=0
PRIVATE nUsado    :=0
PRIVATE aTELA[0][0]
PRIVATE aGETS[0]
PRIVATE oGetd


bCampo    := { |nCPO| Field(nCPO) }

//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Salva a integridade dos campos de Bancos de Dados    Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
dbSelectArea(cAlias)
If LastRec() == 0
	Return (.T.)
EndIf

If SDA->DA_FILIAL != xFilial("SDA")
	Help(" ",1,"A000FI")
	Return (.T.)
EndIf

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё M265BUT - Ponto de Entrada para Adicionar botoes        Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If ExistBlock("M265BUT")
	aButtonUsr := ExecBlock("M265BUT",.F.,.F.,{nOpc})
	If ValType(aButtonUsr) == "A"
		For nX:=1 to Len(aButtonUsr)
			aAdd(aButtons,aButtonUsr[nX])
		Next
	EndIf
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Salva a integridade dos campos de Bancos de Dados    Ё
//Ё p/ preencher variaveis da Enchoice                   Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
dbSelectArea(cAlias)
For i := 1 TO FCount()
	M->&(EVAL(bCampo,i)) := FieldGet(i)
Next i

//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Conta registros de movimentos ja incluidos           Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
nCounter	:=	A265UltIt('N')

If nCounter > 0
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Monta a entrada de dados do arquivo                  Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
	cSeek    := xFilial("SDB")+DA_PRODUTO+DA_LOCAL+DA_NUMSEQ+DA_DOC+DA_SERIE+DA_CLIFOR+DA_LOJA
	cLoteSDA := DA_LOTECTL
	lRastro  := Rastro(DA_PRODUTO)

	AAdd(aNoFields,'DB_PRODUTO') ; AAdd(aNoFields,'DB_DOC')     ; AAdd(aNoFields,'DB_SERIE')   ; AAdd(aNoFields,'DB_CLIFOR')
	AAdd(aNoFields,'DB_LOJA')    ; AAdd(aNoFields,'DB_TIPONF')  ; AAdd(aNoFields,'DB_ORIGEM')  ; AAdd(aNoFields,'DB_NUMLOTE')
	AAdd(aNoFields,'DB_LOTECTL') ; AAdd(aNoFields,'DB_TM')      ; AAdd(aNoFields,'DB_LOCAL')

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Monta aHeader e aCols                                        Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	PRIVATE aHeader[0],aCols[0], Continua
	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Caso ja tenha dados, preenche linhas com movimentos anteriores  Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды

	FillGetDados(nOpc,"SDB",1,cSeek,bSeekWhile,bSeekFor,aNoFields,/*aYesFields*/,/*lOnlyYes*/,/*cQuery*/,/*bMontCols*/,/*lEmpty*/)

	nCounter:=Len(aCols)

EndIf

// Array com objetos utilizados
AADD(aObjects,{100,095,.T.,.F.,.F.})
AADD(aObjects,{100,100,.T.,.T.,.F.})

aPosObj:=MsObjSize(aInfo,aObjects)

DEFINE MSDIALOG oDlg TITLE cCadastro OF oMainWnd PIXEL FROM aSize[7],0 TO aSize[6],aSize[5]
EnChoice(cAlias,nReg,nOpc,,,,,{aPosObj[1,1],aPosObj[1,2],aPosObj[1,3],aPosObj[1,4]})
If nCounter > 0
	oGetd := MsGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc)
EndIf
ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||oDlg:End()},{||oDlg:End()},,aButtons)
RETURN

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA265IncluiЁ Autor Ё Rodrigo de A. SartorioЁ Data Ё 05/11/97 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Distribuicao de produtos p/ Localizacao Fisica             Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A265Inclui(ExpC1,ExpN1,ExpN2)                              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpC1 = Alias do arquivo                                   Ё╠╠
╠╠Ё          Ё ExpN1 = Numero do registro                                 Ё╠╠
╠╠Ё          Ё ExpN2 = Numero da opcao selecionada                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA265                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A265Inclui(cAlias,nReg,nOpc)
Local nOpca    := 0
Local cSeek    := ''
Local cLoteSDA := ''
Local lRastro  := .F.
Local bCampo

// Verifica a existencia de PE para preencher aCols
Local lMTA265Cols := (ExistBlock( 'A265COL' ) )
Local aBackCols   :={}
Local aNoFields   :={}
Local bSeekWhile  := {|| SDB->DB_FILIAL+SDB->DB_PRODUTO+SDB->DB_LOCAL+SDB->DB_NUMSEQ+SDB->DB_DOC+SDB->DB_SERIE+SDB->DB_CLIFOR+SDB->DB_LOJA } //Condicao While para montar o aCols
Local bSeekFor    := {|| SDB->DB_TM <= "500" .And. SDB->DB_TIPO == "D" .And. If(lRastro,cLoteSDA==SDB->DB_LOTECTL,.T.) }

// Salva o Array aRotina Original
Local aCopia :=ACLONE(aRotina)
Local nI     := 0
Local oDlg, aButtonUsr


Local nITENSDIST:=9999
Local dDataFec  := MVUlmes()

Local aObjects :={},aPosObj  :={}
Local aSize    :=MsAdvSize()
Local aInfo    :={aSize[1],aSize[2],aSize[3],aSize[4],3,3}
Local i        := 0
Local nX       := 0
Local nPosAlias:= 0
Local nPosRec  := 0
Local lEndProt := .F. // EndereГamento via Protheus
Local lMvNegatBF :=  SuperGETMV("MV_NEGATBF",.F.,.F.)

// Variavel para ponto de entrada
Local lRetPE := .T.

PRIVATE aButtons  := {}

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Ativa tecla F4 para comunicacao com Saldos por Endereco      Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If ( ! l265Auto )
	Set Key VK_F4 TO ShowF4()
EndIf

PRIVATE oGetd
PRIVATE nPosLocali:=0,nPosQuant:=0,nPosData:=0,nPosEstorn:=0,nPosNumSer:=0,nPosItem:=0,nPosQtSegum:=0
PRIVATE nCounter:=0

//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Monta a entrada de dados do arquivo                  Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
PRIVATE nUsado:=0

bCampo    := { |nCPO| Field(nCPO) }

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Inicializa novamente as perguntas do programa                Ё
//Ё Evita o erro que ocorre apos exportar para Excel onde as     Ё
//Ё variaveis mv_par01 e mv_par02 sao desconfiguradas            Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If Type("mv_par01") != "N"
	Pergunte("MTA265",.F.)
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Salva a integridade dos campos de Bancos de Dados    Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
dbSelectArea(cAlias)
If LastRec() == 0
	Return (.T.)
EndIf

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Ponto de Entrada para permitir ou nao enderecamento via Protheus / ACD	|
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If ExistBlock("A265NACD")
	lEndProt := ExecBlock("A265NACD",.F.,.F.)
EndIf

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Trava endereГamento via Protheus quando existe controle de cСdigo interno do produto "CB0"|
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If UsaCB0("01") .And. !l265Auto .And. !lEndProt
   MsgStop(STR0039,STR0016)//O controle de cСdigo interno estА habilitado, nesse caso, o endereГamento deverА ser feito pelas rotinas do ACD.","AtenГЦo!"
   Return
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Verificar data do ultimo fechamento em SX6.                  Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If dDataFec >= dDataBase
	Help ( " ", 1, "FECHTO" )
	Return
EndIf

If SDA->DA_FILIAL != xFilial("SDA")
	Help(" ",1,"A000FI")
	Return (.T.)
EndIf

If QtdComp(SDA->DA_SALDO,.T.) <= QtdComp(0,.T.)
	Help(" ",1,"A265NAOQTD")
	Return (.T.)
EndIf

If !(Reclock("SDA",.F.))
	Return (.T.)
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Salva a integridade dos campos de Bancos de Dados    Ё
//Ё p/ preencher variaveis da Enchoice                   Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
dbSelectArea(cAlias)
For i := 1 To FCount()
	M->&(EVAL(bCampo,i)) := FieldGet(i)
Next i

cSeek    := xFilial("SDB")+DA_PRODUTO+DA_LOCAL+DA_NUMSEQ+DA_DOC+DA_SERIE+DA_CLIFOR+DA_LOJA
cLoteSDA := DA_LOTECTL
lRastro  := Rastro(DA_PRODUTO)

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Botao para exportar dados para EXCEL                    Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If RemoteType() == 1
	aAdd(aButtons,{PmsBExcel()[1],{|| DlgToExcel({{"ENCHOICE",cCadastro,aGets,aTela},{"GETDADOS",OemToAnsi(STR0024),aHeader,aCols} })},PmsBExcel()[2],PmsBExcel()[3]})
EndIf
//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё BotЦo para geraГЦo dos nЗmeros de sИrie automaticamente Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
aAdd(aButtons,{STR0045,{|| A265GerNS(aHeader,SDA->DA_QTDORI,SDA->DA_SALDO)} , 'Gerar NЗmeros de SИrie' , 'Gerar NЗmeros de SИrie' })  //'Gerar nЗmeros de SИrie'

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё M265BUT - Ponto de Entrada para Adicionar botoes        Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If ExistBlock("M265BUT")
	aButtonUsr := ExecBlock("M265BUT",.F.,.F.,{nOpc})
	If ValType(aButtonUsr) == "A"
		For nX:=1 to Len(aButtonUsr)
			aAdd(aButtons,aButtonUsr[nX])
		Next nX
	EndIf
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Monta a entrada de dados do arquivo                  Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
PRIVATE aTELA[0][0],aGETS[0],Continua

AAdd(aNoFields,'DB_PRODUTO') ; AAdd(aNoFields,'DB_DOC')     ; AAdd(aNoFields,'DB_SERIE')   ; AAdd(aNoFields,'DB_CLIFOR')
AAdd(aNoFields,'DB_LOJA')    ; AAdd(aNoFields,'DB_TIPONF')  ; AAdd(aNoFields,'DB_ORIGEM')  ; AAdd(aNoFields,'DB_NUMLOTE')
AAdd(aNoFields,'DB_LOTECTL') ; AAdd(aNoFields,'DB_TM')      ; AAdd(aNoFields,'DB_LOCAL')   ; AAdd(aNoFields,'DB_DESSER')
AAdd(aNoFields,'DB_TAREFA')  ; AAdd(aNoFields,'DB_DESTAR')  ; AAdd(aNoFields,'DB_ATIVID')  ; AAdd(aNoFields,'DB_DESATI')
AAdd(aNoFields,'DB_RHFUNC')  ; AAdd(aNoFields,'DB_RECHUM')  ; AAdd(aNoFields,'DB_RECFIS')  ; AAdd(aNoFields,'DB_OCORRE')
AAdd(aNoFields,'DB_ANOMAL')  ; AAdd(aNoFields,'DB_ANOMDES') ; AAdd(aNoFields,'DB_ENDDES')  ; AAdd(aNoFields,'DB_CARGA')
AAdd(aNoFields,'DB_ESTFIS')  ; AAdd(aNoFields,'DB_HRINI')   ; AAdd(aNoFields,'DB_HRFIM')   ; AAdd(aNoFields,'DB_UNITIZ')
AAdd(aNoFields,'DB_ATUEST')  ; AAdd(aNoFields,'DB_STATUS')  ; AAdd(aNoFields,'DB_PRIORI')  ; AAdd(aNoFields,'DB_ORDTARE')
AAdd(aNoFields,'DB_ORDATIV') ; AAdd(aNoFields,'DB_IDOPERA') ; AAdd(aNoFields,'DB_SEQCAR')  ; AAdd(aNoFields,'DB_REGWMS')
AAdd(aNoFields,'DB_DESHUM')  ; AAdd(aNoFields,'DB_TEMPO')

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Monta aHeader e aCols                                                     Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
PRIVATE aHeader:={},aCOLS:={}

FillGetDados(4,"SDB",1,cSeek,bSeekWhile,bSeekFor,aNoFields,/*aYesFields*/,/*lOnlyYes*/,/*cQuery*/,/*bMontCols*/,/*lEmpty*/)

//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Descobre a posicao dos campos obrigatorios no AHeaderЁ
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
For nx = 1 To Len(aHeader)
	If Trim(aHeader[nx][2]) == "DB_LOCALIZ"
		nPosLocali:=nX
	ElseIf Trim(aHeader[nx][2]) == "DB_QUANT"
		nPosQuant:=nX
	ElseIf Trim(aHeader[nx][2]) == "DB_DATA"
		nPosData:=nX
	ElseIf Trim(aHeader[nx][2]) == "DB_ESTORNO"
		nPosEstorn:=nX
	ElseIf Trim(aHeader[nx][2]) == "DB_NUMSERI"
		nPosNumSer:=nX
	ElseIf Trim(aHeader[nx][2]) == "DB_ITEM"
		nPosItem:=nX
	ElseIf Trim(aHeader[nx][2]) == "DB_QTSEGUM"
		nPosQtSegum:=nx
	ElseIf IsHeadAlias(aHeader[nx][2])
		nPosAlias:=nx
	ElseIf IsHeadRec(aHeader[nx][2])
		nPosRec:=nx
	EndIf
Next nx

nCounter:=Len(aCols)
If nCounter > 1 .Or. (nCounter == 1 .And. (!Empty(aCols[nCounter,nPosQuant]) .And. (!Empty(aCols[nCounter,nPosLocali]) .Or. !Empty(aCols[nCounter,nPosNumSer]))))
	AADD(aCols,Array(Len(aHeader)+1))
	For i:=1 to Len(aHeader)
		If i == nPosAlias
			aCOLS[nCounter+1][i] := "SDB"
		ElseIf i == nPosRec
			aCOLS[nCounter+1][i] := 0
		Else
			cCampo:=Alltrim(aHeader[i,2])
			aCols[nCounter+1][i] := CriaVar(cCampo)
		EndIf
	Next i
	aCOLS[nCounter+1][Len(aHeader)+1] := .F.
	aCOLS[nCounter+1][nPosItem] := Soma1(aCols[Len(aCols)-1,nPosItem])
	aCols[nCounter+1][nPosData] := dDataBase
Else
	aCols[nCounter][nPosData] := dDataBase
	aCOLS[nCounter][nPosItem] := StrZero(1,Len(aCOLS[nCounter][nPosItem]))
	nCounter:=0
EndIf

/* o FrontLoja pode deixar a SBF negativa, caso isso acontece
devera ser apresentado uma msg informando se o usuАrio irА utilizar o endereГo negativo*/
If lMvNegatBF
	A265NegEnd(SDA->DA_PRODUTO,SDA->DA_LOCAL,SDA->DA_SALDO,nPosLocali,nPosQuant,nPosItem,nPosAlias,nPosRec,ACLONE(aCols[Len(aCols)]))
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Monta aCols com Localizacoes sugeridas p/ Distribuir Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
If mv_par02 == 1
	A265MtCols(SDA->DA_PRODUTO,SDA->DA_LOCAL,SDA->DA_SALDO,nPosItem,nPosLocali,nPosQuant,nPosQtSegum,ACLONE(aCols[Len(aCols)]),nPosAlias,nPosRec)
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//ЁExecuta P.E. para preencher ou mudar aCols                    Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If lMTA265Cols
	aBackCols:=ACLONE(aCols)
	lRetPE:=ExecBlock('A265COL',.F.,.F.)
	If ValType(lRetPe) == "L" .And. !lRetPe
		Return
	EndIf
	If Valtype(aCols) # "A"
		aCols:={}
		aCols:=ACLONE(aBackCols)
	EndIf
EndIf

// Array com objetos utilizados
AADD(aObjects,{100,095,.T.,.F.,.F.})
AADD(aObjects,{100,100,.T.,.T.,.F.})

aPosObj:=MsObjSize(aInfo,aObjects)

If Type("l265Auto") != "L" .Or. !l265Auto
	DEFINE MSDIALOG oDlg TITLE cCadastro OF oMainWnd PIXEL FROM aSize[7],0 TO aSize[6],aSize[5]
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Muda o valor do aRotina para so visualizar enchoice.         Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		aRotina[3]:={STR0003,"A265Inclui", 0 , 2}
		EnChoice(cAlias,nReg,nOpc,,,,,{aPosObj[1,1],aPosObj[1,2],aPosObj[1,3],aPosObj[1,4]})
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Restaura o aRotina original p/ a GetDados.                   Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		aRotina:=ACLONE(aCopia)
		oGetd := MsGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"A265LinOk","A265TudoOk","+DB_ITEM=DB_DATA",.T.,,,,nITENSDIST,"A265VldAll()",,,"A265Del")
		oGetd:oBrowse:Refresh()
	ACTIVATE MSDIALOG oDlg ON INIT (oGetd:oBrowse:nRowPos:=Len(aCols),oGetd:oBrowse:Refresh(),EnchoiceBar(oDlg,{|| IIF(oGetd:TudoOk(),(nOpca:=1,oDlg:End()),)},{||oDlg:End()},,aButtons))
Else
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//ЁSe for rotina automatica atualiza aCols conforme o aAutoItens,Ё
	//Ёcom opcao de alteracao para pegar dados se ja existir         Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If ( nCounter > 0 )
		MsAuto2aCols(4,,"DB_ITEM")
	Else
		MsAuto2aCols()
	EndIf
	//здддддддддддддддддддддддддддддддддддддддддд©
	//ЁGera validacao das informacoes adiquiridasЁ
	//юдддддддддддддддддддддддддддддддддддддддддды
	nOpcA := 1
	For nI := 1 to SDA->(FCount())
		Aadd(aValidGet,{SDA->(FieldName(nI)),SDA->(FieldGet(nI)),"",.t.})
	Next
	If ( nCounter > 0 )
		If ! SDB->(MsVldAcAuto(aValidGet,"A265LinOk(o)","A265TudoOk(o)",,4,"DB_ITEM"))   // consiste o campos do Acols
			nOpcA := 0
		EndIf
	Else
		If nOpcA == 0 .or. ! SDB->(MsVldAcAuto(aValidGet,"A265LinOk(o)","A265TudoOk(o)"))   // consiste o campos do Acols
			nOpcA := 0
		EndIf
	EndIf
EndIf
//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Grava movimentos e baixa saldo a classificar no SB2 e no SDA Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If nOpca == 1
	A265Grava()
Else
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//ЁExecuta P.E. ao sair sem gravar 				                 Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If (ExistBlock("MTA265CAN"))
		ExecBlock("MTA265CAN",.F.,.F.)
	EndIf
EndIf
//Destrava o Lock
SDA->(MsUnLock())
//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Desativa tecla F4 para comunicacao com Saldos dos Lotes      Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
SET KEY VK_F4 TO
RETURN

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA265ExcluiЁ Autor Ё Rodrigo de A. SartorioЁ Data Ё 05/11/97 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Distribuicao de produtos p/ Localizacao Fisica             Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A265Exclui(ExpC1,ExpN1,ExpN2)                              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpC1 = Alias do arquivo                                   Ё╠╠
╠╠Ё          Ё ExpN1 = Numero do registro                                 Ё╠╠
╠╠Ё          Ё ExpN2 = Numero da opcao selecionada                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA265                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A265Exclui(cAlias,nReg,nOpc)
Local nOpca := 0
Local cSeek := ''
Local nx    := 0
Local i     := 0
Local nI    := 0
Local bCampo
// Array com campos que podem ser alterados
Local aAlter   :={}
Local aObjects :={}
Local aPosObj  :={}
Local aNoFields:={}
Local cLoteSDA := SDA->DA_LOTECTL+SDA->DA_NUMLOTE
Local lRastro  := Rastro(SDA->DA_PRODUTO)
Local oDlg, aButtonUsr

Local aSize    :=MsAdvSize()
Local aInfo    :={aSize[1],aSize[2],aSize[3],aSize[4],3,3}

Local bSeekWhile := {|| SDB->DB_FILIAL+SDB->DB_PRODUTO+SDB->DB_LOCAL+SDB->DB_NUMSEQ+SDB->DB_DOC+SDB->DB_SERIE+SDB->DB_CLIFOR+SDB->DB_LOJA } //Condicao While para montar o aCols
Local bSeekFor   := {|| SDB->DB_ESTORNO <> "S" .And. SDB->DB_TM <= "500" .And. SDB->DB_TIPO == "D" .And. If(lRastro,cLoteSDA==SDB->DB_LOTECTL+SDB->DB_NUMLOTE,.T.) }
Local uRet

//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Monta a entrada de dados do arquivo                  Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды

PRIVATE aButtons   := {}
PRIVATE nUsado     :=0
PRIVATE nCounter   :=0
PRIVATE nPosLocali :=0
PRIVATE nPosQuant  :=0
PRIVATE nPosData   :=0
PRIVATE nPosEstorn :=0
PRIVATE nPosLote   :=0
PRIVATE nPosLotCtl :=0
PRIVATE nPosNumSer :=0
PRIVATE nPosItem   :=0
PRIVATE nPosQtSegum:=0
PRIVATE Continua
PRIVATE aTELA[0][0]
PRIVATE aGETS[0]
PRIVATE oGetd
Private lIsEstorno := .T.

l265Auto := If(ValType(l265Auto) == "L",l265Auto,.F.)

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Campos que podem ser alterados na GetDados, se for adicionadoЁ
//Ё mais algum campo nesta variavel,tambem deverah ser feita a   Ё
//Ё alteracao na variavel aAltAuto no inicio do MATA265          Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
AADD(aAlter,"DB_ESTORNO")

bCampo    := { |nCPO| Field(nCPO) }

//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Salva a integridade dos campos de Bancos de Dados    Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
dbSelectArea(cAlias)
If LastRec() == 0
	Return (.T.)
EndIf

If SDA->DA_FILIAL != xFilial("SDA")
	Help(" ",1,"A000FI")
	Return (.T.)
EndIf

If !(Reclock("SDA",.F.))
	Return (.T.)
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Salva a integridade dos campos de Bancos de Dados    Ё
//Ё p/ preencher variaveis da Enchoice                   Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
dbSelectArea(cAlias)
For i := 1 To FCount()
	M->&(EVAL(bCampo,i)) := FieldGet(i)
Next i

//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Conta registros de movimentos ja incluidos           Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
nCounter	:=	A265UltIt('N', .F.)

If nCounter == 0 //-- Conta somente Registros NAO DELETADOS
	If !l265Auto
		Aviso(STR0009,STR0014,{"OK"})  //###"Atencao"###"TODOS ITENS JA FORAM ESTORNADOS ! ! !"
	EndIf
	Return
EndIf

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё M265BUT - Ponto de Entrada para Adicionar botoes        Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If ExistBlock("M265BUT")
	aButtonUsr := ExecBlock("M265BUT",.F.,.F.,{nOpc})
	If ValType(aButtonUsr) == "A"
		For nX:=1 to Len(aButtonUsr)
			aAdd(aButtons,aButtonUsr[nX])
		Next
	EndIf
EndIf

cSeek	 := xFilial("SDB")+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_NUMSEQ+SDA->DA_DOC+SDA->DA_SERIE+SDA->DA_CLIFOR+SDA->DA_LOJA

AAdd(aNoFields,'DB_PRODUTO') ; AAdd(aNoFields,'DB_DOC')     ; AAdd(aNoFields,'DB_SERIE')   ; AAdd(aNoFields,'DB_CLIFOR')
AAdd(aNoFields,'DB_LOJA')    ; AAdd(aNoFields,'DB_TIPONF')  ; AAdd(aNoFields,'DB_ORIGEM')
AAdd(aNoFields,'DB_TM')      ; AAdd(aNoFields,'DB_LOCAL')   ; AAdd(aNoFields,'DB_SERVIC')

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Monta aHeader e aCols                                        Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
PRIVATE aHeader[0],aCols[0]

FillGetDados(nOpc,"SDB",1,cSeek,bSeekWhile,bSeekFor,aNoFields,/*aYesFields*/,/*lOnlyYes*/,/*cQuery*/,/*bMontCols*/,/*lEmpty*/)

//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Descobre a posicao dos campos obrigatorios no AHeaderЁ
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
For nx = 1 To Len(aHeader)
	If Trim(aHeader[nx][2]) == "DB_LOCALIZ"
		nPosLocali:=nX
	ElseIf Trim(aHeader[nx][2]) == "DB_QUANT"
		nPosQuant:=nX
	ElseIf Trim(aHeader[nx][2]) == "DB_DATA"
		nPosData:=nX
	ElseIf Trim(aHeader[nx][2]) == "DB_ESTORNO"
		nPosEstorn:=nX
	ElseIf Trim(aHeader[nx][2]) == "DB_NUMLOTE"
		nPosLote:=nX
	ElseIf Trim(aHeader[nx][2]) == "DB_LOTECTL"
		nPosLotCtl:=nX
	ElseIf Trim(aHeader[nx][2]) == "DB_NUMSERI"
		nPosNumSer:=nX
	ElseIf Trim(aHeader[nx][2]) == "DB_ITEM"
		nPosItem:=nX
	ElseIf Trim(aHeader[nx][2]) == "DB_QTSEGUM"
		nPosQtSegum:=nx
	EndIf
Next nx

AADD(aObjects,{100,095,.T.,.F.,.F.})
AADD(aObjects,{100,100,.T.,.T.,.F.})

aPosObj:=MsObjSize(aInfo,aObjects)

If !l265Auto
	DEFINE MSDIALOG oDlg TITLE cCadastro OF oMainWnd PIXEL FROM aSize[7],0 TO aSize[6],aSize[5]
	EnChoice(cAlias,nReg,nOpc,,,,,{aPosObj[1,1],aPosObj[1,2],aPosObj[1,3],aPosObj[1,4]})
	oGetd := MsGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"A265EstOk","A265ETDOk","",,aAlter)
	ACTIVATE MSDIALOG oDlg ON INIT (oGetd:oBrowse:nRowPos:=Len(aCols),oGetd:oBrowse:Refresh(),EnchoiceBar(oDlg,{|| IIF(oGetd:TudoOk(),(nOpca:=1,oDlg:End()),)},{||oDlg:End()},,aButtons))
Else
	nOpca := 1
	MsAuto2aCols(4,,"DB_ITEM")
	For nI := 1 to SDA->(FCount())
		Aadd(aValidGet,{SDA->(FieldName(nI)),SDA->(FieldGet(nI)),"",.t.})
	Next
	If ! SDB->(MsVldAcAuto(aValidGet,"A265EstOk(o)",,,4,"DB_ITEM"))   // consiste o campos do Acols
		nOpca := 0
	EndIf
EndIf

//зддддддддддддддддддддддддддддддддддддддд©
//Ё PE para validar a execucao do estorno Ё
//юддддддддддддддддддддддддддддддддддддддды
If ExistBlock("M265VEST")
	uRet  := ExecBlock( "M265VEST", .F., .F., {nOpca} )
	nOpca := If(ValType(uRet)=="N", uRet, nOpca)
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Estorna movimentos e baixa saldo a classificar no SB2 e  SDA Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If nOpca == 1
	A265Estorn()
EndIf

RETURN

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA265Grava Ё Autor Ё Rodrigo de A. SartorioЁ Data Ё 06/11/97 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Grava os registros de movimentacao de distribuicao         Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A265Grava()                                                Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA265                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A265Grava()

Local i          := 0
Local nEmpenho   := 0
Local nBaixa     := 0
Local nEmpenho2  := 0
Local nBaixa2    := 0
Local nPos       := 0
Local nX         := 0
Local nQtde      := 0
Local n1Cnt      := 0
Local nSaldoSBF  := 0
Local nPosDCF    := 0
Local nRecnoSDB  := 0
Local nTamNSeri  := FWSX3Util():GetFieldStruct("DB_NUMSERI")[3]

Local cSeek      := ''
Local cSeekSD1   := ''
Local cSeekSD7   := ''
Local cNumSD1    := ''
Local cEndOrig   := ''
Local cTm        := ''
Local cNumSer	 := ''

Local lMTA265I   := (ExistBlock( 'MTA265I' ) )
Local aCpoUsu    := {}

Local lAchouD1   := .F.
Local lGrvEnd    := .F.

Local cLocalCQ   := GetMvNNR('MV_CQ','98')
Local bCampo     := { |nCPO| Field(nCPO) }
Local dDtValid,lCQ
Local aAreaDTC

Local lIntWMS    := Iif(FindFunction("IntWMS"),IntWMS(SDA->DA_PRODUTO),IntDL(SDA->DA_PRODUTO))
Local lExecDCF   := lIntWMS .And. SuperGetMV('MV_RADIOF') == 'S'
Local cServWMSE  := SuperGetMV('MV_SRVWMSE', .F., '499') //-- Servico de WMS Generico para Entradas
Local nPosServ   := aScan(aHeader, { |x| Alltrim(x[2]) == 'DB_SERVIC' })

// Variavel usada no monitoramento de saldos na funcao LogMov() (SIGACUSA)
Local aSldAnt    := {}
Local lIntegPPI  := PCPIntgPPI()

Local aAreaSD3
Local cOldAlias

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Ativa variavel relativa a movimentacao                       Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
lMovimento:=.T.

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Verifica se Existem Campos de Usuario no SX3                 Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
SX3->(dbSetOrder(1))
If SX3->(dbSeek('SDB', .F.))
	Do While !SX3->(Eof()) .And. SX3->X3_ARQUIVO == 'SDB'
		If SX3->X3_PROPRI == 'U'
			aAdd(aCpoUsu, {SX3->X3_CAMPO, SX3->X3_TIPO})
		EndIf
		SX3->(dbSkip())
	EndDo
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Posiciona no almoxarifado correto.                           Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
SB2->(dbSeek(xFilial("SB2")+SDA->DA_PRODUTO+SDA->DA_LOCAL))

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Grava somente novos movimentos.                              Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
For i := nCounter+1 To Len(aCols)
	If !(aCols[i,Len(aCols[i])])
		//-- Validacoes WMS
		If	lIntWMS .And. nPosServ > 0 .And. aCols[i,nPosServ]!=cServWMSE
			If	!Empty(aCols[i,nPosServ]) .And. Empty(SDA->DA_DOC)
				If Type("l265Auto") != "L" .Or. !l265Auto
					Aviso('MATA26502',STR0027,{'Ok'}) //'O campo "DOCUMENTO" deve ser preenchido quando integrado ao WMS.'
				EndIf
				//-- Sai do laco do For sem efetuar gravacoes
				Exit
			EndIf
			//-- Nao permite enderecar quantidade superior ao saldo a distribuir, considerando os
			//-- servicos de enderecamento pendentes na radio frequencia.
			nSaldoSBF := WmsSaldoSBF(SDA->DA_LOCAL,,SDA->DA_PRODUTO,,SDA->DA_LOTECTL,SDA->DA_NUMLOTE,.F.,.T.,.T.,.F.,'3',,SDA->DA_NUMSEQ,SDA->DA_DOC,SDA->DA_SERIE,SDA->DA_CLIFOR,SDA->DA_LOJA)
			If	QtdComp(nSaldoSBF + aCols[i,nPosQuant]) > QtdComp(SDA->DA_SALDO)
				AutoGrLog(Repl('-',80))
				AutoGrLog(STR0029) //'OCORRENCIA NO ENDERECAMENTO MANUAL'
				AutoGrLog(STR0030+SDA->DA_DOC) //'Documento : '
				If	!Empty(SDA->DA_SERIE)
					AutoGrLog(STR0031+SerieNfId("SDA",2,"DA_SERIE")) //'Serie : '
				EndIf
				If	!Empty(SDA->DA_CLIFOR)
					AutoGrLog(STR0032+SDA->DA_CLIFOR) //'Cod.Cli/Forn : '
					AutoGrLog(STR0033+SDA->DA_LOJA) //'Loja : '
				EndIf
				AutoGrLog(STR0034+SDA->DA_LOCAL) //'Armazem : '
				AutoGrLog(STR0035+SDA->DA_PRODUTO) //'Produto : '
				AutoGrLog(' ')
				If	nSaldoSBF > 0
					AutoGrLog(STR0036) //'Existe O.S.WMS pendente para este documento'
					AutoGrLog(' ')
				EndIf
				AutoGrLog(STR0037+Transform(SDA->DA_SALDO-nSaldoSBF,'@E 9,999,999.99')) //'Saldo a distribuir : '
				AutoGrLog(Repl('-',80))
				MostraErro()
				Exit
			EndIf
		EndIf
		//-- Gerar e executar a O.S.WMS sem atualizar o estoque.
		//-- O processo inicia na nota fiscal de entrada, informe o endereco( D1_ENDER ) e
		//-- nao preencha o codigo do servico( D1_SERVIC ),
		//-- pois a O.S.WMS sera gerada e executada no enderecamento de produtos quando o
		//-- codigo de servico( DB_SERVIC ) for diferente do servico de WMS generico para entradas e o
		//-- endereco e estrutura fisica de destino for informado nos campos DB_LOCALIZ e DB_ESTDES.
		If	lIntWMS .And. nPosServ > 0 .And. !Empty(aCols[i,nPosServ]) .And. aCols[i,nPosServ]!=cServWMSE
			//-- Posiciona no item da entrada de nota para identificar o endereco e estrutura inicial
			cTm      := ''
			cEndOrig := ''
			lGrvEnd  := .F.
			nPosDCF  := 0
			If	SDA->DA_ORIGEM == 'SD1'
				SD1->(DbSetOrder(5))
				SD1->(MsSeek(xFilial('SD1')+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_NUMSEQ))
				If	!Empty(SD1->D1_SERVIC)
					If Type("l265Auto") != "L" .Or. !l265Auto
						DLAviso(, 'MATA26501', STR0018+AllTrim(Tabela('L4',SD1->D1_SERVIC,.F.))+STR0019) //'O servico de '###' devera ser executado pela rotina de Execucao de Servicos'
					EndIf
					//-- Sai do laco do For sem efetuar gravacoes
					Exit
				EndIf
				cTm      := SD1->D1_TES
				cEndOrig := SD1->D1_ENDER
			ElseIf SDA->DA_ORIGEM == 'SD3'
				SD3->(DbSetOrder(3))
				SD3->(MsSeek(xFilial('SD3')+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_NUMSEQ))
				cTm := SD3->D3_TM
			ElseIf SDA->DA_ORIGEM == 'SD5'
				//-- gerar OS e nao executar ao informar codigo de servico na rotina de Enderecar saldos (MATA265)
				//-- para saldos gerados pela manutencao de lotes (SD5).
				lExecDCF := .F.
			EndIf
			//-- Solicita a digitacao do endereco e estrutura inicial
			If Empty(cEndOrig)
				DLPergEnd(@cEndOrig,.T.,.T.,'1',SDA->DA_LOCAL) //'Identifique a origem do Servico WMS:'
			EndIf
			WmsCriaDCF('SDA',,,{aCols[i,nPosServ],aCols[i,nPosQuant],cEndOrig},@nPosDCF)

			If lExecDCF .And. !Empty(nPosDCF)
				DCF->(DbGoTo(nPosDCF))
				WmsExeDCF('1')
			EndIf

		Else

			Begin Transaction
			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Chamada da LogMov para verificar o saldo antes da     |
			//| atualizacao das tabelas SB2/SBF/SB8                   |
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			LogMov('SDA',,,SDA->DA_PRODUTO,SDA->DA_LOCAL,,,,,.T.,@aSldAnt)

			If SDA->DA_ORIGEM == 'SD3' .AND. SDA->DA_EMPENHO >0
				// Se nЦo existir o registro na SD3, o empenho da SDA deve ser retirado.
				// Proveniente de uma redistribuiГЦo de estorno de OP (FunГЦo:PergDevLoc()),
				// a qual o movimento (SD3) foi excluido.
				cOldAlias := Alias()
				dbSelectArea("SD3")
				aAreaSD3 := SD3->(GetArea())
				dbSetOrder(4) // d3_filial +d3_numseq
				If !dbSeek(xFilial("SD3")+SDA->DA_NUMSEQ)
					RecLock("SDA",.F.)
					Replace DA_EMPENHO With 0
					Replace DA_EMP2    With 0
					SDA->(MsUnLock())
				EndIf
				RestArea(aAreaSD3)
				If !Empty(cOldAlias)
					dbSelectArea(cOldAlias)
				EndIf
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Gera movimento (SDB)                                         Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			nRecnoSDB := 0
			cNumSer := IIf(nPosNumSer > 0,aCols[i,nPosNumSer],Space(nTamNSeri))
			CriaSDB(SDA->DA_PRODUTO,SDA->DA_LOCAL,aCols[i,nPosQuant],aCols[i,nPosLocali],cNumSer,SDA->DA_DOC,SDA->DA_SERIE,SDA->DA_CLIFOR,SDA->DA_LOJA,SDA->DA_TIPONF,SDA->DA_ORIGEM,aCols[i,nPosData],SDA->DA_LOTECTL,SDA->DA_NUMLOTE,SDA->DA_NUMSEQ,"499","D",aCols[i,nPosItem],.F.,If(SDA->DA_EMPENHO>0,aCols[i,nPosQuant],0),If(nPosQtSegum>0,aCols[i,nPosQtSegum],0),,,,,,,,,,,,,,,,,,,@nRecnoSDB)
			
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Efetua a Gravacao dos Campos de Usuario da Linha do aCols    Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If Len(aCpoUsu) > 0
				RecLock('SDB', .F.)
				For nX := 1 to Len(aCpoUsu)
					nPos:=aScan(aHeader,{|x| x[2] == aCpoUsu[nX,1]})
					If nPos > 0 .And. ValType(aCols[i,nPos])==aCpoUsu[nX,2]
						Replace &(aCpoUsu[nX,1])	With aCols[i, nPos]
					EndIf
				Next nX
				MsUnlock()
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Baixa saldo classificar do arquivo de saldos em estoque (SB2)Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			RecLock("SB2",.F.)
			Replace B2_QACLASS With B2_QACLASS - SDB->DB_QUANT

			If SB2->(ColumnPos("B2_DMOV")) > 0
				REPLACE	B2_DMOV WITH dDataBase
			EndIf

			If SB2->(ColumnPos("B2_HMOV")) > 0
				REPLACE	B2_HMOV WITH Time()
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Atualiza CQ_QTDISP e B2_QEMPSA para baixar pre-requisicao.   Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			A265AtuSA(1)

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Baixa saldo empenhado no arquivo de saldos por sub-lote (SB8)Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If Rastro(SDA->DA_PRODUTO)
				If Rastro(SDA->DA_PRODUTO,"S")
					dbSelectArea("SB8")
					dbSetOrder(3)
					cSeek:=xFilial("SB8")+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_LOTECTL+SDA->DA_NUMLOTE
					If dbSeek(cSeek)
						RecLock("SB8",.F.)
						Replace B8_QACLASS With B8_QACLASS - SDB->DB_QUANT
						Replace B8_QACLAS2 With B8_QACLAS2 - SDB->DB_QTSEGUM
						dDtValid := B8_DTVALID
					EndIf
				Else
					nEmpenho:=SDB->DB_QUANT
					nEmpenho2:=SDB->DB_QTSEGUM
					dbSelectArea("SB8")
					dbSetOrder(3)
					cSeek:=xFilial("SB8")+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_LOTECTL
					dbSeek(cSeek)
					Do While !Eof() .And.  QtdComp(nEmpenho,.T.) >  QtdComp(0,.T.) .And. B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL == cSeek
						nBaixa :=IF( QtdComp(SB8->B8_QACLASS,.T.) <  QtdComp(nEmpenho,.T.),SB8->B8_QACLASS,nEmpenho)
						nBaixa2:=IF( QtdComp(SB8->B8_QACLAS2,.T.) <  QtdComp(nEmpenho2,.T.),SB8->B8_QACLAS2,nEmpenho2)

						Reclock("SB8",.F.)
						Replace B8_QACLASS With B8_QACLASS - nBaixa
						Replace B8_QACLAS2 With B8_QACLAS2 - ConvUM(SB8->B8_PRODUTO, nBaixa, nBaixa2, 2)
						dDtValid := B8_DTVALID
						nEmpenho -= nBaixa
						nEmpenho2-= nBaixa2
						dbSkip()
					EndDo
				EndIf
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Cria Saldo no SBF baseado no movimento                       Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			GravaSBF("SDB",,,nRecnoSDB)

			// Verifica se o produto tem CQ
			cSeekSD7 := xFilial("SD7")+DA_PRODUTO+DA_NUMSEQ+DA_DOC
			SD7->(dbSetOrder(3))
			If SD7->(dbSeek(cSeekSD7))
				cSeekSD1 := xFilial("SD1")+SD7->D7_PRODUTO+SD7->D7_DOC+SD7->D7_SERIE+SD7->D7_FORNECE+SD7->D7_LOJA
				lCQ      := .T.
			Else
				cSeekSD1 := xFilial("SD1")+SDA->DA_PRODUTO+SDA->DA_DOC+SDA->DA_SERIE+SDA->DA_CLIFOR+SDA->DA_LOJA
				lCQ      := .F.
			EndIf

			cNumSD1 := If(lCQ,"SD7->D7_NUMERO == SD1->D1_NUMCQ","SDA->DA_NUMSEQ == SD1->D1_NUMSEQ")

			//-- Caso item da NF seja para OP, grava o numero da OP na requisicao.
			SD1->(dbSetOrder(2))
			SD1->(dbSeek(cSeekSD1))
			While !SD1->(Eof()) .And. SD1->(D1_FILIAL+D1_COD+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA) == cSeekSD1
				If &cNumSD1 .And. !Empty(SD1->D1_OP) .And. (SDA->DA_LOCAL # cLocalCQ)
					lAchouD1 := .T.
					Exit
				EndIf
				SD1->(dbSkip())
			End
			If lAchouD1
				//-- Gera Movimenta┤└o (S) RE5 Ref. a OP no SD1 (SD3)
				SB1->(dbSetOrder(1))
				SB1->(dbSeek(xFilial("SB1")+SDA->DA_PRODUTO))

				RecLock('SD3', .T.)
				Replace D3_FILIAL  With xFilial('SD3')
				Replace D3_COD     With SDA->DA_PRODUTO
				Replace D3_QUANT   With SDB->DB_QUANT
				Replace D3_CF      With 'RE5'
				Replace D3_CHAVE   With 'E0'
				Replace D3_LOCAL   With SDA->DA_LOCAL
				Replace D3_DOC     With If(lCQ,SD7->D7_NUMERO,SDA->DA_DOC)
				Replace D3_EMISSAO With dDataBase
				Replace D3_UM      With SB1->B1_UM
				Replace D3_GRUPO   With SB1->B1_GRUPO
				Replace D3_NUMSEQ  With If(lCQ,SD7->D7_NUMSEQ,SDA->DA_NUMSEQ)
				Replace D3_QTSEGUM With If(lCQ,SD7->D7_QTSEGUM,SDA->DA_QTSEGUM)
				Replace D3_SEGUM   With SB1->B1_SEGUM
				Replace D3_TM      With '999'
				Replace D3_TIPO    With SB1->B1_TIPO
				Replace D3_CONTA   With SB1->B1_CONTA
				Replace D3_USUARIO With CUSERNAME
				Replace D3_OP      With SD1->D1_OP
				Replace D3_NUMLOTE With SDA->DA_NUMLOTE
				Replace D3_LOTECTL With SDA->DA_LOTECTL
				Replace D3_LOCALIZ With aCols[i,nPosLocali]
				Replace D3_IDENT   With SDA->DA_NUMSEQ
				If Rastro(SDA->DA_PRODUTO)
					Replace D3_DTVALID With dDtvALID
				EndIf
				MsUnlock()
				nSD3Rec := Recno()

				// aCM => array com os custos medio do produto
				aCM := If(If(lCQ,SD7->D7_ORIGLAN=='CP',SDA->DA_ORIGEM=='SD1'),PegaCMD1(),PegaCMD3())

				//-- Grava o custo da movimentacao
				aCusto := GravaCusD3(aCM)

				dbSelectArea("SD4")
				dbSetOrder(1)
				If MsSeek(xFilial("SD4")+SD1->D1_COD+SD1->D1_OP)
					nQtde := Min(SD4->D4_QTDEORI-SD4->D4_QUANT,SDB->DB_QUANT)
					RecLock("SD4",.f.)
					SD4->D4_QUANT	:= SD4->D4_QUANT   - nQtde
					SD4->D4_QTSEGUM	:= SD4->D4_QTSEGUM - ConvUM(SD4->D4_COD, nQtde, 0, 2)
					dbSelectArea("SB2")
					dbSetOrder(1)
					If MsSeek(xFilial("SB2")+SD4->D4_COD+SD4->D4_LOCAL)
						RecLock("SB2",.F.)
						nQtde := IIf(nQtde==NIL,SD1->D1_QUANT,nQtde)
						Replace B2_QEMP  With B2_QEMP  - nQtde
						Replace B2_QEMP2 With B2_QEMP2 - ConvUM(SB2->B2_COD, nQtde, 0, 2)
					EndIf
				EndIf

				//-- Atualiza o saldo atual (VATU) com os dados do SD3
				B2AtuComD3(aCusto)

				//-- Acerta custo da OP relacionada na NF de Entrada
				C2AtuComD3(aCusto)

			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Baixa saldo do arquivo de Saldos a classificar   (SDA)       Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			RecLock("SDA",.F.)
			Replace DA_SALDO   With DA_SALDO - SDB->DB_QUANT
			Replace DA_QTSEGUM With DA_QTSEGUM - SDB->DB_QTSEGUM
			Replace DA_EMPENHO With DA_EMPENHO - SDB->DB_EMPENHO
			Replace DA_EMP2    With DA_EMP2 - SDB->DB_EMP2

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Integracao com o Modulo de Transporte (TMS)                  Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If IntTMS()
				aAreaDTC := DTC->(GetArea())
				DUH->(dbSetOrder(1))
				DTC->(dbSetOrder(2))
				If DTC->(MsSeek(xFilial('DTC')+ SDA->(DA_DOC+DA_SERIE+DA_CLIFOR+DA_LOJA) )) .And. ;
						!DUH->(MsSeek(xFilial('DUH')+ cFilAnt + SDA->(DA_DOC+DA_SERIE+DA_CLIFOR+DA_LOJA) ))
					RegToMemory( 'DUH', .T. )
					M->DUH_FILIAL := xFilial('DUH')
					M->DUH_FILORI := cFilAnt
					M->DUH_NUMNFC := SDA->DA_DOC
					M->DUH_SERNFC := SDA->DA_SERIE
					M->DUH_CLIREM := SDA->DA_CLIFOR
					M->DUH_LOJREM := SDA->DA_LOJA
					M->DUH_LOCAL  := SDA->DA_LOCAL
					M->DUH_QTDVOL := GdFieldGet('DB_QUANT'  ,i)
					M->DUH_LOCALI := GdFieldGet('DB_LOCALIZ',i)
						M->DUH_CODPRO  := SDA->DA_PRODUTO
					nCampos := DUH->( FCount() )
					RecLock('DUH',.T.)
					For n1Cnt := 1 To nCampos
						FieldPut( n1Cnt, M->&( Eval( bCampo,n1Cnt ) ) )
					Next
					SerieNfId("DUH",1,"DUH_SERNFC",,,SDA->DA_SERIE,SDA->DA_SERIE)
					MsUnLock()
				EndIf
				RestArea(aAreaDTC)
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Chamada da LogMov apos atualizacao das tabelas SB2/SBF/SB8 |
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			LogMov('SDA',,,SDA->DA_PRODUTO,SDA->DA_LOCAL,,,,,,aClone(aSldAnt))

			if !lAchouD1 .AND. lIntegPPI
				// Quando nЦo tА gerando SD3, quer dizer que jА gerou
				// A mensagem gerada nЦo foi enviada, entЦo a mandar a msg atualizada para o PPI
				nRecNoSDA := SDA->(Recno())
				dbSelectArea("SOE")
				SOE->(dbSetOrder(1))
				If SOE->(dbSeek(xFilial("SOE")+"SB2")) .AND. ALLTRIM(SOE->OE_PARINTG) == '1'
					If !isApontMES() //Se o movimento foi gerado pelo Totvs MES, nЦo И necessАrio executar a integraГЦo dos saldos.
						MATA225PPI(SDA->DA_PRODUTO,;
									SDA->DA_LOCAL,;
									aCols[i,nPosLocali],;
									aCols[i,nPosNumSer],;
									SDA->DA_LOTECTL,;
									SDA->DA_NUMLOTE,;
									dDtvALID,;
									SDB->DB_QUANT,;
									if(SDB->DB_TM<'500','1','2'),;
									SDA->DA_NUMSEQ,;
									SDA->DA_DOC)
					EndIf
				Endif

				SDA->(DbGoTo(nRecNoSDA))
			Endif

			End Transaction

			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Ponto de entrada Posterior a gravacao na Inclus└o - MTA265I       Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lMTA265I
				ExecBlock("MTA265I", .F., .F., {i})
			EndIf

		EndIf
	EndIf
Next i

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Integracao com o Modulo de Transporte (TMS) caso o documento Ё
//Ё seja relacionado a alguma viagem                             Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If IntTMS() .And. (QtdComp(SDA->DA_SALDO) == QtdComp(0))
	A265DocTMS(.F.)
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//ЁExecuta P.E. apos gravacao das movimentacoes/integracoes      Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If (ExistBlock("MTA265GRV"))
	ExecBlock("MTA265GRV",.F.,.F.)
EndIf

RETURN

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA265EstornЁ Autor Ё Rodrigo de A. SartorioЁ Data Ё 06/11/97 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Estorna gravacao de movimentacao de distribuicao           Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A265Estorn()                                               Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA265                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A265Estorn()

Local cSeek      := ''
Local cSeek2     := ''
Local cSeekSD1   := ''
Local cSeekSD7   := ''
Local cNumSD1    := ''
Local i          := 0
Local nEmpenho   := 0
Local nBaixa     := 0
Local nEmpenho2  := 0
Local nBaixa2    := 0
Local nPos       := 0
Local nX         := 0
Local nZ         := 0
Local nSldDE5    := 0
Local nRestaura  := 0
Local nRestDC    := 0
Local nRecnoSDB  := 0
Local nCount     := 0
Local nQtdEnd    := 0
Local nQtdLote   := 0

Local aCpoUsu    := {}
Local aArray     := {}
Local aTravas    := {}

Local lMTA265E   := (ExistBlock( 'MTA265E' ) )
Local lMT265ACD   := ExistBlock('MT265ACD')
Local lIntACD	 := SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local dDataFec   := MVUlmes()
Local lAchouD1   := .F.

Local dDtValid,lCQ

Local cLocalCQ   := GetMvNNR('MV_CQ','98')
Local lEmpPrev   := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
Local lRe5       := .F.
Local cDistaut	 := SuperGETMV("MV_DISTAUT")

Local lIntegPPI  := PCPIntgPPI()

// Variavel usada no monitoramento de saldos na funcao LogMov() (SIGACUSA)
Local aSldAnt    := {}

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Verificar data do ultimo fechamento em SX6.                  Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If dDataFec >= dDataBase
	Help ( " ", 1, "FECHTO" )
	Return
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Verifica se Existem Campos de Usuario no SX3                 Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
SX3->(dbSetOrder(1))
If SX3->(dbSeek('SDB', .F.))
	Do While !SX3->(Eof()) .And. SX3->X3_ARQUIVO == 'SDB'
		If SX3->X3_PROPRI == 'U'
			aAdd(aCpoUsu, {SX3->X3_CAMPO, SX3->X3_TIPO})
		EndIf
		SX3->(dbSkip())
	EndDo
EndIf


//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Verifica se no SD3 o D3_CF = RE5                             Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
SD3->(dbSetOrder(2))
SD3->(MsSeek(xFilial("SD3")+SDA->DA_DOC+SDA->DA_PRODUTO))
While !Eof() .And. xFilial("SD3")+SDA->DA_DOC+SDA->DA_PRODUTO == SD3->D3_FILIAL+SD3->D3_DOC+SD3->D3_COD
	If SD3->D3_CF == "RE5" .And. !Empty(SD3->D3_OP) .And. SDA->DA_NUMSEQ+SDA->DA_LOTECTL == SD3->D3_NUMSEQ+SD3->D3_LOTECTL .And. SD3->D3_ESTORNO # "S"
		lRe5 := .T.
		Exit
	EndIf
	SD3->(dbSkip())
EndDo

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Posiciona no almoxarifado correto.                           Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
SB2->(dbSeek(xFilial("SB2")+SDA->DA_PRODUTO+SDA->DA_LOCAL))

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Processa somente novos estornos.                             Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
For i:=1 To Len(aCols)
	If aCols[i,nPosEstorn] == "S"
		// Chamada da funГЦo SldPorLote para validar o saldo antes do Estorno
		aArray:=SldPorLote(SDA->DA_PRODUTO,SDA->DA_LOCAL,aCols[i,nPosQuant],If(nPosQtSegum>0,aCols[i,nPosQtSegum],0),SDA->DA_LOTECTL,SDA->DA_NUMLOTE,aCols[i,nPosLocali],aCols[i,nPosNumSer],@aTravas,NIL,NIL,.T.)
		nQtdEnd  := 0
		nQtdLote := 0
		For nX := 1 to Len(aArray)
			nQtdEnd += aArray[nX,5]
			For nZ := 1 to Len(aArray[nX,10])
				nQtdLote += aArray[nX,10,nZ,2]
			Next nZ
		Next
		If lRe5 .Or. (QtdComp(nQtdEnd,.T.) >= QtdComp(aCols[i,nPosQuant],.T.) .And. IIf(Rastro(SDA->DA_PRODUTO),QtdComp(nQtdLote,.T.) >= QtdComp(aCols[i,nPosQuant],.T.),.T.))
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Grava movimento de estorno (SDB)                             Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If UsaCb0("01") .And. (lIntACD) .And. !lMT265ACD
				//Valida se a etiqueta que estА sendo estornada pertence ao movimento antes de estornar
				If !CBMTA265E(1,i) .and. cDistaut <> SB2->B2_LOCAL + alltrim(aCols[i,nPosLocali])
					Return
				EndIf
			EndIf

			Begin Transaction
				//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Chamada da LogMov para verificar o saldo antes da     |
				//| atualizacao das tabelas SB2/SBF/SB8                   |
				//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				LogMov('SDA',,,SDA->DA_PRODUTO,SDA->DA_LOCAL,,,,,.T.,@aSldAnt)

				dbSelectArea("SDB")
				dbSetOrder(1)
				cSeek:=xFilial("SDB")+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_NUMSEQ+SDA->DA_DOC+SDA->DA_SERIE+SDA->DA_CLIFOR+SDA->DA_LOJA+aCols[i,nPosItem]
				dbSeek(cSeek)
				Do While !Eof() .And. cSeek == DB_FILIAL+DB_PRODUTO+DB_LOCAL+DB_NUMSEQ+DB_DOC+DB_SERIE+DB_CLIFOR+DB_LOJA+DB_ITEM
					If DB_TIPO == "D" .And. DB_ESTORNO # "S"
						Exit
					EndIf
					dbSkip()
				EndDo
				RecLock("SDB",.F.)
				Replace DB_ESTORNO WITH "S"
				nRecnoSDB := 0
				CriaSDB(SDA->DA_PRODUTO,SDA->DA_LOCAL,aCols[i,nPosQuant],aCols[i,nPosLocali],aCols[i,nPosNumSer],SDA->DA_DOC,SDA->DA_SERIE,SDA->DA_CLIFOR,SDA->DA_LOJA,SDA->DA_TIPONF,SDA->DA_ORIGEM,aCols[i,nPosData],SDA->DA_LOTECTL,SDA->DA_NUMLOTE,SDA->DA_NUMSEQ,"999","D",aCols[i,nPosItem],.T.,If(SDA->DA_EMPENHO>0,aCols[i,nPosQuant],0),If(nPosQtSegum>0,aCols[i,nPosQtSegum],0),,,,,,,,,,,,,,,,,,,@nRecnoSDB)

				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Efetua a Gravacao dos Campos de Usuario da Linha do aCols    Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If Len(aCpoUsu) > 0
					RecLock('SDB', .F.)
					For nX := 1 to Len(aCpoUsu)
						If (nPos:=aScan(aHeader,{|x|x[2]==aCpoUsu[nX,1]}))>0 .And. ValType(aCols[i,nPos])==aCpoUsu[nX,2]
							Replace &(aCpoUsu[nX,1])	With aCols[i, nPos]
						EndIf
					Next nX
					MsUnlock()
				EndIf

				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Soma saldo classificar no arquivo de saldos em estoque (SB2) Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				RecLock("SB2",.F.)
				Replace B2_QACLASS With B2_QACLASS + SDB->DB_QUANT

				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Atualiza CQ_QTDISP e B2_QEMPSA para estornar pre-requisicao. Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				A265AtuSA(2)

				// Verifica se o produto tem CQ
				cSeekSD7 := xFilial("SD7")+DA_PRODUTO+DA_NUMSEQ+DA_DOC
				SD7->(dbSetOrder(3))
				If SD7->(dbSeek(cSeekSD7))
					cSeekSD1 := xFilial("SD1")+SD7->D7_PRODUTO+SD7->D7_DOC+SD7->D7_SERIE+SD7->D7_FORNECE+SD7->D7_LOJA
					lCQ     := .T.
				Else
					cSeekSD1 := xFilial("SD1")+	SDA->DA_PRODUTO+SDA->DA_DOC+SDA->DA_SERIE+SDA->DA_CLIFOR+SDA->DA_LOJA
					lCQ     := .F.
				EndIf

				cNumSD1 := If(lCQ,"SD7->D7_NUMERO == SD1->D1_NUMCQ","SDA->DA_NUMSEQ == SD1->D1_NUMSEQ")

				//-- Caso item da NF seja para OP, grava o numero da OP na requisicao.
				SD1->(dbSetOrder(2))
				SD1->(dbSeek(cSeekSD1))
				If &cNumSD1 .And. !Empty(SD1->D1_OP) .And. (SDA->DA_LOCAL # cLocalCQ)
					lAchouD1 := .T.
				EndIf

				If lAchouD1
					//-- Gera Movimenta┤└o (S) RE5 Ref. a OP no SD1 (SD3)
					SB1->(dbSetOrder(1))
					SB1->(dbSeek(xFilial("SB1")+SDA->DA_PRODUTO))
					SD3->(dbSetOrder(2))
					SD3->(MsSeek(xFilial("SD3")+SDA->DA_DOC+SDA->DA_PRODUTO))
					While xFilial("SD3")+SDA->DA_DOC+SDA->DA_PRODUTO == SD3->D3_FILIAL+SD3->D3_DOC+SD3->D3_COD
						If SD3->D3_CF == "RE5" .And. !Empty(SD3->D3_OP) .And. SDA->DA_NUMSEQ+SDA->DA_LOTECTL == SD3->D3_NUMSEQ+SD3->D3_LOTECTL .And. SD3->D3_ESTORNO # "S" .And. SDB->DB_QUANT == SD3->D3_QUANT
							RecLock('SD3', .F.)				// Estorno do RE5
							Replace D3_ESTORNO With "S"
							dDtValid := SD3->D3_DTVALID
							Exit
						EndIf
						SD3->(dbSkip())
					EndDo
					RecLock('SD3', .T.)			 	// Cria DE5
					Replace D3_FILIAL  With xFilial('SD3')
					Replace D3_COD     With SDA->DA_PRODUTO
					Replace D3_QUANT   With SDB->DB_QUANT
					Replace D3_CF      With 'DE5'
					Replace D3_CHAVE   With 'E9'
					Replace D3_LOCAL   With SDA->DA_LOCAL
					Replace D3_DOC     With If(lCQ,SD7->D7_NUMERO,SDA->DA_DOC)
					Replace D3_EMISSAO With dDataBase
					Replace D3_UM      With SB1->B1_UM
					Replace D3_GRUPO   With SB1->B1_GRUPO
					Replace D3_NUMSEQ  With If(lCQ,SD7->D7_NUMSEQ,SDA->DA_NUMSEQ)
					Replace D3_QTSEGUM With If(lCQ,SD7->D7_QTSEGUM,SDA->DA_QTSEGUM)
					Replace D3_SEGUM   With SB1->B1_SEGUM
					Replace D3_TM      With '499'
					Replace D3_TIPO    With SB1->B1_TIPO
					Replace D3_CONTA   With SB1->B1_CONTA
					Replace D3_USUARIO With CUSERNAME
					Replace D3_OP      With SD1->D1_OP
					Replace D3_NUMLOTE With SDA->DA_NUMLOTE
					Replace D3_LOTECTL With SDA->DA_LOTECTL
					Replace D3_LOCALIZ With aCols[i,nPosLocali]
					Replace D3_IDENT   With SDA->DA_NUMSEQ
					Replace D3_DTVALID With dDtValid
					Replace D3_ESTORNO With "S"
					MsUnlock()
					nSD3Rec := Recno()
					// aCM => array com os custos medio do produto
					aCM := If(If(lCQ,SD7->D7_ORIGLAN=='CP',SDA->DA_ORIGEM=='SD1'),PegaCMD1(),PegaCMD3())
					//-- Grava o custo da movimentacao
					aCusto := GravaCusD3(aCM)
					nSldDE5 := SDB->DB_QUANT
					dbSelectArea("SD4")
					dbSetOrder(1)
					MsSeek(xFilial("SD4")+SD1->D1_COD+SD1->D1_OP)
					While nSldDE5 > 0
						If SD4->(D4_FILIAL+D4_COD+D4_OP) == xFilial("SD4")+SD1->(D1_COD+D1_OP)
							If QtdComp(SD4->D4_QUANT,.T.) < QtdComp(SD4->D4_QTDEORI,.T.) .And.;
								!A103ChkBN(SD4->D4_OP, SD4->D4_COD, SD4->D4_LOCAL, SD4->(Recno()))
								RecLock("SD4",.f.)
								nRestaura := Min(nSldDe5,SD4->D4_QTDEORI-SD4->D4_QUANT)
								SD4->D4_QUANT	:= SD4->D4_QUANT   + nRestaura
								SD4->D4_QTSEGUM	:= SD4->D4_QTSEGUM + ConvUM(SD4->D4_COD, nRestaura, 0, 2)
								dbSelectArea("SB2")
								dbSetOrder(1)
								If MsSeek(xFilial("SB2")+SD4->D4_COD+SD4->D4_LOCAL)
									RecLock("SB2",.F.)
									Replace B2_QEMP  With B2_QEMP  + nRestaura
									Replace B2_QEMP2 With B2_QEMP2 + ConvUM(SB2->B2_COD, nRestaura, 0, 2)
								EndIf
								dbSelectArea("SDC")
								dbSetOrder(2)
								MsSeek(xFilial("SDC")+SD1->(D1_COD+D1_LOCAL+D1_OP))
								nRestDC := nRestaura
								While QtdComp(nRestDC,.T.) > QtdComp(0,.T.) .And. SDC->(DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP) == xFilial("SDC")+SD1->(D1_COD+D1_LOCAL+D1_OP)
									If SDC->DC_QUANT < SDC->DC_QTDORIG
										RecLock("SDC",.F.)
										SDC->DC_QUANT += Min(nRestDC,SDC->DC_QTDORIG)
										SDC->DC_QTSEGUM += ConvUM(SDC->DC_PRODUTO,Min(nRestDC,SDC->DC_QTDORIG),0,2)
										MsUnlock()
										dbSelectArea("SBF")
										dbSetOrder(1)
										If MsSeek(xFilial("SBF")+SDC->(DC_LOCAL+DC_LOCALIZ+DC_PRODUTO),.F.)
											RecLock("SBF",.F.)
											SBF->BF_EMPENHO += Min(nRestDC,SDC->DC_QTDORIG)
											SBF->BF_EMPEN2 += ConvUM(SBF->BF_PRODUTO,Min(nRestDC,SDC->DC_QTDORIG),0,2)
											MsUnlock()
										EndIf
										nRestDC -= Min(nRestDC,SDC->DC_QTDORIG)
									EndIf
									SDC->(dbSkip())
								End
								nSldDE5 -= nRestaura
							EndIf
							SD4->(dbSkip())
						Else
							nSldDE5 := 0
						EndIf
					End
					//-- Atualiza o saldo atual (VATU) com os dados do SD3
					B2AtuComD3(aCusto)
					//-- Acerta custo da OP relacionada na NF de Entrada
					C2AtuComD3(aCusto)
				EndIf

				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Baixa saldo empenhado no arquivo de saldos por sub-lote (SB8)Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If Rastro(SDA->DA_PRODUTO)
					If Rastro(SDA->DA_PRODUTO,"S")
						dbSelectArea("SB8")
						dbSetOrder(3)
						cSeek2:=xFilial("SB8")+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_LOTECTL+SDA->DA_NUMLOTE
						If dbSeek(cSeek2)
							RecLock("SB8",.F.)
							Replace B8_QACLASS With B8_QACLASS + SDB->DB_QUANT
							Replace B8_QACLAS2 With B8_QACLAS2 + SDB->DB_QTSEGUM
						EndIf
					Else
						nEmpenho:=SDB->DB_QUANT
						nEmpenho2:=SDB->DB_QTSEGUM
						dbSelectArea("SB8")
						dbSetOrder(3)
						dbSelectArea("SD5")
						dbSetOrder(3)
						dbSeek(xFilial("SD5")+SDB->DB_NUMSEQ+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_LOTECTL)
						While !Eof() .And. nEmpenho > 0 .And. D5_FILIAL+D5_NUMSEQ+D5_PRODUTO+D5_LOCAL+D5_LOTECTL == xFilial("SD5")+SDB->DB_NUMSEQ+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_LOTECTL
							dbSelectArea("SB8")
							If dbSeek(xFilial("SB8")+SD5->D5_PRODUTO+SD5->D5_LOCAL+SD5->D5_LOTECTL+SD5->D5_NUMLOTE)
								nBaixa:=If(SB8Saldo(Nil,Nil,Nil,Nil,Nil,lEmpPrev) < nEmpenho,SB8Saldo(Nil,Nil,Nil,Nil,Nil,lEmpPrev),nEmpenho)
								nBaixa2:=If(SB8Saldo(Nil,Nil,Nil,.T.,Nil,lEmpPrev) < nEmpenho2,SB8Saldo(Nil,Nil,Nil,.T.,Nil,lEmpPrev),nEmpenho2)
								Reclock("SB8",.F.)
								Replace B8_QACLASS With B8_QACLASS + nBaixa
								Replace B8_QACLAS2 With B8_QACLAS2 + ConvUM(SB8->B8_PRODUTO, nBaixa, nBaixa2, 2)
								nEmpenho -= nBaixa
								nEmpenho2-= nBaixa2
							EndIf
							dbSelectArea("SD5")
							dbSkip()
						End
						dbSelectArea("SB8")
						dbSetOrder(3)
						cSeek2:=xFilial("SB8")+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_LOTECTL
						dbSeek(cSeek2)
						Do While !Eof() .And. nEmpenho > 0 .And. B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL == cSeek2
							nBaixa:=If(SB8Saldo(Nil,Nil,Nil,Nil,Nil,lEmpPrev) < nEmpenho,SB8Saldo(Nil,Nil,Nil,Nil,Nil,lEmpPrev),nEmpenho)
							nBaixa2:=If(SB8Saldo(Nil,Nil,Nil,.T.,Nil,lEmpPrev) < nEmpenho2,SB8Saldo(Nil,Nil,Nil,.T.,Nil,lEmpPrev),nEmpenho2)
							Reclock("SB8",.F.)
							Replace B8_QACLASS With B8_QACLASS + nBaixa
							Replace B8_QACLAS2 With B8_QACLAS2 + ConvUM(SB8->B8_PRODUTO, nBaixa, nBaixa2, 2)
							nEmpenho -= nBaixa
							nEmpenho2-= nBaixa2
							dbSkip()
						EndDo
					EndIf
				EndIf

				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Soma saldo no arquivo de Saldos a classificar   (SDA)        Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				RecLock("SDA",.F.)
				Replace DA_SALDO   With DA_SALDO + SDB->DB_QUANT
				Replace DA_QTSEGUM With DA_QTSEGUM + SDB->DB_QTSEGUM
				Replace DA_EMPENHO With DA_EMPENHO + SDB->DB_EMPENHO
				Replace DA_EMP2    With DA_EMP2 + SDB->DB_EMP2
				//Se nЦo achou SD1, nЦo executou a funГЦo B2AtuComD3, e nЦo fez integraГЦo com Totvs MES.
				//Nesse caso, executa a integraГЦo com o MES.
				If !lAchouD1 .And. lIntegPPI
					dbSelectArea("SOE")
					SOE->(dbSetOrder(1))
					If SOE->(dbSeek(xFilial("SOE")+"SB2")) .AND. ALLTRIM(SOE->OE_PARINTG) == '1'
						If !isApontMES()
							MATA225PPI(SDB->DB_PRODUTO,;
										SDB->DB_LOCAL,;
										SDB->DB_LOCALIZ,;
										SDB->DB_NUMSERI,;
										SDB->DB_LOTECTL,;
										SDB->DB_NUMLOTE,;
										IF(Rastro(SDA->DA_PRODUTO),SB8->B8_DTVALID,SDB->DB_DATA),;
										SDB->DB_QUANT,;
										'2',;
										SDB->DB_NUMSEQ,;
										SDB->DB_DOC)
						EndIf
					Endif
				EndIf

				If IntTMS()
					DUH->( dbSetOrder( 1 ) )
					If DUH->( MsSeek( xFilial("DUH")+ cFilAnt + SDA->( DA_DOC+DA_SERIE+DA_CLIFOR+DA_LOJA ) ) )
						RecLock( "DUH", .F. )
						DUH->(DbDelete())
						MsUnLock()
					EndIf
				EndIf

				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Baixa Saldo no SBF baseado no movimento                      Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				GravaSBF("SDB",,,nRecnoSDB)

				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Chamada da LogMov apos atualizacao das tabelas SB2/SBF/SB8 |
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				LogMov('SDA',,,SDA->DA_PRODUTO,SDA->DA_LOCAL,,,,,,aClone(aSldAnt))

			End Transaction

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Integracao com o ACD - Faz Acerto do CB0 no estorno da Distribuicao 	   Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lIntACD .And. !lMT265ACD
				CBMTA265E(2,i)
			//здддддддддддддддддддддддддддддддддддддддддд©
			//ЁTemplate de acinamento de ponto de entradaЁ
			//юдддддддддддддддддддддддддддддддддддддддддды
			ElseIf ExistTemplate("MTA265E")
				ExecTemplate("MTA265E", .F., .F., {i} )
			EndIf

			If lMTA265E
				ExecBlock("MTA265E", .F., .F., {i} )
			EndIf

		Else
			nCount++
		EndIf
		MaDesTrava(aTravas)
	EndIf
Next i

If nCount > 0
	Help(" ",1,"MA265QTEST")
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Integracao com o Modulo de Transporte (TMS) caso o documento Ё
//Ё seja relacionado a alguma viagem                             Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If IntTMS() .And. QtdComp(SDA->DA_SALDO) > QtdComp(0)
	A265DocTMS(.T.)
EndIf
RETURN

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA265VldAllЁ Autor Ё Rodrigo de A. SartorioЁ Data Ё 06/11/97 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Valida campo a campo na GetDados p/ impedir alteracao em   Ё╠╠
╠╠Ё          Ё movimentos anteriores.                                     Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A265VldAll()                                               Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA265                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A265VldAll()
Local nx
Local cVar:=Alltrim(ReadVar())
Local lRet:=.T.
//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Verifica somente se a linha for de movimento anterior ou estorno.Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If n <= nCounter
	For nX := 1 to Len(aHeader)
		If AllTrim(aHeader[nX][2]) == Substr(cVar,4,10)
			If &(cVar) # aCols[n][nX]
				HELP(" ",1,"A175NAO")
				lRet:=.F.
				Exit
			EndIf
		EndIf
	Next nX
ElseIf cVar == "M->DB_ESTORNO"
	HELP(" ",1,"A265NAOEST")
	lRet:=.F.
EndIf
Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA265TudoOkЁ Autor Ё Rodrigo de A. SartorioЁ Data Ё 17/09/99 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Valida a GetDados antes de abandonar                       Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A265TudoOk()                                               Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA265                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A265TudoOk(o)
Local lRet	:=.T.
Local lRetPE:=.T.
Local nX    := 0
Local nAnt  := n

For nX :=1 To Len(aCols)
	n:= nX
	lRet := A265LinOk(o)
	If !lRet
		Exit
	Endif
Next

n:= nAnt

If lRet .And. ExistBlock("MA265TDOK")
	lRetPE:=ExecBlock("MA265TDOK",.F.,.F.)
	If ValType(lRetPE) == "L"
		lRet:=lRetPE
	EndIf
EndIf
Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA265LinOK Ё Autor Ё Rodrigo de A. SartorioЁ Data Ё 06/11/97 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Valida a linha da GetDados na inclusao                     Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A265LinOk()                                                Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA265                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A265LinOk(o)
Local lRet       := .T.
Local i          := 0
Local nQuant     := 0
Local nQuant2    := 0
Local nQuantCols := 0
Local nAchou     := 0
Local nPosDCF    := 0
Local nPQtSegum	 := 0

Local cSeek      := ''
Local cServico   := ''
Local cSeekSD1   := ''
local cSeekSD3   := ''
Local cPNumSer	 := ''

Local aArea      := GetArea()
Local aInfProd   := InfProd(SDA->DA_PRODUTO)
Local lIntegEIC  := (SuperGetMV("MV_EASY") == "S")
Local dDataFec   := MVUlmes()
Local cAcao      := "2"
Local nPosRecn   := aScan(aHeader, { |x| Alltrim(x[2]) == 'DB_REC_WT' })
Local nPosServ   := aScan(aHeader, { |x| Alltrim(x[2]) == 'DB_SERVIC' })
Local nTamNSeri  := FWSX3Util():GetFieldStruct("DB_NUMSERI")[3]
Local lWmsMsg    := .T.

l265Auto := If(ValType(l265Auto) == "L",l265Auto,.F.)

If !(aCols[n,Len(aCols[n])])

	If l265Auto
		n := Len(aCols)	  // Posiciona a variavel "N" utilizada para definir a linha atual do aCols
	EndIf

	//-- Verifica se o movimento de origem foi excluido por outro usuario
	lRet := lRet .AND. LocMovOri()

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica campos obrigatorios                                 Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If (Empty(aCols[n,nPosLocali]) .And. Empty(aCols[n,nPosNumSer])) .Or. Empty(aCols[n,nPosQuant]) .Or. Empty(aCols[n,nPosData])
		Help(" ",1,"MA260OBR")
		lRet:=.F.
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Valida data maior ou igual a data original do movimento      Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. aCols[n,nPosData] < SDA->DA_DATA
		Help(" ",1,"DATADISTRI")
		lRet:=.F.
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Valida se a data do Movimento e' Menor que a data de ultimo fechamento  Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. dDataFec >= aCols[n,nPosData] .And. aCols[n,nPosData] == dDataBase
		Help ( " ", 1, "FECHTO" )
		lRet:=.F.
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Valida quantidade IGUAL A 1 quando usa numero de serie       Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	cPNumSer  := IIf(nPosNumSer > 0, aCols[n,nPosNumSer],Space(nTamNSeri))
	nPQtSegum := IIf(nPosQtSegum > 0,aCols[n,nPosQtSegum], 0)

	If lRet
		lRet:=MtAvlNSer(SDA->DA_PRODUTO,cPNumSer,aCols[n,nPosQuant],nPQtSegum)
	EndIf
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se j═ nao existe um numero de serie p/ este produto Ё
	//Ё neste almoxarifado.                                          Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. nPosNumSer > 0 .AND. n >= nCounter+1 .And. !Empty(aCols[n,nPosNumSer])
		dbSelectArea("SBF")
		dbSetOrder(4)
		cSeek  := xFilial("SBF")+SDA->DA_PRODUTO+aCols[n,nPosNumSer]
		nAchou := ASCAN(aCols,{|x| x[nPosNumSer] == aCols[n,nPosNumSer] .And. Empty(x[nPosEstorn]) })
		If (nAchou > 0 .And. nAchou >= nCounter+1 .And. nAchou # n) .Or. (dbSeek(cSeek) .And. QtdComp(BF_QUANT) > QtdComp(0))
			Help(" ",1,"NUMSERIEEX")
			lRet:=.F.
		EndIf
	EndIf
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se nao existe outro produto nesta localizacao que   Ё
	//Ё utilize controle de area.                                    Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se nao existe outro produto nesta localizacao que   Ё
	//Ё utilize controle de area.                                    Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet
		If aCols[n,nPosRecn] == 0
			SBE->(dbSetOrder(1))
			If SBE->(dbSeek(xFilial("SBE")+SDA->DA_LOCAL+aCols[n,nPosLocali]))
				//зддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Verifica se utiliza controle de Cubagem         Ё
				//юддддддддддддддддддддддддддддддддддддддддддддддддды
				If aInfProd[1] .OR. (SBE->BE_ALTURLC*SBE->BE_LARGLC*SBE->BE_COMPRLC > 0)
					lRet:=ProdLocali(SDA->DA_PRODUTO,SDA->DA_LOCAL,aCols[n,nPosLocali])
				EndIf
			EndIf
		EndIf
	EndIf
	If lRet
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se qtd distribuida nao ultrapassou o saldo a ser    Ё
		//Ё distribuido.                                                 Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		For i:= 1 to Len(aCols)
			If aCols[i,nPosEstorn] # "S" .And. !(aCols[i,Len(aCols[i])])
				nQuant+= aCols[i,nPosQuant]
				If nPosQtSegum > 0
					nQuant2+= aCols[i,nPosQtSegum]
				EndIf
			EndIf
		Next i
		If QtdComp(nQuant) > QtdComp(SDA->DA_QTDORI) .Or. If(nPosQtSegum > 0,QtdComp(NoRound(nQuant2, TamSx3("DA_QTDORI2")[2])) > QtdComp(SDA->DA_QTDORI2),.F.)
			Help(" ",1,"MA265QUANT")
			lRet:=.F.
		EndIf
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se o produto est═ sendo inventariado.      Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. BlqInvent(SDA->DA_PRODUTO, SDA->DA_LOCAL)
		Help(" ",1,"BLQINVENT",,SDA->DA_PRODUTO + OemToAnsi(STR0017) + SDA->DA_LOCAL,1,11) //" Almox: "
		lRet:=.F.
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se qtd distribuida nao ultrapassou a capacidade da  Ё
	//Ё localizacao.                                                 Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. !Empty(aCols[n,nPosLocali])
		For i:=nCounter+1 to Len(aCols)
			If aCols[i,nPosLocali] == aCols[n,nPosLocali]
				nQuantCols+=aCols[i,nPosQuant]
			EndIf
		Next i
		lRet:=Capacidade(SDA->DA_LOCAL,aCols[n,nPosLocali],nQuantCols,SDA->DA_PRODUTO)
	EndIf
	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se qtde a distribuir foi empenhada conforme conceito da processo de importaГЦo, se sim, nЦo    Ё
	//Ё permitir a distribuiГЦo dos produtos.                                                                   Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. cPaisLoc != "BRA" .And. lIntegEIC .And. Rastro(SDA->DA_PRODUTO)
		If SaldoSDA(SDA->DA_PRODUTO,SDA->DA_LOCAL,SDA->DA_LOTECTL,SDA->DA_NUMLOTE,.T. ) < aCols[len(Acols)][nPosQuant]
			If !l265Auto
				Aviso(STR0016,STR0017, { "  OK  " } )
			EndIf
			lRet := .F.
		EndIf
	EndIf
	If lRet .And. Iif(FindFunction("IntWMS"),IntWMS(SDA->DA_PRODUTO),IntDL(SDA->DA_PRODUTO))
		cServico := ''
		If SDA->DA_ORIGEM == 'SD1'
		   SD1->(DbSetOrder(5))
		   If SD1->(MsSeek(cSeekSD1:=xFilial("SD1")+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_NUMSEQ))
		      cServico := SD1->D1_SERVIC
		   EndIf
		ElseIf SDA->DA_ORIGEM == 'SD3'
			SD3->(DbSetOrder(3)) //D3_FILIAL+D3_COD+D3_LOCAL+D3_NUMSEQ
			If SD3->(MsSeek(cSeekSD3:=xFilial('SD3')+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_NUMSEQ))
				While SD3->(!Eof() .And. D3_FILIAL+D3_COD+D3_LOCAL+D3_NUMSEQ == cSeekSD3)
					If (SD3->D3_ESTORNO # 'S') .And. !Empty(SD3->D3_SERVIC)
						cServico := SD3->D3_SERVIC
					EndIf
					SD3->(DbSkip())
				EndDo
			EndIf
		EndIf
		// --- Validacoes WMS
		lWmsMsg := WmsMsgExibe(!l265Auto)
		If !Empty(cServico)
			//-- Verifica se o servico diferente de conferencia 000005 - DLCONFEREN
			DC5->(DbSetOrder(1)) //DC5_FILIAL+DC5_SERVIC+DC5_ORDEM
			If DC5->(MsSeek(xFilial('DC5')+cServico) .And. DC5_FUNEXE<>'000005')
				If lRet .And. WmsChkDCF(SDA->DA_ORIGEM,,,cServico,,,SDA->DA_DOC,SDA->DA_SERIE,SDA->DA_CLIFOR,SDA->DA_LOJA,SDA->DA_LOCAL,SDA->DA_PRODUTO,,,SDA->DA_NUMSEQ,,@nPosDCF,cAcao)
				   lRet := WmsAvalDCF('2')
				   If lRet
					   If l265Auto .Or. SuperGetMV('MV_WMSDCFV',.F.,.F.) .Or. Aviso(STR0009,STR0023,{STR0025,STR0026}) == 1 //'Atencao'###'Este endereГamento possui serviГo WMS. Estorna O.S.WMS ?'###'Sim'###'Nao'
					      WmsDelDCF('1',SDA->DA_ORIGEM,DCF->DCF_ID,!l265Auto)
					   Else
					      lRet := .F.
					   EndIf
					EndIf
				EndIf
			EndIf
		EndIf
		cServico := Iif(nPosServ>0,aCols[n,nPosServ],'')
		//Aqui deve validar o novo serviГo informado
		If lRet .And. !WmsVldEntr(SDA->DA_DOC,cServico,SDA->DA_PRODUTO,SDA->DA_LOCAL,aCols[n,nPosLocali],SDA->DA_LOTECTL,SDA->DA_NUMLOTE,aCols[n,nPosNumSer],Iif(aCols[n,nPosRecn] > 0,0,aCols[n,nPosQuant]))
			lRet := .F.
		EndIf
		WmsMsgExibe(lWmsMsg)
	EndIf
EndIf
RestArea(aArea)
Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA265QSegumЁ Autor Ё Rodrigo de A. SartorioЁ Data Ё 04/10/99 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Calcula a quantidade na Segunda Unidade de medida          Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A265QSegum()                                               Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA265                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A265QSegum()
Local cVar:=Alltrim(ReadVar())
Local lExecuta := .T.

If Type("l265Auto") == "L" .And. l265Auto .And. Type("lIsEstorno") == "L" .And. lIsEstorno
	lExecuta := .F.
	/*
		NЦo tem necessidade de validar a segunda unidade de medida no estorno do endereГamento.
		Motivo:
		Quantidade da primeira unidade de medida: 300
		B1_TIPCONV = D
		B1_CONV = 19,80198
		Segunda unidade de medida serА: 300 / 19,80198 = 15,1500001515
		Ao arredondar, irА ficar como 15,15.

		No estorno, se for executada a validaГЦo da segunda unidade de medida. Nessa validaГЦo,
		И efetuado o calculo da primeira unidade de medida novamente.
		15.15 * 19,80198 = 299,999997

		A partir desse momento, nЦo irА efetuar o estorno da quantidade total do endereГo.
	*/
EndIf
If lExecuta
	If cVar == "M->DB_QUANT"
		If nPosQtSegum > 0
			aCols[n,nPosQtSegum] := ConvUm(SDA->DA_PRODUTO,&(ReadVar()),aCols[n,nPosQtSegum],2)
		EndIf
	ElseIf cVar == "M->DB_QTSEGUM"
		aCols[n,nPosQuant] := ConvUm(SDA->DA_PRODUTO,aCols[n,nPosQuant],&(ReadVar()),1)
	EndIf
EndIf
Return .T.

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA265EstOK Ё Autor Ё Rodrigo de A. SartorioЁ Data Ё 06/11/97 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Valida a linha da GetDados no estorno                      Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A265EstOk()                                                Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA265                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A265EstOk(o)
Local lRet  := .T.,lRe5:=.F.
Local nSaldo:= 0
Local dDataFec   := MVUlmes()
Local lMvNegatBF :=  SuperGETMV("MV_NEGATBF",.F.,.F.)

If aCols[n,nPosEstorn] == "S"
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Impede o Estorno de Enderecamentos anteriores ao Fechamento  Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If dDataFec >= aCols[n, nPosData]
		Help (' ', 1, 'FECHTO')
		lRet := .F.
	EndIf
	If lRet
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se no SD3 o D3_CF = RE5                             Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		SD3->(dbSetOrder(2))
		SD3->(MsSeek(xFilial("SD3")+SDA->DA_DOC+SDA->DA_PRODUTO))
		While !Eof() .And. xFilial("SD3")+SDA->DA_DOC+SDA->DA_PRODUTO == SD3->D3_FILIAL+SD3->D3_DOC+SD3->D3_COD
			If SD3->D3_CF == "RE5" .And. !Empty(SD3->D3_OP) .And. SDA->DA_NUMSEQ+SDA->DA_LOTECTL == SD3->D3_NUMSEQ+SD3->D3_LOTECTL .And. SD3->D3_ESTORNO # "S"
				// Caso a OP esteja totalmente encerrada nao deve permitir estornar o enderecamento, caso contrario ira verificar saldo SBF
				SC2->(DbSetOrder(1))
				If SC2->(MsSeek(xFilial("SC2")+SD3->D3_OP)) .And.;
					SC2->C2_TPOP == "F" .And. !Empty(SC2->C2_DATRF) .And. SC2->C2_QUJE >= SC2->C2_QUANT // Encerrada totalmente
					Help(" ", 1, "A265OPENC", Nil, STR0048, 1, 0, Nil, Nil, Nil, Nil, Nil, {STR0049})
					lRet := .F.
					Exit
				Else
					lRe5 := .T.
					Exit
				EndIf
			EndIf
			SD3->(dbSkip())
		EndDo
		If !lRe5 .and. !lMvNegatBF .And. lRet
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se qtd distribuida ja foi utilizada                 Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			nSaldo:=SaldoSBF(M->DA_LOCAL,aCols[n,nPosLocali],M->DA_PRODUTO,aCols[n,nPosNumSer],aCols[n,nPosLotCtl],aCols[n,nPosLote])
			If nSaldo < aCols[n,nPosQuant]
				Help(" ",1,"MA265QTEST")
				lRet:=.F.
			EndIf
		EndIf
	EndIf
EndIf
Return lRet

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA265MtColsЁ Autor ЁRodrigo de A. Sartorio Ё Data Ё 28/12/99 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Monta array aCols com Localizacoes e qtdes. sugeridas      Ё╠╠
╠╠Ё          Ё (pode gerar n linhas em br. conf. enderecos sugeridos      Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Sintaxe  ЁA265MtCols(ExpC1,ExpC2,ExpN1,ExpN2,ExpN3,ExpN4,ExpN5,		  Ё╠╠
╠╠Ё          Ё           aExpA1,ExpN6,ExpN7)                              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpC1 - > Produto utilizado                                Ё╠╠
╠╠Ё          Ё ExpC2 - > Almoxarifado utilizado                           Ё╠╠
╠╠Ё          Ё ExpN1 - > Saldo a ser distribuido                          Ё╠╠
╠╠Ё          Ё ExpN2 - > Posicao do item no array aCols                   Ё╠╠
╠╠Ё          Ё ExpN3 - > Posicao da Localizacao no array aCols            Ё╠╠
╠╠Ё          Ё ExpN4 - > Posicao da Qtd. 1a UM no array aCols             Ё╠╠
╠╠Ё          Ё ExpN5 - > Posicao da Qtd. 2a UM no array aCols             Ё╠╠
╠╠Ё          Ё ExpA1 - > Copia do array aCols em branco                   Ё╠╠
╠╠Ё          Ё ExpN6 - > Posicao do alias (ALI_WT) no array aCols         Ё╠╠
╠╠Ё          Ё ExpN7 - > Posicao do recno (REC_WT) no array aCols         Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA265                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
*/
Static Function A265MtCols(cProduto,cLocal,nSaldo,nPosItem,nPosLocali,nPosQuant,nPosQtSegum,aBackCols,nPosAlias,nPosRec)
Local lFirst:=.T.
Local aArray:=MADistrAut(cLocal,cProduto,nSaldo)
Local zi	:=0

For zi:=1 to Len(aArray)
	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Utiliza linha em branco e apos isso Inclui linha no array aCols Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If !lFirst
		AADD(aCols,ACLONE(aBackCols))
		aCols[Len(aCols),nPosItem]:=Soma1(aCols[Len(aCols)-1,nPosItem])
	Else
		lFirst:=.F.
	EndIf
	aCols[Len(aCols),nPosLocali] :=aArray[zi,1]
	aCols[Len(aCols),nPosQuant]	 :=aArray[zi,2]
	aCols[Len(aCols),nPosQtSegum]:=aArray[zi,3]
	// Grava o Alias e Recno (Walk-Thru)
	aCols[Len(aCols),nPosAlias]	 :="SDB"
	aCols[Len(aCols),nPosRec]	 :=0
Next zi
Return

/*/
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбддддддддддд©╠╠
╠╠ЁFun┤└o    ЁA265LegendЁRev.   Ё Edson Maricate        Ё Data Ё29.07.2000 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддаддддддддддд╢╠╠
╠╠Ё          ЁDemonstra a legenda das cores da mbrowse                     Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁNenhum                                                       Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   ЁNenhum                                                       Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁDescri┤└o ЁEsta rotina monta uma dialog com a descricao das cores da    Ё╠╠
╠╠Ё          ЁMbrowse.                                                     Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Materiais                                                   Ё╠╠
╠╠юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
/*/
Function A265Legend()
BrwLegenda(cCadastro,STR0011,{	{"ENABLE" ,STR0012},;	//"Legenda"###"Saldo a Distribuir"
											{"DISABLE",STR0013}})	//"Ja Distribuido"
Return(.T.)


/*/
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбддддддддддд©╠╠
╠╠ЁFun┤└o    ЁA265UltIt ЁRev.   Ё Bruno Sobieski        Ё Data Ё29.07.2000 Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁExpC1: Define se deve retornar como numerico ou como caracterЁ╠╠
╠╠Ё          Ё                                                             Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   ЁUltimo item utilizado no SDB                                 Ё╠╠
╠╠Ё          Ё                                                             Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁDescri┤└o ЁEsta rotina monta Retorna o ultimo item utilizado no SDB     Ё╠╠
╠╠Ё          Ё para o SDA posicionado .                                    Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Materiais                                                   Ё╠╠
╠╠юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A265UltIt(cTipo, lContaDel)
Local cSeek    := xFilial("SDB")+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_NUMSEQ+SDA->DA_DOC+SDA->DA_SERIE+SDA->DA_CLIFOR+SDA->DA_LOJA
Local cLoteSDA := SDA->DA_LOTECTL+SDA->DA_NUMLOTE
Local lRastro  := Rastro(SDA->DA_PRODUTO)
Local aArea	   := GetArea()
Local aAreaSDB := SDB->(GetArea())
Local cCounter := StrZero(0,TamSx3('DB_ITEM')[1])
Local nCounter := 0

DEFAULT cTipo      := 'N'
DEFAULT lContaDel  := .T.

dbSelectArea("SDB")
dbSetOrder(1)
If dbSeek(cSeek)
	Do While !EOF() .And. DB_FILIAL+DB_PRODUTO+DB_LOCAL+DB_NUMSEQ+DB_DOC+DB_SERIE+DB_CLIFOR+DB_LOJA == cSeek
		If DB_TM > "500" .Or. DB_TIPO # "D"
			dbSkip()
			Loop
		EndIf
		If lRastro .And. !(cLoteSDA==DB_LOTECTL+DB_NUMLOTE)
			If !Empty(DB_LOTECTL) .And. !Empty(DB_NUMLOTE)
				dbSkip()
				Loop
			EndIf
		EndIf
		If !(DB_ATUEST $ 'S ') //-- Desconsidera Servicos do WMS
			dbSkip()
			Loop
		EndIf
		If !lContaDel
			If !Empty(DB_ESTORNO) .Or. !(DB_ATUEST $ 'S ')
				dbSkip()
				Loop
			EndIf
		EndIf
		If cTipo == "N"
			nCounter++
		Else
			cCounter := Soma1(cCounter)
		EndIf
		dbSkip()
	EndDo
EndIf

RestArea(aAreaSDB)
RestArea(aArea)
Return (IIf(cTipo == "N",nCounter,cCounter))

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбддддддддддд©╠╠
╠╠ЁFun┤└o    ЁA265DocTMSЁRev.   ЁRodrigo de A. Sartorio Ё Data Ё15.11.2002 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддаддддддддддд╢╠╠
╠╠Ё          ЁVerifica o relacionamento do documento com os arquivos do    Ё╠╠
╠╠Ё          ЁSIGATMS                                                      Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁlEstorno - Indica se esta estornando enderecamento           Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   ЁNenhum                                                       Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Materiais                                                   Ё╠╠
╠╠юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A265DocTMS(lEstorno)
Local aAreaDTC := DTC->(GetArea())
Local cSeekDUD:="",cSeekDTC:=""
Local lOk:=.T.

dbSelectArea("SDA")
dbSetOrder(1)

dbSelectArea("SD1")
dbSetOrder(1)

// Pesquisa o CTRC amarrado a essa NF
dbSelectArea("DTC")
dbSetOrder(2)
If dbSeek(xFilial("DTC")+SDA->DA_DOC+SDA->DA_SERIE+SDA->DA_CLIFOR+SDA->DA_LOJA+SDA->DA_PRODUTO)
	cSeekDUD:=xFilial("DUD")+DTC_FILDOC+DTC_DOC+DTC_SERIE+cFilAnt
	cSeekDTC:=DTC_FILDOC+DTC_DOC+DTC_SERIE
	If lEstorno
		// No estorno do enderecamento marca o DUD com flag de nao enderecado
		dbselectArea("DUD")
		dbSetOrder(1)
		If dbSeek(cSeekDUD) .And. DUD->DUD_ENDERE == "2"
			Reclock("DUD",.F.)
			Replace DUD_ENDERE With "1"
			MsUnlock()
		EndIf
	Else
		// Varre todas as NFS do CTRC verificando se todas estao enderecadas
		// Caso isso ocorra marca o DUD com flag de ja enderecado
		dbSetOrder(3)
		dbSeek(xFilial("DTC")+cSeekDTC)
		While !Eof() .And. lOk .And. DTC_FILIAL+DTC_FILDOC+DTC_DOC+DTC_SERIE == xFilial("DTC")+cSeekDTC
			// Verifica se o produto utiliza controle de enderecamento
			If Localiza(DTC_CODPRO)
				If SD1->(dbSeek(xFilial("SD1")+DTC->DTC_NUMNFC+DTC->DTC_SERNFC+DTC->DTC_CLIREM+DTC->DTC_LOJREM+DTC->DTC_CODPRO))
					If (SDA->(dbSeek(xFilial("SDA")+DTC->DTC_CODPRO+SD1->D1_LOCAL+SD1->D1_NUMSEQ+DTC->DTC_NUMNFC+DTC->DTC_SERNFC+DTC->DTC_CLIREM+DTC->DTC_LOJREM+DTC->DTC_CODPRO)))
						lOk:=lOk .And. (QtdComp(SDA->DA_SALDO) == QtdComp(0))
					EndIf
				EndIf
			EndIf
			dbSelectArea("DTC")
			dbSkip()
		End
		// No enderecamento marca o DUD com flag de enderecado
		If lOk
			dbselectArea("DUD")
			dbSetOrder(1)
			If dbSeek(cSeekDUD)
				Reclock("DUD",.F.)
				Replace DUD_ENDERE With "2"
				MsUnlock()
			EndIf
		EndIf
	EndIf
EndIf
RestArea(aAreaDTC)
RETURN

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё SHOWF4   Ё Autor Ё Rodrigo de A. SartorioЁ Data Ё 29/11/95 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Chamada da funcao F4LOCALIZ                                Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA240                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function ShowF4(a,b,c)
Local cCampo:=AllTrim(Upper(ReadVar()))
Private cLoteCTL   := SDA->DA_LOTECTL
Private cNumLote   := SDA->DA_NUMLOTE
If cCampo == "M->DB_LOCALIZ" .Or. cCampo == "M->DB_NUMSERI"
	F4Localiz(,,, "A265",SDA->DA_PRODUTO,SDA->DA_LOCAL,,ReadVar())
EndIf
Return NIL

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A265ATUSAЁ Autor Ё Marcos V. Ferreira    Ё Data Ё 16/08/05 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Atualiza campos B2_QEMPSA / CQ_QTDISP utilizados na baixa  Ё╠╠
╠╠Ё          Ё da pre-requisicao. Posicionar SDA/SDB                      Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA265                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function A265AtuSA(nTipo)
Local nQtdLib	:= 0
Local nQtdaLib	:= 0
Local nPosSC    := 0
Local nX        := 0
Local aAreaAnt	:= GetArea()
Local aAreaSD1	:= SD1->(GetArea())
Local aAreaSC7	:= SC7->(GetArea())
Local aAreaSCQ	:= SCQ->(GetArea())
Local aAreaSB2	:= SB2->(GetArea())
Local aAreaDHN	:= DHN->(GetArea())
Local aPosDHN	:= {}
Local aNumSC	:= {}
Local aSC       := {}
Local lSDA      := .F.
Local cFilSC	:= ""
Local cNumSC	:= ""
Local cItemSC	:= ""
Local cFilQry   := ""
Local cProduto  := ""
Local cCotacao  := ""
Local cAliasCot := GetNextAlias()

Default nTipo := 0

//зддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё nTipo == 1 - Distribuicao B2_QEMPSA / CQ_QTDISP	Ё
//Ё nTipo == 2 - Estorno B2_QEMPSA / CQ_QTDISP		Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддды
If SDA->DA_ORIGEM == "SD1"
	dbSelectArea("SD1")
	dbSetOrder(5)
	If	dbSeek( xFilial("SD1") + SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_NUMSEQ )
		nQtdaLib := SDB->DB_QUANT
		dbSelectAreA("SC7")
		dbSetOrder(1)
		If dbSeek( xFilial("SC7") + SD1->(D1_PEDIDO+D1_ITEMPC ))
			cFilSC	:= SC7->C7_FILIAL
			cNumSC	:= SC7->C7_NUMSC
			cItemSC	:= SC7->C7_ITEMSC
			cFilQry := SC7->C7_FILIAL
			cProduto:= SC7->C7_PRODUTO
			cCotacao:= SC7->C7_NUMCOT
			lSDA 	:= .T.
			aAdd(aSC,{cFilSC, cNumSC, cItemSC})
		Else	// Opcao para quando e utilizada Compra Centralizada onde a SC e transferida de uma filial para outra
			dbSetOrder(19)
			If dbSeek(xFilial("SD1") + SD1->(D1_COD + D1_PEDIDO + D1_ITEMPC))
				aNumSC	:= GetAdvFVal("SC1",{ "C1_FISCORI", "C1_SCORI", "C1_ITSCORI", "C1_FILIAL" },SC7->(C7_FILIAL+C7_NUMSC+C7_ITEMSC),1)
				cFilSC	:= aNumSC[1]
				cNumSC	:= aNumSC[2]
				cItemSC	:= aNumSC[3]
				cFilQry := aNumSC[4]
				cProduto:= SC7->C7_PRODUTO
				cCotacao:= SC7->C7_NUMCOT
				lSDA := .T.
				aAdd(aSC,{cFilSC, cNumSC, cItemSC})
			EndIf
			dbSetOrder(1)
		EndIf

		// Tratamento para cotacao gerada com mais de um item de SC do mesmo produto
		// onde os itens sao aglutinados gerando somente um item de cotacao/pedido
		If !Empty(cCotacao)

			BeginSql Alias cAliasCot

				SELECT	SC1.C1_FILIAL C1_FILIAL,
						SC1.C1_NUM C1_NUM,
						SC1.C1_ITEM C1_ITEM,
						SC1.C1_FISCORI C1_FISCORI,
						SC1.C1_SCORI C1_SCORI,
						SC1.C1_ITSCORI C1_ITSCORI
					FROM %table:SC1% SC1
					WHERE   SC1.C1_FILIAL  = %Exp:cFilQry%
						AND SC1.C1_PRODUTO = %Exp:cProduto%
						AND SC1.C1_COTACAO = %Exp:cCotacao%
						AND SC1.%NotDel%
			EndSQL

			While (cAliasCot)->(!Eof())
				// Verifica se utilizou Compra Centralizada
				If !Empty((cAliasCot)->C1_FISCORI) .And. !Empty((cAliasCot)->C1_SCORI) .And. !Empty((cAliasCot)->C1_ITSCORI)
					If (nPosSC := aScan(aSC, { |x| x[1] == (cAliasCot)->C1_FISCORI .And. x[2] == (cAliasCot)->C1_SCORI .And. x[3] == (cAliasCot)->C1_ITSCORI})) == 0
						aAdd(aSC,{(cAliasCot)->C1_FISCORI, (cAliasCot)->C1_SCORI, (cAliasCot)->C1_ITSCORI})
					EndIf
				Else
					If (nPosSC := aScan(aSC, { |x| x[1] == (cAliasCot)->C1_FILIAL .And. x[2] == (cAliasCot)->C1_NUM .And. x[3] == (cAliasCot)->C1_ITEM})) == 0
						aAdd(aSC,{(cAliasCot)->C1_FILIAL, (cAliasCot)->C1_NUM, (cAliasCot)->C1_ITEM})
					EndIf
				EndIf
				(cAliasCot)->(DbSkip())
			End

			(cAliasCot)->(DbCloseArea())

		EndIf

		If lSDA
			For nX := 1 To Len(aSC)
				If !Empty(aSC[nX][2]) .And. !Empty(aSC[nX][3])
					aPosDHN := COMPosDHN({3,{'1', aSC[nX][1], aSC[nX][2], aSC[nX][3]}})
					If aPosDHN[1]
						While !(aPosDHN[2])->(Eof()) .And. ( (aPosDHN[2])->(DHN_FILDES + DHN_DOCDES + DHN_ITDES) == aSC[nX][1] + aSC[nX][2] + aSC[nX][3] ) .And. nQtdaLib > 0
							SCQ->(DbSetOrder(1))
							If SCQ->(DbSeek(xFilial("SCQ") + (aPosDHN[2])->DHN_DOCORI + AllTrim( (aPosDHN[2])->DHN_ITORI )))
								While !(SCQ->(Eof())) .And. AllTrim(SCQ->(CQ_FILIAL + CQ_NUM + CQ_ITEM)) == AllTrim((aPosDHN[2])->(DHN_FILORI + DHN_DOCORI + DHN_ITORI))
									If Empty(SCQ->CQ_NUMREQ)
										RecLock("SCQ",.F.)
										If nTipo == 1
											nQtdLib := Min(SCQ->CQ_QUANT-SCQ->CQ_QTDISP,nQtdALib)
										ElseIf nTipo == 2
											nQtdLib := Min(SCQ->CQ_QTDISP,nQtdALib)
										EndIf
										nQtdALib-= nQtdLib
										If nTipo == 1
											SCQ->CQ_QTDISP += nQtdLib
										ElseIf nTipo == 2
											SCQ->CQ_QTDISP -= nQtdLib
										EndIf
										SCQ->CQ_STATUSC:= ""
										dbSelectArea("SB2")
										dbSetOrder(1)
										MsSeek(xFilial("SB2")+SCQ->CQ_PRODUTO+SCQ->CQ_LOCAL)
										Reclock("SB2",.F.)
										If nTipo == 1
											SB2->B2_QEMPSA += nQtdLib
										ElseIf nTipo == 2
											SB2->B2_QEMPSA -= nQtdLib
										EndIf
										MsUnlock()
									EndIf
									SCQ->(DbSkip())
									//dbSelectArea("SCQ")
									//dbSkip()
								EndDo
							EndIf
							(aPosDHN[2])->(dbSkip())
						EndDo
						(aPosDhn[2])->(DbCloseArea())
					EndIf
				EndIf
			Next nX
		EndIf
		aSC := aSize(aSC,0)
	EndIf
EndIf
RestArea(aAreaSD1)
RestArea(aAreaSC7)
RestArea(aAreaSCQ)
RestArea(aAreaSB2)
RestArea(aAreaAnt)
RestArea(aAreaDHN)
Return

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁPrograma  ЁMenuDef   Ё Autor Ё Fabio Alves Silva     Ё Data Ё04/10/2006Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Utilizacao de menu Funcional                               Ё╠╠
╠╠Ё          Ё                                                            Ё╠╠
╠╠Ё          Ё                                                            Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   ЁArray com opcoes da rotina.                                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁParametros do array a Rotina:                               Ё╠╠
╠╠Ё          Ё1. Nome a aparecer no cabecalho                             Ё╠╠
╠╠Ё          Ё2. Nome da Rotina associada                                 Ё╠╠
╠╠Ё          Ё3. Reservado                                                Ё╠╠
╠╠Ё          Ё4. Tipo de Transa┤└o a ser efetuada:                        Ё╠╠
╠╠Ё          Ё    1 - Pesquisa e Posiciona em um Banco de Dados           Ё╠╠
╠╠Ё          Ё    2 - Simplesmente Mostra os Campos                       Ё╠╠
╠╠Ё          Ё    3 - Inclui registros no Bancos de Dados                 Ё╠╠
╠╠Ё          Ё    4 - Altera o registro corrente                          Ё╠╠
╠╠Ё          Ё    5 - Remove o registro corrente do Banco de Dados        Ё╠╠
╠╠Ё          Ё5. Nivel de acesso                                          Ё╠╠
╠╠Ё          Ё6. Habilita Menu Funcional                                  Ё╠╠
╠╠цддддддддддедддддддддддддддбдддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё   DATA   Ё Programador   ЁManutencao efetuada                         Ё╠╠
╠╠цддддддддддедддддддддддддддедддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё          Ё               Ё                                            Ё╠╠
╠╠юддддддддддадддддддддддддддадддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
/*/
Static Function MenuDef()

Private aRotina	:={	{STR0001,"AxPesqui"  , 0 , 1,0,.F.},;	//"Pesquisar"
								{STR0002,"A265Visual", 0 , 2,0,nil},;	//"Visualizar"
								{STR0003,"A265Inclui", 0 , 4,0,nil},;	//"EnDerecar"
								{STR0004,"A265Exclui", 0 , 6,0,nil},;	//"Estornar"
								{STR0011,"A265Legend", 0 , 1,0,.F.} }	//"Legenda"

If	ExistBlock ("MTA265MNU")
	ExecBlock ("MTA265MNU",.F.,.F.)
EndIf

Return (aRotina)

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA265ETDOk Ё Autor Ё Moises Nunes                      Ё Data Ё 04/01/11 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Valida a execucao do estorno, retornando para a tela de dados          Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A265ETDOk()                                                            Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA265                                                                Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A265ETDOk()
//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё M265ESTOK - PE para validar a execucao do estorno, retornando para a tela de dados  Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
Local lRet := .T.
If (ExistBlock("M265ESTOK"))
	lRet:=ExecBlock("M265ESTOK",.F.,.F.)
	If ValType(lRet)<>"L"
		lRet:=.T.
	EndIf
EndIf
Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA265DelЁ Autor Ё  Nilton MK 				  Data Ё 01/06/12 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Valida a pemissЦo de uso da tecla del					  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A265DEL()                                                  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA265                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/

Function A265DEL()
Local lRet	:=.F.
Local nPosRecn := aScan(aHeader, { |x| Alltrim(x[2]) == 'DB_REC_WT' })
Local nPosFoc  := oGetd:obrowse:nAt
Static nCnt    := 0

nCnt++
If  nPosFoc > 0 .and. nPosRecn > 0 .and. (nCnt%2>0)   // proteГЦo para executar apenas uma unica vez , efeito da msgetdados
	if acols[nPosFoc][nPosRecn] > 0
       AVISO('ATENCAO!',STR0042,{"OK"})
	   lRet:=.F.
	Else
	   lRet:=.T.
	EndIf
EndIf
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A265GerNS(aHead,nQtdOri,nSaldo)
GeraГЦo de NЗmero de SИrie
@author guilherme.pimentel

@param aHead - CabeГalho da tabela
@param nQtdOri - Quantidade Original
@param nSaldo - Saldo
@return lRet

@since 09/01/2014
@version 1.0
/*/
//-------------------------------------------------------------------

Function A265GerNS(aHeadSDB,nQtdOri,nSaldo,xColsSDB,oGetSD1)
Local nX := 0
Local nY := 0
Local nQtde := 0
Local nLinha := 0
Local cProduto := SDA->DA_PRODUTO
Local lRet := .T.
Local aFormula := {}

If Valtype(xColsSDB) == "O"
	aColsSDB := xColsSDB:aCols
	nLinha := xColsSDB:nAt
	cProduto := oGetSD1:aCols[oGetSD1:nAt][GDFieldPos("D1_COD",oGetSD1:aHeader)]
ElseIf Valtype(xColsSDB) == "A"
	aColsSDB := xColsSDB
Else
	aColsSDB := aCols
EndIf

//Define Indice para uso na obtenГЦo do nЗmero de sИrie
dbSelectArea("SBF")
dbSetOrder(4)

aFormula := A265SetNS(A265GetFor(cProduto),aHeadSDB,aColsSDB)

If !Empty(aFormula[1])
	//Colocado caso haja a inserГЦo de algum registro manualmente antes de executar a distribuiГЦo automatica
	For nX := 1 to Len(aColsSDB)
		If !aColsSDB[nX,Len(aHeadSDB)+1] .and. IIF(GDFieldPos("DB_ESTORNO",aHeadSDB)>0,aColsSDB[nX,GDFieldPos("DB_ESTORNO",aHeadSDB)]<>'S',.F.)
			nQtde += aColsSDB[nX,GDFieldPos("DB_QUANT",aHeadSDB)]
		EndIf
	Next nX

	nSaldo := nQtdOri - nQtde

	//Coloca o valor na linha inicial caso esteja vazia
	If aColsSDB[Len(aColsSDB),GDFieldPos("DB_QUANT",aHeadSDB)] == 0 .And. Empty(aColsSDB[Len(aColsSDB),GDFieldPos("DB_NUMSERI",aHeadSDB)])

		aColsSDB[Len(aColsSDB),GDFieldPos("DB_QUANT",aHeadSDB)] := 1
		aColsSDB[Len(aColsSDB),GDFieldPos("DB_NUMSERI",aHeadSDB)] := aFormula[1]//cFormula
		aColsSDB[Len(aColsSDB),GDFieldPos("DB_LOCALIZ",aHeadSDB)] := aFormula[2]
		nSaldo := nSaldo - 1
		aFormula := A265SetNS(aFormula,aHeadSDB,aColsSDB)
	EndIf

	For nX := (Len(aColsSDB)+1) to (nSaldo + Len(aColsSDB))
		AAdd(aColsSDB,Array(Len(aHeadSDB) + 1))

		For nY := 1 to Len(aHeadSDB)
			If IsHeadAlias(aHeadSDB[nY][2])
				aColsSDB[nX,nY] := 'SDB'
			ElseIf IsHeadRec(aHeadSDB[nY][2])
				aColsSDB[nX,nY] := 0
			Else
				aColsSDB[nX,nY] := CriaVar(aHeadSDB[nY, 2],.F.)
			EndIf
		Next nY

		aColsSDB[nX,1] := StrZero(Len(aColsSDB),Len(aColsSDB[Len(aColsSDB),1]))
		aColsSDB[nX,GDFieldPos("DB_QUANT",aHeadSDB)] := 1
		If GDFieldPos("DB_DATA",aHeadSDB) > 0
			aColsSDB[nX,GDFieldPos("DB_DATA",aHeadSDB)] := dDataBase
		EndIf
		aColsSDB[nX,GDFieldPos("DB_NUMSERI",aHeadSDB)] := aFormula[1]//cFormula
		aColsSDB[nX,GDFieldPos("DB_LOCALIZ",aHeadSDB)] := aFormula[2]
		aColsSDB[nX,(Len(aHeadSDB) + 1)] := .F.

		aFormula := A265SetNS(aFormula,aHeadSDB,aColsSDB)

		If Valtype(xColsSDB) == "O"
			xColsSDB:nAt := nX
			A103CHANGE(oGetSD1, xColsSDB, 'SDB')
		EndIf

	Next nX

	If Valtype(xColsSDB) == "O"
		xColsSDB:nAt := nLinha
	Else
		aCols := aColsSDB
	EndIf
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A265GetFor()
ObtenГЦo da fСrmula a ser utilizada
@author guilherme.pimentel

@since 09/01/2014
@version 1.0
@return cValor
/*/
//-------------------------------------------------------------------

Function A265GetFor(cProduto)
Local oDlg		:= Nil
Local oFont1	:= Nil
Local oSize
Local cValor := ''
Local cEnd := Replicate(" ", (TamSx3('BE_LOCALIZ')[1]))
Local cLocal := SDA->DA_LOCAL
Local aValor
Local cTitulo

dbSelectArea("SX3")
dbSetOrder(2)
If dbSeek( "BF_LOCALIZ" )
	cTitulo := X3Titulo()
EndIf

If SB5->(DbSeek(xFilial('SB5')+cProduto))

	cValor := Formula(SB5->B5_FORSER)
	If Empty(cValor)
		cValor := Replicate(" ", (TamSx3('BF_NUMSERI')[1]))
	EndIf
Else
	cValor := Replicate(" ", (TamSx3('BF_NUMSERI')[1]))
EndIF

//Monta Dialog                                                 Ё
DEFINE Font oFont1 Name "Consolas" Size 07,17
DEFINE MSDIALOG oDlg Title STR0043 From 0,0 To 165,305 Of oDlg Pixel

// Calcula dimensУes                                            Ё
oSize := FwDefSize():New(.T.,,,oDlg)

oSize:AddObject( "CABECALHO",  100, 80, .T., .T. ) // Totalmente dimensionavel
oSize:AddObject( "GETDADOS" ,  100, 20, .T., .T. ) // Totalmente dimensionavel

oSize:lProp 	:= .T. // Proporcional
oSize:aMargins 	:= { 3, 3, 3, 3 } // Espaco ao lado dos objetos 0, entre eles 3

oSize:Process() 	   // Dispara os calculos

@ oSize:GetDimension("CABECALHO","LININI")	,oSize:GetDimension("CABECALHO","COLINI")  SAY cTitulo OF oDlg PIXEL SIZE 30,7
@ oSize:GetDimension("CABECALHO","LININI")+8	,oSize:GetDimension("CABECALHO","COLINI")  MSGet oEnd Var cEnd Picture PesqPict("SBE","BE_LOCALIZ") F3 "SBE" Of oDlg PIXEL SIZE 50,8 Valid ExistCpo("SBE",cLocal+cEnd)

@ oSize:GetDimension("CABECALHO","LININI")+23	,oSize:GetDimension("CABECALHO","COLINI")  SAY STR0044 OF oDlg PIXEL SIZE 40,50
@ oSize:GetDimension("CABECALHO","LININI")+31	,oSize:GetDimension("CABECALHO","COLINI")  MSGet oCanal Var cValor Font oFont1 Size 149 ,10 Valid !Empty(Trim(cValor)) Of oDlg PIXEL SIZE 50,50

ACTIVATE MSDIALOG oDlg CENTER ON INIT EnchoiceBar(oDlg,{||  oDlg:End() },{|| cValor := '',cEnd := '', oDlg:End()})

aValor := {cValor,cEnd}

Return aValor

//-------------------------------------------------------------------
/*/{Protheus.doc} A265SetNS(cValor,aHeadSDB)
ObtenГЦo do prСximo nЗmero de sИrie vАlido
@author guilherme.pimentel

@param cValor - Valor Base
@param aHeadSDB - CabeГalho da tabela
@return cValor

@since 09/01/2014
@version 1.0
/*/
//-------------------------------------------------------------------

Function A265SetNS(aValor,aHeadSDB,aColsSDB)
Local cValor
Local nX
Local cNoCar := '1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ'
Local nLastCar := 0
Local cValor1

If !Empty(aValor[1])
	cValor := PadR(AllTrim(aValor[1]),TamSX3( 'BF_NUMSERI' )[1],' ')
	For nX := 1 to len(alltrim(aValor[1]))
		If !Substr(alltrim(aValor[1]),nX,1) $ cNoCar
			nLastCar:= nX
	    EndIf
	Next nx
	If nLastCar > 0
		cValor1 := substr(cValor,nLastCar+1,len(cValor))
	Else
		cValor1 := cValor
	EndiF

	While SBF->(DbSeek(xFilial('SBF')+SDA->DA_PRODUTO+cValor)) .Or. (ASCAN(aColsSDB,{|x| x[GDFieldPos("DB_NUMSERI",aHeadSDB)] == cValor .And. IIF(GDFieldPos("DB_ESTORNO",aHeadSDB)>0,Empty(x[GDFieldPos("DB_ESTORNO")]),.T.)  }) > 0)
		If nLastcar > 0
			cValor := PAdR(Substr(cValor,1,nLastCar)+Soma1(alltrim(cValor1)),TamSX3( 'BF_NUMSERI' )[1],' ')
		Else
			cValor := PadR(Soma1(AllTrim(cValor)),TamSX3( 'BF_NUMSERI' )[1],' ')
		EndIf
	End
	aValor[1]:= cValor
EndIf
Return aValor

//-------------------------------------------------------------------
/*/{Protheus.doc} A265NegEnd()
Rotina que tem por conceito verificar se existe algum endereГo negativo
para o produto informado, se tiver deverА fazer uma pergunta se o usuАrio
gostaria de utilizar o endereГo negativo , caso seja sim deverА trazer o
acols preenchido.

*** SOMENTE PARA FRONT LOJA ***

@author Bruno.Schmidt
@since  16/08/2016
@version 1.0
@return NIL
/*/
//-------------------------------------------------------------------
Function A265NegEnd(cProduto,clocal,nSaldo,nPosLocali,nPosQuant,nPosItem,nPosAlias,nPosRec,aBackCols)
Local cQuery			:=	""
Local nSaldoAux		:=	0
Local lMvSugEndNeg	:=	SuperGETMV("MV_SUGENDN",.F.,.T.)
Local lExec			:= .F.
#IFDEF TOP
	//-- Avalia se existe registro com o Quantidade negativa
	cQuery := "SELECT BF_LOCALIZ,BF_QUANT "
	cQuery += " FROM " +RetSqlName("SBF") +" SBF "
	cQuery += " WHERE SBF.BF_FILIAL = '" + xFilial("SBF")+ "'"
	cQuery += " AND SBF.BF_PRODUTO = '" + cProduto + "' AND SBF.D_E_L_E_T_=' ' "
	cQuery += " AND SBF.BF_LOCAL = '" + clocal + "'"
	cQuery += " AND SBF.BF_QUANT <  0 "
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"QRYSBF",.T.,.T.)

	If !QRYSBF->(Eof())
		If lMvSugEndNeg
			If MsgYesNo(STR0046,STR0047)
				lExec := .T.
			Endif
		Else
			lExec := .T.
		EndIf

		If lExec
			While !QRYSBF->(Eof()) .and. nSaldo > nSaldoAux
				If nSaldoAux > 0
					AADD(aCols,ACLONE(aBackCols))
					aCols[Len(aCols),nPosItem]	:= Soma1(aCols[Len(aCols)-1,nPosItem])
					aCols[Len(aCols),nPosAlias]	:= "SDB"
					aCols[Len(aCols),nPosRec]	:= 0
					aCols[Len(aCols),nPosLocali]:= QRYSBF->BF_LOCALIZ
					aCols[Len(aCols),nPosQuant]	:= IIF(nSaldo - nSaldoAux  > (QRYSBF->BF_QUANT * -1),QRYSBF->BF_QUANT * -1,nSaldo - nSaldoAux)
				Else
					aCols[Len(aCols),nPosLocali]:= QRYSBF->BF_LOCALIZ
					aCols[Len(aCols),nPosQuant]	:= IIF(nSaldo > (QRYSBF->BF_QUANT * -1),QRYSBF->BF_QUANT * -1,nSaldo)
				EndIf
				nSaldoAux := aCols[Len(aCols),nPosQuant]
				QRYSBF->(DbSkip())
			End
		EndIf
	EndIf

	QRYSBF->(DbCloseArea())
#ELSE

	While SBF->(!Eof()) .And. SBF->SBF_FILIAL == xFilial('SBF') .And. SBF->BF_PRODUTO == cProduto .and. SBF->BF_LOCAL == cLocal .and.  SBF->BF_QUANT <  0 .and. nSaldo > nSaldoAux
		If MsgYesNo(STR0046,STR0047)
			If nSaldoAux > 0
				AADD(aCols,ACLONE(aBackCols))
				aCols[Len(aCols),nPosItem]:=Soma1(aCols[Len(aCols)-1,nPosItem])
				aCols[Len(aCols),nPosAlias]	:= "SDB"
				aCols[Len(aCols),nPosRec]	:= 0
				aCols[Len(aCols),nPosLocali]:= SBF->BF_LOCALIZ
				aCols[Len(aCols),nPosQuant]	:= IIF(nSaldo - nSaldoAux  > (SBF->BF_QUANT * -1),SBF->BF_QUANT * -1,nSaldo - nSaldoAux)
			Else
				aCols[Len(aCols),nPosLocali]:= QRYSBF->BF_LOCALIZ
				aCols[Len(aCols),nPosQuant]	:= IIF(nSaldo > (SBF->BF_QUANT * -1),SBF->BF_QUANT * -1,nSaldo)
			EndIf
			nSaldoAux := aCols[Len(aCols),nPosQuant]
			SBF->(DbSkip())
		Endif
	DbSkip()
	End
#ENDIF

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} isApontMES()
Verifica se o registro posicionado da tabela SDA, И um movimento gerado
por um apontamento de produГЦo, realizado pela integraГЦo Totvs MES.

@author Lucas.franca
@since  18/12/2017
@version 1.0
@return lRet -> .T. = Movimento gerado pelo Totvs MES. .F. = NЦo foi gerado pelo Totvs MES.
/*/
//-------------------------------------------------------------------
Static Function isApontMES()
	Local aArea     := GetArea()
	Local lRet      := .F.
	Local cQuery    := ""
	Local cAliasMES := ""

	If AllTrim(SDA->DA_ORIGEM) == "SD3"
		cQuery := " SELECT COUNT(*) TOTAL "
		cQuery +=   " FROM " + RetSqlName("SD3") + " SD3 "
		cQuery +=  " WHERE SD3.D3_FILIAL  = '" + xFilial("SD3") + "' "
		cQuery +=    " AND SD3.D_E_L_E_T_ = ' ' "
		cQuery +=    " AND SD3.D3_NUMSEQ  = '" + SDA->DA_NUMSEQ + "' "
		cQuery +=    " AND SD3.D3_COD     = '" + SDA->DA_PRODUTO + "' "
		cQuery +=    " AND SD3.D3_ESTORNO <> 'S'"
		cQuery +=    " AND SD3.D3_OBSERVA = 'TOTVSMES'"

		cQuery := ChangeQuery(cQuery)
		cAliasMES := GetNextAlias()
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasMES,.T.,.T.)
		If (cAliasMES)->(TOTAL) > 0
			lRet := .T.
		EndIf
		(cAliasMES)->(dbCloseArea())
	EndIf
	RestArea(aArea)
Return lRet

/*/{Protheus.doc} LocMovOri
	Verifica se o movimento de origem (SD1/SD3) foi excluido por outro usuario.
	O registro na SDA deve sempre estar posicionado
	@type  Function
	@author reynaldo
	@since 21/09/2020
	@version 1.0
	@param nenhum
	@return lRet, logico, Verdadeiro se nЦo teve inconsistencia com o movimento origem
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function LocMovOri()
Local lRet
Local aAreaAnt
Local aAreaSD1
Local aAreaSDB
Local cSeek
Local lExist
Local lProcess

	lRet := .T.     // Somente falso se houve origem na SD1 e SD3 e nЦo encontrou.
	lProcess := .F. // se a origem foi da SD1 ou SD3
	lExist := .F.   // se encontrou a origem

	If SDA->DA_ORIGEM == 'SD1'
		lProcess := .T.
		aAreaAnt := GetArea()
		aAreaSD1 := SD1->(GetArea())
		dbSelectArea("SD1")
		dbSetOrder(5)
		If dbSeek(xFilial("SD1")+SDA->DA_PRODUTO+SDA->DA_LOCAL+SDA->DA_NUMSEQ)
			lExist := .T.
		EndIf
		RestArea(aAreaSD1)
		RestArea(aAreaAnt)

	ElseIf SDA->DA_ORIGEM == 'SD3'
		lProcess := .T.

		aAreaAnt := GetArea()
		aAreaSD3 := SD3->(GetArea())
		dbSelectArea("SD3")
		dbSetOrder(8)
		cSeek := xFilial('SD3')+SDA->DA_DOC+SDA->DA_NUMSEQ
		If SD3->(dbSeek(cSeek))
			While SD3->(!Eof() .And. D3_FILIAL+D3_DOC+D3_NUMSEQ == cSeek )
				If SD3->D3_COD == SDA->DA_PRODUTO
					If (SD3->D3_ESTORNO # 'S') .Or. (SD3->D3_ESTORNO == 'S' .And. SD3->D3_TM == '499')
						lExist := .T.
						Exit
					EndIf
				EndIf
				SD3->(dbSkip())
			EndDo
		// O registro na SD3 pode ter sido excluido na rotina MATA330,
		// jА que sЦo estornos re-distribuidos
		Else
			aAreaSDB := SDB->(GetArea())
			dbSelectArea("SDB")
			dbSetOrder(1)

			// Se existir uma distribuiГЦo anterior proveniente de SD3 ou SC2, foi um redistribuicao de estorno
			cSeek := xFilial('SDB')+SDA->(DA_PRODUTO+DA_LOCAL+DA_NUMSEQ+DA_DOC)
			If SDB->(dbSeek(cSeek))
				While SDB->(!Eof() .And. DB_FILIAL+DB_PRODUTO+DB_LOCAL+DB_NUMSEQ+DB_DOC == cSeek )
					If (SDB->DB_ORIGEM == SDA->DA_ORIGEM .OR. SDB->DB_ORIGEM == "SC2")
						lExist := .T.
						Exit
					EndIf
					SDB->(dbSkip())
				EndDo
			EndIf
			RestArea(aAreaSDB)
		EndIf
		RestArea(aAreaSD3)

		RestArea(aAreaAnt)

		If lProcess
			If ! lExist
				Help(" ",1,"A265NOMOV")
				lRet := .F.
			EndIf
		EndIf
	EndIf

Return lRet
