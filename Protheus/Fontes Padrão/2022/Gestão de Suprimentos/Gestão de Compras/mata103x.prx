#INCLUDE "MATA103X.CH" 
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "FWADAPTEREAI.CH" 
#Include "FWLIBVERSION.CH"
#DEFINE VALMERC  01	// Valor total do mercadoria
#DEFINE VALDESC  02	// Valor total do desconto
#DEFINE TOTPED	 03	// Total do Pedido
#DEFINE FRETE    04	// Valor total do Frete
#DEFINE VALDESP  05	// Valor total da despesa
#DEFINE TOTF1	 06	// Total de Despesas Folder 1               
#DEFINE SEGURO	 07	// Valor total do seguro
#DEFINE TOTF3	 08	// Total utilizado no Folder 3	
#DEFINE VNAGREG	 09	// Valor total nao agregado ao total do documento
#DEFINE VALEMB   10 // Valor total da embalagem
#DEFINE _CRLF	Chr(13) + Chr(10)     

Static lIndCteCol
Static lLGPD  		:= FindFunction("SuprLGPD") .And. SuprLGPD()
Static __lVLib      := FWLibVersion() >= "20211116"

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³ MATA103X ³ Autor ³ Eduardo Riera         ³ Data ³ 17.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Funcoes de validacao e controle de interface do documento de ³±±
±±³          ³ de entrada                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeCabDoc ³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de tratamento do cabecalho do documento de entrada    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpO1: Objeto da Janela que sera disponibilizado os Get      ³±±
±±³          ³ExpA2: Array com as posicoes dos gets do documento de entrada³±±
±±³          ³Expb3: Codeblock para atualizacao dos dados do documento     ³±±
±±³          ³ExpL4: Informa se o cabecalho pode ser alterado              ³±±
±±³          ³ExpL5: Indica se eh uma uma pre-nota                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo exibir/controlar o folder finan³±±
±±³          ³ceiro.                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
 
Function NfeCabDoc(oDlg,aPosGet,bRefresh,lVisual,lFiscal,cUfOrig,lClassif,lPreNota,nCombo,oCombo,cCodRet,oCodRet,lNfMedic,aCodR,cRecIss,cNatureza,l140Altera,aNFEletr,aNfeDanfe,aInfAdic)
Local aObjetos   := Array(12)
Local lTpCompl   := SF1->(ColumnPos("F1_TPCOMPL")) > 0 .And. Type("cTpCompl") == "C"
Local lSubSerie  := cPaisLoc == "BRA" .And. SF1->(ColumnPos("F1_SUBSERI")) > 0 .And. SuperGetMv("MV_SUBSERI",.F.,.F.)
Local aCombo1    := {STR0001,;	//"Normal"
						STR0002,;	//"Devolucao"
						STR0003,;	//"Beneficiamento"
						STR0004,;	//"Compl.  ICMS"
						STR0005,;	//"Compl.  IPI"
						If(lTpCompl,STR0159,STR0006)} 	//"Compl. Preco/Frete"
						
Local aCombo2    := {STR0007,STR0008} //"Nao"###"Sim"
Local aCombo3    := {"",STR0160,STR0161,STR0162}
Local aCombo2Lan := {STR0007,STR0008,STR0008} // Nao retirar, abrange language=English
Local aAuxCombo1 := {"N","D","B","I","P","C"}
Local aAuxCombo2 := {"N","S","Y"}
Local aAuxCombo3 := {"","1","2","3"}

Local c103SayForn:= IIf(cTipo$"DB",RetTitle("F2_CLIENTE"),RetTitle("F1_FORNECE"))
Local c103Tipo	 := ""
Local c103TpComp := ""
Local c103Form	 := cFormul
Local cCar       := CHR(34)+CHR(39)        // Caracteres que não serão permitidos na digitação do campo: Nota e Série
Local nAux       := aScan(aAuxCombo1,cTipo)
Local lGspInUseM := If(Type('lGspInUse')=='L', lGspInUse, .F.)
Local nTamGetFor := 45          
Local nScreen    := GetScreenRes()[1]
Local nEspLoja   := 0 
Local nAltNFE    := 0

Local lUfOrig    := ( ValType( cUfOrig ) == "C" )
Local lMt103CPS  := Existblock("MT103CPS")
Local oNfMedic   := .F. 
Local lUsaNewKey := TamSX3("F1_SERIE")[1] == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso

Local lIntGfe := SuperGetMV("MV_INTGFE",.F.,.F.)
Local oUfOrig := NIL

lClassif:= If( ValType( lClassif ) == "L" , lClassif, .F.) 

cFormul := If( ValType( cFormul ) <> "C" .Or. Empty(cFormul) , "N", cFormul ) 

DEFAULT lPreNota 	:= .F.
DEFAULT l140Altera	:= .F.
Default aCodR	 	:= {}
Default cRecIss	 	:= "1"
Default cNatureza	:= ""
Default aNFEletr    := {}
Default aNfeDanfe   := {}
Default aInfAdic    := {}

If lPreNota
	nEspLoja   := Iif(nScreen<1280 .And. !lVisual, 5,-3)
Else
	nEspLoja   := Iif(nScreen<1280 .And. !lVisual, 5,1)
EndIF					
nAltNFE    := Iif(lPreNota .And. ALTERA  ,15 ,0)   

aCombo1    := IIF(lPreNota,{STR0001,STR0002,STR0003,If(lTpCompl,STR0159,STR0006)},{STR0001,STR0002,STR0003,STR0004,STR0005,If(lTpCompl,"Complemento",STR0006)}) //STR0001>"Normal" STR0002>"Devolucao" STR0003>"Beneficiamento" STR0004>"Compl.  ICMS" STR0005>"Compl.  IPI" STR0006>"Compl. Preco/Frete"
aAuxCombo1 := IIF(lPreNota,{"N","D","B","C"},{"N","D","B","I","P","C"})
nAux       := aScan(aAuxCombo1,cTipo)

If !Empty(cTipo) .And. nAux <> 0
	c103Tipo := aCombo1[nAux]
EndIf
nAux := aScan(aAuxCombo2,cFormul)
If !Empty(cFormul) .And. nAux <> 0
	c103Form := aCombo2Lan[nAux]
EndIf

If lTpCompl
	nAux := aScan(aAuxCombo3,cTpCompl)
	If !Empty(cTpCompl) .And. nAux <> 0
		c103TpComp := aCombo3[nAux]
	EndIf
EndIf

If !lNfMedic
	If TamSX3("A2_COD")[1]< 9 
		nTamGetFor:=(6*TamSX3("A2_COD")[1])
	ElseIf TamSX3("A2_COD")[1]< 15
		nTamGetFor:=(4.8*TamSX3("A2_COD")[1])
	Else
		nTamGetFor:=(4*TamSX3("A2_COD")[1])
	EndIf
EndIf
@ aPosGet[3,1],aPosGet[3,2] TO aPosGet[3,3],aPosGet[3,4] LABEL "" OF oDlg PIXEL

@ aPosGet[3,1]+(2,6),aPosGet[1,1] SAY RetTitle("F1_TIPO") OF oDlg PIXEL SIZE 35,09 
@ aPosGet[3,1]+(2,5),aPosGet[1,2] MSCOMBOBOX aObjetos[1] VAR c103Tipo ITEMS aCombo1 SIZE 60,100;
	WHEN !lVisual .And. !IsInCallStack("MATA116") .And. !IsInCallStack("MATA119") .And. A103ChWhen("F1_TIPO",c103Tipo,lClassif) ;
	VALID NfeCombo(@cTipo,aCombo1,c103Tipo,aAuxCombo1,"1").And.NfeTipo(cTipo,@cA100For,@cLoja,aObjetos[6],aObjetos[7],aObjetos[8],oDlg,cTpCompl);
	OF oDlg PIXEL

If lTpCompl
	aObjetos[1]:bChange := {||A103TpComp(@aObjetos,c103Tipo,@c103TpComp)}
	
	@ aPosGet[3,1]+(2,6),aPosGet[1,3] SAY RetTitle("F1_TPCOMPL") Of oDlg PIXEL SIZE 52,09
	@ aPosGet[3,1]+(2,5),aPosGet[1,4] MSCOMBOBOX aObjetos[11] VAR c103TpComp ITEMS aCombo3 SIZE 50,100 ;
		WHEN !lVisual .And. !IsInCallStack("MATA116") .And. !IsInCallStack("MATA119") .And. c103Tipo == "Complemento";
		VALID NfeCombo(@cTpCompl,aCombo3,c103TpComp,aAuxCombo3,"3") .And. NfeTipo(cTipo,@cA100For,@cLoja,aObjetos[6],aObjetos[7],aObjetos[8],,cTpCompl);
		OF oDlg PIXEL

	If !lGspInUseM
		@ aPosGet[3,1]+(2,6),aPosGet[1,5] SAY RetTitle("F1_FORMUL") Of oDlg PIXEL SIZE 52,09
		@ aPosGet[3,1]+(2,5),aPosGet[1,6] MSCOMBOBOX aObjetos[2] VAR c103Form ITEMS aCombo2 SIZE 30,50 ;
			WHEN !lVisual .And. A103ChWhen("F1_FORMUL",c103Form,lClassif) ;
			VALID NfeCombo(@cFormul,aCombo2Lan,c103Form,aAuxCombo2,"2").And.NfeFormul(cFormul,@cNFiscal,@cSerie,aObjetos[3],@aObjetos[4]) ;
			OF oDlg PIXEL                            
	EndIf
ElseIf !lGspInUseM
	@ aPosGet[3,1]+(2,6),aPosGet[1,3] SAY RetTitle("F1_FORMUL") Of oDlg PIXEL SIZE 52,09
	@ aPosGet[3,1]+(2,5),aPosGet[1,4] MSCOMBOBOX aObjetos[2] VAR c103Form ITEMS aCombo2 SIZE 30,50 ;
		WHEN !lVisual .And. A103ChWhen("F1_FORMUL",c103Form,lClassif) ;
		VALID NfeCombo(@cFormul,aCombo2Lan,c103Form,aAuxCombo2,"2").And.NfeFormul(cFormul,@cNFiscal,@cSerie,aObjetos[3],@aObjetos[4]) ;
		OF oDlg PIXEL                            
Endif

@ aPosGet[3,1]+(2,6),aPosGet[1,7] SAY RetTitle("F1_DOC") Of oDlg PIXEL SIZE 45,09
@ aPosGet[3,1]+(2,5),aPosGet[1,8] MSGET aObjetos[3] VAR cNFiscal PICTURE PesqPict("SF1","F1_DOC") ;
	WHEN !lVisual.And.VisualSX3("F1_DOC") .And.cFormul<>"S" .And. A103ChWhen("F1_DOC",cNFiscal,lClassif) ;
	VALID NfeFornece(cTipo,@cA100For,@cLoja,,@nCombo,@oCombo,@cCodRet,@oCodRet,@aCodR,@cRecIss,@cNatureza,aObjetos[3]).And.CheckSX3("F1_DOC") .And. !A103VldCpo(cNfiscal,cCar);
	OF oDlg PIXEL SIZE 46,09 

@ aPosGet[3,1]+(2,6),aPosGet[1,9] SAY RetTitle("F1_SERIE") Of oDlg PIXEL SIZE 23,09
@ aPosGet[3,1]+(2,5),aPosGet[1,10] MSGET aObjetos[4] VAR cSerie  PICTURE PesqPict("SF1","F1_SERIE") ;
    F3 IIF( lMT103CPS,ExecBlock("MT103CPS",.F.,.F.),"");
    WHEN !lVisual.And.VisualSX3('F1_SERIE').And.cFormul<>"S" .And. A103ChWhen("F1_SERIE",cSerie,lClassif);
	VALID NfeFornece(cTipo,@cA100For,@cLoja,,@nCombo,@oCombo,@cCodRet,@oCodRet,@aCodR,@cRecIss,@cNatureza,aObjetos[3]).And.CheckSX3("F1_SERIE") .And. !A103VldCpo(cSerie,cCar);
	OF oDlg PIXEL SIZE 18,09

If lSubSerie
	@ aPosGet[3,1]+(2,6),aPosGet[1,11] SAY RetTitle("F1_SUBSERI") Of oDlg PIXEL SIZE 23,09
	@ aPosGet[3,1]+(2,5),aPosGet[1,12] MSGET aObjetos[12] VAR cSubSerie PICTURE PesqPict("SF1","F1_SUBSERI") ;
		WHEN !lVisual.And.VisualSX3('F1_SUBSERI').And.cFormul<>"S" .And. A103ChWhen("F1_SUBSERI",cSubSerie,lClassif);
		VALID NfeFornece(cTipo,@cA100For,@cLoja,,@nCombo,@oCombo,@cCodRet,@oCodRet,@aCodR,@cRecIss,@cNatureza,aObjetos[3]).And.CheckSX3("F1_SUBSERI") .And. !A103VldCpo(cSubSerie,cCar);
		OF oDlg PIXEL SIZE 18,09
EndIf

If cPaisLoc == "PTG"
	@ aPosGet[3,1]+(2,6),aPosGet[1,9] SAY RetTitle("F1_DIACTB") Of oDlg PIXEL SIZE 30,09
	@ aPosGet[3,1]+(2,5),aPosGet[1,10] MSGET aObjetos[10] VAR cCodDiario PICTURE PesqPict("SF1","F1_DIACTB") WHEN !lVisual .And. VisualSX3("F1_DIACTB") F3 CpoRetF3("F1_DIACTB") ;
	    VALID CheckSX3("F1_DIACTB") OF oDlg PIXEL SIZE 30,09 HASBUTTON
EndIf
@ aPosGet[3,1]+25,aPosGet[2,1] SAY RetTitle("F1_EMISSAO") OF oDlg PIXEL SIZE 35,09
@ aPosGet[3,1]+24,aPosGet[2,2] MSGET aObjetos[5] VAR dDEmissao PICTURE PesqPict("SF1","F1_EMISSAO") ;
	WHEN (!lVisual .or. lClassif).And.VisualSX3("F1_EMISSAO").And. A103ChWhen("F1_EMISSAO",dDEmissao,lClassif) Valid CheckSX3("F1_EMISSAO") .And. NfeEmissao(dDEmissao) ;
	OF oDlg PIXEL SIZE 45 ,9 HASBUTTON

If Valtype( lNfMedic ) == "L" .And. !lVisual .And. A103GCDisp() // Indica se exibe CheckBox de carga das medicoes de contratos
	@ aPosGet[3,1]+25,aPosGet[2,3]-15 SAY aObjetos[6] VAR c103SayForn Of oDlg PIXEL SIZE 43,09
	@ aPosGet[3,1]+24,aPosGet[2,4]-35 MSGET aObjetos[7] VAR cA100For  ;
		PICTURE PesqPict("SF1","F1_FORNECE") F3 CpoRetF3("F1_FORNECE");
		WHEN !lVisual.And.VisualSX3("F1_FORNECE").And. A103ChWhen("F1_FORNECE",cA100For,lClassif) ;
		VALID NfeFornece(cTipo,@cA100For,@cLoja,@cUfOrig,@nCombo,@oCombo,@cCodRet,@oCodRet,@aCodR,@cRecIss,@cNatureza,aObjetos[3],,aNFEletr,aNfeDanfe,aInfAdic).And.CheckSX3("F1_FORNECE",cA100For).And.NfeVldRef("NF_CODCLIFOR",cA100For) ;
		OF oDlg PIXEL SIZE nTamGetFor,09 HASBUTTON
Else
	@ aPosGet[3,1]+25,aPosGet[2,3]-10 SAY aObjetos[6] VAR c103SayForn Of oDlg PIXEL SIZE 43,09
	@ aPosGet[3,1]+24,aPosGet[2,4]-nAltNFE MSGET aObjetos[7] VAR cA100For  ;
		PICTURE PesqPict("SF1","F1_FORNECE") F3 CpoRetF3("F1_FORNECE");
		WHEN !lVisual.And.VisualSX3("F1_FORNECE").And. A103ChWhen("F1_FORNECE",cA100For,lClassif) ;
		VALID NfeFornece(cTipo,@cA100For,@cLoja,@cUfOrig,@nCombo,@oCombo,@cCodRet,@oCodRet,@aCodR,@cRecIss,@cNatureza,aObjetos[3],,aNFEletr,aNfeDanfe,aInfAdic).And.CheckSX3("F1_FORNECE",cA100For).And.NfeVldRef("NF_CODCLIFOR",cA100For) ;
		OF oDlg PIXEL SIZE nTamGetFor,09 HASBUTTON 
		
		If IsInCallStack("MATA119")  
			NfeFornece(cTipo,@cA100For,@cLoja,@cUfOrig,@nCombo,@oCombo,@cCodRet,@oCodRet,@aCodR,@cRecIss,@cNatureza,aObjetos[3],,aNFEletr,aNfeDanfe,aInfAdic)
	    EndIf
EndIf
@ aPosGet[3,1]+24,aPosGet[2,5]+nEspLoja MSGET aObjetos[8] VAR cLoja ;
	PICTURE PesqPict("SF1","F1_LOJA") ;
	F3 CpoRetF3("F1_LOJA") ;
	WHEN !lVisual.And.VisualSX3("F1_LOJA") .And. A103ChWhen("F1_LOJA",cLoja,lClassif);
	VALID NfeFornece(cTipo,@cA100For,@cLoja,@cUfOrig,@nCombo,@oCombo,@cCodRet,@oCodRet,@aCodR,@cRecIss,@cNatureza,aObjetos[3],,aNFEletr,aNfeDanfe,aInfAdic).And.CheckSX3("F1_LOJA",cLoja).And.NfeVldRef("NF_LOJA",cLoja) ;	
	OF oDlg PIXEL SIZE 15,09 HASBUTTON

If !lGspInUseM
	
	@ aPosGet[3,1]+25,aPosGet[2,6]+nAltNFE SAY RetTitle("F1_ESPECIE") Of oDlg PIXEL SIZE 63,09
	@ aPosGet[3,1]+24,aPosGet[2,7]+nAltNFE MSGET aObjetos[9] VAR cEspecie ;
		PICTURE PesqPict("SF1","F1_ESPECIE") ;
		F3 CpoRetF3("F1_ESPECIE");
		WHEN (lClassif.Or.!lVisual).And.VisualSX3("F1_ESPECIE").And. A103ChWhen("F1_ESPECIE",cEspecie,lClassif);
		VALID CheckSX3("F1_ESPECIE",cEspecie) .And. Iif(lIntGfe,A103VldEsp(cEspecie),.T.)	.And. ;
        IIf( lUsaNewKey , NfeFornece(cTipo,@cA100For,@cLoja,@cUfOrig,@nCombo,@oCombo,@cCodRet,@oCodRet,@aCodR,@cRecIss,@cNatureza,aObjetos[3]) , .T.) ;
		OF oDlg PIXEL SIZE 30,09 HASBUTTON

	If lUfOrig
		@ aPosGet[3,1]+25,aPosGet[2,8]+nAltNFE SAY OemToAnsi(STR0028) Of oDlg PIXEL SIZE 63 ,9 // UF.Origem
		@ aPosGet[3,1]+24,aPosGet[2,9]+nAltNFE MSGET oUfOrig VAR cUfOrig PICTURE "@!" F3 "12" ;
			When !lVisual.And.VisualSX3('F1_EST').And. A103ChWhen("F1_EST",cUfOrig,lClassif) .And. !IsInCallStack("MATA116") Valid CheckSX3('F1_EST',cUfOrig) .And. ;
			MaFisAlt( "NF_UFORIGEM", cUfOrig ) .And. IIF(ExistBlock("M103NFEL") .And. !lPreNota,A103NfElet("F1_EST",cUfOrig,aNFEletr,aNfeDanfe,aInfAdic),.T.) .And. Eval( bGdRefresh ) OF oDlg PIXEL SIZE 20,9 HASBUTTON
		If(lLGPD,OfuscaLGPD(oUfOrig,"F1_EST"),.F.)
	EndIf

Endif        
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Indica se exibe CheckBox de carga das medicoes de contratos         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Valtype( lNfMedic ) == "L" .And. (!lVisual .Or. l140Altera) .And. A103GCDisp()   
	@ aPosGet[3,1]+25,aPosGet[2,10] SAY STR0053 Of oDlg PIXEL SIZE 40,09 // "Filtra Medicao"
	@ aPosGet[3,1]+24,aPosGet[2,10] + 44 CHECKBOX oNfMedic VAR lNfMedic PROMPT "" SIZE 008,010 ON CLICK( oNfMedic:Refresh() ) OF oDlg PIXEL
EndIf                                                                                         	

bRefresh := {|| NfeCabOk(lVisual,aObjetos[1],aObjetos[3],aObjetos[5],aObjetos[7],aObjetos[8],lFiscal,cUfOrig,,,aObjetos[9],.T.,aObjetos[11],c103TpComp)}

aObjetos[1]:SetFocus()

//Salva o cTipo
If Empty(cTipo) 
	NfeCombo(@cTipo,aCombo1,c103Tipo,aAuxCombo1,"1")
Endif  

Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeCabOk  ³Autor  ³ Eduardo Riera         ³ Data ³17.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao dos dados do cabecalho do documento de   ³±±
±±³          ³entrada                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpL1: Indica se eh uma operacao de visualizacao             ³±±
±±³          ³ExpO2: Objeto get do tipo do documento de entrada            ³±±
±±³          ³ExpO3: Objeto get do numero do documento de entrada          ³±±
±±³          ³ExpO4: Objeto get da data de emissao do documento de entrada ³±±
±±³          ³ExpO5: Objeto get do codigo do fornecedor do documento       ³±±
±±³          ³ExpO6: Objeto get da loja do fornecedor do documento         ³±±
±±³          ³ExpC7: Unidade federativa de origem                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo exibir/controlar o folder finan³±±
±±³          ³ceiro.                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeCabOk(lVisual,oTipo,oNota,oEmissao,oFornece,oLoja,lFiscal,cUfOrig,cCodMunISS,cUfPresISS,oEspecie,lVldEspec,oTpCompl)
Local lRetorno 	:= .T.
Local bIPRefresh:= {|| MaFisToCols(aHeader,aCols,,"MT100"),Eval(bRefresh),Eval(bGdRefresh)}	// Carrega os valores da Funcao fiscal e executa o Refresh
Local lEspObg	:= SuperGetMV("MV_ESPOBG",.F.,.F.)
Local lTpCompl	:= SF1->(ColumnPos("F1_TPCOMPL")) > 0 .And. Type("cTpCompl") == "C" .And. !Empty(MaFisScan("NF_TPCOMPL",.F.)) 
Local lTrbGen   := IIf(FindFunction("ChkTrbGen"),ChkTrbGen("SD1", "D1_IDTRIB"),.F.) // Verificacao se pode ou nao utilizar tributos genericos
Local lMt116    := FwIsInCallStack("A116INCLUI")

DEFAULT lFiscal := .T.
DEFAULT lVldEspec	:= .F.
DEFAULT cUfOrig := ""
DEFAULT cCodMunISS := ""
DEFAULT cUfPresISS := ""
DEFAULT oEspecie	:= NIL

If !lVisual
	Do Case
		Case Empty(cTipo)
			If oTipo<>Nil
				oTipo:SetFocus()
				lRetorno := .F.
			EndIf
		Case lTpCompl .And. cTipo == "C" .And. Empty(cTpCompl)
			If oTpCompl<>Nil
				oTpCompl:SetFocus()
				lRetorno := .F.
			EndIf
		Case Empty(cNFiscal) .And. cFormul <> "S"
			If oNota<>Nil
				oNota:SetFocus()
				lRetorno := .F.
			EndIf
		Case Empty(dDEmissao)
			If oEmissao<>Nil
				oEmissao:SetFocus()
				lRetorno := .F.
			EndIf
		Case Empty(cA100For)
			If oFornece<>Nil
				oFornece:SetFocus()
				lRetorno := .F.
			EndIf
		Case Empty(cLoja)
			If oLoja<>Nil
				oLoja:SetFocus()
				lRetorno := .F.
			EndIf
		Case Empty(cEspecie) .And. lEspObg .And. lVldEspec .And. (AllTrim(FunName())<>"MATA140")
			If oEspecie<>Nil 
				oEspecie:SetFocus()
				lRetorno := .F.
			EndIf
	EndCase
Endif

If lRetorno .And. lFiscal
	If !MaFisFound("NF")
        MaFisIni(cA100For,cLoja,IIf(cTipo$'DB',"C","F"),cTipo,Nil,MaFisRelImp("MT100",{"SF1","SD1"}),,!lVisual,NIL,NIL,NIL,,,,,,,,,,,,,,dDEmissao,,,,,,,,lTrbGen)
        If !Empty(cUfOrig)
            MaFisAlt("NF_UFORIGEM",cUfOrig)
		Endif   
        If !Empty(cCodmunISS)
            MaFisAlt("NF_CODMUN",cCodMunISS)
		EndIf

        If !Empty(cUfPresISS)
            MaFisAlt("NF_UFPREISS",cUfPresISS)
		EndIf
	Else
        If (!Empty(cUfOrig) .And. !lMt116)
            MaFisAlt("NF_UFORIGEM",cUfOrig)
		Endif 
		If lMt116
			If cUfOrig <> cUfOri .And. Empty(aInfAdic[10])
				cUfOrig := cUfOri
				MaFisAlt("NF_UFORIGEM",cUfOrig)
			ElseIf !Empty(aInfAdic[10]) .And. aInfAdic[10] <> cUfOrig .And. MaFisRet( ,"NF_UFORIGEM") <> aInfAdic[10] 
				cUfOrig := aInfAdic[10]
				MaFisAlt("NF_UFORIGEM",cUfOrig)
			EndIf	
		EndIf    
		If !Empty(MaFisScan("NF_DTEMISS",.F.))	// Verifica se a MATXFIS possui a referentcia NF_DTEMISS
			MaFisAlt("NF_DTEMISS",dDEmissao)
			Eval(bIPRefresh)
		EndIf	
	EndIf
	If(Type("cEspecie")<>"U" .And. cEspecie<>Nil)
		MaFisAlt("NF_ESPECIE",cEspecie)			
	EndIf
	If lTpCompl
		MaFisAlt("NF_TPCOMPL", cTpCompl)
	EndIf
EndIf

If lRetorno	.And. cFormul<>"S"	
	lRetorno := A103ExstNF()
	If !lRetorno
		If  ValType(oNota) == "O"
			oNota:SetFocus()						
		EndIf
	EndIf
EndIf

Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeCombo  ³Autor  ³Alexandre Inacio Lemes ³ Data ³22/01/2009 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de verificacao dos codigos dos combos                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Variavel que recebera conteudo do array de referencia.³±±
±±³          ³ExpA2: Array do combobox                                     ³±±
±±³          ³ExpC3: Valor selecionado do combobox                         ³±±
±±³          ³ExpA4: Objeto say para atualizar o texto                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1: Posicicao do combo                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo encontrar a referencia correta ³±±
±±³          ³do combobox                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NfeCombo(cVariavel,aCombo,cCombo,aReferencia,cIdent)

Local nPos	:= aScan(aCombo,cCombo)
Local lRet  := (nPos>0)
Local nPosProd := aScan(aHeader,{|x| AllTrim(x[2]) == "D1_COD"} )

//Garante que não haverá diferenças de espaço.
cVariavel := Alltrim(cVariavel)
aReferencia[nPos] := Alltrim(aReferencia[nPos])

If Type("cFunTipo") == "U"
	Static cFunTipo := ""
EndIf

If !Empty(cVariavel) .And. cVariavel <> aReferencia[nPos] .And. cIdent == "1" .And. (Len(aCols) > 1 .Or. !Empty(aCols[1][nPosProd])) //verifica se tem informação no aCols para excluir
	If MsgYesNo(STR0071,STR0018) //"Ao alterar o tipo da Nota os itens já digitados serão excluídos. Deseja continuar?"
	If IsInCallStack("MATA140")
			A103LimpIT(cTipo,@cA100For,@cLoja)
		EndIf
		If nPos > 0
			cVariavel := aReferencia[nPos]
		EndIf
    Else
        lRet := .F.
	EndIf
ElseIf cIdent == "3" //Tipo de Complemento
	If cVariavel <> aReferencia[nPos] .And. (Len(aCols) > 1 .And. !Empty(aReferencia[nPos]) .Or. !Empty(aCols[1][nPosProd]))
		If MsgYesNo(STR0071,STR0018) //"Ao alterar o tipo da Nota os itens ja digitados serao excluidos. Deseja continuar?"
			If IsInCallStack("MATA140")
				A103LimpIT(cTipo,@cA100For,@cLoja)
			EndIf
			If nPos > 1
				cVariavel := aReferencia[nPos]
			Else
				lRet := .F.
			EndIf
		Else
       	lRet := .F.
		EndIf
	ElseIf (cVariavel <> aReferencia[nPos] .and. Empty(aReferencia[nPos])) //caso o usuário retorne o campo de complemento para vazio
		If (Len(aCols) > 1 .Or. !Empty(aCols[1][nPosProd])) .and. MsgYesNo(STR0071,STR0018) //"Ao alterar o tipo da Nota os itens ja digitados serao excluidos. Deseja continuar?"
			If IsInCallStack("MATA140")
				A103LimpIT(cTipo,@cA100For,@cLoja)
			EndIf
			If nPos > 1
				cVariavel := aReferencia[nPos]
			Else
				lRet := .F.
			EndIf
		Else
			lRet := .F.
		EndIf
	Else
		If nPos > 1
			cVariavel := aReferencia[nPos]
		EndIf
	EndIf
Else
	If nPos > 0
		cVariavel := aReferencia[nPos]
	EndIf
EndIf

If cIdent == "1" //Tipo
	c103Tp := cVariavel
Endif

Return (lRet)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeTipo   ³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao do tipo do documento de entrada          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Tipo do documento de entrada                          ³±±
±±³          ³ExpC2: Codigo do Fornecedor                                  ³±±
±±³          ³ExpA3: Codigo da Loja                                        ³±±
±±³          ³ExpO4: Objeto say para atualizar o texto                     ³±±
±±³          ³ExpO5: Objeto Get para atualizar o codigo do fornecedor      ³±±
±±³          ³ExpO6: Objeto Get para atualizar o codigo da loja            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Tipo valido                                           ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar o tipo do documento de ³±±
±±³          ³entrada                                                      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeTipo(cTipo,cFornece,cLoja,oSay,oFornece,oLoja,oConsF3,cTpCompl)

Local nY 		:= 0
Local cTitulo	:= ""

Local aBusca:= {} 
Local nPosForR:= 0
Local nPosForE:= 0

Default cTpCompl := ""

If Type("cFunTipo") == "U"
	Static cFunTipo := ""
EndIf

cFunTipo:= "NfeTipo"

If oConsF3 <> Nil
	aBusca:=aClone(oConsF3:aControls)
	nPosForR:= Ascan(aBusca,{|x| x:cSX1HLP =="F1_FORRET"})
	nPosForE:= Ascan(aBusca,{|x| x:cSX1HLP =="F1_FORENT"})
EndIf

If cTipo$"DB"
	If oFornece<>Nil
		oFornece:cF3 := CpoRetF3("C5_CLIENTE")
	EndIf
	
	If (oConsF3 <> Nil) .and. (nPosForR>0) .and. (nPosForE>0)
		oConsF3:aControls[nPosForR]:cF3:=CpoRetF3("C5_CLIENTE")
		oConsF3:aControls[nPosForE]:cF3:=CpoRetF3("C5_CLIENTE")
	EndIf 
	
	If oSay<>Nil
		cTitulo := oSay:cCaption
		oSay:SetText(RetTitle("F2_CLIENTE"))
		If oSay:cCaption<>cTitulo
			cFornece := CriaVar("F1_FORNECE",.F.)
			cLoja    := CriaVar("F1_LOJA",.F.)		
		Endif
	EndIf
	If MaFisFound("NF") .And. MaFisRet(,"NF_TIPONF") <> cTipo
		cFornece := CriaVar("F1_FORNECE",.F.)
		cLoja    := CriaVar("F1_LOJA",.F.)
	EndIf
Else
	If oFornece <> Nil
		oFornece:cF3 := CpoRetF3("F1_FORNECE")
	EndIf
	
	If (oConsF3 <> Nil) .and. (nPosForR>0) .and. (nPosForE>0)
		oConsF3:aControls[nPosForR]:cF3:= CpoRetF3("F1_FORNECE")
		oConsF3:aControls[nPosForE]:cF3:= CpoRetF3("F1_FORNECE")
	EndIf 

	If oSay <> Nil
		cTitulo := oSay:cCaption
		oSay:SetText(RetTitle("F1_FORNECE"))
		If oSay:cCaption<>cTitulo
			cFornece := CriaVar("F1_FORNECE",.F.)
			cLoja    := CriaVar("F1_LOJA",.F.)		
		Endif
	EndIf
	If MaFisFound("NF") .And. MaFisRet(,"NF_TIPONF") <> cTipo
		cFornece	:= CriaVar("F1_FORNECE",.F.)
		cLoja		:= CriaVar("F1_LOJA",.F.)
	EndIf
EndIf   

If MaFisFound("NF") .And. ((AllTrim(cTipo) <> AllTrim(MafisRet(,"NF_TIPONF")) .Or. AllTrim(cTpCompl) <> AllTrim(MafisRet(,"NF_TPCOMPL")))) .And. !IsInCallStack("A103DEVOL")
	cCondicao	:= 	CriaVar("F1_COND")
	aCols 		:= {}
	aadd(aCols,Array(Len(aHeader)+1))
	For ny := 1 to Len(aHeader)
		If Trim(aHeader[ny][2]) == "D1_ITEM"
			aCols[1][ny] 	:= StrZero(1,Len(SD1->D1_ITEM))
		Else    
			If Trim(aHeader[ny][2]) <> "D1_ALI_WT".And. Trim(aHeader[nY][2]) <> "D1_REC_WT"
				aCols[1][ny] := CriaVar(aHeader[ny][2])
	    	EndIf
		EndIf
		aCols[1][Len(aHeader)+1] := .F.
	Next nY
	MaFisAlt("NF_CLIFOR",IIf(cTipo$"DB","C","F"))
	MaFisAlt("NF_TIPONF",cTipo)
	MaFisClear()
	If oSay<>Nil
		oSay:Refresh()
	EndIf
	If oFornece<>Nil
		oFornece:Refresh()
	EndIf
	If oLoja<>Nil
		oLoja:Refresh()
	EndIf
	If bGdRefresh<>Nil
		Eval(bGDRefresh)
	EndIf
	If bRefresh<>Nil
		Eval(bRefresh)
	EndIf
	
	If oConsF3 <> Nil
		oConsF3:Refresh()
	EndIf
		
EndIf
Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFormul ³Autor  ³ Eduardo Riera         ³ Data ³16.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao do formulario proprio do documento de    ³±±
±±³          ³entrada                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Formulario proprio (S/N)                              ³±±
±±³          ³ExpC2: Numero do documento de entrada                        ³±±
±±³          ³ExpA3: Serie do documento de entrada                         ³±±
±±³          ³ExpO4: Objeto say para atualizar o texto                     ³±±
±±³          ³ExpO5: Objeto Get para atualizar o codigo do fornecedor      ³±±
±±³          ³ExpO6: Objeto Get para atualizar o codigo da loja            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Formulario valido                                     ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar se o formulario eh pro-³±±
±±³          ³prio ( S/N )                                                 ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFormul(cFormul,cNota,cSerie,oNFiscal,oSerie)
Local cXEspecie:=""

If Type("cFunTipo") == "U"
	Static cFunTipo := ""
EndIf

If cFormul == "S" 
	cNota		:= CriaVar("F1_DOC",.F.)
	cSerie  	:= SerieNfId("SF1",5,"F1_SERIE")
Else
	If cPaisLoc == "BRA" .And. Type("lIntermed") == "L" .And. lIntermed
		aInfAdic[16] := ""
		aInfAdic[17] := Space(06)
		Eval(bRefresh)
	Endif
EndIf

//---------------------------//
//Ponto de Entrada: MT103ESP //
//---------------------------//
If ExistBlock("MT103ESP")      
	cXEspecie := ExecBlock("MT103ESP",.F.,.F.,{cFormul})    
	If (ValType(cXEspecie) == 'C' )
		cEspecie := Padr(cXEspecie,TamSX3("F1_ESPECIE")[1])
	EndIf
EndIf

If oNFiscal<>Nil
	oNFiscal:Refresh()
EndIf
If oSerie<>Nil
	oSerie:Refresh()
EndIf             
If oNFiscal<>Nil .And. Empty(cFunTipo)
	IF cFormul == "N"
		oNFiscal:Setfocus()
	EndIf
EndIf

cFunTipo:= ""

Return(.T.)    

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFornece³Autor  ³ Eduardo Riera         ³ Data ³16.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao do codigo do fornecedor do documento de  ³±±
±±³          ³entrada                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Tipo do documento de entrada                          ³±±
±±³          ³ExpC2: Codigo do documento de entrada                        ³±±
±±³          ³ExpC3: Loja do documento de entrada                          ³±±
±±³          ³ExpC4: Unidade federativa (sera alimentado por referencia)   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Codigo Valido                                         ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar se o codigo do fornece-³±±
±±³          ³dor no documento de entrada                                  ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function NfeFornece(cTipo,cFornece,cCodLoja,cUfOrig,nCombo,oCombo,cCodRet,oCodRet,aCodR,cRecIss,cNatureza,oNrNota,lOkDespImp,aNFEletr,aNfeDanfe,aInfAdic)

Local aArea      	:= GetArea()
Local cNatDup2   	:= ""
Local cCampoVld  	:= ""
Local lRetorno   	:= .F.
Local lForAntNFE 	:= ( Type( "cForAntNfe" ) == "C" ) 
Local lLojAntNFE 	:= ( Type( "cLojAntNfe" ) == "C" ) 
Local a          	:= 0
Local lDespImpor  	:= "MATA119" $ FunName()
Local lPreNota    	:= IsInCallStack("MATA140")
Local lMaFisFound	:= MaFisFound()
Local cA2TIPO		:= ""
Local cNatBloq		:= ""

Default	aCodR		:=	{}
Default cRecIss		:=	"1"
Default cNatureza	:= ""
Default lOkDespImp	:= .F.
Default aNFEletr    := {}
Default aNfeDanfe   := {}
Default aInfAdic    := {}

If Type('l103Auto')=='U'
	Private l103Auto  := .F.
Endif

If Empty(cNatureza) .And. lMaFisFound
	cNatureza := MaFisRet(,"NF_NATUREZA")
Endif

//Verifica se o codigo do fornecedor eh valido
If !Empty(cFornece)
	If cTipo$"DB"
		
		If cCodLoja == Nil .Or. Empty(cCodLoja)
			dbSelectArea("SA1")
			SA1->(dbSetOrder(1))
			If !(xFilial("SA1") == SA1->A1_FILIAL .And. cFornece == SA1->A1_COD)
				If SA1->(MsSeek(xFilial("SA1")+cFornece))
					//-- Se a Loja estiver vazia busco próxima loja desbloqueada
					While SA1->(!Eof()) .And. SA1->A1_COD == cFornece
						If SA1->A1_MSBLQL <> "1"
							cCodLoja := SA1->A1_LOJA
							lRetorno := .T.
							Exit
						EndIf
						SA1->(DbSkip())
					EndDo
				Else
					Help("  ",1,"REGNOIS")
				EndIf
			Else
				cCodLoja := SA1->A1_LOJA
				lRetorno := .T.
			EndIf
		Else
			dbSelectArea("SA1")
			SA1->(dbSetOrder(1))			
			If SA1->(MsSeek(xFilial("SA1")+cFornece+cCodLoja))
				lRetorno := .T.
			Else
				Help("  ",1,"REGNOIS")
			EndIf

			//Verifica se o Registro esta Bloqueado
			If lRetorno .And. !RegistroOk("SA1")
				lRetorno := .F.
			EndIf
		EndIf

		If lRetorno .And. lForAntNFE .And. lLojAntNFE .And. (!(cFornece == cForAntNFE) .Or. !(cCodLoja == cLojAntNFE))
			If IsInCallStack("A103Devol")
				If cUfOrig <> NIL .and. Empty(cUfOrig)
					cUfOrig := SA1->A1_EST 					
				EndIf 					
				cRecIss  := Iif( SA1->A1_RECISS$"1S","1","2" )
			Else
				If cUfOrig <> NIL
					cUfOrig := SA1->A1_EST			
				EndIf 					
				cRecIss  := Iif( SA1->A1_RECISS$"1S","1","2" )
			EndIf
		
			If cTipo <> "D"
				dbSelectArea("SE4")
				SE4->(DbSetOrder(1))
				If SE4->(MsSeek(xFilial("SE4")+SA1->A1_COND))
					If SE4->E4_TIPO <> "9" .And. SE4->E4_TIPO <> "A"
						cCondicao := SA1->A1_COND
					EndIf
				EndIf
				
				dbSelectArea("SED")
				SED->(dbSetOrder(1))
				If SED->(MsSeek(xFilial("SED")+SA1->A1_NATUREZ))
					cNatureza := SA1->A1_NATUREZ
				Else
					cNatureza := CriaVar("E1_NATUREZ",.F.)
				EndIf
				MaFisAlt("NF_NATUREZA",cNatureza)
			Else
				cCondicao := CriaVar("F1_COND",.F.)
				cNatureza := CriaVar("E1_NATUREZ",.F.)
			EndIf
		EndIf

	ElseIf !lOkDespImp
	
		If cCodLoja == Nil .Or. Empty(cCodLoja)
			dbSelectArea("SA2")
			SA2->(dbSetOrder(1))
			If !(xFilial("SA2") == SA2->A2_FILIAL .And. cFornece == SA2->A2_COD)
				If SA2->(MsSeek(xFilial("SA2")+cFornece))
					//-- Se a Loja estiver vazia busco próxima loja desbloqueada
					While SA2->(!Eof()) .And. SA2->A2_COD == cFornece
						If SA2->A2_MSBLQL <> "1"
							cCodLoja := SA2->A2_LOJA
							lRetorno := .T.
							Exit
						EndIf
						SA2->(DbSkip())
					EndDo
				Else
					Help("  ",1,"REGNOIS")
				EndIf
			Else
				cCodLoja := SA2->A2_LOJA
				lRetorno := .T.				
			EndIf
		Else
			dbSelectArea("SA2")
			SA2->(dbSetOrder(1))
			If SA2->(MsSeek(xFilial("SA2")+cFornece+cCodLoja))
				lRetorno := .T.
			Else
				Help("  ",1,"REGNOIS")
			EndIf

			//Verifica se o Registro esta Bloqueado
			If lRetorno .And. !RegistroOk("SA2")
				lRetorno := .F.
			EndIf	
		EndIf
	
		If lRetorno .And. lForAntNFE .And. lLojAntNFE .And. (!(cFornece == cForAntNFE) .Or. !(cCodLoja == cLojAntNFE))
			If !(IsInCallStack("A116Inclui"))
				cUfOrig	:= SA2->A2_EST
			Endif
			cA2TIPO	:= SA2->A2_TIPO
			cRecIss	:= Iif( SA2->A2_RECISS$"1S","1","2" )
		
			dbSelectArea("SE4")
			SE4->(dbSetOrder(1))
			If SE4->(MsSeek(xFilial("SE4")+SA2->A2_COND))
				If SE4->E4_TIPO <> "9" .And. SE4->E4_TIPO <> "A"
					cCondicao  := SA2->A2_COND
				Endif
			Else
				cCondicao := Space(TamSx3("F1_COND")[1])
			EndIf			
		
			dbSelectArea("SED")
			SED->(dbSetOrder(1))
			If SED->(MsSeek(xFilial("SED")+SA2->A2_NATUREZ))
				cNatureza := SA2->A2_NATUREZ
			Else
				cNatureza	:= CriaVar("E2_NATUREZ",.F.)
				cNatDup2	:= SuperGetMV("MV_2DUPNAT",.F.,"")
				
				If !Empty(cNatDup2)
					cNatureza:= &(cNatDup2)
				EndIf
			EndIf

			If !Empty(cNatureza)
				cNatBloq := GetAdvFval("SED","ED_MSBLQL", fwxFilial("SED") + cNatureza,1)
				If cNatBloq == "1" //Registro bloqueado
					cNatureza	:= CriaVar("E2_NATUREZ",.F.)
				Endif
			Endif

			MaFisAlt("NF_NATUREZA",cNatureza)
		EndIf

		If lRetorno .And. !lPreNota
			cA2TIPO := SA2->A2_TIPO
			If ExistBlock("MT103DRF")
				aDirfRt := ExecBlock("MT103DRF",.F.,.F.,{nCombo,cCodRet,@oCombo,@oCodRet})		
				If ValType(aDirfRt) == "A" .And. Len(aDirfRt) > 0
					For a := 1 To Len(aDirfRt)
						nCombo  := Iif(aDirfRt[a][2] > 2, 2, aDirfRt[a][2])
						cCodRet := ""
						If nCombo = 1 
							cCodRet := aDirfRt[a][3]
						EndIf
						If !Empty(cCodRet)
							If aScan(aCodR,{|aX| aX[4]==aDirfRt[a][1]})==0
								aAdd( aCodR,{99, cCodRet,1,aDirfRt[a][1]})
							Else
								aCodR[aScan(aCodR, {|aX| aX[4]==aDirfRt[a][1]})][2] := cCodRet
							EndIf
						EndIf
					Next a
				EndIf
				If ValType( oCombo ) == "O"
					oCombo:Refresh()
				EndIf
				If ValType( oCodRet ) == "O"
					oCodRet:Refresh()
				EndIf
				nCombo  := 2
				cCodRet := "    "
			EndIf
		EndIf
		MaFisAlt("NF_TPCLIFOR",cA2TIPO)
	Else
		lRetorno := .T.
	EndIf 
	
	If lRetorno .And. l103auto
		lRetorno := A103ExstNF()
	EndIf       
Else
	lRetorno := .T.
EndIf

If lRetorno .And. lForAntNFE .And. lLojAntNFE
	cForAntNFE := cFornece
	cLojAntNFE := cCodLoja
ElseIf !lRetorno .And. lDespImpor .And. cFormul == "S"
	cNFiscal := " "
	cSerie   := " "
EndIf

// Ponto de entrada para preencher informacoes na aba Danfe e Nota Fiscal Eletronica
If lRetorno .And. ExistBlock("M103NFEL") .And. !lPreNota
	If AllTrim(ReadVar()) == "CA100FOR"
		cCampoVld := "F1_FORNECE"
	ElseIf AllTrim(ReadVar()) == "CLOJA"
		cCampoVld := "F1_LOJA"
	EndIf
	If !Empty(cCampoVld)
		A103NfElet(cCampoVld,cUfOrig,aNFEletr,aNfeDanfe,aInfAdic)
	EndIf
EndIf

RestArea(aArea)

Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFldFin ³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de tratamento do folder financeiro                    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpO1: Objeto da Janela principal                            ³±±
±±³          ³ExpL2: Indica se o folder eh "somente visualizacao"          ³±±
±±³          ³ExpA3: Array com registros do SE2 quando for visualizacao    ³±±
±±³          ³ExpN4: Indica a posicao X de referencia p/ criacao da Janela ³±±
±±³          ³ExpA5: Array com registros do SE1 quando for visualizacao    ³±±
±±³          ³ExpA6: AHeader dos Titulos a Pagar                           ³±±
±±³          ³ExpA7: ACols   dos Titulos a Pagar                           ³±±
±±³          ³ExpA6: AHeader do SEV                                        ³±±
±±³          ³ExpA7: ACols   do SEV                                        ³±±
±±³          ³ExpL9: Identifica multiplas NF de Desp.Imp. par. MV_NUMITEN  ³±±
±±³          ³       e/ou se passado .T. faz Refresh no folder Duplicatas  ³±±
±±³          ³       mesmo sem acessar a pasta                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo exibir/controlar o folder finan³±±
±±³          ³ceiro.                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFldFin(oDlg,lVisual,aRecSE2,nPosX,aRecSE1,aHeadSE2,aColsSE2,aHeadSEV,aColsSEV,bRefresh,lCalcula,cModRetPIS,lPccBaixa,lTxNeg,cNatureza,nTaxaMoeda,aColTrbGen,nColsSE2,aParcTrGen,cIdsTrGen)

Local aArea     := GetArea()
Local aStruSEV  := {}
Local aIdSEV	:= {}
Local aItensSEV	:= {}
Local aCpoHead  := {}
Local aCposPE	:= {}
Local aVisTrbGen:= {}
Local cDescricao:= ""
Local cQuery    := ""
Local cAliasSEV := "SEV"
Local cChave    := ""
Local nX        := 0
Local nY        := 0
Local nI        := 0
Local nPosItSEV := 0
Local nMultDec  := GetNewPar( "MV_MULTDEC", 2 ) 
Local nTxDia	:= 0
Local nPosRecno := 0
Local nPosValTrb:= 0
Local lQuery    := .F.
Local lAltera	:= !lVisual 
Local l103BDP   := .F.   
Local lEvValPerc:= SEV->(FieldPos("EV_VALPERC")) > 0
Local aAltNewGd := Nil
Local aNFEGDSEV := {}
Local oCtaPag
Local oMoeda
Local oNatureza
Local oDescri
Local oCondicao
Local oTaxa
Local oTxNeg 
Local oMultNat
Local oDscMoeda
Local lMT103NAT  := Existblock("MT103NAT")
Local lMT103GET  := Existblock("MT103GET")
Local lShowRet   := .F.
Local nPosH      := 0 				 
Local lMult      := .T.
Local lRecalc    := .T.
Local lTrbGen    := IIf(FindFunction("ChkTrbGen"),ChkTrbGen("SD1", "D1_IDTRIB"),.F.) .And. FindFunction("FinImpFis") // Verifica se o sistema esta preparado para utilizar o motor de tributos genericos
Local nValDupAnt := 0
Local cLimRec    := SuperGetMv("MV_LIMREC",.F.,"1")
Local aCpoSE2	 := {}
Local lMT103SE2	 := ExistBlock("MT103SE2")
Local lMULNATP   := SuperGetMV("MV_MULNATP")
Local lDUPBRUT   := GetNewPar ("MV_DUPBRUT", .F.)
Local lMT103BDP	 := ExistBlock("MT103BDP")
Local lNFEGDSEV	 := ExistBlock("NFEGDSEV")
Local cCONFDUP	 := GetNewPar( "MV_CONFDUP", "2" )
Local lMTCOLSE2	 := ExistBlock("MTCOLSE2")
Local aSEVcampos := {}
Local cX3Usado 	 := ''
Local nX3Nivel	 := 0
Local nMoedAux 	 := 0
Local oStruSeV   := FWFormStruct(1, 'SEV'  )
Local lAuto103 :=  (Type("l103Auto") <> "U" .And. (l103Auto))

DEFAULT aRecSE1		:=	{}
DEFAULT aRecSE2		:=	{}
DEFAULT aColTrbGen  := {}
DEFAULT aParcTrGen  := {}
DEFAULT lCalcula  	:= .F.
DEFAULT lPccBaixa 	:= .F.
DEFAULT lTxNeg		:= .F.              
DEFAULT cNatureza	:= ""
DEFAULT nTaxaMoeda	:= 0
DEFAULT nColsSE2    := 0
DEFAULT cIdsTrGen	:= ""

aAdd(aSEVcampos,"EV_NATUREZ")
aAdd(aSEVcampos,"EV_PERC")

// Alguns clientes possuem o campo EV_VALPERC e gatilhos para os campos EV_PERC e EV_VALPERC chamando a funcao NfeRatSEV que atualizam um ao outro
// O campo EV_VALPERC deve constar do aCols de multiplas naturezas, caso contrario o percentual digitado em EV_PERC eh zerado pelo gatilho
If lEvValPerc
	aAdd(aSEVcampos,"EV_VALPERC")
EndIf

/*carrega campos customizados.*/
For nI := 1 to len(oStruSeV:afields) 
 If	GetSx3Cache(oStruSeV:afields[nI][3],"X3_PROPRI") == "U"
 	aAdd(aSEVcampos,oStruSeV:afields[nI][3])
 EndIf
Next

If Type("nTaxa")=="N"
	nTaxaMoeda:= nTaxa
EndIf
If Type("nMoedaCor")=="N"
	nMoedAux := nMoedaCor
EndIf
// Armazena no array aColTrbGen as colunas que serao exibidas na aba Duplicatas referentes ao motor de tributos genericos
If lTrbGen
	aColTrbGen := xFisRetTG(Iif(INCLUI,dDataBase,SF1->F1_EMISSAO))
EndIf

bRefresh    := {|| NfeRFldFin(@cCondicao,@cDescricao,@cNatureza,nMoedaCor,@nTaxaMoeda,oCondicao,oNatureza,oMoeda,oTaxa,oDscMoeda,oCtaPag,oMultNat,!lVisual,@aColsSE2,aHeadSE2,@aColsSEV,aHeadSEV,oDescri,oTxNeg,cLimRec,@lRecalc,@nValDupAnt,aColTrbGen,@aParcTrGen,nColsSE2,@cIdsTrGen)}

//Montagem do aHeader da Getdados do contas a pagar
If Empty(aHeadSE2)
	If cPaisLoc == "BRA"
		aCpoSE2 := {{"E2_PARCELA",".F.",".T."}        ,{"E2_VENCTO","M->E2_VENCTO >= M->dDEmissao",".T."} ,{"E2_VALOR","Positivo()",".T."}           ,;
					{"E2_IRRF"   ,"Positivo()",".T."} ,{"E2_ISS"   ,"Positivo()",".T."}                 ,{"E2_INSS" ,"Positivo()","A103VldInss()"} ,;
					{"E2_PIS"    ,"Positivo()",".T."} ,{"E2_COFINS","Positivo()",".T."}                 ,{"E2_CSLL" ,"Positivo()",".T."}           ,;
					{"E2_SEST"   ,"Positivo()",".T."} ,{"E2_FETHAB","Positivo()",".T."}                 ,{"E2_FABOV","Positivo()",".T."}           ,;
					{"E2_FACS"   ,"Positivo()",".T."} ,{"E2_IMA"   ,"Positivo()",".T."}                 ,{"E2_FAMAD","Positivo()",".T."}           ,;
					{"E2_BTRISS" ,"Positivo()",".T."}}
	Else
		aCpoSE2 := {{"E2_PARCELA",".F.",".T."},{"E2_VENCTO","M->E2_VENCTO>=M->dDEmissao",".T."},{"E2_VALOR","Positivo()",".T."}}
	EndIf

	DbSelectArea("SX3")
	SX3->(dbSetOrder(2))

	For nX := 1 To Len(aCpoSE2)
		If SX3->(MsSeek(aCpoSE2[nX,1]))

			AADD(aHeadSE2,{TRIM(x3titulo()),;
							SX3->X3_CAMPO,;
							SX3->X3_PICTURE,;
							SX3->X3_TAMANHO,;
							SX3->X3_DECIMAL,;
							aCpoSE2[nX,2],;
							SX3->X3_USADO,;
							SX3->X3_TIPO,;
							SX3->X3_F3,;
							SX3->X3_CONTEXT,;
							SX3->X3_CBOX,;
							SX3->X3_RELACAO,;
							aCpoSE2[nX,3]})
		EndIf
	Next nX

	// Inclusao das colunas referentes ao motor de tributos genericos
	If lTrbGen .And. Len(aColTrbGen) > 0
		For nX := 1 To Len(aColTrbGen)
			aAdd(aHeadSE2,;
				{aColTrbGen[nX][1],;
				"F2D_VALOR",;
				PesqPict("F2D","F2D_VALOR"),;
				TamSx3("F2D_VALOR")[1],;
				TamSX3("F2D_VALOR")[2],;
				"Positivo()",;
				"",;
				"N",;
				"",;
				"R",;
				"",;
				"",;
				".T."})
		Next nX
		aAdd(aCpoHead,"F2D_VALOR")
	EndIf

	//PE para adicionar campos no aCols da SE2
	If lMT103SE2
		aCposPE:= ExecBlock("MT103SE2",.F.,.F.,{aHeadSE2,lVisual})
		If ValType (aCposPE) == "A" .And. Len(aCposPE) > 0
			For nX:= 1 to Len(aCposPE)
				AADD(aHeadSE2, aCposPE[nX])
			Next nX
		EndIf
	EndIf

	// Variavel que contem o numero de colunas da tabela SE2 exibidas na aba Duplicatas
	nColsSE2 := Len(aHeadSE2) - Len(aColTrbGen)

EndIf

//Campos editaveis na aba duplicatas.
For nX := 1 To Len(aHeadSE2)
	If aHeadSE2[nX,2] <> "E2_PARCELA"
		aAdd(aCpoHead,aHeadSE2[nX,2])
	Endif
Next nX
	
//Adiciona os campos de Alias e Recno ao aHeader para WalkThru
ADHeadRec("SE2",aHeadSE2)

//Montagem do aHeader da Getdados de multipla natureza
If Empty(aHeadSEV) .And. lMULNATP	
	For nX := 1 To Len(aSEVcampos)
		cX3Usado := GetSx3Cache(aSEVcampos[nX],"X3_USADO")
		nX3Nivel := GetSx3Cache(aSEVcampos[nX],"X3_NIVEL")
		IF X3Uso(cX3Usado) .AND. cNivel >= nX3Nivel		
			AADD(aHeadSEV,{ TRIM(GetSx3Cache(aSEVcampos[nX],"X3_TITULO")),;	//X3_TITULO
							GetSx3Cache(aSEVcampos[nX],"X3_CAMPO"),;	//X3_CAMPO,;
							GetSx3Cache(aSEVcampos[nX],"X3_PICTURE"),; 	//X3_PICTURE,;
							GetSx3Cache(aSEVcampos[nX],"X3_TAMANHO"),;	//X3_TAMANHO,;
							GetSx3Cache(aSEVcampos[nX],"X3_DECIMAL"),;	//X3_DECIMAL,;
							GetSx3Cache(aSEVcampos[nX],"X3_VALID"),;	//X3_VALID,;
							GetSx3Cache(aSEVcampos[nX],"X3_USADO"),;	//X3_USADO,;
							GetSx3Cache(aSEVcampos[nX],"X3_TIPO"),;		//X3_TIPO,;
							GetSx3Cache(aSEVcampos[nX],"X3_F3"),;		//X3_F3,;
							GetSx3Cache(aSEVcampos[nX],"X3_CONTEXT"),;	//X3_CONTEXT,;
							GetSx3Cache(aSEVcampos[nX],"X3_CBOX"),;		//X3_CBOX,;   
							GetSx3Cache(aSEVcampos[nX],"X3_RELACAO"),;	//X3_RELACAO,;
							".T."})
			If AllTrim(aSEVcampos[nX])=="EV_PERC"
				aHeadSEV[nX][3] := "@E 999." + Replicate("9",nMultDec)                
			EndIf
		EndIf		
	Next nX
EndIf

//Adiciona os campos de Alias e Recno ao aHeader para WalkThru
ADHeadRec("SEV",aHeadSEV)

//Montagem do aCols da Getdados das multiplas naturezas
If lVisual
	If !Empty(aRecSE2)
		dbSelectArea("SE2")
		MsGoto(aRecSE2[1])
		
		dbSelectArea("SEV")
		dbSetOrder(1)

		aStruSEV  := SEV->(dbStruct())
		cAliasSEV := "NFEFLDFIN"
		lQuery    := .T.
		cQuery    := " SELECT SEV.*,SEV.R_E_C_N_O_ SEVRECNO "
		cQuery    += " FROM "+RetSqlName("SEV")+" SEV "
		cQuery    += " WHERE SEV.EV_FILIAL = '" + xFilial("SEV") + "'"
		cQuery    += " AND SEV.EV_PREFIXO  = '" + SE2->E2_PREFIXO + "'"
		cQuery    += " AND SEV.EV_NUM	   = '" + SE2->E2_NUM + "'"
		cQuery    += " AND SEV.EV_PARCELA  = '" + SE2->E2_PARCELA + "'"
		cQuery    += " AND SEV.EV_TIPO     = '" + SE2->E2_TIPO + "'"
		cQuery    += " AND SEV.EV_CLIFOR   = '" + SE2->E2_FORNECE + "'"
		cQuery    += " AND SEV.EV_LOJA     = '" + SE2->E2_LOJA + "'"
		cQuery    += " AND SEV.EV_RECPAG   = 'P' "
		cQuery    += " AND SEV.D_E_L_E_T_  = ' ' "
		cQuery    += " ORDER BY "+SqlOrder(SEV->(IndexKey()))

		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSEV)
		
		For nX := 1 To Len(aStruSEV)
			If aStruSEV[nX][2]<>"C"
				TcSetField(cAliasSEV,aStruSEV[nX][1],aStruSEV[nX][2],aStruSEV[nX][3],aStruSEV[nX][4])
			EndIf
		Next nX

		While (cAliasSEV)->(!Eof()) .And. (cAliasSEV)->EV_FILIAL == xFilial("SEV") .And.;
				(cAliasSEV)->EV_PREFIXO == SE2->E2_PREFIXO .And.;
				(cAliasSEV)->EV_NUM     == SE2->E2_NUM 	.And.;
				(cAliasSEV)->EV_PARCELA == SE2->E2_PARCELA .And.;
				(cAliasSEV)->EV_TIPO    == SE2->E2_TIPO 	.And.;
				(cAliasSEV)->EV_CLIFOR  == SE2->E2_FORNECE .And.;
				(cAliasSEV)->EV_LOJA    == SE2->E2_LOJA

			If (cAliasSEV)->EV_RECPAG == "P"
				aadd(aColsSEV,Array(Len(aHeadSEV)+1))
				For nX := 1 To Len(aHeadSEV)
					If IsHeadRec(aHeadSEV[nX][2])
						aColsSEV[Len(aColsSEV)][nX] := IIf(lQuery , (cAliasSEV)->SEVRECNO , SEV->(Recno())  )
						If (cAliasSEV)->EV_IDENT = "2"
							aadd(aIdSEV,IIf(lQuery,(cAliasSEV)->SEVRECNO,SEV->(Recno())))
							nPosRecno := nX
						EndIf
					ElseIf IsHeadAlias(aHeadSEV[nX][2])
						aColsSEV[Len(aColsSEV)][nX] := "SEV"
					ElseIf aHeadSEV[nX,10] == "V"
						aCOLSSEV[Len(aColsSEV)][nX] := CriaVar(aHeadSEV[nX,2],.F.)
					Else
						aCOLSSEV[Len(aColsSEV)][nX] := FieldGet(FieldPos(aHeadSEV[nX,2]))
					EndIf
					If AllTrim(aHeadSEV[nX,2]) == "EV_PERC"
						aCOLSSEV[Len(aColsSEV)][nX] *= 100
					EndIf
				Next nX
				aCOLSSEV[Len(aColsSEV)][Len(aHeadSEV)+1] := .F.
			EndIf
			(cAliasSEV)->(dbSkip())
		EndDo
		
		If Len(aIdSEV) > 0 .And. nPosRecno > 0
			For nX := 1 To Len(aIdSEV)
				If (nPosItSEV := aScan(aColsSEV, {|x| x[nPosRecno]==aIdSEV[nX]})) > 0
					aadd(aItensSEV,aColsSEV[nPosItSEV])
				EndIf
			Next nX
			If Len(aItensSEV) > 0
				aColsSEV := aItensSEV
			EndIf
		EndIf
		
		If lQuery
			(cAliasSEV)->(dbCloseArea())
			dbSelectArea("SEV")
		EndIf
	EndIf
EndIf

If Empty(aColsSEV) .And. lMULNATP
	//Montagem do aCols da Getdados dos titulos a pagar
	aadd(aColsSEV,Array(Len(aHeadSEV)+1))
	For nX := 1 To Len(aHeadSEV)
		If IsHeadRec(aHeadSEV[nX][2])
			aColsSEV[Len(aColsSEV)][nX] := 0
		ElseIf IsHeadAlias(aHeadSEV[nX][2])
			aColsSEV[Len(aColsSEV)][nX] := "SEV"
		Else
			aColsSEV[Len(aColsSEV)][nX] := CriaVar(aHeadSEV[nX,2],.F.)	
		EndIf
	Next nX
	aColsSEV[Len(aColsSEV)][Len(aHeadSEV)+1] := .F.
EndIf

//Montagem do aCols da Getdados dos titulos financeiros
If lVisual
	Do Case
	Case !Empty(aRecSE2)
		For nX := 1 To Len(aRecSE2)
			dbSelectArea("SE2")
			MsGoto(aRecSE2[nX])
			nMoedaCor	:= SE2->E2_MOEDA
			nTaxaMoeda  := SF1->F1_TXMOEDA
			nTxDia		:= RecMoeda(SE2->E2_EMISSAO,nMoedaCor)
			lTxNeg		:= !Empty(SE2->E2_TXMOEDA) .And. nTxDia <> 0 .And. nTxDia <> SE2->E2_TXMOEDA
			If SE2->E2_TIPO == MVNOTAFIS .Or. cPaisLoc <> "BRA"
				If SE2->E2_TIPO == MVNOTAFIS
					cNatureza	:= SE2->E2_NATUREZ
				EndIf

				// Retorna valores de tributos genericos gravados na tabela FKQ para exibir na visualizacao da nota
				If lTrbGen
					cChave := SE2->E2_FILIAL+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
					aVisTrbGen := FinImpFis(cChave,SE2->E2_FILORIG,"SE2",.F.)
				EndIf

				aadd(aColsSE2,Array(Len(aHeadSE2)+1))
				For nY := 1 To Len(aHeadSE2)
					If IsHeadRec(aHeadSE2[nY][2])
						aColsSE2[Len(aColsSE2)][nY] := SE2->(RecNo())
					ElseIf IsHeadAlias(aHeadSE2[nY][2])
						aColsSE2[Len(aColsSE2)][nY] := "SE2"
					ElseIf aHeadSE2[nY][2] == "F2D_VALOR"
						If Len(aVisTrbGen) > 0 .And. Len(aVisTrbGen[1]) >= 9 .And. (nPosValTrb := aScan(aVisTrbGen,{|x| x[9] == aHeadSE2[nY][1]}) ) > 0	// Verifica se tem valor a exibir na coluna
							aColsSE2[Len(aColsSE2)][nY] := aVisTrbGen[nPosValTrb][3]
						Else
							aColsSE2[Len(aColsSE2)][nY] := CriaVar("F2D_VALOR")
						EndIf
					Else
						aColsSE2[Len(aColsSE2)][nY] := FieldGet(FieldPos(aHeadSE2[nY,2]))
					EndIf
				Next nY
				aColsSE2[Len(aColsSE2)][Len(aHeadSE2)+1] := .F.
				
				If lDUPBRUT
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_IRRF"}))<>0
						//Conversao do valor do imposto para Moeda 2
					    If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]						
						Endif
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_ISS"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else 
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]						
						Endif
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_INSS"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_PIS"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else 
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_COFINS"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else                                                                                
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_CSLL"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_FETHAB"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_SEST"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_FABOV"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf                                                                 
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_FACS"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_IMA"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_FAMAD"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_BTRISS"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						EndIf
					EndIf
					// Tratamento para visualizacao dos valores calculados pelo motor de tributos genericos
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="F2D_VALOR"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						EndIf	
					EndIf
				EndIf
			EndIf
		Next nX

	Case !Empty(aRecSE1)
		For nX	:= 1 To Len(aRecSE1)
			dbSelectArea("SE1")
			MsGoto(aRecSE1[nX])
			cNatureza	:= SE1->E1_NATUREZ
			nMoedaCor	:= SE1->E1_MOEDA
			nTaxaMoeda  := SF1->F1_TXMOEDA
			If Alltrim(SE1->E1_TIPO)$"NF/"+MV_CRNEG .Or. cPaisLoc!="BRA"
				aadd(aColsSE2,Array(Len(aHeadSE2)+1))
				For nY := 1 To Len(aHeadSE2)
					If IsHeadRec(aHeadSE2[nY][2])
						aColsSE2[Len(aColsSE2)][nY] := SE1->(RecNo())
					ElseIf IsHeadAlias(aHeadSE2[nY][2])
						aColsSE2[Len(aColsSE2)][nY] := "SE1"
					ElseIf aHeadSE2[nY][2] == "F2D_VALOR"
						aColsSE2[Len(aColsSE2)][nY] := CriaVar("F2D_VALOR")
					Else									
						If FieldPos("E1"+SubStr(aHeadSE2[nY,2],3)) > 0	
							aColsSE2[Len(aColsSE2)][nY] := FieldGet(FieldPos("E1"+SubStr(aHeadSE2[nY,2],3)))
        	            EndIf                    
                    EndIf
				Next nY
				aColsSE2[Len(aColsSE2)][Len(aHeadSE2)+1] := .F.
			EndIf
		Next nX
	EndCase
EndIf

If Empty(aColsSE2)
	//Montagem do aCols da Getdados dos titulos a pagar
	aadd(aColsSE2,Array(Len(aHeadSE2)+1))
	For nX := 1 To Len(aHeadSE2)
		If IsHeadRec(aHeadSE2[nX][2])
			aColsSE2[Len(aColsSE2)][nX] := 0
		ElseIf IsHeadAlias(aHeadSE2[nX][2])
			aColsSE2[Len(aColsSE2)][nX] := "SE2"
		ElseIf aHeadSE2[nX][2] == "F2D_VALOR"
			aColsSE2[Len(aColsSE2)][nX] := CriaVar("F2D_VALOR")
		Else
			aColsSE2[Len(aColsSE2)][nX] := CriaVar(aHeadSE2[nX,2],.F.)	
		EndIf
	Next nX
	aColsSE2[Len(aColsSE2)][Len(aHeadSE2)+1] := .F.
Elseif !Empty(aColsSE2) .And. lVisual
	If lMTCOLSE2
		aColsPE:= ExecBlock("MTCOLSE2",.F.,.F.,{aColsSE2,0})
		If ValType(aColsPE) == "A"
			aColsSE2	 := aColsPE
		EndIf
	EndIf
EndIf

dbSelectArea("SE4")
SE4->(dbSetOrder(1))

//Inicializa as variaveis dados dos titulos financeiros
If lVisual
	If SE4->(MsSeek(xFilial("SE4")+cCondicao))
		cDescricao := SE4->E4_DESCRI
	EndIf
Else
	If MaFisFound("NF") .And. !IsInCallStack("A103DEVOL")
		cNatureza := MaFisRet(,"NF_NATUREZA")
		lAltera := IIF(MaFisRet(,"NF_BASEDUP")>0,.T.,.F.)
		
		If SE4->(MsSeek(xFilial("SE4")+cCondicao))
			cDescricao := SE4->E4_DESCRI
		Else
			cDescricao := CriaVar("E4_DESCRI",.F.)
		EndIf
	EndIf
EndIf

If ( oDlg<>Nil )                  
	@ 03,04 SAY RetTitle("F1_COND") Of oDlg PIXEL SIZE 40,09	
	@ 02,45 MSGET oCondicao VAR cCondicao  ;
		PICTURE PesqPict('SF1','F1_COND')  ;
		OF oDlg PIXEL SIZE 22,09 ;
		F3 CpoRetF3('F1_COND') ;
		WHEN VisualSX3('F1_COND');
		VALID Vazio().Or.(cTipo<>'D' .And. NfeCond(cCondicao,@oDescri,@cDescricao) .And. CheckSX3('F1_COND') .And. Eval(bRefresh)) HASBUTTON
	oCondicao:lReadOnly := (IIF((INCLUI .Or. ALTERA) .And. lMt103Get,ExecBlock("MT103GET",.F.,.F.),!lAltera) .And. MaFisFound("NF") .And. cTipo <> "D") .Or. cTipo == 'D'  // O Retorno .T. Do ponto MT103GET impede a edicao do Get
	oCondicao:bLostFocus := { || IIf(!Vazio(cCondicao) .And. cTipo<>'D' .And. !NfeCond2(cCondicao),{oFolder:nOption := 6},"")}
   	
	@ 16,04 SAY RetTitle("E4_DESCRI") Of oDlg PIXEL SIZE 30,09
	@ 15,31 MSGET oDescri VAR cDescricao  PICTURE PesqPict('SE4','E4_DESCRI') OF oDlg PIXEL SIZE 55,09	
	oDescri:lReadOnly := .T.

	@ 29,04 SAY RetTitle("A2_NATUREZ") Of oDlg PIXEL SIZE 41,09
	@ 28,31 MSGET oNatureza VAR cNatureza  ;
		PICTURE PesqPict('SE2','E2_NATUREZ') ;    
		OF oDlg PIXEL SIZE 55,09 ;
		F3 CpoRetF3("E2_NATUREZ") ;
		VALID if(lMt103Nat, if(ExecBlock("MT103NAT",.F.,.F.,cNatureza),NfeVldRef("NF_NATUREZA",cNatureza),.F.),;
  		                     Vazio(cNatureza) .Or. (ExistCpo('SED',cNatureza) .And. A103ValNat(cNatureza) .And. NfeVldRef("NF_NATUREZA",cNatureza))) HASBUTTON
		                     
	    oNatureza:lReadOnly := IIF((INCLUI .Or. ALTERA) .And. lMt103Get,ExecBlock("MT103GET",.F.,.F.),!lAltera) // O Retorno .T. Do ponto MT103GET impede a edicao do Get

	@ 42,04 SAY oDscMoeda PROMPT RetTitle("F1_MOEDA") Of oDlg PIXEL SIZE 30,09
	@ 41,31 MSGET oMoeda VAR nMoedaCor SIZE 12,09 PIXEL OF oDlg ;
		VALID nMoedaCor<=MoedFin().And. nMoedaCor <> 0 .And. a103AtuTaxa(@nMoedAux)  PICTURE X3Picture("F1_MOEDA") HASBUTTON
	oMoeda:lReadOnly := IIF((INCLUI .Or. ALTERA) .And. lMt103Get,ExecBlock("MT103GET",.F.,.F.),!lAltera) // O Retorno .T. Do ponto MT103GET impede a edicao do Get

	@ 41,45 MSGET oTaxa VAR nTaxaMoeda SIZE 41,09 PIXEL OF oDlg PICTURE X3Picture("F1_TXMOEDA");
		VALID Eval(bRefresh)
	oTaxa:lReadOnly := IIF((INCLUI .Or. ALTERA) .And. lMt103Get,ExecBlock("MT103GET",.F.,.F.),!lAltera .And. nMoedaCor <> 1) // O Retorno .T. Do ponto MT103GET impede a edicao do Get

	@ 52,04 CHECKBOX oTxNeg  VAR lTxNeg PROMPT STR0050 SIZE 100,010 ON CLICK( oTxNeg:Refresh() ) OF oDlg PIXEL
	oTxNeg:lReadOnly := !(INCLUI .Or. ALTERA)
	
	lShowRet := ValType( cModRetPIS ) == "C" .And. !lVisual

	//Ponto de Entrada para Bloquear a edicao do aColsSe2 de Duplicatas
	If lMT103BDP
		l103BDP:=ExecBlock("MT103BDP",.F.,.F.,{})
		If ValType(l103BDP)<>'L'
			l103BDP:=.F.
		EndIf
	EndIf
	
	If lMULNATP .And. !__lPyme    
		//Ponto de Entrada permite quais os campos podem ser editados ou nao
		//na getdados do Rateio das Multiplas Naturezas 
		If lNFEGDSEV
			aNFEGDSEV := ExecBlock("NFEGDSEV", .F., .F.)
			If valtype(aNFEGDSEV) == "A"
				aAltNewGd := aNFEGDSEV
			EndIf
		EndIf

		oCtaPag  := MsNewGetDados():New(004,090,058,(nPosX/2)+060,IIF(lAltera,GD_UPDATE,0),"NfeLOkSE2","NfeTOkSE2",/*inicpos*/,aCpoHead,/*freeze*/,120,"A103VencSE2()",/*superdel*/,/*delok*/,oDlg,aHeadSE2,aColsSE2)
		If l103BDP
			oCtaPag:oBrowse:lReadOnly:= .T.
		EndIf
		
		oMultNat := MsNewGetDados():New(004,(nPosX/2)+064,058,nPosX+066,IIf(lAltera,GD_INSERT+GD_UPDATE+GD_DELETE,0),"NfeLOkSEV",/*TudoOK*/,/*inicpos*/,aAltNewGd,/*freeze*/,200,/*fieldok*/,/*superdel*/,/*delok*/,oDlg,aHeadSEV,aColsSEV)		
		oMultNat:oBrowse:bLostFocus	:= {|| aColsSEV:=aClone(oMultNat:aCols),;
											NfeMultNat(oMultNat,aColsSE2,aHeadSE2,aColsSEV,aHeadSEV),;
		  							       oFolder:nOption := IIf(lMult, Eval( { || oFoco103:Cargo[2] := .T., oFolder:nOption } ), Eval( { || oFoco103:Cargo[2] := .F.,6 } ) )}
		
		oMultNat:oBrowse:bValid	:= { || NfeTOkSEV(oMultNat:aHeader,oMultNat:aCols,@lMult) } 
	Else
		oCtaPag  := MsNewGetDados():New(004,090,058,nPosX+065,IIF(lAltera,GD_UPDATE,0),"NfeLOkSE2","NfeTOkSE2",/*inicpos*/,aCpoHead,/*freeze*/,120,"A103VencSE2()",/*superdel*/,/*delok*/,oDlg,aHeadSE2,aColsSE2)
		
		If l103BDP
			oCtaPag:oBrowse:lReadOnly:= .T.
		EndIf
	EndIf

	If lShowRet
		@ 004,nPosX+068 BUTTON STR0054 SIZE 30,11 FONT oDlg:oFont ; // "Retencao"
			ACTION A103CalcRt(aColsSE2,aHeadSE2,@cModRetPIS,lPccBaixa) OF oDlg PIXEL
	EndIf				

	@ IIF(lShowRet,015,004),nPosX+068 BUTTON STR0055 MESSAGE STR0056 SIZE 30,11 FONT oDlg:oFont ;
	ACTION NfeRatImp(oCtaPag,nMoedaCor,aColsSE2,aHeadSE2,aColTrbGen,nColsSE2) OF oDlg PIXEL // "Rat.Imp.", "Rateio de Impostos Financeiros"
	
	If Type( "oFoco103" ) == "O" .And. cCONFDUP == "1" 
		//Esta secao verifica para qual objeto a getdados do financeiro perdeu o foco
		//Se perder o foco para o objeto oFoco103 ( dummy ) localizado na confirmacao da dialog		
		//marca a variavel de controle da Dialog como .F. impedindo o fechamento da janela caso				
		//a TudoOk da getdados retorne .F.						
		oCtaPag:oBrowse:bLostFocus	:= {|nHand| NfeMultNat(oMultNat,aColsSE2,aHeadSE2,aColsSEV,aHeadSEV),oFolder:nOption := IIf(NfeTotFin(oCtaPag:aHeader,oCtaPag:aCols,IIf(cLimRec=="3",.F.,.T.),@lRecalc,nColsSE2,aColTrbGen),oFolder:nOption, Eval( { |nHand| oFoco103:Cargo[1] := !( nHand == oFoco103:hWnd ),6 }, nHand ) ),aColsSE2:=oCtaPag:aCols }
	Else		
		oCtaPag:oBrowse:bLostFocus	:= {|| NfeMultNat(oMultNat,aColsSE2,aHeadSE2,aColsSEV,aHeadSEV),oFolder:nOption := IIf(NfeTotFin(oCtaPag:aHeader,oCtaPag:aCols,IIf(cLimRec=="3",.F.,.T.),@lRecalc,nColsSE2,aColTrbGen),oFolder:nOption,6),aColsSE2:=oCtaPag:aCols }	
	EndIf 	

EndIf

If lCalcula
	Eval(bRefresh)
EndIf

If lAuto103 .And. cTipo == "N" .And. SED->ED_CALCIRF == 'S' .And. (SA2->A2_TIPO == 'F' .Or. SA2->A2_IRPROG =='1')
	If MaFisFound("NF") .And. MaFisRet(,"NF_BASEDUP")<>0
		If nMoedaCor == 1
			nValor := NoRound(xMoeda(MaFisRet(,"NF_BASEDUP"),MaFisRet(,"NF_MOEDA"),nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")),2)
		Else
			nValor := Round(xMoeda(MaFisRet(,"NF_BASEDUP"),MaFisRet(,"NF_MOEDA"),nMoedaCor,dDEmissao,nDecTaxa,Nil,MaFisRet(,"NF_TXMOEDA")),2)
		EndIf
	
		nValIpi := Iif( nValor > 0, NoRound(xMoeda(MaFisRet(,"NF_VALIPI") ,MaFisRet(,"NF_MOEDA"),nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")),2), 0 )
		nValSol	:= Iif( nValor > 0, NoRound(xMoeda(MaFisRet(,"NF_VALSOL") ,MaFisRet(,"NF_MOEDA"),nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")),2), 0 )
		aVencto	:= Condicao(nValor,cCondicao,nValIpi,dDEmissao,nValSol)
		dVencReal:= aVencto[1][1]
		MaRecIR(dVencReal)
		nIrrf	:= MaFisRet(,"NF_VALIRR")
	EndIf	
EndIf

nTaxa:= nTaxaMoeda
RestArea(aArea)

Return oCtaPag

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeRatImp ³Autor  ³Alexandre Inacio Lemes ³ Data ³13/10/2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Faz o rateio dos impostos do folder de duplicatas pelo valor ³±±
±±³          ³das parcelas do titulo.                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA103                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NfeRatImp(oCtaPag,nMoedaCor,aColsSE2,aHeadSE2,aColTrbGen,nColsSE2)

Local aRateio   := {0,0,0,0,0,0,0}
Local aCols     := {}
Local aTribGen  := {}
Local nPValor   := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_VALOR"})
Local nPIRRF    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_IRRF"})
Local nPISS     := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_ISS"})
Local nPINSS    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_INSS"})
Local nPPIS     := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_PIS"})
Local nPCOFINS  := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_COFINS"})
Local nPCSLL    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_CSLL"})
Local nPSEST    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_SEST"})
Local nPosValTrb:= 0
Local nX        := 0
Local nZ        := 0
Local nValor    := 0
Local nIrrf		:= 0
Local nIss	    := 0
Local nInss	    := 0
Local nPis      := 0
Local nCofins   := 0
Local nCsll     := 0 
Local nSEST		:= 0
Local lISSNat	:= .T.
Local cNatNF	:= ""
Local lISSTes	:= SuperGetMv("MV_ISSRETD",.F.,.F.)
Local lTrbGen   := IIf(FindFunction("ChkTrbGen"),ChkTrbGen("SD1", "D1_IDTRIB"),.F.) // Verificacao se pode ou nao utilizar tributos genericos
Local cINSSAd	:= "0"

//Rateio do Impostos Financeiros
If MaFisFound("NF") .And. MaFisRet(,"NF_BASEDUP")<>0

	//Verifica se deve existir o calculo do ISS pela natureza do titulo
	cNatNF := MaFisRet(,"NF_NATUREZA")
	dbSelectArea("SED")
	If SED->(dbSeek(xFilial("SED")+cNatNF))
		lISSNat := SED->ED_CALCISS <> "N" .Or. lISSTes
	Endif            

	If Type("aBaseDup")=="U" .Or. aBaseDup==Nil
		aBaseDup := {MaFisRet(,"NF_BASEDUP"),0}
	EndIf
	
	cINSSAd	:=	MaFisScan("NF_VALINA",.F.)

	nValor  := NoRound(xMoeda(MaFisRet(,"NF_BASEDUP"),MaFisRet(,"NF_MOEDA"),nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")),2)
	nIrrf	:= MaFisRet(,"NF_VALIRR")
	nIss	:= IIf(MaFisRet(,"NF_RECISS")=="2".And.lISSNat,MaFisRet(,"NF_VALISS"),0)
	nInss   := MaFisRet(,"NF_VALINS")+Iif(cINSSAd<>"0",MaFisRet(,"NF_VALINA"),0)
	nPis    := MaFisRet(,"NF_VALPIS")
	nCofins := MaFisRet(,"NF_VALCOF")
	nCsll   := MaFisRet(,"NF_VALCSL")
	nSEST	:= MaFisRet(,"NF_VALSES")
	// Retorna valores calculados pelo motor de tributos genericos
	If lTrbGen .And. !Empty(cNatNF)
		aTribGen := MaFisRet(,"NF_TRIBGEN")
		For nZ := 1 To Len(aColTrbGen)
			aAdd(aRateio,0)
		Next nZ
	EndIf

	aCols := IIf(oCtaPag<>Nil,oCtaPag:aCols,aCols)
	
	For nX := 1 To Len(aCols)
		If nPIRRF <> 0
			aCols[nX][nPIRRF] := IIf(nX==Len(aCols),nIRRF-aRateio[1],NoRound(nIRRF*aCols[nX][nPValor]/nValor,2))
			aRateio[1] += aCols[nX][nPIRRF]
		EndIf
		If nPISS <> 0
			aCols[nX][nPISS] := IIf(nX==Len(aCols),nISS -aRateio[2],NoRound(nISS*aCols[nX][nPValor]/nValor,2))
			aRateio[2] += aCols[nX][nPISS]
		EndIf
		If nPINSS <> 0
			aCols[nX][nPINSS] := IIf(nX==Len(aCols),nINSS-aRateio[3],NoRound(nINSS*aCols[nX][nPValor]/nValor,2))
			aRateio[3] += aCols[nX][nPINSS]
		EndIf
		If nPPIS <> 0
			aCols[nX][nPPIS] := IIf(nX==Len(aCols),nPIS-aRateio[4],NoRound(nPIS*aCols[nX][nPValor]/nValor,2))
			aRateio[4] += aCols[nX][nPPIS]
		EndIf
		If nPCOFINS <> 0
			aCols[nX][nPCOFINS] := IIf(nX==Len(aCols),nCOFINS-aRateio[5],NoRound(nCOFINS*aCols[nX][nPValor]/nValor,2))
			aRateio[5] += aCols[nX][nPCOFINS]
		EndIf
		If nPCSLL <> 0
			aCols[nX][nPCSLL] := IIf(nX==Len(aCols),nCSLL-aRateio[6],NoRound(nCSLL*aCols[nX][nPValor]/nValor,2))
			aRateio[6] += aCols[nX][nPCSLL]
		EndIf
		If nPSEST <> 0
			aCols[nX][nPSEST] := IIf(nX==Len(aCols),nSEST-aRateio[7],NoRound(nSEST*aCols[nX][nPValor]/nValor,2))
			aRateio[7] += aCols[nX][nPSEST]
		EndIf		
		// Rateia os valores gerados pelo motor de tributos genericos
		For nZ := 1 To Len(aTribGen)
			If (nPosValTrb := aScan(aColTrbGen,{|x| x[1] == aTribGen[nZ][1]}) ) > 0
				aCols[nX][nColsSE2+nPosValTrb] := IIf(nX==Len(aCols),aTribGen[nZ][3]-aRateio[7+nPosValTrb],NoRound(aTribGen[nZ][3]*aCols[nX][nPValor]/nValor,2))
				aRateio[7+nPosValTrb] += aCols[nX][nColsSE2+nPosValTrb]
			EndIf
		Next nZ
	Next nX

	If oCtaPag<>Nil
		If !Empty(aCols)
			oCtaPag:aCols := aCols
		EndIf
		oCtaPag:nAt   := 1
		oCtaPag:Refresh()
	EndIf
			
EndIf

Return( .T. ) 

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeMultNat³Autor  ³Alexandre Inacio Lemes ³ Data ³05/07/2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Rotina de recalculo do valor rateado em multiplas Naturezas. ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA103                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Static Function NfeMultNat(oMultNat,aColsSE2,aHeadSE2,aColsSEV,aHeadSEV)

Local nPValSEV  := aScan(aHeadSEV,{|x| AllTrim(x[2])=="EV_VALPERC"})
Local nPercSEV  := aScan(aHeadSEV,{|x| AllTrim(x[2])=="EV_PERC"})
Local nPValor   := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_VALOR"})
Local nPIRRF    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_IRRF"})
Local nPISS     := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_ISS"})
Local nPINSS    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_INSS"})
Local nPPIS     := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_PIS"})
Local nPCOFINS  := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_COFINS"})
Local nPCSLL    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_CSLL"})
Local nValor    := 0 
Local nValISS   := 0
Local nValIRRF  := 0
Local nValINSS  := 0
Local nValPIS   := 0
Local nValCOF   := 0
Local nValCSLL  := 0
Local nY        := 0
Local nValFun   := 0
Local nMultDec  := GetNewPar( "MV_MULTDEC", 2 ) 
Local nValFet   := Iif( MaFisFound("NF") , MaFisRet(,"NF_VALFET") , 0 )
Local lMT103SEV := ExistBlock("MT103SEV")

If MaFisFound("NF")
	nValFun := MaFisRet(,"NF_FUNRURAL")
EndIf

//Utilizado para manipular naturezas
If oMultNat<>Nil
	If lMT103SEV
		aColsSEV := ExecBlock("MT103SEV",.F.,.F.,{aHeadSEV,aColsSEV})
		If !Empty(aColsSEV)
			oMultNat:aCols := aClone(aColsSEV)
		EndIf
		oMultNat:Refresh()
	Endif
EndIf

//Verifica se ha necessidade da gravacao das multiplas naturezas
If nPValSEV > 0

	If oMultNat<>Nil
	   aColsSEV := aClone(oMultNat:aCols)
	EndIf

	aEval(aColsSE2,{|x| nValor   += x[nPValor] })
	aEval(aColsSE2,{|x| nValISS  += x[nPISS]   })
	aEval(aColsSE2,{|x| nValIRRF += x[nPIRRF]  })
	aEval(aColsSE2,{|x| nValINSS += x[nPINSS]  })
	aEval(aColsSE2,{|x| nValPIS  += x[nPPIS]   })
	aEval(aColsSE2,{|x| nValCOF  += x[nPCOFINS]})
	aEval(aColsSE2,{|x| nValCSLL += x[nPCSLL]  })

    nValor := nValor-nValISS-nValIRRF-nValINSS-nValPIS-nValCOF-nValCSLL
	
	nRateio := 0
	For nY := 1 To Len(aColsSEV)
		If !aColsSEV[nY][Len(aColsSEV[1])] .And. !Empty(aColsSEV[nY][1])
			aColsSEV[nY][nPValSEV] := IIf(nY==Len(aColsSEV),nValor-nValFun-nValFet-nRateio,NoRound(nValor*aColsSEV[nY][nPercSEV]/100,nMultDec))
			nRateio += aColsSEV[nY][nPValSEV]
		EndIf
	Next nY
	
	If oMultNat<>Nil
		If !Empty(aColsSEV)
			oMultNat:aCols := aClone(aColsSEV)
		EndIf
		oMultNat:Refresh()
	EndIf
EndIf

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeRFldFin³Autor  ³ Eduardo Riera         ³ Data ³12.12.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao dos dados do folder financeiro do      ³±±
±±³          ³documento de entrada                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Condicao de Pagamento                                 ³±±
±±³          ³ExpC2: Descricao da condicao de pagamento                    ³±±
±±³          ³ExpC3: Natureza                                              ³±±
±±³          ³ExpN4: Codigo da Moeda                                       ³±±
±±³          ³ExpN5: Taxa da moeda                                         ³±±
±±³          ³ExpO6: Objeto da condicao de pagamento                       ³±±
±±³          ³ExpO7: Objeto da natureza                                    ³±±
±±³          ³ExpO8: Objeto da Moeda                                       ³±±
±±³          ³ExpO9: Objeto da taxa da moeda                               ³±±
±±³          ³ExpOA: Objeto da descricao da moeda                          ³±±
±±³          ³ExpOB: Objeto da getdados do titulos financeiros             ³±±
±±³          ³ExpLC: Indica se a rotina esta em modo de inclusao           ³±±
±±³          ³ExpAD: ACols com as parcelas dos titulos financeiros         ³±±
±±³          ³ExpAE: AHeader das parcelas dos titulos financeiros          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar os dados do folder   ³±±
±±³          ³financeiro do documento de entrada                           ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NfeRFldFin(cCondicao,cDescricao,cNatureza,nMoeda,nTaxa,oCondicao,oNatureza,oMoeda,oTaxa,oDscMoeda,oCtaPag,oMultNat,lInclui,aColsSE2,aHeadSE2,aColsSEV,aHeadSEV,oDescri,oTxNeg,cLimRec,lRecalc,nValDupAnt,aColTrbGen,aParcTrGen,nColsSE2,cIdsTrGen)

Local nValor    := 0
Local nValIpi	:= 0
Local nValSol	:= 0
Local nTotDup   := 0
Local nTotIRF   := 0
Local nTotINSS  := 0
Local nTotISS   := 0
Local nTotPIS   := 0
Local nTotCOF   := 0
Local nTotCSLL  := 0
Local nTotSEST	:= 0
Local nTotFet	:= 0
Local nTotFab	:= 0
Local nTotFac   := 0
Local nTotIMA   := 0
Local nTotFAM   := 0
Local nTotBTISS	:= 0
Local nTribGen  := 0
Local nTotTrbGen:= 0
Local nX        := 0
Local nY        := 0
Local nZ        := 0
Local nPParcela := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_PARCELA"})
Local nPVencto  := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_VENCTO"})
Local nPValor   := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_VALOR"})
Local nPIRRF    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_IRRF"})
Local nPISS     := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_ISS"})
Local nPINSS    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_INSS"})
Local nPPIS     := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_PIS"})
Local nPCOFINS  := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_COFINS"})
Local nPCSLL    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_CSLL"})
Local nPValSEV  := aScan(aHeadSEV,{|x| AllTrim(x[2])=="EV_VALPERC"})
Local nPercSEV  := aScan(aHeadSEV,{|x| AllTrim(x[2])=="EV_PERC"})
Local nPSEST    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_SEST"})
Local nPFETHAB  := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_FETHAB"})
Local nPFABOV 	:= aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_FABOV"})
Local nPFACS  	:= aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_FACS"})
Local nPIMA  	:= aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_IMA"})
Local nPFAMAD  	:= aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_FAMAD"})
Local nPBTISS  	:= aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_BTRISS"})
Local nValSEV   := 0
Local nValFun   := 0
Local nValFet   := 0
Local nValFab   := 0
Local nValFac	:= 0
Local nValIMA	:= 0
Local nValFAMAD := 0
Local nIrrf		:= 0
Local nInss	    := 0
Local nIss	    := 0
Local nPis      := 0
Local nCofins   := 0
Local nCsll     := 0
Local nSEST		:= 0
Local nValBTISS	:= 0
Local nUsadoSE2 := Len(aHeadSE2)
Local nMultDec  := GetNewPar( "MV_MULTDEC", 2 ) 
Local nTamParc  := TamSx3("E2_PARCELA")[1]
Local nDecTaxa  := TamSX3("F1_TXMOEDA")[2]
Local nPosNfOri := 0
Local nPosSerOri:= 0
Local nPosVec    := aScan(aHeadSE2, { |x| AllTrim(x[01]) == AllTrim(Posicione('SX3',2,'E2_VENCTO','SX3->X3_TITULO'))})
Local nPosValTrb:= 0
Local cNfOri	:= ""
Local cSerOri	:= ""
Local aColsTit	:= IIF(Type('lMoedTit')=='L' .And. lMoedTit,Iif(ValType(aCols)=="A",aClone(aCols),Iif(ValType(aColsNF)=="A",aClone(aColsNF),{})),{})
Local dDataTit	:= dDEmissao
Local cAliasBkp	:= ""
Local aD1Bkp	:= aClone(aCols)
Local aCols     := {}
Local aColsDup  := {}
Local aColsPE   := {}
Local aVencto   := {}
Local a103Cnd2  := {}
Local aRateio   := {0,0,0,0,0,0,0,0}
Local cParcela  := SuperGetMV("MV_1DUP") 
Local aRatBasTG := {}
Local aTribGen  := {}
Local cMT103NTZ
Local lVencto   := .F.
Local cCampo    := ReadVar()
Local cMoeda    := "" 
Local lMT103GET  := Existblock("MT103GET")
Local lMT103TXPC:= ExistBlock("MT103TXPC")
Local lRatIRRF	:= SuperGetMV("MV_RATIRRF",.F.,.T.)
Local lRatISS	:= SuperGetMV("MV_RATISS",.F.,.T.)
Local lRatINSS	:= SuperGetMV("MV_RATINSS",.F.,.T.)
Local lRatSEST	:= SuperGetMV("MV_RATSEST",.F.,.T.)
Local lRatPIS	:= SuperGetMV("MV_RATPIS",.F.,.T.) 
Local lRatCOFINS:= SuperGetMV("MV_RATCOF",.F.,.T.)  
Local lRatCSLL	:= SuperGetMV("MV_RATCSLL",.F.,.T.) 
Local lISSNat	:= .T.
Local lISSTes	:= SuperGetMv("MV_ISSRETD",.F.,.F.)
Local lChkDup	:= .F.
Local lDupNew   := .F.
Local lTrbGen   := IIf(FindFunction("ChkTrbGen"),ChkTrbGen("SD1", "D1_IDTRIB"),.F.) .And. FindFunction("FinParcFKK") .And. FindFunction("A103TrbGen") .And. FindFunction("A103AtuTrG") // Verificacao se pode ou nao utilizar tributos genericos
Local cINSSAd	:= "0"
Local bCondLim  := { || .T. }
Local aDadosPC := {}
Local nTotNF	:= 0
Local nI		:= 0
Local nTotRDF	:= 0
LOCAL lExcRetorno := .F.
Local lAv1DUPNAT  := .F.
Local lMTCOLSE2	  := ExistBlock("MTCOLSE2")
Local lA103VLR	 := ExistBlock("A103VLR")
Local lMVNFENAT	:= SuperGetMV("MV_NFENAT",.F.,.F.)
Local c1DUPNAT	:= SuperGetMV("MV_1DUPNAT",.F.,"")
Local c2DUPNAT	:= SuperGetMV("MV_2DUPNAT",.F.,"")
Local lMT103NTZ	:= ExistBlock("MT103NTZ")
Local cTXMOENC	:= SuperGetMv("MV_TXMOENC",.F.,"1")
Local lA103VCTO	:= ExistBlock("A103VCTO")
Local nLIMPAG	:= SuperGetMV("MV_LIMPAG")
Local lA103CND2	:= ExistBlock("A103CND2")
Local c1DUPREF	:= SuperGetMV("MV_1DUPREF")
Local lA1031DUP	:= ExistBlock("A1031DUP")
Local lMT103DUP	:= ExistBlock("MT103DUP")
Local nD1Tes	:= 0
Local nD1Ret	:= 0
Local nD1Ded	:= 0
Local nD1Fat	:= 0
Local nD1Tot	:= 0
Local nE2Vlr	:= 0
Local cNatBloq	:= ""

DEFAULT cNatureza  := CriaVar("E2_NATUREZ",.F.)
DEFAULT lInclui    := .F.
DEFAULT cLimRec    := "1"
DEFAULT lRecalc    := .T.
DEFAULT nValDupAnt := 0
DEFAULT aColTrbGen := {}
DEFAULT aParcTrGen := {}
DEFAULT nColsSE2   := 0
DEFAULT cIdsTrGen	:= ""

 If Type('l103Auto')=='U'
	Private l103Auto  := .F.
Endif

//Atualiza o array aColsNF
aColsNF:= {}

//Obtem a natureza do cadastro de fornecedores
If lInclui
	//Ponto de entrada para alterar valor da Duplicata
	If lA103VLR .And. MaFisFound("NF")
		nValor := ExecBlock("A103VLR",.F.,.F.)
		If nValor <> MaFisRet(,"NF_BASEDUP")
			MaFisAlt("NF_BASEDUP",nValor) 
		EndIf
	EndIf
	
	If MaFisFound("NF")
		If Type("lTOPDRFRM") <> "U" .And. lTOPDRFRM .And. ValType(aD1Bkp) == "A" .And. Len(aD1Bkp) > 0
			nTotNF	:= 0

			cAliasBkp := aD1Bkp[1,Len(aD1Bkp[1])-2]

			If cAliasBkp == "SD1"
				nD1Tes	:= GdFieldPos("D1_TES",aHeadD1)
				nD1Ret	:= GdFieldPos("D1_RETENCA",aHeadD1)
				nD1Ded	:= GdFieldPos("D1_DEDUCAO",aHeadD1)
				nD1Fat	:= GdFieldPos("D1_FATDIRE",aHeadD1)
				nD1Tot	:= GdFieldPos("D1_TOTAL",aHeadD1)

				If nD1Tes > 0 .And. nD1Ret > 0 .And. nD1Ded > 0 .And. nD1Fat > 0
					For nI := 1 To Len(aD1Bkp)
						If !aD1Bkp[nI,Len(aHeadD1)+1]
							If GetAdvFval("SF4","F4_DUPLIC",xFilial("SF4") + aD1Bkp[nI,nD1Tes],1) == "S"
								nTotNF += MaFisRet(nI,"IT_TOTAL")

								nTotRDF += aD1Bkp[nI,nD1Ret]
								nTotRDF += aD1Bkp[nI,nD1Ded]
								nTotRDF += aD1Bkp[nI,nD1Fat]
							Endif
						Endif
					Next nI
				Endif
			Elseif cAliasBkp == "SE2"
				nE2Vlr	:= GdFieldPos("E2_VALOR",aHeader)

				If nE2Vlr > 0
					For nI := 1 To Len(aD1Bkp)
						If !aD1Bkp[nI,Len(aHeader)+1]
							nTotNF += aD1Bkp[nI,nE2Vlr]
						Endif
					Next nI
				Endif
				nTotNF := xMoeda(nTotNF,nMoeda,MaFisRet(,"NF_MOEDA"),dDEmissao,Nil,MaFisRet(,"NF_TXMOEDA"),Nil)
			Endif
			
			nTotNF := nTotNF - nTotRDF
			If nTotNF > 0 .And. nTotNF <> 0
				MaFisRet(,"NF_BASEDUP")
				MaFisAlt("NF_BASEDUP",nTotNF)
			EndIf
		Endif

		//Verifica se deve existir o calculo do ISS pela natureza do titulo
		dbSelectArea("SED")
		If SED->(dbSeek(xFilial("SED")+cNatureza))
			lISSNat := SED->ED_CALCISS <> "N" .Or. lISSTes
		Endif            

		If Empty(cNatureza)
			If cTipo$'DB'
				lAv1DUPNAT := .T.
			EndIf
			
			//Correção posicionamento SC5
			If lMVNFENAT .And. "C5_NATUREZ" $ c1DUPNAT
				aAreaSD2x := SD2->(GetArea())
				nPosNfOri := aScan(aHeader,{|x| AllTrim(x[2]) == "D1_NFORI"} )
				If Type("aColSD1") == "A" .And. Len(aColSD1) > 0 .And. nPosNfOri > 0
					If !Empty(aColSD1[1][nPosNfOri])
						nPosSerOri := aScan(aHeader,{|x| AllTrim(x[2]) == "D1_SERIORI"} )
						SD2->(DbSetOrder(3))
						SD2->(DbGoTop())
						If  nPosSerOri > 0 .And. SD2->(DbSeek(xFilial("SD2")+aColSD1[1][nPosNfOri]+aColSD1[1][nPosSerOri]+cA100For+cLoja))
							DbSelectArea("SC5")
							SC5->(DbSetOrder(3))
							If SC5->(DbSeek(xFilial("SC5")+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_PEDIDO))
								If cTipo == "N" .And. SC5->C5_TIPO == "B"	//Retorno de Beneficiamento
									lAv1DUPNAT := .T.
									lExcRetorno	:= .T.
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
				RestArea(aAreaSD2x)
			EndIf
			
			//Utiliza MacroSubstituição referente MV_1DUPNAT por se tratar de
			//Devolução OU Beneficiamento OU NF de Retorno referente SAÍDA de Beneficiamento
			If lAv1DUPNAT
				cNatureza := &(c1DUPNAT)
				
				//lExcRetorno = .T., NF do Tipo Normal, executa MacroSubstituição
				//da MV_2DUPNAT - Relacionado a Entrada - Fornecedor
				If Empty(cNatureza) .AND. lExcRetorno
					cNatureza := &(c2DUPNAT)
				EndIf
				
				If !Empty(cNatureza)
					MaFisAlt("NF_NATUREZA",cNatureza)
				EndIf
			Else
				cNatureza := &(c2DUPNAT)
				If !Empty(cNatureza)
					MaFisAlt("NF_NATUREZA",cNatureza)
				EndIf
			EndIf
		Else
			cNatureza := MaFisRet(,"NF_NATUREZA")
		EndIf

		If !Empty(cNatureza)
			cNatBloq := GetAdvFval("SED","ED_MSBLQL", fwxFilial("SED") + cNatureza,1)
			If cNatBloq == "1" //Registro bloqueado
				cNatureza	:= CriaVar("E2_NATUREZ",.F.)
				MaFisAlt("NF_NATUREZA",cNatureza)
			Endif
		Endif

		If SED->ED_CALCIRF=='N'
			nCombo	:= 2
			cCodRet := ''
		EndIf		

		//Ponto de Entrada para selecionar a natureza no Documento de Entrada
		If lMT103NTZ
			cMT103NTZ  := ExecBlock("MT103NTZ",.F.,.F.,{cNatureza})    
			If ( ValType(cMT103NTZ ) == 'C' )
			  	dbSelectArea("SED")
				If SED->(dbSeek(xFilial("SED")+cMT103NTZ)) 
					cNatureza := cMT103NTZ
					MaFisAlt("NF_NATUREZA",cNatureza)
				EndIf
			EndIf
		EndIf      
	EndIf
	
	//Atualiza a descricao da condicao de pagamento
	If !Empty(cCondicao) 
		dbSelectArea("SE4")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SE4")+cCondicao) )
			cDescricao	:= SE4->E4_DESCRI
	EndIf
			Else
		cDescricao := " "

	EndIf
	
	//Verifica parâmetro MV_MOEDTIT para gerar devolução NCC na mesma moeda e taxa do título original
	If Type('lMoedTit')=='L' .And. lMoedTit .And. cTipo == "D" .And. cTXMOENC == "1"
		nPosNfOri := aScan(aHeader,{|x| AllTrim(x[2]) == "D1_NFORI"} )
		nPosSerOri:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_SERIORI"} )
		
		If len(aColsTit)>=1 .And. nPosNfOri > 0
			If len(aColsTit[1]) >= nPosNfOri
				cNfOri := aColsTit[1][nPosNfOri]
			EndIf
		EndIf

		If len(aColsTit)>=1 .And. nPosSerOri > 0
			If len(aColsTit[1]) >= nPosSerOri
				cSerOri := aColsTit[1][nPosSerOri]
			EndIf
		EndIf

		IF !Empty(cNfOri)

			DbSelectArea("SF2")
			DbSetOrder(1)
			If MsSeek(xFilial("SF2") + cNfOri + cSerOri)
				cSerOri := IIf(Empty(SF2->F2_PREFIXO),&(c1DUPREF),SF2->F2_PREFIXO)
				cSerOri := PadR( cSerOri, Len( SE1->E1_PREFIXO ) )
		    EndIf
		    
			DbSelectArea("SE1")
			DbSetOrder(2)
            cSerOri := Substr(cSerOri,1,3)
			MsSeek(xFilial("SE1")+cA100For+cLoja+cSerOri+cNfOri)
			While !Eof() .And. xFilial("SE1") == SE1->E1_FILIAL .And.;
					cA100For == SE1->E1_CLIENTE .And.;
					cLoja	 == SE1->E1_LOJA    .And.;
					cSerOri	 == SE1->E1_PREFIXO .And.;
					cNfOri	 == SE1->E1_NUM
				If SE1->E1_TIPO == "NF " .And. SE1->E1_MOEDA > 0 .And. SE1->E1_EMISSAO <> CTOD('  /  /  ')
					nMoedaCor := SE1->E1_MOEDA
					nMoeda	  := nMoedaCor
					If !Empty(SF2->F2_DTTXREF)
						dDataTit := SF2->F2_DTTXREF
					Else
						dDataTit := SE1->E1_EMISSAO
						lBlqTxNeg:= .F.
						nValFat  := SF2->F2_VALFAT
					EndIf
					nTaxa	  := 0
					Exit
				Endif
				SE1->(dbSkip())
			EndDo
		EndIf
	EndIf
	
	//Atualiza a taxa da Moeda
	cMoeda := SuperGetMv("MV_MOEDA"+AllTrim(Str(nMoeda,2)))
	If nMoeda <> 1
		If !"NTAXA"$Upper(cCampo) 
		    If ( l103Auto .Or. lMT103TXPC ) .And. nTaxa <> 0
		        MaFisAlt("NF_TXMOEDA",nTaxa)  
			EndIf
		    If (nTaxa == 0 .And. L103Auto) .Or. (!L103Auto)
				nTaxa := MaFisRet(,"NF_TXMOEDA")
			EndIf
			If nTaxa == 0
				nTaxa := RecMoeda(ddatabase,nMoeda)
				nTaxa := xMoeda(1,nMoeda,MaFisRet(,"NF_MOEDA"),IIF(Type('lMoedTit')=='L' .And. lMoedTit,dDataTit,dDEmissao),nDecTaxa)
				MaFisAlt("NF_TXMOEDA",nTaxa)
			Else
				If ("NMOEDA"$Upper(cCampo))
					nTaxa := RecMoeda(dDEmissao,nMoeda)
					MaFisAlt("NF_TXMOEDA",nTaxa)
			 	EndIf
			EndIf
		Else
			MaFisAlt("NF_TXMOEDA",nTaxa)
		EndIf
	Else
		nTaxa := 0
		nTaxa := RecMoeda(ddatabase,nMoeda)
		MaFisAlt("NF_TXMOEDA",nTaxa)
	EndIf
	
	cINSSAd	:=	MaFisScan("NF_VALINA",.F.)
	
	//Atualiza a getdados dos titulos financeiros
	If !Empty(cCondicao) .And. MaFisFound("NF") .And. MaFisRet(,"NF_BASEDUP")<>0
		If nMoeda == 1
			nValor := NoRound(xMoeda(MaFisRet(,"NF_BASEDUP"),MaFisRet(,"NF_MOEDA"),nMoeda,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")),2)
		Else
			nValor := Round(xMoeda(MaFisRet(,"NF_BASEDUP"),MaFisRet(,"NF_MOEDA"),nMoeda,dDEmissao,nDecTaxa,Nil,MaFisRet(,"NF_TXMOEDA")),2)
		EndIf
		
		If Type("aBaseDup")=="U" .Or. aBaseDup==Nil
			aBaseDup := {MaFisRet(,"NF_BASEDUP"),0}
		EndIf
		
		nValFun := MaFisRet(,"NF_FUNRURAL")
		nValFet := IIf(MaFisRet(,"NF_RECFET")=="2",MaFisRet(,"NF_VALFET"),0) 		 
		nValFab := IIf(MaFisRet(,"NF_RECFAB")=="2",MaFisRet(,"NF_VALFAB"),0)				
		nValFac := IIf(MaFisRet(,"NF_RECFAC")=="2",MaFisRet(,"NF_VALFAC"),0)
		nValIMA := IIf(MaFisRet(,"NF_RECIMA")=="2",MaFisRet(,"NF_VALIMA"),0)
		nValFAMAD := IIf(MaFisRet(,"NF_RECFMD")=="2",MaFisRet(,"NF_VALFMD"),0)		
		nIrrf	:= MaFisRet(,"NF_VALIRR")
		nInss   := MaFisRet(,"NF_VALINS")+Iif(cINSSAd<>"0",MaFisRet(,"NF_VALINA"),0)
		nIss	:= IIf(MaFisRet(,"NF_RECISS")=="2".And.lISSNat,MaFisRet(,"NF_VALISS"),0)
		nPis    := MaFisRet(,"NF_VALPIS")
		nCOFINS := MaFisRet(,"NF_VALCOF")
		nCSLL   := MaFisRet(,"NF_VALCSL")		
		nSEST	:= MaFisRet(,"NF_VALSES")
		nValBTISS := MaFisRet(,"NF_VALCPM")
		nValIpi := Iif( nValor > 0, NoRound(xMoeda(MaFisRet(,"NF_VALIPI") ,MaFisRet(,"NF_MOEDA"),nMoeda,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")),2), 0 )
		nValSol	:= Iif( nValor > 0, NoRound(xMoeda(MaFisRet(,"NF_VALSOL") ,MaFisRet(,"NF_MOEDA"),nMoeda,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")),2), 0 )
		If lTrbGen	// Verifica se o sistema esta preparado para utilizar o motor de tributos genericos
			aTribGen := MaFisRet(,"NF_TRIBGEN")	// Retorna os valores calculados pelo motor
		EndIf
		aVencto	:= Condicao(nValor,cCondicao,nValIpi,dDEmissao,nValSol)

		//Quando altero a data de vencimento do titulo, atualiza o array de duplicatas
		If cCampo == "M->E2_VENCTO" .And. ValType(aVencto) == "A"
		  // Caso algumas das parcelas esta com a data diferente permanece a data Digitada. 
			If Len(aVencto) == Len(aColsSe2) 
				For nX := 1 To Len (aVencto) 
					If aVencto[nX][1] <> aColsSe2[nX][nPosVec] .And. CTOD('  /  /  ') <> aColsSe2[nX][nPosVec]
						aVencto[1][1] := aColsSe2[nX][nPosVec]
					EndIf
				Next nX
			Else	 
				aVencto[1][1] := M->E2_VENCTO
			EndIf	

		ElseIf cCampo!="CCONDICAO" .And. Type('dNewVenc')=='D' .And. dNewVenc != CTOD('  /  /  ') .And. len(aVencto) > 0 .And. cCampo!="DDEMISSAO"
			aVencto[1][1] := dNewVenc
		ElseIf cCampo=="CCONDICAO" .And. Type('dNewVenc')=='D' .And. dNewVenc != CTOD('  /  /  ')
			dNewVenc := aVencto[1][1]
		EndIf

		If lA103VCTO
        	aDadosPC:=ExecBlock("A103VCTO",.F.,.F.,{ aClone(aColsSE2),nValor,cCondicao,nValIpi,dDEmissao,nValSol})
        	If ValType(aDadosPC) == "A"
        		If Len(aDadosPC) >= 1
        			If Len(aDadosPc[1])>= 2
        				aVencto := aClone(aDadosPC)
        			EndIf
        		EndIf
        	EndIf
  		EndIf

		nTotDup := 0
		aCols := IIf(oCtaPag<>Nil,oCtaPag:aCols,aCols)
		If Len(aCols)>0
			If aCols[nPParcela][nPValor]<>nValor .And. Len(aVencto) == 1   
				If cLimRec == "1" 
					If Abs(aCols[nPParcela][nPValor]-nValor)>=nLIMPAG .Or. nValor != nValDupAnt
					    aCols[nPParcela][nPValor]:= nValor 
					EndIf
				ElseIf cLimRec == "2"
					If Abs(aCols[nPParcela][nPValor]-nValor)>nLIMPAG .Or. nValor != nValDupAnt
						aCols[nPParcela][nPValor]:= nValor 
					EndIF
				ElseIf cLimRec == "3"
					If lRecalc .Or. nValor != nValDupAnt
						If Abs(aCols[nPParcela][nPValor]-nValor)>=nLIMPAG
						    aCols[nPParcela][nPValor]:= nValor
						EndIf
					EndIf
				EndIF
				If cCampo == "CCONDICAO" .Or. Empty(aCols[nPParcela][nPVencto]) .Or. aCols[nPParcela][nPVencto] == dDataBase .Or. aCols[nPParcela][nPVencto] == aColsSE2[nPParcela][nPVencto]
			    	aCols[nPParcela][nPVencto]:=aVencto[1][1]
			    EndIf
			EndIf
        EndIf
		aEval(aCols,{|x| nTotDup+= x[nPValor] })
		If nPIRRF <> 0
			aEval(aCols,{|x| nTotIRF+= x[nPIRRF] })
		EndIf
		If nPINSS <> 0
			aEval(aCols,{|x| nTotINSS+= x[nPINSS] })
		EndIf
		If nPISS <> 0
			aEval(aCols,{|x| nTotISS+= x[nPISS] })
		EndIf
		If nPPIS <> 0
			aEval(aCols,{|x| nTotPis+= x[nPPIS] })
		EndIf
		If nPCOFINS <> 0
			aEval(aCols,{|x| nTotCof+= x[nPCOFINS] })
		EndIf
		If nPCSLL <> 0
			aEval(aCols,{|x| nTotCsll+= x[nPCSLL] })
		EndIf
		If nPSEST <> 0
			aEval(aCols,{|x| nTotSEST+= x[nPSEST] })
		EndIf
		If nPFETHAB <> 0
			aEval(aCols,{|x| nTotFET+= x[nPFETHAB] })
		EndIf		
		If nPFABOV <> 0
			aEval(aCols,{|x| nTotFAB+= x[nPFABOV] })
		EndIf		
		If nPFACS <> 0
			aEval(aCols,{|x| nTotFAC+= x[nPFACS] })
		EndIf
		If nPIMA <> 0
			aEval(aCols,{|x| nTotIMA+= x[nPIMA] })
		EndIf
		If nPFAMAD <> 0
			aEval(aCols,{|x| nTotFAM+= x[nPFAMAD] })
		EndIf
		If nPBTISS <> 0
			aEval(aCols,{|x| nTotBTISS+= x[nPBTISS] })
		EndIf
		If lTrbGen
			For nZ := 1 To Len(aTribGen)
				If (nPosValTrb := aScan(aColTrbGen,{|x| x[1] == aTribGen[nZ][1]}) ) > 0	// Encontra a coluna da duplicata referente ao tributo generico
					nTribGen += aTribGen[nZ][3]											// Guarda o valor total de tributos genericos passiveis de rentecao
					aEval(aCols,{|x| nTotTrbGen += x[nColsSE2+nPosValTrb] })			// Guarda o valot total dos tributos que constam no aCols de Duplicatas
				EndIf
			Next nZ
		EndIf
		//Quando altero a condicao de pagamento ou data de vencimento recalculo o Valor do IRR
		If Type('dDVencAnt')=='U'
			PRIVATE dDVencAnt := IIf(len(aVencto) > 0,aVencto[1][1],stod("")) 
		Endif 
		If nIrrf > 0
			If cCampo=="CCONDICAO" .And. (Empty(cCondicaoOld) .Or. cCondicao<>cCondicaoOld)
	       		dVencReal:= aVencto[1][1]
				MaRecIR(dVencReal)
				nIrrf	:= MaFisRet(,"NF_VALIRR")
			ElseIf (cCampo == "M->E2_VENCTO" .And. dDVencAnt <> &(cCampo) )
				dVencReal:= &(cCampo)
				MaRecIR(dVencReal)
				nIrrf	:= MaFisRet(,"NF_VALIRR")
			ElseIf cCampo == "CNATUREZA" .and. ValType(aVencto[1][1]) == "D"
				dVencReal:= aVencto[1][1]
				MaRecIR(dVencReal)
				nIrrf	:= MaFisRet(,"NF_VALIRR")		
			EndIf
		EndIf		
			
		lVencto := .T.                                                      
		//Checa os Vencimentos aCols X Vencimentos Calculados quando ocorrer alteração nos
		//campos Data de Emissão, Condição de Pagamento e Cod.Fornecedor.
		//Quando algum destes campos mudar de conteúdo e o valor anterior for diferente do
		//valor atual, a rotina será executada e a variável que armazena o valor anterior
		//será atualizada.
 		If ((cCampo == "DDEMISSAO" .And. iif(Empty(dEmisOld),.T.,dMudaEmi<>dEmisOld)) .OR. (cCampo == "CCONDICAO" .And. (Empty(cCondicaoOld) .Or. cCondicao<>cCondicaoOld)) .Or. (cCampo == "CA100FOR" .And. (Empty(cCa100ForOLD) .Or. Ca100For<>cCa100ForOLD)) ) .Or. lA103VCTO
			For nX := 1 To Len(aVencto)
				If aScan(aCols,{|x| x[nPVencto]==aVencto[nX][1]})==0
					lVencto := .F.
				EndIf
			Next nX    
			//Atualiza a variável xOld com o conteúdo atual do Cabeçalho da NFE
			If (cCampo == "DDEMISSAO" .And. iif(Empty(dEmisOld),.T.,dMudaEmi<>dEmisOld))
			    dEmisOld := dMudaEmi
			ElseIf (cCampo == "CA100FOR" .And. (Empty(cCa100ForOLD) .Or. cCa100ForOLD<>cA100For))
			    cCa100ForOLD := cA100For 
			ElseIf (cCampo == "CCONDICAO" .And. (Empty(cCondicaoOld) .Or. cCondicaoOLD<>cCondicao))
			    cCondicaoOLD := cCondicao
			EndIF
		EndIf		     
		
		//Verifica se o recalculo deve ser efetuado mesmo se o valor total for igual ao permitido
		If cLimRec == "1"
			//Esta e a situacao "default", ou seja, mesmo que o valor principal esteja igual, recalcula
			//Eh mantida assim em respeito ao legado do sistema			
			bCondLim := { || Abs(nValor-nTotDup)>=nLIMPAG }
		ElseIf cLimRec == "2" 			
			bCondLim := { || Abs(nValor-nTotDup)>nLIMPAG }
		ElseIf cLimRec == "3"
			bCondLim := {|| .F.}
		EndIf	 
		
		If ( Eval( bCondLim ) .Or. nValor == 0 .Or. nTotDup == 0 .Or.;
			MaFisRet(,"NF_VALIRR")<>nTotIRF  .Or.;
			(MaFisRet(,"NF_VALINS")+Iif(cINSSAd<>"0",MaFisRet(,"NF_VALINA"),0))<>nTotINSS .Or.;
			IIf(MaFisRet(,"NF_RECISS")=="2".And.lISSNat,MaFisRet(,"NF_VALISS"),0)<>nTotISS .Or.;
			MaFisRet(,"NF_VALPIS")<>nTotPIS .Or.;
			MaFisRet(,"NF_VALCOF")<>nTotCOF .Or.;
			MaFisRet(,"NF_VALCSL")<>nTotCSLL .Or.;
			MaFisRet(,"NF_VALSES")<>nTotSEST .Or.;
			IIf(MaFisRet(,"NF_RECFET")=="2",MaFisRet(,"NF_VALFET"),0)<>nTotFet .Or.;
			IIf(MaFisRet(,"NF_RECFAB")=="2",MaFisRet(,"NF_VALFAB"),0)<>nTotFab .Or.;
			IIf(MaFisRet(,"NF_RECFAC")=="2",MaFisRet(,"NF_VALFAC"),0)<>nTotFac .Or.;
			IIf(MaFisRet(,"NF_RECIMA")=="2",MaFisRet(,"NF_VALIMA"),0)<>nTotIMA .Or.;
			IIf(MaFisRet(,"NF_RECFMD")=="2",MaFisRet(,"NF_VALFMD"),0)<>nTotFAM .Or.;
			MaFisRet(,"NF_VALCPM")<>nTotBTISS .Or.;
			Len(aVencto) <> Len(aCols) .Or.; 
			!lVencto .Or.;
			(nTribGen<>nTotTrbGen .And. !Empty(cNatureza)) .Or.;
			(Type("lAtuDupPC") == "L" .And. lAtuDupPC .And. !Empty(cCondicao))) .And.;
			IIf(cLimRec == "3",(lRecalc .Or. nValor != nValDupAnt),.T.)  
			
			//Ponto de entrada para alterar condicao de pagamento
			If lA103CND2
				a103Cnd2 := Aclone(aVencto)
				nTotDup := 0
				
				//Ajusta a quebra das parcelas para passar ao ponto de entrada
				For nX := 1 To Len(a103Cnd2)
					a103Cnd2[nX][2] := NoRound(a103Cnd2[nX][2],2)
					If nX <> Len(a103Cnd2)
						nTotDup += a103Cnd2[nx][2]
					Else
						a103Cnd2[nX][2]   := nValor-nTotDup
					EndIf
				Next nX

				a103Cnd2 := ExecBlock("A103CND2",.F.,.F.,a103Cnd2)
				If Valtype(a103Cnd2)=="A"
					aVencto := Aclone(a103Cnd2)
				EndIf
				nValor := 0
				For nX := 1 To Len(aVencto)
					nValor += aVencto[nX][2]
				Next nX
			EndIf
			
			//Montagem do acols das parcelas do titulo financeiro
			nTotDup := 0   
			aColsDup:=aclone(aCols)
			aCols := {}
	        cParcela:= IIF(Len(aVencto)>1,cParcela," ")
			
			If !l103Auto .And. lA1031DUP
				lChkDup:= ExecBlock("A1031DUP",.F.,.F.)
				If ValType(lChkDup) <> "L"
					lChkDup:= .F.
				EndIf
			EndIf
			
        	//Consiste tamanho do campo de parcelas e parametro MV_1DUP
			If !l103Auto .And. lChkDup
				If ( Len(aVencto) > 1 ) .And. ( nTamParc <> Len(cParcela) )
					Help('',1,'A1031DUP')
				EndIf
				
				//Consiste numero de parcelas da condicao e o maximo suportado pelo tamanho do campo
				If  Len(aVencto) > ( IIF ( STRZERO(0,nTamParc) == cParcela .Or. Val(cParcela) > 0,35,25) ** nTamParc ) 
					Help('',1,'A103PARC',,STR0108+Alltrim(STR(( IIF ( STRZERO(0,nTamParc) == cParcela .Or.; //##Numero maximo de parcelas:
					Val(cParcela) > 0,35,25) ** nTamParc )) )+Chr(10)+Chr(13)+STR0109+Alltrim(STR(Len(aVencto))),5,1)//##Parcelas da condicao de pagamento
				EndIf
			EndIf
			For nX := 1 To Len(aVencto)
				aVencto[nX][2] := NoRound(aVencto[nX][2],2)
				aadd(aCols,Array(nUsadoSE2+1))
				For nY := 1 To nUsadoSE2
					If IsHeadRec(aHeadSE2[nY][2])
					    aCols[Len(aCols)][nY] := 0
					ElseIf IsHeadAlias(aHeadSE2[nY][2])
					    aCols[Len(aCols)][nY] := "SE2"
				    Else		
						aCols[Len(aCols)][nY] := CriaVar(aHeadSE2[nY,2],.F.)
			        EndIf			
				Next nY
				aCOLS[Len(aCols)][nUsadoSE2+1] := .F.
				If nX <> Len(aVencto)
					aCols[nX][nPParcela] := cParcela 
					// Se a Data for alterada manualmente mantem a data modificada.
					If !(cCampo $ "CCONDICAO|DDEMISSAO|") .And. (Len(aColsSe2) == Len(aVencto) .And. aVencto[nX][1] <> aColsSe2[nX][nPosVec] .And. !Empty(aColsSe2[nX][nPosVec]))
						aCols[nX][nPVencto] := aColsSe2[nX][nPosVec]
					Else
						aCols[nX][nPVencto] := aVencto[nX][1]
					EndIf
					aCols[nX][nPValor]   := aVencto[nX][2]
					nTotDup += aVencto[nx][2]
					cParcela := MaParcela(cParcela)
				Else
				  If cCampo = "DDEMISSAO"  
				    	aCols[nX][nPParcela] := cParcela
				    	// Se a Data for alterada manualmente mantem a data modificada.
				    	If (nX >= Len(aColsSe2))  .OR. (Len(aColsSe2) == Len(aVencto) .And. aVencto[nX][1] <> aColsSe2[nX][nPosVec])
				    		aCols[nX][nPVencto]  := aVencto[nX][1]
				    	Else
				    		aCols[nX][nPVencto]  := aColsSe2[Len(aColsSe2)][nPosVec]
				    	EndIf
						aCols[nX][nPValor]   := nValor-nTotDup
					Else
					    aCols[nX][nPParcela] := cParcela
				    	// Se a Data for alterada manualmente mantem a data modificada.
						aCols[nX][nPVencto]  := If(Len(aColsSe2) == Len(aVencto) .And. aVencto[nX][1] <> aColsSe2[nX][nPosVec] .And. CTOD('  /  /  ') <> aColsSe2[nX][nPosVec] .AND. READVAR() <> "CCONDICAO"   ,aColsSe2[Len(aColsSe2)][nPosVec],aVencto[nX][1])   
						If Type("lAtuDupPC") == "L" .And. lAtuDupPC 
							aCols[nX][nPVencto] := aVencto[nX][1]
							lAtuDupPC := .F.  
						Endif

						aCols[nX][nPValor]   := nValor-nTotDup
					Endif
					
				EndIf

			Next nX
			
			//Ponto de Entrada: A103DUP
			If lMT103DUP .And. Len(aColsDup)>0 
			    lDupNew:= ExecBlock("MT103DUP",.F.,.F.,{aColsDup,aVencto,nValor})
				If Valtype(lDupNew)<>"L"
					lDupNew:=.F.
				EndIf
			EndIf
			
			If lDupNew
				aCols:=aClone(aColsDup)  
			EndIf

			//Verifica se ha necessidade da gravacao das multiplas naturezas
			If nPValSEV > 0                   
                nValSEV := nValor-nValFun-nValFet-nIrrf-nInss-nIss-nPis-nCOFINS-nCSLL-nValFab-nValFac-nValIMA-nValFAMAD-nValBTISS
				nRateio := 0
				For nY := 1 To Len(aColsSEV)
					If !aColsSEV[nY][Len(aColsSEV[1])] .And. !Empty(aColsSEV[nY][1])
						aColsSEV[nY][nPValSEV] := IIf(nY==Len(aColsSEV),nValSEV-nRateio,NoRound(nValSEV*aColsSEV[nY][nPercSEV]/100,nMultDec))
						nRateio += aColsSEV[nY][nPValSEV]
					EndIf
				Next nY
            EndIf

			// Verifica se o sistema esta preparado para utilizar o motor de tributos genericos
			If Len(aTribGen) > 0
				// Cria o array que ira conter os valores retornados pelo motor de tributos genericos por parcela de duplicata
				aParcTrGen := A103TrbGen(aVencto,aTribGen,aColTrbGen,@aRateio,@aRatBasTG,@cIdsTrGen)
			EndIf

			//Rateio do Impostos Financeiros
			If Len(aCols)>0
				//Gera o valor da Fethab apenas na primeira parcela
				If nPFETHAB <> 0
					aCols[1][nPFETHAB] := nValFet
				EndIf
					
				If nPFABOV <> 0
					aCols[1][nPFABOV] := nValFab
				EndIf	

				If nPFACS <> 0
					aCols[1][nPFACS] := nValFac
				EndIf
				
				If nPIMA <> 0
					aCols[1][nPIMA] := nValIMA
				EndIf
				
				If nPFAMAD <> 0
					aCols[1][nPFAMAD] := nValFAMAD
				EndIf	
				
				//Se o parametro nao permitir o rateio do IRRF/ISS/INSS, o valor sera descontado apenas na primeira parcela
				If !lRatIRRF
					If nPIRRF <> 0
						aCols[1][nPIRRF] := nIRRF- aRateio[1]
						aRateio[1] += aCols[1][nPIRRF]
					EndIf
				Endif       
				If !lRatISS
					If nPISS <> 0
						aCols[1][nPISS] := nISS - aRateio[2]
						aRateio[2] += aCols[1][nPISS]
					EndIf
				Endif       
				If !lRatINSS
					If nPINSS <> 0
						aCols[1][nPINSS] := nINSS - aRateio[3]
						aRateio[3] += aCols[1][nPINSS]
					EndIf   
				Endif
				If !lRatPIS
					If nPPIS <> 0
						aCols[1][nPPIS] := nPIS - aRateio[4]
						aRateio[4] += aCols[1][nPPIS]
					EndIf
				EndIf
				If !lRatCOFINS
					If nPCOFINS <> 0
						aCols[1][nPCOFINS] := nCOFINS - aRateio[5]
						aRateio[5] += aCols[1][nPCOFINS]
					EndIf
				EndIf
				If !lRatCSLL
					If nPCSLL <> 0
						aCols[1][nPCSLL] := nCSLL - aRateio[6]
						aRateio[6] += aCols[1][nPCSLL]
					EndIf
				EndIf
				If !lRatSEST
					If nPSEST <> 0
						aCols[1][nPSEST] := nSEST - aRateio[7]
						aRateio[7] += aCols[1][nPSEST]
					EndIf
				EndIf
				If !lRatISS
					If nPBTISS <> 0
						aCols[1][nPBTISS] := nValBTISS - aRateio[8]
						aRateio[8] += aCols[1][nPBTISS]
					EndIf
				EndIf
				// Preenche com os valores gerados pelo motor de tributos genericos
				If lTrbGen .And. !Empty(cNatureza)
					For nZ := 1 To Len(aTribGen)

						If aParcTrGen[1][nZ][5]	// Indica se retem integralmente na primeira parcela

							If (nPosValTrb := aScan(aColTrbGen,{|x| x[1] == aTribGen[nZ][1]}) ) > 0	// Encontra a coluna da duplicata referente ao tributo generico

								// Atualiza o array de duplicatas na tela
								aCols[1][nColsSE2+nPosValTrb] := aTribGen[nZ][3] - aRateio[7+nPosValTrb]
								aRateio[7+nPosValTrb] += aCols[1][nColsSE2+nPosValTrb]

								// Atualiza o array que sera passado para o Financeiro
								aParcTrGen[1][nZ][2]  := aTribGen[nZ][2] - aRatBasTG[nPosValTrb]	// Base do tributo generico
								aRatBasTG[nPosValTrb] += aParcTrGen[1][nZ][2]						// Saldo da base a ratear
								aParcTrGen[1][nZ][3]  := aCols[1][nColsSE2+nPosValTrb]				// Valor do tributo generico

							EndIf

						EndIf

					Next nZ
				EndIf
			EndIf
			
			For nX := 1 To Len(aCols)
				If nPIRRF <> 0
					If lRatIRRF
						aCols[nX][nPIRRF] := IIf(nX==Len(aCols),nIRRF-aRateio[1],NoRound(nIRRF*aCols[nX][nPValor]/nValor,2))
						aRateio[1] += aCols[nX][nPIRRF]
					Endif
				EndIf
				If nPISS <> 0
					If lRatISS
						aCols[nX][nPISS] := IIf(nX==Len(aCols),nISS -aRateio[2],NoRound(nISS*aCols[nX][nPValor]/nValor,2))
						aRateio[2] += aCols[nX][nPISS]
					Endif
				EndIf
				If nPINSS <> 0
					If lRatINSS
						aCols[nX][nPINSS] := IIf(nX==Len(aCols),nINSS-aRateio[3],NoRound(nINSS*aCols[nX][nPValor]/nValor,2))
						aRateio[3] += aCols[nX][nPINSS]
					Endif
				EndIf
				If nPPIS <> 0
					If lRatPIS
						aCols[nX][nPPIS] := IIf(nX==Len(aCols),nPIS-aRateio[4],NoRound(nPIS*aCols[nX][nPValor]/nValor,2))
						aRateio[4] += aCols[nX][nPPIS]
                    EndIf 
				EndIf
				If nPCOFINS <> 0
					If lRatCOFINS
						aCols[nX][nPCOFINS] := IIf(nX==Len(aCols),nCOFINS-aRateio[5],NoRound(nCOFINS*aCols[nX][nPValor]/nValor,2))
						aRateio[5] += aCols[nX][nPCOFINS]
                    EndIf
				EndIf
				If nPCSLL <> 0
					If lRatCSLL
						aCols[nX][nPCSLL] := IIf(nX==Len(aCols),nCSLL-aRateio[6],NoRound(nCSLL*aCols[nX][nPValor]/nValor,2))
						aRateio[6] += aCols[nX][nPCSLL]
                    EndIf
				EndIf
				If nPSEST <> 0
					If lRatSEST
						aCols[nX][nPSEST] := IIf(nX==Len(aCols),nSEST-aRateio[7],NoRound(nSEST*aCols[nX][nPValor]/nValor,2))
						aRateio[7] += aCols[nX][nPSEST]
					Endif
				EndIf
				If nPBTISS <> 0
					If lRatISS
						aCols[nX][nPBTISS] := IIf(nX==Len(aCols),nValBTISS-aRateio[8],NoRound(nValBTISS*aCols[nX][nPValor]/nValor,2))
						aRateio[8] += aCols[nX][nPBTISS]
					EndIf
				EndIf
				// Preenche com os valores gerados pelo motor de tributos genericos
				If lTrbGen .And. !Empty(cNatureza)
					For nZ := 1 To Len(aTribGen)

						If !aParcTrGen[nX][nZ][5]	// Indica se retem integralmente na primeira parcela

							If (nPosValTrb := aScan(aColTrbGen,{|x| x[1] == aTribGen[nZ][1]}) ) > 0	// Encontra a coluna da duplicata referente ao tributo generico

								// Atualiza o array de duplicatas na tela
								aCols[nX][nColsSE2+nPosValTrb] := IIf(nX==Len(aCols),aTribGen[nZ][3]-aRateio[7+nPosValTrb],NoRound(aTribGen[nZ][3]*aCols[nX][nPValor]/nValor,2))
								aRateio[7+nPosValTrb]   += aCols[nX][nColsSE2+nPosValTrb]

								// Atualiza o array que sera passado para o Financeiro
								// O valor do tributo deve ser igual ao valor exibido na aba Duplicatas, porem a base precisa ser calculada pois a aba Duplicatas nao trabalha com base
								aParcTrGen[nX][nZ][2] := IIf(nX==Len(aCols),aTribGen[nZ][2]-aRatBasTG[nPosValTrb],NoRound(aTribGen[nZ][2]*aCols[nX][nPValor]/nValor,2))	// Base do tributo generico
								aRatBasTG[nPosValTrb] += aParcTrGen[nX][nZ][2]			// Saldo a ratear da base
								aParcTrGen[nX][nZ][3] := aCols[nX][nColsSE2+nPosValTrb]	// Valor do tributo generico

							EndIf

						EndIf

					Next nZ
				EndIf
			Next nX
		EndIf
		
		If cCampo == "M->E2_VENCTO" .And. ValType(aIrrfNew)=="A"
			aIrrfNew := aCols
		EndIf
		nValDupAnt := nValor
	Else
		If MaFisFound("NF")
			aCols   := IIf(oCtaPag<>Nil,oCtaPag:aCols,aCols)
			nValor := NoRound(xMoeda(MaFisRet(,"NF_BASEDUP"),MaFisRet(,"NF_MOEDA"),nMoeda,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")),2)
			
			If Type("lTOPDRFRM") <> "U" .And. lTOPDRFRM .And. ValType(aD1Bkp) == "A" .And. Len(aD1Bkp) > 0
				nValor	:= 0
				
				cAliasBkp := aD1Bkp[1,Len(aD1Bkp[1])-2]

				If cAliasBkp == "SD1"
					nD1Tes	:= GdFieldPos("D1_TES",aHeadD1)
					nD1Ret	:= GdFieldPos("D1_RETENCA",aHeadD1)
					nD1Ded	:= GdFieldPos("D1_DEDUCAO",aHeadD1)
					nD1Fat	:= GdFieldPos("D1_FATDIRE",aHeadD1)
					nD1Tot	:= GdFieldPos("D1_TOTAL",aHeadD1)

					If nD1Tes > 0 .And. nD1Ret > 0 .And. nD1Ded > 0 .And. nD1Fat > 0
						For nI := 1 To Len(aD1Bkp)
							If !aD1Bkp[nI,Len(aHeadD1)+1]
								If GetAdvFval("SF4","F4_DUPLIC",xFilial("SF4") + aD1Bkp[nI,nD1Tes],1) == "S"
									nValor += MaFisRet(nI,"IT_TOTAL")

									nTotRDF += aD1Bkp[nI,nD1Ret]
									nTotRDF += aD1Bkp[nI,nD1Ded]
									nTotRDF += aD1Bkp[nI,nD1Fat]
								Endif
							Endif
						Next nI
					Endif
				Elseif cAliasBkp == "SE2"
					nE2Vlr	:= GdFieldPos("E2_VALOR",aHeader)

					If nE2Vlr > 0
						For nI := 1 To Len(aD1Bkp)
							If !aD1Bkp[nI,Len(aHeader)+1]
								nValor += aD1Bkp[nI,nE2Vlr]
							Endif
						Next nI
					Endif
				Endif
				
				nValor := nValor - nTotRDF
				nValor := xMoeda(nValor,MaFisRet(,"NF_MOEDA"),nMoeda,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA"))
				If nValor > 0 .And. nValor <> MaFisRet(,"NF_BASEDUP")
					MaFisAlt("NF_BASEDUP",nValor)
				ElseIf nValor == 0
					nValor := MaFisRet(,"NF_BASEDUP")
				EndIf
			Endif
		
			If nValor == 0
				aCols := {}
			EndIf
			nValFun := MaFisRet(,"NF_FUNRURAL")
			nValFet := IIf(MaFisRet(,"NF_RECFET")=="2",MaFisRet(,"NF_VALFET"),0)			                                         
			nValFab := IIf(MaFisRet(,"NF_RECFAB")=="2",MaFisRet(,"NF_VALFAB"),0)				
			nValFac := IIf(MaFisRet(,"NF_RECFAC")=="2",MaFisRet(,"NF_VALFAC"),0)
			nValIMA := IIf(MaFisRet(,"NF_RECIMA")=="2",MaFisRet(,"NF_VALIMA"),0)
			nValFAMAD := IIf(MaFisRet(,"NF_RECFMD")=="2",MaFisRet(,"NF_VALFMD"),0)		
			nIrrf	:= MaFisRet(,"NF_VALIRR")
			nInss   := MaFisRet(,"NF_VALINS")+Iif(cINSSAd<>"0",MaFisRet(,"NF_VALINA"),0)
			nIss	:= IIf(MaFisRet(,"NF_RECISS")=="2".And.lISSNat,MaFisRet(,"NF_VALISS"),0)
			nPis    := MaFisRet(,"NF_VALPIS")
			nCOFINS := MaFisRet(,"NF_VALCOF")
			nCSLL   := MaFisRet(,"NF_VALCSL")			
			nSEST   := MaFisRet(,"NF_VALSES")
			nValBTISS := MaFisRet(,"NF_VALCPM")

			If Empty(aCols)			
				aadd(aCols,Array(nUsadoSE2+1))
			EndIf			
			
			For nY := 1 To nUsadoSE2
				If IsHeadRec(aHeadSE2[nY][2])
					aCols[Len(aCols)][nY] := 0
				ElseIf IsHeadAlias(aHeadSE2[nY][2])
					aCols[Len(aCols)][nY] := "SE2"
				ElseIf nY <> nPVencto
					aCOLS[Len(aCols)][nY] := CriaVar(aHeadSE2[nY,2],.F.)
				Else
					aCols[Len(aCols)][nPVencto]  := IIf(Empty(aCols[Len(aCols)][nPVencto]),dDataBase,aCols[Len(aCols)][nPVencto])
				Endif
			Next nY

			aCOLS[Len(aCols)][nUsadoSE2+1] := .F.
			aCols[Len(aCols)][nPParcela] := Space(Len(SE2->E2_PARCELA))
			aCols[Len(aCols)][nPVencto]  := Iif(Empty(aCols[Len(aCols)][nPVencto]),dDataBase,aCols[Len(aCols)][nPVencto])
			aCols[Len(aCols)][nPValor]   := nValor

			//Verifica se ha necessidade da gravacao das multiplas naturezas
			If nPValSEV > 0
                nValSEV := nValor-nValFun-nValFet-nIrrf-nInss-nIss-nPis-nCOFINS-nCSLL-nValFac-nValFab-nValIMA-nValFAMAD-nValBTISS
				nRateio := 0
				For nY := 1 To Len(aColsSEV)
					If !aColsSEV[nY][Len(aColsSEV[1])] .And. !Empty(aColsSEV[nY][1])
						aColsSEV[nY][nPValSEV] := IIf(nY==Len(aColsSEV),nValSEV-nRateio,NoRound(nValSEV*aColsSEV[nY][nPercSEV]/100,nMultDec))
						nRateio += aColsSEV[nY][nPValSEV]
					EndIf
				Next nY
            EndIf
		EndIf
	EndIf
EndIf

//Atualiza os objetos
If oCondicao<>Nil
	oCondicao:lReadOnly  := (IIF((INCLUI .Or. ALTERA) .And. lMt103Get,ExecBlock("MT103GET",.F.,.F.), nValor == 0) .And. cTipo <> "D") .Or. cTipo == 'D' // O Retorno .T. Do ponto MT103GET impede a edicao do Get
    oCondicao:Refresh()
EndIf
If oNatureza<>Nil
	oNatureza:lReadOnly  := IIF((INCLUI .Or. ALTERA) .And. lMt103Get,ExecBlock("MT103GET",.F.,.F.), nValor == 0) // O Retorno .T. Do ponto MT103GET impede a edicao do Get
EndIf
If oMoeda<>Nil
	oMoeda:lReadOnly := IIF((INCLUI .Or. ALTERA) .And. lMt103Get,ExecBlock("MT103GET",.F.,.F.), nValor == 0) // O Retorno .T. Do ponto MT103GET impede a edicao do Get
EndIf
If oNatureza<>Nil
	oNatureza:Refresh()
EndIf
If oMoeda<>Nil
	oMoeda:Refresh()
EndIf
If oTaxa<>Nil
	oTaxa:lReadOnly := IIF((INCLUI .Or. ALTERA) .And. lMt103Get,ExecBlock("MT103GET",.F.,.F.),nMoedaCor == 1 .Or. ( cTipo=="D" .And. GetNewPar("MV_TXMOENC","1")=="1" .And. Iif(Type('lBlqTxNeg')=='L',lBlqTxNeg,.T.) .And. Iif(Type('nValFat')=='N' .And. nValFat > 0,nValor == nValFat,.T.) ))
	oTaxa:Refresh()
EndIf
If oDscMoeda<>Nil
	If nMoeda == 1
		cMoeda := RetTitle("F1_MOEDA")	
	EndIf
	oDscMoeda:SetText(cMoeda)
EndIf
If oCtaPag<>Nil
	oCtaPag:lUpdate := nValor <> 0
	If !Empty(aCols)
		oCtaPag:aCols := aCols 
		aColsSE2      := aCols
		If lMTCOLSE2
			aColsPE:= ExecBlock("MTCOLSE2",.F.,.F.,{aColsSE2,1})
			If ValType(aColsPE) == "A"
				oCtaPag:aCols:= aColsPE
				aColsSE2	 := aColsPE
			EndIf
		EndIf	
	EndIf
	oCtaPag:nAt   := 1
	oCtaPag:Refresh()
Else
	If !Empty(aCols)
		aColsSE2      := aCols
		If lMTCOLSE2
			aColsPE:= ExecBlock("MTCOLSE2",.F.,.F.,{aColsSE2,1})
			If ValType(aColsPE) == "A"
				aColsSE2	 := aColsPE
			EndIf
		EndIf	
	EndIf
EndIf
// Atualiza array de tributos genericos para que os valores fiquem coerentes com a aba Duplicatas, pois as colunas sao editaveis
If lTrbGen .And. Len(aParcTrGen) > 0
	A103AtuTrG(@aParcTrGen,aColTrbGen,aTribGen,aColsSE2,nColsSE2)
EndIf
If oMultNat<>Nil
	oMultNat:lUpdate := nValor <> 0
	If !Empty(aColsSEV)
		oMultNat:aCols := aColsSEV
	EndIf
	oMultNat:Refresh()
EndIf
If oDescri <> Nil
	oDescri:Refresh()
EndIf
If oTxNeg <> Nil
	oTxNeg:Refresh()
EndIf

Return


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeLOkSE2 ³Autor  ³ Eduardo Riera         ³ Data ³06.12.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao da LinhaOk para a getdados dos titulos   ³±±
±±³          ³financeiros                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL: Indica se a linha da getdados eh valida                ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina valida a getdados dos titulos financeiros        ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeLOkSE2()

Local lRetorno  := .T.
Local nPValor   := aScan(aHeader,{|x| AllTrim(x[2])=="E2_VALOR"})
Local nPIRRF    := aScan(aHeader,{|x| AllTrim(x[2])=="E2_IRRF"})
Local nPISS     := aScan(aHeader,{|x| AllTrim(x[2])=="E2_ISS"})
Local nPINSS    := aScan(aHeader,{|x| AllTrim(x[2])=="E2_INSS"})
Local nPPIS     := aScan(aHeader,{|x| AllTrim(x[2])=="E2_PIS"})
Local nPCOFINS  := aScan(aHeader,{|x| AllTrim(x[2])=="E2_COFINS"})
Local nPCSLL    := aScan(aHeader,{|x| AllTrim(x[2])=="E2_CSLL"})
Local nPFETHAB  := aScan(aHeader,{|x| AllTrim(x[2])=="E2_FETHAB"})
Local nPFABOV  	:= aScan(aHeader,{|x| AllTrim(x[2])=="E2_FABOV"})
Local nPFACS	:= aScan(aHeader,{|x| AllTrim(x[2])=="E2_FACS"})
Local nPIMA		:= aScan(aHeader,{|x| AllTrim(x[2])=="E2_IMA"})
Local nPFAMAD	:= aScan(aHeader,{|x| AllTrim(x[2])=="E2_FAMAD"}) 
Local lM103LSE2	:= Existblock("M103LSE2")

If lM103LSE2
	lRetorno := Execblock("M103LSE2",.F.,.F.)
Endif

If nPIRRF*nPISS*nPINSS*nPPIS*nPCOFINS*nPCSLL*IIf(Empty(nPFETHAB),1,nPFETHAB)*IIf(Empty(nPFABOV),1,nPFABOV)*IIf(Empty(nPFACS),1,nPFACS) > 0
	If aCols[n][nPValor]<=aCols[n][nPIRRF]+aCols[n][nPISS]+aCols[n][nPINSS]+aCols[n][nPPIS]+aCols[n][nPCOFINS]+aCols[n][nPCSLL]+IIf(nPFETHAB>0,aCols[n][nPFETHAB],0) .And.;
		aCols[n][nPValor]+aCols[n][nPIRRF]+aCols[n][nPISS]+aCols[n][nPINSS]+aCols[n][nPPIS]+aCols[n][nPCOFINS]+aCols[n][nPCSLL]+IIf(nPFABOV>0,aCols[n][nPFABOV],0)+ ;
		IIf(nPFACS>0,aCols[n][nPFACS],0)+IIf(nPIMA>0,aCols[n][nPIMA],0)+IIf(nPFAMAD>0,aCols[n][nPFAMAD],0)!=0
		Help(" ",1,"A100VALDUP",,"IRRF/ISS/INSS/PIS/COFINS/CSLL"+IIf(nPFETHAB>0,"/FETHAB","")+IIf(nPFABOV>0,"/FABOV","")+IIf(nPFACS>0,"/FACS","")+IIf(nPIMA>0,"/IMA","")+IIf(nPFAMAD>0,"/FAMAD",""),3,0)
	    lRetorno := .F.
	EndIf
Else
	If nPIRRF*nPISS*nPINSS > 0
		If aCols[n][nPValor]<=aCols[n][nPIRRF]+aCols[n][nPISS]+aCols[n][nPINSS] .And.;
		    aCols[n][nPValor]+aCols[n][nPIRRF]+aCols[n][nPISS]+aCols[n][nPINSS]!=0
			Help(" ",1,"A100VALDUP",,"IRRF/ISS/INSS",3,0)
			lRetorno := .F.
		EndIf
	EndIf
EndIf
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeTOkSE2 ³Autor  ³ Eduardo Riera         ³ Data ³09.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao da TudoOk para a getdados do contas a    ³±±
±±³          ³pagar                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1:Indica se a getdados eh valida                         ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina valida a getdados do contas a pagar              ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeTOkSE2()

Local lRetorno := NfeTotFin(aHeader,aCols)

Return(lRetorno)
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeLOkSEV ³Autor  ³ Eduardo Riera         ³ Data ³09.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao da LinhaOk para a getdados das Multiplas ³±±
±±³          ³naturezas                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL: Indica se a linha da getdados eh valida                ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina valida a getdados das multiplas naturezas        ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeLOkSEV()

Local lRetorno   := .T.
Local nPosNat    := aScan(aHeader,{|x| AllTrim(x[2]) == "EV_NATUREZ"})
Local nPosVlr    := aScan(aHeader,{|x| AllTrim(x[2]) == "EV_PERC"})

If MaFisFound("NF") .And. MaFisRet(,"NF_BASEDUP")>0 .And. nPosNat > 0 .And. nPosVlr > 0 .And. ((len(aCols) > 1) .Or. (!Empty(aCols[1,nPosNat]) .Or. !Empty(aCols[1,nPosVlr])))
	lRetorno := MaCheckCols(aHeader,aCols,N)
EndIf      

If nPosNat>0 .And. lRetorno
	lRetorno:=A103ValNat(aCols[N,nPosNat])
EndIf

Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeTOkSEV ³Autor  ³ Eduardo Riera         ³ Data ³09.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao da TudoOk para a getdados das Multiplas  ³±±
±±³          ³naturezas                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL: Indica se a getdados eh valida                         ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina valida a getdados das multiplas naturezas        ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeTOkSEV(aHeadSev, aColsSev,lvalor)
Local nX       := 0
Local nUsadoSEV:= Len(aHeadSev)
Local nPPerc   := aScan(aHeadSev,{|x| AllTrim(x[2])=="EV_PERC"})
Local nPNat    := aScan(aHeadSev,{|x| AllTrim(x[2])=="EV_NATUREZ"})
Local nSoma    := 0    
Local lRetorno := .T.
Local lMULNATP := SuperGetMV("MV_MULNATP",.F.,.F.)
Local lNFENAT  := SuperGetMV("MV_NFENAT",.F.,.F.)   
                                                      
If (INCLUI .Or. ALTERA)
	If MaFisFound("NF") .And. MaFisRet(,"NF_BASEDUP")>0 .And. nPNat > 0 .And.;
	nPPerc > 0 .And. ((len(aColsSev) > 1) .Or. (!Empty(aColsSev[1,nPNat]) .Or. !Empty(aColsSev[1,nPPerc])))
		For nX:= 1 To len(aColsSev)
			lRetorno := MaCheckCols(aHeadSev,aColsSev,nX)
			If !lRetorno
				Exit
			EndIf
		Next nX
	EndIf
	
	//Verifica se existem naturezas com lançamento sintético
	If nPNat>0 .And. lRetorno
		For nX:= 1 To len(aColsSev)
			lRetorno := A103ValNat(aColsSev[nX][nPNat])
			If !lRetorno
				Exit
			EndIf
		Next nX
	EndIf
	
	//Verifica se a soma dos percentuais eh 100%
	If !(cTipo$"DB") .And. lRetorno .And. ;
	    MaFisFound("NF") .And. MaFisRet(,"NF_BASEDUP")>0 .And. lMULNATP
		For nX := 1 To Len(aColsSev)
			If !aColsSev[nX][nUsadoSEV+1]
				If aColsSev[nX][nPPerc]<>0
					nSoma += aColsSev[nX][nPPerc]
				Else
					If nPNat == 0 .Or. !Empty(aColsSev[nX][nPNat])
						aColsSev[nX][nUsadoSEV+1] := .T.
					EndIf
				EndIf
			EndIf
		Next nX                       
	 	If Empty( MaFisRet(,"NF_NATUREZA") ) .And. nSoma == 0 .And. lNFENAT
			Help(" ",1,"A103NATURE")
			lRetorno := .F.
		EndIf 	
		If lRetorno .And. nSoma <> 0 .And. nSoma <> 100 
			Help(" ",1,"A103TOKSEV",,STR0040+TransForm(nSoma,"@E 999.99%"),4,0)
			lRetorno := .F.
		EndIf
	EndIf
EndIf

lValor := lRetorno

Return(lRetorno)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NFEVLDSEV³ Autor ³Alexandre Inacio Lemes ³ Data ³28/09/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Exibe o Help de rateio percentual de Multiplas Naturezas   ³±±
±±³          ³apos a funcao NfeTOkSEV tornar .F. a propriedade Cargo[2]  ³±±
±±³          ³do Objeto oFoco103 para impedir a finalizacao da Nfe quando³±±
±±³          ³a soma do percentual do SEV nao for = a 100%.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA103                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeVldSEV(lRetorno,aHeader,aCols,aHeadSEV,aColsSEV)
Local aRetSEV 	:= {}
Local lNFECTSEV	:= ExistBlock("NFECTSEV")
Local lNFEVLSEV	:= ExistBlock("NFEVLSEV")

If !lRetorno
	Help(" ",1,"A103TOKSEV")
EndIf

If lNFECTSEV
	aRetSEV := ExecBlock('NFECTSEV', .F., .F., {aHeadSEV,aColsSEV})
	
	If valtype(aRetSEV) == "A"
		if len(aRetSEV) >= 1 .And. valtype(aRetSEV[1]) == "A"
			aHeaderSEV := aClone(aRetSEV[1])
		EndIf
		if len(aRetSEV) >= 2 .And. valtype(aRetSEV[2]) == "A"
			aColsSEV   := aClone(aRetSEV[2])
		EndIf	
	EndIf		
EndIf     

If lRetorno .And. lNFEVLSEV
	lRetorno := ExecBlock("NFEVLSEV",.F.,.F.,{aHeader,aCols,aHeadSEV,aColsSEV})
EndIf

Return lRetorno

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NFERATSEV³ Autor ³Alexandre Inacio Lemes ³ Data ³01/07/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³                                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA103                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeRatSEV(nPercSEV,nValSEV)

Local nPPerc   := aScan(aHeader,{|x| AllTrim(x[2])=="EV_PERC"})
Local nPVLperc := aScan(aHeader,{|x| AllTrim(x[2])=="EV_VALPERC"})
Local nValor   := 0 
Local nValFun  := 0
Local nValFet  := 0
Local nIrrf	   := 0
Local nInss	   := 0
Local nIss	   := 0
Local nPis     := 0
Local nCofins  := 0
Local nCsll    := 0
Local nValRet  := 0
Local nTotPerc := 0
Local nMultDec := GetNewPar( "MV_MULTDEC", 2 ) 
Local lISSNat  := .T.
Local cNatNF   := ""
Local lISSTes  := SuperGetMv("MV_ISSRETD",.F.,.F.)
Local cINSSAd  := "0"

If nPVlPerc > 0

	If MaFisFound("NF")		

		//Verifica se deve existir o calculo do ISS pela natureza do titulo
		cNatNF := MaFisRet(,"NF_NATUREZA")
		dbSelectArea("SED")
		If SED->(dbSeek(xFilial("SED")+cNatNF))
			lISSNat := SED->ED_CALCISS <> "N" .Or. lISSTes
		Endif
		
		cINSSAd	:=	MaFisScan("NF_VALINA",.F.)            

		nValor  := MaFisRet(,"NF_BASEDUP")
		nValFun := MaFisRet(,"NF_FUNRURAL")
		nValFet := IIf(MaFisRet(,"NF_RECFET")=="2",MaFisRet(,"NF_VALFET"),0)
		nValFab := IIf(MaFisRet(,"NF_RECFAB")=="2",MaFisRet(,"NF_VALFAB"),0)
		nValFac := IIf(MaFisRet(,"NF_RECFAC")=="2",MaFisRet(,"NF_VALFAC"),0)
		nValIMA := IIf(MaFisRet(,"NF_RECIMA")=="2",MaFisRet(,"NF_VALIMA"),0)
		nValFAMAD := IIf(MaFisRet(,"NF_RECFMD")=="2",MaFisRet(,"NF_VALFMD"),0)		
		nIrrf	:= MaFisRet(,"NF_VALIRR")
		nInss   := MaFisRet(,"NF_VALINS")+Iif(cINSSAd<>"0",MaFisRet(,"NF_VALINA"),0)
		nIss	:= IIf(MaFisRet(,"NF_RECISS")=="2".And.lISSNat,MaFisRet(,"NF_VALISS"),0)
		nPis    := MaFisRet(,"NF_VALPIS")
		nCOFINS := MaFisRet(,"NF_VALCOF")
		nCSLL   := MaFisRet(,"NF_VALCSL")
	EndIf

    nValor := nValor-nValFun-nValFet-nIrrf-nInss-nIss-nPis-nCOFINS-nCSLL-nValFab-nValFac-nValIMA-nValFAMAD

	If nPercSEV > 0
		aCols[n][nPVlPerc] := ( nValor * nPercSEV ) / 100
		aCols[n][nPPerc]   := ( aCols[n][nPVlPerc] / nValor ) * 100
		nValRet := aCols[n][nPPerc]
	Else
		aCols[n][nPVlPerc] := 0
	EndIf
	
	If nValSEV > 0
		aCols[n][nPPerc]   := Round(( nValSEV / nValor ) * 100, nMultDec )
		aCols[n][nPVlPerc] := ( nValor * aCols[n][nPPerc] ) / 100
		nValRet := aCols[n][nPVlPerc]
	Else
		aCols[n][nPPerc] := 0
		nTotPerc := nPercSEV
	EndIf
EndIf

Return nValRet  

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeCond2  ³ Rev   ³ Julio C.Guerato       ³ Data ³06.05.2009 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Condicao de Pagamento                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina Validar se a Condição de Pagamento é valida      ³±±
±±³	         ³porém somente retorna .T. ou .F..							   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NfeCond2(cCondicao)

Local aArea    := GetArea()
Local lRetorno := Empty(cCondicao)

dbSelectArea("SE4")
dbSetOrder(1)
If !Empty(cCondicao)
	MsSeek(xFilial("SE4")+cCondicao)
	if Eof()
		lRetorno := .F.
	Else	 
	    lRetorno := IIF(SE4->E4_TIPO == "9",.F.,.T.)
	EndIf
EndIf

RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeCond   ³ Rev   ³ Edson Maricate        ³ Data ³07.08.2001 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de tratamento do folder de totais                     ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Condicao de Pagamento                                 ³±±
±±³          ³ExpO2: Objeto da descricao de pagamento                      ³±±
±±³          ³ExpC3: Descricao da condicao de pagamento                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo exibir/controlar o folder finan³±±
±±³          ³ceiro.                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeCond(cCondicao,oDescri,cDescricao)

Local aArea    := GetArea()
Local lRetorno := Empty(cCondicao)

DEFAULT cDescricao := ""

//Valida a condicao de pagamento
dbSelectArea("SE4")
dbSetOrder(1)
If ( !Empty(cCondicao) .And. ExistCpo("SE4",cCondicao) )
	MsSeek(xFilial("SE4")+cCondicao)
	If SE4->E4_TIPO == "9"
		Help("  ",1,"A100COND")
		lRetorno := .F.
	Elseif SE4->E4_TIPO == "A"
		If SuperGetMV("MV_VEICULO") == "S" .and. ( FM_PILHA("VEI") .or. FM_PILHA("OFI") ) // Chamada via execauto - Condição de Pagamento exclusivas para SIGAVEI/SIGAOFI
			lRetorno := .T.
		Else
			Help(" ",1,"A103COND",,STR0214,1,0) //"Condição de Pagamento exclusivas para SIGAVEI/SIGAOFI e não deve gerar duplicata"
			lRetorno := .F.
		EndIf	
	Else
		cDescricao	:= SE4->E4_DESCRI
		lRetorno := .T.
	EndIf
EndIf

//Efetua o refresh no objeto da descricao da condicao de pagto
If oDescri <> Nil
	oDescri:Refresh()
EndIf
RestArea(aArea)
Return(lRetorno)
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFldTot ³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao do folder de totais                    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpO1: Objeto da Janela que sera disponibilizado os Get      ³±±
±±³          ³ExpA2: Array com os gets de totais                           ³±±
±±³          ³ExpA3: Array com as posicoes dos gets de totais              ³±±
±±³          ³Expb4: Codeblock para atualizaco dos dados do Folder         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar o folder de totais   ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFldTot(oDlg,aGets,aPosGet,bRefresh)

Local aObjetos := Array(Len(aGets))

@ 06,aPosGet[1] SAY RetTitle("F1_VALMERC") Of oDlg PIXEL SIZE 55 ,9 //"Valor da Mercadoria"
@ 05,aPosGet[2] MSGET aObjetos[VALMERC] VAR aGets[VALMERC] PICTURE PesqPict('SD1','D1_TOTAL') OF oDlg PIXEL When .F. SIZE 80,09			
@ 06,aPosGet[3] SAY RetTitle("F1_DESCONT") Of oDlg PIXEL SIZE 49 ,9 //"Descontos"
@ 05,aPosGet[4] MSGET aObjetos[VALDESC] VAR aGets[VALDESC]  PICTURE PesqPict('SD1','D1_VALDESC') OF oDlg PIXEL When .F. SIZE 80,09			
If Len(aGets)>3
	@ 20,aPosGet[1] SAY RetTitle("F1_FRETE") Of oDlg PIXEL SIZE 45 ,9 //"Valor do Frete"
	@ 19,aPosGet[2] MSGET aObjetos[FRETE] VAR aGets[FRETE]  PICTURE PesqPict('SD1','D1_TOTAL') OF oDlg PIXEL When .F. SIZE 80,09
	@ 20,aPosGet[3] SAY RetTitle("F1_SEGURO") Of oDlg PIXEL SIZE 50 ,9 //"Vlr. do Seguro"
	@ 19,aPosGet[4] MSGET aObjetos[SEGURO] VAR aGets[SEGURO]  PICTURE PesqPict('SD1','D1_TOTAL') OF oDlg PIXEL When .F. SIZE 80,09	
	@ 34,aPosGet[3] SAY RetTitle("F1_DESPESA") Of oDlg PIXEL SIZE 50 ,9 //"Despesas"
	@ 33,aPosGet[4] MSGET aObjetos[VALDESP] VAR aGets[VALDESP]  PICTURE PesqPict('SD1','D1_TOTAL') OF oDlg PIXEL When .F.  SIZE 80,09
	@ 34,aPosGet[1] SAY RetTitle("F1_VALEMB") Of oDlg PIXEL SIZE 50 ,9 //"Valor da embalagem"
	@ 33,aPosGet[2] MSGET aObjetos[VALEMB] VAR aGets[VALEMB]  PICTURE PesqPict('SD1','D1_TOTAL') OF oDlg PIXEL When .F.  SIZE 80,09
	If GetNewPar("MV_VNAGREG",.F.) .And. cPaisLoc == "BRA"
		If Len(aGets) < 10   
			Aadd(aGets,0)
			Aadd(aObjetos,0)
		Endif
		@ 51,aPosGet[1] SAY STR0062 Of oDlg PIXEL SIZE 58 ,9 //"Valor não Agregado"
		@ 49,aPosGet[2] MSGET aObjetos[VNAGREG] VAR aGets[VNAGREG]  PICTURE PesqPict('SF1','F1_VNAGREG') OF oDlg PIXEL When .F. SIZE 80,09
	Endif
EndIf
@ 51,aPosGet[3] SAY RetTitle("F1_VALBRUT") Of oDlg PIXEL SIZE 58 ,9 //"Total do Doc."
@ 49,aPosGet[4] MSGET aObjetos[TOTPED] VAR aGets[TOTPED]  PICTURE PesqPict('SF1','F1_VALBRUT') OF oDlg PIXEL When .F. SIZE 80,09

@ 43,3 TO 46,aPosGet[5] LABEL '' OF oDlg PIXEL

bRefresh := {|| NfeRFldTot(aGets,aObjetos)}       

Return(.T.)
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeRFldTot³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao do folder de totais                    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: Array com as variaveis dos get de totais              ³±±
±±³          ³ExpA2: Array com os objetos dos get de totais                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar o folder de totais   ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeRFldTot(aGets,aObjetos)

Local nVlrAnterior := 0

nVlrAnterior := aGets[VALMERC]
aGets[VALMERC] := IIf(MaFisFound(),MaFisRet(,"NF_VALMERC"),aGets[VALMERC])
If nVlrAnterior <> aGets[VALMERC] .Or. !MaFisFound()
	aObjetos[VALMERC]:Refresh()
EndIf
nVlrAnterior := aGets[VALDESC]
aGets[VALDESC] := IIf(MaFisFound(),MaFisRet(,"NF_DESCONTO"),aGets[VALDESC])
If nVlrAnterior <> aGets[VALDESC] .Or. !MaFisFound()
	aObjetos[VALDESC]:Refresh()
EndIf
nVlrAnterior := aGets[TOTPED ]
aGets[TOTPED ] := IIF(MaFisFound(),MaFisRet(,"NF_TOTAL"),aGets[TOTPED ])
If nVlrAnterior <> aGets[TOTPED ] .Or. !MaFisFound()
	aObjetos[TOTPED ]:Refresh()
EndIf
If Len(aGets)>3
	nVlrAnterior := aGets[FRETE  ]
	aGets[FRETE  ] := IIF(MaFisFound(),MaFisRet(,"NF_FRETE"),aGets[FRETE  ])
	If nVlrAnterior <> aGets[FRETE  ] .Or. !MaFisFound()
		aObjetos[FRETE  ]:Refresh()
	EndIf
	nVlrAnterior := aGets[SEGURO ]
	aGets[SEGURO ] := IIF(MaFisFound(),MaFisRet(,"NF_SEGURO"),aGets[SEGURO ])
	If nVlrAnterior <> aGets[SEGURO ] .Or. !MaFisFound()
		aObjetos[SEGURO ]:Refresh()
	EndIf
	nVlrAnterior := aGets[VALDESP]
	aGets[VALDESP] := IIF(MaFisFound(),MaFisRet(,"NF_DESPESA"),aGets[VALDESP])
	If nVlrAnterior <> aGets[VALDESP] .Or. !MaFisFound()
		aObjetos[VALDESP]:Refresh()
	EndIf
	nVlrAnterior := aGets[VALEMB]
	aGets[VALEMB] := IIF(MaFisFound(),MaFisRet(,"NF_VALEMB"),aGets[VALEMB])
	If nVlrAnterior <> aGets[VALEMB] .Or. !MaFisFound()
		aObjetos[VALEMB]:Refresh()
	EndIf
	If GetNewPar("MV_VNAGREG",.F.)
		nVlrAnterior := aGets[VNAGREG ]
		aGets[VNAGREG ] := IIF(MaFisFound(),MaFisRet(,"NF_VNAGREG"),aGets[VNAGREG ])
		If nVlrAnterior <> aGets[VNAGREG ] .Or. !MaFisFound()
			aObjetos[VNAGREG ]:Refresh()
		EndIf
	Endif
EndIf
Return .T.
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFldFor ³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao do folder do fornecedor                ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpO1: Objeto da Janela que sera disponibilizado os Get      ³±±
±±³          ³ExpA2: Array com os gets de totais                           ³±±
±±³          ³ExpA3: Array com as posicoes dos gets de totais              ³±±
±±³          ³Expb4: Codeblock para atualizaco dos dados do Folder         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar o folder de fornece- ³±±
±±³          ³res                                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFldFor(oDlg,aGets,aPosGet,bRefresh)

Local aObjetos := Array(Len(aGets))
Local nObj := 1

@ 06,aPosGet[1,1] SAY RetTitle("A2_NOME") Of oDlg PIXEL SIZE 37,09
@ 05,aPosGet[1,2] MSGET aObjetos[nObj] VAR aGets[1] ;
	PICTURE PesqPict('SA2','A2_NOME');
	When .F. ;
	OF oDlg PIXEL SIZE 159,09
If(lLGPD,OfuscaLGPD(aObjetos[nObj],"A2_NOME"),.F.)	

nObj++
@ 06,aPosGet[1,3] SAY RetTitle("A2_TEL") Of oDlg PIXEL SIZE 23,09
@ 05,aPosGet[1,4]+5 MSGET aObjetos[nObj] VAR aGets[2] ;
	When .F. ;
	OF oDlg PIXEL SIZE 74,09
If(lLGPD,OfuscaLGPD(aObjetos[nObj],"A2_TEL"),.F.)	
	
nObj++
@ 43,aPosGet[2,1] SAY RetTitle("A2_PRICOM") Of oDlg PIXEL SIZE 32,09
@ 42,aPosGet[2,2] MSGET aObjetos[3] VAR aGets[3] ;
	PICTURE PesqPict('SA2','A2_PRICOM') ;
	When .F. ;
	OF oDlg PIXEL SIZE 40,09
nObj++
@ 43,aPosGet[2,3] SAY RetTitle("A2_ULTCOM") Of oDlg PIXEL SIZE 36,09
@ 42,aPosGet[2,4] MSGET aObjetos[nObj] VAR aGets[4] ;
	PICTURE PesqPict('SA2','A2_ULTCOM');
	WHEN .F. OF oDlg PIXEL SIZE 40,09
nObj++
@ 43,aPosGet[2,5]-30 SAY RetTitle("A2_CGC") Of oDlg PIXEL SIZE 26,09
@ 42,aPosGet[2,5]+20 MSGET aObjetos[nObj] VAR aGets[7] ;
	PICTURE PesqPict('SA2','A2_CGC');
	WHEN .F. OF oDlg PIXEL SIZE 76,09
If(lLGPD,OfuscaLGPD(aObjetos[nObj],"A2_CGC"),.F.)	
	
nObj++
If Len(aGets)>=8
	@ 43,aPosGet[3,3] SAY RetTitle("A2_INSCR") Of oDlg PIXEL SIZE 30,09
	@ 42,aPosGet[3,4] MSGET aObjetos[6] VAR aGets[8] ;
		PICTURE PesqPict('SA2','A2_INSCR');
		WHEN .F. OF oDlg PIXEL SIZE 60,09
	If(lLGPD,OfuscaLGPD(aObjetos[nObj],"A2_INSCR"),.F.)
	nObj++
Endif
@ 24,aPosGet[3,1] SAY RetTitle("A2_END") Of oDlg PIXEL SIZE 49,09
@ 23,aPosGet[3,2] MSGET aObjetos[nObj] VAR aGets[5];
	PICTURE PesqPict('SA2','A2_END');
	WHEN .F. OF oDlg PIXEL SIZE 205,9
	If(lLGPD,OfuscaLGPD(aObjetos[nObj],"A2_END"),.F.)		
nObj++		
@ 24,aPosGet[3,3] SAY RetTitle("A2_EST") Of oDlg PIXEL SIZE 32,09
@ 23,aPosGet[3,4] MSGET aObjetos[nObj] VAR aGets[6] ;
	PICTURE PesqPict('SA2','A2_EST');
	WHEN .F. OF oDlg PIXEL SIZE 21,09
@ If(Len(aGets)>=8,5,42),aPosGet[3,5] BUTTON STR0009 SIZE 30 ,11 FONT oDlg:oFont ; //"Mais Inf."
	ACTION A103ToFC030()  OF oDlg PIXEL
	If(lLGPD,OfuscaLGPD(aObjetos[nObj],"A2_EST"),.F.)
bRefresh := {|| NfeRFldFor(aGets,aObjetos)}

Return(.T.)
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeRFldFor³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao do folder do fornecedor                ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: Array com as variaveis dos get de totais              ³±±
±±³          ³ExpA2: Array com os objetos dos get de totais                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar o folder de fornece- ³±±
±±³          ³dor                                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeRFldFor(aGets,aObjetos)

Local aArea := GetArea()
Local nX    := 0 
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o array que contem os dados do Fornecedor      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cTipo $ "DB"
	If aGets <> Nil
		dbSelectArea("SA1")
		dbSetOrder(1)
		If MsSeek(xFilial("SA1")+cA100For+cLoja)
			aGets[1] := SA1->A1_NOME					// Nome
			aGets[2] := IIF(!Empty(SA1->A1_DDI),"( "+TransForm(SA1->A1_DDI,PesqPict("SA1","A1_DDI"))+") ","");
			+TransForm(alltrim(SA1->A1_DDD),PesqPict("SA1","A1_DDD"))+" "+TransForm(SA1->A1_TEL,PesqPict("SA1","A1_TEL")) // Telefone
			aGets[3] := SA1->A1_PRICOM	    			//Primeira Compra
			aGets[4] := SA1->A1_ULTCOM      			//Ultima Compra
			aGets[5] := SA1->A1_END+" - "+SA1->A1_MUN	//Endereco
			aGets[6] := SA1->A1_EST         			//Estado
			aGets[7] := SA1->A1_CGC         			//Cgc
			If Len(aGets)>=8
				aGets[8] := SA1->A1_INSCR         			//Inscricao estadual
			Endif
			For nX := 1 To Len(aObjetos)
				If aObjetos[nX]<>Nil
					aObjetos[nX]:Refresh()
				EndIf
			Next nX
		EndIf
	EndIf
Else
	If aGets <> Nil
		dbSelectArea("SA2")
		dbSetOrder(1)
		If MsSeek(xFilial("SA2")+cA100For+cLoja)

			aGets[1] := SA2->A2_NOME					// Nome
			aGets[2] := IIF(!Empty(SA2->A2_DDI),"( "+TransForm(SA2->A2_DDI,PesqPict("SA2","A2_DDI"))+") ","");
			+TransForm(alltrim(SA2->A2_DDD),PesqPict("SA2","A2_DDD"))+" "+TransForm(SA2->A2_TEL,PesqPict("SA2","A2_TEL")) // Telefone
			aGets[3] := SA2->A2_PRICOM					//Primeira Compra
			aGets[4] := SA2->A2_ULTCOM      			//Ultima Compra
			aGets[5] := SA2->A2_END+" - "+SA2->A2_MUN	//Endereco
			aGets[6] := SA2->A2_EST         			//Estado
			aGets[7] := SA2->A2_CGC         			//Cgc
			If Len(aGets)>=8
				aGets[8] := SA2->A2_INSCR         			//Inscricao estadual
			Endif
			For nX := 1 To Len(aObjetos)
				If aObjetos[nX]<>Nil
					aObjetos[nX]:Refresh()
				EndIf
			Next nX
		EndIf
	EndIf
EndIf
RestArea(aArea)
Return(.T.)   

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFldDsp ³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao do folder de Despesas acessorias       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpO1: Objeto da Janela que sera disponibilizado os Get      ³±±
±±³          ³ExpA2: Array com os gets das despesas acessorias             ³±±
±±³          ³ExpA3: Array com as posicoes dos gets das despesas acessorias³±±
±±³          ³Expb4: Codeblock para atualizaco dos dados do Folder         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar o folder das despesas³±±
±±³          ³acessorias                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFldDsp(oDlg,aGets,aPosGet,bRefresh)

Local aObjetos := Array(Len(aGets))

@ 09,aPosGet[1,1] SAY RetTitle("F1_DESCONT") Of oDlg PIXEL SIZE 48,09
@ 08,aPosGet[1,2] MSGET aObjetos[VALDESC] VAR aGets[VALDESC] ;
	PICTURE PesqPict("SD1","D1_VALDESC") ;
	OF oDlg PIXEL ;
	WHEN !l103Visual .And. A103LCF("F1_DESCONT") .And. !cTipo$"PI" ;
	VALID CheckSX3("F1_DESCONT",aGets[VALDESC]) .And. aGets[VALDESC]>=0 .And. NfeVldRef("NF_DESCONTO",aGets[VALDESC]) SIZE 80,09 HASBUTTON
@ 09,aPosGet[1,3] SAY RetTitle("F1_FRETE") Of oDlg PIXEL SIZE 35,09
@ 08,aPosGet[1,4] MSGET aObjetos[FRETE] VAR aGets[FRETE] ;
	PICTURE PesqPict("SF1","F1_FRETE") ;
	OF oDlg PIXEL ;
	WHEN !l103Visual .and. A103LCF("F1_FRETE");
	VALID CheckSX3("F1_FRETE",aGets[FRETE]) .And. aGets[FRETE]>=0 .And. NfeVldRef("NF_FRETE",aGets[FRETE]) SIZE 80,09 HASBUTTON
@ 26,aPosGet[1,1] SAY RetTitle("F1_DESPESA") Of oDlg PIXEL SIZE 42,09
@ 25,aPosGet[1,2] MSGET aObjetos[VALDESP] VAR aGets[VALDESP] ;
	PICTURE PesqPict("SF1","F1_DESPESA") ;
	OF oDlg PIXEL ;
	WHEN !l103Visual .And. A103LCF("F1_DESPESA");
	VALID CheckSX3("F1_DESPESA",aGets[VALDESP]) .And. aGets[VALDESP]>=0 .And. NfeVldRef("NF_DESPESA",aGets[VALDESP]) SIZE 80,09 HASBUTTON
@ 26,aPosGet[1,3] SAY RetTitle("F1_SEGURO") Of oDlg PIXEL SIZE 35,09
@ 25,aPosGet[1,4] MSGET aObjetos[SEGURO] VAR aGets[SEGURO] ;
	PICTURE PesqPict("SF1","F1_SEGURO") ;
	OF oDlg PIXEL ;
	WHEN !l103Visual .And. A103LCF("F1_SEGURO");
	VALID CheckSX3("F1_SEGURO",aGets[SEGURO]) .And. aGets[SEGURO]>=0 .And. NfeVldRef("NF_SEGURO",aGets[SEGURO]) SIZE 80,9	HASBUTTON
@ 38,11 TO 40 ,aPosGet[2,1] LABEL "" OF oDlg PIXEL
@ 48,aPosGet[2,2] SAY STR0010 Of oDlg PIXEL SIZE 60,09 //"Total ( Frete+Despesas)"
@ 47,aPosGet[2,3] MSGET aObjetos[TOTF3] VAR aGets[TOTF3] ;
	PICTURE PesqPict("SF1","F1_VALBRUT") ;
	OF oDlg PIXEL ;
	WHEN .F. SIZE 80,09 HASBUTTON

bRefresh := {|| NfeRFldDsp(aGets,aObjetos)}

Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeVldRef ³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao das referencias fiscais dos Gets fixos ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Referencias fiscais dos impostos de cabecalho         ³±±
±±³          ³ExpA2: Valor da referencia                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar o folder das despesas³±±
±±³          ³acessorias                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeVldRef(cReferencia,xValor)

Local aArea	   := GetArea()
Local nPosPc   := aScan(aHeader,{|x| AllTrim(x[2])=="D1_PEDIDO"})
Local nPosItPc := aScan(aHeader,{|x| AllTrim(x[2])=="D1_ITEMPC"}) 
Local nPosTes  := aScan(aHeader,{|x| AllTrim(x[2])=="D1_TES"})
Local nCnt     := 0
Local lPedidos := .F.
Local lRetorno := .T.
Local lRetPE   := .T.
Local lPedPre  := .F.
Local cUfOri   := ""  
Local aVecReal := {}
Local dVecReal := CTOD('//')
Local lCteOriDest	:= SF1->(ColumnPos("F1_UFORITR")) > 0 .And. SF1->(ColumnPos("F1_MUORITR")) > 0 .And. SF1->(ColumnPos("F1_UFDESTR")) > 0 .And. SF1->(ColumnPos("F1_MUDESTR")) > 0
Local cUfDest  := ""

If Type("cCondicao") == "C"
   aVecReal := Condicao(1,cCondicao,,dDEmissao) // O valor (parametro 1) não interessa neste momento, mas a funcão Condição() não retorna nada se o primeiro paramentro for 0 (zero), por esse motivo tive que chumbar um valor (1).
EndIf

If Len(aVecReal) > 0
	dVecReal := aVecReal[1][1]
Else
    dVecReal := dDataBase
EndIf  

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o Fornecedor da Pre-Nota foi alterado quando tiver vinculo com Pedidos |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cReferencia $ "NF_LOJA/NF_CODCLIFOR"  
   	If nPosTes=0 .And. nPosPc>0 .And. nPosItPc>0 .And. Len(aCols)>0 
        DbSelectArea("SC7")
   	    DbSetOrder(1)
		For nCnt := 1 to Len(aCols)
		    If Len(Trim(aCols[nCnt][nPosPc]))>0 .And. Len(Trim(aCols[nCnt][nPosItPc]))>0
	 	  	    MsSeek(xFilial("SC7")+aCols[nCnt][nPosPc]+aCols[nCnt][nPosItPc]) 
		   	    If C7_NUM==aCols[nCnt][nPosPc] .And. C7_ITEM==aCols[nCnt][nPosItPc] 
		    	    If C7_FORNECE<>CA100FOR .Or. C7_LOJA<>CLOJA
		    	       	lPedPre:=.T.
		    	       	exit
		    	     EndIf
		    	EndIf
		    EndIf
		Next nCnt
	EndIf    
EndIf

If (MaFisFound("NF") .And. !(MaFisRet(,cReferencia)==xValor)) .Or. lPedPre 
	If cReferencia $ "NF_LOJA/NF_CODCLIFOR" .And. nPosPc > 0 .And. nPosItPC > 0;
			.And. Len(aCols) > 0 .And. ( lConsLoja .Or. cReferencia == "NF_CODCLIFOR")
		For nCnt := 1 to Len(aCols)
			If !ExistBlock("MT103VCN")
				If !lPedidos .And. !Empty(aCols[nCnt][nPosPc])
					If Aviso(OemToAnsi(STR0018),OemToAnsi(STR0027),{OemToAnsi(STR0016),OemToAnsi(STR0017)}) == 2  //"Existem pedidos relacionados a este fornecedor! Estas informações serão apagadas. Deseja Continuar?""###"Continua"###"Abandona"
						lRetorno := .F.
						Exit
					Else
						lPedidos := .T.
					EndIf
				EndIf
				If lPedidos
					aCols[nCnt][nPosPc]   := Space(Len(aCols[nCnt][nPosPc]))
					aCols[nCnt][nPosItPc] := Space(Len(aCols[nCnt][nPosItPc]))
				EndIf
			Else       
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Ponto de Entrada MT103VCN - Valida se ira manter o acols com  |
				//| os pedidos preenchidos se o Fornecedor / Loja forem alterados |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				lPedidos := If(ValType(lRetPE:=ExecBlock("MT103VCN",.F.,.F.,{aHeader,aCols,cReferencia,xValor}))=='L',lRetPE,.T.)
				If ValType(lPedidos) == "L"
					If !lPedidos
						aCols[nCnt][nPosPc]   := Space(Len(aCols[nCnt][nPosPc]))
						aCols[nCnt][nPosItPc] := Space(Len(aCols[nCnt][nPosItPc]))
					EndIf
				Endif
			EndIf
		Next
	EndIf                    
	
	If lRetorno .And. !lPedPre     
		If cReferencia == "NF_NATUREZA"
			cUfOri   := MaFisRet(,"NF_UFORIGEM")
			
			If lCteOriDest
				cUfDest := MaFisRet(,"NF_UFDEST")
			Endif		
		Endif	
	
		MaFisAlt(cReferencia,xValor,,,,,,,dVecReal)
		
		/*Re-insere informações após recriação dos array's fiscais pela troca da natureza
		Utiliza MaFisLoad ao Invés de MaFisRef ou MaFisAlt para não alterar recalcular impostos durante mudança da Natureza (ou mudar a CFOP no caso da Modalidade)*/
		If cReferencia == "NF_NATUREZA" 
			//UF DE ORIGEM
			MaFisLoad("NF_UFORIGEM",cUfOri,,,,,,,dVecReal)
			
			If lCteOriDest .And. !Empty(cUfDest)
				//UF DE DESTINO
				MaFisLoad("NF_UFDEST",cUfDest,,,,,,,dVecReal)
			Endif				
			
			//MODALIDADE DE FRETE
			If Type("aNfeDanfe") == "A" .AND. Len(aNfeDanfe)>=23
				If !Empty(MafisScan("NF_MODAL",.F.)) .And. (Left(aNfeDanfe[23],2) $ "  |01|02|03|04|05|06")
					MaFisLoad("NF_MODAL",Left(aNfeDanfe[23],2))
				EndIf
			EndIf		
		Endif
		
		MaFisToCols(aHeader,aCols,,"MT100")
	EndIf
	Eval(bGDRefresh)
	Eval(bRefresh)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada MT103DSP                 |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRetorno .And. ExistBlock('MT103DSP')
	lRetorno := If(ValType(lRetPE:=ExecBlock('MT103DSP',.F.,.F.,{aHeader,aCols,cReferencia,xValor}))=='L',lRetPE,.T.)
EndIf

RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeRFldDsp³Autor  ³ Eduardo Riera         ³ Data ³13.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao do folder das despesas acessorias      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: Array com as variaveis dos get de totais              ³±±
±±³          ³ExpA2: Array com os objetos dos get de totais                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar o folder das despesas³±±
±±³          ³acessorias                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeRFldDsp(aGets,aObjetos)

Local nVlrAnterior := 0
Local nX := 1

nVlrAnterior := aGets[VALDESC]
If MaFisFound("NF")
	aGets[VALDESC] := MaFisRet(,"NF_DESCONTO")
EndIf
If nVlrAnterior <> aGets[VALDESC]
	aObjetos[VALDESC]:Refresh()
EndIf
nVlrAnterior := aGets[FRETE]
If MaFisFound("NF")
	aGets[FRETE] := MaFisRet(,"NF_FRETE")
EndIf
If nVlrAnterior <> aGets[FRETE]
	aObjetos[FRETE]:Refresh()
EndIf
nVlrAnterior := aGets[VALDESP]
If MaFisFound("NF")
	aGets[VALDESP] := MaFisRet(,"NF_DESPESA")
EndIf
If nVlrAnterior <> aGets[VALDESP]
	aObjetos[VALDESP]:Refresh()
EndIf
nVlrAnterior := aGets[SEGURO]
If MaFisFound("NF")
	aGets[SEGURO] := MaFisRet(,"NF_SEGURO")
EndIf
If nVlrAnterior <> aGets[SEGURO]
	aObjetos[SEGURO]:Refresh()
EndIf
nVlrAnterior := aGets[TOTF3  ]
aGets[TOTF3  ] := aGets[FRETE]+aGets[SEGURO]+aGets[VALDESP]
If nVlrAnterior <> aGets[TOTF3  ]
	aObjetos[TOTF3  ]:Refresh()
EndIf
For nX := 1 To Len(aObjetos)
	If aObjetos[nX]<>Nil
		aObjetos[nX]:Refresh()
	EndIf
Next nX

Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFldChg ³Autor  ³ Eduardo Riera         ³ Data ³11.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de controle da troca de folder                        ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Folder de destino                                     ³±±
±±³          ³ExpN2: Folder atual                                          ³±±
±±³          ³ExpO3: Objeto do Folder                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo exibir/controlar os folders do ³±±
±±³          ³rodape do documento de entrada                               ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFldChg(nFldDst,nFldAtu,oFolder,aCodeBlock)

DEFAULT nFldDst := IIf(oFolder<>Nil,oFolder:nOption,1)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza os objetos do folder de destino                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(aCodeBlock) .And. nFldDst<=Len(aCodeBlock) .And. !Empty(aCodeBlock[nFldDst])
	Eval(aCodeBlock[nFldDst])
EndIf
Return(.T.) 

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeDelItem³ Autor ³ Edson Maricate        ³ Data ³04.03.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina valida a delecao de um item do documento de entra³±±
±±³          ³da                                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Sempre .T.                                            ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar a delecao do item do   ³±±
±±³          ³documento de entrada informado a funcao fiscal               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeDelItem()

STATIC __lExeDel := .F.

Local cIdentB6  := ""
Local nPIdentB6 := GDFieldPos( "D1_IDENTB6")
Local nI        := 0
Local nPosCalc  := 0
Local nPosIt	:= 0
Local nPosItD1	:= aScan(aHeader,{|aX| aX[2]==PadR("D1_ITEM",Len(SX3->X3_CAMPO))})
	
__lExeDel := !__lExeDel

If !MaFisFound("IT",n)
	MaFisAdd("","",0,0,0,CriaVar("D1_NFORI"),CriaVar("D1_SERIORI"),,0,0,0,0,0)
EndIf
MaFisDel(n,aCols[n][Len(aCols[n])])

If __lExeDel .And. !GDDeleted()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Libera a reserva do identificador de poder de terceiros  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If !Empty( nPIdentB6 )
		If !Empty( cIdentB6 := aCols[ n, nPIdentB6 ] )
			Leave1Code( "SD1_D1_IDENTB6" + cIdentB6 )
		EndIf 		
    EndIf
EndIf

Eval(bRefresh)

If Type("oLancApICMS")<>"U" .And. oLancApICMS<>Nil .And. nPosItD1>0
	nPosCalc:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_CALPRO"})
	nPosIt	:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_NUMITE"})
	For nI := 1 To Len(oLancApICMS:aCols)
		If aCols[n,nPosItD1]==oLancApICMS:aCols[nI,nPosIt]
			oLancApICMS:aCols[nI,Len(oLancApICMS:aCols[nI])]	:=	aCols[n,Len(aCols[n])]
		EndIf
	Next nI
	oLancApICMS:Refresh()
EndIf

If Type("oLancCDV")<>"U" .And. oLancCDV<>Nil .And. nPosItD1>0
	nPosCalc:=	aScan(oLancCDV:aHeader,{|aX|aX[2]=="CDV_AUTO"})
	nPosIt	:=	aScan(oLancCDV:aHeader,{|aX|aX[2]=="CDV_NUMITE"})
	For nI := 1 To Len(oLancCDV:aCols)
		If aCols[n,nPosItD1]==oLancCDV:aCols[nI,nPosIt]
			oLancCDV:aCols[nI,Len(oLancCDV:aCols[nI])]	:=	aCols[n,Len(aCols[n])]
		EndIf
	Next nI
	oLancCDV:Refresh()
EndIf

Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeEmissao³ Autor ³ Edson Maricate        ³ Data ³04.03.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina valida a data de emissao do documento de entrada ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpD1: Data de Emissao                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se a data eh valida                            ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar a data de emissao do   ³±±
±±³          ³documento de entrada.                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeEmissao(dEmissao)
Local lRet	:= .T.

Static dMudaEmi
Default dMudaEmi := cToD("")

If !Empty(dEmissao) .And. dEmissao > dDataBase
	lRet := .F.
	Help("  ",1,"A103DATAM")
Else                        
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza folder financeiro quando alterar a data de emissao do documento fiscal³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ     
	If !Empty(dEmissao) .And. dEmissao <> dMudaEmi
		dMudaEmi := dEmissao
		Eval(bRefresh,6)
	Endif
Endif
Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³SetVar113 ³ Autor ³ TOTVS                 ³ Data ³07.07.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina seta um novo valor a variavel dMudaEmi           ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: conteudo para a variavel                              ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/  
function SetVar113(cCont) 
  dMudaEmi:=cCont
Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeNextDoc³ Autor ³ Edson Maricate        ³ Data ³04.03.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina controla a numeracao do documento de entrada qdo ³±±
±±³          ³o formulario for proprio                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpD1: Data de Emissao                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se a data eh valida                            ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo controlar/atualizar a numeracao³±±
±±³          ³do documento de entrada quando o formulario for proprio.     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeNextDoc(cNFiscal,cNfSerie,lAtiva,cNumNfGFE)

Local aArea	   := GetArea()
Local aAreaSF1 := SF1->(GetArea())
Local lRetorno := .T.
Local nItensNf := 0
Local cTipoNf  := SuperGetMv("MV_TPNRNFS")
Local cNum103  := ""  
Local cMT103SRI:= ""
Local lUsaNewKey  := TamSX3("F1_SERIE")[1] == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso
Local cSerieId    := IIf( lUsaNewKey , SerieNfId("SF1",4,"F1_SERIE",dDEmissao,cEspecie,cNfSerie) , cNfSerie )

If cFormul == "S" .And. lAtiva
	Private cNumero:= ""
	Private cSerie := ""
	lRetorno:= Sx5NumNota(@cSerie,cTipoNf,,,,@cSerieId,dDEmissao ) // O parametro cSerieId deve ser passado para funcao Sx5NumNota afim de tratar a existencia ou nao do mesmo numero na funcao VldSx5Num do MATXFUNA.PRX
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Validacao da NF informada pelo usuario                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. cTipoNF <> "3"
		SF1->(dbSetOrder(1))
		If SF1->(MsSeek(xFilial("SF1")+PADR(cNumero,TamSx3("F1_DOC")[1])+SerieNfId("SF1",4,"F1_SERIE",dDEmissao,cEspecie,cSerie)+cA100For+cLoja,.F.))
			Help(" ",1,"EXISTNF")
			lRetorno := .F.
			cNumero:= ""
			cSerie := ""
		EndIf
	EndIf
	If lRetorno
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica o numero de maximo de itens da serie.               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aEval(aCols,{|x| nItensNf += IIF(x[Len(x)],0,1)})
		If nItensNf > 0 	.And. nItensNf > a460NumIt(cSerie,.T.)
			Help(" ",1,"A100NITENS")
			lRetorno := .F.
		Else
			If cTipoNf <> "3"

				cSerieId := IIf( lUsaNewKey , SerieNfId("SF1",4,"F1_SERIE",dDEmissao,cEspecie,cSerie) , cSerie )

				// Se numeracao for SXE/SXF e usuario alterou numero, respeita numero do usuarop
				If cTipoNf <> "2" .OR. !lMudouNum
					cNumero := NxtSX5Nota(cSerie, NIL, cTipoNf,,,, cSerieId)// O parametro cSerieId deve ser passado para funcao NxtSx5Nota afim de tratar a existencia ou nao do mesmo numero na funcao VldSx5Num do MATXFUNA.PRX
				EndIf	
			Else 
				If !lMudouNum	// Verifica se usuario alterou numero da nota fiscal
					cNumNfGFE := cNumero
					cNumero := Space(TamSx3("F1_DOC")[1])
				EndIf	
			EndIf
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de entrada para permitir alterar o numero da nota      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistBlock("M103NUM",.F.,.F.)
			cNum103 := ExecBlock("M103NUM",.F.,.F.,{cNumero})
			If Valtype( cNum103 ) == "C"
				cNumero := cNum103
			EndIf
		EndIf
	EndIf

	If lRetorno
	   cNFiscal:=cNumero
	   cNFSerie:=cSerie
    Else 
	   cNFiscal:= CriaVar("F1_DOC",.F.)
	   cNFSerie:= SerieNfId("SF1",5,"F1_SERIE")      
    EndIf
ElseIf cFormul == "N" .And. lAtiva
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica o preenchimento dos campos.        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Empty(ca100For) .Or. Empty(dDEmissao) .Or. Empty(cTipo) .Or. (Empty(cNFiscal).And.cFormul<>"S") .Or.(Empty(cSerie).And.X3Obrigat("F1_SERIE"))
		Help(" ",1,"A100FALTA")
		lRetorno := .F.
	EndIf

	SF1->(dbSetOrder(1))
	If SF1->(MsSeek(xFilial("SF1")+cNFiscal+SerieNfId("SF1",4,"F1_SERIE",dDEmissao,cEspecie,cSerie)+cA100For+cLoja,.F.))
		Help(" ",1,"EXISTNF")
		lRetorno := .F.
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Ponto de entrada para manipular o cNFSerie     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ                 
If ExistBlock("MT103SRI")  
	cMT103SRI := ExecBlock("MT103SRI",.F.,.F.,{cNFiscal,cNFSerie})
  	If ValType(cMT103SRI) == "C"
		cNFSerie := cMT103SRI
	EndIf  
EndIf                  

RestArea(aAreaSF1)
RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103IniCpo³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao dos dados referentes ao codigo de produ³±±
±±³          ³to.                                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Sempre verdadeiro                                     ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar as informacoes do    ³±±
±±³          ³item do documento de entrada referente ao produto            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103IniCpo()

Local aArea			:= GetArea() 
Local aTriggerCpo	:= {}
Local nPosCod 		:= GetPosSD1("D1_COD" )
Local nPosUM		:= GetPosSD1("D1_UM" )
Local nPosSegUM		:= GetPosSD1("D1_SEGUM" )
Local nPosCC		:= GetPosSD1("D1_CC" )
Local nPosConta 	:= GetPosSD1("D1_CONTA" )
Local nPosItCt  	:= GetPosSD1("D1_ITEMCTA" )
Local nPosClVl  	:= GetPosSD1("D1_CLVL" )
Local nPosDtValid	:= GetPosSD1("D1_DTVALID" )

Local nPosTotal		:= GetPosSD1("D1_TOTAL" )
Local nPosLocal		:= GetPosSD1("D1_LOCAL" )

Local nPosQtSegum	:= GetPosSD1("D1_QTSEGUM" )
Local nPosTes		:= GetPosSD1("D1_TES" )
Local nPosPedido	:= GetPosSD1("D1_PEDIDO" )
Local nPosItemPC	:= GetPosSD1("D1_ITEMPC" )
Local nPosLoteCtl	:= GetPosSD1("D1_LOTECTL") 
Local nPosChassi 	:= GetPosSD1("D1_CHASSI")  
Local nPosTesAut	:= Nil
Local cReadVar   	:= ReadVar()
Local cProduto   	:= ""
Local uRet       	:= Nil
Local lDtValid   	:= .T.
Local lMT103CPO	:= ExistBlock("MT103CPO")
Local lTesAuto	:= .F.

If (Type("l103Auto") <> "U" .And. l103Auto .And. len(aAutoItens) >= n)
	nPosTesAut := IIf(Type("aAutoItens")=="U",0,If(Empty(aAutoItens),0,aScan(aAutoItens[n],{|x|Trim(x[1])== "D1_TES" })))
EndIf

If lMT103CPO
	If nPosConta > 0
		AADD(aTriggerCpo,"D1_CONTA")
	EndIf
	aTriggerCpo:= ExecBlock("MT103CPO",.F.,.F.,{aTriggerCpo})
	If ValType(aTriggerCpo) <> "A"
		aTriggerCpo:= {}
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza os dados com base no cadastro de produto       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SB1")
dbSetOrder(1)
If !"D1_COD"$cReadVar
	MsSeek(xFilial("SB1")+aCols[n][nPosCod])
	cProduto := aCols[n][nPosCod]
Else
	MsSeek(xFilial("SB1")+M->D1_COD)
	cProduto := M->D1_COD
EndIf
If nPosUm<>0
	aCols[n][nPosUM] := SB1->B1_UM
EndIf
If nPosSegUM<>0
	aCols[n][nPosSegUM] := SB1->B1_SEGUM
EndIf
If nPosCC > 0
	If lMT103CPO
		If Len(aTriggerCpo) > 0 .And. Ascan(aTriggerCpo,{|x| x== "D1_CC"})  > 0
			aCols[n][nPosCC] := SB1->B1_CC
		Else	
			aCols[n][nPosCC] := IIF(Empty(aCols[n][nPosCC]),SB1->B1_CC,aCols[n][nPosCC])
		EndIf
	Else
		aCols[n][nPosCC] := IIF(Empty(aCols[n][nPosCC]),SB1->B1_CC,aCols[n][nPosCC])
	EndIf		
EndIf
If nPosConta > 0
	If lMT103CPO
		If Len(aTriggerCpo) > 0 .And. Ascan(aTriggerCpo,{|x| x== "D1_CONTA"})  > 0 
			aCols[n][nPosConta] := IIF(Empty(aCols[n][nPosConta]),SB1->B1_CONTA,aCols[n][nPosConta])
		Else
			aCols[n][nPosConta] := SB1->B1_CONTA		
		EndIf
	Else
		aCols[n][nPosConta] := SB1->B1_CONTA
	EndIf
EndIf
If nPosItCt > 0
	If lMT103CPO
		If Len(aTriggerCpo) > 0 .And. Ascan(aTriggerCpo,{|x| x== "D1_ITEMCTA"})  > 0
			aCols[n][nPosItCt] := SB1->B1_ITEMCC
		Else
			aCols[n][nPosItCt] := IIF(Empty(aCols[n][nPosItCt]),SB1->B1_ITEMCC,aCols[n][nPosItCt])
		EndIf
	Else
		aCols[n][nPosItCt] := IIF(Empty(aCols[n][nPosItCt]),SB1->B1_ITEMCC,aCols[n][nPosItCt])
	EndIf			
EndIf
If nPosClVl > 0
	If lMT103CPO
		If Len(aTriggerCpo) > 0 .And. Ascan(aTriggerCpo,{|x| x== "D1_CLVL"})  > 0
			aCols[n][nPosClVl] := SB1->B1_CLVL
		Else	
			aCols[n][nPosClVl] := IIF(Empty(aCols[n][nPosClVl]),SB1->B1_CLVL,aCols[n][nPosClVl])
		EndIf
	Else		
		aCols[n][nPosClVl] := IIF(Empty(aCols[n][nPosClVl]),SB1->B1_CLVL,aCols[n][nPosClVl])
	EndIf
EndIf
aCols[n][nPosLocal]	:= RetFldProd(SB1->B1_COD,"B1_LOCPAD")
If nPosQtSegum<>0
	aCols[n][nPosQtSegum] := 0
	a100SegUM()
EndIf
If nPosChassi > 0 .And. cPaisLoc == "BRA"
	aCols[n][nPosChassi] := SB1->B1_CHASSI
EndIf

If nPosTes > 0
    //Obtem a TES da aAutoItens quando for passado por Rotina Automatica
    If (Type("l103Auto") <> "U" .And. l103Auto) 
	    If Empty(aCols[n][nPosTes]) .And. nPosTesAut>0 .And. !IsInCallStack("TSFGrvNF") //Se foi chamado pelo TSF (Totvs Sped Fiscal), nao atualiza TES no Array
	    	aCols[n][nPosTes]:= aAutoItens[n][nPosTesAut][2]
	    EndIf
	    
	    //Se informou TES via rotina automatica funções fiscais só devem ser executadas 
    	//no preenchimento da TES pela funcao MsGetDAuto 
    	
		If nPosTesAut > 0 .And. !Empty(aAutoItens[n][nPosTesAut][2])
			lTesAuto := .T.
		EndIf	 
	EndIf
    If cPaisLoc <> "COL"
	    If (Empty(aCols[n][nPosTes]) .And. !Empty(RetFldProd(SB1->B1_COD,"B1_TE"))) .Or.;
	    	 (lMT103CPO .And. Len(aTriggerCpo) > 0 .And. Ascan(aTriggerCpo,{|x| x == "D1_TES"})  > 0  .And. !Empty(RetFldProd(SB1->B1_COD,"B1_TE")))
	 		SF4->(dbSetOrder(1))
			If SF4->(dbSeek(xFilial("SF4")+RetFldProd(SB1->B1_COD,"B1_TE")))
				If !RegistroOk("SF4",.F.)
					Aviso("A103NTES",STR0072+CHR(10)+STR0073+RetFldProd(SB1->B1_COD,"B1_TE"),{STR0038})
				Else              
					aCols[n][nPosTes] := RetFldProd(SB1->B1_COD,"B1_TE")
				EndIf
			EndIf
	    EndIf 
	    
		If !lTesAuto .And. MaFisFound("IT",n)
			If !Empty(aCols[n][nPosTes])
				MaFisAlt("IT_TES",aCols[n][nPosTes],n)
			EndIf
			If aCOLS[n][nPosTotal]<>0
				MaFisToCols(aHeader,aCols,N,"MT100")
			EndIf
		EndIf
	EndIf
EndIf
If Rastro(cProduto) .And. nPosDtValid > 0
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ P.E para manipular a data de validade do lote (D1_DTVALID) ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock('MT103DTLT')
		uRet := ExecBlock( 'MT103DTLT', .F., .F., {aCols[n][nPosCod], ;
												   aCols[n][nPosLocal], ;
								 				   aCols[n][nPosLoteCtl], ;
								 				   aCols[n][nPosDtValid]})
		
		If ValType( uRet ) == 'D'
			aCols[n][nPosDtValid] := uRet
			lDtValid := .F.
		EndIf
	EndIf	
	If lDtValid
		aCols[n][nPosDtValid]:= IIF(Empty(aCols[n][nPosDtValid]),dDataBase + SB1->B1_PRVALID,aCols[n][nPosDtValid]) // Proteje a sobreposicao da data caso o usuario de get no produto ao classificar o produto.
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o pedido de compra eh valido                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nPosPedido > 0 
	If !Empty(aCols[n][nPosPedido])
		dbSelectArea("SC7")
		dbSetOrder(14)
		If MsSeek(xFilial("SC7")+aCols[n][nPosPedido]+aCols[n][nPosItemPC])
			If SC7->C7_PRODUTO <> cProduto
				aCols[n][nPosPedido]	:= Space(Len(aCols[n][nPosPedido]))
				aCols[n][nPosItemPC]	:= Space(Len(aCols[n][nPosItemPC]))
			EndIf
			If !Empty(SC7->C7_LOCAL)
				aCols[n][nPosLocal] := SC7->C7_LOCAL
			EndIf
		EndIf
	EndIf
EndIf

//-- Preenche entidades contabeis com cadastro do prod. ou PC
FillCTBEnt(If(Empty(nPosPedido) .Or. Empty(aCols[n,nPosPedido]),"SB1","SC7"),n)

RestArea(aArea)
Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103Trigge³ Autor ³ Edson Maricate        ³ Data ³07.01.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta funcao indica ao sistema que uma referencia de imposto  ³±±
±±³          ³foi alterado em um gatilho                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Nome do campo alterado                                ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T. Se o campo esta no aHeader                        ³±±
±±³          ³       .F. Se o campo nao esta no aHeader                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar as referencias que   ³±±
±±³          ³foram alteradas atraves de um gatilho do dicionario de dados ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103Trigger(cCampo)

Local aArea 	:= GetArea()
Local aRefer    := {}
Local lRetorno	:= .T.
Local nPosCpo	:= aScan(aHeader,{|x| AllTrim(x[2])==AllTrim(cCampo)})
If nPosCpo > 0
	aRefer := MaFisGetRF(aHeader[nPosCpo][6])
	If !Empty(aRefer[1])
		MaFisRef(aRefer[1],aRefer[2],aCols[N,nPosCpo])
		If cPaisLoc <>"BRA"
			ModxAtuObj()
		EndIf
	EndIf
Else
	lRetorno := .F.
EndIf
Eval(bRefresh)
RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103Total ³ Autor ³ Edson Maricate        ³ Data ³07.01.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina valida a digitacao do valor total do item do docu³±±
±±³          ³mento de entrada                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Valor do total digitado                               ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se o valor eh valido                           ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo verifica se o valor informado  ³±±
±±³          ³como total do item do documento de entrada eh valido         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103Total(nTotal)

Local aArea	   := GetArea()
Local nPQuant  := GetPosSD1("D1_QUANT")
Local nPPreco  := GetPosSD1("D1_VUNIT")
Local nPTes    := GetPosSD1("D1_TES"  )
Local nPQSegUm := GetPosSD1("D1_QTSEGUM")
Local nQtSegUm := 0
Local nDif	   := 0
Local cTes     := ""
Local lRetorno := .T.
If cPaisLoc  == "PAR"
	If nPQuant > 0 .And. nPPreco > 0 .And. aCols[n][nPQuant] > 0
		nDif := Abs(NoRound(aCols[n][nPQuant]*aCols[n][nPPreco],MsDecimais(Mafisret(,"NF_MOEDA")))-nTotal)
	EndIf
Else
	If nPQuant > 0 .And. nPPreco > 0 .And. aCols[n][nPQuant] > 0 .And. aCols[n][nPPreco] > 0
		nDif := Abs(NoRound(aCols[n][nPQuant]*aCols[n][nPPreco],2)-nTotal)
	EndIf
EndIf

If nPQSegUm > 0
	nQtSegUm := aCols[n][nPQSegUm]
EndIf

If nPTES > 0
	cTes := aCols[n][nPTES]
	if cTes==NIL
	    cTes:=''
	endif
EndIf

// Total pela segunda unidade de medida
If SuperGetMV("MV_CALC2UM")		// indica se irá recalcular o valor unitario pelo total caso exista 2 unidade de medida
	If nQtSegUm > 0 .And. nDif > 0.49
		aCols[n][nPPreco] := nTotal / aCols[n][nPQuant]
		If	MaFisFound("IT",n)
			MaFisAlt("IT_PRCUNI",aCols[n][nPPreco],n)
		EndIf

		If cPaisLoc  == "PAR"
			If nPQuant > 0 .And. nPPreco > 0 .And. aCols[n][nPQuant] > 0
				nDif := Abs(NoRound(aCols[n][nPQuant]*aCols[n][nPPreco],MsDecimais(Mafisret(,"NF_MOEDA")))-nTotal)
			EndIf
		Else
			If nPQuant > 0 .And. nPPreco > 0 .And. aCols[n][nPQuant] > 0
		nDif := Abs(NoRound(aCols[n][nPQuant]*aCols[n][nPPreco],2) - nTotal)
	EndIf
		EndIf
	EndIf
Endif

If cPaisLoc=="PAR"
	If cTipo$"NDB" .And. !MaTesSel(cTES) .And. (IIf(MsDecimais(Mafisret(,"NF_MOEDA"))==0,nDif > 1.00,nDif > 0.49) )
		Help(" ",1,"TOTAL")
		lRetorno := .F.
	EndIf
Else
	If cTipo$"NDB" .And. !MaTesSel(cTES) .And. nDif > 0.49
	Help(" ",1,"TOTAL")
	lRetorno := .F.
	EndIf
EndIF
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Este IF tem como finalidade atualizar o valor total do item no rodapeh da NF³
//³    quando digitamos o valor total do item. Apenas na PRE-NOTE (MATA140)    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Upper (AllTrim (FunName ()))=="MATA140"
	Eval (bRefresh,,,nTotal)
EndIf

RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeNfS2Acols³ Autor ³ Edson Maricate      ³ Data ³07.01.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina atualiza o acols com base no item do documento de³±±
±±³          ³saida                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Numero do registro do item do documento de saida      ³±±
±±³          ³ExpN2: Item do acols no documento de entrada                 ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Sempre .T.                                            ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar a funcao fiscal com  ³±±
±±³          ³base no item do documento de saida e atualizar o acols tb.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeNfs2Acols(nRecSD2,nItem)

Local aArea		 := GetArea()
Local aAreaSD2	 := SD2->(GetArea())
Local cMvNFEAval :=	GetNewPar( "MV_NFEAFSD", "000" )
Local cNfFilOri	 := ""
Local nPQuant    := 0
Local nValor     := 0
Local nPValAcRS  := 0
Local nPD1FilOri := 0
Local nPDesc     := 0
Local aIndA1U	 := {}
Local cUfTransp	 := ""
Local nX 		 := 1

If IsInCallStack("COMXCOL")
	For nX := 1 to nItem 
		If !MaFisFound("IT",nX)
			MaFisAdd("","",0,0,0,CriaVar("D1_NFORI"),CriaVar("D1_SERIORI"),,0,0,0,0,0)
		EndIf
	Next nX
Endif

MaColsToFis(aHeader,aCols,nItem,"MT100",.T.)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona na item da Nota Original          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nPQuant   := GetPosSD1("D1_QUANT")
nPValAcRS := GetPosSD1("D1_VALACRS")
nPDesc    := GetPosSD1("D1_DESC")

//Campo D1_FILORI precisa estar como usado para buscar por filial diferente de xFilial("SF2") - usado pela rotina LOJA720 do modulo SIGALOJA
nPD1FilOri:= GetPosSD1("D1_FILORI")
If nPD1FilOri > 0 .And. !Empty(aCols[nItem][nPD1FilOri])  
	cNfFilOri := aCols[nItem][nPD1FilOri]
Else
	cNfFilOri := xFilial("SF2")
EndIf

dbSelectArea("SD2")
MsGoto(nRecSD2)
dbSelectArea("SF2")
dbSetOrder(1)
MsSeek(cNfFilOri+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Dispara o ponto para cada item da NF        ³
//³ Executa somente se nao for uma chamada da   ³
//³ A103VLDNFO - Preservando comportamento		³
//³ original - Executa somente 1 vez por linha  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock( "MT103INF" ) .And. !IsInCallStack("A103VldNFO") 
	ExecBlock( "MT103INF", .F., .F., { nItem } ) 	
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza a Funcao Fiscal                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If MaFisRet(nItem,"IT_RECORI")<>nRecSD2
	MaFisAlt("IT_RECORI",nRecSD2,nItem)
EndIf
//Se for integração EAI, não troca a UF de origem
If !IsInCallStack("MATI103") .And. !IsInCallStack("TMSA500ANU") .And. !IsInCallStack("CANANULA")
	If cPaisLoc == "BRA" 
		cUfTransp := If(Type("aInfAdic") <> "U" .And. Len(aInfAdic) > 0,aInfAdic[10],"") //Se foi enviado o campo F1_UFORITR
	Endif
	// Manter o estado da Nota de Saida mesmo para venda com Cupom Fiscal (LOJA).
	If MaFisRet(,"NF_UFORIGEM")<>SF2->F2_EST .and. (cTipo == "D" .and. Empty(cUfTransp))
		MaFisAlt("NF_UFORIGEM",SF2->F2_EST)
		cUfOrig := SF2->F2_EST   
	EndIf
EndIf
If SD2->D2_DESCZFR <> 0
	nValor := A410Arred(IIF(SD2->D2_QUANT-aCols[nItem][nPQuant] == 0 , SD2->D2_DESCZFR, (SD2->D2_DESCZFR/SD2->D2_QUANT)*aCols[nItem][nPQuant]),"D2_DESCZFR")	
	MaFisAlt("IT_DESCZF",nValor,nItem)
	
	nValor := A410Arred(IIF(SD2->D2_QUANT-aCols[nItem][nPQuant] == 0 , SD2->D2_DESCZFC, (SD2->D2_DESCZFC/SD2->D2_QUANT)*aCols[nItem][nPQuant]),"D2_DESCZFC")
	MaFisAlt("IT_DESCZFCOF",nValor,nItem)
	
	nValor := A410Arred(IIF(SD2->D2_QUANT-aCols[nItem][nPQuant] == 0 , SD2->D2_DESCZFP, (SD2->D2_DESCZFP/SD2->D2_QUANT)*aCols[nItem][nPQuant]),"D2_DESCZFP")
	MaFisAlt("IT_DESCZFPIS",nValor,nItem)
EndIf

If !Empty(SD2->D2_CODISS)
	MaFisAlt("IT_CODISS",SD2->D2_CODISS,nItem)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Agrega o Frete/Desp/Seguro  referente a NF Retornada  ³
//| de acordo com o parametro MV_NFEAFSD 				  ³
//ÀÄÄÄÄ--ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ           
If SD2->D2_VALFRE <> 0     
    If len(cMvNFEAval)>=1
        If Substr(cMvNFEAval,1,1)=="1"     
            nValor := A410Arred(IIF(SD2->D2_QUANT-aCols[nItem][nPQuant] == 0 , SD2->D2_VALFRE, (SD2->D2_VALFRE/SD2->D2_QUANT)*aCols[nItem][nPQuant]),"D1_VALFRE")
			MaFisAlt("IT_FRETE",nValor,nItem)
		EndIf
	EndIf                  
EndIf

If SD2->D2_SEGURO <> 0
    If len(cMvNFEAval)>=2
        If Substr(cMvNFEAval,2,1)=="1"
 	        nValor := A410Arred(IIF(SD2->D2_QUANT-aCols[nItem][nPQuant] == 0 , SD2->D2_SEGURO, (SD2->D2_SEGURO/SD2->D2_QUANT)*aCols[nItem][nPQuant]),"D1_SEGURO")
			MaFisAlt("IT_SEGURO",nValor,nItem)
        EndIf
    EndIf
EndIf

If SD2->D2_DESPESA <> 0
    If len(cMvNFEAval)=3
        If Substr(cMvNFEAval,3,1)=="1"
    	    nValor := A410Arred(IIF(SD2->D2_QUANT-aCols[nItem][nPQuant] == 0 , SD2->D2_DESPESA, (SD2->D2_DESPESA/SD2->D2_QUANT)*aCols[nItem][nPQuant]),"D1_DESPESA")
			MaFisAlt("IT_DESPESA",nValor,nItem)
	    EndIf
    EndIf
EndIf       

//Obtém o valor do Acrescimo Financeiro na Nota de Origem e faz o rateio //
If nPValAcRS >0 
    If SD2->D2_VALACRS >0
 	    aCols[nItem][nPValAcRS] := ( SD2->D2_VALACRS / SD2->D2_QUANT ) * aCols[nItem][nPQuant]
    EndIf
Endif

If SD2->D2_DESC <> 0 .And. nPDesc > 0 .And. aCols[nItem][nPDesc] == 0 
	aCols[nItem][nPDesc] := SD2->D2_DESC
EndIf

If cPaisLoc == "BRA" .And. Type("lIntermed") == "L" .And. lIntermed .And. cFormul == "S"
	aIndA1U	:= GetAdvFVal("SC5",{"C5_INDPRES","C5_CODA1U"},xFilial("SC5") + SD2->D2_CLIENTE + SD2->D2_LOJA + SD2->D2_PEDIDO,3)
	If Len(aIndA1U) > 0
		If !Empty(aIndA1U[1])
			aInfAdic[16] := aIndA1U[1]
		Endif
		If !Empty(aIndA1U[2])
			aInfAdic[17] := aIndA1U[2]
		Endif
	Endif
Endif 

MaFisToCols(aHeader,aCols,nItem,"MT100")

RestArea(aArea)
RestArea(aAreaSD2)
Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeNfe2Aco³ Autor ³ Edson Maricate        ³ Data ³07.01.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina atualiza o acols com base no item do documento de³±±
±±³          ³entrada                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Numero do registro do item do documento de entrada    ³±±
±±³          ³ExpN2: Item do acols no documento de entrada                 ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Sempre .T.                                            ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar a funcao fiscal com  ³±±
±±³          ³base no item do documento de entrada e atualizar o acols tb. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeNfe2Acols(nRecSD1,nItem)

Local aArea		:= GetArea()
Local aAreaSD1	:= SD1->(GetArea())
Local lAtualiza := .F.
Local aIndA1U	:= {}

dbSelectArea("SD1")
MsGoto(nRecSD1)

If MaFisFound("NF")
	If MaFisRet(nItem,"IT_NFORI")<>SD1->D1_DOC
		MaFisAlt("IT_NFORI",SD1->D1_DOC,nItem)
		lAtualiza := .T.
	EndIf
	If MaFisRet(nItem,"IT_SERORI")<>SD1->D1_SERIE
		MaFisAlt("IT_SERORI",SD1->D1_SERIE,nItem)
		lAtualiza := .T.	
	EndIf
	If MaFisRet(nItem,"IT_RECORI")<>nRecSD1
		MaFisAlt("IT_RECORI",nRecSD1,nItem)
		lAtualiza := .T.
	EndIf
Endif

If lAtualiza
	MaColsToFis(aHeader,aCols,nItem,"MT100",.T.)
EndIf

If lAtualiza
	If cPaisLoc == "BRA" .And. Type("lIntermed") == "L" .And. lIntermed .And. cFormul == "S"
		aIndA1U	:= GetAdvFVal("SF1",{"F1_INDPRES","F1_CODA1U"},xFilial("SF1") + SD1->D1_DOC + SD1->D1_SERIE + SD1->D1_FORNECE + SD1->D1_LOJA + SD1->D1_TIPO,1)
		If Len(aIndA1U) > 0
			If !Empty(aIndA1U[1])
				aInfAdic[16] := aIndA1U[1] 
			Endif
			If !Empty(aIndA1U[2])
				aInfAdic[17] := aIndA1U[2]
			Endif 
		Endif
	Endif
Endif

If bGdRefresh<>Nil
	Eval(bGDRefresh)
EndIf

RestArea(aArea)
RestArea(aAreaSD1)
Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfePC2Acol³ Autor ³ Edson Maricate        ³ Data ³27.01.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina atualiza o acols com base no item do pedido de   ³±±
±±³          ³compra                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1 : Numero do registro do SC7                            ³±±
±±³          ³ExpN2 : Item da NF                                           ³±±
±±³          ³ExpN3 : Saldo do Pedido                                      ³±±
±±³          ³ExpC1 : Item a ser carregado no aCols ( D1_ITEM )            ³±±
±±³          ³ExpL1 : Indica se os dados da Pre-Nota devem ser preservados ³±±
±±³          ³ExpA1 : Valores das despesas acessorias do pedido de compras ³±±
±±³          ³ExpA2 : Cabecalho do rateio                                  ³±±
±±³          ³ExpA3 : Itens do rateio                                      ³±±
±±³          ³ExpN4 : Preco unitário na Pré-Nota						   ³±±
±±³          ³ExpL2 : Indica se nota foi importada pelo TOTVS Colaboracao  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Sempre .T.                                            ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar a funcao fiscal com  ³±±
±±³          ³base no item do pedido de compra.                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NFePC2Acol(nRecSC7,nItem,nSalPed,cItem,lPreNota,aRateio,aHeadSDE,aColsSDE,nPrUPreNf,lTColab)

Local aArea		   := GetArea()
Local aAreaSC7	   := SC7->(GetArea())
Local aAreaSF4	   := SF4->(GetArea())
Local aAreaSB1	   := SB1->(GetArea())
Local aAreaSC1     := SC1->(GetArea())
Local aAreaSTJ
Local aRefSC7      := MaFisSXRef("SC7")

Local cNGMNTNO	   := SuperGetMV("MV_NGMNTNO",.F.,"2")
Local cMVARRPEDC   := SuperGetMV("MV_ARRPEDC", .F., "")

Local lRateioPC    := SuperGetMv("MV_NFEDAPC")
Local lAllPC       := .T.
Local lAltImpPreNf := .F.
Local lMaFisFound  := MaFisFound()
Local lMT103IPC	   := ExistBlock( "MT103IPC",,.T. )
Local lMT103RCC	   := ExistBlock( "MT103RCC",,.T. )
Local lMT103IP2	   := ExistBlock( "MT103IP2",,.T. )
Local lRateioDE	   := .F.
Local lTOPDRFRM    := FindFunction("A120RDFRM") .And. A120RDFRM("A103")

Local nQuantPed    := 0
Local nX           := 0   
Local nCntFor      := 0 
Local nValUnit     := 0
Local nValFre      := 0
Local nValDesc     := 0
Local nValDesp     := 0
Local nValSeg      := 0
Local nValTot      := 0
Local nPosQtd      := GetPosSD1("D1_QUANT")
Local nPosQtd2     := GetPosSD1("D1_QTSEGUM")
Local nPosTes      := GetPosSD1("D1_TES")
Local nPosVunit    := GetPosSD1("D1_VUNIT")
Local nPosBicm     := GetPosSD1("D1_BASEICM")
Local nPosPicm     := GetPosSD1("D1_PICM")
Local nPosVicm     := GetPosSD1("D1_VALICM")
Local nPosBipi     := GetPosSD1("D1_BASEIPI")
Local nPosIpi      := GetPosSD1("D1_IPI")
Local nPosVipi     := GetPosSD1("D1_VALIPI")
Local nPValFret	   := GetPosSD1("D1_VALFRE")
Local nPValDesc	   := GetPosSD1("D1_VALDESC")
Local nPValDesp	   := GetPosSD1("D1_DESPESA")
Local nPValSeg	   := GetPosSD1("D1_SEGURO")
Local nPVOrdem 	   := GetPosSD1("D1_ORDEM")
Local nPMSIPC	   := GetNewPar("MV_PMSIPC",2)
Local aVencReal    := {}
Local dVencReal    := Ctod("")
Local lXmlxped	   := .F.
Local lPropFret    := SuperGetMV("MV_FRT103E",.F.,.T.)//Proporcionalização de frete.

DEFAULT aHeadSDE  := {}
DEFAULT aColsSDE  := {}

DEFAULT lPreNota := .F.
DEFAULT lTColab  := .F.
DEFAULT aRateio  := {0,0,0}

If lTColab 
	lXmlxped := SuperGetMV("MV_XMLXPED",.F.,.F.) //.T. = Mantém dados provenientes da NF, .F. = Assume dados provenientes do pedido de compra
Endif

//-- Verifica a existencia do item do acols
If nItem == Nil .Or. nItem > Len(aCols)
	aadd(aCols,Array(Len(aHeader)+1))
	For nX := 1 to Len(aHeader)
		If IsHeadRec(aHeader[nX][2])
		    aCols[Len(aCols)][nX] := 0
		ElseIf IsHeadAlias(aHeader[nX][2])
		    aCols[Len(aCols)][nX] := "SD1"
		ElseIf Trim(aHeader[nX][2]) == "D1_ITEM"
			aCols[Len(aCols)][nX] 	:= IIF(cItem<>Nil,cItem,StrZero(1,Len(SD1->D1_ITEM)))
		Else
			aCols[Len(aCols)][nX] := CriaVar(aHeader[nX][2], (aHeader[nX][10] <> "V") )
		EndIf
		aCols[Len(aCols)][Len(aHeader)+1] := .F.
	Next nX
	nItem := Len(aCols)
EndIf

//Posiciona registros
dbSelectArea("SC7")
SC7->(MsGoto(nRecSC7))

lAllPC := SC7->C7_QUANT == nSalPed .And. Empty(SC7->C7_REAJUST)

dbSelectArea("SB1")
SB1->(dbSetOrder(1))
SB1->(DbSeek(xFilial("SB1")+SC7->C7_PRODUTO))

If !lXmlxped
	nQuantPed:= SC7->C7_QUANT
	nValFre  := SC7->C7_VALFRE
	nValDesc := SC7->C7_VLDESC 
	nValDesp := SC7->C7_DESPESA
	nValSeg  := SC7->C7_SEGURO
	If !Empty(cMVARRPEDC) .AND. AllTrim(Upper(cMVARRPEDC)) == "NOROUND"
		nValUnit := NoRound(NfePcReaj(SC7->C7_REAJUST,lReajuste),TamSX3('D1_VUNIT')[2])
		nValTot := NoRound(nSalPed*nValUnit,TamSX3('D1_TOTAL')[2])
	Else
		nValUnit := Round(NfePcReaj(SC7->C7_REAJUST,lReajuste),TamSX3('D1_VUNIT')[2])
		nValTot := Round(nSalPed*nValUnit,TamSX3('D1_TOTAL')[2])
	EndIf
Else
	nValUnit := aCols[nItem][nPosVunit]
	nSalPed  := aCols[nItem][nPosQtd]
	nValFre	 := aCols[nItem][nPValFret]
	nValDesc := aCols[nItem][nPValDesc]
	nValDesp := IIF((nPValDesp > 0),aCols[nItem][nPValDesp],0)
	nValSeg  := IIF((nPValSeg > 0),aCols[nItem][nPValSeg],0)
	If !Empty(cMVARRPEDC)
		If AllTrim(Upper(cMVARRPEDC)) == "ROUND"
			nValTot := Round(nSalPed*nValUnit, TamSX3('D1_TOTAL')[2])
		ElseIf AllTrim(Upper(cMVARRPEDC)) == "NOROUND"
			nValTot := NoRound(nSalPed*nValUnit,TamSX3('D1_TOTAL')[2])
		EndIf
	Else
		nValTot := Round(nSalPed*nValUnit,TamSX3('D1_TOTAL')[2])
	EndIf
EndIf

//Carrega os impostos do pedido de compra para o Doc.Entrada
If lMaFisFound
	//Obtem a condicao de pagamento do pedido de compra
	If (l103Class .and. Empty(cCondicao)) .Or. !l103Class  
		cCondicao := Iif(l103Auto .And. !Empty(cCondicao), cCondicao, SC7->C7_COND)
		aVencReal := Condicao(1,cCondicao,,M->dDEmissao) // O valor (parametro 1) não interessa neste momento, mas a funcão Condição() não retorna nada se o primeiro paramentro for 0 (zero), por esse motivo tive que chumbar um valor (1).
		If Len(aVencReal) > 0
			dVencReal := aVencReal[1][1]
		Else
			dVencReal := dDataBase
		EndIf  
	EndIf

	MaFisIniLoad(nItem)
	For nX := 1 To Len(aRefSc7)
		Do Case
		Case aRefSC7[nX][2] == "IT_QUANT"
			If !lPreNota
				MaFisLoad(aRefSc7[nX][2],nSalPed,nItem)
			EndIf
		Case aRefSc7[nX][2] == "IT_PRCUNI"
			If !lPreNota
				MaFisLoad(aRefSc7[nX][2],nValUnit,nItem)
			EndIf
		Case aRefSc7[nX][2] == "IT_VALMERC"
			If !lPreNota
				MaFisLoad(aRefSc7[nX][2],nValTot,nItem)
			EndIf
		Case aRefSc7[nX][2] == "IT_DESCONTO"
			If !lPreNota
				MaFisLoad(aRefSc7[nX][2],xMoeda(((nValDesc/nQuantPed)* nSalPed),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA,),nItem)
			EndIf
		Case aRefSc7[nX][2] == "IT_VALEMB"
			MaFisLoad(aRefSc7[nX][2],xMoeda(SC7->C7_VALEMB,SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA,),nItem)
		Case aRefSc7[nX][2] == "IT_SEGURO"
			If lRateioPC
				MaFisLoad(aRefSc7[nX][2],xMoeda(((nValSeg/nQuantPed)*nSalPed),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA,),nItem)
			Else
				aRateio[1] += xMoeda(((nValSeg/nQuantPed)*nSalPed),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)
			EndIf
		Case aRefSc7[nX][2] == "IT_DESPESA"
			If lRateioPC
				MaFisLoad(aRefSc7[nX][2],xMoeda(((nValDesp/nQuantPed)*nSalPed),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA,),nItem)
			Else
				aRateio[2] += xMoeda(((nValDesp/nQuantPed)*nSalPed),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)
			EndIf
		Case aRefSc7[nX][2] == "IT_FRETE"
			If lRateioPC	
				MaFisLoad(aRefSc7[nX][2],xMoeda(((nValFre/nQuantPed)*nSalPed),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA,),nItem)
			Else
				aRateio[3] += xMoeda(((nValFre/nQuantPed)*nSalPed),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)
			EndIf
		Case aRefSc7[nX][2] == "IT_TES"
			If !Empty(SC7->C7_TES)
				dbSelectArea("SF4")
				SF4->(dbSetOrder(1))
				SF4->(DbSeek(xFilial("SF4")+SC7->C7_TES))				
				MaFisLoad("IT_CF",MaFisCFO(nItem,SF4->F4_CF),nItem)
			EndIf
		Case aRefSc7[nX][2] == "IT_BASEICM"
			nD1BaseIcm := SC7->(FieldGet(FieldPos(aRefSc7[nX][1])))
			If !lPreNota .Or. Empty(SD1->D1_BASEICM) .Or. SD1->D1_BASEICM == nD1BaseIcm
				If nD1BaseIcm <> 0
					MaFisLoad(aRefSc7[nX][2],nD1BaseIcm,nItem)
				Else
					lAltImpPreNf := .T.
				EndIf
			Else
				lAltImpPreNf := .T.
			EndIf
		Case aRefSc7[nX][2] == "IT_ALIQICM"
			nD1Picm := SC7->(FieldGet(FieldPos(aRefSc7[nX][1])))
			If !lPreNota .Or. Empty(SD1->D1_PICM) .Or. SD1->D1_PICM == nD1Picm
				If nD1Picm <> 0
					MaFisLoad(aRefSc7[nX][2],nD1Picm,nItem)
				Else
					lAltImpPreNf := .T.
				EndIf
			Else
				lAltImpPreNf := .T.
			EndIf
		Case aRefSc7[nX][2] == "IT_VALICM"
			nD1ValIcm	:= SC7->(FieldGet(FieldPos(aRefSc7[nX][1])))
			If !lPreNota .Or. Empty(SD1->D1_VALICM) .Or. SD1->D1_VALICM == nD1ValIcm
				If nD1ValIcm <> 0
					MaFisLoad(aRefSc7[nX][2],nD1ValIcm,nItem)
				Else
					lAltImpPreNf := .T.
				EndIf
			Else
				lAltImpPreNf := .T.
			EndIf			
		Case aRefSc7[nX][2] == "IT_BASEIPI"
			nD1BaseIpi	:= SC7->(FieldGet(FieldPos(aRefSc7[nX][1])))
			If !lPreNota .Or. Empty(SD1->D1_BASEIPI) .Or. SD1->D1_BASEIPI == nD1BaseIpi
				If nD1BaseIpi <> 0
					MaFisLoad(aRefSc7[nX][2],nD1BaseIpi,nItem)
				Else
					lAltImpPreNf := .T.
				EndIf				
			Else
				lAltImpPreNf := .T.
			EndIf
		Case aRefSc7[nX][2] == "IT_ALIQIPI"
			nD1AliqIpi := SC7->(FieldGet(FieldPos(aRefSc7[nX][1])))
			If !lPreNota .Or. Empty(SD1->D1_IPI) .Or. SD1->D1_IPI == nD1AliqIpi
				If nD1AliqIpi <> 0
					MaFisLoad(aRefSc7[nX][2],nD1AliqIpi,nItem)
				Else
					lAltImpPreNf := .T.
				EndIf				
			Else
				lAltImpPreNf := .T.
			EndIf
		Case aRefSc7[nX][2] == "IT_VALIPI"
			nD1ValIpi	:= SC7->(FieldGet(FieldPos(aRefSc7[nX][1])))	
			If !lPreNota .Or. Empty(SD1->D1_VALIPI) .Or. SD1->D1_VALIPI == nD1ValIpi
				If nD1ValIpi <> 0
					MaFisLoad(aRefSc7[nX][2],nD1ValIpi,nItem)
				Else
					lAltImpPreNf := .T.
				EndIf				
			Else
				lAltImpPreNf := .T.
			EndIf			
		OtherWise
			MaFisLoad(aRefSc7[nX][2],SC7->(FieldGet(FieldPos(aRefSc7[nX][1]))),nItem)
		EndCase
	Next nX
	MaFisEndLoad(nItem)
Else
	//Obtem a condicao de pagamento do pedido de compra
	cCondicao := SC7->C7_COND 
EndIf

//Atualiza o acols com base no pedido de compras
If !lPreNota
	For nCntFor := 1 To Len(aHeader)
		Do Case
		Case Trim(aHeader[nCntFor,2]) == "D1_COD"
			aCols[nItem,nCntFor] := SC7->C7_PRODUTO     
		Case Trim(aHeader[nCntFor,2]) == "D1_REVISAO"
			aCols[nItem,nCntFor] := SC7->C7_REVISAO
		Case Trim(aHeader[nCntFor,2]) == "D1_TOTAL"			
			aCols[nItem,nCntFor] := Round(nSalPed*Round(nValUnit,TamSX3('D1_VUNIT')[2]), TamSX3('D1_TOTAL')[2])
		Case Trim(aHeader[nCntFor,2]) == "D1_TES" .And. !Empty(SC7->C7_TES)
			aCols[nItem,nCntFor] := SC7->C7_TES
		Case Trim(aHeader[nCntFor,2]) == "D1_PEDIDO"
			aCols[nItem,nCntFor] := SC7->C7_NUM
		Case Trim(aHeader[nCntFor,2]) == "D1_QUANT" .Or. Trim(aHeader[nCntFor,2]) == "D1_SLDEXP"
			aCols[nItem,nCntFor] := nSalPed
		Case Trim(aHeader[nCntFor,2]) == "D1_VUNIT"
			aCols[nItem,nCntFor] := Round(nValUnit,TamSX3('D1_VUNIT')[2])
		Case Trim(aHeader[nCntFor,2]) == "D1_ITEMPC"
			aCols[nItem,nCntFor] := SC7->C7_ITEM
		Case Trim(aHeader[nCntFor,2]) == "D1_LOCAL"
			aCols[nItem,nCntFor] := SC7->C7_LOCAL
		Case Trim(aHeader[nCntFor,2]) == "D1_CC"
			aCols[nItem,nCntFor] := SC7->C7_CC     
		Case Trim(aHeader[nCntFor,2]) == "D1_OP"
			dbSelectArea("SC1")
			SC1->(dbSetOrder(1))
			SC1->(dbSeek(xFilial("SC1")+SC7->C7_NUMSC+SC7->C7_ITEMSC))
			If AllTrim(SC1->C1_ORIGEM) <> "MATA106" .And. (IIf(nPVOrdem > 0 ,Empty(aCols[nItem,nPVOrdem]) , .T.))
				aCols[nItem,nCntFor] := SC7->C7_OP
			EndIf			
		Case Trim(aHeader[nCntFor,2]) == "D1_ITEMCTA"			// Item Contabil
			aCols[nItem,nCntFor] := Iif( Empty(SC7->C7_ITEMCTA) .AND. SC7->C7_RATEIO !="1", SB1->B1_ITEMCC, SC7->C7_ITEMCTA )
		Case Trim(aHeader[nCntFor,2]) == "D1_CONTA"				// Conta Contabil
			aCols[nItem,nCntFor] := Iif( Empty(SC7->C7_CONTA) .AND. SC7->C7_RATEIO !="1", SB1->B1_CONTA, SC7->C7_CONTA )
		Case Trim(aHeader[nCntFor,2]) == "D1_CLVL"				// Classe de Valor
			aCols[nItem,nCntFor] := Iif( Empty(SC7->C7_CLVL) .AND. SC7->C7_RATEIO !="1", SB1->B1_CLVL, SC7->C7_CLVL )
		Case Trim(aHeader[nCntFor,2]) == "D1_UM"
			aCols[nItem,nCntFor] := SC7->C7_UM
		Case Trim(aHeader[nCntFor,2]) == "D1_SEGUM"
			aCols[nItem,nCntFor] := SC7->C7_SEGUM
		Case Trim(aHeader[nCntFor,2]) == "D1_QTSEGUM"
			aCols[nItem,nCntFor] := IIF(SB1->B1_CONV <> 0 .And. aCols[nItem][nPosQtd] <> 0, ConvUm(SB1->B1_COD,aCols[nItem][nPosQtd],aCols[nItem][nPosQtd2],2),SC7->C7_QTSEGUM) 
		Case Trim(aHeader[nCntFor,2]) == "D1_DESC"
			aCols[nItem,nCntFor] := SC7->C7_DESC
		Case Trim(aHeader[nCntFor,2]) == "D1_VALDESC"
			aCols[nItem,nCntFor] := xMoeda(((SC7->C7_VLDESC/SC7->C7_QUANT)* nSalPed) , SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)
		Case Trim(aHeader[nCntFor,2]) == "D1_RATEIO" 
			aCols[nItem,nCntFor] := SC7->C7_RATEIO
			If SC7->C7_RATEIO == "1"
				lRateioDE	:= .T.
			Endif
		Case Trim(aHeader[nCntFor,2]) == "D1_VALFRE"
			If nPValFret > 0
				aCols[nItem,nCntFor] := if(lPropFret,xMoeda(((SC7->C7_VALFRE/SC7->C7_QUANT)* nSalPed),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA),xMoeda(SC7->C7_VALFRE,SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA))
			EndIf
		Case Trim(aHeader[nCntFor,2]) == "D1_DESPESA"
			If nPValDesp > 0
				aCols[nItem,nCntFor] := xMoeda(((SC7->C7_DESPESA/SC7->C7_QUANT)* nSalPed) , SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)
			Endif
		Case Trim(aHeader[nCntFor,2]) == "D1_SEGURO"
			If nPValSeg > 0
				aCols[nItem,nCntFor] := xMoeda(((SC7->C7_SEGURO/SC7->C7_QUANT)* nSalPed) , SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)  
			Endif
		Case Trim(aHeader[nCntFor,2]) == "D1_CODGRP"
			aCols[nItem,nCntFor] := SB1->B1_GRUPO
		Case Trim(aHeader[nCntFor,2]) == "D1_CODITE"
			aCols[nItem,nCntFor] := SB1->B1_CODITE  
		Case Trim(aHeader[nCntFor,2]) == "D1_CLASFIS"
			dbSelectArea("SF4")
			SF4->(dbSetOrder(1))
			SF4->(DbSeek(xFilial("SF4")+SC7->C7_TES))		
			aCols[nItem,nCntFor] := SubStr(SB1->B1_ORIGEM,1,1)+SF4->F4_SITTRIB
		Case Trim(aHeader[nCntFor,2]) == "D1_IPI"
			If !Empty(SC7->C7_IPI)
				aCols[nItem,nCntFor] := SC7->C7_IPI
			Else
				aCols[nItem,nCntFor] := SB1->B1_IPI
			EndIf
		Case Trim(aHeader[nCntFor,2]) == "D1_PICM"
			If !Empty(SC7->C7_PICM)
				aCols[nItem,nCntFor] := SC7->C7_PICM
			Else
				aCols[nItem,nCntFor] := SB1->B1_PICM
			EndIf 
		Case Trim(aHeader[nCntFor,2]) == "D1_ITEMMED"
			aCols[nItem,nCntFor] := If( !Empty( SC7->C7_CONTRA ) .And. !Empty( SC7->C7_MEDICAO ), "1", "2" )
		//Nota de empenho	
		Case Trim(aHeader[nCntFor,2]) == "D1_CODNE"
			aCols[nItem,nCntFor] := SC7->C7_CODNE
		Case Trim(aHeader[nCntFor,2]) == "D1_ITEMNE"
			aCols[nItem,nCntFor] := SC7->C7_ITEMNE
		Case Trim(aHeader[nCntFor,2]) == "D1_DTVALID"
			If Rastro(SC7->C7_PRODUTO) 
				aCols[nItem,nCntFor] := dDatabase + SB1->B1_PRVALID
			Else
				aCols[nItem,nCntFor] := Ctod( '' )
			EndIf
		Case Trim(aHeader[nCntFor,2]) == "D1_ORDEM"
			aAreaSC1 := SC1->(GetArea())
			
			dbSelectArea("SC1")
			SC1->(dbSetOrder(1))
			SC1->(dbSeek(xFilial("SC1")+SC7->C7_NUMSC+SC7->C7_ITEMSC))
			If AllTrim(SC1->C1_ORIGEM) <> "MATA106"
				If cNGMNTNO == "1"
					aAreaSC1 := SC1->(GetArea())
					aAreaSTJ := STJ->(GetArea())
				
					If !Empty(SC7->C7_OP)
						dbSelectArea("STJ") 
						STJ->(dbSetOrder(1))
						
						cOPStj := SubStr(SC7->C7_OP,1,At("OS",SC7->C7_OP)-1)
						
						If !Empty(cOPStj) .And. STJ->(dbSeek(xFilial("STJ")+ cOPStj))
							aCols[nItem,nCntFor] := cOPStj			
						EndIf
					Else
						dbSelectArea("SC1")
						SC1->(dbSetOrder(1))
						If SC1->(dbSeek(xFilial("SC1")+SC7->C7_NUMSC+SC7->C7_ITEMSC))
							dbSelectArea("STJ")
							STJ->(dbSetOrder(1))
							
							cOPStj := if(!empty(SC1->C1_OS),SC1->C1_OS,SubStr(SC1->C1_OP,1,At("OS",SC1->C1_OP)-1))
							
							If !Empty(cOPStj) .And. STJ->(dbSeek(xFilial("STJ")+ cOPStj))
								aCols[nItem,nCntFor] := cOPStj
								NGSDCHKORDEM(cOPStj,nItem)
							Endif
						Endif
					EndIf
				
					RestArea(aAreaSTJ)
					RestArea(aAreaSC1)
				EndIf
			Endif
			RestArea(aAreaSC1)
		//Integração RM TOP x Protheus (Retenção/Dedução/Faturamento Direto)
		Case Type("lTOPDRFRM") <> "U" .And. lTOPDRFRM .And. Trim(aHeader[nCntFor,2]) == "D1_RETENCA" 
			aCols[nItem,nCntFor] := SC7->C7_RETENCA-SC7->C7_QUJERET
			
		Case Type("lTOPDRFRM") <> "U" .And. lTOPDRFRM .And. Trim(aHeader[nCntFor,2]) == "D1_DEDUCAO"
			aCols[nItem,nCntFor] := SC7->C7_DEDUCAO-SC7->C7_QUJEDED
			
		Case Type("lTOPDRFRM") <> "U" .And. lTOPDRFRM .And. Trim(aHeader[nCntFor,2]) == "D1_FATDIRE"
			aCols[nItem,nCntFor] := SC7->C7_FATDIRE-SC7->C7_QUJEFAT
		EndCase
	Next nCntFor
	FillCTBEnt("SC7",nItem)
	
	//Atualização de campos referente o modulo de Armazenagem - SIGAWMS	
	If IntWMS(SC7->C7_PRODUTO) 
		WmsAvalSD1("8","SD1",aCols,nItem,aHeader)
	EndIf

	If !lMaFisFound
		aRateio[1] += xMoeda(SC7->C7_SEGURO ,SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)
		aRateio[2] += xMoeda(SC7->C7_DESPESA,SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)
		aRateio[3] += xMoeda(SC7->C7_VALFRE ,SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)
	EndIf

	//Complementa o rateio da nota fiscal de saida com o rateio do pedido de compras
	If lRateioDE
		If Empty(aHeadSDE)
			dbSelectArea("SX3")
			SX3->(dbSetOrder(1))
			SX3->(DbSeek("SDE"))
			While SX3->(!EOF()) .And. SX3->X3_ARQUIVO == "SDE"
				IF X3Uso(SX3->X3_USADO) .AND. cNivel >= SX3->X3_NIVEL .And. !"DE_CUSTO" $ SX3->X3_CAMPO
					AADD(aHeadSDE,{TRIM(x3Titulo()),;
						SX3->X3_CAMPO,;
						SX3->X3_PICTURE,;
						SX3->X3_TAMANHO,;
						SX3->X3_DECIMAL,;
						SX3->X3_VALID,;
						SX3->X3_USADO,;
						SX3->X3_TIPO,;
						SX3->X3_F3,;
						SX3->X3_CONTEXT } )
				EndIf
				SX3->(dbSkip())
			EndDo
			//Adiciona os campos de Alias e Recno ao aHeader para WalkThru
			ADHeadRec("SDE",aHeadSDE)	
		Endif

		cItemRat := IIF(cItem<>Nil,cItem,StrZero(nItem,Len(SD1->D1_ITEM)))
		RatPed2NF(aHeadSDE,@aColsSDE,cItemRat,nRecSC7)
	Endif

	// 1 - utilização a associação automática com o PMS
	// 2 - não utiliza a associação automática com o PMS
	// default: não utilizar a associação automática
	If IntePMS() .And. nPMSIPC == 1
		PMS103IPC(nItem)
	EndIf

	//Efetua a chamada dos pontos de entrada
	If ExistTemplate( "MT103IPC",,.T. ) .AND. HasTemplate("MT103IPC")  
		ExecTemplate( "MT103IPC", .F., .F.,{nItem})
	EndIf

	//Agroindustria
	If FindFunction("OGXUtlOrig") .And. OGXUtlOrig()  //Encontra a função
		If FindFunction("OGX205") //Encontra a função
			OGX205() // Executa a função
		EndIf
	EndIf

	If lMT103IPC
		ExecBlock( "MT103IPC", .F., .F.,{nItem})
	EndIf
	
	If lMT103RCC
		aColsSDE := ExecBlock( "MT103RCC", .F., .F.,{aHeadSDE,aColsSDE})
	EndIf
EndIf

//Quando ha TES no pedido de compra, deve-se recalcular os
//impostos carregados para verificar se nao ha novos impostos
//que devem ser calculados!
If lMaFisFound
	Do Case
	Case cA100For+cLoja <> SC7->C7_FORNECE+SC7->C7_LOJA
		MaFisLoad("IT_TES","",nItem)	
		MaFisAlt("IT_ALIQICM",0,nItem)
		MaFisAlt("IT_ALIQIPI",0,nItem)
		If Empty(SC7->C7_TES)
			MaFisAlt("IT_TES",RetFldProd(SB1->B1_COD,"B1_TE"),nItem)
		Else
			MaFisAlt("IT_TES",SC7->C7_TES,nItem)				
		EndIf
	Case Empty(SC7->C7_TES) .And. !Empty(RetFldProd(SB1->B1_COD,"B1_TE"))
		MaFisLoad("IT_TES","",nItem)
		MaFisAlt("IT_TES",RetFldProd(SB1->B1_COD,"B1_TE"),nItem)
	Case Empty(SC7->C7_TES) .And. Empty(RetFldProd(SB1->B1_COD,"B1_TE")) .And. nPosTes > 0
		MaFisLoad("IT_TES","",nItem)
		MaFisAlt("IT_TES",IF( aCols[nItem,nPosTes] == Nil,CriaVar("D1_TES"),aCols[nItem,nPosTes] ),nItem,,,,,,dVencReal)
	Case !Empty(SC7->C7_TES)
		MaFisLoad("IT_TES","",nItem)
		MaFisAlt("IT_TES",SC7->C7_TES,nItem,,,,,,dVencReal)
		If lAllPC .And. !lAltImpPreNf
			// Quando for Relacionar o Pedido a Nf ou preço unitário da Pré-Nf for igual ao Pedido, entra na Rotina
			// Caso Preço Unitário da Pré-Nf for divergente do pedido, prevalece o preço da Pré-Nf mesmo que a quantidade do pedido seja igual.
		    
		    If nPrUPreNf == Nil .Or. (nPrUPreNf-SC7->C7_PRECO) == 0  
				For nX := 1 To Len(aRefSc7)
					Do Case
					Case !("IT_BAS"$aRefSc7[nX][2] .Or. "IT_VAL"$aRefSc7[nX][2] .Or. "IT_ALIQ"$aRefSc7[nX][2])
						//Não fazer nada
					case !Empty(SC7->(FieldGet(FieldPos(aRefSc7[nX][1]))))
						iF !(SUBSTR(aRefSc7[NX][2],4,3) $ 'BAS|VAL')
							MaFisAlt(aRefSc7[nX][2],SC7->(FieldGet(FieldPos(aRefSc7[nX][1]))),nItem)
						ELSE
							MaFisAlt(aRefSc7[nX][2],xMoeda(SC7->(FieldGet(FieldPos(aRefSc7[nX][1]))),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA,),nItem)
						ENDif
					EndCase
				Next nX
			EndIf
		EndIf		
		If lTColab
			aCols[nItem,nPosBicm] := MaFisRet(nItem,"IT_BASEICM")
			aCols[nItem,nPosPicm] := MaFisRet(nItem,"IT_ALIQICM")
			aCols[nItem,nPosVicm] := MaFisRet(nItem,"IT_VALICM")
			aCols[nItem,nPosBipi] := MaFisRet(nItem,"IT_BASEIPI")
			aCols[nItem,nPosIpi]  := MaFisRet(nItem,"IT_ALIQIPI")
			aCols[nItem,nPosVipi] := MaFisRet(nItem,"IT_VALIPI")
		EndIf
	EndCase

	//Ponto de entrada para tratamentos diversos após o recalculo de
	//impostos carregados a partir da TES correspondente
	If lMT103IP2
		ExecBlock( "MT103IP2", .F., .F.,{nItem})
	EndIf
	
	MaFisToCols(aHeader,aCols,Len(aCols),"MT100")
	aColsD1 := acols //Atualização necessária para que, o Array do Lançamento da Apuração de ICMS tenha o mesmos itens do acols da Nota Fiscal de Entrada.
EndIf

If cPaisLoc == "BRA" .And. Type("lIntermed") == "L" .And. lIntermed
	Eval(bRefresh,10)
Endif

RestArea(aAreaSB1)
RestArea(aAreaSF4)
RestArea(aAreaSC7)
RestArea(aArea)
Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfePcReaj ³ Autor ³ Edson Maricate        ³ Data ³28.01.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina atualiza o valor unitario do pedido de compra com³±±
±±³          ³base na cotacao da moeda                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 : Formula de reajuste                                  ³±±
±±³          ³ExpL2 : Indica se a formula de reajuste de ser aplicada      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1: valor unitario reajustado                             ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar o valor unitario do  ³±±
±±³          ³pedido de compra com base na taxa da moeda do dia            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NfePcReaj(cReajuste,lReajuste)

Local nPreco := 0
Local dBase  := dDataBase

dDataBase := dDEmissao
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o pedido de compra com base na cotacao da moeda     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nPreco := xMoeda(SC7->C7_PRECO,SC7->C7_MOEDA,1,M->dDEmissao,9,SC7->C7_TXMOEDA)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Aplica a formula de reajuste do pedido de compra             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(SC7->C7_REAJUST)
	If !Empty(cReajuste) .And. lReajuste
		nPreco := Formula(cReajuste)
	EndIf
EndIf
dDataBase := dBase
Return( nPreco )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeVldIni ³ Autor ³ Edson Maricate        ³ Data ³07.01.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina verifica se o documento de entrada pode ser      ³±±
±±³          ³incluido ou classificado                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 : Formula de reajuste                                  ³±±
±±³          ³ExpL2 : Indica se a formula de reajuste de ser aplicada      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1: valor unitario reajustado                             ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar a inclusao ou classifi-³±±
±±³          ³cacao do documento de entrada                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeVLDINI(lClass,lGeraLanc,lClaNfCfDv) 

Local lRet 	   := .F.
Local lRetPE   := .T.
Local dDataFec := MVUlmes()
Local lWmsCRD  := SuperGetMV("MV_WMSCRD",.F.,.F.)

Default lClaNfCfDv := .F.

Do Case
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verificar se a NF ja foi classificada.                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case lClass .And. SF1->F1_STATUS == "A"
	Help("  ",1,"A100CLASSI")
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verificar se a Pre-Nota foi bloqueada.                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case lClass .And. SF1->F1_STATUS == "B" .And. SuperGetMV("MV_RESTCLA",.F.,"2")=="1"
	Help("  ",1,"A103BLCLA")
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verificar data do ultimo fechamento em SX6.                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case dDataFec >= dDataBase
	Help( " ", 1, "FECHTO" )
	If ( Type("l103Auto") <> "U" .And. l103Auto )
		lRet := .F.
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica parametro MV_DATAFIS pela data de digitacao.        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case !FisChkDt(dDatabase)
	lRet := .F.
OtherWise
	lRet := .T.
EndCase

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Validacao para nao permitir a classificacao de pre-notas que possuem |
//| o parametro MV_DATAHOM configurado com o conteudo igual a "2"        |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. lClass .And. SuperGetMv("MV_DATAHOM",.F.,"1")=="2"
	If !Empty(SF1->F1_RECBMTO)
		If dDataFec >= SF1->F1_RECBMTO
			Help( " ", 1, "FECHTO" )
			lRet := .F.
		EndIf
	EndIf	
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Integracao com o modulo de Armazenagem - SIGAWMS                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. lClass .And. (IntWMS() .Or. lWmsCRD) .And. FindFunction("WmsAvalSF1") .And. SF1->F1_TIPO $ "N|D|B" //-- Validação se pode classificar a nota fiscal
	lRet := WmsAvalSF1("1","SF1")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se estiver trabalhando com Conferencia Fisica, verifica se esta em processo de conferencia|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. lClass .And. SuperGetMV("MV_CONFFIS") == "S"  
	If Len(AllTrim(SF1->F1_STATCON))>0   
		lClaNfCfDv := (SF1->F1_STATCON == "2" .And. SuperGetMv("MV_CLACFDV",.F.,.F.) .And. MsgYesNo(STR0149,STR0018) ) //"Esta nota está com bloqueio de divergencia na conferencia física do ACD, Deseja classifica-la mesmo assim?"
		If !lClaNfCfDv
			If SF1->F1_STATCON <> "1"
				lRet := .F. 
				Help(' ', 1, 'A103NFCONF')
			EndIf	
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada MT103INC                 |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. ExistBlock('MT103INC')
	lRet := If(ValType(lRetPE:=ExecBlock('MT103INC',.F.,.F.,lClass))=='L',lRetPE,.T.)
EndIf
Return(lRet)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103Alert³Autor³Edson Maricate          ³ Data ³15.02.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Aviso de que a almoxarifado nao existe                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA103                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103Alert(cProduto,cAlmox,lAuto)
Local lRet
Local cLinha1:= STR0011+ cAlmox + STR0012 //"O Armazem "###" nao existe para este produto. "
Local cLinha2:= STR0013 //"Deseja cria-lo agora ? "
Local aSvOrdem:={Alias(),IndexOrd(),Recno()}

DEFAULT lAuto := .F.

dbSelectArea("SB2")
If MsSeek(xFilial("SB2")+cProduto+cAlmox,.F.)
	Return .T.
EndIf
If lAuto
	lRet := .T.
Else
    If ExistBlock("M103XLERT")
		lRet:=ExecBlock("M103XLERT",.F.,.F.)
		If Valtype(lRet) <> "L" .and. lRet == .F.
			lRet:=.T.
		EndIf
  	Else
		TONE(3500,1)
		lRet := (MsgYesNo(OemToAnsi(cLinha1+cLinha2),STR0014+cProduto)) // //"Atencao - " 
	EndIf	
EndIf

If lRet
	CriaSB2(cProduto,cAlmox)
EndIf

dbSelectArea(aSvOrdem[1])
dbSetOrder(aSvOrdem[2])
MsGoto(aSvOrdem[3])

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103VldCC³ Autor ³ Edson Maricate         ³ Data ³02.02.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Efetua a validacao do Centro de Custo, Conta Contab. e Item ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA103                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103VldCC(aMuda)   
Local cVar			:= ReadVar()
Local lMostraHelp   := .F.
Local lRateio		:= .F.
Local nPosCC		:= GetPosSD1("D1_CC" )
Local nPosConta	    := GetPosSD1("D1_CONTA" )
Local nPosItemCta	:= GetPosSD1("D1_ITEMCTA" )
Local nPosRateio	:= GetPosSD1("D1_RATEIO" )
Local nPosCLVL		:= GetPosSD1("D1_CLVL" )
Local nPosPed		:= GetPosSD1("D1_PEDIDO" )
Local nPosItPc		:= GetPosSD1("D1_ITEMPC" )
Default aMuda       :={.T.,.T.,.T.,.T.} // CC,Conta,ItemCta e ClVl

If ExistBlock("MT103VCC")
	aMuda := ExecBlock("MT103VCC",.F.,.F.,aMuda)
	If !(ValType(aMuda) == "A" .And. Valtype(aMuda[1]) == "L" .And. Valtype(aMuda[2]) == "L" .And. Valtype(aMuda[3]) == "L" .And. Valtype(aMuda[4]) == "L")
		aMuda:={.T.,.T.,.T.,.T.} // CC,Conta,ItemCta e ClVl
	EndIf
EndIf

// Verifica se validacao esta partindo da pre-nota MATA140
If FunName() == "MATA140" .And. nPosPed > 0 .And. nPosItPc > 0
	If !Empty(aCols[n][nPosPed]) .And. !Empty(aCols[n][nPosItPc])
		SC7->(DbSetOrder(1))
		If SC7->(MsSeek(xFilial("SC7")+aCols[n][nPosPed]+aCols[n][nPosItPc]))
			If SC7->C7_RATEIO == "1"
				lRateio := .T.
			EndIf
		EndIf
	EndIf
EndIf

If ( nPosRateio > 0 .And. aCols[n][nPosRateio] == '1' ) .Or. lRateio 
	If nPosCC > 0 .And. aMuda[1]
		aCols[n][nPosCC]		:= Space(Len(aCols[n][nPosCC]))          
		If cVar == "M->D1_CC"   
			M->D1_CC		    	:= Space(Len(aCols[n][nPosCC]))
		EndIf
		
		lMostraHelp:= .T.
	Endif
	If nPosConta > 0 .And. aMuda[2]
		aCols[n][nPosConta]	 	:= Space(Len(aCols[n][nPosConta])) 
		If cVar == "M->D1_CONTA"   
			M->D1_CONTA 			:= Space(Len(aCols[n][nPosConta]))
		EndIf   
		
		lMostraHelp:= .T.
	Endif
	If nPosItemCta > 0 .And. aMuda[3]
		aCols[n][nPosItemCta]	:= Space(Len(aCols[n][nPosItemCta]))   
		If cVar == "M->D1_ITEMCTA"  
			M->D1_ITEMCTA			:= Space(Len(aCols[n][nPosItemCta]))
		EndIf
		
		lMostraHelp:= .T.
	Endif
	If nPosCLVL > 0 .And. aMuda[4]
		aCols[n][nPosCLVL]		:= Space(Len(aCols[n][nPosCLVL]))     
		If cVar == "M->D1_CLVL"  
			M->D1_CLVL				:= Space(Len(aCols[n][nPosCLVL]))
		EndIf
		
		lMostraHelp:= .T.
	Endif
	If lMostraHelp
		Help('   ',1,'A103RATEI')	
	EndIf
EndIf

Return .T.

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103ITDEV³ Autor ³ Edson Maricate         ³ Data ³07.04.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Consiste a Nota Fiscal Origem Digitada                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA103                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103ItDev(cItemOri)

Local nPosNfOri := GetPosSD1("D1_NFORI" )
Local nPosSerOri:= GetPosSD1("D1_SERIORI" )
Local nPosCfo	:= GetPosSD1("D1_CF" )
Local nPosCod   := GetPosSD1("D1_COD" )
Local nPosIT    := GetPosSD1("D1_ITEM" )
Local nPosITOri := GetPosSD1("D1_ITEMORI" )    
Local nPosFilOri:= GetPosSD1("D1_FILORI")
Local nPosFornec:= GetPosSD1("D1_FORNECE")
Local nPosLoja	:= GetPosSD1("D1_LOJA")
Local cFilOri	:= xFilial("SD2")
Local aArea		:= GetArea()
Local aAreaSD2	:= SD2->(GetArea())
Local aAreaSD1	:= SD1->(GetArea())
Local lRet 		:= .T.
Local lTrbGen   := IIf(FindFunction("ChkTrbGen"),ChkTrbGen("SD1", "D1_IDTRIB"),.F.) // Verificacao se pode ou nao utilizar tributos genericos
Local lMata143  := IsInCallStack("MATA143") .or.  IsInCallStack("MATA447")

Default l103Auto := .F.

If nPosNfOri > 0 .And. !Empty(aCols[n][nPosNfOri])
	If nPosFilOri > 0 .And. !Empty(aCols[n][nPosFilOri])
		cFilOri := aCols[n][nPosFilOri]
	Endif
Endif


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ COMPATIBILIZACAO !!Verifica se e utilizado a rotina MATA100  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type('l100') <> 'U' .And. l100
	If cPaisLoc == "BRA"
		Return A100ItDev()
	Else
		Return A100ItDev( cItemOri)
	EndIf
EndIf   

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Forca passagem pela validacao para Rot.Automática ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If l103Auto .And. Empty(cItemOri) .And. cPaisLoc <> "RUS" //-- Russia ULCD could add or remove items
	cItemOri:="x"
EndIf

If !Empty(cItemOri)
	If cTipo == "D" .Or. (cTipo == "B" .And. !FwIsInCallStack("MATI103A"))

		DbSelectArea("SF2")
		DbSetOrder(1)

		If ExistBlock("MT103SF2")
			ExecBlock("MT103SF2",.F.,.F.,{ aCols , nPosNfOri , nPosSerOri })
		Else
			MsSeek(xFilial("SF2",cFilOri) + aCols[n][nPosNfOri] + aCols[n][nPosSerOri] )
		EndIf

		dbSelectArea("SD2")
		dbSetOrder(3)
		If !MsSeek(xFilial('SD2',cFilOri)+aCols[n][nPosNfOri]+aCols[n][nPosSerOri]+SF2->F2_CLIENTE+SF2->F2_LOJA+aCols[n][nPosCod]+cItemOri)
			If MsSeek(xFilial("SD2",cFilOri)+aCols[n][nPosNFOri]+aCols[n][nPosSerOri]+SF2->F2_CLIENTE+SF2->F2_LOJA)
				While SD2->(!Eof()) .And.;										// Encontrou a nota e o item,
					SD2->D2_FILIAL == xFilial("SD2",cFilOri) .And.;					// porem o codigo do produto esta diferente.
					SD2->D2_DOC == aCols[n][nPosNFOri] .And.;					// Neste caso nao deve permitir a devolucao.
					SD2->D2_SERIE == aCols[n][nPosSerOri] .And.;
					SD2->D2_CLIENTE == SF2->F2_CLIENTE .And.;
					SD2->D2_LOJA == SF2->F2_LOJA
					If SD2->D2_ITEM == AllTrim(cItemOri)
						AVISO(STR0018,STR0150,{STR0038})						// Atencao # O codigo do produto para devolucao deve ser igual ao do item da nota original. # Ok
						lRet := .F.
					EndIf
					SD2->(dbSkip())
				EndDo
			EndIf
			If !l103Auto .And. lRet .And. !A103ExsSF8(cNFiscal,cSerie,cA100For,cLoja)
				If SuperGetMV("MV_VLDNFO",.F.,.F.)
					//De acordo com a legislação, não é obrigatório o preenchimento do doc. de origem para os CFOPs 1201,1202,1410,1411,5921 e 6921 em NF devolução
					If (("|"+AllTrim(StrTran(aCols[n][nPosCfo],".",""))+"|") $ "|1201|1202|1410|1411|") .AND. cTipo $ "D"
						lRet := .T.
					ElseIf Aviso(STR0018,STR0096+TRIM(aCols[n][nPosNfOri])+"/"+TRIM(aCols[n][nPosSerOri])+"-"+TRIM(aCols[n][nPosITOri])+"("+aCols[n][nPosIT]+") "+STR0097+CHR(13)+STR0098+" "+STR0099,{STR0016,STR0017}) == 2  
				       lRet := .F.
	    		    Else
	        		   lRet := .T.
		        	ENDIF
		   		EndIf
		  	Else 
				If SuperGetMV("MV_VLDNFO",.F.,.F.) .And. lRet
					//De acordo com a legislação, não é obrigatório o preenchimento do doc. de origem para os CFOPs 1201,1202,1410,1411,5921 e 6921 em NF devolução
					If !((("|"+AllTrim(StrTran(aCols[n][nPosCfo],".",""))+"|") $ "|1201|1202|1410|1411|") .AND. cTipo $ "D")
				  		Help(" ",1,"MT103NFO",,STR0096+TRIM(aCols[n][nPosNfOri])+"/"+TRIM(aCols[n][nPosSerOri])+"-"+aCols[n][nPosIT]+"  "+STR0097,1,0)
				  		lRet:=.F.
			  		EndIf
			 	EndIf
		  	EndIf
		Else
			If !MaFisFound("NF")
				MaFisEnd()
				MaFisIni(SF2->F2_CLIENTE,SF2->F2_LOJA,IIF(SF2->F2_TIPO$'DB',"F","C"),SF2->F2_TIPO,"P",,If(SF2->F2_TIPO=="C",AllTrim(SF2->F2_ORIGLAN),Nil),,,,,,,,,,,,,,,,,,,,,,,,,,lTrbGen)
			EndIf
			If IsInCallStack("A103LINOK")
				lRet := .T.
			Else 
				lRet := NfeNfs2Acols(SD2->(RecNo()),n)
			EndIf
				/* Valida se o cliente da Nota inserida é o mesmo cliente da Nota de Origem			
				-Para a rotina chamada pelo SIGALOJA rotina de Troca e Devolução não validar pois efetuamos troca para clientes diferentes
				-Nao executar validacao quando estiver utilizando sistema TSF - Fonte SPEDFILE03 (tratamento para Lojas CEM) 
				-Integração EAI não valida se usar parametro MV_VLDCDEV = .F. */			
			If SuperGetMV("MV_VLDNFO",.F.,.F.) .And. !IsInCallStack("TSFGrvNF") .And. !IsInCallStack("LOJA720") .And. cTipo != "B" .And. ; 
				!( IsInCallStack("MATI103") .And. !SuperGetMv("MV_VLDCDEV",.F.,.T.)) .And. !IsInCallStack("LOJA600") 
				If SF2->F2_CLIENTE <> cA100For
					Help(" ",1,"F4NAONOTA")
	        	    lRet := .F.
			   	EndIf
			EndIf
		EndIf
	ElseIf cTipo$"CPI" .Or. (cTipo == "B" .And. FwIsInCallStack("MATI103A"))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Valida se a Nota tem o mesmo numero da Nota de Origem  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lMata143 .And. Trim(aCols[n][nPosNfOri])==Trim(cNFISCAL) .And. Trim(aCols[n][nPosSerOri])==Trim(cSERIE) .And. CFORMUL=="N"
		    Help(" ",1,"MT103NFIG",,STR0094+CHR(13)+STR0095+" "+aCols[n][nPosIt],1,0)
	    	lRet := .F.
		ElseIf lMata143
			If Trim(aCols[n][nPosNfOri])==Trim(cNFISCAL) .And. Trim(aCols[n][nPosSerOri])==Trim(cSERIE)
				SF1->(DbSetOrder(1)) // F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA+F1_TIPO
				If SF1->(MsSeek(xFilial("SF1")+aCols[n][nPosNfOri]+aCols[n][nPosSerOri]+aCols[n][nPosFornec]+aCols[n][nPosLoja]))
					Help(" ",1,"MT103NFIG",,STR0094+CHR(13)+STR0095+" "+aCols[n][nPosIt],1,0) // "Documento de Entrada esta con el mismo Numero de Factura / Serie del Documento de Origen" - "Corrija el Numero del Documento de Entrada/Serie o Documento de Origen del item: "
					lRet := .F.
				EndIf
			EndIf
	    Endif      
	    
	    If lRet 
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Notas de Credito e Debito...                                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SF1")              
			DbSetOrder(1)
			
			if funname()=="MATA447"     
				nPosMx05:=ASCAN(aProvMT447B , {|x| x[1]+x[2]==aCols[n,nPosNfOri] + aCols[n,nPosSerOri]})  
				cA100For :=aProvMT447B[nPosMx05,3] 
				cLoja:=aProvMT447B[nPosMx05,4]
		    endif
			// Verifica se fornecedor esta preenchido para posicionar SF1 por fornecedor
			If ExistBlock("MT103SF1")
				ExecBlock("MT103SF1",.F.,.F.,{ aCols , nPosNfOri , nPosSerOri })
			Else
				If Type("cA100For") == "C" .And. !Empty(cA100For) .And. Type("cLoja") == "C" .And. !lMata143 .And. !FwIsInCallStack("MATI103A")
					MsSeek(xFilial("SF1") + aCols[n][nPosNfOri] + aCols[n][nPosSerOri] + cA100For + cLoja)
				Else
					MsSeek(xFilial("SF1") + aCols[n][nPosNfOri] + aCols[n][nPosSerOri] )
					If FindFunction("buscaRegCH")
						buscaRegCH(xFilial("SF1"),aCols[n][nPosNfOri],aCols[n][nPosSerOri],cA100For,aCols[n][nPosLoja],lMata143,aCols[n][27])	
					Endif
				EndIf
			EndIf

			dbSelectArea("SD1")
			dbSetOrder(1)
			If !MsSeek(xFilial('SD1')+aCols[n][nPosNfOri]+aCols[n][nPosSerOri]+SF1->F1_FORNECE+SF1->F1_LOJA+aCols[n][nPosCod]+cItemOri)
				If ( Type('l103Auto') <> 'U' .And. !l103Auto ) .And. !A103ExsSF8(cNFiscal,cSerie,cA100For,cLoja)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Nao e rotina automatica, emite aviso com a pergunta e aguarda  ³
					//³ resposta se deve ou nao aceitar a NF informada.                ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If SuperGetMV("MV_VLDNFO",.F.,.F.) 
						If Aviso(STR0018,STR0096+TRIM(aCols[n][nPosNfOri])+" "+STR0103+TRIM(aCols[n][nPosSerOri])+" "+STR0101+aCols[n][nPosIT]+" "+STR0097+CHR(13)+STR0098+" "+STR0099,{STR0016,STR0017}) != 1
							lRet := .F.
 						Else
							lRet := .T.                                                     
						EndIf
					EndIf
				ElseIf ( Type('l103Auto') <> 'U' .And. l103Auto ) .And. !A103ExsSF8(cNFiscal,cSerie,cA100For,cLoja)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Rotina automatica: se nao existir documento de origem, retorna ³
					//³ falso e nao permite continuar o processo, a menos que a NF de  ³
					//³ origem informada inicie com CIAP.                              ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If Upper(Substr(Trim(aCols[n][nPosNfOri]), 1, 4)) != 'CIAP' ;
						.And. !(Type('aAutoCab') <> 'U' ;
						.And. aScan(aAutoCab, {|x| x[1] == "COLAB" .And. x[2] == "S"}) > 0) //Se for TOTVS COLAB a verificação da nota ja foi feita e nesse ponto o fornecedor ja nao é mais o mesmo
						If SuperGetMV("MV_VLDNFO",.F.,.F.) 
			  				Help(" ",1,"MT103OINV",,STR0096+TRIM(aCols[n][nPosNfOri])+"/"+TRIM(aCols[n][nPosSerOri])+"-"+aCols[n][nPosIT]+"  "+STR0097,1,0)
					  		lRet:=.F.
					 	EndIf
					EndIf
				EndIf 
			ElseIf !FwIsInCallStack("PROCDOCS") .And. !FwIsInCallStack("MATI103A")  //Se documento veio do TOTVS Colaboração não deve passar pela função
				NfeNfe2Acols(SD1->(RecNo()),n)
			EndIf      
		EndIf
	EndIf
EndIf

RestArea(aAreaSD1)
RestArea(aAreaSD2)
RestArea(aArea)

Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103VldOP ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 04/02/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Valida a Ordem de Producao digitada na NF                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MatA103                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103VldOP()

Local lRet:=.T.,cOP:=&(ReadVar())
Local nPosPc  	:= GetPosSD1("D1_PEDIDO")
Local nPosItPc	:= GetPosSD1("D1_ITEMPC")
Local nPosCod	:= GetPosSD1("D1_COD")
Local nPosQuant	:= GetPosSD1("D1_QUANT")
Local nPosOs	:= GetPosSD1("D1_ORDEM")
//Local cSeek	  := ''	 
Local aAreaAnt:= GetArea()
Local aPosDhn	:= {}

If !Empty(cOp)
	lRet:=ExistCpo("SC2",cOp)
	If lRet
		SC2->(dbSetOrder(1))
		If SC2->(MsSeek(xFilial("SC2")+cOP)) .And. SC2->C2_TPOP == "P"
			Help(" ",1,"NOPPREVIST")
			lRet:=.F.
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Analisa se existe PC's amarrado a uma SC'a onde a SC's foi gerada |
	//| pela rotina de solicitacao ao armazem e ja foi informado o numero |
	//| da Ordem de Producao na Solicitacao ao Armazem.					  |	
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nPosPc > 0 .And. nPosItPc > 0
		If lRet .And. !Empty(aCols[n,nPosPC])
			dbSelectArea("SC7")
			dbSetOrder(1) //C7_FILIAL+C7_NUM+C7_ITEM+C7_SEQUEN
			If dbSeek(xFilial("SC7")+aCols[n,nPosPC]+aCols[n,nPosItPC])
			 	If !Empty(SC7->C7_NUMSC)
					//dbSelectArea("SCQ")
					//dbSetOrder(2)//CQ_FILIAL+CQ_NUMSC+CQ_ITSC
					//dbSeek(cSeek:=xFilial("SCQ")+SC7->C7_NUMSC+SC7->C7_ITEMSC)
					aPosDhn := COMPosDHN({3,{'1',xFilial("DHN"),SC7->C7_NUMSC,SC7->C7_ITEMSC}})
					If aPosDhn[1]
						Do While !((aPosDhn[2])->(Eof()))// .And. cSeek == xFilial("SCQ")+SCQ->CQ_NUMSC+SCQ->CQ_ITSC
							SCQ->(DbSetOrder(1))
							If SCQ->(DbSeek((aPosDhn[2])->(DHN_FILORI + DHN_DOCORI +  AllTrim(DHN_ITORI))))
								Do While !(DHN->(EoF())) .And. DHN->(DHN_FILORI + DHN_DOCORI +  AllTrim(DHN_ITORI)) == (aPosDhn[2])->(DHN_FILORI + DHN_DOCORI +  AllTrim(DHN_ITORI)) 
								    If !Empty(SCQ->CQ_OP)
										Aviso(STR0018,STR0044+" "+STR0045,{STR0038},2)						    	
										lRet := .F.  
										Exit
								    EndIf
								 	DHN->(DbSkip())
								EndDo
							EndIf
							(aPosDhn[2])->(dbSkip())
						EndDo
						(aPosDhn[2])->(DbCloseArea())
					EndIf
						
			 	EndIf
			EndIf
		EndIf
	EndIf
	
	//Valida a O.P quando integrado com o módulo de manutenção de ativos
	If nPosCod > 0 .And. nPosQuant > 0 .And. nPosOs > 0 .And. FindFunction("NGAPAGD1OR")
		If !NGAPAGD1OR(aCols[n,nPosOs],cOp,aCols[n,nPosCod],aCols[n,nPosQuant])
			lRet := .F.
		EndIf
	EndIf
	
EndIf

RestArea(aAreaAnt)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³ A103DtVld   ³Autor³Rodrigo de A. Sartorio³ Data ³ 05/03/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ So permite digitar a data de validade do lote apos usuario ³±±
±±³          ³ digitar o Lote de Controle.                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata103                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103DtVld(dDtValid)
Local lRet		 :=.T.
Local aAreaAnt   := GetArea()
Local aAreaSB8   := SB8->(GetArea())
Local nPosCodigo := GetPosSD1('D1_COD')
Local nPosLocal	 := GetPosSD1("D1_LOCAL")
Local nPosLote	 := GetPosSD1("D1_NUMLOTE")
Local nPosLotCTL := GetPosSD1("D1_LOTECTL")
Local nPosDvalid := GetPosSD1("D1_DTVALID")
Local nPosLotFor := GetPosSD1("D1_LOTEFOR")
Local lLoteVenc	 := SuperGetMV("MV_LOTVENC") == "S"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ POSICIONA A SB1  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SB1")
MsSeek(xFilial("SB1")+aCols[n,nPosCodigo])         

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ COMPATIBILIZACAO !!Verifica se e utilizado a rotina MATA100  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type('l100') <> 'U' .And. l100
	Return A100DtVld()
EndIf

If !( Type('l103Auto') <> 'U' .And. l103Auto ) .And. !Rastro(aCols[n,nPosCodigo]) .And. !Empty(aCols[n,nPosLote]) .And. !Empty(aCols[n,nPosLotCtl]) 
	Help(" ",1,"NAORASTRO")
	lRet:=.F.
EndIf

If lRet .And.  !Empty(dDtValid)
	If Empty(aCols[n,nPosLotFor]) .And. Empty(aCols[n,nPosLote]) .And. Empty(aCols[n,nPosLotCtl]) .And. !Empty(dDtValid) .And. !Rastro(aCols[n,nPosCodigo])
		M->D1_DTVALID := CTOD("  /  /  ")
		lRet:=.T.
	ElseIF lRet .And. dDtValid < dDataBase 
		//-- Verifica se permite a digitacao de datas de validade vencidas.
		If lLoteVenc 
			//-- Avisa ao usuario que a data de validade esta 
			//-- vencida, porem permite a movimentacao.
			If !(Type('l103Auto') <> 'U' .And. l103Auto)
				Help(" ",1,"LOTEVENC")
			EndIf	
		Else
			Help(" ",1,"DTVALIDINV")
			lRet:=.F.
		EndIf	
	EndIf
	
	SB8->(dbSetOrder(3))
	If lRet .And. SB8->(dbSeek(xFilial("SB8")+aCols[n,nPosCodigo]+aCols[n,nPosLocal]+aCols[n,nPosLotCTL]+IF(Rastro(aCols[n,nPosCodigo],"S"),aCols[n,nPosLote],"")))
		If dDtValid # SB8->B8_DTVALID
			If !( Type('l103Auto') <> 'U' .And. l103Auto )
				Help(" ",1,"A240DTVALI")
			EndIf	
			M->D1_DTVALID := SB8->B8_DTVALID               
			aCols[n,nPosDvalid] := SB8->B8_DTVALID
		EndIf		
	Endif		
Endif
	
RestArea(aAreaSB8)
RestArea(aAreaAnt)                      

Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103ZERA  ³ Autor ³ Edson Maricate        ³ Data ³03.05.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Zera Nota Fiscal de Origem e Serie da Nota                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA103                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103Zera()
Local aArea			:= GetArea()
Local nPosNFOri
Local nPosSerOri
Local nPosItmOri
Local nPosProd := GetPosSD1("D1_COD")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ COMPATIBILIZACAO !!Verifica se e utilizado a rotina MATA100  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type('l100') <> 'U' .And. l100
	Return A100Zera()
EndIf

If cTipo == "D" .And. Iif(nPosProd > 0, Rastro(aCols[n][nPosProd],"S"), .T.)
	nPosNFOri	:= GetPosSD1("D1_NFORI")
	nPosSerOri	:= GetPosSD1("D1_SERIORI")
	nPosItmOri	:= GetPosSD1("D1_ITEMORI")

	aCols[n][nPosNFOri]	:= CriaVar("D1_NFORI")
	aCols[n][nPosSerOri]	:= SerieNfId("SD1",5,"D1_SERIORI") 
	aCols[n][nPosItmori]	:= CriaVar("D1_ITEMORI")
   
	If MaFisFound("NF")     
		MaFisIniLoad(n)
		MaFisLoad("IT_NFORI",aCols[n][nPosNFOri],n)
		MaFisLoad("IT_SERORI",aCols[n][nPosSerOri],n)
		MaFisLoad("IT_RECORI",0,n)
		MaFisEndLoad(n)
	EndIf
EndIf

RestArea(aArea)
Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun??o   ³ A103LotCTL  ³Autor³Rodrigo de A. Sartorio³ Data ³ 22/11/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri??o³ Valida o lote de control digitado pelo usuario.            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata103                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function A103LotCTL()

Local cVar			:= ReadVar()
Local cConteudo		:= &(ReadVar())
Local cCod			:= aCols[n][GetPosSD1("D1_COD")]
Local nPosLote		:= GetPosSD1("D1_NUMLOTE")
Local nPosLotCTL	:= GetPosSD1("D1_LOTECTL")
Local nPosDvalid	:= GetPosSD1("D1_DTVALID")
Local nPosLocal		:= GetPosSD1("D1_LOCAL")
Local nPosTes		:= GetPosSD1("D1_TES")
Local aAreaAnt		:= GetArea()
Local aAreaSB8		:= {}
Local lRet			:= .T.
Local lRotAuto      := Type("l103Auto") == "L" .And. l103Auto
Local lSublPD3Ok    := .F.
Local cLoteCtlA  	:= ''
Local cBuscaSF4		:= ""
Local cBuscaSB8		:= ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ COMPATIBILIZACAO !!Verifica se e utilizado a rotina MATA100  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type('l100') <> 'U' .And. l100
	Return A100LotCTL()
EndIf

If !(Type('cLoteCtl')=='C')
	cLoteCtlA := CriaVar('D1_LOTECTL')
Else
	cLoteCtlA := cLoteCtl
EndIf

If (!Rastro(cCod) .And. cVar == "M->D1_NUMLOTE" .And. !Empty(cConteudo)) .Or. (!Rastro(cCod) .And. cVar == "M->D1_LOTECTL" .And. !Empty(cConteudo))
	If nPosLote > 0
		aCols[n, nPosLote]   := CriaVar("D1_NUMLOTE")
	EndIf
	aCols[n, nPosLotCTL] := CriaVar("D1_LOTECTL")
	aCols[n, nPosDValid] := CriaVar("D1_DTVALID")
	Help(" ",1,"NAORASTRO")
	lRet     := .F.
ElseIf !A103VlStr()
	lRet := .F.
ElseIf cVar == "M->D1_NUMLOTE" .And. !Empty(cConteudo)
	If cTipo == 'D' //-- NF Devolu??o
		dbSelectArea("SB8")
		aAreaSB8 := GetArea()
		dbSetOrder(2)
		If MsSeek(xFilial("SB8")+cConteudo+cLoteCtlA, .F.) .And. B8_PRODUTO+B8_Local == cCod+cLocal
			aAreaSB8[3]          := Recno()
			M->D1_LOTECTL        := SB8->B8_LOTECTL
			aCols[n, nPosLotCTL] := SB8->B8_LOTECTL
			If nPosLote > 0
				aCols[n, nPosLote]   := cConteudo
			EndIf
		Else
			M->D1_LOTECTL        := CriaVar("D1_LOTECTL")
			M->D1_DTVALID        := CriaVar("D1_DTVALID")
			If nPosLote > 0
				M->D1_NUMLOTE      := CriaVar("D1_NUMLOTE")
				aCols[n, nPosLote] := CriaVar("D1_NUMLOTE")
			EndIf
			aCols[n, nPosLotCTL] := CriaVar("D1_LOTECTL")
			aCols[n, nPosDValid] := CriaVar("D1_DTVALID")
		EndIf
		RestArea(aAreaSB8)
	Else
		// Valida sublote informado na rotina automatica de devolucao de poder de terceiros, se for valido mantem o sublote
		If lRotAuto .And. nPosTes > 0 .And. !Empty(aCols[n, nPosTes])
			cBuscaSF4 := xFilial("SF4") + aCols[n, nPosTes]
			If Posicione("SF4", 1, cBuscaSF4, "F4_PODER3") == "D"
				cBuscaSB8 := xFilial("SB8") + cConteudo + aCols[n, nPosLotCTL] + cCod + aCols[n, nPosLocal]
				If Posicione("SB8", 2, cBuscaSB8, "B8_NUMLOTE") == cConteudo
					lSublPD3Ok := .T.
				EndIf
			EndIf
		EndIf
		If !lSublPD3Ok
			M->D1_DTVALID        := CriaVar("D1_DTVALID")
			If nPosLote > 0
				M->D1_NUMLOTE        := CriaVar("D1_NUMLOTE")
				aCols[n, nPosLote]   := CriaVar("D1_NUMLOTE")
			EndIf
			aCols[n, nPosDValid] := CriaVar("D1_DTVALID")
		EndIf
	EndIf
ElseIf cVar == "M->D1_LOTECTL" .And. !Empty(cConteudo) 
	aAreaSB8 := GetArea()
	SB8->(dbSetOrder(3))
	If SB8->(dbSeek(xFilial("SB8")+cCod+aCols[n,nPosLocal]+cConteudo+IF(Rastro(cCod,"S"),aCols[n,nPosLote],"")))
		If aCols[n, nPosDValid] # SB8->B8_DTVALID 
			If Type('lMSErroAuto') <> 'L'
				Help(" ",1,"A240DTVALI")
			EndIf	
			M->D1_DTVALID := SB8->B8_DTVALID
			aCols[n,nPosDvalid] := SB8->B8_DTVALID						
		EndIf			
	Endif		
	RestArea(aAreaSB8)
EndIf

RestArea(aAreaAnt)

Return lRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³  A103PC  ³ Prog. ³Edson Maricate         ³Data  ³20.05.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Valida o pedido de compras digitado.                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³A103PC()                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA103,MATA140                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103PC()

Local nPosItemPC := GetPosSD1("D1_ITEMPC")

aCols[n][nPosItemPC] := CriaVar("D1_ITEMPC")

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103Item³ Prog. ³Edson Maricate           ³Data  ³20.05.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Valida o item do pedido digitado.                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³A103Item()                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA103,MATA140                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103Item()

Local aArea      := GetArea()
Local aAreaSC7   := SC7->(GetArea())
Local nPosQTD    := GetPosSD1("D1_QUANT" )
Local nPosPrd    := GetPosSD1("D1_COD" )
Local nPosPedido := GetPosSD1("D1_PEDIDO" )
Local nPosItemPC := GetPosSD1("D1_ITEMPC" )
Local nPItem     := GetPosSD1("D1_ITEM" )
Local nX         := 0
Local cItem      := &(ReadVar())
Local nPcToler   := 0
Local lTolerQtd  := .T.
Local lRet		 := .F.
Local lEic       := .F.
Local nFreeQt    := 0
Local lLibQt     := GETNEWPAR("MV_LIBQTEM", .F.)
Local lIs140auto := SuperGetMV("MV_IS140AU",.F.,.F.)
Local lXmlxped   := SuperGetMV("MV_XMLXPED",.F.,.F.)

If !Empty(aCols[n][nPosPedido])
	nRecC7 := A103RECC7(xFilial("SC7"),aCols[n][nPosPedido],cA100For,cLoja,aCols[n][nPosPrd],cItem)
	SC7->(DbGoTo(nRecC7))

	If Empty(SubStr(cItem,3)) .And. !Empty(SC7->C7_SEQUEN)
		lEic := .T.
	EndIf
	If !lEic .And. nRecC7 > 0
		nFreeQT := 0
		If !lEic
			For nx := 1 To Len( aCols )
				If (nx # n) .And. ;
					(aCols[ nx,nPosPrd] == SC7->C7_PRODUTO) .And. ;
					(aCols[ nx,nPosPedido] == SC7->C7_NUM) .And. ;
					(aCols[ nx,nPosItemPC] == SC7->C7_ITEM) .And. ;
					!ATail( aCols[nx] )
					nFreeQT += aCols[nx,nPosQTD]
				EndIf
			Next
		Else
			/*/
			For nx := 1 To Len( aCols )
				If (nx # n) .And. ;
					(aCols[ nx,nPosPrd] == C7_PRODUTO) .And. ;
					(aCols[ nx,nPosPedido] == C7_NUM) .And. ;
					(aCols[ nx,nPosItemPC] == C7_ITEM) .And. ;
					(aCols[ nx,nPITEM] == C7_SEQUEN) .And. ;
					!ATail( aCols[nx] )
					nFreeQT += aCols[nx,nPosQTD]
				EndIf
			Next
			/*/
		EndIf
		IF ValType(SuperGetMV("MV_PCTOLER",.F.,"0")) == "C"
			nPcToler := Val(SuperGetMV("MV_PCTOLER",.F.,"0"))/100
		Else
			nPcToler := SuperGetMV("MV_PCTOLER",.F.,0)/100
		EndIf
		If nPcToler > 0
			If aCols[n][nPosQtd] > (SC7->C7_QUANT+(SC7->C7_QUANT * nPcToler))
				lTolerQtd := .F.
			Endif
		Endif
		
		If ALTERA
			dbSelectArea("SD1")
			dbSetOrder(1)
			dbSeek(xFilial('SD1')+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+aCols[n][nPosPrd]+aCols[n][nPItem])
			nFreeQT -= SD1->D1_QUANT
		EndIf
		
		dbSelectArea("SC7")
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se nao h  residuos, se possui saldo em abto e   ³
		//³ se esta liberado por alcadas se houver controle.         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ((((nFreeQT:=((SC7->C7_QUANT+(SC7->C7_QUANT * nPcToler)))-SC7->C7_QUJE-SC7->C7_QTDACLA-nFreeQT) > 0) .Or. ((nFreeQT:=((SC7->C7_QUANT+(SC7->C7_QUANT * nPcToler)))-SC7->C7_QUJE-SC7->C7_QTDACLA-nFreeQT) >= 0 .AND. (FunName() == "MATA447")) ) .And. lTolerQtd .And. Empty(SC7->C7_RESIDUO) .And. IIf(SuperGetMV("MV_RESTNFE")=="S", SC7->C7_CONAPRO <> "B", .T.) .And. SC7->C7_TPOP <> "P") .Or. lLibQt	

			If cPaisLoc == "BRA"
				If Type("l140Auto")== "U"
					If IsInCallStack("COMXCOL")
						if !lXmlxped //.T. = Mantém dados provenientes da NF, .F. = Assume dados provenientes do pedido de compra vinculado
							NFEPC2ACOL(SC7->(RecNo()),n,IIf(Empty(aCols[n][nPosQtd]).Or.aCols[n][nPosQtd]>nFreeQt,nFreeQt,aCols[n][nPosQtd]),,,,,,,.T.)
						endif
					else 
						NFEPC2ACOL(SC7->(RecNo()),n,IIf(Empty(aCols[n][nPosQtd]).Or.aCols[n][nPosQtd]>nFreeQt,nFreeQt,aCols[n][nPosQtd]),,,,,,,.F.)
					Endif	
				Else
					NFEPC2ACOL(SC7->(RecNo()),n,IIf(Empty(aCols[n][nPosQtd]).Or.aCols[n][nPosQtd]>nFreeQt,nFreeQt,aCols[n][nPosQtd]),,lIs140auto)
				EndIf
            ElseIf !(FunName() $ "MATA143/MATA447")			// Não executa validação na geração de fatura originária de desembaraço para não sobrepor qtde e valor do pedido ao do desembaraço
	            LxA103SC7ToaCols(SC7->(RecNo()),n,IIf(Empty(aCols[n][nPosQtd]).Or.aCols[n][nPosQtd]>nFreeQt,nFreeQt,aCols[n][nPosQtd]))
            EndIf
			lRet 	:= .T.
		Else
			Help(' ', 1, 'A103PCNSLD')
		EndIf
	Else
		If !lEic
			Help("   ",1,"REGNOIS")
		Else
			lRet := .T.
		EndIf
	EndIf
Else
	Help("   ",1,"REGNOIS")
EndIf

RestArea(aAreaSC7)
RestArea(aArea)

Return lRet


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³ A103TRAVA ³ Autor ³ Aline Correa do Vale  ³ Data ³07/03/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Tratamento de DEAD-LOCK - Arquivo SB2                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Mata103                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103Trava() 
Local aTrava    := {}
Local ni        := 0
Local nPosPrd   := GetPosSD1("D1_COD")
Local nPosLoc   := GetPosSD1("D1_LOCAL")
Local nPosTes   := GetPosSD1("D1_TES")
Local lTrava    := .T.
Local lTravaSA1 := .T.
Local lTravaSA2 := .T.
Local lTravaSB2 := .T.
Local cFilSF4   := xFilial("SF4")
Local aAreaAnt	:= GetArea()

Static lMT103TRV := ExistBlock("MT103TRV")

If ( __TTSInUse )
	// Ponto de Entrada MT103TRV utilizado para desligar o Lock das tabelas SA1 / SA2
	If lMT103TRV
		aRetorno  := ExecBlock("MT103TRV",.F.,.F.,{cA100For,cLoja,IIf(cTipo$"DB","C","F")})
		If Type('aRetorno') == "A" .And. Len(aRetorno) >= 3
			lTravaSA1 := aRetorno[1]
			lTravaSA2 := aRetorno[2]
			lTravaSB2 := aRetorno[3]
		EndIf	
	EndIf

	SF4->( dbSetOrder(1) )

	For ni := 1 to Len(aCols)
		IF ( Len(aCols[nI]) > Len(aHeader) ) .And. !(aCols[ni][Len(aCols[ni])])
			If nPosTes > 0 .And. SF4->( MsSeek(cFilSF4+aCols[ni,nPosTes]) )
				If SF4->F4_ESTOQUE == "S"
					AADD(aTrava,aCols[ni,nPosPrd]+aCols[ni,nPosLoc])
				Endif
			Else
				AADD(aTrava,aCols[ni,nPosPrd]+aCols[ni,nPosLoc])
			EndIf
		EndIf
	Next
	
	If cTipo $ "DB"
		If lTravaSA1
			lTrava := MultLock("SA1",{cA100For+cLoja},1)
		EndIf	
	Else
		If lTravaSA2
			lTrava := MultLock("SA2",{cA100For+cLoja},1)
		EndIf	
	EndIf

	If lTrava .And. Len(aTrava) > 0
		If lTravaSB2
			lTrava := MultLock("SB2",aTrava,1)
		EndIf	
	EndIf
	
	If ( !lTrava )
		SB2->(MsRUnLock())
		SA1->(MsRUnLock())
		SA2->(MsRUnLock())
	EndIf
	RestArea(aAreaAnt)
	Return ( lTrava )
Else
	DbSelectArea("SB2")
	DbSetOrder(1)
	For ni := 1 to Len(aCols)
		IF ( Len(aCols[nI]) > Len(aHeader) ) .And. !(aCols[ni][Len(aCols[ni])])
			If nPosTes > 0 .And. SF4->( MsSeek(cFilSF4+aCols[ni,nPosTes]) )
				If SF4->F4_ESTOQUE == "S"
					If MsSeek(xFilial("SB2")+aCols[ni,nPosPrd]+aCols[ni,nPosLoc])
						lTrava := SoftLock("SB2")
					EndIf
				Endif
			Else
				If MsSeek(xFilial("SB2")+aCols[ni,nPosPrd]+aCols[ni,nPosLoc])
					lTrava := SoftLock("SB2")
				EndIf
			EndIf
		EndIf
	Next
	RestArea(aAreaAnt)
	Return(lTrava)
EndIf

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³MaCanDelF1³ Autor ³ Edson Maricate        ³ Data ³11.10.2001 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao da exclusao de uma nota fiscal de entrada³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Numero do Registro do SF1.                       (OPC)³±±
±±³          ³ExpA2: Array com os pedidos de venda gerados a partir da nota³±±
±±³          ³       fiscal de entrada.                               (OPC)³±±
±±³          ³ExpA3: Array com os titulos financeiro gerados          (OPC)³±±
±±³          ³ExpL4: Indica se pode apagar notas de conhec de frete   (OPC)³±±
±±³          ³ExpL5: Indica se pode apagar notas de despesas de import(OPC)³±±
±±³          ³ExpL6: Indica se estou apagando um remito (localizacoes)(OPC)³±±
±±³          ³ExpL7: Indica se se trata de un retorno simbolico automatico,³±±
±±³          ³       no caso de ser, o retorno pode ser apagado.           ³±±
±±³          ³ExpA8: Array contendo os recnos dos titulos no SE1(devolucao)³±±
±±³          ³ExpL9: Indica se a exclusao esta sendo feita pelo SIGAEIC    ³±±
±±³          ³ExpL10:Indica se a exclusao esta sendo feita pelo SIGATMS    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se a nota pode ser excluida                    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar a exclusao de uma Nota ³±±
±±³          ³fiscal de entrada/Documento de entrada.                      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function MaCanDelF1(nRecSF1,aRecSC5,aRecSE2,lCanDelFr,lCanDelDp,lRemito,lRSAuto,aRecSe1,lExcViaEIC,lExcViaTMS,l103Exclui)
Local lEofSD3   := .T.
Local aArea		:= GetArea()
Local aAreaSD1	:= SD1->(GetArea())
Local aAreaSF8	:= SF8->(GetArea())
Local aStruSD1  := {}
Local aStruSE2  := {}

Local lQuery    := .F.
Local lRetorno	:= .F.
Local lRetAPO   := .T.
Local l100Del	:= ExistBlock("A100DEL")  
Local lM103APO  := ExistBlock("M103APO")
Local lIntACD	:= SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local lEstNeg   := (SuperGetMv("MV_ESTNEG")=="S")
Local lEECFAT	:= SuperGetMv("MV_EECFAT",.F.,.F.)
Local lForpcnf	:= SuperGetMV("MV_FORPCNF",.F.,.F.)
Local lR103ENEG := .F.
Local dDataFec	:= MVUlmes()
Local dDataVenc
Local dDataIni
Local dDataFim
Local lShowAviso:= (SuperGetMv("MV_AV10925",.T.,"2") == "1")
Local cLocTran  := SuperGetMV("MV_LOCTRAN",.F.,"95")
Local lAviso    := .F.
Local lAvisoISS := .F.
Local lVldRetISS:= .F.
Local lRetISSMes:= 	GetNewPar("MV_MODRISS","1") == "2"
Local lBxCaucGct:= .F.
Local dDataBloq	:= GetNewPar("MV_ATFBLQM",CTOD(""))

Local nPosLote	:= 0
Local nX		:= 0
Local nSldTran  := 0
Local nSldLote  := 0
Local aLotes	:= {}
Local cMensagem := ""
Local cPrefixo  := ""
Local cQuery    := ""
Local cAliasSD1 := "SD1"
Local cAliasSE2 := "SE2"
Local nAcICMSAPR:= 0	
Local aAreaSN1  := {}
Local aRetXFin  := {}
Local cTesDR    := SuperGetMV("MV_TESDR",,"")
Local lNumTrib	:= .T.
Local cNumTit	:= ""
Local cFilCTR   := ""
Local aAreaSE2IR
Local nRecE2in
Local l103EstAdt:= SuperGetMv("MV_ESTOADT",.F.,.F.) //Permite o estorno de documento de entrada vinculado a PC com PA(somente via execauto).

Local cSepNeg   := If("|"$MV_CPNEG,"|",",")
Local cSepProv  := If("|"$MVPROVIS,"|",",")
Local cSepRec   := If("|"$MVPAGANT,"|",",")

Local nCountSE2 := 0
Local lPriParAdtBx := .F.
Local nValorAdtFR3 := 0


local nTamPref := TamSX3("E2_PREFIXO")[1]
local cPrefPIS := PadR(SuperGetMV("MV_PREFPIS",.F.,"PIS"), nTamPref)
local cPrefCOF := PadR(SuperGetMV("MV_PREFCOF",.F.,"COF"), nTamPref)
local cPrefISS := PadR(SuperGetMv("MV_PREFISS",.F.,"ISS"), nTamPref)
local cPreFase := PadR(SuperGetMv("MV_PREFASE",.F.,"TX"), nTamPref)
local nQtdTit  := 0
local nQtdTot  := 0
Local cNatGilRat := ''
Local aNats		:= {}
Local lIntGC	 := IIf((SuperGetMV("MV_VEICULO",,"N")) == "S",.T.,.F.)
Local cE1Cliente := "" // Quando integrado com DMS, o cliente pode ser outro se utilizado condicao de pagamento TIPO A na venda.
Local cE1Loja    := "" // Quando integrado com DMS, o cliente pode ser outro se utilizado condicao de pagamento TIPO A na venda.
Local cE1NReduz  := "" // Quando integrado com DMS, o cliente pode ser outro se utilizado condicao de pagamento TIPO A na venda.
Local cPrefOri	 := ""
Local cNumOri	 := ""
Local cParcOri	 := ""
Local cTipoOri 	 := ""
Local cCfOri	 := ""
Local cLojaOri	 := ""
Local cQBCod	 := ""
Local cQBLocal   := ""
Local l140Estor  := FwIsInCallStack("A140EstCla")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Analisa os parametros da Rotina                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT aRecSC5    := {}
DEFAULT aRecSE1    := {}
DEFAULT aRecSE2    := {}
DEFAULT lCanDelFr  := .F.
DEFAULT lCanDelDp  := .F.
DEFAULT lRemito    := .F.          
DEFAULT lExcViaEIC := .F. 
DEFAULT lExcViaTMS := .F.   
DEFAULT l103Exclui := .F.                       

If Type("cTipo") == "U"
	cTipo:= SF1->F1_TIPO
EndIf

If nRecSF1 <> Nil
	dbSelectArea("SF1")
	MsGoto(nRecSF1)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ajusta a Pesquisa das Notas de Conhecimento de Frete e D.I.  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
SF8->(dbSetOrder(2))
Do Case
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se a NF possui NF de Conhec. e Desp. de Import.     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case !lCanDelFr .And. ((SF8->(MsSeek(xFilial("SF8")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+SF1->F1_TIPO)) .And. SF1->F1_TIPO != "C" );
 		.Or. A103CTECOL(SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FILIAL,SF1->F1_FORNECE,SF1->F1_LOJA+SF1->F1_TIPO))
	Help(" ", 1, "A103CAGREG")
	lRetorno := .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Nao excluir NF incluida pelo MATA910                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case SF1->F1_ORIGLAN == "LF"
	Help("  ",1,"NAOCOM")
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Nao excluir NF nao classificada                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case Empty(SF1->F1_STATUS)
	Help(" ",1,"A100NOCLAS")
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verificar data do ultimo fechamento em SX6                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case dDataFec>=dDataBase .Or. dDataFec>=SF1->F1_DTDIGIT
	Help( " ", 1, "FECHTO" )
	lRetorno := .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica ultima data para operacoes fiscais                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case !FisChkExc(SF1->F1_SERIE,SF1->F1_DOC,SF1->F1_FORNECE,SF1->F1_LOJA,,"E")
	lRetorno := .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com o ACD		  				  	  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case lIntACD .And. !(CBA100DEL())
	lRetorno := .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Template acionando ponto de entrada                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case ExistTemplate("A100DEL") .And. !(ExecTemplate("A100DEL",.F.,.F.))				
	lRetorno := .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de entrada para permitir ou nao a exclusao             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case l100Del .And. !(Execblock("A100DEL",.F.,.F.))
	lRetorno := .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Nao excluir nota de Frete Gerada pela rotina MATA116         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case SF1->F1_TIPO == "C" .And. SF1->F1_ORIGLAN == "F "  .And. !lCanDelFr
	Help(" ",1,"A100NDELFR")
	lRetorno := .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Nao excluir nota de Despesas de Importacao                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case SF1->F1_TIPO == "C" .And. SF1->F1_ORIGLAN == " D"	.And. !lCanDelDp
	Help(" ",1,"A100NDELDP")
	lRetorno := .F.
	//ÚLocalizacoesÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Nao excluir NF (de devolucao ou retorno) que gerou PV se este³
	//³ ainda existe.                                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case !lRsAuto .And. !Empty(SF1->F1_PEDVEND) .And. (SF1->F1_PEDVEND == "AUTO  " .Or. Eval( {|| SC5->(DbSetORder(1)),SC5->(MsSeek(xFilial("SC5")+SF1->F1_PEDVEND) ) }) )
	If SF1->F1_PEDVEND <> "AUTO  " 
		Help(" ",1,"A103PV" ,,RetTitle("C9_PEDIDO") + "  " + SF1->F1_PEDVEND,04,02)
	Else
		Help(" ",1,"A103CONS" )
	Endif
	lRetorno	:=	.F.
	
	//Função Modulo DMS para permitir ou nao a exclusao
Case lIntGC .and. FindFunction("OA2900035_MaCanDelF1_Valid") .and. !OA2900035_MaCanDelF1_Valid( { SF1->F1_DOC, SF1->F1_SERIE, SF1->F1_FORNECE, SF1->F1_LOJA } )
	lRetorno :=	.F.

OtherWise
	lRetorno := .T. 
EndCase   

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se Documento de Entrada Original está vinculado aos outros Documentos ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRetorno
	lQuery    := .T.
	cAliasSD1 := GetNextAlias()

	If Select(cAliasSD1) > 0 
		dbSelectArea(cAliasSD1)
	    dbCloseArea()
	EndIf

	cQuery    := "SELECT COUNT(D1_DOC) AS NOTAORI "
	cQuery    += "  FROM "+RetSqlName("SD1")+" SD1 "
	cQuery    += " JOIN "+RetSqlName("SF1")+" SF1 "
	cQuery    += " ON SF1.F1_FILIAL = SD1.D1_FILIAL "
	cQuery    += " AND SF1.F1_DOC = SD1.D1_DOC "
	cQuery    += " AND SF1.F1_SERIE = SD1.D1_SERIE "
	cQuery    += " AND SF1.F1_FORNECE = SD1.D1_FORNECE "
	cQuery    += " AND SF1.F1_LOJA = SD1.D1_LOJA "
	cQuery    += " AND SF1.D_E_L_E_T_ = ' ' "
	cQuery    += " AND SF1.F1_TPCOMPL IN ( '1','2') " //Retiro o complemento de frete da validação pois a mesma é efetuada via SF8(A103CAGREG)
	cQuery    += " WHERE SD1.D1_FILIAL  = '"+xFilial("SD1")+"'"
	cQuery    += "   AND SD1.D1_NFORI   = '"+SF1->F1_DOC+"'"
	cQuery    += "   AND SD1.D1_SERIORI = '"+SF1->F1_SERIE+"'"
	cQuery    += "   AND SD1.D1_FORNECE = '"+SF1->F1_FORNECE+"'"
	cQuery    += "   AND SD1.D1_LOJA    = '"+SF1->F1_LOJA+"'"
	cQuery    += "   AND ( SD1.D1_DOC <> '"+SF1->F1_DOC+"' OR SD1.D1_SERIE <> '"+SF1->F1_SERIE+"' OR SD1.D1_FORNECE <> '"+SF1->F1_FORNECE+"' OR SD1.D1_LOJA <> '"+SF1->F1_LOJA+"')"
	cQuery    += "   AND SD1.D1_TIPO IN ('P','I','C') "
	cQuery    += "   AND SD1.D_E_L_E_T_=' ' "
	
	cQuery := ChangeQuery( cQuery )
	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasSD1, .T., .T. )      
	
	If ctipo != "C"
		If (cAliasSD1)->NOTAORI > 0 
		   	Help(' ',1,'A103NEXCOR') 
		   	lRetorno := .F.
		EndIf
	EndIf
	(cAliasSD1)->(dbCloseArea())
EndIf


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Analisa os itens da Nota fiscal de Entrada                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SD1")
dbSetOrder(1)

lQuery    := .T.
cAliasSD1 := "MACANDELF1"
aStruSD1  := SD1->(dbStruct())
cQuery    := "SELECT SD1.*,SD1.R_E_C_N_O_ SD1RECNO "
cQuery    += "  FROM "+RetSqlName("SD1")+" SD1 "
cQuery    += " WHERE SD1.D1_FILIAL   = '"+xFilial("SD1")+"'"
cQuery    += "   AND SD1.D1_DOC	     = '"+SF1->F1_DOC+"'"
cQuery    += "   AND SD1.D1_SERIE    = '"+SF1->F1_SERIE+"'"
cQuery    += "   AND SD1.D1_FORNECE  = '"+SF1->F1_FORNECE+"'"
cQuery    += "   AND SD1.D1_LOJA	 = '"+SF1->F1_LOJA+"'"
cQuery    += "   AND SD1.D1_TIPO	 = '"+SF1->F1_TIPO+"'"
cQuery    += "   AND SD1.D_E_L_E_T_	 = ' ' "
cQuery    += "ORDER BY "+SqlOrder(SD1->(IndexKey()))

cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD1,.T.,.T.)

For nX := 1 To Len(aStruSD1)
	If aStruSD1[nX][2]<>"C"
		TcSetField(cAliasSD1,aStruSD1[nX][1],aStruSD1[nX][2],aStruSD1[nX][3],aStruSD1[nX][4])
	EndIf
Next nX

While !Eof().And. (cAliasSD1)->D1_FILIAL == xFilial('SD1') .And.;
		(cAliasSD1)->D1_DOC == SF1->F1_DOC .And.;
		(cAliasSD1)->D1_SERIE == SF1->F1_SERIE .And.;
		(cAliasSD1)->D1_FORNECE == SF1->F1_FORNECE .And.;
		(cAliasSD1)->D1_LOJA == SF1->F1_LOJA .And. lRetorno

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se a O.P. vinculada a uma N.F. esta encerrada     ³
	//³ ou se ja possui quantidade apontada.                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If !(SuperGetMV("MV_PRNFBEN",.F.,.F.))
		dbSelectArea("SC2")
		dbSetOrder(1)
		If MsSeek(xFilial("SC2")+(cAliasSD1)->D1_OP) .And. !lCanDelFr
			If !Empty(SC2->C2_DATRF)
				Help("",1,"A103ENCERR")
				lRetorno := .F.
			ElseIf QtdComp(SC2->C2_QUJE,.T.) > QtdComp(0,.T.)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ`¿
				//³Ponto de entrada que permite ou não a validação da exclusão da NF vinculada a uma OP³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ`Ù
				If lM103APO
					lRetAPO := ExecBlock("M103APO",.F.,.F.)										
					If ValType(lRetAPO)<> "L"
						lRetAPO := .T.
					Endif
				EndIf
				If lRetApo .And.(Type('l103Auto') <> 'U' .And. l103Auto) .Or. Aviso(OemToAnsi(STR0018),OemToAnsi(STR0048)+(cAliasSD1)->D1_OP+OemToAnsi(STR0049),{OemToAnsi(STR0016),OemToAnsi(STR0017)},nil,nil,1) == 2
					lRetorno := .F.
				EndIf
			EndIf
		EndIf		
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ AvalMovDiv - Funcao utilizada para avaliar possiveis divergencias de     |
	//|              saldo no estorno do movimento selecionado.                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !(SF1->F1_TIPO$"PIC") .And. AvalMovDiv((cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL,(cAliasSD1)->D1_LOTECTL,(cAliasSD1)->D1_NUMLOTE,(cAliasSD1)->D1_NUMSEQ,(cAliasSD1)->D1_TES)
		lRetorno := .F.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona o Arquivo SF4.                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea('SF4')
	dbSetOrder(1)
	MsSeek(xFilial("SF4")+(cAliasSD1)->D1_TES)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica a posicao do Pedido de Vendas  (Devolucao)          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. !Empty((cAliasSD1)->D1_NUMPV)
		dbSelectArea('SC5')
		If MsSeek(xFilial("SC5")+(cAliasSD1)->D1_NUMPV)
			aAdd(aRecSC5,SC5->(RecNo()))
		EndIf
		dbSelectArea('SC6')
		dbSetOrder(1)
		If MsSeek(xFilial("SC6")+(cAliasSD1)->D1_NUMPV+(cAliasSD1)->D1_ITEMPV)
			If SC6->C6_QTDLIB+SC6->C6_QTDENT <> 0
				If (Type('l103Auto') <> 'U' .And. l103Auto) .Or. Aviso(OemToAnsi(STR0018),OemToAnsi(STR0015),{OemToAnsi(STR0016),OemToAnsi(STR0017)}) == 2 //"O pedido de vendas gerado pelo Docto. de devolucao ja foi liberado ou atendido e nao sera excluido. Deseja continuar ?"###"Continua"###"Abandona"
					lRetorno := .F.
					Exit
				EndIf
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Trava os registros do SC7.                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. !Empty((cAliasSD1)->D1_PEDIDO)
		nRecC7 := A103RECC7(xFilial("SC7"),(cAliasSD1)->D1_PEDIDO,(cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,(cAliasSD1)->D1_COD,(cAliasSD1)->D1_ITEMPC)
		SC7->(DbGoTo(nRecC7))
		If nRecC7 > 0
			cFilCTR := CNTBuscFil(xFilial('CND'), SC7->C7_MEDICAO)
			If !lBxCaucGct .And. CN9->(DbSeek(cFilCTR + SC7->(C7_CONTRA + C7_CONTREV)))
				lBxCaucGct := CN9->CN9_FLGCAU == "1" //Quando oriundo de contrato com caução não deve validar a exclusão do título a pagar
			EndIf
			If !SoftLock('SC7')
				lRetorno := .F.
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Trava os registros do SD7 e SD3                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. !Empty((cAliasSD1)->D1_NUMCQ)
		dbSelectArea("SD7")
		dbSetOrder(1)
		If MsSeek(xFilial("SD7")+(cAliasSD1)->D1_NUMCQ+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL)
			While !Eof() .And.lRetorno .And. xFilial("SD7") == SD7->D7_FILIAL .And.;
					(cAliasSD1)->D1_NUMCQ == SD7->D7_NUMERO .And.;
					(cAliasSD1)->D1_COD == SD7->D7_PRODUTO .And.;
					(cAliasSD1)->D1_LOCAL == SD7->D7_LOCAL
				If ((cAliasSD1)->D1_TIPO $ 'NBD' .or. (cAliasSD1)->D1_TIPO == 'C' .and. SF1->F1_TPCOMPL == '2') .And.;
				   (SD7->D7_TIPO==1 .Or. SD7->D7_TIPO==2 ) .And. Empty(SD7->D7_ESTORNO)	
					Help(' ',1,'A100CQ')
					lRetorno := .F.
					Exit
				ElseIf !SoftLock("SD7")
					lRetorno := .F.
					Exit
				Else
					dbSelectArea("SD3")
					dbSetOrder(4)
					If lRetorno .And. MsSeek(xFilial("SD3")+SD7->D7_NUMSEQ)
						While !Eof() .And. lRetorno .And. SD3->D3_FILIAL == xFilial("SD3") .And.;
								SD3->D3_NUMSEQ == SD7->D7_NUMSEQ
							If !SoftLock("SD3")
								lRetorno := .F.
								Exit
							EndIf
							dbSelectArea("SD3")
							dbSkip()
						EndDo
					EndIf
				EndIf
				dbSelectArea("SD7")
				dbSkip()
			EndDo
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica a existencia de Poder de Terceiros                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. SF4->F4_PODER3=="R"
		dbSelectArea("SB6")
		dbSetOrder(3)
		MsSeek(xFilial("SB6")+(cAliasSD1)->D1_NUMSEQ+(cAliasSD1)->D1_COD+'R')
		While ( !Eof() .And. lRetorno .And. xFilial("SB6") == SB6->B6_FILIAL .And.;
				(cAliasSD1)->D1_NUMSEQ==SB6->B6_IDENT .And.;
				(cAliasSD1)->D1_COD==SB6->B6_PRODUTO .And.;
				"R"==SB6->B6_PODER3 )
			If SB6->B6_QUANT<>SB6->B6_SALDO .And. SB6->B6_TIPO=="D"
				Help(' ',1,'A520NPODER')
				lRetorno := .F.
			EndIf
			dbSelectArea("SB6")			
			dbSkip()
		EndDo
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao do Ativo Fixo - Travamento                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. (ExistBlock ("M103XATF"))
		lRetorno	:=	ExecBlock ("M103XATF", .F., .F., {cAliasSD1})
	Else
		If lRetorno .And. !Empty((cAliasSD1)->D1_CBASEAF)
			lRetorno := M103XAFEXC((cAliasSD1)->D1_DOC,(cAliasSD1)->D1_SERIE,(cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,(cAliasSD1)->D1_COD)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica a existencia do CIAP                                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lRetorno .And. !Empty((cAliasSD1)->D1_CODCIAP)
			dbSelectArea('SF9')
			dbSetOrder(1)
			If MsSeek(xFilial("SF9")+(cAliasSD1)->D1_CODCIAP)
				If !Empty( SN1->N1_CODCIAP ) .Or. !Empty((cAliasSD1)->D1_CODCIAP)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Este WHILE se deve ao desmabrento no ativo fixo(SN1) pela quantidade.³
					//³A tabela SN1 eh posicionada logo acima                               ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					nAcICMSAPR	:=	0
					aAreaSN1	:=	SN1->(GetArea ())
					
					If Alltrim(SN1->N1_NFESPEC) == ""
						DbSelectArea("SN1")
						DbSetOrder(8)
						If !DbSeek(xFilial("SN1")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+ "     " +(cAliasSD1)->D1_DOC+(cAliasSD1)->D1_SERIE+(cAliasSD1)->D1_ITEM)
							RestArea (aAreaSN1)						
						EndIf	
					Else
					 	If (cAliasSD1)->D1_CODCIAP<>SN1->N1_CODCIAP
							DbSelectArea("SN1")
							DbSetOrder(4)
							If !DbSeek(xFilial("SN1")+(cAliasSD1)->D1_CODCIAP)
								RestArea (aAreaSN1)						
							EndIf
						EndIf
					EndIf
					
					Do While !SN1->(Eof ()) .And.;
						(cAliasSD1)->D1_CODCIAP==SN1->N1_CODCIAP
						nAcICMSAPR	+=	SN1->N1_ICMSAPR
						
						SN1->(DbSkip ())
					EndDo
					RestArea (aAreaSN1)
					If  (((!Empty((cAliasSD1)->D1_CBASEAF) .And. SF9->F9_ICMIMOB <> nAcICMSAPR).Or.(Empty((cAliasSD1)->D1_CBASEAF) .And.SF9->F9_ICMIMOB <> 0)).Or.;
							SF9->F9_BXICMS <> 0 .Or. SF9->F9_MOTIVO <> " " .Or. SF9->F9_VLESTOR <> 0)
						Help("  ",1,"A100CIAPDE")
						lRetorno := .F.
					EndIf
				EndIf				
			EndIf
		EndIf
	EndIf
	//Verifica se existe bloqueio contabil - Validacao incluida em 03/08/2015 changeset 320011 release 12
	If lRetorno .And. SF4->F4_ATUATF == "S" .And. !Empty(dDataBloq) .And. (cAliasSD1)->D1_DTDIGIT <= dDataBloq
		Help(" ",1,"ATFCTBBLQ")	// Processo bloqueado pelo Calendario Contabil ou parametro de bloqueio nesta data ou periodo.
		lRetorno := .F.
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se algum produto esta sendo inventariado.           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. BlqInvent((cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL)
		Help("  ",1,"BLQINVENT",,(cAliasSD1)->D1_COD+STR0022+(cAliasSD1)->D1_LOCAL,1,11) //"Armazem: "
		lRetorno := .F.
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se algum produto ja foi distribuido                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Localiza((cAliasSD1)->D1_COD)
		dbSelectArea('SDA')
		dbSetOrder(1)
		If lRetorno .And. MsSeek(xFilial("SDA")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL+(cAliasSD1)->D1_NUMSEQ+(cAliasSD1)->D1_DOC+(cAliasSD1)->D1_SERIE+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA)
			If !(SDA->DA_QTDORI == SDA->DA_SALDO)
				Help(" ",1,"SDAJADISTR")
				lRetorno := .F.
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica a quantidade devolvida.                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. ((cAliasSD1)->D1_QTDEDEV <> 0 .Or. (cAliasSD1)->D1_VALDEV <> 0)
		Help(' ',1,'NAOEXCL')
		lRetorno := .F.
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica a quantidade clasificada (remitos de localizacoes)  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. lRemito .And. (cAliasSD1)->D1_QTDACLA <> (cAliasSD1)->D1_QUANT
		Help(' ',1,'NAOEXCLREM')
		lRetorno := .F.
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o remito esta amarrada a alguma nota de Credito  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. lRemito
		SD1->(DbSetOrder(10))
		If SD1->(MsSeek(xFilial("SD1")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_SERIE+(cAliasSD1)->D1_DOC))
			Help(' ',1,'NAOEXCLREM',,SD1->D1_ESPECIE+" "+SerieNfId("SD1",2,"D1_SERIE")+"/"+SD1->D1_DOC,1,11)
			lRetorno := .F.
		Endif
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica o Servico do WMS.                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. !Empty((cAliasSD1)->D1_SERVIC) .And. IntWMS() .And. cTipo $ "N|D|B" .And. SF4->F4_ESTOQUE == "S"
		lRetorno := WmsAvalSD1("7",cAliasSD1)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Totaliza no array aLotes para validar a exclusao.            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. Rastro((cAliasSD1)->D1_COD).And. SF4->F4_ESTOQUE=='S'
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ aLotes[nx][1] : Codigo do Produto        ³
		//³ aLotes[nx][2] : Almoxarifado             ³
		//³ aLotes[nx][3] : Lote                     ³
		//³ aLotes[nx][4] : SubLote                  ³
		//³ aLotes[nx][5] : OP                       ³
		//³ aLotes[nx][6] : Numero Sequencial        ³
		//³ aLotes[nx][7] : Quantidade               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nPosLote :=Ascan(aLotes,{|x| x[1]+x[2]+x[3]+x[4]==(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL+(cAliasSD1)->D1_LOTECTL+(cAliasSD1)->D1_NUMLOTE+(cAliasSD1)->D1_OP+(cAliasSD1)->D1_NUMSEQ})
		If nPosLote > 0
			aLotes[nPosLote][7] += (cAliasSD1)->D1_QUANT
		Else
			aADD(aLotes,{(cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL,(cAliasSD1)->D1_LOTECTL,(cAliasSD1)->D1_NUMLOTE,(cAliasSD1)->D1_OP,(cAliasSD1)->D1_NUMSEQ,(cAliasSD1)->D1_QUANT})
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se Sld no B2 ficar  Neg. ou Menor que Sld em Reserva³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. SF4->F4_ESTOQUE == "S" .And. (cAliasSD1)->D1_QUANT > 0
		SB2->(dbSetOrder(1))
		If SB2->(MsSeek(xFilial('SB2')+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL, .F.))
			If (cAliasSD1)->D1_COD <> cQBCod .or. (cAliasSD1)->D1_LOCAL <> cQBLocal
				cQBCod   := (cAliasSD1)->D1_COD
				cQBLocal := (cAliasSD1)->D1_LOCAL
				nSaldoB2 := SB2->B2_QATU
			EndIf
			nSaldoB2 := nSaldoB2-(cAliasSD1)->D1_QUANT
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se existe movimento de requisicao do material para a OP³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty((cAliasSD1)->D1_OP) .OR. (IntePms() .and. PmsExAFN(cAliasSD1))
				SD3->(dbSetOrder(4))
				If SD3->(dbSeek(xFilial("SD3")+(cAliasSD1)->D1_NUMSEQ))
					nSaldoB2 += SD3->D3_QUANT
				EndIf
			EndIf                                                        
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se existe movimento de material em Transito            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (cAliasSD1)->D1_TRANSIT == 'S'
				SD3->(dbSetOrder(4))
				If SD3->(dbSeek(xFilial("SD3")+(cAliasSD1)->D1_NUMSEQ))
					nSaldoB2 += SD3->D3_QUANT
				EndIf
			EndIf                                        

			If !SuperGETMV("MV_NEGATBF",.F.,.F.)                                       
			If QtdComp(nSaldoB2)<QtdComp(0)
			    If lEstNeg  //Permite Estoque Negativo
			        If (Rastro((cAliasSD1)->D1_COD) .Or. Localiza((cAliasSD1)->D1_COD))  // MV_ESTNEG = S e Produto com Rastro / Localização, não permite estoque negativo
						If !(Type('l103Auto') <> 'U' .And. l103Auto)
							Aviso(STR0018,STR0019 + AllTrim((cAliasSD1)->D1_COD)+"/"+(cAliasSD1)->D1_LOCAL + STR0023 + AllTrim(Str(nSaldoB2))+") ",{STR0025}) //"Atencao" //"O Saldo do Prod/Loc "###" ficara negativo apos a Exclusao ("###"Aborta"
						EndIf	
						lRetorno := .F.
			    	Else
						If !(Type('l103Auto') <> 'U' .And. l103Auto)
					    	If !(Rastro((cAliasSD1)->D1_COD) .And. Localiza((cAliasSD1)->D1_COD)) .And. !(FunName() $ 'EICDI154')  // MV_ESTNEG = S e Produto sem Rastro / Localização, avisa que o estoque ficara negativo  e nao originado do Recebimento de Importacao
						    	lRetorno := (Aviso(STR0018,STR0019 + AllTrim((cAliasSD1)->D1_COD)+'/'+(cAliasSD1)->D1_LOCAL + STR0023 + AllTrim(Str(nSaldoB2)) + STR0024,{STR0025,STR0016}) == 2) //"Atencao"###"O Saldo do Prod/Loc "###"Continua" //" ficara negativo apos a Exclusao ("###"). Continua?"###"Aborta"
						    EndIf
						EndIf
					EndIf
				Else  // Não Permite Estoque Negativo
					If !(Type('l103Auto') <> 'U' .And. l103Auto)  
					    lR103ENEG:=A103ValEstNeg((cAliasSD1)->D1_COD,cAliasSD1)
					EndIf	
					lRetorno := lR103ENEG	
			    EndIf
			ElseIf QtdComp(nSaldoB2)<QtdComp(SB2->B2_RESERVA)
				If lEstNeg   //Permite Estoque Negativo
				    If (Rastro((cAliasSD1)->D1_COD) .Or. Localiza((cAliasSD1)->D1_COD))  // MV_ESTNEG = S e Produto com Rastro / Localização, não permite estoque negativo
						If !(Type('l103Auto') <> 'U' .And. l103Auto)
							Aviso(STR0018,STR0019 + AllTrim((cAliasSD1)->D1_COD)+"/"+(cAliasSD1)->D1_LOCAL + STR0026 + AllTrim(Str(nSaldoB2))+")",{STR0025}) //"Atencao"###"O Saldo do Prod/Loc " //" ficara Menor que o Saldo em Reserva apos a Exclusao ("###"Aborta"
						EndIf	
						lRetorno := .F.
					Else
						If !(Type('l103Auto') <> 'U' .And. l103Auto)
						    If !(Rastro((cAliasSD1)->D1_COD) .And. Localiza((cAliasSD1)->D1_COD))  .And. !(FunName() $ 'EICDI154')   // MV_ESTNEG = S e Produto sem Rastro / Localização, avisa que o estoque ficara negativo
						    	lRetorno := (Aviso(STR0018,STR0019 + AllTrim((cAliasSD1)->D1_COD)+'/'+(cAliasSD1)->D1_LOCAL + STR0023 + AllTrim(Str(nSaldoB2)) + STR0024,{STR0025,STR0016}) == 2) //"Atencao"###"O Saldo do Prod/Loc "###"Continua" //" ficara negativo apos a Exclusao ("###"). Continua?"###"Aborta"
					    	EndIf
				    	EndIf
			    	EndIf
			  	Else  // Não Permite Estoque Negativo   
				  	If !(Type('l103Auto') <> 'U' .And. l103Auto)
					    lR103ENEG:=A103ValEstNeg((cAliasSD1)->D1_COD,cAliasSD1)
					EndIf	
					lRetorno := lR103ENEG
				EndIf
			EndIf
		EndIf	
	EndIf				
	EndIf				
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o item de nota originou-se do SIGAEIC                            ³
	//³ Permite a exclusao apenas quando a chamada da exclusao for feita pelo EIC    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. !lExcViaEIC .And. !Empty( ( cAliasSD1 )->D1_TIPO_NF ) 
		Help( "", 1, "A103EXCIMP" )  // "Este documento nao pode ser excluido pois foi criado pelo SIGAEIC. A exclusao devera ser efetuada pelo SIGAEIC."
		lRetorno := .F. 
	EndIf 	

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o item de nota originou-se do SIGATMS                            ³
	//³ Permite a exclusao apenas quando a chamada da exclusao for feita pelo TMS    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	SF4->(DbSetOrder(1))
	If SF4->(DbSeek(xFilial('SF4')+cTesDR)) .And. SF4->F4_ESTOQUE == 'S'
		dbSelectArea('DTC')
		dbSetOrder(2) //-- DTC_FILIAL+DTC_NUMNFC+DTC_SERNFC+DTC_CLIREM+DTC_LOJREM
		IF MsSeek(xFilial('DTC') + SF1->F1_DOC + SF1->F1_SERIE + SF1->F1_FORNECE + SF1->F1_LOJA, .F.)
			Help('', 1, 'A103EXCTMS') //-- 'Este documento nao pode ser excluido pois foi criado pelo SIGATMS. A exclusao devera ser efetuada pelo SIGATMS.'
			lRetorno := .F.
		EndIf
	EndIf

	dbSelectArea(cAliasSD1)
	dbSkip()

EndDo
If lQuery
	dbSelectArea(cAliasSD1)
	dbCloseArea()
	dbSelectArea("SD1")
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se os Lotes podem ser excluidos                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//Não há necessidade de validar a exclusão de lote quando se trata de um conhecimento de frete (F1_TIPO = C | F1_TPCOMPL = 3)
If lRetorno .and. SF1->F1_TIPO <> "C" .AND. SF1->F1_TPCOMPL <> "3"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ aLotes[nx][1] : Codigo do Produto        ³
	//³ aLotes[nx][2] : Almoxarifado             ³
	//³ aLotes[nx][3] : Lote                     ³
	//³ aLotes[nx][4] : SubLote                  ³
	//³ aLotes[nx][5] : OP                       ³
	//³ aLotes[nx][6] : Numero Sequencial        ³
	//³ aLotes[nx][7] : Quantidade               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nX := 1 to Len(aLotes)

		nSldLote := SaldoLote(aLotes[nX][1],aLotes[nX][2],aLotes[nX][3],aLotes[nX][4],,,.T.)
		// Verifica o saldo em transito disponivel
		nSldTran := SaldoLote(aLotes[nX][1],cLocTran,aLotes[nX][3],aLotes[nX][4],,,.T.)
		If (nSldLote+nSldTran) < aLotes[nX][7]
			If !Empty(aLotes[nx,5])
				dbSelectArea("SD3")
				dbSetOrder(4)
				MsSeek(xFilial("SD3")+aLotes[nx,6])
				While !Eof() .And. SD3->D3_CF # "RE5" .And. SD3->D3_NUMSEQ == aLotes[nx,6]
					dbSkip()
				End
				lEofSD3 := IIF(SD3->D3_NUMSEQ # aLotes[nx,6],.T.,.F.)
				If lEofSD3
					Help(" ",1,"A100NOLOTE",,aLotes[nX,1]+"  "+aLotes[nX,2]+"    "+aLotes[nX,3],5,4)
					lRetorno := .F.
					Exit
				EndIf
			Else
				Help(" ",1,"A100NOLOTE",,aLotes[nX,1]+"  "+aLotes[nX,2]+"    "+aLotes[nX,3],5,4)
				lRetorno := .F.
				Exit
			EndIf
		EndIf
	Next
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se as duplicatas podem ser excluidas  SE2           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRetorno .And. (ExistBlock ("M103XFIN"))
	aRetXFin	:= ExecBlock ("M103XFIN", .F., .F. , {lAviso,lAvisoISS})
	If ValType(aRetXFin) == "A" .And. Len(aRetXFin) <= 3 
		lRetorno	:= IIF(ValType(aRetXFin[1]) == "L",aRetXFin[1],lRetorno)
		lAviso		:= IIF(ValType(aRetXFin[2]) == "L",aRetXFin[2],lAviso)
		lAvisoISS	:= IIF(ValType(aRetXFin[3]) == "L",aRetXFin[3],lAvisoISS)
	EndIf	
EndIf

If lRetorno
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica o Prefixo correto da Nota fiscal de Entrada         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cPrefixo	:= IIf(Empty(SF1->F1_PREFIXO),&(SuperGetMV("MV_2DUPREF")),SF1->F1_PREFIXO)	
	dbSelectArea("SE2")
	dbSetOrder(6)

	lQuery    := .T.
	aStruSE2  := SE2->(dbStruct())
	cAliasSE2 := "MACANDELF1"
	cQuery    := "SELECT SE2.*,SE2.R_E_C_N_O_ SE2RECNO "
	cQuery    += "  FROM "+RetSqlName("SE2")+" SE2 "
	cQuery    += " WHERE SE2.E2_FILIAL   = '"+xFilial("SE2")+"'"
	cQuery    += "   AND SE2.E2_FORNECE  = '"+SF1->F1_FORNECE+"'"
	cQuery    += "   AND SE2.E2_LOJA	 = '"+SF1->F1_LOJA+"'"
	cQuery    += "   AND SE2.E2_PREFIXO  = '"+cPrefixo+"'"
	cQuery    += "   AND SE2.E2_NUM		 = '"+SF1->F1_DUPL+"'"
	cQuery    += "   AND SE2.D_E_L_E_T_  = ' ' "
	cQuery    += "ORDER BY "+SqlOrder(SE2->(IndexKey()))

	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE2,.T.,.T.)
	
	For nX := 1 To Len(aStruSE2)
		If aStruSE2[nX][2]<>"C"
			TcSetField(cAliasSE2,aStruSE2[nX][1],aStruSE2[nX][2],aStruSE2[nX][3],aStruSE2[nX][4])
		EndIf
	Next nX
		
	If cPaisLoc $ "BRA|MEX" .and. SF1->F1_TIPO != "D" .and. (cAliasSE2)->(!Eof())
		If lRetorno .and. A120UsaAdi(SF1->F1_COND) 
			If !Empty((cAliasSE2)->E2_BAIXA) .and. (cAliasSE2)->E2_VALOR != (cAliasSE2)->E2_SALDO
				cQ := "SELECT SUM(FR3_VALOR) AS FR3_VALOR "
				cQ += "  FROM "+RetSqlName("FR3")
				cQ += " WHERE FR3_FILIAL = '"+xFilial("FR3")+"' "
				cQ += "   AND FR3_CART   = 'P' "
				cQ += "   AND FR3_TIPO   IN "+FormatIn(MVPAGANT,"/")+" "
				If lForpcnf .And. ( SC7->C7_FORNECE <> SF1->F1_FORNECE .Or. SC7->C7_LOJA <> SF1->F1_LOJA )
					cQ += "   AND FR3_FORNEC = '"+SC7->C7_FORNECE+"' "
					cQ += "   AND FR3_LOJA   = '"+SC7->C7_LOJA+"' "
				Else
					cQ += "   AND FR3_FORNEC = '"+SF1->F1_FORNECE+"' "
					cQ += "   AND FR3_LOJA   = '"+SF1->F1_LOJA+"' "
				EndIf
				cQ += "   AND FR3_DOC    = '"+SF1->F1_DOC+"' "
				cQ += "   AND FR3_SERIE  = '"+SF1->F1_SERIE+"' "
				cQ += "   AND D_E_L_E_T_ = ' ' "
            	
				cQ := ChangeQuery(cQ)
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQ),"TRBFR3",.T.,.T.)
					
				TcSetField("TRBFR3","FR3_VALOR","N",TamSX3("FR3_VALOR")[1],TamSX3("FR3_VALOR")[2])						
				   
			   nValorAdtFR3 := TRBFR3->FR3_VALOR           
				   
			   TRBFR3->(dbCloseArea())
			   //Tratamento para bloquear o estorno e exclusão do documento caso a data base seja menor que a data de emissão
			   If lRetorno .And. dDataBase < SF1->F1_DTDIGIT .And. nValorAdtFR3 != 0
			   		If l140Estor 
						Help(,,"A140ESTORN",, STR0226, 1, 0,,,,,,{STR0227})
						lRetorno := .F.
					Elseif l103Exclui
						Help(,,"A103NFISCAL",, STR0228, 1, 0,,,,,,{STR0227})
						lRetorno := .F.
					EndIf					
			   EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ compara o valor baixado para o titulo ( E2_VALOR - E2_SALDO ), com o valor dos adiantamentos. Se o valor for igual, continua a exclusao   ³
				//³ do documento, se o valor for diferente eh porque houveram outras baixas para o titulo, neste caso, nao eh possivel excluir o documento,   ³
				//³ primeiro deve-se excluir estas outras baixas no Financeiro.  												                                           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÀÄÄÄÄÄÄÄÄÄÄÙ
				If (cAliasSE2)->(E2_VALOR-E2_SALDO) = nValorAdtFR3 .And. lRetorno
					If !(Type('l103Auto') <> 'U' .And. l103Auto)
						If !ApMsgYesNo(STR0106 + CRLF+ STR0107) //"Por tratar-se de condição de pagamento com Adiantamento, a exclusão do Documento de Entrada também irá excluir a compensação do(s) título(s) de adiantamento associado(s) a este Documento de Entrada no momento da sua geração."#CRLF#"Deseja continuar?"
							lRetorno := .F.
						Endif
					Else
						// .T. - permite excl de docto de entrada com PC vinculado a PA.
						// .F. - não permite a exclusão.
						If !l103EstAdt
							lRetorno := .F.
							Help('',1,'103ESTADT',,STR0229,1,0)//"Sistema está configurado para não permitir a exclusão do documento de entrada via rotina automática quando houver vinculo com pedido de compra e pagamento antecipado. Verifique o parâmetro MV_ESTOADT"
						Endif
					Endif  
			   	Endif				   
			Endif 
		Endif	
	Endif	
	
	dbSelectArea(cAliasSE2)
		
	While ( !Eof() .And. lRetorno .And.;
			xFilial("SE2")  == (cAliasSE2)->E2_FILIAL  .And.;
			SF1->F1_FORNECE == (cAliasSE2)->E2_FORNECE .And.;
			SF1->F1_LOJA    == (cAliasSE2)->E2_LOJA    .And.;
			cPrefixo	    == (cAliasSE2)->E2_PREFIXO .And.;
			SF1->F1_DUPL	== (cAliasSE2)->E2_NUM )
		If (cAliasSE2)->E2_TIPO == MVNOTAFIS
			aadd(aRecSE2,If(lQuery,(cAliasSE2)->SE2RECNO,(cAliasSE2)->(RecNo())))

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ se for nota fiscal com adiantamento compensado, valida se a nota fiscal tem somente uma parcela no contas a pagar                                        ³
			//³ se for somente 1 parcela, segue o cancelamento e nao valida se o titulo estah baixado, pois a compensacao desta parcela vai ser desfeita na rotina       ³
			//³ A103Grava                                                                                                                                                ³
			//³ se for mais de uma parcela, valida as parcelas a partir da segunda, para checar se hah alguma parcela baixada                                            ³
			//³ se a nota fiscal tiver um pedido de compra oriundo de um contrato com caução não deve validar a exclusão do título a pagar							     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cPaisLoc $ "BRA|MEX"
				If SF1->F1_TIPO != "D"	
					If nCountSE2 = 0
						If A120UsaAdi(SF1->F1_COND)
		   					If !Empty((cAliasSE2)->E2_BAIXA) .and. (cAliasSE2)->E2_VALOR != (cAliasSE2)->E2_SALDO .And. !A103BXADT((cAliasSE2)->E2_PREFIXO,(cAliasSE2)->E2_NUM,(cAliasSE2)->E2_PARCELA,(cAliasSE2)->E2_TIPO,(cAliasSE2)->E2_FORNECE,(cAliasSE2)->E2_LOJA,(cAliasSE2)->E2_FILORIG) //tem baixa para o adiantamento
		   						lPriParAdtBx := .T.
		   					Endif
				   		Endif
				   	Endif
			   	Endif
		   	Endif	
			
			If IIf((cPaisLoc == "BRA" .And. lPriParAdtBx),.F., !lBxCaucGct .And. !FaCanDelCP(cAliasSE2,"MATA100|PLSMPAG"))
				lRetorno := .F.
				Exit
			EndIf  
			
			If cPaisLoc <> "RUS"
			// Verifica se titulo foi conciliado por DDA
				If VldConcDda((cAliasSE2)->E2_FILIAL, (cAliasSE2)->E2_FORNECE, (cAliasSE2)->E2_LOJA, (cAliasSE2)->E2_CODBAR, (cAliasSE2)->E2_FILIAL+ "|" + (cAliasSE2)->E2_PREFIXO+"|" + (cAliasSE2)->E2_NUM+"|" +;
								(cAliasSE2)->E2_PARCELA+"|" + (cAliasSE2)->E2_TIPO+"|" + (cAliasSE2)->E2_FORNECE+"|" + (cAliasSE2)->E2_LOJA + "|")
					lRetorno := .F.
					Help('',1,'FIN050DDA',,STR0166,1,0)
					Exit
				EndIf
			EndIf      

			If lRetISSMes
				dDataVenc := (cAliasSE2)->E2_VENCREA
			EndIf
			
			If ((cAliasSE2)->E2_PRETPIS == "2" .Or. (cAliasSE2)->E2_PRETCOF == "2" .Or. (cAliasSE2)->E2_PRETCSL == "2") .And.;
				((cAliasSE2)->E2_VRETPIS == 0 .Or. (cAliasSE2)->E2_VRETCOF == 0 .Or. (cAliasSE2)->E2_VRETCSL == 0)
				lAviso   := .T.
			Endif	

			If (cAliasSE2)->E2_ISS > 0 .Or. (cAliasSE2)->E2_VRETISS > 0
				lVldRetISS := .T.
		EndIf
		lPriParAdtBx := .F.
		nCountSE2++
		
		EndIf
		dbSelectArea(cAliasSE2)
		dbSkip()
	EndDo
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Apaga tambem os registro de impostos	   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aAreaSE2IR := GetArea()
	dbSelectArea("SE2")
	dbSetOrder(6)
	dbSeek(xFilial("SE2")+SF1->F1_FORNECE+SF1->F1_LOJA+cPrefixo+SF1->F1_DUPL) //xFilial("SE2")+cPrefixo+SF1->F1_DUPL )

    If (SE2->E2_FILIAL+SE2->E2_FORNECE+SE2->E2_LOJA+SE2->E2_PREFIXO+SE2->E2_NUM == ;
		(xFilial("SE2")+SF1->F1_FORNECE+SF1->F1_LOJA+cPrefixo+SF1->F1_DUPL))
		nRecE2in:=SE2->(RecNo())
		dbSetOrder(0)
		SE2->(MsGoto(nRecE2in))
		
		// Quantidade de titulos gerados PIS, COF ou ISS
		// Como a ordenação está de acordo com o recno, verifico a quantidade total que foi gerado de titulo ( PIS, COF ou ISS)
		nQtdTit := 0
		nQtdTot := 0

		cPrefOri  := SE2->E2_PREFIXO
		cNumOri   := SE2->E2_NUM
		cParcOri  := SE2->E2_PARCELA
		cTipoOri  := SE2->E2_TIPO
		cCfOri    := SE2->E2_FORNECE
		cLojaOri  := SE2->E2_LOJA
		cEmiOri   := SE2->E2_EMISSAO
		
		if SF1->F1_ISS > 0 
			nQtdTot += 1
		endif

		if SF1->F1_VALIMP5 > 0
			nQtdTot += 1
		endif

		if SF1->F1_VALIMP6 > 0
			nQtdTot += 1
		endif

		if SF1->F1_VALFASE > 0
			nQtdTot += 1
		endif

		//Natureza para Contribuição Seguridade Social.
 		IF ExistBlock("NTFUNR")
			cNatGilRat   := ExecBlock("NTFUNR",.f.,.f.,{SE2->E2_ORIGEM,SE2->E2_PREFIXO})
		Else
			cNatGilRat := SuperGetMv("MV_CSS",.F.,Criavar('ED_CODIGO'))
		Endif

		cNatGilRat := PadR(cNatGilRat,TamSX3('ED_CODIGO')[1]) 
		aNats := {&(SuperGetMv("MV_IRF")),;
					SuperGetMv("MV_PISIMP",.F.,""),;
					SuperGetMv("MV_COFIMP",.F.,""),;
					SuperGetMv("MV_ISSIMP",.F.,""),;
					SuperGetMv("MV_FASEIMP",.F.,""),; 
					cNatGilRat }

		While (!EOF() .And. ( ( SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM == (xFilial("SE2")+cPrefixo+SF1->F1_DUPL) ) ) .Or. ;
		(SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM == (xFilial("SE2")+(cPrefPIS+SF1->F1_DUPL))) .Or.;
		(SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM == (xFilial("SE2")+(cPrefCOF+SF1->F1_DUPL))) .Or.;
		(SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM == (xFilial("SE2")+(cPrefISS+SF1->F1_DUPL))) .Or.;
		(SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM == (xFilial("SE2")+(cPreFase+SF1->F1_DUPL))) .Or.;
		GetDelTitImp( cPrefPIS, cPrefCOF, cPrefISS, cPreFase, @nQtdTit, nQtdTot ) )

		 	if SE2->E2_PREFIXO == cPrefPIS .or. SE2->E2_PREFIXO == cPrefCOF .or. SE2->E2_PREFIXO == cPrefISS
		 		nQtdTit += 1
		 	endif

			If !Empty(SE2->E2_IDDARF) 
				lRetorno := .F.
				Help(" ",1,"NAOEXCNFS","NAOEXCNFS","Ja foi gerado DARF, ID "+SE2->E2_IDDARF+", verifique na rotina FINA373",1,0)
				Exit
			EndIf

			If !Empty(SE2->E2_TITPAI)
				If Alltrim(SE2->E2_TITPAI) == Alltrim(cPrefOri + cNumOri + cParcOri + cTipoOri + cCfOri + cLojaOri)
					aadd(aRecSE2,SE2->(RecNo()))			
				Endif
			Else	
				If (SE2->E2_FORNECE+SE2->E2_LOJA <> SF1->F1_FORNECE+SF1->F1_LOJA) .And. E2_TIPO <> "CID" .And. E2_TIPO <> "ISS"
					DbSkip()
					Loop			
				ElseIf Ascan(aNats,Alltrim(SE2->E2_NATUREZ)) > 0 .And. SE2->E2_SALDO != 0 .And. aScan(aRecSE2,SE2->(RecNo())) == 0
					aadd(aRecSE2,SE2->(RecNo()))			
				EndIf	
			Endif	
			//Acrescentado comparação com E2_TITPAI, pois esta é a forma mais segura de se identificar os titulos filhos no momento da exclusão da nota de entrada.
			//Caso o campo esteja vazio foi alterado a comparação para que seja rodado todo o loop de notas iguais para que caso seja identificado alguma com o mesmo 
			//fornecedor a mesma possa ser excluida e não apenas dar um EXIT como era anteriormente. 

			dbSkip()
		EndDo
  	EndIf
	RestArea(aAreaSE2IR)
	If lQuery
		dbSelectArea(cAliasSE2)
		dbCloseArea()
		dbSelectArea("SE2")
	EndIf
EndIf

If lRetorno .And. lRetISSMes .And. !Empty(dDataVenc) .And. lVldRetISS
	dDataIni:= FirstDay(dDataVenc)
	dDataFim:= LastDay(dDataVenc)
	
	lQuery    := .T.
 	cAliasSE2 := GetNextAlias()

	cQuery := "SELECT E2_PREFIXO, E2_NUM, E2_ISS, E2_VRETISS, SE2.R_E_C_N_O_ SE2RECNO "
	cQuery += "  FROM "+RetSqlName( "SE2" ) + " SE2 "
	cQuery += " WHERE E2_FILIAL   = '"+xFilial("SE2")+"'"
	cQuery += "   AND E2_FORNECE  = '"+SF1->F1_FORNECE	+ "'"
	cQuery += "   AND E2_LOJA     = '"+SF1->F1_LOJA+"'"
	cQuery += "   AND E2_VENCREA  >= '"+DToS(dDataIni)+"'"
	cQuery += "   AND E2_VENCREA  <= '"+DToS(dDataFim)+"'"
	cQuery += "   AND (E2_ISS > 0 OR E2_VRETISS > 0)"
	cQuery += "   AND E2_TIPO NOT IN " + FormatIn(MVABATIM,"|")
	cQuery += "   AND E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)
	cQuery += "   AND E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv)
	cQuery += "   AND E2_TIPO NOT IN " + FormatIn(MVPAGANT,cSepRec)
	cQuery += "   AND D_E_L_E_T_=' '"

	cQuery := ChangeQuery( cQuery )
	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasSE2, .F., .T. )
	
    TcSetField(cAliasSE2,"E2_ISS","N",TamSX3("E2_ISS")[1],TamSX3("E2_ISS")[2])
    TcSetField(cAliasSE2,"E2_VRETISS","N",TamSX3("E2_VRETISS")[1],TamSX3("E2_VRETISS")[2])
	
	While !(cAliasSE2)->(Eof())
		If cPrefixo == (cAliasSE2)->E2_PREFIXO .And.;
	       SF1->F1_DUPL == (cAliasSE2)->E2_NUM
			(cAliasSE2)->(dbSkip())
			If (cAliasSE2)->(Eof())
				lAvisoISS:= .F.			
				lRetorno := .T.
			ElseIf (cAliasSE2)->E2_ISS > 0
				lAvisoISS:= .T.
				lRetorno := .F.
				Exit
			EndIf
		Else
			If (cAliasSE2)->E2_ISS > 0
				lAvisoISS:= .T.
				lRetorno := .F.
			End
			(cAliasSE2)->(dbSkip())
		EndIf
	EndDo
	If lQuery
		dbSelectArea(cAliasSE2)
		dbCloseArea()
		dbSelectArea("SE2")
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se as duplicatas podem ser excluidas  SE1           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRetorno .And. SF1->F1_TIPO == 'D'
	cE1Cliente := SF1->F1_FORNECE // Quando integrado com DMS, o cliente pode ser outro se utilizado condicao de pagamento TIPO A na venda.
	cE1Loja    := SF1->F1_LOJA    // Quando integrado com DMS, o cliente pode ser outro se utilizado condicao de pagamento TIPO A na venda.
	cE1NReduz  := "" 			  // Quando integrado com DMS, o cliente pode ser outro se utilizado condicao de pagamento TIPO A na venda.

	If lIntGC .and. ExistFunc("FMX_NCCCliente")
		FMX_NCCCliente(SF1->F1_DOC, SF1->F1_SERIE, SF1->F1_FORNECE, SF1->F1_LOJA, @cE1Cliente, @cE1Loja, @cE1NReduz)
	EndIf

	dbSelectArea('SE1')
	dbSetOrder(2)
	If MsSeek(xFilial("SE1")+cE1Cliente+cE1Loja+cPrefixo+SF1->F1_DOC)
		While !Eof().And. lRetorno .And. xFilial()+cE1Cliente+cE1Loja+cPrefixo+SF1->F1_DOC==;
				E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM
			If !(SE1->E1_TIPO$ MV_CRNEG)
				dbSelectArea('SE1')
				dbSkip()
				Loop
			EndIf
			aadd(aRecSE1,SE1->(RecNo()))
			If SE1->E1_SALDO <> SE1->E1_VALOR
				Help(' ',1,'A100FINBX')
				lRetorno := .F.
			ElseIf !SoftLock('SE1')
				lRetorno := .F.
			EndIf
			dbSelectArea('SE1')
			dbSkip()
		EndDo
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                  
//³ Verifica se a NFE gerou Imposto ICMS ANTECIPACAO no SE2 CAPag³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If cPaisLoc == "BRA"
	If!Empty(SF1->F1_NUMTRIB)
		If AllTrim(SF1->F1_NUMTRIB) == "N"
			lNumTrib := .F.
		EndIf
		cNumTit := SF1->F1_NUMTRIB
	EndIf
Else
	cNumTit := SF1->F1_DOC
EndIf

If lRetorno .And. cPaisloc=="BRA" .And. lNumTrib
	dbSelectArea("SE2")
	SE2->(dbsetOrder(1))
	If dbSeek(xFilial("SE2") + "ICM" + cNumTit)
		Do While SE2->(!Eof()) .And. SE2->E2_PREFIXO+SE2->E2_NUM == "ICM" + cNumTit
			//Se o titulo sofreu pagamento nao permitir excluir a NFE
			If !Empty(SE2->E2_BAIXA).And. SE2->E2_SALDO<>SE2->E2_VALOR .And. ;
				ALLTRIM(SE2->E2_TIPO)=="TX" .And. ALLTRIM(SE2->E2_ORIGEM) == "MATA103"

				cMensagem:=" Não é possível excluir esse documento por "+CHR(10)
				cMensagem+="estar vinculado a um título a pagar de imposto "+CHR(10)
				cMensagem+="( "+SE2->E2_NUM+"/"+SE2->E2_PREFIXO+") baixado total ou parcialmente."+CHR(10)
				cMensagem+="Para excluir esse documento, será necessário "+CHR(10)
				cMensagem+="primeiramente estornar esse título através "+CHR(10)
				cMensagem+="do módulo financeiro."

				Help(" ",1,"NAOEXCNFS","NAOEXCNFS",cMensagem,1,0)
				lRetorno := .F.
			Endif
			SE2->(DbSkip())
		EndDo
	Endif
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Integracao com o EEC     											|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRetorno .And. lEECFAT
	lRetorno := EECFAT3("VLD",.T.)
EndIf

If lAviso .And. lShowAviso
	If !(Type('l103Auto') <> 'U' .And. l103Auto)
		Aviso(OemToAnsi(STR0018),OemToAnsi(STR0039),{OemToAnsi(STR0038)},2)
	EndIf	
ElseIf lAvisoISS
	If !(Type('l103Auto') <> 'U' .And. l103Auto)
		Aviso(OemToAnsi(STR0018),OemToAnsi(STR0041),{OemToAnsi(STR0038)},2)
	EndIf	
Endif

//-----------------------------------------------------------------------------------------
//Verifica abaixo se existem títulos de recolhimento gerados pelo motor Fiscal/Financeiro
//-----------------------------------------------------------------------------------------
If lRetorno .And. cPaisloc == "BRA" .And. AliasInDic("F2F") .And. AliasInDic("FK7") .AND. FindFunction("xFisDelTit") .And. SF1->(FieldPos('F1_IDNF')) > 0 
	// Opcao = 1 p/ somente validar a exclusão.
	lRetorno := xFisDelTit(SF1->F1_IDNF, "SF1", "MATA100", 1)
EndIf

If !lRetorno .And. lExcViaEIC
	lMsErroAuto := .T.
EndIf

RestArea(aAreaSD1)
RestArea(aAreaSF8)
RestArea(aArea)

Return lRetorno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³ A103Potenc  ³Autor³Rodrigo de A. Sartorio³ Data ³ 17/06/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Validacao para digitar a potencia do Lote corretamente     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata103                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103Potenc()
LOCAL lRet      := .T.
LOCAL cCod		:= aCols[n][GetPosSD1("D1_COD")]
LOCAL cLocal    := aCols[n][GetPosSD1("D1_LOCAL")]
LOCAL nPosLote  := GetPosSD1("D1_NUMLOTE")
LOCAL nPosLotCTL:= GetPosSD1("D1_LOTECTL")
LOCAL nPotencia := &(ReadVar())
LOCAL aAreaSB8  := SB8->(GetArea())
LOCAL cAlias    := Alias()
If nPotencia <> 0
	If !Rastro(cCod)
		Help(" ",1,"NAORASTRO")
		lRet:=.F.
	Else
		If !PotencLote(cCod)
			Help(" ",1,"NAOCPOTENC")
			lRet:=.F.
		EndIf	
		If lRet .And. ((nPosLotCTL > 0 .And. !Empty(aCols[n,nPosLotCTL])) .Or. (nPosLote > 0 .And. !Empty(aCols[n,nPosLote])))
			// Verifica se a data de validade pode ser utilizada
			dbSelectArea("SB8")
			dbSetOrder(3)	
			If MsSeek(xFilial("SB8")+cCod+cLocal+aCols[n,nPosLotCTL]+IF(Rastro(cCod,"S"),+aCols[n,nPosLote],"")) .And. nPotencia # SB8->B8_POTENCI
				Help(" ",1,"POTENCORI")
				&(ReadVar()):=SB8->B8_POTENCI
			EndIf
			RestArea(aAreaSB8)
		EndIf
	EndIf
EndIf

dbSelectArea(cAlias)
Return lRet


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³MaAvalSF1 ³ Autor ³ Eduardo Riera         ³ Data ³30.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de complemento de atualizacao dos dados do documento  ³±±
±±³          ³de entrada                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Codigo do evento                                      ³±±
±±³          ³       [1] Implantacao do pre-documento de Entrada           ³±±
±±³          ³       [2] Estorno do pre-documento de Entrada               ³±±
±±³          ³       [3] Exclusao do pre-documento de entrada              ³±±
±±³          ³       [4] Implantacao do documento de Entrada               ³±±
±±³          ³       [5] Estorno do documento de Entrada                   ³±±
±±³          ³       [6] Exclusao do documento de Entrada                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo complementar a atualizacao dos ³±±
±±³          ³dados do documento de entrada e seus anexos                  ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaAvalSF1(nOpcao,cAliasSF1)

Local aArea       := GetArea()
Local aAreaSF1    := SF1->(GetArea())
Local lHomologado := .F.
Local lAtuSA2     := .T.
Local cSF1PKey    := xFilial("SF1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA
Local nMCusto	  := Val(SuperGetMV("MV_MCUSTO"))
Local lMT103TRV   := ExistBlock("MT103TRV")

Default cAliasSF1 := "SF1"

Do Case
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Implantacao do Pre documento de entrada                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nOpcao == 1

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorno do Pre documento de entrada                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nOpcao == 2

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclusao do Pre documento de entrada                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nOpcao == 3
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza os acumulados do fornecedor                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (cAliasSF1)->F1_TIPO=="N"
		// Ponto de Entrada MT103TRV utilizado para desligar a atualizacao da tabela SA2
		If lMT103TRV 
			lAtuSA2 := ExecBlock("MT103TRV",.F.,.F.,{SF1->F1_FORNECE,SF1->F1_LOJA,"F"})[2]
		EndIf
		// Atualiza dados da SA2 com base no documento incluido		
		If lAtuSA2 
			RecLock("SA2",.F.)
			SA2->A2_MCOMPRA := Max(xMoeda(SF1->F1_VALBRUT,1,Val(SuperGetMV("MV_MCUSTO")),SF1->F1_EMISSAO),SA2->A2_MCOMPRA)
			SA2->A2_MNOTA   := Max(SA2->A2_MNOTA,Round(NoRound(xMoeda(SF1->F1_VALBRUT,1,nMCusto,SF1->F1_EMISSAO,3),3),2) )
			SA2->(MsUnLock())
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Reabre o Aviso de Recebimento se Houver                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("DB2")
	dbSetOrder(1)
	If MsSeek(xFilial("DB2")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
		dbSelectArea("DB1")
		dbSetOrder(1)
		If MsSeek(xFilial("DB1")+DB2->DB2_NRAVRC)
			dbSelectArea("DB2")
			dbSetOrder(1)
			While !Eof() .And. xFilial("DB2") == DB2->DB2_FILIAL .And.;
				DB2->DB2_NRAVRC == DB1->DB1_NRAVRC
				If xFilial("SF1")+DB2->DB2_DOC+DB2->DB2_SERIE+DB2->DB2_CLIFOR+DB2->DB2_LOJA <>  cSF1PKey 
					dbSelectArea("SF1")
					dbSetOrder(1)
					If MsSeek(xFilial("SF1")+DB2->DB2_DOC+DB2->DB2_SERIE+DB2->DB2_CLIFOR+DB2->DB2_LOJA) 
						lHomologado := .T.
						Exit
					EndIf
				EndIf
				dbSelectArea("DB2")
				dbSkip()
			EndDo
			RecLock("DB1",.F.,.T.)			
			DB1->DB1_HOMOLO := IIf(lHomologado,"2","1")	 // Reabre o Aviso de Recebimento como parcialmente atendido
			MsUnLock()
		EndIf		
    EndIf
	RestArea(aAreaSF1)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Implantacao do documento de entrada                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nOpcao == 4
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza os acumulados do fornecedor                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (cAliasSF1)->F1_TIPO=="N"
		//Nao realizado por falta de informacao
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorno do documento de entrada                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nOpcao == 5

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclusao do documento de entrada                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nOpcao == 6
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Reabre o Aviso de Recebimento se Houver                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("DB2")
	dbSetOrder(1)
	If MsSeek(xFilial("DB2")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
		dbSelectArea("DB1")
		dbSetOrder(1)
		If MsSeek(xFilial("DB1")+DB2->DB2_NRAVRC)
			dbSelectArea("DB2")
			dbSetOrder(1)
			While !Eof() .And. xFilial("DB2") == DB2->DB2_FILIAL .And.;
				DB2->DB2_NRAVRC == DB1->DB1_NRAVRC
				If xFilial("SF1")+DB2->DB2_DOC+DB2->DB2_SERIE+DB2->DB2_CLIFOR+DB2->DB2_LOJA <>  cSF1PKey 
					dbSelectArea("SF1")
					dbSetOrder(1)
					If MsSeek(xFilial("SF1")+DB2->DB2_DOC+DB2->DB2_SERIE+DB2->DB2_CLIFOR+DB2->DB2_LOJA) 
						lHomologado := .T.
						Exit
					EndIf
				EndIf
				dbSelectArea("DB2")
				dbSkip()
			EndDo
			RecLock("DB1",.F.,.T.)			
			DB1->DB1_HOMOLO := IIf(lHomologado,"2","1")	 // Reabre o Aviso de Recebimento como parcialmente atendido
			MsUnLock()
		EndIf		
    EndIf
EndCase
RestArea(aAreaSF1)
RestArea(aArea)
Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³MaAvalSD1 ³ Autor ³ Eduardo Riera         ³ Data ³01.10.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de complemento de atualizacao dos dados do item do    ³±±
±±³          ³documento de entrada                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Codigo do evento                                      ³±±
±±³          ³       [1] Implantacao de pre-documento de entrada           ³±±
±±³          ³       [2] Estorno do pre-documento de entrada               ³±±
±±³          ³       [3] Exclusao fisica do pre-documento de entrada       ³±±
±±³          ³       [4] Implantacao do documento de entrada               ³±±
±±³          ³       [5] Estorno do documento de entrada                   ³±±
±±³          ³       [6] Exclusao fisica do documento de entrada           ³±±
±±³          ³ExpC2: Alias do SD1                                     (OPC)³±±
±±³          ³ExpL3:Indica se o SA5 deve ser Incluido                 (OPC)³±±
±±³          ³ExpL4:Indica se a data da ultima compra sera dt.digitacao ou ³±±
±±³          ³      emissao.                                               ³±±
±±³          ³ExpL5:Indica se o custo atualizado no SA5 deve ser liquido   ³±±
±±³          ³      (OPC)                                                  ³±±
±±³          ³ExpL6:Indica se o SA5 deve ser atualizado               (OPC)³±±
±±³          ³ExpA7:Array com os recnos do documentos de entrada de origem ³±±
±±³          ³      (OPC)                                                  ³±±
±±³          ³ExpA8:Array com os numeros dos contratos deste docto de      ³±±
±±³          ³  entrada - gestao de contratos (OPC)                        ³±±
±±³          ³ExpL9: Indica de grava SA5 pelo codigo do produto ou pela    ³±±
±±³          ³       referencia de grade                                   ³±±
±±³          ³lEstNfClass - indica se eh estorno da classificacao          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo complementar a atualizacao dos ³±±
±±³          ³dados do item do documento de entrada e seus anexos          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaAvalSD1(nOpcao,cAliasSD1,lIncSA5,lDataUcom,lPrecoDes,lAtuSA5,aRecSF1Ori,aContratos,lIncRef,aCIAP,lEstNfClass,aCompFutur,lAgregaOri)

Local aArea      := SD1->(GetArea())
Local aAreaSD1   := {}
Local aAreaSF1   := {}
Local aAreaSA2   := {}
Local aCustoEnt  := {}
Local aEnvCele   := {}
Local aRetQIE    := {}
Local aMov       := {}
Local aLote      := {"",""}
Local aSD3       := {}
Local cCursorSD7 := "SD7"
Local cLocOrig   := SD1->D1_LOCAL
Local nAtraso    := 0
Local nX         := 0
Local lEnviaCQ   := .F.
Local lEnvCQPE   := .F.
Local lQuery     := .F.
Local aBaixa     := {}
Local nQtdBaixa  := 0
Local lAjNfCompl := SuperGetMV("MV_AJUSNFC",.F.,.F.)
Local lCusFifo   := SuperGetMV("MV_CUSFIFO",.F.)
Local lCusLifo   := SuperGetMV("MV_CUSLIFO",.F.,.F.)
Local lEECFAT    := SuperGetMv("MV_EECFAT",.F.,.F.)
Local cFTCiap    := GetNewPar("MV_FTCIAP","N") //Utilizado para calc. ICMS no CIAP. Se S= Considera valor de ICMS FRETE se N= Nao considera ICMS FRETE.
Local lVldNFO    := SuperGetMV("MV_VLDNFO",.F.,.F.)

Local nVlrCompl  := 0
Local cDoc       := ""
Local cSerie     := ""
Local cFornec    := ""
Local cLoja      := ""
Local cCod       := ""
Local cItem      := ""
Local cTemp		 := GetNextAlias()
Local cUsoD1_TRT := GetSx3Cache("D1_TRT","X3_USADO")

Local nQtdD1     := 1
Local cProdRef   := " "
Local cNfFrete	 := ""
Local cSeFrete	 := ""
Local cForFrete	 := ""
Local cLojFrete	 := ""
Local cProdItem	 := ""
Local cProd		 := ""
Local cCodCiap	 := ""
Local lAchou    := .F.     
Local lReferencia := .F.
Local lTemSDC    := .F.
Local lRetEnd    := .T.
Local lComplQtd  := Type("cTpCompl") == "C" 
Local cLocaliz   := ""
Local nSldRE5 	 := 0
Local nQtdBxa    := 0
Local nQtdSDC  	 := 0
Local nQtdSD4    := 0
Local nPcoCompra :=0
Local nIcmFrete	 := 0
Local nQtdOriFr  := 0
Local nValOriFr  := 0
Local nVlDescFr  := 0
Local lTpNFQie 	 := iif(ExistBlock("MT103QIETP"),ExecBlock("MT103QIETP",.F.,.F.),.F.) 		// permite mudar o tipo do documento ao legado (NF)									
Local cFabric  := ""
Local cFabLoja := ""
Local nMcusto		:= SuperGetMV("MV_MCUSTO")
Local cSimpNac   := ""
Local nF1Origem  := 0
Local nFilCiap   := 0
Local nCodCiap   := 0
static lInspec  := iif(ExistBlock("Q103INSP"),ExecBlock("Q103INSP",.F.,.F.),.F.) 		// Permite gerar inspeção de entrada em produto tipo CQ = M

Local aStruSD7  := {}
Local cQuery    := ""	

Local lWmsNew := SuperGetMv("MV_WMSNEW",.F.,.F.)
Local lD1FilOri	:= SD1->(ColumnPos("D1_FILORI")> 0)
Local cD1FilOri	:= ""
Local cSF2Fil 	:= ""
Local lProcLoja	:= IsInCallStack("LOJA720")
Local lDHQInDic := AliasInDic("DHQ") .And. SF4->(ColumnPos("F4_EFUTUR") > 0)
Local lMt103Com := FindFunction("A103FutFat") .And. FindFunction("A103FutRem")
Local ld3kLimp	:= Findfunction('MatLimpD3K')
Local lFornece := SD3->(ColumnPos("D3_FORNDOC")) > 0 .And. SD3->(ColumnPos("D3_LOJADOC")) > 0

Static _oQrySW7 

DEFAULT cAliasSD1 := "SD1"
DEFAULT lIncSA5   := .F.
DEFAULT lAtuSA5   := .F.
DEFAULT lDataUcom := .F.
DEFAULT lPrecoDes := .F.
DEFAULT aCIAP     := {{(cAliasSD1)->D1_CODCIAP}}
DEFAULT lEstNfClass := .F.
DEFAULT lIncRef   := .F. 
DEFAULT aCompFutur := {}
DEFAULT lAgregaOri := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Funcao utilizada para verificar a ultima versao dos fontes      ³
//³ SIGACUS.PRW, SIGACUSA.PRX e SIGACUSB.PRX, aplicados no rpo do   |
//| cliente, assim verificando a necessidade de uma atualizacao     |
//| nestes fontes. NAO REMOVER !!!							        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If (SF4->F4_ATUATF == "N" .And. SF4->F4_CIAP == "S") .Or. (SF4->F4_ATUATF == "S" .And. SF4->F4_CIAP == "S")
	aCIAP := {{(cAliasSD1)->D1_CODCIAP}}
EndIf                                              
        
cProdRef	:= (cAliasSD1)->D1_COD
lReferencia	:= MatGrdPrrf(@cProdRef,.T.)
		
Do Case
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Implantacao de um pre-documento de entrada                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nOpcao == 1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza a quantidade nao classificada nos saldos fisicos           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB2")
	dbSetOrder(1)
	If !(xFilial("SB2")==SB2->B2_FILIAL .And. (cAliasSD1)->D1_COD==SB2->B2_COD .And. (cAliasSD1)->D1_LOCAL==SB2->B2_LOCAL)
		If !MsSeek(xFilial("SB2")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL) .and. !Empty((cAliasSD1)->D1_LOCAL)
			CriaSB2((cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL)
		EndIf
	EndIf
	If !Empty((cAliasSD1)->D1_LOCAL)
		RecLock("SB2",.F.)
		SB2->B2_NAOCLAS += (cAliasSD1)->D1_QUANT
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza a quantidade nao classificada do pedido de Compra          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	MaAvalPC("SC7",6)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Tratamento da gravacao do SD1 na Integridade Referencial            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SD1->(FkCommit())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com PMS                                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If IntePms()
		If !IsIntegTop(,.T.)
			PmsWriteNF(1,cAliasSD1,.T.)
		Else
			If !Empty(SD1->D1_PEDIDO)
				If !PMSNFSA(SD1->D1_PEDIDO,SD1->D1_ITEMPC)[1] //Não é S.A
					PmsWriteNF(1,cAliasSD1,.T.)
				Endif
			Else
				PmsWriteNF(1,cAliasSD1,.T.)
			Endif
		Endif
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica complementos de integracao                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("bTTSSD1")=="B"
		Eval(bTTSSD1,nOpcao)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorno de um pre-documento de entrada                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
Case nOpcao == 2
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com PMS                                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If IntePms()
		If !IsIntegTop(,.T.)
			PmsWriteNF(2,cAliasSD1,.T.)
		Else
			If !Empty(SD1->D1_PEDIDO)
				If !PMSNFSA(SD1->D1_PEDIDO,SD1->D1_ITEMPC)[1] //Não é S.A
					PmsWriteNF(2,cAliasSD1,.T.)
				Endif
			Else
				PmsWriteNF(2,cAliasSD1,.T.)
			Endif
		Endif
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza a quantidade nao classificada do pedido de Compra          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	MaAvalPC("SC7",7)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza a quantidade nao classificada nos saldos fisicos           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB2")
	dbSetOrder(1)
	If !(xFilial("SB2")==SB2->B2_FILIAL .And. (cAliasSD1)->D1_COD==SB2->B2_COD .And. (cAliasSD1)->D1_LOCAL==SB2->B2_LOCAL)
		If !MsSeek(xFilial("SB2")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL)
			CriaSB2((cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL)
		EndIf
	EndIf
	RecLock("SB2",.F.)
	SB2->B2_NAOCLAS -= (cAliasSD1)->D1_QUANT	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica complementos de integracao                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("bTTSSD1")=="B"
		Eval(bTTSSD1,nOpcao)
	EndIf	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclusao fisica de um pre-documento de entrada                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
Case nOpcao == 3
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com PMS                                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If IntePms()
		If !IsIntegTop(,.T.)
			PmsWriteNF(3,cAliasSD1,.T.)
		Else
			If !Empty(SD1->D1_PEDIDO)
				If !PMSNFSA(SD1->D1_PEDIDO,SD1->D1_ITEMPC)[1] //Não é S.A
					PmsWriteNF(3,cAliasSD1,.T.)
				Endif
			Else
				PmsWriteNF(3,cAliasSD1,.T.)
			Endif
		Endif
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica complementos de integracao                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("bTTSSD1")=="B"
		Eval(bTTSSD1,nOpcao)
	EndIf	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Implantacao de um documento de entrada                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nOpcao == 4
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona registros                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB1")
	dbSetOrder(1)
	MsSeek(xFilial("SB1")+(cAliasSD1)->D1_COD)

	dbSelectArea("SF4")
	dbSetOrder(1)
	MsSeek(xFilial("SF4")+(cAliasSD1)->D1_TES)	

	dbSelectArea("SA2")
	dbSetOrder(1)
	MsSeek(xFilial("SA2")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA)


	dbSelectArea("SB2")
	dbSetOrder(1)
	If SF4->F4_ESTOQUE == "S" .And. !(xFilial("SB2")==SB2->B2_FILIAL .And. (cAliasSD1)->D1_COD==SB2->B2_COD .And. (cAliasSD1)->D1_LOCAL==SB2->B2_LOCAL)
		If !MsSeek(xFilial("SB2")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL)
			CriaSB2((cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL)
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pedido de Compra                                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty((cAliasSD1)->D1_PEDIDO)
		nRecC7 := A103RECC7(xFilial("SC7"),(cAliasSD1)->D1_PEDIDO,(cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,(cAliasSD1)->D1_COD,(cAliasSD1)->D1_ITEMPC)
		SC7->(DbGoTo(nRecC7))
		If nRecC7 > 0
			nAtraso := (cAliasSD1)->D1_DTDIGIT-SC7->C7_DATPRF			
			If	MA103CkAIC(SC7->C7_FORNECE,SC7->C7_LOJA,SC7->C7_PRODUTO)	
				(cAliasSD1)->D1_QTDPEDI	:= (cAliasSD1)->D1_QUANT
			Else
				(cAliasSD1)->D1_QTDPEDI	:= Min(SC7->C7_QUANT-SC7->C7_QUJE,(cAliasSD1)->D1_QUANT)
			EndIf
			MaAvalPC("SC7",8)
			
			If A103GcDisp() 
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Baixa o saldo a receber da planilha                                    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				CtaAvalGCT(1,aContratos,SC7->C7_CONTRA,SC7->C7_PLANILH,SC7->C7_ITEMED,SD1->D1_QUANT,,SC7->C7_MEDICAO,SD1->D1_TOTAL)
			EndIf 				
			
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Amarracao Fornecedor/Produto                                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lIncSA5 .And. (cAliasSD1)->D1_TIPO == "N" 
	    cRefGrd := AtuSA5((cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,(cAliasSD1)->D1_COD,lIncRef)
		If !Empty(SB1->B1_GRUPO)
			dbSelectArea("SBM")
			dbSetOrder( 1 )
			If MsSeek(xFilial("SBM")+SB1->B1_GRUPO)
				dbSelectArea("SAD")
				dbSetOrder(1)
				If !MsSeek(xFilial("SAD")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+SB1->B1_GRUPO,.F.)
					RecLock("SAD",.T.)
					SAD->AD_FILIAL	:= xFilial("SAD")
					SAD->AD_FORNECE := (cAliasSD1)->D1_FORNECE
					SAD->AD_LOJA    := (cAliasSD1)->D1_LOJA
					SAD->AD_NOMEFOR := SA2->A2_NOME
					SAD->AD_GRUPO   := SB1->B1_GRUPO
					SAD->AD_NOMGRUP := SBM->BM_DESC
					MsUnlock()
				EndIf
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Analise do CQ                                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	If SF4->F4_ESTOQUE == "S"
		lEnviaCQ := .F.
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³                  CONDICOES DE ENVIO AO CQ                              ³
		//³                                                                        ³
		//³1) Documentos de entrada de complemento de preco, despesa de importacao,³
		//³   conhecimento de frete e entrada serao enviados ao CQ se o almoxarifa-³
		//³   do de destino for o MV_CQ                                            ³
		//³2) Documentos de complemento serao enviados ao CQ se o documento de ori-³
		//³   gem foi enviado para o CQ.                                           ³
		//³3) Para o Controle de CQ Microsiga os documentos de entrada tipo Normal ³
		//³   serao enviados caso:                                                 ³
		//³   a)A nota do fornecedor ( A5_NOTA ) for inferior a nota minima do pro-³
		//³   duto ( B1_NOTAMIN ).                                                 ³
		//³   b)O documento de entrada for escolhido pelo criterio de SKIP-LOTE    ³
		//³4) Produtos com controle de CQ pelo Quality                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			
		Do Case
		Case (cAliasSD1)->D1_TIPO == "C" .And. (cAliasSD1)->D1_ORIGLAN $"FR,DP" .And. alltrim((cAliasSD1)->D1_LOCAL) == SuperGetMV("MV_CQ")
			lEnviaCQ := .T.
		Case (cAliasSD1)->D1_TIPO $ "CIP" .And.!Empty((cAliasSD1)->D1_ITEMORI)
			aAreaSD1 := (cAliasSD1)->(GetArea())
			dbSelectArea("SD1")
			dbSetOrder(1)
			If MsSeek(xFilial("SD1")+(cAliasSD1)->D1_NFORI+(cAliasSD1)->D1_SERIORI+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_ITEMORI,.F.)
				If alltrim((cAliasSD1)->D1_LOCAL) == alltrim(SuperGetMV("MV_CQ"))
					lEnviaCQ := .T.
				EndIf
			EndIf
			RestArea(aAreaSD1)
		Case (cAliasSD1)->D1_TIPO == "N" .And. !((cAliasSD1)->D1_QUANT > 0)	// Nota Normal com quantidade zero nao gera movimentacao de CQ (SD7) e nao deve direcionar para o armazem CQ caso contrario o custo fica perdido no CQ nao sendo possivel liberar
			lEnviaCQ := .F.
		Case !(cAliasSD1)->D1_TIPO $ "CIP" .And. alltrim((cAliasSD1)->D1_LOCAL) == alltrim(SuperGetMV("MV_CQ"))
			lEnviaCQ := .T.
		Case (cAliasSD1)->D1_TIPO == "N" .And. RetFldProd(SB1->B1_COD,"B1_TIPOCQ") $ " ,M"
			If !Empty((cAliasSD1)->D1_CONHEC)
				dbSelectArea("SW7")
				dbSetOrder(1)
				If _oQrySW7 == nil 
					cQuery := "SELECT W7_FABR, W7_FABLOJ FROM "
					cQuery += RetSqlName("SW7")
					cQuery += " WHERE W7_FILIAL = ?"
					cQuery += " AND W7_HAWB     = ?"
					cQuery += " AND W7_COD_I    = ?"
					cQuery += " AND W7_FORN     = ?"
					cQuery += " AND W7_POSICAO  = ?"
					cQuery += " AND D_E_L_E_T_  = ?"
					If __lVLib
						_oQrySW7 := FwExecStatement():New(cQuery)
					Else
						_oQrySW7 := FWPreparedStatement():New(cQuery)
					EndIf
				EndIf
				_oQrySW7:SetString(1, xFilial('SW7'))
				_oQrySW7:SetString(2, PadR(Alltrim((cAliasSD1)->D1_CONHEC),TamSX3("W7_HAWB")[1]))
				_oQrySW7:SetString(3, (cAliasSD1)->D1_COD)
				_oQrySW7:SetString(4, SF1->F1_FORNECE)
				_oQrySW7:SetString(5, (cAliasSD1)->D1_ITEM)
				_oQrySW7:SetString(6, Space(1))

				If __lVLib
					_oQrySW7:OpenAlias('_QrySW7')
				Else
					cQuery := _oQrySW7:GetFixQuery()
					MpSysOpenQuery(cQuery,'_QrySW7')
				EndIf
				If _QrySW7->(!Eof())
					cFabric  := _QrySW7->W7_FABR
					cFabLoja := _QrySW7->W7_FABLOJ
				EndIf 
				_QrySW7->(dbCloseArea())
			EndIf			
			dbSelectArea("SA5")
			dbSetOrder(1)
			If !Empty(cFabric) .And. !Empty(cFabLoja)
				lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_COD+cFabric+cFabLoja,.F.)
			Else
				lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_COD,.F.)
			EndIf
			If !lAchou .And. lReferencia
				dbSelectArea("SA5")
				dbSetOrder(9)
				If !Empty(cFabric) .And. !Empty(cFabLoja)
					lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+cProdRef+cFabric+cFabLoja,.F.)
				Else
					lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+cProdRef,.F.)
				EndIf
			Endif
			If lAchou
				If SA5->A5_NOTA<SB1->B1_NOTAMIN .Or. SA5->A5_SKIPLOT>0
					If  SA5->A5_NOTA<SB1->B1_NOTAMIN .Or.  Mod(SA5->A5_ENTREGA,SA5->A5_SKIPLOT)==0
						lEnviaCQ := .T.
					EndIf
					If SA5->A5_SKIPLOT > 0
						RecLock("SA5",.F.)
						SA5->A5_ENTREGA += 1
						MsUnlock()
					EndIf
				EndIf
			EndIf
		Case RetFldProd(SB1->B1_COD,"B1_TIPOCQ") == "Q"
			DbSelectArea("SA5")
			DbSetOrder(1)
			lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_COD,.F.)
			If !lAchou .And. lReferencia
				DbSelectArea("SA5")
				DbSetOrder(9)
				lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+cProdRef,.F.)
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Quando houver integracao com o Quality as NFs referentes a Beneficia-  ³
			//³ mento e Devolucao poderao ser Inspecionadas conforme parametrizacao.   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If QieTipoNF(SD1->D1_TIPO,SD1->D1_TES)
				lEnviaCQ := .F.
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Ponto de Entrada para critica do Envio do Material para  ³
				//³ Inspecao no Quality, para Inspecao no Quality o mesmo de ³
				//³ vera estar igual a .T.									 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ExistBlock("ENVCQQUA")
					lEnviaCQ := ExecBlock("ENVCQQUA",.F.,.F.)										
				Else
					lEnviaCQ := .T.
				EndIf
			EndIf
		EndCase
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de Entrada para critica do Envio do Material para  ³
		//³ C.Q.                                                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistBlock("ENVCQMAT")
			lEnvCQPE := ExecBlock("ENVCQMAT",.F.,.F.,{lEnviaCQ})										
			If ValType(lEnvCQPE) == "L"
				lEnviaCQ := lEnvCQPE
			Endif
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualizacao do CQ                                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lEnviaCQ
			If allTRIM((cAliasSD1)->D1_LOCAL)  <> alltrim(SuperGetMV("MV_CQ"))
				(cAliasSD1)->D1_LOCAL := SuperGetMV("MV_CQ")
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza Poder de Terceiro                                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SF4->F4_PODER3<>"N"
		aCustoEnt := MaAtuSB6("SD1",1)
		(cAliasSD1)->D1_CUSTO	:= aCustoEnt[1]
		(cAliasSD1)->D1_CUSTO2	:= aCustoEnt[2]
		(cAliasSD1)->D1_CUSTO3	:= aCustoEnt[3]
		(cAliasSD1)->D1_CUSTO4	:= aCustoEnt[4]
		(cAliasSD1)->D1_CUSTO5	:= aCustoEnt[5]	
	EndIf

	// Compra com entrega futura.
	If lDHQInDic .And. lMt103Com
		// F4_EFUTUR -> 1-Simples faturamento de compra futura / 2-Remessa de compra futura.
		If SF4->F4_EFUTUR = "1" .And. (cAliasSD1)->D1_QUANT > 0 .And. (cAliasSD1)->D1_VUNIT > 0
			A103FutFat(.F.)
		ElseIf SF4->F4_EFUTUR = "2" .And. Len(aCompFutur) > 0  // Nota de remessa de compra futura.
			A103FutRem(.F., aCompFutur)
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ CIAP                                                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aAreaSA2 := SA2->(GetArea())
	If SA2->(MsSeek(xFilial("SA2")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA))
		cSimpNac := Iif(cPaisLoc == "BRA",SA2->A2_SIMPNAC,"")
	Endif
	RestArea(aAreaSA2)
	
	If (SF4->F4_CIAP=="S" .And. (((cAliasSD1)->D1_VALICM  > 0 .Or. SF4->F4_CREDICM == "S") .Or. ((cAliasSD1)->D1_ICMNDES > 0) .Or. ;	
	(SF4->F4_COMPL == "S" .And. cSimpNac == "1")))
	
		If Type('l103Auto')=='L'
			If l103Auto
				nF1Origem  := aScan(aAutoCab, {|x| x[1] == "F1_ORIGEM"}) 
		        nFilCiap   := aScan(aAutoItens[1], {|x| x[1] == "FIL_CIAP"})
		        nCodCiap   := aScan(aAutoItens[1], {|x| x[1] == "COD_CIAP"})
		    EndIf
		EndIf

		(cAliasSD1)->D1_CODCIAP := A103CIAP(1, cAliasSD1, , "MATA103", nF1Origem, nFilCiap, nCodCiap, aRecSF1Ori)

	ElseIf AllTrim(cFTCiap) == "S" .And. IsInCallStack("MATA116")    
		aAreaSD1  := SD1->(GetArea())
		aAreaSF1  := SF1->(GetArea())
		cNfFrete := (cAliasSD1)->D1_DOC
		cSeFrete := (cAliasSD1)->D1_SERIE
		cForFrete := (cAliasSD1)->D1_FORNECE
		cLojFrete := (cAliasSD1)->D1_LOJA
		cProdItem := (cAliasSD1)->D1_COD
	 	
		//CIAP - NF de Complemento de Frete - Atualiza o valor de ICMS do BEM (SF9) somando o valor de ICMS do frete.
		#IFDEF TOP
			If (TcSrvType ()<>"AS/400")
				BeginSql alias cTemp
					SELECT SD1.D1_CODCIAP, SD1.D1_COD, SD1.D1_SERIE, SD1.D1_FORNECE, SD1.D1_LOJA, SD1.D1_VALICM, SD1.D1_QUANT
						FROM %table:SD1% SD1
						WHERE SD1.D1_FILIAL = %xfilial:SD1% AND
							  SD1.D1_DOC = %exp:cNfFrete% AND
							  SD1.D1_SERIE = %exp:cSeFrete% AND
							  SD1.D1_FORNECE = %exp:cForFrete% AND
							  SD1.D1_LOJA = %exp:cLojFrete% AND
							  SD1.D1_COD = %exp:cProdItem% 
				EndSql					
				For nX := 1 to Len(aRecSF1Ori)
					dbSelectArea("SF1")
					MsGoto(aRecSF1Ori[nX])
					
					While !(cTemp)->(Eof())
						cProd := (cTemp)->D1_COD
						nIcmFrete := (cTemp)->D1_VALICM
						DbSelectArea("SD1")
						DbSetOrder(2)
						If SD1->(MsSeek(xFilial("SD1")+cProd+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)) 
							nQtdD1 := Int(SD1->D1_QUANT)
					
							DbSelectArea("SF9")
							DbSetOrder(1)
							If SF9->(MsSeek(xFilial("SF9")+SD1->D1_CODCIAP))
									While !SF9->(EOF()) .And.;
									 (xFilial("SF9")+DTOS(F9_DTENTNE)+F9_DOCNFE+F9_SERNFE+F9_FORNECE+F9_LOJAFOR+F9_CFOENT) == (xFilial("SF9")+SD1->(DTOS(D1_DTDIGIT)+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_CF))
										If SF9->F9_QTDPARC == SF9->F9_SLDPARC
											RecLock("SF9",.F.)
											IF SF4->F4_BENSATF == "2"
												SF9->F9_VALICMS += NoRound((nIcmFrete/nQtdD1),2) * nQtdD1
												SF9->F9_VALFRET += NoRound((nIcmFrete/nQtdD1),2) * nQtdD1
											Else
												SF9->F9_VALICMS += NoRound((nIcmFrete/nQtdD1),2) 
												SF9->F9_VALFRET += NoRound((nIcmFrete/nQtdD1),2) 
											EndIf
											MsUnlock()
										EndIf
										SF9->(DbSkip())
									EndDo
							EndIf
						EndIf
						(cTemp)->(dbSkip())
		   			EndDo
		   		Next nX
			Else
		#ENDIF
		For nX := 1 to Len(aRecSF1Ori)
			dbSelectArea("SF1")
			MsGoto(aRecSF1Ori[nX])
		
			DbSelectArea("SD1")
			SD1->(DbSetOrder(1))
			SD1->(MsSeek(xFilial("SD1")+cNfFrete+cSeFrete+cForFrete+cLojFrete))
			While !SD1->(Eof()) .And. SD1->D1_FILIAL==xFilial("SD1") .And. SD1->D1_DOC==cNfFrete .And. SD1->D1_FORNECE==cForFrete .And. SD1->D1_LOJA==cLojFrete .And. SD1->D1_COD==cProdItem
				#IFDEF TOP
					cProd		:= (cTemp)->D1_COD
					nIcmFrete	:= (cTemp)->D1_VALICM	
				#ELSE
					cProd		:= SD1->D1_COD
					nIcmFrete	:= SD1->D1_VALICM	
				#ENDIF			
				    
				DbSelectArea("SD1")
				DbSetOrder(2)
				If SD1->(MsSeek(xFilial("SD1")+cProd+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA))
					cCodCiap := SD1->D1_CODCIAP
					nQtdD1 := Int(SD1->D1_QUANT)
				EndIf
					
				DbSelectArea("SF9")
				DbSetOrder(1)
				If SF9->(MsSeek(xFilial("SF9")+cCodCiap))
				If cPaisLoc == "BRA"
					If SF9->F9_QTDPARC == SF9->F9_SLDPARC
						RecLock("SF9",.F.)
							IF SF4->F4_BENSATF == "2"
								SF9->F9_VALICMS += NoRound((nIcmFrete/nQtdD1),2) * nQtdD1
								SF9->F9_VALFRET += NoRound((nIcmFrete/nQtdD1),2) * nQtdD1
							Else
								SF9->F9_VALICMS += NoRound((nIcmFrete/nQtdD1),2) 
								SF9->F9_VALFRET += NoRound((nIcmFrete/nQtdD1),2) 
							EndIf
						SF9->(MsUnlock())
					EndIf
				EndIf
				EndIf				
				
				SD1->(dbSkip())
			EndDo
		Next nX
		#IFDEF TOP
			EndIf
		#ENDIF
		If Select(cTemp) > 0
			(cTemp)->(DbCloseArea())
		EndIf
		RestArea(aAreaSD1)
		RestArea(aAreaSF1)

	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Amarracao Fornecedor/Produto                                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lAtuSA5
		dbSelectArea("SA5")
		If !( xFilial("SA5") == SA5->A5_FILIAL .And.;
				(cAliasSD1)->D1_FORNECE == SA5->A5_FORNECE .And.;
				(cAliasSD1)->D1_LOJA == SA5->A5_LOJA .And.;
				(cAliasSD1)->D1_COD == SA5->A5_PRODUTO )
			dbSetOrder(1)				
			lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_COD,.F.)
			If !lAchou .And. lReferencia
				dbSelectArea("SA5")
				dbSetOrder(9)
				lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+cProdRef,.F.)
			Endif
		EndIf
		If lAchou    
			lIncSA5 := .T.
			RecLock("SA5",.F.)
			For nX := 1 To 12
				If ( FieldGet(FieldPos("A5_DTCOM"+StrZero(nX,2))) == (cAliasSD1)->D1_EMISSAO .And.;
						FieldGet(FieldPos("A5_PRECO" +StrZero(nX,2))) == IIF(nMcusto=="1",(cAliasSD1)->D1_CUSTO/(cAliasSD1)->D1_QUANT,(cAliasSD1)->(FieldGet(FieldPos("D1_CUSTO"+nMcusto)))/(cAliasSD1)->D1_QUANT) .And.;
						FieldGet(FieldPos("A5_QUANT" +StrZero(nX,2))) == (cAliasSD1)->D1_QUANT .And.;
						FieldGet(FieldPos("A5_COND"  +StrZero(nX,2))) == SF1->F1_COND )
					lIncSA5 := .F.
					nX := 13
				EndIf
			Next nX
			If lIncSA5
				If ( SA5->A5_PRECO12 <> 0 )
					For nX := 1 To 11					
						FieldPut(FieldPos("A5_DTCOM"+StrZero(nX,2)),FieldGet(FieldPos("A5_DTCOM"+StrZero(nX+1,2))))
						FieldPut(FieldPos("A5_PRECO"+StrZero(nX,2)),FieldGet(FieldPos("A5_PRECO"+StrZero(nX+1,2))))
						FieldPut(FieldPos("A5_QUANT"+StrZero(nX,2)),FieldGet(FieldPos("A5_QUANT"+StrZero(nX+1,2))))
						FieldPut(FieldPos("A5_COND" +StrZero(nX,2)),FieldGet(FieldPos("A5_COND"+StrZero(nX+1,2))))
					Next nX
					SA5->A5_PRECO12 := 0
				EndIf
				For nX := 1 To 12
					If ( FieldGet(FieldPos("A5_PRECO"+StrZero(nX,2))) == 0 )
						FieldPut(FieldPos("A5_DTCOM"+StrZero(nX,2)),(cAliasSD1)->D1_EMISSAO)
						FieldPut(FieldPos("A5_PRECO"+StrZero(nX,2)),IIF(nMcusto=="1",(cAliasSD1)->D1_CUSTO/(cAliasSD1)->D1_QUANT,(cAliasSD1)->(FieldGet(FieldPos("D1_CUSTO"+nMcusto)))/(cAliasSD1)->D1_QUANT))
						FieldPut(FieldPos("A5_QUANT"+StrZero(nX,2)),(cAliasSD1)->D1_QUANT)
						FieldPut(FieldPos("A5_COND"+StrZero(nX,2)),SF1->F1_COND)
						nX := 13
					EndIf
				Next nX
			EndIf
			MsUnlock()
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza Produto                                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (cAliasSD1)->D1_TIPO == "N" .And. SF4->F4_UPRC$" S"
		If dDataBase >= RetFldProd(SB1->B1_COD,"B1_UCOM")
			If RetArqProd(SB1->B1_COD)
				RecLock("SB1",.F.)
				SB1->B1_UCOM := IIf(lDataUcom,(cAliasSD1)->D1_DTDIGIT,(cAliasSD1)->D1_EMISSAO)
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ PE: MT103UPC - Permite customizar gravacao do ultimo preco de compra   |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ExistBlock("MT103UPC")
					nPcoCompra := ExecBlock("MT103UPC",.F.,.F.)
					If ValType(nPcoCompra)=="N"    
						SB1->B1_UPRC :=nPcoCompra
					endif
				Else
					SB1->B1_UPRC := IIf(lPrecoDes,(cAliasSD1)->D1_VUNIT-((cAliasSD1)->D1_VALDESC/(cAliasSD1)->D1_QUANT),(cAliasSD1)->D1_VUNIT)
				EndIf
			Else
				RecLock("SBZ",.F.)
				SBZ->BZ_UCOM := IIf(lDataUcom,(cAliasSD1)->D1_DTDIGIT,(cAliasSD1)->D1_EMISSAO)
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ PE: MT103UPC - Permite customizar gravacao do ultimo preco de compra   |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ExistBlock("MT103UPC")
					nPcoCompra := ExecBlock("MT103UPC",.F.,.F.)
					If ValType(nPcoCompra)=="N"    
						SBZ->BZ_UPRC :=nPcoCompra
					endif
				Else
					SBZ->BZ_UPRC := IIf(lPrecoDes,(cAliasSD1)->D1_VUNIT-((cAliasSD1)->D1_VALDESC/(cAliasSD1)->D1_QUANT),(cAliasSD1)->D1_VUNIT)
				EndIf              
				
				dbSelectArea("SB1")
			Endif	
		EndIf
	Else                    
		If (cAliasSD1)->D1_TIPO == "C" .And. SF4->F4_UPRC$" S"	
 			If dDataBase >= RetFldProd(SB1->B1_COD,"B1_UCOM")
 				aAreaSF1  := SF1->(GetArea()) 
				aAreaSD1  := SD1->(GetArea()) 
		   		nVlrCompl := (cAliasSD1)->D1_VUNIT 
		   		cDoc	  := (cAliasSD1)->D1_NFORI 
		   		cSerie	  := (cAliasSD1)->D1_SERIORI
		   		cFornec	  := (cAliasSD1)->D1_FORNECE
		   		cLoja	  := (cAliasSD1)->D1_LOJA
		   		cCod	  := (cAliasSD1)->D1_COD 
		   		cItem	  := AllTrim((cAliasSD1)->D1_ITEMORI)
		   		If !Empty(cItem)
					dbSelectArea("SD1")
					dbSetOrder(1)
					If MsSeek(xFilial("SD1")+cDoc+cSerie+cFornec+cLoja+cCod+cItem)	
						nQtdOriFr := (cAliasSD1)->D1_QUANT
						nValOriFr := (cAliasSD1)->D1_VUNIT
						nVlDescFr := (cAliasSD1)->D1_VALDESC
						
						If nQtdOriFr > 0 .And. nValOriFr > 0
							If RetArqProd(SB1->B1_COD)
								RecLock("SB1",.F.)
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ PE: MT103UPC - Permite customizar gravacao do ultimo preco de compra   |
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If ExistBlock("MT103UPC")
									nPcoCompra := ExecBlock("MT103UPC",.F.,.F.)
									If ValType(nPcoCompra)=="N"    
										SB1->B1_UPRC :=nPcoCompra
									endif
								Else
									SB1->B1_UPRC := IIf(lPrecoDes,nValOriFr-(nVlDescFr/nQtdOriFr)+ (nVlrCompl/nQtdOriFr) ,nVlrCompl/nQtdOriFr+nValOriFr)	    
								EndIf
							Else
								RecLock("SBZ",.F.)									
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ PE: MT103UPC - Permite customizar gravacao do ultimo preco de compra   |
				   				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If ExistBlock("MT103UPC")
									nPcoCompra := ExecBlock("MT103UPC",.F.,.F.,)
									If ValType(nPcoCompra)=="N"    
										SBZ->BZ_UPRC :=nPcoCompra
									endif
								Else
									SBZ->BZ_UPRC := IIf(lPrecoDes,nValOriFr-(nVlDescFr/nQtdOriFr)+ (nVlrCompl/nQtdOriFr) ,nVlrCompl/nQtdOriFr+nValOriFr)	    
								EndIf
							EndIf 
						EndIf
					EndIf             
				ElseIf AllTrim((cAliasSD1)->D1_ORIGLAN) == "FR"	// Nota gerada via MATA116
					For nX := 1 to Len(aRecSF1Ori)
						dbSelectArea("SF1")
						MsGoto(aRecSF1Ori[nX])
						dbSelectArea("SD1")
						dbSetOrder(1)
						If MsSeek(xFilial("SD1") + SF1->(F1_DOC + F1_SERIE + F1_FORNECE + F1_LOJA) + cCod)
							While SD1->(!Eof()) .And. SD1->(D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA) == SF1->(F1_DOC + F1_SERIE + F1_FORNECE + F1_LOJA) .And. SD1->D1_COD == cCod
								nQtdOriFr := SD1->D1_QUANT
								nValOriFr := SD1->D1_VUNIT
								nVlDescFr := SD1->D1_VALDESC
								
								If nQtdOriFr > 0 .And. nValOriFr > 0
									If RetArqProd(SB1->B1_COD)
										RecLock("SB1",.F.)
										//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
										//³ PE: MT103UPC - Permite customizar gravacao do ultimo preco de compra   |
						   				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										If ExistBlock("MT103UPC")
											nPcoCompra := ExecBlock("MT103UPC",.F.,.F.)
											If ValType(nPcoCompra)=="N"    
												SB1->B1_UPRC :=nPcoCompra
											endif
										Else
											SB1->B1_UPRC := IIf(lPrecoDes,nValOriFr-(nVlDescFr/nQtdOriFr)+ (nVlrCompl/nQtdOriFr) ,nVlrCompl/nQtdOriFr+nValOriFr)	    
										EndIf
									Else
										RecLock("SBZ",.F.)
											
										//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
										//³ PE: MT103UPC - Permite customizar gravacao do ultimo preco de compra   |
						   				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										If ExistBlock("MT103UPC")
											nPcoCompra := ExecBlock("MT103UPC",.F.,.F.,)
											If ValType(nPcoCompra)=="N"    
												SBZ->BZ_UPRC :=nPcoCompra
											endif
										Else
											SBZ->BZ_UPRC := IIf(lPrecoDes,nValOriFr-(nVlDescFr/nQtdOriFr)+ (nVlrCompl/nQtdOriFr) ,nVlrCompl/nQtdOriFr+nValOriFr)	    
										EndIf
									EndIf 
								EndIf
				
								SD1->(DbSkip())
							End
						EndIf
					Next nX						
				EndIf
				      
				RestArea(aAreaSF1)
				RestArea(aAreaSD1)
			EndIf
		EndIf					
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza saldo fisico e financeiro                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SF4->F4_ESTOQUE=="S"
		B2AtuComD1(Nil,Nil,Nil,Nil,lAgregaOri)
		If lEnviaCQ
			If Localiza((cAliasSD1)->D1_COD) .And. !Empty(SuperGetMV("MV_DISTAUT"))
				A100Distri((cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL,(cAliasSD1)->D1_NUMSEQ,(cAliasSD1)->D1_DOC, (cAliasSD1)->D1_SERIE, (cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,Nil,Nil,(cAliasSD1)->D1_QUANT,(cAliasSD1)->D1_LOTECTL,(cAliasSD1)->D1_NUMLOTE)
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualizacao do CQ - Tipo 0 (Zero) - Saldo Original                     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !(cAliasSD1)->D1_TIPO$"CIP" .Or. (lComplQtd .And. cTpCompl == "2")
				If fGeraCQ0("SD1",(cAliasSD1)->D1_COD,"CP",cLocOrig)
					If (cAliasSD1)->D1_NUMCQ <> SD7->D7_NUMERO
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Esta verificacao eh efetuada para otimizar a performance, evitando     ³
						//³ o "flush" em ambiente TOPCONNECT                                       ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !__TTSINUSE
							RecLock("SD1")
						EndIf
						(cAliasSD1)->D1_NUMCQ := SD7->D7_NUMERO
					EndIf
					If RetFldProd(SB1->B1_COD,"B1_TIPOCQ") == "Q" .or. lInspec
						If Rastro(SB1->B1_COD)
							dbSelectArea("SD5")
							dbSetOrder(3)
							If MsSeek(xFilial("SD5")+(cAliasSD1)->D1_NUMSEQ+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL+(cAliasSD1)->D1_LOTECTL,.F.)
								aLote := {SD5->D5_LOTECTL,; //Numero do Lote
									SD5->D5_NUMLOTE}    //Sequencia do Sub-Lote
							Else
								aLote := {"",""}
							EndIf						
						EndIf
						aEnvCele := {(cAliasSD1)->D1_DOC,; //Numero da Nota Fiscal
							(cAliasSD1)->D1_SERIE,;        //Serie da Nota Fiscal
							(cAliasSD1)->D1_TIPO,;         //Tipo da Nota Fiscal
							(cAliasSD1)->D1_EMISSAO,;      //Data de Emissao da Nota Fiscal
							(cAliasSD1)->D1_DTDIGIT,;      //Data de Entrada da Nota Fiscal
							iif (lTpNFQie,SF1->F1_ESPECIE,"NF"),;  //Tipo de Documento 
							(cAliasSD1)->D1_ITEM,;         //Item da Nota Fiscal
							" ",;                  		    //Numero do Remito (Localizacoes)
							(cAliasSD1)->D1_PEDIDO,;       //Numero do Pedido de Compra
							(cAliasSD1)->D1_ITEMPC,;       //Item do Pedido de Compra
							(cAliasSD1)->D1_FORNECE,;      //Codigo Fornecedor/Cliente
							(cAliasSD1)->D1_LOJA,;         //Loja Fornecedor/Cliente
							(cAliasSD1)->D1_LOTEFOR,;      //Numero do Lote do Fornecedor
							Space(6),;         			    //Codigo do Solicitante
							(cAliasSD1)->D1_COD,;          //Codigo do Produto
							(cAliasSD1)->D1_LOCAL,;        //Local Origem
							aLote[1],;             			//Numero do Lote
							aLote[2],;             			//Sequencia do Sub-Lote
							(cAliasSD1)->D1_NUMSEQ,;       //Numero Sequencial
							SD7->D7_NUMERO,;       		    //Numero do CQ
							(cAliasSD1)->D1_QUANT,;        //Quantidade
							(cAliasSD1)->D1_TOTAL,;        //Preco
							nAtraso,;              			//Dias de atraso
							(cAliasSD1)->D1_TES,;          //TES
							AllTrim(FunName()),;   			//Origem						
							" ",;                  			//Origem TXT	
							0}                     			//Quantidade do Lote Original									
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Realiza a integracao Materiais x Inspecao de Entradas		           ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						aRetQIE := QAtuMatQie(aEnvCele,1,,IIf(Type('l103Auto') <> 'U', l103Auto, .F.) )
						If aRetQIE[1] $ "C,L"
							//Informa variael WMS para controle de skip lote
							If IntWMS(SD7->D7_PRODUTO)
								WmsSkipCQ(.T.)
							EndIf
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Realiza automaticamente a libercao do CQ qdo nao ha inspecao no Quality³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							aMov := {}
							aadd(aMov, {})
							aadd(aMov[Len(aMov)], 1)                 //-- Tipo da Movimentação (1=Libera/2=Rejeita)
							aadd(aMov[Len(aMov)], SD7->D7_SALDO)     //-- Quantidade a ser Movimentada
							aadd(aMov[Len(aMov)], SD7->D7_LOCDEST)   //-- Local de Destino da Movimentacao
							aadd(aMov[Len(aMov)], SD7->D7_DATA)      //-- Data da Movimentacao
							aadd(aMov[Len(aMov)], "")                //-- X=Estornado
							aadd(aMov[Len(aMov)], "")                //-- Motivo da Rejeicao
							aadd(aMov[Len(aMov)], aRetQIE[2])        //-- Observacao
							aadd(aMov[Len(aMov)], SD7->D7_SALDO2)   //-- Quantidade na 2a Unidade de Medida
							If IntWMS(SD7->D7_PRODUTO)
								aadd(aMov[Len(aMov)],(cAliasSD1)->D1_ENDER) // Endereço
								aadd(aMov[Len(aMov)],SD7->D7_NUMSERI)       // Numero Série
								aadd(aMov[Len(aMov)],(cAliasSD1)->D1_SERVIC)// Serviço WMS
							EndIf							

							fGravaCQ(SD7->D7_PRODUTO, SD7->D7_NUMERO, .F.,aMov,PegaCMD1())	
						EndIf		
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Execblock QIEA210T apos gravacao da movim. do CQ Celerina              ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If ExistBlock("QIEA210T")
							ExecBlock("QIEA210T",.F.,.F.,{"EST"})
						EndIf
					EndIf
				EndIf
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualizacao do CQ - Tipo 8 (Oito) - Documentos de Complemento          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If fGeraCQ8((cAliasSD1)->D1_DOC,(cAliasSD1)->D1_SERIE,(cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,(cAliasSD1)->D1_COD,(cAliasSD1)->D1_ITEM,"CP",(cAliasSD1)->D1_LOCAL,aRecSF1Ori)
					If (cAliasSD1)->D1_NUMCQ <> SD7->D7_NUMERO
						(cAliasSD1)->D1_NUMCQ := SD7->D7_NUMERO
					EndIf
				EndIf
			EndIf
		EndIf		
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza requisicao direta a Ordem de Producao                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SF4->F4_ESTOQUE == "S" .And. !Empty((cAliasSD1)->D1_OP) .And. !lEnviaCQ
		If Localiza((cAliasSD1)->D1_COD)
			dbSelectArea("SBE")
			dbSetOrder(1)
			SBE->(MsSeek(xFilial("SBE")+(cAliasSD1)->D1_LOCAL))
			cLocaliz := SBE->BE_LOCALIZ
			
			dbSelectArea("SDC")
			dbSetOrder(2)
			If MsSeek(xFilial("SDC")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL+(cAliasSD1)->D1_OP)
				While !Eof() .And. xFilial("SDC")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL+(cAliasSD1)->D1_OP == xFilial("SDC")+SDC->DC_PRODUTO+SDC->DC_LOCAL+SDC->DC_OP
					If QtdComp(SDC->DC_QUANT) > QtdComp(0)
						lRetEnd  := A100Distri((cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL,(cAliasSD1)->D1_NUMSEQ,(cAliasSD1)->D1_DOC,(cAliasSD1)->D1_SERIE,(cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,SDC->DC_LOCALIZ,Nil,(cAliasSD1)->D1_QUANT,(cAliasSD1)->D1_LOTECTL,(cAliasSD1)->D1_NUMLOTE)
						lTemSDC  := .T.
						cLocaliz := SDC->DC_LOCALIZ
						Exit
					Endif	
					dbSelectArea("SDC")
					dbSkip()
				EndDo
			Endif                                         
			// Notas de Complemento: Icms, IPI, Precos não será considerada, não possui quantidade.
			If !lTemSDC .And. (cAliasSD1)->D1_QUANT >0
				lRetEnd  := A100Distri((cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL,(cAliasSD1)->D1_NUMSEQ,(cAliasSD1)->D1_DOC,(cAliasSD1)->D1_SERIE,(cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,cLocaliz,Nil,(cAliasSD1)->D1_QUANT,(cAliasSD1)->D1_LOTECTL,(cAliasSD1)->D1_NUMLOTE)
			Endif				
		EndIf
		If lRetEnd  
			nSldRE5 := (cAliasSD1)->D1_QUANT
			dbSelectArea("SD3")
			RecLock("SD3",.T.)
			SD3->D3_FILIAL	:= xFilial("SD3")
			SD3->D3_COD		:= (cAliasSD1)->D1_COD
			SD3->D3_QUANT	:= (cAliasSD1)->D1_QUANT
			SD3->D3_TM		:= "999"
			SD3->D3_OP		:= (cAliasSD1)->D1_OP
			SD3->D3_LOCAL	:= (cAliasSD1)->D1_LOCAL
			SD3->D3_DOC		:= (cAliasSD1)->D1_DOC
			SD3->D3_EMISSAO	:= (cAliasSD1)->D1_DTDIGIT
			SD3->D3_NUMSEQ	:= (cAliasSD1)->D1_NUMSEQ
			SD3->D3_UM		:= (cAliasSD1)->D1_UM
			SD3->D3_GRUPO	:= (cAliasSD1)->D1_GRUPO
			SD3->D3_TIPO	:= (cAliasSD1)->D1_TP
			SD3->D3_SEGUM	:= (cAliasSD1)->D1_SEGUM
			SD3->D3_CONTA	:= (cAliasSD1)->D1_CONTA
			SD3->D3_CF		:= "RE5"
			SD3->D3_QTSEGUM	:= (cAliasSD1)->D1_QTSEGUM
			SD3->D3_USUARIO	:= CUSERNAME
			SD3->D3_CUSTO1	:= (cAliasSD1)->D1_CUSTO
			SD3->D3_CUSTO2	:= (cAliasSD1)->D1_CUSTO2
			SD3->D3_CUSTO3	:= (cAliasSD1)->D1_CUSTO3
			SD3->D3_CUSTO4	:= (cAliasSD1)->D1_CUSTO4
			SD3->D3_CUSTO5	:= (cAliasSD1)->D1_CUSTO5
			SD3->D3_NUMLOTE	:= (cAliasSD1)->D1_NUMLOTE
			SD3->D3_LOTECTL	:= (cAliasSD1)->D1_LOTECTL
			SD3->D3_DTVALID	:= (cAliasSD1)->D1_DTVALID
	        SD3->D3_LOCALIZ := cLocaliz
			SD3->D3_POTENCI := (cAliasSD1)->D1_POTENCI
			If X3Uso(cUsoD1_TRT)
				SD3->D3_TRT	    := (cAliasSD1)->D1_TRT
			EndIf
			If lFornece
				SD3->D3_FORNDOC	:= (cAliasSD1)->D1_FORNECE
				SD3->D3_LOJADOC	:= (cAliasSD1)->D1_LOJA
			EndIf
			
			//Verifica integração do Manutenção de Ativos X Estoque
			If AllTrim(SuperGetMV("MV_NGMNTES",.F.,'N')) == 'S'			
				If SubStr((cAliasSD1)->D1_OP,7,5) == "OS001"
					SD3->D3_ORDEM := SubStr((cAliasSD1)->D1_OP,1,6)
				EndIf
			EndIf
			
			//trecho que verifica se deve baixar algum SDC quando a qtd da nf e maior que a diferenca d4-dc
			//Em Notas de Complemento, nSLDRE5 = 0 
			If Localiza((cAliasSD1)->D1_COD,.T.) .And. nSldRE5>0
				dbSelectArea("SD4")
				dbSetOrder(1)
				If MsSeek(xFilial("SD4")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_OP)
					While !EOF() .And. SD4->(D4_FILIAL+D4_COD+D4_OP) == xFilial("SD4")+(cAliasSD1)->(D1_COD+D1_OP)
						nQtdSD4 += SD4->D4_QUANT
						dbSkip()
					End
				EndIf
				dbSelectArea("SDC")
				dbSetOrder(2)
				If MsSeek(xFilial("SDC")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL+(cAliasSD1)->D1_OP)
					While !EOF() .And. SDC->(DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP) == xFilial("SDC")+(cAliasSD1)->(D1_COD+D1_LOCAL+D1_OP)
						nQtdSDC += SDC->DC_QUANT
						dbSkip()
					End
				EndIf
				
				nQtdSDC := nQtdSD4 - nQtdSDC
				If (cAliasSD1)->D1_QUANT > nQtdSDC
					nQtdSDC := (cAliasSD1)->D1_QUANT - nQtdSDC
				Else
					nQtdSDC := 0
				EndIf
	
			 	If	MsSeek(xFilial("SDC")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL+(cAliasSD1)->D1_OP)	
					While nQtdSDC > 0 .And. !EOF() .And.SDC->(DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP) ==;
														 xFilial("SDC")+(cAliasSD1)->(D1_COD+D1_LOCAL+D1_OP)
						If !lWmsNew
							dbSelectArea("SBF")
							dbSetOrder(1)
							If MsSeek(xFilial("SBF")+SDC->(DC_LOCAL+DC_LOCALIZ+DC_PRODUTO),.F.)
								RecLock("SBF",.F.)
								SBF->BF_EMPEN2 -= ConvUM(SBF->BF_PRODUTO,Min(SBF->BF_EMPENHO,nQtdSDC),SDC->DC_QTSEGUM,2)
								SBF->BF_EMPENHO -= Min(SBF->BF_EMPENHO,nQtdSDC)
								MsUnlock()
							EndIf
						EndIf
						nQtdBxa := Min(SDC->DC_QUANT,nQtdSDC)
						RecLock("SDC",.F.)
						SDC->DC_QTSEGUM -= ConvUM(SDC->DC_PRODUTO,Min(SDC->DC_QUANT,nQtdSDC),SDC->DC_QTSEGUM,2)
						SDC->DC_QUANT -= Min(SDC->DC_QUANT,nQtdSDC)
						MsUnlock()
						
						nQtdSDC -= nQtdBxa
						SDC->(dbSkip())				
					End
				EndIf 
			EndIf
	
			dbSelectArea("SD4")
			dbSetOrder(1)
			If MsSeek(xFilial("SD4")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_OP)
				While nSldRE5 > 0
					If SD4->(D4_FILIAL+D4_COD+D4_OP) == xFilial("SD4")+(cAliasSD1)->(D1_COD+D1_OP)
						If SD4->D4_QUANT > 0 .And. ! SD4->(A103ChkBN(D4_OP, D4_COD, D4_LOCAL, Recno()))
							dbSelectArea("SB2")
							If MsSeek(xFilial("SB2")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL,.F.)
								RecLock("SB2",.F.)
								SB2->B2_QEMP2 -= ConvUM(SB2->B2_COD,Min(SB2->B2_QEMP,Min(SD4->D4_QUANT,nSldRE5)),SD4->D4_QTSEGUM,2)
								SB2->B2_QEMP  -= Min(SB2->B2_QEMP,Min(SD4->D4_QUANT,nSldRE5))
								MsUnlock()
							EndIf
							RecLock("SD4",.F.)
							nQtdBxa := Min(Min(SD4->D4_QUANT,nSldRE5),(cAliasSD1)->D1_QUANT)
							SD4->D4_QTSEGUM	-= ConvUM(SD4->D4_COD,nQtdBxa,(cAliasSD1)->D1_QTSEGUM,2)
							SD4->D4_QUANT	-= nQtdBxa
							MsUnlock()
							nSldRE5 -= nQtdBxa
						Endif
						SD4->(dbSkip())
					Else
						nSldRe5 := 0
					EndIf
				End
			EndIf
			dbSelectArea("SC2")
			dbSetOrder(1)
			If MsSeek(xFilial("SC2")+(cAliasSD1)->D1_OP)
				SD3->D3_CC      := SC2->C2_CC
				SD3->D3_ITEMCTA	:= SC2->C2_ITEMCTA
				SD3->D3_CLVL    := SC2->C2_CLVL
			EndIf
			B2AtuComD3({SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
			C2AtuComD3({SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza requisicao valorizada para nota complementar com Custo Fifo     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lEnviaCQ .And. (lCusFifo .Or. lCusLifo) .And. lAjNfCompl
		NfeComplFF(cAliasSD1,(lCusFifo .Or. lCusLifo),1)
	EndIf	
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Devolucao de produtos                                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (cAliasSD1)->D1_TIPO == "D" .And. !Empty((cAliasSD1)->D1_ITEMORI)

		If (lProcLoja .Or. !lVldNFO) .And. lD1FilOri .And. !Empty((cAliasSD1)->D1_FILORI)
			cD1FilOri := SD1->D1_FILORI
			cSF2Fil   := cD1FilOri
		Else
			cD1FilOri := xFilial("SD2")
			cSF2Fil   := xFilial("SF2")
		EndIf

		DbSelectArea("SF2")
		DbSetOrder(1)
		MsSeek(cSF2Fil + (cAliasSD1)->D1_NFORI + (cAliasSD1)->D1_SERIORI)
		
		If !(cD1FilOri == SD2->D2_FILIAL .And.;
				(cAliasSD1)->D1_NFORI   == SD2->D2_DOC    .And.;
				(cAliasSD1)->D1_SERIORI == SD2->D2_SERIE  .And.;
				SF2->F2_CLIENTE 		== SD2->D2_CLIENTE .And.;
				SF2->F2_LOJA 			== SD2->D2_LOJA    .And.;
				(cAliasSD1)->D1_COD 	== SD2->D2_COD     .And.;
				Alltrim((cAliasSD1)->D1_ITEMORI) == AllTrim(SD2->D2_ITEM))
			dbSelectArea("SD2")
			dbSetOrder(3)
			MsSeek(cSF2Fil+(cAliasSD1)->D1_NFORI+(cAliasSD1)->D1_SERIORI+SF2->F2_CLIENTE+SF2->F2_LOJA+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_ITEMORI )
		EndIf
		If (SD2->(!Eof()))
			RecLock("SD2",.F.)
			SD2->D2_QTDEDEV	+= (cAliasSD1)->D1_QUANT
			SD2->D2_VALDEV	+= (cAliasSD1)->D1_TOTAL
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Tratamento da gravacao do SD1 na Integridade Referencial            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SD1->(FkCommit())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com o modulo de projetos                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If IntePms()
		If !IsIntegTop(,.T.)
			PmsWriteNF(1,cAliasSD1)
		Else
			If !Empty(SD1->D1_PEDIDO)
				If !PMSNFSA(SD1->D1_PEDIDO,SD1->D1_ITEMPC)[1] //Não é S.A
					PmsWriteNF(1,cAliasSD1)
				Endif
			Else
				PmsWriteNF(1,cAliasSD1)
			Endif
		Endif
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com o EEC     											|
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lEECFAT
		EECFAT3("GRV",.F.)
    EndIf	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica complementos de integracao                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("bTTSSD1")=="B"
		Eval(bTTSSD1,nOpcao)
	EndIf	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorno de um documento de entrada                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nOpcao == 5
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona registros                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB1")
	dbSetOrder(1)
	MsSeek(xFilial("SB1")+(cAliasSD1)->D1_COD)

	dbSelectArea("SF4")
	dbSetOrder(1)
	MsSeek(xFilial("SF4")+(cAliasSD1)->D1_TES)

	dbSelectArea("SA2")
	dbSetOrder(1)
	MsSeek(xFilial("SA2")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com o EEC     											|
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lEECFAT
   		EECFAT3("GRV",.T.)
	EndIf
   	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Retorna o pergunte da MATA103                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    Pergunte("MTA103", .F.)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com o modulo de projetos                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If IntePms()
		PmsWriteNF(2,cAliasSD1)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Devolucao de produtos                                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (cAliasSD1)->D1_TIPO == "D" .And. !Empty((cAliasSD1)->D1_ITEMORI)

		If (Alltrim(SD1->D1_ORIGLAN) = 'LO' .Or. !lVldNFO) .And. lD1FilOri .And. !Empty((cAliasSD1)->D1_FILORI) //Issue: DVARLOJ4-1309-Validação se Origem for LOJA Utilizar FilOri.
			cD1FilOri := SD1->D1_FILORI
			cSF2Fil   := cD1FilOri
		Else
			cD1FilOri := xFilial("SD2")
			cSF2Fil   := xFilial("SF2")
		EndIf

		DbSelectArea("SF2")
		DbSetOrder(1)
		MsSeek(cSF2Fil + (cAliasSD1)->D1_NFORI + (cAliasSD1)->D1_SERIORI)
		
		If !(cD1FilOri == SD2->D2_FILIAL .And.;
				(cAliasSD1)->D1_NFORI   == SD2->D2_DOC 	.And.;
				(cAliasSD1)->D1_SERIORI == SD2->D2_SERIE   .And.;
				SF2->F2_CLIENTE         == SD2->D2_CLIENTE .And.;
				SF2->F2_LOJA 	        == SD2->D2_LOJA 	.And.;
				(cAliasSD1)->D1_COD     == SD2->D2_COD 	.And.;
				Alltrim((cAliasSD1)->D1_ITEMORI) == AllTrim(SD2->D2_ITEM))
			dbSelectArea("SD2")
			dbSetOrder(3)
			MsSeek(cD1FilOri+(cAliasSD1)->D1_NFORI+(cAliasSD1)->D1_SERIORI+SF2->F2_CLIENTE+SF2->F2_LOJA+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_ITEMORI )
		EndIf
		If (SD2->(!Eof()))
			RecLock("SD2",.F.)
			SD2->D2_QTDEDEV	-= (cAliasSD1)->D1_QUANT
			SD2->D2_VALDEV	-= (cAliasSD1)->D1_TOTAL
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Se a devolução veio de uma troca/devolução da loja, altera o status do ³
	        //³ do item da venda.                                                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SD2->D2_ORIGLAN == "LO"
				LJ020AltStatus(SD2->D2_FILIAL, SD2->D2_SERIE, SD2->D2_DOC, SD2->D2_COD, SD2->D2_ITEMPV)
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza requisicao direta a Ordem de Producao                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty((cAliasSD1)->D1_OP)
		dbSelectArea("SD3")
		dbSetOrder(4)
		nSldRe5 := (cAliasSD1)->D1_QUANT
		If MsSeek(xFilial("SD3")+(cAliasSD1)->D1_NUMSEQ, .F.)
			While !Eof() .And. xFilial("SD3") == SD3->D3_FILIAL .And.;
					SD3->D3_NUMSEQ == (cAliasSD1)->D1_NUMSEQ .And.;
					SD3->D3_CF <> "RE5"
				dbSelectArea("SD3")
				dbSkip()
			EndDo
			If SD3->D3_ESTORNO # "S" .And. !SD3->D3_NUMSEQ <> (cAliasSD1)->D1_NUMSEQ .And. Empty(SD3->D3_PROJPMS)
				RecLock("SD3",.F.)
				SD3->D3_ESTORNO := "S"
				For nX := 1 To FCount()
					aadd(aSD3,FieldGet(nX))
				Next nX
				RecLock("SD3",.T.)
				For nX := 1 To FCount()
					FieldPut(nX,aSD3[nX])
				Next nX
				SD3->D3_TM      := "499"
				SD3->D3_CF      := "DE5"
				SD3->D3_USUARIO := CUSERNAME
				
				//Estorna Amarracao com producoes de terceiros MATA037
				If ld3kLimp
					MatLimpD3K(SD3->D3_COD,SD3->D3_NUMSEQ)
				EndIf
				dbSelectArea("SD4")
				dbSetOrder(1)
				MsSeek(xFilial("SD4")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_OP)
				While nSldRE5 > 0
					If SD4->(D4_FILIAL+D4_COD+D4_OP) == xFilial("SD4")+(cAliasSD1)->(D1_COD+D1_OP)
						If ! SD4->(A103ChkBN(D4_OP, D4_COD, D4_LOCAL, Recno()))
							RecLock("SD4",.F.)
							aBaixa:={Min(SD4->D4_QTDEORI-SD4->D4_QUANT,(cAliasSD1)->D1_QUANT),ConvUM(SD4->D4_COD, Min(SD4->D4_QTDEORI-SD4->D4_QUANT,(cAliasSD1)->D1_QUANT),0,2)}

							SD4->D4_QUANT   += aBaixa[1]
							SD4->D4_QTSEGUM += aBaixa[2]

							dbSelectArea("SB2")
							If MsSeek(xFilial("SB2")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL,.F.)
								RecLock("SB2",.F.)
								SB2->B2_QEMP  += aBaixa[1]
								SB2->B2_QEMP2 += aBaixa[2]
								MsUnlock()
							EndIf

							nSldRE5 -= SD4->D4_QUANT
						EndIf
						SD4->(dbSkip())
					Else
						nSldRE5 := 0
					EndIf
				End
				B2AtuComD3({SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
				C2AtuComD3({SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
			EndIf
		EndIf	
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorna requisicao valorizada para nota complementar com Custo Fifo    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (lCusFifo .Or. lCusLifo) .And. lAjNfCompl .And. (cAliasSD1)->D1_TIPO == 'C'
		dbSelectArea("SD3")
		dbSetOrder(4)
		If MsSeek(xFilial("SD3")+(cAliasSD1)->D1_NUMSEQ, .F.)
			While !Eof() .And. xFilial("SD3") == SD3->D3_FILIAL .And.;
					SD3->D3_NUMSEQ == (cAliasSD1)->D1_NUMSEQ .And.	SD3->D3_CF <> "RE6"
				dbSelectArea("SD3")
				dbSkip()
			EndDo
			If SD3->D3_ESTORNO # "S" .And. !SD3->D3_NUMSEQ <> (cAliasSD1)->D1_NUMSEQ .And. Empty(SD3->D3_PROJPMS)
				RecLock("SD3",.F.)
				SD3->D3_ESTORNO := "S"
				aSD3 := {}
				For nX := 1 To FCount()
					aadd(aSD3,FieldGet(nX))
				Next nX
				RecLock("SD3",.T.)
				For nX := 1 To FCount()
					FieldPut(nX,aSD3[nX])
				Next nX
				SD3->D3_TM      := "499"
				SD3->D3_CF      := "DE6"
				SD3->D3_USUARIO := CUSERNAME
				
				//Estorna Amarracao com producoes de terceiros MATA037
				If ld3kLimp
					MatLimpD3K(SD3->D3_COD,SD3->D3_NUMSEQ)
				EndIf

				B2AtuComD3({SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
			EndIf
		EndIf	
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorno do CQ                                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SF4->F4_ESTOQUE == "S" .AND. !Empty((cAliasSD1)->D1_NUMCQ) .AND. (cAliasSD1)->D1_ORIGLAN <> "LO"

		If !(lComplQtd .And. cTpCompl == "2")	// Nota de Complemento de Quantidade nao gera movimentacao de CQ do tipo 8 portanto nao deve chamar a funcao abaixo, caso contrario sera exibido Help indevidamente. O estorno da mov. de CQ sera tratado o bloco seguinte.
			fEstoCQ8((cAliasSD1)->D1_NUMCQ,(cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL,IIF((cAliasSD1)->D1_TIPO$"CIP",{(cAliasSD1)->D1_DOC, (cAliasSD1)->D1_SERIE, (cAliasSD1)->D1_FORNECE, (cAliasSD1)->D1_LOJA},Nil))
		EndIf

		If !(cAliasSD1)->D1_TIPO $ "CIP" .Or. (lComplQtd .And. cTpCompl == "2")
			dbSelectArea("SD7")
			dbSetOrder(1)

			If RetFldProd(SB1->B1_COD,"B1_TIPOCQ")=="Q"
				lQuery := .T.
				cCursorSD7 := GetNextAlias()

				cQuery := "SELECT SD7.*,SD7.R_E_C_N_O_ SD7RECNO "
				cQuery += "  FROM "+RetSqlName("SD7")+" SD7 "
				cQuery += " WHERE SD7.D7_FILIAL  = '"+xFilial("SD7")+"'"
				cQuery += "   AND SD7.D7_NUMERO  = '"+(cAliasSD1)->D1_NUMCQ+"'"
				cQuery += "   AND SD7.D7_LOCAL   = '"+(cAliasSD1)->D1_LOCAL+"'"
				cQuery += "   AND SD7.D7_PRODUTO = '"+(cAliasSD1)->D1_COD+"'"
				cQuery += "   AND SD7.D_E_L_E_T_ = ' ' "
				cQuery += "ORDER BY "+SqlOrder(SD7->(IndexKey()))

				cQuery := ChangeQuery(cQuery)
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursorSD7)

				For nX := 1 To Len(aStruSD7)
					If aStruSD7[nX][2]<>"C"
						TcSetField(cCursorSD7,aStruSD7[nX][1],aStruSD7[nX][2],aStruSD7[nX][3],aStruSD7[nX][4])
					EndIf
				Next nX

			Else
				lQuery := .T.
				cQuery := "UPDATE "+RetSqlName("SD7")+" "
				cQuery += "   SET D_E_L_E_T_ = '*' "
				cQuery += " WHERE D7_FILIAL  = '"+xFilial("SD7")+"'"
				cQuery += "   AND D7_NUMERO  = '"+(cAliasSD1)->D1_NUMCQ+"'"
				cQuery += "   AND D7_PRODUTO = '"+(cAliasSD1)->D1_COD+"'"
				cQuery += "   AND D7_LOCAL   = '"+(cAliasSD1)->D1_LOCAL+"'"
				cQuery += "   AND D_E_L_E_T_ = ' ' "

				TcSqlExec(cQuery)
				SD7->(MsGoto(0))
			EndIf

			If !lQuery .Or. RetFldProd(SB1->B1_COD,"B1_TIPOCQ")=="Q"
				While !(cCursorSD7)->(Eof()) .And. xFilial("SD7") == (cCursorSD7)->D7_FILIAL .And.;
						(cAliasSD1)->D1_NUMCQ == (cCursorSD7)->D7_NUMERO  .And.;
						(cAliasSD1)->D1_COD   == (cCursorSD7)->D7_PRODUTO .And.;
						(cAliasSD1)->D1_LOCAL == (cCursorSD7)->D7_LOCAL
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Estorno do CQ no Quality                                               ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If (cCursorSD7)->D7_TIPO==0 .And. (cCursorSD7)->D7_ORIGLAN=="CP" .And. RetFldProd(SB1->B1_COD,"B1_TIPOCQ")=="Q"
						If Rastro(SB1->B1_COD)
							dbSelectArea("SD5")
							dbSetOrder(3)
							If MsSeek(xFilial("SD5")+(cAliasSD1)->D1_NUMSEQ+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL+(cAliasSD1)->D1_LOTECTL,.F.)
								aLote := {SD5->D5_LOTECTL,SD5->D5_NUMLOTE}
							Else
								aLote := {"",""}
							EndIf
						EndIf
						aEnvCele := {(cAliasSD1)->D1_DOC,; //Numero da Nota Fiscal
							(cAliasSD1)->D1_SERIE,;        //Serie da Nota Fiscal
							(cAliasSD1)->D1_TIPO,;         //Tipo da Nota Fiscal
							(cAliasSD1)->D1_EMISSAO,;      //Data de Emissao da Nota Fiscal
							(cAliasSD1)->D1_DTDIGIT,;      //Data de Entrada da Nota Fiscal
							"NF",; 	  		                //Tipo de Documento
							(cAliasSD1)->D1_ITEM,; 	        //Item da Nota Fiscal
							(cAliasSD1)->D1_REMITO,;       //Numero do Remito (Localizacoes)
							(cAliasSD1)->D1_PEDIDO,;       //Numero do Pedido de Compra
							(cAliasSD1)->D1_ITEMPC,;       //Item do Pedido de Compra
							(cAliasSD1)->D1_FORNECE,;      //Codigo Fornecedor/Cliente
							(cAliasSD1)->D1_LOJA,;         //Loja Fornecedor/Cliente
							(cAliasSD1)->D1_LOTEFOR,;      //Numero do Lote do Fornecedor
							Space(6),;                     //Codigo do Solicitante
							(cAliasSD1)->D1_COD,;          //Codigo do Produto
							(cAliasSD1)->D1_LOCAL,;        //Local Origem
							aLote[1],;                     //Numero do Lote
							aLote[2],;                     //Sequencia do Sub-Lote
							(cAliasSD1)->D1_NUMSEQ,;       //Numero Sequencial
							(cCursorSD7)->D7_NUMERO,;      //Numero do CQ
							(cAliasSD1)->D1_QUANT,;        //Quantidade
							(cAliasSD1)->D1_TOTAL,;        //Preco
							0,;                            //Dias de atraso
							(cAliasSD1)->D1_TES,;          //TES
							AllTrim(FunName()),;           //Origem						
							" ",;                          //Origem TXT	
							0}                             //Quantidade do Lote Original
						aRecCele := QAtuMatQie(aEnvCele,2,,IIf(Type('l103Auto') <> 'U', l103Auto, .F. ))
					EndIf

					If lQuery
						SD7->( MsGoto( ( cCursorSD7 )->SD7RECNO ) )
					EndIf

					RecLock("SD7", .F.)
					SD7->( dbDelete() )
					( cCursorSD7 )->( dbSkip() )
				EndDo			
			EndIf
			If lQuery
				dbSelectArea(cCursorSD7)
				dbCloseArea()
				dbSelectArea("SD7")
			EndIf
		EndIf	
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza saldo fisico e financeiro                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RecLock("SD1",.F.)
	If SF4->F4_ESTOQUE=="S"
		B2AtuComD1(-1,(cAliasSD1)->D1_SKIPLOT, cAliasSD1, .T.)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Amarracao Fornecedor/Produto                                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SA5")
	dbSetOrder(1)
	lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_COD)
	If !lAchou .And. lReferencia	
		dbSelectArea("SA5")
		dbSetOrder(1)
		lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+cProdRef)
	Endif
	If lAchou	
		RecLock("SA5",.F.)
		For nX := 1 To 12
			If ( FieldGet(FieldPos("A5_DTCOM"+StrZero(nX,2))) == (cAliasSD1)->D1_EMISSAO .And.;
					FieldGet(FieldPos("A5_PRECO" +StrZero(nX,2))) == IIF(nMcusto=="1",(cAliasSD1)->D1_CUSTO/(cAliasSD1)->D1_QUANT,(cAliasSD1)->(FieldGet(FieldPos("D1_CUSTO"+nMcusto)))/(cAliasSD1)->D1_QUANT) .And.;
					FieldGet(FieldPos("A5_QUANT" +StrZero(nX,2))) == (cAliasSD1)->D1_QUANT .And.;
					FieldGet(FieldPos("A5_COND"  +StrZero(nX,2))) == SF1->F1_COND )

				FieldPut(FieldPos("A5_DTCOM"+StrZero(nX,2)),Ctod(""))
				FieldPut(FieldPos("A5_PRECO" +StrZero(nX,2)),0)
				FieldPut(FieldPos("A5_QUANT" +StrZero(nX,2)),0)
				FieldPut(FieldPos("A5_COND"  +StrZero(nX,2)),"")

			EndIf
		Next nX
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza quantidade de entregas do produto  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SA5->A5_SKIPLOT > 0
			SA5->A5_ENTREGA -= 1
		EndIf
   		MsUnlock()

	EndIf
	//CIAP
	If ( !Empty((cAliasSD1)->D1_CODCIAP) ) .Or. (cFTCiap=="S" .And. IsInCallStack("MATA116"))
		A103CIAP(2, cAliasSD1, , "MATA103")       
	EndIf 
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pedido de Compra                                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty((cAliasSD1)->D1_PEDIDO)
		nRecC7 := A103RECC7(xFilial("SC7"),(cAliasSD1)->D1_PEDIDO,(cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,(cAliasSD1)->D1_COD,(cAliasSD1)->D1_ITEMPC)
		SC7->(DbGoTo(nRecC7))
		If nRecC7 > 0
			MaAvalPC("SC7",9)
			
			If A103GCDisp()
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Retorna o saldo a receber da planilha                                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				CtaAvalGCT(2,aContratos,SC7->C7_CONTRA,SC7->C7_PLANILH,SC7->C7_ITEMED,SD1->D1_QUANT,,SC7->C7_MEDICAO,SD1->D1_TOTAL)
			EndIf 
		EndIf
	EndIf		
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza Poder de Terceiro                                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SF4->F4_PODER3<>"N"
		MaAtuSB6("SD1",2)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica os documentos de cobertura                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SDH")
	dbSetOrder(1)
	If MsSeek(xFilial("SDH")+SD1->D1_NUMSEQ)
		nQtdBaixa := SDH->DH_QUANT
		RecLock("SDH")
		SDH->(dbDelete())
		MsUnLock()
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o documento de cobertura original                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SDH->DH_TPMOV == "2"
			dbSelectArea("SDH")
			dbSetOrder(2)
			If MsSeek(xFilial("SDH")+"1"+SDH->DH_SERIE+SDH->DH_DOC+SDH->DH_ITEM+SDH->DH_CLIENTE+SDH->DH_LOJACLI+SDH->DH_FORNECE+SDH->DH_LOJAFOR+SDH->DH_OPER)
				RecLock("SDH")
				SDH->DH_SALDO += nQtdBaixa
				MsUnLock()
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica complementos de integracao                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("bTTSSD1")=="B"
		Eval(bTTSSD1,nOpcao)
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com o modulo de projetos                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If IntePms()
		PmsWriteNF(3,cAliasSD1,,,lEstNfClass)
	EndIf

	// Exclui consumo e saldo de compra de entrega futura
	If lDHQInDic .And. lMt103Com
		A103FutRem(.T.)
		A103FutFat(.T.)
	EndIf

EndCase
RestArea(aArea)
Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeRatCC  ³ Autor ³ Eduardo Riera         ³ Data ³15.10.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Interface com o usuario para o rateio de centro de custo dos ³±±
±±³          ³itens do documento de entrada                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: aHeader do alias SDE                                  ³±±
±±³          ³ExpA2: aCols do alias SDE com a seguinte estrutura:          ³±±
±±³          ³       [1] Item do documento de entrada                      ³±±
±±³          ³       [2] aCols do SDE                                      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo controlar a interface com o usu³±±
±±³          ³ario do rateio dos itens do documento de entrada             ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103RatCC()
Local bSavKeyF9   := SetKey(VK_F9,Nil)

If !l103Auto .And. !IsInCallStack ('MATA140')
	If M->D1_RATEIO =="1"
		Eval(bSavKeyF9,.T.)
	Endif
EndIf
SetKey(VK_F9 ,bSavKeyF9)            

Return(.T.)

Function NfeRatCC(aHeadSDE,aColsSDE,lAltera,lValidX3)

Local aArea       := GetArea()
Local aSavaRotina := aClone(aRotina)
Local aColsCC     := {}
Local aButtons	  := {}
Local aButtonUsr  := {}
Local aHeadSD1    := {}
Local aColsSD1    := {}
Local aBkpSDE     := {}
Local aNoFields   := {"DE_CUSTO1","DE_CUSTO2","DE_CUSTO3","DE_CUSTO4","DE_CUSTO5"}
Local aCTBEnt     := CTBEntArr()
Local bSavKeyF4   := SetKey(VK_F4 ,Nil)
Local bSavKeyF5   := SetKey(VK_F5 ,Nil)
Local bSavKeyF6   := SetKey(VK_F6 ,Nil)
Local bSavKeyF7   := SetKey(VK_F7 ,Nil)
Local bSavKeyF8   := SetKey(VK_F8 ,Nil)
Local bSavKeyF9   := SetKey(VK_F9 ,Nil)
Local bSavKeyF10  := SetKey(VK_F10,Nil)
Local bSavKeyF11  := SetKey(VK_F11,Nil)
Local nPItemNF	  := GetPosSD1("D1_ITEM" )
Local nPCC	      := GetPosSD1("D1_CC" )
Local nPConta	  := GetPosSD1("D1_CONTA" )
Local nPItemCta   := GetPosSD1("D1_ITEMCTA" )
Local nPCLVL	  := GetPosSD1("D1_CLVL" )
Local nPCtbEnt    := 0
Local nPDECC	  := 0
Local nPDEConta	  := 0
Local nPDEItemCta := 0
Local nPDECLVL	  := 0
Local nPRateio    := GetPosSD1("D1_RATEIO" )
Local nColTotal   := GetPosSD1("D1_TOTAL" )
Local nItem  	   := aScan(aColsSDE,{|x| x[1] == aCols[n][nPItemNF]})
Local nY          := 0
Local nX          := 0
Local nZ          := 0
Local nSavN       := N
Local nPPercSDE   := 0
Local nTotPerc    := 0
Local nOpcA       := 0
Local nNewTam     := 0
Local nLinDoc     := 0
Local lContinua   := .T.
Local lRet        := .T.
Local lMT103LRAT  := .T.
Local lRetPCO     := .T.
Local oDlg
Local cCampo      := ReadVar()
Local nAviso      := 0  
Local oSize
Local lMA103REPRAT:=ExistBlock("MA103REPRAT")
Local aColsSDEcpy
Local aHeadAux    := {}
Local lMV103lRat  := SuperGetMv("MV_M103LRA",.F.,.F.)

DEFAULT aHeadSDE  := {}
DEFAULT aColsSDE  := {}
DEFAULT lAltera   := .T.
DEFAULT lValidX3  := .F.

Private aOrigHeader := aClone(aHeader)
Private aOrigAcols  := aClone(aCols)
Private oGetMan
Private nOrigN      := N 
Private nPercRat    := 0
Private nPercARat	  := 100
Private oPercRat
Private oPercARat
Private cItNfEntr  := aCols[n, nPItemNF] //utilizado pela funcao PcoVldLan() modulo PCO
Private nVlrTotal  := aCols[n, nColTotal] //utilizado pela funcao PcoVldLan() modulo PCO
Private oGetDad
           
dbSelectArea("SX3")
	dbSetOrder(1)
	MsSeek("SDE")
	While !EOF() .And. (SX3->X3_ARQUIVO == "SDE")
		IF X3USO(SX3->X3_USADO) .AND. cNivel >= SX3->X3_NIVEL .And. !"DE_CUSTO"$SX3->X3_CAMPO
			AADD(aHeadAux,{ TRIM(x3Titulo()),;
				SX3->X3_CAMPO,;
				SX3->X3_PICTURE,;
				SX3->X3_TAMANHO,;
				SX3->X3_DECIMAL,;
				SX3->X3_VALID,;
				SX3->X3_USADO,;
				SX3->X3_TIPO,;
				SX3->X3_F3,;
				SX3->X3_CONTEXT,;
				SX3->X3_PROPRI } )
		EndIf
		dbSelectArea("SX3")
		dbSkip()
	EndDo

If Type("aColsD1")=="A"
	aColSD1 := aCols
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada para inibir o Rateio do item por    	 ³
//³ Centro de Custo                           			     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("NFEINICC")
	lRet := Execblock("NFEINICC",.F.,.F.)
	If ValType(lRet) <> "L"
		lRet := .T.
	EndIf
EndIf      

If lRet
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ativa os botoes da toolbar                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (!l103Visual)
		If !__lPyme	
			aadd(aButtons,{'AUTOM',{||  a103RatPCnf(aHeadSde,oGetDad) },STR0021,OemToAnsi(STR0029)}) //'Escolha de Rateio Pre-Configurado'
		EndIF	
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ponto de Entrada Padrao                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock("A103BRCC")  
		aButtonUsr := ExecBlock("A103BRCC",.F.,.F.,{{|x|aHeadSde}})
	  	If ValType(aButtonUsr) == "A"
			For nX   := 1  To  Len(aButtonUsr)
		  		aadd(aButtons,aClone(aButtonUsr[nX]))
			Next nX
		EndIf  
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Impede de executar a rotina quando a tecla F3 estiver ativa		   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("InConPad") == "L"
		lContinua := !InConPad
	EndIf
	If lContinua
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Montagem do aHeader do SDE                                          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Empty(aHeadSDE)
			dbSelectArea("SX3")
			dbSetOrder(1)
			MsSeek("SDE")
			While !EOF() .And. (SX3->X3_ARQUIVO == "SDE")
				IF X3USO(SX3->X3_USADO) .AND. cNivel >= SX3->X3_NIVEL .And. !"DE_CUSTO"$SX3->X3_CAMPO
					AADD(aHeadSDE,{ TRIM(x3Titulo()),;
						SX3->X3_CAMPO,;
						SX3->X3_PICTURE,;
						SX3->X3_TAMANHO,;
						SX3->X3_DECIMAL,;
						SX3->X3_VALID,;
						SX3->X3_USADO,;
						SX3->X3_TIPO,;
						SX3->X3_F3,;
						SX3->X3_CONTEXT } )
				EndIf
				dbSelectArea("SX3")
				dbSkip()
			EndDo
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Adiciona os campos de Alias e Recno ao aHeader para WalkThru.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ADHeadRec("SDE",aHeadSDE)
		EndIf
	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³A rotina a seguir limpa o rateio digitado no item quando o mesmo for ³
		//³acionado pela validacao do campo D1_RATEIO com conteudo igual a NAO. ³
		//³Quando o rateio e disparado pela tecla F9, o D1_RATEIO sempre sera   ³
		//³igual a SIM e o lValidX3 assume o default .F., porem quando o rateio ³
		//³for acionado pela validacao do D1_RATEIO o lValidX3 sera .T. e aciona³
		//³a rotina a seguir para confirmar ou nao a exclusao do rateio no item.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ       	
		If nItem > 0 .And. lValidX3    
			If M->D1_RATEIO == "2"
				If Aviso(STR0018,STR0030,{STR0008,STR0007})==1
					nNewTam   := Len(aColsSDE)-1
					aColsSDE  := aSize(aDel(aColsSDE,nItem), nNewTam)
					nItem := aScan(aColsSDE,{|x| x[1] == aCols[n][nPItemNF]})
		        EndIF 
		    EndIf
	    EndIf
	    
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Montagem do aCols do SDE                                            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nItem > 0 
			aColsCC := aClone(aColsSDE[nItem][2])
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Totaliza o % ja Rateado ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nPercRat := 0 
			
			For nX   := 1  To  Len(aColsCC)
			If aColsCC[nX][aScan(aHeadSDE,{|x| AllTrim(x[2])=="DE_PERC"})] <> NIL
				nPercRat += aColsCC[nX][aScan(aHeadSDE,{|x| AllTrim(x[2])=="DE_PERC"})]
			EndIf						 
		
			For nY   := 1  To  Len(aHeadAux)
				IF !(aHeadAux[nY][2] $ "DE_REC_WT")  .and. !(aHeadAux[nY][2] $ "DE_ALI_WT") 
					IF aHeadAux[nY][11] == "U" 
						Do Case
							Case (aHeadAux[nY][8] == "C" .or.  aHeadAux[nY][8] == "M") .and. Empty(aColsCC[nX][nY]) 
								 aColsCC[nX][nY] := Space(aHeadAux[nY][4])
							Case aHeadAux[nY][8] == "N" .and. Empty(aColsCC[nX][nY]) 
								aColsCC[nX][nY] := 0
						EndCase 
					EndIf
				EndIf
			Next nY  
		Next nX 
			
			nPercARat := 100 - nPercRat
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ aHeader e aCols do SD1 devem ser salvos pois a FillGetDados destroe ³
			//³ ambos por serem PRIVATE, independente da construcao do aColsCC.     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
			aHeadSD1 := aClone(aHeader)
			aColsSD1 := aClone(aCols)
	        aHeadSDE := {}
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Sintaxe da FillGetDados(nOpcX,Alias,nOrdem,cSeek,bSeekWhile,uSeekFor,aNoFields,aYesFields,lOnlyYes,cQuery,bMontCols,lEmpty,aHeaderAux,aColsAux,bAfterCols,bBeforeCols,bAfterHeader,cAliasQry |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			FillGetDados(IIf(lAltera,3,2),"SDE",1,,,,aNoFields,,,,,.T.,aHeadSDE,aColsCC,,,)
			aColsCC[1][aScan(aHeadSDE,{|x| Trim(x[2])=="DE_ITEM"})] := StrZero(1,Len(SDE->DE_ITEM))

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de Entrada para açterar array de rateio por CC       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	                          
			If ExistBlock("MT100RTX") .And. ( !lValidX3 .Or. (lValidX3 .And. M->D1_RATEIO == "1") )
				If ValType(aColsCC) == "A"
					aColsCC:= ExecBlock("MT100RTX",.F.,.F.,{aHeadSDE,aColsCC})
				Endif
			Endif
	
	        aHeader := aHeadSD1
	        aCols   := aColsSD1
	
		EndIf
		If !(Type('l103Auto') <> 'U' .And. l103Auto)   		
			aHeadSD1 := aClone(aHeader)
			aColsSD1 := aClone(aCols)
			DEFINE MSDIALOG oDlg FROM 100,100 TO 350,740 TITLE STR0020 Of oMainWnd PIXEL //"Rateio por Centro de Custo"
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Calcula dimensões                                            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			oSize := FwDefSize():New(.T.,,,oDlg)
			oSize:aWorkArea := {000, 035, 320, 120 }
			oSize:AddObject( "CABECALHO",  100, 10, .T., .T. ) // Totalmente dimensionavel
			oSize:AddObject( "GETDADOS" ,  100, 80, .T., .T. ) // Totalmente dimensionavel 
			oSize:AddObject( "RODAPE"   ,  100, 10, .T., .T. ) // Totalmente dimensionavel
			
			oSize:lProp 	:= .T. // Proporcional             
			oSize:aMargins 	:= { 3, 3, 3, 3 } // Espaco ao lado dos objetos 0, entre eles 3 
		
			oSize:Process() 	   // Dispara os calculos   
						
			@ oSize:GetDimension("CABECALHO","LININI") ,oSize:GetDimension("CABECALHO","COLINI") SAY RetTitle("F1_DOC")  OF oDlg PIXEL SIZE 20,09
			@ oSize:GetDimension("CABECALHO","LININI") ,oSize:GetDimension("CABECALHO","COLINI")+30 SAY Substr(cSerie,1,3)+"/"+cNFiscal OF oDlg PIXEL SIZE 50,09
			@ oSize:GetDimension("CABECALHO","LININI") ,oSize:GetDimension("CABECALHO","COLINI")+93 SAY RetTitle("D1_ITEM") OF oDlg PIXEL SIZE 20,09
			@ oSize:GetDimension("CABECALHO","LININI") ,oSize:GetDimension("CABECALHO","COLINI")+112 SAY aCols[N][nPItemNF]  OF oDlg PIXEL SIZE 20,09
			
		    oGetDad := MsNewGetDados():New(oSize:GetDimension("GETDADOS","LININI"),oSize:GetDimension("GETDADOS","COLINI"),;
					   oSize:GetDimension("GETDADOS","LINEND"),oSize:GetDimension("GETDADOS","COLEND"),;
     			       IIF(lAltera,GD_INSERT+GD_UPDATE+GD_DELETE,0),"NfeRatLOk","NfeRatTOk","+DE_ITEM",,,999,/*fieldok*/,/*superdel*/,/*delok*/,oDlg,aHeadSDE,aColsCC)		
			oGetMan := oGetDad
			
			@ oSize:GetDimension("RODAPE","LININI"),oSize:GetDimension("RODAPE","COLINI") Say OemToAnsi(STR0042) FONT oDlg:oFont OF oDlg PIXEL	 // "% Rateada: "
			@ oSize:GetDimension("RODAPE","LININI"),oSize:GetDimension("RODAPE","COLINI")+30  Say oPercRat VAR nPercRat Picture PesqPict("SDE","DE_PERC") FONT oDlg:oFont COLOR CLR_HBLUE OF oDlg PIXEL
			@ oSize:GetDimension("RODAPE","LININI"),oSize:GetDimension("RODAPE","COLINI")+180 Say OemToAnsi(STR0043) FONT oDlg:oFont OF oDlg PIXEL	 // "% A Ratear: "
	 		@ oSize:GetDimension("RODAPE","LININI"),oSize:GetDimension("RODAPE","COLINI")+214 Say oPercARat VAR nPercARat Picture PesqPict("SDE","DE_PERC") FONT oDlg:oFont COLOR CLR_HBLUE OF oDlg PIXEL		
			ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar(oDlg,{||IIF(oGetDad:TudoOk(),(nOpcA:=1,oDlg:End()),(nOpcA:=0))},{||oDlg:End()},,aButtons)
			
			If lAltera
				aColsCC := Aclone(oGetDad:aCols)
			Else
		        aHeader := aHeadSD1
		        aCols   := aColsSD1
			EndIf
		Else
			nOpcA := 1
		EndIf
		nPPercSDE := aScan(aHeadSDE,{|x| AllTrim(x[2])=="DE_PERC"})
		nTotPerc := 0
		
		aColsPar :={}
		AEval( aColsCC, { |x| If( !x[ Len(aHeadSDE) + 1], AAdd( aColsPar, x ), ) } ) 
		aColsCC := aClone( aColsPar )   
		
		For nX := 1 To Len(aColsCC)
			nTotPerc += aColsCC[nX][nPPercSDE]
		Next nX			
	
		nPDECC	      := aScan(aHeadsde,{|x| AllTrim(x[2]) == "DE_CC"} )
		nPDEConta	  := aScan(aHeadsde,{|x| AllTrim(x[2]) == "DE_CONTA"} )
		nPDEItemCta   := aScan(aHeadsde,{|x| AllTrim(x[2]) == "DE_ITEMCTA"} )
		nPDECLVL	  := Ascan(aHeadsde,{|x| AllTrim(x[2]) == "DE_CLVL"} )
	
		If nOpcA == 1 .And. lAltera
			If nTotPerc > 0
				If nItem > 0
					aColsSDE[nItem][2]	:= aClone(aColsCC)
				Else
					aadd(aColsSDE,{aCols[N][nPItemNF],aClone(aColsCC)})
				EndIf
		
				aCols[N][nPRateio] := "1"
				               
				//Ponto de Entrada que irá indicar se o aCOLS continuará
				//preenchido quando houver rateio por Centro de Cust0
				If ExistBlock("MT103LRAT")
			   		lMT103LRAT := ExecBlock("MT103LRAT",.F.,.F.,{aHeadSDE,aColsSDE})
	   				If ValType(lMT103LRAT)<>"L"
		   				lMT103LRAT:=.T.
		   			EndIf
			 	EndIf

				//Parametro MV_M103LRA indica se o aCols continuara preenchido
				//quando houver rateio por centro de custo.
				If !lMT103LRAT .Or. !lMV103lRat
					lMT103LRAT := .F.
				Endif

				If lMT103LRAT
					If nPCC <> 0 .And. nPDECC <> 0
						aCols[N][nPCC]     := Space(Len(aCols[N][nPCC]))
					EndIf
					If nPConta <> 0 .And. nPDEConta <> 0
						aCols[N][nPConta]  := Space(Len(aCols[N][nPConta]))
					EndIf
					If nPItemCta <> 0 .And. nPDEItemCta <> 0
						aCols[N][nPItemCta]:= Space(Len(aCols[N][nPItemCta]))
					EndIf
					If nPCLVL <> 0 .And. nPDECLVL <> 0
						aCols[N][nPCLVL]   := Space(Len(aCols[N][nPCLVL]))
					EndIf

					For nZ := 1 To Len(aCTBEnt)
						If ( nPCtbEnt := GetPosSD1("D1_EC"+aCTBEnt[nZ]+"DB" ) ) > 0
							aCols[N][nPCtbEnt] := Space(Len(aCols[N][nPCtbEnt]))
						EndIf
						If ( nPCtbEnt := GetPosSD1("D1_EC"+aCTBEnt[nZ]+"CR" ) ) > 0
							aCols[N][nPCtbEnt] := Space(Len(aCols[N][nPCtbEnt]))
						EndIf
					Next nZ
				EndIf
							
			    If Len(aCols)>1
					cMsg := CRLF + CRLF
					cMsg += STR0167 + StrZero(n,TamSx3("D1_ITEM")[1]) + CRLF //"Sim - Replica TODAS informações a partir do item do documento posicionado:"
					cMsg += STR0168 //"Todos - Replica TODAS informações para todos os itens do documento"
				
					nAviso := Aviso(STR0018,STR0046+cMsg,{STR0008,STR0007,STR0047}) //"Atenção"###"Replicar informações para os demais itens do documento?"###"Sim"###"Não"###"Todos"
					aBkpSDE := aClone(aColsSDE)
					If nAviso == 3
						aColsSDE := {}
						nAux := 1
					Else
						nAux := n
					EndIf
					If nAviso <> 2
						For nX := nAux To Len(aCols)
							nItem  	  := aScan(aColsSDE,{|x| x[1] == aCols[nX][nPItemNF]})
							If nItem == 0
								aadd(aColsSDE,{aCols[nX][nPItemNF],aClone(aColsCC)})
	
								aCols[nX][nPRateio] := "1"
	                             
								If lMT103LRAT	
									If nPCC <> 0 .And. nPDECC <> 0
										aCols[NX][nPCC]     := Space(Len(aCols[NX][nPCC]))
									EndIf
									If nPConta <> 0 .And. nPDEConta <> 0
										aCols[NX][nPConta]  := Space(Len(aCols[NX][nPConta]))
									EndIf
									If nPItemCta <> 0 .And. nPDEItemCta <> 0
										aCols[NX][nPItemCta]:= Space(Len(aCols[NX][nPItemCta]))
									EndIf
									If nPCLVL <> 0 .And. nPDECLVL <> 0
										aCols[NX][nPCLVL]   := Space(Len(aCols[NX][nPCLVL]))
									EndIf

									For nZ := 1 To Len(aCTBEnt)
										If ( nPCtbEnt := GetPosSD1("D1_EC"+aCTBEnt[nZ]+"DB" ) ) > 0
											aCols[N][nPCtbEnt] := Space(Len(aCols[N][nPCtbEnt]))
										EndIf
										If ( nPCtbEnt := GetPosSD1("D1_EC"+aCTBEnt[nZ]+"CR" ) ) > 0
											aCols[N][nPCtbEnt] := Space(Len(aCols[N][nPCtbEnt]))
										EndIf
									Next nZ

								EndIf	
								If nAviso == 3 .And. lMA103REPRAT
									aColsSDEcpy:=ExecBlock("MA103REPRAT",.F.,.F.,{aHeadSDE,aColsSDE})
									If ValType(aColsSDEcpy) == 'A'
									   aColsSDE:= aColsSDEcpy
									EndIf
								EndIf
							Else
								aColsSDE[nItem,2] := aClone(aColsCC)
							EndIf
							// Executa validacao de bloqueio no SIGAPCO para todos os itens do documento
							// quando for selecionada opcao para replicar rateio para os demais itens
							If aCols[nX][nPItemNF] != cItNfEntr	// Nao executa validacao para a linha da nota que esta posicionada, pois ja foi validada pela funcao NfeRatLok
								cItNfEntr := aCols[nX][nPItemNF]
								nVlrTotal := aCols[nX][nColTotal]
								nLinDoc := aScan(aColsSDE,{|x| x[1] == aCols[nX][nPItemNF]})
								lRetPCO := NfeRatTok(aHeadSDE,aColsCC,nLinDoc,.T.)
								If !lRetPCO
									aColsSDE := aBkpSDE
									Exit
								EndIf
							EndIf
						Next nX			
					EndIf
				EndIf
			Else
				If nItem > 0
					aColsSDE[nItem][2]	:= aClone(aColsCC)
				Else
					aadd(aColsSDE,{aCols[N][nPItemNF],aClone(aColsCC)})
				EndIf
				aCols[nSavN][nPRateio] := "2"
				M->D1_RATEIO := "2"
			EndIf
		ElseIf !l103Visual
			If nTotPerc > 0 .And. nItem > 0
				If "D1_RATEIO" $ cCampo
					&cCampo := "1"
				EndIf
				aCols[nSavN][nPRateio] := "1"
			Else
				If "D1_RATEIO" $ cCampo
					&cCampo := "2"
				EndIf
				aCols[nSavN][nPRateio] := "2"
			EndIf
		EndIf
	EndIf                                                                    
EndIf

If nOpcA == 0
	If nTotPerc <= 0
		aCols[nSavN][nPRateio] := "2"
		M->D1_RATEIO := "2"	
	Endif		
EndIf

If Type("aAuxColSDE") == "U"
	PRIVATE aAuxColSDE := {}
EndIf

aAuxColSDE := aColsSDE

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura a integridade da rotina                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aRotina	:= aClone(aSavaRotina)
N := nSavN
SetKey(VK_F4 ,bSavKeyF4)
SetKey(VK_F5 ,bSavKeyF5)
SetKey(VK_F6 ,bSavKeyF6)
SetKey(VK_F7 ,bSavKeyF7)
SetKey(VK_F8 ,bSavKeyF8)
SetKey(VK_F9 ,bSavKeyF9)
SetKey(VK_F10,bSavKeyF10)
SetKey(VK_F11,bSavKeyF11)
RestArea(aArea)
Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeCarCC ³ Autor ³ Wagner Mobile Costa    ³ Data ³21.10.2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Carrega as definicoes de rateio externo                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA103                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function NfeCarCC(aCols, aHeader, cItem, lPrimeiro, lRatBlq)

Local lCusto		:= CtbMovSaldo("CTT")
Local lItem	 		:= CtbMovSaldo("CTD")
Local lCLVL	 		:= CtbMovSaldo("CTH")
Local lMT103PRE     := ExistBlock("MT103PRE")
Local lBloqCTJ      := .F.
Local nPosPerc		:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_PERC" } )
Local nPosItem		:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_ITEM" } )
Local nPosCC		:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_CC"} )
Local nPosConta		:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_CONTA"} )
Local nPosItemCta	:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_ITEMCTA"} )
Local nPosCLVL		:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_CLVL"} )
Local nHeader       := 0
Local aMT103PRE     := {}
Local aEntidades	:= {}
Local nEnt			:= 0
Local nDeb			:= 0

cItem := StrZero(Val(cItem), tamSX3("DE_ITEM")[1])
If lPrimeiro
	//-- Se ja foi informado algum rateio, limpar o aCols
	If aCols[Len(aCols)][nPosPerc] <> 0
		aCols := {}
		Aadd(aCols, Array(Len(aHeader) + 1))
		For nHeader := 1 To Len(aHeader)
			If Trim(aHeader[nHeader][2]) <> "DE_ALI_WT" .And. Trim(aHeader[nHeader][2]) <> "DE_REC_WT"
				aCols[Len(aCols)][nHeader] := CriaVar(aHeader[nHeader][2])
			Endif
		Next
	EndIf
	cItem := Soma1(cItem)
	aCols[Len(aCols)][nPosItem]  := cItem
	aCols[Len(aCols)][Len(aHeader)+1] := .F.
Else
	If CTJ->(FieldPos('CTJ_MSBLQL'))>0
		lBloqCTJ:=IIF(CTJ->CTJ_MSBLQL=="1",.T.,.F.)
	EndIf
	
	If !lBloqCTJ
		If aCols[Len(aCols)][nPosPerc] = 0
			nCols := Len(aCols)
			cItem := aCols[nCols][nPosItem]
		Else
			If Len(aCols) > 0
				cItem := aCols[Len(aCols)][nPosItem]
			Endif
			Aadd(aCols, Array(Len(aHeader) + 1))
			cItem := Soma1(cItem)
		EndIf
		
		For nHeader := 1 To Len(aHeader)
			If Trim(aHeader[nHeader][2]) <> "DE_ALI_WT" .And. Trim(aHeader[nHeader][2]) <> "DE_REC_WT"
				aCols[Len(aCols)][nHeader] := CriaVar(aHeader[nHeader][2])
			EndIf
		Next
		
		aCols[Len(aCols)][nPosItem] := cItem
		
		// Interpreto os campos incluida possibilidade de variaveis de memoria
		If !Empty(CTJ->CTJ_DEBITO)
			aCols[Len(aCols)][nPosConta]	:= CTJ->CTJ_DEBITO
		Else
			aCols[Len(aCols)][nPosConta]	:= CTJ->CTJ_CREDIT
		Endif
		
		If lCusto
			If ! Empty(CTJ->CTJ_CCD)
				aCols[Len(aCols)][nPosCc]	:= CTJ->CTJ_CCD
			Else
				aCols[Len(aCols)][nPosCc]	:= CTJ->CTJ_CCC
			Endif
		EndIf
		
		If lItem
			If ! Empty(CTJ->CTJ_ITEMD)
				aCols[Len(aCols)][nPosItemCta]	:= CTJ->CTJ_ITEMD
			Else
				aCols[Len(aCols)][nPosItemCta]	:= CTJ->CTJ_ITEMC
			Endif
		EndIf
		
		If lClVl
			If ! Empty(CTJ->CTJ_CLVLDB)
				aCols[Len(aCols)][nPosClVl]	:= CTJ->CTJ_CLVLDB
			Else
				aCols[Len(aCols)][nPosClVl]	:= CTJ->CTJ_CLVLCR
			Endif
		EndIf
		aCols[Len(aCols)][nPosPerc] := CTJ->CTJ_PERCEN
		aCols[Len(aCols)][Len(aHeader) + 1] := .F.
		
		aEntidades := CtbEntArr()
		For nEnt := 1 to Len(aEntidades)
			For nDeb := 1 to 2
				cCpo := "DE_EC"+aEntidades[nEnt]
				cCTJ := "CTJ_EC"+aEntidades[nEnt]
				
				If nDeb == 1 
					cCpo += "DB"
					cCTJ += "DB"
				Else
					cCpo += "CR"
					cCTJ += "CR"
				EndIf
				
				nPosHead := aScan(aHeader,{|x| AllTrim(x[2]) == Alltrim(cCpo) } )
				
				If nPosHead > 0
			   		aCols[Len(aCols)][nPosHead] := CTJ->(&(cCTJ))
				EndIf
				
			Next nDeb
		Next nEnt
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Ponto de Entrada que retorna dados dos campos personalizados   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lMT103PRE
			aMT103PRE := ExecBlock( "MT103PRE", .F., .F.,{aHeader,aCols})
			If ( ValType(aMT103PRE) == 'A' )
				aCols := AClone(aMT103PRE)
			EndIf
		EndIf
	Else
		If !lRatBlq
			Aviso("A103NFECARCC",STR0191,{"Ok"})
			lRatBlq := .T.
		EndIf
	EndIf
EndIf

Return .T.
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeRatLok ³ Autor ³ Eduardo Riera         ³ Data ³15.10.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Validacao da linhaok dos itens do rateio dos itens do documen³±±
±±³          ³to de entrada                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se a linha esta valida                         ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar a linhaok do rateio dos³±±
±±³          ³itens do documento de entrada                                ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeRatLOk()

Local nPPerc    := aScan(aHeader,{|x| AllTrim(x[2]) == "DE_PERC"} )
Local nPCC	    := aScan(aHeader,{|x| AllTrim(x[2]) == "DE_CC"} )
Local nPConta	:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_CONTA"} )
Local nPItemCta := aScan(aHeader,{|x| AllTrim(x[2]) == "DE_ITEMCTA"} )
Local nPCLVL	:= Ascan(aHeader,{|x| AllTrim(x[2]) == "DE_CLVL"} )

Local nEc05Db	:= Ascan(aHeader,{|x| AllTrim(x[2]) == "DE_EC05DB"} )
Local nEc06Db	:= Ascan(aHeader,{|x| AllTrim(x[2]) == "DE_EC06DB"} )
Local nEc07Db	:= Ascan(aHeader,{|x| AllTrim(x[2]) == "DE_EC07DB"} )
Local nEc08Db	:= Ascan(aHeader,{|x| AllTrim(x[2]) == "DE_EC08DB"} )
Local nEc09Db	:= Ascan(aHeader,{|x| AllTrim(x[2]) == "DE_EC09DB"} )
Local nPosEC05CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC05CR"})
Local nPosEC06CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC06CR"}) 
Local nPosEC07CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC07CR"})
Local nPosEC08CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC08CR"})
Local nPosEC09CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC09CR"}) 
Local aEntid  := {}
Local aEntid2 := {}

Local lRetorno  := .T.       
Local lMt103LOk := Existblock("MT103LOK")
Local nX        := 0  
Local nAscan	:= 0
Local lDAmarCt	:= SuperGetMV( "MV_DAMARCT",.F.,.F. )
Local lRatDupl	:= GetNewPar("MV_RATDUPL",.F.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se valida ou nao o aCols a partir das validacoes do aHeader ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Iif( nPConta	> 0, aAdd(aEntid, aCols[n,nPConta])	 , aAdd(aEntid, " ") )
Iif( nPCC		> 0, aAdd(aEntid, aCols[n,nPCC])	 , aAdd(aEntid, " ") )
Iif( nPItemCta	> 0, aAdd(aEntid, aCols[n,nPItemCta]), aAdd(aEntid, " ") )
Iif( nPClVl		> 0, aAdd(aEntid, aCols[n,nPClVl])	 , aAdd(aEntid, " ") )
Iif( nEc05Db	> 0, aAdd(aEntid, aCols[n,nEc05Db])	 , aAdd(aEntid, " ") )
Iif( nEc06Db	> 0, aAdd(aEntid, aCols[n,nEc06Db])	 , aAdd(aEntid, " ") )
Iif( nEc07Db	> 0, aAdd(aEntid, aCols[n,nEc07Db])	 , aAdd(aEntid, " ") )
Iif( nEc08Db	> 0, aAdd(aEntid, aCols[n,nEc08Db])	 , aAdd(aEntid, " ") )
Iif( nEc09Db	> 0, aAdd(aEntid, aCols[n,nEc09Db])	 , aAdd(aEntid, " ") )

Iif( nPConta	> 0, aAdd(aEntid2, aCols[n,nPConta])   , aAdd(aEntid2, " ") )
Iif( nPCC		> 0, aAdd(aEntid2, aCols[n,nPCC])	   , aAdd(aEntid2, " ") )
Iif( nPItemCta	> 0, aAdd(aEntid2, aCols[n,nPItemCta]) , aAdd(aEntid2, " ") )
Iif( nPClVl		> 0, aAdd(aEntid2, aCols[n,nPClVl])    , aAdd(aEntid2, " ") )
Iif( nPosEC05CR > 0, aAdd(aEntid2, aCols[n,nPosEC05CR]), aAdd(aEntid2, " ") )
Iif( nPosEC06CR > 0, aAdd(aEntid2, aCols[n,nPosEC06CR]), aAdd(aEntid2, " ") )
Iif( nPosEC07CR > 0, aAdd(aEntid2, aCols[n,nPosEC07CR]), aAdd(aEntid2, " ") )
Iif( nPosEC08CR > 0, aAdd(aEntid2, aCols[n,nPosEC08CR]), aAdd(aEntid2, " ") )
Iif( nPosEC09CR > 0, aAdd(aEntid2, aCols[n,nPosEC09CR]), aAdd(aEntid2, " ") )

If lMt103Lok
	lRetorno := Execblock("MT103LOK",.F.,.F.)
Endif   

If lRetorno .And. !lRatDupl
	If nEc05Db = 0
		nAscan := Ascan( aCols, { |e| 	e[nPCC] == aCols[n][nPCC] .And. e[nPConta] == aCols[n][nPConta] .And. e[nPItemCta] == aCols[n][nPItemCta] .And.;
												 	e[nPCLVL] == aCols[n][nPCLVL] .And. !e[len(e)] } )
	Elseif nEc09Db > 0
		nAscan := Ascan( aCols, { |e| 	e[nPCC] == aCols[n][nPCC] .And. e[nPConta] == aCols[n][nPConta] .And. e[nPItemCta] == aCols[n][nPItemCta] .And.;
												 	e[nPCLVL] == aCols[n][nPCLVL] .And. !e[len(e)] .And. ;
												 	e[nEc09Db] == aCols[n][nEc09Db] .And. e[nEc08Db] == aCols[n][nEc08Db] .And. e[nEc07Db] == aCols[n][nEc07Db] .And. ;
												 	e[nEc06Db] == aCols[n][nEc06Db] .And. e[nEc05Db] == aCols[n][nEc05Db]} )
	Elseif nEc08Db > 0
		nAscan := Ascan( aCols, { |e| 	e[nPCC] == aCols[n][nPCC] .And. e[nPConta] == aCols[n][nPConta] .And. e[nPItemCta] == aCols[n][nPItemCta] .And.;
												 	e[nPCLVL] == aCols[n][nPCLVL] .And. !e[len(e)] .And. ;
												 	e[nEc08Db] == aCols[n][nEc08Db] .And. e[nEc07Db] == aCols[n][nEc07Db] .And. ;
												 	e[nEc06Db] == aCols[n][nEc06Db] .And. e[nEc05Db] == aCols[n][nEc05Db]} )
	Elseif nEc07Db > 0
		nAscan := Ascan( aCols, { |e| 	e[nPCC] == aCols[n][nPCC] .And. e[nPConta] == aCols[n][nPConta] .And. e[nPItemCta] == aCols[n][nPItemCta] .And.;
												 	e[nPCLVL] == aCols[n][nPCLVL] .And. !e[len(e)] .And. ;
												 	e[nEc07Db] == aCols[n][nEc07Db] .And. ;
												 	e[nEc06Db] == aCols[n][nEc06Db] .And. e[nEc05Db] == aCols[n][nEc05Db]} )
	Elseif nEc06Db > 0
		nAscan := Ascan( aCols, { |e| 	e[nPCC] == aCols[n][nPCC] .And. e[nPConta] == aCols[n][nPConta] .And. e[nPItemCta] == aCols[n][nPItemCta] .And.;
												 	e[nPCLVL] == aCols[n][nPCLVL] .And. !e[len(e)] .And. ;
												 	e[nEc06Db] == aCols[n][nEc06Db] .And. e[nEc05Db] == aCols[n][nEc05Db]} )
	Elseif nEc05Db > 0
		nAscan := Ascan( aCols, { |e| 	e[nPCC] == aCols[n][nPCC] .And. e[nPConta] == aCols[n][nPConta] .And. e[nPItemCta] == aCols[n][nPItemCta] .And.;
												 	e[nPCLVL] == aCols[n][nPCLVL] .And. !e[len(e)] .And. ;
												 	e[nEc05Db] == aCols[n][nEc05Db]} )
	Endif
	
	If nAscan > 0 .And. n != nAscan
		Help(" ",1,"CCEXIST")// Centro de Custo ja Cadastrado
		lRetorno := .F.	
	Endif                                    
Endif

If !aCols[N][Len(aCols[N])]
	If aCols[N][nPPerc] == 0
		Help(" ",1,"A103PERC")
		lRetorno := .F.
	EndIf
EndIf

//Consiste amarração da Conta Contábil X Centro de Custo
If lRetorno .And. !lDAmarCt
	If nPConta <> 0 .And. nPCC>0 .And. nPItemCta <> 0 .And. nPClVl <> 0 .And.;
 	   (!CtbAmarra(aCols[n,nPConta],aCols[n,nPCC],aCols[n,nPItemCta],aCols[n,nPClVl],/*lPosiciona*/,/*lHelp*/,/*lValidLinOk*/,aEntid) .Or.;
		!CtbAmarra(aCols[n,nPConta],aCols[n,nPCC],aCols[n,nPItemCta],aCols[n,nPClVl],/*lPosiciona*/,/*lHelp*/,/*lValidLinOk*/,aEntid2))
	   lRetorno:=.F.
	EndIf
EndIf

If lRetorno .And. empty(aCols[N][nPCC]) // O Centro de Custo SEMPRE devera ser obrigatorio, Conta Contabil, Item Contabil e Classe Valor nao tem esta necessidade
	Help('   ',1,'A103RATEI')
	lRetorno:=.F.	
EndIf

If lRetorno .And. CTT->CTT_BLOQ == "1"
	Help('   ',1,"CTA_BLOQ")
	lRetorno:=.F.
Endif

If lRetorno
	nPercRat := 0
	nPercARat:= 0
	For nX	:= 1 To Len(aCols)
		If !aCols[nX][Len(aCols[nX])]
			nPercRat += aCols[nX][nPPerc]
		EndIf
	Next
	nPercARat := 100 - nPercRat
	If Type("oPercRat")=="O"
		oPercRat:Refresh()
		oPercARat:Refresh()
	Endif
EndIf  

If lRetorno
	Do Case
	Case cTipo == "B"
		lRetorno :=	PcoVldLan("000054","11","MATA103",/*lUsaLote*/,/*lDeleta*/, .T./*lVldLinGrade*/)
	Case cTipo == "D"
		lRetorno :=	PcoVldLan("000054","10","MATA103",/*lUsaLote*/,/*lDeleta*/, .T./*lVldLinGrade*/)
	OtherWise
		lRetorno :=	PcoVldLan("000054","09","MATA103",/*lUsaLote*/,/*lDeleta*/, .T./*lVldLinGrade*/)
	EndCase
Endif

Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeRatTok ³ Autor ³ Eduardo Riera         ³ Data ³15.10.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Validacao da TudoOk dos itens do rateio dos itens do documen-³±±
±±³          ³to de entrada                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se a todas as linhas estao validas             ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar a tudook do rateio dos ³±±
±±³          ³itens do documento de entrada                                ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeRatTok(aHeadSDE,aColsSDE,nLinDoc,lReplica)

Local nPPerc     	:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_PERC"})
Local nPCC	     	:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_CC"})
Local nPConta	 	:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_CONTA"})
Local nPItemCta  	:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_ITEMCTA"})
Local nPCLVL	 	:= Ascan(aHeader,{|x| AllTrim(x[2]) == "DE_CLVL"})
Local nPosEC05DB 	:= aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC05DB"}) 
Local nPosEC05CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC05CR"})
Local nPosEC06DB    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC06DB"}) 
Local nPosEC06CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC06CR"})
Local nPosEC07DB    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC07DB"}) 
Local nPosEC07CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC07CR"})
Local nPosEC08DB    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC08DB"}) 
Local nPosEC08CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC08CR"})
Local nPosEC09DB    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC09DB"}) 
Local nPosEC09CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC09CR"}) 
Local aEntid	 	:= {}
Local aEntid2	 	:= {}  

Local nTotal   := 0   
Local nX       := 0 
Local nK	   := 0
Local lRetorno := .T.
Local lMt103ROk := Existblock("MT103ROK")
Local n_SaveLin 
Local lDAmarCt	:= SuperGetMV( "MV_DAMARCT",.F.,.F. )
Local aBkpHead := {}
Local aBkpCols := {}
Local aEntCtb  := CtbEntArr()
Local cVarAuxDB:= ""
Local cVarAuxCR:= ""
Local cCmpAuxDB:= ""
Local cCmpAuxCR:= ""


Default aHeadSDE := {}
Default aColsSDE := {}
Default nLinDoc  := 0
Default lReplica := .F.

If Type("l103Class") <> "L"
	l103Class := .F.
Endif

If lMt103Rok .And. !lReplica
	lRetorno := Execblock("MT103ROK",.F.,.F.)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se valida ou nao o aCols a partir das validacoes do aHeader ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Iif( nPConta	> 0, aAdd(aEntid, aCols[n,nPConta])	  , aAdd(aEntid, " ") )
Iif( nPCC		> 0, aAdd(aEntid, aCols[n,nPCC])	  , aAdd(aEntid, " ") )
Iif( nPItemCta	> 0, aAdd(aEntid, aCols[n,nPItemCta]) , aAdd(aEntid, " ") )
Iif( nPClVl		> 0, aAdd(aEntid, aCols[n,nPClVl])	  , aAdd(aEntid, " ") )
Iif( nPosEC05DB > 0, aAdd(aEntid, aCols[n,nPosEC05DB]), aAdd(aEntid, " ") )
Iif( nPosEC06DB > 0, aAdd(aEntid, aCols[n,nPosEC06DB]), aAdd(aEntid, " ") )
Iif( nPosEC07DB > 0, aAdd(aEntid, aCols[n,nPosEC07DB]), aAdd(aEntid, " ") )
Iif( nPosEC08DB > 0, aAdd(aEntid, aCols[n,nPosEC08DB]), aAdd(aEntid, " ") )
Iif( nPosEC09DB > 0, aAdd(aEntid, aCols[n,nPosEC09DB]), aAdd(aEntid, " ") )

Iif( nPConta	> 0, aAdd(aEntid2, aCols[n,nPConta])   , aAdd(aEntid2, " ") )
Iif( nPCC		> 0, aAdd(aEntid2, aCols[n,nPCC])      , aAdd(aEntid2, " ") )
Iif( nPItemCta	> 0, aAdd(aEntid2, aCols[n,nPItemCta]) , aAdd(aEntid2, " ") )
Iif( nPClVl		> 0, aAdd(aEntid2, aCols[n,nPClVl])	   , aAdd(aEntid2, " ") )
Iif( nPosEC05CR > 0, aAdd(aEntid2, aCols[n,nPosEC05CR]), aAdd(aEntid2, " ") )
Iif( nPosEC06CR > 0, aAdd(aEntid2, aCols[n,nPosEC06CR]), aAdd(aEntid2, " ") )
Iif( nPosEC07CR > 0, aAdd(aEntid2, aCols[n,nPosEC07CR]), aAdd(aEntid2, " ") )
Iif( nPosEC08CR > 0, aAdd(aEntid2, aCols[n,nPosEC08CR]), aAdd(aEntid2, " ") )
Iif( nPosEC09CR > 0, aAdd(aEntid2, aCols[n,nPosEC09CR]), aAdd(aEntid2, " ") )

If !lReplica
	For nX	:= 1 To Len(aCols)
		If !aCols[nX][Len(aCols[nX])]
			If !lDAmarCt
				//Consiste amarração da Conta Contábil X Centro de Custo
				If (!CtbAmarra(aCols[n,nPConta],aCols[n,nPCC],aCols[n,nPItemCta],aCols[n,nPClVl],/*lPosiciona*/,/*lHelp*/,/*lValidLinOk*/,aEntid) .Or.;
					!CtbAmarra(aCols[n,nPConta],aCols[n,nPCC],aCols[n,nPItemCta],aCols[n,nPClVl],/*lPosiciona*/,/*lHelp*/,/*lValidLinOk*/,aEntid2))
					lRetorno:=.F.
					Aviso("NfeRatTok",STR0120+" "+aCols[nX,1],{"Ok"})
					Exit 
				EndIf
			Endif 
			nTotal := nTotal + aCols[nX][nPPerc]
		
			//-- Verifica se existe alguma Entidade Contábil bloqueada.
			If lRetorno .And. (l103Class .Or. INCLUI) 
				
				//-- Centro de Custo
				If nPCC > 0 .And. !Empty(aCols[nX,nPCC]) .And. !ValidaBloq(aCols[nX,nPCC], dDataBase, "CTT")		
					lRetorno:= .F.
					Exit
				EndI
				//-- Conta Contábil
				If nPConta > 0 .And. !Empty(aCols[nX,nPConta]) .And. !ValidaBloq(aCols[nX,nPConta], dDataBase, "CT1")		
					lRetorno:= .F.
					Exit
				EndIf
				//-- Item Contábil
				If nPItemCta > 0 .And. !Empty(aCols[nX,nPItemCta]) .And. !ValidaBloq(aCols[nX,nPItemCta], dDataBase, "CTD")		
					lRetorno:= .F.
					Exit
				EndIf
				//-- Classe de Valor
				If nPClVl > 0 .And. !Empty(aCols[nX,nPClVl]) .And. !ValidaBloq(aCols[nX,nPClVl], dDataBase, "CTH")		
					lRetorno:= .F.
					Exit
				EndI
				For nK := 1 To Len(aEntCtb)
					//-- Entidade Contabil Adicional DB
					cVarAuxDB := "nPosEC" + aEntCtb[nK] + "DB"
					cCmpAuxDB := "DE_EC" + aEntCtb[nK] + "DB"
					If &(cVarAuxDB) > 0 .And. !Empty(aCols[nX,&(cVarAuxDB)]) .And. !ValidaBloq(aCols[nX,&(cVarAuxDB)], dDataBase, "CV0",,, aEntCtb[nK])
						lRetorno := .F.
						Exit
					EndI
					//-- Entidade Contabil Adicional CR
					cVarAuxCR := "nPosEC" + aEntCtb[nK] + "CR"
					cCmpAuxCR := "DE_EC" + aEntCtb[nK] + "CR"
					If &(cVarAuxCR) > 0 .And. !Empty(aCols[nX,&(cVarAuxCR)]) .And. !ValidaBloq(aCols[nX,&(cVarAuxCR)], dDataBase, "CV0",,, aEntCtb[nK])
						lRetorno := .F.
						Exit
					EndI
				Next nK

				If !lRetorno
					Exit
				EndIf
			Endif
		EndIf

	Next
EndIf

If lRetorno .And. nTotal > 0 .And. nTotal <> 100 .And. !lReplica 
	Help(" ",1,"A103TOTRAT")
	lRetorno := .F.
EndIf  

// Executa validacao de bloqueio no SIGAPCO para todos os itens do documento
// quando for selecionada opcao para replicar rateio para os demais itens
If lReplica
	aBkpHead := aHeader
	aBkpCols := aCols
	aHeader  := aHeadSDE
	aCols    := aColsSDE
	nOrigN   := nLinDoc
EndIf

If lRetorno
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se ha bloqueio em algum item do pco qdo valida for por grade ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PcoBlqFim({{"000054","09"},{"000054","10"},{"000054","11"}}) .Or. lReplica
		n_SaveLin := n
		For nx:=1 to len(aCols)
			If !aCols[nx][Len(aCols[nx])]
			    n := nX
				If lRetorno
					Do Case
					Case cTipo == "B"
						lRetorno	:=	PcoVldLan("000054","11","MATA103",/*lUsaLote*/,/*lDeleta*/, .F./*lVldLinGrade*/)
					Case cTipo == "D"
						lRetorno	:=	PcoVldLan("000054","10","MATA103",/*lUsaLote*/,/*lDeleta*/, .F./*lVldLinGrade*/)
					OtherWise
						lRetorno	:=	PcoVldLan("000054","09","MATA103",/*lUsaLote*/,/*lDeleta*/, .F./*lVldLinGrade*/)
					EndCase
	            Endif
	            If !lRetorno
	            	Exit
	            EndIf	
			EndIf
		Next
		n := n_SaveLin
    EndIf
EndIf

// Retorna aHeader e Acols ao estado original
If lReplica
	aHeader := aBkpHead
	aCols   := aBkpCols
EndIf

Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeViewPrd³ Autor ³ Eduardo Riera         ³ Data ³17.12.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Visualizacao da consulta ao historico de compras             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo executar a visualizacao do his-³±±
±±³          ³torico de compra do produto da linha da getdados             ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeViewPrd()

Local nPosCod	:= GetPosSD1("D1_COD")

If nPosCod <> 0
	MaFisSave()
	MaFisEnd()
	If !AtIsRotina("MACOMVIEW")
		If !Empty(aCols[n][nPosCod])
			MaComView(aCols[n][nPosCod])
		EndIf
	EndIf
	MaFisRestore()
EndIf
Return
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeTotFin ³ Autor ³ Eduardo Riera         ³ Data ³18.07.2003 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Totalizacao do array financeiro                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: aHeader do array de duplicatas                        ³±±
±±³          ³ExpA2: aCols do array de duplicatas                          ³±±
±±³          ³ExpL3: Habilita o Help (DEFAULT .T.)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: O Documento de entrada esta coerente com as parcelas  ³±±
±±³          ³       financeiras                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo verificar se o somatorio das   ³±±
±±³          ³parcelas eh total de duplicatas do documento de Entrada      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeTotFin(aHeader,aCols,lHelp,lRecalc,nColsSE2,aColTrbGen)

Local aArea    := GetArea()
Local lRetorno := .T.
Local nTotDup  := 0
Local nIRRF    := 0
Local nISS     := 0
Local nINSS    := 0
Local nPIS     := 0
Local nCOFINS  := 0
Local nCSLL    := 0
Local nFethab  := 0 
Local nFabov   := 0 
Local nFacs    := 0
Local nIMA	   := 0
Local nFAMAD   := 0 
Local nPValor  := aScan(aHeader,{|x| AllTrim(x[2])=="E2_VALOR"})
Local nPIRRF   := aScan(aHeader,{|x| AllTrim(x[2])=="E2_IRRF"})
Local nPISS    := aScan(aHeader,{|x| AllTrim(x[2])=="E2_ISS"})
Local nPINSS   := aScan(aHeader,{|x| AllTrim(x[2])=="E2_INSS"})
Local nPPIS    := aScan(aHeader,{|x| AllTrim(x[2])=="E2_PIS"})
Local nPCOFINS := aScan(aHeader,{|x| AllTrim(x[2])=="E2_COFINS"})
Local nPCSLL   := aScan(aHeader,{|x| AllTrim(x[2])=="E2_CSLL"})
Local nPFETHAB := aScan(aHeader,{|x| AllTrim(x[2])=="E2_FETHAB"})
Local nPFABOV  := aScan(aHeader,{|x| AllTrim(x[2])=="E2_FABOV"})
Local nPFACS   := aScan(aHeader,{|x| AllTrim(x[2])=="E2_FACS"})
Local nPIMA    := aScan(aHeader,{|x| AllTrim(x[2])=="E2_IMA"})
Local nPFAMAD  := aScan(aHeader,{|x| AllTrim(x[2])=="E2_FAMAD"})
Local nX       := 0 
Local lISSNat  := .T.
Local cNatNF   := ""
Local lISSTes	:= SuperGetMv("MV_ISSRETD",.F.,.F.)
Local cINSSAd	:= "0"
Local nLIMPAG	:= SuperGetMV("MV_LIMPAG")
Local lMT103FIN	:= ExistBlock("MT103FIN")
Local aTribGen := {}
Local lTrbGen  := IIf(FindFunction("ChkTrbGen"),ChkTrbGen("SD1", "D1_IDTRIB"),.F.) .And. FindFunction("FinGrvFK7") .And. FindFunction("FINCalImp") .And. FindFunction("A103TrbGen") .And. FindFunction("A103AtuTrG") // Verifica se o sistema esta preparado para utilizar o motor de tributos genericos
Local nY       := 0
Local nTribGen := 0
Local nTotTrbGen:= 0
Local nPosValTrb:= 0

If Type("aBaseDup")=="U" .Or. aBaseDup==Nil
	aBaseDup := {0,0}
EndIf

DEFAULT lHelp      := .T.
DEFAULT lRecalc    := .T.
DEFAULT nColsSE2   := 0
DEFAULT aColTrbGen := {}

//Verifica se deve existir o calculo do ISS pela natureza do titulo
If MaFisFound("NF")
	cNatNF := MaFisRet(,"NF_NATUREZA")
	dbSelectArea("SED")
	If SED->(dbSeek(xFilial("SED")+cNatNF))
		lISSNat := SED->ED_CALCISS <> "N" .Or. lISSTes
	Endif            
EndIf

cINSSAd	:=	MaFisScan("NF_VALINA",.F.)

If MaFisFound("NF")
	If lTrbGen .And. !Empty(cNatNF)
		aTribGen := MaFisRet(,"NF_TRIBGEN")	// Retorna os valores calculados pelo motor	
		If Len(aTribGen) > 0 .And. Len(aColTrbGen) > 0	// Armazena no array aColTrbGen as colunas que serao exibidas na aba Duplicatas referentes ao motor de tributos genericos
			For nY := 1 To Len(aTribGen)
				If aScan(aColTrbGen,{|x| AllTrim(x[1]) == AllTrim(aTribGen[nY][1])}) > 0	// Verifica se o tributo e exibido nas Duplicatas pois nem todos os tributos calculados na nota sao passiveis de retencao
					nTotTrbGen += aTribGen[nY][3]	// Guarda o valor total de tributos genericos passiveis de rentecao
				EndIf
			Next nY
		EndIf
	EndIf
EndIf

//Verifica o valor total das duplicatas com o total da NFE
If (INCLUI .Or. ALTERA) .And. lRetorno .And. !Empty(cCondicao) .And. cTipo <> "D" .And. MaFisFound("NF")
	dbSelectArea("SE4")
	dbSetOrder(1)
	MsSeek(xFilial("SE4")+cCondicao)
	If SE4->E4_TIPO <> "A"
		For nX := 1 To Len(aCols)
			nTotDup += aCols[nX][nPValor]
			If nPIRRF > 0
				nIRRF += aCols[nX][nPIRRF]
			EndIf
			If nPISS > 0
				nISS += aCols[nX][nPISS]
			EndIf
			If nPINSS > 0
				nINSS += aCols[nX][nPINSS]
			EndIf
			If nPPIS > 0
				nPIS += aCols[nX][nPPIS]
			EndIf                       	
			If nPCOFINS > 0
				nCOFINS += aCols[nX][nPCOFINS]
			EndIf
			If nPCSLL> 0
				nCSLL += aCols[nX][nPCSLL]
			EndIf
			If nPFETHAB > 0
				nFETHAB += aCols[nX][nPFETHAB]
			EndIf 
			If nPFABOV > 0
				nFABOV += aCols[nX][nPFABOV]
			EndIf 
			If nPFACS > 0
				nFACS += aCols[nX][nPFACS]
			EndIf
			If nPIMA > 0
				nIMA += aCols[nX][nPIMA]
			EndIf
			If nPFAMAD > 0
				nFAMAD += aCols[nX][nPFAMAD]
			EndIf
			If lTrbGen .And. !Empty(cNatNF)
				For nY := 1 To Len(aTribGen)
					If (nPosValTrb := aScan(aColTrbGen,{|x| x[1] == aTribGen[nY][1]}) ) > 0	// Encontra a coluna da duplicata referente ao tributo generico
						nTribGen += aCols[nX][nColsSE2+nPosValTrb]
					EndIf
				Next nY
			EndIf

			If nPValor > 0 .And. nPIRRF > 0 .And. nPISS > 0 .And. nPCOFINS > 0 .And. nPCSLL > 0 .And. nPPIS > 0 .And. nPINSS > 0
				If xMoeda(nTotDup,nMoedaCor,1,dDEmissao,Nil,MaFisRet(,"NF_TXMOEDA")) > 0 .And. (aCols[nX][nPIRRF]+aCols[nX][nPISS]+aCols[nX][nPINSS]+aCols[nX][nPPIS]+aCols[nX][nPCOFINS]+aCols[nX][nPCSLL]+IIf(nPFETHAB>0,aCols[nX][nPFETHAB],0)+IIf(nPFACS>0,aCols[nX][nPFACS],0)+IIf(nPFABOV>0,aCols[nX][nPFABOV],0)+IIf(nPIMA>0,aCols[nX][nPIMA],0)+IIf(nPFAMAD>0,aCols[nX][nPFAMAD],0) + nTribGen) > (xMoeda(nTotDup,nMoedaCor,1,dDEmissao,Nil,MaFisRet(,"NF_TXMOEDA"))-0.01)
					Help(" ",1,"A100VALP",,,3,0)	//Valor da somatoria dos impostos superior ao valor da parcela.
					lRetorno := .F.
					Exit
				EndIf
			EndIf			
		Next nX
		If nTotDup > 0  .Or. !IsInCallStack("MATA103") //caso contrario o sistema calcula o valor automaticamente
			If Abs(xMoeda(MaFisRet(,"NF_BASEDUP")+aBaseDup[2],1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nTotDup) > nLIMPAG
				If lHelp .Or. ExistBlock("MT103DUP")
					Help(" ",1,"A100VALDUP",,SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(MaFisRet(,"NF_BASEDUP"),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nTotDup)),3,0)
				EndIf  
				lRetorno := .F.
			ElseIf  Abs(MaFisRet(,"NF_BASEDUP")-NoRound(xMoeda(nTotDup,nMoedaCor,1,dDEmissao,Nil,MaFisRet(,"NF_TXMOEDA")),2))>0.01
					aBaseDup := {MaFisRet(,"NF_BASEDUP"),0}
				If nMoedaCor<=1
					MaFisAlt("NF_BASEDUP",NoRound(xMoeda(nTotDup,nMoedaCor,1,dDEmissao,Nil,MaFisRet(,"NF_TXMOEDA")),2))
				EndIf
				aBaseDup[2] := aBaseDup[1]-MaFisRet(,"NF_BASEDUP")
			EndIf
			
			If nPIRRF > 0
				If Abs(QtdComp(nIRRF) - qtdcomp(MaFisRet(,"NF_VALIRR")))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"IRF "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(MaFisRet(,"NF_VALIRR"),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nIRRF)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPISS > 0
				If Abs(QtdComp(nISS) - IIf(MaFisRet(,"NF_RECISS")=="2".And.lISSNat,QtdComp(MaFisRet(,"NF_VALISS")),0))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"ISS "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(IIf(MaFisRet(,"NF_RECISS")=="2".And.lISSNat,MaFisRet(,"NF_VALISS"),0),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nISS)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPINSS > 0
				If Abs(QtdComp(nINSS)- (QtdComp(MaFisRet(,"NF_VALINS"))+Iif(cINSSAd<>"0",QtdComp(MaFisRet(,"NF_VALINA")),0)))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"INSS "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(MaFisRet(,"NF_VALINS")+Iif(cINSSAd<>"0",MaFisRet(,"NF_VALINA"),0),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nINSS)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPPIS > 0
				If Abs(QtdComp(nPIS) - QtdComp(MaFisRet(,"NF_VALPIS")))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"PIS "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(MaFisRet(,"NF_VALPIS"),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nPIS)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPCOFINS > 0
				If Abs(QtdComp(nCOFINS) - QtdComp(MaFisRet(,"NF_VALCOF")))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"COFINS "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(MaFisRet(,"NF_VALCOF"),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nCOFINS)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPCSLL > 0
				If NoRound(Abs(QtdComp(nCSLL) - QtdComp(MaFisRet(,"NF_VALCSL"))),2)>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"CSLL "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(MaFisRet(,"NF_VALCSL"),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nCSLL)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPFETHAB > 0
				If Abs(nFETHAB - IIf(MaFisRet(,"NF_RECFET")=="2",MaFisRet(,"NF_VALFET"),0))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"FETHAB "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(IIf(MaFisRet(,"NF_RECFET")=="2",MaFisRet(,"NF_VALFET"),0),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nFETHAB)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPFACS > 0
				If Abs(nFACS - IIf(MaFisRet(,"NF_RECFAC")=="2",MaFisRet(,"NF_VALFAC"),0))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"FACS "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(IIf(MaFisRet(,"NF_RECFAC")=="2",MaFisRet(,"NF_VALFAC"),0),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nFACS)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPFABOV > 0
				If Abs(nFabov - IIf(MaFisRet(,"NF_RECFAB")=="2",MaFisRet(,"NF_VALFAB"),0))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"FABOV "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(IIf(MaFisRet(,"NF_RECFAB")=="2",MaFisRet(,"NF_VALFAB"),0),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nFabov)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPIMA > 0
				If Abs(nIMA - IIf(MaFisRet(,"NF_RECIMA")=="2",MaFisRet(,"NF_VALIMA"),0))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"IMA "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(IIf(MaFisRet(,"NF_RECIMA")=="2",MaFisRet(,"NF_VALIMA"),0),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nIMA)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPFAMAD > 0
				If Abs(nFAMAD - IIf(MaFisRet(,"NF_RECFMD")=="2",MaFisRet(,"NF_VALFMD"),0))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"FAMAD "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(IIf(MaFisRet(,"NF_RECFMD")=="2",MaFisRet(,"NF_VALFMD"),0),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nFAMAD)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If lTrbGen .And. !Empty(cNatNF)
				If Abs(nTribGen - nTotTrbGen) > 0
					If lHelp
						Help(" ",1,"A100VALDUP",,SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((nTotTrbGen - nTribGen))+STR0209,3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf

			If lRetorno .And. nPIRRF*nPISS*nPINSS*nPPIS*nPCOFINS*nPCSLL*IIf(Empty(nPFETHAB),1,nPFETHAB)*IIf(Empty(nPFABOV),1,nPFABOV)*IIf(Empty(nPFACS),1,nPFACS)*IIf(Empty(nPIMA),1,nPIMA)*IIf(Empty(nPFAMAD),1,nPFAMAD) > 0
				If Abs(nIRRF+nINSS+nISS+nPIS+nCOFINS+nCSLL+nFETHAB+nFabov+nFacs+nIMA+nFAMAD)>xMoeda(nTotDup,nMoedaCor,1,dDEmissao,Nil,MaFisRet(,"NF_TXMOEDA"))
					If lHelp
						Help(" ",1,"A100VALDUP",,"IRRF/ISS/INSS/PIS/COFINS/CSLL"+IIf(nPFETHAB>0,"/FETHAB","")+IIf(nPFABOV>0,"/FABOV","")+IIf(nPFACS>0,"/FACS","")+IIf(nPIMA>0,"/IMA","")+IIf(nPFAMAD>0,"/FAMAD",""),3,0)
					EndIf
		    		lRetorno := .F.
				EndIf		
			Else
			If lRetorno .And. nPIRRF*nPISS*nPINSS>0
				If Abs(nIRRF+nINSS+nISS)>xMoeda(nTotDup,nMoedaCor,1,dDEmissao,Nil,MaFisRet(,"NF_TXMOEDA"))
					If lHelp
						Help(" ",1,"A100VALDUP",,"IRRF/ISS/INSS",3,0)
					EndIf
					lRetorno := .F.
				EndIf		
			EndIf
		EndIf
	EndIf
	EndIf
    //Pontos de Entrada
	If lMT103FIN
		lRetorno := ExecBlock("MT103FIN",.F.,.F.,{aHeader,aCols,lRetorno})	
	EndIf
EndIf

If !lRetorno
	lRecalc := .F.
EndIf

RestArea(aArea)
Return(lRetorno)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103CalcRt³ Autor ³ Sergio Silveira       ³ Data ³17/08/2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Totalizacao do array financeiro                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: aHeader do array de duplicatas                        ³±±
±±³          ³ExpA2: aCols do array de duplicatas                          ³±±
±±³          ³ExpL3: Habilita o Help (DEFAULT .T.)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: O Documento de entrada esta coerente com as parcelas  ³±±
±±³          ³       financeiras                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo verificar se o somatorio das   ³±±
±±³          ³parcelas eh total de duplicatas do documento de Entrada      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function A103CalcRt(aColsSE2,aHeadSE2,cModRetPIS,lPccBaixa)
                                  
Local aListBox := {}
Local cAnoMes    := ""   
Local cAcessRad  := GetNewPar( "MV_AC10925", "1" ) 
Local nRadio     := Val( cModRetPIS ) 
Local nOpca      := 0 
Local nPosVenc   := GdFieldPos( "E2_VENCTO", aHeadSE2 )  
Local nLoop      := 0 
Local nTamAnoMes := 0                                
Local nPPIS      := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_PIS"})
Local nPCOFINS   := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_COFINS"})
Local nPCSLL     := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_CSLL"})
Local lProcessa  := .F.
Local oOk        := LoadBitmap( GetResources(), "LBOK" )
Local oNOk       := LoadBitmap( GetResources(), "LBNO" )
Local oDlgRet  
Local oList           
Local oRadio         
Local oBold 
Local oBmp        
Local oBut1
Local oBut2
Local lMT103RET := ExistBlock( "MT103RET" )

//Obtem os valores por ano/mes para as parcelas desta nota  
For nLoop := 1 to Len( aColsSE2 ) 

	If aColsSE2[ nLoop, nPPIS ] > 0 .Or. aColsSE2[ nLoop, nPCOFINS ] > 0 .Or. aColsSE2[ nLoop, nPCSLL ] > 0 

		lProcessa := .T.

		nTamAnoMes := Len( DToC( aColsSE2[ nLoop, nPosVenc ] ) ) - 3 
		cAnoMes := DToS( aColsSE2[ nLoop, nPosVenc ] )

		If Empty( nScanMes := AScan( aListBox, { |x| Left( x[2], 6 ) == Left( cAnoMes, 6 ) } ) )	
			AAdd( aListBox, { .T., cAnoMes } ) 
		EndIf 
		
	Endif
Next nLoop     

If lProcessa

	ASort( aListBox, , , { |x,y| y[2] > x[2] } )   
	
	//Converte os valores para exibicao em tela  
	AEval( aListBox, { |x| x[2] := Right( DToC( SToD( x[2] ) ), nTamAnoMes ) } ) 
	
	DEFINE MSDIALOG oDlgRet TITLE STR0031 FROM 09,0 TO 33.8,60 OF oMainWnd // "Calculo de retencao" 
	
	DEFINE FONT oBold NAME "Arial" SIZE 0, -13 BOLD
	
	@  0, -25 BITMAP oBmp RESNAME "PROJETOAP" oF oDlgRet SIZE 55, 1000 NOBORDER WHEN .F. PIXEL
	
	@ 03, 40 SAY STR0032 FONT oBold PIXEL // "Modalidade de retencao do PIS/COFINS/CSLL"
	
	@ 14, 30 TO 16 ,400 LABEL '' OF oDlgRet   PIXEL
	
	@ 25, 40 RADIO oRadio VAR nRadio 3D SIZE 70, 11 PROMPT STR0033,STR0034,STR0035 of oDlgRet PIXEL // "Calculado pelo sistema","Efetua retencao", "Nao efetua retencao"
	
	oRadio:SetEnable( cAcessRad == "1" .And. !lPccBaixa )	
	oList := TWBrowse():New( 65, 40, 190, 96,,{ STR0036, STR0037 },,oDlgRet,,,,,,,,,,,,.F.,,.T.,,.F.,,,) // "Retencao", "Mes / Ano"
	
	oList:SetArray(aListBox)
	oList:bLine := { || { If( aListBox[oList:nAT,1], oOk, oNOK ), aListBox[oList:nAT,2] } } 
		                                                                                        
	DEFINE SBUTTON oBut1 FROM 168, 169 TYPE 1 ACTION ( nOpca := 1, oDlgRet:End() )  ENABLE of oDlgRet		 
	DEFINE SBUTTON oBut2 FROM 168, 202 TYPE 2 ACTION ( nOpca := 0, oDlgRet:End() )  ENABLE of oDlgRet
	
	oRadio:bChange := { || A103Radio( aColsSE2,aHeadSE2,@oList,@aListBox,nRadio ) } 
	Eval( oRadio:bChange ) 
	
	ACTIVATE MSDIALOG oDlgRet CENTERED  
	
	If nOpca == 1 
		cModRetPIS := Str( nRadio, 1 ) 
	EndIf 
	
	// Ponto de Entrada para identificar a opção de retenção marcada pelo usuário no momento de inclusão da nota
	If lMT103RET
		ExecBlock("MT103RET", , ,{nRadio,nOpca}) 
	EndIf

Endif
	
Return( .T. ) 


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103Radio ³ Autor ³ Sergio Silveira       ³ Data ³17/08/2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Controle do radio button                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: aHeader do array de duplicatas                        ³±±
±±³          ³ExpA2: aCols do array de duplicatas                          ³±±
±±³          ³ExpO1: Habilita o Help (DEFAULT .T.)                         ³±±
±±³          ³ExpA3: Habilita o Help (DEFAULT .T.)                         ³±±
±±³          ³ExpN1: Habilita o Help (DEFAULT .T.)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo verificar se o somatorio das   ³±±
±±³          ³parcelas eh total de duplicatas do documento de Entrada      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function A103Radio( aColsSE2,aHeadSE2,oList,aListBox,nRadio )

Do Case 
Case nRadio == 1  
	A103Recal(aColsSE2,aHeadSE2,@oList,@aListBox)
Case nRadio == 2 
	AEval( aListBox, { |x| x[1] := .T. } ) 
	bLine := oList:bLine
	oList:SetArray(aListBox)
	oList:bLine := bLine 
Case nRadio == 3 
	AEval( aListBox, { |x| x[1] := .F. } ) 
	bLine := oList:bLine
	oList:SetArray(aListBox)
	oList:bLine := bLine 
EndCase                                

oList:Refresh() 

Return( .T. ) 

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A103Recal ³ Autor ³Sergio Silveira        ³ Data ³05/08/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Efetua o calculo do valor de titulos financeiros que        ³±±
±±³          ³calcularam a retencao do PIS / COGINS / CSLL e nao          ³±±
±±³          ³criaram os titulos de abatimento                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Logico    - .T. item do pedido sera faturado, .F. nao sera  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpD1 - Data de referencia                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function A103Recal( aColsSE2, aHeadSE2, oList, aList ) 

Local aAreaSE2  := SE2->( GetArea() ) 
Local aDadosMes := {}
Local aStruct   := {} 
Local aCampos   := {}                         
Local aProp     := {}     
Local aFil10925 := {} 

Local cQuery    := ""
Local cAliasQry := "" 
Local cSepNeg   := If("|"$MV_CPNEG,"|",",")
Local cSepProv  := If("|"$MVPROVIS,"|",",")
Local cSepRec   := If("|"$MVPAGANT,"|",",")
Local cAnoMes   := "" 
Local cModTot   := GetNewPar( "MV_MT10925", "1" )
Local cQryFil   := "" 

Local dDataIni  := CToD( "" )
Local dDataFim  := CToD( "" )

Local nLoop     := 0
Local nLoop2    := 0
Local nPosVenc  := GdFieldPos( "E2_VENCTO", aHeadSE2 )  
Local nPosValor := GdFieldPos( "E2_VALOR" , aHeadSE2 )  
Local nMinRet   := GetNewPar( "MV_VL10925", 5000 ) 
Local nScanMes  := 0 
Local nAdic     := 0
Local nValTot   := 0
Local nBasePis  := MaFisRet(,"NF_BASEPIS")
Local nBaseCof  := MaFisRet(,"NF_BASECOF")
Local nBaseCsl  := MaFisRet(,"NF_BASECSL")
Local nProp     := 0
Local nSaldoProp:= 0
Local nPropPis  := 0
Local nPropCof  := 0
Local nPropCsl  := 0  
Local nX        := 0
Local nPPIS     := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_PIS"})
Local nPCOFINS  := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_COFINS"})
Local nPCSLL    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_CSLL"})

//Chamado SDFPWW
Local cAglutFil := SuperGetMV("MV_PCCAGLU",,"1")
Local aAreaSM0  := {}
Local cCGCSM0   := ""
Local cEmpAtu   := ""
Local lMT103FRT := ExistBlock( "MT103FRT" )

//Verifica valor total das duplicatas  
For nX := 1 to Len(aColsSE2)
	nValTot += aColsSE2[ nX, nPosValor ]
Next

//Calcula proporcao  
nSaldoProp := 1 

For nX := 1 to Len(aColsSE2)
	If nX == Len(aColsSE2)  
		nProp := nSaldoProp
	Else 			
		nProp := Round( aColsSE2[ nX, nPosValor ] / nValTot,6)
		nSaldoProp -= nProp
	EndIf	
   AAdd( aProp, nProp )
Next nX

//Obtem os valores por ano/mes para as parcelas desta nota  
For nLoop := 1 to Len( aColsSE2 ) 

	cAnoMes	:= Left( DToS( aColsSE2[ nLoop, nPosVenc ] ), 6 ) 	
	nScanMes := AScan( aDadosMes, { |x| x[1] == cAnoMes } ) 

   //Caso as parcelas sejam do mesmo mes, deve somar o valor das parcelas para aplicar ou nao a cumulatividade
	If aColsSE2[ nLoop, nPPIS ] > 0 .Or. aColsSE2[ nLoop, nPCOFINS ] > 0 .Or. aColsSE2[ nLoop, nPCSLL ] > 0 .Or. nScanMes > 0
		
		If nScanMes == 0
			AAdd( aDadosMes, { cAnoMes, 0,0,0,0 } ) 
			nScanMes := Len( aDadosMes ) 	
		EndIf 
	
		nPropPis := NoRound(nBasePis * aProp[nLoop],6)
		nPropCof := NoRound(nBaseCof * aProp[nLoop],6)
		nPropCsl := NoRound(nBaseCsl * aProp[nLoop],6)		
		
		aDadosMes[ nScanMes, 2 ] += aColsSE2[ nLoop, nPosValor ]
		aDadosMes[ nScanMes, 3 ] += nPropPis
		aDadosMes[ nScanMes, 4 ] += nPropCof
		aDadosMes[ nScanMes, 5 ] += nPropCsl
	    
    EndIf
    	
Next nLoop 

//Ordena o array de ano / mes  
ASort( aDadosMes, , , { |x,y| y[1] > x[1] } ) 

dDataIni := CToD( "01/" + Right( aDadosMes[ 1, 1 ], 2 ) + "/" + Left( aDadosMes[ 1, 1 ], 4 ) ) 
dDataFim := LastDay( CToD( "15/" + Right( aDadosMes[ Len( aDadosMes ), 1 ], 2 ) + "/" + Left( aDadosMes[ Len( aDadosMes ), 1 ], 4 ) ) )

//Ponto de Entrada MT103FRT para tratamento de Filiais com o mesmo CNPJ
aFil10925 := {}
aAreaSM0  := SM0->(GetArea())
cEmpAtu   := SM0->M0_CODIGO
cCGCSM0   := SM0->M0_CGC
SM0->(DbSetOrder(1))
SM0->(MsSeek(cEmpAnt))                                           

//Se parametro "MV_PCCAGLU" existe com conteudo diferente de 1
If cAglutFil == "2" .Or. cAglutFil == "3"
	Do While !SM0->(Eof()) .And. SM0->M0_CODIGO == cEmpAtu
		//Verifica se a filial tem o mesmo CGC/Raiz de CGC
		If (cAglutFil == "2" .And. cCGCSM0 == SM0->M0_CGC) .Or. (cAglutFil == "3" .And. Left(cCGCSM0,8) == Left(SM0->M0_CGC,8))
			AAdd(aFil10925,FWGETCODFILIAL)
		EndIf
		SM0->(DbSkip())
	EndDo

ElseIf lMT103FRT
	aFil10925 := ExecBlock( "MT103FRT", .F., .F. ) 
Else 
	aFil10925 := { xFilial( "SE2" ) }  				     
EndIf
SM0->(RestArea(aAreaSM0))
        
aCampos := { "E2_VALOR","E2_VENCREA","E2_PIS","E2_COFINS","E2_CSLL","E2_ISS","E2_INSS","E2_IRRF","E2_VRETPIS","E2_VRETCOF","E2_VRETCSL" } 
aStruct := SE2->( dbStruct() ) 	

SE2->( dbCommit() ) 
   
cAliasQry := GetNextAlias()

cQuery := "SELECT E2_VALOR,E2_VENCREA,E2_PIS,E2_COFINS,E2_CSLL,E2_ISS,E2_INSS,E2_IRRF,E2_PRETPIS,E2_PRETCOF,E2_PRETCSL,E2_VRETPIS,E2_VRETCOF,E2_VRETCSL,R_E_C_N_O_ RECNO "

cQuery += ",E2_BASEPIS,E2_BASECOF,E2_BASECSL "	                                                                    
Aadd(aCampos,"E2_BASEPIS")
Aadd(aCampos,"E2_BASECOF")
Aadd(aCampos,"E2_BASECSL")		
                   
cQuery += ",E2_PRETIRF,E2_VRETIRF " 
AAdd(aCampos,"E2_PRETIRF") 
AAdd(aCampos,"E2_VRETIRF") 

cQuery += " FROM "+ RetSqlName( "SE2" ) + " SE2 " 
cQuery += "WHERE "                     

//Carrega as filiais do filtro
cQryFil := "("

For nLoop := 1 to Len( aFil10925 ) 
	cQryFil += "E2_FILIAL='" + aFil10925[ nLoop ] + "' OR "
Next nLoop 						                                

cQryFil := Left( cQryFil, Len( cQryFil ) - 3 ) 

cQryFil  += ") AND " 

cQuery += cQryFil 

cQuery += "E2_FORNECE='"  + cA100For            + "' AND " 	
cQuery += "E2_LOJA='"     + cLoja               + "' AND "
cQuery += "E2_VENCREA>='" + DToS( dDataIni )     + "' AND "		
cQuery += "E2_VENCREA<='" + DToS( dDataFim )     + "' AND "
cQuery += "E2_TIPO NOT IN " + FormatIn(MVABATIM,"|") + " AND "	                    
cQuery += "E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)  + " AND "
cQuery += "E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv) + " AND "
cQuery += "E2_TIPO NOT IN " + FormatIn(MVPAGANT,cSepRec)  + " AND "

//Verifica o modo de totalizacao  
If cModTot == "2" 
	cQuery += "(E2_PIS<>0 OR E2_COFINS<>0 OR E2_CSLL<>0 ) AND "
EndIf 			

cQuery += "D_E_L_E_T_=' '"                                             

cQuery := ChangeQuery( cQuery ) 

dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )

For nLoop2 := 1 To Len( aStruct ) 
	If !Empty( AScan( aCampos, AllTrim( aStruct[nLoop2,1] ) ) ) 
		TcSetField( cAliasQry, aStruct[nLoop2,1], aStruct[nLoop2,2],aStruct[nLoop2,3],aStruct[nLoop2,4])
	EndIf 			
Next nLoop2 

//Obtem os valores por ano/mes para as parcelas desta nota  
While !( cAliasQRY )->( Eof()) 

	cAnoMes := Left( DToS( ( cAliasQRY )->E2_VENCREA ), 6 ) 	
	
	If Empty( nScanMes := AScan( aDadosMes, { |x| x[1] == cAnoMes } ) )
		AAdd( aDadosMes, { cAnoMes, 0, 0, 0, 0 } ) 
		nScanMes := Len( aDadosMes ) 	
	EndIf 

	nAdic := 0
	
      nAdic += ( ( cAliasQRY )->E2_VALOR + ( cAliasQRY )->E2_ISS + ( cAliasQRY )->E2_INSS  ) 
      
	nAdic += If( Empty( ( cAliasQRY )->E2_VRETIRF ), ( cAliasQRY )->E2_IRRF, ( cAliasQRY )->E2_VRETIRF )
	
	If Empty( ( cAliasQRY )->E2_PRETPIS )
		nAdic += If( Empty( ( cAliasQRY )->E2_VRETPIS ), ( cAliasQRY )->E2_PIS, ( cAliasQRY )->E2_VRETPIS ) 
	EndIf 								

	If Empty( ( cAliasQRY )->E2_PRETCOF )
		nAdic += If( Empty( ( cAliasQRY )->E2_VRETCOF ), ( cAliasQRY )->E2_COFINS, ( cAliasQRY )->E2_VRETCOF )
	EndIf 								

	If Empty( ( cAliasQRY )->E2_PRETCSL )
		nAdic += If( Empty( ( cAliasQRY )->E2_VRETCSL ), ( cAliasQRY )->E2_CSLL, ( cAliasQRY )->E2_VRETCSL ) 
	EndIf

	aDadosMes[ nScanMes, 2 ] += nAdic

	If ( cAliasQRY )->E2_BASEPIS > 0 .Or. ( cAliasQRY )->E2_BASECOF > 0 .Or. ( cAliasQRY )->E2_BASECSL > 0
		aDadosMes[nScanMes, 3] += ( cAliasQRY )->E2_BASEPIS 
		aDadosMes[nScanMes, 4] += ( cAliasQRY )->E2_BASECOF 
		aDadosMes[nScanMes, 5] += ( cAliasQRY )->E2_BASECSL 
	Else
		aDadosMes[nScanMes, 3] += nAdic
		aDadosMes[nScanMes, 4] += nAdic
		aDadosMes[nScanMes, 5] += nAdic
	EndIf 
		
	( cAliasQRY )->( dbSkip()) 
	
   EndDo 
   
// Fecha a area de trabalho da query 
   
   ( cAliasQRY )->( dbCloseArea() ) 
   dbSelectArea( "SE2" ) 

ASort( aDadosMes, , , { |x,y| y[1] > x[1] } ) 

//Verifica se supera o valor para retencao  
For nLoop := 1 To Len( aDadosMes ) 
	aList[ nLoop, 1 ] := ( aDadosMes[ nLoop, 3 ] > nMinRet .Or.aDadosMes[ nLoop, 4 ] > nMinRet .Or. aDadosMes[ nLoop, 5 ] > nMinRet   ) 
Next nLoop              

bLine := oList:bLine
oList:SetArray(aList)
oList:bLine := bLine 

SE2->( RestArea( aAreaSE2 ) ) 

Return( .T. ) 

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NfeComplFF ³ Autor ³Marcos V. Ferreira    ³ Data ³24/10/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Rotina utilizada para gerar requisicao valorizada 'RE6'    ³±±
±±³          ³ sempre que for incluida  uma nota complementar com o custo ³±±
±±³          ³ Fifo ativado, onde a nota origem esta no periodo anterior. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 - Alias do arquivo SD1                                ³±±
±±³          ³ExpL1 - Informa se esta utilizando Custo Fifo				  |±±
±±³          ³ExpN1 - nTipo = 1 - Gera requisicao valorizada			  |±±
±±³          ³        nTipo = 2 - Pesquisa Lote Original        		  |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Logico - .T. se localizou o lote original nota complementar ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NfeComplFF(cAlias,lCusFifo,nTipo)
Local lAjNfCompl:= SuperGetMV("MV_AJUSNFC",.F.,.F.)
Local dDtLimite	:= SuperGetMV("MV_ULMES",.F.)+1
Local aAreaAnt	:= GetArea()
Local aAreaSF4  := SF4->(GetArea())
Local aQtdLote	:= {}	
Local lGrava	:= .F.
Local lRet		:= .F.
Local nProporc  := 0
Local lM103NFC	:= ExistBlock("M103NFC")
Local cUsoD1_TRT:= GetSx3Cache("D1_TRT","X3_USADO")

Default cAlias  := "SD1"
Default lCusFifo:= .F.
Default nTipo   := 1

dbSelectArea("SF4")
dbSetOrder(1)
MsSeek(xFilial("SF4")+(cAlias)->D1_TES)	

If lAjNfCompl .And. lCusFifo .And. (cAlias)->D1_TIPO == 'C' .And. SF4->F4_ESTOQUE == 'S'
	dbSelectArea("SD8")
	dbSetOrder(3)
		If MsSeek(xFilial("SD8")+(cAlias)->D1_NFORI+(cAlias)->D1_SERIORI+(cAlias)->D1_ITEMORI) .And. SD8->D8_DTPROC < dDtLimite
		dbSelectArea("SBD")
		dbSetOrder(2)
		If MsSeek(xFilial("SBD")+SD8->D8_SEQ)
			//BD_STATUS == ' ' Lote Fifo Aberto
			//BD_STATUS == 'Z' Lote Fifo Encerrado
			If nTipo == 1 .And. SBD->BD_STATUS == ' '
				aQtdLote := CalcEstFF( (cAlias)->D1_COD,(cAlias)->D1_LOCAL,dDtLimite,Nil,Nil,SBD->BD_SEQ)
				If aQtdLote[1] == SBD->BD_QUANT
                      lGrava := .F. //Qtde do Lote Fifo ainda nao utilizada
				Else
					//Formula: Qtde Inicial do Lote - Qtde Atual do Lote / Qtde Inicial do Lote
					nProporc := (SBD->BD_QUANT-aQtdLote[1])/SBD->BD_QUANT 
					lGrava   := .T.
				EndIf	
			ElseIf nTipo == 1 .And. SBD->BD_STATUS == 'Z'
				nProporc := 1
				lGrava   := .T.
			ElseIf nTipo == 2
				lRet := .T.
			EndIf	
		EndIf	
	EndIf

	//Ponto de Entrada para validar a gravacao da requisicao valorizada
	If lM103NFC
		lGrava := ExecBlock("M103NFC",.F.,.F.,{lGrava .And. nTipo == 1,nProporc})
	EndIf

EndIf

//Gravacao da requisicao valorizada para consumir o custo da nota de complemento de preco
If lGrava .And. nTipo == 1
	RecLock("SD3",.T.)
	SD3->D3_FILIAL	:= xFilial("SD3")
	SD3->D3_COD		:= (cAlias)->D1_COD
	SD3->D3_QUANT	:= (cAlias)->D1_QUANT
	SD3->D3_TM		:= "999"
	SD3->D3_OP		:= (cAlias)->D1_OP
	SD3->D3_LOCAL	:= (cAlias)->D1_LOCAL
	SD3->D3_DOC		:= (cAlias)->D1_DOC
	SD3->D3_EMISSAO	:= (cAlias)->D1_DTDIGIT
	SD3->D3_NUMSEQ	:= (cAlias)->D1_NUMSEQ
	SD3->D3_UM		:= (cAlias)->D1_UM
	SD3->D3_GRUPO	:= (cAlias)->D1_GRUPO
	SD3->D3_TIPO	:= (cAlias)->D1_TP
	SD3->D3_SEGUM	:= (cAlias)->D1_SEGUM
	SD3->D3_CONTA	:= (cAlias)->D1_CONTA
	SD3->D3_CF		:= "RE6"
	SD3->D3_QTSEGUM	:= (cAlias)->D1_QTSEGUM
	SD3->D3_USUARIO	:= CUSERNAME
	SD3->D3_CUSTO1	:= (cAlias)->D1_CUSTO  * nProporc
	SD3->D3_CUSTO2	:= (cAlias)->D1_CUSTO2 * nProporc
	SD3->D3_CUSTO3	:= (cAlias)->D1_CUSTO3 * nProporc
	SD3->D3_CUSTO4	:= (cAlias)->D1_CUSTO4 * nProporc
	SD3->D3_CUSTO5	:= (cAlias)->D1_CUSTO5 * nProporc
	SD3->D3_NUMLOTE	:= (cAlias)->D1_NUMLOTE
	SD3->D3_LOTECTL	:= (cAlias)->D1_LOTECTL
	SD3->D3_DTVALID	:= (cAlias)->D1_DTVALID
	SD3->D3_POTENCI := (cAlias)->D1_POTENCI
	If X3Uso(cUsoD1_TRT)
		SD3->D3_TRT	:= (cAlias)->D1_TRT
	EndIf
	dbSelectArea("SB2")
	B2AtuComD3({SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
EndIf

RestArea(aAreaSF4)
RestArea(aAreaAnt)
Return lRet       

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103GCDisp³ Autor ³ Sergio Silveira       ³ Data ³ 03/03/2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Indica se o produto gestao de contratos esta disponivel      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpL1 -> Indicao disponibilidade                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ PROGRAMADOR  ³ DATA   ³ BOPS ³  MOTIVO DA ALTERACAO                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³              ³        ³      ³                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/                                                                         

Function A103GCDisp() 

Local lRet := .F. 

//Verifica se possui um registro na tabela de contratos
lRet := !Empty( CN9->( LastRec() ) )

Return( lRet ) 

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103ChWhen³ Autor ³Rodrigo de A Sartorio  ³ Data ³ 12/06/2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Checa when dos campos de cabecalho da Pre-Nota e Nota        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/                                                                         
Function A103ChWhen(cCampo,cConteudo,lClassif)
LOCAL lRet:=.T.
LOCAL lExistBlock:=ExistBlock("MT103CWH")
// Ponto de Entrada que permite alterar o WHEN
If lExistBlock
	lRet:=Execblock("MT103CWH",.F.,.F.,{cCampo,cConteudo,lClassif})
	If ValType(lRet) # "L"
		lRet:=.T.
	EndIf
EndIf
RETURN lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFldNfe ³Autor  ³ Mary Hergert          ³ Data ³10/07/2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de tratamento do folder da nota fiscal eletronica     ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpO1: Objeto da Janela que sera disponibilizado os Get      ³±±
±±³          ³ExpA2: Array com os gets da NF-e                             ³±±
±±³          ³ExpA3: Array com as posicoes dos gets da NF-e                ³±±
±±³          ³Expb4: Codeblock para atualizaco dos dados do Folder         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFldNfe(oDlg,aNFEletr,aPosGet,bRefresh)

Local aObjetos	:= Array(Len(aNFEletr))                     
Local nHRes     := oMainWnd:nClientWidth

If cPaisLoc == "BRA"
	@ 09,aPosGet[1,1] SAY OemToAnsi(STR0057) Of oDlg PIXEL SIZE 48,12
	@ 08,aPosGet[1,2] MSGET aObjetos[01] VAR aNFEletr[01] ;
		PICTURE PesqPict("SF1","F1_NFELETR") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_NFELETR");     
		VALID CheckSX3("F1_NFELETR",aNFEletr[01]);
		SIZE 50,09 HASBUTTON
	aObjetos[01]:cSX1Hlp := "F1_NFELETR"	
	
	
	@ 26,aPosGet[1,1] SAY OemToAnsi(STR0058) Of oDlg PIXEL SIZE 48,12
	@ 25,aPosGet[1,2] MSGET aObjetos[03] VAR aNFEletr[03] ;
		PICTURE PesqPict("SF1","F1_EMINFE") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_EMINFE");
		VALID A103NFe('EMINFE',aNFEletr) .And. CheckSX3("F1_EMINFE",aNFEletr[03]);
		SIZE 60,09 HASBUTTON
	aObjetos[03]:cSX1Hlp := "F1_EMINFE"	
	
	@ 26,IIF(nHRes <= 800, aPosGet[1,3]+10, aPosGet[1,3]) SAY OemToAnsi(STR0059) Of oDlg PIXEL SIZE 48,12
	@ 25,IIF(nHRes <= 800, aPosGet[1,4]+15, aPosGet[1,4]) MSGET aObjetos[04] VAR aNFEletr[04] ;
		PICTURE PesqPict("SF1","F1_HORNFE") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_HORNFE");
		VALID CheckSX3("F1_HORNFE",aNFEletr[04]);
		SIZE 80,9	HASBUTTON
	aObjetos[04]:cSX1Hlp := "F1_HORNFE"
	
	@ 43,aPosGet[1,1] SAY OemToAnsi(STR0061) Of oDlg PIXEL SIZE 48,12
	@ 42,aPosGet[1,2] MSGET aObjetos[05] VAR aNFEletr[05] ;
		PICTURE PesqPict("SF1","F1_CREDNFE") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_CREDNFE");
		VALID A103NFe('CREDNFE',aNFEletr) .And. CheckSX3("F1_CREDNFE",aNFEletr[05]);
		SIZE 60,09 HASBUTTON
	aObjetos[05]:cSX1Hlp := "F1_CREDNFE"	
	
	@ 43,IIF(nHRes <= 800, aPosGet[1,3]+10, aPosGet[1,3]) SAY OemToAnsi(STR0063) Of oDlg PIXEL SIZE 48,12
	@ 42,IIF(nHRes <= 800, aPosGet[1,4]+15, aPosGet[1,4]) MSGET aObjetos[06] VAR aNFEletr[06] ;
		PICTURE PesqPict("SF1","F1_NUMRPS") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_NUMRPS");
		VALID CheckSX3("F1_NUMRPS",aNFEletr[06]);
		SIZE 80,09 HASBUTTON
	aObjetos[06]:cSX1Hlp := "F1_NUMRPS"	
	             
	@ 43,IIF(nHRes <= 800, aPosGet[1,3]+10, aPosGet[1,5]) SAY OemToAnsi(STR0060) Of oDlg PIXEL SIZE 48,12
   	@ 42,IIF(nHRes <= 800, aPosGet[1,4]+15, aPosGet[1,6]) MSGET aObjetos[02] VAR aNFEletr[02] ;
		PICTURE PesqPict("SF1","F1_CODNFE") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_CODNFE");       
		VALID CheckSX3("F1_CODNFE",aNFEletr[02]);
		SIZE IIF(nHRes <= 800, 95, 185),09 HASBUTTON
	aObjetos[02]:cSX1Hlp := "F1_CODNFE"
	             
 		@ 09,IIF(nHRes <= 800, aPosGet[1,5]+30, aPosGet[1,5]) SAY OemToAnsi(STR0104) Of oDlg PIXEL SIZE 48,12
	@ 08,IIF(nHRes <= 800, aPosGet[1,6]+30, aPosGet[1,6]) MSGET aObjetos[07] VAR aNFEletr[07] ;
		PICTURE PesqPict("SF1","F1_MENNOTA") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_MENNOTA");
		SIZE IIF(nHRes <= 800, 95, 185),09 HASBUTTON
	aObjetos[07]:cSX1Hlp := "F1_MENNOTA"	 

	@ 26,IIF(nHRes <= 800, aPosGet[1,5]+30, aPosGet[1,5]) SAY OemToAnsi(STR0105) Of oDlg PIXEL SIZE 48,12
	@ 25,IIF(nHRes <= 800, aPosGet[1,6]+30, aPosGet[1,6]) MSGET aObjetos[08] VAR aNFEletr[08] ;
		PICTURE PesqPict("SF1","F1_MENPAD") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_MENPAD");
		VALID VALIDSM4(aNFEletr);
	    F3 "SM4";
		SIZE 20,09 HASBUTTON
	aObjetos[08]:cSX1Hlp := "F1_MENPAD"	 
	
Endif

Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A103NFe   ³ Autor ³Mary C. Hergert        ³ Data ³29/06/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Valida campos da Nota Fiscal Eletronica de Sao Paulo        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³A103NFe(cExp01,aExp01)                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cExp01: Campo a ser validado                                ³±±
±±³          ³aExp01: Array com as variaveis de memoria                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103NFe(cCampo,aNFEletr)

Local lRet := .T.

If cPaisLoc == "BRA"
	If cCampo == "EMINFE"    
		If !Empty(aNFEletr[03]) .And. aNFEletr[03] < dDEmissao
			Help("",1,"A100NFEDT")	
			lRet := .F.
		Endif
	ElseIf cCampo == "CREDNFE"
		If aNFEletr[05] < 0
			Help("",1,"A100NFECR")	
			lRet := .F.
		Endif
	Endif
Endif

Return lRet
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³a103xLAICMS³ Autor ³ Gustavo G. Rueda      ³ Data ³05/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Funcao para montagem do GETDADOS do folder de lancamentos   ³±±
±±³          ³ fiscais.                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³oLancApICMS -> Objeto criado pelo MSNEWGETDADOS             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³oDlg -> Objeto pai onde o GETDADOS serah criado.            ³±±
±±³          ³aPos -> posicoes de criacao do objeto.                      ³±±
±±³          ³aHeadCDA -> array com o HEADER da tabela CDA                ³±±
±±³          ³aColsCDA -> array com o ACOLS da tabela CDA                 ³±±
±±³          ³lVisual -> Flag de visualizacao                             ³±±
±±³          ³lInclui -> Flag de inclusao                                 ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function a103xLAICMS(oDlg,aPos,aHeadCDA,aColsCDA,lVisual,lInclui)
Local	oLancApICMS
Local	bCond		:=	{||.T.}
Local	bSkip		:=	{|| CDA->CDA_TPREG == "NA" }
Local	cVisual		:=	Iif(lVisual,"'1'","'2'")
Local	cFormulBkp	:=	cFormul
Local	aCmpsCDA	:=	{"CDA_NUMITE","CDA_CODLAN","CDA_BASE","CDA_ALIQ","CDA_VALOR"}
Local aArea		:= GetArea()
Local cSerieId  := SerieNfId("SD1",4,"D1_SERIE",dDEmissao,cEspecie,cSerie)
Local lCalcCDV  := Type("oLancCDV")=="O" 
Local nbtnCDV	:= Iif(lCalcCDV, 45,0)

//Campo criado pelo compatibilizador UPDFIS
aAdd(aCmpsCDA,"CDA_IFCOMP")
//Campo complemento para registro 0460 campo 3
If cPaisLoc == "BRA"
	aAdd(aCmpsCDA,"CDA_CLANC")
EndIf

If CDA->(FieldPos("CDA_VLOUTR")) > 0 .And. CDA->(FieldPos("CDA_TXTDSC")) > 0 .And. CDA->(FieldPos("CDA_CODCPL")) > 0 .And. CDA->(FieldPos("CDA_CODMSG")) > 0
	aAdd(aCmpsCDA,"CDA_VLOUTR")
	 aAdd(aCmpsCDA,"CDA_TXTDSC")
	aAdd(aCmpsCDA,"CDA_CODCPL")
	aAdd(aCmpsCDA,"CDA_CODMSG")
Endif	

aMHead("CDA","CDA_TPMOVI/CDA_ESPECI/CDA_FORMUL/CDA_NUMERO/CDA_SERIE/CDA_CLIFOR/CDA_LOJA/CDA_GUIA",@aHeadCDA)
If lVisual
	dbSelectArea("CDA")
	CDA->(dbSetOrder(1))
	If !CDA->(MsSeek(xFilial("CDA")+"E"+cEspecie+cFormul+cNFiscal+cSerieId+cA100For+cLoja)) .And. cFormul=="N"	//tratamento implementado devido ao default do mata103 para o cformul ser "N", porem as tabelas para N podem gravar branco ou N.
		cFormul	:=	" "
	CDA->(MsSeek(xFilial("CDA")+"E"+cEspecie+cFormul+cNFiscal+cSerieId+cA100For+cLoja))
	EndIf
	bCond	:=	{||xFilial("CDA")+"E"+cEspecie+cFormul+cNFiscal+cSerieId+cA100For+cLoja==CDA->(CDA_FILIAL+CDA_TPMOVI+CDA_ESPECI+CDA_FORMUL+CDA_NUMERO+CDA_SERIE+CDA_CLIFOR+CDA_LOJA)}
EndIf
aMAcols(lVisual,"CDA",@aColsCDA,aHeadCDA,bCond,bSkip)

oLancApICMS	:=	MsNewGetDados():New(aPos[1],aPos[2],aPos[4],aPos[3]-nbtnCDV,Iif(lVisual,0,GD_UPDATE+GD_INSERT+GD_DELETE),"a103xLOk","a103xLOk","+CDA_SEQ",aCmpsCDA,/*freeze*/,9999,/*fieldok*/,/*superdel*/,"LancDel("+cVisual+")",oDlg,@aHeadCDA,@aColsCDA)

If lCalcCDV
	@ aPos[1]+12,aPos[3]-nbtnCDV BUTTON STR0208 SIZE 45,11 FONT oDlg:oFont ;
	ACTION MT103CDV(.T.) OF oDlg PIXEL		   
Endif

cFormul	:=	cFormulBkp

RestArea(aArea)

Return oLancApICMS
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³aMHead    ³ Autor ³ Gustavo G. Rueda      ³ Data ³05/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Funcao para montagem do HEADER do GETDADOS                 ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias da tabela base para montagem do HEADER      ³±±
±±³          ³cNCmps -> Campos que nao serao considerados no HEADER       ³±±
±±³          ³aH -> array no qual o HEADER serah montado                  ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function aMHead(cAlias,cNCmps,aH)
Local	lRet	:=	.T.
Local	cValid	:=	""

//Salva a Integridade dos campos de Bancos de Dados
dbSelectArea("SX3")
dbSetOrder(1)
dbSeek(cAlias)
While !Eof() .And. (X3_ARQUIVO==cAlias)
	IF X3USO(X3_USADO) .And. cNivel >= X3_NIVEL .and. !(AllTrim(X3_CAMPO)+"/"$cNCmps)
		
		If AllTrim(X3_CAMPO)=="CDA_NUMITE"
			cValid	:=	"LancCpIt().And.LancCps()"
		Else
			cValid	:=	AllTrim(X3_VALID)+Iif(Empty(AllTrim(X3_VALID)),"",".And.")+"LancCps()"
		EndIf	
	
		AADD(aH,{ Trim(X3Titulo()), ;
			AllTrim(X3_CAMPO),;
			X3_PICTURE,;
			X3_TAMANHO,;
			X3_DECIMAL,;
			cValid,;
			X3_USADO,;
			X3_TIPO,;
			X3_F3,;
			X3_CONTEXT,;
			X3_CBOX,;
			X3_RELACAO})
	Endif
	dbSkip()
Enddo
Return lRet
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³aMAcols   ³ Autor ³ Gustavo G. Rueda      ³ Data ³05/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Funcao para montagem do ACOLS do GETDADOS                  ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³nOpc -> Opcao do AROTINA                                    ³±±
±±³          ³cAlias -> Alias da tabela base para montagem do HEADER      ³±±
±±³          ³aC -> array no qual o ACOLS serah montado                   ³±±
±±³          ³aH -> array no qual o HEADER serah montado                  ³±±
±±³          ³bCond -> Condicao de loop do while                          ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function aMAcols(lVisual,cAlias,aC,aH,bCond,bSkip)
Local	lRet	:=	.T.
Local	nI		:=	0

DEFAULT bSkip 	:= {|| .F. }

dbSelectArea(cAlias)
dbSetOrder(1)
If lVisual .And. !Eof()
	//Monta o array aCols com os itens
	aC	:=	{}
	While !Eof() .And. Eval(bCond)
		IF Eval(bSkip)
			dbSkip()
			Loop
		EndIf
		aAdd(aC,Array(Len(aH)+1))
		For nI := 1 To Len(aH)
			aC[Len(aC),nI] := FieldGet(FieldPos(aH[nI,2]))
		Next
		aC[Len(aC),Len(aH)+1] := .F.
		dbSkip()
	End	
Else
	aC				:=	{Array(Len(aH)+1)}
	aC[1,Len(aH)+1]	:=	.F.
	For nI := 1 To Len(aH)
		If aH[nI,10]#"V"
			aC[1,nI]	:=	CriaVar(aH[nI,2])
		EndIf

		If "_SEQ"$aH[nI,2]
			aC[1,nI]	:=	StrZero(1,aH[nI,4])
		EndIf
	Next	
EndIf
Return lRet
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³LancDel   ³ Autor ³ Gustavo G. Rueda      ³ Data ³13/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Funcao para validar a delecao do lancamento fiscal do docu- ³±±
±±³          ³ mento criado pelo sistema.                                 ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T. ou .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cVisual -> indica se a nota esta sendo visualizada. 1=Sim,  ³±±
±±³          ³ 2=Nao                                                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LancDel(cVisual)
Local	lRet	:=	.T.
Local	nPosCalc:=	0
Local	nPosIt	:=	0
Local 	nPosItD1:= 	0
Local	nPos	:=	0

If Type("oLancApICMS")=="O" .And. cVisual=="2"
	nPosCalc:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_CALPRO"})
	nPosIt	:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_NUMITE"})
	
	If nPosCalc>0 .And. oLancApICMS:aCols[oLancApICMS:nAT,nPosCalc]=="1"
		//Registros calculados pelo sistema não poderão ser excluídos, pois serão utilizados como log da rotina.
		//Caso seja necessário alterar este cálculo, basta inserir novos itens nesta opção de ajuste ou utitlizar a funcionalidade de Gerenciamento dos Lançamentos Fiscais de ICMS. Vale ressaltar que na Apuração de ICMS será considerada a sequência maior de cada lançamento fiscal do documento.
		Help("  ",1,"LAICMSDEL1")	
		lRet	:=	.F.
	
	ElseIf nPosCalc>0 .And. oLancApICMS:aCols[oLancApICMS:nAT,nPosCalc]=="2" .And. Type("aColsD1")=="A" .And. Type("aHeadD1")="A"
		nPosItD1:= 	GetPosSD1("D1_ITEM")	
		
		If nPosItD1>0 .And. nPosIt>0
			nPos	:=	aScan(aColsD1,{|aX|PadR(aX[nPosItD1],TamSx3("CDA_NUMITE")[1])==oLancApICMS:aCols[oLancApICMS:nAT,nPosIt].And.!aX[Len(aColsD1[1])]})
			If nPos==0
				//Este registro não pode ser recuperado, pois o mesmo encontra-se excluído juntamente com seu respectivo item do documento fiscal.
				//Para se recuperar este registro é necessário que se tenha o respectivo item deste documento fiscal ativado.
				Help("  ",1,"LAICMSDEL2")
				lRet	:=	.F.
			EndIf
		EndIf
	EndIf
EndIf
Return lRet
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³LancCpIt  ³ Autor ³ Gustavo G. Rueda      ³ Data ³13/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Funcao para validar o item digitado no lancamento fiscal com³±±
±±³          ³ os itens do documento fiscal.                              ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T. ou .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LancCpIt()
Local	lRet	:=	.T.
Local	nPosCalc:=	0
Local	nPosItD1:=	0

If Type("oLancApICMS")=="O"

	nPosCalc:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_CALPRO"})

	If nPosCalc>0 .And. oLancApICMS:aCols[oLancApICMS:nAT,nPosCalc]=="2" .And. Type("aColsD1")=="A" .And. Type("aHeadD1")="A"
		nPosItD1:= 	GetPosSD1("D1_ITEM")
		If nPosItD1>0
			nPos	:=	aScan(aColsD1,{|aX|aX[nPosItD1]==M->CDA_NUMITE.And.!aX[Len(aColsD1[1])]})
			If nPos==0
				//Número do item é inválido para este lançamento fiscal.
				//Deve-se informar um número de item existente no respectivo documento fiscal.
				Help("  ",1,"LAICMSCMP1")
				lRet	:=	.F.
			EndIf
		EndIf
	EndIf
EndIf
Return lRet
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³LancCps   ³ Autor ³ Gustavo G. Rueda      ³ Data ³13/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Funcao para validar os campos alimentados pelo sistema que  ³±±
±±³          ³ nao poderao ser alterados.                                 ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T. ou .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LancCps()
Local	lRet	:=	.T.
Local	nPosCalc:=	0

If Type("oLancApICMS")=="O"
	nPosCalc:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_CALPRO"})
	If nPosCalc>0 .And. oLancApICMS:aCols[oLancApICMS:nAT,nPosCalc]=="1"
		//Registros calculados pelo sistema não poderão ser alterados, pois serão utilizados como log da rotina.
		//Caso seja necessário alterar este cálculo, basta inserir novos itens nesta opção de ajuste ou utitlizar a funcionalidade de Gerenciamento dos Lançamentos Fiscais de ICMS. Vale ressaltar que na Apuração de ICMS será considerada a sequência maior de cada lançamento fiscal do documento.
		Help("  ",1,"LAICMSCMP2")
		lRet	:=	.F.
	EndIf
EndIf

Return lRet
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³a103xLOk  ³ Autor ³ Gustavo G. Rueda      ³ Data ³13/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Funcao para validar a linha do acols de lancamentos         ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T. ou .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function a103xLOk()
Local	lRet	:=	.T.
Local	nPosLanc:=	0
Local	nPosVlr	:=	0
Local	nNumIte	:=	0
Local	nPosCal	:=	0
Local	lCalPro	:=	.T.

If Type("oLancApICMS")=="O"
	nPosLanc:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_CODLAN"})
	nPosVlr:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_VALOR"})
	nNumIte:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_NUMITE"})
	nPosCal:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_CALPRO"})

	If !oLancApICMS:aCols[oLancApICMS:nAT,Len(oLancApICMS:aCols[oLancApICMS:nAT])] .And.;
		!Empty(oLancApICMS:aCols[oLancApICMS:nAT,nNumIte])

		If nPosLanc>0 .And. Empty(oLancApICMS:aCols[oLancApICMS:nAT,nPosLanc])
			Help(1," ","OBRIGAT",,"CDA_CODLAN"+Space(30),3,0)
			lRet	:=	.F.
		EndIf
		
		If nPosCal > 0
			lCalPro:= oLancApICMS:aCols[oLancApICMS:nAT,nPosCal] =='2' //Calc pelo usuario
		Endif

		If lRet .And. nPosLanc>0 .And. Empty(oLancApICMS:aCols[oLancApICMS:nAT,nPosVlr]) .And. lCalPro
			Help(1," ","OBRIGAT",,"CDA_VALOR"+Space(30),3,0)
			lRet	:=	.F.
		EndIf
	EndIf
EndIf
Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFlddIV ³Autor  ³ Microsiga S/A         ³ Data ³09/09/2008 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de tratamento do folder para informacoes diversas     ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpO1: Objeto da Janela que sera disponibilizado os Get      ³±±
±±³          ³ExpA1: Array com as posicoes dos gets da NF-e                ³±±
±±³          ³ExpB1: Codeblock para atualizaco dos dados do Folder         ³±± 
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFldDiv(oDlg,aPosGet,bRefresh)
Local lDigChv := GetNewPar("MV_DCHVNFE",.F.)
Local aObjetos	:= Array(Len(aNFEDanfe))   
Local nrFolder  := 9		//posicao do folder       
Local nTamGetFor:= (TamSX3("A2_COD")[1])
Local aCombo	:= CarregaTipoFrete()    
Local aComboCTE := {}
Local aComboMod := {}
Local aComboMne := {}
Local cCar      := "QWERTYUIOPASDFGHJKLZXCVBNM0123456789"
Local nPosLojaRet := 0
Local nPsTpcTe  := 0
Local nPsTpFrt	:= 0
Local nPsModal	:= 0
Local cChvEspe  := ""
Local cCompara  := "|SPED|CTE|"
Local lMT103DCF := ExistBlock("MT103DCF")

If lDigChv
	cChvEspe := SuperGetMV( "MV_CHVESPE" , .F. , "" )
	cChvEspe := StrTran(cChvEspe,",","|")
	cChvEspe := StrTran(cChvEspe,";","|")
	
	If !Empty( cChvEspe )
		cCompara += cChvEspe + "|"
	EndIf
EndIF

// Caso a aba "Lançamentos da Apuração de ICMS" esteja ativa a posição da aba Danfe e modificada para 10
If cPaisLoc == "BRA" .And. Type('l103Class')=="L" .And.;
   l103Class .And. AliasInDic("CDA")
	nrFolder  := 10
EndIf
			
If TamSX3("A2_COD")[1]< 9 
	nTamGetFor:=(6*TamSX3("A2_COD")[1])
ElseIf TamSX3("A2_COD")[1]< 15
	nTamGetFor:=(4.8*TamSX3("A2_COD")[1])
Else
	nTamGetFor:=(4*TamSX3("A2_COD")[1])
EndIf

aComboCte := LoadX3Arr("F1_TPCTE")
If !Empty(aNFEDanfe[18])
	If l103Visual .Or. (Type('l103Class')=="L" .And. l103Class)
		nPsTpcTe := aScan(aComboCte ,{|x| AllTrim(Substr(x,1)) == AllTrim(aNFEDanfe[18])})
	Else
		nPsTpcTe := aScan(aComboCte ,{|x| AllTrim(Substr(x,1,1)) == AllTrim(aNFEDanfe[18])})
	Endif 		            
EndIf	
nPsTpcTe := Max(1,nPsTpcTe)

If !Empty(aNFEDanfe[14])
	nPsTpFrt := aScan(aCombo ,{|x| Substr(x,1,1) == Substr(aNFEDanfe[14],1,1)})		            
EndIf
nPsTpFrt := Max(1, nPsTpFrt)

aComboMod := LoadX3Arr("F1_MODAL")
If !Empty(aNFEDanfe[23])
	nPsModal := ascan(aComboMod ,{|x| Substr(x,1,2) == Substr(aNFEDanfe[23],1,2)})
Endif
nPsModal := Max(1, nPsModal)

aComboMne := LoadX3Arr("F1_DEVMERC", {|x| SubStr(x,5,3)})

If Type("aNFEDanfe") == "A"       

	@ 05,aPosGet[1,1] SAY STR0074 Of oDlg PIXEL SIZE 32,12    // Cod. Transp
	@ 04,aPosGet[1,2] MSGET aObjetos[01] VAR aNFEDanfe[01] ;
		PICTURE X3Picture("F1_TRANSP") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_TRANSP");  
	   	VALID IIF(Len(Trim(aNFEDanfe[01]))>0,CheckSX3("F1_TRANSP",aNFEDanfe[01]),.T.);
	   	F3 "SA4";
		SIZE 50,08 HASBUTTON
	aObjetos[01]:cSX1Hlp    := "F1_TRANSP"	   
	aObjetos[01]:bLostFocus := { || IIf( Len(Trim(aNFEDanfe[01]))>0 .And. CheckSX3("F1_TRANSP",aNFEDanfe[01]),{oFolder:nOption := nrFolder},"")}

	@ 05,aPosGet[1,3] SAY STR0075 Of oDlg PIXEL SIZE 30,12   // Placa
	@ 04,aPosGet[1,4] MSGET aObjetos[12] VAR aNFEDanfe[12] ;
		PICTURE X3Picture("F1_PLACA") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_PLACA") ;
		VALID CheckSX3("F1_PLACA",aNFEDanfe[12]) .And. A103VldCpo(aNFEDanfe[12],cCar,1);
		SIZE 30,08 HASBUTTON
	aObjetos[12]:cSX1Hlp := "F1_PLACA"  
	aObjetos[12]:bLostFocus := { || IIf(!A103VldCpo(aNFEDanfe[12],cCar,1),{oFolder:nOption := nrFolder},"")}

	@ 17,aPosGet[1,1] SAY STR0078 Of oDlg PIXEL SIZE 32,12  // Especie 1
	@ 16,aPosGet[1,2] MSGET aObjetos[04] VAR aNFEDanfe[04] ;
		PICTURE X3Picture("F1_ESPECI1") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_ESPECI1");
		VALID CheckSX3("F1_ESPECI1",aNFEDanfe[04]);
		SIZE 50,08 HASBUTTON
	aObjetos[04]:cSX1Hlp := "F1_ESPECI1"

	@ 17,aPosGet[1,3] SAY STR0082 Of oDlg PIXEL SIZE 32,12   // Volume 1
	@ 16,aPosGet[1,4] MSGET aObjetos[05] VAR aNFEDanfe[05] ;
		PICTURE X3Picture("F1_VOLUME1") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_VOLUME1");
		VALID CheckSX3("F1_VOLUME1",aNFEDanfe[05]);
		SIZE 50,08 HASBUTTON
	aObjetos[05]:cSX1Hlp := "F1_VOLUME1"

	@ 29,aPosGet[1,1] SAY STR0079 Of oDlg PIXEL SIZE 32,12  // Especie 2
	@ 28,aPosGet[1,2] MSGET aObjetos[06] VAR aNFEDanfe[06] ;
		PICTURE X3Picture("F1_ESPECI2") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_ESPECI2");
		VALID CheckSX3("F1_ESPECI2",aNFEDanfe[06]);
		SIZE 50,08 HASBUTTON
	aObjetos[06]:cSX1Hlp := "F1_ESPECI2"

	@ 29,aPosGet[1,3] SAY STR0083 Of oDlg PIXEL SIZE 32,12  // Volume 2
	@ 28,aPosGet[1,4] MSGET aObjetos[07] VAR aNFEDanfe[07] ;
		PICTURE X3Picture("F1_VOLUME2") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_VOLUME2");
		VALID CheckSX3("F1_VOLUME2",aNFEDanfe[07]);
		SIZE 50,08 HASBUTTON
	aObjetos[07]:cSX1Hlp := "F1_VOLUME2"	

	@ 41,aPosGet[1,1] SAY STR0080 Of oDlg PIXEL SIZE 32,12  // Especie 3
	@ 40,aPosGet[1,2] MSGET aObjetos[08] VAR aNFEDanfe[08] ;
		PICTURE X3Picture("F1_ESPECI3") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_ESPECI3");
		VALID CheckSX3("F1_ESPECI3",aNFEDanfe[08]);
		SIZE 50,08 HASBUTTON
	aObjetos[08]:cSX1Hlp := "F1_ESPECI3"

	@ 41,aPosGet[1,3] SAY STR0084 Of oDlg PIXEL SIZE 32,12  // Volume 3
	@ 40,aPosGet[1,4] MSGET aObjetos[09] VAR aNFEDanfe[09] ;
		PICTURE X3Picture("F1_VOLUME3") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_VOLUME3");
		VALID CheckSX3("F1_VOLUME3",aNFEDanfe[09]);
		SIZE 50,08 HASBUTTON
	aObjetos[09]:cSX1Hlp := "F1_VOLUME3"

	@ 53,aPosGet[1,1] SAY STR0081 Of oDlg PIXEL SIZE 32,12   // Especie 4
	@ 52,aPosGet[1,2] MSGET aObjetos[10] VAR aNFEDanfe[10] ;
		PICTURE X3Picture("F1_ESPECI4") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_ESPECI4");
		VALID CheckSX3("F1_ESPECI4",aNFEDanfe[10]);
		SIZE 50,08 HASBUTTON
	aObjetos[10]:cSX1Hlp := "F1_ESPECI4"

	@ 53,aPosGet[1,3] SAY STR0085 Of oDlg PIXEL SIZE 32,12  // Volume 4
	@ 52,aPosGet[1,4] MSGET aObjetos[11] VAR aNFEDanfe[11] ;
		PICTURE X3Picture("F1_VOLUME4") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_VOLUME4");
		VALID CheckSX3("F1_VOLUME4",aNFEDanfe[11]);
		SIZE 50,08 HASBUTTON
	aObjetos[11]:cSX1Hlp := "F1_VOLUME4"

	@ 05,aPosGet[1,5] SAY STR0111 Of oDlg PIXEL SIZE 32,12  // Chave NFE
	@ 04,aPosGet[1,6] MSGET aObjetos[13] VAR aNFEDanfe[13] ;
		PICTURE X3Picture("F1_CHVNFE") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual.And. VisualSX3("F1_CHVNFE") .and. IIF(lDigChv, (cFormul == "N" .And. ("|" + AllTrim(cEspecie) + "|" $ cCompara)) ,.T.) ;
		VALID (If(A103ConsNfeSef(),,(aNFEDanfe[13] := Space(44),aObjetos[13]:refresh())),.T.);
		SIZE 195,08 HASBUTTON
	aObjetos[13]:cSX1Hlp := "F1_CHVNFE"
	If(lLGPD,OfuscaLGPD(aObjetos[13],"F1_CHVNFE"),.F.)   

	@ 17,aPosGet[1,5] SAY STR0077 Of oDlg PIXEL SIZE 32,12  // Peso Bruto
	@ 16,aPosGet[1,6] MSGET aObjetos[03] VAR aNFEDanfe[03] ;
		PICTURE X3Picture("F1_PBRUTO") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_PBRUTO");
		VALID CheckSX3("F1_PBRUTO",aNFEDanfe[03]);
		SIZE 50,08 HASBUTTON
	aObjetos[03]:cSX1Hlp := "F1_PBRUTO"	

	@ 29,aPosGet[1,5] SAY STR0076 Of oDlg PIXEL SIZE 32,12    // Peso Liquido
	@ 28,aPosGet[1,6] MSGET aObjetos[02] VAR aNFEDanfe[02] ;
		PICTURE X3Picture("F1_PLIQUI") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_PLIQUI");       
		VALID CheckSX3("F1_PLIQUI",aNFEDanfe[02]);
		SIZE 50,08 HASBUTTON
	aObjetos[02]:cSX1Hlp := "F1_PLIQUI"

 	@ 41,aPosGet[1,5] SAY OemToAnsi(IIF(cTipo$"DB",STR0163,STR0115)) Of oDlg PIXEL SIZE 40,12          
	@ 40,aPosGet[1,6] MSGET aObjetos[16] VAR aNFEDanfe[16] ;
		PICTURE X3Picture("F1_FORRET") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_FORRET");       
		VALID CheckSX3("F1_FORRET",aNFEDanfe[16]) .And. NfeFornece(cTipo,@aNFEDanfe[16],@aNFEDanfe[17]);
		F3 CpoRetF3("F1_FORRET");
		SIZE nTamGetFor,08 HASBUTTON
	aObjetos[16]:cSX1Hlp := "F1_FORRET"

	nPosLojaRet := aPosGet[1,6] + nTamGetFor
	@ 40,nPosLojaRet MSGET aObjetos[17] VAR aNFEDanfe[17] ;
		PICTURE X3Picture("F1_LOJARET") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_LOJARET");       
		VALID CheckSX3("F1_LOJARET",aNFEDanfe[17]) .And. NfeFornece(cTipo,@ aNFEDanfe[16],@ aNFEDanfe[17]);
		F3 CpoRetF3("F1_LOJARET");
		SIZE 02,08 HASBUTTON
	aObjetos[17]:cSX1Hlp := "F1_LOJARET"

	@ 53,aPosGet[1,5] SAY OemToAnsi(IIF(cTipo$"DB",STR0164,STR0123)) Of oDlg PIXEL SIZE 40,12                   
	@ 52,aPosGet[1,6] MSGET aObjetos[19] VAR aNFEDanfe[19] ;
		PICTURE X3Picture("F1_FORENT") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_FORENT");       
		VALID CheckSX3("F1_FORENT",aNFEDanfe[19]) .And. NfeFornece(cTipo,@aNFEDanfe[19],@aNFEDanfe[20]);
		F3 CpoRetF3("F1_FORENT");
		SIZE nTamGetFor,08 HASBUTTON
	aObjetos[19]:cSX1Hlp := "F1_FORENT"

	nPosLojaRet := aPosGet[1,6] + nTamGetFor
	@ 52,nPosLojaRet MSGET aObjetos[20] VAR aNFEDanfe[20] ;
		PICTURE X3Picture("F1_LOJAENT") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_LOJAENT");       
		VALID CheckSX3("F1_LOJAENT",aNFEDanfe[20]) .And. NfeFornece(cTipo,@ aNFEDanfe[19],@ aNFEDanfe[20]);
		F3 CpoRetF3("F1_LOJAENT");
		SIZE 02,08 HASBUTTON
	aObjetos[20]:cSX1Hlp := "F1_LOJAENT"

	@ 17,aPosGet[1,7] SAY STR0114 Of oDlg PIXEL SIZE 40,12   // Valor do Pedagio     
	@ 16,aPosGet[1,8] MSGET aObjetos[15] VAR aNFEDanfe[15] ;
		PICTURE X3Picture("F1_VALPEDG") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_VALPEDG");       
		VALID CheckSX3("F1_VALPEDG",aNFEDanfe[15]);
		SIZE 62,08 HASBUTTON
	aObjetos[15]:cSX1Hlp := "F1_VALPEDG"

	@ 29,aPosGet[1,7] SAY STR0113 OF oDlg PIXEL SIZE 035,008 // "Tp. Frete"
	@ 28,aPosGet[1,8] MSCOMBOBOX aObjetos[14] VAR aNFEDanfe[14] ITEMS aCombo WHEN !l103Visual SIZE 075,028 OF oDlg PIXEL
	aObjetos[14]:NAT := nPsTpFrt
	aObjetos[14]:refresh()
	oTpFrete := @aObjetos[14]

	@ 41,aPosGet[1,7] SAY STR0116 OF oDlg PIXEL SIZE 035,008 // "Tipo Ct-e"
	@ 40,aPosGet[1,8] MSCOMBOBOX aObjetos[18] VAR aNFEDanfe[18] ITEMS aComboCTE;
  	WHEN !l103Visual .And. VisualSX3("F1_TPCTE") .And. If("CTE" $ Upper(Trim(cEspecie)),.T.,.F.);
	VALID A103ConsCTE(aNFeDanfe[18]);
	SIZE 075,028 OF oDlg PIXEL
	aObjetos[18]:NAT := nPsTpcTe
	aObjetos[18]:refresh()
	
	@ 53,aPosGet[1,7] SAY "Modalidade" Of oDlg PIXEL SIZE 035,008
	@ 52,aPosGet[1,8] MSCOMBOBOX aObjetos[23] VAR aNFEDanfe[23] ITEMS aComboMod;
  	WHEN !l103Visual .And. VisualSX3("F1_MODAL") .And. If("CTE" $ Upper(Trim(cEspecie)),.T.,(aNFEDanfe[23]:=aComboMod[1],aObjetos[23]:refresh(),.F.));
	VALID A103VldMod(aNFeDanfe[23]);
	SIZE 075,028 OF oDlg PIXEL
	aObjetos[23]:NAT := nPsModal
	aObjetos[23]:refresh()

	@ 05,aPosGet[1,9] SAY STR0124 Of oDlg PIXEL SIZE 40,12        
	@ 04,aPosGet[1,10] MSGET aObjetos[21] VAR aNFEDanfe[21] ;
		PICTURE X3Picture("F1_NUMAIDF") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_NUMAIDF");
		F3 CpoRetF3("F1_NUMAIDF");
		SIZE nTamGetFor-3,08 HASBUTTON
	aObjetos[21]:cSX1Hlp := "F1_NUMAIDF"

	@ 17,aPosGet[1,9] SAY STR0125 Of oDlg PIXEL SIZE 40,12        
	@ 16,aPosGet[1,10] MSGET aObjetos[22] VAR aNFEDanfe[22] ;
		PICTURE X3Picture("F1_ANOAIDF") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_ANOAIDF");
		F3 CpoRetF3("F1_ANOAIDF");
		SIZE 02,08 HASBUTTON
	aObjetos[22]:cSX1Hlp := "F1_ANOAIDF"

	@ 29,aPosGet[1,9] SAY STR0169 Of oDlg PIXEL SIZE 50,12  // Merc. não entreg.
	@ 28,aPosGet[1,10] MSCOMBOBOX aObjetos[24] VAR aNFEDanfe[24] ITEMS aComboMne;
	WHEN !l103Visual .And. VisualSX3("F1_DEVMERC") .And. If(cTipo $ "DBN" .And. cFormul=="S",.T.,(aNFEDanfe[24]:=aComboMne[1],aObjetos[24]:Refresh(),.F.));
	SIZE 25,08 OF oDlg PIXEL
	aObjetos[24]:cSX1Hlp := "F1_DEVMERC"

	//Ponto de Entrada utilizado para habilitar o botão Mais Info. na aba DANFE
	If lMT103DCF
		@ 42,aPosGet[1,9] BUTTON STR0009 SIZE 30 ,11 FONT oDlg:oFont ACTION A103CompDanfe() OF oDlg PIXEL
	EndIf
EndIf
Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103DescMun |Autor ³João Victor Pellegrini³ Data ³06/12/2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Preenche a descricao do Municipio                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cCodMun  = Codigo do Municipio                              ³±±
±±³          ³oDescMun = Objeto da descricao ddo Municipio                ³±±
±±³          ³cDescMun = Descricao do Municipio                           ³±±
±±³          ³cUF      = UF do Municipio                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103DescMun(cCodMun,oDescMun,cDescMun,cUF,nOpc)

Local lRet := .T.
Local aAreaSA2 := SA2->(GetArea())

DEFAULT cUF := ""
Default nOpc	:= 0

If nOpc == 0
	If Empty(cUF) .And. (Type("cA100For")== "C" .And. !Empty(cA100For)) .And. (Type("cLoja")== "C" .And. !Empty(cLoja))
		cUF := Posicione("SA2",1, xFilial("SA2") + cA100For + cLoja , "A2_EST" )	
	EndIf
Endif

If !Empty(cCodMun) .And. cPaisLoc $ "ANG|AUS|BRA|CHI|COL|COS|DOM|EQU|HAI|MEX|PER|PTG|VEN"
	If cUf == ""
		CC2->(dbSetOrder(3))
		lRet := CC2->(MsSeek(xFilial("CC2")+cCodMun))
	Else
		CC2->(dbSetOrder(1))
		lRet := CC2->(MsSeek(xFilial("CC2")+cUF+cCodMun))
	EndIf
	
	If lRet .And. cPaisLoc $ "ANG|AUS|BRA|CHI|COL|COS|DOM|EQU|HAI|MEX|PER|PTG|VEN"
		cDescMun:= CC2->CC2_MUN
		oDescMun:Refresh()
	Else
	   If nOpc == 0
	   		If !Empty(cCodMun) 
				Help( " " , 1 , "ISSINV" )
				cDescMun := ""
			EndIf
		Else
			If !l103Visual
				Help("",1,"NOTEXISTMUN",,"Municipio não existe",1,0)
				cDescMun := ""
			Endif
		EndIf
	Endif
Else
	If nOpc == 1
		cDescMun := ""
		oDescMun:Refresh()
	Endif
EndIf
RestArea(aAreaSA2)
Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFldAdic³Autor  ³ João Victor Pellegrini³ Data ³05/12/2013 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de tratamento do folder para informacoes adicionais   ³±±
±±³          ³do documento                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³oDlg: Objeto da Janela que sera disponibilizado os Get       ³±±
±±³          ³aPosGet: Array com as posicoes dos gets das Infos. Adicionais³±±
±±³          ³aInfAdic: Array com as informacoes adicionais do docto.      ³±±
±±³          ³oDescMun: Objeto da Descrição do Município                   ³±±
±±³          ³cDescMun: Descricao do Municipio                             ³±± 
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFldAdic(oDlg,aPosGet,aInfAdic,oDescMun,cDescMun,l103Visual,lMT116,bRefresh,lMT140)   

Local aObjetos := Array(Len(aInfAdic))

Local cMotRet  := CriaVar("DHI_CODIGO",.F.)
Local cDescRet := CriaVar("DHI_DESCRI",.F.)
Local cHistRet := CriaVar("F1_HISTRET",.F.)
Local oMemoRet
Local nTamGetFor:=TamSX3("A1_COD")[1]
Local nTamLoja :=TamSX3("A1_LOJA")[1]
Local nPosLoja := 0
Local aCombo := {"","1=Sim","2=Não"}
Local lCteOriDest		:= SF1->(ColumnPos("F1_UFORITR")) > 0 .And. SF1->(ColumnPos("F1_MUORITR")) > 0 .And. SF1->(ColumnPos("F1_UFDESTR")) > 0 .And. SF1->(ColumnPos("F1_MUDESTR")) > 0
Local cMunOri			:= ""
Local oMunOri
Local cMunDest		:= ""
Local oMunDest
Local aPos			:= {}
Local aPos140		:= {}
Local aIndPres		:= {}
Local nF1IndPres 	:= 0
Local lDevRetorna 	:= FwIsInCallStack("A103ProcDv")
Local lClas			:= .F.
Local lMT103		:= FwIsInCallStack("MATA103")

Default lMT116 		:= .F.
Default l103Visual 	:= .F.
Default lMT140		:= .F.

If Type("l103Class") <> "L"
	l103Class := .F.
Endif

If !lMT140 .And. !lMT116
	lClas := l103Class
Endif

If l103Visual .And. !lMT140 
	cMotRet  := SF1->F1_MOTRET
	cDescRet := Posicione("DHI",1,xFilial("DHI")+cMotRet,"DHI_DESCRI") 
	cHistRet := SF1->F1_HISTRET
EndIf
  
If cPaisLoc == "BRA" .And. !lMT116 .And. !lMT140
    @ aPosGet[1,1],aPosGet[1,2]    SAY "UF. Incid. ISS:" OF oDlg PIXEL SIZE 100,100 //"UF Incid. ISS:"
	@ aPosGet[1,1] -1,aPosGet[1,2]+ 35 MSGET aObjetos[18] VAR aInfAdic[18] PICTURE X3Picture("CC2_EST") ; 
		WHEN !l103Visual .And. !SuperGetMV("MV_ISSXMUN",.F.,.F.) ;
		VALID Vazio(aInfAdic[18]) .or. (ExistCpo("SX5","12" + aInfAdic[18]) .And. Eval( {|| M->F1_ESTPRES := aInfAdic[18] , lEditMun:= .T. } ) .And. ;
		MaFisAlt("NF_UFPREISS",aInfAdic[18],));
		F3 "12" OF oDlg PIXEL SIZE 10,08 HASBUTTON 

	@ aPosGet[1,1],aPosGet[1,2] + 65 SAY STR0151 Of oDlg PIXEL SIZE 48,12 //"Descrição Municipio"
	@ aPosGet[1,1] - 1,aPosGet[1,2] + 110 MSGET aObjetos[01] VAR aInfAdic[01] ;
		PICTURE PesqPict("SF1","F1_INCISS") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_INCISS") .And. !SuperGetMV("MV_ISSXMUN",.F.,.F.) ;
		F3 "CC2SF1" ;  
		VALID A103DescMun(@aInfAdic[01], @oDescMun, @cDescMun, aInfAdic[18]);
		SIZE 40,09 HASBUTTON
	aObjetos[01]:cSX1Hlp := "F1_INCISS"
	
	@ aPosGet[1,1] - 1,aPosGet[1,2] + 150 MSGET oDescMun VAR cDescMun WHEN .F. OF oDlg PIXEL SIZE 130,006		

	@ aPosGet[1,1], aPosGet[1,2] + 290 SAY STR0156 Of oDlg PIXEL SIZE 32,12    // Veiculo 1
	@ aPosGet[1,1] - 1,aPosGet[1,2] + 320 MSGET aObjetos[02] VAR aInfAdic[02] ;                   
		PICTURE X3Picture("F1_VEICUL1") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_VEICUL1");  
    	F3 CpoRetF3("F1_VEICUL1");
    	VALID CheckSX3("F1_VEICUL1",aInfAdic[02]) .And. (Vazio() .Or. ExistCpo("DA3"));
		SIZE 50,08 HASBUTTON
	aObjetos[02]:cSX1Hlp    := "F1_VEICUL1"	   

	@ aPosGet[1,1], aPosGet[1,2] + 390 SAY STR0157 Of oDlg PIXEL SIZE 32,12    // Veiculo 2
	@ aPosGet[1,1] - 1,aPosGet[1,2] + 420 MSGET aObjetos[03] VAR aInfAdic[03] ;
		PICTURE X3Picture("F1_VEICUL2") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_VEICUL2");
    	F3 CpoRetF3("F1_VEICUL2");
    	VALID CheckSX3("F1_VEICUL2",aInfAdic[03]) .And. (Vazio() .Or. ExistCpo("DA3"));
		SIZE 50,08 HASBUTTON
	aObjetos[03]:cSX1Hlp    := "F1_VEICUL2"

	@ aPosGet[1,1], aPosGet[1,2] + 490 SAY STR0158 Of oDlg PIXEL SIZE 32,12    // Veiculo 3
	@ aPosGet[1,1] - 1,aPosGet[1,2] + 520 MSGET aObjetos[04] VAR aInfAdic[04] ;
		PICTURE X3Picture("F1_VEICUL3") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_VEICUL3");
    	F3 CpoRetF3("F1_VEICUL3");
    	VALID CheckSX3("F1_VEICUL3",aInfAdic[04]) .And. (Vazio() .Or. ExistCpo("DA3"));
		SIZE 50,08 HASBUTTON
	aObjetos[04]:cSX1Hlp    := "F1_VEICUL3"

	@ aPosGet[1,1] +15,aPosGet[1,2] + 120 SAY "Data de Competência" Of oDlg PIXEL SIZE 80,12
	@ aPosGet[1,1] +14,aPosGet[1,2] + 200 MSGET aObjetos[05] VAR aInfAdic[05] ;
		PICTURE "" ;
		OF oDlg PIXEL ; 
		WHEN !l103Visual .And. VisualSX3("F1_DTCPISS") ;
		SIZE 80,09 HASBUTTON
	aObjetos[05]:cSX1Hlp := "F1_DTCPISS"
		
	If SuperGetMV("MV_MT103SN",.F.,.F.)
		@ aPosGet[1,1], aPosGet[1,2] + 520 SAY "Opt Simp Nac" Of oDlg PIXEL SIZE 35,20   // Simples Nacional
		@ aPosGet[1,1] - 1,aPosGet[1,2] + 560 MSCOMBOBOX aObjetos[06] VAR aInfAdic[06] ITEMS aCombo ;	
		WHEN !l103Visual .And. VisualSX3("F1_SIMPNAC") ;//criar parametro
		VALID CheckSX3("F1_SIMPNAC",aInfAdic[06]);
		SIZE 055,08 OF oDlg PIXEL
		aObjetos[06]:cSX1Hlp    := "F1_SIMPNAC"
	EndIf
   	
	@ aPosGet[1,1]+15, aPosGet[1,2] + 310 SAY "Cliente de Entrega" Of oDlg PIXEL SIZE 80,12
	@ aPosGet[1,1] +14,aPosGet[1,2] + 360 MSGET aObjetos[07] VAR aInfAdic[07] ;	
		PICTURE X3Picture("F1_CLIDEST") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_CLIDEST") .And. (AllTrim(cEspecie) $ "CTR/CTE/CTA/CA/CTF" .Or. "NFST"$AllTrim(cEspecie));
		F3 CpoRetF3("F1_CLIDEST");
		VALID CheckSX3("F1_CLIDEST",aInfAdic[07]) .And. (existcpo("SA1") .Or. Vazio());
		SIZE nTamGetFor,08 HASBUTTON
	aObjetos[07]:cSX1Hlp := "F1_CLIDEST"

	nPosLoja := aPosGet[1,2] + 400 	
	@ aPosGet[1,1] +14,nPosLoja MSGET aObjetos[08] VAR aInfAdic[08] ;
		PICTURE X3Picture("F1_LOJDEST") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_LOJDEST") .And. (AllTrim(cEspecie) $ "CTR/CTE/CTA/CA/CTF" .Or. "NFST"$AllTrim(cEspecie));
		F3 CpoRetF3("F1_LOJDEST");
		VALID CheckSX3("F1_LOJDEST",aInfAdic[08]) .And. IIf(bGdRefresh <> NIL, Eval( bGdRefresh ), .T.);		
		SIZE nTamLoja,08 HASBUTTON
	aObjetos[08]:cSX1Hlp := "F1_LOJDEST"
	If SF1->(ColumnPos("F1_CLIPROP")) > 0 .And. SF1->(ColumnPos("F1_LJCLIPR")) > 0	
		@ aPosGet[1,1] + 15, aPosGet[1,2]  SAY 'Cliente Proprietario' Of oDlg PIXEL SIZE 80,12    
		@ aPosGet[1,1] + 14,aPosGet[1,2] + 50 MSGET aObjetos[14] VAR aInfAdic[14] ;
			PICTURE X3Picture("F1_CLIPROP") ;
			OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_CLIPROP") .and. cTipo $ "B";
			F3 CpoRetF3("F1_CLIPROP");
			VALID CheckSX3("F1_CLIPROP",aInfAdic[14]) .And. (existcpo("SA1") .Or. Vazio());
			SIZE nTamGetFor,08 HASBUTTON
		aObjetos[14]:cSX1Hlp := "F1_CLIPROP" 

		nPosLoja := aPosGet[1,2] + 90	
		@ aPosGet[1,1] +14,nPosLoja MSGET aObjetos[15] VAR aInfAdic[15] ;
			PICTURE X3Picture("F1_LJCLIPR") ;
			OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_LJCLIPR") .and. cTipo $ "B";
			F3 CpoRetF3("F1_LJCLIPR");
			VALID CheckSX3("F1_LJCLIPR",aInfAdic[15]) .And. IIf(bGdRefresh <> NIL, Eval( bGdRefresh ), .T.);		
			SIZE nTamLoja,08 HASBUTTON
		aObjetos[15]:cSX1Hlp := "F1_LJCLIPR"
	EndIf 
EndIf

If SF1->(FieldPos("F1_MOTRET")) > 0 .And. l103Visual .And. !lMT116 .And. !lMT140

	If !Empty(cMotRet)
		@ aPosGet[1,1]+15,aPosGet[1,2]+330  SAY RetTitle("F1_MOTRET")   Of oDlg PIXEL
		@ aPosGet[1,1]+14,aPosGet[1,2]+360  MSGET cMotRet  SIZE  60, 10 Of oDlg PIXEL When .F. 
		
		@ aPosGet[1,1]+15,aPosGet[1,2]+430  SAY RetTitle("DHI_DESCRI")   Of oDlg PIXEL
		@ aPosGet[1,1]+14,aPosGet[1,2]+470  MSGET cDescRet SIZE 180, 10 Of oDlg PIXEL When .F.
	
		@ aPosGet[1,1]+45,aPosGet[1,2]+490 SAY RetTitle("F1_HISTRET")  Of oDlg PIXEL
		@ aPosGet[1,1]+30,aPosGet[1,2]+520 GET oMemoRet VAR cHistRet   Of oDlg MEMO  When .F. size 140,30 PIXEL
	EndIf
	
EndIf

If lCteOriDest .And. !lMT140
	If lMT116
		aAdd(aPos,{0,-1,15,14})
	Else
		aAdd(aPos,{30,29,45,44})
	Endif
	
	//Origem
	@ aPosGet[1,1]+aPos[1,1],aPosGet[1,2] SAY STR0175 Of oDlg PIXEL SIZE 80,12 //"UF Origem transporte"
	@ aPosGet[1,1]+aPos[1,2],aPosGet[1,2]+80 MSGET aObjetos[10] VAR aInfAdic[10] ;
			PICTURE X3Picture("F1_UFORITR")	OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_UFORITR") ;
			F3 CpoRetF3("F1_UFORITR");
			VALID CheckSX3("F1_UFORITR",aInfAdic[10]) .And. A103UFREF() .And. IIf(bGdRefresh <> NIL, Eval( bGdRefresh ), .T.)  ;		
			SIZE 20,08 HASBUTTON
		aObjetos[10]:cSX1Hlp := "F1_UFORITR"
		
	@ aPosGet[1,1]+aPos[1,1],aPosGet[1,2]+120 SAY STR0176 Of oDlg PIXEL SIZE 80,12 //"Municipio Origem transporte"
	@ aPosGet[1,1]+aPos[1,2],aPosGet[1,2]+190 MSGET aObjetos[11] VAR aInfAdic[11] ;
			PICTURE X3Picture("F1_MUORITR")	OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_MUORITR").And. If(!Empty(ALLTRIM(aInfAdic[10])),.T.,.F.) ;
			F3 CpoRetF3("F1_MUORITR");
			VALID CheckSX3("F1_MUORITR",aInfAdic[11]) .And. A103DescMun(aInfAdic[11],@oMunOri,@cMunOri,AllTrim(aInfAdic[10]),1) .And. IIf(bGdRefresh <> NIL, Eval( bGdRefresh ), .T.)  ;		
			SIZE 40,08 HASBUTTON
		aObjetos[11]:cSX1Hlp := "F1_MUORITR"
		
	@ aPosGet[1,1]+aPos[1,2],aPosGet[1,2]+ 240 MSGET oMunOri VAR cMunOri WHEN .F. OF oDlg PIXEL SIZE 130,006
	If l103Visual .Or. !Empty(SF1->F1_UFORITR)
		A103DescMun(aInfAdic[11],@oMunOri,@cMunOri,AllTrim(aInfAdic[10]),1)
	Endif
	
	//Destino
	@ aPosGet[1,1]+aPos[1,3],aPosGet[1,2] SAY STR0177 Of oDlg PIXEL SIZE 80,12 //"UF Destino transporte"
	@ aPosGet[1,1]+aPos[1,4],aPosGet[1,2]+80 MSGET aObjetos[12] VAR aInfAdic[12] ;
			PICTURE X3Picture("F1_UFDESTR")	OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_UFDESTR") ;
			F3 CpoRetF3("F1_UFDESTR");
			VALID CheckSX3("F1_UFDESTR",aInfAdic[12]) .And. A103UFDEST() .And. IIf(bGdRefresh <> NIL, Eval( bGdRefresh ), .T.)  ;		
			SIZE 20,08 HASBUTTON
		aObjetos[12]:cSX1Hlp := "F1_UFDESTR"
		
	@ aPosGet[1,1]+aPos[1,3],aPosGet[1,2]+120 SAY STR0178 Of oDlg PIXEL SIZE 80,12 //"Municipio Destino transporte"
	@ aPosGet[1,1]+aPos[1,4],aPosGet[1,2]+190 MSGET aObjetos[13] VAR aInfAdic[13] ;
			PICTURE X3Picture("F1_MUDESTR")	OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_MUDESTR") .And. If(!Empty(ALLTRIM(aInfAdic[12])),.T.,.F.) ;
			F3 CpoRetF3("F1_MUDESTR");
			VALID CheckSX3("F1_MUDESTR",aInfAdic[13]) .And. A103DescMun(aInfAdic[13],@oMunDest,@cMunDest,AllTrim(aInfAdic[12]),1) .And. IIf(bGdRefresh <> NIL, Eval( bGdRefresh ), .T.)  ;		
			SIZE 40,08 HASBUTTON
		aObjetos[13]:cSX1Hlp := "F1_MUDESTR"

	@ aPosGet[1,1]+aPos[1,4],aPosGet[1,2] + 240 MSGET oMunDest VAR cMunDest WHEN .F. OF oDlg PIXEL SIZE 130,006
	If l103Visual .Or. !Empty(SF1->F1_UFDESTR)
		A103DescMun(aInfAdic[13],@oMunDest,@cMunDest,AllTrim(aInfAdic[12]),1)
	Endif
Endif 

If cPaisLoc == "BRA" .And. Type("lIntermed") == "L" .And. lIntermed
	If lMT140 
		aAdd(aPos140,{0,-1,15,14,0,50})
	Elseif lMT116
		aAdd(aPos140,{30,29,45,44,0,50})
	Else
		aAdd(aPos140,{30,29,45,44,380,430}) 
	Endif

	aIndPres := LoadX3Arr("F1_INDPRES")
	If !Empty(aInfAdic[16])
		If l103Visual .Or. lDevRetorna .Or. lMT116 .Or. lMT140 .Or. l103Class .Or. ( lMT103 .and. INCLUI )
			nF1IndPres := aScan(aIndPres ,{|x| AllTrim(Substr(x,1,1)) == AllTrim(aInfAdic[16])})
			If nF1IndPres == 0
				nF1IndPres := aScan(aIndPres ,{|x| AllTrim(Substr(x,1)) == AllTrim(aInfAdic[16])})
			Endif  
		Endif		 		            
	EndIf	
	nF1IndPres := Max(1,nF1IndPres)

	@ aPosGet[1,1]+aPos140[1,1],aPosGet[1,2]+aPos140[1,5] SAY RetTitle("F1_INDPRES") OF oDlg PIXEL SIZE 40,09
	@ aPosGet[1,1]+aPos140[1,2],aPosGet[1,2]+aPos140[1,6] MSCOMBOBOX aObjetos[16] VAR aInfAdic[16] ITEMS aIndPres ;
		WHEN (!l103Visual) .And. VisualSX3("F1_INDPRES") ;
		VALID A103VldPres() SIZE 85 ,9 OF oDlg PIXEL  
	aObjetos[16]:bChange := {|| A103ChgPres()}      
	aObjetos[16]:NAT := nF1IndPres    

	@ aPosGet[1,1]+aPos140[1,3],aPosGet[1,2]+aPos140[1,5] SAY RetTitle("F1_CODA1U") Of oDlg PIXEL SIZE 40,12
	@ aPosGet[1,1]+aPos140[1,4],aPosGet[1,2]+aPos140[1,6] MSGET aObjetos[17] VAR aInfAdic[17] ;
			PICTURE X3Picture("F1_CODA1U")	OF oDlg PIXEL ;   
			WHEN !l103Visual .And. VisualSX3("F1_CODA1U");
			F3 CpoRetF3("F1_CODA1U");
			VALID A103VldA1U() ;		
			SIZE 50,08 HASBUTTON   
Endif 

bRefresh := {|| NfeRFldAdic(aObjetos)} 

Return

/*/
{Protheus.doc} NfeRFldAdic
Refresh Foldes Informações adicionais
NT2020-006

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Static Function NfeRFldAdic(aObjetos) 

Local nX			:= 1
Local nF1IndPres	:= 0

For nX := 1 To Len(aObjetos)
	If nX == 16
		aIndPres := LoadX3Arr("F1_INDPRES")
		If !Empty(aInfAdic[16])
			nF1IndPres := aScan(aIndPres ,{|x| AllTrim(Substr(x,1,1)) == AllTrim(aInfAdic[16])})
			If nF1IndPres == 0
				nF1IndPres := aScan(aIndPres ,{|x| AllTrim(Substr(x,1)) == AllTrim(aInfAdic[16])})
			Endif 
		EndIf	
		nF1IndPres := Max(1,nF1IndPres)
	Endif
	If aObjetos[nX]<>Nil
		If nX == 16
			aObjetos[nX]:NAT := nF1IndPres 
		Endif
		aObjetos[nX]:Refresh()
	EndIf
Next nX

Return


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeVincOri³Autor  ³ Marcelo Custodio      ³ Data ³15/12/2008 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Permite consultar as notas de saida de devolucao do produto  ³±±
±±³          ³para vincular no documento de entrada - Projeto Oleo e Gas - ³±±
±±³          ³Pilar 1                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Informa o codigo do fornecedor                        ³±±
±±³          ³ExpC2: Informa codigo da loja                                ³±±
±±³          ³ExpC3: Informa o codigo do produto                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                         y    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeVincOri(cCodForn,cCodLoja,cCodProd)
Local oTempTable := NIL
Local cQuery     := ""
Local cAlias     := ""
Local nPosCod	 := aScan(aHeader,{|x| AllTrim(x[2])=='D1_COD'})
Local aSize      := MsAdvSize( .F. )
Local aObjects   := {}
Local aInfo      := {}
Local aArea      := GetArea()
Local aAreaSB1   := SB1->(GetArea())
Local aAreaSA2   := SA2->(GetArea())
Local aOrdem     := {AllTrim(RetTitle("F2_DOC"))+"+"+AllTrim(RetTitle("F2_SERIE")),AllTrim(RetTitle("F2_EMISSAO"))}
Local aPesq      := {{Space(Len(SD1->D1_DOC+SD1->D1_SERIE)),"@!"},{Ctod(""),"@!"}}
Local aSavHead   := aClone(aHeader)
Local lContinua  := .T.
Local aHeadTrb   := {}
Local aStruTrb   := {}
Local cAliasTRB  := ""
Local nPosNfVinc := aScan(aHeader,{|x| AllTrim(x[2])=='D1_NFVINC'})
Local nPosSeVinc := aScan(aHeader,{|x| AllTrim(x[2])=='D1_SERVINC'})
Local nPosItVinc := aScan(aHeader,{|x| AllTrim(x[2])=='D1_ITMVINC'})
Local oGetDb
Local nX
Local oPanel
Local oDlg
Local oCombo
Local cCombo
Local oGet
Local xPesq
Local nOpca

//Preenche os filtros com os valores definidos na nota
DEFAULT cCodForn := cA100For
DEFAULT cCodLoja := cLoja
DEFAULT cCodProd := aCols[n][nPosCod]

lContinua := (!Empty(cCodForn) .AND. !Empty(cCodLoja) .AND. !Empty(cCodProd) .And. !Empty(nPosNfVinc) .And. !Empty(nPosSeVinc) .And. !Empty(nPosItVinc))

If lContinua
	SB1->(dbSetOrder(1))
	SA2->(dbSetOrder(1))

	lContinua := (SB1->(dbSeek(xFilial("SB1")+cCodProd)) .And. SA2->(dbSeek(xFilial("SA2")+cCodForn+cCodLoja)))

	If lContinua
	
		//Monta estrutura do arquivo temporario
		dbSelectArea("SX3")
		dbSetOrder(1)
		MsSeek("SD2")
		While !Eof() .And. SX3->X3_ARQUIVO == "SD2"
			If ( X3USO(SX3->X3_USADO) .And. cNivel >= SX3->X3_NIVEL .And. SX3->X3_CONTEXT<>"V" .And. SX3->X3_TIPO<>"M" .And. !(SX3->X3_CAMPO $ "D2_CLIENTE,D2_LOJA") ) .OR. (AllTrim(SX3->X3_CAMPO) $ "D2_DOC,D2_SERIE,D2_EMISSAO")
				Aadd(aHeadTrb,{ TRIM(X3Titulo()),;
					SX3->X3_CAMPO,;
					SX3->X3_PICTURE,;
					SX3->X3_TAMANHO,;
					SX3->X3_DECIMAL,;
					SX3->X3_VALID,;
					SX3->X3_USADO,;
					SX3->X3_TIPO,;
					SX3->X3_ARQUIVO,;
					SX3->X3_CONTEXT,;
					IIf(AllTrim(SX3->X3_CAMPO)$"D2_DOC,D2_SERIE,D2_ITEM,D2_COD","00",SX3->X3_ORDEM) })
				aadd(aStruTRB,{SX3->X3_CAMPO,SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL,IIf(AllTrim(SX3->X3_CAMPO)$"D2_DOC,D2_SERIE,D2_ITEM,D2_COD","00",SX3->X3_ORDEM)})
			EndIf				
			dbSelectArea("SX3")
			dbSkip()
		EndDo
		
		aHeadTrb := aSort(aHeadTrb,,,{|x,y| x[11] < y[11]})
		aStruTrb := aSort(aStruTrb,,,{|x,y| x[05] < y[05]})
		
		//Gera arquivo temporario
		cAliasTRB := GetNextAlias()
		oTempTable := FWTemporaryTable():New( cAliasTRB )
		oTempTable:SetFields( aStruTRB )
		oTempTable:AddIndex("indice1", {"D2_DOC","D2_SERIE"} )
		oTempTable:AddIndex("indice2", {"D2_EMISSAO"} )
		oTempTable:Create()
		
		PRIVATE aHeader := aHeadTRB
		xPesq := aPesq[(cAliasTRB)->(IndexOrd())][1]
	
		//Filtra notas de devolucao do fornecedor e produto informados
		cQuery := "SELECT SD2.R_E_C_N_O_ AS RECNO "
		cQuery += "  FROM " + RetSQLName("SD2") + " SD2, " + RetSQLName("SF2") + " SF2, " + RetSQLName("SF4") + " SF4 "
		cQuery += " WHERE SD2.D2_FILIAL  = '" + xFilial("SD2") + "'"
		cQuery += "   AND SF2.F2_FILIAL  = '" + xFilial("SF2") + "'"
		cQuery += "   AND SF4.F4_FILIAL  = '" + xFilial("SF4") + "'"
		cQuery += "   AND SD2.D2_DOC     = SF2.F2_DOC    "
		cQuery += "   AND SD2.D2_TES     = SF4.F4_CODIGO "
		cQuery += "   AND SD2.D2_COD     = '" + SB1->B1_COD + "'"
		cQuery += "   AND SF2.F2_CLIENTE = '" + SA2->A2_COD + "'"
		cQuery += "   AND SF2.F2_LOJA    = '" + SA2->A2_LOJA + "'"
		cQuery += "   AND (SF4.F4_PODER3 = 'D' OR SF2.F2_TIPO = 'D')"
		cQuery += "   AND SD2.D_E_L_E_T_ = ' ' "
		cQuery += "   AND SF2.D_E_L_E_T_ = ' ' "
		cQuery += "   AND SF4.D_E_L_E_T_ = ' '"
		
		cAlias := GetNextAlias()
		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)
		
		//Preenche arquivo temporario
		While !(cAlias)->(Eof())
			SD2->(MsGoto((cAlias)->RECNO))
			
			If !SD2->(Eof())
				RecLock(cAliasTRB,.T.)
				For nX := 1 To Len(aStruTRB)
					(cAliasTRB)->(FieldPut(nX,SD2->(FieldGet(FieldPos(aStruTRB[nX][1])))))
				Next nX
				MsUnlock()
			EndIf

			(cAlias)->(dbSkip())
		EndDo
		(cAlias)->(DbCloseArea())
		
		If !(cAliasTRB)->(Eof())
			//Calcula dimensoes da tela
			aSize[1] /= 1.5
			aSize[2] /= 1.5
			aSize[3] /= 1.5
			aSize[4] /= 1.3
			aSize[5] /= 1.5
			aSize[6] /= 1.3
			aSize[7] /= 1.5
			
			AAdd( aObjects, { 100, 020,.T.,.F.,.T.} )
			AAdd( aObjects, { 100, 060,.T.,.T.} )
			AAdd( aObjects, { 100, 020,.T.,.F.} )
			aInfo   := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 }
			aPosObj := MsObjSize( aInfo, aObjects,.T.)
			
			DEFINE MSDIALOG oDlg TITLE STR0065 FROM aSize[7],000 TO aSize[6],aSize[5] OF oMainWnd PIXEL //"Vinculo - Documento de Saída"
			@ aPosObj[1,1],aPosObj[1,2] MSPANEL oPanel PROMPT "" SIZE aPosObj[1,3],aPosObj[1,4] OF oDlg CENTERED LOWERED
			cTexto1 := AllTrim(RetTitle("F2_CLIENTE"))+"/"+AllTrim(RetTitle("F2_LOJA"))+": "+SA2->A2_COD+"/"+SA2->A2_LOJA+"  -  "+RetTitle("A2_NOME")+": "+;
			If(lLGPD,RetTxtLGPD(SA2->A2_NOME,"A2_NOME"),SA2->A2_NOME)
			@ 002,005 SAY cTexto1 SIZE aPosObj[1,3],008 OF oPanel PIXEL
			cTexto2 := AllTrim(RetTitle("B1_COD"))+": "+SB1->B1_COD+"/"+SB1->B1_DESC
			@ 012,005 SAY cTexto2 SIZE aPosObj[1,3],008 OF oPanel PIXEL	
	
			oGetDb := MsGetDB():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],1,"Allwaystrue","allwaystrue","",.F., , ,.F., ,cAliasTRB)
			
			DEFINE SBUTTON FROM aPosObj[3,1]+000,aPosObj[3,4]-030 TYPE 1 ACTION (nOpcA := 1,oDlg:End()) ENABLE OF oDlg
			DEFINE SBUTTON FROM aPosObj[3,1]+012,aPosObj[3,4]-030 TYPE 2 ACTION (nOpcA := 0,oDlg:End()) ENABLE OF oDlg
			
			@ aPosObj[3,1]+00,aPosObj[3,2]+00 SAY STR0066 PIXEL //"Pesquisar por:"
			@ aPosObj[3,1]+12,aPosObj[3,2]+00 SAY STR0067 PIXEL //"Localizar"
			@ aPosObj[3,1]+00,aPosObj[3,2]+40 MSCOMBOBOX oCombo VAR cCombo ITEMS aOrdem SIZE 100,044 OF oDlg PIXEL ;
				VALID ((cAliasTRB)->(dbSetOrder(oCombo:nAt)),(cAliasTRB)->(dbGotop()),xPesq := aPesq[(cAliasTRB)->(IndexOrd())][1],.T.)
			@ aPosObj[3,1]+12,aPosObj[3,2]+40 MSGET oGet VAR xPesq Of oDlg PICTURE aPesq[(cAliasTRB)->(IndexOrd())][2] PIXEL ;
				VALID ((cAliasTRB)->(MsSeek(Iif(ValType(xPesq)=="C",AllTrim(xPesq),xPesq),.T.)),.T.).And.IIf(oGetDb:oBrowse:Refresh()==Nil,.T.,.T.)
			ACTIVATE MSDIALOG oDlg CENTERED
			
			If nOpca == 1
				//Carrega documento selecionado
				aCols[n,nPosNfVinc] := (cAliasTRB)->D2_DOC
				aCols[n,nPosSeVinc] := (cAliasTRB)->D2_SERIE
				aCols[n,nPosItVinc] := (cAliasTRB)->D2_ITEM
			EndIf
		Else
			Aviso(STR0018,STR0068,{"OK"}) //"Atenção"###"Não existe devolução para o fornecedor/produto informado"
		EndIf
		
		dbSelectArea(cAliasTRB)
		dbCloseArea()
	EndIf
Else
	Aviso(STR0018,STR0069,{"OK"}) //"Atenção"###"Informe o fornecedor e o produto"
EndIf

aHeader   := aClone(aSavHead)

RestArea(aAreaSA2)
RestArea(aAreaSB1)
RestArea(aArea)

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeVldVinc³Autor  ³ Marcelo Custodio      ³ Data ³15/12/2008 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Valida o documento de saida informado no vinculo             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Informa o campo a ser validado                        ³±±
±±³          ³       1 - Documento                                         ³±±
±±³          ³       2 - Serie                                             ³±±
±±³          ³       3 - Item                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeVldVinc(nFld)
Local cValor     := &(ReadVar())
Local nPosNfVinc := aScan(aHeader,{|x| AllTrim(x[2])=='D1_NFVINC'})
Local nPosSeVinc := aScan(aHeader,{|x| AllTrim(x[2])=='D1_SERVINC'})
Local nPosProd   := aScan(aHeader,{|x| AllTrim(x[2])=='D1_COD'})
Local lRet       := .T.

SD2->(DbSetOrder(3))

Do Case
	Case nFld==1//Valida documento
		lRet := SD2->(dbSeek(xFilial("SD2")+cValor))
	Case nFld==2//Valida Serie
		lRet := SD2->(dbSeek(xFilial("SD2")+aCols[n,nPosNfVinc]+cValor))
	Case nFld==3//Valida Item
		lRet := SD2->(dbSeek(xFilial("SD2")+aCols[n,nPosNfVinc]+aCols[n,nPosSeVinc]+cA100For+cLoja+aCols[n][nPosProd]+cValor))
EndCase

If lRet//Valida TES de devolucao
	SF4->(dbSetOrder(1))
	lRet := (SF4->(dbSeek(xFilial("SF4")+SD2->D2_TES)) .And. (SF4->F4_PODER3 == "D" .OR. SD2->D2_TIPO == "D"))
EndIf

If !lRet
	Aviso(STR0018,STR0070,{"OK"}) //"Atenção"###"Documento de saída inválido"
EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103LCF   ³ Autor ³ Julio C Guerato       ³ Data ³22.01.2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Funcao que aplica ponto de entrada para manipular o bloqueio³±±
±±³          ³ou desbloqueio de campos. 								  ³±±
±±³          ³Nao existindo o campo no ponto de entrada, sera retornado   ³±±
±±³          ³.T. a fim de que o programa continue operando normalmente.  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Nome do Campo 				                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL:  Retorna .F. ou .T. 					              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MATA103X                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103LCF(cCampo)

Local lRet103 	:= .T.
Local aArea    	:= GetArea()
Local aAreaSX3 	:= SX3->(GetArea())
Local lMT103LCF := ExistBlock("MT103LCF")

DbSelectArea('SX3')
DbSetOrder(2)

// Se não houver o ponto de entrada que determina o bloqueio ou a edição de um campo,
// a função retornará o que estiver no SX3.

If MsSeek(cCampo)
	If( SX3->X3_VISUAL=="V" .OR. (IIF(ALLTRIM(SX3->X3_WHEN) == '',.F.,ALLTRIM(SX3->X3_WHEN))))
		lRet103	:=	.F.
	EndIf
EndIf

If cCampo != Nil
	If lMT103LCF
		lRet103 := ExecBlock("MT103LCF",.F.,.F.,{cCampo})
		If!ValType(lRet103)=="L"
			lRet103 := .T.
		Endif
	EndIf
EndIf

RestArea(aAreaSX3)
RestArea(aArea)
Return(lRet103) 

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103VLDCPO³ Autor ³ Julio C Guerato       ³ Data ³11/12/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Funcao para verificar se um determinado caracter existe em  ³±±
±±³          ³uma variável				 								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Variável com conteudo que será validado              ³±±
±±³			 ³ExpC2: Caracter a ser procurado na String                   ³±±
±±³			 ³ExpN1: Tipo de verificação				                  ³±±
±±³			 ³  	 0 = Verifica se existe algum caracterer de ExpC2 que ³±±
±±³			 ³		   	 que não é permitido em ExpC1					  ³±±
±±³			 ³		 1 = Verifica se todos os caracteres de ExpC1 existem ³±±
±±³			 ³		   	 em ExpC2										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL:  Retorna .F. ou .T. 					              ³±±
±±³		     ³.F. = Caracter Não Existe / .T. = Caracter Existe           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MATA103X                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103VldCpo(cValor, cCarac, nTipo)
                                
Local lRet := .F.                                      
Local nX   := 0  
Local nCT  := 0
Default nTipo:=0

If Len(cValor)>0 .And. Len(cCarac)>0
	If nTipo==0
	    For nX:=1 To len(cCarac)
    	     if RAT(SUBSTR(cCarac,nX,1),cValor)>0 .And. !lRet
        	    lRet:= .T.
	         EndIf
    	Next nX     
 	Else
 	    For nX:=1 To len(Trim(cValor))
    	     if RAT(SUBSTR(cValor,nX,1),cCarac)=0
    	     	nCT++ 
	         EndIf
    	Next nX                                              
    	lRet:=iif(nCT>0,.F.,.T.)
  	EndIf
EndIF

Return (lRet)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103VLDNFO³ Autor ³ Julio C Guerato       ³ Data ³30/12/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Funcao para validar todos os Documentos vinculados aos itens³±±
±±³          ³de uma nota fiscal		 								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±  
±±³Parametros³ nItem = Número do Item no Acols                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±  
±±³Retorno   ³ExpL:  Retorna .F. ou .T. 					              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MATA103X                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103VldNFO(n)
                                
Local lRet  	 := .T.       
Local cItem 	 := ""
Local nPosItmOri := GetPosSD1("D1_ITEMORI")

If cTipo$"DCPI"      
    cItem:=IIf(Empty(aCols[n][nPosItmOri]),"x",aCols[n][nPosItmOri])  
    lRet:=A103ITDEV(cItem)
EndIf

Return(lRet)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RatPed2NF ºAutor  ³Microsiga           º Data ³  06/18/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Carrega automaticamente o rateio do item da Nota fiscal    º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RatPed2NF(aHeadSDE,aColsSDE,cItem,nRecSC7,aRateioCC)
Local aArea			:= GetArea()
Local nPosItem		:= Ascan(aHeadSDE,{|x| AllTrim(x[2]) == "DE_ITEM"} )
Local nPosPerc		:= Ascan(aHeadSDE,{|x| AllTrim(x[2]) == "DE_PERC"} )
Local nPosCC		:= Ascan(aHeadSDE,{|x| AllTrim(x[2]) == "DE_CC"} )
Local nPosConta		:= Ascan(aHeadSDE,{|x| AllTrim(x[2]) == "DE_CONTA"} )
Local nPosItCta		:= Ascan(aHeadSDE,{|x| AllTrim(x[2]) == "DE_ITEMCTA"} )
Local nPosCLVL		:= Ascan(aHeadSDE,{|x| AllTrim(x[2]) == "DE_CLVL"} )
Local nPosACols		:= Ascan(aColsSDE,{|x| AllTrim(x[1]) == Alltrim(cItem) } )
Local nCt			:= 0
Local nLinha		:= 0
Local nX			:= 0
Local nPos			:= 0
Local nPosRatCC		:= 0
Local nPosRatPer	:= 0
Local nPosRatCLVL	:= 0
Local nPosRatItCta	:= 0
Local nPosRatConta	:= 0
Local aAux			:= {}
Local aEntidades	:= {}
Local nEnt			:= 0
Local nDeb			:= 0
Local nTamItem		:= TamSX3("DE_ITEM")[1]
Local lSC7Exclsv	:= FWModeAcces("SC7", 1) + FWModeAcces("SC7", 2) + FWModeAcces("SC7", 3) == "EEE"
Local lCTTExclsv    := FWModeAcces("CTT", 3) == "E"
Local lGetRat		:= .T.
Local lPCFilen		:= SuperGetMv("MV_PCFILEN",.F.,.F.)
Local ny            := 1
Default aRateioCC := {}

If !Empty(aRateioCC)
	If (nPos := Ascan(aRateioCC,{|x| x[1]== cItem})) > 0
		aAux := aRateioCC[nPos][2]
		For nX := 1 To Len(aAux)
			
			If nCt == 0
				If nPosACols <= 0
					aAdd(aColsSDE,{ cItem,{} } )
					nPosACols := Len(aColsSDE)
					nCt+=1
				EndIf
			EndIF
			
			aAdd(aColsSDE[nPosACols][2],Array( Len(aHeadSDE) + 1 ) )
			nLinha++

			For ny := 1 to Len(aAux[nx])

				nPosHead	:= aScan(aHeadSDE,{|x| AllTrim(x[2]) == Alltrim(aAux[1][ny][1])})
				nPos		:= Ascan(aAux[nX],{|x| AllTrim(x[1]) == Alltrim(aAux[1][ny][1])})

				If nPosHead > 0 .And. nPos > 0
					aColsSDE[nPosACols][2][nLinha][nPosHead] := aAux[nx][nPos][2]
				Endif
			Next

			aColsSDE[nPosACols][2][nLinha][nPosItem]  := RetAsc(nLinha,nTamItem,.T.)
			aColsSDE[nPosACols][2][nLinha][Len(aHeadSDE) + 1] := .F.

			aEntidades := CtbEntArr()
			For nEnt := 1 to Len(aEntidades)
				For nDeb := 1 to 2
					cCpo := "DE_EC"+aEntidades[nEnt]
						
					If nDeb == 1
						cCpo += "DB"
					Else
						cCpo += "CR"
					EndIf
						
					nPosHead	:= aScan(aHeadSDE,{|x| AllTrim(x[2]) == Alltrim(cCpo) } )
					nPos		:= Ascan(aAux[nX],{|x| AllTrim(x[1]) == Alltrim(cCpo) } )
						
					If nPosHead > 0 .And. nPos > 0
						aColsSDE[nPosACols][2][nLinha][nPosHead] := aAux[nX][nPos][2]
					EndIf
						
				Next nDeb
			Next nEnt
						
		Next nX	

	EndIf	
Else
	SC7->(MsGoTo(nRecSC7))
	If lCTTExclsv .And. lSC7Exclsv
		lGetRat := SC7->C7_FILIAL == cFilAnt

		If !lGetRat .And. lPCFilen
			lGetRat := SC7->C7_FILENT == cFilAnt
		Endif
	EndIf
	If lGetRat
		dbSelectArea("SCH")
		cFilSCH := xFilial("SCH", Iif(lSC7Exclsv, SC7->C7_FILIAL, cFilAnt))
		SCH->(dbSetOrder(1))//CH_FILIAL+CH_PEDIDO+CH_FORNECE+CH_LOJA+CH_ITEMPD+CH_ITEM
		If SCH->(dbSeek(cFilSCH + SC7->( C7_NUM + C7_FORNECE + C7_LOJA + C7_ITEM ) ))
			While SCH->(!Eof()) .And. SCH->(CH_FILIAL + CH_PEDIDO + CH_FORNECE+ CH_LOJA+ CH_ITEMPD) == cFilSCH + SC7->( C7_NUM + C7_FORNECE + C7_LOJA + C7_ITEM  )
				If nCt == 0
					If nPosACols <= 0
						aAdd(aColsSDE,{ cItem,{} } )
						nPosACols := Len(aColsSDE)
					Else
						aColsSDE[nPosACols][2] := {}
					EndIf
					nCt+=1
				EndIF
				nLinha++
				If len(aColsSDE[nPosACols][2]) < nLinha
					aAdd(aColsSDE[nPosACols][2],Array( Len(aHeadSDE) + 1 ) )
				EndIf
				aColsSDE[nPosACols][2][nLinha][nPosItem]  := RetAsc(Str(nLinha),nTamItem,.T.)
				aColsSDE[nPosACols][2][nLinha][nPosPerc]   	:= SCH->CH_PERC
				aColsSDE[nPosACols][2][nLinha][nPosCC]   	:= SCH->CH_CC
				aColsSDE[nPosACols][2][nLinha][nPosConta]   := SCH->CH_CONTA
				aColsSDE[nPosACols][2][nLinha][nPosItCta]  	:= SCH->CH_ITEMCTA
				aColsSDE[nPosACols][2][nLinha][nPosCLVL]   	:= SCH->CH_CLVL
				aColsSDE[nPosACols][2][nLinha][Len(aHeadSDE) + 1] := .F.
				
				aEntidades := CtbEntArr()
				For nEnt := 1 to Len(aEntidades)
					For nDeb := 1 to 2
						cCpo := "DE_EC"+aEntidades[nEnt]
						cSCH := "CH_EC"+aEntidades[nEnt]
							
						If nDeb == 1
							cCpo += "DB"
							cSCH += "DB"
						Else
							cCpo += "CR"
							cSCH += "CR"
						EndIf
							
						nPosHead := aScan(aHeadSDE,{|x| AllTrim(x[2]) == Alltrim(cCpo) } )
							
						If nPosHead > 0
							aColsSDE[nPosACols][2][nLinha][nPosHead] := SCH->(&(cSCH))
						EndIf
							
					Next nDeb
				Next nEnt
					
				SCH->(dbSkip())
			EndDo
		EndIf
	EndIf
Endif

RestArea(aArea)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A103ValNatºAutor  ³TOTVS			     º Data ³  14/10/2010 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Validacoes na Natureza									  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A103ValNat(cNatureza)
Local aArea:= GetArea()
Local lRet := .T.
If !Empty(cNatureza)
	DbSelectArea("SED")
	DbSetOrder(1)
	DbSeek (xFilial("SED")+cNatureza)
	If !Eof() .And. ED_TIPO == "1"
        Help("  ",1,"A103VLDNAT")
     	lRet:= .F.
	EndIf         
	//Valida se a natureza pode ser utilizada pelo compras
	If lRet
	   lRet:=FinVldNat(.F.,cNatureza,2)
	EndIf
EndIf    
RestArea(aArea)
Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A103ValFrete ºAutor  ³TOTVS		     º Data ³  23/02/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Valida Campo Tipo de Frete / Aba: DANFE					  º±±  
±±º		     ³ O conteudo somente podera ser preenchido quando nao existirº±±  
±±º		     ³ nenhum pedido vinculado ao pedido de compras				  º±±  
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103ValFrete()
Local aArea	   := GetArea()
Local nPosPc   := GetPosSD1("D1_PEDIDO")
Local nPosItPc := GetPosSD1("D1_ITEMPC")
Local nX       := 0
Local lPed     := .F.
Local lRet     := .T.
Local lvldFret := SuperGetMV("MV_VALFRET",.F.,.F.)

For nX:=1 to Len(aCols)
	If nPosPc>0
		lPed:=IIF(Empty(aCols[nX][nPosPc]),.F.,.T.) 
	EndIf
	If nPosItPc>0 .And. !lPed
		lPed:=IIF(Empty(aCols[nX][nPosPc]),.F.,.T.)
	EndIf
	If lPed 
	   Exit 
	EndIf
Next nX   
                            
IF Len(aNfeDanfe)>0
    If !lvldFret .And. lPed .And. Len(Trim(aNFEDanfe[14]))>0   //Tem PC vinculado a Nota e Tipo de Frete esta preenchido
    	lRet:=.F.
    EndIf
EndIf

If !lRet     
	Help('',1,'A103FRETE')
EndIf

RestArea(aArea)
Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A103ValEstNegºAutor  ³TOTVS		     º Data ³  25/02/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Valida se irá permitir estoque negativo					  º±±  
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103ValEstNeg(cProd,cAliasSd1)
Local aArea	     := GetArea()   
Local lMT103ENEG := ExistBlock("MT103ENEG")  
Local lRet	     := .F.

//Ponto de Entrada que permite o saldo negativo mesmo o parâmetro MV_ESTNEG estando como N
//Produto não poderá ter lote ou localizacao  
If lMT103ENEG
	If !(Rastro(cProd) .And. !Localiza(cProd))
		lRet:=ExecBlock("MT103ENEG",.F.,.F.,{cAliasSD1})
		If ValType(lRet)<>"L"
			lRet:=.F.
		EndIf
	EndIf
Else
	Aviso(STR0018,STR0019 + AllTrim((cAliasSD1)->D1_COD)+"/"+(cAliasSD1)->D1_LOCAL + STR0023 + AllTrim(Str(nSaldoB2))+") ",{STR0025}) //"Atencao" //"O Saldo do Prod/Loc "###" ficara negativo apos a Exclusao ("###"Aborta"
	lRet:=.F.
EndIf

RestArea(aArea)
Return (lRet)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A103CompDanfeºAutor  ³TOTVS		     º Data ³  13/06/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Campos complementares aba DANFE	             			  º±±  
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103CompDanfe()
Local aCompDanfe:={}

aCompDanfe:=execblock("MT103DCF",.F.,.F.,{INCLUI,ALTERA,L103VISUAL,aDanfeComp})
If Valtype(aCompDanfe)=="A"
	aDanfeComp:=aClone(aCompDanfe)
EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ A103LockPC ºAutor  ³TOTVS              º Data ³  30/08/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Bloqueia Pedidos utilizados no Acols				    	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                               		      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/ 
Function A103LockPC(aCabec, aItens) 
Local nPed		:= GetPosSD1("D1_PEDIDO")
Local nItPed	:= GetPosSD1("D1_ITEMPC")
Local nCodProd	:= GetPosSD1("D1_COD")
Local nXp		:= 0
Local nBlq		:= 0
Local cUnico   := ""
Local lRet		:= .T.
Local aAreaAtu	:= GetArea()

aRegsLock:={}

If Len(aItens)>0 .and. nPed>0 .And. nItPed>0 
	
	If Len(aItens)>0 .and. nPed>0 .And. nItPed>0 
		If FindFunction("FWX2Unico")
			cUnico := FWX2Unico("SC7")
		Else
			cUnico := "C7_FILIAL+C7_NUM+C7_ITEM+C7_SEQUEN+C7_ITEMGRD" // X2_UNICO da SC7
		EndIf
	EndIf
	If Len(AllTrim(cUnico))>0
		DbSelectArea("SC7")
		DbSetOrder(4)
		For nXp:=1 to Len(aItens)
			If !Empty(aItens[nXp][nPed]) .And. !Empty(aItens[nXp][nItPed])
				If DbSeek(xFilial("SC7")+aItens[nXp][nCodProd]+aItens[nXp][nPed]+aItens[nXp][nItPed])
					If !MultLock("SC7",{&cUnico},1,.F.,.T.)
						nBlq++
						Exit
					Else
						aaDD(aRegsLock,{"SC7",Recno()})
						If DbSeek(xFilial("SC7")+aItens[nXp][nCodProd]+aItens[nXp][nPed]+aItens[nXp][nItPed])
							If	!(MA103CkAIC(SC7->C7_FORNECE,SC7->C7_LOJA,SC7->C7_PRODUTO))
								If ( !(C7_QUANT-C7_QUJE-IIF(l103Class,0,C7_QTDACLA))>0 .Or. C7_RESIDUO$'S' .Or. C7_ENCER$'E' ) .And. C7_ORIGEM <> 'EICPO400'
									Help(" ",1,"QTDLIBMAI")
									lRet := .F.
									nBlq++
									Exit
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
	   Next nXp
	EndIf
EndIf

If nBlq>0
	A103UnlkPC()
	lRet := .F.
EndIf

RestArea(aAreaAtu)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ A103LockPC ºAutor  ³TOTVS              º Data ³  30/08/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Desbloqueia Pedidos utilizados no Acols			    	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                               		      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103UnlkPC
	SC7->(MsUnLockAll())
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ A103ChamaHelp ºAutor  ³TOTVS           º Data ³  03/10/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao para exibir os Helps do campo F1_CHVNFE ao finalizarº±± 
±±º          | o documento de entrada                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                               		      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/ 
Function A103ChamaHelp(l103Inc,l103Cla)

Local lDigChv 	:= GetNewPar("MV_DCHVNFE",.F.) 
Local lRetorno 	:= .T.
Local cChvEspe	:= SuperGetMV( "MV_CHVESPE" , .F. , "" )
Local cCompara	:= "|SPED|CTE|"
Local aCompara	:= {}
Local lRotAuto  := Type("l103Auto") == "L" .And. l103Auto

Default l103Inc := .F.
Default l103Cla := .F.

If lDigChv
	cChvEspe := StrTran(cChvEspe,",","|")
	cChvEspe := StrTran(cChvEspe,";","|")
	
	If !Empty( cChvEspe )
		cCompara += cChvEspe + "|"
	EndIf
Endif

//Adequeacao da Validacao
//Transforma a String em Array
aCompara := StrToKarr(cCompara,"|")
    
If lDigChv 
	If SF1->(FieldPos("F1_CHVNFE")) > 0 .And. (!lRotAuto .Or. (lRotAuto .And. (l103Inc .Or. l103Cla)))
		If (cFormul == "N" .and. aScan(aCompara,{|x| x == ALLTRIM(cEspecie)} ) > 0 )
			If Type("aNFEDanfe[13]") <> "U"
				M->F1_CHVNFE 	:= IIF(!EMPTY(M->F1_CHVNFE),M->F1_CHVNFE,aNFEDanfe[13]) 
			EndIf

			If GetSx3Cache("F1_CHVNFE",'X3_VISUAL') == "V"
			 	Help(" ",1,"CHVALTERAR")
	   			lRetorno := .F.
	   		ElseIf Empty(M->F1_CHVNFE)
				Help(" ",1,"DCHVNFE")
				lRetorno := .F.
			ElseIf len(Alltrim(M->F1_CHVNFE)) < 44
				Help(" ",1,"CHVMENOR")
				lRetorno := .F.
			EndIf
         EndIf   
	EndIf  	
EndIf  

Return lRetorno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ A103ConsNfeSef ºAutor  ³TOTVS          º Data ³  03/10/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Consulta a chave da NFe digitada na Sefaz                  º±± 
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                               		      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/ 
Function A103ConsNfeSef(cVarChvNfe,aCab) 

Local lConChv 	:= GetNewPar("MV_CHVNFE",.F.)
Local lDigChv 	:= GetNewPar("MV_DCHVNFE",.F.)
Local lBlqChv	:= GetNewPar("MV_BCHVNFE",.F.)
Local lRet	  	:= .F.   
Local cURL      := PadR(GetNewPar("MV_SPEDURL","http://"),250)
Local cIdEnt   	:= ""
Local cChaveNFe := ""
Local cCodRet	:= "Codigo de retorno: "
Local cMensRet  := "Mensagem de retorno: " 
Local cProt		:= "Protocolo: "
Local cChavCan	:= "A chave informada não poderá ser gravada, pois está cancelada junto à Sefaz."
Local cChvAuto	:= ""
Local nPos		:= ""
Local cChvEspe	:= SuperGetMV( "MV_CHVESPE" , .F. , "" )
Local cCompara	:= "|SPED|CTE|NFA|"
Local cError	:= ""

local lConsCte	:= SuperGetMV("MV_CONSCTE",.F.,.F.)
local lConsNfe	:= SuperGetMV("MV_CONSNFE",.F.,.F.)
Local nPosVld056	:= 0

DEFAULT aCab	:= IIf( Type("aAutoCab") == "A",aAutoCab,{})

nPosVld056		:= IIf (Len(acab)>0,aScan(acab,{|x| AllTrim(x[1]) == "VLDAMNFE"}),0)

Private oWS

Default cVarChvNfe	:= ""

If lDigChv
	cChvEspe := StrTran(cChvEspe,",","|")
	cChvEspe := StrTran(cChvEspe,";","|")
	
	If !Empty( cChvEspe )
		cCompara += cChvEspe + "|"
	EndIf
Endif
If Type("aNFEDanfe[13]") ==  "C"
	M->F1_CHVNFE := aNFEDanfe[13]
EndIf
If	(lDigChv .and. cFormul == "N" .and. ( "|" + AllTrim(cEspecie) + "|" $ cCompara ) )  
	If Empty(cVarChvNfe)
		M->F1_CHVNFE 	:= &(ReadVar())
		cChaveNFe  		:= M->F1_CHVNFE
	Else
		cChaveNFe  		:= cVarChvNfe
	EndIF
	
	If Type("l103Auto") == "U"
		Private l103Auto := .F.
	EndIf
	
	If Type("l116Auto") == "U"
		Private l116Auto := .F.
	EndIf
		
	If l103Auto
		nPos := aScan(aAutoCab,{|x| AllTrim(x[1]) == "F1_CHVNFE"})
		If nPos > 0
			cChvAuto := aAutoCab[nPos,2]
		Endif
		
		If !Empty(cChvAuto) .And. cChvAuto <> cChaveNFe
			M->F1_CHVNFE	:= cChvAuto	
			cChaveNFe		:= M->F1_CHVNFE
		Endif
	Endif		
	
    If lConChv
    	If IsReady(cURL)
	
	    	//Obtem o codigo da entidade
			If FindFunction("getCfgEntidade") 
				cIdEnt := getCfgEntidade(@cError)
			Else 
				cError := "Função getCfgEntidade não localizada no RPO!"
			EndIf

			If !Empty(cError)
				Aviso("SPED",cError,{"OK"},3)
			EndIf  
			
			oWs:= WsNFeSBra():New()
			oWs:cUserToken   := "TOTVS"
			oWs:cID_ENT      := cIdEnt
			ows:cCHVNFE		 := cChaveNFe
			oWs:_URL         := AllTrim(cURL)+"/NFeSBRA.apw"
			
			If oWs:ConsultaChaveNFE()
				If Type ("oWs:oWSCONSULTACHAVENFERESULT:cPROTOCOLO") == "U" .OR. Empty (oWs:oWSCONSULTACHAVENFERESULT:cPROTOCOLO)
					If AllTrim(oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE) == "731" .or. AllTrim(oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE) == "526"
						If ((FwIsInCallStack("GFEA065") .And. lConsCte) .or. (FwIsInCallStack("MATA103") .And. lConsNfe) )  .And. (l103Auto .Or. l116Auto)
							lRet := .T.
						Else
							If !l103Auto
								If MsgNoYes(cCodRet+oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE+CRLF+;
											cMensRet+oWs:oWSCONSULTACHAVENFERESULT:cMSGRETNFE+CRLF+;
											"Verificar se o Ano-Mês da Chave de Acesso está com atraso"+CRLF+;
											"superior a 6 meses em relação ao Ano-Mês atual."+CRLF+CRLF+CRLF+;
											"Deseja inserir a chave mesmo assim?")
									lRet := .T.							
								Else
									M->F1_CHVNFE := "" 
									lRet := .F.
								EndIf
							
							Else
								If nPosVld056 > 0 .And. aCab[nPosVld056][2] == "S"
									Help("  ",1,"CONSULTNF",,cCodRet+oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE+CRLF+;
												cMensRet+oWs:oWSCONSULTACHAVENFERESULT:cMSGRETNFE+CRLF+;
												"Verificar se o Ano-Mês da Chave de Acesso está com atraso"+CRLF+;
												"superior a 6 meses em relação ao Ano-Mês atual.",1,0)
									lRet := .F.
								EndIf	
							Endif
						EndIf
					ElseIf AllTrim(oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE) == "101" .or. AllTrim(oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE) == "151"
						Help("  ",1,"CONSULTNF",,cCodRet+oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE+CRLF+;
				   		       cMensRet+oWs:oWSCONSULTACHAVENFERESULT:cMSGRETNFE+CRLF+CRLF+cChavCan,1,0) 
						lRet := .F.
					Else
						If !l103Auto
							MsgAlert("A chave digitada não foi encontrada na Sefaz, favor verificar")
						Else
							Help("  ",1,"CONSULTNF",,"A chave digitada não foi encontrada na Sefaz, favor verificar",1,0)
						Endif
						M->F1_CHVNFE := "" 
						lRet := .F.
					endIf
				Else
				    If AllTrim(oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE) == "101" .or. AllTrim(oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE) == "151"
						Help("  ",1,"CONSULTNF",,cCodRet+oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE+CRLF+;
				   		       cMensRet+oWs:oWSCONSULTACHAVENFERESULT:cMSGRETNFE+CRLF+CRLF+cChavCan,1,0) 
						lRet := .F.		
					Else	
						lRet := .T.
						If !l103Auto
							MsgAlert(cCodRet+oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE+CRLF+;
							         cMensRet+oWs:oWSCONSULTACHAVENFERESULT:cMSGRETNFE+CRLF+;
							         cProt+oWs:oWSCONSULTACHAVENFERESULT:cPROTOCOLO)
						Endif
					EndIf
				EndIf
			Else
				Aviso("SPED",IIf(Empty(GetWscError(3)),GetWscError(1),GetWscError(3)),{"OK"},3)
				If len(Alltrim(M->F1_CHVNFE)) > 0 .and. len(Alltrim(M->F1_CHVNFE)) < 44
					If GetRemoteType() == -1 //Job
						lRet := .T. 
					Else 
						If !l103Auto
							If MsgNoYes("A chave informada é menor que o permitido e impossibilita a consulta na Sefaz."+CRLF+CRLF+;
										"Deseja APAGAR o conteúdo do campo para inserir uma nova chave?")
								M->F1_CHVNFE := "" 
								lRet := .F.  //Limpa o campo caso tenha uma chave menor 
							Else 
								lRet := .T.
							EndIf
						Else
							Help("  ",1,"CONSULTNF",,"A chave informada é menor que o permitido e impossibilita a consulta na Sefaz.",1,0)
							lRet := .F.
						Endif
					Endif
				ElseIf  (lBlqChv .And. !Empty(GetWscError(3))) .Or.;  //"Falha no retorno da SEFAZ"
				 		("INTERNAL SERVER ERROR" $ Upper(GetWscError(3))) //Internal Server Error
				  	M->F1_CHVNFE := "" 
					lRet := .F.
				Else
					lRet := .T.			
				EndIf	
			EndIf
		Else
			Help(" ",1,"TSSINATIVO")	
			lRet := .F.
		EndIf	
	Else
		lRet := .T.
	EndIf
Else
	lRet := .T.  
EndIf    

Return  lRet                
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ IsReady ºAutor  ³TOTVS                 º Data ³  03/10/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica se a conexao com o TSS pode ser estabelecida      º±± 
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                               		      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/ 
Static Function IsReady(cURLTss)

Local oWS
Local lRetorno := .F.    

PutMV("MV_SPEDURL",cURLTss)

SuperGetMv() //Limpa o cache de parametros - nao retirar        

DEFAULT cURLTss  := PadR(GetNewPar("MV_SPEDURL","http://"),250)

//Verifica se o servidor da Totvs esta no ar
oWs := WsSpedCfgNFe():New()
oWs:cUserToken := "TOTVS"
oWS:_URL := AllTrim(cURLTss)+"/SPEDCFGNFe.apw"

If oWs:CFGCONNECT()
	lRetorno := .T.
EndIf

Return lRetorno


/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ A103VldEsp ºAutor  ³Leandro Paulino    º Data ³  28/12/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Valida as especies permitidas quando a integração com o    º±±
±±º			 ³	TOTVSGEF estiver habilitada                           	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                               		      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/

Function A103VldEsp ()
Local lRet			:= .T.                                                                                                

If ("CTR" $ cEspecie .Or. "CTE" $ cEspecie .Or. "NFST" $ cEspecie ) .And. (!( FWIsInCallStack( "FWUMESSAGE" ) .OR. FWIsInCallStack( "FWFORMEAI" ) ))
	If MsgYesNo(STR0121 + Chr(13) + STR0122,STR0018) //"Com a integração ativa entre o ERP Protheus e o TOTVSGFE, os documentos de Transporte devem ser lançados pelo TOTVSGFE! "/"Confirma o lançamento? ")
	Else 
		lRet := .F.
	EndIF	
EndIf

Return lRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A103ConsCTEºAutor  ³TOTVS S.A.		 º Data ³  29/12/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Consiste o Tipo CTE		   						          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³MATA103                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103ConsCTE(cTpCTE)
Local lRet :=.T.

If Type("cEspecie")<>"U" .And. "CTE" == AllTrim(cEspecie)
	If Empty(trim(cTPCTE))
	    Aviso(STR0014 + " " + RetTitle("F1_TPCTE"),STR0118,{STR0038})
		lRet := .F.		
	EndIf
EndIf
Return lRet
            
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o	 ³M103GrvSE5³ Autor ³ Aline S Damasceno     ³ Data ³ 26/07/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Gravacao de registros do SE5 na exclusao C.Pagar			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ F050GrvSE5()		 										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ MATA103										    		  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MT103GrvSE5()
Local aAreaGrv	:= GetArea()
Local oModelMov 	:= NIL
Local oSubFK5
Local oSubFKA
Local oSubFK2
Local cCamposE5	:= ""
Local lRet 		:= .T.

//Limpa chaves de relacionamento (SE5)
Local cAliasSE5  := GetNextAlias()

	BeginSql Alias cAliasSE5
		SELECT E5_FILIAL, E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_CLIFOR, E5_LOJA, SE5.R_E_C_N_O_ 
	  	FROM %table:SE5% SE5
		WHERE 	E5_FILIAL		= %Exp:xFilial("SE5")%	AND 
				E5_PREFIXO 	= %Exp:SE2->E2_PREFIXO%	AND 
				E5_NUMERO 		= %Exp:SE2->E2_NUM%		AND
				E5_PARCELA 	= %Exp:SE2->E2_PARCELA%	AND
				E5_TIPO    	= %Exp:SE2->E2_TIPO%		AND
				E5_FORNECE 	= %Exp:SE2->E2_FORNECE%	AND
				E5_LOJA 		= %Exp:SE2->E2_LOJA%		AND
				SE5.%NotDel%
		ORDER BY E5_FILIAL, E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_CLIFOR, E5_LOJA
	EndSql
	
	dbSelectArea(cAliasSE5)
	DbGoTop()
	
	While (cAliasSE5)->(!Eof())
		
		SE5->(DbGoTo((cAliasSE5)->R_E_C_N_O_)) 

		cCamposE5 := ""
		
		cCamposE5 += "{"
		cCamposE5 += "{'E5_KEY'		, SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_FORNECE+E5_LOJA)	}"
		cCamposE5 += ",{'E5_PREFIXO', ''																			}"
		cCamposE5 += ",{'E5_NUMERO'	, ''																			}"
		cCamposE5 += ",{'E5_PARCELA', ''																			}"
		cCamposE5 += ",{'E5_TIPO'	, ''																			}"
		//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
		cCamposE5 += ",{'E5_LA'		, 'S"  + SubStr( SE5->E5_LA, 2, 1 ) + "'										}" 
		cCamposE5 += "}"
		
		If SE5->E5_TABORI == "FK5" 
			oModelMov := FWLoadModel("FINM030") //Recarrega o Model de movimentos para pegar o campo do relacionamento (SE5->E5_IDORIG)
			oModelMov:SetOperation( MODEL_OPERATION_UPDATE ) //Alteração
			oModelMov:Activate()
			oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
			oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5
			
			//Posiciona a FKA com base no IDORIG da SE5 posicionada
			oSubFKA := oModelMov:GetModel( "FKADETAIL" )
			oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )
					
			//Dados Contábeis
			oSubFK5 := oModelMov:GetModel("FK5DETAIL")	
			oSubFK5:SetValue( "FK5_LA", "S" ) //Salva apenas 1 caractere (S ou N) nas FKs
			
			If oModelMov:VldData()
				oModelMov:CommitData()
		   		oModelMov:DeActivate()
			Else
				lRet := .F.
				cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[6])        	
				Help( ,,"M030VALID",,cLog, 1, 0 )
    		Endif
		ElseIf SE5->E5_TABORI == "FK2"
			oModelMov := FWLoadModel("FINM020") //Recarrega o Model de movimentos para pegar o campo do relacionamento (SE5->E5_IDORIG)
			oModelMov:SetOperation( MODEL_OPERATION_UPDATE ) //Alteração
			oModelMov:Activate()
			oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
			oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5
			
			//Posiciona a FKA com base no IDORIG da SE5 posicionada
			oSubFKA := oModelMov:GetModel( "FKADETAIL" )
			oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )
					
			//Dados Contábeis
			oSubFK2 := oModelMov:GetModel("FK2DETAIL")	
			oSubFK2:SetValue( "FK2_LA", "S" ) //Salva apenas 1 caractere (S ou N) nas FKs
			
			If oModelMov:VldData()
				oModelMov:CommitData()
		   		oModelMov:DeActivate()
			Else
				lRet := .F.
				cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[6])        	
				Help( ,,"M020VALID",,cLog, 1, 0 )
	    	Endif
		EndIf
    	
	(cAliasSE5)->(dbskip())
	Enddo

(cAliasSE5)->(dbclosearea())
RestArea(aAreaGrv)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FillCTBEntºAutor  ³ Andre Anjos		 º Data ³ 02/08/12    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Inicaliza campos das entidades contabeis de acordo com a   º±±
±±º          ³ origem.                                                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA103                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function FillCTBEnt(cOrigem,nItem)
Local aCTBEnt := CTBEntArr()
Local nX	  := 0

For nX := 1 To Len(aCTBEnt)
	If GetPosSD1("D1_EC"+aCTBEnt[nX]+"CR") > 0 .And. (cOrigem)->(FieldPos(Substr(cOrigem,2)+"_EC"+aCTBEnt[nX]+"CR")) > 0
		aCols[nItem,GetPosSD1("D1_EC"+aCTBEnt[nX]+"CR")] := (cOrigem)->&(Substr(cOrigem,2)+"_EC"+aCTBEnt[nX]+"CR")
	EndIf
	If GetPosSD1("D1_EC"+aCTBEnt[nX]+"DB") > 0 .And. (cOrigem)->(FieldPos(Substr(cOrigem,2)+"_EC"+aCTBEnt[nX]+"DB")) > 0
		aCols[nItem,GetPosSD1("D1_EC"+aCTBEnt[nX]+"DB")] := (cOrigem)->&(Substr(cOrigem,2)+"_EC"+aCTBEnt[nX]+"DB")
	EndIf
Next nX

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    |ISSFldDiv ³Autor  ³ Vitor Felipe          ³ Data ³06/06/2012 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Desc.     ³ Rotina tratamento do folder para informacoes do ISS e INSS. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ oDlg: Objeto da Janela que sera disponibilizado os Get.     ³±±
±±³          ³ aPosGet: Array com as posicoes dos gets da NF-e.            ³±±
±±³          ³ aObjetos: Codeblock para atualizaco dos dados do Folder.    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Fiscal.                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ISSFldDiv(oDlg,aPosGet,aObjetos,aInfISS,aFldCBAtu,nInfISS)      

Local aCombo1 := {STR0126,STR0127} //"1=Sim","2=Nao"
Local lEditMun:= .F.

PRIVATE M->F1_ESTPRES := ""

@ 04,03 TO 23 ,630 LABEL "" OF oDlg PIXEL
@ 05,aPosGet[1,1] SAY STR0128 Of oDlg PIXEL SIZE 50,50	// "Dados do Município:"

@ 010,aPosGet[1,2]    SAY STR0131 OF oDlg PIXEL SIZE 100,100 //"UF:"
@ 009,aPosGet[1,2]+15 MSGET aObjetos[01,03] VAR aInfISS[01,03] PICTURE X3Picture("CC2_EST") ; 
WHEN !l103Visual ;
VALID Vazio(aInfISS[01,03]) .or. (ExistCpo("SX5","12" + aInfISS[01,03]) .And. Eval( {|| M->F1_ESTPRES := aInfISS[01,03] , lEditMun:= .T. } ) .And. ;
MaFisAlt("NF_UFPREISS",aInfISS[01,03],) .And. aObjetos[1,1]:SetFocus());
	F3 "12" OF oDlg PIXEL SIZE 10,08 HASBUTTON 

@ 010,aPosGet[1,10]+10 SAY STR0129 Of oDlg PIXEL SIZE 100,100 //"Codigo Mun:"
@ 009,aPosGet[1,10]+45 MSGET aObjetos[01,01] VAR aInfISS[01,01] PICTURE PesqPict('SA2','A2_COD_MUN');
WHEN !l103Visual .And. lEditMun  ;
VALID NaoVazio(aInfISS[01,01]) .and. A103DescMun( aInfISS[01,01] , @aObjetos[01,02] , @aInfISS[01,02] , aInfISS[01,03] ) .And. ;
MaFisAlt("NF_CODMUN",aInfISS[01,01],) .And. EncForIss(M->F1_ESTPRES,MaFisRet(,"NF_CODMUN"),aObjetos,@aInfISS); 
F3 "CC2SF1" OF oDlg PIXEL SIZE 30,08 HASBUTTON

@ 010,aPosGet[1,10]+088 SAY STR0130 Of oDlg PIXEL SIZE 100,100 //"Desc. Mun:"
@ 009,aPosGet[1,10]+115 MSGET aObjetos[01,02] VAR aInfISS[01,02] PICTURE X3Picture("CC2_MUN"); 
WHEN .F. OF oDlg PIXEL SIZE 60,08 HASBUTTON  

@ 10,aPosGet[1,5] SAY STR0132 Of oDlg PIXEL SIZE 100,100	   		// "Ded Mat:"
@ 09,aPosGet[1,13] MSCOMBOBOX aObjetos[01,04] VAR aInfISS[01,04];
	ITEMS aCombo1 SIZE 25,08;
	WHEN .F.;
	OF oDlg PIXEL
@ 10,aPosGet[1,7] SAY STR0133 Of oDlg PIXEL SIZE 100,100		// "Ded Serv:"
@ 09,aPosGet[1,14] MSCOMBOBOX aObjetos[01,05] VAR aInfISS[01,05];
	ITEMS aCombo1 SIZE 25,08;
	WHEN .F.;
	OF oDlg PIXEL
@ 10,aPosGet[1,8] SAY STR0134 Of oDlg PIXEL SIZE 100,100	   		// "%Ded. Mat.:"
@ 09,aPosGet[1,15] MSGET aObjetos[01,06] VAR aInfISS[01,06] PICTURE X3Picture("CC2_PERMAT");
SIZE 35,08 HASBUTTON;
WHEN .F.;
OF oDlg PIXEL
@ 10,aPosGet[1,9] SAY STR0135 Of oDlg PIXEL SIZE 100,100		// "%Ded. Ser.:"
@ 09,aPosGet[1,16] MSGET aObjetos[01,07] VAR aInfISS[01,07] PICTURE X3Picture("CC2_PERSER");
	SIZE 35,08 HASBUTTON;
	WHEN .F.;
	OF oDlg PIXEL

@ 24,03 TO 43 ,630 LABEL "" OF oDlg PIXEL
@ 25,aPosGet[1,1] SAY STR0136 Of oDlg PIXEL SIZE 100,100		// "ISS Apurado:"
@ 30,aPosGet[1,2] SAY STR0137 Of oDlg PIXEL SIZE 100,100		// "Valor dos Sericos:"
@ 29,aPosGet[1,10] MSGET aObjetos[02,01] VAR aInfISS[02,01];
	PICTURE X3Picture("D1_TOTAL") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON
@ 30,aPosGet[1,3] SAY STR0138 Of oDlg PIXEL SIZE 100,100		// "Sericos:"
@ 29,aPosGet[1,11] MSGET aObjetos[02,02] VAR aInfISS[02,02] ;
	PICTURE X3Picture("D1_ABATISS") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON
@ 30,aPosGet[1,4] SAY STR0139 Of oDlg PIXEL SIZE 100,100		// "Materiais:"
@ 29,aPosGet[1,17] MSGET aObjetos[02,03] VAR aInfISS[02,03] ;
	PICTURE X3Picture("D1_ABATMAT") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON
@ 30,aPosGet[1,5] SAY STR0140 Of oDlg PIXEL SIZE 100,100	// "B. Cálculo:"
@ 29,aPosGet[1,18] MSGET aObjetos[02,04] VAR aInfISS[02,04] ;
	PICTURE X3Picture("D1_BASEISS") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON
@ 30,aPosGet[1,6] SAY STR0141 Of oDlg PIXEL SIZE 100,100		// "Val. ISS:"
@ 29,aPosGet[1,19] MSGET aObjetos[02,05] VAR aInfISS[02,05] ;
	PICTURE X3Picture("D1_VALISS") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON

@ 44,03 TO 63 ,630 LABEL "" OF oDlg PIXEL
@ 45,aPosGet[1,1] SAY STR0142 Of oDlg PIXEL SIZE 100,100	// "INSS Apurado:"
@ 50,aPosGet[1,2] SAY STR0143 Of oDlg PIXEL SIZE 100,100	// "Valor Serviço:"
@ 49,aPosGet[1,10] MSGET aObjetos[03,01] VAR aInfISS[03,01] ;
	PICTURE X3Picture("D1_TOTAL") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON 

@ 50,aPosGet[1,3] SAY STR0144 Of oDlg PIXEL SIZE 100,100		// "Recolhido:"
@ 49,aPosGet[1,11] MSGET aObjetos[03,02] VAR aInfISS[03,02] ;
	PICTURE X3Picture("D1_ABATINS") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON    

@ 50,aPosGet[1,4] SAY STR0138 Of oDlg PIXEL SIZE 100,100		// "Servicos:"
@ 49,aPosGet[1,17] MSGET aObjetos[03,03] VAR aInfISS[03,03] ;
	PICTURE X3Picture("D1_AVLINSS") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON
@ 50,aPosGet[1,5] SAY STR0146 Of oDlg PIXEL SIZE 100,100	// "B. Cálculo:"
@ 49,aPosGet[1,18] MSGET aObjetos[03,04] VAR aInfISS[03,04] ;
	PICTURE X3Picture("D1_BASEINS") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON
@ 50,aPosGet[1,6] SAY STR0147 Of oDlg PIXEL SIZE 100,100		// "Val. INSS:"
@ 49,aPosGet[1,19] MSGET aObjetos[03,05] VAR aInfISS[03,05] ;
	PICTURE X3Picture("D1_VALINS") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON

aFldCBAtu[nInfISS] := {|| ISSRFldTot(aObjetos,@aInfISS)}

Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  |ISSRFldTotºAutor  ³ Vitor Felipe       º Data ³ 19/06/2012  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Roda validacoes e atualiza para o ISS x Municipio.         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ aObjetos: Array contento os Objetos do Folder.             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ISSRFldTot(aObjetos,aInfISS)

Local nX		:= 0
Local nY		:= 0
Local nPosCod 	:= GetPosSD1("D1_COD")
Local lMeples 	:= .F.
Local cTmun     := SuperGetMv("MV_EISSXM") 

If Len(aCols) > 0 .And. !Empty(aCols[01,nPosCod])
	
	If cTmun = "1"
		lMeples := .T.
	Endif
    If Empty(aInfISS[1,1]) .Or. aInfISS[1,1] != MaFisRet(,"NF_CODMUN")
		aInfISS[1,1] := Iif(lMeples,SubSTR(MaFisRet(,"NF_M0CODMUN"),3, Len(MaFisRet(,"NF_M0CODMUN"))),MaFisRet(,"NF_CODMUN") ) 
		aInfISS[1,3] := Iif(lMeples,MaFisRet(,"NF_UFDEST"),MaFisRet(,"NF_UFPREISS") )
	Endif
	
	//BUSCA O MUNICIPIO NA TABELA CC2 (MUNICIPIOS) E CARREGA O RESTANTE DOS CAMPOS
	dbSelectArea("CC2")
	dbSetOrder(1)
	If CC2->(MsSeek(xFilial("CC2")+aInfISS[1,3]+aInfISS[1,1]))
	If cPaisLoc $ "ANG|AUS|BRA|CHI|COL|COS|DOM|EQU|HAI|MEX|PER|PTG|VEN"
		aInfISS[1,2] := AllTrim(CC2->CC2_MUN)
	EndIf
		If cPaisLoc == "BRA"
		aInfISS[1,4] := CC2->CC2_MDEDMA
		aInfISS[1,5] := CC2->CC2_MDEDSR
		aInfISS[1,6] := CC2->CC2_PERMAT
		aInfISS[1,7] := CC2->CC2_PERSER
		EndIf
	EndIf
	
	If INCLUI .Or. ALTERA .Or. l103Visual
		aInfISS[2,2] := 0 ; aInfISS[2,3] := 0 ; aInfISS[3,2] := 0 ; aInfISS[3,3] := 0
		//ATUALIZA OS ARRAYS DO FOLDER - ISS
		aInfISS[2,1] := MaFisRet(,"NF_TOTAL")		//Valor Total
		aInfISS[2,2] := MaFisRet(,"NF_ISSABSR")	//Abatimentos de Sericos
		aInfISS[2,3] := MaFisRet(,"NF_ISSABMT")	//Abatimentos de Materiais
		aInfISS[2,4] := MaFisRet(,"NF_BASEISS")	//Base do ISS
		aInfISS[2,5] := MaFisRet(,"NF_VALISS")		//Valor do ISS
		//ATUALIZA OS ARRAYS DO FOLDER - INSS
		aInfISS[3,1] := MaFisRet(,"NF_TOTAL")		//Valor Total
		aInfISS[3,2] := MaFisRet(,"NF_INSABSR")	//Abatimentos de Sericos
		aInfISS[3,3] := MaFisRet(,"NF_INSABMT")	//Abatimentos de Materiais
		aInfISS[3,4] := MaFisRet(,"NF_BASEINS")	//Base de Calculo do INSS
		aInfISS[3,5] := MaFisRet(,"NF_VALINS")		//Valor do INSS
	EndIf
	
	//Atualiza os Objetos.
	For nX := 1 to Len(aObjetos)
		For nY := 1 To Len(aObjetos[nX])
			aObjetos[nX,nY]:Refresh()
		Next nY
	Next nX
	
	If aObjetos[01,03] <> Nil
		aObjetos[01,03]:lReadOnly := !MaFisFound("IT",1)
		aObjetos[01,03]:Refresh()
	EndIf
	
EndIF

Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o	 ³ EncForIss ³Autor  ³ Adilson Roberto      ³ Data ³ 12/05/20 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Funcao para checar se existe cadastro com as informações   ³±±
±±³          ³ inseridas na rotina FISA052                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ EncForIss()	 										      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ MATA103X										    		  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
STATIC FUNCTION EncForIss(cEstIss,cCodmunIss,aObjetos,aInfISS)
Local nPosCodISS := GetPosSD1("D1_CODISS")
Local nPosCod	 := GetPosSD1('D1_COD')

If nPosCod > 0
	DbSelectArea("SB1")
	DbSetORder(1)
	If DbSeek(xFilial("SB1")+aCols[01][nPosCod])    
		If SB1->B1_MEPLES == "2"			
			CE1->(DbSeek(xFilial("CE1")+Iif(nPosCodISS >0, aCols[01][nPosCodISS], SB1->B1_CODISS)+ cEstIss + cCodmunIss))
			If !xFilial("CE1") == CE1->CE1_FILIAL .And. !(Iif(nPosCodISS >0, aCols[01][nPosCodISS], SB1->B1_CODISS) == CE1->CE1_CODISS) .And. !cEstIss == CE1->CE1_ESTISS .And. !cCodmunIss == CE1->CE1_CMUISS
				MsgAlert("Cadastro não localizado na rotina FISA052")
			Endif
			ISSRFldTot(aObjetos,@aInfISS)				
		EndIf
	EndIf
Else
	MsgAlert("Código do Produto não localizado, o campo D1_COD deve ser configurado como Usado")
EndIf

Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o	 ³ A103VLDITO ³Autor  ³ Carlos Capeli       ³ Data ³ 29/10/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Funcao para validar os itens da nota fiscal original	na	  ³±±
±±³          ³ classificacao de uma nota de devolucao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ A103VLDITO()	 										      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ MATA103X										    		  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103VLDITO()

Local nPosItOri	:= 0
Local nX		:= 0
Local cItem		:= ""
local lClass	:= Iif(Type('l103Class')=='L',l103Class,.F.)
Local nBkp		:= n

If lClass
	If (nPosItOri := GetPosSD1("D1_ITEMORI")) > 0
		For nX := 1 To Len(aCols)
			cItem := aCols[nX][nPosItOri]
			n := nX
			If !Empty(cItem)
				A103ItDev(cItem)
			EndIf
		Next nX
		n := nBkp
	EndIf
EndIf

Return

/*±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun?ao    ³a103RatPCnf| Autor ³Aline S Damasceno      ³ Data ³ 08/01/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri?ao ³ Funcao utilizada para a funcao AdmRatExt e refresh no       ³±±
±±³          ³ objeto.  							                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ oGetDad = Objeto MSSelect				                   ³±±
±±³ 	     ³ aHeadSde= Cabecalho SDE  				                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA103                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function a103RatPCnf(aHeadSde,oGetDad)

If A103PRERAT(aHeadSde)
	AdmRatExt(aHeadSde,oGetDad:aCols,{ |x,y,z,w,t| NfeCarCC(x,y,@z,w,@t) })
	
	If ValType(oGetDad) == "O"
		oGetDad:oBrowse:Refresh()   
	EndIf
Endif   

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o	 ³A103CODRSEF³ Autor ³ TOTVS                 ³ Data ³ 01/02/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Busca código de retorno SEFAZ da Nota Original			   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ A103CODRSEF()	 										   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ MATA103										    		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103CODRSEF(aHeader,aCols)
Local aAreaSF3	:= SF3->(GetArea())
Local nPosNfOri := GetPosSD1("D1_NFORI" )
Local nPosSerOri:= GetPosSD1("D1_SERIORI" )
Local lRet		:= .T.

// Verifica se a nota original foi transmitida à SEFAZ (F3_CODRSEF = 100), caso contrário não permite incluir a devolução
If nPosNfOri > 0 .And. nPosSerOri > 0
	DbSelectArea("SF3")
	DbSetOrder(4)
	If MsSeek(xFilial("SF3")+cA100For+cLoja+aCols[1][nPosNfOri]+aCols[1][nPosSerOri])
		If SF3->F3_CODRSEF!="100"
			Aviso(STR0018,STR0148,{STR0038})
			lRet := .F.
		EndIf
	EndIf
EndIf

RestArea(aAreaSF3)
Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o	 ³A103VencSE2³ Autor ³ Carlos Capeli         ³ Data ³ 13/10/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Recalcula IR ao alterar vencimento do título na aba Duplic. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ A103VencSE2()	 										   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ MATA103										    		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103VencSE2()

Local cCampo	  := ReadVar()
Local cCpoE2	  := StrTran(cCampo,"M->","")
Local nPosIrrf	  := aScan(aHeader,{|x| AllTrim(x[2])=="E2_IRRF"})
Local nPosVenc	  := aScan(aHeader,{|x| AllTrim(x[2])=="E2_VENCTO"})
Local nPosE2	  := 0
Local lRet		  := .T.
Private aIrrfNew  := {}
Private dDVencAnt := stod("")

//Atualiza o campo no aCols
nPosE2 := aScan(aHeader,{|x| AllTrim(x[2]) == cCpoE2 .And. cCpoE2 != "F2D_VALOR"})
If nPosE2 > 0
	If cCpoE2 == "E2_VENCTO"
		dDVencAnt := acols[n][nPosE2]
	Endif
    

	aCols[n,nPosE2] := &cCampo
EndIf

If cCampo == "M->E2_VENCTO" .And. nPosIrrf > 0 .And. N == 1
	If Type("bIRRefresh")=="B"
		Eval(bIRRefresh)
	EndIf
	If Len(aIrrfNew) >= 1
		aCols	:= aIrrfNew
		dNewVenc:= aIrrfNew[1][nPosVenc]
	EndIf
Endif

If Type("bRefresh")=="B"
	Eval(bRefresh,6)
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MTA103TROPºAutor  ³Microsiga           º Data ³  08/24/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funçao para automatizar digitacao de tipos de operacoes na º±±
±±º          ³ Classificacao da Nota de Entrada                           º±±
±±º          ³                                                            º±±
±±º          ³ Parametro: nItem - Linha do acols que esta posicionado     º±±
±±º          ³                                                            º±±
±±º          ³ Incluido na validacao do campo D1_OPER                     º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ P11                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function MTA103TROP(nItem)
Local lClassifica 	:= IIf(Type('l103Class')=="L" .And. l103Class,.T.,.F.)
Local nPosOpe		:= 0
Local nPosTes		:= 0
Local nPosCod		:= 0
Local nVezes		:= 0
Local lValOp		:= IIf( Type('mv_par22')=='N' .And. mv_par22 == 1, .T., .F. )
Local cTpOpAtu		:= M->D1_OPER
Local nItemOri		:= n
Local lFirst		:= .T.
Local lTrocAll  	:= .T.
Local lDivImp		:= SuperGetMV("MV_NFDVIMP",.F.,.F.) ; 
					.And. COLConVinc(SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA) > 0 ;
					.And. Type("oListDvIm") == "O" ;
					.And. Type("oDivCount") == "O"
Local nOpc		:= 0

Default nItem	:= 0

If (lClassifica .Or. Inclui)  .And. lValOp .And. nItem >= 1
	nPosOpe:= aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_OPER'}) 
	If nItem < Len(aCols) .and. nPosOpe > 0 
 		if readvar() == "M->D1_OPER"
			cTpOpAtu := IIF( !empty(M->D1_OPER), M->D1_OPER, space(TAMSX3("D1_OPER")[1]))
		else
			cTpOpAtu := aCols[nItem][nPosOpe]
		endif
		nPosTes  := aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_TES' })
		nPosCod  := aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_COD' })
		
		For nVezes	:= nItem to Len(aCols)
			// Substituo o valor do item do aCols para atualizaçoes na função MaTesInt()
			n	:= nVezes
			// Se é um item válido
			If !aCols[nVezes][Len(aHeader)+1]
				// Realiza atualização
        		If lFirst .AND. EMPTY(cTpOpAtu)
					If nItemOri < Len(aCols)
						nOpc := Aviso(STR0153,STR0207,{STR0008,STR0007,STR0215}) // Tipo de operação não preenchido, deseja apagar o conteúdo dos campos TES e Tipo operação a todos os próximos itens ?
						If nOpc == 1
							lTrocAll := .T.
						Elseif nOpc == 2
							lTrocAll := .F.
						Else
							Exit
						Endif
					Endif
				EndIf
		    	if  lTrocAll .OR. lFirst 
		    			aCols[nVezes][nPosTes]	:= MaTesInt(1,cTpOpAtu,cA100For,cLoja,If(cTipo$"DB","C","F"),aCols[nVezes][nPosCod],"D1_TES")
		    			aCols[nVezes][nPosOpe]	:= cTpOpAtu
						MaFisAlt("IT_TPOPER",cTpOpAtu,n)
						lFirst	 := .F.

		    		//Atualiza a Grid de Divergência de Impostos
						If lDivImp
							ColLoadDiv(oListDvIm,oDivCount)
					    EndIf
				endif				
				
				/*Integracao com o modulo de Armazenagem - SIGAWMS*/
				If lClassifica .And. IntWMS() .And. SF4->F4_ESTOQUE == "S" .And. cTipo $ "N|D|B"					
					WmsAvalSD1("2","SD1",aCols,nVezes,aHeader)//Efetua o tratamento dos campos do SIGAWMS do aCols
				EndIf
			EndIf
		Next nVezes
	
	EndIf
EndIf

n	:= nItemOri
//Atualiza a Grid de Divergência de Impostos no item original
If lDivImp	.And. ( nPosOpe:= aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_OPER'}) ) > 0 ;
			.And. ( nPosTes:= aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_TES' }) ) > 0 ;
			.And. ( nPosCod:= aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_COD' }) ) > 0 
	If !Empty(M->D1_OPER)
		aCols[n][nPosOpe]	:= M->D1_OPER
	EndIf
	aCols[n][nPosTes]	:= MaTesInt(1,aCols[n][nPosOpe],cA100For,cLoja,If(cTipo$"DB","C","F"),aCols[n][nPosCod],"D1_TES")
	ColLoadDiv(oListDvIm,oDivCount)
EndIf

Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MTA103OPERºAutor  ³Microsiga           º Data ³  08/24/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao para automatizar digitacao de tipos de operacoes na º±±
±±º          ³ Digitação da Nota Fiscal de Entrada                        º±±
±±º          ³                                                            º±±
±±º          ³ Parametro: nItem - Linha do acols que esta posicionado     º±±
±±º          ³                                                            º±±
±±º          ³ Incluído na validação do campo D1_TOTAL                    º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MTA103OPER(nItem)

Local lRet	:= .T.
Local nPosOpe	:= 0
Local nPosTes	:= 0
Local nPosCod	:= 0
Local lValOp	:= .F. 

Default nItem	:= 0
If INCLUI 
	lValOp	:= GetNewPar("MV_A103OPE",.F.)
	If lValOp .and. nItem > 1
		If ( nPosOpe:= aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_OPER'}) ) > 0
	    	aCols[nItem][nPosOpe]	:= aCols[nItem-1][nPosOpe]
		
			nPosTes:= aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_TES'})
			nPosCod:= aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_COD'})
		
			aCols[nItem][nPosTes]	:= MaTesInt(1,aCols[nItem][nPosOpe],cA100For,cLoja,If(cTipo$"DB","C","F"),aCols[nItem][nPosCod],"D1_TES")

		EndIf
	EndIf
EndIf
	
Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RetModCTE ºAutor  ³Carlos Capeli		 º Data ³  20/02/2014 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna a Modalidade do Transporte				          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³MATA103                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RetModCTE(cMod)
Local aCombo1  :={}
Local aComboMod:={}
Local cModCte  := ""
Local nMod      := 0

aCombo1:=x3CboxToArray("F1_MODAL")[1]
aSize(aComboMod,Len(aCombo1)+1)
For nMod:=1 to Len(aComboMod)
	aComboMod[nMod]:=IIf(nMod==1," ",aCombo1[nMod-1])
Next nMod
nMod:=Ascan(aComboMod, {|x| Substr(x,1,2) == cMod})
If nMod>0
	cModCte:=aComboMod[nMod]
EndIf

Return cModCte

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A103VldMod ºAutor  ³Carlos Capeli		 º Data ³  20/02/2014 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Validacao Modalidade Transporte					          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³MATA103X                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103VldMod(cModCTE)

Local cOpcao := Substr(cModCTE,1,2)

If !Empty(MafisScan("NF_MODAL",.F.)) .And. (cOpcao $ "  |01|02|03|04|05|06")
	MaFisRef("NF_MODAL","MT100",cOpcao)
	MaFisToCols(aHeader,aCols,,"MT100")
	Eval(bGDRefresh)
	Eval(bRefresh)
EndIf

Return

/* 
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A103ChkInfAdicºAutor  ³TOTVS		     º Data ³  03/10/2014  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Cria Array com Estrutura dos Campos da Aba de Informacoes    º±±  
±±º          ³Adicionais												   º±±  
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nTipo: 1 - Inclusao										   ³±±
±±³					  2 - Visualizacao / Exclusao						   ³±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103ChkInfAdic(nTipo)          

Local aAreaInfAdic 		:= GetArea()
Local lCteOriDest		:= SF1->(ColumnPos("F1_UFORITR")) > 0 .And. SF1->(ColumnPos("F1_MUORITR")) > 0 .And. SF1->(ColumnPos("F1_UFDESTR")) > 0 .And. SF1->(ColumnPos("F1_MUDESTR")) > 0

DEFAULT nTipo := 1

// Para ativar a aba de Informacoes Adicionais e necessario possuir pelo menos um dos campos abaixo:
// F1_INCISS  - Criado pelo UPDFIS
// F1_VEICUL1 - Criado pelo NFEP11R1 -> NFE11R164
// F1_VEICUL2 - Criado pelo NFEP11R1 -> NFE11R164
// F1_VEICUL3 - Criado pelo NFEP11R1 -> NFE11R164

aInfAdic := {}
DbSelectArea("SF1")

If cPaisLoc == "BRA" .And. FieldPos("F1_INCISS") > 0	// Grava municipio de incidencia do ISS para apresentar este dado quando o município da prestacao do servico nao for o do cliente, fornecedor ou SIGAMAT
	AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_INCISS"), SF1->F1_INCISS ))
	lFldInfAdic := .T.
EndIf
	// Grava dados do veiculo para transmissao do Manifesto Eletronico de Documentos Fiscais
If cPaisLoc == "BRA" .And. FieldPos("F1_VEICUL1") > 0	// Grava dados do veiculo para transmissao do Manifesto Eletronico de Documentos Fiscais
	AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_VEICUL1"), SF1->F1_VEICUL1 ))
	lFldInfAdic := .T.
EndIf
	// Grava dados do veiculo para transmissao do Manifesto Eletronico de Documentos Fiscais
If cPaisLoc == "BRA" .And. FieldPos("F1_VEICUL2") > 0	// Grava dados do veiculo para transmissao do Manifesto Eletronico de Documentos Fiscais
	AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_VEICUL2"), SF1->F1_VEICUL2 ))
	lFldInfAdic := .T.
EndIf
	// Grava dados do veiculo para transmissao do Manifesto Eletronico de Documentos Fiscais
If cPaisLoc == "BRA" .And. FieldPos("F1_VEICUL3") > 0	// Grava dados do veiculo para transmissao do Manifesto Eletronico de Documentos Fiscais
	AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_VEICUL3"), SF1->F1_VEICUL3 ))
	lFldInfAdic := .T.
EndIf
	// Data de execução do serviço
If cPaisLoc == "BRA" .And. ColumnPos("F1_DTCPISS") > 0	// Data de execução do serviço
    AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_DTCPISS"), SF1->F1_DTCPISS ))
	lFldInfAdic := .T.
EndIf
// Grava dados do do Simples Nacional
If cPaisLoc == "BRA" .And. ColumnPos("F1_SIMPNAC") > 0	// Grava dados do do Simples Nacional
	AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_SIMPNAC"), SF1->F1_SIMPNAC ))
	lFldInfAdic := .T.
EndIf
If cPaisLoc == "BRA" .And. ColumnPos("F1_CLIDEST") > 0	
	AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_CLIDEST"), SF1->F1_CLIDEST ))	
	lFldInfAdic := .T.
EndIf
If cPaisLoc == "BRA" .And. ColumnPos("F1_LOJDEST") > 0	
	AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_LOJDEST"), SF1->F1_LOJDEST ))	
	lFldInfAdic := .T.
EndIf
If cPaisLoc == "BRA" .And. ColumnPos("F1_ESTDES") > 0	
	AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_ESTDES"), SF1->F1_ESTDES ))	
	lFldInfAdic := .T.
EndIf
If cPaisLoc == "BRA" .And. lCteOriDest
	AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_UFORITR"), SF1->F1_UFORITR ))
	AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_MUORITR"), SF1->F1_MUORITR ))
	AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_UFDESTR"), SF1->F1_UFDESTR ))
	AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_MUDESTR"), SF1->F1_MUDESTR ))
	lFldInfAdic := .T.
Endif
If cPaisLoc == "BRA" .And. ColumnPos("F1_CLIPROP") > 0	
	AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_CLIPROP"), SF1->F1_CLIPROP ))	
	lFldInfAdic := .T.
Else
	AADD(aInfAdic, " ")
EndIf
If cPaisLoc == "BRA" .And. ColumnPos("F1_LJCLIPR") > 0	
	AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_LJCLIPR"), SF1->F1_LJCLIPR ))	
	lFldInfAdic := .T.
Else
	AADD(aInfAdic, " ")
EndIf 

If cPaisLoc == "BRA" .And. Type("lIntermed") == "L" .And. lIntermed
	AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_INDPRES"), SF1->F1_INDPRES ))
	AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_CODA1U"), SF1->F1_CODA1U ))
	lFldInfAdic := .T.
Endif

If cPaisLoc == "BRA" .And. FieldPos("F1_ESTPRES") > 0	// Grava Estado de incidencia do ISS para apresentar este dado quando o município da prestacao do servico nao for o do cliente, fornecedor ou SIGAMAT
	AADD(aInfAdic, IIF(nTipo==1, CriaVar("F1_ESTPRES"), SF1->F1_ESTPRES ))
	lFldInfAdic := .T.
EndIf

RestArea(aAreaInfAdic)         

Return
                 
//-------------------------------------------------------------------
/*/{Protheus.doc} A103LimpIT() 
Limpa itens ao trocar o tipo da nota no pré documento de entrada
@author taniel.silva
@since 17/10/2014
@version P12
/*/
//-------------------------------------------------------------------
Function A103LimpIT(Tipo,cFornece,cLoja)
Local nY := 0

cFornece	:= CriaVar("F1_FORNECE",.F.)
cLoja	:= CriaVar("F1_LOJA",.F.)
aCols	:= {}

aadd(aCols,Array(Len(aHeader)+1))

	For ny := 1 to Len(aHeader)
	If Trim(aHeader[ny][2]) == "D1_ITEM"
		aCols[1][ny] 	:= StrZero(1,Len(SD1->D1_ITEM))
	Else    
		If Trim(aHeader[ny][2]) <> "D1_ALI_WT".And. Trim(aHeader[nY][2]) <> "D1_REC_WT"
			aCols[1][ny] := CriaVar(aHeader[ny][2])
	    EndIf
	EndIf
	aCols[1][Len(aHeader)+1] := .F.
Next nY	


If bGdRefresh<>Nil
	Eval(bGDRefresh)
EndIf

If bRefresh<>Nil
	Eval(bRefresh)
EndIf

Return .T.


Function A103VldInss() 

Local lRet     := .T.
Local cINSS	 := SX3->X3_WHEN

If !Empty(cINSS) .And. Valtype(cINSS) == "C"  
   If  RAT(  ("M->"),cinss ) == 0  
	   lRet:= &(cINSS)
   Endif     
Endif

Return(lRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} VALIDSM4
Rotina que irá fazer a validação do campo F1_MENPAD na tabela SM4.
@author Allan Santos da Silva
@since 10/04/2015
@version 11.90
/*/
//-------------------------------------------------------------------

Static Function VALIDSM4(aNFEletr)

Local lRet := .F.

If SM4->(DbSeek(xFilial("SM4")+aNFEletr[8])) .Or. Empty(aNFEletr[8])
	If  !RegistroOk("SM4") 
		lRet := .F.
	Else
		lRet := .T.
	EndIf
Else
	Help(" ",1,"A084MSBLQ",,STR0211,1,0)//Código Invalido ou Não Cadastrado!!!
EndIf	

Return(lRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} A103CIAP()
Realiza a geração de CIAP ou Exclusão
@author Leonardo Quintania
@since 27/10/2014
@version 1.0
/*/
//-------------------------------------------------------------------
Function A103CIAP(nOpc,cAliasSD1,nQtdReq,cRotina,nF1Origem,nFilCiap,nCodCiap,aRecSF1Ori)

	If FindFunction("FISCIAP")
		cCiap := FISCIAP(nOpc,cAliasSD1,nQtdReq,cRotina,nF1Origem,nFilCiap,nCodCiap,aRecSF1Ori)
	EndIf
	
Return cCiap


//-------------------------------------------------------------------
/*/{Protheus.doc}A103ChkBN
Verifica se deve baixar o empenho na inclusao da nota.
Caso a nota seja retorno do beneficiamento, nao devera baixar empenho neste momento.
Se jah houver SGO para a OP e produto, significa que o empenho jah foi baixado
no envio para beneficiamento via Faturamento.

@author isaias.silva
@since 04/05/2015
@version P11.80 replica 12
/*/
//-------------------------------------------------------------------

Function A103ChkBN(cOp, cProduto , cLocal , nRecSD4)
Local aAreas := { GetArea(), SGO->(GetArea()) }
Local lRet   := .F.
Local lContinua := If(FindFunction("A410CtEmpBN"), A410CtEmpBN() == 2, .F.)

If lContinua
	SGO->(dbSetOrder(1)) // FILIAL + OP + COD + LOCAL
	If SGO->(MsSeek(xFilial('SGO')+cOP+cProduto+cLocal)) .And. SGO->(GO_RECNOD4) == nRecSD4
		lRet := .T.
	EndIf
EndIf

RestArea(aAreas[2])
RestArea(aAreas[1])
Return lRet
//-------------------------------------------------------------------
/*/{Protheus.doc}M103XAFEXC
Valida se a nota tem ativo a classificar.

@author alvaro.camillo
@since 14/12/2015
@version P12
/*/
//-------------------------------------------------------------------
Static Function M103XAFEXC(cDoc,cSerie,cFornec,cLoja,cProduto)
Local lRet			:= .T.
Local aArea		:= GetArea()
Local cQuery		:= ""
Local cNextAlias	:= GetNextAlias()

dbSelectArea('SN1')
dbSetOrder(1)

cQuery	+= " SELECT " 
cQuery	+= " 	N1_FILIAL, "
cQuery	+= " 	N1_CBASE, "
cQuery	+= " 	N1_ITEM  "
cQuery	+= " FROM  "
cQuery	+= " 	"+RetSQLName("SN1")+" SN1 "
cQuery	+= " WHERE "
cQuery	+= " 	N1_FILIAL = '"+xFilial("SN1")+"' AND "
cQuery	+= " 	N1_PRODUTO = '"+cProduto+"' AND "
cQuery	+= " 	N1_FORNEC = '"+cFornec+"' AND "
cQuery	+= " 	N1_LOJA = '"+cLoja+"' AND "
cQuery	+= " 	N1_NSERIE = '"+cSerie+"' AND "
cQuery	+= " 	N1_NFISCAL = '"+cDoc+"' AND "
cQuery	+= " 	SN1.D_E_L_E_T_ = ' ' "

cQuery := ChangeQuery(cQuery)  
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cNextAlias,.T.,.T.)  


While (cNextAlias)->(!EOF())
	
	If SN1->(MsSeek( (cNextAlias)->(N1_FILIAL+N1_CBASE+N1_ITEM)))
		If AF012AVLDL("SN3",.T.)
			If !SoftLock('SN1')
				lRet := .F.
				Exit
			EndIf
		Else
			lRet := .F.
			Exit
		EndIf
	EndIf
	(cNextAlias)->(dbSkip())
EndDo

(cNextAlias)->(dbCloseArea())
RestArea(aArea)
Return lRet 

//-------------------------------------------------------------------
/*/{Protheus.doc}A103Desp
Recalcula despesas acessórias, com base no percentual da quantidade 
utilizada do pedido de compras ou Doumento de saída

@author jose.delmondes
@since 20/01/2016
@version P11.80
/*/
//-------------------------------------------------------------------
Function A103Desp(lClassOrd)
Local nPosPc	:= GetPosSD1("D1_PEDIDO") 	//Pedido - Número Pedido de Compra
Local nPosItPc	:= GetPosSD1("D1_ITEMPC") 	//Pedido - Item Pedido de Compra

Local nPosNfOri := GetPosSD1("D1_NFORI")  	//Devolução - NF Origem
Local nPosSerOri:= GetPosSD1("D1_SERIORI")	//Devolução - Serie Origem
Local nPosITOri := GetPosSD1("D1_ITEMORI")	//Devolução - Item Origem
Local nPosProd  := GetPosSD1("D1_COD")		//Devolução - Cod Produto Origem
Local cCliOri	:= ca100for											//Devolução - Cliente Origem
Local cLojaOri	:= cLoja											//Devolução - Loja Origem

Local aAreaAnt := getArea()
Local aAreaSC7 := SC7->(getArea())
Local aAreaSD2 := SD2->(getArea())

Local nPosQuant	:= GetPosSD1("D1_QUANT")
Local nDivisor	:= 0
Local nMultipl	:= 0
Local nQuant	:= 0
Local nVlrDesp	:= 0
Local nVlrSeg	:= 0
Local nVlrFrt	:= 0

Default lClassOrd := .F.

SC7->(dbSetOrder(1))
SD2->(dbSetOrder(3))

If lClassOrd
	nQuant := aCols[n][nPosQuant]
Else
	nQuant := if(Empty(M->D1_QUANT),SD1->D1_QUANT,M->D1_QUANT)
EndIf
If nPosPc > 0 .And. nPosItPc > 0.And.;
 SC7->(MsSeek(xFilial("SC7")+aCols[n][nPosPc]+aCols[n][nPosItPc])) 
	
	If nQuant + SC7->C7_QUJE < SC7->C7_QUANT 
		nDivisor := SC7->C7_QUANT
		nMultipl := nQuant	
	Else
		nDivisor := SC7->C7_QUANT
		nMultipl := SC7->C7_QUANT - SC7->C7_QUJE
	EndIf
			 
	//Recalcula despesa
	If !Empty(SC7->C7_DESPESA)
		nVlrDesp := xMoeda((SC7->C7_DESPESA/nDivisor)*nMultipl,SC7->C7_MOEDA,1,dDEmissao,Nil,SC7->C7_TXMOEDA)		
		MaFisAlt("IT_DESPESA",nVlrDesp,N)
	EndIf
	//Recalcula seguro
	If !Empty(SC7->C7_SEGURO)
		nVlrSeg := 	xMoeda((SC7->C7_SEGURO/nDivisor)*nMultipl,SC7->C7_MOEDA,1,dDEmissao,Nil,SC7->C7_TXMOEDA)	
		MaFisAlt("IT_SEGURO",nVlrSeg,N)
	EndIf
	//Recalcula frete
	If !Empty(SC7->C7_VALFRE)
		nVlrFrt := xMoeda((SC7->C7_VALFRE/nDivisor)*nMultipl,SC7->C7_MOEDA,1,dDEmissao,Nil,SC7->C7_TXMOEDA)		
		MaFisAlt("IT_FRETE",nVlrFrt,N)
	EndIf
ElseIf nPosNfOri > 0 .And. nPosSerOri > 0 .And. nPosITOri > 0 .And. nPosITOri > 0 .And.;
  SD2->(MsSeek(xFilial("SD2")+aCols[n][nPosNfOri]+aCols[n][nPosSerOri]+cCliOri+cLojaOri+aCols[n][nPosProd]+aCols[n][nPosITOri]))
	nMultipl := nQuant
	nDivisor := SD2->D2_QUANT
	//Recalcula despesa
	If !Empty(SD2->D2_DESPESA)		
		MaFisAlt("IT_DESPESA",(SD2->D2_DESPESA/nDivisor)*nMultipl,N)
	EndIf
	//Recalcula seguro
	If !Empty(SD2->D2_SEGURO)		
		MaFisAlt("IT_SEGURO",(SD2->D2_SEGURO/nDivisor)*nMultipl,N)
	EndIf
	//Recalcula frete
	If !Empty(SD2->D2_VALFRE)		
		MaFisAlt("IT_FRETE",(SD2->D2_VALFRE/nDivisor)*nMultipl,N)
	EndIf
EndIf

RestArea(aAreaSD2)
RestArea(aAreaSC7)
RestArea(aAreaAnt)

Return

/*/{Protheus.doc}A103CodR
Função para auxiliar a validação do Ponto de Entrada M103CODR 
@author Manuela Cavalcante
@since 18/02/2016
@version P11.80
@return Nil
/*/
Function A103CodR(aCodR)
Local lRet := .T.
Local lCodR := .F.
Local lM103CODR := ExistBlock("M103CODR")

	If lM103CODR // P.E. para validar se o array "aCodR" está preenchido ou não".
		lCodR := ExecBlock("M103CODR",.F.,.F.,{aCodR})
		If Valtype(lCodR)=="L"
			lRet := lCodR
		EndIf
	EndIf			

Return lRet

/*/{Protheus.doc} A103CTECOL
Função para validar a existência de CT-e (Totvs Colaboração) ao excluir uma NF 
@author Rodrigo Machado Pontes
@since 27/04/16
@version P12
@return Nil
/*/

Static Function A103CTECOL(cNFCol,cSerCol,cFilCol,cForCol,cLjCol,cTipo)

Local lRet 		:= .F.
Local lIndCteCol	:= .F.
Local cIndexSD1	:= ""
Local cQuery		:= ""
Local aArea		:= GetArea()

cFilCol	:= PadR(cFilCol,TamSx3("D1_FILIAL")[1])
cNFCol	:= PadR(cNFCol,TamSx3("D1_NFORI")[1])
cSerCol	:= PadR(cSerCol,TamSx3("D1_SERIORI")[1])
cForCol	:= PadR(cForCol,TamSx3("D1_FORNECE")[1])
cLjCol	:= PadR(cLjCol,TamSx3("D1_LOJA")[1])
cTipo	:= PadR(cTipo,TamSx3("D1_TIPO")[1])

DbSelectArea("SD1")

If lIndCteCol == Nil
	If !Empty(SD1->(IndexKey(19))) //D1_FILIAL+D1_NFORI+D1_SERIORI+D1_FORNECE+D1_LOJA 
		lIndCteCol := .T.
	Else
		lIndCteCol := .F.
	Endif
Endif

If lIndCteCol
	SD1->(DbSetOrder(19)) //D1_FILIAL+D1_NFORI+D1_SERIORI+D1_FORNECE+D1_LOJA
	If SD1->(DbSeek(cFilCol + cNFCol + cSerCol + cForCol + cLjCol)) .And. SD1->D1_TIPO == "C"
		lRet := .T.
	Endif
Else
	cIndexSD1 := CriaTrab(,.f.)  
	
	cQuery    := "D1_FILIAL == '"     +cFilCol+  "' .AND. "
	cQuery    += "D1_NFORI == '"      +cNFCol+     "' .AND. "
	cQuery    += "D1_SERIORI == '"    +cSerCol+   "' .AND. "  
	cQuery    += "D1_FORNECE == '"    +cForCol+ "' .AND. "  
	cQuery    += "D1_LOJA == '"       +cLjCol+    "' .AND. "
	cQuery    += "D1_TIPO == '"       +cTipo+    "' .AND. "	  
	cQuery    += "D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_TIPO <> '" + cNFCol+cSerCol+cForCol+cLjCol+cTipo + "'"

	IndRegua("SD1",cIndexSD1,"D1_FILIAL+D1_NFORI+D1_SERIORI+D1_FORNECE+D1_LOJA",, cQuery ,"")
	nIndexSD1 :=RetIndex("SD1")+1  
	
	SD1->(dbSetorder(nIndexSD1))  
	SD1->(dbGoTop())     

	If SD1->(!Eof()) .And. SD1->D1_TIPO == "C"
		lRet := .T.
	EndIf

	FErase(cIndexSD1 + OrdBagExt())
	DbClearFilter()
Endif

RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} COLConVinc()
Função que verifica se o documento tem vinculo com o  totvs 
colaboração e retorna o RECNO da SDS referente ao documento ou zero 
caso não tenha vinculo.
Requer posicionamento da SF1

@author Flavio Lopes Rasta
@since 20/06/2016
@version 11 
/*/
//-------------------------------------------------------------------
Function COLConVinc(cNota,cSerie,cFornece,cLoja)
Local aAreaSDS	:= SDS->(GetArea())
Local nRecno 	:= 0
Local cChvNf	:= SF1->F1_CHVNFE

SDS->(DbSetOrder(1))
If SDS->(DbSeek(xFilial("SDS")+cNota+cSerie+cFornece+cLoja))
	If cChvNf == SDS->DS_CHAVENF
		nRecno := SDS->(Recno())
	EndIf
Endif

RestArea(aAreaSDS)
Return nRecno

//-------------------------------------------------------------------
/*/{Protheus.doc} COLConVinc()
Cria grid de divergência de impostos na classificação do documento
de entrada(MATA103)

@author Flavio Lopes Rasta
@since 22/06/2016
@version 11 
/*/
//-------------------------------------------------------------------
Function COLListDiv(oWnd,aPosWnd,oGet)
Local aHeadImp	:={}
Local nX			:= 0

Aadd(aHeadImp, {" ","LEGENDA", "@BMP", 2, 0,,, 'C',,'V'})
Aadd(aHeadImp, {AllTrim("Imposto"),"IMPOSTO","@!",25,0,,,'C',,'R'})
Aadd(aHeadImp, {AllTrim("Valor TES"),"VALORT"	,"@E 999,999,999.99",14,2,,,'N',,'R'})
Aadd(aHeadImp, {AllTrim("Valor XML"),"VALORX"	,"@E 999,999,999.99",14,2,,,'N',,'R'})
Aadd(aHeadImp, {AllTrim("Aliq. TES"),"ALIQT"	,"@E 999,999,999.99",14,2,,,'N',,'R'})
Aadd(aHeadImp, {AllTrim("Aliq. XML"),"ALIQX"	,"@E 999,999,999.99",14,2,,,'N',,'R'})	

TSay():New(5,10,{|| "Impostos:"},oWnd,,,,,,.T.,,,50,10)
oListDvIm := MsNewGetDados():New(5,45,60,385,4, "AllwaysTrue", "AllwaysTrue", /*cIniCpos*/, ,, 999, "AllwaysTrue", "", "AllwaysTrue", oWnd,@aHeadImp)

TSay():New(5,415,{|| "Itens com Divergência:"},oWnd,,,,,,.T.,,,70,9)
@ 5 ,476 MSGET oDivCount VAR nDivCount COLOR CLR_RED OF oWnd PIXEL SIZE 20,9 When .F.
TSay():New(7,500,{|| "/"},oWnd,,,,,,.T.,,,9,9)
@ 5 ,506 MSGET oDivTot VAR Len(aCols) COLOR CLR_RED OF oWnd PIXEL SIZE 20,9 When .F.
@ 20 ,476 BUTTON "Próximo Item com Divergência" SIZE 80 ,11 ACTION {||oGet:GoTo(A103ProDiv()),A103PosFld()}  OF oWnd PIXEL

For nX := 1 To Len(aCols)
	n := nX
ColLoadDiv(oListDvIm,oDivCount)
Next nX

n := 1

Return oListDvIm

//-------------------------------------------------------------------
/*/{Protheus.doc} ColLoadDiv()
Carrega dados no grid de divergência de impostos na classificação
do documento de entrada (MATA103)
@author Flavio Lopes Rasta
@since 22/06/2016
@version 11 
/*/
//-------------------------------------------------------------------
Function ColLoadDiv(oListDvIm,oDivCount)
Local oOK			:= LoadBitmap(GetResources(),'BR_VERDE')
Local oNO			:= LoadBitmap(GetResources(),'BR_VERMELHO')
Local aImpostos		:= {}
Local nX			:= 1
Local aColsImp		:= {}
Local nPosLegend 	:= GetPosSD1("D1_LEGENDA")

Local nPosFornec	:= GetPosSD1("D1_FORNECE")
Local nPosLoja		:= GetPosSD1("D1_LOJA")
Local nPosDoc		:= GetPosSD1("D1_DOC")
Local nPosSerie		:= GetPosSD1("D1_SERIE")
Local nPosItem		:= GetPosSD1("D1_ITEM")

Local nValorTes := 0
Local nAliqTes	:= 0
Local lMVDiviZer:= SuperGetMv("MV_DIVIZER",.F.,.F.)
Local nDiverg	:= 0
Local lCOLDVIMP := ExistBlock("COLDVIMP")

SDT->(DbSetOrder(8))
If SDT->(DbSeek(xFilial("SDT") + aCols[n,nPosFornec] + aCols[n,nPosLoja] + aCols[n,nPosDoc] + aCols[n,nPosSerie] + aCols[n,nPosItem] ))

	aAdd(aImpostos,{"IPI"		,MaFisRet(n,"IT_VALIPI")	,"DT_XMLIPI"	,MaFisRet(n,"IT_ALIQIPI" )	,"DT_XALQIPI"})
	aAdd(aImpostos,{"ICMS"		,MaFisRet(n,"IT_VALICM")	,"DT_XMLICM"	,MaFisRet(n,"IT_ALIQICM" )	,"DT_XALQICM"})
	aAdd(aImpostos,{"ISS"		,MaFisRet(n,"IT_VALISS")	,"DT_XMLISS"	,MaFisRet(n,"IT_ALIQISS" )	,"DT_XALQISS"})
	aAdd(aImpostos,{"PIS"		,MaFisRet(n,"IT_VALPS2")	,"DT_XMLPIS" 	,MaFisRet(n,"IT_ALIQPS2")	,"DT_XALQPIS"})
	aAdd(aImpostos,{"COFINS"	,MaFisRet(n,"IT_VALCF2")	,"DT_XMLCOF"	,MaFisRet(n,"IT_ALIQCF2")	,"DT_XALQCOF"})
	aAdd(aImpostos,{"ICMS ST"	,MaFisRet(n,"IT_VALSOL")	,"DT_XMLICST"	,MaFisRet(n,"IT_ALIQSOL")	,"DT_XALICST"})
		
	For nX:=1 To Len(aImpostos)
		
		aAdd(aColsImp,{})
		
		nValorTes 	:= aImpostos[nX][2]
		nAliqTes	:= If(lMVDiviZer .And. nValorTes == 0 ,0,aImpostos[nX][4])
	
		If nValorTes <> SDT->&(aImpostos[nX][3]) .Or. nAliqTes <> SDT->&(aImpostos[nX][5])
			aAdd(aTail(aColsImp),oNO)
		Else
			aAdd(aTail(aColsImp),oOK)
		Endif
		aAdd(aTail(aColsImp),aImpostos[nX][1])
		aAdd(aTail(aColsImp),nValorTes)
		aAdd(aTail(aColsImp),SDT->&(aImpostos[nX][3]))
		aAdd(aTail(aColsImp),nAliqTes)
		aAdd(aTail(aColsImp),SDT->&(aImpostos[nX][5]))
		aAdd(aTail(aColsImp),.F.)
	Next nX

	If lCOLDVIMP
		aColsImp := ExecBlock("COLDVIMP",.F.,.F.,{"MATA103",aColsImp})
	Endif
	
	If (nPos:=aScan(aColsImp,{|x| x[1]:cName == "BR_VERMELHO"})) > 0
		aCols[n][nPosLegend] := aColsImp[nPos][1]:cName 
	Else
		aCols[n][nPosLegend] := aColsImp[1][1]:cName
	Endif

Endif

oListDvIm:SetArray(aColsImp)

oListDvIm:Refresh()

For nX:=1 To Len(aCols)
	If aCols[nX,nPosLegend] == "BR_VERMELHO"
		nDiverg++
	Endif
Next nX

nDivCount := nDiverg

oDivCount:Refresh()

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A103PosFld()
Atualiza dados no grid de divergência de impostos na classificação
do documento de entrada (MATA103)
@author Flavio Lopes Rasta
@since 22/06/2016
@version 11 
/*/
//-------------------------------------------------------------------

Function A103PosFld() 

If SuperGetMV("MV_NFDVIMP",.F.,.F.) .And. COLConVinc(SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA) > 0 .And. !INCLUI
	ColLoadDiv(oListDvIm,oDivCount)
Endif

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} A103DivImp()
Carrega dados no grid de divergência de impostos na classificação
do documento de entrada (MATA103)
@author Flavio Lopes Rasta
@since 22/06/2016
@version 11 
/*/
//-------------------------------------------------------------------
Function A103DivImp(aLineDiv)
Local aImpostos	:= {}
Local aColsImp	:= {}
Local nX		:= 1
Local cRet		:= "BR_VERDE"
Local oOK		:= LoadBitmap(GetResources(),'BR_VERDE')
Local oNO		:= LoadBitmap(GetResources(),'BR_VERMELHO')

Local nPosFornec	:= GetPosSD1("D1_FORNECE")
Local nPosLoja		:= GetPosSD1("D1_LOJA")
Local nPosDoc		:= GetPosSD1("D1_DOC")
Local nPosSerie		:= GetPosSD1("D1_SERIE")
Local nPosItem		:= GetPosSD1("D1_ITEM")

Local nValorTes := 0
Local nAliqTes	:= 0
Local lMVDiviZer:= SuperGetMv("MV_DIVIZER",.F.,.F.)
Local lCOLDVIMP := ExistBlock("COLDVIMP")

SDT->(DbSetOrder(8))
If SDT->(DbSeek(xFilial("SDT") + aCols[n,nPosFornec] + aCols[n,nPosLoja] + aCols[n,nPosDoc] + aCols[n,nPosSerie] + aCols[n,nPosItem] ))

	aAdd(aImpostos,{"IPI"		,MaFisRet(n,"IT_VALIPI")	,"DT_XMLIPI"	,MaFisRet(n,"IT_ALIQIPI" )	,"DT_XALQIPI"})
	aAdd(aImpostos,{"ICMS"		,MaFisRet(n,"IT_VALICM")	,"DT_XMLICM"	,MaFisRet(n,"IT_ALIQICM" )	,"DT_XALQICM"})
	aAdd(aImpostos,{"ISS"		,MaFisRet(n,"IT_VALISS")	,"DT_XMLISS"	,MaFisRet(n,"IT_ALIQISS" )	,"DT_XALQISS"})
	aAdd(aImpostos,{"PIS"		,MaFisRet(n,"IT_VALPS2")	,"DT_XMLPIS" 	,MaFisRet(n,"IT_ALIQPS2")	,"DT_XALQPIS"})
	aAdd(aImpostos,{"COFINS"	,MaFisRet(n,"IT_VALCF2")	,"DT_XMLCOF"	,MaFisRet(n,"IT_ALIQCF2")	,"DT_XALQCOF"})
	aAdd(aImpostos,{"ICMS ST"	,MaFisRet(n,"IT_VALSOL")	,"DT_XMLICST"	,MaFisRet(n,"IT_ALIQSOL")	,"DT_XALICST"})
	
	If lCOLDVIMP
		For nX:=1 To Len(aImpostos)
			
			nValorTes	:= aImpostos[nX][2]
			nAliqTes	:= If(lMVDiviZer .And. (nValorTes == 0),0,aImpostos[nX][4])
			
			aAdd(aColsImp,{})
			aAdd(aTail(aColsImp),If(nValorTes == SDT->&(aImpostos[nX][3]) .And. nAliqTes == SDT->&(aImpostos[nX][5]),oOK,oNO))
			aAdd(aTail(aColsImp),aImpostos[nX][1])
			aAdd(aTail(aColsImp),nValorTes)
			aAdd(aTail(aColsImp),SDT->&(aImpostos[nX][3]))
			aAdd(aTail(aColsImp),nAliqTes)
			aAdd(aTail(aColsImp),SDT->&(aImpostos[nX][5]))
			aAdd(aTail(aColsImp),.F.)
		Next nX
		
		aColsImp := ExecBlock("COLDVIMP",.F.,.F.,{"MATA103",aColsImp})
		
		If aScan(aColsImp,{|x| x[1]:cName == "BR_VERMELHO"}) > 0
			cRet := "BR_VERMELHO"
		Endif
	Else
		For nX:=1 To Len(aImpostos)
			
			nValorTes	:= aImpostos[nX][2]
			nAliqTes	:= If(lMVDiviZer .And. (nValorTes == 0),0,aImpostos[nX][4])
			
			If nValorTes <> SDT->&(aImpostos[nX][3]) .Or. nAliqTes <> SDT->&(aImpostos[nX][5])
				cRet:= "BR_VERMELHO"
				Exit
			Endif
		Next nX
	Endif	
Endif

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A103ProDiv()
Atualiza legenda do item do docuemtnto de entrada (MATA103)
@author Flavio Lopes Rasta
@since 22/06/2016
@version 11 
/*/
//-------------------------------------------------------------------
Function A103ProDiv()
Local nX	:= 1
Local nRet	:= 1
For nX:=1 To Len(aCols)
	If aCols[nX,GetPosSD1("D1_LEGENDA")] == "BR_VERMELHO"
		nRet:=nX
		Exit
	Endif
Next
Return nRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A103ProDiv()
@since 22/06/2016
@version 11 
/*/
//-------------------------------------------------------------------
Function A103TpComp(aObjetos,c103Tipo,c103TpComp)
Local lRet := .F.

If c103Tipo <> "Complemento"
	aObjetos[11]:lActive := .F.
	c103TpComp := ""
Else
	aObjetos[11]:lActive := .T.
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} RetDevMerc()
Retorna descricao da marcacao de opcao de devolucao de mercadoria nao entregue
@author TOTVS
@since 08/02/2017
@version 11 
/*/
//-------------------------------------------------------------------
Function RetDevMerc(cDevMerc)

Local cRet := " "

If cDevMerc == "N"   
	cRet := "Nao"
ElseIf cDevMerc == "S"
	cRet := "Sim"
Else
	cRet := " "
EndIf

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A103GRVSF8()
Grava SF8 (Conhecimento Frete x Nota Original)
@author Rodrigo M Pontes
@since 10/04/2017
@version 11 
/*/
//-------------------------------------------------------------------

Function A103GRVSF8()

Local aArea		:= GetArea()
Local aF8NfOri	:= {}
Local nI		:= 0
Local nPosNFOri	:= GetPosSD1("D1_NFORI")
Local nPosSeOri	:= GetPosSD1("D1_SERIORI")
Local nPosPrd	:= GetPosSD1("D1_COD")
Local lF8NfOri	:= .F.
Local lColab	:= .F.
Local cForOrig	:= ""
Local cLojOrig	:= ""

If nPosNFOri > 0 .And. nPosSeOri > 0 .And. nPosPrd > 0
	lColab := !COLFINSDS(1,cNFiscal+cSerie+cA100For+cLoja,1) //.F. = Encontrou na SDS

	For nI := 1 To Len(aCols)
		If !aCols[nI,Len(aHeader)+1]
			If !Empty(aCols[nI,nPosNFOri])
				//Verifica se CTE existe na SF8 e possui vinculo com a nota original
				If !lColab
					lF8NfOri	:= A103OriSF8(cNFiscal,cSerie,cA100For,cLoja,aCols[nI,nPosNFOri],aCols[nI,nPosSeOri])
				Else
					aF8NfOri	:= A103OriSDS(cNFiscal,cSerie,cA100For,cLoja,aCols[nI,nPosNFOri],aCols[nI,nPosSeOri])
					lF8NfOri	:= aF8NfOri[1]
					cForOrig	:= aF8NfOri[2]
					cLojOrig	:= aF8NfOri[3]
				Endif
				
				If !lF8NfOri
					If RecLock("SF8",.T.)
						SF8->F8_FILIAL	:= xFilial("SF8")
						SF8->F8_DTDIGIT	:= Iif(Empty(SF1->F1_DTDIGIT),Date(),SF1->F1_DTDIGIT)
						SF8->F8_NFDIFRE	:= cNFiscal
						SF8->F8_SEDIFRE	:= cSerie
						SF8->F8_TRANSP	:= cA100For
						SF8->F8_LOJTRAN	:= cLoja
						SF8->F8_NFORIG	:= aCols[nI,nPosNFOri]
						SF8->F8_SERORIG	:= aCols[nI,nPosSeOri]
						SF8->F8_FORNECE	:= Iif(!lColab,cA100For,cForOrig)
						SF8->F8_LOJA	:= Iif(!lColab,cLoja,cLojOrig)
						SF8->F8_TIPO	:= "F"
						SF8->(MsUnlock())
					Endif
				Endif
			Endif
		Endif
	Next nI
Endif

RestArea(aArea)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A103OriSDS()
Busca pelo Fornecedor + Loja da nf original via Colaboração
@author Rodrigo M Pontes
@since 10/04/2020
@version 11 
/*/
//-------------------------------------------------------------------

Function A103OriSDS(cNFiscal,cSerie,cA100For,cLoja,cNFOri,cSeOri)

Local cQry		:= ""
Local cFornOrig	:= ""
Local cLojaOrig	:= ""
Local cAliasQry := GetNextAlias()
Local lExistSF8	:= .F.
Local aRet		:= {}

cQry := " SELECT DISTINCT F1_FORNECE, F1_LOJA"
cQry += " FROM " + RetSqlName("SF1") + " SF1, " + RetSqlName("SDT") + " SDT, " + RetSqlName("SD1") + " SD1"
cQry += " WHERE  SF1.F1_DOC = SDT.DT_NFORI"
cQry += " AND    SF1.F1_SERIE = SDT.DT_SERIORI"
cQry += " AND    SD1.D1_ITEM = SDT.DT_ITEMORI"
cQry += " AND    SF1.F1_CHVNFE = SDT.DT_CHVNFO"
cQry += " AND    SDT.DT_DOC = '" + cNFiscal + "'"
cQry += " AND    SDT.DT_SERIE = '" + cSerie + "'"
cQry += " AND 	 SDT.DT_FORNEC = '" + cA100For + "'"
cQry += " AND 	 SDT.DT_LOJA = '" + cLoja + "'"
cQry += " AND	 SDT.DT_NFORI = '" + cNFOri + "'"
cQry += " AND 	 SDT.DT_SERIORI = '" + cSeOri + "'"
cQry += " AND SF1.D_E_L_E_T_ = ' '
cQry += " AND SD1.D_E_L_E_T_ = ' '
cQry += " AND SDT.D_E_L_E_T_ = ' ' 

cQry := ChangeQuery(cQry)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),cAliasQry)

DbSelectArea(cAliasQry)
If (cAliasQry)->(!EOF())
	cFornOrig	:= (cAliasQry)->F1_FORNECE
	cLojaOrig	:= (cAliasQry)->F1_LOJA
Endif

(cAliasQry)->(DbCloseArea())

If !Empty(cFornOrig) .And. !Empty(cLojaOrig)
	lExistSF8 := A103OriSF8(cNFiscal,cSerie,cA100For,cLoja,cNFOri,cSeOri,cFornOrig,cLojaOrig)
Endif

aRet := {lExistSF8,cFornOrig,cLojaOrig}

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A103OriSF8()
Verifica se amarração cte x nf original ja existe na SF8
@author Rodrigo M Pontes
@since 10/04/2017
@version 11 
/*/
//-------------------------------------------------------------------

Function A103OriSF8(cNFiscal,cSerie,cA100For,cLoja,cNFOri,cSeOri,cFornOrig,cLojaOrig)

Local lRet		 := .F.
Local cQry		 := ""
Local cAlF8NFCTE := GetNextAlias()

Default cFornOrig	:= ""
Default cLojaOrig	:= ""

cQry := " SELECT F8_NFDIFRE"
cQry += " FROM " + RetSqlName("SF8")
cQry += " WHERE D_E_L_E_T_ = ''"
cQry += " AND F8_NFDIFRE = '" + cNFiscal + "'"
cQry += " AND F8_SEDIFRE = '" + cSerie + "'"
cQry += " AND F8_TRANSP = '" + cA100For + "'"
cQry += " AND F8_LOJTRAN = '" + cLoja + "'"
cQry += " AND F8_NFORIG = '" + cNFOri + "'"
cQry += " AND F8_SERORIG = '" + cSeOri + "'"

If !Empty(cFornOrig) .And. !Empty(cLojaOrig)
	cQry += " AND F8_FORNECE = '" + cFornOrig + "'"
	cQry += " AND F8_LOJA = '" + cLojaOrig + "'"
Else
	cQry += " AND F8_FORNECE = '" + cA100For + "'"
	cQry += " AND F8_LOJA = '" + cLoja + "'"
Endif

cQry := ChangeQuery(cQry)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),cAlF8NFCTE)

DbSelectArea(cAlF8NFCTE)
If (cAlF8NFCTE)->(!EOF())
	lRet := .T.
Endif

(cAlF8NFCTE)->(DbCloseArea())

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} AProdFanta()
Retorna se o produto é fantasma
@author Yuri Porto
@since 03/02/2017
@version 11 
/*/
//-------------------------------------------------------------------
Function AProdFanta(nProd)

Local lRet := .T.
// Remover apos Dez/2018
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} GetDelTitImp()
Função responsavel por buscar o proximo prefixo dos titulos de COF, PIS ou ISS de importação, 
caso não tenha encontrado pelos parametros "MV_PREFCOF", "MV_PREFPIS" e "MV_PREFISS" respectivamente.

@author Bruno Akyo Kubagawa
@since 01/11/2017
@version 12.1.17
/*/
//-------------------------------------------------------------------
static function GetDelTitImp(cPrefPIS, cPrefCOF, cPrefISS, cPreFase, nCont, nTotal)
	local lRet := .F.
	local cPrefixo := SE2->E2_PREFIXO
	local cPrefAux := ""
	local lContinua := .F.
	
	if nCont < nTotal

		if alltrim(SE2->E2_TIPO) == "PIS" .and. cPrefixo > cPrefPIS 
			lContinua := .T.
			cPrefAux := cPrefPIS

		elseif alltrim(SE2->E2_TIPO) == "COF" .and. cPrefixo > cPrefCOF
			lContinua := .T.
			cPrefAux := cPrefCOF
		
		elseif alltrim(SE2->E2_TIPO) == "ISS" .and. cPrefixo > cPrefISS
			lContinua := .T.
			cPrefAux := cPrefISS
		elseif alltrim(SE2->E2_TIPO) == "TX" .and. cPrefixo > cPreFase
			lContinua := .T.
			cPrefAux := cPreFase
		endif	

		While lContinua
			cPrefAux := soma1(cPrefAux)
			If cPrefAux == cPrefixo .and. (SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM == (xFilial("SE2") + cPrefAux + SF1->F1_DUPL) )
				lRet := .T.
				nCont += 1
				lContinua := .F.
				exit
			ElseIf (SE2->E2_FILIAL+SE2->E2_NUM != (xFilial("SE2") + SF1->F1_DUPL) )
				lContinua := .F.
				exit
			Endif
		EndDo
		
	endif
	
return lRet

/*/{Protheus.doc}A103TpRep
Função para habilitação do campo D1_TPREPAS utilizado no REINF
@return lRet = .T. habilita; .F. não habilita 

@author Carlos Capeli
@since  30/08/2016
		 
/*/
Function A103TpRep()

Local aArea := GetArea()
local aAreaSA2 := SA2->(GetArea())
Local lRet := .F.

SA2->(dbSetOrder(1))
If SA2->(MsSeek(xFilial("SA2")+cA100For+cLoja))
	If SA2->A2_DESPORT == "1"
		lRet := .T.
	EndIf
EndIf

RestArea(aAreaSA2)
RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A103MUFCTE()
Função de validação do codigo de municipio

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/
//-------------------------------------------------------------------

Function A103MUFCTE(cCpoVld)

Local lRet		:= .T.
Local cEst		:= ""
Local cCodMun	:= ""
Local aArea	:= GetArea()

If cCpoVld == "ORIG"
	cEst 		:= PadR(aInfAdic[10],TamSx3("CC2_EST")[1])
	cCodMun 	:= PadR(aInfAdic[11],TamSx3("CC2_CODMUN")[1])
Elseif cCpoVld == "DEST"
	cEst 		:= PadR(aInfAdic[12],TamSx3("CC2_EST")[1])
	cCodMun 	:= PadR(aInfAdic[13],TamSx3("CC2_CODMUN")[1])
Endif

If !Empty(cCodMun)
	DbSelectArea("CC2")
	CC2->(DbSetOrder(3))
	If CC2->(DbSeek(xFilial("CC2") + cCodMun))
		If cCpoVld == "ORIG" .And. Empty(aInfAdic[10])
			aInfAdic[10] := CC2->CC2_EST
		Elseif cCpoVld == "DEST" .And. Empty(aInfAdic[12])
			aInfAdic[12] := CC2->CC2_EST
		Endif
	Else
		lRet := .F.
	Endif
Else
	If cCpoVld == "ORIG"
		aInfAdic[10] := Space(2)
		A103UFREF()
	Elseif cCpoVld == "DEST"
		aInfAdic[12] := Space(2)
		A103UFDEST()
	Endif	
Endif

RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A103MUFCTE()
Filtro da consulta padrão CC2CTE

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/
//-------------------------------------------------------------------

Function M103FILCTE()

Local cFiltro 	:= ".T."
Local cReadVar	:= ReadVar()

//Municipio Origem
If cReadVar == "AINFADIC[11]"
	cFilUF := "O"
	M->F1_UFORITR := AINFADIC[10]
	
	cFiltro := "M->F1_UFORITR == CC2->CC2_EST"
	
//Municipio Destino
Elseif cReadVar == "AINFADIC[13]"
	cFilUF := "D"
	M->F1_UFDESTR := AINFADIC[12] 
	
	cFiltro := "M->F1_UFDESTR == CC2->CC2_EST"
Endif

If cFiltro == ".T."
	If cFilUf == "O"
		M->F1_UFORITR := AINFADIC[10]
		cFiltro := "M->F1_UFORITR == CC2->CC2_EST"
	Elseif cFilUf == "D"
		M->F1_UFDESTR := AINFADIC[12]
		cFiltro := "M->F1_UFDESTR == CC2->CC2_EST"
	Endif
Endif

Return &cFiltro

//-------------------------------------------------------------------
/*/{Protheus.doc} A103UFREF()
Atualiza UF de origem

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/
//-------------------------------------------------------------------

Static Function A103UFREF()

If !Empty(aInfAdic[10])
	cUfOrig := aInfAdic[10]
	MaFisRef("NF_UFORIGEM","MT100",aInfAdic[10])
Else
	If cTipo $ "DB" //Cliente
		cUfOrig := Posicione("SA1",1,xFilial("SA1")+cA100For+cLoja,"A1_EST")
	Else
		cUfOrig := Posicione("SA2",1,xFilial("SA2")+cA100For+cLoja,"A2_EST")
	Endif
	MaFisRef("NF_UFORIGEM","MT100",cUfOrig)
Endif

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} A103UFDEST()
Atualiza UF de origem

@author r.cavalcante
@since 29/04/2022
@version 12
/*/
//-------------------------------------------------------------------

Static Function A103UFDEST()
Local cEstado		:= "" 

If !Empty(aInfAdic[12])
	MaFisRef("NF_UFDEST","MT100", aInfAdic[12])
Else
	cEstado	:= GetNewPar("MV_ESTADO", "")  
	MaFisRef("NF_UFDEST","MT100", cEstado)
Endif

Return .T.


//-------------------------------------------------------------------
/*/{Protheus.doc} A103UFREF()
Validação para que os valores de retenção/dedução/faturamento direto
não sejam maiores que os valores do PC/NF.

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/
//-------------------------------------------------------------------

Function A103RDFVLD()

Local aArea		:= GetArea()
Local nRet		:= 0
Local nDed		:= 0
Local nFat		:= 0
Local nTot		:= 0
Local nToRDF	:= 0
Local nRetPC	:= 0
Local nDedPC	:= 0
Local nFatPC	:= 0
Local nTotPC	:= 0
Local nToRDFPC	:= 0
Local nI		:= 0
Local nRound	:= TamSx3("D1_TOTAL")[2]
Local nPD1PC	:= GetPosSD1("D1_PEDIDO")
Local nPD1ITPC	:= GetPosSD1("D1_ITEMPC")
Local nPD1XRET	:= GetPosSD1("D1_RETENCA")
Local nPD1XDED	:= GetPosSD1("D1_DEDUCAO")
Local nPD1XFAT	:= GetPosSD1("D1_FATDIRE")
Local nPD1TOT	:= GetPosSD1("D1_TOTAL")
Local cMsgRet	:= ""
Local cMsgDed	:= ""
Local cMsgFat	:= ""
Local cMsg		:= ""
Local lRet		:= .T.

DbSelectArea("SC7")
SC7->(DbSetOrder(1))

If nPD1PC > 0 .And. nPD1ITPC > 0
	For nI := 1 To Len(aCols)
		If !aCols[nI,Len(aHeader)+1]
			If !Empty(aCols[nI,nPD1PC]) //Tem pedido
				If SC7->(DbSeek(xFilial("SC7") + aCols[nI,nPD1PC] + aCols[nI,nPD1ITPC]))
					//Valores do PC
					nTotPC		:= Round((SC7->C7_QUANT - SC7->C7_QUJE) * SC7->C7_PRECO,nRound)
					nRetPC 		:= SC7->C7_RETENCA - SC7->C7_QUJERET
					nDedPC 		:= SC7->C7_DEDUCAO - SC7->C7_QUJEDED
					nFatPC 		:= SC7->C7_FATDIRE - SC7->C7_QUJEFAT
					nToRDFPC	:= nRetPC+nDedPC+nFatPC
					
					//Valores na NF
					nTot	:= aCols[nI,nPD1TOT]
					nRet	:= aCols[nI,nPD1XRET]
					nDed	:= aCols[nI,nPD1XDED]
					nFat	:= aCols[nI,nPD1XFAT]
					nToRDF	:= nRet+nDed+nFat 
					
					//Saldo do PC apos NF
					nSaldoPC	:= nTotPC-nTot 
					
					//Saldo Ret/Ded/Fat do PC apos NF
					nSaldoRDF := nToRDFPC-nToRDF
					
					//Valida se valores de retenção/dedução/faturamento direto são maiores do que o PC
					If nRet > nRetPc //Valor retenção maior que saldo disponivel
						cMsgRet	:= STR0179 + AllTrim(Transform(nRet,X3Picture("D1_RETENCA"))) + STR0180 + AllTrim(Transform(nRetPC,X3Picture("D1_RETENCA"))) //"Valor de retenção: "##" é maior que o saldo disponivel no PC: "
					Endif
					
					If nDed > nDedPC //Valor dedução maior que saldo disponivel
						cMsgDed	:= STR0181 + AllTrim(Transform(nDed,X3Picture("D1_DEDUCAO"))) + STR0180 + AllTrim(Transform(nDedPC,X3Picture("D1_DEDUCAO"))) //"Valor de dedução: "##" é maior que o saldo disponivel no PC: "
					Endif
						
					If nFat > nFatPC //Valor faturamento direto maior que saldo disponivel
						cMsgFat	:= STR0182 + AllTrim(Transform(nFat,X3Picture("D1_FATDIRE"))) + STR0180 + AllTrim(Transform(nFatPC,X3Picture("D1_FATDIRE"))) //"Valor de faturamento direto: "##" é maior que o saldo disponivel no PC: "
					Endif
					
					If !Empty(cMsgRet) .Or. !Empty(cMsgDed) .Or. !Empty(cMsgFat)
						cMsg := STR0183 + StrZero(nI,TamSx3("D1_ITEM")[1]) + STR0184 //"O Item NF: "##" esta com divergencias nos valores de Retenção/Dedução/Faturamento Direto"
							
						If !Empty(cMsgRet)
							cMsg += CRLF + CRLF + cMsgRet
						Endif
							
						If !Empty(cMsgDed)
							cMsg += CRLF + CRLF + cMsgDed
						Endif
						
						If !Empty(cMsgFat)
							cMsg += CRLF + CRLF + cMsgFat
						Endif
					Endif
					
					If !Empty(cMsg)
						Exit
					Endif					

					If nSaldoPC <= 0 //PC totalmente atendido
						If nRet <> nRetPC
							cMsgRet	:= STR0185 + AllTrim(Transform(nRetPC,X3Picture("D1_RETENCA"))) //"Valor de retenção deve ser igual ao saldo disponivel no PC: "
						Endif
						
						If nDed <> nDedPC
							cMsgDed	:= STR0186 + AllTrim(Transform(nDedPC,X3Picture("D1_DEDUCAO"))) //"Valor de dedução deve ser igual ao saldo disponivel no PC: "
						Endif
						
						If nFat <> nFatPC
							cMsgFat	:= STR0187 + AllTrim(Transform(nFatPC,X3Picture("D1_FATDIRE"))) //"Valor de faturamento direto deve ser igual ao saldo disponivel no PC: "
						Endif
						
						If !Empty(cMsgRet) .Or. !Empty(cMsgDed) .Or. !Empty(cMsgFat)
							cMsg := STR0183 + StrZero(nI,TamSx3("D1_ITEM")[1]) + STR0184 + CRLF + ; //"O Item NF: "##" esta com divergencias nos valores de Retenção/Dedução/Faturamento Direto"
									 STR0188 //"É necessario que os valores sejam iguais aos saldos disponiveis, pois o PC esta sendo totalmente atendido."
							
							If !Empty(cMsgRet)
								cMsg += CRLF + CRLF + cMsgRet
							Endif
							
							If !Empty(cMsgDed)
								cMsg += CRLF + CRLF + cMsgDed
							Endif
							
							If !Empty(cMsgFat)
								cMsg += CRLF + CRLF + cMsgFat 
							Endif
							
							Exit
						Endif
					//PC parcialmente atendido
					Else
						If nSaldoRDF > nSaldoPC //saldo de retenção/dedução/faturamento maior que o saldo do PC
							cMsg := STR0183 + StrZero(nI,TamSx3("D1_ITEM")[1]) + STR0189 + AllTrim(Transform(nSaldoRDF - nSaldoPC,X3Picture("D1_FATDIRE"))) //Item NF: # esta com os valores de retenção/dedução/faturamento direto muito baixo. A soma dos valores deve ser pelo menos, mais: "
							Exit
						Elseif nSaldoPC > 0 .and. nSaldoRDF == 0 .And. nToRDFPC > 0 //PC parcialmente atendido, valores de retenção/dedução/faturamento totalmente atendido
							cMsg := STR0183 + StrZero(nI,TamSx3("D1_ITEM")[1]) + STR0190 //Item NF: # esta com os valores de retenção/dedução/faturamento direto estão sendo totalmente atendidos, porem o PC não. Corrija os valores."
							Exit
						Endif
					Endif
				Endif
			Endif
		Endif
	Next nI
Endif

If !Empty(cMsg)
	Help(" ",1,"INTRM",,cMsg,1,1)
	lRet := .F.
Endif

RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A103ATURM()
Atualização do saldo atendido dos valores de retenção/dedução 
e faturamento direto no pedido de compra.

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/
//-------------------------------------------------------------------

Function A103ATURM(cOperador,cCampo,nValor,cPedido,cItemPC)

Local aArea	:= GetArea()

DbSelectArea("SC7")
SC7->(DbSetOrder(1))
If SC7->(DbSeek(xFilial("SC7") + cPedido + cItemPc))
	If RecLock("SC7",.F.)
		If cOperador == "+"
			If cCampo == "RET" //Retenção
				SC7->C7_QUJERET += nValor
			Elseif cCampo == "DED" //Dedução
				SC7->C7_QUJEDED += nValor
			Elseif cCampo == "FAT" //Faturamento Direto
				SC7->C7_QUJEFAT += nValor
			Endif			
		Elseif cOperador == "-"
			If cCampo == "RET" //Retenção
				SC7->C7_QUJERET -= nValor
			Elseif cCampo == "DED" //Dedução
				SC7->C7_QUJEDED -= nValor
			Elseif cCampo == "FAT" //Faturamento Direto
				SC7->C7_QUJEFAT -= nValor
			Endif
		Endif
		SC7->(MsUnlock())
	Endif 
Endif

RestArea(aArea)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A103GATRM()
Gatilho para atualizar valores de retenção/dedução/faturamento direto
quando o pedido esta sendo atendido parcialmente.

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/
//-------------------------------------------------------------------

Function A103GATRM(cCpo)

Local aArea	:= GetArea()
Local nRet		:= 0
Local nTotPC	:= 0
Local nTotNF	:= 0
Local cPC		:= aCols[n,GetPosSD1("D1_PEDIDO")]
Local cITPC	:= aCols[n,GetPosSD1("D1_ITEMPC")]

If !Empty(cPC)
	nTotPC := Posicione("SC7",1,xFilial("SC7") + cPC + cITPC,"C7_TOTAL")
	
	nTotNF := aCols[n,GetPosSD1("D1_QUANT")]*aCols[n,GetPosSD1("D1_VUNIT")]
	
	If cCpo == "RET"
		nVlr := Posicione("SC7",1,xFilial("SC7") + cPC + cITPC,"C7_RETENCA") - Posicione("SC7",1,xFilial("SC7") + cPC + cITPC,"C7_QUJERET")
	Elseif cCpo == "DED"
		nVlr := Posicione("SC7",1,xFilial("SC7") + cPC + cITPC,"C7_DEDUCAO") - Posicione("SC7",1,xFilial("SC7") + cPC + cITPC,"C7_QUJEDED")
	Elseif cCpo == "FAT"
		nVlr := Posicione("SC7",1,xFilial("SC7") + cPC + cITPC,"C7_FATDIRE") - Posicione("SC7",1,xFilial("SC7") + cPC + cITPC,"C7_QUJEFAT")
	Endif
	
	nRet := (nTotNF/nTotPC)*nVlr
Endif

RestArea(aArea)

Return nRet

/*/{Protheus.doc} A103EvDes()
Envio do evento de desacordo CTE

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/

Function A103EvDes()

Local cString  		:= ""
Local nOpcA    		:= 0
Local oDlgObs
Local oGetObs
Local cMsgHelp		:= ""
Local cMsgNoYes		:= ""
Local lRet			:= .T.

cMsgNoYes := STR0195 + CRLF + ; //"Você deseja enviar o desacordo do CTE: "
			STR0196 + AllTrim(SF1->F1_DOC) + CRLF + ; //"Documento: "
			STR0197 + AllTrim(SF1->F1_SERIE) + CRLF + ; //"Serie: "
			STR0198 + AllTrim(SF1->F1_FORNECE) + CRLF + ; //"Fornecedor: "
			STR0199 + AllTrim(SF1->F1_LOJA) + CRLF + ; //"Loja: "
			STR0200 + AllTrim(SF1->F1_CHVNFE) + CRLF + ; //"Chave: "
			" ?" + CRLF + CRLF + STR0201 //"Ao confirmar o envio, não será possível desfazer a ação."

If Empty(SF1->F1_IDDES) .Or. SF1->F1_IDDES $ '0/1/5'
	cString := SF1->F1_OBSDES 
	DEFINE MSDIALOG oDlgObs TITLE STR0202 FROM 15,20 TO 24,60 //"Observação - Evendo Desacordo"
	DEFINE SBUTTON FROM 52, 101.8 TYPE 1  ENABLE OF oDlgObs ACTION (nOpca := 1,oDlgObs:End())
	DEFINE SBUTTON FROM 52, 128.9 TYPE 2  ENABLE OF oDlgObs ACTION (nOpca := 2,oDlgObs:End())

	@ 0.5,0.7  GET oGetObs VAR cString OF oDlgObs MEMO size 150,40
	
	ACTIVATE MSDIALOG oDlgObs	
	
	If nOpca == 1
		
		If !Empty(cString) .And. Len(AllTrim(cString)) >= 15 .And. Len(AllTrim(cString)) <= 255
			If MsgNoYes(cMsgNoYes)
				If RecLock('SF1',.F.)
					SF1->F1_OBSDES	:= AllTrim(cString)
					SF1->F1_IDDES	:= "1" //1=Aguardando retorno SEFAZ
					SF1->F1_STATUS	:= "D" //D=Aguardando retorno SEFAZ evento desacordo
					SF1->(MsUnLock())
				Endif
				
				cIDEvento := A103EnvDes()
				If !Empty(cIDEvento) .And. ExistFunc("TMSPedMDes")
					TMSPedMDes("SF1")
				EndIf
			Endif 
		Else
			cMsgHelp := STR0203 //"Verificar o tamanho do campo Observacao. Deve ser  maior que 15 e menor que 255 posições."
			Help( " ", 1, "A103OBSDES",,cMsgHelp,1,0)
			lRet := .F.
		EndIf		
	EndIf
EndIf 

Return lRet

/*/{Protheus.doc} A103EnvDes() 
Envio do evento de desacordo CTE

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/

Static Function A103EnvDes()

Local cXml			:= ""
Local cURL			:= PadR(GetNewPar("MV_SPEDURL","http://"),250)
Local cIdEnt		:= ""
Local cRet			:= ""
Local lUsaColab	:= .F.
Local oWs

cXml :='<envEvento>'
cXml +=	'<eventos>'
cXml +=		'<detEvento>'
cXml +=			'<tpEvento>610110</tpEvento>'
cXml +=			'<chNFe>' + SF1->F1_CHVNFE + '</chNFe>'
cXml +=			'<indDesacordoOper>1</indDesacordoOper>'
cXml +=			'<xObs>' + AllTrim(SF1->F1_OBSDES) + '</xObs>
cXml +=		'</detEvento>'
cXml +=	'</eventos>'
cXml +='</envEvento>'
	
If CTIsReady(,,,lUsaColab)
	// Obtem o codigo da entidade
	cIdEnt := RetIdEnti(lUsaColab)	
	
	oWs:= WsNFeSBra():New()
	oWs:cUserToken	:= "TOTVS" 
	oWs:cID_ENT		:= cIdEnt
	oWs:cXML_LOTE		:= cXml
	oWS:_URL			:= AllTrim(cURL)+"/NFeSBRA.apw"
	
	If oWs:RemessaEvento()	
		aRetorno := {oWS:oWsRemessaEventoResult:cString}
		If !Empty(aRetorno[1][1])
			cRet := aRetorno[1][1]
		EndIf
	EndIf
EndIf

Return cRet

/*/{Protheus.doc} A103Aposen
Interface para informacao dos valores de aposentadoria especial - Projeto REINF
@author carlos.capeli
@since 28/03/2018
@version 12.1.17
@type function
/*/
Function A103Aposen(aHeadDHP,aColsDHP,lIncApos,lClaApos,aColRotAut)

Local aArea     := GetArea()
Local aColApEsp := {}
Local oDlg      := Nil
Local oGetDHP   := Nil
Local nPosItNf  := GetPosSD1("D1_ITEM" )
Local nPosItTot := GetPosSD1("D1_TOTAL" )
Local nItem     := 0
Local nOpcA     := 0
Local nX        := 0
Local nY        := 0
Local nItemDHP  := 0

Default aHeadDHP   := {}
Default aColsDHP   := {}
Default aColRotAut := {}
Default lIncApos   := .T.
Default lClaApos   := .T.

// Montagem do aHeader DHP
If Empty(aHeadDHP)
	dbSelectArea("SX3")
	dbSetOrder(1)
	MsSeek("DHP")
	While !Eof() .And. (SX3->X3_ARQUIVO == "DHP")
		If X3USO(SX3->X3_USADO) .And. cNivel >= SX3->X3_NIVEL
			aAdd(aHeadDHP,{ Trim(x3Titulo()),;
				SX3->X3_CAMPO,;
				SX3->X3_PICTURE,;
				SX3->X3_TAMANHO,;
				SX3->X3_DECIMAL,;
				SX3->X3_VALID,;
				SX3->X3_USADO,;
				SX3->X3_TIPO,;
				SX3->X3_F3,;
				SX3->X3_CONTEXT,;
				SX3->X3_PROPRI } )
		EndIf
		dbSelectArea("SX3")
		dbSkip()
	EndDo
EndIf

// Montagem do aCols DHP
If !lIncApos .And. Empty(aColsDHP)	// Entra nesta condicao somente quando for Visualizacao, Classificacao ou Exclusao
	DbSelectArea("DHP")
	DbSetOrder(1)
	If MsSeek(xFilial("DHP")+cNFiscal+cSerie+cA100For+cLoja)
		While DHP->(!Eof()) .And. xFilial("DHP") == DHP->DHP_FILIAL .And. ;
				DHP->DHP_DOC == cNFiscal .And. ;
				DHP->DHP_SERIE == cSerie .And. ;
				DHP->DHP_FORNEC == cA100For .And. ;
				DHP->DHP_LOJA == cLoja

			aAdd(aColsDHP,{DHP->DHP_ITEMNF,{Array(Len(aHeadDHP)+1)}})
			nItemDHP++
			For nX := 1 To Len(aHeadDHP)
				If aHeadDHP[nX][10] <> "V"
					aColsDHP[nItemDHP][2][Len(aColsDHP[nItemDHP][2])][nX] := DHP->(FieldGet(FieldPos(aHeadDHP[nX][2])))
				Else
					aColsDHP[nItemDHP][2][Len(aColsDHP[nItemDHP][2])][nX] := DHP->(CriaVar(aHeadDHP[nX][2]))
				EndIf
			Next nX
			aColsDHP[nItemDHP][2][Len(aColsDHP[nItemDHP][2])][Len(aHeadDHP)+1] := .F.

			DHP->(DbSkip())
		End
	EndIf
ElseIf l103Auto .And. Len(aColRotAut) > 0	// Entra nesta condicao somente quando for rotina automatica
	For nX := 1 To Len(aColRotAut)
		aAdd(aColsDHP,{aColRotAut[nX][1],{Array(Len(aHeadDHP)+1)}})
		For nY := 1 To Len(aHeadDHP)
			If ( nPosCpo := aScan(aColRotAut[nX][2][1],{|x| x[1] == aHeadDHP[nY][2]}) ) > 0
				aColsDHP[Len(aColsDHP)][2][1][nY] := aColRotAut[nX][2][1][nPosCpo][2]
			EndIf
		Next nY
		aColsDHP[Len(aColsDHP)][2][1][Len(aHeadDHP)+1] := .F.
	Next nX
EndIf

If !l103Auto

	If (nItem := aScan(aColsDHP,{|x| x[1] == aCols[N][nPosItNf]})) > 0
		aColApEsp := aClone(aColsDHP[nItem][2])
	Else
		aAdd(aColApEsp,Array(Len(aHeadDHP)+1))
		For nX := 1 To Len(aHeadDHP)
			aColApEsp[1,nX] := CriaVar(aHeadDHP[nX,2])
		Next nX
		aColApEsp[1,Len(aHeadDHP)+1] := .F.
	EndIf

	DEFINE MSDIALOG oDlg FROM 100,100 TO 280,550 TITLE "Aposentadoria Especial" Of oMainWnd PIXEL //"Aposentadoria Especial"

	oGetDHP := MsNewGetDados():New(20,3,65,225,IIF((lIncApos.Or.lClaApos),GD_INSERT+GD_UPDATE+GD_DELETE,0),,,,,,1,,,,oDlg,aHeadDHP,aColApEsp)

	@ 6 ,4 SAY AllTrim(RetTitle("F1_DOC"))+":" OF oDlg PIXEL SIZE 20,09
	@ 6 ,26 SAY cNFiscal +"-"+ Substr(cSerie,1,3) OF oDlg PIXEL SIZE 50,09
	@ 6 ,80 SAY AllTrim(RetTitle("D1_ITEM"))+":" OF oDlg PIXEL SIZE 20,09
	@ 6 ,102 SAY aCols[N][nPosItNf] OF oDlg PIXEL SIZE 20,09

	Define SButton From 73,195 Type 1 Of oDlg Enable Action ( nOpcA := 1, oDlg:End() )
	Define SButton From 73,160 Type 2 Of oDlg Enable Action oDlg:End()

	ACTIVATE MSDIALOG oDlg CENTERED

	If nOpcA == 1 .And. (lIncApos .Or. lClaApos)
		If A103ApoTok(aHeadDHP,oGetDHP:aCols,aCols[N][nPosItTot])
			If nItem > 0
				aColsDHP[nItem][2] := aClone(oGetDHP:aCols)
			Else
				aAdd(aColsDHP,{aCols[N][nPosItNf],aClone(oGetDHP:aCols)})
			EndIf
			A103AtuApos(aHeadDHP,aColsDHP)
		EndIf
	EndIf

EndIf

RestArea(aArea)

Return

/*/{Protheus.doc} A103ApoTok
Funcao de validacao TudoOk de aposentadoria especial - Projeto REINF
@author carlos.capeli
@since 28/03/2018
@version 12.1.17
@type function
/*/
Function A103ApoTok(aHeadDHP,aColsDHP,nValTot)

Local nPos15   := aScan(aHeadDHP,{|x| AllTrim(x[2]) == "DHP_FAIXA1"} )
Local nPos20   := aScan(aHeadDHP,{|x| AllTrim(x[2]) == "DHP_FAIXA2"} )
Local nPos25   := aScan(aHeadDHP,{|x| AllTrim(x[2]) == "DHP_FAIXA3"} )
Local nValor15 := 0
Local nValor20 := 0
Local nValor25 := 0
Local lRet     := .T.

If nPos15 > 0
	nValor15 := aColsDHP[1][nPos15]
EndIf
If nPos20 > 0
	nValor20 := aColsDHP[1][nPos20]
EndIf
If nPos25 > 0
	nValor25 := aColsDHP[1][nPos25]
EndIf
If ( nValor15 + nValor20 + nValor25 ) > nValTot
	Help("",1,"A103APOESP",,"A somatória dos valores de aposentadoria especial não pode ser superior ao total do item da nota.",1,0)
	lRet := .F.
EndIf

Return lRet

/*/{Protheus.doc} A103AtuApos
Funcao de atualizacao das referencias fiscais de aposentadoria especial - Projeto REINF
@author carlos.capeli
@since 28/03/2018
@version 12.1.17
@type function
/*/
Function A103AtuApos(aHeadDHP,aColsDHP)

Local nPosItNf  := GetPosSD1("D1_ITEM" )
Local nPos15    := aScan(aHeadDHP,{|x| AllTrim(x[2]) == "DHP_FAIXA1"} )
Local nPos20    := aScan(aHeadDHP,{|x| AllTrim(x[2]) == "DHP_FAIXA2"} )
Local nPos25    := aScan(aHeadDHP,{|x| AllTrim(x[2]) == "DHP_FAIXA3"} )
Local nValor15  := 0
Local nValor20  := 0
Local nValor25  := 0
Local nX        := 0
Local nItemNf   := 0
Local lRefImp15 := !Empty(MafisScan("IT_SECP15",.F.))
Local lRefImp20 := !Empty(MafisScan("IT_SECP20",.F.))
Local lRefImp25 := !Empty(MafisScan("IT_SECP25",.F.))
Local lDeletado := .F.

For nX := 1 To Len(aColsDHP)
	If ( nItemNf := aScan(aCols,{|x| x[nPosItNf] == aColsDHP[nX][1]}) ) > 0
		lDeletado := aColsDHP[nX][2][1][Len(aColsDHP[nX][2][1])]
		aColsDHP[nX][2][1][Len(aColsDHP[nX][2][1])] := .F.
		If lRefImp15 .And. nPos15 > 0
			nValor15 := Iif(lDeletado,0,aColsDHP[nX][2][1][nPos15])
			MaFisAlt("IT_SECP15",nValor15,nItemNf)
		EndIf
		If lRefImp20 .And. nPos20 > 0
			nValor20 := Iif(lDeletado,0,aColsDHP[nX][2][1][nPos20])
			MaFisAlt("IT_SECP20",nValor20,nItemNf)
		EndIf
		If lRefImp25 .And. nPos25 > 0
			nValor25 := Iif(lDeletado,0,aColsDHP[nX][2][1][nPos25])
			MaFisAlt("IT_SECP25",nValor25,nItemNf)
		EndIf
		aColsDHP[nX][2][1][Len(aColsDHP[nX][2][1])] := lDeletado
	EndIf
Next nX

Return

/*/{Protheus.doc} A103disObr
Função para desabilitar a obrigatoriedade dos campos do ativo SN3 : N3_HISTOR E N3_CCONTAB

@author Gustavo Mantovani Cândido
@since 19/04/2018
@version 12.1.17
@type function
/*/
Function A103disObr()

Local lMata240	:= If(FindFunction("CallsOfEst"),CallsOfEst(),FwIsInCallStack("MATA241") .Or. FwIsInCallStack("MATA240"))
Local lMata103	:= FwIsInCallStack("MATA103")
Local lMata116	:= FwIsInCallStack("MATA116")
Local lMata101N	:= FWIsInCallStack("MATA101N")
Local lMata102N	:= FWIsInCallStack("MATA102N") .or. (FindFunction("CallsMI").and. CallsMI() ) .or. (FWIsInCallStack("A143GERANF") .and. cPaisLoc=="ARG"  )
Local lMata119	:= FwIsInCallStack("MATA119")
Local lRet := .f.

If lMata103 .OR. lMata116 .Or. lMata240 .Or. lMata101N .Or. lMata119 .Or. lMata102N
	lRet := .T.
EndIf

Return (lRet)

/*/{Protheus.doc} A103DESARC()
Validação do evento desacordo

@param	nOpc 1-Parametros,2-Evento Desacordo,3-Monitor

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/

Function A103DESARC(nOpc)

Local lRet			:= .T.
Local lF1Desa		:= SF1->(FieldPos("F1_IDDES")) > 0 .And. SF1->(FieldPos("F1_OBSDES")) > 0
Local cMsgHelp		:= ""
Local cInscr   		:= ""
Local cContrib 		:= ""
Local cEspDes		:= "|CTE|CTEOS|"
Local dDataFec		:= MVUlmes()
Local lContrib 		:= .F.

If !lF1Desa
	cMsgHelp := STR0194 //"Campos: F1_IDDES e F1_OBSDES não encontrados no dicionario."
	Help( " ", 1, "A103CPODES",,cMsgHelp,1,0) 
	lRet := .F.
Else
	If nOpc == 2 .Or. nOpc == 3
		If !("|"+Alltrim(SF1->F1_ESPECIE)+"|" $ cEspDes)
			cMsgHelp := STR0192 //"Evento de desacordo apenas para conhecimentos de frete."
			Help( " ", 1, "A103DESACORDO",,cMsgHelp,1,0) 
			lRet := .F.
		Endif
	Endif
	
	If lRet .And. nOpc == 2
		//Valida se possui chave do documento
		If lRet .And. Empty(SF1->F1_CHVNFE)
			cMsgHelp := STR0216 //"Documento não possui chave informada."
			Help( " ", 1, "A103DESCHV",,cMsgHelp,1,0)
			lRet := .F.
		Endif

		//Validação se esta dentra do fechamento de estoque
		If lRet .And. dDataFec >= dDataBase .Or. dDataFec >= SF1->F1_DTDIGIT
			Help( " ", 1, "FECHTO" )
			lRet := .F.
		Endif
		
		//Verifica Fiscal
		If lRet .And. !FisChkExc(SF1->F1_SERIE,SF1->F1_DOC,SF1->F1_FORNECE,SF1->F1_LOJA,,"E")
			lRet := .F.
		Endif
		
		// Verifica se existe bloqueio contabil
		If lRet
			lRet := CtbValiDt(Nil ,SF1->F1_DTDIGIT,.T. ,Nil ,Nil ,{"COM001"}) // Retorno .F. -> Help CTBBLOQ - Calendario Contabil Bloqueado. Verifique o processo.
		EndIf
		
		If lRet
			//-- Verifica se fornecedor e contribuinte do ICMS
			cInscr   := Posicione("SA2", 1, xFilial("SA2") + SF1->F1_FORNECE + SF1->F1_LOJA,"A2_INSCR")
			cContrib := Posicione("SA2", 1, xFilial("SA2") + SF1->F1_FORNECE + SF1->F1_LOJA,"A2_CONTRIB")
			
			If	Alltrim(cContrib) == "2" .Or. Empty(cInscr) .Or. Alltrim(Upper(cInscr)) $ "ISENT" .Or. Alltrim(Upper(cInscr)) $ "RG"
				lContrib := .F.
			Else
				lContrib := .T.
			EndIf
			
			If !lContrib
				cMsgHelp := STR0193 //"Fornecedor não é contribuinte. Evento de Desacordo não permitido."
				Help( " ", 1, "A103FORNDES",,cMsgHelp,1,0) 
				lRet := .F.
			EndIf
		Endif
	Endif

	If lRet .And. nOpc == 3
		If Empty(SF1->F1_IDDES)
			cMsgHelp := STR0204 //"É preciso realizar o envio do evento primeiro."
			Help( " ", 1, "A103EVNDES",,cMsgHelp,1,0) 
			lRet := .F.
		Endif
	Endif
	
	If lRet
		If nOpc == 1 //Parametros
			SpedEpecPar()
		Elseif nOpc == 2 //Evento Desacordo
			A103EvDes()
		Elseif nOpc == 3 .And. ExistFunc("TMSPedMDes") //Monitor
			TMSPedMDes()
		Endif
	Endif
Endif

Return lRet

/*/{Protheus.doc} A103NfElet
Funcao para executar ponto de entrada para carregar informacoes nas abas Nota Fiscal Eletronica, Danfe e Inf. Adicionais
@author carlos.capeli
@since 25/06/2018
@version 12.1.17
@type function
/*/
Function A103NfElet(cCampoVld,cUf,aNFEletr,aNfeDanfe,aInfAdic)

Local lM103NfEl := Existblock("M103NFEL")
Local aRetPE    := {}

Default cCampoVld := ""
Default cUf       := ""
Default aNFEletr  := {}
Default aNfeDanfe    := {}
Default aInfAdic  := {}

If lM103NfEl
	aRetPE := ExecBlock("M103NFEL",.F.,.F.,{cCampoVld,cUf,aNFEletr,aNfeDanfe,aInfAdic})
	If ValType(aRetPE) == "A"
		If Len(aRetPE) > 0 .And. ValType(aRetPE[1]) == "A"
			aNFEletr := aClone(aRetPE[1])
		EndIf
		If Len(aRetPE) > 1 .And. ValType(aRetPE[2]) == "A"
			aNfeDanfe := aClone(aRetPE[2])
		EndIf
		If Len(aRetPE) > 2 .And. ValType(aRetPE[3]) == "A"
			aInfAdic := aClone(aRetPE[3])
		EndIf
	EndIf
EndIf

Return .T.
/*/{Protheus.doc} A103XDesfaz()
Validacao da rotina de Desfazimento para processo de Compra com Entrega Futura
@param	Nenhum
@author Carlos Capeli
@since 28/08/18
@version 12
/*/
Function A103XDesfaz()

Local lDHQInDic := AliasInDic("DHQ") .And. SF4->(ColumnPos("F4_EFUTUR") > 0)
Local lMt103Com := FindFunction("A103Desfaz")
Local lRet      := .T.

If lDHQInDic .And. lMt103Com
	A103Desfaz()
ElseIf !lDHQInDic
	Help( " ", 1, "A103DHQ",,STR0205,1,0)
	lRet := .F.
ElseIf !lMt103Com
	Help( " ", 1, "A103COMFUT",,STR0206,1,0) 
	lRet := .F.
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A103VldObr()
Validação dos campos caso sejam configurados como obrigatórios. gerando Help para aviso de campos vazios

@param    aNFEletr - Array - Nota Fiscal Eletrônica
@return   lRet - Lógica - Caso exista algum campo obrigatório em branco retornarão Falso

@author Gustavo Mantovani Cândido
@since 04/10/18
@version 11
/*/
//-------------------------------------------------------------------
Function A103VldObr(aNFEletr,lMT140)
Local lRet				:= .T.
Local lCteOriDest		:= SF1->(FieldPos("F1_UFORITR")) > 0 .And. SF1->(FieldPos("F1_MUORITR")) > 0 .And. SF1->(FieldPos("F1_UFDESTR")) > 0 .And. SF1->(FieldPos("F1_MUDESTR")) > 0
Local lObrigat			:= "|"+Alltrim(cEspecie)+"|" $ "|CTE|CTEOS|"
Local cCpoVazio			:= ""
Local aCpoNota 			:= {}
Local aCpoDanfe 		:= {}
Local aCpoInfAdi 		:= {}

Default lMT140 := .F. 

If !lMT140
	aCpoNota	:= {		{"F1_NFELETR",1},;
							{"F1_CODNFE",2},;				
							{"F1_EMINFE",3},;
							{"F1_HORNFE",4},;
							{"F1_CREDNFE",5},;
							{"F1_NUMRPS",6},;
							{"F1_MENNOTA",7},;
							{"F1_MENPAD",8}}

	aCpoDanfe 	:= {		{"F1_TRANSP",1},;
							{"F1_PLIQUI",2},;
							{"F1_PBRUTO",3},;
							{"F1_ESPECI1",4},;
							{"F1_VOLUME1",5},;
							{"F1_ESPECI2",6},;
							{"F1_VOLUME2",7},;
							{"F1_ESPECI3",8},;
							{"F1_VOLUME3",9},;
							{"F1_ESPECI4",10},;
							{"F1_VOLUME4",11},;
							{"F1_PLACA",12},;
							{"F1_CHVNFE",13},;
							{"F1_TPFRETE",14},;
							{"F1_VALPEDG",15},;
							{"F1_FORRET",16},;
							{"F1_LOJARET",17},;
							{"F1_TPCTE",18},;
							{"F1_FORENT",19},;
							{"F1_LOJAENT",20},;
							{"F1_NUMAIDF",21},;
							{"F1_ANOAIDF",22},;
							{"F1_MODAL",23},;
							{"F1_DEVMERC",24}}

	aCpoInfAdi	:= {		{"F1_INCISS",1},;
							{"F1_VEICUL1",2},;
							{"F1_VEICUL2",3},;
							{"F1_VEICUL3",4},;
							{"F1_DTCPISS",5},;
							{"F1_SIMPNAC",6},;
							{"F1_CLIDEST",7},;
							{"F1_LOJDEST",8},;
							{"F1_ESTDES",9}}
Endif							

If lCteOriDest .And. lObrigat
	Aadd(ACpoInfAdi, {"F1_UFORITR",10})
	Aadd(ACpoInfAdi, {"F1_MUORITR",11})
	Aadd(ACpoInfAdi, {"F1_UFDESTR",12})
	Aadd(ACpoInfAdi, {"F1_MUDESTR",13})
ENdIf

If cPaisLoc == "BRA" .And. Type("lIntermed") == "L" .And. lIntermed
	Aadd(ACpoInfAdi, {"F1_INDPRES",16})
	Aadd(ACpoInfAdi, {"F1_CODA1U" ,17})
Endif

//Validando campos obrigatÃ³rios da Nota Fiscal EletrÃ´nica
If !lMT140 .And. ValType(aNFEletr) == "A" .And. !empty(aNFEletr)
       cCpoVazio += A103CpoFor(aCpoNota, aNFEletr)
EndIf

//validando os campos obrigatÃ³rios da aba Danfe
If !lMT140 .And. type("aNFEDanfe") == "A" .And. !empty(aNFEDanfe)
       cCpoVazio += A103CpoFor(aCpoDanfe, aNFEDanfe) 
EndIf

//validando os campos obrigatÃ³rios InformaÃ§Ãµes Adicionais
If type("aInfAdic") == "A" .And. !empty(aInfAdic)
    cCpoVazio += A103CpoFor(aCpoInfAdi, aInfAdic) 
EndIf        

If !empty(cCpoVazio)
	cCpoVazio := substr(cCpoVazio,1, (len(cCpoVazio) - 2))
	Help(1," ","OBRIGAT",,cCpoVazio,2,1)
	lRet := .F.
EndIf

Return lRet
 
//-------------------------------------------------------------------
/*/{Protheus.doc} A103CpoFor()
Laço de validação para campos da função A103VldObr

@param    aCpoHeader - Array - Nome dos Campos da aba
@param    aCpoCont - Array - Conteúdo dos Campos da aba
@return   cCpoVazio - String - Retorna nome dos campos obrigatÃ³rios que estÃ£o vazios

@author Gustavo Mantovani Cândido
@since 04/10/18
@version 11
/*/
//-------------------------------------------------------------------
Static Function A103CpoFor(aCpoHeader,aCpoCont)
Local cCpoVazio := ""
Local cTipoCPO  := ""
Local ni 		:= 0
 
For ni := 1 to len(aCpoHeader)
       If SF1->(FieldPos(aCpoHeader[ni,1])) > 0
              if x3obrigat(aCpoHeader[ni,1])
                     cTipoCPO := tamSX3(aCpoHeader[ni,1])[3]                     
                     if ((cTipoCPO  == "C" .or. cTipoCPO  == "D") .And. empty(aCPOCont[aCpoHeader[ni,2]])) .Or. ;
                           (cTipoCPO == "N" .And. aCpoCont[aCpoHeader[ni,2]] <= 0)
                                  cCpoVazio += aCpoHeader[nI,1] + ", "
                     EndIf
              EndIf
       EndIf        
next ni
Return cCpoVazio

/*-------------------------------------------------------------------
{Protheus.doc} a103AtuTaxa()
@author Leandro Nishihata
@since 13/03/19
@version 12
-------------------------------------------------------------------*/
Static Function a103AtuTaxa(nMoedAux)
Local lRet := .T.

If nMoedAux <> nMoedaCor
	Eval(bRefresh)
Endif
	nMoedAux := NMOEDACOR
return lRet

/*/{Protheus.doc} LoadX3Arr
	Retorna um array contendo as opcoes de um campo combobox
	fornecido em <cField>, alem disso adiciona uma opcao vazia
	no comeco do vetor.
@author philipe.pompeu
@since 21/06/2019
@return aResult, opcoes do X3 de <cField>
@param cField, caracter, campo que deve ter seu X3 retornado
@param bAlter, block, bloco de cod. p/ alterar o retorno
/*/
Static Function LoadX3Arr(cField, bAlter)
	Local aResult := {}
	Local nI := 0
	Default bAlter := Nil
	
	aResult := X3CboxToArray(cField)[1]
	
	If(bAlter != Nil)
		For nI:= 1 to Len(aResult)
			aResult[nI] := Eval(bAlter, aResult[nI])
		Next nI
	EndIf
		
	aAdd(aResult,Nil)
	AIns(aResult,1)
	aResult[1] := " "
Return aResult

/*/{Protheus.doc} A103RATAFN
Monta array de rateio de projeto ao alterar pre nota ou
classificar um documento de entrada

@author rodrigo.mpontes
@since 21/06/2019
/*/

Function A103RATAFN(cNF,cSer,cFor,cLoj,aRatAFN,aHdrAFN)

Local aArea		:= GetArea()
Local aItens	:= {}
Local nI		:= 0
Local nPosRat	:= 0
Local cQry		:= ""
Local cAliasD1	:= GetNextAlias()
Local cItemAnt	:= "0001"

DbSelectArea("AFN")
AFN->(DbSetOrder(2))

aHdrAFN := GetaHeader("AFN")

cQry	:= " SELECT D1_DOC, D1_SERIE, D1_FORNECE, SD1.D1_LOJA, D1_ITEM, "
cQry	+= "AFN_PROJET, AFN_REVISA, AFN_TAREFA, AFN.R_E_C_N_O_ "
cQry	+= " FROM " + RetSqlName("SD1") + " SD1" 
cQry	+= " INNER JOIN " + RetSqlName("AFN") + " AFN"
cQry	+= " ON AFN.AFN_FILIAL = SD1.D1_FILIAL"
cQry	+= " AND AFN.AFN_DOC = SD1.D1_DOC"
cQry	+= " AND AFN.AFN_SERIE = SD1.D1_SERIE"
cQry	+= " AND AFN.AFN_FORNEC = SD1.D1_FORNECE"
cQry	+= " AND AFN.AFN_LOJA = SD1.D1_LOJA"
cQry	+= " AND AFN.AFN_ITEM = SD1.D1_ITEM"
cQry	+= " WHERE AFN.AFN_FILIAL = '" +xFilial("AFN")+ "' "
cQry	+= " AND AFN.AFN_DOC = '" +cNF+ "' "
cQry	+= " AND AFN.AFN_SERIE = '" +cSer+ "' "
cQry	+= " AND AFN.AFN_FORNEC = '" +cFor+ "' "
cQry	+= " AND AFN.AFN_LOJA = '" +cLoj+ "' "
cQry	+= " AND AFN.D_E_L_E_T_ = ' '  "
cQry	+= " AND SD1.D_E_L_E_T_ = ' ' "
cQry	:= ChangeQuery(cQry)

dbUseArea( .T., "TOPCONN", TcGenQry( , , cQry ), cAliasD1, .T., .T. )

While (cAliasD1)->(!Eof())
	AFN->(DbGoTo((cAliasD1)->R_E_C_N_O_))
	If (cAliasD1)->AFN_REVISA == PmsAF8Ver((cAliasD1)->AFN_PROJET)
		If cItemAnt <> (cAliasD1)->D1_ITEM
			aSize(aItens,0)
		EndIf
		aADD(aItens,Array(Len(aHdrAFN)+1))
		For nI := 1 to Len(aHdrAFN)
			If ( aHdrAFN[nI,10] != "V")
				aItens[Len(aItens),nI] := AFN->(FieldGet(AFN->(ColumnPos(aHdrAFN[nI,2]))))
			ElseIf AllTrim(aHdrAFN[nI,2]) $ "AFN_ALI_WT | AFN_REC_WT"
				If AllTrim(aHdrAFN[nI,2]) == "AFN_ALI_WT"
					aItens[Len(aItens),nI] := "AFN"
				ElseIf AllTrim(aHdrAFN[nI,2]) == "AFN_REC_WT"
					aItens[Len(aItens),nI] := AFN->(Recno())
				EndIf
			Else
				aItens[Len(aItens),nI] := CriaVar(aHdrAFN[nI,2])
			EndIf
		Next nI
		aItens[Len(aItens),Len(aHdrAFN)+1] := .F.
	EndIf
	
	nPosRat    := aScan(aRatAFN,{|x| x[1] == (cAliasD1)->D1_ITEM})
	If nPosRat > 0
		aRatAFN[nPosRat,2]    := aClone(aItens)
	Else
		aADD(aRatAFN,{(cAliasD1)->D1_ITEM,aClone(aItens)})
	EndIf
	cItemAnt := (cAliasD1)->D1_ITEM	
	(cAliasD1)->(DbSkip())
EndDo				

aSize(aItens,0)
(cAliasD1)->(DbCloseArea())
RestArea(aArea)

Return

/*/{Protheus.doc} A103VlStr
Funcao que valida a existencia de caracteres especiais em uma string.
@type  Function
@author leonardo.magalhaes
@since 30/07/2019
@version 1.00
@return lRet, Boolean, Retorna true (.T.) Quando não existir caracter especial e false (.F.) quando existir
@example (examples)
@see (links_or_references)
/*/
Function A103VlStr(cString, nOpcx)
	
	Local lRet       	:= .T.
	Local nCont			:= 0
	Local cConteudo		:= "" 
	Local cCaracter		:= "'|" + '"'

	Default cString		:= ""
	Default nOpcx		:= 1

	cConteudo := Alltrim(Iif(nOpcx == 1, &(ReadVar()), cString))

	If !(ValType(cConteudo) == "C")
		lRet := .F.
	Else
		For nCont := 1 to Len(cConteudo)
			If SubStr(cConteudo, nCont, 1) $ cCaracter
				lRet := .F.
				Exit
			EndIf
		Next nCont
	EndIf 

	If !lRet 
		Help(,, "A103VLSTR",, STR0212, 1, 0) //Para este campo, não é permitido a utilização de caracteres especiais!
	EndIf

Return lRet

/*/{Protheus.doc} A103PRERAT
Validação do pre rateio para que o campo ITEM fique
na primeira posição, pois a função é generica da 
controladoria.

@author rodrigo.mpontes
@since 21/06/2019
/*/

Static Function A103PRERAT(aHead)

Local lRet	:= .T.
Local nPos	:= 0

nPos := aScan(aHead,{|x| AllTrim(x[2]) == "DE_ITEM"})
If nPos > 0 .And. nPos <> 1
	Help(" ",1,"A103PRERAT",,STR0213,1,1) //"O campo ITEM deve ficar na primeira posição."
	lRet := .F.
Endif

Return lRet

/*/{Protheus.doc} A103CLASFIS
Importar o clasfis caso documento é originado via
totvs colaboração / importador xml

@author rodrigo.mpontes
@since 21/06/2019
/*/

Function A103CLASFIS(cDoc,cSer,cForn,cLoja,cItem,cD1ClasFis)

Local aArea		:= GetArea()
Local aRet		:= {}
Local lColab	:= .F.
Local cClasFis	:= ""
Local nClasFis	:= SuperGetMV("MV_COLCLAS",.F.,0)

If nClasFis < 2 
	DbSelectArea("SDT")
	SDT->(DbSetOrder(8)) //DT_FILIAL, DT_FORNEC, DT_LOJA, DT_DOC, DT_SERIE, DT_ITEM

	If SDT->(FieldPos("DT_CLASFIS")) > 0 .And. SDT->(DbSeek(xFilial("SDT") + cForn + cLoja + cDoc + cSer)) .And. !Empty(SDT->DT_CLASFIS)
		lColab := .T.
		If SDT->(DbSeek(xFilial("SDT") + cForn + cLoja + cDoc + cSer + cItem))
			cClasFis := Iif(nClasFis==0,SDT->DT_CLASFIS,SubStr(SDT->DT_CLASFIS,1,1) + SubStr(cD1ClasFis,2,Len(cD1ClasFis)))
		Endif 
	Endif
Endif

aRet := {lColab,cClasFis}

RestArea(aArea)

Return aRet


/*/{Protheus.doc} A103TrfIPI
Valida se e necessario alterar a Base do IPI conforme
implementacao do parametro MV_PBIPITR. 

@author Materiais
@since 11/09/2019
/*/
Function A103TrfIPI(cTES, n)

Local nPosItem  := GetPosSD1("D1_ITEM")
Local nPosTES   := GetPosSD1("D1_TES")
Local nPosCod   := GetPosSD1("D1_COD")
Local nPosQtd   := GetPosSD1("D1_QUANT")
Local nPbIPITr  := SuperGetMv("MV_PBIPITR",.F.,0)
Local cFilOri   := ""
Local cNumPV    := ""
Local cItmPV    := ""
Local aAreaSF4  := {}
Local aAreaSC6  := {}
Local aItmSD2   := {}
Default cTES    := aCols[n,nPosTES]



If !Empty(MaFisScan("IT_PRCCF",.F.)) .And. nPbIPITr > 0
	aAreaSF4 := SF4->(GetArea())
	aAreaSC6 := SC6->(GetArea())
	SF4->(dbSetOrder(1))
	If SF4->(MsSeek(xFilial("SF4")+cTES)) .And. SF4->F4_TRANFIL == "1"
 		If A103TrFil(cTES,cTipo,ca100For,cLoja,cNFiscal,cSerie,aCols[n,nPosCod],aCols[n,nPosQtd],@aItmSD2,GdFieldGet('D1_LOTECTL',n),GdFieldGet('D1_NUMLOTE',n),.F.,aCols[n,nPosItem])
 			If Len(aItmSD2) > 0
	 			cFilOri := aItmSD2[aScan(aItmSD2,{|x| AllTrim(x[1])=="D2_FILIAL"})][2]
	 			cNumPV  := aItmSD2[aScan(aItmSD2,{|x| AllTrim(x[1])=="D2_PEDIDO"})][2]
	 			cItmPV  := aItmSD2[aScan(aItmSD2,{|x| AllTrim(x[1])=="D2_ITEMPV"})][2]
	 			dbSelectArea("SC6") 
	 			SC6->(dbSetOrder(1))
	 			If SC6->(FieldPos("C6_IPITRF")) > 0 .And. SC6->(MsSeek(cFilOri+cNumPV+cItmPV)) 
					MaFisAlt("IT_PRCCF",SC6->C6_IPITRF,n)
				EndIf
			EndIf
		EndIf
	EndIf
	RestArea(aAreaSF4)
	RestArea(aAreaSC6)
EndIf

Return .T.

/*/{Protheus.doc} A103ExstNF
Valida se a nota fiscal e/ou titulo NF e/ou NCC já existe
@author Kevin Alexander
@since 30/10/2019
/*/
Static Function A103ExstNF()

Local aArea      	:= GetArea()
Local aAreaSF1   	:= SF1->(GetArea())
Local aSerAltern	:= {}

Local lRetorno 		:= .T.
Local lUsaNewKey 	:= TamSX3("F1_SERIE")[1] == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso
Local lNaoExiste 	:= .T.

Local cSerAltern	:= ""
Local cTamSerie 	:= SerieNfId("SF1",6,"F1_SERIE") 
Local cMsg		  	:= ""
Local cQuery   		:= ""
Local cSerieId   	:= IIf( lUsaNewKey , SerieNfId("SD1",4,"D1_SERIE",dDEmissao,cEspecie,cSerie) , cSerie )
Local cEASYFIN		:= SuperGetMv("MV_EASYFIN")
Local c2DUPREF		:= SuperGetMv("MV_2DUPREF")

Local nI 			:= 0
	
If INCLUI
	FreeUsedCode()
	dbSelectArea("SF1")
	SF1->(dbSetOrder(1))
	If SF1->(MsSeek(xFilial("SF1")+cNFiscal+cSerieId+cA100For+cLoja,.F.))
		If ExistBlock("M103ALTS") .And. !lUsaNewKey
			aSerAltern := ExecBlock("M103ALTS",.F.,.F.,{cNFiscal,cSerie,cA100For,cLoja})
			If Valtype(aSerAltern) == 'A' .And. Len(aSerAltern) > 0 
				For nI:=1 To Len(aSerAltern) 
					If Len(Alltrim(cSerie)) = cTamSerie // Serie atual com o mesmo tamanho do campo
						If aSerAltern[nI,2] = 1 // Prefixo (a frente da serie) Ex. '.1'
							cSerAltern := Substr(aSerAltern[nI,1],1,1)+Substr(cSerie,2,cTamSerie-1)
						Else // Sufixo (apos a serie) Ex. '1.'
							cSerAltern := Substr(cSerie,1,cTamSerie-1)+Substr(aSerAltern[nI,1],1,1)
						Endif
					Else // Serie atual com tamanho menor que o tamanho do campo
						If aSerAltern[nI,2] = 1 // Prefixo (a frente da serie) Ex. '.1'
							cSerAltern := Substr(aSerAltern[nI,1],1,1)+Alltrim(cSerie)
						Else // Sufixo (apos a serie) Ex. '1.'
							cSerAltern := Alltrim(cSerie)+Substr(aSerAltern[nI,1],1,1)
						Endif					
					Endif 
					If SF1->(MsSeek(xFilial("SF1")+cNFiscal+Padr(cSerAltern,cTamSerie)+cA100For+cLoja,.F.))
						If !l103Auto
							cMsg := 'Os documentos de entrada: '+_CRLF+cNFiscal+' '+cSerie+_CRLF+cNFiscal+' '+cSerAltern+_CRLF+'Já existem cadastrados'
							MsgAlert(cMsg)
						Endif
						If Len(aSerAltern) > nI // Ainda possui alternativas
							Loop
						Endif
						lRetorno := .F.
						Exit
					Else // Quando não existir ainda, sugerir a alteração da série
						cMsg := 'Deseja alterar a série para continuar ?'+_CRLF+"Novo valor: "+cSerAltern
						If l103Auto .Or. MsgYesNo(cMsg)
							cSerie := cSerAltern
							Exit
						Else
							lRetorno := .F.
							Exit
						Endif
					Endif
				Next nI
			Else
				lRetorno := .F.
			Endif
		Else
			lRetorno := .F.
		Endif
		
		If !lRetorno
			Help(" ",1,"EXISTNF")
			lNaoExiste := .F.
		EndIf	
	Else
		If !FreeForUse("NFE",xFilial("SF1")+cNFiscal+cSerieId+cA100For+cLoja)
			lRetorno := .F.
		EndIf
	EndIf
	
	If cTipo == "D" 
		If lRetorno .And. cEASYFIN == "N" .And. "SF1->F1_SERIE" $ c2DUPREF .And. !lUsaNewKey
			cQuery := "SELECT COUNT(E1_FILIAL) TITULOS "
			cQuery += "  FROM "+RetSqlName("SE1")+" SE1 "
			cQuery += " WHERE SE1.E1_FILIAL  ='"+xFilial("SE1")+"'"
			cQuery += "   AND SE1.E1_PREFIXO ='"+cSerie+"'"
			cQuery += "   AND SE1.E1_NUM	 ='"+cNFiscal+"'"
			cQuery += "   AND SE1.E1_TIPO    ='"+MV_CRNEG+"'"
			cQuery += "   AND SE1.E1_CLIENTE ='"+cA100For+"'"
			cQuery += "   AND SE1.E1_LOJA	 ='"+cLoja+"'"
			cQuery += "   AND SE1.D_E_L_E_T_ =' ' "
	
			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"NFEFORNECE")
	
			If NFEFORNECE->TITULOS > 0 
				Help(" ",1,"FANUMNCC",,"NCC a ser gerada ja existe.",4,1)
				lRetorno := .F.
			EndIf
			NFEFORNECE->(dbCloseArea())
			dbSelectArea("SE1") 
		EndIf                      
	Else	
		If lNaoExiste .And. lRetorno .And. cEASYFIN == "N" .And. "SF1->F1_SERIE" $ c2DUPREF .And. !lUsaNewKey
			cQuery := "SELECT COUNT(E2_FILIAL) TITULOS "
			cQuery += "  FROM "+RetSqlName("SE2")+" SE2 "
			cQuery += " WHERE SE2.E2_FILIAL  ='"+xFilial("SE2")+"'"
			cQuery += "   AND SE2.E2_PREFIXO ='"+cSerie+"'"   
			cQuery += "   AND SE2.E2_NUM	 ='"+cNFiscal+"'"
			cQuery += "   AND SE2.E2_TIPO	 ='"+MVNOTAFIS+"'"
			cQuery += "   AND SE2.E2_FORNECE ='"+cA100For+"'"
			cQuery += "   AND SE2.E2_LOJA	 ='"+cLoja+"'"
			cQuery += "   AND SE2.D_E_L_E_T_ =' ' "
	
			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"NFEFORNECE")
	
			If NFEFORNECE->TITULOS > 0
				Help(" ",1,"FA050NUM")
				lRetorno := .F.
			EndIf
			
			NFEFORNECE->(dbCloseArea())
			dbSelectArea("SE2")
		EndIf
	EndIf
EndIf

RestArea(aAreaSF1)
RestArea(aArea)

Return lRetorno

/*/{Protheus.doc} A103BXADT
Verifica se possui alguma baixa no titulo que ja foi utilizado uma PA

@param cPref	Prefixo
@param cNum		Numero
@param cParc	Parcela
@param cTip		Tipo
@param cForn	Fornecedor/Cliente
@param cLoj		Loja
@param cFilOrig	Filial Origem

@author rodrigo.mpontes
@since 30/10/2019
/*/

Static Function A103BXADT(cPref,cNum,cParc,cTip,cForn,cLoj,cFilOrig)

Local aArea			:= GetArea()
Local aBaixa		:= {}
Local nTotAdto		:= 0
Local nTotImpost	:= 0
Local lBaixaAbat 	:= .F.
Local lBxCec 		:= .F.
Local lNotBax 		:= .F.
Local lAglImp 		:= .F.
Local lRet			:= .F.

Private ABAIXASE5	:= {}
Private aRecBorra	:= {}

aBaixa := Sel080Baixa("BA /VL /",cPref,cNum,cParc,cTip,@nTotAdto,@lBaixaAbat,cForn,cLoj,@lBxCec,.F.,@lNotBax,@nTotImpost,@lAglImp,.T.,,,,,cFilOrig)

If Len(aBaixa) > 0 //Tem baixas alem da compensação do PA
	lRet := .T.
Endif

RestArea(aArea)
Return lRet

/*/{Protheus.doc} A103SELPC
Verifica na seleção do PC/AE na classificação se ja possui o vinculo, 
caso ja tenha, o vinculo deve ser via Pedido (Item).

@param aTitCampos	Cabeçalho
@param aF4For		Array com os PC/AE
@param nSel			Posição selecionada
@param lIntPms		Integração com o PMS

@author rodrigo.mpontes
@since 25/09/2020
/*/

Function A103SELPC(aTitCampos,aF4For,nSel,lIntPms)

Local aArea		:= GetArea()
Local aPCAE		:= {}
Local nPos		:= aScan(aTitCampos,{|x| AllTrim(Upper(x)) == "PEDIDO"})
Local nFind		:= 0 
Local lAlerta	:= .F.
Local cFilSD1	:= xFilial("SD1")

If Type('l103Class') <> "L" 
	l103Class := .F.  
Endif

If l103Class
	If nPos > 0//Encontrou o campo PEDIDO
		DbSelectArea("SD1") //Busca PC/AE ja vinculados ao abrir a tela de classificação
		SD1->(DbSetOrder(1))
		If SD1->(DbSeek(cFilSD1 + cNFiscal + cSerie + cA100For + cLoja ))
			While SD1->(!EOF()) .And. SD1->D1_FILIAL == cFilSD1 .And. ;
					SD1->D1_DOC == cNFiscal .And. SD1->D1_SERIE == cSerie .And. ;
					SD1->D1_FORNECE == cA100For .And. SD1->D1_LOJA == cLoja 

				If !Empty(SD1->D1_PEDIDO) 
					aAdd(aPCAE,{SD1->D1_PEDIDO,SD1->D1_ITEM})
				Endif
				SD1->(DbSkip())
			Enddo
		Endif

		If Len(aPCAE) > 0 //Verifica se o PC/AE selecionado, ja estava vinculado
			nFind := aScan(aPCAE,{|x| AllTrim(x[1]) == AllTrim(aF4For[nSel,3])})
			If nFind > 0
				lAlerta := .T.
			Endif
		Endif

		If lAlerta //Apresenta alerta, para que o mesmo PC/AE seja vinculado via Pedido (Item) 
			Aviso(STR0018,STR0217 + aPCAE[nFind,2] + STR0218) //"Esse PC/AE ja está vinculado no item: " ## " do documento, utilize o vinculo via Pedido(Item) "                                                                                                                                                                                                                                                                                                                                                                                                                                                                
		Else
			aF4For[nSel,1] := !aF4For[nSel,1]

			If lIntPms .And. FindFunction("PmsInt")
				PmsInt(aF4For[nSel,3])
			Endif
		Endif
	Endif
Else
	aF4For[nSel,1] := !aF4For[nSel,1]

	If lIntPms .And. FindFunction("PmsInt")
		PmsInt(aF4For[nSel,3])
	Endif
Endif

RestArea(aArea)

Return

/*/{Protheus.doc} A103RECC7
Função para realizar a busca do recno pedido de compra
pelo indice 25 ou através de query.  

@param cFilent		Filial de entrega
@param cPedido		Numero do pedido
@param cCodFor		Código do Fornecedor
@param cLjFor		Loja do Fornecedor
@param cNumIt		Numero do item

@author fabiano.dantas
@since 17/12/2020
@version P12
@return Nil
/*/

Function A103RECC7(cFilent,cPedido,cCodFor,cLjFor,cProd,cNumIt)

Local nRecSC7   := 0
Local aArea		:= GetArea()
Local cAliasAux := GetNextAlias()
Local cIndexC7  := SC7->(IndexKey(6))
Local lMt140	:= FwIsInCallStack("MATA140")
Local lMt103	:= FwIsInCallStack("MATA103")
Local lProcCOL	:= FwIsInCallStack("ProcDocs")
Local lForPCNF	:= SuperGetMV("MV_FORPCNF",.F., .F.)
Local lFindNew	:= .T.
Local lFornCOL	:= .F.

cFilent	:= PadR(cFilent,TamSx3("C7_FILENT")[1])
cPedido	:= PadR(cPedido,TamSx3("C7_NUM")[1])
cCodFor	:= PadR(cCodFor,TamSx3("C7_FORNECE")[1])
cLjFor	:= PadR(cLjFor,TamSx3("C7_LOJA")[1])
cProd	:= PadR(cProd,TamSx3("C7_PRODUTO")[1])
cNumIt	:= PadR(cNumIt,TamSx3("C7_ITEM")[1])

DbSelectArea("SC7")

If lProcCOL .Or. AllTrim(SF1->F1_ORIGEM) == "COMXCOL" 
	Pergunte("MTA140I",.F.)
	If MV_PAR12 == 2 
		lFornCOL := .T.
	Endif
Endif

If lMt140
	Pergunte("MTA140",.F.)
	If MV_PAR02 == 2 .Or. lForPCNF .Or. lProcCOL .Or. lFornCOL //Fornecedor
		lFindNew := .F.
		SC7->(DbSetOrder(19))
	Endif
Endif

If lMt103
	Pergunte("MTA103",.F.) 
	If MV_PAR07 == 2 .Or. lForPCNF .Or. lProcCOL .Or. lFornCOL  //Fornecedor 
		lFindNew := .F.
		SC7->(DbSetOrder(19))
	Endif
Endif

If lFindNew
	If "C7_ITEM" $ cIndexC7 //C7_FILENT+C7_PRODUTO+C7_FORNECE+C7_LOJA+C7_NUM+C7_ITEM+C7_ITEMGRD
		SC7->(DbSetOrder(6))
		If SC7->(DbSeek((cFilent+cProd+cCodFor+cLjFor+cPedido+cNumIt)))
			nRecSC7 := SC7->(RecNo())
		Endif
		If nRecSC7 == 0
			SC7->(DbSetOrder(19))
			If SC7->(DbSeek(cFilent+cProd+cPedido+cNumIt))
				nRecSC7 := SC7->(Recno())				
			Endif
		Endif
	Else

		BeginSQL Alias cAliasAux
			SELECT 	SC7.R_E_C_N_O_ AS SC7RECNO
			FROM 	%Table:SC7% SC7
			WHERE 	C7_FILENT 	 	 = %Exp:cFilent%
					AND C7_NUM  	 = %Exp:cPedido%
					AND C7_FORNECE 	 = %Exp:cCodFor%
					AND C7_LOJA 	 = %Exp:cLjFor%
					AND C7_PRODUTO   = %Exp:cProd%
					AND C7_ITEM 	 = %Exp:cNumIt%
					AND SC7.%NotDel%
		EndSQL
		If !(cAliasAux)->(Eof())
			nRecSC7 := (cAliasAux)->SC7RECNO
		ENDIF
		If nRecSC7 == 0
			SC7->(DbSetOrder(19))
			If SC7->(DbSeek(cFilent+cProd+cPedido+cNumIt))
				nRecSC7 := SC7->(Recno())				
			Endif			
		EndIf
		(cAliasAux)->(DbCloseArea())
	Endif
Else
	If lMt140 .Or. lMT103
		If SC7->(DbSeek(cFilent+cProd+cPedido+cNumIt))
			nRecSC7 := SC7->(Recno())
		Endif
	Endif
Endif 

RestArea(aArea)

Return nRecSC7 

/*/
{Protheus.doc} A103CPOINTER
Valida existencia dos campos para processo de intermediador
NT2020-006

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Function A103CPOINTER()

Local lRet := .F.

If 	SF1->(FieldPos("F1_INDPRES")) > 0 .And. SF1->(FieldPos("F1_CODA1U")) > 0
	lRet := .T.
Endif

Return lRet

/*/
{Protheus.doc} A103VldPres
Valida indicador de presença
NT2020-006

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Function A103VldPres()

Local lRet			:= .T.

Return lRet

/*/
{Protheus.doc} A103ChgPres
Valida mudança em tempo de execução do indicador de presença
NT2020-006

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Function A103ChgPres() 

Local lRet			:= .T.
Local nI			:= 0
Local nPNFOri		:= GetPosSD1("D1_NFORI")
Local nPNFSerOri	:= GetPosSD1("D1_SERIORI")
Local nPNFItOri		:= GetPosSD1("D1_ITEMORI")
Local nPProd		:= GetPosSD1("D1_COD")
Local cIndPres		:= ""
Local cPedC5		:= ""
Local nLinAtv		:= 0
Local lDtNT2006		:= A103DNT2006()

If lDtNT2006
	For nI := 1 To Len(aCols)
		If !aCols[nI,Len(aCols[nI])]
			If (cTipo == "N" .And. !Empty(aCols[nI,nPNFOri]))
				nLinAtv++
			Endif
		Endif
	Next nI
Endif

If cFormul == "S" .And. lDtNT2006
	If cTipo == "N" 
		If (nPNFOri > 0 .And. nPNFSerOri > 0 .And. nPNFItOri > 0)
			For nI := 1 To Len(aCols)
				If !aCols[nI,Len(aCols[nI])]
					If !Empty(aCols[nI,nPNFOri])
						cPedC5 := GetAdvFVal("SD2","D2_PEDIDO",xFilial("SD2") + aCols[nI,nPNFOri] + aCols[nI,nPNFSerOri] + ca100For + cLoja + aCols[nI,nPProd] + aCols[nI,nPNFItOri],3)
						If !Empty(cPedC5)
							cIndPres := GetAdvFVal("SC5","C5_INDPRES",xFilial("SC5") + ca100For + cLoja + cPedC5,3)
							If nLinAtv == 0 
								aInfAdic[16] := cIndPres
								nLinAtv++
							Elseif nLinAtv >= 1
								If SubStr(aInfAdic[16],1,1) <> cIndPres
									Help(" ",1,"A103INDPRES",,STR0221 + RetTitle("F1_INDPRES"),1,0) //"Não é possivel alterar "
									aInfAdic[16] := cIndPres
									lRet := .F.
								Endif
							Endif
						Endif
					Endif
				Endif
				If !lRet
					Exit
				Endif
			Next nI
		Endif
	Endif
	
Endif 

Eval(bRefresh,10)

Return lRet

/*/
{Protheus.doc} A103VldA1U
Valida codigo do intermediador
NT2020-006

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Function A103VldA1U()

Local lRet			:= .T.
Local nI			:= 0
Local nPNFOri		:= GetPosSD1("D1_NFORI")
Local nPNFSerOri	:= GetPosSD1("D1_SERIORI")
Local nPNFItOri		:= GetPosSD1("D1_ITEMORI")
Local nPProd		:= GetPosSD1("D1_COD")
Local cCodA1U		:= ""
Local cPedC5		:= ""
Local lDtNT2006		:= A103DNT2006()

If cFormul == "S" .And. lDtNT2006
	If lRet .And. !Empty(aInfAdic[17]) 
		lRet := ExistCpo("A1U",aInfAdic[17],1)
	Endif

	If lRet .And. cTipo == "N"
		If (nPNFOri > 0 .And. nPNFSerOri > 0 .And. nPNFItOri > 0)
			For nI := 1 To Len(aCols)
				If !aCols[nI,Len(aCols[nI])]
					If !Empty(aCols[nI,nPNFOri])
						cPedC5 := GetAdvFVal("SD2","D2_PEDIDO",xFilial("SD2") + aCols[nI,nPNFOri] + aCols[nI,nPNFSerOri] + ca100For + cLoja + aCols[nI,nPProd] + aCols[nI,nPNFItOri],3)
						If !Empty(cPedC5)
							cCodA1U := GetAdvFVal("SC5","C5_CODA1U",xFilial("SC5") + ca100For + cLoja + cPedC5,3)
							If aInfAdic[17] <> cCodA1U
								Help(" ",1,"A103CODA1U",,STR0221 + RetTitle("F1_CODA1U"),1,0) //"Não é possivel alterar "
								aInfAdic[17] := cCodA1U
								lRet := .F.
							Endif
						Endif
					Endif
				Endif
			Next nI
		Endif
	Endif 
Endif

Eval(bRefresh,10) 

Return lRet 

/*/
{Protheus.doc} A103INTERMED
Validação nos campos D1_NFORI/D1_SERIORI/D1_ITEMORI para indicador de presenca
e codigo do intermediador
NT2020-006

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Function A103INTERMED() 

Local lRet 			:= .T.

Return lRet

/*/
{Protheus.doc} A103INTWHEN
Validação nos campos D1_NFORI/D1_SERIORI/D1_ITEMORI para indicador de presenca
e codigo do intermediador
NT2020-006

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Function A103INTWHEN() 

Local lRet 			:= .T.

Return lRet

/*/
{Protheus.doc} A103DNT2006
Validação de data para validação de indicador de presença e intermediador.
NT2020-006

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Function A103DNT2006()

Local lRet 			:= .F.
Local dDTNT2006		:= SuperGetMv("MV_NT2006I",.F.,"05/04/2021")
Local dDtNT 

If ValType(dDTNT2006) == "C"
	dDtNT := CtoD(dDTNT2006)
Elseif ValType(dDTNT2006) == "D"
	dDtNT := dDTNT2006
Endif

If dDataBase >= dDtNT
	lRet := .T.
Endif

Return lRet

/*/
{Protheus.doc} A103EICTRANS
Verifica se documento é originado do EIC ou Transferencia entre filias

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Function A103EICTRANS(aCabAuto) 

Local lRet		:= .F.
Local lEic		:= .F.
Local lTransFil	:= FwIsInCallStack("MATA310") .Or. FwIsInCallStack("MATA311")
Local lDtNT2006	:= A103DNT2006()
Local nPHAWB	:= 0

Default aCabAuto	:= {}

If Len(aCabAuto) > 0
	nPHAWB := aScan(aCabAuto,{|x|Trim(x[1])== "F1_HAWB" })
	If nPHAWB > 0
		If !Empty(aCabAuto[nPHAWB,2])
			lEic := .T.
		Endif
	Endif
Endif

If lDtNT2006 .And. (lEic .Or. lTransFil)
	lRet := .T.
Endif

Return lRet

/*/{Protheus.doc} GetPosSD1
Efetuar o retorno da posição do aHeader do SD1

@Param cCampo		nome do campo

@author Nilton Rodrigues
@since 22/03/2022
@return Nil, indefinido
/*/
Function GetPosSD1(cCampo as character)
	Local nX           as numeric 
	Local nTotaHeader  as numeric 
	Local nPos         as numeric 
	Static _HeaderSD1
	//- verifica se é um SD1 
	If Substr(aHeader[1,2],1,3) == 'D1_'
		nTotaHeader:= Len(aHeader)
		//- Valida o cache se ele existe e se é válido
		If !_HeaderSD1 == nil .and. nTotaHeader <> Len(_HeaderSD1:Getnames())
			_HeaderSD1:fromJson("{}")
			FREEOBJ( _HeaderSD1 )
			_HeaderSD1 := nil 
		EndIF 

		//- Verifica a existencia do cache
		If _HeaderSD1 == nil 
			_HeaderSD1 := JsonObject():New()
			//- efetua a carga do cache pela posição do aHeader
			For nX := 1 to nTotaHeader
				_HeaderSD1[AllTrim(aHeader[nX,2])] := nX
			Next nX 
		EndIf 

		//- checa a existência do campo, sendo nulo ou 0 força mesmo assim 
		//- a pesquisa do registro pelo aScan
		If (nPos := _HeaderSD1[AllTrim(cCampo)]) == nil .or. nPos == 0
			nPos := aScan(aHeader,{|x| AllTrim(x[2]) == cCampo} )
			//- retiro o nulo 
			_HeaderSD1:DelName(AllTrim(cCampo))
		EndIf 
	Else 
		nPos := aScan(aHeader,{|x| AllTrim(x[2]) == cCampo} )
	EndIf 
Return nPos
/*/{Protheus.doc} SetProxNum
Efetua a carga do ProxNum para o aCols de entrada


@author Nilton Rodrigues
@since 22/03/2022
@return Nil, indefinido
/*/
Static Function SetProxNum
	Local nX          as Numeric
	Local nTotaCols   as numeric 
	Local nTotaHeader as numeric 
	Static _oProxNum 
	nTotaCols   := Len(aCols)
	nTotaHeader := Len(aHeader)

	If _oProxNum == NIL
		_oProxNum := JsonObject():New()
	Else 
		//- Reseta o Json
		_oProxNum:fromJson("{}")
	EndIf 

	For nX := 1 to Len(aCols)
		//Atualiza a regua de processamento
		If !aCols[nx][nTotaHeader+1]
			_oProxNum[cValToChar(nX)] := ProxNum()
		else
			_oProxNum[cValToChar(nX)] := Space(Len(SD1->D1_NUMSEQ))
		EndIf 
	Next nX

Return
