#INCLUDE 'APWEBEX.CH'
#INCLUDE "APWEBSRV.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "AP5MAIL.CH" 
#Include "topconn.ch"

#DEFINE DIRRAIZ 	PLSMUDSIS( GetNewPar("MV_TISSDIR","\TISS\") )
#DEFINE DIRONLINE 	PLSMUDSIS( "ONLINE\" )
#DEFINE DIRSUBRAI 	DIRRAIZ+DIRONLINE
#DEFINE DIRCAISA  	PLSMUDSIS( DIRSUBRAI+"CAIXASAIDA\" )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³PLSXFUN   ³ Autor ³Alexander Santos       ³ Data ³28.03.2006  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Web Service das funcionalidades do Plano de Saude            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas da composicao da solicitacao.			       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMatCompGui
		WSDATA RdaCode	 	AS String  OPTIONAL //Codigo da Rda
		WSDATA NomeUsu	 	AS String  OPTIONAL //Nome do usuario
		WSDATA DtGui	 	AS String  OPTIONAL //Data da Guia
		WSDATA CodTab	 	AS String  OPTIONAL //Tabela
		WSDATA CodPro	 	AS String  OPTIONAL //Codigo do Procedimento
		WSDATA DesPro	 	AS String  OPTIONAL //Descricao do Procedimento
		WSDATA QtdSol		AS String  OPTIONAL //Quantidade Solicitada
		WSDATA QtdRea		AS String  OPTIONAL //Quantidade Realizada
		WSDATA QtdSal		AS String  OPTIONAL //Quantidade Saldo
		WSDATA StaAud		AS String  OPTIONAL //Status do Auditoria
		WSDATA StaPro		AS String  OPTIONAL //Status do procedimento
		WSDATA StaGui		AS String  OPTIONAL //Status da Guia
		WSDATA Cancel		AS String  OPTIONAL //Cancelada
		WSDATA OnLine		AS String  OPTIONAL //Guia Online
		WSDATA MatCri		AS Array Of GenericStruct OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas do BD6										   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMatBD6
    	WSDATA seqinf	 	AS String  OPTIONAL //Sequencia informada
		WSDATA sequen	 	AS String  OPTIONAL //Sequencia gravada
		WSDATA codpad	 	AS String  OPTIONAL //CodPad
		WSDATA codpro	 	AS String  OPTIONAL //CodPro
		WSDATA qtdpro	 	AS Integer OPTIONAL //QtdPro
		WSDATA orimov	 	AS String  OPTIONAL //OriMov
		WSDATA procci	 	AS String  OPTIONAL //ProcCi
		WSDATA recno	 	AS Integer OPTIONAL //Recno
		WSDATA denreg		AS String  OPTIONAL //Denreg
		WSDATA fadent		AS String  OPTIONAL //FadEnt
		WSDATA datpro		AS Date    OPTIONAL //DatPro
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas do pre-atendimento							   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMatPre
    	WSDATA Matric	 	AS String  OPTIONAL //Matricula
		WSDATA CodUsr	 	AS String  OPTIONAL //Codigo de usuario web
		WSDATA NomeUsu	 	AS String  OPTIONAL //Nome do usuario
		WSDATA OpeRda	 	AS String  OPTIONAL //Operadora da rda
		WSDATA CodRda	 	AS String  OPTIONAL //Codigo da rda
		WSDATA NomRda	 	AS String  OPTIONAL //Nome da rda
		WSDATA CodLoc	 	AS String  OPTIONAL //LOCAL de atendimento
		WSDATA Trilha	 	AS String  OPTIONAL //Trilha Cartao
		WSDATA TpAca		AS String  OPTIONAL //Tipo de acao inclusao/alteracao/exclusao
		WSDATA TissVer		AS String  OPTIONAL //versao tiss
		WSDATA CodRdaOld 	AS String  OPTIONAL //Codigo da rda antes da alteração
		WSDATA CodLocOld	AS String  OPTIONAL //LOCAL de atendimento antes da alteração
		WSDATA OrdResult	AS String  OPTIONAL //Ordenação do resultado Pre-Atendimento (Desc/Asc)
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas do co-participacao							   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMatVlr
   WSDATA ExibeCo	 		AS String  OPTIONAL //Se exibe a co-participacao
   WSDATA ExibeBa	 		AS String  OPTIONAL //Se exibe a Base da co-participacao
   WSDATA GuiAco	 		AS String  OPTIONAL //Guia Comprada
   WSDATA PagRDA			AS String  OPTIONAL //Pagamento da Rda
   WSDATA VlrPF	 			AS Float   OPTIONAL //Valor PF
   WSDATA VlrBPF			AS Float   OPTIONAL //Valor Base PF
   WSDATA PercPF	 		AS Float   OPTIONAL //Valor Percentual PF
   WSDATA VlrTPF	 		AS Float   OPTIONAL //Valor Total PF
   WSDATA VlrTAD	 		AS Float   OPTIONAL //Valor Taxa
   WSDATA Msg001	 		AS String  OPTIONAL //"Valor da Co-Participacao&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
   WSDATA Msg002	 		AS String  OPTIONAL //"Valor a ser pago direto a rede de atendimento&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;")
   WSDATA Msg003	 		AS String  OPTIONAL //"Valor da Co-Participacao&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;")
   WSDATA Msg004	 		AS String  OPTIONAL //"Valor da Compra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;")
   WSDATA Msg005	 		AS String  OPTIONAL //"Valor da Taxa Administracao&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;")
   WSDATA Msg006	 		AS String  OPTIONAL //"Valor Total da Co-Participacao&nbsp;R$:&nbsp;")
   WSDATA Msg007	 		AS String  OPTIONAL //"Valor total a ser pago direto a rede de atendimento&nbsp;R$:&nbsp;")
   WSDATA Msg008	 		AS String  OPTIONAL //"Valor Total da Co-Participacao&nbsp;R$:&nbsp;")
   WSDATA Msg009	 		AS String  OPTIONAL //"Valor Total da Compra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;")
   WSDATA Msg010	 		AS String  OPTIONAL //"(*) Nao inclui valores de materiais e medicamentos.&nbsp;")
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas do pre-atendimento							   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SRetMatPre
		WSDATA Matric	 	AS String OPTIONAL 	//Nome do Usuario
		WSDATA NomeUsu	 	AS String OPTIONAL 	//Nome do Usuario
		WSDATA Rda		 	AS String OPTIONAL 	//Nome do Usuario
		WSDATA NomeRda	 	AS String OPTIONAL 	//Nome da Rda
		WSDATA CodLoc	 	AS String  OPTIONAL //LOCAL de atendimento
		WSDATA DatChe	 	AS Date OPTIONAL 	//Data de chegada
		WSDATA HorChe	 	AS String OPTIONAL 	//Hora de Chegada
		WSDATA Msg		 	AS String OPTIONAL 	//Mensagem
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas para profissiona de saude			   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT RtProfSaud
	WSDATA ListProfSaud				AS Array Of ProfSaud OPTIONAL
	WSDATA ListPfSExe				AS Array Of ProfSaud OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas para profissiona de saude			   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT ProfSaud
	WSDATA Code	 			AS String OPTIONAL //Codigo do Profissional de Saude
	WSDATA Name				AS String OPTIONAL //Nome do profissional de Saude
	WSDATA CodSig			AS String OPTIONAL //Sigla CRM
	WSDATA NumCr			AS String OPTIONAL //Numero CRM
	WSDATA Estado			AS String OPTIONAL //Estado CRM
	WSDATA CpfCnpj			AS String OPTIONAL //Cpf ou Cnpj
	WSDATA CodOpe			AS String OPTIONAL //Operadora
	WSDATA Especi			AS Array Of GenericStruct OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura de entrada de dados do web service							   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMITE
	WSDATA CodOpe			AS String OPTIONAL
	WSDATA AnoAut			AS String OPTIONAL
	WSDATA MesAut			AS String OPTIONAL
	WSDATA AliMov			AS String OPTIONAL
	WSDATA NumAut			AS String OPTIONAL
	WSDATA SeqProc		AS String OPTIONAL
	WSDATA TpPublico		AS String OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura de entrada de dados do web service							   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMProDad
	WSDATA CodPad			AS String OPTIONAL
	WSDATA CodPro			AS String OPTIONAL
	WSDATA VlrPro			AS String OPTIONAL
	WSDATA CodRda			AS String OPTIONAL
	WSDATA Data	  			AS Date   OPTIONAL
	WSDATA CodLoc			AS String OPTIONAL
	WSDATA TpPrest			AS String OPTIONAL
	WSDATA TpServ			AS String OPTIONAL
	WSDATA TpProc			AS String OPTIONAL
	WSDATA qtdpro	 		AS Integer OPTIONAL //QtdPro
	WSDATA TissVer	 		AS String OPTIONAL //QtdPro
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura de matriz MSDadRda											   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT MSDadRda
	WSDATA Code				AS String OPTIONAL 			//Codigo da RDA
	WSDATA Name				AS String OPTIONAL 			//Nome da RDA
	WSDATA CnpfCpf			AS String OPTIONAL 			//Cnpj ou Cpf
	WSDATA Cnes				AS String OPTIONAL 			//Codigo CNES
	WSDATA CodProf			AS String OPTIONAL 			//Codigo do Profissional
	WSDATA CodOpe			AS String OPTIONAL 			//Operadora
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura de matriz de combos											   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT MSCombo
	WSDATA CodPad					AS String OPTIONAL
	WSDATA CbTpDoe		        	AS Array Of GenericStruct OPTIONAL
	WSDATA CbTmpDoe		        	AS Array Of GenericStruct OPTIONAL
	WSDATA CbIndAcid	        	AS Array Of GenericStruct OPTIONAL
	WSDATA CbTpCon		        	AS Array Of GenericStruct OPTIONAL
	WSDATA CbTpSai		        	AS Array Of GenericStruct OPTIONAL
	WSDATA CbCarSolict		        AS Array Of GenericStruct OPTIONAL
	WSDATA CbTpAtend		        AS Array Of GenericStruct OPTIONAL
	WSDATA CbTpAtOD			        AS Array Of GenericStruct OPTIONAL
	WSDATA CbViaAce		        	AS Array Of GenericStruct OPTIONAL
	WSDATA CbTecUti		        	AS Array Of GenericStruct OPTIONAL
	WSDATA CbGraPart		        AS Array Of GenericStruct OPTIONAL
	WSDATA CbTpPreAte				AS Array Of GenericStruct OPTIONAL
	WSDATA CbTpInter				AS Array Of GenericStruct OPTIONAL
	WSDATA CbRegInter				AS Array Of GenericStruct OPTIONAL
	WSDATA CbTipGui					AS Array Of GenericStruct OPTIONAL
	WSDATA CbTipFat					AS Array Of GenericStruct OPTIONAL

	WSDATA CbCategoria				AS Array Of GenericStruct OPTIONAL
	WSDATA CbSexo					AS Array Of GenericStruct OPTIONAL
	WSDATA CbEstCiv					AS Array Of GenericStruct OPTIONAL
	WSDATA CbEstado					AS Array Of GenericStruct OPTIONAL
	WSDATA CbCidade					AS Array Of GenericStruct OPTIONAL
	WSDATA CbTipLog					AS Array Of GenericStruct OPTIONAL
	WSDATA CbStatus					AS Array Of GenericStruct OPTIONAL
	WSDATA CbSituac					AS Array Of GenericStruct OPTIONAL
	WSDATA CbOperac					AS Array Of GenericStruct OPTIONAL
	WSDATA CbTipo					AS Array Of GenericStruct OPTIONAL
	WSDATA CbSitCad					AS Array Of GenericStruct OPTIONAL
	WSDATA CbGeneric				AS Array Of GenericStruct OPTIONAL
	WSDATA CbMotCar					AS Array Of GenericStruct OPTIONAL
	WSDATA CbMotBlo					AS Array Of GenericStruct OPTIONAL
	WSDATA CbGrauPa					AS Array Of GenericStruct OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura de matriz de combos											   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT MSDadESP
	WSDATA CodPad					AS String OPTIONAL
	WSDATA DadRdaTp					AS Array Of MSDadRda OPTIONAL
	WSDATA CbGraPar					AS Array Of GenericStruct OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura para retorno da autorizacao de um procedimento				   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMatRetAutProc
	WSDATA ProAut					AS Boolean 	OPTIONAL				//Autorizado sim ou nao
	WSDATA Nivel					AS String 	OPTIONAL				//Nivel da autorizacao ou da negativa
	WSDATA TpProc					AS String 	OPTIONAL				//Tipo de Procedimento, resgatado da tabela BR8
	WSDATA Chave					AS String 	OPTIONAL				//Chave
	WSDATA Autori					AS String 	OPTIONAL				//Autori com base no BR8
	WSDATA PosBD6					AS Integer 	OPTIONAL				//Posicao da matriz aMatBD6
	WSDATA SeqInf					AS String 	OPTIONAL				//Sequencia informada
	WSDATA MatRetRes				AS String 	OPTIONAL				//String com o retorno campo a campo conforme matriz solicitada. deve ser separada por # para campos e ";" para campo valor
	WSDATA MatCri					AS Array Of GenericStruct OPTIONAL 	//Criticas da autorizacao
	WSDATA Lembrete				    AS String OPTIONAL				//Lembrete da BR8
	WSDATA Alerta					AS Array Of GenericStruct OPTIONAL 	//Alertas do procedimento
	WSDATA NumGui					AS String   OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura da matriz de retorno de Interação
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SViewInteracao
	WSDATA SeqInt					AS String OPTIONAL
	WSDATA SeqMop					AS String OPTIONAL
	WSDATA DesMop					AS String OPTIONAL
	WSDATA RespPrest				AS String OPTIONAL
	WSDATA Setor  				AS String OPTIONAL
	WSDATA DtIteracao  			AS Date OPTIONAL
	WSDATA ResPre  				AS Boolean OPTIONAL
	WSDATA Observacao 			AS String OPTIONAL
	WSDATA AliasPai 			   AS String OPTIONAL
	WSDATA Anexado 			    AS Boolean OPTIONAL
	WSDATA TipDirec 			AS String OPTIONAL 
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura da matriz de retorno do Log de Acesso					   	   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SViewHistLog
	WSDATA DataAc					AS String OPTIONAL
	WSDATA HoraAc					AS String OPTIONAL
	WSDATA EstacaoAc				AS String OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura da matriz de parametros do Log de Acesso					   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SViewPar
	WSDATA CodLog					AS String OPTIONAL
	WSDATA DateDe					AS String OPTIONAL
	WSDATA DateAte					AS String OPTIONAL
	WSDATA HorDe					AS String OPTIONAL
	WSDATA HorAte					AS String OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura da matriz de Criticas										   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT UserCardCri
	WSDATA DesPri					AS String OPTIONAL
	WSDATA DesSeq					AS String OPTIONAL
	WSDATA DesTer					AS String OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura de matriz do cabecalho da guia								   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT MCabGui
	WSDATA Rda			AS String OPTIONAL
	WSDATA CodLoc		AS String OPTIONAL
	WSDATA RegAns		AS String OPTIONAL
	WSDATA NomeRda		AS String OPTIONAL
	WSDATA CnpjCpfSol 	AS String OPTIONAL
	WSDATA CnesSol      AS String OPTIONAL
	WSDATA TpLograd		AS String OPTIONAL
	WSDATA Endereco		AS String OPTIONAL
	WSDATA Numero		AS String OPTIONAL
	WSDATA Complemento	AS String OPTIONAL
	WSDATA Municipio	AS String OPTIONAL
	WSDATA Bairro		AS String OPTIONAL
	WSDATA Estado		AS String OPTIONAL
	WSDATA IBGE			AS String OPTIONAL
	WSDATA Cep			AS String OPTIONAL
	WSDATA Tel   		AS String OPTIONAL
	WSDATA DtAut		AS Date   OPTIONAL
	WSDATA HrAut		AS String OPTIONAL
	WSDATA TipAut		AS String OPTIONAL
	WSDATA Senha		AS String OPTIONAL
	WSDATA DtValid		AS Date   OPTIONAL
	WSDATA DtSolicit	AS Date   OPTIONAL
	WSDATA HrSolicit	AS String OPTIONAL
	WSDATA CarSolicit	AS String OPTIONAL
	WSDATA Cid			AS String OPTIONAL
	WSDATA Cid2			AS String OPTIONAL
	WSDATA Cid3			AS String OPTIONAL
	WSDATA Cid4			AS String OPTIONAL
	WSDATA ProSol		AS String OPTIONAL
	WSDATA OpeSol		AS String OPTIONAL
	WSDATA NomeSol		AS String OPTIONAL
	WSDATA CodSigSol	AS String OPTIONAL
	WSDATA NumCrSol		AS String OPTIONAL
	WSDATA EstSigSol	AS String OPTIONAL
	WSDATA CbosSol		AS String OPTIONAL
	WSDATA DescCbosSol	AS String OPTIONAL
	WSDATA ProExe		AS String OPTIONAL
	WSDATA OpeExe		AS String OPTIONAL
	WSDATA NomeExe		AS String OPTIONAL
	WSDATA CodSigExe	AS String OPTIONAL
	WSDATA NumCrExe		AS String OPTIONAL
	WSDATA EstSigExe	AS String OPTIONAL
	WSDATA obs		    AS String OPTIONAL
	WSDATA Matric	    AS String OPTIONAL
	WSDATA NomeUsr	    AS String OPTIONAL
	WSDATA STAut	    AS String OPTIONAL
	WSDATA DesSTAut	    AS String OPTIONAL
	WSDATA IndCli	    AS String OPTIONAL
	WSDATA NumImp	    AS String OPTIONAL
	WSDATA Origem	    AS String OPTIONAL
	WSDATA ChvBD6	    AS String OPTIONAL
	WSDATA TipAto	    AS String OPTIONAL
	WSDATA TipFat	    AS String OPTIONAL
	WSDATA TpIntern	    AS String OPTIONAL
	WSDATA RegInter	    AS String OPTIONAL
	WSDATA QtdDSol	    AS String OPTIONAL
	WSDATA TipDoe	    AS String OPTIONAL
	WSDATA TmpDoe	    AS String OPTIONAL
	WSDATA UndDoe	    AS String OPTIONAL
	WSDATA IndAcid	    AS String OPTIONAL
	WSDATA DPrAH  		AS Date   OPTIONAL
	WSDATA QtdDAut		AS String OPTIONAL
	WSDATA QtdDPro		AS String OPTIONAL
	WSDATA TpAcom		AS String OPTIONAL
	WSDATA DesAcom		AS String OPTIONAL
	WSDATA PadCon		AS String OPTIONAL
	WSDATA CnpjSolT		AS String OPTIONAL
	WSDATA NomeSolT		AS String OPTIONAL
	WSDATA CnesSolT		AS String OPTIONAL
	WSDATA RdaSolT		AS String OPTIONAL
	WSDATA ProfSolT		AS String OPTIONAL
	WSDATA OpeSolT		AS String OPTIONAL
	WSDATA DatInt  		AS Date   OPTIONAL
	WSDATA DatAlt  		AS Date   OPTIONAL
	WSDATA HorAlt  		AS String OPTIONAL
	WSDATA Cancel  		AS String OPTIONAL
	WSDATA FindEvo 		AS String OPTIONAL
	WSDATA NomPla 		AS String OPTIONAL
	WSDATA DtVldCar     AS Date   OPTIONAL
	WSDATA CarSaud      AS String OPTIONAL
	WSDATA GrPar      	AS String OPTIONAL
	WSDATA Peso      	AS String OPTIONAL
	WSDATA Altura      	AS String OPTIONAL
	WSDATA Idade      	AS String OPTIONAL
	WSDATA Sexo      		AS String OPTIONAL
	WSDATA AteRN			AS String 	OPTIONAL	//Se e recen nascido
	WSDATA IniFat      AS Date   OPTIONAL
	WSDATA FimFat      AS Date   OPTIONAL
	WSDATA PrvOpm      AS String   OPTIONAL
	WSDATA PrvQui      AS String   OPTIONAL
	WSDATA   DtRlz                    AS String OPTIONAL
	WSDATA   DtRlz2                   AS String OPTIONAL
	WSDATA   DtRlz3                   AS String OPTIONAL
	WSDATA   DtRlz4                   AS String OPTIONAL
	WSDATA   DtRlz5                   AS String OPTIONAL
	WSDATA   DtRlz6                   AS String OPTIONAL
	WSDATA   DtRlz7                   AS String OPTIONAL
	WSDATA   DtRlz8                   AS String OPTIONAL
	WSDATA   DtRlz9                   AS String OPTIONAL
	WSDATA   DtRlz1                   AS String OPTIONAL
	WSDATA TipAte			AS String OPTIONAL
	WSDATA TipCon			AS String OPTIONAL
	WSDATA IndAci			AS String OPTIONAL
	WSDATA TipSai			AS String OPTIONAL
	WSDATA EXECCO			AS String OPTIONAL
	WSDATA RGEXCO			AS String OPTIONAL
	WSDATA CCPECO			AS String OPTIONAL
	WSDATA CEPCCO			AS String OPTIONAL
	WSDATA PREXCC			AS STRING OPTIONAL
	WSDATA Gralau			AS String OPTIONAL
	WSDATA Protoc  		AS String OPTIONAL
	WSDATA NumAux			as String OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura de matriz do itens da guia									   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT MIteGui
	WSDATA TpServ				AS String  OPTIONAL
	WSDATA Sequencia			AS String  OPTIONAL
	WSDATA CodPad				AS String  OPTIONAL
	WSDATA CodPad_Ori			AS String  OPTIONAL
	WSDATA CodPro				AS String  OPTIONAL
	WSDATA CodPro_Ori			AS String  OPTIONAL
	WSDATA TpModAdd				AS String  OPTIONAL
	WSDATA DesPro				AS String  OPTIONAL
	WSDATA QtdSol				AS String  OPTIONAL
	WSDATA QtdAut				AS String  OPTIONAL
	WSDATA Fabric				AS String  OPTIONAL
	WSDATA VlrApr				AS Float   OPTIONAL
	WSDATA Exibe				AS String  OPTIONAL
	WSDATA Dente				AS String   OPTIONAL
	WSDATA Face					AS String   OPTIONAL
	WSDATA QtdUs				AS Float   OPTIONAL
	WSDATA VlrCon				AS Float   OPTIONAL
	WSDATA VlrTPF				AS Float   OPTIONAL
	WSDATA Autori				AS String   OPTIONAL
	WSDATA DtExe				AS Date   	OPTIONAL
	WSDATA Senha				AS String   OPTIONAL
	WSDATA ResAut				AS String   OPTIONAL
	WSDATA GrPar				AS String   OPTIONAL
	WSDATA HorIni				AS String   OPTIONAL
	WSDATA HorFim				AS String   OPTIONAL
	WSDATA ViaAc				AS String   OPTIONAL
	WSDATA TecUt				AS String   OPTIONAL
	WSDATA RedAcre				AS Float   OPTIONAL
	WSDATA VlrTAp				AS Float   OPTIONAL
	WSDATA StProc				AS String   OPTIONAL
	WSDATA Diagno				AS String   OPTIONAL
	WSDATA Pacote				AS String   OPTIONAL
	WSDATA TpProc				AS String  OPTIONAL
	WSDATA SPctIteGui	       AS Array Of MPctIteGui OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Pacotes do item da guia
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT MPctIteGui
	WSDATA CodPad				AS String  OPTIONAL
	WSDATA CodPro				AS String  OPTIONAL
	WSDATA DesPro				AS String  OPTIONAL
ENDWSSTRUCT


WSSTRUCT MExeGui

	WSDATA Sequen  			AS String OPTIONAL
	WSDATA GrPar				AS String OPTIONAL
	WSDATA	CpfExe 			AS String OPTIONAL
	WSDATA	NomExe 			AS String OPTIONAL
	WSDATA	ConReg 			AS String OPTIONAL
	WSDATA	NumCr 				AS String OPTIONAL
	WSDATA	UfCr 				AS String OPTIONAL
	WSDATA	Cbo	 				AS String OPTIONAL

ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura  Principal												   	   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMatAutGui
	WSDATA SCabGui			    AS MCabGui OPTIONAL
	WSDATA SIteGui			    AS Array Of MIteGui OPTIONAL
	WSDATA SCriGui			    AS Array Of AutErrorView OPTIONAL
	WSDATA MatCri				AS Array Of GenericStruct OPTIONAL
	WSDATA SExeGui					AS Array Of MExeGui OPTIONAL
	WSDATA SetDtInt				AS String OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura  Principal												   	   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMatAut
	WSDATA NumeAut			    AS String 	OPTIONAL
	WSDATA NumeInt			    AS String 	OPTIONAL
	WSDATA TipoTran			    AS String 	OPTIONAL
	WSDATA DtAut			    AS Date 	OPTIONAL
	WSDATA HrAut			    AS String 	OPTIONAL
	WSDATA Tp				    AS String 	OPTIONAL
	WSDATA TpStatus				AS String 	OPTIONAL
	WSDATA Prorrog			AS String 	OPTIONAL
	WSDATA Status			    AS String 	OPTIONAL
	WSDATA Senha			    AS String 	OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura  Principal												   	   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT UserCardView
	WSDATA CardNumber			AS String 	OPTIONAL				//Numero do cartao. (caso seja usuario de intercambio vai cadastrar na hora)
	WSDATA CardNumberOld		AS String 	OPTIONAL                //Matricula Antiga
	WSDATA CardName				AS String 	OPTIONAL				//Nome na Carteirinha
	WSDATA Interchange			AS Boolean 	OPTIONAL				//Intercambio
	WSDATA OpeOri				AS String 	OPTIONAL   				//Operadora Origem
	WSDATA Plano				AS String 	OPTIONAL				//Plano do Usuario
	WSDATA ValCar				AS Date 	OPTIONAL				//Validade da Carteirinha
	WSDATA NumCarNac			AS String 	OPTIONAL				//Numero nacional de saude
	WSDATA ViaCartao			AS Integer 	OPTIONAL				//Via do Cartao
	WSDATA LOCALCob				AS String 	OPTIONAL				//LOCAL de Cobranca
	WSDATA Abrange				AS String 	OPTIONAL				//Abrangencia
	WSDATA NatJuri				AS String 	OPTIONAL				//Naturesa juridica
	WSDATA Telefone				AS String 	OPTIONAL				//Telefone
	WSDATA NomTit				AS String 	OPTIONAL				//Nome Titular
	WSDATA NomEmp				AS String 	OPTIONAL				//Nome Empresa
	WSDATA Vida					AS String 	OPTIONAL				//Vida do usuario
	WSDATA Dig1					AS String 	OPTIONAL				//String Biometrica 1
	WSDATA Dig2					AS String 	OPTIONAL				//String Biometrica 2
	WSDATA TpAcom				AS String 	OPTIONAL				//Tipo de Acomodacao
	WSDATA DesAcom				AS String 	OPTIONAL				//Descricao da Acomodacao
	WSDATA PadCon				AS String 	OPTIONAL				//Padrao de Conforto
	WSDATA ChkBioInter			AS Boolean 	OPTIONAL				//Checa Sim ou Nao Biometria para intercambio
	WSDATA UserCritica			AS Array Of UserCardCri OPTIONAL	//Matriz de criticas do usuario
	WSDATA DatBlo               AS Date     OPTIONAL                //Data de Bloqueio do usuário
	WSDATA CritPreAtdm			AS Boolean  OPTIONAL					 //permite continuar pre-atendimento mesmo com criticas
	WSDATA StatusEl             AS String   OPTIONAL                //Status Elegibilidade
	WSDATA MsnBloInter 		AS String	OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Strutura para autorizacao de um procedimento							   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SMatAutProc
	WSDATA Rda					AS String 	OPTIONAL	//Codigo da RDA
	WSDATA NomRda				AS String 	OPTIONAL	//Nome da Rda
	WSDATA OpeRda				AS String 	OPTIONAL	//Operadora da RDA
	WSDATA CodLoc				AS String 	OPTIONAL	//LOCAL de Atendimento
	WSDATA Matric				AS String 	OPTIONAL	//Matricula do Usuario
	WSDATA CdpfSo				AS String 	OPTIONAL	//Codigo do profissional Solicitante
	WSDATA TipGui				AS String 	OPTIONAL	//Tipo de guia
	WSDATA PadInt				AS String 	OPTIONAL	//Tipo Acomodacao
	WSDATA PadCon				AS String 	OPTIONAL	//Padrao de Conforto
	WSDATA DatPro				AS Date 	OPTIONAL	//Data da autorizacao
	WSDATA HorPro				AS String 	OPTIONAL	//Hora da autorizacao
	WSDATA SeqMov				AS String 	OPTIONAL	//Sequencia
	WSDATA CodPad				AS String 	OPTIONAL	//Codigo da Tabela
	WSDATA CodPro				AS String 	OPTIONAL	//Codigo do Procedimento
	WSDATA QtdPro				AS Integer 	OPTIONAL	//Qtd de procedimento
	WSDATA Cid					AS String 	OPTIONAL	//Cid
	WSDATA RegAte				AS String 	OPTIONAL	//Regime de atendimento
	WSDATA RegInter				AS String 	OPTIONAL	//Regime de internacao
	WSDATA CodExe				AS String 	OPTIONAL	//Codigo do profissional Executante
	WSDATA NomExe				AS String 	OPTIONAL	//Nome do Executante
	WSDATA CodSig				AS String 	OPTIONAL 	//Sigla CRM
	WSDATA NumCr				AS String 	OPTIONAL 	//Numero CRM
	WSDATA Estado				AS String 	OPTIONAL 	//Estado CRM
	WSDATA AteRN				AS String 	OPTIONAL	//Se e recen nascido
	WSDATA Sequen				AS String 	OPTIONAL	//Sequencia
	WSDATA TipPre				AS String 	OPTIONAL	//Tipo de prestador
	WSDATA GrpInt				AS String 	OPTIONAL	//Grupo de Internacao
	WSDATA AreaAbr				AS String 	OPTIONAL	//Abrangencia
	WSDATA ChavLib				AS String 	OPTIONAL	//Chave da Guia
	WSDATA MatRet				AS String 	OPTIONAL	//String com os campos de retorno separados por #
	WSDATA TipoProc				AS String 	OPTIONAL	//Tipo de Processamento
	WSDATA Cbos				    AS String 	OPTIONAL	//Cbos Especialidade
	WSDATA ChvBD6				AS String 	OPTIONAL	//Chave BD6
	WSDATA EndCon				AS String 	OPTIONAL	//Endereco do Contratado
	WSDATA Dente				AS String 	OPTIONAL	//Dente
	WSDATA Face					AS String 	OPTIONAL	//Face
	WSDATA GrPar				AS String 	OPTIONAL	//Grau de Participacao
	WSDATA AutItem				AS Array Of AutItemView OPTIONAL //Item do formulario
	WSDATA MatBD6          		AS Array Of SMatBD6 OPTIONAL //Dados do BD6
	WSDATA StProc				AS String 	OPTIONAL	//Status do Procedimento
	WSDATA TissVer			    AS String 	OPTIONAL	//Versao Tiss da RDA
	WSDATA ValorApr			    AS String 	OPTIONAL	//Valor apresentado
	
	WSDATA CarSol				AS String   OPTIONAL    //Carater Solicitação
	WSDATA Cnes					AS String   OPTIONAL    //CNES
	WSDATA Cid2					AS String   OPTIONAL    // CID 2 
	WSDATA Cid3					AS String   OPTIONAL    // CID 3 
	WSDATA Cid4					AS String   OPTIONAL    // CID 4 
	WSDATA Cid5					AS String   OPTIONAL    // CID 5 
	WSDATA TipSai				AS String   OPTIONAL    // Tipo de Saida
	WSDATA TipFat				AS String   OPTIONAL    // Tipo de Faturamento 
	WSDATA IndAci				AS String   OPTIONAL    // Indicação de Acidente
	WSDATA TipInt				AS String   OPTIONAL    // Tipo de Internação 
	WSDATA NumSol				AS String   OPTIONAL    // Número Solicitação de Internação
	WSDATA NumGuiTrc			AS String   OPTIONAL    // Número Solicitação de Internação
						
	WSDATA CodOpe				AS String   OPTIONAL    // Número Solicitação de Internação
	WSDATA CodLdp				AS String   OPTIONAL    // Número Solicitação de Internação
	WSDATA CodPeg				AS String   OPTIONAL    // Número Solicitação de Internação
	WSDATA Numero			    AS String   OPTIONAL    // Número Solicitação de Internação	
	
	WSDATA DtIniF 				AS String   OPTIONAL    // Data de Inicio do Faturamento
	WSDATA HrIniF				AS String   OPTIONAL    // Hora Inicio Faturamento
	WSDATA DtFimF				AS String   OPTIONAL    // Data Fim Faturamento
	WSDATA HrFimF				AS String   OPTIONAL    // Hora Fim Faturamento
	
	WSDATA HorIni				AS String OPTIONAL	//Hora Inicio
	WSDATA HorFim				AS String OPTIONAL	//Hora Fim
	WSDATA ViaAc				AS String OPTIONAL	//Via Acesso
	WSDATA TecUt				AS String OPTIONAL   //Tecnica Utilizada
	WSDATA RedAcre			    AS Float  OPTIONAL   //RedAcre
	WSDATA GrpParExe			AS String OPTIONAL//Array Of GrpPar OPTIONAL
	WSDATA Operacao			    AS String OPTIONAL//Array Of GrpPar OPTIONAL		
	WSDATA Observ				AS String OPTIONAL			
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas para Contatos						   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT ContatosTiss
	WSDATA Nome				AS String OPTIONAL //Nome do Contato
	WSDATA TipoContato		AS String OPTIONAL //Tipo do Contato//Coordenador/Suplente
	WSDATA Telefone			AS String OPTIONAL //Telefone
	WSDATA Email			AS String OPTIONAL //Email
	WSDATA Site  			AS String OPTIONAL //Site
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas para Links						   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT LinksList
	WSDATA Codigo		AS String OPTIONAL //Codigo do Link
	WSDATA Descricao	AS String OPTIONAL //Descrição
	WSDATA Link			AS String OPTIONAL //Link
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas para Produtos						   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT ProdutosList
	WSDATA Codigo			AS String OPTIONAL //Codigo do Produto
	WSDATA Versao			AS String OPTIONAL //Versao do Produto
	WSDATA Nome				AS String OPTIONAL //Nome do Produto
	WSDATA Abrangencia		AS String OPTIONAL //Abrangencia do Produto
	WSDATA Susep			AS String OPTIONAL //Numero do Registro do Produto
	WSDATA Segmentacao		AS String OPTIONAL //Segmentacao assistencial
	WSDATA NRegistro 		AS String OPTIONAL //Numero Registro ANS BI3_SCPA
	WSDATA Classificacao	AS String OPTIONAL //BI3_CLAPLS
	WSDATA Situacao 		AS String OPTIONAL //Situação na ANS BI3_APOSRG
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas para Familia						   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT FamBloqList
	WSDATA Matricula		AS String OPTIONAL 	//Matricula do Beneficiario
	WSDATA Nome				AS String OPTIONAL 	//Nome do Beneficiario
	WSDATA CPF	  			AS String OPTIONAL 	//CPF do Beneficiario
	WSDATA DataInc			AS DATE   OPTIONAL  //Data de Inclusao do Beneficiario
	WSDATA DataNasc			AS DATE   OPTIONAL  //Data de Nascimento do Beneficiario      
	WSDATA DataBloq			AS DATE   OPTIONAL  //Data de Bloqueio do Beneficiario 
	WSDATA SolicAbert		AS String OPTIONAL 	//Tipo de vinculo do Beneficiario
	WSDATA TipoBenef		AS String OPTIONAL 	//Tipo de vinculo do Beneficiario
	WSDATA Recno            AS Integer OPTIONAL //
	WSDATA MsgRN            AS String OPTIONAL 	//Mensagem RN412
ENDWSSTRUCT        
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas solicitacoes de bloqueio			   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SolicCanPlaList
	WSDATA Protocolo		AS String OPTIONAL  
	WSDATA DataSolic		AS DATE   OPTIONAL 
	WSDATA DataBloq 		AS DATE   OPTIONAL   
	WSDATA Status   		AS String OPTIONAL  
	WSDATA Origem           AS String OPTIONAL    
	WSDATA Recno            AS Integer OPTIONAL
ENDWSSTRUCT 
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas utilizadas para Produtos						   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT ArquivosList
	WSDATA Data				AS Date OPTIONAL //Data do Upload
	WSDATA NomeArqIn		AS String OPTIONAL //Nome do Arquivo de entrada a ser exibido
	WSDATA ArquivoIn		AS String OPTIONAL //Nome do Arquivo de entrada
	WSDATA ArquivoOut		AS String OPTIONAL //Nome do Arquivo de saida
	WSDATA DesSta			AS String OPTIONAL //Descricao do status do arquivo
	WSDATA Status			AS String OPTIONAL //Status do arquivo
	WSDATA QtdPag			AS Integer OPTIONAL //Quantidade de Paginas
	WSDATA CodPeg			AS String OPTIONAL 	//CodPeg
	WSDATA TPARQ			AS String OPTIONAL //NFSS
	WSDATA Sequen			AS String OPTIONAL //Sequencia
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para peg
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT sMatPEG
	WSDATA funName					AS String	OPTIONAL
	WSDATA where					AS String	OPTIONAL
	WSDATA colsCk					AS String	OPTIONAL
	WSDATA colsUnCk					AS String	OPTIONAL
	WSDATA semaforo					AS String	OPTIONAL
	WSDATA gerPeg					AS Boolean	OPTIONAL
	WSDATA mosGui					AS Boolean	OPTIONAL
	WSDATA funJS					AS String	OPTIONAL
	WSDATA grvVlrApr					AS Boolean	OPTIONAL
	WSDATA TipoGuia				AS String OPTIONAL	
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar proc. com carência no portal
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SCarPor
	WSDATA CodPro			    AS String 	OPTIONAL
	WSDATA DescPro		    AS String 	OPTIONAL
	WSDATA REC				    AS String 	OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para termos TISS
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT STermoTiss
	WSDATA VerTiss		AS String	OPTIONAL
	WSDATA VlrProt		AS String	OPTIONAL
	WSDATA CodAlias		AS String	OPTIONAL
	WSDATA VlrTiss		AS String	OPTIONAL
	WSDATA CodTab			AS String	OPTIONAL
	WSDATA Campo			AS String	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SGuiaTiss
	WSDATA VerTiss		AS String	OPTIONAL
	WSDATA TipGui			AS String	OPTIONAL
	WSDATA DadCombo		AS String OPTIONAL
ENDWSSTRUCT

WSSTRUCT SRetGuiaTiss
	WSDATA Pagina			AS String OPTIONAL
	WSDATA CmpGuia		AS Array Of SCmpGuia OPTIONAL
	WSDATA RetCmbsGuia	AS Array Of SRetCmbsGuia OPTIONAL
	WSDATA Grids			AS String OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar os dados dos usuarios do grupo familiar
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SDadGrp
	WSDATA Matricl			    AS String 	OPTIONAL
	WSDATA NomeBnf			    AS String 	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar as receitas cadastradas para o usuario
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SDadRecUsr
	WSDATA CodRec               AS String OPTIONAL
	WSDATA NomRec               AS String OPTIONAL
	WSDATA CodMed               AS String OPTIONAL
	WSDATA NomMed               AS String OPTIONAL
	WSDATA QtdAut					AS Integer OPTIONAL
	WSDATA QtdExe					AS Integer OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estrutura para retornar os dados da solicitação de opcionais
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SDadSolOpc
		//informações da solicitação
		WSDATA RecnoSol  AS String 	OPTIONAL //recno da solicitação
		WSDATA Prot      AS String 	OPTIONAL //protocolo
		WSDATA DataSol   AS Date 	OPTIONAL //data da solicitação
		WSDATA HoraSol   AS String 	OPTIONAL //hora da solicitação
		WSDATA Classe    AS String  OPTIONAL
		//informações da operadora
		WSDATA DadosOpe  AS SDadOpe OPTIONAL //nome da operadora
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estrutura para retornar os dados da operadora
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SDadOpe
		WSDATA CodOpe	   AS String 	OPTIONAL //código da operadora
		WSDATA NomeOpe   AS String 	OPTIONAL //nome da operadora
		WSDATA Ender     AS String 	OPTIONAL //endereço
		WSDATA NumEnd    AS String 	OPTIONAL //numero do endereco
		WSDATA Compl     AS String 	OPTIONAL //complemento
		WSDATA Bairro    AS String 	OPTIONAL //bairro
		WSDATA Cidade    AS String 	OPTIONAL //cidade
		WSDATA Estado    AS String 	OPTIONAL //estado
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar a carencia do beneficiario no portal
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SRetCaren
	WSDATA cMsg			    AS String 	OPTIONAL
	WSDATA cInfo			    AS String 	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Estrutura  Principal Noticias			                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SNoticia
	WSDATA DtNotIni		    AS Date 		OPTIONAL
	WSDATA DtNotFin		    AS Date 		OPTIONAL
	WSDATA TituloNot		    AS String 	OPTIONAL
	WSDATA TextoNot		    AS String 	OPTIONAL
	WSDATA ArqNot			    AS Array Of  SArqNot OPTIONAL
	WSDATA cEspec			    AS String 	OPTIONAL
	WSDATA cCodNot		    AS String 	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Estrutura  Principal Arquivos de Noticias                               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SArqNot
	WSDATA CodObj		    AS String 		OPTIONAL
	WSDATA Objeto		    AS String 		OPTIONAL
ENDWSSTRUCT


WSSTRUCT SCmbGuia
	WSDATA CampoG			AS String	OPTIONAL
	WSDATA CBOX			AS String	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SRetCmbsGuia
	WSDATA CampoG			AS String	OPTIONAL
	WSDATA CBOX			AS String	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SCmpGuia
	WSDATA Tipo			AS String	OPTIONAL
	WSDATA Nome			AS String	OPTIONAL
	WSDATA Descri			AS String	OPTIONAL
	WSDATA CmpGrid		AS Array Of SCmpGrid OPTIONAL
	WSDATA aCols			AS Array Of String	OPTIONAL
	WSDATA aHeader		AS Array Of String	OPTIONAL
	WSDATA xCols			AS String	OPTIONAL
	WSDATA xHeader		AS String	OPTIONAL
	WSDATA Valid			AS String	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SCmpGrid
	WSDATA Tipo			AS String	OPTIONAL
	WSDATA Nome			AS String	OPTIONAL
	WSDATA Descri			AS String	OPTIONAL
	WSDATA Valid			AS String	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Estrutura  Principal dado beneficiário                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT SBenefi
	WSDATA NomBenef		    AS String 	OPTIONAL
	WSDATA Matric			    AS String 	OPTIONAL
	WSDATA REC				    AS String 	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SMatric
	WSDATA Matric			    AS String 	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar as classes de procedimentos cadastradas
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SClasseProc
	WSDATA CodInt	    		AS String 	OPTIONAL // Cod operadora
	WSDATA CODE		    	AS String 	OPTIONAL // Codigo da Classe
	WSDATA Description    	AS String 	OPTIONAL // Descrição
	WSDATA IsMedic	    	AS String 	OPTIONAL // Classe de agrupamento para medicamentos sim ou nao
	WSDATA CodPad          	AS String 	OPTIONAL // Codigo de tabela padrão para procedimento padrao
	WSDATA CodProc          	AS String  OPTIONAL // Codigo de procedimento padrão para essa classe
	WSDATA DesProc			As String OPTIONAL // Descrição do procedimento, para evitar uma nova requisição no app
ENDWSSTRUCT

WSSTRUCT SUsuario
	WSDATA permite			AS String 		OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar os dados do tipo de documento de reembolso do portal do beneficiario
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SDadTip
	WSDATA Cod					    AS String 	OPTIONAL
	WSDATA Descri				    AS String 	OPTIONAL
	WSDATA ImgHelp			    AS String 	OPTIONAL
	WSDATA Obriga        		AS String  OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas dos procedimentos inseridos pelo beneficiario pelo portal
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SItensReemb
	WSDATA CodPro	    		AS String 	OPTIONAL // Cod da despesa
	WSDATA CodPad	    		AS String 	OPTIONAL // Cod da despesa
	WSDATA TipDoc		    	AS String 	OPTIONAL // Tipo do documento
	WSDATA NroDoc		    	AS String 	OPTIONAL // Numero do documento fiscal
	WSDATA CodRda		    	AS String 	OPTIONAL // Codigo da RDA nao ref
	WSDATA UsoC		    	AS String 	OPTIONAL // Medcimento de Uso Continuo
	WSDATA IsMedic	    	AS String 	OPTIONAL // Se e medicamento
	WSDATA EnviaRec    		AS String 	OPTIONAL // Se sera enviada a receita junto ao protocolo
	WSDATA VlrPro	    		AS String 	OPTIONAL // Valor da despesa
	WSDATA DatDoc	    		AS Date 	OPTIONAL // Data do documento
	WSDATA QtdPro	    		AS String 	OPTIONAL // qtd da despesa
	WSDATA Estd	    		AS String 	OPTIONAL // qtd da despesa
	WSDATA CodMun	    		AS String 	OPTIONAL // qtd da despesa
	WSDATA SeqRec	    		AS String 	OPTIONAL // Sequencial da Receita
	WSDATA NomRDA				AS STRING OPTIONAL //Nome da RDA não referenciada
	WSDATA Matric         	AS String 	OPTIONAL // matricula do beneficiario
	WSDATA CodRec           	AS String 	OPTIONAL // codigo da receita
	WSDATA CodMed				AS String 	OPTIONAL // codigo do medicamento
	WSDATA SeqMed           	AS String 	OPTIONAL // sequencial do medicamento
	WSDATA CPFCNPJ			AS String OPTIONAL // CPF/CNPJ da rede não referenciada
	WSDATA	TipSer				AS String 	OPTIONAL // tipo do serviço
	WSDATA RecNoItem			AS String 	OPTIONAL // recno do item do reembolso
	WSDATA StatusIte			AS String 	OPTIONAL // Status do item (aprovado ou negado) 
	WSDATA Cidade			    AS String 	OPTIONAL // recno do item do reembolso
	WSDATA UF        			AS String 	OPTIONAL // recno do item do reembolso
	WSDATA ValorPago   			AS String 	OPTIONAL // valor reembolsado 
	WSDATA ValUnitari  			AS String 	OPTIONAL // valor reembolsado 
	WSDATA DatComprov  			AS String 	OPTIONAL // Data do comprovante 

ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas dos procedimentos inseridos pelo beneficiario pelo portal
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SEstrReemb
	WSDATA CodSol				AS String	OPTIONAL // Codigo da solicitação (protocolo)
	WSDATA CodRda		    	AS String 	OPTIONAL // Codigo da RDA nao ref
	WSDATA TipDoc				AS String 	OPTIONAL // Tipo do documento da solicitação de reembolso
	WSDATA CpfCnpj			AS String 	OPTIONAL // CPF ou CNPJ do prestador do serviço
	WSDATA NomePre			AS String 	OPTIONAL // Nome do prestador do serviço
	WSDATA NumDoc				AS String 	OPTIONAL // Número do documento/comprovante fiscal
	WSDATA DtEmis				AS String	OPTIONAL // Data de emissão do documento/comprovante fiscal
	WSDATA status				AS String	OPTIONAL // Status do protocolo	
	WSDATA UF					AS String 	OPTIONAL
	WSDATA Cidade				AS String 	OPTIONAL
	WSDATA ListDesp			AS Array Of SItensReemb OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar a observação do protocolo de reembolso
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SRetObsProt
	WSDATA cMsg			    AS String 	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar itens excluidos do reembolso
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SRetIteEx
	WSDATA cMsg			    AS String 	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar o nome de todos os estados do Brasil
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SDadEst
	WSDATA Descri				    AS String 	OPTIONAL
	WSDATA CodMun				    AS String 	OPTIONAL
ENDWSSTRUCT
WSSTRUCT STratind
	WSDATA obrigat					AS Boolean	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SDadCodMun
	WSDATA Descri				    AS String 	OPTIONAL
	WSDATA CodCid				    AS String 	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SDadSiglaCR
	WSDATA Descri				    AS String 	OPTIONAL
	WSDATA CodMun				    AS String 	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SDadEnder
	WSDATA Descri				    AS String 	OPTIONAL
	WSDATA CodLoc				    AS String 	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SDadEspec
	WSDATA Descri				    AS String 	OPTIONAL
	WSDATA CodEsp				    AS String 	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SDadload
	WSDATA DescriA			    AS String 	OPTIONAL
	WSDATA DescriB			    AS String 	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SDadBloq
	WSDATA CodBlo				    AS String 	OPTIONAL
	WSDATA Descri				    AS String 	OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas de dados de documento										  						³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SDocs
	WSDATA DocSeq		AS String 	OPTIONAL // Código do documento
	WSDATA DocDesc	AS String 	OPTIONAL // Descrição do documento
	WSDATA DocObrig	AS String 	OPTIONAL // Obrigatoriedade do documento
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estrutura de acreditacoes
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SAcredit
	WSDATA CODIGO 	As String // "Codigo da relação"
	WSDATA CODACR 	As String // "Codigo da acreditação"
	WSDATA DESCACR 	As String // "Descrição da acreditação"
	WSDATA NIVACR 	As String // "Nivel da acreditação"
	WSDATA DESCNIV 	As String // "Descrição do nivel da acreditação"
	WSDATA CODINT 	As String // "CODINT"
	WSDATA CODLOC 	As String // "Código do Local"
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas das solicitações de opcionais no portal									  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SItensOpc
	WSDATA CodBen	    		AS String 	OPTIONAL // Cod do Beneficiário
	WSDATA CodOpc	    		AS String 	OPTIONAL // Cod do Opcional
	WSDATA DatAde		    	AS Date 	OPTIONAL // Data adesão
	WSDATA DatLim		    	AS Date 	OPTIONAL // Data Limite
	WSDATA GrpEmp				AS String	OPTIONAL // Grupo Empresa
	WSDATA CtrEmp				AS String	OPTIONAL // Contrato Empresa
	WSDATA VerCtr				AS String	OPTIONAL // Versão Contrato
	WSDATA SubCtr				AS String	OPTIONAL // Sub Contrato
	WSDATA VerSub				AS String	OPTIONAL // Versão Sub-Contrato
	WSDATA MatUsu				AS String	OPTIONAL // Matricula Titular
	WSDATA EmpBen				AS String	OPTIONAL // Empresa/Beneficiario
	WSDATA CodPln				AS String	OPTIONAL // Codigo Plano
	WSDATA VerPln				AS String	OPTIONAL // Versão Plano
	WSDATA VerOpc				AS String	OPTIONAL // Versão Opcional
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas das solicitações de opcionais no portal									  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SAdadosOpc
	WSDATA dadosBenOpc	    		AS Array of SItensOpc OPTIONAL // Cod do Beneficiário
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Definicao da estruturas utilizadas para retornar as mensagens do portal
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT SMsgPortal
	WSDATA CodMsg		    AS String 	OPTIONAL
	WSDATA Mensagem	    AS String 	OPTIONAL
ENDWSSTRUCT

WSSTRUCT SAMsgsPortal
	WSDATA mensagens         AS Array of SMsgPortal  OPTIONAL
ENDWSSTRUCT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas da impressão de guias TISS em branco			   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT STipGui //30-11
		WSDATA Cod					    AS String 	OPTIONAL //codigo
		WSDATA Descri				    AS String 	OPTIONAL // descrição
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao da estruturas da composicao da solicitacao					   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄlÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSTRUCT st_cart_usuario
	WSDATA mat_usuario	AS String OPTIONAL
	WSDATA tip_usuario	AS String OPTIONAL
ENDWSSTRUCT

WSSTRUCT cart_usuarios
	WSDATA cLogin			AS String OPTIONAL 
	WSDATA cart_usuarios	AS Array of st_cart_usuario OPTIONAL
ENDWSSTRUCT

WSSTRUCT layouts_cartao
	WSDATA layout_nickname 				 AS String OPTIONAL
ENDWSSTRUCT

WSSTRUCT carencias
	WSDATA tipo_servico   				 AS String OPTIONAL
	WSDATA carencia						 AS String OPTIONAL
ENDWSSTRUCT

WSSTRUCT cartao_virtual
	WSDATA login								AS String OPTIONAL		//DESCRIPTION "Informar 'S'(Sim) no beneficiario da familia que acabou de logar"
	WSDATA titular							AS String OPTIONAL
	WSDATA titular_matricula					AS String OPTIONAL
	WSDATA matricula							AS String OPTIONAL
	WSDATA matricula_funcionario			AS String OPTIONAL
	WSDATA matricula_sis_antigo				AS String OPTIONAL
	WSDATA nome								AS String OPTIONAL
	WSDATA sexo								AS String OPTIONAL
	WSDATA nascimento				    		AS Date   OPTIONAL	
	WSDATA telefone							AS String OPTIONAL
	WSDATA email								AS String OPTIONAL	 
	WSDATA inclusao							AS Date   OPTIONAL 	
	WSDATA dependencia_id					AS String OPTIONAL
	WSDATA prontuario_id						AS String OPTIONAL 	
	WSDATA bloqueado							AS String OPTIONAL
	WSDATA motivo_bloqueio					AS String OPTIONAL 	
	WSDATA cpf									AS String OPTIONAL
	WSDATA tipo_pessoa_contratante			AS String OPTIONAL
	WSDATA numero_contrato					AS String OPTIONAL
	
	WSDATA endereco							AS String OPTIONAL
	WSDATA numero								AS String OPTIONAL
	WSDATA complemento						AS String OPTIONAL
	WSDATA bairro								AS String OPTIONAL
	WSDATA cidade								AS String OPTIONAL
	WSDATA estado								AS String OPTIONAL
	WSDATA cep									AS String OPTIONAL
	WSDATA celular							AS String OPTIONAL
	
	WSDATA tipo_beneficiario_id				AS String OPTIONAL
	WSDATA tipo_beneficiario_descricao 	AS String OPTIONAL			
	WSDATA grau_parentesco_id				AS String OPTIONAL 
	WSDATA grau_parentesco_descricao		AS String OPTIONAL 		
	WSDATA numero_cns							AS String OPTIONAL
	WSDATA data_cpt							AS String OPTIONAL
	
	WSDATA convenio_id						AS String OPTIONAL
	WSDATA convenio_descricao				AS String OPTIONAL
	WSDATA convenio_versao					AS String OPTIONAL
	WSDATA convenio_abrangencia				AS String OPTIONAL
	WSDATA convenio_acomodacao				AS String OPTIONAL
	WSDATA convenio_segmentacao				AS String OPTIONAL	
	WSDATA convenio_tipo_contrato			AS String OPTIONAL	
	WSDATA convenio_participativo			AS String OPTIONAL	
	WSDATA convenio_modalidade_cobranca 	AS String OPTIONAL	
	WSDATA convenio_padrao_conforto			AS String OPTIONAL	
	WSDATA convenio_permite_reembolso	 	AS String OPTIONAL	
	WSDATA convenio_tipo_rede_id		 	AS String OPTIONAL
	WSDATA convenio_tipo_rede_descricao 	AS String OPTIONAL
	WSDATA convenio_opcional					AS String OPTIONAL
	WSDATA convenio_carencias				AS Array of carencias OPTIONAL
	WSDATA convenio_ANS						AS String OPTIONAL
	WSDATA convenio_regulamentacao			AS String OPTIONAL 
		
	// Dados do cartão do beneficiario
	WSDATA cartao_validade					AS Date OPTIONAL 		
	WSDATA cartao_via							AS String OPTIONAL
	WSDATA cartao_imagem						AS String OPTIONAL	
	WSDATA cartao_imagem_verso				AS String OPTIONAL
	WSDATA cartao_obs							AS String OPTIONAL
	wsdata cartao_contato1  					AS String OPTIONAL
	WSDATA cartao_contato2					AS String OPTIONAL
	WSDATA cartao_contato3					AS String OPTIONAL
	WSDATA cartao_contato4					AS String OPTIONAL
	WSDATA cartao_contato5					AS String OPTIONAL
	WSDATA layout_cartoes					AS Array of layouts_cartao OPTIONAL
	
	// Empresa
	WSDATA empresa_id							AS String OPTIONAL	
	WSDATA empresa_nome						AS String OPTIONAL
	WSDATA empresa_responsavel				AS String OPTIONAL 	 			
ENDWSSTRUCT

WSSTRUCT st_cartao_virtual
	WSDATA retorno_status   	 				AS Boolean 					OPTIONAL
	WSDATA mensagem							As String						OPTIONAL
	WSDATA retorno_dados		 				AS Array Of cartao_virtual 	OPTIONAL
ENDWSSTRUCT

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Retorna o texto do li e concordo no portal
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
WSSTRUCT RetLieCon
	WSDATA cLieCon	AS String 	OPTIONAL
ENDWSSTRUCT

//--< Dados do beneficiario >--
WSSTRUCT st_dados_benef
	WSDATA CNOMEUSUARI	 				AS String 	OPTIONAL
	WSDATA CMATRICULA					As String	OPTIONAL
	WSDATA DDTNACTO						As String	OPTIONAL
	WSDATA CCNESUSU						As String	OPTIONAL
	WSDATA CSUSEP						As String	OPTIONAL
	WSDATA CSEGASSPL					As String	OPTIONAL
	WSDATA CNUMREGOPE					As String	OPTIONAL
	WSDATA CCONTATOOPE					As String	OPTIONAL
	WSDATA CCONTATOANS					As String	OPTIONAL
	WSDATA DCPT							As String	OPTIONAL
	WSDATA CTPACOMODA					As String	OPTIONAL
	WSDATA CCONTRATACA					As String	OPTIONAL
	WSDATA CABRANG						As String	OPTIONAL
	WSDATA CNOMPRO						As String	OPTIONAL
	WSDATA CNFANTAZOPE					As String	OPTIONAL
	WSDATA CNFAADMBENE					As String	OPTIONAL
	WSDATA CRZSOCIAL					As String	OPTIONAL
	WSDATA DDTVIGPL						As String	OPTIONAL
	WSDATA CNUMCON						As String	OPTIONAL
	WSDATA DDATCON						As String	OPTIONAL
	WSDATA DDTMAXCON					As String	OPTIONAL
	WSDATA CINFOPLAN					As String	OPTIONAL
	WSDATA CINFORMACOE					As String	OPTIONAL
	WSDATA CCARENCAMB					As String	OPTIONAL
	WSDATA CCARENCHOS					As String	OPTIONAL
	WSDATA CCARENCPAT					As String	OPTIONAL
	WSDATA CCARENCODO					As String	OPTIONAL
ENDWSSTRUCT


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao do Web Service de Controle do Usuario                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
WSSERVICE PLSXFUN	 				DESCRIPTION "Funções Genéricas (Login Usuário, E-Mail, Cartão e RDA)"
	WSDATA UserCode					AS String
	WSDATA UserPlsCode				AS String
	WSDATA UserPlsName				AS String
	WSDATA PLSCodUsr 				AS String  OPTIONAL //Codigo de usuario web
	WSDATA TpPor					AS Integer
	WSDATA VldGen					AS String
	WSDATA CodeOpe					AS String
	WSDATA UserLCode				AS LoginView
	WSDATA UserCardNumber			AS String 	OPTIONAL
	WSDATA UserCardEdition			AS String 	OPTIONAL
	WSDATA UserCardName				AS String
	WSDATA LOCALExec				AS String 	OPTIONAL
	WSDATA AreaAbr					AS String 	OPTIONAL
	WSDATA ListOfRDA				AS Array Of RDAView
	WSDATA ObjProfSaud				AS RtProfSaud
	WSDATA RDACode					AS String 	OPTIONAL
	WSDATA CodLoc					AS String 	OPTIONAL
	WSDATA Tipo						AS String 	OPTIONAL
	WSDATA CodEsp					AS String 	OPTIONAL
	WSDATA ServiceCode				AS String
	WSDATA ServiceName				AS String
	WSDATA TableCode				AS String
	WSDATA ProcedureCode			AS String
	WSDATA ProcCodeTransformed		AS String
	WSDATA UserCard					AS UserCardView
	WSDATA MatGuia					AS SMatAutGui
	WSDATA UserEmail                AS String
	WSDATA SmtpEnv                	AS String
	WSDATA UsuEmai                	AS String
	WSDATA UsuPass	                AS String
	WSDATA MsgRet                	AS String
	WSDATA MViewPar					AS SViewPar
	WSDATA MViewHistLog 			AS Array Of SViewHistLog
	WSDATA MViewInteracao 			AS Array Of SViewInteracao
	WSDATA MatAut              		AS Array Of SMatAut
	WSDATA IteGui              		AS Array Of MIteGui
	WSDATA Header           		As Array Of BrwHeader
	WSDATA Alias					As String OPTIONAL
	WSDATA Campos					As String
	WSDATA Busca					As String OPTIONAL
	WSDATA TipBusca					As String OPTIONAL
	WSDATA MtStCOMBO                As MsCombo
	WSDATA MtStDadESP               As MSDadESP
	WSDATA RetAutProc               AS SMatRetAutProc
	WSDATA WSNULL					AS String
	WSDATA Cid						AS String
	WSDATA NumAut					AS String
	WSDATA NumPeg					AS String
	WSDATA Motivo					AS String
	WSDATA TipoAut					AS String 	OPTIONAL
	WSDATA DtAut					AS Date
	WSDATA ProDad                   AS SMProDad
	WSDATA IteDad                   AS SMITE
	WSDATA MtStProDad                   AS SMProDad
	WSDATA SAutProc                 AS SMatAutProc
	WSDATA MatPre          			AS SMatPre
	WSDATA MatBD6          			AS Array Of SMatBD6
	WSDATA MatComGui          		AS Array Of SMatCompGui
	WSDATA RetMatPre				AS Array Of SRetMatPre
	WSDATA RetBox					AS Array Of GenericStruct OPTIONAL
	WSDATA RetCoPar					AS SMatVlr 	OPTIONAL
	WSDATA CompanyCode				AS String  	OPTIONAL
	WSDATA RegPagina 	        	AS Integer 	OPTIONAL 	//Indica quantos registros serao mostrados por pagina
	WSDATA PaginaIni   	    		AS Integer 	OPTIONAL 	//Indica pagina inicial
	WSDATA BuscaTReg				AS String  	OPTIONAL 	//Indica se procura total de registro ou total de pagina
	WSDATA RegTotal   	    		AS Boolean 	OPTIONAL 	//Indica se busca quantidade de registros
	WSDATA QtdPaginas				AS Integer 	OPTIONAL 	//Indica quantidade de paginas
	WSDATA TipoLink 	    		AS String  	OPTIONAL 	//Tipo Link 1=WebService;2=UpLoad/Download
	WSDATA Pesquisa					AS String	OPTIONAL	//Pesquisa em formato de filtro
	WSDATA semaforo					AS String	OPTIONAL	//Controla processo assincrono
	WSDATA Limite					AS Integer	OPTIONAL	//Quantidade de registros a ser devolvido pela query
	WSDATA TissContatos				AS Array Of ContatosTiss OPTIONAL
	WSDATA ListProdutos				AS Array Of ProdutosList OPTIONAL
	WSDATA ListArquivos				AS Array Of ArquivosList OPTIONAL
	WSDATA ListLinks				AS Array Of LinksList OPTIONAL
	WSDATA ListFamBloq				AS Array Of FamBloqList OPTIONAL
	WSDATA ListSolicCanPla  		AS Array Of SolicCanPlaList OPTIONAL
	WSDATA DatInt  					AS Date 	OPTIONAL
	WSDATA HorInt  					AS String 	OPTIONAL
	WSDATA DatAlt  					AS Date   OPTIONAL
	WSDATA HorAlt  					AS String OPTIONAL
	WSDATA MotAlt  					AS String OPTIONAL
	WSDATA Where  					AS String 	OPTIONAL
	WSDATA camposCustom            AS String OPTIONAL
	WSDATA DirArqIn					AS String 	OPTIONAL
	WSDATA Tp						AS Integer 	OPTIONAL
	WSDATA Retorno					AS String 	OPTIONAL
	WSDATA Idx						AS Integer 	OPTIONAL
	WSDATA Chave					AS String 	OPTIONAL
	WSDATA CmdChave					AS String 	OPTIONAL
	WSDATA FunName				    AS String 	OPTIONAL
	WSDATA MatUsu				    AS String 	OPTIONAL
	WSDATA MotCar				    AS String 	OPTIONAL
	WSDATA NumCon				    AS String 	OPTIONAL
	WSDATA SubCon				    AS String 	OPTIONAL
	WSDATA TipAtd				    AS String 	OPTIONAL
	WSDATA matPeg					AS sMatPEG 	OPTIONAL
	WSDATA Especi					AS Array Of GenericStruct OPTIONAL
	WSDATA TermoTiss				AS STermoTiss OPTIONAL
	WSDATA GuiaTiss				AS SGuiaTiss OPTIONAL
	WSDATA RetGuiaTiss			AS SRetGuiaTiss OPTIONAL
	WSDATA cParMV					AS String OPTIONAL
	WSDATA cDefMV					AS String OPTIONAL
	WSDATA cRetMv                   AS String OPTIONAL
	WSDATA StProc				    AS String 	OPTIONAL
	WSDATA ProcCarPort			AS Array Of SCarPor OPTIONAL
	WSDATA DadosGrpFam			AS Array Of SDadGrp OPTIONAL
	WSDATA DadUsrRec            AS Array of SDadRecUsr OPTIONAL
	WSDATA cUsrLogin			   AS String 	OPTIONAL
	WSDATA SoFam   			   AS String 	OPTIONAL
	WSDATA UsrLoginCode			   AS String 	OPTIONAL
	WSDATA DadCarenc				AS Array Of SRetCaren OPTIONAL
	WSDATA cMatrc					AS String 	OPTIONAL
	WSDATA cRecno					AS String 	OPTIONAL
	WSDATA Noticia          		AS Array Of SNoticia
	WSDATA cCodEsp				AS String 	OPTIONAL
	WSDATA cCodNotic				AS String 	OPTIONAL
	WSDATA cCodRDA				AS String 	OPTIONAL
	WSDATA cUserCod				AS String 	OPTIONAL
	WSDATA cOpcao					AS String 	OPTIONAL
	WSDATA ExisTbl				AS Boolean	OPTIONAL
	WSDATA MClasseProc 			AS Array Of SClasseProc
	WSDATA CpfCnpj				AS String 	OPTIONAL
	WSDATA Crm					AS String 	OPTIONAL
	WSDATA Protoc 				AS String 	OPTIONAL
	WSDATA Benef 				AS String 	OPTIONAL
	WSDATA Medico 				AS String 	OPTIONAL
	WSDATA DtReceita 			AS String 	OPTIONAL
	WSDATA Medicamento 			AS String 	OPTIONAL
	WSDATA CodSig				AS String 	OPTIONAL 	//Sigla Conselho
	WSDATA RetProtocolo         AS String 	OPTIONAL
	WSDATA UsaClasse 			AS String OPTIONAL
	WSDATA Estado				AS String 	OPTIONAL
	WSDATA ShowAnexo				AS String 	OPTIONAL
	WSDATA cRDA					AS String 	OPTIONAL
	WSDATA BenInter				AS Array Of SBenefi
	WSDATA AMatric 				AS Array Of SMatric
	WSDATA Usuario 				AS Array Of SUsuario
	WSDATA cUsr					AS String 	OPTIONAL
	WSDATA SetDtInt				AS String OPTIONAL
	WSDATA cCheckDePara 			AS String 	OPTIONAL
	WSDATA cTissVer 				AS String 	OPTIONAL
	WSDATA TipGui 				AS String 	OPTIONAL
	WSDATA DadosTipDoc			AS Array Of SDadTip OPTIONAL
	WSDATA DatDoc					AS Date
	WSDATA NomRdaNRef			 	AS String 	OPTIONAL
	WSDATA VlrApr				 	AS String 	OPTIONAL
	WSDATA ItensReemb				AS SEstrReemb OPTIONAL //Item do formulario
	WSDATA DadObsProt				AS Array Of SRetObsProt OPTIONAL
	WSDATA DadItemExc				AS Array Of SRetIteEx OPTIONAL
	WSDATA UsrCod				 	AS String 	OPTIONAL
	WSDATA DadEst					AS Array Of SDadEst OPTIONAL
	WSDATA cCodPro                AS String OPTIONAL
	WSDATA dTratvinc              AS Array Of STratInd 	OPTIONAL
	WSDATA CodMenu              AS String
	WSDATA CodPor               AS Integer
	WSDATA CamImg               AS String
	WSDATA Classe				 	AS String 	OPTIONAL
	WSDATA codPro                AS String OPTIONAL
	WSDATA TipoVld              	AS String 	OPTIONAL
	WSDATA SenhaVld              AS String 	OPTIONAL
	WSDATA RetSenha              AS String 	OPTIONAL
	WSDATA Telefone              AS String 	OPTIONAL
	WSDATA RecnoBB8              AS String 	OPTIONAL
	WSDATA RetPrest              AS String 	OPTIONAL
	WSDATA CodRdaAcr				 AS String  	OPTIONAL
	WSDATA Acredit				 AS Array of SAcredit	 OPTIONAL
	WSDATA ChaveInt					AS String 	OPTIONAL
	WSDATA Resposta					AS String 	OPTIONAL
	WSDATA Pendente					AS Boolean OPTIONAL
	WSDATA Publico					AS String OPTIONAL
	WSDATA Sequen					AS String OPTIONAL
	WSDATA Ret					 As String Optional
	WSDATA Pacotes			AS	String OPTIONAL
	WSDATA cArquivo				AS String OPTIONAL
	WSDATA NoArqComp			AS String OPTIONAL
	WSDATA cCodRDA				AS String OPTIONAL
	WSDATA Indice					AS String OPTIONAL
	WSDATA lIncRap				AS Boolean OPTIONAL
	WSDATA CodSol					AS String OPTIONAL
	WSDATA Observ					AS String OPTIONAL
    WSDATA CodEst				AS String OPTIONAL
	WSDATA DADRETMUN			As Array Of SDadCodMun OPTIONAL
	WSDATA DadSiglaCR			AS Array Of SDadSiglaCR OPTIONAL
	WSDATA DadEnder			AS Array Of SDadEnder OPTIONAL
	WSDATA DadEspec			AS Array Of SDadEspec OPTIONAL
	WSDATA DadLog				AS String OPTIONAL
	WSDATA Dadload			AS Array Of SDadload OPTIONAL
	WSDATA DadosOpc        AS SAdadosOpc OPTIONAL
	WSDATA Valores          	AS String OPTIONAL
	WSDATA ArrOpc			   AS String OPTIONAL
	WSDATA Classe          	AS String OPTIONAL
	WSDATA DadSolOpc        	AS SDadSolOpc OPTIONAL
	WSDATA cCodTb						AS String OPTIONAL
	WSDATA FlgVRDA					AS String   OPTIONAL
	WSDATA cCodLoc					AS String OPTIONAL
	WSDATA Documentos			AS Array of SDocs OPTIONAL
	WSDATA ItemReemb        	AS SItensReemb OPTIONAL
	WSDATA TipSer				AS String OPTIONAL
	WSDATA Matric				AS String OPTIONAL
	WSDATA NumDoc				AS String OPTIONAL
	WSDATA DocEmi				AS String OPTIONAL
	WSDATA CEP				    AS String OPTIONAL
	WSDATA Rotina           	AS String OPTIONAL
	WSDATA CodMsg           	AS String OPTIONAL
	WSDATA Idioma           	AS String OPTIONAL
	WSDATA DadBloq				AS Array Of SDadBloq OPTIONAL
	WSDATA CodMot				AS String OPTIONAL
	WSDATA CdPlan				AS String OPTIONAL
	WSDATA VsPlan				AS String OPTIONAL
	WSDATA PermT				AS String OPTIONAL
	WSDATA DadosTipGui	   		AS Array Of STipGui OPTIONAL
	WSDATA DatGuia			    AS String OPTIONAL
	WSDATA DtLimRetro			AS String OPTIONAL
	WSDATA Modo					AS String OPTIONAL
	WSDATA MsnBloInter 		    AS String	OPTIONAL
	WSDATA DigiGui				AS String OPTIONAL
	WSDATA DtJs				AS String OPTIONAL
	WSDATA NumGuiRef 			AS String OPTIONAL
	WSDATA TpGuiRef  			AS String OPTIONAL
	WSDATA RecGuiRef 			AS String OPTIONAL
	WSDATA DocObrig           	AS String OPTIONAL
	WSDATA Altera        		AS String OPTIONAL
	WSDATA BloqGui				AS Boolean OPTIONAL
	WSDATA AltCpAT				AS Boolean OPTIONAL
	WSDATA RecnoBD5				AS String OPTIONAL
	WSDATA CamposAlterados	    	AS String OPTIONAL
	WSDATA ItensAlterados	    	AS String OPTIONAL
	WSDATA DataString				AS String OPTIONAL
	WSDATA NumProtoc			 	AS String OPTIONAL
	WSDATA CritProtoc			 	AS String OPTIONAL
	WSDATA DDD  				 	AS String OPTIONAL
	WSDATA	ProtAnt 				AS String OPTIONAL
	WSDATA	Sentimento 			 	AS String OPTIONAL
	WSDATA	TxtLivre 				AS String OPTIONAL
	WSDATA	Matric 				 	AS String OPTIONAL
	WSDATA	Intercambio		 		AS Boolean OPTIONAL
	WSDATA 	dados_benef				AS st_dados_benef OPTIONAL
	WSDATA lista_de_cartoes		 	AS cart_usuarios OPTIONAL
	WSDATA ret_cartao_virtual		As st_cartao_virtual OPTIONAL
	WSDATA lVisualizaProtoc			AS Boolean	OPTIONAL
	WSDATA StMPctIteGui				AS Array Of MPctIteGui OPTIONAL	
	WSDATA RetLieCon 				AS RetLieCon OPTIONAL
	WSDATA CabAlt					AS Boolean OPTIONAL
	WSDATA RecDivs					AS String 	OPTIONAL //recnos B1N
	WSDATA AtuB1N					AS String 	OPTIONAL //Atualiza B1N
	WSDATA TipGui					AS String OPTIONAL
	WSDATA TipProf				AS String OPTIONAL
	WSDATA DadosLanc			 AS Array Of STipGui OPTIONAL
	WSDATA CodProf              AS String OPTIONAL 
	WSDATA OriReemb            	  AS String OPTIONAL  
	WSDATA CodPad		 			AS String OPTIONAL
	WSDATA CodDente		 		AS String OPTIONAL
	WSDATA Dados		 		AS String OPTIONAL
	WSDATA CarreExe					AS Boolean OPTIONAL 
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Metodo																   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	WSMETHOD PlsIntPad			 DESCRIPTION "Operadora  LOCAL"
	WSMETHOD ChkCodPro			 DESCRIPTION "Verifica se o procedimento e valido"
	WSMETHOD ChkCodPct			 DESCRIPTION "Verifica se o procedimento e pacote"
	WSMETHOD GetInteracao		 DESCRIPTION "Retornar dados da Interação"
	WSMETHOD GrvIntera			 DESCRIPTION "Atualizar Auditoria/Interação"
	WSMETHOD RetLstPro 			 DESCRIPTION "Retorna a lista de procedimentos vinculados ao pacote"
	WSMETHOD ChkQtdPro			 DESCRIPTION "Verifica a quantidade para wxibir o lembrete"
	WSMETHOD GetVlrPro			 DESCRIPTION "Retorna o valor do procedimento"
	WSMETHOD ChkCid				 DESCRIPTION "Verifica se o CID e valido"
	WSMETHOD BrwRDA				 DESCRIPTION "Retorna RDA x Local de Atendimento"
	WSMETHOD ProfSaud				 DESCRIPTION "Retorno todos os Profissional de Saude não bloqueados"
	WSMETHOD UserCardValidation	 DESCRIPTION "Validação da Trilha do Cartão"
	WSMETHOD GetEmail			 	 DESCRIPTION "Envio de de E-mail com senha do usuario "
	WSMETHOD GetHistLogin		 DESCRIPTION "Historico de Acesso ao Portal"
	WSMETHOD getCombo			 	 DESCRIPTION "Alimenta varios combos"
	WSMETHOD AutProc				 DESCRIPTION "Autorização de Procedimento"
	WSMETHOD RetAutLib			 DESCRIPTION "Retorna dados de uma Autorização/Solicitação pela matricula ou numero da guia"
	WSMETHOD RetSerPct			 DESCRIPTION "Retorna serviços que fazem parte de pacote"
	WSMETHOD RetAut				 DESCRIPTION "Retorno das guias do usuário por data e prestador"
	WSMETHOD PreAte				 DESCRIPTION "Rotina de Pré-Atendimento"
	WSMETHOD StatusGuia			 DESCRIPTION "Status de uma Autorização"
	WSMETHOD CancelaGuia			 DESCRIPTION "Cancelamento de Guia"
	WSMETHOD GetBox				 DESCRIPTION "Retorna o x2-box de um determinado campo"
	WSMETHOD GetVlrCo				 DESCRIPTION "Retorna o valor da co-participacao"
	WSMETHOD Elegibilidade		 DESCRIPTION "Elegibilidade do Beneficiário"
	WSMETHOD GetContato			 DESCRIPTION "Lista os Contatos TISS"
	WSMETHOD getProdutos			 DESCRIPTION "Lista os Produtos"
	WSMETHOD GetPaginas			 DESCRIPTION "Total de Paginas"
	WSMETHOD getFList				 DESCRIPTION "Lista de arquivo xml do usuario Upload"
	WSMETHOD GetLinks			 	 DESCRIPTION "Lista Links de WebService / Upload - Download"
	WSMETHOD GetDadG				 DESCRIPTION "Retorna dado especifico por tipo de guia"
	WSMETHOD ExeDHInt				 DESCRIPTION "Informar a data de internação"
	WSMETHOD VldHoIn				 DESCRIPTION "Valida dados do Honorario Individual"
	WSMETHOD VldHoPar				 DESCRIPTION "Valida Participações do Honorario Individual"
	WSMETHOD GetBD6				 DESCRIPTION "Carrega dados do BD6"
	WSMETHOD ProcUpXml			 DESCRIPTION "Processa arquivo XML de Upload"
	WSMETHOD ProcDeXml			 DESCRIPTION "Deleta arquivo XML de Upload"
	WSMETHOD IncXmlUp			 	 DESCRIPTION "Inclui ou altera registro da tabela de upload"
	WSMETHOD getGAT    			 DESCRIPTION "Gatilho de campo"
	WSMETHOD setSolCar			 DESCRIPTION "Soliticacao de Carteirinha"
	WSMETHOD getDadGrid			 DESCRIPTION "Retorna dados para gridData"
	WSMETHOD setTFGuia			 DESCRIPTION "Transferencia de guia eletronica para PEG de definitivo"
	WSMETHOD getInProces			 DESCRIPTION "Verifica se esta em processamento transferencia de guais para peg definitivo"
	WSMETHOD posicione			 DESCRIPTION "Posicione"
  	WSMETHOD ppImpRel				 DESCRIPTION "Imprime um determinado relatorio e manda ele por email"
	WSMETHOD ProfSAll				 DESCRIPTION "Retorna todos os profissionais de saude cadastrados"
	WSMETHOD PLSGETMV            DESCRIPTION "Retorna o valor de um parametro SX6"
	WSMETHOD ExCarPortal			 DESCRIPTION "Exibe no portal procedimentos com carência "
	WSMETHOD DadGrpFam			 DESCRIPTION "Retorna os beneficiários que fazem parte do grupo familiar"
	WSMETHOD CarenBnf				 DESCRIPTION "Retorna os dados de carencia do beneficiario"
	WSMETHOD RetNot				 DESCRIPTION "Retorno do filtro de Noticias X Prestadores"
	WSMETHOD ExNotPort			 DESCRIPTION "Verifica a existencia da tabela BPL"
	WSMETHOD GetVlrTiss			 DESCRIPTION "Retorna o termo da TISS"
	WSMETHOD GetFormTiss			 DESCRIPTION "Retorna o formulário da Guia TISS"
	WSMETHOD GetCMBFormT			 DESCRIPTION "Retorna os campos do Tipo Combo da Guia TISS"
	WSMETHOD RetClassProc		 DESCRIPTION "Retorna as classes de procedimentos cadastradas"
	WSMETHOD RDANotRef			 DESCRIPTION "Retorna os dados da rede não referenciada BK6"
	WSMETHOD VldBTQChv           DESCRIPTION "Valida uma chave na tabela BTQ"
	WSMETHOD AutAnexo            DESCRIPTION "Autorizacao de procedimento do anexo"
	WSMETHOD Matric				 DESCRIPTION "Retorna matricula para o campo do pré-atendimento do portal"
	WSMETHOD VALACEBOT			 DESCRIPTION "Valida se usuario logado tem permissão para utilizar o botao internado na tela de pré-atendimento"
	WSMETHOD ReembChkRegr		 DESCRIPTION "Retorna parametrizações de solicitaçao de reembolso no portal do beneficiario"
	WSMETHOD DadTipDoc			 DESCRIPTION "Retorna os tipos de documento que será selecionado no reembolso pelo portal do beneficiario"
	WSMETHOD RDARef				 DESCRIPTION "Retorna os dados da rede não referenciada BK6"
	WSMETHOD PutReembBen			 DESCRIPTION "Faz a gravacao do protocolo de solicitacao de reembolso no portal do beneficiario"
	WSMETHOD OBSPROTOC			 DESCRIPTION "Retorna a observação digitada pelo usuário no protocolo de reembolso/uso constante"
	WSMETHOD RETMEMOGEN			 DESCRIPTION "Retorna o conteudo de um campo memo real genericamente posicionando pelo recno"
	WSMETHOD ExcItmReemb			 DESCRIPTION "Retorna os itens excluidos pelo usuário de uma solicitação de reembolso"
	WSMETHOD ReembDelPI			 DESCRIPTION "Exclui item ou solicitaçao de reembolso protocolada"
	WSMETHOD AtuBow				 DESCRIPTION "Atualiza BOW de acordo com as baixas dos titulo vinculados ao protocolo"
	WSMETHOD DADRETEST			 DESCRIPTION "Retorna todos os estado brasileiros"
	WSMETHOD GetDadGen			 DESCRIPTION "Retorna os dados de um registro de uma tabela qualquer passada por parametro"
	WSMETHOD PPINDCLIN			 DESCRIPTION "Verifica se é obrigatorio a indicação clinica para um procedimento"
	WSMETHOD SenhaExp		        DESCRIPTION "Verifica se a Senha Expirou"
	WSMETHOD VLNUMGUI            DESCRIPTION "Verifica se a guia informada e valida"
	WSMETHOD DelAtalho		  	 DESCRIPTION "Deleta atalho do portal"
	WSMETHOD AddAtalho           DESCRIPTION "Grava atalho no portal"
	WSMETHOD DesProc				 DESCRIPTION "Verifica se o codigo do procedimento é válido"
	WSMETHOD CriPsw		        DESCRIPTION "Valida senha de usário de portal Web"
	WSMETHOD GetPrestBB8         DESCRIPTION "Retorna Dados do prestador de acordo com o RECNO da BAX"
	WSMETHOD Acreditacoes		 DESCRIPTION "Retorna dados das acreditações"
	WSMETHOD GetCalend			 DESCRIPTION "Calendario de Envio de Faturamento"
	WSMETHOD UplConhec 			 DESCRIPTION "Upload de documentos com destino ao banco de conhecimento"
	WSMETHOD GrvSolAdt			 DESCRIPTION "Pré-Gravação da solicitação de aditivo contratual"
	WSMETHOD ConSolAdt			 DESCRIPTION "Pós gravação da solicitação de aditivo contratual (pós-anexos)"
	WSMETHOD DADRETSIGLACR		 DESCRIPTION "Retorna todas as siglas do C.R dos profissionais"
	WSMETHOD DADRETENDER         DESCRIPTION "Combo de endereços"
	WSMETHOD DADRETESPEC			 DESCRIPTION "Combo de Especialidades"
	WSMETHOD GRAVALOG				 DESCRIPTION "Gravação Corpo clínico"
	WSMETHOD DADLOAD				 DESCRIPTION "Load das combos Estado e CR"
	WSMETHOD DelCorpoClinico		 DESCRIPTION "Exclui um profissional do corpo clinico"
	WSMETHOD DadFrmEmp      	 	 DESCRIPTION "Retorna os beneficiários vinculados ao grupo familiar/ grupo empresa"
	WSMETHOD DADRETCID			 DESCRIPTION "Combo de Cidades"
	WSMETHOD DADRETCEN			 DESCRIPTION "Retorna dados do endereco"
	WSMETHOD VERACESSO			 DESCRIPTION "Verifica se é primeiro acesso"
	WSMETHOD INCBENOPC 			 DESCRIPTION "Grava BeneficiáriosxOpcionais"
	WSMETHOD VLDBENOPC   		 DESCRIPTION "Valida a inclusão de opcionais na solicitação de opcionais do portal"
	WSMETHOD GetSolOpc   		 DESCRIPTION "Retorna os dados da solicitação de opcionais"
	WSMETHOD CHECKPROCEDIMENTO   DESCRIPTION "Verifica se inclusão de procedimento é válida de acordo com existência do registro"
	WSMETHOD GRAVAPROCEDIMENTO   DESCRIPTION "Gravação de log para análise de inclusão ou exclusão de procedimentos no contrado da RDA"
	WSMETHOD GrvSolOpc	        DESCRIPTION "pós-gravação da rotina de solicitação de opcionais, caso seja anexado documento"
	WSMETHOD UnUplConhec	        DESCRIPTION "Exclui arquivo enviado para o banco de conhecimento"
	WSMETHOD CpyArqConhe	        DESCRIPTION "Copia um arquivo do banco de conhecimento para uma pasta de download"
	WSMETHOD DelDesp				 DESCRIPTION "Exclui registro de despesa da solicitação de reembolso"
	WSMETHOD VerPermRee			 DESCRIPTION "Verifica se o beneficiário tem permissãopara reembolso"
	WSMETHOD AltSolOpc   		 DESCRIPTION "altera o status da solicitação de opcionais para 2-EM ANALISE quando há inclusão de documentos"
	WSMETHOD PLSTWPGQ				 DESCRIPTION "Grava dados na tabela B96, sobre solictação de tabela de preços RDA"
	WSMETHOD PLSRELYB				 DESCRIPTION "Select para mostrar tabela de solictações"
	WSMETHOD GetDocCorpoCli		 DESCRIPTION "Retorna os documentos cadastrados para o corpo clínico da RDA"
	WSMETHOD GetUsrRec   		 DESCRIPTION "Retorna as receitas do usuário cadastradas para medicamentos de uso continuo"
	WSMETHOD GrvItReemb  		 DESCRIPTION "Grava item do reembolso antes de finalizar a solicitação"
	WSMETHOD GrvFimReemb			 DESCRIPTION "Finaliza gravação da solicitação"
	WSMETHOD VldPrtReem 			 DESCRIPTION "Valida o status da solicitação e devolve os dados para serem editados na tela de solicitação"
	WSMETHOD AltStatRee			 DESCRIPTION "Altera o status do reembolso"
	WSMETHOD IsMedBJE				 DESCRIPTION "Verifica se o serviço é do tipo medicamento"
	WSMETHOD EditSolic 			 DESCRIPTION "Retorna os dados para serem editados na tela de solicitação"
	WSMETHOD GrvRec				 DESCRIPTION "Grava Receita e itens da receita."
	WSMETHOD ExclRect			DESCRIPTION "Exclusão Itens da Receita."
	WSMETHOD AltRect			DESCRIPTION "Alteração Status Receita."
	WSMETHOD RDAPro				DESCRIPTION "Retorna os dados do Profissional BB0."
	WSMETHOD DADRETBEN 			DESCRIPTION "Retorna os dados da vida."
	WSMETHOD VERBENPRI 			DESCRIPTION "Recebe o Login e verifica se é benef, ou ja solicitou."
	WSMETHOD VerPro 			DESCRIPTION "Verifica se já não possue algum protocolo em aberto."
	WSMETHOD AltStBen 			DESCRIPTION "Altera staus da solicitação."
	WSMETHOD PLSPSQVIDA   		DESCRIPTION "Valida o primeiro acesso"
	WSMETHOD GetMsgPortal 		DESCRIPTION "Retorna as mensagens do portal"
	WSMETHOD DADRETBLOQ 		DESCRIPTION "Retorna os motivos da tabela B9G"
	WSMETHOD RETDOC				DESCRIPTION "Retorna os documentos vinculados ao motivo"
	WSMETHOD PREEXCBEN			DESCRIPTION "Pré-gravação da exclusão do beneficiários"
	WSMETHOD POSEXCBEN			DESCRIPTION "Pós-Gravaço da exclusão do beneficiário"
	WSMETHOD PLSVERINCDIG		DESCRIPTION "Verifica se usuário tem acesso a inclusão de guias no portal"
	WSMETHOD getDiaRetro		DESCRIPTION "Dias Retroativos e Permissões de Inclusão de Guias"
	WSMETHOD DadTipGui			DESCRIPTION "Retorna o tipo de guia para impressão em branco"
	WSMETHOD getArqRel			DESCRIPTION "Lista arquivos gerados dos relatorios de pagamentos para download"
	WSMETHOD BloqReem			DESCRIPTION "Verifica se a data do recibo do reembolso é anterior a data de bloqueio do usuário"
	WSMETHOD UsoConsDel 		DESCRIPTION "Exclui protocolo de uso constante ou medicamento"
	WSMETHOD AltStatusB4F       DESCRIPTION "Altera o status da receita quando o beneficiario anexa itens"
	WSMETHOD VLDBA1MATEMP		DESCRIPTION "Retorna número da carteirinha caso o número informado seja encontrado na BA1 (BA1_MATEMP)"
	WSMETHOD GETDIGP 			DESCRIPTION "Retorna o local de digitação padrão para digitação offline"
	WSMETHOD ATGUIAAAUT 		DESCRIPTION "Atualiza guia após autorização"
	WSMETHOD AltFlaInt			DESCRIPTION "Altera a flag do anexo"
	WSMETHOD GRVALTOFF			DESCRIPTION "Grava Alteração Offline"
	WSMETHOD RETCRIMF			DESCRIPTION "Retorna as críticas da BDX"
	WSMETHOD RETCRIAUT			DESCRIPTION "Exbir críticas das guias através da BEG/BEL para o beneficiário"
	WSMETHOD VerDtGuia			DESCRIPTION "Verifica data de atendimento da guia"
	WSMETHOD VBlqBen			DESCRIPTION "Verifica a data de bloqueio do beneficiário"
	WSMETHOD getNumProtoc		DESCRIPTION "Retorna o número sequencial do Protocolo"
	WSMETHOD VldNumProtoc		DESCRIPTION "Valida se o número do Protocolo de Atendimento está correto"
	WSMETHOD Protocolo			DESCRIPTION "Retorna os dados do protocolo quando for intercambio"
	WSMETHOD RetBTQChv 		    DESCRIPTION "Retorna os dados da BTQ de acordo com a Tabela"
	WSMETHOD ExeDHAlt			DESCRIPTION "Informar a data de internação"
	WSMETHOD VlDtFut			DESCRIPTION "Validação de data futura"
	WSMETHOD GetReembProc		DESCRIPTION "Retorna uma lista de procedimento com base no tipo de serviço do reembolso online"
	WSMETHOD PesqReembProc		DESCRIPTION "Retorna uma lista de procedimento com base no tipo de serviço do reembolso online"
	WSMETHOD RetCarVirt			DESCRIPTION "Retorna os dados necessários para geração do cartão virtual do beneficiário no app totvs guia saúde"
	WSMETHOD GetLieCon			DESCRIPTION "Retorna texto do Li e Concordo na solicitaçao reembolso"
	WSMETHOD UpdB1N				DESCRIPTION "Atualiza todas os itens da B1N quando altera o cabeçalho no reembolso"
	WSMETHOD RetItercamb		DESCRIPTION "Retorna se é um usuário de intercambio"	
	WSMETHOD RetDadBen			DESCRIPTION "Retorna os dados do beneficiario"
	WSMETHOD HabBotao			DESCRIPTION "Verifica de foi anexado uma receita no Uso constante"
	WSMETHOD getLancam			DESCRIPTION "Lista os lançamentos"
	WSMETHOD VerGuiInt			DESCRIPTION "Verifica situação da Internação, para lançamento da guia de Resumo de Internação."
	WSMETHOD ExclResu 			DESCRIPTION "Exclusã Resumo"	
	WSMETHOD VldItReemb			DESCRIPTION "Valida itens negados para reembolso"
	WSMETHOD getFamBloq			DESCRIPTION "Retorna os beneficiários da família para realização do bloqueio"
	WSMETHOD procSolicBloq    	DESCRIPTION "Efetua a gravação de uma solicitação de bloqueio"
	WSMETHOD getSolCanPla     	DESCRIPTION "Busca solicitações de bloqueio de plano"
	WSMETHOD RetCriTXT			Description "Retorna as críticas do XML em base 64"
	WSMETHOD isDupGui			DESCRIPTION "Verifica se a guia prestes a ser digitada pode estar sendo duplicada"
	WSMethod RetProSau			Description "Retorna codigo do profissional de saude para internacao"
	WsMethod RetCriPROT			Description "Protocolo"
	WSMETHOD RetVldDent			DESCRIPTION "Retorna as faces para um determinado dente" 
	WSMETHOD getCboxGen			DESCRIPTION "Retorna dados para combobox generico" 
	
ENDWSSERVICE
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PlsIntPad ³Autor  ³ Alexander Santos      ³ Data ³13.01.2005 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina que retorna a operadora local						     |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PlsIntPad WSRECEIVE NullParam WSSEND CodeOpe  WSSERVICE PLSXFUN
LOCAL aArea	  := GetArea()
LOCAL lRet    := .T.
LOCAL cCodInt := PlsIntPad()

If !Empty(cCodInt) .And. Len(cCodInt) == 4
   ::CodeOpe := cCodInt
Else
	SetSoapFault( "PlsIntPad", cCodInt )
	lRet := .F.
EndIf

RestArea( aArea )

Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getCombo  ³Autor  ³ Alexander Santos      ³ Data ³02.02.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina para alimentar matriz conforme o x3_combo			   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD getCombo WSRECEIVE UserCode,Tp,Alias,Retorno,Idx,Chave,CmdChave,ShowAnexo WSSEND MtStCOMBO WSSERVICE PLSXFUN
LOCAL nI	  		:= 0
LOCAL lRet    		:= .T.
LOCAL aArea	  		:= GetArea()
LOCAL aRet	  		:= {}
LOCAL aRetAux 		:= {}
LOCAL lOdonto 		:= GetNewPar("MV_PLATIOD","0") == "1"
LOCAL lSisOdo 		:= GetNewPar("MV_PLSISOD","0") == "1"
lOCAL cEvento		:=	""
LOCAL cCodInt 		:= PlsIntPad()
LOCAL cRetTpFt		:= ""
LOCAL cTissVer		:= PLSTISSVER()
LOCAL lPLSTPFAT     := ExistBlock("PLSTPFAT")
DEFAULT ::Tp		:=  1
DEFAULT ::Alias    	:= ""
DEFAULT ::Retorno	:= ""
DEFAULT ::Idx       := 1
DEFAULT ::Chave		:= ""
DEFAULT ::CmdChave	:= ""
DEFAULT ::ShowAnexo	:= "0"
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Checa rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode , "PLSXFUN", "getCombo" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Define a strutura principal											   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	::MtStCOMBO := WsClassNew( "MsCombo" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Prestador
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	If ::Tp == 1
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta o codigo da tabela codpad									   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CodPad := GetNewPar("MV_PLSTBPD","01")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta matriz conforme x3_box Tipo de Doença							   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRet := {}
		aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_TIPDOE",'X3_CBOX') ),,,1 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbTpDoe := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbTpDoe, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbTpDoe[nI]:Code        := AllTrim(aRet[nI,2])
				   ::MtStCOMBO:CbTpDoe[nI]:Description := AllTrim(aRet[nI,3])
			   EndIf
		   Next
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta matriz conforme x3_box Tempo doenca							   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRet := {}
		aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_UTPDOE",'X3_CBOX') ),,,1 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbTmpDoe := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbTmpDoe, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbTmpDoe[nI]:Code        := AllTrim(aRet[nI,2])
				   ::MtStCOMBO:CbTmpDoe[nI]:Description := AllTrim(aRet[nI,3])
			   EndIf
		   Next
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta matriz conforme x3_box Indicacao de acidente					   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRet := {}
		aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_INDACI",'X3_CBOX') ),,,1 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbIndAcid := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbIndAcid, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbIndAcid[nI]:Code        := AllTrim(aRet[nI,2])
				   ::MtStCOMBO:CbIndAcid[nI]:Description := AllTrim(aRet[nI,3])
			   EndIf
		   Next
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta matriz conforme x3_box										   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRet := {}
		aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_TIPCON",'X3_CBOX') ),,,1 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura Tipo de consulta								   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbTpCon := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbTpCon, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbTpCon[nI]:Code        := AllTrim(aRet[nI,2])
				   ::MtStCOMBO:CbTpCon[nI]:Description := AllTrim(aRet[nI,3])
			   EndIf
		   Next
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta matriz conforme x3_box Tip de saida							   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRet := {}
		aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_TIPSAI",'X3_CBOX') ),,,1 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbTpSai := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbTpSai, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbTpSai[nI]:Code        := AllTrim(aRet[nI,2])
				   ::MtStCOMBO:CbTpSai[nI]:Description := AllTrim(aRet[nI,3])
			   EndIf
		   Next
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta matriz conforme x3_box Carater da solicitacao					   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRet := {}
	    If BB8->( FieldPos("BB8_CARSOL") ) == 0
		    AaDd(aRet,{'U',"Urgencia/Emergencia"} )
		    AaDd(aRet,{'E',"Eletiva"} )
		Else
			aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BB8_CARSOL",'X3_CBOX') ),,,1 )
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbCarSolict := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbCarSolict, WsClassNew( "GenericStruct" ) )
				   If BB8->( FieldPos("BB8_CARSOL") ) == 0
					   ::MtStCOMBO:CbCarSolict[nI]:Code        := AllTrim(aRet[nI,1])
					   ::MtStCOMBO:CbCarSolict[nI]:Description := AllTrim(aRet[nI,2])
				   Else
					   ::MtStCOMBO:CbCarSolict[nI]:Code        := AllTrim(aRet[nI,2])
					   ::MtStCOMBO:CbCarSolict[nI]:Description := AllTrim(aRet[nI,3])
				   EndIf
			   EndIf
		   Next
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta matriz conforme x3_box tipo de atendimento					   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRet := {}
		aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_TIPATE",'X3_CBOX') ),,,2 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Para versoes inferiores a 3.0 nao utilizo os novos tipos de atendimento³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cTissVer < "3.00.00"
			aRetAux := {}
			For nI := 1 to len(aRet)
				If !aRet[nI][2] $ "11,13,14,15,16,17 18,19,20,21"
			    	Aadd(aRetAux,aRet[nI])
			    EndIf
			Next
			aRet := aRetAux
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbTpAtend := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbTpAtend, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbTpAtend[nI]:Code        := AllTrim(aRet[nI,2])
				   ::MtStCOMBO:CbTpAtend[nI]:Description := AllTrim(aRet[nI,3])
			   EndIf
		   Next
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta matriz conforme x3_box tipo de atendimento ODONTOLOGICO		   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRet := {}
		aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_TIPATO",'X3_CBOX') ),,,2 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbTpAtOD := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbTpAtOD, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbTpAtOD[nI]:Code        := AllTrim(aRet[nI,2])
				   ::MtStCOMBO:CbTpAtOD[nI]:Description := AllTrim(aRet[nI,3])
			   EndIf
		   Next
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Matriz auxiliar para pegar a via de acesso mais codigo da via	   	   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		BGR->( DbSetOrder(1) )//BGR_FILIAL + BGR_CODINT + BGR_CODVIA
		BGR->( DbGoTop() )
	    While !BGR->( Eof() )
	       AaDd(aRetAux,{BGR->BGR_VIATISS,BGR->BGR_CODVIA})
	    BGR->( DbSkip() )
	    EndDo
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta matriz conforme x3_box Via de acesso							   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRet := {}
		aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BGR_VIATIS",'X3_CBOX') ),,,1 )
	    For nI := 1 To Len( aRet )
		    nPos := aScan( aRetAux, { |x| x[1] == aRet[nI,2] } )
	        If !Empty(aRet[nI,1]) .And. nPos > 0
	        	aRet[nI,2] := aRetAux[nPos,2]
	        EndIf
	    Next
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbViaAce := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbViaAce, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbViaAce[nI]:Code        := AllTrim(aRet[nI,2])
				   ::MtStCOMBO:CbViaAce[nI]:Description := AllTrim(aRet[nI,3])
			   EndIf
		   Next
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta matriz conforme x3_box Tecnica Utilizada						   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRet := {}
		aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BE2_TECUTI",'X3_CBOX') ),,,1 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbTecUti := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbTecUti, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbTecUti[nI]:Code        := AllTrim(aRet[nI,2])
				   ::MtStCOMBO:CbTecUti[nI]:Description := AllTrim(aRet[nI,3])
			   EndIf
		   Next
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta matriz conforme x3_box Grau de participacao					   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRet := {}
		BWT->( DbSetOrder(1) )//BWT_FILIAL + BWT_CODOPE + BWT_CODPAR
		BWT->( DbGoTop() )
	    While !BWT->( Eof() )
		   AaDd(aRet,{BWT->BWT_CODPAR,BWT->BWT_DESCRI} )
	    BWT->( DbSkip() )
	    EndDo
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbGraPart := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbGraPart, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbGraPart[nI]:Code        := AllTrim(aRet[nI,1])
				   ::MtStCOMBO:CbGraPart[nI]:Description := AllTrim(aRet[nI,2])
			   EndIf
		   Next
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta matriz conforme x3_box Tipo de pre atendimento				   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRet := {}
		aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_TIPO",'X3_CBOX') ),,,1 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbTpPreAte := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³ Se Nao for Odonto nao montar o Tipo Atendimento = 4-Odontologico
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					If !lSisOdo
			       		If !lOdonto .And. AllTrim(aRet[nI,2])== "4"
							Loop
						Endif
					ElseIf lSisOdo .and. AllTrim(aRet[nI,2])<> "4"
						Loop
	   				EndIf
	   				If ::ShowAnexo == '0' .and. alltrim(AllTrim(aRet[nI,2])) $ "7,8,9"
						loop
			   		Endif
				   	AaDd( ::MtStCOMBO:CbTpPreAte, WsClassNew( "GenericStruct" ) )
				   	::MtStCOMBO:CbTpPreAte[Len(::MtStCOMBO:CbTpPreAte)]:Code        := AllTrim(aRet[nI,2])
				   	::MtStCOMBO:CbTpPreAte[Len(::MtStCOMBO:CbTpPreAte)]:Description := AllTrim(aRet[nI,3])
			   EndIf
		   Next nI
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta matriz conforme x3_box Tipo de Internacao						   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRet := {}
		BQR->( DbSetOrder(1) )//BQR_FILIAL + BQR_GRPINT + BQR_TIPINT
		BQR->( DbGoTop() )
	    While !BQR->( Eof() )

	    	If BQR->BQR_GRPINT == GetNewPar("MV_GRPINT",'1')
			   AaDd(aRet,{BQR->BQR_TIPINT,BQR->BQR_DESTIP} )
			EndIf

	    BQR->( DbSkip() )
	    EndDo
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbTpInter := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbTpInter, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbTpInter[nI]:Code        := AllTrim(aRet[nI,1])
				   ::MtStCOMBO:CbTpInter[nI]:Description := AllTrim(aRet[nI,2])
			   EndIf
		   Next
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta matriz conforme x3_box Regime internacao						   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRet := {}
		aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BE4_REGINT",'X3_CBOX') ),,,1 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbRegInter := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbRegInter, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbRegInter[nI]:Code        := AllTrim(aRet[nI,2])
				   ::MtStCOMBO:CbRegInter[nI]:Description := AllTrim(aRet[nI,3])
			   EndIf
		   Next nI
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Monta matriz conforme x3_box Tipo de guia
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := {}
		aadd(aRet,{'01', 'Guia de Consulta'})
	    aadd(aRet,{'02', 'Guia de SP_SADT / Odontologia '})
	    aadd(aRet,{'05', 'Guia de Resumo de Internação '})
	    aadd(aRet,{'06', 'Guia de Honorários '})
	    aadd(aRet,{'10', 'Guia de Recurso de Glosa '})
		//O trecho abaixo é o original, mas foi comentado, pois estava sendo exibido na tela de Geração de protocolos todas as guias,
		//mesmo aquelas que não podem ser cobradas. Foi optado então em colocar apenas as guias que devem ser cobradas
		//de forma que somente essas sejam exibidas. 
		/*BCL->(dbSetOrder(1))//BCL_FILIAL + BCL_CODOPE + BCL_TIPGUI
		BCL->(dbGoTop())
	    while !BCL->(eof())

	    	if BCL->BCL_PERINC == "1"
			   aadd(aRet,{BCL->BCL_TIPGUI,BCL->BCL_DESCRI} )
			endIf

	    BCL->(dbSkip())
	    endDo*/
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbTipGui := {}
		if len(aRet) > 0
		   for nI := 1 to len( aRet )
		       if !empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbTipGui, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbTipGui[nI]:Code        := allTrim(aRet[nI,1])
				   ::MtStCOMBO:CbTipGui[nI]:Description := allTrim(aRet[nI,2])
			   endIf
		   next nI
		endIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Monta matriz conforme x3_box Sexo
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := {}
		aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_TIPFAT",'X3_CBOX') ),,,1 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbTipFat := {}
		If Len(aRet) > 0
			For nI := 1 To Len( aRet )
		    	If !Empty(aRet[nI,1])
		     		If lPLSTPFAT
						cRetTpFt := ExecBlock("PLSTPFAT",.F.,.F.,{})
					Endif

					If !Empty(cRetTpFt)
						If aRet[nI,2] $ Alltrim(cRetTpFt)
						   	AaDd( ::MtStCOMBO:CbTipFat, WsClassNew( "GenericStruct" ) )
							   	::MtStCOMBO:CbTipFat[Len(::MtStCOMBO:CbTipFat)]:Code        := AllTrim(aRet[nI,2])
							   	::MtStCOMBO:CbTipFat[Len(::MtStCOMBO:CbTipFat)]:Description := AllTrim(aRet[nI,3])
						Endif
					Else
					   	AaDd( ::MtStCOMBO:CbTipFat, WsClassNew( "GenericStruct" ) )
						   	::MtStCOMBO:CbTipFat[Len(::MtStCOMBO:CbTipFat)]:Code        := AllTrim(aRet[nI,2])
						   	::MtStCOMBO:CbTipFat[Len(::MtStCOMBO:CbTipFat)]:Description := AllTrim(aRet[nI,3])
					Endif
			   EndIf
		   Next nI
		EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Empresa
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	ElseIf ::Tp == 2
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Monta matriz de categoria
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := PLGETDADR("BIH","BIH->BIH_CODTIP,BIH->BIH_DESCRI")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbCategoria := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbCategoria, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbCategoria[nI]:Code        := AllTrim(aRet[nI,1])
				   ::MtStCOMBO:CbCategoria[nI]:Description := AllTrim(aRet[nI,2])
			   EndIf
		   Next
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Monta matriz conforme x3_box Sexo
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := {}
		aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BA1_SEXO",'X3_CBOX') ),,,1 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbSexo := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbSexo, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbSexo[nI]:Code        := AllTrim(aRet[nI,2])
				   ::MtStCOMBO:CbSexo[nI]:Description := AllTrim(aRet[nI,3])
			   EndIf
		   Next nI
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Estado civil
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := PLGETDADR("SX5","SX5->X5_CHAVE,SX5->X5_DESCRI",1,'33',"X5_TABELA")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Alimenta a estrutura
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		::MtStCOMBO:CbEstCiv := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbEstCiv, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbEstCiv[nI]:Code        := AllTrim(aRet[nI,1])
				   ::MtStCOMBO:CbEstCiv[nI]:Description := AllTrim(aRet[nI,2])
			   EndIf
		   Next nI
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Estado
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := PLGETDADR("SX5","SX5->X5_CHAVE,SX5->X5_DESCRI",1,'12',"X5_TABELA")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Alimenta a estrutura
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		::MtStCOMBO:CbEstado := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbEstado, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbEstado[nI]:Code        := AllTrim(aRet[nI,1])
				   ::MtStCOMBO:CbEstado[nI]:Description := AllTrim(aRet[nI,2])
			   EndIf
		   Next nI
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Tipo Logradouro
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := PLGETDADR("B18","B18->B18_CODIGO,B18->B18_DESCRI")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Alimenta a estrutura
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		::MtStCOMBO:CbTipLog := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbTipLog, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbTipLog[nI]:Code        := AllTrim(aRet[nI,1])
				   ::MtStCOMBO:CbTipLog[nI]:Description := AllTrim(aRet[nI,2])
			   EndIf
		   Next nI
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Status
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := { {'0','Novo'},{'1','Pendente'},{'2','Rejeitado'},{'3','Aceite'} }
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Alimenta a estrutura
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		::MtStCOMBO:CbStatus := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbStatus, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbStatus[nI]:Code        := AllTrim(aRet[nI,1])
				   ::MtStCOMBO:CbStatus[nI]:Description := AllTrim(aRet[nI,2])
			   EndIf
		   Next nI
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Motivo de bloqueio
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := PLGETDADR("BG3","BG3->BG3_CODBLO,BG3->BG3_DESBLO",,'0',"BG3_TIPBLO",.T.)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Alimenta a estrutura
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		::MtStCOMBO:CbMotBlo := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbMotBlo, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbMotBlo[nI]:Code        := AllTrim(aRet[nI,1])
				   ::MtStCOMBO:CbMotBlo[nI]:Description := AllTrim(aRet[nI,2])
			   EndIf
		   Next nI
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Monta matriz conforme x3_box GrauPa
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := {}
		aRet := PLGETDADR("BRP","BRP->BRP_CODIGO,BRP->BRP_DESCRI")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MtStCOMBO:CbGrauPa := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbGrauPa, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbGrauPa[nI]:Code        := AllTrim(aRet[nI,1])
				   ::MtStCOMBO:CbGrauPa[nI]:Description := AllTrim(aRet[nI,2])
			   EndIf
		   Next nI
		EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Familia
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	ElseIf ::Tp == 3
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Verifico os Motivo de segunda via de cartao no Parametro
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		cEvento := AllTrim(GetNewPar("MV_PLSPERO",""))+"/"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³Posiciona na BPX
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		BPX->( DbSetOrder(1) ) //BPX_FILIAL+BPX_CODINT +BPX_MOTIVO

		While (nPos := at("/",cEvento)) > 0
			cAux   	:= SubStr(cEvento, 1, nPos-1)
			cEvento	:= SubStr(cEvento, nPos+1)

			If	BPX->( MsSeek( xFilial( "BPX" ) + cCodInt+cAux) )
				AaDd(aRet, {BPX->BPX_MOTIVO,BPX->BPX_DESCRI } )
			EndIf
		EndDo
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Alimenta a estrutura
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		::MtStCOMBO:CbMotCar := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbMotCar, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbMotCar[nI]:Code        := AllTrim(aRet[nI,1])
				   ::MtStCOMBO:CbMotCar[nI]:Description := AllTrim(aRet[nI,2])
			   EndIf
		   Next nI
		EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Especifico
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	ElseIf ::Tp == 4
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Retorno Generico
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := PLGETDADR(::Alias,::Retorno,::Idx,::Chave,::CmdChave)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Alimenta a estrutura
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		::MtStCOMBO:CbGeneric := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbGeneric, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbGeneric[nI]:Code        := AllTrim(aRet[nI,1])
				   ::MtStCOMBO:CbGeneric[nI]:Description := AllTrim(aRet[nI,2])
			   EndIf
		   Next nI
		EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Movimentacao
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	ElseIf ::Tp == 5
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Situacao
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := { {'1','Pendente'},{'2','Rejeitado'},{'3','Aceite'} }
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Alimenta a estrutura
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		::MtStCOMBO:CbSituac := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbSituac, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbSituac[nI]:Code        := AllTrim(aRet[nI,1])
				   ::MtStCOMBO:CbSituac[nI]:Description := AllTrim(aRet[nI,2])
			   EndIf
		   Next nI
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Operacao
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := { {'0','Carteirinha'},{'1','Inclusão'},{'2','Alteração'},{'3','Cancelamento'} }
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Alimenta a estrutura
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		::MtStCOMBO:CbOperac := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbOperac, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbOperac[nI]:Code        := AllTrim(aRet[nI,1])
				   ::MtStCOMBO:CbOperac[nI]:Description := AllTrim(aRet[nI,2])
			   EndIf
		   Next nI
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Tipo
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := { {'0','Analítico'},{'1','Sintético'} }
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Alimenta a estrutura
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		::MtStCOMBO:CbTipo := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbTipo, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbTipo[nI]:Code        := AllTrim(aRet[nI,1])
				   ::MtStCOMBO:CbTipo[nI]:Description := AllTrim(aRet[nI,2])
			   EndIf
		   Next nI
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Situacao Cadastral
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aRet := { {'0','Ativo'},{'1','Bloqueado'} }
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Alimenta a estrutura
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		::MtStCOMBO:CbSitCad := {}
		If Len(aRet) > 0
		   For nI := 1 To Len( aRet )
		       If !Empty(aRet[nI,1])
				   AaDd( ::MtStCOMBO:CbSitCad, WsClassNew( "GenericStruct" ) )
				   ::MtStCOMBO:CbSitCad[nI]:Code        := AllTrim(aRet[nI,1])
				   ::MtStCOMBO:CbSitCad[nI]:Description := AllTrim(aRet[nI,2])
			   EndIf
		   Next nI
		EndIf
	EndIf
Else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetDadG     ³Autor³ Alexander Santos      ³ Data ³22.02.2010 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna dados especificos por tipo de guia				   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetDadG WSRECEIVE UserCode,Tipo WSSEND MtStDadESP WSSERVICE PLSXFUN
LOCAL nI	  	 	:= 0
LOCAL lRet    	 	:= .T.
LOCAL aArea	  	 	:= GetArea()
LOCAL aRet	  	  	:= {}
//TISS 2.2 - Requisitos minimos é a existencia da tabela BRI e a existencia da função PLSRETLDP
If ! ( PLSALIASEX("BRI") .And. FindFunction("PLSRETLDP") )
	lRet := .F.
	SetSoapFault( "","Necessário atualizar pacote da TISS 2.2 para se utilizar esta funcionalidade.")
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Checa rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "GetDadG" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Define a strutura principal											   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	::MtStDadESP := WsClassNew( "MSDadESP" )
	Do Case
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Consulta															   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Case ::Tipo == '1'
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Sadt																   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Case ::Tipo == '2'
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Internacao															   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Case ::Tipo == '3'
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Dados da internacao													   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet := {}
			aRet := PLRDATP()
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStDadESP:DadRdaTp := {}
			If Len(aRet) > 0
			   For nI := 1 To Len( aRet )
				   AaDd( ::MtStDadESP:DadRdaTp, WsClassNew( "MSDadRda" ) )
				   ::MtStDadESP:DadRdaTp[nI]:Code      := aRet[nI,1]
				   ::MtStDadESP:DadRdaTp[nI]:Name 		:= AllTrim(aRet[nI,2])
				   ::MtStDadESP:DadRdaTp[nI]:CnpfCpf 	:= aRet[nI,3]
				   ::MtStDadESP:DadRdaTp[nI]:Cnes 		:= aRet[nI,4]
				   ::MtStDadESP:DadRdaTp[nI]:CodProf	:= aRet[nI,5]
				   ::MtStDadESP:DadRdaTp[nI]:CodOpe		:= aRet[nI,6]
			   Next
			EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Odontologico														   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Case ::Tipo == '4'
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta o codigo da tabela codpad									   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStDadESP:CodPad := GetNewPar("MV_PLSTPOD",GetNewPar("MV_PLSTBPD","01") )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Honorario Individual												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Case ::Tipo == '5'
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Alimenta a estrutura												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			BWT->( DbSetOrder(3) )//BWT_FILIAL + BWT_CODOPE + BWT_CODEDI
			BWT->( DbGoTop() )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta retorno														   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			::MtStDadESP:CbGraPar := {}
		    While !BWT->( Eof() )
		    	If !Empty(BWT->BWT_CODEDI)

				   AaDd( ::MtStDadESP:CbGraPar, WsClassNew( "GenericStruct" ) )
				   ::MtStDadESP:CbGraPar[Len(::MtStDadESP:CbGraPar)]:Code        := BWT->BWT_CODPAR
				   ::MtStDadESP:CbGraPar[Len(::MtStDadESP:CbGraPar)]:Description := AllTrim(BWT->BWT_DESCRI)

				EndIf
		    BWT->( DbSkip() )
		    EndDo
	EndCase
Else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³UserCardVa³Autor  ³ Alexander Santos      ³ Data ³05.11.2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao do cartao do usuário                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD UserCardValidation WSRECEIVE UserCode, UserCardNumber, UserCardEdition ,UserCardName, LOCALExec, AreaAbr ,Tipo, TipAtd, DatGuia, BloqGui WSSEND  UserCard WSSERVICE PLSXFUN
LOCAL nI
LOCAL lRetorno 		:= .T.
LOCAL aArea 		:= GetArea()
LOCAL aRetorno 		:= {}
LOCAL lMatrAnt      := GetNewPar("MV_PLMATAP","0") == "1" //Mostra Matricula Antiga Portal
Local nDiasBloq	:= GetNewPar("MV_PLDIABL", 0) //Tolerância para atendimento de usuário bloqueado
DEFAULT ::LOCALExec := ""
DEFAULT ::AreaAbr   := ""
DEFAULT ::Tipo		:= "0"
DEFAULT ::DatGuia	:= ""
DEFAULT ::BloqGui	:= ""

//TISS 2.2 - Requisitos minimos é a existencia da tabela BRI e a existencia da função PLSRETLDP
If ! ( PLSALIASEX("BRI") .And. FindFunction("PLSRETLDP") )
	lRetorno := .F.
	SetSoapFault( "","Necessário atualizar pacote da TISS 2.2 para se utilizar esta funcionalidade.")
	RestArea( aArea )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fim da Rotina														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Return(lRetorno)
Endif
If PrtChkUser( ::UserCode, "PLSXFUN", "USERCARDVALIDATION" )

	aRetorno := PLVLDUSRP( ::UserCardNumber, ::UserCardEdition,::UserCardName,::LOCALExec,::AreaAbr,"2",::Tipo,::TipAtd,::DatGuia,::BloqGui)

	If Len(aRetorno) > 0
		If aRetorno[1]
			::UserCard 					:= WsClassNew( "UserCardView" )
			::UserCard:CardNumber		:= IIF(lMatrAnt .And. !Empty(aRetorno[3,1,2]),aRetorno[3,1,2],aRetorno[3,1,1])
			::UserCard:CardNumberOld	:= aRetorno[3,1,2]
			::UserCard:CardName			:= Upper(aRetorno[3,1,3])
			::UserCard:Interchange		:= aRetorno[3,1,4]
			::UserCard:OpeOri	   	    := aRetorno[3,1,5]
			::UserCard:Plano	   	    := aRetorno[3,1,6]
			::UserCard:ValCar	   	    := aRetorno[3,1,7]
			::UserCard:NumCarNac	    := aRetorno[3,1,8]
			::UserCard:ViaCartao		:= aRetorno[3,1,9]
			::UserCard:LOCALCob			:= aRetorno[3,1,10]
			::UserCard:Abrange			:= aRetorno[3,1,11]
			::UserCard:NatJuri			:= aRetorno[3,1,12]
			::UserCard:Telefone			:= aRetorno[3,1,13]
			::UserCard:NomTit			:= aRetorno[3,1,14]
			::UserCard:NomEmp			:= aRetorno[3,1,15]
			::UserCard:Vida				:= aRetorno[3,1,16]
			::UserCard:Dig1				:= aRetorno[3,1,17]
			::UserCard:Dig2				:= aRetorno[3,1,18]
			::UserCard:TpAcom			:= aRetorno[3,1,19]
			::UserCard:PadCon			:= aRetorno[3,1,20]
			::UserCard:DesAcom			:= aRetorno[3,1,21]
			::UserCard:ChkBioInter		:= GetNewPar("MV_PLCHINB","0") == "1"
			::UserCard:CritPreAtdm		:= GetNewPar("MV_CRIPREA",.F.)

			If Len(aRetorno[3,1]) >= 22
				::UserCard:DatBlo           := iif(valType(aRetorno[3,1,22]) == "C", cToD(aRetorno[3,1,22]), aRetorno[3,1,22])
			EndIf

			/*IF !(aRetorno[3,1,23])

				If  !Empty(::UserCard:DatBlo) .AND. ::UserCard:DatBlo <= (dDatabase)
					lRetorno := .F.
					SetSoapFault( "", "Usuário Bloqueado, não será possível prosseguir com o atendimento!!!" )
				Endif
			Else
				lRetorno := .T.
				::UserCard:MsnBloInter	:= aRetorno[2]
			Endif*/


			IF !(aRetorno[3,1,23])  //Verifico se tem algum tipo de bloqueio

				IF (Empty(::DatGuia)) //Não vem da digitação de guias off-line
					If  !Empty(::UserCard:DatBlo) .AND. (::UserCard:DatBlo + nDiasBloq )<= (dDatabase)
						lRetorno := .F.
						SetSoapFault( "", "Usuário Bloqueado, não será possível prosseguir com o atendimento!!!" )
				    Else
				    	lRetorno := .T.
				    	::UserCard:MsnBloInter	:= aRetorno[2]
				    Endif
				ELSE
					IF ( !Empty(::UserCard:DatBlo) .AND. (::UserCard:DatBlo + nDiasBloq )<= (cToD(::DatGuia)) )
						lRetorno := .F.
						SetSoapFault( "", "Usuário Bloqueado, não será possível prosseguir com o atendimento!!!" )
					ElseIf cToD(::DatGuia) < BA1->BA1_DATINC //vemos se o beneficiário já estava cadastrado na data, estamos com a BA1 posicionada
						lRetorno := .F.
						SetSoapFault( "","Data de Atendimento anterior à data de inclusão do Beneficiário!"	)					
					Endif
				ENDIF
			ENDIF

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Retorna Criticas do usuário											   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 		    ::UserCard:UserCritica 	:= {}
 		    //DatGuia preenchido significa digitação off-line. A regra de cima verifica se a data do atendimento é menor que bloqueio
 		    //pois o PLSVLDCON usa a database para conferir bloqueio e no nosso caso, pode estar bloqueado hoje, mas alguns dias atras não.
		    If Len(aRetorno[4]) > 0 .AND. (Empty(::DatGuia))
	    	   For nI := 1 To Len( aRetorno[4] )
	  			   AaDd( ::UserCard:UserCritica, WsClassNew( "UserCardCri" ) )
				   ::UserCard:UserCritica[nI]:DesPri := aRetorno[4,nI,1]
				   ::UserCard:UserCritica[nI]:DesSeq := aRetorno[4,nI,2]
				   ::UserCard:UserCritica[nI]:DesTer := aRetorno[4,nI,3]
               Next
            EndIf
		Else
		   lRetorno := .F.
		   SetSoapFault( "", aRetorno[2] )
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Passe o cartão ou digite a matricula novamente" )
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³BrwRDA    ³Autor  ³ Alexander Santos      ³ Data ³05.11.2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao do cartao do usuário                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD BrwRDA WSRECEIVE UserCode, UserLCode WSSEND ListOfRDA WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aArea 		:= GetArea()
LOCAL aRetorno 		:= {}
LOCAL nI			:= 0
LOCAL nY			:= 0

If PrtChkUser( ::UserCode, "PLSXFUN", "BRWRDA" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Rda																	   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aRetorno := PLRELRDA( ::UserLCode:UserLoginCode )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Matriz Rda															   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	::ListOfRda := {}
	For nI := 1 To Len( aRetorno )
		aAdd( ::ListOfRda, WsClassNew( "RDAView" ) )
		::ListOfRda[nI]:Code		:= aRetorno[nI][1]
		::ListOfRda[nI]:Name		:= aRetorno[nI][2]
		::ListOfRda[nI]:RegAtend	:= aRetorno[nI][3]
		::ListOfRda[nI]:TpPrest		:= aRetorno[nI][4]
		::ListOfRda[nI]:CnpfCpf		:= aRetorno[nI][5]
		::ListOfRda[nI]:Cnes		:= aRetorno[nI][6]
		::ListOfRda[nI]:TpLograd	:= aRetorno[nI][7]
		::ListOfRda[nI]:Address		:= aRetorno[nI][8]
		::ListOfRda[nI]:Numero		:= aRetorno[nI][9]
		::ListOfRda[nI]:Complen		:= aRetorno[nI][10]
		::ListOfRda[nI]:District	:= aRetorno[nI][11]
		::ListOfRda[nI]:Zone		:= aRetorno[nI][12]
		::ListOfRda[nI]:State		:= aRetorno[nI][13]
		::ListOfRda[nI]:IBGE		:= aRetorno[nI][14]
		::ListOfRda[nI]:Cep			:= aRetorno[nI][15]
		::ListOfRda[nI]:RegAns		:= aRetorno[nI][16]
		::ListOfRda[nI]:SigCr		:= aRetorno[nI][18]
		::ListOfRda[nI]:CodCr		:= aRetorno[nI][19]
		::ListOfRda[nI]:EstCr		:= aRetorno[nI][20]
		::ListOfRda[nI]:TipPE		:= aRetorno[nI][21]
		::ListOfRda[nI]:CodBB0		:= aRetorno[nI][22]
		::ListOfRda[nI]:CodOpe		:= aRetorno[nI][23]
		::ListOfRda[nI]:CodLoc		:= aRetorno[nI][24]
		::ListOfRda[nI]:DesLoc		:= aRetorno[nI][25]
		::ListOfRda[nI]:CarSol		:= aRetorno[nI][28]
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Versão da TISS                      									   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aRetorno[nI]) >=29
			::ListOfRda[nI]:TissVer		:= aRetorno[nI][29]
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Matriz Especialidades												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::ListOfRda[nI]:MEspRda := {}
		For nY := 1 To Len( aRetorno[nI,26] )
			AaDd( ::ListOfRda[nI]:MEspRda, WsClassNew( "EspRda" ) )
			::ListOfRda[nI]:MEspRda[nY]:CodEsp		:= aRetorno[nI,26,nY][1]
			::ListOfRda[nI]:MEspRda[nY]:DesEsp 	:= aRetorno[nI,26,nY][2]
			::ListOfRda[nI]:MEspRda[nY]:CodCBOS	:= aRetorno[nI,26,nY][3]
			::ListOfRda[nI]:MEspRda[nY]:DesCBOS	:= aRetorno[nI,26,nY][4]
		Next nY
	Next nI
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ProfSaud  ³Autor  ³ Alexander				³ Data ³01.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Pega todos os profissionais de saude BB0					   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ProfSaud WSRECEIVE UserCode,RDACode,CodLoc,Busca,Tipo, TipGui, TipProf, CarreExe WSSEND ObjProfSaud WSSERVICE PLSXFUN 
Local lRetorno 	   := .T.
Local aArea 	   := GetArea()
Local aRetorno 	   := {}
Local nI		   := 0
Local nJ		   := 1
DEFAULT ::Busca    := ""
DEFAULT ::Tipo	   := "1"
DEFAULT ::TipGui   := ""
DEFAULT ::TipProf  := "S"
DEFAULT ::CarreExe := .T. 

If PrtChkUser( ::UserCode, "PLSXFUN", "ProfSaud" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Profissional de saude												   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aRetorno := PLPROFSAUD(::RDACode,::CodLoc,::Busca,::Tipo, iif(::TipProf == "S", 1,2), ::TipGui)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica retorno														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(aRetorno)
		::ObjProfSaud:ListProfSaud := {}
		For nI := 1 To Len( aRetorno )
			aAdd( ::ObjProfSaud:ListProfSaud, WsClassNew( "ProfSaud" ) )
			::ObjProfSaud:ListProfSaud[nI]:Code		:= aRetorno[nI][1]
			::ObjProfSaud:ListProfSaud[nI]:Name 	:= aRetorno[nI][2]
			::ObjProfSaud:ListProfSaud[nI]:CodSig	:= aRetorno[nI][3]
			::ObjProfSaud:ListProfSaud[nI]:NumCr	:= aRetorno[nI][4]
			::ObjProfSaud:ListProfSaud[nI]:Estado	:= aRetorno[nI][5]
			::ObjProfSaud:ListProfSaud[nI]:CpfCnpj	:= aRetorno[nI][6]
			::ObjProfSaud:ListProfSaud[nI]:CodOpe	:= aRetorno[nI][7]
			::ObjProfSaud:ListProfSaud[nI]:Especi  := {}
			nK := 1
			If Len(aRetorno[nI]) >= 12 .and. !Empty(aRetorno[nI][12])
				For nJ:=1 to Len(aRetorno[nI][12])
					AaDd( ::ObjProfSaud:ListProfSaud[nI]:Especi, WsClassNew( "GenericStruct" ) )
					::ObjProfSaud:ListProfSaud[nI]:Especi[nK]:Code			:= aRetorno[nI][12][nJ][1]
			    	::ObjProfSaud:ListProfSaud[nI]:Especi[nK]:Description	:= aRetorno[nI][12][nJ][2]
					nK++
				Next
			Endif
		Next nI
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Profissional de saude Executante										   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ::CarreExe != NIL .AND. ::CarreExe
		aRetorno := PLPROFSAUD(::RDACode,::CodLoc,::Busca,::Tipo,2)
		If !Empty(aRetorno)
			::ObjProfSaud:ListPfSExe := {}
			For nI := 1 To Len( aRetorno )
				aAdd( ::ObjProfSaud:ListPfSExe, WsClassNew( "ProfSaud" ) )
				::ObjProfSaud:ListPfSExe[nI]:Code		:= aRetorno[nI][1]
				::ObjProfSaud:ListPfSExe[nI]:Name 		:= aRetorno[nI][2]
				::ObjProfSaud:ListPfSExe[nI]:CodSig		:= aRetorno[nI][3]
				::ObjProfSaud:ListPfSExe[nI]:NumCr		:= aRetorno[nI][4]
				::ObjProfSaud:ListPfSExe[nI]:Estado		:= aRetorno[nI][5]
				::ObjProfSaud:ListPfSExe[nI]:CpfCnpj	:= aRetorno[nI][6]
				::ObjProfSaud:ListPfSExe[nI]:CodOpe		:= aRetorno[nI][7]
				::ObjProfSaud:ListPfSExe[nI]:Especi  := {}
				nK := 1
				If Len(aRetorno[nI]) >= 12 .and. !Empty(aRetorno[nI][12])
					For nJ:=1 to Len(aRetorno[nI][12])
						AaDd( ::ObjProfSaud:ListPfSExe[nI]:Especi, WsClassNew( "GenericStruct" ) )
						::ObjProfSaud:ListPfSExe[nI]:Especi[nK]:Code		:= aRetorno[nI][12][nJ][1]
						::ObjProfSaud:ListPfSExe[nI]:Especi[nK]:Description	:= aRetorno[nI][12][nJ][2]
						nK++
					Next
				Endif
			Next nI
		EndIf
	EndIf 
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ProfSAll  ³Autor  ³ Daher					³ Data ³01.03.2013 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Pega todos os profissionais de saude BB0					   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ProfSAll WSRECEIVE UserCode,Busca WSSEND ObjProfSaud WSSERVICE PLSXFUN
Local lRetorno 	:= .T.
Local aArea 	:= GetArea()
Local aRetorno 	:= {}
Local nI		:= 0
Local nJ		:= 1
DEFAULT ::Busca := ""

If PrtChkUser( ::UserCode, "PLSXFUN", "ProfSaud" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Profissional de saude												   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aRetorno := PROFALL(::Busca)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica retorno														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		::ObjProfSaud:ListProfSaud := {}
		For nI := 1 To Len( aRetorno )
			aAdd( ::ObjProfSaud:ListProfSaud, WsClassNew( "ProfSaud" ) )
			::ObjProfSaud:ListProfSaud[nI]:Code		:= aRetorno[nI][1]
			::ObjProfSaud:ListProfSaud[nI]:Name 	:= aRetorno[nI][2]
			::ObjProfSaud:ListProfSaud[nI]:CodSig	:= aRetorno[nI][3]
			::ObjProfSaud:ListProfSaud[nI]:NumCr	:= aRetorno[nI][4]
			::ObjProfSaud:ListProfSaud[nI]:Estado	:= aRetorno[nI][5]
			::ObjProfSaud:ListProfSaud[nI]:CpfCnpj	:= aRetorno[nI][6]
			::ObjProfSaud:ListProfSaud[nI]:CodOpe	:= aRetorno[nI][7]
			::ObjProfSaud:ListProfSaud[nI]:Especi  := {}
			nK := 1
			If Len(aRetorno[nI]) >= 12 .and. !Empty(aRetorno[nI][12])
				For nJ:=1 to Len(aRetorno[nI][12])
					AaDd( ::ObjProfSaud:ListProfSaud[nI]:Especi, WsClassNew( "GenericStruct" ) )
					::ObjProfSaud:ListProfSaud[nI]:Especi[nK]:Code			:= aRetorno[nI][12][nJ][1]
			    	::ObjProfSaud:ListProfSaud[nI]:Especi[nK]:Description	:= aRetorno[nI][12][nJ][2]
					nK++
				Next
			Endif
		Next nI


Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetEmail	    ³Autor  ³ Alexander				³ Data ³15/06/2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina para envio da senha do usuário por e-mail				   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetEmail WSRECEIVE UserCode, UserEmail, SmtpEnv, UsuEmai, UsuPass WSSEND MsgRet WSSERVICE PLSXFUN
LOCAL lOK
LOCAL aArea    		:= GetArea()
LOCAL lRetorno		:= .T.
LOCAL cBody			:= ""
LOCAL cSenhaTemp	:= ""
LOCAL cEmailPLS     := GetNewPar("MV_PLMAILD",'Plano de Saude<planodesaude@totvs.com.br>')
LOCAL cDirRaiz 		:= PLSMUDSIS( GetNewPar("MV_TISSDIR","\TISS\") )
LOCAL cDirWeb			:= PLSMUDSIS( cDirRaiz+"UPLOAD\")
Local carqName		:= ""
DEFAULT ::MsgRet 	:= ""

If PrtChkUser( ::UserCode, "PLSXFUN", "GetEmail" )
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³Verifica se o email existe											   ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    BSW->(DbSetOrder(4)) //BSW_FILIAL + BSW_EMAIL
	If BSW->( MsSeek(xFilial("BSW")+UPPER(Alltrim(UserEmail))))

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	    //³Monta o corpo do e-mail												   ³
	    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cBody := "<html><style type='text/css'><!-- .texto {font-family: Arial, Helvetica, sans-serif;font-size: 12px;"
		cBody += "color: #333333;text-decoration: none;font-weight: normal;}"
		cBody += ".titulo {	font-family: Arial, Helvetica, sans-serif;font-size: 16px;"
		cBody += "color: #19167D;text-decoration: none;font-weight: bold;} --> </style><body>"
		cBody += "<table width='550' border='0' cellpadding='0' cellspacing='0'><tr>"
		cBody += "<td height='263' align='left' valign='top' class='texto'><p class='titulo'><strong><font size='4'>"
		cBody += "Senha de acesso ao Portal do Plano de Saude"
		cBody += "</font></strong></p>"
		While !BSW->(Eof()) .And. BSW->(BSW_FILIAL+UPPER(Alltrim(BSW_EMAIL))) == xFilial("BSW")+UPPER(Alltrim(UserEmail))
			cBody += "<table  width='550' border='1' cellpadding='2' cellspacing='2' bordercolor='#D2DCDF'>"
			cBody += "<tr bordercolor='#D2DCDF' bgcolor='F2F3F5'>"
			cBody += "<td><span class='texto'>"
			cBody += "Login: "
			cBody += "<strong>" + AllTrim(BSW->BSW_LOGUSR) + "</strong><br>"
			cSenhaTemp := Embaralha(DtoS(date())+StrTran(Time(),":","")+AllTrim(BSW->BSW_LOGUSR)+Alltrim(BSW->BSW_EMAIL),0)
			cSenhaTemp := Left(Alltrim(cSenhaTemp),8)
			RecLock("BSW",.F.)
				BSW->BSW_SENHA := PLSCRIDEC(1,AllTrim(cSenhaTemp))
			BSW->(MsUnlock())
			cBody += "Senha:" + AllTrim(cSenhaTemp) + "</strong></span></td>"
			cBody += "</tr></table><br />"
	   		BSW->(DbSkip())
		End
		cBody += "</td></tr></table></body></html>"
	    
	    //criamos o arquivo .htm temporário para enviar o e-mail
	  	carqName := cDirWeb + "00001" + "senha" + STRTran(time(), ":", "_") + ".htm"
		nHandle := FCreate(carqName)
		fWrite(nHandle, cBody) //colocamos o conteúdo no arquivo
		fclose(nHandle)
		//Função de envio de e-mails dos sinalizadores
		PlsWFProc("00001", "email esqueceu a senha", "Senha do PORTAL Plano de Saude", cBody, AllTrim(UserEmail), , , carqName, , , ,)
		//Apagamos o arquivo criado
		FErase(carqName)
				::MsgRet := "Senha enviada com sucesso!"

	Else
		::MsgRet := "E-MAIL não encontrado"
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea(aArea)

Return(lRetorno)
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetHistLogin³Autor  ³ Alexander 	        ³ Data ³15.06.2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna o Historio de acesso ao portal para um Usuário	   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetHistLogin WSRECEIVE UserCode, MViewPar  WSSEND MViewHistLog WSSERVICE PLSXFUN
LOCAL nI
LOCAL lRetorno 		:= .T.
LOCAL aArea 		:= GetArea()
LOCAL aRet			:= {}

If PrtChkUser( ::UserCode, "PLSXFUN", "GetHistLogin" )

	aRet := PLSHISTLOG( ::MViewPar:CodLog,::MViewPar:DateDe,::MViewPar:DateAte,::MViewPar:HorDe,::MViewPar:HorAte )

 	::MViewHistLog 	:= {}
	If Len(aRet) > 1
       For nI := 1 To Len( aRet )
  		   AaDd( ::MViewHistLog, WsClassNew( "SViewHistLog" ) )
		   ::MViewHistLog[nI]:DataAc 		:= DtoC(aRet[nI,1])
		   ::MViewHistLog[nI]:HoraAc 		:= aRet[nI,2]
		   ::MViewHistLog[nI]:EstacaoAc 	:= aRet[nI,3]
       Next
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ChkCid 	³Autor  ³ Alexander	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o cid	e valido						  		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ChkCid WSRECEIVE UserCode, Cid WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aArea    		:= GetArea()
DEFAULT ::WSNULL 	:= "true|"
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "ChkCid" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se verifica se e consulta											   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BA9->( DbSetOrder(1) )//BA9_FILIAL+BA9_CODDOE
	If !BA9->( MsSeek( xFilial("BA9")+::Cid ) )
	   ::WSNULL := "false|Cid não encontrado"
	Else
		::WSNULL := alltrim(BA9->BA9_DOENCA)
	Endif
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RetLstPro ³Autor  ³ Roberto	            ³ Data ³10.04.2015	 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna lista de procedimentos do pacote   	 	 		 	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RetLstPro WSRECEIVE ProDad  WSSEND WSNULL WSSERVICE PLSXFUN
Local cCodPro  := ::ProDad:CodPro
Local lRetorno
Local cProcedimento := ''
Local aProcPac := {}
Local nCont	 := 0
Local cCodPadVinc
Local cCodProVinc
Local cDesProVinc
Private aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB", .F. ,"87"))
Default ::WSNULL 	:= ""

cCondicao := {|| BLE->BLE_FILIAL == xFilial("BLE") .And. ;
                 AllTrim(BLE->BLE_CODPRO) == alltrim(cCodPro) .And. BLE->BLE_TIPO == "9" .And. ;
                 BLE->BLE_VIGDE <= DDATABASE .And. (Empty(BLE->BLE_VIGATE) .Or.  DDATABASE <= BLE->BLE_VIGATE) }

BLE->(DbSetOrder(1))
BLE->(DbSetFilter(cCondicao,""))
BLE->(DbGoTop())

If !BLE->(EOF())
	::WSNULL += "true|"
EndIf

While !BLE->(EOF())

	If nCont <> 0
		::WSNULL += "|"
	EndIf

	cProcedimento := Posicione("BR8",1,xFilial("BR8")+BLE->BLE_CPADOC+BLE->BLE_CODOPC,"BR8_DESCRI")

	cPadBkp := PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  AllTrim(BLE->BLE_CPADOC) ,.T.)

	cCodProVinc	  :=  PLSGETVINC("BTU_CDTERM", "BR8", .F., cCodPadVinc,  Alltrim(AllTrim(BLE->BLE_CPADOC)+AllTrim(BLE->BLE_CODOPC)), .F. ,aTabDup, @cPadBkp)
	cCodPadVinc   :=  cPadBkp
	cDesProVinc	  :=  PLSGETVINC("BTQ_DESTER", "BR8", .F., cCodPadVinc,  Alltrim(AllTrim(BLE->BLE_CPADOC)+AllTrim(BLE->BLE_CODOPC)))

	/*Adiiconando campos para preenchimento da grade em tela.*/
	::WSNULL += "cCodPadSSol;" + cCodPadVinc/*AllTrim(BLE->BLE_CPADOC)*/ + "~"+ "cCodProSSol;"+ cCodProVinc/*AllTrim(BLE->BLE_CODOPC)*/ + "~" + "cDesProSSol;" + /*AllTrim(cProcedimento)*/cDesProVinc

	BLE->(DbSkip())
	nCont += 1
End
::WSNULL += "||"
Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ChkCodPct ³Autor  ³ Roberto	            ³ Data ³09.04.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o procedimento e pacote   	 	 			   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ChkCodPct WSRECEIVE ProDad  WSSEND WSNULL WSSERVICE PLSXFUN
Local cCodPad  := ::ProDad:CodPad
Local cCodPro  := ::ProDad:CodPro
Local cCodRda	:= ::ProDad:CodRda
Local lRetorno := "0"
Local aDados	:= {}
Local lPLSEXPC := GetNewPar("MV_PLSEXPC",.T.)

Default ::WSNULL 	:= ""


cCondicao := {|| BLE->BLE_FILIAL == xFilial("BLE") .And. ;
                 AllTrim(BLE->BLE_CODPRO) == AllTrim(cCodPro) .And. BLE->BLE_TIPO == "9" .And. ;
                 BLE->BLE_VIGDE <= DDATABASE .And. (Empty(BLE->BLE_VIGATE) .Or.  DDATABASE <= BLE->BLE_VIGATE) }

BLE->(DbSetOrder(1))
BLE->(DbSetFilter(cCondicao,""))
BLE->(DbGoTop())

If !BLE->(EOF())
	BLZ->(DbSetOrder(1))//BLZ_FILIAL+BLZ_CODINT+BLZ_CODRDA+BLZ_CODPAD+BLZ_CODPRO
	If !BLZ->(DbSeek(xFilial("BLZ")+BLE->BLE_CODINT+cCodRda+BLE->BLE_CODPAD+BLE->BLE_CODPRO))
		lRetorno  := '0'  //Indica que o pacote não pertence a RDA.
	Else
		lRetorno  := '1'  //Indica que o código digitado é um pacote.
	EndIf
Else
	If lPLSEXPC
		cCondicao := {|| BLE->BLE_FILIAL == xFilial("BLE") .And. ;
		                 AllTrim(BLE->BLE_CODOPC) == AllTrim(cCodPro) .And. BLE->BLE_TIPO == "9" .And. ;
		                 BLE->BLE_VIGDE <= DDATABASE .And. (Empty(BLE->BLE_VIGATE) .Or.  DDATABASE <= BLE->BLE_VIGATE) }

		BLE->(DbSetOrder(1))
		BLE->(DbSetFilter(cCondicao,""))
		BLE->(DbGoTop())

		If !BLE->(EOF())

			BLE->(DbGoTop())

			While !BLE->(EOF())

				cCondicao := {|| BLD->BLD_FILIAL == xFilial("BLD") .And. ;
		                        BLD->BLD_CODPRO == BLE->BLE_CODPRO ;
		                        }

				BLD->(DbSetOrder(1))
				BLD->(DbSetFilter(cCondicao,""))
				BLD->(DbGoTop())
				//Verifica se na tabela de RDA x Pacote existe o procedimento dentro do pacote
				BLZ->(DbSetOrder(1))//BLZ_FILIAL+BLZ_CODINT+BLZ_CODRDA+BLZ_CODPAD+BLZ_CODPRO
				If BLZ->(DbSeek(xFilial("BLZ")+BLD->BLD_CODINT+cCodRda+BLD->BLD_CODPAD+BLD->BLD_CODPRO))
					aadd(aDados,{BLD->BLD_CODPRO, BLD->BLD_DESPRO})
				EndIf
				BLE->(DbSkip())
			End

			If Len(aDados) > 0
				lRetorno := '2' //Indica que o código digitado pertence a um serviço que esta relacionado a um pacote.
			Else
				lRetorno := '3' //Indica que o código digitado pertence a um serviço que não esta relacionado a um pacote.
			EndIf
		Else
			lRetorno := '3' //Indica que o código digitado pertence a um serviço que não esta relacionado a um pacote.
		EndIf
	Else
		lRetorno := '3' //Indica que o código digitado pertence a um serviço que não esta relacionado a um pacote.
	EndIf
EndIf

::WSNULL += lRetorno
Return .T.


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ChkCodPro ³Autor  ³ Alexander	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o procedimento e valido						   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ChkCodPro WSRECEIVE UserCode, ProDad, MatPre WSSEND WSNULL WSSERVICE PLSXFUN
	LOCAL lRetorno 		:= .T.
	LOCAL lConsulta		:= .F.
	LOCAL aArea    		:= GetArea()
	LOCAL lForBloq      := .F.
	LOCAL lForLembr     := .F.
	LOCAL cLembrete		:= ""
	LOCAL cTabDen			:= ""
	LOCAL cDenReg			:= ""
	LOCAL cFace			:= ""
	Local lBusDir		:= .F.
	LOCAL aUser    := {}
	LOCAL aDadRDA    := {}
	LOCAL Ano		:= ""
	LOCAL Mes		:= ""
	LOCAL cTissVer := ""
	LOCAL cCodPad  := ::ProDad:CodPad
	LOCAL cCodPro  := ::ProDad:CodPro
	LOCAL cVinc := ""
	LOCAL cDesVinc := ""
	PRIVATE aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB",.F.,"87"))
	PRIVATE aErrVarVin := {.F., "", "", ""}


	DEFAULT ::WSNULL 	:= ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PrtChkUser( ::UserCode, "PLSXFUN", "ChkCodPro" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se o procedimento existe									   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If aScan(  ClassDataArr(::ProDad)  ,{|x| AllTrim(x[1]) == "TISSVER"  }) > 0 .AND. ValType(::ProDad:TissVer) <> 'U'
			cTissVer := ::ProDad:TissVer
		EndIf

	//Faz os de-para das terminologias
		If cTissVer >="3"
			cCodPad		:= AllTrim(PLSVARVINC('87','BR4',cCodPad))
			cCodPro		:= AllTrim(PLSVARVINC(::ProDad:CodPad,'BR8', ::ProDad:CodPro, cCodPad+::ProDad:CodPro,,aTabDup,@CCODPAD))

			If 	!PChkTabDup(@cCodPad,cCodPro,::ProDad:CodPad) .or. aErrVarVin[1] == .T.
				::WSNULL := "false|De/Para não realizado para -> ("+::ProDad:CodPad+")("+::ProDad:CodPro+"), certifique-se que o mesmo encontra-se na tabela de dominio TISS/ANS. Caso esteja, entre em contato com a sua operadora."
			EndIf
			BR8->(DbSetOrder(3))
			If !BR8->( MsSeek(xFilial("BR8")+AllTrim(cCodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cCodPro) ) )+cCodPad ))
				::WSNULL := "false|Procedimento não encontrado -> ("+cCodPad+")("+cCodPro+")"
			EndIf

		Else
			BR8->( DbSetOrder(3) )//BR8_FILIAL + BR8_CODPSA + BR8_CODPAD
			If !BR8->( MsSeek(xFilial("BR8")+AllTrim(cCodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cCodPro) ) )+cCodPad ))
				::WSNULL := "false|Procedimento não encontrado -> ("+cCodPad+")("+cCodPro+")"
			EndIf
		Endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica procedimento e tipo de guia									   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lConsulta := PLSISCON( AllTrim(cCodPad),AllTrim(cCodPro) )
		If ::ProDad:TpServ == "1" .And. !lConsulta
			::WSNULL := "false|Não é um codigo de consulta ->( "+cCodPro+" )"
		ElseIf At(BR8->BR8_TPPROC,::ProDad:TpProc) == 0 .And. !Empty(BR8->BR8_TPPROC)
			::WSNULL := "false|Procedimento não compatível como tipo de serviço"
		EndIf
		If BR8->(FieldPos("BR8_TIPRAX")) > 0 .and. !Empty(BR8->BR8_TIPRAX) .and. ;
			BR8->BR8_TIPRAX <> '0'
			lForBloq := .T.
		Endif
		If BR8->(FieldPos("BR8_LEMBRE")) > 0 .and. !Empty(BR8->BR8_LEMBRE)
			cLembrete := BR8->BR8_LEMBRE
			If ::ProDad:TpServ == "5"
				lForLembr := .F.
			Else
				lForLembr := PLSLEMBRE(Iif(ProDad:TpServ == '3',.T.,.F.),.T.,cCodPad,cCodPro) //,ProDad:QtdPro)
			EndIf
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se o procedimento permite busca direta									   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		BTP->(dbSetOrder(1)) //BTP_FILIAL + BTP+_CODTAB
		lBusDir := BTP->(MsSeek(xFilial("BTP") + ProDad:CodPad)) .AND. BTP->BTP_BUSDIR = "1"
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Retorna a descricao do procedimento									   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Empty(::WSNULL)

					::WSNULL := "true|"+Iif(cTissVer >="3" .AND. !lBusDir, PLSGETVINC("BTQ_DESTER", 'BR8', .F., ::ProDad:CodPad, Alltrim(cCodPad+cCodPro)), AllTrim(BR8->BR8_DESCRI))	+"|"+Iif( BR8->( FieldPos("BR8_TRAIND") )>0 , BR8->BR8_TRAIND,"0" )+"|"+BR8->BR8_TPPROC

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Retorna o valor do procedimento												   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			Ano := Alltrim(Str(Year(dDataBase)))
			Mes := Alltrim(Str(month(dDataBase)))

			BA1->(dbSetorder(02))
			If valtype(MatPre:Matric) <> 'U' .AND. BA1->( dbSeek(xFilial("BA1")+MatPre:Matric) )

				aUser := PLSDADUSR(::MatPre:Matric,'1',.F.,dDatabase,Nil,Nil,Nil)
				aDadRda := PLSDADRDA(PlsIntPad(),::ProDad:CodRda,"1",dDataBase,"","")

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Retorna Valor										                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aValor := PLSCALCEVE(cCodPad,cCodPro,Mes,Ano,;
									PlsIntPad(),::ProDad:CodRda,aDadRDA[15],"",;
									aDadRDA[12],1,dDataBase,"1",/*cPadInt*/ "",/*::RegAte*/,0,aUser,"",;
									{},nil,nil,nil,nil,"",{},nil,"",0,{},nil,dDataBase,"",{},"",.F.,0,{},nil,;
									.F.,100,"","",1,1,{},"","",,,/*::RegInt*/,"","")

				If ValType(aValor) == "A"

							If Len(aValor) >= 2
								::WSNULL += "|" + Alltrim(Str(aValor[2],13,2))
							Endif
						Else
							::WSNULL += "|0"
						Endif
					Else
						::WSNULL += "|0"
					Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se for odonto														   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If ::ProDad:TpServ == "4"

						If cTissVer >="3"

							If BR8->(FieldPos("BR8_ODONTO")) > 0 .and. BR8->BR8_ODONTO <> "1"
								::WSNULL := "false|Tipo do procedimento não é odontológico! -> ("+cCodPad+")("+cCodPro+")"
							EndIf

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Retorna os dentes que estao amarados ao procedimento					   ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							BYL->( DbSetOrder(1) )//BYL_FILIAL + BYL_CODPAD + BYL_CODPSA + BYL_CODIGO + BYL_TIPO + BYL_FACE
							B05->( DbSetOrder(1) )//B05_FILIAL + B05_CODPAD + B05_CODPSA + B05_CODIGO + B05_TIPO
							If B05->( MsSeek( xFilial("B05")+AllTrim(cCodPad)+AllTrim(cCodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cCodPro) ) ) ) )
								::WSNULL += '|1'
							Else
								::WSNULL += '|0'
							EndIf
						Else

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Retorna os dentes que estao amarados ao procedimento					   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						BYL->( DbSetOrder(1) )//BYL_FILIAL + BYL_CODPAD + BYL_CODPSA + BYL_CODIGO + BYL_TIPO + BYL_FACE
						B05->( DbSetOrder(1) )//B05_FILIAL + B05_CODPAD + B05_CODPSA + B05_CODIGO + B05_TIPO
						If B05->( MsSeek( xFilial("B05")+AllTrim(cCodPad)+AllTrim(cCodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cCodPro) ) ) ) )
							While !B05->( Eof() ) .And. xFilial("B05")+AllTrim(cCodPad+cCodPro) == B05->B05_FILIAL+AllTrim(B05->(B05_CODPAD+B05_CODPSA))
								::WSNULL += '~' + AllTrim(B05->B05_CODIGO) + '$' + AllTrim(B05->B05_CODIGO)+'-'+AllTrim(B05->B05_DESCRI)+'&%-- Face --'
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Retorna as faces do dente											   ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If BYL->( MsSeek( xFilial("BYL")+AllTrim(cCodPad)+AllTrim(cCodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cCodPro) ) )+B05->B05_CODIGO ) )
									While !BYL->( Eof() ) .And. xFilial("BYL")+cCodPad+AllTrim(cCodPro)+AllTrim(B05->B05_CODIGO) == BYL->BYL_FILIAL+BYL->(BYL_CODPAD+AllTrim(BYL_CODPSA)+AllTrim(BYL_CODIGO))
										::WSNULL += '*' + AllTrim(BYL->BYL_FACE) + '%' + AllTrim(BYL->BYL_FACE)+'-'+AllTrim(BYL->BYL_DESFAC)
										BYL->( DbSkip() )
									EndDo
								EndIf

								B05->( DbSkip() )
							EndDo
						EndIf

						EndIf

					Else
				// Apenas para igualar o tamanho do array quando nao for odontologico.
						::WSNULL += "| "
					EndIf

			// Mensagem de raio X
					If lForBloq
						::WSNULL += "|forblo"
					Else
						::WSNULL += "| "
					Endif

			// Lembretes
					If lForLembr
						::WSNULL += "|forbla"
						::WSNULL += "|"+cLembrete
					Else
						::WSNULL += "| "
						::WSNULL += "| "
					Endif
				EndIf
			If	ProDad:CodPro <> "" .And. cTissVer >="3" .AND. !lBusDir 
				cSql := "SELECT BTU_VLRSIS, BTU_VLRBUS FROM "+RetSqlName("BTU")
				cSql += " WHERE BTU_FILIAL = '"+xFilial("BTU")+"' "
				cSql += " AND BTU_CODTAB = '" + ProDad:CodPad  + "' "
				cSql += " AND BTU_CDTERM = '" + ProDad:CodPro + "' "
				cSql += " AND D_E_L_E_T_ <> '*' "
				cSql := ChangeQuery(cSql)

				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql),"TRBBTU",.T.,.F.)

				if TRBBTU->(eof())
					SetSoapFault( "", "Procedimento não encontrado na Tab. da TISS->( "+::ProDad:CodPro+" )" )
					TRBBTU->(DbCloseArea())
					RETURN(.F.)
				endif
				cSql1 := "SELECT BR8_LEMBRE FROM "+RetSqlName("BR8")
				cSql1 += " WHERE BR8_FILIAL = '"+xFilial("BR8")+"' "
				cSql1 += " AND BR8_CODPAD = '" + SUBSTR(TRBBTU->BTU_VLRSIS,Len(xFilial("BR8"))+1,2) + "' "
				cSql1 += " AND BR8_CODPSA = '" + TRBBTU->BTU_VLRBUS  + "' "
				cSql1 += " AND D_E_L_E_T_ <> '*' "
				cSql1 := ChangeQuery(cSql1)

				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql1),"TRBBR8",.T.,.F.)

				cLembrete := ALLTRIM(TRBBR8->BR8_LEMBRE)

				If !Empty(cLembrete)
				::WSNULL += "true|forbla"
				::WSNULL += "|"+cLembrete
				EndIf

				If Select("TRBBTU") > 0
					DbSelectArea("TRBBTU")
					TRBBTU->(DbCloseArea())
				Endif
				If Select("TRBBR8") > 0
					DbSelectArea("TRBBR8")
					TRBBR8->(DbCloseArea())
				Endif
			Endif


	Else
		lRetorno := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
	EndIf

	RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ChkQtdPro ³Autor  ³ Totvs	            ³ Data ³21.10.2013 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³QtdPro																   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ChkQtdPro WSRECEIVE UserCode, ProDad WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aArea    		:= GetArea()
LOCAL lForLembr     := .F.
LOCAL cLembrete		:= ""
DEFAULT ::WSNULL 	:= ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If PrtChkUser( ::UserCode, "PLSXFUN", "ChkQtdPro" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se o procedimento existe									   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BR8->( DbSetOrder(3) )//BR8_FILIAL + BR8_CODPSA + BR8_CODPAD
	If BR8->( MsSeek(xFilial("BR8")+AllTrim(ProDad:CodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(ProDad:CodPro) ) )+ProDad:CodPad ))

		If BR8->(FieldPos("BR8_LEMBRE")) > 0 .and. !Empty(BR8->BR8_LEMBRE)
			cLembrete := BR8->BR8_LEMBRE
			lForLembr := PLSLEMBRE(Iif(ProDad:TpServ == '3',.T.,.F.),.T.,ProDad:CodPad,ProDad:CodPro,ProDad:QtdPro)
		Endif

		// Lembretes
		If lForLembr
			::WSNULL += "true|forbla"
			::WSNULL += "|"+cLembrete
		Endif
	Endif
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf
RestArea( aArea )

If 	ProDad:CodPro <> ""
	cSql := "SELECT BTU_VLRSIS, BTU_VLRBUS FROM "+RetSqlName("BTU")
	cSql += " WHERE BTU_FILIAL = '"+xFilial("BTU")+"' "
	cSql += " AND BTU_CODTAB = '" + ProDad:CodPad  + "' "
	cSql += " AND BTU_CDTERM = '" + ProDad:CodPro + "' "
	cSql += " AND D_E_L_E_T_ <> '*' "
	cSql := ChangeQuery(cSql)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql),"ALIASBTU",.T.,.F.)

	cSql1 := "SELECT BR8_LEMBRE FROM "+RetSqlName("BR8")
	cSql1 += " WHERE BR8_FILIAL = '"+xFilial("BR8")+"' "
	cSql1 += " AND BR8_CODPAD = '" + SUBSTR(ALIASBTU->BTU_VLRSIS,Len(xFilial("BR8"))+1,2) + "' "
	cSql1 += " AND BR8_CODPSA = '" + ALIASBTU->BTU_VLRBUS  + "' "
	cSql1 += " AND D_E_L_E_T_ <> '*' "
	cSql1 := ChangeQuery(cSql1)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql1),"ALIASBR8",.T.,.F.)

	cLembrete := ALLTRIM(ALIASBR8->BR8_LEMBRE)
	If ! Empty(cLembrete)
		::WSNULL += "true|forbla"
		::WSNULL += "|"+cLembrete
	EndIf

	If Select("ALIASBTU") > 0
		DbSelectArea("ALIASBTU")
		ALIASBTU->(DbCloseArea())
	Endif

	If Select("ALIASBR8") > 0
		DbSelectArea("ALIASBR8")
		ALIASBR8->(DbCloseArea())
	Endif
Endif

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetVlrPro ³Autor  ³ Alexander	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o procedimento e valido						   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetVlrPro WSRECEIVE UserCode, ProDad, cCodTb, cCodPro, cCodRDA, cCodLoc, cCodEsp, FlgVRDA WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aArea    		:= GetArea()
Local nI				:= 0
LOCAL aUser    := {}
LOCAL aDadRDA    := {}
LOCAL Ano		:= ""
LOCAL Mes		:= ""

Local cColum			:= ""

////////////////////
Local aRetDaD
Local aPlsVal
Local cAno				:= Alltrim(Str(Year(date())))
Local cMes				:= Alltrim(Str(month(date()/*dDataBase*/)))
Local cNomUnid		:= "-"
Local lFlgCt			:= IIF(FlgVRDA = "SIM", .T., .F.)
Local cPadBkp			:= ""
PRIVATE aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB",.F.,"87"))

::WSNULL 	:= ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "GetVlrPro" )
IF (!lFlgCt)  //Se não for valorizar por RDA
	WSNULL := WsClassNew( "SMProDad" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se o procedimento existe									   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BR8->( DbSetOrder(3) )//BR8_FILIAL + BR8_CODPSA + BR8_CODPAD
	If BR8->( MsSeek(xFilial("BR8")+AllTrim(::ProDad:CodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(::ProDad:CodPro) ) )+::ProDad:CodPad ))

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Retorna o valor do procedimento												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		Ano := Alltrim(Str(Year(dDataBase)))
		Mes := Alltrim(Str(month(dDataBase)))

		If PLSDADUSR(MatPre:Matric,'1',.F.,dDatabase,,,"NAO_VALIDAR_CARTAO")[1]
			aUser := PLSGETUSR()//PLSDADUSR(MatPre:Matric,'1',.F.,dDatabase,,,"NAO_VALIDAR_CARTAO")
		EndIf
		aDadRda := PLSDADRDA(PlsIntPad(),::ProDad:CodRda,"1",dDataBase,"","")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Retorna Valor										                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aValor := PLSCALCEVE(::ProDad:CodPad,::ProDad:CodPro,Mes,Ano,;
							PlsIntPad(),::ProDad:CodRda,aDadRDA[15],"",;
							aDadRDA[12],1,dDataBase,"1",/*cPadInt*/ "",/*::RegAte*/,0,aUser,"",;
							{},nil,nil,nil,nil,"",{},nil,"",0,{},nil,dDataBase,"",{},"",.F.,0,{},nil,;
							.F.,100,"","",1,1,{},"","",,,/*::RegInt*/,"","")

		If ValType(aValor) == "A"

			If Len(aValor) >= 2
				::WSNULL :=  Alltrim(Str(aValor[2],13,2))
			Endif
		Else
			::WSNULL := "0"
		Endif
	Else
		lRetorno := .F.
		SetSoapFault( "","Procedimento não encontrado->( "+::ProDad:CodPro+" )" )
	EndIf
ELSE  //Se for valorizar por prestador
	
		cCodTb		:= AllTrim( PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  cCodTb,.T.) )
		cCodPro 	:= Alltrim( PLSGETVINC("BTU_CDTERM", "BR8", .F., Alltrim(cCodTb),  Alltrim(cCodPro), .T. ,aTabDup, @cPadBkp) )
		aDadRDA 	:= PLSDADRDA(PlsIntPad(),cCodRDA,'1',date(),cCodLoc,cCodEsp,/*cCodTb*/,/*cCodPro*/,,,,,)
		aRetDad 	:= PLSAUTP(date(),,cCodTb,cCodPro,1,aUser,,aDadRDA,,.T.,,.F.,,,,,,,,,,,,,,,,,,,,,,'2')

		//Monto array de cabeçalho para grid de composição
		cCabec := "[{name:'Unidade'},{name:'Descrição'},{name:'Referência'},{name:'Porte'}]"
						
	//Se aRetDad[1] = .T., então procedimento pode ser realizado e está liberado. Verificar valores
		If aRetDaD[1] 
			aPlsVal := PLSCALCEVE (cCodTb, cCodPro, cMes, cAno, PlsIntPad(),::cCodRDA, ::cCodEsp,"",::cCodLoc,1,date(),"1",;
                  "",,,aUser)
			If (Len(aPlsVal[1][1]) > 8)  
				IF (Len(aPlsVal[1]) >= 1)
					For nI := 1 To Len(aPlsVal[1])
		  BD3->(DbSetOrder(1))
						BD3->(MsSeek((xFilial("BD3")) + aPlsVal[1, nI, 1]))
		        		cColum += "{0:{field:'UNID', value:'" + aPlsVal[1,nI,1] + "'} ,1:{field:'DESCRI', value:'" + BD3->BD3_DESCRI + "'},2:{field:'REFER', value:'" + STR(aPlsVal[1,nI,9]) + "'},3:{field:'PORTE', value:'" + (aPlsVal[1,nI,12]) + "'} },"
		        	Next	
	     ENDIF
		   
		   		//Monto o arrays de colunas 
				cColum := "[" + SUBSTRING(cColum, 1, Len(cColum)-1) + "]"
				//Nome do procedimento + elegivel + valor + cabeçalho grid + colunas grid
				::WSNULL := aPlsVal[1][1][8] + "|Sim|" + AllTrim(cValtochar(transform(aPlsVal[2], "@E 999,999,999.99"))) + "|" + cCabec + "|" + cColum + "|" + AllTrim(BR8->BR8_DESCRI) + "|"
		
			ELSE
				::WSNULL := aPlsVal[1][1][8] + "|Não|" + AllTrim(STR(aPlsVal[2])) + "|" + cCabec + "|" + cColum + "|" + BR8->BR8_DESCRI + "|" 
	   ENDIF
		   ELSE
		   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		   //³Aqui, retorno a crítica caso o procedimento não tenha sido encontrado no PLSAUTP ³
		   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		   cCabec := "[{name:'Cód. Glosa'},{name:'Descrição'},{name:'Observação'}]"
			For nI := 1 To Len(aRetDad[2])
				cColum += "{0:{field:'COD', value:'" + aRetDad[2,nI,1] + "'} ,1:{field:'DESCRI', value:'" + aRetDad[2,nI,2] + "'},2:{field:'OBS', value:'" + aRetDad[2,nI,3] + "'} },"
			Next	
			cColum := "[" + SUBSTRING(cColum, 1, Len(cColum)-1) + "]" 
		   ::WSNULL := aRetDad[2,1,7] + "|Não|" + AllTrim("0.00") + "|" + cCabec + "|" + cColum + "|" + BR8->BR8_DESCRI + "|" 
		ENDIF  
	ENDIF	
BR8->(DBCLOSEAREA())
BD3->(DBCLOSEAREA())
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AutProc   ³Autor  ³ Alexander	            ³ Data ³06.04.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Checa regra de um procedimento para um atendimento		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD AutProc WSRECEIVE UserCode, SAutProc, cRecno, DigiGui WSSEND RetAutProc WSSERVICE PLSXFUN
LOCAL nI		 := 0
LOCAL nCont		 := 0
LOCAL nRecBD6    := 0
LOCAL cTipo		 := "1"
LOCAL cOpeSol	 := ""
LOCAL cOpeExe	 := ""
LOCAL cMsg		 := ""
LOCAL cEspSol 	 := ""
LOCAL cEspExe 	 := ""
LOCAL cAliasCab  := "" //12-07

LOCAL lRetorno 	 := .T.
LOCAL lTrtExe    := .F.
LOCAL lRdaProf	 := .F.
LOCAL lAto		 := .F.
LOCAL lSolict	 := (::SAutProc:TipoProc == 'S')
LOCAL cRdaProf	 := ""
LOCAL cCodRda  	 := ::SAutProc:Rda
LOCAL cOpeMov	 := ::SAutProc:OpeRDA
LOCAL cCodEsp    := ::SAutProc:Cbos
LOCAL cCodLoc	 := ::SAutProc:CodLoc
LOCAL cCodProf   := Iif(lSolict,::SAutProc:CdpfSo,::SAutProc:CodExe)
LOCAL cAno		 := ""
LOCAL cMes       := ""
LOCAL cString	 := ""
LOCAL cMatRetRes := "" //Resultado da solicitacao da matriz de retorno separados por ";" para campo e valor e por "#" para outro campo.
LOCAL nQtdUs	 := 0
LOCAL nVlrCon	 := 0
LOCAL nVlrTPF	 := 0
LOCAL aMatRet    := {} //Matriz de retorno faz tratamento para ate 10 retornos diferentes
LOCAL aRetCri	 := {}
LOCAL aVldGen	 := nil
LOCAL aCritica	 := {{}}
LOCAL aCliente	 := {}
LOCAL aRet		 := {}
LOCAL aRetUs	 := {}
LOCAL aDadUsr    := {}
LOCAL aDadRda    := {}
LOCAL aValor	 := {}
LOCAL aQtdBrw	 := {}
LOCAL aArea    	 := GetArea()
LOCAL lFiltPRF   := GetNewPar("MV_PLSPRFS",.t.)
LOCAL nLimitePTU := GetNewPar("MV_PLLIPTU",50)
LOCAL nIndUt	 :=	0
LOCAL nInd1		 := 0
LOCAL cCodNeg 	 := ""
LOCAL aAlerta    := {}
LOCAL aRetAlert  := {}
LOCAL nPosAud    := 0
Local nRecno	 := iIf( ValType(::cRecno) == "U", 0, Val(::cRecno))
Local lDiggui	 := ValType(::DigiGui) == "C" .and. lower(::DigiGui) == "digitacao"

Local aDados 	 := {}
Local aItens 	 := {}
Local objCtrlGuia:= nil

Local aObjProcedimentos := {}
Local oObjVOGuia
Local aRetGui
Local lVerAud := .T.

Local aProcAuto	:= {}

PRIVATE aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB",.F.,"87"))
PRIVATE aErrVarVin := {.F., "", "", ""}

//Checa Usuário														   
If PrtChkUser( ::UserCode, "PLSXFUN", "AutProc" )

	//Ponto de entrada para troca de dados na aut do portal				   
	If ExistBlock("PLCHEDAD")
		aRetPtoEnt := ExecBlock("PLCHEDAD",.F.,.F.,{::SAutProc:CodPad,	::SAutProc:CodPro,::SAutProc:TipoProc })
		::SAutProc:CodPad 	:= aRetPtoEnt[1]
		::SAutProc:CodPro	:= aRetPtoEnt[2]
		::SAutProc:TipoProc	:= aRetPtoEnt[3]
	EndIf
	
	//Monta a matriz de retorno												 
	cString := ::SAutProc:MatRet
    While ( nPos := At( "~", cString ) ) > 0
	    AaDd( aMatRet,SubStr( cString, 1, nPos-1 ) )
	    cString := SubStr( cString, nPos+1, Len(cString) )
	EndDo
	
	//Monta matriz com procedimentos ja executados							 
	For nI := 1 To Len( ::SAutProc:AutItem )
	
		AaDd( aQtdBrw, { 	PADR(::SAutProc:AutItem[nI]:CodPad,Len(BR8->BR8_CODPAD)),;
							PADR(::SAutProc:AutItem[nI]:ProcedureCode,Len(BR8->BR8_CODPSA)),;
							::SAutProc:AutItem[nI]:ProcedureQuantity,;
							::SAutProc:DATPRO,;
							::SAutProc:AutItem[nI]:HORINI,;
							PADR(::SAutProc:AutItem[nI]:DENTE,Len(B04->B04_CODIGO)),;
							PADR(::SAutProc:AutItem[nI]:FACE,Len(B09->B09_FADENT)),;
							StrZero(Val(::SAutProc:AutItem[nI]:SEQUENCE), TamSx3("BD6_SEQUEN")[1])} )
	Next
	
	//Pega o ano e o mes de pagamento											 
	aRet := PLSXVLDCAL(::SAutProc:DatPro,PLSINTPAD(),.F.,"","")
	
	If aRet[1]
	    cMes := aRet[5]
	    cAno := aRet[4]
	ElseIf Len(aRet[2]) > 0
		lRetorno := .F.
		SetSoapFault( "", aRet[2,1,1]+" - "+aRet[2,1,2])
	EndIf

	BAU->(DbSelectArea("BAU"))
	BAU->(DbSetOrder(1))
	If (BAU->(MsSeek(xFilial("BAU")+cCodRda)))
		cTissVer := BAU->BAU_TISVER
	EndIf

	If cTissVer >= "3"

		cCodPad := AllTrim(PLSVARVINC('87','BR4', Alltrim(::SAutProc:CodPad)))
		cCodPro := AllTrim(PLSVARVINC(::SAutProc:CodPad,'BR8',::SAutProc:CodPro ,cCodPad+::SAutProc:CodPro,,aTabDup,@CCODPAD))

		If 	!PChkTabDup(@cCodPad,cCodPro,::SAutProc:CodPad) .or. aErrVarVin[1] == .T.
		   	SetSoapFault( "", "De/Para não realizado para -> ("+::SAutProc:CodPad+") "+::SAutProc:CodPro )
		   	Return .F.
		EndIf
		
		BR8->(DbSetOrder(3))
		If !BR8->( MsSeek(xFilial("BR8")+AllTrim(cCodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cCodPro) ) )+cCodPad ))
			SetSoapFault( "", "Procedimento não encontrado na tabela padrao -> ("+cCodPad+") "+cCodPro )
		   	Return .F.
		EndIf

		::SAutProc:CodPad := cCodPad
		::SAutProc:CodPro := cCodPro

	Endif

	//Verifica RDA															 
    If lRetorno
    
		//Operadora do profissional												 
		BB0->( DbSetOrder(1) ) //BB0_FILIAL + BB0_CODIGO
		If BB0->( MsSeek( xFilial( "BB0" ) + cCodProf) )
		
		    If lSolict
				cOpeSol := BB0->BB0_CODOPE
			Else
				cOpeExe := BB0->BB0_CODOPE
			EndIf
			
		EndIf
		
		//Posiciona no local e verifica se e para tratar o executante				 
		BB8->( MsSeek(xFilial("BB8")+cCodRda+cOpeMov+cCodLoc) )
		
		lTrtExe := Iif(BB8->BB8_TRTEXE == '1',.t.,.f.)
		
		//Pega a Rda do Profissional												 
		BAU->( DbSetOrder( 5 ) ) //BAU_FILIAL + BAU_CODBB0
		If BAU->( MsSeek( xFilial("BAU")+cCodProf ) )
			cRdaProf := BAU->BAU_CODIGO
		EndIf
		
		//Rda contratada diference da rda do profissional							 
		lRdaProf := ( cCodRda <> cRdaProf .and. ! Empty(cRdaProf) )

		//Procura o Local	no profissional											 
		lEntrou := .F.
		
		If ! Empty(cRdaProf) .and. ! Empty(::SAutProc:EndCon) .and. lRdaProf .and. lTrtExe 
			
			If nInd1 == 0
				nIndUt := PLSBUIND("BB8","BB8_FILIAL + BB8_TIPLOG + BB8_CEP + BB8_NR_END + BB8_EST + BB8_CODIGO + BB8_CODINT") /// Busca da Ordem do indice pela descrição
				nInd1  := nIndUt
			Endif
			
			BB8->( DbSetOrder(nInd1) )//BB8_FILIAL + BB8_TIPLOG + BB8_CEP + BB8_NR_END + BB8_EST + BB8_CODIGO + BB8_CODINT                                          //sempre procuro um local na rda que eu vou gerar a guia
			If BB8->( MsSeek( xFilial("BB8") + ::SAutProc:EndCon + cRdaProf + cOpeMov ) )
			
				while  !BB8->(Eof()) .and. BB8->(BB8_FILIAL+BB8_TIPLOG+BB8_CEP+BB8_NR_END+BB8_EST+BB8_CODIGO+BB8_CODINT) == ;
										    xFilial("BB8")+::SAutProc:EndCon + cRdaProf + cOpeMov
			
					if empty(BB8->BB8_DATBLO)
						lEntrou := .t.
						cCodLoc := BB8->BB8_CODLOC
						exit
					endIf
					
				BB8->(dbSkip())
				enddo
				
				If !lEntrou
				
					cCodLoc := ""

					FWLogMsg('WARN',, 'SIGAPLS', funName(), '', '01',"RDA Prof. " + cRdaProf + " - Local de Atendimento não encontrado com base no Endereço -> ( " + ::SAutProc:EndCon + "-" + cRdaProf + "-" + cOpeMov + " )" , 0, 0, {})
				
				endIf
				
			else
				
				cCodLoc := ""
				FWLogMsg('WARN',, 'SIGAPLS', funName(), '', '01',"RDA Prof. " + cRdaProf + " - Local de Atendimento não encontrado com base no Endereço -> ( " + ::SAutProc:EndCon + "-" + cRdaProf + "-" + cOpeMov + " )" , 0, 0, {})
			
			endIf
			
		endIf
		
		//Verifica se vai checar a rda contratada ou a do profissional			 
		If lRdaProf .and. ( lTrtExe .And. lSolict ) .And. lFiltPRF
			cCodRda := cRdaProf
		endIf

		if lSolict
			cEspSol := cCodEsp
		else
			cEspExe := cCodEsp
		endIf
		
		//Tratamento para Rda														 
		aRet := PLSDADRDA(cOpeMov,cCodRda,"1",::SAutProc:DatPro,cCodLoc,cCodEsp,::SAutProc:CodPad,::SAutProc:CodPro,nil,nil,cEspSol,cEspExe)
		
		if aRet[1]
		   aDadRda := PLSGETRDA()
		else
		   
		   lRetorno := .F.
		   
		   for nI := 1 to len(aRet[2])
		       cMsg += aRet[2,nI,1] + " - " + allTrim(aRet[2,nI,2]) + Iif( nI != 1, " - " + allTrim(aRet[2,nI,3]),"") + chr(13) + chr(10)
		   next
		   
		   setSoapFault( "", cMsg )
		   
		endIf
		
	endIf
	
	//Verifica Usr															 
	if lRetorno

	 	::SAutProc:Matric:= PPLTROMAT(::SAutProc:Matric)  
	
		//Dados do usuario														 
		aRet := PLSDADUSR(::SAutProc:Matric,cTipo,.F.,::SAutProc:DatPro,Nil,Nil,Nil)
	
		if aRet[1]
			aDadUsr := PLSGETUSR()
		else
	
			lRetorno := .F.
			for nI := 1 to len(aRet[2])
			    cMsg += aRet[2,nI,1] + " - " + allTrim(aRet[2,nI,2]) + Iif( nI != 1," - " + allTrim(aRet[2,nI,3]),"") + chr(13) + chr(10)
			next
			
			SetSoapFault( "", cMsg)
		endIf
		
	endIf
	
	//Verifica se alcancou o limite de itens PTU Online				     	 
	If lRetorno .and. aDadUsr[45] <> PlsIntPad() .and. allTrim(GetNewPar("MV_PLSUNI","1")) == "1" .and. len(aQtdBrw) >= nLimitePTU
	
		if aScan(aQtdBrw,{|x| alltrim(x[1]) == alltrim(::SAutProc:CodPad) .and. alltrim(x[2]) == alltrim(::SAutProc:CodPro) }) == 0
		 	lRetorno := .F.
		 	cMsg += "O limite para solicitações PTU Online é de "+Alltrim(Str(nLimitePTU))+" itens. "+Chr(13)+Chr(10)
		 	SetSoapFault( "", cMsg)
		EndIf
		
	EndIf
	
	//Verifica se pode fazer a autorizacao									 
	If lRetorno

		//Recno do BD6															 
		If ! lSolict .AND. ! lDigGui 
	        
	        BD6->( DbSetOrder(6) ) //BD6_FILIAL + BD6_CODOPE + BD6_CODLDP + BD6_CODPEG + BD6_NUMERO + BD6_ORIMOV + BD6_CODPAD + BD6_CODPRO
			If BD6->( MsSeek( xFilial("BD6")+::SAutProc:ChvBD6+::SAutProc:CodPad+::SAutProc:CodPro) )
				nRecBD6 := BD6->( Recno() )
			EndIf
			
		Elseif ! lSolict .and. lDigGui .and. nRecno > 0
			
			BD5->(DbGoTo(nRecno))
			BD6->(DbsetOrder(6))
			If BD6->(MsSeek(xfilial("BD6") + BD5->(BD5_CODOPE + BD5_CODLDP + BD5_CODPEG + BD5_NUMERO + BD5_ORIMOV) + ::SAutProc:CodPad + ::SAutProc:CodPro))
				nRecBD6 := BD6->( Recno() )
			EndIf
			
		EndIf
		
		//TODO - rever o conceito solicita executa deve ser feito deintro da PLSAUTP e nao aqui.
		//se teve liberacao nao preciso mais checar as regras idade, sexo, etc etc
		If ! Empty(::SAutProc:ChavLib)
			
			BE2->(dbSetOrder(6)) 
			If BE2->(MsSeek(xFilial("BE2") + ::SAutProc:ChavLib + ::SAutProc:CodPad + ::SAutProc:CodPro))
			 
				If BE2->BE2_STATUS == "1"
			
					If ::SAutProc:DatPro < BE2->BE2_DATPRO
						
						SetSoapFault( "","A data de atendimento é anterior à data da solicitação" )
						return .F.
					EndIf
					
				EndIf
				
				If BE2->BE2_AUDITO == "0"
					lVerAud := .F.
				EndIf
			elseIf BE2->(MsSeek(xFilial("BE2") + ::SAutProc:ChavLib))
			
				If !(empTy(BE2->BE2_NRLBOR))
					lVerAud := !(PLBYEPU(PADL(::SAutProc:TipGui,2,"0"), BE2->BE2_NRLBOR, aProcAuto, ::SAutProc:CodPad, ::SAutProc:CodPro)[1])
				EndIf
			EndIf 
				
			aVldGen := {.F.,.F.,.F.,.F.,.F.,.F.,.F.,.F.,.F.,lVerAud,.F.}
			
		Endif

		If ::SAutProc:TipGui $ "2"
			cAliasCab := "BE1"
		elseIf ::SAutProc:TipGui $ "3"
			cAliasCab := "BE4"
		endIf
		
		//Checa a regra para um determinado procedimento							 
		if ::SAutProc:TipGui <> '5'
		 
			aRet := PLSAUTP(::SAutProc:DatPro,;
							::SAutProc:HorPro,;
							PADR(::SAutProc:CodPad,Len(BR8->BR8_CODPAD)),;
							PADR(::SAutProc:CodPro,Len(BR8->BR8_CODPSA)),;
							::SAutProc:QtdPro - IIF(nRecBD6 > 0 .and. lDigGui .and. nRecno > 0, BD6->BD6_QTDPRO, 0),;
							aDadUsr,;
							nRecBD6,;
							aDadRDA,;
							"1",;
							Iif(GetNewPar("MV_PLSMODA","1")=="0",.F.,.T.),;
							::SAutProc:Cid,;
							.t.,;
							"1",;
							lSolict,;
							cOpeSol,;
							::SAutProc:CdpfSo,;
							cAno,;
							cMes,;
							::SAutProc:PadInt,;
			    			::SAutProc:PadCon,;
			    			::SAutProc:RegAte,;
			    			.f.,;
			    			::SAutProc:CodExe,;
			    			NIL,;
			    			0,;
			    			cOpeExe,;
			    			NIL,;
			    			::SAutProc:AteRN,;
			                NIL,NIL,;
			                ::SAutProc:Sequen,;
			                ::SAutProc:ChavLib,;
			                .f.,;
			                "2",;
			                ::SAutProc:Face,;
			                NIL,NIL,;
			                ::SAutProc:TipPre,;
			                ::SAutProc:GrpInt,;
			                NIL,NIL,;
			                SAutProc:ChavLib,;
			                ::SAutProc:AreaAbr,;
			                NIL,NIL,;
			                ::SAutProc:Dente,;
			                NIL,NIL,;
							IiF( lSolict,.F.,lTrtExe),;
							.F.,;
							::SAutProc:TipoProc,;
							cCodEsp,;
							aQtdBrw,;
							aVldGen,;
							cCodLoc,;
							nil,;
							nil,;
							nil,;
							.T.,;
							cAliasCab,;
							::SAutProc:RegInter,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							cEspSol,;
							cEspExe,;
							nil,;
							nil,;
							iIf(!Empty(::SAutProc:TipGui),PADL(::SAutProc:TipGui,2,"0"),""),;
							::SAutProc:StProc,;
							nil,;
							.t.,;
							nil,;
							nil,;
							nil,;
							nil,;
							nil,;
							::SAutProc:ValorApr,;
							nil,;
							nil,;
							iIf(nRecBD6 > 0 .and. lDigGui .and. nRecno > 0, BD6->BD6_QTDPRO, 0))
		else
			aRet := {}
			aadd(aRet, .t.)
			lAto := .f.
		endif
		
		//Retorno															   	   
		If Len(aRet) > 0
		
			If  Len(aRet) >= 2 .AND. valtype(aRet[2]) == "A"
				lAuditoria := aScan( aRet[2],{|x| x[1] == "025" } ) > 0 
			Else
				lAuditoria := .f.
			EndIf

			//Verifica se procedimento em auditoria se enquandra na exceção cadastrada 
			//Caso esteja na exceção retira o procedimento da auditoria. 
			if ! empty(lAuditoria) .and. lAuditoria
			
				//Internação ou Resumo de Internação
				if ::SAutProc:TipGui $ "3,5" 
				
					cTpaten := PLSRetAut("3")[1]
					
				//Anexos
				elseif ::SAutProc:TipGui $ "7,8,9"
				  
					cTpaten := PLSRetAut("7")[1]
					
				else
					cTpaten := PLSRetAut()[1]
				endif
	   	  		
	     		//³B1O_CODPRO+B1O_TPGUIA+B1O_IDADE+B1O_QTDPRO
	     		if PLSVLDEX(Left( cCodPro + Space( TamSX3("B1O_CODPRO")[1] ), TamSX3("B1O_CODPRO")[1] )+cTpaten,aDadUsr[26],::SAutProc:QtdPro)
		       		
		       		If LEN(aRet[2]) == 2
			       		aRet[1] := .T.
		       			aRet[2] := {}
		       			aRet[3] := "B1O"
		       		Else
		       			aRet[2][Ascan( aRet[2],{|x| x[1] == "025" } )][2] := ""
		       		EndIf
		       		
	     		endif
	     		
			endif

		   	aCritica := IIF(Len(aRet) >= 2, aRet[2], {})

			//Separa o que é critica negativa do que é alerta
   			PLSALERTA(@aCritica,@aRet,@aAlerta)

		   ::RetAutProc			:= WsClassNew( "SMatRetAutProc" )
		   ::RetAutProc:ProAut	:= aRet[1]
		   ::RetAutProc:Nivel	:= iIf( Len(aRet) >= 3, aRet[3], "")
		   ::RetAutProc:TpProc	:= BR8->BR8_TPPROC
		   ::RetAutProc:Chave	:= iIf( Len(aRet) >= 4, aRet[4], "")
		   lAto					:= iIf( len(aRet) >= 5, aRet[5], .f. )
		   aValor 				:= iIf( len(aRet) >= 6 .and. lAto , aRet[6], {} )
	 	   ::RetAutProc:Autori	:= ""
		   ::RetAutProc:MatCri	:= {}

		   //Se foi autorizado														  
		   If aRet[1]
		   
			  	::RetAutProc:Autori := IIF( Len(aRet) >= 2, iif(valType(aRet[2])=='C',aRet[2],''), "") //BR8_AUTORI (0=Dispensa Autorizacao;1=Automatica;2=Guia Operadora;3=Auditoria;4=Guia Empresa;5=Guia Empresa/Operadora;6=Avalicao Contratual)

				//Somente guia Odontologica											   
			  	If ::SAutProc:TipGui == '4' .And. Len(aValor) == 0
			  	
					//Valor da Co-Participacao											   	   
					aValor := PLSCALCCOP(	::SAutProc:CodPad,;
											::SAutProc:CodPro,;
											cMes,;
											cAno,;
											aDadRda[02],;
											cCodEsp,;
											"",;
											cCodLoc,;
											::SAutProc:QtdPro,;
											::SAutProc:DatPro,;
											.F.,;
											"2",;
											'0',;
											::SAutProc:GrpInt,;
											aDadUsr,;
											nil,;
											nil,;
											{},;
											::SAutProc:RegAte,;
											0,;
											.T.,;
											.F.,;
											::SAutProc:HorPro,;
											NIL,;
											aDadRda[14],;
											::SAutProc:TipPre,;
											NIL,;
											NIL,;
											{},;
											::RetAutProc:Nivel,;
											::RetAutProc:Chave,;
											nil,;
											nil,;
											::SAutProc:Cid,;
											nil,;
											IIF(!Empty(::SAutProc:TipGui),PADL(::SAutProc:TipGui,2,"0"),""),; //36
											nil,;
											nil,;
											nil,;
											nil,;
											nil,;
											nil,;
											nil,;
											nil,;
											nil,;
											nil,;
											nil,;
											nil,;
											nil,;
											nil,;
											nil,;
											nil,;
											nil,;
											nil,;
											nil,;
											nil,;
											nil,;
											::SAutProc:Dente,;
											::SAutProc:Face)
				EndIf
				
				//Verifica pagamento no ato											   
				If lAto
				
					If aValor[1] .And. aValor[16] == "1" .And. If( Len(aValor)>=27, !aValor[27], .T. )
				
						If BA3->BA3_TIPOUS == "1"
							aCliente := PlBuscaClien("1","1",aDadUsr)
						Else
							aCliente := PlBuscaClien("2","1",aDadUsr)
						EndIf
				
						lAto := ( aCliente[1] .Or. ( aValor[12] > 0 .And. BR8->BR8_PODDIG == "1" ) )
				
					Else
						lAto := .F.
					EndIf
					
				EndIf

				//Alertas do procedimento
				If len(aAlerta) > 0

				  	::RetAutProc:Alerta := {}

				  	nCont := 0

				  	For nI := 1 To Len(aAlerta)

					   //Retira a informacao de nivel das criticas
					   If At('nível',Lower(aAlerta[nI,2])) > 0
					   	   Loop
					   EndIf

					   If ! Empty(aAlerta[nI,1])
						   aRetAlert := PLSRETCRI( AllTrim( aAlerta[nI,1] ),cTissVer )
					   Else
					       aRetAlert := {}
						   AaDd(aRetAlert,{"",aAlerta[nI,2]} )
					   EndIf

					   nCont++
					   AaDd( ::RetAutProc:Alerta, WsClassNew( "GenericStruct" ) )
					   ::RetAutProc:Alerta[nCont]:Code			:= Iif( Empty(aRetAlert[1,1]),"&nbsp;&nbsp;&nbsp;&nbsp;",aRetAlert[1,1] )
					   ::RetAutProc:Alerta[nCont]:Description	:= PadR( AllTrim(aRetAlert[1,2]),60 ) + Iif( !Empty( aAlerta[nI,3] ) ," ( " + AllTrim( aAlerta[nI,3] ) + " )" ,"" ) + "<br>"
					   
				    Next
				    
			    EndIf
			    
		   Else
		   
			  //Criticas																 
			  For nI := 1 To Len(aCritica)

				//Retira a informacao de nivel das criticas
				If At('nível',Lower(aCritica[nI,2])) > 0
					Loop
			  	EndIf

			    If !Empty(aCritica[nI,1])
					aRetCri := PLSRETCRI( AllTrim( aCritica[nI,1] ),cTissVer )

					If EMPTY(aRetCri[1][2])
						aRetCri[1][1] := aCritica[nI][2]
						aRetCri[1][2] := aCritica[nI][3]
					EndIf

					cCodNeg := aRetCri[1,1]
				Else
					aRetCri := {}
					AaDd(aRetCri,{"",aCritica[nI,2]} )
				EndIf

			  	nCont++
				AaDd( ::RetAutProc:MatCri, WsClassNew( "GenericStruct" ) )
				::RetAutProc:MatCri[nCont]:Code			:= Iif( Empty(aRetCri[1,1]),"&nbsp;&nbsp;&nbsp;&nbsp;",aRetCri[1,1] )
				::RetAutProc:MatCri[nCont]:Description	:= PadR( AllTrim(aRetCri[1,2]),60 ) + Iif( !Empty( aCritica[nI,3] ) ," ( " + AllTrim( aCritica[nI,3] ) + " )" ,"" ) + "<br>"
				
			  Next

			  //Alertas do procedimento
			  If len(aAlerta) > 0

		  		 ::RetAutProc:Alerta := {}

		  		 nCont := 1

		  		 AaDd( ::RetAutProc:Alerta, WsClassNew( "GenericStruct" ) )
				 
				 ::RetAutProc:Alerta[nCont]:Code	:= "<hr size='40' width='99%' align='center' noshade><br>" +;
													   "<b>Alertas do Procedimento</b> <br>"
				 ::RetAutProc:Alerta[nCont]:Description	:= "<br>"

		  		 For nI := 1 To Len(aAlerta)
		  		 
					//Retira a informacao de nivel das criticas
					If At('nível',Lower(aAlerta[nI,2])) > 0
						Loop
				  	EndIf

				    If ! Empty(aAlerta[nI,1])
						aRetAlert := PLSRETCRI( AllTrim( aAlerta[nI,1] ),cTissVer )
					Else
						aRetAlert := {}
						AaDd(aRetAlert,{"",aAlerta[nI,2]} )
					EndIf

				  	nCont++
					AaDd( ::RetAutProc:Alerta, WsClassNew( "GenericStruct" ) )
					::RetAutProc:Alerta[nCont]:Code		:= Iif( Empty(aRetAlert[1,1]),"&nbsp;&nbsp;&nbsp;&nbsp;",aRetAlert[1,1] )
					::RetAutProc:Alerta[nCont]:Description	:= PadR( AllTrim(aRetAlert[1,2]),60 ) + Iif( !Empty( aAlerta[nI,3] ) ," ( " + AllTrim( aAlerta[nI,3] ) + " )" ,"" ) + "<br>"
					
			    Next
			    
			  EndIf
			  
		   EndIf
		   
		   //Vou incluir a Primeira BE4 ou BD6 que está sendo autorizada
		   if ::SAutProc:TipGui == '5' .and. ::SAutProc:Operacao == 'I'
		   
		   		
			   	aDados := MntResDad(::SAutProc:CarSol, ::SAutProc:Rda, ::SAutProc:Cnes, ::SAutProc:CodLoc, ::SAutProc:Matric, ::SAutProc:Cbos,;
			   	 					::SAutProc:Cid, ::SAutProc:Cid2, ::SAutProc:Cid3, ::SAutProc:Cid4, ::SAutProc:Cid5, ::SAutProc:TipSai,;
			   	 					::SAutProc:TipFat, ::SAutProc:IndAci, ::SAutProc:TipInt, ::SAutProc:RegAte, ::SAutProc:NumSol, ::SAutProc:AteRN,; 
			   	 					::SAutProc:DtIniF, ::SAutProc:HrIniF, ::SAutProc:DtFimF, ::SAutProc:HrFimF, ::SAutProc:NumGuiTrc, ::SAutProc:Observ,;
			   	 					::SAutProc:PadCon, ::SAutProc:PadInt, ::SAutProc:DatPro )
			   	
		   		 								
		   		aItens := MntResIte(::SAutProc:SeqMov , ::SAutProc:CodPro, ::SAutProc:CodPad,  ::SAutProc:QtdPro ,;
		   							   iif(aRet[1] .OR. (!aRet[1] .AND. aRet[2][1][1]) == "564", ::SAutProc:QtdPro, 0) ,;
		   							   ::SAutProc:ValorApr,::SAutProc:HorIni, ::SAutProc:HorFim, ::SAutProc:ViaAc, ::SAutProc:TecUt,;
		   							   ::SAutProc:RedAcre, iif(aRet[1], "1", "0"), ::SAutProc:DatPro)		    
		   							   
		   		
		   		objCtrlGuia := CO_ResumoInter():New()
		   		
		   		if alltrim(::SAutProc:Numero) = ""
		   		 
			   		oObjGui 			:= objCtrlGuia:addGuia(aDados,aItens)
			   		::RetAutProc:NumGui := oObjGui:getCodOpe() + ";" + oObjGui:getCodLdp()  + ";" + oObjGui:getCodPeg()  + ";" + oObjGui:getNumero() 
			   		
			   	else
			   	
					if alltrim(::SAutProc:CodOpe) <> alltrim(BE4->BE4_CODOPE) .or. ;
					   alltrim(::SAutProc:CodLdp) <> alltrim(BE4->BE4_CODLDP) .or. ;
					   alltrim(::SAutProc:CodPeg) <> alltrim(BE4->BE4_CODPEG) .or. ;
					   alltrim(::SAutProc:Numero) <> alltrim(BE4->BE4_NUMERO)
				
						BE4->(dbSetOrder(1)) //BE4_FILIAL+BE4_CODOPE+BE4_CODLDP+BE4_CODPEG+BE4_NUMERO+BE4_SITUAC+BE4_FASE
						BE4->(msSeek(xFilial("BE4")+::SAutProc:CodOpe+::SAutProc:CodLdp+::SAutProc:CodPeg + left(::SAutProc:Numero, TamSx3("BE4_NUMERO")[1])))   
										
					endif			   		

			   		oObjVOGuia := objCtrlGuia:montaResInt(aDados, aItens, .F., .F., .F. )
			   		
			   		oObjVOGuia:setCodOpe(::SAutProc:CodOpe)
			   		oObjVOGuia:setTipGui("05")
			   		oObjVOGuia:setCodLdp(::SAutProc:CodLdp)
			   		oObjVOGuia:setCodPeg(::SAutProc:CodPeg)
			   		oObjVOGuia:setNumero(::SAutProc:Numero)
			   		
			   		aObjProcedimentos 	:= objCtrlGuia:getLstProcedimentos(::SAutProc:Matric, aItens, oObjVOGuia)
			   		aRetGui 			:= objCtrlGuia:incIteGuia(oObjVOGuia, aObjProcedimentos, .F.)
			   		::RetAutProc:NumGui := oObjVOGuia:getCodOpe() + ";" + oObjVOGuia:getCodLdp()  + ";" + oObjVOGuia:getCodPeg()  + ";" + oObjVOGuia:getNumero()
			   		
			   	endif
			   			   		
		   endif 		   

		   //Pega os valores do procedimento caso seja odonto ou pagamento no ato    
		   If Len(aValor) > 0
		   
			   If aValor[1]
			   
				    If Len(aValor) >= 17
						
						aRetUs  := aValor[17][1]
						
						For nI := 1 To Len(aRetUs)
						
							If Len(aRetUs[nI]) >= 9
							
								nQtdUs += aRetUs[nI,9] //US usada para calculo do evento
								
							EndIf
							
						Next
						
					EndIf
					
					nVlrCon	:= aValor[06] //Valor contratado
					nVlrTPF	:= aValor[12] //Valor Total da participacao
					
			   Endif
			   
		   EndIf
		   
		   //Resultado da matriz de retorno										  
		   For nI := 1 To Len(aMatRet)
		   
		       Do Case
		   		  
		   		  //Retorna sim ou nao para autorizacao
		          Case Lower(aMatRet[nI]) == 'cstatusaut' 	
			
			          cMatRetRes += aMatRet[nI] + ";" + Iif(aRet[1],Iif(lAto,"5","1"),"0") + "~"
				  
				  //Retorna quantidade autorizada ou negada
		          Case Lower(aMatRet[nI]) $ 'cqtdautssol,cqtdsexe,cqtdoexe,cqtdsautpro' 
			
						If aRet[1]		
			
					  		cMatRetRes += aMatRet[nI] + ";" + AllTrim(Str(::SAutProc:QtdPro)) + "~"					  
			
					  	//Critica de quantidade executada maior que solicitada
					  	//nesse caso é necessário gravar a quantidade no grid para que na confirmação da guia
					  	//o sistema possa negar o procedimento pela quantidade executada.
					  	ElseIf ! aRet[1] .and. len(aRet[2]) > 0 .and. aRet[2][1][1] $ "564,078"
			
					  		cMatRetRes += aMatRet[nI] + ";" + AllTrim(Str(::SAutProc:QtdPro)) + "~" 					  	
			
					  	ElseIf Lower(aMatRet[nI]) != "cqtdsexe"
			
					  		cMatRetRes += aMatRet[nI] + ";0~"
					  		 
					 	EndIf
				  
				  //Retorna Quantidade US
                  Case Lower(aMatRet[nI]) == 'nqtdusse' 
			          
			          cMatRetRes += aMatRet[nI] + ";" + AllTrim(Str(nQtdUs))  +"~"
				  
				  //Retorna Valor contratado
                  Case Lower(aMatRet[nI]) == 'nvlrunise' 
			          
			          cMatRetRes += iif( !empty(::SAutProc:ValorApr) .and. (::SAutProc:ValorApr > "0,00"), aMatRet[nI] + ";" + alltrim(::SAutProc:ValorApr),  aMatRet[nI] + ";" + AllTrim(Str(nVlrCon))) + "~"
				  
				  //Retorna Valor participacao
                  Case Lower(aMatRet[nI]) == 'nvlrfrpase' 
			          
			          cMatRetRes += aMatRet[nI] + ";" + AllTrim(Str(nVlrTPF)) + "~"
				  
				  //Retorna S-autorizado, N-nao autorizado
                  Case Lower(aMatRet[nI]) == 'cautse' 
			          
			          cMatRetRes += aMatRet[nI] + ";" + Iif(aRet[1],"S","N") + "~"
				  
				  //Retorna o codigo da glosa
				  Case Lower(aMatRet[nI]) == 'ccodneg' 
				  
					  cMatRetRes += aMatRet[nI] + ";" + cCodNeg + "~"
					  
		       EndCase
		       
		   Next
		   
		   //Retorna a string formatada				
	 	   ::RetAutProc:MatRetRes := cMatRetRes
		   
		   //Lembrete do Procedimento na Tabela Padrão
		   ::RetAutProc:Lembrete := "0"

			If BR8->( FieldPos("BR8_LEMBRE") ) > 0 .and. ! Empty(BR8->BR8_LEMBRE)

				If PLSLEMBRE(.F.,.T.,::SAutProc:CodPad,::SAutProc:CodPro)
					::RetAutProc:Lembrete := allTrim(BR8->BR8_LEMBRE)
				EndIf
				
			EndIf
			
		Else
			
			lRetorno := .F.
			SetSoapFault( "", "Retorno invalido na checagem do procedimento ("+::ProDad:CodPro+")" )
			
		EndIf
		
	EndIf
	
Else
	
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
	
EndIf

RestArea( aArea )

Return lRetorno


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VldHoPar   ³Autor  ³ Alexander	            ³ Data ³11.03.2010 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica item do honorario individual						   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VldHoPar WSRECEIVE UserCode, SAutProc WSSEND RetAutProc WSSERVICE PLSXFUN
	
LOCAL lRetorno 		:= .T.
Local cOpeOri := ""
Local cCodPla := ""
Local cTissVer
Local cGrPar
Local cCodPad
Local cCodPro
Local aTpPRec := {}
Local aItens := {}
Local aResult := {}
Local aPartAntigas	:= strToArray( ::SAutProc:GrpParExe , ';')
		
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "VldHoPar" )	
	
    //Posiciona na internacao														
    BE4->( DbSetOrder(2) )//BE4_FILIAL + BE4_CODOPE + BE4_ANOINT + BE4_MESINT + BE4_NUMINT
    If BE4->( MsSeek(xFilial("BE4")+::SAutProc:ChavLib) )
    
	    If aScan(  ClassDataArr(::SAutProc)  ,{|x| AllTrim(x[1]) == "TISSVER"  }) > 0
	    	cTissVer := ::SAutProc:TissVer
	    EndIf

	    //Faz os de-para das terminologias
		If cTissVer >="3"
			cGrPar		:= AllTrim(PLSVARVINC('35','BWT', ::SAutProc:GrPar))

			cCodPad := AllTrim(PLSVARVINC('87','BR4', ::SAutProc:CodPad))
			cCodPro := AllTrim(PLSVARVINC(::SAutProc:CodPad,'BR8',::SAutProc:CodPro ,cCodPad+::SAutProc:CodPro))
			::SAutProc:CodPad := cCodPad
			::SAutProc:CodPro := cCodPro

		Else
			 cGrPar := ::SAutProc:GrPar
		EndIf    

	    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	    //³ Participacao																³
	    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		AaDd( aTpPRec,{ cGrPar,;
						::SAutProc:Rda,;
						::SAutProc:NomRda,;
						::SAutProc:CodSig,;
						::SAutProc:NumCr,;
						::SAutProc:Estado,;
						Iif(Empty(::SAutProc:NomExe),::SAutProc:NomRda,::SAutProc:NomExe),;
						.T. } )

        	
    	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	    //³ Item																		³
	    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		AaDd( aItens, {	{ "SEQMOV", StrZero(Val(::SAutProc:SeqMov),TamSx3("BD6_SEQUEN")[1]) },;
						{ "CODPRO", ::SAutProc:CodPro },;
						{ "CODPAD", ::SAutProc:CodPad },;
						{ "QTD"	  , ::SAutProc:QtdPro },;
						{ "QTDAUT", ::SAutProc:QtdPro },;
						{ "VLRAPR", 0 },;
						{ "DATPRO", Date() },;
						{ "ATPPAR", aTpPRec },;
						{ "TISSVER", cTissVer } } )

		aItens[1] := WsAutoOpc( aItens[1] )
    
        
		BA1->(dbSetOrder(2))
		if BA1->(msseek(xFilial("BA1")+BE4->(BE4_CODOPE+BE4_CODEMP+BE4_MATRIC+BE4_TIPREG+BE4_DIGITO)))
			cOpeOri := BA1->BA1_OPEORI
			cCodPla := BA1->BA1_CODPLA
		endIf
			
		if(empty(cCodPla))
			BA3->(dbSetOrder(1))
			if BA3->(msseek(xFilial("BA3")+BE4->(BE4_CODOPE+BE4_CODEMP+BE4_MATRIC)))
				cCodPla := BA3->BA3_CODPLA
			endIf
		endIf

		::RetAutProc		:= WsClassNew( "SMatRetAutProc" )
			
		aResult	:= PLVLDPART(/*CToD("")*/ ::SAutProc:DatPro , BE4->BE4_CODRDA, BE4->BE4_CODESP, BE4->BE4_SUBESP, BE4->BE4_CODLOC, BE4->BE4_LOCAL, cOpeOri, cCodPla, aItens, aPartAntigas)
		::RetAutProc:ProAut	   := aResult[1]
		::RetAutProc:MatRetRes := aResult[2]
		
	Else
		lRetorno := .F.
		SetSoapFault( "", "Nenhuma guia encontrada ( "+Transform( ::SAutProc:ChavLib, "@R 9999.9999.99.99999999" )+" )" )
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VldHoIn   ³Autor  ³ Alexander	            ³ Data ³11.03.2010 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica item do honorario individual						   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VldHoIn WSRECEIVE UserCode, SAutProc WSSEND RetAutProc WSSERVICE PLSXFUN
LOCAL nI		 	:= 0
LOCAL lRetorno 		:= .T.
LOCAL aItens		:= {}
LOCAL aTpPRec		:= {}
LOCAL aCriticas 	:= {}
LOCAL aMatBD6		:= {}
LOCAL aRet			:= {}
LOCAL aArea    	 	:= GetArea()
LOCAL cTissver	:= ""
LOCAL cOpeOri		:= ""
LOCAL cCodPla		:= ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "VldHoIn" )
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³ Posiciona na internacao														³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    BE4->( DbSetOrder(2) )//BE4_FILIAL + BE4_CODOPE + BE4_ANOINT + BE4_MESINT + BE4_NUMINT
    If BE4->( MsSeek(xFilial("BE4")+::SAutProc:ChavLib) )

	    If aScan(  ClassDataArr(::SAutProc)  ,{|x| AllTrim(x[1]) == "TISSVER"  }) > 0 .AND. ValType(::SAutProc:TissVer) <> 'U'
	    	cTissVer := ::SAutProc:TissVer
	    EndIf

	    //Faz os de-para das terminologias
		If cTissVer >="3"
			cGrPar		:= AllTrim(PLSVARVINC('35','BWT', ::SAutProc:GrPar))

			cCodPad := AllTrim(PLSVARVINC('87','BR4', ::SAutProc:CodPad))
			cCodPro := AllTrim(PLSVARVINC(::SAutProc:CodPad,'BR8',::SAutProc:CodPro ,cCodPad+::SAutProc:CodPro))
			::SAutProc:CodPad := cCodPad
			::SAutProc:CodPro := cCodPro

		Else
			 cGrPar := ::SAutProc:GrPar
		EndIf

	    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	    //³ Participacao																³
	    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		AaDd( aTpPRec,{ cGrPar,;
						::SAutProc:Rda,;
						::SAutProc:NomRda,;
						::SAutProc:CodSig,;
						::SAutProc:NumCr,;
						::SAutProc:Estado,;
						Iif(Empty(::SAutProc:NomExe),::SAutProc:NomRda,::SAutProc:NomExe),;
						.T. } )

	    If aScan(  ClassDataArr(::SAutProc)  ,{|x| AllTrim(x[1]) == "TISSVER"  }) > 0
	    	cTissVer := ::SAutProc:TissVer
	    EndIf

	    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	    //³ Item																		³
	    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		AaDd( aItens, {	{ "SEQMOV", StrZero(Val(::SAutProc:SeqMov),TamSx3("BD6_SEQUEN")[1]) },;
						{ "CODPRO", ::SAutProc:CodPro },;
						{ "CODPAD", ::SAutProc:CodPad },;
						{ "QTD"	  , ::SAutProc:QtdPro },;
						{ "QTDAUT", ::SAutProc:QtdPro },;
						{ "VLRAPR", 0 },;
						{ "DATPRO", Date() },;
						{ "ATPPAR", aTpPRec },;
						{ "TISSVER", cTissVer } } )

		aItens[1] := WsAutoOpc( aItens[1] )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta aMatBD6															 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nI:=1 To Len(SAutProc:MATBD6)
		     AaDd(aMatBD6,{	SAutProc:MATBD6[nI]:seqinf,;
							SAutProc:MATBD6[nI]:sequen,;
							SAutProc:MATBD6[nI]:codpad,;
							SAutProc:MATBD6[nI]:codpro,;
							SAutProc:MATBD6[nI]:qtdpro,;
							SAutProc:MATBD6[nI]:orimov,;
							SAutProc:MATBD6[nI]:procci,;
							SAutProc:MATBD6[nI]:recno,;
							SAutProc:MATBD6[nI]:denreg,;
							SAutProc:MATBD6[nI]:fadent,;
							SAutProc:MATBD6[nI]:datpro } )
		Next
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Valida procedimento do Honorario Individual								 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		BA1->(dbSetOrder(2))
		if BA1->(msseek(xFilial("BA1")+BE4->(BE4_CODOPE+BE4_CODEMP+BE4_MATRIC+BE4_TIPREG+BE4_DIGITO)))
			cOpeOri := BA1->BA1_OPEORI
			cCodPla := BA1->BA1_CODPLA
		endIf
		
		if(empty(cCodPla))
			BA3->(dbSetOrder(1))
			if BA3->(msseek(xFilial("BA3")+BE4->(BE4_CODOPE+BE4_CODEMP+BE4_MATRIC)))
				cCodPla := BA3->BA3_CODPLA
			endIf
		endIf
		
		aRet := PLVLDRESHO(BE4->(BE4_CODOPE+BE4_CODLDP+BE4_CODPEG+BE4_NUMERO),"2"/*"1"*/,"2",;
						   BE4->BE4_DTALTA,BE4->BE4_TIPFAT,.T.,;
						   BE4->(BE4_CODOPE+BE4_CODEMP+BE4_MATRIC+BE4_TIPREG+BE4_DIGITO),"2",;
				   		   "","","",::SAutProc:DatPro,aItens,aMatBD6,{},{},aCriticas,nil,nil,nil,;
				   		   BE4->BE4_CODRDA, BE4->BE4_CODESP, BE4->BE4_SUBESP, BE4->BE4_CODLOC, BE4->BE4_LOCAL, cOpeOri, cCodPla, .T. )
				   		   
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Retorno															   	   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   	::RetAutProc		:= WsClassNew( "SMatRetAutProc" )
	   	::RetAutProc:ProAut	:= .T.
	   	::RetAutProc:PosBD6	:= aRet[2]
	   	::RetAutProc:SeqInf	:= aRet[3]
	   	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	   	//³Se foi autorizado													   ³
	   	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   	If (aRet[1] == .F. .And. Len(aCriticas) == 0) //Pode ocorrer do usuário trocar o código da tabela ou procedimento para um inexistente e o sistema não criticava e dava errorlog. Controle realizado para esta situação.
	   		lRetorno := .F.
			SetSoapFault( "", "De/Para não existente ou códigos inválidos de tabela e procedimento.<br>Revise os dados." )	
		EndIf
	   	If Len(aCriticas) > 0
		   	::RetAutProc:ProAut	:= .F.
		   	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		   	//³Processar criticas retornadas										   ³
		   	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		   	::RetAutProc:MatCri	:= {}
			For nI:=1 To Len(aCriticas)

				If !Empty(aCriticas[nI,1])
					aRetCri := PLSRETCRI( AllTrim( aCriticas[nI,2] ) )

					If EMPTY(aRetCri[nI][2])
						aRetCri[1][1] := aCriticas[nI][2]
						aRetCri[1][2] := aCriticas[nI][3]
					EndIf
				Else
					aRetCri := {}
					AaDd(aRetCri,{"",aCriticas[nI,2]} )
				EndIf

				AaDd( ::RetAutProc:MatCri, WsClassNew( "GenericStruct" ) )
				::RetAutProc:MatCri[nI]:Code 		:= Iif( Empty(aRetCri[1,1]),"&nbsp;&nbsp;&nbsp;&nbsp;",aRetCri[1,1] )
				::RetAutProc:MatCri[nI]:Description	:= PadR( AllTrim(aRetCri[1,2]),60 ) + "<br>"
			Next
	   	EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Nenhuma guia encontrada ( "+Transform( ::SAutProc:ChavLib, "@R 9999.9999.99.99999999" )+" )" )
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim do Metodo														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    VldBTQChv ³Autor  ³ Daher		            ³ Data ³06.04.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os dados da liberacao pelo numero da liberacao	   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VldBTQChv WSRECEIVE UserCode, Chave, cOpcao,cCheckDePara WSSEND MatGuia WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL cSQL			:= ""
LOCAL cAlias      	:= "BTQ"

If PrtChkUser( ::UserCode, "PLSXFUN", "RetAut" ) //consome uma licença, checa integridade d acesso

	cSql := "SELECT R_E_C_N_O_ RECNE,BTQ_DESTER DESCRI"
	cSql += " FROM " + RetSQLName(cAlias)
	cSql += " WHERE " + cAlias + "_FILIAL = '" + xFilial(cAlias) + "' AND BTQ_VIGDE <= '" + DTOS(dDataBase) + "' "
	cSql += " AND BTQ_CODTAB ='" + ::cOpcao  + "'"
	cSql += " AND BTQ_CDTERM LIKE '" + ::Chave + "%' "
	cSql += " AND D_E_L_E_T_ = '' "
	PlsQuery(cSql,'TrbSql')
	
	::MatGuia:SCabGui					:= WsClassNew( "MCabGui" )
	::MatGuia:SCabGui:obs				:= ""
	If !TrbSql->(Eof()) .and. TrbSql->RECNE > 0
		BTU->(DbSetOrder(5)) //BTU_FILIAL, BTU_CODTAB, BTU_CDTERM, BTU_ALIAS
		If cCheckDePara == '1' .and. !BTU->(MsSeek(xFilial("BTU")+::cOpcao+padr(::Chave, tamsx3("BTU_CDTERM")[1])))
			lRetorno := .F.
			TrbSql->(DbCloseArea())
			SetSoapFault( "", "Tabela de terminologia ["+::cOpcao+"] nao contem o de-para para o termo ["+::Chave+"]. Entre em contato com a sua operadora." )
		Else
			lRetorno := .T.
			::MatGuia:SCabGui:obs				:= UPPER(ALLTRIM(TrbSql->DESCRI))
			TrbSql->(DbCloseArea())
		Endif
    Else
		lRetorno := .F.
		TrbSql->(DbCloseArea())
		SetSoapFault( "", "Nao encontrada nenhuma referencia para o codigo informado" )
    EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    RetBTQChv ³Autor  ³ Roberto	            ³ Data ³06.04.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os dados da BTQ de acordo com a tabela e data.	   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RetBTQChv WSRECEIVE UserCode, Chave WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL cSQL			:= ""
LOCAL cAlias      	:= "BTQ"

If PrtChkUser( ::UserCode, "PLSXFUN", "RetBTQChv" ) //consome uma licença, checa integridade de acesso

	cSql := "SELECT BTQ_CDTERM CDTERM,BTQ_DESTER DESCRI"
	cSql += " FROM " + RetSQLName(cAlias)
	cSql += " WHERE " + cAlias + "_FILIAL = '" + xFilial(cAlias) + "'"// AND BTQ_VIGDE <= '" + DTOS(dDataBase) + "' "

	cSQL += " AND ( '"+dtos(dDataBase)+"' >= BTQ_VIGDE ) AND "
	cSQL += "     (( '"+dtos(dDataBase)+"' <= BTQ_VIGATE OR BTQ_VIGATE = '' ) OR ( BTQ_VIGDE = '' AND BTQ_VIGATE = '' )) "

	cSql += " AND BTQ_CODTAB ='" + ::Chave  + "'"
	cSql += " AND D_E_L_E_T_ = '' "

	cQuery	:= ChangeQuery(cSql)
	TcQuery cQuery New Alias "TabTmp"

	::WSNULL := ""

	While !TabTmp->(Eof())
		::WSNULL += alltrim(TabTmp->CDTERM) + ";" + alltrim(TabTmp->DESCRI) + "#"
		TabTmp->(DbSkip())
	Enddo

	TabTmp->(DBCLOSEAREA())

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RetSerPct ³Autor  ³ Roberto	Vanderlei     ³ Data ³07.05.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os dados dos serviços que compoem algum pacote	   	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RetSerPct WSRECEIVE UserCode, UserCardNumber, NumAut, TipoAut, RDACode, CodLoc, Tipo, CodEsp, SetDtInt, Altera WSSEND IteGui WSSERVICE PLSXFUN

	Local cMatric
	Local nI
	Local nP

	local cCodPro
	local cProcedimento

	PRIVATE aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB", .F. ,"87"))

	cMatric := PPLTROMAT(UserCardNumber)

	aRetorno := PLSRETAULI(cMatric,::NumAut,::TipoAut,::RDACode,::CodLoc,::CodEsp,,,,,,::Tipo,,,::Altera)

   	For nI := 1 To Len(aRetorno[4])

   		cCodPro := aRetorno[4,nI,4]

   		cCondicao := {|| BLE->BLE_FILIAL == xFilial("BLE") .And. ;
	                 AllTrim(BLE->BLE_CODOPC) == alltrim(cCodPro) .And. BLE->BLE_TIPO == "9" .And. ;
	                 BLE->BLE_VIGDE <= DDATABASE .And. (Empty(BLE->BLE_VIGATE) .Or.  DDATABASE <= BLE->BLE_VIGATE) }

		BLE->(DbSetOrder(1))
		BLE->(DbSetFilter(cCondicao,""))
		BLE->(DbGoTop())

		/*if !BLE->(EOF())
			::WSNULL += "true|"
		endif*/

		//while !BLE->(EOF())

		if !BLE->(EOF())
			nP := 1
			AaDd(::IteGui, WsClassNew( "MIteGui" ) )
			::IteGui[nI]:TpServ 	:= aRetorno[4,nI,1]
			::IteGui[nI]:Sequencia	:= aRetorno[4,nI,2]

			dbSelectArea("BAU")
			dbSetOrder(1)
			dbSeek(xFilial("BAU") + aRetorno[3,1])

			If BAU->BAU_TISVER >= "3"
				cPadBkp 	:= PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  aRetorno[4,nI,3],.T.)

			   	::IteGui[nI]:CodPro 	:= PLSGETVINC("BTU_CDTERM", "BR8", .F., ::IteGui[nI]:CodPad,  Alltrim(aRetorno[4,nI,3]+aRetorno[4,nI,4]), .F. ,aTabDup, @cPadBkp)
			   	::IteGui[nI]:CodPad := cPadBkp
			   	::IteGui[nI]:DesPro 	:= PLSGETVINC("BTQ_DESTER", "BR8", .F., ::IteGui[nI]:CodPad,  Alltrim(aRetorno[4,nI,3]+aRetorno[4,nI,4]))
			   	::IteGui[nI]:CodPro_Ori := aRetorno[4,nI,4]
			Else

			 	::IteGui[nI]:CodPad 	:= aRetorno[4,nI,3]
				::IteGui[nI]:CodPro 	:= aRetorno[4,nI,4]
				::IteGui[nI]:DesPro 	:= aRetorno[4,nI,5]

			Endif

			::IteGui[nI]:QtdSol 	:= aRetorno[4,nI,6]
			::IteGui[nI]:QtdAut 	:= aRetorno[4,nI,7]

			::IteGui[nI]:SPctIteGui := {}

			while !BLE->(EOF())


				AaDd(::IteGui[nI]:SPctIteGui, WsClassNew( "MPctIteGui" ) )
				cProcedimento := Posicione("BLD",3,xFilial("BLD")+BLE->BLE_CPADOC+BLE->BLE_CODPRO,"BLD_DESPRO")



				::IteGui[nI]:SPctIteGui[nP]:CodPad := alltrim(BLE->BLE_CODPAD)
				::IteGui[nI]:SPctIteGui[nP]:CodPro := alltrim(BLE->BLE_CODPRO)
				::IteGui[nI]:SPctIteGui[nP]:DesPro := alltrim(cProcedimento)

				nP += 1
				BLE->(DbSkip())
			enddo
		endif
    Next

	lRetorno := .T.
return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RetAutLib ³Autor  ³ Alexander	            ³ Data ³06.04.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os dados da liberacao pelo numero da liberacao	   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RetAutLib WSRECEIVE UserCode, UserCardNumber, NumAut, TipoAut, RDACode, CodLoc, Tipo, CodEsp, SetDtInt, Pacotes, Altera, TipGui, DigiGui, DatGuia, cOpcao WSSEND MatGuia WSSERVICE PLSXFUN
LOCAL nI                    := 0
LOCAL nP                    := 0
LOCAL nPct 					:= 0
LOCAL lRetorno 	 			:= .T.
LOCAL lInc					:= .F.
LOCAL aRet					:= {}
LOCAL aRetorno	 			:= {}
LOCAL aArea					:= GetArea()
LOCAL cMatric				:= ""
LOCAL lContinua			:= .t.
LOCAL cTissVer				:= PLSTISSVER(::RDACode)//passo como parametro a RDA que esta logada
LOCAL aTpProcs			:= RetSx3Box( X3CBox( Posicione('SX3',2,'BR8_TPPROC','X3_CBOX') ),,,1 )
LOCAL nPosTpProc			:= 0
local lItemPct 	:= .F.
local cProcedimento := ""
local cCodProcedimento := ""
local aPacotes
local cCodProc
local cCodPad
local aCampos
local cTpAlt
local cDatAtd			:= ""
local lDtSeInt       := GetNewPar("MV_DTSEINT",.F.)

PRIVATE aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB", .F. ,"87"))
DEFAULT ::UserCardNumber	:= ""
DEFAULT ::NumAut		 	:= ""
DEFAULT ::TipoAut			:= "0"
DEFAULT ::RDACode			:= ""
DEFAULT ::CodLoc			:= ""
DEFAULT ::Tipo			:= "0"
DEFAULT ::CodEsp			:= ""
DEFAULT ::SetDtInt			:= "0"
DEFAULT ::Pacotes	:= {}
DEFAULT ::TipGui := ""
DEFAULT ::DigiGui := ""
DEFAULT ::DatGuia := ""
DEFAULT ::cOpcao	:= "0"

//TISS 2.2 - Requisitos minimos é a existencia da tabela BRI e a existencia da função PLSRETLDP
If ! ( PLSALIASEX("BRI") .And. FindFunction("PLSRETLDP") )
	lRetorno	  := .F.
	SetSoapFault( "","Necessário atualizar pacote da TISS 2.2 para se utilizar esta funcionalidade.")
	RestArea( aArea )
	Return lRetorno
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "RetAutLib" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se e Usuário de intercambio e pega a matricula original		   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cMatric := PPLTROMAT(::UserCardNumber)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Ponto de entrada para validar a liberacao informada
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	if existblock("PL90VLDLIB")
		aRetorno	:=  execBlock("PL90VLDLIB",.F.,.F.,{::NumAut,.t.})
		lContinua	:= aRetorno[1]
	endIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Retorna dados da Internacao - formulario de internacao/data internacao  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if lContinua
		aRetorno := {} //Reinicia array caso esteja utilizando PE PL90VLDLIB
		if ::cOpcao == "1"
			cDatAtd := ::DatGuia
		endif
			
		If ::Tipo == '3' .OR. ::Tipo == '11' .OR. ::Tipo == '6'
			
			BE4->(dbsetorder(2))
			If BE4->(MsSeek(xFilial("BE4") + ::NumAut))
				
				If BE4->BE4_SITUAC == "2"
					lRetorno := .F.
					SetSoapFault( "", "A guia digitada está cancelada" )
					
				ElseIf BE4->BE4_STATUS == "6"
					lRetorno := .F.
					SetSoapFault( "", "Guia em análise pela auditoria" )
					
				ElseIf BE4->BE4_STATUS == "3"
					lRetorno := .F.
					SetSoapFault( "", "A guia digitada não foi autorizada" )
					
				ElseIf ::Tipo == '6' .AND. Empty(BE4->BE4_DATPRO)
					lRetorno := .F.
					SetSoapFault( "", "A data de Internação ainda não foi informada pelo prestador. Não será possível continuar." )
				EndIf
				
				If (!empty(::RDACode) .and.  ::Tipo == '11') .or. (!empty(::RDACode) .and. ::Tipo == '3' .and. ::SetDtInt = '1')
					if !(BE4->BE4_CODRDA $ ::RDACode)
						lRetorno := .F.
						SetSoapFault( "", "A guia informada pertence a outro prestador." )
					Else
						If ::Tipo == '11' .And. lDtSeInt
							If Empty(BE4->BE4_DATPRO)
								SetSoapFault( "", "Data de internação nao informada!" )
								lRetorno := .F.															
							EndIf
						EndIf		
                  EndIf    
				Endif
				
			EndIf
			
			If !lRetorno
				Return lretorno
			EndIf
			aRetorno := PLSDADINT(::NumAut,,::TipoAut, ::Tipo)
			
			//Retorna dados do Honorario Medico
		ElseIf ::Tipo == '5'
			
			aRetorno := PLSDADHON(::NumAut)
			
			//Retorna dados dos Anexos
		ElseIf ::Tipo $ '7,8,9'
			
			PLA09ALIB(::NumAut,.T.,aRetorno, ::RDACode)
			
			//Retorna uma liberacao se existir para este Usuário 					   ³
			//Vai ter que ser ajustado para checar se pode executar ou nao somente    ³
			//quando selecionar o executante. (Caso onde a clinica e Juridica e tem   ³
			//corpo clinico. (Contratado diferente de profissional)				   ³
		Else
			BEA->(dbsetorder(1))
			If BEA->(MsSeek(xFilial("BEA")+::NumAut))
				
				If BEA->BEA_LIBERA == "0"
					
					lRetorno := .F.
					SetSoapFault( "", "O número digitado não é de uma liberação." )
					
				ElseIf AllTrim(BEA->(BEA_OPEUSR+BEA_CODEMP+BEA_MATRIC+BEA_TIPREG+BEA_DIGITO)) <> UserCardNumber .And. AllTrim(BEA->(BEA_OPEUSR+BEA_CODEMP+BEA_MATRIC+BEA_TIPREG+BEA_DIGITO)) <> cMatric
					
					lRetorno := .F.
					SetSoapFault( "", "Esta guia não corresponde ao beneficiário selecionado" )
					
				ElseIf BEA->BEA_CANCEL == '1'
					
					lRetorno := .F.
					SetSoapFault( "", "A guia digitada está cancelada")
					
				ElseIf BEA->BEA_STATUS == '3'
					
					lRetorno := .F.
					SetSoapFault( "", "A guia digitada não foi autorizada")
					
				ElseIf BEA->BEA_STALIB == "2"
					
					lRetorno := .F.
					SetSoapFault( "", "Liberação não possui saldo para execução")
				EndIf
				
				If !lRetorno
					Return lretorno
				EndIf
			EndIf
			
			aRetorno := PLSRETAULI(cMatric,::NumAut,::TipoAut,::RDACode,::CodLoc,::CodEsp,,,,,,::Tipo,,,::Altera,cDatAtd )
			
		endIf
		
	endIf
	
	//Verifica o Retorno
	If aRetorno[1]
		
		if (::TipGui == "6")
			
			if !empty(::DatGuia)
				
				if !empty(aRetorno[3,70]) .and.  aRetorno[3,70] < CTOD(::DatGuia)
					lRetorno := .F.
					SetSoapFault( "", "A internação está com a data de alta anterior a data de atendimento informada, não será possível incluir honorário." )
					return lRetorno
				EndIf
				
				if  aRetorno[3,69] > CTOD(::DatGuia)
					lRetorno := .F.
					SetSoapFault( "", "A data de atendimento esta anteior a data de inclusão da solicitação de internação, não será possível incluir honorário." )
					return lRetorno
				EndIf
				
			endIf
			
			if ::UserCardNumber <> aRetorno[3,39]
				lRetorno := .F.
				SetSoapFault( "", "A solicitação de internação informada pertence a outra matrícula." )
				return lRetorno
			endif
			
		endIf
		
		If (cTissVer >= '3')
			if ::Tipo = '3'
				cCarSol := alltrim(PLSGETVINC("BTU_CDTERM", "BDR", .F., "23", AllTrim(aRetorno[3,92])))
			else
				If Len(aRetorno[3]) > 91 .and. Len(aRetorno[3]) <= 97
					cCarSol := alltrim(PLSGETVINC("BTU_CDTERM", "BDR", .F., "23", AllTrim(aRetorno[3,91])))
				Else
					cCarSol := alltrim(PLSGETVINC("BTU_CDTERM", "BDR", .F., "23", AllTrim(aRetorno[3,22])))
				Endif
			endif
		Else
			cCarSol := AllTrim(aRetorno[3,22])
		Endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cabecalho															   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MatGuia:SCabGui					:= WsClassNew( "MCabGui" )
		::MatGuia:SCabGui:Rda				:= aRetorno[3,1]
		::MatGuia:SCabGui:RegAns			:= aRetorno[3,2]
		::MatGuia:SCabGui:NomeRda			:= aRetorno[3,3]
		::MatGuia:SCabGui:CnpjCpfSol 		:= aRetorno[3,4]
		::MatGuia:SCabGui:CnesSol      		:= aRetorno[3,5]
		::MatGuia:SCabGui:TpLograd			:= aRetorno[3,6]
		::MatGuia:SCabGui:Endereco			:= aRetorno[3,7]
		::MatGuia:SCabGui:Numero			:= aRetorno[3,8]
		::MatGuia:SCabGui:Complemento		:= aRetorno[3,9]
		::MatGuia:SCabGui:Municipio			:= aRetorno[3,10]
		::MatGuia:SCabGui:Bairro			:= aRetorno[3,11]
		::MatGuia:SCabGui:Estado			:= aRetorno[3,12]
		::MatGuia:SCabGui:IBGE				:= aRetorno[3,13]
		::MatGuia:SCabGui:Cep				:= aRetorno[3,14]
		::MatGuia:SCabGui:Tel   			:= aRetorno[3,15]
		::MatGuia:SCabGui:DtAut				:= aRetorno[3,16]
		::MatGuia:SCabGui:HrAut				:= aRetorno[3,17]
		::MatGuia:SCabGui:Senha				:= aRetorno[3,18]
		::MatGuia:SCabGui:DtValid			:= aRetorno[3,19]
		::MatGuia:SCabGui:DtSolicit			:= aRetorno[3,20]
		::MatGuia:SCabGui:HrSolicit			:= aRetorno[3,21]
		::MatGuia:SCabGui:CarSolicit		:= cCarSol
		::MatGuia:SCabGui:Cid				:= aRetorno[3,23]
		::MatGuia:SCabGui:ProSol			:= aRetorno[3,24]
		::MatGuia:SCabGui:OpeSol			:= aRetorno[3,25]
		::MatGuia:SCabGui:NomeSol			:= aRetorno[3,26]
		::MatGuia:SCabGui:CodSigSol			:= aRetorno[3,27]
		::MatGuia:SCabGui:NumCrSol			:= aRetorno[3,28]
		::MatGuia:SCabGui:EstSigSol			:= aRetorno[3,29]
		::MatGuia:SCabGui:CbosSol			:= aRetorno[3,30]
		::MatGuia:SCabGui:DescCbosSol		:= aRetorno[3,31]
		::MatGuia:SCabGui:ProExe			:= aRetorno[3,32]
		::MatGuia:SCabGui:OpeExe			:= aRetorno[3,33]
		::MatGuia:SCabGui:NomeExe			:= aRetorno[3,34]
		::MatGuia:SCabGui:CodSigExe			:= aRetorno[3,35]
		::MatGuia:SCabGui:NumCrExe			:= aRetorno[3,36]
		::MatGuia:SCabGui:EstSigExe			:= aRetorno[3,37]
		::MatGuia:SCabGui:Obs				:= aRetorno[3,38]
		::MatGuia:SCabGui:Matric			:= iif(::Tipo <> '11' .and. !empty(cMatric) .and. aRetorno[3,39]<>cMatric,cMatric,aRetorno[3,39])
		::MatGuia:SCabGui:NomeUsr			:= aRetorno[3,40]
		::MatGuia:SCabGui:STAut				:= aRetorno[3,41]
		::MatGuia:SCabGui:IndCli			:= aRetorno[3,42]
		::MatGuia:SCabGui:Origem			:= aRetorno[3,43]
		::MatGuia:SCabGui:ChvBD6			:= aRetorno[3,44]
		::MatGuia:SCabGui:TipAto			:= aRetorno[3,45]
		::MatGuia:SCabGui:TipFat			:= aRetorno[3,46]
		::MatGuia:SCabGui:NumImp			:= aRetorno[3,47]
		
		If Len(aRetorno[3]) == 96 //Retorno para internação
			::MatGuia:SCabGui:CodLoc			:= aRetorno[3,95]
			
			If (cTissVer >= '3')
				cTpAlt := alltrim(PLSGETVINC("BTU_CDTERM", "BIY", .F., "39", AllTrim(aRetorno[3,96])))
				::MatGuia:SCabGui:TipAut			:= cTpAlt
			else
				::MatGuia:SCabGui:TipAut			:= AllTrim(aRetorno[3,96])
			endif
			
			If ValType(::MatGuia:SCabGui:TipAut) <> "C"
				::MatGuia:SCabGui:TipAut := ""
			EndIf
		Endif
		
		//Numero de Auxiliares
		if Len(aRetorno) > 6
			::MatGuia:SCabGui:NumAux := Alltrim(STR(aRetorno[7]))
		else
		    ::MatGuia:SCabGui:NumAux := ""
		endif
		
		If Len(aRetorno[3]) > 96 //Retorno SADT
			
			If (cTissVer >= '3')
				cTpAlt := alltrim(PLSGETVINC("BTU_CDTERM", "BIY", .F., "39", AllTrim(aRetorno[3,96])))
				::MatGuia:SCabGui:TipAut			:= cTpAlt
			else
				::MatGuia:SCabGui:TipAut			:= AllTrim(aRetorno[3,96])
			endif
			
			If BEA->(FieldPos("BEA_DTRLZ"))>0 .and. !Empty(aRetorno[3,89])
				::MatGuia:SCabGui:DtRlz			:= dToc(aRetorno[3,89])
				::MatGuia:SCabGui:DtRlz2			:= dToc(aRetorno[3,90])
				::MatGuia:SCabGui:DtRlz3			:= dToc(aRetorno[3,91])
				::MatGuia:SCabGui:DtRlz4			:= dToc(aRetorno[3,92])
				::MatGuia:SCabGui:DtRlz5			:= dToc(aRetorno[3,93])
				::MatGuia:SCabGui:DtRlz6			:= dToc(aRetorno[3,94])
				::MatGuia:SCabGui:DtRlz7			:= dToc(aRetorno[3,95])
				::MatGuia:SCabGui:DtRlz8			:= dToc(aRetorno[3,96])
				::MatGuia:SCabGui:DtRlz9			:= dToc(aRetorno[3,97])
				::MatGuia:SCabGui:DtRlz1			:= dToc(aRetorno[3,98])
			EndIf
			IF !Empty(Altera)
				::MatGuia:SCabGui:TipSai	:= aRetorno[3,100]
				::MatGuia:SCabGui:TipCon	:= aRetorno[3,101]
				::MatGuia:SCabGui:TipAte	:= aRetorno[3,102]
				
				::MatGuia:SCabGui:EXECCO	:= aRetorno[3,103]
				::MatGuia:SCabGui:CEPCCO	:= aRetorno[3,106]
				::MatGuia:SCabGui:RGEXCO	:= aRetorno[3,104]
				::MatGuia:SCabGui:CCPECO	:= aRetorno[3,105]
				::MatGuia:SCabGui:PREXCC	:= aRetorno[3,107]
				::MatGuia:SCabGui:IndAci	:= aRetorno[3,108]
			ENDIF
			::MatGuia:SCabGui:Protoc			:= iif(len(aRetorno[3]) >= 109, aRetorno[3,109], "")
		else
			::MatGuia:SCabGui:Protoc			:= ""
		Endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Referente a internacao/prorrogacao									   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lInc := ( Len( aRetorno[3] ) > 47 )
		
		If (cTissVer >= '3')
			cTpIntern := Iif(lInc,aRetorno[3,48],'')
			
			If Len(aRetorno[3]) > 60
				cTpAcom := alltrim(PLSGETVINC("BTU_CDTERM", "BI4", .F., "49", AllTrim(aRetorno[3,60])))
			Endif
			If Len(aRetorno[3]) > 92 .and. Len(aRetorno[3]) <= 97
				cTpIntern := aRetorno[3,93]//pego o conteudo do grpint
			Endif
		Else
			cTpIntern := Iif(lInc,aRetorno[3,48],'')
			cTpAcom   := Iif(lInc,aRetorno[3,60],'')
		Endif
		
		::MatGuia:SCabGui:TpIntern			:= cTpIntern
		::MatGuia:SCabGui:RegInter			:= Iif(lInc,aRetorno[3,49],'')
		::MatGuia:SCabGui:QtdDSol			:= Iif(lInc,AllTrim(Str(aRetorno[3,50])),'0')
		::MatGuia:SCabGui:TipDoe			:= Iif(lInc,aRetorno[3,51],'')
		::MatGuia:SCabGui:TmpDoe			:= Iif(lInc,aRetorno[3,52],'')
		::MatGuia:SCabGui:UndDoe			:= Iif(lInc,aRetorno[3,53],'')
		::MatGuia:SCabGui:IndAcid			:= Iif(lInc,aRetorno[3,54],'')
		::MatGuia:SCabGui:Cid2				:= Iif(lInc,aRetorno[3,55],'')
		::MatGuia:SCabGui:Cid3				:= Iif(lInc,aRetorno[3,56],'')
		::MatGuia:SCabGui:Cid4				:= Iif(lInc,aRetorno[3,57],'')
		::MatGuia:SCabGui:DPrAH			    := Iif(lInc,aRetorno[3,58],CToD(""))
		::MatGuia:SCabGui:QtdDAut			:= Iif(lInc,AllTrim(Str(aRetorno[3,59])),'0')
		::MatGuia:SCabGui:TpAcom			:= cTpAcom
		::MatGuia:SCabGui:PadCon			:= Iif(lInc,aRetorno[3,61],'')
		::MatGuia:SCabGui:CnpjSolT			:= Iif(lInc,aRetorno[3,62],'')
		::MatGuia:SCabGui:NomeSolT			:= Iif(lInc,AllTrim(aRetorno[3,63]),'')
		::MatGuia:SCabGui:CnesSolT			:= Iif(lInc,aRetorno[3,64],'')
		::MatGuia:SCabGui:DesAcom			:= Iif(lInc,aRetorno[3,65],'')
		::MatGuia:SCabGui:RdaSolT			:= Iif(lInc,aRetorno[3,66],'')
		::MatGuia:SCabGui:ProfSolT			:= Iif(lInc,aRetorno[3,67],'')
		::MatGuia:SCabGui:OpeSolT			:= Iif(lInc,aRetorno[3,68],'')
		::MatGuia:SCabGui:DatInt			:= Iif(lInc,aRetorno[3,69],Date())
		::MatGuia:SCabGui:DatAlt			:= Iif(lInc,aRetorno[3,70],CToD(""))
		::MatGuia:SCabGui:HorAlt			:= Iif(lInc,aRetorno[3,71],'')
		::MatGuia:SCabGui:Cancel			:= Iif(lInc,aRetorno[3,72],'')
		::MatGuia:SCabGui:DesSTAut			:= Iif(lInc,aRetorno[3,73],'')
		::MatGuia:SCabGui:FindEvo			:= Iif(lInc,aRetorno[3,74],'')
		::MatGuia:SCabGui:NomPla			:= Iif(lInc,aRetorno[3,75],'')
		::MatGuia:SCabGui:DtVldCar			:= Iif(lInc,aRetorno[3,76],CToD(""))
		::MatGuia:SCabGui:CarSaud			:= Iif(lInc,aRetorno[3,77],'')
		::MatGuia:SCabGui:GrPar				:= Iif( Len(aRetorno[3]) >= 79 ,aRetorno[3,79],'')
		::MatGuia:SCabGui:QtdDPro			:= Iif( Len(aRetorno[3]) >= 80 ,Iif(lInc,AllTrim(Str(aRetorno[3,80])),'0'),'0')
		If Empty(aRetorno[3,69]) .And. ::SetDtInt == "0"//Liberacao sem data de internacao, somente na execucao/prorrogacao
			SetSoapFault( "","Liberação sem data de internação.")
			RestArea(aArea)
			Return .F.
		EndIf
		lCmp := ( Len( aRetorno[3] ) > 82 )
		
		::MatGuia:SCabGui:Peso			    := Iif(lInc .and. lCmp,aRetorno[3,82],'')
		::MatGuia:SCabGui:Altura			    := Iif(lInc .and. lCmp,aRetorno[3,83],'')
		::MatGuia:SCabGui:Idade				:= Iif(lInc .and. lCmp,aRetorno[3,84],'')
		::MatGuia:SCabGui:Sexo				:= Iif(lInc .and. lCmp,aRetorno[3,85],'')
		
		lCmp := ( Len( aRetorno[3] ) > 85 )
		::MatGuia:SCabGui:AteRN				:= Iif(lCmp,aRetorno[3,86],'')
		::MatGuia:SCabGui:IniFat			:= Iif(lCmp,aRetorno[3,87],cTod(''))
		::MatGuia:SCabGui:FimFat			:= Iif(lCmp,aRetorno[3,88],cTod(''))
		
		lIxs := ( Len( aRetorno[3] ) > 88 .and. Len(aRetorno[3]) <= 97)
		::MatGuia:SCabGui:AteRN				:= Iif(lIxs,aRetorno[3,91],::MatGuia:SCabGui:AteRN)//na internacao o rn vem na posicao 91
		::MatGuia:SCabGui:PrvOpm			:= Iif(lIxs,aRetorno[3,89],'')
		::MatGuia:SCabGui:PrvQui			:= Iif(lIxs,aRetorno[3,90],'')
		::MatGuia:SCabGui:Gralau			:= Iif(lIxs,aRetorno[3,IIF(Len(aRetorno[3]) > 96, 99, 95)],'')
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Item													 			      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::MatGuia:SIteGui := {}
		For nI := 1 To Len( aRetorno[4] )
			AaDd( ::MatGuia:SIteGui, WsClassNew( "MIteGui" ) )
			::MatGuia:SIteGui[nI]:TpServ 	:= aRetorno[4,nI,1]
			::MatGuia:SIteGui[nI]:Sequencia	:= aRetorno[4,nI,2]
			
			dbSelectArea("BAU")
			dbSetOrder(1)
			dbSeek(xFilial("BAU") + aRetorno[3,1])
			
			If cTissVer >= "3"
				cPadBkp 	:= PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  aRetorno[4,nI,3],.T.)
				
				BTP->(DbSetOrder(1))
				If BTP->(Msseek(xFilial("BTP")+cPadBkp)) .AND. BTP->BTP_BUSDIR == "1"
					::MatGuia:SIteGui[nI]:CodPro 	:= PLSGETVINC("BTU_CDTERM", "BR8", .F., ::MatGuia:SIteGui[nI]:CodPad,  AllTrim(aRetorno[4,nI,4]), .F. ,aTabDup, @cPadBkp)
				else
					::MatGuia:SIteGui[nI]:CodPro 	:= PLSGETVINC("BTU_CDTERM", "BR8", .F., ::MatGuia:SIteGui[nI]:CodPad,  Alltrim(aRetorno[4,nI,3]+aRetorno[4,nI,4]), .F. ,aTabDup, @cPadBkp)
				EndIf
				
				::MatGuia:SIteGui[nI]:CodPad := cPadBkp
				::MatGuia:SIteGui[nI]:DesPro 	:= PLSGETVINC("BTQ_DESTER", "BR8", .F., ::MatGuia:SIteGui[nI]:CodPad,  Alltrim(aRetorno[4,nI,5]))
				::MatGuia:SIteGui[nI]:CodPro_Ori := alltrim(aRetorno[4,nI,4])
				::MatGuia:SIteGui[nI]:CodPad_Ori := alltrim(aRetorno[4,nI,3])
			Else
				::MatGuia:SIteGui[nI]:CodPad 	:= aRetorno[4,nI,3]
				::MatGuia:SIteGui[nI]:CodPro 	:= aRetorno[4,nI,4]
				::MatGuia:SIteGui[nI]:DesPro 	:= aRetorno[4,nI,5]
			Endif
			::MatGuia:SIteGui[nI]:QtdSol 	:= aRetorno[4,nI,6]
			::MatGuia:SIteGui[nI]:QtdAut 	:= aRetorno[4,nI,7]
			::MatGuia:SIteGui[nI]:Fabric 	:= aRetorno[4,nI,8]
			::MatGuia:SIteGui[nI]:VlrApr 	:= aRetorno[4,nI,9]
			::MatGuia:SIteGui[nI]:Exibe	 	:= aRetorno[4,nI,10]
			::MatGuia:SIteGui[nI]:Dente	 	:= aRetorno[4,nI,18]
			::MatGuia:SIteGui[nI]:Face	 	:= aRetorno[4,nI,19]
			::MatGuia:SIteGui[nI]:QtdUs	 	:= aRetorno[4,nI,20]
			::MatGuia:SIteGui[nI]:VlrCon	 	:= aRetorno[4,nI,21]
			::MatGuia:SIteGui[nI]:VlrTpf	 	:= aRetorno[4,nI,22]
			::MatGuia:SIteGui[nI]:Autori	 	:= aRetorno[4,nI,23]
			::MatGuia:SIteGui[nI]:DtExe	 	:= aRetorno[4,nI,26]
			::MatGuia:SIteGui[nI]:Senha	 	:= aRetorno[4,nI,27]
			::MatGuia:SIteGui[nI]:ResAut 	:= IiF( Len(aRetorno[4,nI]) >= 28,aRetorno[4,nI,28],"")
			If (cTissVer >= '3')
				::MatGuia:SIteGui[nI]:GrPar 		:= IiF( Len(aRetorno[4,nI]) >= 29,PLSGETVINC("BTU_CDTERM", "BWT", .F., "35",  aRetorno[4,nI,29]),"")
				::MatGuia:SIteGui[nI]:ViaAc 		:= IiF( Len(aRetorno[4,nI]) >= 32,PLSGETVINC("BTU_CDTERM", "BGR", .F., "61",  aRetorno[4,nI,32]),"")
				::MatGuia:SIteGui[nI]:TecUt 		:= IiF( Len(aRetorno[4,nI]) >= 33,PLSGETVINC("BTU_CDTERM", "B0E", .F., "48",  aRetorno[4,nI,33]),0)
			Else
				::MatGuia:SIteGui[nI]:GrPar 		:= IiF( Len(aRetorno[4,nI]) >= 29,aRetorno[4,nI,29],"")
				::MatGuia:SIteGui[nI]:ViaAc 		:= IiF( Len(aRetorno[4,nI]) >= 32,aRetorno[4,nI,32],"")
				::MatGuia:SIteGui[nI]:TecUt 		:= IiF( Len(aRetorno[4,nI]) >= 33,aRetorno[4,nI,33],0)
			Endif
			::MatGuia:SIteGui[nI]:HorIni 	:= IiF( Len(aRetorno[4,nI]) >= 30,aRetorno[4,nI,30],"")
			::MatGuia:SIteGui[nI]:HorFim 	:= IiF( Len(aRetorno[4,nI]) >= 31,aRetorno[4,nI,31],"")
			::MatGuia:SIteGui[nI]:RedAcre 	:= IiF( Len(aRetorno[4,nI]) >= 34,aRetorno[4,nI,34],0)
			::MatGuia:SIteGui[nI]:VlrTAp 	:= IiF( Len(aRetorno[4,nI]) >= 35,aRetorno[4,nI,35],0)
			::MatGuia:SIteGui[nI]:Diagno 	:= IiF( Len(aRetorno[4,nI]) >= 36,aRetorno[4,nI,36],"")
			::MatGuia:SIteGui[nI]:Pacote 	:= "N"
			::MatGuia:SIteGui[nI]:TpModAdd := "M"  //Indica se o procedimento esta sendo adicionado M - Manualmente ou A - Automaticamente pelo processo de pacotes.
			BR8->(dbSetOrder(1))
			if (BR8->(msseek(xFilial("BR8")+aRetorno[4,nI,3]+aRetorno[4,nI,4])))
				nPosTpProc := iif(!empty(BR8->BR8_TPPROC), aScan(aTpProcs, {|x| x[2] == BR8->BR8_TPPROC}),aScan(aTpProcs, {|x| x[2] == "0"}))
				if(nPosTpProc > 0)
					::MatGuia:SIteGui[nI]:TpProc := aTpProcs[nPosTpProc][2] + " - " + aTpProcs[nPosTpProc][3]//uso para carregar os campos de total na guia
				endIf
			endIf
		Next
		//Roberto - Verifica se os itens da liberação são pacotes, se sim, adicionam todos os sub-itens do pacote.
		if BAU->BAU_TISVER >= "3" .AND. ::Tipo == '2'
			
			aPacotes := PlSplitAdvpl(::Pacotes, "|")
			
			//Montando Array com todos os pacotes.
			For nP := 1 To Len( ::MatGuia:SIteGui )
				
				cCodProc := ::MatGuia:SIteGui[nP]:CodPro_Ori
				
				cCondicao := {|| BLE->BLE_FILIAL == xFilial("BLE") .And. ;
					AllTrim(BLE->BLE_CODPRO) == alltrim(cCodProc) .And. BLE->BLE_TIPO == "9" .And. ;
					BLE->BLE_VIGDE <= DDATABASE .And. (Empty(BLE->BLE_VIGATE) .Or.  DDATABASE <= BLE->BLE_VIGATE)}
				
				BLE->(DbSetOrder(1))
				BLE->(DbSetFilter(cCondicao,""))
				BLE->(DbGoTop())
				
				if !BLE->(EOF())
					while !BLE->(EOF())
						
						if(!PPLSEXIS(::MatGuia:SIteGui, BLE->BLE_CODOPC))
							AADD(::MatGuia:SIteGui, WsClassNew( "MIteGui" ) )
							nTamanho := len(::MatGuia:SIteGui)
							
							::MatGuia:SIteGui[nP]:Pacote := "S"
							::MatGuia:SIteGui[nTamanho] := PPLSPCTM(::MatGuia:SIteGui[nP], "I", aTabDup, PPLSPCTSEQ(::MatGuia))
							
							cPadBkp 	:= PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  BLE->BLE_CODPAD,.T.)
							::MatGuia:SIteGui[nTamanho]:CodPro := PLSGETVINC("BTU_CDTERM", "BR8", .F., ::MatGuia:SIteGui[nTamanho]:CodPad,  Alltrim(BLE->BLE_CODPAD+BLE->BLE_CODOPC), .F. ,aTabDup, @cPadBkp)
							::MatGuia:SIteGui[nTamanho]:CodPad := PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  BLE->BLE_CODPAD,.T.)
							::MatGuia:SIteGui[nTamanho]:DesPro := PLSGETVINC("BTQ_DESTER", "BR8", .F., ::MatGuia:SIteGui[nTamanho]:CodPad,  Alltrim(BLE->BLE_CODPAD+BLE->BLE_CODOPC))
							::MatGuia:SIteGui[nTamanho]:CodPro_Ori := BLE->BLE_CODOPC;
								
						endif
						
						BLE->(DbSkip())
					enddo
				else
					
					for nPct := 1 to Len(aPacotes)
						aCampos := PlSplitAdvpl(aPacotes[nPct], ";")
						
						if(len(aCampos[1]) > 8)
							cCod :=  SubStr(aCampos[1], 3,  len(aCampos[1]))
						else
							cCod := aCampos[1]'
						endif
						
						if(cCod = ::MatGuia:SIteGui[nP]:CodPro_Ori)
							cCondicao := {|| BLE->BLE_FILIAL == xFilial("BLE") .And. ;
								AllTrim(BLE->BLE_CODPRO) == alltrim(aCampos[2]) .And. BLE->BLE_TIPO == "9" .And. ;
								BLE->BLE_VIGDE <= DDATABASE .And. (Empty(BLE->BLE_VIGATE) .Or.  DDATABASE <= BLE->BLE_VIGATE)}
							
							BLE->(DbSetOrder(1))
							BLE->(DbSetFilter(cCondicao,""))
							BLE->(DbGoTop())
							
							//Adicionando o Pacote
							if(!PPLSEXIS(::MatGuia:SIteGui, /*cCodProcedimento*/BLE->BLE_CODPRO))
								
								AADD(::MatGuia:SIteGui, WsClassNew( "MIteGui" ) )
								nTamanho := len(::MatGuia:SIteGui)
								
								//cPadBkp 	:= PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  BLE->BLE_CODPAD,.T.)
								//cCodProcedimento := PLSGETVINC("BTU_CDTERM", "BR8", .F., ::MatGuia:SIteGui[nTamanho]:CodPad,  Alltrim(BLE->BLE_CODPAD+BLE->BLE_CODPRO), .F. ,aTabDup, @cPadBkp)
								
								::MatGuia:SIteGui[nTamanho] := PPLSPCTM(::MatGuia:SIteGui[nP], "I", aTabDup, PPLSPCTSEQ(::MatGuia))
								
								cPadBkp 	:= PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  BLE->BLE_CODPAD,.T.)
								::MatGuia:SIteGui[nTamanho]:CodPro := PLSGETVINC("BTU_CDTERM", "BR8", .F., ::MatGuia:SIteGui[nTamanho]:CodPad,  Alltrim(BLE->BLE_CODPAD+BLE->BLE_CODPRO), .F. ,aTabDup, @cPadBkp)
								::MatGuia:SIteGui[nTamanho]:CodPad := PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  BLE->BLE_CODPAD,.T.)
								::MatGuia:SIteGui[nTamanho]:DesPro := PLSGETVINC("BTQ_DESTER", "BR8", .F., ::MatGuia:SIteGui[nTamanho]:CodPad,  Alltrim(BLE->BLE_CODPAD+BLE->BLE_CODPRO))
								::MatGuia:SIteGui[nTamanho]:CodPro_Ori := BLE->BLE_CODPRO;
									
								
							endif
							
							while !BLE->(EOF())
								
								if(!PPLSEXIS(::MatGuia:SIteGui, BLE->BLE_CODOPC))
									
									AADD(::MatGuia:SIteGui, WsClassNew( "MIteGui" ) )
									nTamanho := len(::MatGuia:SIteGui)
									
									::MatGuia:SIteGui[nTamanho] := PPLSPCTM(::MatGuia:SIteGui[nP], "I", aTabDup, PPLSPCTSEQ(::MatGuia))
									
									cPadBkp 	:= PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  BLE->BLE_CODPAD,.T.)
									::MatGuia:SIteGui[nTamanho]:CodPro := PLSGETVINC("BTU_CDTERM", "BR8", .F., ::MatGuia:SIteGui[nTamanho]:CodPad,  Alltrim(BLE->BLE_CODPAD+BLE->BLE_CODOPC), .F. ,aTabDup, @cPadBkp)
									::MatGuia:SIteGui[nTamanho]:CodPad := PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  BLE->BLE_CODPAD,.T.)
									::MatGuia:SIteGui[nTamanho]:DesPro := PLSGETVINC("BTQ_DESTER", "BR8", .F., ::MatGuia:SIteGui[nTamanho]:CodPad,  Alltrim(BLE->BLE_CODPAD+BLE->BLE_CODOPC))
									::MatGuia:SIteGui[nTamanho]:CodPro_Ori := BLE->BLE_CODOPC;
										
								endif
								
								BLE->(DbSkip())
								
							enddo
							
						endif
					next
					
				endif
				
			Next
			
		endif
		
		If ::Tipo == '5' .AND. cTissVer >= "3"
			//Item
			::MatGuia:SExeGui := {}
			For nI := 1 To Len( aRetorno[6] )
				AaDd( ::MatGuia:SExeGui, WsClassNew( "MExeGui" ) )
				::MatGuia:SExeGui[nI]:Sequen 	:= aRetorno[6,nI,1]
				::MatGuia:SExeGui[nI]:GrPar		:= PLSGETVINC("BTU_CDTERM", "BWT", .F., "35", ALLTRIM(aRetorno[6,nI,2]))
				::MatGuia:SExeGui[nI]:CpfExe 	:= aRetorno[6,nI,3]
				::MatGuia:SExeGui[nI]:NomExe 	:= aRetorno[6,nI,4]
				::MatGuia:SExeGui[nI]:ConReg 	:= aRetorno[6,nI,5]
				::MatGuia:SExeGui[nI]:NumCr 		:= aRetorno[6,nI,6]
				::MatGuia:SExeGui[nI]:UfCr 		:= aRetorno[6,nI,7]
				::MatGuia:SExeGui[nI]:Cbo	 	:= PLSGETVINC("BTU_CDTERM", "BAQ", .F., "24", ALLTRIM(aRetorno[6,nI,8]))
			Next
		EndIf
		//³Critica de Itens										 			      ³
		::MatGuia:SCriGui := {}
		For nI := 1 To Len( aRetorno[5] )
			AaDd( ::MatGuia:SCriGui, WsClassNew( "AutErrorView" ) )
			
			::MatGuia:SCriGui[nI]:Sequence 	:= aRetorno[5,nI,1]
			
			If !Empty( AllTrim(aRetorno[5,nI,1]) )
				aRet := PLSRETCRI( AllTrim( aRetorno[5,nI,1] ) )
				
				If LEN(aRetorno[5][nI]) >= 7
					If EMPTY(aRet[1][2])
						aRet[1][1] := "[" + alltrim(aRetorno[5][nI][7]) + "] " + aRetorno[5][nI][2]
						aRet[1][2] := alltrim(aRetorno[5][nI][3])
					Else
						aRet[1][1] := "[" + alltrim(aRetorno[5][nI][7]) + "] " + aRet[1][1]
					EndIf
				Else
					If !Empty( AllTrim(aRetorno[5,nI,2]) )
						aRet := PLSRETCRI( AllTrim( aRetorno[5,nI,2] ) )
						
						If EMPTY(aRet[1][2])
							aRet[1][1] := aRetorno[5][nI][2]
							aRet[1][2] := aRetorno[5][nI][3]
						EndIf
					EndIf
				EndIf
			Else
				aRet := {}
				AaDd( aRet, {"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" , AllTrim( aRetorno[5,nI,3] ) })
			EndIf
			
			::MatGuia:SCriGui[nI]:Code			:= AllTrim( aRet[1,1] )
			::MatGuia:SCriGui[nI]:Description 	:= PadR( AllTrim(aRet[1,2]),70 )
		Next
		//³Critica Genericas										 			      ³
		If Len(aRetorno)>5 .AND. ::Tipo <> '5'
			::MatGuia:MatCri := {}
			For nI := 1 To Len( aRetorno[6] )
				AaDd( ::MatGuia:MatCri, WsClassNew( "GenericStruct" ) )
				::MatGuia:MatCri[nI]:Code		:= aRetorno[6,nI,1]
				::MatGuia:MatCri[nI]:Description	:= aRetorno[6,nI,2]
			Next
		EndIf
	ElseIf !Empty(aRetorno[2])
		lRetorno := .F.
		SetSoapFault( "", aRetorno[2] )
	Else
		lRetorno := .F.
		If Len(aRetorno[5]) >= 1
			If Len(aRetorno[6]) >= 1
				cMsgAux	:= "Liberação não pode ser executada ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" + Chr(13)+Chr(10) + Chr(13)+Chr(10)
				For nI := 1 To Len( aRetorno[6] )
					cMsgAux += aRetorno[6,nI,1] +" - "+ aRetorno[6,nI,2] + Chr(13)+Chr(10)
				Next
				SetSoapFault( "", cMsgAux )
			Else
				SetSoapFault( "", "Liberação não pode ser executada ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )
			EndIf
		Else
			If Len(aRetorno) >= 8
				dbSelectArea("BE2")
				dbsetOrder(1)
				dbSeek(xFilial("BE2") + aRetorno[8])
				If BE2->BE2_STATUS == "0" .AND. BE2_AUDITO == "1"
					SetSoapFault( "", "Guia encontra-se em Auditoria e não pode ser executada. ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )
				Elseif BEA->BEA_STATUS == "5"
					SetSoapFault( "", "Guia contém título a receber e não pode ser executada. ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )
				Else
					SetSoapFault( "", "Nenhuma guia encontrada ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )
				Endif
			Else
				If ::Tipo == '3' .or. ::Tipo == '6'
					If BEA->(MsSeek(xFilial("BEA")+::NumAut)) .And. BEA->BEA_TIPO <> ::Tipo
						SetSoapFault( "", "Guia informada não é uma guia de solicitação de internação ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )
					Else
						SetSoapFault( "", "Nenhuma guia encontrada ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )
					EndIf
				Elseif ::Tipo == '5'
					SetSoapFault( "", "Nenhuma guia encontrada ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )
				Elseif ::Tipo $ '7,8,9,11'
					If EmpTy(aRetorno[2])
						SetSoapFault( "", "Guia nao encontrada ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )
					else
						SetSoapFault( "", aRetorno[2] + " ( "+Transform( ::NumAut, "@R 9999.9999.99.99999999" )+" )" )
					EndIf
				Endif
			EndIf
		Endif
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
Return lRetorno

static Function PPLSPCTSEQ(aMatGuia)

	local nSequencia := 0
	local nS

	For nS := 1 To Len( aMatGuia:SIteGui )
		if aMatGuia:SIteGui[nS]:Sequencia <> NIL
			if nSequencia < val(aMatGuia:SIteGui[nS]:Sequencia)
	    		nSequencia := val(aMatGuia:SIteGui[nS]:Sequencia)
	    	endif
    	endif
    next

return CVALTOCHAR(nSequencia + 1)


static Function PPLSPCTM(oMatGuia, cTipo, aTabDup, cSeq)

	local SIteGuiPct := WsClassNew("MIteGui")

	SIteGuiPct:TpServ 		:= oMatGuia:TpServ
	SIteGuiPct:Sequencia		:= cSeq//oMatGuia:Sequencia
	SIteGuiPct:QtdSol			:= oMatGuia:QtdSol
	SIteGuiPct:QtdAut 	 	:= oMatGuia:QtdAut
	SIteGuiPct:Exibe	 	 	:= oMatGuia:Exibe
	SIteGuiPct:Autori	 		:= oMatGuia:Autori
	SIteGuiPct:DtExe	 		:= oMatGuia:DtExe
	SIteGuiPct:Senha	 		:= oMatGuia:Senha
	SIteGuiPct:ResAut 	 	:= oMatGuia:ResAut
	SIteGuiPct:GrPar 	 		:= oMatGuia:GrPar
	SIteGuiPct:HorIni 	 	:= oMatGuia:HorIni
	SIteGuiPct:HorFim 	 	:= oMatGuia:HorFim


	SIteGuiPct:Fabric 		:= oMatGuia:Fabric
	SIteGuiPct:VlrApr 		:= oMatGuia:VlrApr
	SIteGuiPct:Dente	 		:= oMatGuia:Dente
	SIteGuiPct:Face	 		:= oMatGuia:Face
	SIteGuiPct:QtdUs	 		:= oMatGuia:QtdUs
	SIteGuiPct:VlrCon			:= oMatGuia:VlrCon
	SIteGuiPct:VlrTpf			:= oMatGuia:VlrTpf
	SIteGuiPct:Autori			:= oMatGuia:Autori
	SIteGuiPct:DtExe	 		:= oMatGuia:DtExe
	SIteGuiPct:Senha	 		:= oMatGuia:Senha
	SIteGuiPct:ViaAc 			:= oMatGuia:ViaAc
	SIteGuiPct:TecUt 			:= oMatGuia:TecUt
	SIteGuiPct:RedAcre 		:= oMatGuia:RedAcre
	SIteGuiPct:VlrTAp 		:= oMatGuia:VlrTAp
	SIteGuiPct:Diagno 		:= oMatGuia:Diagno
	SIteGuiPct:Pacote 		:= cTipo

/*	SIteGuiPct:CodPro_Ori	:= cCodProcedimento_Ori;

	SIteGuiPct:CodPro 		:= cCodProcedimento//PLSGETVINC("BTU_CDTERM", "BR8", .F., ::MatGuia:SIteGui[nTamanho]:CodPad,  Alltrim(BLE-> BLE_CODPAD+BLE-> BLE_CODOPC), .F. ,aTabDup, @cPadBkp)
	SIteGuiPct:CodPad 		:= PLSGETVINC("BTU_CDTERM", "BR4", .F., "87",  cTabela_Orig,.T.)
	SIteGuiPct:DesPro 		:= PLSGETVINC("BTQ_DESTER", "BR8", .F., SIteGuiPct:CodPad,  Alltrim(cTabela_Orig+cCodProcedimento))
*/

return SIteGuiPct


static Function PPLSEXIS(aArray, cCodigo)

	local vExiste := .F.
	local nI

	for  nI := 1  to len(aArray)
		if(alltrim(aArray[nI]:CodPro_Ori) = alltrim(cCodigo))
			vExiste := .T.
		endif
	next

return vExiste


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RetAut    ³Autor  ³ Alexander	            ³ Data ³06.04.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna guias de um Usuário por prestador e data			   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RetAut WSRECEIVE UserCode, UserCardNumber,RDACode,CodLoc,DtAut WSSEND MatAut WSSERVICE PLSXFUN
LOCAL nI            := 1
LOCAL lRetorno 		:= .T.
LOCAL aRet	 		:= {}
LOCAL aArea			:= GetArea()
LOCAL cMatric		:= ""
LOCAL cSQL			:= ""

BQV->(dbSetOrder(1))

If PrtChkUser( ::UserCode, "PLSXFUN", "RetAut" ) //consome uma licença, checa integridade d acesso

	//////////////////////////////////////////////////////////////////////
	//Verifica se e Usuário de intercambio e pega a matricula original	
	//////////////////////////////////////////////////////////////////////
    cMatric := PPLTROMAT(::UserCardNumber)
   	
	//////////////////////////////////////////////////////////////////////
	//Monta query para pegar as autorizações do usuario + rda				   
	//////////////////////////////////////////////////////////////////////
	cSQL := " SELECT BEA_OPEMOV,BEA_ANOAUT,BEA_MESAUT,BEA_NUMAUT,BEA_OPEINT, "
	cSQL += " BEA_TIPO,BEA_DTDIGI,BEA_HORPRO,BEA_STATUS, BEA_SENHA "
	cSQL += " FROM " + RetSQLName("BEA")
	cSQL += " WHERE BEA_FILIAL = '" + xFilial("BEA") +"' "
	cSQL += "   AND BEA_OPEUSR = '" + SubStr(cMatric,1,4) +"' "
	cSQL += "   AND BEA_CODEMP = '" + SubStr(cMatric,5,4) +"' "
	cSQL += "   AND BEA_MATRIC = '" + SubStr(cMatric,9,6) +"' "
	cSQL += "   AND BEA_TIPREG = '" + SubStr(cMatric,15,2) +"' "
	cSQL += "   AND BEA_DIGITO = '" + SubStr(cMatric,17,1) +"' "
	cSQL += "   AND BEA_CODRDA = '" + ::RDACode +"'  "
	cSQL += "   AND BEA_TIPO  <> '3' "   

	If !EMPTY(::DtAut) 
		cSQL += "    AND BEA_DTDIGI = '" + DtoS(::DtAut) +"' "
	EndIf 
	
	cSQL += "    AND BEA_CODLOC = '" + ::CodLoc +"' "
	cSQL += "    AND D_E_L_E_T_ <> '*' "
	cSQL += "    AND BEA_STATUS <> '5' "
	cSQL += " ORDER BY BEA_DATPRO "
	
	cSQL := ChangeQuery(cSQL)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TRBRETAUT",.T.,.F.)
	

	While !TrbRetAut->( Eof() )
   		AaDd(aRet,{	TrbRetAut->(BEA_OPEMOV+BEA_ANOAUT+BEA_MESAUT+BEA_NUMAUT),;  									//Numero da autorizacao consult/sadt
   					"",;
					Iif(TrbRetAut->BEA_TIPO=="1","CONSULTA",Iif(TrbRetAut->BEA_TIPO=="2","SADT","ODONTOLOGICO"  ) ),; //Tipo de guia
   					TrbRetAut->BEA_DTDIGI,;									 										//Data da autorizacao
   					TrbRetAut->BEA_HORPRO,;																			//Hora da autorizacao
   					TrbRetAut->BEA_TIPO  ,;																			 //Tipo Guia			
   					TrbRetAut->BEA_STATUS,;
   					TrbRetAut->BEA_SENHA})									 									    //Status Guia
		
		TrbRetAut->( DbSkip() )
    EndDo
	
	TrbRetAut->( DbCloseArea() )

   	//////////////////////////////////////////////////////////////////////
	//Monta query para pegar as autorizações do usuario + rda			
	//////////////////////////////////////////////////////////////////////
	cSQL := " SELECT B0D_CODOPE,B0D_ANOAUT,B0D_MESAUT,B0D_NUMAUT,B0D_NUMINT,B0D_DATGUI "
	cSQL += "   FROM " + RetSQLName("B0D")
	cSQL += "  WHERE B0D_FILIAL = '" + xFilial("B0D") +"' "
	cSQL += "    AND B0D_NUMCAR = '" + cMatric +"' "
	cSQL += "    AND B0D_CODRDA = '" + ::RDACode +"' "

	If !EMPTY(::DtAut) 
		cSQL += "    AND B0D_DATGUI = '" + DtoS(::DtAut) +"' "
	EndIf 
	
	cSQL += "    AND D_E_L_E_T_ <> '*' "
	cSQL += " ORDER BY B0D_DATGUI "
	
	cSQL := ChangeQuery(cSQL)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TRBRETAUT",.T.,.F.)
	
    While !TrbRetAut->( Eof() )

	    B0E->(DbSetOrder(2)) //B0E_FILIAL + B0E_OPEMOV + B0E_ANOAUT + B0E_MESAUT + B0E_NUMAUT +B0E_SEQUEN
		B0E->( MsSeek( xFilial("B0E")+TrbRetAut->(B0D_CODOPE+B0D_ANOAUT+B0D_MESAUT+B0D_NUMAUT) ) )

   		AaDd(aRet,{	TrbRetAut->(B0D_CODOPE+B0D_ANOAUT+B0D_MESAUT+B0D_NUMAUT),;	//Numero da autorizacao consult/sadt
   					TrbRetAut->(B0D_NUMINT),; 									//Numero da autorizacao de internacao
   					"HONORáRIO",; 												//Tipo de guia
   					TrbRetAut->B0D_DATGUI,;										//Data da autorizacao
   					B0E->B0E_HORINI,;											//Hora da autorizacao
   					"5",;
   					B0E->B0E_STATUS,;											// Status da Guia - 1-Autorizado - 2-Não Autorizado 
   					"Guia Hon Individual" })									//Tipo Guia
    	
		TrbRetAut->( DbSkip() )
    EndDo
	
	TrbRetAut->( DbCloseArea() )

	//////////////////////////////////////////////////////////////////////
	//Monta query para pegar as autorizações do usuario + rda				   
	//////////////////////////////////////////////////////////////////////
	cSQL := " SELECT B4A_OPEMOV,B4A_ANOAUT,B4A_MESAUT,B4A_NUMAUT,B4A_DATSOL,B4A_TIPGUI ,B4A_STATUS, B4A_SENHA"
	cSQL += "   FROM " + RetSQLName("B4A") + " B4A "
	cSQL += "  INNER JOIN " + RetSQLName("BEA") + " BEA "
	cSQL += "  ON BEA_FILIAL = '" + xFilial("BEA") + "' "
	cSQL += "    AND BEA_OPEMOV || BEA_ANOAUT || BEA_MESAUT || BEA_NUMAUT = B4A_GUIREF "
	cSQL += "  WHERE B4A_FILIAL = '" + xFilial("B4A") +"' "
	cSQL += "    AND B4A_OPEUSR = '" + SubStr(cMatric,1,4) +"' "
	cSQL += "    AND B4A_CODEMP = '" + SubStr(cMatric,5,4) +"' "
	cSQL += "    AND B4A_MATRIC = '" + SubStr(cMatric,9,6) +"' "
	cSQL += "    AND B4A_TIPREG = '" + SubStr(cMatric,15,2) +"' "
	cSQL += "    AND B4A_DIGITO = '" + SubStr(cMatric,17,1) +"' "
	cSQL += "    AND BEA_CODRDA = '" + ::RDACode + "' "
	cSQL += "    AND BEA_CODLOC = '" + ::CodLoc + "' "
			
	If !EMPTY(::DtAut) 
		cSQL += "    AND B4A_DATSOL = '" + DtoS(::DtAut) +"' "
	EndIf 

	cSQL += "    AND B4A.D_E_L_E_T_ <> '*' "
	cSQL += "    AND BEA.D_E_L_E_T_ <> '*' "
	cSQL += " ORDER BY B4A_DATSOL "
	
	cSQL := ChangeQuery(cSQL)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TRBRETAUT",.T.,.F.)
	
	While !TrbRetAut->( Eof() )

		AaDd(aRet,{	TrbRetAut->(B4A_OPEMOV+B4A_ANOAUT+B4A_MESAUT+B4A_NUMAUT),;	//Numero da autorizacao consult/sadt
					'',; 														//Numero da autorizacao de internacao
					IF(TrbRetAut->B4A_TIPGUI=='09','ANEXO OPME',If(TrbRetAut->B4A_TIPGUI=='07','ANEXO QUIMIOTERAPIA','ANEXO RADIOTERAPIA')),; 				//Tipo de guia
					TrbRetAut->B4A_DATSOL,;										//Data da autorizacao
					'',;														//Hora da autorizacao
					alltrim(str(VAL(TrbRetAut->B4A_TIPGUI))),;
					TrbRetAut->B4A_STATUS,;
					TrbRetAut->B4A_SENHA } )									//Tipo Guia
		
		TrbRetAut->( DbSkip() )
	EndDo
	
	TrbRetAut->( DbCloseArea() )

	//////////////////////////////////////////////////////////////////////
	//Monta query para pegar as autorizações do usuario + rda			
	//////////////////////////////////////////////////////////////////////
	cSQL := " SELECT B4Q_OPEMOV,B4Q_ANOAUT,B4Q_MESAUT,B4Q_NUMAUT,B4Q_DATSOL, B4Q_STATUS, B4Q_SENHA "
	cSQL += "   FROM " + RetSQLName("B4Q")
	cSQL += "  WHERE B4Q_FILIAL = '" + xFilial("B4Q") +"' "
	cSQL += "    AND B4Q_OPEUSR = '" + SubStr(cMatric,1,4) +"' "
	cSQL += "    AND B4Q_CODEMP = '" + SubStr(cMatric,5,4) +"' "
	cSQL += "    AND B4Q_MATRIC = '" + SubStr(cMatric,9,6) +"' "
	cSQL += "    AND B4Q_TIPREG = '" + SubStr(cMatric,15,2) +"' "
	cSQL += "    AND B4Q_DIGITO = '" + SubStr(cMatric,17,1) +"' "
	cSQL += "    AND B4Q_CODRDA = '" + ::RDACode +"' "
	
	If !EMPTY(::DtAut) 
		cSQL += "    AND B4Q_DATSOL = '" + DtoS(::DtAut) +"' "
	EndIf 
	
	cSQL += "    AND D_E_L_E_T_ <> '*' "
	cSQL += " ORDER BY B4Q_DATSOL "
	
	cSQL := ChangeQuery(cSQL)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TRBRETAUT",.T.,.F.)
	
	While !TrbRetAut->( Eof() )

		AaDd(aRet,{	TrbRetAut->(B4Q_OPEMOV+B4Q_ANOAUT+B4Q_MESAUT+B4Q_NUMAUT),;	//Numero da autorizacao consult/sadt
					'',; 														//Numero da autorizacao de internacao
					"PRORROGAÇÃO INTERNAÇÃO",; 									//Tipo de guia
					TrbRetAut->B4Q_DATSOL,;										//Data da autorizacao
					'',;														//Hora da autorizacao
					'11',;
					TrbRetAut->B4Q_STATUS,;	
					TrbRetAut->B4Q_SENHA})										//Tipo Guia
		
		TrbRetAut->( DbSkip() )
	EndDo
	
	TrbRetAut->( DbCloseArea() )
	
	//////////////////////////////////////////////////////////////////////
	//Monta query para pegar as autorizações do usuario + rda			
	//////////////////////////////////////////////////////////////////////
	cSQL := " SELECT BE4_CODOPE,BE4_ANOINT,BE4_MESINT,BE4_NUMINT,BE4_DTDIGI,BE4_HORPRO,BE4_STATUS, BE4_SENHA"
	cSQL += " FROM " + RetSQLName("BE4")
	cSQL += " WHERE BE4_FILIAL = '" + xFilial("BE4") +"' "
	cSQL += "   AND BE4_OPEUSR = '" + SubStr(cMatric,1,4) +"' "
	cSQL += "   AND BE4_CODEMP = '" + SubStr(cMatric,5,4) +"' "
	cSQL += "   AND BE4_MATRIC = '" + SubStr(cMatric,9,6) +"' "
	cSQL += "   AND BE4_TIPREG = '" + SubStr(cMatric,15,2) +"' "
	cSQL += "   AND BE4_DIGITO = '" + SubStr(cMatric,17,1) +"' "
	cSQL += "   AND BE4_CODRDA = '" + ::RDACode +"' "
	cSQL += "   AND BE4_CODLOC = '" + ::CodLoc +"' "
	
	If !EMPTY(::DtAut) 
		cSQL += "    AND BE4_DTDIGI = '" + DtoS(::DtAut) +"' "
	EndIf 
	
	cSQL += "    AND D_E_L_E_T_ <> '*' "
	cSQL += " ORDER BY BE4_DATPRO "
	
	cSQL := ChangeQuery(cSQL)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TRBRETAUT",.T.,.F.)
	
	While !TrbRetAut->( Eof() )

		AaDd(aRet,{	TrbRetAut->(BE4_CODOPE+BE4_ANOINT+BE4_MESINT+BE4_NUMINT),;	//Numero da autorizacao consult/sadt
					TrbRetAut->(BE4_CODOPE+BE4_ANOINT+BE4_MESINT+BE4_NUMINT),; 	//Numero da autorizacao de internacao
					"INTERNAÇÃO",; 												//Tipo de guia
					TrbRetAut->BE4_DTDIGI,;										//Data da autorizacao
					TrbRetAut->BE4_HORPRO,;										//Hora da autorizacao
					"3",;														//Tipo Guia			
					TrbRetAut->BE4_STATUS,;
					TrbRetAut->BE4_SENHA})										//Tipo Guia
		
		TrbRetAut->( DbSkip() )
	EndDo
	
	TrbRetAut->( DbCloseArea() )

	//////////////////////////////////////////////////////////////////////
	//Guias
	//////////////////////////////////////////////////////////////////////
	If Len(aRet) > 0
	
	   ::MatAut := {}
   	
	      For nI := 1 To Len( aRet )
		   AaDd( ::MatAut, WsClassNew( "SMatAut" ) )
		   ::MatAut[nI]:NumeAut 	:= aRet[nI,1]
		   ::MatAut[nI]:NumeInt 	:= aRet[nI,2]
		   ::MatAut[nI]:TipoTran 	:= aRet[nI,3]
		   ::MatAut[nI]:DtAut 		:= STOD(aRet[nI,4])
		   ::MatAut[nI]:HrAut 		:= aRet[nI,5]
		   ::MatAut[nI]:Tp 			:= aRet[nI,6]
		  
		   If Len(aRet[nI]) >= 7
		   	::MatAut[nI]:TpStatus	:= aRet[nI,7]
		   EndIf
		  
		   ::MatAut[nI]:Prorrog		:= cvaltochar( IIF(B4Q->(dbSeek(xFilial('B4Q')+::MatAut[nI]:NumeAut)), .F., (BQV->(dbSeek(xFilial('BQV')+::MatAut[nI]:NumeAut))) ) )
		   ::MatAut[nI]:Status		:= PlsStatGui( aRet[nI,7], IIf("ANEXO"$aRet[nI,3], "B4A", IIf("HONORáRIO"$aRet[nI,3], "B0D", "BEA")  )  )
		   ::MatAut[nI]:Senha		:= aRet[nI,8]
       Next
    Else
		lRetorno := .F.
		SetSoapFault( "", "Nenhuma guia encontrada para o Usuário ( "+Iif( Len(::UserCardNumber)>16 ,Transform(::UserCardNumber, "@R 9999.9999.999999.99-9" ),Transform(::UserCardNumber, "@R 999.9999.999999.99-9" ) )+" )" )
    EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

BQV->(dbCloseArea())

RestArea( aArea )

Return lRetorno
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa   ³ PreAte   ³ Autor ³ Alexander Santos	     ³ Data ³ 2.05.07  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao  ³ Inclusao do pre-atendimento								   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PreAte WSRECEIVE UserCode, MatPre WSSEND RetMatPre WSSERVICE PLSXFUN
LOCAL nI        	:= 1
LOCAL lRetorno 		:= .T.
LOCAL aMat 			:= {}
LOCAL aRet 			:= {}
LOCAL aArea			:= GetArea()
//TISS 2.2 - Requisitos minimos é a existencia da tabela BRI e a existencia da função PLSRETLDP
If ! ( PLSALIASEX("BRI") .And. FindFunction("PLSRETLDP") )
	lRetorno := .F.
	SetSoapFault( "","Necessário atualizar pacote da TISS 2.2 para se utilizar esta funcionalidade.")
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "PreAte" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Matriz  com dados do pre atendimento									   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    AaDd(aMat,MatPre:Matric)	//Matricula
	AaDd(aMat,MatPre:CodUsr)	//Codigo de Usuário web
	AaDd(aMat,MatPre:NomeUsu)	//Nome do Usuário
	AaDd(aMat,MatPre:OpeRda)	//Operadora da rda
	AaDd(aMat,MatPre:CodRda)	//Codigo da rda
	AaDd(aMat,MatPre:NomRda)	//Nome da rda
	AaDd(aMat,MatPre:CodLoc)	//LOCAL de atendimento
	AaDd(aMat,MatPre:Trilha)	//Trilha do Cartao
	AaDd(aMat,MatPre:CodRdaOld) // codigo da RDA antes da alteração
	AaDd(aMat,MatPre:CodLocOld) // codigo do local antes da alteração
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³gravacao ou atualizacao do pre atendimento retorna todos os Usuários	   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aRet := PLVLDPRE(aMat,MatPre:TpAca, MatPre:OrdResult)
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³Guias													 			   ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    ::RetMatPre := {}
   	For nI := 1 To Len( aRet[2] )
	   AaDd(::RetMatPre, WsClassNew( "SRetMatPre" ) )
	   ::RetMatPre[nI]:Msg		:= aRet[1]
	   ::RetMatPre[nI]:Matric	:= aRet[2,nI,1]
	   ::RetMatPre[nI]:NomeUsu	:= aRet[2,nI,2]
	   ::RetMatPre[nI]:Rda		:= aRet[2,nI,3]
	   ::RetMatPre[nI]:NomeRda 	:= aRet[2,nI,4]
	   ::RetMatPre[nI]:CodLoc	:= aRet[2,nI,5]
	   ::RetMatPre[nI]:DatChe 	:= aRet[2,nI,6]
	   ::RetMatPre[nI]:HorChe 	:= aRet[2,nI,7]
    Next
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa   ³ StatusGuia       ³ Autor ³ Alexander Santos	³ Data ³ 29.05.07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao  ³ Status de uma Autorizacao								   	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
WSMETHOD StatusGuia WSRECEIVE UserCode, NumAut ,TipoAut WSSEND MatComGui WSSERVICE PLSXFUN
LOCAL nI,nY,nPos:= 0
LOCAL lRetorno 	:= .T.
LOCAL aRet 		:= {}
LOCAL aCriticas	:= {}
LOCAL aRetCri	:= {}
LOCAL aRetBox	:= {}
LOCAL aArea		:= GetArea()
LOCAL cNomUsrP  := ""
LOCAL cCodRdaP  := ""
LOCAL cStatusP  := ""
LOCAL cDatSolP  := ""
LOCAL cCancelP	:= ""
local cOnLine	:= "0"
Local lPTUOn50  := alltrim(GetNewPar("MV_PTUVEON","35")) >= "50" .And. BEA->(FieldPos("BEA_CANEDI")) > 0
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Data com 4 digitos													   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Set Century On
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "StatusGuia" )

	If ::TipoAut != '3'

	   SIX->( DbSetOrder(1) )
	   If SIX->( MsSeek("BEAA") )
		   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		   //³ Posiciona no cabecalho               									   ³
		   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		   BEA->( DbSetOrder(1) )//BEA_FILIAL + BEA_OPEMOV + BEA_ANOAUT + BEA_MESAUT + BEA_NUMAUT
		   If PlsAliasExi('B4A')
		   		B4A->( DbSetOrder(1) )
		   Endif
		   If PlsAliasExi('B4A') .and. B4A->( MsSeek(xFilial("B4A")+::NumAut) ) .And. B4A->B4A_TIPGUI == strzero(val(::TipoAut),2)
		          cNomUsrP := B4A->B4A_NOMUSR
				  cCodRdaP := space(6)
				  cStatusP := B4A->B4A_STATUS
				  cDatSolP := DToC(B4A->B4A_DATSOL)
				  cCancelP := B4A->B4A_CANCEL
				  cOnLine  := B4A->B4A_COMUNI

		   		  B4C->( DbSetOrder(1) )//BE2_FILIAL + BE2_OPEMOV + BE2_ANOAUT + BE2_MESAUT + BE2_NUMAUT + BE2_SEQUEN
				  BEG->( DbSetOrder(1) )//BEG_FILIAL + BEG_OPEMOV + BEG_ANOAUT + BEG_MESAUT + BEG_NUMAUT + BEG_SEQUEN
			      If B4C->( MsSeek(xFilial("B4C")+B4A->(B4A_OPEMOV+B4A_ANOAUT+B4A_MESAUT+B4A_NUMAUT)) )
			         While ! B4C->( Eof() ) .And. B4C->(B4C_FILIAL+B4C_OPEMOV+B4C_ANOAUT+B4C_MESAUT+B4C_NUMAUT) == ;
			                                       xFilial("B4C")+B4A->(B4A_OPEMOV+B4A_ANOAUT+B4A_MESAUT+B4A_NUMAUT)
						    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						    //³Critica de Itens										 			       ³
						    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						    aCriticas := {}
						    If BEG->( MsSeek( xFilial("BEG")+B4C->(B4C_OPEMOV+B4C_ANOAUT+B4C_MESAUT+B4C_NUMAUT+B4C_SEQUEN) ) )
						    	While !BEG->( Eof() ) .And. BEG->(BEG_FILIAL+BEG_OPEMOV+BEG_ANOAUT+BEG_MESAUT+BEG_NUMAUT+BEG_SEQUEN) ==;
						    								 xFilial("BEG")+B4C->(B4C_OPEMOV+B4C_ANOAUT+B4C_MESAUT+B4C_NUMAUT+B4C_SEQUEN)
								   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								   //³ Matriz de itens															   ³
								   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								   If !Empty(BEG->BEG_CODGLO)
					                   AaDd(aCriticas,{	AllTrim(BEG->BEG_SEQUEN),; //Sequencia
					                   					AllTrim(BEG->BEG_CODGLO),; //Codigo Glosa
					                   					AllTrim(BEG->BEG_DESGLO),; 	//Tabela
					                   					AllTrim(BEG->BEG_INFGLO)} )	//Procedimento
					               EndIf
						        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						        //³ Skip																	    ³
						        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						        BEG->( DbSkip() )
						        EndDo
					        EndIf
		                    AaDd(aRet,{	AllTrim(B4C->B4C_CODPAD),; 										    //01-Tabela
		                   			  	AllTrim(B4C->B4C_CODPRO),; 										    //02-Procedimento
		                   			 	AllTrim(B4C->B4C_DESPRO),;											//03-Descricao
		                   			 	Iif( B4C->B4C_QTDSOL==0 , AllTrim(Str(B4C->B4C_QTDPRO)) , AllTrim(Str(B4C->B4C_QTDSOL)) ) ,;//04-Qtd Solicitada
		                   			 	Iif( B4C->B4C_STATUS=="1" , AllTrim(Str(B4C->B4C_QTDPRO)),"0"),;	//05-Qtd Realizada
		                   			 	Iif( B4C->B4C_STATUS=="1",AllTrim(Str(B4C->B4C_SALDO)),"0"),;  	 //06-Qtd Saldo
		                   			 	Iif(B4C->B4C_AUDITO=="1","Sim","Não"),;						     //07-Auditoria
		                   			 	Iif(B4C->B4C_STATUS=="1","Autorizado","Não Autorizado"),;			 //08-Status
		                   			 	aCriticas} )    		                                             //09-Criticas
			               B4C->( DbSkip() )
			         Enddo
		   		  Endif
		   ElseIf BEA->( MsSeek(xFilial("BEA")+::NumAut) ) .And. BEA->BEA_TIPO == ::TipoAut
				  cNomUsrP := BEA->BEA_NOMUSR
				  cCodRdaP := BEA->BEA_CODRDA
				  cStatusP := BEA->BEA_STATUS
				  cDatSolP := DToC(BEA->BEA_DATSOL)
				  cCancelP := BEA->BEA_CANCEL
				  cOnLine  := BEA->BEA_COMUNI
				  //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				  //³ item																		  ³
				  //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			      BE2->( DbSetOrder(1) )//BE2_FILIAL + BE2_OPEMOV + BE2_ANOAUT + BE2_MESAUT + BE2_NUMAUT + BE2_SEQUEN
				  BEG->( DbSetOrder(1) )//BEG_FILIAL + BEG_OPEMOV + BEG_ANOAUT + BEG_MESAUT + BEG_NUMAUT + BEG_SEQUEN
			      If BE2->( MsSeek(xFilial("BE2")+BEA->(BEA_OPEMOV+BEA_ANOAUT+BEA_MESAUT+BEA_NUMAUT)) )
			         While ! BE2->( Eof() ) .And. BE2->(BE2_FILIAL+BE2_OPEMOV+BE2_ANOAUT+BE2_MESAUT+BE2_NUMAUT) == ;
			                                       xFilial("BE2")+BEA->(BEA_OPEMOV+BEA_ANOAUT+BEA_MESAUT+BEA_NUMAUT)
						    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						    //³Critica de Itens										 			       ³
						    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						    aCriticas := {}
						    If BEG->( MsSeek( xFilial("BEG")+BE2->(BE2_OPEMOV+BE2_ANOAUT+BE2_MESAUT+BE2_NUMAUT+BE2_SEQUEN) ) )
						    	While !BEG->( Eof() ) .And. BEG->(BEG_FILIAL+BEG_OPEMOV+BEG_ANOAUT+BEG_MESAUT+BEG_NUMAUT+BEG_SEQUEN) ==;
						    								 xFilial("BEG")+BE2->(BE2_OPEMOV+BE2_ANOAUT+BE2_MESAUT+BE2_NUMAUT+BE2_SEQUEN)
								   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								   //³ Matriz de itens															   ³
								   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								   If !Empty(BEG->BEG_CODGLO)
					                   AaDd(aCriticas,{	AllTrim(BEG->BEG_SEQUEN),; //Sequencia
					                   					AllTrim(BEG->BEG_CODGLO),; //Codigo Glosa
					                   					AllTrim(BEG->BEG_DESGLO),; 	//Tabela
					                   					AllTrim(BEG->BEG_INFGLO)} )	//Procedimento
					               EndIf
						        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						        //³ Skip																	    ³
						        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						        BEG->( DbSkip() )
						        EndDo
					       EndIf
		                   AaDd(aRet,{	AllTrim(BE2->BE2_CODPAD),; 										    //01-Tabela
		                   			  	AllTrim(BE2->BE2_CODPRO),; 										    //02-Procedimento
		                   			 	AllTrim(BE2->BE2_DESPRO),;											//03-Descricao
		                   			 	Iif( BE2->BE2_QTDSOL==0 , AllTrim(Str(BE2->BE2_QTDPRO)) , AllTrim(Str(BE2->BE2_QTDSOL)) ) ,;//04-Qtd Solicitada
		                   			 	AllTrim(Str(BE2->BE2_QTDPRO)) /*Iif( BE2->BE2_STATUS=="1" , AllTrim(Str(BE2->BE2_QTDPRO)),"0")*/,;	//05-Qtd Realizada
		                   			 	Iif( BE2->BE2_STATUS=="1",AllTrim(Str(BE2->BE2_SALDO)),"0"),;  	 //06-Qtd Saldo
		                   			 	Iif(BE2->BE2_AUDITO=="1","Sim","Não"),;						     //07-Auditoria
		                   			 	Iif(BE2->BE2_STATUS=="1","Autorizado","Não Autorizado"),;			 //08-Status
		                   			 	aCriticas,;
		                   			 	BEA->BEA_TIPGUI} )    		                                             //09-Criticas
			               BE2->( DbSkip() )
			         Enddo
			      Else
						lRetorno := .F.
						SetSoapFault( "", "Não existe procedimento para esta Guia" )
			      EndIf
		   Else
				lRetorno := .F.
				SetSoapFault( "", "Guia não encontrada" )
		   EndIf
	   EndIf
	Else
	   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	   //³ Posiciona no cabecalho               									   ³
	   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   BE4->( DbSetOrder(2) )//BE4_FILIAL + BE4_CODOPE + BE4_ANOINT + BE4_MESINT + BE4_NUMINT
	   If BE4->( MsSeek(xFilial("BE4")+::NumAut) )
		  cNomUsrP := BE4->BE4_NOMUSR
	      cCodRdaP := BE4->BE4_CODRDA
	      cStatusP := BE4->BE4_STATUS
	      cDatSolP := DToC(BE4->BE4_DTDIGI)
	      cCancelP := BE4->BE4_CANCEL
	      cOnLine  := BE4->BE4_COMUNI
		  //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		  //³ item																		  ³
		  //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	      BEJ->( DbSetOrder(1) )//BEJ_FILIAL + BEJ_CODOPE + BEJ_ANOINT + BEJ_MESINT + BEJ_NUMINT + BEJ_SEQUEN
		  BEL->( DbSetOrder(1) ) //BEL_FILIAL + BEL_CODOPE + BEL_ANOINT + BEL_MESINT + BEL_NUMINT + BEL_SEQUEN + BEL_CODGLO
	      If BEJ->( MsSeek(xFilial("BEJ")+BE4->(BE4_CODOPE+BE4_ANOINT+BE4_MESINT+BE4_NUMINT)) )
	         While ! BEJ->( Eof() ) .And. BEJ->(BEJ_FILIAL+BEJ_CODOPE+BEJ_ANOINT+BEJ_MESINT+BEJ_NUMINT) == ;
	                                       xFilial("BEJ")+BE4->(BE4_CODOPE+BE4_ANOINT+BE4_MESINT+BE4_NUMINT)
				    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				    //³Critica de Itens										 			       ³
				    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				    aCriticas := {}
				    If BEL->( MsSeek( xFilial("BEL")+BEJ->(BEJ_CODOPE+BEJ_ANOINT+BEJ_MESINT+BEJ_NUMINT+BEJ_SEQUEN) ) )
				    	While !BEL->( Eof() ) .And. BEL->(BEL_FILIAL+BEL_CODOPE+BEL_ANOINT+BEL_MESINT+BEL_NUMINT+BEL_SEQUEN) == ;
				    								 xFilial("BEL")+BEJ->(BEJ_CODOPE+BEJ_ANOINT+BEJ_MESINT+BEJ_NUMINT+BEJ_SEQUEN)
						   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						   //³ Matriz de itens															   ³
						   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						   If !Empty(BEL->BEL_CODGLO)
			                   AaDd(aCriticas,{	AllTrim(BEL->BEL_SEQUEN),; //Sequencia
			                   					AllTrim(BEL->BEL_CODGLO),; //Codigo Glosa
			                   					AllTrim(BEL->BEL_DESGLO),; 	//Tabela
			                   					AllTrim(BEL->BEL_INFGLO)} )	//Procedimento
			               EndIf
				        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				        //³ Skip																	    ³
				        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				        BEL->( DbSkip() )
				        EndDo
			       EndIf
		           //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		           //³ Procedimento																   ³
		           //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                   AaDd(aRet,{	AllTrim(BEJ->BEJ_CODPAD),; 										    //01-Tabela
                   			  	AllTrim(BEJ->BEJ_CODPRO),; 										    //02-Procedimento
                   			 	AllTrim(BEJ->BEJ_DESPRO),;											//03-Descricao
                   			 	Iif( BEJ->BEJ_QTDSOL==0 , AllTrim(Str(BEJ->BEJ_QTDPRO)) , AllTrim(Str(BEJ->BEJ_QTDSOL)) ) ,;//04-Qtd Solicitada
                   			 	Iif( BEJ->BEJ_STATUS=="1" , AllTrim(Str(BEJ->BEJ_QTDPRO)),"0"),;	//05-Qtd Realizada
                   			 	"0",;  	 															//06-Qtd Saldo
                   			 	Iif( BEJ->BEJ_AUDITO=="1","Sim","Não"),;						    //07-Auditoria
                   			 	Iif( BEJ->BEJ_STATUS=="1","Autorizado","Não Autorizado"),;			//08-Status
                   			 	aCriticas} )    		                                            //09-Criticas
	               BEJ->( DbSkip() )
	         EndDo
	      EndIf
		  //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		  //³ Itens da prorrogacao														 ³
		  //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	      BQV->( DbSetOrder(1) )//BQV_FILIAL + BQV_CODOPE + BQV_ANOINT + BQV_MESINT + BQV_NUMINT + BQV_SEQUEN
	      BQZ->( DbSetOrder(1) ) //BQZ_FILIAL + BQZ_CODOPE + BQZ_ANOINT + BQZ_MESINT + BQZ_NUMINT + BQZ_SEQUEN
	      If BQV->( MsSeek(xFilial("BQV")+BE4->(BE4_CODOPE+BE4_ANOINT+BE4_MESINT+BE4_NUMINT) ) )
	         While ! BQV->( Eof() ) .And. BQV->(BQV_FILIAL+BQV_CODOPE+BQV_ANOINT+BQV_MESINT+BQV_NUMINT) == ;
	                                       xFilial("BQV")+BE4->(BE4_CODOPE+BE4_ANOINT+BE4_MESINT+BE4_NUMINT)
				    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				    //³Critica de Itens										 			       ³
				    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				    aCriticas := {}
					If BQZ->( MsSeek( xFilial("BQZ")+BQV->(BQV_CODOPE+BQV_ANOINT+BQV_MESINT+BQV_NUMINT+BQV_SEQUEN) ) )
						While !BQZ->( Eof() ) .And. BQZ->(BQZ_FILIAL+BQZ_CODOPE+BQZ_ANOINT+BQZ_MESINT+BQZ_NUMINT+BQZ_SEQUEN) == ;
													 xFilial("BQZ")+BQV->(BQV_CODOPE+BQV_ANOINT+BQV_MESINT+BQV_NUMINT+BQV_SEQUEN)
						   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						   //³ Matriz de itens															   ³
						   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						   If !Empty(BQZ->BQZ_CODGLO)
			                   AaDd(aCriticas,{	AllTrim(BQZ->BQZ_SEQUEN),; //Sequencia
			                   					AllTrim(BQZ->BQZ_CODGLO),; //Codigo Glosa
			                   					AllTrim(BQZ->BQZ_DESGLO),; 	//Tabela
			                   					AllTrim(BQZ->BQZ_INFGLO)} )	//Procedimento
			               EndIf
				        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				        //³ Skip																	    ³
				        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				        BQZ->( DbSkip() )
				        EndDo
			        EndIf
			        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			        //³ Procedimento																³
			        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                    AaDd(aRet,{	AllTrim(BQV->BQV_CODPAD),; 										    //01-Tabela
                   			  	AllTrim(BQV->BQV_CODPRO),; 										    //02-Procedimento
                   			 	AllTrim(BQV->BQV_DESPRO),;											//03-Descricao
                   			 	Iif( BQV->BQV_QTDSOL==0 , AllTrim(Str(BQV->BQV_QTDPRO)) , AllTrim(Str(BQV->BQV_QTDSOL)) ) ,;//04-Qtd Solicitada
                   			 	Iif( BQV->BQV_STATUS=="1" , AllTrim(Str(BQV->BQV_QTDPRO)),"0"),;	//05-Qtd Realizada
                   			 	"0",;  	 															//06-Qtd Saldo
                   			 	Iif( BQV->BQV_AUDITO=="1","Sim","Não"),;						     //07-Auditoria
                   			 	Iif( BQV->BQV_STATUS=="1","Autorizado","Não Autorizado"),;			 //08-Status
                   			 	aCriticas} )    		                                             //09-Criticas
	         //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	         //³ Skip																		 ³
	         //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	         BQV->( DbSkip() )
	         EndDo
	      EndIf
          //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
          //³ Verfica se achou procediemntos											  ³
          //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	      If Len(aRet)==0
				lRetorno := .F.
				SetSoapFault( "", "Não existe procedimento para esta Guia" )
	      EndIf
	   Else
			lRetorno := .F.
			SetSoapFault( "", "Guia não encontrada" )
	   EndIf

	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Monta restorno														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	If ::TipoAut $ '07,08,09'
		aRetBox		:= RetSx3Box( X3CBox( Posicione('SX3',2,"B4A_STATUS",'X3_CBOX') ),,,Val(B4A->B4A_STATUS) )
	Else
		aRetBox		:= RetSx3Box( X3CBox( Posicione('SX3',2,"BEA_STATUS",'X3_CBOX') ),,,Val(BEA->BEA_STATUS) )
	Endif

	::MatComGui	:= {}
	For nI:=1 To Len( aRet )
		AaDd( ::MatComGui, WsClassNew( "SMatCompGui" ) )
		::MatComGui[nI]:RdaCode	:= cCodRdaP 							//1-Codigo da Rda
		::MatComGui[nI]:NomeUsu	:= cNomUsrP 							//2-Nome do Usuário
		::MatComGui[nI]:DtGui	:= cDatSolP   					//3-Dt da Autorizacao

		If (nPos := AsCan( aRetBox , {|x| AllTrim(x[2]) == cStatusP} ))>0
			::MatComGui[nI]:StaGui 	:= aRetBox[nPos,3] 						//4-Status Guia
		EndIf

		::MatComGui[nI]:Cancel 	:= Iif(cCancelP=="1","SIM","NÃO")	//5-Cancelada
		::MatComGui[nI]:CodTab 	:= aRet[nI,1]	    						//6-Tabela
		::MatComGui[nI]:CodPro 	:= aRet[nI,2]	   							//7-Codigo do procedimento
		::MatComGui[nI]:DesPro 	:= aRet[nI,3]	   		   					//8-Descricao procedimento
		::MatComGui[nI]:QtdSol 	:= aRet[nI,4]	   							//9-Qtd Solicitada
		::MatComGui[nI]:QtdRea 	:= aRet[nI,5]	   							//10-Qtd Realizada
		::MatComGui[nI]:QtdSal 	:= aRet[nI,6]	   							//11-Qtd Saldo
		::MatComGui[nI]:StaAud 	:= aRet[nI,7]	   		   					//12-Status Auditoria
		::MatComGui[nI]:StaPro 	:= aRet[nI,8]	   							//13-Status Procedimento
		::MatComGui[nI]:OnLine 	:= iIf(lPTUOn50,cOnLine,'0')				//14-Guia Online

		//Criticas

		aCriticas 				:= aRet[nI,9]
		::MatComGui[nI]:MatCri	:= {}
		For nY := 1 To Len( aCriticas )
			AaDd( ::MatComGui[nI]:MatCri, WsClassNew( "GenericStruct" ) )

			aRetCri := PLSRETCRI( AllTrim( aCriticas[nY,2] ) )

			If EMPTY(aRetCri[nI][2])
				aRetCri[1][1] := aCriticas[nI][2]
				aRetCri[1][2] := aCriticas[nI][3]
			EndIf

			::MatComGui[nI]:MatCri[nY]:Code		:= AllTrim( aRetCri[1,1] )
			::MatComGui[nI]:MatCri[nY]:Description := PadR( AllTrim( aRetCri[1,2] ),70 )
		Next
	Next
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Area																	   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa   ³ CancelaGuia      ³ Autor ³ Alexander Santos	³ Data ³ 29.05.07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao  ³ Cancelamento da Guia										  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
WSMETHOD CancelaGuia WSRECEIVE UserCode, NumAut, Motivo, Tipo WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 	:= .T.
LOCAL aArea		:= GetArea()
default ::Motivo := ''
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Data com 4 digitos													   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Set Century On
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "CancelaGuia" )
	SIX->( DbSetOrder(1) )
	If SIX->( MsSeek("BEAA") )
	   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	   //³ Posiciona no cabecalho               									   ³
	   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   BEA->( DbSetOrder(1) )//BEA_FILIAL + BEA_OPEMOV + BEA_ANOAUT + BEA_MESAUT + BEA_NUMAUT
	   If PlsAliasExi('B4A')
	   		B4A->( DbSetOrder(1) )
	   Endif
	   If BEA->( MsSeek(xFilial("BEA")+::NumAut) )
			::WSNULL := PLSA090CAN(.T.,::Motivo)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica o processamento do cancelamento								 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty(::WSNULL)
				::WSNULL := "false|"+::WSNULL
			Else
				::WSNULL:= "true|SIM"
			EndIf
	   ElseIF PlsAliasExi('B4A') .and. B4A->( MsSeek(xFilial("B4A")+::NumAut) )
	   		::WSNULL := PLSA09ACAN(.T.)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica o processamento do cancelamento								 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty(::WSNULL)
				::WSNULL := "false|"+::WSNULL
			Else
				::WSNULL:= "true|SIM"
			EndIf

	   ELSEIF (::Motivo == "RECOFF")  //Para cancelar o registro da BD5
	   		::WSNULL := PLSCNCGCOB(::NumAut,,,::Tipo)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica o processamento do cancelamento								 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty(::WSNULL)
				::WSNULL := "false|"+::WSNULL
			Else
				::WSNULL:= "true|SIM"
			EndIf

	   Else
			lRetorno := .F.
			SetSoapFault( "", "Guia não encontrada" )
	   Endif
	Endif
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Area																	   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa   ³ ExeDHInt         ³ Autor ³ Alexander Santos	³ Data ³ 06.03.10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao  ³ Data e hora da internacao									  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
WSMETHOD ExeDHInt WSRECEIVE UserCode, NumAut, DatInt, HorInt WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 	:= .T.
LOCAL aRet		:= {}
LOCAL aArea		:= GetArea()
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Data com 4 digitos													   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Set Century On
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "ExeDHInt" )
   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   //³ Posiciona no cabecalho               									   ³
   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   BE4->( DbSetOrder(2) )//BE4_FILIAL + BE4_CODOPE + BE4_ANOINT + BE4_MESINT + BE4_NUMINT
   If BE4->( MsSeek(xFilial("BE4")+::NumAut) )
		aRet 	 := PLSA92DtIn(.T.,::DatInt, ::HorInt)
		::WSNULL := aRet[1]
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica o processamento do cancelamento								 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !Empty(::WSNULL)
			::WSNULL := "false|"+::WSNULL
		Else
			::WSNULL:= "true|SIM|" + DtoC(aRet[2]) + "|" + aRet[3]
		EndIf
   Else
		lRetorno := .F.
		SetSoapFault( "", "Guia não encontrada" )
   EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Area																	   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa   ³ ExeDHAlt         ³ Autor ³ Roberto Vanderlei³ Data ³ 02.09.16 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao  ³ Data e hora da alta     									  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
WSMETHOD ExeDHAlt WSRECEIVE UserCode, NumAut, DatAlt,HorAlt,MotAlt   WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 	:= .T.
LOCAL cRet		:= ""
LOCAL aArea		:= GetArea()
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Data com 4 digitos													   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Set Century On
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "ExeDHAlt" )
   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   //³ Posiciona no cabecalho               									   ³
   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   BE4->( DbSetOrder(2) )//BE4_FILIAL + BE4_CODOPE + BE4_ANOINT + BE4_MESINT + BE4_NUMINT
   If BE4->( MsSeek(xFilial("BE4")+::NumAut) )
		cRet 	 := PLSADtAlt(.T.,::DatAlt, ::HorAlt, ::MotAlt)
		::WSNULL := cRet
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica o processamento do cancelamento								 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !Empty(::WSNULL)
			::WSNULL := "false|"+::WSNULL
		Else
			::WSNULL:= "true|SIM|"// + DtoC(aRet[2]) + "|" + aRet[3]
		EndIf
   Else
		lRetorno := .F.
		SetSoapFault( "", "Guia não encontrada" )
   EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Area																	   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa   ³ Elegibilidade    ³ Autor ³ Alexander Santos	³ Data ³ 29.05.07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao  ³ Elegibilidade do beneficiario								  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
WSMETHOD Elegibilidade WSRECEIVE UserCode, UserCardNumber WSSEND UserCard WSSERVICE PLSXFUN
LOCAL nI        := 1
LOCAL lRetorno 	:= .T.
LOCAL aRetorno	:= {}
LOCAL aArea		:= GetArea()
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Data com 4 digitos													   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Set Century On
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "Elegibilidade" )

	aRetorno := PLVLDUSRP( ::UserCardNumber,"" )

	If Len(aRetorno) > 0
		If aRetorno[1]
			::UserCard 					:= WsClassNew( "UserCardView" )
			::UserCard:CardNumber		:= aRetorno[3,1,1]
			::UserCard:CardNumberOld	:= aRetorno[3,1,2]
			::UserCard:CardName			:= Upper(aRetorno[3,1,3])
			::UserCard:Interchange		:= aRetorno[3,1,4]
			::UserCard:OpeOri	   	    := aRetorno[3,1,5]
			::UserCard:Plano	   	    := aRetorno[3,1,6]
			::UserCard:ValCar	   	    := aRetorno[3,1,7]
			::UserCard:NumCarNac	    := aRetorno[3,1,8]
			::UserCard:ViaCartao		:= aRetorno[3,1,9]
			::UserCard:LOCALCob			:= aRetorno[3,1,10]
			::UserCard:Abrange			:= aRetorno[3,1,11]
			::UserCard:NatJuri			:= aRetorno[3,1,12]
			::UserCard:Telefone			:= aRetorno[3,1,13]
			::UserCard:NomTit			:= aRetorno[3,1,14]
			::UserCard:NomEmp			:= aRetorno[3,1,15]
			::UserCard:Vida				:= aRetorno[3,1,16]
			::UserCard:Dig1				:= aRetorno[3,1,17]
			::UserCard:Dig2				:= aRetorno[3,1,18]
			If Len(aRetorno[3,1]) >= 22
				::UserCard:DatBlo          := aRetorno[3,1,22]
			EndIf

			If ExistBlock("PPLEXSTAT")
				::UserCard:StatusEl:= ExecBlock("PPLEXSTAT",.F.,.F.,{})
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Retorna Criticas do usuário											   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 		    ::UserCard:UserCritica 	:= {}
		    If Len(aRetorno[4]) > 0
	    	   For nI := 1 To Len( aRetorno[4] )
	  			   AaDd( ::UserCard:UserCritica, WsClassNew( "UserCardCri" ) )
				   ::UserCard:UserCritica[nI]:DesPri := aRetorno[4,nI,1]
				   ::UserCard:UserCritica[nI]:DesSeq := aRetorno[4,nI,2]
				   ::UserCard:UserCritica[nI]:DesTer := aRetorno[4,nI,3]
               Next
            EndIf
		Else
		   lRetorno := .F.
		   SetSoapFault( "", aRetorno[2] )
		EndIf
	Else
		lRetorno := .F.
		SetSoapFault( "", "Matricula não encontrada" )
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetBox    ³Autor  ³ Alexander Santos      ³ Data ³02.02.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina para alimentar matriz conforme o x3_box			   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetBox WSRECEIVE UserCode,Campos,ShowAnexo WSSEND RetBox WSSERVICE PLSXFUN
LOCAL nI	  		:= 0
LOCAL lRet    		:= .T.
LOCAL aArea	  		:= GetArea()
LOCAL aRet	  		:= {}
LOCAL cX3cBox       := NIL
LOCAL cStrCBox		:= NIL
DEFAULT ::ShowAnexo	:= '0'
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Checa rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "GetBox" )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta matriz conforme x3_box Tipo de pre atendimento				   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cX3cBox := GetSx3Cache(::Campos,"X3_CBOX")

	If SUBSTR(cX3cBox,1,1) == "#"

		cX3cBox := STRTRAN(SUBSTR(cX3cBox,2), " ", "")
		cStrCBox := &(cX3cBox)
	Else
		cStrCBox := ALLTRIM(cX3cBox)
	EndIf

	aRet := {}
	aRet := RetSx3Box( cStrCBox,,,1 )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Alimenta a estrutura												   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	::RetBox := {}
	If Len(aRet) > 0
	   For nI := 1 To Len( aRet )
			If !Empty(aRet[nI,3])
			   If (::Campos $ "BEA_TIPO") .and. ::ShowAnexo == '0' .and. alltrim(aRet[nI,2]) $ "7,8,9"
					loop
			   Endif
			   AaDd( ::RetBox, WsClassNew( "GenericStruct" ) )
			   ::RetBox[nI]:Code        := aRet[nI,2]
			   ::RetBox[nI]:Description := AllTrim(aRet[nI,3])
			EndIf
	   Next
	EndIf

Else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetVlrCo  ³Autor  ³ Alexander Santos      ³ Data ³02.02.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna o valor da co-participacao						   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetVlrCo WSRECEIVE UserCode,NumAut WSSEND RetCoPar WSSERVICE PLSXFUN
LOCAL lRet     	:= .T.
LOCAL aArea	   	:= GetArea()
LOCAL cExibeCo 	:= ""
LOCAL cExibeBa 	:= ""
LOCAL aVlrPF   	:= {}
LOCAL aRet		:= {}
LOCAL cMsg001	:= "Valor da Co-Participacao&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
LOCAL cMsg002	:= "Valor a ser pago direto a rede de atendimento&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
LOCAL cMsg003	:= "Valor da Co-Participacao&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
LOCAL cMsg004	:= "Valor da Compra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
LOCAL cMsg005	:= "Valor da Taxa Administracao&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
LOCAL cMsg006	:= "Valor Total da Co-Participacao&nbsp;R$:&nbsp;"
LOCAL cMsg007	:= "Valor total a ser pago direto a rede de atendimento&nbsp;R$:&nbsp;"
LOCAL cMsg008	:= "Valor Total da Co-Participacao&nbsp;R$:&nbsp;"
LOCAL cMsg009	:= "Valor Total da Compra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$:&nbsp;"
LOCAL cMsg010	:= "(*) Nao inclui valores de materiais e medicamentos.&nbsp;"
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Checa rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "GetVlrCo" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta matriz conforme x3_box Tipo de pre atendimento				   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cExibeCo := GetNewPar("MV_PLSEXPF","1")
	cExibeBa := GetNewPar("MV_PLSEXBT","1")
	If cExibeCo == "1"
		BEA->( DbSetOrder(1) )//BEA_FILIAL + BEA_OPEMOV + BEA_ANOAUT + BEA_MESAUT + BEA_NUMAUT + DTOS(BEA_DATPRO) + BEA_HORPRO
		If BEA->( MsSeek( xFilial("BEA")+::NumAut ) )
	    	BD5->( DbSetOrder(1) )//BD5_FILIAL + BD5_CODOPE + BD5_CODLDP + BD5_CODPEG + BD5_NUMERO + BD5_SITUAC + BD5_FASE + dtos(BD5_DATPRO) + BD5_OPERDA + BD5_CODRDA
	    	If BD5->(MsSeek(xFilial("BD5")+BEA->(BEA_OPEMOV+BEA_CODLDP+BEA_CODPEG+BEA_NUMGUI)))
				aVlrPF := PLSVALCOPA()
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta a estrutura												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aVlrPF) > 0
		   ::RetCoPar		  := WsClassNew( "SMatVlr" )
		   ::RetCoPar:ExibeCo := cExibeCo
		   ::RetCoPar:ExibeBa := cExibeBa
		   ::RetCoPar:GuiAco  := BEA->BEA_GUIACO
		   ::RetCoPar:VlrPF   := aVlrPF[1]
		   ::RetCoPar:VlrBPF  := aVlrPF[2]
		   ::RetCoPar:PercPF  := aVlrPF[3]
		   ::RetCoPar:VlrTPF  := aVlrPF[4]
		   ::RetCoPar:VlrTAD  := aVlrPF[5]
		   ::RetCoPar:PagRDA  := aVlrPF[6]
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Personalizacao das mensagens de co-participacao no portal pls		   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ExistBlock("PLSCOPGUI")
			   aRet := ExecBlock("PLSCOPGUI")
			EndIf
		   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		   //³ Mensagem customisada													  ³
		   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		   If Len(aRet) == 0
		   	  aRet :=  {{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""},{.T.,""}}
		   EndIf
		   ::RetCoPar:Msg001 := Iif( aRet[1,1], Iif( Empty(aRet[1,2]) ,cMsg001,aRet[1,2] ), "" )
		   ::RetCoPar:Msg002 := Iif( aRet[2,1], Iif( Empty(aRet[2,2]) ,cMsg002,aRet[2,2] ), "" )
		   ::RetCoPar:Msg003 := Iif( aRet[3,1], Iif( Empty(aRet[3,2]) ,cMsg003,aRet[3,2] ), "" )
		   ::RetCoPar:Msg004 := Iif( aRet[4,1], Iif( Empty(aRet[4,2]) ,cMsg004,aRet[4,2] ), "" )
		   ::RetCoPar:Msg005 := Iif( aRet[5,1], Iif( Empty(aRet[5,2]) ,cMsg005,aRet[5,2] ), "" )
		   ::RetCoPar:Msg006 := Iif( aRet[6,1], Iif( Empty(aRet[6,2]) ,cMsg006,aRet[6,2] ), "" )
		   ::RetCoPar:Msg007 := Iif( aRet[7,1], Iif( Empty(aRet[7,2]) ,cMsg007,aRet[7,2] ), "" )
		   ::RetCoPar:Msg008 := Iif( aRet[8,1], Iif( Empty(aRet[8,2]) ,cMsg008,aRet[8,2] ), "" )
		   ::RetCoPar:Msg009 := Iif( aRet[9,1], Iif( Empty(aRet[9,2]) ,cMsg009,aRet[9,2] ), "" )
		   ::RetCoPar:Msg010 := Iif( aRet[10,1], Iif( Empty(aRet[10,2]) ,cMsg010,aRet[10,2] ), "" )
		EndIf
	EndIf
Else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetContato³Autor  ³ Flavio S. Correa      ³ Data ³16.06.2009 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina Lista de Contatos TISS                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetContato WSRECEIVE UserCode, CompanyCode WSSEND TissContatos WSSERVICE PLSXFUN
LOCAL lRet 		:= .T.
LOCAL aArea 	:= GetArea()
LOCAL nI		:= 1
LOCAL aSx3Box	:= {}
LOCAL TipoPrest	:= ""

DEFAULT ::CompanyCode 	:= PLSINTPAD()

If PrtChkUser( ::UserCode, "PLSXFUN","GetContato" )

	If BIM->( FieldPos('BIM_CONTIS') ) > 0 .And. BIM->( FieldPos('BIM_TIPCOM') ) > 0 .And.;
	   BIM->( FieldPos('BIM_RG') ) > 0 .And. BIM->( FieldPos('BIM_ESPECI') ) > 0 .And. BIM->( FieldPos('BIM_SITE') ) > 0
		dbSelectArea("BA0")
		dbSelectArea("BIM")

		BA0->(dbSetOrder(1)) //BA0_FILIAL+BA0_CODIDE+BA0_CODINT
		BIM->(dbSetOrder(1))
		::TissContatos := {}

		aSx3Box := RetSx3Box( Posicione("SX3", 2, "BIM_TIPCOM", "X3CBox()" ),,, 1 )

		If BA0->(dbSeek(xFilial("BA0")+::CompanyCode))
			If BIM->(dbSeek(xFilial("BIM")+::CompanyCode))
				While !BIM->(Eof()) .And. BIM->(BIM_FILIAL+BIM_CODINT) == xFilial("BIM")+::CompanyCode
					If BIM->BIM_CONTIS == "1"
						aadd(::TissContatos,wsClassNew("ContatosTiss"))
						::TissContatos[nI]:Nome 		:= BIM->BIM_NOME

						TipoPrest	:= AllTrim( aSx3Box[Ascan( aSx3Box, { |aBox| aBox[2] = BIM->BIM_TIPCOM} )][3] )
						::TissContatos[nI]:TipoContato	:= TipoPrest

						::TissContatos[nI]:Telefone 	:= IIf(!Empty(BIM->BIM_RAMAL),BIM->BIM_TELCON + " - " + BIM->BIM_RAMAL,BIM->BIM_TELCON)
						::TissContatos[nI]:Email 		:= BIM->BIM_EMAIL
						::TissContatos[nI]:Site 		:= If(UPPER(Substr(Alltrim(BIM->BIM_SITE),1,4))=="HTTP",Alltrim(BIM->BIM_SITE),;
															"http://"+Alltrim(BIM->BIM_SITE))
						nI++
					EndIf
					BIM->(dbSkip())
				EndDo
			EndIf
		Else
			lRet := .F.
			SetSoapFault( "", "Operadora não encontrada" )
		EndIf

		If Len(::TissContatos) == 0
			lRet := .F.
			SetSoapFault( "", "Nenhum contato encontrado" )
		EndIf
	Else
		lRet := .F.
		SetSoapFault( "", "Verifique o dicionario de dados" )
	EndIf
Else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getProdutos³Autor  ³ Alexander Santos      ³ Data ³18.05.2010 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina Lista de Produtos 		                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD getProdutos WSRECEIVE UserCode WSSEND ListProdutos WSSERVICE PLSXFUN
LOCAL aArea 	:= GetArea()
LOCAL nI		:= 1
LOCAL lRet 		:= .T.
LOCAL cCondBI3  := IiF(BI3->(Fieldpos("BI3_PORTAL")) > 0,'BI3->BI3_STATUS == "1" .And. BI3->BI3_PORTAL <>"2" ','BI3->BI3_STATUS == "1"')
LOCAL cCodInt 	:= PlsIntPad()

DEFAULT ::RegPagina	:= 10
DEFAULT ::PaginaIni	:= 1
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se tem direito para executar o metodo								   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode , "PLSXFUN", "getProdutos" )

	::ListProdutos := {}
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Posiciona no produto da operadora									   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BI3->( dbSetOrder(1) )//BI3_FILIAL + BI3_CODINT + BI3_CODIGO + BI3_VERSAO
	If BI3->( dbSeek(xFilial("BI3")+cCodInt) )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Carrega os produtos													   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		While !BI3->(Eof()) .And. BI3->(BI3_FILIAL + BI3_CODINT) == xFilial("BI3")+cCodInt
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Filtro																   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If &(cCondBI3)
				AaDd( ::ListProdutos,wsClassNew("ProdutosList") )
				::ListProdutos[nI]:Codigo		:= BI3->BI3_CODIGO
				::ListProdutos[nI]:Versao		:= BI3->BI3_VERSAO
				::ListProdutos[nI]:Nome 		:= Alltrim(BI3->BI3_DESCRI)
				::ListProdutos[nI]:Abrangencia 	:= Posicione("BF7",1,xFilial("BF7")+BI3->BI3_ABRANG,"BF7_DESORI")
				::ListProdutos[nI]:Susep 		:= BI3->BI3_SUSEP
				::ListProdutos[nI]:Segmentacao 	:= Posicione("BI6",1,xFilial("BI6")+BI3->BI3_CODSEG,"BI6_DESCRI")
				::ListProdutos[nI]:NRegistro 		:= BI3->BI3_SCPA

				aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BI3_CLAPLS",'X3_CBOX') ),,,1 )
				If (nPos := AsCan( aRet , {|x| AllTrim(x[2]) == BI3->BI3_CLAPLS} ) ) > 0
					::ListProdutos[nI]:Classificacao := aRet[nPos,3]
			  	else
			  		::ListProdutos[nI]:Classificacao := " "
			  	EndIf

				aRet := RetSx3Box( X3CBox( Posicione('SX3',2,"BI3_SITANS",'X3_CBOX') ),,,1 )
				If (nPos := AsCan( aRet , {|x| AllTrim(x[2]) == BI3->BI3_SITANS} ) ) > 0
					::ListProdutos[nI]:Situacao := aRet[nPos,3]
				else
					::ListProdutos[nI]:Situacao := " "
			  	EndIf

				nI++
			EndIf
			BI3->( dbSkip() )
		EndDo
	EndIf
Else
	lRet := .F.
	SetSoapFault( "", "Usuário não autorizado" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim do metodo														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetPaginas ³Autor  ³ Alexander Santos      ³ Data ³18.05.2010 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina Total de Paginas da tabela Produto                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetPaginas WSRECEIVE RegPagina WSSEND QtdPaginas WSSERVICE PLSXFUN
LOCAL aArea 	:= GetArea()
LOCAL nI 		:= 0
LOCAL nRet		:= 0
LOCAL lRet 		:= .T.
LOCAL cSQL		:= ""
LOCAL cCodInt 	:= PlsIntPad()

DEFAULT ::RegPagina	:= 10
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se tem direito para executar o metodo								   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( "MSALPHA", "PLSXFUN","GetPaginas" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Query retorna quantidade de produtos									   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cSQL := "SELECT COUNT(*) AS QTD "
	cSQL += "  FROM " + RetSQLName("BI3")
	cSQL += " WHERE BI3_FILIAL = '" + xFilial("BI3") +"' "
	cSQL += "   AND BI3_CODINT = " + cCodInt
	cSQL += "   AND BI3_STATUS = '1' "
	cSQL += "   AND D_E_L_E_T_ <> '*' "

	If BI3->( Fieldpos("BI3_PORTAL") ) > 0
		cSQL += " AND BI3_PORTAL <> '2' "
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Executa query														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	OPEN QUERY cSQL ALIAS "GETPAGINAS"

	::QtdPaginas := 0
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Quantidade de paginas												   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If !GETPAGINAS->( Eof() )
    	nI	:= GETPAGINAS->QTD
		nRet:= mod(nI, ::RegPagina)

		If nRet > 0
			::QtdPaginas := Int(nI / ::RegPagina)+1
		Else
			::QtdPaginas := Int(nI / ::RegPagina)
		EndIf
    Else
		lRet := .F.
		SetSoapFault( "", "Nenhum Produto encontrado" )
    EndIf

    CLOSE QUERY "GETPAGINAS"
Else
	lRet := .F.
	SetSoapFault( "", "Usuário não autorizado" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim do Metodo														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetLinks	³Autor  ³ Flavio S. Correa      ³ Data ³22.06.2009 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina Lista de Links 		                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetLinks WSRECEIVE UserCode, CompanyCode, TipoLink WSSEND ListLinks WSSERVICE PLSXFUN
LOCAL lRet 		:= .T.
LOCAL aArea 	:= GetArea()
LOCAL nI		:= 1

DEFAULT ::CompanyCode	:= PLSINTPAD()
DEFAULT ::TipoLink		:= "1"

If PrtChkUser( ::UserCode, "PLSXFUN","GetLinks" )

	If PLSALIASEXI("B0F") .And. B0F->( FieldPos("B0F_CODIGO") ) > 0 .And. B0F->( FieldPos("B0F_CODINT") ) > 0
		dbSelectArea("BA0")
		dbSelectArea("B0F")

		BA0->(dbSetOrder(1))//BA0_FILIAL+BA0_CODIDE+BA0_CODINT
		B0F->(dbSetOrder(1))

		::ListLinks := {}

		If BA0->(dbSeek(xFilial("BA0")+::CompanyCode))
			If B0F->(dbSeek(xFilial("B0F")+::CompanyCode))
				While !B0F->(Eof()) .And. B0F->(B0F_FILIAL+B0F_CODINT) == xFilial("B0F")+::CompanyCode
					If B0F->B0F_TIPO == ::TipoLink

						aadd(::ListLinks,wsClassNew("LinksList"))
						::ListLinks[nI]:Codigo 	  	:= B0F->B0F_CODIGO
						::ListLinks[nI]:Descricao	:= Alltrim(B0F->B0F_DESCRI)
						::ListLinks[nI]:Link	 	:= If(UPPER(Substr(Alltrim(B0F->B0F_LINK),1,4))=="HTTP",Alltrim(B0F->B0F_LINK),;
						"http://"+Alltrim(B0F->B0F_LINK))
						nI++

					EndIf
					B0F->(dbSkip())
				EndDo
			EndIf
		Else
			lRet := .F.
			SetSoapFault( "", "Operadora não encontrada" )
		EndIf

		If Len(::ListLinks) == 0
			lRet := .F.
			SetSoapFault( "", "Nenhum link encontrado" )
		EndIf
	Else
		lRet := .F.
		SetSoapFault( "", "Tabela B0F não encontrada na base de DADOS" )
	EndIf
Else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetBD6	³Autor  ³ Alexander Santos      ³ Data ³13.04.2010 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna a dados do BD6									   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetBD6 WSRECEIVE UserCode,NumPeg  WSSEND MatBD6 WSSERVICE PLSXFUN
LOCAL nI		:= 1
LOCAL aMatBD6 	:= {}
LOCAL aArea 	:= GetArea()
LOCAL lRet 		:= .T.
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Checa rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN","GetBD6" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega BD6															   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aMatBD6 := PLSCARBD6(::NumPeg)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega Estrutura													   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	::MatBD6 := {}
	If Len(aMatBD6) > 0
	   For nI := 1 To Len( aMatBD6 )

		   AaDd( ::MatBD6, WsClassNew( "SMatBD6" ) )

		   ::MatBD6[nI]:seqinf := aMatBD6[nI,1]
		   ::MatBD6[nI]:sequen := aMatBD6[nI,2]
		   ::MatBD6[nI]:codpad := aMatBD6[nI,3]
		   ::MatBD6[nI]:codpro := aMatBD6[nI,4]
		   ::MatBD6[nI]:qtdpro := aMatBD6[nI,5]
		   ::MatBD6[nI]:orimov := aMatBD6[nI,6]
		   ::MatBD6[nI]:procci := aMatBD6[nI,7]
		   ::MatBD6[nI]:recno  := aMatBD6[nI,8]
		   ::MatBD6[nI]:denreg := aMatBD6[nI,9]
		   ::MatBD6[nI]:fadent := aMatBD6[nI,10]
		   ::MatBD6[nI]:datpro := aMatBD6[nI,11]

	   Next
	EndIf
Else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getFList   ³Autor  ³ Totvs 				 ³ Data ³20.02.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Lista de arquivos xml											³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD getFList WSRECEIVE UserCode, RegPagina, PaginaIni, RDACode WSSEND ListArquivos WSSERVICE PLSXFUN
LOCAL aArea 	:= GetArea()
LOCAL nI		:= 1
LOCAL nSkip		:= 0
LOCAL nQtdPag	:= 0
LOCAL lRetorno	:= .T.
LOCAL cCodInt 	:= PlsIntPad()

DEFAULT ::RegPagina		:= 10
DEFAULT ::PaginaIni		:= 1
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se tem direito para executar o metodo								   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode , "PLSXFUN","getFList" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Quantidade de registro que deve pular								   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PLSALIASEXI("BXX") .and. BXX->(FieldPos("BXX_CODPEG")) > 0
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³Retorna a quantidade de paginas
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		nQtdPag := getRegPag("BXX"," WHERE BXX_FILIAL = '" + xFilial("BXX") + "' AND BXX_CODINT = '" + cCodInt + "' AND BXX_CODRDA = '" + ::RDACode + "' AND BXX_TPNFS = '1' AND D_E_L_E_T_ = ' ' AND BXX_DATMOV >= '"+dtos(dDatabase-GetNewPar("MV_PLDIXML",30))+"' ",::RegPagina)[1]
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³nSkip
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	 	nSkip := (::RegPagina * ::PaginaIni) - ::RegPagina
		::ListArquivos := {}
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³Posiciona no arquivo da rda
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		cSql := " select R_E_C_N_O_ REC from "+RetSqlName("BXX")
		cSql += " where "
		cSql += " BXX_FILIAL = '"+xFilial("BXX")+"' "
		cSql += " AND BXX_CODINT = '"+cCodInt+"' "
		cSql += " AND BXX_CODRDA = '"+::RDACode+"' "
		cSql += " AND BXX_TPNFS = '1' "
		cSql += " AND BXX_DATMOV >= '"+dtos(dDatabase-GetNewPar("MV_PLDIXML",30))+"'"
		cSql += " AND D_E_L_E_T_ = ' ' "
		cSql += " ORDER BY R_E_C_N_O_ desc"
		PlsQuery(cSql,'trbBXX')

		If trbBXX->(!Eof())
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Elemina registros ja mostrados										   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			//If nSkip > 0
				//trbBXX->( dbSkip(nSkip) ) // dbSkip(X) estava falhando
			//EndIf
			If ::PaginaIni > 1
				While nI <= nSkip
					trbBXX->( dbSkip() )
					nI++
				EndDo
				nI := 1
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Carrega os arquivos do usuario										   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			While !trbBXX->( Eof() )
				
				BXX->(DbGoTo(trbBXX->REC))
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Filtro																   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				AaDd( ::ListArquivos,wsClassNew("ArquivosList") )
				::ListArquivos[nI]:Data			:= BXX->BXX_DATMOV
				::ListArquivos[nI]:NomeArqIn	:= BXX->BXX_ARQIN
				::ListArquivos[nI]:ArquivoIn	:= BXX->BXX_ARQIN
				::ListArquivos[nI]:ArquivoOut 	:= AllTrim(BXX->BXX_ARQOUT)
				::ListArquivos[nI]:Status 		:= BXX->BXX_STATUS
				::ListArquivos[nI]:DesSta 		:= PLSTXTSX3("BXX_STATUS",BXX->BXX_STATUS)
				::ListArquivos[nI]:QtdPag 		:= nQtdPag
				::ListArquivos[nI]:CodPeg 		:= If(Empty(BXX->BXX_CODPEG),space(tamsx3("BXX_CODPEG")[1]),BXX->BXX_CODPEG)
				::ListArquivos[nI]:tpArq 		:= BXX->BXX_TPARQU
				::ListArquivos[nI]:Sequen 		:= BXX->BXX_SEQUEN
				nI++
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Verifica registros por paginas										   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If nI > ::RegPagina
					Exit
				EndIf
				trbBXX->( dbSkip() )
			EndDo
		EndIf
		trbBXX->(DbCloseArea())
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se existe registros													   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Len(::ListArquivos) == 0
		lRetorno := .F.
		SetSoapFault( "", "Nenhum registro encontrado" )
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim do metodo														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³IncXmlUp   ³Autor  ³ Totvs 				 ³ Data ³20.02.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de inclusao de arquivo de Upload						³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD IncXmlUp WSRECEIVE UserCode, UserPlsName, DirArqIn, RDACode WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno		:= .T.
LOCAL aArea 		:= GetArea()
LOCAL cUpldPath		:= getWebDir("UPLOADPATH")
LOCAL cDirRaiz 		:= PLSMUDSIS( GetNewPar("MV_TISSDIR","\TISS\") )
LOCAL cDirWeb		:= PLSMUDSIS( cDirRaiz+"UPLOAD\")//getWebDir("UPLOADPATH")
Local cPartArq		:= ::RDACode + "_" + Alltrim(Str(month(date()))) + "_" + ( Alltrim(Str(Year(date()))) ) + "_" +;
                       Left(Time(),2) + "_" + Substr(Time(),4,2) + "_" + Right(Time(),2)
Local nI				:= 0
Local lExit1			:= .F.
Local lExit2			:= .F.
Local aFilReal	:= {}
Local lRename		:= .F.
Local nRename		:= -1
DEFAULT ::WSNULL 	:= ""

cNomeArq1 	:= Lower( AllTrim( SubStr( ::DirArqIn, Rat(PLSMUDSIS('\'),::DirArqIn)+1) ) )
//Copia nome Arquivo para montar nome exibição
cNomeExibe := cNomeArq1
//Pega a extensão do arquivo
cExtArq	:= SubStr(cNomeArq1, RAT(".", cNomeArq1)+1)
//Monta nome de exibição
cNomeExibe := SubStr(cNomeExibe, 1, RAT(".", cNomeExibe)) + cExtArq
//Pega o nome do arquivo
cNomeArq1	:= SubStr(cNomeArq1, 1, RAT(".", cNomeArq1)-1)
//Renomeia o aruqivo para nome nome + data atual + horário atual
//às vezes não dava tempo de renomear o arquivo, então tentamos umas vezes mais
while (nRename == -1 .AND. nI < 1000)
	nRename := FRename(cDirWeb+cNomeArq1+"."+cExtArq, cDirWeb+cNomeArq1+"_"+cPartArq+"."+cExtArq)
	nI++
EndDo

::DirArqIn := cDirWeb+cNomeArq1+"_"+cPartArq+"."+cExtArq

If PrtChkUser( ::UserCode ,"PLSXFUN","IncXmlUp" )
	
	If nRename <> -1 //Se não conseguiu renomear, solicitamos um novo envio
		::WSNULL := PLSINALUP(::UserPlsName, ::RDACode,.T.,.T.,::DirArqIn) //cDirWeb+cNomeArq1+"_"+cPartArq+"."+cExtArq)
	Else
		::WSNULL := "Ocorreu um erro no envio do arquivo, por favor tente novamente"
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ProcUpXml  ³Autor  ³ Totvs 				 ³ Data ³20.02.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de processamento do arquivo xml Upload					³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ProcUpXml WSRECEIVE UserCode, UserPlsName, DirArqIn, RDACode WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno	 	:= .T.
LOCAL aArea 		:= GetArea()
LOCAL aRet			:= {}
DEFAULT ::WSNULL	:= "true|"
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se tem direito para executar o metodo								   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode ,"PLSXFUN","ProcUpXml" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Faz a gravacao do arquivo de saida										 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	::WSNULL := PLSINALUP(::UserPlsName, ::RDACode, .T., .F., ::DirArqIn,aRet)
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim do metodo														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getGAT    ³Autor  ³ Totvs			        ³ Data ³06.07.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Gatilho de campo											   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD getGAT WSRECEIVE UserCode, UserPlsCode, TpPor, VldGen, FunName, Chave, Tp, TipGui WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno	:= .T.
LOCAL nI		:= 0
LOCAL aArea 	:= GetArea()
LOCAL aRet		:= {}
DEFAULT ::TipGui  := ''
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Se tem direito para executar o metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
If PrtChkUser( ::UserCode ,"PLSXFUN","getGat" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Retira mascara do conteudo da chave
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	::Chave := PLRETCARS(::Chave)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Executa rotina generica (gatilho)
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	aRet := ExecBlock(::FunName, .F., .F., { ::Chave, ::Tp, ::UserPlsCode ,::TpPor ,::VldGen,::TipGui } )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Retorno
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	aRet := WCGatField(aRet)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Devolve os campos em vazio para limpar a tela
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	For nI:=1 To Len(aRet)
		::WSNULL += aRet[nI]
	Next
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Fim do metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³setSolCar ³Autor  ³ Totvs			        ³ Data ³06.07.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Solicitacao de Carteirinha								   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD setSolCar WSRECEIVE UserCode, MatUsu, MotCar WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno	:= .T.
LOCAL nI		:= 0
LOCAL aArea 	:= GetArea()
LOCAL aRet		:= {}

DEFAULT ::WSNULL := ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Se tem direito para executar o metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
If PrtChkUser( ::UserCode ,"PLSXFUN","setSolCar" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Retira mascara do conteudo da chave
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	::MatUsu := PLRETCARS(::MatUsu)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Executa rdmake
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	aRet := ExecBlock('PLSPROSC', .F., .F., { ::MatUsu, ::MotCar } )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Se falha no processamento
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	If !aRet[1]

		::WSNULL += "false|Processamento não foi Efetivado|"

		For nI:=1 To Len(aRet[2])
	        ::WSNULL += WCTextNeg(aRet[2,nI,1] + " - " + aRet[2,nI,2],.F.)
		Next

	Else
		::WSNULL += "true|Processado com Sucesso|"+ Chr(13)+Chr(10) + aRet[2]
	EndIf

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Fim do metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getDadGrid³Autor  ³ Totvs			        ³ Data ³06.07.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retonar dados para a gridData								   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD getDadGrid WSRECEIVE userCode, funName, where, buscaTReg, paginaIni, pesquisa, semaforo, camposCustom WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL aArea 	:= getArea()
LOCAL lRetorno	:= .t.
LOCAL lContinua	:= .t.
LOCAL nQtd		:= (::PaginaIni-1)
LOCAL nRecPes	:= 0
LOCAL nI		:= 0
LOCAL nQtdPag 	:= 0
LOCAL nSkip		:= 0
LOCAL nPos		:= 0
LOCAL nQtdReg 	:= 1
LOCAL nPaginaAtu:= 0
LOCAL nH		:= 0
LOCAL nW 		:= 0
LOCAL nPosSel	:= 0
LOCAL lResetVar	:= .f.
LOCAL lCSemafo	:= .f.
LOCAL cBtnPos	:= ""
LOCAL cAlias	:= ""
LOCAL cTitulo	:= ""
LOCAL cSql		:= ""
LOCAL cMsg		:= ""
LOCAL cPesquisa	:= ""
LOCAL xHeader 	:= "[{}]"
LOCAL xCols		:= "[]"
LOCAL cWhere	:= ""
LOCAL cFieldJ	:= ""
LOCAL bFilPes	:= ""
LOCAL aRet		:= {}
LOCAL aFieldInfo:= {}
LOCAL lNoIdeLine := .F.
//Vetor aAlisNExt: em SQL UNION, quando não existe a coluna em alguma tabela, passar o alias da coluna
//principal e o nome do apelido, para que seja substituido na rotina e traga o valor correto, evitando NIL
Local aAlisNExt  := {}
DEFAULT ::WSNULL 	:= ""
DEFAULT ::pesquisa 	:= ""
DEFAULT ::semaforo  := ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Se tem direito para executar o metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
if prtChkUser( ::UserCode, "PLSXFUN", "getDadGrid" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³se recebe o semaforo devo verificar se e possivel fazer a consulta
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	if !empty(::semaforo)
		nH := PLSAbreSem(::semaforo, .f.)
		if nH == 0
			cMsg := "Favor aguardar o termino do processamento que esta em andamento!"
			lResetVar := .t.
			lCSemafo := .t.
		else
			PLSFechaSem(nH,::semaforo)
		endIf
	endIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Executa rotina generica dados para brw gridData
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	if !lCSemafo
		aRet       := execBlock(::funName, .f., .f., { ::Where, ::camposCustom } )
		cAlias     := aRet[01]
		cSql       := aRet[02]
		cWhere     := aRet[03]
		nRegPagina := aRet[04]
		aFieldInfo := getIField( aRet[05] )
		cFieldJ    := aRet[06]
		cPesquisa  := iIf(len(aRet)>06,aRet[07],"")
		cAlias1    := iIf(len(aRet)>07,aRet[08],"")
		cSql1      := iIf(len(aRet)>08,aRet[09],"")
		cWhere1    := iIf(len(aRet)>09,aRet[10],"")
		lNoIdeLine := iIf(len(aRet)>10,aRet[11],.F.)
		cCmpCbox   := iIf(len(aRet)>11,aRet[12],"")
		cAlias2    := iIf(len(aRet)>12,aRet[13],"")
		cSql2      := iIf(len(aRet)>13,aRet[14],"")
		cWhere2    := iIf(len(aRet)>14,aRet[15],"")
		aAlisNExt  := iIf(len(aRet)>15,aRet[16],"")
		cAlias3    := iIf(len(aRet)>16,aRet[17],"")
		cSql3      := iIf(len(aRet)>17,aRet[18],"")
		cWhere3    := iIf(len(aRet)>18,aRet[19],"")
		cAlias4    := iIf(len(aRet)>19,aRet[20],"")
		cSql4      := iIf(len(aRet)>20,aRet[21],"")
		cWhere4    := iIf(len(aRet)>21,aRet[22],"")	
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³Se faz a busca por quantidade de registros e paginas
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If ::BuscaTReg == '1'
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³Retorna a quantidade de registros
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			aRet := getRegPag(cAlias,cWhere,nRegPagina,cFieldJ)

			nQtdPag := aRet[1]
			nQtdReg := aRet[2]
			
			If ! Empty(cSql1)
				aRet 	:= getRegPag(cAlias1,cWhere1,nRegPagina,/*cFieldJ*/,.T.)
				nQtdReg += aRet[2]
			Endif

			If ! Empty(cSql2)
				aRet 	:= getRegPag(cAlias2,cWhere2,nRegPagina,/*cFieldJ*/,.T.)
				nQtdReg += aRet[2]
			Endif

			If ! Empty(cSql3)
				aRet 	:= getRegPag(cAlias3,cWhere3,nRegPagina,/*cFieldJ*/,.T.)
				nQtdReg += aRet[2]
			Endif

			If ! Empty(cSql4)
				aRet 	:= getRegPag(cAlias4,cWhere4,nRegPagina,/*cFieldJ*/,.T.)
				nQtdReg += aRet[2]
			Endif

			//	Calcula a quantidade real de Páginas
			nI 		:= Mod(nQtdReg, nRegPagina)
			nQtdPag := Int(nQtdReg / nRegPagina)
			nQtdPag += Iif(nI > 0, 1 ,0)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ aHeader
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			xHeader := "["
			
			For nI := 1 To Len(aFieldInfo)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³ Verifica se foi informado funcao de tratamento na linha
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				cTitulo := aFieldInfo[nI,1]
				If (nPos := At('#',cTitulo) ) > 0
					cTitulo := SubStr(cTitulo, (nPos+1), Len(cTitulo) )
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³ Cabecalho
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				xHeader += "{name:'" + cTitulo + "'}" + Iif( Len(aFieldInfo) != nI ,",","]" )
			Next
			
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³Monta cabecalho e item
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If nQtdReg > 0
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³verifica se o idenfificador de linha "IDENLINHA" foi inserido na query
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			if ! empty(cAlias) .and. at("IDENLINHA",cSql) == 0 .and. ! lNoIdeLine
				nPosSel	:= at('SELECT',upper(cSql))
				cSql 	:= subStr(cSql,nPosSel,7) + retSQLName(cAlias) + ".R_E_C_N_O_ IDENLINHA, " + substr(cSql,nPosSel+7)
			endIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³Executa query
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			OPEN QUERY cSQL ALIAS "GETDADGRID"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ verifica se tem pesquisa
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			if ! empty(::Pesquisa)
				bFilPes 	:= {|| &(::Pesquisa) }
				cPesquisa 	:= "'" + cPesquisa + "' "
				GETDADGRID->(dbSetFilter(bFilPes, ::Pesquisa))
				GETDADGRID->(dbGoTop())
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³ filtro nao encontrou dados da pesquisa
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				if GETDADGRID->(eof())
					lContinua := .f.
				else
					nRecPes := GETDADGRID->(recno())
					GETDADGRID->(dBClearFilter())
					GETDADGRID->(dbGoTop())
				endIf
			else
				nRecPes := nRegPagina	//	Serve para ajudar no calculo da página atual na Consulta Status Autorização
			endIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Alimenta a matriz
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			if lContinua
				if !GETDADGRID->(eof())
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³ Abre matriz aCols
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					xCols := "["
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³Quantidade de registro que deve pular ja contando o registro de pesquisa em qual pagina foi encontrado
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					if nRecPes > 0
						nPaginaAtu := ::PaginaIni + iIf( mod(nRecPes, nRegPagina) > 0, int(nRecPes / nRegPagina), int(nRecPes / nRegPagina)-1 )
						nSkip := (nRegPagina *  nPaginaAtu ) - nRegPagina
					else
						nSkip := (nRegPagina * ::PaginaIni ) - nRegPagina
					endIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³Elimina registros
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					/*if nSkip > 0
						GETDADGRID->( dbSkip(nSkip) )
					endIf*/
					//fiz isso poruqe por algum motivo o dbskip(numero) parou de funcionar
					for nW := 1 to nSkip
						GETDADGRID->( dbSkip() )
					next nW
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³ while do resultado
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					while !GETDADGRID->(eof())
						nQtd++

						if nQtd <= ((::PaginaIni + nRegPagina)-1)
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
							//³ aCols
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
							xCols += "{"
							for nI := 1 to len(aFieldInfo)
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
								//³ Verificando se tem alguma coluna especial (bottons)
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
								cBtnPos := aFieldInfo[nI,1]
								if (nPos := at('#',cBtnPos) ) > 0
									cBtnPos := subStr(cBtnPos, 1, nPos )
								else
									cBtnPos := ""
								endIf
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
								//³ Monta acols
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
								For nH := 1 TO Len(aAlisNExt)  //Nos casos onde no SQL Union, não existe a coluna em determinada tabela, para evitar erro de Nil.
									IF (aFieldInfo[nI,2] == aAlisNExt[nH,1])
										aFieldInfo[nI,2] := aAlisNExt[nH,2]
									ENDIF
								Next
								//Verifico se a guia foi criada no Digitação de guias e se o BD5_NUMAUT está vazio
								If 'BD5_NUMAUT' $ aFieldInfo[nI,2] .and. Empty(GETDADGRID->BD5_NUMAUT)
									aFieldInfo[nI,2] := StrTran( aFieldInfo[nI,2], "BD5_NUMAUT", "BD5_NUMERO")
								EndIf
								
								__SetCentury( "on" ) //coloquei aqui pois quando o campo tem ALIAS, o sistema não acha no SX3 e não pega o tipo e ai precisa fazer o DTOC la no cCampo da query
								
								if aFieldInfo[nI,2] $ "RECNO,R_E_C_N_O_"

									xCols += cValToChar((nI-1)) + ":{field:'"+aFieldInfo[nI,2]+"', value:'" + cBtnPos + IIF(ValType(GETDADGRID->&(aFieldInfo[nI,2]))=='N',allTrim(cValToChar(GETDADGRID->&(aFieldInfo[nI,2]))),allTrim(GETDADGRID->&(aFieldInfo[nI,2]))) + "'} " + Iif( Len(aFieldInfo) != nI ,",","" )
										
								else	
									xCols += cValToChar((nI-1)) + ":{field:'"+aFieldInfo[nI,2]+"', value:'" + cBtnPos + getFMask(GETDADGRID->&(aFieldInfo[nI,2]), aFieldInfo[nI,3], aFieldInfo[nI,4], aFieldInfo[nI,2], IIf(aFieldInfo[nI,2] $ cCmpCbox, AllTrim( X3CBox(Posicione('SX3' , 2 ,cCmpCbox,'X3_CBOX')) ),"")) + "'} " + Iif( Len(aFieldInfo) != nI ,",","" )
								endif
								
								__SetCentury( "Off" )
							next
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
							//³ verifica se tem o campo na area de trabalho
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
							if GETDADGRID->(fieldPos("IDENLINHA"))>0
								If GETDADGRID->(fieldPos("ALIAS"))>0
									xCols += "," + cValToChar((nI-1)) + ":{field: 'IDENLINHA', value:'" + alltrim(GETDADGRID->ALIAS)+allTrim(cValToChar(GETDADGRID->IDENLINHA)) + "'} "
								Else
									xCols += "," + cValToChar((nI-1)) + ":{field: 'IDENLINHA', value:'" + allTrim(cValToChar(GETDADGRID->IDENLINHA)) + "'} "
								Endif
							endIf
							xCols +=  "},"
						else
							exit
						endIf

						GETDADGRID->( dbSkip() )
					endDo
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³ Fecha matriz
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					xCols := iif(xCols == "[", xCols + "]",left( xCols,len(xCols)-1 ) + "]")
				endIf
			else
				lContinua 	:= .f.
				cMsg 		:= "Conteudo da pesquisa não encontrado!"
			endIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Fecha area de trabalho
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			CLOSE QUERY "GETDADGRID"
		Else
			cMsg := "Não existe registro para esta consulta!"
			lResetVar := .t.
		endIf
	endIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ limpa conteudo de retorno
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	if lResetVar
		xHeader := "[{}]"
		nQtdReg := 0
		nQtdPag := 0
		nRegPagina := 0
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Retorno
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	::WSNULL := "true|" + cValToChar(nQtdReg) + "|" + cValToChar(nQtdPag) + "|" + cValToChar(nRegPagina) + "|" + xHeader + "|" +	xCols + "|" + cMsg + "|" + iIf(lContinua,'true','false') + "|" + cValToChar(nPaginaAtu) + "|" + cPesquisa + "|" + iIf(lCSemafo,'true','false') + "|"
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf
RestArea( aArea )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Fim do metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return lRetorno

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VerDtGuia  ³Autor ³ Roberto Vanderlei     ³ Data ³21.07.2016 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Validação para geração de peg de guias do portal			   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VerDtGuia WSRECEIVE Chave,Tipo, userCode, TipGui WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL aArea 	:= getArea()
LOCAL lRetorno	:= .T.
LOCAL nQtdDias 	:= getNewPar("MV_PLDRETR",90)
LOCAL dDtMin    := daySub(Date(), nQtdDias)
LOCAL dDtAtend	:= 0
LOCAL aGuias	:= {}
LOCAL nI		:= 0
LOCAL cRetorno	:= "true|"
LOCAL cContador := 0
local cRecno	:= 0
Local cAlias	:= Iif ( (Valtype(::TipGui) == 'U') .Or. ::TipGui <> "05", "BD5", "BE4" ) 
Local cFinal	:= Iif ( (Valtype(::TipGui) == 'U') .Or. ::TipGui <> "05", "AUT", "INT" ) 
Local cOperad	:= Iif ( (Valtype(::TipGui) == 'U') .Or. ::TipGui <> "05", "_OPEMOV", "_CODOPE" ) 

DEFAULT ::WSNULL := ""

//Se tem direito para executar o metodo
if PrtChkUser( ::userCode ,"PLSXFUN","VerDtGuia" )

	cRetorno += str(nQtdDias) + "|"

	if ::Tipo = "D" .or. ::Tipo = "'D'"//Digitação Offline

		aGuias	:= strToArray( ::Chave , ';')

		For nI := 1 To Len( aGuias )

			dDtAtend := strToArray(aGuias[nI], '$')[2]

			if ctod(dDtAtend) <= dDtMin
			 	cContador := cContador +  1
				cRetorno += aGuias[nI] + ";"
			endif
			
		next

	else
	
		aGuias := strToArray( ::Chave , ',')

		//Posiciona nos Recnos para verificar data de atendimento e afins.
		for nI := 1 to len(aGuias)

			cRecno := aGuias[nI]

			cSQL := "SELECT " + cAlias + "_DATPRO DATPRO," + cAlias + cOperad + " OPEMOV, " + cAlias + "_ANO" + cFinal + " ANOAUT, " + cAlias + "_MES" + cFinal + " MESAUT, " + cAlias + "_NUM" + cFinal + " NUMAUT "
			cSQL += "   FROM " + retSQLName(cAlias)
			cSQL += " WHERE R_E_C_N_O_ = " + cRecno
			cSQL += "    AND D_E_L_E_T_ = ''"

			dbUseArea(.T.,"TOPCONN",TCGENQRY(,,ChangeQuery(cSql)),"TrbBD5",.F.,.T.)

			If !TrbBD5->(EOF())

				TCSETFIELD("TrbBD5","DATPRO","D",08,0)

				if TrbBD5->DATPRO <= dDtMin
				 	cContador := cContador +  1
					cRetorno  += cRecno +  "$" + dtoc(TrbBD5->DATPRO) + "$" + TrbBD5->OPEMOV + TrbBD5->ANOAUT + TrbBD5->MESAUT + TrbBD5->NUMAUT +  ";"
				endif

			Else

				FWLogMsg('WARN',, 'SIGAPLS', funName(), '', '01',"Não achou !" , 0, 0, {})

			EndIf

			TrbBD5->(dbCloseArea())

		next

	endif

	if cContador = Len( aGuias )
		cRetorno += "|" + "T"
	else
		cRetorno += "|" + "P"
	endif
else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
endIf

::WSNULL := cRetorno

restArea( aArea )

Return lRetorno

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³setTFGuia  ³Autor ³ Totvs			        ³ Data ³06.07.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Inclusao de peg de guias do portal						   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD setTFGuia WSRECEIVE userCode, matPeg WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL aArea 	:= getArea()
LOCAL nH 		:= 0
LOCAL lRetorno	:= .t.
LOCAL lContinua	:= .t.
LOCAL lExcluiPEG	:= .t.
LOCAL aMat		:= strToArray( matPeg:where , '|' )
Default matPeg:funName	:= ""  //Se vazio, vem da geração normal da peg no portal.

DEFAULT ::WSNULL := ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Se tem direito para executar o metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
if PrtChkUser( ::userCode ,"PLSXFUN","setTFGuia" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ cria protocolo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	nH := PLSAbreSem(matPeg:semaforo,.f.)
	if nH == 0
		::WSNULL := "true|Favor aguardar o termino do processamento que esta em andamento!"
	else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ fecha semaforo
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		PLSFechaSem(nH,matPeg:semaforo)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ quanto nao mostra as guias no portal deve verificar se existe registro para selecao
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If matPeg:gerPeg .and. !matPeg:mosGui
			lContinua := PLSVDPEGU(aMat)
		ElseIf !matPeg:gerPeg
			lExcluiPEG := PLSDELPEG(aMat) //verifica se a PEG pode ser excluida
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ se existe registro
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If lContinua .and. lExcluiPEG
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ transfere as guias
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			PLSPEGGUI(aMat,matPeg:colsCk,matPeg:colsUnCk,matPeg:semaforo,matPeg:mosGui, matPeg:funName,matPeg:grvVlrApr, .T., matPeg:TipoGuia)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ retorno
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			if matPeg:gerPeg
				::WSNULL := "true|O protocolo está sendo gerado. Em alguns minutos consulte o mesmo através da opção << Consultar Protocolos Gerados >>"
			else
				::WSNULL := "true|Protocolo está sendo cancelado. Em alguns minutos consulte a sua exclusão através da opção << Consultar Protocolos Gerados >>. Caso o protocolo não mais esteja sendo exibido o seu cancelamento foi finalizado."
			endIf
		else
			If !lExcluiPEG
				::WSNULL := "true|PEG com guia faturada não pode ser excluida."
			Else
				::WSNULL := "true|Não existe registro para os parâmetros informados!"
			EndIf
		endIf
	endIf
else
	lRetorno := .f.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
endIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Fim do metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return lRetorno
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getInProces³Autor ³ Totvs			        ³ Data ³06.07.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³verifica se ainda esta em processo de transferencia de guia  |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD getInProces WSRECEIVE userCode, matPeg WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL aArea 	:= getArea()
LOCAL lRetorno	:= .t.

DEFAULT ::WSNULL := ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Se tem direito para executar o metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
if PrtChkUser( ::userCode ,"PLSXFUN","getInProces" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ cria protocolo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	nH := PLSAbreSem(matPeg:semaforo,.f.)
	if nH == 0
		::WSNULL := "true|false|"
	else
		PLSFechaSem(nH,matPeg:semaforo)
		::WSNULL := "true|true|" + matPeg:funJS
	endIf
else
	lRetorno := .f.
	setSoapFault( "", "Não autorizado a utilização do metodo" )
endIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Fim do metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getIField ³Autor  ³ Totvs			        ³ Data ³06.07.2012 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retonar titulo + campo 									   |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function getIField(cCampo)
LOCAL aRet 		:= {}
LOCAL aRetAux	:= {}
LOCAL aCampos	:= StrToArray(AllTrim(cCampo),",")
LOCAL nI		:= 1
LOCAL cTitulo	:= ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Matriz de campos para identificar os titulos dos campos aHeader
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
For nI:=1 To Len(aCampos)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Matriz de titulo + campo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	aRetAux := StrToArray( AllTrim( aCampos[nI] ),"=" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Se o titulo nao foi informado pega do x3_titulo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	cTitulo := RetTitle(aRetAux[2])
	If AllTrim(aRetAux[1]) == "?"
		aRetAux[1] := cTitulo
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Titulo e Campos (pegar o conteudo posteriormente)
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	AaDd(aRet, { AllTrim(aRetAux[1]) ,aRetAux[2] , AllTrim(SX3->X3_TIPO), SX3->X3_PICTURE, SX3->X3_CBOX} )
Next
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Fim do metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return aRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getRegPag  ³Autor  ³ Totvs				 ³ Data ³20.02.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina Total de Paginas e Total de Registros				    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function getRegPag(cAlias,cWhere,nRegPagina,cFieldJ,lComp)
LOCAL aArea 	:= GetArea()
LOCAL nRest		:= 0
LOCAL nQtdReg	:= 0
LOCAL nQtdPag 	:= 0
LOCAL cSQL		:= ""
LOCAL lAliasExit:= .T.
DEFAULT cFieldJ	:= ""
	DEFAULT lComp		:= .F.
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Query
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
If !Empty(cAlias)
	lAliasExit := PLSALIASEXI(cAlias)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Se a tabela existe
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
If lAliasExit
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Join o from esta na variavel cWhere retornada pela PPLSRDBRW
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    If !Empty(cFieldJ)
		cSQL := "SELECT COUNT(DISTINCT " + cFieldJ + ") AS QTD "
	Else
		cSQL := "SELECT COUNT(*) AS QTD "
		cSQL += "  FROM " + RetSQLName(cAlias)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Where
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	If !Empty(cWhere)
		cSQL += cWhere
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Executa query
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	OPEN QUERY cSQL ALIAS "GETREGPAG"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Quantidade de paginas
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    If !GETREGPAG->( Eof() )
    	nQtdReg	:= GETREGPAG->QTD

    	if nRegPagina==0
    		nRegPagina := 1
    	endIf

		nRest	:= mod(nQtdReg, nRegPagina)

		If nRest > 0
			nQtdPag	:= Int(nQtdReg / nRegPagina)+1
		Else
			nQtdPag := Int(nQtdReg / nRegPagina)
		EndIf

			If 	nQtdPag == 0 .And. !lComp
			nQtdPag := 1
		EndIf
    EndIf

    CLOSE QUERY "GETREGPAG"
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Fim do Metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return( {nQtdPag,nQtdReg} )
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getFMask	 ³Autor  ³ Totvs				 ³ Data ³20.02.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna conteudo formatado conforme tipo e picture			³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function getFMask(xConteudo ,cTipo, cPicture,cCampo, cBox)
LOCAL nPos			:= 0
LOCAL aRetBox		:= {}
DEFAULT cTipo	 	:= ValType(xConteudo)
DEFAULT cPicture 	:= ""
DEFAULT cCampo 	:= ""
DEFAULT cBox 		:= ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Se nao informado ou nao achou no x3 recno por exemplo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
If Empty(cTipo)
	cTipo := ValType(xConteudo)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Convert e formata
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Do Case
	Case !Empty(cBox) .AND. cTipo == 'C'
		aRetBox := RetSx3Box( X3CBox( Posicione('SX3',2,cCampo,'X3_CBOX') ),,,1 )

		If (nPos := AsCan( aRetBox , {|x| AllTrim(x[2]) == xConteudo} ))>0
			xConteudo := aRetBox[nPos,3]
		EndIf
	Case cTipo == 'C'
		xConteudo := allTrim( Iif(!Empty(cPicture), TransForm( AllTrim(xConteudo) ,cPicture), AllTrim(xConteudo) ) )
	Case cTipo == 'N'
		If Empty(cPicture)
			cPicture := "@E 999,999,999.99"
		EndIf
		xConteudo := allTrim(Iif(!Empty(cPicture), TransForm( xConteudo ,cPicture), cValToChar(xConteudo) ))
	Case cTipo == 'D'
		__SetCentury( "on" )

		xConteudo := DToC(SToD(xConteudo))

		__SetCentury("off")
EndCase
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Fim do Metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return(xConteudo)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³timeField ³Autor  ³ Karine Riquena Limp   ³ Data ³23.12.2016 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Transforma um campo da query no formato Hora   				  |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function timeField(xConteudo)
Local nTam := len(xConteudo)
		
	xConteudo := Stuff( xConteudo, 3, 0, ":" )
	
	if(nTam > 4)
		xConteudo := Stuff( xConteudo, 6, 0, ":" )
	endIf		
	
Return xConteudo

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Somente para poder compilar
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function PLSXFUN()
Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ProcUpXml  ³Autor  ³ Totvs 				 ³ Data ³20.02.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de processamento do arquivo xml Upload					³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ProcDeXml WSRECEIVE UserCode, UserPlsName, DirArqIn, RDACode WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno	 	:= .T.
LOCAL aArea 		:= GetArea()
LOCAL cDirRaiz	   	:= PLSMUDSIS( GetNewPar("MV_TISSDIR","\TISS\") )
LOCAL cDirBkp		:= PLSMUDSIS( cDirRaiz+"UPLOAD\BACKUP\")
LOCAL cDirUpload	:= PLSMUDSIS( cDirRaiz+"UPLOAD\" )
LOCAL cFile    		:= ""
LOCAL cExten   		:= ""
LOCAL cDirDocs 		:= ""

DEFAULT ::WSNULL	:= "true|"
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se tem direito para executar o metodo								   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode ,"PLSXFUN","ProcDeXml" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Processa o arquivo enviado												 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cSql := " select R_E_C_N_O_ REC FROM "+RetSqlName("BXX")
	cSql += " where "
	cSql += " BXX_FILIAL = '"+xFilial("BXX")+"' "
	cSql += " AND BXX_CODRDA = '"+::RDACode+"' "
	cSql += " AND (BXX_ARQIN  = '"+lower(::DirArqIn)+"' OR BXX_ARQIN  = '"+::DirArqIn+"')"
	cSql += " AND D_E_L_E_T_ = ' ' "
	PlsQuery(cSql,"trbBXX")
	If !trbBXX->(Eof())
	     BXX->(DbGoTo(trbBXX->REC))
	     BXX->(Reclock("BXX",.F.))
	     BXX->(DbDelete())
	     BXX->(MsUnlock())
	     ::WSNULL := "true|Arquivo excluido com sucesso!"
	Endif
	trbBXX->(DbCloseArea())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³Estou deletando ele do banco de conhecimento
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	SplitPath( ::DirArqIn,,, @cFile, @cExten )

	If FindFunction( "MsMultDir" ) .And. MsMultDir()
		cDirDocs := MsRetPath( cFile+cExten )
	Else
		cDirDocs := MsDocPath()
	Endif

	If file(PLSMUDSIS(cDirDocs + "\" + cFile+cExten))
		fErase(PLSMUDSIS(cDirDocs + "\" + cFile+cExten))
	Endif

	ACB->(DbSetOrder(2))
	while ACB->(MsSeek(xFilial('ACB')+Upper( cFile + cExten )))
		AC9->(DbSetORder(1))
		while AC9->(MsSeek(xFilial("AC9")+ACB->ACB_CODOBJ))
			AC9->(RecLock( "AC9", .F. ))
			AC9->(DbDelete())
			AC9->( MsUnlock() )
		Enddo
		ACB->(RecLock( "ACB", .F. ))
		ACB->(DbDelete())
		ACB->( MsUnlock() )
	Enddo

	if file(cDirUpload+cFile+cExten)
		fErase(cDirUpload+cFile+cExten)
	endIf
	if file(cDirBkp+cFile+cExten)
		fErase(cDirBkp+cFile+cExten)
	endIf

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim do metodo														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getInProces³Autor ³ Totvs			        ³ Data ³06.07.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³verifica se ainda esta em processo de transferencia de guia  |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD posicione WSRECEIVE userCode,Alias,Chave,CmdChave,Idx WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL aArea 	:= getArea()
LOCAL lRetorno	:= .t.

DEFAULT ::WSNULL := ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Se tem direito para executar o metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
if PrtChkUser( ::userCode ,"PLSXFUN","posicione" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ cria protocolo
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	if (::Alias)->(FieldPos(::CmdChave)) > 0
		cRet 	 := "true|"+alltrim(Posicione(::Alias,::Idx,xFilial(::Alias)+::Chave,::CmdChave))
	else
		cRet 	 := "true|"
	Endif
	::WSNULL := cRet

else
	lRetorno := .f.
	setSoapFault( "", "Não autorizado a utilização do metodo" )
endIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Fim do metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return lRetorno

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getInProces³Autor ³ Totvs			        ³ Data ³06.07.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³verifica se ainda esta em processo de transferencia de guia  |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ppImpRel WSRECEIVE userCode,Chave,FunName WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL aArea 	:= getArea()
LOCAL aChave	:= {} // Campos da chave
LOCAL aRecTit	:= {} // Recno dos titulos selecionados
LOCAL aParF	:= {} // parametros pra função (Devem ser montados na ordem de recebimento da função)
LOCAL lRetorno	:= .t.
LOCAL nLin			:= 0
LOCAL cTitRel		:= ""
LOCAL cPathSrv 	:= lower(getMV("MV_RELT"))
LOCAL aTitulos	:= {{"PLSRELDPM", "Demonstrativo de Pagamento"} ,; // Titulo dos relatorios por rotina
						 {"PLSRELDAC", "Demonstrativo de Análise de Processamento de Contas"},;
						 {"PLSRELDPO", "Demonstrativo de Pagamento Odontologico"},;
						 {"PLSRELEPM", "Extrato de Pagamento da RDA"}}
Local lRetUsu		:= .T.
Local cMensag 		:= ""

DEFAULT ::WSNULL := ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³PE para troca do nome de exibição dos relatorios no email por Rotina   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("PLIMPRELT")
	aTitulos := ExecBlock("PLIMPRELT",.F.,.F.,{::FunName})
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Se tem direito para executar o metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
if PrtChkUser( ::userCode ,"PLSXFUN","ppImpRel" )
	aChave 	:= PSplitAdvpl(::Chave, "|") // 1 - RDA, 2 - Email, 3 - Recnos SE2, 4 - Tipo Relatório: '1' = PDF ou '2' = XML, 5 - Somente Glosa ?
	aRecTit	:= PSplitAdvpl(aChave[3], ",") //RecnoS SE2

	BAU->(DbSetOrder(1))
	If BAU->(MsSeek(xFilial("BAU")+aChave[1]))
		IF AllTrim(BAU->BAU_SIGLCR) <> ALLTRIM("CRO")  .AND. FunName=="PLSRELDPO"
			lRetUsu := .f.
			cMensag	:=	"O Profissional da Saúde não é da area de Odontologia. "
		Endif

		If Empty(BAU->BAU_EMAIL)   .AND. !Empty(aChave[2])
			RecLock("BAU", .F.)
				BAU->BAU_EMAIL :=  Alltrim(aChave[2])
			MsUnlock()
		EndIf
	EndIf

	If Len(aRecTit) > 0 .and. lRetUsu
		For nLin := 1 to Len(aRecTit)
			If funname$'PLSRELDPM/PLSRELEPM' //Demonstrativo de Pagamento/Extrato de Pagamento da RDA
				cAlias:=StrTran(Substr(aRecTit[nLin],1,4),"'","")
				DbSelectArea(cAlias)
				DbGoTo(Val(StrTran(Substr(aRecTit[nLin],5,len(aRecTit[nLin])),"'","")))//retira aspas e posiciona no registro
				If cAlias =="SE2"
					aParF := {aChave[1], SE2->E2_ANOBASE, SE2->E2_MESBASE, .T.,cPathSrv, SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA),"SE2"} // Montagem dos parametros que a função vai receber  // Ex.: PLSRELDPM(cCodRda,cAnoW,cMesW,lWeb,cPathW,cNmTitPg)
				Else
					aParF := {aChave[1], Substr(SC7->C7_LOTPLS,1,4), Substr(SC7->C7_LOTPLS,5,2), .T.,cPathSrv, SC7->C7_NUM,"SC7"} // Montagem dos parametros que a função vai receber  // Ex.: PLSRELDPM(cCodRda,cAnoW,cMesW,lWeb,cPathW,cNmTitPg)
				Endif
			//	cTitRel := aTitulos[aScan( aTitulos, { |x| x[1] == ::FunName } ), 2]
			ElseIf funname == "PLSRELDAC" //Demonstrativo de Análise de Processamento de Contas
				cAlias:=StrTran(Substr(aRecTit[nLin],1,4),"'","")
				DbSelectArea(cAlias)
				DbGoTo(Val(StrTran(Substr(aRecTit[nLin],5,len(aRecTit[nLin])),"'","")))//retira aspas e posiciona no registro
				aParF := {aChave[1], BCI->BCI_ANO, BCI->BCI_MES,.T.,cPathSrv, BCI->BCI_CODPEG,"BCI", .F., aChave[5]} // Montagem dos parametros que a função vai receber  // Ex.: PLSRELDPM(cCodRda,cAnoW,cMesW,lWeb,cPathW,cNmTitPg)
			Else //Demonstrativo de Pagamento Odontologico
				DbSelectArea("SE2")
				DbGoTo(Val(StrTran(Substr(aRecTit[nLin],5,len(aRecTit[nLin])),"'","")))//retira aspas e posiciona no registro
				aParF := {aChave[1], SE2->E2_ANOBASE, SE2->E2_MESBASE, .T.,cPathSrv, SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)} // Montagem dos parametros que a função vai receber  // Ex.: PLSRELDPM(cCodRda,cAnoW,cMesW,lWeb,cPathW,cNmTitPg)
			//	cTitRel := aTitulos[aScan( aTitulos, { |x| x[1] == ::FunName } ), 2] // Busca no array o titulo do relatorio de acordo com a rotina do mesmo
			Endif
			
			cTitRel := aTitulos[aScan( aTitulos, { |x| x[1] == ::FunName } ), 2] // Busca no array o titulo do relatorio de acordo com a rotina do mesmo
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ "Relatorios processamento de contas"
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			// EXECUTA O STARTJOB PLSTJBMAIL(cNomRot,cMailSend, cTitRel, lExcel, aParFuncao, cTipoRel)
			PLSTJBMAIL(::FunName,aChave[2], cTitRel, .F., aParF, aChave[4] )
		Next nLin
		cRet 	 := "true|"
		::WSNULL := cRet
	Else
		lRetorno := .f.
		cMensag	+="Não autorizado a utilização do metodo"
		setSoapFault( "",cMensag )
	EndIf
else
	lRetorno := .f.
	setSoapFault( "", "Não foram informados os parametros necessários" )
endIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Fim do metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return lRetorno

//--------------------------------------------------------------------------
//PSplitAdvpl - Funcao que retorna um array a partir de uma string de      |
// separacao conforme passo pelo parametro (similir Split JavaScript)      |
//--------------------------------------------------------------------------
Static Function PSplitAdvpl(cString, cCharSep)
Local aArray	:= {}
Local cStrAtu	:= ""
Local nAt		:= 0

If SubStr(cString, 1,1) == cCharSep //remove caracter de separação no inicio
	cString := Alltrim(SubStr(cString, 2,Len(cString)))
EndIf
If SubStr(cString, Len(cString),1) == cCharSep //remove caracter de separação no fim
	cString := Alltrim(SubStr(cString, 1,Len(cString)-1))
EndIf
While (nAt := At(cCharSep, cString)) > 0
	cStrAtu := Alltrim(SubStr(cString, 1,At(cCharSep, cString)-1 ))
	If !Empty(cStrAtu)
		AaDD(aArray,  Alltrim(SubStr(cString, 1,At(cCharSep, cString)-1 )))
	EndIf
	cString := Alltrim(SubStr(cString, At(cCharSep, cString)+1,Len(cString) ))
EndDo
If !Empty(Alltrim(cString))
	AaDD(aArray,  cString)
EndIf
Return(aArray)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ PLSGETMV ºAutor  ³ TOTVS S/A          º Data ³  16/08/2013 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Um metodo para retornar o valor de um parametro SX6        º±±
±±ºParametro:³ cParMV - parametro a ser consultado                        º±±
±±º          ³ cDefMV - valor padrao para parametro inexistente           º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
WSMETHOD PLSGETMV WSRECEIVE cParMV,cDefMV WSSEND cRetMv WSSERVICE PLSXFUN
Default ::cRetMv := ""

If !Empty(cParMV)
	::cRetMV := GetNewPar(cParMV,cDefMV)
EndIf

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ExCarPortal    ³Autor  ³ Thiago Guilherme  ³ Data ³28.11.2013 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os procedimentos que possuem carência que poderão ser³±±
±±³				visualizados
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ExCarPortal WSRECEIVE UserCode WSSEND ProcCarPort WSSERVICE PLSXFUN
LOCAL nI        := 1
LOCAL aArea	  := GetArea()
LOCAL lRetorno  := .T.
LOCAL cExiCaren := "1"
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "ExCarPortal" )

	If BR8->(FieldPos("BR8_CARPRT")) > 0

		dbSelectArea("BR8")
		BR8->(DbSetOrder(9))

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Retorna os procedimentos que possuem carencia e que poderao ser vistos  ³
		// no portal.
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If dbSeek(xFilial("BR8")+cExiCaren)

			::ProcCarPort := {}

			While !BR8->(EOF()) .AND. BR8->(BR8_FILIAL+BR8_CARPRT) == xFilial("BR8")+cExiCaren

			   AaDd( ::ProcCarPort, WsClassNew( "SCarPor" ) )
			   ::ProcCarPort[nI]:CodPro   := AllTrim(BR8->BR8_CODPSA)
			   ::ProcCarPort[nI]:DescPro  := SubSTR(BR8->BR8_DESCRI,1, 50)
			   ::ProcCarPort[nI]:REC      := ALLTRIM(STR(br8->(recno())))
			   nI++
			   BR8->(dbSkip())
			EndDo
		EndIf
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DadGrpFam    ³Autor  ³ Thiago Guilherme  ³ Data ³08.01.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os beneficiários que fazem parte do grupo familiar   ³±±
±±³
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DadGrpFam WSRECEIVE UserCode, cUsrLogin WSSEND DadosGrpFam WSSERVICE PLSXFUN
LOCAL nI        := 1
LOCAL aArea	  := GetArea()
LOCAL lRetorno  := .T.
LOCAL cSQL
LOCAL cCodFam
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "DadGrpFam" )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³retorna a matricula do beneficiario que esta cadastrado para o login	³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	cSQL := "SELECT B49_BENEFI "
	cSQL += "FROM " + RetSQLName("B49")
	cSQL += " WHERE B49_CODUSR = '" + cUsrLogin + "' AND "
	cSQL += " D_E_L_E_T_ = ' '"

	PLSQuery(cSQL,"TrbRetTit")

	if !TrbRetTit->(EOF())

		cCodFam := SUBSTR(TrbRetTit->B49_BENEFI,1,14)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³retorna os beneficiarios da familia principal
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		cSQL := "SELECT BA1_CODINT, BA1_CODEMP, BA1_MATRIC, BA1_TIPREG, BA1_DIGITO, BA1_NOMUSR, BA1_TIPUSU"
		cSQL += " FROM " + RetSQLName("BA1")
		cSQL += " WHERE BA1_CODINT + BA1_CODEMP + BA1_MATRIC = " + cCodFam
		cSQL += " AND D_E_L_E_T_ = ''"
		PLSQuery(cSQL,"TrbRetFMP")

		While !TrbRetFMP->(EOF())

	       AaDd( ::DadosGrpFam, WsClassNew( "SDadGrp" ) )
			::DadosGrpFam[nI]:Matricl := TrbRetFMP->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO)
			::DadosGrpFam[nI]:NomeBnf := TrbRetFMP->BA1_NOMUSR
			nI++
			TrbRetFMP->(dbSkip())
		EndDo

		If BA3->(FieldPos("BA3_GRPFAM")) > 0

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³retorna os dados dos beneficiarios que fazem parte do grupo familiar
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			TrbRetFMP->(dbGoTop())

			While TrbRetFMP->BA1_TIPUSU ==  "D"
				TrbRetFMP->(dbSkip())
			EndDo

			cSQL := "SELECT BA3_CODINT, BA3_CODEMP, BA3_MATRIC "
			cSQL += "FROM " + RetSQLName("BA3")
			cSQL += " INNER JOIN " + RetSQLName("BA1")
			cSQL += " ON BA1_CODINT + BA1_CODEMP + BA1_MATRIC = BA3_CODINT + BA3_CODEMP + BA3_MATRIC"
			cSQL += " WHERE BA3_GRPFAM = '" + TrbRetFMP->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO) + "'"
			cSQL += " AND " + RetSQLName("BA3")+".D_E_L_E_T_ = '' AND " + RetSQLName("BA1")+".D_E_L_E_T_ = ''"
			cSQL += " GROUP BY BA3_CODINT, BA3_CODEMP, BA3_MATRIC"
			PLSQuery(cSQL,"TrbRetGpFm")


			cSQL := "SELECT BA1_CODINT, BA1_CODEMP, BA1_MATRIC, BA1_TIPREG, BA1_DIGITO, BA1_NOMUSR, BA1_TIPUSU"
			cSQL += " FROM " + RetSQLName("BA1")
			cSQL += " WHERE BA1_CODINT + BA1_CODEMP + BA1_MATRIC IN( "

			If !TrbRetGpFm->(EOF())

				While !TrbRetGpFm->(EOF())
					cSQL += TrbRetGpFm->(BA3_CODINT + BA3_CODEMP + BA3_MATRIC)

					TrbRetGpFm->(dbSkip())

					if TrbRetGpFm->(EOF())
						cSQL += ")"
					Else
						cSQL += ","
					EndIf
				EndDo

				cSQL += " AND D_E_L_E_T_ = ''"
				PLSQuery(cSQL,"TrUsrGrp")
				
				While !TrUsrGrp->(EOF())

			       AaDd( ::DadosGrpFam, WsClassNew( "SDadGrp" ) )
					::DadosGrpFam[nI]:Matricl := TrUsrGrp->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO)
					::DadosGrpFam[nI]:NomeBnf := TrUsrGrp->BA1_NOMUSR
					nI++
					TrUsrGrp->(dbSkip())
				EndDo

				TrUsrGrp->(dbCloseArea())
			EndIf

			TrbRetGpFm->(dbCloseArea())

		EndIf
	EndIf

	TrbRetFMP->(dbCloseArea())
	TrbRetTit->(dbCloseArea())

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CarenBnf    ³Autor  ³ Thiago Guilherme  ³ Data ³08.01.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os dados de carencia do beneficiario				   ³±±
±±³
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD CarenBnf WSRECEIVE UserCode, cMatrc, cRecno WSSEND DadCarenc WSSERVICE PLSXFUN
LOCAL lRetorno  := .T.
LOCAL aRDA 	  := PLSDADRDA(PlsIntPad(),GetNewPar("MV_PLSRDAG","999999"),"1",dDatabase)
LOCAL dData	  := dDatabase
LOCAL cHora	  := TIME()
LOCAL aUsr 	  := PLSDADUSR(cMatrc,'1',.F.,dDatabase,,,"NAO_VALIDAR_CARTAO")
LOCAL aRetCar
LOCAL cSQL
LOCAL nI
LOCAL nQtdCrt
LOCAL aArea	  := GetArea()
LOCAL nCont	  := 1
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "CarenBnf" )

	cSQL := "SELECT BR8_CODPAD, BR8_CODPSA "
	cSQL += "FROM " + RetSQLName("BR8")
	cSQL += " WHERE R_E_C_N_O_ = " + cRecno
	PLSQuery(cSQL,"TrbRetCar")
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Retorna as carências														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aRetCar := PLSAUTP(dData,cHora,TrbRetCar->BR8_CODPAD,TrbRetCar->BR8_CODPSA,1,aUsr,0,aRDA,"1",,,.T.,"1",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,;
						  ,,,,.F.,,,,NIL,.F.,,,,,,,,,,,,,,,,,,,,,,,.F.)

	TrbRetCar->(dbCloseArea())

	nQtdCrt := len(aRetCar[2])

	If !aRetCar[1]

		For nI := 1 To nQtdCrt

		    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Filtra as críticas que devem ser retornadas para o beneficiario			 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		    If !("Nível" $ aRetCar[2][nI][2]) .AND. (LEN(aRetCar[2][nI][2]) > 3)

			    AaDd( ::DadCarenc, WsClassNew( "SRetCaren" ) )

				If !EMPTY(aRetCar[2][nI][2] )
					::DadCarenc[nCont]:cMsg  := aRetCar[2][nI][2]
				Else
					::DadCarenc[nCont]:cMsg  := ""
				endIf

				If !EMPTY(aRetCar[2][nI][3])
					::DadCarenc[nCont]:cInfo := aRetCar[2][nI][3]
				Else
					::DadCarenc[nCont]:cInfo := ""
				EndIf

				nCont++
			EndIf
		Next
	Else

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se nao existir críticas, o procedimento esta liberado   					 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		AaDd( ::DadCarenc, WsClassNew( "SRetCaren" ) )
		::DadCarenc[1]:cMsg  := ""
		::DadCarenc[1]:cInfo := ".T."
	EndIf

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RetAut    ³Autor  ³ Thiago Guilherme      ³ Data ³27.01.14	 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna as noticias disponiveis no portal para o prestador   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RetNot WSRECEIVE UserCode, cCodEsp, cCodNotic, cCodRDA, cUserCod, cOpcao WSSEND Noticia WSSERVICE PLSXFUN
LOCAL nI          := 1
LOCAL nJ          := 1
LOCAL lRetorno	:= .T.
LOCAL aRet	 		:= {}
LOCAL aRetArq		:= {}
LOCAL aArea		:= BPL->(GetArea())
LOCAL cCodNot		:= ""
LOCAL cSQL			:= ""
LOCAL cSQL2		:= ""
LOCAL cEspc		:= ""
LOCAL nReg
LOCAL aDadUsr		:= {}
LOCAL cDir	 	:= getWebDir()
LOCAL nQtdArq
LOCAL nQtdBco
LOCAL lExtArq := .F.
LOCAL nCount
LOCAL nCountArq := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "RetNot" ) //consome uma licença, checa integridade de acesso

   If cOpcao == "1"

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Retorna os títulos das notícias 											   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If EMPTY(cUserCod)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Seleciona as especialidades dos prestadores    						   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cSQL := "SELECT BBF_CODIGO,BBF_CDESP "
				cSQL += " FROM " + RetSQLName("BBF")
				cSQL += " WHERE BBF_FILIAL = '" + xFilial("BBF")+"' "
				cSQL += " AND BBF_CODIGO IN (" + cCodRDA  + ")"
				cSQL += " AND " + RetSqlName("BBF")+".D_E_L_E_T_ = ''"

				PLSQuery(cSQL,"TrbEspPrt")

				While !TrbEspPrt->(EOF())

					cEspc += TrbEspPrt->BBF_CDESP + ","
					TrbEspPrt->(dbSkip())
				EndDo

				nReg := len(cEspc)

				cEspc := STUFF(cEspc , nReg, 1, "")

				TrbEspPrt->(dbCloseArea())

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Verifica a existencia de noticias para as especialidades				   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cSQL2 := "SELECT BAQ_CODESP, BAQ_DESCRI, BPM_CODIGO"
			   	cSQL2 += " FROM " + RetSQLName("BAQ")
			   	cSQL2 += " INNER JOIN " +RetSQLName("BPM")
			   	cSQL2 += " ON BAQ_CODESP = BPM_CODESP"
			   	cSQL2 += " WHERE BPM_CODESP IN( " + cEspc + ") AND "
			   	cSQL2 += RetSqlName("BPM")+".D_E_L_E_T_ = '' AND " + RetSqlName("BAQ")+".D_E_L_E_T_ = ''
			   	cSQL2 += "GROUP BY BAQ_CODESP, BAQ_DESCRI, BPM_CODIGO"
				
			   	PLSQuery(cSQL2,"TrbReTEspc")

			   	nI := 0

			   	While !TrbReTEspc->(EOF())

					cCodNot += TrbReTEspc->BPM_CODIGO + ","
					TrbReTEspc->(dbSkip())
				EndDo

				TrbReTEspc->(dbCloseArea())

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Retorna as noticias para os Prestadores especificos			            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cSQL:= " SELECT BPO_CODIGO"
				cSQL+= " FROM " + RetSQLName("BPO")
				cSQL+= " WHERE BPO_CODRDA IN (" + cCodRDA + ")
				cSQL+= " AND " + RetSqlName("BPO")+".D_E_L_E_T_ = ''"
				PLSQuery(cSQL,"TrbRetBPO")

				nI := 0

			   	While !TrbRetBPO->(EOF())

					cCodNot += If ( !TrbRetBPO->BPO_CODIGO $ cCodNot, TrbRetBPO->BPO_CODIGO + ",",'')
					TrbRetBPO->(dbSkip())
				EndDo

				TrbRetBPO->(dbCloseArea())

				nReg 	 := len(cCodNot)
				cCodNot := If(EMPTY(cCodNot),"''", STUFF(cCodNot , nReg, 1, ""))

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Retorna as noticias disponiveis para as especialidades				   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cSQL:= "SELECT BPL_FILIAL,BPL_CODIGO,BPL_TITULO,BPL_VIGINI,BPL_VIGFIN"
				cSQL+= " FROM " + RetSQLName("BPL")
				cSQL+= " WHERE BPL_CODIGO IN( " + cCodNot + ") "
				cSQL+= " AND BPL_TIPUSU IN(1,3)"
				cSQL+= " AND BPL_VIGINI <= '" + DTOS(dDataBase) + "' AND BPL_VIGFIN >= '" + DTOS(dDataBase) + "'"
				cSQL+= " AND " + RetSqlName("BPL")+".D_E_L_E_T_ = '' "

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Quando não existir especialidade e nem prestador cadastrado em uma
				// noticia, entao todas as especialidades visualizarao a noticia           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cSQL += " OR  NOT EXISTS( SELECT BPM_CODIGO FROM " + RetSQLName("BPM") + " WHERE BPL_CODIGO = BPM_CODIGO AND D_E_L_E_T_ ='' ) AND "
				cSQL +=      "NOT EXISTS( SELECT BPO_CODIGO FROM " + RetSQLName("BPO") + " WHERE BPL_CODIGO = BPO_CODIGO AND D_E_L_E_T_ = '')" 
				cSQL += " AND " + RetSqlName("BPL") + ".D_E_L_E_T_ = '' "
				cSQL += " AND BPL_VIGINI <= '" + DTOS(dDataBase) + "' AND BPL_VIGFIN >= '" + DTOS(dDataBase) + "' AND BPL_TIPUSU IN(1,3)"

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Agrupamento e ordenação pela ultima noticia inclusa, pois o portal    ³
				// sempre mostrará as ultimas dez notícias inclusas
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cSQL+= " GROUP BY BPL_FILIAL,BPL_CODIGO,BPL_TITULO,BPL_VIGINI,BPL_VIGFIN"
				cSQL+= " ORDER BY BPL_CODIGO DESC"
				PLSQuery(cSQL,"TrbRetNot")
		Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³retorna a matricula do beneficiario que esta cadastrado para o login	³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cSQL := "SELECT B49_BENEFI "
				cSQL += "FROM " + RetSQLName("B49")
				cSQL += " WHERE B49_CODUSR = '" + cUserCod + "' AND "
				cSQL += " D_E_L_E_T_ = ' '"
				PLSQuery(cSQL,"TrbRetTit")

				if !TrbRetTit->(EOF())

						aDadUsr := PLSDADUSR(TrbRetTit->B49_BENEFI,'1',.F.,dDatabase,,,"NAO_VALIDAR_CARTAO")

						cSQL:= " SELECT BPP_CODIGO"
						cSQL+= " FROM " + RetSQLName("BPP")
						cSQL+= " WHERE BPP_CODPLA = '" + IIF(LEN(aDadUsr) < 11, GetNewPar("MV_CODPLAP",""), aDadUsr[11]) + "'"
						cSQL+= " AND " + RetSqlName("BPP")+".D_E_L_E_T_ = ''"
						PLSQuery(cSQL,"TrbRetBPP")
						
						While !TrbRetBPP->(EOF())

							cCodNot += If ( !TrbRetBPP->BPP_CODIGO $ cCodNot, TrbRetBPP->BPP_CODIGO + ",",'')
							TrbRetBPP->(dbSkip())
						EndDo
						
						TrbRetBPP->(dbCloseArea())
						
						//retira a virgula na última posição
						cCodNot := If(EMPTY(cCodNot),"''", STUFF(cCodNot , len(cCodNot), 1, ""))
						
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Retorna as noticias disponiveis para o beneficiario					   ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						cSQL:= "SELECT BPL_FILIAL,BPL_CODIGO,BPL_TITULO,BPL_VIGINI,BPL_VIGFIN"
						cSQL+= " FROM " + RetSQLName("BPL")
						cSQL+= " WHERE BPL_CODIGO IN( " + cCodNot + ") "
						cSQL+= " AND BPL_TIPUSU IN(2,3)"
						cSQL+= " AND BPL_VIGINI <= '" + DTOS(dDataBase) + "' AND BPL_VIGFIN >= '" + DTOS(dDataBase) + "'"
						cSQL+= " AND " + RetSqlName("BPL")+".D_E_L_E_T_ = '' "
						
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Quando não existir produto cadastrado em uma
						// noticia, entao todos os beneficiários visualizarão a noticia           ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						cSQL+= " OR  NOT EXISTS( SELECT BPP_CODIGO FROM " + RetSQLName("BPP") //08-09 ini
						cSQL+= " WHERE BPL_CODIGO = BPP_CODIGO "
						cSQL+= " AND " + RetSqlName("BPP") + ".D_E_L_E_T_ ='') AND " + RetSqlName("BPL") + ".D_E_L_E_T_ = '' "
						cSQL+= " AND BPL_VIGINI <= '" + DTOS(dDataBase) + "' AND BPL_VIGFIN >= '" + DTOS(dDataBase) + "' AND BPL_TIPUSU IN(2,3)" //08-09 fim
						cSQL+= " GROUP BY BPL_FILIAL,BPL_CODIGO,BPL_TITULO,BPL_VIGINI,BPL_VIGFIN"
						cSQL+= " ORDER BY BPL_CODIGO DESC"
						
						PLSQuery(cSQL,"TrbRetNot")
				EndIf

				TrbRetTit->(dbCloseArea())
		EndIf

	If (Select("TrbRetNot") > 0)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Monta matriz de retorno												   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	    While !TrbRetNot->( Eof() )
	    	cNotic := BPL->BPL_NOTICI

	    	dbSelectArea("BPL")
	    	dbSetOrder(1)
	    	If BPL->( MsSeek( xFilial( "BPL" ) + TrbRetNot->BPL_CODIGO) )
	    		cNotic := BPL->BPL_NOTICI
	    	EndIf

			AaDd(aRet,{TrbRetNot->BPL_VIGINI,; 	 					//Data Inicial
	   					TrbRetNot->BPL_VIGFIN,; 							//Data Final
	   					TrbRetNot->BPL_TITULO,;							//Titulo
	   					cNotic, TrbRetNot->BPL_CODIGO} )

	   		TrbRetNot->( DbSkip() )
	    EndDo

	    TrbRetNot->( DbCloseArea() )
		EndIf
		
	    If !EMPTY(aRet)
		    If Len(aRet) > 0
			   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			   //³Guias													 			      ³
			   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			   ::Noticia := {}

		   	    For nI := 1 To Len( aRet )
				   AaDd( ::Noticia, WsClassNew( "SNoticia" ) )//cria uma estrutura e alienta c o contreudo do array aRet
				   ::Noticia[nI]:DtNotIni 	:= aRet[nI,1]   //essa estrutura deve ser declarada no cabeçalho do webservice
				   ::Noticia[nI]:DtNotFin 	:= aRet[nI,2]   //com base em outra etrutura SMatAut
				   ::Noticia[nI]:TituloNot 	:= aRet[nI,3]
				   ::Noticia[nI]:TextoNot	:= aRet[nI,4]
				   ::Noticia[nI]:cCodNot		:= aRet[nI,5]
				   ::Noticia[nI]:cEspec     := cEspc
				   ::Noticia[nI]:ArqNot  := {}
				Next
			 Else
				lRetorno := .F.
				SetSoapFault( "", "Nenhuma Noticia encontrada para o Usuário ( "+Iif( Len(::UserCardNumber)>16 ,Transform(::UserCardNumber, "@R 9999.9999.999999.99-9" ),Transform(::UserCardNumber, "@R 999.9999.999999.99-9" ) )+" )" )
		     EndIf
	    EndIf

   ElseIf cOpcao == "2"
	   	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Retornar as noticias e os anexos de acordo com o título selecionado     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	    dbSelectArea("BPL")
	    dbSetOrder(1)

	   	 If BPL->( MsSeek( xFilial( "BPL" ) + cCodNotic) ) // TROCAR PARA CODIGO DA NOTICIA
	    	While xFilial( "BPL" ) + cCodNotic == BPL->(BPL_FILIAL+BPL_CODIGO)

		    	If cOpcao == "2"

			    	dbSelectArea("AC9")
			    	dbSetOrder(2)//AC9_FILIAL, AC9_ENTIDA, AC9_FILENT, AC9_CODENT, AC9_CODOBJ
			    	If AC9->( MsSeek( xFilial( "AC9" ) + "BPL"+ BPL->(BPL_FILIAL+BPL_FILIAL+BPL_CODIGO)))

				   		While (xFilial( "AC9" )+ AllTrim(AC9_ENTIDA+AC9_FILENT+AC9_CODENT)) == ;
				   				(xFilial( "AC9" )+'BPL'+ BPL->(BPL_FILIAL+BPL_FILIAL+BPL_CODIGO))

			    				dbSelectArea("ACB")
			    				dbSetOrder(1)//ACB_FILIAL, ACB_CODOBJ
			    				If ACB->( MsSeek( xFilial( "ACB" ) + AC9->AC9_CODOBJ) )

			   					AaDd(aRetArq,{ACB->ACB_CODOBJ, ACB->ACB_OBJETO} )
			    				EndIf
			    			AC9->(dbSkip())
			    		EndDo
			    	EndIf
		 		EndIf

		   		AaDd(aRet,{BPL->BPL_TITULO,	BPL->BPL_NOTICI, BPL->BPL_CODIGO} )

   				BPL->( DbSkip() )
	   		EndDo
	   	EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica o Retorno													   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aRet) > 0
		   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		   //³Guias													 			      ³
		   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		   ::Noticia := {}

	   	    For nI := 1 To Len( aRet )
			   AaDd( ::Noticia, WsClassNew( "SNoticia" ) )//cria uma estrutura e alienta c o contreudo do array aRet
			   ::Noticia[nI]:TituloNot 	:= aRet[nI,1]
			   ::Noticia[nI]:TextoNot	:= aRet[nI,2]
			   ::Noticia[nI]:cCodNot		:= aRet[nI,3]
			   ::Noticia[nI]:ArqNot  := {}

			   	If cOpcao == "2"

					cDir := cDir + "imagens-pls\arquivonoticia\"+ cCodNotic + "\"

					aArqDir := DIRECTORY(cDir + PLSMUDSIS("\*.*"))

					nQtdArq := Len(aArqDir)
					nQtdBco := Len(aRetArq)

					If nQtdArq > 0

						For nCount := 1 To nQtdArq

							For nJ := 1 To nQtdBco

								If ALLTRIM(aRetArq[nJ,2]) == STRTRAN(aArqDir[nCount][1], "_", " ")
									lExtArq := .T.

									nCountArq += 1
									
									AaDd( ::Noticia[nI]:ArqNot, WsClassNew( "SArqNot" ) )
		   							::Noticia[nI]:ArqNot[nCountArq]:CodObj	:= aRetArq[nJ,1]
		   							::Noticia[nI]:ArqNot[nCountArq]:Objeto	:= aRetArq[nJ,2]

									EXIT
								EndIf
							Next

							If !lExtArq

								If aArqDir[nCount][5] == "A"
									fErase(cDir+aArqDir[nCount][1])
								EndIf
							Else
								lExtArq := .F.
							EndIf
						Next
					EndIf
				EndIf
			Next
	    Else
			lRetorno := .F.
			SetSoapFault( "", "Nenhuma Noticia encontrada para o Usuário ( "+Iif( Len(::UserCardNumber)>16 ,Transform(::UserCardNumber, "@R 9999.9999.999999.99-9" ),Transform(::UserCardNumber, "@R 999.9999.999999.99-9" ) )+" )" )
	    EndIf
	EndIf
Else
 	lRetorno := .F.
   	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ExNotPort    ³Autor  ³ Thiago Guilherme   ³ Data ³28.01.14	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna as noticias disponiveis no portal para o prestador   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ExNotPort WSRECEIVE UserCode WSSEND ExisTbl WSSERVICE PLSXFUN

LOCAL aArea	  := GetArea()
LOCAL lRetorno  := .T.
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "ExNotPort" )
 	
 	If PLSALIASEX("BPL") .AND. GetNewPar("MV_NOTPRT",.F.)
  		::ExisTbl:= .T.
   	Else
		::ExisTbl:= .F.
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetVlrTiss ³Autor  ³ Alexander	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o procedimento e valido						   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetVlrTiss WSRECEIVE UserCode,TermoTiss WSSEND WSNULL WSSERVICE PLSXFUN

LOCAL lRetorno 		:= .T.
LOCAL aArea    		:= GetArea()

//LOCAL cTissVer		:= PLSTISSVER()


DEFAULT ::WSNULL	:= ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode , "PLSXFUN", "GetVlrTiss" )

	If Valtype(TermoTiss:VerTiss) <> 'U' .AND. TermoTiss:VerTiss >= '3'
		::WSNULL := "true|"
		::WSNULL += TermoTiss:Campo + "|" + ALLTRIM(PLSRETTIS("",TermoTiss:CodAlias,TermoTiss:VlrProt, .F., /*cChave*/) )
	Else
		::WSNULL := "true|"
		::WSNULL += TermoTiss:Campo + "|" + TermoTiss:cVlrProt
	EndIf

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetCmbFormT ³Autor  ³ Rogerio Machado Tabosa ³ Data ³01.02.2014³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os campos do TIpo Combo da GUIA dinamica do Portal	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetCmbFormT WSRECEIVE UserCode,GuiaTiss WSSEND RetGuiaTiss WSSERVICE PLSXFUN

LOCAL lRetorno 	:= .T.
LOCAL aArea    	:= GetArea()
LOCAL nCmp			:= 0
LOCAL cTipGui		:= ""
LOCAL cVerTiss	:= ""
LOCAL cCampo		:= ""
LOCAL cBOXRet		:= ""

If PrtChkUser( ::UserCode , "PLSXFUN", "GetCmbFormT" )
	//VARIÁVEL DE RETORNO
	::RetGuiaTiss := WsClassNew( "SRetGuiaTiss" )
	::RetGuiaTiss:RetCmbsGuia := {}

	cTipGui := GuiaTiss:TipGui
	cVerTiss:= GuiaTiss:VerTiss

	If B7B->(MsSeek(xFilial("B7B")+cTipGui+cVerTiss) )
		While !B7B->(EOF()) .AND. xFilial("B7B")+cTipGui+cVerTiss ==;
			B7B->(B7B_FILIAL+B7B_TIPGUI+B7B_TISVER)

			cCampo 	:= AllTrim(B7B->B7B_NOMXMO)
			cBOXRet 	:= Alltrim(B7B->B7B_CBOX)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//Alimenta a Struct com os combos
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			If B7B->B7B_TIPO == 'C'
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//Adiciona o grid a estrutura
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				AaDd( ::RetGuiaTiss:RetCmbsGuia, WsClassNew( "SRetCmbsGuia" ) )
				nCmp := Len(::RetGuiaTiss:RetCmbsGuia)
				::RetGuiaTiss:RetCmbsGuia[nCmp]:CampoG := cCampo
				::RetGuiaTiss:RetCmbsGuia[nCmp]:CBOX := cBOXRet

			EndIf
			B7B->(DbSkip())
		EndDo
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetFormTiss ³Autor  ³ Everton M. Fernandes   ³ Data ³06.03.2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Monta formulario da guia no padrao da TISS configurado  	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetFormTiss WSRECEIVE UserCode,GuiaTiss,Tipo,cRecno,DtLimRetro,MsnBloInter,DigiGui,AltCpAT,RecnoBD5,NumGuiRef,TpGuiRef,RecGuiRef,Intercambio,DtJs WSSEND RetGuiaTiss WSSERVICE PLSXFUN
Local lRetorno 	:= .T.
Local lContinua	:= .T.
Local aArea   	:= GetArea()
Local oForm		:= Nil
Local oTabPriFP	:= Nil
Local oHtml		:= Nil
Local RetGuia	:= NIL
Local cGrids	:= ""
Local cDesGri	:= ""
Local aDadosGuia	:= {}
Local aAreaBCL  := {}
Local aAreaB7A  := {}
Local aAreaB7B  := {}
Local aAreaSIX  := {}
Local aCustomBtn := {}
Local cDigiGui	:= IIF(ValType(::DigiGui) == "C", AllTrim(::DigiGui), "")
Local lTpAlt	:= IIF(ValType(::AltCpAT) == "L", AltCpAT, .F. )
Local lIntercambio	:= IIF(ValType(::Intercambio) == "L", ::Intercambio, .F. )
Local lPLPRGSN := IIF(GuiaTiss:TipGui == "11",GetNewPar("MV_PLPRGSN", .F.),.F.)
Default ::RecnoBD5 	:= ""
Default ::DtJs		:= ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode , "PLSXFUN", "GetFormTiss" )
	//VARIÁVEL DE RETORNO
	::RetGuiaTiss := WsClassNew( "SRetGuiaTiss" )
	::RetGuiaTiss:CmpGuia := {}

	//VARIAVEL QUE É MANIPULADA
	RetGuia := WsClassNew( "SRetGuiaTiss" )
	RetGuia:CmpGuia := {}

	DbSelectArea("B7C")
	DbSelectArea("B7B")
	DbSelectArea("BCL")
	B7C->(DbSetOrder(1))
	B7B->(DbSetOrder(3))
	BCL->(DbSetOrder(1))

	BCL->(MsSeek(xFilial("BCL")+PlsIntPad()+GuiaTiss:TipGui)) // Não retirar é necessário pelo problema no seek da guia de consulta e de RG que eh 01 e 10
	BCL->(DbGoTop())
	If BCL->(MsSeek(xFilial("BCL")+PlsIntPad()+GuiaTiss:TipGui))
		cFuncLoad :=AllTrim(BCL->BCL_PORLOA)

		IF Empty(cDigiGui)
			cFuncVoltar := AllTrim(BCL->BCL_PORVOL)
		ENDIF
		IF (AltCpAT)
			cFuncVoltar	:= "window.location='W_PPLCHACOM.APW'" //Se veio da opção de alterar guias já autorizadas na tela de consulta autorização
		ENDIF

		IF !Empty(cDigiGui)
			cFuncVoltar	:= "window.location='W_PPLDIGGUIP.APW'" //Se veio do digitação de guias, vai voltar pro digitação de guias
		ENDIF

		cFuncImp := AllTrim(BCL->BCL_PORIMP)

		IF !AltCpAT .or. ::RecnoBD5 <> ""
			cFuncGrv := AllTrim(BCL->BCL_PORGRV)
		ELSE
			cFuncGrv := "fRecCmp(FrmGuia); return false;"
		ENDIF
	Else
		cFuncGrv := ""
		cFuncLoad := ""
		cFuncVoltar := ""
		cFuncImp := ""
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Cria a página
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	oHtml := WCHtml():New()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Cria cabeçalho da página
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	::RetGuiaTiss:Pagina := "true|" + oHtml:getDType(.T.,.T.,,,::DtJs)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Formulario
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	oForm := WCForm():New("FrmGuia")
	oForm:setWidth("800")
	oForm:setTitle(BCL->BCL_PORTIT)
	oForm:setAlignBtn("RIGHT")
	//Funções e botões
	oForm:setJsFClick(cFuncGrv)//("fProcForm(FrmGuia); return false;")
	oForm:setJsFImp(cFuncImp)//("fImpGuia()")
	oForm:setFBack(cFuncVoltar)//("window.location='W_PPLCHAPRE.APW?cP=2'")
	
	if Empty(cDigiGui) .and. GuiaTiss:TipGui $ "01,02,03,07,08,09,11" //se não é digitação offline
		aadd(aCustomBtn,"bAnexoDoc~Anexar documentos~anexoDocGui()") 
	endIf
	
	oForm:setACustomBtn(aCustomBtn) 
	oForm:setFuncLoad(cFuncLoad)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Cria campos Hidden
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	MntHidden(GuiaTiss:TipGui,@oForm)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Tabela principal
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	oTabPriFP := WCTable():New("tabPrincipal")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Logo Institucional
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	oLiImgInst:= WCLine():new()
	oGrpImgInst := WCFieldSet():new("","770","100","100")

	oBLegBr := WCComponent():New("BI","bLegBr","Logo Institucional")
	oBLegBr:SetJsFunc("fLinkLogo();")
	If !Empty(BCL->BCL_PORIMG)
		oBLegBr:setImgBtn("/" + BCL->BCL_PORIMG)
	Else
		oBLegBr:setImgBtn("/Protheus.png")
	EndIf

	oBLegBr:setHelpBtn("Logo Institucional")
	oBLegBr:setAlign('right')
	oBLegBr:setDisable()
	oBLegBr:setImgWidth("260")
	oBLegBr:setImgHeight("53")

	oGrpImgInst:setAddCFS(oBLegBr)
	oLiImgInst:setAddComp(oGrpImgInst)
	oTabPriFP:setAddLine(oLiImgInst)

	//Caso possua guia fornecida para alteração, posiciona na BEA a guia selecionada para alteração.
	if !Empty(::cRecno)
		aAreaBCL  := BCL->(GetArea())
		aAreaB7A  := B7A->(GetArea())
		aAreaB7B  := B7B->(GetArea())
		aAreaSIX  := SIX->(GetArea())
		BEA->(DbSetOrder(1))
		If(BEA->(MsSeek(xFilial("BEA") + ::cRecno)))
			aDadosGuia := PL446DAD(BEA->BEA_TIPGUI)
		EndIf
		RestArea(aAreaBCL)
		RestArea(aAreaB7A)
		RestArea(aAreaB7B)
		RestArea(aAreaSIX)
	endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//Monta os Grupos de Campos e Campos da tela
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	aReturn := MntGrupo(GuiaTiss:TipGui,GuiaTiss:VerTiss,,@oTabPriFP,@RetGuia,@oForm, GuiaTiss:DadCombo,@cGrids,@cDesGri,aDadosGuia,cDigiGui,lTpAlt,lIntercambio)

	//Cria o campo que guarda os nomes e descrições dos grids
	oForm:setAddFieldHidden(alltrim('cGrids'),Alltrim(cGrids))

	//Armazena origem da chamada da tela de digitação
	oForm:setAddFieldHidden(alltrim('cTipoOrigem'),::Tipo)
	//Armazena em hidden a data limite retroativa para digitação de guias
	oForm:setAddFieldHidden(allTrim('dDtLimRetro'),::DtLimRetro)

	//Armazenamento Hidden se trata de alteração de alguns campos após autorização e número da guia
	oForm:setAddFieldHidden(alltrim('cLstCmpAlt'),"")
	oForm:setAddFieldHidden(alltrim('cLstCmpAltServ'),"")
	//Armazenamento Hidden se trata de alteração de alguns campos após autorização e número da guia
	oForm:setAddFieldHidden(alltrim('cAltCmpG'),::Tipo)
	//Armazenamento Hidden se trata do recno da bd5 para alterar as guias de digitação offline
	oForm:setAddFieldHidden(alltrim('cRecnoBD5'),::RecnoBD5)
	oForm:setAddFieldHidden(allTrim('cNumGuiRef'),::NumGuiRef)
   	oForm:setAddFieldHidden(allTrim('cTpGuiRef '),::TpGuiRef)
	oForm:setAddFieldHidden(allTrim('cRecGuiRef'),::RecGuiRef)

	oForm:setAddFieldHidden(alltrim('cValueProcAnt'),"")
	
	oForm:setAddFieldHidden(alltrim('cNumGuiRes'),"")

	If (lPLPRGSN)
		oForm:setAddFieldHidden(alltrim('cPLPRGSN'),"1")
	EndIf
	
	lContinua := aReturn[1]

		//Armazena em hidden a menssagem de paciente internado e bloqueiado
	oForm:setAddFieldHidden(allTrim('cMsnBloInt'),::MsnBloInter)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Tabelas do form
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	oForm:setAddTables(oTabPriFP)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Form no HTML
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	oHtml:setObj(oForm)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ Se deu tudo certo, retorna o HTML
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	If lContinua
		::RetGuiaTiss:Pagina += oHtml:loadWC()
		::RetGuiaTiss:CmpGuia := aClone(RetGuia:CmpGuia)
		::RetGuiaTiss:Grids	:= cGrids
	Else
		::RetGuiaTiss := WsClassNew( "SRetGuiaTiss" )
		::RetGuiaTiss:Pagina := aReturn[2]
	EndIf

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autoriza do a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MntGrupo ³Autor  ³ Alexander	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Monta grupo de campos              						   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
STATIC Function MntGrupo(cTipGui, cVerTiss, cPai, oTabPriFP,RetGuiaTiss,oForm, cDadCmb,cGrids,cDesGri,aDadosGuia,cDigiGui,lTpAlt,lIntercambio)
Local aReturn 		:= {.T.,""}
Local aArea			:= B7C->(GetArea())

Default cTipGui		:= ""
Default cVerTiss	:= ""
Default cPai		:= CriaVar("B7C_GRUPAI")
Default aDadosGuia	:= {}
Default cDigiGui	:= ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³ Varre a tabela de grupos de campos do portal
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
If B7C->(MsSeek(xFilial("B7C")+cTipGui+cVerTiss+cPai) )
	While !B7C->(EOF()) .AND. xFilial("B7C")+cTipGui+cVerTiss+cPai ==;
				B7C->(B7C_FILIAL+B7C_TIPGUI+B7C_TISVER+B7C_GRUPAI)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//Monta os campos do Grupo
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		MntCampo(cTipGui,cVerTiss,cPai,@oTabPriFP,@RetGuiaTiss,@oForm, cDadCmb, @cGrids,@cDesGri,aDadosGuia,cDigiGui,lTpAlt,lIntercambio)

		B7C->(DbSkip())
	EndDo
Else
	aReturn[1] := .F.
	aReturn[2] := "<b>Não existem campos configurados para a guia <br>Contate a Operadora."
EndIf

RestArea( aArea )

Return aReturn

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MntCampo ³Autor  ³ Alexander	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o procedimento e valido						   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
STATIC Function MntCampo(cTipGui, cVerTiss, cPai, oTabPriFP, RetGuiaTiss, oForm, cDadCmb, cGrids, cDesGri, aDadosGuia, cDigiGui, lTpAlt,lIntercambio)
Local cTamanho  := ""
Local nOrdem	:= Val(B7C->B7C_ORDEM)
Local nCmp		:= 0
Local cBtn		:= ""
Local cBtnS	    := ""
Local cAleBS	:= ""
Local nI		:= 0
Local nK		:= 0
Local nOrdemOld := "0"
Local aArSess   := {}
Local aArAux	:= {}
Local aCmbGuia  := {}
Local cConteudo	:= ""
Local cCmpEDI		:= ""
Local lDisable	:= .F.
Default cDesGri	:= ""
Default aDadosGuia := {}
Default cDigiGui	:= ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³ Cria nova Linha
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
&("oLi"+ B7C->B7C_ORDEM ):= WCLine():new()
&("oLi"+ B7C->B7C_ORDEM ):setHGroup()
&("oLi"+ B7C->B7C_ORDEM ):setNomeHGr(Alltrim(B7C->B7C_VARGRU))
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³ Cria o grupo fieldset
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
cGrupo := "oFS" + B7C->B7C_ORDEM
&(cGrupo) := WCFieldSet():new(B7C->B7C_DESCRI,"770","10","10")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³ Varre os campos do grupo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
If B7B->(MsSeek(xFilial("B7B")+cTipGui+cVerTiss+B7C->B7C_ORDEM ) )
	While !B7B->(EOF()) .AND. xFilial("B7B")+cTipGui+cVerTiss+B7C->B7C_ORDEM ==;
			B7B->(B7B_FILIAL+B7B_TIPGUI+B7B_TISVER+B7B_GRUPO)

		//Se o campo não tiver nome de variável vai para o próximo...
		If Empty(B7B->B7B_NOMXMO)
			B7B->(DbSkip())
			Loop
		EndIf
			
		//Campo exclusivo de UNIMEDs para transações de PTU Online
		If AllTrim(B7B->B7B_NOMXMO) == 'cTokEdi' .And. !lIntercambio
			B7B->(DbSkip())
			Loop
		EndIf
			
		cCampo := AllTrim("oCmp"+B7B->B7B_NOMXMO)
		cDescri := Capital(STRZERO(B7B->B7B_ORDEM,3) + " - " + B7B->B7B_DESCRI) //Alterado para Capital, pois, por algum motivo, a função CAPITALACE não funcionava com as palavras "descrição" e "doses"
		cNome := AllTrim(B7B->B7B_NOMXMO)
		nOrdem := B7B->B7B_ORDEM
		lDisable := .F.

		//Se o array de dados da guia possuir elementos, alimenta o conteudo do campo
		//Essa funcionalidade será contemplada no futuro: alteração de guias pelo portal
		/*if (len(aDadosGuia) > 0)
			IF(ValType(aDadosGuia[B7B->B7B_ORDEM]) == "D")
				cConteudo := DTOC(aDadosGuia[B7B->B7B_ORDEM])
			ElseIF(ValType(aDadosGuia[B7B->B7B_ORDEM]) == "N")
				cConteudo := AllTrim(Str(aDadosGuia[B7B->B7B_ORDEM]))
			ElseIF(ValType(aDadosGuia[B7B->B7B_ORDEM]) == "A")
				cConteudo := aDadosGuia[B7B->B7B_ORDEM][1]
			ElseIF(ValType(aDadosGuia[B7B->B7B_ORDEM]) <> "U")
				cConteudo := aDadosGuia[B7B->B7B_ORDEM]
			EndIf
		endif*/
		//Contador de campos
		nCmp := Len(RetGuiaTiss:CmpGuia)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//Alimenta a Struct que servirá de guia na página
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If B7C->B7C_TIPO == 'G'
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//Adiciona o grid a estrutura
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			If !Empty(B7C->B7C_NOMGRI)
				cGrid := AllTrim(B7C->B7C_NOMGRI)
			Else
				cGrid := "Brw" + B7C->B7C_ORDEM
			EndIf
			If nCmp == 0 .OR. nOrdemOld <> B7B->B7B_GRUPO
				nCmp++
				nK := 1
				AaDd( RetGuiaTiss:CmpGuia, WsClassNew( "SCmpGuia" ) )
				RetGuiaTiss:CmpGuia[nCmp]:Tipo := 'G'
				RetGuiaTiss:CmpGuia[nCmp]:Nome := cGrid
				RetGuiaTiss:CmpGuia[nCmp]:Descri := ""
				RetGuiaTiss:CmpGuia[nCmp]:CmpGrid := {}
				RetGuiaTiss:CmpGuia[nCmp]:aCols := {}
				RetGuiaTiss:CmpGuia[nCmp]:aHeader := {}
				RetGuiaTiss:CmpGuia[nCmp]:xCols := ""
				RetGuiaTiss:CmpGuia[nCmp]:xHeader := ""

				oForm:setGlobalVar("o"+cGrid)

				//Prepara variável que seja passada para o JS com os campos do Grid
				If !Empty(cGrids)
					cGrids += "@"
				EndIf
				cGrids += cGrid + "~"

			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//Adiciona os campos da Grid
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			AaDd( RetGuiaTiss:CmpGuia[nCmp]:CmpGrid, WsClassNew( "SCmpGrid" ) )
			RetGuiaTiss:CmpGuia[nCmp]:CmpGrid[nK]:Tipo := B7B->B7B_TIPO
			RetGuiaTiss:CmpGuia[nCmp]:CmpGrid[nK]:Nome := cNome
			RetGuiaTiss:CmpGuia[nCmp]:CmpGrid[nK]:Descri := B7B->B7B_DESCRI
			nK++
			nOrdemOld := B7B->B7B_GRUPO

			//cGrids += "'" + cNome + "',"
			cGrids += cNome + ","
			cDesGri += B7B->B7B_DESCRI + ","
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//Adiciona os campos
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			nCmp++
			AaDd( RetGuiaTiss:CmpGuia, WsClassNew( "SCmpGuia" ) )

			RetGuiaTiss:CmpGuia[nCmp]:Tipo := B7B->B7B_TIPO
			RetGuiaTiss:CmpGuia[nCmp]:Nome := cNome
			RetGuiaTiss:CmpGuia[nCmp]:Descri := B7B->B7B_DESCRI
			RetGuiaTiss:CmpGuia[nCmp]:CmpGrid := {}

		EndIf

		//Recupera tamanho do campo
		If Len(cDescri) > B7B->B7B_TAMANH
			cTamanho := STR(Len(cDescri))
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Monta os objetos HTML
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		Do Case

		Case B7B->B7B_TIPO == 'T'
			If B7B->(FieldPos('B7B_MAXLEN')) > 0 .AND. B7B->B7B_MAXLEN > 0
				//Para um atendimento normal, o campo de Protocolo de Atendimento não pode permitir digitação e deve ser obrigatório
				//Para um atendimento de intercambio, o campo deve ser opcional e permite digitação
				If !lIntercambio .And. cNome $ ("cProtoc")
					&(cCampo) := WCComponent():new("F",cNome,cDescri,,Alltrim(STR(B7B->B7B_MAXLEN)),.T.)
				Else
					&(cCampo) := WCComponent():new("F",cNome,cDescri,,Alltrim(STR(B7B->B7B_MAXLEN)),B7B->B7B_OBRIGA)
				Endif
			Else
				&(cCampo) := WCComponent():new("F",cNome,cDescri,,Alltrim(STR(B7B->B7B_TAMANH)),B7B->B7B_OBRIGA)
			EndIf

		Case B7B->B7B_TIPO == 'F' // Tipo File
			If B7B->(FieldPos('B7B_MAXLEN')) > 0 .AND. B7B->B7B_MAXLEN > 0
				&(cCampo) := WCComponent():new("F",cNome,cDescri,,Alltrim(STR(B7B->B7B_MAXLEN)),B7B->B7B_OBRIGA)
			Else
				&(cCampo) := WCComponent():new("F",cNome,cDescri,,Alltrim(STR(B7B->B7B_TAMANH)),B7B->B7B_OBRIGA)
			EndIf
			&(cCampo):setType("file") // Falo que é do tipo file

		Case B7B->B7B_TIPO == 'M'
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Insere objeto do tipo TEXTAREA
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			&(cCampo) := WCComponent():new("TA",cNome,cDescri,'500',STR(B7B->B7B_TAMANH),B7B->B7B_OBRIGA)

		Case B7B->B7B_TIPO == 'C'
			cTamanho := Alltrim(B7B->B7B_TAMANH)

			aArSess 	:= {}
			aCmbGuia 	:= {}
			aArAux		:= {}
			If ValType(cDadCmb) <> 'U'
				aCmbGuia := StrToArray(cDadCmb, "|")
			EndIf

			&(cCampo) := WCComponent():new("C",cNome,cDescri,cTamanho,Alltrim(STR(B7B->B7B_TAMANH)),B7B->B7B_OBRIGA,.f.)

			For nI := 1 To Len(aCmbGuia)
				If  Alltrim(B7B->B7B_NOMXMO) $ aCmbGuia[nI] .AND. ";" $ aCmbGuia[nI]
					aArAux := Separa(aCmbGuia[nI], ";")
					Exit
				EndIf
			Next nI
			For nI := 2 To Len(aArAux) // Começa a partir da segunda posição pois a primeira eh o nome do campo
				AADD(aArSess, aArAux[nI])
			Next

			If !Empty(aArSess)
				&(cCampo):setArrCombo(aArSess)
			EndIf

			&(cCampo):setIsName()

		EndCase

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//Seta as propriedades comuns dos campos
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If !Empty(Alltrim(B7B->B7B_INIPAD))
			cIniPad := AllTrim(B7B->B7B_INIPAD)
			If B7B->B7B_TIPO == 'C'
				&(cCampo):setDefCB(cInipad)
			EndIf
			&(cCampo):setValue(cIniPad)

		EndIf
		//ele tem que ficar aqui do lado de fora pois o usuario pode criar um inicializador novo, dai la no jsusr.pls eu ja coloquei todos campos do grid
		//oForm:setAddFieldHidden(alltrim('aInipad'+B7B->B7B_CAMPO),Alltrim(B7B->B7B_INIPAD))
		If !Empty(B7B->B7B_INIPAD)
			oForm:setAddFieldHidden(alltrim('aInipad'+B7B->B7B_NOMXMO),Alltrim(B7B->B7B_INIPAD))
		EndIf

		If Empty(cDigiGui)
			If !lTpAlt
				If !(B7B->B7B_EDITAR)
					&(cCampo):setReadOnly()
					lDisable := .T.
				EndIf
				If !Empty(Alltrim(B7B->B7B_F3))
					&(cCampo):setJsFF3(B7B->B7B_F3)
					&(cCampo):setOpenGrp(.T.)
					&(cCampo):setCloseGrp(.T.)
				EndIf
			Else
				If !(B7B->B7B_EDIALT)
					&(cCampo):setReadOnly()
					lDisable := .T.
				ElseIf B7B->B7B_EDIALT .And. !(cNome $ ("cTpAteExe|cIndAcid|cTpCon|cTpSai|cProSol|cCbosExe|cVlrPro|cAssBen|cObs"))
					&(cCampo):setReadOnly()
					lDisable := .T.
				Else
					If !Empty(Alltrim(B7B->B7B_F3))
						&(cCampo):setJsFF3(B7B->B7B_F3)
						&(cCampo):setOpenGrp(.T.)
						&(cCampo):setCloseGrp(.T.)
					EndIf
				EndIf

			EndIf
		Else
			If !(B7B->B7B_EDIOFF)
				&(cCampo):setReadOnly()
				lDisable := .T.
			ElseIf B7B->B7B_EDIOFF .And. (cNome $ ("cNumeHoId|cGuiaInter")) .And. lTpAlt 
				&(cCampo):setReadOnly()
				lDisable := .T.
			Else
				If !Empty(Alltrim(B7B->B7B_F3))
					&(cCampo):setJsFF3(B7B->B7B_F3)
					&(cCampo):setOpenGrp(.T.)
					&(cCampo):setCloseGrp(.T.)
				EndIf
			EndIf
		EndIf

		If !Empty(Alltrim(B7B->B7B_KEYPRE))
			&(cCampo):setJSKeyPre(alltrim(B7B->B7B_KEYPRE))
		EndIf

		If B7B->B7B_OBRIGA
			oForm:setObrigat(B7B->B7B_NOMXMO,AllTrim(B7B->B7B_KEYPRE))
		ElseIf !lIntercambio .And. cNome $ ("cProtoc")
			&(cCampo):setReadOnly()
			oForm:setObrigat(B7B->B7B_NOMXMO,AllTrim(B7B->B7B_KEYPRE))
		EndIf

		If !Empty(Alltrim(B7B->B7B_KEYDOW))
			&(cCampo):setJSKeyDown(alltrim(B7B->B7B_KEYDOW))
		EndIf

		If !Empty(Alltrim(B7B->B7B_VALID))
			cValid := AllTrim(B7B->B7B_VALID)
			&(cCampo):setJSBlur(cValid)
		EndIf

		If !Empty(Alltrim(B7B->B7B_GATILH))
			cGatilho := AllTrim(B7B->B7B_GATILH)
			cChave := AllTrim(B7B->B7B_CHVGAT)
			&(cCampo):setJSChange("validCmpGen(null"+",'"+;
				cNome+"',"+IIF(Empty(cGatilho),"null","'"+cGatilho+"'")+","+IIF(Empty(cChave),"null","'"+cChave+"'")+")")
		EndIf

		If !Empty(Alltrim(B7B->B7B_ACTION))
			&(cCampo):setJsFBtn(B7B->B7B_ACTION)
			&(cCampo):setOpenGrp(.T.)
			&(cCampo):setCloseGrp(.T.)
		EndIf

		If B7B->(FieldPos('B7B_ACTIO2'))>0 .AND. !Empty(Alltrim(B7B->B7B_ACTIO2)) .AND. !lDisable
			&(cCampo):setJsFBtL(B7B->B7B_ACTIO2)
			&(cCampo):setOpenGrp(.T.)
			&(cCampo):setCloseGrp(.T.)
		EndIf

		If B7B->(FieldPos('B7B_TOOTIP'))>0 .AND. B7B->B7B_TOOTIP == '1'
			&(cCampo):setToolTip('1')
		EndIf

		If B7B->(FieldPos('B7B_HELP'))>0 .AND. !Empty(Alltrim(B7B->B7B_HELP))
			&(cCampo):setJsHelp(B7B->B7B_HELP)
		EndIf

		If !Empty(Alltrim(B7B->B7B_CHANGE))
	 		cChange := AllTrim(B7B->B7B_CHANGE)
	 		&(cCampo):setJSChange(cChange)
	 	EndIf

		If !Empty(Alltrim(B7B->B7B_CSS))
	 		&(cCampo):setCSS(B7B->B7B_CSS)
	 	EndIf
		//Adiciona classe do calendário nos campos de data porém quando o campo esta desabilitado não pode adicionar
		if UPPER(SubStr(Alltrim(B7B->B7B_NOMXMO),1,1)) == "D" .AND. !lDisable
			&(cCampo):setData(.T.)
		endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//Seta componente ao fiedlset
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		&(cGrupo):setAddCFS(&(cCampo))
		B7B->(DbSkip())
	EndDo

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³ As Grids necessitam de alguns objetos a mais
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	If B7C->B7C_TIPO == 'G'

		cGrids += "|" + cDesGri
		cDesGri := ""
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Campo oculto RECNO
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		oForm:setAddFieldHidden(cGrid + "_RECNO","")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Botao Salvar
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If !Empty(B7C->B7C_FUNSAV)
			cBtnS := "oSave" + cGrid
			&(cBtnS) := WCComponent():New("B","bSave" + cGrid,"Salvar")

			cFunSave := B7C->B7C_FUNSAV + " ; "
			&(cBtnS):SetJsFunc(cFunSave)
			&(cBtnS):setAlign('right')
			&(cBtnS):setInlineB(.T.)
			&(cBtnS):setDisable()
			&(cBtnS):setCSS("Botoes")
			&(cBtnS):setNoTagTDIE()
			&(cBtnS):setOpenGrp(.T.)
			&(cBtnS):setCloseGrp( Empty(B7C->B7C_LINOK) ) //Se o B7C_LINOK estiver vazio, fecha o grupo, se não estiver, vai fechar no if abaixo
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Botao incluir
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		If !Empty(B7C->B7C_LINOK)
			cBtn := "oInc" + cGrid
			&(cBtn) := WCComponent():New("B","bInc" + cGrid,"Incluir")

			cFunInc := B7C->B7C_LINOK + " ; "
			&(cBtn):SetJsFunc(cFunInc)
			&(cBtn):setAlign('right')
			&(cBtn):setInlineB(.T.)
			&(cBtn):setCSS("Botoes")
			&(cBtn):setNoTagTDIE()
			&(cBtn):setOpenGrp(.F.)
			&(cBtn):setCloseGrp(.T.)
		EndIf
		
		//-----------------------------------------------------------------------------------
		//   Componente de alert do bootstrap para exibir mensagens no grid ao add um item
		//-----------------------------------------------------------------------------------
		
		cAleBS := "info"+cGrid
		&(cAleBS) := WCComponent():New("CHTM")
		&(cAleBS):setValue( '<div class="col-xs-12 col-sm-12 col-md-12 col-lg-12"><div class="alert alert-info" id="' + "info"+cGrid +'" style="display:none;"></div></div>' )
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Grid
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		&(cGrid) := WCComponent():New("BW",cGrid)
		&(cGrid):setBrWidth("770")
		&(cGrid):setJsFunc("")
		&(cGrid):setPosicao("30")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		//³ Adiciona os componentes ao grupo
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

		If !Empty(B7C->B7C_FUNSAV)
			&(cGrupo):setAddCFS(&(cBtnS))
		EndIf
		If !Empty(B7C->B7C_LINOK)
			&(cGrupo):setAddCFS(&(cBtn))
		EndIf

		&(cGrupo):setAddCFS(&(cAleBS))
		&(cGrupo):setAddCFS(&(cGrid))

	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//Seta o Grupo à Linha
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	&("oLi"+ B7C->B7C_ORDEM ):setAddComp(&(cGrupo))

EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³ Fechamento da Tabela
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
oTabPriFP:setAddLine(&("oLi"+ B7C->B7C_ORDEM ))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³ Cria subgrupos
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
MntGrupo(cTipGui,cVerTiss,B7C->B7C_ORDEM,@oTabPriFP,@RetGuiaTiss,@oForm,GuiaTiss:DadCombo,@cGrids, @cDesGri, aDadosGuia,cDigiGui,lTpAlt, lIntercambio)


Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MntHidden ³Autor  ³ Alexander	            ³ Data ³06.03.2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Insere campos hidden na guia                         		  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
STATIC Function MntHidden(cTipGui,oForm,aCampos)

Local nLen	:= 0
Local nPos	:= 0

DEFAULT aCampos := { 	;
						{"01","cRda"		,"<%=HttpGet->cRda%>"       										       },;
						{"01","cCodLoc"	,"<%=HttpGet->cCodLoc%>"       												},;
						{"01","cTpPe"		,""                              											},;
						{"01","cNomeExe"	,""                           												},;
						{"01","cRegEsp"	,"<%=HttpSession->ExisRegEsp%>"												},;
						{"01","cCpsObr"	,"<%=HttpSession->cObrCpGuia%>"												},;
						{"01","cmvTabDef",GETMV("MV_TABDEF")															},;
						{"01","cTp"		,"<%=HttpSession->cTp%>"														},;
						{"01","cProSol"	,""																				},;
						{"02","cCmpl"		,"<%=IIf (Type('HttpSession->cCmpl') <> 'U',HttpSession->cCmpl,'')%>"	},;
						{"02","cTp"		,"<%=IIf(Type('HttpSession->cTp') <> 'U' ,HttpSession->cTp,'')%>"		},;
						{"02","cRda"		,"<%=HttpGet->cRda%>"														},;
						{"02","cCodLoc"	,"<%=HttpGet->cCodLoc%>"														},;
						{"02","cChvBD6"	,""																				},;
						{"02","cTpPe" 	,""																				},;
						{"02","cNomeSol"	,""																				},;
						{"02","cNomeExe"	,""																				},;
						{"02","cSeqProc"	,""																				},; 
						{"02","cStatusAut","0"																			},;
						{"02","cmvTabDef",GETMV("MV_TABDEF")															},;
						{"02","cMatTabES"	,""																				},;
						{"02","cMatTabExe",""																			},;
						{"02","cCmpIndCli",""																			},;
						{"02","cPacote",""																				},;
						{"02","cRegEsp"	,"<%=HttpSession->ExisRegEsp%>"												},;
						{"02","cIteRegEsp",""																			},;
						{"02","cCpsObr"	,"<%=HttpSession->cObrCpGuia%>"												},;
						{"02","cProSol"	,""																				},;
						{"02","cStatItem",""																				},; 
						{"02","cDataServ","<%=IIF(VALTYPE(HttpSession->USR_INFO[1]:OWSUSERLOGPLS:dDataServer) == 'D',"  +;
												" DTOC(HttpSession->USR_INFO[1]:OWSUSERLOGPLS:dDataServer),'')%>"       },; 
						{"03","cmvTabDef",GETMV("MV_TABDEF")															},;
						{"03","cRda"		,"<%=HttpGet->cRda%>"														},;
						{"03","cCodLoc"	,"<%=HttpGet->cCodLoc%>"														},;
						{"03","cCmpl"		,"<%=HttpSession->cCmpl%>"													},;
						{"03","cTp"		,"<%=HttpSession->cTp%>"														},;
						{"03","cChvBD6"	,""																				},;
						{"03","cNomeSol"	,""																				},;
						{"03","cStatusAut","0"																			},;
						{"03","cMatTabES"	,""																				},;
						{"03","cCmpIndCli",""																			},;
						{"03","cRdaSolT"	,""																				},;
						{"03","cProfSolT"	,""																				},;
						{"03","cProSol"	,""																				},;
						{"03","cOpeSolT"	,""																				},;
						{"03","dDatInt"	,""																				},;
						{"03","dDatAlt"	,""																				},;
						{"03","cGralau"	,""																				},;
						{"03","cDataServ","<%=IIF(VALTYPE(HttpSession->USR_INFO[1]:OWSUSERLOGPLS:dDataServer) == 'D'," +;
												" DTOS(HttpSession->USR_INFO[1]:OWSUSERLOGPLS:dDataServer),'')%>"},;
						{"05","cCmpl"		,"<%=IIf (Type('HttpSession->cCmpl') <> 'U',HttpSession->cCmpl,'')%>"	},;
						{"05","cTp"		,"<%=IIf(Type('HttpSession->cTp') <> 'U' ,HttpSession->cTp,'')%>"		},;
						{"05","cRda"		,"<%=HttpGet->cRda%>"														},;
						{"05","cCodLoc"	,"<%=HttpGet->cCodLoc%>"														},;
						{"05","cChvBD6"	,""																				},;
						{"05","cTpPe" 	,""																				},;
						{"05","cNomeSol"	,""																				},;
						{"05","cNomeExe"	,""																				},;
						{"05","cSeqProc"	,""																				},; 
						{"05","cStatusAut","0"																			},;
						{"05","cmvTabDef",GETMV("MV_TABDEF")															},;
						{"05","cMatTabES"	,""																				},;
						{"05","cMatTabExe",""																			},;
						{"05","cCmpIndCli",""																			},;
						{"05","cPacote",""																				},;
						{"05","cRegEsp"	,"<%=HttpSession->ExisRegEsp%>"												},;
						{"05","cIteRegEsp",""																			},;
						{"05","cCpsObr"	,"<%=HttpSession->cObrCpGuia%>"												},;
						{"05","cProSol"	,""																				},;
						{"05","cProExe"	,""																				},;
						{"05","cTissVer"	,"<%=HttpSession->cTissVer%>"												},;	
						{"05","cCritProc"	,""												},;																														
						{"05","cPadConfSol",""																			},;		
						{"05","cTpAcomSol",""																			},;																														
						{"05","cNumMaxAux","<%=HttpSession->cNumAux%>"												},;																								
						{"06","cRda"		,"<%=IIF(Type('HttpSession->cRdaRel') <> 'U',HttpSession->cRdaRel,HttpGet->cRda)%>"},;
						{"06","cCodLoc"	,"<%=IIF(Type('HttpSession->cCodLoc') <> 'U',HttpSession->cCodLoc,HttpGet->cCodLoc)%>"},;
						{"06","cChvBD6"	,""																				},;
						{"06","cProSol"	,""																				},;
						{"06","cMatTabES"	,""																			},;
						{"06","cMatTabExe",""																			},;
						{"06","cProExe"	,""																				},;
						{"06","cTp"		,"<%=HttpSession->cTp%>"														},;
						{"06","cTissVer"	,"<%=HttpSession->cTissVer%>"												},;
						{"06","cNumMaxAux","<%=HttpSession->cNumAux%>"												},;	
						{"07","cStatusAut","0"																			},;
						{"07","cNumAut","0"																				},;
						{"07","cMatTabExe",""																			},;
						{"07","cMatTabES"	,""																				},;
						{"07","cTp"		,"<%=HttpSession->cTp%>"														},;
						{"08","cMatTabES"	,""																				},;
						{"08","cStatusAut","0"																			},;
						{"08","cNumAut","0"																				},;
						{"08","cMatTabExe",""																			},;
						{"08","cTp"		,"<%=HttpSession->cTp%>"														},;
						{"09","cNumAut","0"																				},;
						{"09","cStatusAut","0"																			},;
						{"09","cMatTabExe",""																			},;
						{"09","cMatTabES"	,""																				},;
						{"09","cTp"		,"<%=HttpSession->cTp%>"														},;
						{"10","cRecnoB4D"	,"<%=HttpGet->cRecnoB4D%>"    										       },;
						{"10","cMatJustif",""																			},;
						{"10","cOpc"		,"<%=HttpGet->cOpc%>"														},;
						{"10","cTpRecGlo"	,""																				},;
						{"11","cCmpl"		,"<%=IIf (Type('HttpSession->cCmpl') <> 'U',HttpSession->cCmpl,'')%>"	},;
						{"11","cTp"		,"<%=IIf(Type('HttpSession->cTp') <> 'U' ,HttpSession->cTp,'')%>"		},;
						{"11","cRda"		,"<%=IIF(Type('HttpSession->cRdaRel') <> 'U',HttpSession->cRdaRel,HttpGet->cRda)%>"},;
						{"11","cCodLoc"	,"<%=IIF(Type('HttpSession->cCodLoc') <> 'U',HttpSession->cCodLoc,HttpGet->cCodLoc)%>"},;
						{"11","cChvBD6"	,""																				},;
						{"11","cTpPe" 	,""																				},;
						{"11","cProSol"	,""																				},;
						{"11","cNomeSol"	,""																				},;
						{"11","cNomeExe"	,""																				},;
						{"11","cStatusAut","0"																			},;
						{"11","cTissVer"	,"<%=HttpSession->cTissVer%>"												},;
						{"11","cMatTabES"	,""																				},;
						{"11","cmvTabDef",GETMV("MV_TABDEF")															},;
						{"11","cRdaLog","<%= PLA09ASES() %>"															},; //Rdas's Que estão Logadas no Sistema					
						{"12","cRda"		,"<%=HttpGet->cRda%>"       										       },;
						{"12","cCodLoc"	,"<%=HttpGet->cCodLoc%>"       												},;
						{"12","cTpPe"		,""                              											},;
						{"12","cChvBD6"	,""																				},;
						{"12","cNomeExe"	,""                           												},;
						{"12","cTp"		,"<%=HttpSession->cTp%>"      												},;
						{"12","cMatTabES"	,""																				},;
						{"12","cMatTabExe",""																			},;
						{"12","cProExe"	,""																				},;
						{"12","cStatusAut","0"																			},;
						{"12","cTissVer"	,"<%=HttpSession->cTissVer%>"												},;
						{"12","cDatIniFat"	,""												},;
						{"12","cDatFimFat"	,""												},;
						{"12","cDatAtd"	,"<%=HttpSession->cDatAtd%>"												};
					}

//Permite a inclusão de campos Hidden por P.E.
If ExistBlock("PLSCPHID")
	aCampos := ExecBlock("PLSCPHID",.F.,.F.,{cTipGui,aCampos})
Endif

While (nPos:=aScan( aCampos , {|x| AllTrim(x[1]) == cTipGui} )) > 0 .AND. aCampos[nPos][1] == cTipGui
	oForm:setAddFieldHidden(aCampos[nPos,2],aCampos[nPos,3])
	nSize := Len(aCampos)
	aDel(aCampos,nPos)
	aSize(aCampos,nSize-1)
EndDo

Return

//--------------------------------------------------------------------
/*/{Protheus.doc} RetClassProc

Retorna as classes de procedimentos cadastradas na BJE
@since 02/2014
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD RetClassProc WSRECEIVE userCode WSSEND MClasseProc WSSERVICE PLSXFUN
LOCAL aArea 	:= getArea()
LOCAL lRetorno	:= .t.
LOCAL nC			:= 0
LOCAL cSql 		:= ""
LOCAL lPadPro 	:= (BJE->(FieldPos("BJE_CODPAD")) > 0) .AND. (BJE->(FieldPos("BJE_CODPRO")) > 0)
DEFAULT ::WSNULL := ""

////////////////////////////////////////////////////////////////////////////////
//³Se tem direito para executar o metodo
////////////////////////////////////////////////////////////////////////////////
If PrtChkUser( ::userCode ,"PLSXFUN","RetClassProc" )
	
	////////////////////////////////////////////////////////////////////////////////
	//³ alimenta array de classes
	////////////////////////////////////////////////////////////////////////////////
	
	cSql := "SELECT " 
	cSql += "BJE_CODINT, "
	cSql += "BJE_CODIGO, "
	cSql += "BJE_ISMEDI, "
	cSql += "BJE_DESCRI, "
	cSql += "BJE_CODPAD, "
	cSql += "BJE_CODPRO  "
	cSql += " FROM " + retSqlName("BJE") + " BJE " 
	cSql += " INNER JOIN " + retSqlName("BR8") + " BR8 "
	cSql += " ON BJE_FILIAL = '" + xFilial("BJE") + "'"
	cSql += " AND BR8_FILIAL = '" + xFilial("BR8") + "'"
	cSql += " AND BJE_CODIGO = BR8_CLASSE " 
	cSql += " AND BR8_EXPBEN = '1' "
	cSql += " AND BJE.D_E_L_E_T_ = ' '"
	cSql += " AND BR8.D_E_L_E_T_ = ' '"
	cSql += "GROUP BY "
	cSql += "BJE_CODINT, "
	cSql += "BJE_CODIGO, 
	cSql += "BJE_DESCRI, "
	if lPadPro
		cSql += "BJE_CODPAD, "
		cSql += "BJE_CODPRO,  "
	endIf
	cSql += "BJE_ISMEDI "
	cSql += "ORDER BY BJE_DESCRI "
	
	cSQL := ChangeQuery(cSQL)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TrbBJE",.T.,.F.)

	while !TrbBJE->(EOF())

			nC ++
			AaDd( ::MClasseProc, WsClassNew( "SClasseProc" ) )
			::MClasseProc[nC]:CodInt			:= TrbBJE->BJE_CODINT
			::MClasseProc[nC]:Code			:= TrbBJE->BJE_CODIGO + "|" + IIF( Vazio(AllTrim(TrbBJE->BJE_ISMEDI)), "0", TrbBJE->BJE_ISMEDI )
			::MClasseProc[nC]:Description	:= TrbBJE->BJE_DESCRI
			if lPadPro
				::MClasseProc[nC]:CodPad  	:= TrbBJE->BJE_CODPAD
				::MClasseProc[nC]:CodProc	:= TrbBJE->BJE_CODPRO
				
				BR8->(DbSetOrder(1)) 
				If BR8->(MsSeek(xFilial("BR8") + TrbBJE->BJE_CODPAD + TrbBJE->BJE_CODPRO))
				
					::MClasseProc[nC]:DesProc := AllTrim(BR8->(BR8_DESCRI))
				Else
					::MClasseProc[nC]:DesProc := "Descrição não encontrada"
				EndIf 
			endIf

		TrbBJE->(DbSkip())
	EndDo

	TrbBJE->(DbCloseArea())
Else
	lRetorno := .f.
	setSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ChkCid 	³Autor  ³ Tabosa 	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o cid	e valido						  		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RDANotRef WSRECEIVE UserCode, CpfCnpj WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aArea    		:= GetArea()
DEFAULT ::WSNULL 	:= "true|"
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "RDANotRef" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se verifica se e consulta											   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BK6->( DbSetOrder(4) )//BK6_FILIAL+BK6_CGC
	If !BK6->( MsSeek( xFilial("BK6")+ StrTran(StrTran(StrTran(::CpfCnpj,".",""),"-",""),"/","") ) )
	   ::WSNULL := "false|Rede de atendimento não encontrada"
	Else
		::WSNULL := "true|" + BK6->(BK6_CODIGO+"|"+Alltrim(BK6_NOME)+"|"+Alltrim(BK6_SIGLA)+"|"+BK6_ESTCR)
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    AutAnexo   ³Autor  ³ Daher		            ³ Data ³26.02.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Checa regra de um procedimento para um atendimento		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD AutAnexo WSRECEIVE UserCode, SAutProc WSSEND RetAutProc WSSERVICE PLSXFUN
LOCAL nI		 := 0
LOCAL nCont		 := 0
LOCAL cTipo		 := "1"
LOCAL cMsg		 := ""
LOCAL lRetorno 	 := .T.
LOCAL lAto		 := .F.
LOCAL cAno		 := ""
LOCAL cMes       := ""
LOCAL cString	 := ""
LOCAL cMatRetRes := "" //Resultado da solicitacao da matriz de retorno separados por ";" para campo e valor e por "#" para outro campo.
LOCAL nQtdUs	 := 0
LOCAL nVlrCon	 := 0
LOCAL nVlrTPF	 := 0
LOCAL aMatRet    := {} //Matriz de retorno faz tratamento para ate 10 retornos diferentes
LOCAL aRetCri	 := {}
LOCAL aVldGen	 := nil
LOCAL aCritica	 := {{}}
LOCAL aRet		 := {}
LOCAL aDadUsr    := {}
LOCAL aValor	 := {}
LOCAL aQtdBrw	 := {}
LOCAL aArea    	 := GetArea()

PRIVATE aTabDup 	:= PlsBusTerDup(SuperGetMv("MV_TISSCAB", .F. ,"87"))
PRIVATE aErrVarVin 	:= {.F., "", "", ""}

//Checa Usuário
If PrtChkUser( ::UserCode, "PLSXFUN", "AutProc" )
	
	//Ponto de entrada para troca de dados na aut do portal
	If ExistBlock("PLCHEDAD")
	
		aRetPtoEnt := ExecBlock("PLCHEDAD",.F.,.F.,{::SAutProc:CodPad,	::SAutProc:CodPro,::SAutProc:TipoProc })
	
		::SAutProc:CodPad 	:= aRetPtoEnt[1]
		::SAutProc:CodPro	:= aRetPtoEnt[2]
		::SAutProc:TipoProc	:= aRetPtoEnt[3]
		
	EndIf
	
	//Monta a matriz de retorno
	cString := ::SAutProc:MatRet
	
	While ( nPos := At( "~", cString ) ) > 0
		AaDd( aMatRet,SubStr( cString, 1, nPos-1 ) )
		cString := SubStr( cString, nPos+1, Len(cString) )
	EndDo
	
	//Monta matriz com procedimentos ja executados
	//Pega o ano e o mes de pagamento
	aRet := PLSXVLDCAL(::SAutProc:DatPro,PLSINTPAD(),.F.,"","")
	
	If aRet[1]
		
		cMes := aRet[5]
		cAno := aRet[4]
		
	ElseIf Len(aRet[2]) > 0
		
		lRetorno := .F.
		SetSoapFault( "", aRet[2,1,1]+" - "+aRet[2,1,2])
		
	EndIf
	
	//Verifica Usr
	If lRetorno
		
		//Dados do usuario
		aRet := PLSDADUSR(::SAutProc:Matric,cTipo,.F.,::SAutProc:DatPro,Nil,Nil,Nil)
		
		If aRet[1]
			aDadUsr := PLSGETUSR()
		Else
		
			lRetorno := .F.
			
			For nI := 1 To Len(aRet[2])
				cMsg += aRet[2,nI,1]+" - "+AllTrim(aRet[2,nI,2])+Iif(nI!=1," - "+AllTrim(aRet[2,nI,3]),"")+Chr(13)+Chr(10)
			Next
			
			SetSoapFault( "", cMsg)
			
		EndIf
		
	EndIf
	
	//Verifica se pode fazer a autorizacao
	cCodPad := AllTrim(PLSVARVINC('87','BR4', ::SAutProc:CodPad))
	cCodPro := AllTrim(PLSVARVINC(::SAutProc:CodPad,'BR8',::SAutProc:CodPro ,cCodPad+::SAutProc:CodPro,,aTabDup,@CCODPAD))
	
	If aErrVarVin[1] == .T.
		SetSoapFault( "", "De/Para não realizado para ->  ("+::SAutProc:CodPad+") "+::SAutProc:CodPro )
		Return .F.
	EndIf
	
	If 	!PChkTabDup(@cCodPad,cCodPro,::SAutProc:CodPad,.T.)
		SetSoapFault( "", "Procedimento Bloqueado pela Operadora -> ("+::SAutProc:CodPad+") "+::SAutProc:CodPro )
		Return .F.
	EndIf
	
	::SAutProc:CodPad := cCodPad
	::SAutProc:CodPro := cCodPro
	
	For nI := 1 To Len( ::SAutProc:AutItem )
	
		AaDd( aQtdBrw, {PADR(cCodPad,Len(BR8->BR8_CODPAD)),;
						PADR(cCodPro,Len(BR8->BR8_CODPSA)),;
						::SAutProc:AutItem[nI]:ProcedureQuantity,;
						::SAutProc:DATPRO,;
						::SAutProc:AutItem[nI]:HORINI,;//Iif(ValType(SAutProc:AutItem[nI]:HORINI)=='C',::SAutProc:AutItem[nI]:HORINI,Substr(TIME(),1,5)),;
						PADR(::SAutProc:AutItem[nI]:DENTE,Len(B04->B04_CODIGO)),;
						PADR(::SAutProc:AutItem[nI]:FACE,Len(B09->B09_FADENT)),;
						StrZero(Val(::SAutProc:AutItem[nI]:SEQUENCE), TamSx3("BD6_SEQUEN")[1])} )
	Next
	
	If lRetorno

		//Checa a regra para um determinado procedimento							 
		aRet := PLSAUTP(::SAutProc:DatPro,;
						nil,;
						PADR(::SAutProc:CodPad,Len(BR8->BR8_CODPAD)),;
						PADR(::SAutProc:CodPro,Len(BR8->BR8_CODPSA)),;
						::SAutProc:QtdPro,;
						aDadUsr,;
						nil,;
						nil,;
						"1",;
						.f.,;
						::SAutProc:Cid,;
						.t.,;
						"1",;
						.f.,;
						nil,;
						nil,;
						cAno,;
						cMes,;
						nil,;
						nil,;
						nil,;
						.t.,;
						nil,;
						nil,;
						0,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						.f.,;//33
						"2",;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						.f.,;//49
						.f.,;
						nil,;
						nil,;
						aQtdBrw,;
						aVldGen,;
						nil,;
						nil,;
						nil,;
						nil,;
						.f.,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						nil,;
						iIf(! empty(::SAutProc:TipGui),PADL(::SAutProc:TipGui,2,"0"),""),;
						nil,;
						nil,;
						.T.)

		//Retorno															   	   
		If Len(aRet) > 0
		
			::RetAutProc		:= WsClassNew( "SMatRetAutProc" )
			::RetAutProc:ProAut	:= aRet[1]
			
			aCritica 			:= aRet[2]
			::RetAutProc:Nivel	:= aRet[3]
			::RetAutProc:Chave	:= aRet[4]

			lAto				:= Iif( len(aRet) >= 5, aRet[5], .f. )
			aValor 				:= Iif( len(aRet) == 6 .and. lAto , aRet[6], {} )

			::RetAutProc:Autori	:= ""
			::RetAutProc:MatCri	:= {}
			
			//Se foi autorizado														  
			If aRet[1]
				::RetAutProc:Autori := iif(valType(aRet[2])=='C',aRet[2],'') //BR8_AUTORI (0=Dispensa Autorizacao;1=Automatica;2=Guia Operadora;3=Auditoria;4=Guia Empresa;5=Guia Empresa/Operadora;6=Avalicao Contratual)
			Else
				
				//Criticas																 
				For nI := 1 To Len(aCritica)
					
					//Retira a informacao de nivel das criticas
					If At('nível',Lower(aCritica[nI,2])) > 0
						Loop
					endIf
					
					If ! empty(aCritica[nI,1])
					
						aRetCri := PLSRETCRI( AllTrim( aCritica[nI,1] ) )
						
						if empty(aRetCri[1][2])
							aRetCri[1][1] := aCritica[nI][2]
							aRetCri[1][2] := aCritica[nI][3]
						endIf
						
					else
						
						aRetCri := {}
						aadd(aRetCri,{"",aCritica[nI,2]} )
						
					endIf
					
					nCont++
					aadd( ::RetAutProc:MatCri, WsClassNew( "GenericStruct" ) )
					
					::RetAutProc:MatCri[nCont]:Code			:= Iif( empty(aRetCri[1,1]),"&nbsp;&nbsp;&nbsp;&nbsp;",aRetCri[1,1] )
					::RetAutProc:MatCri[nCont]:Description	:= PadR( allTrim(aRetCri[1,2]),60 ) + Iif( ! Empty( aCritica[nI,3] ) ," ( " + AllTrim( aCritica[nI,3] ) + " )" ,"" ) + "<br>"
				Next
				
			EndIf
			
			//Resultado da matriz de retorno										  
			For nI := 1 To Len(aMatRet)
			
				Do Case
					
					//Retorna sim ou nao para autorizacao
					Case Lower(aMatRet[nI]) == 'cstatusaut' 	
			
						cMatRetRes += aMatRet[nI]+";"+Iif(aRet[1],Iif(lAto,"5","1"),"0")+"~"
					
					//Retorna quantidade autorizada ou negada
					Case Lower(aMatRet[nI]) $ 'cqtdautssol,cqtdsexe,cqtdoexe,cqtdsautpro' 
			
						cMatRetRes += aMatRet[nI]+";"+Iif(aRet[1],AllTrim(Str(::SAutProc:QtdPro)),"0")+"~"
					
					//Retorna Quantidade US
					Case Lower(aMatRet[nI]) == 'nqtdusse' 
			
						cMatRetRes += aMatRet[nI]+";"+AllTrim(Str(nQtdUs))+"~"
						
					//Retorna Valor contratado	
					Case Lower(aMatRet[nI]) == 'nvlrunise' 
			
						cMatRetRes += aMatRet[nI]+";"+AllTrim(Str(nVlrCon))+"~"
					
					//Retorna Valor participacao
					Case Lower(aMatRet[nI]) == 'nvlrfrpase' 
			
						cMatRetRes += aMatRet[nI]+";"+AllTrim(Str(nVlrTPF))+"~"
						
					//Retorna S-autorizado, N-nao autorizado	
					Case Lower(aMatRet[nI]) == 'cautse' 
			
						cMatRetRes += aMatRet[nI]+";"+Iif(aRet[1],"S","N")+"~"
			
				EndCase
					
			Next
			
			//Retorna a string formatada											  
			::RetAutProc:MatRetRes := cMatRetRes
			
		Else
			lRetorno := .F.
			SetSoapFault( "", "Retorno invalido na checagem do procedimento ("+::ProDad:CodPro+")" )
		EndIf
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Matric    ³Autor  ³ Thiago Guilherme      ³ Data ³19.03.14	 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna a matricula selecionado no pré atendimento		     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD Matric WSRECEIVE UserCode, cRecno WSSEND AMatric WSSERVICE PLSXFUN

LOCAL cSQL
LOCAL lRetorno := .T.
LOCAL nI 		 := 1
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "Matric" ) //consome uma licença, checa integridade de acesso

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Seleciona os beneficiarios com internação em aberto						   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cSQL := " SELECT BE4_CODOPE, BE4_CODEMP, BE4_MATRIC, BE4_TIPREG, BE4_DIGITO"
	cSQL += " FROM " + RetSQLName("BE4")
	cSQL += " WHERE R_E_C_N_O_ = '" + cRecno + "'"
	cSQL += " AND " + RetSqlName("BE4")+".D_E_L_E_T_ = ''"
	PLSQuery(cSQL,"TrbMatric")
	
	While !TrbMatric->(Eof())

		AaDd( ::AMatric, WsClassNew( "SMatric" ) )
		::AMatric[nI]:Matric   := TrbMatric->(BE4_CODOPE+BE4_CODEMP+BE4_MATRIC+BE4_TIPREG+BE4_DIGITO)
		nI++
		TrbMatric->(dbSkip())
	EndDo

	TrbMatric->(dbCloseArea())
Else
 	lRetorno := .F.
   	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VALACEBOT    ³Autor  ³ Thiago Guilherme      ³ Data ³19.03.14³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Valida se usuario tem acesso ao botão internação			     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VALACEBOT WSRECEIVE UserCode, cUsr WSSEND Usuario WSSERVICE PLSXFUN

LOCAL cSQL
LOCAL lRetorno := .T.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "VALACEBOT" ) //consome uma licença, checa integridade de acesso

	If BSW->( FieldPos("BSW_BEINTR") ) > 0
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Seleciona os beneficiarios com internação em aberto						   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cSQL := " SELECT BSW_BEINTR"
		cSQL += " FROM " + RetSQLName("BSW")
		cSQL += " WHERE BSW_CODUSR = '" + cUsr + "'"
		cSQL += " AND " + RetSqlName("BSW")+".D_E_L_E_T_ = ''"
		PLSQuery(cSQL,"TrbUsr")
		
		If !TrbUsr->(Eof())

			If !EMPTY(TrbUsr->(BSW_BEINTR))
				AaDd( ::Usuario, WsClassNew( "SUsuario" ) )
				::Usuario[1]:permite   := TrbUsr->(BSW_BEINTR)
			EndIf
		EndIf

		TrbUsr->(dbCloseArea())
	EndIf
Else
 	lRetorno := .F.
   	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ReembChkRegr ³Autor  ³ Tabosa 	          ³ Data ³06.03.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna parametrizacoes de reembolso no port benef           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ReembChkRegr WSRECEIVE UserCode, MatUsu WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aArea    		:= GetArea()
LOCAL nDiasTol		:= 60

If PrtChkUser( "MSALPHA", "PLSXFUN", "ReembChkRegr" )

	BA1->(DbSetOrder(2))
	BA1->(MsSeek(xFilial("BA1")+SubStr(::MatUsu,1,16)))
	BA3->(DbSetOrder(1))
	BA3->(MsSeek(xFilial("BA3")+SubStr(::MatUsu,1,14)))

 	BI3->( DbSetOrder(1) )//BI3_FILIAL + BI3_CODINT + BI3_CODIGO + BI3_VERSAO
	BI3->(MsSeek(xFilial("BI3")+BA3->(BA3_CODINT+BA3_CODPLA+BA3_VERSAO) ) )

	// ****** NUMERO DE DIAS DE TOLERANCIA A PARTIR DA DATA DO DOCUMENTO PARA SOLIC.
	//If BI3->( FieldPos("BI3_MXDRMB") ) > 0 retirar 08-05
	
	If BI3->BI3_MXDRMB > 0 //08-05 ini
		nDiasTol := BI3->BI3_MXDRMB
		::WSNULL := DTOC(dDataBase - nDiasTol) + "|1"  // Permite reemb na web
	EndIf //08-05 fim
	/*Else retirar 08-05
		::WSNULL := DTOC(dDataBase - nDiasTol) + "|0"
	EndIf*/

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DadGrpFam    ³Autor  ³ Thiago Guilherme  ³ Data ³08.01.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os beneficiários que fazem parte do grupo familiar   ³±±
±±³
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DadTipDoc WSRECEIVE UserCode WSSEND DadosTipDoc WSSERVICE PLSXFUN
LOCAL nI        := 1
LOCAL aArea	  := GetArea()
LOCAL lRetorno  := .T.
LOCAL cSQL
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "DadTipDoc" )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³retorna os tipos de documentos utilizados no reembolso do portal do beneficiário	³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	cSQL := "SELECT BBS_COD, BBS_DESCRI, BBS_IMG  "
	if(BBS->(FieldPos("BBS_OBRIGA")) > 0 )
		cSQL += ", BBS_OBRIGA "
	endIf

	cSQL += "FROM " + RetSQLName("BBS")
	cSQL += " WHERE D_E_L_E_T_ = ''"
	PLSQuery(cSQL,"TrbRetTip")
	
	if !TrbRetTip->(EOF())

		While !TrbRetTip->(EOF())

	       AaDd( ::DadosTipDoc, WsClassNew( "SDadTip" ))
			::DadosTipDoc[nI]:Cod    := TrbRetTip->BBS_COD
			::DadosTipDoc[nI]:Descri := TrbRetTip->BBS_DESCRI
			::DadosTipDoc[nI]:ImgHelp := TrbRetTip->BBS_IMG
			::DadosTipDoc[nI]:Obriga  := iif(BBS->(FieldPos("BBS_OBRIGA")) > 0 , TrbRetTip->BBS_OBRIGA, "1")
			nI++
			TrbRetTip->(dbSkip())
		EndDo
	EndIf
	TrbRetTip->(dbCloseArea())

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RDARef 	³Autor  ³ Tabosa 	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o cid	e valido						  		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RDARef WSRECEIVE UserCode, CpfCnpj, Matric WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aArea    		:= GetArea()
Local cCpfCnpj		:= AllTrim(StrTran(StrTran(StrTran(::CpfCnpj,".",""),"-",""),"/",""))
DEFAULT ::WSNULL 	:= "true|"
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "RDARef" )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se o CPF não corresponde a alguem da familia				   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BA1->( DbSetOrder(4) )//BA1_FILIAL + BA1_CPFUSR

	If BA1->( MsSeek( xFilial("BA1")+ cCpfCnpj ) ) .AND. BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC) == ::Matric

	   	::WSNULL := "true|NE|O CPF digitado corresponde ao titular ou dependente da família, digite o CPF/CNPJ do prestador do serviço contido no documento fiscal."

		RestArea( aArea )
		Return lRetorno
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se prestador esta cadastrado na rede não referenciada		    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BK6->( DbSetOrder(4) )//BK6_FILIAL+BK6_CGC
	If !BK6->( MsSeek( xFilial("BK6")+ StrTran(StrTran(StrTran(::CpfCnpj,".",""),"-",""),"/","") ) )

	   ::WSNULL := "true|N|Prestador de serviço não encontrado, clique em OK para cadastrá-lo."
	Else

		If LEN(cCpfCnpj) <> 11 .AND. LEN(cCpfCnpj) <> 14

			::WSNULL := "false|Quantidade de caracteres inválido."
	   	Else
			
			BID->(DbSetOrder(1)) 
			BID->(MsSeek(xFilial("BID") + BK6->(BK6_MUNCR)))
			
	   		::WSNULL := "true|S|" + BK6->(BK6_CODIGO+"|"+Alltrim(BK6_NOME)+"|"+Alltrim(BK6_SIGLA)+"|"+BK6_ESTCR+"|"+BK6_MUNCR+"|"+BID->BID_DESCRI) 
	 	EndIf
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PutReembBen 	³Autor  ³ Tabosa 	           ³ Data ³06.03.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³ Realiza a gravacao da solic de reembolso do portal do Benef ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

WSMETHOD PutReembBen WSRECEIVE UserCode, MatUsu, DatDoc, CpfCnpj, NomRdaNRef, VlrApr, Telefone, ItensReemb WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aArea    		:= GetArea()
LOCAL cProtocolo	:= ""
LOCAL aCliente 		:= {}
LOCAL aDadRDA 		:= {}
LOCAL nValMin		:= 0 // Valor minimo acumulado para solicitaçao de reembolso
LOCAL lOK			:= .T.
LOCAL ADadCli		:= separa(::CpfCnpj)
LOCAL aNomBen		:= separa(::MatUsu)
LOCAL nCount		:= 0
LOCAL cMatBen		:= ""
Local lInsBK6		:= SupergetMV("MV_VRDANRF", .F., .F.)
LOCAL cCodInt    := ""
LOCAL cCodRDA    := ""
LOCAL cCodEsp    := ""
LOCAL cTipPreFor := ""
LOCAL cRegExe    := ""
LOCAL cEstExe    := ""
LOCAL cCdPfRe     := ""
LOCAL cCodLoc    := ""
LOCAL cUFAte     := ""
LOCAL cMunAte    := ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If PrtChkUser( "MSALPHA", "PLSXFUN", "PutReembBen" )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Checagem do usuario															   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	BA1->(DbSetOrder(2))
	If BA1->(dbSeek(xFilial("BA1")+ substr(aNomBen[1],1,14)))
		While BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC) == substr(aNomBen[1],1,14)

			If BA1->BA1_TIPUSU == "T"
				cMatBen := BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)
				EXIT
			EndIf
		EndDo
	EndIf

	BA1->(DbSetOrder(2))
	BA1->(MsSeek(xFilial("BA1")+SubStr(cMatBen,1,16)))
	BA3->(DbSetOrder(1))
	BA3->(MsSeek(xFilial("BA3")+SubStr(cMatBen,1,14)))

 	BI3->( DbSetOrder(1) )//BI3_FILIAL + BI3_CODINT + BI3_CODIGO + BI3_VERSAO
	BI3->(MsSeek(xFilial("BI3")+BA3->(BA3_CODINT+BA3_CODPLA+BA3_VERSAO) ) )

	// ***************** Verifica valor minimo para sol de reembolso cadastrado no produto //
	If BI3->( FieldPos("BI3_VMIRMB") ) > 0
		nValMin := BI3->BI3_VMIRMB
	EndIf

	If Val(::VlrApr) < nValMin // nao atingiu o valor necessário para solicitar o reembolso
		::WSNULL := "false|Valor minimo [ " + Alltrim(Str(nValMin)) + " ] para solicitação de reembolso não atingido!"
		lOK := .F.
	EndIf
	// ***************VErifica permissao para sol de reemb no portal do beneficiario //
	If BA3->BA3_REEWEB <> "1" .OR. BA3->BA3_PODREM <> "1" .AND. lOK
		::WSNULL := "false|Beneficiário sem permissão para solicitação de reembolso!"
		lOK := .F.
	EndIf

	If ExistBlock("PLVLWEBA")
		lOk := ExecBlock("PLVLWEBA",.F.,.F.,{lOk, aNomBen, ::DatDoc, aDadCli, ::NomRdaNRef, ::VlrApr, ::ItensReemb})
	EndIf
	If lOK
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cria protocolo de Reembolso													   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Begin Transaction
		RecLock("BOW", .T.)
			BOW->BOW_FILIAL := xFilial("BOW")
			BOW->BOW_PROTOC := (cProtocolo := GetSXENum("BOW","BOW_PROTOC"))
			BOW->BOW_TIPPAC := GetNewPar("MV_PLSTPAA","1")
			BOW->BOW_STATUS := "0"
			BOW->BOW_USUARI := cMatBen

			aCliente := PLSAVERNIV(	BA3->BA3_CODINT,BA3->BA3_CODEMP,BA3->BA3_MATRIC,IF(BA3->BA3_TIPOUS=="1","F","J"),;
										BA3->BA3_CONEMP,BA3->BA3_VERCON,BA3->BA3_SUBCON,BA3->BA3_VERSUB,nil,BA1->BA1_TIPREG,.F.)

			If aCliente[1,1] <> "ZZZZZZ"
				BOW->BOW_CODCLI	:= aCliente[1][1]
				BOW->BOW_LOJA  	:= aCliente[1][2]
				BOW->BOW_NOMCLI	:= aCliente[1][3]
			EndIf

			BOW->BOW_TIPUSR := "99"
			BOW->BOW_VIACAR := BA1->BA1_VIACAR
			BOW->BOW_NOMUSR := BA1->BA1_NOMUSR
			BOW->BOW_CODEMP := BA3->BA3_CODEMP
			BOW->BOW_MATRIC := BA3->BA3_MATRIC
			BOW->BOW_TIPREG := BA1->BA1_TIPREG
			BOW->BOW_DIGITO := BA1->BA1_DIGITO
			BOW->BOW_MATUSA := "1"
			BOW->BOW_DTDIGI := dDataBase
			BOW->BOW_OPERDA := BA1->BA1_CODINT
			BOW->BOW_CONEMP := BA3->BA3_CONEMP
			BOW->BOW_VERCON := BA3->BA3_VERCON
			BOW->BOW_SUBCON := BA3->BA3_SUBCON
			BOW->BOW_VERSUB := BA3->BA3_VERSUB
			BOW->BOW_TELCON := ::Telefone

			BK6->( DbSetOrder(4) )//BK6_FILIAL+BK6_CGC

			For nCount := 1 To LEN(ADadCli)
				If !EMPTY(ADadCli[nCount])

					If BK6->( MsSeek( xFilial("BK6")+ StrTran(StrTran(StrTran(ADadCli[nCount],".",""),"-",""),"/","") ) )
						BOW->BOW_CODREF 	:= BK6->BK6_CODIGO
						BOW->BOW_NOMREF 	:= BK6->BK6_NOME
						BOW->BOW_UFATE	:= 	BK6->BK6_ESTCR
						If BK6->( FieldPos("BK6_MUNCR") ) > 0
							BOW->BOW_MUNATE	:= 	BK6->BK6_MUNCR
						EndIf
					Else // Cria novo registro de rede nao referenciada na BK6
					  IF (!lInsBK6)
						aDadRda :=  PlsIncBK6(Alltrim(::NomRdaNRef), ::CpfCnpj)
						BOW->BOW_CODREF 	:= aDadRda[1][1]
						BOW->BOW_NOMREF 	:= aDadRda[1][2]
						EndIf
					EndIf
				EndIf
			Next

			BOW->BOW_OPESOL := BA1->BA1_CODINT
			BOW->BOW_OPEUSR := BA1->BA1_CODINT
			BOW->BOW_ESTSOL := GETMV("MV_PLSESPD")
			BOW->BOW_OPEEXE := BA1->BA1_CODINT
			BOW->BOW_SIGLA  := GETMV("MV_PLSIGLA")
			BOW->BOW_ESTEXE := GETMV("MV_PLSESPD")
			BOW->BOW_VLRAPR := Val(::VlrApr)
			BOW->BOW_CDOPER := ::UserCode
			BOW->BOW_NOMOPE := Posicione("BSW",5,xFilial("BSW")+::UserCode,"BSW_NOMUSR")

			lBAU    := .F.

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Se foi informado a rede nao referenciada
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			If !Empty(BOW->BOW_CODREF)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³ Rede nao referenciada
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				BK6->(dbSetOrder(3) )//BK6_FILIAL, BK6_CODIGO
				If BK6->( MsSeek(xFilial("BK6")+BOW->BOW_CODREF) )
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³ Rda referente a Rede nao referenciada
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					BAU->(dbSetOrder(8) )//BAU_FILIAL, BAU_CODBK6
					If BAU->( MsSeek(xFilial("BAU")+BOW->BOW_CODREF) )
						lBAU := .T.
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³ Se achou a rda e o estado e crm esta preenchido
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					If !lBAU .And. !Empty(BK6->BK6_CONREG) .And. !Empty(BK6->BK6_ESTCR)
						BAU->(dbSetOrder(3) )//BAU_FILIAL, BAU_ESTCR, BAU_CONREG, BAU_SIGLCR
						If BAU->( MsSeek(xFilial("BAU")+BK6->(BK6_ESTCR+BK6_CONREG)) )
							lBAU := .T.
						EndIf
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					//³ Se tem vida
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
					If !lBAU .And. !Empty(BK6->BK6_MATVID)
						BAU->(dbSetOrder(9) )//BAU_FILIAL,BAU_MATVID
						If BAU->( MsSeek(xFilial("BAU")+BK6->BK6_MATVID) )
							lBAU := .T.
						EndIf
					EndIf
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³Se nao encontrar procuro RDA generica
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			If !lBAU
				BAU->(dbSetOrder(1) )//BAU_FILIAL,BAU_CODIGO
				If BAU->( MsSeek(xFilial("BAU")+GetNewPar("MV_PLSRDAG","999999")) )
					lBAU := .T.
				Endif
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Alimenta M
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			If lBAU
				BOW->BOW_CODRDA := BAU->BAU_CODIGO
				BOW->BOW_NOMRDA := BAU->BAU_NOME
				BOW->BOW_TIPPRE := BAU->BAU_TIPPRE

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³ Profissional relacionado a rda
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				BB0->( DbSetOrder(1) ) //BB0_FILIAL + BB0_CODIGO
				BB0->( MsSeek( xFilial("BB0")+BAU->BAU_CODBB0 ) )

				If BB0->(Found())
					BOW->BOW_REGEXE := BB0->BB0_NUMCR
					BOW->BOW_NOMEXE := BB0->BB0_NOME
					BOW->BOW_CDPFRE := BB0->BB0_CODIGO
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³ DadRda
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				PLSDADRDA(BOW->BOW_OPERDA,BOW->BOW_CODRDA,"1",dDataBase,Subs(BOW->BOW_LOCATE,1,3),"")

				aDadRDA := PLSGETRDA()
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				//³ Atualiza M
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
				if len(aDadRDA) >=15
					BOW->BOW_CODESP := aDadRDA[15]
					BOW->BOW_DESESP := aDadRDA[17]
					BOW->BOW_LOCATE := aDadRDA[18]
					BOW->BOW_ENDLOC := aDadRDA[20]
				EndIf
			EndIf

			BOW->BOW_OPEMOV := PLSINTPAD()
			BOW->BOW_EMPMOV := cNumEmp

			BA3->(DbSetOrder(1))
			BA3-> (DbSeek(xFilial("BA3") + BOW->BOW_OPERDA + BOW->BOW_CODEMP + BOW->BOW_MATRIC))

			If BA3->(FieldPos("BA3_TIPPGO")) > 0
					BOW->BOW_PGMTO := "Em Análise"
           EndIf

		BOW->(MsUnlock())
		PlsGrvB1N( cProtocolo,::ItensReemb,aNomBen, lInsBK6 )
		ConfirmSX8()
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ P.E. utilizado para manipular o último registro da BOW que foi gravado ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistBlock("PLWEBBOW")
			ExecBlock("PLWEBBOW",.F.,.F.,{BOW->(Recno())})
		Endif
		End Transaction
		::WSNULL := "true|" + cProtocolo
	Else
		If lOK // passou pelas outras criticas
			::WSNULL := "false|Existe inconsistências no seu cadastro que impossibilitam a solicitação do reembolso, entre em contato com a operadora!"
		EndIf
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

//Requisito: Nova tela de solicitação de reembolso
//Static Function PlsIncBK6 Movida para o Fonte PLSFUNREEMB como Function
//Static Function PlsGrvB1N Movida para o fonte PLSFUNREEMB como function

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³OBSPROTOC ³Autor  ³ Thiago Guilherme³ Data ³01.08.2014       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna observação do protocolo de reembolso                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD OBSPROTOC WSRECEIVE UserCode, cRecno, Tipo WSSEND DadObsProt WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aArea 		:= GetArea()
LOCAL cObs := ""
LOCAL nI := 1
If PrtChkUser( ::UserCode, "PLSXFUN", "OBSPROTOC" )
	if ::Tipo == "receita" //protocolo de uso constante
		B7D->(dbSelectArea("B7D"))
		B7D->(dbGoto(val(cRecno)))

		 nLines := MLCount( B7D->B7D_OBS )

		 For nI := 1 to nLines
			if !(empty(memoLine(B7D->B7D_OBS,,nI)))
			 	cObs += alltrim(strTran(strTran(memoLine(B7D->B7D_OBS,,nI), chr(10), ""), chr(13),""))
			endIf
		 Next nI

		AaDd( ::DadObsProt, WsClassNew( "SRetObsProt" ) )
		::DadObsProt[1]:cMsg  := IIf(EMPTY(cObs), "false|Sem Observação", "true|"+cObs)
	else
		BOW->(dbSelectArea("BOW"))
		BOW->(dbGoto(val(cRecno)))

			nLines := MLCount( BOW->BOW_OBS )
	
			For nI := 1 to nLines
				if !(empty(memoLine(BOW->BOW_OBS,,nI)))
				 	cObs += alltrim(strTran(strTran(memoLine(BOW->BOW_OBS,,nI), chr(10), ""), chr(13),""))
				endIf
			Next nI
			
			AaDd( ::DadObsProt, WsClassNew( "SRetObsProt" ) )
			::DadObsProt[1]:cMsg  := IIf(EMPTY(cObs), "Sem Informação.", ALLTRIM(cObs))

	endIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ExcItmReemb ³Autor  ³ Thiago Ribas      ³ Data ³01.08.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retornar mensagem                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ExcItmReemb WSRECEIVE UserCode, cRecno WSSEND DadItemExc WSSERVICE PLSXFUN 
LOCAL lRetorno := .T.
LOCAL lAchou   := .F.

If PrtChkUser( ::UserCode, "PLSXFUN", "ExcItmReemb" )
	
	B1N->(dbGoTo(VAL(cRecno)))
	

	B14->(DbSetOrder(1)) 
	If B14->(MsSeek(xFilial("B14") + B1N->(B1N_PROTOC + B1N_CODPRO + B1N_MATRIC + B1N_SEQUEN)))
	
		lAchou := .T.
		
	ElseIf B14->(MsSeek(xFilial("B14") + B1N->(B1N_PROTOC + B1N_CODPRO)))
	
		While !lAchou .and. B14->(!EOF()) .and. xFILIAL("B14")+B14->(B14_CDPROT+B14_CODPRO) == ;
							B1N->(B1N_FILIAL + B1N_PROTOC + B1N_CODPRO)

			if alltrim(B1N->B1N_MATRIC) == alltrim(B14->B14_MATRIC)
				lAchou := .T.
			else
				B14->(dbSkip())
			endIf
		EndDo
	EndIf
	
	IF lAchou	
		AaDd( ::DadItemExc, WsClassNew( "SRetIteEx" ) )
		::DadItemExc[1]:cMsg  := B14->B14_MOTIVO
	Else
		AaDd( ::DadItemExc, WsClassNew( "SRetIteEx" ) )
		::DadItemExc[1]:cMsg  := "Sem Informação."
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ReembChkRegr ³Autor  ³ Tabosa 	          ³ Data ³06.03.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna parametrizacoes de reembolso no port benef           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ReembDelPI WSRECEIVE UserCode, cRecno, Alias, Chave WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aArea    		:= GetArea()
LOCAL nVlrItem		:= 0
LOCAL aChave			:= {}
LOCAL aRecnosB1N		:= {}
LOCAL nI := 0
DEFAULT ::Chave := "" //formato B1N: B1N_PROTOC-B1N_TIPDOC-B1N_NUMDOC-B1N_DATDOC-B1N_PRCNPJ
DEFAULT ::cRecno := "0"
If PrtChkUser( "MSALPHA", "PLSXFUN", "ReembDelPI" )

	If ::Alias == "BOW" // Deleta protocolo
		BOW->(DbGoTop())
		BOW->(DbGoTo(Val(::cRecno)))
	Else // Deleta Item
		//no reembolso multicomprovante no portal, exclui o comprovante inteiro, portanto exclui várias B1N
		if((empty(::cRecno) .or. ::cRecno == "0") .and. !empty(::Chave))
			aChave := Separa(::Chave, "-")
			
			BOW->(DbSetOrder(1))
			BOW->(MsSeek(xFilial("BOW") + alltrim(aChave[1]) ))
			
			B1N->(DbSetOrder(2))
			B1N->(MsSeek(xFilial("B1N") + alltrim(aChave[1]) ))
			
			While B1N->(!EOF()) .AND. B1N->B1N_PROTOC == aChave[1]
				
				if STRTRAN(B1N->B1N_TIPDOC, " ", "") == aChave[2] .and. ALLTRIM(B1N->B1N_NUMDOC) == aChave[3];
												    .and. B1N->B1N_DATDOC == STOD(aChave[4]);
												    .and. ALLTRIM(B1N->B1N_PRCNPJ) == aChave[5]
					aAdd(aRecnosB1N, B1N->(Recno()))
				endIf
				
				B1N->(dbSkip())
			EndDo
			
		else
		B1N->(DbGoTop())
		B1N->(DbGoTo(Val(::cRecno)))
			
			aAdd(aRecnosB1N, B1N->(Recno()))

		BOW->(DbSetOrder(1))
		BOW->(MsSeek(xFilial("BOW") + B1N->B1N_PROTOC ))
		endIf
	EndIf

	//Solicitação Não concluída - Foi alterado, pois devido aos novos status e a obrigatoriedade de anexo,
	//poderá cancelar somente se não concluiu a solicitação
	If BOW->BOW_STATUS <> 'A'

		::WSNULL := "false|Não foi possível excluir esta solicitação pois já esta protocolada, entre em contato com a operadora!"
	Else
		If ::Alias == "BOW"
			Begin Transaction
			P001AEXCG(BOW->BOW_PROTOC)
			End Transaction
		Else
			
			for nI := 1 to len(aRecnosB1N)
				
				B1N->(DbGoTo(aRecnosB1N[nI]))

				B14->(dbSetOrder(1))
				If B14->(dbSeek(xFilial("B14")+B1N->(B1N_PROTOC + B1N_CODPRO + B1N_MATRIC + B1N_SEQUEN))) //11-09

					nVlrItem := B1N->B1N_VLRAPR
					B14->(RecLock('B14',.F.))
					B14->(DbDelete())
					B14->( MsUnlock() )
				EndIf

				if B1N->(FieldPos("B1N_VLRTOT")) > 0
					nVlrItem += B1N->B1N_VLRTOT
				else
					nVlrItem += B1N->B1N_VLRAPR
				endIf
				
			B1N->(RecLock('B1N',.F.))
			B1N->(DbDelete())
			B1N->(DbSkip())
			B1N->( MsUnlock() )
				
			next nI
			
		EndIf
		
		::WSNULL := "true|Excluido com sucesso!"

		//atualiza o valor total apresentado ao incluir novos itens pelo remote.
		BOW->(RecLock('BOW',.F.))
		BOW->BOW_VLRAPR -= nVlrItem
		BOW->( MsUnlock() )
	EndIf

	nVlrItem := 0
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AtuBow   ³Autor  ³ Totvs 				 ³ Data ³19.08.14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Atualiza a BOW com as baixas de titulo							³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD AtuBow WSRECEIVE UserCode,UsrCod WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL aArea 	:= GetArea()
LOCAL aDadUsr := {}
LOCAL nI
LOCAL lRetorno := .T.
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se tem direito para executar o metodo								   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode , "PLSXFUN","AtuBow" )
	If BOW->(FieldPos("BOW_PGMTO")) > 0

		//Retorna o usuario relacionado a solicitacao
		cSQL := "SELECT B49_BENEFI "
		cSQL += "FROM " + RetSQLName("B49")
		cSQL += " WHERE B49_CODUSR = '" + UsrCod + "' AND "
		cSQL += " D_E_L_E_T_ = ' '"
		PLSQuery(cSQL,"TrbRetTit")
		
		While !TrbRetTit->(EOF())
			AADD(aDadUsr, PLSDADUSR(TrbRetTit->B49_BENEFI,'1',.F.,dDatabase,,,"NAO_VALIDAR_CARTAO"))

			TrbRetTit->(dbSkip())
		EndDo

		TrbRetTit->(dbCloseArea())

		//verifica os reembolsos aprovados e que ainda nao foram atualizados no protocolo que o titulo foi pago.
		For nI := 1 To LEN(aDadUsr)

			BOW->(dbSetOrder(5)) // BOW_FILIAL + BOW_USUARI
			If BOW->(dbSeek(xFilial("BOW") + aDadUsr[nI][2]))

				While !BOW->(EOF()) .AND. BOW->BOW_USUARI == aDadUsr[nI][2]

					SE2->(dbSetOrder(1)) //E2_FILIAL, E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, E2_FORNECE
					If SE2->(dbSeek(xFilial("SE2") + BOW->(BOW_PREFIX + BOW_NUM + BOW_PARCE + BOW_TIPO + BOW_FORNEC)))

						If !EMPTY(SE2->E2_BAIXA) .AND. LEN(ALLTRIM(BOW->BOW_PGMTO)) < 12

							BOW->(Reclock("BOW",.F.))
							BOW->BOW_PGMTO := 'Pagamento realizado ' + DTOC(SE2->E2_VENCTO)
							BOW->(MsUnlock())

						//caso uma baixa de título seja cancelada, atualiza para a data de pagamento.
						ElseIf EMPTY(SE2->E2_BAIXA) .AND. LEN(ALLTRIM(BOW->BOW_PGMTO)) > 12
							BOW->(Reclock("BOW",.F.))
							BOW->BOW_PGMTO := DTOC(SE2->E2_VENCTO)
							BOW->(MsUnlock())
						EndIf
					EndIf

					BOW->(dbSkip())
				EndDo

			EndIf
		Next
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim do metodo														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DadRetEst    ³Autor  ³ Thiago Guilherme  ³ Data ³08.01.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna o nome de todos os estados							    ³±±
±±³
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADRETEST WSRECEIVE UserCode,Tipo WSSEND DadEst WSSERVICE PLSXFUN
LOCAL nI        := 1
LOCAL aArea	  := GetArea()
Local aSX5		:= {}
LOCAL lRetorno  := .T.
Local nJ 		:= 1
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "DADRETEST" )

	If EMPTY(Tipo)
	
		//retorna os estados utilizados no reembolso do portal do beneficiário

		aSX5 := FWGetSX5("12")

		For nJ := 1 To Len(aSX5)
			If ALLTRIM(aSX5[nJ][3]) != "EX"
			      AaDd( ::DadEst, WsClassNew( "SDadEst" ))
				  ::DadEst[nI]:Descri := aSX5[nJ][3]
				  nI++
			  EndIf
		Next nJ
	EndIf

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetDadGen 	³Autor  ³ Tabosa 	            ³ Data ³06.03.2007 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os campos com os valores de uma tabela generica		  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

WSMETHOD GetDadGen WSRECEIVE UserCode, cRecno, Alias, Campos WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aArea    		:= GetArea()
LOCAL cAlias			:= ::Alias
LOCAL cCampos			:= ::Campos
LOCAL cStrMacro		:= ""
LOCAL cRetMacro		:= ""
LOCAL nAt1, nAt2, nI	:= 0
LOCAL aVlrRet			:= {}
LOCAL cTipCpo			:= ""
DEFAULT ::WSNULL 	:= "true|"
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "GetDadGen" )

	If Empty(cAlias) .OR. Empty(::cRecno) .OR. Empty(cCampos)
	   ::WSNULL := "false|Parametros insuficentes para encontrar o registro"
	Else
		::WSNULL 	:= "true|"
		DbSelectArea(cAlias)
		DbGoTo(Val(::cRecno))
		cCampos := StrTran(cCampos,"(mais)" ,"+") // Alguma versão estaqva substituindo o + pro espaço na URL aqui eu trato
		If "***" $ cCampos // quer dizer que tem uma expressão pra rodar entao eu substituo pela macro rodada (Ex: Posicione)
			While (nAt1 := at("***",cCampos)) > 0 // Busco os delimitadores do macro #FUNCAO()#
				nAt2 := at("***",SubStr(cCampos, nAt1+1, Len(cCampos)) )
				cStrMacro := SubStr(cCampos, nAt1+3, nAt2-3 )
				cRetMacro := "'" + Alltrim(&(cStrMacro)) + "'" // Executo a macro e guardo na variavel entre aspas (somente string por enquanto)
				cCampos := StrTran(cCampos,"***" + cStrMacro + "***",cRetMacro) // Substituo a macro pelo valor
			EndDo
		EndIf
		aVlrRet := StrToArray(cCampos, "|")
		For nI := 1 To Len(aVlrRet)
			If Substr(cAlias,2,3) + "_" $ Substr(aVlrRet[nI],1,4) // Se é um campo e nao uma expressão trato o tipo
				cTipCpo := Valtype(&(cAlias+"->" + aVlrRet[nI]))
				If cTipCpo <> "C"
					Do Case
						Case cTipCpo == 'N'
							aVlrRet[nI] := "Alltrim(Str(" + aVlrRet[nI] + "))"
						Case cTipCpo == 'D'
							aVlrRet[nI] := "DTOC(" + aVlrRet[nI] + ")"
					EndCase
				EndIf
			EndIf
			::WSNULL += &(cAlias+"->(" + aVlrRet[nI] + ")")  + "|"
		Next nI
		//::WSNULL += "true|" + &(cAlias+"->(" + cCampos + ")")
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    PPINDCLIN    ³ Autor ³ Daher			       ³ Data ³ 11/12/14 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

WSMETHOD PPINDCLIN WSRECEIVE SAutProc WSSEND dTratVinc WSSERVICE PLSXFUN

Local lRetorno 		:= .T.
Local nI := 1
LOCAL aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB", .F. ,"87"))
LOCAL xCodPad := ""
LOCAL xCodPro := ""
//monto retorno
AaDd( ::dTratVinc, WsClassNew( "sTratInd" ))
::dTratVinc[nI]:obrigat := .F.

For nI := 1 To Len( ::SAutProc:AutItem )

	xCodPad := AllTrim(PLSVARVINC('87','BR4', ::SAutProc:AutItem[nI]:CodPad ))
	xCodPro := AllTrim(PLSVARVINC(xCodPad,'BR8',::SAutProc:AutItem[nI]:ProcedureCode ,xCodPad+::SAutProc:AutItem[nI]:ProcedureCode,,aTabDup,@xCodPad))

	BR8->(DbSetOrder(1))//BR8_FILIAL+BR8_CODPAD+BR8_CODPSA+BR8_ANASIN
	If BR8->(MsSeek(xFilial("BR8")+alltrim(xCodPad+xCodPro)))
		If BR8->BR8_TRAIND == '1'
			::dTratVinc[1]:obrigat := .T.
			exit
		Endif
	Endif

Next

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³SenhaExp  ³Autor  ³ Totvs				    ³ Data ³19.03.14   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³verifique se ira mostrar msg expiraçao senha portal		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD SenhaExp WSRECEIVE UserCode, PLSCodUsr WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL aArea 	:= GetArea()
LOCAL lRetorno := .T.
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se tem direito para executar o metodo								   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode , "PLSXFUN","SenhaExp" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Valida usuario/senha                                               	   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BSW->( DbSetOrder(5) ) //BSW_FILIAL + BSW_CODUSR
	If  BSW->(MsSeek(xFilial("BSW")+::PLSCodUsr)) .AND. TAMSX3('BSW_SENHA')[1] >= 32 .AND.  BX1->(FieldPos("BX1_CODUSR")) > 0 .AND. BX1->(FieldPos("BX1_QTACES")) > 0 .AND. BSW->(FieldPos("BSW_DTSEN")) > 0
		aRetSen := PLVLDSDT()
   		If !aRetSen[1] .And. aRetSen[2]
   			::WSNULL := "true|Falta(m) "+Alltrim(Str(aRetSen[3]))+" dia(s) para expirar a sua senha, favor efetuar a troca de sua senha...!!!"
   		EndIf
    Endif
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim do metodo														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DesProc 	³Autor  ³ Thiago 	            ³ Data ³16.012.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o codigo do procedimento é válido		  		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DesProc WSRECEIVE UserCode, codPro,classe WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aArea    		:= GetArea()
DEFAULT ::WSNULL 	:= "true|"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "DesProc" )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se o codigo digitado é válido									   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BR8->( DbSetOrder(3) )//BR8_FILIAL + BR8_CODPSA

	If !BR8->( MsSeek( xFilial("BR8")+ codPro))

	   	::WSNULL := "false|Procedimento não encontrado."

		RestArea( aArea )
		Return lRetorno
	Else

		while xFilial("BR8") + codPro == xFilial("BR8") + ALLTRIM(BR8->(BR8_CODPSA))
			If BR8->(BR8_CLASSE) == classe
				::WSNULL := "true|" + BR8->(BR8_DESCRI) + "|" + BR8->(BR8_CODPAD)

				RestArea( aArea )
				Return lRetorno
			Else
				::WSNULL := "false|Procedimento não encontrado."
			EndIf

			BR8->(dbSkip())
		EndDo
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VldNumGPri³Autor  ³ TOTVS S/A	            ³ Data ³04/11/2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verifica se o numero da guia informado e valido			   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VLNUMGUI WSRECEIVE UserCode, NumAut, TipGui WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRet			:= .T.
DEFAULT ::WSNULL	:= "true|"

//Verifica o usuario
If PrtChkUser( ::UserCode, "PLSXFUN", "VLNUMGUI" )
	
	If PLVLNGUI(NumAut,TipGui)
	
	   ::WSNULL := "true|"
	Else
		::WSNULL :=  "true|Guia não localizada!"
	Endif
Else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DelAtalho        ³Autor  ³ Karine Riquena	³ Data ³26.11.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Deleta atalho do portal        							        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DelAtalho WSRECEIVE UserCode, CodMenu, UsrCod WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL aArea 	:= GetArea()
LOCAL lReturn := .T.
LOCAL lAchou  := .F.
DEFAULT ::WSNULL 	:= "true|"


If PrtChkUser( ::UserCode, "PLSXFUN", "DelAtalho" )
	dbSelectArea("B95")
	B95->(dbGoTop())

    While (B95->(!Eof()) .AND. lAchou == .F.)
       If(B95->B95_CODUSR == ::UsrCod .and. B95->B95_CODMNU == ::CodMenu)
       	RecLock("B95",.F.)
       	B95->(dbDelete())
       	B95->(MsUnlock())
       	lAchou = .T.
       EndIf
       B95->(dbSkip())
    EndDo

    ::WSNULL 	:= "true|"
Else
	lReturn := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea(aArea)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³ Fim do Metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Return lReturn
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AddAtalho        ³Autor  ³ Karine Riquena	³ Data ³05.12.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Adiciona atalho no portal      							        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD AddAtalho WSRECEIVE UserCode, CodMenu, UsrCod, CamImg, CodPor WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL aArea 	:= GetArea()
LOCAL lReturn := .T.
LOCAL cCodPortal
LOCAL cDescri
LOCAL aAtalhos := {}
LOCAL lAchou := .F.
LOCAL cCaminho
LOCAL cString
DEFAULT ::WSNULL 	:= "true|"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "AddAtalho" )
	     If ::CodPor == 1
	     		cCodPortal := "000008"
	     Else
	     		cCodPortal := "000010"
	     EndIf

	      DbSelectArea("B95")
          DbSetOrder(1) // SIX -> B95_FILIAL+B95_CODUSR+B95_CODMNU+B95_CODPOR
	      If !(B95->(DbSeek(XFilial("B95") + UsrCod + ::CodMenu + cCodPortal )))
			   cDescri := Posicione("AI8",1,xFilial("AI8") + cCodPortal + ::CodMenu ,"AI8_TEXTO")
				Begin Transaction
				RecLock("B95", .T.)
					B95->B95_FILIAL := xFilial("B95")
					B95->B95_CODUSR := ::UsrCod
					B95->B95_CODMNU := ::CodMenu
					B95->B95_CODPOR := cCodPortal
					B95->B95_DESCRI := cDescri
					B95->B95_IMG    := ::CamImg
				B95->(MsUnlock())
				End Transaction

	     dbSelectArea("AI8")
         			AI8->(DBGoTop())

         			While (AI8->(!Eof()) .AND. lAchou == .F.)
            			If(AI8->AI8_CODMNU == ::CodMenu .AND. AI8->AI8_PORTAL == cCodPortal)
                			Aadd(aAtalhos, { ::CodMenu, cDescri, ::CamImg, AI8->AI8_WEBSRV, AI8_ROTINA })
                			lAchou := .T.
            			EndIf
            			AI8->(dbSkip())
         			EndDo

     	  AI8->(dbCloseArea())

		       cString := Alltrim(aAtalhos[1][1]) + "|" + AllTrim(aAtalhos[1][2]) + "|" + AllTrim(aAtalhos[1][3]) + "|" + AllTrim(aAtalhos[1][4]) + "|" + AllTrim(aAtalhos[1][5])
				::WSNULL := "true|" + cString
	   Else
	   		::WSNULL := "false|Atalho ja existente, verifique!"
	   EndIf
Else
	lReturn := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lReturn
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CriPsw  ³Autor  ³ Totvs				    ³ Data ³19.03.14   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³verifique se ira mostrar msg expiraçao senha portal		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD CriPsw WSRECEIVE UserCode, TipoVld, SenhaVld WSSEND RetSenha WSSERVICE PLSXFUN
LOCAL aArea 	:= GetArea()
LOCAL lRetorno := .T.

If PrtChkUser( ::UserCode , "PLSXFUN","CriPsw" )
	::RetSenha := PLSCRIDEC(Val(::TipoVld),::SenhaVld)
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim do metodo														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ UplConhec ³Autor  ³ Oscar				 ³ Data ³15.06.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³			 ³ Upload Banco Conhecimento 									³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD UplConhec WSRECEIVE UserCode, cArquivo, cCodRDA, Chave, Alias, cRecno, Indice, lIncRap, NoArqComp WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno	:= .T.
LOCAL aArea 	:= GetArea()
LOCAL cRet 		:= ""
LOCAL cNomeArq1	:= ""
Local cNomeExibe:= ""
Local cExtArq	:= ""
LOCAL cDirRaiz 	:= PLSMUDSIS( GetNewPar("MV_TISSDIR","\TISS\") )
LOCAL cDirWeb	:= PLSMUDSIS( cDirRaiz+"UPLOAD\") 
Local nIndice	:= IIF( !(Empty(::Indice)), Val(::Indice), 0 )
Local nRecno	:= IIF( !(Empty(::cRecno)), Val(::cRecno), 0 )
local cTabela	:= ::Alias
Local cChave	:= xFilial(cTabela) + ::Chave
Local cChavBow	:= substr(::Chave,5,LEN(BOW->BOW_PROTOC))
Local cPartArq	:= "_"+ Alltrim(Str(month(date()))) + "_" + ( Alltrim(Str(Year(date()))) ) + "_" +;
                       Left(Time(),2) + "_" + Substr(Time(),4,2) + "_" + Right(Time(),2)
Local cAlias    := ""
Local cAliasIte	:= ""
Local lDownload	:= .F.
local cDownload	:= ""
Local lBlqAne	:= GetNewPar("MV_PLBAGN",.F.)
Local lGuiNeg	:= .F.
Local cChaveInt	:= ''

Default lIncRap 	:= .F.

DEFAULT ::WSNULL 	:= ""
DEFAULT ::cArquivo 	:= ""
DEFAULT ::NoArqComp := "" //Texto Adicional a ser adicionado no arquivo para upload.

If PrtChkUser( ::UserCode ,"PLSXFUN","UplConhec" )

	lDownload := GetNewPar("MV_PLPDWN", .F.)

	//Trata se não existe pasta para uploads definida no .INI
	If "ERROR" $ upper(alltrim(cDirWeb))
		FWLogMsg('ERROR',, 'SIGAPLS', funName(), '', '01',"LOG DE ERRO NO UPLOAD PATH: " + Upper( GetPvProfString( GetEnvHost(), "UPLOADPATH", "ERROR", GetADV97() ) ) , 0, 0, {})
		cRet := "Diretorio de upload nao informado no .INI do SERVER."
	Endif

	//Trata se o arquivo existe, já foi enviado, ou não foi informado
	if ! lIncRap

		//Adiciona o dia no cPartArq
		cPartArq := allTrim(str(day(date()))) + cPartArq

		If ! empty(::cArquivo) .and. empty(cRet)

			cNomeArq1 	:= lower( allTrim( subStr( ::cArquivo, Rat(PLSMUDSIS('\'),::cArquivo)+1) ) )
			
			//Copia nome Arquivo para montar nome exibição
			cNomeExibe := cNomeArq1
			
			//Pega a extensão do arquivo
			cExtArq := subStr(cNomeArq1, RAT(".", cNomeArq1)+1) //Alterado de AT para RAT
			
			//Monta nome de exibição
			cNomeExibe := subStr(cNomeExibe, 1, RAT(".", cNomeExibe)) + cExtArq
			
			//Pega o nome do arquivo
			cNomeArq1 := subStr(cNomeArq1, 1, RAT(".", cNomeArq1)-1)
			
			//Renomeia o aruqivo para nome nome + data atual + horário atual
			if ! empty(::NoArqComp)
				cPartArq += "_" + ::NoArqComp
			endif	
			
			FRenameEx(cDirWeb + cNomeArq1 + "." + cExtArq, cDirWeb + cNomeArq1 + "_" + cPartArq + "." + cExtArq)

			If Empty(cNomeArq1)
				cRet :=  "Falha ao incluir (Verifique se o arquivo já foi inserido ou entre em contato com a operadora)"
			Endif

			//atribuição apra busca no banco de conhecimento
			cNomeArq1 := cNomeArq1 + "_" + cPartArq + "." + cExtArq
			
			ACB->( dbSetOrder(2) )
			If ACB->( msSeek( xFilial("ACB") + upper( allTrim(cNomeArq1) ) ) )
				cRet := "Arquivo [" + cNomeExibe + "] ja existe no banco de conhecimento, altere o nome e tente novamente!"
			endIf
			
		Else
			cRet := "Arquivo nao informado."
		EndIf

    ELSE
    
      If ! Empty(::cArquivo) .and. Empty(cRet)

		  cNomeArq1 := Lower( AllTrim( SubStr( ::cArquivo, Rat(PLSMUDSIS('\'),::cArquivo)+1) ) )
		  cExtArq	:= SubStr(cNomeArq1, RAT(".", cNomeArq1)+1)
		  cNomeArq1	:= SubStr(cNomeArq1, 1, AT(".", cNomeArq1)-1)
		  
		  FRenameEx(cDirWeb+cNomeArq1+"."+cExtArq, cDirWeb+::Chave+cPartArq+"."+cExtArq)
		  
		  cNomeArq1 := ::Chave+cPartArq+"."+cExtArq
		  
		  If Empty(cNomeArq1)
			  cRet :=  "Falha ao incluir (Verifique se o arquivo já foi inserido ou entre em contato com a operadora)"
		  Endif

		  ACB->(DbSetOrder(2))
		  If ACB->(MsSeek(xFilial("ACB") + Upper(Alltrim(cNomeArq1))))
			  cRet := "Arquivo ja existe no banco de conhecimento, altere o nome e tente novamente!"
		  EndIf

	  Else
		  cRet := "Arquivo nao informado."
	  EndIf
	  
   ENDIF

	If Empty(cRet)
		//Posiciona no registro
		//Se o REcno não foi informado, traz o Recno do registro
		//Dono da chave informada
		if ( nRecno == 0 .and. ! lIncRap )
			
			&(cTabela)->(DbSetOrder(nIndice))
			&(cTabela)->(MsSeek(cChave))
			
			nRecno := &(cTabela)->(Recno())
			
		EndIF
		
		IF ! empty(cRecno)
			&(cTabela)->( DbGoTo( nRecno ) )
		EndIf
		
		If cTabela != "BOW"
		
			BE4->(dbSetOrder(2))
			BEA->(dbSetOrder(1))
			B4A->(dbSetOrder(1))
			B4Q->(DbSetOrder(1))
			BE2->(DbSetOrder(1))
			B4C->(DbSetOrder(1))
			
			If BE4->(MsSeek(xFilial("BE4") + subStr(Chave,1,18)))
				cAlias 		:= "BE4"
				cAliasIte 	:= "BEJ"
			ElseIf BEA->(MsSeek(xFilial("BEA") + subStr(Chave,1,18)))
				cAlias 		:= "BEA"
				cAliasIte 	:= "BE2"
			ElseIf B4A->(MsSeek(xFilial("B4A") + subStr(Chave,1,18)))
				cAlias 		:= "B4A"	
				cAliasIte 	:= "B4C"		
			ElseIf B4Q->(MsSeek(xFilial("B4Q") + subStr(Chave,1,18)))
				cAlias 		:= "B4Q"
				cAliasIte 	:= "BQV"
			EndIf

			//Verifica Guia/Evento negado na auditoria
			if ! Empty(cAlias)
			
				lGuiNeg := &(cAlias + "->" + cAlias +"_STATUS") == "3"
				
				If ! lGuiNeg .and. Len(Chave) == 21
				
					If (&(cAliasIte)->(MsSeek(xFilial(cAliasIte)+Chave)))
						lGuiNeg := &(cAliasIte + "->" + cAliasIte +"_STATUS") == "0" .AND. &(cAliasIte + "->" + cAliasIte +"_AUDITO") == "0"
					EndIf
					
				EndIf
				
			EndIf

		EndIf

		//Se há arquivo, chama função que grava no banco de conhecimento
		//E exclui do local padrão de upload
		If lBlqAne .and. lGuiNeg
			
			cRet 	 := "Não é permitido incluir anexos em guia/evento negado."
			::WSNULL := "false|" + cRet

			Return(lRetorno)
			
		ElseIf ! Empty(cNomeArq1)
		
			PLSINCONH(cDirWeb + cNomeArq1, ::Alias, cChave,.T.)
			
			//Se tiver B53, altera para deixar identificado como "Existe Documento"
			cChaveInt := substr(cChave, len(xFilial("BEA")) + 1, 18)
			PLSATUB53(cChave, cChaveInt, ::Alias)
			
			//Se permitir download, copia o arquivo para o diretorio web
			If lDownload 
			
				cDownload := SuperGetMV("MV_RELT")
				
				// Copio para pasta de downloads
				__COPYFILE( PLSMUDSIS(cDirWeb + cNomeArq1), PLSMUDSIS(cDownload + cNomeArq1) )
				
			EndIf
			
			FERASE(cDirWeb + cNomeArq1) //apaga arquivo do diretorio WEB e deixa apenas no conhecimento
			
		EndIf
		
		cRet := "Arquivo Enviado com sucesso."

		If cTabela != "BOW"

			If ! empty(cAlias)

				BBR->(dbSetOrder(1))
				If BBR->(MsSeek(xFilial("BBR") + Chave))
	
					// Só devo atualizar o status da Guia se for interação, pois essa função é generica pra anexo de documentos, não deve ocorrer pra tudo
					&(cAlias + "->(RecLock('" + cAlias + "',.F.))" )
					&(cAlias + "->" + cAlias +"_STATUS") := "6"
					&(cAlias + "->(MsUnLock())")

					While BBR->(BBR_FILIAL + BBR_CODOPE + BBR_ANOAUT + BBR_MESAUT + BBR_NUMAUT + BBR_SEQPRO) == xFilial("BBR") + Chave

						If !BBR->BBR_RESPRE  .OR. BBR->BBR_TPDIRP == "B" //quando é beneficiario não tem respostas 

							BBR->(RecLock("BBR",.F.))
							BBR->BBR_RESPRE := .F.
							BBR->BBR_TPDIRP := ""
							BBR->(MsUnLock())

							exit
						EndIf

						BBR->(DbSkip())
					EndDo
					
				EndIf
				
			EndIf
			
		EndIf

		//Atualmente o protocolo de reembolso não possui interação com o beneficiário, caso este processo
		//se confirme o código abaixo deve ser retirado.
		IF cTabela == "BOW"
		
			DbselectArea("BOW")
			DbSetOrder(1)
			IF DbSeek(xFilial("BOW") + cChavBow) 
				
				If BOW->BOW_STATUS == "B" 
					BOW->(RecLock("BOW",.F.))
					BOW->BOW_STATUS := "2"
					BOW->(MsUnLock())
				Endif
				
			Endif
		Endif

		IF (ValType(HttpSession->nAnexos) == "N")
			HttpSession->nAnexos := HttpSession->nAnexos + 1
		else
			HttpSession->nAnexos := 1
		EndIf
		
	EndIf
	
	::WSNULL := "true|" + cRet

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GrvSolAdt  ³Autor  ³ Oscar 				 ³ Data ³15.06.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ 		 ³																³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GrvSolAdt WSRECEIVE UserCode, cCodRDA, CodSol, Observ WSSEND WSNULL WSSERVICE PLSXFUN

LOCAL lRetorno	:= .T.
LOCAL aArea 		:= GetArea()
LOCAL cRet 		:= ""

DEFAULT ::WSNULL 	:= ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se tem direito para executar o metodo								   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode ,"PLSXFUN","GrvSolAdt" )

	cRet := PLS814GRVS(::CodSol, ::cCodRDA, ::Observ)
	::WSNULL := "true|" + cRet

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ConSolAdt  ³Autor  ³ Oscar				 ³ Data ³15.06.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³			 ³																³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD ConSolAdt WSRECEIVE UserCode, cCodRDA, Chave WSSEND WSNULL WSSERVICE PLSXFUN

LOCAL lRetorno	:= .T.
LOCAL aArea 		:= GetArea()
LOCAL cRet 		:= ""

DEFAULT ::WSNULL 	:= ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se tem direito para executar o metodo								   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode ,"PLSXFUN","ConSolAdt" )

	cRet := PLS814SEND(::cCodRDA, ::Chave)
	::WSNULL := cRet

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetPrestBB8  ³Autor  ³Everton M Fernandes ³ Data ³15.10.15   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna dados do prestador de acordo com a BAX               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetPrestBB8 WSRECEIVE UserCode, RecnoBB8 WSSEND RetPrest WSSERVICE PLSXFUN
LOCAL aArea 	:= GetArea()
LOCAL lRetorno := .T.

If PrtChkUser( ::UserCode , "PLSXFUN","GetPrestBB8" )

	BB8->(DbSelectArea("BB8"))
	BB8->(DbGoTo(val(::RecnoBB8)))

	cRet := "{Descricao:'" + trim(BB8->BB8_DESLOC)	+ "'," + ;
			"CPFCGC:'"		+ trim(BB8->BB8_CPFCGC)	+ "'," + ;
			"Estado:'"		+ trim(BB8->BB8_EST)	+ "'," + ;
			"Municipio:'"	+ trim(BB8->BB8_MUN)	+ "'," + ;
			"Bairro:'"		+ trim(BB8->BB8_BAIRRO)	+ "'," + ;
			"Endereco:'"	+ trim(BB8->BB8_END)	+ "'," + ;
			"Numero:'"		+ trim(BB8->BB8_NR_END)	+ "'," + ;
			"CEP:'"		+ trim(BB8->BB8_CEP)	+ "'," + ;
			"Telefone:'"	+ trim(BB8->BB8_TEL)	+ "'," + ;
			"Email:'"		+ trim(BB8->BB8_EMAIL)	+ "'," + ;
			"Site:'"		+ trim(BB8->BB8_WEB)	+ "'"

	BAU->(DbSelectArea("BAU"))
	BAU->(DbSetOrder(1))
	If BAU->(MsSeek(xFilial("BAX")+trim(BB8->BB8_CODIGO)))
		cRet += ",NFantasia:'" + trim(BAU->BAU_NFANTA) + "'" + ;
				 ",Nome:'" + trim(BAU->BAU_NOME) + "'" + ;
				 ",ConReg:'" + trim(BAU->BAU_CONREG) + "'}"

	Else
		cRet += ",NFantasia:''" + ;
				 ",Nome:''" + ;
				 ",ConReg:''}"
	EndIf


	::RetPrest := cRet
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³ Retorno
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim do metodo														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
//--------------------------------------------------------------------------
/*/{Protheus.doc} Acreditacoes
WS que retorna as acreditações.

@Project	TTQLAU
@author	Lucas de Azevedo Nonato
@since		15/10/2015
@version	P12
/*/
//---------------------------------------------------------------------------

wsMethod Acreditacoes wsReceive UserCode,CodRdaAcr wsSend Acredit wsService PLSXFUN
local lRetorno := .T.
local i 		:= 1
local aArea 	:= GetArea()
local cRet 		:= ""
local cSql		:= ""

if PrtChkUser( ::UserCode , "PLSXFUN","Acreditacoes" )	
	cSql := " SELECT B7P_CODIGO, B7P_CODACR, B7P_NIVACR, B7P_CODINT, B7P_CODLOC "
	cSql += " FROM " + RetSQLName("B7P")
	cSql += " WHERE B7P_FILIAL = '" + xFilial("B7P") + "' "
	cSql += " AND B7P_CODIGO = '" + alltrim(CodRdaAcr) + "'  "
	cSql += " AND D_E_L_E_T_ = ' ' "
	
	cSql := ChangeQuery(cSql)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql),"TrbB7P",.T.,.F.)	
	
	while !TrbB7P->(eof())
		aadd( ::Acredit, WsClassNew( "SAcredit" ))			

		::Acredit[i]:CODIGO 	:= TrbB7P->B7P_CODIGO
		::Acredit[i]:CODACR     := TrbB7P->B7P_CODACR
		::Acredit[i]:DESCACR    := PlRetSX5("ZJ",TrbB7P->B7P_CODACR)
		::Acredit[i]:NIVACR     := TrbB7P->B7P_NIVACR
		::Acredit[i]:DESCNIV	:= PlsNIVACR(TrbB7P->B7P_NIVACR)
		::Acredit[i]:CODINT     := TrbB7P->B7P_CODINT
		::Acredit[i]:CODLOC     := TrbB7P->B7P_CODLOC
		i++		
		TrbB7P->(dbSkip())
	enddo
	
else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
endif

RestArea( aArea )

return lRetorno

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} PlsNIVACR
Retorna a descrição do nivel de acreditações.

@Project	TTQLAU
@author	Lucas de Azevedo Nonato
@since		15/10/2015
@version	P12
@Return	L

/*/
//---------------------------------------------------------------------------------------
Function PlsNIVACR(cNivAcr)
Local cDesc := ''

DO CASE
  CASE alltrim(cNivAcr) == '1'
     cDesc := "Acreditado"
  CASE alltrim(cNivAcr) == '2'
     cDesc := "Acreditado Pleno"
  CASE alltrim(cNivAcr) == '3'
     cDesc := "Acreditado com Excelencia"
  CASE alltrim(cNivAcr) == '4'
  	 cDesc := "Acreditado sem nivel de acreditacao"
  OTHERWISE
     cDesc := " "
ENDCASE

Return cDesc

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DADRETSIGLACR ³Autor  ³ TOTVS             ³ Data ³17.07.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna as siglas do C.R dos profissionais       		    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADRETSIGLACR WSRECEIVE UserCode WSSEND DadSiglaCR WSSERVICE PLSXFUN
LOCAL nI        := 1
LOCAL aArea	  := GetArea()
LOCAL lRetorno  := .T.


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³retorna os tipos de documentos utilizados no reembolso do portal do beneficiário	³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BAH->(DbSetOrder(1))
//BAH->(MsSeek(xFilial("BAH")+""))
While !BAH->(Eof()) //.and. BAH->BAH_XXX == "XXXX"
  AaDd( ::DadSiglaCR, WsClassNew( "SDadSiglaCR" ))
  ::DadSiglaCR[nI]:Descri := BAH->BAH_CODIGO
  nI++
  BAH->(DbSkip())
Enddo

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GrvIntera ³Autor  ³ Roberto	Vanderlei     ³ Data ³12.07.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Atualiza Auditoria/Interação	   	  							 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GrvIntera WSRECEIVE Chave, ChaveInt, Resposta, Pendente, Publico WSSEND WSNULL WSSERVICE PLSXFUN
	local cSETORAT := GetNewPar("MV_SETORAT","00")
	local cRecno
	local cAliasMov
	Local cAliasRec
	local cChaBusca := SUBSTR(::ChaveInt,1,21)
	local cChavGui:= SUBSTR(::ChaveInt,1,18)
	local lPendInte := .F.
	default ::Pendente := .T.
	default ::Publico := ""

	B53->(dbSetOrder(1))

	If B53->(msSeek(xFilial("B53") + ::Chave)) .or. B53->(msSeek(xFilial("B53") + cChavGui)) 
		Begin Transaction

			BBR->(dbSetOrder(2))

			//Atualiza Interacao
			If BBR->(msSeek(xFilial("BBR") + ::ChaveInt))
				
				cAlias := BBR->BBR_ALIMOV 
				
				BBR->(RecLock("BBR",.F.))
				BBR->BBR_RESPOS := ::Resposta
				BBR->BBR_SETOR  := Posicione("SX5",1,xFilial("SX5")+"BL"+cSETORAT/*BX4->BX4_CODDEP*/,"X5_DESCRI")//cSETORAT
				BBR->BBR_TPDIRP:=""
				BBR->(MsUnLock())
			endif

			//se o publico é prestador e não há mais pendencias com anexos e respostas, atualiza o status da guia
			if (::Publico) == "P"  .and.  !(::Pendente)

				If BBR->(msSeek(xFilial("BBR") + cChavGui)) 
					While (BBR->(!Eof()) .AND. BBR->(BBR_FILIAL+BBR_CODOPE+BBR_ANOAUT+BBR_MESAUT+BBR_NUMAUT) == (xFilial("BBR") + cChavGui)) 

						//Verifica se tem alguma pendência de interação por parte do PRESTADOR, caso possua, o setor responsável permanece como PRESTADOR. 
						If BBR->BBR_TPDIRP == "P" .and. BBR->BBR_RESPRE .AND. EMPTY(BBR->BBR_RESPOS) 
							lPendInte := .T.
							EXIT

						ElseIf !BBR->BBR_ANEXAD  
							lPendInte := .T.
							EXIT		
						endif

						BBR->(dbSkip())
					endDo
				EndIf
               
				If !lPendInte

				if(cAlias == "BEA")
					BEA->(DbSetOrder(1))
					If BEA->(MsSeek(xFilial("BEA")+B53->(B53_NUMGUI)))
						BEA->(RecLock("BEA",.F.))
						BEA->BEA_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
						BEA->(MsUnLock())
					EndIf
				elseif(cAlias == "BE4")
					BE4->(DbSetOrder(2))
					If BE4->(MsSeek(xFilial("BE4")+B53->(B53_NUMGUI)))
						BE4->(RecLock("BE4",.F.))
						BE4->BE4_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
						BE4->(MsUnLock())
					EndIf
			elseif(cAlias == "B4A")
					B4A->(DbSetOrder(1))
					If B4A->(MsSeek(xFilial("B4A")+B53->(B53_NUMGUI)))
						B4A->(RecLock("B4A",.F.))
						B4A->B4A_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
						B4A->(MsUnLock())
					EndIf
					
				endIf

			IF B53->B53_ALIMOV=="B4Q"
					B4Q->(DbSetOrder(1))
					If B4Q->(MsSeek(xFilial("B4Q")+B53->(B53_NUMGUI)))
						B4Q->(RecLock("B4Q",.F.))
						B4Q->B4Q_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
						B4Q->(MsUnLock())
					EndIf
				
			Endif
			
					//Atualiza Auditoria
					cAliasMov 	:= B53->B53_ALIMOV
					cAliasRec 	:= B53->B53_RECMOV

					B53->(RecLock("B53",.F.))
					B53->B53_CODDEP := cSETORAT
					B53->(MsUnLock())

			//Atualizar tabela de Encaminhamento - B71
			IF !Empty(cSETORAT)
			   		  PLSICB71(cAliasMov, cAliasRec, cSETORAT,::Resposta )
			ENDIF
				EndIf

				::WSNULL := If(lPendInte, 'true', 'false')
			Else
				if(cAlias == "BEA")
					BEA->(DbSetOrder(1))
					If BEA->(MsSeek(xFilial("BEA")+B53->(B53_NUMGUI)))
						BEA->(RecLock("BEA",.F.))
						BEA->BEA_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
						BEA->(MsUnLock())
					EndIf
				elseif(cAlias == "BE4")
					BE4->(DbSetOrder(2))
					If BE4->(MsSeek(xFilial("BE4")+B53->(B53_NUMGUI)))
						BE4->(RecLock("BE4",.F.))
						BE4->BE4_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
						BE4->(MsUnLock())
					EndIf
				elseif(cAlias == "B4A")
					B4A->(DbSetOrder(1))
					If B4A->(MsSeek(xFilial("B4A")+B53->(B53_NUMGUI)))
						B4A->(RecLock("B4A",.F.))
						B4A->B4A_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
						B4A->(MsUnLock())
					EndIf
					
			endIf

			IF B53->B53_ALIMOV=="B4Q"
					B4Q->(DbSetOrder(1))
					If B4Q->(MsSeek(xFilial("B4Q")+B53->(B53_NUMGUI)))
						B4Q->(RecLock("B4Q",.F.))
						B4Q->B4Q_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
						B4Q->(MsUnLock())
					EndIf
				
			Endif
				
				//Atualiza Auditoria
				cAliasMov 	:= B53->B53_ALIMOV
				cAliasRec 	:= B53->B53_RECMOV
				
				B53->(RecLock("B53",.F.))
				B53->B53_CODDEP := cSETORAT
				B53->(MsUnLock())
				
				//Atualizar tabela de Encaminhamento - B71
				IF !Empty(cSETORAT)
					PLSICB71(cAliasMov, cAliasRec, cSETORAT,::Resposta )
				ENDIF
				::WSNULL := 'true'
			endIf

		End Transaction
	endif

return .T.


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetInteracao ³Autor  ³ Roberto	        ³ Data ³07.07.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Busca dados das Interações   	 	 				           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetInteracao WSRECEIVE IteDad  WSSEND MViewInteracao WSSERVICE PLSXFUN

	LOCAL lRetorno   := ""
	LOCAL cAliMov	  := ::IteDad:AliMov
	LOCAL cAliIte	 := ""
	LOCAL cCodOpe    := ::IteDad:CodOpe
	LOCAL cAnoAut    := ::IteDad:AnoAut
	LOCAL cMesAut    := ::IteDad:MesAut
	LOCAL cNumAut    := ::IteDad:NumAut
	LOCAL cSeqProc   := ::IteDad:SeqProc
	LOCAL cTpPublico := ::IteDad:TpPublico
	LOCAL cChave     := ""
	local aDadHist   := {}
	local aCabHist   := {}
	local aTrbHist   := {}
	local nCont      := 0
	local cSQL       := ""
	local cObs		:= ""
	local cRespos	:= ""
	local nT			:= 1

	// Ajuste para considerar o cabeçalho e o item pra mostrar o historico pois ambos são gravados na tabela
	IF cAliMov == "BE2" .OR. cAliMov == "BEA"
		cAliIte := "BE2"
		cAliMov := "BEA"
	ElseIf cAliMov == "BE4" .OR. cAliMov == "BEJ"
		cAliIte := "BEJ"
		cAliMov := "BE4"
	ElseIf cAliMov == "B4A" .OR. cAliMov == "B4C"
		cAliIte := "B4C"
		cAliMov := "B4A"
	ElseIf cAliMov == "B4Q" .OR. cAliMov == "BQV"
		cAliIte := "BQV"
		cAliMov := "B4Q"
	EndIf

	::MViewInteracao 	:= {}

	cSQL := "SELECT * FROM " + RetSQLName("BBR")
	cSQL += "WHERE BBR_FILIAL = '" + xFilial("BBR") + "' "
	cSQL += "AND BBR_CODOPE = '" + cCodOpe + "' "
	cSQL += "AND BBR_ANOAUT = '" + cAnoAut + "' "
	cSQL += "AND (BBR_TPDIRP = '" + cTpPublico + "' OR BBR_TPDIRP = 'A') " 
	cSQL += "AND BBR_MESAUT = '" + cMesAut + "' "
	cSQL += "AND BBR_NUMAUT = '" + cNumAut + "' "
	cSQL += "AND BBR_SEQPRO = '" + cSeqProc + "' "
	cSQL += "AND (BBR_ALIMOV = '" + cAliMov + "' OR BBR_ALIMOV = '" + cAliIte + "') "
	cSQL += "AND " + RetSQLName("BBR")+".D_E_L_E_T_ = ''"

	cSQL := ChangeQuery(cSQL)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSQL),"TrbBBR",.T.,.F.)

	while !TrbBBR->(EOF())

		nCont += 1

		AaDd( ::MViewInteracao, WsClassNew( "SViewInteracao" ) )

		if cTpPublico = TrbBBR->BBR_TPDIRP .Or. TrbBBR->BBR_TPDIRP = 'A'

			::MViewInteracao[nCont]:SeqInt 	  	:= TrbBBR->BBR_SEQUEN
			::MViewInteracao[nCont]:SeqMop 	  	:= TrbBBR->BBR_SEQMOP
			::MViewInteracao[nCont]:DesMop 	  	:= Posicione("BBP",1,xFilial("BBP")+TrbBBR->BBR_SEQMOP,"BBP_DESMOT")
			::MViewInteracao[nCont]:Setor 	  	:= TrbBBR->BBR_SETOR
			::MViewInteracao[nCont]:DtIteracao  := STOD(TrbBBR->BBR_DTITER)
			::MViewInteracao[nCont]:ResPre 		:= &("."+TrbBBR->BBR_RESPRE+".")
			::MViewInteracao[nCont]:Anexado		:= &("."+TrbBBR->BBR_ANEXAD+".")
			::MViewInteracao[nCont]:TipDirec	:= TrbBBR->BBR_TPDIRP 
			
			BBR->(dbSetOrder(2))
			if BBR->(MsSeek(xFilial("BBR") + cCodOpe + cAnoAut + cMesAut + cNumAut + cSeqProc + TrbBBR->BBR_SEQUEN))
				
				//Codifica em hexadecimal
				cObs := ""
				cRespos := ""
				if !empty(BBR->BBR_OBSERV)
				
					cObs := plsStrBNum( BBR->BBR_OBSERV ,16, 2 )
				endif
	
				if !empty(BBR->BBR_RESPOS)
				
					cRespos := plsStrBNum( BBR->BBR_RESPOS ,16, 2 )
					
				endif
			EndIf
			::MViewInteracao[nCont]:RespPrest 	:= cRespos					
			::MViewInteracao[nCont]:Observacao	:= cObs
			::MViewInteracao[nCont]:AliasPai	:= TrbBBR->BBR_ALIMOV
		endif

		TrbBBR->(DbSkip())
	enddo

	TrbBBR->(dbCloseArea())

return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DADRETCID	 ³Autor  ³ Fábio S. dos Santos   ³ Data ³22/07/2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³Recebe o código do estado e envia os códigos e descrições das ³±±
±±³			 ³cidades.														³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADRETCID WSRECEIVE UserCode, CodEst WSSEND DADRETMUN WSSERVICE PLSXFUN
Local cCodInt	:= PLSINTPAD()
Local nI		:= 1
LOCAL aArea 	:= GetArea()
Local lRetorno	:= .T.

If PrtChkUser( ::UserCode ,"PLSXFUN","DADRETESPEC" )

	BID->(DbSetOrder(4))
	BID->(MsSeek(xFilial("BID")+alltrim(::CodEst)))
	While ( !(BID->(EoF())) .AND. (BID->BID_EST == alltrim(::CodEst)))
		Aadd(::DADRETMUN, WsClassNew ( "SDadCodMun" ) )
		::DADRETMUN[nI]:CodCid := BID->BID_CODMUN
		::DADRETMUN[nI]:Descri := StrTran(BID->BID_DESCRI,"'"," ")
		nI++
		BID->(DbSkip())
	EndDo
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do método." )
EndIf
RestArea( aArea )
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DADRETCEN	 ³Autor  ³ Roberto vanderlei   ³ Data ³  16/11/2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³Recebe o código do CEP e retorna o endereço. 					³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADRETBEN WSRECEIVE UserCode, CpfCnpj  WSSEND WSNULL WSSERVICE PLSXFUN
Local cCodInt	:= PLSINTPAD()
Local nI		:= 1
LOCAL aArea 	:= GetArea()
Local lRetorno	:= .T.
::WSNULL := ""
If PrtChkUser( ::UserCode ,"PLSXFUN","DADRETCEN" )
	BTS->(DbSetOrder(3))
	BTS->(MsSeek(xFilial("BTS")+ ::CpfCnpj + Space(TamSX3("BTS_CPFUSR")[1]-Len( AllTrim(::CpfCnpj)))   ))
	While ( !(BTS->(EoF())) .AND. (Alltrim(BTS->(BTS_CPFUSR)) == Alltrim(::CpfCnpj)))
		::WSNULL := "true|" + BTS->BTS_NOMUSR + "|" + SubStr((dtos(BTS->BTS_DATNAS)),7,2) + '/'+ SubStr((dtos(BTS->BTS_DATNAS)),5,2)+'/'+ SubStr((dtos(BTS->BTS_DATNAS)),0,4) + "|" + BTS->BTS_DRGUSR + "|" + BTS->BTS_ORGEM +  "|" + BTS->BTS_NRCRNA + "|" + BTS->BTS_PAI + "|" + BTS->BTS_MAE + "|" + BTS->BTS_EMAIL + "|" + BTS->BTS_CEPUSR  + "|" + BTS->BTS_COMEND + "|" + BTS->BTS_NR_END + "|" + BTS->BTS_DDD + "|" + BTS->BTS_TELEFO + "|" + BTS->BTS_SEXO + "|" + BTS->BTS_RGEST + "|" + BTS->BTS_UNIVER + "|" + BTS->BTS_ESTCIV + "|" + BTS->BTS_INVALI + "|" + BTS->BTS_ESTADO + "|" + BTS->BTS_CODMUN + "?" + BTS->BTS_MUNICI + "|" + BTS->BTS_ENDERE + "|" + BTS->BTS_BAIRRO
		BTS->(DbSkip())
	EndDo
Else
	lRetorno := .F.
	//SetSoapFault( "", "Não autorizado a utilização do método." )
EndIf
RestArea( aArea )
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DADRETCEN	 ³Autor  ³ Roberto vanderlei   ³ Data ³  16/11/2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³Recebe o código do CEP e retorna o endereço. 					³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADRETCEN WSRECEIVE UserCode, Cep WSSEND WSNULL WSSERVICE PLSXFUN

Local cCodInt := PLSINTPAD()
Local nI := 1
LOCAL aArea := GetArea()
Local lRetorno := .T.

::WSNULL := ""
If PrtChkUser( ::UserCode ,"PLSXFUN","DADRETCEN" )
	BC9->(DbSetOrder(1))
	BC9->(MsSeek(xFilial("BC9") + ::Cep))	//	Se for EOF() (CEP não Cadastrado), irá limpar os campos na Tela
	::WSNULL := "true|" + BC9->(IIF(EOF(), "CEP não Cadastrado !", BC9_END)) + "|" + BC9->BC9_BAIRRO + "|" + BC9->BC9_MUN+"?"+BC9->BC9_MUN + "|" + BC9->BC9_EST
Else
	lRetorno := .F.
EndIf
RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VERBENPRI	 ³Autor  ³ Roberto vanderlei   ³ Data ³  16/11/2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³Recebe o Login e verifica se é benef, ou ja solicitou.        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VERBENPRI WSRECEIVE UserCode, UsrLoginCode WSSEND WSNULL WSSERVICE PLSXFUN

LOCAL aArea 	:= GetArea()
Local lRetorno	:= .T.

::WSNULL := ""

If PrtChkUser( ::UserCode ,"PLSXFUN","VERBENPRI" )

	BA1->(DbSetOrder(4))
	BA1->(MsSeek(xFilial("BA1")+ alltrim(::UsrLoginCode) + Space(TamSX3("BA1_CPFUSR")[1]-Len( AllTrim(::UsrLoginCode)))   ))

	if (!(BA1->(EoF())) .AND. (Alltrim(BA1->(BA1_CPFUSR)) == Alltrim(::UsrLoginCode)))
		::WSNULL	:= "N"
	else
		B2N->(DbSetOrder(2))
		B2N->(MsSeek(xFilial("B2N")+ alltrim(::UsrLoginCode) + Space(TamSX3("B2N_CPFUSR")[1]-Len( AllTrim(::UsrLoginCode)))   ))

		if (!(B2N->(EoF())) .AND. (Alltrim(B2N->(B2N_CPFUSR)) == Alltrim(::UsrLoginCode)))
			::WSNULL	:= "N"
		else
			::WSNULL	:= "S"
		endif
	endif
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do método." )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DADRETENDER ³Autor  ³ Oscar Zanin         ³ Data ³24.07.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Carrega combo de locais de atendimento	 	               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADRETENDER WSRECEIVE UserCode, cCodRDA, cCodLoc  WSSEND DadEnder WSSERVICE PLSXFUN

Local cCodInt := PLSINTPAD()
Local nI		:= 1
Local aArea	:= getArea()
Local lRetorno	:= .T.
local cCodLoc		:= IIF(ValType(::cCodLoc) == "C", ::cCodLoc, "")

If PrtChkUser( ::UserCode ,"PLSXFUN","DADRETENDER" )

	BB8->(DbSetOrder(1))
	BB8->(MsSeek(xFilial("BB8")+::cCodRDA+cCodInt+cCodLoc))
	while (!(BB8->(EoF())) .AND. (BB8->(BB8_CODIGO) == ::cCodRDA) .And. BB8->(BB8_CODLOC) == cCodLoc .And. Empty(BB8->(BB8_DATBLO)) )
		Aadd(::DadEnder, WsClassNew ( "sDadEnder" ) )
		::DadEnder[nI]:CodLoc := BB8->(BB8_CODLOC)
		::DadEnder[nI]:Descri := BB8->(BB8_END)
		nI++
		BB8->(DbSkip())
	EndDo
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DADRETESPEC ³Autor  ³ Oscar Zanin         ³ Data ³24.07.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Carrega combo de especialidades	 		 	               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADRETESPEC WSRECEIVE UserCode, cCodRDA, CodLoc WSSEND DadEspec WSSERVICE PLSXFUN

Local cCodInt := PLSINTPAD()
Local nI		:= 1
Local aArea	:= getArea()
Local lRetorno	:= .T.
local cCodLoc		:= IIF(ValType(::CodLoc) == "C", ::CodLoc, "")
Local cCodRDA		:= Iif(Valtype(::cCodRDA) == "C", ::cCodRDA, "")

If PrtChkUser( ::UserCode ,"PLSXFUN","DADRETESPEC" )

	BAX->(DbSetOrder(1))
	BAX->(MsSeek(xFilial("BAX")+cCodRDA+cCodInt+cCodLoc))
	while ( !(BAX->(EoF())) .AND. (BAX->(BAX_CODIGO) == ::cCodRDA) .AND. (BAX->(BAX_CODLOC) == ::CodLoc) )
		Aadd(::DadEspec, WsClassNew ( "SDadEspec" ) )
		::DadEspec[nI]:CodEsp := BAX->(BAX_CODESP)
		::DadEspec[nI]:Descri := Posicione("BAQ",1,xFilial("BAQ")+cCodInt+BAX->BAX_CODESP,"BAQ_DESCRI")
		nI++
		BAX->(DbSkip())
	EndDo
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GRAVALOG 	³Autor  ³ Oscar Zanin           ³ Data ³24.07.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Grava solicitação de inclusão de corpo clínico               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GRAVALOG WSRECEIVE UserCode, DadLog, cUsrLogin WSSEND WSNULL WSSERVICE PLSXFUN

Local lRetorno	:= .T.
Local cDados		:= ::DadLog
Local cLogin 		:= ::cUsrLogin
Local cRet			:= ""

DEFAULT ::WSNULL 	:= "true|"

If PrtChkUser( ::UserCode ,"PLSXFUN","GRAVALOG" )

	cRet := PLS814LOG(cDados, cLogin)
	::WSNULL += cRet
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DADLOAD	³Autor  ³ Oscar Zanin           ³ Data ³24.07.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna os estados e sigla CR para combos corpo clínico      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADLOAD WSRECEIVE UserCode, Tipo WSSEND Dadload WSSERVICE PLSXFUN
LOCAL nI        	:= 1
LOCAL aArea	  	:= GetArea()
LOCAL cTipo		:= iif(EMPTY(::Tipo),"UF|SIGLA",::Tipo)
LOCAL lRetorno  	:= .T.
Local aSX5 		:= {}
Local nJ		:= 1
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "DADLOAD" )

	//Faz consulta de acordo com o parâmetro 'Campos':
	// VAZIO 	- UF e Sigla
	// UF		- Apenas UF
	// Sigla	- Apenas Sigla

	If(cTipo == "UF|SIGLA" .or. Upper(cTipo) == "UF")
		aSX5 := FWGetSX5("12")

		For nJ := 1 To Len(aSX5)
		      	AaDd( ::Dadload, WsClassNew( "SDadload" ))
			::Dadload[nI]:DescriA := aSX5[nJ][3]
			  	nI++
		Next nJ
	EndIf

	If(cTipo == "UF|SIGLA" .or. Upper(cTipo) == "SIGLA")
		BAH->(DbSetOrder(1))
		BAH->(DbGoTop())
		While !BAH->(Eof())
		  AaDd( ::Dadload, WsClassNew( "SDadload" ))
		  ::Dadload[nI]:DescriB := BAH->BAH_CODIGO
		  nI++
		  BAH->(DbSkip())
		Enddo
	EndIf

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DelCorpoClinico³Autor  ³ TOTVS	        ³ Data ³20/07/2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Bloqueia um profissional do copro clinico                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DelCorpoClinico WSRECEIVE UserCode, cRecno, Alias WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aArea    		:= GetArea()
LOCAL nVlrItem		:= 0

BC1->(DbGoTo(Val(cRecno)))
RecLock('BC1', .F.)
BC1_CODBLO := GetNewPar("MV_PLBLQCC", "   ")
BC1_MOTBLO := Posicione("BAP", 1, xFilial("BAP") + BC1->BC1_CODBLO, "BAP_DESCRI")
BC1_DATBLO := dDataBase
BC1_OBSERV := "Bloqueio via Portal"
MsUnlock()
::WSNULL := "true|Bloqueado com sucesso!"
RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetCalend ³Autor  ³ Giuvany Ribeiro       ³ Data ³05.08.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Pegar o calendario                                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetCalend WSRECEIVE UserCode, RDACode WSSEND WSNULL WSSERVICE PLSXFUN
Local lRet 		:= .T.
Local aArea 	:= GetArea()
Local nI		:= 1
Local aAux		:={}
Local aRet    := {}
Local  cCodPad := Subs(AllTrim(GetMv("MV_PLSCDCO")),1,2)
Local  cCodPro := Subs(AllTrim(GetMv("MV_PLSCDCO")),3,16)
Local lReembolso:= .F.
Local lJob :=.T.
Local lRPC	:= .T.
Local lHelp := .F.
Local cCodInt := PLSINTPAD()
Local aRdas := strtokarr(RDACode, "|")
DEFAULT WSNULL := ""

If PrtChkUser( ::UserCode, "PLSXFUN","GetCalend" )
	for nI := 1 to len(aRdas)
		aAux := PLSXVLDCAL(Date(),cCodInt,lHelp,cCodPad,cCodPro,lRPC,aRdas[nI],lReembolso,lJob)
		if aAux[1]
			if nI > 1
				::WSNULL += "@"
			endIf

			if len(aAux) > 8
				::WSNULL += aRdas[nI]+"|"+aAux[8]+"~"+aAux[9]
			else
				::WSNULL += aRdas[nI]
			endif

			aAdd(aRet, aAux)
		Else
			if nI > 1
				::WSNULL += "@"
			endIf

			if len(aAux) > 8
				::WSNULL += aRdas[nI]+"|"+ "Não encontrado" +"~"+ "Não encontrado"
			else
				::WSNULL += aRdas[nI]
			endif

			aAdd(aRet, aAux)
		endIf
	next nI
Else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o 	 ³CheckProcedimento ³Autor  ³ Rodrigo Morgon³ Data ³17/08/2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³        ³Verifica se solicitação do prestador pode ser realizada        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD CHECKPROCEDIMENTO WSRECEIVE UserCode, DadLog WSSEND WSNULL WSSERVICE PLSXFUN

LOCAL nI        	:= 1
LOCAL aArea	  	:= GetArea()
LOCAL lRetorno	:= .T.
LOCAL cCodInt		:= PlsIntPad()
LOCAL cCodRDA		:= ""
LOCAL cCodLoc		:= ""
LOCAL cCodEsp		:= ""
LOCAL cCodTab		:= ""
LOCAL cCodPro		:= ""
LOCAL cPadBkp		:= ""
LOCAL lHasBC0		:= .F.
LOCAL lHasB7L		:= .F.
LOCAL cSQL		    := ""
LOCAL nQtdReg	 	:= 0

PRIVATE aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB",.F.,"87"))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "CHECKPROCEDIMENTO" )

	::WSNULL 	:= "true|"

	// Realiza validação de acordo com os critérios do Where na BC0 e B7L
	//
	// BC0 - Procedimentos da RDA
	// aWhere[1] = 1 - Inclusão = Verifica se não existe registro na base para esse procedimento
	// aWhere[1] = 2 - Exclusão = Verifica se existe registro na base para esse procedimento
	//
	// B7L - Tabela de log
	// aWhere[1] = 1 - Inclusão = Verifica se não existe solicitação em análise para essa RDA, tabela e procedimento
	// aWhere[1] = 2 - Exclusão = Verifica se não existe solicitação de exclusão para essa RDA, tabela e procedimento
	//
	// Para todos os casos, se uma das condições não for satisfeita, retorna .F.

	//Formata os campos para correta busca na tabela
	aDadLog := Separa( ::DadLog, "|" )

	cCodRDA	:= AllTrim(aDadLog[2])+Space(TamSX3("BC0_CODIGO")[1]-Len(AllTrim(aDadLog[2])))
	cCodLoc	:= AllTrim(aDadLog[3])+Space(TamSX3("BC0_CODLOC")[1]-Len(AllTrim(aDadLog[3])))
	cCodEsp	:= AllTrim(aDadLog[4])+Space(TamSX3("BC0_CODESP")[1]-Len(AllTrim(aDadLog[4])))
	cCodTab	:= AllTrim(aDadLog[5])+Space(TamSX3("BC0_CODTAB")[1]-Len(AllTrim(aDadLog[5])))
	cCodPro	:= AllTrim(aDadLog[6])+Space(TamSX3("BC0_CODOPC")[1]-Len(AllTrim(aDadLog[6])))

	//DE/PARA da tabela e procedimento ANS para código interno.
	//cColuna, cAlias, lMsg, cCodTab , cVlrTiss, lPortal, aTabDup, cPadBkp )
	cPadBkp	:= PLSGETVINC("BTU_VLRBUS", "BR4", .F., "87", cCodTab, .T.)
	cCodTab	:= AllTrim(cPadBkp)
	cCodPro 	:= PLSGETVINC("BTU_VLRBUS", "BR8", .F., cCodTab,  cCodTab + AllTrim(cCodPro), .T. ,aTabDup, @cPadBkp)

	//Verifica na tabela BC0 - Procedimentos da RDA e na B7L - Tabela de log
	BC0->(DbSetOrder(2))
	BC0->(MsSeek(xFilial("BC0") + cCodRDA + cCodInt + cCodLoc + cCodEsp + cCodPro))
	lHasBC0 := !BC0->(EoF())

	//Verifica na tabela B98 se existe cabeçalho de item criado para a RDA selecionada
	B98->(DbSetOrder(2)) //B98_FILIAL+B98_CODINT+B98_CODIGO
	B98->(MsSeek(xFilial("B98") + cCodInt + cCodRDA))

	While !B98->(EoF()) .And. (B98->(B98_CODIGO) == cCodRda) .And. !lHasB7L
		If	!B98->(B98_APROVA) .and. !B98->(B98_INDEFE) .and. !B98->(B98_ATIVO)
			//Se existe na B98 e ainda não foi verificada (isto é, não foi aprovada/indeferida/não está ativa
			//Verifica se os itens tabela B7L correspondem ao procedimento solicitado.
			//Verificação feita através do índice B7L_FILIAL+B7L_CHAVE+B7L_CAMPO

			B7L->(DbSetOrder(3))
			B7L->(MsSeek(xFilial("B7L") + PADR(B98->B98_CODSEQ, TamSX3("B7L_CHAVE")[1]) + "BC0_CODOPC"))

			lHasB7L := !B7L->(EoF()) .And. AllTrim(B7L->B7L_VLPOS) == AllTrim(cCodPro)
		EndIf

		B98->(DbSkip())
	EndDo

	If AllTrim(aDadLog[1]) == "1" .AND. !lHasB7L//Inclusão de procedimento
		cSQL := "SELECT B7L_CHAVE"
		cSQL += " FROM " + RetSQLName("B7L")
		cSQL += " WHERE B7L_CAMPO = 'BC0_CODIGO' AND B7L_VLPOS = '" + cCodRDA + "' AND"
		cSQL += " B7L_GRAVAD = 'F' AND " + RetSqlName("B7L")+".D_E_L_E_T_ = '' "

		cSQL += " OR    B7L_CAMPO = 'BC0_CODLOC' AND B7L_VLPOS = '" + cCodLoc + "' AND"
		cSQL += " B7L_GRAVAD = 'F' AND " + RetSqlName("B7L")+".D_E_L_E_T_ = '' "

		cSQL += " OR    B7L_CAMPO = 'BC0_CODESP' AND B7L_VLPOS = '" + cCodEsp + "' AND"
		cSQL += " B7L_GRAVAD = 'F' AND " + RetSqlName("B7L")+".D_E_L_E_T_ = '' "

		cSQL += " OR    B7L_CAMPO = 'BC0_CODPAD' AND B7L_VLPOS = '" + cCodTab + "' AND"
		cSQL += " B7L_GRAVAD = 'F' AND " + RetSqlName("B7L")+".D_E_L_E_T_ = '' "

		cSQL += " OR    B7L_CAMPO = 'BC0_CODOPC' AND B7L_VLPOS = '" + SUBSTR(cCodPro,3) + "' AND"
		cSQL += " B7L_GRAVAD = 'F' AND " + RetSqlName("B7L")+".D_E_L_E_T_ = '' "

		cSQL += " GROUP BY B7L_CHAVE"
		cSQL += " HAVING COUNT(B7L_CHAVE) = 5"

		cSQL := ChangeQuery(cSQL)
		dbUseArea( .T., "TOPCONN", TCGENQRY(,,cSQL),"B7LQuery", .F., .T.)

		Count To nQtdReg //Variavel que recebe a quantidade de registros

		B7LQuery->(dbCloseArea())

		If nQtdReg > 0
			lHasB7L := .T.
		EndIf
	EndIf

	Do Case
		//Inclusão de procedimento
		Case AllTrim(aDadLog[1]) == "1"
			If lHasBC0 .or. lHasB7L
				//Procedimento já existente no cadastro, então não pode ser realizado novamente.
				::WSNULL := "false|Procedimento já cadastrado ou em análise."
			EndIf

		//Exclusão de procedimento
		Case AllTrim(aDadLog[1]) == "2"
			If !lHasBC0
				::WSNULL := "false|Procedimento não encontrado."
			EndIf
	EndCase

	RestArea(aArea)
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

return lRetorno


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GRAVAPROCEDIMENTO ³Autor  ³ Rodrigo Morgon³ Data ³21.08.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   	Grava solicitação de inclusão ou exclusão procedimento   		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GRAVAPROCEDIMENTO WSRECEIVE UserCode, DadLog, cUsrLogin WSSEND WSNULL WSSERVICE PLSXFUN

Local lRetorno	:= .T.
Local cDados		:= ::DadLog
Local cLogin 		:= ::cUsrLogin
Local cRet			:= ""
Local aDados		:= {}
Local aLinhas		:= {}
Local nI			:= 1

DEFAULT ::WSNULL 	:= "true|"

If PrtChkUser( ::UserCode ,"PLSXFUN","GRAVAPROCEDIMENTO" )

	//Cria um array com todas as linhas da grid
	aDados := Separa(cDados,"|",.F.)
	for nI := 1 to len(aDados)
		aadd(aLinhas, Separa(aDados[nI],"$",.F.))
	next

	cRet := PLS814PROC(aLinhas, cLogin)
	::WSNULL += cRet
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VerAcesso ³Autor  ³ Roberto Vanderlei     ³ Data ³14.08.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verificar primeiro acesso, caso sim, solicitar atualização.  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VERACESSO WSRECEIVE UsrLoginCode WSSEND WSNULL WSSERVICE PLSXFUN

Local lRet 		     := .T.
local lPrimeiroAcesso := .F.
local cPrimeiroAcesso
local cNomUsr  := ""
local cLogin   := ""
local cSenha   := ""
local nCont
local cMensagem := ""
DEFAULT WSNULL := ""

if ValType(HttpSession->aMensagensPortal) = 'U'
	HttpSession->aMensagensPortal := PLSRETMSG("3")
endif

for nCont := 1 to len(HttpSession->aMensagensPortal)

	if(HttpSession->aMensagensPortal[nCont][1] = "STR0001")
		cMensagem := HttpSession->aMensagensPortal[nCont][2]
	endif

next nCont


BSW->(DbSelectArea("BSW"))
BSW->(DbSetOrder(5))

If (BSW->(MsSeek(xFilial("BSW")+ ::UsrLoginCode)))

	lPrimeiroAcesso := BSW->BSW_PRIACE

	if lPrimeiroAcesso
		cPrimeiroAcesso := "true"
	else
		cPrimeiroAcesso := "false"
	endif

	cNomUsr 		  := BSW->BSW_NOMUSR
	cLogin  		  := BSW->BSW_LOGUSR
	cSenha 		  := PLSCRIDEC(2, BSW->BSW_SENHA) //Se estiver no padrão antigo, descriptografa e gera o hash MD5

	if alltrim(cMensagem) <> ""
		cMensagem := strTran(cMensagem, "%NOMUSR%", Capital(cNomUsr))
	endif

	::WSNULL := ::UsrLoginCode + "|" + cLogin + "|" + Capital(cNomUsr) + "|" + cSenha + "|" + cPrimeiroAcesso + "|" + cMensagem
else
	lRet := .F.
	SetSoapFault( "", "Usuário não encontrado.")
EndIf

Return lRet


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ GrvSolOpc ³Autor  ³ Oscar 				 ³ Data ³18.09.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³			 ³	Grava solicitação  2 de 2                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GrvSolOpc WSRECEIVE UserCode, Chave WSSEND WSNULL WSSERVICE PLSXFUN

LOCAL lRetorno	:= .T.
LOCAL aArea 		:= GetArea()
LOCAL cRet 		:= ""

DEFAULT ::WSNULL 	:= ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se tem direito para executar o metodo								   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode ,"PLSXFUN","GrvSolOpc" )

	PLS009WEBP(::Chave)
	::WSNULL := "true|"

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Exclusão Banco Conhecimento³Autor  ³ Oscar ³ Data ³05.10.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³UnUplConhec ³																      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD UnUplConhec WSRECEIVE UserCode, cRecno WSSEND WSNULL WSSERVICE PLSXFUN

LOCAL lRetorno	:= .T.
LOCAL lRet    	:= .T.
LOCAL aArea 		:= GetArea()
LOCAL cRet 		:= ""
Local nRecno		:= IIF( !(Empty(::cRecno)), Val(::cRecno), 0 )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se tem direito para executar o metodo								   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode ,"PLSXFUN","UnUplConhec" )

	If nRecno > 0
		//Chama a função para exclusão do arquivo
		lRet := PLSOUTCONH( nRecno )
	EndIf

	If lRet
		cRet := "Arquivo Excluído com sucesso"
	EndIF

	::WSNULL := "true|"+cRet

Else
	lRetorno := .F.
	::WSNULL := "false|"+"Erro na exclusão"
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o  ³Cópia da base conhecimento³Autor ³ Francisco ³ Data ³06.01.2017 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³CpyArqConhe ³																      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD CpyArqConhe WSRECEIVE UserCode, cRecno WSSEND WSNULL WSSERVICE PLSXFUN

LOCAL lRetorno	:= .T.
LOCAL lRet    	:= .T.
LOCAL aArea 		:= GetArea()
LOCAL cRet 		:= ""
Local nRecno		:= IIF( !(Empty(::cRecno)), Val( STRTRAN(::cRecno,".","")), 0 )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se tem direito para executar o metodo								   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode ,"PLSXFUN","CpyArqConhe" )

	If nRecno > 0
		//Chama a função para copia do arquivo
		cRet := PLSCOPWEB( nRecno )
	EndIf

	If !Empty(cRet)
		::WSNULL := "true|"+cRet
	Else
		::WSNULL := "false|Falha ao baixar o arquivo"
	EndIF
Else
	lRetorno := .F.
	::WSNULL := "false|"+"Erro na transmissão do arquivo"
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DelDesp³Autor  ³ Oscar Zanin   ³ Data ³20.10.2015 		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Método para deletar uma despesa adicionada							  	 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DelDesp WSRECEIVE UserCode, cRecno WSSEND WSNULL WSSERVICE PLSXFUN

Local lRetorno 	:= .T.
Local lRet			:= .T.
Local aArea		:= GetArea()
Local cRet			:= ""
Local nRecno		:= IIF( !(Empty(::cRecno)), Val(::cRecno), 0 )

If PrtChkUser( ::UserCode, "PLSXFUN", "DelDesp" )

	If nRecno > 0
		lRet := PLSOUTB1N(nRecno)
	EndIf

	If lRet
		cRet := "Despesa Excluída com sucesso"
	EndIf

	::WSNULL := "true|"+cRet

else
	lRetorno := .F.
	::WSNULL	:= "false|"+"Erro na Exclusão"
	setSoapFault( "", "Não autorizado a utilização do método" )
EndIF

restArea(aArea)

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GrvFimReemb³Autor  ³ Oscar Zanin   ³ Data ³20.10.2015 		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Finaliza gravação da solicitação de reembolso 							  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GrvFimReemb WSRECEIVE UserCode, MatUsu, NomRdaNRef, CPFCNPJ, cUsrLogin, CodSol, NumDoc, DocEmi, Tipo, Altera, DocObrig, CabAlt, RecDivs, AtuB1N, TipoVld WSSEND WSNULL WSSERVICE PLSXFUN

Local lRetorno	:= .T.
Local aRet		:= {}
Local cRet		:= ""
Local cCodSol	:= If(Valtype(::CodSol) == "C", ::CodSol, "ZZZZX")
Local aDados	:= {}
LOCAL aDadUsr := PLSGETUSR()
Local aDadBK6	:= {}
Local lIncBK6	:= GetNewPar("MV_VRDANRF", .F.)
Local cUf		:= ""
Local cMunc		:= ""
LOCAL aDadRet := {} 

DEFAULT Altera   := "false" 
DEFAULT DocObrig := "true"
DEFAULT CabAlt   := .F.
DEFAULT RecDivs  := "0"
DEFAULT AtuB1N   := "S"
DEFAULT TipoVld  := "1" 

// Quando esse método é executado por fora do portal protheus, o aDadUsr fica vazio porque não passar por nenhum lugar que executa PLSDADUSR. 
// É necessário executar PLSDADUSR.
If Len(aDadUsr) == 0
	// Executa PLSDADUSR apenas para alimentar a váriavel stática aDadUsr do PLSMFUN. Essa váriavel será necessária ao longo deste processo e depende essa ação. 
	aDadUsr := PLSDADUSR(::MatUsu,'1',.F.,dDatabase,,,"NAO_VALIDAR_CARTAO")	
Endif

//Monta aDados
Aadd(aDados, ::MatUsu)
Aadd(aDados, ::CPFCNPJ)
Aadd(aDados, ::cUsrLogin)
Aadd(aDados, xFilial("BOW"))
Aadd(aDados, AllTrim(::NomRdaNRef))
Aadd(aDados, AllTrim(::NumDoc))
Aadd(aDados, ::DocEmi)
Aadd(aDados, ::Tipo)
Aadd(aDados, cUf)
Aadd(aDados, cMunc)

//Verifico se é Multicomprovante. Se sim, tenho que pegar as possiveis RDAs diferentes na B1N
//Além disso, o sistema grava na BOW o estado e Municipio da primeira inclusão, mas caso coloquemos mais
//de um comprovante, o sistema retorna o CNPJ do último comprobante, sem sempre de acordo com a BOW
If (TipoVld == "1" .And. !lIncBK6 ) //Tem que ser multicomprovante = "1" e o parâmetro deve estar false, grava direto
	aDadBK6 := PLSRCRNRF (cCodSol)
	If ( (Empty(aDados[2]) .Or. aDados[2] <> aDadBK6[2,1]) .And. (Len(aDadBK6[1]) > 0) )
		aDados[2] := Iif(!Empty(aDadBK6[2,1]), aDadBK6[2,1], aDadBK6[1,2,2])
	EndIf	
	If ( (Empty(aDados[5]) .Or. aDados[5] <> aDadBK6[2,2]) .And. (Len(aDadBK6[1]) > 0))
		aDados[5] := Iif(!Empty(aDadBK6[2,2]), aDadBK6[2,2], aDadBK6[1,2,1])
	EndIf
	If (!Empty(aDadBK6[2,3]) .AND. len(aDadBK6[1]) >= 1)
		aDados[9]  := Iif(!Empty(aDadBK6[2,3]), aDadBK6[2,3], aDadBK6[1,2,3])
		aDados[10] := Iif(!Empty(aDadBK6[2,4]), aDadBK6[2,4], aDadBK6[1,2,4])
	EndIf
Endif	


If PrtChkUser( ::UserCode, "PLSXFUN", "GrvFimReemb" )
	if !empty(cCodSol)
		
		If BCT->(FieldPos("BCT_VALREE")) > 0  
			
			//verifica se existem itens negados e deleta do banco de dados.
			aDadRet := PLDELITEM(cCodSol) 
			
			//Se na primeir posição retornar true, significa que existe pelo menos um item aprovado no protocolo.
			If aDadRet[1]
				
				cRet := PLSCMPBOW(cCodSol, aDados, ::Altera, ::DocObrig, ::CabAlt, ::RecDivs, ::AtuB1N)
				aRet := Separa(cRet, "|")
				if aRet[1] == "true"
					lRetorno := .T.
				EndIf
				
				//se na segunda posição retornar false significa que não existem itens negados.
				If !aDadRet[2]
					::WSNULL := cRet + "|true"
				else
					
					//se na segunda posição retornar true significa existem itens negados e aprovados no protocolo.
					::WSNULL := "true|<b>Os itens negados não serão gravados ou contabilizados no protocolo!</b>"
					::WSNULL += "<br/><br/>"
					::WSNULL += SubStr(cRet,6)
					::WSNULL += "|false"
				EndIf
			Else
				//se na primeira posição retornar false significa que todos os itens foram negados.
				::WSNULL := "true|Solicitação não concluída pois todos os itens foram negados!|false"
			EndIf
		Else
			
			cRet := PLSCMPBOW(cCodSol, aDados, ::Altera, ::DocObrig, ::CabAlt, ::RecDivs, ::AtuB1N)
			aRet := Separa(cRet, "|")
			
			if aRet[1] == "true"
				lRetorno := .T.
			EndIf
			
			::WSNULL := cRet
		EndIf 
	Else
		::WSNULL := "false|"
	EndIf 
else
	lRetorno := .F.
	::WSNULL := "false|"
	setSoapFault("", "Não autorizado a utilização do método" )
EndIF

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VerPermRee³Autor  ³ Oscar Zanin   ³ Data ³20.10.2015 		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Verifica se o usuário do portal tem permissão para solicitar reembolso ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VerPermRee WSRECEIVE UserCode, cUsrLogin WSSEND WSNULL WSSERVICE PLSXFUN

Local lRetorno := .T.

If PrtChkUser( ::UserCode, "PLSXFUN", "VerPermRee" )
	::WSNULL := IIF( PLSREEMBDI(::cUsrLogin), "true", "false" )
else
	lRetorno := .F.
	::WSNULL := "false|"
	setSoapFault("", "Não autorizado a utilização do método" )
EndIf

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DadFrmEmp ³Autor  ³ Karine Riquena Limp   ³ Data ³11.09.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Retorna os beneficiários que fazem parte do grupo familiar            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DadFrmEmp WSRECEIVE UserCode, cUsrLogin, TpPor, SoFam, MatUsu, PermT WSSEND DadosGrpFam WSSERVICE PLSXFUN
LOCAL nI        := 1
LOCAL aArea	  := GetArea()
LOCAL lRetorno  := .T.
LOCAL cSQL		  := ""
LOCAL cCodFam
DEFAULT ::SoFam   := ""
DEFAULT ::MatUsu   := ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "DadGrpFam" )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³retorna a matricula do beneficiario que esta cadastrado para o login	³
	//Se Permt igual a 1, significa que é filtro referente aos usuários na solicitaçãod e reembolso
	//pois agora, o controle de quem pode constar neste campo como disponíevl para reembolso é via BA1_REEWEB
	// e BA3_REEWEB não existe mais.
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF (PermT <> '1')
		cSQL := PLSGETBA1(::TpPor, ::cUsrLogin, ::MatUsu, ::SoFam)
	ELSE
		cSQL := PLSGETREE(::TpPor, ::cUsrLogin, ::MatUsu, ::SoFam, ::PermT)
	ENDIF

	PLSQuery(cSQL,"TrbRetFE")
	
	While !TrbRetFE->(EOF())

	  AaDd( ::DadosGrpFam, WsClassNew( "SDadGrp" ) )
		::DadosGrpFam[nI]:Matricl := TrbRetFE->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO)
		::DadosGrpFam[nI]:NomeBnf := TrbRetFE->BA1_NOMUSR
		nI++
		TrbRetFE->(dbSkip())

	EndDo
	TrbRetFE->(dbCloseArea())
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³INCBENOPC ³Autor  ³ Fábio S. dos Santos   ³ Data ³14/08/2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³ Realiza a gravacao dos Beneficiários x Opcionais			   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD INCBENOPC WSRECEIVE UserCode, DadosOpc, cUsrLogin, CodPor, Classe WSSEND WSNULL WSSERVICE PLSXFUN
Local lRet		:= .T.
Local lRetorno	:= .T.
Local aRet		:= {}
Local cLogin 	:= ::cUsrLogin
Local aDadRet	:= {}
Local cUrl		:= ""
Local cMsg		:= ""
Local oDados	:= DadosOpc:DADOSBENOPC
Local nI := 1
local aOpc := {}
local cMatTit := ""
local cCodOpc := ""
local cVerOpc := ""
local cDesOpc := ""
local cMatricula := ""
local cOpc := ""
local lVldOpcTit := SuperGetMv("MV_PVLOPCT")
Default WSNULL := ""

If PrtChkUser( ::UserCode, "PLSXFUN", "SolOpc" )

	if lVldOpcTit .and. len(::DadosOpc:DADOSBENOPC) > 0
		BA1->(dbSetOrder(1))
		BA1->(msSeek(xFilial("BA1")+left(::DadosOpc:DADOSBENOPC[1]:CODBEN, 14)+ALLTRIM(SuperGetMv("MV_PLCDTIT"))))
		cMatTit := BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)

		For nI := 1 to len(::DadosOpc:DADOSBENOPC)

			cMatricula := ::DadosOpc:DADOSBENOPC[nI]:CODBEN
			cCodOpc    := ::DadosOpc:DADOSBENOPC[nI]:CODOPC
			cVerOpc    := ::DadosOpc:DADOSBENOPC[nI]:VEROPC
			cDesOpc    := Posicione("BI3",1,xFilial("BI3")+PLSINTPAD()+cCodOpc,"BI3_DESCRI")

			//garanto que vou validar o codigo do opcional apenas uma vez, pois posso ter varios dependentes com o mesmo codigo
			if !(aScan(aOpc, { |x| x == cCodOpc}) > 0 )
				//se não é a matricula do titular e não tem ele na solicitação com esse codigo de opcional e não existe na BF4 a matricula do titular
				if(cMatricula != cMatTit) .and. !(AScan( ::DadosOpc:DADOSBENOPC, { |x| x:CODBEN == cMatTit .and. x:CODOPC == cCodOpc} ) > 0)	;
										     .and. !PLSVLDOPCT(cMatTit, cCodOpc, 3)

					cOpc += cCodOpc+"~"+cVerOpc+"~"+cDesOpc+"#"
					lRet := .F.

				endIf

				aAdd(aOpc, cCodOpc)

			endIf


		Next nI

	endIf

	if lRet

		If ExistBlock("PLSGRVBEN")
			aRet := ExecBlock("PLSGRVBEN",.F.,.F.,{oDados})
			lRet	:= aRet[1]
		EndIf

	endIf

	If lRet
		::WSNULL := PLS009GRV(::DadosOpc, cUsrLogin, CodPor, Classe)

		aDadRet := Separa( ::WSNULL, '|' )
		cMsg := "Solicitação gravada com sucesso, seu protocolo é " + aDadRet[5]
		If aDadRet[1] == "1"
			cExec := "W_PPLUPLOPC.APW?cChave="+aDadRet[2]+"&cRecno="+aDadRet[3]+"&cLista="+aDadRet[4]+"&cModo=2&cAlitab=BBA&cNumInd=1"
			::WSNULL := "anexo|" + cMsg + ", por favor anexar os documentos necessários na pagina seguinte!|" + cExec + "|" + aDadRet[6]
		Else
			::WSNULL := cMsg
		EndIf
	Elseif !lRet .and. !empty(cOpc)
		::WSNULL := "opctit|" + left(cOpc, len(cOpc)-1)
	Else
		::WSNULL := aRet[2]
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³VldBenOpc ³Autor  ³ Karine Riquena Limp   ³ Data ³21.09.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Verifica se os beneficiarios inseridos na solicitação já possuem os   ³±±
±±³  opcionais solicitados na base de dados e em vigência                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VLDBENOPC WSRECEIVE UserCode, Valores, ArrOpc WSSEND WSNULL WSSERVICE PLSXFUN
local aValores := {}
local cMatricula := ""
local cCodOpc := ""
local cVerOpc := ""
local cDesOpc := ""
local cNome := ""
local cValores := ""
local cRec := ""
local cVldEspe := ""
local dtBlo
local dtBas
local dtAtu := dToS(Date())
local nI := 0
local nJ := 1
local lAchou := .F.
local lRetorno := .T.
local aRet := {.T., ""}
local aOpc := {}
local cMatTit := ""
local cOpcTit := ""
local lVldOpcTit := getNewPar("MV_PVLOPCT", .F.)
Local lPLVINSOP  := ExistBlock("PLVINSOP")
Default ::WSNULL := ""
Default ::ArrOpc := ""
If PrtChkUser( ::UserCode, "PLSXFUN", "VldBenOpc" )
	aValores	:= Separa ( ::Valores, "@" , .F.)

	BF4->(dbSetOrder(1))
	nI := 1

	if lVldOpcTit .and. len(aValores) > 0

		BA1->(dbSetOrder(1))
		cValores   := Separa(aValores[1], ";", .F.)
		BA1->(msSeek(xFilial("BA1")+left(Separa(cValores[1], "$", .F.)[2], 14)+ALLTRIM(SuperGetMv("MV_PLCDTIT"))))
		cMatTit := BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)
	endIf

	while nI <= len(aValores) .AND. len(aValores) > 0 // essa condição é pq eu diminuo o array no meio do while
		cValores   := Separa(aValores[nI], ";", .F.)
		cMatricula := left(Separa(cValores[1], "$", .F.)[2], 16) // retiro o digito da matricula
		cNome      := Separa(cValores[2], "$", .F.)[2]
		cCodOpc    := Separa(cValores[3], "$", .F.)[2]
		cDesOpc    := Separa(cValores[5], "$", .F.)[2]
		dtBas      := Separa(cValores[6], "$", .F.)[2]
		dtBlo      := Separa(cValores[7], "$")[2] //retirei .F. pois quando nao vinha a data de bloqueio dava array out of bounds, esse .f. é para não considerar a posição quando estiver vazia
		lAchou     := .F.

		If lPLVINSOP
			//se for bloqueada a inclusão do opcional por algun motivo especificico,
			//esse ponto de entrada retorna um array, composto por um valor lógico e uma mensagem
			aRet := ExecBlock("PLVINSOP",.F.,.F.,{cMatricula, cCodOpc, cToD(dtBas), cToD(dtBlo)})
		Endif

		if(aRet[1])
			if(BF4->(MsSeek(xFilial("BF4")+cMatricula+cCodOpc)))
				while( BF4->(!EOF()) .AND. ;
						BF4->(BF4_FILIAL+BF4_CODINT+BF4_CODEMP+BF4_MATRIC+BF4_TIPREG+BF4_CODPRO);
						   ==(xFilial("BF4")+cMatricula+cCodOpc)  .AND. !lAchou  )
						   dtBas := dToS(BF4->BF4_DATBAS)
						   dtBlo := dToS(BF4->BF4_DATBLO)
						   //verifica se o opcional está em vigênia
						   if ( (empty(dtBas) .or. dtBas <= dtAtu) .AND. (empty(dtBlo) .or. dtAtu <= dtBlo) )
						   		ADEL(aValores, nI)
						   		ASIZE(aValores, (len(aValores)-1))
						   		nI-- //nI-- porque estou diminuindo o array
						   		cRec += cMatricula+"~"+cNome+"~"+cCodOpc+"~"+cDesOpc+"~"+dToC(BF4->BF4_DATBAS)+"~"+dToC(BF4->BF4_DATBLO)+"#"
						   		lAchou := .T.
						   endIf
					BF4->(dbSkip())
				endDo
			endIf
		else
			ADEL(aValores, nI)
			ASIZE(aValores, (len(aValores)-1))
			nI-- //nI-- porque estou diminuindo o array
			cVldEspe += aRet[2]+"~"+cMatricula+"~"+cNome+"~"+cCodOpc+"~"+cDesOpc+"#"
		endIf
		nI++
	endDo


	if lVldOpcTit .and. len(aValores) > 0


		//faço o while novamente para pegar somente os opcionais que ainda nao existem na BF4
		//entao se o titular estiver nesse aValores é pq ainda nao possui o opcional na BF4
		//logo, ele deve estar aqui, senão, não pode incluir os dependentes
		nI := 1
		while nI <= len(aValores) .AND. len(aValores) > 0 // essa condição é pq eu diminuo o array no meio do while

			cValores   := Separa(aValores[nI], ";", .F.)
			cMatricula := alltrim(Separa(cValores[1], "$", .F.)[2])
			cCodOpc    := Separa(cValores[3], "$", .F.)[2]
			cVerOpc    := Separa(cValores[4], "$", .F.)[2]
			cDesOpc    := Separa(cValores[5], "$", .F.)[2]

			//garanto que vou validar o codigo do opcional apenas uma vez, pois posso ter varios dependentes com o mesmo codigo
			if !(aScan(aOpc, { |x| x == cCodOpc}) > 0 )
				//se não é a matricula do titular e não tem ele na solicitação com esse codigo de opcional e não existe na BF4 a matricula do titular
				if(cMatricula != cMatTit) .and. !(AScan( aValores, { |x| "Field_BenefsMat$"+cMatTit $ x .and. "Field_CodOpc$"+cCodOpc $ x} ) > 0)	;
										     .and. !(cMatTit+"$"+cCodOpc $ ::ARROPC) .and. !PLSVLDOPCT(cMatTit, cCodOpc, 3)
					ADEL(aValores, nI)
					ASIZE(aValores, (len(aValores)-1))
					nI-- //nI-- porque estou diminuindo o array
					cOpcTit += cCodOpc+"~"+cVerOpc+"~"+cDesOpc+"#"
				endIf

				aAdd(aOpc, cCodOpc)

			endIf

			nI++
		endDo

	endIf

	if(len(aValores) <= 0)
		::WSNULL += "0" //coloco esse 0 quando não tem mais valores no array, para dar o split na webfunction
	else
		for nI := 1 to len(aValores)
			::WSNULL += aValores[nI] + iif(nI < len(aValores), "@", "")
		next nI
	endIf

	::WSNULL += "|" + iif(cRec <> "",left(cRec, len(cRec)-1) ,"0") + "|" + iif(cVldEspe <> "",left(cVldEspe, len(cVldEspe)-1) ,"0") + "|" + iif(cOpcTit <> "",left(cOpcTit, len(cOpcTit)-1) ,"0") // tirando o # do final
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetSolOpc ³Autor  ³ Karine Riquena Limp   ³ Data ³25.09.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Retorna o protocolo da solicitação                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetSolOpc WSRECEIVE UserCode, cRecno WSSEND DadSolOpc WSSERVICE PLSXFUN
LOCAL nI        := 1
LOCAL aArea	  := GetArea()
LOCAL lRetorno  := .T.
LOCAL nRecno    := 0
LOCAL cClasse   := ""
LOCAL cCodInt   := PLSINTPAD()
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "GetSolOpc" )

	BA0->(dbSetOrder(1))
	BA0->(msSeek(xFilial("BA0")+cCodInt))
			nRecno := Val(cRecno)
			BBA->(dbGoTo(nRecno))

			if(!empty(BBA->BBA_CLASSE))

				BY4->(dbSetOrder(1))
				if(BY4->(msSeek(xFilial("BY4")+BBA->BBA_CLASSE)))
					cClasse:= BY4->BY4_DESC
				endif

			endif

			::DadSolOpc := WsClassNew( "SDadSolOpc" )

			::DadSolOpc:RecnoSol           := ::cRecno
			::DadSolOpc:Prot               := BBA->BBA_NROPRO
			::DadSolOpc:DataSol            := BBA->BBA_DATSOL
			::DadSolOpc:HoraSol            := BBA->BBA_HORSOL
			::DadSolOpc:Classe             := cClasse
			::DadSolOpc:DadosOpe           := WsClassNew( "SDadOpe" )
			::DadSolOpc:DadosOpe:CodOpe    := cCodInt
			::DadSolOpc:DadosOpe:NomeOpe   := BA0->BA0_NOMINT
			::DadSolOpc:DadosOpe:Ender     := BA0->BA0_END
			::DadSolOpc:DadosOpe:NumEnd    := BA0->BA0_NUMEND
			::DadSolOpc:DadosOpe:Compl     := BA0->BA0_COMPEN
			::DadSolOpc:DadosOpe:Bairro    := BA0->BA0_BAIRRO
			::DadSolOpc:DadosOpe:Cidade    := BA0->BA0_CIDADE
			::DadSolOpc:DadosOpe:Estado    := BA0->BA0_EST
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AltSolOpc ³Autor  ³ Karine Riquena Limp   ³ Data ³28.09.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Altera o status da solicitação para 2-EM ANÁÇISE quando há            ³±±
±±³		envio de documento pela consulta                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD AltSolOpc WSRECEIVE UserCode, cRecno WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRet := .T.
LOCAL lRetorno := .T.
LOCAL aArea	  := GetArea()
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "AltSolOpc" )
	lRet := PL09AltOpc(Val(::cRecno))
	if(lRet)
		::WSNULL := "true|"
	else
		::WSNULL := "false|"
	endif
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetUsrRec ³Autor  ³ Karine Riquena Limp   ³ Data ³07.10.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Retorna as receitas de medicamentos de uso continuo                   ³±±
±±³		cadastradas para o beneficiario                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetUsrRec WSRECEIVE UserCode, MatUsu WSSEND DadUsrRec WSSERVICE PLSXFUN
local nI        := 1
local lRetorno := .T.
local aArea	  := GetArea()

if PrtChkUser( ::UserCode, "PLSXFUN", "GetUsrRec" )
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³retorna as receitas e medicamentos do beneficiario                      ³
    //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	B4F->(dbSetOrder(2))
	B7D->(dbSetOrder(3))
	BR8->(dbSetOrder(3))

	B4F->(MsSeek(xFilial("B4F")+ alltrim(::MatUsu)))

	while !B4F->(EOF()) .AND. alltrim(xFilial("B4F")+::MatUsu) == alltrim(B4F->(B4F_FILIAL+B4F_MATRIC))

		if(B4F->B4F_STATUS == '3' .OR. B4F->B4F_STATUS == '5') //3= Deferido ; 5=Deferido parcialmente

			if B7D->(MsSeek(xFilial("B7D") + B4F->B4F_CODREC))

				while !B7D->(EOF()) .AND. alltrim(xFilial("B7D")+B4F->B4F_CODREC) == alltrim(B7D->(B7D_FILIAL+B7D_CODREC))

					if(B7D->B7D_OK) //SE O MEDICAMENTO ESTÁ APROVADO

						if BR8->(MsSeek(xFilial("BR8") + B7D->(B7D_CODMED+B7D_CODPAD)))

							 AaDd( ::DadUsrRec, WsClassNew( "SDadRecUsr" ) )
							::DadUsrRec[nI]:CodRec := alltrim(B4F->B4F_CODREC)
							::DadUsrRec[nI]:NomRec := alltrim(B4F->B4F_DESCRI)
							::DadUsrRec[nI]:CodMed := alltrim(B7D->B7D_CODPAD) + "|" + alltrim(B7D->B7D_CODMED) + "|" + alltrim(B7D->B7D_SEQUEN)
							::DadUsrRec[nI]:NomMed := alltrim(BR8->BR8_DESCRI)
							::DadUsrRec[nI]:QtdAut := B7D->B7D_QTDAUT
							::DadUsrRec[nI]:QtdExe := B7D->B7D_QTDEXE
				   			nI++

						endIf

					endIf

					B7D->(dbSkip())

				endDo

			endIf

		endIf

		B4F->(dbSkip())
	endDo

	BR8->(dbCloseArea())
	B7D->(dbCloseArea())
	B4F->(dbCloseArea())
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GrvItReemb³Autor  ³ Karine Riquena Limp   ³ Data ³14.10.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Grava o item do reembolso                                             ³±±
±±³		                                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GrvItReemb WSRECEIVE UserCode, CodSol, ItemReemb, cRecno, MatUsu, CabAlt, RecDivs, OriReemb WSSEND WSNULL WSSERVICE PLSXFUN 

local nI        := 1
local lRetorno := .T.
local aArea	  := GetArea()
local cResult   := ""
local aResult   := {} 
local lBOW   := iif(::CodSol == "0", .T., .F.)
local lB1N   := iif(::cRecno == "0", .T., .F.)

default ::WSNULL := ""
default ::CabAlt := .F.
default ::RecDivs := ""

if PrtChkUser( ::UserCode, "PLSXFUN", "GrvItReemb" )
    aResult := PLSREEMBIT(lBOW, lB1N, ::CodSol, ::ItemReemb, ::cRecno, ::MatUsu, ::CabAlt, ::RecDivs, ::OriReemb) //retorna o protocolo da BOW e o recno da B1N 
 	
 	If VALTYPE(aResult) == "A" 
 	
 		::WSNULL := aResult[1] + "$" + FWJsonSerialize(aResult[2],.F.,.T.) 
 	Else
 		::WSNULL := aResult 
 	EndIf 
else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
endIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PLSPSQVIDA³Autor  ³ Fábio S. dos Santos   ³ Data ³21.09.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Verifica se os beneficiarios inseridos na solicitação já possuem os   ³±±
±±³  opcionais solicitados na base de dados e em vigência                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PLSPSQVIDA WSRECEIVE UserCode, CpfCnpj WSSEND WSNULL WSSERVICE PLSXFUN
Local lRetorno := .T.
Local aArea	:= GetArea()
Default ::WSNULL := ""
If PrtChkUser( ::UserCode, "PLSXFUN", "PLSPSQVIDA" )
	::WSNULL := PLS013VCPF(::CpfCnpj)
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf
RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³IsMedBJE³Autor  ³ Oscar Zanin   ³ Data ³20.10.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³  Verifica se o Serviço foi marcado como Medicamento		               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD IsMedBJE WSRECEIVE UserCode, TipSer WSSEND WSNULL WSSERVICE PLSXFUN

Local lRet	:= .T.
Local aArea	:= GetArea()
Default ::WSNULL := ""

If PrtChkUser( ::UserCode, "PLSXFUN", "IsMedBJE" )
	::WSNULL := PLSBJECHK(::TipSer)
else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do método" )
EndIF

RestArea( aArea )

Return lRet
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o 	³ EditSolic ³Autor  ³ Rodrigo Morgon³      Data ³17/08/2015  	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³        ³ Retorna array com dados de uma solicitação                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD EditSolic WSRECEIVE UserCode, cRecno, lVisualizaProtoc, Chave WSSEND ItensReemb WSSERVICE PLSXFUN

Local lRetorno 		:= .T.
Local aArea	  		:= GetArea()
Local lInsBK6		:= SupergetMV("MV_VRDANRF", .F., .F.)
Local cDtB1N		:= ""
Local nI			:= 1
Local cDescPro	    := ""
Local cIsMed		:= ""
Local aChave		:= {}
Local cDataComp    	:= ""

DEFAULT ::lVisualizaProtoc := .F.
DEFAULT ::Chave := ""
DEFAULT ::cRecno := ""

//Private aDadosSoli 	:= {}

if PrtChkUser( ::UserCode, "PLSXFUN", "EditSolic" )

 	if(!empty(::cRecno))
 	BOW->(DbGoTop())
	BOW->(DbGoTo(Val(::cRecno))) //Posiciona no registro selecionado para edição na tela de consulta.	
	
	if BOW->(BOW_STATUS) == "A" .or. ::lVisualizaProtoc //Permite a edição se o status for "A" (Solicitação não concluída).
		// lVisualizaProtoc = para permitir que o app apresente o detalhe do reembolso pois não cabem todos em uma celula da lista de protocolos  
		// mesmo retornando os dados para o app, a edição só será permitida se o status for A. 
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Dados referentes ao cabeçalho                                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::ItensReemb := WsClassNew( "SEstrReemb" )

		::ItensReemb:CodSol	:= BOW->BOW_PROTOC //Alimenta struct com o codigo da solicitação (protocolo de reembolso).

		//Para recuperar os dados do documento, posicionar no primeiro item do protocolo na B1N
		B1N->(DbSetOrder(1))
		B1N->(DbGoTop())
		B1N->(MsSeek(xFilial("B1N") + BOW->BOW_PROTOC ))

		::ItensReemb:TipDoc	:= AllTrim(B1N->B1N_TIPDOC)
		::ItensReemb:NumDoc 	:= AllTrim(B1N->B1N_NUMDOC)
		
		cDtB1N := DTOS(B1N->B1N_DATDOC)
		::ItensReemb:DtEmis 	:= SubStr(cDtB1N,7,2) + "/" + SubStr(cDtB1N,5,2) + "/" + SubStr(cDtB1N,1,4)

		::ItensReemb:CpfCnpj := B1N->B1N_PRCNPJ
		::ItensReemb:NomePre := B1N->B1N_PRNOME
		::ItensReemb:UF		 := B1N->B1N_EST	
		::ItensReemb:Cidade	 := B1N->B1N_CODMUN
		::ItensReemb:status	 := BOW->BOW_STATUS // agora retorna o status do protocolo para controle de edição no app.

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Dados referentes aos itens da solicitação                               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		::ItensReemb:ListDesp := {}
		while( !B1N->( Eof() ) .AND. B1N->B1N_PROTOC == ::ItensReemb:CodSol)
			aadd(::ItensReemb:ListDesp, WsClassNew( "SItensReemb" ))

			cIsMed := Posicione("BJE", 1, xfilial("BJE") + Alltrim(B1N->B1N_TIPSER), "BJE_ISMEDI")
			::ItensReemb:ListDesp[nI]:CodPro     := AllTrim(B1N->B1N_CODPRO) + "|" + ALLTRIM( Posicione("BR8",1,xFilial("BR8")+B1N->B1N_CODPAD+B1N->B1N_CODPRO,"BR8_DESCRI") )
			::ItensReemb:ListDesp[nI]:VlrPro     := StrTran(StrTran(AllTrim(STRZero(B1N->B1N_VLRTOT,12,2)), ",", ""), ".", ",")
			::ItensReemb:ListDesp[nI]:ValorPago  := StrTran(StrTran(AllTrim(STRZero(B1N->B1N_VLRREE,12,2)), ",", ""), ".", ",")
			::ItensReemb:ListDesp[nI]:ValUnitari := StrTran(StrTran(AllTrim(STRZero(B1N->B1N_VLRAPR,12,2)), ",", ""), ".", ",")
			
			cDataComp := DTOS(B1N->B1N_DATDOC)
			::ItensReemb:ListDesp[nI]:DatComprov := SubStr(cDataComp,7,2) + "/" + SubStr(cDataComp,5,2) + "/" + SubStr(cDataComp,1,4) 
			
			::ItensReemb:ListDesp[nI]:CodPad     := AllTrim(B1N->B1N_CODPAD)
			::ItensReemb:ListDesp[nI]:UsoC       := AllTrim(B1N->B1N_USOCON)
			::ItensReemb:ListDesp[nI]:QtdPro 	 := AllTrim(STR(B1N->B1N_QTDPRO))
			::ItensReemb:ListDesp[nI]:Matric 	 := AllTrim(B1N->B1N_MATRIC)
			::ItensReemb:ListDesp[nI]:CodRec 	 := AllTrim(B1N->B1N_CODREC)
			::ItensReemb:ListDesp[nI]:CodMed 	 := AllTrim(B1N->B1N_CODMED)
			::ItensReemb:ListDesp[nI]:SeqMed 	 := AllTrim(B1N->B1N_SEQMED)
			::ItensReemb:ListDesp[nI]:TipSer 	 := AllTrim(B1N->B1N_TIPSER) + "|" + iif(empty(cIsMed), "0", cIsMed)
			::ItensReemb:ListDesp[nI]:RecNoItem  := AllTrim(STR(B1N->(Recno())))
			::ItensReemb:ListDesp[nI]:StatusIte  := B1N->B1N_IMGSTA 
			B1N->(DbSkip())
			nI++
			cDescPro := ""
		endDo
	else
		//Status diferente de "A" - Solicitação não concluída
		lRetorno := .F.
		SetSoapFault( "", "O status atual da solicitação não permite o uso desta funcionalidade." )
	endif
else

		aChave := Separa(::Chave, "-")
			
			BOW->(DbSetOrder(1))
			BOW->(MsSeek(xFilial("BOW") + alltrim(aChave[1]) ))
			if(BOW->BOW_STATUS == "A" .or. aChave[6] == "V")
			
				::ItensReemb := WsClassNew( "SEstrReemb" )
				::ItensReemb:CodSol	:= BOW->BOW_PROTOC //Alimenta struct com o codigo da solicitação (protocolo de reembolso).
			
				B1N->(DbSetOrder(2))
				if(B1N->(MsSeek(xFilial("B1N") + alltrim(aChave[1]) )))

					::ItensReemb:ListDesp := {}
					::ItensReemb:status	:= BOW->BOW_STATUS // agora retorna o status do protocolo para controle de edição no app.
					
					while( !B1N->( Eof() ) .AND. B1N->B1N_PROTOC == ::ItensReemb:CodSol)
						
						if STRTRAN(B1N->B1N_TIPDOC, " ", "") == aChave[2] .and. ALLTRIM(B1N->B1N_NUMDOC) == aChave[3];
							.and. B1N->B1N_DATDOC == STOD(aChave[4]).and. ALLTRIM(B1N->B1N_PRCNPJ) == aChave[5]
							
							::ItensReemb:TipDoc	:= AllTrim(B1N->B1N_TIPDOC)
							::ItensReemb:NumDoc 	:= AllTrim(B1N->B1N_NUMDOC)
							cDtB1N := DTOS(B1N->B1N_DATDOC)
							::ItensReemb:DtEmis 	:= SubStr(cDtB1N,7,2) + "/" + SubStr(cDtB1N,5,2) + "/" + SubStr(cDtB1N,1,4)
	
							::ItensReemb:CpfCnpj := B1N->B1N_PRCNPJ
							::ItensReemb:NomePre	:= B1N->B1N_PRNOME
							::ItensReemb:UF		:= B1N->B1N_EST	
							::ItensReemb:Cidade	:= B1N->B1N_CODMUN
							
							aadd(::ItensReemb:ListDesp, WsClassNew( "SItensReemb" ))
							//Recupera descrição do procedimento
							BR8->(DbSetOrder(3))//BR8_FILIAL + BR8_CODPSA
							If BR8->(MsSeek(xFilial("BR8") + B1N->(B1N_CODPRO)))
								While xFilial("BR8") + ALLTRIM(B1N->(B1N_CODPRO)) == xFilial("BR8") + ALLTRIM(BR8->(BR8_CODPSA)) .and. Empty(cDescPro)
									If BR8->(BR8_CLASSE) == B1N->(B1N_TIPSER)
										cDescPro	:= AllTrim(BR8->(BR8_DESCRI))
									EndIf
									BR8->(dbSkip())
								EndDo
							EndIf
						
							cIsMed := Posicione("BJE", 1, xfilial("BJE") + Alltrim(B1N->B1N_TIPSER), "BJE_ISMEDI")
							::ItensReemb:ListDesp[nI]:CodPro     := AllTrim(B1N->B1N_CODPRO) + "|" + cDescPro
							::ItensReemb:ListDesp[nI]:VlrPro     := StrTran(StrTran(AllTrim(STRZero(B1N->B1N_VLRTOT,12,2)), ",", ""), ".", ",")
							::ItensReemb:ListDesp[nI]:ValUnitari := StrTran(StrTran(AllTrim(STRZero(B1N->B1N_VLRAPR,12,2)), ",", ""), ".", ",")
							::ItensReemb:ListDesp[nI]:ValorPago  := StrTran(StrTran(AllTrim(STRZero(B1N->B1N_VLRREE,12,2)), ",", ""), ".", ",")
							::ItensReemb:ListDesp[nI]:CodPad     := AllTrim(B1N->B1N_CODPAD)
							::ItensReemb:ListDesp[nI]:UsoC       := AllTrim(B1N->B1N_USOCON)
							::ItensReemb:ListDesp[nI]:QtdPro     := AllTrim(STR(B1N->B1N_QTDPRO))
							::ItensReemb:ListDesp[nI]:Matric     := AllTrim(B1N->B1N_MATRIC)
							::ItensReemb:ListDesp[nI]:CodRec     := AllTrim(B1N->B1N_CODREC)
							::ItensReemb:ListDesp[nI]:CodMed     := AllTrim(B1N->B1N_CODMED)
							::ItensReemb:ListDesp[nI]:SeqMed     := AllTrim(B1N->B1N_SEQMED)
							::ItensReemb:ListDesp[nI]:TipSer     := AllTrim(B1N->B1N_TIPSER) + "|" + iif(empty(cIsMed), "0", cIsMed)
							::ItensReemb:ListDesp[nI]:RecNoItem  := AllTrim(STR(B1N->(Recno())))
							::ItensReemb:ListDesp[nI]:StatusIte  := B1N->B1N_IMGSTA 
							nI++
							cDescPro := ""	
						
						endIf
						
						B1N->(DbSkip())
						
					endDo
				endIf	
			else
				//Status diferente de "A" - Solicitação não concluída
	lRetorno := .F.
				SetSoapFault( "", "O status atual da solicitação não permite o uso desta funcionalidade." )
			endIf			
	endIf
else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
endIf

RestArea(aArea)
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o 	³ VldStatPro³Autor  ³ Rodrigo Morgon³ Data ³17/08/2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³        ³Valida status do protocolo e retorna array com dados do mesmo. ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD VldPrtReem WSRECEIVE UserCode, cRecno WSSEND ItensReemb WSSERVICE PLSXFUN

Local lRetorno 	:= .T.
Local aArea	  	:= GetArea()
Local cResult   	:= ""
Local aReturn		:= {}
Local lInsBK6		:= SupergetMV("MV_VRDANRF", .F., .F.)

default ::WSNULL := ""

if PrtChkUser( ::UserCode, "PLSXFUN", "VldPrtReem" )

 	BOW->(DbGoTop())
	BOW->(DbGoTo(Val(::cRecno))) //Posiciona no registro selecionado para edição na tela de consulta.

	if BOW->(BOW_STATUS) == "A" //Permite a edição se o status for "A" (Solicitação não concluída).
		::ItensReemb := WsClassNew( "SEstrReemb" )

		//Para recuperar os dados do documento, posicionar no primeiro item do protocolo na B1N
		B1N->(DbSetOrder(1))
		B1N->(DbGoTop())
		B1N->(MsSeek(xFilial("B1N") + BOW->BOW_PROTOC ))

		::ItensReemb:TipDoc	:= B1N->B1N_TIPDOC
		::ItensReemb:NumDoc 	:= B1N->B1N_NUMDOC
		::ItensReemb:DtEmis 	:= B1N->B1N_DATDOC

		//Recupera dados da BK6 - Rede não referenciada
		//Caso o parâmetro MV_VRDANRF esteja definido como .T., o ambiente utiliza a validação da BK6 antes da inclusão.
		//Nesse caso, os dados estão disponíveis nos campos B1N_PRCNPJ e B1N_PRNOME da tabela B1N.
		If lInsBK6
			::ItensReemb:CpfCnpj := B1N->B1N_PRCNPJ
			::ItensReemb:NomePre	:= B1N->B1N_PRNOME
		Else
			BK6->(DbSetOrder(3))
			BK6->(DbGoTop())
			BK6->(MsSeek(xFilial("BK6") + B1N->B1N_CODREF))

			::ItensReemb:CpfCnpj := BK6->BK6_CGC
			::ItensReemb:NomePre	:= BK6->BK6_NOME
		EndIf
	else
		//Status diferente de "A" - Solicitação não concluída
		lRetorno := .F.
		SetSoapFault( "", "O status atual da solicitação não permite o uso desta funcionalidade." )
	endif
else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
endIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

//
//
//
WSMETHOD AltStatRee WSRECEIVE UserCode, cRecno, cOpcao WSSEND WSNULL WSSERVICE PLSXFUN

Local lRetorno 	:= .T.
Local nRecno 		:= IIF( ValType(::cRecno) == "C", Val(::cRecno), 0)
Default WSNULL 	:= ""

If PrtChkUser( ::UserCode, "PLSXFUN", "AltStatRee" )

	if nRecno > 0
		if PLSBOWCGST(nRecno, ::cOpcao)
			::WSNULL := "true|"
		else
			::WSNULL := "false|"
		EndIf
	else
		::WSNULL := "false|"
	EndIf

else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do método" )
	::WSNULL := "false|"
EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RDAPro 	³Autor  ³ Roberto Vanderlei     ³ Data ³13.10.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna profisisonal BB0						  		   	   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RDAPro WSRECEIVE UserCode, Crm, Estado, CodSig WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aArea    		:= GetArea()
LOCAL cCodInt 		:= PlsIntPad()
local cNome			:= ""
local cCodigo

DEFAULT ::WSNULL 	:= "true|"
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "RDAPro" )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se prestador esta cadastrado na rede não referenciada		    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	BB0->( DbSetOrder(4) )//BB0_FILIAL+BB0_ESTADO+BB0_NUMCR+BB0_CODSIG+BB0_CODOPE

	If BB0->( MsSeek( xFilial("BB0") + alltrim(::Estado) + ::Crm + Space(TamSx3("BB0_NUMCR")[1] - Len(::Crm)) + alltrim(::CodSig)/*"CRM"*/ + Space(TamSx3("BB0_CODSIG")[1] - 3) + cCodInt ))
		::WSNULL := "true|1|" + BB0->(BB0_CODIGO+"|"+Alltrim(BB0_NOME))
	else
		::WSNULL := "true|0|"
	endif

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GrvRec  ³Autor  ³ Roberto Vanderlei 	     ³ Data ³16.10.15   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Grava Receita.		   									 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

WSMETHOD GrvRec WSRECEIVE UserCode, Protoc, Benef, Crm, Estado, Medico, DtReceita, Medicamento, CodSig WSSEND RetProtocolo WSSERVICE PLSXFUN
LOCAL aArea 	:= GetArea()
LOCAL lRetorno := .T.

If PrtChkUser( ::UserCode , "PLSXFUN","GrvRec" )
	
	B7D->(DbSetOrder(3)) 
	If !B7D->(MsSeek(xFilial("B7D") + ::Protoc + ::Medicamento))
	
		::RetProtocolo := PlsGrvRec(::Protoc, ::Benef, ::Crm, ::Estado, ::Medico, ::DtReceita,::Medicamento, ::CodSig)
	Else
		::RetProtocolo := "false|Este medicamento já foi selecionado"
	EndIf 
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim do metodo														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno          
         
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PlsGrvRec  ³Autor  ³ Roberto Vanderlei    ³ Data ³16.10.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Grava os Dados da Receita B7D - B4F              			   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function PlsGrvRec(cProtoc, cBenef, cCrm, cUf, cMedico, cDtReceita, cMedicamento, cCodSig)

local cProtocItem := ""
local nRecB4F	  := ""
local aIndice     := {} 

default cProtoc := "000000"

if cProtoc == "000000"	
	If TamSX3("B4F_CODREC")[1] > 6 .AND. TamSX3("B7D_CODREC")[1] > 6
		cProtoc	:= P773GERPRO()    
	Else
		cProtoc	:= GetSXENum("B4F", "B4F_CODREC")
		B4F->(ConfirmSX8())
	EndIf
	
	B4F->(RecLock("B4F", .T.))
			B4F->B4F_FILIAL := xFilial("B4F")
			B4F->B4F_CODREC := cProtoc
			B4F->B4F_DESCRI	:= "Receita Nº " + cProtoc + "."
			B4F->B4F_MATRIC := cBenef
			B4F->B4F_CODFAM := SubStr(cBenef, 1, 14)
			B4F->B4F_DTCAD  := Date()
			B4F->B4F_SIGLA	:= cCodSig//"CRM"
			B4F->B4F_ESTSOL := cUf
			B4F->B4F_REGSOL := cCrm
			B4F->B4F_PORTAL := .T.
			B4F->B4F_STATUS := "A"
			B4F->B4F_DATINI := ctod(cDtReceita)
	B4F->B4F_DATFIN := ctod(cDtReceita) + val(GetNewPar("MV_PLSVLDR", "30"))
	B4F->(MsUnlock())

endif

//Gravação dos itens da receita
nRecB4F := B4F->(Recno())

If FindFunction("PLGERSEQE") 

	aadd(aIndice,{"B7D_FILIAL",xFilial("B7D")})
	aadd(aIndice,{"B7D_CODREC",cProtoc})

	cProtocItem := PLGERSEQE("B7D", "B7D_SEQUEN", aIndice) 

Else
	cProtocItem := GetSXENum("B7D", "B7D_SEQUEN")
EndIf 

B7D->(RecLock("B7D", .T.))
B7D->B7D_FILIAL := xFilial("B7D")
B7D->B7D_CODREC := cProtoc
B7D->B7D_SEQUEN := cProtocItem
B7D->B7D_CODMED	:= cMedicamento
B7D->B7D_BENEFI := cBenef
B7D->B7D_QTDAUT := 0
B7D->B7D_QTDEXE := 0
B7D->B7D_DTVINI := ctod(cDtReceita)
B7D->B7D_DTFVAL := ctod(cDtReceita) + val(GetNewPar("MV_PLSVLDR", "30"))
B7D->B7D_CODPAD := PlsBusCla(cMedicamento)
B7D->(MsUnlock())

//	Ponto de Entrada na Inclusão do Medicamento
If ExistBlock("PLGRRCFIM")
	ExecBlock("PLGRRCFIM", .f., .f., {cProtoc})
Endif

Return(cProtoc + "|" + str(nRecB4F))

************************************************
Static Function PlsBusCla(cMedicamento)
	local cClasse  := ""
	local aClasses := {}
	local i
	local cSQL

	cSQL := "SELECT BR8_CODPAD "
	cSQL += "FROM " + RetSQLName("BR8")
	cSQL += " INNER JOIN " + RetSQLName("BJE")
	cSQL += " ON BJE_CODIGO = BR8_CLASSE"
	cSQL += " WHERE BR8_CODPSA = '" + AllTrim(cMedicamento) + Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cMedicamento) ) ) + "'"
	cSQL += " AND " + RetSQLName("BR8")+".D_E_L_E_T_ = '' AND " + RetSQLName("BJE")+".D_E_L_E_T_ = ''"

	OPEN QUERY cSQL ALIAS "TrbRetPad"

	If !TrbRetPad->(EOF())

		While !TrbRetPad->(EOF())
			cClasse := TrbRetPad->BR8_CODPAD
			TrbRetPad->(dbSkip())
		EndDo
	Endif

	CLOSE QUERY "TrbRetPad"

return(cClasse)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetMsgPortal ³Autor  ³  Karine Riquena   ³ Data ³14.08.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Verificar primeiro acesso, caso sim, solicitar atualização.  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetMsgPortal WSRECEIVE UserCode,TpPor,Rotina,CodMsg, Idioma WSSEND WSNULL WSSERVICE PLSXFUN
Local lRet 		     := .T.
Local aMensagensPortal := {}
Local oMsgs := nil
Local cJson := ""
Local nCont := 0
DEFAULT ::WSNULL := ""
DEFAULT ::TpPor  := 0
DEFAULT ::Rotina := ""
DEFAULT ::Idioma := "POR"
DEFAULT ::CodMsg := ""
If PrtChkUser( ::UserCode, "PLSXFUN", "GetMsgPortal" )
    aMensagensPortal := PLSRETMSG(alltrim(STR(::TpPor)), ::CodMsg , ::Idioma, ::Rotina)
    oMsgs := WsClassNew( "SAMsgsPortal" )
    oMsgs:Mensagens  := {}
	for nCont := 1 to len(aMensagensPortal)

		AaDd( oMsgs:Mensagens, WsClassNew( "SMsgPortal" ) )
		oMsgs:Mensagens[nCont]:CodMsg	  := aMensagensPortal[nCont][1]
		oMsgs:Mensagens[nCont]:Mensagem := aMensagensPortal[nCont][2]

	next nCont

	::WSNULL := FWJsonSerialize(oMsgs,.F.,.T.)
Else


	lRet := .F.
	SetSoapFault( "", "Usuário não encontrado.")
EndIf

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ExclResu  ³Autor  ³ Roberto Vanderlei 	 ³ Data ³16.10.15   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Excluir Resumo		   								   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

WSMETHOD ExclResu WSRECEIVE UserCode, Chave WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL aArea 	:= GetArea()
LOCAL lRetorno := .T.
Local aResultado := {}
Local aNumGui
Local cCodOpe
Local cCodLdp
Local cCodPeg
Local cNumero
Local cOriMov := "5"
Local cCodPad_Orig
Local cCodPad
Local cCodPro
PRIVATE aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB",.F.,"87"))
	
If PrtChkUser( ::UserCode , "PLSXFUN","ExclRect" )
	
	aResultado := PlSplitAdvpl(::Chave, "$")
	
	cCodPad_Orig := aResultado[2]
	cCodPro	:= aResultado[3]
	
	cCodPad := AllTrim(PLSVARVINC('87','BR4', cCodPad_Orig))
	cCodPro := AllTrim(PLSVARVINC(cCodPad_Orig,'BR8',cCodPro ,cCodPad+cCodPro,,aTabDup,@CCODPAD))
	
	cCodPro := cCodPro + Space(16 - len(cCodPro))
	
	aResultado[1] := aResultado[1] + ";;"
	
	aNumGui := PlSplitAdvpl(aResultado[1], ";")
	
	cCodOpe := aNumGui[1]
	cCodLdp := aNumGui[2]
	cCodPeg := aNumGui[3]
	cNumero := aNumGui[4]
	
	BD6->(DbSetorder(6))
	If BD6->(msSeek(xFilial("BD6")+cCodOpe+cCodLdp+cCodPeg+cNumero+cOriMov+cCodPad+cCodPro))
		RecLock( "BD6" , .F. )
		DBDelete() 
		BD6->(MsUnLock())
	endif
	
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim do metodo														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ExclRect  ³Autor  ³ Roberto Vanderlei 	 ³ Data ³16.10.15   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Excluir Item receita		   								   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

WSMETHOD ExclRect WSRECEIVE UserCode, Protoc, Medicamento WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL aArea 	:= GetArea()
LOCAL lRetorno := .T.

If PrtChkUser( ::UserCode , "PLSXFUN","ExclRect" )

	B7D->(DbSetOrder(3)) //B7D_FILIAL + B7D_CODREC + B7D_CODMED

	If B7D->( MsSeek( xFilial("B7D")+AllTrim(::Protoc) + Space(TamSX3("B7D_CODREC")[1]-Len( AllTrim(::Protoc))) + AllTrim(::Medicamento) + Space(TamSX3("B7D_CODMED")[1]-Len( AllTrim(::Medicamento)))) ) = .T.
		B7D->(RecLock('B7D',.F.))
		B7D->(DbDelete())
		B7D->(DbSkip())
		B7D->(MsUnlock())
	endif

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim do metodo														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AltRect  ³Autor  ³ Roberto Vanderlei 	 ³ Data ³16.10.15   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Alterar Status Item receita		   						³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

WSMETHOD AltRect WSRECEIVE UserCode, Protoc, Benef WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL aArea 	:= GetArea()
LOCAL lRetorno := .T.

If PrtChkUser( ::UserCode , "PLSXFUN","AltRect" )

	B4F->(DbSetOrder(1)) //B7D_FILIAL + B7D_CODREC + B7D_CODMED

	If B4F->( MsSeek( xFilial("B4F")+AllTrim(::Protoc) + Space(TamSX3("B4F_CODREC")[1]-Len( AllTrim(::Protoc))) + AllTrim(::Benef) + Space(TamSX3("B4F_MATRIC")[1]-Len( AllTrim(::Benef)))) ) = .T.
		B4F->(RecLock('B4F',.F.))
			B4F->B4F_STATUS := "1"
		B4F->(MsUnlock())
	endif

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim do metodo														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

WSMETHOD VerPro WSRECEIVE UserCode, CpfCnpj WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL aArea 	:= GetArea()
LOCAL lRetorno  := .T.

If PrtChkUser( ::UserCode , "PLSXFUN","VerPro" )

	BBA->(DbSetOrder(2)) //B7D_FILIAL + B7D_CODREC + B7D_CODMED

	If BBA->( MsSeek( xFilial("BBA")+AllTrim(::CpfCnpj) + Space(TamSX3("BBA_CPFTIT")[1]-Len( AllTrim(::CpfCnpj))))) = .T.
		if BBA->BBA_TIPSOL = "2" .and. BBA->BBA_TIPMAN = "2" .and. BBA->BBA_STATUS $ "1,2"
			::WSNULL := "S"
		else
			::WSNULL := "N"
		endif
	else
		::WSNULL := "N"
	endif

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim do metodo														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DadTipGui    ³Autor  ³ Thiago Guilherme  ³ Data ³30.11.2015  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³³Retorna os tipos de guia para impressão em branco                      ³±±
±±³																		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DadTipGui WSRECEIVE UserCode WSSEND DadosTipGui WSSERVICE PLSXFUN

LOCAL nI       := 1
LOCAL aArea	   := GetArea()
LOCAL lRetorno := .T.
LOCAL cSQL     :=  ""
LOCAL cTissVer := PLSTISSVER()
Local aSX5		:= {}
Local nJ 		:= 1

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Checa Usuário														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode, "PLSXFUN", "DadTipGui" )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	//³retorna os tipos de guia para impressão em branco					 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	aSX5 := FWGetSX5("PU")
	For nJ := 1 To Len(aSX5)

		If cTissVer >= "3"
		    AaDd( ::DadosTipGui, WsClassNew( "STipGui" ))
		    ::DadosTipGui[nI]:Cod    := aSX5[nJ][3]
		    ::DadosTipGui[nI]:Descri := aSX5[nJ][4]
		    nI++
		Else
			If !ALLTRIM(aSX5[nJ][3]) $ "3,4,5,6,7"
				AaDd( ::DadosTipGui, WsClassNew( "STipGui" ))
		   		::DadosTipGui[nI]:Cod    := aSX5[nJ][3]
		   		::DadosTipGui[nI]:Descri := aSX5[nJ][4]
		   		nI++
			EndIf
		EndIf
	Next nJ	
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AltStBen  ³Autor  ³ Roberto Vanderlei 	 ³ Data ³08.12.15   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Alterar Status Solicitação Alteração Beneficiário  		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

WSMETHOD AltStBen WSRECEIVE UserCode, Chave, Modo WSSEND WSNULL WSSERVICE PLSXFUN

LOCAL aArea 	:= GetArea()
LOCAL lRetorno := .T.

::WSNULL := ""

If PrtChkUser( ::UserCode , "PLSXFUN","AltStBen" )

	BBA->(DbSetOrder(1)) //B7D_FILIAL + B7D_CODREC + B7D_CODMED

	if alltrim(::Modo) = "1"
	If BBA->( MsSeek( xFilial("BBA")+AllTrim(::Chave) + Space(TamSX3("BBA_CODSEQ")[1]-Len( AllTrim(::Chave))))) = .T.
		BBA->(RecLock('BBA',.F.))
			BBA->BBA_STATUS := "2"
		BBA->(MsUnlock())
	endif
	else
		 BBA->(DbGoTo(val(alltrim(::Chave))))
	     BBA->(Reclock("BBA",.F.))
	     	BBA->BBA_STATUS := "2"
	     BBA->(MsUnlock())
	endif
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim do metodo														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PlsTWPGQ 	³Autor  ³ Renan Martins         ³ Data ³06.03.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³INCLUI REGISTROS DE SOLICITAÇÃO DA TABELA DE PREÇOS PELO PRES-±±
±±³          ³TADOR NO PROTAL						  							  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PLSTWPGQ WSRECEIVE UserCode, cCodTb, cCodRDA, cCodLoc, cCodEsp, UsuEmai, PLSCodUsr, Tipo  WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRet 	 	:= .T.
Local lFlagIn		:= .F.
Local aArea		:= GetArea()
DEFAULT ::WSNULL 	:= "true|"

If PrtChkUser( ::UserCode, "PLSXFUN", "PLSTWPGQ" ) //Checa autorização
   ::WSNULL := PLSINB96(::cCodTb, ::cCodRDA, ::cCodLoc, ::cCodEsp, ::UsuEmai, ::PLSCodUsr, ::Tipo)
      Else
		 lRetorno := .F.
		 SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea(aArea)
Return lRet


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PLSRELTB 	³Autor  ³ Renan Martins         ³ Data ³06.03.2014 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna select para Solicitações da tabela B96  		          ±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PLSRELYB WSRECEIVE UserCode, cCodRDA, PLSCodUsr WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRet 	 	:= .T.
Local aArea		:= GetArea()

If PrtChkUser(::UserCode, "PLSXFUN", "PLSRELYB" )
  ::WSNULL := PLSSLB96(::cCodRDA, ::PLSCodUsr)
    Else
	  lRet := .F.
	  SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea(aArea)
Return lRet
//-------------------------------------------------------------------
/*/{Protheus.doc} GetDocCorpoCli
Retorna array com documentos cadastrados para o corpo clínico da RDA.

@author Rodrigo Morgon
@since 28/10/2015
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD GetDocCorpoCli WSRECEIVE UserCode WSSEND Documentos WSSERVICE PLSXFUN

Local lRetorno	:= .T.
Local cCodMot		:= GetNewPar("MV_MOTCORP","")
Local nI			:= 1
Default ::WSNULL	:= ""

If PrtChkUser( ::UserCode, "PLSXFUN", "GetDocCorpoCli" )

	if !Empty(cCodMot)
		::Documentos := {}

		cCodMot := AllTrim(cCodMot)

		B9X->(DbSetOrder(3)) //B9X_FILIAL+B9X_CODINT+B9X_CODMOT+B9X_SEQMOT
		If(B9X->(MsSeek(xFilial("B9X") + PlsIntPad() + cCodMot)))
			While !B9X->(Eof()) .and. B9X->B9X_CODMOT == cCodMot
				aadd(::Documentos, WsClassNew("SDocs")) //Add novo item na lista de documentos

				::Documentos[nI]:DocSeq		:= AllTrim(B9X->B9X_SEQMOT)
				::Documentos[nI]:DocDesc		:= AllTrim(B9X->B9X_DOCMOT)
				::Documentos[nI]:DocObrig	:= AllTrim(B9X->B9X_OBRIG)

				B9X->(dbSkip())
				nI++
			EndDo
		EndIf

		::WSNULL := IIF(len(::Documentos) > 0, "true|", "false|")
	else
		::WSNULL := "false|"
	EndIf
else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do método" )
	::WSNULL := "false|"
EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DADRETBLOQ ³Autor  ³ Oscar Zanin         ³ Data ³04.12.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Carrega combo de locais de Motivos			 	               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD DADRETBLOQ WSRECEIVE UserCode WSSEND DadBloq WSSERVICE PLSXFUN

Local cCodInt := PLSINTPAD()
Local nI		:= 1
Local aArea	:= getArea()
Local lRetorno	:= .T.

If PrtChkUser( ::UserCode ,"PLSXFUN","DADRETBLOQ" )

	B9G->(DbSetOrder(3))
	B9G->(MsSeek(xFilial("B9G")+"2"))
	while (!(B9G->(EoF())) .AND. (B9G->(B9G_TIPMOT) == "2") )
		Aadd(::DadBloq, WsClassNew ( "sDadBloq" ) )
		::DadBloq[nI]:CodBlo := B9G->(B9G_COD) + "~" + B9G->(B9G_MOTBG3)
		::DadBloq[nI]:Descri := B9G->(B9G_MOTIVO)
		nI++
		B9G->(DbSkip())
	EndDo
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RETDOC   ³Autor  ³ Oscar Zanin         ³ Data ³04.12.2015    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Alerta com os documentos. Vai ser no onchange do combo       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RETDOC WSRECEIVE UserCode, CodMot WSSEND WSNULL WSSERVICE PLSXFUN

Local lRetorno	:= .T.
Default ::WSNULL := ""

If PrtChkUser( ::UserCode, "PLSXFUN", "RETDOC" )

	::WSNULL := P977BDOC(::CodMot)

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PREEXCBEN  ³Autor  ³ Oscar Zanin         ³ Data ³04.12.2015  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Pré-gravação da exclusão do beneficiário                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PREEXCBEN WSRECEIVE UserCode, Tp, UsrCod, cRecno, CodMot, VsPlan, CdPlan WSSEND WSNULL WSSERVICE PLSXFUN

Local lRetorno := .T.
Default ::WSNULL := ""

If PrtChkUser( ::UserCode, "PLSXFUN", "PREEXCBEN" )

	::WSNULL := PLXPR997AB(::UsrCod, ::Tp, ::cRecno, ::CodMot, ::VsPlan, ::CdPlan)
else

	lRetorno := .F.
	SetSoapFault("", "Não autorizado a utilização do método")
EndIF

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³POSEXCBEN  ³Autor  ³ Oscar Zanin         ³ Data ³04.12.2015  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ ³Pós-gravação da exclusão do beneficiário (conclusão da solicitação)   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD POSEXCBEN WSRECEIVE UserCode, cRecno, CodMot WSSEND WSNULL WSSERVICE PLSXFUN

Local lRetorno := .T.
Local nRecno	 := Val(::cRecno)
Default ::WSNULL := ""

If PrtChkUser( ::UserCode, "PLSXFUN", "POSEXCBEN" )

	::WSNULL := PLS977ABPS(nRecno, ::CodMot)
else

	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do método")
EndIf

return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PLSRELTB 	³Autor  ³ Renan Martins         ³ Data ³10/2014 ³   ±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna select para Solicitações da tabela B96  		          ±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PLSVERINCDIG WSRECEIVE UserCode, PLSCodUsr WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRet 	 	:= .T.
Local aArea		:= GetArea()

If PrtChkUser(::UserCode, "PLSXFUN", "PLSVERINCDIG" )
	WSNULL := PLSACSINCDIG(::PLSCodUsr)
    Else
	  lRet := .F.
	  SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea(aArea)
Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getDiaRetro ³Autor  ³       ³ Data ³25.11.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Pegar Permissão Digitação de Guia Retroativa e os dias       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GETDIARETRO WSRECEIVE UserCode, RDACode, CodLoc, cUsr, DatGuia WSSEND WSNULL WSSERVICE PLSXFUN
Local lRet 	:= .T.
Local aArea 	:= GetArea()

DEFAULT ::WSNULL := ""

If PrtChkUser( ::UserCode, "PLSXFUN","getDiaRetro" )
	::WSNULL := PLSDIARET(PLSINTPAD(),::RDACode,::CodLoc,::cUsr, ::DatGuia)
Else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRet


//---------------------------------------------------------------------------------------
/*/{Protheus.doc} 	getArqRel
metodo da listagem de arquivos nos relatorios de pagamento PPLRELMOV

@author	Rogério Tabosa
@since		01/2016
@version	P11
/*/

WSMETHOD getArqRel WSRECEIVE userCode, RDACode WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL aArea 	:= getArea()
LOCAL lRetorno	:= .t.
LOCAL cMsg		:= ""
LOCAL nQtdPag 	:= 0
LOCAL nQtdReg 	:= 0
LOCAL nPaginaAtu:= 0
LOCAL nRegPagina:= 20
LOCAL xHeader 	:= "[{name:'Arquivo'},{name:'Tipo'},{name:'Data Geração'},{name:'Download'}]"
LOCAL xCols		:= "[]"
LOCAL nI		:= 0
LOCAL aFiles	:= {}
LOCAL cPathSrv 	:= lower(getMV("MV_RELT"))
LOCAL cTipoRel	:= ""
LOCAL cQtdDiArq	:= SuperGetMv("MV_QTDIARQ",.F.,"0")
LOCAL dDatCut	:= dDataBase - Val(cQtdDiArq)
LOCAL lOk		:= .F.

DEFAULT ::WSNULL 	:= ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//³Se tem direito para executar o metodo
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
if prtChkUser( ::UserCode ,"PLSXFUN","getArqRel" )
	//Busco os arquivos no diretorio
	aFiles := Directory(cPathSrv+'*.rar*')
	aFiles := aSort(aFiles,,, { |x, y| x[3] > y[3] })

	If Len(aFiles) > 0
		xCols := "["
		for nI := 1 to len(aFiles)

			If !("_" + RDACode $ aFiles[nI,1]) .OR. aFiles[nI,3] < dDatCut//Somente arquivos da RDA selecionada e data determinada no parametro
				Loop
			EndIf

			If "RELDAC" $ aFiles[nI,1]
				cTipoRel := "Analise de Contas"
			ElseIf "RELDPM" $ aFiles[nI,1]
				cTipoRel := "Demonstrativo Pagamento"
			ElseIf "RELDPO" $ aFiles[nI,1]
				cTipoRel := "Pagamento Odonto"
			ElseIf "RELEPM" $ aFiles[nI,1]
				cTipoRel := "Extrato de Pagamento"
			ElseIf "RELPLAN" $ aFiles[nI,1]
				cTipoRel := "Planilha de Produção"
			Else
				Loop //cTipoRel := "NI" // Não identificado
			Endif

			lOk := .T.
			xCols += ""
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			//³ Monta acols
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			xCols += "{	0:{field:'FileName', value:'" + aFiles[nI,1] + "'},"
			xCols += "  1:{field:'TipRel', value:'" + cTipoRel +  "'},"
			xCols += "  2:{field:'cData', value:'" + dToc(aFiles[nI,3]) +  "'},"
			xCols += "  3:{field:'Download', value:'0#" + '"' + aFiles[nI,1] + '"' +  "'},"
			xCols += "	4:{field: 'IDENLINHA', value:'" + aFiles[nI,1] + "'} } " + Iif( Len(aFiles) != nI ,",","" )

			nQtdReg ++
		next
		xCols += "]"
	Else
		cMsg 		:= "Não existe registro para esta consulta!"
		::WSNULL 	:= "false|Não existe registro para esta consulta!"
	EndIf
	If !lOk
		cMsg 		:= "Não existe registro para esta consulta!"
		::WSNULL 	:= "false|Não existe registro para esta consulta!" // Retorno
	Else
		// Retorno
		::WSNULL := "true|true|" + cValToChar(nQtdReg) + "|1|" + cValToChar(nRegPagina) + "|" + xHeader + "|" +	xCols + "|" + cMsg + "|true|" + cValToChar(nPaginaAtu) + "||false|"
	EndIf

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )
Return lRetorno

/*/{Protheus.doc} 	BloqReem
metodo que verifica se o usuário está bloqueado, e se a data informada é superior a data de bloqueio

@author	Lucas Nonato
@since		03/2016
@version	P12
/*/

WSMETHOD BloqReem WSRECEIVE UserCode, ItemReemb, DocObrig WSSEND WSNULL WSSERVICE PLSXFUN
local nI        := 1
local lRetorno := .T.
local aRetorno := nil
local cProc	  := ""
local aArea	  := GetArea()
local cResult   := ""
local cNumProt  := ""
default ::WSNULL := ""

if PrtChkUser( ::UserCode, "PLSXFUN", "BloqReem" )
	aRetorno := PLCHKDUPRE(::ItemReemb, ::DocObrig)
	If !aRetorno[1]
		cNumProt := aRetorno[2]
		cProc	  := aRetorno[3]
		::WSNULL := "false|A despesa " + cProc + " já foi solicitada no protocolo " + cNumProt
	ElseIf !PLBLOQREEM(::ItemReemb:Matric, ::ItemReemb:DATDOC)
		::WSNULL := "false|Usuário bloqueado na data " + cValToChar(::ItemReemb:DATDOC)
	Elseif existblock("PLVLDITREE")
		aRetorno	:=  execBlock("PLVLDITREE",.F.,.F.,{ ::ItemReemb })
		if !aRetorno[1]
			::WSNULL := "false|" + aRetorno[2]
		endIf
	endIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
endIf
RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim da Rotina														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³UsoConsDel ³Autor  ³ Karine Riquena Limp   ³ Data ³05.04.2016 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Exclui uma solicitação não concluida  de uso constante        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD UsoConsDel WSRECEIVE UserCode, cRecno, Alias WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aArea    		:= GetArea()
LOCAL nVlrItem		:= 0

If PrtChkUser( "MSALPHA", "PLSXFUN", "UsoConsDel" )

	PLSDELUSOC(::Alias, val(::cRecno))

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno
//-------------------------------------------------------------------
/*/{Protheus.doc} VLDBA1MATEMP
Valida se o número informado na digitação de guias off-line refere-se à matrícula do beneficiário na empresa.
Caso positivo, retorna os dados da carteirinha do mesmo.
Caso negativo, permanece com o número informado e procede para as validações da carteirinha.

@author Rodrigo Morgon
@since 05/05/2016
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD VLDBA1MATEMP WSRECEIVE UserCode, UserCardNumber WSSEND WSNULL WSSERVICE PLSXFUN

Local lRetorno	:= .T.
Default WSNULL	:= ""

If PrtChkUser( ::UserCode, "PLSXFUN", "VLDBA1MATEMP" )
	BA1->(DbSetOrder(6)) //BA1_FILIAL+BA1_MATEMP

	If (BA1->(MsSeek(xFilial("BA1")+::UserCardNumber))) .and. (AllTrim(BA1->BA1_MATEMP) == AllTrim(::UserCardNumber))
		::WSNULL := BA1->BA1_CODINT + BA1->BA1_CODEMP + BA1->BA1_MATRIC + BA1->BA1_TIPREG + BA1->BA1_DIGITO
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do método" )
EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RETMEMOGEN³Autor  ³Karine Riquena Limp    ³ Data ³05.05.2016 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna o conteído memo de um campo posicionando pelo recno  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RETMEMOGEN WSRECEIVE UserCode, cRecno, Alias, Campos WSSEND DadObsProt WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aArea 		:= GetArea()
LOCAL cObs := ""
LOCAL nI := 1
Local cAlias := ::Alias
Local cCampo := ::Campos
If PrtChkUser( ::UserCode, "PLSXFUN", "RETOBSGEN" )

	&(cAlias)->(dbSetOrder(1))
	&(cAlias)->(dbGoto(val(::cRecno)))


	nLines := MLCount( &(cAlias+"->"+cCampo ) )

	For nI := 1 to nLines
		if !(empty(memoLine(&(cAlias+"->"+cCampo ),,nI)))
		 	cObs += alltrim(strTran(strTran(memoLine(&(cAlias+"->"+cCampo ),,nI), chr(10), ""), chr(13),""))
		endIf
	Next nI

	AaDd( ::DadObsProt, WsClassNew( "SRetObsProt" ) )
	::DadObsProt[1]:cMsg  := IIf(EMPTY(cObs), "false|0", "true|"+cObs)
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AltStatusB4F ³Autor  ³ Karine Riquena Limp   ³ Data ³05.04.2016 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Exclui uma solicitação não concluida  de uso constante        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD AltStatusB4F WSRECEIVE UserCode, cRecno, StProc WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aArea    		:= GetArea()

If PrtChkUser( "MSALPHA", "PLSXFUN", "UsoConsDel" )

	begin transaction
		B4F->(dbSelectArea("B4F"))
		B4F->(dbgoto(val(::cRecno)))
		B4F->(Reclock("B4F", .F.))
			B4F->B4F_STATUS := ::StProc
		B4F->(msUnlock())
	end transaction
	::WSNULL := "true|"

Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno


//-------------------------------------------------------------------
/*/{Protheus.doc} AltStTissG
Altera o status da guia para em análise

@author Karine Riquena Limp
@since 20/07/2016
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD AltFlaInt WSRECEIVE UserCode, Chave, Alias, Pendente, Sequen WSSEND WSNULL WSSERVICE PLSXFUN
	local cAliasPai := iif(::Alias == "BE2", "BEA", iif(::Alias == "BEJ" .OR. ::Alias == "BQV", "BE4", "B4A"))
	local lRet := .T.
	local lIntRespo := .F.
	local cSetorAt  := GetNewPar("MV_SETORAT","00")
	local cTipoGuia := ''
	
	If cAliasPai = 'BEA'
		cTipoGuia := '1'
		
	ElseIf cAliasPai = 'BE4'
		cTipoGuia := '2'
		
	else
		cTipoGuia := '3'
	endif
	
	If PrtChkUser( ::UserCode , "PLSXFUN", "AltFlaInt" )
		
		Begin Transaction
			
			BBR->(dbSetOrder(1))
			BBR->(msSeek(xFilial("BBR") + ::Chave)) 
			while (BBR->(!Eof()) .AND. BBR->(BBR_FILIAL+BBR_CODOPE+BBR_ANOAUT+BBR_MESAUT+BBR_NUMAUT) == (xFilial("BBR") + ::Chave)) 
				
				If !BBR->BBR_RESPRE .AND. BBR->BBR_SEQPRO == ::Sequen
				
					BBR->(RecLock("BBR",.F.))
					BBR->BBR_ANEXAD := .T. //ALTERO A FLAG PARA ATUALIZAR TODAS A INTERAÇÕES DO PROCEDIMENTO
					BBR->BBR_TPDIRP := ""
					BBR->(MsUnLock())
				EndIf 

				If BBR->BBR_RESPRE .AND. EMPTY(BBR->BBR_RESPOS) .AND. !lIntRespo
					lIntRespo := .T.
				Endif
				
				BBR->(dbSkip())
			endDo
			
			If lIntRespo
				::WSNULL := "true|Existem interações em aberto que necessitam de uma resposta descritiva.|PENDENDESCRI"
			Else
				::WSNULL := "true|Anexos confirmados!"
				
				if(!(::Pendente))
					if(cAliasPai == "BEA")
						BEA->(DbSetOrder(1))
						If BEA->(MsSeek(xFilial("BEA") + ::Chave))
							BEA->(RecLock("BEA",.F.))
							BEA->BEA_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
							BEA->(MsUnLock())
						EndIf
					elseif(cAliasPai == "BE4")
						BE4->(DbSetOrder(2))
						If BE4->(MsSeek(xFilial("BE4") + ::Chave))
							BE4->(RecLock("BE4",.F.))
							BE4->BE4_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
							BE4->(MsUnLock())
						EndIf
					elseif(cAliasPai == "B4A")
						B4A->(DbSetOrder(1))
						If B4A->(MsSeek(xFilial("B4A") + ::Chave))
							B4A->(RecLock("B4A",.F.))
							B4A->B4A_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
							B4A->(MsUnLock())
						EndIf
					endIf
					::WSNULL += "|STTISS"
					
					B53->(dbSetOrder(1))
					
					If B53->(MsSeek(xFilial('B53') + ::Chave + cTipoGuia))
						B53->(RecLock("B53",.F.))
						B53->B53_CODDEP := cSetorAt
						B53->(MsUnLock())
						
						IF B53->B53_ALIMOV=="B4Q"
							B4Q->(DbSetOrder(1))
							If B4Q->(MsSeek(xFilial("B4Q")+B53->(B53_NUMGUI)))
								B4Q->(RecLock("B4Q",.F.))
								B4Q->B4Q_STTISS := "2" //ALTERO O STATUS TISS PARA "EM ANÁLISE"
								B4Q->(MsUnLock())
							EndIf
							
						Endif
						//Atualizar tabela de Encaminhamento - B71
						If !Empty(cSetorAt)
							
							PLSICB71(B53->B53_ALIMOV, B53->B53_RECMOV, cSetorAt, "Arquivo enviado com sucesso." )
						EndIf
					EndIf
				endIf
			EndIf
			
		End Transaction
		
	Else
		
		lRet := .F.
		SetSoapFault( "", "Não autorizado a utilização do metodo" )
		
	EndIf
	
return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} ATGUIAAAUT
Atualiza guia após autorização

@author Renan Martins
@since 06/2016
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD ATGUIAAAUT	 WSRECEIVE Chave, CmdChave WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 		:= .T.
LOCAL aDados   		:= {}

If PrtChkUser( "MSALPHA", "PLSXFUN", "ATGUIAAAUT" )

	aDados := SEPARA (Chave, '|', .F.)
	aItens := SEPARA(CmdChave, '|', .F.)
	IF PLSPGDRECN (aDados, aItens)
		::WSNULL := "true|"
	ELSE
		::WSNULL := "false|"
	ENDIF
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf


Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getDiaRetro ³Autor  ³       ³ Data ³25.11.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Pegar Permissão Digitação de Guia Retroativa e os dias       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GETDIGP WSRECEIVE UserCode WSSEND WSNULL WSSERVICE PLSXFUN
Local lRet 	:= .T.
Local aArea 	:= GetArea()

DEFAULT ::WSNULL := ""

If PrtChkUser( ::UserCode, "PLSXFUN","GETDIGP" )
	::WSNULL := PLSRETLDP(4)
Else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRet




//-------------------------------------------------------------------
/*/{Protheus.doc} GRVALTOFF
Gravar Alteração OFFLine

@author Roberto Vanderlei
@since 23.06.2016
@version P12
@obs DigiGui para verificar digitação de guias Off-Line e Tipo para verificar se deve ou não finalizar a guia editada.
/*/
//-------------------------------------------------------------------
WSMETHOD GRVALTOFF WSRECEIVE UserCode, CamposAlterados, ItensAlterados, Tipo, RecnoBD5, TableCode, DigiGui, TipoAut WSSEND WSNULL WSSERVICE PLSXFUN
Local lRet 	:= .T.
Local aArea 	:= GetArea()
Local aCriticas			:= {}

local cCritica			:= ""
local cEsp 				:= ""
local nFor
local nItem
local cTpCon
local cTpSai
local cTpDoe
local cTmpDoe
local cTmpDoeC
local cIndAcid
local aTabDup 		:= PlsBusTerDup(SuperGetMv("MV_TISSCAB",.F.,"87"))
local objGuia
local cAtendRN
local aCampoCabec 	:= {}
local aCampoItem 	:= {}
local aCampoTela 	:= {}
local aCamposAlterados  := StrTokArr(::CamposAlterados, ";" )
local aItensAlterados  :=  IIF(ValType(::ItensAlterados) <> "U",StrTokArr(::ItensAlterados, "#"),{})
local cStringItem := ""
local aCampos := {}
local aItens := {}
local aObjProcedimentos := {}
local oCoGuia 			:= CO_Guia():New()
local oObjGuia 			:= nil
local cCodTab  			:= ""
local cCodPro  			:= ""
local nI				:= 0

local dDtExe        := ""
local cHorIniSExe   := ""
local cHorFimSExe   := ""
local cCodPadSExe   := ""
local cCodProSExe   := ""
local cQtdSExe      := ""
local cViaSExe      := ""
local cTecSExe      := ""
local nVlrUniSExe   := ""
local cSequencial   := "0"

local cCodPadOriginal := ""
local cCodProOriginal := ""
local nGuia 			:= 0
local aRetGui		:= {.F.,""}
local lSaveOk := .T.

DEFAULT ::WSNULL := ""
DEFAULT TipoAut		:= "2"	//Sem mudança de fase


If PrtChkUser( ::UserCode, "PLSXFUN","GETCMPALT" )

	//Realiza o tratamento para alteração dos campos do cabeçalho
	for nFor := 1 to len(aCamposAlterados)

		aCampoTela := StrTokArr(aCamposAlterados[nFor], "$")

		if len(aCampoTela) = 1
			aadd(aCampoTela, "")
		endif

		if alltrim(aCampoTela[1]) <> ""
			if ::Tipo == "1"
				Do Case
				   Case aCampoTela[1] == 'cAtendRN'

					  aadd(aCampoCabec, {"BD5_ATERNA", aCampoTela[2]})

				   Case aCampoTela[1]  == 'cObs'
				   	  aadd(aCampoCabec, {"BD5_OBSGUI", Alltrim(aCampoTela[2])})

				   Case aCampoTela[1] == 'cCbosExe'

					  cCbos	 := aCampoTela[2]
				   	  cEsp := SubString(cCbos,1,3)

				   	  aadd(aCampoCabec, {"BD5_CODESP", cEsp})
				   	  aadd(aCampoItem,  {"BD6_CODESP", cEsp})

				   Case aCampoTela[1] == 'cTpCon'

				   	  cTpCon := alltrim(PLSVARVINC('52', nil, aCampoTela[2]) )

				   	  aadd(aCampoCabec, {"BD5_TIPCON", cTpCon})
				   	  aadd(aCampoItem,  {"BD6_TIPCON", cTpCon})

				   Case aCampoTela[1] == 'cProSol' //Verificar Prestador
					  cProExe	 := aCampoTela[2]
				   	  aAdd(aCampoCabec,  {"BD5_CDPFRE", cProExe})
				   	  aAdd(aCampoItem,   {"BD6_CDPFRE", cProExe})

				   Case aCampoTela[1] == 'cTpSai'

				   	  cTpSai := alltrim(PLSVARVINC('39','BEA', aCampoTela[2]))

				   	  aadd(aCampoCabec, {"BD5_TIPSAI", cTpSai})

				   Case aCampoTela[1] == 'cTpDoe'

				   	  aadd(aCampoCabec, {"BD5_TIPDOE", aCampoTela[2]})

				   Case aCampoTela[1] == 'cTmpDoe'

				   	  aadd(aCampoCabec, {"BD5_TPODOE", aCampoTela[2]})

				   Case aCampoTela[1] == 'cTmpDoeC'

				   	  aadd(aCampoCabec, {"BD5_UTPDOE", aCampoTela[2]})

				   Case aCampoTela[1] == 'cIndAcid'

				   	  cIndAcid := alltrim(PLSVARVINC('36', nil, aCampoTela[2]))
				   	  aadd(aCampoCabec, {"BD5_INDACI", cIndAcid})


				   Case aCampoTela[1] == 'cCodPad'

				   	  cCodPad := AllTrim(PLSVARVINC('87','BR4', aCampoTela[2]))
				   	  aadd(aCampoItem, {"BD6_CODPAD", cCodPad})

				   Case aCampoTela[1] == 'cCodPro'

				   	  cCodPad := AllTrim(PLSVARVINC('87','BR4', ::TableCode))

				   	  cCodPro := AllTrim(PLSVARVINC(::TableCode,'BR8',aCampoTela[2] ,::TableCode+aCampoTela[2],,aTabDup,@CCODPAD))

				   	  aadd(aCampoItem, {"BD6_CODPRO", cCodPro})

				   Case aCampoTela[1]  == 'cVlrPro'
				   	  aadd(aCampoItem, {"BD6_VLRAPR", Val(AllTrim(StrTran(aCampoTela[2],",","")))})
					  aadd(aCampoItem, {"BD6_VALORI", Val(AllTrim(StrTran(aCampoTela[2],",","")))})
				EndCase

			elseif ::Tipo == "6"
					Do Case
						Case aCampoTela[1] == 'cAtendRN'

							aadd(aCampoCabec, {"BD5_ATERNA", aCampoTela[2]})

						/*Case aCampoTela[1] == 'dDataIniFat'
							aadd(aCampoCabec, {"BD5_TPODOE", cTmpDoe})
							ctod(HttpPost->dDataIniFat)		//Inicio Faturamento

						Case aCampoTela[1] == 'dDadaFimFat'
							aadd(aCampoCabec, {"BD5_TPODOE", cTmpDoe})
							ctod(HttpPost->dDadaFimFat)		//Fim Faturamento*/
					EndCase

			elseif ::Tipo == "2"
			  	Do Case
				   Case aCampoTela[1] == 'cAtendRN'

				   	  aAdd(aCampoCabec,  {"BD5_ATERNA", aCampoTela[2]})

				   Case aCampoTela[1]  == 'cObs'
				   	  aadd(aCampoCabec, {"BD5_OBSGUI", Alltrim(aCampoTela[2])})

				   Case aCampoTela[1]  == 'cProSol'

				   	  aAdd(aCampoCabec,  {"BD5_CDPFSO", aCampoTela[2] })
				   	  aAdd(aCampoItem,   {"BD6_CDPFSO", aCampoTela[2] })

				   Case aCampoTela[1]  == 'cCodSigSol'

				   	  aAdd(aCampoCabec,  {"BD5_SIGLA", aCampoTela[2] })
				   	  aAdd(aCampoItem,   {"BD6_SIGLA", aCampoTela[2] })

				   Case aCampoTela[1] == 'cNumCrSol'

				   	  aAdd(aCampoCabec,  {"BD5_REGSOL", aCampoTela[2]})
				   	  aAdd(aCampoItem,   {"BD6_REGSOL", aCampoTela[2]})

				   Case aCampoTela[1] == 'cEstSigSol'

				   	  aAdd(aCampoCabec,  {"BD5_ESTSOL", aCampoTela[2]})
				   	  aAdd(aCampoItem,   {"BD6_ESTSOL", aCampoTela[2]})

				   Case aCampoTela[1] == 'cCbosSol'
					  cCbosSol := aCampoTela[2]
				   	  aAdd(aCampoCabec,  {"BD5_ESPSOL", SubString(cCbosSol,1,3)})
				   	  aAdd(aCampoCabec,  {"BD5_CODESP", SubString(cCbosSol,1,3)})
				   	  aAdd(aCampoItem,   {"BD6_CODESP", SubString(cCbosSol,1,3)})

				   Case aCampoTela[1] == 'cCarSolicit'

				   	  aAdd(aCampoCabec,  {"BD5_TIPADM", aCampoTela[2]})

				   Case aCampoTela[1] == 'dDtSolicit'

				   	  aAdd(aCampoCabec,  {"BD5_DATSOL", aCampoTela[2]})

				   Case aCampoTela[1] == 'cIndCliSol'
				  	  nTaman	 := (TamSX3("BD5_INDCLI")[1])
					  cIndCliSol := aCampoTela[2]
				   	  aAdd(aCampoCabec,  {"BD5_INDCLI", SubStr(AllTrim(cIndCliSol),1, nTaman) })
				   	  aAdd(aCampoCabec,  {"BD5_INDCL2", IIF (Len(cIndCliSol) > nTaman, SubStr(cIndCliSol,nTaman+1,Len(cIndCliSol) ), "")})

				   Case aCampoTela[1] == 'cCnesExe'

				   	  aAdd(aCampoCabec,  {"BD5_CNES", aCampoTela[2] })

				   Case aCampoTela[1] == 'cTpAteExe'   //De/Para
					  cTpAteExe := alltrim(PLSVARVINC('50', nil, aCampoTela[2]) )
				   	  aAdd(aCampoCabec,  {"BD5_TIPATE", cTpAteExe})

				   Case aCampoTela[1] == 'cIndAcid'   //De/Para
					  cIndAcid := alltrim(PLSVARVINC('36', nil, aCampoTela[2]) )
				   	  aAdd(aCampoCabec,  {"BD5_INDACI", cIndAcid})

				   Case aCampoTela[1] == 'cTpCon'    //De/Para
					  cTpCon := alltrim(PLSVARVINC('52', nil, aCampoTela[2]) )
				   	  aAdd(aCampoCabec,  {"BD5_TIPCON", cTpCon})
				   	  aAdd(aCampoItem,   {"BD6_ESTSOL", cTpCon})

				   Case aCampoTela[1] == 'cTpSai'    //De/Para
					  cTpSai := alltrim( PLSVARVINC('39', nil, aCampoTela[2]) )
				   	  aAdd(aCampoCabec,  {"BD5_TIPSAI", cTpSai})

				   Case aCampoTela[1] == 'cTpDoe'

					  aadd(aCampoCabec, {"BD5_TIPDOE", aCampoTela[2]})

				   Case aCampoTela[1] == 'cTmpDoe'

				  	  aadd(aCampoCabec, {"BD5_TPODOE", aCampoTela[2]})

			       Case aCampoTela[1] == 'cTmpDoeC'

			      	  aadd(aCampoCabec, {"BD5_UTPDOE", aCampoTela[2]})

			       Case aCampoTela[1] == 'cNumInt'
			      	  cNumInt	 := aCampoTela[2]
			      	  aadd(aCampoCabec, {"BD5_NRLBOR", cNumInt})
			      	  aadd(aCampoItem,  {"BD6_NRLBOR", cNumInt})
		        EndCase
			endif
		endif
	next

	objGuia := CO_Guia():New()
	aRetGui := objGuia:altGuia(aCampoCabec, aCampoItem, ::RecnoBD5)
	lSaveOk := aRetGui[1]
	//-------------------------------------------------------------------
	// Realiza o tratamento para alteração dos campos da grid de itens
	//-------------------------------------------------------------------
	for nItem := 1 to len(aItensAlterados)
		cStringItem := aItensAlterados[nItem]
		aCampos     := StrTokArr(cStringItem, ";" )

		if StrTokArr(aCampos[1], "$")[2] == "A"
			//-----------------------------------------------
			// ALTERACAO
			//-----------------------------------------------
			aCmpOrg  := retCmpIte(cStringItem, ::TableCode, aTabDup)
			aRetGui := oCoGuia:altItem(aCmpOrg, ::RecnoBD5)
			lSaveOk := aRetGui[1]

		else
			//-----------------------------------------------
			// INCLUSAO
			//-----------------------------------------------
			if StrTokArr(aCampos[1], "$")[2] == "I"

				if len(StrTokArr(aCampos[2], "$")) > 1
					dDtExe         := StrTokArr(aCampos[2], "$")[2]
				endif

				if len(StrTokArr(aCampos[3], "$")) > 1
					cHorIniSExe    := StrTokArr(aCampos[3], "$")[2]
				endif

				if len(StrTokArr(aCampos[4], "$")) > 1
					cHorFimSExe    := StrTokArr(aCampos[4], "$")[2]
				endif

				if len(StrTokArr(aCampos[5], "$")) > 1
					cCodPadSExe    := StrTokArr(aCampos[5], "$")[2]
				endif

				if len(StrTokArr(aCampos[6], "$")) > 1
					cCodProSExe    := StrTokArr(aCampos[6], "$")[2]
				endif

				if len(StrTokArr(aCampos[7], "$")) > 1
					cQtdSExe       := StrTokArr(aCampos[7], "$")[2]
				endif

				if len(StrTokArr(aCampos[8], "$")) > 1
					cViaSExe       := StrTokArr(aCampos[8], "$")[2]
				endif

				if len(StrTokArr(aCampos[9], "$")) > 1
					cTecSExe       := StrTokArr(aCampos[9], "$")[2]
				endif

				if len(StrTokArr(aCampos[10], "$")) > 1
					nVlrUniSExe    := StrTokArr(aCampos[10], "$")[2]
				endif

				/*if len(StrTokArr(aCampos[11], "$")) > 1
					cSequencial    := StrTokArr(aCampos[11], "$")[2]
				endif*/

				oObjGuia := oCoGuia:loadGuiaRecno(val(::RecnoBD5), .F., .T.)

				for nGuia  := 1 to len(oObjGuia:getProcedimentos())
					if nGuia = 1
						cSequencial := strzero(val(oObjGuia:getProcedimentos()[nGuia]:getSeqMov()) + 1, 3)
					else
						if val(oObjGuia:getProcedimentos()[nGuia]:getSeqMov()) >= val(cSequencial)
							cSequencial := strzero(val(oObjGuia:getProcedimentos()[nGuia]:getSeqMov()) + 1, 3)
						endif
					endif
				next

				mntaIte(dDtExe, cHorIniSExe, cHorFimSExe, cCodPadSExe, cCodProSExe, cQtdSExe, cViaSExe, cTecSExe, nVlrUniSExe, cSequencial, aItens)

				aObjProcedimentos:= oCoGuia:getLstProcedimentos(oObjGuia:getDadBenef():getMatric(), aItens, oObjGuia)

				aRetGui := oCoGuia:incIteGuia(oObjGuia, aObjProcedimentos, .F.)
				lSaveOk := aRetGui[1]

			else
				//-----------------------------------------------
				// EXCLUSAO
				//-----------------------------------------------
				if StrTokArr(aCampos[1], "$")[2] == "E"

					cCodPadOriginal := AllTrim(PLSVARVINC('87','BR4', StrTokArr(aCampos[3], "$")[2]))
					cCodProOriginal := AllTrim(PLSVARVINC(StrTokArr(aCampos[3], "$")[2],'BR8',StrTokArr(aCampos[2], "$")[2] ,StrTokArr(aCampos[3], "$")[2]+StrTokArr(aCampos[2], "$")[2],,aTabDup,@cCodPadOriginal))

					aRetGui := oCoGuia:excIteGuia(cCodPadOriginal, cCodProOriginal, ::RecnoBD5)
					lSaveOk := aRetGui[1]
				endif
			endif
		endif
	next

	IF (::TipoAut == "1")
		aCriticas := PLSMDFSGDIG (::RecnoBD5, ::TipoAut)

		IF !aCriticas[1]
			cCritica := "<br>Foram encontradas críticas no processamento: <br>"
			For nI := 3  TO Len(aCriticas)
				If (aCriticas[nI,1,1] <> "")
					aRet := PLSRETCRI( AllTrim( aCriticas[nI,1,1]))

					If EMPTY(aRet[1][2])
						aRet[1][1] := aCriticas[nI][1][1]
						aRet[1][2] := aCriticas[nI][1][2]
					EndIf

				ENDIF
				cCritica += "Procedimento: <br>"+ aCriticas[nI,1,7] + " -- Cód. Glosa: " + aRet[1,1] + " -- " + PadR( AllTrim(aRet[1,2]),75 ) + "<br>"
			NEXT
			cCritica := "|-|"+cCritica
		ENDIF
	ENDIF

Else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

::WSNULL := IIF(lSaveOk,aRetGui[2]+cCritica,"")

RestArea( aArea )

Return lRet

function retCmpIte(cStringItem, cTableCode, aTabDup)
	local nFor
	local cCampo
	local cValor
	local cCodPad
	local cCodPro
	local cTecUti
	local aCampos  := StrTokArr(cStringItem, ";" )
	local aRetorno := {}
	local cCodPadOriginal := ""
	local cCodProOriginal := ""


	cCodPadOriginal := AllTrim(PLSVARVINC('87','BR4', StrTokArr(aCampos[3], "$")[2]))
	cCodProOriginal := AllTrim(PLSVARVINC(StrTokArr(aCampos[3], "$")[2],'BR8',StrTokArr(aCampos[2], "$")[2] ,StrTokArr(aCampos[3], "$")[2]+StrTokArr(aCampos[2], "$")[2],,aTabDup,@cCodPadOriginal))

	aadd(aRetorno, {"PROCED", cCodProOriginal })
	aadd(aRetorno, {"TAB", cCodPadOriginal })

	for nFor := 1 to len(aCampos)
	 	if nFor > 3 //Despreza o Tipo Código proc original e Código Tab Original
			cCampo := StrTokArr(aCampos[nFor], "$")[1]
			cValor := Iif(Len(StrTokArr(aCampos[nFor], "$")) > 1,StrTokArr(aCampos[nFor], "$")[2],"")

			Do Case
				Case cCampo == 'dDtExe'
					aadd(aRetorno,  {"BD6_DATPRO", ctod(cValor)})

				Case cCampo == 'cHorIniSExe'
					aadd(aRetorno,  {"BD6_HORPRO", cValor})

				Case cCampo == 'cHorFimSExe'
					aadd(aRetorno,  {"BD6_HORFIM", StrTran(cValor,":","")}) //Tratamento para retirar o ":" da hora, pois o tamanho do campo é 4.

				Case cCampo == 'cCodPadSExe'

					cCodPad := AllTrim(PLSVARVINC('87','BR4', cValor))
				   	aadd(aRetorno, {"BD6_CODPAD", cCodPad})

				Case cCampo == 'cCodProSExe'

					cCodPad := AllTrim(PLSVARVINC('87','BR4', cTableCode))
				   	cCodPro := AllTrim(PLSVARVINC(cTableCode,'BR8',cValor ,cTableCode+cValor,,aTabDup,@CCODPAD))

				   	aadd(aRetorno, {"BD6_CODPRO", cCodPro})

				Case cCampo == 'cDesProSExe'
					aadd(aRetorno,  {"BD6_DESPRO", left(alltrim(cValor), TamSx3("BD6_DESPRO")[1]) })

				Case cCampo == 'cQtdSExe'
					aadd(aRetorno,  {"BD6_QTDSOL", val(alltrim(cValor))})
					aadd(aRetorno,  {"BD6_QTDPRO", val(alltrim(cValor))})

				Case cCampo == 'cViaSExe'
				
					aadd(aRetorno,  {"BD6_VIA", cValor})
					aadd(aRetorno,  {"BD6_PERVIA", plRtPerV(cValor)})

				Case cCampo == 'cTecSExe' //Verificar

					cTecUti := alltrim(PLSVARVINC('48', nil, cValor) )
					aadd(aRetorno,  {"BD6_TECUTI", cTecUti})

				Case cCampo == 'nVlrUniSExe'
					aadd(aRetorno,  {"BD6_VLRAPR", val(cValor)})

			endcase
		endif
	next

return aRetorno

function mntaIte(dDtExe, cHorIniSExe, cHorFimSExe, cCodPadSExe, cCodProSExe, cQtdSExe, cViaSExe, cTecSExe, nVlrUniSExe, cSequencial, aItens)

local cCodPro
local cCodPad
local aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB",.F.,"87"))
local cTecUti

cCodPad  := AllTrim(PLSVARVINC('87','BR4', cCodPadSExe))
cCodPro  := AllTrim(PLSVARVINC(cCodPadSExe,'BR8',cCodProSExe,cCodPadSExe+cCodProSExe,,aTabDup,@CCODPAD))

cTecUti := alltrim(PLSVARVINC('48', nil, cTecSExe) )

AaDd( aItens, {{ "SEQMOV", strzero(val(cSequencial), 3)},;
			   { "CODPRO", cCodPro },;
			   { "CODPAD", cCodPad },;
			   { "QTD"	 , VAL(cQtdSExe) },;
			   { "QTDAUT", VAL(cQtdSExe) },;
			   { "VLRAPR", VAL(nVlrUniSExe) },;
			   { "HORINI", cHorIniSExe },;
			   { "HORFIM", strTran(cHorFimSExe,":","")},;
			   { "VIAAC",  cViaSExe },;
			   { "TECUT",  cTecUti },;
			   { "STPROC", "" } ,;
			   { "SLVPRO", "" } ,;
			   { "SLVPAD", "" } ,;
			   { "STPROC", "" } ,;
			   { "DATPRO", CTOD(dDtExe) } } )

return


//-------------------------------------------------------------------
/*/{Protheus.doc} RETCRIMF
Retorna as críticas para o usuário

@author Renan Martins
@since 06/2016
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD RETCRIMF WSRECEIVE UserCode, Chave WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 	:= .T.
LOCAL aCrit		:= {}
LOCAL ctexto	:= ""
LOCAL nI		:= 0

IF PrtChkUser( ::UserCode, "PLSXFUN", "RETCRIMF" )

	aCrit := PLSMFCRITP(::Chave)
	IF len(aCrit) > 0
	cTexto +="<div width: 30px; height: 30px; overflow-y: scroll;>"
	cTexto += '<table border = 1 bordercolor=#DDDDDD>'
		For nI := 1 TO Len(aCrit)
			//cTexto += "<li>Procedimento: "+ aCrit[nI,1] + " --- Código Glosa: " + aCrit[nI,2,1,1] + " ---  Descrição: " + aCrit[nI,2,1,2] + "</li>"
			cCor := IIF((nI%2 == 0), '#E8F6F8', '#F7FCFC')
			cTexto += '<tr BGCOLOR='+cCor+'>'
			cTexto += "<td><strong>Procedimento:</strong> "+ Alltrim(aCrit[nI,1]) + "<br><strong>Motivo:</strong> " + aCrit[nI,2,1,1] + "<br><strong>Descrição:</strong> " + aCrit[nI,2,1,2] + "</td>"
			cTexto += '</tr>'
		Next
	 cTexto+= '</table>'
	 cTexto+= '</div>'
	ELSE
		cTexto += "Glosas não encontradas"
	ENDIF
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

::WSNULL := cTexto
Return lRetorno


//-------------------------------------------------------------------
/*/{Protheus.doc} RETCRIAUT
Retorna as críticas para o beneficiário

@author Renan Martins
@since 06/2016
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD RETCRIAUT WSRECEIVE UserCode, Chave WSSEND WSNULL WSSERVICE PLSXFUN
LOCAL lRetorno 	:= .T.
LOCAL aCrit		:= {}
LOCAL ctexto	:= ""
LOCAL nI		:= 0

IF PrtChkUser( ::UserCode, "PLSXFUN", "RETCRIAUT" )

	aCrit := PLSCRIBNF(::Chave)
	IF len(aCrit) > 0
	cTexto +="<div width: 30px; height: 30px; overflow-y: scroll;>"
	cTexto += '<table border = 1 bordercolor=#DDDDDD>'
		For nI := 1 TO Len(aCrit)
			cCor := IIF((nI%2 == 0), '#E8F6F8', '#F7FCFC')
			cTexto += '<tr BGCOLOR='+cCor+'>'
			cTexto += "<td><strong>Motivo:</strong> " + aCrit[nI,1,1,1] + " ---  <strong>Descrição:</strong> " + aCrit[nI,1,1,2] + "</td>"
			cTexto += '</tr>'
		Next
	 cTexto+= '</table>'
	 cTexto+= '</div>'
	ELSE
		cTexto += "Glosas não encontradas"
	ENDIF
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

::WSNULL := cTexto
Return lRetorno


//-------------------------------------------------------------------
/*/{Protheus.doc} VBlqBen
Verifica se o beneficiário está bloqueado
@author Oscar Zanin
@since 08/2016
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD VBlqBen WSRECEIVE UserCode, Benef, DataString WSSEND WSNULL WSSERVICE PLSXFUN

Local lRetorno := .T.
Local cChave	:= Left(::Benef, 14)
Local cTipReg	:= SubStr(::Benef, 15, 2)
Local dData	:= CtoD(::DataString)
Local aAreaBA1	:= BA1->(GetArea())
//BA1_FILIAL+BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO                                                                             
BA1->(DbSetOrder(2))
BA1->(MsSeek(xFilial("BA1") + ::Benef))

IF PrtChkUser( ::UserCode, "PLSXFUN", "VBlqBen" )

	If dData > dDataBase
		::WSNULL := "false|Data de Atendimento inserida é maior que a data atual!"
	ElseIf dData < BA1->BA1_DATINC
		::WSNULL = "false|Data de Atendimento anterior à data de inclusão do Beneficiário!"
	ElseIf PlChHiBlo("BCA",dData,cChave,cTipReg) .AND. !(PLSPACINT(::Benef,dData)) //Também tem que ver se está internado
		::WSNULL := "false|Usuário bloqueado na data informada!"
	else
		::WSNULL := "true|Ok"
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea(aAreaBA1)

Return lRetorno


//---------------------------------------------------------------------------------------
/*/{Protheus.doc} getNumProtoc
WS que retorna o número do protocolo de atendimento.

@author	Lucas Nonato
@since		08/08/2016
@version	P11


/*/
//---------------------------------------------------------------------------------------

wsMethod getNumProtoc wsReceive userCode wsSend NumProtoc wsService PLSXFUN
Local lRet := .T.
If prtChkUser( ::UserCode ,"PLSXFUN","getNumProtoc" )

	::NumProtoc := P773GerPro("")
	If Empty(::NumProtoc)
		lRet := .F.
	EndIF
EndIF

Return lRet

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} VldNumProtoc
WS que valida o número do protocolo de atendimento, somente quando for intercambio

@author	Lucas Nonato
@since		08/08/2016
@version	P11

/*/
//---------------------------------------------------------------------------------------

wsMethod VldNumProtoc wsReceive userCode,NumProtoc,MatUsu wsSend CritProtoc wsService PLSXFUN
Local lRet 	:= .T.
Local aResult	:= {}

If prtChkUser( ::UserCode ,"PLSXFUN","VldNumProtoc" )
	aResult := PLVldProtInt(::MatUsu,::NumProtoc)
	If !aResult[1]
		::CritProtoc 	:= AllTrim(aResult[2])
	Else
		::CritProtoc :=	""
	EndIf

EndIf

Return lRet

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} Protocolo
WS que faz a comunicação com a Unimed Origem para pegar o número do protocolo

@author	Lucas Nonato
@since		08/08/2016
@version	P11

/*/
//---------------------------------------------------------------------------------------

wsMethod Protocolo wsReceive UserCode,DDD,Telefone,ProtAnt,Sentimento,TxtLivre,Matric wsSend WSNULL wsService PLSXFUN
Local lRet 	:= .T.
Local aResult	:= {}
Local aDados	:= {::DDD,::Telefone,::ProtAnt,::Sentimento,::TxtLivre}

If prtChkUser( ::UserCode ,"PLSXFUN","Protocolo" )
	aResult := PL773WEBRN("",::Matric,,,,.T.,aDados)
	If aResult[1]
		::WSNULL := "true|" + aResult[3]
	Else
		::WSNULL := "false|[" + aResult[2][1][1] +"] " + aResult[2][1][2]
	EndIf
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} VlDtFut
Verifica se a data não é futura (servidor)
@author Oscar Zanin
@since 08/2016
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD VlDtFut WSRECEIVE UserCode, DataString WSSEND WSNULL WSSERVICE PLSXFUN

Local lRetorno := .T.
Local dData	:= CtoD(::DataString)

IF PrtChkUser( ::UserCode, "PLSXFUN", "VlDtFut" )

	If dData > dDataBase
		::WSNULL := "false|Data de Atendimento inserida é maior que a data atual!"

	else
		::WSNULL := "true|Ok"
	EndIf
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

Return lRetorno

//-------------------------------------------------------------------
/*/{Protheus.doc} UpdB1N

@author Karine Riquena Limp
@since 28/09/2016
@version P12
@description Atualiza todas os itens da B1N quando altera o cabeçalho 
               no reembolso
/*/
//-------------------------------------------------------------------
WSMETHOD UpdB1N WSRECEIVE UserCode, CodSol, CPFCNPJ, NomRdaNRef, Tipo, NumDoc, DocEmi WSSEND WSNULL WSSERVICE PLSXFUN

Local lRetorno := .T.

IF PrtChkUser( ::UserCode, "PLSXFUN", "UpdB1N" )
	PLSUPDB1N(::CodSol, ::CPFCNPJ, ::NomRdaNRef, ::Tipo, ::NumDoc, ctod(::DocEmi))
	::WSNULL := "true|Ok"
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getDiaRetro ³Autor  ³ Geraldo Félix Júnior³ Data ³25.11.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna uma lista de procedimento com base no tipo de serviço do reembolso online
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetReembProc WSRECEIVE UserCode, TipSer, Pesquisa WSSEND StMPctIteGui WSSERVICE PLSXFUN
Local lRet 	:= .T.
Local aArea 	:= GetArea()
LOCAL cSql 	:= ""
LOCAL cTipSer	:= ::TipSer
LOCAL cDesPro := ::Pesquisa
LOCAL nCnt := 0

If !PrtChkUser( ::UserCode, "PLSXFUN","GetReembProc" )
	RestArea( aArea )
	lRet := .F.	
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

If Empty(cTipSer)
	RestArea( aArea )
	lRet := .F.	
	SetSoapFault( "", "Tipo de serviço não informado" )
Endif

If lRet
	cSql := "SELECT BR8_CODPAD, BR8_CODPSA, BR8_DESCRI FROM "+RetSqlName("BR8")+" BR8 WHERE BR8_FILIAL = '"+xFilial("BR8")+"' "
	cSql += "AND BR8_CLASSE = '"+cTipSer+"' "
	cSql += "AND BR8_EXPBEN = '1' "
	cSql += "AND D_E_L_E_T_ = '' "
	If !Empty(cDesPro) 
		cSql += "AND BR8_DESCRI LIKE '%"+Alltrim(Upper(cDesPro))+"%' "
	Endif
	cSql += "ORDER BY BR8_DESCRI "
	cSql := ChangeQuery(cSql)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql),"TRB1",.T.,.F.)
	
	If !TRB1->( Eof() )
		::StMPctIteGui := {}
		
		While !TRB1->( Eof() )
			nCnt ++
			
			// Limita 30 registros. O aplicativo vai emitir alerta para refinar a busca quando houver mais de 30 itens. 
			If nCnt > 30
				Exit
			Endif
			
			AaDd( ::StMPctIteGui, WsClassNew( "MPctIteGui" ) )
					
			::StMPctIteGui[nCnt]:CodPad			:= TRB1->BR8_CODPAD
			::StMPctIteGui[nCnt]:CodPro			:= TRB1->BR8_CODPSA
			::StMPctIteGui[nCnt]:DesPro			:= Alltrim(TRB1->BR8_DESCRI)
		
			TRB1->( dbSkip() )
		Enddo	
	Else
		lRet := .f.
		setSoapFault( "", "Não existem procedimentos para o tipo de serviço informado." )
	EndIf

	TRB1->( dbCloseArea() )
Endif

Return lRet 

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getDiaRetro ³Autor  ³ Geraldo Félix Júnior³ Data ³25.11.2015 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna uma lista de procedimento com base no tipo de serviço do reembolso online
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD PesqReembProc WSRECEIVE UserCode, TipSer, cCodPro WSSEND StMPctIteGui WSSERVICE PLSXFUN
Local lRet 	:= .T.
Local aArea 	:= GetArea()
LOCAL cSql 	:= ""
LOCAL cTipSer	:= ::TipSer
LOCAL cCodPro := ::cCodPro
//LOCAL cCodPad := ::cCodTb

LOCAL nCnt := 0

If !PrtChkUser( ::UserCode, "PLSXFUN","PesqReembProc" )
	RestArea( aArea )
	lRet := .F.	
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

If Empty(cTipSer)
	RestArea( aArea )
	lRet := .F.	
	SetSoapFault( "", "Tipo de serviço não informado" )
Endif

If Empty(cCodPro)
	RestArea( aArea )
	lRet := .F.	
	SetSoapFault( "","Código do procedimento não informado" )
Endif

If lRet
	cSql := "SELECT * FROM "+RetSqlName("BR8")+" BR8 WHERE BR8_FILIAL = '"+xFilial("BR8")+"' "
	cSql += "AND BR8_CLASSE = '"+cTipSer+"' "
	cSql += "AND BR8_EXPBEN = '1' "
	cSql += "AND BR8_CODPSA = '"+cCodPro+"' "
	cSql += "AND D_E_L_E_T_ = '' " 
	cSql := ChangeQuery(cSql)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql),"TRB1",.T.,.F.)
	
	::StMPctIteGui := {}
	If !TRB1->( Eof() )
		Aadd(::StMPctIteGui, WsClassNew( "MPctIteGui" ))	
		::StMPctIteGui[1]:CodPad			:= TRB1->BR8_CODPAD
		::StMPctIteGui[1]:CodPro			:= TRB1->BR8_CODPSA
		::StMPctIteGui[1]:DesPro			:= Alltrim(TRB1->BR8_DESCRI)		
	Else
		lRet := .f.
		setSoapFault( "", "Produto não localizado." )
	EndIf
	
	TRB1->( dbCloseArea() )
Endif

Return lRet 

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RetCarVirt ³Autor  ³ Totvs   ³ Data ³05.04.2016 				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Exclui uma solicitação não concluida  de uso constante        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD RetCarVirt WSRECEIVE UserCode,lista_de_cartoes  WSSEND ret_cartao_virtual WSSERVICE PLSXFUN
 
LOCAL cSql 		:= ""
LOCAL cCodInt		:= ""
LOCAL cCodEmp   	:= ""
LOCAL cMatric		:= ""
LOCAL cTipReg		:= ""
LOCAL cDigito		:= ""

local cCodPla		:= ""
LOCAL cVerPla 	:= ""
LOCAL cDesPla		:= ""

LOCAL nCnt			:= 0
LOCAL lFoundGBH	:= .F.
LOCAL cTelefone	:= ""

LOCAL cTitular 			:= GetNewPar("MV_PLCDTIT", "T")
LOCAL aRetRede			:= {}

LOCAL cOpcional			:= ""
LOCAL cRetObs				:= ""
LOCAL oObjBackup			:= nil
LOCAL aAux					:= {}

LOCAL cMatTit	    		:= ""
LOCAL nNomTit				:= ""
LOCAL aEndTitular			:= {}
LOCAL lExistTitular		:= .F.
LOCAL cMatric 			:= ""
LOCAL cTipUsr 			:= ""
LOCAL aUsr					:= {}
LOCAL cLogUsr				:= ::lista_de_cartoes:cLogin
LOCAL nCount				:= 0
local lMSCVOPC := Existblock("MSCVOPC")
local lMSCVREDE := Existblock("MSCVREDE")
local lMSLOGFIM := Existblock("MSLOGFIM")

// Validação de usuário
If !PrtChkUser( ::UserCode, "PLSXFUN", "RetCarVirt" )
	SetSoapFault( "", "Não autorizado a utilização do método" )
	
	Return .f.
EndIf
// Inicializa o objeto.
::ret_cartao_virtual := WsClassNew( "st_cartao_virtual" )	
::ret_cartao_virtual:retorno_dados 		:= {}
::ret_cartao_virtual:mensagem			 	:= ""
 
lExistTitular := .F.
For nCnt := 1 to len (::lista_de_cartoes:cart_usuarios)
	// Cria uma matriz mais simples de usar
	Aadd(aUsr, {	::lista_de_cartoes:cart_usuarios[nCnt]:mat_usuario,; 
				 	::lista_de_cartoes:cart_usuarios[nCnt]:tip_usuario})		
		
	// Verifica se o titular está presente na lista de usuários 
	If ::lista_de_cartoes:cart_usuarios[nCnt]:tip_usuario == cTitular 
		lExistTitular := .T.
				
		cMatTit := ::lista_de_cartoes:cart_usuarios[nCnt]:mat_usuario
	Endif	
Next

If Len(aUsr) == 0
	::ret_cartao_virtual:retorno_status 	:= .F.
	::ret_cartao_virtual:mensagem			:= "Inconsistencias no cadastro. Lista vazia."
	
	Return .T.
Endif

// Ordena o array 
Asort(aUsr,,, {|x, y| x[1] < y[1]})

// Posiciona familia do usuário
BA3->(DbSetOrder(1))
If !BA3->(MsSeek(xFilial("BA3")+SubStr(aUsr[1][1],1,14)))
	::ret_cartao_virtual:retorno_status 	:= .F.
	::ret_cartao_virtual:mensagem			:= "Inconsistencias no cadastro. Familia não existe"
	
	Return .T.
Endif

If !BG9->( dbSeek(xFilial("BG9")+BA1->BA1_CODINT+BA1->BA1_CODEMP) )
	::ret_cartao_virtual:retorno_status 	:= .F.
	::ret_cartao_virtual:mensagem			:= "Inconsistencias no cadastro. Empresa não existe"
	
	Return .T.
Endif

If !BQC->(dbSeek(xFilial("BQC")+BA3->BA3_CODINT+BA3->BA3_CODEMP+BA3->BA3_CONEMP+BA3->BA3_VERCON+BA3->BA3_SUBCON+BA3->BA3_VERSUB))
	::ret_cartao_virtual:retorno_status 	:= .F.
	::ret_cartao_virtual:mensagem			:= "Inconsistencias no cadastro. Sub não existe"
	
	Return .T.
Endif
																			
If lExistTitular 
	// Se o titular estiver presente na lista de usuários, armazena os dados dele. 
	BA1->( dbSetorder(02) )
	BA1->( dbSeek(xFilial("BA1")+cMatTit) )	 
	cNomTit := Alltrim(BA1->BA1_NOMUSR)	
	aEndTitular :={BA1->BA1_ENDERE,;
						BA1->BA1_NR_END,;
						BA1->BA1_COMEND,;
						BA1->BA1_BAIRRO,;
						BA1->BA1_MUNICI,;
						BA1->BA1_ESTADO,;
						BA1->BA1_CEPUSR}
					
Else
	// Se o titular não estiver presente na lista de usuários, vou precisar descobrir quem ele é para armazenar os dados dele.
	cSql := "SELECT BA1_CODINT,BA1_CODEMP,BA1_MATRIC,BA1_TIPREG,BA1_DIGITO,BA1_ENDERE,BA1_NR_END,BA1_COMEND,BA1_BAIRRO,BA1_MUNICI,BA1_ESTADO,BA1_CEPUSR,BA1_NOMUSR "
	cSql += " FROM "+RetSqlName("BA1")+" WHERE BA1_FILIAL = '"+xFilial("BA1")+"' "
	cSql += " AND BA1_CODINT = '"+BA3->BA3_CODINT+"' "
	cSql += " AND BA1_CODEMP = '"+BA3->BA3_CODEMP+"' "
	cSql += " AND BA1_MATRIC = '"+BA3->BA3_MATRIC+"' "
	cSql += " AND BA1_TIPUSU = '"+cTitular+"' "
	cSql += " AND D_E_L_E_T_ = ' '"
	PlsQuery(cSql, "TRBBA1")
	
	If !TRBBA1->(Eof())
		cMatTit := Alltrim(TRBBA1->BA1_CODINT + TRBBA1->BA1_CODEMP + TRBBA1->BA1_MATRIC + TRBBA1->BA1_TIPREG + TRBBA1->BA1_DIGITO)
		cNomTit := Alltrim(TRBBA1->BA1_NOMUSR)
	
		aEndTitular := {	BA1->BA1_ENDERE,;
							BA1->BA1_NR_END,;
							BA1->BA1_COMEND,;
							BA1->BA1_BAIRRO,;
							BA1->BA1_MUNICI,;
							BA1->BA1_ESTADO,;
							BA1->BA1_CEPUSR}
	Endif

	TRBBA1->( dbCloseArea() )
Endif

BA1->( dbSetorder(02) )
BIH->(dbSetorder(01))
BRP->(dbSetorder(01))
BT6->(DbSetOrder(1))
BI3->(dbSetorder(01))
BB6->(DbSetOrder(1))
BTS->(dbSetorder(1))
BQC->(dbSetorder(1))
BG9->(dbSetorder(1))
GCM->(dbSetorder(02))

// Chegou neste ponto, é porque está tudo OK.
::ret_cartao_virtual:retorno_status 	:= .T.

For nCount := 1 to len(aUsr)

	If !BA1->( dbSeek(xFilial("BA1")+aUsr[nCount][1]) )
		Loop
	Endif
	
	// Registra o codigo do produto do usu'ario
	If !Empty(BA1->BA1_CODPLA) .and. !Empty(BA1->BA1_VERSAO)
		cCodPla := BA1->BA1_CODPLA
		cVerPla := BA1->BA1_VERSAO
		cCodInt := BA1->BA1_CODINT
	Else	
		cCodPla := BA3->BA3_CODPLA
		cVerPla := BA3->BA3_VERSAO
		cCodInt := BA3->BA3_CODINT				
	Endif
	
	// Posiciona o plano da famila	
	If BI3->(dbSeek(xFilial("BI3")+cCodInt+cCodPla+cVerPla))
		cDesPla := BI3->BI3_DESCRI
		cPlaHsp := BI3->BI3_HSPPLA
	Else
		cDesPla := ""
		cPlaHsp := ""
	Endif

	// Agora busca o convenio do paciente, se houver integração com HSP.	
	If GCM->(dbSeek(xFilial("GCM")+cPlaHsp))
		cCodCon := GCM->GCM_CODCON
		
	Else
		cCodCon := GCM->GCM_CODCON
		
	Endif

	GBH->(dbSetorder(8))
	GD4->(DbSetOrder(3))
					
	// Faz um backup dos dados do usuário que fez o login porque o BA1 será movido.
	cCodInt := BA1->BA1_CODINT
	cCodEmp := BA1->BA1_CODEMP
	cMatric := BA1->BA1_MATRIC
	cTipReg := BA1->BA1_TIPREG
	cDigito := BA1->BA1_DIGITO
		
	// Garante que o os bloqueados serão desconsiderados
	If !Empty(BA1->BA1_DATBLO) .and. BA1->BA1_DATBLO < dDataBase
		TRB->( dbSkip())
	Endif
	
	aAdd(::ret_cartao_virtual:retorno_dados, WsClassNew( "cartao_virtual" ) )
	nI := Len(::ret_cartao_virtual:retorno_dados)
	
	// Marca o flag que indica que foi este o usuário do login.
	If BA1->(BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG) == (cCodInt + cCodEmp + cMatric + cTipReg)
		::ret_cartao_virtual:retorno_dados[nI]:login := cLogUsr 
				
	Else
		::ret_cartao_virtual:retorno_dados[nI]:login := ""
	Endif
	
	// Flag que indica que este usuario é o titular
	If BA1->BA1_TIPUSU == cTitular
		::ret_cartao_virtual:retorno_dados[nI]:titular	:= "S"	
		
	Else
		::ret_cartao_virtual:retorno_dados[nI]:titular	:= "N"	
	Endif		

	::ret_cartao_virtual:retorno_dados[nI]:titular_matricula := cMatTit
	 
	// Flag que indica que o beneficiário está bloqueado no sistema.
	If (!Empty(BA1->BA1_DATBLO) .and. BA1->BA1_DATBLO < dDataBase)
		::ret_cartao_virtual:retorno_dados[nI]:bloqueado			:= "S"	
		::ret_cartao_virtual:retorno_dados[nI]:motivo_bloqueio		:= "Usuário bloqueado no sistema"
	Else
		::ret_cartao_virtual:retorno_dados[nI]:bloqueado			:= "N"	
		::ret_cartao_virtual:retorno_dados[nI]:motivo_bloqueio		:= ""
	Endif

	// Se houver integração com HSP, torna-se obrigatório ter o vinculo entre o GBH e BTS.
	// Se o relacionamento não estiver integro, trata o beneficiário com se não tivesse acesso. 
	If GBH->(dbSeek(xFilial("GBH")+BA1->BA1_MATVID))	
		::ret_cartao_virtual:retorno_dados[nI]:prontuario_id			:= GBH->GBH_CODPAC
	
	Else
		::ret_cartao_virtual:retorno_dados[nI]:prontuario_id			:= ""
	Endif	
	
	// Tipo de usuário
	::ret_cartao_virtual:retorno_dados[nI]:tipo_beneficiario_id				:= Alltrim(BA1->BA1_TIPUSU)
	If BIH->(dbSeek(xFilial("BIH")+BA1->BA1_TIPUSU))
		::ret_cartao_virtual:retorno_dados[nI]:tipo_beneficiario_descricao	:= Alltrim(BIH->BIH_DESCRI)
	Else
		::ret_cartao_virtual:retorno_dados[nI]:tipo_beneficiario_descricao	:= ""
	Endif
	
	// Grau de parentesco
	::ret_cartao_virtual:retorno_dados[nI]:grau_parentesco_id					:= Alltrim(BA1->BA1_TIPREG)
	If BRP->(dbSeek(xFilial("BRP")+BA1->BA1_GRAUPA))
		::ret_cartao_virtual:retorno_dados[nI]:grau_parentesco_descricao		:= Alltrim(BRP->BRP_DESCRI)
	Else
		::ret_cartao_virtual:retorno_dados[nI]:grau_parentesco_descricao		:= ""
	Endif
	
	// Cartão de identificação: dados básicos
	If !Empty(BA1->BA1_DTVLCR)
		::ret_cartao_virtual:retorno_dados[nI]:cartao_validade					:= BA1->BA1_DTVLCR
	Endif
	::ret_cartao_virtual:retorno_dados[nI]:cartao_via						:= Alltrim(Str(BA1->BA1_VIACAR))	
	::ret_cartao_virtual:retorno_dados[nI]:data_cpt							:= dtoc(BA1->BA1_DATCPT)		
	
	// Cartão de identificação: numero CNS	
	If BTS->( dbSeek(xFilial("BTS")+BA1->BA1_MATVID))
		If BTS->(FieldPos("BTS_NRCRNA")) > 0
			::ret_cartao_virtual:retorno_dados[nI]:numero_cns	:= BTS->BTS_NRCRNA
		Else
			::ret_cartao_virtual:retorno_dados[nI]:numero_cns	:= ""
		Endif
	Else
		::ret_cartao_virtual:retorno_dados[nI]:numero_cns	:= ""
	Endif
	
	// Dados pessoais
	cTelefone := Alltrim(BA1->BA1_DDD) + Alltrim(BA1->BA1_TELEFO)	
	::ret_cartao_virtual:retorno_dados[nI]:matricula				:= Alltrim(BA1->BA1_CODINT + BA1->BA1_CODEMP + BA1->BA1_MATRIC + BA1->BA1_TIPREG + BA1->BA1_DIGITO)
	::ret_cartao_virtual:retorno_dados[nI]:matricula_funcionario	:= BA3->BA3_AGMTFU	
	::ret_cartao_virtual:retorno_dados[nI]:matricula_sis_antigo	:= BA1->BA1_MATANT
	 
	::ret_cartao_virtual:retorno_dados[nI]:nome						:= Alltrim(BA1->BA1_NOMUSR)
	::ret_cartao_virtual:retorno_dados[nI]:sexo						:= Alltrim(BA1->BA1_SEXO)
	::ret_cartao_virtual:retorno_dados[nI]:cpf						:= Alltrim(BA1->BA1_CPFUSR)
	::ret_cartao_virtual:retorno_dados[nI]:nascimento				:= BA1->BA1_DATNAS
	::ret_cartao_virtual:retorno_dados[nI]:telefone					:= cTelefone
	::ret_cartao_virtual:retorno_dados[nI]:celular					:= cTelefone
	::ret_cartao_virtual:retorno_dados[nI]:email					:= Alltrim(BA1->BA1_EMAIL)
	::ret_cartao_virtual:retorno_dados[nI]:dependencia_id			:= Alltrim(BA1->BA1_TIPREG)
	::ret_cartao_virtual:retorno_dados[nI]:inclusao					:= BA1->BA1_DATINC
	::ret_cartao_virtual:retorno_dados[nI]:empresa_id				:= Alltrim(cCodEmp)
	
	If BG9->BG9_TIPO == '1' // Pessoa Física
		::ret_cartao_virtual:retorno_dados[nI]:tipo_pessoa_contratante	:= "FISICA"
		::ret_cartao_virtual:retorno_dados[nI]:empresa_nome		:= cNomTit
	Else
		::ret_cartao_virtual:retorno_dados[nI]:tipo_pessoa_contratante	:= "JURIDICA"
		::ret_cartao_virtual:retorno_dados[nI]:empresa_nome			:= BQC->BQC_NREDUZ 
	Endif
	::ret_cartao_virtual:retorno_dados[nI]:numero_contrato			:= Alltrim(BA3->BA3_NUMCON)
	
	// Endereço
	If !Empty(BA1->BA1_ENDERE)
		::ret_cartao_virtual:retorno_dados[nI]:endereco				:= Alltrim(BA1->BA1_ENDERE)
		::ret_cartao_virtual:retorno_dados[nI]:numero				:= Alltrim(BA1->BA1_NR_END)
		::ret_cartao_virtual:retorno_dados[nI]:complemento			:= Alltrim(BA1->BA1_COMEND)
		::ret_cartao_virtual:retorno_dados[nI]:bairro				:= Alltrim(BA1->BA1_BAIRRO)
		::ret_cartao_virtual:retorno_dados[nI]:cidade				:= Alltrim(BA1->BA1_MUNICI)
		::ret_cartao_virtual:retorno_dados[nI]:estado				:= Alltrim(BA1->BA1_ESTADO)
		::ret_cartao_virtual:retorno_dados[nI]:cep					:= Alltrim(BA1->BA1_CEPUSR)
		
	Else
		::ret_cartao_virtual:retorno_dados[nI]:endereco				:= Alltrim(aEndTitular[1])
		::ret_cartao_virtual:retorno_dados[nI]:numero				:= Alltrim(aEndTitular[2])
		::ret_cartao_virtual:retorno_dados[nI]:complemento			:= Alltrim(aEndTitular[3])
		::ret_cartao_virtual:retorno_dados[nI]:bairro				:= Alltrim(aEndTitular[4])
		::ret_cartao_virtual:retorno_dados[nI]:cidade				:= Alltrim(aEndTitular[5])
		::ret_cartao_virtual:retorno_dados[nI]:estado				:= Alltrim(aEndTitular[6])
		::ret_cartao_virtual:retorno_dados[nI]:cep					:= Alltrim(aEndTitular[7])
	Endif
				
	// Dados do plano
	If !Empty(cCodPla)
		::ret_cartao_virtual:retorno_dados[nI]:convenio_id						:= Alltrim(cCodPla)+Alltrim(cVerPla)
		::ret_cartao_virtual:retorno_dados[nI]:convenio_descricao				:= Alltrim(cDesPla)
		::ret_cartao_virtual:retorno_dados[nI]:convenio_versao					:= Alltrim(cVerPla)
						
		::ret_cartao_virtual:retorno_dados[nI]:convenio_abrangencia				:= Alltrim(Posicione("BF7",1,xFilial("BF7")+BI3->BI3_ABRANG,"BF7_DESORI"))
		::ret_cartao_virtual:retorno_dados[nI]:convenio_acomodacao				:= Alltrim(Posicione("BI4",1,xFilial("BI4")+BI3->BI3_CODACO,"BI4_DESCRI"))
		::ret_cartao_virtual:retorno_dados[nI]:convenio_segmentacao				:= alltrim(Posicione("BI6",1,xFilial("BI6")+BI3->BI3_CODSEG,"BI6_DESCRI"))
		::ret_cartao_virtual:retorno_dados[nI]:convenio_tipo_contrato			:= Alltrim(Posicione("BII",1,xFilial("BII")+BI3->BI3_TIPCON,"BII_DESCRI"))
		::ret_cartao_virtual:retorno_dados[nI]:convenio_padrao_conforto		:= Alltrim(Posicione("BN5",1,xFilial("BN5")+BI3->BI3_PADSAU,"BN5_DESCRI"))
		::ret_cartao_virtual:retorno_dados[nI]:convenio_modalidade_cobranca	:= Alltrim(PLSTXTSX3("BI3_MODPAG", BI3->BI3_MODPAG))
		::ret_cartao_virtual:retorno_dados[nI]:convenio_participativo			:= Alltrim(PLSTXTSX3("BI3_CPFM", BI3->BI3_CPFM))
		::ret_cartao_virtual:retorno_dados[nI]:convenio_regulamentacao			:= Alltrim(PLSTXTSX3("BI3_APOSRG", BI3->BI3_APOSRG))		
		::ret_cartao_virtual:retorno_dados[nI]:convenio_ANS						:= BI3->BI3_SUSEP
			
		// Opcional
		If lMSCVOPC
			cOpcional := Execblock("MSCVOPC", .F., .F., {cCodPla,cVerPla})
			If ValType(cOpcional) == "C" .and. !Empty(cOpcional)   		
				::ret_cartao_virtual:retorno_dados[nI]:convenio_opcional	:= cOpcional
			Else
				::ret_cartao_virtual:retorno_dados[nI]:convenio_opcional	:= ""			
			Endif
		Else
			::ret_cartao_virtual:retorno_dados[nI]:convenio_opcional		:= ""			
		Endif 
		
		// Dados sobre o tipo de rede
		If lMSCVREDE
			aRetRede := Execblock("MSCVREDE", .F., .F., {cCodPla,cVerPla})
			If ValType(aRetRede) == "A" .and. Len(aRetRede) > 0   		
				::ret_cartao_virtual:retorno_dados[nI]:convenio_tipo_rede_id				:= aRetRede[1] 
				::ret_cartao_virtual:retorno_dados[nI]:convenio_tipo_rede_descricao		:= aRetRede[2]
				
			Else
				::ret_cartao_virtual:retorno_dados[nI]:convenio_tipo_rede_id				:= "" 
				::ret_cartao_virtual:retorno_dados[nI]:convenio_tipo_rede_descricao		:= ""
			
			Endif
		Else
			::ret_cartao_virtual:retorno_dados[nI]:convenio_tipo_rede_id				:= "" 
			::ret_cartao_virtual:retorno_dados[nI]:convenio_tipo_rede_descricao		:= ""		
		Endif 
			
		// Cartão de identificação: carencias
		aCarencias := {}
		
		// Carencias padrões
		aAux := PLSLISMSGC(BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO),PlsIntPad()+cCodPla,cVerPla,BA1->BA1_DATCAR,BA1->BA1_SEXO,"1")			
		For nCnt := 1 To Len(aAux)
			Aadd(aCarencias, {aAux[nCnt][2],;
					 Iif(aAux[nCnt][3]<dDataBase,; // Carencia cumprida ?
					 	"Cumprida",;
					  	dToc(aAux[nCnt][3]))})
		Next
		
		If ValType(aCarencias) == "A" .and. Len(aCarencias) > 0			
			::ret_cartao_virtual:retorno_dados[nI]:convenio_carencias := {}
				 
			For nCnt := 1 to len(aCarencias)
				Aadd(::ret_cartao_virtual:retorno_dados[nI]:convenio_carencias,WsClassNew( "carencias"))
					
				::ret_cartao_virtual:retorno_dados[nI]:convenio_carencias[nCnt]:tipo_servico	:= aCarencias[nCnt][1]
				::ret_cartao_virtual:retorno_dados[nI]:convenio_carencias[nCnt]:carencia	  	:= aCarencias[nCnt][2]
			Next
		Endif
				
	Else
		::ret_cartao_virtual:retorno_dados[nI]:convenio_id							:= ""
		::ret_cartao_virtual:retorno_dados[nI]:convenio_descricao					:= ""
		::ret_cartao_virtual:retorno_dados[nI]:convenio_versao						:= ""						
		::ret_cartao_virtual:retorno_dados[nI]:convenio_abrangencia				:= ""
		::ret_cartao_virtual:retorno_dados[nI]:convenio_acomodacao				:= ""
		::ret_cartao_virtual:retorno_dados[nI]:convenio_segmentacao				:= ""
		::ret_cartao_virtual:retorno_dados[nI]:convenio_tipo_contrato				:= ""
		::ret_cartao_virtual:retorno_dados[nI]:convenio_padrao_conforto			:= ""
		::ret_cartao_virtual:retorno_dados[nI]:convenio_modalidade_cobranca		:= ""
		::ret_cartao_virtual:retorno_dados[nI]:convenio_participativo				:= ""
		::ret_cartao_virtual:retorno_dados[nI]:convenio_permite_reembolso		:= ""	
	Endif
	
	// Cartão de identificação: inicializa o array de layout de cartões 
	::ret_cartao_virtual:retorno_dados[nI]:layout_cartoes := {}
		
	If lMSLOGFIM
		oObjBackup := Execblock("MSLOGFIM", .F., .F., {::ret_cartao_virtual,nI,cMatTit,lExistTitular})
		If ValType(oObjBackup) == "O"
			::ret_cartao_virtual := oObjBackup
		Endif
	Endif
		
Next

If Len(::ret_cartao_virtual:retorno_dados) == 0
	MBSetFault(@ret_grupo_familiar, "MB039")
Endif

Return(.T.)	

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    GetLieCon  ³Autor ³ Leandro de Faria     ³ Data ³07.10.2016 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Retorna o texto para exibição do li e concordo   		   		±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD GetLieCon WSRECEIVE UserCode WSSEND RetLieCon WSSERVICE PLSXFUN

Local lRetorno 	:= .T.
Local cCodInt	:= PlsIntPad()
Local aAreas 	:= {BA0->(GetArea()),GetArea()}
Local nLines    := 0
Local nI		:= 0

IF PrtChkUser( ::UserCode, "PLSXFUN", "GetLieCon" )

	//Localiza a operadora padrão
	BA0->(dbSetOrder(1))
	If BA0->(dbSeek(xFilial("BA0")+cCodInt)) .And. BA0->(FieldPos("BA0_LIECON") ) > 0
	
		nLines := MLCount( BA0->BA0_LIECON )

   		For nI := 1 to nLines

			if !(empty(memoLine(BA0->BA0_LIECON,,nI)))
			 	::RetLieCon:cLieCon += alltrim(strTran(strTran(memoLine(BA0->BA0_LIECON,,nI), chr(10), ""), chr(13),""))
			endIf
		Next nI
	Else
		::RetLieCon:cLieCon := ""
	EndIf

	AEval(aAreas, {|x| RestArea(x)})
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

Return (lRetorno)

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} RetItercamb
WS que retorna se é um usuário de intercambio

@author		Lucas Nonato
@since		14/09/2016
@version	P11 

/*/
//---------------------------------------------------------------------------------------

wsMethod RetItercamb wsReceive UserCode, UserCardNumber wsSend WSNULL wsService PLSXFUN
Local lRet 	:= .T.

BA1->( DbSetOrder(2) ) //BA1_FILIAL + BA1_CODINT + BA1_CODEMP + BA1_MATRIC + BA1_TIPREG + BA1_DIGITO

If prtChkUser( ::UserCode ,"PLSXFUN","RetItercamb" )
	//Caso a empresa do beneficiario for igual a empresa de intercambio retorna true
	If SubStr(::UserCardNumber,5,4) == GetNewPar("MV_PLSGEIN",'')
		::WSNULL := "true|" 
	Else
		::WSNULL := "" 
	EndIf
EndIf	

Return lRet

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} RetDadBen
WS que retorna os dados do usuário

@author		Lucas Nonato
@since		07/12/2016
@version	P11 

/*/
//---------------------------------------------------------------------------------------
wsMethod RetDadBen wsReceive UserCode,Matric wsSend dados_benef wsService PLSXFUN
	local lRet 	:= .T.
	local aRet	:= {}

	if( prtChkUser( ::UserCode,"PLSXFUN","RetItercamb" ) )
		aRet := PLSA271( ::Matric )
		
		if( len( aRet ) > 0 )
			::dados_benef := wsClassNew( "st_dados_benef" )
			::dados_benef:CNOMEUSUARI		:= aRet[ 1 ][ 01 ]
			::dados_benef:CMATRICULA		:= aRet[ 1 ][ 02 ]
			::dados_benef:DDTNACTO			:= aRet[ 1 ][ 03 ]
			::dados_benef:CCNESUSU			:= aRet[ 1 ][ 04 ]
			::dados_benef:CSUSEP			:= aRet[ 1 ][ 05 ]
			::dados_benef:CSEGASSPL			:= aRet[ 1 ][ 06 ]
			::dados_benef:CNUMREGOPE		:= aRet[ 1 ][ 07 ]
			::dados_benef:CCONTATOOPE		:= aRet[ 1 ][ 08 ]
			::dados_benef:CCONTATOANS		:= aRet[ 1 ][ 09 ]
			::dados_benef:DCPT				:= aRet[ 1 ][ 10 ]
			::dados_benef:CTPACOMODA		:= aRet[ 1 ][ 11 ]
			::dados_benef:CCONTRATACA		:= aRet[ 1 ][ 12 ]
			::dados_benef:CABRANG			:= aRet[ 1 ][ 13 ]
			::dados_benef:CNOMPRO			:= aRet[ 1 ][ 14 ]
			::dados_benef:CNFANTAZOPE		:= aRet[ 1 ][ 15 ]
			::dados_benef:CNFAADMBENE		:= aRet[ 1 ][ 16 ]
			::dados_benef:CRZSOCIAL			:= aRet[ 1 ][ 17 ]
			::dados_benef:DDTVIGPL			:= aRet[ 1 ][ 18 ]
			::dados_benef:CNUMCON			:= aRet[ 1 ][ 19 ]
			::dados_benef:DDATCON			:= aRet[ 1 ][ 20 ]
			::dados_benef:DDTMAXCON			:= aRet[ 1 ][ 21 ]
			::dados_benef:CINFOPLAN			:= aRet[ 1 ][ 22 ]
			::dados_benef:CINFORMACOE		:= aRet[ 1 ][ 23 ] 
			::dados_benef:CCARENCAMB		:= aRet[ 1 ][ 24 ] 
			::dados_benef:CCARENCHOS		:= aRet[ 1 ][ 25 ] 
			::dados_benef:CCARENCPAT		:= aRet[ 1 ][ 26 ] 
			::dados_benef:CCARENCODO		:= aRet[ 1 ][ 27 ] 
		endIf
	endIf
return lRet
//---------------------------------------------------------------------------------------
/*/{Protheus.doc} HabBotao
WS Verifica se foi anexado uma receita no Uso constante

@author	Robson Nayland
@since		22/02/2017
@version	P12 

/*/
//---------------------------------------------------------------------------------------

wsMethod HabBotao wsReceive UserCode,cRecno,Chave wsSend WSNULL wsService PLSXFUN
Local lRet 	:= .T.


If prtChkUser( ::UserCode ,"PLSXFUN","HabBotao" )

B4F->( DbSetOrder(1) ) 
AC9->( DbSetOrder(2) )	

	If AC9->(MsSeek(xFilial("AC9")+"B4F"+xFilial("B4F")+xFilial("B4F")+Chave))
		::WSNULL := "true|" 
	Else
		::WSNULL := "false" 

	EndIf
EndIf	

Return lRet


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³getLancam³Autor  ³ Alexander Santos      ³ Data ³18.05.2010 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina Lista de Lançamentos	                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
WSMETHOD getLancam WSRECEIVE UserCode WSSEND DadosLanc WSSERVICE PLSXFUN
LOCAL aArea 	:= GetArea()
LOCAL nI		:= 1
LOCAL lRet 		:= .T.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se tem direito para executar o metodo								   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If PrtChkUser( ::UserCode , "PLSXFUN", "getLancam" )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Posiciona no lançamento									   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BFQ->(dbGoTop())
	
	While !BFQ->(EOF())
		
		If BFQ->BFQ_EXTFIN == "1"
		
		   AaDd( ::DadosLanc, WsClassNew( "STipGui" ))
		   ::DadosLanc[nI]:Cod    := BFQ->BFQ_CODLAN
		   ::DadosLanc[nI]:Descri := BFQ->BFQ_DESCRI
		   nI++
	   EndIf
      
      BFQ->(DbSkip())
	EndDo
Else
	lRet := .F.
	SetSoapFault( "", "Usuário não autorizado" )
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Fim do metodo														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} VldItReemb
Valida itens negados para reembolso

@author Francisco Edcarlo
@since 03/2017
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD VldItReemb WSRECEIVE UserCode, CodSol WSSEND WSNULL WSSERVICE PLSXFUN
local lRetorno := .T.
local cCodSol := ::CodSol
::WSNULL := "true|"

If PrtChkUser( ::UserCode, "PLSXFUN", "VldItReemb" )
	if cCodSol != "ZZZZX"
		
		If BCT->(FieldPos("BCT_VALREE")) > 0  
			
			//verifica se existem itens negados e deleta do banco de dados.
			aDadRet := PLDELITEM(cCodSol) 
			
			//Se na primeir posição retornar true, significa que existe pelo menos um item aprovado no protocolo.
			If aDadRet[1]
				
				//se na segunda posição retornar false significa que não existem itens negados.
				If aDadRet[2]
					//se na segunda posição retornar true significa existem itens negados e aprovados no protocolo.
					::WSNULL := "true|<b>Os itens negados não serão gravados ou contabilizados no protocolo!</b>"
					::WSNULL += "|false"
				EndIf
			Else
				//se na primeira posição retornar false significa que todos os itens foram negados.
				::WSNULL := "true|Solicitação não concluída pois todos os itens foram negados!|false"
			EndIf
		Else
			
			::WSNULL := "true|"
		EndIf 
	Else
		::WSNULL := "false|"
	EndIf 
else
	lRetorno := .F.
	::WSNULL := "false|"
	setSoapFault("", "Não autorizado a utilização do método" )
EndIF

Return lRetorno

//-------------------------------------------------------------------
/*/{Protheus.doc} getFamBloq

Traz beneficiarios da familia para realizacao do bloqueio
@author  Renan Sakai
@version P11
@since   28/03/17
/*/
//-------------------------------------------------------------------
WSMETHOD getFamBloq WSRECEIVE UserCode, cUsrLogin WSSEND ListFamBloq WSSERVICE PLSXFUN
LOCAL nI        := 1
LOCAL aArea	    := GetArea()
LOCAL lRetorno  := .T.
LOCAL lOpen     := .F.
LOCAL cSQL
LOCAL cCodFam
LOCAL cTitular  := GetNewPar("MV_PLCDTIT","T")

// Checa Usuario
If PrtChkUser( ::UserCode, "PLSXFUN", "getFamBloq" )
	

	// Retorna a matricula do beneficiario que esta cadastrado para o login
	cSQL := " SELECT B49_BENEFI "
	cSQL += " FROM " + RetSQLName("B49")
	cSQL += " WHERE B49_CODUSR = '" + cUsrLogin + "' AND "
	cSQL += " D_E_L_E_T_ = ' ' "
	cSql := ChangeQuery(cSql)  
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql),"TrbRetTit",.T.,.F.) //PLSQuery(cSQL,"TrbRetTit")
	
	If !TrbRetTit->(EOF())
		
		cCodFam := SUBSTR(TrbRetTit->B49_BENEFI,1,14)
		::ListFamBloq  := {}
        
       	BA1->(DbSetOrder(2))
		
		If BA1->(MsSeek(xFilial("BA1")+TrbRetTit->B49_BENEFI)) .And. BA1->BA1_TIPUSU != GetNewPar("MV_PLCDTIT","T")
			If Calc_Idade(dDataBase,BA1->BA1_DATNAS) >= 18
				AaDd( ::ListFamBloq,wsClassNew("FamBloqList") )  
				nI := 1
				::ListFamBloq[nI]:Recno     := BA1->(Recno())
				::ListFamBloq[nI]:Matricula := Transform(BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO), "@R !!!!.!!!!.!!!!!!-!!-!")
				::ListFamBloq[nI]:Nome      := Alltrim(BA1->BA1_NOMUSR)
				::ListFamBloq[nI]:CPF       := Transform(BA1->BA1_CPFUSR, "@R 999.999.999-99")  
				::ListFamBloq[nI]:DataNasc  := BA1->BA1_DATNAS
				::ListFamBloq[nI]:DataInc   := BA1->BA1_DATINC
	        	::ListFamBloq[nI]:TipoBenef := IIf(BA1->BA1_TIPUSU == cTitular,"TITULAR","DEPENDENTE")   
	        	::ListFamBloq[nI]:DataBloq	 := BA1->BA1_DATBLO       
	        		
		       	lOpen := .F.
	    	   	B5K->(DbSetOrder(2))
	        	If B5K->(MsSeek(xFilial("B5K")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)))
		       		While B5K->(B5K_FILIAL+B5K_MATUSU) == xFilial("B5K")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO) .And. !B5K->(Eof())
			   			B5J->(DbSetOrder(1))
			   			If B5J->(MsSeek(xFilial("B5J")+B5K->B5K_CODIGO)) .And. B5J->B5J_STATUS == "0"
			   				lOpen := .T.
			   				Exit
			   			EndIf
			   			B5K->(DbSkip())
			   		EndDo	
		       	EndIf    
		   		::ListFamBloq[nI]:SolicAbert := IIf(lOpen,"Sim","Não")
		   	EndIf	
		Else
			// Retorna os beneficiarios da familia
			If BA1->(MsSeek(xFilial("BA1")+cCodFam))
	        	While BA1->(BA1_FILIAL+BA1_CODINT+BA1_CODEMP+BA1_MATRIC) == xFilial("BA1")+cCodFam .And. !BA1->(Eof())
			  		AaDd( ::ListFamBloq,wsClassNew("FamBloqList") )  
			  		::ListFamBloq[nI]:Recno     := BA1->(Recno())
					::ListFamBloq[nI]:Matricula := Transform(BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO), "@R !!!!.!!!!.!!!!!!-!!-!")
					::ListFamBloq[nI]:Nome      := Alltrim(BA1->BA1_NOMUSR)
					::ListFamBloq[nI]:CPF       := Transform(BA1->BA1_CPFUSR, "@R 999.999.999-99")  
					::ListFamBloq[nI]:DataNasc  := BA1->BA1_DATNAS
					::ListFamBloq[nI]:DataInc   := BA1->BA1_DATINC
	        		::ListFamBloq[nI]:TipoBenef := IIf(BA1->BA1_TIPUSU == cTitular,"TITULAR","DEPENDENTE")   
	        		::ListFamBloq[nI]:DataBloq	 := BA1->BA1_DATBLO       
	        		
	        		lOpen := .F.
	        		B5K->(DbSetOrder(2))
	        		If B5K->(MsSeek(xFilial("B5K")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)))
	        			While B5K->(B5K_FILIAL+B5K_MATUSU) == xFilial("B5K")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO) .And. !B5K->(Eof())
		        			B5J->(DbSetOrder(1))
		        			If B5J->(MsSeek(xFilial("B5J")+B5K->B5K_CODIGO)) .And. B5J->B5J_STATUS == "0"
		        				lOpen := .T.
		        				Exit
		        			EndIf
		        			B5K->(DbSkip())
		        		EndDo	
	        		EndIf    
	   				::ListFamBloq[nI]:SolicAbert := IIf(lOpen,"Sim","Não")
	        		BA1->(DbSkip())
	        		nI++
	        	EndDo
			EndIf
		EndIf
		
		TrbRetTit->(dbCloseArea())
	EndIf
	
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno               


//-------------------------------------------------------------------
/*/{Protheus.doc} procSolicBloq

Traz beneficiarios da familia para realizacao do bloqueio
@author  Renan Sakai
@version P11
@since   28/03/17
/*/
//-------------------------------------------------------------------
WSMETHOD procSolicBloq WSRECEIVE UserCode, cUsrLogin, cRecno WSSEND NumProtoc WSSERVICE PLSXFUN
LOCAL lRetorno  := .T.         
LOCAL aRecnos   := StrTokArr(cRecno,",")  
LOCAL nX        := 0

//Monta arrau com os recnos dos beneficiarios que serao cancelados
For nX := 1 to len(aRecnos)
	aRecnos[nX] := Val(StrTran(aRecnos[nX],"'",""))
Next 

// Checa Usuario
If PrtChkUser( ::UserCode, "PLSXFUN", "procSolicBloq" )

	// Retorna a matricula do beneficiario que esta cadastrado para o login
	cSQL := " SELECT B49_BENEFI "
	cSQL += " FROM " + RetSQLName("B49")
	cSQL += " WHERE B49_CODUSR = '" + cUsrLogin + "' AND "
	cSQL += " D_E_L_E_T_ = ' ' "
	cSql := ChangeQuery(cSql)  
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql),"TrbRetTit",.T.,.F.) //PLSQuery(cSQL,"TrbRetTit")
	
	If !TrbRetTit->(EOF())
		::NumProtoc := PL99BGRVRP(TrbRetTit->B49_BENEFI,aRecnos)  
	EndIf
	
	TrbRetTit->(dbCloseArea())   

EndIf

Return lRetorno                  

//-------------------------------------------------------------------
/*/{Protheus.doc} getSolCanPla

Traz informacoes de uma solicitacao de cancelamento de plano ja realizada
@author  Renan Sakai
@version P11
@since   28/03/17
/*/
//-------------------------------------------------------------------
WSMETHOD getSolCanPla WSRECEIVE UserCode, cUsrLogin, cRecno WSSEND ListSolicCanPla WSSERVICE PLSXFUN
LOCAL cStatus   := ""
LOCAL nI        := 1
LOCAL aArea	    := GetArea()
LOCAL lRetorno  := .T.
LOCAL cSQL
LOCAL cTitular  := GetNewPar("MV_PLCDTIT","T")
LOCAL cOrigem   := ""

// Checa Usuario
If PrtChkUser( ::UserCode, "PLSXFUN", "getSolCanPla" )
	

	// Retorna a matricula do beneficiario que esta cadastrado para o login
	cSQL := " SELECT B49_BENEFI "
	cSQL += " FROM " + RetSQLName("B49")
	cSQL += " WHERE B49_CODUSR = '" + cUsrLogin + "' AND "
	cSQL += " D_E_L_E_T_ = ' ' "
	cSql := ChangeQuery(cSql)  
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cSql),"TrbRetTit",.T.,.F.) //PLSQuery(cSQL,"TrbRetTit")
	
	If !TrbRetTit->(EOF())
				
		::ListSolicCanPla  := {}
        
        //Se matricula informada, carrego todos os protocolos do beneficiario
		If cRecno <> "0" 
			BA1->(DbGoTo(Val(cRecno)))   
			B5K->(DbSetOrder(2))    
			B5J->(DbSetOrder(1))
        	If B5K->(MsSeek(xFilial("B5K")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO)))
        		
        		While B5K->(B5K_FILIAL+B5K_MATUSU) == xFilial("B5K")+BA1->(BA1_CODINT+BA1_CODEMP+BA1_MATRIC+BA1_TIPREG+BA1_DIGITO) .And. !B5K->(Eof())
	       			
	       			If B5J->(MsSeek(xFilial("B5J")+B5K->B5K_CODIGO))
			       		Do Case
			        		Case B5J->B5J_STATUS ==  "0"
			        			cStatus := "Pendente"
			        		Case B5J->B5J_STATUS == "1"
			        			cStatus := "Bloqueio Efetuado"
			        		Case B5J->B5J_STATUS == "2"
			        			cStatus := "Confim.Emitida"
			            EndCase
			        	           
			        	Do Case
			        		Case B5J->B5J_ORISOL ==  "1"
			        			cOrigem := "Presencial"
			        		Case B5J->B5J_ORISOL == "2"
			        			cOrigem := "Call-Center"
			        		Case B5J->B5J_ORISOL == "3"
			        			cOrigem := "Portal Web"
			            EndCase    
		    
				  		AaDd( ::ListSolicCanPla,wsClassNew("SolicCanPlaList") )  
				  		::ListSolicCanPla[nI]:Recno     := B5J->(Recno())
						::ListSolicCanPla[nI]:Protocolo := B5J->B5J_PROTOC
						::ListSolicCanPla[nI]:DataSolic := B5J->B5J_DATSOL
						::ListSolicCanPla[nI]:DataBloq  := B5J->B5J_DATBLO   
						::ListSolicCanPla[nI]:Status    := cStatus
						::ListSolicCanPla[nI]:Origem    := cOrigem
			       		B5J->(DbSkip())
			       		nI++
			    	EndIf
			    	B5K->(DbSkip())
	       		EndDo	
        	EndIf    
		
		Else
			B5J->(DbSetOrder(3))
			If B5J->(MsSeek(xFilial("B5J")+TrbRetTit->B49_BENEFI))
	        	While B5J->(B5J_FILIAL+B5J_MATSOL) == xFilial("B5J")+TrbRetTit->B49_BENEFI .And. !B5J->(Eof())   
	        		Do Case
	        			Case B5J->B5J_STATUS ==  "0"
	        				cStatus := "Pendente"
	        			Case B5J->B5J_STATUS == "1"
	        				cStatus := "Bloqueio Efetuado"
	        			Case B5J->B5J_STATUS == "2"
	        				cStatus := "Confim.Emitida"
	        	    EndCase      
	        	    
        	    	Do Case
		        		Case B5J->B5J_ORISOL ==  "1"
		        			cOrigem := "Presencial"
		        		Case B5J->B5J_ORISOL == "2"
		        			cOrigem := "Call-Center"
		        		Case B5J->B5J_ORISOL == "3"
		        			cOrigem := "Portal Web"
		            EndCase    
	        	    
			  		AaDd( ::ListSolicCanPla,wsClassNew("SolicCanPlaList") )  
			  		::ListSolicCanPla[nI]:Recno     := B5J->(Recno())
					::ListSolicCanPla[nI]:Protocolo := B5J->B5J_PROTOC
					::ListSolicCanPla[nI]:DataSolic := B5J->B5J_DATSOL
					::ListSolicCanPla[nI]:DataBloq  := B5J->B5J_DATBLO   
					::ListSolicCanPla[nI]:Status    := cStatus
					::ListSolicCanPla[nI]:Origem    := cOrigem
	        		B5J->(DbSkip())
	        		nI++
	        	EndDo
			EndIf
		EndIf
		TrbRetTit->(dbCloseArea())
	EndIf
	
Else
	lRetorno := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf

RestArea( aArea )

Return lRetorno  


/*/{Protheus.doc} RetCriTXT
Retorna as críticas em base 64
@author Renan Martins
@since 06/2017
/*/
wsMethod RetCriTXT wsReceive UserCode, Busca wsSend WSNULL wsService PLSXFUN
Local lRet	:= .T.

If prtChkUser( ::UserCode ,"PLSXFUN","RetCriTXT" )
	::WSNULL := "true|"+PLSRCRIT(::Busca, "", .T.)
Else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf	

Return lRet

/*/{Protheus.doc} DupGui
Verifica se a guia prestes a ser digitada pode estar sendo duplicada
@author victor.silva
@since 22/06/2017
@version P12
/*/
WSMETHOD isDupGui WSRECEIVE UserCode, RdaCode, TipGui, NumGuiRef, UserCardNumber, DatGuia WSSEND WSNULL WSSERVICE PLSXFUN
local cAliGui	:= ""
local nIdx		:= ""
local cMsg		:= ""
local lRetorno 	:= .T.
local lIsDup	:= .F.

default ::WSNULL 	:= ""

If PrtChkUser( ::UserCode, "PLSXFUN", "isDupGui" )	

	// Busca guias com a mesma chave realizadas no mesmo dia 
	lIsDup := RetGuiDup(::TipGui,::DatGuia,@cMsg,::RdaCode,::NumGuiRef,UserCardNumber)
	
	if lIsDup
		::WSNULL := "true|S|" + cMsg
	else
		::WSNULL := "true|N|--"
	endIf
	
Else
	lRetorno := .F.
	SetSoapFault( "", "Usuário não autorizado" )
EndIf

Return lRetorno

Static Function RetGuiDup(cTipGui,cDatGui,cMsg,cCodRda,cGuiSol,cMatUsr)
local cAliasQry	:= GetNextAlias()
local lRet 		:= .F.
local cNumGui	:= ""
local cCampos	:= ""
local cSql		:= ""

default cMsg	:= ""

//TODO - Tratar Guia de Honorarios
if cTipGui == "6"
	Return lRet
endif

//TODO - Tratar Guia de Resumo de Internação 
If cTipGui == '5'
	return lRet
endif

cSql	:= "%"
do case
	case cTipGui $ "1/2/4"	//GUIA DE CONSULTA/SADT/ODONTO

		cCampos	:= "% BEA_OPEMOV OPEMOV, BEA_ANOAUT ANOAUT, BEA_MESAUT MESAUT, BEA_NUMAUT NUMAUT %"
		cSql	+= RetSqlName("BEA") + " BEA WHERE "
		cSql	+= "BEA_FILIAL = '" + xFilial("BEA") + "' AND " 
		cSql	+= "BEA_OPEUSR = '" + SubStr(cMatUsr,1,4) + "' AND " 
		cSql	+= "BEA_CODEMP = '" + SubStr(cMatUsr,5,4) + "' AND " 
		cSql	+= "BEA_MATRIC = '" + SubStr(cMatUsr,9,6) + "' AND " 
		cSql	+= "BEA_TIPREG = '" + SubStr(cMatUsr,15,2) + "' AND "  
		cSql	+= "BEA_DATPRO = '" + cDatGui + "' AND "
		cSql	+= "BEA_CODRDA = '" + cCodRda + "' AND "
		cSql	+= "BEA_TIPGUI = '" + ("0" + cTipGui) + "' AND "
		cSql	+= "BEA.D_E_L_E_T_ = ' '"

	case cTipGui == "3"		//GUIA DE SOL. INTERNACAO

		cCampos	:= "% BE4_CODOPE OPEMOV, BE4_ANOINT ANOAUT, BE4_MESINT MESAUT, BE4_NUMINT NUMAUT %"
		cSql	+= RetSqlName("BE4") + " BE4 WHERE "
		cSql	+= "BE4_FILIAL = '" + xFilial("BE4") + "' AND " 
		cSql	+= "BE4_OPEUSR = '" + SubStr(cMatUsr,1,4) + "' AND " 
		cSql	+= "BE4_CODEMP = '" + SubStr(cMatUsr,5,4) + "' AND " 
		cSql	+= "BE4_MATRIC = '" + SubStr(cMatUsr,9,6) + "' AND " 
		cSql	+= "BE4_TIPREG = '" + SubStr(cMatUsr,15,2) + "' AND "  
		cSql	+= "BE4_DATPRO = '" + cDatGui + "' AND "
		cSql	+= "BE4_CODRDA = '" + cCodRda + "' AND "
		cSql	+= "BE4.D_E_L_E_T_ = ' '"

	/*case cTipGui == "6"		//GUIA DE HONORARIOS

		cCampos	:= "% BD5_CODOPE OPEMOV, BD5_ANOAUT ANOAUT, BD5_MESAUT MESAUT, BD5_NUMAUT NUMAUT %"
		cSql	+= RetSqlName("BD5") + " BD5 WHERE " 
		cSql	+= "BD5_FILIAL = '" + xFilial("BD5") + "' AND "
		cSql	+= "BD5_GUIINT = '" + cGuiSol + "' AND "
		cSql	+= "BD5_DATPRO = '" + cDatGui + "' AND "
		cSql	+= "BD5.D_E_L_E_T_ = ' '"*/

	case cTipGui $ "7/8/9"	//ANEXOS

		cCampos	:= "% B4A_OPEMOV OPEMOV, B4A_ANOAUT ANOAUT, B4A_MESAUT MESAUT, B4A_NUMAUT NUMAUT %"
		cSql	+= RetSqlName("B4A") + " B4A WHERE "
		cSql	+= "B4A_FILIAL = '" + xFilial("BD5") + "' AND "
		cSql	+= "B4A_GUIREF = '" + cGuiSol + "' AND "
		cSql	+= "B4A_TIPGUI = '" + ("0" + cTipGui) + "' AND "
		cSql	+= "B4A_DATSOL = '" + cDatGui + "' AND "
		cSql	+= "B4A.D_E_L_E_T_ = ' '"

	case cTipGui == "11"	//GUIA DE SOL.PRORROGAÇÃO DE INT

		cCampos	:= "% B4Q_OPEMOV OPEMOV, B4Q_ANOAUT ANOAUT, B4Q_MESAUT MESAUT, B4Q_NUMAUT NUMAUT %"
		cSql	+= RetSqlName("B4Q") + " B4Q WHERE "
		cSql	+= "B4Q_FILIAL = '" + xFilial("B4Q") + "' AND " 
		cSql	+= "B4Q_GUIREF = '" + cGuiSol + "' AND " 
		cSql	+= "B4Q_DATPRO = '" + cDatGui + "' AND " 
		cSql	+= "B4Q.D_E_L_E_T_ = ' '"
		
endcase
cSql	+= "%"

//Realiza a consulta
BeginSql alias cAliasQry
SELECT
	%exp:cCampos%
FROM
	%exp:cSql%
EndSql

//Caso ache algum resultado, significa que houve inclusao de guia com os mesmos dados no dia
if (cAliasQry)->(!Eof())
	lRet 	:= .T.
	cNumGui := Transform(AllTrim((cAliasQry)->(OPEMOV + ANOAUT + MESAUT + NUMAUT)), "@R 9999.9999.99-99999999" )
endif

(cAliasQry)->(DbCloseArea())

// Compoe a mensagem
if lRet
	cMsg := "Identificamos que recentemente foi realizada "
	if cTipGui $ '7/8/9'
		cMsg += "a inclusão do anexo '"
	else
		cMsg += "a inclusão da guia '"
	endif
	cMsg += cNumGui
	cMsg += "' para o mesmo beneficiário, tem certeza que deseja prosseguir?"
endif

Return lRet


//--------------------------------------------------------------------
/*/{Protheus.doc} VerGuiInt

Atualiza os status da BD5, BD6 e BD7 para cancelado quando chamada a função do Portal, do módulo de Digitação de Guias Off-Line
@author Renan Martins
@since 03/2017
@version P12
/*/
//-------------------------------------------------------------------
WSMETHOD VerGuiInt WSRECEIVE UserCode, NumGuiRef, DatGuia, RDACode WSSEND WsNull WSSERVICE PLSXFUN
LOCAL aArea 	:= GetArea()
LOCAL nI		:= 1
LOCAL lRet 	:= .T.
Local cRet		:= ""
Local cNumGuiTrc
Local cMatric

Set Century On
//³Se tem direito para executar o metodo								   ³
If PrtChkUser( ::UserCode , "PLSXFUN", "VerGuiInt" )
	cRet := PlsVrIntAl(::NumGuiRef, ::DatGuia, @cNumGuiTrc, @cMatric, ::RDACode)
	If !Empty(cRet)
		::WSNULL := "false|" + cRet
	Else
		::WSNULL:= "true|S|" +  cNumGuiTrc +'|'+ cMatric
	EndIf
Else
	lRet := .F.
	SetSoapFault( "", "Usuário não autorizado" )
EndIf

RestArea( aArea )
Return lRet

/*/{Protheus.doc} RetProSau
Retorna codigo do profissional de saude para internacao
@author TOTVS Team
@since 06/2017
/*/
WSMETHOD RetProSau WSRECEIVE UserCode,CpfCnpj,CodProf WSSEND WSNULL WSSERVICE PLSXFUN
	local lRetorno := .T.
	
	if( prtChkUser( ::UserCode,"PLSXFUN","RetProSau" ) )
		BB0->( dbSetOrder( 3 ) ) // bb0_filial + bb0_cgc
		if( BB0->( dbSeek( xFilial( "BB0" ) + ::CpfCnpj ) ) )
			::WSNULL := BB0->BB0_CODIGO
		else
			::WSNULL := ::CodProf
		endIf 
	else
		lRetorno := .F.
		SetSoapFault( "", "Usuário não autorizado" )
	endif

return lRetorno

/*/{Protheus.doc} RetCriPROT
Protocolo
@author André Dini
@since 07/2017
/*/
wsMethod RetCriPROT wsReceive UserCode, Busca, TipBusca wsSend WSNULL wsService PLSXFUN
Local lRet	:= .T.
Local cChave := ""

If prtChkUser( ::UserCode ,"PLSXFUN","RetCriPROT" )

	If TipBusca == "UpXML"

		cChave := If( valtype(::Busca) <> 'U', plsintpad() + ::Busca , nil )
		
		::WSNULL := "true|" + PLSRCPRT(cChave, "", .T.,,,,.T.) + "|" + ::Busca
		
	Else
		
		::WSNULL := "true|" + PLSRCPRT("", "", .T.,::Busca,,,.T.) + "|" + ::Busca
		
	EndIf
	
	
Else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf	

Return lRet

/*/{Protheus.doc} RetVldDent
Retorna se existe uma face para determinado dente.
@author andre.dini
@since 04/01/2017
/*/
wsMethod RetVldDent wsReceive UserCode, CodDente, CodPad, CodPro wsSend WSNULL wsService PLSXFUN
Local lRet 		:= .T.
LOCAL aTabDup := PlsBusTerDup(SuperGetMv("MV_TISSCAB", .F. ,"87"))
LOCAL cCodPad := ""
LOCAL cCodPro := ""

If prtChkUser( ::UserCode ,"PLSXFUN","RetVldDent" )
	::WSNULL := "true|"
	
	cCodPad		:= AllTrim(PLSVARVINC('87','BR4',::CodPad))
	cCodPro		:= AllTrim(PLSVARVINC(::CodPad,'BR8', ::CodPro, cCodPad+::CodPro,,aTabDup,@cCodPad))
	
	// Faz a verificação
	If BYL->( MsSeek( xFilial("BYL")+AllTrim(cCodPad)+AllTrim(cCodPro)+Space( TamSX3("BR8_CODPSA")[1]-Len( AllTrim(cCodPro) ) )+CodDente ) )
		::WSNULL += "1"
	Else
		::WSNULL += "0"
	EndIf	
Else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf	

Return lRet


/*/{Protheus.doc} getCboxGen
Retorna os valores para combo box generico.
@author francisco.edcarlo
@since 21/12/2017
/*/
wsMethod getCboxGen wsReceive UserCode, Alias, Dados, Where wsSend WSNULL wsService PLSXFUN
Local lRet 		:= .T.
Local cRet 		:= ""

If prtChkUser( ::UserCode ,"PLSXFUN","getCboxGen" )
	::WSNULL := "true|"
	
	cRet := PLSCBOXGEN(self:Alias, self:Dados, self:Where) 
	
	// Faz a verificação
	If Empty(cRet)
		::WSNULL := "false|"
	Else
		::WSNULL += cRet
	EndIf	
Else
	lRet := .F.
	SetSoapFault( "", "Não autorizado a utilização do metodo" )
EndIf	

Return lRet

