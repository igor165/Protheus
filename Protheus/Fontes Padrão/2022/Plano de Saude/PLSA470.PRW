#include "PROTHEUS.CH"
#include "PLSMGER.CH"
#include "Plsa470.ch"
#include "COLORS.CH"
#DEFINE pMoeda "@E 999,999,999,999.99"

STATIC cPLSTIPPRE 	:= ""
STATIC _oBaixa		:= NIL
STATIC _aMarks		:= NIL
STATIC objCENFUNLGP := CENFUNLGP():New() 
/*/
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
???Programa  ? PLSA470 ? Autor ? Tulio Cesar          ? Data ? 29.05.2000 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Gerar contas a pagar aos credenciados.                     ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
function PLSA470()
Local lDismarca		:= GetNewPar("MV_PLSMLOT","0")=="1" 
LOCAL cSQL        	:= ""
LOCAL aIndices 		:= {}
LOCAL cFilBAF		:= ""     
PRIVATE lMarkt 		:= .T.
PRIVATE cCadastro 	:= STR0001 // "Lotes de Pagamentos da Rede de Atendimento"
PRIVATE aRotina   	:= MenuDef(.F.)
PRIVATE oTex       	:= nil    
PRIVATE nValorGlo  	:= 0

//?????????????????????????????????????????????????????????????????????Ä¿
//? Verifica se o usuario tem alguma operadora parametrizada            ?
//???????????????????????????????????????????????????????????????????????   
If Empty(PLSINTPAD())
    Return
EndIf    
//??????????????????????????????????????????????????????????????????????????????????????????Ä¿
//? Verifica se o parametro MV_PLSMLOT esta ativo = 1 e desmarca todos os marcados           ?
//????????????????????????????????????????????????????????????????????????????????????????????   
If lDismarca
   	cSQL := "UPDATE "+RetSQLName("BAU")+" SET BAU_OK = "
	cSQL := cSQL + "'  '"    
   	cSQL += " WHERE BAU_FILIAL = '"+xFilial("BAU")+"' AND D_E_L_E_T_ = ' '"
   	
   	TCSQLExec(cSQL)
   	DbSelectarea("SX6")
   	
	SX6->(DbSetOrder(1))
	IF SX6->(DbSeek(xFilial("BAU")+"MV_PLSMLOT"))
		putMV( "MV_PLSMLOT","0" )
	EndIf	
Endif
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Testa possibilidade de usar a rotina...                                  ?
//????????????????????????????????????????????????????????????????????????????
If  substr(GETMV("MV_PLTIPE2"),1,1) <> '"' .and.  substr(GETMV("MV_PLTIPE2"),1,1) <> "'" 
    If ! ( upper(substr(GETMV("MV_PLTIPE2"),1,5)) == "EXECB" .Or. upper(substr(GETMV("MV_PLTIPE2"),1,2)) == "U_" )
       MsgStop(STR0106) // "O parametro MV_PLTIPE2 deve conter um comando com sintaxe AdvPl, ou seja, deve conter uma literal entre aspas ou uma chamada de funcao (execblock)."
       Return
    Endif   
Endif         

If ExistBlock("PL470BAF")
	cFilBAF := ExecBlock("PL470BAF",.F.,.F.,cFilBAF)
Endif

BAF->(DbSetOrder(1))
BAF->(MsSeek(xFilial("BAF")))
BAF->(mBrowse(006,001,022,075,"BAF",nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,cFilBAF))
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Fim da funcao principal...                                               ?
//????????????????????????????????????????????????????????????????????????????
Return
/*/
??????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
???Programa  ? PLSA470NEW ? Autor ? Tulio Cesar       ? Data ? 29.05.2000 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Gerar um novo lote de pagamento                            ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
Function PLSA470NEW()
LOCAL   nInd        := 0
LOCAL   cSQL        := ""
LOCAL   cCampos   	:= GetNewPar("MV_PLSFBAU","BAU_CODIGO,BAU_NOME,BAU_CONREG,BAU_TIPPRE")
LOCAL   bEnd      	:= {|| oDlg:End() }
LOCAL   lProcessa 	:= .T. 
LOCAL   aRotiBkp  	:= aClone(aRotina)
LOCAL   aCampos   	:= {}         
LOCAL   aAuxFld   	:= {}
LOCAL   aLegMark  	:= {}
Local 	lRet 		:= .F.
Local 	nI 		:= 0
Local cFilTpPre	:= ""

PRIVATE oMBrwBAU	:= nil
PRIVATE cMarca 		:= ""
PRIVATE cTitulo  	:= STR0008 //"Pagamento a Credenciados"
PRIVATE oDlg        := nil
PRIVATE oBrowse     := nil                         
PRIVATE lCheck   	:= .T.
PRIVATE oCheck      := nil
PRIVATE aTela       := {}
PRIVATE cAno       	:= ""
PRIVATE cMes       	:= ""
PRIVATE dVencto    	:= ctod("")
PRIVATE cFiltro    	:= ""
PRIVATE dDatMvIni  	:= ctod("")
PRIVATE dDatMvFin  	:= ctod("")
PRIVATE dDataPagto 	:= cTod("") 
PRIVATE cLocDigIn  	:= ""
PRIVATE cLocDigFi  	:= ""
PRIVATE cCodPegIn  	:= ""
PRIVATE cCodPegFi  	:= ""
PRIVATE cNumMovIn  	:= ""
PRIVATE cNumMovFi  	:= ""
PRIVATE cCodOpe    	:= PLSINTPAD()
PRIVATE cCdEmpDeS  	:= ""
PRIVATE cCdEmpAteS 	:= ""
PRIVATE cExcessao  	:= ""
PRIVATE lGerPagBlo 	:= .F. 
PRIVATE cLoteImp   	:= ""
PRIVATE cCodDC     	:= ""
PRIVATE cCodDC1    	:= ""
PRIVATE cCodDC2    	:= ""
PRIVATE cCodDC3    	:= ""
PRIVATE cCodDC4    	:= ""
PRIVATE cCodDC5    	:= ""
PRIVATE cCodDC6    	:= ""
PRIVATE cCodNat    	:= ""
PRIVATE lGuiCob    	:= .F.
PRIVATE cCopCre    	:= ""   
PRIVATE cRdaDe     	:= ""
PRIVATE cRdaAte    	:= ""
PRIVATE cGrpPag    	:= ""
PRIVATE lCalcImp   	:= .F.
PRIVATE nApUsDif   	:= 0
PRIVATE cInd       	:= CriaTrab(Nil,.F.)
PRIVATE nIndEsp    	:= 0
PRIVATE cHisTit    	:= ""
PRIVATE cPerg      	:= "PLA470"
PRIVATE cMarkBr    	:= ""
PRIVATE cRdaFiltro 	:= ""
PRIVATE lLimpaTudo	:=.F.
PRIVATE lFirst		:=.T.              
PRIVATE cExcPeg		:= ""
PRIVATE cNoExcPeg		:= "" // Variavel criada para trazer somente as PEG?s não selecionadas. para tratamento de estouro em BD #CAIO MACIENTE
PRIVATE cChaOLP		:= ""
PRIVATE cParOld		:= ""
PRIVATE cProcDe		:= ""
PRIVATE cProcAte		:= ""
PRIVATE lRmbPTU	    := .F.

STATIC lMsgProc		:= .F.

//???????????????????????????????????????????????????????????????????????????
//? Busca parametros...                                                      
//???????????????????????????????????????????????????????????????????????????
if !A470Perg()
	lMsgProc := .F.
   return
endif   

//Controla a mensagem dos campos referente a rotina de processo - MV_PAR33 e MV_PAR34.
lMsgProc := .F.

//???????????????????????????????????????????????????????????????????????????
//? Busca campos que serao exibidos no browse...                             
//???????????????????????????????????????????????????????????????????????????
STORE FIELDS "BAU" TO aAuxFld FOR AllTrim(SX3->X3_CAMPO) $ cCampos

SX3->(DbSetOrder(2))
If SX3->(MsSeek("BAU_OK"))
   aadd(aCampos,{SX3->X3_CAMPO,,SX3->X3_TITULO,SX3->X3_PICTURE})  
Else
   Help("",1,"PLSA470OK")
Endif   

For nInd := 1 To Len(aAuxFld)
    If SX3->(MsSeek(aAuxFld[nInd]))
       aadd(aCampos,{SX3->X3_CAMPO,,SX3->X3_TITULO,SX3->X3_PICTURE})
    Endif   
Next
//???????????????????????????????????????????????????????????????????????????
//? Acessa parametros da opcao...                                            
//???????????????????????????????????????????????????????????????????????????

pergunte(cPerg,.f.)

cAno       := mv_par01
cMes       := mv_par02
dVencto    := iif( empty(mv_par03), PLSCHKNCAL(), mv_par03)
cFiltro    := allTrim(mv_par04)
cHisTit    := mv_par05
dDatMvIni  := mv_par06
dDatMvFin  := mv_par07
cLocDigIn  := mv_par08
cLocDigFi  := mv_par09
cCodPegIn  := mv_par10
cCodPegFi  := mv_par11
cNumMovIn  := mv_par12
cNumMovFi  := mv_par13
cCodOpe    := mv_par14
cCdEmpDeS  := mv_par15
cCdEmpAteS := mv_par16
cExcessao  := mv_par17
lGerPagBlo := mv_par18==1
cLoteImp   := mv_par19
cCodDC1    := mv_par20
cCodDC2    := mv_par21
cCodDC3    := mv_par22
cCodDC4    := mv_par23
cCodDC5    := mv_par24
cCodDC6    := mv_par25
cCodNat    := mv_par26
lGuiCob    := mv_par27==1
cCopCre    := fMntPAR24(mv_par28)
cRdaDe     := mv_par29
cRdaAte    := mv_par30
cGrpPag    := AllTrim(mv_par31)
cProcDe    := mv_par33
cProcAte   := mv_par34

//Caso a Operadora não utilize a regra de PTU de reembolso,
//o preenchimento do Pergunte não irá interferir na rotina.
If GetNewPar("MV_PLRPTU", .F.)
	lRmbPTU	   := mv_par41==1
else
	lRmbPTU := .F.
endIf

lCalcImp   := .F.

if ! empty(cFiltro)
lRet := .T.
endif

If GetNewPar("MV_PLATIOD","0") == '1' .AND. BD7->(Fieldpos("BD7_USDIF")) > 0 
	nApUsDif   := mv_par32
Else
	nApUsDif   := 2
EndIf

aRotina := {	{ STR0002,'BAU->(AxPesqui())'		,  0 , K_Incluir    , 0, Nil},;	//"Pesquisar"	        
				{ STR0148,'A470SldMar()'				,  0 , K_Pesquisar  , 0, .F.},;//"Saldo Selecionado(s)"
            	{ STR0149,'PL470CHVPG()'	,  0 , K_Visualizar , 0, Nil},;	//"Saldo Posicionado"
            	{ STR0150,'A470TitMar()'  			,  0 , K_Incluir    , 0, Nil},;//"Gerar Pgto."
            	{ "Marca/Desmarca todos",'A470Inverte()'  ,  0 , K_Pesquisar    , 0, Nil}}	
//?????????????????????????????????????????????????????????????????????????????
//? Varios pagamentos no mes
//?????????????????????????????????????????????????????????????????????????????
if  getNewPar("MV_PLPGUNI","1") == "3" 
   aadd( aRotina,{ STR0120 ,'A470TitMar(.t.)' , 0 , K_Incluir , 0 , Nil} )	//"Gerar Pgto Selec - Ult Calc Mes"
endIf
//????????????????????????????????????????????????????????????????????????????Ä¿
//? BOPS 102025 - Se o lote de pagamento eh referente a um Lote de Importacao, ?
//?               verifica se todas as guias estao com a fase "3-Pronta".      ?
//?               Caso haja guias que nao estejam prontas, nao gera o lote de  ?
//?               pagamento. Isso se faz necessario para que o Titulo de Con-  ?
//?               testacao seja gerado corretamente, ou seja, no valor total   ?
//?               glosado no Lote de Importacao em questao.                    ?
//??????????????????????????????????????????????????????????????????????????????
if !empty(cLoteImp) .And. !lRmbPTU .AND. GetNewPar("MV_PLFTGLI", .T.) 
	if ! PLSLOTIMP(cLoteImp, @cRdaDe, @cRdaAte, @mv_par29, @mv_par30)
		lProcessa := .F.
	endIf
endIf        
//????????????????????????????????????????????????????????????????????????????Ä¿
//? Ponto de entrada para avaliar a continuidade do processo                   ?
//??????????????????????????????????????????????????????????????????????????????
If ExistBlock("PLS470OK")
   lRet := ExecBLock("PLS470OK",.F.,.F.,{"I",dDataBase})
   If !lRet
      Return
   Endif
EndIf   

If lProcessa
	If  lGuiCob .and. ( BD6->(FieldPos("BD6_NUMSE1")) == 0 .and. BD6->(FieldPos("BD6_NUMTIT")) == 0 )
	    msgalert(STR0009) //"Para tratar apenas as guias ja cobradas, eh necessario ter o campo BD6_NUMSE1 criado e atualizado BD6"
	    lGuiCob := .F.
	Endif             

	If  lGuiCob
	    msgalert(STR0010) //"Atencao: estara sendo gerado pagamento apenas para as guias ja cobradas !"
	Endif             

	If  ! empty(alltrim(cCodDC1) + alltrim(cCodDC2) + alltrim(cCodDC3) + alltrim(cCodDC4) + alltrim(cCodDC5) + alltrim(cCodDC6))
	    cCodDC := alltrim(cCodDC1) + "," + alltrim(cCodDC2)+ "," + alltrim(cCodDC3)+ "," + alltrim(cCodDC4)+ "," + alltrim(cCodDC5)+ "," + alltrim(cCodDC6)
	    cCodDC := strtran(cCodDC,",,",",")
	Else
	    cCodDC := ""
	Endif        
	//???????????????????????????????????????????????????????????????????????????
	//? Executa um filtro no arquivo de credenciados...                          
	//???????????????????????????????????????????????????????????????????????????
	BAU->(dbSetOrder(2))
	BAU->(msSeek(xFilial("BAU")))

	//???????????????????????????????????????????????????????????????????????????
	//? markbrow
	//???????????????????????????????????????????????????????????????????????????
   	oMBrwBAU:= FWMarkBrowse():New()
	oMBrwBAU:SetAlias("BAU")
	oMBrwBAU:SetMenuDef("PLSA470")
	oMBrwBAU:SetDescription("")
	oMBrwBAU:ForceQuitButton()
	oMBrwBAU:SetFieldMark("BAU_OK")
//	oMBrwBAU:SetSemaphore(.T.)
	oMBrwBAU:SetAllMark({ ||  A470Inverte(oMBrwBAU) })
	
	if !empty(cFiltro)
		cFilTpPre := "BAU_FILIAL == '"+xFilial("BAU")+"' .AND. BAU_CODIGO >= '" + cRdaDe + "' .AND. BAU_CODIGO <= '" + cRdaAte + "' .AND. BAU_TIPPRE $ '" + cFiltro + "' "
	else
		cFilTpPre := "BAU_FILIAL == '"+xFilial("BAU")+"' .AND. BAU_CODIGO >= '" + cRdaDe + "' .AND. BAU_CODIGO <= '" + cRdaAte + "' "
	endif
	
	if !empty(cCopCre)
		cFilTpPre += " .AND. BAU_COPCRE $ '" + cCopCre + "' "
	endif

	If !empty(cGrpPag)		
		cFilTpPre += " .AND. BAU_GRPPAG $ '" + cGrpPag + "'"		
	endif
	
	If ExistBlock("PL470MAK")
		cFilTpPre :=  ExecBlock("PL470MAK",.F.,.F.,{cFilTpPre})
	Endif
	
	oMBrwBAU:SetFilterDefault( cFilTpPre )
	
	//-------------------------------------------------------------------
	//  LGPD
	//-------------------------------------------------------------------
	objCENFUNLGP:useLogUser()

	// Registra a marca definida para o browse. Esta marca ser? usada no processamento.
	cMarca := oMBrwBAU:cMark
	oMBrwBAU:Activate()
	
	If cMarca == nil .and. oMBrwBAU:cMark <> nil
		cMarca := oMBrwBAU:cMark
	Endif   
	
	If cMarca <> nil
		// Desmarca tudo que foi marcado. Devido ao controle de semaforo do FWMarkBrowse não podemos usar
		// O update direto no banco. 
		cSql := "Select R_E_C_N_O_ REGISTRO FROM "+RetSqlName("BAU")+" WHERE BAU_FILIAL = '"+xFilial("BAU")+"' "
		cSql += "AND BAU_OK = '"+cMarca+"' "
		cSql += "AND D_E_L_E_T_ = ' '"
		cSQL := ChangeQuery(cSQL)
		dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cSQL),"TRB1",.F.,.T.)
		While !TRB1->( Eof() )
			BAU->( dbGoto(TRB1->REGISTRO) )
			
			// Desmarca
			oMBrwBAU:MarkRec()
			
			TRB1->( dbSkip() )
		Enddo		
		TRB1->( dbCloseArea() )
	Endif		
	//???????????????????????????????????????????????????????????????????????????
	//? Fim da Rotina Principal                                                  
	//???????????????????????????????????????????????????????????????????????????
endIf

aRotina  := aclone(aRotiBkp)

Return (lRet)
/*
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Í»??
???Programa  ?A470Inverte  ?Autor  ?Microsiga           ? Data ?  22/08/15???
?????????????????????????????????????????????????????????????????????????Í¹??
???Desc.     ?  Fun??o para marcar e desmarcar todos da MarkBrowse        ???
?????????????????????????????????????????????????????????????????????????Í¼??
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
*/
function A470Inverte()
Local nReg 	 := BAU->(Recno())
BAU->( dbgotop() ) 

While !BAU->(Eof())
	// Marca ou desmarca. Este metodo respeita o controle de semaphoro. 
	oMBrwBAU:MarkRec()
	
	BAU->(dbSkip())
Enddo

BAU->(dbGoto(nReg))
oMBrwBAU:oBrowse:Refresh(.t.)

Return .T.

/*/
??????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
??? Funcao   ? A470MARK? Autor ? Tulio Cesar          ? Data ? 06.06.2000 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Marca/Desmarca todos os itens do Browse...                 ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
Static Function A470Mark(lObj)
LOCAL cSQL
DEFAULT lObj := .T.

If  lObj
    MsProcTXT(If(lCheck,STR0016,STR0017)+STR0018) //"Marcando"###"Desmarcando"###" Todos os Credenciados ..." //"Marcando"###"Desmarcando"###" Todos os Credenciados ..."
Endif    

cSQL := "UPDATE "+RetSQLName("BAU")+" SET BAU_OK = "
If !lCheck .and. BAU->BAU_OK=cMarkBr
   cSQL := cSQL + "'  '"    
Elseif lCheck .and. Empty(BAU->BAU_OK)  
   cSQL := cSQL + "'"+cMarkBr+"'"
Elseif lCheck .and. BAU->BAU_OK<>cMarkBr  
    msginfo(STR0151)
Endif                                               
cSQL += " WHERE BAU_FILIAL = '"+xFilial("BAU")+"' AND D_E_L_E_T_ = ' '"
TCSQLExec(cSQL)

BAU->(DbGoTop())
BAU->(MsSeek(xFilial("BAU")))

If  lObj
    oBrowse:oBrowse:Refresh()
Endif    

Return
/*/
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
??? Funcao   ? A470PERG ? Autor ? Tulio Cesar         ? Data ? 06.06.2000 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Acessa pergunta no SX1 para a opcao...                     ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
Static Function A470Perg()
LOCAL aOldArea := GetArea()
LOCAL lRet     := .F.

lRet := pergunte("PLA470",.T.)

If lRet                       
   	cAno       := mv_par01
   	cMes       := mv_par02
   	dVencto    := iif( empty(mv_par03), PLSCHKNCAL(), mv_par03)
   	cFiltro    := allTrim(mv_par04)
   	dDatMvIni  := mv_par06
   	dDatMvFin  := mv_par07
   	cLocDigIn  := mv_par08
   	cLocDigFi  := mv_par09
   	cCodPegIn  := mv_par10
   	cCodPegFi  := mv_par11
   	cNumMovIn  := mv_par12
   	cNumMovFi  := mv_par13
   	cCodOpe    := mv_par14
   	cCdEmpDeS  := mv_par15
   	cCdEmpAteS := mv_par16
   	cExcessao  := mv_par17
   	lGerPagBlo := mv_par18==1
   	cLoteImp   := mv_par19
   	cCodDC1    := mv_par20
   	cCodDC2    := mv_par21
   	cCodDC3    := mv_par22
   	cCodDC4    := mv_par23
   	cCodDC5    := mv_par24
   	cCodDC6    := mv_par25	   
   	cCodNat    := mv_par26
   	lGuiCob    := mv_par27==1
   	cCopCre    := fMntPAR24(mv_par28)
   	cRdaDe     := mv_par29
   	cRdaAte    := mv_par30
   	cGrpPag    := AllTrim(mv_par31)
	cProcDe    := mv_par33
	cProcAte   := mv_par34
   
	If GetNewPar("MV_PLATIOD","0") == '1' .AND. Fieldpos("BD7_USDIF") > 0
		nApUsDif   := mv_par32
	Else
		nApUsDif   := 2
	EndIf
	
	If (!(empTy(mv_par03)) .AND. mv_par03 < msdate())
	   MsgStop("Data de Vencimento menor que a data de emissão ou em branco")
	   Return(.F.)
	Endif
	
	If ! Empty(aOldArea[1])
		RestArea(aOldArea)
	Endif
	
	If EMPTY(cProcDe) .OR. EMPTY(cProcAte)
		cFiltro := allTrim(mv_par04)
	EndIf
	
	msAguarde({|| A470IND(cFiltro,.T.,,cCopCre,cRdaDe,cRdaAte,cGrpPag, cProcDe, cProcAte, cCodOpe, cCodPegIn, cCodPegFi, .T.)})
	
	cHisTit  := mv_par05   
Endif   

Return(lRet)
/*/
??????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
??? Funcao   ? A470IND  ? Autor ? Tulio Cesar         ? Data ? 08.06.2000 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Remonta indice/filtro no arquivo de fornecedores...        ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
static Function A470IND(cFiltro,lMsg,lImpFol,cCopCre,cRdaDe,cRdaAte,cGrpPag, cProcDe, cProcAte, cCodOpe, cCodPegIn, cCodPegFi, lExbAc50)
LOCAL cFor 		:= "BAU_FILIAL = '"+xFilial("BAU")+"'"
LOCAL cMVPLSRDAG	:= GetNewPar("MV_PLSRDAG","999999")
LOCAL	aCodRda  	:= {}
LOCAL	acProc		:= {}
LOCAL cRda		:= ""
LOCAL cSQL		:= ""
LOCAL cProces		:= ''
LOCAL nCont		:= 0

DEFAULT lImpFol  := .F.
DEFAULT cCopCre  := ""
DEFAULT cRdaDe   := ""
DEFAULT cRdaAte  := Replicate("Z",Len(BAU->BAU_CODIGO))
DEFAULT cGrpPag  := ""
DEFAULT cCodOpe  := ""
DEFAULT cCodPegIn := ""
DEFAULT cCodPegFi := ""
DEFAULT cProcDe  := ""
DEFAULT cProcAte := "ZZZZZZZZ"
Default lExbAc50	:= .F.

If ! Empty(cFiltro)
	cFor := cFor + " .And. Alltrim(BAU_TIPPRE) $ '" + cFiltro + "' .And. BAU_CODIGO <> '" + cMVPLSRDAG + "'"
Else
	cFor := cFor + " .And. BAU_CODIGO <> '" + cMVPLSRDAG + "'"
Endif

// Filtro por processo INICIO - Quem informa de branco a zzz para peg e processo nao usa processo
If !( Empty(cCodPegIn) .And. cCodPegFi == "ZZZZZZZZ" ) .Or. !( Empty(cProcDe) .And. cProcAte == "ZZZZZZZZZZ" )
	If EMPTY(cCodOpe)
		msgAlert("Preencha o c?digo da operadora.")
		Return .F.
	ElseIf !EMPTY(cCodOpe) 

		//???????????????????????????????????????????????????????????????????????????
		//? query
		//???????????????????????????????????????????????????????????????????????????
		cSql := " SELECT DISTINCT BCI_CODRDA "
		cSql += "  FROM "+BCI->(retSQLName("BCI"))
		cSql += " WHERE BCI_FILIAL = '"+xFilial("BCI")+"' "
		cSql += "   AND BCI_CODOPE = '" + cCodOpe + "' "
		If !EMPTY(cCodPegFi)
			cSql += "   AND BCI_CODPEG BETWEEN '"+cCodPegIn+"' AND '"+cCodPegFi+"' "
		ElseIf !EMPTY(cProcAte)
			cSql += "   AND BCI_PROCES BETWEEN '"+cProcDe+"' AND '"+cProcAte+"' "
		EndIf
		cSql += "   AND BCI_CODRDA BETWEEN '"+cRdaDe+"' AND '"+cRdaAte+"' "
		If GETNEWPAR("MV_STATISS",.F.) 
			cSql += "   AND BCI_STTISS = '3' "
		EndIf
		cSql += " AND D_E_L_E_T_ = ' ' "
		//???????????????????????????????????????????????????????????????????????????
		//? executa query
		//???????????????????????????????????????????????????????????????????????????
		cSQL := ChangeQuery(cSQL)
		dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cSQL),"TRBFIL",.F.,.T.)

		Do While !TRBFIL->(Eof())
			aAdd(aCodRda,TRBFIL->BCI_CODRDA)
			TRBFIL->(DbSkip())
		EndDo
		
		TRBFIL->(DbCloseArea())
		If !EMPTY(aCodRda)
			nMax := 50
			nLen := len(aCodRda)
			If nLen > nMax
				if lExbAc50  // Como ? rotina de filtro, deve exibir apenas na tela inicial. Depois de eixibir os resultados, caso marque apenas um titulo para gerar, exibia novamente a mensagem
					MsgAlert(STR0175 + Chr(13)+;  //"O Filtro por PEG/Protocolo resultou em mais de 50 RDAs. Refine o filtro PEG/Processo ou retire-o."
								STR0176 + " ' " + cRdaDe + " ' " + STR0177 + " ' " + cRdaAte + " ' " ) // " Ser?o exibidas as RDAs de " # " at? "
				endif
				cFor := cFor + " .And. BAU_CODIGO >= '" + cRdaDe + "' .And. BAU_CODIGO <= '" + cRdaAte + "'"
			Else
				cFor := cFor + " .AND. "
				For nCont := 1 To nLen
					if nCont < len(aCodRda)
						cFor := cFor + " BAU_CODIGO = '" + aCodRda[nCont] + "' .OR. "
					Else
						cFor := cFor + " BAU_CODIGO = '" + aCodRda[nCont] + "' "
					EndIf
				Next
			EndIf
			//cFor := cFor + " .AND. BAU_CODIGO $ (" +cSql+ ") "
		ElseIf ! Empty(cRdaDe+cRdaAte)
			cFor := cFor + " .And. BAU_CODIGO >= '" + cRdaDe + "' .And. BAU_CODIGO <= '" + cRdaAte + "'"
		EndIf
	EndIf
ElseIf ! Empty(cRdaDe+cRdaAte)
	cFor := cFor + " .And. BAU_CODIGO >= '" + cRdaDe + "' .And. BAU_CODIGO <= '" + cRdaAte + "'"
EndIf

// Filtro por processo FIM
    
If  lImpFol
	cFor := cFor + " .And. BAU_CALIMP == '3'"
Endif
If ! Empty(cCopCre)
	cFor := cFor + " .And. BAU_COPCRE $ '" + cCopCre + "'"
Endif
                                                   
If ! Empty(cGrpPag)
	If BAU->(FieldPos("BAU_GRPPAG")) > 0
		cFor := cFor + " .And. BAU_GRPPAG $ '" + cGrpPag + "'"
	Endif
EndIf

If lMsg
	/*Ponto de Entrada para a Filtragem inicial das Operadoras atrav?s 
	do Bot?o Novo Lote Pagto  */
	If ExistBlock("PL470MAK")
		cFor :=  ExecBlock("PL470MAK",.F.,.F.,{cFor})
	Endif
Else
	/*Ponto de Entrada colocado no Else pq essa funcao A470IND eh 
	chamado em dois momentos da rotina, e o momento correto para
	alterar o filtro eh na segunda chamada, onde o lMsg eh passado
	como .F. */
	If ExistBlock("PL470FIL")
		cFor := ExecBlock("PL470FIL",.F.,.F.,{cFor})
	Endif
Endif

BAU->(dbSetOrder(1))
BAU->(dbSetFilter({||&cFor},cFor))
BAU->(msSeek(xFilial("BAU")))

Return
/*/
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
??? Funcao   ?A470SLDMAR? Autor ? Tulio Cesar         ? Data ? 09.06.2000 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Exibe o saldo em determinado mes/ano base (Marcados)       ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
function A470SldMar()

msAguarde({|| processaMrk()}, "", STR0147, .T.)

Return nil
/*/
??????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
??? Funcao   ?A470SLDMAR? Autor ? Tulio Cesar         ? Data ? 09.06.2000 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Exibe o saldo em determinado mes/ano base (Marcados)       ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
function processaMrk()
LOCAL aOldArea 	 := GetArea()
LOCAL aSaldo   	 := {}
LOCAL aSoma    	 := {0}
LOCAL nIndBAU  	 := BAU->(IndexOrd())
LOCAL nRecBAU  	 := BAU->(Recno())
LOCAL cCalcImp   := ""
LOCAL aLancPagto := {}
   
// Registra a marca definida para o browse. Esta marca ser? usada no processamento.
cMarca    := oMBrwBAU:cMark
nValorGlo := 0   // esse item foi adicionado para zerar a varivel pois se ficarmos na mesma tela e tirar um novo saldo SELECIONADO ira trazer o saldo da consulta aterior

if BuscaRDAPag(cCodOpe,cMarca,cRDAde,cRDAAte,cGrpPag,cFiltro,cCopCre,cCodPegIn,cCodPegFi,cProcDe,cProcAte)

   while ! TRBBAU->(Eof())
         
		//Despreza RDA com BAU_CALIMP nao preenchido                               
		if Empty(TRBBAU->BAU_CALIMP)

		    MsgInfo("Rede de atendimento c?digo " + TRBBAU->BAU_CODIGO + " sem Forma de Pagto. (BAU_CALIMP) preenchida. não será processada!")
            TRBBAU->(DbSkip())

            loop                              
		endIf

		//Exibe mensagem informativa...                                            
		msProcTXT(STR0020+TRBBAU->BAU_CODIGO+" - "+AllTrim(TRBBAU->BAU_NOME)+"...") //"Saldo -> "
         
		cCalcImp := if(Empty(TRBBAU->BAU_CALIMP),"2",TRBBAU->BAU_CALIMP)

		aSaldo   := PLSLDCRE(TRBBAU->BAU_CODIGO,cAno,cMes,dDatMvIni,dDatMvFin,cLocDigIn,cLocDigFi,cCodPegIn,;
                              cCodPegFi,cNumMovIn,cNumMovFi,cCodOpe,TRBBAU->BAU_CODSA2,TRBBAU->BAU_LOJSA2,aLancPagto,cCalcImp,;
                              cCdEmpDeS,cCdEmpAteS,cExcessao,cLoteImp,cCodDC,/*lCalcImp*/,/*cCodNat*/,/*lGuiCob*/,;
                              /*lPgtDiv*/,/*lGerLot*/,/*lMudUs*/,/*nNewU*/,/*nApUsDif*/,/*lAtuGui*/,/*cOpeLote*/,;
                              /*cLote*/,dDataPagto,cExcPeg,,,cNoExcPeg,lRmbPTU)
		if aSaldo[1]
			aSoma[1] := aSoma[1] + aSaldo[4,1]
		endif   

		If len(aSaldo) > 10
			nValorGlo += aSaldo[13]
		Else                                                                                	
			nValorGlo := 0
		EndIf
					 
   TRBBAU->(DbSkip())
   endDo

   //Exibe Saldo dos Marcados...                                              
   if aSoma[1] < 0 
      msgInfo(STR0021+TransForm(ABS(aSoma[1]),pMoeda)+ Chr(13)+ STR0022 + CHR(13)+ CHR(10)+; 	//"VALOR BRUTO ......... :"pMoeda" (Debito)"
      "VALOR GLOSA ......... : " + TransForm(ABS(nValorGlo),pMoeda))							//"VALOR GLOSA ......... :"nValorGlo"      "
   else
      msgInfo(STR0021+TransForm(ABS(aSoma[1]),pMoeda)+ Chr(13)+ STR0023 + CHR(13)+ CHR(10)+;	//"VALOR BRUTO ......... :"pMoeda" (Credito)"
      "VALOR GLOSA ......... :" + TransForm(ABS(nValorGlo),pMoeda))								//"VALOR GLOSA ......... :"nValorGlo"       "
   endIf    

else
	Help("",1,"BuscaRDAPag",,STR0024,1) //"Nao foram selecionados credenciados"
endIf   

TRBBAU->(DbCloseArea())

nValorGlo := 0
BAU->(dbGoTo(nRecBAU))
BAU->(dbSetOrder(nIndBAU))

//Restaura area antiga...                                                  
if ! Empty(aOldArea[1])
   RestArea(aOldArea)
endif
   
return

/*/
??????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
??? Funcao   ?BuscaRDAPag? Autor ? Tulio Cesar         ? Data ? 09.06.2000 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Busca as RDAs selecionadas                                 ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
Static Function BuscaRDAPag(cCodOpe,cMarca,cRDAde,cRDAAte,cGrpPag,;
		cFiltro,cCopCre,cCodPegIn,cCodPegFi,cProcDe,cProcAte,lCount,nTotRda)

LOCAL cMVPLSRDAG := GetNewPar("MV_PLSRDAG","999999")
LOCAL cSql		:= ""
LOCAL cFrom		:= ""
LOCAL cWhere	:= ""
Local lRet		:= .F.
LOCAL cAlias	:= "TRBBAU"

Local nFor		:= 0
Local aCopCre	:= {}
Local cRetCopCre	:= ""

DEFAULT lCount := .F.
DEFAULT nTotRda := 0

//???????????????????????????????????????????????????????????????????????????
//? query
//???????????????????????????????????????????????????????????????????????????
cSql := " SELECT "
cSql += " BAU.R_E_C_N_O_ RECNO,BAU_CODIGO,BAU_CALIMP,BAU_NOME,BAU_CODSA2,BAU_LOJSA2,BAU_NREDUZ,BAU_DIAPGT,BAU_OK "
cFrom :=   "FROM " + retSQLName("BAU") + " BAU "
cWhere += "WHERE BAU_FILIAL = '"+xFilial("BAU")+"' "
cWhere +=   "AND BAU_CODIGO <> '" + cMVPLSRDAG + "' "
cWhere +=   "AND BAU_OK = '" + cMarca + "' "
If !EMPTY(cRDAAte)
	cWhere += "AND BAU_CODIGO BETWEEN '"+cRDAde+"' AND '"+cRDAAte+"' "
EndIf
If !EMPTY(cGrpPag)
	cWhere += "AND BAU_GRPPAG IN "+ FormatIn(Strtran(cGrpPag, " ", ''), ",") +" "
EndIf
If !EMPTY(cFiltro)
	cFiltro := "'" + cFiltro + "'"
	cFiltro := STRTRAN(cFiltro, ",", "','")
	cWhere += "AND BAU_TIPPRE IN ("+cFiltro+") "
EndIf
If !EMPTY(cCopCre)
	aCopCre := Separa(cCopCre, ",")
	for nFor := 1 to len(aCopCre)
		cRetCopCre += "'" + aCopCre[nFor] + "',"
	next nFor
	cRetCopCre := left(cRetCopCre, (len(cRetCopCre)-1))

	cWhere += "AND BAU_COPCRE IN ("+cRetCopCre+") "
EndIf
cWhere +=   "AND BAU.D_E_L_E_T_ = ' ' "

//==================
//? executa query
//==================
cSql += cFrom + cWhere
If Select((cAlias)) > 0
	(cAlias)->(DbCloseArea())
EndIf
cSQL := changeQuery(cSQL)
dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cSQL),cAlias,.F.,.T.)

If (cAlias)->(Eof())
	lRet := .F.
Else
	lRet := .T.
EndIf
If lCount
	cSql := " SELECT COUNT(1) TOTRDA "
	cSql += cFrom + cWhere
	cSQL := changeQuery(cSQL)
	dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cSQL),"TRBCNT",.F.,.T.)
	nTotRda := TRBCNT->TOTRDA
	TRBCNT->(DbCloseArea())
Else
	nTotRda := 0
EndIf

Return lRet

/*/
??????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
??? Funcao   ?A470SLDMAR? Autor ? Tulio Cesar         ? Data ? 09.06.2000 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Exibe o saldo em determinado mes/ano base (Marcados)       ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
Function A470TitMar(lUltCalc, lAutoma)
Default lAutoma		:= .F.
 
If lFirst
	If !lAutoma
		Processa( {|| ProcTite(lUltCalc, lAutoma) }, "Aguarde...", STR0147,.F.)
	Else
		ProcTite(lUltCalc, lAutoma)
	EndIf
Endif	

Return(.T.)
/*/
??????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
??? Funcao   ?A470TitMAR? Autor ? Tulio Cesar         ? Data ? 09.06.2000 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Gerar Titulo em determinado mes/ano base (Marcados)        ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
Function ProcTite(lUltCalc, lAutoma)
Local nH			:= 0
Local nPos			:= 0
Local nPosLiq		:= 0
Local nBruCalc		:= 0
Local nLiqCalc		:= 0
Local cNumLote		:= ""
Local cExp			:= ""
Local cVar       	:= ""
Local cTitulo		:= ""
Local aOldArea		:= {}
Local nIndBAU		:= 0
Local aRetorno		:= {}
Local nQtdOK		:= 0
Local nQtdNO		:= 0
Local aCrit 		:= {}
Local aResult		:= {}
Local nNum01		:= 0
Local nNum02		:= 0
Local cNumero		:= ""
Local cPrevixo		:= ""
Local nAux			:= 0
Local dVencReal		:= stod("")               
Local nValBruAcu	:= 0
Local nValIrAcu		:= 0
Local nValLiqAcu	:= 0
Local cMVPLSRDAG 	:= GetNewPar("MV_PLSRDAG","999999")
Local nSeq			:= 0
Local cIdeRot		:= ""
Local cCodCha		:= ""
Local cCamSX1		:= ""
Local dPDat      	:= date()
Local cPHorini   	:= time()
Local nHorIni    	:= Seconds()
Local aRecnBce	 	:= {}	
Local i			 	:= 0
Local nY         	:= 0
Local nTit       	:= 0   
Local nVlrServ   	:= 0
Local nVlrTx	 	:= 0
Local nTotRda		:= 0
Local nRecBAU		:= 0
Local cCalcImp    	:= if(BAU->(FieldPos("BAU_CALIMP"))>0,BAU->BAU_CALIMP,"2")
Local nRecNewBAF	:= 0
Local nVlrGloAne 	:= 0
Local lNewCal		:= GetNewPar("MV_PLCALPG", "1") == "2"
Local cParcela		:= space(TamSx3("E2_PARCELA")[1])
Local nHNumPag		:= 0
Local nTenta		:= 0
Local cChavePri 	:= "PLSA470.SMF"
Local cChaveSem 	:= ""
Local cFilRDA	 	:= "BAU_FILIAL == '"+xFilial("BAU")+"' .AND. BAU_CODIGO >= '" + cRdaDe + "' .AND. BAU_CODIGO <= '" + cRdaAte + "'"
Local cTipTitInt	:= ""
Local lPLSUni		:= GetNewPar("MV_PLSUNI", "0") == "1"
Local cPLPREND 		:= GetNewPar("MV_PLPREND","")
Local cPLTIPND 		:= GetNewPar("MV_PLTIPND","")
Local cPLPREE2 		:= GetNewPar("MV_PLPREE2","")
Local cPLTIPE2 		:= GetNewPar("MV_PLTIPE2","")
Local cPLNUME2 		:= GetNewPar("MV_PLNUME2","")
Local aRetTotal     := {}
Local aTitBru		:= {}
Local aTitLiq		:= {}

Default lUltCalc 	:= .F. 
Default lAutoma		:= .F.

//??????????????????????????????????????????????????????????????????????????Ä¿
//? Pede a confirmacao do usuario...                                         ?
//????????????????????????????????????????????????????????????????????????????
If !lAutoma .AND. ! MsgYesNo(STR0025) //"Confirma a geracao do pagamento com base nos parametros informados"
   Return(.F.)
Endif   

// Registra a marca definida para o browse. Esta marca ser? usada no processamento.
If Empty(cMarca) //TODO Altera??o Claudio
	cMarca := oMBrwBAU:cMark
EndIf

IncProc('Iniciando...')
nH := PLSAbreSem(cChavePri)

IncProc('Gerando n?mero do lote de pagamento...')

cNumLote := PLSA625Cd("BAF_NUMLOT","BAF",1,"BAF->(BAF_CODOPE+BAF_ANOLOT+BAF_MESLOT)",cCodOpe+cAno+cMes)

aOldArea := GetArea()
nIndBAU  := BAU->(IndexOrd())
nRecBAU  := BAU->(Recno())
nQtdOK   := 0
nQtdNO   := 0
aCrit    := {}
aResult  := {}
nNum01   := 1
nNum02   := 1

SE2->(dbSetOrder(1))
BAU->(DbClearFilter())
BAU->(RetIndex("BAU"))
BAU->(DbSetOrder(1))

If BuscaRDAPag(cCodOpe,cMarca,cRDAde,cRDAAte,cGrpPag,cFiltro,cCopCre,cCodPegIn,cCodPegFi,cProcDe,cProcAte,.T.,@nTotRda) 
	
	lFirst := .f.
	
	// TSYLYO - reestrutura??o do controle de transa??o:
	// Agora o primeiro passo ? gerar o lote, depois ele ser? incrementador sob demanda.
	BAF->(RecLock("BAF",.T.))
		BAF->BAF_FILIAL	:= xFilial("BAF")
		BAF->BAF_CODOPE 	:= cCodOpe
		BAF->BAF_NUMLOT 	:= cNumLote
		BAF->BAF_ANOLOT 	:= cAno
		BAF->BAF_MESLOT 	:= cMes
		BAF->BAF_OPESIS 	:= PLSRtCdUsr()
		BAF->BAF_NOMOPE 	:= PLRETOPE()
		BAF->BAF_DTDIGI 	:= Date()
		BAF->BAF_HRDIGI 	:= StrTran(Time(),":","")
		BAF->BAF_GRUPOS 	:= cFiltro
		BAF->BAF_HISTIT 	:= cHisTit
		BAF->BAF_DTMVDE 	:= dDatMvIni
		BAF->BAF_DTMVAT 	:= dDatMvFin
		BAF->BAF_LCDGDE 	:= cLocDigIn
		BAF->BAF_LCDGAT 	:= cLocDigFi
		BAF->BAF_PEGDE  	:= cCodPegIn
		BAF->BAF_PEGATE 	:= cCodPegFi
		BAF->BAF_NMMVDE 	:= cNumMovIn
		BAF->BAF_NMMVAT 	:= cNumMovFi
		
		If BAF->(FieldPos("BAF_SEQIMP")) > 0
			BAF->BAF_SEQIMP := cLoteImp
		EndIf
		If BAF->(FieldPos("BAF_DATPAG")) > 0
			BAF->BAF_DATPAG := dDataPagto
		EndIf           	
	BAF->( MsUnlock() )
	
	// Permite novos usu?rios conectarem na rotina ap?s seleção do usu?rio e cria??o da capa de lote 
	PLSFechaSem(nH,cChavePri)
	
	// Registra o recno da BAF para garantir que ele estar? posicionado mais abaixo.
	nRecNewBAF := BAF->( Recno() )
   	//???????????????????????????????????????????????????????????????????????????
   	//? Quantidade de registros
   	//???????????????????????????????????????????????????????????????????????????
	nRecBAU := BAU->(recno())

	nQtdNO := 0
	aCrit	:= {}
   	//???????????????????????????????????????????????????????????????????????????
   	//? Set regua
   	//???????????????????????????????????????????????????????????????????????????
   ProcRegua(nTotRda)
   	//???????????????????????????????????????????????????????????????????????????
   	//? Processa rda
   	//???????????????????????????????????????????????????????????????????????????
   While ! TRBBAU->(Eof())// .And. BAU->BAU_FILIAL == xFilial("BAU") .and. BAU->BAU_CODIGO <= cRdaAte
	
		// Redefine as v?riaveis de totais
		nValBruAcu	:= 0
		nValLiqAcu	:= 0
		nValIrAcu	:= 0
		nQtdOK 		:= 0
		nQtdNO		:= 0
	   	nVlrServ	:= 0     
		nVlrTx 		:= 0	   
		nTit		:= 1		//Padrao e gerar um titulo

		//??????????????????????????????????????????????????????????????????????????Ä¿
		//? Exibe mensagem informativa...                                            ?
		//????????????????????????????????????????????????????????????????????????????
		IncProc('Apurando Prestador: '+TRBBAU->BAU_CODIGO+" - "+allTrim(TRBBAU->BAU_NREDUZ))

		BAU->(DbSetOrder(1))
		BAU->(MsSeek(xfilial("BAU")+Alltrim(TRBBAU->BAU_CODIGO)))
		//??????????????????????????????????????????????????????????????????????????Ä¿
		//? Despreza RDA fora do intervalo informado nos parametros iniciais         ?
		//????????????????????????????????????????????????????????????????????????????
		if qtdVldRda(cRdaDe,cRdaAte,cGrpPag,cMVPLSRDAG,cFiltro,cCopCre,cMarca,lGerPagBlo,dVencto,aCrit,@nQtdNO)
			TRBBAU->(DbSkip())
			loop
		endIf
     	//??????????????????????????????????????????????????????????????????????????Ä¿
     	//? Se pagamento de lote de intercambio, verifica se gera Fatura e RDC       ?
     	//????????????????????????????????????????????????????????????????????????????
	 	If lPLSUni .AND. ! Empty(cLoteImp)
	 		BRJ->(DbSetOrder(1))
			If BRJ->(DbSeek(xFilial("BRJ")+cLoteImp,.F.))     
				Do While !BRJ->(Eof()) .And. BRJ->(BRJ_FILIAL+BRJ_CODIGO) == xFilial("BRJ")+cLoteImp
					If BRJ->BRJ_REGPRI == "1"  //Registro Principal e Status "a Faturar"
						cTipTitInt := BRJ->BRJ_TPCOB 
						If Empty(cTipTitInt)
							cTipTitInt := "2"//Se vazio, assume fatura que e o padrao
						EndIf
						If BRJ->BRJ_TPCOB == "3" //Ambos, gero dois titulos
							nTit := 2  
						EndIf
						Exit	
					EndIf  
					BRJ->(DbSkip())
		        EndDo
			EndIf	 
	 	EndIf
		
		// TSYLYO - reestrutura??o do controle de transa??o:
		// Agora a transa??o ? por prestador. Cada prestador processado abre uma transa??o, gera o titulo, 
		// atualiza os flags de faturamento, incrementa os totais do lote e depois encerra a transa??o. 
		// O ciclo se repete a cada prestador. Este processo tornar? a gera??o do lote mais r?pida e produtiva.		
		Begin Transaction

			//??????????????????????????????????????????????????????????????????????????Ä¿
			//? Quando for A500 do tipo '3'-Ambos, gero dois titulos: NDC + Taxas        ?
			//????????????????????????????????????????????????????????????????????????????
			For nY := 1 to nTit
				cCodNat := mv_par26 //Restaura a natureza informada no pergunte
				//??????????????????????????????????????????????????????????????????????????Ä¿
				//? Bu)sca dados dos parametros...                                           ?
				//????????????????????????????????????????????????????????????????????????????
				If cTipTitInt == '3' .And. nY == 1
					cPrefixo := cPLPREND
					cTipo    := cPLTIPND
					cCodNat  := mv_par39
				Else
					cPrefixo := cPLPREE2
					cTipo    := cPLTIPE2
					cCodNat	 := mv_par26
				EndIf
				cNumero  := cPLNUME2
                cNumero  := Eval({|| &cNumero  })	
                cPrefixo 	:= Eval({|| &cPrefixo })
	         	cTipo		:= Eval({|| &cTipo })
	         	 	
				/// Abre controle de sem?foros da numera??o do Titulo
				cChaveSem:= "PLSA470E2"+BAF->(BAF_CODOPE+BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)+TRBBAU->BAU_CODIGO+".SMF"
				nHNumPag := PLSAbreSem(cChaveSem)

				While ( SE2->(DbSeek(xFilial("SE2")+cPrefixo+cNumero+cParcela+cTipo,.F.)) .or.;
					nHNumPag == 0 ) .and. nTenta < 200
					
					cNumero := Soma1(cNumero)
					/// Abre controle de sem?foros da numera??o do Titulo
					PLSFechaSem(nHNumPag,cChaveSem)
					nHNumPag := PLSAbreSem(cChaveSem)
					nTenta ++
					 
				EndDo
				
				// Se não conseguiu um numero disponivel, sai do Loop registrando a critica
				If SE2->(Found()) .and. nHNumPag == 0 .and. nTenta >= 200		
				
					aCrit := {"B","Prefixo+Numero+Parcela+Tipo+Fornecedor+Loja ja existe",0}
				
					/// Fecha controle de sem?foros da numera??o do Titulo
					PLSFechaSem(nHNumPag,cChaveSem)
					Exit
				EndIf
				
	         // Desfaz o filtro para nao gerar um registro no BAU com o Codigo UNIAO
	         nIndBAU  := BAU->(IndexOrd())
	         nRecBAU  := TRBBAU->(RECNO)                       
	         
	         If ! Empty(dVencto)
	            dVencReal := dVencto
	         Elseif !(lNewCal)
	            nAux := TRBBAU->BAU_DIAPGT
	            While .T.
	                  dVencReal := ctod(StrZero(nAux,2)+"/"+cMes+"/"+cAno)
	                  If ! Empty(dVencReal)
	                     Exit
	                  Endif
	                  nAux --   
	            Enddo
	         else
	         	dVencReal := PLSCHKNCAL()
	         Endif   
	         
			 BAU->(DbGoTo(nRecBAU))
			 
			 IncProc('Gerando Pagamento Prestador: '+TRBBAU->BAU_CODIGO+" - "+allTrim(TRBBAU->BAU_NREDUZ))
			 
			 aRetorno := PLGERCRE(cCodOpe,TRBBAU->BAU_CODIGO,TRBBAU->BAU_CODSA2,TRBBAU->BAU_LOJSA2,cAno,cMes,dVencReal,;
									cPrefixo,cNumero,cTipo,cHisTit,cCodOpe,cAno+cMes+cNumLote,;
									dDatMvIni,dDatMvFin,cLocDigIn,cLocDigFi,cCodPegIn,cCodPegFi,cNumMovIn,cNumMovFi,cCodOpe,/*aLancPagto*/,;
									cCdEmpDeS,cCdEmpAteS,cExcessao,lGerPagBlo,cLoteImp,cCodDC,lCalcImp,cCodNat,lGuiCob,lUltCalc,;
									nApUsDif,IIF(TRBBAU->BAU_CALIMP $ '1,3,4',.t., nil) /*lAtuGui*/,cExcPeg,cTipTitInt,nY,lRmbPTU)
		      //Fina050 estava adicionando um espa?o no final
			  cTipo := alltrim(cTipo)
			  BAU->(DbGoTo(nRecBAU))
		      BAU->(DbSetOrder(nIndBAU))         
			  If Len(aRetorno) = 0 .OR. ValType(aRetorno[1]) <> "C"// Houve erro na gera??o precisa retornar tudo. Acr?scimo do Valtype para situa??es em que o operador não tem permiss?o pra gerar pedido de compra (RDA configurada pra pedido de compra)
					/// Fecha controle de sem?foros da numera??o do Titulo
					PlsFechaSem(nHNumPag,cChaveSem)
					Exit
			  Endif
			  if aRetorno[1] == "1"
					nQtdOK ++
			  else
					nQtdNO ++
					aadd(aCrit,{TRBBAU->BAU_CODIGO,TRBBAU->BAU_NOME,aRetorno[1],aRetorno[2]})
			  endif
			  
			  nValBruAcu += aRetorno[3]
			  
			  If len(aRetorno) > 3 
					If lRmbPTU
						nVlrGloAne += aRetorno[4][13]
					Else
						nVlrServ 	+= aRetorno[4][14]
						nVlrTx		+= aRetorno[4][15]
					EndIf				
			  EndIf
			  
			  if len(aRetorno) > 4
			  
					nValIrAcu  += aRetorno[6]
				
					If TRBBAU->BAU_CALIMP $ '1'  //Forma de Pagto da RDA : 1=Pedido de Compra;2=Financeiro;3=Folha Pagto/Fin;4=Folha de Pagto/GPE
						nValBruAcu := IIf( ValType(aRetorno[4][4][1]) <> NIL, aRetorno[4][4][1], 0 ) + aRetorno[5] //Os descontos do pedido de compra s?o separados na NDF
						nValLiqAcu += (nValBruAcu- (nValIrAcu+aRetorno[5]))
					Else
						If cTipo == "NDF"//Quando tem NDF preciso refazer cTipo senao vai buscar o saldo liquido em cima de NDF
							If cTipTitInt == '3'
								cTipo := cPLTIPND
							Else
								cTipo := cPLTIPE2
							EndIf
							cTipo := Eval({|| &cTipo })
						EndIf

						if (nPos := ascan(aTitBru,{|x| x[1] == cNumLote+cPrefixo+cTipo}) ) == 0
							aadd(aTitBru,{cNumLote+cPrefixo+cTipo,0})
							nPos := len(aTitBru)
							nBruCalc := 0
						else
							nBruCalc := aTitBru[nPos][2]
						endif

						if (nPosLiq := ascan(aTitLiq,{|x| x[1] == cNumLote+cPrefixo+cTipo}) ) == 0
							aadd(aTitLiq,{cNumLote+cPrefixo+cTipo,0})
							nPosLiq := len(aTitLiq)
							nLiqCalc := 0
						else
							nLiqCalc := aTitLiq[nPosLiq][2]
						endif

						aRetTotal := PLSLDLIQTT(cCodOpe,cAno,cMes,cNumLote,cPrefixo,cTipo,nBruCalc,nLiqCalc)
						nValLiqAcu += aRetTotal[1] 
						nValBruAcu := aRetTotal[2]
						//Se calculou o bruto pela fun??o PLSLDLIQTT não somo o valor, estava dando duplicidade.
						
						if len(aTitBru) >= 1 
							aTitBru[nPos][2] += nValBruAcu
						endif

						if len(aTitLiq) >= 1 
							aTitLiq[nPosLiq][2] += nValLiqAcu
						endif
					EndIf
			  endIf

				/// Fecha controle de sem?foros da numera??o do Titulo
				PlsFechaSem(nHNumPag,cChaveSem)
				
			Next
			
			// TSYLYO - reestrutura??o do controle de transa??o:
			// Ao invez de gerar o lote apenas no final, agora a cada novo titulo gerado, incrementa o lote de pagamento.
			// Assim, a transa??o fica mais leve.	
			// Garante que o BAF estar? posicionado.  
			If nRecNewBAF <> BAF->( Recno() )
				BAF->( dbGoto(nRecNewBAF) )
			Endif		
						
			If !BAF->( Eof() )	
			
				cTipTitInt := ''
				If !Empty(BAF->BAF_SEQIMP)
					
					BRJ->(DbSetOrder(1))
					If BRJ->(DbSeek(xFilial("BRJ")+BAF->BAF_SEQIMP,.F.))
						Do While !BRJ->(Eof()) .And. BRJ->(BRJ_FILIAL+BRJ_CODIGO) == xFilial("BRJ")+BAF->BAF_SEQIMP
							If BRJ->BRJ_REGPRI == "1" 
								cTipTitInt := BRJ->BRJ_TPCOB
								Exit
							EndIf
							BRJ->(DbSkip())
						EndDo
					EndIf
				EndIf
				
				BAF->( RecLock("BAF", .F.) )				
				BAF->BAF_VLRBRU 	+= nValBruAcu				
				BAF->BAF_VLRIR		+= nValIrAcu
				BAF->BAF_VLRLIQ 	+= Iif(nValLiqAcu>=0,nValLiqAcu,0)
				BAF->BAF_RDAPAG 	+= nQtdOK
				BAF->BAF_RDACRI 	+= nQtdNO
				BAF->BAF_RESLOT 	:= If(BAF->BAF_VLRLIQ>=0,"2","1")
				
				If BAF->(FieldPos("BAF_VLRGLO")) > 0 .AND. BAF->(FieldPos("BAF_VLTXGL")) > 0 	   					
	   				
	   				If lRmbPTU 
	   					BAF->BAF_VLRGLO += nVlrGloAne	   					
	   				ElseIf cTipTitInt == "3"	                 
				      	// Tipo 3 - Ambos  (BAF_VLRGLO) = Valor Servico e BAF_VLTXGL = Valor Taxa   
						BAF->BAF_VLRGLO += nVlrServ //aRetorno[4][14]     
						BAF->BAF_VLTXGL += nVlrTx 	//aRetorno[4][15]	   						   
				    Else      
						BAF->BAF_VLRGLO += nVlrServ //Passamos a sempre gravar o valor de glosa
				    EndIf
				     			   					   
   				EndIf    					
				BAF->( MsUnlock() )
								
			Endif			
			
			// Redefine as v?riaveis de totais
			nValBruAcu	:= 0
			nValLiqAcu	:= 0
			nValIrAcu	:= 0
			nQtdOK 		:= 0
			nQtdNO		:= 0
  		   	nVlrServ	:= 0     
			nVlrTx 		:= 0	   
			//??????????????????????????????????????????????????????????????????????????Ä¿
	   		//? Grava as criticas...                                                     ?
	   		//????????????????????????????????????????????????????????????????????????????
	   		If Len(aCrit) > 0
		   		For nAux := 1 To Len(aCrit)
		       	BEM->(RecLock("BEM",.T.))
						BEM->BEM_FILIAL := xFilial("BEM")
				    	BEM->BEM_CODOPE := cCodOpe
				    	BEM->BEM_NUMLOT := cNumLote
				    	BEM->BEM_ANOLOT := cAno
				    	BEM->BEM_MESLOT := cMes
				    	BEM->BEM_CODCRI := aCrit[nAux,3]
				    	BEM->BEM_DESCRI := aCrit[nAux,4]
				    	BEM->BEM_CODRDA := aCrit[nAux,1]
				    	BEM->BEM_NOMRDA := aCrit[nAux,2]
				   BEM->(MsUnLock())
			    Next
			    aCrit:={}
			Endif               
			//?????????????????????????????????????????????????????????????????????????Ä¿
			//?Gravando o numero do lote na tabela  de Apontamento Pagamento  BCE       ?
			//???????????????????????????????????????????????????????????????????????????
			   		
   			aRecnBce := {}
   		
	   		BCE->(dbSetOrder(2))  
	   		BCE->(DbGoTop())  
	   		
			If BCE->(DbSeek(xFilial("BCE")+TRBBAU->BAU_CODIGO+cCodOpe+cAno+cMes))
				While BCE->(!Eof()) .and.  BCE->(BCE_FILIAL+BCE_CODIGO+BCE_CODINT+BCE_ANOPAG+BCE_MESPAG)=(xFilial("BCE")+TRBBAU->BAU_CODIGO+cCodOpe+cAno+cMes)
				    If Empty(BCE->BCE_NUMLOT)
						Aadd(aRecnBce,BCE->(Recno()))
					Endif
			   		BCE->(DbSkip())
			   	Enddo
			Endif 
			
			For i:=1 to Len(aRecnBce)
				BCE->(DbGoTo(aRecnBce[i]))
				
				BCE->(RecLock("BCE",.F.))
					BCE->BCE_NUMLOT :=cAno+cMes+cNumLote
					BCE->BCE_OPELOT :=cCodOpe 
		   		BCE->(MsUnlock())  
			Next i
			
			If TRBBAU->BAU_CALIMP == '2'
				SE2->(ConfirmSX8())
			Endif
			
			If Len(aRetorno) = 0
				DisarmTransaction()
			Endif
						
		End Transaction
		
		TRBBAU->(DbSkip())
	EndDo
	TRBBAU->(DbCloseArea())
Else
	PLSFechaSem(nH,cChavePri)
	Help("",1,"ProcTite",,STR0024,1) //"Nao foram selecionados credenciados"
Endif    

//???????????????????????????????????????????????????????????????????????????
//? Volta o Filtro
//???????????????????????????????????????????????????????????????????????????

A470IND(cFiltro,.T.,,cCopCre,cRdaDe,cRdaAte,cGrpPag, cProcDe, cProcAte, cCodOpe, cCodPegIn, cCodPegFi, .F.)
//??????????????????????????????????????????????????????????????????????????Ä¿                                           
//? Restaura area antiga...                                                  ?
//????????????????????????????????????????????????????????????????????????????
If ! Empty(aOldArea[1])
   RestArea(aOldArea)
Endif   
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Caso houve resultados...                                                 ?
//????????????????????????????????????????????????????????????????????????????

// Garante que o BAF estar? posicionado.  
If nRecNewBAF <> BAF->( Recno() )
	BAF->( dbGoto(nRecNewBAF) )
Endif	

// TSYLYO - reestrutura??o do controle de transa??o:
// O sistema precisa olhar para os campos do lote.
If BAF->BAF_RDAPAG > 0 .Or. BAF->BAF_RDACRI > 0
   //??????????????????????????????????????????????????????????????????????????Ä¿
   //? Grava historico de processamento                                         ?
   //????????????????????????????????????????????????????????????????????????????
   cIdeRot := "PLSA470 "
   cCodCha := cCodOpe + cAno + cMes + cNumLote + dtos(dPDat) + cPHorIni

   cHistor := STR0027 + cAno + cMes + cNumLote + STR0028 + dtoc(dPDat) + STR0029 + cPHorIni + STR0030 + Time() //"Geracao Lote Pagto: "###" Data: "###" Inicio: "###" Fim: "
   PLSHISGRV(cIdeRot,cCodCha,"0001",cHistor)

   cHistor := STR0031 + PLSRtCdUsr() + " " + USRRETNAME(PLSRtCdUsr()) //"   Usuario: "
   PLSHISGRV(cIdeRot,cCodCha,"0002",cHistor)

   For nSeq := 1 to 37
       cCamSX1 := "mv_par" + strzero(nSeq,2)
       If ValType(&cCamSX1) == "C"
          cCamSX1 := &cCamSX1
       ElseIf ValType(&cCamSX1) == "N"
          cCamSX1 := AllTrim(Str(&cCamSX1))
       ElseIf ValType(&cCamSX1) == "D"
          cCamSX1 := dtoc(&cCamSX1)
       Endif   
       cHistor := "   " + Posicione("SX1",1,"PLA470"+strzero(nSeq,2),"X1_PERGUNT") + ": " + cCamSX1
       PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq+2,4),cHistor)
   Next
   
ElseIf nRecNewBAF <> 0
	BAF->( Reclock("BAF", .F.) )
		BAF->( dbDelete() )
	BAF->( MsUnlock() )					
Endif
//??????????????????????????????????????????????????????????????????????????Ä¿
//? BOPS 110258: Como a tabela SRC eh utilizada e permanece aberta, a rotina ?
//?              GPEM120 (Fechamentos/Mensal) nao consegue abri-la em modo   ?
//?              exclusivo. Isso causa o transtorno de ser necessario fechar ?
//?              a conexao do usuario que executou esta rotina ou "restart"  ?
//?              do TopConnect. Assim, fecho a tabela no fim da rotina.      ?
//????????????????????????????????????????????????????????????????????????????

If Select("SRC") > 0
	SRC->(DbCloseArea())
EndIf

// Garante que o BAF estar? posicionado.  
If nRecNewBAF <> BAF->( Recno() )
	BAF->( dbGoto(nRecNewBAF) )
Endif	

// TSYLYO - reestrutura??o do controle de transa??o:
// O sistema precisa olhar para os campos do lote.
If BAF->BAF_RDAPAG > 0 .Or. BAF->BAF_RDACRI > 0

	//????????????????????????????????????????????????????????????????????????????????Ä¿
	//? BOPS 106128 - Permite tratar tabelas envolvidas na rotina de lote de pagamento ?
	//??????????????????????????????????????????????????????????????????????????????????
	If  ExistBlock("PL470FLT")
		ExecBlock("PL470FLT",.F.,.F.)
	Endif

   BGQ->(dbCloseArea())
   
   PLSA470MOV("BAF",BAF->(Recno()),K_Visualizar,lAutoma)
   
Else
	MsgInfo(STR0146)//"não foram encontrado movimenta?oes nesta competencia (Ano e M?s)!"
Endif

//??????????????????????????????????????????????????????????????????????????Ä¿
//? Fim da Rotina...                                                         ?
//????????????????????????????????????????????????????????????????????????????
Return(.F.)

/*/
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
???Programa  ? PLSTIPPRE  ? Autor ? Tulio Cesar       ? Data ? 22.10.2002 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Exibe os tipos da RDA para uso em um F3                    ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Uso       ? F3 BYT                                                     ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Parametros? Padrao do mBrowse                                          ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
Function PLSTIPPRE(cDado,cCampo)
LOCAL oDlg
LOCAL nOpca     := 0
LOCAL bOK       := { || nOpca := K_OK, oDlg:End() }
LOCAL bCancel   := { || oDlg:End() }
LOCAL oCritica
LOCAL cSQL
LOCAL aCritica  := {}
LOCAL nInd                     
Local nIteMar
Local cBak := cDado
Local lRet := .F.
Local aCampos := {}
Local aBls    := {}

DEFAULT cCampo  := ""
                                                                                  
//??????????????????????????????????????????????????????????????????????????Ä¿
//? coloca virgula no comeco (caso tenha inicializador padrao)               ?
//????????????????????????????????????????????????????????????????????????????
cDado  := AllTrim(cDado)   
if subs(cDado,len(cDado),1) != "," .AND. cDado != ""
	cDado += ","
endif

cSQL := "SELECT BAG_CODIGO, BAG_DESCRI FROM "+RetSQLName("BAG")+" WHERE "
cSQL += "BAG_FILIAL = '"+xFilial("BAG")+"' AND D_E_L_E_T_ = '' ORDER BY BAG_FILIAL,BAG_DESCRI"
cSQL := ChangeQuery(cSQL)
dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cSQL),"TrbBAG",.F.,.T.)

While ! TrbBAG->(Eof())
     
      aadd(aCritica,{TrbBAG->BAG_CODIGO,TrbBAG->BAG_DESCRI,If(Alltrim(TrbBAG->BAG_CODIGO)$cDado,.T.,.F.)})

TRBBAG->(DbSkip())
Enddo
TrbBAG->(DbCloseArea())
DbSelectArea("BA1")


DEFINE MSDIALOG oDlg TITLE STR0032 FROM ndLinIni,ndColIni TO ndLinFin,ndColFin OF GetWndDefault() //"Tipos de Rede de Atendimento"

@ 020,012 SAY oSay PROMPT STR0033 SIZE 100,010 OF oDlg PIXEL COLOR CLR_HBLUE //"Selecione o(s) tipo(s)"

oCritica := TcBrowse():New( 035, 012, 330, 150,,,, oDlg,,,,,,,,,,,, .F.,, .T.,, .F., )
                                            
oCritica:AddColumn(TcColumn():New(" ",{ || IF(aCritica[oCritica:nAt,3],LoadBitmap( GetResources(), "LBOK" ),LoadBitmap( GetResources(), "LBNO" )) },;
         "@!",nil,nil,nil,015,.T.,.T.,nil,nil,nil,.T.,nil))     

oCritica:AddColumn(TcColumn():New(STR0034,{ || OemToAnsi(aCritica[oCritica:nAt,1]) },; //"Codigo"
         "@!",nil,nil,nil,020,.F.,.F.,nil,nil,nil,.F.,nil))     

oCritica:AddColumn(TcColumn():New(STR0035,{ || OemToAnsi(aCritica[oCritica:nAt,2]) },; //"Descricao"
         "@!",nil,nil,nil,200,.F.,.F.,nil,nil,nil,.F.,nil))     

oCritica:SetArray(aCritica)         
oCritica:bLDblClick := { || aCritica[oCritica:nAt,3] := Eval( { || nIteMar := 0, aEval(aCritica, {|x| IIf(x[3], nIteMar++, )}), IIf(nIteMar < 12 .Or. aCritica[oCritica:nAt, 3],IF(aCritica[oCritica:nAt,3],.F.,.T.),.F.) })}

//-- LGPD -------- 
if objCENFUNLGP:isLGPDAt() 
	aCampos := {.F.,"BAG_CODIGO","BAG_DESCRI"} 
	aBls := objCENFUNLGP:getTcBrw(aCampos) 
	oCritica:aObfuscatedCols := aBls 
endif 
//---------------- 

ACTIVATE MSDIALOG oDlg ON INIT EnChoiceBar(oDlg,bOK,bCancel,.F.,{})

If nOpca == K_OK
                  
   cDado := ""
   For nInd := 1 To Len(aCritica)
       If aCritica[nInd,3]
          cDado += aCritica[nInd,1]+","
       Endif 
   Next

Endif
                                  
//??????????????????????????????????????????????????????????????????????????Ä¿
//? tira a virgula do final                                                  ?
//????????????????????????????????????????????????????????????????????????????
if subs(cDado,len(cDado),1) == ","
	cDado := subs(cDado,1,len(cDado)-1)
endif                

if !empty(cCampo)
	cCampo  := "M->"+cCampo
	&cCampo := cDado 
	cPLSTIPPRE := cDado
endif

If FunName() == "PLSA475"
	mv_par27 := cDado
	mv_par04 := cBak
Endif

if ! empty(cDado)
	lRet := .T.
endif

Return(lRet)

/*/
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
???Programa  ? PLSTIPDC   ? Autor ? Angelo Sperandio  ? Data ? 02.09.2005 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Exibe os tipos da debito/credito para uso em um F3         ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Uso       ? F3 B4T                                                     ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Parametros? Padrao do mBrowse                                          ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/

Function PLSTIPDC(cDado,cCampo)

//??????????????????????????????????????????????????????????????????????????Ä¿
//? Define variaveis...                                                      ?
//????????????????????????????????????????????????????????????????????????????
LOCAL oDlg
LOCAL nOpca     := 0
LOCAL bOK       := { || nOpca := K_OK, oDlg:End() }
LOCAL bCancel   := { || oDlg:End() }
LOCAL oCritica
LOCAL cSQL
LOCAL aCritica  := {}
LOCAL nInd                     
Local nIteMar
LOCAL lRet := .F.
Local aCampos := {}
Local aBls    := {}
DEFAULT cCampo  := ""
//??????????????????????????????????????????????????????????????????????????Ä¿
//? coloca virgula no comeco (caso tenha inicializador padrao)               ?
//????????????????????????????????????????????????????????????????????????????
cDado  := AllTrim(cDado)   
If  subs(cDado,len(cDado),1) != "," .AND. cDado != ""
	cDado += ","
Endif

cSQL := "SELECT BBB_CODSER, BBB_DESCRI FROM " + RetSQLName("BBB") + " WHERE "
cSQL += "BBB_FILIAL = '" + xFilial("BBB") + "' AND D_E_L_E_T_ = '' ORDER BY BBB_FILIAL,BBB_DESCRI"
cSQL := ChangeQuery(cSQL)
dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cSQL),"TrbBBB",.F.,.T.)

While ! TrbBBB->(Eof())
     
      aadd(aCritica,{TrbBBB->BBB_CODSER,TrbBBB->BBB_DESCRI,If(TrbBBB->BBB_CODSER$cDado,.T.,.F.)})

TRBBBB->(DbSkip())
Enddo
TrbBBB->(DbCloseArea())

DEFINE MSDIALOG oDlg TITLE STR0036 FROM ndLinIni,ndColIni TO ndLinFin,ndColFin OF GetWndDefault() //"Tipos de Debito/Credito"

@ 020,012 SAY oSay PROMPT STR0033 SIZE 100,010 OF oDlg PIXEL COLOR CLR_HBLUE //"Selecione o(s) tipo(s)"

oCritica := TcBrowse():New( 035, 012, 330, 150,,,, oDlg,,,,,,,,,,,, .F.,, .T.,, .F., )
                                            
oCritica:AddColumn(TcColumn():New(" ",{ || IF(aCritica[oCritica:nAt,3],LoadBitmap( GetResources(), "LBOK" ),LoadBitmap( GetResources(), "LBNO" )) },;
         "@!",nil,nil,nil,015,.T.,.T.,nil,nil,nil,.T.,nil))     

oCritica:AddColumn(TcColumn():New(STR0034,{ || OemToAnsi(aCritica[oCritica:nAt,1]) },; //"Codigo"
         "@!",nil,nil,nil,020,.F.,.F.,nil,nil,nil,.F.,nil))     

oCritica:AddColumn(TcColumn():New(STR0035,{ || OemToAnsi(aCritica[oCritica:nAt,2]) },; //"Descricao"
         "@!",nil,nil,nil,200,.F.,.F.,nil,nil,nil,.F.,nil))     

oCritica:SetArray(aCritica)         
oCritica:bLDblClick := { || aCritica[oCritica:nAt,3] := Eval( { || nIteMar := 0, aEval(aCritica, {|x| IIf(x[3], nIteMar++, )}), IIf(nIteMar < 12 .Or. aCritica[oCritica:nAt, 3],IF(aCritica[oCritica:nAt,3],.F.,.T.),.F.) })}


//-- LGPD -------- 
if objCENFUNLGP:isLGPDAt() 
	aCampos := {.F.,"BBB_CODSER","BBB_DESCRI"} 
	aBls := objCENFUNLGP:getTcBrw(aCampos) 
	oCritica:aObfuscatedCols := aBls 
endif 
//---------------- 

ACTIVATE MSDIALOG oDlg ON INIT EnChoiceBar(oDlg,bOK,bCancel,.F.,{})

If nOpca == K_OK
                  
   cDado := ""
   For nInd := 1 To Len(aCritica)
       If aCritica[nInd,3]
          cDado += aCritica[nInd,1]+","
       Endif 
   Next

Endif
                                  
//??????????????????????????????????????????????????????????????????????????Ä¿
//? tira a virgula do final                                                  ?
//????????????????????????????????????????????????????????????????????????????
if subs(cDado,len(cDado),1) == ","
	cDado := subs(cDado,1,len(cDado)-1)
endif                

if !empty(cCampo)
	If !"MV_PAR" $ UPPER(cCampo)
		cCampo  := "M->"+cCampo
	EndIf
	&cCampo := cDado
endif
if ! empty(cDado)
	lRet := .T.
endif
Return(lRet)


/*/
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
???Programa  ? PLSA470MOV ? Autor ? Tulio Cesar       ? Data ? 31.08.2003 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Visualiza um lote de pagamento de RDA                      ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
Function PLSA470MOV(cAlias,nReg,nOpc,lAutoma)
LOCAL nOpca   	:= 0
LOCAL bBotOk    := {|| nOpca := 1,oDlg1:End() }
LOCAL bCancel 	:= {|| nOpca := 0,oDlg1:End() }
LOCAL nOrdSE2Esp:= GetNewPar("MV_PLSOSE2",11)
LOCAL oDlg1
LOCAL oFolder
LOCAL oEnchoice
LOCAL aRet
LOCAL cChaveSE2
LOCAL nRecSE2
LOCAL aButtons     	:= {}
LOCAL lConfirm		:= .f.
LOCAL aEstorno		:= {}
LOCAL cIdeRot
LOCAL cCodCha
LOCAL cTitulo
LOCAL cIdeRot2
LOCAL cCodCha2
LOCAL cTitulo2
Local nI           := 0
LOCAL dDataPagto   	:= BAF->BAF_DATPAG
Local lTitCont     	:= .F.
Local aCriticas    	:= {}
Local aColsAux1    	:= {}
Local aColsAux2    	:= {}
Local aCabec		:= { 	{"Prefixo","@C",30},{"Numero","@C",30},;
							{"Parcela","@C",30},{"Tipo","@C",30},;
							{"Critica","@C",250} }

Local cFilOrig		:= cFilAnt
Local cFilSRC		:= xFilial('SRC')
Local cFilSC7		:= xFilial('SC7')

Local i				:= 0
Local nPosFil		:= 0
Local nPosMat		:= 0

PRIVATE aColsSE2   := {}
PRIVATE aHeaderSE2 := {}
PRIVATE aVetSE2    := {}
PRIVATE oBrwSE2

PRIVATE aColsBGQ   := {}
PRIVATE aHeaderBGQ := {}
PRIVATE aVetBGQ    := {}
PRIVATE oBrwBGQ

PRIVATE aColsBEM   := {}
PRIVATE aHeaderBEM := {}
PRIVATE aVetBEM    := {}
PRIVATE oBrwBEM

PRIVATE aColsSE1   := {}
PRIVATE aHeaderSE1 := {}
PRIVATE aVetSE1    := {}
PRIVATE oBrwSE1

PRIVATE aColsSC7   := {}
PRIVATE aHeaderSC7 := {}
PRIVATE aVetSC7    := {}
PRIVATE oBrwSC7

PRIVATE aColsSRC    := {}
PRIVATE aHeaderSRC  := {}
PRIVATE aHeade2SRC  := {}
PRIVATE aVetSRC     := {}
PRIVATE oBrwSRC
PRIVATE aColsSRD    := {}
PRIVATE aHeaderSRD  := {}
PRIVATE aVetSRD     := {}
PRIVATE oBrwSRD
Private aHeade2RGB := {}
Private aHeaderRGB := {}
Default lAutoma		:= .F.

//verifica se a database est? no periodo contabil e se estiver não pode excluir o lote de pagamento
if (nOpc != K_Excluir .and. nOpc != K_Alterar) .or. ( FindFunction('PLVLDBLQCO') .And. PLVLDBLQCO(dDataBase, {"PLS006"}, .T.) ) 

	//Cria botao para permitir consultar historico de processamento do lote    
	If  nOpc == K_Visualizar .or. nOpc == K_Excluir .or. nOpc == K_Alterar
		cIdeRot  := "PLSA470 "
		cCodCha  := BAF->BAF_CODOPE + BAF->BAF_ANOLOT + BAF->BAF_MESLOT + BAF->BAF_NUMLOT
		cTitulo  := STR0037 + transform(cCodCha,"@R !!!!.!!!!.!!.!!!!") //"Historico de Processamento - Lote: "
		
		aadd(aButtons,{"RELATORIO"  ,{|| PLSHISCON(cIdeRot,cCodCha,cTitulo) },STR0038,STR0133}) //"Consulta Historico de Processamento"##"Hist Proc"
		
		cIdeRot2 := "PLSMPAG "
		cCodCha2 := BAF->BAF_CODOPE + BAF->BAF_ANOLOT + BAF->BAF_MESLOT + BAF->BAF_NUMLOT
		cTitulo2 := STR0039 + transform(cCodCha,"@R !!!!.!!!!.!!.!!!!") //"Historico de Calculo por RDA - Lote: "
		
		aadd(aButtons,{"RELATORIO"  ,{|| PLSHISCON(cIdeRot2,cCodCha2,cTitulo2) },STR0040,STR0134}) //"Consulta Historico de Calculo por RDA"##"Hist RDA"
	Endif

	//? Analisa a existencia de baixa em um dos titulos a pagar                  
	If nOpc == K_Excluir .or. nOpc == K_Alterar
		if baixaFutura()
			return
		endif
		aRet := PLSA470PEx("SE2", lAutoma)
		
		if ! aRet[1]
			
			PLSCRIGEN(aRet[2],{ {STR0041,"@C",30}, {STR0042,"@C",30 }, {STR0043,"@C",30 }, {"Tipo","@C",30}, {STR0044,"@C",30}, {"Loja","@C",30}, {STR0045,"@C",100 }  }, STR0046) //"Prefixo"###"Numero"###"Parcela"//"Fornecedor"//"Nome Fornecedor"//"Os Titulos a Pagar Abaixo Sofreram Baixa. Voce deve cancelar a baixa para excluir o lote"
			return
		
		elseIf ! aRet[3]
			
			PLSCRIGEN(aRet[4],{ {STR0041,"@C",30}, {STR0042,"@C",30 }, {STR0043,"@C",30 }, {"Tipo","@C",30}, {STR0044,"@C",30} , {"Loja","@C",30},{STR0045,"@C",100 }  }, STR0132) //"Prefixo"###"Numero"###"Parcela"//"Fornecedor"//"Nome Fornecedor"//"Os Titulos a Pagar abaixo j? foram contabilizados, portanto não ser? poss?vel excluir o Lote."
			return

		elseIf ! aRet[5]

			return

		endIf

		//? Analisa a existencia de titulos de contestacao que foram transferidos    ?
		If BAF->(FieldPos("BAF_SEQIMP")) > 0 .and. ! Empty(BAF->BAF_SEQIMP) .and. BRJ->(MsSeek(xFilial("BRJ")+BAF->BAF_SEQIMP))
			
			SE1->(DbSetOrder(1))
			If SE1->(MsSeek(xFilial("SE1")+BRJ->(BRJ_PREFIX+Alltrim(BRJ_NUMTIT)+BRJ_PARCEL+BRJ_TIPTIT)))
				
				While !SE1->(EOF()) .and. SE1->(E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO) == xFilial("SE1")+BRJ->(BRJ_PREFIX+Alltrim(BRJ_NUMTIT)+BRJ_PARCEL+BRJ_TIPTIT)
					// Titulo nao esta em carteira, nao pode excluir o lote...
					If SE1->E1_SITUACA <> '0'
						Aadd(aCriticas, {SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,STR0143})  //"Titulo transferido para banco."
					Endif
					SE1->(DbSkip())
				Enddo
			EndIf

			//? Verifica a existecia de titulos de NDC                                   ?
			If BRJ->( FieldPos("BRJ_PRENDC") ) > 0 .And. BRJ->( FieldPos("BRJ_NUMNDC") ) > 0 .And. ;
					BRJ->( FieldPos("BRJ_PARNDC") ) > 0 .And. 	BRJ->( FieldPos("BRJ_TIPNDC") ) > 0 .And. ;
					SE1->(MsSeek(xFilial("SE1")+BRJ->(BRJ_PRENDC+Alltrim(BRJ_NUMNDC)+BRJ_PARNDC+BRJ_TIPNDC)))
				
				while !SE1->(EOF()) .and. SE1->(E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO) == xFilial("SE1")+BRJ->(BRJ_PRENDC+Alltrim(BRJ_NUMNDC)+BRJ_PARNDC+BRJ_TIPNDC)
					// Titulo nao esta em carteira, nao pode excluir o lote...
					If SE1->E1_SITUACA <> '0'
						Aadd(aCriticas, {SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,STR0143})  //"Titulo transferido para banco."
					Endif
					SE1->(DbSkip())
				endDo
			endIf
			
			//? Encontrado titulos que nao estao em carteira...				        ?
			If Len(aCriticas) > 0
				PLSCRIGEN(aCriticas,aCabec, STR0144,NIL,NIL,NIL,NIL, NIL,NIL,"G",220) //"Verificacao de integridade."
				Return
			EndIf
			
		EndIf
	Endif
	
	//? Leitura dos titulos a pagar...                                           ?
	lSE2 := .F.
	Store Header "SE2" TO aHeaderSE2 For !(AllTrim(SX3->X3_CAMPO) $ "E2_CODAPRO,E2_DATAAGE")
	
	If nOpc == K_Incluir
		Store COLS Blank "SE2" TO aColsSE2 FROM aHeaderSE2
	Else
		SE2->(DbSetOrder(12))//E2_FILIAL+E2_PLOPELT+E2_PLLOTE+E2_NOMFOR
		If !SE2->(dbSeek(xFilial("SE2")+BAF->(BAF_CODOPE+BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)))
			Store COLS Blank "SE2" TO aColsSE2 FROM aHeaderSE2
		Else
			lSE2 := .T.
			Store COLS "SE2" TO aColsSE2 FROM aHeaderSE2 VETTRAB aVetSE2 While SE2->(E2_FILIAL+E2_PLOPELT+E2_PLLOTE) == xFilial("SE2")+BAF->(BAF_CODOPE+BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)
		Endif
	Endif

	//? Leitura dos debitos ...
	lBGQ := .F.
	store Header "BGQ" TO aHeaderBGQ For .T.
	If nOpc == K_Incluir
		Store COLS Blank "BGQ" TO aColsBGQ FROM aHeaderBGQ
	Else
		cSelBGQ := "SELECT * FROM "	+ RetSqlName("BGQ") + " WHERE BGQ_FILIAL = '" + xFilial("BGQ") + "'"
		cSelBGQ += " AND BGQ_CODOPE = '" + BAF->BAF_CODOPE + "' AND BGQ_ANO = '" + BAF->BAF_ANOLOT + "'"
		cSelBGQ += " AND BGQ_NUMLOT = '" + BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT) + "' AND D_E_L_E_T_ = ' '"
		cSelBGQ := ChangeQuery(cSelBGQ)
		dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cSelBGQ),"TRBBGQ",.F.,.T.)
		
		If TRBBGQ->(Eof())
			Store COLS Blank "BGQ" TO aColsBGQ FROM aHeaderBGQ
		Else
			lBGQ := .T.
			TRBBGQ->(dbGoTop())
		Endif
		
		While !TRBBGQ->(Eof())
			Store COLS "TRBBGQ" TO aColsBGQ FROM aHeaderBGQ VETTRAB aVetBGQ While !TRBBGQ->(Eof())
			Exit
		Enddo
		// Preenche a Descri??o do Lan?amento no AcolsBGQ
		If Len(aColsBGQ) > 0
			BBB->(dbSetOrder(1))
			nPos 	:= aScan(aHeaderBGQ,{|x| ALLTRIM(x[2]) == 'BGQ_DESLAN'})
			nPosLct := aScan(aHeaderBGQ,{|x| ALLTRIM(x[2]) == 'BGQ_CODLAN'})
			For i:= 1 to Len(aColsBGQ)
				If Empty(aColsBGQ[i][nPosLct])
					aColsBGQ[i][nPos]:= 'LANCTOS DEB/CRED'
				Else
					BBB->(dbSeek(xFilial('BBB')+aColsBGQ[i][nPosLct]))
					aColsBGQ[i][nPos] := BBB->BBB_DESCRI
				EndIf
			Next
		EndIf
		TRBBGQ->(DbCloseArea())
	Endif

	//? Leitura das criticas...                                                  ?
	Store Header "BEM" TO aHeaderBEM For .T.
	If nOpc == K_Incluir
		Store COLS Blank "BEM" TO aColsBEM FROM aHeaderBEM
	Else
		BEM->(DbSetOrder(1))
		If ! BEM->(MsSeek(xFilial("BEM")+BAF->(BAF_CODOPE+BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)))
			Store COLS Blank "BEM" TO aColsBEM FROM aHeaderBEM
		Else
			Store COLS "BEM" TO aColsBEM FROM aHeaderBEM VETTRAB aVetBEM While BEM->(BEM_FILIAL+BEM_CODOPE+BEM_ANOLOT+BEM_MESLOT+BEM_NUMLOT) == xFilial("BEM")+BAF->(BAF_CODOPE+BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)
		Endif
	Endif
	
	//? Pedidos de compra..                                                      ?
	dbSelectArea("SC7")
	SC7->(DbSetOrder(22))
	SC7->(DbGoTop())
	lSC7 := .F.
	Store Header "SC7" TO aHeaderSC7 For .T.
	If nOpc == K_Incluir
		Store COLS Blank "SC7" TO aColsSC7 FROM aHeaderSC7
	Else
		/*
		Esse item foi alterado devido aos clientes que utilizam em seus campos Filiais o grupo empresa
		cLotPcPls := IIf(Len(xFilial('SC7'))==2, cFilSC7+BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT), cFilSC7+cFilSC7+Space(12-Len(cFilSC7))+BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT) )
		*/
		cLotPcPls :=  cFilSC7+BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)
		If SC7->(MsSeek(cLotPcPls))
			lSC7 := .T.
			Store COLS "SC7" TO aColsSC7 FROM aHeaderSC7 VETTRAB aVetSC7 While ;
				(rtrim(xFilial("SC7")+SC7->(C7_LOTPLS))) == cLotPcPls
		else
			Store COLS Blank "SC7" TO aColsSC7 FROM aHeaderSC7
		Endif
	Endif
	
	// Folha de pagamento
	aHeade2SRC:={}
	aHeade2RGB := {}

	If RGB->(FieldPos("RGB_LOTPLS")) > 0
		RGB->(DbSetOrder(RetOrder( "RGB", "RGB_FILIAL+RGB_LOTPLS" )))//RC_FILIAL+RC_LOTPLS
		RGB->(DbGoTop())
		Store Header "RGB" TO aHeaderRGB For .T.
		For i:=1 to Len(aHeaderRGB)
			aadd(aHeade2RGB,aHeaderRGB[i])
		Next i
	endif
	SRC->(DbSetOrder(RetOrder( "SRC", "RC_FILIAL+RC_LOTPLS" )))//RC_FILIAL+RC_LOTPLS
	SRC->(DbGoTop())
	Store Header "SRC" TO aHeaderSRC For .T.
	For i:=1 to Len(aHeaderSRC)
		If !Alltrim(aHeaderSRC[i,2])$"RC_DESCPD"
			aadd(aHeade2SRC,aHeaderSRC[i])
		Endif
	Next i
	aHeade2SRD:={}
	SRD->(DBOrderNickName("HISTPLS"))
	SRD->(DbGoTop())
	Store Header "SRD" TO aHeaderSRD For .T.
	For i := 1 to Len(aHeaderSRD)
		If !Alltrim(aHeaderSRD[i,2])$"RD_DESCPD"
			aadd(aHeade2SRD,aHeaderSRD[i])
		Endif
	Next i
	lRGB := .F.
	If nOpc == K_Incluir
		If RGB->(FieldPos("RGB_LOTPLS")) > 0
			Store COLS Blank "RGB" TO aColsSRC FROM aHeaderRGB
			aHeade2RGB:={}
			aHeade2SRC:={}
			For i:=1 to Len(aHeaderRGB)
				aadd(aHeade2SRC,aHeaderRGB[i])
			Next i	
		else
			Store COLS Blank "SRC" TO aColsSRC FROM aHeaderSRC
			aHeade2SRC:={}
			For i:=1 to Len(aHeaderSRC)
				If !Alltrim(aHeaderSRC[i,2])$"RC_DESCPD"
					aadd(aHeade2SRC,aHeaderSRC[i])
				Endif
			Next i
		EndIf
	Else
		lSRC := .F.
		lRGB := .F.
		aAreaSM0 := SM0->(GetArea())
		SM0->(dbSetOrder(1))
		SM0->(dbSeek(cEmpAnt,.F.))
		While !SM0->(Eof()) .and. SM0->M0_CODIGO == cEmpAnt
			If RGB->(FieldPos("RGB_LOTPLS")) > 0
				If RGB->(DbSeek(xFilial('RGB')+(BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)),.F.))
					lSRC := .T.
					lRGB := .T.
					Store COLS "RGB" TO aColsSRC FROM aHeade2RGB VETTRAB aVetSRC While ;
						Alltrim(RGB->RGB_LOTPLS) == Alltrim(BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT))
					aHeade2SRC := aclone(aHeade2RGB)
					Exit
				Endif
			ENDIF
			if !lRGB
				If SRC->(DbSeek(xFilial('SRC')+(BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)),.F.))
					lSRC := .T.
					Store COLS "SRC" TO aColsSRC FROM aHeade2SRC VETTRAB aVetSRC While ;
						Alltrim(SRC->RC_LOTPLS) == Alltrim(BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT))
					Exit
				Endif
			endIf
			SM0->(dbSkip())
		EndDo
		
		SM0->(RestArea(aAreaSM0))
		If !lSRC
			aHeade2SRC:={}
			If RGB->(FieldPos("RGB_LOTPLS")) > 0
				For i:=1 to Len(aHeaderRGB)
					aadd(aHeade2SRC,aHeaderRGB[i])
				Next i
				Store COLS Blank "RGB" TO aColsSRC FROM aHeade2SRC
			else
				For i:=1 to Len(aHeaderSRC)
					If !Alltrim(aHeaderSRC[i,2])$"RC_DESCPD"
						aadd(aHeade2SRC,aHeaderSRC[i])
					Endif
				Next i
				Store COLS Blank "SRC" TO aColsSRC FROM aHeade2SRC
			EndIf
		EndIf
		
		lSRD := .F.
		If ! SRD->(DbSeek(xFilial("SRD")+BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)))
			aHeade2SRD:={}
			For i:=1 to Len(aHeaderSRD)
				If !Alltrim(aHeaderSRD[i,2])$"RD_DESCPD"
					aadd(aHeade2SRD,aHeaderSRD[i])
				Endif
			Next i
			Store COLS Blank "SRD" TO aColsSRD FROM aHeade2SRD
		Else
			lSRD := .T.
			Store COLS "SRD" TO aColsSRD FROM aHeade2SRD VETTRAB aVetSRD While ;
				Alltrim(SRD->RD_LOTPLS) == Alltrim(BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT))
		Endif
		
		// Preenche o nome no AcolsSRC
		If Len(aColsSRC) > 0
			SRA->(dbSetOrder(1))
			If RGB->(FieldPos("RGB_LOTPLS")) > 0
				nPos 	:= aScan(aHeaderRGB,{|x| ALLTRIM(x[2]) == 'RGB_NOME'})
				nPosMat := aScan(aHeaderRGB,{|x| ALLTRIM(x[2]) == 'RGB_MAT'})
			else
				nPos 	:= aScan(aHeaderSRC,{|x| ALLTRIM(x[2]) == 'RC_NOME'})
				nPosMat := aScan(aHeaderSRC,{|x| ALLTRIM(x[2]) == 'RC_MAT'})
			EndIf
			
			For i:= 1 to Len(aColsSRC)
				If Empty(aColsSRC[i][nPosMat])
					aColsSRC[i][nPos]	:= 'NAO APLICAVEL'
				Else
					If SRA->(dbSeek(xFilial('SRA')+aColsSRC[i][nPosMat],.F.))
						aColsSRC[i][nPos]	:= SRA->RA_NOME
					Else
						aColsSRC[i][nPos]	:= 'NAO ENCONTRADO'
					EndIf
				EndIf
			Next
		EndIf
	Endif

	//Leitura dos titulos de contestacao             
	If nOpc == 2 .OR. nOpc == 4	 						
		If BAF->(FieldPos("BAF_SEQIMP")) > 0
			
			If ! Empty(BAF->BAF_SEQIMP)
				
				Store Header "SE1" TO aHeaderSE1 For .T.
				BRJ->(DbSetOrder(1))
				
				If ! BRJ->(MsSeek(xFilial("BRJ")+BAF->BAF_SEQIMP))
					Store COLS Blank "SE1" TO aColsSE1 FROM aHeaderSE1
				Else
					SE1->(DbSetOrder(1))

					//Busca novos campos com titulo de NDC                                     
					If BRJ->( FieldPos("BRJ_PRENDC") ) > 0 .And. BRJ->( FieldPos("BRJ_NUMNDC") ) > 0 .And. BRJ->( FieldPos("BRJ_PARNDC") ) > 0 .And. 	BRJ->( FieldPos("BRJ_TIPNDC") ) > 0
						aColsAux1 := {}
						aColsAux2 := {}
						aColsSE1  := {}
						
						If ! SE1->(MsSeek(xFilial("SE1")+BRJ->(BRJ_PREFIX+ALLTRIM(BRJ_NUMTIT)+BRJ_PARCEL+BRJ_TIPTIT))) .And. ;
								! SE1->(MsSeek(xFilial("SE1")+BRJ->(BRJ_PRENDC+ALLTRIM(BRJ_NUMNDC)+BRJ_PARCEL+BRJ_TIPNDC)))
							Store COLS Blank "SE1" TO aColsSE1 FROM aHeaderSE1
						Else
							
							//Monta aCols auxiliares                                                   
							If SE1->(MsSeek(xFilial("SE1")+BRJ->(BRJ_PREFIX+ALLTRIM(BRJ_NUMTIT)+BRJ_PARCEL+BRJ_TIPTIT)))
								Store COLS "SE1" TO aColsAux1 FROM aHeaderSE1 VETTRAB aVetSE1 While ;
									SE1->(E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO) == ;
									xFilial("SE1")+BRJ->(BRJ_PREFIX+ALLTRIM(BRJ_NUMTIT)+BRJ_PARCEL+BRJ_TIPTIT)
							EndIf
							
							If SE1->(MsSeek(xFilial("SE1")+BRJ->(BRJ_PRENDC+ALLTRIM(BRJ_NUMNDC)+BRJ_PARCEL+BRJ_TIPNDC)))
								Store COLS "SE1" TO aColsAux2 FROM aHeaderSE1 VETTRAB aVetSE1 While ;
									SE1->(E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO) == ;
									xFilial("SE1")+BRJ->(BRJ_PRENDC+ALLTRIM(BRJ_NUMNDC)+BRJ_PARCEL+BRJ_TIPNDC)
							EndIf
							
							//? Adiciona para o aCols principal os aCols auxiliares                      ?
							If len(aColsAux1) > 0
								For nI := 1 to len(aColsAux1)
									Aadd(aColsSE1,aColsAux1[nI])
								Next
							EndIf
							
							If len(aColsAux2) > 0
								For nI := 1 to len(aColsAux2)
									Aadd(aColsSE1,aColsAux2[nI])
								Next
							EndIf
							
						EndIf
						
					Else
						
						If ! SE1->(MsSeek(xFilial("SE1")+BRJ->(BRJ_PREFIX+ALLTRIM(BRJ_NUMTIT)+BRJ_PARCEL+BRJ_TIPTIT)))
							Store COLS Blank "SE1" TO aColsSE1 FROM aHeaderSE1
						Else
							Store COLS "SE1" TO aColsSE1 FROM aHeaderSE1 VETTRAB aVetSE1 While ;
								SE1->(E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO) == ;
								xFilial("SE1")+BRJ->(BRJ_PREFIX+ALLTRIM(BRJ_NUMTIT)+BRJ_PARCEL+BRJ_TIPTIT)
						EndIf
						
					EndIf
					
				Endif
				
				ASort(aColsSE1,,,{|x,y| x[1] + x[2] < y[1] + y[2]})
				
			EndIf
			
		EndIf
		
	EndIf
	
	aSize := MsAdvSize(.T.)
	aObjects := {}
	AAdd( aObjects, { 1, 1, .T., .T., .F. } )
	AAdd( aObjects, { 1, 1, .T., .T., .T. } )
	
	aInfo 	:= { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 }
	aPosObj := MsObjSize( aInfo, aObjects, .T., .F. )

	//Visualizando Titulo - Quando mostra Aba Titulo de Contestacao
	//(Visualizacao e Exclusao) 										
	//SIM - Se o Titulo foi criado anterior a criacao do MV_GERPTU,sera exibido.
	//NAO - Se foi criado posterior, nao tera titulo no SE1 e nao sera exibido a aba
	If ( (nOpc == 2 .OR. nOpc == 4) .AND. len(aColsAux1) > 0)  .OR.  ( (nOpc == 2 .OR. nOpc == 4) .AND. (len(aColsAux1) > 0 .AND.  len(aColsAux2) > 0) )
		lTitCont := .T.
	Else
		lTitCont := .F.
	EndIf

	iF !lAutoma
		//? Cria Dialog...                                                           ?
		//Agora eh possivel ter BAU_CALIMP=2 gerando SE2 e SE7 portanto sempre sera apresentado todas as pastas
		DEFINE MSDIALOG oDlg1 TITLE cCadastro FROM aSize[7],0 TO aSize[6],aSize[5] OF GetWndDefault() Pixel

		@ aPosObj[2][1],aPosObj[2][2] FOLDER oFolder SIZE aPosObj[2][3],aPosObj[2][4] OF oDlg1 PIXEL PROMPTS STR0048,STR0049,STR0154,Iif(lTitCont,STR0051,STR0155),STR0156,STR0129,STR0054

		oEnchoice := BAF->(MSMGET():New("BAF",BAF->(Recno()),K_Visualizar,,,,nil,aPosObj[1],nil,,,,,oDlg1,,,.F.))

		oBrwSE2 := TPLSBrw():New(001,002,aPosObj[2][3]-3,aPosObj[2][4]-14,nil  ,oFolder:aDialogs[1],nil    , nil ,nil    ,nil   ,nil, .T.   ,nil  ,.T.   ,nil   ,aHeaderSE2,aColsSE2,.F.,"SE2",K_Visualizar,STR0052,nil,nil) //"Titulos a Pagar Gerados pelo Lote"
		oBrwBGQ := TPLSBrw():New(001,002,aPosObj[2][3]-3,aPosObj[2][4]-14,nil  ,oFolder:aDialogs[2],nil    , nil ,nil    ,nil   ,nil, .T.   ,nil  ,.T.   ,nil   ,aHeaderBGQ,aColsBGQ,.F.,"BGQ",K_Visualizar,STR0053,nil,nil) //"Debitos"
		oBrwSC7 := TPLSBrw():New(001,002,aPosObj[2][3]-3,aPosObj[2][4]-14,nil  ,oFolder:aDialogs[3],nil    , nil ,nil    ,nil   ,nil, .T.   ,nil  ,.T.   ,nil   ,aHeaderSC7,aColsSC7,.F.,"SC7",K_Visualizar,"Pedido de Compra",nil,nil) //"Pedido de Compra"
		if RGB->(FieldPos("RGB_LOTPLS")) > 0
			oBrwSRC := TPLSBrw():New(001,002,aPosObj[2][3]-3,aPosObj[2][4]-14,nil  ,oFolder:aDialogs[4],nil    , nil ,nil    ,nil   ,nil, .T.   ,nil  ,.T.   ,nil   ,aHeade2SRC,aColsSRC,.F.,"RGB",K_Visualizar,"Autonomo",nil,nil) //"Folha"
		else
			oBrwSRC := TPLSBrw():New(001,002,aPosObj[2][3]-3,aPosObj[2][4]-14,nil  ,oFolder:aDialogs[4],nil    , nil ,nil    ,nil   ,nil, .T.   ,nil  ,.T.   ,nil   ,aHeade2SRC,aColsSRC,.F.,"SRC",K_Visualizar,"Autonomo",nil,nil) //"Folha"
		endIf
		oBrwSRD := TPLSBrw():New(001,002,aPosObj[2][3]-3,aPosObj[2][4]-14,nil  ,oFolder:aDialogs[5],nil    , nil ,nil    ,nil   ,nil, .T.   ,nil  ,.T.   ,nil   ,aHeade2SRD,aColsSRD,.F.,"SRD",K_Visualizar,"Hist. Auton.",nil,nil) //"Folha"
		oBrwSE1 := TPLSBrw():New(001,002,aPosObj[2][3]-3,aPosObj[2][4]-14,nil  ,oFolder:aDialogs[6],nil    , nil ,nil    ,nil   ,nil, .T.   ,nil  ,.T.   ,nil   ,aHeaderSE1,aColsSE1,.F.,"SE1",K_Visualizar,STR0130,nil,nil) //"Titulos Contestacao Gerados pelo Lote"
		oBrwBEM := TPLSBrw():New(001,002,aPosObj[2][3]-3,aPosObj[2][4]-14,nil  ,oFolder:aDialogs[7],nil    , nil ,nil    ,nil   ,nil, .T.   ,nil  ,.T.   ,nil   ,aHeaderBEM,aColsBEM,.F.,"BEM",K_Visualizar,STR0054,nil,nil) //"Criticas"
		
		//-------------------------------------------------------------------
		//  LGPD
		//-------------------------------------------------------------------
		objCENFUNLGP:useLogUser()
			
		//Ativa Dialog...
		ACTIVATE MSDIALOG oDlg1 CENTERED ON INIT Eval( { || EnChoiceBar(oDlg1,bBotOk,bCancel,.f.,aButtons) } )
	
	EndIf

	//Trata se for a exclusao do lote...
	If nOpca == K_OK .OR. lAutoma
		
		//Exclusao do lote...
		If nOpc == K_Excluir .or. nOpc == K_Alterar
			
			If ExistBlock("PLS470OK")
				
				lRet := ExecBLock("PLS470OK",.F.,.F.,{"EL",dDataBase})
				
				If !lRet
					Return
				Endif
				
			EndIf
			
			lConfirm := aRet[5]
			aEstorno := aClone(aRet[6])
			
			If lConfirm .and. Len(aEstorno)>0
				
				for nI:=1 to len(aEstorno)
					MaIntBxCP(2,{aEstorno[nI,2]},,{aEstorno[nI,4]},,{.f.,.f.,.f.,.f.,.f.,.f.},,{{aEstorno[nI,4]}},,aEstorno[nI,6])
				next
				
			EndIf
			If !lAutoma
				msAguarde( {|| PLSA470DEL(aVetSE2,aVetBGQ,aVetBEM,aVetSC7,dDataPagto, aVetSRC, cFilSC7, lAutoma) }, STR0055,"", .T.) //"Excluindo lote de pagamento ..."
			Else
				PLSA470DEL(aVetSE2,aVetBGQ,aVetBEM,aVetSC7,dDataPagto, aVetSRC, cFilSC7, lAutoma)
			EndIf
			
		Endif
		
	Endif
	
endIf

Return(.F.)

/*/{Protheus.doc} plDelBGQTIT
exclui bgq pelo titulo
@type function
@author PLSTEAM
@since 26.12.19
@version 1.0
/*/
static function plDelBGQTIT(cPrefixo, cNum, cParcela, cTipo)
local cSql := ''

//BGQ_FILIAL+BGQ_PREFIX+BGQ_NUMTIT+BGQ_PARCEL+BGQ_TIPTIT                                                                                                          
cSql := " UPDATE " + retSQLName("BGQ") + " SET D_E_L_E_T_ = '*' "

if PLCHKRCD("BGQ")
	cSql += " ,R_E_C_D_E_L_ = R_E_C_N_O_"  
endIf

cSql += "  WHERE BGQ_FILIAL = '" + xFilial("BGQ") + "' "
cSql += "    AND BGQ_PREFIX = '" + cPrefixo + "' "
cSql += "    AND BGQ_NUMTIT = '" + cNum + "' "
cSql += "    AND BGQ_PARCEL = '" + cParcela + "' "
cSql += "    AND BGQ_TIPTIT = '" + cTipo + "' "
cSql += "    AND BGQ_LANAUT = '1' "
if BGQ->(fieldPos("BGQ_SEQIMP")) > 0
	cSql += "    AND BGQ_SEQIMP = ' ' "
endif
cSql += "    AND D_E_L_E_T_ = ' ' "

PLSCOMMIT(cSql)

return

/*/{Protheus.doc} plDelBGQCDL
exclui bgq pelo lote
@type function
@author PLSTEAM
@since 26.12.19
@version 1.0
/*/
static function plDelBGQCDL(cCodOpe, cCodRda, cAno, cMes, cCodLanC, cCodLanD, cCodLanR)
local cSql := ''

//BGQ_FILIAL+BGQ_CODOPE+BGQ_CODIGO+BGQ_ANO+BGQ_MES+BGQ_CODLAN+BGQ_OPELOT+BGQ_NUMLOT                                                                               
cSql := " UPDATE " + retSQLName("BGQ") + " SET D_E_L_E_T_ = '*' "  

if PLCHKRCD("BGQ")
	cSql += " ,R_E_C_D_E_L_ = R_E_C_N_O_"  
endIf

cSql += "  WHERE BGQ_FILIAL   = '" + xFilial("BGQ") + "' "
cSql += "    AND BGQ_CODOPE   = '" + cCodOpe + "' "
cSql += "    AND BGQ_CODIGO   = '" + cCodRda + "' "
cSql += "    AND BGQ_ANO      = '" + cAno + "' "
cSql += "    AND BGQ_MES      = '" + cMes + "' "
cSql += "    AND ( BGQ_CODLAN = '" + cCodLanC + "' OR BGQ_CODLAN = '" + cCodLanD + "' OR BGQ_CODLAN = '" + cCodLanR + "' ) "
cSql += "    AND BGQ_PREFIX   <> ' ' "
cSql += "    AND BGQ_NUMTIT   <> ' ' "
cSql += "    AND BGQ_PARCEL   <> ' ' "
cSql += "    AND BGQ_TIPTIT   <> ' ' "
cSql += "    AND BGQ_LANAUT = '1' "
cSql += "    AND D_E_L_E_T_ = ' ' "

PLSCOMMIT(cSql)

return

/*/{Protheus.doc} plDelBGQLOT
exclui bgq pelo lote
@type function
@author PLSTEAM
@since 26.12.19
@version 1.0
/*/
static function plDelBGQLOT(cCodOpe, cCodRda, cAno, cMes, cNumLot)
local cSql := ''

//BGQ_FILIAL+BGQ_CODIGO+BGQ_ANO+BGQ_MES+BGQ_CODOPE+BGQ_OPELOT+BGQ_NUMLOT     
cSql := " UPDATE " + retSQLName("BGQ") + " SET D_E_L_E_T_ = '*' "  

if PLCHKRCD("BGQ")
	cSql += " ,R_E_C_D_E_L_ = R_E_C_N_O_"  
endIf

cSql += "  WHERE BGQ_FILIAL = '" + xFilial("BGQ") + "' "
cSql += "    AND BGQ_CODIGO = '" + cCodRda + "' "
cSql += "    AND BGQ_ANO    = '" + cAno + "' "
cSql += "    AND BGQ_MES    = '" + cMes + "' "
cSql += "    AND BGQ_CODOPE = '" + cCodOpe + "' "
cSql += "    AND BGQ_OPELOT = '" + cCodOpe + "' "
cSql += "    AND BGQ_NUMLOT = '" + cNumLot + "' "
cSql += "    AND BGQ_LANAUT = '1' "
cSql += "    AND BGQ_NUMLAU = 'BBC       ' "
cSql += "    AND D_E_L_E_T_ = ' ' "

PLSCOMMIT(cSql)

return

/*/{Protheus.doc} plDelB15
exclui b15
@type function
@author PLSTEAM
@since 26.12.19
@version 1.0
/*/
static function plDelB15(cCodOpe, cCodRda, cAno, cMes, cNumLot)
local cSql := ''

//B15_FILIAL+B15_OPERDA+B15_ANOLOT+B15_MESLOT+B15_NUMLOT+B15_CODRDA+B15_CLIENT+B15_LOJA                                                                           
cSql := " UPDATE " + retSQLName("B15") + " SET D_E_L_E_T_ = '*' "  

if PLCHKRCD("B15")
	cSql += " ,R_E_C_D_E_L_ = R_E_C_N_O_"  
endIf

cSql += "  WHERE B15_FILIAL = '" + xFilial("B15") + "' "
cSql += "    AND B15_OPERDA = '" + cCodOpe + "' "
cSql += "    AND B15_ANOLOT = '" + cAno + "' "
cSql += "    AND B15_MESLOT = '" + cMes + "' "
cSql += "    AND B15_NUMLOT = '" + cNumLot + "' "
cSql += "    AND B15_CODRDA = '" + cCodRDA + "' "
cSql += "    AND D_E_L_E_T_ = ' ' "

PLSCOMMIT(cSql)

return

/*/{Protheus.doc} plDelBMR
exclui bmr
@type function
@author PLSTEAM
@since 26.12.19
@version 1.0
/*/
static function plDelBMR(cOpeRda, cCodOpe, cCodRda, cAno, cMes, cNumLot)
local cSql := ''

//BMR_FILIAL+BMR_OPERDA+BMR_CODRDA+BMR_OPELOT+BMR_ANOLOT+BMR_MESLOT+BMR_NUMLOT                                                                                    
cSql := " UPDATE " + retSQLName("BMR") + " SET D_E_L_E_T_ = '*' "  

if PLCHKRCD("BMR")
	cSql += " ,R_E_C_D_E_L_ = R_E_C_N_O_"  
endIf

cSql += "  WHERE BMR_FILIAL = '" + xFilial("BMR") + "' "
cSql += "    AND BMR_OPERDA = '" + cOpeRda + "' "
cSql += "    AND BMR_CODRDA = '" + cCodRDA + "' "
cSql += "    AND BMR_OPELOT = '" + cCodOpe + "' "
cSql += "    AND BMR_ANOLOT = '" + cAno + "' "
cSql += "    AND BMR_MESLOT = '" + cMes + "' "
cSql += "    AND BMR_NUMLOT = '" + cNumLot + "' "
cSql += "    AND D_E_L_E_T_ = ' ' "

PLSCOMMIT(cSql)

return

/*/{Protheus.doc} plDelBMS
exclui bms
@type function
@author PLSTEAM
@since 26.12.19
@version 1.0
/*/
static function plDelBMS(cOpeRda, cCodOpe, cCodRda, cAno, cMes, cNumLot)
local cSql := ''

//BMS_FILIAL+BMS_OPERDA+BMS_CODRDA+BMS_OPELOT+BMS_ANOLOT+BMS_MESLOT+BMS_NUMLOT+BMS_CODLAN+BMS_CODPLA+BMS_CC                                                       
cSql := " UPDATE " + retSQLName("BMS") + " SET D_E_L_E_T_ = '*' "  

if PLCHKRCD("BMS")
	cSql += " ,R_E_C_D_E_L_ = R_E_C_N_O_"  
endIf

cSql += "  WHERE BMS_FILIAL = '" + xFilial("BMS") + "' "
cSql += "    AND BMS_OPERDA = '" + cOpeRda + "' "
cSql += "    AND BMS_CODRDA = '" + cCodRDA + "' "
cSql += "    AND BMS_OPELOT = '" + cCodOpe + "' "
cSql += "    AND BMS_ANOLOT = '" + cAno + "' "
cSql += "    AND BMS_MESLOT = '" + cMes + "' "
cSql += "    AND BMS_NUMLOT = '" + cNumLot + "' "
cSql += "    AND D_E_L_E_T_ = ' ' "

PLSCOMMIT(cSql)

return

/*/{Protheus.doc} PLSA470DEL
Exclusao de lote de pagamento 
@type function
@author PLSTEAM
@since 26.12.19
@version 1.0
/*/
Function PLSA470DEL(aVetSE2, aVetBGQ, aVetBEM, aVetSC7, dDataPagto, aVetSRC, cFilSC7, lAutoma)
Local nInd 			:= 0
Local nSeq    		:= 0
Local nVlrExc		:= 0
Local nRDAExc		:= 0
Local cCodRDa   	:= ''       
Local cCodInt		:= ''
Local cAnoLot		:= ''
Local cMesLot		:= ''
Local cLote			:= ''
Local cIdeRot		:= ''
Local cCodCha		:= ''
Local cHorIni 		:= time()
Local cDatIni 		:= dtos(date())
Local cCodUsr		:= RetCodUsr()
Local cCodCreUdf    := GetNewPar("MV_PLSCUSD","903")
Local cCodDebUdf    := GetNewPar("MV_PLSDUSD","904")
Local cCodRestUdf   := GetNewPar("MV_PLSRUSD","905")
Local aRet			:= {} 
Local aPL470LEX 	:= {}	//	Para uso do P.E. PL470LEX - Ap?s exclusão fora da transacao
Local lFieldNDC     := BRJ->( FieldPos("BRJ_PRENDC") ) > 0 .And. BRJ->( FieldPos("BRJ_NUMNDC") ) > 0 .And. BRJ->( FieldPos("BRJ_PARNDC") ) > 0 .And. 	BRJ->( FieldPos("BRJ_TIPNDC") ) > 0 
Local lPL470EXC		:= ExistBlock("PL470EXC")
Local lExclSE2 		:= .t.
local lRecOpen		:= .f.
local lFoundBAU		:= .f.

local lBRJField1	:= (BRJ->( FieldPos("BRJ_PRESE2") ) > 0 .And. BRJ->( FieldPos("BRJ_NUMSE2") ) > 0 .And. ;
						BRJ->( FieldPos("BRJ_PARSE2") ) > 0 .And. BRJ->( FieldPos("BRJ_TIPSE2") ) > 0)

local lBRJField2	:= (BRJ->( FieldPos("BRJ_PREE2N") ) > 0 .And. BRJ->( FieldPos("BRJ_NUME2N") ) > 0 .And. ;
						BRJ->( FieldPos("BRJ_PARE2N") ) > 0 .And. BRJ->( FieldPos("BRJ_TIPE2N") ) > 0 .And. ;   
						BRJ->( FieldPos("BRJ_PRENDC") ) > 0 .And. BRJ->( FieldPos("BRJ_NUMNDC") ) > 0 .And. ;
						BRJ->( FieldPos("BRJ_PARNDC") ) > 0 .And. BRJ->( FieldPos("BRJ_TIPNDC") ) > 0 )


default dDataPagto  := ctod("")
default aVetSRC		:= {}
default cFilSC7		:= xFilial('SC7')
default lAutoma		:= .F.

if ! lAutoma
	msProcTxt(STR0178) //Validando Recursos de Glosa
endIf

lRecOpen := PL470CHRGExs( BAF->BAF_CODOPE, BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT) )

if lRecOpen

	if ! lAutoma
		help(nil, nil , STR0179, nil, STR0180, 1, 0, NIL, NIL, NIL, NIL, NIL, { STR0181 } ) //aten??o / "Existe Recurso de Glosa associado ao lote de pagamento. O lote não ser? exclu?do." / "Caso queira excluir o lote, ser? necess?rio excluir o Recurso de Glosa primeiro."
	endIf

	return(.f.)

endIf

//Grava historico de processamento                                         
cIdeRot := "PLSA470 "
cCodCha := BAF->BAF_CODOPE + BAF->BAF_ANOLOT + BAF->BAF_MESLOT + BAF->BAF_NUMLOT + cDatIni + cHorIni
cHistor := STR0056 + BAF->BAF_ANOLOT + BAF->BAF_MESLOT + BAF->BAF_NUMLOT + STR0057 + dtoc(date()) + STR0058 + cHorIni //"Exclusao Lote Pagto - Lote: "###"   Data: "###"   Inicio: "

nSeq += 1

PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)
cHistor := STR0031 + PLSRtCdUsr() + " " + USRRETNAME(PLSRtCdUsr()) //"   Usuario: "
nSeq += 1

PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

aGrupo := UsrGrComp(cCodUsr)

For nInd := 1 To Len(aVetSC7)

	SC7->( msGoTo( aVetSc7[nInd] ) )

	cGrupCom := ""

	if len(aGrupo) > 0
		cGrupCom := aGrupo[1]
	endIf
		
	if cGrupCom <> alltrim(SC7->C7_GRUPCOM)

		if ! lAutoma
			MsgStop(STR0174)//"O Lote de pagamento não podera ser excluido pois a Solicita??o de compra pertence a um outro grupo de compradores."
		endIf

		return .F.

	endif		
	
	If SC7->C7_ENCER == 'E'
		
		If ! lAutoma
			MsgStop(STR0170)//"O pedido de compra vinculado se encontra encerrado. Nao sera possivel realizar a exclusao."
		EndIf

		Return .F.

	EndIf

	aCab  := {}
	aItem := {}
	
	AADD(aCab,    { "C7_NUM", SC7->C7_NUM, Nil} )
	AADD(aItem, { { "C7_NUM", SC7->C7_NUM, Nil} } )

	lMsErroAuto := .f.
	lMsHelpAuto := .f. 
	
	If ! SC7->(Deleted())

		MSExecAuto({|v,x,y,z| MATA120(v,x,y,z)},1,aCab,aItem,5)
	
		IF lMsErroAuto
			If !lAutoma
				MostraErro()
			EndIf
			Return(.F.)
		EndIF

	Endif                  
	  
Next nInd

nVlrExc := 0
nRDAExc := 0

BAU->(DbSetOrder(1))

Begin Transaction

For nInd := 1 To Len(aVetSRC)
	
	If RGB->(FieldPos("RGB_LOTPLS")) > 0
		RGB->(DbGoTo(aVetSRC[nInd]))
		cCodRDA := RGB->RGB_CODRDA
	else
		SRC->(DbGoTo(aVetSRC[nInd]))
		cCodRDA := SRC->RC_CODRDA
	endIf

	cCodInt 	:= BAF->BAF_CODOPE
	cAnoLot 	:= BAF->BAF_ANOLOT
	cMesLot 	:= BAF->BAF_MESLOT
	cLote   	:= BAF->BAF_NUMLOT
	lFoundBAU 	:= BAU->(msSeek(xFilial("BAU")+cCodRDA))

	If lFoundBAU .And. BAU->BAU_TIPPRE == GetNewPar("MV_PLSTPIN","OPE")

		if ! lAutoma 
			MsProcTxt(STR0064) //"Excluindo debitos/creditos (BGQ) ..."
		EndIf

		plDelBGQTIT(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO)

		cHistor := STR0065 + SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA) + STR0066 + time() //"   Titulo: "###"   Fim exclusao BGQ-Debitos/Creditos: "
		nSeq += 1
		PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

	Endif

	If lFoundBAU .And. GetNewPar("MV_PLATIOD","0") == '1' .AND. BGQ->(Fieldpos("BGQ_ATIVO")) > 0

		if ! lAutoma 
			MsProcTxt(STR0064) //"Excluindo debitos/creditos (BGQ) ..."
		EndIf

		plDelBGQCDL(PlsIntPad(), BAU->BAU_CODIGO, cAnoLot, cMesLot, cCodCreUdf, cCodDebUdf, cCodRestUdf)
		
		cHistor := STR0065 + SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA) + STR0066 + time() //"   Titulo: "###"   Fim exclusao BGQ-Debitos/Creditos: "
		nSeq += 1
		PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

	Endif
	
	//Exclui BRJ-Lancamentos de Contestacao                                    
	If BAU->BAU_TIPPRE == GetNewPar("MV_PLSTPIN","OPE")
		
		if !lAutoma 
			MsProcTxt(STR0067) //"Excluindo lancamentos de contestacao (SE1/BRJ) ..."
		EndIf
		
		SIX->(DbSetOrder(1))
		If SIX->(msSeek("BRJ1")) .And. BAF->(FieldPos("BAF_SEQIMP")) > 0
			
			BRJ->(DbSetOrder(1))
			If  BRJ->(msSeek(xFilial("BRJ")+BAF->BAF_SEQIMP))

				While ! BRJ->(Eof()) .And. BRJ->(BRJ_FILIAL+BRJ_CODIGO) == xFilial("BRJ")+BAF->BAF_SEQIMP
					
					If BRJ->BRJ_REGPRI == "1" .And. BRJ->BRJ_STATUS == "2" //Registro Principal e Status "Faturado"
						
						if !empty(BRJ->BRJ_ARQPAR)
							msgStop('O Lote de pagamento não poderá ser excluido, pois o lote de intercambio ['+BRJ->BRJ_CODIGO+'] possui contestação importada.' )
							disarmTransaction()
							return(.f.)
						endif

						SE1->(DbSetOrder(1))
						if SE1->(msSeek(xFilial("SE1")+BRJ->(BRJ_PREFIX+BRJ_NUMTIT+BRJ_PARCEL+BRJ_TIPTIT)))

							//Executa funcao que analisa a possibilidade de exclusao de uma guia que teve movimentacao financeiro relacionada..
							aRet := PLSA090AE1(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_CLIENTE,SE1->E1_LOJA)

							//[1] - Calendario contabil (.T./.F.)
							//[2] - Movimentado (.T./.F.)
							
							if aRet[1] .and. aRet[2]

								msgStop('O Lote de pagamento não podera ser excluido, verifique o titulo de cobrança. [' + SE1->(E1_PREFIXO +'-'+ E1_NUM +'-'+ E1_PARCELA +'-'+ E1_TIPO +'-'+ E1_CLIENTE) + ']' )
								
								disarmTransaction()
								return(.f.)

							else

								//exclui titulos ou nota				
								if ! P629ExcE1()
									disarmTransaction()
									return(.f.)
								endIf

							endIf

						endIf

		               	//Exclui novos titulos de NDC                                              
		               	If lFieldNDC .And. SE1->(msSeek(xFilial("SE1")+BRJ->(BRJ_PRENDC+BRJ_NUMNDC+BRJ_PARNDC+BRJ_TIPNDC)))
							
							//Executa funcao que analisa a possibilidade de exclusao de uma guia que teve movimentacao financeiro relacionada..
							aRet := PLSA090AE1(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_CLIENTE,SE1->E1_LOJA)

							//[1] - Calendario contabil (.T./.F.)
							//[2] - Movimentado (.T./.F.)
							
							if aRet[1] .and. aRet[2]

								msgStop('O Lote de pagamento não poderá ser excluido, verifique o titulo de cobrança. [' + SE1->(E1_PREFIXO +'-'+ E1_NUM +'-'+ E1_PARCELA +'-'+ E1_TIPO +'-'+ E1_CLIENTE) + ']' )
								
								disarmTransaction()
								return(.f.)

							else

								//exclui titulos ou nota				
								if ! P629ExcE1()
									disarmTransaction()
									return(.f.)
								endIf

							endIf

		         		Endif

						BRJ->(RecLock("BRJ",.F.))

						BRJ->BRJ_STATUS := "1"
						BRJ->BRJ_PREFIX := ""
						BRJ->BRJ_NUMTIT := ""
						BRJ->BRJ_PARCEL := ""
						BRJ->BRJ_TIPTIT := ""

						If lBRJField1
							BRJ->BRJ_PRESE2 := ""
							BRJ->BRJ_NUMSE2 := ""
							BRJ->BRJ_PARSE2 := ""
							BRJ->BRJ_TIPSE2 := ""
						Endif

						If lBRJField2
							BRJ->BRJ_PREE2N := ""
		    	    	   	BRJ->BRJ_NUME2N := ""
			        	   	BRJ->BRJ_PARE2N := ""
			        	   	BRJ->BRJ_TIPE2N := ""        
			        	   	BRJ->BRJ_PRENDC := ""
		    	    	   	BRJ->BRJ_NUMNDC := ""
			        	   	BRJ->BRJ_PARNDC := ""
			        	   	BRJ->BRJ_TIPNDC := ""  
						EndIf

						BRJ->(MsUnLock())

					EndIf

				BRJ->(DbSkip())
				EndDo

			Endif

		Endif

		cHistor := "   BRJ: " + SE2->E2_ANOBASE+SE2->E2_MESBASE+"12" + STR0068 + time() //"   Fim exclusao BRJ-Lancamentos de Contestacao: "
		nSeq += 1
		PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

	Endif
	
	//Executa funcao que atualiza dados nos movimentos limpando o lote...      
	if ! lAutoma 
		MsProcTxt(STR0071) //"Atualizando movimentacao ..."
	EndIf
	
	PLSATUVINP(BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT), BAF->BAF_CODOPE, BAF->BAF_CODOPE, nil, nil,;
				nil, nil, nil, nil, nil, nil, cCodRDA, BAF->BAF_ANOLOT, BAF->BAF_MESLOT, "2",;
				"", nil, nil, nil, nil, nil, nil, nil, dDataPagto)
				
	cHistor := STR0065 + SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA) + STR0061 + time() //"   Titulo: "###"   Fim da limpeza da movimentacao: "
	nSeq += 1
	PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

	//Exclui memoria de calculo                                                
	PLSHISDEL("PLSMPAG2 ",cCodInt+cAnoLot+cMesLot+cLote+cCodRda)

	//exclusao do arquivo B15 - BASES INSS PAGAMENTOS RDA'S - SEFIP            
	if !lAutoma 
		MsProcTxt(STR0122)
	EndIf
	
	plDelB15(BAF->BAF_CODOPE, cCodRda, BAF->BAF_ANOLOT, BAF->BAF_MESLOT, BAF->BAF_NUMLOT)

	cHistor := STR0123 + time()
	nSeq += 1
	PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)
	
	//exclusao do arquivo com a composicao do pagamento...                     
	If ! lAutoma 
		MsProcTxt(STR0074) //"Excluindo composicao do pagamento (BMR) ..."
	EndIf

	plDelBMR(BAF->BAF_CODOPE, BAF->BAF_CODOPE, cCodRda, BAF->BAF_ANOLOT, BAF->BAF_MESLOT, BAF->BAF_NUMLOT)

	cHistor := STR0075 + time() // "   Fim exclusao B15-Bases INSS Pagtos RDAs - SEFIP: "
	nSeq += 1
	PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)
	
	//exclusao do arquivo com a composicao do pagamento...                     
	// Indice 1: BMS_FILIAL+BMS_OPERDA+BMS_CODRDA+BMS_OPELOT+BMS_ANOLOT+BMS_MESLOT+BMS_NUMLOT+BMS_CODLAN+BMS_CODPLA+BMS_CC
	if ! lAutoma 
		MsProcTxt(STR0076) // "Excluindo composicao do pagamento (BMS) ..."
	EndIf
 	
	plDelBMS(BAF->BAF_CODOPE, BAF->BAF_CODOPE, cCodRda, BAF->BAF_ANOLOT, BAF->BAF_MESLOT, BAF->BAF_NUMLOT)

	cHistor := STR0077 + time() // "   Fim exclusao BMS-Resumo Composicao Pagamento: "
	nSeq += 1
	PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)
	
	//Grava historico de processamento                                         
	cHistor := STR0078 + BAF->BAF_ANOLOT + BAF->BAF_MESLOT + BAF->BAF_NUMLOT + STR0058 + cHorIni + STR0079 + time() //"   Fim da exclusao - Lote: "###"   Inicio: "###"   Fim: "
	nSeq += 1
	PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)
	
	If RGB->(FieldPos("RGB_LOTPLS")) > 0

		If !RGB->(Deleted())
			RGB->(RecLock("RGB",.F.))
			RGB->(DbDelete())
			RGB->(MsUnLock())
		Endif

	else
	
		If !SRC->(Deleted())
			SRC->(RecLock("SRC",.F.))
			SRC->(DbDelete())
			SRC->(MsUnLock())
		Endif

	endIf

Next nInd

For nInd := 1 To Len(aVetSC7)
	
	SC7->(DbGoTo(aVetSc7[nInd]))

	cCodRDA 	:= SC7->C7_CODRDA
	cCodInt 	:= BAF->BAF_CODOPE
	cAnoLot 	:= BAF->BAF_ANOLOT
	cMesLot 	:= BAF->BAF_MESLOT
	cLote   	:= BAF->BAF_NUMLOT
	lFoundBAU 	:= BAU->(msSeek(xFilial("BAU")+cCodRDA))

	If lFoundBAU .And. BAU->BAU_TIPPRE == GetNewPar("MV_PLSTPIN","OPE")

		if !lAutoma 
			MsProcTxt(STR0064) //"Excluindo debitos/creditos (BGQ) ..."
		EndIf
		
		plDelBGQTIT(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO)

		cHistor := STR0065 + SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA) + STR0066 + time() //"   Titulo: "###"   Fim exclusao BGQ-Debitos/Creditos: "
		nSeq += 1
		PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

	Endif

	If lFoundBAU .And. GetNewPar("MV_PLATIOD","0") == '1' .AND. BGQ->(Fieldpos("BGQ_ATIVO")) > 0

		if ! lAutoma 
			MsProcTxt(STR0064) //"Excluindo debitos/creditos (BGQ) ..."
		EndIf
		
		plDelBGQCDL(PlsIntPad(), BAU->BAU_CODIGO, cAnoLot, cMesLot, cCodCreUdf, cCodDebUdf, cCodRestUdf)

		cHistor := STR0065 + SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA) + STR0066 + time() //"   Titulo: "###"   Fim exclusao BGQ-Debitos/Creditos: "
		nSeq += 1
		PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

	Endif
	
	//Exclui BRJ-Lancamentos de Contestacao                                    
	If  BAU->BAU_TIPPRE == GetNewPar("MV_PLSTPIN","OPE")

		if ! lAutoma 
			MsProcTxt(STR0067) //"Excluindo lancamentos de contestacao (SE1/BRJ) ..."
		EndIf
		
		SIX->(DbSetOrder(1))
		If SIX->(msSeek("BRJ1")) .And. BAF->(FieldPos("BAF_SEQIMP")) > 0

			BRJ->(DbSetOrder(1))
			If BRJ->(msSeek(xFilial("BRJ")+BAF->BAF_SEQIMP))

				While ! BRJ->(Eof()) .And. BRJ->(BRJ_FILIAL+BRJ_CODIGO) == xFilial("BRJ")+BAF->BAF_SEQIMP

					If BRJ->BRJ_REGPRI == "1" .And. BRJ->BRJ_STATUS == "2" //Registro Principal e Status "Faturado"
						
						if !empty(BRJ->BRJ_ARQPAR)
							msgStop('O Lote de pagamento não poderá ser excluido, pois o lote de intercambio ['+BRJ->BRJ_CODIGO+'] possui contestação importada.' )
							disarmTransaction()
							return(.f.)
						endif

						SE1->(DbSetOrder(1))
						If SE1->(msSeek(xFilial("SE1")+BRJ->(BRJ_PREFIX+BRJ_NUMTIT+BRJ_PARCEL+BRJ_TIPTIT)))

							//Executa funcao que analisa a possibilidade de exclusao de uma guia que teve movimentacao financeiro relacionada..
							aRet := PLSA090AE1(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_CLIENTE,SE1->E1_LOJA)

							//[1] - Calendario contabil (.T./.F.)
							//[2] - Movimentado (.T./.F.)
							
							if aRet[1] .and. aRet[2]

								msgStop('O Lote de pagamento não poderá ser excluido, verifique o titulo de cobrança. [' + SE1->(E1_PREFIXO +'-'+ E1_NUM +'-'+ E1_PARCELA +'-'+ E1_TIPO +'-'+ E1_CLIENTE) + ']' )
								
								disarmTransaction()
								return(.f.)

							else

								//exclui titulos ou nota				
								if ! P629ExcE1()
									disarmTransaction()
									return(.f.)
								endIf

							endIf

						Endif

		    			//Exclui novos titulos de NDC                                              
			    		If lFieldNDC .And. SE1->(msSeek(xFilial("SE1")+BRJ->(BRJ_PRENDC+BRJ_NUMNDC+BRJ_PARNDC+BRJ_TIPNDC)))
							
							//Executa funcao que analisa a possibilidade de exclusao de uma guia que teve movimentacao financeiro relacionada..
							aRet := PLSA090AE1(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_CLIENTE,SE1->E1_LOJA)

							//[1] - Calendario contabil (.T./.F.)
							//[2] - Movimentado (.T./.F.)
							
							if aRet[1] .and. aRet[2]

								msgStop('O Lote de pagamento nãopodera ser excluido, verifique o titulo de cobrança. [' + SE1->(E1_PREFIXO +'-'+ E1_NUM +'-'+ E1_PARCELA +'-'+ E1_TIPO +'-'+ E1_CLIENTE) + ']' )
								
								disarmTransaction()
								return(.f.)

							else

								//exclui titulos ou nota				
								if ! P629ExcE1()
									disarmTransaction()
									return(.f.)
								endIf

							endIf

			       		Endif

						BRJ->(RecLock("BRJ",.F.))
						BRJ->BRJ_STATUS := "1"
						BRJ->BRJ_PREFIX := ""
						BRJ->BRJ_NUMTIT := ""
						BRJ->BRJ_PARCEL := ""
						BRJ->BRJ_TIPTIT := ""

						If lBRJField1
							BRJ->BRJ_PRESE2 := ""
							BRJ->BRJ_NUMSE2 := ""
							BRJ->BRJ_PARSE2 := ""
							BRJ->BRJ_TIPSE2 := ""
						Endif

						If lBRJField2    	
							BRJ->BRJ_PREE2N := ""
							BRJ->BRJ_NUME2N := ""
							BRJ->BRJ_PARE2N := ""
							BRJ->BRJ_TIPE2N := ""        
							BRJ->BRJ_PRENDC := ""
							BRJ->BRJ_NUMNDC := ""
							BRJ->BRJ_PARNDC := ""
							BRJ->BRJ_TIPNDC := ""  
						EndIf	

						BRJ->(MsUnLock())

					EndIf

					BRJ->(DbSkip())
				EndDo

			Endif

		Endif

		cHistor := "   BRJ: " + SE2->E2_ANOBASE+SE2->E2_MESBASE+"12" + STR0068 + time() //"   Fim exclusao BRJ-Lancamentos de Contestacao: "
		nSeq += 1
		PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

	Endif

	//Executa funcao que atualiza dados nos movimentos limpando o lote...      
	if ! lAutoma 
		MsProcTxt(STR0071) //"Atualizando movimentacao ..."
	EndIf

	PLSATUVINP(BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT),BAF->BAF_CODOPE,BAF->BAF_CODOPE,nil,nil,;
				nil,nil,nil,nil,nil,nil,cCodRDA,BAF->BAF_ANOLOT,BAF->BAF_MESLOT,"2",;
				"",nil,nil,nil,nil,nil,nil,nil,dDataPagto)

	cHistor := STR0065 + SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA) + STR0061 + time() //"   Titulo: "###"   Fim da limpeza da movimentacao: "
	nSeq += 1
	PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

	//Exclui memoria de calculo                                                
	PLSHISDEL("PLSMPAG2 ",cCodInt+cAnoLot+cMesLot+cLote+cCodRda)

	//exclusao do arquivo B15 - BASES INSS PAGAMENTOS RDA'S - SEFIP            
	if ! lAutoma 
		MsProcTxt(STR0122)
	EndIf
	
	plDelB15(BAF->BAF_CODOPE, cCodRda, BAF->BAF_ANOLOT, BAF->BAF_MESLOT, BAF->BAF_NUMLOT)

	cHistor := STR0123 + time()
	nSeq += 1
	PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)
	
	//exclusao do arquivo com a composicao do pagamento...                     
	if ! lAutoma 
		MsProcTxt(STR0074) //"Excluindo composicao do pagamento (BMR) ..."
	EndIf
	
	plDelBMR(BAF->BAF_CODOPE, BAF->BAF_CODOPE, cCodRda, BAF->BAF_ANOLOT, BAF->BAF_MESLOT, BAF->BAF_NUMLOT)

	cHistor := STR0075 + time() // "   Fim exclusao B15-Bases INSS Pagtos RDAs - SEFIP: "
	nSeq += 1
	PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)
	
	//exclusao do arquivo com a composicao do pagamento...                     
	// Indice 1: BMS_FILIAL+BMS_OPERDA+BMS_CODRDA+BMS_OPELOT+BMS_ANOLOT+BMS_MESLOT+BMS_NUMLOT+BMS_CODLAN+BMS_CODPLA+BMS_CC
	if ! lAutoma 
		MsProcTxt(STR0076) // "Excluindo composicao do pagamento (BMS) ..."
	EndIf
	
	plDelBMS(BAF->BAF_CODOPE, BAF->BAF_CODOPE, cCodRda, BAF->BAF_ANOLOT, BAF->BAF_MESLOT, BAF->BAF_NUMLOT)

	cHistor := STR0077 + time() // "   Fim exclusao BMS-Resumo Composicao Pagamento: "
	nSeq += 1
	PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)
	
	//Grava historico de processamento                                         ?
	cHistor := STR0078 + BAF->BAF_ANOLOT + BAF->BAF_MESLOT + BAF->BAF_NUMLOT + STR0058 + cHorIni + STR0079 + time() //"   Fim da exclusao - Lote: "###"   Inicio: "###"   Fim: "
	nSeq += 1
	PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

Next nInd

For nInd := 1 To Len(aVetSE2)
	
  	SE2->(DbGoTo(aVetSE2[nInd]))
    
	// Analisa se o registro ja foi deletado pela rotina automatica - caso de tipo "TX", por exemplo.
	if SE2->(Deleted())
		Loop
	endIf

   	//MV_PLPGUNI = '2' gera o pagamento do titulo principal sem impostos
	if SE2->E2_TIPO $ MVTAXA
		loop
	endIf
    
	//Inicializa variaveis                                                     
    cCodRDA 	:= SE2->E2_CODRDA
    cCodInt		:= BAF->BAF_CODOPE
    cAnoLot 	:= BAF->BAF_ANOLOT
    cMesLot 	:= BAF->BAF_MESLOT
    cLote   	:= BAF->BAF_NUMLOT
	lFoundBAU 	:= BAU->(msSeek(xFilial("BAU")+cCodRDA))

    //Exclui SE2-Contas a Pagar                                                
    if ! lAutoma 
		MsProcTxt(STR0069) //"Excluindo contas a pagar (SE2) ..."
	EndIf
	
    If ! (lExclSE2 := PLCANCRE()[1])

	    cHistor := STR0065 + SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA) + STR0135 //"   Titulo: "###"   titulo nãopode ser exclu?do!"
	    nSeq += 1
	    PLSHISGRV(cIdeRot, cCodCha, strZero(nSeq,4), cHistor)

	Else
		
		nRDAExc++
		nVlrExc += SE2->(E2_VALOR + E2_IRRF + E2_INSS + E2_VRETPIS + E2_VRETCOF + E2_VRETCSL)
	    cHistor := STR0065 + SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA) + STR0070 + time() //"   Titulo: "###"   Fim exclusao SE2-Contas a Pagar: "
	    nSeq += 1
	    
		PLSHISGRV(cIdeRot, cCodCha, strZero(nSeq,4), cHistor)
	    
		//Exclui BGQ-Debitos/Creditos                                              
	    if lFoundBAU .and. BAU->BAU_TIPPRE == getNewPar("MV_PLSTPIN", "OPE")
	       
		    if ! lAutoma 
				MsProcTxt(STR0064) //"Excluindo debitos/creditos (BGQ) ..."
			EndIf
			  
			plDelBGQTIT(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO)

	        cHistor := STR0065 + SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA) + STR0066 + time() //"   Titulo: "###"   Fim exclusao BGQ-Debitos/Creditos: "
	        nSeq += 1

	        PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

	    endIf

	    If lFoundBAU .and. getNewPar("MV_PLATIOD","0") == '1' .and. BGQ->(Fieldpos("BGQ_ATIVO")) > 0 

	        if ! lAutoma 
				MsProcTxt(STR0064) //"Excluindo debitos/creditos (BGQ) ..."
			EndIf
			  
			plDelBGQCDL(PlsIntPad(), BAU->BAU_CODIGO, cAnoLot, cMesLot, cCodCreUdf, cCodDebUdf, cCodRestUdf)
  
	       cHistor := STR0065 + SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA) + STR0066 + time() //"   Titulo: "###"   Fim exclusao BGQ-Debitos/Creditos: "
	       nSeq += 1
	       PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

	    Endif	  
		
		plDelBGQLOT(BAF->BAF_CODOPE, BAU->BAU_CODIGO, cAnoLot, cMesLot, BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT))

		//Exclui BRJ-Lancamentos de Contestacao                                    
	    If BAU->BAU_TIPPRE == GetNewPar("MV_PLSTPIN","OPE")

	        if ! lAutoma 
				MsProcTxt(STR0067) //"Excluindo lancamentos de contestacao (SE1/BRJ) ..."
			EndIf
			
	        SIX->(DbSetOrder(1))
	        If  SIX->(msSeek("BRJ1")) .and. BAF->(FieldPos("BAF_SEQIMP")) > 0

	            BRJ->(DbSetOrder(1))
	            If BRJ->(msSeek(xFilial("BRJ")+BAF->BAF_SEQIMP))

			        Do While ! BRJ->(Eof()) .And. BRJ->(BRJ_FILIAL+BRJ_CODIGO) == xFilial("BRJ")+BAF->BAF_SEQIMP
	    	    	 	
						 If BRJ->BRJ_REGPRI == "1" .And. BRJ->BRJ_STATUS == "2" //Registro Principal e Status "Faturado"
		            	    
							if !empty(BRJ->BRJ_ARQPAR)
								msgStop('O Lote de pagamento não poderá ser excluido, pois o lote de intercambio ['+BRJ->BRJ_CODIGO+'] possui contestação importada.' )
								disarmTransaction()
								return(.f.)
							endif

							SE1->(DbSetOrder(1))
	                		If SE1->(msSeek(xFilial("SE1")+BRJ->(BRJ_PREFIX+BRJ_NUMTIT+BRJ_PARCEL+BRJ_TIPTIT)))
							
								//Executa funcao que analisa a possibilidade de exclusao de uma guia que teve movimentacao financeiro relacionada..
								aRet := PLSA090AE1(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_CLIENTE,SE1->E1_LOJA)

								//[1] - Calendario contabil (.T./.F.)
								//[2] - Movimentado (.T./.F.)
								
								if aRet[1] .and. aRet[2]

									msgStop('O Lote de pagamento não podera ser excluido, verifique o titulo de cobrança. [' + SE1->(E1_PREFIXO +'-'+ E1_NUM +'-'+ E1_PARCELA +'-'+ E1_TIPO +'-'+ E1_CLIENTE) + ']' )
									
									disarmTransaction()
									return(.f.)

								else

									//exclui titulos ou nota				
									if ! P629ExcE1()
										disarmTransaction()
										return(.f.)
									endIf

								endIf

	    					EndIf			
		    				
							//Exclui novos titulos de NDC                                              
			               	If lFieldNDC .And. SE1->(msSeek(xFilial("SE1")+BRJ->(BRJ_PRENDC+BRJ_NUMNDC+BRJ_PARNDC+BRJ_TIPNDC)))
								
								//Executa funcao que analisa a possibilidade de exclusao de uma guia que teve movimentacao financeiro relacionada..
								aRet := PLSA090AE1(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_CLIENTE,SE1->E1_LOJA)

								//[1] - Calendario contabil (.T./.F.)
								//[2] - Movimentado (.T./.F.)
								
								if aRet[1] .and. aRet[2]

									msgStop('O Lote de pagamento nãopodera ser excluido, verifique o titulo de cobrança. [' + SE1->(E1_PREFIXO +'-'+ E1_NUM +'-'+ E1_PARCELA +'-'+ E1_TIPO +'-'+ E1_CLIENTE) + ']' )
									
									disarmTransaction()
									return(.f.)

								else

									//exclui titulos ou nota				
									if ! P629ExcE1()
										disarmTransaction()
										return(.f.)
									endIf

								endIf

			         		Endif

		                	BRJ->(RecLock("BRJ",.F.))
    	        		    BRJ->BRJ_STATUS := "1"
        		    	    BRJ->BRJ_PREFIX := ""
    	    	    	    BRJ->BRJ_NUMTIT := ""
	        	    	    BRJ->BRJ_PARCEL := ""
	        	    	    BRJ->BRJ_TIPTIT := ""

		        	   		If lBRJField1
								BRJ->BRJ_PRESE2 := ""
	    	    	    	    BRJ->BRJ_NUMSE2 := ""
		        	    	    BRJ->BRJ_PARSE2 := ""
		        	    	    BRJ->BRJ_TIPSE2 := "" 
		        	    	Endif 

	        	    	    If lBRJField2 	
								BRJ->BRJ_PREE2N := ""
			    	    	   	BRJ->BRJ_NUME2N := ""
				        	   	BRJ->BRJ_PARE2N := ""
				        	   	BRJ->BRJ_TIPE2N := ""        
				        	   	BRJ->BRJ_PRENDC := ""
			    	    	   	BRJ->BRJ_NUMNDC := ""
				        	   	BRJ->BRJ_PARNDC := ""
				        	   	BRJ->BRJ_TIPNDC := ""  
							EndIf

		    	   			BRJ->(MsUnLock())
		           		EndIf

		           	BRJ->(DbSkip())
		            EndDo

	            Endif   

	        Endif

        	cHistor := "   BRJ: " + SE2->E2_ANOBASE+SE2->E2_MESBASE+"12" + STR0068 + time() //"   Fim exclusao BRJ-Lancamentos de Contestacao: "
	        nSeq += 1
    	    PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

	    Endif

	    //Executa funcao que atualiza dados nos movimentos limpando o lote...      
	    if ! lAutoma 
			MsProcTxt(STR0071) //"Atualizando movimentacao ..."
		EndIf
		 
	    PLSATUVINP(BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT), BAF->BAF_CODOPE, BAF->BAF_CODOPE, nil, nil,;
	               nil, nil, nil, nil, nil, nil, cCodRDA, BAF->BAF_ANOLOT, BAF->BAF_MESLOT, "2",;
	               "", nil, nil, nil, nil, nil, nil, nil, dDataPagto)       

	    cHistor := STR0065 + SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA) + STR0061 + time() //"   Titulo: "###"   Fim da limpeza da movimentacao: "
	    nSeq += 1
	    PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

	    //Exclui memoria de calculo                                                
	    PLSHISDEL("PLSMPAG ",cCodInt+cAnoLot+cMesLot+cLote+cCodRda)

	    //exclusao do arquivo B15 - BASES INSS PAGAMENTOS RDA'S - SEFIP            
	    if ! lAutoma 
			MsProcTxt(STR0122)
		EndIf
		
		plDelB15(BAF->BAF_CODOPE, cCodRda, BAF->BAF_ANOLOT, BAF->BAF_MESLOT, BAF->BAF_NUMLOT)

	    cHistor := STR0123 + time()
	    nSeq += 1
	    PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

	    //exclusao do arquivo com a composicao do pagamento...                     
		if ! lAutoma 
			MsProcTxt(STR0074) //"Excluindo composicao do pagamento (BMR) ..."
		endIf

		plDelBMR(BAF->BAF_CODOPE, BAF->BAF_CODOPE, cCodRda, BAF->BAF_ANOLOT, BAF->BAF_MESLOT, BAF->BAF_NUMLOT)

	    cHistor := STR0075 + time() // "   Fim exclusao B15-Bases INSS Pagtos RDAs - SEFIP: "
	    nSeq += 1
	    PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)
	    
	    //exclusao do arquivo com a composicao do pagamento...                     
	    // Indice 1: BMS_FILIAL+BMS_OPERDA+BMS_CODRDA+BMS_OPELOT+BMS_ANOLOT+BMS_MESLOT+BMS_NUMLOT+BMS_CODLAN+BMS_CODPLA+BMS_CC
	    if ! lAutoma 
			MsProcTxt(STR0076) // "Excluindo composicao do pagamento (BMS) ..."
		endIf

		plDelBMS(BAF->BAF_CODOPE, BAF->BAF_CODOPE, cCodRda, BAF->BAF_ANOLOT, BAF->BAF_MESLOT, BAF->BAF_NUMLOT)

	    cHistor := STR0077 + time() // "   Fim exclusao BMS-Resumo Composicao Pagamento: "
	    nSeq += 1
	    PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)
	
	    //Grava historico de processamento                                         
		cHistor := STR0078 + BAF->BAF_ANOLOT + BAF->BAF_MESLOT + BAF->BAF_NUMLOT + STR0058 + cHorIni + STR0079 + time() //"   Fim da exclusao - Lote: "###"   Inicio: "###"   Fim: "
	    nSeq += 1
	    PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

	EndIf

    //BOPS 113091 - Permite excluir os lancamentos de debito/credito gerados   ?
    //              pelo ponto de entrada PLSPAG01.                            ?
    If lPL470EXC
		ExecBlock("PL470EXC",.F.,.F.,{cCodRda,cAnoLot,cMesLot})
	Endif

Next

If lExclSE2

	//Trata a exclusao das criticas...                                         
	if ! lAutoma 
		msProcTxt(STR0072) // "Excluindo criticas (BEM) ..."
	endIf
	
	for nInd := 1 to len(aVetBEM)

	    BEM->( msGoTo( aVetBEM[nInd] ) )
	
	    PLSATUVINP( BAF->(BAF_ANOLOT + BAF_MESLOT + BAF_NUMLOT), BAF->BAF_CODOPE, BAF->BAF_CODOPE,; 
					nil, nil, nil, nil, nil, nil, nil, nil, BEM->BEM_CODRDA, BAF->BAF_ANOLOT,; 
					BAF->BAF_MESLOT, "2", "", nil, nil, nil, nil, nil, nil, nil, dDataPagto) 

	    BEM->(RecLock("BEM", .f.))
	    BEM->(DbDelete())
	    BEM->(MsUnLock())           

	next

	cHistor := STR0073 + time() // "   Fim exclusao BEM-Criticas: "
	nSeq += 1
	PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

    //exclusao do arquivo com a composicao do pagamento...                     
    // Indice 1: BMS_FILIAL+BMS_OPELOT+BMS_ANOLOT+BMS_MESLOT+BMS_NUMLOT
    if ! lAutoma 
		MsProcTxt(STR0076) // "Excluindo composicao do pagamento (BMS) ..."
	EndIf

	plDelBMS(BAF->BAF_CODOPE, BAF->BAF_CODOPE, cCodRda, BAF->BAF_ANOLOT, BAF->BAF_MESLOT, BAF->BAF_NUMLOT)

    cHistor := STR0077 + time() // "   Fim exclusao BMS-Resumo Composicao Pagamento: "
    nSeq += 1
    PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

	//Grava historico de processamento                                         
	cHistor := STR0078 + BAF->BAF_ANOLOT + BAF->BAF_MESLOT + BAF->BAF_NUMLOT + STR0058 + cHorIni + STR0079 + time() // "   Fim da exclusao - Lote: " ## "   Inicio: " ## "   Fim: "
	nSeq += 1
	PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

	//exclusao do cabecalho do lote de pagamento                               
	//Carrega valores chave do lote antes da exclusao da BAF
	aPL470LEX := { BAF->BAF_CODOPE, BAF->BAF_ANOLOT, BAF->BAF_MESLOT, BAF->BAF_NUMLOT, BAF->BAF_LCDGDE, BAF->BAF_LCDGAT, BAF->BAF_PEGATE, BAF->BAF_PEGDE } 

	BAF->(RecLock("BAF",.F.))
	BAF->(DbDelete())
	BAF->(MsUnLock())   
	
	if ! lAutoma 
		MsProcTxt("Excluindo Lancamentos (BGQ) ...") 
	EndIf
	
	for nInd := 1 to len(aVetBGQ)
	
	    BGQ->(msGoTo(aVetBGQ[nInd]))
	
	    PLSATUVINP( BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT), BAF->BAF_CODOPE, BAF->BAF_CODOPE,;
					nil, nil, nil, nil, nil, nil, nil, nil, BGQ->BGQ_CODIGO, BAF->BAF_ANOLOT,;
					BAF->BAF_MESLOT, "2", "", nil, nil, nil, nil, nil, nil, nil, dDataPagto)    
	      
	next
	
else

	//ajusta valor do lote de pagamento                                        
	If  BAF->BAF_VLRBRU > 0

	    BAF->( recLock("BAF", .f.) )
			BAF->BAF_VLRBRU -= nVlrExc
			BAF->BAF_VLRLIQ := IIf( BAF->(BAF_VLRBRU-BAF_VLRIR)<0, 0, BAF->(BAF_VLRBRU-BAF_VLRIR) )
			BAF->BAF_RDAPAG := IIf( BAF->BAF_RDAPAG - nRDAExc>=0, BAF->BAF_RDAPAG - nRDAExc, 0 ) 
	    BAF->( msUnLock() )

	Endif

endIf	

//As informa??es Pertinentes ao Lote de Pagamento nãoForam especificadas      
//e ao realizar a exclusão do Lote nãoestava alterando o Status da guia     
//Permanecendo a guia sempre como Faturada						     
if len(aVetSE2) == 0 .and. len(aVetBGQ) == 0 .and. len(aVetBEM) == 0 .and. len(aVetSC7) == 0
	
	//Executa funcao que atualiza dados nos movimentos limpando o lote...      
	if ! lAutoma 
		msProcTxt(STR0071) //"Atualizando movimentacao ..."
	EndIf
	
	PLSATUVINP( BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT), BAF->BAF_CODOPE, BAF->BAF_CODOPE,;
				nil, nil, nil, nil, nil, nil, nil, nil, cCodRDA, BAF->BAF_ANOLOT, BAF->BAF_MESLOT, "2",;
				"", nil, nil, nil, nil, nil, nil, nil, dDataPagto)
	
	cHistor := STR0065 + SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA) + STR0061 + time() //"   Titulo: "###"   Fim da limpeza da movimentacao: "
	nSeq += 1
	PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)
	
	//Grava historico de processamento                                         
	cHistor := STR0078 + BAF->BAF_ANOLOT + BAF->BAF_MESLOT + BAF->BAF_NUMLOT + STR0058 + cHorIni + STR0079 + time() // "   Fim da exclusao - Lote: " ## "   Inicio: " ## "   Fim: "
	nSeq += 1
	PLSHISGRV(cIdeRot,cCodCha,strzero(nSeq,4),cHistor)

endIf

//Finaliza transacao...                                               
End Transaction

//Chamada do ponto de entrada apos a transacao e antes de finalizar a funcao
if ! empty(aPL470LEX) .and. existBlock("PL470LEX")
	execBlock("PL470LEX",.F.,.F.,aPL470LEX)
endIf

return()

/*/
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
???Programa  ? PLSA470PEX ? Autor ? Tulio Cesar       ? Data ? 31.08.2003 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Verifica se pode ser excluido o lote. se nao ha baixa      ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
Function PLSA470PEx(cTipo,lAutoma)
LOCAL nI			:= 0
LOCAL lPode    		:= .T.
LOCAL aTitulos 		:= {}
LOCAL lPodeCont 	:= .t.
LOCAL aTitCont  	:= {}
LOCAL aTitCri		:= {}
LOCAL aEstorno		:= {}
LOCAL lConfirm		:= .f.
LOCAL lBaixaMA		:= .f.
LOCAL cTipoTit 		:= GETMV("MV_PLTIPE2")

Default lAutoma		:= .F.

if cTipo == "SE2"
	
	cTipoTit := Eval({|| &cTipoTit })
	
	SE2->(DbSetOrder(12)) //E2_FILIAL+E2_PLOPELT+E2_PLLOTE+E2_NOMFOR
	if SE2->(MsSeek(xFilial("SE2")+BAF->(BAF_CODOPE+BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)))
	
		While !SE2->(Eof()) .And. SE2->(E2_FILIAL+E2_PLOPELT+E2_PLLOTE) == xFilial("SE2")+BAF->(BAF_CODOPE+BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)
	      
			if SE2->E2_VALOR <> SE2->E2_SALDO
	
				//Verifica se teve baixa manual ou automatica
				aBaixaSE5	:= {}
				Sel080Baixa("VL /BA /CP /",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,0,.f.,SE2->E2_FORNECE,SE2->E2_LOJA,.f.,.f.,.f.,0,.f.,.t.)
		      
		      	lBaixaMA := .f.
	   	   		
	   	   		if len(aBaixaSE5) > 0
	   	   		
			   		for nI := 1 to len(aBaixaSE5) 
			      		
			      		if SE5->(msSeek(xFilial("SE5")+aBaixaSE5[nI,21]+aBaixaSE5[nI,1]+aBaixaSE5[nI,2]+aBaixaSE5[nI,3]+aBaixaSE5[nI,4]+DToS(aBaixaSE5[nI,7])+aBaixaSE5[nI,5]+aBaixaSE5[nI,6]+aBaixaSE5[nI,9])) .and. empty(SE5->E5_DOCUMEN)
		      				lBaixaMA := .t.
		      				exit
			      		endIf
			      		
			      	next
			      		
			   endIf
		      		
				if lPode
					lPode := .F.
				endif
				
				if SE2->E2_TIPO <> 'NDF' 
					aadd(aEstorno,{SE2->E2_TIPO,SE2->(recno()),'',0,'',0})
				else	
					nPos := len(aEstorno)
					
					if nPos > 0 .and. empty(aEstorno[nPos,3])
						aEstorno[nPos,3] 	:= SE2->E2_TIPO
						aEstorno[nPos,4]	:= SE2->(recno())
						aEstorno[nPos,5]	:= {SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)+space(TamSX3("E5_DOCUMEN")[1]-len(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))}
						aEstorno[nPos,6] 	:= SE2->E2_VALOR
					else
						aAdd(aTitCri,{SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NOMFOR})
						lBaixaMA := .f.	
					endIf	
				endIf
				
				if lBaixaMA
					aAdd(aTitCri,{SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NOMFOR})
				else
					aAdd(aTitulos,{SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NOMFOR})
				endIf
				
			endIf
			
			if ( allTrim(SE2->E2_TIPO) == cTipoTit .and. allTrim(SE2->E2_LA) <> "" ) .and. lPodeCont
       			lPodeCont := .f.  
				aAdd(aTitCont,{SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NOMFOR})
   			endIf
	                  
			SE2->(dbSkip())
		endDo
	endIf

	//Verifica a presenca de NDF pois o titulo sofreu baixa e confirma a compensação
	if len(aTitCri) > 0
		aTitulos := aClone(aTitCri)
	elseIf len(aTitCont) == 0
		If !lAutoma
			lConfirm := msgYesNo('Confirmar o estorno da compensação dos titulos?')
		Else
			lConfirm := .T.
		EndIf

		if lConfirm 	
			aTitulos 	:= {} 
			lPode		:= .t.
		endIf	
	endIf		
endIf

return( { lPode, aTitulos, lPodeCont, aTitCont, lConfirm, aEstorno } )

/*/
??????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
??? Funcao   ? PLSA470EXC ? Autor ? Tulio Cesar       ? Data ? 09.02.2005 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Excluir um ou mais titulos gerados.                        ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
Function PLSA470EXC(cAlias,nReg,nOpc,cFilSC7)
local nI		:= 0
Local nVez		:= 0
LOCAL aDados    := {}
LOCAL aDadosNDF := {}
LOCAL nOrdSE2Esp:= GetNewPar("MV_PLSOSE2",11)
LOCAL aPos		:= 0
LOCAL nPos  	:= 0
LOCAL nPos2 	:= 0
LOCAL nPos3 	:= 0
LOCAL nPos4 	:= 0
LOCAL nQtd      := 0
LOCAL nTotSel   := 0
local lConfirm	:= .f.
local lBaixaMA	:= .f.
Local lExNFPed	:= .F. //Indica se ja .T. existe ou nao .F. NF vinculada ao pedido e compra
Local lExisPed	:= .F. //Indica se tem encontrou pedido de compra
Local cChaveReg	:= ""
Local cRet		:= ""
Local aTitulo   := {}
Local aCriticas := {}
local aEstorno	:= {}
local aMatAux	:= {}
local aRet		:= {}
local aBaixaFut	:= {}
local aCabec	:= {{"Prefixo","@C",30},{"Numero","@C",30}	,;
					{"Parcela","@C",30},{"Tipo","@C",30}	,;
					{"Critica","@C",250} 					 }
                                                                                                                          
Local dDataPagto	:= IIF(BAF->(FieldPos("BAF_DATPAG")) >0 ,BAF->BAF_DATPAG,ctod(""))
local cTipoSE2 		:= GETMV("MV_PLTIPE2")
local lRecOpen		:= .f.
local lBaixaFut		:= .f.

Default cFilSC7 	:= PADR(xFilial('SC7'),SC7->(FWSizeFilial()))

Private aBaixaSE5	:= {}
Private aCdCores := {	{ 'BR_VERMELHO',STR0138 },; //"titulo Baixado"
						{ 'BR_AMARELO', STR0139 },; //"titulo Contabilizado"
						{ 'BR_VERDE',   STR0140 }}  //"titulo/ Pedido de Compra Liberado para Exclusão"
						
Private aCores   := {	{ 'aDados[oCritica:nAt, 6] <> aDados[oCritica:nAt, 14]',	aCdCores[1,1] },;
						{ 'aDados[oCritica:nAt, 19] == "S"',						aCdCores[2,1] },;
						{ 'aDados[oCritica:nAt, 6] == aDados[oCritica:nAt, 14]',	aCdCores[3,1] }}
						
Private aLegenda  		:= { cCadastro, "Status" } 

//Verifico se o Lote tem algum recurso de glosa gravado. Se sim, interrompe o processo
lRecOpen := PL470CHRGExs( BAF->BAF_CODOPE, BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT) )

if !lRecOpen
	cTipoSE2 := eval({|| &cTipoSE2 })
	//??????????????????????????????????????????????????????????????????????????Ä¿
	//? Leitura dos titulos a pagar...                                           ?
	//????????????????????????????????????????????????????????????????????????????
	SE2->(DbSetOrder(nOrdSE2Esp))
	BAU->(DbSetOrder(1))
	if  SE2->(MsSeek(xFilial("SE2")+BAF->(BAF_CODOPE+BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)))
	    while !SE2->(Eof()) .and. SE2->(E2_FILIAL+E2_PLOPELT+E2_PLLOTE) = xFilial("SE2")+BAF->(BAF_CODOPE+BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)
			
			if empty(SE2->E2_TITPAI)
				aadd(aMatAux,{SE2->E2_CODRDA,SE2->E2_TIPO,SE2->(Recno()),SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)+space(TamSX3("E5_DOCUMEN")[1]-len(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))),SE2->E2_VALOR})
			endIf
			//???????????????????????????????????????????????????????????????????????????
			//? verifica se teve baixa manual
			//???????????????????????????????????????????????????????????????????????????
			aBaixaSE5	:= {}
			Sel080Baixa("VL /BA /CP /",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,0,.f.,SE2->E2_FORNECE,SE2->E2_LOJA,.f.,.f.,.f.,0,.f.,.t.)
	
	      	lBaixaMA := .f.
		   	if len(aBaixaSE5) > 0
		   	
		   		for nI := 1 to len(aBaixaSE5) 
		      		if SE5->(msSeek(xFilial("SE5")+aBaixaSE5[nI,21]+aBaixaSE5[nI,1]+aBaixaSE5[nI,2]+aBaixaSE5[nI,3]+aBaixaSE5[nI,4]+DToS(aBaixaSE5[nI,7])+aBaixaSE5[nI,5]+aBaixaSE5[nI,6]+aBaixaSE5[nI,9])) .and. empty(SE5->E5_DOCUMEN)
	      				lBaixaMA := .t.
	      				exit
	      			endIf
		      	next
		      		
		   	endIf
		   
		   	nQtd++
	        BAU->(MsSeek(xFilial("BAU")+SE2->E2_CODRDA))
	
			// Inclu?do condi??o para permitir exclusão de lote com NDF somente 				
			If empty(SE2->E2_TITPAI) .and. AllTrim(SE2->E2_TIPO) <> 'NDF' .or. ( AllTrim(SE2->E2_TIPO) == 'NDF' .and. SE2->E2_SALDO > 0 )
				
	         	aadd(aDados,{"Titulo",;//01
	         				 SE2->E2_CODRDA,;//02
	                         BAU->BAU_NOME,;//03
	                         SE2->(E2_PREFIXO+" "+E2_NUM+" "+E2_PARCELA+" "+E2_TIPO),;//04
	                         SE2->E2_VENCTO,;//05
	                         SE2->E2_VALOR,;//06
	                         SE2->E2_IRRF,;//07
	                         SE2->E2_INSS,;//08
	                         SE2->E2_ISS,;//09
	                         0,;//10
	                         SE2->E2_VRETPIS,;//11
	                         SE2->E2_VRETCOF,;//12
	                         SE2->E2_VRETCSL,;//13
	                         SE2->E2_SALDO,;//14
	                         SE2->(E2_FORNECE+" "+E2_LOJA),;//15
	                         SE2->E2_NOMFOR,;//16
	                         SE2->E2_NATUREZ,;//17
	                         STR0081,; //"Financeiro"-18
	                         SE2->E2_LA,;//19
	                         "2",;//20
	                         SE2->(Recno()),;//21
	                         .f.,;//22
	                         SE2->(E2_PREFIXO+E2_NUM)})//23
			EndIf
			
			If allTrim(SE2->E2_TIPO) == 'NDF' 
	        
	         	aadd(aDadosNDF,{ "Titulo",;//01	
	         					 SE2->E2_CODRDA,;//02
		                         BAU->BAU_NOME,;//03
		                         SE2->(E2_PREFIXO+" "+E2_NUM+" "+E2_PARCELA+" "+E2_TIPO),;//04
		                         SE2->E2_VENCTO,;//05
		                         SE2->E2_VALOR,;//06
		                         SE2->E2_IRRF,;//07
		                         SE2->E2_INSS,;//08
		                         SE2->E2_ISS,;//09
		                         0,;//10
		                         SE2->E2_VRETPIS,;//11
		                         SE2->E2_VRETCOF,;//12
		                         SE2->E2_VRETCSL,;//13
		                         SE2->E2_SALDO,;//14
		                         SE2->(E2_FORNECE+" "+E2_LOJA),;//15
		                         SE2->E2_NOMFOR,;//16
		                         SE2->E2_NATUREZ,;//17
		                         STR0081,; //"Financeiro"-18
		                         SE2->E2_LA,;//19
		                         "2",;//20
		                         SE2->(Recno()),;//21
		                         .f.,;//22
		                         SE2->(E2_PREFIXO+E2_NUM)})//23
	      endIf
	       
	      If lBaixaMA
				if (nPos2 := ascan(aDados,{|x| x[23] == SE2->(E2_PREFIXO+E2_NUM)})) > 0
				 	aDados[nPos2, 22] := lBaixaMA
				endIf
		  endIf
				                         
	    SE2->(DbSkip())
	    endDo
	endIf 
	
	//Pedidos de compra..                                                      
	SC7->(DbSetOrder(22))//C7_FILIAL+C7_LOTPLS+C7_CODRDA                                                                                                                                   
	If SC7->(dbSeek(cFilSC7+BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)))
		
		lExisPed := .T.
		If SC7->C7_ENCER == 'E'//Pedido de Compra encerrado - ja existe NF
			lExNFPed := .T.
		EndIf
	
		while !SC7->(Eof()) .and. SC7->(C7_FILIAL+C7_LOTPLS) = cFilSC7+BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)
			nQtd++
	     	BAU->(MsSeek(xFilial("BAU")+SC7->C7_CODRDA))
	
	     	aadd(aDados,{"Pedido",;//01 
	     				 SC7->C7_CODRDA,;//02
	                     BAU->BAU_NOME,;//03
	                     SC7->(C7_NUM+" "+C7_ITEM+" "+C7_SEQUEN),;//04                                                                                                                           
	                     SC7->C7_DATPRF,;//05
	                     SC7->C7_TOTAL,;//06
	                     SC7->C7_VALIR,;//07
	                     SC7->C7_VALINS,;//08
	                     SC7->C7_VALISS,;//09
	                     0,;//10
	                     0,;//11
	                     0,;//12
	                     0,;//13
	                     SC7->C7_TOTAL,;//14
	                     SC7->(C7_FORNECE+" "+C7_LOJA),;//15
	                     Posicione("SA2",1,xFilial("SA2")+BAU->(BAU_CODSA2+BAU_LOJSA2),"A2_NOME"),;//16
	                     Posicione("SA2",1,xFilial("SA2")+BAU->(BAU_CODSA2+BAU_LOJSA2),"A2_NATUREZ"),;//17
	                     STR0081,; //"Financeiro"-18
	                     "",;//19
	                     "2",;//20
	                     SC7->(Recno()),;//21
	                     .f.,;//22
	                     SC7->(C7_NUM+C7_ITEM)})//23
			
			SC7->(DbSkip())
		endDo
	Endif
	
	
	// Folha.. 
	If RGB->(FieldPos("RGB_LOTPLS")) > 0
		RGB->(DbSetOrder(RetOrder( "RGB", "RGB_FILIAL+RGB_LOTPLS" )))                                                                                                                                    
		If RGB->(RGB->(DbSeek(xFilial('RGB')+BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)),.F.))
			nQtd++
			while !RGB->(Eof()) .and. RGB->(RGB_FILIAL+RGB_LOTPLS) = xFilial('RGB')+BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)
				
		     	BAU->(MsSeek(xFilial("BAU")+RGB->RGB_CODRDA))
		
		     	aadd(aDados,{"Folha",;//01 
		     				  	RGB->RGB_CODRDA,;//02
		                     BAU->BAU_NOME,;//03
		                     RGB->(RGB_MAT+" "+RGB_PD),;//04                                                                                                                           
		                     RGB->RGB_DATA,;//05
		                     RGB->RGB_VALOR,;//06
		                     0,;//07
		                     0,;//08
		                     0,;//09
		                     0,;//10
		                     0,;//11
		                     0,;//12
		                     0,;//13
		                     RGB->(RGB_VALOR),;//14
		                     RGB->(RGB_CODRDA),;//15
		                     Posicione("SA2",1,xFilial("SA2")+BAU->(BAU_CODSA2+BAU_LOJSA2),"A2_NOME"),;//16
		                     Posicione("SA2",1,xFilial("SA2")+BAU->(BAU_CODSA2+BAU_LOJSA2),"A2_NATUREZ"),;//17
		                     "Folha",; //"Financeiro"-18
		                     "",;//19
		                     "2",;//20
		                     RGB->(Recno()),;//21
		                     .f.,;//22
		                     RGB->(RGB_LOTPLS)})//23
		                     
		                     nQtd++
				
				RGB->(DbSkip())
			endDo
		Endif
	else
		SRC->(DbSetOrder(RetOrder( "SRC", "RC_FILIAL+RC_LOTPLS" )))                                                                                                                                    
		If SRC->(SRC->(DbSeek(xFilial('SRC')+(cFilSC7+Space(12-Len(cFilSC7))+BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)),.F.)))
			nQtd++
			while !SRC->(Eof()) .and. SRC->(RC_FILIAL+RC_LOTPLS) = cFilSC7+BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)
				
		     	BAU->(MsSeek(xFilial("BAU")+SRC->RC_CODRDA))
		
		     	aadd(aDados,{"Folha",;//01 
		     				 SRC->RC_CODRDA,;//02
		                     BAU->BAU_NOME,;//03
		                     SRC->(RC_MAT+" "+RC_PD),;//04                                                                                                                           
		                     SRC->RC_DATA,;//05
		                     SRC->RC_VALOR,;//06
		                     0,;//07
		                     0,;//08
		                     0,;//09
		                     0,;//10
		                     0,;//11
		                     0,;//12
		                     0,;//13
		                     SRC->(RC_VALOR),;//14
		                     SRC->(RC_CODRDA),;//15
		                     Posicione("SA2",1,xFilial("SA2")+BAU->(BAU_CODSA2+BAU_LOJSA2),"A2_NOME"),;//16
		                     Posicione("SA2",1,xFilial("SA2")+BAU->(BAU_CODSA2+BAU_LOJSA2),"A2_NATUREZ"),;//17
		                     "Folha",; //"Financeiro"-18
		                     "",;//19
		                     "2",;//20
		                     SRC->(Recno()),;//21
		                     .f.,;//22
		                     SRC->(RC_LOTPLS)})//23
		                     
		                     nQtd++
				
				SRC->(DbSkip())
			endDo
		Endif
	EndIf
	//??????????????????????????????????????????????????????????????????????????Ä¿
	//? Exibe dados do lote de pagamento...                                      ?
	//????????????????????????????????????????????????????????????????????????????
	If (nQtd > 1 .Or. lExisPed) .And. !lExNFPed
	
	    aDados := ASort(aDados,,, { |x,y| x[2] < y[2] })
	    
		//-------------------------------------------------------------------
		//  LGPD
		//-------------------------------------------------------------------
		objCENFUNLGP:useLogUser()

	    aRet := PLS470Mark(aDados)
	    nTotSel := Len(aRet)
	    If nTotSel > 0
		    If msgYesNo("Confirma a exclusao dos calculos selecionados?")
			    For nVez := 1 To Len(aRet)
			    	aEstorno := {}
			    	aPos := aRet[nVez] // {.F.,0}
					nPos := aPos[2]
					If aPos[1] .AND. nPos > 0
						If aDados[nPos, 1] <> "Pedido"	         	
							If aDados[nPos, 6] <> aDados[nPos, 14] .and. !aDados[nPos, 22]
								lConfirm := .T.
							endif	
							If aDados[nPos, 1] == "Titulo" .AND. aDados[nPos, 6] <> aDados[nPos, 14] .and. !lConfirm
								cChaveReg := aDados[nPos, 4]
								aAdd(aCriticas, {SUBSTR(cChaveReg,1,3),SUBSTR(cChaveReg,5,9),SUBSTR(cChaveReg,15,2),SUBSTR(cChaveReg,18,3),"Titulo - "+STR0136})//"O titulo selecionado nãopoder? ser exclu?do pois j? sofreu baixa."
							elseIf aDados[nPos, 19] == "S"
								aAdd(aCriticas, {SUBSTR(cChaveReg,1,3),SUBSTR(cChaveReg,5,9),SUBSTR(cChaveReg,15,2),SUBSTR(cChaveReg,18,3),"Titulo - "+STR0137})//"O titulo selecionado nãopoder? ser exclu?do pois j? foi contabilizado."
							elseIf 	BAF->(FieldPos("BAF_SEQIMP")) > 0 .and. ! Empty(BAF->BAF_SEQIMP) .and. BRJ->(MsSeek(xFilial("BRJ")+BAF->BAF_SEQIMP)) .and. BRJ->( FieldPos("BRJ_PRESE2") ) > 0 .and.;
									BRJ->( FieldPos("BRJ_NUMSE2") ) > 0 .and. BRJ->( FieldPos("BRJ_PARSE2") ) > 0 .and. BRJ->( FieldPos("BRJ_TIPSE2") ) > 0 .and. BRJ->(BRJ_PRESE2)+" "+Alltrim(BRJ->BRJ_NUMSE2)+BRJ->BRJ_PARSE2+"  "+ BRJ->BRJ_TIPSE2== aDados[nPos, 4] //verifica se ? titulo de contesta??o
								
								If !Empty(BRJ->BRJ_NIV550) .And. BRJ->BRJ_NIV550 > "1"
									If !Empty(BRJ->BRJ_NUMTIT)
										aAdd(aCriticas, {BRJ->BRJ_PREFIX,BRJ->BRJ_NUMTIT,BRJ->BRJ_PARCEL,BRJ->BRJ_TIPTIT,"Titulo - "+STR0171})//Titulo com processamento no AJIUS.
									Else
										aAdd(aCriticas, {BRJ->BRJ_PRESE2,BRJ->BRJ_NUMSE2,BRJ->BRJ_PARSE2,BRJ->BRJ_TIPSE2,"Titulo - "+STR0171})//Titulo com processamento no AJIUS.
									EndIf
								EndIf
								
								SE1->(DbSetOrder(1))
								If SE1->(MsSeek(xFilial("SE1")+BRJ->BRJ_PREFIX+Alltrim(BRJ->BRJ_NUMTIT)+BRJ->(BRJ_PARCEL+BRJ_TIPTIT))) .and. SE1->E1_SITUACA <> '0'
									aadd(aCriticas, {SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,"Titulo - "+STR0143})  //"Titulo transferido para banco."
								Endif
										
								If BRJ->( FieldPos("BRJ_PRENDC") ) > 0 .And. BRJ->( FieldPos("BRJ_NUMNDC") ) > 0 .And. BRJ->( FieldPos("BRJ_PARNDC") ) > 0 .And. BRJ->( FieldPos("BRJ_TIPNDC") ) > 0 .And. SE1->(MsSeek(xFilial("SE1")+BRJ->BRJ_PREFIX+Alltrim(BRJ->BRJ_NUMTIT)+BRJ->(BRJ_PARCEL+BRJ_TIPTIT))) .And. SE1->E1_SITUACA <> '0'
									aadd(aCriticas, {SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,"Titulo - "+STR0143})  //"Titulo transferido para banco."
								Endif
							elseIf aDados[nPos, 1] == "Titulo" .AND. aDados[nPos, 6] <> aDados[nPos, 14] .and. baixafutura(aDados[nPos, 2], aBaixaFut)
								aCriticas := aclone(aBaixaFut)
							else
								if lConfirm	
									if len(aMatAux)>0
										aMatAux := asort(aMatAux,,, { |x,y| x[1]+x[2] < y[1]+y[2] })
										nPos2 	 := ascan(aMatAux,{|x| x[1] == aDados[nPos,2]})
										
										if nPos2>0
											
											nPos4 := ascan(aDadosNDF,{|x| x[1] == aDados[nPos,2]})
											
											for nI := nPos2 to len(aMatAux)
												if aMatAux[nI,1] == aDados[nPos,2]
													if allTrim(aMatAux[nI,2]) <> 'NDF' 
														aadd(aEstorno,{aMatAux[nI,2],aMatAux[nI,3],'',0,'',0})
													else
														nPos3 := len(aEstorno)
														aEstorno[nPos3,3]	:= aMatAux[nI,2]
														aEstorno[nPos3,4]	:= aMatAux[nI,3]
														aEstorno[nPos3,5]	:= {aMatAux[nI,4]}
														aEstorno[nPos3,6]	:= aMatAux[nI,5]
													endIf
												else
													exit		
												endIf
											next nI
										endif	
									endIf                              
									
									for nI:=1 to len(aEstorno)		
										MaIntBxCP(2,{aEstorno[nI,2]},,{aEstorno[nI,4]},,{.f.,.f.,.f.,.f.,.f.,.f.},,{{aEstorno[nI,4]}},,aEstorno[nI,6])
									next
								endIf	
								
								// Ponto de entrada para avaliar a continuidade do processo 			                  	
								if ExistBlock("PLS470OK")
									lRet := ExecBLock("PLS470OK",.F.,.F.,{"ET",dDataBase})
									if !lRet
										return
									endIf
			                    endIf   
								
								msAguarde( {|| iif(nPos4>0,cRet:=PLSA470E01(aDadosNDF,nPos4,dDataPagto,.f.),nil),cRet:=PLSA470E01(aDados,nPos,dDataPagto,.t.,iif(nPos4>0,aDadosNDF[nPos4,6],0)),  }, STR0094 + " - "+StrZero(nVez,6)+" de "+ StrZero(nTotSel,6),"", .T.) //"Excluindo calculo ..."
								cChaveReg := IIf ( nPos4>0 , aDadosNDF[nPos,4] , aDados[nPos,4] )
								If cRet == STR0103
									If (nPos4>0 .AND. aDadosNDF[nPos,1] == "Titulo") .OR. (nPos4<=0 .AND. aDados[nPos,1] == "Titulo") 
										aadd(aTitulo, 	{SUBSTR(cChaveReg,1,3),SUBSTR(cChaveReg,5,9),SUBSTR(cChaveReg,15,2),SUBSTR(cChaveReg,18,3)	,"Titulo - "+cRet})
									Else
										aadd(aTitulo, 	{SUBSTR(cChaveReg,1,6),SUBSTR(cChaveReg,8,3),""						,""						,"Folha  - "+cRet})
									EndIf
								Else
									If (nPos4>0 .AND. aDadosNDF[nPos,1] == "Titulo") .OR. (nPos4<=0 .AND. aDados[nPos,1] == "Titulo") 
										aadd(aCriticas, {SUBSTR(cChaveReg,1,3),SUBSTR(cChaveReg,5,9),SUBSTR(cChaveReg,15,2),SUBSTR(cChaveReg,18,3)	,"Titulo - "+cRet})
									Else
										aadd(aCriticas, {SUBSTR(cChaveReg,1,6),SUBSTR(cChaveReg,8,3),""						,""						,"Folha  - "+cRet})
									EndIf
								EndIf
							EndIf
						Else
							// SOMENTE PEDIDOS
							msAguarde( {|| cRet:=PLSA470E01(aDados,nPos,dDataPagto,.T.,0)},STR0094 + " - "+StrZero(nVez,6)+" de "+ StrZero(nTotSel,6),"",.T.) //"Excluindo calculo ..."
							cChaveReg := aDados[nPos,4]
							If cRet == STR0103
								aadd(aTitulo, 	{SUBSTR(cChaveReg,1,6),SUBSTR(cChaveReg,8,4),SUBSTR(cChaveReg,13,4)	,""						,"Pedido - "+cRet})
							Else
								aadd(aCriticas, {SUBSTR(cChaveReg,1,6),SUBSTR(cChaveReg,8,4),SUBSTR(cChaveReg,13,4)	,""						,"Pedido - "+cRet})
							EndIf
						Endif
					Endif
				Next nVez
				
				If Len(aCriticas) > 0
					PLSCRIGEN(aCriticas,aCabec, STR0144,NIL,NIL,NIL,NIL, NIL,NIL,"G",220) //"Verificacao de integridade."
				EndIf
				If Len(aTitulo) > 0
					PLSCRIGEN(aTitulo,aCabec, "Resumo de Processados",NIL,NIL,NIL,NIL, NIL,NIL,"G",220) //"Verificacao de integridade."
				EndIf
			EndIf
		Else
			msgAlert(STR0159) //"Nenhum titulo ou Pedido de Compra foi selecionado, portanto nãoser? exclu?do!"
		Endif                           
	elseIf nQtd == 1
		If !lExNFPed
			msgStop(STR0096) //"Existe somente um pagamento feito. Utilize a rotina de exclusao"
		Else
			MsgStop(STR0170)//"O pedido de compra vinculado se encontra encerrado. Nao sera possivel realizar a exclusao."
		EndIf	
	else
		If !lExNFPed
			Help("",1,"RECNO")//Nao existe registro para o arquivo em pauta
		Else
			MsgStop(STR0170)//"O pedido de compra vinculado se encontra encerrado. Nao sera possivel realizar a exclusao."
		EndIf
	endif

else
	Help(nil, nil , STR0179, nil, STR0180, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0181} ) //aten??o / "Existe Recurso de Glosa associado ao lote de pagamento. O lote nãoser? exclu?do." / "Caso queira excluir o lote, ser? necess?rio excluir o Recurso de Glosa primeiro."
endif

return
/*/
??????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
??? Funcao   ? PLSA470E01 ? Autor ? Tulio Cesar       ? Data ? 09.02.2005 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Excluir calculo selecionado                                ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
Function PLSA470E01(aDados,nPos,dDataPagto,lNdf,nVlrNDF)
LOCAL nPosVet       := 0                                            
LOCAL cCodRDa       := ''   		
LOCAL cCodInt		:= ''
LOCAL cAnoLot		:= ''
LOCAL cMesLot		:= ''
LOCAL cLote			:= ''
LOCAL cIdeRot		:= ''
LOCAL cCodCha		:= ''
LOCAL cTipo			:= ''
Local lExclDoc 	   	:= .T.
Local lFieldNDC   	:= BRJ->( FieldPos("BRJ_PRENDC") ) > 0 .And. BRJ->( FieldPos("BRJ_NUMNDC") ) > 0 .And. ;
				   	   BRJ->( FieldPos("BRJ_PARNDC") ) > 0 .And. BRJ->( FieldPos("BRJ_TIPNDC") ) > 0
Local lPedido      	:= aDados[nPos,1] == "Pedido"
Local lFolha       	:= aDados[nPos,1] == "Folha"
Local lAtuBAF      	:= .F.
local lFoundBAU		:= .f.
Local xPrefixo 	   	:= ''
Local xNumero	   	:= ''
Local xParcela 	   	:= ''
Local nVlrBruExc	:= 0
Local nVlrIrExc		:= 0
Local lPL470EXC		:= ExistBlock("PL470EXC")
	    
default dDataPagto := cTod("")
default lNdf	   := .f.
default nVlrNDF	   := 0

//Grava historico de processamento                                         
If lPedido

	SC7->(DbGoTo(aDados[nPos,21]))
	cCodRDA := SC7->C7_CODRDA

ElseIf lFolha

	If RGB->(FieldPos("RGB_LOTPLS")) > 0
		RGB->(DbGoTo(aDados[nPos,21]))
		cCodRDA := RGB->RGB_CODRDA
	else
		SRC->(DbGoTo(aDados[nPos,21]))
		cCodRDA := SRC->RC_CODRDA
	EndIf

Else
	SE2->(DbGoTo(aDados[nPos,21]))
	cCodRDA := SE2->E2_CODRDA
Endif

cIdeRot := "PLSA470 "
cCodCha := BAF->BAF_CODOPE + BAF->BAF_ANOLOT + BAF->BAF_MESLOT + BAF->BAF_NUMLOT + dtos(date()) + time()
cHistor := STR0097 + cCodRda + STR0057 + dtoc(date()) + STR0098 + time() //"Exclusao Individual Pagto - RDA: "###"   Data: "###"   Hora: "

PLSHISGRV(cIdeRot,cCodCha,"0001",cHistor)
cHistor := STR0031 + PLSRtCdUsr() + " " + USRRETNAME(PLSRtCdUsr()) //"   Usuario: "
PLSHISGRV(cIdeRot,cCodCha,"0002",cHistor)

Begin Transaction

cCodInt := BAF->BAF_CODOPE
cAnoLot := BAF->BAF_ANOLOT
cMesLot := BAF->BAF_MESLOT
cLote   := BAF->BAF_NUMLOT

//Verifica se o titulo eh de impostos                                      
//Caso de calculo de impostos atraves da folha com varios pagamentp ref.   
//um ano/mes base                                                          
BAU->(DbSetOrder(1))
lFoundBAU := BAU->(MsSeek(xFilial("BAU")+cCodRDA))

cTipo := GETMV("MV_PLTIPE2")
cTipo := Eval({|| &cTipo })

If ! lPedido .AND. ! lFolha

	If alltrim(SE2->E2_TIPO) == alltrim(cTipo) .or. (SE2->E2_TIPO == "NDF" .and. empty(SE2->E2_PARCELA))

	    //Excluir titulo gerado...                                                 
		MsProcTxt(STR0069) //"Excluindo contas a pagar (SE2) ..."

	    xPrefixo := SE2->E2_PREFIXO
	    xNumero	 := SE2->E2_NUM
	    xParcela := SE2->E2_PARCELA
	    xPlOpeLt := SE2->E2_PLOPELT
	    xPlLote  := SE2->E2_PLLOTE
	    xCodRDA  := SE2->E2_CODRDA
	    
	    If lExclDoc := PLCANCRE()[1]

		    MsProcTxt(STR0064) //"Excluindo debitos/creditos (BGQ) ..."
			     
		    If lFoundBAU .And. BAU->BAU_TIPPRE == GetNewPar("MV_PLSTPIN","OPE")
		
		        BGQ->(DbSetOrder(7))
		        If  BGQ->(msSeek(xFilial("BGQ")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO))) .And. BGQ->BGQ_LANAUT == '1' .And. Empty(BGQ->(BGQ_PREFIX+BGQ_NUMTIT+BGQ_PARCEL+BGQ_TIPTIT))
	  	            BGQ->(RecLock("BGQ",.F.))
		            BGQ->(DbDelete())
		            BGQ->(MsUnLock())           
		        Endif   

		    Endif
		    delBGQBBC()
		    
		    xRecSE2 := SE2->(Recno())

		    //exclui a ndf se tiver
		    cSql := " SELECT R_E_C_N_O_ RECSE2 FROM " + RetSqlName("SE2")
		    cSql += " WHERE E2_FILIAL  = '" + xFilial('SE2') + "' AND "
		    cSql += "       E2_PLOPELT = '" + xPlOpeLt + "' AND "
			cSql += "       E2_PLLOTE  = '" + xPlLote  + "' AND "
			cSql += "       E2_CODRDA  = '" + xCodRDA  + "' AND "
		    cSql += "       E2_PREFIXO = '" + xPrefixo + "' AND "
		    cSql += "       E2_NUM     = '" + xNumero  + "' AND "
		    cSql += "       D_E_L_E_T_ = ' ' "

			dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cSQL),"TrbNdf",.F.,.T.)		    		    	

		    While !TrbNdf->(Eof())   	
		    
			    SE2->(DbGoTo(TrbNdf->RECSE2))
		    
			    SE2->(Reclock("SE2",.F.))
		        SE2->(DbDelete())
		        SE2->(MsUnlock())		              

		    TrbNdf->(DbSkip())
		    Enddo

		    TrbNdf->(DbCloseArea())	    
		    
		    If xRecSE2 > 0
		    	SE2->(DbGoTo(xRecSE2))
		    Endif

		    If BAU->BAU_TIPPRE == GetNewPar("MV_PLSTPIN","OPE")
		    
		        MsProcTxt(STR0067) //"Excluindo lancamentos de contestacao (SE1/BRJ) ..."
	
		        SIX->(DbSetOrder(1))
		        If  SIX->(msSeek("BRJ1")) .And. BAF->(FieldPos("BAF_SEQIMP")) > 0

		            BRJ->(DbSetOrder(1))
		            If  BRJ->(msSeek(xFilial("BRJ")+BAF->BAF_SEQIMP))

				        Do While ! BRJ->(Eof()) .And. BRJ->(BRJ_FILIAL+BRJ_CODIGO) == xFilial("BRJ")+BAF->BAF_SEQIMP
					
							If BRJ->BRJ_REGPRI == "1" .And. BRJ->BRJ_STATUS == "2" //Registro Principal e Status "Faturado"
				
								SE1->(DbSetOrder(1))
								If SE1->(msSeek(xFilial("SE1")+BRJ->(BRJ_PREFIX+BRJ_NUMTIT+BRJ_PARCEL+BRJ_TIPTIT)))

									SE1->(RecLock("SE1",.F.))
									SE1->(DbDelete())
									SE1->(MsUnLock())

								Endif

								If lFieldNDC .And. SE1->(msSeek(xFilial("SE1")+BRJ->(BRJ_PRENDC+BRJ_NUMNDC+BRJ_PARNDC+BRJ_TIPNDC)))

									SE1->(RecLock("SE1",.F.))
									SE1->(DbDelete())
									SE1->(MsUnLock())

								Endif

								BRJ->(RecLock("BRJ",.F.))
								BRJ->BRJ_STATUS := "1"
								BRJ->BRJ_PREFIX := ""
								BRJ->BRJ_NUMTIT := ""
								BRJ->BRJ_PARCEL := ""
								BRJ->BRJ_TIPTIT := ""

								If 	BRJ->( FieldPos("BRJ_PRESE2") ) > 0 .And. BRJ->( FieldPos("BRJ_NUMSE2") ) > 0 .And. ;
									BRJ->( FieldPos("BRJ_PARSE2") ) > 0 .And. 	BRJ->( FieldPos("BRJ_TIPSE2") ) > 0

									BRJ->BRJ_PRESE2 := ""
									BRJ->BRJ_NUMSE2 := ""
									BRJ->BRJ_PARSE2 := ""
									BRJ->BRJ_TIPSE2 := ""

								Endif

								BRJ->(MsUnLock())

							EndIf
							
						BRJ->(DbSkip())
				        EndDo

		            Endif

		        Endif

		    Endif 

		    //Executa funcao que atualiza dados nos movimentos limpando o lote...      
		    MsProcTxt(STR0071) //"Atualizando movimentacao ..."
		    
		    PLSATUVINP(BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT),BAF->BAF_CODOPE,BAF->BAF_CODOPE,nil,nil,nil,nil,nil,;
		    			nil,nil,nil,cCodRDA,BAF->BAF_ANOLOT,BAF->BAF_MESLOT,"2","",;
		    			nil,nil,nil,nil,nil,nil,nil,dDataPagto)       
		EndIf

	Else

	    //Atencao: falta tratar quando os impostos sao gerados junto do titulo     ?
	    //         principal - AGS ??? 06/09/2005                                  ?
	    cCodRDA := SE2->E2_CODRDA
	    BAU->(DbSetOrder(1))

	    MsProcTxt(STR0100) // "Excluindo impostos do contas a pagar (SE2) ..."
		     
	    For nPosVet := 1 to len(aDados)

			If aDados[nPosVet,2] == cCodRda
		
				SE2->(DbGoTo(aDados[nPosVet,21]))

				//Excluir titulo gerado...                                                 
				MsProcTxt(STR0069)
				
				If lExclDoc := PLCANCRE()[1]

					MsProcTxt(STR0064)

					If lFoundBAU .And. BAU->BAU_TIPPRE == GetNewPar("MV_PLSTPIN","OPE")
						
						BGQ->(DbSetOrder(7))
						If  BGQ->(msSeek(xFilial("BGQ")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO))) .And. BGQ->BGQ_LANAUT == '1' .And. Empty(BGQ->(BGQ_PREFIX+BGQ_NUMTIT+BGQ_PARCEL+BGQ_TIPTIT))
							BGQ->(RecLock("BGQ",.F.))
							BGQ->(DbDelete())
							BGQ->(MsUnLock())
						Endif

					Endif

					delBGQBBC()

					If  BAU->BAU_TIPPRE == GetNewPar("MV_PLSTPIN","OPE")

						MsProcTxt(STR0067)

						SIX->(DbSetOrder(1))
						If SIX->(msSeek("BRJ1")) .And. BAF->(FieldPos("BAF_SEQIMP")) > 0

							BRJ->(DbSetOrder(1))
							If  BRJ->(msSeek(xFilial("BRJ")+BAF->BAF_SEQIMP))
						
								Do While ! BRJ->(Eof()) .And. BRJ->(BRJ_FILIAL+BRJ_CODIGO) == xFilial("BRJ")+BAF->BAF_SEQIMP
						
									If BRJ->BRJ_REGPRI == "1" .And. BRJ->BRJ_STATUS == "2" //Registro Principal e Status "Faturado"
						
										SE1->(DbSetOrder(1))
										If  SE1->(msSeek(xFilial("SE1")+BRJ->(BRJ_PREFIX+BRJ_NUMTIT+BRJ_PARCEL+BRJ_TIPTIT)))
											SE1->(RecLock("SE1",.F.))
											SE1->(DbDelete())
											SE1->(MsUnLock())
										Endif
						
										If lFieldNDC .And. SE1->(msSeek(xFilial("SE1")+BRJ->(BRJ_PRENDC+BRJ_NUMNDC+BRJ_PARNDC+BRJ_TIPNDC)))
											SE1->(RecLock("SE1",.F.))
											SE1->(DbDelete())
											SE1->(MsUnLock())
										Endif
						
										BRJ->(RecLock("BRJ",.F.))
										BRJ->BRJ_STATUS := "1"
										BRJ->BRJ_PREFIX := ""
										BRJ->BRJ_NUMTIT := ""
										BRJ->BRJ_PARCEL := ""
										BRJ->BRJ_TIPTIT := ""
			
										If 	BRJ->( FieldPos("BRJ_PRESE2") ) > 0 .And. BRJ->( FieldPos("BRJ_NUMSE2") ) > 0 .And. ;
											BRJ->( FieldPos("BRJ_PARSE2") ) > 0 .And. 	BRJ->( FieldPos("BRJ_TIPSE2") ) > 0

											BRJ->BRJ_PRESE2 := ""
											BRJ->BRJ_NUMSE2 := ""
											BRJ->BRJ_PARSE2 := ""
											BRJ->BRJ_TIPSE2 := ""

										Endif

										BRJ->(MsUnLock())
									EndIf

									BRJ->(DbSkip())
								EndDo

							Endif

						Endif

					Endif

					//Executa funcao que atualiza dados nos movimentos limpando o lote...      
					MsProcTxt(STR0071)

					PLSATUVINP(BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT),BAF->BAF_CODOPE,BAF->BAF_CODOPE,nil,nil,nil,nil,nil,;
								nil,nil,nil,cCodRda,BAF->BAF_ANOLOT,BAF->BAF_MESLOT,"2","",;
								nil,nil,nil,nil,nil,nil,nil,dDataPagto)
				EndIf

			Endif

	    Next

	Endif

ElseIf lFolha

	//Excluir folha... 					                                     
	MsProcTxt("Excluindo Registro na Folha de Pagamento (RGB) ...") 
	
	lExclDoc:=.F.	    

    For nPosVet := 1 to len(aDados)

    	If  aDados[nPosVet,2] == cCodRda  .and. nPosVet == nPos 
    
			If RGB->(FieldPos("RGB_LOTPLS")) > 0
	
	    		RGB->(DbGoTo(aDados[nPosVet,21]))
	    		lExclDoc:=.T.
	
	    		RGB->(RecLock("RGB",.F.))
				RGB->(DbDelete())
				RGB->(MsUnLock())

			else
	    		
				SRC->(DbGoTo(aDados[nPosVet,21]))
	    		lExclDoc:=.T.
	
	    		SRC->(RecLock("SRC",.F.))
				SRC->(DbDelete())
				SRC->(MsUnLock())

    		endIf

    	Endif

	Next nPosVet
	    
	If lExclDoc 

	    BAU->(DbSetOrder(1))

	    MsProcTxt(STR0064) //"Excluindo debitos/creditos (BGQ) ..."
		     
	    If  BAU->(msSeek(xFilial("BAU")+cCodRDA)) .And. BAU->BAU_TIPPRE == GetNewPar("MV_PLSTPIN","OPE")
	        
			BGQ->(DbSetOrder(2))//BGQ_FILIAL, BGQ_CODIGO, BGQ_ANO, BGQ_MES, BGQ_CODOPE, BGQ_OPELOT, BGQ_NUMLOT //Z Olhar isso
	        
			If RGB->(FieldPos("RGB_LOTPLS")) > 0
		    
			    If BGQ->(msSeek(xFilial("BGQ")+BAU->BAU_CODIGO+Substr(RGB->RGB_LOTPLS,1,6)+PlsIntPad()+PlsIntPad()+RGB->RGB_LOTPLS)) .And. BGQ->BGQ_LANAUT == '1' .And. Empty(BGQ->(BGQ_PREFIX+BGQ_NUMTIT+BGQ_PARCEL+BGQ_TIPTIT)) 
		            BGQ->(RecLock("BGQ",.F.))
		            BGQ->(DbDelete())
		            BGQ->(MsUnLock())           
		        Endif

	        else

		        If BGQ->(msSeek(xFilial("BGQ")+BAU->BAU_CODIGO+Substr(SRC->RC_LOTPLS,1,6)+PlsIntPad()+PlsIntPad()+SRC->RC_LOTPLS)) .And. BGQ->BGQ_LANAUT == '1' .And. Empty(BGQ->(BGQ_PREFIX+BGQ_NUMTIT+BGQ_PARCEL+BGQ_TIPTIT)) 
		            BGQ->(RecLock("BGQ",.F.))
		            BGQ->(DbDelete())
		            BGQ->(MsUnLock())           
		        Endif   

	        EndIf

	    Endif
	    delBGQBBC()
	    //Executa funcao que atualiza dados nos movimentos limpando o lote...      
	    MsProcTxt(STR0071) //"Atualizando movimentacao ..."

	    PLSATUVINP(BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT),BAF->BAF_CODOPE,BAF->BAF_CODOPE,nil,nil,nil,nil,nil,;
	    			nil,nil,nil,cCodRDA,BAF->BAF_ANOLOT,BAF->BAF_MESLOT,"2","",;
	    			nil,nil,nil,nil,nil,nil,nil,dDataPagto)       
	EndIf

Else 

	//Excluir Pedido de Compra gerado...                                       
	MsProcTxt(STR0160)//"Excluindo Pedido de Compra (SC7) ..." 
	 	
	aCab	:= {}
	aItem	:= {}
	
	AADD(aCab ,{"C7_NUM",SC7->C7_NUM ,Nil})
	AADD(aItem,{{"C7_NUM",SC7->C7_NUM ,Nil}})

	lMsErroAuto := .f.
	lMsHelpAuto := .f. 
	
	If !SC7->(Deleted())	

		MSExecAuto({|v,x,y,z| MATA120(v,x,y,z)},1,aCab,aItem,5)
	
		IF lMsErroAuto
			MostraErro()
			lExclDoc:= .F.
		EndIF

	Endif
	    
	If lExclDoc 

	    BAU->(DbSetOrder(1))
	    MsProcTxt(STR0064) //"Excluindo debitos/creditos (BGQ) ..."
		     
	    If BAU->(msSeek(xFilial("BAU")+cCodRDA)) .And. BAU->BAU_TIPPRE == GetNewPar("MV_PLSTPIN","OPE")
	
	        BGQ->(DbSetOrder(2))//BGQ_FILIAL, BGQ_CODIGO, BGQ_ANO, BGQ_MES, BGQ_CODOPE, BGQ_OPELOT, BGQ_NUMLOT
	        If BGQ->(msSeek(xFilial("BGQ")+BAU->BAU_CODIGO+Substr(SC7->C7_LOTPLS,1,6)+PlsIntPad()+PlsIntPad()+SC7->C7_LOTPLS)) .And. BGQ->BGQ_LANAUT == '1' .And. Empty(BGQ->(BGQ_PREFIX+BGQ_NUMTIT+BGQ_PARCEL+BGQ_TIPTIT)) 
	            BGQ->(RecLock("BGQ",.F.))
	            BGQ->(DbDelete())
	            BGQ->(MsUnLock())           
	        Endif   

	    Endif

	    delBGQBBC()
	    //Executa funcao que atualiza dados nos movimentos limpando o lote...      
	    MsProcTxt(STR0071) //"Atualizando movimentacao ..."

	    PLSATUVINP(BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT),BAF->BAF_CODOPE,BAF->BAF_CODOPE,nil,nil,nil,nil,nil,;
	    			nil,nil,nil,cCodRDA,BAF->BAF_ANOLOT,BAF->BAF_MESLOT,"2","",;
	    			nil,nil,nil,nil,nil,nil,nil,dDataPagto)       
	EndIf

Endif	 

If lExclDoc

	//Exclui memoria de calculo                                                
	PLSHISDEL("PLSMPAG ",cCodInt+cAnoLot+cMesLot+cLote+cCodRda)

	//exclusao do arquivo com a composicao do pagamento...                     
	MsProcTxt(STR0101) //"Excluindo composicao de pagamento (BMR) ..."

	BMR->(DbSetOrder(3))
	If BMR->(MsSeek(xFilial("BMR")+BAF->(BAF_CODOPE+cCodRda+BAF_CODOPE+BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)))

	   	While ! BMR->(Eof()) .And. BMR->(BMR_FILIAL+BMR_OPERDA+BMR_CODRDA+BMR_OPELOT+BMR_ANOLOT+BMR_MESLOT+BMR_NUMLOT) == ;
	         					  xFilial("BMR")+BAF->(BAF_CODOPE+cCodRda+BAF_CODOPE+BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)
	         
	         If BMR->BMR_CODLAN == '199'
	         	nVlrIrExc += BMR->BMR_VLRPAG
	         EndIf
	         
	         BMR->(RecLock("BMR",.F.))
	         BMR->(DbDelete())
	         BMR->(MsUnLock())

		BMR->(DbSkip())
	   	Enddo

	EndIf
	
	//Exclusao do arquivo B15 - BASES INSS PAGAMENTOS RDA'S - SEFIP            
	MsProcTxt(STR0122)

	B15->(DbSetOrder(1))
	If B15->(MsSeek(xFilial("B15")+BAF->(BAF_CODOPE+BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)+cCodRDA))

	   	Do While ! B15->(Eof()) .And. B15->(B15_FILIAL+B15_OPERDA+B15_ANOLOT+B15_MESLOT+B15_NUMLOT+B15_CODRDA) == ;
	                                 xFilial("B15")+BAF->(BAF_CODOPE+BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)+cCodRDA
	
	      B15->(RecLock("B15",.F.))
	      B15->(DbDelete())
	      B15->(MsUnLock())

	    B15->(DbSkip())
	   	Enddo

	EndIf

	//exclusao do arquivo com a composicao do pagamento...                     
	MsProcTxt(STR0102) //"Excluindo composicao de pagamento (BMS) ..."

	BMS->(DbSetOrder(1))
	If BMS->(MsSeek(xFilial("BMS")+BAF->(BAF_CODOPE+cCodRda+BAF_CODOPE+BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)))
	   
	   	While ! BMS->(Eof()) .And. 	BMS->(BMS_FILIAL+BMS_OPERDA+BMS_CODRDA+BMS_OPELOT+BMS_ANOLOT+BMS_MESLOT+BMS_NUMLOT) == ;
	         						xFilial("BMS")+BAF->(BAF_CODOPE+cCodRda+BAF_CODOPE+BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)
	         
	         If BMS->BMS_DEBCRE == '2'
	         	nVlrBruExc += BMS->BMS_VLRPAG
	         EndIf
	         
	         BMS->(RecLock("BMS",.F.))
	         BMS->(DbDelete())
	         BMS->(MsUnLock())

	    BMS->(DbSkip())
	   	Enddo

	EndIf

	//Ajusta valor do lote de pagamento                                        
	If BAF->BAF_VLRBRU > 0 

		IF lPedido
			lAtuBAF := .T.
		Else
			lAtuBAF	:= allTrim(SE2->E2_TIPO) <> 'NDF'
		Endif

		If lAtuBAF

		    BAF->(RecLock("BAF",.F.))					//E2_VALOR			//impostos
			   	BAF->BAF_VLRBRU := BAF->BAF_VLRBRU - (aDados[nPos,6] + aDados[nPos,7] + aDados[nPos,8] + aDados[nPos,9] + aDados[nPos,11] + aDados[nPos,12] + aDados[nPos,13])
		    	BAF->BAF_RDAPAG := BAF->BAF_RDAPAG - 1
	   			BAF->BAF_VLRIR  := BAF->BAF_VLRIR - aDados[nPos,7]  
				BAF->BAF_VLRLIQ := IIf( BAF->(BAF_VLRBRU-BAF_VLRIR)<0, 0, BAF->(BAF_VLRBRU-BAF_VLRIR) )		//iif(nValLiqAcu>=0,nValLiqAcu,0)
		    BAF->(MsUnLock())

		 //Exclusao a partir da NDF
		 Else

		 	If AllTrim(SE2->E2_TIPO) == 'NDF' .And. (nVlrBruExc > 0 .Or. nVlrIrExc > 0)
		 		BAF->(RecLock("BAF",.F.))
		 		BAF->BAF_VLRBRU := BAF->BAF_VLRBRU - nVlrBruExc
		 		BAF->BAF_RDAPAG := BAF->BAF_RDAPAG - 1
		 		BAF->BAF_VLRIR  := BAF->BAF_VLRIR - nVlrIrExc
		 		BAF->BAF_VLRLIQ := IIf( BAF->(BAF_VLRBRU-BAF_VLRIR)<0, 0, BAF->(BAF_VLRBRU-BAF_VLRIR) )
		 		BAF->(MsUnLock())
		 	EndIf

	    Endif

	Endif
    
	//BOPS 113091 - Permite excluir os lancamentos de debito/credito gerados   
    //              pelo ponto de entrada PLSPAG01.                            
	If lPL470EXC
		ExecBlock("PL470EXC",.F.,.F.,{cCodRda,cAnoLot,cMesLot})
	Endif

EndIf

End Transaction

If lExclDoc
	
	if lNdf
		cHistor := STR0103 // "Exclusao concluida com sucesso"
	endIf	

Else 
	
	If lPedido
		cHistor := STR0161 //"   Pedido de Compra nãopode ser exclu?do!"
	Else
		cHistor := STR0135 //"   titulo nãopode ser exclu?do!"
	Endif

	PLSHISGRV(cIdeRot,cCodCha,"0003",cHistor)

EndIf

Return(cHistor)

/*/
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
???Programa  ? PLSA470IMP ? Autor ? Angelo Sperandio  ? Data ? 27.08.2005 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Calcular impostos quando existe mais de um pagamento no mes???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
Function PLSA470IMP()
LOCAL   aCampos := {}         
LOCAL   aAuxFld := {}
LOCAL   cCampos := GetNewPar("MV_PLSFBAU","BAU_CODIGO,BAU_NOME,BAU_CONREG,BAU_TIPPRE")
LOCAL   nInd

PRIVATE cTitulo  := STR0124
PRIVATE oDlg
PRIVATE oBrowse                              
PRIVATE lCheck   := .T.
PRIVATE oCheck
PRIVATE aTela
PRIVATE cAno		:= ""
PRIVATE cMes        := ""
PRIVATE dVencto     := cTod("")
PRIVATE cFiltro     := ""
PRIVATE dDatMvIni   := cTod("")
PRIVATE dDatMvFin   := cTod("")
PRIVATE dDataPagto  := cTod("")
PRIVATE cLocDigIn   := ""
PRIVATE cLocDigFi   := ""
PRIVATE cCodPegIn   := ""
PRIVATE cCodPegFi   := ""
PRIVATE cNumMovIn   := ""
PRIVATE cNumMovFi   := ""
PRIVATE cCodOpe     := PLSINTPAD()
PRIVATE cCdEmpDeS   := ""
PRIVATE cCdEmpAteS  := ""
PRIVATE cExcessao   := ""
PRIVATE lGerPagBlo  := .F.
PRIVATE cLoteImp    := ""
PRIVATE lCalcImp    := .F.
PRIVATE cCopCre     := ""
PRIVATE cRdaDe      := ""
PRIVATE cRdaAte     := ""
PRIVATE cGrpPag     := ""
PRIVATE cInd        := CriaTrab(Nil,.F.)
PRIVATE nIndEsp     := 0
PRIVATE cHisTit     := ""
PRIVATE cPerg    	:= "PLA471"
PRIVATE cMarkBr		:= ""
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Busca parametros...                                                      ?
//????????????????????????????????????????????????????????????????????????????
If ! A471Perg()
   Return
Endif   
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Busca campos que serao exibidos no browse...                             ?
//????????????????????????????????????????????????????????????????????????????
STORE FIELDS "BAU" TO aAuxFld FOR AllTrim(SX3->X3_CAMPO) $ cCampos

SX3->(DbSetOrder(2))
If SX3->(MsSeek("BAU_OK"))
   aadd(aCampos,{SX3->X3_CAMPO,"  "})
Else
   Help("",1,"PLSA470OK")
Endif   

For nInd := 1 To Len(aAuxFld)

    If SX3->(MsSeek(aAuxFld[nInd]))
       aadd(aCampos,{SX3->X3_CAMPO,X3TITULO()})
    Endif   
Next
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Acessa parametros da opcao...                                            ?
//????????????????????????????????????????????????????????????????????????????
Pergunte(cPerg,.F.)

cAno       := mv_par01
cMes       := mv_par02
cCodOpe    := mv_par14
cFiltro    := AllTrim(mv_par04)
cCopCre    := fMntPAR24(mv_par24)
cRdaDe     := mv_par25
cRdaAte    := mv_par26
cGrpPag    := AllTrim(mv_par27)
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Executa um filtro no arquivo de credenciados...                          ?
//????????????????????????????????????????????????????????????????????????????
BAU->( DbSetOrder(2) )
BAU->( MsSeek(xFilial("BAU")) )
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Monta Dialog...                                                          ?
//????????????????????????????????????????????????????????????????????????????
DEFINE MSDIALOG oDlg TITLE cTitulo FROM 008.2,010.3 TO 034.4,100.3 OF GetWndDefault()
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Monta Botoes de opcoes...                                                ?
//????????????????????????????????????????????????????????????????????????????
TButton():New(005,008, STR0002          , , { || BAU->(AxPesqui()) , oBrowse:oBrowse:Refresh() } , 052, 010 ,,,,.T.) //"Pesquisar"

TGroup():New(020,004,170,100,STR0011,, , ,.T.) //"Opcoes"

TButton():New(031,008, STR0125    , , { || MsAguarde ( { || IF(A471TitMar(),oDlg:End(),nil) } ) } , 085, 010 ,,,,.T.) 
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Monta Botoes no final do dialogo...                                      ?
//????????????????????????????????????????????????????????????????????????????
SButton():New(180 , 322 , 01 , { || oDlg:End() }, oDlg, .T. )
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Monta CheckBox. Marcar desmarcar todos...                                ?
//????????????????????????????????????????????????????????????????????????????
lCheck := .T.
oCheck := IW_CheckBox(005,105,STR0015,"lCheck") //"Marca/Desmarca Todos"
oCheck:bChange := {|| MsAguarde( {|| A470Mark() } ) }
A470Mark(.F.)
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Monta MarkBrowse...                                                      ?
//????????????????????????????????????????????????????????????????????????????
oBrowse := IW_Browse(018,105,174,350,"BAU","BAU_OK",nil,aCampos)

oBrowse:oBrowse:bAllMark := {|| MsAguarde( {|| A470Mark() } ) }
//-------------------------------------------------------------------
//  LGPD
//-------------------------------------------------------------------
	objCENFUNLGP:useLogUser()
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Ativa o Dialogo...                                                       ?
//????????????????????????????????????????????????????????????????????????????
ACTIVATE DIALOG oDlg ON INIT Eval({|| A470IND(cFiltro,.F.,,cCopCre,cRdaDe,cRdaAte,cGrpPag), MsAguarde( {|| cMarkBr := ThisMark() } ), BAU->(DbGoTop()), oBrowse:oBrowse:Refresh() })
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Fim da Rotina Principal                                                  ?
//????????????????????????????????????????????????????????????????????????????
Return

/*/
??????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
??? Funcao   ? A471PERG ? Autor ? Angelo Sperandio    ? Data ? 27.08.2005 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Acessa pergunta no SX1 para a opcao...                     ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/

Static Function A471Perg()

LOCAL aOldArea := GetArea()
LOCAL lRet

lRet := Pergunte("PLA471",.T.)

If lRet
   cAno       := mv_par01
   cMes       := mv_par02
   If ! Empty(aOldArea[1])
      RestArea(aOldArea)
   Endif   
   If cFiltro <> AllTrim(mv_par04)
      cFiltro := AllTrim(mv_par04)
      MsAguarde({|| A470IND(cFiltro,.T.,.T.)})
   Endif   
Endif   

Return(lRet)

/*/
??????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
??? Funcao   ?A471TitMAR? Autor ? Angelo Sperandio    ? Data ? 27.08.2005 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Calcular impostos para as RDA's marcadas                   ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/

Static Function A471TitMar()
Local nH          	:= ""
Local cNumLote    	:= ""
Local aOldArea    	:= {}
Local nIndBAU     	:= 0
Local nRecBAU     	:= 0
Local aRetorno    	:= {}
Local nQtdOK      	:= 0
Local nQtdNO      	:= 0
Local aCrit       	:= {}
Local nAux        	:= 0
Local cMVPLSRDAG  	:= GetNewPar("MV_PLSRDAG","999999")
Local lNewCal		:= GetNewPar("MV_PLCALPG", "1") == "2"
Local cAno        	:= ""
Local cMes        	:=""
Local cCodOpe     	:= PLSINTPAD()
Local cFiltro     	:= ""
Local dVencReal   	:= ctod("")
Local cTipoTit		:= ''
Local nHNumPag		:= 0
Local cChavePri     := "PLSA470.SMF"
Local cChaveLot     := ""
Local cPLTIPE2		:= GetNewPar("MV_PLTIPE2","")
Local cPLPREE2 		:= GetNewPar("MV_PLPREE2","")
PRIVATE aVerbas   	:= {}
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Solicita parametros                                                      ?
//????????????????????????????????????????????????????????????????????????????
Pergunte("PLA471",.F.)
cAno       := mv_par01
cMes       := mv_par02
cCodOpe    := mv_par03
cFiltro    := AllTrim(mv_par04)
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Define variaveis...                                                      ?
//????????????????????????????????????????????????????????????????????????????
aOldArea := GetArea()
nIndBAU  := BAU->(IndexOrd())
nRecBAU  := BAU->(Recno())
nQtdOK   := 0
nQtdNO   := 0
aCrit    := {}
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Pede a confirmacao do usuario...                                         ?
//????????????????????????????????????????????????????????????????????????????
If ! MsgYesNo(STR0126)
   Return(.F.)
Endif   
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Ajusta indices das tabelas                                               ?
//????????????????????????????????????????????????????????????????????????????
BAF->(dbSetOrder(1))

//??????????????????????????????????????????????????????????????????????????Ä¿
//? Identifica numero do lote                                                ?
//????????????????????????????????????????????????????????????????????????????
cNumLote := PLSA625Cd("BAF_NUMLOT","BAF",1,"BAF->(BAF_CODOPE+BAF_ANOLOT+BAF_MESLOT)",cCodOpe+cAno+cMes)
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Abre novo semaforo para numeracao do lote                                ?
//????????????????????????????????????????????????????????????????????????????
cChaveLot := "PLSA470"+AllTrim(cNumLote)+".SMF"
nHNumPag := PLSAbreSem(cChaveLot)
While ( BAF->(DbSeek(xFilial("BAF")+cCodOpe+cAno+cMes+cNumLote,.F.)) .or. nHNumPag == 0 ) .and. nTenta < 300

	If nHNumPag > 0 //Se abri nessa chamada, fecho o sem?foro, se n?o, a chamada que abriu que cuida dele
		PLSFechaSem(nHNumPag,cChaveLot)
	EndIf
	
	cNumLote := Soma1(cNumLote)
	cChaveLot	:= "PLSA470"+AllTrim(cNumLote)+".SMF" //Atualizo o sem?foro com o novo cNumLote pra não ficar testando sempre o mesmo, 
															//se gerassem 3 "juntos" s? ia proteger o primeiro sem isso
	/// Abre controle de sem?foros da numera??o do lote
	nHNumPag := PLSAbreSem(cChaveLot)

	nTenta ++ 
EndDo

// Se nãoconseguiu um numero disponivel, registra a cr?tica
If (BAF->(Found()) .OR. nHNumPag == 0) .and. nTenta >= 300
	aCrit := {"000000","LOTE INV?LIDO","","C?digo de lote nesta operadora+ano+m?s j? existe"}
    PLSFechaSem(nHNumPag,cChaveLot)
    nHNumPag := 0
EndIf

//??????????????????????????????????????????????????????????????????????????Ä¿
//? Navega por todos os fornedores da area aberta e busca saldo dos marcados ?
//????????????????????????????????????????????????????????????????????????????
BAU->(DbSetOrder(1))
BAU->(DbClearFilter())
BAU->(RetIndex("BAU"))
If  BAU->(MsSeek(xFilial("BAU"))) .and. Len(aCrit) == 0
    While ! BAU->(Eof()) .And. BAU->BAU_FILIAL == xFilial("BAU")
       //??????????????????????????????????????????????????????????????????????????Ä¿
       //? Despreza RDA fora do intervalo informado nos parametros iniciais         ?
       //????????????????????????????????????????????????????????????????????????????
       If  ! Empty(cRdaDe+cRdaAte) .and. !(BAU->BAU_CODIGO >= cRDADe .And. BAU->BAU_CODIGO <= cRDAAte)
			BAU->(DbSkip())
			Loop                              
       EndIf
      	//??????????????????????????????????????????????????????????????????????????Ä¿
      //? Despreza RDA fora do intervalo de Grupos de Pagamento informado nos      ?
      //? parametros iniciais                                                      ?
      //????????????????????????????????????????????????????????????????????????????
 	   If ! Empty(cGrpPag) .And. BAU->(FieldPos("BAU_GRPPAG")) > 0 .and. !BAU->BAU_GRPPAG $ cGrpPag
			BAU->(DbSkip())
			Loop
 	   EndIf
      //??????????????????????????????????????????????????????????????????????????Ä¿
      //? Despreza RDA generica                                                    ?
      //????????????????????????????????????????????????????????????????????????????
      If  BAU->BAU_CODIGO == cMVPLSRDAG
           BAU->(DbSkip())
           Loop                              
      Endif
      //??????????????????????????????????????????????????????????????????????????Ä¿
      //? Despreza RDA conforme filtro                                             ?
      //????????????????????????????????????????????????????????????????????????????
      If  ! Empty(cFiltro) .and. !BAU->BAU_TIPPRE $ cFiltro
			BAU->(DbSkip())
			Loop                              
      Endif                                        
      //??????????????????????????????????????????????????????????????????????????Ä¿
      //? Testa se foi marcado o credenciado atual...                              ?
      //????????????????????????????????????????????????????????????????????????????
      If !Empty(BAU->BAU_OK)
			BAU->(DbSkip())
			Loop                              
      Endif
      //??????????????????????????????????????????????????????????????????????????Ä¿
      //? Exibe mensagem informativa...                                            ?
      //????????????????????????????????????????????????????????????????????????????
      MsProcTXT("RDA: " + BAU->BAU_CODIGO + " - " + AllTrim(BAU->BAU_NOME)+"...")
      //??????????????????????????????????????????????????????????????????????????Ä¿
      //? Calcula impostos para a RDA                                              ?
      //????????????????????????????????????????????????????????????????????????????
      nRecBAU  := BAU->(Recno())

		If !(lNewCal)
	       nAux := BAU->BAU_DIAPGT
	       While .T.
	             dVencReal := ctod(StrZero(nAux,2)+"/"+cMes+"/"+cAno)
	               
	             If ! Empty(dVencReal)
	                Exit
	             Endif
	             nAux --   
	       Enddo
	    else
	    	dVencReal	:= PLSCHKNCAL()
	    EndIf
       
		 cTipoTit := cPLTIPE2
		 cTipoTit := Eval({|| &cTipoTit })
		 cPrefixo := cPLPREE2
		 cPrefixo := Eval({|| &cPrefixo })

       aRetorno := PLSINTGPE(.T.,BAU->BAU_CODIGO,cAno,cMes,aVerbas,cCodOpe,cAno+cMes+cNumLote,"",BAU->BAU_CODSA2,BAU->BAU_LOJSA2,"",/*nValorBIR*/,/*nValorBIN1*/,/*nValorBIN2*/,/*nInsOutEmp*/,/*lAutonomo*/,dVencReal,/*aImpMes*/,/*lUltCalc*/,/*nVrIRRet*/,/*nBInsJFPls*/,/*lPgtoImp*/,/*aCompPag*/,/*lPgUni4*/,/*cNumero*/,/*lHist*/,cTipoTit)
       
       PLSB15_IMP(cCodOpe, cAno, cMes, BAU->BAU_CODIGO)
       
       BAU->(DbGoTo(nRecBAU))
       BAU->(DbSetOrder(nIndBAU))
                
       If  aRetorno[3]
           nQtdOK ++
       Else
           nQtdNO ++
           aadd(aCrit,{BAU->BAU_CODIGO,BAU->BAU_NOME,"",aRetorno[4]})
       Endif   
       //??????????????????????????????????????????????????????????????????????????Ä¿
       //? Acessa proximo registro   A                                              ?
       //????????????????????????????????????????????????????????????????????????????
       BAU->(DbSkip())
    EndDo
Else
    Help(STR0024) //"Nao foram selecionados credenciados"
Endif    
//??????????????????????????????????????????????????????????????????????????Ä¿                                           
//? Restaura filtro                                                          ?
//????????????????????????????????????????????????????????????????????????????
A470IND(cFiltro,.T.)
//??????????????????????????????????????????????????????????????????????????Ä¿                                           
//? Restaura area antiga...                                                  ?
//????????????????????????????????????????????????????????????????????????????
If  ! Empty(aOldArea[1])
    RestArea(aOldArea)
Endif   
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Caso houve resultados...                                                 ?
//????????????????????????????????????????????????????????????????????????????
If  nQtdOK > 0 .Or. nQtdNO > 0
    //?????????????????????????????????????????????????????????????????????Ä¿
    //? Abre a transacao...                                                 ?
    //???????????????????????????????????????????????????????????????????????
    Begin Transaction
    //??????????????????????????????????????????????????????????????????????????Ä¿
    //? Grava no arquivo de lote de pagto...                                     ?
    //????????????????????????????????????????????????????????????????????????????
    BAF->(RecLock("BAF",.T.))
	    BAF->BAF_FILIAL := xFilial("BAF")
	    BAF->BAF_CODOPE := cCodOpe
	    BAF->BAF_NUMLOT := cNumLote
	    BAF->BAF_ANOLOT := cAno
	    BAF->BAF_MESLOT := cMes
	    BAF->BAF_OPESIS := PLSRtCdUsr()
	    BAF->BAF_NOMOPE := PLRETOPE()
	    BAF->BAF_RDAPAG := nQtdOK
	    BAF->BAF_RDACRI := nQtdNO
	    BAF->BAF_DTDIGI := Date()
	    BAF->BAF_HRDIGI := StrTran(Time(),":","")
	    BAF->BAF_GRUPOS := cFiltro
	    BAF->BAF_HISTIT := STR0127
    BAF->(MsUnLock())  
    //??????????????????????????????????????????????????????????????????????????Ä¿
    //? Grava as criticas...                                                     ?
    //????????????????????????????????????????????????????????????????????????????
    For nAux := 1 To Len(aCrit)
        BEM->(RecLock("BEM",.T.))
  	    	BEM->BEM_FILIAL := xFilial("BEM")
	      	BEM->BEM_CODOPE := cCodOpe
	      	BEM->BEM_NUMLOT := cNumLote
	      	BEM->BEM_ANOLOT := cAno
	      	BEM->BEM_MESLOT := cMes
	      	BEM->BEM_CODCRI := aCrit[nAux,3]
	      	BEM->BEM_DESCRI := aCrit[nAux,4]
	      	BEM->BEM_CODRDA := aCrit[nAux,1]
	      	BEM->BEM_NOMRDA := aCrit[nAux,2]
        BEM->(MsUnLock())
    Next
    //?????????????????????????????????????????????????????????????????????Ä¿
    //? Finaliza transacao...                                               ?
    //???????????????????????????????????????????????????????????????????????    
    End Transaction 
    PLSA470MOV("BAF",BAF->(Recno()),K_Visualizar)
Endif
//?????????????????????????????????????????????????????????????????????Ä¿
//? Fecha sem?foro do Lote                                              ?
//???????????????????????????????????????????????????????????????????????    
If nHNumPag > 0
	PLSFechaSem(nHNumPag,cChaveLot)
EndIf
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Fim da Rotina...                                                         ?
//????????????????????????????????????????????????????????????????????????????
Return(.T.)
/*/
??????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
??? Funcao   ?PLSLOTIMP ? Autor ? Sandro Hoffman      ? Data ? 30.06.2006 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Verifica se ha guias no Lote de Importacao que estao com a ???
???          ? fase diferente de "3-Pronta". BOPS 102025                  ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
Static Function PLSLOTIMP(cLoteImp, cRdaDe, cRdaAte, mv_par25, mv_par26)
Local aGuias
Local aCabec
Local lRet  
Local aCampos
Local cCampos
Local cSQL
Local i
                
aGuias  := {}
aCabec  := {}
aCampos := { "BD6_FASE", "BD6_CODLDP", "BD6_CODPEG", "BD6_NUMERO", "BD6_CODPRO", "BD6_DESPRO", "BD6_NUMIMP", "BD6_NUMLOT" }
aCpos   := {}
cSQL    := ""

SX3->(DbSetOrder(2))
For i := 1 To Len(aCampos)
	If SX3->(MsSeek(aCampos[i]))
		aAdd(aCabec, { AllTrim(X3Titulo()), SX3->X3_PICTURE, IIf(Empty(SX3->X3_CBOX), SX3->X3_TAMANHO * 5, 60) })
		aAdd(aCpos, IIf(Empty(SX3->X3_CBOX), "TrbBD6->" + aCampos[i], 'X3Combo("' + aCampos[i] + '", ' + "TrbBD6->" + aCampos[i] + ')'))
		cSQL += IIf(Empty(cSQL), "", ", ") + aCampos[i]
	EndIf
Next i
//??????????????????????????????????????????????????????????????Ä¿
//? Monta array com as guias com fase diferente de "3-Pronta     ?
//????????????????????????????????????????????????????????????????
cSQL := "SELECT " + cSQL
cSQL += "  FROM " + RetSQLName("BD6")
cSQL += " WHERE BD6_FILIAL = '" + xFilial("BD6") + "'"
cSQL += "   AND BD6_SEQIMP = '" + cLoteImp + "'"
cSQL += "   AND BD6_FASE <> '3'"
cSQL += "   AND BD6_SITUAC = '1'"
cSQL += "   AND D_E_L_E_T_ <> '*'"
cSQL := ChangeQuery(cSQL)
dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cSQL),"TrbBD6",.F.,.T.)

TrbBD6->(DbGoTop())
Do While ! TrbBD6->(Eof())
   aAdd(aGuias, { })
   For i := 1 To Len(aCpos)
		aAdd(aGuias[Len(aGuias)], &(aCpos[i]))
   Next i
   TrbBD6->(DbSkip())
Enddo
TrbBD6->(DbCloseArea())
//?????????????????????????????????????????????????????????????????????Ä¿
//? Exibe tela com as guias com fase diferente de "3-Pronta"            ?
//???????????????????????????????????????????????????????????????????????
If  Len(aGuias) > 0
	PlsCriGen(aGuias, aCabec, STR0131)//"Lote de Importa??o nãoser? faturado pois cont?m Guias com FASE diferente de 'Pronta'"	
	lRet := .F.
Else
    lRet := .T.
Endif
//???????????????????????????????????????????????????????????????????????Ä¿
//? Pesquisa qual a RDA que recebera o pagamento deste Lote de Importacao ?
//? para efetuar o filtro a partir do codigo da RDA.                      ?
//?????????????????????????????????????????????????????????????????????????
BRJ->(DbSetOrder(1))
If BRJ->(MsSeek(xFilial("BRJ")+cLoteImp))
	BA0->(DbSetOrder(1))
	If BA0->(MsSeek(xFilial("BA0")+BRJ->BRJ_OPEORI))
		If ! Empty(BA0->BA0_CODRDA)
			cRdaDe   := BA0->BA0_CODRDA
			cRdaAte  := BA0->BA0_CODRDA
			mv_par25 := BA0->BA0_CODRDA
			mv_par26 := BA0->BA0_CODRDA
		Else
			MsgInfo(STR0172 + AllTrim(BA0->BA0_NOMINT) + STR0173)//"Lote de Importa??o nãoser? processado pois a " + AllTrim(BA0->BA0_NOMINT) + " nãopossui RDA vinculada."
			lRet := .F.
		EndIf
	EndIf
EndIf
//?????????????????????????????????????????????????????????????????????Ä¿
//? Fim da funcao                                                       ?
//???????????????????????????????????????????????????????????????????????
Return lRet
/*/
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
??? Funcao   ?fMntPAR24 ? Autor ? Sandro Hoffman      ? Data ? 16.08.2006 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Troca "*" por "" e separa cada "Tipo de Prestador" sele-   ???
???          ? cionado com uma virgula.                                   ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
Static Function fMntPAR24(mv_par24)
Local i, cNewStr := ""

For i := 1 To Len(AllTrim(mv_par24))
	If SubStr(mv_par24, i, 1) <> "*"
		cNewStr += IIf(Empty(cNewStr), "", ",") + SubStr(mv_par24, i, 1)
	EndIf
Next i

Return cNewStr

/*
???????????????????????????????????????????????????????????????????????????????
???????????????????????????????????????????????????????????????????????????????
???????????????????????????????????????????????????????????????????????????Ä¿??
???Funcao    ? PLS470GP   ? Autor ? Sandro Hoffman Lopes  ? Data ? 04.09.06 ???
???????????????????????????????????????????????????????????????????????????Ä´??
???Descricao ? Monta um "markbrowse" para marcar/desmarcar quais grupos de  ???
???          ? pagamento deverao ser retornados pela funcao.                ???
???          ? Parametros:                                                  ???
???          ? - cDados:  Inicializador (conteudo anterior do campo)        ???
???          ? - cCampo:  Campo/variavel que devera ser atualizado(a)       ???
???          ? - nTam:    Tamanho maximo da string que sera retornada       ???
???          ?            (Se nao passado ou passar zero, considera a       ???
???          ?             string completa)                                 ???
???          ? - cCond:   Condicao para filtrar registros                   ???
???          ? Retorno:                                                     ???
???          ? - cDado: Lista de codigos selecionados pela funcao           ???
???          ?          Exemplo de retorno: "0001,0003,0004"                ???
????????????????????????????????????????????????????????????????????????????Ù±?
???????????????????????????????????????????????????????????????????????????????
???????????????????????????????????????????????????????????????????????????????
/*/
Function PLS470GP(cDado,cCampo,nTam,cCond)
	Local oDlg
	Local nOpca     := 0
	Local bOK       := { || nOpca := K_OK, oDlg:End() }
	Local bCancel   := { || oDlg:End() }
	Local oCritica
	Local cSQL
	Local aCritica  := {}
	Local nInd                     
	Local aPosObj   := {}
	Local aObjects  := {}
	Local aSize     := {}
	Local aInfo     := {}
	local lRet		  := .F.
	Local aCampos := {}
	Local aBls    := {}
	Default cCampo  := ""           
	Default nTam    := 0
	Default cCond   := ""
	
	//??????????????????????????????????????????????????????????????????????????Ä¿
	//? Coloca virgula no inicio da string (caso tenha inicializador padrao)     ?
	//????????????????????????????????????????????????????????????????????????????
	cDado := AllTrim(cDado)   
	If  SubStr(cDado, Len(cDado), 1) != "," .And. cDado != ""
		cDado += ","
	EndIf

    B16->(DbSetOrder(2))
    B16->(DbGoTop())
	While ! B16->(Eof())
	    If ! Empty(cCond)
	       If ! &cCond
	          B16->(DbSkip())
	          Loop
           EndIf 
        EndIf
	    aAdd(aCritica, { B16->B16_CODIGO, B16->B16_DESCRI, IIf(B16->B16_CODIGO $ cDado, .T., .F.) })
		B16->(DbSkip())
	Enddo

	aSize := MsAdvSize()
	aSize[7] := Round(aSize[7] * 0.75, 0)
	aSize[6] := Round(aSize[6] * 0.75, 0)
	aSize[5] := Round(aSize[5] * 0.75, 0)
	aSize[4] := Round(aSize[4] * 0.75, 0)
	aSize[3] := Round(aSize[3] * 0.75, 0)
	aObjects := {}       
	AAdd( aObjects, { 1, 10, .T., .F., .T. } )
	AAdd( aObjects, { 1, 1, .T., .T., .T. } )
	
	aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 }
	aPosObj := MsObjSize( aInfo, aObjects )

	DEFINE MSDIALOG oDlg TITLE STR0141 FROM aSize[7],0 To aSize[6],aSize[5] OF GetWndDefault() Pixel // "Grupos de Pagamento"

	@ aPosObj[1][1],aPosObj[1][2]+5 SAY oSay PROMPT STR0142 SIZE aPosObj[1][3],aPosObj[1][4] OF oDlg PIXEL COLOR CLR_HBLUE // "Selecione o(s) Lancamento(s)"

	oCritica := TcBrowse():New( aPosObj[2][1], aPosObj[2][2], aPosObj[2][3], aPosObj[2][4],,,, oDlg,,,,,,,,,,,, .F.,, .T.,, .F., )
                                            
	oCritica:AddColumn(TcColumn():New(" ",{ || IF(aCritica[oCritica:nAt,3],LoadBitmap( GetResources(), "LBOK" ),LoadBitmap( GetResources(), "LBNO" )) },;
         "@!",nil,nil,nil,015,.T.,.T.,nil,nil,nil,.T.,nil))     

	oCritica:AddColumn(TcColumn():New(STR0034,{ || OemToAnsi(aCritica[oCritica:nAt,1]) },; // "Codigo"
         "@!",nil,nil,nil,020,.F.,.F.,nil,nil,nil,.F.,nil))     
	
	oCritica:AddColumn(TcColumn():New(STR0035,{ || OemToAnsi(aCritica[oCritica:nAt,2]) },; // "Descricao"
         "@!",nil,nil,nil,200,.F.,.F.,nil,nil,nil,.F.,nil))     

	oCritica:SetArray(aCritica)         
	oCritica:bLDblClick := { || aCritica[oCritica:nAt,3] := IF(aCritica[oCritica:nAt,3],.F.,.T.) }


	//-- LGPD -------- 
	if objCENFUNLGP:isLGPDAt() 
		aCampos := {.F.,"B16_CODIGO","B16_DESCRI"} 
		aBls := objCENFUNLGP:getTcBrw(aCampos) 
		oCritica:aObfuscatedCols := aBls 
	endif 
	//---------------- 

	ACTIVATE MSDIALOG oDlg ON INIT EnChoiceBar(oDlg,bOK,bCancel,.F.,{}) Center

	If nOpca == K_OK
                  
	   cDado := ""
	   For nInd := 1 To Len(aCritica)
	       If aCritica[nInd,3]
	          cDado += aCritica[nInd,1]+","
	       Endif 
	   Next nInd

	EndIf
                                  
	//??????????????????????????????????????????????????????????????????????????Ä¿
	//? Tira a virgula do final da string                                        ?
	//????????????????????????????????????????????????????????????????????????????
	If SubStr(cDado, Len(cDado), 1) == ","
		cDado := SubStr(cDado, 1, Len(cDado) - 1)
	EndIf                

    If nTam > 0
		cDado := SubStr(cDado, 1, nTam)
	EndIf

	If ! Empty(cCampo)
		cCampo  := "M->" + cCampo
		&cCampo := cDado 
	EndIf

if ! empty(cDado)
	lRet := .T.
endif
Return(lRet)

                  
/*
???????????????????????????????????????????????????????????????????????????????
???????????????????????????????????????????????????????????????????????????????
???????????????????????????????????????????????????????????????????????????Ä¿??
???Funcao    ? PL470VldGP ? Autor ? Sandro Hoffman Lopes  ? Data ? 04.09.06 ???
???????????????????????????????????????????????????????????????????????????Ä´??
???Descricao ? Valida o conteudo de "cConteudo" que foi digitado ou retor-  ???
???          ? nado pela funcao "PLS470GP". Devera conter os codigos dos    ???
???          ? grupos de pagamento separados por virgula e validos.         ???
???          ? Parametros:                                                  ???
???          ? - cConteudo: Codigos dos Grupos de Pagamento a validar       ???
???          ?              Ex.: "0001,0003,0004"                           ???
???          ? Retorno:                                                     ???
???          ? - lRet: .T. se encontrou o registro na tabela B16            ???
???          ?         .F. se nao encontrou o registro na tabela B16        ???
????????????????????????????????????????????????????????????????????????????Ù±?
???????????????????????????????????????????????????????????????????????????????
???????????????????????????????????????????????????????????????????????????????
*/
Function PL470VldGP(cConteudo)

   Local nPos
   Local lRet  := .T.
   
   B16->(DbSetOrder(1)) 
   
   Do While !Empty(cConteudo)
      nPos := At(",", cConteudo)
      If nPos == 0
         nPos := Len(cConteudo) + 1
      EndIf
      If ! B16->(MsSeek(xFilial("B16")+SubStr(cConteudo, 1, nPos - 1)))
         lRet := .F.
         Exit
       Else
         cConteudo := SubStr(cConteudo, nPos + 1)
      EndIf
   EndDo

Return lRet

/*/
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
???Programa  ?MenuDef   ? Autor ? Darcio R. Sporl       ? Data ?05/01/2007???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Utilizacao de menu Funcional                               ???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
Static Function MenuDef(lAll)
Local aBtAdd		:={}
Default lAll	:= .T.

Private aRotina := {	{ STR0002,'AxPesqui'    ,  0 , K_Pesquisar  , 0, .F.},; // "Pesquisar"
                        { STR0003,'PLSA470MOV'  ,  0 , K_Visualizar , 0, Nil},; // "Visualizar"
                        { STR0004,'PLSA470NEW'  ,  0 , K_Incluir    , 0, Nil},; // "Novo Lote Pagto"
                        { STR0006,'PLSA470MOV'  ,  0 , K_Excluir    , 0, Nil},; // "Excluir Lote"
                        { STR0007,'PLSA470EXC'  ,  0 , K_Excluir    , 0, Nil}}  // "Exclusao Individual"
                        
if getNewPar("MV_PLPGUNI","1") == "2" 
    aadd(aRotina,       { STR0104   ,'PLSA470IMP'  ,  0 , K_Pesquisar  , 0, Nil}) // "Calculo Impostos"
endif
//??????????????????????????????????????????????????????????????Ä¿
//? P.E. utilizado para adicionar novas opcoes  ao menu         ?
//????????????????????????????????????????????????????????????????
If ExistBlock("PL470BAD")
	aBtAdd := ExecBlock("PL470BAD",.F.,.F.,{aRotina})
	If ValType(aBtAdd) == "A"
		AEval(aBtAdd,{|x| AAdd(aRotina,x)})
	EndIf
EndIf

If lAll
	aadd( aRotina, { STR0002,'BAU->(AxPesqui())'		,  0 , K_Incluir    , 0, Nil} )
	aadd( aRotina, { STR0148,'A470SldMar()'				,  0 , K_Pesquisar  , 0, .F.} )
	aadd( aRotina, { STR0149,'PL470CHVPG()'	,  0 , K_Visualizar , 0, Nil} )
	aadd( aRotina, { STR0150,'A470TitMar()'  			,  0 , K_Incluir    , 0, Nil} )
	aadd( aRotina, { "Marca/Desmarca todos",'A470Inverte()'  ,  0 , K_Pesquisar    , 0, Nil})
	aadd( aRotina,{ STR0120 ,'A470TitMar(.t.)' , 0 , K_Incluir , 0 , Nil} )	//"Gerar Pgto Selec - Ult Calc Mes"
	aAdd(aRotina,{"Processar Exclusão" 	,"PLS470Ret()"			, 0,4})
	aAdd(aRotina,{"Seleciona tudo"		,"PLS470Sel(1,oMark)"	, 0,4})
	aAdd(aRotina,{"Inverter seleção" 	,"PLS470Sel(2,oMark)"	, 0,4})
	aAdd(aRotina,{"Legenda"				,"BrwLegenda(aLegenda[1], aLegenda[2] ,aCdCores)"	, 0,4})
endIf

Return(aRotina)     

/*/
?????????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????Ä¿??
???Fun??o    ? PLSDSCPEG    ? Autor ?Microsiga              ?Data  ? 08/10/10 ???
?????????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Mostra tela de peg's 										  ???
??????????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????????
/*/
function PLSDSCPEG()
LOCAL nI		:= 0
LOCAL aMatCol 	:= {}
LOCAL aMatLin 	:= {}       
LOCAL cParOld   := ""
LOCAL lOk		:= .F.
//???????????????????????????????????????????????????????????????????????????
//? parametros old
//???????????????????????????????????????????????????????????????????????????
if empty(cParOld) .or. cParOld <> allTrim(MV_PAR14+MV_PAR08+MV_PAR09+MV_PAR10+MV_PAR11+MV_PAR29+MV_PAR30+MV_PAR33+MV_PAR34)
	cParOld := MV_PAR14+MV_PAR08+MV_PAR09+MV_PAR10+MV_PAR11+MV_PAR29+MV_PAR30+MV_PAR33+MV_PAR34
	cChaOLP	:= ""
	cExcPeg	:= ""
endIf	
//???????????????????????????????????????????????????????????????????????????
//? cabecalho
//???????????????????????????????????????????????????????????????????????????
aadd(aMatCol,{"Tipo Guia"	,'@!',050,.f.} )
aadd(aMatCol,{"Operadora"	,'@!',050,.f.} )
aadd(aMatCol,{"Processo"	,'@!',050,.t.} )
aadd(aMatCol,{"Cod. Local"	,'@!',050,.f.} )
aadd(aMatCol,{"PEG"			,'@!',050,.t.} )
aadd(aMatCol,{"Cod. Rda"	,'@!',040,.t.} )
aadd(aMatCol,{"Nome da Rda"	,'@!',200,.t.} )
//???????????????????????????????????????????????????????????????????????????
//? query
//???????????????????????????????????????????????????????????????????????????
cSql := " SELECT BCI_TIPGUI,BCI_CODOPE,BCI_PROCES,BCI_CODLDP,BCI_CODPEG,BCI_CODRDA,BCI_NOMRDA "
cSql += "  FROM "+BCI->(retSQLName("BCI"))
cSql += " WHERE BCI_FILIAL = '"+xFilial("BCI")+"' "
cSql += "   AND BCI_CODOPE = '"+MV_PAR14+"' "
cSql += "   AND BCI_CODLDP BETWEEN '"+MV_PAR08+"' AND '"+MV_PAR09+"' "
cSql += "   AND BCI_CODPEG BETWEEN '"+MV_PAR10+"' AND '"+MV_PAR11+"' "
cSql += "   AND BCI_CODRDA BETWEEN '"+MV_PAR29+"' AND '"+MV_PAR30+"' "
cSql += "   AND BCI_PROCES BETWEEN '"+MV_PAR33+"' AND '"+MV_PAR34+"' "
cSql += "   AND D_E_L_E_T_ = ' ' "
cSql += "   ORDER BY BCI_CODOPE,BCI_PROCES,BCI_CODLDP,BCI_CODPEG "
//???????????????????????????????????????????????????????????????????????????
//? executa query
//???????????????????????????????????????????????????????????????????????????
cSQL := changeQuery(cSQL)
dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cSQL),"TRBFIL",.F.,.T.)
//???????????????????????????????????????????????????????????????????????????
//? monta dados
//???????????????????????????????????????????????????????????????????????????
aMatLin := {}
while !TRBFIL->(eof()) 
	aadd(aMatLin,{X3COMBO("BXX_TIPGUI",TRBFIL->BCI_TIPGUI),TRBFIL->BCI_CODOPE,TRBFIL->BCI_PROCES,TRBFIL->BCI_CODLDP,TRBFIL->BCI_CODPEG,TRBFIL->BCI_CODRDA,TRBFIL->BCI_NOMRDA,(TRBFIL->(BCI_CODOPE+BCI_CODLDP+BCI_CODPEG) $ cChaOLP)})
TRBFIL->(dbSkip()) 
endDo
TRBFIL->(dbclosearea())
//???????????????????????????????????????????????????????????????????????????
//? todos os selecionados
//???????????????????????????????????????????????????????????????????????????
lOk := PLSSELOPT( "Processo e PEG(s)", "Marca e Desmarca todos", aMatLin, aMatCol, K_Incluir,.T.,.T.,.F.)
//???????????????????????????????????????????????????????????????????????????
//? monta os peg que foram selecionados para excluir do pagamento
//???????????????????????????????????????????????????????????????????????????
if lOk
	cChaOLP	:= ""
	cExcPeg	:= ""
	cNoExcPeg	:= ""
	for nI:=1 to len(aMatLin)
	
		if aMatLin[nI,len(aMatLin[nI])]
			cExcPeg += +aMatLin[nI,5]+","
			cChaOLP += aMatLin[nI,2]+aMatLin[nI,4]+aMatLin[nI,5]+","
		Else
			cNoExcPeg += +aMatLin[nI,5]+","
		endIf
	
	next
	cExcPeg := left(cExcPeg,len(cExcPeg)-1)	
	cNoExcPeg := left(cNoExcPeg,len(cNoExcPeg)-1)
	
endIf	 
// a atualiza??o ? feita nas vari?veis cExcPeg e cNoExcPeg, a MV_PAR35 s? ? utilizada para chamar a fun??o no Pergunte() 
MV_PAR35 := IIf(!empty(cExcPeg), "Sim", "Não" )
lOk	:= IIf(!empty(cExcPeg), .T., .F. )
//???????????????????????????????????????????????????????????????????????????
//? Fim da Rotina
//???????????????????????????????????????????????????????????????????????????
Return(lOk)


/*???????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Ä¿??
???Programa  ? VldProcs ? Autor ? Thiago Guilherme  ? Data ? 05.11.2013 ???
?????????????????????????????????????????????????????????????????????????Ä´??
???Descri??o ? Controla mensagem referente aos par?metro MV_PAR33 e MV_PAR34???
??????????????????????????????????????????????????????????????????????????Ù±?
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
/*/
Function VldProcs()
LOCAL cProDe  := MV_PAR33
LOCAL cProAte := MV_PAR34

If (!EMPTY(cProDe) .OR. !EMPTY(cProAte)) .AND. !Empty(mv_par14)
	
	If !lMsgProc 
		MsgAlert('Com os parametros "Processo de" e "Processo até" preenchidos, apenas os paremetros "Ano Base", "Mês Base", "Data de Vencimento" e "Operadora" serão considerados para gerar o lote de pagamento.')
		lMsgProc := .T.
	EndIf
EndIf
Return .T.

/*
???????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????????Í»??
???Programa  ?qtdVldRda ?Autor  ? Totvs			    ? Data ? 26/11/13   	???
?????????????????????????????????????????????????????????????????????????Í¹??
???Desc.     ? verifica rda para pagamento e total de rda                 ???
?????????????????????????????????????????????????????????????????????????Í¼??
?????????????????????????????????????????????????????????????????????????????
???????????????????????????????????????????????????????????????????????????
*/
static function qtdVldRda(cRdaDe,cRdaAte,cGrpPag,cMVPLSRDAG,cFiltro,cCopCre,cMarca,lGerPagBlo,dVencto,aCrit,nQtdNO)
local aRet		:= {}
local lRet		:= .F.
default aCrit	:= {}
default nQtdNO	:= 0
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Despreza RDA fora do intervalo informado nos parametros iniciais         ?
//????????????????????????????????????????????????????????????????????????????
If !Empty(cRdaDe+cRdaAte)
	If  !(BAU->BAU_CODIGO >= cRDADe .And. BAU->BAU_CODIGO <= cRDAAte)
		lRet := .t.
	Endif
EndIf
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Despreza RDA fora do intervalo de Grupos de Pagamento informado nos      ?
//? parametros iniciais                                                      ?
//????????????????????????????????????????????????????????????????????????????
If !lRet .and. !Empty(cGrpPag) .And. BAU->(FieldPos("BAU_GRPPAG")) > 0
	If !BAU->BAU_GRPPAG $ cGrpPag
		lRet := .t.
	EndIf
EndIf
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Despreza RDA generica                                                    ?
//????????????????????????????????????????????????????????????????????????????
If !lRet .and. BAU->BAU_CODIGO == cMVPLSRDAG
	lRet := .t.
Endif
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Despreza RDA conforme filtro                                             ?
//????????????????????????????????????????????????????????????????????????????
If !lRet .and. !Empty(cFiltro)
	If !BAU->BAU_TIPPRE $ cFiltro
		lRet := .t.
	Endif
Endif
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Despreza RDA conforme Tipo de Prestador                            	  ?
//????????????????????????????????????????????????????????????????????????????
If !lRet .and. !Empty(cCopCre)
	If !BAU->BAU_COPCRE $ cCopCre
		lRet := .t.
	Endif
Endif
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Testa se foi marcado o credenciado atual...                              ?
//????????????????????????????????????????????????????????????????????????????
If !lRet .and. Empty(BAU->BAU_OK)
	lRet := .t.
Endif
         
If !lRet .and. BAU->BAU_OK<>cMarca
	lRet := .t.
Endif
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Testa caso de rda bloqueada ou nao...                                    ?
//????????????????????????????????????????????????????????????????????????????
If !lRet .and. !Empty(BAU->BAU_CODBLO) .and. !lGerPagBlo
	lRet := .t.
Endif
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Testa vencimento em branco...                                            ?
//????????????????????????????????????????????????????????????????????????????
If !lRet .and. Empty(dVencto) .And. ( BAU->BAU_DIAPGT == 0 .Or. BAU->BAU_DIAPGT > 31 )
	nQtdNO ++
	aadd(aCrit,{BAU->BAU_CODIGO,BAU->BAU_NOME,"IN",STR0026}) //"Vencimento invalido para este prestador"
	lRet := .t.
Endif
//??????????????????????????????????????????????????????????????????????????Ä¿
//? Ponto de entrada para analisar se deseja processar a RDA                 ?
//? Retorno: { lRet , Cod Critica , Descricao Critica }                      ?
//????????????????????????????????????????????????????????????????????????????
if !lRet .and. existBlock("PLS470RD")
	aRet := execBLock("PLS470RD",.f.,.f.)
	
	if  ! aRet[1]
		aadd(aCrit,{BAU->BAU_CODIGO,BAU->BAU_NOME,aRet[2],aRet[3]})
		lRet := .t.
	endIf
endIf
         
return(lRet)

//--------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PLSLDLIQTT
Retorna o saldo liquido de um faturamento gerado para gravacao do campo BAF_VLRLIQ, pois agora posso ter mais de um titulo por rda e o aretorno nao serve mais

@author PLS TEAM
@since 13/05/2016
@version P12
/*/
//--------------------------------------------------------------------------------------------------
Static Function PLSLDLIQTT(cCodOpe,cAno,cMes,cNumLot,cPrefixo,cTipo,nBruCalc,nLiqCalc)
Local cSql			:= ""
Local nSldLiq		:= 0
Local aTotLote      := {}
Local nSldBruto		:= 0
Default cCodOpe		:= ""
Default cAno		:= ""
Default cMes		:= ""
Default cNumLot		:= ""
Default cPrefixo	:= ""
Default cTipo		:= ""
Default nBruCalc	:= 0
Default nLiqCalc	:= 0

cSql := "SELECT E2_VALOR, E2_TIPO,E2_INSS FROM " + RetSqlName("SE2") 
cSql += " WHERE E2_FILIAL = '" + xFilial("SE2") + "' "
cSql += " AND E2_PLOPELT = '" + cCodOpe + "' "  
cSql += " AND E2_PLLOTE = '" + cAno+cMes+cNumLot + "' "
cSql += " AND E2_PREFIXO = '" +cPrefixo+ "' " 
cSql += " AND E2_ORIGEM = 'PLSMPAG' "
cSql += " AND D_E_L_E_T_=' '"

dbUseArea(.T.,"TOPCONN",TCGENQRY(,,ChangeQuery(cSql)),"SLDLIQ",.F.,.T.)

While !SLDLIQ->(Eof())

	If AllTrim(cTipo) <> AllTrim(SLDLIQ->E2_TIPO)//Demais titulos - debito
		nSldLiq += SLDLIQ->E2_VALOR
	EndIf

	if SLDLIQ->E2_INSS > 0 
		 nSldBruto += SLDLIQ->E2_INSS   //Somar inss ao Bruto
		 nSldLiq   += SLDLIQ->E2_INSS  
	endif

    nSldBruto += SLDLIQ->E2_VALOR 
    
	SLDLIQ->(dbSkip())
	
EndDo

nSldLiq := nSldBruto - nSldLiq

SLDLIQ->(dbCloseArea())

Aadd(aTotLote,Iif(nSldLiq - nLiqCalc >= 0,nSldLiq - nLiqCalc,0))
Aadd(aTotLote,nSldBruto - nBruCalc)

Return aTotLote

//--------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RetImpTpCo
Retorna o percentual de imposto da natureza

@author PLS TEAM
@since 13/05/2016
@version P12
/*/
//--------------------------------------------------------------------------------------------------
Function RetImpTpCo()
Local cTpCo := IIf(!INCLUI,BGQ->BGQ_TIPOCT,M->BGQ_TIPOCT)
Local nRet	:= 20
Local cNat	:= ''

SED->(dbSetOrder(1))
Do Case
	Case cTpCo == '1'
		cNat	:= GetNewPar('MV_PLSNTPF','')
	Case cTpCo == '2'
		cNat	:= GetNewPar('MV_PLSNTPJ','')
	Case cTpCo == '3'
		cNat	:= GetNewPar('MV_PLSNTFT','')
	Case cTpCo == '4'
		cNat	:= GetNewPar('MV_PLSNTHN','')
EndCase		

If !Empty(cNat) .and. SED->(dbSeek(xFilial('SED')+cNat,.F.))
	nRet	:= SED->ED_PERCINS	
EndIf

Return(nRet)	

/*/{Protheus.doc} PLSCHKNCAL
Retorna a Data de pagamento atribu?da no novo calend?rio de pagamento para a
o m?s atual (olhando o dDataBase)
As 6 regras do novo calend?rio, por prioridade, s?o:
1) Informado Ano, M?s e RDA 
2) Informado somente M?s e RDA 
3) Informado somente Ano e RDA
4) Informado somente Ano e M?s
5) Informado somente M?s
6) Informado somente Ano

IMPORTANTE:
Para o funcionamento correto desta fun??o, ? necess?rio estar posicionado no Registro da BAU

@author PLS TEAM
@since 13/05/2016
@version P12
/*/
Function PLSCHKNCAL(cMesAux, cAnoAux)
Local dRet 	    := CtoD("")
Local cAnoPag	:= ""
Local cMesPag	:= ""
Local cDiaPag	:= ""
Local lAchou	:= .f.
Local cCalPad	:= ""
Local cDia	    := ""
local nI        := 0

default cMesAux	:= StrZero(Month(dDataBase), 2)
default cAnoAux	:= AllTrim(Str(Year(dDataBase)))

cCalPad := BAU->BAU_CALPGT

B2K->(dbSetOrder(1))

//Se h? calend?rio vinculado, j? vamos direto nele
if ! empty(cCalPad) 

    for nI := 1 to 2

        if B2K->( msSeek( xFilial("B2K") + cCalPad ) )	
            
            //Posicionamos no calend?rio da refer?ncia
            while ! B2K->(eof()) .and. B2K->B2K_COD == cCalPad
                
                if (B2K->B2K_ANO == cAnoAux) .and. (B2K->B2K_MES == cMesAux) .and. (B2K->B2K_CODRDA == BAU->BAU_CODIGO) .and. B2K->B2K_STATUS == "1"
                    
                    lAchou := .t.
                    
                elseIf (B2K->B2K_MES == cMesAux) .and. empty(B2K->B2K_ANO) .and. (B2K->B2K_CODRDA == BAU->BAU_CODIGO) .and. B2K->B2K_STATUS == "1"
                    
                    lAchou := .t.
                
                elseIf (B2K->B2K_ANO == cAnoAux) .and. empty(B2K->B2K_MES) .and. (B2K->B2K_CODRDA == BAU->BAU_CODIGO) .and. B2K->B2K_STATUS == "1"
                
                    lAchou := .t.
                
                elseIf (B2K->B2K_ANO == cAnoAux) .and. (B2K->B2K_MES == cMesAux) .and. empty(B2K->B2K_CODRDA) .and. B2K->B2K_STATUS == "1"
                
                    lAchou := .t.
                
                elseIf (B2K->B2K_MES == cMesAux) .and. empty(B2K->B2K_ANO) .and. empty(B2K->B2K_CODRDA) .and. B2K->B2K_STATUS == "1"
                
                    lAchou := .t.
                
                elseIf (B2K->B2K_ANO == cAnoAux) .and. empty(B2K->B2K_MES) .and. empty(B2K->B2K_CODRDA) .and. B2K->B2K_STATUS == "1"
                
                    lAchou := .t.
                
                endIf
                
                if lAchou
                    cDia := B2K->B2K_DIAPGT
                    exit
                endIf    

            B2K->(dbSkip())
            endDo
            
            if lAchou

                cDiaPag := strZero(val(cDia), 2)

                if cMesAux == "12"
                    cMesPag := "01"
                    cAnoPag := Soma1(cAnoAux)
                else
                    cMesPag := Soma1(cMesAux)
                    cAnoPag := cAnoAux
                endIf

                dRet := ctod(cDiaPag + "/" + cMesPag + "/" + cAnoPag)
                
                exit
                
            elseIf nI == 1
 
            	B2J->(dbSetOrder(1)) //B2J_FILIAL+B2J_CODINT+B2J_COD
                while ! B2J->(eof()) .and. B2J->B2J_CALPAD <> "1" 
                    B2J->(dbskip())
                endDo
                
            	if ! B2J->(eof())
		            cCalPad := B2J->B2J_COD
                else
                    exit    
                endIf

            endIf
            
        endIf

	next

endIf

return dRet


/*/{Protheus.doc} PL470STRET
Retorno utilizado na fun??o PLSTIPPRE para evitar erro ao
selecionar um rda (antes retornava "xx")

@author PLS TEAM
@since 23/04/2018
@version P12
/*/
function PL470STRET()

return cPLSTIPPRE

//------------------------------------------------------------------------------------------
/*/{Protheus.doc} PLS470Mark
Selecionar mais de uma RDA ou titulos por vez, para excluir em um lote

@author PLS TEAM
@since 27/09/2018
@version P12
/*/
//------------------------------------------------------------------------------------------
Static Function PLS470Mark(aDados)
Local aCpos		:= {}
Local aCampos	:= {}
Local aRet		:= {}
Local aTam		:= {}
Local cTitMBrow	:= OemToAnsi("Exclusão Individual")
Local nFor 		:= 0

Private cAliasTRB	:= ""

aTam := {10,00}
aAdd(aCpos,  {"TIPO"				,"C", aTam[1], aTam[2]})
aAdd(aCampos,{"Tipo"				,"TIPO"			,"C","@!",1,aTam[1],aTam[2]})

aTam := {06,00}
aAdd(aCpos,  {"COD_RDA"				,"C", aTam[1], aTam[2]})
aAdd(aCampos,{"Cod. Rda"			,"COD_RDA"		,"C","",0,aTam[1],aTam[2]})

aTam := TamSx3("BAU_NOME")
aAdd(aCpos,  {"NOME_RDA"			,"C", aTam[1], aTam[2]})
aAdd(aCampos,{"Nome da RDA"			,"NOME_RDA"		,"C","@!",1,aTam[1],aTam[2]})

aTam := {17,00}
aAdd(aCpos,  {"NUMERO"				,"C", aTam[1], aTam[2]})
aAdd(aCampos,{"Numero"				,"NUMERO"		,"C","@!",1,aTam[1],aTam[2]})

aTam := {08,00}
aAdd(aCpos,  {"VENCTO"				,"D", aTam[1], aTam[2]})
aAdd(aCampos,{"Data"				,"VENCTO"		,"C","@!",1,aTam[1],aTam[2]})

aTam := TamSx3("E2_VALOR")
aAdd(aCpos,  {"VALOR"				,"N", aTam[1], aTam[2]})
aAdd(aCampos,{"Valor"				,"VALOR"		,"N",PesqPict("SE2","E2_VALOR"),2,aTam[1],aTam[2]})

aTam := TamSx3("E2_IRRF")
aAdd(aCpos,  {"IRRF"				,"N", aTam[1], aTam[2]})
aAdd(aCampos,{"IRRF"				,"IRRF"			,"N",PesqPict("SE2","E2_IRRF"),2,aTam[1],aTam[2]})

aTam := TamSx3("E2_INSS")
aAdd(aCpos,  {"INSS_PF"				,"N", aTam[1], aTam[2]})
aAdd(aCampos,{"INSS PF"				,"INSS_PF"		,"N",PesqPict("SE2","E2_INSS"),2,aTam[1],aTam[2]})

aTam := TamSx3("E2_ISS")
aAdd(aCpos,  {"INSS_PJ"				,"N", aTam[1], aTam[2]})
aAdd(aCampos,{"INSS PJ"				,"INSS_PJ"		,"N",PesqPict("SE2","E2_ISS"),2,aTam[1],aTam[2]})

aTam := TamSx3("E2_INSS")
aAdd(aCpos,  {"INSS_PJENT"			,"N", aTam[1], aTam[2]})
aAdd(aCampos,{"INSS PJ Ent. Fil."	,"INSS_PJENT"	,"N",PesqPict("SE2","E2_INSS"),2,aTam[1],aTam[2]})

aTam := TamSx3("E2_VRETPIS")
aAdd(aCpos,  {"PIS"					,"N", aTam[1], aTam[2]})
aAdd(aCampos,{"PIS"					,"PIS"			,"N",PesqPict("SE2","E2_VRETPIS"),2,aTam[1],aTam[2]})

aTam := TamSx3("E2_VRETCOF")
aAdd(aCpos,  {"COFINS"				,"N", aTam[1], aTam[2]})
aAdd(aCampos,{"COFINS"				,"COFINS"		,"N",PesqPict("SE2","E2_VRETCOF"),2,aTam[1],aTam[2]})

aTam := TamSx3("E2_VRETCSL")
aAdd(aCpos,  {"CSLL"				,"N", aTam[1], aTam[2]})
aAdd(aCampos,{"CSLL"				,"CSLL"			,"N",PesqPict("SE2","E2_VRETCSL"),2,aTam[1],aTam[2]})

aTam := TamSx3("E2_SALDO")
aAdd(aCpos,  {"VALOR_LIQ"			,"N", aTam[1], aTam[2]})
aAdd(aCampos,{"Valor Liquido"		,"VALOR_LIQ"	,"N",PesqPict("SE2","E2_SALDO"),2,aTam[1],aTam[2]})

aTam := {09,00}
aAdd(aCpos,  {"FORNECEDOR"			,"C", aTam[1], aTam[2]})
aAdd(aCampos,{"Fornecedor"			,"FORNECEDOR"	,"C","@!",1,aTam[1],aTam[2]})

aTam := TamSx3("E2_NOMFOR")
aAdd(aCpos,  {"NOME_FORN"			,"C", aTam[1], aTam[2]})
aAdd(aCampos,{"Nome Fornecedor"		,"NOME_FORN"	,"C","@!",1,aTam[1],aTam[2]})

aTam := TamSx3("E2_NATUREZ")
aAdd(aCpos,  {"NATUREZA"			,"C", aTam[1], aTam[2]})
aAdd(aCampos,{"Natureza"			,"NATUREZA"		,"C","@!",1,aTam[1],aTam[2]})

aTam := {10,00}
aAdd(aCpos,  {"LOCAL_PGTO"			,"C", aTam[1], aTam[2]})
aAdd(aCampos,{"Local de Pagamento"	,"LOCAL_PGTO"	,"C","@!",1,aTam[1],aTam[2]})

aTam := TamSx3("E2_LA")
aAdd(aCpos,  {"CONTABILIZ"			,"C", aTam[1], aTam[2]})
aAdd(aCampos,{"LA"					,"CONTABILIZ"	,"C","@!",1,aTam[1],aTam[2]})

aTam := {02,00}
aAdd(aCpos,  {"IDMARK"				,"C", aTam[1], aTam[2]})

//------------------
//Cria??o da tabela temporaria
//------------------
If _oBaixa <> Nil
	_oBaixa:Delete()
	_oBaixa := Nil
Endif
cAliasTRB := GetNextAlias()
_oBaixa  := FWTemporaryTable():New( cAliasTRB )  
_oBaixa:SetFields(aCpos) 
_oBaixa:Create()
//aStru
For nFor := 1 to Len(aDados)
	(cAliasTRB)->(RecLock(cAliasTRB,.T.))
	(cAliasTRB)->TIPO		:= aDados[nFor][01]
	(cAliasTRB)->COD_RDA	:= aDados[nFor][02]
	(cAliasTRB)->NOME_RDA	:= aDados[nFor][03]
	(cAliasTRB)->NUMERO		:= aDados[nFor][04]
	(cAliasTRB)->VENCTO		:= aDados[nFor][05]
	(cAliasTRB)->VALOR		:= aDados[nFor][06]
	(cAliasTRB)->IRRF		:= aDados[nFor][07]
	(cAliasTRB)->INSS_PF	:= aDados[nFor][08]
	(cAliasTRB)->INSS_PJ	:= aDados[nFor][09]
	(cAliasTRB)->INSS_PJENT	:= aDados[nFor][10]
	(cAliasTRB)->PIS		:= aDados[nFor][11]
	(cAliasTRB)->COFINS		:= aDados[nFor][12]
	(cAliasTRB)->CSLL		:= aDados[nFor][13]
	(cAliasTRB)->VALOR_LIQ	:= aDados[nFor][14]
	(cAliasTRB)->FORNECEDOR := aDados[nFor][15]
	(cAliasTRB)->NOME_FORN	:= aDados[nFor][16]
	(cAliasTRB)->NATUREZA 	:= aDados[nFor][17]
	(cAliasTRB)->LOCAL_PGTO	:= aDados[nFor][18]
	(cAliasTRB)->CONTABILIZ := aDados[nFor][19]
	(cAliasTRB)->(MsUnLock())
Next nFor

If Len(aDados) > 0
	_aMarks := {}
	Private aRotina		:= {}

	aAdd(aRotina,{"Processar Exclusão" 	,"PLS470Ret()"			, 0,4})
	aAdd(aRotina,{"Seleciona tudo"		,"PLS470Sel(1,oMark)"	, 0,4})
	aAdd(aRotina,{"Inverter seleção" 	,"PLS470Sel(2,oMark)"	, 0,4})
	aAdd(aRotina,{"Legenda"				,"BrwLegenda(aLegenda[1], aLegenda[2] ,aCdCores)"	, 0,4})
	
	dbSelectArea(cAliasTRB)
	dbGoTop()

	//??????????????????????????????????????????????????????Ä¿
	//? Construcao do MarkBrowse                             ?
	//????????????????????????????????????????????????????????
	oMark:=FWMarkBrowse():NEW()		// Cria o objeto oMark - MarkBrowse
	oMark:SetAlias(cAliasTRB)		// Define a tabela do MarkBrowse
	oMark:SetDescription(cTitMBrow)	// Define o titulo do MarkBrowse
	oMark:SetFieldMark("IDMARK")	// Define o campo utilizado para a marcacao
	oMark:SetFilterDefault("")		// Define o filtro a ser aplicado no MarkBrowse
	oMark:SetFields(aCampos)		// Define os campos a serem mostrados no MarkBrowse
	oMark:SetSemaphore(.F.)			// Define se utiliza marcacao exclusiva
	oMark:SetWalkThru(.F.)			// Desabilita a opcao de WalkThru
	oMark:DisableReport()			// Desabilita a opcao de imprimir
	oMark:SetAllMark({|| fSelecAll(oMark)})
	oMark:AddLegend( "(cAliasTRB)->VALOR == (cAliasTRB)->VALOR_LIQ","GREEN",	"titulo/ Pedido de Compra Liberado para Exclusão" )
	oMark:AddLegend( "(cAliasTRB)->CONTABILIZ == 'S'", 				"YELLOW",	"titulo Contabilizado" )
	oMark:AddLegend( "(cAliasTRB)->VALOR <> (cAliasTRB)->VALOR_LIQ","RED",		"titulo Baixado" )
	oMark:Activate()				// Ativa o MarkBrowse
	
	If !Empty(_aMarks)
		For nFor := 1 To Len(_aMarks)
			aAdd(aRet,{_aMarks[nFor][01],_aMarks[nFor][02]})
		Next nFor
	EndIf
Else
	Help( ,, 'HELP',,"Registros não encontrado !!!", 1, 0)
EndIf

If _oBaixa <> Nil
	_oBaixa:Delete()
	_oBaixa := Nil
Endif

Return(aRet)

//------------------------------------------------------------------------------------------
/*/{Protheus.doc} PLS470Sel
Funcionalidade de Seleção

@author    PLS TEAM
@version   1.xx
@since     27/09/2018
/*/
//------------------------------------------------------------------------------------------
Function PLS470Sel(nTipo,oMark)
Local lRet := .T.

If nTipo == 1
	fSelecAll(oMark,.F.)
ElseIf nTipo == 2
	fSelecAll(oMark,.T.)
EndIf

Return()

//------------------------------------------------------------------------------------------
/*/{Protheus.doc} fSelecAll
Seleciona todos os registros

@author PLS TEAM
@since 27/09/2018
@version P12
/*/
//------------------------------------------------------------------------------------------
Static Function fSelecAll(oMark,lInverte)

Local lRet		:= .T.		  	 						// Retorno da rotina.                           
Local aAreaTmp	:= (oMark:Alias())->(GetArea())	  		// Guarda a area do browse.
Local lTop 		:= .T.	  								// Posiciona no primeiro registro.
Local cMsg		:= ""

Default lInverte := .F.

If lInverte
	cMsg	:= "Deseja Inverter a Seleção de Todos os Registros ?"
Else
	cMsg	:= "Deseja Selecionar Todos os Registros ?"
EndIf

If MsgYesNo(cMsg,OemToAnsi('ATENCAO'))

	(oMark:Alias())->(DbGoTop())
	While (oMark:Alias())->(!Eof())
		If lInverte
			If ( !oMark:IsMark() )
				RecLock(oMark:Alias(),.F.)
				(oMark:Alias())->IDMARK  := oMark:Mark()
				(oMark:Alias())->(MsUnLock())
			Else
				RecLock(oMark:Alias(),.F.)
				(oMark:Alias())->IDMARK  := " "
				(oMark:Alias())->(MsUnLock())
			EndIf
		Else
			RecLock(oMark:Alias(),.F.)
			(oMark:Alias())->IDMARK  := oMark:Mark()
			(oMark:Alias())->(MsUnLock())
		EndIf
		(oMark:Alias())->(DbSkip())
	EndDo
Endif

RestArea(aAreaTmp)  
oMark:Refresh(lTop)

Return( lRet )

//------------------------------------------------------------------------------------------
/*/{Protheus.doc} PLS470Ret
Prepara o array de retorno para exclusão

@author    PLS TEAM
@version   1.xx
@since     27/09/2018
/*/
//------------------------------------------------------------------------------------------
Function PLS470Ret()
Local cMarca	:= oMark:Mark()
Local nPos		:= 0

_aMarks := {}

dbSelectArea(cAliasTRB)
(cAliasTRB)->(DbGoTop())

While !(cAliasTRB)->(Eof())
	nPos++
	If oMark:IsMark(cMarca)
		aAdd(_aMarks,{.T.,nPos})
	EndIf
	(cAliasTRB)->(dbSkip())
EndDo

CloseBrowse()

Return()

//------------------------------------------------------------------------------------------
/*/{Protheus.doc} PL470CHVPG
fun??o para chamada do PLSVALPAG.  Criada para que o cadastro de privil?gios funcione corretamente.
@author    Oscar
@since     29/04/2019
/*/
//------------------------------------------------------------------------------------------
function PL470CHVPG()

return PLSVALPAG("PLSA470")


//------------------------------------------------------------------------------------------
/*/{Protheus.doc} PL470CHRGExs
Fun??o para verificar se existe Recurso de Glosa atrelado ao lote. Se sim, não pode excluir.
@since     06/2019
/*/
//------------------------------------------------------------------------------------------
function PL470CHRGExs(cCodOpe, cChaveLote)
local cSql 		:= ""
local lRecOpen	:= .f.

cSql := "SELECT B4D_FILIAL "
cSql += " FROM " + RetSqlName("B4D")
cSql += " WHERE B4D_FILIAL = '" + xFilial("B4D") + "' "
cSql += " AND B4D_OPELOT = '" + cCodOpe + "' AND B4D_NUMLOT = '" + cChaveLote + "' "
cSql += " AND D_E_L_E_T_ = ' ' "
cSql := ChangeQuery(cSql)
dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cSql),"TRBREC",.F.,.T.)

If !TRBREC->(Eof())
	lRecOpen := .T.
Else
	lRecOpen := .F.
EndIf

TRBREC->(dbCloseArea())

return lRecOpen


/*/{Protheus.doc} baixaFutura
Valida se h? baixa futura em algum dos titulos antes da exclusão

@author    Lucas Nonato
@version   V12
@since     29/11/2019
/*/
static function baixaFutura(cCodRda,aBaixaFut)
local cSql 			:= ""
local lRet			:= .f.
local aRet			:= {}
default cCodRda 	:= ""
default aBaixaFut 	:= {}
//E2_FILIAL+E2_PLOPELT+E2_PLLOTE+E2_NOMFOR  
                                                                                                                     
cSql := "SELECT E2_PREFIXO,E2_NUM,E2_PARCELA,E2_TIPO,E2_FORNECE,E2_LOJA,E2_NOMFOR,E2_BAIXA "
cSql += " FROM " + RetSqlName("SE2")
cSql += " WHERE E2_FILIAL = '" + xFilial("SE2") + "' "
cSql += " AND E2_PLOPELT = '" + BAF->BAF_CODOPE + "'"
cSql += " AND E2_PLLOTE = '" + BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT)  + "'"
if !empty(cCodRda)
	cSql += " AND E2_CODRDA = '" + cCodRda + "'"
endif
cSql += " AND E2_BAIXA > '" + dtos(dDataBase)  + "'"
cSql += " AND D_E_L_E_T_ = ' ' "

dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cSql),"TRBFUT",.F.,.T.)

while !TRBFUT->(eof())
	lRet := .t.
	aadd(aBaixaFut, {TRBFUT->E2_PREFIXO,TRBFUT->E2_NUM,TRBFUT->E2_PARCELA,TRBFUT->E2_TIPO,"Titulos com baixa futura não podem ser extornados! Data da Baixa: " + dtoc(stod(TRBFUT->E2_BAIXA)) })  
	aAdd(aRet,{TRBFUT->E2_PREFIXO,TRBFUT->E2_NUM,TRBFUT->E2_PARCELA,TRBFUT->E2_TIPO,TRBFUT->E2_FORNECE,TRBFUT->E2_LOJA,TRBFUT->E2_NOMFOR,stod(TRBFUT->E2_BAIXA)})
	TRBFUT->(dbskip())
enddo

if lRet .and. empty(cCodRda)
	PLSCRIGEN(aRet,{ {STR0041,"@C",30}, {STR0042,"@C",30 }, {STR0043,"@C",30 }, {"Tipo","@C",30}, {STR0044,"@C",30} , {"Loja","@C",30},{STR0045,"@C",100 },{"Baixa","@D",8 }  }, "Titulos com baixa futura não podem ser extornados!") //"Prefixo"###"Numero"###"Parcela"//"Fornecedor"//"Nome Fornecedor"
endif

TRBFUT->(dbCloseArea())

return lRet

//------------------------------------------------------------------------------------------
/*/{Protheus.doc} delBGQBBC
Exclusão de d?bito/cr?dito fixo lan?ado automatico

@author    Lucas Nonato
@version   V12
@since     05/12/2019
/*/
static function delBGQBBC()
local cSql as char

cSql := " SELECT R_E_C_N_O_ RECNO FROM " +RetSqlName("BGQ")
cSql += " WHERE BGQ_FILIAL = '" + xFilial("BGQ") + "'"
cSql += " AND BGQ_CODIGO = '" + BAU->BAU_CODIGO + "'"
cSql += " AND BGQ_ANO = '" + BAF->BAF_ANOLOT + "'"
cSql += " AND BGQ_MES = '" + BAF->BAF_MESLOT + "'"
cSql += " AND BGQ_CODOPE = '" + BAF->BAF_CODOPE + "'"
cSql += " AND BGQ_OPELOT = '" + BAF->BAF_CODOPE + "'"
cSql += " AND BGQ_NUMLOT = '" + BAF->(BAF_ANOLOT+BAF_MESLOT+BAF_NUMLOT) + "'"
cSql += " AND BGQ_LANAUT = '1' "
cSql += " AND BGQ_NUMLAU = 'BBC' "
cSql += " AND D_E_L_E_T_ = ' ' "

dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cSQL),"TrbDEL",.F.,.T.)		

while !TrbDEL->(eof())   	
    BGQ->(dbgoto(TrbDEL->RECNO))
    BGQ->(reclock("BGQ",.F.))
    BGQ->(dbdelete())
    BGQ->(msunlock())		              
	TrbDEL->(DbSkip())
enddo

TrbDEL->(dbclosearea())

return
