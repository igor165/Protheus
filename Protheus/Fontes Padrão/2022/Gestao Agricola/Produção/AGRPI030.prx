#INCLUDE "PROTHEUS.CH"
#INCLUDE 'FWMVCDEF.CH'
#INCLUDE "FWADAPTEREAI.CH"
#INCLUDE "AGRPI030.CH"

Static cMessage   := "AgriculturalGeneticEvent"
Static cModelId   := "AGRPA030"
Static nTamCod    := TamSX3("NCJ_CODIGO")[1]

/*/{Protheus.doc} AGRPI030
Função de integração com o adapter EAI para envio e recebimento do cadastro de
eventos genéticos (NCJ) utilizando o conceito de mensagem única.

@param   cXml          Variável com conteúdo XML para envio/recebimento.
@param   cTypeTrans    Tipo de transação (Envio / Recebimento).
@param   cTypeMsg      Tipo de mensagem (Business Type, WhoIs, etc).
@param   cVersion      Versão da mensagem.
@param   cTransac      Nome da transação.

@author  Rogério Sá
@version P12
@since   03/09/2018
@return  aRet  - (array)    Contém o resultado da execução e a mensagem XML de retorno.
       aRet[1] - (boolean)  Indica o resultado da execução da função
       aRet[2] - (caracter) Mensagem XML para envio
       aRet[3] - (caracter) Nome da mensagem
/*/
Function AGRPI030(cXml, cTypeTrans, cTypeMsg, cVersion, cTransac)

Local aRet := {.F., "", cMessage}

If (cTypeMsg == EAI_MESSAGE_WHOIS)
	aRet[1] := .T.
	aRet[2] := '2.000'

ElseIf (cTypeTrans == TRANS_SEND .or. cTypeTrans == TRANS_RECEIVE)
	If cVersion = "2."
		aRet := v2000(cXml, cTypeTrans, cTypeMsg, cVersion)
	Else
		aRet[2] := STR0001  // "A versão da mensagem informada não foi implementada!"
	Endif
Endif

Return aRet


/*/{Protheus.doc} v2000
Implementação do adapter EAI, versão 2.x

@author  Rogério Sá
@version P12
@since   03/09/2018
/*/
Static Function v2000(cXml, cTypeTrans, cTypeMsg, cVersion)

Local lRet       := .F.
Local cXmlRet    := ""
Local nX

Local oXml, oModel, cRefer, cEvent, nMVCOper
Local aErro, cErro, cErroCps

Local lFound     := .F.
Local xValue     := nil
Local cNodePath  := ""
Local aIntID     := {}
Local aValInt    := {}
Local cValInt    := ""
Local cValExt    := ""

If (cTypeTrans == TRANS_SEND)
	If (cTypeMsg == EAI_MESSAGE_BUSINESS)
		lRet    := .T.
		oModel  := FwModelActive()
		cValInt := oModel:GetValue('NCJMASTER', 'NCJ_CODIGO')

		cXMLRet := '<BusinessEvent>'
		cXMLRet += ' <Entity>' + cMessage + '</Entity>'
		cXMLRet += ' <Event>' + If(oModel:GetOperation() = MODEL_OPERATION_DELETE, 'delete', 'upsert') + '</Event>'
		cXMLRet += ' <Identification><key name="code">' + cValInt + '</key></Identification>'
		cXMLRet += '</BusinessEvent>'
		cXMLRet += '<BusinessContent>'
		cXMLRet += ' <CompanyId>' + _NoTags(RTrim(cEmpAnt)) + '</CompanyId>'
		cXMLRet += ' <BranchId>' + _NoTags(RTrim(cFilAnt)) + '</BranchId>'
		cXMLRet += ' <CompanyInternalId>' + _NoTags(RTrim(cEmpAnt + '|' + cFilAnt)) + '</CompanyInternalId>'
		cXMLRet += ' <InternalId>' + AP030IntId(nil, cValInt) + '</InternalId>'
		cXMLRet += ' <Code>' + _NoTags(RTrim(cValInt)) + '</Code>'
		If (oModel:GetOperation() <> MODEL_OPERATION_DELETE)
			cXMLRet += ' <Description>' + StrTran(_NoTags(RTrim(oModel:GetValue('NCJMASTER', 'NCJ_DESCRI'))), CRLF, "&#x0d;&#x0a;") + '</Description>'
			cXMLRet += ' <CommercialDescription>' + _NoTags(RTrim(oModel:GetValue('NCJMASTER', 'NCJ_NOMCOM'))) + '</CommercialDescription>'
			cXMLRet += ' <AgriculturalCultureCode>' + _NoTags(RTrim(oModel:GetValue('NCJMASTER', 'NCJ_CULTUR'))) + '</AgriculturalCultureCode>'
			cXMLRet += ' <AgriculturalCultureInternalId>' + AI800IntId(nil, oModel:GetValue('NCJMASTER', 'NCJ_CULTUR')) + '</AgriculturalCultureInternalId>'
			cXMLRet += ' <AgroFitCode>' + _NoTags(RTrim(oModel:GetValue('NCJMASTER', 'NCJ_UNICO'))) + '</AgroFitCode>'
			cXMLRet += ' <DonorOganismDescription>' + _NoTags(RTrim(oModel:GetValue('NCJMASTER', 'NCJ_DOADOR'))) + '</DonorOganismDescription>'
			cXMLRet += ' <Characteristics>' + _NoTags(RTrim(oModel:GetValue('NCJMASTER', 'NCJ_CARACT'))) + '</Characteristics>'
			cXMLRet += ' <Protein>' + _NoTags(RTrim(oModel:GetValue('NCJMASTER', 'NCJ_PROT'))) + '</Protein>'
			cXMLRet += ' <ApprovalYear>' + _NoTags(RTrim(oModel:GetValue('NCJMASTER', 'NCJ_APROV'))) + '</ApprovalYear>'
		Endif
		cXMLRet += '</BusinessContent>'
		oModel := nil
	Endif

ElseIf (cTypeTrans == TRANS_RECEIVE)
	If (cTypeMsg == EAI_MESSAGE_RESPONSE)  // Resposta da mensagem única TOTVS.
		// Gravo o de/para local, caso tenha sido gravado o dado no sistema remoto.
		lRet := .T.
		oXml := tXmlManager():New()
		oXml:Parse(cXml)
		If Empty(cErro := oXml:Error())
			If upper(oXml:xPathGetNodeValue('/TOTVSMessage/ResponseMessage/ProcessingInformation/Status')) = "OK"
				cRefer := oXml:xPathGetAtt('/TOTVSMessage/MessageInformation/Product', 'name')
				cEvent := AllTrim(Upper(oXml:xPathGetNodeValue('/TOTVSMessage/ResponseMessage/ReceivedMessage/Event')))
				aIntID := oXml:XPathGetChildArray('/TOTVSMessage/ResponseMessage/ReturnContent/ListOfInternalId')
				For nX := 1 to len(aIntID)
					cValExt := oXml:xPathGetNodeValue(aIntID[nX, 2] + '/Destination')
					cValInt := oXml:xPathGetNodeValue(aIntID[nX, 2] + '/Origin')
					If cEvent = 'DELETE' .and. !empty(cValInt)
						CFGA070Mnt(cRefer, "NCJ", "NCJ_CODIGO", nil, cValInt, .T.)
					ElseIf !empty(cValInt) .and. !empty(cValExt)
						CFGA070Mnt(cRefer, "NCJ", "NCJ_CODIGO", cValExt, cValInt)
					Else
						lRet  := .F.
						cErro := STR0002 + "|"  // "Erro no processamento pela outra aplicação"
						cErro += STR0003        // "Erro ao processar de/para de códigos."
					Endif
				Next nX
			Else
				lRet  := .F.
				cErro := STR0002 + "|"  // "Erro no processamento pela outra aplicação|"
				aErro := oXml:XPathGetChildArray('/TOTVSMessage/ResponseMessage/ProcessingInformation/ListOfMessages')
				For nX := 1 To len(aErro)
					cErro += oXml:xPathGetAtt(aErro[nX, 2], 'type') + ": " + Alltrim(oXml:xPathGetNodeValue(aErro[nX, 2])) + "|"
				Next nX
			Endif
		Endif
		oXml := nil

	ElseIf (cTypeMsg == EAI_MESSAGE_RECEIPT)  // Recibo.
		// Não realiza nenhuma ação.

	ElseIf (cTypeMsg == EAI_MESSAGE_BUSINESS)  // Chegada de mensagem de negócios.
		oXml := tXmlManager():New()
		oXml:Parse(cXml)
		If Empty(cErro := oXml:Error())
			lRet    := .T.
			cRefer  := oXml:xPathGetAtt('/TOTVSMessage/MessageInformation/Product', 'name')
			cEvent  := AllTrim(Upper(oXml:xPathGetNodeValue('/TOTVSMessage/BusinessMessage/BusinessEvent/Event')))
			cValExt := oXml:xPathGetNodeValue('/TOTVSMessage/BusinessMessage/BusinessContent/InternalId')
			cValInt := RTrim(CFGA070Int(cRefer, "NCJ", "NCJ_CODIGO", cValExt))
			aValInt := StrToKarr2(cValInt, "|", .T.)

			// Verifica se encontrou uma chave no de/para.
			If len(aValInt) > 2
				NCJ->(dbSetOrder(1))  // NCJ_FILIAL, NCJ_CODIGO.
				lFound := NCJ->(dbSeek(xFilial(nil, aValInt[2]) + aValInt[3], .F.))
			Endif

			If lFound
				If cEvent == 'UPSERT'
					nMVCOper := MODEL_OPERATION_UPDATE
				ElseIf cEvent == 'DELETE'
					nMVCOper := MODEL_OPERATION_DELETE
				Else
					lRet  := .F.
					cErro := STR0004  // "Operação inválida. Somente são permitidas as operações UPSERT e DELETE."
				Endif
			Else
				If cEvent == 'UPSERT'
					nMVCOper := MODEL_OPERATION_INSERT
				ElseIf cEvent == 'DELETE'
					lRet  := .F.
					cErro := STR0005  // "Registro não encontrado no Protheus."
				Else
					lRet  := .F.
					cErro := STR0004  // "Operação inválida. Somente são permitidas as operações UPSERT e DELETE."
				Endif
			Endif

			If lRet
				oModel := FwLoadModel(cModelId)
				oModel:SetOperation(nMVCOper)
				If oModel:Activate()
					If nMVCOper <> MODEL_OPERATION_DELETE
						cNodePath := '/TOTVSMessage/BusinessMessage/BusinessContent/'

						// Se for inclusão, trata o código do registro.
						If nMVCOper == MODEL_OPERATION_INSERT
							// Usa o inicializador padrão do campo de código.
							cValInt := oModel:GetValue('NCJMASTER', 'NCJ_CODIGO')

							// Se o código não tiver inicializador padrão, tenta usar o código do sistema de origem.
							If empty(cValInt)
								If oXml:XPathHasNode(cNodePath + 'Code')
									cValInt := RTrim(oXml:xPathGetNodeValue(cNodePath + 'Code'))
								Endif

								// Se o código for maior do que o campo do Protheus, não usar esse código.
								If len(cValInt) > nTamCod
									cValInt := ""
								Endif
							Endif

							// Se o código já existir na base, não usar esse código.
							If !empty(cValInt)
								cValInt := PadR(cValInt, nTamCod)
								NCJ->(dbSetOrder(1))  // NCJ_FILIAL, NCJ_CODIGO.
								If NCJ->(dbSeek(xFilial() + cValInt, .F.))
									cValInt := ""
								Endif
							Endif

							// Se não puder usar o mesmo código da origem, usa numeração sequencial automática.
							If empty(cValInt)
								cValInt := GetSXENum('NCJ', 'NCJ_CODIGO')
							Endif

							// Atualiza o código no modelo.
							If oModel:GetValue('NCJMASTER', 'NCJ_CODIGO') <> cValInt
								oModel:SetValue('NCJMASTER', 'NCJ_CODIGO', cValInt)
							Endif

							cValInt := AP030IntId(nil, cValInt)
						Endif

						If oXml:XPathHasNode(cNodePath + 'Description')
							xValue := oXml:xPathGetNodeValue(cNodePath + 'Description')
							oModel:SetValue('NCJMASTER', 'NCJ_DESCRI',    xValue)
						Endif

						If oXml:XPathHasNode(cNodePath + 'CommercialDescription')
							xValue := oXml:xPathGetNodeValue(cNodePath + 'CommercialDescription')
							oModel:SetValue('NCJMASTER', 'NCJ_NOMCOM',    xValue)
						Endif

						If oXml:XPathHasNode(cNodePath + 'AgriculturalCultureCode')
							xValue := oXml:xPathGetNodeValue(cNodePath + 'AgriculturalCultureCode')
							oModel:SetValue('NCJMASTER', 'NCJ_CULTUR',    xValue)
						Endif

						If oXml:XPathHasNode(cNodePath + 'AgriculturalCultureInternalId')
							xValue := oXml:xPathGetNodeValue(cNodePath + 'AgriculturalCultureInternalId')
							xValue := AI800Cod(cRefer, xValue)
							If Len(xValue) > 2
								oModel:SetValue('NCJMASTER', 'NCJ_UNICO', xValue[3])
							Else
								cErroCps := STR0011 + " " + STR0012
								lRet := .F.
							EndIf
						Endif

						If oXml:XPathHasNode(cNodePath + 'AgroFitCode')
							xValue := oXml:xPathGetNodeValue(cNodePath + 'AgroFitCode')
							oModel:SetValue('NCJMASTER', 'NCJ_UNICO',    xValue)
						Endif

						If oXml:XPathHasNode(cNodePath + 'DonorOganismDescription')
							xValue := oXml:xPathGetNodeValue(cNodePath + 'DonorOganismDescription')
							oModel:SetValue('NCJMASTER', 'NCJ_DOADOR',    xValue)
						Endif

						If oXml:XPathHasNode(cNodePath + 'Characteristics')
							xValue := oXml:xPathGetNodeValue(cNodePath + 'Characteristics')
							oModel:SetValue('NCJMASTER', 'NCJ_CARACT',    xValue)
						Endif

						If oXml:XPathHasNode(cNodePath + 'Protein')
							xValue := oXml:xPathGetNodeValue(cNodePath + 'Protein')
							oModel:SetValue('NCJMASTER', 'NCJ_PROT',    xValue)
						Endif

						If oXml:XPathHasNode(cNodePath + 'ApprovalYear')
							xValue := oXml:xPathGetNodeValue(cNodePath + 'ApprovalYear')
							oModel:SetValue('NCJMASTER', 'NCJ_APROV',    xValue)
						Endif
					Endif

					If lRet
						lRet := oModel:VldData() .and. oModel:CommitData()
					EndIf

					// Se gravou certo, retorna o código gravado.
					If lRet
						// Atualiza o de/para local.
						If nMVCOper = MODEL_OPERATION_DELETE
							CFGA070Mnt(cRefer, "NCJ", "NCJ_CODIGO", nil, cValInt, .T.)
						ElseIf nMVCOper = MODEL_OPERATION_INSERT
							CFGA070Mnt(cRefer, "NCJ", "NCJ_CODIGO", cValExt, cValInt)
						Endif

						cXmlRet := '<ListOfInternalId>'
						cXmlRet += ' <InternalId>'
						cXmlRet += '  <Origin>' + cValExt + '</Origin>'
						cXmlRet += '  <Destination>' + cValInt + '</Destination>'
						cXmlRet += ' </InternalId>'
						cXmlRet += '</ListOfInternalId>'
					Endif
				Else
					lRet  := .F.
					cErro := StrTran(STR0006, "%cModelId%", cModelId)  // "Erro ao ativar modelo %cModelId%."
				Endif

				If !lRet
					cErro := STR0007  // "A integração não foi bem sucedida. "
					aErro := oModel:GetErrorMessage()
					If len(aErro) > 4 .and. !empty(aErro[5])
						cErro += STR0008 + Alltrim(aErro[5]) + '-' + AllTrim(aErro[6])  // "Foi retornado o seguinte erro: "
						If !Empty(Alltrim(aErro[7]))
							cErro += " " + STR0009 + AllTrim(aErro[7])  // "Solução: "
						Endif
					Else
						cErro += STR0010  // "Verifique os dados enviados."
					Endif

					If !empty(cErroCps)
						cErro += " " + cErroCps
					Endif
				Endif
				oModel:Deactivate()
				oModel:Destroy()
				oModel := nil
			Endif
		Else
			lRet := .F.
		Endif
		oXml := nil
	Endif
EndIf

DelClassIntF()

// Se deu erro no processamento.
If !empty(cErro)
	lRet    := .F.
	cXmlRet := "<![CDATA[" + _NoTags(cErro) + "]]>"
Endif

Return {lRet, cXmlRet, cMessage}


/*/{Protheus.doc} AP030IntId
Monta o InternalId do registro.

@author  Rogério Sá
@version P12
@since   03/09/2081
/*/
Function AP030IntId(cFilOrig, cCodOrig)
Default cFilOrig := cFilAnt
Default cCodOrig := NCJ->NCJ_CODIGO
Return _NoTags(cEmpAnt + '|' + xFilial("NCJ", cFilOrig) + '|' + cCodOrig)


/*/{Protheus.doc} AP030Cod
Busca a chave local do registro a partir do InternalId do sistema remoto.

@author  Felipe Raposo
@version P12
@since   21/09/2018
/*/
Function AP030Cod(cRefer, cValExt)
Local cValInt := RTrim(CFGA070Int(cRefer, "NCJ", "NCJ_CODIGO", cValExt))
Local aValInt := StrToKarr2(cValInt, "|", .T.)
Return aValInt
