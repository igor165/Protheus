#include "PROTHEUS.ch"
#include "RESTFUL.ch"
#include "fileio.ch"
#include "mntng.ch"
#include 'parmtype.ch'

#define VERSIONWS '3.0.8'
#define MINVERSIONAPP '1.9.53'
#define DATEVERSION '30/09/2022'

#define __AFIELDSO_SO__ 1
#define _OS_ 1
#define _SS_ 2
#define CANCELCODE 1
#define FINISHCODE 2
#define PERMISS_OS 1
#define PERMISS_SS 2

// Posições que definem a situação do insumo.
#define _REALIZED_       1
#define _FORESEEN_       2

// Posições do array de insumos que definem a operação.
#define _UPDATE_         1
#define _INSERT_         2
#define _DELETE_         3

// Posições dos detalhes dos insumos.
#define _SEQUENCE_       1
#define _TASK_           2
#define _KEYTASK_        3
#define _TYPE_           4
#define _CODE_           5
#define _KEYCODE_        6
#define _USECALE_        7
#define _RESOURCEAMOUNT_ 8
#define _AMOUNT_         9
#define _UNITY_          10
#define _COST_           11
#define _DESTINY_        12
#define _STARTDATE_      13
#define _STARTHOUR_      14
#define _ENDDATE_        15
#define _ENDHOUR_        16
#define _WAREHOUSE_      17
#define _LOT_            18
#define _SUBLOT_         19
#define _DATELOT_        20
#define _LOCATION_       21
#define _SERIALNUMBER_   22
#define _INPUTNOTE_      23
#define _HOURUNITY_      24
#define _STORE_          25
#define _CATERER_        26
#define _WHITEM_         27
#define _WHREQUEST_      28
#define _SEQTASK_        29
#define _PERCENT_        30
#define _OCCURRENCES_    31

// Posições dos detalhes de ocorrências
#define _PROBLEM_        1
#define _CAUSE_          2
#define _KEYCAUSE_       3
#define _SOLUTION_       4
#define _KEYSOLUTION_    5
#define _OCCURNOTE_      6

#xtranslate @{Header <(cName)>} => ::GetHeader( <(cName)> )
#xtranslate @{Param <n>} => ::aURLParms\[ <n> \]
#xtranslate @{EndRoute} => EndCase
#xtranslate @{Route} => Do Case
#xtranslate @{When <path>} => Case NGIsRoute( ::aURLParms, <path> )
#xtranslate @{When <path> || <path2>} => Case NGIsRoute( ::aURLParms, <path> ) .or. NGIsRoute( ::aURLParms, <path2> )
#xtranslate @{Default} => Otherwise

//métodos que serão renomeados por motivos de Limitação de caracteres
#xtranslate EquipmentPicture => R01
#xtranslate WorkerPicture => R02
#xtranslate ObjectPicture => R03

#xtranslate OrderPicture => R04
#xtranslate OrderPictureRemove => R05
#xtranslate OrderCreate => R06
#xtranslate OrderUpdate => R07
#xtranslate OrderCancel => R08
#xtranslate OrderFinish => R09
#xtranslate OrderPictureList => R10

#xtranslate RequestCreate => R11
#xtranslate RequestPicture => R12
#xtranslate RequestPictureRemove => R13
#xtranslate RequestUpdate => R14
#xtranslate RequestOperation => R15
#xtranslate RequestRemove => R16
#xtranslate RequestPictureList => R17

// Array contendo todos os insumos recebidos do app MNTNG
Static aInputs := { { {}, {}, {} }, { {}, {}, {} } }

Static aETAPAS := {} //Etapas da ordem de serviço
Static cBarra  := If(isSRVunix(),"/","\")
Static cCurDir := CurDir() + If(cBarra $ CurDir(), "" , cBarra )
Static cUserST1               := "" //Código do funcionário da manutenção T1_CODFUNC
Static cUserTQ4               := "" //Código do executante TQ4_CDEXEC
Static cUserLog               := "" //Código do usuário Protheus
Static lPortalOrigin          := .F. //Indica quando é sincronização do portal mobile
Static lOrderPermission       := .F. //Indica se deve validar ambiente para ordens de serviço
Static lRequestPermission     := .F. //Indica se deve validar ambiente para solicitações no login e sync
Static aPermissions           := {}//Permissões do grupo do usuário do portal mobile
Static lPeMntNg               := ExistBlock("MNTNG")
Static lPeMntLog              := ExistBlock('MNTNGLOG') .And. ExecBlock('MNTNGLOG', .F., .F.,{})
Static lDBOrderOk             := .F. //Indica se os campos de usuários para OS estão configurados
Static lDBRequestOk           := .F. //Indica se os campos de usuário oara SS estão configurados
Static lHasSecurity           := HTTPGetSecurity() // Verifica se o processo de autenticação pelo framework está habilitado ( Security = 1 )
Static lMingle                := .F.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTNG
WebService REST para comunicação do aplicativo MNT NG com o SIGAMNT

@author	Larissa Thaís de Farias
@author Marcelo Camargo
@author Vitor Emanuel Batista
@author William Rozin
@author Maria Elisandra de Paula
@since	08/01/2016
@version P12
@return	Nil
/*/
//---------------------------------------------------------------------
WsRestful MNTNG Description STR0001 // "WebService utilizado na aplicação mobile de Ordem de Serviço do módulo de Manutenção de Ativos (SIGAMNT)."

	WsData Value As Character Optional
	WsData Operation As Character Optional
	WsData product As Character Optional
	WsData warehouse As Character Optional

	Data cJson

	WsMethod GET WorkerPicture Description STR0095 Path 'worker/picture/{email}' WsSyntax 'worker/picture/{email}' //"Download da imagem do funcionário"
	WsMethod GET File Description STR0096 Path 'download/{file}' WsSyntax 'download/{file}' //"Download de arquivo"
	WsMethod GET Image Description STR0097 Path 'image/{file}' WsSyntax 'image/{file}' //"Download de imagem"
	WsMethod GET EquipmentPicture Description STR0098 Path 'equipment/picture/{equipment}' WsSyntax 'equipment/picture/{equipment}' //"Download de imagem do equipamento"
	WsMethod GET ObjectPicture Description STR0099 Path 'picture/{object}' WsSyntax 'picture/{object}' //"Download de imagem pelo código do objeto"
	WsMethod GET OrderPictureList Description STR0100 Path 'pictures/{order}' WsSyntax 'pictures/{order}' //"Informações das imagens vinculadas à ordem de serviço"
	WsMethod GET RequestPictureList Description STR0101 Path 'service-request/{value}/list' WsSyntax 'service-request/{value}/list' //"Informações das imagens vinculadas à solicitação de serviço"
	WsMethod GET Version Description STR0102 Path 'version' WsSyntax 'version' //"Versão e data do web service"
	WsMethod GET V1Sync Description STR0103 Path '/v1/sync/{date}/' WsSyntax '/v1/sync/{date}/' //"Download de arquivos para o sincronismo"
	WsMethod GET CheckAll Description STR0148 Path '/check/all/' WsSyntax '/check/all/' //"Validações para utilização do MNTNG"
	WsMethod GET AliasNoOk Description STR0148 Path 'AliasNoOk' WsSyntax 'AliasNoOk' //"Validações para utilização do MNTNG"
	WsMethod GET LGV2 Description STR0189 Path 'loginV2' WsSyntax 'loginV2' // "Retorna os detalhes de uma filial via Mingle"
	WsMethod GET LGV3 Description STR0189 Path 'loginV3' WsSyntax 'loginV3' // "Retorna os detalhes de uma filial"

    WSMETHOD GET SB2;
        DESCRIPTION STR0201; //"Retorna saldo do insumo";
        WSSYNTAX "product-sb2/{product}" ;
        PATH "product-sb2/{product}" PRODUCES APPLICATION_JSON

    WSMETHOD GET SBF;
        DESCRIPTION STR0202; //"Retorna saldo do insumo com endereçamento";
        WSSYNTAX "product-sbf/{product}/{warehouse}}" ;
        PATH "product-sbf/{product}/{warehouse}" PRODUCES APPLICATION_JSON

	WsMethod POST Login Description STR0107 Path 'login' WsSyntax 'login' //"Autenticação do usuário"
	WsMethod POST Counter Description STR0108 Path 'counter' WsSyntax 'counter' //"Apontamento de contador"
	WsMethod POST PlayStop Description STR0109 Path 'playStop' WsSyntax 'playStop' //"Inicia ou finaliza um apontamento de mão de obra da ordem de serviço"
	WsMethod POST EquipmentPicture Description STR0110 Path 'upload/equipment/{equipment}' WsSyntax 'upload/equipment/{equipment}' //"Atualiza a imagem do equipamento no cadastro de bens"
	WsMethod POST WorkerPicture Description STR0111 Path 'upload/worker/{worker}' WsSyntax 'upload/worker/{worker}' //"Atualiza a imagem do funcionário no cadastro de funcionário da manutenção"
	WsMethod POST OrderPicture Description STR0112 Path 'upload/{operation}/{value}' WsSyntax 'upload/{operation}/{value}' //"Upload de imagem correspondendo a um problema ou solução da ordem de serviço"
	WsMethod POST OrderPictureRemove Description STR0113 Path 'picture/delete/{id}' WsSyntax 'picture/delete/{id}' //"Remove uma imagem da ordem de serviço"
	WsMethod POST OrderCreate Description STR0114 Path 'create' WsSyntax 'create' //"Inclusão de ordem de serviço"
	WsMethod POST OrderUpdate Description STR0115 Path 'update' WsSyntax 'update' //"Alteração de ordem de serviço"
	WsMethod POST OrderCancel Description STR0116 Path 'cancel' WsSyntax 'cancel' //"Cancelamento de ordem de serviço"
	WsMethod POST OrderFinish Description STR0117 Path 'finish' WsSyntax 'finish' //"Finalização de ordem de serviço"
	WsMethod POST RequestCreate Description STR0118 Path 'service-request' WsSyntax 'service-request' //"Inclusão de solicitação de serviço"
	WsMethod POST RequestPicture Description STR0119 Path 'service-request/{value}/{operation}' WsSyntax 'service-request/{value}/problem' //"Upload de imagem correspondendo a um problema da solicitação de serviço"

	WsMethod DELETE RequestRemove Description STR0120 Path 'service-request/{value}/' WsSyntax 'service-request/{value}/' //"Remove uma solicitação de serviço"
	WsMethod DELETE RequestPictureRemove Description STR0121 Path 'service-request/{value}/image/' WsSyntax 'service-request/{value}/image/' //"Remove uma imagem da solicitação de serviço"

	WsMethod PUT RequestUpdate Description STR0122 Path 'service-request/{value}/' WsSyntax 'service-request/{value}/' //"Alteração de solicitação de serviço"
	WsMethod PUT RequestOperation Description STR0123 Path 'service-request/{value}/{operation}' WsSyntax 'service-request/{value}/{operation}' //"Operações da solicitação de serviço"

End WsRestful

//---------------------------------------------------------------------
/*/{Protheus.doc} Login
Realiza a autenticação do usuário e retorna
as filiais que o usuário tem acesso e demais informações.

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST Login WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError

	printf('Metodo POST Login')

	::ClearResponse()
	::SetContentType( 'application/json' )

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ),lRet:= .F., Break(oError) } )
	Begin Sequence

		lRet := MultiBranchLogin( Self )

	End Sequence

	ErrorBlock( bLastError )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} LGV2
Aciona login V2 -> detalhes da filial para acesso via Mingle

@author Maria Elisandra de Paula
@param oSelf, instancia do ws
@since 14/06/2022
@return logic, se obteve sucesso no login
/*/
//---------------------------------------------------------------------
WSMETHOD GET LGV2 WsService Mntng

	Local lRet := .F.
	Local bLastError
	Local oError

	printf('inicio infos via MINGLE')

	::ClearResponse()
	::SetContentType( 'application/json' )

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ),lRet:= .F., Break(oError) } )
	Begin Sequence

		lRet := fInfoMINGL( Self )
	
	End Sequence

	ErrorBlock( bLastError )

	printf('fim infos via MINGLE')

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} LGV3
Aciona login V3 -> detalhes da filial sem Mingle

@author Maria Elisandra de Paula
@param oSelf, instancia do ws
@since 14/06/2022
@return logic, se obteve sucesso no login
/*/
//---------------------------------------------------------------------
WSMETHOD GET LGV3 WsService Mntng

	Local lRet := .F.
	Local bLastError
	Local oError

	printf('inicio infos licenca MNT')

	::ClearResponse()
	::SetContentType( 'application/json' )

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ),lRet:= .F., Break(oError) } )
	Begin Sequence

		lRet := fInfoMNT( Self )
	
	End Sequence

	ErrorBlock( bLastError )

	printf('fim infos licenca MNT')

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} SB2
Aciona o envio do saldo do insumo

@author Maria Elisandra de Paula
@param oSelf, instancia do ws
@since 30/08/2022
@return logic, se obteve sucesso no login
/*/
//---------------------------------------------------------------------
WSMETHOD GET SB2 QUERYPARAM Page PATHPARAM product WSREST mntng

	Local lRet := .T.
	Local bLastError
	Local oError
	Local aRet := {}

	printf('Metodo GET SB2')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent()), lRet:= .F., Break(oError)} )

	Begin Sequence

		If ( lRet := CheckAccess( Self, .F. ) )

			aRet := fGetSalSb2( Self, ::product )
			if !aRet[1]
				PrintPostLog( Self, lRet, aRet )
			EndIf
		EndIf
	End Sequence

	ErrorBlock(bLastError)
	
	printf('Fim GET SB2')

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} SBF
Aciona o envio de saldo do insumo com endereçamento

@author Maria Elisandra de Paula
@param oSelf, instancia do ws
@since 30/08/2022
@return logic, se obteve sucesso no login
/*/
//---------------------------------------------------------------------
WSMETHOD GET SBF QUERYPARAM Page PATHPARAM product, warehouse WSREST mntng

	Local lRet := .T.
	Local bLastError
	Local oError
	Local aRet := {}

	printf('Metodo GET SBF')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent()), lRet:= .F., Break(oError)} )

	Begin Sequence

		If ( lRet := CheckAccess( Self, .F. ) )

			aRet := fGetSalSbf( Self, ::product, ::warehouse )
			if !aRet[1]
				PrintPostLog( Self, lRet, aRet )
			EndIf
		EndIf
	End Sequence

	ErrorBlock(bLastError)

	printf('Fim GET SBF')

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} EquipmentPicture
Atualiza imagem do equipamento no cadastro de Bens

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST EquipmentPicture WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	printf('Metodo POST EquipmentPicture')

	Private cUserName
	Private oMainWnd := Self

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := CheckAccess( Self ) )

			Begin Transaction

				lRet := UplEquipPic( @{Param 3}, Self )
				PrintPostLog( Self, lRet )

			Recover
				DisarmTransaction()
			End Transaction

			CloseTransactions( aRet )

		EndIf
	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} WorkerPicture
Atualiza imagem do funcionário no cadastro de funcionário da manutenção

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST WorkerPicture WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	Private cUserName
	Private oMainWnd := Self

	printf('Metodo POST WorkerPicture')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := CheckAccess( Self ) )

			Begin Transaction

				lRet := UplWorkerPic( @{Param 3}, Self )
				PrintPostLog( Self, lRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} OrderPicture
Upload de imagem correspondendo a um problema ou solução da ordem de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST OrderPicture PATHPARAM value, operation WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	Private cUserName
	Private oMainWnd := Self

	printf('Metodo POST OrderPicture' )

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := CheckAccess( Self, , .T. ) )

			Begin Transaction

				aRet := fSaveImg( Self, ::value, Upper( ::operation ), 'STJ' )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} OrderPictureRemove
Remove imagem da ordem de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST OrderPictureRemove WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	Private cUserName
	Private oMainWnd := Self

	printf('Metodo POST OrderPictureRemove')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := CheckAccess( Self, , .T. ) )

			Begin Transaction

				aRet := DelOrderFile( @{Param 3}, Self )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} OrderCreate
Inclui ordem de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST OrderCreate WsService Mntng

	Local lTmpTbl := .F.
	Local lRet    := .T.
	Local aRet    := {}
	Local bLastError
	Local oError

	Private cUserName
	//Esta variável deve estar definida como objeto pois é utilizada em workflow do SIGAMNT (Ex: MNTW215)
	//Caso a variável for retirada, ocorrerá a reabertura da empresa/filial gerando problemas com o BeginTran()
	Private oMainWnd := Self
	Private aNewSc   := {}

	printf('Metodo POST OrderCreate')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := CheckAccess( Self, , .T. ) )

			If ( lTmpTbl := AllTrim( SuperGetMv( 'MV_NGMNTES', .F., 'N' ) ) == 'S' .And. AllTrim( SuperGetMv( 'MV_MNTPRAL', .F., '2' ) ) == '1' .And. FindFunction( 'NewTrbAlt' ) )
				// Quando utilizado conceito de produto alternativo se faz necessária criação dos TRB's antes da
				// inicialização do begin transaction.
				NewTrbAlt()
			EndIf

			Begin Transaction

				aRet := createSO( Self )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence
	If lTmpTbl
		oTempIns:Delete()
		oTempSLP:Delete()
	EndIf
	ErrorBlock(bLastError)

Return lRet


//---------------------------------------------------------------------
/*/{Protheus.doc} OrderUpdate
Altera ordem de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST OrderUpdate WsService Mntng

	Local lTmpTbl := .F.
	Local lRet    := .T.
	Local aRet    := {}
	Local bLastError
	Local oError

	Private cUserName
	Private oMainWnd := Self
	Private aNewSc   := {}

	printf('Metodo POST OrderUpdate')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := CheckAccess( Self, , .T. ) )

			If ( lTmpTbl := AllTrim( SuperGetMv( 'MV_NGMNTES', .F., 'N' ) ) == 'S' .And. AllTrim( SuperGetMv( 'MV_MNTPRAL', .F., '2' ) ) == '1' .And. FindFunction( 'NewTrbAlt' ) )
				// Quando utilizado conceito de produto alternativo se faz necessária criação dos TRB's antes da
				// inicialização do begin transaction.
				NewTrbAlt()
			EndIf

			Begin Transaction

				aRet := updateSO( Self:GetContent(), Self )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence
	If lTmpTbl
		oTempIns:Delete()
		oTempSLP:Delete()
	EndIf
	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} OrderCancel
Cancela ordem de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST OrderCancel WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	Private cUserName
	Private oMainWnd := Self

	printf('Metodo POST OrderCancel')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ),lRet:= .F., Break(oError) } )

	Begin Sequence

		If ( lRet := CheckAccess( Self, , .T. ) )

			Begin Transaction

				aRet := cancelSO( Self )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} OrderFinish
Finaliza ordem de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST OrderFinish WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	Private cUserName
	Private oMainWnd := Self

	printf('Metodo POST OrderFinish')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ),lRet:= .F., Break(oError) } )
	Begin Sequence

		If ( lRet := CheckAccess( Self, , .T. ) )

			Begin Transaction

				aRet := finishSO( Self )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} PlayStop
Inicia ou finaliza um apontamento de mão de obra da ordem de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST PlayStop WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	Private cUserName
	Private oMainWnd := Self

	printf('Metodo POST playStop')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ),lRet:= .F., Break(oError) } )
	Begin Sequence

		If ( lRet := CheckAccess( Self, , .T. ) )

			Begin Transaction

				aRet := playStop( Self:GetContent() )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} Counter
Realiza o apontamento de contador

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST Counter WsService Mntng

	Local lTmpTbl := .F.
	Local lRet    := .T.
	Local aRet    := {}
	Local bLastError
	Local oError

	Private cUserName
	Private oMainWnd := Self
	Private aNewSc   := {}

	printf('Metodo POST counter')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ),lRet:= .F., Break(oError) } )
	Begin Sequence

		If ( lRet := CheckAccess( Self ) )

			If ( lTmpTbl := AllTrim( SuperGetMv( 'MV_NGMNTES', .F., 'N' ) ) == 'S' .And. AllTrim( SuperGetMv( 'MV_MNTPRAL', .F., '2' ) ) == '1' .And. FindFunction( 'NewTrbAlt' ) )
				// Quando utilizado conceito de produto alternativo se faz necessária criação dos TRB's antes da
				// inicialização do begin transaction.
				NewTrbAlt()
			EndIf

			Begin Transaction

				aRet := updCounter( Self:GetContent() )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence
	If lTmpTbl
		oTempIns:Delete()
		oTempSLP:Delete()
	EndIf
	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} RequestCreate
Inclusão de solicitação de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST RequestCreate WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	Private cUserName
	Private oMainWnd := Self

	printf('Metodo POST RequestCreate')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ),lRet:= .F., Break(oError) } )
	Begin Sequence

		If ( lRet := CheckAccess( Self ) )

			Begin Transaction

				aRet := NGUpsertSR( Self, "create", Nil )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} RequestPicture
Upload de imagem correspondendo a um problema ou solução da solicitação de serviço

@author Maria Elisandra de Paula
@since 21/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD POST RequestPicture PATHPARAM value, operation WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	Private cUserName
	Private oMainWnd := Self

	printf('Metodo POST RequestPicture')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ),lRet:= .F., Break(oError) } )
	Begin Sequence

		If ( lRet := CheckAccess( Self ) )

			Begin Transaction

				aRet := fSaveImg( Self, ::value, Upper( ::operation ), 'TQB' )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} Version
Retorna a versão atual do ws

@author Maria Elisandra de Paula
@since 29/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET Version WsService Mntng

	::ClearResponse()
	::SetContentType( 'application/json' )

	printf('Metodo GET Version')
	::SetStatus( 200 )
	::SetResponse( getVersion() )
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} CheckAll
Validações para utilização do app

@author	Maria Elisandra de Paula
@since 30/01/2019
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET CheckAll WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError

	printf('Metodo GET CheckAll')

	::ClearResponse()
	::SetContentType( 'application/json' )

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ),lRet:= .F., Break(oError) } )
	Begin Sequence
		lRet :=  CheckEnvironment( Self )
	End Sequence

	ErrorBlock( bLastError )

Return lRet

WsMethod GET AliasNoOk WsService Mntng

	Local lRet := .F.

	printf('Metodo GET AliasNoOk')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent()), lRet:= .F., Break(oError)} )

	Begin Sequence

		If ( lRet := CheckAccess( Self, .F. ) )

			PrintPostLog( Self, lRet, { .t.,  FWJsonSerialize( fCheckBase( "all", .T. ), .F. )  } )

		EndIf
	End Sequence

	ErrorBlock(bLastError)

Return lRet


//---------------------------------------------------------------------
/*/{Protheus.doc} V1Sync
Gera e envia os pacotes para o sincronismo

@author	Maria Elisandra de Paula
@since 29/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET V1Sync WsService Mntng

	Local lRet := .T.
	Local aRet := {}
	Local bLastError
	Local oError

	printf('Metodo GET V1Sync')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent()), lRet:= .F., Break(oError)} )
	Begin Sequence

		If ( lRet := CheckAccess( Self ) )

			aRet := DoSyncV1( Self, @{Param 3} )
			lRet := PrintPostLog( Self, lRet, aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} File
Realiza o download de arquivo

@author	Maria Elisandra de Paula
@since 29/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET File WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError

	printf('Metodo GET File')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent()), lRet:= .F., Break(oError)} )

	Begin Sequence

		If ( lRet := CheckAccess( Self, .F. ) )

			lRet := fDownload( Self, cCurDir + @{Param 2}, @{Param 2}, lMingle )
			PrintPostLog( Self, lRet )

		EndIf
	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} image
Realiza download de imagem

@author	Maria Elisandra de Paula
@since 29/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET image WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError

	printf('Metodo GET image')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent()), lRet:= .F., Break(oError)} )

	Begin Sequence

		If ( lRet := CheckAccess( Self, .F. ) )

			If !File(cCurDir + @{Param 2})//não chamar função de imagem caso se a logo da empresa não existir
				lRet := .T.
			Else
				lRet := fImage( Self, cCurDir + @{Param 2},lMingle )
			EndIf

			PrintPostLog( Self, lRet )

		EndIf
	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} EquipmentPicture
Realiza download de imagem do equipamento

@author	Maria Elisandra de Paula
@since 29/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET EquipmentPicture WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError

	printf('Metodo GET EquipmentPicture')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent()), lRet:= .F., Break(oError)} )

	Begin Sequence

		If ( lRet := CheckAccess( Self, .F. ) )

			lRet := fEquiPic( @{Param 3}, Self )
			PrintPostLog( Self, lRet )

		EndIf
	End Sequence

	ErrorBlock(bLastError)

Return lRet


//---------------------------------------------------------------------
/*/{Protheus.doc} WorkerPicture
Download da imagem do funcionário

@author	Maria Elisandra de Paula
@since 29/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET WorkerPicture WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError

	printf('Metodo GET WorkerPicture')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent()), lRet:= .F., Break(oError)} )

	Begin Sequence

		If ( lRet := CheckAccess( Self, .F. ) )

			lRet := WorkerPic( @{Param 3}, Self )
			PrintPostLog( Self, lRet )

		EndIf
	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} OrderPictureList
Retorna uma lista de imagens vinculadas a ordem de serviço

@author	Maria Elisandra de Paula
@since 29/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET OrderPictureList WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError

	printf('Metodo GET OrderPictureList')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent()), lRet:= .F., Break(oError)} )

	Begin Sequence

		If ( lRet := CheckAccess( Self, .F. ) )

			lRet := OrderPics( @{Param 2}, Self )
			PrintPostLog( Self, lRet )

		EndIf
	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} ObjectPicture
Realiza download de imagem recebendo o código do objeto

@author	Maria Elisandra de Paula
@since 29/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET ObjectPicture WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError

	printf('Metodo GET ObjectPicture')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent()), lRet:= .F., Break(oError)} )

	Begin Sequence

		If ( lRet := CheckAccess( Self, .F. ) )

			lRet := PicFromRepo( @{Param 2}, Self )
			PrintPostLog( Self, lRet )

		EndIf
	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} RequestPictureList
Retorna lista de imagens vinculadas a solicitação de serviço

@author	Maria Elisandra de Paula
@since 29/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod GET RequestPictureList WsService Mntng

	Local lRet := .T.
	Local bLastError
	Local oError

	printf('Metodo GET RequestPictureList')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent()), lRet:= .F., Break(oError)} )

	Begin Sequence

		If ( lRet := CheckAccess( Self, .F. ) )

			lRet := listImgSR( @{Param 2}, Self )
			PrintPostLog( Self, lRet )

		EndIf
	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} RequestOperation
 Realiza as operações que alteram a situação da solicitação de serviço
'distribute', 'finish', 'feedback'

@author Maria Elisandra de paula
@since 22/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD PUT RequestOperation PATHPARAM value, operation WsService Mntng

	Local aRet := {.T., ""}
	Local bLastError
	Local oError
	Local lRet  := .T.

	printf('Metodo PUT: RequestOperation ' + ::operation )

	/*O ErrorBlock logo abaixo tem controle de transação e deve ser usado da seguinte forma
	Begin Sequence
		...operações antes de abrir a empresa (sem controle de transação)
		Begin Transaction
		...operações após abrir a empresa (controle de transação)
			Recover
				DisarmTransaction()
		End Transaction
	End Sequence
	*/
	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ), lRet := .F., Break(oError) } )
	Begin Sequence

		If ( lRet := CheckAccess( Self ) )

			Begin Transaction

				aRet := NGUpsertSR( Self, ::operation , ::value )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet


//---------------------------------------------------------------------
/*/{Protheus.doc} Mntng/PUT
 Alterações na solicitação de serviço

@author Maria Elisandra de paula
@since 22/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WSMETHOD PUT RequestUpdate WsService Mntng

	Local aRet := {.T., ""}
	Local bLastError
	Local oError
	Local lRet  := .T.

	printf('Metodo PUT: RequestUpdate')

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ), lRet := .F., Break(oError) } )
	Begin Sequence

		If ( lRet := CheckAccess( Self ) )

			Begin Transaction

				aRet := NGUpsertSR( Self, "update", @{Param 2} )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} RequestRemove
Remove solicitação de serviço

@author Maria Elisandra de paula
@since 22/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod DELETE RequestRemove WsService Mntng

	Local aRet := {.T., ""}
	Local bLastError
	Local oError
	Local lRet := .T.

	printf('Metodo DELETE: Request')

	::ClearResponse()
	::SetContentType( 'application/json' )

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ), lRet := .F., Break(oError) } )
	Begin Sequence

		If ( lRet := CheckAccess( Self ) )

			Begin Transaction

				aRet := removeSR( Self, @{Param 2} )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} RequestPictureRemove
Remove imagem da solicitação de serviço

@author Maria Elisandra de paula
@since 22/11/2018
@version P12
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
WsMethod DELETE RequestPictureRemove WsService Mntng

	Local aRet := {.T., ""}
	Local bLastError
	Local oError
	Local lRet := .T.

	printf('Metodo DELETE: RequestPictureRemove')

	::ClearResponse()
	::SetContentType( 'application/json' )

	bLastError := ErrorBlock( { |oError| MntWSError( Self, oError, @{Header User}, ::GetContent() ), lRet := .F., Break(oError) } )
	Begin Sequence

		If ( lRet := CheckAccess( Self ) )

			Begin Transaction

				aRet := delImageSR( Self, @{Param 2} )
				lRet := PrintPostLog( Self, lRet, aRet )

			Recover
				DisarmTransaction()

			End Transaction

			CloseTransactions( aRet )

		EndIf

	End Sequence

	ErrorBlock(bLastError)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fInfoMINGL
Retorna informações da filial - mingle

@param oSelf, objeto, webservice
@author Maria Elisandra de paula
@since 18/04/2022
@return boolean, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
Static Function fInfoMINGL(oSelf)

	Local lRet      := .F.
	Local cError    := ''
	Local aResponse := {}
	Local cJsonResp := ''

	If Select('SM0') == 0 .Or. ;
		Type( 'cEmpAnt' ) != 'C' .Or.;
		Type( 'cFilAnt' ) != 'C' .Or.;
		Type( '__cUserId' ) != 'C' .Or.;
		Empty(cEmpAnt) .Or.;
		Empty(cFilAnt) .Or.;
		Empty(__cUserID)

		lRet   := .F.
		cError := STR0178 //"A requisição está inválida. A empresa/filial não foi aberta corretamente"

	Else

		If lRet := CheckAccess( oSelf, .T., .T. )

			If !fPreLogin(oSelf)
				Return .F.
			EndIf

			aResponse := fGetEnterp( {cEmpAnt + cFilAnt}, UsrRetName( cUserLog ), cUserLog, Trim( UsrRetMail( __cUserID ) ) ) 
			cJsonResp := JsonResult( FWJsonSerialize(aResponse, .F. ) )

			oSelf:SetContentType( 'application/json' )
			oSelf:SetStatus( 200 )
			oSelf:SetResponse( FwhttpEncode( cJsonResp ) )

			Printf("Login efetuado com sucesso")

		EndIf

	EndIf

	If !Empty(cError)
		lRet := .F.
		SetRestFault( 500, EncodeUtf8( cError ) )
		Printf(cError)
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fLicense
Abertura do ambiente

@author Maria Elisandra de paula
@param oWs, objeto, instância do webservice
@since 14/06/2022
@return string, vazio ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function fLicense( oWs )

	Local lFirstTime  := Select("SM0") == 0
	Local lRet        := .T.
	Local aUserPsw    := GetUserPsw( oWs )
	Local cEnterprise := oWs:GetHeader( 'enterprise' )
	Local cBranch     := oWs:GetHeader( 'branch' )

	If Empty( cEnterprise ) .Or. Empty( cBranch )
		Return STR0005 // "A Empresa e Filial devem ser preenchidas no portal."
	EndIf

	If ( lFirstTime .Or. ( AllTrim( cEnterprise ) != AllTrim( cEmpAnt ) .Or. AllTrim( cBranch ) != AllTrim( cFilAnt ) ) )
		Printf( '--------- Abertura da empresa: ' + cEnterprise + ' e filial: ' + cBranch + ' ---------' )
		RpcClearEnv()
		RpcSetType() // Utiliza licença
		lRet := RpcSetEnv( cEnterprise, cBranch, aUserPsw[1], aUserPsw[2], 'MNT', 'MNTNG', , , .F. )
		If !lRet
			Return STR0198 // "Não foi possível abrir o ambiente Protheus."
		EndIf
	EndIf

Return ''

//---------------------------------------------------------------------
/*/{Protheus.doc} GCSync
Garbage collector para os pacotes gerados na pasta temporária. Remove
todos os pacotes velhos e que não estão em uso, que passaram de um dia
para o outro quando já passamos da 01:00.

@author Marcelo Camargo
@since 07/2016
@return nil
/*/
//---------------------------------------------------------------------
Static Function GCSync
	Local cThreadId :=  AllTrim( Str( ThreadId() ) )
	Local aFiles := Directory( cCurDir + "tmp" + cBarra + cThreadId + cBarra + "*", "HSD" )
	Local nI
	Local cDate

	For nI := 1 To Len( aFiles )
		cDate := DToC( aFiles[ nI, 3 ] )
		FErase( cCurDir + "tmp" + cBarra + cThreadId + cBarra + aFiles[ nI, 1 ] )
	Next nI

	DirRemove(cCurDir + "tmp" + cBarra + cThreadId )

Return

//----------------------------------------------------------------------------------
/*/{Protheus.doc} DoSyncV1
Define quais entidades serão utilizadas para gerar o pacote de sync da versão 1

@author Maria Elisandra de Paula
@since 16/10/2018
@param oWS, objeto, webservice base
@param cDate, string, data referência para sincronizar.
@return array, [1] indica se obteve sucesso da operação, [2] vazio ou string de erro
/*/
//-----------------------------------------------------------------------------------
Static Function DoSyncV1( oWS, cDate )

	Local nI
	Local aMethods := {}
	Local aReturn := { .T. , ""}
	Local aMethodsV1 := {}
	Local cError := ValidSync( )

	If !Empty( cError )
		Return { .F., cError }
	EndIf

	//-------------------------------------------------------------------------------
	// Quando é para portal, enviar somente entidades que possuem filtro
	//-------------------------------------------------------------------------------
	If lPortalOrigin
		aMethods := { "sEquipment", "sFamily", "sCostCenter", "sArea", "sService", "sProduct", "sThirdPart", "sTool", "sLocation" }
	Else

		If lOrderPermission .And. lDBOrderOk

			//Entidades gerais para ordem de serviço
			aMethods := { 'sEquipment'  , 'sCostCenter', 'sOrder'     , 'sService'   ,;
						  'sCheckSO'    , 'sInputSO'   , 'sAnswer'    , 'sTask'      ,;
						  'sMaintenance', 'sPrevTask'  , 'sCheckMain' , 'sInputMain' ,;
						  'sProduct'    , 'sWarehouse' , 'sWorker'    , 'sThirdPart' ,;
						  'sTool'       , 'sChecklist' , 'sQuestion'  , 'sSpeciality' }

			//Finalização
			If aPermissions[ PERMISS_OS, 6 ] // finish_order
				aAdd( aMethods, "sFault" )
			EndIf

			// Ocorrências
			If aPermissions[ PERMISS_OS, 18 ] // ocurrences
				aAdd( aMethods, 'sOccurrences' )
				aAdd( aMethods, 'sExceptionFamily' )
				aAdd( aMethods, 'sAssociated' )
			EndIf

			// Localizações para O.S.
			If aPermissions[ PERMISS_OS, 19 ] // location_order
				aAdd( aMethods, "sLocation" )
			EndIf

		Else
			aMethods := {}
		EndIf

		If lRequestPermission .And. RequestIsOk()

			//Entidades gerais para solicitação de serviço
			If aScan( aMethods, "sEquipment" ) == 0
				aAdd( aMethods, "sEquipment" )
			EndIf
			aAdd( aMethods, "sRequest" )
			aAdd( aMethods, "sRequestOrders" )

			//Gerar OS
			If aPermissions[ PERMISS_SS, 5 ] // generate_ss_os
				aAdd( aMethods, "sWorkCenter" )

				If aScan( aMethods, "sCostCenter" ) == 0
					aAdd( aMethods, "sCostCenter" )
				EndIf

				If aScan( aMethods, "sService" ) == 0
					aAdd( aMethods, "sService" )
				EndIf
			EndIf

			//Incluir e editar
			If aPermissions[ PERMISS_SS, 1 ] ;       // create_ss
				.Or. aPermissions[ PERMISS_SS, 2 ] ; // edit_service_request
				.Or. aPermissions[ PERMISS_SS, 3 ]   // distribute_ss
				aAdd( aMethods, "sServiceType" )
				aAdd( aMethods, "sExecutor" )
			EndIf

			// Localização para S.S.
			If aPermissions[ PERMISS_SS, 6 ] .And. ; // location_ss
				aScan( aMethods, "sLocation" ) == 0
				aAdd( aMethods, "sLocation" )
			EndIf

		EndIf
	EndIf

	//--------------------------------------------------------------------
	//modifica a estrutura do o array para enviar data para cada entidade
	//--------------------------------------------------------------------
	For nI := 1 to Len( aMethods )
		aAdd( aMethodsV1, { aMethods[ nI ], cDate, "" } )
	Next nI

	//------------------------------------------------
	// gera o pacote tar.gz de acordo com aMethodsV1
	//------------------------------------------------
	aReturn := CreateTarGz( oWS, aMethodsV1 )

Return aReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} CreateTarGz
Inicia a sincronização e a construção de pacotes de todos os métodos.
Ao final, comprime-os e envia headers para forçar o download

@author Marcelo Camargo
@since 07/2016
@param oWS, objeto, webservice base
@param aMethods, array, nome das funções a serem executadas e data para parâmetro
@return array, [1] indica se obteve sucesso da operação, [2] vazio ou string de erro
/*/
//---------------------------------------------------------------------
Static Function CreateTarGz( oWS, aMethods )

	Local nI        := 0
	Local aGenFiles := { }
	Local aResult   := {}
	Local cSession  := GenFileName( 'session', .T. )
	Local cMsg      := IIf( aMethods[ 1, 2 ] == '0', 'completo', 'parcial' )

	//Funções jogadas para variaveis conforme explicação da função verifyFunction
	Local cTarCompress := "TarCompress"
	Local cGZCompress  := "GZCompress"
	Local aReturn      := { .T. , ""}
	Local cUserMail    := IIf( ValType( oWS:GetHeader( 'user' ) ) == 'C', oWS:GetHeader( 'user' ), Trim( UsrRetMail( __cUserID ) ) )

	printf( "-------------------------------------------------------------------" )
	printf( "Emp.: " + cEmpAnt + "   Fil.:" + cFilAnt  )
	printf( "Inicio geracao de pacote " + cMsg + " por " + cUserMail  )
	printf( 'DataBase: ' + Upper(AllTrim(TcGetDB())) + ' / Application Server em ' + IIf( isSRVunix(), 'Linux', 'Windows' ) + ;
		IIf( lPeMntNg, ' / Possui PE ', '/ Nao possui PE' ) )
	printf( "-------------------------------------------------------------------" )
	GCSync()

	For nI := 1 To Len( aMethods )

		aResult := &( aMethods[ nI,1 ] )( oWs, aMethods[ nI, 2 ] )

		If !aResult[ 1 ]
			printf( "Erro ao sincronizar " + aMethods[ nI ][ 1 ] +  ": " + aResult[ 2 ] )
			Return { .F., STR0124 + " " + aMethods[ nI ][ 1 ] +  ": " + aResult[ 2 ] } // "Erro ao sincronizar"
		EndIf

		//-------------------------------------------------------------
		// quando for data "0" não enviar os arquivos delete
		// quando for sRequestOrders não enviar os arquivos delete
		//-------------------------------------------------------------
		If aMethods[ nI, 2 ] <> "0" .And. aMethods[ nI,1 ] <> "sRequestOrders"
			aAdd( aGenFiles, aResult[ 2, 1 ] )
		EndIf

		aAdd( aGenFiles, aResult[ 2, 2 ] )
	Next nI

	&cTarCompress.(aGenFiles,cSession + ".tar")
	&cGZCompress.(cSession + ".tar",cSession + ".tar.gz")
	fDownload(oWS,cSession + ".tar.gz","sync.tar.gz", lMingle)

	// Após o download, tentamos limpar os próprios vestígios
	For nI := 1 To Len( aGenFiles )
		FErase( aGenFiles[ nI ] )
	Next nI

	FErase( cSession + ".tar" )
	FErase( cSession + ".tar.gz" )

	GCSync()

	printf( "-------------------------------------------------------------------" )
	printf("Fim geracao de pacotes por " + cUserMail )
	printf( "-------------------------------------------------------------------" )

Return aReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} GenFileName
Obtém o nome a ser usado para criação do buffer para armazenar os dados
de sincronização

@author Marcelo Camargo
@since 07/2016
@param cSalt, string, nome base do método a sincronizar
@param [lUnique], boolean, determina se somente um nome dinâmico será dado como saída
@return Array, [1]nome do arquivo delete
               [2]nome do arquivo update
/*/
//---------------------------------------------------------------------
Static Function GenFileName( cSalt, lUnique )

	Local cThreadId := AllTrim( Str( ThreadId() ) )
	Local cUUID := AllTrim( Str( Randomize( 0, 1000000 ) ) ) + ;
		AllTrim( Str( Randomize( 0, 1000000 ) ) )
	Local cFileBase := cCurDir + "tmp" + cBarra + cThreadId + cBarra + cSalt + "_" + cThreadId + cUUID + "_"

	Default lUnique := .F.

	If !ExistDir( cCurDir + "tmp" )
		MakeDir( cCurDir + "tmp" )
	EndIf

	If !ExistDir( cCurDir + "tmp" + cBarra + cThreadId )
		MakeDir( cCurDir + "tmp" + cBarra + cThreadId)
	EndIf

	If lUnique
		Return cFileBase
	EndIf

Return { cFileBase + "delete.json", cFileBase + "update.json" }

/**
 * Modelo de entidade (empresa + filial) e funcionário para autenticação no
 * Protheus.
 **/
Class MntEntity
	Data EnterpriseCode As Character
	Data EnterpriseName As Character
	Data BranchCode As Character
	Data BranchName As Character
	Data WorkerCode As Character
	Data WorkerName As Character
	Data Localization As Character
	Data FailureControl As Logical
	Data UseTask As Logical
	Data ObligatoryChecklist As Logical
	Data Speciality As Character
	Data Unity As Character
	Data ExecutorCode As Character
	Data ExecutorName As Character
	Data RequesterName As Character
	Data RequesterCode As Character
	Data MultipleOrders As Character
	Data Facilities As Character
	Data SurveyRequest As Character
	Data PreventiveForRequest As Character
	Data Specialties As array
	Data IsValidForRequest As Logical
	Data isValidForOrder As Logical
	Data customTimeOut As Character

	Method New() Constructor
EndClass

Method New() Class MntEntity

	::ExecutorCode   := ""
	::ExecutorName   := ""
	::RequesterName  := ""
	::RequesterCode  := ""
	::MultipleOrders := ""
	::Facilities     := ""
	::SurveyRequest  := ""
	::Specialties    := {}

Return Self

Class Branches
	Data EnterpriseCode As Character
	Data EnterpriseName As Character
	Data BranchCode As Character
	Data BranchName As Character
	Data Localization As Character

	Method New() Constructor

EndClass

Method New() Class Branches

	::EnterpriseCode := ''
	::EnterpriseName := ''
	::BranchCode     := ''
	::BranchName     := ''
	::Localization   := ''
	
Return Self

/**
 * Modelo de anexo de ordem de serviço
 **/
Class MntOrderAttachment
	Data Id As Character
	Data Type As Character
	Data Date As Character
	Data FileName As Character
	Data Path As Character
	Data IsOwner As Logical
	Method New() Constructor
EndClass

Method New( cId ) Class MntOrderAttachment
	::Id := cId
	::IsOwner := .T.
Return Self

//---------------------------------------------------------------------
/*/{Protheus.doc} MultiBranchLogin
Retorna informações do usuário e array de filiais a que tem acesso

@author Marcelo Camargo
@param  oSelf, objeto, instância do webservice
@since  24/01/2018
@return logic, se obteve sucesso no login
/*/
//---------------------------------------------------------------------
Static Function MultiBranchLogin( oSelf )

	Local cVersion    := ''
	Local cUserEmail  := ''
	Local cPass       := ''
	Local aInfoUser   := {}
	Local aInfoLogin  := {}
	Local cJsonResp   := ''
	Local aBranches   := {}
	Local cName       := ''
	Local cCodeUser   := ''

	If !fPreLogin(oSelf)
		Return .F.
	EndIf

	cUserEmail := oSelf:GetHeader( 'user' )
	cPass      := oSelf:GetHeader( 'password' )
	cVersion   := oSelf:GetHeader( 'version' )
	Printf( 'App version ' + cVersion )

	StartStatics( oSelf ) //inicializa variáveis static

	Printf( "Origem login " + IIf( !lPortalOrigin, "App", "Portal" ) + '-licenca: ' + IIf(lMingle, 'MINGLE', 'MNT'))

	//--------------------------------------------------------------------
	//Validação abaixo para não acessar empresa/filial desnecessariamente
	//--------------------------------------------------------------------
	If !lPortalOrigin .And. !lOrderPermission .And. !lRequestPermission
		SetRestFault( 400, EncodeUtf8( STR0150 ) ) //"As permissões do grupo de usuário não estão definidas no portal mobile"
		Return .F.
	EndIf

	//--------------------------------
	//Recupera informações do usuário
	//--------------------------------
	aInfoLogin := GetInfoLogin( cUserEmail, cPass, .F., oSelf )

	If !aInfoLogin[1]
		SetRestFault( 403, EncodeUtf8(aInfoLogin[2] ) )
		Return .F.
	Else
		aBranches := aInfoLogin[2]
		aInfoUser := aInfoLogin[3]
	EndIf

	cName := NGEscape( aInfoUser[ 1, 4 ], .T. )
	cCodeUser := aInfoUser[ 1, 1 ]

	If lMingle

		Printf("Iniciando thread filiais")
		cJsonResp := StartJob( 'MNTNBRNCHS', GetEnvserver(), .T.,;
					aBranches, { lPortalOrigin, lOrderPermission,;
					lRequestPermission, lDBOrderOk, lDBRequestOk, aPermissions } )

		Printf("Finalizando thread filiais  ")

	Else
		If lPortalOrigin .Or. fVersion( cVersion, '1.10.7' )
			cJsonResp := fBranches( aBranches ) // retorna json com lista nome e código das filiais
		Else
			cJsonResp := fGetEnterp( aBranches, cName, cCodeUser, cUserEmail ) // retorna json com informações completas filiais
		EndIf

		cJsonResp := FWJsonSerialize(cJsonResp , .F. )

	EndIf

	oSelf:SetContentType( 'application/json' )
	oSelf:SetStatus( 200 )
	oSelf:SetResponse( cJsonResp )

	Printf("Login efetuado com sucesso")

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fPreLogin
Validações de login

@author Maria Elisandra de Paula
@param  oSelf, objeto, instância do webservice
@since  18/04/2022
@return boolean, se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function fPreLogin(oSelf)

	//----------------------------------------------
	// Tratativa para considerar header válido
	//----------------------------------------------
	If ( ValType( oSelf:GetHeader( 'version' ) ) != 'C' )

		SetRestFault( 400, EncodeUtf8( STR0147 ) ) // Requisição inválida'
		Printf( 'Requisicao invalida' )
		Return .F.
	
	EndIf

	If !fVersion( oSelf:GetHeader( 'version' ) ) // Valida versão do App x Web Service

		Printf( 'O aplicativo está desatualizado!' )
		SetRestFault( 400, EncodeUtf8( STR0080 ) ) // O aplicativo está desatualizado. Atualize-o para a última versão disponível.
		Return .F.

	EndIf

	If !fVerFontes()
		Return .F.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fVerFontes
Verifica se fontes estão atualizados

@author Maria Elisandra de Paula
@since  29/06/2022
@return boolean, se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function fVerFontes()

	Local aVersion := { { 'NGMNT00.prx'          , sToD( '20200104' ), '07:00' },;
						{ 'MNTUTIL01.prw'        , sToD( '20200104' ), '07:00' } }

	//------------------------------------------------------------
	// Verifica compatibilidade de fontes para processo de insumos
	//------------------------------------------------------------
	If !NgVldRpo( aVersion )

		/*
			Algumas rotinas dependentes para o correto funcionamento do aplicativo MNTNG encontra-se desatualizadas, sendo elas: ( XXXXXX ). ##
			Atualize-as para a última versão disponível.
		*/
		SetRestFault( 400, EncodeUTF8( STR0163 + ' ( MNTUTIL01, NGWSUTIL e NGMNT00 ). ' + STR0171 ) )
		Return .F.

	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTNBRNCHS
Job que retorna filiais válidas para o usuário

@author Maria Elisandra de Paula
@param aBranches, array, filiais para validação
@param aMainStatics, array, variáveis statics
@since  18/04/2022
@return string, json de filiais
/*/
//---------------------------------------------------------------------
Function MNTNBRNCHS( aBranches, aMainStatics )

	Local cJsonResp := ""

	lPortalOrigin      := aMainStatics[1]
	lOrderPermission   := aMainStatics[2]
	lRequestPermission := aMainStatics[3]
	lDBOrderOk         := aMainStatics[4]
	lDBRequestOk       := aMainStatics[5]
	aPermissions       := aMainStatics[6]
	lMingle            := .T.

	cJsonResp := fBranches( aBranches )

	cJsonResp := FWJsonSerialize(cJsonResp , .F. )

Return cJsonResp

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetEnterp
Retorna informações de todas as filiais a que o usuário tem permissão de acesso

@author Maria Elisandra de Paula
@param aBranches, array, filiais para validação
@param cName, string, nome de autenticação protheus
@param cCodeUser, string, usuário para autenticação
@param cUserEmail, string, email para autenticação
@since  18/04/2022
@return array, filiais
/*/
//---------------------------------------------------------------------
Static Function fGetEnterp( aBranches, cName, cCodeUser, cUserEmail )

	Local nIndex
	Local oEntity
	Local cEnterprise := ''
	Local cBranch     := ''
	Local cAuxiliar   := ''
	Local aResponse   := {}

	// Info: Conteudo de cada linha do array aBranches é no formato "T3M RJ 02 "
	For nIndex := 1 To Len( aBranches )

		cEnterprise := SubStr( aBranches[nIndex], 1, 2 ) // M0_CODIGO (Ex: T3)
		cBranch := SubStr( aBranches[nIndex], 3    ) // M0_CODFIL (Ex: M SP 01 )

		//-------------------------------------------------------------
		//Validação abaixo para não acessar filiais desnecessariamente
		//-------------------------------------------------------------
		If cEnterprise == cAuxiliar .And. !lDBOrderOk
			If lPortalOrigin .Or.; // Origem portal só precisa de campos de ordem de serviço
				( !lPortalOrigin .And. lOrderPermission .And. !lRequestPermission ) // tem permissão apenas para ordem de serviço
				cAuxiliar := cEnterprise
				Loop
			EndIf
		EndIf

		// Abre Empresa/Filial
		If !ConfigEnv2( cEnterprise, cBranch )
			Printf( "Configuracao do ambiente nao realizada" )
			cAuxiliar := cEnterprise
			Loop
		EndIf

		//---------------------------------
		//Inicio das validações de ambiente
		//---------------------------------
		If lPortalOrigin
			//------------------------------------------------------------------
			//Para login do portal deve ter obrigatoriamente os campos de ordem
			//------------------------------------------------------------------
			If !lDBOrderOk
				cAuxiliar := cEnterprise
				Loop
			EndIf
		Else
			//----------------------------------------------------------------------------------
			//Verifica se possui pelo menos uma das configurações válidas: ordem ou solicitação
			//----------------------------------------------------------------------------------
			If !lDBOrderOk .And. !RequestIsOk( )
				Printf( cEnterprise + cBranch + " as configuracoes nao foram realizadas." )
				cAuxiliar := cEnterprise
				Loop
			EndIf

			//----------------------------------------------------
			// Quando tem permissão apenas para ordem de serviço
			//----------------------------------------------------
			If lOrderPermission .And. !lRequestPermission .And. !lDBOrderOk
				Printf( cEnterprise + cBranch + " nao possui os campos de usuario para ordem de servico." )
				cAuxiliar := cEnterprise
				Loop
			EndIf

			//----------------------------------------------------------
			// Quando tem permissão apenas para solicitação de serviço
			//----------------------------------------------------------
			If lRequestPermission .And. !lOrderPermission .And. !RequestIsOk( )
				Printf( cEnterprise + cBranch + " nao esta configurada para solicitações no app MNTNG." )
				cAuxiliar := cEnterprise
				Loop
			EndIf

		EndIf

		cAuxiliar := cEnterprise

		oEntity := fGetInfo(cEnterprise, cBranch, cCodeUser, cName, cUserEmail)

		aAdd( aResponse, oEntity )

	Next nIndex

Return aResponse

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetInfo
Retorna informações de uma filial

@author Maria Elisandra de Paula
@param cEnterprise, string, código do grupo
@param cBranch, string, código da filial
@param cCodeUser, string, usuário para autenticação
@param cName, string, nome do usuário
@param cUserEmail, string, email para autenticação
@since 28/06/2022
@return objeto com informações da filial
/*/
//---------------------------------------------------------------------
Static Function fGetInfo(cEnterprise, cBranch, cCodeUser, cName, cUserEmail)
	
	Local cAliasQry  := ''
	Local cNgTimeOut := ''
	Local oEntity    := MntEntity():New()

	oEntity:EnterpriseCode      := cEnterprise
	oEntity:BranchCode          := cBranch
	oEntity:EnterpriseName      := Alltrim( FWGrpName( cEnterprise ) )
	oEntity:BranchName          := FWFilName( cEnterprise, cBranch )
	oEntity:Localization        := oEntity:EnterpriseName + ' / ' + oEntity:BranchName
	oEntity:FailureControl      := SuperGetMv( 'MV_NGTNDFL', .F., 'S' ) == 'S'
	oEntity:UseTask             := SuperGetMv( 'MV_NGTARGE', .F., '2' ) == '1'
	oEntity:ObligatoryChecklist := SuperGetMv( 'MV_NGETAEX', .F., '1' ) == '1'
	oEntity:Unity               := SuperGetMv( 'MV_NGUNIDT', .F., 'S' )
	oEntity:RequesterName       := NGEscape( cName, .T. )
	oEntity:RequesterCode       := cCodeUser
	oEntity:MultipleOrders      := SuperGetMv( 'MV_NGMULOS', .F., 'S' ) == 'S'
	oEntity:Facilities          := SuperGetMv( 'MV_NG1FAC', .F., '2') == '1'
	oEntity:SurveyRequest       := SuperGetMv( 'MV_NGPSATI', .F., 'N') == 'S'
	oEntity:PreventiveForRequest := SuperGetMv( 'MV_NGSSPRE', .F., 'N') == 'S'
	oEntity:IsValidForRequest   := RequestIsOk()
	oEntity:isValidForOrder     := lDBOrderOk

	cNgTimeOut := SuperGetMV( 'MV_NGTIME', .F., '' )

	If !Empty( cNgTimeOut )
		oEntity:customTimeOut := cNgTimeOut
	EndIf

	/*
		Informações destinadas a utilização de rotas acionadas pelo mobile. Não há necessidade desta informações
		para rotas vindas do portal.
	*/
	If !lPortalOrigin

		cAliasQry := GetNextAlias()

		BeginSql Alias cAliasQry
			SELECT T1.T1_CODFUNC, T1.T1_CODUSU, T1.T1_NOME, T0.T0_NOME
			FROM %table:ST1% T1
			LEFT OUTER JOIN %table:ST2% T2 ON
				T2.T2_CODFUNC = T1.T1_CODFUNC AND
				T2.T2_FILIAL = %xFilial:ST2% AND
				T2.%NotDel%
			LEFT OUTER JOIN %table:ST0% T0 ON
				T0.T0_ESPECIA = T2.T2_ESPECIA AND
				T0.T0_FILIAL = %xFilial:ST0% AND
				T0.%NotDel%
			WHERE
				UPPER(T1.T1_EMAIL) = %exp:Upper( cUserEmail )% AND
				T1.T1_FILIAL = %xFilial:ST1% AND
				T1.%NotDel%
		EndSql

		//---------------------------------------------------------
		// Informações de vínculo com funcionário da manutenção
		//---------------------------------------------------------
		If !(( cAliasQry )->( EoF() ))
			oEntity:WorkerCode := ( cAliasQry )->T1_CODFUNC
			oEntity:WorkerName := AllTrim( Capital( ( cAliasQry )->T1_NOME ) )
			oEntity:Speciality := STR0011 // "Sem especialidade"
			If !Empty( ( cAliasQry )->T0_NOME )
				oEntity:Speciality := AllTrim( Capital( ( cAliasQry )->T0_NOME ) )
			EndIf

			oEntity:Specialties := fSpecialties(( cAliasQry )->T1_CODFUNC)

		EndIf
		( cAliasQry )->( dbCloseArea() )

		//---------------------------------------------------------
		// Informações de vínculo com executante de solicitação
		//---------------------------------------------------------
		cAliasQry := GetNextAlias()
		BeginSql Alias cAliasQry
			SELECT TQ4_CDEXEC, TQ4_NMEXEC
			FROM %table:TQ4% TQ4
			WHERE UPPER(TQ4.TQ4_EMAIL1) = %exp:Upper( cUserEmail )%
				AND TQ4.TQ4_FILIAL = %xFilial:TQ4%
				AND TQ4.%NotDel%
		EndSql

		If !(( cAliasQry )->( EoF() ))
			oEntity:ExecutorCode := Alltrim(( cAliasQry )->TQ4_CDEXEC)
			oEntity:ExecutorName := AllTrim( Capital( ( cAliasQry )->TQ4_NMEXEC ) )
		EndIf
		( cAliasQry )->( dbCloseArea() )

	EndIf

Return oEntity

//---------------------------------------------------------------------
/*/{Protheus.doc} OrderPics
Traz informações do banco de conhecimento sobre as imagens vinculadas a
uma ordem de serviço, incluindo se corresponde ao corpo da ordem ou à
finalização.

@author Marcelo Camargo
@since  11/01/2018
@param  cOrder, string, código da ordem de serviço
@param  oSelf, objeto, instância do webservice
@return logic, se obteve sucesso na operação
/*/
//---------------------------------------------------------------------
Static Function OrderPics( cOrder, oSelf )

	Local cSolic    := ''
	Local aResponse := {}

	// Exige existência da ordem de serviço
	dbSelectArea( 'STJ' )
	dbSetOrder( 1 )
	If !dbSeek( xFilial( 'STJ' ) + cOrder )
		Return .F.
	EndIf

	cSolic := STJ->TJ_SOLICI

	aResponse := fListImg( cOrder, 'STJ' )

	If !Empty( cSolic )
		aResponse := fListImg( cSolic, 'TQB', aResponse, .F. )
	EndIf

	oSelf:SetContentType( 'application/json' )
	oSelf:SetStatus( 200 )
	oSelf:SetResponse( FWJsonSerialize( aResponse, .F. ) )

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fListImg
Retorna lista de imagens da SS ou OS

@author Maria Elisandra de Paula
@since 05/07/2022
@param cKey, string, chave para buscar entidade
@param cTable, string, tabela de ss ou os
@param aListiIni, array, lista inicial
@param lIsOwner, boolean, utilizado para o app identificar se a imagem 
pertence à entidade solicitada pois uma OS pode apresentar uma imagem de uma SS
@return array, lista de imagens em objeto 
/*/
//---------------------------------------------------------------------
Static Function fListImg( cKey, cTable, aListIni, lIsOwner )

	Local cAliasQry := GetNextAlias()
	Local aResponse := {}
	Local oAttachment
	Local cCodEnt   := '% ( AC9.AC9_CODENT = ' + ValtoSql(cKey) + ;
	IIf(cTable == 'TQB', ' OR AC9.AC9_CODENT = ' + ValtoSql( xFilial('TQB') +cKey ) , '') + ')%'  // em alguns casos foi gravado chave com filial

	Default aListIni := {}
	Default lIsOwner := .T.

	aResponse := aListIni

	BeginSql Alias cAliasQry
		SELECT ACB.ACB_CODOBJ, ACB.ACB_OBJETO, ACB.ACB_DESCRI
		FROM %table:AC9% AC9
		INNER JOIN %table:ACB% ACB
			ON ACB.ACB_CODOBJ = AC9.AC9_CODOBJ
		WHERE
			AC9.AC9_FILIAL = %xFilial:AC9% AND
			ACB.ACB_FILIAL = %xFilial:ACB% AND
			AC9.AC9_ENTIDA = %exp:cTable% AND
			%exp:cCodEnt% AND
			AC9.%NotDel% AND
			ACB.%NotDel% AND
			RTRIM(SUBSTRING(ACB.ACB_DESCRI, 1, 8)) IN ('PROBLEM', 'SOLUTION', 'SIGNATUR')
	EndSql

	While !(( cAliasQry )->( EoF() ))

		oAttachment := MntOrderAttachment():New( ( cAliasQry )->ACB_CODOBJ )
		oAttachment:Type     := AllTrim( Lower( SubStr( ( cAliasQry )->ACB_DESCRI, 1, 8 ) ) )
		oAttachment:Date     := AllTrim( SubStr( ( cAliasQry )->ACB_DESCRI, 9 ) )
		oAttachment:FileName := AllTrim( ( cAliasQry )->ACB_OBJETO )
		oAttachment:Path     := '/picture/' + oAttachment:FileName
		oAttachment:IsOwner  := lIsOwner
		aAdd( aResponse, oAttachment )

		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )
Return aResponse

//---------------------------------------------------------------------
/*/{Protheus.doc} PicFromRepo
Recebe o objeto em formato Base64 e retorna a imagem corresponde a ele
do banco de conhecimento

@author Marcelo Camargo
@since  12/01/2018
@param  cObject, string, código do objeto gravado na ACB
@param  oSelf, objeto, instância do webservice
@return logic, se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function PicFromRepo( cObject, oSelf )

	Local cMsDocPath := If(isSRVunix(), Lower(StrTran( MsDocPath(),'\', '/')),MsDocPath())
	Local cFilePath  := cMsDocPath + cBarra + cObject
	If File( cFilePath )
		fImage( oSelf, cFilePath,lMingle )
	ElseIf File( cFilePath + '.jpg' )
		// Fallback para extensão implícita
		fImage( oSelf, cFilePath + '.jpg',lMingle )
	Else
		Return .F.
	EndIf
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} WorkerPic
Retorna a imagem do funcionário na ST1

@author	Larissa Thaís de Farias
@since 02/2016
@param cEmail, string, email do usuário
@param oSelf, objeto, objeto do WS
@return logic, se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function WorkerPic( cEmail, oSelf )
	Local cQuery
	Local cAliasQry := GetNextAlias()
	Local cWorker := ""
	Local cBitmap := ""
	Local cFile := ""
	Local nFolder := 0

	printf( "Sync Foto do funcionário. " + DTOC(dDataBase) + " " + Time() + " - " + cEmail )

	cQuery := "SELECT T1_CODFUNC, T1_BITMAP FROM " + RetSQLName( "ST1" )
	cQuery += "WHERE UPPER(T1_EMAIL) = '" + Upper(cEmail) + "' AND T1_FILIAL = '" + xFilial( "ST1" )
	cQuery += "' AND D_E_L_E_T_ = ' '"
	cQuery := ChangeQuery( cQuery )

	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T. )

	cWorker := AllTrim( (cAliasQry)->T1_CODFUNC )
	cBitmap := (cAliasQry)->T1_BITMAP

	(cAliasQry)->( dbCloseArea() )

	If !Empty( cBitmap )

		If !ExistDir( cCurDir + "worker" )
			nFolder := MakeDir( cCurDir + "worker" )
			If nFolder != 0
				printf( "Não foi possível criar a pasta worker." )
			EndIf
		EndIf

		cFile := cCurDir + "worker" + cBarra + cWorker + ".jpg"

		// Se não existir em cache, extraímos novamente
		If !File( cFile )
			StartJob( 'ExtractBitmap', GetEnvServer(), .T., cBitmap, cFile, cEmpAnt, cFilAnt )
		EndIf
	Else
		printf("Funcionário " + cEmail + " não possui foto.")
	EndIf

	If !Empty(cFile)
		printf( "Foto do funcionário sincronizada. " + DTOC(dDataBase) + " " + Time() + " - " + cEmail + " em: " + cFile )
	EndIf
Return If( Empty(cFile), .T., fImage( oSelf, cFile,lMingle ) )

//---------------------------------------------------------------------
/*/{Protheus.doc} QFault
Query para irregularidades

@autor Maria Elisandra de Paula
@since 10/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de irregularidades
/*/
//---------------------------------------------------------------------
Static Function QFault( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("TP7_MSBLQL","A","TP7",.F.)
	Local cQuery := "SELECT TP7.TP7_CODIRE, TP7.TP7_NOME, "

	cQuery += " CASE "
	cQuery += " WHEN TP7.D_E_L_E_T_ = ' ' THEN 'FALSE' "
	cQuery += " Else 'true' "
	cQuery += " END AS IS_DELETED, "

	If lBlock
		cQuery += " CASE WHEN TP7.TP7_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
	Else
		cQuery += " '' AS BLOCKED "
	EndIf

	cQuery += " FROM " + RetSQLName('TP7') + " TP7 "
	cQuery += " WHERE TP7.TP7_FILIAL = " + ValToSql( xFilial("TP7") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TP7_USERGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TP7_USERGI" ) + " >= " + ValtoSql( cDate ) + ")"
	Else
		cQuery += " AND TP7.D_E_L_E_T_ = ' '"
	EndIf

	If lBlock
		cQuery += " AND TP7.TP7_MSBLQL <> '1' "
	EndIf

	cQuery := ChangeQuery(cQuery)

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sFault
Gera um JSON contendo as informações de Irregularidades para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sFault( oWs, cDate )

	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
    Local nCount    := 0
    Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := QFault( oWs, cDate, "sFault" )
	Local cAliasQry := GeraTemp( cQuery, 'Fault' )

	aFileName := GenFileName( 'fault' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F. , STR0017 + " " + AllTrim( Str( FError() ) ) }//"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{"code":"' + NGEscape( ( cAliasQry )->TP7_CODIRE ) + '",'
			cSubJSON += '"name":"' + NGEscape( ( cAliasQry )->TP7_NOME , .T. ) + '"}'
			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( ( cAliasQry )->TP7_CODIRE ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sFault: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QEquipment
Query para equipamentos

@autor Maria Elisandra de Paula
@since 04/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@param lWhere, boolean, se busca somente a string de condição where da query
@return string, query de equipamentos
/*/
//---------------------------------------------------------------------
Static Function QEquipment( oWs, cDate, cOrigin, lWhere )

	Local aEquipment:= IIf( ValType( oWS:GetHeader( 'equipment' ) ) == "C", StrTokArr( oWS:GetHeader( 'equipment' ) , "|"), {} )
	Local cIsNull   := IIf( Upper(AllTrim(TcGetDB())) == "ORACLE","NVL",IIf( Upper(AllTrim(TcGetDB())) $ "DB2","COALESCE","ISNULL" ) )
	Local cQuery    := "SELECT ST9.T9_CODBEM "
	Local lFieldTaf := NGCADICBASE( 'TAF_USERGI', 'A', 'TAF', .F. ) .And. NGCADICBASE( 'TAF_USERGA', 'A', 'TAF', .F. )
	Local lBlock    := NGCADICBASE("T9_MSBLQL","A","ST9",.F.)
	Local cFilter   := ''
	Local cWhere    := ''

	Default lWhere := .F.

	If cOrigin == "sEquipment"

		cQuery += ", ST9.T9_NOME, ST9.T9_CCUSTO, ST9.T9_BARCODE, T9_LOCAL, " + IIf( !lPortalOrigin .And. aPermissions[ PERMISS_OS, 18 ], ' ST9.T9_CODFAMI, ', '' ) // ocurrences
		//Busca data e hora do último apontamento de contador
		cQuery += cIsNull + "((SELECT MAX(TP_DTLEITU || '' || TP_HORA) "
		cQuery += "   FROM " + RetSQLName('STP') + " STP "
		cQuery += "   WHERE STP.D_E_L_E_T_ = ' ' "
		cQuery += "     AND TP_FILIAL =  " + ValToSql(xFilial("STP"))
		cQuery += "     AND TP_CODBEM = ST9.T9_CODBEM) , '')  AS DTHRCOUNT , "

		//Busca data e hora do último apontamento do SEGUNDO contador
		cQuery += cIsNull + "((SELECT MAX(TPP_DTLEIT || '' || TPP_HORA) "
        cQuery += "   FROM " + RetSQLName('TPP') + " TPP "
        cQuery += "   WHERE TPP.D_E_L_E_T_ = ' ' "
        cQuery += "     AND TPP_FILIAL =  " + ValToSql(xFilial("TPP"))
		cQuery += "     AND TPP_CODBEM = ST9.T9_CODBEM), '') AS DTHRCOUNT2 , "

		cQuery += cIsNull + "(CTT_DESC01,'') AS CCNAME,"
		cQuery += cIsNull + "(HB_NOME,'') AS CTNAME,"
		cQuery += cIsNull + "(TPE_TPCONT,'') TPE_TPCONT,"
		cQuery += cIsNull + "(TPE_POSCON,0) TPE_POSCON,"
		cQuery += cIsNull + "(TPE_LIMICO,0) TPE_LIMICO,"
		cQuery += cIsNull + "(T9_POSCONT,0 ) T9_POSCONT,"
		cQuery += cIsNull + "(T9_TPCONTA,'') T9_TPCONTA,"
		cQuery += cIsNull + "(T9_DTULTAC,'') T9_DTULTAC,"
		cQuery += cIsNull + "(T9_LIMICON,0)  T9_LIMICON,"
		cQuery += " T9_TEMCONT,"
		cQuery += " T9_CENTRAB,"
		cQuery += " ST9.T9_ESTRUTU,"

		cQuery += "CASE "
		cQuery += "    WHEN ST9.D_E_L_E_T_ = ' ' THEN 'FALSE' "
		cQuery += "Else "
		cQuery += "    'true' "
		cQuery += "END AS IS_DELETED, "

		cQuery += "CASE "
		cQuery += 	"WHEN ST9.T9_BITMAP = ' ' THEN 'FALSE' "
		cQuery += "ELSE "
		cQuery += 	"'TRUE' "
		cQuery += "END AS HASIMAGE,"

		If lBlock
			cQuery += " CASE WHEN ST9.T9_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += "'' AS BLOCKED "
		EndIf

	EndIf

	cQuery += "FROM " + RetSQLName( 'ST9' ) + " ST9 "
	cQuery += " INNER JOIN " + RetSQLName( 'CTT' ) + " CTT "
	cQuery += "    ON CTT_CUSTO = T9_CCUSTO AND " + QCostCenter( oWs, '0', '' , .T. )

	cQuery += "LEFT JOIN " + RetSQLName( 'SHB' ) + " SHB ON HB_COD = T9_CENTRAB "
	cQuery += "     AND SHB.D_E_L_E_T_ = ' ' AND HB_FILIAL = " + ValToSql( xFilial( "SHB" ) )

	cQuery += "  LEFT JOIN " + RetSQLName('TPE') + " TPE"
	cQuery += "    ON TPE_CODBEM = T9_CODBEM"
	cQuery += "     AND TPE.D_E_L_E_T_ = ' ' "
	cQuery += "     AND TPE_FILIAL = " + ValToSql(xFilial("TPE"))

	cQuery += "  INNER JOIN " + RetSQLName('ST6') + " ST6  "
	cQuery += " 	ON  ST6.T6_CODFAMI = ST9.T9_CODFAMI AND " + QFamily( oWs, '0', '', .T. )

	cQuery += " WHERE "

	cWhere += " ST9.T9_FILIAL = " + ValtoSql( xFilial('ST9') )
	cWhere += " AND T9_SITMAN = 'A' AND T9_SITBEM = 'A' "
	cWhere += makeFilter( aEquipment, "ST9.T9_CODBEM" )

	If cDate != "0"

		cWhere += " AND (" + dateQuery( "T9_USERLGA" ) + " >= " + ValtoSql( cDate )
		cWhere += " OR " + dateQuery( "T9_USERLGI" ) + " >= " + ValtoSql( cDate )

		//------------------------------------------------
		// verifica se houve alteração na taf do bem
		//------------------------------------------------
		If lFieldTaf
        	cWhere += " OR ( "
            cWhere += " SELECT COUNT( TAF.TAF_CODCON ) ARVORE "
			cWhere += " FROM " + RetSQLName( 'TAF' ) + " TAF "
			cWhere += " WHERE TAF.TAF_CODCON = ST9.T9_CODBEM "
			cWhere += "     AND TAF.TAF_INDCON = '1' "
			cWhere += "     AND TAF.TAF_FILIAL = " + ValToSql( xFilial( 'TAF') )
			cWhere += "     AND TAF.TAF_MODMNT = 'X' "
			cWhere += "     AND (" + dateQuery( "TAF_USERGA" ) + " >= " + ValtoSql( cDate )
			cWhere += "         OR " + dateQuery( "TAF_USERGI" ) + " >= " + ValtoSql( cDate ) + " ) ) > 0"
		EndIf

		cWhere += " ) "

	Else
		cWhere += " AND ST9.D_E_L_E_T_ = ' '"
	EndIf

	If lPortalOrigin .And. lBlock
		cWhere += " AND ST9.T9_MSBLQL <> '1' "
	EndIf

	If lPeMntNg
		cFilter := ExecBlock("MNTNG",.F.,.F.,{"FILTER_EQUIPMENT",oWS})
		If !Empty(cFilter)
			cWhere += cFilter
		EndIf
	EndIf

	If lWhere
		cQuery := cWhere
	Else
		cQuery += cWhere
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sEquipment
Gera um JSON contendo as informações de Equipamento para a sincronização
com o aplicativo Mobile

Filtros:
equipamento
família
centro de custo

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sEquipment( oWS, cDate )

	Local cLocTree    := ""
	Local aFileName   := {}
	Local lFirst      := .T.
	Local lFirstD     := .T.
    Local nCount      := 0
    Local cHrIn       := Time()
	Local nDelete     := 0
	Local nUpdate     := 0
	Local cSubJSON    := ""
	Local lOcurrences := !lPortalOrigin .And. aPermissions[ PERMISS_OS, 18 ] // ocurrences
	Local lDbMSSQL    := "MSSQL" $ Upper(AllTrim(TcGetDB()))
	Local cQuery      := ChangeQuery( QEquipment( oWS, cDate, "sEquipment" ) )
	Local cAliasQry   := GeraTemp( cQuery, 'Equipment' )

	aFileName := GenFileName( 'equipment' )

	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->T9_CODBEM, .T. ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->T9_NOME,.T. ) + '",'
			cSubJSON += '"costCenterCode":"' + NGEscape( (cAliasQry)->T9_CCUSTO, .T.  ) + '",'
			cSubJSON += '"costCenterName":"' + NGEscape( (cAliasQry)->CCNAME , .T. ) + '",'
			cSubJSON += '"barCode":"'        + NGEscape( (cAliasQry)->T9_BARCODE , .T. ) + '",'
			cSubJSON += '"workCenterName":"' + NGEscape( (cAliasQry)->CTNAME , .T. ) + '",'
			cSubJSON += '"workCenterCode":"' + NGEscape( (cAliasQry)->T9_CENTRAB , .T. ) + '",'

			If lOcurrences
				cSubJSON += '"familyCode":"' + NGEscape( (cAliasQry)->T9_CODFAMI , .T. ) + '",'
			EndIf

			// Caso o equipamento possua imagem vinculada ao seu cadastro, envia a flag hasImage.
			If Alltrim( (cAliasQry)->HASIMAGE ) == 'TRUE'
				cSubJSON += '"hasImage":true,'
			EndIf

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cLocTree := ""

			// Ponto de entrada para buscar localização por customização do cliente
			If lPeMntNg
				cLocTree := ExecBlock("MNTNG",.F.,.F.,{"DESCRIPTION_LOCALIZATION",oWS, (cAliasQry)->T9_CODBEM })
			EndIf

			//---------------------------------------------------------
			// Busca localização do bem
			//---------------------------------------------------------
			If Empty( cLocTree )
				If lDbMSSQL
					cLocTree := Localization( (cAliasQry)->T9_CODBEM )
				Else
					cLocTree := NGLocComp( (cAliasQry)->T9_CODBEM, '1' )
				EndIf

				If Empty( cLocTree ) .or. AllTrim( cLocTree )  == Alltrim( (cAliasQry)->T9_CODBEM )
					cLocTree := AllTrim( (cAliasQry)->T9_LOCAL )
				EndIf

			EndIf

			cSubJSON += '"localization":"' + NGEscape( cLocTree , .T.  ) + '"'

			// Caso tenha contador irá criar mais um vetor para armazenar os dados de contador
			If (cAliasQry)->T9_TEMCONT == "S"
				cSubJSON += ',"counter":[{'
	      		cSubJSON += '"name":"'    + NGEscape((cAliasQry)->T9_TPCONTA)   + '",'
				cSubJSON += '"value":'    + cValtoChar((cAliasQry)->T9_POSCONT) + ','
				cSubJSON += '"limit":'    + Substr(cValtoChar((cAliasQry)->T9_LIMICON), 0,9) + ','
				cSubJSON += '"datetime":"'+ NGEscape((cAliasQry)->DTHRCOUNT) + '"}'

	      		//caso tenha segundo contador
	      		If (cAliasQry)->TPE_POSCON > 0
		      		cSubJSON += ',{"name":"'    + NGEscape((cAliasQry)->TPE_TPCONT)   + '",'
					cSubJSON += '"value":'    + cValtoChar((cAliasQry)->TPE_POSCON) + ','
					cSubJSON += '"limit":'    + Substr(cValtoChar((cAliasQry)->TPE_LIMICO),0,9) + ','
					cSubJSON += '"datetime":"'+ NGEscape((cAliasQry)->DTHRCOUNT2) + '"}'
				EndIf

				cSubJSON += ']'

			// Caso possua controle de contador definido pelo pai imediato ou da estrutura.
			ElseIf (cAliasQry)->T9_TEMCONT $ 'P#I' .And. (cAliasQry)->T9_ESTRUTU == 'S'

				// Envia neste chave o número de contadores que controlam o equipamento.
				cSubJSON += ',"finishOrderCounters":' + cValToChar( IIf( (cAliasQry)->TPE_POSCON > 0, 2, 1 ) )

			EndIf

			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->T9_CODBEM, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )

	printf("sEquipment: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QLocation
Query para localizações (TAF).
@type function

@autor Wexlei Silveira
@since 17/12/2020

@param oWS    , objeto  , Referência ao webservice
@param cDate  , caracter, Data da última sincronização
@param cOrigin, caracter, Função origem da chamada (utilizado para não entrar em loop)

@return string, Query de localizações
/*/
//---------------------------------------------------------------------
Static Function QLocation( oWs, cDate, cOrigin )

	Local aLocation  := IIf( ValType( oWS:GetHeader( 'location' ) ) == 'C', StrTokArr( oWS:GetHeader( 'location' ) , '|'), {} )
	Local cIsNull    := IIf( Upper(AllTrim(TcGetDB())) == 'ORACLE', 'NVL', IIf( Upper( AllTrim( TcGetDB() ) ) $ 'DB2', 'COALESCE', 'ISNULL' ) )
	Local lBlock     := NGCADICBASE( 'TAF_MSBLQL', 'A', 'TAF', .F. )
	Local lSLocation := cOrigin == 'sLocation'

	Local cQuery     := "SELECT TAF_CODNIV "

	If lSLocation

		cQuery += ", TAF_NOMNIV, TAF_NIVSUP, TAF_CCUSTO, TAF_CENTRA, "
		cQuery += cIsNull + "(CTT_DESC01,'') AS CCNAME," // Descrição do Centro de Custo
		cQuery += cIsNull + "(HB_NOME,'') CTNAME,"       // Descrição do Centro de Trabalho

		cQuery += "CASE WHEN TAF.D_E_L_E_T_ = ' ' THEN '0' ELSE '1' END AS IS_DELETED, "

		// Campo padrão de bloqueio (MSBLQL)
		If lBlock
			cQuery += " TAF.TAF_MSBLQL AS BLOCKED "
		Else
			cQuery += " '' AS BLOCKED "
		EndIf

	EndIf

	cQuery += "  FROM " + RetSQLName( 'TAF' ) + " TAF "

	If lSLocation

		// Join com Centro de Custo
		cQuery += "  LEFT JOIN " + RetSQLName( 'CTT' ) + " CTT "
		cQuery += "     ON CTT_CUSTO      = TAF.TAF_CCUSTO "
		cQuery += "    AND CTT.D_E_L_E_T_ = ' ' "
		cQuery += "    AND CTT_FILIAL     = " + ValToSql( xFilial("CTT") )

		// Join com Centro de Trabalho
		cQuery += "  LEFT JOIN " + RetSQLName( 'SHB' ) + " SHB "
		cQuery += "     ON SHB.HB_COD     = TAF.TAF_CENTRA "
		cQuery += "    AND SHB.D_E_L_E_T_ = ' ' "
		cQuery += "    AND SHB.HB_FILIAL  = " + ValToSql( xFilial( "SHB" ) )

	EndIf

	cQuery += " WHERE TAF.TAF_FILIAL = " + ValToSql( xFilial('TAF') )
	cQuery += "   AND TAF.TAF_MODMNT = 'X'" // Somente itens do MNT
	cQuery += "   AND TAF.TAF_INDCON = '2'" // Somente Localização

	// Aplica filtro de localizações selecionadas no portal mobile
	cQuery += makeFilter( aLocation, "TAF.TAF_CODNIV" )

	// Filtro por Centro de Custo
	cQuery += " AND ( TAF.TAF_CCUSTO = ' ' "
	cQuery += "       OR TAF.TAF_CCUSTO IN ( " + QCostCenter( oWS, "0", "QLocation" ) +" ) ) "

	If cDate <> "0"
		// Filtro por Data da Última Alteração
		cQuery += " AND ("    + dateQuery( "TAF_USERGA" ) + " >= " + ValtoSql( cDate )
		cQuery += "      OR " + dateQuery( "TAF_USERGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		// Filtro por registros deletados
		// Caso cDate seja '0', deve-se apenas sincronizar registros não deletados
		cQuery += " AND TAF.D_E_L_E_T_ = ' ' "
	EndIf

	// Filtro de registros bloqueados para o Portal Mobile
	// Apenas registro ativos devem ser enviados
	If lPortalOrigin .And. lBlock
		cQuery += " AND TAF.TAF_MSBLQL = '2' "
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sLocation
Gera um JSON contendo as informações de Localizações para a sincronização
com o aplicativo Mobile.

@author	Wexlei Silveira
@since 17/12/2020

@param oWS  , objeto  , Referência ao webservice
@param cDate, caracter, Data da última sincronização

@return array, [1]   Indica se obteve sucesso na operação,
               [2,1] Nome do arquivo de delete,
			   [2,2] Nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sLocation( oWS, cDate )

	Local cAliasQry := GetNextAlias()
	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local cHrIn     := Time()
    Local nCount    := 0
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cFullPath := ''
	Local cSubJSON  := ''
	Local lDbMSSQL  := 'MSSQL' $ Upper(AllTrim(TcGetDB())) // Ambientes com SGBD MSSQL
	Local cQuery    := ChangeQuery( QLocation( oWS, cDate, 'sLocation' ) )

	dbUseArea( .T., 'TOPCONN', TCGenQry( Nil, Nil, cQuery ), cAliasQry, .T., .T. )
	aFileName := GenFileName( 'location' )

	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + ' ' + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If ( cAliasQry )->IS_DELETED == '0'

			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"'   + NGEscape( (cAliasQry)->TAF_CODNIV, .T. ) + '",'
			cSubJSON += '"name":"'   + NGEscape( (cAliasQry)->TAF_NOMNIV, .T. ) + '",'
			cSubJSON += '"parent":"' + NGEscape( (cAliasQry)->TAF_NIVSUP, .T. ) + '",'

			If !Empty( (cAliasQry)->TAF_CCUSTO )
				cSubJSON += '"costCenterCode":"' + NGEscape( (cAliasQry)->TAF_CCUSTO, .T. ) + '",'
				cSubJSON += '"costCenterName":"' + NGEscape( (cAliasQry)->CCNAME    , .T. ) + '",'
			EndIf

			If !Empty( (cAliasQry)->TAF_CENTRA )
				cSubJSON += '"workCenterCode":"' + NGEscape( (cAliasQry)->TAF_CENTRA, .T. ) + '",'
				cSubJSON += '"workCenterName":"' + NGEscape( (cAliasQry)->CTNAME    , .T. ) + '",'
			EndIf

			If (cAliasQry)->BLOCKED == '1'
				cSubJSON += '"blocked":true,'
			EndIf

			//---------------------------------------------------------
			// Busca descrição da hierarquia da localização
			//---------------------------------------------------------
			If lDbMSSQL
				cFullPath := Localization( (cAliasQry)->TAF_CODNIV, '2' )
			Else
				cFullPath := NGLocComp( (cAliasQry)->TAF_CODNIV, '2' )
			EndIf

			cSubJSON += '"path":"' + NGEscape( cFullPath , .T.  ) + '"'

			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->TAF_CODNIV, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )

	printf( 'sLocation: ' + cValtoChar( nCount ) + ' em ' + ElapTime( cHrIn, Time() ) )

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QService
Query para serviços

@autor Maria Elisandra de Paula
@since 04/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@param lWhere, boolean, se busca somente a string de condição where da query
@return string, query de serviços
/*/
//---------------------------------------------------------------------
Static Function QService( oWs, cDate, cOrigin, lWhere )

	Local aService := If(ValType(oWS:GetHeader( 'service' )) == "C", StrTokArr( oWS:GetHeader( 'service' ) , "|"), {})
	Local aType    := If(ValType(oWS:GetHeader( 'type' )) == "C", StrTokArr( oWS:GetHeader( 'type' ) , "|"), {})
	Local lBlock   := NGCADICBASE("T4_MSBLQL","A","ST4",.F.)
	Local cFilter  := ''
	Local cQuery   := "SELECT ST4.T4_SERVICO "
	Local cWhere   := ''

	Default lWhere := .F.

	If cOrigin == "sService"

		cQuery += ",ST4.T4_NOME, "
		cQuery += "CASE WHEN STE.TE_CARACTE = 'P' THEN 'P' Else 'C' END AS TYPE, "
		cQuery += "CASE "
		cQuery += "    WHEN ST4.D_E_L_E_T_ = ' ' THEN 'FALSE' "
		cQuery += "Else 'true' "
		cQuery += "END AS IS_DELETED, "

		If lBlock
			cQuery += " CASE WHEN ST4.T4_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += "'' AS BLOCKED "
		EndIf

	EndIf

	cQuery += "FROM " + RetSQLName('ST4') + " ST4 "

	cQuery += "INNER JOIN " + RetSQLName('STE') + " STE "
	cQuery += "    ON STE.TE_TIPOMAN = ST4.T4_TIPOMAN"
	cQuery += "    AND STE.TE_FILIAL = " + ValToSql( xFilial('STE') )
	cQuery += "    AND STE.D_E_L_E_T_= ' ' "
	cQuery += makeFilter( aType, 'STE.TE_CARACTE' )

	cQuery += "INNER JOIN " + RetSQLName('STD') + " STD "
	cQuery += "    ON STD.TD_CODAREA = ST4.T4_CODAREA"
	cQuery += "    AND STD.TD_FILIAL = " + ValToSQL( xFilial("STD") )
	cQuery += "    AND STD.D_E_L_E_T_ = ' ' "
	cQuery += "    AND STD.TD_CODAREA IN (" + QArea( oWs, '0', '' ) + ")"
	cQuery += " WHERE "

	cWhere += " ST4.T4_FILIAL = " + ValToSql( xFilial("ST4") )
	cWhere += makeFilter( aService, "ST4.T4_SERVICO" )


	If cDate <> "0"
		cWhere += " AND (" + dateQuery( "T4_USERLGA" ) + " >= " + ValtoSql( cDate )
		cWhere += " OR " + dateQuery( "T4_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cWhere += " AND ST4.D_E_L_E_T_ = ' ' "
	EndIf

	If lPortalOrigin .And. lBlock
		cWhere += " AND ST4.T4_MSBLQL <> '1' "
	EndIf

	If lPeMntNg
		cFilter := ExecBlock("MNTNG",.F.,.F.,{"FILTER_SERVICE",oWS})
		If !Empty(cFilter)
			cWhere += cFilter
		EndIf
	EndIf

	If lWhere
		cQuery := cWhere
	Else
		cQuery += cWhere
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sService
Gera um JSON contendo as informações de Serviço para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sService( oWS, cDate )

	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
    Local nCount    := 0
    Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := ChangeQuery( QService( oWS, cDate, "sService" ) )
	Local cAliasQry := GeraTemp( cQuery, 'Service' )

	aFileName := GenFileName( 'service' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F. , STR0017 + " " + AllTrim( Str( FError() ) ) }//"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape((cAliasQry)->T4_SERVICO, .T. ) + '",'
			cSubJSON += '"name":"' + NGEscape((cAliasQry)->T4_NOME, .T.) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"type":"' + NGEscape((cAliasQry)->TYPE) + '"'
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->T4_SERVICO,.T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )

	printf("sService: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return {.T., aFileName}

//---------------------------------------------------------------------
/*/{Protheus.doc} QMaintenance
Query para manutenção

@autor Maria Elisandra de Paula
@since 17/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de manutenção
/*/
//---------------------------------------------------------------------
Static Function QMaintenance( oWs, cDate, cOrigin )

	Local cQuery := ""
	Local aProduct := If(ValType(oWS:GetHeader( 'product' )) == "C", StrTokArr( oWS:GetHeader( 'product' ) , "|"), {})

	If cOrigin == "sMaintenance"
		cQuery := " SELECT STF.TF_CODBEM, STF.TF_SERVICO, STF.TF_SEQRELA, STF.TF_NOMEMAN, "
		cQuery += " CASE "
		cQuery += " WHEN STF.D_E_L_E_T_ = ' ' THEN 'FALSE' "
		cQuery += " Else 'true' "
		cQuery += " END AS IS_DELETED "
	Else
		cQuery := " SELECT STF.TF_CODBEM || STF.TF_SERVICO || STF.TF_SEQRELA "
	EndIf

	cQuery += " FROM " + RetSQLName('STF') + " STF "

	cQuery += " INNER JOIN " + RetSQLName('ST4') + " ST4 "
	cQuery += "    ON STF.TF_SERVICO = ST4.T4_SERVICO AND " + QService( oWS, '0', '', .T. )

	cQuery += " INNER JOIN " + RetSQLName('ST9') + " ST9 "
	cQuery += "    ON STF.TF_CODBEM = ST9.T9_CODBEM AND " + QEquipment( oWS, '0', '', .T. )

	cQuery += " WHERE STF.TF_FILIAL = " + ValtoSql( xFilial("STF") )
	cQuery += " AND STF.TF_ATIVO <> 'N' "

	//Retorna apenas as manutenções que não tenham insumo produto sem permissão para usuário
	If Len(aProduct) > 1
		cQuery += " AND ((SELECT COUNT(STG.TG_CODIGO) FROM "+ RetSQLName('STG') +" STG"
		cQuery += " WHERE STG.TG_FILIAL = "+ ValToSQL(xFilial("STG"))
		cQuery += "      AND STG.TG_CODBEM = STF.TF_CODBEM "
		cQuery += "      AND STG.TG_SERVICO = STF.TF_SERVICO "
		cQuery += "      AND STG.TG_SEQRELA = STF.TF_SEQRELA "
		cQuery += "      AND STG.D_E_L_E_T_ = ' ' "
		cQuery += "		 AND STG.TG_TIPOREG = 'P' "
		cQuery += MakeFilter( aProduct, "STG.TG_CODIGO" , .f.)

		If aProduct[1] == "reject"
			cQuery += ")) = 0 "
		ElseIf aProduct[1] == "filter"
			cQuery += ") > 0 "
			cQuery += " OR "

			cQuery += " (SELECT COUNT(STG.TG_CODIGO) FROM "+ RetSQLName('STG') +" STG"
			cQuery += " WHERE STG.TG_FILIAL = "+ ValToSQL(xFilial("STG"))
			cQuery += "      AND STG.TG_CODBEM = STF.TF_CODBEM "
			cQuery += "      AND STG.TG_SERVICO = STF.TF_SERVICO "
			cQuery += "      AND STG.TG_SEQRELA = STF.TF_SEQRELA "
			cQuery += "      AND STG.D_E_L_E_T_ = ' ' "
			cQuery += "		 AND STG.TG_TIPOREG = 'P' "
			cQuery += ") = 0 )"
		EndIf
	EndIf

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TF_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TF_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND STF.D_E_L_E_T_ = ' '"
	EndIf


Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sMaintenance
Gera um JSON contendo as informações de Manutenção para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWs - Objeto com referência ao webservice
@param cDate - Data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sMaintenance( oWs, cDate )

	Local cEquip
	Local cServ
	Local cSeq
	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
    Local nCount    := 0
    Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := ChangeQuery( QMaintenance( oWs, cDate, "sMaintenance" ) )
	Local cAliasQry := GeraTemp( cQuery, 'Maintenance' )

	aFileName := GenFileName( 'maintenance' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F. , STR0017 + " " + AllTrim( Str( FError() ) ) } //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cEquip := AllTrim( (cAliasQry)->TF_CODBEM )
			cServ  := AllTrim( (cAliasQry)->TF_SERVICO )
			cSeq   := AllTrim( (cAliasQry)->TF_SEQRELA )

			cSubJSON += '{'
			cSubJSON += '"equipment":"' + NGEscape( (cAliasQry)->TF_CODBEM, .T.) + '",'
			cSubJSON += '"service":"' + NGEscape( (cAliasQry)->TF_SERVICO, .T. ) + '",'
			cSubJSON += '"sequence":"' + NGEscape( (cAliasQry)->TF_SEQRELA ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->TF_NOMEMAN , .T. ) + '"'
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape((cAliasQry)->TF_CODBEM, .T.) + ;
						'+' + NGEscape((cAliasQry)->TF_SERVICO, .T.) +;
						'+' + TF_SEQRELA + '"'

			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sMaintenance: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T. , aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QProduct
Query para produtos

@autor Maria Elisandra de Paula
@since 03/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param lWhere, boolean, se busca somente a string de condição where da query
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@param lWhere, boolean, se busca somente a string de condição where da query
@return string, query de produto
/*/
//---------------------------------------------------------------------
Static Function QProduct( oWs, cDate, cOrigin, lWhere )

	Local cWhere    := ''
	Local nX
	Local aProducts := NGProdMNT()
	Local cProdutos := ""
	Local aProduct  := IIf(ValType(oWS:GetHeader( 'product' )) == "C", StrTokArr( oWS:GetHeader( 'product' ) , "|"), {})
	Local cFilter	:= ""
	Local lBlock    := NGCADICBASE("B1_MSBLQL","A","SB1",.F.)
	Local lProdMod  := SuperGetMV("MV_PRODMOD",.F.,.T.)
	Local cQuery    := "SELECT DISTINCT SB1.B1_COD "

	Default lWhere  := .F.

	For nX := 1 To Len(aProducts)
		cProdutos += "'" + aProducts[nX] + "'" + IIf(nX<>Len(aProducts),',','')
	Next nX

	If cOrigin == "sProduct"

		cQuery += ", SB1.B1_DESC, SB1.B1_UM, SB1.B1_LOCPAD, B1_RASTRO, B1_LOCALIZ, "
		cQuery += "CASE "

		If lProdMod //Remove o produto quando este passa a ser do tipo mão de obra.
			cQuery += " WHEN SB1.B1_CCCUSTO = ' ' THEN 'FALSE'"
		EndIf

		cQuery += "WHEN SB1.D_E_L_E_T_ = ' ' THEN 'FALSE' "
		cQuery += "Else 'true' "
		cQuery += "END AS IS_DELETED,"

		If lBlock
			cQuery += " CASE WHEN SB1.B1_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += " '' AS BLOCKED "
		EndIf
	EndIf

	cQuery += "FROM " + RetSQLName('SB1') + " SB1 WHERE "

	cWhere := " SB1.B1_FILIAL = " + ValtoSql( xFilial("SB1") )
	cWhere += " AND SUBSTRING(SB1.B1_COD,1,3) <> 'MOD' AND SB1.B1_COD NOT IN ("+cProdutos+") "
	cWhere += makeFilter(aProduct, "SB1.B1_COD")

	If cDate <> "0"
		cWhere += " AND (" + dateQuery( "B1_USERLGA" ) + " >= " + ValtoSql( cDate )
		cWhere += " OR " + dateQuery( "B1_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		//Remove o produto quando este passa a ser do tipo mão de obra.
		If lProdMod
			cWhere += "AND SB1.B1_CCCUSTO = ' ' "
		EndIf
		cWhere += " AND SB1.D_E_L_E_T_ = ' ' "
	EndIf

	If lPortalOrigin .And. lBlock
		cWhere += " AND SB1.B1_MSBLQL <> '1' "
	EndIf

	If lPeMntNg
		cFilter := ExecBlock("MNTNG",.F.,.F.,{"FILTER_PRODUCT",oWS})
		If !Empty(cFilter)
			cWhere += cFilter
		EndIf
	EndIf

	If lWhere
		cQuery := cWhere
	Else
		cQuery += cWhere
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sProduct
Gera um JSON contendo as informações de Produto para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sProduct( oWS, cDate )

	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local lUsaLote  := SuperGetMV("MV_RASTRO",.F.,'N') == "S"
	Local lUsaLocal := SuperGetMV("MV_LOCALIZ") == "S"
	Local cQuery    := ChangeQuery( QProduct( oWS, cDate, "sProduct" ) )
	Local cAliasQry := GeraTemp( cQuery, 'Product' )

	aFileName := GenFileName( 'product' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return { .T., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())
		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->B1_COD, .T. ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->B1_DESC, .T. ) + '",'
			cSubJSON += '"unity":"' + NGEscape( (cAliasQry)->B1_UM ) + '",'

			//Controle de rastro: 'L':controla somente Lote,'S':controla lote e sub-lote
			If lUsaLote .And. (cAliasQry)->B1_RASTRO $ "SL"
				cSubJSON += '"tracking":"' + (cAliasQry)->B1_RASTRO + '",'
			EndIf

			//Controle de localização: sim ou não
			If lUsaLocal .And. (cAliasQry)->B1_LOCALIZ == "S"
				cSubJSON += '"addressing":true,'
			EndIf

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"warehouse":"' + NGEscape( (cAliasQry)->B1_LOCPAD, .T. ) + '"'
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->B1_COD, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )

	printf("sProduct: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return {.T., aFileName}

//---------------------------------------------------------------------
/*/{Protheus.doc} QWarehouse
Query para local de produto

@autor Maria Elisandra de Paula
@since 10/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de locais
/*/
//---------------------------------------------------------------------
Static Function QWarehouse( oWs, cDate, cOrigin )

	Local cQuery := " SELECT SB2.B2_LOCAL, SB2.B2_COD, "

	cQuery += " CASE "
	cQuery += " 	WHEN SB2.D_E_L_E_T_ = ' ' THEN 'FALSE' "
	cQuery += "     Else 'true' "
	cQuery += " 	END AS IS_DELETED "
	cQuery += "	FROM " + RetSQLName('SB2') + " SB2 "
	cQuery += "	INNER JOIN " + RetSQLName('SB1') + " SB1 ON SB2.B2_COD = SB1.B1_COD "
	cQuery += "		AND SB1.B1_FILIAL = " + ValtoSql( xFilial("SB1") )
	cQuery += "	WHERE SB2.B2_FILIAL = " + ValtoSql( xFilial("SB2") )

	cQuery += " AND " + QProduct( oWS, cDate, '', .T. ) + " "

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "B2_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "B2_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND SB2.D_E_L_E_T_ = ' '"
	EndIf

	If lPeMntNg
		cFilter := ExecBlock("MNTNG",.F.,.F.,{"FILTER_WAREHOUSE",oWS})
		If !Empty(cFilter)
			cQuery += cFilter
		EndIf
	EndIf

	cQuery := ChangeQuery(cQuery)

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sWarehouse
Gera um JSON contendo as informações de Almoxarifado para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sWarehouse( oWs, cDate )

	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := QWarehouse( oWs, cDate, "sWarehouse" )
	Local cAliasQry := GeraTemp( cQuery, 'Warehouse' )

	aFileName := GenFileName( 'warehouse' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.T., STR0017 + " " + AllTrim( Str( FError() ) ) }//"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())
		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->B2_LOCAL, .T. ) + '",'
			cSubJSON += '"product":"' + NGEscape( (cAliasQry)->B2_COD, .T. ) + '"'
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->B2_LOCAL, .T. ) + "+" + NGEscape( (cAliasQry)->B2_COD, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sWarehouse: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QCostCenter
Query para centro de custo

@autor Maria Elisandra de Paula
@since 10/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@param lWhere, boolean, se busca somente a string de condição where da query
@return string, query de centro de custo
/*/
//---------------------------------------------------------------------
Static Function QCostCenter( oWs, cDate, cOrigin, lWhere )

	Local aCostCenter := If(ValType(oWS:GetHeader( 'costCenter' )) == "C", StrTokArr( oWS:GetHeader( 'costCenter' ) , "|"), {})
	Local cFilter     := ""
	Local lBlock      := NGCADICBASE("CTT_MSBLQL","A","CTT",.F.)
	Local cQuery      := ''
	Local cWhere      := ''

	Default lWhere := .F.

	cQuery := "SELECT CTT.CTT_CUSTO "

	If cOrigin == "sCostCenter"

		cQuery += " , CTT.CTT_DESC01, CTT.CTT_LOCAL, "
		cQuery += "CASE WHEN CTT.D_E_L_E_T_ = ' ' THEN 'FALSE' "
		cQuery += "Else 'true' END AS IS_DELETED, "

		If lBlock
			cQuery += " CASE WHEN CTT.CTT_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += "'' AS BLOCKED "
		EndIf

	EndIf

	cQuery += "FROM " + RetSQLName('CTT') + " CTT "
	cQuery += " WHERE "

	//---------------------
	// Condição Where
	//---------------------
	cWhere += " CTT.CTT_FILIAL = " + ValtoSql( xFilial("CTT") )
	cWhere += makeFilter( aCostCenter, "CTT.CTT_CUSTO" )

	If cDate != "0"
		cWhere += " AND (" + dateQuery( "CTT_USERGA" ) + " >= " + ValtoSql( cDate )
		cWhere += " OR " + dateQuery( "CTT_USERGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cWhere += " AND CTT.D_E_L_E_T_ = ' '"
	EndIf

	If lPortalOrigin .And. lBlock
		cWhere += " AND CTT.CTT_MSBLQL <> '1' "
	EndIf

	If lPeMntNg
		cFilter := ExecBlock("MNTNG",.F.,.F.,{"FILTER_COSTCENTER",oWS})
		If !Empty(cFilter)
			cWhere += cFilter
		EndIf
	EndIf

	If lWhere
		cQuery := cWhere
	Else
		cQuery += cWhere
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sCostCenter
Gera um JSON contendo as informações de Centro de Custo para a sincronização
com o aplicativo Mobile

Filtro:
Centro de custo

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sCostCenter( oWs, cDate )

	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := ChangeQuery( QCostCenter( oWs, cDate, "sCostCenter" ) )
	Local cAliasQry := GeraTemp( cQuery, 'CostCenter' )

	aFileName := GenFileName( 'costcenter' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())
		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->CTT_CUSTO, .T. ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->CTT_DESC01 , .T. ) + '",'
			cSubJSON += '"warehouse":"' + NGEscape( (cAliasQry)->CTT_LOCAL , .T. ) + '"'
			cSubJSON += '}'
			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->CTT_CUSTO, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )

	printf("sCostCenter: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T. , aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QFamily
Query para família de bens

@autor Maria Elisandra de Paula
@since 10/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@param lWhere, boolean, se busca somente a string de condição where da query
@return string, query de família
/*/
//---------------------------------------------------------------------
Static Function QFamily( oWs, cDate, cOrigin, lWhere )

	Local cFilter
	Local lBlock  := NGCADICBASE("T6_MSBLQL","A","ST6",.F.)
	Local aFamily := IIf( ValType( oWS:GetHeader( 'family' ) ) == "C", StrTokArr( oWS:GetHeader( 'family' ) , "|"), {})
	Local cQuery  := "SELECT ST6.T6_CODFAMI "
	Local cWhere  := ''

	Default lWhere := .F.

	If cOrigin == "sFamily"
		cQuery += " , ST6.T6_NOME, "
		cQuery += " CASE WHEN ST6.D_E_L_E_T_ = ' ' THEN 'FALSE' "
		cQuery += " Else 'true' END AS IS_DELETED, "

		If lBlock
			cQuery += " CASE WHEN ST6.T6_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += "'' AS BLOCKED "
		EndIf

	EndIf

	cQuery += "FROM " + RetSQLName('ST6') + " ST6 "
	cQuery += " WHERE "

	//----------------------
	// Condição where
	//----------------------
	cWhere := " ST6.T6_FILIAL = " + ValtoSql( xFilial("ST6") )
	cWhere += makeFilter( aFamily, "ST6.T6_CODFAMI" )

	If cDate <> "0"
		cWhere += " AND (" + dateQuery( "T6_USERLGA" ) + " >= " + ValtoSql( cDate )
		cWhere += " OR " + dateQuery( "T6_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cWhere += " AND ST6.D_E_L_E_T_ = ' '"
	EndIf

	If lPortalOrigin .And. lBlock
		cWhere += " AND ST6.T6_MSBLQL <> '1' "
	EndIf

	If lPeMntNg
		cFilter := ExecBlock("MNTNG",.F.,.F.,{"FILTER_FAMILY",oWS})
		If !Empty(cFilter)
			cWhere += cFilter
		EndIf
	EndIf

	If lWhere
		cQuery := cWhere
	Else
		cQuery += cWhere
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sFamily
Gera um JSON contendo as informações de Família para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 12/05/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sFamily( oWs, cDate )

	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := ChangeQuery( QFamily( oWs, cDate, "sFamily" ) )
	Local cAliasQry := GeraTemp( cQuery, 'Family' )

	aFileName := GenFileName( 'family' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf


	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->T6_CODFAMI, .T. ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->T6_NOME , .T. ) + '"'
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->T6_CODFAMI, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )

	printf("sFamily: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QWorker
Query para funcionários da manutenção

@autor Maria Elisandra de Paula
@since 06/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de funcionário da manutenção
/*/
//---------------------------------------------------------------------
Static Function QWorker( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("T1_MSBLQL","A","ST1",.F.)
	Local cQuery := "SELECT ST1.T1_CODFUNC "

	If cOrigin == "sWorker"

		cQuery += " , ST1.T1_NOME, "
		cQuery += "CASE "
		cQuery += "WHEN ST1.D_E_L_E_T_ = ' ' THEN 'FALSE' "
		cQuery += "Else 'true' "
		cQuery += "END AS IS_DELETED,"

		If lBlock
			cQuery += " CASE WHEN ST1.T1_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += "'' AS BLOCKED "
		EndIf
	EndIf

	cQuery += "FROM " + RetSQLName('ST1') + " ST1 "
	cQuery += "WHERE T1_DISPONI = 'S' AND T1_FILIAL = " + ValtoSql( xFilial("ST1") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "T1_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "T1_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND ST1.D_E_L_E_T_ = ' '"
	EndIf

	cQuery := ChangeQuery(cQuery)

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sWorker
Gera um JSON contendo as informações de Funcionários para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sWorker( oWs, cDate )

	Local cSpeciality := ""
	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := QWorker( oWs, cDate, "sWorker" )
	Local cAliasQry := GeraTemp( cQuery, 'Worker' )

	aFileName := GenFileName( 'worker' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			dbSelectArea("ST2")
			dbSetOrder(1)
			If dbSeek(xFilial("ST2")+(cAliasQry)->T1_CODFUNC)
				cSpeciality := NGEscape( ST2->T2_ESPECIA, .T. )
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' +  NGEscape( (cAliasQry)->T1_CODFUNC, .T. ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->T1_NOME , .T. ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"speciality":"' + cSpeciality + '"'
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )

			cSpeciality := ""
			dbSelectArea(cAliasQry)
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->T1_CODFUNC, .T.) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sWorker: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QThirdPart
Query para terceiros

@autor Maria Elisandra de Paula
@since 06/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@param lWhere, boolean, se busca somente a string de condição where da query
@return string, query de terceiros
/*/
//---------------------------------------------------------------------
Static Function QThirdPart( oWs, cDate, cOrigin, lWhere )

	Local aThirdP := IIf(ValType(oWS:GetHeader( 'thirdPart' )) == "C", StrTokArr( oWS:GetHeader( 'thirdPart' ) , "|"), {})
	Local cFilter := ''
	Local lBlock  := NGCADICBASE("A2_MSBLQL","A","SA2",.F.)
	Local cQuery  := "SELECT SA2.A2_COD"
	Local cWhere  := ''

	Default lWhere := .F.

	If cOrigin == "sThirdPart"

		cQuery += ", SA2.A2_NOME, SA2.A2_LOJA, "
		cQuery += "CASE "
		cQuery += "WHEN SA2.D_E_L_E_T_ = ' ' THEN 'FALSE' "
		cQuery += "Else 'true' "
		cQuery += "END AS IS_DELETED,"

		If lBlock
			cQuery += " CASE WHEN SA2.A2_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += " '' AS BLOCKED "
		EndIf
	EndIf

	cQuery += "FROM " + RetSQLName('SA2') + " SA2 "
	cQuery += "WHERE "

	//---------------------------
	// condição where
	//---------------------------
	cWhere += " SA2.A2_FILIAL = " + ValtoSql( xFilial('SA2') )
	cWhere += makeFilter( aThirdP, "SA2.A2_COD" )

	If cDate <> "0"
		cWhere += " AND (" + dateQuery( "A2_USERLGA" ) + " >= " + ValtoSql( cDate )
		cWhere += " OR " + dateQuery( "A2_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cWhere += " AND SA2.D_E_L_E_T_ = ' ' "
	EndIf

	If lPortalOrigin .And. lBlock
		cWhere += " AND SA2.A2_MSBLQL <> '1' "
	EndIf

	If lPeMntNg
		cFilter := ExecBlock("MNTNG",.F.,.F.,{"FILTER_THIRDPART",oWS})
		If !Empty(cFilter)
			cWhere += cFilter
		EndIf
	EndIf

	If lWhere
		cQuery := cWhere
	Else
		cQuery += cWhere
		cQuery := ChangeQuery(cQuery)
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sThirdPart
Gera um JSON contendo as informações de Terceiros para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sThirdPart( oWs, cDate )

	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := QThirdPart( oWs, cDate, "sThirdPart" )
	Local cAliasQry := GeraTemp( cQuery, 'ThirdPart' )

	aFileName := GenFileName( 'thirdpart' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' +  NGEscape( (cAliasQry)->A2_COD, .T. ) + '",'
			cSubJSON += '"store":"' + NGEscape( (cAliasQry)->A2_LOJA, .T. ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->A2_NOME , .T. ) + '"'
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->A2_COD, .T. ) + '+' + NGEscape( (cAliasQry)->A2_LOJA, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )

	printf("sThirdPart: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QSpeciality
Query para especialidades

@autor Maria Elisandra de Paula
@since 06/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de especialidade
/*/
//---------------------------------------------------------------------
Static Function QSpeciality( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("T0_MSBLQL","A","ST0",.F.)
	Local cQuery := "SELECT ST0.T0_ESPECIA"

	If cOrigin == "sSpeciality"

		cQuery += " , ST0.T0_NOME, "
		cQuery += "CASE WHEN ST0.D_E_L_E_T_ = ' ' THEN 'FALSE' "
		cQuery += "Else 'true' END AS IS_DELETED,"

		If lBlock
			cQuery += " CASE WHEN ST0.T0_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += " '' AS BLOCKED "
		EndIf
	EndIf

	cQuery += "FROM " + RetSQLName('ST0') + " ST0 "
	cQuery += "WHERE ST0.T0_FILIAL = " + ValtoSql( xFilial("ST0") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "T0_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "T0_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND ST0.D_E_L_E_T_ = ' ' "
	EndIf

	cQuery := ChangeQuery(cQuery)

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sSpeciality
Gera um JSON contendo as informações de Especialidade para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sSpeciality( oWs, cDate )

	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := QSpeciality( oWs, cDate, "sSpeciality" )
	Local cAliasQry := GeraTemp( cQuery, 'Speciality' )

	aFileName := GenFileName( 'speciality' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->T0_ESPECIA, .T. ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->T0_NOME , .T. ) + '"'
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->T0_ESPECIA, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sSpeciality: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QTool
Query para ferramentas

@autor Maria Elisandra de Paula
@since 06/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@param lWhere, boolean, se busca somente a string de condição where da query
@return string, query de ferramentas
/*/
//---------------------------------------------------------------------
Static Function QTool( oWs, cDate, cOrigin, lWhere )

	Local aTool   := If(ValType(oWS:GetHeader( 'tool' )) == "C", StrTokArr( oWS:GetHeader( 'tool' ) , "|"), {})
	Local cFilter := ""
	Local lBlock  := NGCADICBASE("H4_MSBLQL","A","SH4",.F.)
	Local cQuery  := "SELECT SH4.H4_CODIGO "
	Local cWhere  := ''

	Default lWhere := .F.

	If cOrigin == "sTool"

		cQuery += ", SH4.H4_DESCRI, "
		cQuery += "CASE WHEN SH4.D_E_L_E_T_ = ' ' THEN 'FALSE' "
		cQuery += "Else 'true' END AS IS_DELETED,"

		If lBlock
			cQuery += "CASE WHEN SH4.H4_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += " '' AS BLOCKED "
		EndIf
	EndIf

	cQuery += "FROM " + RetSQLName('SH4') + " SH4 "
	cQuery += "WHERE "

	//-------------------------------
	// Condição where
	//-------------------------------
	cWhere += " SH4.H4_FILIAL = " + ValtoSql( xFilial("SH4") )

	cWhere += makeFilter(aTool, "SH4.H4_CODIGO")

	If cDate <> "0"
		cWhere += " AND (" + dateQuery( "H4_USERLGA" ) + " >= " + ValtoSql( cDate )
		cWhere += " OR " + dateQuery( "H4_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cWhere += " AND SH4.D_E_L_E_T_ = ' ' "
	EndIf

	If lPortalOrigin .And. lBlock
		cWhere += " AND SH4.H4_MSBLQL <> '1' "
	EndIf

	If lPeMntNg
		cFilter := ExecBlock("MNTNG",.F.,.F.,{"FILTER_TOOL",oWS})
		If !Empty(cFilter)
			cWhere += cFilter
		EndIf
	EndIf

	If lWhere
		cQuery := cWhere
	Else
		cQuery += cWhere
		cQuery := ChangeQuery( cQuery )
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sTool
Gera um JSON contendo as informações de Ferramentas para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sTool( oWs, cDate )

	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := QTool( oWs, cDate, "sTool" )
	Local cAliasQry := GeraTemp( cQuery, 'Tool' )

	aFileName := GenFileName( 'tool' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf


	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->H4_CODIGO, .T. ) + '",'

		If (cAliasQry)->BLOCKED == "TRUE"
			cSubJSON += '"blocked":true,'
		EndIf

			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->H4_DESCRI, .T. ) + '"'
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->H4_CODIGO, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )

	printf("sTool: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QTask
Query para etapas Tarefas

@autor Maria Elisandra de Paula
@since 17/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de tarefas
/*/
//---------------------------------------------------------------------
Static Function QTask( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("TT9_MSBLQL","A","TT9",.F.)
	Local cQuery := "SELECT TT9.TT9_TAREFA "

	If cOrigin == "sTask"

		cQuery += " , TT9.TT9_DESCRI, "
		cQuery += " CASE WHEN TT9.D_E_L_E_T_ = ' ' THEN 'FALSE' "
		cQuery += " Else 'true' END AS IS_DELETED,"

		If lBlock
			cQuery += " CASE WHEN TT9.TT9_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += " '' AS BLOCKED "
		EndIf
	EndIf

	cQuery += "FROM " + RetSQLName('TT9') + " TT9 "
	cQuery += "WHERE TT9.TT9_FILIAL = " + ValtoSql( xFilial("TT9") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TT9_USERGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TT9_USERGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND TT9.D_E_L_E_T_ = ' '"
	EndIf

	cQuery := ChangeQuery( cQuery )

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sTask
Gera um JSON contendo as informações de Tarefas Genéricas para a sincronização
com o aplicativo Mobile

@obs Para tarefa genérica, habilitar parâmetro MV_NGTARGE
@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sTask( oWs, cDate )

	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := QTask( oWs, cDate, "sTask" )
	Local cAliasQry := GeraTemp( cQuery, 'Task' )

	aFileName := GenFileName( 'task' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->TT9_TAREFA, .T. ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->TT9_DESCRI , .T. ) + '"'
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->TT9_TAREFA, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	//------------------------------------------------------
	// Quando não utiliza tarefas genéricas envia tarefa '0'
	//------------------------------------------------------
	If cDate == '0' .And. SuperGetMv( 'MV_NGTARGE', .F., '2' ) != '1'
		cSubJSON := IIF( !lFirst, ',', '' ) + '{"code":"0","name":"' + EncodeUtf8( 'SEM ESPECIFICAÇÃO DE TAREFA' ) + '"}'
		FWrite( nUpdate, cSubJSON )
	EndIf

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sTask: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T. , aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QPrevtask
Query para tarefas da manutenção

@autor Maria Elisandra de Paula
@since 17/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de tarefas da manutenção
/*/
//---------------------------------------------------------------------
Static Function QPrevtask( oWs, cDate, cOrigin )

	Local cQuery := "SELECT ST5.T5_TAREFA, ST5.T5_DESCRIC, ST5.T5_CODBEM, "

	cQuery += "ST5.T5_SERVICO, ST5.T5_SEQRELA, ST5.T5_SEQUENC,"
	cQuery += "CASE "
	cQuery += "WHEN ST5.D_E_L_E_T_ = ' ' THEN 'FALSE' "
	cQuery += "Else 'true' "
	cQuery += "END AS IS_DELETED "
	cQuery += "FROM " + RetSQLName('ST5') + " ST5 "
	cQuery += "WHERE ST5.T5_FILIAL = " + ValtoSql( xFilial("ST5") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "T5_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "T5_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND ST5.D_E_L_E_T_ = ' '"
	EndIf

	cQuery += " AND ST5.T5_CODBEM || ST5.T5_SERVICO || ST5.T5_SEQRELA "
	cQuery += "  IN ( " + QMaintenance( oWS, "0", '' ) +" )"
	cQuery += "ORDER BY ST5.T5_CODBEM, ST5.T5_SERVICO, ST5.T5_SEQRELA, ST5.T5_SEQUENC "

	cQuery := ChangeQuery( cQuery )

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sPrevTask
Gera um JSON contendo as informações de Tarefas Preventivas para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sPrevTask( oWs, cDate )

	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := QPrevTask( oWs, cDate, "sPrevTask" )
	Local cAliasQry := GeraTemp( cQuery, 'PrevTask' )

	aFileName := GenFileName( 'prevtask' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"equipment":"' + NGEscape( (cAliasQry)->T5_CODBEM, .T. ) + '",'
			cSubJSON += '"service":"' + NGEscape( (cAliasQry)->T5_SERVICO, .T. ) + '",'
			cSubJSON += '"sequence":"' + NGEscape( (cAliasQry)->T5_SEQRELA ) + '",'
			cSubJSON += '"task":"' + NGEscape( (cAliasQry)->T5_TAREFA, .T. ) + '",'
			cSubJSON += '"description":"' + NGEscape( (cAliasQry)->T5_DESCRIC , .T. ) + '"'
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->T5_CODBEM, .T. ) + '+' + NGEscape( (cAliasQry)->T5_SERVICO, .T. ) + ;
						'+' +  NGEscape( (cAliasQry)->T5_SEQRELA ) + '+' + NGEscape( (cAliasQry)->T5_TAREFA, .T.) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sPrevTask: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QArea
Query para area

@autor Maria Elisandra de Paula
@since 17/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de area da manutenção
/*/
//---------------------------------------------------------------------
Static Function QArea( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("TD_MSBLQL","A","STD",.F.)
	Local aArea := IIf( ValType( oWS:GetHeader( 'area' ) ) == "C", StrTokArr( oWS:GetHeader( 'area' ) , "|"), {})
	Local cQuery := "SELECT STD.TD_CODAREA "

	If cOrigin == "sArea"
		cQuery += " , STD.TD_NOME, "
		cQuery += "CASE "
		cQuery += "WHEN STD.D_E_L_E_T_ = ' ' THEN 'FALSE' "
		cQuery += "Else 'true' "
		cQuery += "END AS IS_DELETED, "

		If lBlock
			cQuery += " CASE WHEN STD.TD_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += " '' AS BLOCKED "
		EndIf

	EndIf

	cQuery += "FROM " + RetSQLName('STD') + " STD "
	cQuery += "WHERE STD.TD_FILIAL = " + ValtoSql( xFilial("STD") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TD_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TD_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND STD.D_E_L_E_T_ = ' '"
	EndIf

	cQuery += makeFilter( aArea, "STD.TD_CODAREA" )

	If lPortalOrigin .And. lBlock
		cQuery += " AND STD.TD_MSBLQL <> '1' "
	EndIf

	If lPeMntNg
		cFilter := ExecBlock("MNTNG",.F.,.F.,{"FILTER_AREA",oWS})
		If !Empty(cFilter)
			cQuery += cFilter
		EndIf
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sArea
Gera um JSON contendo as informações de Área para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 12/05/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sArea( oWs, cDate )

	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local nCount    := 0
	Local cHrIn     := Time()
	Local cQuery    := ChangeQuery( QArea( oWs, cDate, "sArea" ) )
	Local cAliasQry := GeraTemp( cQuery, 'Area' )

	aFileName := GenFileName( 'area' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf


	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape((cAliasQry)->TD_CODAREA, .T. ) + '",'
			cSubJSON += '"name":"' + NGEscape((cAliasQry)->TD_NOME , .T. ) + '"'
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->TD_CODAREA ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )

	printf("sArea: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QChecklist
Query para etapas

@autor Maria Elisandra de Paula
@since 12/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de etapas
/*/
//---------------------------------------------------------------------
Static Function QChecklist( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("TPA_MSBLQL","A","TPA",.F.)
	Local cQuery := "SELECT TPA.TPA_ETAPA "

	If cOrigin == "sChecklist"

		cQuery += " , TPA.TPA_DESCRI, TPA_OPCOES, "
		cQuery += "CASE "
		cQuery += "WHEN TPA.D_E_L_E_T_ = ' ' THEN 'FALSE' "
		cQuery += "Else 'true' "
		cQuery += "END AS IS_DELETED, "

		If lBlock
			cQuery += " CASE WHEN TPA.TPA_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += " '' AS BLOCKED "
		EndIf
	EndIf

	cQuery += "FROM " + RetSQLName('TPA') + " TPA "
	cQuery += "WHERE TPA.TPA_FILIAL = " + ValtoSql( xFilial("TPA") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TPA_USERGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TPA_USERGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND TPA.D_E_L_E_T_ = ' '"
	EndIf

	cQuery := ChangeQuery( cQuery )

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sChecklist
Gera um JSON contendo as informações de Checklist para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sChecklist( oWs, cDate )

	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := QChecklist( oWs, cDate, "sChecklist" )
	Local cAliasQry := GeraTemp( cQuery, 'Checklist' )

	aFileName := GenFileName( 'checklist' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->TPA_ETAPA, .T. ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->TPA_DESCRI , .T. ) + '"'

			If (cAliasQry)->TPA_OPCOES <> "0"
				cSubJSON += ',"option":"' + (cAliasQry)->TPA_OPCOES + '"'
			EndIf

			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->TPA_ETAPA, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sChecklist: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QQuestion
Query para opções da etapa

@autor Maria Elisandra de Paula
@since 17/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de opções da etapa
/*/
//---------------------------------------------------------------------
Static Function QQuestion( oWs, cDate, cOrigin )

	Local cQuery := " SELECT TPC_ETAPA, TPC_OPCAO, TPC_DESOPC, TPC_TIPCAM, TPC_TIPRES, "

	cQuery += " CASE "
	cQuery += "     WHEN TPC.D_E_L_E_T_ = ' ' THEN 'FALSE' "
	cQuery += " 	Else 'true' "
	cQuery += " 	END AS IS_DELETED "
	cQuery += " FROM " + RetSQLName('TPC') + " TPC "
	cQuery += " WHERE TPC.TPC_FILIAL = " + ValtoSql(xFilial("TPC"))

	If cDate <> "0"
		cQuery += "	AND (" + dateQuery( "TPC_USERGA" ) + " >= " + ValtoSql( cDate )
		cQuery += "	OR " + dateQuery( "TPC_USERGI" ) + " >= " + ValtoSql(cDate) + ")"
	Else
		cQuery += " AND TPC.D_E_L_E_T_ = ' '"
	EndIf

	cQuery := ChangeQuery( cQuery )

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sQuestion
Gera um JSON contendo as informações de perguntas (opções das etapas)
para a sincronização com o aplicativo Mobile

@author	Larissa Thaís de Farias
@author	Maria Elisandra de Paula
@since 17/04/2018
@param cDate - Data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sQuestion ( oWs, cDate )

	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := QQuestion( oWs, cDate, "sQuestion" )
	Local cAliasQry := GeraTemp( cQuery, 'Question' )

	aFileName := GenFileName( 'question' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"checklist":"'		+ NGEscape( (cAliasQry)->TPC_ETAPA, .T. ) + '",'
			cSubJSON += '"code":"'			+ NGEscape( (cAliasQry)->TPC_OPCAO , .T.) + '",'
			cSubJSON += '"description":"'	+ NGEscape( (cAliasQry)->TPC_DESOPC , .T.) + '",'
			cSubJSON += '"answerType":"'	+ NGEscape( (cAliasQry)->TPC_TIPRES ) + '"'

			If (cAliasQry)->TPC_TIPRES == "2"
				cSubJSON += ',"fieldType":"' + NGEscape( (cAliasQry)->TPC_TIPCAM ) + '"'
			EndIf

			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->TPC_ETAPA, .T. ) + '+' + NGEscape( (cAliasQry)->TPC_OPCAO, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sQuestion: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QAnswer
Query para respostas da etapa da ordem

@autor Maria Elisandra de Paula
@since 17/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de respostas da etapa
/*/
//---------------------------------------------------------------------
Static Function QAnswer( oWs, cDate, cOrigin )

	Local cQuery := " SELECT TPQ_ORDEM, TPQ_PLANO, TPQ_ETAPA,TPQ_OPCAO,TPC_TIPCAM,"

	cQuery += "  TPQ_TAREFA, TPQ_ORDEMG, TPC_TPMANU,TPC_TIPRES,"
	cQuery += "  CASE "
	cQuery += "   WHEN TPC_TIPRES = '1' THEN '.T.'"
	cQuery += "   ELSE TPQ_RESPOS "
	cQuery += "   END AS TPQ_RESPOS,"
	cQuery += "  CASE "
	cQuery += "   WHEN TPQ.D_E_L_E_T_ = ' ' THEN 'FALSE' "
	cQuery += "   Else 'true' "
	cQuery += "   END AS IS_DELETED "
	cQuery += " FROM " + RetSQLName('TPQ') + " TPQ "
	cQuery += " JOIN " + RetSQLName('TPC') + " TPC "
	cQuery += "  ON TPC_FILIAL = " + ValtoSql(xFilial("TPC"))
	cQuery += "	 AND TPC_ETAPA = TPQ_ETAPA "
	cQuery += "	 AND TPC_OPCAO = TPQ_OPCAO "
	cQuery += "	 AND TPC.D_E_L_E_T_ = ' ' "
	cQuery += " INNER JOIN " + RetSQLName('STJ') + " STJ "
	cQuery += " 	ON STJ.TJ_ORDEM = TPQ.TPQ_ORDEM AND STJ.TJ_PLANO = TPQ.TPQ_PLANO "
	cQuery += "		AND TJ_FILIAL = " + ValtoSql( xFilial("STJ") )
	cQuery += QOrder( oWs, cDate, '' )
	cQuery += "	AND TPQ.TPQ_FILIAL = " + ValtoSql(xFilial("TPQ"))

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TJ_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TJ_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND TPQ.D_E_L_E_T_ = ' '"
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sAnswer
Gera um JSON contendo as informações de respostas das etapas para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@author	Maria Elisandra de Paula
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sAnswer ( oWs, cDate )

	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local xValue
	Local cQuery    := ChangeQuery( QAnswer( oWs, cDate, "sAnswer" ) )
	Local cAliasQry := GeraTemp( cQuery, 'Answer' )

	aFileName := GenFileName( 'answer' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += fToJson("order",    (cAliasQry)->TPQ_ORDEM) + ","
			cSubJSON += fToJson("plan",     (cAliasQry)->TPQ_PLANO) + ","
			cSubJSON += fToJson("task",     (cAliasQry)->TPQ_TAREFA)+ ","
			cSubJSON += fToJson("checklist",(cAliasQry)->TPQ_ETAPA)	+ ","
			cSubJSON += fToJson("code",     (cAliasQry)->TPQ_OPCAO, .T., .T.)	+ ","

			//Há uma O.S ou S.S gerada quando o campo (cAliasQry)->TPQ_ORDEMG estiver preenchido
			If !Empty((cAliasQry)->TPQ_ORDEMG)
				cSubJSON += fToJson(If((cAliasQry)->TPC_TPMANU == "1","serviceOrder", "serviceRequest"),(cAliasQry)->TPQ_ORDEMG) + ","
			EndIf

			xValue := Nil
			If (cAliasQry)->TPC_TIPRES == "1" .Or. ((cAliasQry)->TPC_TIPCAM == "L" )
				If Alltrim((cAliasQry)->TPQ_RESPOS) == ".T."
					xValue := .T.
				Else
					xValue := .F.
				EndIf
			ElseIf (cAliasQry)->TPC_TIPCAM == "N"
				xValue := Val((cAliasQry)->TPQ_RESPOS)
			Else
				xValue := (cAliasQry)->TPQ_RESPOS
			EndIf

			cSubJSON += fToJson("value",xValue)
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->TPQ_ORDEM, .T. )  + '+' +  NGEscape( (cAliasQry)->TPQ_PLANO )  + '+' + ;
						NGEscape( (cAliasQry)->TPQ_TAREFA, .T. )  + '+' +  NGEscape( (cAliasQry)->TPQ_ETAPA, .T. )  + '+' + ;
						NGEscape( (cAliasQry)->TPQ_OPCAO, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sAnswer: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QOrder
Query para ordens de serviço

@autor Maria Elisandra de Paula
@since 04/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de ordens de serviço
/*/
//---------------------------------------------------------------------
Static Function QOrder( oWs, cDate, cOrigin )

	Local lFilterByUser := ValType(oWS:GetHeader( 'By-User' )) == "C" .And. oWS:GetHeader( 'By-User' ) == 'true'
	Local lSpecialties  := ValType(oWS:GetHeader( 'By-User-Specialties' )) == "C" .And.;
							oWS:GetHeader( 'By-User-Specialties' ) == 'true' 

	Local lFilterUserSS := ValType(oWS:GetHeader( 'By-User-Related-Requests' )) == 'C' ;
							.And. oWS:GetHeader( 'By-User-Related-Requests' ) == 'true'

	Local aProduct      := If(ValType(oWS:GetHeader( 'product' )) == "C", StrTokArr( oWS:GetHeader( 'product' ) , "|"), {})
	Local cQuery        := ""

	fLogUser( lFilterByUser, lFilterUserSS, lSpecialties )

	lFilterByUser := lFilterByUser .And. !Empty( cUserST1 )
	lSpecialties  := lSpecialties .And. !Empty( cUserST1 ) 

	//Retira os campos que não serão usados na subquery dos métodos de insumo e etapa
	If cOrigin == "sOrder"

		cQuery += " SELECT DISTINCT STJ.TJ_ORDEM,   STJ.TJ_TIPOOS, "
		cQuery += " STJ.TJ_PLANO,   STJ.TJ_CODBEM,  STJ.TJ_SERVICO, STJ.TJ_SEQRELA, "
		cQuery += " STJ.TJ_DTORIGI, STJ.TJ_SITUACA, STJ.TJ_DTMPINI, STJ.TJ_HOMPINI, "
		cQuery += " STJ.TJ_DTMPFIM, STJ.TJ_HOMPFIM, STJ.R_E_C_N_O_, STJ.TJ_CCUSTO,  "
		cQuery += " STJ.TJ_POSCONT, STJ.TJ_POSCON2, STJ.TJ_HORACO1, STJ.TJ_HORACO2, "
		cQuery += " STJ.TJ_DTPPINI, STJ.TJ_HOPPINI, STJ.TJ_DTPPFIM, STJ.TJ_HOPPFIM, "
		cQuery += " STJ.TJ_DTPRINI, STJ.TJ_HOPRINI, STJ.TJ_DTPRFIM, STJ.TJ_HOPRFIM, "

		//-----------------------------------
		//código do usuário de inclusão
		//-----------------------------------
		cQuery += "CASE WHEN " + ValtoSql( cUserLog ) + " = " + fUserQuery()
		cQuery += "THEN 'true' ELSE '' END OWNER, "

		cQuery += " CASE WHEN STE.TE_CARACTE = 'P' "
		cQuery += " THEN 'P' Else 'C' END AS TYPE, "

		cQuery += " CASE "
		cQuery += "     WHEN STJ.TJ_SITUACA = 'C' THEN 'true' "
		cQuery += "     WHEN STJ.TJ_TERMINO = 'S' THEN 'true' "
		cQuery += "     WHEN STJ.D_E_L_E_T_ = '*' THEN 'true' "


		//-------------------------------------------------------------------------------------------------------------
		// O trecho abaixo realiza as condições de filtros do portal relacionados a usuário, deve ocorre apenas a
		// partir do segundo sync (quando a data vir preenchida) para identificar as ordens que devem ser deletadas do
		// app (quando um insumo foi deletado e não deve ser apresentado mais para determinado usuário)
		//-------------------------------------------------------------------------------------------------
		If cDate != '0' .And. ( lFilterByUser .Or. lSpecialties )

			//------------------------------------------
			//Retorna apenas OS's abertas pelo usuário
			//------------------------------------------
			cQuery += " WHEN ( (" + ValtoSql( cUserLog ) + " <> " + fUserQuery() + ") "
			cQuery += "  AND ( (SELECT COUNT(STL.TL_CODIGO) FROM "+ RetSQLName('STL') +" STL"
			cQuery += "       WHERE STL.TL_FILIAL = " + ValToSQL(xFilial("STL"))
			cQuery += "         AND STL.TL_ORDEM = STJ.TJ_ORDEM "
			cQuery += "         AND STL.D_E_L_E_T_ = ' ' AND ( "

			//-----------------------------------------
			// O.S's  do usuário logado
			//-----------------------------------------
			If lFilterByUser
				cQuery += " ( STL.TL_CODIGO = " + ValToSQL(AllTrim(cUserST1))
				cQuery += "		AND STL.TL_TIPOREG = 'M' )"

				If lSpecialties
					cQuery += "	OR "
				EndIf

			EndIf

			//-----------------------------------------------------------------------------------
			// Retorna apenas as O.S's que tenha pelo menos uma especialidade do usuário logado
			//-----------------------------------------------------------------------------------
			If lSpecialties
				cQuery += "( STL.TL_TIPOREG = 'E' AND STL.TL_CODIGO IN"
				cQuery +=  " ( SELECT ST2.T2_ESPECIA FROM " + RetSQLName('ST2') + " ST2"
				cQuery +=  " WHERE ST2.T2_FILIAL = " + ValToSQL(xFilial("ST2"))
				cQuery +=  "	AND ST2.D_E_L_E_T_ = ' '"
				cQuery +=  "	AND ST2.T2_CODFUNC = " + ValToSQL(AllTrim(cUserST1))
				cQuery +=  " GROUP BY ST2.T2_ESPECIA ) ) "

			EndIf

			cQuery += " ) ) = 0 "

			If lFilterUserSS

				//----------------------------------------------------
				// Vê se a OS não está atrelada a alguma SS
				//-----------------------------------------------------
				cQuery +=  " AND ( STJ.TJ_ORDEM NOT IN (" + QRequestOrders( oWs, '0', 'SORDER', .T. ) + "))"

			Endif

			cQuery += ") ) THEN 'true'

		EndIf

		cQuery += " Else 'FALSE' "
		cQuery += " END AS IS_DELETED "
		cQuery += " FROM " + RetSQLName('STJ') + " STJ "

	EndIf

	cQuery += " INNER JOIN " + RetSQLName('ST4') + " ST4 "
	cQuery += "     ON STJ.TJ_SERVICO = ST4.T4_SERVICO AND " + 	QService( oWS, '0', '', .T. )

	cQuery += " INNER JOIN " + RetSQLName('STE') + " STE "
	cQuery += "     ON STE.TE_TIPOMAN = ST4.T4_TIPOMAN "
	cQuery += "     AND TE_FILIAL = " + ValToSql( xFilial("STE",) )
	cQuery += "     AND STE.D_E_L_E_T_ = ' ' "

	cQuery += " INNER JOIN " + RetSQLName('STD') + " STD "
	cQuery += "	    ON ST4.T4_CODAREA = STD.TD_CODAREA "
	cQuery += "     AND TD_FILIAL = " + ValtoSql( xFilial('STD') )
	cQuery += "     AND STD.D_E_L_E_T_ = ' ' "

	cQuery += " LEFT JOIN " + RetSQLName('STF') + " STF "
	cQuery += "	    ON STF.TF_CODBEM = STJ.TJ_CODBEM "
	cQuery += "     AND STF.TF_SERVICO = STJ.TJ_SERVICO "
	cQuery += "     AND STF.TF_SEQRELA = STJ.TJ_SEQRELA "
	cQuery += "     AND STF.TF_ATIVO <> 'N' "
	cQuery += "     AND STF.D_E_L_E_T_ = ' ' "
	cQuery += "     AND STF.TF_FILIAL = " + ValtoSql( xFilial("STF") )

	cQuery += " WHERE STJ.TJ_FILIAL = " + ValtoSql(xFilial("STJ"))

	//---------------------------------------------------------------------------------
	// O trecho abaixo realiza as condições de filtros do portal relacionados a usuário, deve ocorre apenas a
	// no primeiro sync (quando a data não está preenchida) para identificar as ordens que devem aparecer
	// no app (quando o usuário gerou a ordem ou algum insumo pertence a ele)
	//-------------------------------------------------------------------------------------------------
	If cDate == '0' .And. ( lFilterByUser .Or. lSpecialties )

		//------------------------------------------
		//Retorna apenas OS's abertas pelo usuário
		//------------------------------------------
		cQuery += " AND ( (" + ValtoSql( cUserLog ) + " = " + fUserQuery()

		cQuery += ") OR ("
		cQuery += "(SELECT COUNT(STL.TL_CODIGO) FROM "+ RetSQLName('STL') +" STL"
		cQuery += " WHERE STL.TL_FILIAL = " + ValToSQL(xFilial("STL"))
		cQuery += " 	AND STL.TL_ORDEM = STJ.TJ_ORDEM "
		cQuery += "     AND STL.D_E_L_E_T_ = ' ' AND ( "

		//-----------------------------------------
		// Retorna apenas O.S's  do usuário logado,
		// conforme insumos previstos e realizados
		//-----------------------------------------
		If lFilterByUser

			cQuery += " ( STL.TL_CODIGO = " + ValToSQL(AllTrim(cUserST1))
			cQuery += " 	AND STL.TL_TIPOREG = 'M' ) "

			If lSpecialties
				cQuery += " OR "
			EndIf

		EndIf

		//-----------------------------------------------------------------------------------
		// Retorna apenas as O.S's que tenha pelo menos uma especialidade do usuário logado
		// conforme insumos previstos e realizados
		//------------------------------------------------------
		If lSpecialties
			cQuery +=  " ( STL.TL_TIPOREG = 'E' AND STL.TL_CODIGO IN "
			cQuery +=  "	(SELECT ST2.T2_ESPECIA FROM " + RetSQLName('ST2') + " ST2"
			cQuery +=  "		WHERE ST2.T2_FILIAL = " + ValToSQL(xFilial("ST2"))
			cQuery +=  "	    	AND ST2.D_E_L_E_T_ = ' '"
			cQuery +=  "			AND ST2.T2_CODFUNC = " + ValToSQL(AllTrim(cUserST1))
			cQuery +=  "		GROUP BY ST2.T2_ESPECIA ) ) "

		EndIf

		cQuery += " ) ) > 0 "

		If lFilterUserSS

			//----------------------------------------------------
			// Vê se a OS não está atrelada a alguma SS
			//-----------------------------------------------------
			cQuery +=  " OR ( STJ.TJ_ORDEM IN (" + QRequestOrders( oWs, '0', 'SORDER', .T. ) + "))"

		Endif

		cQuery += " ) )"

	EndIf

	//Retorna apenas se não houver nenhum insumo com usa calendário habilitado
	cQuery += " AND (SELECT COUNT(STL.TL_CODIGO) FROM "+ RetSQLName('STL') +" STL"
	cQuery += " WHERE STL.TL_FILIAL = "+ ValToSQL(xFilial("STL"))
	cQuery += "      AND STL.TL_ORDEM = STJ.TJ_ORDEM "
	cQuery += "      AND STL.D_E_L_E_T_ = ' ' "
	cQuery += " AND STL.TL_USACALE = 'S' "
	cQuery += ") = 0 "

	If Len(aProduct) > 1

		//Retorna apenas as ordens que não tenham insumo produto sem permissão para usuário
		cQuery += " AND ((SELECT COUNT(STL.TL_CODIGO) FROM "+ RetSQLName('STL') +" STL"
		cQuery += " WHERE STL.TL_FILIAL = "+ ValToSQL(xFilial("STL"))
		cQuery += "      AND STL.TL_ORDEM = STJ.TJ_ORDEM "
		cQuery += "      AND STL.D_E_L_E_T_ = ' ' "
		cQuery += "		 AND STL.TL_TIPOREG = 'P' "
		cQuery += MakeFilter( aProduct, "STL.TL_CODIGO" , .f.)

		If aProduct[1] == "reject"
			cQuery += ")) = 0 "
		ElseIf aProduct[1] == "filter"
			cQuery += ") > 0 "
			cQuery += " OR "

			cQuery += "  (SELECT COUNT(STL.TL_CODIGO) FROM "+ RetSQLName('STL') +" STL"
			cQuery += " WHERE STL.TL_FILIAL = "+ ValToSQL(xFilial("STL"))
			cQuery += "      AND STL.TL_ORDEM = STJ.TJ_ORDEM "
			cQuery += "      AND STL.D_E_L_E_T_ = ' ' "
			cQuery += "		 AND STL.TL_TIPOREG = 'P' "
			cQuery += ") = 0 ) "

		EndIf
	EndIf

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TJ_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TJ_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
		cQuery += " AND TJ_SITUACA <> 'P' "
	Else
		cQuery += "AND TJ_SITUACA = 'L' AND TJ_TERMINO <> 'S' "
		cQuery += "AND STJ.D_E_L_E_T_ = ' ' "
	EndIf

	// Busca por bens e localizações
	cQuery += " AND ( ( TJ_TIPOOS = 'B' AND TJ_CODBEM IN ( " + QEquipment( oWS, "0", "QOrder" ) + " ) ) "
	If aPermissions[ PERMISS_OS, 19 ] // location_order
		cQuery += "   OR ( TJ_TIPOOS = 'L' AND TJ_CODBEM IN ( " + QLocation( oWS, "0", "QOrder"  ) + " ) ) "
	EndIf
	cQuery += ")"

	// Considera cenários onde as localizações não possuem um centro de custo
	cQuery += " AND ( "
	If aPermissions[ PERMISS_OS, 19 ] // location_order
		cQuery += " ( TJ_TIPOOS = 'L' AND TJ_CCUSTO = ' ' ) OR "
	EndIf
	cQuery += " TJ_CCUSTO IN ( " + QCostCenter( oWS, "0", "QOrder" ) + " ) )"

	cQuery += " AND TJ_SERVICO IN ( " + QService( oWS, "0", "QOrder" ) + " )"

	If lPEMNTNG

		cFilter := ExecBlock( 'MNTNG', .F., .F., { 'FILTER_ORDER', oWS } )

		If !Empty( cFilter )
			cQuery += cFilter
		EndIf

	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sOrder
Gera um JSON contendo as informações de Ordens de Serviço para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sOrder( oWs, cDate )

	Local lSYP      := NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
	Local cDescri   := ""
	Local aFileName := {}
	Local cDtInicial
	Local cDtFinal
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := ChangeQuery( QOrder( oWs, cDate, "sOrder" ) )
	Local cAliasQry := GeraTemp( cQuery, 'Order' )


	aFileName := GenFileName( 'serviceorder' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			If !Empty((cAliasQry)->TJ_DTMPINI)
				cDtInicial := (cAliasQry)->TJ_DTMPINI
			Else
				cDtInicial := (cAliasQry)->TJ_DTORIGI
				printf('Ordem ' + (cAliasQry)->TJ_ORDEM + ' nao possui data inicial. Favor verificar.')
			EndIf

			If !Empty((cAliasQry)->TJ_DTMPFIM)
				cDtFinal := (cAliasQry)->TJ_DTMPFIM
			Else
				cDtFinal := (cAliasQry)->TJ_DTORIGI
				printf('Ordem ' + (cAliasQry)->TJ_ORDEM + ' nao possui data final. Favor verificar.')
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAliasQry)->TJ_ORDEM, .T. ) + '",'
			cSubJSON += '"plan":"' + NGEscape( (cAliasQry)->TJ_PLANO ) + '",'
			cSubJSON += '"equipment":"' + NGEscape( (cAliasQry)->TJ_CODBEM, .T. ) + '",'
			cSubJSON += '"service":"' + NGEscape( (cAliasQry)->TJ_SERVICO, .T. ) + '",'
			cSubJSON += '"sequence":"' + NGEscape( (cAliasQry)->TJ_SEQRELA ) + '",'
			cSubJSON += '"startDateTime":"' + cDtInicial + ' ' + NGEscape( (cAliasQry)->TJ_HOMPINI ) + '",'
			cSubJSON += '"endDateTime":"' + cDtFinal + ' ' + NGEscape( (cAliasQry)->TJ_HOMPFIM ) + '",'
			cSubJSON += '"type":"' + NGEscape( (cAliasQry)->TYPE ) + '",'
			cSubJSON += '"costCenterCode":"' + NGEscape((cAliasQry)->TJ_CCUSTO, .T. ) + '",'
			cSubJSON += '"originDate":"' + (cAliasQry)->TJ_DTORIGI + '",'

			//-----------------------------------------
			// Informações de parada do equipamento
			//-----------------------------------------

			If !Empty( (cAliasQry)->TJ_DTPPINI ) .And. !Empty( (cAliasQry)->TJ_HOPPINI ) // parada prevista inic
				cSubJSON += '"plannedDownTime":"' + (cAliasQry)->TJ_DTPPINI + ' ' + NGEscape( (cAliasQry)->TJ_HOPPINI ) + '",'
			EndIf

			If !Empty( (cAliasQry)->TJ_DTPPFIM ) .And. !Empty( (cAliasQry)->TJ_HOPPFIM ) // parada prevista fim
				cSubJSON += '"plannedUpTime":"' + (cAliasQry)->TJ_DTPPFIM + ' ' + NGEscape( (cAliasQry)->TJ_HOPPFIM ) + '",'
			EndIf

			If !Empty( (cAliasQry)->TJ_DTPRINI ) .And. !Empty( (cAliasQry)->TJ_HOPRINI ) // parada real inic
				cSubJSON += '"downTime":"' + (cAliasQry)->TJ_DTPRINI + ' ' + NGEscape( (cAliasQry)->TJ_HOPRINI ) + '",'
			EndIf

			If !Empty( (cAliasQry)->TJ_DTPRFIM ) .And. !Empty( (cAliasQry)->TJ_HOPRFIM ) // parada real fim
				cSubJSON += '"upTime":"' + (cAliasQry)->TJ_DTPRFIM + ' ' + NGEscape( (cAliasQry)->TJ_HOPRFIM ) + '",'
			EndIf

			//------------------------------------
			// Informações de contadores da OS
			//------------------------------------
			If ( (cAliasQry)->TJ_POSCONT > 0 .And. !Empty( (cAliasQry)->TJ_HORACO1 ) ) .OR. ;
				( (cAliasQry)->TJ_POSCON2 > 0 .And. !Empty( (cAliasQry)->TJ_HORACO2 ) )

				cSubJSON += '"counter":['

				If (cAliasQry)->TJ_POSCONT > 0 .And. !Empty( (cAliasQry)->TJ_HORACO1 )
					cSubJSON += '{"value":' + cValtoChar( (cAliasQry)->TJ_POSCONT ) + ','
					cSubJSON += '"time":"' + NGEscape( (cAliasQry)->TJ_HORACO1 ) + '"}'
				Else
					cSubJSON += '{}'//A primeira posição do array deve existir sempre
				EndIf

				If (cAliasQry)->TJ_POSCON2 > 0 .And. !Empty( (cAliasQry)->TJ_HORACO2 )
					cSubJSON += ',{"value":' + cValtoChar( (cAliasQry)->TJ_POSCON2 ) + ','
					cSubJSON += '"time":"' + NGEscape( (cAliasQry)->TJ_HORACO2 ) + '"}'
				EndIf

				cSubJSON += '],'

			EndIf

			If (cAliasQry)->OWNER == "true"
				cSubJSON += '"owner":true,'
			EndIf

			// Caso a O.S. seja do tipo localização adiciona o item LOCATION como true
			If (cAliasQry)->TJ_TIPOOS == 'L'
				cSubJSON += '"location":true,'
			EndIf

			dbSelectArea('STJ')
			dbGoTo( (cAliasQry)->R_E_C_N_O_ )

			If lSYP //Caso o MEMO esteja na SYP
				cDescri := NGMEMOSYP(STJ->TJ_MMSYP)
			Else
				cDescri := STJ->TJ_OBSERVA
			EndIf

			cSubJSON += '"description":"' + NGEscape( cDescri , .t. ) + '"'

			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->TJ_ORDEM, .T. )  + "+" + NGEscape( (cAliasQry)->TJ_PLANO ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		dbSelectArea(cAliasQry)
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )
	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sOrder: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T., aFileName }


//---------------------------------------------------------------------
/*/{Protheus.doc} QInputSO
Query para insumos da ordem de serviço

@author	Maria Elisandra de Paula
@since 03/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de insumos da ordem de serviço
/*/
//---------------------------------------------------------------------
Static Function QInputSO( oWs, cDate, cOrigin )

	Local cQuery := "SELECT STL.TL_ORDEM "
	Local cIsNull := IIf( Upper(AllTrim(TcGetDB())) == "ORACLE","NVL",IIf( Upper( AllTrim( TcGetDB() ) ) $ "DB2","COALESCE","ISNULL" ) )

	cQuery += ",STL.TL_PLANO, STL.TL_SEQRELA, STL.TL_TAREFA, STL.TL_TIPOREG, STL.TL_PERMDOE, "
	cQuery += "    STL.TL_CODIGO, STL.TL_QUANTID, STL.TL_QUANREC, STL.TL_UNIDADE, STL.TL_DESTINO, TL_OBSERVA,  "
	cQuery += "    STL.TL_DTINICI, STL.TL_HOINICI, STL.TL_DTFIM, STL.TL_HOFIM, STL.TL_LOCAL, STL.TL_SEQTARE, "
	cQuery += "    STL.TL_TIPOHOR, STL.TL_LOCALIZ, STL.TL_NUMSERI, STL.TL_LOTECTL, STL.TL_NUMLOTE, STL.TL_NUMSA, STL.TL_ITEMSA, "
	cQuery += "    STL.R_E_C_N_O_, "

	If aPermissions[ PERMISS_OS, 18 ] // ocurrences

		cQuery += cIsNull + "( STN.TN_CODOCOR, '' ) AS TN_CODOCOR, "
		cQuery += cIsNull + "( STN.TN_CAUSA  , '' ) AS TN_CAUSA  , "
		cQuery += cIsNull + "( STN.TN_SOLUCAO, '' ) AS TN_SOLUCAO, "
		cQuery += "STN.TN_DESCRIC, "
		cQuery += "STN.R_E_C_N_O_ AS RECNO_STN, "

	EndIf

	//colunas CP_PREREQU e CP_OK abaixo indicam quando há pre-requisicão de SA
	cQuery += cIsNull + "( CP_PREREQU,' ' ) CP_PREREQU,"
	cQuery += cIsNull + "( CP_OK, ' ') CP_OK, "

	//coluna QUOTATION abaixo indica quantidade de insumo com pedido ou cotação ( substitui a função NGBUSC1COM )
	cQuery += " CASE WHEN STL.TL_TIPOREG IN( 'T', 'P' ) "
	cQuery += "     THEN " + cIsNull + "(( "
	cQuery += "         SELECT SUM( "
	cQuery += "             CASE WHEN C1_PEDIDO <> ' ' THEN C1_QUJE "
	cQuery += "                 WHEN C1_COTACAO <> ' ' THEN C1_QUANT "
	cQuery += "	            ELSE 0 "
	cQuery += "             END ) QUANT "
	cQuery += "         FROM " + RetSQLName("SC1") + " SC1 "
	cQuery += "         WHERE SC1.D_E_L_E_T_= ' ' "
	cQuery += "             AND C1_FILIAL = " + ValtoSql( xFilial("SC1") )
	cQuery += "             AND STL.TL_ORDEM || 'OS001' = SC1.C1_OP "
	cQuery += "             AND STL.TL_CODIGO = C1_PRODUTO "
	cQuery += "             AND STL.TL_LOCAL = C1_LOCAL "
	cQuery += "         GROUP BY SC1.C1_OP, C1_PRODUTO, C1_LOCAL ), 0) "
	cQuery += " ELSE 0 "
	cQuery += " END AS QUOTATION, "

	cQuery += " CASE "
	cQuery += "    WHEN STJ.TJ_SITUACA = 'C' THEN 'true' "
	cQuery += "    WHEN STJ.TJ_TERMINO = 'S' THEN 'true' "
	cQuery += "    WHEN STJ.D_E_L_E_T_ = '*' THEN 'true' "
	cQuery += "    WHEN STL.D_E_L_E_T_ = '*' THEN 'true' "
	cQuery += " ELSE 'FALSE' "
	cQuery += " END AS IS_DELETED "

	cQuery += " FROM " + RetSQLName('STL') + " STL "
	cQuery += " INNER JOIN " + RetSQLName('STJ') + " STJ "
	cQuery += "  ON STJ.TJ_ORDEM = STL.TL_ORDEM "
	cQuery += "      AND STJ.TJ_PLANO = STL.TL_PLANO "
	cQuery += "      AND STJ.TJ_FILIAL = " + ValtoSql( xFilial("STJ") )

	cQuery += " LEFT JOIN " + RetSQLName("SCP") + " SCP "
	cQuery += "     ON STL.TL_NUMSA = SCP.CP_NUM "
	cQuery += "     AND STL.TL_ITEMSA = SCP.CP_ITEM "
	cQuery += "     AND SCP.CP_FILIAL = " + ValtoSql( xFilial("SCP") )
	cQuery += "     AND SCP.CP_PREREQU <> ' ' AND SCP.CP_OK <> ' ' "
	cQuery += "     AND SCP.D_E_L_E_T_ = ' ' "
	cQuery += "     AND STL.TL_TIPOREG IN( 'P', 'M', 'T')"

	If aPermissions[ PERMISS_OS, 18 ] // ocurrences

		cQuery += " LEFT JOIN " + RetSQLName( 'STN' ) + " STN ON "
		cQuery += 	" STN.TN_FILIAL  = " + ValToSQL( xFilial( 'STN' ) ) + " AND "
		cQuery += 	" STN.TN_ORDEM   = STL.TL_ORDEM   AND "
		cQuery += 	" STN.TN_PLANO   = STL.TL_PLANO   AND "
		cQuery += 	" STN.TN_TAREFA  = STL.TL_TAREFA  AND "
		cQuery += 	" STN.TN_SEQRELA = STL.TL_SEQRELA AND "
		cQuery += 	" STN.D_E_L_E_T_ = ' ' "

	EndIf

	cQuery += QOrder( oWs, cDate, '' )
	cQuery += " AND STL.TL_FILIAL = " + ValtoSql( xFilial("STL") )


	If cDate == "0"
		cQuery += " AND STL.D_E_L_E_T_ = ' ' "
	EndIf

	//Considera apenas os insumos (STL) que possuam relacionamento correto, não ocorrendo de enviar um insumo de um produto que não existe
	cQuery += " AND ((TL_TIPOREG = 'M' AND EXISTS (SELECT 1 FROM " + RetSQLName('ST1') + " ST1 "
	cQuery += "    WHERE TL_CODIGO = T1_CODFUNC AND ST1.D_E_L_E_T_ = ' ' AND T1_FILIAL = " + ValtoSql( xFilial("ST1") )

	cQuery += " )) OR (TL_TIPOREG = 'P' AND EXISTS (SELECT 1 FROM " + RetSQLName('SB1') + " SB1 "
	cQuery += "   WHERE TL_CODIGO = B1_COD AND " + QProduct( oWS, '0', '', .T. )

	cQuery += " )) OR (TL_TIPOREG = 'E' AND EXISTS (SELECT 1 FROM " + RetSQLName('ST0') + " ST0 "
	cQuery += "   WHERE TL_CODIGO = T0_ESPECIA AND ST0.D_E_L_E_T_ = ' ' AND T0_FILIAL = " + ValtoSql( xFilial("ST0") )

	cQuery += ")) OR (TL_TIPOREG = 'T' AND EXISTS (SELECT 1 FROM " + RetSQLName('SA2') + " SA2 "
	cQuery += "   WHERE TL_CODIGO = A2_COD AND " + QThirdPart( oWS, '0', '', .T. )

	cQuery += ")) OR (TL_TIPOREG = 'F' AND EXISTS (SELECT 1 FROM " + RetSQLName('SH4') + " SH4 "
	cQuery += "   WHERE TL_CODIGO = H4_CODIGO AND " + QTool( oWS, '0', '', .T. )
	cQuery += ")) ) "

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sInputSO
Gera um JSON contendo as informações de Insumos da OS para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sInputSO( oWs, cDate )

	Local aFileName := {}
	Local cOrder
	Local cPlan
	Local cTipo
	Local cCod
	Local cSeqTa
	Local cTask      := ''
	Local cSeqRe     := ''
	Local cTNObserva := ''
	Local cAuxJSON   := ''
	Local lFirstSTN  := .T.
	Local lEmptySTN  := .F.
	Local lFirst     := .T.
	Local lFirstD    := .T.
	Local nCount     := 0
	Local cHrIn      := Time()
	Local nDelete    := 0
	Local nUpdate    := 0
	Local cSubJSON   := ""
	Local lUsaLote   := SuperGetMV("MV_RASTRO",.F.,'N') == "S" //Indica se utiliza controle de rastro nos produtos
	Local lUsaLocal  := SuperGetMV("MV_LOCALIZ") == "S" //Indica se utiliza controle de localização nos produtos
	Local cTlObserva := ""
	Local cUsaIntEs  := SuperGetMv("MV_NGMNTES",.F.,"N")
	Local cQuery     := ChangeQuery( QInputSO( oWs, cDate, "sInputSO" ) + " ORDER BY TL_ORDEM " )
	Local cAliasQry  := GeraTemp( cQuery, 'InputSO' )

	aFileName := GenFileName( 'inputso' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		cOrder  := NGEscape( (cAliasQry)->TL_ORDEM, .T. )
		cPlan   := NGEscape( (cAliasQry)->TL_PLANO )
		cTask   := NGEscape( (cAliasQry)->TL_TAREFA, .T. )
		cTipo   := NGEscape( (cAliasQry)->TL_TIPOREG )
		cCod    := NGEscape( (cAliasQry)->TL_CODIGO, .T. )
		cSeqRe  := NGEscape( (cAliasQry)->TL_SEQRELA )
		cSeqTa  := NGEscape( (cAliasQry)->TL_SEQTARE )
		cPerc   := If( (cAliasQry)->TL_PERMDOE != Nil, (cAliasQry)->TL_PERMDOE, Nil)

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"order":"' + cOrder + '",'
			cSubJSON += '"plan":"' + cPlan + '",'
			cSubJSON += '"sequence":"' + cSeqRe + '",'
			cSubJSON += '"task":"' + cTask + '",'
			cSubJSON += '"taskSequence":"' + cSeqTa + '",'
			cSubJSON += '"percent":' + cValtoChar(cPerc) + ','
			cSubJSON += '"type":"' + cTipo + '",'
			cSubJSON += '"code":"' + cCod + '",'

			If (cAliasQry)->TL_TIPOREG != 'P' .And. Alltrim((cAliasQry)->TL_UNIDADE) == 'H' .And. (cAliasQry)->TL_TIPOHOR == 'S'
				cSubJSON += '"amount":' + cValtoChar(NGRETHORDDH((cAliasQry)->TL_QUANTID)[2]) + ','
			Else
				cSubJSON += '"amount":' + cValtoChar((cAliasQry)->TL_QUANTID) + ','
			EndIf
			cSubJSON += '"resourceAmount":' + cValtoChar((cAliasQry)->TL_QUANREC) + ','
			cSubJSON += '"unity":"' + NGEscape( (cAliasQry)->TL_UNIDADE ) + '",'
			cSubJSON += '"destiny":"' + NGEscape( (cAliasQry)->TL_DESTINO ) + '",'
			cSubJSON += '"startDateTime":"' + NGEscape( (cAliasQry)->TL_DTINICI ) + ' ' + NGEscape( (cAliasQry)->TL_HOINICI ) + '",'
			cSubJSON += '"endDateTime":"' + NGEscape( (cAliasQry)->TL_DTFIM ) + ' ' + NGEscape( (cAliasQry)->TL_HOFIM) + '",'
			cSubJSON += '"warehouse":"' + NGEscape( (cAliasQry)->TL_LOCAL ) + '",'

			If (cAliasQry)->TL_TIPOREG == "P"
				//Controle de rastro: 'L':controla somente Lote,'S':controla lote e sub-lote
				If lUsaLote .And. ! Empty((cAliasQry)->TL_LOTECTL)
					cSubJSON += '"lot":"' + (cAliasQry)->TL_LOTECTL + '",'
					cSubJSON += '"sublot":"' + (cAliasQry)->TL_NUMLOTE + '",'
				EndIf

				//Controle de localização: sim ou não
				If lUsaLocal .And. ( !Empty((cAliasQry)->TL_LOCALIZ) .Or. ! Empty((cAliasQry)->TL_NUMSERI) )
					cSubJSON += '"location":"' + (cAliasQry)->TL_LOCALIZ + '",'
					cSubJSON += '"serialnumber":"' + (cAliasQry)->TL_NUMSERI + '",'
				EndIf
			EndIf

			//Os campos abaixo só serão enviados caso os insumos possuam pre requisição
			If cUsaIntEs == "S" .And. !Empty( (cAliasQry)->CP_PREREQU ) .And. !Empty( (cAliasQry)->CP_OK  )
				cSubJSON += '"warehouseRequest":"' + (cAliasQry)->TL_NUMSA + '",'
				cSubJSON += '"warehouseItem":"' + (cAliasQry)->TL_ITEMSA + '",'
			EndIf

			//Caso tenha cotação de compras envia quantidade ---
			If (cAliasQry)->QUOTATION > 0
				cSubJSON += '"quotation":' + cValtoChar( (cAliasQry)->QUOTATION ) + ','
			EndIf

			cTlObserva := ""

			dbSelectArea("STL")
			dbGoTo( (cAliasQry)->R_E_C_N_O_ )
			If !Empty( STL->TL_OBSERVA )
				cTlObserva := Alltrim( STL->TL_OBSERVA )
				cTlObserva := StrTran( cTlObserva, '"', '\"' )
			EndIf

			cSubJSON += '"note":"' + NGEscape( cTlObserva , .t. ) + '"'

			If aPermissions[ PERMISS_OS, 18 ] .And. ( lEmptySTN := !Empty( (cAliasQry)->TN_CODOCOR ) ) // ocurrences

				cSubJSON  += ',"occurrences":['
				lFirstSTN := .T.
				cOrder    := (cAliasQry)->TL_ORDEM
				cPlan     := (cAliasQry)->TL_PLANO
				cTask     := (cAliasQry)->TL_TAREFA
				cSeqRe    := (cAliasQry)->TL_SEQRELA

				Do While (cAliasQry)->( !EoF() ) .And. (cAliasQry)->TL_ORDEM == cOrder .And. (cAliasQry)->TL_PLANO == cPlan .And.;
					(cAliasQry)->TL_TAREFA == cTask .And. (cAliasQry)->TL_SEQRELA == cSeqRe

					cAuxJSON := ','

					If lFirstSTN
						lFirstSTN := .F.
						cAuxJSON  := ''
					EndIf

					cSubJSON += cAuxJSON + '{'

					cSubJSON += '"problem":"'   + NGEscape( (cAliasQry)->TN_CODOCOR ) + '"'

					cSubJSON += IIf( !Empty( (cAliasQry)->TN_CAUSA )  , ',"cause":"'    + NGEscape( (cAliasQry)->TN_CAUSA )   + '"', '' )
					cSubJSON += IIf( !Empty( (cAliasQry)->TN_SOLUCAO ), ',"solution":"' + NGEscape( (cAliasQry)->TN_SOLUCAO ) + '"', '' )

					cTNObserva := ''

					dbSelectArea( 'STN' )
					dbGoTo( (cAliasQry)->RECNO_STN )
					If !Empty( STN->TN_DESCRIC )
						cSubJSON += ',"note":"' + NGEscape( StrTran( AllTrim( STN->TN_DESCRIC ), '"', '\"' ) , .T. ) + '"'
					EndIf

					cSubJSON += '}'

					(cAliasQry)->( dbSkip() )

				EndDo

				cSubJSON += ']'

			EndIf

			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )

		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + cOrder + "+" + cPlan + "+" + cTask + "+" + cTipo + "+" + cCod + "+" + cSeqRe + "+" + cSeqTa + '"'

			FWrite( nDelete, cSubJSON )

			lEmptySTN := .F.

		EndIf

		nCount++

		// Caso não exista ocorrência relacionada a este registro, pula para o proximo.
		If !lEmptySTN

			(cAliasQry)->( dbSkip() )

		EndIf

	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )

	printf("sInputSO: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QCheckSO
Query para etapas da ordem de serviço

@autor Maria Elisandra de Paula
@since 12/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de etapas da ordem de serviço
/*/
//---------------------------------------------------------------------
Static Function QCheckSO( oWs, cDate, cOrigin )

	Local cQuery := " SELECT STQ.TQ_ORDEM "

	If cOrigin == "sCheckSO"
		cQuery += ", STQ.TQ_PLANO, STQ.TQ_SEQTARE,STQ.TQ_SEQETA, STQ.TQ_TAREFA, STQ.TQ_ETAPA, "
		cQuery += "    STQ.TQ_CODFUNC, "
		cQuery += "    CASE  WHEN STJ.TJ_SITUACA = 'C' THEN 'true' "
		cQuery += "     WHEN STJ.TJ_TERMINO = 'S' THEN 'true' "
		cQuery += "     WHEN STQ.D_E_L_E_T_ = '*' THEN 'true' "
		cQuery += "    Else 'FALSE' END AS IS_DELETED "
	EndIf

	cQuery += " FROM " + RetSQLName('STQ') + " STQ "
	cQuery += " INNER JOIN " + RetSQLName('STJ') + " STJ "
	cQuery += " 	ON STJ.TJ_ORDEM = STQ.TQ_ORDEM AND STJ.TJ_PLANO = STQ.TQ_PLANO "
	cQuery += "		AND TJ_FILIAL = " + ValtoSql( xFilial("STJ") )
	cQuery += " INNER JOIN " + RetSQLName('TPA') + " TPA2"
	cQuery += "   ON TPA2.TPA_ETAPA = TQ_ETAPA"
	cQuery += "     AND TPA2.TPA_FILIAL = " + ValtoSql(xFilial("TPA"))
	cQuery += "     AND TPA2.D_E_L_E_T_ = ' ' "

	//Inicio da subquery que devolve de quais OS os insumos devem ser trazidos
	cQuery += QOrder( oWs, cDate, '' )
	cQuery += " AND STQ.TQ_FILIAL = " + ValtoSql( xFilial("STQ") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TJ_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TJ_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND STJ.TJ_SITUACA = 'L' "
		cQuery += " AND STJ.TJ_TERMINO = 'N' "
		cQuery += " AND STQ.D_E_L_E_T_ = ' ' "
	EndIf

	If cOrigin == "sCheckSO"

		cQuery += ' ORDER BY STQ.TQ_ORDEM, STQ.TQ_PLANO, '
		cQuery += 	' STQ.TQ_SEQTARE,'
		cQuery += 	' STQ.TQ_SEQETA,'
		cQuery += 	' STQ.TQ_TAREFA,'
		cQuery += 	' STQ.TQ_ETAPA'

	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sCheckSO
Gera um JSON contendo as informações de Etapas da OS para a sincronização
com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 02/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sCheckSO( oWs, cDate )

	Local cOrder
	Local cPlan
	Local cSeque
	Local cTare
	Local cCod
	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := ChangeQuery( QCheckSO( oWs, cDate, "sCheckSO") )
	Local cAliasQry := GeraTemp( cQuery, 'CheckSO' )

	aFileName := GenFileName( 'checkso' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		cOrder := NGEscape( (cAliasQry)->TQ_ORDEM, .T. )
		cPlan  := NGEscape( (cAliasQry)->TQ_PLANO )
		cSeque := NGEscape( (cAliasQry)->TQ_SEQTARE )
		cTare  := NGEscape( (cAliasQry)->TQ_TAREFA, .T. )
		cCod   := NGEscape( (cAliasQry)->TQ_ETAPA, .T. )

		// Tratamento para inconsistência do app quando o campo tarefa é vazio
		If Empty( cTare )
			cTare := '0'
		EndIf

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"order":"' + cOrder + '",'
			cSubJSON += '"plan":"' + cPlan + '",'
			cSubJSON += '"sequence":"' + cSeque + '",'
			cSubJSON += '"task":"' + cTare + '",'
			cSubJSON += '"code":"' + cCod + '",'
			cSubJSON += '"user":"' + NGEscape( (cAliasQry)->TQ_CODFUNC, .T. ) + '"'
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + cOrder + "+" + cPlan + "+" + cTare + "+" + cCod + "+" + cSeque + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sCheckSO: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QInputMain
Query para insumos da manutenção

@autor Maria Elisandra de Paula
@since 17/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de insumos da manutenção
/*/
//---------------------------------------------------------------------
Static Function QInputMain( oWs, cDate, cOrigin )

	Local cQuery := "SELECT STG.TG_CODBEM "

	If cOrigin == "sInputMain"
		cQuery += ", STG.TG_SERVICO, STG.TG_SEQRELA, STG.TG_TAREFA, STG.TG_TIPOREG, "
		cQuery += "       STG.TG_CODIGO, STG.TG_QUANTID, STG.TG_QUANREC, STG.TG_UNIDADE, STG.TG_DESTINO, "
		cQuery += "       STG.TG_LOCAL, "
		cQuery += "CASE "
		cQuery += "WHEN STF.D_E_L_E_T_ = '*' THEN 'true' "
		cQuery += "WHEN STG.D_E_L_E_T_ = '*' THEN 'true' "
		cQuery += "Else 'FALSE' "
		cQuery += "END AS IS_DELETED "
	EndIf

	cQuery += "FROM " + RetSQLName('STG') + " STG "
	cQuery += "INNER JOIN " + RetSQLName('STF') + " STF ON STF.TF_CODBEM = STG.TG_CODBEM AND STF.TF_SERVICO = STG.TG_SERVICO "
	cQuery += 		"AND STF.TF_SEQRELA = STG.TG_SEQRELA AND TF_FILIAL = " + ValtoSql( xFilial("STF") )
	cQuery += 		" AND STF.TF_ATIVO = 'S' AND STF.D_E_L_E_T_ = ' ' "
	cQuery += "WHERE STG.TG_FILIAL = " + ValtoSql( xFilial("STG") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TG_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TG_USERLGI" ) + " >= " + ValtoSql( cDate ) + " )"
	Else
		cQuery += "AND STG.D_E_L_E_T_ = ' '"
	EndIf

	//------------------------------------------------------
	// condição para enviar somente insumos das
	// manutenções que serão enviadas
	//-----------------------------------------------------
	cQuery += " AND STG.TG_CODBEM || STG.TG_SERVICO || STG.TG_SEQRELA "
	cQuery += "  IN ( " + QMaintenance( oWS, "0", '' ) + ")"

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sInputMain
Gera um JSON contendo as informações de Insumos da Manutenção para a
sincronização com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 05/04/2016
@param oWs, objeto, self do Webservice que contém os headers
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sInputMain( oWs, cDate )

	Local cCodBem
	Local cService
	Local cTarefa
	Local cTipo
	Local cCode
	Local cSeqRe
	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local nCount    := 0
	Local cQuery    := ChangeQuery( QInputMain( oWs, cDate, "sInputMain") )
	Local cAliasQry := GeraTemp( cQuery, 'InputMain' )

	aFileName := GenFileName( 'inputmain' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		cCodBem  := NGEscape( (cAliasQry)->TG_CODBEM, .T. )
		cService := NGEscape( (cAliasQry)->TG_SERVICO, .T. )
		cSeqRe   := NGEscape( (cAliasQry)->TG_SEQRELA )
		cTarefa  := NGEscape( (cAliasQry)->TG_TAREFA, .T. )
		cTipo    := NGEscape( (cAliasQry)->TG_TIPOREG )
		cCode    := NGEscape( (cAliasQry)->TG_CODIGO, .T. )

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"equipment":"' + cCodBem + '",'
			cSubJSON += '"service":"' + cService + '",'
			cSubJSON += '"sequence":"' + cSeqRe + '",'
			cSubJSON += '"task":"' + cTarefa + '",'
			cSubJSON += '"type":"' + cTipo + '",'
			cSubJSON += '"code":"' + cCode + '",'
			cSubJSON += '"amount":"' + cValToChar((cAliasQry)->TG_QUANTID) + '",'
			cSubJSON += '"resourceAmount":"' + cValToChar((cAliasQry)->TG_QUANREC ) + '",'
			cSubJSON += '"unity":"' + NGEscape( (cAliasQry)->TG_UNIDADE ) + '",'
			cSubJSON += '"destiny":"' + NGEscape( (cAliasQry)->TG_DESTINO ) + '",'
			cSubJSON += '"warehouse":"' + NGEscape( (cAliasQry)->TG_LOCAL, .T. ) + '"'
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + cCodBem + "+" + cService + "+" + cSeqRe + "+" + cTarefa + "+" + cTipo + "+" + cCode + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sInputMain: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return { .T. , aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} QCheckMain
Query para etapas da manutenção

@autor Maria Elisandra de Paula
@since 17/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de etapas da manutenção
/*/
//---------------------------------------------------------------------
Static Function QCheckMain( oWs, cDate, cOrigin )

	Local cQuery := " SELECT STH.TH_CODBEM , STH.TH_SERVICO, STH.TH_SEQRELA,

	cQuery +=  "STH.TH_TAREFA, STH.TH_ETAPA, "
	cQuery += " STH.TH_SEQETA, "
	cQuery += " (SELECT ST5.T5_SEQUENC FROM " + RetSQLName('ST5') + " ST5 "
	cQuery += " 	WHERE ST5.T5_FILIAL = STH.TH_FILIAL "
	cQuery += " 		AND ST5.T5_CODBEM = STH.TH_CODBEM "
	cQuery += "      	AND ST5.T5_SERVICO = STH.TH_SERVICO "
	cQuery += "     	AND ST5.T5_SEQRELA = STH.TH_SEQRELA "
	cQuery += "			AND ST5.T5_TAREFA = STH.TH_TAREFA "
	cQuery += "      	AND ST5.D_E_L_E_T_ = ' ' ) AS SEQUENC, "
	cQuery += " CASE "
	cQuery += " WHEN STF.D_E_L_E_T_ = '*' THEN 'true' "
	cQuery += " WHEN STH.D_E_L_E_T_ = '*' THEN 'true' "
	cQuery += " Else 'FALSE' "
	cQuery += " END AS IS_DELETED "

	cQuery += " FROM " + RetSQLName('STH') + " STH "
	cQuery += " INNER JOIN " + RetSQLName('STF') + " STF "
	cQuery += "    ON STF.TF_CODBEM = STH.TH_CODBEM "
	cQuery += "      AND STF.TF_SERVICO = STH.TH_SERVICO "
	cQuery += "      AND STF.TF_SEQRELA = STH.TH_SEQRELA "
	cQuery += "      AND TF_FILIAL = " + ValtoSql( xFilial("STF") )
	cQuery += "      AND STF.TF_ATIVO = 'S'"
	cQuery += " WHERE STH.TH_FILIAL = " + ValtoSql( xFilial("STH") )

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TH_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TH_USERLGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND STF.D_E_L_E_T_ = ' ' AND STH.D_E_L_E_T_ = ' ' "
	EndIf

	//------------------------------------------------------
	// condição para enviar somente etapas das
	// manutenções que serão enviadas
	//-----------------------------------------------------
	cQuery += " AND STH.TH_CODBEM || STH.TH_SERVICO || STH.TH_SEQRELA "
	cQuery += "  IN(" + QMaintenance( oWS, "0", '' ) + ")"
	cQuery += "  ORDER BY STH.TH_CODBEM, STH.TH_SERVICO, STH.TH_SEQRELA, SEQUENC, STH.TH_SEQETA "

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sCheckMain
Gera um JSON contendo as informações de Etapas da Manutenção para a
sincronização com o aplicativo Mobile

@author	Larissa Thaís de Farias
@since 05/04/2016
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sCheckMain( oWs, cDate )

	Local cCodBem   := ""
	Local cServic   := ""
	Local cSeque    := ""
	Local cTare     := ""
	Local cCode     := ""
	Local aFileName := {}
	Local lFirst    := .T.
	Local lFirstD   := .T.
	Local nCount    := 0
	Local cHrIn     := Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := ChangeQuery( QCheckMain( oWs, cDate, "sCheckMain" ) )
	Local cAliasQry := GeraTemp( cQuery, 'CheckMain' )

	aFileName := GenFileName( 'checkmain' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		cCodBem := NGEscape( (cAliasQry)->TH_CODBEM, .T. )
		cServic := NGEscape( (cAliasQry)->TH_SERVICO )
		cSeque  := NGEscape( (cAliasQry)->TH_SEQRELA )
		cTare   := NGEscape( (cAliasQry)->TH_TAREFA, .T. )
		cCode   := NGEscape( (cAliasQry)->TH_ETAPA, .T. )

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"equipment":"' + cCodBem + '",'
			cSubJSON += '"service":"' + cServic + '",'
			cSubJSON += '"sequence":"' + cSeque + '",'
			cSubJSON += '"task":"' + cTare + '",'
			cSubJSON += '"code":"' + cCode + '"'
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + cCodBem + "+" + cServic + "+" + cSeque + "+" + cTare + "+" + cCode + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sCheckMain: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

 Return { .T., aFileName }

//---------------------------------------------------------------------
/*/{Protheus.doc} NextIdentifier
Gera um nome de arquivo baseado nos caracteres ASCII em um tamanho
específico com o objetivo de obter um código único em um contexto
limitado.

@author Marcelo Camargo
@since  29/01/18
@param  nSize - Tamanho do identificador
@return Character, nome para arquivo
/*/
//---------------------------------------------------------------------
Static Function NextIdentifier( nSize )
	Local cIdentifier := FWTimeStamp(1) //data e hora
	Local nIndex
	For nIndex := 1 To nSize
		cIdentifier += Chr( Randomize( /* A */ 65, /* Z */ 90 ) )
	Next
Return cIdentifier

//---------------------------------------------------------------------
/*/{Protheus.doc} fSaveImg
Faz upload da imagem vinda do webservice e grava no banco de
conhecimento fazendo referência à ordem de serviço.

@author Marcelo Camargo
@autor Maria Elisandra de Paula
@since  10/01/18
@param  oSelf, objeto, objeto, instância do webservice
@param  cKey, string, código da ordem de serviço or SS
@param  cType, string, tipo da imagem: PROBLEM/SOLUTION/SIGNATURE
@para cTable, string, 'TQB' ou 'STJ'
@return array, [1] se obteve sucesso,
               [2] informações da imagem gravada ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function fSaveImg( oSelf, cKey, cType, cTable )

	Local cDocPath
	Local cObject
	Local cFilePath
	Local nHandler
	Local cObjCode
	Local oResponse
	Local nNameSize  := 5
	Local cDateTime  := DToC( Date() ) + ' ' + Time()
	Local cMsDocPath := IIf(isSRVunix(), Lower(StrTran( MsDocPath(),'\', '/')),MsDocPath())
	Local aBinImagem := {}
	Local aRet       := {.T.}
	Local cError     := ''
	Local nCodeRest  := 0
	Local cOrder     := cKey

	If cTable == 'STJ'
		// Garante existência da ordem de serviço
		dbSelectArea( 'STJ' )
		dbSetOrder( 1 )
		If dbSeek( xFilial( 'STJ' ) + cOrder )
			If STJ->TJ_SITUACA == 'C'
				// Retorna mensagem de erro somente para o server com o código referente as alterações de uma O.S. já cancelada.
				cError    := 'Ordem de servico ja cancelada ' + cOrder + '. ' + DtoC( dDataBase ) + ' ' + Time()
				nCodeRest := CANCELCODE
			ElseIf STJ->TJ_TERMINO == 'S'
				// Retorna mensagem de erro somente para o server com o código referente as alterações de uma O.S. já finalizada.
				cError    := 'Ordem de servico ja finalizada ' + cOrder + '. ' + DtoC( dDataBase ) + ' ' + Time()
				nCodeRest := FINISHCODE
			EndIf
		Else
			cError := STR0024 // "Ordem de serviço não encontrada"
		EndIf

		If !Empty( cError )
			Return { .F., cError, , nCodeRest }
		EndIf		

	ElseIf !NGIFDBSEEK("TQB", cKey, 1)
		aRet := {.F., STR0145 } //"Solicitação não localizada."
		If !aRet[1]
			Return aRet
		EndIf
	EndIf

	aBinImagem := fGetBinImg( oSelf )

	If !Empty( aBinImagem[1] )
		Return { .F., aBinImagem[1] }
	EndIf

	cDocPath := cMsDocPath
	cObject  := NextIdentifier( nNameSize ) + '.jpg'
	// Enquanto existirem nomes conflitantes, geramos outro
	While File( cDocPath + cBarra + cObject )
		cObject := NextIdentifier( nNameSize ) + '.jpg'
	EndDo

	// Abrimos um ponteiro para o novo arquivo para depositar os bytes
	cFilePath := cDocPath + cBarra + cObject
	nHandler := FCreate( cFilePath, Nil, Nil, .F. )
	If nHandler == -1
		Return { .F., STR0018 + " " + AllTrim( Str( FError() ) ) } // "Erro ao criar arquivo no servidor"
	EndIf
	FWrite( nHandler, aBinImagem[ 2 ] )
	FClose( nHandler )

	aBinImagem := Nil
	FreeObj( aBinImagem )

	// Posicionar na tabela de objetos
	dbSelectArea( 'ACB' )
	dbSetOrder( 2 ) // ACB_FILIAL + ACB_OBJETO
	// Arquivo não possui registro na base, então adicionamos
	If !dbSeek( xFilial( 'ACB' ) + cObject )
		RecLock( 'ACB', .T. )
		cObjCode := GetSXEnum( 'ACB', 'ACB_CODOBJ' )
		ACB->ACB_FILIAL := xFilial( 'ACB' )
		ACB->ACB_CODOBJ := cObjCode
		ACB->ACB_OBJETO := cObject
		ACB->ACB_DESCRI := cType + ' ' + cDateTime
		MsUnlock()
		ConfirmSX8()

		// Gravar vínculos entre objetos e ordem na AC9
		dbSelectArea( 'AC9' )
		dbSetOrder( 1 ) // AC9_FILIAL + AC9_CODOBJ + AC9_ENTIDA + AC9_FILENT + AC9_CODENT

		If !dbSeek( xFilial( 'AC9' ) + cObjCode + cTable + xFilial( 'STJ' ) + cKey )
			RecLock( 'AC9', .T. )
			AC9->AC9_FILIAL := xFilial( 'AC9' )
			AC9->AC9_FILENT := xFilial( cTable )
			AC9->AC9_ENTIDA := cTable
			AC9->AC9_CODENT := cKey
			AC9->AC9_CODOBJ := cObjCode
			MsUnlock()
		EndIf
	EndIf

	oResponse := MntOrderAttachment():New( cObjCode )
	oResponse:Path     := '/picture/' + AllTrim( cObject )
	oResponse:Date     := cDateTime
	oResponse:Type     := cType
	oResponse:FileName := cObject

Return { .T., FWJsonSerialize( oResponse, .F. ) }

//---------------------------------------------------------------------
/*/{Protheus.doc} DelOrderFile
Remove um arquivo do banco de conhecimento baseado no vínculo da AC9.
Remove o arquivo do repositório e deleta logicamente a entrada da ACB e
o vínculo da AC9.

@author Marcelo Camargo
@since  12/01/18
@param  cId, string, ID (código do objeto) da AC9
@param  oSelf, objeto, objeto, instância do webservice
@return array, [1] se obteve sucesso,
               [2] json ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function DelOrderFile( cId, oSelf )

	Local cAliasQry  := GetNextAlias()
	Local cMsDocPath := If(isSRVunix(), Lower(StrTran( MsDocPath(),'\', '/')),MsDocPath())
	Local cDocPath   := cMsDocPath + cBarra

	BeginSql Alias cAliasQry
		SELECT AC9_CODENT, ACB_OBJETO
		FROM %table:AC9% AC9
		INNER JOIN %table:ACB% ACB
			ON ACB_CODOBJ = AC9_CODOBJ
		WHERE
			AC9_FILIAL = %xFilial:AC9% AND
			AC9_FILENT = %xFilial:STJ% AND
			AC9_ENTIDA = 'STJ' AND
			AC9_CODOBJ = %Exp:cId% AND
			AC9.%NotDel% AND
			ACB.%NotDel%
	EndSql

	If Empty( ( cAliasQry )->AC9_CODENT )
		Return { .F., STR0069 } // "Não há ordem de serviço vinculada à imagem"
	EndIf

	// Remover vínculo de entidades (deleção lógica)
	dbSelectArea( 'AC9' )
	dbSetOrder( 2 ) // AC9_FILIAL + AC9_ENTIDA + AC9_FILENT + AC9_CODENT + AC9_CODOBJ
	If dbSeek( xFilial( 'AC9' ) + 'STJ' + xFilial( 'STJ' ) + ( cAliasQry )->AC9_CODENT + cId )
		RecLock( 'AC9', .F. )
		dbDelete()
		MsUnlock()
	EndIf

	// Remover registro textual do banco de objetos (deleção lógica)
	dbSelectArea( 'ACB' )
	dbSetOrder( 1 ) // ACB_FILIAL + ACB_CODOBJ
	If dbSeek( xFilial( 'ACB' ) + cId )
		RecLock( 'ACB', .F. )
		dbDelete()
		MsUnlock()
	EndIf

	// Remover arquivo físico do banco de conhecimento
	If File( cDocPath + ( cAliasQry )->ACB_OBJETO )
		FErase( cDocPath + ( cAliasQry )->ACB_OBJETO )
	EndIf

	( cAliasQry )->( dbCloseArea() )
Return { .T., '{}' }

//---------------------------------------------------------------------
/*/{Protheus.doc} UplWorkerPic
Realiza o upload e save da foto do funcionário

@author	Marcelo Camargo
@since	22/04/16
@param cEquipment, string, código do funcionário
@param oSelf, objeto, classe de webservice
@return logic, se obteve sucesso no upload da imagem
/*/
//---------------------------------------------------------------------
Static Function UplWorkerPic( cWorker, oSelf )
	Local cPath := cCurDir  + 'worker'
	Local cFilePath
	Local nHandler
	Local cRecNo
	Local cObject
	Local lRet       := .T.
	Local aBinImagem := {}

	dbSelectArea( 'ST1' )
	dbSetOrder( 1 )
	If dbSeek( xFilial( 'ST1' ) + Upper( cWorker ) )

		// Recupera o valor em base64 da imagem e decodifica-o
		aBinImagem := fGetBinImg( oSelf )
		If !Empty( aBinImagem[1] )
			SetRestFault( 403, EncodeUtf8( aBinImagem[1] ) )
			lRet := .F.

		Else

			If !ExistDir( cPath )
				MakeDir( cPath )
			EndIf

			// Substituir cache existente
			cFilePath := cPath + cBarra + cWorker + '.jpg'
			If File( cFilePath )
				FErase( cFilePath )
			EndIf

			nHandler := FCreate( cFilePath, Nil, Nil, .F. )
			If nHandler == -1
				SetRestFault( 403, EncodeUtf8(STR0018 + " " + AllTrim(Str(FError())))) // "Erro ao criar arquivo no servidor"
				lRet := .F.
			Else
				FWrite( nHandler, aBinImagem[ 2 ] )
				FClose( nHandler )

				aBinImagem := Nil
				FreeObj( aBinImagem )

				cRecNo  := ST1->( RecNo() )
				cObject := StartJob( 'InsertBitmap', GetEnvServer(), .T., cFilePath, 'W_' + ST1->T1_CODFUNC, cEmpAnt, cFilAnt )
				dbGoTo( cRecNo )
				RecLock( 'ST1', .F. )
				ST1->T1_BITMAP := cObject
				MsUnlock()

			EndIf

		EndIf

	Else
		lRet := .F.
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} UplEquipPic
Realiza o upload e save da foto do equipamento

@author	Marcelo Camargo
@since	22/04/16
@param cEquipment, string, código do Equipamento
@param oSelf, objeto, classe de webservice
@return logic, se obteve sucesso ao salvar imagem
/*/
//---------------------------------------------------------------------
Static Function UplEquipPic( cEquipment, oSelf )
	Local cPath := cCurDir  + 'equipment'
	Local cFilePath
	Local nHandler
	Local cRecNo
	Local cObject
	Local lRet       := .T.
	Local aBinImagem := {}

	dbSelectArea( 'ST9' )
	dbSetOrder( 1 )
	If dbSeek( xFilial( 'ST9' ) + Upper( cEquipment ) )

		// Recupera o valor em base64 da imagem e decodifica-o
		aBinImagem := fGetBinImg( oSelf )
		If !Empty( aBinImagem[1] )
			SetRestFault( 403, EncodeUtf8( aBinImagem[1] ) )
			lRet := .F.

		Else

			If !ExistDir( cPath )
				MakeDir( cPath )
			EndIf

			// Substituir cache existente
			cFilePath := cPath + cBarra + cEquipment + '.jpg'
			If File( cFilePath )
				FErase( cFilePath )
			EndIf

			nHandler := FCreate( cFilePath, Nil, Nil, .F. )
			If nHandler == -1
				SetRestFault( 403, EncodeUtf8(STR0018+ " " + AllTrim(Str(FError())) )) // "Erro ao criar arquivo no servidor"
				lRet := .F.
			Else
				FWrite( nHandler, aBinImagem[ 2 ] )
				FClose( nHandler )

				aBinImagem := Nil
				FreeObj( aBinImagem )

				cRecNo  := ST9->( RecNo() )
				cObject := StartJob( 'InsertBitmap', GetEnvServer(), .T., cFilePath, 'E_' + ST9->T9_CODBEM, cEmpAnt, cFilAnt )
				dbGoTo( cRecNo )
				RecLock( 'ST9', .F. )
				ST9->T9_BITMAP := cObject
				MsUnlock()

			EndIf

		EndIf

	Else
		lRet := .F.
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fEquiPic
Realiza o download da foto do Equipamento

@author	Larissa Thaís de Farias
@author Marcelo Camargo
@since	31/03/16
@param cEquipment, string, código do Equipamento
@param oSelf, objeto, classe de webservice
@return logic, se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function fEquiPic( cEquipment, oSelf )
	Local cPath
	Local cFilePath

	dbSelectArea( 'ST9' )
	dbSetOrder( 1 )
	If dbSeek( xFilial( 'ST9' ) + Upper( cEquipment ) ) .And. !Empty( ST9->T9_BITMAP )
		cPath := cCurDir + 'equipment'

		// Pasta de extração pode ter sido coletada pelo GC
		If !ExistDir( cPath )
			MakeDir( cPath )
		EndIf

		cFilePath := cPath + cBarra + cEquipment + '.jpg'

		// Caso não haja arquivo em cache, extraímos, senão reaproveitamos
		If !File( cFilePath ) .And. !StartJob( 'ExtractBitmap', GetEnvServer(), .T., ST9->T9_BITMAP, cFilePath, cEmpAnt, cFilAnt )
			Return .F.
		EndIf

		Return fImage( oSelf, cFilePath,lMingle )
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} createSO
Realiza a criação da OS

@author	Larissa Thaís de Farias
@author	Vitor Emanuel Batista
@author	Maria Elisandra de paula
@since 28/03/16
@param oWs, objeto, objeto que contém os dados da OS para a inclusão
@return array, [1]se obteve sucesso, [2]json para retorno
/*/
//---------------------------------------------------------------------
Static Function createSO( oWs )

	Local aArray     := {}
	Local aChecklist := {}
	Local oInputs    := {}
	Local aStartDate := {}
	Local aEndDate   := {}
	Local aRetSR     := {}
	Local oParser
	Local cError     := ""
	Local cType      := ""
	Local cObservation := ""
	Local aCounter   := {}	//armazena os dados referente a contadores
	Local cService   := ""
	Local cEquipment := ""
	Local cSequence  := ""
	Local cBemLoc  := "B"
	Local lSYP    := NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
	Local cOrdem     := ""
	Local lRet := .T.
	Local nCounter1 := 0
	Local nCounter2 := 0
	Local cHour1    := ''
	Local cHour2    := ''
	Local cJson    := oWs:GetContent()
	Local dDtOrigin:= ctod("  /  /  ")
	Local cCode    := ""
	Local cPlan    := ""
	Local aOSGeradas:= {}
	Local aSSGeradas:= {}
	Local aRetEtapas:= {}
	Local aNoSTQ 	:= {}
	Local cUsaIntEs := SuperGetMv("MV_NGMNTES",.F.,"N")
	Local dMvUlmes  := SuperGetMv("MV_ULMES",.F.,Stod(""))
	Local dDtStopIni := Ctod(' / / ')
	Local cHrStopIni := ""
	Local dDtStopFin := Ctod(' / / ')
	Local cHrStopFin := ""
	Local xValue

	// Limpa variáveis Static
	aETAPAS      := {}

	If FWJsonDeserialize(cJson,@oParser)

		//---------------------------------------------------------------------------
		// Trecho abaixo abre as tabelas para tratar msg "AJUSTAR PARAMETRO MV_DOCSEQ"
		//---------------------------------------------------------------------------

		If Select('SD1') <= 0
			dbSelectArea('SD1')
		EndIf
		If Select('SD2') <= 0
			dbSelectArea('SD2')
		EndIf
		If Select('SD3') <= 0
			dbSelectArea('SD3')
		EndIf

		If !AttIsMemberOf( oParser, "serviceRequest" )

			//------------------------------
			//Preenche os campos
			//------------------------------
			aStartDate   := StrTokArr(oParser:startDate, " ")
			cObservation := oParser:observation
			cService     := Upper(PADR(oParser:service,6))
			aEndDate     := StrTokArr(oParser:endDate, " ")
			cEquipment   := Upper(PADR(oParser:equipment,16))
			aChecklist   := oParser:checklist
			oInputs      := oParser:inputs
			dDtOrigin    := StoD(aStartDate[1])
			cSequence    := IIf( AttIsMemberOf( oParser, 'sequence' ), PadR( oParser:sequence, 3 ), '0  ' )
			cType        := IIf( AttIsMemberOf( oParser, 'type' ), oParser:type, IIf( Trim( cSequence ) == '0', 'C', 'P' ) )

			If !Empty(cError)
				Return {.f.,cError}
			EndIf

			If !AttIsMemberOf( oParser, "location" )

				// Valida se o equipamento não encontra-se inativo desde a ultima sincronização.
				If !fcheckEquip( cEquipment, @cError )
					Return { .F., cError }
				EndIf

				// Valida se a manutenção encontra-se inativa desde a ultima sincronização.
				If cType == 'P' .And. !fcheckMain( cEquipment, cService, cSequence, @cError )
					Return { .F., cError }
				EndIf

			Else

				//----------------------------------------------------------
				// Validação do Tipo de OS quando Localização
				//----------------------------------------------------------
				If cType == "P"
					Return { .F., STR0172 } // "Não é possível abrir ordens de serviço preventivas para localizações."
				EndIf

				cBemLoc := "L"

			EndIf

			If cUsaIntEs == "S" .And. dDtOrigin <= dMvUlmes
				Return { .f., STR0085 + " " + Dtoc( dMvUlmes ) } //"A data da ordem de serviço não pode ser menor ou igual a data do último fechamento do estoque "
			EndIf

			//------------------------------------------
			//Atualiza informações de contador da ordem
			//------------------------------------------
			If AttIsMemberOf( oParser, "counter" ) .And. Len( aCounter := oParser:counter ) > 0

				If AttIsMemberOf( aCounter[1], "value" ) .And. ( nCounter1 := aCounter[1]:value ) > 0

					If AttIsMemberOf( aCounter[1], "time" )
						cHour1 := aCounter[1]:time
					ElseIf AttIsMemberOf( aCounter[1], "datetime" ) //Para atender versões antigas do app
						cHour1 := StrTokArr(aCounter[1]:datetime," ")[2]
					EndIf

				EndIf

				//segundo contador da ordem
				If Len( aCounter ) > 1 .And. AttIsMemberOf( aCounter[2], "value" ) ;
					.And. ( nCounter2 := aCounter[2]:value ) > 0

					If AttIsMemberOf( aCounter[2], "time" )
						cHour2 := aCounter[2]:time
					ElseIf AttIsMemberOf( aCounter[2], "datetime" )//Para atender versões antigas do app
						cHour2 := StrTokArr(aCounter[2]:datetime," ")[2]
					EndIf

				EndIf

			EndIf

			If Empty(cObservation)
				cObservation := ""
			EndIf

			//------------------------------------------
			// Informações de parada de equipamento
			//------------------------------------------
			If AttIsMemberOf( oParser, "downTime" )
				xValue := StrTokArr( oParser:downTime, " " )
				If !Empty( xValue[1] ) .And. !Empty( xValue[2] )
					dDtStopIni := Stod( xValue[1] )
					cHrStopIni := xValue[2]
				EndIf
			EndIf

			If AttIsMemberOf( oParser, "upTime" )
				xValue := StrTokArr( oParser:upTime, " " )
				If !Empty( xValue[1] ) .And. !Empty( xValue[2] )
					dDtStopFin := Stod( xValue[1] )
					cHrStopFin := xValue[2]
				EndIf
			EndIf

			//----------------------------------------------------------
			// Validação das datas de parada
			//----------------------------------------------------------
			If !Empty( dDtStopIni ) .And. !Empty( cHrStopIni ) .And. ;
				!Empty( dDtStopFin ) .And. !Empty( cHrStopFin ) .And. ;
				Dtos( dDtStopIni ) + cHrStopIni > Dtos( dDtStopFin ) + cHrStopFin

				cError := STR0160 // "A data e hora fim de parada não pode ser menor que a data e hora inicial."

			EndIf

			If !Empty(cError)
				Return { .f. ,cError}
			EndIf

			// Inicializa array aInputs contendo os insumos previstos e realizados.
			cError := getInputs( oInputs, , , cEquipment )

			If !Empty(cError)
				Return { .f. ,cError}
			EndIf

			//Inicializa variaveis de aETAPAS
			cError := getCheckList( aChecklist, , , cType, cEquipment, cService, cSequence )
			If !Empty(cError)
				Return { .f. , cError}
			EndIf

			//Verifica se a OS já foi criada e não houve a atualização com o Mobile por queda de conexão
			printf("Verificando se ordem de servico ja existe. ")
			cOrdem :=  fEqualOrder( aStartDate, cObservation, nCounter1, nCounter2, cService,;
									aEndDate, cEquipment, cSequence, cType, dDtStopIni, cHrStopIni )

			If Empty(cOrdem)
				printf("Validando a ordem de servico. ")
				cError := fValidIns("","", 3)
				If !Empty(cError)
					Return { .f. , cError}
				EndIf

				//Ponto de entrada para validações antes da inclusão da ordem de serviço
				If Empty( cError ) .And. lPeMntNg
					cError := ExecBlock( 'MNTNG', .F., .F., { 'CREATE_VALID_ORDER', oWs } )
				EndIf

				If !Empty(cError)
					Return { .f. , cError }
				EndIf

				//----------------------------------
				//Valida contadores da ordem
				//----------------------------------
				If nCounter1 > 0 .And. !Empty( cHour1 )
					cError := ValidCounter( cEquipment, nCounter1, dDtOrigin, cHour1, 1 )
				EndIf

				If Empty( cError ) .And. nCounter2 > 0 .And. !Empty( cHour2 )
					cError := ValidCounter( cEquipment, nCounter2, dDtOrigin, cHour2, 2 )
				EndIf

				//----------------------------------
				// Aplica contadores da ordem
				//----------------------------------
				If Empty( cError )

					If nCounter1 > 0 .And. !Empty( cHour1 )
						NGTRETCON( cEquipment, dDtOrigin, nCounter1, cHour1, 1 )
					EndIf

					If nCounter2 > 0 .And. !Empty( cHour2 )
						NGTRETCON( cEquipment, dDtOrigin, nCounter2, cHour2, 2 )
					EndIf

				EndIf

				If !Empty(cError)
					Return { .f. , cError }
				EndIf

				printf("Incluindo ordem de servico. ")

				//------------------------------
				// Gera a O.S
				//------------------------------
				aArray := NGGERAOS(cType,dDtOrigin,cEquipment,cService,cSequence,"S","S","S",,"L",.F.,.F.,,cBemLoc)

				//------------------------------
				//Verifica se a O.S foi aberta com sucesso
				//------------------------------
				If aArray[1][1] == "S"

					dbSelectArea("STJ")
					dbSetOrder(1)
					If dbSeek(xFilial("STJ")+aArray[1][3])

						cCode := STJ->TJ_ORDEM
						cPlan := STJ->TJ_PLANO

						//------------------------------
						//Preenche as informações enviadas que não foram inseridas na abertura da O.S
						//------------------------------
						RecLock("STJ",.F.)
						If !Empty(cObservation)
							If lSYP
								MsMM(STJ->TJ_MMSYP,80,,cObservation,1,,,"STJ","TJ_MMSYP")
							Else
								STJ->TJ_OBSERVA := cObservation
							EndIf
						EndIf

						//----------------------------------------------------------
						//Grava campos de contadores de acordo com o envio do app
						//----------------------------------------------------------

						STJ->TJ_CONTINI := nCounter1
						STJ->TJ_POSCONT := nCounter1
						STJ->TJ_HORACO1 := cHour1
						STJ->TJ_POSCON2 := nCounter2
						STJ->TJ_HORACO2 := cHour2
						STJ->TJ_USUAINI := cUserName

						//----------------------------------------------------------
						// Grava campos de parada de acordo com o envio do app
						//----------------------------------------------------------
						If !Empty( dDtStopIni ) .And. !Empty( cHrStopIni )
							STJ->TJ_DTPRINI := dDtStopIni
							STJ->TJ_HOPRINI := cHrStopIni
						EndIf

						If !Empty( dDtStopFin ) .And. !Empty( cHrStopFin )
							STJ->TJ_DTPRFIM := dDtStopFin
							STJ->TJ_HOPRFIM := cHrStopFin
						EndIf

						STJ->(MsUnlock())

						If Empty(cError)
							printf(" Verificando a existencia de insumos previstos ")
							cError := InputSTLPrev(aArray[1][3], cType, .f. , oWS)
							printf(" Termino da verificacao de insumos previstos ")
						EndIf

						//------------------------------
						//Insere os insumos e etapas
						//------------------------------
						If Empty(cError)
							printf(" Verificando a existencia de insumos realizados ")
							cError := InputSTLRea( aArray[1][3], cType )
							printf(" Termino da verificacao de insumos realizados ")
						EndIf

						If Empty(cError)
							printf(" Verificando etapas ")
							aRetEtapas := InputSTQ(cCode, cPlan )
							cError     := aRetEtapas[1]
							aOSGeradas := aRetEtapas[2]
							aSSGeradas := aRetEtapas[3]
							aNoSTQ     := aRetEtapas[4]
							printf(" Termino da verificacao etapas ")
						EndIf

						If Empty( cError )
							//atualiza data e hora prevista da ordem de serviço
							UpdDatesStj( cCode,;
									cPlan,;
									Stod( aStartDate[1] ),;
									aStartDate[2],;
									Stod(aEndDate[1]),;
									aEndDate[2] )
						EndIf

						If !Empty(cError)
							return { .F., cError }
						EndIf
					EndIf

				Else
					cError := aArray[1][2]
				EndIf

				If Empty(cError)
					cOrdem := cCode
					printf("Ordem de servico incluida com sucesso (" + cOrdem + ")" )
				EndIf
			Else
				printf("Ordem de serviço ja existe (" + cOrdem + ").")
			EndIf
		Else
			//--------------------------------------------------------------------
			// Realiza a abertura de ordem de serviço vinculada a uma solicitação
			//--------------------------------------------------------------------
			aRetSR := NGUpsertSR( oWS, "order" , oParser:serviceRequest )
			If !aRetSR[1]
				cError := aRetSR[2]
			ElseIf NGIFDBSEEK( "STJ", aRetSR[2], 1 )
				cOrdem := STJ->TJ_ORDEM
				cPlan := STJ->TJ_PLANO
			EndIf
		EndIf
	Else
		If !FWJsonDeserialize(cJson,@oParser)
			cError := STR0022 // "Json inválido."
		Else
			cError := STR0023 // "Ocorreu um problema ao gerar a ordem de serviço."
		EndIf
	EndIf

	If Empty(cError)

		If lPeMntNg
			ExecBlock("MNTNG",.F.,.F.,{ "CREATED_ORDER", oWs })
		EndIf

		cJson := JSONResult( '{"code":"' + cOrdem + '", "plan":"' + cPlan + '",' + ;
					'"message":[' + fMessage( aOSGeradas, aSSGeradas, aNoSTQ ) + ']}' )
	Else
		cJson := cError
		lRet := .F.
		printf("Erro na criação da OS :"  + cJson)

	EndIf
Return { lRet, cJson }

//---------------------------------------------------------------------
/*/{Protheus.doc} updateSO
Realiza a atualização da OS

@author	Larissa Thaís de Farias
@author	Vitor Emanuel Batista
@author	Maria Elisandra de Paula
@since	29/03/2016
@param cJson, objeto, body da requisição (getcontent)
@param oWs, objeto, objeto com o JSON que contém os dados da OS para a alteração
@return array,  [1] se obteve sucesso, [2] json para retorno, [3] respostas não geradas
				[4] Código de erro MNTNG.
/*/
//---------------------------------------------------------------------
Static Function updateSO( cJson , oWs )

	Local oParser
	Local cError := ""
	Local cCode, cPlan, cType, cObservation
	Local nCodeRest := 0

	Local aStartDate, aEndDate, aChecklist
	Local oInputs
	Local lSYP    := NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
	Local lRet := .T.
	Local lSTJ := .F.
	Local lSTLPrev:= .F.
	Local lSTLRea := .F.
	Local lSTQ    := .F.
	Local aOSGeradas := {}
	Local aSSGeradas := {}
	Local aRetEtapas := {}
	Local aNoSTQ     := {}
	Local dDtStopIni := Ctod(' / / ')
	Local cHrStopIni := ""
	Local dDtStopFin := Ctod(' / / ')
	Local cHrStopFin := ""
	Local xValue

	Private aGETINS  := {}
	Private lAltera := .t.

	// Limpa variáveis Static
	aETAPAS      := {}

	If !Empty(cJson) .and. FWJsonDeserialize(cJson,@oParser)

		//---------------------------------------------------------------------------
		// FAVOR NÃO RETIRAR DO FONTE
		// Este trecho realiza a abertura das tabelas para que a função ProxNum()
		// possa funcionar corretamente no mntutil durante a criação de bloqueios
		// de produto e mão de obra.
		// Caso seja retirado, será desencadeado o erro:
		// "AJUSTAR PARAMETRO MV_DOCSEQ"
		// na segunda execução do fonte
		//---------------------------------------------------------------------------

		If Select('SD1') <= 0
			dbSelectArea('SD1')
		EndIf
		If Select('SD2') <= 0
			dbSelectArea('SD2')
		EndIf
		If Select('SD3') <= 0
			dbSelectArea('SD3')
		EndIf

		//----------------------------------------------
		//Preenche os campos
		//----------------------------------------------
		aStartDate   := StrTokArr(oParser:startDate, " ")
		cObservation := oParser:observation
		aEndDate     := StrTokArr(oParser:endDate, " ")
		aChecklist   := oParser:checklist
		oInputs      := oParser:inputs
		cEquipment   := Upper( PADR( oParser:equipment, TamSx3( 'TJ_CODBEM' )[ 1 ] ) )
		cType        := oParser:type
		cCode        := oParser:code
		cPlan        := oParser:plan
		cService     := Upper(PADR(oParser:service,6))
		cSequence    := IIf( AttIsMemberOf( oParser, 'sequence' ), PadR( oParser:sequence, 3 ), '0  ' )

		dbSelectArea("STJ")
		dbSetOrder(1)
		If dbSeek( xFilial("STJ") + cCode + cPlan )
			If STJ->TJ_SITUACA == 'C'
				// Retorna mensagem de erro somente para o server com o código referente as alterações de uma O.S. já cancelada.
				cError    := 'Ordem de servico ja cancelada ' + cCode + '. ' + DtoC( dDataBase ) + ' ' + Time()
				nCodeRest := CANCELCODE
			ElseIf STJ->TJ_TERMINO == 'S'
				// Retorna mensagem de erro somente para o server com o código referente as alterações de uma O.S. já finalizada.
				cError    := 'Ordem de servico ja finalizada ' + cCode + '. ' + DtoC( dDataBase ) + ' ' + Time()
				nCodeRest := FINISHCODE
			EndIf
		Else
			// Ordem de serviço não encontrada
			cError := STR0024
		EndIf

		If !Empty( cError )
			Return { .F., cError, aNoSTQ, nCodeRest }
		EndIf

		//------------------------------------------
		// Informações de parada de equipamento
		//------------------------------------------
		If AttIsMemberOf( oParser, "downTime" )
			xValue := StrTokArr( oParser:downTime, " " )
			If !Empty( xValue[1] ) .And. !Empty( xValue[2] )
				dDtStopIni := Stod( xValue[1] )
				cHrStopIni := xValue[2]
			EndIf
			xValue := Nil
		EndIf

		If AttIsMemberOf( oParser, "upTime" )
			xValue := StrTokArr( oParser:upTime, " " )
			If !Empty( xValue[1] ) .And. !Empty( xValue[2] )
				dDtStopFin := Stod( xValue[1] )
				cHrStopFin := xValue[2]
			EndIf
			xValue := Nil
		EndIf

		printf( 'Inicio do processo de atualizacao da O.S. ' + cCode + ' por ' + oWs:GetHeader( 'user' ) )

		// Inicializa array aInputs contendo os insumos previstos e realizados.
		cError := getInputs( oInputs, cCode, cPlan, cEquipment, .T. )

		If !Empty(cError)
			Return { .F., cError, aNoSTQ }
		EndIf

		printf( ' Realizando validacao dos insumos' )
		cError := fValidIns( cCode, cPlan, 4 )

		If !Empty(cError)
			Return { .f. , cError, aNoSTQ }
		EndIf

		//Inicializa variaveis de aETAPAS
		cError := getCheckList( aChecklist, cCode, cPlan, cType, cEquipment, cService, cSequence )
		If !Empty(cError)
			Return { .f. , cError, aNoSTQ }
		EndIf

		//Ponto de entrada para validações antes da alteração da ordem de serviço
		If Empty( cError ) .And. lPeMntNg
			cError := ExecBlock( 'MNTNG', .F., .F., { 'UPDATE_VALID_ORDER', oWs } )
		EndIf

		If !Empty(cError)
			Return { .f. , cError }
		EndIf

		printf(" Avaliando necessidade de modificacao na O.S. ")
		aUpdated := SoUpdated( aChecklist, cCode, cPlan, aStartDate, aEndDate, cObservation,;
								 dDtStopIni, cHrStopIni, dDtStopFin, cHrStopFin )

		lSTJ     := aUpdated[1] // Indica se STJ já está atualizada
		lSTLPrev := aUpdated[2] // Indica se insumos preventivos já estão atualizados
		lSTLRea  := aUpdated[3] // Indica se insumos realizados já estão atualizaodos
		lSTQ     := aUpdated[4] // Indica se etapas já estão atualizadas

		If !lSTJ

			dbSelectArea("STJ")
			dbSetOrder(1)
			If dbSeek(xFilial("STJ")+cCode+cPlan)

				//----------------------------------------------------------
				// Validação caso alteração na data e hora inicio de parada
				//----------------------------------------------------------
				If !Empty( dDtStopIni ) .And. !Empty( cHrStopIni ) .And. ;
					!Empty( dDtStopFin ) .And. !Empty( cHrStopFin ) .And. ;
					Dtos( dDtStopIni ) + cHrStopIni > Dtos( dDtStopFin ) + cHrStopFin

					cError := STR0160 // "A data e hora fim de parada não pode ser maior que a data e hora inicial."

				EndIf

				If !Empty( cError )
					Return { .f. , cError }
				EndIf

				printf(" Inicio da alteracao da ordem de servico ")
				//------------------------------
				//Preenche as informações enviadas que não foram inseridas na abertura da O.S
				//------------------------------
				RecLock("STJ",.F.)
				If !Empty(cObservation)
					If lSYP
						MsMM(STJ->TJ_MMSYP,80,,cObservation,1,,,"STJ","TJ_MMSYP")
					Else
						STJ->TJ_OBSERVA := cObservation
					EndIf
				EndIf

				//----------------------------------------------------------
				// Grava campos de parada de acordo com o envio do app
				//----------------------------------------------------------
				STJ->TJ_DTPRINI := dDtStopIni
				STJ->TJ_HOPRINI := cHrStopIni
				STJ->TJ_DTPRFIM := dDtStopFin
				STJ->TJ_HOPRFIM := cHrStopFin

				STJ->(MsUnlock())
			Else
				cError := STR0024 // "Ordem de serviço não encontrada."
			EndIf
		EndIf

		If !lSTLPrev .And. Empty(cError)
			printf(" Inicio das alteracoes dos insumos previstos ")
			cError := InputSTLPrev(cCode, cType, .t. ,oWs )
			printf(" Termino das alteracoes dos insumos previstos ")
		EndIf

		If !lSTLRea .And. Empty(cError)
			printf( ' Inicio das alteracoes dos insumos realizados ' )
			cError := InputSTLRea( cCode, cType )
			printf( ' Termino das alteracoes dos insumos realizados ' )
		EndIf

		If !lSTQ .And. Empty(cError)

			//------------------------------
			//Deleta e/ou insere as etapas
			//------------------------------
			printf(" Inicio das alteracoes de etapas ")
			aRetEtapas := InputSTQ(Padr(cCode,TamSx3("TJ_ORDEM")[1]), Padr(cPlan,TamSx3("TJ_PLANO")[1]))
			cError     := aRetEtapas[1]
			aOSGeradas := aRetEtapas[2]
			aSSGeradas := aRetEtapas[3]
			aNoSTQ     := aRetEtapas[4]
			printf(" Termino da verificacao etapas ")
		EndIf

		If Empty(cError)
			UpdDatesStj( cCode,;
					cPlan,;
					STOD(aStartDate[1]),;
					aStartDate[2],;
					STOD(aEndDate[1]),;
					aEndDate[2] )
		Else
			printf("Ocorreu um problema ao atualizar a ordem de servico.")
		EndIf
	Else
		cError := STR0022 // "Json inválido."
	EndIf

	If Empty(cError)

		cJson := JSONResult( '{"code":"' + cCode + '", "plan":"' + cPlan + '",' + ;
					'"message":[' + fMessage( aOSGeradas, aSSGeradas, aNoSTQ ) + ']}' )

		If lSTJ .And. lSTLPrev .And. lSTLRea .And. lSTQ
			printf( "Nao houve modificacoes na OS " + cCode )
		Else
			printf("Fim da atualizacao de OS. "  )
		EndIf
	Else
		cJson := cError
		lRet := .F.
		printf("Erro na atualizacao de OS. " + cError )
	EndIf

Return {lRet, cJson, aNoSTQ}

//---------------------------------------------------------------------
/*/{Protheus.doc} SoUpdated
Indica se houve algum tipo de alteração na ordem de serviço

@author	Larissa Thaís de Farias
@since 02/2016

@param aChecklist, array, etapas da ordem de serviço
@param cCode, string, código da OS para finalização
@param cPlan, string, plano da OS
@param aStartDate, array, data e hora da ordem de serviço
@param cObservation, string, observação da ordem de serviço
@param aEndDate, array, data e hora fim da ordem de serviço
@param dDtStopIni, date, data real parada inicio
@param cHrStopIni, string, hora real parada inicio
@param dDtStopFin, date, data real parada fim
@param cHrStopFin, string, hora real parada fim

@return array, [1] indica se a STJ está atualizada(não precisa de alteração)
               [2] indica se insumos previstos estão atualizados (não precisam de alteração)
			   [3] indica se insumos realizados estão atualizados (não precisam de alteração)
			   [4] indica se etapas estão atualizadas (não precisam de alteração)
/*/
//---------------------------------------------------------------------
Static Function SoUpdated( aChecklist, cCode, cPlan, aStartDate, aEndDate, cObservation,;
							dDtStopIni, cHrStopIni, dDtStopFin, cHrStopFin )

	Local lSTJ     := .F.
	Local lSTLPrev := .F.
	Local lSTLRea  := .F.
	Local lSTQ     := .F.

	dbSelectArea("STJ")
	dbSetOrder(1)
	If dbSeek(xFilial("STJ")+cCode+cPlan)

		lSTJ := STOD(aStartDate[1]) == STJ->TJ_DTMPINI .And. aStartDate[2] == STJ->TJ_HOMPINI .And. ;
				Alltrim( cObservation ) == Alltrim( STJ->TJ_OBSERVA ) .And. STOD(aEndDate[1]) == STJ->TJ_DTMPFIM .And. ;
				aEndDate[2] == STJ->TJ_HOMPFIM .And. dDtStopIni == STJ->TJ_DTPRINI .And. cHrStopIni == STJ->TJ_HOPRINI;
				.And. dDtStopFin == STJ->TJ_DTPRFIM .And. cHrStopFin == STJ->TJ_HOPRFIM

		// Insumos Realizados
		lSTLRea  := Empty( aInputs[_REALIZED_,_INSERT_] ) .And. Empty( aInputs[_REALIZED_,_UPDATE_] ) .And.;
			Empty( aInputs[_REALIZED_,_DELETE_] )

		// Insumos Previstos
		lSTLPrev := Empty( aInputs[_FORESEEN_,_INSERT_] ) .And. Empty( aInputs[_FORESEEN_,_UPDATE_] ) .And.;
			Empty( aInputs[_FORESEEN_,_DELETE_] )

		If len(aChecklist) == 0
			//verifico se a OS não tem etapa
			dbSelectArea("STQ")
			dbSetOrder(1)
			lSTQ := !dbSeek(xFilial("STQ")+cCode)
		Else
			//Etapa Não Executada e Etapa Executada
			lSTQ := fEqualSteps(cCode, cPlan)
		EndIf

	EndIf

Return { lSTJ, lSTLPrev, lSTLRea, lSTQ }

//---------------------------------------------------------------------
/*/{Protheus.doc} finishSO
Realiza a finalização da OS

@author	Larissa Thaís de Farias
@author	Vitor Emanuel Batista
@since 02/2016
@param oWs, objeto, objeto com o JSON que contém os dados para a finalização
@return array,  [1]se obteve sucesso, [2]json para retorno [3] Etapas não geradas
				[4] Código de erro MNTNG.
/*/
//---------------------------------------------------------------------
Static Function finishSO( oWs )

	Local lRet      := .F.
	Local cError    := ""
	Local nI        := 0
	Local nCodeRest := 0
	Local aNoSTQ    := {}
	Local aJson     := {}
	Local oParser
	Local cCode
	Local cPlan
	Local cJson

	If FWJsonDeserialize( oWs:GetContent(), @oParser )

		cCode := oParser:order
		cPlan := oParser:plan
		cJson := oParser:json

		//quando a ordem já está finalizada e ainda há uma tentativa de finalizar: não faz nenhuma operação e retorna .t.
		dbSelectArea("STJ")
		dbSetOrder(1)
		If dbSeek(xFilial("STJ") + cCode + cPlan )
			If STJ->TJ_SITUACA == 'C'
				// Retorna mensagem de erro somente para o server com o código referente as alterações de uma O.S. já cancelada.
				cError    := 'Ordem de servico ja cancelada ' + cCode + '. ' + DtoC( dDataBase ) + ' ' + Time()
				nCodeRest := CANCELCODE
			ElseIf STJ->TJ_TERMINO == 'S'
				// Retorna mensagem de erro somente para o server com o código referente as alterações de uma O.S. já finalizada.
				cError    := 'Ordem de servico ja finalizada ' + cCode + '. ' + DtoC( dDataBase ) + ' ' + Time()
				nCodeRest := FINISHCODE
			EndIf
			If !Empty( cError )
				Return { .F., cError, aNoSTQ, nCodeRest }
			EndIf
		EndIf

		aJson	:= updateSO( cJson , oWs )
		lRet 	:= aJson[1]
		cJson	:= aJson[2]
		aNoSTQ	:= aJson[3]
		MsUnlockAll()
	Else
		lRet := .F.
		cJson := STR0022 // "Json inválido."
	EndIf

	//-------------------------------------------------------------
	// O array aNoSTQ recupera as etapas que não foram geradas
	// por haver uma resposta com ação que geraria uma os preventiva
	// com mais de uma sequência cadastrada
	//-------------------------------------------------------------

	If lRet .And. Len( aNoSTQ ) > 0

		cError := STR0063 + Space(1) + cCode + Space(1) //"A ordem de serviço" #
		cError += STR0077 + Space(1) //"foi atualizada, mas não pode ser finalizada."
		cError += STR0078 + "," + Space(1) //"Houve a necessidade de gerar Ordem(s) Preventiva(s) a partir da Resposta da Etapa"
		cError += STR0079 + CRLF  //"porém a manutenção cadastrada possui mais de uma sequência."

		For nI := 1 to Len( aNoSTQ )
			cError += STR0074  + Space(1) + Alltrim(aNoSTQ[nI][1]) + "," //"Tarefa"
			cError += STR0075  + Space(1) + Alltrim(aNoSTQ[nI][2]) + "," //"Etapa"
			cError += STR0076  + Space(1) + Alltrim(aNoSTQ[nI][3]) + CRLF //"Opção"
		Next nI

		cJson := cError

		lRet := .F.
	EndIf

	If lRet

		dbSelectArea("STJ")
		dbSetOrder(1)
		If dbSeek(xFilial("STJ") + cCode + cPlan )

			cError := ""

			//Verifica se tem pelo menos um insumo realizado
			If verifyInput(cCode, cPlan)

				//----------------------------------------------
				//Realiza outras validações e finaliza a ordem
				//----------------------------------------------
				cError := finish( oWs, cCode, cPlan )

			Else
				cError := STR0063 + " " + cCode + " " + STR0064//"A ordem de serviço" # "não pode ser finalizada pois não existe insumo realizado."
			EndIf
		EndIf
	Else
		cError := cJson
	EndIf

	If !Empty( cError )
		cJson := cError
		lRet  := .f.
	Else
		printf("Finalizacao completa. " + DTOC(dDataBase) + " " + Time())
	EndIf

Return {lRet, cJson}

//---------------------------------------------------------------------
/*/{Protheus.doc} finish
Realiza a finalização da OS

@author	Larissa Thaís de Farias
@since 02/2016
@param oWs, objeto, web service
@param cCode, caracter, código da ordem
@param cPlan, caracter, plano
@return string, vazio ou descrição do erro caso exista
/*/
//---------------------------------------------------------------------
Static Function finish( oWs, cCode, cPlan )

	Local cError     := ""
	Local cTENDFLAHA := SuperGetMV("MV_NGTNDFL",.F.,"S")
	Local cObsFim    := ""
	Local cFault     := ""
	Local aAuxiliar  := {}
	Local dDtMRFim   := Ctod( ' / / ')
	Local cHoMRFim   := ''
	Local dDtMRIni   := Ctod( ' / / ')
	Local cHoMRIni   := ''
	Local nCounter1  := 0
	Local nCounter2  := 0
	Local cHour1     := ""
	Local cHour2     := ""
	Local cDadCode   := ''
	Local oCounter
	Local oParser
	Local dDtStopIni := Ctod( ' / / ' )
	Local dDtStopFin := Ctod( ' / / ' )
	Local cHrStopIni := ""
	Local cHrStopFin := ""
	Local lShowField := .T.
	Local xValue

	Private cNGERROR := ""

	FWJsonDeserialize( oWs:GetContent(), @oParser )

	If lPeMntNg

		// P.E. que permite manipulação das informações enviadas para finalização da O.S.
		xValue := ExecBlock( 'MNTNG', .F., .F., { 'UPDATE_FINISH_ORDER', oParser } )

		If ValType( xValue ) == 'O'
			oParser := xValue
		EndIf

	EndIf

	If AttIsMemberOf( oParser, "observation" )
		cObsFim := oParser:observation
	EndIf

	If AttIsMemberOf( oParser, "fault" )
		cFault := oParser:fault
	EndIf

	//Data real Inicio
	If AttIsMemberOf( oParser, "startDate" )
		aAuxiliar := StrTokArr( oParser:startDate, " " )
		dDtMRIni  := Stod( aAuxiliar[1] )
		cHoMRIni  := aAuxiliar[2]
	EndIf

	//Data real fim
	If AttIsMemberOf( oParser, "endDate" )
		aAuxiliar := StrTokArr( oParser:endDate, " " )
		dDtMRFim  := Stod( aAuxiliar[1] )
		cHoMRFim  := aAuxiliar[2]
	EndIf

	//Informações de contador
	If AttIsMemberOf( oParser, 'counter' ) .And. Len( oCounter := oParser:counter ) > 0

		nCounter1 := oCounter[1]:value //Valor do primeiro contador

		If nCounter1 > 0

			If AttIsMemberOf( oCounter[1], "time" )
				cHour1 := oCounter[1]:time //hora do primeiro contador
			ElseIf AttIsMemberOf( oCounter[1], "datetime" )
				cHour1 := StrTokArr(oCounter[1]:datetime," ")[2] //hora do primeiro contador - app com versão antiga
			EndIf

		EndIf

		If Len( oCounter ) == 2

			nCounter2 := oCounter[2]:value //Valor do segundo contador

			If nCounter2 > 0

				If AttIsMemberOf( oCounter[2], "time" )
					cHour2 := oCounter[2]:time //hora do segundo contador
				ElseIf AttIsMemberOf( oCounter[2], "datetime" )
					cHour2 := StrTokArr(oCounter[2]:datetime," ")[2] //hora do segundo contador - app com versão antiga
				EndIf

			EndIf

		EndIf

	Else

		// Campo contador não foi apresentado no app MNTNG.
		lShowField := .F.

		dbSelectArea( 'ST9' )
		dbSetOrder( 1 )
		If dbSeek( xFilial( 'ST9' ) + STJ->TJ_CODBEM ) .And. ST9->T9_TEMCONT $ 'P#I'

			nCounter1 := NGACUMEHIS( STJ->TJ_CODBEM, dDtMRFim, cHoMRFim, 1, 'E' )[1]
			cHour1    := cHoMRFim

			// Inicializa váriaveis para contador 2, caso o equipamento possua.
			If MNTCont2( xFilial( 'TPE' ), STJ->TJ_CODBEM, .T. )

				nCounter2 := NGACUMEHIS( STJ->TJ_CODBEM, dDtMRFim, cHoMRFim, 2, 'E' )[1]
				cHour2    := cHoMRFim

			EndIf

		EndIf

	EndIf

	// Define o código do pai para o equipamento relacionado a O.S. para reporte de contador em estrutura.
	cDadCode := NGTBEMPAI( STJ->TJ_CODBEM, STJ->TJ_CODBEM )

	//------------------------------------------
	// Informações de parada de equipamento
	//------------------------------------------
	If AttIsMemberOf( oParser, "downTime" ) .And. AttIsMemberOf( oParser, "upTime" )

		xValue := StrTokArr( oParser:downTime, " " )
		If !Empty( xValue[1] ) .And. !Empty( xValue[2] )
			dDtStopIni := Stod( xValue[1] )
			cHrStopIni := xValue[2]
		EndIf

		xValue := StrTokArr( oParser:upTime, " " )
		If !Empty( xValue[1] ) .And. !Empty( xValue[2] )
			dDtStopFin := Stod( xValue[1] )
			cHrStopFin := xValue[2]
		EndIf

	EndIf

	printf(" Validacoes para finalizar OS " + cCode + ". " + DTOC(dDataBase) + " " + Time())

	//campo irregularidade somente será obrigatório quando parâmetro estiver definido
	If cTENDFLAHA <> "N" .and. cPlan == "000000"
		If cTENDFLAHA == "S" .And. Empty(cFault)
			cError := STR0065 //"É obrigatório definir uma irregularidade."
		EndIf

		dbSelectArea( "TP7" )
		dbSetOrder( 1 )
		If Empty ( cError ) .and. !Empty( cFault ) .and. !dbSeek( xFilial( "TP7" ) + cFault )
			cError := STR0026 //"Irregularidade não cadastrada no Protheus, favor sincronizar os dados novamente."
		EndIf
	EndIf

	//-------------------------------------------------------
	//Verifica obrigatoriedade de resposta das etapas e executante
	//-------------------------------------------------------
	If Empty(cError) .And. !NGRESPETAEX(cCode,.f.)[1]
		cError := STR0066 + " " + cCode //"Existe(m) etapa(s) sem resposta(s) e/ou sem o executante para a ordem de serviço:"
	EndIf

	//-----------------------------------
	// Validações de contador
	//-----------------------------------
	If Empty( cError )
		cError := CounterFinish( cDadCode, nCounter1, cHour1, nCounter2, cHour2, dDtMRFim, oWS, lShowField )
	EndIf

	//----------------------------------------------
	// Validações de data e hora manutenção
	//----------------------------------------------
	If Empty( cError )
		cError := fDateValid( dDtMRIni, cHoMRIni, dDtMRFim, cHoMRFim )
	EndIf

	//----------------------------------------------
	// Validações de data e hora parada equipamento
	//----------------------------------------------
	If Empty( cError )

		If Dtos( dDtStopIni ) + cHrStopIni > Dtos( dDtStopFin ) + cHrStopFin
			cError := STR0160 // "A data e hora fim de parada não pode ser maior que a data e hora inicial."
		EndIf

		If Empty( cError ) .And. dDtStopIni > dDataBase
			cError := STR0161 // "A data real início de parada não pode ser maior que a data atual."
		EndIf

	EndIf


	//Ponto de entrada que executa pré validação para a finalização de O.S.
	If Empty( cError ) .And. lPeMntNg
		cError := ExecBlock( 'MNTNG', .F., .F., { 'FINISH_VALID_ORDER', oWs } )
	EndIf

	If Empty(cError) .And. NGIFDBSEEK("STJ", cCode + cPlan, 1)

		printf("Finalizando OS " + cCode + ". " + DTOC(dDataBase) + " " + Time())

		//-------------------------------------------------------------
		// Campos abaixo devem ser carregados antes de acionar NGFINAL
		//-------------------------------------------------------------
		RecLock( "STJ", .F. )

		If !Empty( cObsFim )
			STJ->TJ_OBSERVA = cObsFim
		EndIf

		STJ->TJ_DTMRINI := dDtMRIni
		STJ->TJ_HOMRINI := cHoMRIni
		STJ->TJ_DTMRFIM := dDtMRFim
		STJ->TJ_HOMRFIM := cHoMRFim
		STJ->TJ_IRREGU  := cFault
		STJ->TJ_USUAFIM := cUserName

		If nCounter1 > 0
			STJ->TJ_POSCONT := nCounter1
			STJ->TJ_HORACO1 := cHour1
		EndIf

		If nCounter2 > 0
			STJ->TJ_POSCON2 := nCounter2
			STJ->TJ_HORACO2 := cHour2
		EndIf

		MsUnlock()

		If NGFINAL( STJ->TJ_ORDEM, STJ->TJ_PLANO, dDtStopIni, cHrStopIni, dDtStopFin, cHrStopFin, STJ->TJ_POSCONT,;
			STJ->TJ_POSCON2, cDadCode, STJ->TJ_HORACO1, STJ->TJ_HORACO2 )

			cError := ''
			MsUnlock()

			//-------------------------------------------------------------
			//Envia wf de encerramento de OS quando está vinculada a uma SS
			//-------------------------------------------------------------
			WfFinish( cCode )

			If lPeMntNg
				ExecBlock("MNTNG",.F.,.F.,{ "FINISHED_ORDER", oWs })
			EndIf
		Else
			cError := STR0027 + " " + cNGERROR // "Ocorreu um problema ao finalizar a ordem de serviço."
		EndIf

	ElseIf Empty(cError)
		cError := STR0024 // "Ordem de serviço não encontrada."
	EndIf


Return cError

//---------------------------------------------------------------------
/*/{Protheus.doc} cancelSO
Realiza o cancelamento da OS

@author	Larissa Thaís de Farias
@author	Vitor Emanuel Batista
@since 02/2016
@param oWS, objeto, objeto com o JSON que contém os dados de cancelamento
@return array,  [1]se obteve sucesso,
				[2]json para retorno,
				[3] Etapas não geradas,
				[4] Código de erro MNTNG.
/*/
//---------------------------------------------------------------------
Static Function cancelSO( oWS )

	Local oParser
	Local cError := ''
	Local cCode  := ''
	Local cPlan  := ''
	Local cMsg   := ''
	Local cBody  := oWS:GetContent()
	Local xRetAux
	Local nCodeRest := 0

	//caso tenha de fazer estorno no empenho, lAltera é utilizada dentro do MNTGERAD3("DE1") no NGDELETOS
	Private lAltera := .F.

	If FWJsonDeserialize(cBody,@oParser)

		cCode := oParser:order
		cPlan := oParser:plan
		cMsg  := oParser:message

		printf("Inicio do processo de cancelamento da OS " + cCode + ". " + DTOC(dDataBase) + " " + Time())

		dbSelectArea( 'STJ' )
		dbSetOrder( 1 )
		If dbSeek( xFilial( 'STJ' ) + cCode + cPlan )
			If STJ->TJ_SITUACA == 'C'
				// Retorna mensagem de erro somente para o server com o código referente as alterações de uma O.S. já cancelada.
				cError    := 'Ordem de servico ja cancelada ' + cCode + '. ' + DtoC( dDataBase ) + ' ' + Time()
				nCodeRest := CANCELCODE
			ElseIf STJ->TJ_TERMINO == 'S'
				// Retorna mensagem de erro somente para o server com o código referente as alterações de uma O.S. já finalizada.
				cError    := 'Ordem de servico ja finalizada ' + cCode + '. ' + DtoC( dDataBase ) + ' ' + Time()
				nCodeRest := FINISHCODE
			EndIf
			If !Empty( cError )
				Return { .F., cError, , nCodeRest }
			EndIf
		EndIf

		//Verifica se existe insumo com cotação	ou insumo reportado
		cError := fValidIns(cCode, cPlan , 5)
		If !Empty(cError)
			Return { .f. , cError}
		EndIf

		//Checa se existe SA com Pre-Requisicao
		If !NGCHKSAPR( cCode , cPlan, , .F., .F. )
			Return { .f. , STR0039 }
		EndIf

		If lPeMntNg
			cError:= ExecBlock("MNTNG",.F.,.F.,{ "CANCEL_VALID" , oWS })
			If !Empty(cError)
				Return { .f. , cError }
			EndIf
		EndIf

		xRetAux := NGDELETOS(cCode, cPlan, cMsg,.T.)
		//Condição para tratar chamada NGDELETOS desatualizada (retorno lógico)
		If Valtype( xRetAux ) == 'L' .And. !xRetAux
			cError := STR0028 +  " " + cCode + "." // "Ocorreu um problema ao cancelar a ordem de serviço"
		ElseIf Valtype( xRetAux ) == 'A' .And. !xRetAux[1]
			cError := xRetAux[2]
		EndIf

		//----------------------------------------------------------
		//Confirma o cancelamento da OS para exclusão de contadores
		//----------------------------------------------------------
		If Empty( cError )

			dbSelectArea("STJ")
			dbSetOrder(1)
			If dbSeek(xFilial("STJ") + cCode + cPlan)
				If STJ->TJ_SITUACA == 'C'
					//Exclui contador 1
					If !Empty( STJ->TJ_HORACO1 ) .And. STJ->TJ_POSCONT > 0 ;
						.And. NGIFDBSEEK( "STP", STJ->TJ_CODBEM + Dtos( STJ->TJ_DTORIGI ) + STJ->TJ_HORACO1, 5 ) ;
						.And. STP->TP_TIPOLAN != "I"
						MNT470EXCO(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO1,1)
					EndIf

					//Exclui contador 2
					If !Empty( STJ->TJ_HORACO2 ) .And. STJ->TJ_POSCON2 > 0 ;
						.And. NGIFDBSEEK( "TPP", STJ->TJ_CODBEM + Dtos( STJ->TJ_DTORIGI ) + STJ->TJ_HORACO2, 5 ) ;
						.And. TPP->TPP_TIPOLA != "I"
						MNT470EXCO(STJ->TJ_CODBEM,STJ->TJ_DTORIGI,STJ->TJ_HORACO2,2)
					EndIf
				Else
					cError := STR0028 +  " " + cCode + "." // "Ocorreu um problema ao cancelar a ordem de serviço"
				EndIf
			EndIf
		EndIf

	Else
		cError := STR0022 // "Json inválido."
	EndIf

	If Empty(cError)
		printf("Processo de cancelamento completo. " + DTOC(dDataBase) + " " + Time())
	Else
		Return { .F. , cError}
	EndIf

Return { .T., JSONResult(  ) }

//---------------------------------------------------------------------
/*/{Protheus.doc} getVersion
Retorna a Versão e a Data do WebService

@author	Larissa Thaís de Farias
@since	29/09/16
@return string, json com informações de versão do ws
/*/
//---------------------------------------------------------------------
Static Function getVersion()

	printf("Coletando versoes em " + DTOC(Date()) + " " + Time() + ' --> ws:' + VERSIONWS + ' date:' + DATEVERSION )

Return JSONResult('{"ws":"' + VERSIONWS + '","minVersion":"' + MINVERSIONAPP + '","date":"' + DATEVERSION + '"}')

//---------------------------------------------------------------------
/*/{Protheus.doc} dateQuery
Retorna o trecho que decodifica a data de alteração e inclusão de um registro
para ser utilizado em querys

@author	Larissa Thaís de Farias
@since	 02/2016
@param cField, string, campo (XX_USERLGI, XX_USERLGA)
@return string, trecho para comparação de datas
/*/
//---------------------------------------------------------------------
Static Function dateQuery( cField )

	Local cQuery := ""

	If Upper(AllTrim(TcGetDB())) $ 'ORACLE/POSTGRES'
		cQuery := "TO_CHAR("
		    cQuery += "("
		        cQuery += "(ASCII(SUBSTR(" + cField + ",12,1)) - 50) * 100"
		    cQuery += ") + "
		    cQuery += "("
		        cQuery += "ASCII(SUBSTR(" + cField + ",16,1)) - 50"
		    cQuery += ") + TO_DATE('19960101', 'YYYYMMDD')"
		cQuery += ", 'YYYYMMDD')"
	ElseIf Upper(AllTrim(TcGetDB())) $ 'DB2' // Syntax exclusiva DB2
		cQuery := " VARCHAR_FORMAT( ( TO_DATE( '19960101', 'YYYYMMDD' ) + "
		cQuery += "( ( ASCII( SUBSTR( " + cField + ", 12, 1 ) ) - 50) * 100 + "
		cQuery += "  ( ASCII( SUBSTR( " + cField + ", 16, 1 ) ) - 50 ) ) days ), 'YYYYMMDD' ) "
	Else
		cQuery := "( "
			cQuery += "CONVERT(VARCHAR, "
				cQuery += "DATEADD(DAY, "
				cQuery += "(
					cQuery += "(ASCII(SUBSTRING(" + cField + ",12,1)) - 50) * 100 + "
					cQuery += "(ASCII(SUBSTRING(" + cField + ",16,1)) - 50)
				cQuery += "), "
				cQuery += "'19960101'), "
			cQuery += "112) "
		cQuery += ")"
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} isUser
Valida o Usuário e Senha

@author	Larissa Thaís de Farias
@since	 03/2016

@param cEmail    , string, email do usuário
@param cPassword , string, senha do usuário
@param lDecodePsw, boolean, indica se a senha deve ser decodificada segundo o padrão BASE64
@return array, [1] se usuário é válido, [2] informações do usuário ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function isUser( cEmail, cPassword, lDecodePsw )

	Local aReturn := {}

	Default lDecodePsw := .T.

	// Autenticação fica a cargo da camada de framework, chegando ao ws já autenticado.
	If lHasSecurity
		aReturn := fVldSecur(cEmail)
	Else
		aReturn := fVldNoSecur(cEmail, cPassword, lDecodePsw)
	EndIf

Return aReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} fVldSecur
Valida o usuário quando tem security habilitado

@author Maria Elisandra de Paula
@since 14/06/2022
@param cEmail, string, email do usuário
@return array, [1] se usuário é válido, 
				[2] informações do usuário ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function fVldSecur(cEmail)

	Local aInfoUser := {}
	Local lSeek := .F.

	Printf( 'Autenticacao BASIC habilitada' )

	If Type('__cUserID') == 'C' .And. !Empty(__cUserID)
		cUserLog := __cUserID
		cUserName := UsrRetName( cUserLog )
	Else
		
		Return {.F., STR0190 } // "O usuário para autenticação não foi definido. Verifique as configurações (chave Security)"
	EndIf

	PswOrder( 1 ) // ID do usuário ou grupo

	/*
		PswSeek e PswRet chamados em redundância devido a uma inconsit~encias nestas funções do framework
		como não tivemos solução por parte da equipe responsável, estaremos subindo de forma paliativa com
		este contorno.
	*/
	lSeek := PswSeek( __cUserID, .T. )
	lSeek := PswSeek( __cUserID, .T. )

	aInfoUser := PswRet()
	lSeek := PswSeek( __cUserID, .T. )
	aInfoUser := PswRet()

	fLogMntng( 'lHasSecurity - __cUserID: ' + IIf( Type('__cUserID') == 'C', __cUserID, 'Nulo' ) )

Return { .T., aInfoUser }

//---------------------------------------------------------------------
/*/{Protheus.doc} fVldNoSecur
Valida o usuário quando não tem security habilitado

@author Maria Elisandra de Paula
@since 14/06/2022
@param cEmail, string, email do usuário
@param cPassword, string, senha do usuário
@param lDecodePsw, boolean, se a senha deve ser decodificada
@return array, [1] se usuário é válido, 
				[2] informações do usuário ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function fVldNoSecur(cEmail, cPassword, lDecodePsw)

	Local aInfoUser    := {}
	Local nHandle      := -1 // Deve ser inicializado com valor negativo, pois zero é um conteúdo válido.

	Printf( 'Autenticacao BASIC desabilitada' )

	If lMingle
		Return { .F., STR0179 } //"Para utilização da plataforma MINGLE é necessário que a chave security esteja igual a '1'" 
	EndIf

	If Empty(cEmail) .or. Empty(cPassword)
		Return { .F.,STR0007 } //"O usuário e senha não foram preenchidos."
	EndIf

	cPassword := IIf( lDecodePsw, Decode64( cPassword ), cPassword )

	// Caso já possua uma conexão com o BD aberta não necessita de uma nova abertura.
	If !TCIsConnected()
		
		fLogMntng( 'Conexao temporaria iniciada' )

		// Conexão temporária com o BD forçada para evitar o erro: dbusearea - db driver not initialized.
		nHandle := TcLink()

	EndIf

	// Autenticação com o Protheus via email
	PswOrder( 4 ) // E-mail do usuário
	If !PswSeek( cEmail ) .Or. !PswName( cPassword )
		Return { .F.,STR0008 }//"Usuário ou senha incorretos."
	Endif

	aInfoUser := PswRet()

	// Quando aberto manualmente a conexão com BD, esta deve ser fechada manualmente.
	If nHandle >= 0

		fLogMntng( 'Conexao temporaria finalizada' )

		// Encerrando conexão temporária com o BD.
		TCUnlink( nHandle )

	EndIf

	//--------------------------------------------------
	//Verificações de acesso do usuário
	//--------------------------------------------------
	If aInfoUser[ 1, 17 ]
		Return { .F., STR0013 } // "Usuário inativo no ERP Protheus."
	EndIf

Return { .T., aInfoUser } 

//----------------------------------------------------------------------------------
/*/{Protheus.doc} getInputs
Preenche o array aInputs com insumos previstos e realizados.
de acordo com informações passadas pelo mobile

@author	Larissa Thaís de Farias
@since	24/03/16
@param  oParser  , objeto , insumos do objeto (:inputs)
@param  cOrder   , string , código da ordem de serviço
@param  cPlan    , string , código do plano da ordem de serviço
@param  cEquip   , string , código do bem
@param  lGetIns  , boolean, Define se deve inicializar o array aGetIns.
@param  lPlayStop, boolean, Indica que a chamada foi realizada pela rota PlayStop.
@return string , vazio ou descrição do erro
/*/
//----------------------------------------------------------------------------------
Static Function getInputs( oParser, cOrder, cPlan, cEquip, lGetIns, lPlayStop )

	Local nIndex     := 0
	Local nOpcX      := 0
	Local nStatus    := 0
	Local aDate      := {}
	Local aInputTemp := {}
	Local aTask      := {}
	Local cDefUnity  := SuperGetMV("MV_NGUNIDT",.F.,"S")
	Local cError     := ''
	Local cSeqTask   := '000'
	Local lIsDone    := .F.
	Local nSizeUN    := Len( SB1->B1_UM )
	Local cBranchSB1 := xFilial( 'SB1' )

	Default cOrder    := "" //somente na alteração esta variável será passada por parâmetro, para validação de previstos
	Default cPlan     := "" //somente na alteração esta variável será passada por parâmetro, para validação de previstos
	Default lGetIns   := .F.
	Default lPlayStop := .F.

	// Zera array de controle de insumos
	aInputs := { { {}, {}, {} }, { {}, {}, {} } }

	For nIndex := 1 To Len( oParser )

		aInputTemp := Array( 31 )

		// Define se o insumo e Realizado ou Previsto
		lIsDone := IIf( AttIsMemberOf( oParser[nIndex], 'isDone' ), oParser[nIndex]:isDone, .F. )

		// TL_UNIDADE
		aInputTemp[_UNITY_] := PadR( IIf( AttIsMemberOf( oParser[nIndex], 'unity' ), oParser[nIndex]:unity, 'H' ), Len( SB1->B1_UM ) )

		If AttIsMemberOf( oParser[nIndex], 'unity' )
			If oParser[nIndex]:type == 'P'
				If AllTrim( Upper( oParser[nIndex]:unity ) ) == AllTrim( Upper( Posicione( 'SB1', 1, cBranchSB1 + oParser[nIndex]:code, 'B1_UM' ) ) )
					aInputTemp[_UNITY_] := PadR( oParser[nIndex]:unity, nSizeUN )
				Else
					cError := STR0180 + oParser[nIndex]:code + STR0181 //'Unidade informada no insumo ' ' inválida! Favor verificar o campo unity.'
					exit
				EndIf
			Else
				aInputTemp[_UNITY_] := PadR( oParser[nIndex]:unity, nSizeUN )
			EndIf

		Else
			aInputTemp[_UNITY_] := PadR( 'H', nSizeUN )
		EndIf

		// TL_DESTINO
		If AttIsMemberOf( oParser[nIndex], 'destiny' )
			If Upper( oParser[nIndex]:type ) == 'P'
				If oParser[nIndex]:destiny $ 'A/S/T'
					aInputTemp[_DESTINY_] := oParser[nIndex]:destiny
				Else
					cError := STR0182 + oParser[nIndex]:code + STR0183 // 'Destino informado no insumo ' ' inválido! Favor verificar o campo destiny.'
					exit
				EndIf
			Else
				aInputTemp[_DESTINY_] := oParser[nIndex]:destiny
			EndIf
		Else
			aInputTemp[_DESTINY_] := ''
		EndIf

		// TL_TIPOREG
		aInputTemp[_TYPE_] := IIf( AttIsMemberOf( oParser[nIndex], 'type' ), oParser[nIndex]:type, '' )

		// TL_PERMDOE
		aInputTemp[_PERCENT_] := IIf( AttIsMemberOf( oParser[nIndex], 'percent' ), oParser[nIndex]:percent, 0 )

		// TL_OBSERVA
		aInputTemp[_INPUTNOTE_] := IIf( AttIsMemberOf( oParser[nIndex], 'note' ), Trim( oParser[nIndex]:note ), '' )

		// TL_QUANREC
		aInputTemp[_RESOURCEAMOUNT_] := IIf( AttIsMemberOf( oParser[nIndex], 'resourceAmount' ), oParser[nIndex]:resourceAmount, 0 )

		// TL_QUANTID
		aInputTemp[_AMOUNT_] := IIf( AttIsMemberOf( oParser[nIndex], 'amount' ), oParser[nIndex]:amount, 0 )

		If aInputTemp[_TYPE_] == 'P' .And. Len( cValtoChar(oParser[nIndex]:amount ) ) > 9
			Return STR0029 + " " + STR0030 + " " + NGSEEK( "SB1", oParser[nIndex]:code, 1, "B1_DESC") //"Campo quantidade está incorreto." # "Produto"
		EndIf

		// TL_DTVALID
		aInputTemp[_DATELOT_] := cToD( '' )

		// TL_USACALE
		aInputTemp[_USECALE_] := 'N'

		// TL_CUSTO
		aInputTemp[_COST_] := 0

		// TL_FORNEC
		aInputTemp[_CATERER_] := ''

		// TL_LOJA
		aInputTemp[_STORE_] := ''

		// TL_TIPOHOR
		aInputTemp[_HOURUNITY_] := IIf( AttIsMemberOf( oParser[nIndex], 'hourUnity' ), IIf( Empty( oParser[nIndex]:hourUnity ),;
			cDefUnity, oParser[nIndex]:hourUnity ), cDefUnity )

		// TL_LOCAL
		aInputTemp[_WAREHOUSE_] := PadR( IIf( AttIsMemberOf( oParser[nIndex], 'warehouse' ), oParser[nIndex]:warehouse,;
			IIf( aInputTemp[_TYPE_] == 'T',	PadR( SuperGetMV( 'MV_NGLOCPA', .F., '01' ), Len( STL->TL_LOCAL ) ), '' ) ),;
			Len( STL->TL_LOCAL ) )

		// TL_TAREFA
		aInputTemp[_TASK_] := PadR( IIf( AttIsMemberOf( oParser[nIndex], 'task' ), oParser[nIndex]:task, '0'),;
			Len( STL->TL_TAREFA ) )

		// Backup TL_TAREFA
		aInputTemp[_KEYTASK_] := PadR( IIf( AttIsMemberOf( oParser[nIndex], 'keyTask' ), oParser[nIndex]:keyTask, ''),;
			Len( STL->TL_TAREFA ) )

		// TL_CODIGO
		aInputTemp[_CODE_] := PadR( IIf( AttIsMemberOf( oParser[nIndex], 'code' ), oParser[nIndex]:code, '' ),;
			Len( STL->TL_CODIGO ) )

		// Backup TL_CODIGO
		aInputTemp[_KEYCODE_] := PadR( IIf( AttIsMemberOf( oParser[nIndex], 'keyCode' ), oParser[nIndex]:keyCode, ''),;
			Len( STL->TL_CODIGO ) )

		// TL_SEQRELA
		aInputTemp[_SEQUENCE_] := PadR( IIf( AttIsMemberOf( oParser[nIndex], 'sequence' ), oParser[nIndex]:sequence, '0'),;
			Len( STL->TL_SEQRELA ) )

		// TL_SEQTARE
		aInputTemp[_SEQTASK_] := PadR( IIf( AttIsMemberOf( oParser[nIndex], 'taskSequence' ), oParser[nIndex]:taskSequence,;
			IIf( !lIsDone, fseqTask( cOrder, cPlan, @cSeqTask ), '' ) ), Len( STL->TL_SEQTARE ) )

		// TL_LOCALIZ
		aInputTemp[_LOCATION_] := IIf( AttIsMemberOf( oParser[nIndex], 'location' ), Upper( PadR( oParser[nIndex]:location,;
			Len( STL->TL_LOCALIZ ) ) ), '' )

		// TL_NUMSERI
		aInputTemp[_SERIALNUMBER_] := IIf( AttIsMemberOf( oParser[nIndex], 'serialnumber' ), Upper( PadR( oParser[nIndex]:serialnumber,;
			Len( STL->TL_NUMSERI ) ) ), '' )

		// TL_NUMSA
		aInputTemp[_WHREQUEST_] := IIf( AttIsMemberOf( oParser[nIndex], 'warehouseRequest' ), PadR( oParser[nIndex]:warehouseRequest,;
			Len( STL->TL_NUMSA ) ), '' )

		// TL_ITEMSA
		aInputTemp[_WHITEM_] := IIf( AttIsMemberOf( oParser[nIndex], 'warehouseItem' ), PadR( oParser[nIndex]:warehouseItem,;
			Len( STL->TL_ITEMSA ) ), '' )

		// TL_LOTECTL
		aInputTemp[_LOT_] := IIf( AttIsMemberOf( oParser[nIndex], 'lot' ), Upper( PadR( oParser[nIndex]:lot,;
			Len( STL->TL_LOTECTL ) ) ), '' )

		// TL_NUMLOTE
		aInputTemp[_SUBLOT_] := IIf( AttIsMemberOf( oParser[nIndex], 'sublot' ), Upper( PadR( oParser[nIndex]:sublot,;
			Len( STL->TL_NUMLOTE ) ) ), '' )

		// TL_DTINICI & TL_HOINICI
		If AttIsMemberOf( oParser[nIndex], 'startDate' )
			aDate := StrTokArr( oParser[nIndex]:startDate, ' ' )
		ElseIf AttIsMemberOf( oParser[nIndex], 'date' )
			aDate := StrTokArr( oParser[nIndex]:date, ' ' )
		Else
			aDate := { dToS( dDataBase ), '08:00' }
		EndIf

		// TL_DTINICI
		aInputTemp[_STARTDATE_] := sToD( aDate[1] )

		// TL_HOINICI
		aInputTemp[_STARTHOUR_] := aDate[2]

		// TL_DTFIM & TL_HOFIM
		If AttIsMemberOf( oParser[nIndex], 'endDate' )
			aDate := StrTokArr( oParser[nIndex]:endDate, ' ' )
		ElseIf AttIsMemberOf( oParser[nIndex], 'date' )
			aDate := StrTokArr( oParser[nIndex]:date, ' ' )
		Else
			aDate := { dToS( dDataBase ), '18:00' }
		EndIf

		// TL_DTFIM
		aInputTemp[_ENDDATE_] := sToD( aDate[1] )

		// TL_HOFIM
		aInputTemp[_ENDHOUR_] := aDate[2]

		// Ocorrências
		If AttIsMemberOf( oParser[nIndex], 'occurrences' )

			/*
				Preenche uma matriz contendo a indetificação do insumo e a listagem de ocorrências relacionadas para o
				controle de gravação.
			*/
			aInputTemp[_OCCURRENCES_] := aClone( GetOccurrences( oParser[nIndex]:occurrences ) )

		EndIf

		//Converte um valor em decimal para horas (numérico)
		If aInputTemp[_TYPE_] != 'P' .And. Trim( aInputTemp[_UNITY_] ) == 'H' .And. cDefUnity != 'D'
			aInputTemp[_AMOUNT_] := NGRHODSEXN( aInputTemp[_AMOUNT_], 'D' )
		EndIf

		nStatus := IIf( lIsDone, _REALIZED_, _FORESEEN_ )

		// Separa os insumos por operação as quais foram acionados.
		Do Case

			Case lPlayStop .Or. oParser[nIndex]:operation == 'C'

				aAdd( aInputs[nStatus,_INSERT_], aInputTemp )

			Case oParser[nIndex]:operation == 'U'

				// Valida e carrega detalhes da S.A. relacionada ao insumo no arrary aInputs.
				cError := checkSA( cOrder, cPlan, @aInputTemp, 'U' )

				If Empty( cError )

					aAdd( aInputs[nStatus,_UPDATE_], aInputTemp )

				Else

					Return cError

				EndIf

			Case oParser[nIndex]:operation == 'D'

				// Valida S.A. relacionada ao insumo.
				cError := checkSA( cOrder, cPlan, aInputTemp, 'D' )

				If Empty( cError )

					aAdd( aInputs[nStatus,_DELETE_], aInputTemp )

				Else

					Return cError

				EndIf

		EndCase

		If lGetIns

			dbSelectArea( 'STL' )
			dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA + TL_SEQTARE
			msSeek( xFilial( 'STL' ) + cOrder + cPlan + aInputTemp[_KEYTASK_] + aInputTemp[_TYPE_] + aInputTemp[_KEYCODE_] +;
				aInputTemp[_SEQUENCE_] + aInputTemp[_SEQTASK_] )

			aAdd( aGetIns, { aInputTemp[_KEYTASK_], aInputTemp[_TYPE_], aInputTemp[_KEYCODE_], '', aInputTemp[_USECALE_], aInputTemp[_RESOURCEAMOUNT_],;
				aInputTemp[_AMOUNT_], aInputTemp[_UNITY_], aInputTemp[_DESTINY_], aInputTemp[_STARTDATE_], aInputTemp[_STARTHOUR_], aInputTemp[_WAREHOUSE_],;
				lIsDone, STL->( RecNo() ), IIf( oParser[nIndex]:operation == 'D', .T., .F. ) } )

		EndIf

		aInputTemp := {}

	Next nIndex

	// Tratamento exclusivo para inclusão e alteração dos insumos previstos.
	If !Empty( aInputs[_FORESEEN_,_UPDATE_] ) .Or. !Empty( aInputs[_FORESEEN_,_INSERT_] )

		/*
			Loop executado três vezes para que possa abranger insumos previstos dos processo de inclusão/alteração.
		*/
		For nOpcX := 1 To 2

			If !Empty( aInputs[_FORESEEN_,nOpcX] )

				aTask := aClone( aInputs[_FORESEEN_,nOpcX] )

				// Processo de verificação do Produto Alternativo.
				If FindFunction( 'NGALTPROD' ) .And. Trim( SuperGetMv( 'MV_MNTPRAL', .F., '2' ) ) == '1' .And.;
					Trim( SuperGetMv( 'MV_NGGERSA', .F., 'N' ) ) == 'N' .And. Trim( SuperGetMv( 'MV_NGMNTES', .F., 'N' ) ) == 'S'

					aTask := NGALTPROD( aTask, , cEquip, 'TL', 'MNTNG', { _TYPE_, _CODE_, _AMOUNT_, _TASK_, _WAREHOUSE_,;
						_DESTINY_, _COST_ } )

				EndIf

			EndIf

		Next nOpcX

	EndIf

Return cError

//---------------------------------------------------------------------
/*/{Protheus.doc} getCheckList
Preenche o array aETAPAS

@author	Larissa Thaís de Farias
@since	24/03/16
@param oParser, array, etapas vindos do JSON
@param  cOrder, string, código da ordem
@param cPlan, string, plano
@param cType, string, tipo de manutenção: 'P' ou 'C'
@param cEquipment, string, código do bem 
@param cService, string, código do serviço
@param cSequence, string, sequencia da manutenção

@return string, vazio ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function getCheckList( oParser,  cOrder, cPlan, cType, cEquipment, cService, cSequence )

	Local aCheck    := {}
	Local aAnswers  := {}
	Local aConvert  := {}
	Local aAux      := {}
	Local cConteudo := ''
	Local cError    := ''
	Local cTask     := ''
	Local cStep     := ''
	Local cWorker   := ''
	Local cOk       := ''
	Local cMarca    := GetMark()
	Local cTaskDef  := Padr( '0', TamSx3( 'TQ_TAREFA' )[1] )
	Local cSeqStep  := Space( TamSx3('TQ_SEQETA')[1] )
	Local cSeqTask  := Space( TamSx3("TQ_SEQTARE")[1] )
	Local nI        := 1
	Local nX        := 0
	Local cKeyManut := ''

	Default cOrder := ''
	Default cPlan  := ''

	If cType == 'P'
		cKeyManut := xFilial('STF') + cEquipment + cService + cSequence
	EndIf

	For nI := 1 To Len( oParser )

		cTask    := IIf( AttIsMemberOf( oParser[nI], 'task' ), Padr( oParser[nI]:task, TamSx3( 'TQ_TAREFA' )[1] ), cTaskDef )
		cStep    := IIf( AttIsMemberOf( oParser[nI], 'step' ), Padr( oParser[nI]:step, TamSx3( 'TQ_ETAPA' )[1] ), '' )
		cOk      := IIf( AttIsMemberOf( oParser[nI], 'isDone' ) .And. oParser[nI]:isDone, cMarca, '' )
		cWorker  := IIf( AttIsMemberOf( oParser[nI], 'worker' ), Padr(oParser[nI]:worker, TamSx3('TQ_CODFUNC')[1]), '' )
		cSeqStep := Space( TamSx3('TQ_SEQETA')[1] )
		cSeqTask := Space( TamSx3("TQ_SEQTARE")[1] )

		lVerManut := .T.

		//-----------------------------------------------
		// Busca sequencia da etapa já gravada no banco
		//-----------------------------------------------
		If !Empty(  cOrder )

			dbSelectArea('STQ')
			dbSetOrder(1)
			If dbSeek( xFilial('STQ') +  cOrder + cPlan + cTask + cStep )

				cSeqStep := STQ->TQ_SEQETA
				cSeqTask := STQ->TQ_SEQTARE

				lVerManut := .F.
	
			EndIf
		
		EndIf

		//--------------------------------------------------------
		// Busca sequencia das etapas pelo cadastro da manutenção
		//--------------------------------------------------------
		If cType == 'P' .And. lVerManut

			dbSelectArea('ST5')
			dbSetOrder(1)
			If dbSeek( cKeyManut + cTask )
				cSeqTask := CValToChar( ST5->T5_SEQUENC )
			EndIf

			dbSelectArea('STH')
			dbSetOrder(1)
			If dbSeek( cKeyManut + cTask + cStep )
				cSeqStep := STH->TH_SEQETA
			EndIf

		EndIf

		//-------------------------------------
		// Respostas das etapas
		//-------------------------------------
		If AttIsMemberOf( oParser[nI], 'answers' )
			aAux:= oParser[nI]:answers
			For nX := 1 to Len(aAux)
				aConvert := fToString(oParser[nI]:step,aAux[nX]:code,aAux[nX]:value)
				cConteudo := aConvert[2]

				If !aConvert[1]
					cError := cConteudo
					Exit
				EndIf

				aadd(aAnswers, { Padr(aAux[nX]:code,TamSx3("TPQ_OPCAO")[1]),Padr(cConteudo, TamSx3("TPQ_RESPOS")[1])})
			Next
			If !Empty(cError)
				Exit
			EndIf
		EndIf

		//1 - TQ_TAREFA
		aAdd( aCheck, cTask )

		//2 - TQ_ETAPA
		aAdd( aCheck, cStep )

		//3 - TQ_SEQETA
		aAdd( aCheck, cSeqStep )

		//4 - TQ_SEQTARE
		aAdd( aCheck, cSeqTask )

		//5 - TQ_CODFUNC
		aAdd( aCheck, cWorker )

		//6 - TQ_OK
		aAdd( aCheck, cOk )

		//7 - aAnswers:= {TPQ_OPCAO, TPQ_RESPOS}
		aAdd( aCheck, aAnswers )

		aAdd( aETAPAS, aCheck )
		aCheck   := {}
		aAnswers := {}

	Next nI

Return cError

//---------------------------------------------------------------------
/*/{Protheus.doc} InputSTQ
Insere as etapas e respostas

@author	Maria Elisandra de paula
@author	Larissa Thaís de Farias
@since  24/03/16
@param cOrder, caracter, número da Ordem de Serviço
@param cPlan, caracter, código do plano da ordem de serviço
@return array, [1] vazio ou descrição do erro,
               [2] array com as ordens geradas pelas respostas
			   [3] array com as solicitações geradas pelas respostas
			   [4] respostas não geradas
aEtapas:
[1]-TQ_TAREFA
[2]-TQ_ETAPA
[3]-TQ_SEQETA
[4]-TQ_SEQTARE
[5]-TQ_CODFUNC
[6]-TQ_OK
[7]-{TPQ_OPCAO, TPQ_RESPOS}

/*/
//---------------------------------------------------------------------
Static Function InputSTQ(cOrder, cPlan)

	Local oStep
	Local cError     := ""
	Local cTarefa    := ''
	Local cEtapa     := ''
	Local cSeqTask   := ''
	Local cSeqCheck  := ''
	Local nI         := 0 
	Local nX         := 0
	Local nOperat    := 0
	Local aOSGeradas := {}
	Local aSSGeradas := {}
	Local aAnswers   := {}
	Local aCols      := {}
	Local aExcluir   := {}
	Local aNoSTQ     := {}
	Local aInfoList  := {}

	//------------------------------------
	// Exclusões de etapas
	//------------------------------------

	dbSelectArea("STQ")
	dbSetOrder(1)
	If dbSeek(xFilial("STQ") +  cOrder + cPlan)
		While !Eof() .And. cOrder + cPlan == STQ->TQ_ORDEM + STQ->TQ_PLANO
			If aScan(aEtapas,{|x|Alltrim(x[1]) == Alltrim(STQ->TQ_TAREFA)  .And.;
								Alltrim(x[2]) == Alltrim(STQ->TQ_ETAPA )}) == 0
				aAdd(aExcluir,{STQ->TQ_ORDEM, STQ->TQ_PLANO, STQ->TQ_TAREFA, STQ->TQ_ETAPA, STQ->TQ_SEQTARE})
			EndIf
			dbSkip()
		EndDo
	EndIf

	For nX := 1 to Len(aExcluir)

		oStep := MNTStep():New()
		oStep:setAsk(.F.)//Não apresenta mensagens condicionais (.F.)
		oStep:setOperation(5)//seta operação como 'excluir'
		oStep:Load({xFilial("STQ") + ;
					aExcluir[nX][1] + ;
					aExcluir[nX][2] + ;
					aExcluir[nX][3] + ;
					aExcluir[nX][4] + ;
					aExcluir[nX][5]})

		If oStep:valid()// Realiza as validações de Etapas
			oStep:delete()//Deleta a Etapa
		Else
			cError := STR0125 + ":" + Space(1) +  aExcluir[nX][4] + Space(1) //"Operação excluir etapa"
			cError += STR0126 + ":" + Space(1) + oStep:GetErrorList()[1] //"Erro"
			Exit
		EndIf

	Next nX

	If Empty(cError)

		//------------------------------------
		// Alterações e inclusões de etapas
		//------------------------------------
		For nI := 1 to Len(aEtapas)

			cTarefa   := aEtapas[nI][1]
			cEtapa    := aEtapas[nI][2]
			cSeqCheck := aEtapas[nI][3]
			cSeqTask  := aEtapas[nI][4]
			cCodFun   := aEtapas[nI][5]
			cOk       := aEtapas[nI][6]
			aAnswers  := aEtapas[nI][7]

			dbSelectArea("STQ")
			dbSetOrder(1)
			If dbSeek(xFilial("STQ") +  cOrder + cPlan + cTarefa + cEtapa + cSeqTask)
				//-------------------------------------------
				//verifica se houve alguma alteração na etapa
				//-------------------------------------------
				If fModifEtapa(cOrder,cPlan,cTarefa,cEtapa,cOk,aAnswers)
					nOperat := 4
				Else
					//----------------------------------------
					// quando uma resposta não foi alterada não
					// tem necessidade de enviar para alteração
					//----------------------------------------
					Loop
				EndIf
			Else
				nOperat := 3
			EndIf
			oStep := MNTStep():New()
			oStep:setAsk(.F.)//Não apresenta mensagens condicionais (.F.)
			oStep:setOperation(nOperat)//set

			If nOperat == 4
				oStep:Load({xFilial("STQ") + cOrder + cPlan + cTarefa + cEtapa + cSeqTask})
			EndIf

			oStep:setValue("TQ_FILIAL" , xFilial("STQ"))
			oStep:setValue("TQ_ORDEM"  , cOrder)
			oStep:setValue("TQ_PLANO"  , cPlan)
			oStep:setValue("TQ_TAREFA" , cTarefa)
			oStep:setValue("TQ_ETAPA"  , cEtapa)
			oStep:setValue("TQ_SEQETA" , cSeqCheck)
			oStep:setValue("TQ_SEQTARE", cSeqTask)
			oStep:setValue("TQ_CODFUNC", cCodFun)
			oStep:setValue("TQ_OK"     , cOk)


			//-------------------------------------------------------
			//Carrega acols de acordo com respostas
			//-------------------------------------------------------
			aHeaderAux:= oStep:GetHeader("TPQ")
			aCols := fCargaAcols(cOrder, cPlan, cTarefa, cEtapa, aAnswers, aHeaderAux,nOperat)

			oStep:setCols("TPQ", aCols)

			aInfoList := {}

			If oStep:valid()// Realiza as validações de Etapas
				If oStep:upsert()//Realiza a gravação das Etapas

					//----------------------------------------
					//recupera ordens geradas pelas respostas
					//-----------------------------------------
					aAdd(aOSGeradas,aClone(oStep:getResultList()[_OS_]))

					//----------------------------------------
					//recupera solicitações geradas pelas respostas
					//-----------------------------------------
					aAdd(aSSGeradas,aClone(oStep:getResultList()[_SS_]))


				Else
					cError:= STR0127 + ":" + Space(1) +  cEtapa + Space(1) //"Operação alterar/incluir etapa"
					cError+= STR0126 + ":" + oStep:GetErrorList()[1] //"Erro"
					Exit
				EndIf
			Else

				//-----------------------------------------------
				//recupera informações das respostas não geradas
				//-----------------------------------------------
				aInfoList := oStep:getInfoList()
				If Len(aInfoList) > 0
					For nX := 1 to Len(aInfoList)
						aAdd(aNoSTQ, {cTarefa, cEtapa, aInfoList[nX]})
					Next nX
				Else
					cError:= STR0127 + ":" + Space(1) +  cEtapa + Space(1) //"Operação alterar/incluir etapa"
					cError+= STR0126 + ":" + oStep:GetErrorList()[1] //"Erro"
					Exit
				EndIf
			EndIf
		Next nI
	EndIf
Return { cError, aOSGeradas, aSSGeradas, aNoSTQ }

//---------------------------------------------------------------------
/*/{Protheus.doc} InputSTLRea
Realiza processamento dos insumos realizados
@type function

@author	Alexandre Santos
@since  20/11/2020

@param cOrdem, string, número da Ordem de Serviço
@param cType , string, tipo da OS, C: Corretiva, P: Preventiva
@return nil
/*/
//---------------------------------------------------------------------
Static Function InputSTLRea(cOrdem, cType )

	Local cError     := ""
	Local nInput     := 0
	Local lEstNega   := AllTrim(GetMv("MV_ESTNEG")) == "S"
	Local lMoveStock := .F.
	Local cUsaIntEs  := SuperGetMv("MV_NGMNTES",.F.,"N")
	Local aDelete    := {}
	Local aUpdate    := {}
	Local aInsert    := {}

	// Alteração e Inclusão de Insumos
	If !Empty( aInputs[_REALIZED_,_UPDATE_] ) .Or. !Empty( aInputs[_REALIZED_,_INSERT_] )

		// Forma de facilitar a codificação e entendimento da matriz.
		aUpdate := aClone( aInputs[_REALIZED_,_UPDATE_] )

		For nInput := 1 To Len( aUpdate )

			dbSelectArea( 'STL' )
			dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA + TL_SEQTARE
			If msSeek( xFilial( 'STL' ) + STJ->TJ_ORDEM + STJ->TJ_PLANO + aUpdate[nInput,_KEYTASK_] + aUpdate[nInput,_TYPE_] +;
				aUpdate[nInput,_KEYCODE_] + aUpdate[nInput,_SEQUENCE_] )

				// Indica que não será inclusa uma nova movimentação de estoque - SD3 para o insumo.
				lMoveStock := .F.

				If STL->TL_QUANTID != aUpdate[nInput,_AMOUNT_] .Or.	STL->TL_CODIGO != aUpdate[nInput,_CODE_]

					// Realiza estorno da movimentação de estoque somente quando houver alteração no produto ou quantidade.
	            	cError := RevMovSto()

					If !Empty( cError )
						printf( cError )
						Return cError
					EndIf

					// Indica que será inclusa uma nova movimentação de estoque - SD3 para o insumo.
					lMoveStock := .T.

				EndIf

				printf( '  - Modificando insumo realizado: ' + Trim( STL->TL_TAREFA ) + '/' + Trim( STL->TL_CODIGO ) +;
					' -> ' + Trim( aUpdate[nInput,_TASK_] ) + '/' + Trim( aUpdate[nInput,_CODE_] ) +;
					' ( ' + cValToChar( aUpdate[nInput,_AMOUNT_] ) +      ' )' )

				If !NGRETINS( 	STJ->TJ_ORDEM                   ,;
								STJ->TJ_PLANO                   ,;
								cType                           ,; // PTIPO
								Nil                             ,;	// PCODBEM
								Nil                             ,; // PSERVICO
								Nil                             ,;	// PSEQ
								aUpdate[nInput,_TASK_]       ,;
								aUpdate[nInput,_TYPE_]          ,;
								aUpdate[nInput,_CODE_]       ,;
								aUpdate[nInput,_AMOUNT_]        ,;
								aUpdate[nInput,_UNITY_]         ,;
								aUpdate[nInput,_DESTINY_]       ,;
								'Insumo Realizado.'             ,;
								aUpdate[nInput,_STARTDATE_]     ,;
								aUpdate[nInput,_STARTHOUR_]     ,;
								'F'                             ,; //PGERAFES
								aUpdate[nInput,_WAREHOUSE_]     ,;
								aUpdate[nInput,_LOT_]           ,;
								aUpdate[nInput,_SUBLOT_]        ,;
								aUpdate[nInput,_DATELOT_]       ,;
								aUpdate[nInput,_LOCATION_]      ,;
								aUpdate[nInput,_PERCENT_]       ,;
								aUpdate[nInput,_USECALE_]       ,;
								'N'                             ,; // PGARANT
								Nil                             ,; // PLOCAPL
								Nil                             ,; // PQTDGAR
								Nil                             ,; // PUNIGAR
								Nil                             ,; // PCONGAR
								.T.                             ,; // PLEST
								@cError, ,                      ,;
								aUpdate[nInput,_RESOURCEAMOUNT_],;
								aUpdate[nInput,_SERIALNUMBER_]  ,;
								{ aUpdate[nInput,_KEYTASK_]     ,;
								  aUpdate[nInput,_KEYCODE_] }   ,;
								aUpdate[nInput,_SEQUENCE_]      ,;
								aUpdate[nInput,_SEQTASK_]       ,;
								lMoveStock )

					printf( cError )
					Return cError

				EndIf

				If Empty( cError )
					RecLock( 'STL', .F. )
						STL->TL_OBSERVA := aUpdate[nInput,_INPUTNOTE_]
					STL->( MsUnLock() )
				EndIf

				If !Empty( aUpdate[nInput,_OCCURRENCES_,_INSERT_] ) .Or. !Empty( aUpdate[nInput,_OCCURRENCES_,_UPDATE_] ) .Or.;
					!Empty( aUpdate[nInput,_OCCURRENCES_,_DELETE_] )

					// Grava ocorrências na base de dados
					InputSTN( xFilial( 'STN' ), STJ->TJ_ORDEM, STJ->TJ_PLANO, STL->TL_TAREFA, STL->TL_SEQRELA,;
						aUpdate[nInput,_OCCURRENCES_] )

				EndIf

			Else

				// Caso não encontra para alteração, adiciona na lista de inclusão de insumos.
				aAdd( aInputs[_REALIZED_,_INSERT_], aUpdate[nInput] )

			EndIf

		Next nInput

		// Forma de facilitar a codificação e entendimento da matriz.
		aInsert := aClone( aInputs[_REALIZED_,_INSERT_] )

		For nInput := 1 To Len( aInsert )

			If cUsaIntEs == 'S' .And. aInsert[nInput,_TYPE_] == 'P' .And. !lEstNega //Testa poder ter saldo negativo se retornar .T.(Prossegue e nao testa o saldo em estoque)se .F.(Testa se o Saldo esta negativo)

				INCLUI := .T. // Essa variavel foi declarada pq é utilizada na função NGSALSB2

				// Testa se o saldo esta negativo
				If !NGSALSB2( aInsert[nInput,_CODE_], aInsert[nInput,_WAREHOUSE_], aInsert[nInput,_AMOUNT_], .F., ,;
					aInsert[nInput,_STARTDATE_], .T. )
					Return STR0034 + ' ' + NGSEEK( 'SB1', aInsert[nInput,_CODE_], 1, 'B1_DESC' ) // Saldo insuficiente para o produto:
				EndIf

			EndIf

			printf( '  - Incluindo insumo realizado ' + Trim( aInsert[nInput,_TASK_] ) + '/' + Trim( aInsert[nInput,_CODE_] ) + ' ( ' +;
				cValtochar( aInsert[nInput,_AMOUNT_] ) + ' )' )

			If !NGRETINS( 	STJ->TJ_ORDEM              ,;
							STJ->TJ_PLANO              ,;
							cType                      ,; // PTIPO
							Nil                        ,;	// PCODBEM
							Nil                        ,; // PSERVICO
							Nil                        ,;	// PSEQ
							aInsert[nInput,_TASK_]     ,;
							aInsert[nInput,_TYPE_]     ,;
							aInsert[nInput,_CODE_]     ,;
							aInsert[nInput,_AMOUNT_]   ,;
							aInsert[nInput,_UNITY_]    ,;
							aInsert[nInput,_DESTINY_]  ,;
							'Insumo Realizado.'        ,;
							aInsert[nInput,_STARTDATE_],;
							aInsert[nInput,_STARTHOUR_],;
							'F'                        ,; //PGERAFES
							aInsert[nInput,_WAREHOUSE_],;
							aInsert[nInput,_LOT_]      ,;
							aInsert[nInput,_SUBLOT_]   ,;
							Nil                        ,; // PDTVALID
							aInsert[nInput,_LOCATION_] ,;
							aInsert[nInput,_PERCENT_]  ,;
							'N'                        ,; // PCALEND
							'N'                        ,; // PGARANT
							Nil                        ,; // PLOCAPL
							Nil                        ,; // PQTDGAR
							Nil                        ,; // PUNIGAR
							Nil                        ,; // PCONGAR
							.T.                        ,; // PLEST
							@cError, ,                 ,;
							aInsert[nInput,_RESOURCEAMOUNT_],;
							aInsert[nInput,_SERIALNUMBER_] )

				printf( cError )
				Return cError

			EndIf

			If Empty( cError )
				RecLock( 'STL', .F. )
					STL->TL_OBSERVA := aInsert[nInput,_INPUTNOTE_]
				STL->( MsUnLock() )
			EndIf

			If !Empty( aInsert[nInput,_OCCURRENCES_,_INSERT_] ) .Or. !Empty( aInsert[nInput,_OCCURRENCES_,_UPDATE_] ) .Or.;
				!Empty( aInsert[nInput,_OCCURRENCES_,_DELETE_] )

				// Grava ocorrências na base de dados
				InputSTN( xFilial( 'STN' ), STJ->TJ_ORDEM, STJ->TJ_PLANO, STL->TL_TAREFA, STL->TL_SEQRELA,;
					aInsert[nInput,_OCCURRENCES_] )

			EndIf

		Next nInput

	EndIf

	// Deleção de insumos
	If !Empty( aInputs[_REALIZED_,_DELETE_] )

		// Forma de facilitar a codificação e entendimento da matriz.
		aDelete := aClone( aInputs[_REALIZED_,_DELETE_] )

		For nInput := 1 To Len( aDelete )

			dbSelectArea( 'STL' )
			dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA + TL_SEQTARE
			If msSeek( xFilial( 'STL' ) + STJ->TJ_ORDEM + STJ->TJ_PLANO + aDelete[nInput,_KEYTASK_] + aDelete[nInput,_TYPE_] +;
				aDelete[nInput,_KEYCODE_] + aDelete[nInput,_SEQUENCE_] )

				// Verificar se o insumo foi gerado por meio de uma requisicao do estoque e nao deleta
				// Insumos realizados com solicitação de armazém não devem ser deletados
	            If ( STL->TL_ORIGNFE $ 'SD3%SD1' ) .Or. ( !Empty( STL->TL_NUMSA ) )
	                Loop
	            EndIf

				printf( '  - Excluindo insumo realizado: ' + Trim( STL->TL_TAREFA ) + '/' + Trim( STL->TL_CODIGO ) +;
					' (' + cValToChar( STL->TL_QUANTID ) + ')' )

	            cError := RevMovSto()

				If !Empty( cError )
					printf( cError )
					Return cError
				EndIf

				dbSelectArea("TPZ")
				dbSetOrder(1)
				dbSeek(xFilial("TPZ")+STJ->TJ_ORDEM+STJ->TJ_PLANO)
	            While !EoF() .And. TPZ->(TPZ_FILIAL+TPZ_ORDEM+TPZ_PLANO+TPZ_SEQREL) == xFilial("TPZ")+STJ->TJ_ORDEM+STJ->TJ_PLANO+STL->TL_SEQRELA
					RecLock("TPZ",.F.)
					DbDelete()
					TPZ->(MsUnLock())
					TPZ->(dbSkip())
				EndDo

				RecLock( 'STL', .F. )
					dbDelete()
				STL->( MsUnLock() )

			EndIf

		Next nInput

	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} InputSTLPrev
Realiza processamento dos insumos previstos

@author	Larissa Thaís de Farias
@since  24/03/16
@param cOrdem, string, número da Ordem de Serviço
@param lAltera, boolean, se operação é alteração
@param cType, string, tipo da OS, C: Corretiva, P: Preventiva
@return string, vazio ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function InputSTLPrev(cOrdem, cType, lAltera, oWS)

	Local nI     := 1
	Local nInput := 0
	Local cError := ""

	Private aDtSa  := {}

	//Variável aRotina é utilizada na função NGRETINS quando insumo tipo produto com estrutura
	Private aRotina := {}

	// Gravação e bloqueio de insumos
	If !Empty( aInputs[_FORESEEN_,_UPDATE_] ) .Or. !Empty( aInputs[_FORESEEN_,_INSERT_] )

		//-------------------------------------------------------------------
		// Realiza a criação dos Insumos Previstos e gera array de bloqueio
		//-------------------------------------------------------------------
		aBLO := NGGSTLSTQ( STJ->TJ_ORDEM, STJ->TJ_PLANO, STJ->TJ_CCUSTO, oWs )

		//TODO: ver garantia

		//-------------------------------------------------------------
		// Efetua o bloqueio de Ferramentas
		//-------------------------------------------------------------
		For nI := 1 to Len(aBLO[1])
			printf( ' - Bloqueando Ferramentas' )
			a330FER(aBLO[1][nI])
		Next nI

		//-------------------------------------------------------------
		// Efetua o bloqueio de Mao de Obra
		//-------------------------------------------------------------
		For nI := 1 To Len(aBLO[2])
			printf(" - Bloqueando Mao de Obra")
			a330FUN(aBLO[2][nI])
		Next nI

		//-------------------------------------------------------------
		// Efetua o bloqueio de Especialistas
		//-------------------------------------------------------------
		For nI := 1 To Len(aBLO[3])
			printf(" - Bloqueando Especialistas")
			a330ESP(aBLO[3][nI])
		Next nI

		//-------------------------------------------------------------
		// Efetua o bloqueio de Produtos
		//-------------------------------------------------------------
		If Len(aBLO[4]) > 0

			cError := blockProduct(3, lAltera )

		EndIf

		//-------------------------------------------------------------
		// Gera Solicitacao de compra para terceiros
		//-------------------------------------------------------------
		If Empty( cError ) .And. Len( aBLO[5] ) > 0

			blockThird()

		EndIf

		aBLO := {}

	EndIf

	// Deleção de insumos
	If !Empty( aInputs[_FORESEEN_,_DELETE_] )

		// Forma de facilitar a codificação e entendimento da matriz.
		aDelete := aClone( aInputs[_FORESEEN_,_DELETE_] )

		For nInput := 1 To Len( aDelete )

			dbSelectArea( 'STL' )
			dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA + TL_SEQTARE
			If msSeek( xFilial( 'STL' ) + STJ->TJ_ORDEM + STJ->TJ_PLANO + aDelete[nInput,_KEYTASK_] + aDelete[nInput,_TYPE_] +;
				aDelete[nInput,_KEYCODE_] + aDelete[nInput,_SEQUENCE_] + aDelete[nInput,_SEQTASK_] )

				// Remove relacionamentos associados ao insumo.
				DeleteRelation()

				printf( '  - Excluindo insumo previsto: ' + Trim( STL->TL_TAREFA ) + '/' + Trim( STL->TL_CODIGO ) +;
						' (' + cValToChar( STL->TL_QUANTID ) + ')' )

				RecLock( 'STL', .F. )
					dbDelete()
				STL->( MsUnLock() )

			EndIf

		Next nInput

	EndIf

Return cError


//---------------------------------------------------------------------
/*/{Protheus.doc} NGGSTLSTQ
Grava as etapas e insumos previstos

@author	Larissa Thaís de Farias
@since	24/03/16

@param cORDEM, string, numero da Ordem de Servico
@param cPLANOOS, string, numero do plano da Ordem de Servico
@param cCENTCUS, string, codigo do centro de custo

@return aBLO, array, insumos para fazer bloqueio
/*/
//---------------------------------------------------------------------
Static Function NGGSTLSTQ( cORDEM, cPLANOOS, cCENTCUS, oWS )

	Local aBlo      := { {}, {}, {}, {}, {} }
	Local cUsaBloqC := AllTrim(GETMV("MV_NGCORPR"))
	Local cRecno := ''
	Local aTask  := {}
	Local nInput := 0
	Local nOpcX  := 0

	If cPLANOOS > "000000"
		M->TI_BLOQFUN := "S"
		M->TI_BLOQFER := "S"
		M->TI_BLOQITE := "S"
		M->TI_PLANO   := cPLANOOS
	Else
		M->TI_BLOQFUN := If(cUsaBloqC == "S","S","N")
		M->TI_BLOQFER := If(cUsaBloqC == "S","S","N")
		M->TI_BLOQITE := If(cUsaBloqC == "S","S","N")
		M->TI_PLANO   := cPLANOOS
	EndIf

	/*
		Loop executado duas vezes para que possa abranger insumos previstos do processo de inclusão/alteração.
	*/
	For nOpcX := 1 To 2

		aTask := aClone( aInputs[_FORESEEN_,nOpcX] )

		For nInput := 1 to Len( aTask )

			dbSelectArea( 'STL' )
			dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA + TL_SEQTARE
			If nOpcX == 1 .And. msSeek( xFilial( 'STL' ) + STJ->TJ_ORDEM + STJ->TJ_PLANO + aTask[nInput,_KEYTASK_] + aTask[nInput,_TYPE_] +;
				aTask[nInput,_KEYCODE_] + aTask[nInput,_SEQUENCE_] + aTask[nInput,_SEQTASK_] )

				printf( ' - Modificando insumo previsto: ' + Trim( aTask[nInput,_KEYTASK_] ) + '/' + Trim( aTask[nInput,_KEYCODE_] ) +;
					' -> ' + Trim( aTask[nInput,_TASK_] ) + '/' + Trim( aTask[nInput,_CODE_] ) +;
					' ( ' + cValToChar( aTask[nInput,_AMOUNT_] ) + ' )' )

				// Remove relacionamentos associados ao insumo.
				DeleteRelation( @aTask[nInput] )

				RecLock( 'STL', .F. )

			Else

				printf( ' - Incluindo insumo previsto ' + Trim( aTask[nInput,_TASK_] ) + '/' + Trim( aTask[nInput,_CODE_] ) +;
					'( ' + cValToChar( aTask[nInput,_AMOUNT_] ) + ' )' )

				RecLock( 'STL', .T. )
				STL->TL_FILIAL  := xFilial( 'STL' )
				STL->TL_ORDEM   := cORDEM
				STL->TL_PLANO   := cPLANOOS

			EndIf

			STL->TL_TAREFA  := aTask[nInput,_TASK_]
			STL->TL_TIPOREG := aTask[nInput,_TYPE_]
			STL->TL_CODIGO  := aTask[nInput,_CODE_]
			STL->TL_SEQRELA := '0  '
			STL->TL_SEQTARE := aTask[nInput,_SEQTASK_]
			STL->TL_DTINICI := aTask[nInput,_STARTDATE_]
			STL->TL_HOINICI := aTask[nInput,_STARTHOUR_]
			STL->TL_DTFIM   := aTask[nInput,_ENDDATE_]
			STL->TL_HOFIM   := aTask[nInput,_ENDHOUR_]
			STL->TL_QUANREC := aTask[nInput,_RESOURCEAMOUNT_]
			STL->TL_QUANTID := aTask[nInput,_AMOUNT_]
			STL->TL_UNIDADE := aTask[nInput,_UNITY_]
			STL->TL_DESTINO := aTask[nInput,_DESTINY_]
			STL->TL_LOCAL   := aTask[nInput,_WAREHOUSE_]
			STL->TL_TIPOHOR := aTask[nInput,_HOURUNITY_]
			STL->TL_USACALE := aTask[nInput,_USECALE_]
			STL->TL_FORNEC  := aTask[nInput,_CATERER_]
			STL->TL_LOJA    := aTask[nInput,_STORE_]
			STL->TL_NUMSA   := aTask[nInput,_WHREQUEST_]
			STL->TL_ITEMSA  := aTask[nInput,_WHITEM_]
			STL->TL_OBSERVA := aTask[nInput,_INPUTNOTE_]
			STL->TL_CUSTO   := NGCALCUSTI( aTask[nInput,_CODE_], aTask[nInput,_TYPE_], aTask[nInput,_AMOUNT_], ,;
				aTask[nInput,_HOURUNITY_] )

			STL->(MsUnlock())


			If lPeMntNg
				ExecBlock("MNTNG",.F.,.F.,{ "CREATED_PLANNED_INPUT", oWs })
			EndIf

			cRecno := STL->( Recno() )

			nTIP := 0
			If aTask[nInput,_TYPE_] == "F"
				nTIP := If(M->TI_BLOQFER == "S",1,0)
			ElseIf aTask[nInput,_TYPE_] == "M"
				nTIP := If(M->TI_BLOQFUN == "S",2,0)
			ElseIf aTask[nInput,_TYPE_] == "E"
				nTIP := If(M->TI_BLOQFUN == "S",3,0)
			ElseIf aTask[nInput,_TYPE_] == "P"
				nTIP := If(M->TI_BLOQITE == "S",4,0)
			ElseIf aTask[nInput,_TYPE_] == "T"
				nTIP := If(M->TI_BLOQITE == "S",5,0)
			EndIf

			If nTIP > 0 .And. Empty(STL->TL_NUMSA+STL->TL_ITEMSA)

				//---------------------
				// Estrutura array aBlo, grava STL
				//---------------------
				aAdd( aBlo[nTIP] , MntBloArr( cRecno, cCENTCUS ) )

			EndIf

		Next nInput

	Next nOpcX

Return aBLO

//---------------------------------------------------------------------
/*/{Protheus.doc} blockProduct
Bloqueia Produtos
@type function

@author	Larissa Thaís de Farias
@since	24/03/2016

@param  nOpM    , numérico, número da operação
@return Caracter, Mensagem de erro, caso tenha.

@obs Cópia da função A330PRO
/*/
//---------------------------------------------------------------------
Static Function blockProduct(nOpM, lAltera )

	Local aRet       := { .T., '' }
	Local lLogix     := AllTrim( GetNewPar("MV_NGINTER", "N") ) == "L"
	Local aLinhaProd := {}

	Private aIAglu := {} // [PRODUTO],[LOCAL],[QUANTIDADE],[OP],[TAREFA],[C.C.],[DT. INICIO],[RESERVA],[ORDEM],[PLANO]....[QUANTIDADE REAL]
	Private nPRO := 1 //Variavel utilizada pela funcao NGPRODALTER
	Private lGeraSA	:= NG420CHKSA()
	Private aSCGer	:= {}
	Private aSTLRep	:= {}
	Private	cNuISC1 := 0 //utilizada na S.C.

	//Variáveis utilizadas para não ocorrer erros nas chamadas de funções posteriorres a blockProduct
	M->TJ_ORDEM := STJ->TJ_ORDEM
	M->TJ_PLANO := STJ->TJ_PLANO
	M->TJ_CODBEM:= STJ->TJ_CODBEM

	cOP  := M->TJ_ORDEM + "OS001"
	cOP := Alltrim(cOP)+Space(Len(SC1->C1_OP) - Len(Alltrim(cOP)))

	printf(" - Bloqueando Produtos")

	While nPRO <= Len(aBLO[4])

		Iold		:= nPRO
		cCodPro		:= Left(aBLO[4][nPRO][2], Len(SB1->B1_COD))
		cOP			:= AllTrim(aBLO[4][nPRO][8]) + "OS001"
		cOP			:= Alltrim(cOP)+Space(Len(SC1->C1_OP) - Len(Alltrim(cOP)))
		cLOCSTL		:= aBLO[4][nPRO][18]
		cLocAux		:= aBLO[4][nPRO][18]
		nQTDCOMP	:= aBLO[4][nPRO][3] //0.00
		lPROBLEMA	:= .F.
		cALMCOMP	:= '01'
		cALMEMPE	:= '01'
		cOPrin		:= cOP
		cTAREFA		:= aBLO[4][nPRO][1]

		// NOVO PROCESSO DE SOLICITACAO
		// AGLUTINACAO POR PRODUTO E ALMOAXARIFADO
		nPosSC := Ascan(aIAglu,{|x| x[1]+x[2] = cCodPro+cLOCSTL})
		If nPosSC > 0
			aIAglu[nPosSC][3] += nQTDCOMP
			If lAltera
				aIAglu[nPosSC,Len(aIAglu[nPosSC])] += nQTDCOMP
			EndIf
		Else
			aAdd(aIAglu,{cCodPro,cLOCSTL,nQTDCOMP,cOp,cTAREFA,STJ->TJ_CCUSTO,;
				aBLO[4][nPRO][4],"S",aBLO[4,nPRO,8],aBLO[4,nPRO,9]})
			If lAltera
				Aadd(aIAglu[Len(aIAglu)],nQTDCOMP)
			EndIf
		EndIf

		nPRO++
	End While

	If STJ->TJ_SITUACA == "L"

		If lAltera
			// RETIRA A QUANTIDADE JA SOLICITADA, ESTA NO NGUTIL02
			NGRETJACOMP(cOP)
		EndIf

		If lLogix .And. Empty(aLinhaProd)
			dbSelectArea("STL")
			dbSetOrder(1)
			If dbSeek( xFilial("STL") + STJ->TJ_ORDEM + STJ->TJ_PLANO )
				While !Eof() .And. STJ->TJ_ORDEM == STL->TL_ORDEM .And. STJ->TJ_PLANO == STL->TL_PLANO
					If Alltrim(STL->TL_SEQRELA) == "0"
						aAdd(aLinhaProd, {STL->TL_CODIGO, STL->TL_ORDEM, STL->TL_QUANTID, STL->TL_CODAEN})
					EndIf

					dbSelectArea("STL")
					dbSkip()
				End
			EndIf
		EndIf

		aRet := NGINTCOMPEST( STJ->TJ_DTMPINI, STJ->TJ_DTMPFIM, 'MNTA420', , aLinhaProd, , .T. )

	EndIf

	aIAglu := {}

Return IIf( ValType( aRet ) == 'A', aRet[2], '' )

//---------------------------------------------------------------------
/*/{Protheus.doc} blockThird
Bloqueia Terceiros

@author	Larissa Thaís de Farias
@since	24/03/16
@obs Cópia da função A330TER
@return nil
/*/
//---------------------------------------------------------------------
Static Function blockThird()

	Local i := 0
	Local cAlmox := PADR( SuperGetMV("MV_NGLOCPA",.F.,"01") , Len(STL->TL_LOCAL) )

	printf( ' - Gera S.A./S.C. para terceiros' )

	//Ordena registros conforme a maior quantidade solicitada
	aSort(aBLO[5],,,{|x,y| x[3] > y[3]})
	For i := 1 To Len(aBLO[5])

		If STJ->TJ_SITUACA = "L"
			If Empty(aBLO[5][i][18])
				a340TER(aBLO[5][i],cAlmox,aBLO[5][i][3],aBLO[5][i][19],.F.,i)
			Else
				a340TER(aBLO[5][i],aBLO[5][i][18],aBLO[5][i][3],aBLO[5][i][19],.F.,i)
			EndIf
		EndIf

	Next i

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MntBloArr
Preenche array aBlo com informacoes do insumo

@Param	nRecnoSTL - Registro da STL

@author Lucas Guszak
@author Larissa Farias
@since 29/08/2014
@param nRecnoSTL, numérico, recno da STL
@return .T.
/*/
//---------------------------------------------------------------------
Static Function MntBloArr( nRecnoSTL, cCusto )

	Local nQuantid := 0
	Local cTamItem := Space( TamSx3("C1_ITEM")[1] )
	Local aBloqueio := {}
	Local aAreaSTL := STL->( GetArea() )

	//------------------------------------------------
	// Posiciona no registro( Insumo ) a ser bloqueado
	//------------------------------------------------
	DbSelectArea( "STL" )
	DbGoTo( nRecnoSTL )

	//---------------------------------------------------------
	// Atribui quantidade para bloqueio conforme tipo do insumo
	//---------------------------------------------------------
	If STL->TL_TIPOREG $ "E/F"
		nQuantid := STL->TL_QUANREC
	Else
		nQuantid := STL->TL_QUANTID
	EndIf

	//---------------------
	// Estrutura array aBlo
	//---------------------
	aAdd( aBloqueio , STL->TL_TAREFA	) // 01 - Tarefa
	aAdd( aBloqueio , STL->TL_CODIGO	) // 02 - Codigo Insumo
	aAdd( aBloqueio , nQuantid			) // 03 - Quantidade
	aAdd( aBloqueio , STL->TL_DTINICI	) // 04 - Data Inicio
	aAdd( aBloqueio , STL->TL_HOINICI	) // 05 - Hora Inicio
	aAdd( aBloqueio , STL->TL_DTFIM		) // 06 - Data Fim
	aAdd( aBloqueio , STL->TL_HOFIM		) // 07 - Hora Fim
	aAdd( aBloqueio , STL->TL_ORDEM		) // 08 - Ordem de Servico
	aAdd( aBloqueio , STL->TL_PLANO		) // 09 - Plano
	aAdd( aBloqueio , cCusto			) // 10 - Centro de Custo
	aAdd( aBloqueio , STL->TL_LOCAL		) // 11 - Numero da SC
	aAdd( aBloqueio , STL->TL_UNIDADE	) // 12 - Numero do Item da SC
	aAdd( aBloqueio , "S"				) // 13 - Quantidade do Estoque da Opercao - TL_QTDOPER
	aAdd( aBloqueio , /* */				) // 14 - Almoxarifado da Operacao - TL_ALMOPERA
	aAdd( aBloqueio , 0.00				) // 15 - Quantidade de estoque da matriz - TL_QTDOMAT
	aAdd( aBloqueio , cTamItem			) // 16 - Almoxarifado da matriz - TL_ALMOMAT
	aAdd( aBloqueio , 0.00				) // 17 - Quantidade da SC  - TL_QTDSC1
	aAdd( aBloqueio , STL->TL_LOCAL		) // 18 - Codigo do local gravado na STL
	aAdd( aBloqueio , 0.00 				) // 19 - Unidade
	aAdd( aBloqueio , STL->TL_OBSERVA	) // 20 - Observacao do Insumo
	aAdd( aBloqueio , 0.00				) // 21 - Quantidade da SC TL_QTDSC1
	aAdd( aBloqueio , /* */				) // 22 - Gera Reserva?
	aAdd( aBloqueio , STL->TL_FORNEC	) // 23 - Fornecedor TL_FORNEC
	aAdd( aBloqueio , STL->TL_LOJA		) // 24 - Loja do fornecedor TL_LOJA

	RestArea( aAreaSTL )

Return aBloqueio

//---------------------------------------------------------------------
/*/{Protheus.doc}  fEqualOrder
Verifica se a OS já tenha foi inserida.
obs.: ocorre caso o aplicativo envie a requisição de create
e a internet caia antes de o WS dar o retorno.

@param aStartDate, array, data e Hora de início
@param cObservation, string, observação
@param nCounter, numérico, valor do primeiro contador
@param nCounter2, numérico, valor do segundo contador
@param cService, string, serviço
@param aEndDate, array, data e Hora de Fim
@param cEquipment, string, equipamento
@param cSequence, string, sequencia (caso Preventiva)
@param cType, string, tipo da ordem "P" para preventiva ou "C" para corretiva
@param dDtStopIni, date, data da parada
@param cHrStopIni, hora, hora da parada

@author Larissa Thaís de Farias
@since 08/04/2016
@return string, vazio ou código da ordem quando encontrada
/*/
//---------------------------------------------------------------------
Static Function fEqualOrder( aStartDate, cObservation, nCounter, nCounter2,;
				cService, aEndDate, cEquipment, cSequence, cType, dDtStopIni, cHrStopIni )

	Local cAliasQry := GetNextAlias()
	Local cOrdem    := ""
	Local cCondSql	:= "%%"

	If cType == "C"
		cCondSql := "%AND STJ.TJ_DTPRINI = " + ValToSQL( dDtStopIni ) + " AND STJ.TJ_HOPRINI = " + ValToSQL( cHrStopIni ) + "%"
	EndIf

	//-----------------------------------------
	// Busca O.S com mesmas características
	//-----------------------------------------
	BeginSql Alias cAliasQry

		SELECT STJ.TJ_ORDEM
		FROM %Table:STJ% STJ
		WHERE STJ.TJ_CODBEM = %exp:cEquipment%
			AND STJ.TJ_FILIAL = %xFilial:STJ%
			AND STJ.TJ_DTMPINI = %exp:Stod( aStartDate[1] )%
			AND STJ.TJ_HOMPINI = %exp:aStartDate[2]%
			AND STJ.TJ_DTMPFIM = %exp:Stod( aEndDate[1] )%
			AND STJ.TJ_HOMPFIM = %exp:aEndDate[2]%
			AND STJ.TJ_POSCONT = %exp:nCounter%
			AND STJ.TJ_SERVICO = %exp:cService%
			AND STJ.TJ_SEQRELA = %exp:cSequence%
			AND STJ.TJ_POSCON2 = %exp:nCounter2%
			AND STJ.TJ_SITUACA = 'L'
			AND %notDel%
			%exp:cCondSql%
		ORDER BY STJ.TJ_ORDEM DESC

	EndSql

	If !( cAliasQry )->( EoF() )
		cOrdem := (cAliasQry)->TJ_ORDEM
	EndIf

	(cAliasQry)->(dbCloseArea())

	If Empty( cOrdem )
		Return ""
	EndIf

	//-------------------------------------------------------
	// Trechos a seguir compara outras caracterícticas da OS
	//-------------------------------------------------------
	dbSelectArea("STJ")
	dbSetOrder(1)
	If !dbSeek( xFilial("STJ") + cOrdem ) .Or. Alltrim( STJ->TJ_OBSERVA ) != Alltrim( cObservation )
		Return ""
	EndIf

	// Quando insumos do json = zero e há STL
	dbSelectArea( 'STL' )
	dbSetOrder( 1 )
	If ( Empty( aInputs[_REALIZED_,_INSERT_] ) .Or. Empty( aInputs[_REALIZED_,_UPDATE_] ) .Or. Empty( aInputs[_REALIZED_,_DELETE_] ) ) .And.;
	   ( Empty( aInputs[_FORESEEN_,_INSERT_] ) .Or. Empty( aInputs[_FORESEEN_,_UPDATE_] ) .Or. Empty( aInputs[_FORESEEN_,_DELETE_] ) ) .And.;
	   dbSeek( xFilial( 'STL' ) + cOrdem )
		Return ''
	EndIf

Return cOrdem

//---------------------------------------------------------------------
/*/{Protheus.doc} fEqualSteps
Verifica se as Etapas são iguais

@param cOrdem, string, ordem de Serviço
@param cPlano, string, plano da Ordem de Serviço
@author Larissa Thaís de Farias
@since 08/04/2016
@return logic, indica se as etapas já estão gravados
/*/
//---------------------------------------------------------------------
Static Function fEqualSteps(cOrdem, cPlano)

	Local nI := 1
	Local aAnswers := {}
	Local lChanged := .F.
	Local cTarefa  := ""
	Local cEtapa   := ""
	Local cSeqTare := ""
	Local cCodFun  := ""
	Local nScan    := 0

	//verifica se houve alteração nas etapas
	For nI := 1 to Len(aEtapas)

		cTarefa  := aEtapas[nI][1]
		cEtapa   := aEtapas[nI][2]
		cSeqTare := aEtapas[nI][3]
		cCodFun  := aEtapas[nI][5]
		cOk      := aEtapas[nI][6]
		aAnswers := aEtapas[nI][7]

		dbSelectArea("STQ")
		dbSetOrder(1)
		If dbSeek( xFilial("STQ") + cOrdem + cPlano + cTarefa + cEtapa )
			//verifica se houve alterações nas respostas
			If fModifEtapa(cOrdem,cPlano,cTarefa,cEtapa,cOk,aAnswers)
				lChanged := .T.
				Exit
			EndIf
		Else
			lChanged := .T.
			Exit
		EndIf
	Next nI

	//O trecho abaixo verifica se alguma etapa foi excluída pelo app e precisa ser excluído na base
	If !lChanged

		dbSelectArea("STQ")
		dbSetOrder(1)
		If dbSeek(xFilial("STQ")+ cOrdem + cPlano)
			While !Eof() .And.  cOrdem + cPlano == STQ->TQ_ORDEM + STQ->TQ_PLANO

				If lChanged
					Exit
				EndIf

				If (nScan := aScan(aEtapas,{|x| x[1] == STQ->TQ_TAREFA .And. x[2] == STQ->TQ_ETAPA })) == 0
					lChanged := .T.
					Exit

				EndIf
				dbSelectArea("STQ")
				dbSkip()
			EndDo
		EndIf
	EndIf

Return !lChanged

//---------------------------------------------------------------------
/*/{Protheus.doc} verifyInput
Verifica se possui pelo menos um insumo realizado

@param cCode, string, código da ordem de serviço
@param cPlan, string, plano da ordem de serviço
@author Maria Elisandra de Paula
@since 23/05/2016
@return logic, se há pelo menos um insumo realizado
/*/
//---------------------------------------------------------------------
Static Function verifyInput(cCode, cPlan)

	/*
	Obs.: não utilizamos consultas por query pois ao conectar o banco ainda não estarão gravadas/liberadas
	as tabelas necessárias para validação (devido ao beginTransaction)
	*/
	dbSelectArea("STL")
	dbSetOrder(1)
	dbSeek(xFilial("STL")+cCode+cPlan)
	While !Eof() .And. STL->TL_FILIAL == xFilial("STL") .And. STL->TL_ORDEM == cCode .And. STL->TL_PLANO == cPlan

		If Val(STL->TL_SEQRELA) > 0
			Return .T.
		EndIf

		dbSkip()
	EndDo

Return .F.

//---------------------------------------------------------------------
/*/{Protheus.doc} MakeFilter
Gera, parcialmente, uma query que localiza ou rejeita os itens baseados em
sua chave primária

@author	Larissa Thaís de Farias
@author Marcelo Camargo
@since 02/06/2016
@param aArray, array, valores vindos do portal
@param cField, string, campo no qual será aplicado o filtro
@param lNotIn, boolean, se permite concatenar "NOT" na string
@return string, utilizada em condições where
/*/
//---------------------------------------------------------------------
Static Function MakeFilter( aArray, cField , lNotIn)
	Local cQuery := ""
	Local nI
	Default lNotIn := .t.

	If Len( aArray ) > 1
		cQuery += " AND " + cField + " "

		If aArray[ 1 ] == "reject" .And. lNotIn
			cQuery += "NOT "
		EndIf
		cQuery += "IN ("

		For nI := 2 To Len( aArray )
			If nI > 2
				cQuery += ','
			EndIf

			cQuery += "'" + aArray[ nI ] + "'"
		Next nI
		cQuery += ") "
	EndIf

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} playStop
Aponta um insumo como realizado e grava a hora ínicio e fim de um insumo

@author Larissa Thaís de Farias
@param cBody, string, objeto com o JSON que contém os dados para o play e stop
@since 06/06/2016
@return array, [1] sucesso da operação, [2] json para retorno
/*/
//---------------------------------------------------------------------
Function playStop(cBody)

	Local oParser
	Local cError := ""
	Local cOrder
	Local cPlan
	Local cJson
	Local lRet := .T.
	Local dMvUlmes := SuperGetMv("MV_ULMES",.F.,Stod(""))
	Local cUsaIntEs := SuperGetMv("MV_NGMNTES",.F.,"N")

	printf('Inicio de reporte via PlayStop')

	If FWJsonDeserialize(cBody,@oParser)

		cOrder  := oParser:order
		cPlan	:= oParser:plan
		oParser := oParser:json

		DbSelectArea("STJ")
		dbSetOrder(1)

		If dbSeek(xFilial('STJ')+cOrder+cPlan) .and. STJ->TJ_TERMINO == 'N' .and. STJ->TJ_SITUACA == 'L'

			//---------------------------------------------------------------------------
			// Trecho abaixo abre as tabelas para tratar msg "AJUSTAR PARAMETRO MV_DOCSEQ"
			//---------------------------------------------------------------------------

			If Select('SD1') <= 0
				dbSelectArea('SD1')
			EndIf
			If Select('SD2') <= 0
				dbSelectArea('SD2')
			EndIf
			If Select('SD3') <= 0
				dbSelectArea('SD3')
			EndIf

			cError := getInputs( oParser, , , , , .T. )

            If Empty(cError)

				// Valida se há conflito de horários nos insumos de mão de obra
                If aInputs[_REALIZED_,_INSERT_,1,_TYPE_] == 'M' .And. !NGVALDATIN( aInputs[_REALIZED_,_INSERT_,1,_CODE_], cOrder, cPlan,;
					aInputs[_REALIZED_,_INSERT_,1,_STARTDATE_], aInputs[_REALIZED_,_INSERT_,1,_STARTHOUR_], aInputs[_REALIZED_,_INSERT_,1,_ENDDATE_],;
					aInputs[_REALIZED_,_INSERT_,1,_ENDHOUR_], aInputs[_REALIZED_,_INSERT_,1,_TYPE_], , 'STL', , )[1]

                    // Conflito de horários no insumo de mão de obra do funcionário: # entre o período de # até
					Return { .F., STR0031 + ' ' + NGSeek( 'ST1', aInputs[_REALIZED_,_INSERT_,1,_CODE_], 1, 'T1_NOME' ) + ' ' + STR0032 + ' ' +;
						dToC( aInputs[_REALIZED_,_INSERT_,1,_STARTDATE_] ) + ' ' + aInputs[_REALIZED_,_INSERT_,1,_STARTHOUR_] + ' ' + STR0033 + ' ' +;
						dToC( aInputs[_REALIZED_,_INSERT_,1,_ENDDATE_] )   + ' ' + aInputs[_REALIZED_,_INSERT_,1,_ENDHOUR_]   + '.' }

                EndIf

				//Valida data de fechamento de estoque
				If aInputs[_REALIZED_,_INSERT_,1,_TYPE_] == 'M' .And. cUsaIntEs == 'S' .And. aInputs[_REALIZED_,_INSERT_,1,_STARTDATE_] <= dMvUlmes

					// A data não pode ser menor ou igual a data do último fechamento do estoque
					Return { .F., STR0084 + ' ' + dToC( dMvUlmes ) }

				EndIf

				printf( ' - Inclusao de insumo realizado via PlayStop ' + Trim( aInputs[_REALIZED_,_INSERT_,1,_TASK_] ) + '/' +;
					Trim( aInputs[_REALIZED_,_INSERT_,1,_CODE_] ) + ' ( ' + cValtochar( aInputs[_REALIZED_,_INSERT_,1,_AMOUNT_] ) + ' )' )

                NGRETINS(	cOrder				  						,;
                		  	cPlan 				  						,;
                		 	oParser[1]:type		  						,;
							      				  						,;
                    			  				  						,;
                    			  				  						,;
                    		aInputs[_REALIZED_,_INSERT_,1,_TASK_]     	,;
                    		aInputs[_REALIZED_,_INSERT_,1,_TYPE_]     	,;
                    		aInputs[_REALIZED_,_INSERT_,1,_CODE_]     	,;
                    		aInputs[_REALIZED_,_INSERT_,1,_AMOUNT_]   	,;
                    		aInputs[_REALIZED_,_INSERT_,1,_UNITY_]    	,;
                    		aInputs[_REALIZED_,_INSERT_,1,_DESTINY_]  	,;
                    		'Insumo Realizado.'   						,;
                    		aInputs[_REALIZED_,_INSERT_,1,_STARTDATE_]	,;
                    		aInputs[_REALIZED_,_INSERT_,1,_STARTHOUR_]	,;
                    		"F"                   						,;
                    		aInputs[_REALIZED_,_INSERT_,1,_WAREHOUSE_]	,;
                    							  						,;
                    							  						,;
                    							  						,;
                    							  						,;
                    		aInputs[_REALIZED_,_INSERT_,1,_PERCENT_]  	,;
                    		aInputs[_REALIZED_,_INSERT_,1,_USECALE_]  	,;
                    		"N"     			  						,;
                    							  						,;
                    							  						,;
                    							 						,;
                    							  						,;
                    		.T.					  						,;
                    		cError				   						;
                    	)
            EndIf

		Else
			cError := STR0035 // "Insumo não enviado."
		EndIf
	Else
		cError := STR0022 // "Json inválido."
	EndIf

	If Empty(cError)
		cJson := JSONResult(  )
	Else
		cJson := cError
		lRet := .F.
	EndIf

	printf('Final de reporte via PlayStop.')

return { lRet, cJson }

//---------------------------------------------------------------------
/*/{Protheus.doc} validCounter
Valida contador

@author Larissa Thaís de Farias
@since 06/06/2016
@param cEquipment, string, código do Bem
@param nCounter, numérico, leitura do contador
@param dDate, data, data da leitura
@param cHour, string, hora da Leitura
@param nTipoC, numérico, tipo do contador (Primeiro ou Segundo)
@return string, vazio ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function ValidCounter(cEquipment, nCounter, dDate, cHour , nTipoC)

	Local aVerifica
	Local aValida := {}

	Default dDate := dDataBase
	Default cHour := SubStr( Time(), 1, 5 )
	Default nTipoC:= 1

	If nTipoC == 1
		aValida:= {"ST9","STP","STP->TP_ACUMCON"}
	Else
		aValida:= {"TPE","TPP","TPP->TPP_ACUMCO"}
	EndIf

	If !Positivo(nCounter) .Or. nCounter == 0
		Return STR0036 // "Contador vazio ou não possui um valor positivo."
	End

	// Valida data e/ou hora posterior
	If ( DToS( dDate ) + cHour ) > ( DToS( Date() ) + SubStr( Time(), 1, 5 ) )

		// A hora de leitura do contador 1: XX:XX não deve ser maior que a hora atual do sistema: XX:XX
		Return STR0041 + Trim( cValToChar( nTipoC ) ) + ': ' + cHour + STR0176 + SubStr( Time(), 1, 5 )

	EndIf

	aVerifica := NGCHKHISTO( cEquipment, dDate, nCounter, cHour, nTipoC, , .F., , , .F. )

	If !aVerifica[1]
		Return STR0037+" "+aVerifica[2] //"Problemas com o histórico do contador: "
	EndIf

	If !CHKPOSLIM(cEquipment,nCounter,nTipoC)
		Return STR0038 // "Contador excede o seu limite. Favor verificar troca de contador."
	End

	//Obs.: A validação de variação dia não é necessária pois no padrão existe um MsgYesNo, deixando que o usuário prossiga com a operação

Return ""

//---------------------------------------------------------------------
/*/{Protheus.doc} MntWSError
Faz tratamento de erro.log

@param Self, objeto, objeto de ws
@param, oError, objeto, objeto errorblock
@param, cUser, string, email do usuário
@param, oContent, objeto, conteúdo do ws
@author Larissa Thaís de Farias
@since 04/04/2016
@return nil
/*/
//---------------------------------------------------------------------
Function MntWSError( Self, oError, cUser, oContent )

	conout('','')
	printf('Inicio de tratamento de erro-----------------------')
	printf('O seguinte erro ocorreu: ' + oError:Description)
	printf('------------------------------------------------------------------')
	conout('','')
	printf('Stack: ' + oError:ErrorStack)
	printf('Fim do tratamento de erro-----------------------')
	conout('','')

	SetRestFault(500, EncodeUtf8( STR0128 + ": " + oError:Description) ) //"O seguinte erro ocorreu"

	DisarmTransaction()

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} JSONResult
Formato do JSON para sucesso

@author	Marcelo Camargo
@since	 14/03/2016
@version P12
@return	string
/*/
//---------------------------------------------------------------------
Static Function JSONResult( cResult )
Return '{ "hasError": false, "hasStack": false' + If(!Empty(cResult),',"data": ' + cResult,'') + ' }'

//---------------------------------------------------------------------
/*/{Protheus.doc} fRetError
String no formato JSON para erro

@author	Maria Elisandra de Paula
@since 14/06/2022
@param cResult, string, descrição do erro
@param oSelf, objeto, instância do ws
@return	boolean, sempre verdadeiro
@obs retorna verdadeiro para neste caso possa ser tratado no aplicativo
/*/
//---------------------------------------------------------------------
Static Function fRetError(cResult,oSelf)
	oSelf:SetResponse('{ "hasError": true, "message":"' + EncodeUtf8( cResult ) + ' "}')
	Printf(cResult)
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fInsBase
Retorna string para query com insumos criados/alterados não deletados da ordem+plano

@param cOrdem, string, ordem de Serviço
@param cPlano, string, plano da ordem de serviço

@author	Maria Elisandra de Paula
@since 08/03/2017
@version P12
@return	string, query para buscar insumos
/*/
//---------------------------------------------------------------------
Static Function fInsBase( cOrdem, cPlano )

	Local cQuery:= " SELECT "

	cQuery += " 	TL_TAREFA, "
	cQuery += " 	TL_TIPOREG,"
	cQuery += " 	TL_TIPOHOR,"
	cQuery += " 	TL_CODIGO, "
	cQuery += " 	TL_SEQRELA,"
	cQuery += " 	TL_SEQTARE,"
	cQuery += " 	TL_QUANTID,"
	cQuery += " 	TL_QUANREC,"
	cQuery += " 	TL_OBSERVA,"
	cQuery += " 	TL_UNIDADE,"
	cQuery += " 	TL_DTINICI,"
	cQuery += " 	TL_HOINICI,"
	cQuery += " 	TL_DTFIM,  "
	cQuery += " 	TL_PERMDOE,"
	cQuery += " 	TL_HOFIM,  "
	cQuery += " 	TL_LOCAL,  "
	cQuery += " 	TL_LOCALIZ,"
	cQuery += " 	TL_NUMSERI,"
	cQuery += " 	TL_LOTECTL,"
	cQuery += " 	TL_NUMLOTE,"
	cQuery += "		TL_NUMSA, TL_ITEMSA,"
	cQuery += " 	TL_DESTINO,"
	cQuery += " 	TL_CUSTO, TL_USACALE, TL_FORNEC, TL_LOJA, TL_DTVALID"

	cQuery += " FROM " + RetSqlName("STL") + " STL "
	cQuery += " WHERE TL_FILIAL = "  + ValtoSql(xFilial("STL"))
	cQuery += " 	AND TL_ORDEM = " + ValtoSql(cOrdem)
	cQuery += " 	AND TL_PLANO = " + ValtoSql(cPlano)
	cQuery += "     AND D_E_L_E_T_ = ' ' "

Return cQuery

//-----------------------------------------------------------------------------
/*/{Protheus.doc} fValidIns
Valida insumos

@author	Maria Elisandra de Paula
@param cOrdem, string, ordem de Serviço
@param cPlano, string, plano da ordem de serviço
@param nOpc, numérico, operação: 3=inclui O.S, 4=altera O.S, 5=cancela O.S
@since 14/03/2017
@return	string, vazia ou com descrição do erro
/*/
//-----------------------------------------------------------------------------
Static Function fValidIns( cOrdem, cPlano , nOpc )

	Local cReturn  := ""
	Local aInsBase := {}
	Local nPosArr  := 0
	Local cAliasQry:= ""
	Local cQuery   := ""
	Local nY       := 0
	Local nOpcX    := 0
	Local nInput   := 0
	Local nI       := 0
	Local cOP      := ""
	Local lTemCotac:= .F.
	Local nQtdComp := 0
	Local aInsAPP  := {}
	Local aInsRastro:= {}
	Local aInsLocal := {}
	Local aInpRea   := {}
	Local aBaseRas:= {}
	Local aBaseLocal:= {}
	Local cUsaIntEs := SuperGetMv("MV_NGMNTES",.F.,"N")
	Local cInicio
	Local cFim
	Local dMvUlmes := SuperGetMv("MV_ULMES",.F.,Stod(""))
	Local nRegLog := 0

	Private aHEADER := {}

	For nOpcX := 1 To 6

		If nOpcX == 1
			aInputTemp := aClone( aInputs[_REALIZED_,_UPDATE_] ) // update realizados
		ElseIf nOpcX == 2
			aInputTemp := aClone( aInputs[_FORESEEN_,_UPDATE_] ) // update previstos
		ElseIf nOpcX == 3
			aInputTemp := aClone( aInputs[_REALIZED_,_INSERT_] ) // insert realizados
		ElseIf nOpcX == 4
			aInputTemp := aClone( aInputs[_FORESEEN_,_INSERT_] ) // insert previstos
		ElseIf nOpcX == 5
			aInputTemp := aClone( aInputs[_REALIZED_,_DELETE_] ) // delete realizados
		ElseIf nOpcX == 6
			aInputTemp := aClone( aInputs[_FORESEEN_,_DELETE_] ) // delete previstos
		EndIf

		For nInput := 1 to Len( aInputTemp )

			If nOpcX < 5 .And. aInputTemp[nInput,_TYPE_] == 'P' .And. Empty( aInputTemp[nInput,_WAREHOUSE_] )
				Return cOrdem + CRLF + STR0129 + ': ' + AllTrim( aInputTemp[nInput,_CODE_] ) // O almoxarifado é obrigatório. Produto
			EndIf

			If cUsaIntEs == 'S' .And. aInputTemp[nInput,_TYPE_] $ 'P/M' .And. aInputTemp[nInput,_STARTDATE_] <= dMvUlmes
				If nOpcX <= 4
					Return cOrdem + CRLF + STR0086 + ' ' + Dtoc( dMvUlmes ) //"Os insumos não podem ter a data menor ou igual a data do último fechamento do estoque"
				Else
					Return cOrdem + CRLF + STR0177 + ' ' + Dtoc( dMvUlmes ) // "Não é permitido excluir o insumo com data menor ou igual a data do último fechamento do estoque"
				EndIf
			EndIf

		Next nInput

	Next nOpcX

	If nOpc == 4 .Or. nOpc == 5 // Alteração ou cancelamento

		cOP       := AllTrim(cOrdem) + "OS001"
		cQuery    := ChangeQuery( fInsBase(cOrdem, cPlano) )
		cAliasQry := GetNextAlias()

		dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasQry,.F.,.T.)

		dbSelectArea(cAliasQry)
		While !(cAliasQry)->(Eof())

			If nOpc == 5 .And. Val((cAliasQry)->TL_SEQRELA) > 0
				cReturn:=  " " + STR0042 // "Cancelamento não permitido, esta ordem de serviço já tem insumos reportados."
				Exit
			EndIf

			//aInsBase:insumos PREVISTOS (produtos/terceiros) - BASE
			If (cAliasQry)->TL_TIPOREG $ "P/T"
				If (nPosArr := aScan(aInsBase, {|x| x[1] + x[2] == (cAliasQry)->TL_CODIGO + (cAliasQry)->TL_LOCAL})) == 0
		    		aAdd(aInsBase, {(cAliasQry)->TL_CODIGO, (cAliasQry)->TL_LOCAL, 0 ,0 } )
		    		nPosArr := Len( aInsBase )
		    	EndIf
				aInsBase[nPosArr][3] += (cAliasQry)->TL_QUANTID

				nQtdComp := NGBUSC1COM( cOP, (cAliasQry)->TL_CODIGO, (cAliasQry)->TL_LOCAL, '' )
				aInsBase[nPosArr][4] := nQtdComp

				If nQtdComp > 0
					lTemCotac := .T.

					If nOpc == 5
						//Aqui já foi verificado que um item da base possui cotação
						cReturn := STR0043 // "Não é permitido cancelar a ordem de serviço, pois há solicitações de cotação em aberto para o item '"
						cReturn += Alltrim((cAliasQry)->TL_CODIGO) + STR0044 // "' . Verifique se as cotações para esta ordem de serviço foram liberadas. Se não libere-as."
						Exit
					EndIf

				EndIf
			EndIf

			If nOpc == 4

				//aBaseRas :insumos REALIZADOS para validação de Rastro - BASE
				If (cAliasQry)->TL_TIPOREG $ "P" .And. Val((cAliasQry)->TL_SEQRELA) > 0
					If (nPosArr :=  aScan(aBaseRas, {|x| x[1] + x[2] + x[3] + x[4] == ;
									(cAliasQry)->TL_CODIGO 	+ ;
									(cAliasQry)->TL_LOCAL 	+ ;
									(cAliasQry)->TL_LOTECTL + ;
									(cAliasQry)->TL_NUMLOTE })) == 0

			    		aAdd(aBaseRas, {(cAliasQry)->TL_CODIGO,(cAliasQry)->TL_LOCAL,(cAliasQry)->TL_LOTECTL ,(cAliasQry)->TL_NUMLOTE , 0 } )
			    		nPosArr := Len( aBaseRas )
			    	EndIf
					aBaseRas[nPosArr][5] += (cAliasQry)->TL_QUANTID
				EndIf

				//aBaseLocal :insumos REALIZADOS para validação de Localização - BASE
				If (cAliasQry)->TL_TIPOREG $ "P" .And. Val((cAliasQry)->TL_SEQRELA) > 0
					If (nPosArr :=  aScan(aBaseLocal, {|x| x[1] + x[2] + x[3] + x[4] + x[5] + x[6] == ;
									(cAliasQry)->TL_CODIGO 	+ ;
									(cAliasQry)->TL_LOCAL 	+ ;
									(cAliasQry)->TL_LOTECTL + ;
									(cAliasQry)->TL_NUMLOTE + ;
									(cAliasQry)->TL_LOCALIZ + ;
									(cAliasQry)->TL_NUMSERI  })) == 0

			    		aAdd(aBaseLocal, ;
			    				{(cAliasQry)->TL_CODIGO	,;
			    				(cAliasQry)->TL_LOCAL	,;
			    				(cAliasQry)->TL_LOTECTL ,;
			    				(cAliasQry)->TL_NUMLOTE	,;
			    				(cAliasQry)->TL_LOCALIZ ,;
			    				(cAliasQry)->TL_NUMSERI ,0 } )

			    		nPosArr := Len( aBaseLocal )
			    	EndIf
					aBaseLocal[nPosArr][7] += (cAliasQry)->TL_QUANTID
				EndIf
			EndIf

			(cAliasQry)->(dbSkip())
		EndDo

		(cAliasQry)->(dbCloseArea())

		//Neste bloco valida se algum item já tem cotação para não permitir alterar a quantidade para menos
		If Empty( cReturn ) .And. nOpc != 5

			If lTemCotac

				For nInput := 1 To Len( aInputs[_FORESEEN_,_UPDATE_] )

					// aInsAPP: Insumos PREVISTOS vindos do APP ( Produtos/Terceiros ).
					If aInputs[_FORESEEN_,_UPDATE_,nInput,_TYPE_] $ 'P/T'

						If ( nPosArr := aScan( aInsAPP, { |x| x[1] + x[2] == aInputs[_FORESEEN_,_UPDATE_,nInput,_KEYCODE_] +;
							aInputs[_FORESEEN_,_UPDATE_,nInput,_WAREHOUSE_] } ) ) == 0

				    		aAdd( aInsAPP, { aInputs[_FORESEEN_,_UPDATE_,nInput,_KEYCODE_], aInputs[_FORESEEN_,_UPDATE_,nInput,_WAREHOUSE_], 0 } )
				    		nPosArr := Len( aInsAPP )

				    	EndIf

						aInsAPP[nPosArr,3] += aInputs[_FORESEEN_,_UPDATE_,nInput,_AMOUNT_]

					EndIf

				Next nInput

				// Valida quantidade de insumos da base com cotados caso tenha cotação de compras
				For nInput := 1 To Len( aInsBase )

					If aInsBase[nInput,4] > 0

						// Identifica que um item da base possui cotação e está sendo modificado
						If ( nPosArr := aScan( aInsAPP, { |x| x[1] + x[2] == aInsBase[nInput,1] + aInsBase[nInput,2] } ) ) > 0 .And.;
							aInsAPP[nPosArr,3] < aInsBase[nInput,4]

							cReturn := STR0045 // Não é permitido modificar/excluir a ordem de serviço, pois há solicitações de cotação em aberto para o item
							cReturn += aInsBase[nInput,1] + STR0046 // Verifique se as cotações para esta ordem de serviço foram liberadas. Se não libere-as.
							Exit

						EndIf

					EndIf

				Next nInput

			EndIf

		EndIf

	EndIf

	// Neste bloco carrega vetores de itens e os valida caso tenha rastro e localização
	If Empty( cReturn ) .And. nOpc != 5

		// Verifica insumos das operações INSERT e UPDATE
		For nOpcX := 1 To 2

			aInpRea := aClone( aInputs[_REALIZED_,nOpcX] )

			// Carrega vetores de insumos realizados para validações
			If !Empty( aInpRea ) .And. cUsaIntEs == 'S'

				For nY := 1 To Len( aInpRea )

					If aInpRea[nY,_TYPE_] == 'P'

						/*
							aInsRastro: insumos REALIZADOS do mobile com soma dos repetidos para Rastro.
							{ TL_CODIGO, TL_LOCAL, TL_LOTECTL, TL_NUMLOTE, Total }
						*/
						If ( nPosArr := aScan( aInsRastro, { |x| x[1] + x[2] + x[3]+ x[4] ==;
								aInpRea[nY,_CODE_] + aInpRea[nY,_WAREHOUSE_] + aInpRea[nY,_LOT_]+ aInpRea[nY,_SUBLOT_] } ) ) == 0

							aAdd( aInsRastro, { aInpRea[nY,_CODE_], aInpRea[nY,_WAREHOUSE_], aInpRea[nY,_LOT_],;
								aInpRea[nY,_SUBLOT_], 0 } )
							nPosArr := Len( aInsRastro )

						EndIf

						aInsRastro[nPosArr,5] += aInpRea[nY,_AMOUNT_]

						/*
							aInsLocal: insumos REALIZADOS do mobile com soma dos repetidos para Localização.
							{ TL_CODIGO, TL_LOCAL, TL_LOTECTL, TL_NUMLOTE, TL_LOCALIZ, TL_NUMSERI, Total }
						*/
						If ( nPosArr := aScan( aInsLocal, { |x| x[1] + x[2] + x[3]+ x[4] + x[5]+ x[6] ==;
							aInpRea[nY,_CODE_] + aInpRea[nY,_WAREHOUSE_] + aInpRea[nY,_LOT_] + aInpRea[nY,_SUBLOT_] +;
							aInpRea[nY,_LOCATION_] + aInpRea[nY,_SERIALNUMBER_] } ) ) == 0

							aAdd( aInsLocal, { aInpRea[nY,_CODE_], aInpRea[nY,_WAREHOUSE_], aInpRea[nY,_LOT_],;
								aInpRea[nY,_SUBLOT_], aInpRea[nY,_LOCATION_], aInpRea[nY,_SERIALNUMBER_], 0 } )
							nPosArr := Len( aInsLocal )

						EndIf

						aInsLocal[nPosArr,7] += aInpRea[nY,_AMOUNT_]

					EndIf

				Next nY

				//Valida insumos produto realizados - Rastro e Localização
				cError := NG400VLD( aInsRastro, aInsLocal, aBaseRas, aBaseLocal, cOrdem )
				If !Empty(cError)
					Return cError
				EndIf
			EndIf

			/*
				verifica conflito de horários nos insumos realizados passados pelo APP ( com os insumos da ordem(app) e
				depois com os insumos da base )
			*/
			For nI := 1 To Len( aInpRea )

				If aInpRea[nI,_TYPE_] == 'M'

					cInicio := dToC( aInpRea[nI,_STARTDATE_] ) + aInpRea[nI,_STARTHOUR_]
					cFim    := dToC( aInpRea[nI,_ENDDATE_] )   + aInpRea[nI,_ENDHOUR_]
					nRegLog := 0

					If nOpcX == 1 // update de insumo

						dbSelectArea( 'STL' )
						dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA
						If dbSeek( xFilial( 'STL' ) + cOrdem + cPlano + aInpRea[nI,_KEYTASK_] + aInpRea[nI,_TYPE_] + aInpRea[nI,_KEYCODE_] + aInpRea[nI,_SEQUENCE_] )

							nRegLog := STL->( Recno() )

						EndIf

					EndIf

					// aScanX: busca conflitos dentro da própria ordem sem validar com o insumo que está sendo passado ( y <> nI )
					If ( aScanX( aInpRea , { |x,y| 	x[_TYPE_] == 'M'                .And.; // MDO
													x[_CODE_] == aInpRea[nI,_CODE_] .And.; // Código
							( ( cInicio > dToC( x[_STARTDATE_] ) + x[_STARTHOUR_]   .And.;
								cInicio < dToC( x[_ENDDATE_] )   + x[_ENDHOUR_] )    .Or.; // cInicio: 07:30 - X 07:00 - 08:00
							  ( cFim > dToC( x[_STARTDATE_] )    + x[_STARTHOUR_]   .And.;
								cFim < dToC( x[_ENDDATE_] )      + x[_ENDHOUR_] )    .Or.; // cFim: 09:30 - X 09:00 - 10:00
							  ( dToC( x[_STARTDATE_] ) + x[_STARTHOUR_] > cInicio   .And.;
								dToC( x[_STARTDATE_] ) + x[_STARTHOUR_] < cFim  )    .Or.; // X INICIO: 08:00 - cInicio:07:30 cFim: 08:30
							  ( dToC( x[_ENDDATE_] )   + x[_ENDHOUR_]   > cInicio   .And.;
								dToC( x[_ENDDATE_] )   + x[_ENDHOUR_]   < cFim )     .Or.; // X FIM: 09:00 - cInicio:08:30 cFim:09:30
							  ( cInicio == dToC( x[_STARTDATE_] ) + x[_STARTHOUR_] ) .Or.; // Hora inicio iguais
							  ( cFim == dToC( x[_ENDDATE_] ) + x[_ENDHOUR_] ) )     .And.; // Hora fim iguais
								y + nI } ) > 0 );  // Não validar com ele mesmo
						.Or. ( !NGVALDATIN( aInpRea[nI,_CODE_],;
							cOrdem,;
							cPlano,;
							aInpRea[nI,_STARTDATE_],;
							aInpRea[nI,_STARTHOUR_],;
							aInpRea[nI,_ENDDATE_],;
							aInpRea[nI,_ENDHOUR_],;
							aInpRea[nI,_TYPE_],;
							IIf( nRegLog > 0, nRegLog,Nil ),;
							'STL' )[1] )

						// "Conflito de horários no insumo de mão de obra do funcionário#"entre o período:" #"até"
						Return 	STR0031 + ' ' + Trim( NGSEEK( 'ST1', aInpRea[nI,_CODE_], 1, 'T1_NOME' ) )        + ' ' +;
								STR0032 + ' ' + dToC( aInpRea[nI,_STARTDATE_] )  + ' ' + aInpRea[nI,_STARTHOUR_] + ' ' +;
								STR0033 + ' ' + dToC( aInpRea[nI,_ENDDATE_] )    + ' ' + aInpRea[nI,_ENDHOUR_]   + '.'

					EndIf

				EndIf

			Next nI

		Next nOpcX

	EndIf

Return cReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} NG400VLD - Validações do MNTA400
Validação de insumos realizados
	aInsRastro[1]-TL_CODIGO
	aInsRastro[2]-TL_LOCAL
	aInsRastro[3]-TL_LOTECTL
	aInsRastro[4]-TL_NUMLOTE
	aInsRastro[5]-TL_QUANTID

	aInsLocal[1]-TL_CODIGO
	aInsLocal[2]-TL_LOCAL
	aInsLocal[3]-TL_LOTECTL
	aInsLocal[4]-TL_NUMLOTE
	aInsLocal[5]-TL_LOCALIZ
	aInsLocal[6]-TL_NUMSERI
	aInsLocal[7]-TL_QUANTID

@author	Maria Elisandra de Paula
@since 21/03/2017
@version P12
@return	string, vazia ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function NG400VLD( aInsRastro, aInsLocal, aBaseRas, aBaseLocal, cOrdem )

	Local nQtdDe    := 0
	Local cReturn   := ""
	Local nY        := 0
	Local nSaldoLote:= 0
	Local lEstNega  := AllTrim(GetMv("MV_ESTNEG")) == "S"
	Local nSaldoSBF := 0

	If Len(aInsRastro) > 0
		For nY:= 1 to Len(aInsRastro)

			dbSelectArea("SB8")
			//Valida Rastro ---------------------------------------------------------------------
			If fRastro(aInsRastro[nY][1])
				//Busca no vetor aBaseRas (insumo-produto-realizado-base-rastro) e soma quantidade
				//nQtdDe: quantidade de produtos iguais já gravados na base
				If (nBusca := aScan(aBaseRas,{|x| x[1] + x[2]+ x[3]+ x[4] == aInsRastro[nY][1] + aInsRastro[nY][2] + aInsRastro[nY][3] + aInsRastro[nY][4] })) == 0
					nQtdDe := 0
				Else
					nQtdDe :=  aBaseRas[nBusca][5]
				EndIf

				dbSelectArea("SB8")
				If fRastro(aInsRastro[nY][1],"S")
					//Valida o sub-lote
					If Empty(aInsRastro[nY][4])
						Return STR0047  + CRLF + STR0048 + Alltrim(aInsRastro[nY][1]) + CRLF + STR0049 + Alltrim(aInsRastro[nY][2])// "Numero do sub-lote não informado."#"Produto: "#"local "
					Else
						dbSelectArea("SB8")
						dbSetOrder(02)
						If dbSeek(xFilial("SB8")+aInsRastro[nY][4]+aInsRastro[nY][3]+aInsRastro[nY][1]+aInsRastro[nY][2])

							nSaldoLote := SB8Saldo(.F.,!Empty(aInsRastro[nY][3]+aInsRastro[nY][4]),NIL,NIL,NIL,NIL,NIL,""/*M->TL_DTINICI*/)

		  					If QtdComp(nSaldoLote)+ nQtdDe < QtdComp(aInsRastro[nY][5])
		     					Return STR0050 + CRLF + STR0051 + Alltrim(aInsRastro[nY][1]) + CRLF + STR0049 + Alltrim(aInsRastro[nY][2]) + CRLF + STR0052 + Alltrim(aInsRastro[nY][3]) + CRLF + STR0053 + Alltrim(aInsRastro[nY][4])
		     					//"Saldo indisponível: "#"produto: "#"local " #"lote " #"sub-lote "
							EndIf
						Else
			            	Return STR0054 + CRLF + STR0048 + Alltrim(aInsRastro[nY][1]) + CRLF + STR0049 + Alltrim(aInsRastro[nY][2])
			            			//"Numero do sub-lote não corresponde ao produto que foi informado."#"Produto: " #"local "
						EndIf
					EndIf
				ElseIf fRastro( aInsRastro[nY][1] , "L" )
					//Valida somente lote
					If Empty(aInsRastro[nY][3])
						Return STR0055  + CRLF + STR0048 + Alltrim(aInsRastro[nY][1]) + CRLF + STR0049 + Alltrim(aInsRastro[nY][2])
								// "Numero do lote não informado."#"Produto: "#"local "
					Else
						dbSelectArea("SB8")
						dbSetOrder(03)
						If dbSeek(xFilial("SB8")+aInsRastro[nY][1]+aInsRastro[nY][2]+aInsRastro[nY][3])
							nSaldo:= SaldoLote(aInsRastro[nY][1],aInsRastro[nY][2],aInsRastro[nY][3],NIL,.F.,!Empty(aInsRastro[nY][3]+aInsRastro[nY][4]),NIL,dDatabase)
							If QtdComp(nSaldo)+ nQtdDe < QtdComp(aInsRastro[nY][5])
								Return STR0050  + CRLF + STR0048  + Alltrim(aInsRastro[nY][1]) + CRLF + STR0049 + Alltrim(aInsRastro[nY][2])+ CRLF + STR0052 + Alltrim(aInsRastro[nY][3])
										//"Saldo indisponível."#"produto: "#"local " #"lote "
			        		EndIf
						Else
							Return STR0056 + CRLF + STR0048 + Alltrim( aInsRastro[nY][1]) + CRLF + STR0049 + Alltrim(aInsRastro[nY][2])
									//"Numero do lote não corresponde ao produto informado."#"Produto: " #"local "
						EndIf
					EndIf
				EndIf
			EndIf
		Next nY
	EndIf

	If Len(aInsLocal) > 0
		For nY:= 1 to Len(aInsLocal)
			//nQtdDe: quantidade de produtos iguais já gravados na base
			If (nBusca := aScan(aBaseLocal,{|x| x[1] + x[2]+ x[3]+ x[4] + x[5] + x[6]== ;
					aInsLocal[nY][1] + aInsLocal[nY][2] + aInsLocal[nY][3] + aInsLocal[nY][4] + aInsLocal[nY][5]+ aInsLocal[nY][6]})) == 0
				nQtdDe := 0
			Else
				nQtdDe :=  aBaseLocal[nBusca][7]
			EndIf

			//Validacao do LOCALIZACAO--------------------------------------------
			//Verifica se ha problema na habilitacao do controle por enderecamento fisico
			If !Empty(aInsLocal[nY][5]) .Or. !Empty(aInsLocal[nY][6])
				If !FLocaliza( Padr( aInsLocal[nY][1], TAMSX3("B1_COD")[1] ) )
		        	Return STR0057 + aInsLocal[nY][1] + STR0058 // "O parâmetro 'MV_LOCALIZ' esta desativado ou o campo 'B1_LOCALIZ' do produto: " #" está preenchido com 'N'."
				EndIf
			EndIf

			If FLocaliza( Padr( aInsLocal[nY][1], TAMSX3("B1_COD")[1] ) )
				//Valida a obrigatoriedade de informar o enderecamento fisico se o produto tem o controle
				If Empty(aInsLocal[nY][5]) .And. Empty(aInsLocal[nY][6])
			       Return STR0059  + CRLF + STR0048  + aInsLocal[nY][1] + CRLF + STR0049 + aInsLocal[nY][2]
			       			//"Localização e numero de série não informados."#" Produto: "#"local "
				EndIf

				If !Empty( aInsLocal[nY,5] ) .And. !Empty( aInsLocal[nY,2] ) .And. !NGIFDBSEEK( 'SBE', aInsLocal[nY,2] +;
					aInsLocal[nY,5], 1, .F. )
					Return STR0061 // "Campo localização não existe."
				EndIf

				If !lEstNega .And. ( !Empty(aInsLocal[nY][5]) .Or. !Empty(aInsLocal[nY][6]) )
					nSaldoSBF := QtdComp(SaldoSBF(aInsLocal[nY][2],aInsLocal[nY][5],aInsLocal[nY][1],aInsLocal[nY][6],;
								aInsLocal[nY][3],aInsLocal[nY][4],.F.,,, cOrdem + 'OS001' ))

					If nSaldoSBF + nQtdDe < QtdComp( aInsLocal[nY][7] )
						Return STR0062 + CRLF + STR0048 + aInsLocal[nY][1] + CRLF + STR0049 + aInsLocal[nY][2]//"O endereço informado não possui saldo suficiente."#" Produto: "#"local "
					EndIf

				EndIf

			EndIf
		Next nY
	EndIf
Return cReturn
//---------------------------------------------------------------------
/*/{Protheus.doc} updCounter
Realiza a criação do contador

@author	Maria Elisandra de Paula
@since 14/02/2017
@param cJson - Objeto com o JSON que contém os dados do contador para inclusão
@return array, [1] se obteve sucesso da operação,[2] json
/*/
//---------------------------------------------------------------------
Static Function updCounter(cJson)

	Local oParser
	Local cError     := ""
	Local aCounter   := 0
	Local cEquipment := ""
	Local lRet := .T.
	Local aDtLeitura := {}
	Local nI := 0
	Local cGERAPREV  := AllTrim(GETMv("MV_NGGERPR"))
	Local nCounter   := 0

	If FWJsonDeserialize(cJson,@oParser)

		printf("Inicio Inclusão de contador: " + DTOC(dDataBase) + " " + Time())

		cEquipment:= Upper(Padr(oParser:equipment,16))
		aCounter  := oParser:counter

		//Valida contador
		For nI:= 1 to Len(aCounter)

			If aCounter[nI]:value > 0
				aDtLeitura   := StrTokArr(aCounter[nI]:datetime," ")
				cError := ValidCounter(cEquipment,aCounter[nI]:value,Stod(aDtLeitura[1]),aDtLeitura[2],nI)
				If !Empty(cError)
					Exit
				EndIf
			EndIf
		Next nI

		//Aplica contador
		If Empty(cError)
			For nI:= 1 to Len(aCounter)
				If aCounter[nI]:value > 0
					aDtLeitura := StrTokArr(aCounter[nI]:datetime," ")
					NGTRETCON(cEquipment,Stod(aDtLeitura[1]),aCounter[nI]:value,aDtLeitura[2],nI)

					printf("Contador criado. Leitura: " + aDtLeitura[1] + " " + aDtLeitura[2] )
					nCounter:= aCounter[nI]:value
				EndIf
			Next nI
			//GERAR O.S AUTOMATICA POR CONTADOR
			If ( cGERAPREV == "S" .Or. cGERAPREV == "C" )
				NGGEROSAUT(cEquipment,nCounter,xFilial("STJ"))
			EndIf
		Else
			Return {.F.,cError}
		EndIf

	Else
		cError := STR0022 // "Json inválido."
	EndIf

	If Empty(cError)
		cJson := JSONResult(  )
	Else
		cJson := cError
		lRet := .F.
	EndIf

Return { lRet, EncodeUtf8(cJson) }
//---------------------------------------------------------------------
/*/{Protheus.doc} fRastro
Verifica se produto utiliza Rastro - lote e/ou sublote

@author	Maria Elisandra de Paula
@since 02/05/2017
@param cProduto - produto a pesquisar
@param cTipo - "L" - lote ou "S"-Sublote
@return logic, se possui controle de rastro
/*/
//---------------------------------------------------------------------
Static Function fRastro( cProduto, cTipo )

	Local lUsaLote := SuperGetMV("MV_RASTRO",.F.,'N') == "S"
	Local lLote    := .f.
	Default cTipo := ""

	If lUsaLote
		dbSelectArea("SB1")
		dbSetOrder(1)
		If dbSeek(xFilial("SB1") +  cProduto )
			lLote := If( Empty(cTipo),(SB1->B1_RASTRO $ "SL" ),(SB1->B1_RASTRO $ cTipo) )
		EndIf
	EndIf

Return lLote
//---------------------------------------------------------------------
/*/{Protheus.doc} fLocaliza
Verifica se produto utiliza LOCALIZAÇÃO - SERIE

@author	Maria Elisandra de Paula
@since 02/05/2017
@param cProduto - produto a pesquisar
@return logic, se possui controle de localização
/*/
//---------------------------------------------------------------------
Static Function fLocaliza( cProduto )

	Local lUsaLocal := SuperGetMV("MV_LOCALIZ") == "S"
	Local lLocaliza := .f.

	If lUsaLocal
		dbSelectArea("SB1")
		dbSetOrder(1)
		If dbSeek(xFilial("SB1") +  cProduto )
			lLocaliza := SB1->B1_LOCALIZ == "S"
		EndIf
	EndIf

Return lLocaliza

//---------------------------------------------------------------------
/*/{Protheus.doc} printf
Função para apresentar ou não mensagens no server, utilizado geralmente
para testes de desenvolvimento

@author	Vitor Emanuel Batista
@since 06/07/2017
@return string, log com data e hora
/*/
//---------------------------------------------------------------------
Static Function printf(cLog)
Return conout("["+time()+" - "+cValToChar(ThreadId())+"] " + cLog)

//---------------------------------------------------------------------
/*/{Protheus.doc} CounterFinish
Validações de contador na finalização
@type function

@author	Maria Elisandra de Paula
@since 19/07/2017

@param cDadCode  , string , Código do bem pai para reporte de contador.
@param nCounter1 , numeric, Valor do contador 1
@param cHour1    , string , Hora do contador 1
@param nCounter2 , numeric, Valor do contador 2
@param cHour2    , string , Hora do contador 2
@param dDtMRFim  , date   , Data real fim da os
@param oWS       , object , Instância do ws
@param lShowField, boolean, Define se o campo contador foi apresentado.

@return string, vazio ou descrição de erro
/*/
//---------------------------------------------------------------------
Static Function CounterFinish( cDadCode, nCounter1, cHour1, nCounter2, cHour2, dDtMRFim, oWS, lShowField )

	Local cError     := ''
    Local lHasCount1 := .F.
	Local lHasCount2 := .F.
	Local lVldPos    := .T.
    Local lVldPos2   := .T.
	Local aNGCONTRET := {}

	// Valida se informação que o bem encontra-se ou não na estrutura está atualizada na base do app.
	dbSelectArea( 'ST9' )
	dbSetOrder( 1 )
	If dbSeek( xFilial( 'ST9' ) + STJ->TJ_CODBEM ) .And. ST9->T9_TEMCONT $ 'P#I'

		If lShowField .And. ST9->T9_ESTRUTU == 'N'

			/*
				Este equipamento não encontra-se mais em uma estrutura, sendo assim não é permitido o reporte de contador. ###
				Para seguir com a finalização da O.S. deve-se ( cancelar ou reverter ) a finalização em andamento e realizar um sincronismo.
			*/
			cError := STR0164 + STR0166

		ElseIf !lShowField .And. ST9->T9_ESTRUTU == 'S'

			/*
				Este equipamento encontra-se em uma estrutura, sendo assim deve-se realizar o reporte de contador. ###
				Para seguir com a finalização da O.S. deve-se ( cancelar ou reverter ) a finalização em andamento e realizar um sincronismo.
			*/
			cError := STR0165 + STR0166

		EndIf

	EndIf

	// Somente executar este trecho se bem é controlado por algum tipo de contador.
	If Empty( cError ) .And. ( lHasCount1 := NGSEEK( 'ST9', cDadCode, 1, 'T9_TEMCONT' ) $ 'S#P#I' )

		// Verifica se bem possui segundo contador.
		lHasCount2 := MNTCont2( xFilial( 'TPE' ), cDadCode, .T. )

		If Val( STJ->TJ_PLANO ) > 0
			dbSelectArea("STF")
			dbSetOrder(1)
			dbSeek( xFilial("STF")  + STJ->TJ_CODBEM + STJ->TJ_SERVICO + STJ->TJ_SEQRELA)

			If STF->TF_TIPACOM $ "CAF" .And. ( nCounter1 == 0 .Or. Empty( cHour1 ) )
				Return STR0130 //"Para finalizar uma ordem de serviço preventiva controlada por contador, é obrigatório informá-lo."
			Else
				lVldPos := .F.
			EndIf

			If lHasCount2 .And. STF->TF_TIPACOM == "S" .And. ( nCounter2 == 0 .Or. Empty( cHour2 ) )
				Return STR0131 //"Para finalizar uma ordem de serviço preventiva controlada pelo segundo contador, é obrigatório informá-lo."
			Else
				lVldPos2 := .F.
			EndIf
		EndIf

		aNGCONTRET := NGCONTRET( dDtMRFim, nCounter1, cHour1, lHasCount1 .And. lVldPos,;
								 dDtMRFim , nCounter2, cHour2, lHasCount2 .And. lVldPos2, .F.)

		If !Empty( aNGCONTRET[2] )
			Return aNGCONTRET[2]
		EndIf

	    If Empty( cError )

			If nCounter1 > 0
				cError := ValidCounter( cDadCode, nCounter1, dDtMRFim, cHour1, 1 )
			EndIf

			If Empty( cError ) .And. lHasCount2 .And. nCounter2 > 0
				cError := ValidCounter( cDadCode, nCounter2, dDtMRFim, cHour2, 2 )
			EndIf

		EndIf

		If Empty( cError ) .And. lPeMntNg
			cError:= ExecBlock("MNTNG",.F.,.F.,{ "COUNTER_VALID_FINISH" , oWS })
		EndIf

	EndIf

Return cError
//---------------------------------------------------------------------
/*/{Protheus.doc} UpdDatesStj
Atualiza as datas previstas da ordem de serviço

@param cOrdem, string, OS a ser alterada
@param cPlano, string, plano da ordem
@param dDTMPINI, data, data prevista inicio inserida pelo usuário
@param cHOMPINI, string, hora prevista inicio inserida pelo usuário
@param dDTMPFIM, data, data prevista fim inserida pelo usuário
@param cHOMPFIM, string, hora prevista fim inserida pelo usuário
@author	Maria Elisandra de Paula
@since 07/08/2017
@return nil
/*/
//---------------------------------------------------------------------
Static Function UpdDatesStj( cOrdem, cPlano, dDTMPINI, cHOMPINI, dDTMPFIM, cHOMPFIM )

	Local dMIN
	Local cMin
	Local dMAX
	Local cMax

	//variáveis private utilizadas na função NGDTHORFINAL
	vVETRE := {}
	lPRIMD := .T.

	dbSelectArea("STL")
	dbSetOrder(1)
	If dbSeek( xFilial("STL") + cOrdem + cPlano )
		While !Eof() .And. STL->TL_FILIAL == xFilial("STL");
					 .And. STL->TL_ORDEM == cOrdem;
					 .And. STL->TL_PLANO == cPlano

			If Alltrim(STL->TL_SEQRELA) == "0"
				NGDTHORFINAL( STL->TL_DTINICI, STL->TL_HOINICI, STL->TL_DTFIM,;
								STL->TL_HOFIM, STL->TL_TIPOREG, STL->TL_SEQRELA, "P" )
			   dMIN := vVETRE[1]
			   cMin := vVETRE[2]
			   dMAX := vVETRE[3]
			   cMax := vVETRE[4]
			EndIf
			dbSelectArea("STL")
			dbSkip()
		EndDo
	EndIf

	dbSelectArea("STJ")
	dbSetOrder(1)
	If dbSeek(xFilial("STJ") + cOrdem + cPlano)
		RecLock( "STJ", .F. )
		STJ->TJ_DTMPINI := If( Empty( dMIN ), dDTMPINI, dMIN )
		STJ->TJ_HOMPINI := If( Empty( cMin ), cHOMPINI, cMin )
		STJ->TJ_DTMPFIM := If( Empty( dMAX ), dDTMPFIM, dMAX )
		STJ->TJ_HOMPFIM := If( Empty( cMax ), cHOMPFIM, cMax )
		MsUnLock()
	EndIf

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} fToJson
Retorna estrutura propriedade e valor para json

@param cPropri, string, propriedade do elemento
@param xValue, indefinido, valor do elemento
@param lEscape, boolean, indica se deve tratar as strings antes de concatenar
@param lUtf8, boolean, indica se deve converter as strings para a codificação utf-8

@author	Maria Elisandra de Paula
@since 07/08/2017
@return string, json
/*/
//---------------------------------------------------------------------
Static Function fToJson(cPropri,xValue,lEscape,lUtf8)

	Local xConteudo
	Local cRet:= ""

	Default lEscape := .T.
	Default lUtf8   := .F.

	cRet+= '"' + cPropri + '"' + ':'

	If Valtype(xValue) == "C"
		cRet+= '"'
		xConteudo := xValue
	ElseIf Valtype(xValue) == "N"
		xConteudo := cValtoChar(xValue)
		lEscape := .F.
	ElseIf Valtype(xValue) == "L"
		If xValue
			xConteudo := "true"
		Else
			xConteudo := "false"
		EndIf
		lEscape := .F.
	EndIf

	If lEscape
		cRet+= NGEscape(xConteudo,lUtf8)
	Else
		cRet+= xConteudo
	EndIf

	If Valtype(xValue) == "C"
		cRet += '"'
	EndIf

Return cRet
//---------------------------------------------------------------------
/*/{Protheus.doc} fToString
Retorna string de resposta de acordo com o tipo de opção da etapa

@author	Maria Elisandra de Paula
@since 07/08/2017
@param cEtapa, caracter, código da etapa
@param cOption, caracter, código da opção da etapa
@param xValue, indefined, valor de resposta
@return array, {se conversão ocorreu corretamente, conteúdo}
/*/
//---------------------------------------------------------------------
Static Function fToString(cEtapa, cOption, xValue)

	Local aRet := {.T., ""}
	Local cType:= ""

	dbSelectArea("TPA")
	dbSetOrder(1)
	If !dbseek(xFilial("TPA") + cEtapa)
		aRet := {.F., Alltrim(cEtapa) + Space(1) + STR0132 } // "o código da etapa não existe ou pertence à tabela TPA - Etapas Genéricas"
	ElseIf TPA->TPA_OPCOES == "0"
			aRet := {.F., STR0075 + ":" + Space(1) + Alltrim(cEtapa) + Space(1) + ; // "Etapa"
							STR0133 } // "tipo de opções '0',não deve ter respostas."
	ElseIf TPA->TPA_OPCOES $ "1/2"
		If NGIFDBSEEK("TPC", TPA->TPA_ETAPA + cOption, 1)

			If TPC->TPC_TIPRES == "1" //marcar
				If !Empty(xValue) .And. ValType(xValue) <> "L"
					Return {.F., STR0075 + ":" + Space(1) + Alltrim(cEtapa) + Space(1) +; //"Etapa"
								 STR0076 + ":" + Space(1) + Alltrim(cOption) + Space(1) +; //"Opção"
								 STR0134 +; //"Valor informado não corresponde com o tipo utilizado."
								 STR0135 } //"Informe um valor vazio ou do tipo lógico."
				Else
					Return aRet
				EndIf
			ElseIf TPC->TPC_TIPCAM == "D" .And. Valtype( xValue ) == "C" .And. !Empty( CToD ( xValue ) )
				cType:= Valtype( CToD ( xValue ) )
			Else
				cType:= Valtype(xValue)
			EndIf

			If TPC->TPC_TIPCAM <> cType
				aRet := {.F., STR0075 + ":" + Space(1) + Alltrim(cEtapa) + Space(1) +; //"Etapa"
							  STR0076 + ":" + Space(1) + Alltrim(cOption) + Space(1) +; //"Opção"
							  STR0134 +; //"Valor informado não corresponde com o tipo utilizado."
							STR0136 + Space(1) + NGRETSX3BOX("TPC_TIPCAM",TPC->TPC_TIPCAM)} //"Informe um valor do tipo"
			ElseIf Valtype(xValue) == "C" .Or. Valtype(xValue) == "D"
				aRet[2] := xValue
			ElseIf Valtype(xValue) == "N"
				aRet[2] := cValtoChar(xValue)
			ElseIf Valtype(xValue) == "L"
				aRet[2] := If(xValue,".T.",".F.")
			EndIf

		Else
			aRet := {.F., STR0075 + ":" + Space(1) + Alltrim(cEtapa) + Space(1) +; //"Etapa"
						  STR0076 + ":" + Space(1) + Alltrim(cOption) + Space(1) +; //"Opção"
						  STR0137 } //"não existe ou não pertence à tabela TPC - Opções da Etapa Genérica."
		Endif
	EndIf
Return aRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fModifEtapa
Verifica se uma etapa foi modificada

@author	Maria Elisandra de Paula
@since 14/08/2018
@param cOrder, caracter, código da ordem de serviço
@param cPlan, caracter, código do plano
@param cTarefa, caracter, código da tarefa
@param cEtapa, caracter, código da etapa
@param cOk, caracter, marcação campo TQ_OK
@param aAnswers, array, respostas da etapa
@return logic, se houve alteração
/*/
//---------------------------------------------------------------------
Static Function fModifEtapa(cOrder,cPlan,cTarefa,cEtapa,cOk,aAnswers)

	Local lModified := .F.
	Local cAliasQry := GetNextAlias()
	Local cQuery    := ""
	Local nI

	If (Empty(STQ->TQ_OK) .And. !Empty(cOk)) ; //marcou como executada
		.Or. (!Empty(STQ->TQ_OK) .And. Empty(cOk)) //desmarcou
		Return .T.
	EndIf

	cQuery := "SELECT TPQ_OPCAO, TPQ_RESPOS "
	cQuery += " FROM " + RetSqlName("TPQ")
	cQuery += " WHERE D_E_L_E_T_ = ' '"
	cQuery += "   AND TPQ_ORDEM  = " + ValtoSql(cOrder)
	cQuery += "   AND TPQ_PLANO  = " + ValtoSql(cPlan)
	cQuery += "   AND TPQ_TAREFA = " + ValtoSql(cTarefa)
	cQuery += "   AND TPQ_ETAPA  = " + ValtoSql(cEtapa)
	cQuery := ChangeQuery(cQuery)

	MPSysOpenQuery(cQuery, cAliasQry)

	While (cAliasQry)->(!EoF())
		If aScan(aAnswers, {|x| x[1] == (cAliasQry)->TPQ_OPCAO .And. Alltrim(x[2]) == Alltrim((cAliasQry)->TPQ_RESPOS ) }) == 0 //resposta igual
			lModified := .T. //modificou a resposta ou a excluiu
			Exit
		EndIf
		(cAliasQry)->(dbSkip())
	EndDo

	(cAliasQry)->(dbCloseArea())

	If !lModified
		For nI := 1 to Len(aAnswers)
			dbSelectArea("TPQ")
			dbSetOrder(1)
			If !dbSeek(xFilial("TPQ") + cOrder + cPlan + cTarefa + cEtapa + aAnswers[nI][1])
				lModified := .T. //incluiu uma resposta na etapa
				Exit
			EndIf
		Next nI
	EndIf
Return lModified
//---------------------------------------------------------------------
/*/{Protheus.doc} fCargaAcols
Verifica se uma etapa foi modificada

@author	Maria Elisandra de Paula
@since 14/05/2018
@param cOrder, caracter, código da ordem de serviço
@param cPlan, caracter, código do plano
@param cTarefa, caracter, código da tarefa
@param cEtapa, caracter, código da etapa
@param aAnswers, array, respostas da etapa
@param aHeaderAux, array, header de respostas
@return array, estrutura do acols para respostas da etapa
/*/
//---------------------------------------------------------------------
Static Function fCargaAcols(cOrder, cPlan, cTarefa, cEtapa, aAnswers, aHeaderAux,nOperat)

	Local nX
	Local aLinha     := BlankGetd(aHeaderAux)[1]
	Local aCols      := {}
	Local nPosFilial := aScan( aHeaderAux , {|x| Alltrim(x[2]) == "TPQ_FILIAL" })
	Local nPosOrdem  := aScan( aHeaderAux , {|x| Alltrim(x[2]) == "TPQ_ORDEM"  })
	Local nPosPlano  := aScan( aHeaderAux , {|x| Alltrim(x[2]) == "TPQ_PLANO"  })
	Local nPosTarefa := aScan( aHeaderAux , {|x| Alltrim(x[2]) == "TPQ_TAREFA" })
	Local nPosEtapa  := aScan( aHeaderAux , {|x| Alltrim(x[2]) == "TPQ_ETAPA"  })
	Local nPosOk     := aScan( aHeaderAux , {|x| Alltrim(x[2]) == "TPQ_OK"     })
	Local nPosOpcao  := aScan( aHeaderAux , {|x| Alltrim(x[2]) == "TPQ_OPCAO"  })
	Local nPosRespos := aScan( aHeaderAux , {|x| Alltrim(x[2]) == "TPQ_RESPOS" })
	Local cMarca  := GetMark()

	//-------------------------------------------------------
	// carrega acols com as respostas que devem ser gravadas
	//-------------------------------------------------------
	For nX := 1 to Len(aAnswers)
		aLinha[nPosFilial] := xFilial("TPQ")
		aLinha[nPosOrdem]  := cOrder
		aLinha[nPosPlano]  := cPlan
		aLinha[nPosTarefa] := cTarefa
		aLinha[nPosEtapa]  := cEtapa
		aLinha[nPosOk]     := cMarca
		aLinha[nPosOpcao]  := aAnswers[nX][1]
		aLinha[nPosRespos] := aAnswers[nX][2]

		aAdd(aCols,aClone(aLinha))
	Next nX

	//--------------------------------------------------------
	// carrega acols com as respostas que devem ser excluídas
	//--------------------------------------------------------
	If nOperat > 3
		dbSelectArea("TPQ")
		dbSetOrder(1)
		If dbSeek(xFilial("TPQ") + cOrder + cPlan + cTarefa + cEtapa)

			While !Eof() .And. cOrder + cPlan + cTarefa + cEtapa == ;
				TPQ->TPQ_ORDEM + TPQ->TPQ_PLANO + TPQ->TPQ_TAREFA + TPQ->TPQ_ETAPA

				If aScan(aAnswers, {|x| x[1] == TPQ->TPQ_OPCAO }) == 0
					aLinha[nPosFilial] := xFilial("TPQ")
					aLinha[nPosOrdem]  := cOrder
					aLinha[nPosPlano]  := cPlan
					aLinha[nPosTarefa] := cTarefa
					aLinha[nPosEtapa]  := cEtapa
					aLinha[nPosOpcao]  := TPQ->TPQ_OPCAO
					aTail(aLinha)      := .T. //deletada

					aAdd(aCols,aClone(aLinha))
				EndIf
				dbSkip()
			EndDo
		EndIf
	EndIf
Return aCols

//---------------------------------------------------------------------
/*/{Protheus.doc} fMessage
Retorna Json de mensagens

@author	Maria Elisandra de Paula
@since 11/06/2018
@param aOSGeradas, array, ordens ou solicitações geradas
	{TPQ->TPQ_TAREFA,TPQ->TPQ_ETAPA,TPQ->TPQ_OPCAO,TPQ->TPQ_ORDEMG}
@param aSSGeradas, array, solicitações geradas
	{TPQ->TPQ_TAREFA,TPQ->TPQ_ETAPA,TPQ->TPQ_OPCAO,TPQ->TPQ_ORDEMG}
@param aNoStQ, array, etapas não criadas/alteradas
	{TPQ->TPQ_TAREFA,TPQ->TPQ_ETAPA,TPQ->TPQ_OPCAO}
@param cOpenSR, caracter, solicitações vinculada na finalização da ordem
@return string, json
/*/
//---------------------------------------------------------------------
Static Function fMessage( aOSGeradas, aSSGeradas,aNoStQ, cOpenSR)

	Local cRet     := ""
	Local lItem    := .F.
	Local lFirst   := .T.
 	Local nX       := 0
 	Local cJsonItem:= ""

	Default cOpenSR:= ""

	//----------------------------------------
	// SS geradas pelas respostas de checklist
	//----------------------------------------
	cJsonItem := fJsonRes( aOSGeradas )
	If !Empty( cJsonItem )
		lItem := .T.
		cRet += '{"id":"serviceOrder",'
		cRet += '"items":[' + cJsonItem + ']}'
	EndIf

	//----------------------------------------
	// OS geradas pelas respostas de checklist
	//----------------------------------------
	cJsonItem := fJsonRes( aSSGeradas )

	If !Empty( cJsonItem )
		cRet += If(lItem,',','')
		lItem := .T.
		cRet += '{"id":"serviceRequest",'
		cRet += '"items":[' + cJsonItem + ']}'
	EndIf

	//----------------------------------------
	// checklist (STQ) não incluídos
	//----------------------------------------
	If Len( aNoSTQ ) > 0

		cRet += If(lItem,',','')
		lItem := .T.
		lFirst:= .T.

		cRet += '{"id":"checklist",'
		cRet += '"items":['

		For nX := 1 to Len( aNoSTQ )

			cRet  += If(lFirst,'',',')
			lFirst := .F.

			cRet += '{"task":"'     + Alltrim(aNoSTQ[nX][1]) + '",'
			cRet += '"checklist":"' + Alltrim(aNoSTQ[nX][2]) + '",'
			cRet += '"answer":"'    + Alltrim(aNoSTQ[nX][3]) + '"}'
		Next nX
		cRet += ']}'
	EndIf

	//------------------------------------------------
	// solicitações que ficam abertas na finalização
	//------------------------------------------------
	If !Empty( cOpenSR )
		cRet += If(lItem,',','')
		lItem := .T.
		cRet += '{"id":"openServiceRequest",'
		cRet += '"items":["' + Alltrim(cOpenSR) + '"]}'
	EndIf

Return cRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fJsonRes
Retorna Json de ordens/solicitações geradas pelas respostas de etapas

@author	Maria Elisandra de Paula
@since 15/05/2018
@param aGeradas, array, ordens ou solicitações geradas
@sample fJsonRes({TPQ->TPQ_TAREFA,TPQ->TPQ_ETAPA,TPQ->TPQ_OPCAO,TPQ->TPQ_ORDEMG})
@return string, json
/*/
//---------------------------------------------------------------------
Static Function fJsonRes(aGeradas)

	Local cRet    := ''
	Local lFirst  := .T.
	Local nI,nX
	Local aOrdens := {}

	For nI := 1 to Len(aGeradas)

		For nX := 1 to Len(aGeradas[nI])
			aOrdens:= aGeradas[nI]
			cRet  += ','
			If lFirst
				lFirst := .F.
				cRet := ''
			EndIf

			cRet += '{"task":"'     + Alltrim(aOrdens[nX][1]) + '",'
			cRet += '"checklist":"' + Alltrim(aOrdens[nX][2]) + '",'
			cRet += '"answer":"'    + Alltrim(aOrdens[nX][3]) + '"'
			cRet += ',"code":"'     + Alltrim(aOrdens[nX][4])
			cRet += '"}'
		Next nX
	Next nI
Return cRet

//---------------------------------------------------------------------
/*/{Protheus.doc} Localization
Busca localização do bem na TAF

@param cCode, Caracter, Código do Bem
@param cType, Caracter, Tipo do código (1=Bem; 2=Localização)

@author	Maria Elisandra de Paula
@since 23/01/2019

@return string, hierarquia completa do equipamento/localização
/*/
//---------------------------------------------------------------------
Static Function Localization( cCode, cType )

	Local cAliasQry := GetNextAlias()
	Local lAdd      := .F.
	Local cLocTree  := ""
	Local cQuery
	Local lAsset

	Default cType := '1'

	lAsset := cType == '1'

	cQuery := " WITH RECUR_TAF"
	cQuery += "    AS ("
	cQuery += "        SELECT TAF.TAF_CODNIV,"
	cQuery += "               TAF.TAF_NIVSUP,"
	cQuery += "               TAF.TAF_INDCON,"
	cQuery += "               TAF.TAF_CODCON,"
	cQuery += "               0 AS LEVEL,"

	//------------------------------------------------
	// Define origem do nome do registro base (bem/localização)
	//------------------------------------------------
	If lAsset
		// Para bem, captura o nome do equipamento (T9_NOME)
		cQuery += " Rtrim(Cast(ST9.T9_NOME AS VARCHAR("+ cValToChar( TamSx3("TAF_NOMNIV")[1] ) + "))) AS TAF_NOMNIV"
	Else
		// Para localização, utiliza o próprio nome da localização
		cQuery += " TAF.TAF_NOMNIV"
	EndIf

	cQuery += "        FROM " + RetSqlName("TAF") + " TAF"

	//------------------------------------------------
	// Para bem, confirma existencia do equipamento na ST9
	//------------------------------------------------
	If lAsset
		cQuery += "               INNER JOIN " + RetSqlName("ST9") + " ST9"
		cQuery += "                       ON ST9.T9_CODBEM = " + ValtoSql( cCode )
		cQuery += "                          AND ST9.T9_FILIAL = " + ValtoSql( xFilial("ST9") )
		cQuery += "                          AND ST9.D_E_L_E_T_ = ' ' "
	EndIf

	//------------------------------------------------
	// Filtros para busca do bem/localização base na TAF
	//------------------------------------------------
	cQuery += "        WHERE  TAF.TAF_FILIAL = " + ValtoSql( xFilial("TAF") )
	cQuery += "               AND TAF.TAF_MODMNT = 'X'"
	cQuery += "               AND TAF.D_E_L_E_T_ = ' '"
	cQuery += "               AND TAF.TAF_INDCON = " + ValToSql( cType )

	//------------------------------------------------
	// Filtra o código do bem/localização base
	//------------------------------------------------
	If lAsset
		// Para bem, busca pelo código do bem (TAF_CODCON)
		cQuery += "               AND TAF.TAF_CODCON = " + ValToSql( cCode )
	Else
		// Para localização, busca pelo código da localização (TAF_CODNIV)
		cQuery += "               AND TAF.TAF_CODNIV = " + ValToSql( cCode )
	EndIf

	cQuery += "         UNION ALL"

	//------------------------------------------------
	// Caso recursivo
	//------------------------------------------------
	cQuery += "         SELECT A.TAF_CODNIV, "
	cQuery += "                A.TAF_NIVSUP, "
	cQuery += "                A.TAF_INDCON, "
	cQuery += "                A.TAF_CODCON, "
	cQuery += "                ( R.LEVEL + 1 ) AS LEVEL, " // Nivel para ordenar
	cQuery += "                Rtrim(A.TAF_NOMNIV) "
	cQuery += "         FROM " + RetSqlName("TAF") + " A "
	cQuery += "                INNER JOIN RECUR_TAF R "
	cQuery += "                        ON R.TAF_NIVSUP = A.TAF_CODNIV "
	cQuery += "         WHERE  A.TAF_FILIAL = " + ValtoSql( xFilial("TAF") )
	cQuery += "                AND A.TAF_MODMNT = 'X' "
	cQuery += "                AND A.TAF_INDCON = '2' "
	cQuery += "                AND A.D_E_L_E_T_ = ' ')"

	cQuery += " SELECT NOMNIV = R.TAF_NOMNIV FROM RECUR_TAF R"
	cQuery += " ORDER BY R.LEVEL DESC"

	MPSysOpenQuery( cQuery, cAliasQry )
	dbSelectArea( cAliasQry )

	Do While !( cAliasQry )->( Eof() )

		If lAdd
			cLocTree += " > "
		Else
			lAdd := .T.
		EndIf

		cLocTree += Alltrim( ( cAliasQry )->NOMNIV )
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

Return cLocTree

//---------------------------------------------------------------------
/*/{Protheus.doc} ExtractBitmap
Extrai uma imagem do RPO, mas é construída para ser lançada
assincronamente em outro processo para fazer a partir de um contexto
de empresa e filial vazio. É um bugfix para o erro em REPOSIT.PRW da
TOTVS, não me julguem. "Draco dormiens nunquam titillandus"

@author  Marcelo Camargo
@since   26/01/2018
@version P12
@param   cObject, string, nome do objeto
@param   cPath, string, caminho de saída
@param   cEnterprise, string, empresa para posicionar
@param   cBranch, string, filial para posicionar
@return  logic, se extraiu imagem do RPO
/*/
//---------------------------------------------------------------------
Function ExtractBitmap( cObject, cPath, cEnterprise, cBranch )
	Local oReposit

	RpcSetType( 3 )
	RpcSetEnv( cEnterprise, cBranch, Nil, Nil, 'MNT' )
	cObject  := Left( cObject, 8 )
	oReposit := FWBmpRep():New()
	If !oReposit:ExistBmp( cObject )
		oReposit:CloseRepository()
		Return .F.
	EndIf
	oReposit:Extract( cObject, cPath )
	oReposit:CloseRepository()
	RpcClearEnv()
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} InsertBitmap
Insere um item no repositório de imagens

@author  Marcelo Camargo
@since   26/01/2016
@version P12
@param   cPath, string, localização atual do arquivo
@param   cObject, string, nome do objeto
@param   cEnterprise, string, empresa para posicionar
@param   cBranch, string, filial para posicionar
@return  Character, se inseriu o item no RPO de imagens
/*/
//---------------------------------------------------------------------
Function InsertBitmap( cPath, cObject, cEnterprise, cBranch )

	Local oReposit

	RpcSetType( 3 )
	RpcSetEnv( cEnterprise, cBranch, Nil, Nil, 'MNT' )
	oReposit := FWBmpRep():New()
	cObject := oReposit:InsertBmp( cPath, Left( cObject, 8 ), .T. )
	oReposit:CloseRepository()
	RpcClearEnv()
Return cObject

//---------------------------------------------------------------------
/*/{Protheus.doc} QServiceType
Query para tipos de serviços

@author	Maria Elisandra de paula
@since 28/09/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de tipos de serviços da ss
/*/
//---------------------------------------------------------------------
Static Function QServiceType( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("TQ3_MSBLQL","A","TQ3",.F.)
	Local cQuery := " SELECT TQ3_CDSERV "

	If cOrigin == "sServiceType"

		cQuery += " , TQ3_NMSERV, TQ3_CDRESP, "
		cQuery += "		CASE WHEN TQ3.D_E_L_E_T_ = ' ' "
		cQuery += "			THEN 'FALSE' Else 'true' "
		cQuery += "			END AS IS_DELETED, "

		If lBlock
			cQuery += " CASE WHEN TQ3.TQ3_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += "'' AS BLOCKED "
		EndIf
	EndIf

	cQuery += " FROM " + RetSqlName('TQ3') + " TQ3"
	cQuery += "	WHERE TQ3_FILIAL = " + ValtoSql(xFilial("TQ3"))

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TQ3_USERGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TQ3_USERGI" ) + " >=  " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND TQ3.D_E_L_E_T_ = ' '"
	EndIf

	cQuery := ChangeQuery(cQuery)

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sServiceType
Gera um arquivo json contendo as informações de tipos de serviços
para a sincronização com o aplicativo mobile

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sServiceType( oWs, cDate )

	Local aFileName	:= {}
	Local lFirst	:= .T.
	Local lFirstD	:= .T.
	Local nCount	:= 0
	Local cHrIn		:= Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := QServiceType( oWs, cDate, "sServiceType" )
	Local cAliasQry	:= GeraTemp( cQuery, 'ServiceType' )

	aFileName := GenFileName( 'servicetype' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{"serviceType":"' + NGEscape( (cAliasQry)->TQ3_CDSERV, .T. ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->TQ3_NMSERV, .T. ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"responsible":"' + NGEscape( (cAliasQry)->TQ3_CDRESP, .T. ) + '"}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->TQ3_CDSERV, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	FClose( nUpdate )
	printf("sServiceType: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return {.T., aFileName}

//---------------------------------------------------------------------
/*/{Protheus.doc} sExecutor
Gera um arquivo json contendo as informações de executantes de SS
para a sincronização com o aplicativo mobile

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sExecutor( oWs, cDate )

	Local aFileName	:= {}
	Local lFirst	:= .T.
	Local lFirstD	:= .T.
	Local nCount	:= 0
	Local cHrIn		:= Time()
	Local cSubJSON  := ""
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cQuery    := QExecutor( oWs, cDate, "sExecutor" )
	Local cAliasQry	:= GeraTemp( cQuery, 'Executor')

	aFileName := GenFileName( 'executor' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{"executor":"' + NGEscape( (cAliasQry)->TQ4_CDEXEC, .T. ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->TQ4_NMEXEC, .T. ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"email":"' + NGEscape( (cAliasQry)->TQ4_EMAIL1, .T. ) + '"}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->TQ4_CDEXEC, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sExecutor: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return {.T., aFileName}

//---------------------------------------------------------------------
/*/{Protheus.doc} QExecutor
Query para executante de solciitações

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de executantes de ss
/*/
//---------------------------------------------------------------------
Static Function QExecutor( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("TQ4_MSBLQL","A","TQ4",.F.)
	Local cQuery := "	SELECT TQ4_CDEXEC "

	If cOrigin == "sExecutor"

		cQuery += " , TQ4_NMEXEC, TQ4_EMAIL1, "
		cQuery += "		CASE WHEN TQ4.D_E_L_E_T_ = ' ' "
		cQuery += "			THEN 'FALSE' Else 'true' "
		cQuery += "			END AS IS_DELETED, "

		If lBlock
			cQuery += " CASE WHEN TQ4.TQ4_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += "'' AS BLOCKED "
		EndIf

	EndIf

	cQuery += " FROM " + RetSqlName('TQ4') + " TQ4"
	cQuery += "	WHERE TQ4_FILIAL = " + ValtoSql(xFilial("TQ4"))

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TQ4_USERGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TQ4_USERGI" ) + " >=  " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND TQ4.D_E_L_E_T_ = ' '"
	EndIf

	cQuery := ChangeQuery(cQuery)

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sWorkCenter
Gera um arquivo json contendo as informações de centro de trabalho
para a sincronização com o aplicativo mobile

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sWorkCenter( oWs, cDate )

	Local aFileName	:= {}
	Local lFirst	:= .T.
	Local lFirstD	:= .T.
	Local nCount	:= 0
	Local cHrIn		:= Time()
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := QWorkCenter( oWs, cDate, "sWorkCenter" )
	Local cAliasQry := GeraTemp( cQuery, 'WorkCenter' )

	aFileName := GenFileName( 'workcenter' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '{"workCenter":"' + NGEscape( (cAliasQry)->HB_COD, .T. ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAliasQry)->HB_NOME, .T. ) + '",'

			If (cAliasQry)->BLOCKED == "TRUE"
				cSubJSON += '"blocked":true,'
			EndIf

			cSubJSON += '"costCenter":"' + NGEscape( (cAliasQry)->HB_CC, .T. ) + '"}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->HB_COD, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sWorkCenter: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return {.T., aFileName}

//---------------------------------------------------------------------
/*/{Protheus.doc} QWorkCenter
Query para centro de trabalho

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de centro de trabalho
/*/
//---------------------------------------------------------------------
Static Function QWorkCenter( oWs, cDate, cOrigin )

	Local lBlock := NGCADICBASE("HB_MSBLQL","A","SHB",.F.)
	Local cQuery := " SELECT HB_COD "

	If cOrigin == "sWorkCenter"

		cQuery += " , HB_NOME, HB_CC, "
		cQuery += "		CASE WHEN SHB.D_E_L_E_T_ = ' ' "
		cQuery += "			THEN 'FALSE' Else 'true' "
		cQuery += "			END AS IS_DELETED, "

		If lBlock
			cQuery += " CASE WHEN SHB.HB_MSBLQL = '1' THEN 'TRUE' ELSE '' END AS BLOCKED "
		Else
			cQuery += "'' AS BLOCKED "
		EndIf

	EndIf

	cQuery += " FROM " + RetSqlName('SHB') + " SHB"
	cQuery += "	WHERE HB_FILIAL = " + ValtoSql(xFilial("SHB"))

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "HB_USERLGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "HB_USERLGI" ) + " >=  " + ValtoSql( cDate ) + ") "
	Else
		cQuery += " AND SHB.D_E_L_E_T_ = ' '"
	EndIf

	cQuery := ChangeQuery(cQuery)

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} QRequestOrders
Query para ordens das solicitações

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de ordens da ss
/*/
//---------------------------------------------------------------------
Static Function QRequestOrders( oWs, cDate, cOrigin, lOnlyExec )

	Local cQuery	:= ""
	Local lMultiple := SuperGetMv( 'MV_NGMULOS', .F., 'S' ) == 'S'

	Default lOnlyExec := .F.

	If cOrigin <> "sRequestOrders"
		cQuery := " SELECT STJ.TJ_ORDEM "
	Else

		cQuery := " SELECT TQB.TQB_SOLICI SOLICI, STJ.TJ_TIPOOS, "
		cQuery += " STJ.TJ_ORDEM, STJ.TJ_PLANO, STJ.TJ_SERVICO, STJ.TJ_SEQRELA, ST4.T4_NOME, STJ.TJ_SITUACA, STJ.R_E_C_N_O_, "
		cQuery += " STJ.TJ_CODBEM, STJ.TJ_HOMPINI, STJ.TJ_DTMPINI, STJ.TJ_DTMPFIM, STJ.TJ_DTORIGI, "
		cQuery += "	STJ.TJ_HOMPFIM, STJ.TJ_CCUSTO, CTT.CTT_DESC01, STJ.TJ_TERMINO, "
		cQuery += "	CASE WHEN STE.TE_CARACTE = 'P' THEN 'P' Else 'C' END AS TYPE, "
		cQuery += "	CASE WHEN STJ.TJ_TIPOOS = 'L' THEN TAF.TAF_NOMNIV Else ST9.T9_NOME END AS NOME, "

		//---------------------------------------------------------------------------------------------
		//O trecho abaixo deve ser o mesmo da query Qrequest
		//pois na entidade citada o controle de deletados também é realizado pela TQB como é feito aqui
		//----------------------------------------------------------------------------------------------
		cQuery += " CASE WHEN TQB.D_E_L_E_T_ = '*' THEN 'true' "
		cQuery += "	WHEN TQB.TQB_SOLUCA = 'C' THEN 'true' "
		 //Encerrada sem necessidade de feedback
		cQuery += " WHEN TQB.TQB_SOLUCA = 'E' AND TQ3.TQ3_PESQST = '2' THEN 'true' "
		 //Encerrada e já respondida
		cQuery += "	WHEN TQB.TQB_SOLUCA = 'E' AND TQ3.TQ3_PESQST = '1' AND TQB.TQB_PSAP <> ' ' THEN 'true' "
		//Encerrada não-respondida mas é de outro usuário
		cQuery += "	WHEN TQB.TQB_SOLUCA = 'E' AND TQ3.TQ3_PESQST = '1' AND TQB.TQB_PSAP = ' ' "
		cQuery += "		AND TQB.TQB_CDSOLI <> " + ValToSql( cUserLog ) + " THEN 'true' "
		cQuery += "	ELSE 'FALSE' END AS IS_DELETED "

	EndIf

	cQuery += " FROM " + RetSqlName("STJ") + " STJ"

	If lMultiple
		cQuery += " JOIN " + RetSqlName("TT7") + " TT7 ON "
		cQuery += " TT7.TT7_ORDEM = STJ.TJ_ORDEM "
		cQuery += "    AND TT7.TT7_FILIAL = " + ValtoSql(xFilial("TT7"))
		cQuery += "    AND TT7.D_E_L_E_T_ = ' ' "
	EndIf

	cQuery += " JOIN " + RetSqlName("TQB") + " TQB ON "
	cQuery += "    TQB.TQB_FILIAL = " + ValtoSql(xFilial("TQB"))

	If lMultiple
		cQuery += " AND TT7.TT7_SOLICI = TQB.TQB_SOLICI "
	Else
		//Quando não é de multiplas ordens, o vínculo é pelo campo TQB_ORDEM
		cQuery += " AND TQB.TQB_ORDEM = STJ.TJ_ORDEM "
	EndIf

	//------------------------------------------------------------------------
	//Deve ser passado o parâmetro de data para que sejam carregadas
	//todas as ordens de serviço das solicitações modificadas.
	//-------------------------------------------------------------------------
	cQuery += " AND TQB.TQB_SOLICI IN (" + QRequest( oWs, cDate, "sRequestOrders", lOnlyExec ) + ") "

	cQuery += " LEFT JOIN " + RetSqlName("TQ3") + " TQ3 ON "
	cQuery += " 	TQ3.TQ3_CDSERV = TQB.TQB_CDSERV"
	cQuery += " 	AND TQ3.TQ3_FILIAL = " + ValtoSql(xFilial("TQ3"))

	cQuery += " JOIN " + RetSqlName("ST4") + " ST4 ON "
	cQuery += " 	ST4.T4_SERVICO = STJ.TJ_SERVICO"
	cQuery += " 	AND ST4.T4_FILIAL = " + ValtoSql(xFilial("ST4"))
	cQuery += " 	AND ST4.D_E_L_E_T_ = ' '"

	cQuery += " JOIN " + RetSQLName('STE') + " STE "
	cQuery += "		ON STE.TE_TIPOMAN = ST4.T4_TIPOMAN "
	cQuery += "		AND STE.TE_FILIAL = " + ValtoSql( xFilial("STE") )
	cQuery += "		AND STE.D_E_L_E_T_ = ' ' "

	cQuery += " LEFT JOIN " + RetSqlName("ST9") + " ST9 ON "
	cQuery += " 	STJ.TJ_TIPOOS = 'B'"
	cQuery += " 	AND ST9.T9_CODBEM = STJ.TJ_CODBEM"
	cQuery += " 	AND ST9.T9_FILIAL = " + ValtoSql(xFilial("ST9"))
	cQuery += " 	AND ST9.D_E_L_E_T_ = ' ' "

	cQuery += " LEFT JOIN " + RetSqlName("TAF") + " TAF ON "
	cQuery += " 	STJ.TJ_TIPOOS = 'L'"
	cQuery += " 	AND TAF.TAF_CODNIV = RTRIM(STJ.TJ_CODBEM)"
	cQuery += " 	AND TAF.TAF_FILIAL = " + ValtoSql(xFilial("TAF"))
	cQuery += " 	AND TAF.D_E_L_E_T_ = ' '"

	cQuery += " LEFT JOIN " + RetSqlName("CTT") + " CTT ON"
	cQuery += " 	STJ.TJ_CCUSTO = CTT.CTT_CUSTO"
	cQuery += " 	AND CTT.CTT_FILIAL = " + ValtoSql(xFilial("CTT"))
	cQuery += " 	AND CTT.D_E_L_E_T_ = ' '"

	cQuery += " WHERE STJ.TJ_FILIAL = " + ValtoSql(xFilial("STJ"))
	cQuery += "    AND STJ.TJ_SITUACA IN( 'L', 'P' ) "
	cQuery += "    AND STJ.TJ_TIPOOS IN( 'B', 'L' ) "
	cQuery += "    AND (    ( STJ.TJ_TIPOOS = 'B' AND ST9.T9_CODBEM IS NOT NULL AND CTT.CTT_CUSTO IS NOT NULL ) "
	cQuery += "          OR ( STJ.TJ_TIPOOS = 'L' AND TAF.TAF_CODNIV IS NOT NULL AND ( STJ.TJ_CCUSTO = ' ' OR CTT.CTT_CUSTO IS NOT NULL ) ) ) "
	cQuery += "    AND STJ.D_E_L_E_T_ = ' ' "

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} sRequestOrders
Gera um arquivo json contendo as informações das ordens de serviço de solicitações

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//---------------------------------------------------------------------
Static Function sRequestOrders( oWs, cDate )

	Local aFileName	 := {}
	Local lFirst	 := .T.
	Local lFirstD	 := .T.
	Local nCount	 := 0
	Local cHrIn		 := Time()
	Local nDelete    := 0
	Local nUpdate    := 0
	Local cSubJSON   := ""
	Local cDtInicial := ""
	Local cDtFinal   := ""
	Local lSYP       := NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
	Local cDescri    := ""
	Local cQuery	 := ChangeQuery( QRequestOrders( oWs, cDate, "sRequestOrders" ) )
	Local cAliasQry := GeraTemp( cQuery, 'RequestOrders' )

	aFileName := GenFileName( 'requestorders' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			If !Empty((cAliasQry)->TJ_DTMPINI)
				cDtInicial := (cAliasQry)->TJ_DTMPINI
			Else
				cDtInicial := (cAliasQry)->TJ_DTORIGI
				printf('Ordem ' + (cAliasQry)->TJ_ORDEM + ' nao possui data inicial.')
			EndIf

			If !Empty((cAliasQry)->TJ_DTMPFIM)
				cDtFinal := (cAliasQry)->TJ_DTMPFIM
			Else
				cDtFinal := (cAliasQry)->TJ_DTORIGI
				printf('Ordem ' + (cAliasQry)->TJ_ORDEM + ' nao possui data final.')
			EndIf

			cSubJSON += '{"serviceRequest":"' 	+ NGEscape((cAliasQry)->SOLICI, .T. ) + '",'
			cSubJSON += '"orderCode":"' 		+ NGEscape((cAliasQry)->TJ_ORDEM, .T. ) + '",'
			cSubJSON += '"plan":"'				+ NGEscape( (cAliasQry)->TJ_PLANO ) + '",'
			cSubJSON += '"serviceCode":"' 		+ NGEscape((cAliasQry)->TJ_SERVICO, .T. ) + '",'
			cSubJSON += '"sequence":"' 			+ NGEscape( (cAliasQry)->TJ_SEQRELA ) + '",'
			cSubJSON += '"serviceName":"' 		+ NGEscape((cAliasQry)->T4_NOME, .T. ) + '",'
			cSubJSON += '"equipmentCode":"' 	+ NGEscape((cAliasQry)->TJ_CODBEM, .T. ) + '",'
			cSubJSON += '"equipmentName":"'		+ NGEscape((cAliasQry)->NOME, .T. ) + '",'
			cSubJSON += '"startDateTime":"'		+ cDtInicial + " " + NGEscape((cAliasQry)->TJ_HOMPINI, .T. ) + '",'
			cSubJSON += '"endDateTime":"'		+ cDtFinal   + " " + NGEscape((cAliasQry)->TJ_HOMPFIM, .T. ) + '",'
			cSubJSON += '"situation":"'			+ Alltrim( (cAliasQry)->TJ_SITUACA ) + '",'
			cSubJSON += '"type":"'				+ NGEscape( (cAliasQry)->TYPE ) + '",'

			If !Empty( (cAliasQry)->TJ_CCUSTO )
				cSubJSON += '"costCenterCode":"'	+ NGEscape((cAliasQry)->TJ_CCUSTO, .T. ) + '",'
				cSubJSON += '"costCenterName":"'	+ NGEscape((cAliasQry)->CTT_DESC01, .T. ) + '",'
			Endif

			If (cAliasQry)->TJ_TERMINO == 'S'
				cSubJSON += '"finished":true,'
			EndIf

			// Caso a S.S. seja do tipo localização adiciona o item LOCATION como true
			If (cAliasQry)->TJ_TIPOOS == 'L'
				cSubJSON += '"location":true,'
			EndIf

			dbSelectArea('STJ')
			dbGoTo( (cAliasQry)->R_E_C_N_O_ )

			If lSYP
				cDescri := NGMEMOSYP(STJ->TJ_MMSYP)
			Else
				cDescri := STJ->TJ_OBSERVA
			EndIf
			cSubJSON += '"description":"' + NGEscape( cDescri , .t. ) + '"}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->TJ_ORDEM, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sRequestOrders: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return {.T., aFileName}

//----------------------------------------------------------------------
/*/{Protheus.doc} QRequest
Query para solicitações de serviço

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@param cOrigin, caracter, função origem da chamada (utilizado para não entrar em loop)
@return string, query de ss
/*/
//----------------------------------------------------------------------
Static Function QRequest( oWs, cDate, cOrigin, lOnlyExec )

	Local cQuery := " SELECT TQB.TQB_SOLICI "
	Local lFilterUserSS := ValType(oWS:GetHeader( 'By-User-Related-Requests' )) == "C" ;
							.And. oWS:GetHeader( 'By-User-Related-Requests' ) == 'true'

	Default lOnlyExec := .F.

	If cOrigin == "sRequest"

		cQuery += ", TQB.TQB_CODBEM, TQB.TQB_CCUSTO, TQB.R_E_C_N_O_, "
		cQuery += "	 TQB.TQB_DTABER, TQB.TQB_HOABER, TQB.TQB_CDSOLI, TQB.TQB_USUARI, TQB.TQB_RAMAL, "
		cQuery += "	 TQB.TQB_SOLUCA, TQB.TQB_CDSERV, TQB.TQB_DTFECH, TQB.TQB_HOFECH, "
		cQuery += "	 TQB.TQB_TEMPO,  TQB.TQB_CDEXEC, TQB.TQB_PRIORI, TQB.TQB_PSAP, TQB.TQB_PSAN, TQ3.TQ3_PESQST, "
		cQuery += "	 TQB.TQB_POSCON, TQB.TQB_POSCO2, TQB.TQB_TIPOSS, "

		//---------------------------------------------------------------------------------------------
		//Se o trecho abaixo for modificado, deve ser replicado na query QrequestOrders
		//pois na entidade citada o controle de deletados também é realizado pela TQB como é feito aqui
		//----------------------------------------------------------------------------------------------
		cQuery += " CASE WHEN TQB.D_E_L_E_T_ = '*' THEN 'true' "
		cQuery += "	WHEN TQB.TQB_SOLUCA = 'C' THEN 'true' "
		 //Encerrada sem necessidade de feedback
		cQuery += " WHEN TQB.TQB_SOLUCA = 'E' AND TQ3.TQ3_PESQST = '2' THEN 'true' "
		 //Encerrada e já respondida
		cQuery += "	WHEN TQB.TQB_SOLUCA = 'E' AND TQ3.TQ3_PESQST = '1' AND TQB.TQB_PSAP <> ' ' THEN 'true' "
		//Encerrada não-respondida mas é de outro usuário
		cQuery += "	WHEN TQB.TQB_SOLUCA = 'E' AND TQ3.TQ3_PESQST = '1' AND TQB.TQB_PSAP = ' ' "
		cQuery += "		AND TQB.TQB_CDSOLI <> " + ValToSql( cUserLog ) + " THEN 'true' "

		//-----------------------------------------------------------------------------------
		// Envio de solicitações para serem deletadas, caso foi alterado o executante da ss
		//-----------------------------------------------------------------------------------
		If lFilterUserSS .And. cDate != '0'

			cQuery += " WHEN TQB.TQB_CDSOLI <> " + ValtoSql( cUserLog )

			If !Empty( cUserTQ4 ) //é executante de SS
				cQuery += " AND TQB.TQB_CDEXEC <> " + ValtoSql( cUserTQ4 )
			EndIf

			cQuery += " THEN 'true' "

		EndIf

		cQuery += "	ELSE 'FALSE' END AS IS_DELETED "
	EndIf

	cQuery += " FROM " + RetSqlName("TQB") + " TQB"

	cQuery += " LEFT JOIN " + RetSqlName("TQ3") + " TQ3 ON "
	cQuery += " 	TQ3.TQ3_CDSERV = TQB.TQB_CDSERV"
	cQuery += " 	AND TQ3.TQ3_FILIAL = " + ValtoSql(xFilial("TQ3"))

	cQuery += " WHERE TQB.TQB_FILIAL = " + ValtoSql(xFilial("TQB"))

	//-------------------------------------------------------------------
	// Somente as solicitações de serviço relacionadas ao usuário
	// Deve haver o filtro somente no primeiro sync
	// A partir do segundo sync será tratado no case when
	//-------------------------------------------------------------------
	If lFilterUserSS .And. cDate == '0'

		If !lOnlyExec

			cQuery += " AND ( TQB.TQB_CDSOLI = " + ValtoSql( cUserLog )

			If !Empty( cUserTQ4 ) //é executante de SS
				cQuery += " OR TQB.TQB_CDEXEC = " + ValtoSql( cUserTQ4 )
			EndIf

			cQuery += ")"

		ElseIf lOnlyExec .And. !Empty( cUserTQ4 ) // Somente SS do executante

			cQuery += " AND ( TQB.TQB_CDEXEC = " + ValtoSql( cUserTQ4 ) +")" 
		
		EndIf
		
	EndIf

	If cDate <> "0"
		cQuery += " AND (" + dateQuery( "TQB_USERGA" ) + " >= " + ValtoSql( cDate )
		cQuery += " OR " + dateQuery( "TQB_USERGI" ) + " >= " + ValtoSql( cDate ) + ") "
	Else
		cQuery += "	AND ( TQB.TQB_SOLUCA IN('A','D') "
		cQuery += " 	OR ( TQB.TQB_SOLUCA = 'E' AND TQ3.TQ3_PESQST = '1' "
		cQuery += " 		AND TQB.TQB_CDSOLI = " + ValToSql( cUserLog )
		cQuery += " 		AND TQB.TQB_PSAP = ' ' ) )" //pendente de feedback
		cQuery += " AND TQB.D_E_L_E_T_ = ' ' "

	EndIf

	//-------------------------------------------------------------
	// Condição abaixo para considerar apenas bens enviados ao app
	//-------------------------------------------------------------

	// Busca por bens e localizações
	cQuery += " AND ( ( TQB.TQB_TIPOSS = 'B' AND TQB.TQB_CODBEM IN ( " + QEquipment( oWS, "0", "QRequest" ) + " ) )"
	If aPermissions[ PERMISS_SS, 6 ] // location_ss
		cQuery += "   OR ( TQB.TQB_TIPOSS = 'L' AND TQB.TQB_CODBEM IN ( " + QLocation( oWS, "0", "QRequest"  ) + " ) ) "
	EndIf
	cQuery += " ) "

	// Considera cenários onde as localizações não possuem um centro de custo
	cQuery += " AND (
	If aPermissions[ PERMISS_SS, 6 ] // location_ss
		cQuery += " ( TQB.TQB_TIPOSS = 'L' AND TQB.TQB_CCUSTO = ' ' ) OR "
	EndIf
	cQuery += " TQB.TQB_CCUSTO IN ( " + QCostCenter( oWS, "0", "QRequest" ) + " ) )"


	If lPEMNTNG

		cFilter := ExecBlock( 'MNTNG', .F., .F., { 'FILTER_REQUEST', oWS } )

		If !Empty( cFilter )
			cQuery += cFilter
		EndIf

	EndIf

Return cQuery

//----------------------------------------------------------------------
/*/{Protheus.doc} sRequest
Gera um arquivo json contendo as informações das solicitações de serviço
para a sincronização com o aplicativo mobile

@author	Maria Elisandra de paula
@since 01/08/2018
@param oWS, objeto, referência ao webservice
@param cDate, caracter, data da última sincronização
@return array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//----------------------------------------------------------------------
Static Function sRequest( oWs, cDate )

	Local aFileName	:= {}
	Local lFirst	:= .T.
	Local lFirstD	:= .T.
	Local nCount	:= 0
	Local cHrIn		:= Time()
	Local cDescss   := ""
	Local cSolution := ""
	Local lMemoSS   := NGCADICBASE("TQB_CODMSS","A","TQB",.F.)
	Local lMemoSolu := NGCADICBASE("TQB_CODMSO","A","TQB",.F.)
	Local nDelete   := 0
	Local nUpdate   := 0
	Local cSubJSON  := ""
	Local cQuery    := ChangeQuery( QRequest( oWs, cDate, "sRequest" ) )
	Local cAliasQry := GeraTemp( cQuery, 'Request' )

	aFileName := GenFileName( 'request' )
	nDelete := FCreate( aFileName[ 1 ] )
	nUpdate := FCreate( aFileName[ 2 ] )

	If nDelete == -1 .Or. nUpdate == -1
		Return {.F., STR0017 + " " + AllTrim( Str( FError() ) )} //"Falha ao alocar memória:"
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	dbSelectArea(cAliasQry)
	While !(cAliasQry)->(EoF())

		If Upper( ( cAliasQry )->IS_DELETED ) == 'FALSE'
			// Itens a criar ou atualizar
			cSubJSON := ','

			If lFirst
				lFirst := .F.
				cSubJSON := ''
			EndIf

			//----------------------------------------------
			// Tratamento para campos memo
			//----------------------------------------------
			dbSelectArea("TQB")
			dbGoTo((cAliasQry)->R_E_C_N_O_)

			If lMemoSS
				cDescss := NGMEMOSYP(TQB->TQB_CODMSS)
			Else
				cDescss := TQB->TQB_DESCSS
			EndIf

			If lMemoSolu
				cSolution := NGMEMOSYP(TQB->TQB_CODMSO)
			Else
				cSolution := TQB->TQB_DESCSO
			EndIf

			//-------------------------------------------------
			// Rótulos enviados independente da situação da ss
			//-------------------------------------------------
			cSubJSON += '{"serviceRequest":"' 	+ NGEscape((cAliasQry)->TQB_SOLICI, .T. ) + '",'
			cSubJSON += '"equipment":"'			+ NGEscape((cAliasQry)->TQB_CODBEM, .T. ) + '",'
			cSubJSON += '"dateTime":"'			+ (cAliasQry)->TQB_DTABER + " " + (cAliasQry)->TQB_HOABER + '",'
			cSubJSON += '"description":"' 		+ NGEscape(cDescss, .T.) + '",'
			cSubJSON += '"requesterCode":"'		+ NGEscape((cAliasQry)->TQB_CDSOLI, .T. ) + '",'
			cSubJSON += '"requesterName":"'		+ NGEscape((cAliasQry)->TQB_USUARI, .T. ) + '",'
			cSubJSON += '"situation":"' 		+ (cAliasQry)->TQB_SOLUCA + '",'

			If !Empty((cAliasQry)->TQB_CDSERV)
				cSubJSON += '"serviceType":"' + NGEscape((cAliasQry)->TQB_CDSERV, .T. ) + '",'
			EndIf

			If !Empty((cAliasQry)->TQB_RAMAL)
				cSubJSON += '"telephoneExtension":"'+ NGEscape((cAliasQry)->TQB_RAMAL) + '",'
			EndIf

			//-------------------------------------------------------------
			// Encerradas serão enviadas somente se tem pesquisa pendente
			//-------------------------------------------------------------
			If (cAliasQry)->TQB_SOLUCA == 'E' .AND. (cAliasQry)->TQ3_PESQST == '1' .AND.;
				 Alltrim((cAliasQry)->TQB_CDSOLI) == Alltrim( cUserLog )
				cSubJSON += '"finish":"' + (cAliasQry)->TQB_DTFECH + " " + (cAliasQry)->TQB_HOFECH + '",'
				cSubJSON += '"duration":"' + (cAliasQry)->TQB_TEMPO + '",'
			EndIf

			If (cAliasQry)->TQB_SOLUCA != 'A'
				cSubJSON += '"executor":"' + NGEscape((cAliasQry)->TQB_CDEXEC) + '",'
				If !Empty( (cAliasQry)->TQB_PRIORI )
					cSubJSON += '"priority":"' + (cAliasQry)->TQB_PRIORI + '",'
				EndIf
			EndIf

			//-------------------------------------------------------------------------
			// Contadores serão enviados somente se foram informados na abertura da ss
			//-------------------------------------------------------------------------
			If (cAliasQry)->TQB_POSCON > 0
				cSubJSON += '"counter":' + cValtoChar((cAliasQry)->TQB_POSCON) + ','
			EndIf

			If (cAliasQry)->TQB_POSCO2 > 0
				cSubJSON += '"secondCounter":' + cValtoChar((cAliasQry)->TQB_POSCO2) + ','
			EndIf

			If !Empty( cSolution )
				cSubJSON += '"solution":"' + NGEscape( cSolution , .T. ) + '",'
			EndIf

			// Caso a S.S. seja do tipo localização adiciona o item LOCATION como true
			If (cAliasQry)->TQB_TIPOSS == 'L'
				cSubJSON += '"location":true,'
			EndIf

			//------------------------------
			// costCenter para fechar o json
			//------------------------------
			cSubJSON += '"costCenter":"' + NGEscape((cAliasQry)->TQB_CCUSTO, .T. ) + '"}'

			FWrite( nUpdate, cSubJSON )
		Else
			// Itens a excluir
			cSubJSON := ','

			If lFirstD
				lFirstD := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAliasQry)->TQB_SOLICI, .T. ) + '"'
			FWrite( nDelete, cSubJSON )
		EndIf
		nCount++
		( cAliasQry )->( dbSkip() )
	EndDo

	( cAliasQry )->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )
	printf("sRequest: " + cValtoChar(nCount) + " em " + ElapTime(cHrIn, Time()))

Return {.T., aFileName}


//----------------------------------------------------------------------
/*/{Protheus.doc} NGUpsertSR
Realiza a inclusão/alteração da solicitação de serviço de acordo com a operação

@author	Maria Elisandra de paula
@since 02/08/2018
@param oWS, objeto, referência ao webservice
@param cOperation, caracter, operação para gerar/alterar solicitações:
		'update', 'distribute', 'finish', 'feedback' or 'order'
@param cSolici, caracter, código da solicitação (quando alteração)
@param [lValEnv], lógico, define se deverá realizar validação de ambiente(ErrorForRequest).
@return array, [1] se obteve sucesso na operação
               [2] vazio ou descrição do erro
/*/
//----------------------------------------------------------------------
Function NGUpsertSR( oWS, cOperation, cSolici, lValEnv )

	Local aRet	 := { .T., ""}
	Local cJson	 := oWs:GetContent()
	Local oMntSR
	Local oParser
	Local cEqual := ""
	Local cError := ""
	Local aOrder := {}

	Default cSolici := ""
	Default lValEnv := .T.

	printf("service-request: inicio " + cSolici)
	
	If lValEnv
		//Valida o ambiente para solicitações
		aRet[2] := ErrorForRequest( )
		If !Empty( aRet[2] )
			Return { .F., "O ambiente não está devidamente configurado" + ":" + CRLF + aRet[2] }
		EndIf
	EndIf

	oMntSR := MntSR():New()

	If FWJsonDeserialize(cJson,@oParser) .And. ValType( oParser ) == "O"

		If cOperation == "create"
			//Variáveis públicas obrigatórias
			Public Inclui := .F.
			Public lLecancel := .F.
		ElseIf !NGIFDBSEEK("TQB", cSolici, 1)
			aRet := {.F., STR0138 } //"não localizada."
		EndIf

		If aRet[1]

			oMntSR:setOperation( IIf(cOperation == "create", 3, 4)) //Determina a operação
			oMntSR:setAsk(.F.)//Não apresenta mensagens condicionais

			//-----------------------------------------------------
			//Preenche os campos de acordo com a requisição do ws
			//-----------------------------------------------------
			aRet := fSetValueSS( oParser, oMntSR, cOperation, cSolici )

			If aRet[1]

				//-----------------------------------------------------
				//Verifica se a solicitação já foi incluída/alterada
				//-----------------------------------------------------
				cEqual := EqualRequest( oMntSR, cOperation, cSolici )

				If Empty(cEqual)

					printf("service-request: validando...")
					If !(oMntSR:valid()) //Validação da classe
						aRet[1] := .F.
						aRet[2] := oMntSR:GetErrorList()[1]
					Else
						printf("service-request: gravando dados...")
						If (cOperation $ "create/update/feedback" .And. oMntSR:upsert()) .Or.; //Realiza inclusão/alteração
							(cOperation == "distribute" .And. oMntSR:assign()) .Or. ;
							(cOperation == "finish" .And. oMntSR:close()) .Or.;
							(cOperation == "order" .And. Len(aOrder := oMntSR:createSO()) > 0 )

							If cOperation == "create"
								aRet[2] := '{"serviceRequest":"' + oMntSR:getValue("TQB_SOLICI") + '"}'
								Printf("service-request: " + oMntSR:getValue("TQB_SOLICI") + " incluida com sucesso!")
							ElseIf cOperation == "order"

								//-----------------------------------------------------
								//Inclusão de insumos realizados na ordem de serviço
								//-----------------------------------------------------
								If NGIFDBSEEK( "STJ", aOrder[1], 1 ) .And. !Empty( aInputs[_REALIZED_,_INSERT_] )

									printf(" Verificando insumos realizados XX ")
									aRet[2] := InputSTLRea( aOrder[1], If( AttIsMemberOf( oParser, 'type' ), oParser:type, "C" ) )

									If Empty( aRet[2] )
										//----------------------------------------------------------------
										//caso não ocorra erro na inclusão da ordem de serviço e insumos,
										//a segunda posição do array é o código da ordem gerada
										//----------------------------------------------------------------
										aRet[2] := aOrder[1]
									Else
										aRet[1] := .F.
									EndIf

									printf(" Termino da verificacao de insumos realizados ")
								EndIf

								If aRet[1]
									aRet[2] := aOrder[1]
									Printf("service-request: ordem de servico " + aOrder[1] +  " incluida com sucesso!")
								EndIf

							Else
								Printf("service-request: " + oMntSR:getValue("TQB_SOLICI") +" alterada com sucesso!")
							EndIf

						Else
							aRet := { .F., oMntSR:GetErrorList()[1] }
						EndIf
					EndIf
				Else

					RollBackSX8() // Cancela utilização de numero sugerido caso exista			
					If cOperation == "create"
						aRet[2] := '{"serviceRequest":"' + cEqual + '"}'
					ElseIf cOperation == "order"
						aRet[2] := cEqual
					EndIf

					Printf("service-request: " + cEqual + " - operacao " + cOperation + " ja foi realizada")

				EndIf
			EndIf
		EndIf
	Else
		aRet := { .F., STR0070 } // "Corpo da requisição inválido"
	EndIf

	//--------------------------------
	// mensagem de erro, caso ocorra
	//---------------------------------
	If !aRet[1]
		DO CASE
		CASE cOperation == "create"
			cError += STR0139 //"Erro ao incluir solicitação"
		CASE cOperation == "distribute"
			cError += STR0140 + " " + cSolici //"Erro ao distribuir a solicitação"
		CASE cOperation == "finish"
			cError += STR0141 + " " + cSolici //"Erro ao encerrar a solicitação "
		CASE cOperation == "order"
			cError += STR0142 + " " + cSolici //"Erro ao gerar ordem de serviço para a solicitação "
		OTHERWISE
			cError += STR0143 + " " + cSolici //"Erro ao alterar a solicitação"
		ENDCASE

		aRet[2] := cError + ": " + aRet[2]
	EndIf

	oMntSR:Free() //Elimina o objeto da memória.
Return aRet

//----------------------------------------------------------------------
/*/{Protheus.doc} removeSR
Realiza a exclusão da solicitação

@author	Maria Elisandra de paula
@since 06/08/2018
@param oWS, objeto, referência ao webservice
@param cSolici, caracter, código da solicitação a ser excluída
@return array, [1] se obteve sucesso na operação
               [2] vazio ou descrição do erro
/*/
//----------------------------------------------------------------------
Static Function removeSR( oWS, cSolici )

	Local aRet	 := { .T., "" }
	Local oMntSR
	Local cAliasQry

	Printf("service-request: " + cSolici + " - excluir")

	//Valida o ambiente para solicitações
	aRet[2] := ErrorForRequest( )
	If !Empty( aRet[2] )
		Return { .F., "O ambiente Protheus não está devidamente configurado" + ":" + CRLF + aRet[2] }
	EndIf

	oMntSR := MntSR():New()

	If !NGIFDBSEEK("TQB", cSolici, 1)

		cAliasQry := GetNextAlias()
		BeginSql Alias cAliasQry
			SELECT D_E_L_E_T_ EXCLUIDO FROM %table:TQB%
			WHERE TQB_FILIAL = %xFilial:TQB% AND TQB_SOLICI = %Exp:cSolici%
		EndSql

		If (cAliasQry)->EXCLUIDO == "*"
			Printf("service-request: operacao excluir ja realizada.")
			(cAliasQry)->(dbCloseArea())
			Return aRet
		Else
			Printf("service-request: " + cSolici + " nao localizada.")
			(cAliasQry)->(dbCloseArea())
			Return {.F., STR0145 } //"Solicitação não localizada."
		EndIf
	EndIf

	oMntSR:setAsk(.F.)//Não apresenta mensagens condicionais
	oMntSR:setOperation(5)
	oMntSR:load({xFilial("TQB") + cSolici}) // carrega campos da solicitação

	// Retira campo prioridade
	oMntSR:removeField( "TQB_PRIORI" )

	If !(oMntSR:valid() .And. oMntSR:delete()) //Realiza inclusão
		aRet[1] := .F.
		aRet[2] := STR0144 + ":" + Space(1) + cSolici + Space(1) + oMntSR:GetErrorList()[1] //"Erro ao excluir a solicitação"
		Printf("service-request: " + aRet[2])
	Else
		Printf("service-request: " + oMntSR:getValue("TQB_SOLICI") + " excluida com sucesso!")
	EndIf

	oMntSR:Free() //Elimina o objeto da memória.
Return aRet

//----------------------------------------------------------------------
/*/{Protheus.doc} fSetValueSS
Carrega os campos necessários de acordo com a objeto ws

@author	Maria Elisandra de paula
@since 06/08/2018
@param oParser, objeto, conteúdo recebido pela requisição
@param oMntSR, objeto, instância da classe MNTSR - ss
@param cOperation, caracter, tipo de operação ex.: "distribute"
@param cSolici, caracter, código da solicitação de serviço
@return array, [1] se obteve sucesso na operação
               [2] vazio ou descrição do erro
/*/
//----------------------------------------------------------------------
Static Function fSetValueSS( oParser, oMntSR, cOperation, cSolici )

	Local xValue
	Local aFieldsOrder := {}
	Local aChecklist := {}
	Local aJSON_Inputs := {}
	Local aTemp := {}
	Local ochecklist
	Local nX
	Local cError   := ""
	Local lRepCont := SuperGetMV( 'MV_NGLANEX', .F., '' ) != 'A'

	Default cSolici := ""

	printf("service-request: carregando dados...")

	If cOperation == "create"

		//------------------------------------------------
		//Campos que só podem ser preenchidos na inclusão
		//------------------------------------------------

		oMntSR:setValue("TQB_FILIAL", xFilial("TQB"))
		oMntSR:setValue("TQB_ORIGEM", IIf( AttIsMemberOf( oParser, "origin" ), oParser:origin, "MNTNG" ) )

		If AttIsMemberOf( oParser, "equipment" )
			oMntSR:setValue( 'TQB_CODBEM', PadR( oParser:equipment, Len( ST9->T9_CODBEM ) ) )
		EndIf

		//----------------------------------------------------------------------------------------------
		// Data e hora é considerado as informações enviadas do app para não gerar duplicadas
		//----------------------------------------------------------------------------------------------
		If AttIsMemberOf( oParser, "datetime" )
			xValue := StrTokArr( oParser:datetime," ")
			oMntSR:setValue( "TQB_DTABER", Stod( xValue[1] ) )
			oMntSR:setValue( "TQB_HOABER", xValue[2] )
			xValue := Nil
		EndIf

		//---------------------------------------------------------------------------
		// Recupera o centro de custo e centro de trabalho do equipamento no período
		//---------------------------------------------------------------------------
		If AttIsMemberOf( oParser, "location" )

			oMntSR:setValue( 'TQB_TIPOSS', 'L' )
			// Caso centro de custo esteja no Header, utilizará seu conteúdo
			If AttIsMemberOf( oParser, "costCenter" )

				If NGIFDBSEEK( 'CTT', oParser:costCenter, 1, .F.  )
					oMntSR:setValue( 'TQB_CCUSTO', Padr( oParser:costCenter, TamSx3("CTT_CUSTO")[1] ) )
				Else
					Return { .F., STR0186 } // 'Centro de custo informado não é válido! Favor verificar o conteúdo do campo costCenter'
				EndIf
				
			Else
				oMntSR:setValue( 'TQB_CCUSTO', Posicione( 'TAF', 7, xFilial( 'TAF' ) + 'X2' + SubStr( oParser:equipment, 1, 3 ), 'TAF_CCUSTO' ) )
			EndIf
			oMntSR:setValue( 'TQB_CENTRA', Posicione( 'TAF', 7, xFilial( 'TAF' ) + 'X2' + SubStr( oParser:equipment, 1, 3 ), 'TAF_CENTRA' ) )

		Else

			xValue := NgFilTPN(oMntSR:getValue("TQB_CODBEM"),oMntSR:getValue("TQB_DTABER"),oMntSR:getValue("TQB_HOABER"))
			If Len(xValue) > 0
				oMntSR:setValue("TQB_CCUSTO", xValue[2])
				oMntSR:setValue("TQB_CENTRA", xValue[3])
			EndIf

		EndIf

		xValue := Nil
		
		If lRepCont
			
			If AttIsMemberOf( oParser, "counter" ) .And. Valtype( oParser:counter ) == 'N'
				oMntSR:setValue("TQB_POSCON", oParser:counter)
			EndIf

			If AttIsMemberOf( oParser, "secondCounter" ) .And. Valtype( oParser:secondCounter ) == 'N'
				oMntSR:setValue("TQB_POSCO2", oParser:secondCounter)
			EndIf

		EndIf

	Else

		oMntSR:load({xFilial("TQB") + cSolici}) // Busca a chave da tabela de solicitação de serviço

	EndIf

	//----------------------------------------
	//Carrega status de acordo com operação
	//----------------------------------------
	Do Case
		Case cOperation == "create"
			oMntSR:setValue("TQB_SOLUCA", "A") //em análise
		Case cOperation == "distribute"
			oMntSR:setValue("TQB_SOLUCA", "D") //distribuída
		Case cOperation == "finish"
			oMntSR:setValue("TQB_SOLUCA", "E") //encerrada

	EndCase

	If AttIsMemberOf( oParser, "telephoneExtension" )
		oMntSR:setValue("TQB_RAMAL", oParser:telephoneExtension)
	EndIf

	If AttIsMemberOf( oParser, "description" )
		oMntSR:setValue("TQB_DESCSS", oParser:description)
	EndIf

	If AttIsMemberOf( oParser, "serviceType" )
		oMntSR:setValue("TQB_CDSERV", oParser:serviceType)
	EndIf

	If AttIsMemberOf( oParser, "priority" )
		If oParser:priority $ '1/2/3'
			oMntSR:setValue("TQB_PRIORI", oParser:priority)
		Else
			Return { .F., STR0184 } // 'Valor informado do campo prioridade inválido! Favor verificar o campo priority'
		EndIf
	ElseIf Empty( oMntSR:GetValue("TQB_PRIORI") )
		oMntSR:removeField( "TQB_PRIORI" )
	EndIf

	If AttIsMemberOf( oParser, "executor" )
		oMntSR:setValue("TQB_CDEXEC", oParser:executor)
	EndIf

	If cOperation == "finish"
		//--------------------------------------------------------
		//Campos que podem ser alterados somente no encerramento
		//--------------------------------------------------------
		If AttIsMemberOf( oParser, "finish" )
			xValue := StrTokArr( oParser:finish, " ")
			oMntSR:setValue("TQB_DTFECH", Stod(xValue[1]))
			oMntSR:setValue("TQB_HOFECH", xValue[2])
			xValue := nil
		EndIf

		If AttIsMemberOf( oParser, "duration" )
			oMntSR:setValue("TQB_TEMPO", oParser:duration)
		EndIf

		If AttIsMemberOf( oParser, "solution" )
			oMntSR:setValue("TQB_DESCSO", oParser:solution)
		EndIf

	ElseIf cOperation == "feedback"
		//----------------------------------------------------
		//Campos que podem ser alterados somente na pesquisa
		//----------------------------------------------------
		If AttIsMemberOf( oParser, "onTimeService" )
			oMntSR:setValue("TQB_PSAP", oParser:onTimeService)
		EndIf

		If AttIsMemberOf( oParser, "needFeedback" )
			oMntSR:setValue("TQB_PSAN", oParser:needFeedback)
		EndIf

		If AttIsMemberOf( oParser, "onTimeDescription" )
			oMntSR:setValue("TQB_OBSPRA", oParser:onTimeDescription)
		EndIf

		If AttIsMemberOf( oParser, "needFeedback" )
			oMntSR:setValue("TQB_OBSATE", oParser:needFeedback)
		EndIf

	ElseIf cOperation == "order"

		//-----------------------------------------------------
		// carrega campos da ordem de serviço da solicitação
		//-----------------------------------------------------
		If AttIsMemberOf( oParser, "equipment" )
			aAdd( aFieldsOrder, {"TJ_CODBEM" , Padr( oParser:equipment, TamSx3("T9_CODBEM")[1] ) } )
		Else
			aAdd( aFieldsOrder, { "TJ_CODBEM" , "" } )
		EndIf

		aAdd( aFieldsOrder, {"TJ_OBSERVA", IIf( AttIsMemberOf( oParser, "observation"), oParser:observation , "")})
		aAdd( aFieldsOrder, {"TJ_SERVICO", IIf( AttIsMemberOf( oParser, "service" ) , Padr( oParser:service, TamSx3("T4_SERVICO")[1] ) , "")})
		
		If AttIsMemberOf( oParser, "situation" )
			If Upper( oParser:situation ) $ 'L/P/C'
				aAdd( aFieldsOrder, { "TJ_SITUACA", oParser:situation } )
			Else
				Return { .F., STR0185 } //'A situação informada para abetura da O.S. não é válida! Favor informar uma situação válida.'
			EndIf
		Else
			aAdd( aFieldsOrder, { "TJ_SITUACA", "L" } )
		EndIf
		
		If AttIsMemberOf( oParser, "costCenter" )
			If NGIFDBSEEK( 'CTT', oParser:costCenter, 1, .F.  )
				aAdd( aFieldsOrder, {"TJ_CCUSTO" , Padr( oParser:costCenter, TamSx3("CTT_CUSTO")[1] ) })
			Else
				Return { .F., STR0186 } // 'Centro de custo informado não é válido! Favor verificar o conteúdo do campo costCenter'
			EndIf
		Else
			aAdd( aFieldsOrder, { 'TJ_CCUSTO', '' } )
		EndIf

		aAdd( aFieldsOrder, {"TJ_SEQRELA" , IIf( AttIsMemberOf( oParser, "sequence" ) , oParser:sequence  , "0")})
		aAdd( aFieldsOrder, {"TJ_PLANO"   , IIf( AttIsMemberOf( oParser, "sequence" ) , "000001"  , "000000")})

		If AttIsMemberOf( oParser, "location" )
			aAdd( aFieldsOrder, {'TJ_TIPOOS', 'L'})
		EndIf

		If AttIsMemberOf( oParser, "workCenter" )
			aAdd( aFieldsOrder, {"TJ_CENTRAB", Padr( oParser:workCenter, TamSx3("TJ_CENTRAB")[1] )})
		EndIf

		If AttIsMemberOf( oParser, "startDate" )
			xValue := StrTokArr( oParser:startDate, " ")
			aAdd( aFieldsOrder, {"TJ_DTORIGI", Stod(xValue[1])})
			aAdd( aFieldsOrder, {"TJ_HOMPINI", xValue[2]})
			
		Else
			aAdd( aFieldsOrder, {"TJ_DTORIGI", Ctod("") })
			aAdd( aFieldsOrder, {"TJ_HOMPINI", "" })
		EndIf

		If lRepCont .And. AttIsMemberOf( oParser, 'counter' ) .And. Valtype( oParser:counter ) == 'N'
			aAdd( aFieldsOrder, { 'TJ_POSCONT', oParser:counter } )
			aAdd( aFieldsOrder, { 'TJ_HORACO1', xValue[ 2 ] } )
		Else
			aAdd( aFieldsOrder, { 'TJ_POSCONT', 0 } )
		EndIf

		If lRepCont .And. AttIsMemberOf( oParser, 'secondCounter' ) .And. Valtype(oParser:secondCounter) == 'N'
			aAdd( aFieldsOrder, { 'TJ_POSCON2', oParser:secondCounter } )
			aAdd( aFieldsOrder, { 'TJ_HORACO2', xValue[ 2 ] } )
		Else
			aAdd( aFieldsOrder, { 'TJ_POSCON2', 0 } )
		EndIf

		//-----------------------------------------
		// Informações de parada do equipamento
		//-----------------------------------------
		If AttIsMemberOf( oParser, "downTime" )

			xValue := StrTokArr( oParser:downTime, " " )
			If !Empty( xValue[1] ) .And. !Empty( xValue[2] )
				aAdd( aFieldsOrder, {"TJ_DTPRINI", Stod( xValue[1] ) })
				aAdd( aFieldsOrder, {"TJ_HOPRINI", xValue[2] })
			EndIf
			xValue := Nil

		EndIf

		//---------------------------------------------------------------
		// carrega insumos previstos da ordem de serviço da solicitação
		//---------------------------------------------------------------
		If AttIsMemberOf( oParser, "inputs" ) .And. Len( oParser:inputs ) > 0
			//carrega arrays de insumos
			cError := getInputs( oParser:inputs )

			If !Empty( cError )
				Return { .F., cError }
			Else

				aInsert := aClone( aInputs[_FORESEEN_,_INSERT_] )

				For nX:= 1 to Len( aInsert ) //somente insumos não realizados
					aTemp := {}
					aAdd( aTemp, { "TL_TAREFA" , aInsert[nX,_TASK_] } )
					aAdd( aTemp, { "TL_TIPOREG", aInsert[nX,_TYPE_] } )
					aAdd( aTemp, { "TL_CODIGO" , aInsert[nX,_CODE_] } )
					aAdd( aTemp, { "TL_QUANREC", aInsert[nX,_RESOURCEAMOUNT_] } )
					aAdd( aTemp, { "TL_QUANTID", aInsert[nX,_AMOUNT_] } )
					aAdd( aTemp, { "TL_UNIDADE", aInsert[nX,_UNITY_] } )
					aAdd( aTemp, { "TL_DESTINO", aInsert[nX,_DESTINY_] } )
					aAdd( aTemp, { "TL_DTINICI", aInsert[nX,_STARTDATE_] } )
					aAdd( aTemp, { "TL_HOINICI", aInsert[nX,_STARTHOUR_] } )
					aAdd( aTemp, { "TL_DTFIM"  , aInsert[nX,_ENDDATE_] } )
					aAdd( aTemp, { "TL_HOFIM"  , aInsert[nX,_ENDHOUR_] } )
					aAdd( aTemp, { "TL_LOCAL"  , aInsert[nX,_WAREHOUSE_] } )
					aAdd( aTemp, { "TL_USACALE", aInsert[nX,_USECALE_] } )
					aAdd( aTemp, { "TL_SEQTARE", aInsert[nX,_SEQTASK_] } )
					aAdd( aTemp, { "TL_OBSERVA", aInsert[nX,_INPUTNOTE_] } )

					aAdd( aJSON_Inputs, aTemp )
				Next nX
			EndIf
		EndIf

		//-------------------------------------------------
		// carrega etapas da ordem de serviço da solicitação
		//-------------------------------------------------
		If AttIsMemberOf( oParser, "checklist" ) .And. Len( oParser:checklist ) > 0
			For nX:= 1 to Len( oParser:checklist )

				ochecklist := oParser:checklist[nX]
				aTemp := {}
				aAdd( aTemp, { "TQ_TAREFA" , IIf( AttIsMemberOf( ochecklist, "task" ), Padr( ochecklist:task, TamSx3("TQ_TAREFA")[1] ), "" ) } )
				aAdd( aTemp, { "TQ_ETAPA"  , IIf( AttIsMemberOf( ochecklist, "step" ), Padr( ochecklist:step, TamSx3("TQ_ETAPA")[1] ), "" ) } )
				aAdd( aTemp, { "TQ_SEQETA" , IIf( AttIsMemberOf( ochecklist, "sequence" ), Padr( ochecklist:sequence, TamSx3("TQ_SEQETA")[1] ), "" ) } )	

				aAdd( aChecklist, aTemp )

			Next nX
		Else
			aAdd( aChecklist, { } )
		EndIf

		If Len( aJSON_Inputs ) == 0
			aAdd( aJSON_Inputs, { } )
		EndIf

		oMntSR:setValueSO( { { aFieldsOrder, aJSON_Inputs, aChecklist } } )

	EndIf

Return { .T., "" }

//--------------------------------------------------------------------------------
/*/{Protheus.doc}  EqualRequest
Verifica se a inclusão/alteração já ocorreu.Esta verificação deve ocorrer
para não haver duplicidade de registros com códigos diferentes (quando inclusão)
e para evitar que um workflow seja enviado duas vezes.

@param oMntSR, objeto, instância da classe de solicitação MNTSR
@param cOperation, caracter, tipo de operação relacionada as rotas do ws:
		pode ser: "create", "update", "distribute", "finish" ou "feedback"
@param cSolici, caracter, código da solicitação de serviço
@author Maria Elisandra de Paula
@since 06/08/2018
@return string, vazio ou o código da ss já existente com as mesmas características
/*/
//---------------------------------------------------------------------
Static Function EqualRequest( oMntSR, cOperation, cSolici )

	Local cAliasQry := GetNextAlias()
	Local cQuery    := ""
	Local cEqual    := ""
	Local xValue
	Local lMultiple := SuperGetMv( 'MV_NGMULOS', .F., 'S' ) == 'S'
	Local nCodBem   := 0
	Local nHr		:= 0
	Local nDt		:= 0
	Local nServico	:= 0
	Local aFieldsOrder := {}

	printf("service-request: verificando...")

	If cOperation == "order"

		aFieldsOrder := oMntSR:aFieldSo[1, __AFIELDSO_SO__] //será sempre primeira posição pois é inserido apenas uma ordem por vez

		If lMultiple
			cQuery := " SELECT TT7_SOLICI SOLICI, TT7_ORDEM ORDEM "
		Else
			cQuery := " SELECT TQB_SOLICI SOLICI, TQB_ORDEM ORDEM "
		EndIf

		cQuery += " FROM " + RetSqlName("STJ") + " STJ"

		If lMultiple
			cQuery += " JOIN " + RetSqlName("TT7") + " TT7 ON "
			cQuery += " 	TT7_ORDEM = TJ_ORDEM "
			cQuery += " 	AND TT7_FILIAL = " + ValtoSql(xFilial("TT7"))
			cQuery += " 	AND TT7_SOLICI = " + ValtoSql( cSolici )
			cQuery += " 	AND TT7.D_E_L_E_T_ = ' ' "
		Else
			cQuery += " JOIN " + RetSqlName("TQB") + " TQB ON "
			cQuery += " 	TQB_ORDEM = TJ_ORDEM "
			cQuery += " 	AND TQB_FILIAL = " + ValtoSql(xFilial("TQB"))
			cQuery += " 	AND TQB_SOLICI = " + ValtoSql( cSolici )
			cQuery += " 	AND TQB.D_E_L_E_T_ = ' ' "
		EndIf

		cQuery += " WHERE STJ.D_E_L_E_T_ = ' ' "

		If (nCodBem	:= aScan(aFieldsOrder,{|x| AllTrim(Upper(X[1])) == "TJ_CODBEM" })) > 0
			cQuery += " AND TJ_CODBEM =  " + ValtoSql( aFieldsOrder[nCodBem, 2] )
		EndIf

		If (nDt := aScan(aFieldsOrder,{|x| AllTrim(Upper(X[1])) == "TJ_DTORIGI" })) > 0
			cQuery += " AND TJ_DTORIGI = " + ValtoSql( aFieldsOrder[nDt, 2] )
		EndIf

		If (nHr	:= aScan(aFieldsOrder,{|x| AllTrim(Upper(X[1])) == "TJ_HOMPINI" })) > 0
			cQuery += " AND TJ_HOMPINI = " + ValtoSql( aFieldsOrder[nHr, 2] )
		EndIf

		If (nServico:= aScan(aFieldsOrder,{|x| AllTrim(Upper(X[1])) == "TJ_SERVICO" })) > 0
			cQuery += " AND TJ_SERVICO = " + ValtoSql( aFieldsOrder[nServico, 2] )
		EndIf
	Else

		cQuery := " SELECT TQB_SOLICI SOLICI FROM " + RetSqlName("TQB") + " TQB"
		cQuery += " WHERE TQB.D_E_L_E_T_ = ' ' "
		cQuery += " AND TQB_FILIAL = " + ValtoSql(xFilial("TQB"))

		If cOperation == "create"
			//----------------------------------------------------------------
			//Compara campos preenchidos na inclusão e não podem ser alterados
			//----------------------------------------------------------------
			cQuery += "	AND TQB_CODBEM = " + ValToSql(oMntSR:getValue("TQB_CODBEM"))
			cQuery += "	AND TQB_DTABER = " + ValToSql(oMntSR:getValue("TQB_DTABER"))
			cQuery += "	AND TQB_HOABER = " + ValToSql(oMntSR:getValue("TQB_HOABER"))
			cQuery += "	AND TQB_POSCON = " + ValToSql(oMntSR:getValue("TQB_POSCON"))
			cQuery += "	AND TQB_POSCO2 = " + ValToSql(oMntSR:getValue("TQB_POSCO2"))
			cQuery += "	AND TQB_CDSOLI = " + ValToSql(oMntSR:getValue("TQB_CDSOLI"))
			cQuery += " AND TQB_CDSERV = " + ValToSql(oMntSR:getValue("TQB_CDSERV"))

		Else
			cQuery += " AND TQB_SOLICI = " + ValToSql(oMntSR:getValue("TQB_SOLICI"))

			If cOperation == "update"
				cQuery += " AND TQB_RAMAL  = " + ValToSql(oMntSR:getValue("TQB_RAMAL"))
				cQuery += " AND TQB_CDSERV = " + ValToSql(oMntSR:getValue("TQB_CDSERV"))
				cQuery += " AND TQB_PRIORI = " + ValToSql(oMntSR:getValue("TQB_PRIORI"))
				cQuery += " AND TQB_CDEXEC = " + ValToSql(oMntSR:getValue("TQB_CDEXEC"))
			ElseIf cOperation == "distribute"
				cQuery += " AND TQB_SOLUCA = 'D'"
			ElseIf cOperation == "finish"
				cQuery += " AND TQB_SOLUCA = 'E'"
			Elseif cOperation == "feedback"
				cQuery += " AND TQB_PSAP <> ' '"
			EndIf
		EndIf
	EndIf

	cQuery := ChangeQuery( cQuery )
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)

	cEqual := (cAliasQry)->SOLICI

	If !Empty( cEqual )

		If cOperation == "order"
			cEqual := (cAliasQry)->ORDEM
		Else
			//-----------------------------------------
			// Verifica se o campo memo foi alterado
			//-----------------------------------------
			dbSelectArea("TQB")
			dbSetOrder(1)
			If dbSeek(xFilial("TQB") + cEqual )

				If NGCADICBASE("TQB_CODMSS","A","TQB",.F.)
					xValue := NGMEMOSYP(TQB->TQB_CODMSS)
				Else
					xValue := TQB->TQB_DESCSS
				EndIf

				If Alltrim(xValue) != Alltrim(oMntSR:getValue("TQB_DESCSS"))// Verifica se o campo memo foi alterado
					cEqual := ""
				EndIf

			EndIf
		EndIf
	EndIf

	(cAliasQry)->(dbCloseArea())

Return cEqual

//----------------------------------------------------------------------
/*/{Protheus.doc} listImgSR
Envia lista de imagens vinculadas a solicitação de serviço

@author	Maria Elisandra de paula
@since 20/08/2018
@param cSolici, caracter, código da solicitação a ser excluída
@param oWs, objeto, webservice
@return array, [1] se obteve sucesso na operação
               [2] vazio ou descrição do erro
/*/
//----------------------------------------------------------------------
Static Function listImgSR( cSolici, oWs )

	Local aRet	 := { .T., "" }
	Local oMntSR
	Local aResponse := {}

	printf( "service-request: lista imagens")

	//Valida o ambiente para solicitações
	aRet[2] := ErrorForRequest( )
	If !Empty( aRet[2] )
		Return { .F., "O ambiente Protheus não está devidamente configurado" + ":" + CRLF + aRet[2] }
	EndIf

	oMntSR := MntSR():New()

	// Garante existência da ordem de serviço
	If !NGIFDBSEEK("TQB", cSolici, 1)
		printf("service-request: nao localizada")
		Return .F.
	EndIf

	aResponse := fListImg( cSolici, 'TQB' )

	oWs:SetResponse( FWJsonSerialize( aResponse, .F. ) )
	oWs:SetStatus( 200 )
	oMntSR:Free()

Return .T.

//----------------------------------------------------------------------
/*/{Protheus.doc} delImageSR
Remove uma imagem da solicitação de serviço
do \dirdoc\ e da tabelas AC9 e ACB

@author	Maria Elisandra de paula
@since 21/08/2018
@param cID, caracter, código do objeto no banco do conhecimento
@param oWs, objeto, referencia do ws rest
@return array, [1] se obteve sucesso na operação
               [2] vazio ou descrição do erro
/*/
//----------------------------------------------------------------------
Static Function delImageSR( oWs, cID )

	Local aRet := { .T., "" }
	Local oMntSR

	Printf( "Service request: delImageSR "  + cID )

	//Valida o ambiente para solicitações
	aRet[2] := ErrorForRequest( )
	If !Empty( aRet[2] )
		Return { .F., "O ambiente Protheus não está devidamente configurado" + ":" + CRLF + aRet[2] }
	EndIf

	oMntSR := MntSR():New()

	If !oMntSR:deleteFile( cID ) .And. Len( oMntSR:getErrorList() ) > 0
		aRet := {.F. , oMntSR:getErrorList()[1] }
	EndIf
Return aRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fSpecialties
Busca especialidades do funcionário

@param cCodFunc, caracter, código do funcionário na ST1
@author	Maria Elisandra de Paula
@since 28/08/2018
@return array, especialidades do funcionário
/*/
//---------------------------------------------------------------------
Static Function fSpecialties( cCodFunc )

	Local aRet := {}
	Local cAliasQry := GetNextAlias()

	BeginSql Alias cAliasQry
		SELECT T2_ESPECIA
		FROM %table:ST2% ST2
		WHERE
			ST2.T2_FILIAL = %xFilial:ST2% AND
			ST2.T2_CODFUNC = %Exp:cCodFunc% AND
			ST2.%NotDel%
	EndSql

	While !( cAliasQry )->( EoF() )
		aAdd( aRet, ( cAliasQry )->T2_ESPECIA )
		( cAliasQry )->(dbSkip())
	EndDo

	( cAliasQry )->(dbCloseArea())

Return aRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fUserQuery
String para usuário de inclusão

@author	Maria Elisandra de Paula
@since 04/10/2018
@return string, utilizado para comparação de usuário
/*/
//---------------------------------------------------------------------
Static Function fUserQuery()

	Local cQuery := " RTRIM( "

	cQuery += " SUBSTRING(TJ_USERLGI, 11,1) || SUBSTRING(TJ_USERLGI, 15,1) ||"
	cQuery += "  SUBSTRING(TJ_USERLGI, 2, 1) || SUBSTRING(TJ_USERLGI, 6, 1) ||"
	cQuery += "  SUBSTRING(TJ_USERLGI, 10,1) || SUBSTRING(TJ_USERLGI, 14,1) ||"
	cQuery += "  SUBSTRING(TJ_USERLGI, 1, 1) || SUBSTRING(TJ_USERLGI, 5, 1) ||"
	cQuery += "  SUBSTRING(TJ_USERLGI, 9, 1) || SUBSTRING(TJ_USERLGI, 13,1) ||"
	cQuery += "  SUBSTRING(TJ_USERLGI, 17,1) || SUBSTRING(TJ_USERLGI, 4, 1) ||"
	cQuery += "  SUBSTRING(TJ_USERLGI, 8, 1) ) "

Return cQuery

//---------------------------------------------------------------------
/*/{Protheus.doc} CheckAccess
Realiza operações/validações iniciais para rotas

@author	Maria Elisandra de Paula
@since 22/11/2018
@param oWS, objeto, referência ao webservice
@param lCheckUser, boolean, se há necessidade de validação de usuário
@param lCheckOrder, boolean, se há necessidade de validação para ordem de serviço
@return logic, se obteve sucesso na inicialização do ambiente e usuário válido
/*/
//---------------------------------------------------------------------
Static Function CheckAccess( oWs, lCheckUser, lCheckOrder )

	Local lRet   := .T.
	Local aUser  := {}
	Local cError := ''

	Default lCheckUser  := .T.
	Default lCheckOrder := .F.

	StartStatics( oWs ) //inicializa variáveis static

	oWs:ClearResponse()
	oWs:SetContentType( 'application/json' )

	If !fVerFontes()
		Return .F.
	EndIf

	If !lMingle
		cError := fLicense(oWs) // Realiza abertura da empresa/consome licença
		If !Empty(cError)
			lRet := .F.
			SetRestFault(401, EncodeUtf8( cError ) )
			Printf( cError )
		EndIf
	EndIf

	If lRet

		//------------------------------------------------------
		// As variáveis lDBOrderOk e lDBRequestOk devem
		// ser definidas logo após a abertura da empresa/filial
		//------------------------------------------------------
		lDBOrderOk := Len( fCheckBase( "order" ) ) == 0
		lDBRequestOk := Len( fCheckBase( "request" ) ) == 0

		If lCheckOrder .And. !lDBOrderOk
			SetRestFault(401, EncodeUtf8( STR0149 ) ) //401( não autorizado ) - Os campos de usuário para ordens de serviço não estão configurados.
			Printf( STR0149 )
			lRet :=  .F.
		EndIf

		If lRet .And. lCheckUser

			If lHasSecurity

				fLogMntng( 'lHasSecurity - __cUserID: ' + IIf( Type('__cUserID') == 'C', __cUserID, 'Nulo' ) )

				cUserLog  := __cUserID
				cUserName := UsrRetName( __cUserID )

				GetUserCfg( Trim( UsrRetMail( __cUserID ) ) ) // Vínculo UserProtheus x ST1 x TQ4 (executante de solicitações)

			Else

				aUser := fVldNoSecur( oWs:GetHeader('user'), oWs:GetHeader('password')) // Realiza validação do usuário

				If !aUser[1]
					SetRestFault(401, EncodeUtf8(aUser[2]) ) //401 - não autorizado
					Printf( aUser[2] )
					lRet :=  .F.
				Else
					cUserLog  := aInfoUser[ 2, 1 ]
					cUserName := UsrRetName( cUserLog )
					__cUserID := aInfoUser[2, 1]	// Variável pública necessária para realizar o log de inclusão de usuário

					GetUserCfg( cEmail ) // Recupera vínculo do funcionário da manutenção e executante de solicitações
				EndIf

			EndIf

		EndIf

	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} PrintPostLog
Realiza operações finais após as operações realizadas nas rotas post

@author	Maria Elisandra de Paula
@since 22/11/2018
@param oWS, objeto, referência ao webservice
@param lRet, boolean, indica se as operações ocorreram com sucesso
@param aRet, array, retorno das operações
				[1] indica se as operações ocorreram com sucesso
				[2] mensagem de erro/sucesso
				[3] Etapas não geradas
				[4] Código de erro MNTNG.
@return logic, se operações foram realizadas com sucesso de acordo com os parâmetros
/*/
//---------------------------------------------------------------------
Static Function PrintPostLog( oWs, lRet, aRet )

	Local nSize     := 0
	Local nCodeRest := 400

	Default aRet := {}

	// Verifica tamanho do array de informações
	nSize := Len( aRet )

	If nSize > 0

		If !aRet[ 1 ]
			lRet := .F.
			If nSize > 3
				nCodeRest := aRet[ 4 ]
			EndIf
			SetRestFault( nCodeRest, EncodeUTF8( aRet[ 2 ] ), , 400 )
			printf( '-------------------------------------------' )
			printf('SetRestFault: ' + cValToChar( nCodeRest ) )
			printf( aRet[ 2 ] )
			printf( '-------------------------------------------' )
		Else
			oWs:SetStatus( 200 )
			If !Empty( aRet[2] )
				oWs:SetResponse( EncodeUtf8( aRet[2] ) )
			Else
				oWs:SetResponse( '{}' )
			EndIf
		EndIf

	ElseIf !lRet
		printf('-------------------------------------------')
		printf('SetRestFault: 500')
		printf("Houve um problema ao executar a requisição.")
		printf('-------------------------------------------')
		SetRestFault( 500, EncodeUTF8(STR0010) )//"Houve um problema ao executar a requisição."
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} CloseTransactions
Realiza operações pós controle de transação

@author	Maria Elisandra de Paula
@since 22/11/2018
@param aRet, array, retorno das operações
				[1] indica se as operações ocorreram com sucesso
@return nil
/*/
//---------------------------------------------------------------------
Static Function CloseTransactions( aRet )

	//Caso tenha sido executado e tenha caído em uma validação
	If len(aRet) > 0 .And. !aRet[1]
		DisarmTransaction()
	EndIf

	//Garante que todos os BeginTran foram liberados
	While inTransact()
		printf('------------ Liberando transacao ------------')
		EndTran()
	Enddo

	//Garante que todos os registro foram liberados
	DBCommitAll( )
	MsUnlockAll( )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} GetInfoLogin
Recupera informações de usuário e filiais com permissão de acesso

@author	Maria Elisandra de Paula
@since 13/12/2018
@param cEmail, string, email do usuário
@param cPassword, string, senha do usuário
@param lDecodePsw, boolean, indica se a senha deve ser decodificada segundo o padrão BASE64
@param oWs, objeto, instancia do web service
@return array, [1] se obteve sucesso, [2] filiais do usuário, [3] infos de usuário
/*/
//---------------------------------------------------------------------
Static Function GetInfoLogin( cEmail, cPassword, lDecodePsw, oWs )

	Local nIndex    := 0
	Local aInfoUser := {}
	Local aBranches := {}
	Local aLoadSM0  := {}
	Local aUser     := isUser( cEmail, cPassword, lDecodePsw )
	Local aValid    := {}
	Local aIgnore   := fIgnoreEnt(oWs)
	Local cEnterp   := ''
	Local cBranch   := ''

	If !aUser[1]
		Return { .F., aUser[2] }
	Else
		aInfoUser := aUser[2]
	EndIf

	//Carrega as filiais do usuário respeitando as restrições de acesso
	aBranches := BranchUser( aInfoUser )

	If Empty( aBranches )
		Return { .F., STR0071 } //"Usuário sem permissão de acesso às empresas/filiais no ERP Protheus."
	EndIf

	/*
		A função ConfigEnv2 abaixo não abre o ambiente (pois não é passado os dois primeiros parâmetros),
	 	mas é necessário utilizá-la para que as filiais retornadas em FWLoadSM0 sejam apenas as válidas
	*/
	If !lMingle
		ConfigEnv2( '', '', aInfoUser[1,2])
	EndIf

	If aScan( aBranches, '@@@@' ) > 0 // @@@@ significa acesso a todas as filiais

		// Se tiver acesso a todas as empresas/filiais, percorre toda a SM0
		If ValType( aLoadSM0 := FWLoadSM0( .T. ) ) <> "A" .Or. Empty(aLoadSM0)
			Return { .F., STR0072 } //"Não foi possível carregar as empresas/filiais."
		Endif

		aBranches := {}
		For nIndex := 1 To Len( aLoadSM0 )
			aAdd( aBranches, aLoadSM0[ nIndex, 1 ] + aLoadSM0[ nIndex, 2 ] )
		Next nIndex
	
	EndIf

	//Ordena as filiais
	Asort( aBranches )

	For nIndex := 1 To Len( aBranches )

		cEnterp := Substr( aBranches[nIndex], 1, 2 )
		cBranch := Substr( aBranches[nIndex], 3 )

		If Ascan(aIgnore, cEnterp) == 0 .And. ; // descarta filiais do ponto de entrada reject group
			FWFilExist( cEnterp, cBranch  ) .And. ; // verifica se filial existe pois aBranches pode trazer filiais deletadas
			AScan( aValid, aBranches[ nIndex ] ) == 0 //Para não repetir filiais no array (pode ter filiais deletadas com mesmo ID)
			
			aAdd( aValid, aBranches[ nIndex ] )
		
		EndIf

	Next nIndex

Return { .T., aValid, aInfoUser }

//-------------------------------------------------------------------------
/*/{Protheus.doc} BranchUser
Recupera as filiais do usuário considerando o grupo e permissões de acesso

@param aInfoUser, array, informações do usuário
@author Maria Elisandra de Paula
@since 24/09/2019
@version P12
@return array, código das filiais
/*/
//-------------------------------------------------------------------------
Static Function BranchUser( aInfoUser )

	Local aAuxiliar := {}
	Local aReturn   := {}
	Local aGroups   := {}
	Local aBrUser   := {}
	Local aBrGroup  := {}
	Local cGrpRule  := ''
	Local lUser19   := .F.
	Local l156      := .F.
	Local nIndex    := 0
	Local nGroup    := 0

	//--------------------------------------------------
	// cGrpRule - indica a regra de acesso por grupo
	// 1-Usuário prioriza regras do grupo
	// 2-Usuário desconsidera regras do grupo
	// 3-Usuário soma regras do grupo
	//--------------------------------------------------
	cGrpRule  := FWUsrGrpRule( aInfoUser[ 1, 1 ] )

	If cGrpRule $ "2/3"

		lUser19 := fCheckMod( aInfoUser[3] ) //Indica se usuário possui acesso ao SIGAMNT ou SIGAGFR

		//Quando o usuário não possui acesso ao módulo
		If !lUser19 .And. cGrpRule == "2"
			Return aReturn
		EndIf

		aBrUser := aInfoUser[ 2, 6 ] //recupera as filiais do usuário

		If cGrpRule == "2"
			aReturn := aClone( aBrUser )//desconsidera as filiais do grupo
		EndIf

	EndIf

	If cGrpRule $ "1/3"

		//recupera os grupos do usuário - o primeiro grupo tem prioridade
		aGroups := GroupUser( aInfoUser[1][1] )

		If Ascan( aGroups, { |x| x[2] } ) == 0 // nenhum grupo tem acesso ao 19 ou 95

			If cGrpRule == "1" //Prioriza
				Return aReturn
			EndIf

			//Não tem permissão ao 19 ou 95 nas configs de grupo e nem nas configurações de usuário
			If cGrpRule == "3" .And. !lUser19 //soma
				Return aReturn
			EndIf

		EndIf

		//Trecho abaixo busca as filiais dos grupos considerando as permissões de acesso
		For nGroup := 1 to Len( aGroups )

			cGroup := aGroups[ nGroup, 1 ]

			//o primeiro grupo sempre tem prioridade em relação aos acessos
			//FWGrpAcess - retorna strings de 'S' e 'N' dos acessos configurados no SIGACFG/Acessos
			If nGroup == 1 .And. Substr( FWGrpAcess( cGroup ), 156, 1 ) == 'S'
				l156 := .T. // será possível acessar apenas os módulos que estiverem em cada grupo
			EndIf

			If l156 .And. !aGroups[ nGroup, 2 ] // Verifica se o grupo tem acesso ao 19 ou 95
				Loop
			EndIf

			aAuxiliar := FWGrpEmp( cGroup )//Recupera as filiais do grupo

			//Tratamento para não repetir as filiais
			For nIndex := 1 To Len( aAuxiliar )
				If aScan( aBrGroup, Alltrim( aAuxiliar[ nIndex ] ) ) == 0
					aAdd( aBrGroup, Alltrim( aAuxiliar[ nIndex ] ) )
				EndIf
			Next nIndex

		Next nGroup

		aReturn := aClone( aBrGroup )//Considera as filiais do usuário

		If cGrpRule == "3" .And. !( l156 .And. !lUser19 )
			//Soma as filiais do usuario com as filiais do grupo
			For nIndex := 1 to Len( aBrUser )
				//Tratamento para não repetir as filiais
				If aScan( aReturn, Alltrim( aBrUser[ nIndex ] ) ) == 0
					aAdd( aReturn, Alltrim( aBrUser[ nIndex ] ) )
				EndIf

			Next nIndex

		EndIf
	EndIf

Return aReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} GroupUser
Retorna os grupos do usuário e se tem acesso ao sigamnt

@param cUserChk, string, código do usuário
@author Maria Elisandra de Paula
@since 24/09/2019
@version P12
@return array, { [1]código do grupo, [2]se possui acesso ao 19 ou 95 }
/*/
//---------------------------------------------------------------------
Static Function GroupUser( cUserChk )

	Local nIndex   := 0
	Local aReturn  := {}
	Local aGroups  := FWSFUsrGrps( cUserChk ) //recupera os grupos do usuário - o primeiro grupo tem prioridade

	For nIndex := 1 to Len( aGroups )

		//FwGrpMenu - recupera os módulos do grupo
		aAdd( aReturn, { aGroups[ nIndex ], fCheckMod( FwGrpMenu( aGroups[ nIndex ] ) ) } )

	Next nIndex

Return aReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} fCheckMod
Indica se possui acesso ao sigamnt

@param aModulos, array, módulos configurados no sigacfg
@author Maria Elisandra de Paula
@since 24/09/2019
@version P12
@return boolean, se possui acesso ao modulo 19 ou 95
/*/
//---------------------------------------------------------------------
Static Function fCheckMod( aModulos )

	Local nPosMNT := Ascan( aModulos,{ | x | Left( x, 2 ) == '19' } ) // recupera a posição do módulo 19 - SIGAMNT
	Local nPosGFR := 0
	Local lChkMod := .F.

	If nPosMNT > 0
		lChkMod := SubStr( aModulos[ nPosMNT ], 3, 1 ) != 'X' // verifica se 19 está marcado ( 'X' é desmarcado )
	EndIf

	// Caso não possua acesso ao módulo SIGAMNT, verifica se existe o módulo 95 no ambiente
	If !lChkMod .And. ( nPosGFR := Ascan( aModulos,{ | x | Left( x, 2 ) == '95' } ) ) > 0 // recupera a posição do módulo 95 - SIGAGFR
		lChkMod := SubStr( aModulos[ nPosGFR ], 3, 1 ) != 'X' // verifica se 95 está marcado ( 'X' é desmarcado )
	EndIf

Return lChkMod

//---------------------------------------------------------------------
/*/{Protheus.doc} CheckEnvironment
Recupera informações do ambiente para utilização do MntNg

@author	Maria Elisandra de Paula
@since 14/12/2018
@param oWs, objeto, objeto rest
@return logic, indica se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function CheckEnvironment( oWs )

	Local aBranches   := {}
	Local aInfoLogin
	Local aEnterprise := {}
	Local nBranch     := 0
	Local cResponse   := ""
	Local cJsonResp   := ""

	StartStatics( oWs ) //inicializa variáveis static

	//--------------------------------
	//Recupera informações do usuário
	//--------------------------------
	aInfoLogin := GetInfoLogin( oWs:GetHeader('user'), oWs:GetHeader('password'), .T., oWs )
	If !aInfoLogin[1]
		Printf( aInfoLogin[2] )
		SetRestFault( 403, EncodeUtf8(aInfoLogin[2] ) )
		Return .F.
	Else
		aBranches := aInfoLogin[2]
	EndIf

	//------------------------------------------
	//carrega array aEnterprise:
	// [1] - enterprise
	// [2] - array de branches
	//------------------------------------------
	For nBranch := 1 to Len(aBranches)
		nScan := aScan( aEnterprise, {|x| x[1] == SubStr( aBranches[nBranch], 1, 2 ) } )

		If nScan > 0
			Aadd( aEnterprise[nScan,2], SubStr( aBranches[nBranch], 3 ) )
		Else
			aAdd( aEnterprise, { SubStr( aBranches[nBranch], 1, 2 ), { SubStr( aBranches[nBranch], 3, FWSizeFilial( SubStr( aBranches[nBranch], 1, 2 ) ) ) } } )
		EndIf
	Next nBranch

	If lMingle
		// Inicia nova thread para não alterar ambiente aberto pelo PrepareIn
		cJsonResp := StartJob( 'MNTNGCHECK', GetEnvserver(), .T., aEnterprise, ;
								{ lPortalOrigin, lDBOrderOk, lDBRequestOk, aPermissions } )
	Else
		cJsonResp := fGetEnvEnt( aEnterprise )
	EndIf

	cResponse := '{"enterprises":'+ cJsonResp + '}'

	oWs:SetStatus( 200 )
	oWs:SetResponse( FwhttpEncode(cResponse) )

	Printf( 'Check realizado' )

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTNGCHECK
Job que retorna filiais do usuário

@author	Maria Elisandra de Paula
@since 18/04/2022

@param aEnterprise, array, filiais para validação
@param aMainStatics, array, variáveis static
@return string, json de filiais
/*/
//---------------------------------------------------------------------
Function MNTNGCHECK( aEnterprise, aMainStatics )

	Local cJsonResp := ""

	lPortalOrigin      := aMainStatics[1]
	lDBOrderOk         := aMainStatics[2]
	lDBRequestOk       := aMainStatics[3]
	aPermissions       := aMainStatics[4]
	lMingle            := .T.

	cJsonResp := fGetEnvEnt( aEnterprise )

Return cJsonResp

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetEnvEnt
Validação de filiais do usuário

@author	Maria Elisandra de Paula
@since 18/04/2022

@param aEnterprise, array, filiais para validação
@return string, json de filiais
/*/
//---------------------------------------------------------------------
Static Function fGetEnvEnt( aEnterprise )

	Local oResponse
	Local aAuxiliar   := {}
	Local aResponse   := {}
	Local cEnterprise := ""
	Local nEnterprise := 0
	Local nBranch     := 0

	For nEnterprise := 1 to Len(aEnterprise)

		cEnterprise := aEnterprise[nEnterprise,1]
		aAuxiliar   := aEnterprise[nEnterprise,2]
		aBranches   := {}

		nBranch := 1

		// Abre Empresa/Filial
		If !ConfigEnv2( cEnterprise, aAuxiliar[nBranch] )
			Printf( "Configuracao do ambiente nao realizada para " + cEnterprise + aAuxiliar[nBranch] )
			loop
		EndIf

		oResponse := JsonObject():New()
		oResponse[ "code" ] := cEnterprise
		oResponse[ "name" ] := Alltrim( FWGrpName( cEnterprise ) )
		oResponse[ "requestDatabase" ] := lDBRequestOk
		oResponse[ "orderDatabase" ] := lDBOrderOk

		Aadd( aResponse, oResponse )

		fLogTab() // tabelas sem campos de usuário

	Next nEnterprise

Return FWJsonSerialize( aResponse, .F. )

//---------------------------------------------------------------------
/*/{Protheus.doc} fCheckBase
Verifica se o ambiente possui todos os campos necessários para o MNTNG

@author	Maria Elisandra de Paula
@since 18/12/2018
@param cCheck, string, indica qual verificação: 'order' or 'request' or all
@param lItemized, boolean, se deve retornar todas as tabelas inconsistentes
@return array, lista de tabelas inconsistentes
/*/
//---------------------------------------------------------------------
Static Function fCheckBase( cCheck, lItemized )

	Local aFieldName := {}
	Local nAlias     := 0
	Local aAlias     := {}
	Local aOrder     := { "A2","B1","B2","H4","T0","T1","T5","T6","TF","TG","TH","TP7","TPA","TPC","TPQ","TT9"}
	Local aRequest   := { "TQB", "TQ3", "TQ4", "HB" }
	Local aErrorList := {}
	Local cTable     := ""

	Default lItemized := .F.

	// Se utilizará ocorrencias
	// Obs: As requisições vindas do portal mobile não trafegam as permissões do usuário
	If cCheck != "request" .And. ( lPortalOrigin .Or. aPermissions[ PERMISS_OS, 18 ] ) // ocurrences
		aAdd( aOrder, 'T8' )
		aAdd( aOrder, 'TUS' )
		aAdd( aOrder, 'TQ5' )
	EndIf

	If cCheck == "order"

		aAlias := aClone( aOrder ) // Campos para ordem de serviço

	ElseIf cCheck == "request"

		aAlias := aClone( aRequest ) // Campos para solicitação de serviço

	ElseIf cCheck == "all"

		aAlias := aClone( aOrder )

		For nAlias := 1 to Len( aRequest )
			aAdd( aAlias, aRequest[ nAlias ] )
		Next nAlias

	EndIf

	//---------------------------------------------
	// Campos necessários para ordem e solicitação
	//---------------------------------------------
	aAdd( aAlias, "T9"  )
	aAdd( aAlias, "CTT" )
	aAdd( aAlias, "T4"  )
	aAdd( aAlias, "TD"  )
	aAdd( aAlias, "TJ"  )

	// Se utilizará localizações em O.S. ou S.S.
	// Obs: As requisições vindas do portal mobile não trafegam as permissões do usuário
	If lPortalOrigin                   .Or. ;
		aPermissions[ PERMISS_OS, 19 ] .Or. ; // location_order
		aPermissions[ PERMISS_SS, 6 ]         // location_ss
		aAdd( aAlias, "TAF" )
	EndIf

	For nAlias := 1 To Len( aAlias )

		cTable := aAlias[nAlias]

		If Len( aAlias[nAlias] ) == 3
			aFieldName := { "_USERGI","_USERGA" }
		Else
			aFieldName := { "_USERLGI","_USERLGA" }
			cTable := "S" + cTable
		EndIf

		//----------------------------------------
		// Verifica a existência dos campos
		//----------------------------------------
		dbSelectArea( cTable )
		If FieldPos( aAlias[nAlias] + aFieldName[1] ) == 0 .Or. ;
			FieldPos( aAlias[nAlias] + aFieldName[2] ) == 0

			aAdd( aErrorList, cTable )

			If !lItemized
				Exit
			EndIf

		EndIf
	Next nI

	aSort( aErrorList )

Return aErrorList

//---------------------------------------------------------------------
/*/{Protheus.doc} StartStatics
Inicializa variáveis statics

@param oWs, objeto, web service
@author	Maria Elisandra de Paula
@since 28/01/2019
@return nil
/*/
//---------------------------------------------------------------------
Static Function StartStatics( oWs )

	Local nIndex
	Local aOrder   := {}
	Local aRequest := {}
	Local nLenPerm := 0

	aETAPAS := {}
	aInputs := { { {}, {}, {} }, { {}, {}, {} } }
	cUserST1 := ""
	cUserTQ4 := ""
	cUserLog := ""
	lPortalOrigin      := ValType( oWS:GetHeader( 'source' ) ) == "C"  .And. oWS:GetHeader( 'source' ) == "portal"

	lOrderPermission   := .F.
	lRequestPermission := .F.
	lDBOrderOk         := .F.
	lDBRequestOk       := .F.
	aEquipment         := If( ValType( oWS:GetHeader( 'equipment' ) ) == "C", StrTokArr( oWS:GetHeader( 'equipment' ) , "|"), {} )
	lMingle            := ValType( oWS:GetHeader( 'mingle' ) ) == 'C' // Define que o processo está utilizando Mingle

	// Quando o processo é feito via Mingle o header não aceita _ (Underline),
	// realizado tratamento para o cenário substituindo o _ (Underline) por - (Hífen)
	If lMingle

		aOrder := { 'create-order-corr'   , 'create-order-prev',;
					'edit-order-corr'     , 'edit-order-prev',;
					'cancel-order'        , 'finish-order',;
					'prev-input-product'  , 'prev-input-thirdpart',;
					'prev-input-tool'     , 'prev-input-labor',;
					'prev-input-specialit', 'prev-checklist',;
					'done-input-product'  , 'done-input-thirdpart',;
					'done-input-tool'     , 'done-input-labor',;
					'done-checklist'      , 'occurrences',;
					'location-order'      }

		aRequest := { 'create-ss'    , 'edit-service-request',;
					  'distribute-ss' , 'finish-ss'          ,;
					  'generate-ss-os', 'location-ss'         }
	Else

		aOrder := { 'create_order_corr'   , 'create_order_prev',;
					'edit_order_corr'     , 'edit_order_prev',;
					'cancel_order'        , 'finish_order',;
					'prev_input_product'  , 'prev_input_thirdpart',;
					'prev_input_tool'     , 'prev_input_labor',;
					'prev_input_specialit', 'prev_checklist',;
					'done_input_product'  , 'done_input_thirdpart',;
					'done_input_tool'     , 'done_input_labor',;
					'done_checklist'      , 'occurrences',;
					'location_order';
					}

		aRequest := { 'create_ss'      , 'edit_service_request',;
					  'distribute_ss'  , 'finish_ss'           ,;
					  'generate_ss_os' ,'location_ss'}

	EndIf

	aPermissions := { Array( 19 ), Array( 6 ) }

	//----------------------------------------------------------------
	//Carrega o array aPermissions com permissões do grupo do usuário
	//----------------------------------------------------------------
	If !lPortalOrigin

		//--------------------------------
		// Permissões de O.S.
		//--------------------------------
		nLenPerm := Len(aOrder)

		For nIndex := 1 to Len( aPermissions[ PERMISS_OS ] )

			aPermissions[ PERMISS_OS, nIndex ] := nIndex <= nLenPerm                                   .And. ;
			                                      ValType( oWS:GetHeader( aOrder[ nIndex ] ) ) == "C"  .And. ;
												oWS:GetHeader( aOrder[ nIndex ] ) == "true"

			lOrderPermission := lOrderPermission .Or. aPermissions[ PERMISS_OS, nIndex ]

		Next nIndex

		//--------------------------------
		// Permissões de S.S.
		//--------------------------------
		nLenPerm := Len(aRequest)

		For nIndex := 1 to Len( aPermissions[ PERMISS_SS ] )

			aPermissions[ PERMISS_SS, nIndex ] := nIndex <= nLenPerm                                     .And. ;
			                                      ValType( oWS:GetHeader( aRequest[ nIndex ] ) ) == "C"  .And. ;
												oWS:GetHeader( aRequest[ nIndex ] ) == "true"

			lRequestPermission := lRequestPermission .Or. aPermissions[ PERMISS_SS, nIndex ]

		Next nIndex

	EndIf

	fLogMntng( 'lOrderPermission: ' + IIf( lOrderPermission, 'true', 'false') )
	fLogMntng( 'lRequestPermission: ' + IIf( lRequestPermission, 'true', 'false' ) )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} RequestIsOk
Validações para solicitações de serviço

@author	Maria Elisandra de Paula
@since 04/02/2019
@return logic, se possui configurações para ss no MNT NG
/*/
//---------------------------------------------------------------------
Static Function RequestIsOk( )

Return lDBRequestOk .And. ; //Campos de usuário estão configurados
	!( SuperGetMv( 'MV_NG1FAC', .F., '2') == '1' ) .And.; //Não é ambiente com facilities
	Len( GetApoInfo( "MNTSR.PRW" ) ) > 0 .And.; // Possui classe de SS compilada
	DictionaryIsOk() //Campos que eram obrigatórios estão corrigidos

//---------------------------------------------------------------------
/*/{Protheus.doc} ValidSync
Validações para sincronismo

@author	Maria Elisandra de Paula
@since 04/02/2019
@return string, descrição do erro
/*/
//---------------------------------------------------------------------
Static Function ValidSync( )

	Local cError := ""

	Do Case
	Case lPortalOrigin

		//-----------------------------------------------------------------
		// para portal somente campos de ordens são necessários
		//-----------------------------------------------------------------
		If !lDBOrderOk
			cError := STR0149 //"Os campos de usuário para ordens de serviço não estão configurados."
		EndIf

	Otherwise

		If !lRequestPermission .And. !lOrderPermission
			cError := STR0150 //"As permissões do grupo de usuário não estão definidas no portal mobile."
		Else
			//----------------------------------
			//pelo menos uma das opções está ok
			//----------------------------------
			If ( lOrderPermission .And. lDBOrderOk ) .Or. ( lRequestPermission .And. RequestIsOk() )
				cError := ""
			Else

				//-------------------------------------------------
				// trecho abaixo trata a mensagem para o usuário
				//-------------------------------------------------
				If lOrderPermission .And. !lDBOrderOk
					cError += STR0151 + ": " + CRLF + STR0152 + CRLF + CRLF //"Para ordens de serviço"# //"Configurar os campos de usuário"
				EndIf

				If lRequestPermission .And. !RequestIsOk( )
					cError += STR0153 + ":" + CRLF //"Para solicitações de serviço
					cError += ErrorForRequest( )

				EndIf

				cError := STR0154  + CRLF + CRLF + cError //"O ambiente não está devidamente configurado"
			EndIf
		EndIf
	EndCase
Return cError

//---------------------------------------------------------------------
/*/{Protheus.doc} ErrorForRequest
Retorna erro para operações de solicitações

@author	Maria Elisandra de Paula
@since 04/02/2019
@return string, descrição do erro
/*/
//---------------------------------------------------------------------
Static Function ErrorForRequest( )

	Local cError := ""

	If !lDBRequestOk
		cError += STR0152 + CRLF //"Configurar os campos de usuário"
	EndIf

	If Len( GetApoInfo("MNTSR.PRW") ) == 0
		cError += STR0155 + CRLF //"Atualizar o repositório (RPO)"
	EndIf

	If SuperGetMv( 'MV_NG1FAC', .F., '2') == '1'
		cError += STR0156 + CRLF //"Ajustar parâmetro 'MV_NG1FAC' para '2'"
	EndIf

	If !DictionaryIsOk()
		cError += "Aplicar o pacote de atualização do dicionário de dados" + CRLF
	EndIf

Return cError

//---------------------------------------------------------------------------
/*/{Protheus.doc} ConfigEnv2
Realiza configurações para empresa/filial e/ou usuário sem utilizar licença
@type function

@author	Maria Elisandra de Paula
@since 08/02/2019

@param  cEnterprise  , String, Código da empresa
@param  cBranch      , String, Código da filial
@param  cUserProtheus, String, Código do usuário para login protheus
@return Boolean      , Se houve a abertura da empresa/filial

@obs quando a empresa e filial não são definidas o usuário é obrigatórios,
nos casos onde o usuário não é definidos a empresa e filial são obrigatórios
/*/
//---------------------------------------------------------------------------
Static Function ConfigEnv2( cEnterprise, cBranch, cUserProtheus )

	Local cUser := cUserProtheus
	Local lRet := .T.

	//---------------------------------------------------------------------------------------------
	// Tratativa realizada para evitar uma falha crítica (error log - SX20 não existe)
	// ao executar o RPCSETENV passando o usuario de Administrador como parametro.
	// Por algum motivo nenhuma empresa/filial é encontrada para realizar a abertura do dicionario
	//---------------------------------------------------------------------------------------------
	If ValType( cUserProtheus ) == "C" .And. cUserProtheus == "Administrador"
		cUser := "Adm"
	EndIf

	Printf( 'Acesso a empresa/filial ' + cEnterprise + cBranch  )

	// Caso a empresa não tenha sido aberta ou for diferente da empresa a ser verificada
	// Limpa o ambiente, liberando a licença e fechando as conexões e abre um ambiente com a nova empresa
	If Type( 'cEmpAnt' ) == 'U' .Or. cEmpAnt != cEnterprise

		RpcClearEnv()
		RpcSetType( 3 ) // Sem utilizar licença
		If !Empty( cEnterprise ) .And. !Empty( cBranch )

			/*
				Realiza a abertura da empresa conforme enviado no parâmetro, para as chamadas onde já se tem o conhecimento
				da empresa e filial que serão utilizadas.
			*/
			lRet := RpcSetEnv( cEnterprise, cBranch, , , 'MNT', 'MNTNG' )

		Else

			/*
				A função abaixo não abre o ambiente, porém é necessário utilizá-la para que as filiais retornadas em FWLoadSM0
				sejam apenas as válidas para o usuário. Não sendo necessário passar o senha, pois o memso já encontra-se autenticado.
			*/
			lRet := RpcSetEnv( '', '', cUser, '', 'MNT', 'MNTNG' )

		EndIf

	ElseIf cFilAnt != cBranch
		// Caso empresa já esteja aberta, altera somente a filial.
		cFilAnt := cBranch
	EndIf

	If lRet
		lDBOrderOk   := Len( fCheckBase( "order" ) ) == 0
		lDBRequestOk := Len( fCheckBase( "request" ) ) == 0
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} DictionaryIsOk
Verifica se updDistri foi aplicado caso seja release 12.1.017
Obs.: Este pacote retira a obrigatoriedade de campos de solicitação de serviço.
Para versões superiores a 12.1.017 os campos já estão ajustados nativamente

@author	Maria Elisandra de Paula
@since 11/02/2019
@return string, descrição do erro
/*/
//---------------------------------------------------------------------
Static Function DictionaryIsOk()

	Local lRet := .T.

	//Os campos abaixo não devem ser obrigatórios pois não fazem parte da inclusão de SS
	If GetRPORelease() <= '12.1.017' .And.;
		( X3Obrigat("TQB_CDXEC") .Or.;
		X3Obrigat("TQB_DESCSO") .Or.;
		X3Obrigat("TQB_DTCANC") .Or.;
		X3Obrigat("TQB_DTFECH") .Or.;
		X3Obrigat("TQB_FUNEXE") .Or.;
		X3Obrigat("TQB_HOFECH") .Or.;
		X3Obrigat("TQB_HRCANC") .Or.;
		X3Obrigat("TQB_MECANC") .Or.;
		X3Obrigat("TQB_TEMPO") )

		lRet := .F.

	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} ProdMovest
Retorna o código do produto para movimentação de estoque

@author	Maria Elisandra de Paula
@since 31/07/2019
@param cCodigo, string, código do insumo
@param cTipoReg, string, tipo do insumo
@return string, código do produto
/*/
//---------------------------------------------------------------------
Static Function ProdMovest( cCodigo, cTipoReg )

	Local cRetProd := ''

	If cTipoReg == 'P'
		cRetProd := cCodigo
	ElseIf cTipoReg == 'T'
		cRetProd := PadR( NGProdMNT("T")[1], TamSx3( 'B1_COD' )[1] )
	ElseIf cTipoReg == 'M'
		If FindFunction( 'MntGetPrdM' )
			cRetProd := MntGetPrdM( cCodigo )
		Else
			dbSelectArea("ST1")
			dbSetOrder(1)
			dbSeek( xFilial( "ST1" ) + cCodigo )
			cRetProd := PadR( 'MOD' + ST1->T1_CCUSTO, TamSX3( 'B1_COD' )[1] )
		EndIf
	EndIf

Return cRetProd

//---------------------------------------------------------------------
/*/{Protheus.doc} WfFinish
Envio de WF de encerramento de OS quando está vinculada a uma SS

@author	Maria Elisandra de Paula
@since 01/08/2019
@param cOrderCode, string, Código da ordem de serviço finalizada
/*/
//---------------------------------------------------------------------
Static Function WfFinish( cOrderCode )

	If AllTrim( SuperGetMV( 'MV_NGSSWRK', .F., 'N' ) ) == 'S'

		dbSelectArea('STJ')
		dbSetOrder(1)
		dbSeek( xFilial('STJ') + cOrderCode )

		If AllTrim( SuperGetMV( 'MV_NGMULOS', .F., 'N' ) ) == 'S'
			dbSelectArea('TT7')
			dbSetOrder(2)
			If dbSeek( xFilial('TT7') + cOrderCode )
				dbSelectArea('TQB')
				dbSetOrder(1)
				If dbSeek( xFilial('TQB') + TT7->TT7_SOLICI )
					Printf( 'Enviando wf para solicitante - ' + TQB->TQB_CDSOLI )
					MNW29502( TQB->TQB_CDSOLI )
				EndIf
			EndIf
		Else
			dbSelectArea('TQB')
			dbSetOrder(4)
			If dbSeek( xFilial('TQB') + cOrderCode )
				Printf( 'Enviando wf para solicitante - ' + TQB->TQB_CDSOLI )
				MNW29502( TQB->TQB_CDSOLI )
			EndIf
		EndIf
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fDateValid
Valida data e hora da finalização

@author	Maria Elisandra de Paula
@since 03/10/2019
@param dDtMRIni, date, data real inicio
@param cHoMRIni, string, hora real inicio
@param dDtMRFim, date, data real fim
@param cHoMRFim, string, hora real fim
@return string, vazio ou descrição do erro
/*/
//---------------------------------------------------------------------
Static Function fDateValid( dDtMRIni, cHoMRIni, dDtMRFim, cHoMRFim )

	Local cError   := ""
	Local aDtHor   := Time2NextDay(IncTime( time(), 0, 5, 0), date())  //incrementa 5 minutos - tolerância
	Local cHrMais5 := DtoS( aDtHor[2] ) + aDtHor[1]

	//Valida data inicial com data final
	If Dtos( dDtMRIni ) + cHoMRIni > Dtos( dDtMRFim ) + cHoMRFim
		cError := STR0158 //"A data e hora fim da manutenção não pode ser maior que a data e hora inicial."
	EndIf

	//Valida data e/ou hora posterior ( soemnte por garantia pois o app já trata essas validações )
	If Empty( cError ) .And. ( Dtos( dDtMRIni ) + cHoMRIni ) > cHrMais5 .Or. ( Dtos( dDtMRFim ) + cHoMRFim ) > cHrMais5
		cError := STR0159 // "A data e hora real fim da manutenção não pode ser maior que a data e hora atual."
	EndIf

Return cError

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} GetUserCfg
Obtem o usuario cadastrado no sistema, no qual foi vinculado a um executante/funcionário.
@type function

@author	Alexandre Santos
@since 04/03/2020

@sample GetUserCfg( 'anitta@ngi.com.br' )

@param  cMail, Caracter, E-mail vinculado ao usuário.
@return Nil
/*/
//---------------------------------------------------------------------------------------
Static Function GetUserCfg( cMail )

	Local cAliasST1 := GetNextAlias()
	Local cAliasTQ4 := GetNextAlias()

	// Busca vínculo com funcionário da manutenção - ST1
	BeginSql Alias cAliasST1

		SELECT
			ST1.T1_CODFUNC
		FROM
			%table:ST1% ST1
		WHERE
			UPPER( ST1.T1_EMAIL ) = %exp:Upper( cMail )% AND
			ST1.T1_FILIAL = %xFilial:ST1% AND
			ST1.%NotDel%

	EndSql

	cUserST1 := IIf( ( cAliasST1 )->( !EoF() ), AllTrim( (cAliasST1)->T1_CODFUNC ), '' )

	(cAliasST1)->(dbCloseArea())

	// Busca vínculo com executante de solicitações - TP4
	BeginSql Alias cAliasTQ4

		SELECT
			TQ4.TQ4_CDEXEC
		FROM
			%table:TQ4% TQ4
		WHERE
			UPPER( TQ4.TQ4_EMAIL1 ) = %exp:Upper( cMail )% AND
			TQ4.TQ4_FILIAL = %xFilial:TQ4% AND
			TQ4.%NotDel%

	EndSql

	cUserTQ4 := IIf( (cAliasTQ4)->( !EoF() ), AllTrim( (cAliasTQ4)->TQ4_CDEXEC ), '' )

	(cAliasTQ4)->(dbCloseArea())

Return

//---------------------------------------------------------------------------------------
/*/{Protheus.doc} GetUserPsw
Obtem o usuario e senha de autenticação utilizado quando habilitado o método BASIC.
@type function

@author	Alexandre Santos
@since 04/03/2020

@sample GetUserPsw( oJson )

@param  oWs  , Object, Contuedo recebido na requisição.
@return Array, 	[1] - Usuário de autenticação.
				[2] - Senha para autenticação.

@obs Valor default de retorno deve ser como NIL, pois em sua utilização, quando não
configurado com security = 0 a função RpcSetEnv não deve receber contúdo nos
parâmetros 3 e 4.
/*/
//---------------------------------------------------------------------------------------
Static Function GetUserPsw( oWs )

	Local aReturn  	:= { Nil, Nil }
	Local cUserPsw 	:= ''
	Local cUser    	:= ''
	Local cPassword := ''
	Local nPoint    := 0

	If lHasSecurity

		cUserPsw  := Decode64( StrTran( oWs:GetHeader( 'authorization' ), 'BASIC ', '' ) )
		nPoint    := At( ':', cUserPsw )
		cUser     := Trim( SubStr( cUserPsw, 1, ( nPoint - 1 ) ) )
		cPassword := Trim( SubStr( cUserPsw, ( nPoint + 1 ) ) )

		aReturn := { cUser, cPassword }

	EndIf

Return aReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} fVersion
Verifica se versão é compatível com outra (por ex.: versão mínima)

@obs [1] Major
	[2] Minor
	[3] Patch
@author	Maria Elisandra de Paula
@since 13/04/2020
@param cVersion, string, version do app
@param [cCompare], string, versão para comparação
@return boolean, se está atualizado
/*/
//---------------------------------------------------------------------
Static Function fVersion( cVersion, cCompare )

	Local aVersionApp := StrTokArr( cVersion, "." )
	Local aVersionMin := {}

	Default cCompare := MINVERSIONAPP

	aVersionMin := StrTokArr( cCompare, "." ) // versão mínima exigida

	// Major do app é superior ao exigido
	If Val(aVersionApp[1]) > Val(aVersionMin[1])
		Return .T.
	EndIf

	// Major do app é a mesma da versão exigida
	If Val(aVersionApp[1]) == Val(aVersionMin[1])

		// Minor do app é superior ao exigido
		If Val(aVersionApp[2]) > Val(aVersionMin[2])
			Return .T.
		EndIf

		// Minor do app é igual ao exigido e patch é igual ou superior
		If Val(aVersionApp[2]) == Val(aVersionMin[2]) .And.;
			Val(aVersionApp[3]) >= Val(aVersionMin[3])
			Return .T.
		EndIf
	EndIf

Return .F.

//----------------------------------------------------------------------------------
/*/{Protheus.doc} QOccurrences
Query para Ocorrências.
@type function

@autor Alexandre Santos
@since 21/07/2020

@param cDate  , Caracter, Data da última sincronização.
@param cAlsST8, Caracter, Tabela utilizada para montagem do arquivo JSON.
@return
/*/
//----------------------------------------------------------------------------------
Static Function QOccurrences( cDate, cAlsST8 )

	Local cWhere  := "%ST8.D_E_L_E_T_ = ' '%"
	Local cField  := "%,'FALSE' AS BLOCKED%"
	Local lBlock  := NGCADICBASE( 'T8_MSBLQL', 'A', 'ST4', .F. )

	If cDate != '0'
		cWhere := '%('  + dateQuery( 'T8_USERLGA' ) + ' >= ' + ValToSQL( cDate ) + ' OR '
		cWhere +=         dateQuery( 'T8_USERLGI' ) + ' >= ' + ValToSQL( cDate ) + ' )%'
	EndIf

	If lBlock
		cField := "%,CASE "
		cField += 	" WHEN ST8.T8_MSBLQL = '1' THEN 'TRUE' "
		cField +=	" ELSE 'FALSE' END AS BLOCKED%"
	EndIf

	BeginSQL Alias cAlsST8

		SELECT
			ST8.T8_CODOCOR,
			ST8.T8_NOME   ,
			ST8.T8_TIPO   ,
			CASE
				WHEN ST8.D_E_L_E_T_ = ' ' THEN 'FALSE'
				ELSE 'TRUE' END AS IS_DELETED
			%exp:cField%
		FROM
			%table:ST8% ST8
		WHERE
			ST8.T8_FILIAL = %xFilial:ST8% AND
			%exp:cWhere%

	EndSQL

Return

//-----------------------------------------------------------------------------------------
/*/{Protheus.doc} sOccurrences
Gera um JSON contendo as informações de Ocorrências dos tipos Problema, Causa e Solução para
a sincronização com o aplicativo Mobile.
@type function

@author	Alexandre Santos
@since 21/07/2020

@param oWS   , Objeto  , Referência ao webservice.
@param cDate , Caracter, Data da última sincronização.
@return Array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//-----------------------------------------------------------------------------------------
Static Function sOccurrences( oWs, cDate )

	Local aFileName   := GenFileName( 'occurrences' )
	Local cHourIn     := Time()
	Local cSubJSON    := ''
	Local cAlsST8     := GetNextAlias()
	Local nCount      := 0
	Local nDelete     := FCreate( aFileName[ 1 ] )
	Local nUpdate     := FCreate( aFileName[ 2 ] )
	Local lFirstST8   := .T.
	Local lFirstD     := .T.

	If nDelete == -1 .Or. nUpdate == -1
		Return { .F., STR0017 + Space( 1 ) + Trim( Str( FError() ) ) } // Falha ao alocar memória:
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	// Seleciona ocorrências dos tipos PROBLEMA, CAUSA e SOLUÇÃO.
	QOccurrences( cDate, @cAlsST8 )

	Do While (cAlsST8)->( !EoF() )

		// INCLUIR e ALTERAR
		If Upper( (cAlsST8)->IS_DELETED ) == 'FALSE'

			cSubJSON    := ','

			If lFirstST8
				lFirstST8 := .F.
				cSubJSON  := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"code":"' + NGEscape( (cAlsST8)->T8_CODOCOR, .T. ) + '",'
			cSubJSON += '"name":"' + NGEscape( (cAlsST8)->T8_NOME   , .T. ) + '",'
			cSubJSON += '"type":"' + NGEscape( (cAlsST8)->T8_TIPO   , .T. ) + '"'

			If Upper( (cAlsST8)->BLOCKED ) != 'FALSE'
				cSubJSON += ',"blocked":true'
			EndIf

			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )

		// EXCLUIR
		Else

			cSubJSON := ','

			If lFirstD
				lFirstD  := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAlsST8)->T8_CODOCOR, .T. ) + '"'

			FWrite( nDelete, cSubJSON )

		EndIf

		nCount++

		(cAlsST8)->( dbSkip() )

	EndDo

	(cAlsST8)->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )

	printf( 'sOccurrences: ' + cValtoChar( nCount ) + ' em ' + ElapTime( cHourIn, Time() ) )

Return { .T., aFileName }

//----------------------------------------------------------------------------------
/*/{Protheus.doc} QExceptionFamily
Query para Excessões de Família para Ocorrências.
@type function

@autor Alexandre Santos
@since 21/07/2020

@param cDate  , Caracter, Data da última sincronização.
@param cAlsTUS, Caracter, Tabela utilizada para montagem do arquivo JSON.
@return
/*/
//----------------------------------------------------------------------------------
Static Function QExceptionFamily( cDate, cAlsTUS )

	Local cWhere  := "%TUS.D_E_L_E_T_ = ' '%"

	If cDate != '0'
		cWhere := '%('  + dateQuery( 'TUS_USERGA' ) + ' >= ' + ValToSQL( cDate ) + ' OR '
		cWhere +=         dateQuery( 'TUS_USERGI' ) + ' >= ' + ValToSQL( cDate ) + ' )%'
	EndIf

	BeginSQL Alias cAlsTUS

		SELECT
			TUS.TUS_CODOCO,
			TUS.TUS_FAMILI,
			CASE
				WHEN TUS.D_E_L_E_T_ = ' ' THEN 'FALSE'
				ELSE 'TRUE' END AS IS_DELETED
		FROM
			%table:TUS% TUS
		WHERE
			TUS.TUS_FILIAL = %xFilial:TUS% AND
			%exp:cWhere%

	EndSQL

Return

//----------------------------------------------------------------------------------
/*/{Protheus.doc} sExceptionFamily
Gera um JSON contendo as informações de Excessões de Família para a sincronização
com o aplicativo Mobile.
@type function

@author	Alexandre Santos
@since 21/07/2020

@param oWS   , Objeto  , Referência ao webservice.
@param cDate , Caracter, Data da última sincronização.
@return Array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//----------------------------------------------------------------------------------
Static Function sExceptionFamily( oWs, cDate )

	Local aFileName   := GenFileName( 'exceptionFamily' )
	Local cHourIn     := Time()
	Local cSubJSON    := ''
	Local cAlsTUS     := GetNextAlias()
	Local nCount      := 0
	Local nDelete     := FCreate( aFileName[ 1 ] )
	Local nUpdate     := FCreate( aFileName[ 2 ] )
	Local lFirstTUS   := .T.
	Local lFirstD     := .T.

	If nDelete == -1 .Or. nUpdate == -1
		Return { .F., STR0017 + Space( 1 ) + Trim( Str( FError() ) ) } // Falha ao alocar memória:
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	// Seleciona Excessões de Família para Ocorrências.
	QExceptionFamily( cDate, @cAlsTUS )

	Do While (cAlsTUS)->( !EoF() )

		// INCLUIR e ALTERAR
		If Upper( (cAlsTUS)->IS_DELETED ) == 'FALSE'

			cSubJSON := ','

			If lFirstTUS
				lFirstTUS := .F.
				cSubJSON  := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"occurrence":"' + NGEscape( (cAlsTUS)->TUS_CODOCO, .T. ) + '",'
			cSubJSON += '"family":"'     + NGEscape( (cAlsTUS)->TUS_FAMILI, .T. ) + '"'
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )

		// EXCLUIR
		Else

			cSubJSON := ','

			If lFirstD
				lFirstD  := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAlsTUS)->TUS_CODOCO, .T. ) + NGEscape( (cAlsTUS)->TUS_FAMILI, .T. ) + '"'

			FWrite( nDelete, cSubJSON )

		EndIf

		nCount++

		(cAlsTUS)->( dbSkip() )

	EndDo

	(cAlsTUS)->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )

	printf( 'sExceptionFamily: ' + cValtoChar( nCount ) + ' em ' + ElapTime( cHourIn, Time() ) )

Return { .T., aFileName }

//----------------------------------------------------------------------------------
/*/{Protheus.doc} QAssociated
Query para Associação entre Ocorrências.
@type function

@autor Alexandre Santos
@since 21/07/2020

@param cDate  , Caracter, Data da última sincronização.
@param cAlsTQ5, Caracter, Tabela utilizada para montagem do arquivo JSON.
@return
/*/
//----------------------------------------------------------------------------------
Static Function QAssociated( cDate, cAlsTQ5 )

	Local cWhere  := "%TQ5.D_E_L_E_T_ = ' '%"

	If cDate != '0'
		cWhere := '%('  + dateQuery( 'TQ5_USERGA' ) + ' >= ' + ValToSQL( cDate ) + ' OR '
		cWhere +=         dateQuery( 'TQ5_USERGI' ) + ' >= ' + ValToSQL( cDate ) + ' )%'
	EndIf

	BeginSQL Alias cAlsTQ5

		SELECT
			TQ5.TQ5_CODOCO,
			TQ5.TQ5_CODOCR,
			CASE
				WHEN TQ5.D_E_L_E_T_ = ' ' THEN 'FALSE'
				ELSE 'TRUE' END AS IS_DELETED
		FROM
			%table:TQ5% TQ5
		WHERE
			TQ5.TQ5_FILIAL = %xFilial:TQ5% AND
			%exp:cWhere%

	EndSQL

Return

//----------------------------------------------------------------------------------
/*/{Protheus.doc} sAssociated
Gera um JSON contendo as informações de Associação entre Ocorrências para a sincronização
com o aplicativo Mobile.
@type function

@author	Alexandre Santos
@since 21/07/2020

@param oWS   , Objeto  , Referência ao webservice.
@param cDate , Caracter, Data da última sincronização.
@return Array, [1] indica se obteve sucesso na operação,
               [2,1] nome do arquivo de delete,
			   [2,2] nome do arquivo de update
/*/
//----------------------------------------------------------------------------------
Static Function sAssociated( oWs, cDate )

	Local aFileName   := GenFileName( 'associated' )
	Local cHourIn     := Time()
	Local cSubJSON    := ''
	Local cAlsTQ5     := GetNextAlias()
	Local nCount      := 0
	Local nDelete     := FCreate( aFileName[ 1 ] )
	Local nUpdate     := FCreate( aFileName[ 2 ] )
	Local lFirstTQ5   := .T.
	Local lFirstD     := .T.

	If nDelete == -1 .Or. nUpdate == -1
		Return { .F., STR0017 + Space( 1 ) + Trim( Str( FError() ) ) } // Falha ao alocar memória:
	EndIf

	FWrite( nDelete, '[' )
	FWrite( nUpdate, '[' )

	// Seleciona ASSOCIAÇÃO entre ocorrências
	QAssociated( cDate, @cAlsTQ5 )

	Do While (cAlsTQ5)->( !EoF() )

		// INCLUIR e ALTERAR
		If Upper( (cAlsTQ5)->IS_DELETED ) == 'FALSE'

			cSubJSON := ','

			If lFirstTQ5
				lFirstTQ5 := .F.
				cSubJSON  := ''
			EndIf

			cSubJSON += '{'
			cSubJSON += '"occurrence":"' + NGEscape( (cAlsTQ5)->TQ5_CODOCO, .T. ) + '",'
			cSubJSON += '"associated":"' + NGEscape( (cAlsTQ5)->TQ5_CODOCR, .T. ) + '"'
			cSubJSON += '}'

			FWrite( nUpdate, cSubJSON )

		// EXCLUIR
		Else

			cSubJSON := ','

			If lFirstD
				lFirstD  := .F.
				cSubJSON := ''
			EndIf

			cSubJSON += '"' + NGEscape( (cAlsTQ5)->TQ5_CODOCO, .T. ) + NGEscape( (cAlsTQ5)->TQ5_CODOCR, .T. ) + '"'

			FWrite( nDelete, cSubJSON )

		EndIf

		nCount++

		(cAlsTQ5)->( dbSkip() )

	EndDo

	(cAlsTQ5)->( dbCloseArea() )

	FWrite( nDelete, ']' )
	FWrite( nUpdate, ']' )

	FClose( nDelete )
	FClose( nUpdate )

	printf( 'sAssociated: ' + cValtoChar( nCount ) + ' em ' + ElapTime( cHourIn, Time() ) )

Return { .T., aFileName }

//----------------------------------------------------------------------------------
/*/{Protheus.doc} InputSTN
Realiza gravação de ocorrências na tabela STN.
@type function

@author	Alexandre Santos
@since 27/07/2020

@param cFilSTN, string, Filial corrente para ocorrências
@param cOrder , string, Ordem de Serviço referente aos insumos.
@param cPlan  , string, Plano de Manutenção referente aos insumos.
@param cTask  , string, Tarefa do insumo relacionado as ocorrencias.
@param cSeque , string, Sequência de inclusão do insumo relacionado as ocorrencias.
@param aOccur , array , Lista com ocorrênciaspara gravação.
						[1] - Problema
						[2] - Causa
						[3] - Solução
						[4] - Observação
@return
/*/
//----------------------------------------------------------------------------------
Static Function InputSTN( cFilSTN, cOrder, cPlan, cTask, cSeque, aOccurrences )

	Local nOcc   := 0

	If !Empty( aOccurrences[_UPDATE_] )

		// Forma de facilitar a codificação e entendimento da matriz.
		aUpdate := aClone( aOccurrences[_UPDATE_] )

		// Gravação das ocorrências na tabela STN.
		For nOcc := 1 To Len( aUpdate )

			dbSelectArea( 'STN' )
			dbSetOrder( 1 ) // TN_FILIAL + TN_ORDEM + TN_PLANO + TN_TAREFA + TN_SEQRELA + TN_CODOCOR + TN_CAUSA + TN_SOLUCAO
			If msSeek( cFilSTN + cOrder + cPlan + cTask + cSeque + aUpdate[nOcc,_PROBLEM_] + aUpdate[nOcc,_KEYCAUSE_] +;
				aUpdate[nOcc,_KEYSOLUTION_] )

				printf( '  - Modificando ocorrencia: ' + Trim( cTask ) + '/' + Trim( cSeque ) )

				RecLock( 'STN', .F. )

					STN->TN_CAUSA   := aUpdate[nOcc,_CAUSE_]
					STN->TN_SOLUCAO := aUpdate[nOcc,_SOLUTION_]
					STN->TN_DESCRIC := aUpdate[nOcc,_OCCURNOTE_]

				STN->( MsUnLock() )

			Else

				// Caso não encontra para alteração, adiciona na lista de inclusão de ocorrências.
				aAdd( aOccurrences[_INSERT_], aUpdate[nOcc] )

			EndIf

		Next nOcc

	EndIf

	If !Empty( aOccurrences[_INSERT_] )

		// Forma de facilitar a codificação e entendimento da matriz.
		aInsert := aClone( aOccurrences[_INSERT_] )

		// Gravação das ocorrências na tabela STN.
		For nOcc := 1 To Len( aInsert )

			printf( '  - Incluindo ocorrencia: ' + Trim( cTask ) + '/' + Trim( cSeque ) + ' ( ' + cValtochar( nOcc ) + ' )' )

			RecLock( 'STN', .T. )

				STN->TN_FILIAL  := cFilSTN
				STN->TN_ORDEM   := cOrder
				STN->TN_PLANO   := cPlan
				STN->TN_TAREFA  := cTask
				STN->TN_SEQRELA := cSeque
				STN->TN_CODOCOR := aInsert[nOcc,_PROBLEM_]
				STN->TN_CAUSA   := aInsert[nOcc,_CAUSE_]
				STN->TN_SOLUCAO := aInsert[nOcc,_SOLUTION_]
				STN->TN_DESCRIC := aInsert[nOcc,_OCCURNOTE_]

			STN->( MsUnLock() )

		Next nOcc

	EndIf

	// Deleção de insumos
	If !Empty( aOccurrences[_DELETE_] )

		// Forma de facilitar a codificação e entendimento da matriz.
		aDelete := aClone( aOccurrences[_DELETE_] )

		For nOcc := 1 To Len( aDelete )

			dbSelectArea( 'STN' )
			dbSetOrder( 1 ) // TN_FILIAL + TN_ORDEM + TN_PLANO + TN_TAREFA + TN_SEQRELA + TN_CODOCOR + TN_CAUSA + TN_SOLUCAO
			If msSeek( cFilSTN + cOrder + cPlan + cTask + cSeque + aDelete[nOcc,_PROBLEM_] + aDelete[nOcc,_KEYCAUSE_] +;
				aDelete[nOcc,_KEYSOLUTION_] )

				printf( '  - Excluindo ocorrencia: ' + Trim( cTask ) + '/' + Trim( cSeque ) )

				RecLock( 'STN', .F. )
				dbDelete()
				STN->( MsUnLock() )

			EndIf

		Next nOcc

	EndIf

Return

//----------------------------------------------------------------------------------
/*/{Protheus.doc} GetOccurrences
Recupera uma lista co mas ocorrências recebidas do app.
@type function

@author	Alexandre Santos
@since 27/07/2020

@param oParser, Object , Objeto JSON contendo a lista de ocorrências enviadas pelo app.
@return Array , Matriz contendo três lista de ocorrências, separadas pelas operações de
inclusão, alteração e exclusão. Cada lista comporta pelas posições:
					[1] - Problema
					[2] - Causa
					[3] - Backup Causa
					[4] - Solução
					[5] - Backup Solução
					[6] - Observação
/*/
//----------------------------------------------------------------------------------
Static Function GetOccurrences( oParser )

	Local nIndex      := 0
	Local aOccurrTemp := {}

	aOccurrences := { {}, {}, {} }

	For nIndex := 1 To Len( oParser )

		aOccurrTemp := Array( 6 )

		// Define que o processo de controle de ocorrências encontra-se habilitado.
		aPermissions[ PERMISS_OS, 18 ] := .T.

		// TN_CODOCOR - Problema
		aOccurrTemp[_PROBLEM_] := oParser[nIndex]:problem

		// TN_CAUSA - Causa
		aOccurrTemp[_CAUSE_] := IIf( AttIsMemberOf( oParser[nIndex], 'cause' ), oParser[nIndex]:cause, Space( Len( STN->TN_CAUSA ) ) )

		// Backup TN_CAUSA
		aOccurrTemp[_KEYCAUSE_] := IIf( AttIsMemberOf( oParser[nIndex], 'keyCause' ), oParser[nIndex]:KeyCause, Space( Len( STN->TN_CAUSA ) ) )

		// TN_SOLUCAO - Solução
		aOccurrTemp[_SOLUTION_] := IIf( AttIsMemberOf( oParser[nIndex], 'solution' ), oParser[nIndex]:solution, Space( Len( STN->TN_SOLUCAO ) ) )

		// Backup TN_SOLUCAO
		aOccurrTemp[_KEYSOLUTION_] := IIf( AttIsMemberOf( oParser[nIndex], 'keySolution' ), oParser[nIndex]:KeySolution, Space( Len( STN->TN_SOLUCAO ) ) )

		// Observação
		aOccurrTemp[_OCCURNOTE_] := IIf( AttIsMemberOf( oParser[nIndex], 'note' ), oParser[nIndex]:note, '' )

		// Separa as ocorrências por operação as quais foram acionados.
		Do Case

			// Inclusão
			Case oParser[nIndex]:operation == 'C'

				aAdd( aOccurrences[_INSERT_], aOccurrTemp )

			// Alteração
			Case oParser[nIndex]:operation == 'U'

				aAdd( aOccurrences[_UPDATE_], aOccurrTemp )

			// Exclusão
			Case oParser[nIndex]:operation == 'D'

				aAdd( aOccurrences[_DELETE_], aOccurrTemp )

		EndCase

	Next nIndex

Return aOccurrences

//----------------------------------------------------------------------------------
/*/{Protheus.doc} DeleteRelation
Remove os relacionamento do insumos para efetivar a alteração ou deleção do insumo.
@type function

@author	Alexandre Santos
@since 14/10/2020

@param aTask, array, Lista de insumo em manipulação.
@return
/*/
//----------------------------------------------------------------------------------
Static Function DeleteRelation( aTask )

	Local lIntRM    := Trim( SuperGetMv( 'MV_NGINTER', .F., 'N' ) ) == 'M'
	Local lAglut    := Trim( SuperGetMv( 'MV_NGMNTAS', .F., '2' ) ) == '1'
	Local lUpdSld   := .T.
	Local nSizeISA  := TamSX3( 'TL_ITEMSA' )[1]
	Local nSizeNSA  := TamSX3( 'TL_NUMSA' )[1]

	// Variáveis seguindo o modelo do aHeader da rotina MNTA420.
	Local nPosType  := 2
	Local nPosCode  := 3
	Local nPosAmou  := 7
	Local nPosWare  := 12
	Local nPosRecNo := 14

	Default aTask   := {}

	If STL->TL_TIPOREG $ 'P/T'

		cCodPSC1 := STL->TL_CODIGO
		cCodPTer := ''

		If STL->TL_TIPOREG == 'T'

			// Ira verificar apenas o primeiro Produto Terceiro do parametro
			cCodPTer := IIf( FindFunction( 'NGProdMNT' ), NGProdMNT( 'T' )[1], Trim( GetMV( 'MV_PRODTER' ) ) )
			cCodPSC1 := cCodPTer + Space( Len( SB1->B1_COD ) - Len( cCodPTer ) )

		EndIf

		If STL->TL_TIPOREG == 'P'
			lUpdSld := aScan( aGetIns,{ |x|	Trim( x[nPosType] ) == Trim( STL->TL_TIPOREG ) .And. Trim( x[nPosCode] ) ==;
				Trim( STL->TL_CODIGO ) .And. Trim( x[nPosWare] ) == Trim( STL->TL_LOCAL ) .And. x[13] } ) == 0
		EndIf

		NGDELSC1PR( STJ->TJ_ORDEM, 'OS001', cCodPSC1, IIf( Empty( STL->TL_LOCAL ), NGSEEK( 'SB1', cCodPTer, 1, 'B1_LOCPAD' ), STL->TL_LOCAL ),;
			STL->TL_QUANTID, lUpdSld, lUpdSld, { STL->TL_NUMSC + STL->TL_ITEMSC, 1 }, "SC1->C1_FILIAL == '" + xFilial( 'SC1' ) +;
			"' .And. SC1->C1_NUM == '" + STL->TL_NUMSC + "' .And. SC1->C1_ITEM == '" + STL->TL_ITEMSC + "'" )

		RecLock( 'STL', .F. )
			STL->TL_NUMSC  := Space( Len( SC1->C1_NUM ) )
			STL->TL_ITEMSC := Space( Len( SC1->C1_ITEM ) )
		STL->( MsUnLock() )

		GERAOPNEW( cCodPSC1, STL->TL_QUANTID, STJ->TJ_ORDEM, , , , , , , 5 )

	EndIf

	// Deleção de solicitação de armazém
	If NG420CHKSA( STL->TL_TIPOREG )

		dbSelectArea( 'SCP' )
		dbSetOrder( 1 )
		If msSeek( xFilial( 'SCP' ) + STL->TL_NUMSA + STL->TL_ITEMSA ) .And. SCP->CP_QUJE <= 0 .And. SCP->CP_PREREQU != 'S' .And.;
			fVldAltSA( STL->( RecNo() ), aGetIns, nPosRecNo, nPosAmou, nPosCode, nPosWare )

			If lIntRM

				// S.A. agluinada
				If lAglut

					If NGMUReques( SCP->( RecNo() ), 'SCP', .F., 5 )

						dbSelectArea( "SCP" )
						dbSetOrder( 1 )
						If msSeek( xFilial( 'SCP' ) + STL->TL_NUMSA  )

							Do While SCP->( !EoF() ) .And. SCP->CP_NUM == STL->TL_NUMSA

								If SCP->CP_PREREQU != 'S'

									// Realiza exclusão da S.A. e seus relacionamentos ( SCR ).
									IIf( FindFunction( 'MntDelReq' ), MntDelReq( SCP->CP_NUM, SCP->CP_ITEM, 'SA', .T. ), NGDELETAREG( 'SCP' ) )

									// Limpa valores da requisição do array de insumos.
									If !Empty( aTask ) .And. ( !Empty( aTask[_WHREQUEST_] ) .Or. !Empty( aTask[_WHITEM_] ) )

										aTask[_WHREQUEST_] := Space( nSizeNSA )
										aTask[_WHITEM_]    := Space( nSizeISA )

									EndIf

								EndIf

								SCP->( dbSkip() )

							EndDo

						EndIf

					EndIf

				// S.A. não aglutinada
				Else

					If NGMUReques( SCP->( RecNo() ), 'SCP', .F., 5 )

						// Realiza exclusão da S.A. e seus relacionamentos ( SCR ).
						IIf( FindFunction( 'MntDelReq' ), MntDelReq( SCP->CP_NUM, SCP->CP_ITEM, 'SA', .T. ), NGDELETAREG( 'SCP' ) )

						// Limpa valores da requisição do array de insumos.
						If !Empty( aTask ) .And. ( !Empty( aTask[_WHREQUEST_] ) .Or. !Empty( aTask[_WHITEM_] ) )

							aTask[_WHREQUEST_] := Space( nSizeNSA )
							aTask[_WHITEM_]    := Space( nSizeISA )

						EndIf

					EndIf

				EndIf

			Else

				// Realiza exclusão da S.A. e seus relacionamentos ( SCR ).
				IIf( FindFunction( 'MntDelReq' ), MntDelReq( SCP->CP_NUM, SCP->CP_ITEM, 'SA', .T. ), NGDELETAREG( 'SCP' ) )

				// Limpa valores da requisição do array de insumos.
				If !Empty( aTask ) .And. ( !Empty( aTask[_WHREQUEST_] ) .Or. !Empty( aTask[_WHITEM_] ) )

					aTask[_WHREQUEST_] := Space( nSizeNSA )
					aTask[_WHITEM_]    := Space( nSizeISA )

				EndIf

			EndIf

		EndIf

	EndIf

	// Deleção de bloqueio de ferramentas
	If STL->TL_TIPOREG == 'F'

		dbSelectArea( 'SH9' )
		dbSetOrder( 3 ) // H9_FILIAL + H9_TIPO + H9_FERRAM + H9_DTINI + H9_HRINI
		If msSeek( xFilial( 'SH9' ) + 'F' + SubStr( STL->TL_CODIGO, 1, Len( SH9->H9_FERRAM ) ) + dToS( STL->TL_DTINICI ) +;
			STL->TL_HOINICI )

			printf( ' - Deleta bloqueios de Ferramentas' )

			If AliasInDic( 'SGT' )

				dbSelectArea( 'SGT' )
				dbSetOrder( 1 )
				If msSeek( xFilial( 'SGT' ) + SH9->H9_TIPO + SH9->H9_CCUSTO + SH9->H9_RECURSO + dToS( SH9->H9_DTINI ) +;
					SH9->H9_HRINI )

					RecLock( 'SGT', .F. )
					dbDelete()
					SGT->( MsUnLock() )

				EndIf

			EndIf

			RecLock( 'SH9', .F. )
			dbDelete()
			SH9->( MsUnLock() )

		EndIf

	EndIf

	// Deleção do bloqueio de especialidade.
	dbSelectArea( 'TTY' )
	dbSetOrder( 1 ) // TTY_FILIAL + TTY_ORDEM + TTY_PLANO + TTY_TAREFA + TTY_CODESP + TTY_DTINI + TTY_HRINI
	If msSeek( xFilial( 'TTY' ) + STJ->TJ_ORDEM + STJ->TJ_PLANO + STL->TL_TAREFA + STL->TL_CODIGO + dToS( STL->TL_DTINICI ) +;
		STL->TL_HOINICI )

		printf( ' - Deleta bloqueios de especialidade' )
		RecLock( 'TTY', .F. )
		dbDelete()
		TTY->( MsUnLock() )

	EndIf

	// Deleção do bloqueio de funcionário.
	dbSelectArea( 'STK' )
	dbSetOrder( 1 ) // TK_FILIAL + TK_ORDEM + TK_PLANO + TK_TAREFA + TK_CODFUNC + TK_DATAINI + TK_HORAINI
	If msSeek( xFilial( 'STK' ) + STJ->TJ_ORDEM + STJ->TJ_PLANO + STL->TL_TAREFA + PadR( STL->TL_CODIGO, Len( STK->TK_CODFUNC ) ) +;
		dToS( STL->TL_DTINICI ) + STL->TL_HOINICI )

		printf( ' - Deleta bloqueio de Funcionario' )
		RecLock( 'STK', .F. )
		dbDelete()
		STK->( MsUnLock() )

	EndIf

	// Deleta todos os Problemas antes de refazer os bloqueios de bens e insumos
	dbSelectArea( 'STA' )
	dbSetOrder( 1 ) // TA_FILIAL + TA_ORDEM + TA_PLANO + TA_TAREFA + TA_TIPOREG + TA_CODIGO + TA_DESCRIC
	If msSeek( xFilial( 'STA' ) + STJ->TJ_ORDEM + STJ->TJ_PLANO + STL->TL_TAREFA + STL->TL_TIPOREG + PadR( STL->TL_CODIGO,;
		Len( STA->TA_CODIGO ) ) )

		Do While STA->( !EoF() ) .And. STA->TA_ORDEM == STJ->TJ_ORDEM .And. STA->TA_PLANO == STJ->TJ_PLANO .And.;
			STA->TA_TAREFA == STL->TL_TAREFA .And. STA->TA_TIPOREG == STL->TL_TIPOREG .And. STA->TA_CODIGO == PadR( STL->TL_CODIGO,;
			Len( STA->TA_CODIGO ) )

			printf( " - Deletando registro de problema: ' " + Trim( STA->TA_DESCRIC ) + " ' referente ao bloqueio do insumo" )
			RecLock( 'STA', .F. )
			dbDelete()
			STA->( MsUnLock() )

			STA->( dbSkip() )

		EndDo

	EndIf

Return

//----------------------------------------------------------------------------------
/*/{Protheus.doc} RevMovSto
Realiza estorno de movimentação no estoque referente ao insumo.
@type function

@author	Alexandre Santos
@since 19/10/2020

@param
@return string, Mensagem de erro caso exista.
/*/
//----------------------------------------------------------------------------------
Static Function RevMovSto( )

	Local cError     := ''
	Local xRetMovEst := Nil

	If !Empty( STL->TL_NUMSEQ )

	    dbSelectArea( 'SD3' )
	    dbSetOrder( 4 )
	    If msSeek( xFilial( 'SD3' ) + STL->TL_NUMSEQ ) .And. SD3->D3_ESTORNO != 'S'

			printf( '  - Gerando estorno do insumo realizado: ' + Trim( STL->TL_TAREFA ) + '/' + Trim( STL->TL_CODIGO ) +;
				' (' + cValToChar( STL->TL_QUANTID ) + ')' )

			xRetMovEst := MntMovEst( 'RE0', STL->TL_LOCAL, ProdMovest( STL->TL_CODIGO, STL->TL_TIPOREG ), STL->TL_QUANTID,;
				SD3->D3_EMISSAO, SD3->D3_DOC, , '', .T., STL->TL_NUMSEQ, , , , , , , , .T. )

			// Tratamento para chamada função com retorno desatualizado
			If Valtype( xRetMovEst ) == 'A' .And. !xRetMovEst[1]
				cError := STR0157 + CRLF + xRetMovEst[2] //"Problema no estorno de produto ao alterar/excluir insumo realizado. "
			ElseIf Valtype( xRetMovEst ) == 'C' .And. Empty( xRetMovEst )
				cError := STR0157 //"Problema no estorno de produto ao alterar/excluir insumo realizado. "
			ElseIf NGPRODESP( SD3->D3_COD, .F., 'M' )
	            NGAtuErp( 'SD3', 'INSERT' )
	        EndIf

		EndIf

	EndIf

Return cError

//---------------------------------------------------------------------
/*/{Protheus.doc} checkSA
Carrega os campos de S.A. no array de aInputs
@type function

@author	Alexandre Santos
@since 09/12/2020

@param  cOrder    , string, Número da ordem de serviço.
@param  cPlan     , string, Plano de manutenção.
@param  aInputTemp, array , Detalhes do insumo
@param  cOperat   , string, Operação em processo podendo ser UPDATE ou DELETE.

@return string, mensagem de erro caso houver.
/*/
//---------------------------------------------------------------------
Static Function checkSA( cOrder, cPlan, aInputTemp, cOperat )

	Local aAreaSCP  := SCP->( GetArea() )
	Local aAreaSTL  := STL->( GetArea() )
	Local cError    := ''

	dbSelectArea( 'STL' )
	dbSetOrder( 1 ) // TL_FILIAL + TL_ORDEM + TL_PLANO + TL_TAREFA + TL_TIPOREG + TL_CODIGO + TL_SEQRELA + TL_SEQTARE
	If dbSeek( xFilial( 'STL' ) + cOrder + cPlan + aInputTemp[_KEYTASK_] + aInputTemp[_TYPE_] + aInputTemp[_KEYCODE_] +;
		PadR( '0', TamSX3( 'TL_SEQRELA' )[1] ) + aInputTemp[_SEQTASK_] ) .And. !Empty( STL->TL_NUMSA )

		dbSelectArea( 'SCP' )
		dbSetOrder( 1 ) // CP_FILIAL + CP_NUM + CP_ITEM + CP_LOCAL
		If dbSeek( xFilial( 'SCP' ) + STL->TL_NUMSA + STL->TL_ITEMSA ) .And. !Empty( SCP->CP_PREREQU )

			// Impede deleção de S.A. com pré-requisição
			If cOperat == 'D'

				/*
					O insumo do tipo X XXXXXXXX com quantidade: XX e tarefa XXXXXX não pode ser excluído da ordem de
					serviço pois está vinculado a uma movimentação interna do estoque.
				*/
				cError := STR0087 + ' ' + NGRetSX3Box( 'TL_TIPOREG', STL->TL_TIPOREG ) + ' ' + Trim( STL->TL_CODIGO ) +;
					' ' + STR0088 + ' ' + cValToChar( STL->TL_QUANTID ) + ' ' + STR0089 + ' ' + Trim( STL->TL_TAREFA ) +;
					STR0162

			ElseIf cOperat == 'U'

				// Impede alteração de campos chave na S.A.
				If aInputTemp[_AMOUNT_] != SCP->CP_QUANT .Or. aInputTemp[_WAREHOUSE_] != SCP->CP_LOCAL

					/*
						O insumo do tipo X XXXXXXXX com quantidade: XX e tarefa XXXXXX não pode ser alterado da ordem de
						serviço pois está vinculado a uma movimentação interna do estoque.
					*/
					cError := STR0087 + ' ' + NGRetSX3Box( 'TL_TIPOREG', STL->TL_TIPOREG ) + ' ' + Trim( STL->TL_CODIGO ) +;
						' ' + STR0088 + ' ' + cValToChar( STL->TL_QUANTID ) + ' ' + STR0089 + ' ' + Trim( STL->TL_TAREFA ) +;
						STR0090

				// Grava valores da S.A. no array aInputTemp
				Else

					aInputTemp[_WHREQUEST_] := STL->TL_NUMSA
					aInputTemp[_WHITEM_]    := STL->TL_ITEMSA

				EndIf

			EndIf

		// Grava valores da S.A. no array aInputTemp
		Else

			aInputTemp[_WHREQUEST_] := STL->TL_NUMSA
			aInputTemp[_WHITEM_]    := STL->TL_ITEMSA

		EndIf

	EndIf

	RestArea( aAreaSTL )
	RestArea( aAreaSCP )

Return cError

//-----------------------------------------------------------------------
/*/{Protheus.doc} fcheckEquip
Valida inconsistências no cadastro do equipamento selecionado para a O.S.
@type function

@author Alexandre Santos
@since 23/12/2020

@param cCode   , string, Código do equipamento.
@param cError  , string, Variavél para tratamento e retorno de erro.

@return boolean, Indica se foi identificado alguma inconsisência no
cadastro do equipamento.
/*/
//-----------------------------------------------------------------------
Static Function fcheckEquip( cCode, cError )

	Local lReturn  := .T.
	Local aAreaST9 := ST9->( GetArea() )
	Local aAreaAll := GetArea()

	dbSelectArea( 'ST9' )
	dbSetOrder( 1 )
	If dbSeek( xFilial( 'ST9' ) + cCode )

		If ST9->T9_SITBEM == 'I'

			/*
				Este bem encontra-se inativo.
				Realize um novo sincronismo para atualizar os dados do aplicativo.
			*/
			cError  := STR0167 + STR0170
			lReturn := .F.

		ElseIf ST9->T9_SITBEM == 'T'

			/*
				Este bem encontra-se em outra filial devido a uma tranferência.
				Realize um novo sincronismo para atualizar os dados do aplicativo.
			*/
			cError  := STR0168 + STR0170
			lReturn := .F.

		EndIf

	Else

		/*
			Código não localizado no cadastro de bens.
			Realize um novo sincronismo para atualizar os dados de seu aplicativo.
		*/
		cError  := STR0169 + STR0170
		lReturn := .F.

	EndIf

	RestArea( aAreaAll )
	RestArea( aAreaST9 )

Return lReturn

//-----------------------------------------------------------------------
/*/{Protheus.doc} fcheckMain
Valida inconsistências no cadastro de manutenção selecionada para a O.S.
@type function

@author Alexandre Santos
@since 13/01/2020

@param cCode   , string, Código da manutenção.
@param cServ   , string, Código da serviço.
@param cSeq    , string, Sequência da manutenção.
@param cError  , string, Variavél para tratamento e retorno de erro.

@return boolean, Indica se foi identificado alguma inconsisência no
cadastro do manutenção.
/*/
//-----------------------------------------------------------------------
Static Function fcheckMain( cCode, cServ, cSeq, cError )

	Local lReturn  := .T.
	Local aAreaSTF := STF->( GetArea() )
	Local aAreaST9 := ST9->( GetArea() )
	Local aAreaAll := GetArea()

	dbSelectArea( 'ST9' )
	dbSetOrder( 1 ) // T9_FILIAL + T9_CODBEM
	If dbSeek( xFilial( 'ST9' ) + cCode )

		If ST9->T9_SITMAN == 'I'

			/*
				Este bem encontra-se inativo para o processo de manutenção.
				Realize um novo sincronismo para atualizar os dados do aplicativo.
			*/
	   		cError  := STR0175 + STR0170
	   		lReturn := .F.

		Else

			dbSelectArea( 'STF' )
			dbSetOrder( 1 ) // TF_FILIAL + TF_CODBEM + TF_SERVICO + TF_SEQRELA
			If dbSeek( xFilial( 'STF' ) + cCode + cServ + cSeq )

				If STF->TF_ATIVO == 'N'

					/*
						Esta manutenção encontra-se inativa.
						Realize um novo sincronismo para atualizar os dados do aplicativo.
					*/
					cError  := STR0173 + STR0170
					lReturn := .F.

				EndIf

			Else

				/*
					Código não localizado no cadastro de manutenção.
					Realize um novo sincronismo para atualizar os dados de seu aplicativo.
				*/
				cError  := STR0174 + STR0170
				lReturn := .F.

			EndIf

		EndIf

	EndIf

	RestArea( aAreaAll )
	RestArea( aAreaST9 )
	RestArea( aAreaSTF )

Return lReturn

//-----------------------------------------------------------------------
/*/{Protheus.doc} fseqTask
Gera valor para o campo TL_SEQTARE quando o insumo é incluso pelo APP.
@type function

@author Alexandre Santos
@since 21/01/2021

@param cOrder  , string, Ordem de serviço.
@param cPlan   , string, Plano de manutenção.
@param cSeqTask, string, Númeração para incremento.

@return string, Valor a ser gravado no campo TL_SEQTARE.
/*/
//-----------------------------------------------------------------------
Static Function fseqTask( cOrder, cPlan, cSeqTask )

	Local cAlsSTL    := GetNextAlias()

	Default cOrder   := ''
	Default cPlan    := ''
	Default cSeqTask := ''

	BeginSQL Alias cAlsSTL

		SELECT TL_SEQTARE FROM %table:STL% WHERE TL_ORDEM = %exp:cOrder% AND TL_PLANO = %exp:cPlan% AND TL_FILIAL = %xFilial:STL% AND %NotDel% ORDER BY TL_SEQTARE DESC

	EndSQL

	cSeqTask := Soma1( IIf( (cAlsSTL)->( !EoF() ), (cAlsSTL)->TL_SEQTARE, cSeqTask ) )

	(cAlsSTL)->( dbCloseArea() )

Return cSeqTask

//-----------------------------------------------------------------------
/*/{Protheus.doc} GeraTemp
Gera uma tabela temporária

@author Maria Elisandra de Paula
@since 20/05/21
@param cQuery, string, consulta a ser executada
@param cEntity, string, arquivo em execução
@return string, alias da temporária
/*/
//-----------------------------------------------------------------------
Static Function GeraTemp( cQuery, cEntity )

	Local cTemp := GetNextAlias()

	dbUseArea( .T., "TOPCONN", TCGenQry( Nil, Nil, cQuery ), cTemp, .T., .T. )

	fLogMntng( cEntity + ': ' + cQuery )

Return cTemp

//-----------------------------------------------------------------------
/*/{Protheus.doc} fLogTab
Verifica tabelas sem campos de usuário

@author Maria Elisandra de Paula
@since 13/09/21
@return nil
/*/
//-----------------------------------------------------------------------
Static Function fLogTab()

	Local cLog   := ''
	Local aCheck := {}
	Local nIndex := 0

	If lPeMntLog .And. ( !lDBOrderOk .Or. !lDBRequestOk )

		aCheck := fCheckBase( 'all', .T. )
		For nIndex := 1 To Len( aCheck )
			cLog += aCheck[nIndex] + '  '
		Next nIndex
		fLogMntng( 'Emp.: ' + cEmpAnt + ' - tabelas sem campos de usuario: ' + cLog )
	EndIf

Return

//-------------------------------------------------------------------------------------------
/*/{Protheus.doc} fLogUser
Gera logs de usuário

@author Maria Elisandra de Paula
@since 13/09/21
@param lFilterByUser, boolean, flag filtro somente OS de usuário configurada
@param lFilterUserSS, boolean, flag filtro somente SS de usuário configurada
@param lSpeciality, boolean, flag filtro somente especialidade de usuário configurada
@return nil
/*/
//-------------------------------------------------------------------------------------------
Static Function fLogUser( lFilterByUser, lFilterUserSS, lSpeciality )

	If lPeMntLog
		fLogMntng( 'Somente OS relacionada: ' + IIf( lFilterByUser, 'true', 'false' )  )
		fLogMntng( 'Somente SS relacionada: ' + IIf( lFilterUserSS, 'true', 'false' )  )
		fLogMntng( 'Somente especialidade : ' + IIf( lSpeciality, 'true', 'false' )  )
		fLogMntng( 'cUserST1 : ' + cUserST1  )
		fLogMntng( 'cUserTQ4 : ' + cUserTQ4  )
		fLogMntng( '__cUserID: ' + IIf( Type('__cUserID') == 'C', __cUserID, 'Nulo' ) )
	EndIf 

Return

//-----------------------------------------------------------------------
/*/{Protheus.doc} fLogMntng
Gera logs adicionais para análise

@author Maria Elisandra de Paula
@since 13/09/21
@param cLog, string, mensagem a imprimir
@return nil
/*/
//-----------------------------------------------------------------------
Static Function fLogMntng( cLog )

	If lPeMntLog
		Printf( cLog )
	EndIf

Return

//-----------------------------------------------------------------------
/*/{Protheus.doc} fGetBinImg
Decode de imagens

@author Maria Elisandra de Paula
@since 18/04/2022
@param oWS, object, instância do ws
@return array [1]descrição do erro
			  [2]imagem decodificada
/*/
//-----------------------------------------------------------------------
Static Function fGetBinImg( oWS )

	Local cBinImagem := ''
	Local cError     := ''
	Local oJson

	If lMingle
		oJson  := JsonObject():New()
		cError := oJson:FromJson( oWS:GetContent() )
		If Empty(cError)
			cBinImagem := oJson['image']  // Para requisições oriundas do Mingle, a imagem será trafegada na chave 'image'
		EndIf
		FreeObj( oJson )
	Else
		cBinImagem := oWS:GetContent()
	EndIf

	cBinImagem := Decode64(cBinImagem)

Return { cError, cBinImagem }

//-----------------------------------------------------------------------
/*/{Protheus.doc} fIgnoreEnt
Busca grupo de empresas que devem ser ignoradas

@param oWs, objeto, instância do ws
@author Maria Elisandra de Paula
@since 20/01/22
@param oWs, objeto, instancia do ws
@return array, empresas que devem ser ignoradas
/*/
//-----------------------------------------------------------------------
Static Function fIgnoreEnt(oWs)

	Local aReturn := {}
	Local xIgnore

	If lPeMntNg
		//------------------------------------------------------------------
		// ID do PE para filtrar as empresas que não devem carregar no app 
		//------------------------------------------------------------------
		xIgnore := ExecBlock("MNTNG",.F.,.F.,{"COMPANY_GROUP_IGNORE", oWs})
		If !Empty(xIgnore)
			aReturn := xIgnore
		EndIf
	EndIf

Return aReturn

//---------------------------------------------------------------------
/*/{Protheus.doc} NGEscape
Tratamento de strings para a geração do JSON

@author Maria Elisandra de Paula
@since 16/05/2022

@param cStr, string , texto que deve ser manipulado.
@param [lUTF8], boolean, se deve converter o texto para UTF-8.  
@return string
/*/
//---------------------------------------------------------------------
Static Function NGEscape( cStr, lUtf8 )

    Default lUtf8 := .f.

	If lUtf8
		cStr := fTEncoUtf8( cStr )
	Else
		cStr := fEscapaStr( cStr )
	EndIf

Return cStr

//---------------------------------------------------------------------
/*/{Protheus.doc} fEscapaStr
Substitui caracteres que não podem estar contidos no arquivo json

@author Maria Elisandra de Paula
@since 16/05/2022
@param cStr, string , texto que deve ser manipulado
@return string
/*/
//---------------------------------------------------------------------
Static Function fEscapaStr( cStr ) 

	If cStr != Nil

		// substitui caracteres inválidos por espaço
		cStr := StrTran( cStr, CHR(129), ' ')
		cStr := StrTran( cStr, CHR(141), ' ')
		cStr := StrTran( cStr, CHR(143), ' ')
		cStr := StrTran( cStr, CHR(144), ' ')
		cStr := StrTran( cStr, CHR(157), ' ')

		// escape de caracteres válidos
		cStr := StrTran( cStr, '\', '\\' )
		cStr := StrTran( cStr, '"', '\"' )
		cStr := StrTran( cStr, CHR( 13 ) + CHR( 10 ), '\n' )
		cStr := StrTran( cStr, CHR( 10 ), '\n' )
		cStr := StrTran( cStr, CHR( 13 ), '\n' )
		cStr := Alltrim( cStr )

	Else 
		cStr := ' '
	EndIf

Return cStr

//---------------------------------------------------------------------
/*/{Protheus.doc} fTEncoUtf8
Escape de string, conversão para encode-Utf8 
e realiza tratamento caso tenha problema

@author Maria Elisandra de Paula
@since 13/05/2022
@param cStr, string, texto que deve ser manipulado
@return string com tratamento
/*/
//---------------------------------------------------------------------
Static Function fTEncoUtf8( cStr )

    Local cStrBkp := cStr

	If cStr != Nil .And. !Empty( cStr )

		cStr := EncodeUtf8( fEscapaStr( cStrBkp ) )

		If cStr == Nil .Or. Empty( cStr ) 
			cSTr := fTrataStr( cStrBkp )
			cStr := EncodeUtf8( fEscapaStr( cSTr ) )
		EndIf

	EndIf

    If cStr == Nil
        cStr := ' '
    EndIf

Return cStr

//---------------------------------------------------------------------
/*/{Protheus.doc} fTrataStr
Tratamento de texto com erro ao converter para utf-8

@author Maria Elisandra de Paula
@since 13/05/2022
@param cStr, string, texto que deve ser manipulado
@return string com tratamento
/*/
//---------------------------------------------------------------------
Static Function fTrataStr( cStr )

	Local cConvertid := ''
	Local cRetorno   := ''
	Local cTesta100  := ''
	Local nInicio    := 1
	Local nTam       := Len( cStr )

	While( nInicio <= nTam )

		cTesta100  := Substr( cStr, nInicio, 100 ) 
		cConvertid := EncodeUtf8( cTesta100 )

		If cConvertid == Nil
			cConvertid := fTrataChar( cTesta100 ) // substitui caracter com problema para ' '
		EndIf

		cRetorno += cConvertid
		nInicio += 100

	EndDo

Return cRetorno

//---------------------------------------------------------------------
/*/{Protheus.doc} fTrataChar
Converte caracter com problema para ' '

@author Maria Elisandra de Paula
@since 13/05/2022
@param cStr, string, texto que deve ser manipulado
@return string com tratamento
/*/
//---------------------------------------------------------------------
Static Function fTrataChar( cStr100 )

    Local nX    := 0
	Local cChar := ''

	// teste com cada caracter da string
    For nX := 1 To Len( cStr100 )

        cChar := Substr( cStr100, nX, 1)

        If !Empty( cChar ) .And. EncodeUtf8( cChar ) == Nil
            cStr100 := StrTran( cStr100, cChar, ' ')
        EndIf

    Next nX

Return cStr100

//---------------------------------------------------------------------
/*/{Protheus.doc} fBranches
Retorna um array com código e nome do grupo e filial

@author Maria Elisandra de Paula
@since 28/06/2022
@param aBranches, array, filiais que o usuário tem permissão de acesso
@return array de filiais
/*/
//---------------------------------------------------------------------
Static Function fBranches( aBranches )

	Local oEntity
	Local cEnterprise := ''
	Local cBranch     := ''
	Local nIndex      := 0
	Local aResponse   := {}
	Local aJafoi      := {}
	Local lBranch     := .F. 

	// Info: Conteudo de cada linha do array aBranches é no formato "T3M RJ 02 "
	For nIndex := 1 To Len( aBranches )

		cEnterprise := SubStr( aBranches[nIndex], 1, 2 ) // M0_CODIGO (Ex: T3)
		cBranch := SubStr( aBranches[nIndex], 3    ) // M0_CODFIL (Ex: M SP 01 )

		If Ascan(aJafoi, cEnterprise) == 0

			aadd(aJafoi, cEnterprise)

			If !ConfigEnv2( cEnterprise, cBranch )
				Printf( "Configuracao do ambiente nao realizada" )
				Loop
			EndIf

			If !lDBOrderOk .And. !lDBRequestOk
				Printf( cEnterprise + cBranch + " Falta campos de usuário." )
				Loop
			EndIf

			If lOrderPermission .And. !lDBOrderOk
				Printf( cEnterprise + cBranch + " nao possui os campos de usuario para ordem de servico." )
				Loop
			EndIf

			If lRequestPermission .And. !lOrderPermission .And. !lDBRequestOk
				Printf( cEnterprise + cBranch + " nao possui os campos de usuario para solicitações." )
				Loop
			EndIf

			lBranch := .T.

		EndIf

		If lBranch

			oEntity := Branches():New()
			oEntity:EnterpriseCode      := cEnterprise
			oEntity:BranchCode          := cBranch
			oEntity:EnterpriseName      := Alltrim( FWGrpName( cEnterprise ) )
			oEntity:BranchName          := FWFilName( cEnterprise, cBranch )
			oEntity:Localization        := oEntity:EnterpriseName + ' / ' + oEntity:BranchName

			aAdd( aResponse, oEntity )

		EndIf

	Next nIndex

Return aResponse

//---------------------------------------------------------------------
/*/{Protheus.doc} fInfoMNT
Retorna as informações de apenas uma filial - quando não possui valid Mingle

@author Maria Elisandra de paula
@param oSelf, objeto, instância do webservice
@since 07/06/2022
@return logic, se obteve sucesso no login
/*/
//---------------------------------------------------------------------
Static Function fInfoMNT( oSelf )

	Local oEntity
	Local cEnterprise := oSelf:GetHeader( 'enterprise' )
	Local cBranch     := oSelf:GetHeader( 'branch' )
	Local cEmail      := oSelf:GetHeader( 'email' )
	Local aResponse   := {}
	Local aValid      := fInitMnt(oSelf)

	If !Empty(aValid[1])
		Return fRetError( aValid[1], oSelf )	
	EndIf

	oEntity := fGetInfo(cEnterprise, cBranch, aValid[3], NGEscape( aValid[2], .T. ), cEmail)

	aAdd( aResponse, oEntity )

	oSelf:SetContentType( 'application/json' )
	oSelf:SetResponse(jsonResult(FWJsonSerialize( aResponse, .F. )))

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fInitMnt
Validação e acesso ao ambiente no login sem mingle

@author Maria Elisandra de paula
@param oSelf, objeto, instância do webservice
@since 14/06/2022
@return array, [1] descrição do erro caso houver,
				[2] nome do usuário
				[3] código do usuário
/*/
//---------------------------------------------------------------------
Static Function fInitMnt( oSelf )

	Local cVersion    := oSelf:GetHeader( 'version' )
	Local aInfoUser   := {}
	Local aInfoLogin  := {}
	Local aBranches   := {}
	Local nAscan      := 0
	Local cError      := {}

	Printf( 'App version ' + cVersion )

	oSelf:ClearResponse()
	oSelf:SetContentType( 'application/json' )

	StartStatics( oSelf )

	aInfoLogin := GetInfoLogin( oSelf )

	If !aInfoLogin[1]
		Return { aInfoLogin[2] }
	Else
		aBranches := aInfoLogin[2]
		aInfoUser := aInfoLogin[3]
	EndIf

	cError := fLicense( oSelf )

	If !Empty( cError )
		Return { cError }
	EndIf

	lDBOrderOk := Len( fCheckBase( "order" ) ) == 0
	lDBRequestOk := Len( fCheckBase( "request" ) ) == 0

	If !lOrderPermission .And. !lRequestPermission
		Return { STR0191 } // "As permissões de grupo não foram encontradas nesta requisição, verifique as configurações de grupo de usuário no portal mobile."
	EndIf

	If !lDBOrderOk .And. !lDBRequestOk
		Return { STR0192 + ": " + STR0195 } // "O ambiente Protheus não está devidamente configurado para o MNT NG" # "não possui todos os campos de usuario."
	EndIf

	If lOrderPermission .And. !lDBOrderOk
		Return { STR0192 + ": " + STR0193 } // // "O ambiente Protheus não está devidamente configurado para o MNT NG" # "não possui todos os campos de usuario para ordem de servico."
	EndIf

	If lRequestPermission .And. !lDBRequestOk
		Return {  STR0192 + ": " + STR0194 } // // "O ambiente Protheus não está devidamente configurado para o MNT NG" # "não possui os campos de usuario para solicitações."
	EndIf

	If lRequestPermission .And. SuperGetMv( 'MV_NG1FAC', .F., '2') == '1'
		Return { STR0192 + ": " + STR0196}
	EndIf

	nAscan = Ascan(aBranches, oSelf:GetHeader( 'enterprise' ) + oSelf:GetHeader( 'branch' ) )

	If nAscan == 0
		Return { STR0197 } // "Este usuário não possui acesso a essa filial. Verifique as permissões no configurador do Protheus."
	EndIf

Return {'', aInfoUser[ 1, 1 ], aInfoUser[ 1, 4 ]}

//---------------------------------------------------------------------
/*/{Protheus.doc} fDownload
Download de arquivo

@param oWebService, objeto, instância do ws
@param cPath, string, caminho do arquivo
@param cFileName, string, nome do arquivo
@param [lEncode64], boolean, se deve converter para base64

@author Marcelo Camargo
@since 14/03/2016
@return boolean, se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function fDownload( oWebService, cPath, cFileName, lEncode64 )
    
	Local xBytes := fReadBytes( cPath )
	
	Default lEncode64 := .F.

    If Nil == xBytes .Or. FError() != 0 
        Return .F.
    EndIf
	
	If lEncode64
		xBytes := Encode64(xBytes)
	EndIf

    oWebService:SetContentType( 'application/octet-stream' )
    oWebService:SetHeader( 'Content-Disposition', 'attachment; filename=' + cFileName )
    oWebService:SetHeader( 'Pragma', 'no-cache' )
    oWebService:SetResponse( xBytes )

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fImage
Download de imagem

@param oWebService, objeto, instância do ws
@param cPath, string, caminho do arquivo
@param [lEncode64], boolean, se deve converter para base64

@author Marcelo Camargo
@since 14/03/2016
@version P12
@return boolean, se obteve sucesso
/*/
//---------------------------------------------------------------------
Static Function fImage( oWebService, cPath, lEncode64 )
    
	Local xBytes := fReadBytes( cPath )
	
	Default lEncode64 := .F.

    If Nil == xBytes .Or. 0 <> FError()
        Return .F.
    EndIf

    If !lEncode64
        oWebService:SetContentType( 'image/png' )
        oWebService:SetResponse( xBytes )
    Else
        oWebService:SetContentType( 'application/json' )
        oWebService:SetResponse( '{"image":"' + Encode64(xBytes) + '"}' )
    EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fReadBytes
Retorna caracteres de um arquivo binário

@param cFileName, string, nome do arquivo
@author Marcelo Camargo
@since 30/08/2016
@return caracteres do arquivo
/*/
//---------------------------------------------------------------------
Static Function fReadBytes( cFileName )
    
	Local nHandler := FOpen( cFileName, FO_READWRITE + FO_SHARED )
    Local nSize    := 0
    Local xBuffer  := ''

    If -1 == nHandler
        Return Nil
    EndIf

    nSize := FSeek( nHandler, 0, FS_END )
    FSeek( nHandler, 0 )
    FRead( nHandler, xBuffer, nSize )
    FClose( nHandler )
Return xBuffer

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetSalSb2
Envia saldo de produtos da SB2

@author Maria Elisandra de Paula
@since 29/09/2022
@param oWs, objeto, instância do webservice
@param cproduct, string, código do produgo
@return array, 
		1 [se obteve sucesso na operação]
		2 [mensagem de erro]
/*/
//---------------------------------------------------------------------
Static Function fGetSalSb2( oWs, cProduct )

	Local aAux  := {}
	Local cResp :=  '{"items":[' 
	Local nI    := 0

	If !FindFunction('MntSldSB2')
		Return {.F., FwhttpEncode(STR0203)}// 'O repositório do servidor não está atualizado para a funcionalidade de saldos de produtos.')}
	EndIf

	aAux := MntSldSb2(cProduct)

	If !Empty(aAux)
		For nI := 1 to Len(aAux)
			If nI > 1
				cResp += ','
			EndIf
			cResp += '{"warehouse":"' + aAux[nI,1] + '",'
			cResp += '"quantity":' + cValTochar(aAux[nI,2]) + '}' 
		Next nI
	EndIf

	cResp += ']}'

	oWs:SetStatus( 200 )
	oWs:SetResponse( FwhttpEncode( cResp ) )

Return {.T., ''}

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetSalSbf
Envia saldo de produtos com endereçamento - SBF

@author Maria Elisandra de Paula
@since 29/09/2022
@param oWs, objeto, instância do webservice
@param cproduct, string, código do produto
@param cWarehouse, string, código do local
@return array, 
		1 [se obteve sucesso na operação]
		2 [mensagem de erro]
/*/
//---------------------------------------------------------------------
Static Function fGetSalSbf( oWs, cProduct, cWarehouse )

	Local aAux  := {}
	Local cResp :=  '{"items":[' 
	Local nI    := 0

	If !FindFunction('MntSldSB2')
		Return {.F., FwhttpEncode(STR0203)}// 'O repositório do servidor não está atualizado para a funcionalidade de saldos de produtos.')}
	EndIf

	aAux := MntSldSbf(cProduct, cWarehouse)

	If !Empty(aAux)
		For nI := 1 to Len(aAux)
			If nI > 1
				cResp += ','
			EndIf
			cResp += '{"address":"' + aAux[nI,1] + '",'
			cResp += '"quantity":' + cValTochar(aAux[nI,2]) + '}' 
		Next nI
	EndIf

	cResp += ']}'

	oWs:SetStatus( 200 )
	oWs:SetResponse( FwhttpEncode( cResp ) )

Return {.T., ''}
