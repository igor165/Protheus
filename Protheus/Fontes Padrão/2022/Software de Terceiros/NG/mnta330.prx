#INCLUDE "MNTA330.CH"
#INCLUDE "PROTHEUS.CH"

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA330

Programa de Processamento do Plano de Manutencao

@author	Paulo Pego
@version MP11 e MP12
@source  Generico
/*/
//---------------------------------------------------------------------
Function MNTA330(cPlano)

	//Guarda conteudo e declara variaveis padroes
	Local aNGBEGINPRM := {}

	If !FindFunction( 'MNTAmIIn' ) .Or. MNTAmIIn( 19, 35, 95 )

		aNGBEGINPRM := NGBEGINPRM()

		Private dDtMi
		Private _DTPROX, dREAL, _CONPROX, _HHPROX
		Private lPlan330   := .T.
		Private aRotina    := MenuDef()
		Private aAC        := {STR0001,STR0002}       //"Abandona"###"Confirma"
		Private _lFirstOS  := .F. // Indica se é a primeira O.S. do cálculo da Próxima Manutenção (ocorre normalmente quando não há ordens de serviço para a manutenção)
		Private lLubrif    := .T.
		Private lEstrut    := .F.
		Private lCEstru    := NGCADICBASE("TI_ESTRUTU","A","STI",.F.)
		Private lMVMOINP   := If(GetNewPar("MV_NGMOINP","2")=="1",.T.,.F.)  //Mostra Inconsistencias do Plano
		Private aIndSTI    := {}
		Private lNovoBrw   := If(TcSrvType() == "AS/400" .OR. TcSrvType() == "iSeries" .OR. Empty(TcSrvType()),.F.,.T.)
		Private aBensTrb   := {}  // Indica bens marcados pelo filtro de bens
		Private lAbriu     := .F. // Indica se o usuário confirmou a tela de filtro.

		//Inicio NAO MEXER....
		Private aDataOPC1 := {}
		Private aDataOPC7 := {}
		Private aOPC1     := {}
		Private aOPC7     := {}
		Private vVetP     := {}
		Private aNumSC1   := {}
		Private cNumSC1   := Space(Len(SC1->C1_NUM))
		Private cNuISC1   := 0
		Private lconsterc := .T.
		Private lconsNPT  := .T.
		// FIM

		//Variaveis do Tamanho da Tela
		Private aSize    := MsAdvSize(,.F.,430)
		Private aObjects := {}
		Private nLargura := 0
		Private nAltura  := 0
		Private lFiltBem := .F. // Indica se usuário usa filtro por bem na rotina
		Private cMarca   := GetMark() // Indica valor de marca da cTRB de filtro do escopo de bens para manutenção
		Private cPla     := cPlano

		nAltura  := aSize[6]
		nLargura := aSize[5]

		If isInCallStack("MNTA331")
			asMenu := NGRIGHTCLICK("MNTA331")
		ElseIf isInCallStack("MNTA350")
			asMenu := NGRIGHTCLICK("MNTA350")
		EndIf

		If UPPER(AllTrim(cPlano)) = "L"
			lLubrif := .F.
		EndIf

		lModBe := .T.

		lForTPG := NGCADICBASE("TG_FORNEC","A","STG",.F.)

		cCondicao := IIf(cPlano == "L","ST4->T4_LUBRIFI = 'S'","ST4->T4_LUBRIFI <> 'S'")

		aAdd(aObjects,{050,050,.t.,.t.})
		aAdd(aObjects,{100,100,.t.,.t.})
		aInfo   := {aSize[1],aSize[2],aSize[3],aSize[4],0,0}
		aPosObj := MsObjSize(aInfo, aObjects,.t.)

		//Define o cabecalho da tela de atualizacoes
		cCADASTRO := IIf(cPlano = "L",STR0027,STR0009)

		If lNovoBrw
			cFilMbroSTI := "TI_FILIAL = '"+xFilial('STI')+"'"+If(Upper(AllTrim(cPlano)) = "L"," And TI_LUBRIFI = 'S'"," And TI_LUBRIFI = 'N'")

			MBROWSE(6,1,22,75,"STI",,,,,,,,,,,,,,cFilMbroSTI)
		Else
			cFiltro := "TI_FILIAL = '"+xFilial('STI')+"'"+If(Upper(AllTrim(cPlano)) = "L"," .And. TI_LUBRIFI = 'S'"," .And. TI_LUBRIFI = 'N'")

			cFiltroI   := cFiltro
			bFiltraBrw := {|| FilBrowse("STI",@aIndSTI,@cFiltro)}
			Eval(bFiltraBrw)

			nINDSTI := INDEXORD()
			mBrowse( 6, 1, 22, 75, "STI")

			aEval(aIndSTI,{|x| Ferase(x[1]+OrdBagExt())})
			ENDFILBRW("STI",aIndSTI)
		EndIf

		Set Key VK_F9 To
		NGDBAREAORDE("STI",1)
		Set Filter To
		NGDBAREAORDE("STI",1)

		//Retorna conteudo de variaveis padroes
		NGRETURNPRM(aNGBEGINPRM)

	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} A330Inclui

Programa de inclusao de Plano de Acompanhamento

@author	Paulo Pego
@version MP11 e MP12
@source  Generico
@param ExpC1 = Alias do arquivo
ExpN1 = Numero do registro
ExpN2 = Opcao selecionada
/*/
//---------------------------------------------------------------------
Function A330INCLUI(cALIAS,nREG,nOPCX)

	Local oGET, i, oMenu
	Local cSAVEMENUH
	Local oDLG      := Nil
	Local oPnlEnch  := Nil
	Local oPanelTot := Nil
	Local bCAMPO    := {||}
	Local LVAR01    := 1
	Local nLINHAS   := 0
	Local GetList   := {}
	Local nOPCAO    := 3
	Local lGRAVAOK  := .T.
	Local aButtons  := {}
	Local oSize     := FwDefSize():New(.T.)
	Local nLinIniTl := oSize:aWindSize[1] // Linha  inicial da tela
	Local nColIniTl := oSize:aWindSize[2] // Coluna inicial da tela
	Local nLinFimTl := oSize:aWindSize[3] // Linha  final   da tela
	Local nColFimTl := oSize:aWindSize[4] // Coluna final   da tela
	Local nInd      := 0
	Local nTamTot   := 0
	Local cCampo    := ""
	Local cRelacao  := ""
	Local aHeadInc  := {}

	//Salva a integridade dos dados
	Private nL1,nL2,nC1,nC2
	Private cA330NUM := SPACE(06)
	Private cA331NUM := SPACE(06)
	Private cNOME    := SPACE(40)
	Private nOPCA    := 0
	Private cNBemi   := NGRETTITULO("TI_BEMINI")
	Private cNNomi   := NGRETTITULO("TI_NOMBINI")
	//Monta a entrada de dados do arquivo
	Private aTELA[0][0]
	Private aGETS[0]
	Private aHEADER[0]
	Private CONTINUA
	Private nUSADO := 0

	Private cAliasTRB1 := GetNextAlias()
	Private oTmpTbl7
	Private oMark

	// Verifica se ha integracao com modulo Chao de Fabrica [SIGASFC]
	// Valida existencia de parametro de motivo de parada (MV_SFCMTSP)
	If FindFunction("NGINTSFC") .And. NGINTSFC() .And. ( !NGSFCPARAM() .Or. !NGSFCRESP() )
		Return .F.
	EndIf

	Store 0 to nL1,nL2,nC1,nC2

	dbSelectArea('STI')
	nSAVREG := RECNO()

	Set Filter To
	NGDBAREAORDE(cAlias,1)

	cA330NUM := LockPlano() // Retorna o próximo código de plano disponível

	If Upper(AllTrim(cPla)) == "L"
		Set Filter To STI->TI_FILIAL = xFilial("STI") .And. STI->TI_LUBRIFI = "S"
	Else
		Set Filter To STI->TI_FILIAL = Xfilial("STI") .And. STI->TI_LUBRIFI = "N"
	EndIf

	If ExistBlock( 'MNTA3305' )
		ExecBlock( 'MNTA3305', .F., .F. )
	EndIf

	DbGoto(nSAVREG)
	bCAMPO  := {|nCPO| Field(nCPO)}
	NGDBAREAORDE("STI",1)
	nSAVREG := Recno()

	DbGobottom()
	dbSkip(1)
	For i := 1 To Fcount()
		M->&(EVAL(bCAMPO,i)) := FieldGet(i)
		IF ValType(M->&(EVAL(bCAMPO,i))) == "C"
			M->&(EVAL(bCAMPO,i)) := Space(Len(M->&(EVAL(bCAMPO,i))))
		ElseIf ValType(M->&(EVAL(bCAMPO,i))) == "N"
			M->&(EVAL(bCAMPO,i)) := 0
		ElseIf ValType(M->&(EVAL(bCAMPO,i))) == "D"
			M->&(EVAL(bCampo,i)) := CTOD("  /  /  ")
		ElseIf ValType(M->&(EVAL(bCAMPO,i))) == "L"
			M->&(EVAL(bCAMPO,i)) := .F.
		EndIf
	Next i

	aHeadInc := NGHeader(cALIAS)

	For nInd := 1 To Len(aHeadInc)

		cCampo   := aHeadInc[nInd,2]
		cRelacao := Posicione("SX3",2,cCampo,"X3_RELACAO")

		If !Empty(cRelacao)
			xx  := "M->" + Trim(cCampo)
			yy  := Trim(cRelacao)
			&xx.:= &yy.
		Endif

	Next nInd

	M->TI_PLANO := cA330NUM

	nOPCA := 0
	aPOS1 := {15,1,140,aPosObj[2,4]}

	DEFINE MSDIALOG oDLG TITLE cCADASTRO FROM nLinIniTl,nColIniTl TO nLinFimTl,nColFimTl OF oMAINWND PIXEL STYLE nOR(WS_VISIBLE,WS_POPUP)

	oPanelTot       := TPanel():Create(oDLG,0,0,,,.F.,,,CLR_WHITE,0,0)
	oPanelTot:Align := CONTROL_ALIGN_ALLCLIENT

	oPnlEnch        := TPanel():New(0,0,Nil,oPanelTot,Nil,.T.,.F.,Nil,Nil,0,0,.T.,.F.)
	oPnlEnch:Align  := CONTROL_ALIGN_ALLCLIENT

	oEnchoice       := Msmget():New("STI", nREG, nOPCX,,,,,aPOS1,,3,,,,oPnlEnch)
	oEnchoice:oBox:Align := CONTROL_ALIGN_ALLCLIENT

	If Len(aSMenu)	 > 0
		NGPOPUP(aSMenu,@oMenu)
		oEnchoice:oBox:bRClicked := { |o,x,y| oMenu:Activate(x,y,oDlg)}
		oDlg:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDlg)}
	EndIf

	aAdd( aButtons, { "" , { || A330FILBEM() }, "Filtrar Bens" } )

	ACTIVATE MSDIALOG oDLG ON INIT EnchoiceBar(oDLG,{||nOPCA:=1,If(!MNTA330FI(),nOPCA := 0,oDLG:End())},{||oDLG:End()},AlignObject(oDlg,{oEnchoice:oBox},1),aButtons)

	If nOPCA == 1
		Processa({|lCanc330| a330GRAVA(cALIAS,nOPCAO,@lCanc330)},,,.T.)  // Chamada da funcao de recalculos
		EvalTrigger()
	EndIf

	//---------------------------------------
	// Elimina bloqueio feito pelo LockPlano
	//---------------------------------------
	UnLockPlano(cA330NUM)

	dbSelectArea(cALIAS)
	lEstrut  := .F.
	lFiltBem := .F.
	lAbriu   := .F.

	If Type("oTmpTbl7") == "O"
		//Deleta Tabela de Criação do Plano
		oTmpTbl7:Delete()
	EndIf
Return nOPCA

//---------------------------------------------------------------------
/*/{Protheus.doc} A330Deleta

Programa de exclusao de Familias de Bens

@author	Paulo Pego
@version MP11 e MP12
@source  Generico
@param ExpC1 = Alias do arquivo
ExpN1 = Numero do registro
/*/
//---------------------------------------------------------------------
Function A330DELETA(cALIAS,nREG,nOPC)

	Local bCAMPO,nOPCA,cCOD, cMOTIVO, oDLG
	Local oMenu     := Nil
	Local oPnlEnch  := Nil
	Local oPanelTot := Nil
	Local LVAR01    := 1
	Local nLINHAS   := 0
	Local lERRO     := .F.
	Local aOS       := {}
	Local aFER      := {}
	Local lOK       := .T.
	Local cIntSFC   := If( FindFunction("NGINTSFC"), NGINTSFC(.F.), "" ) // Verifica se ha integracao com modulo Chao de Fabrica [SIGASFC]
	Local aSFCErro  := {}
	Local oSize     := FwDefSize():New(.T.)
	Local nLinIniTl := oSize:aWindSize[1] // Linha  inicial da tela
	Local nColIniTl := oSize:aWindSize[2] // Coluna inicial da tela
	Local nLinFimTl := oSize:aWindSize[3] // Linha  final   da tela
	Local nColFimTl := oSize:aWindSize[4] // Coluna final   da tela

	//Monta a entrada de dados do arquivo
	Private aTELA[0][0]
	Private aGETS[0]
	//Objeto e Alias da Tabela temporaria 1
	Private oTmpTbl1
	Private cAliasTemp := GetNextAlias()

	aDBF1 := {} //Tabela temporária para guardar os problemas encontrados no plano
	aAdd(aDBF1,{"OS"     ,"C",TAMSX3("TJ_ORDEM")[1]  ,0}) // Ordem de Serviço
	aAdd(aDBF1,{"SEQUEN" ,"C",TAMSX3("TL_SEQRELA")[1],0}) // Sequencia
	aAdd(aDBF1,{"TIPO"   ,"C",TAMSX3("TL_TIPOREG")[1],0}) // Tipo de Insumo
	aAdd(aDBF1,{"CODIGO" ,"C",TAMSX3("TL_CODIGO")[1] ,0}) // Cod. Insumo
	aAdd(aDBF1,{"TIPCOT" ,"C",70                     ,0}) // Tipo de Cotação

	//Intancia classe FWTemporaryTable
	oTmpTbl1:= FWTemporaryTable():New( cAliasTemp, aDBF1 )
	//Adiciona os Indices
	oTmpTbl1:AddIndex( "Ind01" , {"OS","SEQUEN"} )
	//Cria a tabela temporaria
	oTmpTbl1:Create()

	bCAMPO := {|nCPO| Field(nCPO) }
	If STI->TI_PLANO == "000000" .Or. STI->TI_PLANO == "000001"
		Help("",1, "PLANAOCANC")
		Return
	EndIf

	If STI->TI_SITUACA == "C" .Or. STI->TI_TERMINO = "S"
		Help("",1, "PLANJACANC")
		Return
	EndIf

	M->TI_PLANO := STI->TI_PLANO

	//Verifica problema de cotação e solicitações pendentes para cada insumo.
	NGIFDBSEEK('STJ',M->TI_PLANO,3,.F.)
	While STJ->(!Eof()) .and. STJ->TJ_FILIAL == xFilial("STJ") .and. STJ->TJ_PLANO == M->TI_PLANO
		MNT330INSB(STJ->TJ_ORDEM,cAliasTemp)
		NGDBSELSKIP("STJ")
	End

	NGSETIFARQUI(cAliasTemp,,1)
	If Reccount() > 0
		If MsgYesNo(STR0097) //
			fImp330Log(cAliasTemp)
		EndIf
		//Deleta aquivo de problemas do plano
		oTmpTbl1:Delete()
		Return .F.
	EndIf

	//Envia para processamento dos Gets
	nOPCA := 0
	aPOS1 := {15,1,140,aPosObj[2,4]}

	SoftLock(cALIAS)
	DEFINE MSDIALOG oDLG TITLE cCADASTRO FROM nLinIniTl,nColIniTl TO nLinFimTl,nColFimTl OF oMAINWND PIXEL STYLE nOR(WS_VISIBLE,WS_POPUP)

	oPanelTot       := TPanel():Create(oDLG,0,0,,,.F.,,,CLR_WHITE,0,0)
	oPanelTot:Align := CONTROL_ALIGN_ALLCLIENT

	oPnlEnch        := TPanel():New(0,0,Nil,oPanelTot,Nil,.T.,.F.,Nil,Nil,0,0,.T.,.F.)
	oPnlEnch:Align  := CONTROL_ALIGN_ALLCLIENT

	oEnchoice       := Msmget():New(cALIAS,nREG,nOPC,aAC,"AC",STR0010,,aPOS1,,3,,,,oPnlEnch)
	oEnchoice:oBox:Align := CONTROL_ALIGN_ALLCLIENT

	NGPOPUP(aSMenu,@oMenu)
	oDlg:bRClicked := { |o,x,y| oMenu:Activate(x,y,oDlg)}

	ACTIVATE MSDIALOG oDLG ON INIT EnchoiceBar(oDLG,{|| nOPCA:=2,oDLG:End()},{|| nOPCA:=1,oDLG:End()})
	dbSelectArea(cALIAS)

	If nOPCA == 2
		cCOD := STI->TI_PLANO
		NGIFDBSEEK('STJ',cCOD,3,.F.)
		While !Eof() .And. xFilial('STJ') == STJ->TJ_FILIAL .And. STJ->TJ_PLANO == cCOD
			If stj->tj_tipoos = "B"
				If NGIFDBSEEK('STL',STJ->TJ_ORDEM+STJ->TJ_PLANO+"1  ",3,.F.)
					Help("",1,"JAREPORTOS")
					Return .T.
				EndIf

				// Caso integrado ao modulo SIGASFC, e o bem for uma maquina
				// Verifica se será possivel cancelar a parada programada relacionada a O.S.
				If STJ->TJ_PLANO > "000000" .And. !Empty(STJ->TJ_DTPPINI) .And. !Empty(cIntSFC) .And. !Empty(NGVRFMAQ(STJ->TJ_CODBEM)) .And. !NGSFCDELPP(STJ->TJ_ORDEM,.F.,.F.)
					aAdd(aSFCErro,{STJ->TJ_ORDEM,STJ->TJ_CODBEM,STJ->TJ_DTPPINI,STJ->TJ_HOPPINI,STJ->TJ_DTPPFIM,STJ->TJ_HOPPFIM})
				EndIf

			EndIf
			NGDBSELSKIP("STJ")
		End
		//apos passar por todas as verificacoes , deleta o registro

		NGIFDBSEEK('STJ',cCOD,3,.F.)
		While !Eof() .And. (xFilial("STJ")+cCOD) == (TJ_FILIAL+TJ_PLANO)
			If STJ->TJ_TERMINO != "S" .And. STJ->TJ_TIPOOS = "B"
				aAdd(aOS,{TJ_ORDEM,TJ_CODBEM,TJ_CCUSTO,TJ_DTMPINI,TJ_HOMPINI,TJ_PLANO,TJ_SITUACA})
			EndIf
			dbSkip()
		EndDo

		Processa({|lEND| lOK := a330DELMOV(aOS,.t.)})
		If lOK
			NGDELETAREG(cALIAS)
			NGDBAREAORDE("STI",1)
		EndIf

	Else
		(cALIAS)->(MsUnLock())
	EndIf

	If !Empty(cIntSFC) .And. Len(aSFCErro) > 0
		MNT330ESFC(aSFCErro, 3)
	EndIf

	dbSelectArea(cALIAS)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³A330Grava ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Efetua o processamento de calculo para a manutencao        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A330GRAVA(cALIAS,nOPCAO,lCanc330)

	Local dINI,dFIM,hINI,hFIM
	Local _OLDPROX1,_OLDDT1,OLDREAL1,_OLDPROX2,_OLDDT2,OLDREAL2,_OLDOK1,_OLDOK2
	Local nTOT,nPOS,SCR,nRECNO,i,n,x
	Local nSEMN
	Local nFe,nFr
	Local dOldDtINI, cOldHrINI, dOldDtFIM, cOldHrFIM
	Local aNewTermino, nTempoDeco
	Local nx         	:= 0
	Local ny         	:= 0
	Local nk			:= 0
	Local nMAXARRAY  	:= 0
	Local nCNTITEM   	:= 1
	Local aT9Area    	:= {}
	Local aANTERIOR  	:= {}
	Local nCNTDEL    	:= 0
	Local aBLO       	:= {{},{},{},{},{}}
	Local aFER       	:= {}
	Local lExistOS   	:= .F. // Verifica se a O.S. ja existe
	Local nForManuts 	:= 0   // Contador do 'For' que percorre as Manutenções
	Local nQtdOSDia  	:= 0
	Local nMaxOSDia  	:= 0 // Quantidade de O.S. por Dia e Quantidade Máxima de O.S. em um Dia
	Local lOK        	:= .T.
	Local lParada    	:= .F.
	Local lMNTA3307		:= ExistBlock("MNTA3307")
	Local lMNTA3308		:= ExistBlock("MNTA3308")
	Local lMNTA3303		:= ExistBlock("MNTA3303")
	Local lMNTA330V		:= ExistBlock("MNTA330V")
	Local lMNTA3306		:= ExistBlock("MNTA3306")
	Local lMNTA3309		:= ExistBlock("MNTA3309")
	Local lNGADDETAPA	:= ExistBlock("NgAddEtapa")
	Local lNGETAPNEX	:= ExistBlock("NGETAPNEX")
	Local cNGUNIDT		:= AllTrim(GetMv("MV_NGUNIDT"))
	Local cPRODTER		:= GETMV("MV_PRODTER")
	Local aSFCErro   	:= {} // Verifica possiveis erros quando integrado ao SIGASFC
	Local cIntSFC    	:= If( FindFunction("NGINTSFC"), NGINTSFC(.F.), "" ) // Verifica se ha integracao com modulo Chao de Fabrica [SIGASFC]
	Local cRecSFC    	:= ""
	Local lMMoeda    	:= NGCADICBASE("TL_MOEDA","A","STL",.F.) // Multi-Moeda
	Local aCstMoeda  	:= {}
	Local nSizeCod      := Len( SB1->B1_COD )
	Local aArea      	:= {}
	Local aGlut         := {}
	Local aProdOrdem    := {}
	Local cTpSaldo      := AllTrim( SuperGetMV( 'MV_TPSALDO' ) ) // Define Tipo de calculo para verificar saldo
	Local lNgInter      := AllTrim( SuperGetMV( 'MV_NGINTER', .F., ''  ) ) == 'M'
	Local cNGFLUT       := AllTrim(SuperGetMV("MV_NGFLUT", .F., "N"))
	Local cNGLOCPA      := Padr( SuperGetMv("MV_NGLOCPA",.F.,"01"), TamSx3("NNR_CODIGO")[1] )
	Local lMvMntEs      := SuperGetMV( 'MV_NGMNTES', .F., 'N' ) == 'S'

	Local nIndex        := 0
	Local nSaldoPro     := 0
	Local cSeqSt5       := ''
	Local cSpaceSt5     := Space( TamSx3('T5_SEQUENC')[1] )

	// Variáveis das Tabelas Temporárias
	Private cITRBA3301 := ""
	Private cITRBA3302 := ""

	//Indica se a ETAPAS da O.S. devem ser geradas
	Private lETAPAS    := .T.
	Private cORDEM     := ""
	Private nACUMUL    := 0
	Private lPRINDT    := .F.
	Private aVETINR    := {}
	Private lPE3304    := If(ExistBlock("MNTA3304"),.T.,.F.)
	Private lTRB3304   := .F.  //indica a existencia do arquivo (cTRB330)
	Private lPrimCPr   := .F.
	Private nIncCPr    := 0
	Private nPoscCpr   := 0
	Private DDataCPr   := Ctod("  /  /  ")
	Private nPCONTFIXO := GetMV("MV_NGCOFIX") //Percentual para calcular o contador fixo da manutencao
	Private nPERFIXO   := nPCONTFIXO / 100
	Private lPlaEstu   := .F.,nIcEst := 1
	Private aDIAMANUT  := {}
	Private SpEsp      := Space(Len(st2->t2_especia))
	Private aCalenF    := {}
	Private a330TmpF   := {}
	Private aMNTA3308  := {}
	Private a330EspB   := {}
	Private a330FerT   := {}
	Private n330Tole   := If( NGCADICBASE("TI_TOLEPER","A","STI",.F.) , M->TI_TOLEPER , 0 )
	Private aCALESTF   := {}
	Private aCalenda   := {} //Array utilizado para armazenar as horas quebradas do calendário.
	Private nHorasSTJ  := "00:00"
	Private lFrtInput  := .F.
	Private dLastDate  := Ctod('  /  /  ')
	Private oTmpTbl2
	Private oTmpTbl3
	Private oTmpTbl4
	//Alias das Tabelas temporarias
	Private cTRB    := GetNextAlias()
	Private cTRBPRB := GetNextAlias()
	Private cTRB330 := GetNextAlias()

	If lCEstru
		If M->TI_ESTRUTU = "S"
			lPlaEstu := .T.
			vRetEst  := f330BensStc(M->TI_BEMINI,M->TI_BEMFIM) //Bens que estão na estrutura
		EndIf
	EndIf

	cALIAS := "STI"
	NGDBAREAORDE(cALIAS,1)
	M->TI_FILIAL := xFilial("STI")
	If !dbSeek(xFilial("STI")+M->TI_PLANO)

		RecLock(cALIAS,.T.)
		For ny := 1 To STI->(Fcount())
			nx := "M->" + Fieldname(ny)
			FieldPut(ny, &nx.)
		Next ny
		Replace TI_FILIAL  With xFilial("STI")
		Replace TI_USUARIO With If(Len(STI->TI_USUARIO) > 15,cUsername,Substr(CUSUARIO,7,15))
		Replace TI_SITUACA With "P"
		Replace TI_TERMINO With "N"
		Replace TI_LUBRIFI With If(Upper(AllTrim(cPla)) = "L","S","N")

		STI->(MsUnLock())

	EndIf

	//Criacao de arquivos temporarios
	NGDBAREAORDE("STJ",6)
	NGDBAREAORDE("STF",1)

	aCAMPOS := DbStruct()
	aAdd(aCAMPOS,{"DTULTPROC" ,"D",8,0})
	aAdd(aCAMPOS,{"POSCONT"   ,"N",9,0})
	aAdd(aCAMPOS,{"POSCON2"   ,"N",9,0})
	aAdd(aCAMPOS,{"HORACON1"  ,"C",5,0})
	aAdd(aCAMPOS,{"CONPROX"   ,"N",9,0})
	aAdd(aCAMPOS,{"DTPROX"    ,"D",8,0})
	aAdd(aCAMPOS,{"DTULTMA"   ,"D",8,0})
	aAdd(aCAMPOS,{"DTREAL"    ,"D",8,0})
	aAdd(aCAMPOS,{"HRREAL"    ,"C",5,0})
	aAdd(aCAMPOS,{"TEMPO"     ,"N",4,0})
	aAdd(aCAMPOS,{"UNID"      ,"C",1,0})
	aAdd(aCAMPOS,{"PRIOBEM"   ,"C",3,0})
	aAdd(aCAMPOS,{"CALENDA"   ,"C",3,0})
	aAdd(aCAMPOS,{"CCUSTO"    ,"C",Len(SI3->I3_CUSTO),0})
	aAdd(aCAMPOS,{"CENTRAB"   ,"C",6,0})
	aAdd(aCAMPOS,{"VARDIA"    ,"N",6,0})
	aAdd(aCAMPOS,{"FERRAMENTA","C",1,0})
	aAdd(aCAMPOS,{"ORDEM"     ,"C",6,0})
	aAdd(aCAMPOS,{"POSCPR1"   ,"N",9,0})
	aAdd(aCAMPOS,{"POSCPR2"   ,"N",9,0})
	aAdd(aCAMPOS,{"DTLIMTOL"  ,"D",8,0})

	aMNTA3308 := aClone(aCampos) // Array utilizado pelo PE MNTA3308

	//Intancia classe FWTemporaryTable
	oTmpTbl2:= FWTemporaryTable():New( cTRB, aCampos )
	//Adiciona os Indices
	oTmpTbl2:AddIndex( "Ind01" , {"TF_FILIAL","TF_PRIORID","PRIOBEM"} )
	oTmpTbl2:AddIndex( "Ind02" , {"TF_FILIAL","TF_CODBEM","DTREAL"}   )
	oTmpTbl2:AddIndex( "Ind03" , { 'TF_FILIAL', 'TF_CODBEM', 'TF_SERVICO', 'TF_SEQRELA' } )
	//Cria a tabela temporaria
	oTmpTbl2:Create()

	aCAMPOS := {}
	aAdd(aCAMPOS,{"CODBEM" ,"C",TAMSX3("TF_CODBEM")[1],0})
	aAdd(aCAMPOS,{"SERVIC" ,"C",TAMSX3("TF_SERVICO")[1],0})
	aAdd(aCAMPOS,{"SEQUEN" ,"C",TAMSX3("TF_SEQRELA")[1],0})
	aAdd(aCAMPOS,{"DESCRI" ,"C",160,0})

	//Intancia classe FWTemporaryTable
	oTmpTbl3:= FWTemporaryTable():New( cTRBPRB, aCAMPOS )
	//Adiciona os Indices
	oTmpTbl3:AddIndex( "Ind01" , {"CODBEM","SERVIC","SEQUEN"} )
	//Cria a tabela temporaria
	oTmpTbl3:Create()

	//Selecionando Registros de Bens de Manutencao
	NGDBAREAORDE("ST9",3)
	dbSeek(xFilial("ST9")+M->TI_CCUSINI,.T.)
	ProcRegua(If(!lPlaEstu,Reccount(),Len(vRetEst)))

	nORDEM := 1
	cWhile := If(!lPlaEstu,'!Eof() .And. ST9->T9_FILIAL == xFilial("ST9") .And. ST9->T9_CCUSTO >= M->TI_CCUSINI .And. ST9->T9_CCUSTO <= M->TI_CCUSFIM',;
	'nIcEst <= Len(vRetEst)')
	If !(&cWhile)
		fGravPrb(If(!lPlaEstu,STR0065,;  //"Não existem bens válidos para o intervalo de centro de custo selecionado."
		STR0066))  //"Não existem bens válidos para a estrutura selecionada."
	EndIf

	aT9Area := ST9->(GetArea())
	If !MNT330VCAL()
		Return
	EndIf
	RestArea(aT9Area)
	nIcEst := 1

	// percorre bens para gerar manutenção
	While &(cWhile) .and. !lCanc330

		// Se o bem não estiver na lista dos selecionados, vai pro próximo registro,
		If lFiltBem .And. ( aScan(aBensTrb,{ |x| AllTrim( x ) == AllTrim( ST9->T9_CODBEM ) }) == 0 )
			dbSelectArea( "ST9" )
			dbSkip()
			Loop
		EndIf

		lPriIf := .F. //indica se atende as condicoes do bem
		If lPlaEstu
			NGIFDBSEEK('ST9',vRetEst[nIcEst],1,.F.)
			ccCODBEM := ST9->T9_CODBEM
			If !(If(Empty(M->TI_FAMIINI),.T.,ST9->T9_CODFAMI >= M->TI_FAMIINI .And. ST9->T9_CODFAMI <= M->TI_FAMIFIM) .And.;
			If(Empty(M->TI_CTRAINI),.T.,ST9->T9_CENTRAB >= M->TI_CTRAINI .And. ST9->T9_CENTRAB <= M->TI_CTRAFIM)   .And.;
			If(lModBe,If(Empty(M->TI_TIPMODI),.T.,ST9->T9_TIPMOD >= M->TI_TIPMODI .And. ST9->T9_TIPMOD <= M->TI_TIPMODF),.t.))
				lPriIf := .F.  //"Bem não atende aos parâmetros informados no plano de manutenção."
			ElseIf ST9->T9_SITBEM != "A"
				fGravPrb(STR0068+" '"+NGRETSX3BOX("T9_SITBEM","A")+"'.",ccCODBEM)  //"Situação do bem está diferente de"
			ElseIf ST9->T9_SITMAN == "I"
				fGravPrb(STR0069+" '"+NGRETSX3BOX("T9_SITMAN","I")+"'.",ccCODBEM)  //"No cadastro de bens a situação da manutenção está"
			Else
				lPriIf := .T.
			EndIf
		Else
			ccCODBEM := ST9->T9_CODBEM
			If !(If(Empty(M->TI_FAMIINI),.T.,ST9->T9_CODFAMI >= M->TI_FAMIINI .And. ST9->T9_CODFAMI <= M->TI_FAMIFIM) .And.;
			If(Empty(M->TI_CTRAINI),.T.,ST9->T9_CENTRAB >= M->TI_CTRAINI .And. ST9->T9_CENTRAB <= M->TI_CTRAFIM) .And.;
			If(Empty(M->TI_BEMINI), .T.,ccCODBEM >= M->TI_BEMINI .And. ccCODBEM <= M->TI_BEMFIM)                 .And.;
			If(lModBe,If(Empty(M->TI_TIPMODI),.T.,ST9->T9_TIPMOD >= M->TI_TIPMODI .And. ST9->T9_TIPMOD <= M->TI_TIPMODF),.t.))
				lPriIf := .F.  //"Bem não atende aos parâmetros informados no plano de manutenção."
			ElseIf ST9->T9_SITBEM != "A"
				fGravPrb(STR0068+" '"+NGRETSX3BOX("T9_SITBEM","A")+"'.",ccCODBEM)  //"Situação do bem está diferente de"
			ElseIf ST9->T9_SITMAN == "I"
				fGravPrb(STR0069+" '"+NGRETSX3BOX("T9_SITMAN","I")+"'.",ccCODBEM)  //"No cadastro de bens a situação da manutenção está"
			Else
				lPriIf := .T.
			EndIf
		EndIf

		nRECNO := Recno()

		If lMNTA3307
			If !ExecBlock("MNTA3307",.F.,.F.)
				lPriIf := .F.
				fGravPrb(STR0070,ccCODBEM)  //"Inconsistência encontrada com o ponto de entrada MNTA3307."
			EndIf
		EndIf

		IncProc(Oemtoansi(STR0011)) //"Selecionando Bens para Manutenao"

		If lPriIf

			NGIFDBSEEK('STF',ccCODBEM,1,.F.)
			OLDDAT         := STF->TF_DTULTMA
			M->TF_DTULTMA  := STF->TF_DTULTMA
			OLDSERV        := Space(6)
			lPRIMA         := .T.  //indica primeiro loop (necessidade de criacao do arquivo temporario (cTRB330))
			cSEQAU         := STF->TF_SEQRELA
			lPRIMNTEM      := .F.

			If !(STF->(!Eof()) .And. STF->TF_FILIAL == xFilial('STF') .And. STF->TF_CODBEM == ccCODBEM)
				fGravPrb(STR0071,ccCODBEM)  //"Não existem manutenções para o bem."
			EndIf

			While STF->(!Eof()) .And. STF->TF_FILIAL == xFilial('STF') .And. STF->TF_CODBEM == ccCODBEM

				If Empty( STF->TF_CALENDA )
					fGravPrb(STR0059, STF->TF_CODBEM, STF->TF_SERVICO, STF->TF_SEQRELA ) // "Campo calendário não está preenchido, ajustar o cadastro da manutenção do bem."
					STF->( dbSkip() )
					Loop
				EndIf

				aCalenda := NGCALENDAH( STF->TF_CALENDA ) //Retorna um array, com as horas do calendário da manutenção

				If aScan( aCalenda, { |x| x[1] != '00:00' } ) == 0

					fGravPrb( STR0116, STF->TF_CODBEM, STF->TF_SERVICO, STF->TF_SEQRELA ) // Calendário sem especificação de horas disponivéis.
					STF->( dbSkip() )
					Loop

				EndIf

				lPrimCPr := .F.
				nIncCPr  := 0
				nPoscCpr := 0
				DDataCPr := Ctod("  /  /  ")

				// Caso haja integracao com Chao de Fabrica (SIGASFC), valida existencia de turno conforme calendario da manutencao
				If !Empty(cIntSFC) .And. !Empty(NGVRFMAQ(STF->TF_CODBEM)) .And. !NGSFCTRNCL(STF->TF_CALENDA)
					fGravPrb(STR0109,STF->TF_CODBEM,STF->TF_SERVICO,STF->TF_SEQRELA) // "Número de turno inexistente no módulo Chão de Fábrica."
					NGDBSELSKIP("STF")
					Loop
				EndIf

				If lPRIMA .And. STF->TF_TIPACOM = "T"
					If lPE3304
						lPRIMNTEM := .T. //Indica que a Primeira Manutencao e por tempo
						If Select(cTRB330) <= 0
							aDBF330  := {{"DATAPLA","D",08,0}}

							//Intancia classe FWTemporaryTable
							oTmpTbl4:= FWTemporaryTable():New( cTRB330, aDBF330 )
							//Adiciona os Indices
							oTmpTbl4:AddIndex( "Ind01" , {"DATAPLA"} )
							//Cria a tabela temporaria
							oTmpTbl4:Create()
							lTRB3304 := .T.
						EndIf
					EndIf
					lPRIMA := .F.
				EndIf

				dDPRIREAL := Ctod('  /  /  ')
				nDTREAL   := 0
				nMANUCT   := 0
				lCONTREAL := .F.
				lATRASA   := .F.
				lINCONT   := .t.
				lCONTFIXO := .t.
				cTIPMAN   := Space(1)

				lSkipSTI := .T.  //indica se deve pular manutencao STF

				If M->TI_TIPACOM = "1" .And. STF->TF_TIPACOM = "T" //1=Tempo, T=Tempo
					lSkipSTI := .F.
				ElseIF M->TI_TIPACOM = "2" .And. STF->TF_TIPACOM = "C" //2=Contador, C=Contador
					lSkipSTI := .F.
				ElseIF M->TI_TIPACOM = "3" .And. STF->TF_TIPACOM = "A" //3=Tempo/Contador, A=Tempo/Contador
					lSkipSTI := .F.
				ElseIF M->TI_TIPACOM = "4" .And. STF->TF_TIPACOM = "P" //4=Producao, P=Producao
					lSkipSTI := .F.
				ElseIF M->TI_TIPACOM = "5" .And. STF->TF_TIPACOM = "F" //5=Contador Fixo, F=Contador Fixo
					lSkipSTI := .F.
				ElseIF M->TI_TIPACOM = "6" .And. STF->TF_TIPACOM = "S" //6=Segundo Conta, S=Segundo Conta
					lSkipSTI := .F.
				ElseIf M->TI_TIPACOM = "7"
					lSkipSTI := .F.
				EndIf

				If IIf(Empty(M->TI_SERVINI),.T.,STF->TF_SERVICO >= M->TI_SERVINI .And. STF->TF_SERVICO <= M->TI_SERVFIM) .And.;
				IIf(Empty(M->TI_AREAINI),.T.,STF->TF_CODAREA >= M->TI_AREAINI .And. STF->TF_CODAREA <= M->TI_AREAFIM) .And.;
				IIf(Empty(M->TI_TIPOINI),.T.,STF->TF_TIPO    >= M->TI_TIPOINI .And. STF->TF_TIPO    <= M->TI_TIPOFIM) .And.;
				STF->TF_ATIVO != "N" .And. STF->TF_PLANEJA <> 'N' .And. STF->TF_PERIODO <> "E" .And. lSkipSTI = .F.

					If NGIFDBSEEK('ST4',STF->TF_SERVICO,1,.F.)
						If &(cCondicao)
							If lMNTA3303
								ExecBlock("MNTA3303",.F.,.F.)
							Else

								M->TF_DTULTMA  := STF->TF_DTULTMA
								OLDDAT         := STF->TF_DTULTMA
								dREAL          := M->TF_DTULTMA
								_DTPROX        := dREAL
								_HHPROX        := If(STF->TF_UNENMAN == "H", fUltOSMan(STF->TF_FILIAL, STF->TF_CODBEM, STF->TF_SERVICO, STF->TF_SEQRELA, STF->TF_DTULTMA), 0.00)
								_CONPROX       := 0
								_DTMAKE        := M->TF_DTULTMA
								lFIRST         := .T.
								M->T9_POSCONT  := ST9->T9_POSCONT
								M->T9_CONTACU  := ST9->T9_CONTACU
								M->T9_VARDIA   := ST9->T9_VARDIA
								M->T9_DTULTAC  := ST9->T9_DTULTAC

								// INICIO DO NOVO BLOCO DE CONSISTENCIA
								cCodBem1 := STF->TF_CODBEM
								NGIFDBSEEK('ST9',STF->TF_CODBEM,1,.F.)
								If ST9->T9_TEMCONT <> 'N' .And.  STF->TF_TIPACOM $ "CAPF"

									cBEMAUX := Space(Len(ST9->T9_CODBEM))

									If ST9->T9_TEMCONT == 'I'
										cBEMAUX := NGBEMIME(STF->TF_CODBEM)
									ElseIf ST9->T9_TEMCONT == 'P'
										cBEMAUX := NGBEMPAI(STF->TF_CODBEM)
									EndIf

									If !Empty(cBEMAUX)
										If NGIFDBSEEK('ST9',cBEMAUX,1,.F.)
											M->T9_POSCONT := ST9->T9_POSCONT
											M->T9_VARDIA  := ST9->T9_VARDIA
										EndIf
										_DTMAKE := ST9->T9_DTULTAC

									EndIf
								EndIf
								// FIM DO NOVO BLOCO DE CONSISTENCIA
								NGDBAREAORDE("ST9",3)
								DbGoto(nRECNO)

								nCSTF := aSCAN(aCALESTF,{|x| x[1] == STF->TF_CALENDA})
								If nCSTF = 0
									aDIAMANUT := NG_H7(STF->TF_CALENDA)
									aAdd(aCALESTF,{STF->TF_CALENDA,aDIAMANUT})
								Else
									aDIAMANUT := aCALESTF[nCSTF,2]
								EndIf

								If STF->TF_TIPACOM <> "S"
									// Quantidade de Dias a verificar (incrementa +1 porque o dia inicial também conta)
									nForManuts := ( (M->TI_DATAFIM - M->TF_DTULTMA) + 1 )
									// Caso o incremento da manutenção seja em horas, então multiplica os dias pelas quantidades de O.S. possíveis de serem geradas em um único dia
									If STF->TF_UNENMAN == "H"
										nMaxOSDia := MNTA340MXD(STF->TF_CODBEM, STF->TF_SERVICO, STF->TF_SEQRELA)
										nForManuts := ( nForManuts * nMaxOSDia )
									EndIf

									For N := 1 To nForManuts
										If _DTPROX > M->TI_DATAFIM
											Exit
										EndIf
										If STF->TF_TIPACOM == "C" .Or. STF->TF_TIPACOM == "P"
											If !(A330PROC("C",1))
												Loop
											EndIf
											cTIPMAN := "C"
										ElseIf STF->TF_TIPACOM == "F"
											If lFIRST
												_DTMAKE := ST9->T9_DTULTAC
											EndIf
											If !(A330PROC("F",1))
												Loop
											EndIf
											cTIPMAN := "F"
										ElseIf STF->TF_TIPACOM == "T"
											If !(A330PROC("T",1))
												Loop
											EndIf
											cTIPMAN := "T"
										ElseIf STF->TF_TIPACOM == "A"
											If nMANUCT < 2
												If STF->TF_UNENMAN == "H"
													nIncMan := STF->TF_TEENMAN/24
												ElseIf STF->TF_UNENMAN == "D"
													nIncMan := STF->TF_TEENMAN
												ElseIf STF->TF_UNENMAN == "S"
													nIncMan := STF->TF_TEENMAN * 7
												Else
													nIncMan := STF->TF_TEENMAN * 30
												EndIf
												If nMANUCT == 0
													/*quando vai calcular a primeira OS utiliza as informacoes da manutencao e do bem*/
													dDtTem := STF->TF_DTULTMA + nIncMan
													dDtCom := ST9->T9_DTULTAC+((STF->TF_CONMANU + STF->TF_INENMAN) - ST9->T9_CONTACU) / ST9->T9_VARDIA
													cTIPMAN := If(dDtCom < dDtTem,'C','T')
												ElseIf nMANUCT == 1
													/*e quando vai calcular a proxima, utiliza as informacoes referentes a primeira OS gerada*/
													dbSelectArea(cTRB)
													aAreaTRB := (cTRB)->(GetArea())
													dbSetOrder(03)
													dbGoBottom()
													If !Eof()
														dDtTem := (cTRB)->TF_DTULTMA + nIncMan
														dDtCom := (cTRB)->TF_DTULTMA + Round( ( (cTRB)->TF_INENMAN / ST9->T9_VARDIA ), 0 )
														cTIPMAN := If(dDtCom < dDtTem,'C','T')
													EndIf
													(cTRB)->(RestArea(aAreaTRB))
												EndIf
												nMANUCT++
											EndIf

											If !(A330PROC(cTIPMAN,1))
												Loop
											EndIf

											If cTIPMAN = 'C'
												If M->TI_ATRASAD == "N"
													If _DTPROX >= M->TI_DATAINI
													Else
														dREAL     := _DTPROX
														dDPRIREAL := Ctod("  /  /  ") //dREAL
														Loop
													EndIf
												EndIf
											Else
												If M->TI_ATRASAD == "N"
													If _DTPROX >= M->TI_DATAINI
													Else
														dREAL     := _DTPROX
														dDPRIREAL := Ctod("  /  /  ") //dREAL
														Loop
													EndIf
												EndIf
											EndIf
										Else
											Loop
										EndIf

										dbSelectArea(cTRB)
										DbAppend()
										For i := 1 To STF->(Fcount())
											x   := "STF->"+STF->(Fieldname(i))
											y   := "(cTRB)->"+STF->(Fieldname(i))
											&y. := &x.
										Next i

										nCONT2 := 0
										If NGIFDBSEEK('TPE',ccCODBEM,1,.F.)
											nCONT2 := TPE->TPE_POSCON
										EndIf

										Replace (cTRB)->DTULTPROC  With MAX(M->TF_DTULTMA,ST9->T9_DTULTAC)
										Replace (cTRB)->PRIOBEM    With ST9->T9_PRIORID
										Replace (cTRB)->CALENDA    With ST9->T9_CALENDA
										Replace (cTRB)->DTULTMA    With OLDDAT
										Replace (cTRB)->DTPROX     With _DTPROX
										Replace (cTRB)->CONPROX    With _CONPROX
										If STF->TF_UNENMAN == "H" // Se for uma Manutenção em Horas
											Replace (cTRB)->HRREAL With NTOH( _HHPROX ) //Converte em Horas '_HHPROX'
											Replace (cTRB)->DTREAL With _DTPROX
										Else
											Replace (cTRB)->DTREAL With dREAL
										EndIf
										Replace (cTRB)->CCUSTO     With ST9->T9_CCUSTO
										Replace (cTRB)->CENTRAB    With ST9->T9_CENTRAB
										Replace (cTRB)->VARDIA     With M->T9_VARDIA
										Replace (cTRB)->TF_DTULTMA With dREAL
										Replace (cTRB)->FERRAMENTA With ST9->T9_FERRAME
										Replace (cTRB)->POSCPR1    With nPoscCpr
										If n330Tole > 0
											Replace (cTRB)->DTLIMTOL With fCalcTol( cTIPMAN , 1 , dREAL , n330Tole ) //Calcula Tolerancia
										EndIf

										If lPE3304  .And. lTRB3304 .And. STF->TF_TIPACOM == "T"
											If cSEQAU = STF->TF_SEQRELA
												dbSelectArea(cTRB330)
												DbAppend()
												(cTRB330)->DATAPLA := dREAL
											Else
												//Ponto de entrada para fazer ajuste de datas para manutencoes por tempo
												If lPRIMNTEM
													ExecBlock("MNTA3304",.F.,.F.)
												EndIf
											EndIf
										EndIf

										If STF->TF_PERIODO == "U"
											Exit
										EndIf
									Next
								EndIf

							EndIf
						Else
							fGravPrb(STR0072,STF->TF_CODBEM,STF->TF_SERVICO,STF->TF_SEQRELA)  //"Serviço não atende ao tipo do plano (lubrificação)."
						EndIf
					EndIf
				Else
					If STF->TF_ATIVO == "N"
						fGravPrb(STR0074,STF->TF_CODBEM,STF->TF_SERVICO,STF->TF_SEQRELA)  //"No cadastro de manutenção a situação da manutenção está como 'Inativo'."
					EndIf
					If STF->TF_PLANEJA == 'N'
						fGravPrb(STR0075,TF_CODBEM,STF->TF_SERVICO,STF->TF_SEQRELA)  //"Manutenção não considera planejamento."
					EndIf
					If STF->TF_PERIODO = "E"
						fGravPrb(STR0095,TF_CODBEM,STF->TF_SERVICO,STF->TF_SEQRELA)  //"Periodo da manutencao é eventual."
					EndIf
					If lSkipSTI == .T.
						fGravPrb(STR0076+" '"+NGRETSX3BOX("TF_TIPACOM",STF->TF_TIPACOM)+"' "+;  //"Tipo do acompanhamento da manutenção"
						STR0077+" '"+NGRETSX3BOX("TI_TIPACOM",M->TI_TIPACOM)+"'.",;  //"é diferente do tipo acompanhamento do plano"
						STF->TF_CODBEM,STF->TF_SERVICO,STF->TF_SEQRELA)
					EndIf
				EndIf
				NGDBSELSKIP("STF")
			End

			// INICIO DO PROCESSO DO SEGUNDO CONTADOR
			If NGIFDBSEEK('TPE',ccCODBEM,1,.F.)
				NGIFDBSEEK('STF',TPE->TPE_CODBEM,1,.F.)
				OLDDAT        := STF->TF_DTULTMA
				M->TF_DTULTMA := STF->TF_DTULTMA
				OLDSERV       := Space(6)

				If !(STF->(!Eof()) .And. STF->TF_FILIAL == xFilial('STF') .And. STF->TF_CODBEM == ccCODBEM)
					fGravPrb(STR0071,ccCODBEM)  //"Não existem manutenções para o bem."
				EndIf

				While STF->(!Eof()) .And. STF->TF_FILIAL == xFilial('STF') .And. STF->TF_CODBEM == ccCODBEM
					dDPRIREAL := Ctod('  /  /  ')
					nDTREAL   := 0
					nMANUCT   := 0
					lCONTREAL := .F.
					lATRASA   := .F.
					lINCONT   := .t.
					lCONTFIXO := .t.
					cTIPMAN   := Space(1)

					If STF->TF_TIPACOM = "S"
						If IIf(Empty(M->TI_SERVINI),.T.,STF->TF_SERVICO >= M->TI_SERVINI .And. STF->TF_SERVICO <= M->TI_SERVFIM) .And.;
						IIf(Empty(M->TI_AREAINI),.T.,STF->TF_CODAREA >= M->TI_AREAINI .And. STF->TF_CODAREA <= M->TI_AREAFIM) .And.;
						IIf(Empty(M->TI_TIPOINI),.T.,STF->TF_TIPO    >= M->TI_TIPOINI .And. STF->TF_TIPO    <= M->TI_TIPOFIM) .And.;
						STF->TF_ATIVO != "N" .And. STF->TF_PLANEJA <> 'N' .And. STF->TF_PERIODO <> "E"
							If NGIFDBSEEK('ST4',STF->TF_SERVICO,1,.F.)
								If &(cCondicao)
									lPrimCPr := .F.
									nIncCPr  := 0
									nPoscCpr := 0
									DDataCPr := Ctod("  /  /  ")
									If lMNTA3303
										ExecBlock("MNTA3303",.F.,.F.)
									Else
										M->TF_DTULTMA := STF->TF_DTULTMA
										OLDDAT        := STF->TF_DTULTMA
										dREAL         := M->TF_DTULTMA
										_DTPROX       := dREAL
										_HHPROX       := If(STF->TF_UNENMAN == "H", fUltOSMan(STF->TF_FILIAL, STF->TF_CODBEM, STF->TF_SERVICO, STF->TF_SEQRELA, STF->TF_DTULTMA), 0.00)
										_CONPROX      := 0
										_DTMAKE       := M->TF_DTULTMA
										lFIRST        := .T.
										M->T9_POSCONT := TPE->TPE_POSCON
										M->T9_CONTACU := TPE->TPE_CONTAC
										M->T9_VARDIA  := TPE->TPE_VARDIA
										_DTMAKE       := TPE->TPE_DTULTA
										M->T9_DTULTAC := TPE->TPE_DTULTA

										If !Empty(STF->TF_CONTADO) .And. STF->TF_TIPACOM = "S"
											nRECNO := TPE->(Recno())
											TPE->(dbSetOrder(1))
											If TPE->(dbSeek(xFilial("TPE")+STF->TF_CONTADO))
												M->T9_POSCONT := TPE->TPE_POSCON
												M->T9_VARDIA  := TPE->TPE_VARDIA
											EndIf
											TPE->(DbGoto(nRECNO))
											_DTMAKE := TPE->TPE_DTULTA
											M->T9_DTULTAC := TPE->TPE_DTULTA
										EndIf
										If STF->TF_TIPACOM = "S"

											For N := 1 To ((M->TI_DATAFIM - M->TF_DTULTMA)+1)
												If _DTPROX > M->TI_DATAFIM
													Exit
												EndIf
												If lFIRST
													_DTMAKE := TPE->TPE_DTULTA
												EndIf
												If !(A330PROC("C",2))
													Loop
												EndIf
												If M->TI_ATRASAD == "N"
													If _DTPROX >= M->TI_DATAINI
													Else
														dREAL     := _DTPROX
														//  dDPRIREAL := Ctod("  /  /  ") //dREAL
														Loop
													EndIf
												EndIf
												(cTRB)->(DbAppend())
												For i := 1 TO STF->(Fcount())
													x   := "STF->"+STF->(Fieldname(i))
													y   := "(cTRB)->"+STF->(Fieldname(i))
													&y. := &x.
												Next i
												Replace (cTRB)->DTULTPROC  With MAX(M->TF_DTULTMA,ST9->T9_DTULTAC)
												Replace (cTRB)->PRIOBEM    With ST9->T9_PRIORID
												Replace (cTRB)->CALENDA    With ST9->T9_CALENDA
												Replace (cTRB)->DTULTMA    With OLDDAT
												Replace (cTRB)->DTPROX     With _DTPROX
												Replace (cTRB)->CONPROX    With _CONPROX
												Replace (cTRB)->DTREAL     With dREAL
												If STF->TF_UNENMAN == "H" // Se for uma Manutenção em Horas
													Replace (cTRB)->HRREAL With NTOH(_HHPROX)
												EndIf
												Replace (cTRB)->CCUSTO     With ST9->T9_CCUSTO
												Replace (cTRB)->CENTRAB    With ST9->T9_CENTRAB
												Replace (cTRB)->VARDIA     With M->T9_VARDIA
												Replace (cTRB)->TF_DTULTMA With dREAL
												Replace (cTRB)->FERRAMENTA With ST9->T9_FERRAME
												Replace (cTRB)->POSCPR2    With nPoscCpr
												If n330Tole > 0
													Replace (cTRB)->DTLIMTOL With fCalcTol( cTIPMAN , 2 , dREAL , n330Tole ) //Calcula Tolerancia
												EndIf
												If STF->TF_PERIODO == "U"
													Exit
												EndIf
											Next
										EndIf
									EndIf
								Else
									fGravPrb(STR0072,STF->TF_CODBEM,STF->TF_SERVICO,STF->TF_SEQRELA)  //"Serviço não atende ao tipo do plano (lubrificação)."
								EndIf
							EndIf
						Else
							If STF->TF_ATIVO == "N"
								fGravPrb(STR0074,STF->TF_CODBEM,STF->TF_SERVICO,STF->TF_SEQRELA)  //"No cadastro de manutenção a situação da manutenção está como 'Inativo'."
							EndIf
							If STF->TF_PLANEJA == 'N'
								fGravPrb(STR0075,TF_CODBEM,STF->TF_SERVICO,STF->TF_SEQRELA)  //"Manutenção não considera planejamento."
							EndIf
							If STF->TF_PERIODO = "E"
								fGravPrb(STR0095,TF_CODBEM,STF->TF_SERVICO,STF->TF_SEQRELA)  //"Periodo da manutencao é eventual."
							EndIf
							If lSkipSTI == .T.
								fGravPrb(STR0076+" '"+NGRETSX3BOX("TF_TIPACOM",STF->TF_TIPACOM)+"' "+;  //"Tipo do acompanhamento da manutenção"
								STR0077+" '"+NGRETSX3BOX("TF_TIPACOM",M->TI_TIPACOM)+"'.",;  //"é diferente do tipo acompanhamento do plano"
								STF->TF_CODBEM,STF->TF_SERVICO,STF->TF_SEQRELA)
							EndIf
						EndIf
					EndIf
					NGDBSELSKIP("STF")
				End
			EndIf // FIM DO PROCESSO DO SEGUNDO CONTADOR
		EndIf

		If lTRB3304
			dbSelectArea(cTRB330)
			Zap
		EndIf

		If !lPlaEstu
			NGDBAREAORDE("ST9",3)
			DbGoto(nRECNO)
			dbSkip()
		Else
			nIcEst ++
		EndIf

	End

	NGSETIFARQUI((cTRB),,1)

	If Eof()

		dbSelectArea(cTRBPRB)
		If lMVMOINP
			If (cTRBPRB)->(RecCount()) == 0
				fGravPrb(STR0067+M->TI_PLANO+STR0073)  //"Conforme a parametrização do plano "##", não foi identificada nenhuma manutenção para a geração de ordem de serviço."
			EndIf
			If MsgYesNo(STR0079+CRLF+STR0080)  //"Foram encontradas inconsistências na geração de Ordens de Serviço"##"para o plano. Deseja imprimir o relatório?"
				f330RImp()
			EndIf
		Else
			ShowHelpDlg("OSNAOEXIST2",{STR0089,STR0090},2,;  //"Não foram geradas Ordens de Serviço"##"para este plano."
			{STR0091,STR0092},2)  //"Configure o parâmetro MV_NGMOINP para"##"visualizar inconsistências do plano."
		EndIf
		NGDELETAREG("STI")
		MNTA330TRBA()
		Return .T.
	EndIf

	aArrCal := {}

	NGSETIFARQUI((cTRB),,1)
	ProcRegua(Reccount())
	While !(cTRB)->(Eof()) .and. !lCanc330

		lVerBem := .T. //Variável utilizada para controle do BEM.
		cCodBM  := (cTRB)->tf_codbem
		cCodSM  := (cTRB)->tf_servico
		cCodSR  := (cTRB)->tf_seqrela
		aTarEsp := {}
		nNumMan := 1

		If NGIFDBSEEK("STG",(cTRB)->tf_CodBem+(cTRB)->tf_servico+(cTRB)->tf_seqrela,1,.F.)
			While !Eof() .And. stg->tg_filial = Xfilial("STG")   .And. stg->tg_codbem = (cTRB)->tf_codbem;
			.And. stg->tg_servico = (cTRB)->tf_servico .And. stg->tg_seqrela = (cTRB)->tf_seqrela
				If stg->tg_tiporeg = "E"
					If aSCAN(aTarEsp,{|x| x[1]+Str(x[2],3) == SubStr(STG->TG_CODIGO,1,Len(SpEsp))+Str(STG->TG_QUANREC,3)}) = 0
						aAdd(aTarEsp,{SubStr(STG->TG_CODIGO,1,Len(SpEsp)),STG->TG_QUANREC,0,{}})
					EndIf
				EndIf
				NGDBSELSKIP("STG")
			End
		End

		dLastDate := (cTRB)->DTREAL

		While !(cTRB)->(Eof()) .And. (cTRB)->tf_codbem = cCodBM .And. (cTRB)->tf_servico = cCodSM .And. (cTRB)->tf_seqrela = cCodSR .and. !lCanc330
			IncProc(OEMTOANSI(STR0012)) //"Processando a Manutencao"

			If dLastDate <> (cTRB)->DTREAL //Verifica se a última data é diferente da data corrente.
				lFrtInput := .F. //Nova Insumo
				nHorasSTJ := "00:00"
			EndIf

			//Carrega os funcionários da especialidade, conforme a quantidade necessaria (TG_QUANREC)
			For nFe := 1 To Len(aTarEsp)
				vArEspD        := NGRETFUNESP(aTarEsp[nFe,1])
				aTarEsp[nFe,4] := {}
				For nFr := 1 To aTarEsp[nFe,2]
					If Empty(aTarEsp[nFe,3])
						If aTarEsp[nFe,2] = 1
							nItem := aTarEsp[nFe,3]+1
							nItem := If(nItem > Len(vArEspD),1,nItem)
							aTarEsp[nFe,3] := nItem
						Else
							If nFr = 1
								nItem := aTarEsp[nFe,3]+1
								nItem := If(nItem > Len(vArEspD),1,nItem)
								aTarEsp[nFe,3] := nItem
							Else
								nItem := aTarEsp[nFe,3] + Len(aTarEsp[nFe,4])
								If nItem > Len(vArEspD)
									nItem := 1
									aTarEsp[nFe,3] := nItem
								EndIf
							EndIf
						EndIf
					Else
						If aTarEsp[nFe,2] = 1
							nItem := aTarEsp[nFe,3]+1
							nItem := If(nItem > Len(vArEspD),1,nItem)
							aTarEsp[nFe,3] := nItem
						Else
							If nFr = 1
								nItem := aTarEsp[nFe,3] + 1
								nItem := If(nItem > Len(vArEspD),1,nItem)
								aTarEsp[nFe,3] := nItem
							Else

								If aTarEsp[nFe,2] = 6
									X := 1
								EndIf

								nItem := aTarEsp[nFe,3] + Len(aTarEsp[nFe,4])
								If nItem > Len(vArEspD)
									nItem := 1
									aTarEsp[nFe,3] := nItem
								EndIf
							EndIf
						EndIf
					EndIf

					If Len(vArEspD) >= nItem
						aAdd(aTarEsp[nFe,4],vArEspD[nItem])
					EndIf

				Next nFr

			Next nFe

			aDIAMAN := {}
			nPosC := aSCAN(aArrCal,{|x| x[1] == (cTRB)->tf_calenda})

			aDIAMAN := If(nPosc > 0,aArrCal[nPosc,2],NG_H7((cTRB)->TF_CALENDA))
			If nPosc = 0
				If Len(aDIAMAN) > 0
					aAdd(aArrCal,{(cTRB)->tf_calenda,aDIAMAN})
				EndIf
			EndIf

			If Len(aDIAMAN) == 0
				Help(" ",1,"CALENDINEX",,CHR(13) + STR0049 + (cTRB)->TF_CALENDA ,3,0) //"Calendário : "
				NGDELETAREG("STI")
				MNTA330TRBA()
				Return .F.
			EndIf

			lSTJ := .F.
			nQtdOSDia := 0
			nMaxOSDia := MNTA340MXD((cTRB)->TF_CODBEM, (cTRB)->TF_SERVICO, (cTRB)->TF_SEQRELA)
			cAliasQry := GetNextAlias()
			cQuery := " SELECT COUNT(*) TOTAL "
			cQuery += " FROM "+RetSqlName("STJ")
			cQuery += " WHERE TJ_PLANO   = '"+M->TI_PLANO+"' AND TJ_TIPOOS = 'B' AND"
			cQuery += "       TJ_CODBEM  = '"+(cTRB)->TF_CODBEM+"' AND TJ_FILIAL = '"+xFilial("STJ")+"' AND"
			cQuery += "       TJ_SERVICO = '"+(cTRB)->TF_SERVICO+"' AND TJ_SEQRELA = '"+(cTRB)->TF_SEQRELA+"' AND"
			cQuery += "       TJ_DTORIGI = '"+DTOS((cTRB)->DTPROX)+"' AND D_E_L_E_T_ != '*'"
			cQuery := ChangeQuery(cQuery)
			dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)

			dbSelectArea(cAliasQry)
			dbGoTop()
			nQtdOSDia := (cAliasQry)->TOTAL
			(cAliasQry)->(dbCloseArea())
			// Se a quantidade de O.S. existente para o Dia já for igual ou superior ao máximo permitido, então não poderá incluir nova O.S.
			If nQtdOSDia >= nMaxOSDia
				lSTJ := .T.
			EndIf

			If !lSTJ
				If lMNTA3308
					lSTJ := ExecBlock( 'MNTA3308', .F., .F., {cTrb, aMNTA3308})
				EndIf
			EndIf
			If lSTJ
				NGDBSELSKIP(cTRB)
				Loop
			EndIf

			NGDBAREAORDE("STJ",1)
			cORDEM := CRIAVAR("TJ_ORDEM",.T.)   //Numera no Planejamento
			CONFIRMSX8()

			aTAREFA := A330TAREFA( , cNGFLUT, cNGUNIDT, cPRODTER, cNGLOCPA )  //Retorna aTAREFA contendo Inicio e Fim das Tarefas

			If Empty(aTAREFA)
				nSEM := If(DOW((cTRB)->DTREAL)==1,7,DOW((cTRB)->DTREAL)-1)
			EndIf

			If (cTRB)->TF_UNENMAN == "H" // Se for uma Manutenção em Horas

				If !Empty( aTAREFA ) //Possui insumo atrelado há manutenção

					aAreaSTG := GetArea()

					dbSelectArea( "STG" )
					dbSetOrder( 01 ) //TG_FILIAL+TG_CODBEM+TG_SERVICO+TG_SEQRELA+TG_TAREFA+TG_TIPOREG+TG_CODIGO
					If dbSeek( xFilial( "STG" ) + (cTRB)->TF_CODBEM + (cTRB)->TF_SERVICO + (cTRB)->TF_SEQRELA )
						cQuantid := STG->TG_QUANTID //Quantidade de horas do insumo
					Else
						cQuantid := 0 //Quantidade de horas do insumo
					EndIf

					hINI := (cTRB)->HRREAL //Hora Inicio Manut. Prev.
					dINI := (cTRB)->DTREAL //Data Inicio Manut. Prev.
					hFIM := NTOH( SomaHoras( (cTRB)->HRREAL,cQuantid )) //Hora Fim Manut. Prev.
					dFIM := (cTRB)->DTREAL //Data Fim Manut. Prev.

					If hFIM > NTOH( 24 ) //Se for maior que 24 horas
						hFIM := NTOH( SubHoras( hFIM,24 )) //Calcula a hora Fim do próximo dia
						dFIM := (cTRB)->DTREAL + 1 // O término da O.S. será no dia seguinte, ou seja, incrementa a Data Final da O.S.
					EndIf

					RestArea( aAreaSTG )

				Else
					dbSelectArea("STF")
					aHrsCal := NG_H7((cTRB)->TF_CALENDA)
					aCalenda := NGCALENDAH( (cTRB)->TF_CALENDA ) //Monta um array com todas as horas do calendário da manutenção.
					hFIM := SomaHoras( (cTRB)->HRREAL,(cTRB)->TF_TEENMAN ) //Calcula a hora Fim do próximo dia
					dFIM := (cTRB)->DTREAL //Data Fim Manut. Prev.

					For nK := 1 To Len( aCalenda[ 2 ][ 2 ] ) //Verifica quantas quebras possui o calendário da manutenção

						//Se estiver fora do período do calendário;
						If Len( aCalenda[ 2 ][ 2 ] ) <> 1
							If aCalenda[2][2][nK][1] > NTOH( hFIM ) .Or. aCalenda[2][2][nK][2]  > NTOH( hFIM )
								hFIM := NtoH(hFIM)
								Exit
							Else
								If hFIM > HTON( aHrsCal[1][2] ) //Se a qtd de horas for maior que a qtd máxima de hrs do calendario.
									hFIM := aHrsCal[1][1]
									dFIM++ //A próxima manutenção irá acontecer no próximo dia;

									While A330DUTIL(dFIM,aHrsCal)
										dFIM++
										Loop
									End While

									Exit
								ElseIf hFIM == HTON( aHrsCal[1][2] ) //Se a qtd de horas for igual ao último horário do calendário;
									hFIM := aHrsCal[1][2] //Atribui o último horario do calendário;
									Exit
								EndIf
							EndIf
						Else
							If hFIM >= HTON( aHrsCal[1][2] ) //Se a qtd de horas for maior que a qtd máxima de hrs do calendario.
								//Verifica se a hora de incremento passo de 1 dia
								If hFIM >= 24
									hFIM :=  ( hFIM - 24 )
									//Verifica se na dentro do intervalo de horas do calendário
									If aCalenda[2][2][1][1] <= NTOH( hFIM ) .And. aCalenda[2][2][1][2]  >= NTOH( hFIM )
										hFIM := NTOH(hFIM)
									ElseIf aCalenda[2][2][1][1]  > NTOH( hFIM )
										hFIM := aHrsCal[1][1]
									EndIf
								Else
									hFIM := aHrsCal[1][1]
								EndIf

								dFIM++ //A próxima manutenção irá acontecer no próximo dia;

								While A330DUTIL(dFIM,aHrsCal)
									dFIM++
									Loop
								End While

								Exit
							Else
								hFIM := NtoH(hFIM) //Atribui o último horario do calendário;
								dFIM := (cTRB)->DTREAL //Data Fim Manut. Prev.
								Exit
							EndIf
						EndIf

					Next nK

					dINI := (cTRB)->DTREAL //Data Inicio Manut. Prev.
					hINI := (cTRB)->HRREAL //Hora Inicio Manut. Prev.
					If nK == 0
						hFIM := NTOH( SomaHoras( (cTRB)->HRREAL,(cTRB)->TF_TEENMAN )) //Soma as Horas ( Qtdade de Horas + Incremento )
						dFIM := (cTRB)->DTREAL //Data Fim Manut. Prev.
					EndIf

				EndIf

			Else
				dINI := If( !Empty(aTAREFA),aTAREFA[1][4][1],(cTRB)->DTREAL )
				hINI := If( !Empty(aTAREFA),aTAREFA[1][4][2],aDIAMAN[nSEM][1] )
				dFIM := If( !Empty(aTAREFA),aTAREFA[Len(aTAREFA)][4][3],(cTRB)->DTREAL )
				hFIM := If( !Empty(aTAREFA),aTAREFA[Len(aTAREFA)][4][4],aDIAMAN[nSEM][1] )

				// Se não for a primeira O.S.
				If ValType(dOldDtINI) <> "U" .And. ValType(cOldHrINI) <> "U" .And. ValType(dOldDtFIM) <> "U" .And. ValType(dOldDtINI) <> "U"
					// Se puder haver mais de uma O.S. por dia, e esta manutenção for para o mesmo dia da anterior, então temos que colocar esta manutenção para um perído posterior a anterior, porém, na MESMA DATA da Manutenção Prevista
					If nMaxOSDia > 1 .And. dINI == dOldDtINI .And. dFIM == dOldDtFIM
						// Recebe a Quantidade de Horas entre o Início e o Fim da Manutenção
						nTempoDeco := NGCALENHORA(dINI, hINI, dFIM, hFIM, (cTRB)->TF_CALENDA)

						// Define a Data/Hora Início atual como a Data/Hora Fim anterior
						dINI := dOldDtFIM
						hINI := cOldHrFIM

						// Calcula o novo término da manutenção
						aNewTermino := aClone( NGDTHORFCALE(dINI, hINI, nTempoDeco, (cTRB)->TF_CALENDA) )

						// Define a nova Data/Hora Fim atual
						dFIM := aNewTermino[1]
						hFIM := aNewTermino[2]
					EndIf
				EndIf
				dOldDtINI := dINI //Data Inicio Manut. Prev.
				cOldHrINI := hINI //Hora Inicio Manut. Prev.
				dOldDtFIM := dFIM //Data Fim Manut. Prev.
				cOldHrFIM := hFIM //Hora Fim Manut. Prev
			EndIf

			lParada := (cTRB)->TF_PARADA == "S" .Or. (cTRB)->TF_PARADA == "T"

			//---------------------------------------------
			//Calcula o Tempo de Parada antes da manutencao
			//---------------------------------------------
			Store Ctod("  /  /  ") To dPRE,dPOS
			Store Space(05)        To hPRE,hPOS

			//Calcula o Tempo de Parada depois da manutencao
			If lParada
				MNT330CDHP(dINI,hINI,"A") // Tempo anterior à manutencao
				MNT330CDHP(dFIM,hFIM,"D") // Tempo posterior à manutencao
			EndIf

			//Verifica se ja existe a Ordem de Servico na STJ
			If lMNTA330V
				lExistOS := ExecBlock( 'MNTA330V', .F., .F., { cORDEM } )
			EndIf

			If lExistOS
				DbSelectArea(cTRB)
				dbSkip()
				Loop
			EndIf

			// Caso haja parada do bem, haja integracao com o modulo de Chao de Fabrica,
			// verifica se sera possivel incluir a parada programada relacionada.
			// Caso nao seja possivel, procede conforme conteudo do parametro MV_NGSEGPL.
			If lParada .And. !Empty(cIntSFC) .And. ;
			( !Empty(cRecSFC := NGVRFMAQ((cTRB)->TF_CODBEM) ) .And. ;
			!NGSFCINCPP(cRecSFC ,dPRE, hPRE, dPOS, hPOS, cOrdem, cIntSFC, (cTRB)->TF_CALENDA, .F., .F.))

				// Armazena registro para posterior avaliação de processo
				aAdd(aSFCErro,{"",(cTRB)->TF_CODBEM, dPRE, hPRE, dPOS, hPOS})
				RollBackSX8()

				// Procedimento confome parametro MV_NGSEGPL
				// Caso erros sejam encontrados durante a geracao do plano, prosegue com o plano, ou efetua cancelamento do mesmo
				If GetNewPar("MV_NGSEGPL", 1) == 1
					NGDBSELSKIP(cTRB)
					Loop
				Else
					lCanc330 := .T.
					Exit
				EndIf

			Else
				ConfirmSX8()
			EndIf

			//Tratamento para evitar duplicação de número de O.S. em base
			aArea := GetArea()

			dbSelectArea( "STJ" )
			dbSetOrder( 01 )
			While dbSeek( xFilial( "STJ" ) + cORDEM)

				ConfirmSX8()
				cORDEM := GetSXENum( "STJ","TJ_ORDEM" )

			End While
			RestArea( aArea )

			//Grava no arquivo de Ordem Servico - STJ
			dbSelectArea("STJ")
			STJ->(RecLock("STJ",.T.))
			Replace STJ->TJ_FILIAL  With xFilial("STJ")
			Replace STJ->TJ_ORDEM   With cORDEM
			Replace STJ->TJ_PLANO   With M->TI_PLANO
			Replace STJ->TJ_CODBEM  With (cTRB)->TF_CODBEM
			Replace STJ->TJ_TIPOOS  With "B"
			Replace STJ->TJ_SERVICO With (cTRB)->TF_SERVICO
			Replace STJ->TJ_SEQRELA With (cTRB)->TF_SEQRELA
			Replace STJ->TJ_DTORIGI With (cTRB)->DTPROX
			Replace STJ->TJ_TIPO    With (cTRB)->TF_TIPO
			Replace STJ->TJ_CODAREA With (cTRB)->TF_CODAREA
			Replace STJ->TJ_CCUSTO  With (cTRB)->CCUSTO
			Replace STJ->TJ_DTULTMA With (cTRB)->DTULTMA
			Replace STJ->TJ_COULTMA With (cTRB)->TF_CONMANU
			Replace STJ->TJ_DTMPINI With dINI
			Replace STJ->TJ_HOMPINI With hINI
			If dFim = cToD("01/01/80")
				dFim := dIni
				hFim := hIni
			EndIf
			Replace STJ->TJ_DTMPFIM With dFIM
			Replace STJ->TJ_HOMPFIM With If(Empty(hFIM) .Or. Alltrim(hFIM) = ":",hINI,hFIM)
			Replace STJ->TJ_SITUACA With "P"
			Replace STJ->TJ_TERMINO With "N"
			Replace STJ->TJ_USUARIO With If(Len(STJ->TJ_USUARIO) > 15,cUsername,Substr(CUSUARIO,7,15))
			Replace STJ->TJ_CENTRAB With (cTRB)->CENTRAB
			Replace STJ->TJ_PRIORID With (cTRB)->TF_PRIORID
			Replace STJ->TJ_DTPPINI With dPRE
			Replace STJ->TJ_HOPPINI With hPRE
			Replace STJ->TJ_DTPPFIM With dPOS
			Replace STJ->TJ_HOPPFIM With hPOS
			Replace STJ->TJ_LUBRIFI With NGSEEK("ST4",(cTRB)->TF_SERVICO,1,'T4_LUBRIFI')
			Replace STJ->TJ_TERCEIR With '1'
			dbSelectArea("STJ")
			If FieldPos("TJ_POSCPR1") > 0
				Replace STJ->TJ_POSCPR1 With (cTRB)->POSCPR1
			EndIf
			If FieldPos("TJ_POSCPR2") > 0
				Replace STJ->TJ_POSCPR2 With (cTRB)->POSCPR2
			EndIf

			Replace STJ->TJ_CONTINI With (cTRB)->POSCPR1
			Replace STJ->TJ_USUAINI With If(Len(STJ->TJ_USUAINI) > 15,cUsername,Substr(CUSUARIO,7,15))

			If lMMoeda
				STJ->TJ_MOEDA := "1"
			EndIf

			//Grava o status da ordem de servico se o servico for contralado por follow-up
			dbSelectArea("ST4")
			If NGSEEK("ST4",(cTRB)->TF_SERVICO,1,'T4_FOLLOWU') = "S"
				cTQWSta := NGSEEK("TQW","6 ",3,'TQW_STATUS')
				If !Empty(cTQWSta)
					STJ->TJ_STFOLUP := cTQWSta
				EndIf
			EndIf

			dbSelectArea("STJ")
			If FieldPos("TJ_RESPEQ") > 0
				If !Empty(NGSEEK("TP4",(cTRB)->TF_EQUIPE,1,'TP4_CODRES'))
					Replace STJ->TJ_RESPEQ With TP4->TP4_CODRES
				EndIf
			EndIf
			dbSelectArea("STJ")
			STJ->(MsUnLock())

			If lMNTA3306
				ExecBlock("MNTA3306",.F.,.F.)
			EndIf

			dORIGINAL := (cTRB)->DTPROX
			dINIREAL  := If(Empty(dPRE),dINI,dPRE)
			hINIREAL  := IF(Empty(hPRE),hINI,hPRE)
			dFIMREAL  := If(Empty(dPOS),dFIM,dPOS)
			hFIMREAL  := If(Empty(hPOS),hFIM,hPOS)

			//Efetua o bloqueio do Bem para a data de Manutencao
			If lParada
				A330BEM(dINIREAL,hINIREAL,dFIMREAL,hFIMREAL,(cTRB)->TF_CODBEM,(cTRB)->TF_PARADA,(cTRB)->CCUSTO)
			EndIf

			//Efetua o bloqueio da Ferramenta se o Bem (ST9) estiver indicando uma ferramenta (T9_FERRAME)
			If (cTRB)->FERRAMENTA == "F"
				cCODFER := NGSEEK("ST9",(cTRB)->TF_CODBEM,1,"T9_RECFERR")
				If !Empty(cCODFER)
					aFER := {}
					aAdd(aFER, {"0",cCODFER,1,dINIREAL,hINIREAL,dFIMREAL,hFIMREAL,cORDEM,M->TI_PLANO,(cTRB)->CCUSTO})
					A330FER(aFER[1],(cTRB)->TF_CODBEM)
				EndIf
			EndIf

			//Grava no arquivo de Recursos da Ordem Servico - STL
			aBLO    := {{},{},{},{},{}}
			aTarSeq := {}

			dPINI := Ctod("  /  /  ")
			hPINI := Space(5)
			dPFIM := Ctod("  /  /  ")
			hPFIM := Space(5)

			For i := 1 To Len(aTAREFA)
				//checa se tarefa esta ativa
				If !f330TRFAT((cTRB)->TF_CODBEM,(cTRB)->TF_SERVICO,(cTRB)->TF_SEQRELA,aTAREFA[i][1])
					Loop
				EndIf
				For x := 1 To Len(aTAREFA[i][5])
					//Calcula o Custo Previsto e Grava no STL
					cTIPOREG := aTAREFA[i][5][x][1]
					cCODIGO  := Trim(aTAREFA[i][5][x][2])
					nQTD     := aTAREFA[i][5][x][4]
					nHH      := (aTAREFA[i][5][x][12]/60)
					nTarSeq  := Ascan(aTarSeq,{|x| x[1] == aTAREFA[i][1]})

					If Empty(nTarSeq)
						aAdd(aTarSeq,{aTAREFA[i][1],1})
						cSeqTar := Padr(1,3)
					Else
						aTarSeq[nTarSeq,2] ++
						cSeqTar := Padr(aTarSeq[nTarSeq,2],3)
					EndIf
					If !NGIFDBSEEK("STL",STJ->TJ_ORDEM+M->TI_PLANO+aTAREFA[i][1];
					+aTAREFA[i][5][x][1]+aTAREFA[i][5][x][2];
					+"0  "+cSeqTar,1,.F.)

						If aTAREFA[i][5][x][1] == "P" .And. !NGPROBLQ(aTAREFA[i][5][x][2]) //Se o tipo do insumo for PRODUTO e estiver BLOQUEADO.
							MNTGRAVSTA( STJ->TJ_ORDEM , M->TI_PLANO , aTAREFA[i][1] , "P" , aTAREFA[i][5][x][2] , STR0096 ) //"Produto Bloqueado."
							Loop
						EndIf

						STL->(RecLock("STL",.T.))
						STL->TL_FILIAL  := xFilial("STL")
						STL->TL_ORDEM   := STJ->TJ_ORDEM
						STL->TL_PLANO   := M->TI_PLANO
						STL->TL_TAREFA  := aTAREFA[i][1]
						STL->TL_SEQRELA := "0  "
						STL->TL_DTINICI := aTAREFA[i][5][x][7]
						STL->TL_HOINICI := aTAREFA[i][5][x][8]
						STL->TL_DTFIM   := aTAREFA[i][5][x][9]
						STL->TL_HOFIM   := aTAREFA[i][5][x][10]
						STL->TL_TIPOREG := aTAREFA[i][5][x][1]
						STL->TL_CODIGO  := aTAREFA[i][5][x][2]
						STL->TL_QUANREC := aTAREFA[i][5][x][3]
						STL->TL_QUANTID := aTAREFA[i][5][x][4]
						STL->TL_UNIDADE := aTAREFA[i][5][x][5]
						STL->TL_DESTINO := aTAREFA[i][5][x][6]
						STL->TL_TIPOHOR := cNGUNIDT
						STL->TL_USACALE := "N"

						If STL->TL_TIPOHOR == "D" .And. (STL->TL_TIPOREG <> "P" .And. AllTrim(STL->TL_UNIDADE) == "H")
							STL->TL_QUANTID := NGCONVERHORA(aTAREFA[i][5][x][4],"S","D")
						EndIf

						If NGCADICBASE("TL_SEQTARE","A","STL",.F.)
							STL->TL_SEQTARE := cSeqTar
						EndIf

						If STL->TL_TIPOREG = 'P'
							STL->TL_LOCAL := If(!Empty(aTAREFA[i][5][x][13]),aTAREFA[i][5][x][13],NGSEEK("SB1",STL->TL_CODIGO,1,"B1_LOCPAD"))
						ElseIf STL->TL_TIPOREG = 'T'
							cCodTer := If(FindFunction("NGProdMNT"), NGProdMNT("T")[1], PadR(cPRODTER, Len(STL->TL_CODIGO)))
							STL->TL_LOCAL := If(!Empty(aTAREFA[i][5][x][13]),aTAREFA[i][5][x][13],NGSEEK("SB1",cCodTer,1,"B1_LOCPAD"))
						EndIf

						If lMMoeda .And. FindFunction("NGCALCUSMD")
							aCstMoeda     := NGCALCUSMD(stl->tl_codigo,stl->tl_tiporeg,STL->TL_QUANTID,stl->tl_local,"S",,,stl->tl_quanrec)
							STL->TL_CUSTO := aCstMoeda[1]
							STL->TL_MOEDA := aCstMoeda[2]
						Else
							STL->TL_CUSTO := NGCALCUSTI(stl->tl_codigo,stl->tl_tiporeg,STL->TL_QUANTID,stl->tl_local,"S",,,stl->tl_quanrec)
							If lMMoeda
								STL->TL_MOEDA := "1"
							EndIf
						EndIf

						STL->TL_GARANTI := "N"
						If lForTPG .And. Len(aTAREFA[i][5][x]) > 20
							STL->TL_FORNEC := aTAREFA[i][5][x][21]
							STL->TL_LOJA := aTAREFA[i][5][x][22]
						EndIf

						dbSelectArea("STG")
						dbSetOrder(1) //TG_FILIAL+TG_CODBEM+TG_SERVICO+TG_SEQRELA+TG_TAREFA+TG_TIPOREG+TG_CODIGO
						If dbSeek( xFilial("STG") +  (cTRB)->TF_CODBEM + (cTRB)->TF_SERVICO + (cTRB)->TF_SEQRELA + aTAREFA[i][1] +;
								   aTAREFA[i][5][x][1] + aTAREFA[i][5][x][2] )
							STL->TL_CODAEN := STG->TG_CODAEN
						EndIf

						//Grava campos da STL
						If lMNTA3309
							ExecBlock("MNTA3309",.F.,.F.,{xFilial("STG") + (cTRB)->TF_CODBEM + (cTRB)->TF_SERVICO + (cTRB)->TF_SEQRELA + aTAREFA[i][1] + aTAREFA[i][5][x][1] + aTAREFA[i][5][x][2]})
						EndIf

						STL->(MsUnLock())

						If Empty(dPINI)
							dPINI := STL->TL_DTINICI
							hPINI := STL->TL_HOINICI
						Else
							If STL->TL_DTINICI < dPINI
								dPINI := STL->TL_DTINICI
								hPINI := STL->TL_HOINICI
							ElseIf STL->TL_DTINICI = dPINI
								If STL->TL_HOINICI < hPINI
									hPINI := STL->TL_HOINICI
								EndIf
							EndIf
						EndIf

						If Empty(dPFIM)
							dPFIM := STL->TL_DTFIM
							hPFIM := STL->TL_HOFIM
						Else
							If STL->TL_DTFIM > dPFIM
								dPFIM := STL->TL_DTFIM
								hPFIM := STL->TL_HOFIM
							ElseIf STL->TL_DTFIM = dPFIM
								If STL->TL_HOFIM > hPFIM
									hPFIM := STL->TL_HOFIM
								EndIf
							EndIf
						EndIf
					EndIf

					//Monta Array para Ferramentas, Funcionarios , Especialistas e Produtos; contendo Codigo, quantidade e prazo
					//em que sera utilizado (Data e hora Inicio e Fim).
					nTIP := 0
					If aTAREFA[i][5][x][1] == "F"
						nTIP := 1
					ElseIf aTAREFA[i][5][x][1] == "M"
						nTIP := 2
					ElseIf aTAREFA[i][5][x][1] == "E"
						nTIP := 3
					ElseIf aTAREFA[i][5][x][1] == "P"
						nTIP := If(M->TI_BLOQITE == "S" .And. aTAREFA[i][5][x][11] == "S",4,0)
					ElseIf aTAREFA[i][5][x][1] == "T"
						nTIP := 5
					EndIf
					If nTIP > 0
						AAdd(aBLO[nTIP],{aTAREFA[i][1],;
						aTAREFA[i][5][x][2] ,;
						If(aTAREFA[i][5][x][1] == "P" ,aTAREFA[i][5][x][4],aTAREFA[i][5][x][3]) ,;
						aTAREFA[i][5][x][7] ,;
						aTAREFA[i][5][x][8] ,;
						aTAREFA[i][5][x][9] ,;
						aTAREFA[i][5][x][10],;
						cORDEM              ,;
						m->TI_PLANO         ,;
						(cTRB)->CCUSTO         ,;
						aTAREFA[i][5][x][13]})
					EndIf
				Next
			Next

			If !Empty(dPINI)
				If NGIFDBSEEK("STJ",cORDEM+M->TI_PLANO,1,.F.)
					RecLock("STJ",.F.)
					STJ->TJ_HOMPINI := hINI//hPINI
					STJ->TJ_HOMPFIM := hFIM//If(Empty(hPFIM) .Or. Alltrim(hPFIM) = ":",hINI,hPFIM)

					//Caso a manutencao requisite a parada do bem
					//Calcula o Tempo de Parada do mesmo
					Store Ctod("  /  /  ") To dPRE,dPOS
					Store Space(05)        To hPRE,hPOS

					If lParada
						MNT330CDHP(STJ->TJ_DTMPINI,STJ->TJ_HOMPINI,"A") // Tempo anterior à manutencao
						MNT330CDHP(STJ->TJ_DTMPFIM,STJ->TJ_HOMPFIM,"D") // Tempo posterior à manutencao
					EndIf

					STJ->TJ_DTPPINI := dPRE
					STJ->TJ_HOPPINI := hPRE
					STJ->TJ_DTPPFIM := dPOS
					STJ->TJ_HOPPFIM := hPOS
					STJ->(MsUnLock())
				EndIf
			EndIf

			NGIFDBSEEK("STH",(cTRB)->TF_CODBEM+(cTRB)->TF_SERVICO+(cTRB)->TF_SEQRELA,1,.F.)
			While !Eof() .And. STH->TH_FILIAL  == xFilial("STH") .And.;
				STH->TH_CODBEM  == (cTRB)->TF_CODBEM .And. STH->TH_SERVICO == (cTRB)->TF_SERVICO  .And.;
				STH->TH_SEQRELA == (cTRB)->TF_SEQRELA

				//checa se tarefa esta ativa
				If !f330TRFAT((cTRB)->TF_CODBEM,(cTRB)->TF_SERVICO,(cTRB)->TF_SEQRELA,STH->TH_TAREFA)
					NGDBSELSKIP("STH")
					Loop
				EndIf

				cSeqSt5 := cSpaceSt5

				DbSelectArea('ST5')
				DbSetOrder(1)
				If DbSeek(xFilial('ST5') + (cTRB)->TF_CODBEM+(cTRB)->TF_SERVICO+(cTRB)->TF_SEQRELA+STH->TH_TAREFA) .And.;
					!Empty( ST5->T5_SEQUENC )

					cSeqSt5 := CValToChar( ST5->T5_SEQUENC )

				EndIf

				If !NGIFDBSEEK("STQ",STJ->TJ_ORDEM+STJ->TJ_PLANO+STH->TH_TAREFA+STH->TH_ETAPA,1,.F.)
					RecLock("STQ",.T.)
					STQ->TQ_FILIAL := xFilial("STQ")
					STQ->TQ_ORDEM  := STJ->TJ_ORDEM
					STQ->TQ_PLANO  := STJ->TJ_PLANO
					STQ->TQ_TAREFA := STH->TH_TAREFA
					STQ->TQ_ETAPA  := STH->TH_ETAPA
					STQ->TQ_SEQETA := STH->TH_SEQETA
					STQ->TQ_SEQTARE := cSeqSt5
					STQ->(MsUnLock())
				EndIf
				NGDBSELSKIP("STH")
			End

			If lNGADDETAPA
				ExecBlock("NgAddEtapa",.F.,.F.)
			EndIf

			//Efetua o bloqueio de Ferramentas
			For i := 1 To Len(aBLO[1])
				f330FerT(aBLO[1][i])
			Next

			//Efetua o bloqueio de Mao de Obras temporariamente e não na STK
			For i := 1 To Len(aBLO[2])
				f330TmpF(aBLO[2][i],1)
			Next

			//Efetua o bloqueio de Especialidades temporariamente e não na TTY
			For i := 1 To Len(aBLO[3])
				f330TmpF(aBLO[3][i],2)
			Next

			If lMvMntEs			

				aProdOrdem := {} // produtos da ordem

				/*
				aGlut[1] produto
				aGlut[2] almoxarifado
				aGlut[3] total do item para o plano
				aGlut[4] valor do saldo do item já verificado
				*/

				//------------------------------------
				// Aglutina por produto e almoxarifado
				//------------------------------------
				For i := 1 To Len( aBLO[ 4 ] )

					nQTDCOMP  := aBLO[ 4, i, 3 ]
					cLOCSTL   := aBLO[ 4, i, 11 ]
					cCODPRO   := Left( aBLO[ 4, i, 2 ], nSizeCod )

					nPosSC := Ascan( aGlut, { |x| x[1] + x[2] == cCodPro + cLOCSTL } )
					If nPosSC > 0
						aGlut[ nPosSC, 3 ] += nQTDCOMP
					Else
						aAdd( aGlut, { cCODPRO, cLOCSTL, nQTDCOMP , -9999999 } )
					EndIf

					// aProdOrdem armazena somente os produtos da ordem
					nIndex := Ascan( aProdOrdem, { |x| x[2] + x[11] == cCodPro + cLOCSTL } )
					If nIndex == 0
						aadd( aProdOrdem, aBLO[ 4, i ] )
					EndIf

				Next i

				//----------------------------------------------------------
				// Verifica disponibilidade de produto no estoque
				//----------------------------------------------------------
				For i := 1 To Len( aProdOrdem )
					nIndex := Ascan( aGlut, { |x| x[1] + x[2] == aProdOrdem[ i, 2 ] + aProdOrdem[ i, 11 ] } )
					nSaldoPro := A330PRO( aProdOrdem[ i ], aGlut[nIndex,3], aGlut[nIndex,4], cTpSaldo, lNgInter )
					aGlut[ nIndex, 4 ] := nSaldoPro
				Next i

			EndIf

			If lNGETAPNEX
				ExecBlock("NGETAPNEX",.F.,.F.)
			EndIf

			dLastDate := (cTRB)->DTREAL

			NGDBSELSKIP(cTRB)
		End
	End

	// Caso encontrado erros durante a geração de paradas programadas no SFC
	If !Empty(cIntSFC) .And. Len(aSFCErro) > 0
		MNT330ESFC(aSFCErro, 1)
	EndIf

	If lCanc330 //Se cancelou, deleta tudo
		aOS := {}
		NGIFDBSEEK("STJ",STI->TI_PLANO,3,.F.)
		While !Eof() .And. xFilial("STJ")+STI->TI_PLANO == STJ->(TJ_FILIAL+TJ_PLANO)
			If STJ->TJ_TERMINO != "S" .And. STJ->TJ_TIPOOS = "B"
				aAdd(aOS,{STJ->TJ_ORDEM,STJ->TJ_CODBEM,STJ->TJ_CCUSTO,STJ->TJ_DTMPINI,STJ->TJ_HOMPINI,STJ->TJ_PLANO,STJ->TJ_SITUACA})
			EndIf
			dbSkip()
		EndDo

		Processa({|lEND| lOK := a330DELMOV(aOS,.t.)})
		If lOK
			NGDELETAREG("STI")
			NGDBAREAORDE("STI",1)
		EndIf
	Else

		// Se houver integracao com SIGASFC
		If !Empty(cIntSFC)
			MNT330GSFC(cIntSFC, STI->TI_PLANO)
		EndIf

		//----------------------------------------------------
		// Processamento final do plano de manutenção gerado
		//----------------------------------------------------
		If ExistBlock("MNTA330F")
			ExecBlock("MNTA330F",.F.,.F.)
		EndIf

		// Imprime problemas do planejamento
		MNTA340PROB(.F.)
	EndIf

	MNTA330TRBA()

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT330GSFC
Gera paradas no modulo SIGASFC.

@param cPlanoMan Numero do Plano de Manutencao.

@author Hugo R. Pereira
@since 07/05/2013
@version MP11
@return Nil
/*/
//---------------------------------------------------------------------
Static Function MNT330GSFC(cIntSFC, cPlanoMan)

	Local aArea    := GetArea()
	Local aAreaSTJ := GetArea()

	// Caso haja necessidade de Parada do Bem/Estrutura
	// Se Integrado ao modulo de Chao de Fabrica (SIGASFC), gera Parada Programada

	NGIFDBSEEK("STJ", cPlanoMan, 3, .F.)
	While !Eof() .And. xFilial("STJ") + cPlanoMan == STJ->(TJ_FILIAL + TJ_PLANO)

		If STJ->TJ_TERMINO != "S" .And. STJ->TJ_TIPOOS = "B"
			If !Empty(STJ->TJ_DTPPFIM) .And. !Empty(NGVRFMAQ(STJ->TJ_CODBEM)) // Se houver parada do bem e o mesmo for uma maquina no SIGASFC
				NGSFCINCPP(NGSEEK("ST9",STJ->TJ_CODBEM,1,"T9_RECFERR"),STJ->TJ_DTPPINI,STJ->TJ_HOPPINI,;
				STJ->TJ_DTPPFIM,STJ->TJ_HOPPFIM,STJ->TJ_ORDEM,cIntSFC, (cTRB)->TF_CALENDA) // Gera Parada Programada
			EndIf
		EndIf

		dbSelectArea("STJ")
		dbSkip()
	EndDo

	RestArea(aAreaSTJ)
	RestArea(aArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNTA330TRBA³ Autor ³Inacio Luiz Kolling    ³ Data ³02/06/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Deleta os arquivos temparios e seta arquivos padroes         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTA330TRBA()

	oTmpTbl2:Delete()
	oTmpTbl3:Delete()

	//Deleta o arquivo temporario
	If lPE3304  .And. lTRB3304
		oTmpTbl4:Delete()
	EndIf

	NGDBAREAORDE("ST9",1)
	NGDBAREAORDE("STJ",1)
	dbSelectArea("STI")

Return .t.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³A330DUTIL ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Validacao da data                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A330DUTIL(dDATA,aDIAMNT)
	Local RET := .F.
	Local nSEMN
	Local lDIAMNT := If(aDIAMNT <> nil,.T.,.F.)

	If !lDIAMNT
		If DOW(dDATA) == 1 .Or. DOW(dDATA) == 7
			Return .T.
		EndIf
	Else
		nSEMN := If(DOW(dDATA)==1,7,DOW(dDATA)-1)
		If Len(aDIAMNT) > 0 .And. aDIAMNT[nSEMN][3] == "00:00"
			Return .T.
		EndIf
	EndIf

	NGIFDBSEEK('SH9',"E"+DTOS(dDATA),2,.F.)
	If SH9->H9_DTINI >= dDATA .And. SH9->H9_DTFIM <= dDATA
		RET := .T.
	EndIf

	SH9->(DbsetOrder(1))
Return RET

//----------------------------------------------------------------------
/*/{Protheus.doc} A330TAREFA
Calcula data de inicio e fim de tarefas

@param cVHORA, string, hora
@param cNGFLUT, string, valor do parâmetro MV_NGFLUT
@param cNGUNIDT, string, valor do parãmetro MV_NGUNIDT
@param cPRODTER, string, valor do parâmetro MV_PRODTER
@param cNGLOCPA, string, valor do parâmetro MV_NGLOCPA


@author Paulo Pego
@return .T.
/*/
//----------------------------------------------------------------------
Function A330TAREFA( cVHORA, cNGFLUT, cNGUNIDT, cPRODTER, cNGLOCPA )

	Local aCalend   := {}
	Local aFUNESP   := {}
	Local aDEPENDE  := {}
	Local n4        := 0
	Local nDiaIni   := 0
	Local nDiaFim   := 0
	Local i         := 0
	Local nNIVEL    := 0
	Local nSEM      := 0
	Local hMAX      := 0
	Local nDIA      := 0
	Local OLDDIA    := 0
	Local lHIni     := .F.
	Local lHFim     := .F.
	Local lProblema := .T.
	Local lWhile    := .T.

	Local cObserv   := ''
	Local cReserv   := 'S'
	Local cCOD      := ''
	Local cTarGe    := ''
	Local dMAX      := cToD("01/01/1980")
	Local dINI      := cToD( '' )
	Local dFIM      := cToD( '' )
	Local hINI
	Local hFIM
	Local e
	Local OLDALI
	Local D
	Local f
	Local g
	Local nCODAEN := 0
	Local cAliasQry := ""

	Default cNGFLUT  := AllTrim(SuperGetMV("MV_NGFLUT", .F., "N"))
	Default cNGUNIDT := AllTrim(SuperGetMV("MV_NGUNIDT", .F., ""))
	Default cPRODTER := AllTrim(SuperGetMV("MV_PRODTER", .F., ""))
	Default cNGLOCPA := Padr( SuperGetMv("MV_NGLOCPA",.F.,"01"), TamSx3("NNR_CODIGO")[1] )

	Private lALMOXAR  := .F.,aTAREFA := {},aCalenF := {}

	If Type("aTarEsp") != "A"
		aTarEsp := {}
	EndIf

	If Type("cORDEM") <> "C"
		cORDEM := M->TJ_ORDEM
		M->TI_PLANO := M->TJ_PLANO
	EndIf

	SpEsp := Space(Len(st2->t2_especia))
	dINI  := (cTRB)->DTREAL
	dFIM  := (cTRB)->DTREAL

	nPosCF := aSCAN(aCalenF,{|x| x[1] == (cTRB)->TF_CALENDA})
	If Empty(nPosCF)
		aAdd(aCalenF,{(cTRB)->TF_CALENDA,NGCALENDAH((cTRB)->TF_CALENDA)})
		nPosCF := Len(aCalenF)
	EndIf

	While .T.
		If aCalenF[nPosCF,2,Dow(dINI),1] <> "00:00"
			Exit
		Else
			dINI++
		EndIf
	End

	dDtMi := dINI

	If !FwIsInCallStack( 'NG410GRAVA' )

		cAliasQry := GetNextAlias()

		BeginSql Alias cAliasQry

			SELECT DISTINCT STG.TG_TAREFA
			FROM %Table:STG% STG
			WHERE STG.TG_FILIAL = %xFilial:STG%
				AND STG.TG_CODBEM = %exp:(cTRB)->TF_CODBEM%
				AND STG.TG_SERVICO = %exp:(cTRB)->TF_SERVICO%
				AND STG.TG_SEQRELA = %exp:(cTRB)->TF_SEQRELA%
				AND STG.%notDel%
		EndSql

		While !( cAliasQry )->( EoF() )

			If aSCAN(aTAREFA,{|x| x[1] == (cAliasQry)->TG_TAREFA}) == 0
				aAdd(aTAREFA,{ (cAliasQry)->TG_TAREFA ,0,{},0,{},{"      ",Ctod("  /  /  "),"00:00",0}})
			EndIf

			(cAliasQry)->( dbSkip() )

		EndDo

		(cAliasQry)->( dbCloseArea() )

		If Empty(aTAREFA)
			Return {}
		EndIf

		////////////////////////////////////////////////////////////////////////////
		// Estabelece o nivel de cada tarefa conForme a dependencia (0 - Sem depend)
		////////////////////////////////////////////////////////////////////////////
		nSEM  := If(DOW(dINI)==1,7,DOW(dINI)-1)
		For i := 1 To Len(aTAREFA)
			NGIFDBSEEK("STM",(cTRB)->TF_CODBEM+(cTRB)->TF_SERVICO+(cTRB)->TF_SEQRELA+aTAREFA[i][1],1,.F.)
			While !Eof() .And. xFilial("STM") == STM->TM_FILIAL .And.;
			STM->TM_CODBEM  == (cTRB)->TF_CODBEM  .And. STM->TM_SERVICO == (cTRB)->TF_SERVICO .And.;
			STM->TM_SEQRELA == (cTRB)->TF_SEQRELA .And. STM->TM_TAREFA == aTAREFA[i][1]

				nPosD6 := Ascan(aTAREFA,{|x| x[1] == STM->TM_TAREFA})
				If nPosD6 > 0
					aTAREFA[nPosD6,6,1] := STM->TM_DEPENDE
					aTAREFA[nPosD6,6,4] := STM->TM_SOBREPO
				EndIf
				STM->(dbSkip(1))
			End
		Next

		aTAREFA := aSORT(aTAREFA,,,{|x,y| x[6,1]+x[1] < y[6,1]+y[1] })
		For i := 1 To Len(aTAREFA)
			NGIFDBSEEK("STG",(cTRB)->TF_CODBEM+(cTRB)->TF_SERVICO+(cTRB)->TF_SEQRELA+aTAREFA[i][1],1,.F.)
			While !Eof() .And. xFilial("STG") == STG->TG_FILIAL .And.;
			STG->TG_CODBEM == (cTRB)->TF_CODBEM .And. STG->TG_SERVICO == (cTRB)->TF_SERVICO;
			.And. STG->TG_SEQRELA == (cTRB)->TF_SEQRELA .And. STG->TG_TAREFA == aTAREFA[i][1]

				dFIM := dINI
				nSEM := If(DOW(dINI)==1,7,DOW(dINI)-1)
				If STG->TG_TIPOREG == "P"
					MNT330GMAT(i,5,{STG->TG_TIPOREG,STG->TG_CODIGO,STG->TG_QUANREC,;
					MNT330HCON(STG->TG_QUANTID,STG->TG_TIPOREG),STG->TG_UNIDADE,STG->TG_DESTINO,;
					CTOD("  /  /  "),Space(05),CTOD("  /  /  "),Space(05),STG->TG_RESERVA,;
					0.00,STG->TG_LOCAL,SpEsp,STG->TG_QUANREC,;
					STG->TG_TAREFA,0,Space(3),{},.F.,"",""})
					STG->(dbSkip(1))
					Loop
				EndIf
				If cNGFLUT == "S"
					MNT330CAFLU(i)
					lFrtInput := .T.
				Else
					MNT330CALN(dINI,hINI,dFIM,hFIM,i)
				EndIf
				NGDBSELSKIP("STG")
			End
		Next i

		// Processa as tarefas insumos (data hora ini,fim,dependencia
		For n4 := 1 To Len(aTAREFA)
			aSORT(aTAREFA[n4][5],,,{|x,y| x[1] $ "E/M" })
		Next n4
		MNT330NOTAR()

	Else

		nTARGX := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_TAREFA'  } )
		nTIPOX := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_TIPOREG' } )
		nCODIX := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_CODIGO'  } )
		nQUARX := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_QUANREC' } )
		nQUANX := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_QUANTID' } )
		nUNIDX := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_UNIDADE' } )
		nDESTX := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_DESTINO' } )
		nQTDGX := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_QTDGARA' } )
		nALMOX := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_LOCAL'   } )
		nFORNE := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_FORNEC'  } )
		nLOJA  := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_LOJA'    } )
		nObs   := aScan( aHeaIns, { |x| Trim( Upper( x[2] ) ) == 'TL_OBSERVA' } )

		For n4 := 1 To Len(aGETINS)

			cTarGe := IIf( nTARGX > 0 .And. !Empty( aGETINS[n4,nTARGX] ), aGETINS[n4,nTARGX], PadR( '0', TamSX3( 'TT9_TAREFA' )[1] ) )

			If !aTail( aGETINS[n4] ) .And. !Empty( aGETINS[n4,nTIPOX] )

				If aScan( aTarefa,{ |x| x[1] == cTarGe } ) == 0

					aAdd( aTarefa,{ cTarGe, 0, {}, {}, {} } )

				EndIf

			EndIf

		Next n4

		If Empty(aTAREFA)
			Return {}
		EndIf

		////////////////////////////////////////////////////////////////////////////
		// Estabelece o nivel de cada tarefa conForme a dependencia (0 - Sem depend)
		////////////////////////////////////////////////////////////////////////////
		nSEM  := If(DOW(dINI)==1,7,DOW(dINI)-1)
		
		For i := 1 To Len(aTAREFA)
			
			nNIVEL   := 0
			cCOD     := aTAREFA[i][1]
			aDEPENDE := {}

			/*---------------------------------------------------------+
			| Chamada que busca as dependencias da tarefa posicionada. |
			+---------------------------------------------------------*/
			fGetDepend( (cTRB)->TF_CODBEM, (cTRB)->TF_SERVICO, (cTRB)->TF_SEQRELA, cCOD,;
				@aDepende, @aTarefa[I,3] )

			For d := 1 To Len(aDEPENDE)
				cCOD   := aDEPENDE[d]
				cCtar  := aDEPENDE[d]
				nNIVEL := 1

				While .T.
					If NGIFDBSEEK("STM",(cTRB)->TF_CODBEM+(cTRB)->TF_SERVICO+(cTRB)->TF_SEQRELA+cCOD,1,.F.)
						nNIVEL++
						cCOD := STM->TM_DEPENDE
						If cCOD == cCtar
							Exit
						EndIf
					Else
						Exit
					EndIf
				End
			Next

			aTAREFA[i][2] := nNIVEL+(i/1000)

		Next

		aTAREFA := aSORT(aTAREFA,,,{|x,y| x[2] < y[2]})
		hINI    := If(cVHORA <> Nil,cVHORA,aDIAMAN[nSEM][1])
		hFIM    := aDIAMAN[nSEM][1]
		cHORA   := If(cVHORA <> Nil,HTOM(cVHORA),HTOM(aDIAMAN[nSEM][1]))
		dDATA   := (cTRB)->DTREAL
		nDATA   := 0

		For i := 1 To Len(aTAREFA)
			dFIM   := dINI
			OLDDIA := 0

			For n4 := 1 To Len(aGETINS)

				cTarGe := IIf( nTARGX > 0 .And. !Empty( aGETINS[n4,nTARGX] ), aGETINS[n4,nTARGX], PadR( '0', TamSX3( 'TT9_TAREFA' )[1] ) )

				If aTarefa[I,1] == cTarGe

					If !Atail(aGETINS[n4])

						If IsInCallStack( 'NG410INC' )

							dINI  := IIf( Empty( GDFieldGet( 'TL_DTINICI', n4, .F., aHeaIns, aGetIns ) ), dINI, GDFieldGet(;
								'TL_DTINICI', n4, .F., aHeaIns, aGetIns ) )

							If !Empty( GDFieldGet( 'TL_HOINICI', n4, .F., aHeaIns, aGetIns ) )

								hINI  := GDFieldGet( 'TL_HOINICI', n4, .F., aHeaIns, aGetIns )
								cHORA := hToM( hINI )

							EndIf

						EndIf

						cReserv := Posicione( 'STG', 1, xFilial( 'STG' ) + (cTRB)->TF_CODBEM + (cTRB)->TF_SERVICO +;
						(cTRB)->TF_SEQRELA + aTarefa[I,1] + aGetIns[n4,nTipoX] + aGetIns[n4,nCodIx], 'TG_RESERVA' )

						// FORÇA CONTEUDO DEFAULT
						cReserv := IIf( Empty( cReserv ), 'S', cReserv )

						cObserv := IIf( nObs > 0, aGETINS[n4,nObs], '' )

						dFIM := dINI
						nSEM := If(DOW(dINI)==1,7,DOW(dINI)-1)
						If aGETINS[n4,nTIPOX] == "P"

							nCODAEN := Ascan(aHEAINS,{|x| TRIM(UPPER(x[2])) == "TG_CODAEN"})

							MNT330GMAT( i, 5, { aGETINS[n4,nTIPOX], aGETINS[n4,nCODIX], aGETINS[n4,nQUARX],;
										aGETINS[n4,nQUANX], aGETINS[n4,nUNIDX], aGETINS[n4,nDESTX],;
										dINI, hINI, CTOD("  /  /  "), Space(05), cReserv,;
										0.00, aGETINS[n4,nALMOX], SpEsp, aGETINS[n4,nQUARX],;
										aTarefa[I,1], 0, Space(3), {}, .F., '', '', cObserv, IIf(nCODAEN > 0, aGETINS[n4,nCODAEN],'')} )

							SetPrdMax(dINI, hINI, @dMAX, @hMAX) // Alimenta variaveis correspondente ao periodo maximo
							cHORA := HTOM(hINI)
							Loop
						EndIf
						nTOTH := 0.00
						If Alltrim(aGETINS[n4,nUNIDX]) == "H"
							nTEMPO := aGETINS[n4,nQUANX] * 60

							If cNGUNIDT == "S"
								nVALINHOR := Int(aGETINS[n4,nQUANX]) * 60
								nVALINMIM := (aGETINS[n4,nQUANX] - Int(aGETINS[n4,nQUANX])) *100
								nTEMPO := nVALINHOR+ nVALINMIM
							EndIf

							nTOTH  := nTEMPO
							nFOL   := 0
							nSEM   := If(DOW(dINI)==1,7,DOW(dINI)-1)
							nHORA  := HTOM(aDIAMAN[nSEM][2]) - cHORA
							nHORA  -= INTERVALO(MTOH(cHORA),aDIAMAN[nSEM][2],nSEM)
							nREST  := nTEMPO - nHORA
							nDIA   := nTEMPO
							OLDDIA := MAX(OLDDIA,nDIA)
							If nREST > 0
								While .T.
									If nTEMPO <= nHORA
										hFIM  := MTOH(cHORA+nTEMPO)
										nINTE := INTERVALO(MTOH(cHORA),hFIM,nSEM)
										hFIM  := MTOH(HTOM(hFIM)+nINTE)
										Exit
									EndIf
									dFIM++
									nTEMPO -= nHORA
									nSEM   := If(DOW(dFIM)==1,7,DOW(dFIM)-1)
									nHORA  := HTOM(aDIAMAN[nSEM][3])
									cHORA  := HTOM(aDIAMAN[nSEM][1])
								End
							Else
								hFIM  := MTOH(cHORA+nTEMPO)
								nINTE := INTERVALO(MTOH(cHORA),hFIM,nSEM)
								hFIM  := MTOH(HTOM(hFIM)+nINTE)
								dFIM  := dINI
							EndIf
						Else
							If Alltrim(aGETINS[n4,nUNIDX]) == "S"
								nFOL   := (aGETINS[n4,nQUANX] * 7)
								nTEMPO := 0
							ElseIf Alltrim(aGETINS[n4,nUNIDX]) == "M"
								nFOL   := (aGETINS[n4,nQUANX] * 30)
								nTEMPO := 0
							Else
								nFOL   := aGETINS[n4,nQUANX]
								nTEMPO := 0
							EndIf
							dFAZ   := dINI
							FIMS   := 0
							While .T.
								If nFOL <= 0; Exit; End
								nSEM   := If(DOW(dFAZ)==1,7,DOW(dFAZ)-1)
								If nFOL > 0 .And. nFOL < 1
									nTEMPO += (HTOM(aDIAMAN[nSEM][3]) * nFOL)
								Else
									nTEMPO += HTOM(aDIAMAN[nSEM][3])
								EndIf
								If HTOM(aDIAMAN[nSEM][3]) == 0 .And. Alltrim(aGETINS[n4,nUNIDX]) == "D"
									nFOL++
								EndIf
								nFOL--
								dFAZ++
							End
							nDIA   := nTEMPO
							nTOTH  := nTEMPO
							OLDDIA := MAX(OLDDIA,nDIA)
							dFIM   := dFAZ
							nSEM   := If(DOW(dINI)==1,7,DOW(dINI)-1)
							If (HTOM(hINI) - HTOM(aDIAMAN[nSEM][1])) > 0
								nTEMPO += (HTOM(hINI) - HTOM(aDIAMAN[nSEM][1]))
								nTEMPO -= INTERVALO(aDIAMAN[nSEM][1],hINI,nSEM)
							EndIf
							nHORA := HTOM(aDIAMAN[nSEM][3])
							nREST := nTEMPO - nHORA
							dFIM  := dINI
							cHORA := HTOM(hINI)
							If nREST > 0
								While .T.
									If nTEMPO <= nHORA
										hFIM  := MTOH(cHORA+nTEMPO)
										nINTE := INTERVALO(MTOH(cHORA),hFIM,nSEM)
										hFIM  := MTOH(HTOM(hFIM)+nINTE)
										Exit
									EndIf
									dFIM++
									nTEMPO -= nHORA
									nSEM   := If(DOW(dFIM)==1,7,DOW(dFIM)-1)
									nHORA  := HTOM(aDIAMAN[nSEM][3])
									cHORA  := HTOM(aDIAMAN[nSEM][1])
								End
							Else
								hFIM  := MTOH(cHORA+nTEMPO)
								nINTE := INTERVALO(MTOH(cHORA),hFIM,nSEM)
								hFIM  := MTOH(HTOM(hFIM)+nINTE)
							EndIf
						EndIf

						SetPrdMax(dFIM, hFIM, @dMAX, @hMAX) // Alimenta variaveis correspondente ao periodo maximo
						cHORA := HTOM(hINI)

						If cNGFLUT == "S"

							If aGETINS[n4,nTIPOX] == "E" .And. (M->TI_TIPOMDO == "F" .Or. (M->TI_TIPOMDO == "E" .And. IsInCallStack("MNTA330")))

								nRecTmp := 0
								aFUNESP := BUSCAESP(aGETINS[n4,nCODIX],aGETINS[n4,nQUARX],dINI,dFIM,hIni,hFim,aTAREFA)
								If Len(aFUNESP) < aGETINS[n4,nQUARX]
									OLDALI := ALIAS()

									MNTGRAVSTA( cOrdem, M->TI_PLANO, aTarefa[I,1], 'E', aGetIns[n4,nCodiX], STR0061 )

									dbSelectArea(OLDALI)
								EndIf
								For e := 1 To Len(aFUNESP)

									nRecTmp++

									MNT330GMAT( i, 5, { 'M', aFUNESP[e], 0, aGETINS[n4,nQUANX],	aGETINS[n4,nUNIDX],;
										aGETINS[n4,nDESTX],	dINI, hINI, dFIM, hFIM, cReserv, nTOTH, Space( 2 ), SpEsp,;
										aGETINS[n4,nQUARX], aTarefa[I,1], e, Space( 3 ), {}, .F., '', '', cObserv } )

									If e >= aGETINS[n4,nQUARX]
										Exit
									EndIf
								next e
								If nRecTmp < aGETINS[n4,nQUARX]

									MNT330GMAT( i, 5, { aGETINS[n4,nTIPOX], aGETINS[n4,nCODIX], aGETINS[n4,nQUARX]-nRecTmp,;
										aGETINS[n4,nQUANX], aGETINS[n4,nUNIDX], aGETINS[n4,nDESTX], dINI, hINI, dFIM, hFIM,;
										cReserv, nTOTH, Space( 2 ), SpEsp, aGETINS[n4,nQUARX]-nRecTmp, aTarefa[I,1], 0,;
										Space( 3 ), {}, .F., '', '', cObserv } )

								EndIf
							ElseIf aGETINS[n4,nTIPOX] == "M"
								OLDALI := ALIAS()
								lProblema := .T.
								If NGIFDBSEEK('ST1',aGETINS[n4,nCODIX],1,.F.)
									If NGIFDBSEEK('TP4',ST1->T1_EQUIPE,1,.F.)
										If NGIFDBSEEK('TP6',TP4->TP4_CODIGO,1,.F.)
											lWhile := .T.
											While !Eof() .And. TP6->TP6_FILIAL = Xfilial("TP6") .And.;
											TP6->TP6_EQUIPE == TP4->TP4_CODIGO .And. lWhile
												If dIni >= TP6->TP6_DTINI .And.  dIni <= TP6->TP6_DTFIM .And.;
												dFim >= TP6->TP6_DTINI .And.  dFim <= TP6->TP6_DTFIM

													lHIni := .F.
													lHFim := .F.

													//Faz a validacao pela hora caso a data inicial ou final seja igual
													If dIni == TP6->TP6_DTINI
														aCalend := NGCALENDAH(TP6->TP6_CALEND)
														nDiaIni := DOW(TP6->TP6_DTINI)
														For f := 1 to Len(aCalend[nDiaIni][2])
															For g := 1 to Len(aCalend[nDiaIni][2][f])
																If aCalend[nDiaIni][2][f][1] < hIni
																	lHIni := .T.
																EndIf
															Next g
														Next f
													EndIf

													If dFim == TP6->TP6_DTFIM
														aCalend := NGCALENDAH(TP6->TP6_CALEND)
														nDiaFim := DOW(TP6->TP6_DTFIM)
														For f := 1 to Len(aCalend[nDiaFim][2])
															For g := 1 to Len(aCalend[nDiaFim][2][f])
																If aCalend[nDiaFim][2][f][2] > hFim
																	lHFim := .T.
																EndIf
															Next g
														Next f
													EndIf

													If lHIni .Or. lHFim
														aCalend := {}
														NGDBSELSKIP("TP6")
														Loop
													EndIf

													MNT330GMAT( i, 5, { aGETINS[n4,nTIPOX], aGETINS[n4,nCODIX],;
														aGETINS[n4,nQUARX], aGETINS[n4,nQUANX],	aGETINS[n4,nUNIDX],;
														aGETINS[n4,nDESTX], dINI, hINI, dFIM, hFIM, cReserv, nTOTH,;
														Space( 2 ), SpEsp, aGETINS[n4,nQUARX], aTarefa[I,1], 0, Space( 3 ),;
														{}, .F., '', '', cObserv } )

													lProblema := .F.
													aCalend := {}
													lWhile := .F.
												EndIf
												NGDBSELSKIP("TP6")
											End
										EndIf
									EndIf
									If lProblema

										MNTGRAVSTA( cOrdem, M->TI_PLANO, aTarefa[I,1], 'M', aGetIns[n4,nCodiX], STR0020 +;
											' - ' + Upper( STR0049 ) )

										MNT330GMAT( i, 5, { aGETINS[n4,nTIPOX], aGETINS[n4,nCODIX], aGETINS[n4,nQUARX],;
											aGETINS[n4,nQUANX], aGETINS[n4,nUNIDX], aGETINS[n4,nDESTX], dINI, hINI, dFIM,;
											hFIM, cReserv, nTOTH, Space( 2 ), SpEsp, aGETINS[n4,nQUARX], aTarefa[I,1], 0,;
											Space( 3 ), {}, .F., '', '', cObserv } )

									EndIf
								EndIf
								dbSelectArea(OLDALI)
							Else

								MNT330GMAT( i, 5, { aGETINS[n4,nTIPOX], aGETINS[n4,nCODIX], aGETINS[n4,nQUARX],;
									aGETINS[n4,nQUANX], aGETINS[n4,nUNIDX], aGETINS[n4,nDESTX], dINI, hINI, dFIM,;
									hFIM, cReserv, nTOTH, Space( 2 ), SpEsp, aGETINS[n4,nQUARX], aTarefa[I,1], 0,;
									Space( 3 ), {}, .F., aGETINS[n4,nFORNE], aGETINS[n4,nLOJA], cObserv } )

							EndIf
						Else
							If aGETINS[n4,nTIPOX] == "E" .And. (M->TI_TIPOMDO == "F" .Or. (M->TI_TIPOMDO == "E" .And. IsInCallStack("MNTA330")))
								nRecTmp := 0
								aFUNESP := BUSCAESP(aGETINS[n4,nCODIX],aGETINS[n4,nQUARX],dINI,dFIM,hIni,hFim,aTAREFA)
								If Len(aFUNESP) < aGETINS[n4,nQUARX]
									OLDALI := ALIAS()

									MNTGRAVSTA( cOrdem, M->TI_PLANO, aTarefa[I,1], 'E', aGetIns[n4,nCodiX], STR0061 )

									dbSelectArea(OLDALI)
								EndIf
								For e := 1 To Len(aFUNESP)

									nRecTmp++

									MNT330GMAT( i, 5, { 'M', aFUNESP[e], 0, aGETINS[n4,nQUANX], aGETINS[n4,nUNIDX],;
										aGETINS[n4,nDESTX], dINI, hINI, dFIM, hFIM, cReserv, nTOTH, Space( 2 ), SpEsp,;
										aGETINS[n4,nQUARX], aTarefa[I,1], e, Space( 3 ), {}, .F., '', '', cObserv } )

									If e >= aGETINS[n4,nQUARX]
										Exit
									EndIf

								Next e
								If nRecTmp < aGETINS[n4,nQUARX]

									MNT330GMAT( i, 5, { aGETINS[n4,nTIPOX], aGETINS[n4,nCODIX], aGETINS[n4,nQUARX]-nRecTmp,;
										aGETINS[n4,nQUANX], aGETINS[n4,nUNIDX], aGETINS[n4,nDESTX], dINI, hINI, dFIM,;
										hFIM, cReserv, nTOTH, Space( 2 ), SpEsp, aGETINS[n4,nQUARX]-nRecTmp,;
										aTarefa[I,1], 0, Space( 3 ), {}, .F., '', '', cObserv } )

								EndIf
							ElseIf aGETINS[n4,nTIPOX] == "T"
								If Empty(aGETINS[n4,nALMOX])
									cCodIns := If(FindFunction("NGProdMNT"), NGProdMNT("T")[1], PadR(cPRODTER, Len(STL->TL_CODIGO)))
									If NGIFDBSEEK("SB1",cCodIns,1,.F.)
										aGETINS[n4,nALMOX] := NGSEEK("SB1",cCodIns,1,"B1_LOCPAD")
									Else
										aGETINS[n4,nALMOX] := cNGLOCPA
									EndIf
								EndIf

								MNT330GMAT( i, 5, { aGETINS[n4,nTIPOX], aGETINS[n4,nCODIX], aGETINS[n4,nQUARX],;
									aGETINS[n4,nQUANX], aGETINS[n4,nUNIDX], aGETINS[n4,nDESTX],	dINI, hINI, dFIM,;
									hFIM, cReserv, nTOTH, aGETINS[n4,nALMOX], SpEsp, aGETINS[n4,nQUARX], aTarefa[I,1], 0,;
									Space( 3 ), {}, .F., aGETINS[n4,nFORNE], aGETINS[n4,nLOJA], cObserv } )

							Else

								MNT330GMAT( i, 5, { aGETINS[n4,nTIPOX], aGETINS[n4,nCODIX], aGETINS[n4,nQUARX],;
									aGETINS[n4,nQUANX], aGETINS[n4,nUNIDX], aGETINS[n4,nDESTX], dINI, hINI, dFIM,;
									hFIM, cReserv, nTOTH, Space( 2 ), SpEsp, aGETINS[n4,nQUARX], aTarefa[I,1], 0,;
									Space( 3 ), {}, .F., '', '', cObserv } )

							EndIf
						EndIf

					EndIf

				EndIf

			Next n4

			cHORA := hMAX
			cRET  := {}
			aTAREFA[i][4] := {dINI,hINI,dMAX,MTOH(hMAX),OLDDIA}

			If (i+1) <= Len(aTAREFA) .And.  If(Empty(aTAREFA[i][5]),.F.,aTAREFA[i][5][1][1] != "P")

				cRET := a330NEXT(aTAREFA[i+1][3],aTAREFA[i][5],aTAREFA)

			EndIf

			If Len(cRET) > 0
				dINI := cRET[1]
				hINI := cRET[2]
			EndIf
			nSEM := If(DOW(dINI)==1,7,DOW(dINI)-1)
			If HTOM(hINI) >= HTOM(aDIAMAN[nSEM][2])
				Do While .T.
					dINI++
					nSEM := If(DOW(dINI)==1,7,DOW(dINI)-1)
					If HTOM(aDIAMAN[nSEM][3]) > 0
						hINI := aDIAMAN[nSEM][1]
						Exit
					EndIf
				EndDo
			EndIf
			cHORA := HTOM(hINI)
		Next i

	EndIf

Return aTAREFA

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³A330NEXT  ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Calcula a proxima data de Manutencao                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
STATIC Function A330NEXT(aSOBRE,aBASE,aTAREFA)
	Local cRET,nSEM,nDIA,rDAT,nFOL,SOBRA,nHORA
	Local dOLD := CTOD("01/01/1980"), hOLD := 0
	Local dRET := CTOD(" "), hRET := SPACE(5),l
	LOCAL L := 1

	nDIA := 0
	nHOR := 0

	For L := 1 To Len(aSOBRE)

		nTAR := aSCAN(aTAREFA,{|x| x[1] == aSOBRE[L][1]})
		If nTAR > 0  .And.  !Empty(aTAREFA[nTAR,4])
			nFAT  := If(aSOBRE[L][2] > 0,aSOBRE[L][2],100)/100
			nDIA  := aTAREFA[nTAR][4][5] * nFAT
			nSEM  := If(DOW(aTAREFA[nTAR][4][1])==1,7,DOW(aTAREFA[nTAR][4][1])-1)
			nHORA := (HTOM(aDIAMAN[nSEM][2]) - HTOM(aTAREFA[nTAR][4][2]))
			nHORA -= INTERVALO(aTAREFA[nTAR][4][2],aDIAMAN[nSEM][2],nSEM)
			dRET  := aTAREFA[nTAR][4][1]
			hRET  := HTOM(aTAREFA[nTAR][4][2])

			While .T.
				If nDIA <= nHORA
					nSEM  := If(DOW(dRET)==1,7,DOW(dRET)-1)
					hRET  := MTOH(hRET+nDIA)
					nINTE := INTERVALO(aDIAMAN[nSEM][1],hRET,nSEM)
					hRET  := MTOH(HTOM(hRET)+nINTE)
					Exit
				EndIf
				dRET  := dRET + 1
				nDIA  -= nHORA
				nSEM  := If(DOW(dRET)==1,7,DOW(dRET)-1)
				nHORA := HTOM(aDIAMAN[nSEM][3])
				hRET  := HTOM(aDIAMAN[nSEM][1])
			End
		EndIf
	
	Next L

	If Empty(dRET)
		cRET := {}
	Else
		cRET := {dRET,hRET}
	EndIf
Return cRET

//---------------------------------------------------------------------
/*/{Protheus.doc} a330Bem
Bloqueio do Bem (Recurso) para a manutenção

@param dIni: Data início da parada
@param hIni: Hora início da parada
@param dFim: Data fim da parada
@param hFim: Hora fim da parada
@param cBem: Código do bem a efetuar a parada
@param cParada: Código da parada do bem:
				N  O bem não necessita de parada para a manutenção,
				S  O bem necessita de parada para a manutenção ou
				T  todos os bens da estrutura necessitam de parada para a manutenção
@param cCCusto: Centro de custo do bem no período

@Obs: Se existir bloqueio para o período gera problema (STA).
Se o bloqueio for parcial gera problema e bloqueia o restante do período

@author Paulo Pego
/*/
//---------------------------------------------------------------------
Function A330BEM(dIni, hIni, dFim, hFim, cCodBem, cParada, cCusto)

	Local lProblema := .F.
	Local lBloqueio := .F.
	Local lGeraBlq := .T.
	Local lRec := .F.
	Local cCod := ""
	Local cBem := cCodBem
	Local i := 0
	Local dData := dIni
	Local aBem := {}
	Local aBem2 := {}

	aAdd(aBem,cCodBem)
	ST3->(dbSetOrder(3))
	SH9->(dbSetOrder(1))

	//-------------------------------------------------------------
	// Efetua o bloqueio do Bem Filho Para o Bem Pai
	//-------------------------------------------------------------
	If cParada == "T"

		STC->(dbSetOrder(3))
		While .T.

			If !STC->(dbSeek(xFilial("STC")+cCodBem))

				Exit

			EndIf

			cCodBem := STC->TC_CODBEM
			aAdd(aBem,cCodBem)

		EndDo

		STC->(dbSetOrder(2))

	EndIf

	//-------------------------------------------------------------
	// Efetua o bloqueio do Bem Pai Para o Bem Filho
	//-------------------------------------------------------------
	cCodBem := cBem

	STC->(dbSetOrder(1))
	If STC->(dbSeek(xFilial("STC")+cCodBem))

	While !STC->( Eof() ) .And. STC->TC_FILIAL = Xfilial("STC") .And. cCodBem == STC->TC_CODBEM

			aAdd(aBem,STC->TC_COMPONE)
			aAdd(aBem2,STC->TC_COMPONE)
			STC->(dbSkip())

		EndDo

	EndIf

	For i := 1 To Len(aBem2)

		a330REBLOQ(aBem2[i], @aBem)

	Next i

	STC->(dbSetOrder(2))

	i := 1

	Do While .T.

		cCodBem := aBem[i]
		lRec := .F.

		NGIFDBSEEK('ST9',cCodBem,1,.F.)
		If !Empty(ST9->T9_FERRAME) .And.  !Empty(ST9->T9_RECFERR)

			NGDBAREAORDE("SH1",1)
			lRec := SH1->(dbSeek(xFilial("SH1")+ST9->T9_RECFERR))

			Do While .T.

				If dData > dFim

					Exit

				EndIf

				If lRec

					If NGIFDBSEEK('SH9',"B"+cCusto+cCodBem,1,.F.)

						If SH9->H9_DTINI <= dData .And.  SH9->H9_DTFIM >= dData

							lProblema := .T.
							Exit

						EndIf

					EndIf

				Else

					If NGIFDBSEEK('ST3',cCodBem,1,.F.)

						If ST3->T3_DTINI <= dData .And.  ST3->T3_DTFIM >= dData

							lProblema := .T.
							Exit

						EndIf

					EndIf

				EndIf

				dData++

			EndDo

		EndIf

		If lProblema

			MNTGRAVSTA(cORDEM,M->TI_PLANO,,"B",cCodBem,STR0014)

			If cCodBem = cBem

				lBloqueio := .T.
				NGCANCOSBLO()

			EndIf

		EndIf

		cMOTIVO := "OS.MANUT."+cORDEM+" PLANO "+M->TI_PLANO

		If lRec

			MNTGRAVSH9(ST9->T9_RECFERR,cCusto,cMOTIVO,dIni,dFim,hIni,hFim,"B","1")

		Else

			If cCodBem = cBem

				If !lBloqueio

					If NGCHKBLQBEM(cCodBem,dIni,hIni,dFim,hFim)

						NGCANCOSBLO()
						lGeraBlq := .F.

					EndIf

				EndIf

			EndIf

			If lGeraBlq

				dbSelectArea("ST3")
				RecLock("ST3",.T.)
				Replace T3_FILIAL With xFilial("ST3"),;
				T3_CODBEM With cCodBem        ,;
				T3_MOTIVO With cMOTIVO        ,;
				T3_DTINI  With dINI           ,;
				T3_HRINI  With hIni           ,;
				T3_DTFIM  With dFim           ,;
				T3_HRFIM  With hFim           ,;
				T3_PLANO  With M->TI_PLANO    ,;
				T3_ORDEM  With cORDEM
				ST3->(MsUnLock())

			EndIf

		EndIf

		If Len(aBem) <= i .Or. !lGeraBlq

			Exit

		EndIf

		i++

	EndDo

	ST3->(dbSetOrder(1))

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³a330FER   ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Bloqueio do Bem (Recurso) para a manutencao                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ OBS      ³ Se existir bloqueio para o periodo gera problema.          ³±±
±±³          ³ Se o bloqueio for parcial gera problema e bloqueia o       ³±±
±±³          ³ restante do periodo                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A330FER(aFER,cCBEM)
	Local dDATA,cFER,nFER
	Local lBEMFERR := .F.

	dDATA := aFER[4]
	cFER  := Left(aFER[2],Len(SH9->H9_FERRAM))
	NGIFDBSEEK('SH4',cFER,1,.F.)
	If SH4->H4_QUANT < aFER[3]
		NGDBAREAORDE("STA",1)
		cCHASTA := STR0015+STR(aFER[3]-SH4->H4_QUANT,3)+STR0016
		cCHARET := Alltrim(cCHASTA)+Space(len(STA->TA_DESCRIC)-Len(cCHASTA))
		cCODSTA := Alltrim(aFER[2])+Space(Len(STA->TA_CODIGO) - Len(Alltrim(aFER[2])))
		cCODTAR := Alltrim(aFER[1])+Space(Len(STA->TA_TAREFA) - Len(Alltrim(aFER[1])))

		cCHASTA := aFER[8]+aFER[9]+cCODTAR+"F"+cCODSTA+cCHARET

		If !dbSeek(xFilial("STA")+cCHASTA)

			MNTGRAVSTA(aFER[8],aFER[9],aFER[1],"F",aFER[2],;
			STR0015+STR(aFER[3]-SH4->H4_QUANT,3)+STR0016) //"FALTAM "###" FERRAMENTAS"
		EndIf
	EndIf

	nFER := 0
	NGDBAREAORDE("SH9",3)
	dbSeek( xFilial("SH9") + "F" + cFER + DtoS(aFER[4]) , .T. )
	If Eof() .or. xFilial("SH9") != SH9->H9_FILIAL .or. SH9->H9_TIPO != "F" .or. cFER != SH9->H9_FERRAM .or. SH9->H9_DTINI > aFER[4]
		dbSkip(-1)
		If Eof() .or. Bof() .or. xFilial("SH9") != SH9->H9_FILIAL .or. SH9->H9_TIPO != "F" .or. cFER != SH9->H9_FERRAM
			dbSkip()
		EndIf
	EndIf
	While !Eof() .And. SH9->H9_FILIAL == xFilial("SH9") .And. SH9->H9_TIPO == "F" .And. SH9->H9_FERRAM == cFER .And. SH9->H9_DTINI <= aFER[6]
		If DtoS(aFER[4])+aFER[5] < DtoS(SH9->H9_DTFIM)+SH9->H9_HRFIM .and.;
		DtoS(aFER[6])+aFER[7] > DtoS(SH9->H9_DTINI)+SH9->H9_HRINI

			nFER += SH9->H9_QUANT
		EndIf
		NGDBSELSKIP("SH9")
	End

	If (SH4->H4_QUANT < (nFER+aFER[3]))
		NGDBAREAORDE("STA",1)
		cCHASTA := STR0017
		cCHARET := Alltrim(cCHASTA)+Space(len(STA->TA_DESCRIC)-Len(cCHASTA))
		cCODSTA := Alltrim(aFER[2])+Space(Len(STA->TA_CODIGO)-Len(Alltrim(aFER[2])))
		cCODTAR := Alltrim(aFER[1])+Space(Len(STA->TA_TAREFA)-Len(Alltrim(aFER[1])))

		cCHASTA := aFER[8]+aFER[9]+cCODTAR+"F"+cCODSTA+cCHARET

		If !dbSeek(xFilial("STA")+cCHASTA)
			MNTGRAVSTA(aFER[8],aFER[9],aFER[1],"F",aFER[2],STR0017) //"FERRAMENTA NAO DISPONIVEL"
		EndIf
	EndIf

	cALIASO := ALIAS()

	If cCBEM <> Nil
		If NGIFDBSEEK('ST9',cCBEM,1,.F.)
			If !Empty(ST9->T9_RECFERR)
				If ST9->T9_FERRAME == "F"
					lBEMFERR := .T.
				EndIf
			EndIf
		EndIf
	EndIf

	If lBEMFERR .Or. cCBEM = Nil
		cMOTIVO := STR0018+aFER[8]+STR0019 //"OS.MANUT."###" PLANO "
		If Type("M->TI_PLANO") = "C"
			cMOTIVO += M->TI_PLANO
		ElseIf Type("M->TJ_PLANO") = "C"
			cMOTIVO += M->TJ_PLANO
		EndIf
		MNTGRAVSH9(,,cMOTIVO,aFER[4],aFER[6],aFER[5],aFER[7],"F","1",aFER[2],aFER[3])
	EndIf
	SH9->(dbSetOrder(1))
Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³a330FUN   ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Bloqueio do Bem (Recurso) para a manutencao                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ OBS      ³ Se existir bloqueio para o periodo gera problema.          ³±±
±±³          ³ Se o bloqueio for parcial gera problema e bloqueia o       ³±±
±±³          ³ restante do periodo                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A330FUN(aFUN,nRECSTK)
	Local lPROBLEMA, cFUNC, cHoIn, cHoCe

	cFUNC := Left(aFUN[2],Len(STK->TK_CODFUNC))
	cHoIn := aFUN[5]
	cHoCe := NGSOMAHCAR("00:01",cHoIn)
	vVETFUNC := If(nRECSTK <> Nil,MNT160CKDA(cFUNC,aFUN[4],cHoCe,aFUN[6],aFUN[7],nRECSTK,.F.),;
	MNT160CKDA(cFUNC,aFUN[4],cHoCe,aFUN[6],aFUN[7],,.F.))
	lPROBLEMA := If(!vVETFUNC[1],.T.,.F.)

	If lPROBLEMA
		If !NGIFDBSEEK('STA',aFUN[8]+aFUN[9]+aFUN[1]+"M"+aFUN[2]+STR0020,1,.F.)
			If !dbSeek(xFilial("STA")+aFUN[8]+aFUN[9]+aFUN[1]+"M"+aFUN[2]+STR0060) //"FUNCIONARIO PREVISTO EM O.S. DESTE PLANO"
				MNTGRAVSTA(aFUN[8],aFUN[9],aFUN[1],"M",aFUN[2],STR0020+" - "+Upper(STR0051)) //"FUNCIONARIO NAO DISPONIVEL"
			EndIf
		EndIf
	EndIf

	If !lPROBLEMA
		MNTGRAVSTK(aFUN[2],aFUN[8],aFUN[9],aFUN[1],aFUN[4],aFUN[5],aFUN[6],aFUN[7],;
		STR0021+aFUN[8]) //"O.S. MANUTENCAO N."
	EndIf
Return NIL

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³a330ESP   ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Bloqueio do Bem (Recurso) para a manutencao                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ OBS      ³ Se existir bloqueio para o periodo gera problema.          ³±±
±±³          ³ Se o bloqueio for parcial gera problema e bloqueia o       ³±±
±±³          ³ restante do periodo                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A330ESP(aESP)
	Local lPROBLEMA := .F.,dDATA,nDISPO := 1,nTOTAL := 0,nCont
	Local aFUN := {},i,nForx,aBACK
	Local lTemTTY := NGCADICBASE("TTY_ORDEM","A","TTY",.F.)
	Local cHoraIni,cHoraFim
	Local cEspCod := Left(aESP[2],Len(ST2->T2_ESPECIA))
	Local aBloqTTY := {}

	STK->(dbSetOrder(2))
	ST2->(dbSetOrder(2))
	If lTemTTY
		TTY->(dbSetOrder(2))
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Le ST0 para saber disponibilidade do especialista               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If NGIFDBSEEK('ST0',cEspCod,1,.F.)
		nDISPO := If(T0_DISPONI > 0,(T0_DISPONI /100),1)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Le TTY (bloqueios especialidades)                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lTemTTY
		If TTY->(Dbseek(xFilial("TTY")+cEspCod+DTOS(aESP[4]),.t.))
			dbSelectArea("TTY")
			While !Eof() .and. xFilial("TTY")+cEspCod == TTY->(TTY_FILIAL+TTY_CODESP) .and. TTY->TTY_DTINI >= aESP[4] .and. TTY->TTY_DTFIM <= aESP[6]
				If TTY->TTY_QUANTI > 0
					aAdd( aBloqTTY , { TTY->TTY_DTINI , TTY->TTY_HRINI , TTY->TTY_DTFIM , TTY->TTY_HRFIM , TTY->TTY_QUANTI } )
				EndIf
				dbSkip()
			End
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Le ST2 acumula a quantidade de especialistas disponiveis        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	NGIFDBSEEK('ST2',cEspCod,2,.F.)
	nCont := 0
	While !Eof() .And.;
	ST2->T2_FILIAL+ST2->T2_ESPECIA == xFilial("ST2")+cEspCod

		nCont++
		lPROBLEMA := .F.
		dDATA := aESP[4]
		Do While .T.

			If dDATA > aESP[6]
				Exit
			EndIf

			cHoraIni := "00:00"
			If dDATA == aESP[4]
				cHoraIni := aESP[5]
			EndIf
			cHoraFim := "23:59"
			If dDATA == aESP[6]
				cHoraFim := aESP[7]
			EndIf

			//Verifica bloqueio do funcionario
			If STK->(Dbseek(xFilial("STK")+ST2->T2_CODFUNC+DTOS(dDATA)))
				While !Eof() .and. xFilial("STK")+ST2->T2_CODFUNC+DTOS(dDATA) == STK->(TK_FILIAL+TK_CODFUNC+DTOS(TK_DATAINI))
					If DtoS(dDATA)+cHoraIni < DtoS(STK->TK_DATAFIM)+STK->TK_HORAFIM .and.;
					DtoS(dDATA)+cHoraFim > DtoS(STK->TK_DATAINI)+STK->TK_HORAINI

						lPROBLEMA := .T.
						Exit
					EndIf
					NGDBSELSKIP("STK")
				End
				If lPROBLEMA
					Exit
				EndIf
			EndIf

			//Verifica bloqueio da especialidade
			If lTemTTY
				For nForx := 1 To Len(aBloqTTY)
					If aBloqTTY[nForx,5] > 0 .and.;
					DtoS(dDATA)+cHoraIni < DtoS(aBloqTTY[nForx,3])+aBloqTTY[nForx,4] .and.;
					DtoS(dDATA)+cHoraFim > DtoS(aBloqTTY[nForx,1])+aBloqTTY[nForx,2]

						lPROBLEMA := .T.
						aBloqTTY[nForx,5]--
						Exit
					EndIf
				Next nForx
				If lPROBLEMA
					Exit
				EndIf
			EndIf

			dDATA++
		End

		If !lPROBLEMA
			nTOTAL++
		EndIf
		aAdd(aFUN,{ST2->T2_CODFUNC, If(lPROBLEMA,-1,0) })
		NGDBSELSKIP("ST2")
	End

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcula a a disponibilidade de funcionarios                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aFUN := aSORT(aFUN)
	aBACK := aCLONE(aFUN)
	lPROBLEMA := .F.
	If Round(nTOTAL * nDISPO,0) < aESP[3]
		aFUN  := {}
		For i := 1 To Len(aBACK)
			If aBACK[i][2] >= 0
				aAdd(aFUN,aBACK[i])
			EndIf
		Next
		lPROBLEMA := .T.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera problema                                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lPROBLEMA
		If nTOTAL > 0
			If !NGIFDBSEEK('STA',aESP[8]+aESP[9]+aESP[1]+"E"+aESP[2]+STR0022,1,.F.) //"NENHUM ESPECIALISTA DISPONIVEL"
				MNTGRAVSTA(aESP[8],aESP[9],aESP[1],"E",aESP[2],STR0061) //"QTD. DE ESPECIALISTA INSUFICIENTE"
			EndIf
		Else
			If !NGIFDBSEEK('STA',aESP[8]+aESP[9]+aESP[1]+"E"+aESP[2]+STR0061,1,.F.) //"QTD. DE ESPECIALISTA INSUFICIENTE"
				MNTGRAVSTA(aESP[8],aESP[9],aESP[1],"E",aESP[2],STR0022) //"NENHUM ESPECIALISTA DISPONIVEL"
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Bloqueio da quantidade disponivel                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Len(aFUN) > 0
		If lTemTTY
			MNTGRAVTTY(cEspCod,aESP[8],aESP[9],aESP[1],aESP[4],aESP[5],aESP[6],;
			aESP[7],STR0021+aESP[8], If(lPROBLEMA,Len(aFUN),aESP[3]) ) //"O.S. MANUTENCAO N."
		Else
			For i := 1 To Len(aFUN)
				MNTGRAVSTK(aFUN[i,1],aESP[8],aESP[9],aESP[1],aESP[4],aESP[5],aESP[6],;
				aESP[7],STR0021+aESP[8]) //"O.S. MANUTENCAO N."
			Next
		EndIf
	EndIf

	ST2->(dbSetOrder(1))
	STK->(dbSetOrder(1))
	If lTemTTY
		TTY->(dbSetOrder(1))
	EndIf
Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} A330PRO
Verifica saldo disponivel para produtos

@author  Paulo Pego
@since   07/05/2019
@version P11/P12
@param   aPRO, Array, 01 - Tarefa
					  02 - Código do Produto
					  03 - Quantidade
					  04 - Data inicio
					  05 - Hora inicio
					  06 - Data fim
					  07 - Hora fim
					  08 - O.S.
					  09 - Plano
					  10 - Centro de Custo
					  11 - Local
@param [nAmount], numerico, quantidade de produto solicitada
@param [nBkStock], numerico, saldo do produto (utilizado para não repetir verificação)
@param [cTpSaldo], string, valor do parâmetro MV_TPSALDO
@param [cTpSaldo], string, valor do parâmetro MV_NGINTER
/*/
//-------------------------------------------------------------------
Function A330PRO( aPRO, nAmount, nBkStock, cTpSaldo, lNgInter )

	Local cALMOX   := ""
	Local nSaldo   := 0
	Local nEMPENHO := 0

	Default nAmount := aPRO[ 3 ]
	Default nBkStock := -9999999
	Default cTpSaldo := AllTrim( SuperGetMV( 'MV_TPSALDO' ) )
	Default lNgInter := AllTrim( SuperGetMV( 'MV_NGINTER', .F., ''  ) ) == 'M'

	cCODPRO := Left(aPRO[2], Len(SB1->B1_COD))
	cOP     := aPRO[8] + "OS001"

	NGIFDBSEEK('SB1',cCODPRO,1,.F.)
	cALMOX  := If(!Empty(aPRO[11]),aPRO[11],SB1->B1_LOCPAD)

	If FindFunction( 'NGGetStock' )
		If nBkStock == -9999999 // quando saldo ainda não foi verificado
			nSaldo := NGGetStock( cCODPRO, cALMOX, xFilial('SB2'), cTpSaldo, lNgInter )
		Else
			nSaldo := nBkStock
		EndIf

		lPROBLEMA := nSaldo < nAmount
	Else

		If !NGIFDBSEEK('SB2',cCODPRO+cALMOX,1,.F.)
			CriaSB2(cCODPRO,cALMOX)
			SB2->(MsUnLock())
		EndIf

		nEMPENHO := If(SB2->B2_QEMP < 0, 0, SB2->B2_QEMP)

		cAliasQry := GetNextAlias()
		cQuery := " SELECT SUM(STL.TL_QUANTID) QTD "
		cQuery += " FROM "+RetSqlName("STL")+" STL "
		cQuery += " INNER JOIN "+RetSqlName("STJ")+" STJ "
		cQuery += " ON STJ.TJ_ORDEM = STL.TL_ORDEM AND STJ.TJ_PLANO = STL.TL_PLANO AND STJ.TJ_SITUACA = 'P' AND STJ.D_E_L_E_T_ <> '*' "
		cQuery += " WHERE STL.TL_SEQRELA = '0' AND STL.TL_CODIGO = '"+Trim(cCodPro)+"' AND STL.D_E_L_E_T_ <> '*' "
		cQuery += " GROUP BY STL.TL_CODIGO ORDER BY STL.TL_CODIGO "
		cQuery := ChangeQuery(cQuery)
		dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)

		While !Eof()
			nEmpenho += (cAliasQry)->(QTD)
			DbSkip()
		EndDo

		(cAliasQry)->(dbCloseArea())

		NGDBAREAORDE("STL",1)

		nSaldo    := IIf( lNgInter, NGMUStoLvl( cCODPRO, cALMOX, .F. ), SB2->B2_QATU )
		lPROBLEMA := (nSaldo < nEMPENHO)

	EndIf

	If lPROBLEMA
		MNTGRAVSTA(aPRO[8],aPRO[9],aPRO[1],"P",aPRO[2],STR0026) //"PRODUTO NAO DISPONIVEL"
	EndIf

Return nSaldo

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³BUSCAESP  ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Bloqueio da mao-de-obra (Recurso) para a manutencao        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ OBS      ³ Se existir bloqueio para o periodo gera problema.          ³±±
±±³          ³ Se o bloqueio for parcial gera problema e bloqueia o       ³±±
±±³          ³ restante do periodo                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function BUSCAESP(cCOD,nQTD,dINI,dFIM,hIni,hFim,aTAREFA,dTmpFim)
	Local aRET := {},aFUN := {},dDATA,nPRO := 0,nSEQ := 1,lPROBLEMA,i,x,y
	Local f, g, lHIni := .F., lHFim := .F., nDiaIni, nDiaFim, aCalend := {}, lWhile := .T.
	Local lFlutan := If(AllTrim(GetMv("MV_NGFLUT")) == "S",.t.,.F.)
	NGDBAREAORDE("STK",2)
	cCODXX := Left(cCOD,03)

	NGDBAREAORDE("ST2",2)

	dbSeek(xFilial("ST2")+cCODXX,.T.)
	While !Eof() .And. ST2->T2_FILIAL+ST2->T2_ESPECIA == xFilial("ST2")+cCODXX

		dDATA := dINI
		cCodTu := NGSEEK("ST1",ST2->T2_CODFUNC,1,'T1_TURNO')
		nPosCa := aSCAN(aCalenF,{|x| x[1] == cCodTu})
		If Empty(nPosCa)
			aAdd(aCalenF,{cCodTu,NGCALENDAH(cCodTu)})
			nPosCa := Len(aCalenF)
		EndIf

		//checa disponibilidade do funcionario
		If !NGFUNCRH(ST2->T2_CODFUNC,.F.,dFIM)
			NGDBSELSKIP("ST2")
			Loop
		EndIf
		If !NGFRHAFAST(ST2->T2_CODFUNC,dINI,dFIM,.F., .F.)
			NGDBSELSKIP("ST2")
			Loop
		EndIf

		If !lFlutan
			If !Empty(aCalenF[nPosCa,2])
				If Valtype(dTmpFim) == "D"
					aAdd(aFUN,{ST2->T2_CODFUNC,nPRO})
				Else
					If aCalenF[nPosCa,2,Dow(dDATA),1] <> "00:00" //Verifica se o funcionario trabalha no dia
						aAdd(aFUN,{ST2->T2_CODFUNC,nPRO})
					EndIf
				EndIf
			EndIf
		Else
			aAdd(aFUN,{ST2->T2_CODFUNC,0})
		EndIf
		NGDBSELSKIP("ST2")
	End

	aFUN := aSORT(aFUN,,,{|x,y| x[1] < y[1]})

	For i := 1 To Len(aFUN)
		aAdd(aRET, aFUN[i][1])
	Next

	ST2->(dbSetOrder(1))
	STK->(dbSetOrder(1))
Return aRET

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³A330Final ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Programa de exclusao de Familias de Bens                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ Void A330FINAL                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/ */
Function A330FINAL(cALIAS,nREG,nOPC)

	Local bCAMPO,nOPCA,cCOD
	Local i,cKEY
	Local oDLG,oMenu
	Local oPnlEnch
	Local LVAR01     := 1
	Local nLINHAS    := 0
	Local lERRO      := .F.
	Local aOS        := {}
	Local aFER       := {}
	Local aFOS       := {}
	Local lOk        := .T.
	Local lRet330A   := .T.   // Verifica o retorno do P.E. MNTA330A
	Local cOldSituac := ""
	Local oSize      := FwDefSize():New(.T.)
	Local nLinIniTl  := oSize:aWindSize[1] // Linha  inicial da tela
	Local nColIniTl  := oSize:aWindSize[2] // Coluna inicial da tela
	Local nLinFimTl  := oSize:aWindSize[3] // Linha  final   da tela
	Local nColFimTl  := oSize:aWindSize[4] // Coluna final   da tela
	Local oPanelTot  := Nil
 	Local nInd      := 0
	Local cCampo    := ""
	Local cRelacao  := ""
	Local aHeadFim  := {}

	Private aMNTA330A := {} // Array com as OS em abertas no Plano

	INCLUI := .F.
	If STI->TI_PLANO == "000000" .Or. STI->TI_PLANO == "000001"
		Help("",1,"PLANAOCANC")
		Return
	EndIf

	If STI->TI_SITUACA == "C" .Or. STI->TI_TERMINO = "S"
		Help("",1,"PLANJACANC")
		Return
	EndIf

	If !M330OSAB(STI->TI_PLANO)
		Return .T.
	EndIf

	If FindFunction("NGVLDSTL") .and. !NGVLDSTL("",STI->TI_PLANO) // verifica se não existe insumo com data e hora inicial igual a data e hora final
		Return .F.
	EndIf

	If ExistBlock("MNTA330A")
		lRet330A := ExecBlock("MNTA330A",.F.,.F.,{aMNTA330A})
		If !lRet330A
			Return .T.
		EndIf
	EndIf

	//Monta a entrada de dados do arquivo
	Private aTELA[0][0],aGETS[0]
	bCAMPO := {|nCPO| Field(nCPO)}
	M->TI_PLANO := STI->TI_PLANO

	For i := 1 To Fcount()
		M->&(EVAL(bCAMPO,i)) := FieldGet(i)
		If ValType(M->&(EVAL(bCAMPO,i))) == "C"
			M->&(EVAL(bCAMPO,i)) := Space(Len(M->&(EVAL(bCAMPO,i))))
		ElseIf ValType(M->&(EVAL(bCAMPO,i))) == "N"
			M->&(EVAL(bCAMPO,i)) := 0
		ElseIf ValType(M->&(EVAL(bCAMPO,i))) == "D"
			M->&(EVAL(bCampo,i)) := CTOD("  /  /  ")
		ElseIf ValType(M->&(EVAL(bCAMPO,i))) == "L"
			M->&(EVAL(bCAMPO,i)) := .F.
		EndIf
	Next i

	aHeadFim := NGHeader(cALIAS)

	For nInd := 1 To Len(aHeadFim)

		cCampo   := aHeadFim[nInd,2]
		cRelacao := Posicione("SX3",2,cCampo,"X3_RELACAO")

		If !Empty(cRelacao)
			xx  := "M->" + Trim(cCampo)
			yy  := Trim(cRelacao)
			&xx.:= &yy.
		Endif

	Next nInd

	While .T.

		//Envia para processamento dos Gets
		nOPCA := 0
		aPOS1 := {15,1,140,aPosObj[2,4]}

		DEFINE MSDIALOG oDLG TITLE cCADASTRO FROM nLinIniTl,nColIniTl TO nLinFimTl,nColFimTl OF oMAINWND PIXEL Style nOR(WS_VISIBLE,WS_POPUP)

		oPanelTot       := TPanel():Create(oDLG,0,0,,,.F.,,,CLR_WHITE,0,0)
		oPanelTot:Align := CONTROL_ALIGN_ALLCLIENT

		oPnlEnch       := TPanel():New(0,0,Nil,oPanelTot,Nil,.T.,.F.,Nil,Nil,0,0,.T.,.F.)
		oPnlEnch:Align := CONTROL_ALIGN_ALLCLIENT

		oEnchoice      := Msmget():New(cALIAS, nREG, 5,aAC,"AC",STR0023,,aPOS1,,3,,,,oPnlEnch) //"Quanto  finalizaso?"
		oEnchoice:oBox:Align := CONTROL_ALIGN_ALLCLIENT

		NGPOPUP(aSMenu,@oMenu)
		oDlg:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDlg)}

		ACTIVATE MSDIALOG oDLG ON INIT EnchoiceBar(oDLG,{|| nOPCA := 2,oDLG:End()},{|| nOPCA := 1,oDLG:End()})

		dbSelectArea(cALIAS)
		aFOS := {}

		If nOPCA == 2
			cCOD := STI->TI_PLANO
			dbSelectArea(cALIAS)
			RecLock(cALIAS,.F.)
			Replace STI->TI_TERMINO With "S",;
			STI->TI_USUARIO With If(Len(STI->TI_USUARIO) > 15,cUsername,Substr(CUSUARIO,7,15))
			STI->(MsUnLock())
			NGIFDBSEEK('STJ',cCOD,3,.F.)

			Do While !Eof() .And. xFilial("STJ") == STJ->TJ_FILIAL .And. cCOD == STJ->TJ_PLANO

				If STJ->TJ_TIPOOS = "B"
					lFIM   := .F.
					dPRINI := cToD("  /  /  ")
					hPRINI := Space(5)
					dPRFIM := cToD("  /  /  ")
					hPRFIM := Space(5)

					If STJ->TJ_SITUACA == "L" .And. STJ->TJ_TERMINO == "S"
						lFIM := .F.
					Else
						NGIFDBSEEK('STL',STJ->TJ_ORDEM+STJ->TJ_PLANO,1,.F.)
						Do While !Eof() .And. STL->TL_FILIAL == xFilial("STL") .And. STL->TL_ORDEM  == STJ->TJ_ORDEM  .And. STL->TL_PLANO  == STJ->TJ_PLANO

							If Val(STL->TL_SEQRELA) != 0
								lFIM := .T.
								Exit
							EndIf
							dbSkip()
						EndDo
						dbSelectArea("STJ")
					EndIf

					If lFIM
						nREG := Recno()
						NGFINAL(STJ->TJ_ORDEM,STJ->TJ_PLANO,dPRINI,hPRINI,dPRFIM,hPRFIM,0)
						NGDBAREAORDE("STJ",3)
						DbGoto(nREG)
					Else
						If STJ->TJ_SITUACA != "C" .And. STJ->TJ_TERMINO == "N"

							cOldSituac := STJ->TJ_SITUACA

							RecLock("STJ",.F.)
							STJ->TJ_SITUACA := "C"
							If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
								cObOS := NGMEMOSYP(STJ->TJ_MMSYP)
								cObOS := If(Empty(cObOS),STR0050,Alltrim(STJ->TJ_OBSERVA)+CRLF+STR0050)
								MsMM(,80,,cObOS,1,,,"STJ","TJ_MMSYP")
							Else
								cObOS := STJ->TJ_OBSERVA
								STJ->TJ_OBSERVA := If(Empty(cObOS),STR0050,Alltrim(STJ->TJ_OBSERVA)+CRLF+STR0050)
							EndIf
							STJ->(MsUnLock())

							//-----------------------------------------------------
							// Integração Mensagem Unica para Cancelamento de O.S.
							//-----------------------------------------------------
							If AllTrim(GetNewPar("MV_NGINTER","N")) == "M" .And. cOldSituac <> "P"
								NGMUCanMnO(STJ->(RecNo()))
							EndIf

							aAdd(aOS,{	STJ->TJ_ORDEM  ,;
							STJ->TJ_CODBEM ,;
							STJ->TJ_CCUSTO ,;
							STJ->TJ_DTMPINI,;
							STJ->TJ_HOMPINI,;
							STJ->TJ_PLANO  ,;
							STJ->TJ_SITUACA })
						EndIf
					EndIf
				EndIf
				NGDBSELSKIP("STJ")
			EndDo
			dbSetOrder(1)
			Processa({|lEND| lOK := a330DELMOV(aOS)})
			NGDBAREAORDE("STI",1)
		Else
			(cALIAS)->(MsUnLock())
		EndIf
		Exit
	EndDo
	dbSelectArea(cALIAS)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³A330DELMOV³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Elimina os Movimentos relacionados a OS                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A330DELMOV(aOS,lDELOS)
	Local i,cKEY, nSD
	Local aFER		:= {}
	Local aPRO		:= {}
	Local lDELSTJ	:= If(lDELOS = NIL,.F.,lDELOS)
	Local lMNTA3301	:= ExistBlock("MNTA3301")
	Local lMNTA3302	:= ExistBlock("MNTA3302")
	Local lNGMNTAS	:= SuperGetMV( "MV_NGMNTAS",.F.,"2" )
	Local lOK 		:= .T.
	Local cIntSFC 	:= If( FindFunction("NGINTSFC"), NGINTSFC(.F.), "" ) // Verifica se ha integracao com modulo Chao de Fabrica [SIGASFC]
	Local cNumCP	:= ""
	Local cProdTer	:= PADR( GETMV("MV_PRODTER") , LEN(SB1->B1_COD) )

	// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	// ³Elimina STL as ORDENS CANCELADAS                               ³
	// ³Elimina STK os Bloqueios de Mao de Obra                        ³
	// ³Elimina SH9 os Bloqueios do BEM                                ³
	// ³Elimina ST3 os Bloqueios do BEM                                ³
	// ³Elimina SC1 as Solicitacoes de Compras                         ³
	// ³Elimina SC2 as Ordens de Producao                              ³
	// ³Elimina STA os Problemas Gerados                               ³
	// ³Elimina SD4 os Empenhos do Produto                             ³
	// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Procregua(Len(aOS))

	For i := 1 To Len(aOS)
		Incproc()

		If lDELSTJ
			If NGIFDBSEEK('STJ',aOS[i][1]+aOS[i][6],1) .And. aOS[i][7] != "P"
				// [Mensagem Unica] Se ha integracao por MU, so integra OS que ja foi liberada
				If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"
					lDel := NGMUMntOrd(STJ->(RecNo()),5)
					If !lDel
						lOK := .F.
						Loop
					EndIf
				EndIf
			EndIf
		EndIf

		NGIFDBSEEK('ST9',aOS[i][2],1,.F.)
		If T9_FERRAME = "F"
			aAdd(aFER,{Left(T9_CODBEM,Len(SH9->H9_FERRAM)),aOS[i][4],aOS[i][5],aOS[i][1]})
		EndIf

		NGIFDBSEEK('STQ',aOS[i][1]+aOS[i][6],1,.F.)
		Do While !Eof() .And. TQ_FILIAL+TQ_ORDEM+TQ_PLANO == xFilial("STQ")+aOS[i][1]+aOS[i][6]
			NGDELETAREG("STQ")
			dbSkip()
		EndDo
		NGIFDBSEEK('STK',aOS[i][1]+aOS[i][6],1,.F.)
		Do While !Eof() .And. TK_FILIAL+TK_ORDEM+TK_PLANO == xFilial("STK")+aOS[i][1]+aOS[i][6]
			NGDELETAREG("STK")
			dbSkip()
		EndDo

		If NGCADICBASE("TTY_ORDEM","A","TTY",.F.)
			NGIFDBSEEK('TTY',aOS[i][1]+aOS[i][6],1,.F.)
			Do While !Eof() .And. TTY->(TTY_FILIAL+TTY_ORDEM+TTY_PLANO) == xFilial("TTY")+aOS[i][1]+aOS[i][6]
				NGDELETAREG("TTY")
				dbSkip()
			EndDo
		EndIf

		NGIFDBSEEK('STA',aOS[i][1]+aOS[i][6],1,.F.)
		Do While !Eof() .And. TA_FILIAL+TA_ORDEM+TA_PLANO == xFilial("STA")+aOS[i][1]+aOS[i][6]
			NGDELETAREG("STA")
			dbSkip()
		Enddo

		NGIFDBSEEK('STL',aOS[i][1]+aOS[i][6],1,.F.)
		Do While !Eof() .And. TL_FILIAL+TL_ORDEM+TL_PLANO == xFilial("STL")+aOS[i][1]+aOS[i][6]

			If TL_TIPOREG = "F"
				aAdd(aFER,{Left(TL_CODIGO,Len(SH9->H9_FERRAM)),TL_DTINICI,TL_HOINICI,TL_ORDEM})
			EndIf
			If TL_TIPOREG = "P"
				aAdd(aPRO,{TL_CODIGO,TL_QUANTID,aOS[i][7]})
			EndIf
			If TL_TIPOREG = "T"
				cKEY := If(FindFunction("NGProdMNT"), NGProdMNT("T")[1], cProdTer ) //Ira verificar apenas o primeiro Produto Terceiro do parametro
				aAdd(aPRO,{cKEY,0.00,aOS[i][7]})
			EndIf

			//DELETE SOLICITACAO AO ARMAZEM
			If NGCADICBASE('TL_NUMSA','A','STL',.F.)
				If !Empty(STL->TL_NUMSA)
					If NGIFDBSEEK('SCP',STL->TL_NUMSA+STL->TL_ITEMSA,1,.F.)
						If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"
							If lNGMNTAS == "1"
								cNumCP := SCP->CP_NUM
							Else
								NGMUReques(SCP->(RecNo()),"SCP",.F.,5)
							EndIf
						EndIf

						If Empty(cNumCP)

							// Realiza exclusão da S.A. e seus relacionamentos ( SCR ).
							IIf( FindFunction( 'MntDelReq' ), MntDelReq( SCP->CP_NUM, SCP->CP_ITEM, 'SA' ), NGDELETAREG( 'SCP' ) )

						EndIf

					EndIf
				EndIf
			EndIf
			NGDELETAREG("STL")
			dbSkip()

		EndDo

		If lNGMNTAS == "1"
			If !Empty(cNumCP) .And. NGIFDBSEEK( "SCP",cNumCP,01,.F. )
				If SCP->CP_PREREQU <> "S"
					If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"
						NGMUReques( SCP->( RecNo() ),"SCP",.F.,5 )
					EndIf
					NGDBAREAORD( "SCP",01 )

					While SCP->( DbSeek( xFilial( "SCP" ) + cNumCP ) )

						// Realiza exclusão da S.A. e seus relacionamentos ( SCR ).
						IIf( FindFunction( 'MntDelReq' ), MntDelReq( SCP->CP_NUM, SCP->CP_ITEM, 'SA' ), NGDELETAREG( 'SCP' ) )

					End While

				EndIf
			EndIf
		EndIf

		NGIFDBSEEK('SH9',"B"+DTOS(aOS[i][4]),4,.F.)
		While !Eof() .And. H9_FILIAL+H9_TIPO+DTOS(H9_DTINI) == xFilial("SH9")+"B"+DTOS(aOS[i][4])

			cMOTIVO := STR0018+aOS[i][1]+STR0019+aOS[i][6] //"OS.MANUT."###" PLANO "
			If Trim(cMOTIVO) == Trim(SH9->H9_MOTIVO) .And.  SH9->H9_ORIGEM == "1"
				NGDELETAREG("SH9")
			EndIf
			dbSkip()
		End

		NGIFDBSEEK('ST3',aOS[i][1]+aOS[i][6],2,.F.)
		Do While !Eof() .And. T3_FILIAL+T3_ORDEM+T3_PLANO == xFilial("ST3")+aOS[i][1]+aOS[i][6]
			NGDELETAREG("ST3")
			dbSkip()
		End

		//If aOS[i][7] == "L"
		NGIFDBSEEK('SC1',aOS[i][1]+"OS001",4,.F.)
		Do While !Eof() .And. C1_FILIAL+Substr(C1_OP,1,11) == xFilial("SC1")+aOS[i][1]+"OS001"

			If sc1->c1_tpop == 'F'
				If NGIFDBSEEK("SB2",SC1->C1_PRODUTO+SC1->C1_LOCAL,1,.F.)
					RecLock("SB2",.F.)
					SB2->B2_SALPEDI := SB2->B2_SALPEDI-(SC1->C1_QUANT-SC1->C1_QUJE)
					IF SB2->B2_SALPEDI < 0
						SB2->B2_SALPEDI := 0
					EndIf
					SB2->(MsUnLock())
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Remove o Numero e Item da SC do Pedido de Compra.              ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If NGIFDBSEEK('SC7',SC1->C1_PRODUTO,2,.F.)
					While !Eof() .And. xFilial('SC7')+SC1->C1_PRODUTO==SC7->C7_FILIAL+SC7->C7_PRODUTO
						If SC1->C1_Num+SC1->C1_ITEM == SC7->C7_NUMSC+SC7->C7_ITEMSC
							RecLock("SC7",.F.)
							Replace C7_NUMSC  With "",;
							C7_ITEMSC With ""
							SC7->(MsUnlock())
						EndIf
						NGDBSELSKIP("SC7")
					End
				EndIf
				If AllTrim(GetNewPar("MV_NGINTER","N")) == "M"
					//NGMUCanReq(SC1->(RecNo()),"SC1")
					NGMUReques(SC1->(RecNo()),"SC1",.F.,5)
				EndIf

				// Realiza exclusão da S.C. e seus relacionamentos ( SCR ).
				IIf( FindFunction( 'MntDelReq' ), MntDelReq( SC1->C1_NUM, SC1->C1_ITEM, 'SC' ), NGDELETAREG( 'SC1' ) )

			EndIf

			dbSkip()

		EndDo

		NGIFDBSEEK('SC2',aOS[i][1]+"OS",1,.F.)
		Do While !Eof() .And. C2_FILIAL+C2_NUM+C2_ITEM == xFilial("SC2")+aOS[i][1]+"OS"

			If lMNTA3301
				ExecBlock("MNTA3301",.F.,.F.)
			EndIf
			NGDELETAREG("SC2")
			If lMNTA3302
				ExecBlock("MNTA3302",.F.,.F.)
			EndIf
			dbSkip()
		EndDo

		// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		// ³Retira os empenhos do Produto do SD4                           ³
		// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nSD := 1 To Len(aPRO)
			If NGIFDBSEEK('SD4',aPRO[nSD][1]+aOS[i][1]+"OS001",1,.F.)
				cOP     := aOS[i][1]+"OS001"
				aTRAVAS := {}
				GRAVAEMP(SD4->D4_COD,SD4->D4_LOCAL,SD4->D4_QUANT,0,'','','','',cOP,Str(nSD,3),Nil,Nil,'SC2',Nil,SD4->D4_DATA,@aTRAVAS,.T.,.F.,.T.,.T.,Nil,Nil,.F.)
				NGDELETAREG("SD4")
			EndIf
		Next

		// EndIf

		If NGCADICBASE("TQ9_ORDEM","A","TQ9",.F.)
			NGIFDBSEEK('TQ9',aOS[i][1]+aOS[i][6],1,.F.)
			While !Eof() .And. TQ9_FILIAL+TQ9_ORDEM+TQ9_PLANO == xFilial("TQ9")+aOS[i][1]+aOS[i][6]
				NGDELETAREG("TQ9")
				dbSkip()
			End
		EndIf

		If lDELSTJ
			NGDELETAREG("STJ")
			If !Empty(cIntSFC) .And. !Empty(NGVRFMAQ(aOS[i][2]))
				NGSFCDELPP(aOS[i][1])
			EndIf
		EndIf
	Next

	// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	// ³Elimina SH9 os Bloqueios de ferramentas                        ³
	// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	NGDBAREAORDE("SH9",3)

	For i := 1 To Len(aFER)
		dbSelectArea("SH9")
		dbSeek(xFilial("SH9")+"F"+Left(aFER[i][1],Len(SH9->H9_FERRAM))+DTOS(aFER[i][2])+aFER[i][3])

		While !Eof()                                                             .And.;
		H9_FILIAL+H9_TIPO+H9_FERRAM+DTOS(H9_DTINI)+ H9_HRINI == xFilial("SH9")  +;
		"F"+Left(aFER[i][1],Len(SH9->H9_FERRAM))+DTOS(aFER[i][2])+aFER[i][3]

			cMOTIVO := STR0018+aFER[i][4]+STR0019+M->TI_PLANO //"OS.MANUT."###" PLANO "
			If Trim(cMOTIVO) == Trim(SH9->H9_MOTIVO) .And. SH9->H9_ORIGEM == '1'
				NGDELETAREG("SH9")
			EndIf
			dbSkip()
		End
	Next
Return lOK

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³A330REBLOQ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Funcao recusrsiva que efetua os bloqueios dos bens         ³±±
±±³          ³ Filhos contidos em uma estrutura                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A330REBLOQ(cCOD,aBEM)
	Local aBEM2 := {}, i
	If STC->(dbSeek(xFilial("STC")+cCOD))
		While !Eof() .And. STC->TC_FILIAL = Xfilial("STC") .And.;
		cCOD == STC->TC_CODBEM
			aAdd(aBEM, STC->TC_COMPONE)
			aAdd(aBEM2,STC->TC_COMPONE)
			STC->(dbSkip())
		End
	EndIf

	For i := 1 To Len(aBEM2)
		A330REBLOQ(aBEM2[i],@aBEM)
	Next
Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³A330PROC  ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Processa a Proxima data de Manutencao e a Data Real        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A330PROC(_TIPO,_CUMDOIS)
	Local nINTEI := 0,nRESTO := 0,nPOSPO := 0,cVALOR,nINCDAT := 0
	Local nSEMN
	Local aAreaTRB := {}
	Local nQtdOSDia := 0, nMaxOSDia := 0 // Quantidade de O.S. por Dia e Quantidade Máxima de O.S. em um Dia
	Local nK := 0

	//Ponto de entrada para definir a próxima manutenção (variáveis _CONPROX e _DTPROX)
	If ExistBlock("MNTA330G")
		Return ExecBlock("MNTA330G",.F.,.F.,{ _TIPO, _CUMDOIS})
	EndIf

	//------------------------------
	// Máximo de O.S. por Dia
	//------------------------------
	// Se o Tipo de Incremento da Manutenção for em Horas
	If STF->TF_UNENMAN == "H"
		nQtdOSDia := 0
		nMaxOSDia := MNTA340MXD(STF->TF_CODBEM, STF->TF_SERVICO, STF->TF_SEQRELA)

		// Recebe a quantidade de O.S. no Dia
		dbSelectArea(cTRB)
		aAreaTRB := GetArea()
		dbSetOrder(2)
		dbSeek(STF->TF_FILIAL + STF->TF_CODBEM + DTOS(dREAL), .T.)
		While !Eof() .And. (cTRB)->TF_FILIAL == STF->TF_FILIAL .And. (cTRB)->TF_CODBEM == STF->TF_CODBEM .And. DTOS((cTRB)->DTREAL) == DTOS(dREAL)
			// Neste trecho não precisamos verificar se o Plano de Manutenção é igual, pois o cTRB já é montado somente para o Plano atual
			// Apenas então para ficar ciente da regra, o Plano de Manutenção também é fator de filtro, mas espécificamente aqui não é necessário
			nQtdOSDia++

			dbSelectArea(cTRB)
			dbSkip()
		End
		RestArea(aAreaTRB)
	Else
		// Caso contrário, então somente pode haver uma O.S. por dia
		nMaxOSDia := 1
	EndIf

	//------------------------------
	// Executa o Processamento
	//------------------------------
	If _CUMDOIS = 1   // PRIMEIRO CONTADOR

		If _TIPO == "C"
			If _CONPROX == 0
				_CONPROX := STF->TF_CONMANU + STF->TF_INENMAN
				_DTPROX  := ((_CONPROX - M->T9_CONTACU) / M->T9_VARDIA)
			Else
				_CONPROX := _CONPROX+STF->TF_INENMAN
				_DTPROX  := (_CONPROX - M->T9_CONTACU) / M->T9_VARDIA
			EndIf

			nINTEI := Int(_DTPROX)
			nRESTO := If(nINTEI < 0,_DTPROX*-1,_DTPROX) - If(nINTEI < 0,nINTEI*-1,nINTEI)

			If nRESTO > 0
				cVALOR := Alltrim(Str(nRESTO))
				nPOSPO := At('.',cVALOR)
			EndIf

			nRESTO := If (nPOSPO > 0,Val(Substr(cVALOR,nPOSPO+1,1)),0)

			If nRESTO > 5
				nINCDAT := If(nINTEI <= 0,nINTEI-1,nINTEI+1)
			Else
				nINCDAT := nINTEI
			EndIf

			_DTPROX := M->T9_DTULTAC + nINCDAT

			If _DTPROX <= M->TF_DTULTMA
				_DTPROX :=  (M->TF_DTULTMA + 1 )
			EndIf

			If _DTPROX > M->TI_DATAFIM
				Return .F.
			EndIf

			If M->TI_ATRASAD == "S"
				If lFIRST
					lFIRST := If(lFIRST,.F.,lFIRST)
				Else
					If _DTPROX < M->TI_DATAINI
						Return .F.
					EndIf
				EndIf
			Else
				If _DTPROX < M->TI_DATAINI
					Return .F.
				Else
					lFIRST := If(lFIRST,.F.,lFIRST)
				EndIf
			EndIf

		ElseIf _TIPO == "F"

			// INICIO DO NOVA BLOCO
			If lCONTFIXO
				nULTCON := If(STF->(FieldPos("TF_CONPREV")) == 0,STF->TF_CONMANU,STF->TF_CONPREV)
				lCONTFIXO := .F.
			EndIf

			If _CONPROX == 0

				dbSelectArea("CTT")
				If CTT->(FieldPos("CTT_PERCFI")) > 0  //Campo utilizado pela Galvao Engenharia
					cCENTROCB := NGSEEK("ST9",STF->TF_CODBEM,1,"T9_CCUSTO")
					nPERCCUST := NGSEEK("CTT",cCENTROCB,1,"CTT_PERCFI")
					If nPERCCUST  > 0
						nPERCCUST := nPERCCUST / 100
						nINCPERC  := STF->TF_INENMAN * nPERCCUST
					Else
						nINCPERC := STF->TF_INENMAN * nPERFIXO  // Incremento da manutencao com percentual
					EndIf
				Else
					nINCPERC := STF->TF_INENMAN * nPERFIXO  // Incremento da manutencao com percentual
				EndIf

				nVEZMANU := Int(nULTCON / STF->TF_INENMAN) // Numero de vezes que foi feito a manutencao
				nCONTFIX := nVEZMANU * STF->TF_INENMAN     // Contador fixo exato
				nCONTPAS := nULTCON - nCONTFIX             // Quantidade que passou da manutenção fixa

				If nCONTPAS < nINCPERC .Or. nINCPERC == 0
					_CONPROX := nCONTFIX + STF->TF_INENMAN
				Else
					_CONPROX := nCONTFIX + STF->TF_INENMAN
					_CONPROX += STF->TF_INENMAN
				EndIf
				_DTPROX  := ((_CONPROX - M->T9_CONTACU) / M->T9_VARDIA)

			Else
				_CONPROX := _CONPROX + STF->TF_INENMAN
				_DTPROX  := ((_CONPROX - M->T9_CONTACU) / M->T9_VARDIA)
			EndIf

			nINTEI := Int(_DTPROX)
			nRESTO := If(nINTEI < 0,_DTPROX*-1,_DTPROX) - If(nINTEI < 0,nINTEI*-1,nINTEI)

			If nRESTO > 0
				cVALOR := Alltrim(Str(nRESTO))
				nPOSPO := At('.',cVALOR)
			EndIf

			nRESTO := If (nPOSPO > 0,Val(Substr(cVALOR,nPOSPO+1,1)),0)

			If nRESTO > 5
				nINCDAT := If(nINTEI <= 0,nINTEI-1,nINTEI+1)
			Else
				nINCDAT := nINTEI
			EndIf

			_DTPROX := M->T9_DTULTAC + nINCDAT

			If _DTPROX <= M->TF_DTULTMA
				Return .F.
			EndIf

			If _DTPROX > M->TI_DATAFIM
				Return .F.
			EndIf

			If M->TI_ATRASAD == "S"
				If lFIRST
					lFIRST := If(lFIRST,.F.,lFIRST)
				Else
					If _DTPROX < M->TI_DATAINI
						Return .F.
					EndIf
				EndIf
			Else
				If _DTPROX < M->TI_DATAINI
					Return .F.
				Else
					lFIRST := If(lFIRST,.F.,lFIRST)
				EndIf
			EndIf

			// FIM DO NOVA BLOCO

		ElseIf _TIPO = "T"
			If STF->TF_UNENMAN == "H" //Se for uma Manutenção em Horas

				If !_lFirstOS //Se não for a primeira ordem de serviço

					nHoras	 := SomaHoras( (cTRB)->TF_TEENMAN,_HHPROX ) //Incremento + Início do calendário

					aHrsCal := NG_H7( STF->TF_CALENDA ) //Retorna um array espandindo o calendário da manuteção

					For nK := 1 To Len( aCalenda[ 2 ][ 2 ] ) //Verifica quantas quebras possui o calendário da manutenção

						//Se estiver fora do período do calendário;
						If Len( aCalenda[ 2 ][ 2 ] ) <> 1
							If aCalenda[2][2][nK][1] > NTOH( nHoras ) .Or. aCalenda[2][2][nK][2]  > NTOH( nHoras )
								_HHPROX := nHoras
								Exit
							Else
								If nHoras > HTON( aHrsCal[1][2] ) //Se a qtd de horas for maior que a qtd máxima de hrs do calendario.
									_HHPROX := HTON( aHrsCal[1][1] )
									_DTPROX++ //A próxima manutenção irá acontecer no próximo dia;

									While A330DUTIL(_DTPROX,aHrsCal)
										_DTPROX++
										Loop
									End While

									Exit
								ElseIf nHoras == HTON( aHrsCal[1][2] ) //Se a qtd de horas for igual ao último horário do calendário;
									_HHPROX := HTON( aHrsCal[1][2] ) //Atribui o último horario do calendário;
									Exit
								EndIf
							EndIf
						Else
							If nHoras >= HTON( aHrsCal[1][2] ) //Se a qtd de horas for maior que a qtd máxima de hrs do calendario.
								//Verifica se a hora de incremento passo de 1 dia
								If nHoras >= 24
									nHoras :=  ( nHoras - 24 )
									//Verifica se na dentro do intervalo de horas do calendário
									If aCalenda[2][2][1][1] <= NTOH( nHoras ) .And. aCalenda[2][2][1][2]  >= NTOH( nHoras )
										_HHPROX := nHoras
									ElseIf aCalenda[2][2][1][1]  > NTOH( nHoras )
										_HHPROX := HTON( aHrsCal[1][1] )
									EndIf
								Else
									_HHPROX := HTON( aHrsCal[1][1] )
								EndIf

								_DTPROX++ //A próxima manutenção irá acontecer no próximo dia;

								While A330DUTIL(_DTPROX,aHrsCal)
									_DTPROX++
									Loop
								End While

								Exit
							Else
								_HHPROX := nHoras //Atribui o último horario do calendário;
								Exit
							EndIf
						EndIf

					Next nK
				Else
					//Se for a primeira ordem de serviço
					NGSOMAHORAS(HtoN(aCalenda[2][2][1][1]),"D","_HHPROX")
				EndIf

				If _lFirstOS
					_lFirstOS := .F. // Indica que não é mais o primeiro registro
				EndIf

			ElseIf STF->TF_UNENMAN == "D"
				_DTPROX := _DTPROX + STF->TF_TEENMAN
			ElseIf STF->TF_UNENMAN == "S"
				_DTPROX := _DTPROX + (STF->TF_TEENMAN*7)
			Else
				nANO := YEAR(_DTPROX)
				nMES := Month(_DTPROX)
				nDIA := Day(_DTPROX)
				nMES := nMES + STF->TF_TEENMAN
				Do While nMES > 12
					nMES := nMES - 12
					nANO := nANO + 01
				EndDo
				nDIA    := Strzero(nDIA,2)
				nMES    := Strzero(nMES,2)
				nANO    := AllTrim(Strzero(nANO,4))
				_DTPROX := CTOD(nDIA+'/'+nMES+'/'+nANO)

				Do While Empty(_DTPROX)
					nDIA    := Val(nDIA)-1
					nDIA    := Strzero(nDIA,2)
					_DTPROX := CTOD(nDIA+'/'+nMES+'/'+nANO)
				EndDo
			EndIf

			If M->TI_ATRASAD == "N"
				lFIRST  := .F.
				If (_DTPROX < M->TI_DATAINI) .Or. (_DTPROX > M->TI_DATAFIM)
					dREAL := _DTPROX
					Return .F.
				EndIf
			Else
				If _DTPROX > M->TI_DATAFIM
					Return .F.
				EndIf
			EndIf

			If _DTPROX <  M->TI_DATAINI
				If !lFIRST
					Return .F.
				Else
					lFIRST  := .F.
				EndIf
			EndIf
		EndIf

		// SEGUNDO CONTADOR
	Else
		If _CONPROX == 0
			_CONPROX := STF->TF_CONMANU + STF->TF_INENMAN
			_DTPROX  := ((_CONPROX - M->T9_CONTACU) / M->T9_VARDIA)
		Else
			_CONPROX := _CONPROX+STF->TF_INENMAN
			_DTPROX  := (_CONPROX - M->T9_CONTACU) / M->T9_VARDIA
		EndIf

		nINTEI := Int(_DTPROX)
		nRESTO := If(nINTEI < 0,_DTPROX*-1,_DTPROX) - If(nINTEI < 0,nINTEI*-1,nINTEI)

		If nRESTO > 0
			cVALOR := Alltrim(Str(nRESTO))
			nPOSPO := At('.',cVALOR)
		EndIf

		nRESTO := If (nPOSPO > 0,Val(Substr(cVALOR,nPOSPO+1,1)),0)

		If nRESTO > 5
			nINCDAT := If(nINTEI <= 0,nINTEI-1,nINTEI+1)
		Else
			nINCDAT := nINTEI
		EndIf

		_DTPROX := M->T9_DTULTAC + nINCDAT

		If _DTPROX <= M->TF_DTULTMA
			Return .F.
		EndIf

		If _DTPROX > M->TI_DATAFIM
			Return .F.
		EndIf

		If M->TI_ATRASAD == "S"
			If lFIRST
				lFIRST := If(lFIRST,.F.,lFIRST)
			Else
				If _DTPROX < M->TI_DATAINI
					Return .F.
				EndIf
			EndIf
		Else
			If _DTPROX < M->TI_DATAINI
				Return .F.
			Else
				lFIRST := If(lFIRST,.F.,lFIRST)
			EndIf
		EndIf

	EndIf

	If !Empty(dDPRIREAL)
		If _TIPO = "C" .Or. _TIPO = "F"
			If !lCONTREAL
				lCONTREAL := .T.
				dREAL     := (cTRB)->DTREAL
				If !lATRASA
					nDTREAL   := _DTPROX - (cTRB)->DTPROX
				Else
					nDTREAL   := STF->TF_INENMAN / M->T9_VARDIA
					nINTRE    := Int(nDTREAL)
					nRESRE    := If(nINTRE < 0,nDTREAL*-1,nDTREAL) - If(nINTRE < 0,nINTRE*-1,nINTRE)
					nPOSRE    := 0

					If nRESRE > 0
						cVALRE := Alltrim(Str(nRESRE))
						nPOSRE := At('.',cVALRE)
					EndIf

					nRESRE := If (nPOSRE > 0,Val(Substr(cVALRE,nPOSRE+1,1)),0)

					If nRESRE > 5
						nDTREAL := If(nINTRE <= 0,nINTRE-1,nINTRE+1)
					Else
						nDTREAL := nINTRE
					EndIf
				EndIf

				dREAL := dREAL+nDTREAL
			Else
				dREAL := dDPRIREAL + (_DTPROX - (cTRB)->DTPROX)
			EndIf

		ElseIf _TIPO = "T"
			If STF->TF_UNENMAN == "H"
				dREAL := dDPRIREAL + Int(STF->TF_TEENMAN/24)
			ElseIf STF->TF_UNENMAN == "D"
				dREAL := dDPRIREAL + STF->TF_TEENMAN
			ElseIf STF->TF_UNENMAN == "S"
				dREAL := dDPRIREAL + (STF->TF_TEENMAN*7)
			Else
				nANO := YEAR(dDPRIREAL)
				nMES := Month(dDPRIREAL)
				nDIA := Day(dDPRIREAL)
				nMES := nMES + STF->TF_TEENMAN
				While nMES > 12
					nMES := nMES - 12
					nANO := nANO + 01
				End
				nDIA  := Strzero(nDIA,2)
				nMES  := Strzero(nMES,2)
				nANO  := AllTrim(Strzero(nANO,4))
				dREAL := CTOD(nDIA+'/'+nMES+'/'+nANO)

				While Empty(dREAL)
					nDIA  := Val(nDIA)-1
					nDIA  := Strzero(nDIA,2)
					dREAL := CTOD(nDIA+'/'+nMES+'/'+nANO)
				End
			EndIf
		EndIf
	Else
		dREAL := _DTPROX
	EndIf

	//Verifica se a Data da manutenção é menor que a data Inicio do Plano
	If dREAL < M->TI_DATAINI
		dREAL := M->TI_DATAINI
		If STF->TF_UNENMAN == "H"
			_DTPROX := M->TI_DATAINI
		EndIf
		lATRASA := .T.
	EndIf
	If dREAL > M->TI_DATAFIM
		Return .F.
	EndIf

	// Verifica se já existe uma Ordem de Serviço para o mesmo dia
	// Observação: Nunca deve haver mais O.S. do que o máximo permitido por dia!
	If !MNTA340OSD(STF->TF_CODBEM, STF->TF_SERVICO, STF->TF_SEQRELA, _DTPROX)
		dREAL := _DTPROX
		Return .F.
	EndIf

	//Não gera O.S. para manutenção que ja esteja atrasada quando M->TI_ATRASAD == "N"
	If M->TI_ATRASAD == "N" .And. _DTPROX < M->TI_DATAINI
		Return .F.
	EndIf

	If STF->TF_UNENMAN <> "H" // Se o Tipo de Incremento não for em Horas
		dREAL := If(STF->TF_NAOUTIL = "U" .And. dREAL < _DTPROX,_DTPROX,dREAL)

		If !Empty(dREAL)

			While .T. //Verifica se é dia util
				nSEMN := If(DOW(dREAL)==1,7,DOW(dREAL)-1)
				If A330DUTIL(dREAL,aDIAMANUT) .Or. (Len(aDIAMANUT) > 0 .And. aDIAMANUT[nSEMN][3] == "00:00")
					If STF->TF_NAOUTIL == "U"
						Exit
					ElseIf STF->TF_NAOUTIL == "A"
						dREAL--
						If (dREAL < M->TI_DATAINI) .And. (M->TI_ATRASAD == "N")
							dREAL++
							Return .F.
						EndIf
					Else
						dREAL++
						If dREAL > M->TI_DATAFIM
							dREAL--
							Return .F.
						EndIf
					EndIf
					Loop
				EndIf
				Exit

			End While

		EndIf
	EndIf

	If !Empty( (cTRB)->DTREAL ) .And. STF->TF_CODBEM = (cTRB)->TF_CODBEM .And. STF->TF_SERVICO = (cTRB)->TF_SERVICO .And. STF->TF_SEQRELA = (cTRB)->TF_SEQRELA

		// Se o Tipo de Incremento não for em Horas (em Horas é o único que permite mais de uma O.S. por dia)
		If STF->TF_UNENMAN <> "H"
			// Se for a mesma data, então já existe uma O.S.
			nQtdOSDia := If(DTOS(dREAL) == DTOS((cTRB)->DTREAL), 1, 0)

			// Se for a mesma data
			If (Dtos(dREAL) == Dtos((cTRB)->DTREAL))
				// Apenas incrementa a data caso o número máximo de O.S. por dia seja ultrapassado
				If nQtdOSDia >= nMaxOSDia
					dDATREL := dREAL
					lENTRLO := .F.
					While .T.
						nSEMN := If(DOW(dDATREL)==1,7,DOW(dDATREL)-1)
						dDATREL ++
						If A330DUTIL(dDATREL,aDIAMANUT) .Or. aDIAMANUT[nSEMN][3] == "00:00"
							lENTRLO := .T.
						Else
							Exit
						EndIf
					End

					If lENTRLO
						dDATREL --
					EndIf

					If dDATREL > M->TI_DATAFIM
						Return .F.
					EndIf
					dREAL := dDATREL
				EndIf
			EndIf
		EndIf
	EndIf

	// Processo de projecao do contador
	If _TIPO $ "CF"
		If _DTPROX >= M->T9_DTULTAC
			If !lPrimCPr
				nIncCPr  := M->T9_VARDIA
				nPoscCpr := M->T9_POSCONT + ((_DTPROX - M->T9_DTULTAC) * nIncCPr)
				DDataCPr := _DTPROX
				lPrimCPr := .T.
			Else
				nPoscCpr += (_DTPROX - DdataCPr) * nIncCPr
				DDataCPr := _DTPROX
			EndIf
		EndIf
	EndIf
	dDPRIREAL := If(STF->TF_NAOUTIL = "U" .And. dREAL < _DTPROX,_DTPROX,dREAL)
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³PRE_STOP  ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Calcula a data e hora Parada Antes da manutencao           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function PRE_STOP(dData,Hora)
	Local aHoras := {}
	Local nTempo := 0

	If Empty((cTRB)->TF_TEPAANT)
		Return Nil
	EndIf
	If (cTRB)->TF_UNPAANT == "H" .Or. (cTRB)->TF_UNPAANT == "I"
		nTempo := If((cTRB)->TF_UNPAANT = "H",(cTRB)->TF_TEPAANT * 60,(cTRB)->TF_TEPAANT)
		aHoras := NGRETIRAHOR(Hora, MTOH(nTempo))
		dPre := dData - aHoras[2]
		hPre := aHoras[1]
	ElseIf (cTRB)->TF_UNPAANT == "S"
		dPRE := dData - ((cTRB)->TF_TEPAANT * 5)
		hPRE := Hora
	ElseIf (cTRB)->TF_UNPAANT == "M"
		dPRE := dData - ((cTRB)->TF_TEPAANT * 30)
		hPRE := Hora
	Else
		dPRE := dData - (cTRB)->TF_TEPAANT
		hPRE := Hora
	EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³POS_STOP  ³ Autor ³ Paulo Pego            ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Calcula a data e hora Parada Depois da Manutencao          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function POS_STOP(dData,Hora)
	Local aHoras := {}
	Local nTempo  := 0

	If Empty((cTRB)->TF_TEPADEP)
		Return Nil
	EndIf

	// Atualiza variaveis dPos e hPos, com o tempo posterior a manutencao
	If (cTRB)->TF_UNPADEP == "H" .Or. (cTRB)->TF_UNPADEP == "I"
		nTempo := If((cTRB)->TF_UNPADEP = "H",(cTRB)->TF_TEPADEP,(cTRB)->TF_TEPADEP/60)
		aHoras := NGDTHORFIM(dData,Hora,nTempo,"D")
		dPOS := aHoras[1]
		hPOS := aHoras[2]
	ElseIf (cTRB)->TF_UNPADEP == "S"
		dPOS := dData + ((cTRB)->TF_TEPADEP * 5)
		hPOS := Hora
	ElseIf (cTRB)->TF_UNPADEP == "M"
		dPOS := dData + ((cTRB)->TF_TEPADEP * 30)
		hPOS := Hora
	Else
		dPOS := dData + (cTRB)->TF_TEPADEP
		hPOS := Hora
	EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³MenuDef   ³ Autor ³ Ricardo Dal Ponte     ³ Data ³29/11/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Utilizacao de menu Funcional                               ³±±
±±³          ³                                                            ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array com opcoes da rotina.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Parametros do array a Rotina:                               ³±±
±±³          ³1. Nome a aparecer no cabecalho                             ³±±
±±³          ³2. Nome da Rotina associada                                 ³±±
±±³          ³3. Reservado                                                ³±±
±±³          ³4. Tipo de Transao a ser efetuada:                        ³±±
±±³          ³    1 - Pesquisa e Posiciona em um Banco de Dados           ³±±
±±³          ³    2 - Simplesmente Mostra os Campos                       ³±±
±±³          ³    3 - Inclui registros no Bancos de Dados                 ³±±
±±³          ³    4 - Altera o registro corrente                          ³±±
±±³          ³    5 - Remove o registro corrente do Banco de Dados        ³±±
±±³          ³5. Nivel de acesso                                          ³±±
±±³          ³6. Habilita Menu Funcional                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MenuDef()
	Local aROTINA := {{STR0004,"AxPesqui"  , 0 , 1}   ,; //"Pesquisar"
	{STR0005,"NGCAD01"  , 0 , 2}   ,; //"Visualizar"
	{STR0006,"A330INCLUI", 0 , 3}   ,; //"Incluir"
	{STR0007,"A330FINAL" , 0 , 2}   ,; //"Finalizar"
	{STR0008,"A330DELETA", 0 , 5, 3}}  //"Excluir"

Return(aRotina)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ M330OSAB ³ Autor ³ Elisangela Costa      ³ Data ³ 17/05/07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Monta a tela com as Ordens de Servico abertas do plano     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cPLANO - Codigo do Plano                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/ */
Function M330OSAB(cPLANO)

	Local oMenu

	Private lFinali   := .F.
	Private lFecArq   := .F.
	Private aVETINR   := {}
	Private cAliasTrb := GetNextAlias()
	Private cTRBZX    := GetNextAlias()
	Private oTmpTbl5
	Private oTmpTbl6

	//Tabela temporária para guardar os problemas encontrados no plano
	aDBF000 := {}
	aAdd(aDBF000,{"OS"     ,"C",TAMSX3("TJ_ORDEM")[1]  ,0}) // Ordem de Serviço
	aAdd(aDBF000,{"SEQUEN" ,"C",TAMSX3("TL_SEQRELA")[1],0}) // Sequencia
	aAdd(aDBF000,{"TIPO"   ,"C",TAMSX3("TL_TIPOREG")[1],0}) // Tipo de Insumo
	aAdd(aDBF000,{"CODIGO" ,"C",TAMSX3("TL_CODIGO")[1] ,0}) // Cod. Insumo
	aAdd(aDBF000,{"TIPCOT" ,"C",70                     ,0}) // Tipo de Cotação

	//Intancia classe FWTemporaryTable
	oTmpTbl5:= FWTemporaryTable():New( cAliasTrb, aDBF000 )
	//Adiciona os Indices
	oTmpTbl5:AddIndex( "Ind01" , {"OS","SEQUEN"} )
	//Cria a tabela temporaria
	oTmpTbl5:Create()

	//Tabela para gravar todas as O.s abertas do plano (L/N)
	aDBF001 := {}
	aAdd(aDBF001,{"ORDEM"   ,"C", 06,0}) //Ordem de servico
	aAdd(aDBF001,{"BEM"     ,"C", 16,0}) //Codigo do bem
	aAdd(aDBF001,{"NOMBEM"  ,"C", 30,0}) //Nome do bem
	aAdd(aDBF001,{"CCUSTO"  ,"C", Len(STJ->TJ_CCUSTO),0}) //Centro de custo
	aAdd(aDBF001,{"NOMCCU"  ,"C", 25,0}) //Nome do centro de custo
	aAdd(aDBF001,{"SERVICO" ,"C", 06,0}) //Servico
	aAdd(aDBF001,{"NOMSER"  ,"C", 30,0}) //Nome do servico
	aAdd(aDBF001,{"SEQUENC" ,If(NGVerify("STJ"),"C","N"), 03,0}) //Sequencia
	aAdd(aDBF001,{"DTPREVI" ,"D", 08,0}) //Data prevista inicio
	aAdd(aDBF001,{"HPREVIN" ,"C", 05,0}) //Hora prevista inicio

	//Intancia classe FWTemporaryTable
	oTmpTbl6:= FWTemporaryTable():New( cTRBZX, aDBF001 )
	//Adiciona os Indices
	oTmpTbl6:AddIndex( "Ind01" , {"BEM","ORDEM"} )
	//Cria a tabela temporaria
	oTmpTbl6:Create()

	NGIFDBSEEK('STJ',cPLANO,3,.F.)
	While !Eof() .And. STJ->TJ_FILIAL == xFilial("STJ") .And. STJ->TJ_PLANO == cPLANO

		If STJ->TJ_SITUACA == "L" .And. STJ->TJ_TERMINO == "N"
			dbSelectArea(cTRBZX)
			(cTRBZX)->(DbAppend())
			(cTRBZX)->BEM     := STJ->TJ_CODBEM
			(cTRBZX)->NOMBEM  := If(STJ->TJ_TIPOOS == "B",NGSEEK("ST9",STJ->TJ_CODBEM,1,"Substr(T9_NOME,1,30)"),NGSEEK("TAF","X2"+Substr(STJ->TJ_CODBEM,1,3),7,"Substr(TAF_NOMNIV,1,30)"))
			(cTRBZX)->ORDEM   := STJ->TJ_ORDEM
			(cTRBZX)->CCUSTO  := STJ->TJ_CCUSTO
			(cTRBZX)->NOMCCU  := NGSEEK("SI3",STJ->TJ_CCUSTO,1,"Substr(I3_DESC,1,25)")
			(cTRBZX)->SERVICO := STJ->TJ_SERVICO
			(cTRBZX)->NOMSER  := NGSEEK("ST4",STJ->TJ_SERVICO,1,"Substr(T4_NOME,1,30)")
			(cTRBZX)->SEQUENC := If(NGVerify("STJ"),STJ->TJ_SEQRELA,STJ->TJ_SEQUENC)
			(cTRBZX)->DTPREVI := STJ->TJ_DTMPINI
			(cTRBZX)->HPREVIN := STJ->TJ_HOMPINI
			//Verifica problema de cotação e solicitações pendentes para cada insumo.
			MNT330INSB(STJ->TJ_ORDEM,cAliasTrb)

			aAdd(aMNTA330A,{STJ->TJ_FILIAL,STJ->TJ_ORDEM,STJ->TJ_PLANO}) // Adiciona informações no array para a P.E. MNTA330A

		EndIf
		NGDBSELSKIP("STJ")
	End

	NGSETIFARQUI((cTRBZX),,1)
	If Reccount() == 0
		oTmpTbl6:Delete()
		Return .T.
	EndIf
	NGSETIFARQUI(cAliasTrb,,1)
	If Reccount() > 0
		If MsgYesNo(STR0097)//
			fImp330Log(cAliasTrb)
		EndIf
		oTmpTbl6:Delete()
		oTmpTbl5:Delete() //Deleta aquivo de problemas do plano
		Return .F.
	EndIf

	Define Dialog oDlg330 From 6,0 To 34,100 Title STR0029+" "+cPLANO //"Ordens de serviço em aberto do plano >>"

	@.5,005 Button STR0047 Size 38,12 Pixel Action MNTFI330(.T.)
	@.5,055 Button STR0048 Size 38,12 Pixel Action MNTFI330(.F.)

	dbSelectArea(cTRBZX)
	@ 1,0.3 ListBox Fields  ORDEM   ,;
	BEM     ,;
	NOMBEM  ,;
	SERVICO ,;
	NOMSER  ,;
	SEQUENC ,;
	CCUSTO  ,;
	NOMCCU  ,;
	DTPREVI ,;
	HPREVIN ;
	FieldSizes 30,80,150,40,150,30,80,150,40,40;
	Size 388,180;
	HEADERS STR0030 ,; //"Ordem"
	STR0031 ,; //"Bem"
	STR0032 ,; //"Descrição"
	STR0034 ,; //"Serviço"
	STR0032 ,; //"Descrição"
	STR0035 ,; //"Sequência"
	STR0033 ,; //"C.Custo"
	STR0032 ,; //"Descrição"
	STR0036 ,; //"Dt. Prev. Ini."
	STR0037    //"Hr. Prev. Ini."

	NGPOPUP(aSMenu,@oMenu)
	oDlg330:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDlg330)}

	Activate Dialog oDlg330

	//Deleta os Arquivos temporarios fisicamente
	If !lFecArq
		oTmpTbl6:Delete()
	EndIf

Return lFinali

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNTFI330  ³ Autor ³In cio Luiz Kolling    ³ Data ³30/04/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Controle para a confirmacao da finalizacao do plano (O.S.)  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTFI330(lFiln)
	lFinali := lFiln
	oDlg330:End()
	//Deleta o Arquivo temporario
	oTmpTbl6:Delete()
	lFecArq := .t.
Return lFiln

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ MNTA330E ³ Autor ³In cio Luiz Kolling    ³ Data ³18/04/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Atribuicao de valores para as variaveis e titulos          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ DICIONARIO                                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTA330E()

	Local nF1
	Local nF2
	Local lSaiL  := .F.
	Local nITEM  := 0
	Local xTeste := ""

	nITEM := If(M->TI_ESTRUTU = 'S',Ascan(oENCHOICE:aGETS,{|X| "TI_BEMINI" $X}),Ascan(oENCHOICE:aGETS,{|X| "TI_CCUSINI" $X}))

	If nL1 = 0
		For nF1 := 1 To Len(aTELA)
			For nF2 := 1 To Len(aTELA[nF1])
				If ValType(aTELA[nF1,nF2]) == "C" // Alteração temporaria para corrigir problema de aTela
					If aTELA[nF1,nF2] = cNBemi
						nL1 := nF1
						nC1 := nF2
					EndIf
					If aTELA[nF1,nF2] = cNNomi
						nL2 := nF1
						nC2 := nF2
					EndIf
					If nL1 <> 0 .And. nL2 <> 0
						lSaiL := .t.
						Exit
					EndIf
				EndIf
			Next nF2
			If lSaiL
				Exit
			EndIf
		Next nF1
	EndIf

	If M->TI_ESTRUTU = 'S'
		lEstrut := .t.
		aArrCam := {{"CCUSINI","CTRAINI","SERVINI","AREAINI","TIPOINI","FAMIINI","BEMINI","NOMCINI","NOMCFIM","NOMRINI","NOMRFIM",;
		"NOMSINI","NOMSFIM","NOMAINI","NOMAFIM","NOMTINI","NOMTFIM","NOMFINI","NOMFFIM","NOMBINI","NOMBFIM"},;
		{"CCUSFIM","CTRAFIM","SERVFIM","AREAFIM","TIPOFIM","FAMIFIM","BEMFIM"}}
		If lModBe
			aAdd(aArrCam[1],"TIPMODI")
			aAdd(aArrCam[2],"TIPMODF")
			aAdd(aArrCam[1],"DESMODI")
			aAdd(aArrCam[1],"DESMODF")
		EndIf

		For nF1 := 1 To Len(aArrCam)
			For nF2 := 1 To Len(aArrCam[nF1])
				&("M->TI_"+aArrCam[nF1,nF2]) := NGPREENCH(If(nF1 = 1," ","Z"),"TI_"+aArrCam[nF1,nF2])
			Next nF2
		Next nF1
		aTELA[nL1,nC1] := STR0043
		aTELA[nL2,nC2] := STR0045+' '+STR0043
	Else
		aTELA[nL1,nC1] := cNBemi
		aTELA[nL2,nC2] := cNNomi
		lEstrut := .F.
	EndIf

	If nITEM > 0
		oOBSTJ := oENCHOICE:aENTRYCTRLS[nITEM]
		oOBSTJ:SETFOCUS(oOBSTJ)
	EndIf

Return .t.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ MNTA330E ³ Autor ³In cio Luiz Kolling    ³ Data ³22/04/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Consistencia para o campo bem inicio e/ou pai da estrutura ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ DICIONARIO                                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTA330BE()
	Local lEstP := .t.,lBemIni := .F.
	If lCEstru
		If M->TI_ESTRUTU = "S"
			If !ExistCpo("ST9",M->TI_BEMINI)
				Return .F.
			EndIf
			cBemP := NGBEMPAI(M->TI_BEMINI)
			If Empty(cBemP)
				If !NGIFDBSEEK('STC',M->TI_BEMINI,1,.F.)
					lEstP := .F.
				EndIf
			Else
				If cBemP <> M->TI_BEMINI
					lEstP := .F.
				EndIf
			EndIf
			If !lEstP
				MsgInfo(STR0046,STR0042)
			EndIf

		Else
			lBemIni := .t.
		EndIf
	Else
		lBemIni := .t.
	EndIf

	If lBemIni
		If !Empty(M->TI_BEMINI)
			If !ExistCpo("ST9",M->TI_BEMINI)
				lEstP := .F.
			EndIf
		EndIf
	EndIf
Return lEstP

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ MNTA330FI³ Autor ³In cio Luiz Kolling    ³ Data ³23/04/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Consistencia final                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTA330FI()
	Local lRet := .t.
	If !OBRIGATORIO(aGETS,aTELA)
		lRet := .F.
	EndIf
	If lRet
		If lEstrut
			If Empty(M->TI_BEMINI)
				MsgInfo(STR0043+' '+STR0044,STR0042)
				lRet := .F.
			EndIf
		EndIf
	EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNTGRAVSTA³ Autor ³In cio Luiz Kolling    ³ Data ³28/04/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Grava os problema                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTGRAVSTA(cvORD,cvPLA,cvTARE,cvTRE,cvCOD,cvDES)
	cvTARE := If(cvTARE <> Nil,cvTARE,Space(Len(STA->TA_TAREFA)))
	cvTARE := Alltrim(cvTARE)+Space(Len(STA->TA_TAREFA)-Len(Alltrim(cvTARE)))
	cDesPr := Alltrim(cvDES)+Space(Len(STA->TA_DESCRIC)-Len(Alltrim(cvDES)))
	cCodTa := Alltrim(cvCOD)+Space(Len(STA->TA_CODIGO)-Len(Alltrim(cvCOD)))
	If !NGIFDBSEEK('STA',cvORD+cvPLA+cvTARE+cvTRE+cCodTa+cDesPr,1,.F.)
		RecLock("STA",.T.)
		STA->TA_FILIAL  := xFilial("STA")
		STA->TA_ORDEM   := cvORD
		STA->TA_PLANO   := cvPLA
		STA->TA_TAREFA  := cvTARE
		STA->TA_TIPOREG := cvTRE
		STA->TA_CODIGO  := cCodTa
		STA->TA_DESCRIC := cDesPr
		STA->(MsUnLock())
	EndIf
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNT330GMAT³ Autor ³In cio Luiz Kolling    ³ Data ³29/04/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Alimenta a matriz de insumos/tarefas..... (aTAREFA)         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT330GMAT(mI,mS,aDados)
	aAdd(aTAREFA[mI][mS],aDados)
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNTGRAVSH9³ Autor ³In cio Luiz Kolling    ³ Data ³30/04/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Grava os bloqueios de recurso                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTGRAVSH9(vREC,vCUST,vMOTI,vdINI,vdFIM,vhINI,vhFIM,vTipo,vOrig,;
	vFER,vQTD)

	//desfazer SGT na versao 12 (verificar com a Totvs)
	/*
	If AliasInDic("SGT")
	dbSelectArea("SGT")
	RecLock("SGT",.T.)
	SGT->GT_FILIAL  := xFilial("SGT")
	SGT->GT_RECURSO := If(vREC <> Nil,vREC,Space(Len(SGT->GT_RECURSO)))
	SGT->GT_CCUSTO  := If(vCUST <> Nil,vCUST,Space(Len(SGT->GT_CCUSTO)))
	SGT->GT_MOTIVO  := vMOTI
	SGT->GT_DTINI   := vdINI
	SGT->GT_DTFIM   := vdFIM
	SGT->GT_HRINI   := vhINI
	SGT->GT_HRFIM   := vhFIM
	SGT->GT_TIPO    := vTipo
	SGT->GT_ORIGEM  := vOrig
	SGT->GT_FERRAM  := If(vFER <> Nil,vFER,Space(Len(SGT->GT_FERRAM)))
	SGT->GT_QUANT   := If(vQTD <> Nil,vQTD,0)
	SGT->(MsUnLock())
	EndIf
	*/

	dbSelectArea("SH9")
	RecLock("SH9",.T.)
	SH9->H9_FILIAL  := xFilial("SH9")
	SH9->H9_RECURSO := If(vREC <> Nil,vREC,Space(Len(SH9->H9_RECURSO)))
	SH9->H9_CCUSTO  := If(vCUST <> Nil,vCUST,Space(Len(SH9->H9_CCUSTO)))
	SH9->H9_MOTIVO  := vMOTI
	SH9->H9_DTINI   := vdINI
	SH9->H9_DTFIM   := vdFIM
	SH9->H9_HRINI   := vhINI
	SH9->H9_HRFIM   := vhFIM
	SH9->H9_TIPO    := vTipo
	SH9->H9_ORIGEM  := vOrig
	SH9->H9_FERRAM  := If(vFER <> Nil,vFER,Space(Len(SH9->H9_FERRAM)))
	SH9->H9_QUANT   := If(vQTD <> Nil,vQTD,0)
	SH9->(MsUnLock())
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNTGRAVSTK³ Autor ³In cio Luiz Kolling    ³ Data ³30/04/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Grava os bloqueios de funcionarios                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTGRAVSTK(vCOD,vORD,vPLA,vTAR,vDTI,vHOI,vDTF,vHOF,vMOT)
	If !NGIFDBSEEK('STK',vORD+vPLA+vTAR+vCOD+DTOS(vDTI)+vHOI,1,.F.)
		RecLock("STK",.T.)
		STK->TK_FILIAL  := xFilial("STK")
		STK->TK_CODFUNC := vCOD
		STK->TK_ORDEM   := vORD
		STK->TK_PLANO   := vPLA
		STK->TK_TAREFA  := vTAR
		STK->TK_DATAINI := vDTI
		STK->TK_HORAINI := vHOI
		STK->TK_DATAFIM := vDTF
		STK->TK_HORAFIM := vHOF
		STK->TK_MOTIVO  := vMOT
		STK->(MsUnLock())
		//retirar esse Else na ver11, foi colocado porque o indice 1 da STK estava sem data e hora no indice 1, e no x2_unico estava com data e hora
	Else
		If DtoS(STK->TK_DATAINI)+STK->TK_HORAINI <> DtoS(vDTI)+vHOI
			RecLock("STK",.T.)
			STK->TK_FILIAL  := xFilial("STK")
			STK->TK_CODFUNC := vCOD
			STK->TK_ORDEM   := vORD
			STK->TK_PLANO   := vPLA
			STK->TK_TAREFA  := vTAR
			STK->TK_DATAINI := vDTI
			STK->TK_HORAINI := vHOI
			STK->TK_DATAFIM := vDTF
			STK->TK_HORAFIM := vHOF
			STK->TK_MOTIVO  := vMOT
			STK->(MsUnLock())
		EndIf
	EndIf
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNTGRAVTTY³ Autor ³ Denis                 ³ Data ³12/11/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Grava os bloqueios de especialidade                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTGRAVTTY(vCOD,vORD,vPLA,vTAR,vDTI,vHOI,vDTF,vHOF,vMOT,nQtd)
	If !NGIFDBSEEK('TTY',vORD+vPLA+vTAR+vCOD+DTOS(vDTI)+vHOI,1)
		RecLock("TTY",.T.)
		TTY->TTY_FILIAL  := xFilial("TTY")
		TTY->TTY_CODESP := vCOD
		TTY->TTY_ORDEM  := vORD
		TTY->TTY_PLANO  := vPLA
		TTY->TTY_TAREFA := vTAR
		TTY->TTY_DTINI  := vDTI
		TTY->TTY_HRINI  := vHOI
		TTY->TTY_DTFIM  := vDTF
		TTY->TTY_HRFIM  := vHOF
		TTY->TTY_MOTIVO := vMOT
		TTY->TTY_QUANTI := nQtd
		TTY->(MsUnLock())
	EndIf
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNT330TPMDO³ Autor ³Evaldo Cevinscki Jr.   ³ Data ³27/04/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Retorno do relacao do campo TI_TIPOMDO                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA330,MNTA350                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT330TPMDO()
Return If(!INCLUI,STI->TI_TIPOMDO,If(FunName()=="MNTA350",'F','E'))

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNT330DIST ³ Autor ³In cio Luiz Kolling    ³ Data ³30/04/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Prepara a matriz aTAREFA                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT330DIST(nIa,aArEsF)
	Local nFd := 0

	For nFd := 1 To Len(aArEsF)
		cCodFunI := Alltrim(aArEsF[nFd,2])+Space(Len(stl->tl_codigo)-Len(Alltrim(aArEsF[nFd,2])))
		MNT330GMAT(nIa,5,{aArEsF[nFd,1],cCodFunI,aArEsF[nFd,3],aArEsF[nFd,4],;
		aArEsF[nFd,5],aArEsF[nFd,6],aArEsF[nFd,7],aArEsF[nFd,8],;
		aArEsF[nFd,9],aArEsF[nFd,10],aArEsF[nFd,11],aArEsF[nFd,12],;
		aArEsF[nFd,13],aArEsF[nFd,14],aArEsF[nFd,15],aArEsF[nFd,16],;
		aArEsF[nFd,17],Space(3),aArEsF[nFd,19],.F.,"",""})

	Next nFd
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNT330NOTAR³ Autor ³In cio Luiz Kolling    ³ Data ³30/04/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Calcula a dependencias e data e hora final                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MNT330NOTAR()
	Local nFt := 0,nIt := 0,nFf := 0,dDtaFi := (cTRB)->DTREAL,aDepend := {},lVerBloq,lAjusteCal, aTmpEsp, lTemC20
	Local cHorFI,cHorFF,dDataFF := Ctod("  /  /  ")
	Local lCampoTol := If( Type("(cTRB)->DTLIMTOL") == "D" , .T. , .F. )
	Local lTarefTol := .F. //Tolerancia por Data, Hora e Funcionario
	Local lTaDiaTol := .F. //Tolerancia por Hora e Funcionario
	Local lTaNaoTol := .F. //Tolerancia por Funcionario

	Store Space(5) To cHorFI,cHorFF
	dDtaIn := dDtMI // Data da manutencao que tem calendario... (cTRB)->DTREAL
	cHorIM := MNT330PUHC((cTRB)->TF_CALENDA,dDtaIn,"P") //Verifica primeira hora disponivel no dia

	//Carrega variavel aDepend com as Dependencias de Tarefas
	aTAREFA := aSORT(aTAREFA,,,{|x,y| x[6,1]+x[1] < y[6,1]+y[1] })
	For nFt := 1 To Len(aTAREFA)
		nIt := 1
		While nIt <= Len(aTAREFA[nFt][5])
			If (cTRB)->TF_UNENMAN == "H"
				dDtaIn := If(aTarefa[nFt][5][nIt][7] > dDtMI, aTarefa[nFt][5][nIt][7], dDtMI)
			EndIf
			nSEM   := If(DOW(dDtaIn) == 1,7,DOW(dDtaIn)-1)
			cCodTu := (cTRB)->TF_CALENDA

			cHorIn := MNT330PUHC(cCodTu,dDtaIn,"P") //Verifica primeira hora disponivel no dia

			If aTAREFA[nFt,5,nIt,1] = "M"
				cCodTu := NGSEEK("ST1",aTAREFA[nFt,5,nIt,2],1,'T1_TURNO')

				// SE FOR FLUTUANTE ???
				If !Empty(aTAREFA[nFt,5,nIt,18])
					cHorIn := aTAREFA[nFt,5,nIt,8]
				Else
					If Empty(aTAREFA[nFt,5,nIt,8]) .Or.  Alltrim(aTAREFA[nFt,5,nIt,8]) = ":"
						cHorIn := MNT330PUHC(cCodTu,dDtaIn,"P") //Verifica primeira hora disponivel no dia
					Else
						cHorIn := aTAREFA[nFt,5,nIt,8]
					EndIf

					lTemCa := .t.
					If Empty(cHorIn)
						lTemCa := .F.
					Else
						lTemCa := MNT330CHICA(dDtaIn,cHorIn,cCodTu,.F.)
					EndIf
					If !lTemCa
						If Empty(cHorIn)
							cHorIn := "00:00"
						EndIf
					EndIf
				EndIf

			EndIf

			aTAREFA[nFt,5,nIt,7] := dDtaIn
			aTAREFA[nFt,5,nIt,8] := cHorIn

			If aTAREFA[nFt,5,nIt,1] = "P"
				nIt ++
				Loop
			EndIf

			nPosDep := Ascan(aDepend,{|x| x[1] == aTAREFA[nFt,1]})
			If nPosDep = 0
				aAdd(aDepend,{aTAREFA[nFt,1],dDtaIn,cHorIn,;
				aTAREFA[nFt,5,nIt,4],aTAREFA[nFt,5,nIt,5],;
				StoD(""),"  :  " })

				//      tarefa,data in, hora in,quantidade,unidade
			Else
				If dDtaIn > aDepend[nPosDep,2]
					aDepend[nPosDep,2] := dDtaIn
					aDepend[nPosDep,3] := cHorIn
					aDepend[nPosDep,4] := aTAREFA[nFt,5,nIt,4]
					aDepend[nPosDep,5] := aTAREFA[nFt,5,nIt,5]
				ElseIf dDtaIn = aDepend[nPosDep,2]
					If aDepend[nPosDep,5] <> aTAREFA[nFt,5,nIt,5]
						If aTAREFA[nFt,5,nIt,5] = "M"
							If aTAREFA[nFt,5,nIt,4] > aDepend[nPosDep,4]
								aDepend[nPosDep,2] := dDtaIn
								aDepend[nPosDep,3] := cHorIn
								aDepend[nPosDep,4] := aTAREFA[nFt,5,nIt,4]
								aDepend[nPosDep,5] := aTAREFA[nFt,5,nIt,5]
							EndIf
						EndIf
						If aTAREFA[nFt,5,nIt,5] = "S"
							If aDepend[nPosDep,5] <> "D" .Or. aDepend[nPosDep,5] <> "H"
								If aTAREFA[nFt,5,nIt,4] > aDepend[nPosDep,4]
									aDepend[nPosDep,2] := dDtaIn
									aDepend[nPosDep,3] := cHorIn
									aDepend[nPosDep,4] := aTAREFA[nFt,5,nIt,4]
									aDepend[nPosDep,5] := aTAREFA[nFt,5,nIt,5]
								EndIf
							EndIf
						EndIf

						If aTAREFA[nFt,5,nIt,5] = "H"
							If aDepend[nPosDep,5] <> "M" .Or. aDepend[nPosDep,5] <> "S"
								If aTAREFA[nFt,5,nIt,4] > aDepend[nPosDep,4]
									aDepend[nPosDep,2] := dDtaIn
									aDepend[nPosDep,3] := cHorIn
									aDepend[nPosDep,4] := aTAREFA[nFt,5,nIt,4]
									aDepend[nPosDep,5] := aTAREFA[nFt,5,nIt,5]
								EndIf
							EndIf
						EndIf
					Else
						If aTAREFA[nFt,5,nIt,4] > aDepend[nPosDep,4]
							aDepend[nPosDep,4] := aTAREFA[nFt,5,nIt,4]
						EndIf
					EndIf
				EndIf
			EndIf
			nIt ++
		End
	Next nFt

	aDtHrSTJ := {}
	For nFt := 1 To Len(aTAREFA)
		nIt := 1
		While nIt <= Len(aTAREFA[nFt][5])

			//Indica se o insumo era Especialidade, porém foi alocado como Funcionario, e existe outra opção de funcionario para especialidade
			aTmpEsp := If( Len(aTAREFA[nFt,5,nIt]) >= 19 , If( ValType(aTAREFA[nFt,5,nIt,19]) == "A" , aTAREFA[nFt,5,nIt,19] , {} ) , {} )
			//Indica se a tarefa foi processada
			lTemC20 := If( Len(aTAREFA[nFt,5,nIt]) >= 20 , If( ValType(aTAREFA[nFt,5,nIt,20]) == "L" , .T. , .F. ) , .F. )
			//Indica se deve gerar problema de Excedeu Calendario Manutencao
			lPrExcCal := .t.

			lTarefTol := If( lCampoTol .and. aTAREFA[nFt,5,nIt,1] == "M" .and. !Empty((cTRB)->DTLIMTOL) .and. Empty(aTAREFA[nFt,6,1]) , .T. , .F. )
			lTaDiaTol := If( lCampoTol .and. aTAREFA[nFt,5,nIt,1] == "M" .and. !Empty((cTRB)->DTLIMTOL) , .T. , .F. )
			If !lTarefTol .and. !lTaDiaTol
				lTaNaoTol := If( aTAREFA[nFt,5,nIt,1] == "M" .and. Len(aTmpEsp) > 1, .T. , .F. )
			EndIf

			If !Empty(aTAREFA[nFt,6,1]) //Se Tarefa tiver dependencia
				nPosDep := Ascan(aDepend,{|x| x[1] == aTAREFA[nFt,6,1]})
				nFAT := If(aTAREFA[nFt,6,4] > 0,aTAREFA[nFt,6,4],100)/100
				cCodTu := (cTRB)->TF_CALENDA
				cCodMTu:= cCodTu

				If aTAREFA[nFt,5,nIt,1] = "M"

					// SE FOR FLUTUANTE ???
					cCodTu := If(!Empty(aTAREFA[nFt,5,nIt,18]),aTAREFA[nFt,5,nIt,18],NGSEEK("ST1",aTAREFA[nFt,5,nIt,2],1,'T1_TURNO'))
				EndIf
				If nPosDep > 0
					If Alltrim(aDepend[nPosDep,5]) == "H"

						nHOPX  := NGCONVERHORA(aDepend[nPosDep,4],"S","D") * nFAT
						nQtAcr := NGCONVERHORA(nHOPX,"D","S")

						lTemCa := .t.

						If nFAT == 1 .and. !Empty(aDepend[nPosDep,6]) .and. Len(Alltrim(aDepend[nPosDep,7])) > 1 //Se Sobreposicao for ZERO
							vRetDH := {aDepend[nPosDep,6],aDepend[nPosDep,7]}
						Else
							vRetDH := fDtHoCalend(aDepend[nPosDep,2],aDepend[nPosDep,3],;
							nQtAcr,cCodTu,.F.,.T.)
							lTemCa := If(Alltrim(vRetDH[2]) = ":",.F.,MNT330CHICA(vRetDH[1],vRetDH[2],cCodTu,.F.))
						EndIf

						If !lTemCa
							If aTAREFA[nFt,5,nIt,1] == "M"
								vRetDH := fDtHoCalend(aDepend[nPosDep,2],aDepend[nPosDep,3],;
								nQtAcr,cCodMTu,.F.,.T.)
							EndIf
							If Alltrim(vRetDH[2]) = ":"
								vRetDH := NGDTHORFIM( aDepend[nPosDep,2] , aDepend[nPosDep,3] , nQtAcr )
							EndIf
						EndIf

						dDtaIn := vRetDH[1]
						cHorIn := vRetDH[2]

					Else
						If Alltrim(aDepend[nPosDep,5]) == "S"
							nQtAcr := Int((aDepend[nPosDep,4] * 7) * nFAT)
						ElseIf Alltrim(aDepend[nPosDep,5]) == "M"
							nQtAcr := Int((aDepend[nPosDep,4] * 30) * nFAT)
						Else
							nQtAcr := Int(aDepend[nPosDep,4] * nFAT)
						EndIf

						dDtaIn := aDepend[nPosDep,2]+nQtAcr
						cHorIn := aDepend[nPosDep,3]
						lTemCa := If(Empty(cHorIn),.F.,MNT330CHICA(dDtaIn,cHorIn,cCodTu,.F.))
						If !lTemCa
							// SE NAO TEM CALENDARIO GERAR PROBLEMA
							If aTAREFA[nFt,5,nIt,1] $ "E/M"
								MNTGRAVSTA(cORDEM,M->TI_PLANO,aTAREFA[nFt][1],;
								aTAREFA[nFt,5,nIt,1],aTAREFA[nFt,5,nIt,2],STR0020+" - "+Upper(STR0049))
							EndIf
						EndIf

					EndIf

					nPosDeA := Ascan(aDepend,{|x| x[1] == aTAREFA[nFt,1]})
					If nPosDeA > 0
						If DtoS(dDtaIn)+cHorIn > DtoS(aDepend[nPosDeA,2])+aDepend[nPosDeA,3]
							aDepend[nPosDeA,2] := dDtaIn
							aDepend[nPosDeA,3] := cHorIn
						EndIf
					EndIf

				EndIf

				aTAREFA[nFt,5,nIt,7] := dDtaIn
				aTAREFA[nFt,5,nIt,8] := cHorIn

			EndIf

			cCodTu := (cTRB)->TF_CALENDA
			If aTAREFA[nFt,5,nIt,1] $ "M/E"
				cCodMTu  := cCodTu
				lVerBloq := .t.
				If aTAREFA[nFt,5,nIt,1] == "M"
					// SE FOR FLUTUANTE ???
					cCodTu := If(!Empty(aTAREFA[nFt,5,nIt,18]),aTAREFA[nFt,5,nIt,18],;
					NGSEEK("ST1",aTAREFA[nFt,5,nIt,2],1,'T1_TURNO'))
				EndIf
				If Alltrim(aTAREFA[nFt,5,nIt,5]) == "H"
					vRetDH := fDtHoCalend(aTAREFA[nFt,5,nIt,7],aTAREFA[nFt,5,nIt,8],;
					aTAREFA[nFt,5,nIt,4],cCodTu,.T.,.T.)
					lAjusteCal := .F.
					lTemCa := If(Alltrim(vRetDH[2]) = ":",.F.,MNT330CHICA(aTAREFA[nFt,5,nIt,7],aTAREFA[nFt,5,nIt,8],cCodTu,.t.))

					//Se calendario esta OK, verifica se tem bloqueio quando a OS permite tolerancia
					If lTemCa .and. (lTarefTol .or. lTaDiaTol .or. lTaNaoTol)
						// SE FOR FLUTUANTE ???
						If !Empty(aTAREFA[nFt,5,nIt,18])
							If MNT330TCAF(aTAREFA[nFt,5,nIt,2],aTAREFA[nFt,5,nIt,7],aTAREFA[nFt,5,nIt,8],vRetDH[1],vRetDH[2],0,.t.)
								lTemCa := .F.
								lAjusteCal := .t.
							EndIf
						EndIf
						If lTemCa
							n330Bloq_ := A330BKFUN(aTAREFA[nFt,5,nIt,2],aTAREFA[nFt,5,nIt,7],aTAREFA[nFt,5,nIt,8],vRetDH[1],vRetDH[2],.t.,lTemC20)
							If n330Bloq_ > 0
								lTemCa := .F.
								lAjusteCal := .t.
							EndIf
						EndIf
					EndIf

					If !lTemCa
						If lTarefTol .or. lTaDiaTol .or. lTaNaoTol //Insumo Mao de Obra, Tarefa sem Dependencia e Data Tolerancia preenchida
							//fDataTol - Buscando data disponivel no periodo de tolerancia OU
							//busca outro funcionario da mesma especialidade (desde que seja a mesma data)
							aRetTol := fDataTol( aTAREFA[nFt,5,nIt,7] , If(lTarefTol,(cTRB)->DTLIMTOL,aTAREFA[nFt,5,nIt,7]) , aTAREFA[nFt,5,nIt,8] ,;
							aTAREFA[nFt,5,nIt,4] , cCodTu , aTAREFA[nFt,5,nIt,2], aTAREFA[nFt,5,nIt,18] , ;
							aTmpEsp , lTaNaoTol , lTemC20 )
							If Len(aRetTol) > 0
								aTAREFA[nFt,5,nIt,7] := aRetTol[1] //Data Inicio
								aTAREFA[nFt,5,nIt,8] := aRetTol[2] //Hora Inicio
								aTAREFA[nFt,5,nIt,2] := aRetTol[5] //Cod Funcionario
								cCodTu               := aRetTol[6] //Cod Turno
								vRetDH               := { aRetTol[3] , aRetTol[4] } //Data Fim / Hora Fim
								lAjusteCal := .t.
								lVerBloq   := .F.
								nPosDeZ    := Ascan(aDepend,{|x| x[1] == aTAREFA[nFt,1]})
								If nPosDeZ > 0
									If DtoS(aTAREFA[nFt,5,nIt,07])+aTAREFA[nFt,5,nIt,08] > DtoS(aDepend[nPosDeZ,2])+aDepend[nPosDeZ,3]
										aDepend[nPosDeZ,2] := aTAREFA[nFt,5,nIt,07]
										aDepend[nPosDeZ,3] := aTAREFA[nFt,5,nIt,08]
									EndIf
									If DtoS(vRetDH[1])+vRetDH[2] > DtoS(aDepend[nPosDeZ,6])+aDepend[nPosDeZ,7]
										aDepend[nPosDeZ,6] := vRetDH[1]
										aDepend[nPosDeZ,7] := vRetDH[2]
									EndIf
								EndIf
							EndIf
						EndIf

						If !lAjusteCal
							If aTAREFA[nFt,5,nIt,1] == "M"
								cDePr := If(aTAREFA[nFt,5,nIt,1]=="E",STR0061,STR0020+" - "+Upper(STR0049))
								// SE NAO TEM CALENDARIO GERAR PROBLEMA
								MNTGRAVSTA(cORDEM,M->TI_PLANO,aTAREFA[nFt][1],aTAREFA[nFt,5,nIt,1],aTAREFA[nFt,5,nIt,2],cDePr)
								If MNT330CHICA(aTAREFA[nFt,5,nIt,7],aTAREFA[nFt,5,nIt,8],cCodMTu,.t.)
									lPrExcCal := .F.
									vRetDH := fDtHoCalend(aTAREFA[nFt,5,nIt,7],aTAREFA[nFt,5,nIt,8],;
									aTAREFA[nFt,5,nIt,4],cCodMTu,.T.,.T.)
								Else
									vRetDH := NGDTHORFIM( aTAREFA[nFt,5,nIt,7] , aTAREFA[nFt,5,nIt,8] , aTAREFA[nFt,5,nIt,4] )
								EndIf
							EndIf
							If Alltrim(vRetDH[2]) = ":"
								vRetDH := NGDTHORFIM( aTAREFA[nFt,5,nIt,7] , aTAREFA[nFt,5,nIt,8] , aTAREFA[nFt,5,nIt,4] )
							EndIf
						EndIf
					EndIf

					dDtaFi := vRetDH[1]
					cHorFi := vRetDH[2]
				Else
					If Alltrim(aTAREFA[nFt,5,nIt,5]) == "S"
						dDtaFi := aTAREFA[nFt,5,nIt,7]+Int(aTAREFA[nFt,5,nIt,4] * 7)
					ElseIf Alltrim(aTAREFA[nFt,5,nIt,5]) == "M"
						dDtaFi := aTAREFA[nFt,5,nIt,7]+Int(aTAREFA[nFt,5,nIt,4] * 30)
					Else
						dDtaFi := aTAREFA[nFt,5,nIt,7]+Int(aTAREFA[nFt,5,nIt,4])
					EndIf
					cHorFi := aTAREFA[nFt,5,nIt,8]
				EndIf

				lTmpMsg := .t. //Indica se deve gerar msg de problema (STA)
				If lVerBloq .and. aTAREFA[nFt,5,nIt,1] == "M" //Se a tolerancia nao foi aplicada, verifica bloqueio de mao de obra
					If !Empty(aTAREFA[nFt,5,nIt,18]) // SE FOR FLUTUANTE ???
						If MNT330TCAF(aTAREFA[nFt,5,nIt,2],aTAREFA[nFt,5,nIt,7],aTAREFA[nFt,5,nIt,8],dDtaFi,cHorFi,0,.t.)
							lTmpMsg := .F.
							MNTGRAVSTA(cORDEM,M->TI_PLANO,aTAREFA[nFt][1],"M",aTAREFA[nFt,5,nIt,2],STR0020+" - "+Upper(STR0049)) //"FUNCIONARIO NAO DISPONIVEL"
						EndIf
					EndIf
					If lTmpMsg
						n330Bloq_ := A330BKFUN(aTAREFA[nFt,5,nIt,2],aTAREFA[nFt,5,nIt,7],aTAREFA[nFt,5,nIt,8],dDtaFi,cHorFi,.t.,lTemC20)
						If n330Bloq_ > 0
							cMsgTmp := STR0020+" - "+Upper(STR0051) //"FUNCIONARIO NAO DISPONIVEL" //"BLOQUEIO"
							If n330Bloq_ == 2
								cMsgTmp := STR0060 //"FUNCIONARIO PREVISTO EM O.S. DESTE PLANO"
							ElseIf n330Bloq_ == 3
								cMsgTmp := STR0020+" - "+STR0063 //"FUNCIONARIO NAO DISPONIVEL" //"CAD. FUNC."
							EndIf
							MNTGRAVSTA(cORDEM,M->TI_PLANO,aTAREFA[nFt][1],"M",aTAREFA[nFt,5,nIt,2],cMsgTmp)
						EndIf
					EndIf
				EndIf
				If lTemC20
					aTAREFA[nFt,5,nIt,20] := .T.
				EndIf
			Else
				If aTAREFA[nFt,5,nIt,1] == "P"
					nPosDeZ := Ascan(aDepend,{|x| x[1] == aTAREFA[nFt,1]})
					If nPosDeZ > 0
						aTAREFA[nFt,5,nIt,7] := aDepend[nPosDeZ,2]
						aTAREFA[nFt,5,nIt,8] := aDepend[nPosDeZ,3]
						dDtaFi := aTAREFA[nFt,5,nIt,7]
						cHorFi := aTAREFA[nFt,5,nIt,8]
					Else
						dDtaFi := aTAREFA[nFt,5,nIt,9]
						cHorFi := aTAREFA[nFt,5,nIt,10]
					EndIf
				ElseIf aTAREFA[nFt,5,nIt,1] $ "F/T"
					dDtaFi := aTAREFA[nFt,5,nIt,9]
					cHorFi := aTAREFA[nFt,5,nIt,10]
					nPosDeZ := Ascan(aDepend,{|x| x[1] == aTAREFA[nFt,1]})
					If nPosDeZ > 0
						aTAREFA[nFt,5,nIt,7] := aDepend[nPosDeZ,2]
						aTAREFA[nFt,5,nIt,8] := aDepend[nPosDeZ,3]

						vRetDH := fDtHoCalend(aTAREFA[nFt,5,nIt,7],aTAREFA[nFt,5,nIt,8],aTAREFA[nFt,5,nIt,4],cCodTu,.T.,.T.)
						If Alltrim(vRetDH[2]) = ":"
							vRetDH := NGDTHORFIM( aTAREFA[nFt,5,nIt,7] , aTAREFA[nFt,5,nIt,8] , aTAREFA[nFt,5,nIt,4] )
						EndIf
						dDtaFi := If(Alltrim(vRetDH[2]) = ":",aTAREFA[nFt,5,nIt,7],vRetDH[1])
						cHorFi := If(Alltrim(vRetDH[2]) = ":",aTAREFA[nFt,5,nIt,8],vRetDH[2])
					EndIf
				Else
					dDtaFi := aTAREFA[nFt,5,nIt,9]
					cHorFi := aTAREFA[nFt,5,nIt,10]
				EndIf
			EndIf

			aTAREFA[nFt,5,nIt,9]  := dDtaFi
			aTAREFA[nFt,5,nIt,10] := cHorFi

			//Verifica se calendário do Funcionario excedeu calendário da Manutenção
			If aTAREFA[nFt,5,nIt,1] == "M" .and. cCodMTu <> cCodTu .and. lPrExcCal
				If fDiffCalend( cCodMTu , cCodTu , aTAREFA[nFt,5,nIt,7] , aTAREFA[nFt,5,nIt,8] , ;
				aTAREFA[nFt,5,nIt,9] , aTAREFA[nFt,5,nIt,10] )
					MNTGRAVSTA(cORDEM,M->TI_PLANO,aTAREFA[nFt][1],"M",aTAREFA[nFt,5,nIt,2],STR0064) //"FUNCION. EXCEDEU CALEND. DA MANUTENCAO"
				EndIf
			EndIf

			//Atualiza variavel aDepend (data fim da Tarefa)
			nPosDeZ    := Ascan(aDepend,{|x| x[1] == aTAREFA[nFt,1]})
			If nPosDeZ > 0
				If DtoS(aTAREFA[nFt,5,nIt,9])+aTAREFA[nFt,5,nIt,10] > DtoS(aDepend[nPosDeZ,6])+aDepend[nPosDeZ,7]
					aDepend[nPosDeZ,6] := aTAREFA[nFt,5,nIt,9]
					aDepend[nPosDeZ,7] := aTAREFA[nFt,5,nIt,10]
				EndIf
			EndIf

			cHorFI  := If(aTAREFA[nFt,5,nIt,8] > cHorFI,aTAREFA[nFt,5,nIt,8],cHorFI)
			If aTAREFA[nFt,5,nIt,9] > dDataFF
				dDataFF := aTAREFA[nFt,5,nIt,9]
				cHorFF  := aTAREFA[nFt,5,nIt,10]
			ElseIf aTAREFA[nFt,5,nIt,9] = dDataFF
				cHorFF := If(aTAREFA[nFt,5,nIt,10] > cHorFF,aTAREFA[nFt,5,nIt,10],cHorFF)
			EndIf
			If aTAREFA[nFt,5,nIt,1] != "P"
				If Len(aDtHrSTJ) == 0
					aDtHrSTJ := {aTAREFA[nFt,5,nIt,7],aTAREFA[nFt,5,nIt,8],aTAREFA[nFt,5,nIt,9],aTAREFA[nFt,5,nIt,10],aTAREFA[nFt,5,nIt,9]}
				Else
					If DtoS(aTAREFA[nFt,5,nIt,7])+aTAREFA[nFt,5,nIt,8] < DtoS(aDtHrSTJ[1])+aDtHrSTJ[2]
						aDtHrSTJ[1] := aTAREFA[nFt,5,nIt,7]
						aDtHrSTJ[2] := aTAREFA[nFt,5,nIt,8]
					EndIf
					If DtoS(aTAREFA[nFt,5,nIt,9])+aTAREFA[nFt,5,nIt,10] > DtoS(aDtHrSTJ[3])+aDtHrSTJ[4]
						aDtHrSTJ[3] := aTAREFA[nFt,5,nIt,9]
						aDtHrSTJ[4] := aTAREFA[nFt,5,nIt,10]
						aDtHrSTJ[5] := aTAREFA[nFt,5,nIt,9]
					EndIf
				EndIf
			EndIf
			nIt ++
		End

		cHorFI  := If(Empty(cHorFi),cHorIM,cHorFi)
		cHorFF  := If(Empty(cHorFF),cHorIM,cHorFF)
		dDataFF := If(Empty(dDataFF),(cTRB)->DTREAL,dDataFF)
		aTAREFA[nFt][4] := If(Len(aDtHrSTJ) > 0,aClone(aDtHrSTJ),{(cTRB)->DTREAL,cHorFI,dDataFF,cHorFF,dDataFF})
	Next nFt
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNT330PUHC ³ Autor ³In cio Luiz Kolling    ³ Data ³30/04/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Busca a primeira ou a ultima hora disponivel do dia conforme ³±±
±±³          ³o calendario                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³vCodCa  - Codigo do calendario                  - Obrigatorio³±±
±±³          ³vDta    - Data                                  - Obrigatorio³±±
±±³          ³cTipoH  - Hora (P - Primeira,U - Ultima)        - Obrigatorio³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³cHorCa  - Hora do calendario                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA330                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MNT330PUHC(vCodCa,vDta,cTipoH)
	Local nPosCa := aSCAN(aCalenF,{|x| x[1] == vCodCa})
	Local cHorCa := Space(5)
	If nPosCa > 0
		If !Empty(aCalenF[nPosCa,2])
			If aCalenF[nPosCa,2,Dow(vDta),1] <> "00:00"
				cHorCa := If(cTipoH = "P",aCalenF[nPosCa,2,Dow(vDta),2,1,1],aCalenF[nPosCa,2,Dow(vDta),2,1,Len(aCalenF[nPosCa,2,Dow(vDta),2,1])])
			EndIf
		EndIf
	EndIf
Return cHorCa

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNT330CALN ³ Autor ³ Inacio Luiz Kolling   ³ Data ³11/05/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Alimenta os dados para calendario normal                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³vdINI - Data inicio                            - Obrigatorio ³±±
±±³          ³vhINI - Hora inicio                            - Obrigatorio ³±±
±±³          ³vdFIM - Data fim                               - Obrigatorio ³±±
±±³          ³vhFim - Hora fim                               - Obrigatorio ³±±
±±³          ³vI    - Incremento da matriz (aTAREFA)         - Obrigatorio ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MNT330CALN(vdINI,vhINP,vdFIM,vhFIM,vI)
	Local e := 0,nRecU := 0,cCodTmp, nRecUTot := 0
	Local lCampoTol := If( Type("(cTRB)->DTLIMTOL") == "D" , .T. , .F. )
	Local aAreaSTJ := {}
	Local cMaxHorSTJ := "00:00"
	Local nQtdOSDia := 0, nMaxOSDia := 0 // Quantidade de O.S. por Dia e Quantidade Máxima de O.S. em um Dia
	Local aDtHrIni := {}
	Local lGravaEsp := .F.
	Local lForTPG := NGCADICBASE("TG_FORNEC","A","STG",.F.)

	Private cHorLn := MNT330PUHC((cTRB)->TF_CALENDA,vdINI,"P") //Verifica primeira hora disponivel no dia
	Private dFimLn := vdFIM,cHofLn := vHFIM

	// Quando o Tipo de Incremento da Manutenção for em Horas, recebe a próxima hora disponível do dia
	If (cTRB)->TF_UNENMAN == "H"
		nQtdOSDia := 0
		nMaxOSDia := MNTA340MXD((cTRB)->TF_CODBEM, (cTRB)->TF_SERVICO, (cTRB)->TF_SEQRELA)

		dbSelectArea("STJ")
		aAreaSTJ := GetArea()
		dbSetOrder(2)
		dbSeek(xFilial("STJ",(cTRB)->TF_FILIAL) + "B" + (cTRB)->TF_CODBEM + (cTRB)->TF_SERVICO + (cTRB)->TF_SEQRELA, .T.)
		While !Eof() .And. STJ->TJ_FILIAL == xFilial("STJ",(cTRB)->TF_FILIAL) .And. STJ->TJ_TIPOOS == "B" .And. ;
		STJ->TJ_CODBEM == (cTRB)->TF_CODBEM .And. STJ->TJ_SERVICO == (cTRB)->TF_SERVICO .And. STJ->TJ_SEQRELA == (cTRB)->TF_SEQRELA

			// Apenas O.S. do mesmo Plano e na mesma Data Original (e também não terminadas)
			// Não verificamos aqui se estão liberadas porque não é necessário estar liberada. Pode estar pendente, mas os horários não devem ficar sobrepostos
			If STJ->TJ_PLANO == M->TI_PLANO .And. STJ->TJ_DTMPINI == vdINI .And. STJ->TJ_TERMINO <> "S"
				nQtdOSDia++

				// Recebe a Maior Hora
				If STJ->TJ_HOMPFIM > cMaxHorSTJ // Manutenção
					cMaxHorSTJ := STJ->TJ_HOMPFIM
				EndIf
				If STJ->TJ_HOPPFIM > cMaxHorSTJ // Parada do Bem
					cMaxHorSTJ := STJ->TJ_HOMPFIM
				EndIf
			EndIf

			dbSelectArea("STJ")
			dbSkip()
		End
		RestArea(aAreaSTJ)

		// Caso não tenha ultrapassado o máximo de O.S. no dia, atribui a hora maior
		If nQtdOSDia <= nMaxOSDia .And. cMaxHorSTJ > cHorLn
			cHorLn := cMaxHorSTJ
		EndIf
	EndIf

	If AllTrim(STG->TG_UNIDADE) == "H"
		aDtHrIni := NGDtHrCale(vdINI, cHorLn, (cTRB)->TF_CALENDA)
		vdINI  := aDtHrIni[1]
		cHorLn := aDtHrIni[2]
		vRetDH := fDtHoCalend(vdINI,cHorLn,MNT330HCON(STG->TG_QUANTID,STG->TG_TIPOREG),(cTRB)->TF_CALENDA,.T.,.T.)
		dFimLn   := vRetDH[1]
		cHofLn   := vRetDH[2]
	Else
		dFimLn := (cTRB)->DTREAL + STG->TG_QUANTID
		cHofLn := cHorLn
		If AllTrim(STG->TG_UNIDADE) == "S"
			dFimLn := (cTRB)->DTREAL + (STG->TG_QUANTID * 7)
			cHofLn := cHorLn
		ElseIf AllTrim(STG->TG_UNIDADE) == "M"
			dFimLn := (cTRB)->DTREAL + (STG->TG_QUANTID * 30)
			cHofLn := cHorLn
		EndIf
	EndIf

	If STG->TG_TIPOREG == "E" .And. (M->TI_TIPOMDO == "F" .Or. (M->TI_TIPOMDO == "E" .And. IsInCallStack("MNTA330")))
		dTmpFim := If( lCampoTol , If( (cTRB)->DTLIMTOL > vdINI , (cTRB)->DTLIMTOL , vdINI ) , vdINI )
		aFUNESP := BUSCAESP(STG->TG_CODIGO,STG->TG_QUANREC,vdINI,dFimLn,cHorLn,cHofLn,aTAREFA,dTmpFim)
		aArFuEs := {}

		For e := 1 To Len(aFUNESP)
			cCodTmp := fMntRetDis( SubStr(STG->TG_CODIGO,1,Len(SpEsp)) , STG->TG_QUANREC , nRecU+1 , aFUNESP[e] , aFUNESP )

			cCodCF := NGSEEK("ST1",cCodTmp,1,'T1_TURNO')
			nPosCF := aSCAN(aCalenF,{|x| x[1] == cCodCF})
			If Empty(nPosCF)
				aAdd(aCalenF,{cCodCF,NGCALENDAH(cCodCF)})
				nPosCF := Len(aCalenF)
			EndIf

			If M->TI_TIPOMDO == "F"
				aAdd(aArFuEs,{"M",cCodTmp,0,;
				If(AllTrim(STG->TG_UNIDADE) == "H",MNT330HCON(STG->TG_QUANTID,"M"),STG->TG_QUANTID),;
				STG->TG_UNIDADE,STG->TG_DESTINO,vdINI,cHorLn,;
				dFimLn,cHofLn,STG->TG_RESERVA,0,Space(02),;
				SubStr(STG->TG_CODIGO,1,Len(SpEsp)),;
				STG->TG_QUANREC,STG->TG_TAREFA,e,Space(3),aFUNESP,.F.})
				nRecU ++
			EndIf

			nRecUTot ++

			If nRecUTot = STG->TG_QUANREC
				Exit
			EndIf
		Next e

		If nRecUTot < STG->TG_QUANREC
			If nRecUTot == 0
				MNTGRAVSTA(cORDEM,M->TI_PLANO,STG->TG_TAREFA,"E",STG->TG_CODIGO,STR0022) //"NENHUM ESPECIALISTA DISPONIVEL"
			Else
				MNTGRAVSTA(cORDEM,M->TI_PLANO,STG->TG_TAREFA,"E",STG->TG_CODIGO,STR0061) //"QTD. DE ESPECIALISTA INSUFICIENTE"
				If lCampoTol
					(cTRB)->DTLIMTOL := StoD("")
				EndIf
				MNT330GMAT(vI,5,{STG->TG_TIPOREG,STG->TG_CODIGO,STG->TG_QUANREC-If(M->TI_TIPOMDO == "F",nRecU,0),;
				If(AllTrim(STG->TG_UNIDADE) == "H",MNT330HCON(STG->TG_QUANTID,"M"),STG->TG_QUANTID),STG->TG_UNIDADE,STG->TG_DESTINO,;
				vdINI,cHorLn,dFimLn,cHofLn,STG->TG_RESERVA,0,STG->TG_LOCAL,;
				SpEsp,STG->TG_QUANREC-nRecU,STG->TG_TAREFA,0,Space(3),{},.F.,"",""})
				lGravaEsp := .T.
			EndIf
		EndIf

		If Len(aArFuEs) > 0
			MNT330DIST(vI,aArFuES)
		ElseIf !lGravaEsp
			MNT330GMAT(vI,5,{STG->TG_TIPOREG,STG->TG_CODIGO,STG->TG_QUANREC-If(M->TI_TIPOMDO == "F",nRecU,0),;
			If(AllTrim(STG->TG_UNIDADE) == "H",MNT330HCON(STG->TG_QUANTID,"M"),STG->TG_QUANTID),STG->TG_UNIDADE,STG->TG_DESTINO,;
			vdINI,cHorLn,dFimLn,cHofLn,STG->TG_RESERVA,0,STG->TG_LOCAL,;
			SpEsp,STG->TG_QUANREC-nRecU,STG->TG_TAREFA,0,Space(3),{},.F.})
		EndIf

	ElseIf STG->TG_TIPOREG = "M"
		cCodCF := NGSEEK("ST1",SubStr(STG->TG_CODIGO,1,6),1,'T1_TURNO')
		nPosCF := aSCAN(aCalenF,{|x| x[1] == cCodCF})

		If Empty(nPosCF)
			aAdd(aCalenF,{cCodCF,NGCALENDAH(cCodCF)})
			nPosCF := Len(aCalenF)
		EndIf

		hINIX := MNT330PUHC(cCodCF,vdINI,"P") //Verifica primeira hora disponivel no dia
		hINIX := If(Empty(hINIX),cHorLn,hINIX)
		If !Empty(hINIX)
			MNT330GMAT(vI,5,{"M",STG->TG_CODIGO,0,;
			If(AllTrim(STG->TG_UNIDADE) == "H",MNT330HCON(STG->TG_QUANTID,"M"),STG->TG_QUANTID),;
			STG->TG_UNIDADE,STG->TG_DESTINO,vdINI,cHorLn,;
			dFimLn,cHofLn,STG->TG_RESERVA,0,STG->TG_LOCAL,;
			SubStr(STG->TG_CODIGO,1,Len(SpEsp)),;
			STG->TG_QUANREC,STG->TG_TAREFA,e,Space(3),{},.F.,"",""})
		Else
			MNTGRAVSTA(cORDEM,M->TI_PLANO,STG->TG_TAREFA,"M",;
			STG->TG_CODIGO,STR0020+" - "+Upper(STR0049))
		EndIf
	Else
		If lForTPG
			MNT330GMAT(vI,5,{STG->TG_TIPOREG,STG->TG_CODIGO,STG->TG_QUANREC,;
			If(AllTrim(STG->TG_UNIDADE) == "H",MNT330HCON(STG->TG_QUANTID,"M"),STG->TG_QUANTID),STG->TG_UNIDADE,STG->TG_DESTINO,;
			vdINI,cHorLn,dFimLn,cHofLn,STG->TG_RESERVA,0,STG->TG_LOCAL,;
			SpEsp,STG->TG_QUANREC,STG->TG_TAREFA,0,Space(3),{},.F.,STG->TG_FORNEC,STG->TG_LOJA})
		Else
			MNT330GMAT(vI,5,{STG->TG_TIPOREG,STG->TG_CODIGO,STG->TG_QUANREC,;
			If(AllTrim(STG->TG_UNIDADE) == "H",MNT330HCON(STG->TG_QUANTID,"M"),STG->TG_QUANTID),STG->TG_UNIDADE,STG->TG_DESTINO,;
			vdINI,cHorLn,dFimLn,cHofLn,STG->TG_RESERVA,0,STG->TG_LOCAL,;
			SpEsp,STG->TG_QUANREC,STG->TG_TAREFA,0,Space(3),{},.F.,"",""})
		EndIf
	EndIf
Return

//----------------------------------------------------------------------
/*/{Protheus.doc} MNT330CAFLU
Alimenta os dados para calendario flutuante

@author Inacio Luiz Kolling
@since 14/05/2009
@version P11/P12
/*/
//----------------------------------------------------------------------
Static Function MNT330CAFLU( vI )

	Local e, nRecU := 0
	Local dINIOri, hINIOri

	Local lCampoTol	:= (Type("(cTRB)->DTLIMTOL") == "D")
	Local lForTPG	:= NGCADICBASE("TG_FORNEC", "A", "STG", .F.)

	Store 0 To e,f,g
	dINI	:= dDtMi
	hINI	:= MNT330PUHC( (cTRB)->TF_CALENDA,dINI,"P" ) //Verifica primeira hora disponivel no dia

	// Quando o Tipo de Incremento da Manutenção for em Horas, recebe a próxima hora disponível do dia
	If (cTRB)->TF_UNENMAN == "H"

		If lFrtInput // Verifica se é outro bem ou a data do dia seguinte do insumo.
			nHorasSTJ	:= NTOH( SomaHoras( nHorasSTJ,STG->TG_QUANTID )) //Soma a quantidade de horas com o incremento da manutenção
			hINI		:= nHorasSTJ //Atribui a variável 'Hora Início' do insumo.
		EndIf

	EndIf

	dINIOri	:= dINI //Data Início
	hINIOri	:= hINI //Hora Início

	If AllTrim( STG->TG_UNIDADE ) == "H"
		vRetDH := fDtHoCalend(dINI,hINI,MNT330HCON(STG->TG_QUANTID,STG->TG_TIPOREG),(cTRB)->TF_CALENDA,.T.,.T.)
		dFIM   := vRetDH[1]
		hFIM   := vRetDH[2]
	Else
		dFIM := (cTRB)->DTREAL + STG->TG_QUANTID
		hFIM := hINI
		If AllTrim(STG->TG_UNIDADE) == "S"
			dFIM := (cTRB)->DTREAL + (STG->TG_QUANTID * 7)
			hFIM := hINI
		ElseIf AllTrim(STG->TG_UNIDADE) == "M"
			dFIM := (cTRB)->DTREAL + (STG->TG_QUANTID * 30)
			hFIM := hINI
		EndIf
	EndIf

	dFIMOri := dFIM
	hFIMOri := hFIM

	If STG->TG_TIPOREG == "E" .And. (M->TI_TIPOMDO == "F" .Or. (M->TI_TIPOMDO == "E" .And. IsInCallStack("MNTA330")))
		dTmpFim := If( lCampoTol , If( (cTRB)->DTLIMTOL > dINI , (cTRB)->DTLIMTOL , dINI ) , dINI )
		aFUNESP := BUSCAESP(STG->TG_CODIGO,STG->TG_QUANREC,dINI,dFIM,hIni,hFim,aTAREFA,dTmpFim)

		For e := 1 To Len(aFUNESP)
			cCaleEs := Space(3)
			dINI := dINIOri
			hINI := hINIOri
			dFIM := dFIMOri
			hFIM := hFIMOri
			MNT330TCAF(aFUNESP[e],dINI,hINI,dFIM,hFIM,vI,.F.)
			If M->TI_TIPOMDO == "F"
				MNT330GMAT(vI,5,{"M",aFUNESP[e],0,MNT330HCON(STG->TG_QUANTID,"M"),STG->TG_UNIDADE,STG->TG_DESTINO,;
				dINI,hINI,dFIM,hFIM,STG->TG_RESERVA,0.00,Space(02),SubStr(STG->TG_CODIGO,1,Len(SpEsp)),;
				STG->TG_QUANREC,STG->TG_TAREFA,e,cCaleEs,aFUNESP,.F.,"",""})
				nRecU ++
			EndIf
			If nRecU = STG->TG_QUANREC
				Exit
			EndIf
		Next e

		If nRecU < STG->TG_QUANREC
			If nRecU == 0
				MNTGRAVSTA(cORDEM,M->TI_PLANO,STG->TG_TAREFA,"E",STG->TG_CODIGO,STR0022) //"NENHUM ESPECIALISTA DISPONIVEL"
			Else
				If lCampoTol
					(cTRB)->DTLIMTOL := StoD("")
				EndIf
				MNTGRAVSTA(cORDEM,M->TI_PLANO,STG->TG_TAREFA,"E",STG->TG_CODIGO,STR0061) //"QTD. DE ESPECIALISTA INSUFICIENTE"
			EndIf

			MNT330GMAT(vI,5,{STG->TG_TIPOREG,STG->TG_CODIGO,STG->TG_QUANREC-If(M->TI_TIPOMDO == "F",nRecU,0),;
			MNT330HCON(STG->TG_QUANTID,STG->TG_TIPOREG),STG->TG_UNIDADE,STG->TG_DESTINO,;
			dINI,hINI,dFIM,hFIM,STG->TG_RESERVA,0,;
			STG->TG_LOCAL,SpEsp,STG->TG_QUANREC-nRecU,;
			STG->TG_TAREFA,0,Space(3),{},.F.,"",""})
		EndIf

	ElseIf STG->TG_TIPOREG == "M"
		cCaleEs := Space(3)

		MNT330TCAF(STG->TG_CODIGO,dINI,hINI,dFIM,hFIM,vI,.F.)

		MNT330GMAT(vI,5,{"M",STG->TG_CODIGO,0,MNT330HCON(STG->TG_QUANTID,"M"),STG->TG_UNIDADE,STG->TG_DESTINO,;
		dINI,hINI,dFIM,hFIM,STG->TG_RESERVA,0.00,STG->TG_LOCAL,SubStr(STG->TG_CODIGO,1,Len(SpEsp)),;
		STG->TG_QUANREC,STG->TG_TAREFA,e,cCaleEs,{},.F.,"",""})
	Else
		If lForTPG
			MNT330GMAT(vI,5,{STG->TG_TIPOREG,STG->TG_CODIGO,STG->TG_QUANREC,;
			MNT330HCON(STG->TG_QUANTID,STG->TG_TIPOREG),STG->TG_UNIDADE,STG->TG_DESTINO,;
			dINI,hINI,dFIM,hFIM,STG->TG_RESERVA,0,STG->TG_LOCAL,SpEsp,STG->TG_QUANREC,;
			STG->TG_TAREFA,0,Space(3),{},.F.,STG->TG_FORNEC,STG->TG_LOJA})
		Else
			MNT330GMAT(vI,5,{STG->TG_TIPOREG,STG->TG_CODIGO,STG->TG_QUANREC,;
			MNT330HCON(STG->TG_QUANTID,STG->TG_TIPOREG),STG->TG_UNIDADE,STG->TG_DESTINO,;
			dINI,hINI,dFIM,hFIM,STG->TG_RESERVA,0,STG->TG_LOCAL,SpEsp,STG->TG_QUANREC,;
			STG->TG_TAREFA,0,Space(3),{},.F.,"",""})
		EndIf
	EndIf

Return


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNT330TCAF ³ Autor ³ Inacio Luiz Kolling   ³ Data ³15/05/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Verifica se tem calendario flutuante para o funcionario      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cCodF - Codigo do funcionario                  - Obrigatorio ³±±
±±³          ³vdINI - Data inicio                            - Obrigatorio ³±±
±±³          ³vhINI - Hora inicio                            - Obrigatorio ³±±
±±³          ³vdFIM - Data fim                               - Obrigatorio ³±±
±±³          ³vhFim - Hora fim                               - Obrigatorio ³±±
±±³          ³vI    - Incremento da matriz (aTAREFA)         - Obrigatorio ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna   ³lProblema .t.-> Nao tem calendario,.F. -> tem calendario     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MNT330TCAF(cCodF,vDini,vHini,vDfim,vHfim,vI,lValid)
	Local lProblema := .T.
	Local vRetDH

	If NGIFDBSEEK("ST1",cCodF,1,.F.)
		If NGIFDBSEEK("TP4",ST1->T1_EQUIPE,1)
			If NGIFDBSEEK("TP6",TP4->TP4_CODIGO,1)
				While !Eof() .And. TP6->TP6_FILIAL = Xfilial("TP6") .And.;
				TP6->TP6_EQUIPE == TP4->TP4_CODIGO

					If vDini >= TP6->TP6_DTINI .And. vDini <= TP6->TP6_DTFIM .And.;
					vDfim >= TP6->TP6_DTINI .And. vDfim <= TP6->TP6_DTFIM

						nPosCF := aSCAN(aCalenF,{|x| x[1] == TP6->TP6_CALEND})
						If Empty(nPosCF)
							aAdd(aCalenF,{TP6->TP6_CALEND,NGCALENDAH(TP6->TP6_CALEND)})
							nPosCF := Len(aCalenF)
						EndIf
						cCaleEs := TP6->TP6_CALEND
						If lValid
							If aCalenF[nPosCF,2,Dow(vDini),1] <> "00:00"
								hINIX := MNT330PUHC(TP6->TP6_CALEND,vDini,"P") //Verifica primeira hora disponivel no dia
								If !Empty(hINIX)
									vRetDH := fDtHoCalend(vDini,hINIX,MNT330HCON(STG->TG_QUANTID,STG->TG_TIPOREG),cCaleEs,.T.,.T.)
									If Alltrim(vRetDH[2]) <> ":"
										lProblema := .F.
										dFIM := vRetDH[1]
										hFIM := vRetDH[2]
										Exit
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf
					NGDBSELSKIP("TP6")
				End
			EndIf
		EndIf
	EndIf
Return lProblema

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNT330CHICA³ Autor ³In cio Luiz Kolling   ³ Data ³25/06/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Verifica se a hora esta em um intervalo no calendario       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³dVDATA - Data                                   OBRIGATORIO ³±±
±±³          ³cVHORA - Hora                                   OBRIGATORIO ³±±
±±³          ³cCalen - Codigo do calendario                   OBRIGATORIO ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA330                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
/*/
Function MNT330CHICA(dVDATA,cVhora,cCalen,lHoraFim)
	Local IRetC := .F., nPosCH := aSCAN(aCalenF,{|x| x[1] == cCalen}),nlo := 0
	Local nDiaC := Dow(dVDATA)
	Default lHoraFim := .F.

	If nPosCH > 0
		If Len(aCalenf[nPosCH,2]) > 0 .and. aCalenf[nPosCH,2,nDiac,1] <> "00:00"
			For nlo := 1 To Len(aCalenF[nPosCH,2,nDiaC,2])
				If lHoraFim
					If cVHORA >= aCalenF[nPosCH,2,nDiac,2,nlo,1] .And. cVHORA <= aCalenf[nPosCH,2,nDiaC,2,nlo,2]
						IRetC := .t.
						Exit
					EndIf
				Else
					If cVHORA >= aCalenF[nPosCH,2,nDiac,2,nlo,1] .And. cVHORA < aCalenf[nPosCH,2,nDiaC,2,nlo,2]
						IRetC := .t.
						Exit
					EndIf
				EndIf
			Next nlo
		EndIf
	EndIf
Return IRetC

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNT330HCON ³ Autor ³In cio Luiz Kolling   ³ Data ³25/06/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Converte a hora                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³nQUANTID - Quantidade                           OBRIGATORIO ³±±
±±³          ³cTIPOREG - Tipo do insumo                       OBRIGATORIO ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA330                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
/*/
Function MNT330HCON(nQUANTID,cTIPOREG)
	Local nQtR := nQUANTID
	If cTIPOREG <> "P"
		If GetMv("MV_NGUNIDT") = "D"
			nQtR := NGCONVERHORA(nQUANTID,"D","S")
		EndIf
	EndIf
Return nQtR

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³a330BKFUN ³ Autor ³Inacio Luiz Kolling    ³ Data ³29/05/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Verifica se tem bloqueio do funcionario                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function A330BKFUN(cCod,dDin,cHoIn,dDfi,cHoFi,lBloqTmp,lTemC20)
	Local lTemB := .F., nTemB := 0, cFUNC, cHoiA, cHoCe
	Local nLinX, nColX, lFirst
	Default lBloqTmp := .F. //Indica se verifica bloqueio temporario (Uso MNTA330)

	cFUNC := Left(cCod,Len(STK->TK_CODFUNC))
	cHoiA := cHoIn
	cHoCe := NGSOMAHCAR("00:01",cHoiA)

	//Checa disponibilidade do funcionario
	If !NGFUNCRH(cFUNC,.F.,dDfi)
		nTemB := 3
	EndIf
	If !NGFRHAFAST(cFUNC,dDin,dDfi,.F., .F.)
		nTemB := 3
	EndIf

	If nTemB == 0 .and. lBloqTmp .and. TYPE("a330TmpF") == "A" .and. ValTYPE(lTemC20) == "L" //Uso no MNTA330
		lTemB := fMnt33CKDA(cFUNC,dDin,cHoCe,dDfi,cHoFi,.F.)
		If lTemB
			nTemB := 2 //Indica que o insumo está bloqueado em outra OS deste Plano
		Else
			//Verifica insumos da OS atual ainda não gravados no STL
			lFirst := .F.
			For nLinX := 1 To Len(aTAREFA)
				For nColX := 1 To Len(aTAREFA[nLinX][5])
					If aTAREFA[nLinX,5,nColX,1] == "M" .and. PadR(aTAREFA[nLinX][5][nColX][2],Len(cFUNC)) == cFUNC
						If lTemC20
							If !aTAREFA[nLinX][5][nColX][20]
								Loop
							EndIf
						EndIf
						If DtoS(dDin)+cHoCe < DtoS(aTAREFA[nLinX][5][nColX][9])+aTAREFA[nLinX][5][nColX][10] .and.;
						DtoS(dDfi)+cHoFi > DtoS(aTAREFA[nLinX][5][nColX][7])+aTAREFA[nLinX][5][nColX][8]

							l330Bloq_ := .t. //Indica que o insumo está bloqueado em outra OS deste Plano
							nTemB     := 2
							Exit
						EndIf
					EndIf
				Next nColX
				If nTemB > 0 .or. lFirst
					Exit
				EndIf
			Next nLinX
		EndIf
	EndIf
	If nTemB == 0
		vVret := MNT160CKDA(cFUNC,dDin,cHoCe,dDfi,cHoFi,,.F.)
		lTemB := If(!vVret[1],.T.,.F.)
		If lTemB
			nTemB := 1
		EndIf
	EndIf
Return nTemB

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNT33OTRHO³ Autor ³Inacio Luiz Kolling    ³ Data ³29/05/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Verifica o parametro e/ou troca a hora da manutencao inicio ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT33OTRHO(cVCadl,vDInMa,vHoMa,vHoFu)
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNT330VCAL³ Autor ³Inacio Luiz Kolling    ³ Data ³16/07/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Verifica a existencia dos calendarios do bem,da manutencao  ³±±
±±³          | e do funcionário											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.t. -> Nao tem problemas , .F. -> Tem problema              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Refeita formas de filtro e pesquisa em 08/01/12 - Jackson M.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Variaveis ³ Gerais -------------------------------                     ³±±
±±³          ³ vCALEPROB - Array com os calendários inexistentes          ³±±
±±³          ³ nF        - Controle de For (Array de calendários)         ³±±
±±³          ³ nQtdF     - Controle de salto da mensagem                  ³±±
±±³          ³ cRelCa    - Variável com calendários inexistentes          ³±±
±±³          ³ lEst      - Indica se considera estrutura                  ³±±
±±³          ³ aEst      - Indica os compontentes da estrutura            ³±±
±±³          ³ cCusIni   - Centro de Custo inicial                        ³±±
±±³          ³ cCusFim   - Centro de Custo final                          ³±±
±±³          ³ cCTrIni   - Centro de Trabalho inicial                     ³±±
±±³          ³ cCTrFim   - Centro de Trabalho final                       ³±±
±±³          ³ cFamIni   - Familia inicial                                ³±±
±±³          ³ cFamFim   - Familia final                                  ³±±
±±³          ³ cModIni   - Modelo inicial                                 ³±±
±±³          ³ cModFim   - Modelo final                                   ³±±
±±³          ³ cTipAcom  - Tipo de Acompanhamento do Plano                ³±±
±±³          ³ cBemIni   - Bem inicial                                    ³±±
±±³          ³ cBemFim   - Bem final                                      ³±±
±±³          ³ cSerIni   - Servico incial                                 ³±±
±±³          ³ cSerFim   - Servico final                                  ³±±
±±³          ³ cAreIni   - Area inicial                                   ³±±
±±³          ³ cAreFim   - Area final                                     ³±±
±±³          ³ cTipIni   - Tipo inicial                                   ³±±
±±³          ³ cTipFim   - Tipo final                                     ³±±
±±³          ³                                                            ³±±
±±³          ³ TOP ----------------------------------                     ³±±
±±³          ³ nX        - Controle de For                                ³±±
±±³          ³ cCodigos  - Recebe os códigos de componentes da estrutura  ³±±
±±³          ³ cQuery    - Query a ser executada                          ³±±
±±³          ³ cNewAlias - Variavel que recebe novo alias                 ³±±
±±³          ³                                                            ³±±
±±³          ³ CodeBase -----------------------------                     ³±±
±±³          ³ nRECST9   - Salva o RECNO posicionado (ST9)                ³±±
±±³          ³ cFilST9   - Filtro da ST9                                  ³±±
±±³          ³ cFilSTF   - Filtro da STF                                  ³±±
±±³          ³                                                            ³±±
±±³          ³ Externas (Privadas no MNTA330) -------                     ³±±
±±³          ³ cWhile - Variável de controle de While na ST9              ³±±
±±³          ³ nIcEst - Indica qual posição deve verificar no array de est³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ F.O  ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Jackson M.  ³08/01/12³016403³- Realizado alteracao para melhoria de    ³±±
±±³            ³        ³      ³performance. (Verificacao via TOP)        ³±±
±±³            ³        ³      ³- Adicionado verificacao do calendario do ³±±
±±³            ³        ³      ³Funcionario                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT330VCAL()
	Local nF        := 0, nQtdF := 0
	Local cRelCa    := ""
	Local vCALEPROB := {}
	Local lEst      := lPlaEstu
	Local aEst      := If(lPlaEstu,vRetEst,{})
	Local cCusIni   := M->TI_CCUSINI
	Local cCusFim   := M->TI_CCUSFIM
	Local cCTrIni   := M->TI_CTRAINI
	Local cCTrFim   := M->TI_CTRAFIM
	Local cFamIni   := M->TI_FAMIINI
	Local cFamFim   := M->TI_FAMIFIM
	Local cModIni   := If(lModBe,M->TI_TIPMODI,NIL)
	Local cModFim   := If(lModBe,M->TI_TIPMODF,NIL)
	Local cTipAcom  := M->TI_TIPACOM
	Local cBemIni   := M->TI_BEMINI
	Local cBemFim   := M->TI_BEMFIM
	Local cSerIni   := M->TI_SERVINI
	Local cSerFim   := M->TI_SERVFIM
	Local cAreIni   := M->TI_AREAINI
	Local cAreFim   := M->TI_AREAFIM
	Local cTipIni   := M->TI_TIPOINI
	Local cTipFim   := M->TI_TIPOFIM
	Local nContBens := 0, nContBIni := 1, nContBFim := 150, nTamArray := 150
	Local lPriReg := .T.
	Local aPaisEst  := {}, aBensEst := {}
	Local nX,nY
	Local cCodigos := "", cQuery := ""
	Local cNewAlias := GetNextAlias()

	//Criada query que realiza uma verificação de 4 selects utilizando cláusula UNION

	//Tratamento ST9 - Primeira query contendo verificacao apenas de calendário do bem juntamente com os filtros de acordo com o plano
	//Caso considere a estrutura, irá verificar se o código do bem está na estrutura, caso nao, irá considerar o filtro do plano
	//Criada query que realiza uma verificação de 4 selects utilizando cláusula UNION

	//Tratamento ST9 - Primeira query contendo verificacao apenas de calendário do bem juntamente com os filtros de acordo com o plano
	//Caso considere a estrutura, irá verificar se o código do bem está na estrutura, caso nao, irá considerar o filtro do plano

	//Realiza a quebra de Bens para evitar 'estouro' de query
	If Len(aEst) > 150

		For nContBens := 1 to Len(aEst)

			If !lPriReg
				If ( Len(aEst) - nContBFim ) > 150
					nContBFim += 150
				Else
					nContBFim += (Len(aEst) - nContBFim) +1
				EndIf
				nTamArray := nContBFim - nContBIni
				aBensEst := Array(nTamArray)

			Else
				aBensEst := Array(nTamArray)
			EndIf

			//Copia a tabela com quebra para evitar o 'estouro'
			aCopy( aEst, aBensEst ,nContBIni ,nContBFim,)
			aAdd(aPaisEst,aBensEst)

			//Contador inicial e final nas query divididas
			If lPriReg
				nContBIni := nContBFim + 1
			Else
				nContBIni := nContBFim
			EndIf

			If lPriReg
				lPriReg := .F.
			EndIf

			nContBens := (nContBIni )

		Next nContBens
	Else
		aAdd(aPaisEst,aEst)
	EndIf

	//Contador para leitura de todos os registros
	For nY := 1 to len(aPaisEst)

		cCodigos := ''
		If lEst
			For nX := 1 To Len(aPaisEst[nY])
				If nX == 1
					cCodigos += "'"+aPaisEst[nY][nX]+"'"
				Else
					cCodigos += ",'"+aPaisEst[nY][nX]+"'"
				EndIf
			Next nX
		EndIf

		cQuery := " SELECT ST9.T9_CALENDA AS CALENDARIO FROM "+RetSqlName("ST9")+" ST9 "
		cQuery += " WHERE ST9.T9_CODFAMI >= "+ValToSql(cFamIni)+" AND ST9.T9_CODFAMI <= "+ValToSql(cFamFim)
		cQuery += " AND ST9.T9_FILIAL = "+ValToSql(xFilial("ST9"))
		cQuery += " AND ST9.T9_CCUSTO >= "+ValToSql(cCusIni)+" AND ST9.T9_CCUSTO <= "+ValToSql(cCusFim)
		cQuery += " AND ST9.T9_CENTRAB >= "+ValToSql(cCTrIni)+" AND ST9.T9_CENTRAB <= "+ValToSql(cCTrFim)
		If !lEst
			cQuery += " AND ST9.T9_CODBEM >= "+ValToSql(cBemIni)+" AND ST9.T9_CODBEM <= "+ValToSql(cBemFim)
		Else
			If !Empty(cCodigos)
				cQuery += " AND ST9.T9_CODBEM IN("+cCodigos+") "
			EndIf
		EndIf
		cQuery += " AND ST9.T9_SITBEM = 'A' AND ST9.T9_SITMAN <> 'I' "
		If cModIni <>  NIL .and. cModFim <> NIL
			cQuery += " AND ST9.T9_TIPMOD >= "+ValToSql(cModIni)+" AND ST9.T9_TIPMOD <= "+ValToSql(cModFim)
		EndIf
		cQuery += " AND (SELECT COUNT(*) FROM "+RetSqlName("STF")+" STF WHERE STF.TF_CODBEM = ST9.T9_CODBEM AND STF.D_E_L_E_T_ <> '*' ) > 0 "
		cQuery += " AND ST9.D_E_L_E_T_ <> '*' GROUP BY ST9.T9_CALENDA "

		cQuery += " UNION "

		//Tratamento STF - Segunda query contendo a verificacao dos calendários das manutenções dos bens que estão dentro do filtro do plano
		cQuery += " SELECT STF.TF_CALENDA AS CALENDARIO FROM "+RetSqlName("STF")+" STF "
		cQuery += " JOIN "+RetSqlName("ST9")+" ST9 ON STF.TF_CODBEM = ST9.T9_CODBEM "
		cQuery += " AND ST9.T9_CCUSTO >= "+ValToSql(cCusIni)+" AND ST9.T9_CCUSTO <= "+ValToSql(cCusFim)
		cQuery += " AND ST9.T9_CENTRAB >= "+ValToSql(cCTrIni)+" AND ST9.T9_CENTRAB <= "+ValToSql(cCTrFim)
		cQuery += " AND ST9.T9_SITBEM = 'A' AND ST9.T9_SITMAN <> 'I' "
		If cModIni <>  NIL .and. cModFim <> NIL
			cQuery += " AND ST9.T9_TIPMOD >= "+ValToSql(cModIni)+" AND ST9.T9_TIPMOD <= "+ValToSql(cModFim)
		EndIf
		If !lEst
			cQuery += " AND ST9.T9_CODBEM >= "+ValToSql(cBemIni)+" AND ST9.T9_CODBEM <= "+ValToSql(cBemFim)
		Else
			If !Empty(cCodigos)
				cQuery += " AND ST9.T9_CODBEM IN("+cCodigos+") "
			EndIf
		EndIf
		cQuery += " AND ST9.T9_FILIAL = "+ValToSql(xFilial("ST9"))+"  AND ST9.D_E_L_E_T_ <> '*' "
		cQuery += " WHERE STF.TF_FILIAL = "+ValToSql(xFilial("STF"))+" AND STF.D_E_L_E_T_ <> '*' "
		If cTipAcom = "1"     //1=Tempo, T=Tempo
			cQuery += " AND TF_TIPACOM = 'T'"
		ElseIF cTipAcom = "2" //2=Contador, C=Contador
			cQuery += " AND TF_TIPACOM = 'C'"
		ElseIF cTipAcom = "3" //3=Tempo/Contador, A=Tempo/Contador
			cQuery += " AND TF_TIPACOM = 'A'"
		ElseIF cTipAcom = "4" //4=Producao, P=Producao
			cQuery += " AND TF_TIPACOM = 'P'"
		ElseIF cTipAcom = "5" //5=Contador Fixo, F=Contador Fixo
			cQuery += " AND TF_TIPACOM = 'F'"
		ElseIF cTipAcom = "6" //6=Segundo Conta, S=Segundo Conta
			cQuery += " AND TF_TIPACOM = 'S'"
		EndIf
		cQuery += " AND STF.TF_SERVICO >= "+ValToSql(cSerIni)+" AND STF.TF_SERVICO <= "+ValToSql(cSerFim)
		cQuery += " AND STF.TF_CODAREA >= "+ValToSql(cAreIni)+" AND STF.TF_CODAREA <= "+ValToSql(cAreFim)
		cQuery += " AND STF.TF_TIPO    >= "+ValToSql(cTipIni)+" AND STF.TF_TIPO    <= "+ValToSql(cTipFim)
		cQuery += " AND STF.TF_ATIVO <> 'N' AND STF.TF_PLANEJA <> 'N' AND STF.TF_PERIODO <> 'E' "
		cQuery += " GROUP BY STF.TF_CALENDA "

		cQuery += " UNION "

		//Tratamento ST1 - Terceira query contendo a verificacao dos calendários dos funcionários, relacionados aos insumos das manutenções
		cQuery += " SELECT ST1.T1_TURNO AS CALENDARIO FROM "+RetSqlName("ST1")+" ST1
		cQuery += " WHERE ST1.D_E_L_E_T_ <> '*' AND ST1.T1_FILIAL = "+ValToSql(xFilial("ST1"))
		cQuery += " AND ST1.T1_CODFUNC IN( SELECT STG.TG_CODIGO FROM "+RetSqlName("STG")+" STG "
		cQuery += " JOIN "+RetSqlName("STF")+" STF ON STF.TF_FILIAL = STG.TG_FILIAL "
		cQuery += " AND STF.TF_CODBEM = STG.TG_CODBEM "
		cQuery += " AND STF.TF_SERVICO = STG.TG_SERVICO "
		cQuery += " AND STF.TF_SEQRELA = STG.TG_SEQRELA "
		cQuery += " AND STF.TF_FILIAL = "+ValToSql(xFilial("STF"))+" AND STF.D_E_L_E_T_ <> '*' "
		If cTipAcom = "1"     //1=Tempo, T=Tempo
			cQuery += " AND TF_TIPACOM = 'T'"
		ElseIF cTipAcom = "2" //2=Contador, C=Contador
			cQuery += " AND TF_TIPACOM = 'C'"
		ElseIF cTipAcom = "3" //3=Tempo/Contador, A=Tempo/Contador
			cQuery += " AND TF_TIPACOM = 'A'"
		ElseIF cTipAcom = "4" //4=Producao, P=Producao
			cQuery += " AND TF_TIPACOM = 'P'"
		ElseIF cTipAcom = "5" //5=Contador Fixo, F=Contador Fixo
			cQuery += " AND TF_TIPACOM = 'F'"
		ElseIF cTipAcom = "6" //6=Segundo Conta, S=Segundo Conta
			cQuery += " AND TF_TIPACOM = 'S'"
		EndIf
		cQuery += " AND STF.TF_SERVICO >= "+ValToSql(cSerIni)+" AND STF.TF_SERVICO <= "+ValToSql(cSerFim)
		cQuery += " AND STF.TF_CODAREA >= "+ValToSql(cAreIni)+" AND STF.TF_CODAREA <= "+ValToSql(cAreFim)
		cQuery += " AND STF.TF_TIPO    >= "+ValToSql(cTipIni)+" AND STF.TF_TIPO    <= "+ValToSql(cTipFim)
		cQuery += " AND STF.TF_ATIVO <> 'N' AND STF.TF_PLANEJA <> 'N' AND STF.TF_PERIODO <> 'E' "
		cQuery += " JOIN "+RetSqlName("ST9")+" ST9 ON STF.TF_CODBEM = ST9.T9_CODBEM "
		cQuery += " AND ST9.T9_CCUSTO >= "+ValToSql(cCusIni)+" AND ST9.T9_CCUSTO <= "+ValToSql(cCusFim)
		cQuery += " AND ST9.T9_CENTRAB >= "+ValToSql(cCTrIni)+" AND ST9.T9_CENTRAB <= "+ValToSql(cCTrFim)
		cQuery += " AND ST9.T9_SITBEM = 'A' AND ST9.T9_SITMAN <> 'I' "
		If cModIni <>  NIL .and. cModFim <> NIL
			cQuery += " AND ST9.T9_TIPMOD >= "+ValToSql(cModIni)+" AND ST9.T9_TIPMOD <= "+ValToSql(cModFim)
		EndIf
		If !lEst
			cQuery += " AND ST9.T9_CODBEM >= "+ValToSql(cBemIni)+" AND ST9.T9_CODBEM <= "+ValToSql(cBemFim)
		Else
			If !Empty(cCodigos)
				cQuery += " AND ST9.T9_CODBEM IN("+cCodigos+") "
			EndIf
		EndIf
		cQuery += " AND ST9.T9_FILIAL = "+ValToSql(xFilial("ST9"))+"  AND ST9.D_E_L_E_T_ <> '*' "
		cQuery += " WHERE STG.TG_TIPOREG = 'M' AND STG.D_E_L_E_T_ <> '*' "
		cQuery += " GROUP BY STG.TG_CODIGO ) "
		cQuery += " GROUP BY ST1.T1_TURNO "

		cQuery += " UNION "

		//Tratamento ST2 - Quarta query contendo a verificacao dos calendários que estão relacionados as funcionários. Esta verificação é feita
		//a partir das especilidades vinculadas como insumos nas manutenções
		cQuery += " SELECT ST1.T1_TURNO AS CALENDARIO FROM "+RetSqlName("ST1")+" ST1 "
		cQuery += " JOIN "+RetSqlName("ST2")+" ST2 ON ST2.T2_CODFUNC = ST1.T1_CODFUNC "
		cQuery += " AND ST2.T2_ESPECIA IN( SELECT STG.TG_CODIGO FROM "+RetSqlName("STG")+" STG "
		cQuery += " JOIN "+RetSqlName("STF")+" STF ON STF.TF_FILIAL = STG.TG_FILIAL "
		cQuery += " AND STF.TF_CODBEM = STG.TG_CODBEM "
		cQuery += " AND STF.TF_SERVICO = STG.TG_SERVICO "
		cQuery += " AND STF.TF_SEQRELA = STG.TG_SEQRELA"
		cQuery += " AND STF.TF_FILIAL = "+ValToSql(xFilial("STF"))+" AND STF.D_E_L_E_T_ <> '*' "
		If cTipAcom = "1"     //1=Tempo, T=Tempo
			cQuery += " AND TF_TIPACOM = 'T'"
		ElseIF cTipAcom = "2" //2=Contador, C=Contador
			cQuery += " AND TF_TIPACOM = 'C'"
		ElseIF cTipAcom = "3" //3=Tempo/Contador, A=Tempo/Contador
			cQuery += " AND TF_TIPACOM = 'A'"
		ElseIF cTipAcom = "4" //4=Producao, P=Producao
			cQuery += " AND TF_TIPACOM = 'P'"
		ElseIF cTipAcom = "5" //5=Contador Fixo, F=Contador Fixo
			cQuery += " AND TF_TIPACOM = 'F'"
		ElseIF cTipAcom = "6" //6=Segundo Conta, S=Segundo Conta
			cQuery += " AND TF_TIPACOM = 'S'"
		EndIf
		cQuery += " AND STF.TF_SERVICO >= "+ValToSql(cSerIni)+" AND STF.TF_SERVICO <= "+ValToSql(cSerFim)
		cQuery += " AND STF.TF_CODAREA >= "+ValToSql(cAreIni)+" AND STF.TF_CODAREA <= "+ValToSql(cAreFim)
		cQuery += " AND STF.TF_TIPO    >= "+ValToSql(cTipIni)+" AND STF.TF_TIPO    <= "+ValToSql(cTipFim)
		cQuery += " AND STF.TF_ATIVO <> 'N' AND STF.TF_PLANEJA <> 'N' AND STF.TF_PERIODO <> 'E' "
		cQuery += " JOIN "+RetSqlName("ST9")+" ST9 ON STF.TF_CODBEM = ST9.T9_CODBEM "
		cQuery += " AND ST9.T9_CCUSTO >= "+ValToSql(cCusIni)+" AND ST9.T9_CCUSTO <= "+ValToSql(cCusFim)
		cQuery += " AND ST9.T9_CENTRAB >= "+ValToSql(cCTrIni)+" AND ST9.T9_CENTRAB <= "+ValToSql(cCTrFim)
		cQuery += " AND ST9.T9_SITBEM = 'A' AND ST9.T9_SITMAN <> 'I' "
		If cModIni <>  NIL .and. cModFim <> NIL
			cQuery += " AND ST9.T9_TIPMOD >= "+ValToSql(cModIni)+" AND ST9.T9_TIPMOD <= "+ValToSql(cModFim)
		EndIf
		If !lEst
			cQuery += " AND ST9.T9_CODBEM >= "+ValToSql(cBemIni)+" AND ST9.T9_CODBEM <= "+ValToSql(cBemFim)
		Else
			If !Empty(cCodigos)
				cQuery += " AND ST9.T9_CODBEM IN("+cCodigos+") "
			EndIf
		EndIf
		cQuery += " AND ST9.T9_FILIAL = "+ValToSql(xFilial("ST9"))+"  AND ST9.D_E_L_E_T_ <> '*' "
		cQuery += " WHERE STG.TG_TIPOREG = 'E' AND STG.D_E_L_E_T_ <> '*' "
		cQuery += " GROUP BY STG.TG_CODIGO ) WHERE ST1.D_E_L_E_T_ <> '*' AND ST1.T1_FILIAL = "+ValToSql(xFilial("ST1"))
		cQuery += " GROUP BY ST1.T1_TURNO "

		cQuery := ChangeQuery(cQuery)
		dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),(cNewAlias), .T., .T.)
		While (cNewAlias)->(!Eof())
			If !Empty((cNewAlias)->CALENDARIO)
				If !NGIFDBSEEK("SH7",(cNewAlias)->CALENDARIO,1) .AND. aScan(vCALEPROB,{|x| x == (cNewAlias)->CALENDARIO}) == 0
					aAdd(vCALEPROB,(cNewAlias)->CALENDARIO)
				EndIf
			EndIf
			(cNewAlias)->(dbSkip())
		EndDo
		(cNewAlias)->(DbCloseArea())
	Next nY

	If Len(vCALEPROB) > 0
		NGDELETAREG("STI")
		NGDBAREAORDE("ST9",1)
		vCALEPROB := aSORT(vCALEPROB,,,{|x,y| x < y})
		For nF := 1 To Len(vCALEPROB)
			nQtdF ++
			cRelCa += vCALEPROB[nF]
			If nQtdF = 8//Considera 8 códigos de calendário por linha, caso ultrapasse, quebra a linha para exibicao do help
				nQtdF := 0
				cRelCa += CRLF
			Else
				If nF < Len(vCALEPROB)
					cRelCa += ",  "
				EndIf
			EndIf
		Next nF
		ShowHelpDlg(STR0054,{STR0055+CHR(13)+STR0056+cRelCa},3,; //"Atenção"##"Calendário da manutenção e/ou do bem e/ou do funcionário não existe no cadastro de calendários."##"Calendário(s): "
		{STR0057},3) //"Ajustar o cadastro do bem/ manutenção /funcionário com calendário valido ou cadastrar o calendário que está inválido."
		MsgStop(STR0058,STR0054) //"O processo será cancelado!"
		MNTA330TRBA()
		Return .F.
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³MNT330CDHP³ Autor ³Inacio Luiz Kolling    ³ Data ³11/08/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Calcula a data e a hora Parada do Bem.                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³dData   - Data da Manutencao.                   OBRIGATORIO ³±±
±±³          ³cHora   - Hora da Manutencao.                   OBRIGATORIO ³±±
±±³          ³cTipo   - Tipo parada A -> Antes, D -> Depois.  OBRIGATORIO ³±±
±±³          ³nTmpPar - Tempo de Parada do Bem.               OBRIGATORIO ³±±
±±³          ³          Valor correspondente ao Tipo de Parada (A ; D)    ³±±
±±³          ³cUniTmp - Unidade do Tempo da Parada do Bem.    OBRIGATORIO ³±±
±±³          ³          Opcoes :  H-Horas;                                ³±±
±±³          ³                    D-Dias;                                 ³±±
±±³          ³                    M-Meses;                                ³±±
±±³          ³                    I-Minutos;                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA330                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT330CDHP(dData,cHora,cTipo,nTmpPar,cUniTmp)
	Local vDtH  := {}
	Local nTmp := 0

	// Tratamento efetuado para manter funcionalidade de processos anteriores
	Default nTmpPar := If(cTipo == "A",(cTRB)->TF_TEPAANT,(cTRB)->TF_TEPADEP)
	Default cUniTmp := If(cTipo == "A",(cTRB)->TF_UNPAANT,(cTRB)->TF_UNPADEP)

	// Caso o intuito seja calcular o tempo de parada do bem, anterior a manutenção
	// E caso a manutenção possua tempo de parada, correspondente, definido
	If cTipo = "A"

		If !Empty(nTmpPar)

			// Caso a unidade de tempo seja Horas/Minutos
			// Define novo periodo para parada do bem, considerando unidade
			If cUniTmp == "H" .Or. cUniTmp == "I"
				vDtH := NGDTHORINI(dData,cHora,If(cUniTmp == "H",nTmpPar,nTmpPar/60))
				dPRE := vDtH[1]
				hPRE := vDtH[2]
			Else
				// Define tempo de parada, conforme unidade de tempo informada
				nTmp := nTmpPar * If(cUniTmp == "S",5,If(cUniTmp == "M",30,1))
				dPRE := dDATA - nTmp
				hPRE := cHORA
			EndIf
		Else
			dPRE := dData
			hPRE := cHora
		EndIf

	Else

		// Caso a manutenção possua tempo de parada, posterior a manutencao, definido
		If !Empty(nTmpPar)

			// Caso a unidade de tempo seja Horas/Minutos
			// Define novo periodo para parada do bem, considerando unidade
			If cUniTmp == "H" .Or. cUniTmp == "I"
				vDtH := NGDTHORFIM(dData,cHora,If(cUniTmp == "H",nTmpPar,nTmpPar/60))
				dPOS := vDtH[1]
				hPOS := vDtH[2]

				// Identifica o tipo de unidade da quantidade quando for informado um insumo que utiliza tipo de unidade hora
				If GetNewPar("MV_NGUNIDT","") = "D"
					cMinD := SubStr(vDtH[2],4,2)
					hPOS := If(cMinD <> "00",SubStr(vDtH[2],1,3)+StrZero(NGCONVERHORA(Val(cMinD)),2),vDtH[2])
				EndIf
			Else
				// Define tempo de parada, conforme unidade de tempo informada
				nTmp := nTmpPar * If(cUniTmp == "S",5,If(cUniTmp == "M",30,1))
				dPOS := dDATA + nTmp
				hPOS := cHORA
			EndIf
		Else
			dPOS := dData
			hPOS := cHora
		EndIf

	EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³f330TmpF  ³ Autor ³ Denis                 ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Bloqueio da Mao de Obra e Ferramenta temporariamente       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function f330TmpF(aFUN,nTipo)
	Local cCod

	If nTipo == 2 //Especialidade
		cCod := Left(aFUN[2],Len(ST2->T2_ESPECIA))
		If aSCAN(a330EspB,{|x| x[1]+x[2]+x[3]+x[4]+DtoS(x[5])+x[6] == aFUN[8]+aFUN[9]+aFUN[1]+cCod+DTOS(aFUN[4])+aFUN[5] }) = 0
			//1.TTY_ORDEM, 2.TTY_PLANO, 3.TTY_TAREFA, 4.TTY_CODESP, 5.TTY_DTINI, 6.TTY_HRINI, 7.TTY_DTFIM, 8.TTY_HRFIM, 9.TTY_MOTIVO
			aAdd(a330EspB, { aFUN[8] , aFUN[9] , aFUN[1] , cCod , aFUN[4] , aFUN[5] , aFUN[6] , aFUN[7] , STR0021+aFUN[8] } ) //"O.S. MANUTENCAO N."
		EndIf
	ElseIf nTipo == 1 //Mao de Obra
		cCod := Left(aFUN[2],Len(STK->TK_CODFUNC))
		If aSCAN(a330TmpF,{|x| x[1]+x[2]+x[3]+x[4]+DtoS(x[5])+x[6] == aFUN[8]+aFUN[9]+aFUN[1]+cCod+DTOS(aFUN[4])+aFUN[5] }) = 0
			//1.TK_ORDEM, 2.TK_PLANO, 3.TK_TAREFA, 4.TK_CODFUNC, 5.TK_DATAINI, 6.TK_HORAINI, 7.TK_DATAFIM, 8.TK_HORAFIM, 9.TK_MOTIVO
			aAdd(a330TmpF, { aFUN[8] , aFUN[9] , aFUN[1] , cCod , aFUN[4] , aFUN[5] , aFUN[6] , aFUN[7] , STR0021+aFUN[8] } ) //"O.S. MANUTENCAO N."
		EndIf
	EndIf
Return NIL

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³fMnt33CKDA³ Autor ³ Denis                 ³ Data ³ 05/11/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Valida o intervalo de data/hora do bloqueio do funcionario  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cCODFUNC  - Codigo do Funcionario             - Obrigatorio ³±±
±±³          ³dDTINISTK - Data inicio bloqueio funcionario  - Obrigatorio ³±±
±±³          ³cHRINISTK - Hora inicio bloqueio funcionario  - Obrigatorio ³±±
±±³          ³dDTFIMSTK - Data fim bloqueio funcionario     - Obrigatorio ³±±
±±³          ³cHRFIMSTK - Hora fim bloqueio funcionario     - Obrigatorio ³±±
±±³          ³lBloqData - Indica se retorna Array ou Logico - Obrigatorio ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³SIGAMNT - MNTA330                                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄ-ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ-ÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fMnt33CKDA(cCODFUNC,dDTINISTK,cHRINISTK,dDTFIMSTK,cHRFIMSTK,lBloqData)
	Local nXXX, nPosIni
	Local lRet := .F.
	Local aRet := {}

	Default lBloqData := .F.

	aSORT(a330TmpF,,,{|x,y| x[4]+DtoS(x[5]) < y[4]+DtoS(y[5]) })
	nPosIni := aSCAN(a330TmpF,{|x| x[4] == cCODFUNC })
	//a330TmpF (1.TK_ORDEM, 2.TK_PLANO, 3.TK_TAREFA, 4.TK_CODFUNC, 5.TK_DATAINI, 6.TK_HORAINI, 7.TK_DATAFIM, 8.TK_HORAFIM, 9.TK_MOTIVO)

	If nPosIni > 0
		For nXXX := nPosIni To Len(a330TmpF)
			If lBloqData
				If a330TmpF[nXXX,4] <> cCODFUNC
					Exit
				EndIf
				If DtoS(dDTINISTK)+cHRINISTK < DtoS(a330TmpF[nXXX,7])+a330TmpF[nXXX,8] .and.;
				DtoS(dDTFIMSTK)+cHRFIMSTK > DtoS(a330TmpF[nXXX,5])+a330TmpF[nXXX,6]
					aAdd( aRet , { a330TmpF[nXXX,5] , a330TmpF[nXXX,6] , a330TmpF[nXXX,7] , a330TmpF[nXXX,8] } )
				EndIf
			Else
				If a330TmpF[nXXX,4] <> cCODFUNC .or. lRet
					Exit
				EndIf
				If DtoS(dDTINISTK)+cHRINISTK < DtoS(a330TmpF[nXXX,7])+a330TmpF[nXXX,8] .and.;
				DtoS(dDTFIMSTK)+cHRFIMSTK > DtoS(a330TmpF[nXXX,5])+a330TmpF[nXXX,6]
					lRet := .T.
					Exit
				EndIf
			EndIf
		Next nXXX
	EndIf

	If lBloqData //Retorna array
		Return aRet
	EndIf
Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³fMntRetDis ³ Autor ³ Denis                 ³ Data ³05/11/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Retorna o codigo do funcionario que sera utilizado no rodizio±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fMntRetDis( cEspCod , nEspQtd , nPosTmp , cCodPad , aTmpFun )
	Local nFd    := 0
	Local nPosEs := aSCAN(aTarEsp,{|x| x[1]+Str(x[2],3) == cEspCod+Str(nEspQtd,3)})
	Local cCod_  := cCodPad

	If nPosEs > 0
		If Len(aTarEsp[nPosEs,4]) >= nPosTmp
			cCod_ := aTarEsp[nPosEs,4,nPosTmp]
			If aSCAN(aTmpFun ,{|x| x == cCod_ }) == 0
				cCod_ := cCodPad
			EndIf
		EndIf
	EndIf
Return cCod_

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ fCalcTol ³ Autor ³ Denis                 ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Calcula Data Limite da Tolerancia                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fCalcTol( _TIPO , _CUMDOIS , dREAL , n330Tole )
	Local nINTEI := 0, nRESTO := 0, nPOSPO := 0, cVALOR, nINCDAT := 0
	Local dDataTol := dREAL
	Local nIncTmp

	If (_TIPO $ "C/F" .and. _CUMDOIS == 1) .or. _CUMDOIS == 2

		nIncTmp := ( (STF->TF_INENMAN * n330Tole) / 100 ) / M->T9_VARDIA
		nINTEI  := Int(nIncTmp)
		nResto  := If(nINTEI < 0,nIncTmp*-1,nIncTmp) - If(nINTEI < 0,nINTEI*-1,nINTEI)
		If nRESTO > 0
			cVALOR := Alltrim(Str(nRESTO))
			nPOSPO := At('.',cVALOR)
		EndIf
		nRESTO := If (nPOSPO > 0,Val(Substr(cVALOR,nPOSPO+1,1)),0)
		If nRESTO > 5
			nINCDAT := If(nINTEI <= 0,nINTEI-1,nINTEI+1)
		Else
			nINCDAT := nINTEI
		EndIf
		dDataTol := dREAL + nINCDAT

	ElseIf _TIPO == "T" .and. _CUMDOIS == 1

		If STF->TF_UNENMAN == "H"
			nIncTmp := (STF->TF_TEENMAN * n330Tole) / 100 / 24
			nIncTmp := Int(nIncTmp)
			dDataTol := dREAL + nIncTmp
		ElseIf STF->TF_UNENMAN == "D"
			nIncTmp := (STF->TF_TEENMAN * n330Tole) / 100
			nIncTmp := Int(nIncTmp)
			dDataTol := dREAL + nIncTmp
		ElseIf STF->TF_UNENMAN == "S"
			nIncTmp := (STF->TF_TEENMAN * n330Tole) / 100 * 7
			nIncTmp := Int(nIncTmp)
			dDataTol := dREAL + nIncTmp
		Else
			nIncTmp := (STF->TF_TEENMAN * n330Tole) / 100 * 30
			nIncTmp := Int(nIncTmp)
			dDataTol := dREAL + nIncTmp
		EndIf

	EndIf

	If dDataTol > M->TI_DATAFIM .and. dDataTol >= dREAL
		dDataTol := M->TI_DATAFIM
	EndIf

	If dDataTol <= M->TF_DTULTMA .or. dDataTol > M->TI_DATAFIM .or. dDataTol < dREAL
		Return StoD("")
	EndIf
Return dDataTol

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ fDataTol ³ Autor ³ Denis                 ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Altera data/hora conforme tolerancia                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fDataTol( dBckPrev , dBckTol , cHoraPrev , nQtdPrev , cCal2Fun , cFuncTmp , cTurnoFl , aTmpEsp , lSoTolFunc , lTemC20 )
	Local nFor, nDiff, dDataTmp, cHoraTmp, vRetDH, lTemCa, nXXX, lBloq, nX, lContinua
	Local nLinX, nColX, lProbEs, nInd, dDtTolTmp, dDtIniTmp, cCalFun, nTipInd
	Local cFUNC := Left( cFuncTmp , Len(STK->TK_CODFUNC) )
	Local nQtTmp := nQtdPrev
	Local aBloqs := {}
	Local aBlRet := {}
	Local lOK    := .F.
	Local aRet   := {}
	Local aEspeci:= aClone(aTmpEsp)

	//Se data prevista for vazia ou data tolerancia vazia
	If Empty(dBckPrev) .or. Empty(dBckTol)
		Return aRet
	EndIf
	//Se data prevista for maior que data de tolerancia
	If dBckPrev > dBckTol
		Return aRet
	EndIf

	If aSCAN(aEspeci,{|x| x == cFUNC } ) == 0
		aAdd( aEspeci , cFUNC )
	EndIf

	aSORT(aEspeci,,,{|x,y| x == cFUNC })

	//Armazena os bloqueios dos funcionarios
	For nInd := 1 To Len(aEspeci)
		NGDBAREAORDE("STK",2)
		dbSeek( xFilial("STK") + aEspeci[nInd] + DtoS(dBckPrev) , .T. )
		If Eof() .or. xFilial("STK") != STK->TK_FILIAL .or. aEspeci[nInd] != STK->TK_CODFUNC .or. STK->TK_DATAINI > dBckPrev
			dbSkip(-1)
			If Eof() .or. Bof() .or. xFilial("STK") != STK->TK_FILIAL .or. aEspeci[nInd] != STK->TK_CODFUNC
				dbSkip()
			EndIf
		EndIf
		While !Eof() .And. STK->TK_FILIAL == xFilial("STK") .And. STK->TK_CODFUNC == aEspeci[nInd] .And. STK->TK_DATAINI <= dBckTol
			If dBckPrev <= STK->TK_DATAFIM .and. dBckTol >= STK->TK_DATAINI
				aAdd( aBloqs , { STK->TK_DATAINI , STK->TK_HORAINI , STK->TK_DATAFIM , STK->TK_HORAFIM , aEspeci[nInd] } )
			EndIf
			dbSkip()
		End

		//Verifica bloqueios temporarios do funcionario
		aBlRet := fMnt33CKDA(aEspeci[nInd],dBckPrev,"00:00",dBckTol,"23:59",.t.)
		For nX := 1 To Len(aBlRet)
			aAdd( aBloqs , { aBlRet[nX,1] , aBlRet[nX,2] , aBlRet[nX,3] , aBlRet[nX,4] , aEspeci[nInd] } )
		Next nX

		//Verifica insumos da OS atual ainda não gravados no STL
		lFirst := .F.
		For nLinX := 1 To Len(aTAREFA)
			For nColX := 1 To Len(aTAREFA[nLinX][5])
				If aTAREFA[nLinX,5,nColX,1] == "M" .and. PadR(aTAREFA[nLinX][5][nColX][2],Len(aEspeci[nInd])) == aEspeci[nInd]
					If lTemC20
						If !aTAREFA[nLinX][5][nColX][20]
							Loop
						EndIf
					EndIf
					aAdd( aBloqs , { aTAREFA[nLinX][5][nColX][7] , aTAREFA[nLinX][5][nColX][8] , ;
					aTAREFA[nLinX][5][nColX][9] , aTAREFA[nLinX][5][nColX][10] , aEspeci[nInd] } )
				EndIf
			Next nColX
			If lFirst
				Exit
			EndIf
		Next nLinX

	Next nInd

	For nTipInd := 1 To 2
		dDtIniTmp := dBckPrev
		dDtTolTmp := dBckPrev
		//Na primeira repetição, verifica se os funcionarios da especialidade tem disponibilidade no dia previsto
		//Caso não encontre, será analisado até o ultimo dia de tolerancia (nTipInd == 2)
		If nTipInd == 2
			dDtIniTmp := dBckPrev+1
			dDtTolTmp := dBckTol
		EndIf

		For nInd := 1 To Len(aEspeci)

			//Verifica data disponivel
			nDiff := dDtTolTmp - dDtIniTmp
			cCalFun := NGSEEK("ST1",aEspeci[nInd],1,'T1_TURNO')

			For nFor := 0 To nDiff //A quantidade de repetição corresponde ao numero de dias de diferença da data prevista para a data de tolerancia

				If lOK
					Exit
				EndIf

				dDataTmp := dDtIniTmp + nFor //Define da data base

				If !Empty(cTurnoFl) //Se turno flutuante
					cCaleEs := Space(3)
					MNT330TCAF(aEspeci[nInd],dDataTmp,cHoraPrev,dDataTmp,cHoraPrev,nil,.F.)
					If !Empty(cCaleEs)
						cCalFun := cCaleEs
					EndIf
				EndIf

				If lSoTolFunc //Se nao tiver tolerancia, não muda data inicio
					cHoraTmp := cHoraPrev
					If Empty(cHoraTmp) .or. Alltrim(cHoraTmp) == ":"
						Loop
					EndIf
				Else
					cHoraTmp := MNT330PUHC(cCalFun,dDataTmp,"P") //Define a primeira hora disponivel no dia
					If Empty(cHoraTmp) .or. Alltrim(cHoraTmp) == ":"
						Loop
					EndIf
					If nFor == 0 .and. nTipInd == 1
						cHoraTmp := If( cHoraPrev > cHoraTmp , cHoraPrev , cHoraTmp )
					EndIf
				EndIf

				nMin := HtoM(cHoraTmp)
				lContinua := .T.
				nCont := 0
				//Percorre as horas disponiveis na data temporaria, verificando se tem disponibilidade (sem bloqueio STK ou temporario neste Plano)
				While nMin >= 0 .and. nMin < 1440 .and. lContinua .and. If(lSoTolFunc,nCont == 0,nCont <= 1440)
					nCont++
					vRetDH := fDtHoCalend(dDataTmp,cHoraTmp,nQtTmp,cCalFun,.T.,.T.)
					If Empty(vRetDH[1]) .or. Empty(vRetDH[2]) .or. Alltrim(vRetDH[2]) == ":"
						Exit //Se nao tem calendario no dia
					EndIf
					lTemCa := MNT330CHICA(vRetDH[1],vRetDH[2],cCalFun,.t.)
					If !lTemCa
						Exit //Se nao tem calendario no dia
					EndIf

					//Verifica disponibilidade do funcionario
					If !NGFUNCRH(aEspeci[nInd],.F.,vRetDH[1])
						Exit
					EndIf
					//Verifica Afastamentos
					If !NGFRHAFAST(aEspeci[nInd],dDataTmp,vRetDH[1],.F.,.F.)
						Exit
					EndIf

					If !Empty(cTurnoFl) //se turno flutuante, verifica disponibilidade na data/hora
						lProbEs := MNT330TCAF( aEspeci[nInd] , dDataTmp , cHoraTmp , vRetDH[1] , vRetDH[2] , 1 , .t. )
						If lProbEs
							Exit
						EndIf
					EndIf

					lBloq := .F.
					aMaiorBloq := {StoD(""),Space(5)}
					//Verifica os bloqueios
					For nXXX := 1 To Len(aBloqs)
						If aBloqs[nXXX,5] == aEspeci[nInd]
							If DtoS(dDataTmp)+cHoraTmp < DtoS(aBloqs[nXXX,3])+aBloqs[nXXX,4] .and.;
							DtoS(vRetDH[1])+vRetDH[2] > DtoS(aBloqs[nXXX,1])+aBloqs[nXXX,2]

								If DtoS(aBloqs[nXXX,3])+aBloqs[nXXX,4] > DtoS(aMaiorBloq[1])+aMaiorBloq[2]
									aMaiorBloq := { aBloqs[nXXX,3] , aBloqs[nXXX,4] }
								EndIf
								lBloq := .t.
							EndIf
						EndIf
					Next nXXX

					If lBloq
						If aMaiorBloq[1] <> dDataTmp .or. aMaiorBloq[2] <= cHoraTmp
							lContinua := .F.
							Exit
						EndIf
						//Se encontrou bloqueio, atuliza variavel cHoraTmp para buscar disponibilidade a partir do fim do bloqueio
						nMin := HtoM( aMaiorBloq[2] )
						cHoraTmp := aMaiorBloq[2]
						If !MNT330CHICA(dDataTmp,cHoraTmp,cCalFun,.F.)
							vTepDH := fDtHoCalend(dDataTmp,cHoraTmp, 0.01 ,cCalFun,.T.,.F.,.T.)
							If Alltrim(vTepDH[2]) <> ":" .and. vTepDH[1] == dDataTmp
								cHoraTmp := vTepDH[2]
							EndIf
						EndIf
					Else
						lOK := .t.
						aRet := { dDataTmp , cHoraTmp , vRetDH[1] , vRetDH[2] , aEspeci[nInd] , cCalFun }
						Exit
						//Se encontrou horario disponivel, carrega variavel e retorna a funcao MNT330NOTAR(),
						//onde a data/hora do STL será modificado por tolerancia
					EndIf
				End

				If lOK
					Exit
				EndIf

			Next nFor

			If lOK
				Exit
			EndIf

		Next nInd

		If lOK
			Exit
		EndIf
	Next nInd
Return aRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ f330FerT ³ Autor ³ Denis                 ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Bloqueio de Ferramenta    para a manutencao                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNTA330                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ OBS      ³ Se existir bloqueio para o periodo gera problema.          ³±±
±±³          ³ Se o bloqueio for parcial gera problema e bloqueia o       ³±±
±±³          ³ restante do periodo                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function f330FerT(aFER)
	Local dDATA,cFER,nFER
	Local lBEMFERR := .F.
	Local nXXX, nPosIni
	Local lPROBLEMA := .F.

	dDATA := aFER[4]
	cFER  := Left(aFER[2],Len(SH9->H9_FERRAM))
	NGIFDBSEEK('SH4',cFER,1,.F.)
	If SH4->H4_QUANT < aFER[3]

		cCHASTA := STR0015+STR(aFER[3]-SH4->H4_QUANT,3)+STR0016
		cCHARET := Alltrim(cCHASTA)+Space(len(STA->TA_DESCRIC)-Len(cCHASTA))
		cCODSTA := Alltrim(aFER[2])+Space(Len(STA->TA_CODIGO) - Len(Alltrim(aFER[2])))
		cCODTAR := Alltrim(aFER[1])+Space(Len(STA->TA_TAREFA) - Len(Alltrim(aFER[1])))
		cCHASTA := aFER[8]+aFER[9]+cCODTAR+"F"+cCODSTA+cCHARET
		If !NGIFDBSEEK('STA',cCHASTA,1,)
			MNTGRAVSTA(aFER[8],aFER[9],aFER[1],"F",aFER[2],STR0015+STR(aFER[3]-SH4->H4_QUANT,3)+STR0016) //"FALTAM "###" FERRAMENTAS"
		EndIf
		lPROBLEMA := .T.
	Else
		nFER := 0
		NGDBAREAORDE("SH9",3)
		dbSeek( xFilial("SH9") + "F" + cFER + DtoS(aFER[4]) , .T. )
		If Eof() .or. xFilial("SH9") != SH9->H9_FILIAL .or. SH9->H9_TIPO != "F" .or. cFER != SH9->H9_FERRAM .or. SH9->H9_DTINI > aFER[4]
			dbSkip(-1)
			If Eof() .or. Bof() .or. xFilial("SH9") != SH9->H9_FILIAL .or. SH9->H9_TIPO != "F" .or. cFER != SH9->H9_FERRAM
				dbSkip()
			EndIf
		EndIf
		While !Eof() .And. SH9->H9_FILIAL == xFilial("SH9") .And. SH9->H9_TIPO == "F" .And. SH9->H9_FERRAM == cFER .And. SH9->H9_DTINI <= aFER[6]
			If DtoS(aFER[4])+aFER[5] < DtoS(SH9->H9_DTFIM)+SH9->H9_HRFIM .and.;
			DtoS(aFER[6])+aFER[7] > DtoS(SH9->H9_DTINI)+SH9->H9_HRINI

				nFER += SH9->H9_QUANT
			EndIf
			NGDBSELSKIP("SH9")
		End

		aSORT(a330FerT,,,{|x,y| x[5]+DtoS(x[1]) < y[5]+DtoS(y[1]) })
		nPosIni := aSCAN(a330FerT,{|x| x[5] == cFER })
		//a330FerT (1.H9_DTINI, 2.H9_HRINI, 3.H9_DTFIM, 4.H9_HRFIM, 5.H9_COD, 6.H9_QUANT)
		If nPosIni > 0
			For nXXX := nPosIni To Len(a330FerT)
				If a330FerT[nXXX,5] <> cFER
					Exit
				EndIf
				If DtoS(aFER[4])+aFER[5] < DtoS(a330FerT[nXXX,3])+a330FerT[nXXX,4] .and.;
				DtoS(aFER[6])+aFER[7] > DtoS(a330FerT[nXXX,1])+a330FerT[nXXX,2]

					nFER += a330FerT[nXXX,6]
				EndIf
			Next nXXX
		EndIf

		If (SH4->H4_QUANT < (nFER+aFER[3]))
			cCHASTA := STR0017
			cCHARET := Alltrim(cCHASTA)+Space(len(STA->TA_DESCRIC)-Len(cCHASTA))
			cCODSTA := Alltrim(aFER[2])+Space(Len(STA->TA_CODIGO)-Len(Alltrim(aFER[2])))
			cCODTAR := Alltrim(aFER[1])+Space(Len(STA->TA_TAREFA)-Len(Alltrim(aFER[1])))
			cCHASTA := aFER[8]+aFER[9]+cCODTAR+"F"+cCODSTA+cCHARET
			If !NGIFDBSEEK('STA',cCHASTA,1,.F.)
				MNTGRAVSTA(aFER[8],aFER[9],aFER[1],"F",aFER[2],STR0017) //"FERRAMENTA NAO DISPONIVEL"
			EndIf
			lPROBLEMA := .T.
		EndIf

	EndIf

	If !lPROBLEMA
		//1.H9_DTINI, 2.H9_HRINI, 3.H9_DTFIM, 4.H9_HRFIM, 5.H9_COD, 6.H9_QUANT
		aAdd(a330FerT, { aFER[4] , aFER[5] , aFER[6] , aFER[7] , cFER , aFER[3] } )
	EndIf
	SH9->(dbSetOrder(1))
Return Nil

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³fDtHoCalend ³ Autor ³ Denis                 ³ Data ³30/09/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Calcula a data e hora fim usando calenedario                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA330                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fDtHoCalend(dVDTI,hVHI,nVQTD,cVCALE,lUltimoMin,lHoraFim,lErroTol)
	Local nDIAS  := Dow(dVDTI)
	Local nSOMH  := 0.00
	Local nSOMAH := Round((NGCONVERHORA(nVQTD,"S","D") * 60),0)
	Local hHFC   := "  :  "
	Local lPRIMX ,lSAIR
	Local nSODIA,iX,iY,nFcal := 0
	Local nPosCF := aSCAN(aCalenF,{|x| x[1] == cVCALE})

	Default lUltimoMin := .t. //Indica se considera o ultimo minuto de trabalho
	Default lHoraFim   := .t. //Indica se considera o ultimo minuto de trabalho
	Default lErroTol   := .F. //Quando a funcao for chamado pela funcao de Tolerancia

	Store 0 To nSODIA,iX,iY
	Store .F. To lPRIMX,lSAIR

	If nPosCF == 0
		aAdd(aCalenF,{cVCALE,NGCALENDAH(cVCALE)})
		nPosCF := Len(aCalenF)
	EndIf

	aMATCA := aClone( aCalenF[nPosCF,2] )
	lCALE  := .T.

	While !lSAIR .AND. Len(aMATCA) > 0
		For iX := nDIAS To 7
			For iY := 1 To Len(aMATCA[iX,2])
				If !lPRIMX
					lIfOK := If( lHoraFim , (hVHI >= aMATCA[iX,2,iY,1] .And. hVHI <  aMATCA[iX,2,iY,2]) ,;
					(hVHI >= aMATCA[iX,2,iY,1] .And. hVHI <= aMATCA[iX,2,iY,2])  )
					If lIfOK
						lPRIMX := .t.
						nHOARF := Htom(aMATCA[iX,2,iY,2])
						nHOARI := Htom(hVHI)
						nSOMH  := nHOARF - nHOARI
						If If( lUltimoMin , nSOMH >= nSOMAH , nSOMH > nSOMAH )
							hHFC := Mtoh(nHOARF)
							If nSOMH > nSOMAH
								hHFC := Mtoh(nHOARF - (nSOMH - nSOMAH))
							EndIf
							lSAIR := .t.
							Exit
						EndIf
					EndIf
				Else
					nHOARI := Htom(aMATCA[iX,2,iY,1])
					nHOARF := Htom(aMATCA[iX,2,iY,2])
					nSOMIN := nHOARF - nHOARI
					nSOMH  += nSOMIN
					If If( lUltimoMin , nSOMH >= nSOMAH , nSOMH > nSOMAH )
						hHFC := Mtoh(nHOARF)
						If nSOMH > nSOMAH
							If lErroTol .and. nSOMAH == 1
								nSOMAH := 0
							EndIf
							hHFC := Mtoh(nHOARF-(nSOMH - nSOMAH))
						EndIf
						lSAIR := .t.
						Exit
					EndIf
				EndIf
			Next iY
			If lSAIR
				Exit
			Else
				nSODIA := nSODIA + 1
			EndIf
		Next iX

		If lSAIR
			Exit
		Else
			nDIAS := 1
		EndIf

		nFcal ++
		If nFcal > 2 .And. !lPRIMX
			Exit
		EndIf
	End
	If hHFC == "24:00"
		hHFC := "00:00"
		nSODIA := nSODIA + 1
	EndIf
Return {dVDTI+nSODIA,hHFC}

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³fDiffCalend ³ Autor ³ Denis                 ³ Data ³30/09/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Calcula a data e hora fim usando calendario                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA330                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fDiffCalend(cCalMnt, cCalMdo, dIniData, cIniHora, dFimData, cFimHora )
	Local lRet := .F., nDiff, nFor
	Local dDataTmp, cHor1Ini, cHor1Fim, cHor2Ini, cHor2Fim

	//Verifica data disponivel
	nDiff := dFimData - dIniData

	If nDiff >= 0
		For nFor := 0 To nDiff
			dDataTmp := dIniData + nFor //Define da data base

			cHor1Ini := If(nFor == 0,cIniHora,MNT330PUHC(cCalMdo,dDataTmp,"P")) //Define a primeira hora - Funcionario
			cHor1Fim := If(nFor == nDiff,cFimHora,MNT330PUHC(cCalMdo,dDataTmp,"U")) //Define a ultima hora - Funcionario

			cHor2Ini := MNT330PUHC(cCalMnt,dDataTmp,"P") //Define a primeira hora - Manutencao
			cHor2Fim := MNT330PUHC(cCalMnt,dDataTmp,"U") //Define a ultima hora - Manutencao

			//Se Funcionario nao tem calendario no dia
			If (Empty(cHor1Ini) .or. Alltrim(cHor1Ini) == ":") .or. (Empty(cHor1Fim) .or. Alltrim(cHor1Fim) == ":")
				Loop
			EndIf

			//Se Manutencao nao tem calendario no dia
			If (Empty(cHor1Fim) .or. Alltrim(cHor1Fim) == ":") .or. (Empty(cHor2Fim) .or. Alltrim(cHor2Fim) == ":")
				lRet := .t.
				Exit
			EndIf

			//Se excedeu calendario da manutencao
			If cHor1Ini < cHor2Ini .or. cHor1Fim > cHor2Fim
				lRet := .t.
				Exit
			EndIf
		Next nFor
	EndIf
Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ fGravPrb   ³ Autor ³ Felipe Nathan Welter  ³ Data ³ 19/05/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Grava problemas encontrados nos filtros de selecao p/ plano  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MNTA330                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fGravPrb(cDescri,cCodBem,cServic,cSequen)

	Local aArea := GetArea()
	Local aAreaST9 := ST9->(GetArea())
	Local aAreaSTF := STF->(GetArea())
	Local lGrava := .T.

	Default cCodBem := Space(Len((cTRBPRB)->CODBEM))
	Default cServic := Space(Len((cTRBPRB)->SERVIC))
	Default cSequen := Space(Len((cTRBPRB)->SEQUEN))

	//[imprime relatorio de inconsistencias] e [nao ha OS gravada]
	If lMVMOINP .And. ((cTRB)->(RecCount()) == 0)
		If !lPlaEstu  //valida se for do tipo Bem, nao estrutura
			If !Empty(cCodBem)  //filtra problema no bem conforme planejamento
				NGIFDBSEEK('ST9',cCodBem,1,.F.)
				If !(If(Empty(M->TI_CCUSINI),.T.,ST9->T9_CCUSTO  >= M->TI_CCUSINI .And. ST9->T9_CCUSTO  <= M->TI_CCUSFIM) .And.;
				If(Empty(M->TI_CTRAINI),.T.,ST9->T9_CENTRAB >= M->TI_CTRAINI .And. ST9->T9_CENTRAB <= M->TI_CTRAFIM) .And.;
				If(Empty(M->TI_FAMIINI),.T.,ST9->T9_CODFAMI >= M->TI_FAMIINI .And. ST9->T9_CODFAMI <= M->TI_FAMIFIM) .And.;
				If(Empty(M->TI_BEMINI), .T.,ST9->T9_CODBEM  >= M->TI_BEMINI  .And. ST9->T9_CODBEM  <= M->TI_BEMFIM)  .And.;
				If(lModBe,If(Empty(M->TI_TIPMODI),.T.,ST9->T9_TIPMOD >= M->TI_TIPMODI .And. ST9->T9_TIPMOD <= M->TI_TIPMODF),.T.))
					lGrava := .F.
				EndIf
				If lGrava .And. !Empty(cServic) .And. !Empty(cSequen)  //filtra problema com manutencao conforme planejamento
					NGIFDBSEEK('STF',cCodBem+cServic+cSequen,1,.F.)
					If !(If(Empty(M->TI_SERVINI),.T.,STF->TF_SERVICO >= M->TI_SERVINI .And. STF->TF_SERVICO <= M->TI_SERVFIM) .And.;
					If(Empty(M->TI_AREAINI),.T.,STF->TF_CODAREA >= M->TI_AREAINI .And. STF->TF_CODAREA <= M->TI_AREAFIM) .And.;
					If(Empty(M->TI_TIPOINI),.T.,STF->TF_TIPO    >= M->TI_TIPOINI .And. STF->TF_TIPO    <= M->TI_TIPOFIM))
						lGrava := .F.
					EndIf
				EndIf
			EndIf
		EndIf

		If lGrava
			//valida se problema ja foi gravado
			NGDBAREAORDE((cTRBPRB),1)
			dbSeek(cCodBem+cServic+cSequen,.T.)
			While !Eof() .And. (cTRBPRB)->CODBEM == cCodBem .And. cServic == (cTRBPRB)->SERVIC .And. (cTRBPRB)->SEQUEN == cSequen
				If AllTrim((cTRBPRB)->DESCRI) == cDescri
					lGrava := .F.
					Exit
				EndIf
				dbSkip()
			EndDo

			If lGrava
				RecLock((cTRBPRB),.T.)
				(cTRBPRB)->CODBEM := cCodBem
				(cTRBPRB)->SERVIC := cServic
				(cTRBPRB)->SEQUEN := cSequen
				(cTRBPRB)->DESCRI := cDescri
				MsUnLock(cTRBPRB)
			EndIf
		EndIf
	EndIf
	RestArea(aAreaSTF)
	RestArea(aAreaST9)
	RestArea(aArea)
Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ f330RImp   ³ Autor ³ Felipe Nathan Welter  ³ Data ³ 19/05/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Chamada do relatório de problemas nos filtros                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ a330GRAVA (MNTA330)                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function f330RImp()

	Local cString  := (cTRBPRB)
	Local cDesc1   := STR0081  //"Geração do relatório de inconsistências encontrados durante o processo de"
	Local cDesc2   := STR0082  //"validação dos parâmetros do plano de manutenção."
	Local cDesc3   := ""
	Local wnrel    := "MNTA330"
	Local LIMITE     := 132
	Private aReturn  := {STR0083,1,STR0084, 2, 2, 1, "",1 }  //"Zebrado"##"Administracao"
	Private nLastKey := 0
	Private Tamanho  := "M"
	Private nomeprog := "MNTA330"
	Private Titulo   := STR0085  //"Inconsistências na geração de OS pelo plano de manutenção"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Envia controle para a funcao SETPRINT                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	wnrel:=SetPrint(cString,wnrel,,titulo,cDesc1,cDesc2,cDesc3,.F.,"")
	If nLastKey == 27
		Set Filter To
		Return
	EndIf
	SetDefault(aReturn,cString)
	RptStatus({|lEnd| f330RIT(@lEnd,wnRel,titulo,Tamanho)},titulo)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ f330RIT    ³ Autor ³ Felipe Nathan Welter  ³ Data ³ 19/05/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Impressão do relatório de problemas nos filtros              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ f330RImp (MNTA330)                                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function f330RIT(lEnd,wnRel,titulo,Tamanho)

	Local cCodBem := "",nX := 0
	Local vVetCaE := {"TI_PLANO","TI_DATAPLA","TI_DESCRIC","TI_DATAINI","TI_DATAFIM","TI_ESTRUTU","TI_USARIO",;
	"TI_BEMINI","TI_TIPOMDO","TI_TIPACOM", "TI_TOLEPER"}
	Local cBox := ""
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Define Variaveis                                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Private cRodaTxt := ""
	Private nCntImpr := 0
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Contadores de linha e pagina                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Private li := 80
	Private m_pag := 1
	lEnd := .F.

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se deve comprimir ou nao                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Private nTipo  := IIF(aReturn[4]==1,15,18)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta os Cabecalhos                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Private cabec1 := STR0086  //" Bem"
	Private cabec2 := STR0087  //"      Serviço    Seq.  Inconsistência"

	/*/
	1         2         3         4         5         6         7         8         9         0         1         2         3
	0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
	*************************************************************************************************************************************
	xxxxx.:   xx
	xxx/xxxxxxx/xxxxx                    Inconsistências na geração de OS pelo plano de manutenção 			 				  xxxxx: xx/xx/xx
	xxxx...: xx:xx:xx                                                                          						       xxxxxx: xx/xx/xx
	*************************************************************************************************************************************
	Bem
	Serviço    Seq.  Inconsistência
	*************************************************************************************************************************************
	Parametros do Plano de Manutenção XXXXXX:
	--------------------------------------------------

	Plano de Manutenção:  XXXXXX - XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	Data Plano:           99/99/99
	Data Inicio:          99/99/99
	Data Fim:             99/99/99
	[...]

	Listagem das inconsistências na geração de OS:
	--------------------------------------------------

	XXXXXXXXXXXXXXXX - XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	XXXXXX     XXX   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	XXXXXX     XXX   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	XXXXXX     XXX   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

	XXXXXXXXXXXXXXXX    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

	XXXXXXXXXXXXXXXX    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
	*************************************************************************************************************************************
	*/

	NGSETIFARQUI((cTRBPRB),,1)
	SetRegua((cTRBPRB)->(RecCount()))

	SomaLinha()
	@ Li,001 PSay STR0094 //"Parametros informados para gerar o Plano de Manutenção "
	SomaLinha()
	@ Li,001 PSay Replicate("-",56)
	SomaLinha()
	For nX := 1 to Len(aGETS)
		cCampP := Alltrim(SubS(aGETS[nX],9,10))
		cTemF3 := SubS(aGETS[nX],19,6)
		cCampM := '"M->'+cCampP+'"'
		cCampD := &(cCampM)
		lPrimC := .T.
		If lPlaEstu
			If Ascan(vVetCaE,{|x| x == cCampP}) > 0
				SomaLinha()
				If cCampP = "TI_BEMINI"
					@ Li,001 PSay STR0093+":"  //"Bem Pai"
				Else
					@ Li,001 PSay NGRETTITULO(cCampP)
				EndIf
			Else
				lPrimC := .F.
			EndIf
		Else
			SomaLinha()
			@ Li,001 PSay NGRETTITULO(cCampP)
		EndIf
		If lPrimC
			@ Li,020 PSay ":"
			If Empty(cTemF3)
				If Valtype(&(cCampD)) = "N"
					@ Li,023 PSay &(cCampD)
				Else
					cBox := Posicione("SX3",2,cCampP,"X3CBox()")
					If !Empty(cBox)
						@ Li,023 PSay cBox
					Else
						@ Li,023 PSay If(!Empty(&(cCampD)),&(cCampD)," ")
					EndIf
				EndIf
			Else
				cCampVI := Alltrim(SubS(aGETS[nX+1],9,10))
				cCampVM := '"M->'+cCampVI+'"'
				cCampVD := &(cCampVM)
				@ Li,023 PSay Alltrim(&(cCampD))+If(!Empty(&(cCampVD))," - " + &(cCampVD)," ")
				nX ++
			EndIf
		EndIf
	Next nX

	Li := 80  //Forca a quebra de pagina

	SomaLinha()
	@ Li,001 PSay STR0078  //"Listagem das inconsistências na geração de OS:"
	SomaLinha()
	@ Li,001 PSay Replicate("-",50)
	SomaLinha()
	SomaLinha()

	While (cTRBPRB)->(!Eof())

		IncRegua()

		cCodBem := (cTRBPRB)->CODBEM
		If !Empty(cCodBem)
			@ Li,001 PSay AllTrim(cCodBem) + " - " + NGSEEK("ST9",cCodBem,01,"T9_NOME")
		EndIf

		While !Eof() .And. (cTRBPRB)->CODBEM == cCodBem
			SomaLinha()
			If !Empty((cTRBPRB)->SERVIC)
				@ Li,006 PSay (cTRBPRB)->SERVIC
				@ Li,017 PSay (cTRBPRB)->SEQUEN
			EndIf
			cPrb := "- "+AllTrim((cTRBPRB)->DESCRI)
			While Len(cPrb) > 0
				@ Li,023 PSay SubStr(cPrb,1,105)
				cPrb := SubStr(cPrb,106,Len(cPrb))
				If Len(cPrb) > 0
					SomaLinha()
				EndIf
			EndDo
			dbSkip()
		EndDo

		SomaLinha()
		SomaLinha()

	EndDo

	RODA(nCntImpr,cRodaTxt,Tamanho)

	Set Filter To
	Set Device To Screen
	If aReturn[5] == 1
		Set Printer To
		dbCommitAll()
		OurSpool(wnrel)
	EndIf
	MS_FLUSH()
Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ Somalinha  ³ Autor ³ Felipe Nathan Welter  ³ Data ³ 19/05/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Incrementa Linha e Controla Salto de Pagina                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MNTA330                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function SomaLinha()
	Local nVerif := If(nTIPO==15,75,58)
	Li++
	If Li > nVerif .And. Li <> 81
		Cabec(titulo,cabec1,cabec2,nomeprog,tamanho,nTipo)
		SomaLinha()
	EndIf
	If Li == 81
		Cabec(titulo,cabec1,cabec2,nomeprog,tamanho,nTipo)
	EndIf
Return .T.
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ f330TRFAT  ³ Autor ³ Evaldo Cevinscki Jr.  ³ Data ³ 19/07/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Verifica situacao da Tarefa, se esta Ativa oi Inativa        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MNTA330/MNTA410/MNTA295/NGGERAOS                             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function f330TRFAT(cBemTr,cSerTr,cSeqTr,cTar)
	Local lRet := .t.

	If NGCADICBASE('T5_ATIVA','A','ST5',.F.)
		If NGIFDBSEEK("ST5",cBemTr+cSerTr+cSeqTr+cTar,1)
			If ST5->T5_ATIVA == "2"
				lRet := .F.
			EndIf
		EndIf
	EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³ LockPlano  ³ Autor ³ Vitor Emanuek Batista ³ Data ³12/01/2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Retorna o próximo código de plano de manutenção disponível   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MNTA330                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function LockPlano()
	Local i
	Local cPlanoSTJ
	Local cPlanoSTI
	Local cPlanoSTS
	Local cChave := NGSEEKDIC("SX2","STJ",1,'X2_ARQUIVO')
	Local lExSTI := NGSX2MODO("STI") == "C"

	//--------------------------------------------------------------
	// Verifica se a STJ esta compartilhada e a STI esta exclusiva
	// nao permitindo a repeticao do numero do Plano.
	//--------------------------------------------------------------
	If NGSX2MODO("STJ") == "C" .And. !lExSTI

		//----------------------------------------------------------
		// Busca o próximo código para o plano de acordo com a STJ
		//----------------------------------------------------------
		cPlanoSTJ := NextNumero("STJ",3,"TJ_PLANO",.T.)
		cPlanoSTJ := If(Empty(cPlanoSTJ),"000003",cPlanoSTJ)

		//---------------------------------------------
		// Verifica se o numero do plano é 000000 ou
		// 000001, somando 2 ou 1 respectivamente.
		//---------------------------------------------
		nSoma := If(cPlanoSTJ == "000000",2,If(cPlanoSTJ == "000001",1,0))
		For i := 1 To nSoma
			cPlanoSTJ := If(FindFunction("Soma1Old"),Soma1Old(AllTrim(cPlanoSTJ)),Soma1(AllTrim(cPlanoSTJ)))
		Next i

		//----------------------------------------------------------
		// Busca o próximo código para o plano de acordo com a STI
		//----------------------------------------------------------
		cPlanoSTI := NextNumero("STI",1,"TI_PLANO",.T.)

		//---------------------------------------
		// Considera o maior número para o plano
		//---------------------------------------
		cPlanoSTI := If(cPlanoSTI > cPlanoSTJ,cPlanoSTI,cPlanoSTJ)

	Else
		cPlanoSTI := NextNumero("STI",1,"TI_PLANO",.T.)
	EndIf

	//----------------------------------------------------------
	// Busca o próximo código para o plano de acordo com a STS
	//----------------------------------------------------------
	cPlanoSTS := NextNumero("STS",3,"TS_PLANO",.T.)

	//---------------------------------------
	// Considera o maior número para o plano
	//---------------------------------------
	cPlanoSTI := If(cPlanoSTI > cPlanoSTS,cPlanoSTI,cPlanoSTS)

	While !LockByName(cPlanoSTI+cChave,.F.,lExSTI)
		cPlanoSTI := If(FindFunction("Soma1Old"),Soma1Old(AllTrim(cPlanoSTI)),Soma1(AllTrim(cPlanoSTI)))
	EndDo

Return cPlanoSTI

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³UnLockPlano ³ Autor ³ Vitor EmanueL Batista ³ Data ³12/01/2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Elimina o bloqueia feito pelo LockPlano                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MNTA330                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function UnLockPlano(cPlanoSTI)
	Local cChave := NGSEEKDIC("SX2","STJ",1,'X2_ARQUIVO')
	Local lExSTI := NGSX2MODO("STI") == "C"

	UnLockByName(cPlanoSTI+cChave,.F.,lExSTI)

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fUltOSMan
Função que retorna o horário da última O.S. Terminada relacionada à
manutenção passada como parâmetro desta função.
Caso não haja nenhuma manutenção, então o retorno será o padrão 0.00,
e será indicada que não é necessário incrementar a hora para o primeiro
registro da "próxima manutenção" porque na verdade ainda não há nenhuma
O.S. cadastrada. (isto ocorre normalmente quando é cadastrada a manutenção
do bem e logo em seguida gerado o plano de manutenção; ou seja,
neste processo, nenhuma ordem de serviço foi feita para o bem ainda)

*** ATENÇÃO:
- A variável "_lFirstOS" deve estar declarada como Private
- Esta função é valida apenas para quando o Tipo de Incremento da
manutenção é em HORAS.


@author Wagner Sobral de Lacerda
@since 04/09/2012

@param cManFilial
Filial do cadastro da Manutenção * Obrigatório
@param cManCodBem
Código do Bem do cadastro da Manutenção * Obrigatório
@param cManServic
Serviço do cadastro da Manutenção * Obrigatório
@param cManSeqRel
Sequência do cadastro da Manutenção * Obrigatório
@param dDtUlAcomp
Data do Último Acompanhamento do cadastro da Manutenção * Obrigatório

@return nHrUltOS
/*/
//---------------------------------------------------------------------
Static Function fUltOSMan(cManFilial, cManCodBem, cManServic, cManSeqRel, dDtUlAcomp)

	// Variável do Retorno
	Local nHrUltOS := 0.00

	// Salva as áreas das tabelas atuais
	Local aAreaSTF := STF->( GetArea() )
	Local aAreaSTJ := STJ->( GetArea() )

	// Variáveis para a Última Data/Hora da O.S.
	Local dDtAtuOS := CTOD("")
	Local cHrAtuOS := "00:00"
	Local dDtUltOS := CTOD("")
	Local cHrUltOS := ""

	// Variáveis da Data/Hora da Manutenção Real Fim e da Parada Real Fim (será utilizada a maior para os calculos)
	Local dDtManut := CTOD("")
	Local cHrManut := "00:00"
	Local dDtParad := CTOD("")
	Local cHrParad := "00:00"

	//----------
	// Executa
	//----------
	dbSelectArea("STF")
	dbSetOrder(1)
	If dbSeek(cManFilial + cManCodBem + cManServic + cManSeqRel)
		dbSelectArea("STJ")
		dbSetOrder(2)
		dbSeek(xFilial("STJ",cManFilial) + "B" + cManCodBem + cManServic + cManSeqRel, .T.)
		While !Eof() .And. STJ->TJ_FILIAL == xFilial("STJ",cManFilial) .And. STJ->TJ_TIPOOS == "B" .And. STJ->TJ_CODBEM == cManCodBem .And. ;
		STJ->TJ_SERVICO == cManServic .And. STJ->TJ_SEQRELA == cManSeqRel

			// Apenas verifica Ordens de Serviço Liberadas
			If AllTrim(STJ->TJ_SITUACA) <> "C"
				// Data/Hora da Manutenção Real
				dDtUltOS := STJ->TJ_DTMPFIM
				cHrUltOS := STJ->TJ_HOMPFIM

			EndIf

			dbSelectArea("STJ")
			dbSkip()
		End
	EndIf

	// Caso a última O.S. encontrada seja na mesma data do último acompanhamento da manutenção, define o horário final do acompanhamento
	If Empty(cHrUltOS)
		_lFirstOS := .T.

	Else
		// Do contrário, indica que é a primeira O.S. do dia
		nHrUltOS := HTON(cHrUltOS)

		// Então, se já há uma O.S., então o primeiro registro do dia já existe
		_lFirstOS := .F.
	EndIf

	// Devolve as áreas das tabelas
	RestArea(aAreaSTJ)
	RestArea(aAreaSTF)

Return nHrUltOS

//---------------------------------------------------------------------
/*/{Protheus.doc} SetPrdMax
Alimenta variaveis de periodo maximo.

@param dDtVer Data a ser avaliada.
@param cHrVer Hora a ser avaliada.
@param dDtMax Data maxima atual.
@param cHrMax Hora maxima atual.

@author Hugo R. Pereira
@since 20/03/2013
@return Nil
/*/
//---------------------------------------------------------------------
Static Function SetPrdMax(dDtVer, cHrVer, dDtMax, cHrMax)

	If ValType(dDtVer) != "D" .Or. ValType(cHrVer) != "C"
		Return Nil
	EndIf

	If dDtVer > dDtMax
		dDtMax := dDtVer
		cHrMax := HTOM(cHrVer)
	ElseIf dDtVer == dDtMax .And. HTOM(cHrVer) > cHrMax
		cHrMax := HTOM(cHrVer)
	EndIf

Return
//---------------------------------------------------------------------------------------
/*/{Protheus.doc} fImp330Log
Função que imprime relatório de problemas encontrado na finalização do plano.

@author Cezar Augusto Padilha
@since 18/03/2013
@version MP11
@return Nil
/*/
//---------------------------------------------------------------------------------------
Static Function fImp330Log(cArquiv)
	cString  := cArquiv
	cdesc1   := STR0098 //"Relatório de problemas encontrados na Finalização/Cancelamento do Plano."
	cdesc2   := " "
	cdesc3   := " "
	wnrel    := "MNTA330"
	aReturn  := {STR0083,1,STR0084, 2, 2, 1, "",1 }  //"Zebrado"##"Administracao"
	nLastKey := 0
	Tamanho  := "M"
	nomeprog := "MNTA330"
	Titulo   := STR0099 //"Pendências das O.S. do Plano"

	Private cArqRelat := cArquiv //Arquivo dos problemas do plano

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Envia controle para a funcao SETPRINT                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	wnrel:=SetPrint(cString,wnrel,,titulo,cDesc1,cDesc2,cDesc3,.F.,"")
	If nLastKey == 27
		Set Filter To
		Return
	EndIf
	SetDefault(aReturn,cString)
	If nLastKey == 27
		Set Filter To
		Return
	EndIf

	RptStatus({|lEnd| MNTA330IT(@lEnd,wnRel,titulo,tamanho)},titulo)

Return NIL
//---------------------------------------------------------------------------------------
/*/{Protheus.doc} MNTA330IT
Função que monta o relatório de cotações da O.S.

@author Cezar Augusto Padilha
@since 19/03/2013
@version MP11
@return Nil
/*/
//---------------------------------------------------------------------------------------
Function MNTA330IT

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Define Variaveis                                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cRodaTxt := ""
	nCntImpr := 0
	nAtual   := 0
	contador := 0
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Variaveis para controle do cursor de progressao do relatorio ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nTotRegs := 0
	nMult    := 1
	nPosAnt  := 4
	nPosAtu  := 4
	nPosCnt  := 0
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Contadores de linha e pagina                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	li := 80
	m_pag := 1
	lEnd := .F.

	CABEC1 := STR0100 //"O.S.   Sequencia Tipo Insumo  Código                         Descrição"
	CABEC2 := " "
	ntipo  := 0

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se deve comprimir ou nao                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nTipo  := IIF(aReturn[4]==1,15,18)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta os Cabecalhos                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


	/*/
	1         2         3         4         5         6         7         8         9         0         1         2         3         4         5         6         7         8         9         0         1         2
	01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
	*************************************************************************************************************************************
	xxxxx.:   xx
	xxx/xxxxxxx/xxxxx                     Problemas encontrados nas Ordens de Serviço do plano                            xxxxx: xx/xx/xx
	xxxx...: xx:xx:xx                                                                                                    xxxxxx: xx/xx/xx
	*************************************************************************************************************************************
	O.S.   Sequencia Tipo Insumo  Código                         Descrição
	xxxxxx       xxx xxxxxxxxx    xxxxxxxxxxxxxxxxxxx            xxxxxxxxxxxxxxxxxx
	*/

	dbSelectArea(cArqRelat)
	DbGoTop()
	SetRegua(LastRec())
	While (cArqRelat)->(!eof())
		If lEnd
			@ PROW()+1,001 PSAY STR0014 //"CANCELADO PELO OPERADOR"
			Exit
		EndIf
		IncRegua()
		SomaProbLi()
		@li,000 PSAY (cArqRelat)->OS
		@li,007 PSAY (cArqRelat)->SEQUEN
		If (cArqRelat)->TIPO == 'P'
			@li,017 PSAY STR0103 //'Produto'
		Else
			@li,017 PSAY STR0104 //'Terceiro'
		EndIf
		@li,030 PSAY (cArqRelat)->CODIGO
		@li,061 PSAY (cArqRelat)->TIPCOT
		dbSelectArea(cArqRelat)
		Dbskip()
	endDo
	RetIndex("SA1")
	Set Filter To
	Set device to Screen
	If aReturn[5] == 1
		Set Printer To
		dbCommitAll()
		OurSpool(wnrel)
	EndIf
	MS_FLUSH()
Return NIL
//---------------------------------------------------------------------------------------
/*/{Protheus.doc} SomaProbLi
Função que controla a quebra de páginas do relatório.

@author Cezar Augusto Padilha
@since 19/03/2013
@version MP11
@return Nil
/*/
//---------------------------------------------------------------------------------------
Static Function SomaProbLi()
	Li := li + 1
	If Li > 58
		Cabec(titulo,cabec1,cabec2,nomeprog,tamanho,nTipo)
	EndIf
Return .T.
//---------------------------------------------------------------------------------------
/*/{Protheus.doc} MNT330INSB
Função que busca bloqueio para os insumos, atraves de solicitações de compra e pedidos (SC7).

@author Cezar Augusto Padilha
@since 19/03/2013
@version MP11
@return Nil
/*/
//---------------------------------------------------------------------------------------
Static Function MNT330INSB(cOs,cTabTemp)
	Local cProdPar := ''
	Local lTemCP := .F.
	Local cAliasQry := GetNextAlias()
	Local cPRODTER	:= GetMv("MV_PRODTER")

	dbSelectArea("STL")
	dbSetOrder(1)
	dbSeek(xFilial("STL")+cOs)
	While STL->(!Eof()) .and. STL->TL_ORDEM == cOs
		If Alltrim(STL->TL_TIPOREG) $ 'T/P'
			cProdPar := STL->TL_CODIGO
			lTemCP := .F.
			If Alltrim(STL->TL_TIPOREG) == 'T'
				cProdPar := If(FindFunction("NGProdMNT"), NGProdMNT("T")[1], cPRODTER)
			EndIf
			cQuery := " SELECT C1_PEDIDO, C1_COTACAO FROM "+RetSqlName("SC1")
			cQuery += " WHERE C1_PRODUTO = '"+cProdPar+"' "
			cQuery += " AND C1_LOCAL = '"+STL->TL_LOCAL+"' "
			cQuery += " AND C1_OP = '"+STL->TL_ORDEM+"OS001' "
			If Alltrim(STL->TL_TIPOREG) == 'T'
				cQuery += " AND C1_FORNECE = '"+STL->TL_CODIGO+"' "
			EndIf
			cQuery += " AND D_E_L_E_T_ = ' ' "
			cQuery := ChangeQuery(cQuery)
			dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)
			dbSelectArea(cAliasQry)
			(cAliasQry)->(dbGoTop())
			If !Empty((cAliasQry)->C1_PEDIDO) .or. !Empty((cAliasQry)->C1_COTACAO)
				NGIFDBSEEK("SC1",STL->TL_ORDEM+'OS001',4)
				dbSelectArea(cTabTemp)
				(cTabTemp)->(dbAppend())
				(cTabTemp)->OS     := cOs
				(cTabTemp)->SEQUEN := cValToChar(STL->TL_SEQRELA)
				(cTabTemp)->TIPO   := cValToChar(STL->TL_TIPOREG)
				(cTabTemp)->CODIGO := Alltrim(STL->TL_CODIGO)
				If !Empty((cAliasQry)->C1_PEDIDO)
					(cTabTemp)->TIPCOT := STR0101+STR0106+": "+(cAliasQry)->C1_PEDIDO //"O insumo possuí Solicitação de Compra com "##"Pedido"
				Else
					(cTabTemp)->TIPCOT := STR0101+STR0105+": "+(cAliasQry)->C1_COTACAO
				EndIf
				(cTabTemp)->(MsUnLock())
			EndIf
			(cAliasQry)->(dbCloseArea())
			// >> Verificação das pendencias em solicitação ao armazem, devem aguardar correção do autoexec do MATA185
			dbSelectArea("SCP")
			dbSetOrder(2)
			dbSeek(xFilial("SCP")+cProdPar)
			While !Eof() .and. Alltrim(SCP->CP_PRODUTO) == Alltrim(cProdPar)
				If Alltrim(SCP->CP_OP) == STL->TL_ORDEM+'OS001' .and. SCP->CP_LOCAL == STL->TL_LOCAL
					If SCP->CP_PREREQU == 'S'
						lTemCP := .T.
						Exit
					ElseIf SCP->CP_QUJE > 0
						lTemCP := .T.
						Exit
					EndIf
				EndIf
				dbSelectArea("SCP")
				dbSkip()
			End
			If lTemCP
				dbSelectArea(cTabTemp)
				(cTabTemp)->(dbAppend())
				(cTabTemp)->OS     := cOs
				(cTabTemp)->SEQUEN := cValToChar(STL->TL_SEQRELA)
				(cTabTemp)->TIPO   := cValToChar(STL->TL_TIPOREG)
				(cTabTemp)->CODIGO := Alltrim(STL->TL_CODIGO)
				(cTabTemp)->TIPCOT := STR0102+SCP->CP_NUM //"O insumo possuí Solicitação de Armazém com pré-requisição: "
				(cTabTemp)->(MsUnLock())
			EndIf
		EndIf
		dbSelectArea("STL")
		STL->(dbSkip())
	End
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT330ESFC
Consiste erros de integracao com modulo SIGASFC.

@param aSFCErro Array com inconsistencias encontradas.

@author Hugo R. Pereira
@since 07/05/2013
@version MP11
@return Nil
/*/
//---------------------------------------------------------------------
Static Function MNT330ESFC(aSFCErro, nOpcSFC)

	If MsgYesNo(STR0107 + CHR(13)+CHR(10) + ;	// "Foram encontrados erros no processo de integração com o Chão de Fábrica."
	STR0108) 						// "Deseja enviar-lhes um e-mail a respeito das inconsistencias encontradas?"
		NGSFCERPL(nOpcSFC, aSFCErro) // Envia e-mail ao responsavel no SIGASFC
	EndIf

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} A330FILBEM
Cria cTRB e monta tela para selecionar os bens aleatórios.

@author Pablo Servin
@since 20/02/2014
@version MP11
@return .T.
/*/
//---------------------------------------------------------------------
Function A330FILBEM()

	Local lInverte  := .F.
	Local nOpca     := 0
	Local oFont		:= Nil
	Local aDBF		:= {}
	Local cAliasST9	:= GetNextAlias()

	Private aCposMrk

	//+------------------------------------------------------------------------------+
	//| lAbriu = .F. : Indica que o usuário não confirmou a tela do filtro de bens.  |
	//| lAbriu = .T. : Indica que o usuário confirmou a tela de filtro de bens.      |
	//+------------------------------------------------------------------------------+
	If M->TI_ESTRUTU == "S"
		MsgStop(STR0115)    //"Opção indisponível quando campo Estrutura estiver igual a 'Sim'."
		Return .F.
	EndIf

	If !lAbriu
		//Campos para o arquivo temporário
		aDBF := {{"OK"    ,"C", 02, 0},;
		{"CODBEM","C", 16, 0},;
		{"NOME"  ,"C", 40, 0}}

		If Type("oTmpTbl7") == "O"
			//Deleta Tabela de Criação do Plano
			oTmpTbl7:Delete()
		EndIf

		//Intancia classe FWTemporaryTable
		oTmpTbl7 := FWTemporaryTable():New( cAliasTRB1, aDBF )
		//Adiciona os Indices
		oTmpTbl7:AddIndex( "Ind01" , {"CODBEM","OK"} )
		//Cria a tabela temporaria
		oTmpTbl7:Create()

		//Busca os dados dos bens em questão

		BeginSQL Alias cAliasST9
			SELECT ST9.T9_CODBEM, ST9.T9_NOME
				FROM %table:ST9% ST9
			INNER JOIN %table:STF% STF
				ON STF.TF_CODBEM = ST9.T9_CODBEM
			WHERE ST9.T9_FILIAL = %xFilial:ST9%
				AND STF.TF_FILIAL = %xFilial:STF%
				AND ( ST9.T9_SITMAN <> %exp:'I'% OR ST9.T9_SITBEM  <> %exp:'I'% )
				AND ST9.T9_CCUSTO  BETWEEN %exp:M->TI_CCUSINI% AND %exp:M->TI_CCUSFIM%
				AND ST9.T9_CENTRAB BETWEEN %exp:M->TI_CTRAINI% AND %exp:M->TI_CTRAFIM%
				AND ST9.T9_CODFAMI BETWEEN %exp:M->TI_FAMIINI% AND %exp:M->TI_FAMIFIM%
				AND ST9.T9_CODBEM  BETWEEN %exp:M->TI_BEMINI%  AND %exp:M->TI_BEMFIM%
				AND ST9.T9_TIPMOD  BETWEEN %exp:M->TI_TIPMODI% AND %exp:M->TI_TIPMODF%
				AND STF.TF_SERVICO BETWEEN %exp:M->TI_SERVINI% AND %exp:M->TI_SERVFIM%
				AND STF.TF_CODAREA BETWEEN %exp:M->TI_AREAINI% AND %exp:M->TI_AREAFIM%
				AND STF.TF_TIPO    BETWEEN %exp:M->TI_TIPOINI% AND %exp:M->TI_TIPOFIM%
				AND ST9.%notDel%
				AND STF.%notDel%
				GROUP BY ST9.T9_CODBEM, ST9.T9_NOME
				ORDER BY ST9.T9_CODBEM
		EndSQL

		// Adiciona os bens no arquivo temporário.
		dbSelectArea( cAliasST9 )
		DbGoTop( cAliasST9 )
		While ( cAliasST9 )->( !EoF() )

			RecLock( cAliasTRB1, .T. )
			( cAliasTRB1 )-> OK     := cMarca
			( cAliasTRB1 )-> CODBEM := ( cAliasST9 )->T9_CODBEM
			( cAliasTRB1 )-> NOME   := ( cAliasST9 )->T9_NOME

			MsUnLock( cAliasTRB1 )
			dbSelectArea( cAliasST9 )
			dbSkip()

		EndDo

		( cAliasST9 )->( dbCloseArea() )

	EndIf

	//Verifica se o usuário está acessando a tela de filtro pela primeira vez,
	//se for a primeira vez, preenche o arquivo temporário e realiza o filtro e cadastra na
	//cAliasTRB1 os itens marcados..

	Define FONT oFont NAME "Arial" Size 07,17
	Define msDialog oDlg Title STR0110 From 000,000 To 489,888 Pixel // "Bens Filtrados."

	oGRHNPNL := TPanel():New(0,0,,oDlg,,.T.,,,,0,0,.T.,.F.)
	oGRHNPNL:Align := CONTROL_ALIGN_ALLCLIENT

	@ 010,002 Say STR0111 Font oFont Size 55,10 Of oGRHNPNL Pixel    // "Lista de bens filtrados."
	@ 025,002 Say STR0112 Of oGRHNPNL Pixel                          // "Clique duas vezes sobre um bem para marcar/desmarcar o mesmo."

	// Campos para o MarkBrowse.
	aCposMrk := {{"OK"    , Nil, " "          },;
	{"CODBEM", Nil, "Cód. Bem"   },;
	{"NOME"  , Nil, "Nome do Bem"}}

	oMark := MsSelect():New( cAliasTRB1, "OK",, aCposMrk, @lInverte, @cMarca, {035,000,216,446},,, oGRHNPNL )
	oMark:oBrowse:lHasMark		:= .T.
	oMark:oBrowse:lCanAllMark	:= .T.
	oMark:oBrowse:bAllMark		:= {|| M330MarkAll()}
	oMark:oBrowse:Refresh()

	dbSelectArea( cAliasTRB1 )
	dbGoTop()

	Activate MsDialog oDlg ON INIT EnchoiceBar( oDlg,{|| ( nOpca := 1, lAbriu := .T. ),oDlg:End() },;
	{ || ( nOpca := 0, lAbriu := .F. ), oDlg:End() } ) Center

	If nOpca == 1
		lFiltBem := .T.
		dbSelectArea( cAliasTRB1 )
		dbGoTop()
		While !EoF()
			If ( cAliasTRB1 )->OK == Space( 2 )    // Se o bem não estiver marcado passa para o próximo registro.
				dbSelectArea( cAliasTRB1 )
				dbSkip()
				Loop
			EndIf
			aAdd(aBensTrb,( cAliasTRB1 )->CODBEM ) // Adiciona os bens marcados no array aBensTrb.
			dbSelectArea( cAliasTRB1 )
			dbSkip()
		End While

		//+-----------------------------------------------------------+
		//| fBEMINIFIM: Carrega para os campos TI_BEMINI E TI_BEMFIM  |
		//| o primeiro e último bem marcado na tela de seleção.       |
		//+-----------------------------------------------------------+
		fBEMINIFIM()

	Else
		lFiltBem := .F.
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT330WHEN
Altera o conteúdo X3_WHEN do campo TI_BEMINI ou TI_BEMINI, se o filtro
de bens foi confirmado.

@param cField : Nome do campo.

@author Pablo Servin
@since 24/02/2014
@version MP11
@return lRet
/*/
//----------------------------------------------------------------------
Function MNT330WHEN( cField )

	Local lRet

	Do Case
		Case cField == "TI_BEMINI" .Or. cField == "TI_BEMFIM"
		lRet := !lFiltBem
		OtherWise
		lRet := .F.
	End Case

Return lRet
//----------------------------------------------------------------------
/*/{Protheus.doc} M330MarkAll
Marca/Desmarca todos os registros da tela do MarkBrowse

@author Pablo Servin
@since 24/02/2014
@version MP11
@return Nil
/*/
//----------------------------------------------------------------------
Static Function M330MarkAll()

	NGSETIFARQUI( cAliasTRB1 )
	While !Eof()
		RecLock( cAliasTRB1, .F. )
		( cAliasTRB1 )->OK := IIf( IsMark( 'OK' , cMarca ), "  " , cMarca )
		MsUnLock( cAliasTRB1 )
		dbSkip()
	End While
	NGSETIFARQUI( cAliasTRB1 )

Return Nil

//----------------------------------------------------------------------
/*/{Protheus.doc} fBEMINIFIM
Carrega o primeiro e último registro marcado na cTRB e carrega nos campos
M->TI_BEMINI ou M->BEMFIM

@author Pablo Servin
@since 25/04/2014
@version MP11
@return .T.
/*/
//----------------------------------------------------------------------
Static Function fBEMINIFIM()

	// Procura o primeiro registro da cAliasTRB1 marcado.
	dbSelectArea( cAliasTRB1 )
	dbGoTop()
	While !EoF()
		If ( cAliasTRB1 )->OK <> Space( 2 )
			M->TI_BEMINI := ( cAliasTRB1 )->CODBEM
			Exit
		EndIf
		dbSelectArea( cAliasTRB1 )
		dbSkip()
	End While

	// Procura o último registro da cAliasTRB1 marcado.
	dbSelectArea( cAliasTRB1 )
	dbGoBottom()
	While !BoF()
		If ( cAliasTRB1 )->OK <> Space( 2 )
			M->TI_BEMFIM := ( cAliasTRB1 )->CODBEM
			Exit
		EndIf
		dbSelectArea( cAliasTRB1 )
		dbSkip( -1 )
	End While

Return .T.

//----------------------------------------------------------------------
/*/{Protheus.doc} f330BensStc
Carrega todos os bens da estrutura para cada bem selecionado no plano

@author Tainã Alberto Cardoso
@since 07/12/2015
@version MP11
@return .T.
/*/
//----------------------------------------------------------------------
Static Function f330BensStc(cBemIni,cBemFim)

	Local aBensStc := {}, aArrayBem := {}
	Local nX := 0

	//Busca todos os bens da ST9
	dbSelectArea("ST9")
	dbSetOrder(1)
	If dbSeek( xFilial("ST9") + cBemIni )

		While !Eof() .And. ST9->T9_FILIAL == xFilial("ST9") .And. ST9->T9_CODBEM >= cBemIni .And. ST9->T9_CODBEM <= cBemFim

			aArrayBem := NGCOMPEST(ST9->T9_CODBEM,'B',.T.,.F.)

			For nX := 1 to Len(aArrayBem)

				If aScan(aBensStc,{ |x| AllTrim( x ) == AllTrim( aArrayBem[nX] ) }) == 0
					aAdd(aBensStc,aArrayBem[nX])
				EndIf

			Next nX

			dbSelectArea("ST9")
			dbSkip()

		End

	EndIf

Return aBensStc

//------------------------------------------------------------------------------
/*/{Protheus.doc} fGetDepend
Procura dependências de uma tarefa especificada por parâmetro.
@type function

@author Alexandre Santos
@since  25/07/2022

@param cCodBem, string, Código do Bem
@param cServic, string, Código do Serviço
@param cSeqRel, string, Sequência da Manutenção
@param cTarGen, string, Tarefa utilizada como dependência de outras tarefas.
@param aDepend, array , Tarefas dependentes da tarefa pesquisada.
@param aTarGe , array , Lista com todas as tarefas e suas dependecias.

@return 
/*/
//------------------------------------------------------------------------------
Static Function fGetDepend( cCodBem, cServic, cSeqRel, cTarGen, aDepend, aTarGe )

	Local cAlsSTM := GetNextAlias()
	
	BeginSQL ALIAS cAlsSTM

		SELECT
			STM.R_E_C_N_O_
		FROM
			%table:STM% STM
		WHERE
			STM.TM_FILIAL  = %xFilial:STM% AND
			STM.TM_CODBEM  = %exp:cCodBem% AND
			STM.TM_SERVICO = %exp:cServic% AND
			STM.TM_SEQRELA = %exp:cSeqRel% AND
			STM.TM_TAREFA  = %exp:cTarGen% AND
			STM.%NotDel%

	EndSQL

	While (cAlsSTM)->( !Eof() )

		dbSelectArea( 'STM' )
		dbGoTo( (cAlsSTM)->R_E_C_N_O_ )

		aAdd( aDepend, STM->TM_DEPENDE )
		aAdd( aTarGe , { STM->TM_DEPENDE, STM->TM_SOBREPO } )

		(cAlsSTM)->( dbSkip() )

	End

	(cAlsSTM)->( dbCloseArea() )
	
Return
