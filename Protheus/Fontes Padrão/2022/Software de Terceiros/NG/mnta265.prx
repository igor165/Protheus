#INCLUDE "mnta265.ch"
#INCLUDE "PROTHEUS.CH"

Static cFiltSTJ := ''

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MNTA265  ³ Autor ³ Elisangela Costa      ³ Data ³28/05/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de alteracao das OS dos planos de manutencao      ³±±
±±³          ³ que estejam P/N ou L/N e que nao tenham insumos realizados ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTA265()

	Local cFields     := ''
	Local cFldMemo    := ''
	Local nIndex      := 0
	Local j           := 0
	Local aSize       := {}
	Local aObjects    := {}
	Local aNGBeginPrm := {}
	Local aInfo       := {}
	Local aPosObj     := {}
	Local aGrid       := {}
	Local oTmpTbl2
	Local oTmpTbl3
	Local oTmpTbl4
	Local oTmpTbl5
	Local oPnlPai
	Local oPnlBtn
	Local oPnlGrid
	Local oPnlLeg
	Local oMenu
	Local oDlg

	If ( !FindFunction( 'MNTAmIIn' ) .Or. MNTAmIIn( 19, 95 ) ) .And. fVersion()

		aNGBeginPrm := NGBeginPrm()

		Private aDBFTRBA  := {}
		Private aArEmPr   := {}
		Private aButtons  := {}
		Private cCadastro := OemtoAnsi(STR0001)  //"Alteração de OS"
		Private cFieldQry := ''
		Private oTmpTbl1  

		// Variáveis de controle de contador
		Private TIPOACOM  := .F.
		Private TIPOACOM2 := .F.

		// CRIADA aRotina somente para fins de utilizacao no getdados dos insumos
		Private aRotina := {{STR0002  , "AxPesqui" ,  0 , 1},;   //"Pesquisar"
		{ STR0003 , "NGCAD01" ,  0 , 2},;   //"Visual."
		{ STR0004 , "NGCAD01" ,  0 , 3},;   //"Incluir"
		{ STR0005 , "NGCAD01" ,  0 , 4,0},;  //"Alterar"
		{ STR0006 , "NGCAD01" ,  0 , 5,0},;  //"Excluir"
		{ STR0007 , "NGCAD01" ,  0 , 6,0}}   //"Imprimir"

		Private aTrocaF3  := {}
		Private cPrograma := "MNTA265"
		Private lRETORNO  := .F.
		Private lFILBRW   := .F.
		Private lAblo     := .F.
		Private lPREVIS   := .T. // UTILIZADO NA FUNCAO NGCALDTHO
		Private aVETINR   := {}
		Private cTRBX,cInd1TRBX
		Private cARQUISAI := "XXX", cTIPOSS
		Private oNG265OSSP := LoadBitmap( GetResources(),"BR_VERDE" )
		Private oNG265OSCP := LoadBitmap( GetResources(),"BR_VERMELHO")
		Private oTmpTbl6   := Nil
		Private aCores := {{"!Empty((cTRBA490)->TJ_PROBLEM)", 'BR_VERMELHO' },;
		{"Empty((cTRBA490)->TJ_PROBLEM)" , 'BR_VERDE'}}
		Private lUSATARG  := If(FindFunction("NGUSATARPAD"),NGUSATARPAD(),.f.)
		Private lSEQTAR   := NGCADICBASE("TL_SEQTARE","A","STL",.F.)
		Private asMenu, aHeaIns:={}, aGetIns:={}
		Private aAltIns := {}
		Private aBlo    := {{},{},{},{},{}}
		Private aBkpHead := {}
		Private ABEFCOLS := {}
		Private AAFTCOLS := {}
		Private cTRBL490 := GetNextAlias() //Alias oTmpTbl1
		Private cTRBC490 := GetNextAlias() //Alias oTmpTbl2
		Private cTRBA490 := GetNextAlias() //Alias oTmpTbl3
		Private cTRBP490 := GetNextAlias() //Alias oTmpTbl4
		Private cTRBQ490 := GetNextAlias() //Alias oTmpTbl5
		Private cTRBX490 := GetNextAlias() //Alias oTmpTbl6
		Private cTRBF    := GetNextAlias()
		Private cTRBS    := GetNextAlias()
		Private cTRBEixo := GetNextAlias()

		//Definicao de tamanho de tela e objetos
		aSize := MsAdvSize(,.f.,430)
		Aadd(aObjects,{025,025,.t.,.t.})
		Aadd(aObjects,{075,075,.t.,.t.})
		aInfo := {aSize[1],aSize[2],aSize[3],aSize[4],0,0}
		aPosObj := MsObjSize(aInfo, aObjects,.t.)

		//Variavel utilizada na função NGGERCOTAC do NGUTIL02, chamada na função MNTA490EXC.
		Private fAltera	:= .F.

		//Inicialização variáveis AEN
		If ExistBlock("MNTA420T")
			Private aLinhaProd := {}
			ExecBlock("MNTA420T", .F., .F.)
		EndIf

		//If (NGCADICBASE("TQC_PROGRA","D","TQC",.F.) .And. NGCADICBASE("TQD_PROGRA","D","TQD",.F.))
		asMenu := NGRIGHTCLICK("MNTA265")
		//EndIf

		Aadd(aButtons, {"PARAMETROS" ,{|| MNTA265FIL()},"Filtro"})

		Store Space(8) To cTRBX,cInd1TRBX

		lCORRET := .T.
		aSTLMOD := {}

		cUsaIntAL := AllTrim(GETMV("MV_NGALCAD"))
		cUsaIntPc := AllTrim(GETMV("MV_NGMNTPC"))
		cUsaIntCm := AllTrim(GETMV("MV_NGMNTCM"))
		cUsaIntEs := AllTrim(GETMV("MV_NGMNTES"))

		INCLUI  := .F.
		//|--------------------------------------------------------------|
		//| Variaveis utilizadas para parametros                         |
		//| mv_par01     // De Plano                                     |
		//| mv_par02     // Ate Plano                                    |
		//| mv_par03     // De Centro Custo                              |
		//| mv_par04     // Ate Centro Custo                             |
		//| mv_par05     // De Familia                                   |
		//| mv_par06     // Ate Familia                                  |
		//| mv_par07     // De Bem                                       |
		//| mv_par08     // Ate Bem                                      |
		//| mv_par09     // De Localizacao                               |
		//| mv_par10     // Ate Localizacao                              |
		//| mv_par11     // De Servico                                   |
		//| mv_par12     // Ate Servico                                  |
		//| mv_par13     // De Sequencia                                 |
		//| mv_par14     // Ate Sequencia                                |
		//| mv_par15     // De Data                                      |
		//| mv_par16     // Ate Data                                     |
		//| mv_par17     // Considera Bem/Localiz. (1=Bem,2=Localizacao) |
		//|--------------------------------------------------------------|

		If !Pergunte("MNT265",.T.)
			Return .T.
		EndIf

		dbSelectArea("STL")
		lSEQREL := NgVerify("STL")

		aDBFL := STL->(DbStruct())
		aAdd( aDBFL, { 'PROBMAOBR', "C", 1 , 0 } )
		aAdd( aDBFL, { 'RECNO'    , 'N', 12, 0 } )
		aAdd( aDBFL, { 'STATUS'   , 'N', 01, 0 } )

		//Intancia classe FWTemporaryTable
		oTmpTbl1:= FWTemporaryTable():New( cTRBL490, aDBFL )

		If lUSATARG .And. lSEQTAR
			If lSEQREL
				oTmpTbl1:AddIndex( "Ind01" , {"TL_ORDEM","TL_PLANO","TL_SEQRELA","TL_TIPOREG","TL_CODIGO","TL_TAREFA","TL_SEQTARE"} )
			Else
				oTmpTbl1:AddIndex( "Ind01" , {"TL_ORDEM","TL_PLANO","TL_SEQUENC","TL_TIPOREG","TL_CODIGO","TL_TAREFA","TL_SEQTARE"} )
			EndIf
		Else
			If lSEQREL
				oTmpTbl1:AddIndex( "Ind01" , {"TL_ORDEM","TL_PLANO","TL_SEQRELA","TL_TIPOREG","TL_CODIGO"} )
			Else
				oTmpTbl1:AddIndex( "Ind01" , {"TL_ORDEM","TL_PLANO","TL_SEQUENC","TL_TIPOREG","TL_CODIGO"} )
			EndIf
		EndIf

		oTmpTbl1:AddIndex( '02' , { 'STATUS', 'TL_ORDEM', 'TL_PLANO' } )

		//Cria a tabela temporaria
		oTmpTbl1:Create()

		/*------------------------------------------------------------------------------------------+
		| Gera ordenção dos campos selecionado na query utilizada para montagem do grid de insumos. |
		+------------------------------------------------------------------------------------------*/
		For nIndex := 1 To Len( aDBFL )
				
			If aDBFL[nIndex,2] != 'M' 
				
				cFields  += IIf( Empty( cFields ), aDBFL[nIndex,1], ',' + aDBFL[nIndex,1] )
				
			Else

				cFldMemo += ',' + aDBFL[nIndex,1]

			EndIf
			
		Next nIndex

		/*-----------------------------------------------------------------------+
		| Campos do tipo MEMO devem ser os ultimos campos selecionados na query. |
		+-----------------------------------------------------------------------*/
		cFieldQry := '%' + cFields + cFldMemo + '%'

		aDBFC := {}
		Aadd(aDBFC,{"TL_TIPOREG" , "C", 1,0})
		Aadd(aDBFC,{"TL_NOMTIP"  , "C", 13,0})
		Aadd(aDBFC,{"TL_TAREFA"  , "C", 06,0})
		Aadd(aDBFC,{"TL_CODIGO"  , "C", Len(stl->tl_codigo),0})
		Aadd(aDBFC,{"TL_NOME"    , "C", 30,0})
		If lSEQREL
			Aadd(aDBFC,{"TL_SEQRELA" , "C", 03,0})
		Else
			Aadd(aDBFC,{"TL_SEQUENC" , "N", 02,0})
		Endif
		Aadd(aDBFC,{"TL_QUANTID" , "N", 09,2})
		Aadd(aDBFC,{"TL_UNIDADE" , "C", 03,0})
		Aadd(aDBFC,{"TL_DTINICI" , "D", 08,0})
		Aadd(aDBFC,{"TL_DTFIM"   , "D", 08,0})
		Aadd(aDBFC,{"TL_CUSTO"   , "N", 12,2})
		aAdd(aDBFC,{"TL_DESTINO" , "C", 1,0})
		aAdd(aDBFC,{"TL_LOCAL"   , "C", 2,0})
		aAdd(aDBFC,{"TL_SEQTARE" , "C", 3,0})

		//Intancia classe FWTemporaryTable
		oTmpTbl2:= FWTemporaryTable():New( cTRBC490, aDBFC )
		//Adiciona os Indices
		oTmpTbl2:AddIndex( "Ind01" , {"TL_NOMTIP","TL_CODIGO"} )
		//Cria a tabela temporaria
		oTmpTbl2:Create()

		lInverte := .f.
		cMARCA   := GetMark()
		lQuery   := .t.

		aDBF := {}
		Aadd(aDBF,{"TJ_OK"      , "C", 02,0})
		Aadd(aDBF,{"TJ_ORDEM"   , "C", 06,0})
		Aadd(aDBF,{"TJ_PLANO"   , "C", 06,0})
		Aadd(aDBF,{"TJ_CODBEM"  , "C", 16,0})
		Aadd(aDBF,{"TJ_NOMBEM"  , "C", 30,0})
		Aadd(aDBF,{"TJ_SERVICO" , "C", 06,0})
		Aadd(aDBF,{"TJ_NOMSERV" , "C", 30,0})
		Aadd(aDBF,{"TJ_DTORIGI" , "D", 08,0})
		Aadd(aDBF,{"TJ_TIPO"    , "C", 03,0})
		Aadd(aDBF,{"TJ_NOMTIPO" , "C", 20,0})
		Aadd(aDBF,{"TJ_CODAREA" , "C", 06,0})
		Aadd(aDBF,{"TJ_NOMAREA" , "C", 20,0})
		Aadd(aDBF,{"TJ_CCUSTO"  , "C", Len(STJ->TJ_CCUSTO),0})
		Aadd(aDBF,{"TJ_NOMCUST" , "C", 20,0})
		Aadd(aDBF,{"TJ_DTPPINI" , "D", 08,0})
		Aadd(aDBF,{"TJ_HOPPINI" , "C", 05,0})
		Aadd(aDBF,{"TJ_DTPPFIM" , "D", 08,0})
		Aadd(aDBF,{"TJ_HOPPFIM" , "C", 05,0})
		Aadd(aDBF,{"TJ_DTMPINI" , "D", 08,0})
		Aadd(aDBF,{"TJ_HOMPINI" , "C", 05,0})
		Aadd(aDBF,{"TJ_DTMPFIM" , "D", 08,0})
		Aadd(aDBF,{"TJ_HOMPFIM" , "C", 05,0})
		Aadd(aDBF,{"TJ_USUARIO" , "C", Len(STJ->TJ_USUARIO),0})
		Aadd(aDBF,{"TJ_PRIORID" , "C", 03,0})
		Aadd(aDBF,{"TJ_ACESSO"  , "C", 01,0})
		Aadd(aDBF,{"TJ_ETAPA"   , "C", 01,0})
		Aadd(aDBF,{"TJ_DATANOV" , "D", 08,0})
		Aadd(aDBF,{"TJ_OBSERVA" , "M", 10,0})
		Aadd(aDBF,{"TJ_PROBLEM" , "C", 01,0})
		aAdd(aDBF,{"TJ_CENTRAB" , "C", 06,0})
		aAdd(aDBF,{"TJ_NOMTRAB" , "C", 30,0})
		aAdd( aDBF, { 'TJ_POSCONT', 'N', 09, 0 } )
		aAdd( aDBF, { 'TJ_POSCON2', 'N', 09, 0 } )
		aAdd( aDBF, { 'TJ_HORACO1', 'C', 05, 0 } )
		aAdd( aDBF, { 'TJ_HORACO2', 'C', 05, 0 } )

		aAdd( aGrid, { 'TJ_OK'     , Nil, ' '    , Nil } )
		aAdd( aGrid, { 'TJ_PLANO'  , Nil, STR0078, Nil } )  
		aAdd( aGrid, { 'TJ_ORDEM'  , Nil, STR0023, Nil } )  
		aAdd( aGrid, { 'TJ_CODBEM' , Nil, STR0024, Nil } )  
		aAdd( aGrid, { 'TJ_NOMBEM' , Nil, STR0025, Nil } )  
		aAdd( aGrid, { 'TJ_SERVICO', Nil, STR0026, Nil } ) 
		aAdd( aGrid, { 'TJ_NOMSERV', Nil, STR0027, Nil } )  
		aAdd( aGrid, { 'TJ_DTORIGI', Nil, STR0028, Nil } ) 
		aAdd( aGrid, { 'TJ_TIPO'   , Nil, STR0029, Nil } )  
		aAdd( aGrid, { 'TJ_NOMTIPO', Nil, STR0030, Nil } )  
		aAdd( aGrid, { 'TJ_CODAREA', Nil, STR0031, Nil } )  
		aAdd( aGrid, { 'TJ_NOMAREA', Nil, STR0032, Nil } ) 
		aAdd( aGrid, { 'TJ_CCUSTO' , Nil, STR0033, Nil } )  
		aAdd( aGrid, { 'TJ_NOMCUST', Nil, STR0034, Nil } )  
		aAdd( aGrid, { 'TJ_DTMPINI', Nil, STR0035, Nil } )  
		aAdd( aGrid, { 'TJ_DTMPFIM', Nil, STR0036, Nil } )  
		aAdd( aGrid, { 'TJ_USUARIO', Nil, STR0037, Nil } ) 
		aAdd( aGrid, { 'TJ_PRIORID', Nil, STR0038, Nil } )  

		If ExistBlock("MNTA2651")
			aDBFTRBA := ExecBlock("MNTA2651",.F.,.F.)
			
			If ValType(aDBFTRBA) == "A"
				
				For j := 1 To Len(aDBFTRBA)
					
					Aadd(aDBF,{aDBFTRBA[j][1], aDBFTRBA[j][2], aDBFTRBA[j][3], aDBFTRBA[j][4]})

					aAdd( aGrid, { aDBFTRBA[j,1], Nil, FWX3Titulo( aDBFTRBA[j,1] ), Nil } )

				Next j

			EndIf

		EndIf

		//Intancia classe FWTemporaryTable
		oTmpTbl3:= FWTemporaryTable():New( cTRBA490, aDBF )
		//Adiciona os Indices
		oTmpTbl3:AddIndex( "Ind01" , {"TJ_PLANO","TJ_ORDEM"} )
		//Cria a tabela temporaria
		oTmpTbl3:Create()

		aDBFRTJ := {{"ORDEM"  ,"C",06, 0 },;
		{"PLANO"   ,"C",06, 0 },;
		{"DTMPINI" ,"D",08, 0 },;
		{"DATANOV" ,"D",08, 0 }}

		//Intancia classe FWTemporaryTable
		oTmpTbl4:= FWTemporaryTable():New( cTRBP490, aDBFRTJ )
		//Adiciona os Indices
		oTmpTbl4:AddIndex( "Ind01" , {"PLANO","ORDEM"} )
		//Cria a tabela temporaria
		oTmpTbl4:Create()

		dbSelectArea("STQ")
		aDBFQ      := STQ->(DbStruct())

		//Intancia classe FWTemporaryTable
		oTmpTbl5:= FWTemporaryTable():New( cTRBQ490, aDBFQ )
		//Adiciona os Indices
		oTmpTbl5:AddIndex( "Ind01" , {"TQ_ORDEM","TQ_PLANO","TQ_TAREFA","TQ_ETAPA"} )
		//Cria a tabela temporaria
		oTmpTbl5:Create()

		Processa({ |lEnd| MNTA265OS() }, STR0039) //"Aguarde ..Processanto Arquivo de O.S."

		dbSelectArea(cTRBA490)
		dbGotop()
		If Reccount() = 0
			MsgStop(STR0040,STR0041) //"Nao existem ordens de serviço para serem alteradas."###"ATENÇÃO"
			//Deleta o arquivo temporario fisicamente
			oTmpTbl1:Delete()
			oTmpTbl2:Delete()
			oTmpTbl3:Delete()
			oTmpTbl4:Delete()
			oTmpTbl5:Delete()
			dbSelectArea("STJ")
			dbSetOrder(01)
			Return .T.
		EndIf

		MNTCTemp() // Cria as tabelas temporárias

		cCadastro := OemtoAnsi(STR0042) //"Alteração de OS"

		nOp265 := 0
		Define MsDialog oDLG Title cCadastro From aSize[7],0 To aSize[6],aSize[5] Of oMainWnd PIXEL
		oDlg:lMaximized := .T.

		oPnlPai := TPanel():New(,,,oDLG)
		oPnlPai:Align := CONTROL_ALIGN_ALLCLIENT

		oPnlBtn := TPanel():New(,,,oPnlPai,,,,,,aSize[1],aSize[2],.F.,.F.)
		oPnlBtn:Align := CONTROL_ALIGN_TOP

		@ aSize[8]*2,001 Button STR0043 Size 38,12 Pixel Action MNTA490VIS(cTRBA490) Of oPnlBtn  //"Visualizar"
		@ aSize[8]*2,046 Button STR0080 Size 38,12 Pixel Action MNTA490EXC(cTRBA490) Of oPnlBtn  //"Cancelar"
		@ aSize[8]*2,091 Button STR0045 Size 50,12 Pixel Action MNTA490CUS(cTRBA490,cTRBC490,cTRBL490) Of oPnlBtn  //"Custo Previsto"
		@ aSize[8]*2,148 Button STR0046 Size 38,12 Pixel Action MNTA490INS( .T., cTRBA490, oTmpTbl1, cTRBQ490, 'MNTA265' ) Of oPnlBtn //&Insumos
		@ aSize[8]*2,193 Button STR0047 Size 38,12 Pixel Action MNTA490ETA() Of oPnlBtn  //"Etapas"
		@ aSize[8]*2,238 Button STR0048 Size 38,12 Pixel Action MNTA490MOD(cTRBA490,cTRBL490) Of oPnlBtn  //"Mod. Insumos"
		@ aSize[8]*2,283 Button STR0049 Size 38,12 Pixel Action MNTA490MEP(cTRBA490,cTRBQ490) Of oPnlBtn  //"Mod. Etapas"
		@ aSize[8]*2,328 Button STR0050 Size 38,12 Pixel Action MNT490ATOS(.T.,cTRBA490,aDBFTRBA) Of oPnlBtn  //"Altera O.S."
		@ aSize[8]*2,373 Button STR0051 Size 38,12 Pixel Action MNT265IMP() Of oPnlBtn   //"Imprimir"
		@ aSize[8]*2,418 Button STR0052 Size 38,12 Pixel Action MNT265PROB((cTRBA490)->TJ_ORDEM,(cTRBA490)->TJ_PLANO) Of oPnlBtn   //"Problemas"

		oPnlGrid := TPanel():New(,,,oPnlPai,,,,,,aSize[1],aSize[2],.F.,.F.)
		oPnlGrid:Align := CONTROL_ALIGN_ALLCLIENT

		oMark := MsSelect():New((cTRBA490),"TJ_OK",, aGrid, @lInverte,@cMarca,{ aSize[1], aSize[1], aSize[4]-aSize[2]*3, aSize[3]},,,oPnlGrid,,aCores)
		oMark:bMark := {|| MNTA490MAQ(cTRBA490,cTRBL490,cTRBQ490)} //
		oMark:oBrowse:lhasMark    := .t.
		oMark:oBrowse:lCanAllmark := .t.
		oMark:oBrowse:bAllMark    := { || MNTA490INV(cMarca) }

		oPnlLeg := TPanel():New(,,,oPnlPai,,,,,,aSize[1],aSize[2],.F.,.F.)
		oPnlLeg:Align := CONTROL_ALIGN_BOTTOM

		@ aSize[8]*2,213 Bitmap oNG265OSSP Resource "BR_VERDE" Size 25,25 Pixel Of oPnlLeg Noborder When .F. Of oPnlLeg
		@ aSize[8]*2,237 Say OemToAnsi(STR0071) Size 47,7 Pixel Of oPnlLeg  //"OS sem problema"
		@ aSize[8]*2,348 Bitmap oNG265OSCP Resource "BR_VERMELHO" Size 25,25 Pixel Of oPnlLeg Noborder When .F. Of oPnlLeg
		@ aSize[8]*2,362 Say OemToAnsi(STR0072) Size 47,7 Pixel Of oPnlLeg  //"OS com problema"

		NGPOPUP(asMenu,@oMenu,oDLG)
		oDLG:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDLG)}
		Activate MsDialog oDLG On Init EnchoiceBar(oDLG,{||nOp265:=1,oDLG:End()},{|| nOp265:=2,oDLG:End()},,aButtons) CENTERED

		If nOp265 == 1
			Processa({ |lEnd| MNTA265ALT() }, STR0053) //"Aguarde... Alterando Ordens de Serviço..."
		EndIf

		//Deleta o arquivo temporario fisicamente
		oTmpTbl1:Delete()
		oTmpTbl2:Delete()
		oTmpTbl3:Delete()
		oTmpTbl4:Delete()
		oTmpTbl5:Delete()

		MNTDTemp() // Deleta as tabelas temporárias relacionadas a contador

		dbSelectArea("ST9")
		dbSetOrder(1)

		NGRETURNPRM( aNGBeginPrm )

	EndIf

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MNTA265OS ³ Autor ³Elisangela Costa       ³ Data ³29/05/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Filtra as O.S. conforme parametros                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA265                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTA265OS()

	Local cAlsSTJ  := GetNextAlias()
	Local cFields  := '%'
	Local cWhere   := '%'
	Local cJoin    := '%'
	Local lMNT2651 := ExistBlock( 'MNTA2651' ) .And. !Empty( aDBFTRBA )
	Local nInd     := 0

	//Ordena parametros para impressao do relatorio
	If MV_PAR09 > MV_PAR10
		cTempPar  := MV_PAR09
		MV_PAR09 := MV_PAR10
		MV_PAR10 := cTempPar
	EndIf

	If MV_PAR17 == 1
		
		cWhere  += " AND STJ.TJ_TIPOOS = 'B' "
		cWhere  += " AND STJ.TJ_CODBEM BETWEEN " + ValToSQL( MV_PAR07 ) + " AND " + ValToSQL( MV_PAR08 )

		cFields +=	", SUBSTRING( ST9.T9_NOME, 1, 30 ) AS TJ_NOMBEM "

		cJoin   += " INNER JOIN " + RetSQLName( 'ST9' ) + " ST9 ON "
		cJoin   += 	"ST9.T9_FILIAL = " + ValToSQL( xFilial( 'ST9' ) ) + " AND "
		cJoin   +=	"ST9.T9_CODBEM = STJ.TJ_CODBEM AND " 
		cJoin   += 	"ST9.T9_CODFAMI BETWEEN " + ValToSQL( MV_PAR05 ) + " AND " + ValToSQL( MV_PAR06 ) + " AND "
		cJoin   +=	"ST9.D_E_L_E_T_ = ' ' "

	EndIf

	If MV_PAR17 == 2
		
		cWhere  += " AND STJ.TJ_TIPOOS = 'L' "
		cWhere  += " AND STJ.TJ_CODBEM BETWEEN " + ValToSQL( MV_PAR09 ) + " AND " + ValToSQL( MV_PAR10 )

		cFields +=	", SUBSTRING( TAF.TAF_NOMNIV, 1, 30 ) AS TJ_NOMBEM "

		cJoin   += " INNER JOIN " + RetSQLName( 'TAF' ) + " TAF ON "
		cJoin   += 	"TAF.TAF_FILIAL = " + ValToSQL( xFilial( 'TAF' ) ) + " AND "
		cJoin   +=	"TAF.TAF_MODMNT = 'X' AND "
		cJoin   +=	"TAF.TAF_INDCON = '2' AND " 
		cJoin   +=	"TAF.TAF_CODNIV = STJ.TJ_CODBEM AND "
		cJoin   += 	"TAF.D_E_L_E_T_ = ' ' "

	EndIf

	If MV_PAR17 == 3

		cWhere  += " AND ( ( STJ.TJ_TIPOOS = 'B' AND STJ.TJ_CODBEM BETWEEN " + ValToSQL( MV_PAR07 ) + " AND " + ValToSQL( MV_PAR08 )
		cWhere  += 		" AND EXISTS (  SELECT "
      	cWhere  +=							"ST9.T9_CODBEM "
  		cWhere  +=						"FROM "
      	cWhere  +=							RetSQLName( 'ST9' ) + " ST9 "
  		cWhere  +=						"WHERE "
      	cWhere  +=							"ST9.T9_CODBEM = STJ.TJ_CODBEM AND "
		cWhere  += 							"ST9.T9_FILIAL = " + ValToSQL( xFilial( 'ST9' ) ) + " AND "
		cWhere  +=  						"ST9.T9_CODFAMI BETWEEN " + ValToSQL( MV_PAR05 ) + " AND " + ValToSQL( MV_PAR06 ) + " AND "
		cWhere  +=   						"ST9.D_E_L_E_T_ = ' ' ) ) "
		cWhere  += 	" OR   ( STJ.TJ_TIPOOS = 'L' AND STJ.TJ_CODBEM BETWEEN " + ValToSQL( MV_PAR09 ) + " AND " + ValToSQL( MV_PAR10 ) + " ) ) "
		

		cFields += ",CASE "
		cFields +=		"WHEN STJ.TJ_TIPOOS = 'B' THEN ( SELECT "
		cFields +=											"SUBSTRING( ST9.T9_NOME, 1, 30 ) "
		cFields +=									  	"FROM "
		cFields +=										 	 RetSQLName( 'ST9' ) + " ST9 "
		cFields +=									  	"WHERE "
		cFields += 											"ST9.T9_FILIAL = " + ValToSQL( xFilial( 'ST9' ) ) + " AND "
		cFields +=											"ST9.T9_CODBEM = STJ.TJ_CODBEM AND " 
		cFields +=											"ST9.D_E_L_E_T_ = ' ' ) "
		cFields += 		"ELSE ( SELECT "
		cFields +=					"SUBSTRING( TAF.TAF_NOMNIV, 1, 30 ) "
		cFields += 			   "FROM "
		cFields +=					 RetSQLName( 'TAF' ) + " TAF "
		cFields +=			   "WHERE "
		cFields += 					"TAF.TAF_FILIAL = " + ValToSQL( xFilial( 'TAF' ) ) + " AND "
		cFields +=					"TAF.TAF_MODMNT = 'X' AND "
		cFields +=					"TAF.TAF_INDCON = '2' AND " 
		cFields +=					"TAF.TAF_CODNIV = STJ.TJ_CODBEM AND "
		cFields += 					"TAF.D_E_L_E_T_ = ' ' ) "
		cFields += "END AS TJ_NOMBEM "

	EndIf

	If lMNT2651
		
		For nInd := 1 To Len( aDBFTRBA )

			cFields += ", STJ." + aDBFTRBA[nInd,1]

		Next nInd
	
	EndIf

	If !Empty( cFiltSTJ )
		cWhere +=  " AND " + cFiltSTJ
	EndIF

	cFields += "%"
	cWhere  += "%"
	cJoin   += "%"

	BeginSQL Alias cAlsSTJ

		SELECT
			STJ.TJ_FILIAL ,
			STJ.TJ_ORDEM  ,
			STJ.TJ_PLANO  ,
			STJ.TJ_CODBEM , 
			STJ.TJ_SERVICO,
			SUBSTRING( ST4.T4_NOME, 1, 30 ) AS T4_NOME,
			STJ.TJ_TIPOOS ,
			STJ.TJ_DTORIGI,
			STJ.TJ_DTMPINI,
			STJ.TJ_HOMPINI,
			STJ.TJ_DTMPFIM,
			STJ.TJ_HOMPFIM,
			STJ.TJ_DTPPINI,
			STJ.TJ_HOPPINI,
			STJ.TJ_DTPPFIM,
			STJ.TJ_HOPPFIM,
			STJ.TJ_TIPO   ,
			STE.TE_NOME   ,
			STJ.TJ_CODAREA,
			STD.TD_NOME   ,
			STJ.TJ_CCUSTO ,
			ISNULL( CTT.CTT_DESC01, ' ' ) AS CTT_DESC01,
			STJ.TJ_CENTRAB,
			ISNULL( SHB.HB_NOME, ' ' ) AS HB_NOME,
			STJ.TJ_USUARIO,
			STJ.TJ_PRIORID,
			STJ.TJ_POSCONT,
			STJ.TJ_POSCON2,
			STJ.TJ_HORACO1,
			STJ.TJ_HORACO2,
			CASE
			WHEN (
					SELECT COUNT(STA.TA_ORDEM) 
					FROM %table:STA% STA 
					WHERE STA.TA_FILIAL = %xFilial:STA%
						AND STA.TA_ORDEM = STJ.TJ_ORDEM
						AND STA.TA_PLANO = STJ.TJ_PLANO
						AND STA.%NotDel%
				
			) > 0 THEN 'X' 
			ELSE ' '
			END AS TJ_PROBLEM
			%exp:cFields%
		FROM
			%table:STJ% STJ
		INNER JOIN	
			%table:STI% STI ON
				STI.TI_FILIAL  = %xFilial:STI%  AND
				STI.TI_PLANO   = STJ.TJ_PLANO   AND
				( STI.TI_PLANO IN ( '000000', '000001' ) OR
					( STI.TI_SITUACA = 'P' OR
					( STI.TI_SITUACA = 'L' AND
				 	  STJ.TJ_SITUACA = 'L' ) ) AND
					STI.TI_TERMINO = 'N' ) AND
				STI.%NotDel%
		LEFT JOIN
			%table:CTT% CTT ON
				CTT.CTT_FILIAL = %xFilial:CTT% AND
				CTT.CTT_CUSTO  = STJ.TJ_CCUSTO AND
				CTT.%NotDel%
		INNER JOIN
			%table:ST4% ST4 ON
				ST4.T4_FILIAL  = %xFilial:ST4%  AND
				ST4.T4_SERVICO = STJ.TJ_SERVICO AND
				ST4.%NotDel%
		INNER JOIN
			%table:STE% STE ON
				STE.TE_FILIAL  = %xFilial:STE%  AND
				STE.TE_TIPOMAN = STJ.TJ_TIPO    AND
				STE.%NotDel%
		INNER JOIN
			%table:STD% STD ON
				STD.TD_FILIAL  = %xFilial:STD%  AND
				STD.TD_CODAREA = STJ.TJ_CODAREA AND
				STD.%NotDel%
		LEFT JOIN
			%table:SHB% SHB ON
				SHB.HB_FILIAL = %xFilial:SHB%  AND
				SHB.HB_COD    = STJ.TJ_CENTRAB AND
				SHB.%NotDel%
		%exp:cJoin%
		WHERE
			STJ.TJ_FILIAL = %xFilial:STJ% AND
			STJ.TJ_PLANO   BETWEEN %exp:MV_PAR01% AND %exp:MV_PAR02% AND
			STJ.TJ_CCUSTO  BETWEEN %exp:MV_PAR03% AND %exp:MV_PAR04% AND
			STJ.TJ_SERVICO BETWEEN %exp:MV_PAR11% AND %exp:MV_PAR12% AND
			STJ.TJ_SEQRELA BETWEEN %exp:MV_PAR13% AND %exp:MV_PAR14% AND
			STJ.TJ_DTMPINI BETWEEN %exp:MV_PAR15% AND %exp:MV_PAR16% AND
			STJ.TJ_ORDEPAI = ' ' AND
			STJ.TJ_TERMINO = 'N' AND
			STJ.TJ_SITUACA IN ( 'P', 'L' ) AND
			STJ.%NotDel%
			%exp:cWhere%

	EndSQL
					
	While (cAlsSTJ)->( !EoF() )
	
		RecLock( cTRBA490, .T. )
			
			(cTRBA490)->TJ_ORDEM   := (cAlsSTJ)->TJ_ORDEM
			(cTRBA490)->TJ_PLANO   := (cAlsSTJ)->TJ_PLANO
			(cTRBA490)->TJ_CODBEM  := (cAlsSTJ)->TJ_CODBEM
			(cTRBA490)->TJ_NOMBEM  := (cAlsSTJ)->TJ_NOMBEM
			(cTRBA490)->TJ_SERVICO := (cAlsSTJ)->TJ_SERVICO
			(cTRBA490)->TJ_NOMSERV := (cAlsSTJ)->T4_NOME
			(cTRBA490)->TJ_DTORIGI := SToD( (cAlsSTJ)->TJ_DTORIGI )
			(cTRBA490)->TJ_DTMPINI := SToD( (cAlsSTJ)->TJ_DTMPINI )
			(cTRBA490)->TJ_HOMPINI := (cAlsSTJ)->TJ_HOMPINI
			(cTRBA490)->TJ_DATANOV := SToD( (cAlsSTJ)->TJ_DTMPINI )
			(cTRBA490)->TJ_DTMPFIM := SToD( (cAlsSTJ)->TJ_DTMPFIM )
			(cTRBA490)->TJ_HOMPFIM := (cAlsSTJ)->TJ_HOMPFIM
			(cTRBA490)->TJ_DTPPINI := SToD( (cAlsSTJ)->TJ_DTPPINI )
			(cTRBA490)->TJ_HOPPINI := (cAlsSTJ)->TJ_HOPPINI
			(cTRBA490)->TJ_DTPPFIM := SToD( (cAlsSTJ)->TJ_DTPPFIM )
			(cTRBA490)->TJ_HOPPFIM := (cAlsSTJ)->TJ_HOPPFIM
			(cTRBA490)->TJ_TIPO    := (cAlsSTJ)->TJ_TIPO
			(cTRBA490)->TJ_NOMTIPO := (cAlsSTJ)->TE_NOME
			(cTRBA490)->TJ_CODAREA := (cAlsSTJ)->TJ_CODAREA
			(cTRBA490)->TJ_NOMAREA := (cAlsSTJ)->TD_NOME
			(cTRBA490)->TJ_CCUSTO  := (cAlsSTJ)->TJ_CCUSTO
			(cTRBA490)->TJ_NOMCUST := (cAlsSTJ)->CTT_DESC01
			(cTRBA490)->TJ_CENTRAB := (cAlsSTJ)->TJ_CENTRAB
			(cTRBA490)->TJ_NOMTRAB := (cAlsSTJ)->HB_NOME
			(cTRBA490)->TJ_USUARIO := (cAlsSTJ)->TJ_USUARIO
			(cTRBA490)->TJ_PRIORID := (cAlsSTJ)->TJ_PRIORID
			(cTRBA490)->TJ_PROBLEM := (cAlsSTJ)->TJ_PROBLEM

			If (cAlsSTJ)->TJ_TIPOOS == 'B'

				(cTRBA490)->TJ_POSCONT := (cAlsSTJ)->TJ_POSCONT
				(cTRBA490)->TJ_HORACO1 := (cAlsSTJ)->TJ_HORACO1

				(cTRBA490)->TJ_POSCON2 := (cAlsSTJ)->TJ_POSCON2
				(cTRBA490)->TJ_HORACO2 := (cAlsSTJ)->TJ_HORACO2

			EndIf

			(cTRBA490)->TJ_OBSERVA := Posicione( 'STJ', 1, (cAlsSTJ)->TJ_FILIAL + (cAlsSTJ)->TJ_ORDEM +;
				(cAlsSTJ)->TJ_PLANO, 'TJ_OBSERVA' )

			If lMNT2651

				For nInd := 1 To Len( aDBFTRBA )

					&( '(cTRBA490)->' + aDBFTRBA[nInd,1] ) := &( '(cAlsSTJ)->' + aDBFTRBA[nInd,1] )

				Next nInd
			
			EndIf

		(cAlsSTJ)->( MsUnLock() )

		(cAlsSTJ)->( dbSkip() )
		
	End

	(cAlsSTJ)->( dbCloseArea() )
			
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} MNTA265ALT
Faz a alteracao dos relacionamentos da O.s (Insumos/Etapas)

@author  Elisangela Costa
@since   29/05/2007
@version P11/P12
/*/
//-------------------------------------------------------------------
Function MNTA265ALT()

	Local j
	Local aAreaPE
	Local lOk       := .T.
	Local lMNTA2652 := ExistBlock("MNTA2652")
	Local lUseIntEs := AllTrim( SuperGetMv( 'MV_NGMNTES', .F., 'N' ) ) == 'S'
	// Define se utiliza produto alternativo
	Local lUsePrAlt := AllTrim( SuperGetMv( 'MV_MNTPRAL', .F., '2' ) ) == '1' .And. FindFunction( 'NGATUSTL' ) .And. AllTrim( SuperGetMv( 'MV_NGGERSA', .F., 'N' ) ) == 'N'

	dbSelectArea(cTRBA490)
	dbGotop()
	ProcRegua(LastRec())

	While (cTRBA490)->( !EoF() )

		IncProc()

		If !Empty((cTRBA490)->TJ_OK)

			BEGIN TRANSACTION

				If !Empty((cTRBA490)->TJ_ACESSO)

					// Deleta e recria o STL apartir do arquivo temporario
					lOk := MNTA265STL()

				Endif

				If lOk

					If !Empty((cTRBA490)->TJ_ETAPA)
						// GRAVA ETAPA
						MNTA490GSQ((cTRBA490)->TJ_ORDEM,(cTRBA490)->TJ_PLANO)
					Endif

					dbSelectArea("STJ")
					dbSetOrder(1)
					If dbSeek(xfilial("STJ")+(cTRBA490)->TJ_ORDEM+(cTRBA490)->TJ_PLANO)

						If STJ->TJ_PLANO <> "000000"
							dPOS := CTOD("")
							hPOS := Space(05)
							MNT490POS(STJ->TJ_CODBEM,STJ->TJ_SERVICO,If(NgVerify("STJ"),STJ->TJ_SEQRELA,STR(STJ->TJ_SEQUENC,3)),;
							STJ->TJ_DTMPFIM,STJ->TJ_HOMPFIM)
						Endif

						dbSelectArea("STJ")
						nRecSTJ := Recno()

						If STJ->TJ_SITUACA == "L"

							lOk := M265OSLIB( (cTRBA490)->TJ_ORDEM, (cTRBA490)->TJ_PLANO, (cTRBA490)->TJ_CODBEM, lUseIntEs, lUsePrAlt )

						ElseIf STJ->TJ_SITUACA == "P" .And. !Empty((cTRBA490)->TJ_ACESSO) .And. (cTRBA490)->TJ_PLANO > "000001"

							M265BLOPLA((cTRBA490)->TJ_ORDEM,(cTRBA490)->TJ_PLANO)

						EndIf

						If lOk

							dbSelectArea("STJ")
							dbSetOrder(01)
							dbGoto(nRecSTJ)
							Reclock("STJ",.F.)
							If NGCADICBASE("TJ_MMSYP","A","STJ",.F.)
								MsMM(,80,,(cTRBA490)->TJ_OBSERVA,1,,,"STJ","TJ_MMSYP")
							Else
								STJ->TJ_OBSERVA := (cTRBA490)->TJ_OBSERVA
							EndIf

							STJ->TJ_DTMPFIM := (cTRBA490)->TJ_DTMPFIM
							STJ->TJ_HOMPFIM := (cTRBA490)->TJ_HOMPFIM

							//Recalcula data de parada prevista fim da manutencao
							If STJ->TJ_PLANO <> "000000"
								dPOS := CTOD("  /  /  ")
								hPOS := Space(05)
								MNT490POS(STJ->TJ_CODBEM,STJ->TJ_SERVICO,If(NgVerify("STJ"),STJ->TJ_SEQRELA,STR(STJ->TJ_SEQUENC,3)),;
								STJ->TJ_DTMPFIM,STJ->TJ_HOMPFIM)
								STJ->TJ_DTPPFIM := dPOS
								STJ->TJ_HOPPFIM := hPOS
							EndIf

							If Len(aDBFTRBA) > 0
								For j := 1 To Len(aDBFTRBA)
									&("STJ->"+aDBFTRBA[j][1]) := &("(cTRBA490)->"+aDBFTRBA[j][1])
								Next j
							EndIf
							
							If (cTRBA490)->TJ_DATANOV <> (cTRBA490)->TJ_DTORIGI .And. STJ->TJ_PLANO == "000000"
								STJ->TJ_DTORIGI := (cTRBA490)->TJ_DATANOV
							EndIf
							
							STJ->(MsUnlock())

							//Ponto de entrada para modificar a STJ
							If lMNTA2652
								aAreaPE := GetArea()
								ExecBlock("MNTA2652",.F.,.F.,{STJ->TJ_ORDEM, STJ->TJ_PLANO})
								RestArea(aAreaPE)
							EndIf

							//Deleta e recria bloqueios de ferrametas e recursos (Bloqueio relacionado ao bem)
							If !Empty((cTRBA490)->TJ_ACESSO)
								M265BLOQBR(STJ->TJ_CODBEM,STJ->TJ_ORDEM,STJ->TJ_PLANO,STJ->TJ_SERVICO,;
								If(NgVerify("STJ"),STJ->TJ_SEQRELA,STJ->TJ_SEQUENC),;
								STJ->TJ_CCUSTO,STJ->TJ_DTMPINI,STJ->TJ_HOMPINI,STJ->TJ_DTPPINI,;
									STJ->TJ_HOPPINI,(cTRBA490)->TJ_DTMPINI,(cTRBA490)->TJ_HOMPINI,;
									(cTRBA490)->TJ_DTMPFIM,(cTRBA490)->TJ_HOMPFIM,;
								(cTRBA490)->TJ_DTPPINI,(cTRBA490)->TJ_HOPPINI,STJ->TJ_DTPPFIM,STJ->TJ_HOPPFIM)

							EndIf

						EndIf

					EndIf

					If lOk .And. (cTRBA490)->TJ_DATANOV != (cTRBA490)->TJ_DTMPINI

						Reclock( cTRBP490, .T. )
						(cTRBP490)->ORDEM   := (cTRBA490)->TJ_ORDEM
						(cTRBP490)->PLANO   := (cTRBA490)->TJ_PLANO
						(cTRBP490)->DTMPINI := (cTRBA490)->TJ_DTMPINI
						(cTRBP490)->DATANOV := (cTRBA490)->TJ_DATANOV
						(cTRBP490)->( MsUnLock() )

					EndIf

				EndIf

				// RollBack da transação devido a inconsistência na integração.
				If !lOk

					DisarmTransaction()

				EndIf

			END TRANSACTION

			If STJ->TJ_TIPOOS == 'B' .And. STJ->TJ_DTORIGI <= dDataBase

				TIPOACOM  := NGSeek( 'ST9', (cTRBA490)->TJ_CODBEM, 1, 'T9_TEMCONT' ) == 'S'

				TIPOACOM2 := MNTCont2( FWxFilial( 'ST9' ), (cTRBA490)->TJ_CODBEM )

				BEGIN TRANSACTION

					If TIPOACOM .And. ( STJ->TJ_POSCONT != (cTRBA490)->TJ_POSCONT .Or. STJ->TJ_HORACO1 != (cTRBA490)->TJ_HORACO1 )

						dbSelectArea( 'STP' )
						dbSetOrder( 5 ) // TP_FILIAL + TP_CODBEM + TP_DTLEITU + TP_HORA
						If dbSeek( FWxFilial( 'STP' ) + STJ->TJ_CODBEM + DToS( STJ->TJ_DTORIGI ) + STJ->TJ_HORACO1 )

							aARALTC :=  { 'STP'  , 'STP->TP_FILIAL' , 'STP->TP_CODBEM', 'STP->TP_DTLEITU', 'STP->TP_HORA',;
								'STP->TP_POSCONT', 'STP->TP_ACUMCON', 'STP->TP_VARDIA', 'STP->TP_VIRACON' }

							aARABEM := { 'ST9', 'ST9->T9_POSCONT', 'ST9->T9_CONTACU', 'ST9->T9_DTULTAC', 'ST9->T9_VARDIA' }

							RecLock( 'STP', .F. )
								dbDelete()
							MsUnLock()

							/*----------------------------------------------+
							| Exclui histórico do contador 1 para estrutura |
							+----------------------------------------------*/
							MNTA875ADEL( STP->TP_CODBEM, STP->TP_DTLEITU, STP->TP_HORA, 1, STP->TP_FILIAL, STP->TP_FILIAL, { cTRBS, cTRBF, CTRBEixo } )

						EndIf

						/*----------------------------------------------------+
						| Validação de histórico e variação dia do contador 1 |
						+----------------------------------------------------*/
						If !NGCHKHISTO( (cTRBA490)->TJ_CODBEM, (cTRBA490)->TJ_DTORIGI, (cTRBA490)->TJ_POSCONT, (cTRBA490)->TJ_HORACO1, 1, , .T., FWxFilial( 'ST9' ) ) .Or.;
							!NGVALIVARD( (cTRBA490)->TJ_CODBEM, (cTRBA490)->TJ_POSCONT, (cTRBA490)->TJ_DTORIGI, (cTRBA490)->TJ_HORACO1, 1, .T., , FWxFilial( 'ST9' ) )

							DisarmTransaction()

							BREAK
								
						EndIf
						
						/*----------------------------+
						| Atualiza contador 1 da O.S. |
						+----------------------------*/
						RecLock( 'STJ', .F. )
							STJ->TJ_POSCONT := (cTRBA490)->TJ_POSCONT
							STJ->TJ_HORACO1 := (cTRBA490)->TJ_HORACO1
						MsUnlock()
						
						/*-----------------------------------------------------+
						| Grava histórico de contador 1 e tabelas relacionadas |
						+-----------------------------------------------------*/
						NGTRETCON( STJ->TJ_CODBEM, STJ->TJ_DTORIGI, STJ->TJ_POSCONT, STJ->TJ_HORACO1, 1, , .F., , FWxFilial( 'ST9' ) )

					EndIf

					If TIPOACOM2 .And. ( STJ->TJ_POSCON2 != (cTRBA490)->TJ_POSCON2 .Or. STJ->TJ_HORACO2 != (cTRBA490)->TJ_HORACO2 )
						
						dbSelectArea( 'TPP' )
						dbSetOrder( 5 ) // TPP_FILIAL + TPP_CODBEM + TPP_DTLEIT + TPP_HORA
						If msSeek( FWxFilial( 'TPP' ) + STJ->TJ_CODBEM + DToS( STJ->TJ_DTORIGI ) + STJ->TJ_HORACO2 )
									
							aARALTC  := { 'TPP'  ,'TPP->TPP_FILIAL' , 'TPP->TPP_CODBEM', 'TPP->TPP_DTLEIT', 'TPP->TPP_HORA',;
								'TPP->TPP_POSCON', 'TPP->TPP_ACUMCO', 'TPP->TPP_VARDIA', 'TPP->TPP_VIRACO' }
									
							aARABEM  := { 'TPE', 'TPE->TPE_POSCON', 'TPE->TPE_CONTAC', 'TPE->TPE_DTULTA', 'TPE->TPE_VARDIA' }
									
							RecLock( 'TPP', .F. )
								dbDelete()
							MsUnLock()

							/*----------------------------------------------+
							| Exclui histórico do contador 2 para estrutura |
							+----------------------------------------------*/	
							MNTA875ADEL( TPP->TPP_CODBEM, TPP->TPP_DTLEIT, TPP->TPP_HORA, 2, TPP->TPP_FILIAL, TPP->TPP_FILIAL, { cTRBS, cTRBF, CTRBEixo } )
								
						EndIf

						/*----------------------------------------------------+
						| Validação de histórico e variação dia do contador 2 |
						+----------------------------------------------------*/
						If !NGCHKHISTO( (cTRBA490)->TJ_CODBEM, (cTRBA490)->TJ_DTORIGI, (cTRBA490)->TJ_POSCON2, (cTRBA490)->TJ_HORACO2, 2, , .T., FWxFilial( 'ST9' ) ) .Or.;
							!NGVALIVARD( (cTRBA490)->TJ_CODBEM, (cTRBA490)->TJ_POSCON2, (cTRBA490)->TJ_DTORIGI, (cTRBA490)->TJ_HORACO2, 2, .T., , FWxFilial( 'ST9' ) )

							DisarmTransaction()

							BREAK
								
						EndIf

						/*----------------------------+
						| Atualiza contador 1 da O.S. |
						+----------------------------*/
						RecLock( 'STJ', .F. )
							STJ->TJ_POSCON2 := (cTRBA490)->TJ_POSCON2
							STJ->TJ_HORACO2 := (cTRBA490)->TJ_HORACO2
						MsUnlock()

						/*-----------------------------------------------------+
						| Grava histórico de contador 2 e tabelas relacionadas |
						+-----------------------------------------------------*/
						NGTRETCON( STJ->TJ_CODBEM, STJ->TJ_DTORIGI, STJ->TJ_POSCON2, STJ->TJ_HORACO2, 2, , .F., , FWxFilial( 'ST9' ) )

					EndIf

				END TRANSACTION

			EndIf

		EndIf

		dbSelectArea(cTRBA490)
		dbSkip()

	End

	//Faz a reprogramacao das ordens de servico
	dbSelectArea(cTRBP490)
	dbgotop()
	If Reccount() > 0
		NGOSREPRAT(cTRBP490)
	EndIf

Return .T.

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MNTA265STL³ Autor ³Elisangela Costa       ³ Data ³29/05/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Deleta e recria o STL e seus relacionamentos apartir do    ³±±
±±³          ³arquivo temporario                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA265                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MNTA265STL()

	Local aAreaSTL  := {}
	Local cCodSTLa	:= ""
	Local cPRODTER	:= AllTrim(GetMV("MV_PRODTER"))
	Local cNGLOCPA	:= Padr( SuperGetMv("MV_NGLOCPA",.F.,"01"), TamSx3("NNR_CODIGO")[1] )
	Local cAliasSD4 := ''
	Local cAlsTemp  := ''
	Local cTblTemp  := ''
	Local cAlsSTL   := ''
	Local cNSA      := ''
	Local cISA      := ''
	Local lMMoeda   := NGCADICBASE("TL_MOEDA","A","STL",.F.) // Multi-Moeda
	Local lRet      := .T.
	Local lOk       := .T.
	Local lDelSD4	:= .T.
	Local lSendXML  := .F.
	Local vDataHora := {}
	Local aCstMoeda := {}
	Local nSEQCA    := If(lSEQREL,(cTRBL490)->TL_SEQRELA,Str((cTRBL490)->TL_SEQUENC,2))
	Local ng1		:= 0
	Local nTip 		:= aScan( aBkpHead, { |x| Trim( Upper( x[2] ) ) == 'TL_TIPOREG' } )
	Local nCod 		:= aScan( aBkpHead, { |x| Trim( Upper( x[2] ) ) == 'TL_CODIGO' } )
	Local nLoc 		:= aScan( aBkpHead, { |x| Trim( Upper( x[2] ) ) == 'TL_LOCAL' } )
	Local nQTD      := aScan( aBkpHead, { |x| Trim( Upper( x[2] ) ) == 'TL_QUANTID' } )
	Local lMntas    := SuperGetMV( "MV_NGMNTAS", .F., "2" ) == "1"
	Local cNgUnidt  := SuperGetMV("MV_NGUNIDT", .F., "2" )

	Local lIntegra	:= AllTrim(GetNewPar("MV_NGINTER","N")) == "M"
	Local aSCDel    := {}
	Local nX        := 0
	Local nY        := 0
	Local nSCPItem  := 0
	Local nPosSCP   := 0
	Local nQtIns    := 0
	Local nPosSTL   := 0
	Local nDiff     := 0
	Local nItemExis := 0
	Local cSeqTar   := Replicate( '0', TAMSX3( 'TL_SEQTARE' )[ 1 ] )

	Private aSAGer  := {}
	Private cNumSA  := Space(Len(SCP->CP_NUM))// Usado na funcao NGGERASA.. Nao mexer

	// Deleta o STL e SD4
	dbSelectArea("STL")
	dbSetOrder(1)
	dbSeek(xfilial("STL")+(cTRBA490)->TJ_ORDEM+(cTRBA490)->TJ_PLANO)
	While !Eof() .And. STL->TL_FILIAL == xFILIAL("STL") .And. STL->TL_ORDEM == (cTRBA490)->TJ_ORDEM;
				 .And. STL->TL_PLANO == (cTRBA490)->TJ_PLANO

		lRet := .T.

		If fAltInsPrv( STL->( RecNo() ) ) .Or. ( lIntegra .And. Alltrim(STL->TL_SEQRELA) == "0" )

			If ( STL->TL_TIPOREG == 'P' .Or. STL->TL_TIPOREG == 'T' )

				cCodPSC1 := STL->TL_CODIGO

				If STL->TL_TIPOREG == 'T'
					cCodPTer := If(FindFunction("NGProdMNT"), NGProdMNT("T")[1], cPRODTER) //Ira verificar apenas o primeiro Produto Terceiro do parametro
					cCodPSC1 := cCodPTer+Space(Len(sb1->b1_cod)-Len(cCodPTer))
				EndIf

				lDelSD4 := aScan( aAFTCOLS, {|x| x[nTip] == STL->TL_TIPOREG .And. x[nCod] == STL->TL_CODIGO .And.;
								  x[nLoc] == STL->TL_LOCAL .And. x[Len(aAFTCOLS[1])] == .F. } ) == 0

				lOk := NGDELSC1PR( STL->TL_ORDEM, 'OS001', cCodPSC1, IIf( Empty( STL->TL_LOCAL ), NgSeek( 'SB1', cCodPSC1, 1, 'B1_LOCPAD' ),;
					STL->TL_LOCAL ), STL->TL_QUANTID, lDelSD4 )

				If !lOk
					Exit
				EndIf

			EndIf

			If NG420CHKSA( STL->TL_TIPOREG )

				If NGIFDBSEEK( 'SCP', STL->TL_NUMSA + STL->TL_ITEMSA, 1, .F. )

					If SCP->CP_QUJE <= 0 .And. SCP->CP_PREREQU != 'S' .And. fVldAltSA( STL->( Recno() ), '%' + oTmpTbl1:GetRealName() + '%' )

						If lIntegra

							// Busca a posição do Recno da STL no array aAFTCOLS
							nPosRecno := Len( aAFTCOLS[ 1 ] ) - 1

							// Verifica se o Recno da STL está no aAFTCOLS
							nPosSTL   := aScan(aAFTCOLS,{|x| x[nPosRecno] == STL->(Recno()) } )

							If nPosSTL > 0

								// Caso a linha não esteja deletada, pega quantidade do aAFTCOLS.
								nQtIns := IIf( !aTail( aAFTCOLS[ nPosSTL ] ), aAFTCOLS[ nPosSTL, nQTD ], STL->TL_QUANTID )

								If NGMUTRAREQ("SCP",STL->TL_NUMSA,xFilial("SCP"),.F., STL->TL_ITEMSA, nQtIns, STL->TL_LOCAL)

									If lMntas

										// Calcula diferença da quantidade entre SCP e STL
										nDiff := SCP->CP_QUANT - nQtIns

										// Caso aSCDel já tenha recebido algum valor
										If Len( aSCDel ) > 0

											// Verifica se a S.A. já foi informada.
											nPosSCP := aScan( aSCDel[ 1 ], { |x| x[ 1 ] == SCP->CP_NUM } )

										EndIf

										// CAso não tenha sido informada, inclui uma nova linha.
										If nPosSCP == 0
											aAdd( aSCDel, {{SCP->CP_NUM, { {SCP->CP_ITEM, IIf( !aTail( aAFTCOLS[ nPosSTL ] ), 4, Nil ), nDiff } } }} )
										Else

											// Verifica se o item já foi informado
											nItemExis := aScan( aSCDel[ nPosSCP, 1, 2 ], { |x| x[ 1 ]  == SCP->CP_ITEM } )

											// Caso o item já esteja no aSCDel, adiciona a diferença.
											If nItemExis > 0

												aSCDel[ nPosSCP, 1, 2, nItemExis, 3 ] += nDiff

											Else

												aAdd( aSCDel[ nPosSCP, 1, 2 ], { SCP->CP_ITEM, IIf( !aTail( aAFTCOLS[ nPosSTL ] ), 4, Nil ), nDiff } )

											EndIf
										Endif

									EndIf

								Else
									lRet := .F.
								EndIf
							Else
								lRet := .F.
							EndIf
						Else

							lRet := SCP->CP_PREREQU != 'S'

						EndIf

					EndIf

				EndIf

			EndIf

			//Deleta os bloqueios de Ferramentas
			If STL->TL_TIPOREG == 'F'
				dbSelectArea("SH9")
				dbSetOrder(3)
				If dbSeek(xFILIAL("SH9")+"F"+SubStr(STL->TL_CODIGO,1,Len(SH9->H9_FERRAM))+DtoS(STL->TL_DTINICI)+STL->TL_HOINICI)
					//desfazer SGT na versao 12 (verificar com a Totvs)
					If AliasInDic("SGT")
						SGT->(dbSetOrder(1))
						If SGT->(dbSeek(xFilial("SGT")+SH9->(H9_TIPO+H9_CCUSTO+H9_RECURSO+DTOS(H9_DTINI)+H9_HRINI)))
							RecLock("SGT",.F.)
							SGT->(dbDelete())
							SGT->(MsUnLock())
						EndIf
					EndIf
					RecLock("SH9",.F.,.T.)
					dbDelete()
					SH9->(MsUnLock())
				EndIf
			EndIf

			//Deleta os bloqueios de funcionario da especialidade
			If STL->TL_TIPOREG == 'M'
				
				dbSelectArea( 'STK' )
				dbSetOrder( 1 )
				If dbSeek( xFilial( 'STK' ) + STL->TL_ORDEM + STL->TL_PLANO + STL->TL_TAREFA + STL->TL_TAREFA + STL->TL_CODIGO )
					
					While STK->( !EoF() ) .And. STK->TK_FILIAL == xFilial( 'STK' ) .And. STK->TK_ORDEM == STL->TL_ORDEM .And.;
						STK->TK_PLANO == STL->TL_PLANO .And. STK->TK_TAREFA == STL->TL_TAREFA .And. STK->TK_CODFUNC == STL->TL_CODIGO
					
						RecLock( 'STK', .F. )
						dbDelete()
						STK->( MsUnLock() )
				
						STK->( dbSkip() )
					
					End
				
				EndIf

			EndIf

			If lRet

				cNSA := STL->TL_NUMSA
				cISA := STL->TL_ITEMSA

				NGDELETAREG("STL")

				If !Empty( cNSA )

					cAlsSTL  := GetNextAlias()
					aAreaSTL := STL->( GetArea() )
				
					BeginSQL Alias cAlsSTL

						SELECT
							STL.R_E_C_N_O_ AS REC
						FROM
							%table:STL% STL
						WHERE
							STL.TL_FILIAL = %xFilial:STL% AND
							STL.TL_NUMSA  = %exp:cNSA%  AND
							STL.TL_ITEMSA = %exp:cISA% AND
							STL.%NotDel%

					EndSQL

					While (cAlsSTL)->( !EoF() )

						dbSelectArea( 'STL' )
						dbGoTo( (cAlsSTL)->REC )

						RecLock( 'STL', .F. )
						dbDelete()
						STL->( MsUnLock() )

						(cAlsSTL)->( dbSkip() )

					End

					(cAlsSTL)->( dbCloseArea() )

					RestArea( aAreaSTL )

				EndIf

			EndIf

		EndIf

		If STL->TL_TIPOREG == "T"  .or. STL->TL_TIPOREG == "P"
			If STL->TL_TIPOREG == "T"
				cCodSTLa := If(FindFunction("NGProdMNT"), NGProdMNT("T")[1], PADR(cPRODTER,LEN(STL->TL_CODIGO))) //Ira verificar apenas o primeiro Produto Terceiro do parametro
			Else
				cCodSTLa := STL->TL_CODIGO
			EndIf
			If Empty(STL->TL_LOCAL)
				cLocal := cNGLOCPA
			Else
				cLocal := STL->TL_LOCAL
			EndIf
			cAliasSD4 := GetNextAlias()
			cOpSD4 := STL->TL_ORDEM + "OS001"

			BeginSQL Alias cAliasSD4
				SELECT
					SUM(D4_QUANT) AS SaldoB2
				FROM
					%table:SD4% SD4
				WHERE
					SD4.D4_OP    <> %exp:cOpSD4%   AND
					SD4.D4_COD    = %exp:cCodSTLa% AND
					SD4.D4_FILIAL = %xFilial:STJ%  AND
					SD4.%NotDel%
			EndSQL

			If !NG420CHKSA(STL->TL_TIPOREG) .And. NGIFDBSEEK("SB2",cCodSTLa+cLocal,1,.F.)

				RecLock("SB2",.F.)
				SB2->B2_QEMP := (cAliasSD4)->SaldoB2
				MsUnLock()

			EndIf
			(cAliasSD4)->(dbCloseArea())
		EndIf

		dbSelectArea("STL")
		dbSkip()

	End While

	If lOk

		If lMntas

			For nX := 1 to Len(aSCDel)

				lSendXML := .F.
				
				For nSCPItem := 1 To Len( aSCDel[ nX, 1, 2 ] )
					If NGIFDBSEEK( "SCP",aSCDel[ nX, 1, 1 ] + aSCDel[ nX, 1, 2, nSCPItem, 1 ], 01,.F. )
						If lIntegra
							
							If aSCDel[nX,1,2,nSCPItem,2] != 4 .And. aSCDel[nX,1,2,nSCPItem,3] == 0 .And. !lSendXML

								cAliasSCP := GetNextAlias()
								//Caso todos os itens forem deletados não é necessário o array.
								BeginSQL Alias cAliasSCP

									SELECT
										COUNT( CP_NUM ) AS QTSCP
									FROM
										%table:SCP%
									WHERE
										CP_FILIAL  = %xFilial:SCP% AND
										CP_NUM = %exp:SCP->CP_NUM% AND
										%NotDel%

								EndSQL

								If (cAliasSCP)->QTSCP == Len(aSCDel[nX,1,2]) .And. aScan( aSCDel[ 1, 1, 2 ], { |x| x[ 2 ] == 4 } ) == 0
									lSendXML := NGMUReques( SCP->( RecNo()),"SCP",.F.,5)
								Else
									lSendXML := NGMUReques( SCP->( RecNo()),"SCP",.F.,5,, aSCDel[nX,1,2])
								EndIf

								(cAliasSCP)->( dbCloseArea() )

							EndIf

						EndIf

						If lSendXML .And. SCP->CP_PREREQU <> 'S'

							// Realiza exclusão da S.A. e seus relacionamentos ( SCR ).
							IIf( FindFunction( 'MntDelReq' ), MntDelReq( SCP->CP_NUM, SCP->CP_ITEM, 'SA' ), NGDELETAREG( 'SCP' ) )

						EndIf

					EndIf

				Next nSCPItem

			Next nX

		EndIf

		/*-----------------------------------------------------------+
		| Recria o STL por meio do arquivo com os insumos alterados. |
		+-----------------------------------------------------------*/
		cAlsTemp := GetNextAlias()
		cTblTemp := '%' + oTmpTbl1:GetRealName() + '%'

		BeginSQL Alias cAlsTemp

			SELECT
				R_E_C_N_O_ AS REC
			FROM
				%exp:cTblTemp% TEMP
			WHERE
				TEMP.TL_ORDEM = %exp:(cTRBA490)->TJ_ORDEM% AND
				TEMP.TL_PLANO = %exp:(cTRBA490)->TJ_PLANO% 

		EndSQL
		
		While (cAlsTemp)->( !EoF() )

			dbSelectArea( cTRBL490 )
			dbGoTo( (cAlsTemp)->REC )

			If (cTRBL490)->TL_TIPOREG $ 'P/T' .And. (cTRBL490)->STATUS == 3

				cAlsSA := GetNextAlias()

				BeginSQL Alias cAlsSA

					SELECT
						R_E_C_N_O_ AS REC
					FROM
						%exp:cTblTemp% TEMP
					WHERE
						TEMP.TL_NUMSA  = %exp:(cTRBL490)->TL_NUMSA%  AND
						TEMP.TL_ITEMSA = %exp:(cTRBL490)->TL_ITEMSA% AND
						TEMP.STATUS = 0

				EndSQL

				If (cAlsSA)->( !EoF() )
				
					While (cAlsSA)->( !EoF() )

						dbSelectArea( cTRBL490 )
						dbGoTo( (cAlsSA)->REC )

						RecLock( cTRBL490, .F. )
						(cTRBL490)->STATUS := 2
						MsUnLock()

						(cAlsSA)->( dbSkip() )

					End

				Else

					// Realiza exclusão da S.A. e seus relacionamentos ( SCR ).
					IIf( FindFunction( 'MntDelReq' ), MntDelReq( (cTRBL490)->TL_NUMSA, (cTRBL490)->TL_ITEMSA, 'SA' ), NGDELETAREG( 'SCP' ) )

				EndIf

				(cAlsSA)->( dbCloseArea() )

				dbSelectArea( cTRBL490 )
				dbGoTo( (cAlsTemp)->REC )

			ElseIf (cTRBL490)->STATUS != 3
			
				nSEQCA     := If(lSEQREL,(cTRBL490)->tl_seqrela,str((cTRBL490)->tl_sequenc,2))
				cChavSTL := (cTRBL490)->TL_ORDEM+(cTRBL490)->TL_PLANO+(cTRBL490)->TL_TAREFA+(cTRBL490)->TL_TIPOREG+(cTRBL490)->TL_CODIGO+nSEQCA

				If lSEQTAR .And. Alltrim((cTRBL490)->TL_SEQTARE) <> cSeqTar
					cChavSTL += (cTRBL490)->TL_SEQTARE
				Endif

				If (cTRBL490)->PROBMAOBR == "N"
				
					dbSelectArea("STL")
					dbSetOrder(1)
					If !dbSeek(xFilial("STL")+cChavSTL)
						RecLock("STL",.T.)
						STL->TL_FILIAL := xFilial( 'STL' )
					Else
						RecLock("STL",.f.)
					Endif
					
					dbSelectArea(cTRBL490)
					For ng1 := 1 to Len( aDBFL )
						
						If !( aDBFL[NG1,1] $ 'PROBMAOBR#RECNO#STATUS' )
							
							If aDBFL[NG1,1] == "TL_TIPOHOR"
								STL->TL_TIPOHOR := cNGUNIDT
							ElseIf !lIntegra .And. !( aDBFL[NG1,1] $ 'TL_NUMSA/TL_ITEMSA/TL_FILIAL' ) .Or.;
								!( aDBFL[NG1,1] $ 'TL_NUMSC/TL_ITEMSC/TL_FILIAL' )
									
								ny := "STL->TL_" + Substr( aDBFL[NG1,1], 4, Len( aDBFL[NG1,1] ) )
								nx := cTRBL490+"->TL_" + Substr( aDBFL[NG1,1], 4, Len( aDBFL[NG1,1] ) )
								&ny. := &nx.

								If aDBFL[NG1,1] == "TL_CUSTO"
									If lMMoeda .And. FindFunction("NGCALCUSMD")
										aCstMoeda     := NGCALCUSMD( STL->TL_CODIGO, STL->TL_TIPOREG, STL->TL_QUANTID, (cTRBL490)->TL_LOCAL, (cTRBL490)->TL_TIPOHOR,,,STL->TL_QUANREC )
										STL->TL_CUSTO := aCstMoeda[1]
										STL->TL_MOEDA := aCstMoeda[2]
									Else
										STL->TL_CUSTO := NGCALCUSTI( STL->TL_CODIGO, STL->TL_TIPOREG, STL->TL_QUANTID, (cTRBL490)->TL_LOCAL, (cTRBL490)->TL_TIPOHOR,,, STL->TL_QUANREC )
										If lMMoeda
											STL->TL_MOEDA := '1'
										EndIf
									EndIf
								EndIf

								hINI := If(!Empty((cTRBA490)->TJ_HOMPINI),(cTRBA490)->TJ_HOMPINI,SubStr( Time(),1,5))
								If STL->TL_TIPOREG == "P"
									STL->TL_DTINICI := (cTRBA490)->TJ_DTMPINI
									STL->TL_HOINICI := hINI
									STL->TL_DTFIM   := STL->TL_DTINICI
									STL->TL_HOFIM   := STL->TL_HOINICI
								Else
									
									vDataHora       := NGDTHORFIM((cTRBA490)->TJ_DTMPINI,(cTRBA490)->TJ_HOMPINI,(cTRBL490)->TL_QUANTID)
									STL->TL_DTINICI := (cTRBA490)->TJ_DTMPINI
									STL->TL_HOINICI := hINI
									STL->TL_DTFIM   := vDataHora[1]
									STL->TL_HOFIM   := vDataHora[2]
									
								Endif

							EndIf
						
						EndIf
						
					Next
					
					STL->TL_USACALE := If(Empty(STL->TL_USACALE),"N",STL->TL_USACALE)
					STL->TL_GARANTI := If(Empty(STL->TL_GARANTI),"N",STL->TL_GARANTI)
					
					STL->( MsUnLock() )
				
				Else

					dbSelectArea( 'STA' )
					dbSetOrder( 1 ) // TA_FILIAL + TA_ORDEM + TA_PLANO + TA_TAREFA + TA_TIPOREG + TA_CODIGO + TA_DESCRIC
					If !dbSeek( xFilial( 'STA' ) + (cTRBL490)->TL_ORDEM + (cTRBL490)->TL_PLANO + 'M' +;
						(cTRBL490)->TL_CODIGO + STR0054 )
								
						RecLock( 'STA', .T. )
						STA->TA_FILIAL  := xFILIAL("STA")
						STA->TA_ORDEM   := (cTRBL490)->TL_ORDEM
						STA->TA_PLANO   := (cTRBL490)->TL_PLANO
						STA->TA_TIPOREG := "M"          	
						STA->TA_CODIGO  := (cTRBL490)->TL_CODIGO
						STA->TA_DESCRIC := STR0054 // FUNCIONARIO NAO DISPONIVEL
						STA->( MsUnLock() )

					EndIf

				EndIf

			EndIf
			
			(cAlsTemp)->( dbSkip() )
		
		End

	EndIf

Return lOk

//--------------------------------------------------------------------------------------------------
/*/{Protheus.doc} M265OSLIB
Cria os relacionamentos dos insumos para O.S. ja liberada

@author	Elisangela Costa
@since	29/05/2007

@param cVORDEM  , Caracter, Codigo da Ordem de Servico
@param cVPLANO  , Caracter, Codigo do Plano
@param cCodeBem , Caracter, Código do bem
@param lUseIntEs, Lógico  , Define se possui integração com estoque
@param lUsePrAlt, Lógico  , Define se possui conceito de produto alternativo

@sample M265OSLIB()

@return

/*/
//---------------------------------------------------------------------------------------------------
Function M265OSLIB( cVORDEM, cVPLANO, cCodeBem, lUseIntEs, lUsePrAlt )

	Local aArea     := GetArea()
	Local cBEM490   := ""
	Local cAlsTemp  := GetNextAlias()
	Local cAlsSA    := ''
	Local cTblTemp  := '%' + oTmpTbl1:GetRealName() + '%'
	Local aArraySC  := {}
	Local lOk       := .T.

	Private aNewSc := {} // Utilizado no processo de produto alternativo

	Default lUseIntEs := AllTrim( SuperGetMv( 'MV_NGMNTES', .F., 'N' ) ) == 'S'
	Default lUsePrAlt := AllTrim( SuperGetMv( 'MV_MNTPRAL', .F., '2' ) ) == '1' .And. FindFunction( 'NGATUSTL' )  .And. AllTrim( SuperGetMv( 'MV_NGGERSA', .F., 'N' ) ) == 'N'

	M->TI_PLANO := cVPLANO

	/*------------------------------------------------------
	/ Monta o array com insumos que devem gerar requisições
	--------------------------------------------------------*/
	aARRAYSTL := {}
	ASTLPD    := {}

	BeginSQL Alias cAlsTemp

		SELECT 
			%exp:cFieldQry%
		FROM
			%exp:cTblTemp% TEMP
		WHERE
			TEMP.TL_ORDEM = %exp:cVORDEM% AND
			TEMP.TL_PLANO = %exp:cVPLANO% AND
			TEMP.STATUS IN ( 1, 2 )

	EndSQL
		
	While (cAlsTemp)->( !EoF() )

		aArraySC := { (cAlsTemp)->TL_ORDEM, (cAlsTemp)->TL_CODIGO, (cAlsTemp)->TL_NUMSC, (cAlsTemp)->TL_ITEMSC }

		/*------------------------------------------------------
		/ Consiste se existe S.A. baixada e não envia o insumo
		--------------------------------------------------------*/
		If MNT420BSA( (cAlsTemp)->TL_NUMSA, (cAlsTemp)->TL_ITEMSA, .F., aArraySC ) .And. Alltrim( (cAlsTemp)->TL_SEQRELA ) == "0"

			If aScan( aARRAYSTL, { |x| x[2] + x[9] + x[10] == (cAlsTemp)->TL_CODIGO + (cAlsTemp)->TL_TAREFA + (cAlsTemp)->TL_LOCAL .And.;
				x[3] == (cAlsTemp)->TL_QUANTID } ) == 0

				aAdd( aARRAYSTL, { 	(cAlsTemp)->TL_TIPOREG        , (cAlsTemp)->TL_CODIGO , (cAlsTemp)->TL_QUANTID      , (cAlsTemp)->TL_QUANREC,;
									SToD( (cAlsTemp)->TL_DTINICI ), (cAlsTemp)->TL_HOINICI, SToD( (cAlsTemp)->TL_DTFIM ), (cAlsTemp)->TL_HOFIM  ,;
									(cAlsTemp)->TL_TAREFA         , (cAlsTemp)->TL_LOCAL  , (cAlsTemp)->TL_NUMSA        , (cAlsTemp)->TL_ITEMSA ,;
									(cAlsTemp)->TL_UNIDADE        , (cAlsTemp)->TL_OBSERVA, (cAlsTemp)->TL_FORNEC       , (cAlsTemp)->TL_LOJA   ,;
									(cAlsTemp)->TL_NUMSC          , (cAlsTemp)->TL_ITEMSC , (cAlsTemp)->TL_CUSTO } )

			EndIf
//////////////////SA sempre chega vazia aqui, mesmo pra insumos nao alterados
			If !Empty( (cAlsTemp)->TL_NUMSA )
			
				cAlsSA := GetNextAlias()

				BeginSQL Alias cAlsSA

					SELECT 
						%exp:cFieldQry%
					FROM
						%exp:cTblTemp% TEMP
					WHERE
						TEMP.TL_NUMSA  = %exp:(cAlsTemp)->TL_NUMSA% AND
						TEMP.TL_ITEMSA = %exp:(cAlsTemp)->TL_ITEMSA% AND
						TEMP.STATUS <> 3

				EndSQL

				While (cAlsSA)->( !EoF() )

					If aScan( aARRAYSTL, { |x| x[2] + x[9] + x[10] == (cAlsSA)->TL_CODIGO + (cAlsSA)->TL_TAREFA + (cAlsSA)->TL_LOCAL .And.;
						x[3] == (cAlsSA)->TL_QUANTID } ) == 0

						aAdd( aARRAYSTL, { 	(cAlsSA)->TL_TIPOREG        , (cAlsSA)->TL_CODIGO , (cAlsSA)->TL_QUANTID      , (cAlsSA)->TL_QUANREC,;
											SToD( (cAlsSA)->TL_DTINICI ), (cAlsSA)->TL_HOINICI, SToD( (cAlsSA)->TL_DTFIM ), (cAlsSA)->TL_HOFIM  ,;
											(cAlsSA)->TL_TAREFA         , (cAlsSA)->TL_LOCAL  , (cAlsSA)->TL_NUMSA        , (cAlsSA)->TL_ITEMSA ,;
											(cAlsSA)->TL_UNIDADE        , (cAlsSA)->TL_OBSERVA, (cAlsSA)->TL_FORNEC       , (cAlsSA)->TL_LOJA   ,;
											(cAlsSA)->TL_NUMSC          , (cAlsSA)->TL_ITEMSC , (cAlsSA)->TL_CUSTO } )

					EndIf

					(cAlsSA)->( dbSkip() )

				End

				(cAlsSA)->( dbCloseArea() )

			EndIf

		EndIf
		
		(cAlsTemp)->( dbSkip() )

	End

	(cAlsTemp)->( dbCloseArea() )

	//Deleta todos os Problemas antes de refazer os bloqueios de bens e insumos
	dbSelectArea("STA")
	dbSetOrder(1)
	dbSeek(xFILIAL("STA")+cVORDEM+cVPLANO)
	While !Eof() .And. STA->TA_FILIAL+STA->TA_ORDEM+STA->TA_PLANO == xFILIAL("STA")+cVORDEM+cVPLANO
		RecLock("STA",.F.,.T.)
		dbDelete()
		STA->(MsUnLock())
		dbSkip()
	End

	If lUsePrAlt .And. lUseIntEs .And. Len(aARRAYSTL) > 0
		// Ajusta STL caso haja produto alternativo
		// Ultimo parametro é enviado com base nas posições dos campos
		// TL_QUANTID, TL_CODIGO, TL_LOCAL, TL_CUSTO do array aARRAYSTL
		NGATUSTL( cVORDEM, cVPLANO, cCodeBem, { 03, 02, 10, 19 } )
	EndIf

	// Quando utilizado conceito de produto alternativo, deve-se verificar novamente se o array possui dados.
	If Len(aARRAYSTL) > 0

		cOP  := cVORDEM + "OS001"
		aBLO := { {},{},{},{},{}}

		lGERAEMP := .T.
		If Val(cVPLANO) == 0
			If GETMV("MV_NGCORPR") <> "S"
				lGERAEMP := .F.
			Endif

		Endif

		If lGERAEMP
			Processa({|lEnd| MNTA490PT(cVPLANO,cVORDEM)},STR0055) //"Aguarde ..Preparando Para Gerar Insumos..."
		Endif

		//+-----------------------------------------------------------+
		//| Efetua o bloqueio de Ferramentas                          |
		//+-----------------------------------------------------------+
		Processa({|lEnd| MNTA490FE(cBEM490)},STR0056) //"Aguarde ..Bloqueando Ferramentas..."

		//+-----------------------------------------------------------+
		//| Efetua o bloqueio de Mao de Obras (FUNCIONARIO)           |
		//+-----------------------------------------------------------+
		Processa({|lEnd| MNTA490FU() }, STR0057) //"Aguarde ..Bloqueando Mão-de-Obra..."

		//+-----------------------------------------------------------+
		//| Efetua o bloqueio de Especialistas (FUNCIONARIO)          |
		//+-----------------------------------------------------------+
		Processa({|lEnd| MNTA490ES()},STR0058) //"Aguarde ..Bloqueando Especialidade.."

		//+-----------------------------------------------------------+
		//| Efetua o bloqueio de Produtos                             |
		//+-----------------------------------------------------------+
		dbselectArea("SC2")
		dbsetorder(6)
		dbseek(xFILIAL("SC2")+cOP)

		// Efetua o bloqueio de Produtos.
		Processa( { || lOk := MNTA490PR( .T. ) }, STR0059 ) // Aguarde ..Bloqueando Produto e Integra‡Æo..

		If lOk

			// Gera solicitação de compra para terceiros.
			Processa( { || lOk := MNTA490TE() }, STR0060 ) // Aguarde ..Bloqueando Terceiros..

		EndIf

	Endif

	RestArea( aArea )

Return lOk

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MNT265VALP³ Autor ³Elisangela Costa       ³ Data ³29/05/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Valida o parametro de plano de manutencao                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cVARPLA = Valor do parametro                                ³±±
±±³          ³nPAR = Numero do Parametro de Plano                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA265                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MNT265VALP(cVARPLA,nPAR)

	If nPAR == 1
		If Empty(MV_PAR01)
			Return .T.
		Else
			If !Existcpo("STI",MV_PAR01)
				Return .F.
			EndIf
		EndIf
	Else
		If !Atecodigo("STI",MV_PAR01,MV_PAR02,6)
			Return .F.
		EndIf
	EndIf

	If !Empty(cVARPLA) .And. cVARPLA <> "ZZZZZZ" .And. cVARPLA > "000001"
		dbSelectArea("STI")
		dbSetOrder(01)
		If dbSeek(xFilial("STI")+cVARPLA)
			If (STI->TI_SITUACA <> "L" .And. STI->TI_SITUACA <> "P") .Or. STI->TI_TERMINO <> "N"
				MsgStop(STR0061,STR0041) //"Informe um plano que esteja liberado/nao terminado ou pendente."###"ATENÇÃO"
				Return .F.
			EndIf
		EndIf
	EndIf

Return .T.


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³M265BLOQBR³ Autor ³Elisangela Costa       ³ Data ³18/06/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Deleta e recria bloqueios de Bem e Recursos do bem de OS    ³±±
±±³          ³preventivas                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cCODBE265  - Codigo do bem                                  ³±±
±±³          ³cVPLANO    - Codigo do plano da Ordem de Servico            ³±±
±±³          ³cSERVICO   - Codigo do servico da manutencao                ³±±
±±³          ³cNSEQUEN   - Sequencia da manutencao                        ³±±
±±³          ³cCCUSTO    - Codigo do Centro de Custo                      ³±±
±±³          ³dDTMPINI   - Data de Manutencao Prevista Inicio do STJ      ³±±
±±³          ³cHORMPINI  - Hora de Manutencao Prevista Incicio do STJ     ³±±
±±³          ³dDTPPINI   - Data de Parada Prevista Inicio do STJ          ³±±
±±³          ³cHORPPINI  - Hora de Parada Prevista Inicio do STJ          ³±±
±±³          ³dTRBDTMPI  - Data de Manutencao Prevista Inicio do TRBA     ³±±
±±³          ³cTRBHOMPI  - Hora de Manutencao Prevista Incicio do TRBA    ³±±
±±³          ³dTRBDTMPF  - Data de Manutencao Prevista Fim do TRBA        ³±±
±±³          ³cTRBHOMPF  - Hora de Manutencao Prevista Fim do TRBA        ³±±
±±³          ³dTRBDTPPIN - Data de Parada Prevista Inicio do TRBA         ³±±
±±³          ³cTRBHOPPIN - Hora de Parada Prevista Inicio do TRBA         ³±±
±±³          ³dTRBADTPPFI- Data de Parada Prevista Fim do TRBA            ³±±
±±³          ³cTRBHOPPFIM- Hora de Parada Prevista Fim do TRBA            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA265                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function M265BLOQBR(cCODBE265,cVORDEM,cVPLANO,cSERVICO,cNSEQUEN,cCCUSTO,dDTMPINI,cHORMPINI,dDTPPINI,;
	cHORPPINI,dTRBDTMPI,cTRBHOMPI,dTRBDTMPF,cTRBHOMPF,dTRBDTPPIN,cTRBHOPPIN,dTRBADTPPFI,;
	cTRBHOPPFIM)

	Local nRegST9

	If Val(cVPLANO) > 0

		M->TI_PLANO := cVPLANO
		dbSelectArea("ST9")
		dbSetOrder(1)
		If dbSeek(xFILIAL("ST9")+cCODBE265)

			// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			// ³Elimina SH9 os Bloqueios de ferramentas                        ³
			// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ST9->T9_FERRAME == "F"

				//Checa bloqueios pela data da manutencao prevista inicio
				dbSelectArea("SH9")
				dbSetOrder(03)
				dbSeek(xFILIAL("SH9")+"F"+ST9->T9_RECFERR+DTOS(dDTMPINI)+cHORMPINI)
				While !Eof() .And. SH9->H9_FILIAL+SH9->H9_TIPO+SH9->H9_FERRAM+DTOS(SH9->H9_DTINI)+ SH9->H9_HRINI ==;
				xFILIAL("SH9")+"F"+ST9->T9_RECFERR+DTOS(dDTMPINI)+cHORMPINI

					cMOTIVO := STR0062+cVORDEM+STR0063+cVPLANO  //"OS.MANUT."###" PLANO "
					If Trim(cMOTIVO) == Trim(SH9->H9_MOTIVO) .And. SH9->H9_ORIGEM == '1'
						//desfazer SGT na versao 12 (verificar com a Totvs)
						If AliasInDic("SGT")
							SGT->(dbSetOrder(1))
							If SGT->(dbSeek(xFilial("SGT")+SH9->(H9_TIPO+H9_CCUSTO+H9_RECURSO+DTOS(H9_DTINI)+H9_HRINI)))
								RecLock("SGT",.F.)
								SGT->(dbDelete())
								SGT->(MsUnLock())
							EndIf
						EndIf
						RecLock("SH9",.F.)
						dbDelete()
						SH9->(MsUnLock())
					EndIf
					dbSkip()
				End

				//Checa bloqueios pela data de parada prevista inicio
				If !Empty(dDTPPINI)
					dbSelectArea("SH9")
					dbSetOrder(03)
					dbSeek(xFILIAL("SH9")+"F"+ST9->T9_RECFERR+DTOS(dDTPPINI)+cHORPPINI)
					While !Eof() .And. SH9->H9_FILIAL+SH9->H9_TIPO+SH9->H9_FERRAM+DTOS(SH9->H9_DTINI)+ SH9->H9_HRINI ==;
					xFILIAL("SH9")+"F"+ST9->T9_RECFERR+DTOS(dDTPPINI)+cHORPPINI

						cMOTIVO := STR0062+cVORDEM+STR0063+cVPLANO  //"OS.MANUT."###" PLANO "
						If Trim(cMOTIVO) == Trim(SH9->H9_MOTIVO) .And. SH9->H9_ORIGEM == '1'
							//desfazer SGT na versao 12 (verificar com a Totvs)
							If AliasInDic("SGT")
								SGT->(dbSetOrder(1))
								If SGT->(dbSeek(xFilial("SGT")+SH9->(H9_TIPO+H9_CCUSTO+H9_RECURSO+DTOS(H9_DTINI)+H9_HRINI)))
									RecLock("SGT",.F.)
									SGT->(dbDelete())
									SGT->(MsUnLock())
								EndIf
							EndIf
							RecLock("SH9",.F.)
							dbDelete()
							SH9->(MsUnLock())
						EndIf
						dbSkip()
					End
				EndIf

				// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				// ³Elimina SH9 os Bloqueios de Recursos                           ³
				// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ElseIf ST9->T9_FERRAME == "R"

				//Checa bloqueios pela data da manutencao prevista inicio
				dbSelectArea("SH9")
				dbSetOrder(4)
				dbSeek(xFILIAL("SH9")+"B"+DTOS(dDTMPINI))
				While !Eof() .And. H9_FILIAL+H9_TIPO+DTOS(H9_DTINI) == xFILIAL("SH9")+"B"+DTOS(dDTMPINI)

					cMOTIVO := STR0062+cVORDEM+STR0063+cVPLANO  //"OS.MANUT."###" PLANO "
					If Trim(cMOTIVO) == Trim(SH9->H9_MOTIVO) .And.  SH9->H9_ORIGEM == "1"
						//desfazer SGT na versao 12 (verificar com a Totvs)
						If AliasInDic("SGT")
							SGT->(dbSetOrder(1))
							If SGT->(dbSeek(xFilial("SGT")+SH9->(H9_TIPO+H9_CCUSTO+H9_RECURSO+DTOS(H9_DTINI)+H9_HRINI)))
								RecLock("SGT",.F.)
								SGT->(dbDelete())
								SGT->(MsUnLock())
							EndIf
						EndIf
						RecLock("SH9",.F.)
						dbDelete()
						SH9->(MsUnLock())
					EndIf
					dbSkip()
				End

				//Checa bloqueios pela data de parada prevista inicio
				If !Empty(dDTPPINI)
					dbSelectArea("SH9")
					dbSetOrder(4)
					dbSeek(xFILIAL("SH9")+"B"+DTOS(dDTPPINI))
					While !Eof() .And. H9_FILIAL+H9_TIPO+DTOS(H9_DTINI) == xFILIAL("SH9")+"B"+DTOS(dDTPPINI)

						cMOTIVO := STR0062+cVORDEM+STR0063+cVPLANO  //"OS.MANUT."###" PLANO "
						If Trim(cMOTIVO) == Trim(SH9->H9_MOTIVO) .And.  SH9->H9_ORIGEM == "1"
							//desfazer SGT na versao 12 (verificar com a Totvs)
							If AliasInDic("SGT")
								SGT->(dbSetOrder(1))
								If SGT->(dbSeek(xFilial("SGT")+SH9->(H9_TIPO+H9_CCUSTO+H9_RECURSO+DTOS(H9_DTINI)+H9_HRINI)))
									RecLock("SGT",.F.)
									SGT->(dbDelete())
									SGT->(MsUnLock())
								EndIf
							EndIf
							RecLock("SH9",.F.)
							dbDelete()
							SH9->(MsUnLock())
						EndIf
						dbSkip()
					End
				EndIf
			EndIf

			//Deleta os bloqueios do bem para a Os no ST3
			dbSelectArea("ST3")
			dbSetOrder(2)
			dbSeek(xFILIAL("ST3")+cVORDEM+cVPLANO)
			While !Eof() .And. ST3->T3_FILIAL+ST3->T3_ORDEM+ST3->T3_PLANO == xFilial("ST3")+cVORDEM+cVPLANO
				RecLock("ST3",.F.)
				DbDelete()
				ST3->(MsUnLock())
				dbSkip()
			End

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Efetua o bloqueio do Bem para a data de Manutencao         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("STF")
			dbSetOrder(01)
			If (NgVerify("STF").And. dbSeek(xFILIAL("STF")+cCODBE265+cSERVICO+cNSEQUEN)).Or. ;
			(!NgVerify("STF").And. dbSeek(xFILIAL("STF")+cCODBE265+cSERVICO+Str(cNSEQUEN,3)))

				dINIREAL := If(Empty(dTRBDTPPIN),dTRBDTMPI,dTRBDTPPIN)
				hINIREAL := IF(Empty(cTRBHOPPIN),cTRBHOMPI,cTRBHOPPIN)
				dFIMREAL := If(Empty(dTRBADTPPFI),dTRBDTMPF,dTRBADTPPFI)
				hFIMREAL := If(Empty(cTRBHOPPFIM),cTRBHOMPF,cTRBHOPPFIM)

				dbSelectArea("ST9")
				nRegST9 := Recno()
				If STF->TF_PARADA == "S" .Or. STF->TF_PARADA == "T"
					A265BEM(dINIREAL,hINIREAL,dFIMREAL,hFIMREAL,dDTMPINI,STF->TF_PARADA,;
					STF->TF_CODBEM,ST9->T9_CCUSTO,cVORDEM,cVPLANO)
				EndIf
				dbSelectArea("ST9")
				dbSetOrder(01)
				dbGoto(nRegST9)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Efetua o bloqueio da Ferramenta se o Bem (ST9) estiver     ³
				//³indicando uma ferramenta (T9_FERRAME)                      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ST9->T9_FERRAME == "F"
					If !Empty(ST9->T9_RECFERR)
						aFER := {}
						AADD(aFER, {"0",ST9->T9_RECFERR,1,dINIREAL,hINIREAL,dFIMREAL,hFIMREAL,cVORDEM,cVPLANO,cCCUSTO})
						A330FER(aFER[1],ST9->T9_CODBEM)
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

Return .T.


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A265BEM   ³ Autor ³ Elisangela Costa      ³ Data ³18/06/07  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Bloqueio do Bem (Recurso) para a manutencao                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³MNTA265                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³dINI - Data de padara ou data da manutencao prevista inic.  ³±±
±±³          ³hINI - Hora de parada ou hora da manutencao prevista inic.  ³±±
±±³          ³dFIM - Data de padara ou data da manutencao prevista fim    ³±±
±±³          ³hFIM - Hora de parada ou hora da manutencao prevista fim    ³±±
±±³          ³dDTMPINI- Data da manutenção prevista inicio anterior a alt.³±±
±±³          ³cPARADA - Situacao de parada do bem para manutencao         ³±±
±±³          ³cCODBEM - Codigo do bem                                     ³±±
±±³          ³cCCUSTO - Centro de Custo                                   ³±±
±±³          ³cVORDEM - Codigo da Ordem de Servico                        ³±±
±±³          ³cVPLANO - Codigo do Plano                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³OBS       ³Se existir bloqueio para o periodo gera problema.           ³±±
±±³          ³Se o bloqueio for parcial gera problema e bloqueia o        ³±±
±±³          ³restante do periodo                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A265BEM(dINI,hINI,dFIM,hFIM,dDTMPINI,cPARADA,cCODBEM,cCCUSTO,cVORDEM,cVPLANO)
	Local lPROBLEMA := .F.,dDATA := dINI,aBEM := {},aBEM2 := {},cCOD,i
	Local lBlqueio  := .f., lGeraBlqB := .t.

	cCOD := cCODBEM
	AADD(aBEM,cCOD)
	ST3->(dbSetOrder(3))
	SH9->(dbSetOrder(1))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Efetua o bloqueio do Bem Filho Para o Bem Pai              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPARADA == "T"
		STC->(dbSetOrder(3))

		While .T.
			If !STC->(dbSeek(xFILIAL("STC")+cCOD))
				Exit
			EndIf
			cCOD := STC->TC_CODBEM
			AADD(aBEM,cCOD)
		End
		STC->(dbSetOrder(2))
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Efetua o bloqueio do Bem Pai Para o Bem Filho              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cCOD := cCODBEM
	STC->(dbSetOrder(1))

	If STC->(dbSeek(xFILIAL("STC")+cCOD))
		While !Eof() .And.  cCOD == STC->TC_CODBEM
			AADD(aBEM,STC->TC_COMPONE)
			AADD(aBEM2,STC->TC_COMPONE)
			STC->(dbSkip())
		End While
	EndIf

	For i := 1 To Len(aBEM2)
		a330REBLOQ(aBEM2[i], @aBEM)
	Next
	STC->(dbSetOrder(2))

	//Deleta os bloqueios de Recursos de componentes da estrutura
	If cPARADA == "T"
		For i := 1 To Len(aBEM)
			If aBEM[i] <> cCODBEM
				dbSelectArea("ST9")
				dbSetOrder(01)
				If dbSeek(xFilial("ST9")+aBEM[i])
					If ST9->T9_FERRAME == "R" .And. !Empty(ST9->T9_RECFERR)

						dbSelectArea("SH9")
						dbSetOrder(4)
						dbSeek(xFILIAL("SH9")+"B"+DTOS(dDTMPINI))
						While !Eof() .And. H9_FILIAL+H9_TIPO+DTOS(H9_DTINI) == xFILIAL("SH9")+"B"+DTOS(dDTMPINI)

							cMOTIVO := STR0062+cVORDEM+STR0063+cVPLANO  //"OS.MANUT."###" PLANO "
							If Trim(cMOTIVO) == Trim(SH9->H9_MOTIVO) .And.  SH9->H9_ORIGEM == "1"
								//desfazer SGT na versao 12 (verificar com a Totvs)
								If AliasInDic("SGT")
									SGT->(dbSetOrder(1))
									If SGT->(dbSeek(xFilial("SGT")+SH9->(H9_TIPO+H9_CCUSTO+H9_RECURSO+DTOS(H9_DTINI)+H9_HRINI)))
										RecLock("SGT",.F.)
										SGT->(dbDelete())
										SGT->(MsUnLock())
									EndIf
								EndIf
								RecLock("SH9",.F.)
								dbDelete()
								SH9->(MsUnLock())
							EndIf
							dbSkip()
						End
						Exit
					EndIf
				EndIf
			EndIf
		Next i
	EndIf

	i := 1
	Do While .T.

		cCOD := aBEM[i]
		lREC := .F.

		dbSelectArea("ST9")
		dbSetOrder(1)
		ST9->(dbSeek(xFILIAL("ST9")+cCOD))
		If !Empty(ST9->T9_FERRAME) .And.  !Empty(ST9->T9_RECFERR)
			dbSelectArea("SH1")
			dbSetOrder(1)
			lREC := SH1->(dbSeek(xFILIAL("SH1")+ST9->T9_RECFERR) )

			Do While .T.
				If dDATA > dFIM
					Exit
				EndIf
				If lREC
					dbSelectArea("SH9")
					dbSetOrder(1)
					If SH9->(dbSeek(xFILIAL("SH9")+"B"+cCCUSTO+cCOD))
						If SH9->H9_DTINI <= dDATA .And.  SH9->H9_DTFIM >= dDATA
							lPROBLEMA := .T.
							Exit
						EndIf
					EndIf
				Else
					dbSelectArea("ST3")
					dbSetOrder(1)
					If ST3->(dbSeek(xFILIAL("ST3")+cCOD))
						If ST3->T3_DTINI <= dDATA .And.  ST3->T3_DTFIM >= dDATA
							lPROBLEMA := .T.
							Exit
						EndIf
					EndIf
				EndIf
				dDATA++
			EndDo
		EndIf

		If lPROBLEMA
			dbSelectArea("STA")
			RecLock("STA",.T.)
			Replace TA_FILIAL  With xFILIAL("STA"),;
			TA_ORDEM   With cVORDEM        ,;
			TA_PLANO   With cVPLANO        ,;
			TA_TIPOREG With "B"            ,;
			TA_CODIGO  With cCOD           ,;
			TA_DESCRIC With STR0064 //"BEM NAO DISPONIVEL"
			STA->(MsUnLock())

			If cCOD = cCODBEM
				lBlqueio := .t.
				NGCANCOSBLO()
			Endif

		EndIf
		cMOTIVO := STR0062+cVORDEM+STR0063+cVPLANO //"OS.MANUT."###" PLANO "
		If lREC
			//desfazer SGT na versao 12 (verificar com a Totvs)
			If AliasInDic("SGT")
				RecLock("SGT",.T.)
				Replace SGT->GT_FILIAL  With xFILIAL("SGT")  ,;
				SGT->GT_RECURSO With ST9->T9_RECFERR ,;
				SGT->GT_CCUSTO  With cCCUSTO         ,;
				SGT->GT_MOTIVO  With cMOTIVO         ,;
				SGT->GT_DTINI   With dINI            ,;
				SGT->GT_DTFIM   With dFIM            ,;
				SGT->GT_HRINI   With hINI            ,;
				SGT->GT_HRFIM   With hFIM            ,;
				SGT->GT_TIPO    With "B"             ,;
				SGT->GT_ORIGEM  With "1"
				SGT->(MsUnLock())
			EndIf
			dbSelectArea("SH9")
			RecLock("SH9",.T.)
			Replace H9_FILIAL  With xFILIAL("SH9")  ,;
			H9_RECURSO With ST9->T9_RECFERR ,;
			H9_CCUSTO  With cCCUSTO         ,;
			H9_MOTIVO  With cMOTIVO         ,;
			H9_DTINI   With dINI            ,;
			H9_DTFIM   With dFIM            ,;
			H9_HRINI   With hINI            ,;
			H9_HRFIM   With hFIM            ,;
			H9_TIPO    With "B"             ,;
			H9_ORIGEM  With "1"
			SH9->(MsUnLock())
		Else
			dbSelectArea("ST3")
			RecLock("ST3",.T.)
			Replace T3_FILIAL With xFILIAL("ST3"),;
			T3_CODBEM With cCOD           ,;
			T3_MOTIVO With cMOTIVO        ,;
			T3_DTINI  With dINI           ,;
			T3_HRINI  With hINI           ,;
			T3_DTFIM  With dFIM           ,;
			T3_HRFIM  With hFIM           ,;
			T3_PLANO  With cVPLANO        ,;
			T3_ORDEM  With cVORDEM

			ST3->(MsUnLock())
		EndIf
		If Len(aBEM) <= i .Or. !lGeraBlqB
			Exit
		EndIf
		i++
	EndDo
	ST3->(dbSetOrder(1))

Return NiL

//--------------------------------------------------------------------------------------------------
/*/{Protheus.doc} M265BLOPLA
Gera bloqueio de insumos para OS de planos preventivos

@author	Elisangela Costa
@since	18/06/07

@param cVORDEM , Caracter, Codigo da Ordem de Servico
@param cVPLANO , Caracter, Codigo do Plano

@sample M265BLOPLA()

@obs Se existir bloqueio para o periodo gera problema.
Se o bloqueio for parcial gera problema e bloqueia o restante do periodo

@return

/*/
//---------------------------------------------------------------------------------------------------
Function M265BLOPLA(cVORDEM,cVPLANO)

	Local nSEQDOS     := IIf(lSEQREL, Val(STL->TL_SEQRELA), STL->TL_SEQUENC)
	Local i           := 0
	Local aArraySC    := {}

	Private aARRAYSTL := {}

	M->TI_PLANO := cVPLANO

	dbSelectArea("STL")
	dbSetOrder(1)
	dbSeek(xFilial("STL")+cVORDEM+cVPLANO)
	Do While !Eof() .And. STL->TL_ORDEM == cVORDEM .And. STL->TL_PLANO == cVPLANO .And. xFilial("STL") == STL->TL_FILIAL

		aArraySC := {STL->TL_ORDEM, STL->TL_CODIGO, STL->TL_NUMSC, STL->TL_ITEMSC}

		//Verificar se existe S.A. baixada e nao envia o insumo
		If nSEQDOS = 0 .And. MNT420BSA(STL->TL_NUMSA, STL->TL_ITEMSA, .F., aArraySC)
			Aadd(aARRAYSTL,{STL->TL_TIPOREG,STL->TL_CODIGO,STL->TL_QUANTID,;
						STL->TL_QUANREC,STL->TL_DTINICI,STL->TL_HOINICI,;
						STL->TL_DTFIM,STL->TL_HOFIM,STL->TL_TAREFA,STL->TL_LOCAL,;
						STL->TL_NUMSA, STL->TL_ITEMSA, STL->TL_UNIDADE,;
						STL->TL_OBSERVA,STL->TL_FORNEC, STL->TL_LOJA, STL->TL_NUMSC,STL->TL_ITEMSC})
		EndIf

		dbSelectArea("STL")
		dbSkip()

	EndDo

	If Len(aARRAYSTL) > 0

		aBLO := { {},{},{},{},{}}
		Processa({ |lEnd| MNTA490PT(cVPLANO,cVORDEM)}, STR0055) //"Aguarde ..Preparando Para Gerar Insumos..."


		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Efetua o bloqueio de Ferramentas                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For i := 1 To Len(aBLO[1])
			A330FER(aBLO[1][i])
		Next

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Efetua o bloqueio de Mao de Obras (FUNCIONARIO)            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For i := 1 To Len(aBLO[2])
			A330FUN(aBLO[2][i])
		Next

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Efetua o bloqueio de Produtos                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For i := 1 To Len(aBLO[4])
			A330PRO(aBLO[4][i])
		Next
	EndIf

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MNT265PROB³ Autor ³Elisangela Costa       ³ Data ³02/07/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Lista os problemas da Ordem de Servico                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cVORDEM - Codigo da Ordem de Servico                        ³±±
±±³          ³cVPLANO - Codigo do Plano da OS                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA265                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNT265PROB(cVORDEM,cVPLANO)
	Local oMenu
	Local oBrw, n := 1
	Local oDlg
	Private aPROBLEMOS := {}

	dbSelectArea("STA")
	dbSetOrder(1)
	If dbSeek(xFILIAL("STA")+cVORDEM+cVPLANO)

		While !Eof() .And. STA->TA_FILIAL+STA->TA_ORDEM+STA->TA_PLANO == xFILIAL("STA")+cVORDEM+cVPLANO
			AADD(aPROBLEMOS,{STA->TA_TIPOREG,STA->TA_CODIGO,M265DESCIN(STA->TA_CODIGO,STA->TA_TIPOREG),STA->TA_DESCRIC})
			dbSkip()
		End

		Define Dialog oDlg From 12.5,16 To 34,90 Title STR0065+cVORDEM //"Problemas da OS >> "

		@ .30,0.5 Listbox oBrw Fields aPROBLEMOS[n][1],;
		aPROBLEMOS[n][2],;
		aPROBLEMOS[n][3],;
		aPROBLEMOS[n][4];
		headers STR0066,STR0067,STR0068,STR0069;              //"Tipo Insumo"###"Insumo"###"Descrição"###"Descrição Problema"
		fieldsizes 35,45,70,60;
		Of oDlg Size 285,140

		oBrw:bGotop    := { || n := 1 }
		oBrw:bGoBottom := { || n := eval( oBrw:bLogicLen ) }
		oBrw:bSkip     := { | nwant, nold | nold := n , n += nwant,;
		n := max( 1, min( n, eval( oBrw:bLogicLen ))),n - nOld }
		oBrw:bLogicLen := { || Len(aPROBLEMOS) }
		oBrw:cAlias    := "Array"
		NGPOPUP(aSMenu,@oMenu)
		oDlg:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDlg)}
		Activate Dialog oDlg CENTERED

	Else
		MsgInfo(STR0070 ,STR0041) //"A OS não possui problemas."###"ATENÇÃO"
		Return .T.
	EndIf

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³M265DESCIN³ Autor ³Elisangela Costa       ³ Data ³02/07/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna a descricao do insumo confornme tipo do insumo      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cCODINS  - Codigo do Insumo                                 ³±±
±±³          ³cTIPOINS - Tipo do Insumo                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA265                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function M265DESCIN(cCODINS,cTIPOINS)

	Local cDESCRINS := " ", cCODSTL

	If cTIPOINS == "M"
		cCODSTL := Substr(cCODINS,1,Len(ST1->T1_CODFUNC))
		cDESCRINS := NGSEEK("ST1",cCODSTL,1,'SubStr(T1_NOME,1,30)')

	ElseIf cTIPOINS == "P"
		cCODSTL := Substr(cCODINS,1,Len(SB1->B1_COD))
		cDESCRINS := NGSEEK("SB1",cCODSTL,1,'SubStr(B1_DESC,1,30)')

	ElseIf cTIPOINS == "T"
		cCODSTL := Substr(cCODINS,1,Len(SA2->A2_COD))
		cDESCRINS := NGSEEK("SA2",cCODSTL,1,'SubStr(A2_NOME,1,30)')

	ElseIf cTIPOINS == "F"
		cCODSTL := Substr(cCODINS,1,Len(SH4->H4_CODIGO))
		cDESCRINS := NGSEEK("SH4",cCODSTL,1,'SubStr(H4_DESCRI,1,25)')

	ElseIf cTIPOINS == "E"
		cCODSTL := Substr(cCODINS,1,Len(ST0->T0_ESPECIA))
		cDESCRINS := NGSEEK("ST0",cCODSTL,1,'SubStr(T0_NOME,1,30)')

	ElseIf cTIPOINS == "B"
		cCODSTL := cCODINS+Space(1)
		cDESCRINS := NGSEEK("ST9",cCODSTL,1,'SubStr(T9_NOME,1,30)')

	EndIf

Return cDESCRINS

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT265IMP
Funcao de impressao das OS que estao marcadas

@return Nil

@sample
MNT265IMP()

@author Elisangela Costa
@since 06/09/2007
@version 1.0
/*/
//---------------------------------------------------------------------
Function MNT265IMP()

	Local aMATSX1 := {}
	Local aMATOS  := {}
	Local dMENOR  := CtoD('  /  /  ')
	Local dMAIOR  := dMENOR
	Local nTipOs  := 3 //Valor 3 referente a todas as OS's diferente de canceladas.
	Local cMEORD  := Space(Len(stj->tj_ordem))
	Local cMAORD  := cMEORD
	Local cMEPLA  := Space(Len(stj->tj_plano))
	Local cMAPLA  := cMEPLA
	Local cBemMe  := ""
	Local cBemMa  := ""
	Local cCTrabM := ""
	Local cCTrabP := ""
	Local lTemOs  := .F.

	dbSelectArea(cTRBA490)
	nRecTRBA := Recno()
	dbGotop()
	While !Eof()
		If !Empty((cTRBA490)->TJ_OK)
			lTemOs := .T.
			If Empty(dMENOR)
				dMENOR  := (cTRBA490)->TJ_DTMPINI
				dMAIOR  := dMENOR
				cMEORD  := (cTRBA490)->TJ_ORDEM
				cBemMe  := (cTRBA490)->TJ_CODBEM
				cBemMa  := (cTRBA490)->TJ_CODBEM
				cMAORD  := cMEORD
				cMEPLA  := (cTRBA490)->TJ_PLANO
				cMAPLA  := cMEPLA
				cMECC   := (cTRBA490)->TJ_CCUSTO
				cMACC   := cMECC
				cMECOD  := (cTRBA490)->TJ_CODAREA
				cMACOD  := cMECOD
				cCTrabM := (cTRBA490)->TJ_CENTRAB
				cCtrabP := (cTRBA490)->TJ_CENTRAB
			Else
				dMENOR := Min(dMENOR,(cTRBA490)->TJ_DTMPINI)
				dMAIOR := Max(dMAIOR,(cTRBA490)->TJ_DTMPINI)

				If (cTRBA490)->TJ_CENTRAB < cCTrabP
			    	cCTrabP := (cTRBA490)->TJ_CENTRAB
				EndIf

				If (cTRBA490)->TJ_CENTRAB > cCTrabM
					cCTrabM := (cTRBA490)->TJ_CENTRAB
				EndIf

				If (cTRBA490)->TJ_CODBEM < cBemMe
					cBemMe := (cTRBA490)->TJ_CODBEM
				EndIf

				If (cTRBA490)->TJ_CODBEM > cBemMa
					cBemMa := (cTRBA490)->TJ_CODBEM
				EndIf

				If (cTRBA490)->TJ_ORDEM < cMEORD
					cMEORD := (cTRBA490)->TJ_ORDEM
				EndIf

				If (cTRBA490)->TJ_ORDEM > cMAORD
					cMAORD := (cTRBA490)->TJ_ORDEM
				EndIf

				If (cTRBA490)->TJ_PLANO < cMEPLA
					cMEPLA := (cTRBA490)->TJ_PLANO
				EndIf

				If (cTRBA490)->TJ_PLANO > cMAPLA
					cMAPLA := (cTRBA490)->TJ_PLANO
				EndIf

				If (cTRBA490)->TJ_CCUSTO < cMECC
					cMECC := (cTRBA490)->TJ_CCUSTO
				EndIf

				If (cTRBA490)->TJ_CCUSTO > cMACC
					cMACC := (cTRBA490)->TJ_CCUSTO
				EndIf

				If (cTRBA490)->TJ_CODAREA < cMECOD
					cMECOD := (cTRBA490)->TJ_CODAREA
				EndIf

				If (cTRBA490)->TJ_CODAREA > cMACOD
					cMACOD := (cTRBA490)->TJ_CODAREA
				EndIf

			EndIf

			AADD(aMATOS,{(cTRBA490)->TJ_PLANO,(cTRBA490)->TJ_ORDEM})

		EndIf
		dbSkip()
	End
	If !lTemOs
		MNTA265MAR()
	EndIf

	If ExistBlock("IMPOSMNT")

		aMATSX1 := {{'01',cMEPLA},{'02',cMAPLA},;
					{'03',cBemMe},{'04',cBemMa},;
					{'05',cMEORD},{'06',cMAORD},;
					{'07',cMEORD},{'08',cMAORD},;
					{'15',dMENOR},{'16',dMAIOR},;
					{'25',nTipOs}}

		If Dtos(Ctod(aMATSX1[8,2])) < Dtos(Ctod(aMATSX1[7,2]))
			dTAUXI := aMATSX1[7,2]
			aMATSX1[7,2] := aMATSX1[8,2]
			aMATSX1[8,2] := dTAUXI
		EndIf

	ElseIf lTemOs

		aMATSX1 := {{'01',cMEPLA},{'02',cMAPLA},;
					{'07',cMECC},{'08',cMACC},;
					{'09',cCTrabP},{'10',cCTrabM},;
					{'11',cMECOD},{'12',cMACOD},;
					{'13',cMEORD},{'14',cMAORD},;
					{'15',dMENOR},{'16',dMAIOR},;
					{'25',nTipOs}}

		//Array para o relatorio MNTR676
		aMATSX16 := {{'01',cMEPLA},{'02',cMAPLA},;
					 {'03',cBemMe},{'04',cBemMa},;
					 {'05',cMEORD},{'06',cMAORD},;
					 {'07',Dtoc(dMENOR)},{'08',Dtoc(dMAIOR)},;
					 {'10',nTipOs}}

		If Dtos(aMATSX1[12,2]) < Dtos(aMATSX1[11,2])
			dTAUXI := aMATSX1[11,2]
			aMATSX1[11,2] := aMATSX1[12,2]
			aMATSX1[12,2] := dTAUXI
		EndIf

	EndIf

	If ExistBlock("IMPOSMNT")
		ExecBlock( 'IMPOSMNT', .F., .F., { .F., cMEPLA, cMAPLA, aMATOS } )
	ElseIf ExistBlock("MNTIMPOS")
		If !ExecBlock("MNTIMPOS",.F.,.F.,{stj->tj_plano,stj->tj_ordem,stj->tj_dtmpini,cMEPLA,cMAPLA,aMATOS})
			Return
		EndIf
	ElseIf lTemOs
		MNTR676(.F.,cMEPLA,cMAPLA,aMATOS,,aMATSX16,aMATSX1)
	EndIf

	dbSelectArea(cTRBA490)
	dbGoto(nRecTRBA)

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MNTA265FIL³ Autor ³Rafael Diogo Ristcher  ³ Data ³06/09/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Faz o filtro das Os do browse                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MNTA265                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MNTA265FIL()

	cFiltSTJ := BuildExpr( 'STJ', cFiltSTJ, , .T. )

	dbSelectArea( cTRBA490 )
	Zap

	Processa( { |lEnd| MNTA265OS() }, STR0039 ) //"Aguarde ..Processanto Arquivo de O.S."
	
	dbSelectArea( cTRBA490 )
	dbGoTop( )

Return .t.
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MNTA490MAR³ Autor ³Inacio Luiz Kolling    ³ Data ³25/04/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Consistencia de item marcado                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MNTA490                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MNTA265MAR()
	If Empty((cTRBA490)->TJ_OK)
		MsgInfo("Nao foi selecionado o item","ATENCAO")
		Return .f.
	Endif
Return .t.

//----------------------------------------------------------------------
/*/{Protheus.doc} fAltInsPrv
Verifica se insumo previsto passou por alguma alteração.
@type function

@author	Alexandre Santos
@since	31/08/2021

@param nRecNo  , numeric, RECNO do registro em validação.
@return boolean, Indica se o insumo posicionado sofreu alguma alteração.
/*/
//----------------------------------------------------------------------
Function fAltInsPrv( nRecNo )

	Local aAreaALL := GetArea()
	Local aAreaSTL := STL->( GetArea() )
	Local cAlsTemp := GetNextAlias()
	Local cTblTemp := '%' + oTmpTbl1:GetRealName() + '%'
	Local cWhere   := ''
	Local lRet     := .F.

	If !Empty( nRecNo )
	
		dbSelectArea( 'STL' )
		dbGoTo( nRecNo )

		If Trim( STL->TL_SEQRELA ) == '0'

			cWhere := "% OR "

			If STL->TL_TIPOREG == 'M'

				cWhere += "TEMP.TL_DTINICI <> " + ValToSQL( STL->TL_DTINICI ) + " OR "
				cWhere += "TEMP.TL_HOINICI <> " + ValToSQL( STL->TL_HOINICI ) + " OR "
				cWhere += "TEMP.TL_USACALE <> " + ValToSQL( STL->TL_USACALE ) + "%"

			Else

				cWhere += "TEMP.TL_LOCAL   <> " + ValToSQL( STL->TL_LOCAL )   + " OR "
				cWhere += "TEMP.TL_QUANTID <> " + ValToSQL( STL->TL_QUANTID ) + " OR "
				cWhere += "TEMP.TL_QUANREC <> " + ValToSQL( STL->TL_QUANREC ) + "%"

			EndIf
				
			cAlsTemp := GetNextAlias()

			BeginSQL Alias cAlsTemp

				SELECT
					R_E_C_N_O_ AS REC
				FROM
					%exp:cTblTemp% TEMP
				WHERE
					TEMP.RECNO = %exp:nRecNo% AND
					(	TEMP.TL_TAREFA  <> %exp:STL->TL_TAREFA%  OR
						TEMP.TL_TIPOREG <> %exp:STL->TL_TIPOREG% OR
						TEMP.TL_CODIGO  <> %exp:STL->TL_CODIGO%  OR
						TEMP.STATUS = 3 %exp:cWhere% )
					
			EndSQL

			lRet := (cAlsTemp)->( !EoF() )

			(cAlsTemp)->( dbCloseArea() )

		EndIf

	Else

		lRet := .T.

	EndIf

	RestArea( aAreaSTL )
	RestArea( aAreaALL )

Return lRet

//-----------------------------------------------------------------------------------
/*/{Protheus.doc} fVersion
Valida a versão de fontes relacionado, consistindo se é necessário atualizações.
@type function

@author Alexandre Santos
@since 21/09/2022

@return boolean  , Define se a rotina e suas dependências encontram-se atualziadas.
/*/
//-----------------------------------------------------------------------------------
Static Function fVersion()

	Local aVersion := {}
	Local lRet     := .T.

	aVersion := { { 'MNTA490.prx', SToD( '20220923' ), '08:00' } }
		
	If !( lRet := NgVldRpo( aVersion ) )

		NGMSGMEMO( STR0041,; // Atenção
			STR0081 ) // Para a correta utilização da rotina deve-se realizar a aplicação do pacote acumulado de atualizações.

	EndIf
	
Return lRet
