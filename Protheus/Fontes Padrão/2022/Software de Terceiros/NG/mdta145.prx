#Include "mdta145.ch"
#Include "Protheus.ch"

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTA145
Programa Cadastros de Questionario Medico - FICHAS MEDICAS

@author  Inacio Luiz Kolling
@since   04/04/2000
@return  Lógico, Sempre verdadeiro
/*/
//-------------------------------------------------------------------
Function MDTA145()

	Local aNGBEGINPRM := NGBEGINPRM() //Guarda conteudo e declara variaveis padroes
	Local cPerg :=  PADR( "MDT145" , 10 ) //Grupo de perguntas

	aOldMenu := ACLONE(asMenu) //Armazena variaveis p/ devolucao (NGRIGHTCLICK)

	If (NGCADICBASE("TQC_PROGRA","D","TQC",.F.) .And. NGCADICBASE("TQD_PROGRA","D","TQD",.F.))
		asMenu := NGRIGHTCLICK("MDTA145")
	Else
		asMenu  := {{STR0016,"MDTA120A"}}  //"Exames do Funcionario"
	EndIf

	Private aTrocaF3   := {}, aNGFIELD := {}
	aPos1 := {  15,  1, 95,315 }

	Private aRotina := MenuDef()
	Private lSigaMdtPS := If( SuperGetMv("MV_MDTPS",.F.,"N") == "S", .t. , .f. )
	Private lCombo2 := NGCADICBASE("TMH_COMBO2","D","TMH",.F.)

	//Define o cabecalho da tela de atualizacoes
	Private cCadastro	:= STR0048 //"Dados Quest."
	Private aCHKDEL		:= {}, bNGGRAVA
	Private nSizeCli, nSizeLoj
	Private cPrograma	:= "MDTA145"
	Private cCliMdtPs
	Private aCadTipo	:= {} //Array contendo informações das pergutas do quest.

	nSizeCli := If((TAMSX3("A1_COD")[1]) < 1,6,(TAMSX3("A1_COD")[1]))
	nSizeLoj := If((TAMSX3("A1_LOJA")[1]) < 1,2,(TAMSX3("A1_LOJA")[1]))

	If FindFunction("MDTRESTRI") .AND. !MDTRESTRI(cPrograma)
		NGRETURNPRM(aNGBEGINPRM) // Devolve variaveis armazenadas (NGRIGHTCLICK)
		Return .F.
	Endif

	Pergunte( cPerg , .F. ) //Efetua as perguntas.

	SetKey( VK_F12 , { | | MDT145OBD(cPerg)} ) // Adiciona funcionalidade ao F12

	If lSigaMdtPS
		dbSelectArea("SA1")
		dbSetOrder(1)
		mBrowse( 6, 1,22,75,"SA1")
	Else
		MDT145CAD()
	Endif

	NGRETURNPRM(aNGBEGINPRM) //Retorna conteudo de variaveis padroes
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} fFunCor
Funcao p/ definir cores p/ as situacoes dos funcionarios.

@author  Taina Alberto Cardoso
@since   14/04/2010
@return  aCores, array, legenda correspondente a situação do
funcionário.
/*/
//-------------------------------------------------------------------
Function fFunCor()

	Local aCores := { ;
						{ "FuSeek(TM0->TM0_FILFUN,TM0->TM0_MAT,'SRA->RA_RESCRAI') $  '30/31'",  'BR_PINK'		}  ,;
						{ "FuSeek(TM0->TM0_FILFUN,TM0->TM0_MAT,'SRA->RA_SITFOLH') == ' '"    ,  'BR_VERDE'		}	,;
						{ "FuSeek(TM0->TM0_FILFUN,TM0->TM0_MAT,'SRA->RA_SITFOLH') == 'D'"    ,  'BR_VERMELHO'	}	,;
						{ "FuSeek(TM0->TM0_FILFUN,TM0->TM0_MAT,'SRA->RA_SITFOLH') == 'A'"    ,  'BR_AMARELO'	}	,;
						{ "FuSeek(TM0->TM0_FILFUN,TM0->TM0_MAT,'SRA->RA_SITFOLH') == 'F'"    ,  'BR_AZUL'		}  ,;
						{ "FuSeek(TM0->TM0_FILFUN,TM0->TM0_MAT,'SRA->RA_SITFOLH') == 'I'"    ,  'BR_LARANJA'	}   ;
					}

Return(aCores)

//-------------------------------------------------------------------
/*/{Protheus.doc} MDT145CAD
Monta um browse com as fichas do cliente, e chama as funcoes
para visualizar, incluir, excluir, alterar, etc.

@author  Denis Hyroshi de Souza
@since   08/07/01
@return  uRet, Sempre Nulo
/*/
//-------------------------------------------------------------------
Function MDT145CAD()

	Local aArea			:= GetArea()
	Local oldROTINA := aCLONE(aROTINA)
	Local uRet
	Local oldCad := cCadastro
	Local aIndexTM0		:= {}

	Private aTROCAF3 := {}
	Private aCHKDEL := {}, bNGGRAVA
	Private DTVALIDA  := .T.
	Private bFiltraBrw	:= { || NIL }
	Private wnrel := "MDTA145"

	If lSigaMdtPS
		cCliMdtPs := SA1->A1_COD+SA1->A1_LOJA

		aRotina := {{ STR0004 , "AxPesqui"   , 0 , 1          } ,;	//"Pesquisar"
					{ STR0005 , "NGCAD01"    , 0 , 2          } ,;  //"Visual."
					{ STR0006 , "MDTA145A" , 0 , 4 , 0      } ,; 	//"Questionario"
					{ STR0025 , "GpLegend"   , 0 , 6 , 0 , .F.}  } 	//"Legenda"

		cCadastro := OemToAnsi(STR0007+STR0018+Alltrim(SA1->A1_NOME)) //" do Cliente: "

		// Inicializa o filtro utilizando a funcao FilBrowse
		cFiltraRh := ChkRh("MDTA145","TM0","1")
		cFiltraRh += IF(!Empty(cFiltraRh),' .and. ','')
		cFiltraRh += 'TM0_CLIENT+TM0_LOJA == "'+cCliMdtPs+'"'
		bFiltraBrw := { || FilBrowse("TM0",@aIndexTM0,@cFiltraRH) }
		Eval( bFiltraBrw )

		TM0->( dbGoTop() )
		mBrowse( 6, 1,22,75,"TM0",,,,,,fFunCor() )
		//Deleta o filtro utilizando a funcao FilBrowse
		EndFilBrw( "TM0" , aIndexTm0 )
	Else
		dbSelectArea("TM0")
		dbSetOrder(1)
		mBrowse( 6, 1,22,75,"TM0",,,,,,fFunCor() )

	Endif

	aROTINA := aCLONE(oldROTINA)
	RestArea(aArea)
	cCadastro := oldCad

Return uRet
//-------------------------------------------------------------------
/*/{Protheus.doc} MenuDef
Utilização de Menu Funcional.
Parametros do array aRotina:
	1. Nome a aparecer no cabecalho
	2. Nome da Rotina associada
	3. Reservado
	4. Tipo de Transação a ser efetuada:
		1 - Pesquisa e Posiciona em um Banco de Dados
		2 - Simplesmente Mostra os Campos
		3 - Inclui registros no Bancos de Dados
		4 - Altera o registro corrente
		5 - Remove o registro corrente do Banco de Dados
	5. Nivel de acesso
	6. Habilita Menu Funcional

@author  Rafael Diogo Richter
@since   29/11/2006
@return  aRotina, Array,  Contém as opções da rotina.
/*/
//-------------------------------------------------------------------
Static Function MenuDef()

	Local lSigaMdtPS := If( SuperGetMv("MV_MDTPS",.F.,"N") == "S", .t. , .f. )
	Local aRotina

	If !lSigaMdtPS
		aRotina :=	{  { STR0004 , "AxPesqui"   , 0 , 1          } ,; //"Pesquisar"
					{ STR0005 , "NGCAD01"    , 0 , 2          } ,; //"Visual."
					{ STR0006 , "MDTA145A" , 0 , 4 ,0       } ,; //"Questionario"
					{ STR0025 , "GpLegend"   , 0 , 6 , 0, .F. } } //"Legenda"
	Else
		aRotina :=	{ { STR0004, "AxPesqui"  , 0 , 1},;  //"Pesquisar"
					{ STR0005, "NGCAD01"   , 0 , 2},;  //"Visualizar"
					{ STR0020, "MDT145CAD" , 0 , 4}}   //"Fichas Médicas"
	Endif

Return aRotina

//-------------------------------------------------------------------
/*/{Protheus.doc} MDT145QUESTA
Valida o campo TMI_QUESTA

@author  Inacio Luiz Kolling
@since   04/04/2000
@return  Lógico, Verdadeiro se o compo for válido.
/*/
//-------------------------------------------------------------------
Function MDT145QUESTA()

Return EXISTCPO("TMH",cCliMdtps+M->TMI_QUESTI+M->TMI_QUESTA,2) .And. EXISTCHAV("TMI",M->TMI_NUMFIC+DTOS(M->TMI_DTREAL)+M->TMI_QUESTI+M->TMI_QUESTA)

//-------------------------------------------------------------------
/*/{Protheus.doc} fRetBox145
Mostra campo de acordo com item selecionado

@author  Denis Hyroshi de Souza
@since   15/01/2010
@return  Nil, Sempre Nulo
/*/
//-------------------------------------------------------------------
Function fRetBox145()

	Local nInitcBox ,aCombo:={}, nTam
	Local nTamCpo := Len(aCols[n][nRESPOS])
	Local cCampo  := ""
	Local cCombo  := ""
	Local cComboRes:= If (NGCADICBASE( "TMH_RESPOS", "A", "TMH", .F. ), "TMH->TMH_RESPOS", "TMH->TMH_COMBO+TMH->TMH_COMBO2" )

	If lSigaMdtps
		nTMHi := NGRETORDEM("TMH","TMH_FILIAL+TMH_CLIENT+TMH_LOJA+TMH_QUESTI+TMH_QUESTA",.T.)
		If nTMHi == 0
			nTMHi := 1
		Endif
		dbSelectArea("TMH")
		dbSetOrder(nTMHi)
		dbSeek( xFilial("TMH") + cCliMdtps + M->TMI_QUESTI + aCols[n,nQUESTA])
	Else
		dbSelectArea("TMH")
		dbSetOrder(1)
		dbSeek( xFilial("TMH") + M->TMI_QUESTI + aCols[n,nQUESTA] )
	Endif
	cCombo := Alltrim( &cComboRes )
	If Empty(cCombo)
		cCombo := "1="+Capital(STR0022)+";"+"2="+Capital(STR0023)+";"+"3="+Capital(STR0024) //Sim //Nao //Sem resposta
	Endif

	If Len(aCols) > 0 .And. n > 0 .And. n <= Len(aCols)
		cCampo := aCols[n][nRESPOS]
		aCombo := RetSx3Box(cCombo,@nInitcBox,@nTam,nTamCpo)
		nIniPos := Ascan(aCombo,{|x| cCampo $ x[2]})
		nIniPos := Iif(nIniPos == 0,Len(aCombo),nIniPos)
		cCampo := aCombo[nIniPos,3]
	EndIf

Return cCampo

//-------------------------------------------------------------------
/*/{Protheus.doc} IMPMDT410
Impressao do relatorio de questionario

@param aValores, Array, Valores dos parâmetros da impressão do relatório

@author  Denis Hyroshi de Souza
@since   30/05/2016
@return  Nil, Sempre Nulo
/*/
//-------------------------------------------------------------------
Function IMPMDT410( aValores )

	Local aVlrs := {}
	Local aDados := {}

	If ValType( aValores ) == "A"
		aVlrs := aValores
	EndIf

	If ExistBlock("MDTA1451")
		Return ExecBlock("MDTA1451",.F.,.F.)
	Endif

	If lSigaMdtps
		aAdd( aDados , { "Mv_par01" , (cAliasQue)->A1_COD } )
		aAdd( aDados , { "Mv_par02" , (cAliasQue)->A1_LOJA } )
		aAdd( aDados , { "Mv_par03" , (cAliasQue)->TMI_QUESTI } )
		aAdd( aDados , { "Mv_par04" , (cAliasQue)->TMI_NUMFIC } )
		aAdd( aDados , { "Mv_par05" , (cAliasQue)->TMI_NUMFIC } )
		aAdd( aDados , { "Mv_par06" , Space(Len((cAliasQue)->TMI_QUESTA)) } )
		aAdd( aDados , { "Mv_par07" , Replicate("Z",Len((cAliasQue)->TMI_QUESTA)) } )
		aAdd( aDados , { "Mv_par08" , (cAliasQue)->TMI_DTREAL } )
		aAdd( aDados , { "Mv_par09" , (cAliasQue)->TMI_DTREAL } )
		aAdd( aDados , { "Mv_par10" , 2 } )
	ElseIf Len( aVlrs ) > 0
		aAdd( aDados , { "Mv_par01" , aVlrs[ 1 ] } )
		aAdd( aDados , { "Mv_par02" , aVlrs[ 2 ] } )
		aAdd( aDados , { "Mv_par03" , aVlrs[ 3 ] } )
		aAdd( aDados , { "Mv_par04" , aVlrs[ 4 ] } )
		aAdd( aDados , { "Mv_par05" , aVlrs[ 5 ] } )               // Filtrar questoes ? ###2
		aAdd( aDados , { "Mv_par06" , aVlrs[ 6 ] } )
		aAdd( aDados , { "Mv_par07" , aVlrs[ 7 ] } )
		aAdd( aDados , { "Mv_par08" , aVlrs[ 8 ] } )               // Tipo impressao ?###1
		aAdd( aDados , { "Mv_par09" , aVlrs[ 9 ] } )               // Perguntas por linhas ?###1
	Else
		aAdd( aDados , { "Mv_par01" , (cAliasQue)->TMI_QUESTI } )
		aAdd( aDados , { "Mv_par02" , (cAliasQue)->TMI_QUESTI } )
		aAdd( aDados , { "Mv_par03" , (cAliasQue)->TMI_NUMFIC } )
		aAdd( aDados , { "Mv_par04" , (cAliasQue)->TMI_NUMFIC } )
		aAdd( aDados , { "Mv_par05" , 2 } )               			// Filtrar questoes ?
		aAdd( aDados , { "Mv_par06" , STOD( (cAliasQue)->TMI_DTREAL ) } )
		aAdd( aDados , { "Mv_par07" , STOD( (cAliasQue)->TMI_DTREAL ) } )
		aAdd( aDados , { "Mv_par08" , 1 } )               			// Tipo impressao ?
		aAdd( aDados , { "Mv_par09" , 1 } )               			// Perguntas por linhas ?
		aAdd( aDados , { "Mv_par10" , IIf( MsgYesNo( STR0057, STR0029 ), 1, 2 ) } ) //"Observações em branco deverão ser impressas?"
	Endif

	MDTR410( aDados )

	//Inicializa a Pergunta de Bloqueio
	Pergunte( "MDT145" , .F. )

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} MDT145IBRW
Inicializador de broswse do campo TMI_DESRES

@author  Denis Hyroshi de Souza
@since   30/05/2016
@return  cRet, Caractere, Valor do campo
/*/
//-------------------------------------------------------------------
Function MDT145IBRW()

	Local OldAlias := GetArea()
	Local cRet := Space(30)
	Local nPos,nPos1,cDesc
	Local cCboxTMH := ""
	Local cComboRes:= If(  NGCADICBASE( "TMH_RESPOS", "D", "TMH", .F. ), "TMH->TMH_RESPOS" , "TMH->TMH_COMBO+TMH->TMH_COMBO2" )
	Local lEditBox := .f.

	If Type("lCombTK0") == "L"
		If lCombTK0
			lEditBox := .t.
		Endif
	Endif

	If TMI->TMI_RESPOS == "1"
		cRet := STR0022 //"SIM"
	ElseIf TMI->TMI_RESPOS == "2"
		cRet := STR0023 //"NAO"
	ElseIf TMI->TMI_RESPOS == "3"
		cRet := STR0024 //"SEM RESPOSTA"
	ElseIf !Empty(TMI->TMI_RESPOS) .and. lEditBox
		If lSigaMdtps
			nTMHi := NGRETORDEM("TMH","TMH_FILIAL+TMH_CLIENT+TMH_LOJA+TMH_QUESTI+TMH_QUESTA",.T.)
			If nTMHi == 0
				nTMHi := 1
			Endif
			dbSelectArea("TMH")
			dbSetOrder(nTMHi)
			If dbSeek(xFilial("TMH")+cCliMdtps+TMI->TMI_QUESTI+TMI->TMI_QUESTA)
				cCboxTMH := &cComboRes
			Endif
		Else
			dbSelectArea("TMH")
			dbSetOrder(01)
			If dbSeek(xFilial("TMH")+TMI->TMI_QUESTI+TMI->TMI_QUESTA)
				cCboxTMH := &cComboRes
			Endif
		Endif

		If !Empty(cCboxTMH)
			nPos := At( Substr(TMI->TMI_RESPOS,1,1)+"=" , cCboxTMH )
			If nPos > 0
				nPos1 := At( ";" , Substr( cCboxTMH , nPos+2 ) )
				cDesc := Alltrim(Substr( cCboxTMH , nPos+2 ))
				If nPos1 > 0
					cDesc := Alltrim(Substr( cCboxTMH , nPos+2 , nPos1-1 ))
				Endif
				cRet := PadR(cDesc,30)
			Endif
		Endif
	Endif

	RestArea(OldAlias)

Return Upper(cRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} fChgGD145
Funcao chamada no WHEN do campo TMI_RESPOS

@author  Denis Hyroshi de Souza
@since   04/04/2000
@return  Lógico, Sempre verdadeiro
/*/
//-------------------------------------------------------------------
Function fChgGD145()

	Local cCombBox := ""
	Local cOldAlias:= Alias()
	Local cComboRes:= If(  NGCADICBASE( "TMH_RESPOS", "D", "TMH", .F. ), "TMH->TMH_RESPOS" , "TMH->TMH_COMBO+TMH->TMH_COMBO2" )
	Local nRESPOS  := aSCAN(aHEADER, {|x| AllTrim(Upper(X[2])) == "TMI_RESPOS" })

	If lSigaMdtps
		nTMHi := NGRETORDEM("TMH","TMH_FILIAL+TMH_CLIENT+TMH_LOJA+TMH_QUESTI+TMH_QUESTA",.T.)
		If nTMHi == 0
			nTMHi := 1
		Endif
		dbSelectArea("TMH")
		dbSetOrder(nTMHi)
		dbSeek( xFilial("TMH") + cCliMdtps + M->TMI_QUESTI + aCols[n,nQUESTA])
	Else
		dbSelectArea("TMH")
		dbSetOrder(1)
		dbSeek( xFilial("TMH") + M->TMI_QUESTI + aCols[n,nQUESTA] )
	Endif

	cCombBox := Alltrim( &cComboRes )
	If Empty(cCombBox)
		cCombBox := "1="+Capital(STR0022)+";"+"2="+Capital(STR0023)+";"+"3="+Capital(STR0024) //Sim //Nao //Sem resposta
	Endif
	oGet:aInfo[nRESPOS][2] := cCombBox
	oGet:oBrowse:Refresh()

	If !Empty(cOldAlias)
		dbSelectArea(cOldAlias)
	Endif

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} f145CHAV
Verifica chave da TMI

@sample f145CHAV( 1 )

@param nTipo, Numérico, tipo de verificação da chave:
1 - Se a chave já existe
2 - Se o funcionário já respondeu ao questionário

@author  Roger Rodrigues
@since   19/04/2010
@return  Lógico, Verdadeiro se a chave é consistente
/*/
//-------------------------------------------------------------------
Function f145CHAV(nTipo)

	Local dDtChav := STOD("")
	Local lTemTMI := .F.
	Default nTipo := 1

	If Inclui
		dDtChav := M->TMI_DTREAL
	ElseIf Altera
		If dOldDtReal <> M->TMI_DTREAL
			dDtChav := M->TMI_DTREAL
		Endif
	Endif
	If !Empty(M->TMI_QUESTI) .And. !Empty(dDtChav)
		If !ExistChav("TMI",M->TMI_NUMFIC+DTOS(dDtChav)+M->TMI_QUESTI)
			Return .F.
		Endif
	Endif

	If Inclui .And. nTipo == 2
		dbSelectArea("TMI")
		dbSetOrder(1)
		dbSeek(xFilial('TMI')+M->TMI_NUMFIC)
		While !Eof() .And. xFilial('TMI')+M->TMI_NUMFIC == TMI->TMI_FILIAL+TMI->TMI_NUMFIC
			If M->TMI_QUESTI == TMI->TMI_QUESTI
				lTemTMI := .T.
				Exit
			Endif
			dbSelectArea("TMI")
			dbSkip()
		End
		If lTemTMI
			Return MsgYesNo(STR0026 + " " + STR0027) //"O funcionário já respondeu este questionário."###"Deseja incluir novamente?"
		Endif
	Endif

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} MDT145VQTI
Valida campo TMI_QUESTI.

@author  Denis Hyroshi de Souza
@since   25/10/2017
@return  Lógico, Verdadeiro se o conteúdo do campo é válido.
/*/
//-------------------------------------------------------------------
Function MDT145VQTI()

	Local lPrest := .F.

	If Type("cCliMdtPs") == "C"
		If !Empty(cCliMdtPs)
			lPrest := .T.
		Endif
	Endif

	If lPrest
		Return (EXISTCPO("TMG",cCliMdtps+M->TMI_QUESTI,2))
	Else
		Return (EXISTCPO("TMG",M->TMI_QUESTI,1))
	Endif

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTTMGVQTI
Valida campo TMI_QUESTI.

@author  Denis Hyroshi de Souza
@since   25/10/2017
@return  Lógico, Verdadeiro se o conteúdo do campo é válido.
/*/
//-------------------------------------------------------------------
Function MDTTMGVQTI()

	Local lPrest := .F.

	If Type("cCliMdtPs") == "C"
		If !Empty(cCliMdtPs)
			lPrest := .T.
		Endif
	Endif

	If lPrest
		Return (EXISTCHAV("TMG",cCliMdtps+M->TMG_QUESTI,2))//Verifica se ja existe
	Else
		Return (EXISTCHAV("TMG",M->TMG_QUESTI,1))//Verifica se ja existe
	Endif

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTA145CAD
Tela de cadastro da Ficha Ocupacional

@param cAlias, Caractere, Alias da tabela
@param nReg, Numérico, Numero do registro posicionado na tabela
@param nOpcx, Numérico, Valor da operação a ser relizada
@param oParent, Objeto, Pai onde serão criados os objetos
@param cAliasTrb, Caractere, Alias da tabela temporária
@param lTitulo, Lógico, se imprime título da ficha médica

@author  Denis Hyroshi de Souza
@since   01/07/2008
@return  Nil, Sempre Nulo
/*/
//-------------------------------------------------------------------
Function MDTA145CAD(cAlias,nRecno,nOpcx,oParent,cAliasTrb,lTitulo)

	Local i
	Local oMainWnd
	Local lVisual := .F.
	Local nYY,nXX
	Local nIndTMH, cSeekTMH, cCondTMH
	Local aBtn_Topo := {}

	Local aOldRot   := aClone(aRotina)
	Local lParent   := ValType(oParent) == "O"
	Local cIndNG
	Local oDlgInd
	Local oPaiFic
	Local cNomeFic := ""
	Local cComboRes:= If(  NGCADICBASE( "TMH_RESPOS", "D", "TMH", .F. ), "TMH->TMH_RESPOS" , "TMH->TMH_COMBO+TMH->TMH_COMBO2" )
	Local cQuesti := " "
	Local nLimPnl  := 0
	Local nPosHRod := 0

	Default cAliasTrb := cAliasQue
	Default lTitulo   := .T.

	Private oMenu

	/*If !IsInCallStack( "MDTA410" )
		nOpcx := nOpcx + 1
	EndIf*/

	aRotina := { { STR0004	, "AxPesqui" , 0 , 1	},;//"Pesquisar"
				 { STR0030	, "NGCAD01"  , 0 , 2	},;//"Visualizar"
				 { STR0008	, "NGCAD01"  , 0 , 3	},;//"Incluir"
				 { STR0009	, "NGCAD01"  , 0 , 4	},;//"Alterar"
				 { STR0010	, "NGCAD01"  , 0 , 5 , 3} }//"Excluir"

	If nOpcx == 2 .Or. nOpcx == 5
		lVisual := .T.
	Endif

	Private oFont    := TFont():New("Arial",,-10,.F.,.F.)
	Private oFont12  := TFont():New("Arial",,-12,.T.,.T.)
	Private oFont16  := TFont():New("Arial",,-16,.T.,.T.)
	Private cAliasCTT := "SI3"
	Private aSize := MsAdvSize(,.f.,430), aObjects := {}
	Private nOrdTMI := NGRETORDEM("TMI","TMI_FILIAL+TMI_NUMFIC+TMI_QUESTI+DTOS(TMI_DTREAL)+TMI_QUESTA+TMI_RESPOS",.F.)
	Private nPosPnl  := 0
	Private oPnlPrin
	Private oPnlPai
	Private oIndNG
	Private oBtnFirst
	Private oBtnNext
	Private oBtnPrevi
	Private oBtnLast
	Private nLastPanel := 1 //Indica última página de perguntas apresentada
	Private nLinObj := 0
	Private cX_MF_Fun := Space(40)
	Private cX_MF_Cus := Space(40)

	//Opção para imprimir o relatório em branco
	aAdd( aBtn_Topo , {"HISTORIC", { || MDTIMPTMI() }, STR0032, STR0021} ) //"Imprimir Questionário"###"Imprimir"

	Aadd(aObjects,{200,200,.t.,.f.})
	aInfo := {aSize[1],aSize[2],aSize[3],aSize[4],0,0}
	aPosObj := MsObjSize(aInfo, aObjects,.t.)
	If aSize[6] > 900
		aPosObj[1,3] := aPosObj[1,3] * ( aSize[6] / 560 )
	ElseIf aSize[6] > 650
		aPosObj[1,3] := aPosObj[1,3] * ( aSize[6] / 590 )
	Else
		aPosObj[1,3] := aPosObj[1,3] * ( aSize[6] / 610 )
	Endif

	If Alltrim(GETMV("MV_MCONTAB")) == "CTB"
		cAliasCTT := "CTT"
	Endif

	If IsInCallStack( "MDTA410" ) .And. Select( cAliasQue ) == 0

		aDBFB := {}
		Aadd(aDBFB,{"TMI_NUMFIC"   ,"C", 09,0})
		Aadd(aDBFB,{"TMI_DTREAL"   ,"C", 08,0})
		Aadd(aDBFB,{"TMI_QUESTI"   ,"C", 06,0})

		oTempTable := FWTemporaryTable():New( cAliasQue, aDBFB )
		oTempTable:AddIndex( "1", {"TMI_NUMFIC","TMI_DTREAL","TMI_QUESTI"} )
		oTempTable:Create()

	EndIf

	aCadTipo := {} //Limpa array de perguntas

	If !IsInCallStack( "MDTC990" )
		dbSelectArea("TMI")
		dbSetOrder(nOrdTMI)
		dbSeek(xFilial("TMI")+(cAliasTrb)->TMI_NUMFIC + (cAliasTrb)->TMI_QUESTI + (cAliasTrb)->TMI_DTREAL)
	EndIf
	If cValToChar(nOpcx) $ "4/5" .And. NGCADICBASE("TMK_USUARI","A","TMK",.F.) .And. FindFunction("MDTRESTRI") .And. !MDTRESTUS(MDTDATALO("TMI->TMI_USERGI",.F.))
		aRotina := aClone(aOldRot)
		Return .F.
	Endif
	//Inicializa a Pergunta de Bloqueio
	Pergunte( "MDT145" , .F. )

	aAreaTM0 := TM0->(GetArea())
	dbSelectArea("TMI")

	bCampo := {|nCPO| Field(nCPO) }
	DbSelectArea("TMI")
	For i := 1 To FCount()
	M->&(EVAL(bCampo,i)) := &(EVAL(bCampo,i))
	If nOpcx == 3
		If ValType(M->&(EVAL(bCampo,i))) == "C"
			M->&(EVAL(bCampo,i)) := Space(Len(M->&(EVAL(bCampo,i))))
		ElseIf ValType(M->&(EVAL(bCampo,i))) == "N"
			M->&(EVAL(bCampo,i)) := 0
		ElseIf ValType(M->&(EVAL(bCampo,i))) == "D"
			M->&(EVAL(bCampo,i)) := cTod("  /  /  ")
		ElseIf ValType(M->&(EVAL(bCampo,i))) == "L"
			M->&(EVAL(bCampo,i)) := .F.
		EndIf
	Endif
	Next i
	M->TMI_NUMFIC := TM0->TM0_NUMFIC

	RestArea(aAreaTM0)

	//TELA INICIAL
	nOpcPar := 0
	If nOpcx==3
		nOpcPar := MDTA145TMI(nOpcx==3,nOpcx)
		If nOpcPar == 1
			MDTA145Grv(nOpcx,1)
		Endif
	Endif

	//TELA INICIAL
	nOpca := 0

	If lSigaMdtps
		nIndTMH := NGRETORDEM("TMH","TMH_FILIAL+TMH_CLIENT+TMH_LOJA+TMH_QUESTI",.F.)
		cSeekTMH:= cCliMdtps+M->TMI_QUESTI
		cCondTMH:= "TMH->(TMH_FILIAL+TMH_CLIENT+TMH_LOJA+TMH_QUESTI)"
	Else
		nIndTMH := 1
		cSeekTMH:= M->TMI_QUESTI
		cCondTMH:= "TMH->(TMH_FILIAL+TMH_QUESTI)"
	Endif

	If nOpcPar == 1 .Or. nOpcx != 3

		cTipoFic := M->TMI_QUESTI
		dbSelectArea("TMH")
		dbSetOrder(nIndTMH)
		dbSeek(xFilial("TMH")+cSeekTMH)
			While !Eof() .And. xFilial("TMH")+cSeekTMH == &(cCondTMH)
			//Verifica se usuario precisa responder a pergunta
			If TMH->TMH_INDSEX <> "3"
				If (TMH->TMH_INDSEX == "1" .And. TM0->TM0_SEXO == "2") .Or.;
					(TMH->TMH_INDSEX == "2" .And. TM0->TM0_SEXO == "1")

					dbSelectArea( 'TMH' )
					dbSkip()
					loop
				Endif
			Endif
			aTipoTMH := {}
			If !Empty( &cComboRes )
				aTipoTMH := fRetCombo(Alltrim( &cComboRes ))
			Endif
			aTemp    := Array(Len(aTipoTMH),3)
			For nXX := 1 To Len(aTemp)
				If (TMH->TMH_TPLIST=="1")
				aTemp[nXX,1] := 0
			Else
				aTemp[nXX,1] := .F.
			Endif
			If nOpcx != 3
				dbSelectArea("TMI")
				dbSetOrder(nOrdTMI)
				If dbSeek( xFilial("TMI") + M->TMI_NUMFIC+M->TMI_QUESTI+DTOS(M->TMI_DTREAL)+TMH->TMH_QUESTA+SubStr(aTipoTMH[nXX],1,1) )
					If (TMH->TMH_TPLIST=="1")
					aTemp[nXX,1] := 1
				Else
					aTemp[nXX,1] := .T.
				Endif
					Endif
				Else
				If SubStr(aTipoTMH[nXX],1,1) == TMH->TMH_DEFAUL
					If (TMH->TMH_TPLIST=="1")
						aTemp[nXX,1] := 1
					Else
						aTemp[nXX,1] := .T.
					Endif
				Endif
			Endif
		Next nXX


			//Se não for inclusão
			cMemoM6 := ""
			If nOpcx != 3
				cQuesti := M->TMI_QUESTI
				dbSelectArea("TMI")
				dbSetOrder(nOrdTMI)
				If dbSeek( xFilial("TMI") + M->TMI_NUMFIC+M->TMI_QUESTI+DTOS(M->TMI_DTREAL)+TMH->TMH_QUESTA+"#" )
					cMemoM6 := Alltrim(TMI->TMI_DESCRI)
				Endif
			Endif
			//1 - Codigo Questão
			//2 - Descrição Questão
			//3 - Grupo
			//4 - Array de Opções
			//5 - Cbox
			//6 - Indica se é RADIO (.T.) ou CHECK (.F.)
			//7 - Indica se tem campo Memo
			//8 - Array (respostas,objeto)
			//9 - Ordem
			//10- Campo Memo
			//11- Questionario
			//12- Qtd. Objetos x Pergunta
			//13- Página onde ficará a pergunta
			//ATENCAO: A CONFIGURACAO DA VARIAVEL aCadTipo DEVE SER A MESMA DEFINIDA NO PROGRAMA MDTR410.PRX
			aADD( aCadTipo , { TMH->TMH_QUESTA , Capital(TMH->TMH_PERGUN) , TMH->TMH_CODGRU , aTipoTMH ,;
							&cComboRes , (TMH->TMH_TPLIST=="1") ,;
							(TMH->TMH_ONMEMO=="1") , aTemp , TMH->TMH_ORDEM , cMemoM6 ,cQuesti , 0 , 0} )
			dbSelectArea("TMH")
			dbSkip()
		End

		aSort( aCadTipo ,,, { |x,y| x[9] < y[9] } )

		If Len(aCadTipo) > 0
			oIndNG:=Array(Len(aCadTipo),3)
		Endif

		aAreaTMI := {}
		cChvTmp  := xFilial("TMI") + TMI->TMI_NUMFIC
		dbSelectArea("TMI")
		dbSetOrder(nOrdTMI)
		dbSeek( cChvTmp )
		While !Eof() .And. cChvTmp == TMI->TMI_FILIAL+TMI->TMI_NUMFIC
			If Replicate("#",Len(TMI->TMI_QUESTA)) == TMI->TMI_QUESTA
				If aScan(aAreaTMI, {|x| x == TMI->TMI_DTREAL }) == 0
					aAdd( aAreaTMI , TMI->TMI_DTREAL )
				Endif
			Endif
			dbSelectArea("TMI")
			dbSkip()
		End
		aSort( aAreaTMI ,,, { |x,y| x > y } )
		For nXX := 1 To Len(aAreaTMI)
			If nXX == 1
				cObsAnt := ""
			Endif
			cObsAnt += DtoC(aAreaTMI[nXX]) + "  "
		Next nXX

		nFatMlt := 1.95
		If aPosObj[1,4] <= 410
			nFatMlt := 1.9
		ElseIf aPosObj[1,4] <= 550
			nFatMlt := 1.93
		Endif

		If !lParent
			DEFINE MSDIALOG oDlgInd TITLE OemToAnsi(cCadastro) From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL
			oDlgInd:LESCCLOSE := .F.
			oDlgInd:lMaximized := .T.
		Else
			oDlgInd := oParent
			oDlgInd:CoorsUpdate()
			aPosObj[1,4] := oDlgInd:nWidth/2
			aSize[5] := 0
		EndIf

		//PAGINA 2 - TMI
		nLinObj := 2

		If Empty(TM0->TM0_NOMFIC)
			dbSelectArea("TM0")
			dbSetOrder(1)
			If dbSeek(xFilial("TM0")+(cAliasTrb)->TMI_NUMFIC)
				cNomeFic :=	TM0->TM0_NOMFIC
			Else
				cNomeFic := M->TMT_NOMFIC
			EndIf
		Else
			cNomeFic :=	TM0->TM0_NOMFIC
		EndIf

		//Cria Panel pai que engloba a tela p/ alinhamento
		If !lParent
			oPnlPai := TPanel():New(000,000,,oDlgInd,,,,,CLR_WHITE,000,000,.F.,.F.)
			oPnlPai:Align := CONTROL_ALIGN_ALLCLIENT
			If lTitulo
				oPaiFic := TPanel():New(000,000,,oPnlPai,,,,,CLR_WHITE,000,028,.F.,.F.)
				oPaiFic:Align := CONTROL_ALIGN_TOP
			EndIf
		Else
			@ 0,0 SCROLLBOX oPaiFic VERTICAL OF oDlgInd BORDER
			oPaiFic:Align := CONTROL_ALIGN_ALLCLIENT
		EndIf

		//Titulo do Ficha Médica
		If lTitulo
			oPanelTmp := TPaintPanel():new(nLinObj-1,-4,aPosObj[1,4]+5,14,oPaiFic)
			oPanelTmp:addShape("id=2;type=1;left=0;top=0;width="+Alltrim(Str(aPosObj[1,4]*2.2,5))+";height=28;"+;
						"gradient=1,0,-15,0,40,0.4,#C3DBF9,0.9,#83AAE2,0.0,#FFF6FF;pen-width=0;"+;
						"pen-color=#B0C4DE;can-move=0;can-mark=0;is-blinker=1;")

			@ 2, 11 SAY oGrpNome Prompt cNomeFic PIXEL OF oPanelTmp Font oFont16 COLOR CLR_WHITE
			@ 2, 10 SAY oGrpNome Prompt cNomeFic PIXEL OF oPanelTmp Font oFont16 COLOR RGB(67,70,87)

			@ 2, (aPosObj[1,4]/2) SAY oGrpDtEx Prompt SubStr(DtoC(M->TMI_DTREAL),1,6)+StrZero(Year(M->TMI_DTREAL),4) PIXEL OF oPanelTmp Font oFont16 COLOR CLR_WHITE
			@ 2, (aPosObj[1,4]/2)-1 SAY oGrpDtEx Prompt SubStr(DtoC(M->TMI_DTREAL),1,6)+StrZero(Year(M->TMI_DTREAL),4) PIXEL OF oPanelTmp Font oFont16 COLOR RGB(67,70,87)
			@ 2, aPosObj[1,4]-120 SAY oGrpQues Prompt Space(20) PIXEL OF oPanelTmp Font oFont16 COLOR CLR_WHITE

			nLinObj += 15
		EndIf

		If !lParent
			cOldGrupo := "#"
			nLimPnl	  := 620 //Limite de objetos por tela
			nTotAlt   := 0   //Totalizador de objetos por página
			nContPg   := 1   //Contador de páginas
			For nYY := 1 to Len(aCadTipo)
				aCadTipo[nYY,12] := f145QtObj(aCadTipo[nYY],cOldGrupo)
				nTotAlt += aCadTipo[nYY,12]
				If nTotAlt > nLimPnl
					nContPg += 1
					aCadTipo[nYY,13] := nContPg
					nTotAlt := 0
				Else
					aCadTipo[nYY,13] := nContPg
				EndIf
				cOldGrupo := aCadTipo[nYY,3]
			Next nYY
			cOldGrupo := "#"
			nPosPnl := 0
			@ 000,000 SCROLLBOX oPnlPrinc VERTICAL OF oPnlPai
			oPnlPrinc:Align := CONTROL_ALIGN_ALLCLIENT
			For nYY := 1 to Len(aCadTipo)
				If aCadTipo[nYY,13] == 1 //Monta perguntas da primeira página
					f145MontPg(cOldGrupo,nYY,lVisual,oPnlPrinc)
					cOldGrupo := aCadTipo[nYY,3]
				EndIf
			Next nYY
			//nLinObj += 13

			oPanelRod := TPanel():New(000,000,,oPnlPai,,,,,CLR_WHITE,000,020,.F.,.F.)
			oPanelRod:Align := CONTROL_ALIGN_BOTTOM

			nPosHRod := (aPosObj[1,4]/2)-155

			oBtnFirst := TButton():New(010,010+nPosHRod,STR0041,oPanelRod,{|| MsgRun(STR0047,,{|| f451MovPnl(.T.,0,,lVisual)})},50,10,,,.F.,.T.,.F.,,.F.,,,.F. ) //"Primeira"
			oBtnFirst:Disable()
			oBtnPrevi := TButton():New(010,070+nPosHRod,STR0042,oPanelRod,{|| MsgRun(STR0047,,{|| f451MovPnl(.F.,0,.F.,lVisual)})},50,10,,,.F.,.T.,.F.,,.F.,,,.F. ) //"Anterior"
			oBtnPrevi:Disable()
			@ 010, 130+nPosHRod Say STR0045 PIXEL OF oPanelRod Font oFont12 //"Ir para: "
			aCombo := {STR0046+"01"} //"Página"
			For nYY := 2 to nContPg
				AADD(aCombo,STR0046+StrZero(nYY,2))
			Next nYY
			cCombo := aCombo[1]
			oCombo := tComboBox():New(010,155+nPosHRod,{|u|if(PCount()>0,cCombo:=u,cCombo)},aCombo,55,10,oPanelRod,,,{|| MsgRun(STR0047,,;
									{|| f451MovPnl(.F.,oCombo:nAt,,lVisual)})},,,.T.,,,,{||.T.},,,,,'cCombo') //"Montando Tela..."
			oBtnNext := TButton():New(010,220+nPosHRod,STR0043,oPanelRod,{|| MsgRun(STR0047,,{|| f451MovPnl(.F.,0,.T.,lVisual)})},50,10,,,.F.,.T.,.F.,,.F.,,,.F. ) //"Próximo"
			IIF(nContPg == 1,oBtnNext:Disable(),)
			oBtnLast := TButton():New(010,280+nPosHRod,STR0044,oPanelRod,{|| MsgRun(STR0047,,{|| f451MovPnl(.F.,nContPg,,lVisual)})},50,10,,,.F.,.T.,.F.,,.F.,,,.F. ) //"Última"
			IIF(nContPg == 1,oBtnLast:Disable(),)
		Else
			cOldGrupo := "#"
			For nYY := 1 to Len(aCadTipo)
				f145MontPg(cOldGrupo,nYY,lVisual,oPaiFic)
				cOldGrupo := aCadTipo[nYY,3]
			Next nYY
		EndIf
		If Len(aSMenu) > 0
			If Type("oPnlPrinc") == "O"
				NGPOPUP(aSMenu,@oMenu)
				oPnlPrinc:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oPnlPrinc)}
			EndIf
		Endif

		If !lParent
			ACTIVATE MSDIALOG oDlgInd ON INIT EnchoiceBar(oDlgInd,{|| nOpca := 1,if(MDTA145Ok(.F.),oDlgInd:End(),nOpca := 1)},{|| nOpca := 2,oDlgInd:End()},,aBtn_Topo)
			If nOpca == 1
				MDTA145Grv(nOpcx,2)
			Endif
		EndIf

	Endif

	If !IsInCallStack( "MDTC990" )
		dbselectArea(cAliasTrb)
	EndIf
	aRotina := aClone(aOldRot)

Return nOpcPar

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTA145TMI
Tela de cadastro da tabela TMI

@sample MDTA145TMI( .F. , 3 )

@param lWhenTMI, Lógico, Se deixa código editável
@param nOpcx__, Numérico, Valor da operação a ser relizada

@author  NG Informática
@since   01/10/2010
@return  nOpTemp, Numérico, Tela concluída com sucesso (1) ou
cancelada (2)
/*/
//-------------------------------------------------------------------
Function MDTA145TMI(lWhenTMI,nOpcx__)

	Local nOpTemp := 0
	Local aSitExa := {STR0033,STR0034}//"1=Ativo"##"2=Inativo"
	Local cNomeFic := ""

	DEFINE MSDIALOG oDlgPar TITLE OemToAnsi(cCadastro) From 0,0 To 200,450 OF oMainWnd PIXEL
	oDlgPar:LESCCLOSE := .f.

	//PAGINA 1 - TMI
	nLinObj := 2
	@ 0,0 SCROLLBOX oScroll2 VERTICAL OF oDlgPar BORDER
	oScroll2:Align := CONTROL_ALIGN_ALLCLIENT

	@ 28, 012 SAY oS_DtExa Prompt STR0035 PIXEL OF oScroll2 Font oFont12//"Data"
	@ 28, 085 MSGET oG_DtExa VAR M->TMI_DTREAL SIZE 60,9 VALID f145Data(M->TMI_DTREAL) WHEN lWhenTMI PIXEL OF oScroll2 HasButton
	@ 42, 012 SAY oS_TpExa Prompt STR0036 PIXEL OF oScroll2 Font oFont12//"Código do Questionário"
	@ 42, 085 MSGET oG_TpExa VAR M->TMI_QUESTI SIZE 60,8 WHEN lWhenTMI VALID F3 If(lSigaMdtps,"MDTTMG","TMG") PIXEL OF oScroll2 HasButton

	If !Empty(TM0->TM0_NOMFIC)
		cNomeFic := TM0->TM0_NOMFIC
	Else
		cNomeFic := M->TMT_NOMFIC
	EndIf
	//Titulo do Grupo
	oPanelTmp := TPaintPanel():new(nLinObj-1,-4,aPosObj[1,4]+5,14,oScroll2)
	oPanelTmp:addShape("id=2;type=1;left=0;top=0;width="+Alltrim(Str(aPosObj[1,4]*2.2,5))+";height=28;"+;
                "gradient=1,0,-15,0,40,0.4,#C3DBF9,0.9,#83AAE2,0.0,#FFF6FF;pen-width=0;"+;
                "pen-color=#B0C4DE;can-move=0;can-mark=0;is-blinker=1;")
	@ 2, 11 SAY oGrpNome Prompt cNomeFic PIXEL OF oPanelTmp Font oFont16 COLOR CLR_WHITE
	@ 2, 10 SAY oGrpNome Prompt cNomeFic PIXEL OF oPanelTmp Font oFont16 COLOR RGB(67,70,87)

	oS_DtExa:SetFocus()
	ACTIVATE MSDIALOG oDlgPar ON INIT EnchoiceBar(oDlgPar,{|| If(fNextPnl(.T.) .And. f145Data(M->TMI_DTREAL) .And. VALRegis() ,(nOpTemp := 1,oDlgPar:End()),nOpTemp := 0) },;
														  {|| nOpTemp := 2,oDlgPar:End()}) CENTERED

Return nOpTemp

//-------------------------------------------------------------------
/*/{Protheus.doc} f145Data
Valida data do questionario

@sample f145Data( 01/10/2010 )

@param dTMI_DTREAL, Data, Data a ser validada

@author  NG Informática
@since   01/10/2010
@return  Lógico, Verdadeiro se for uma data válida
/*/
//-------------------------------------------------------------------
Static Function f145Data(dTMI_DTREAL)

	If dTMI_DTREAL > dDataBase
		Help(" ",1,"NGATENCAO",,STR0040,3,1) //"A data do questionário não pode ser maior que a data atual."
		Return .F.
	Endif
	If !NaoVazio(dTMI_DTREAL)
		Return .F.
	Endif

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTA145Grv
Funcao chamada para gravacao

@sample MDTA145Grv( 3, 1 )

@param nOpcx, Numérico, Valor da operação a ser relizada
@param nTipo, Numérico, Tipo da gravação

@author  NG Informática
@since   01/10/2010
@return  Lógico, Sempre Verdadeiro
/*/
//-------------------------------------------------------------------
Function MDTA145Grv(nOpcx,nTipo)

	Local ny,nx,cOrd,nXX,nYY,nZZ
	Local aTMIs := {}
	Local cChave := "", cNumFicha := ""
	Local nOrdTMI := NGRETORDEM("TMI","TMI_FILIAL+TMI_NUMFIC+TMI_QUESTI+DTOS(TMI_DTREAL)+TMI_QUESTA+TMI_RESPOS",.F.)

	If IsInCallStack( "MDTA410" ) .And. Select( cAliasQue ) == 0
		aDBFB := {}
		Aadd(aDBFB,{"TMI_NUMFIC"   ,"C", 09,0})
		Aadd(aDBFB,{"TMI_DTREAL"   ,"C", 08,0})
		Aadd(aDBFB,{"TMI_QUESTI"   ,"C", 06,0})
		oTempTable := FWTemporaryTable():New( cAliasQue, aDBFB )
		oTempTable:AddIndex( "1", {"TMI_NUMFIC","TMI_DTREAL","TMI_QUESTI"} )
		oTempTable:Create()
	EndIf

	Begin Transaction
		If nOpcx == 3 .Or. nOpcx == 4
			If nTipo == 2
				For nYY := 1 to Len(aCadTipo)
					aRespost := {}
					For nXX := 1 To Len(aCadTipo[nYY,4])
						cStrXX := Alltrim( Str(nXX) )
						If aCadTipo[nYY,6] //Radio
							If ValType(aCadTipo[nYY,8,nXX,1]) == "N"
								If aCadTipo[nYY,8,nXX,1] == 1
									aAdd( aRespost , aCadTipo[nYY,4,nXX] )
								Endif
							Endif
						Else //Check
							If ValType(aCadTipo[nYY,8,nXX,1]) == "L"
								If aCadTipo[nYY,8,nXX,1]
									aAdd( aRespost , aCadTipo[nYY,4,nXX] )
								Endif
							Endif
						Endif
					Next nXX
					If ValType(aCadTipo[nYY,10]) == "C" //Adiciona campo memo para gravação
						If !Empty(aCadTipo[nYY,10])
							aAdd( aRespost , "#" )
						Endif
					Endif
					If !Empty(M->TMI_NUMFIC)
						cNumFicha := M->TMI_NUMFIC
					Else
						cNumFicha := M->TMT_NUMFIC
					EndIf
			//Se encontrou informação para a pergunta, grava
					For nZZ := 1 To Len(aRespost)
						dbSelectArea("TMI")
						dbSetOrder(nOrdTMI)          //TMI_NUMFIC +   TMI_QUESTI+DTOS(   TMI_DTREAL)+TMI_QUESTA     +TMI_RESPOS
						If dbSeek( xFilial("TMI") + cNumFicha +M->TMI_QUESTI+DTOS(M->TMI_DTREAL)+aCadTipo[nYY,1]+aRespost[nZZ])
							RecLock("TMI",.F.)
							TMI->TMI_RESPOS := aRespost[nZZ]
						Else
							RecLock("TMI",.T.)
							TMI->TMI_FILIAL := xFilial("TMI")
							TMI->TMI_NUMFIC := cNumFicha
							TMI->TMI_QUESTI := M->TMI_QUESTI
							TMI->TMI_DTREAL := M->TMI_DTREAL
							TMI->TMI_QUESTA := aCadTipo[nYY,1]
							TMI->TMI_RESPOS := aRespost[nZZ]
							If lSigaMdtps
								TMI->TMI_CLIENT := SA1->A1_COD
								TMI->TMI_LOJA   := SA1->A1_LOJA
							Endif
						Endif
						If aRespost[nZZ] == "#"
							TMI->TMI_DESCRI := aCadTipo[nYY,10]
						Endif
						TMI->(MsUnLock())
						aAdd(aTMIs , TMI->(Recno()) )
					Next nZZ
				Next nYY

		//Inclui ou altera o cadastro de itens do Tipo de Ficha
				dbSelectArea("TMI")
				dbSetOrder(nOrdTMI)
				If dbSeek( xFilial("TMI") + cNumFicha +M->TMI_QUESTI+DTOS(M->TMI_DTREAL))
					While !Eof() .and. xFilial("TMI") == TMI->TMI_FILIAL .and. ;
							cNumFicha+M->TMI_QUESTI+DTOS(M->TMI_DTREAL) == TMI->TMI_NUMFIC+TMI->TMI_QUESTI+DTOS(TMI->TMI_DTREAL)

						If TMI->TMI_QUESTA == Replicate("#",Len(TMI->TMI_QUESTA)) .Or. TMI->TMI_QUESTA == Replicate("@",Len(TMI->TMI_QUESTA))
							dbSelectArea("TMI")
							dbSkip()
							Loop
						Endif
						If aScan(aTMIs, {|x| x == TMI->(Recno()) }) == 0
							dbSelectArea("TMI")
							RecLock("TMI",.F.)
							dbDelete()
							TMI->(MsUnLock())
						Endif
						dbSelectArea("TMI")
						dbSkip()
					End
				Endif
			Endif

		ElseIf nOpcx == 5

			dbSelectArea("TMI")
			dbSetOrder(1)
			If dbSeek( xFilial("TMI") + M->TMI_NUMFIC+DTOS(M->TMI_DTREAL)+M->TMI_QUESTI)
				While !Eof() .and. xFilial("TMI") == TMI->TMI_FILIAL .and. ;
						M->TMI_NUMFIC+DTOS(M->TMI_DTREAL)+M->TMI_QUESTI == TMI->TMI_NUMFIC+DTOS(TMI->TMI_DTREAL)+TMI->TMI_QUESTI
					dbSelectArea("TMI")
					RecLock("TMI",.F.)
					dbDelete()
					TMI->(MsUnLock())
					dbSkip()
				End
			Endif
		Endif
	End Transaction
	MDTA145INI()

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} fRetCombo
Verifica se a formula esta correta e faz a gravacao

@param cVar, Caractere, Variável com os campos de resposta do
questionário

@author  Denis Hyroshi de Souza
@since   07/07/2008
@return  aClone(aArray2), Array, Clone do array dos valores do combo
de resposta
/*/
//-------------------------------------------------------------------
Static Function fRetCombo(cVar)

	Local aArray1 := RetSx3Box(cVar,,,1)
	Local nCont,aArray2 := {}

	For nCont := 1 To Len(aArray1)
		If !Empty(aArray1[nCont][1])
			AADD(aArray2,Alltrim(aArray1[nCont][1]))
		Endif
	Next nCont

Return aClone(aArray2)

//-------------------------------------------------------------------
/*/{Protheus.doc} fNextPnl
Ir a proxima tela

@sample fNextPnl( .T. )

@param lIncReg, Lógico, Incrementa regua de progressão.

@author  Denis Hyroshi de Souza
@since   07/07/2008
@return  Lágico, Falso se há campos obrigatórios não preenchidos ou
chave duplicada.
/*/
//-------------------------------------------------------------------
Static Function fNextPnl(lIncReg)

	If Empty(M->TMI_DTREAL)
		MsgInfo( STR0037 )//"O campo Data do exame é obrigatório."
		Return .F.
	Endif
	If Empty(M->TMI_QUESTI)
		MsgInfo( STR0056 )//"O campo Código do Questionário é obrigatório."
		Return .F.
	Endif
	If !ExistChav( "TMI" , TM0->TM0_NUMFIC + M->TMI_QUESTI + DTOS(M->TMI_DTREAL) )
		Return .F.
	Endif

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} fRadioMdt
Validacao do Radio Group

@param nTmpYY, Numérico, Posicionamento no array aCadTipo
@param nTmpXX, Numérico, Posicionamento no array aCadTipo

@author  Denis Hyroshi de Souza
@since   07/047/2008
@return  Lógico, Sempre verdadeiro
/*/
//-------------------------------------------------------------------
Function fRadioMdt(nTmpYY,nTmpXX)

	Local nX

	For nX := 1 To Len(aCadTipo[nTmpYY,8])
		If nX == nTmpXX
			aCadTipo[nTmpYY,8,nX,1] := 1
			aCadTipo[nTmpYY,8,nX,2]:LoadBitmaps("ngradiook")
		Else
			If aCadTipo[nTmpYY,8,nX,1] <> 0
				aCadTipo[nTmpYY,8,nX,1] := 0
				aCadTipo[nTmpYY,8,nX,2]:LoadBitmaps("ngradiono")
			Endif
		Endif
	Next nX

	If Type("oScroll") == "O"
		oScroll:Refresh()
	EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTIMPTMI
Imprime Ficha Medica Ocupacional

@author  Denis Hyroshi de Souza
@since   07/07/2008
@return  Nil, Sempre Nulo
/*/
//-------------------------------------------------------------------
Function MDTIMPTMI()

	Local aOldTipo := aClone(aCadTipo)
	Local cPerg	:= If( lSigaMdtPs, "MDT410PS  " , "MDT410    " )
	Private nPag410 := 0
	Private oPrint
	Private nSizeTMH := (TAMSX3("TMH_PERGUN")[1])
	Private lPrintTel := .t.
	Private oTempTRB, oTempTRB2, oTempTRB1

	nSizeTMH := If( nSizeTMH > 0 , nSizeTMH , 60 )

	If ExistBlock("MDTA1451")
		Return ExecBlock("MDTA1451",.F.,.F.)
	Endif

	Pergunte( cPerg , .F. )

	If lSigaMdtps
		MV_PAR01 := SA1->A1_COD
		MV_PAR02 := SA1->A1_LOJA
		MV_PAR03 := M->TMI_QUESTI
		MV_PAR04 := M->TMI_QUESTI
		MV_PAR05 := TM0->TM0_NUMFIC
		MV_PAR06 := TM0->TM0_NUMFIC //Space(nSizeTMH)
		MV_PAR07 := 2
		MV_PAR08 := M->TMI_DTREAL
		MV_PAR09 := M->TMI_DTREAL
		MV_PAR10 := 1
		MV_PAR11 := 1
	Else
		MV_PAR01 := M->TMI_QUESTI
		MV_PAR02 := M->TMI_QUESTI
		MV_PAR03 := TM0->TM0_NUMFIC
		MV_PAR04 := TM0->TM0_NUMFIC
		MV_PAR05 := 2
		MV_PAR06 := M->TMI_DTREAL
		MV_PAR07 := M->TMI_DTREAL
		MV_PAR08 := 1
		MV_PAR09 := 1
	Endif

	cDESQUEST := ALLTRIM(TMG->TMG_NOMQUE)
	fImpMod2(aCadTipo)

	aCadTipo := aClone(aOldTipo)

	//Inicializa a Pergunta de Bloqueio
	Pergunte( "MDT145" , .F. )

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTA145INI
Filtra o Browse da TMI

@sample MDTA145INI( .T. )

@param lZap, Lógico, Se exclui todos os registros da tabela

@author  Taina A. Cardoso
@since   09/11/2010
@return  Lógico, sempre verdadeiro
/*/
//-------------------------------------------------------------------
Function MDTA145INI(lZap)

	Local cQuery
	Local cTabTMI := RetSqlName("TMI")
	Local cTempQuery
	Private cAliasTMI := GetNextAlias()
	Default lZap := .T.

	If Select(cAliasQue) > 0 .And. lZap
		Dbselectarea(cAliasQue)
		Zap
	EndIf

	//Begin Transaction
	cQuery := "Select TMI_NUMFIC,TMI_DTREAL,TMI_QUESTI "
	cQuery += " From " + cTabTMI + " "
	cQuery += "WHERE TMI_FILIAL = '" + xFilial("TMI") + "' AND "
	cQuery += " D_E_L_E_T_ != '*' And "
	cQuery += " TMI_NUMFIC = '"+ TM0->TM0_NUMFIC +"' "

	If ExistBlock("MDTA1452")
		cTempQuery :=  ExecBlock("MDTA1452",.F.,.F.)
		If ValType(cTempQuery) == "C"
			cQuery += cTempQuery
		EndIf
	Endif
	cQuery += "Group by TMI_NUMFIC,TMI_DTREAL,TMI_QUESTI"
	cQuery := ChangeQuery(cQuery)
	MPSysOpenQuery( cQuery , cAliasTMI )
	//dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTMI,.T.,.T.)

	dbSelectArea(cAliasTMI)
	dbgoTop()
	While !Eof()
		If Select( cAliasQue ) > 0

			Dbselectarea(cAliasQue)
			Dbgotop()
			If !Dbseek( (cAliasTMI)->TMI_NUMFIC+(cAliasTMI)->TMI_DTREAL+(cAliasTMI)->TMI_QUESTI)
				RecLock(cAliasQue,.T.)
				(cAliasQue)->TMI_NUMFIC := (cAliasTMI)->TMI_NUMFIC
				(cAliasQue)->TMI_DTREAL := (cAliasTMI)->TMI_DTREAL
				(cAliasQue)->TMI_QUESTI := (cAliasTMI)->TMI_QUESTI
				(cAliasQue)->( Msunlock() )
			Endif

			dbSelectArea(cAliasTMI)
			dbSkip()
		Else
			Exit
		EndIf

	End
	(cAliasTMI)->(dbCloseArea())
	If Select( cAliasQue ) > 0
		Dbselectarea(cAliasQue)
		dbGoTop()
	EndIf
	If Type( "oBrwQuest" ) == "O"
		oBrwQuest:oBrowse:Refresh()
	EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} VALRegis
Validação para nao haver registros duplicados

@author  Taina A. Cardoso
@since   09/11/2010
@return  Lógico, Verdadeiro se o registro é válido
/*/
//-------------------------------------------------------------------
Static Function VALRegis()

	dbSelectArea("TMI")
	dbSetORder(1)
	If dbSeek(xFilial("TMI")+TM0->TM0_NUMFIC+DTOS(M->TMI_DTREAL)+M->TMI_QUESTI)
		MsgStop(STR0039)//"Já existe um Questionário para essa Data"
		Return .F.
	EndIf

	If !MDT145VQTI()
		Return .F.
	EndIf

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTA145Ok
Função que valida se respostas do questionario foram respondidas.

@param lObrig, Lógico, Define se é obrigatório responder todas as perguntas de
multipla escolha do questionário.

@author Microsiga
@since  09/04/12
@return lRet, Lógico, Indica se as perguntas foram respondidas e/ou
se pode proceder com a gravação
/*/
//---------------------------------------------------------------------
Function MDTA145Ok(lObrig)

	Local nRepost := 0
	Local nXX := 0, nYY := 0
	Local lRet:= .T.

	Default lObrig := .F.

	For nYY := 1 to Len(aCadTipo)
		For nXX := 1 To Len(aCadTipo[nYY,4])
			cStrXX := Alltrim( Str(nXX) )
			If aCadTipo[nYY,6] //Radio
				If ValType(aCadTipo[nYY,8,nXX,1]) == "N"
					If aCadTipo[nYY,8,nXX,1] == 1
						nRepost += 1
					Endif
				Endif
			Else //Check
				If ValType(aCadTipo[nYY,8,nXX,1]) == "L"
					If aCadTipo[nYY,8,nXX,1]
						nRepost += 1
					Endif
				Endif
			Endif
		Next nXX
		If Empty(aCadTipo[nYY,4]) .And. !Empty(aCadTipo[nYY,10])
			nRepost += 1
		EndIf
	Next nYY

	If nRepost < Len(aCadTipo) .And. (Inclui .or. Altera)
		If lObrig
			MsgStop( STR0055 ) //"É obrigatório que todas as perguntas sejam respondidas"
			lRet := .F.
		ElseIf !(MsgYesNO(STR0028,STR0029)) //Há perguntas que ainda não foram respondidas. Deseja confirmar ?"###"ATENÇÃO"
			lRet:= .F.
		Endif
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MDT415DOC
Funcao que carrega o MsDocument na TRBB, posicionado na TMI

@author  Elynton F. Bazzo
@since   07/12/2012
@return  Nil, Sempre Nulo
/*/
//-------------------------------------------------------------------
Function MDT415DOC()

	dbSelectArea("TMI")
	dbSetOrder(01)
	dbSeek( xFilial( "TMI" ) + (cAliasQue)->TMI_NUMFIC + DTOS(STOD ( (cAliasQue)->TMI_DTREAL ) ) + (cAliasQue)->TMI_QUESTI )
	MsDocument("TMI",TMI->(Recno()),4)

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} f145QtObj
Função que calcula a quantidade de objetos que serão criados por essa
pergunta.

@author  Cezar Augusto Padilha
@since   18/06/2013
@return  nRet, Numérico. Quantidade de objetos a serem criados
/*/
//---------------------------------------------------------------------
Static Function f145QtObj(aPerg,cOldGrupo)

	Local nRet 	:= 0

	If aPerg[3] <> cOldGrupo //Panel do grupo
		nRet += 2
	EndIf
	If aPerg[6] //Radio
		nRet += 2
	Else //CheckBox
		nRet += 1
	EndIf
	If aPerg[7] //Objeto Memo
		nRet += 1
	EndIf
	nRet += 2 // Acrescenta objeto da pergunta e groupbox

Return nRet

//---------------------------------------------------------------------
/*/{Protheus.doc} f451MovPnl
Função que controla apresentação dos panels(paginação).

@author Cezar Augusto Padilha
@since 19/06/2013
@return  Nil, Sempre Nulo
/*/
//---------------------------------------------------------------------
Static Function f451MovPnl(lPrim,nForcePainel,lProxima,lVisual)

	Local n := 0
	Local cOldGrupo := ""

	If nForcePainel == 0 .and. !lPrim
		If lProxima
			nForcePainel := nLastPanel + 1
		Else
			nForcePainel := nLastPanel - 1
		EndIf
	Endif
	oPnlPrinc:FreeChildren() //Desabilita Panel anterior

	If !lPrim
		If nForcePainel == aCadTipo[Len(aCadTipo),13]
			nLinObj := 27
			nPosPnl := 0
			cOldGrupo := "#"
			For n := 1 to Len(aCadTipo)
				If aCadTipo[n,13] == nForcePainel
					f145MontPg(cOldGrupo,n,lVisual,oPnlPrinc)
					cOldGrupo := aCadTipo[n,3]
				EndIf
			Next n
			oBtnFirst:Enable()
			oBtnPrevi:Enable()
			oBtnLast:Disable()
			oBtnNext:Disable()
			nLastPanel := nForcePainel
		Else
			nLinObj := 27
			nPosPnl := 0
			cOldGrupo := "#"
			For n := 1 to Len(aCadTipo)
				If aCadTipo[n,13] == nForcePainel
					f145MontPg(cOldGrupo,n,lVisual,oPnlPrinc)
					cOldGrupo := aCadTipo[n,3]
				EndIf
			Next n
			nLastPanel := nForcePainel
			If nForcePainel <> 1
				oBtnFirst:Enable()
				oBtnPrevi:Enable()
				oBtnLast:Enable()
				oBtnNext:Enable()
			Else
				oBtnFirst:Disable()
				oBtnPrevi:Disable()
				oBtnLast:Enable()
				oBtnNext:Enable()
			EndIf
		EndIf
	ElseIf lPrim
		nPosPnl := 0
		nLinObj := 27
		cOldGrupo := "#"
		For n := 1 to Len(aCadTipo)
			If aCadTipo[n,13] == 1
				f145MontPg(cOldGrupo,n,lVisual,oPnlPrinc)
				cOldGrupo := aCadTipo[n,3]
			EndIf
		Next n
		nLastPanel := 1
		oBtnFirst:Disable()
		oBtnPrevi:Disable()
		oBtnLast:Enable()
		oBtnNext:Enable()
	EndIf

Return Nil
//---------------------------------------------------------------------
/*/{Protheus.doc} f145MontPg
Função que so objetos de tela referente as perguntas do questionário.

@author Cezar Augusto Padilha
@since 19/06/2013
@return  Nil, Sempre Nulo
/*/
//---------------------------------------------------------------------
Static Function f145MontPg(cOldGrupo,nPos,lVisual,oObjPai)

	Local nXX := 0

	If cOldGrupo <> aCadTipo[nPos,3]
		cOldGrupo := aCadTipo[nPos,3]
		cDesGrupo := " "
		dbSelectArea("TK0")
		dbSetOrder(01)
		If dbSeek( xFilial("TK0") + cOldGrupo )
			If !Empty(TK0->TK0_DESCRI)
				cDesGrupo := Capital( Alltrim(TK0->TK0_DESCRI) )
			Endif
		Endif
		//Titulo do Grupo
		oPanelTmp := TPaintPanel():new(nPosPnl-1,0,aPosObj[1,4],10,oObjPai)
		oPanelTmp:addShape("id=1;type=1;left=0;top=0;width="+Alltrim(Str(aPosObj[1,4]*2,5))+";height=20;"+;
						"gradient=1,0,0,0,15,0.0,#FFFFFF,0.1,#FFFFFF,1.0,#FFFFFF;pen-width=1;"+;
						"pen-color=#FFFFFF;can-move=0;can-mark=0;is-blinker=1;")

		oPanelTmp:addShape("id=2;type=2;left=10;top=0;width="+Alltrim(Str(aPosObj[1,4]*nFatMlt,5))+";height=20;"+;
						"gradient=1,0,0,0,15,0.0,#FFFFFF,0.1,#FDFBFD,1.0,#CDD1D4;pen-width=1;"+;
						"pen-color=#B0C4DE;can-move=0;can-mark=0;is-blinker=1;")

		@ 1, 11 SAY oIndNG[nPos,3] Prompt Space(40) PIXEL OF oPanelTmp Font oFont12
		oIndNG[nPos,3]:SetText(cDesGrupo)
		nLinObj += 13
		nPosPnl += 13
	Endif

	cStrYY := Alltrim( Str(nPos) )
	//Titulo Questão
	nPosOld := nPosPnl+7
	@ nPosPnl, 009 SAY oIndNG[nPos,1] Prompt Space(40) PIXEL OF oObjPai Font oFont12
	oIndNG[nPos,1]:bSetGet := ;
	&("{|u| If(pCount() == 0, aCadTipo["+cStrYY+",2], aCadTipo["+cStrYY+",2]:=u)}")
	oIndNG[nPos,1]:SetText(aCadTipo[nPos,2])

	//Montando lista de opcoes (radio ou check)
	nLimCol   := aSize[5]/8
	nAcumLi := 0
	For nXX := 1 To Len(aCadTipo[nPos,4])
		cStrXX := Alltrim( Str(nXX) )
		cDescBox := SubStr(aCadTipo[nPos,4,nXX],3)
		If (nAcumLi + Len(cDescBox) + 5) > nLimCol .or. nXX == 1
				nLinObj += 9
				nAcumLi := 0
				nPosPnl += 9
		Endif
		If aCadTipo[nPos,6]
			aCadTipo[nPos,8,nXX,2] := TBtnBmp2():New( nPosPnl*2,26+(nAcumLi*7),14,14,;
			If(aCadTipo[nPos,8,nXX,1]==0,"ngradiono","ngradiook"),,,,{||},oObjPai,,,.T. )
			@ nPosPnl, 22+(nAcumLi*3.5) SAY aCadTipo[nPos,8,nXX,3] Prompt Space(30) PIXEL OF oObjPai
			aCadTipo[nPos,8,nXX,3]:SetText(cDescBox)
			If lVisual
				aCadTipo[nPos,8,nXX,2]:lReadOnly := .T.
			Else
				aCadTipo[nPos,8,nXX,3]:bLClicked := &("{|| fRadioMdt("+cStrYY+","+cStrXX+") }")
				aCadTipo[nPos,8,nXX,2]:bAction := &("{|| fRadioMdt("+cStrYY+","+cStrXX+") }")
			Endif
		Else
			aCadTipo[nPos,8,nXX,2] := TCheckBox():New(nPosPnl,13+(nAcumLi*3.5),cDescBox,,oObjPai,13+(Len(cDescBox)*3.9),7,,,,,,,,.T.)
			aCadTipo[nPos,8,nXX,2]:bSetGet := &("{|u| If(PCount()==0,aCadTipo["+cStrYY+",8,"+cStrXX+",1],aCadTipo["+cStrYY+",8,"+cStrXX+",1]:=u)}")
			If lVisual
				aCadTipo[nPos,8,nXX,2]:lReadOnly := .T.
			Endif
		Endif
		nAcumLi += Len(cDescBox) + 8
	Next nXX

	If aCadTipo[nPos,7]
		//Campo Memo
		nLinObj += 10
		nPosPnl += 10
		oIndNG[nPos,2] := TMultiget():New(nPosPnl,12,,oObjPai,aPosObj[1,4]-30,18,,,,,,.T.)
		oIndNG[nPos,2]:EnableHScroll(.T.)
		oIndNG[nPos,2]:EnableVScroll(.T.)
		oIndNG[nPos,2]:bSetGet := ;
			&("{|u| If(pCount() == 0, aCadTipo["+cStrYY+",10], aCadTipo["+cStrYY+",10]:=u)}")
		nLinObj += 12
		nPosPnl += 12
		If lVisual
			oIndNG[nPos,2]:lReadOnly := .T.
		Endif
		oIndNG[nPos,2]:Refresh()
	Endif
	nLinObj += 13
	nPosPnl += 13
	@ nPosOld,09 TO nPosPnl-3,aPosObj[1,4]-15 OF oObjPai PIXEL

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT145HIST
Chamada do Browse de histórico de exclusao - Necessidade de funcao pois o Browse é montado sobre um TRB, portanto precisava posicionar na tabela

@author Jackson Machado
@since 31/01/2013
@return Nil, Sempre Nulo
/*/
//---------------------------------------------------------------------
Function MDT145HIST()

	Local aArea := GetArea()

	dbSelectArea( "TMI" )
	dbSetOrder( 1 )
	dbSeek( xFilial( "TMI" ) + (cAliasQue)->TMI_NUMFIC + DTOS( STOD( (cAliasQue)->TMI_DTREAL ) ) + (cAliasQue)->TMI_QUESTI )
	MDTA991( "TMI" , { "TMI_NUMFIC" , "TMI_USERGI" } , { TM0->TM0_NUMFIC , TM0->TM0_DTIMPL } )

	RestArea(aArea)

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT145OBD
Função responsavel por habilitar o preenchimento do campo de Observação,
mesmo não existindo campos de perguntas.

@Param cPerg - Pergunta utilizada.

@Obs Uso MDTA145 e MDTA410

@author  Guilherme Freudenburg
@since   09/05/2016
@return  Nil, Sempre Nulo
/*/
//---------------------------------------------------------------------
 Function MDT145OBD(cPerg)

	Local nBck := 0 //Backup para a opção selecionada
	Local lPerg := .F. //Determina se foi alterado a opção

	If IsInCallStack("MDTA200")
		cPerg := PADR( cPerg , 10 )
	EndIf

	//Cria Backup da opção selecionada atualmente
	nBck := mv_par01

	lPerg:= Pergunte( cPerg , .T. )

	If !lPerg
		mv_par01 := nBck //Caso não confirme será retorna a opção anterior
	Endif

Return Nil
