#Include "Protheus.ch"
#Include "MDTA215.ch"
#include "ap5mail.ch"

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTA215
Programa de Cadastro de Laudo por risco.
Para cada risco definido o usuario pordera relacionar os
laudos previamente definidos e ja registrados no sistema.

@return

@sample MDTA215()

@author Thiago Machado - Refeito por: Jackson Machado
@since 23/07/01 - Revisão: 28/10/13
/*/
//---------------------------------------------------------------------
Function MDTA215()

	Local aNGBEGINPRM	:= NGBEGINPRM() // Armazena variaveis p/ devolucao (NGRIGHTCLICK)
    Local cGRUPO, aPERG, aHELP, nA

	Private lSigaMdtPS	:= If( SuperGetMv( "MV_MDTPS" , .F. , "N" ) == "S" , .T. , .F. )
	Private cCadastro	:= OemtoAnsi( If( lSigaMdtPs , "Clientes" , STR0007 ) ) //"Laudos por Risco"
	Private cPrograma	:= "MDTA215"

	Private nSizeCli	:= If((TAMSX3("A1_COD")[1]) < 1,6,(TAMSX3("A1_COD")[1]))
	Private nSizeLoj	:= If((TAMSX3("A1_LOJA")[1]) < 1,2,(TAMSX3("A1_LOJA")[1]))

	Private lCheckMsg,aCOLSTJ0,lTN0EMAIL
	Private aX3TIPADI := {}
	Private aTIPADI   := {}
	Private aX3PERINT

	aX3TIPADI := {}
	IF TMA->(FIELDPOS("TMA_TIPADI")#0)
	   aX3TIPADI := ComboX3Box("TMA_TIPADI",X3Cbox())
	ENDIF
	aX3PERINT := {}
	IF TMA->(FIELDPOS("TN0_PERINT")#0)
	   aX3PERINT := ComboX3Box("TN0_PERINT",X3Cbox())
	ENDIF

	IF NGCADICBASE("TMA_TIPADI",'A','TMA',.F.)
		aX3TIPADI := ComboX3Box("TMA_TIPADI",X3Cbox())
		FOR nA := 1 TO LEN(aX3TIPADI)
		    AADD(aTIPADI,SUBSTR(aX3TIPADI[nA],AT("=",aX3TIPADI[nA])+1))
		NEXT
	ENDIF

	lTN0EMAIL := .F.

	Mdt215Brw( If( lSigaMdtPs , "SA1" , "TO0" ) , 1 , MenuDef( lSigaMdtPs ) )

	NGRETURNPRM(aNGBEGINPRM) // Devolve variaveis armazenadas (NGRIGHTCLICK)

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} Mdt215Brw
Tela inicial para selecao de Cliente. [Prestador de Servico]

@return

@sample Mdt215Brw( 'SA1' , 1 , {} )

@param cAliasBrw - Indica o Alias do Browse (Obrigatório)
@param nOrdBrw	 - Indica o indice do Browse (Obrigatório)
@param aRotPar	 - Indica o aRotina a ser considerado (Obrigatório)

@author Jackson Machado
@since 28/10/13
/*/
//---------------------------------------------------------------------
Static Function Mdt215Brw( cAliasBrw , nOrdBrw , aRotPar )

	Default aRotPar := {}
	Default nOrdBrw := 1

	Private aRotina := aClone( aRotPar )

	If Len( aRotina ) == 0
		Return
	Endif

	dbSelectArea( cAliasBrw )
	dbSetOrder( nOrdBrw )
	mBrowse( 6 , 1 , 22 , 75 , cAliasBrw )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} Mdt215PsLd
Tela inicialm para selecao de Laudos. [Prestador de Servico]

@param cAlias	- Alias do Browse (Obrigatório)
@param nRecno	- Recno do Registro (Obrigatório)
@param nOpcx	- Opção de Seleção (Obrigatório)

@samples Mdt215PsLd( 'SA1' , 1 , 4 )

@author Jackson Machado
@since 28/10/13
/*/
//---------------------------------------------------------------------
Function Mdt215PsLd( cAlias , nRecno , nOpcx )

	Private cCliMdtPs := SA1->A1_COD + SA1->A1_LOJA

	dbSelectArea( "TO0" )
	Set Filter To TO0->TO0_CLIENT+TO0->TO0_LOJA == cCliMdtPs

	Mdt215Brw( "TO0" , 2 , MenuDef( .F. ) )

	dbSelectArea( "TO0" )
	Set Filter To

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MenuDef
Menu Funcional.

@return aRotina - Array de Opções de Menu

@param lMdtPs - Indica se é Prestador de Serviço

@samples MenuDef()

@author Jackson Machado
@since 28/10/13
/*/
//---------------------------------------------------------------------
Static Function MenuDef( lMdtPs )

	Local aRotina := {}

	Default lMdtPs := GetNewPar("MV_MDTPS","N") == "S"

	If lMdtPs
		aRotina := { { STR0001 , "AxPesqui"		, 0, 1 } , ;	// "Pesquisar"
					 { STR0002 , "NGCAD01"		, 0, 2 } , ;	// "Visualizar"
					 { STR0016 , "Mdt215PsLd"	, 0, 4 } }		// "Laudos"
	Else
		aRotina := { { STR0001 , "AxPesqui"		, 0, 1 } , ;	// "Pesquisar"
					 { STR0002 , "NGCAD01"		, 0, 2 } , ;	// "Visualizar"
					 { STR0003 , "Mdt215Cad"	, 0, 4 } }		// "Riscos"
	Endif

Return aRotina

//---------------------------------------------------------------------
/*/{Protheus.doc} MDT125AGE
Busca valores para dois campos virtuais ao mesmo tempo codigo e nome do agente, na inclusao.

@return Null

@samples MDT125AGE()

@author Jackson Machado
@since 28/10/13
/*/
//---------------------------------------------------------------------
Function MDT125AGE()

	Local nX
	Local nPosNom
	Local aArea := GetArea()

	If Type( "aHeader" ) == "A"
		nPosNom := aSCAN( aHeader , { | x | Trim( Upper( x[ 2 ] ) ) == "TO1_NOMRIS" } )
		dbSelectArea( "TN0" )
		dbSetOrder( 1 )
		dbSeek( xFilial( "TN0" ) + M->TO1_NUMRIS )
		dbSelectArea( "TMA" )
		dbSetOrder( 1 )
		dbseek( xFilial( "TMA" ) + TN0->TN0_AGENTE )
		aCols[ n , nPosNom ] := TMA->TMA_NOMAGE
	Else
		dbSelectArea( "TN0" )
		dbSetOrder( 1 )
		If Dbseek( xFilial( "TN0" ) + M->TO1_NUMRIS )
			cAgente := TN0->TN0_AGENTE
			dbSelectArea( "TMA" )
			dbSetOrder( 1 )
			If dbSeek( xFilial( "TMA" ) + cAgente )
				M->TO1_NOMRIS := TMA->TMA_NOMAGE
			Endif
		Endif
	Endif

	RestArea( aArea )

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} GETBROWTO1
Retorna o valid ou o inicializador do campo

@return xRet - Caso seja validação, retorna lógico, caso seja inicializador, retorna caracter

@param cNumRis	- Indica o número do risco (Obrigatório)
@param nNum		- Indica se é validação (1) ou se é inicializador (2) (Obrigatório)

@samples GETBROWTO1( '0000000001' , 1 )

@author Jackson Machado
@since 28/10/13
/*/
//---------------------------------------------------------------------
Function GETBROWTO1( cNumRis , nNum )

	Local xRet	:= Space(20)
	Local aArea	:= GetArea()

	dbSelectArea( "TN0" )
	dbSetOrder( 1 )
	If dbSeek( xFilial( "TN0" , TO1->TO1_FILIAL ) + cNumRis )
		dbSelectArea( "TMA" )
		dbSetOrder( 1 )
		If dbSeek( xFilial( "TMA" , TO1->TO1_FILIAL ) + TN0->TN0_AGENTE )
			xRet := SubStr( TMA->TMA_NOMAGE , 1 , 20 )
		EndIf
	EndIf

	If nNum == 1
		M->TO1_NOMRIS := xRet
		xRet := .T.
	EndIf

	RestArea( aArea )

Return xRet

//---------------------------------------------------------------------
/*/{Protheus.doc} Mdt215Cad
Inclusao de Riscos Avaliados no Laudo

@return Null

@samples Mdt215Cad()

@author Jackson Machado
@since 28/10/13
/*/
//---------------------------------------------------------------------
Function Mdt215Cad(cAlias,nReg,nOpcx)

	Local lOk		:= .F.
	Local nIdx		:= 1
	Local cSeek		:= " TO0->TO0_LAUDO "
	Local cWhile	:= " TO1->TO1_FILIAL == '" + xFilial( "TO1" ) + "' .AND. TO1->TO1_LAUDO == '" + TO0->TO0_LAUDO + "' "
	Local aNoFields	:= {}
	Local oPanel, oPnlTOT
	Local oDialog, oMenu

	//Variaveis de tamanho de tela
	Local lEnchBar	:= .T. // Indica se a janela de diálogo possuirá enchoicebar
	Local lPadrao	:= .F. // Indica se a janela deve respeitar as medidas padrões do Protheus (.T.) ou usar o máximo disponível (.F.)
	Local nMinY		:= 430 // Altura mínima da janela
	Local aSize 	:= MsAdvSize( lEnchBar , lPadrao , nMinY )

	//Definição do Objeto de GetDados Private - Utilizado na rotina MDTA216
	Private oGet215
	Private aCols
	Private aHeader

	//Demais variaveis
	Private aButtons := {}
	Private aOLDACOLS
	Private aCOLSTJ0 := {}

	If NGCADICBASE('TJ0_LAUDO','A','TJ0',.F.)
		AADD(aBUTTONS,{"VENDEDOR",{|| MDT215FER()},STR0029,STR0029 }) //"Func.Exp.Risco" ## "Func.Exp.Risco"
	EndIf

	aAdd( aNoFields , "TO1_FILIAL" )
	aAdd( aNoFields , "TO1_LAUDO" )
	aAdd( aNoFields , "TO1_NOMLAU" )

	If lSigaMdtPs
		aAdd( aNoFields , "TO1_CLIENT" )
		aAdd( aNoFields , "TO1_LOJA" )
		nIdx	:= 3
		cSeek	:= " cCliMdtPs + TO0->TO0_LAUDO "
		cWhile	:= " TO1->TO1_FILIAL == '" + xFilial( "TO1" ) + "' .AND. TO1->TO1_LAUDO == '" + TO0->TO0_LAUDO + "' .And. "
		cWhile	+= " TO1->TO1_CLIENT+TO1->TO1_LOJA = cCliMdtPs "
	EndIf
	FillGetDados( 4 , "TO1" , nIdx , cSeek , { | | } , { | | .T.} , aNoFields , , , , ;
					{ | | NGMontaaCols( "TO1" , &cSeek , cWhile ) } )

	If Empty( aCols )
	   aCols := BlankGetd( aHeader )
	Else
	   M->TO1_NUMRIS := TO1->TO1_NUMRIS
	EndIf

	// CARREGA FUNCIONARIOS EXPOSTOS
	If TN0->(FIELDPOS("TN0_PERINT")) > 0
	   TJ0->(DBSETORDER(1))
	   TJ0->(DBSEEK(XFILIAL("TJ0")+TO0->TO0_LAUDO,.T.))
	   Do While ! TJ0->(EOF()) .And.;
	      TJ0->(TJ0_FILIAL+TJ0_LAUDO) == (XFILIAL("TJ0")+TO0->TO0_LAUDO)
	      *
	      TN0->(DBSETORDER(1))
	      TN0->(DBSEEK(XFILIAL("TN0")+TJ0->TJ0_NUMRIS))
	      TMA->(DBSETORDER(1))
	      TMA->(DBSEEK(XFILIAL("TMA")+TN0->TN0_AGENTE))
	      SRA->(DBSETORDER(1))
	      SRA->(DBSEEK(XFILIAL("SRA")+TJ0->TJ0_MAT))
	      aAdd(aCOLSTJ0,{TJ0->TJ0_NUMRIS,;  //01.RISCO
	                     TMA->TMA_NOMAGE,;  //02.NOME DO AGENTE
	                     TJ0->TJ0_MAT,;     //03.MATRICULA DO FUNCIONARIO
	                     SRA->RA_NOME,;     //04.NOME DO FUNCIONARIO
	                     NGRETSX3BOX( "TMA_TIPADI" , TMA->TMA_TIPADI ),;//TJ0->TJ0_TIPOAD,;  //05.TIPO DE ADICIONAL "TMA->TMA_TIPADI"
	                     NGRETSX3BOX( "TN0_PERINT" , TN0->TN0_PERINT ),;//TN0->TN0_PERINT,;  //06.PERCENTUAL DO ADICIONAL
	                     TJ0->TJ0_PERFOL,;  //07.PERCENTUAL EM FOLHA
	                     TJ0->TJ0_DTINEX,;  //08.DATA DE INICIO NA TAREFA
	                     TJ0->TJ0_DTFIEX,;  //09.DATA DE FINALIZACAO DA TAREFA
	                     TJ0->TJ0_CONFEX,;  //10.1=CONFIRMADA A EXPOSICAO OU 2=NAO CONFIRMADA A EXPOSICAO
	                     TJ0->TJ0_DTCONF,;  //11.DATA DA CONFIRMACAO DA EXPOSICAO
	                     .F.})                 //12.LINHA VALIDA
	      TJ0->(DBSKIP())
	   EndDo
	EndIf

	dbSelectArea("TO1")

	Define MsDialog oDialog Title Ccadastro From aSize[ 7 ] , 0 To aSize[ 6 ] , aSize[ 5 ] Of oMainWnd Pixel

		oPnlTOT := TPanel():New( , , , oDialog , , , , , , , , .F. , .F. )
			oPnlTOT:Align := CONTROL_ALIGN_ALLCLIENT

		oPanel := TPanel():New( 0 , 0 , , oPnlTOT , , .T. , .F. , , , 0 , 70 , .T. , .F. )
			oPanel:Align := CONTROL_ALIGN_TOP

			TSay():New( 07 , 006 , { | | OemtoAnsi( STR0005 ) } , oPanel , , , .F. , .F. , .F. , .T. , , , 020 , 008 )//"Laudo"
			TGet():New( 05 , 028 , { | u | If( PCount() > 0 , TO0->TO0_LAUDO := u , TO0->TO0_LAUDO ) } , oPanel , 60 , 10 , "@!" , ;
						, , , , , , .T. , "" , , { | | .F. } , .F. , .F. , , .F. , .F. , "TO0" , , , , , .T. )

			TSay():New( 21 , 006 ,{ | | OemtoAnsi( STR0009 ) } , oPanel , , , .F. , .F. , .F. , .T. , , , 020 , 008 )//"Nome"
			TGet():New( 19 , 028 , { | u | If( PCount() > 0 , TO0->TO0_NOME := u , TO0->TO0_NOME ) } , oPanel , 150 , 10 , "@!" , ;
						, , , , , , .T. , "" , , { | | .F. } , .F. , .F. , , .F. , .F. , , , , , , )

			TSay():New( 35 , 006 ,{ | | OemtoAnsi( STR0010 ) } , oPanel , , , .F. , .F. , .F. , .T. , , , 040 , 008 )//"Dt.Incic"
			TGet():New( 33 , 028 , { | u | If( PCount() > 0 , TO0->TO0_DTINIC := u , TO0->TO0_DTINIC ) } , oPanel , 50 , 10 , "99/99/9999" , ;
						, , , , , , .T. , "" , , { | | .F. } , .F. , .F. , , .F. , .F. , , , , , , .T. )

			TSay():New( 35 , 139 ,{ | | OemtoAnsi( STR0011 ) } , oPanel , , , .F. , .F. , .F. , .T. , , , 040 , 008 )//"Data Fim"
			TGet():New( 33 , 164 , { | u | If( PCount() > 0 , TO0->TO0_DTFIM := u , TO0->TO0_DTFIM ) } , oPanel , 50 , 10 , "99/99/9999" , ;
						, , , , , , .T. , "" , , { | | .F. } , .F. , .F. , , .F. , .F. , , , , , , .T. )

			TButton():New( 53 , 5 , "&"+STR0003 , oPanel, { | | fMarkRis( oGet215 ) } , 49 , 12 ,, /*oFont*/,,.T.,,,,/* bWhen*/,,)//"Riscos"

		oGet215 := MsNewGetDados():New( 0 , 0 , 1000 , 1000 , IIF( !INCLUI .And. !ALTERA , 0 , GD_INSERT+GD_UPDATE+GD_DELETE ) , ;
						{ | | fLinhaOk( "TO1" , , oGet215 ) } , { | | .T. } , , , , 9999 , , , , oPnlTOT , aHeader , aCols )
			oGet215:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

		NGPOPUP( asMenu , @oMenu , oPanel )
		oPanel:bRClicked:= { | o , x , y | oMenu:Activate( x , y , oPanel ) }

	Activate MsDialog oDialog On Init EnchoiceBar( oDialog , ;
												 { | | lOk := .T. , If( fLinhaOk( "TO1" , .T. , oGet215 ) , oDialog:End() , lOk := .F. ) } , ;
												 { | | oDialog:End() }, , aBUTTONS )

	If lOk
		Begin Transaction

		fGrava()

		If NGCADICBASE( 'TJ0_LAUDO', 'A', 'TJ0', .F. )

			aOLDACOLS := ACLONE( aCOLS )
			PROCESSA( { || fEfetFunc() }, STR0030 ) //"Efetivando Func. Exp. Risco"
			aCOLSTJ0 := ACLONE( aCOLS )
			aCOLS    := ACLONE( aOLDACOLS )

			If TN0->( FIELDPOS( "TN0_PERINT" ) ) > 0 .And. Len( aCOLSTJ0 ) > 0

				If aScan( aCOLSTJ0, { |x| !x[12] .And. x[10] == "1" } ) > 0

					If PERGUNTE( "MDTA215" )
		      			MDT215EMAI( MV_PAR01 )
	   				EndIf
		   		EndIf

			   	//IMPRESSAO DE LAUDO PERICIAL
				MDTR570()
			EndIf

		EndIf

		End Transaction
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fLinhaOk
Validações de Linha

@return Null

@param cAlias	- Indica o Alias a ser considerado para validação (Obrigatório)
@param lFim		- Indica se é TudoOk
@param oObj		- Indica o Objeto a ser considerado (Obrigatório)

@samples fLinhaOk()

@author Jackson Machado
@since 28/10/13
/*/
//---------------------------------------------------------------------
Static Function fLinhaOk( cAlias, lFim, oObj )

	Local aColsOk 	:= {}
	Local aHeadOk	:= {}
	Local aRisEnv	:= {}
	Local nCont		:= 0
	Local nPosCod 	:= 1
	Local nAt		:= 1
    Local lRet		:= .T.

	Default lFim	:= .F.

	If cAlias == "TO1"
		aColsOk	:= aClone( oObj:aCols )
		aHeadOk	:= aClone( aHeader )
		nAt		:= oObj:nAt
		nPosCod	:= aScan( aHeadOk, { | x | Trim( Upper( x[ 2 ] ) ) == "TO1_NUMRIS" } )
		If lFim .And. Len( aColsOk ) == 1 .And. Empty( aColsOk[ 1, nPosCod ] )
			Return lRet
		EndIf
	Endif

	aCols := aClone( oObj:aCols )

	//Percorre aCols
	For nCont := 1 to Len( aColsOk )
		If !aColsOk[ nCont, Len( aColsOk[ nCont ] ) ]

			If lFim .Or. nCont == nAt
				//VerIfica se os campos obrigatórios estão preenchidos
				If Empty( aColsOk[ nCont, nPosCod ] )
					//Mostra mensagem de Help
					Help( " ", 1, "OBRIGAT2", , aHeadOk[ nPosCod, 1 ], 3, 0 )
					lRet := .F.
					Exit
				Endif
			Endif

			//Verifica se é somente LinhaOk
			If nCont <> nAt .And. !aColsOk[ nAt, Len( aColsOk[ nAt ] ) ]
				If aColsOk[ nCont, nPosCod ] == aColsOk[ nAt, nPosCod ]
					Help( " ", 1, "JAEXISTINF", , aHeadOk[ nPosCod, 1 ] )
					lRet := .F.
					Exit
				Endif
			Endif

			//Adiciona o Risco para envio ao eSocial
			aAdd( aRisEnv, { aColsOk[ nCont, 1 ] } )
		Endif
	Next nCont

	//-------------------------------------------------------------------------------------
	// Realiza as validações das informações do evento S-2240 que serão enviadas ao Governo
	//-------------------------------------------------------------------------------------
	/*If lRet .And. lFim
		lRet := MDTLauS2240( aRisEnv, .F. )
	EndIf*/

	PutFileInEof( "TO1" )
	PutFileInEof( "TMA" )
	PutFileInEof( "TN0" )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fGrava
Inclusao de Riscos Avaliados no Laudo

@return Null

@samples fGrava()

@author Jackson Machado
@since 28/10/13
/*/
//---------------------------------------------------------------------
Static Function fGrava()

	Local i, j, nX
	Local nPosCod	:= aScan( aHeader, { | x | Trim( Upper( x[ 2 ] ) ) == "TO1_NUMRIS" } )
	Local nOrd		:= 1
	Local cKey		:= xFilial( "TO1" ) + TO0->TO0_LAUDO
	Local cWhile	:= "xFilial( 'TO1' ) + TO0->TO0_LAUDO == TO1->TO1_FILIAL + TO1->TO1_LAUDO"
	Local aColsOk	:= aClone( aCols )
	Local aRisEnv	:= {}

	If lSigaMdtPs
		nOrd	:= 3
		cKey	:= xFilial( "TO1" ) + cCliMdtPs + TO0->TO0_LAUDO
		cWhile	:= "xFilial( 'TO1' ) + TO0->TO0_CLIENT + TO0->TO0_LOJA + TO0->TO0_LAUDO == TO1->TO1_FILIAL + cCliMdtPs + TO1->TO1_LAUDO"
	EndIf

	If Len( aColsOK ) > 0
		//Coloca os deletados por primeiro
		aSORT( aColsOK, , , { | x, y | x[ Len( aColsOK[ 1 ] ) ] .And. !y[ Len( aColsOK[ 1 ] ) ] } )

		For i := 1 to Len( aColsOK )
			If !aColsOK[ i, Len( aColsOK[ i ] ) ] .And. !Empty( aColsOK[ i, nPosCod ] )

				dbSelectArea( "TO1" )
				dbSetOrder( nOrd )
				If dbSeek( cKey + aColsOK[ i, nPosCod ] )
					RecLock( "TO1", .F. )
				Else
					RecLock( "TO1", .T. )
				EndIf

				For j := 1 to FCount()
					If "_FILIAL" $ Upper( FieldName( j ) )
						FieldPut( j, xFilial( "TO1" ) )
					ElseIf "_LAUDO" $ Upper( FieldName( j ) )
						FieldPut( j, TO0->TO0_LAUDO )
					ElseIf "_CLIENT" $ Upper( FieldName( j ) )
						FieldPut( j, SA1->A1_COD )
					ElseIf "_LOJA" $ Upper( FieldName( j ) )
						FieldPut( j, SA1->A1_LOJA )
					ElseIf ( nPos := aScan( aHeader, { | x | Trim( Upper( x[ 2 ] ) ) == Trim( Upper( FieldName( j ) ) ) } ) ) > 0
						FieldPut( j, aColsOK[ i, nPos ] )
					EndIf
				Next j

				TO1->( MsUnlock() )

				//Adiciona Riscos ao array para envio ao eSocial
				aAdd( aRisEnv, { aColsOK[ i, nPosCod ] } )

			ElseIf !Empty( aColsOK[ i, nPosCod ] )

				dbSelectArea( "TO1" )
				dbSetOrder( nOrd )
				If dbSeek( cKey + aColsOK[ i, nPosCod ] )
					RecLock( "TO1", .F. )
					TO1->( DbDelete() )
					TO1->( MsUnlock() )
				EndIf

			EndIf
		Next i
	EndIf

	dbSelectArea( "TO1" )
	dbSetOrder( nOrd )
	dbSeek( cKey )
	While !Eof() .And. &( cWhile )
		If aScan( aColsOK, { | x | x[ nPosCod ] == TO1->TO1_NUMRIS .And. !x[ Len( x ) ] } ) == 0
			RecLock( "TO1", .F. )
			TO1->( DbDelete() )
			TO1->( MsUnlock() )
		EndIf
		dbSelectArea( "TO1" )
		dbSkip()
	End

	//Retira todos os registros dos funcionários expostos a riscos
	If TN0->( FieldPos( "TN0_PERINT" ) ) > 0
		TJ0->( dbSetOrder( 1 ) )
		TJ0->( dbSeek( xFilial( "TJ0" ) + TO0->TO0_LAUDO, .T. ) )
		Do While ! TJ0->( EoF() ) .And. TJ0->( TJ0_FILIAL + TJ0_LAUDO ) == ( xFilial( "TJ0" ) + TO0->TO0_LAUDO )
			TJ0->( RecLock( "TJ0", .F. ) )
			TJ0->( dbDelete() )
			TJ0->( MsUnlock() )
			TJ0->( dbSkip() )
		EndDo

		//Grava os funcionários expostos ao risco
		For nX := 1 To Len( aCOLSTJ0 )
			If !aCOLSTJ0[ nX, Len( aCOLSTJ0[ 1 ] ) ]
				TJ0->( RecLock( "TJ0", .T. ) )
				TJ0->TJ0_FILIAL := xFilial( "TJ0" )
				TJ0->TJ0_LAUDO  := TO0->TO0_LAUDO
				TJ0->TJ0_NUMRIS := aCOLSTJ0[ nX, 1 ]
				TJ0->TJ0_MAT    := aCOLSTJ0[ nX, 3 ]
				TJ0->TJ0_TIPOAD := IIf( "PERI" $ Upper( aCOLSTJ0[ nX, 5 ] ), "2", IIf( "INSA" $ Upper( aCOLSTJ0[ nX, 5 ] ), "1", "" ) )
				TJ0->TJ0_PERINT := IIf( "N" == Upper( Left( Alltrim( aCOLSTJ0[ nX, 6 ] ), 1 ) ), "5", Left( Alltrim( aCOLSTJ0[ nX, 6 ] ), 1 ) )
				TJ0->TJ0_PERFOL := aCOLSTJ0[ nX, 7 ]
				TJ0->TJ0_DTINEX := aCOLSTJ0[ nX, 8 ]
				TJ0->TJ0_DTFIEX := aCOLSTJ0[ nX, 9 ]
				TJ0->TJ0_CONFEX := Left( aCOLSTJ0[ nX, 10 ], 1 )
				TJ0->TJ0_DTCONF := aCOLSTJ0[ nX, 11 ]
				TJ0->( MsUnlock() )
			EndIf
		Next nX
	EndIf

	//-----------------------------------------------------------------
	// Realiza a integração das informações do evento S-2240 ao Governo
	//-----------------------------------------------------------------
	If FindFunction( "MDTIntEsoc" )
		MDTLauS2240( aRisEnv )
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fMarkRis
Monta um Mark para selecao dos riscos

@return Null

@param oObj - Objeto da GetDados (Obrigatório)

@samples fMarkRis( oObj )

@author Jackson Machado
@since 28/10/13
/*/
//---------------------------------------------------------------------
Static Function fMarkRis( oObj )

	//Variaveis de utilizacao (pesquisa e montagem)
	Local nPosVal
	Local nPosRis	:= aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TO1_NUMRIS"})
	Local nPosNom	:= aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TO1_NOMRIS"})
	Local cCombo	:= "1"
	Local lOk		:= .T.
	Local aColsSup	:= BlankGetd( aHeader )
	Local aResul	:= { STR0025 , STR0026 , "3=Inativos" }  //"1=Todos" ## "2=Ativos"
	Local aTamSX3   := TAMSX3("TN0_QTAGEN")

	//Montagem do TRB
	Local cAliTRB	:= GetNextAlias()
	Local aDBF		:= {}
	Local aTRB		:= {}
	Local oTempTRB

	//Objetos
	Local oMark, oPanel, oCbx, oDialog, oPnlTOT
	Local aArea 	:= GetArea()
	Local aDescIdx	:= {}
	Local cPesquisar:=Space( 200 )

	Private cMarca  := GetMark()
	Private OldCols := aCLONE(oGet215:aCols)
	Private aCbxPesq //ComboBox com indices de pesquisa
	Private cCbxPesq   := ""
	Private oCbxPesq //ComboBox de Pesquisa
	//Variaveis de Sistema
	lInverte := .F.
	lQuery   := .T.

	dbSelectArea( "TO1" )

	aDBF := {}
	aAdd( aDBF , { "TO1_OK"     , "C" , 02 , 0 } )
	aAdd( aDBF , { "TO1_NUMRIS" , "C" , 09 , 0 } )
	aAdd( aDBF , { "TO1_NOMRIS" , "C" , 40 , 0 } )
	aAdd( aDBF , { "TN0_NOMECC" , "C" , 20 , 0 } )
	aAdd( aDBF , { "TN0_DESCFU" , "C" , 20 , 0 } )
	aAdd( aDBF , { "TN0_NOMTAR" , "C" , 20 , 0 } )
	aAdd( aDBF , { "TN0_DESCDP" , "C" , 20 , 0 } )
	aAdd( aDBF , { "TN0_DTAVAL" , "D" , 08 , 0 } )
	aAdd( aDBF , { "TN0_DTELIM" , "D" , 08 , 0 } )
	aAdd( aDBF , { "TN0_QTAGEN" , "N" , aTamSX3[1] , aTamSX3[2] } )
	aAdd( aDBF , { "TN0_UNIMED" , "C" , 06 , 0 } )

	aTRB := {}
	aAdd( aTRB , { "TO1_OK"     , NIL , " "	 	, } )
	aAdd( aTRB , { "TO1_NUMRIS" , NIL , STR0012	, } ) //"Num. Risco"
	aAdd( aTRB , { "TO1_NOMRIS" , NIL , STR0013	, } ) //"Agente"
	aAdd( aTRB , { "TN0_NOMECC" , NIL , STR0018	, } ) //"Centro de Custo"
	aAdd( aTRB , { "TN0_DESCFU" , NIL , STR0019	, } ) //"Função"
	aAdd( aTRB , { "TN0_NOMTAR" , NIL , STR0073	, } ) //"Tarefa"
	aAdd( aTRB , { "TN0_DESCDP" , NIL , STR0074	, } ) //"Departamento"
	aAdd( aTRB , { "TN0_DTAVAL" , NIL , STR0020	, } ) //"Data de Avaliação"
	aAdd( aTRB , { "TN0_DTELIM" , NIL , STR0021	, } ) //"Data de eliminação"
	aAdd( aTRB , { "TN0_QTAGEN" , NIL , STR0022	, } ) //"Quantidade Agente"
	aAdd( aTRB , { "TN0_UNIMED" , NIL , STR0023	, } ) //"Unidade de Medida"

	oTempTRB := FWTemporaryTable():New( cAliTRB, aDBF )
	oTempTRB:AddIndex( "1", {"TO1_NUMRIS"} )
	oTempTRB:AddIndex( "2", {"TO1_NOMRIS"} )
	oTempTRB:AddIndex( "3", {"TO1_OK"} )
	oTempTRB:Create()

	fFiltraMark( cAliTRB, cCombo )

	dbSelectArea( cAliTRB )
	dbSetOrder( 1 )
	dbGoTop()
	If ( cAliTRB )->( Reccount() ) <= 0

		Msgstop( STR0017 , STR0014 ) // "Não existem riscos avaliados."###"ATENÇÃO"

	Else

		Define MsDialog oDialog Title OemToAnsi( STR0003 ) From 64,160 To 580,730 OF oMainWnd Pixel

			oPnlTOT := TPanel():New( , , , oDialog , , , , , , , , .F. , .F. )
				oPnlTOT:Align := CONTROL_ALIGN_ALLCLIENT

	   		oPnl := TPanel():New( 01 , 01 , , oPnlTOT , , , , CLR_BLACK , CLR_WHITE , 0 , 30 , .T. , .F. )
				oPnl:Align	:= CONTROL_ALIGN_TOP

			@ 14 , 16 Say STR0024 Of oPnl Pixel //"Mostrar Riscos:"
			@ 09 , 56 ComboBox oCbx Var cCombo Valid fFiltraMark( cAliTRB , cCombo , oMark ) ITEMS aResul SIZE 75,60  Of oPnl Pixel
			//--- PESQUISAR
			//Define as opcoes de Pesquisa
			aCbxPesq := aClone( aDescIdx )
			aAdd( aCbxPesq , STR0066 ) //"Código+Descrição"
			aAdd( aCbxPesq , STR0067 ) //"Descrição+Código"
			aAdd( aCbxPesq , STR0068 ) //"Marcados"
			cCbxPesq := aCbxPesq[ 1 ]

			oPanel := TPanel():New( 0 , 0 , , oPnlTOT , , .T. , .F. , , , 0 , 55 , .T. , .F. )
			oPanel:Align := CONTROL_ALIGN_TOP

			oCbxPesq := TComboBox():New( 010 , 002 , { | u | If( PCount() > 0 , cCbxPesq := u , cCbxPesq ) } , ;
			aCbxPesq , 200 , 08 , oPanel , , { | | } ;
			, , , , .T. , , , , , , , , , "cCbxPesq" )
			oCbxPesq:bChange := { | | fIndexSet( cAliTRB , aCbxPesq , @cPesquisar , oMark ) }

			oPesquisar := TGet():New( 025 , 002 , { | u | If( PCount() > 0 , cPesquisar := u , cPesquisar ) } , oPanel , 200 , 008 , "" , { | | .T. } , CLR_BLACK , CLR_WHITE , ,;
			.F. , , .T. /*lPixel*/ , , .F. , { | | .T. }/*bWhen*/ , .F. , .F. , , .F. /*lReadOnly*/ , .F. , "" , "cPesquisar" , , , , .F. /*lHasButton*/ )

			oBtnPesq := TButton():New( 010 , 220 , STR0001 , oPanel , { | | fTRBPes( cAliTRB , oMark , cPesquisar ) } , ;//"Pesquisar" //"Pesquisar"
			60 , 10 , , , .F. , .T. , .F. , , .F. , , , .F. )

			oMark := MsSelect():New( cAliTRB , "TO1_OK" , , aTRB , @lInverte , @cMarca , , , , oPnlTOT )
			oMark:oBrowse:lHasMark		:= .T.
			oMark:oBrowse:lCanAllMark	:= .T.
			oMark:oBrowse:bAllMark		:= { | | fInvMark( cAliTRB , cMarca ) }
			oMark:oBrowse:Align			:= CONTROL_ALIGN_ALLCLIENT

		ACTIVATE MSDIALOG oDialog ON INIT EnchoiceBar( oDialog , { | | oDialog:End() } , { | | lOk := .F. , oDialog:End() } )

		If lOk
			dbSelectArea( cAliTRB )
			dbSetOrder( 1 )
			dbGoTop()
			While ( cAliTRB )->( !Eof() )
				If Empty( ( cAliTRB )->TO1_OK )
					If( nPosVal := aScan( aCols , { | x | x[ nPosRis ] == ( cAliTRB )->TO1_NUMRIS } ) ) > 0
						aDel( aCols , nPosVal )
						aSize( aCols , Len( aCols ) - 1 )
					EndIf
				Else
					If aScan( aCols , { | x | x[ nPosRis ] == ( cAliTRB )->TO1_NUMRIS } ) == 0
						aAdd( aCols , aClone( aColsSup[ 1 ] ) )
						aCols[ Len( aCols ) , nPosRis ] := ( cAliTRB )->TO1_NUMRIS
						aCols[ Len( aCols ) , nPosNom ] := ( cAliTRB )->TO1_NOMRIS
					EndIf
				EndIf
				( cAliTRB )->( dbSkip() )
			End

			//Retira a posicao vazia caso seja primeira inclusao
			If( nPosVal := aScan( aCols , { | x | x[ nPosRis ] == Space( Len( ( cAliTRB )->TO1_NUMRIS ) ) } ) ) > 0
				aDel( aCols , nPosVal )
				aSize( aCols , Len( aCols ) - 1 )
			EndIf

			If Len( aCols ) == 0
				aCols := aClone( aColsSup )
			Endif

			oObj:aCols := aClone( aCols )
			oObj:oBrowse:Refresh()


		EndIf

	EndIf

	/*oTempTRB:Delete()
	RestArea( aArea )*/

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fInvMark
Inverte a marcacao do browse

@return Null

@param cAliTRB	- Alias do TRB (Obrigatório)
@param cMarca	- Indica a variavel usada para marcacao

@samples fInvMark()

@author Jackson Machado
@since 28/10/13
/*/
//---------------------------------------------------------------------
Static Function fInvMark( cAliTRB , cMarca )

	Local aArea := GetArea()

	dbSelectArea( cAliTRB )
	dbGoTop()
	While ( cAliTRB )->( !Eof() )
		( cAliTRB )->TO1_OK := If( Empty( ( cAliTRB )->TO1_OK ) , cMarca , Space( Len( ( cAliTRB )->TO1_OK ) ) )
		( cAliTRB )->( dbSkip() )
	End
	RestArea( aArea )

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fFiltraMark
Filtra os Riscos do MarkBrowse.

@author Gabriel Sokacheski
@since 09/02/2022

@param cAliTRB, caractere, Alias do TRB
@param cCombo, caractere, Opção selecionada do Combo
@param oObj, objeto, Objeto a ser atualizado

/*/
//---------------------------------------------------------------------
Static Function fFiltraMark( cAliTRB, cCombo, oObj )

	Local aArea := getArea()
	Local aGrid := aClone( oGet215:aCols )

	Local cOk := ''
	Local cAgente := ''
	Local cCenCus := ''
	Local cFuncao := ''
	Local cTarefa := ''
	Local cDepart := ''

	Local lTO0Finali:= NGCADICBASE( 'TO0_FINALI', 'A', 'TO0', .F. )

	Local nPosRis := aScan( aHeader, { | x | Trim( Upper( x[ 2 ] ) ) == 'TO1_NUMRIS' } )

	dbSelectArea( cAliTRB )
	ZAP

	dbSelectArea( 'TN0' )
	dbSetOrder( 1 )
	( 'TN0' )->( dbGoTop() )

	While ( 'TN0' )->( !Eof() )

		If TN0->TN0_FILIAL == xFilial( 'TN0' )

			If cCombo == '2' // Riscos Ativos

				If !Empty( TN0->TN0_DTELIM )

					( 'TN0' )->( dbSkip() )
					Loop

				EndIf

			ElseIf cCombo == '3' // Riscos Inativos

				If Empty( TN0->TN0_DTELIM )

					( 'TN0' )->( dbSkip() )
					Loop

				EndIf

			EndIf

			dbSelectArea( 'TMA' )
			dbSetOrder( 1 )

			If dbSeek( xFilial( 'TMA' ) + TN0->TN0_AGENTE )

				If lTO0Finali .And. TO0->TO0_TIPREL == '3' // L.T. Pericial

					If !Empty( TO0->TO0_FINALI )

						// Finalidade do Laudo deve ser igual ao Adicional do Agente
						If TMA->TMA_TIPADI != TO0->TO0_FINALI

							( 'TN0' )->( dbSkip() )
							Loop

						EndIf

					EndIf

				EndIf

				cAgente := TMA->TMA_NOMAGE

				// Busca o centro de custo
				If TN0->TN0_CC != '*'

					cCenCus := Posicione( 'CTT', 1, xFilial( 'CTT' ) + TN0->TN0_CC, 'CTT_DESC01' )

				Else

					cCenCus := STR0075

				EndIf

				// Busca a função
				If TN0->TN0_CODFUN != '*'

					cFuncao := Posicione( 'SRJ', 1, xFilial( 'SRJ' ) + TN0->TN0_CODFUN, 'RJ_DESC' )

				Else

					cFuncao := STR0076

				EndIf

				// Busca a tarefa
				If TN0->TN0_CODTAR != '*'

					cTarefa := Posicione( 'TN5', 1, xFilial( 'TN5' ) + TN0->TN0_CODTAR, 'TN5_NOMTAR' )

				Else

					cTarefa := STR0076

				EndIf

				// Busca o departamento
				If TN0->TN0_DEPTO != '*'

					cDepart := Posicione( 'SQB', 1, xFilial( 'SQB' ) + TN0->TN0_DEPTO, 'QB_DESCRIC' )

				Else

					cDepart := STR0075

				EndIf

			EndIf

			If aScan( aGrid, { | x | x[ nPosRis ] == TN0->TN0_NUMRIS } ) != 0

				cOk := cMarca

			EndIf

			dbSelectArea( cAliTRB )

			RecLock( cAliTRB, .T. ) // Incluir
				( cAliTRB )->TO1_OK := cOk
				( cAliTRB )->TO1_NUMRIS := TN0->TN0_NUMRIS
				( cAliTRB )->TO1_NOMRIS := cAgente
				( cAliTRB )->TN0_NOMECC := cCenCus
				( cAliTRB )->TN0_DESCFU := cFuncao
				( cAliTRB )->TN0_NOMTAR := cTarefa
				( cAliTRB )->TN0_DESCDP := cDepart
				( cAliTRB )->TN0_DTAVAL := TN0->TN0_DTAVAL
				( cAliTRB )->TN0_DTELIM := TN0->TN0_DTELIM
				( cAliTRB )->TN0_QTAGEN := TN0->TN0_QTAGEN
				( cAliTRB )->TN0_UNIMED := TN0->TN0_UNIMED
			( cAliTRB )->( MsUnLock() )

		EndIf

		cOk := ''

		( 'TN0' )->( dbSkip() )

	End

	dbSelectArea( cAliTRB )
	dbGoTop()

	If ValType( oObj ) == 'O'

		oObj:oBrowse:Refresh()

		If ( cAliTRB )->( Reccount() ) <= 0

			oObj:oBrowse:Disable()

		Else

			oObj:oBrowse:Enable()

		EndIf

	EndIf

	RestArea( aArea )

Return

//--------------------------------------------------------------------
//--------------------------------------------------------------------
Function MDTA215ALL(cP_PARA,cP_PARB)

	Local lRET
	Local nA,nB

	lRET    := .T.
	cP_PARA := IF(cP_PARA==NIL,"",cP_PARA)
	cP_PARB := IF(cP_PARB==NIL,"",cP_PARB)
	IF cP_PARA == "XB_TN0_FI"
		If NGCADICBASE('TO0_FINALI','A','TO0',.F.) .AND. TO0->TO0_TIPREL == "3"
			If !Empty(TO0->TO0_FINALI)
				cTipAdi := NGSEEK("TMA",TN0->TN0_AGENTE,1,"TMA_TIPADI")
				lRet := TO0->TO0_FINALI == cTipAdi .Or. TO0->TO0_FINALI == "3" .And. Empty( cTipAdi )
			EndIf
		EndIf
	ELSEIF cP_PARA == "TO1_NUMRIS"
		TN0->(DBSETORDER(1))
		IF ! (TN0->(DBSEEK(XFILIAL("TN0")+M->TO1_NUMRIS)))
			MSGINFO(AVSX3("TO1_NUMRIS",5)+STR0031,STR0032) //" nao localizado !" ## "Atencao"
			lRET := .F.
		ELSEIF ! MDTA215ALL("XB_TN0_FI")
			MSGINFO(AVSX3("TO1_NUMRIS",5)+STR0033+AVSX3("TO0_FINALI",5)+STR0034+;  //" nao compativel com a " ## " do "
			AVSX3("TO1_LAUDO",5)+" !",STR0032) //"Atencao"
			IF aCOLS <> NIL
				aCOLS[N,2] := SPACE(LEN(TMA->TMA_NOMAGE))
			ENDIF
			lRET := .F.
		ENDIF
	ELSEIF cP_PARA == "TJ0_DTCONF"
		IF cP_PARB == "GETDB"
			IF aCOLS[N,10] <> "1"
				lRET := .F.
			ENDIF
		ENDIF
	ELSEIF cP_PARA == "VGETD"
		IF READVAR() == "M->TJ0_CONFEX"
			IF EMPTY(M->TJ0_CONFEX)
				MSGINFO(STR0036,STR0032) //"Informe 1 para Sim ou 2 para Nao !" ## "Atencao"
				lRET := .F.
			ELSEIF M->TJ0_CONFEX <> "1"
				aCOLS[N,11] := CTOD("  /  /  ")
			ENDIF
		ELSEIF READVAR() == "M->TJ0_DTCONF"
			IF EMPTY(M->TJ0_DTCONF)
				MSGINFO(STR0037+AVSX3("TJ0_DTCONF",5)+" !",STR0032) //"Preenchimento obrigatorio do campo " ## "Atencao"
				lRET := .F.
			ELSEIF DTOS(M->TJ0_DTCONF) < DTOS(aCOLS[N,8])
				MSGINFO(AVSX3("TJ0_DTCONF",5)+STR0038+AVSX3("TJ0_DTINEX",5)+" !",STR0032) //" nao pode ser inferior a " ## "Atencao"
				lRET := .F.
			ELSEIF ! EMPTY(aCOLS[N,9]) .AND. DTOS(M->TJ0_DTCONF) > DTOS(aCOLS[N,9])
				MSGINFO(AVSX3("TJ0_DTCONF",5)+STR0039+AVSX3("TJ0_DTINEX",5)+" !",STR0032) //" nao pode ser superior a " ## "Atencao"
				lRET := .F.
			ENDIF
		ELSEIF READVAR() == "M->TO1_NUMRIS"
			IF ! EMPTY(aCOLS[N,1]) .AND.;
					aCOLS[N,1] <> M->TO1_NUMRIS

				MSGINFO(STR0040+AVSX3("TO1_NUMRIS",5)+STR0041,STR0032) //"Alteracao do " ## " nao permitida. Exclua a linha atual e inclua uma nova !" ## "Atencao"
				lRET := .F.
			ENDIF
		ENDIF
	ELSEIF cP_PARA == "VLINGD"
		nB := IF(EMPTY(cP_PARB),N,cP_PARB)
		IF EMPTY(aCOLS[N,1])
			MSGINFO(STR0042,STR0032) //"Inclusao nao permitida. Exclua a linha atual !" ## "Atencao"
			lRET := .F.
		ELSEIF aCOLS[nB,10] == "1"
			IF EMPTY(aCOLS[nB,11])
				MSGINFO(STR0037+AVSX3("TJ0_DTCONF",5)+" !",STR0032) //"Preenchimento obrigatorio do campo " ## "Atencao"
				lRET := .F.
			ENDIF
		ENDIF
	ELSEIF cP_PARA == "bOK_GD"
		FOR nA := 1 TO LEN(aCOLS)
			IF ! aCOLS[nA,LEN(aCOLS[nA])]
				IF ! MDTA215ALL("VLINGD",nA)
					lRET := .F.
					nA := LEN(aCOLS)+1
				ENDIF
			ENDIF
		NEXT
	ELSEIF cP_PARA == "DELGD"
		IF ! EMPTY(aCOLS[N,1])
			lRET := .F.
		ENDIF
	ELSEIF cP_PARA == "EMAILTO"
		IF EMPTY(cP_PARB)
			MSGINFO(STR0043,STR0032)  //"Preenchimento obrigatorio do email para envio !" ## "Atencao"
			lRET := .F.
		ENDIF
	ENDIF

RETURN(lRET)

//--------------------------------------------------------------------
//--------------------------------------------------------------------
Static Function MDT215FER()
	LOCAL cOALIAS,oDLG,bOK,bCANCEL,aBUTTONS,nOPC,aTO1,nA,oGETDB,aPOS,aEDITMPA,nNOLD,aSIZE
	PRIVATE aHEADER,lREFRESH,aX3TIPAD,aOLDACOLS

	nNOLD     := oGet215:nAt
	aOLDACOLS := ACLONE(aCOLS)
	BEGIN SEQUENCE
		IF LEN(aCOLS) == 0 .OR.;
			EMPTY(aCOLS[1,1])

			MSGINFO(STR0064,STR0014) //"Informe primeiramente um Risco para que seja possível localizar os funcionários !" ## "ATENCAO"
			BREAK
		ENDIF
		cOALIAS   := ALIAS()
		aSIZE     := MsAdvSize(,.f.,490)
		aTO1      := {TO1->(INDEXORD()),TO1->(RECNO())}
		aEDITMPA  := {"TJ0_PERFOL","TJ0_CONFEX","TJ0_DTCONF"}
		bOK       := {|| nBTOP := 1,IF(MDTA215ALL("bOK_GD"),oDLG:END(),nBTOP := 0)}
		bCANCEL   := {|| nBTOP := 0,oDLG:END()}
		aBUTTONS  := {}
		aCOLS     := {}
		nBTOP     := 0
		lREFRESH  := .F.
		// CARREGA aCOLS PARA TJ0
		PROCESSA( { | | fEfetFunc() } , STR0044 )//"Preenchimento obrigatorio do email para envio !"
			IF LEN(aCOLS) == 0 .OR. EMPTY(aCOLS[1,1])
			MSGINFO(STR0065,STR0014) // "Não a funcionários relacionados para as condições do(s) Risco(s) !" ## "ATENCAO"
			BREAK
		ENDIF
		// CARREGA AS COLUNAS DO BROWSE
		//           1.TITULO              2.Campo Temp 3.Picure              4.Tamanho             5 6.VALID
		aHEADER  := {{AVSX3("TJ0_NUMRIS",5),"TJ0_NUMRIS",AVSX3("TJ0_NUMRIS",6),AVSX3("TJ0_NUMRIS",3),0,""                   ,"","C","",""},;
						{AVSX3("TN0_NOMAGE",5),"TJ0A_NOMAG",AVSX3("TN0_NOMAGE",6),AVSX3("TN0_NOMAGE",3),0,""                   ,"","C","",""},;
						{AVSX3("TJ0_MAT"   ,5),"TJ0_MAT"   ,AVSX3("TJ0_MAT"   ,6),AVSX3("TJ0_MAT"   ,3),0,""                   ,"","C","",""},;
						{AVSX3("RA_NOME"   ,5),"TJ0A_NOMFU",AVSX3("RA_NOME"   ,6),AVSX3("RA_NOME"   ,3),0,""                   ,"","C","",""},;
						{AVSX3("TJ0_TIPOAD",5),"TJ0A_TIPOA",""                   ,18                   ,0,""                   ,"","C","",""},;
						{AVSX3("TJ0_PERINT",5),"TJ0A_PERIN",""                   ,17                   ,0,""                   ,"","C","",""},;
						{AVSX3("TJ0_PERFOL",5),"TJ0_PERFOL",AVSX3("TJ0_PERFOL",6),AVSX3("TJ0_PERFOL",3),0,ALLTRIM(X3VALID("TJ0_PERFOL")),"","N","",""},;
						{AVSX3("TJ0_DTINEX",5),"TJ0_DTINEX",AVSX3("TJ0_DTINEX",6),AVSX3("TJ0_DTINEX",3),0,""                   ,"","D","",""},;
						{AVSX3("TJ0_DTFIEX",5),"TJ0_DTFIEX",AVSX3("TJ0_DTFIEX",6),AVSX3("TJ0_DTFIEX",3),0,""                   ,"","D","",""},;
						{AVSX3("TJ0_CONFEX",5),"TJ0_CONFEX",AVSX3("TJ0_CONFEX",6),AVSX3("TJ0_CONFEX",3),0,"","","C","",""},;
						{AVSX3("TJ0_DTCONF",5),"TJ0_DTCONF",AVSX3("TJ0_DTCONF",6),AVSX3("TJ0_DTCONF",3),0,"","","D","",""}}
		// CARREGA O ARQUIVO TEMPORARIO
		DEFINE MSDIALOG oDLG TITLE cCADASTRO+STR0045 FROM aSIZE[7],0 TO aSIZE[6],aSIZE[5] OF oMainWnd PIXEL //" - Func.Exposto a Riscos"
			aPOS   := POSDLG(oDLG)
			oGetDB := MsGetDados():New(aPOS[1],aPOS[2],aPOS[3]-15,aPOS[4],3,"MDTA215ALL('VLINGD')",,,.T.,aEDITMPA,,.F.,500,"MDTA215ALL('VGETD')",,,"MDTA215ALL('DELGD')",oDlg)
		ACTIVATE MSDIALOG oDLG ON INIT ENCHOICEBAR(oDLG,bOK,bCANCEL,,aBUTTONS) CENTERED
		IF nBTOP == 1
			aCOLSTJ0 := ACLONE(aCOLS)
		ENDIF
		TO1->(DBSETORDER(aTO1[1])) ; TO1->(DBGOTO(aTO1[2]))
		IF ! EMPTY(cOALIAS)
			DBSELECTAREA(cOALIAS)
		ENDIF
	END SEQUENCE
	aCOLS			:= ACLONE(aOLDACOLS)
	oGet215:nAt	:= nNOLD
Return(NIL)

/*
---------------------------------------------------------------------------------
Relatorio de Atualizacao de Insalubridade / Periculosidade - Emissao.: 99/99/9999
---------------------------------------------------------------------------------

ATENCAO:
Os funcionarios abaixo relacionados devem receber adicional de insalubridade / periculosidade conforme indices informados na
coluna "Perc. SESMT" de acordo com o Laudo Tecnico Pericial: XXXXXXXXXX emitido pelo Eng.:XXXXXXXXXXXXXXX

Risco      Agente       Matricula   Nome                 Tipo Adicional  Perc SESMT  Per.Folha  Data Inicio   Data Fim
999999999  XXXXXXXXXXX  9999999999  XXXXXXXXXXXXXXXXXXX  XXXXXXXXXXXXXX      99,99%     99,99%  99/99/9999  99/99/9999
999999999  XXXXXXXXXXX  9999999999  XXXXXXXXXXXXXXXXXXX  XXXXXXXXXXXXXX      99,99%     99,99%  99/99/9999  99/99/9999
999999999  XXXXXXXXXXX  9999999999  XXXXXXXXXXXXXXXXXXX  XXXXXXXXXXXXXX      99,99%     99,99%  99/99/9999  99/99/9999
*/
Function MDT215EMAI(cP_EMAIL)

	Local cSERVER, cACCOUNT, cPASSWORD, lAUTENTICA, cUSERAUT, cPASSAUT, cFROM, cCC, lOK := .F., nA, cCCO

	Private nTIMEOUT := GETMV("MV_RELTIME",,120) //Tempo de Espera antes de abortar a Conexão

	BEGIN SEQUENCE
		cSERVER    := ALLTRIM(GETNEWPAR("MV_RELSERV",""))
		cACCOUNT   := ALLTRIM(GETNEWPAR("MV_RELACNT",""))
		cPASSWORD  := ALLTRIM(GETNEWPAR("MV_RELPSW"," "))
		lAUTENTICA := GETMV("MV_RELAUTH",,.F.)         //Determina se o Servidor de Email necessita de Autenticação
		cUSERAUT   := ALLTRIM(GETMV("MV_RELAUSR",,cACCOUNT))//Usuário para Autenticação no Servidor de Email
		cPASSAUT   := ALLTRIM(GETMV("MV_RELAPSW",,cPASSWORD))//Senha para Autenticação no Servidor de Email
		cFROM      := cACCOUNT
		cCC        := ""
		cError := ""
		CONNECT SMTP SERVER cSERVER ACCOUNT cACCOUNT PASSWORD cPASSWORD TIMEOUT nTIMEOUT RESULT lOK //Considerar Timeout no Envio
		IF ! lOK
			MSGINFO(STR0046,STR0032) //"Falha na Conexão com Servidor de E-Mail" ## "Atencao"
			BREAK
		ENDIF
		IF lAUTENTICA
			IF ! MAILAUTH(cUSERAUT,cPASSAUT)
				MSGINFO(STR0047,STR0032)  //"Falha na Autenticação do Usuário" ## "Atencao"
				DISCONNECT SMTP SERVER RESULT lOK
				BREAK
			ENDIF
		ENDIF
		// MONTA CORPO DO EMAIL
		cBODY := '<html>'
		cBODY := cBODY+'<body>'
		cBODY := cBODY+'<hr>'
		cBODY := cBODY+STR0048+DTOC(dDATABASE) //'Relatorio de Atualizacao de Insalubridade / Periculosidade - Emissao.: '
		cBODY := cBODY+'<hr>'
		cBODY := cBODY+'<br>'
		cBODY := cBODY+'<br>'+STR0049  //'ATENCAO:'
		cBODY := cBODY+'<br>'+STR0050+" "+STR0051+ALLTRIM(TO0->TO0_LAUDO)+STR0052 //'Os funcionarios abaixo relacionados devem receber adicional de insalubridade / periculosidade conforme indices informados na'

		TMK->(DBSETORDER(1))
		TMK->(DBSEEK(XFILIAL("TMK")+TO0->TO0_CODUSU))
		cBODY := cBODY+ALLTRIM(TMK->TMK_NOMUSU)
		cBODY := cBODY+'<br>'
		cBODY := cBODY+'<br>'
		cBODY := cBODY+'<table style="text-align: left; width: 1200Px; height: 100px;" border="1" cellpadding="4" cellspacing="1">'
		cBODY := cBODY+'  <tbody>'
		cBODY := cBODY+'    <tr>'
		cBODY := cBODY+'      <th>'+STR0053+'</th>'  //"Risco"
		cBODY := cBODY+'      <th>'+STR0054+'</th>'  //"Agente"
		cBODY := cBODY+'      <th>'+STR0055+'</th>'  //"Matricula"
		cBODY := cBODY+'      <th>'+STR0056+'</th>'  //"Nome"
		cBODY := cBODY+'      <th>'+STR0057+'</th>'  //"Tipo Adicional"
		cBODY := cBODY+'      <th>'+STR0058+'</th>'  //"Perc.SESMT"
		cBODY := cBODY+'      <th>'+STR0059+'</th>'  //"Perc.Folha"
		cBODY := cBODY+'      <th>'+STR0060+'</th>'  //"Data Inicio"
		cBODY := cBODY+'      <th>'+STR0061+'</th>'  //"Data Fim"
		cBODY := cBODY+'    </tr>'
		lOK := .F.
		FOR nA := 1 TO LEN(aCOLSTJ0)
			IF ! aCOLSTJ0[nA,12] .AND.;
				aCOLSTJ0[nA,10] == "1"

				DbSelectArea("TN0")
				TN0->(DbSetOrder(1))
				IF TN0->(DbSeek(xFilial("TN0")+aCOLSTJ0[nA,1]))

					IF TN0->TN0_ADIFOL <> "S"
						RecLock("TN0",.F.)
						TN0->TN0_ADIFOL := "S"
						TN0->(MsUnlock())
					Endif

				Endif

				cBODY := cBODY+'<tr>'
				cBODY := cBODY+'  <td>'+aCOLSTJ0[nA,1]+'</td>'
				cBODY := cBODY+'  <td>'+aCOLSTJ0[nA,2]+'</td>'
				cBODY := cBODY+'  <td>'+aCOLSTJ0[nA,3]+'</td>'
				cBODY := cBODY+'  <td>'+aCOLSTJ0[nA,4]+'</td>'
				cBODY := cBODY+'  <td>'+aCOLSTJ0[nA,5]+'</td>'
				cBODY := cBODY+'  <td>'+aCOLSTJ0[nA,6]+'</td>'
				cBODY := cBODY+'  <td>'+TRANSFORM(aCOLSTJ0[nA,7],'@E 99.99')+'%'+'</td>'
				cBODY := cBODY+'  <td>'+DTOC(aCOLSTJ0[nA,8])+'</td>'
				cBODY := cBODY+'  <td>'+DTOC(aCOLSTJ0[nA,9])+'</td>'
				cBODY := cBODY+'</tr>'
				lOK   := .T.
			ENDIF
		NEXT
		IF lOK
			cBODY := cBODY+'  </tbody>'
			cBODY := cBODY+'</table>'
			cBODY := cBODY+'</body>'
			cBODY := cBODY+'</html>'
			//ENVIO DE EMAIL
			cTO := ALLTRIM(cP_EMAIL)
			cCC := cCCO := ""
			SEND MAIL FROM cFROM TO cTO CC cCC BCC cCCO SUBJECT STR0062 BODY cBODY RESULT lOK //"Atualizacao de Insalubridade / Periculosidade"

			IF ! lOK
				MSGINFO(STR0063,STR0032)  //"Não foi possível enviar o email. Falha no envio !" ## "Atenção"
			ELSE
				lTN0EMAIL := .T.
			ENDIF

			DISCONNECT SMTP SERVER

		ENDIF
	END SEQUENCE

RETURN(NIL)

//---------------------------------------------------------------------
/*/{Protheus.doc} fTRBPes
Funcao de Pesquisar no Browse.

@samples fTRBPes()

@return Sempre verdadeiro

@param cAliasTRB1	- Alias do MarkBrowse ( Obrigatório )
@param oMark 		- Objeto do MarkBrowse ( Obrigatório )

@author Guilherme Freudenburg
@since 05/03/2014
/*/
//---------------------------------------------------------------------
Static Function fTRBPes(cAliasTRB , oMark , cPesquisar )

	Local nRecNoAtu := 1//Variavel para salvar o recno
	Local lRet		:= .T.

	//Posiciona no TRB e salva o recno
	dbSelectArea( cAliasTRB )
	nRecNoAtu := RecNo()

	dbSelectArea( cAliasTRB )
	If dbSeek( AllTrim( cPesquisar ) )
		//Caso exista a pesquisa, posiciona
		oMark:oBrowse:SetFocus()
	Else
		//Caso nao exista, retorna ao primeiro recno e exibe mensagem
		dbGoTo( nRecNoAtu )
		ApMsgInfo( STR0070 , STR0069 ) //"Valor não encontrado."###"Atenção"
		oPesquisar:SetFocus()
		lRet := .F.
	EndIf

	// Atualiza markbrowse
	oMark:oBrowse:Refresh(.T.)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fIndexSet
Seta o indice para pesquisa.

@return

@param cAliasTRB	- Alias do TRB ( Obrigatório )
@param aCbxPesq	- Indices de pesquisa do markbrowse. ( Obrigatório )
@param cPesquisar	- Valor da Pesquisa ( Obrigatório )
@param oMark		- Objeto do MarkBrowse ( Obrigatório )

@author Guilherme Freudenburg
@since 05/03/2014
/*/
//---------------------------------------------------------------------
Static Function fIndexSet( cAliasTRB , aCbxPesq , cPesquisar , oMark )

	Local nIndice := fIndComb( aCbxPesq ) // Retorna numero do indice selecionado

	// Efetua ordenacao do alias do markbrowse, conforme indice selecionado
	dbSelectArea( cAliasTRB )
	dbSetOrder( nIndice )
	dbGoTop()

	// Se o indice selecionado for o ultimo [Marcados]
	If nIndice == Len( aCbxPesq )
		cPesquisar := Space( Len( cPesquisar ) ) // Limpa campo de pesquisa
		oPesquisar:Disable()              // Desabilita campo de pesquisa
		oBtnPesq:Disable()              // Desabilita botao de pesquisa
		oMark:oBrowse:SetFocus()     // Define foco no markbrowse
	Else
		oPesquisar:Enable()               // Habilita campo de pesquisa
		oBtnPesq:Enable()               // Habilita botao de pesquisa
		oBtnPesq:SetFocus()             // Define foco no campo de pesquisa
	Endif

	oMark:oBrowse:Refresh()

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fIndComb
Retorna o indice, em numero, do item selecionado no combobox

@return nIndice - Retorna o valor do Indice

@param aIndMrk - Indices de pesquisa do markbrowse. ( Obrigatório )

@author Guilherme Freudenburg
@since 05/03/2014
/*/
//---------------------------------------------------------------------
Static Function fIndComb( aIndMrk )

	Local nIndice := aScan( aIndMrk , { | x | AllTrim( x ) == AllTrim( cCbxPesq ) } )

	// Se o indice nao foi encontrado nos indices pre-definidos, apresenta mensagem
	If nIndice == 0
		ShowHelpDlg( STR0069 ,	{ STR0071 } , 1 , ; //"Atenção"###"Índice não encontrado."
									{ STR0072 } , 1 ) //"Contate o administrador do sistema."
		nIndice := 1
	Endif

Return nIndice

//---------------------------------------------------------------------
/*/{Protheus.doc} fEfetFunc
Realiza a gravação dos funcionários expostos no array correto

@return Sempre verdadeiro

@sample fEfetFunc()

@author Jackson Machado
@since 15/05/2015
/*/
//---------------------------------------------------------------------
Static Function fEfetFunc()

	Local nA, nB
	Local nAux	:= Len( aOLDACOLS[ 1 ] )
	Local lRet	:= .T.
	Local lOK	:= .T.

	//Realiza o Backup correto
	aCOLS := aClone( aCOLSTJ0 )

	//Realiza a carga dos novos registros
	For nA := 1 To Len( aOLDACOLS )
		lOK := .T.
		If Len( aCOLS ) > 0
			For nB := 1 To Len( aCOLS )
				//Caso registro já exista, apenas atualiza o status
				If aOLDACOLS[ nA , 1 ] == aCOLS[ nB , 1 ]
					aCOLS[ nB , Len( aCOLS[ 1 ] ) ] := aOLDACOLS[ nA , Len( aOLDACOLS[ 1 ] ) ]
					lOK := .F.
	EndIf
			Next
	EndIf
		If lOK
			MDTPesqTJ0( aOLDACOLS[ nA , 1 ] , { | dDtIni | fGrvArrCols( dDtIni , @aCols , aOLDACOLS , nA , nAux ) } )
	EndIf
	Next

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fGrvArrCols
Grava os valores no array de risco

@return Nill

@param dDataIni Date Data de Inicio da Exposição
@param aCOLS Array Valores atuais dos Funcionários
@param aOLDACOLS Array Valores antigos dos Funcionários
@param nA Numeric Indica posição do array
@param nAux Numeric Indica valor da posição final do Array

@sample fGrvArrCols( '01/01/2015' , @aCOLS , aOLDACOLS , nA , nAux )

@author Jackson Machado
@since 15/05/2015
/*/
//---------------------------------------------------------------------
Static Function fGrvArrCols( dDataIni , aCOLS , aOLDACOLS , nA , nAux )

	//Realiza a Gravação do aCols
	aAdd( aCOLS , {	aOLDACOLS[ nA , 1 ] , ;								//01.RISCO
					TMA->TMA_NOMAGE , ;									//02.NOME DO AGENTE
					SRA->RA_MAT , ;										//03.MATRICULA DO FUNCIONARIO
					SRA->RA_NOME , ;									//04.NOME DO FUNCIONARIO - SRA->RA_NOME,;//04.NOME DO FUNCIONARIO
					NGRETSX3BOX( "TMA_TIPADI" , TMA->TMA_TIPADI ) , ;	//TJ0->TJ0_TIPOAD,;  //05.TIPO DE ADICIONAL "TMA->TMA_TIPADI"
					NGRETSX3BOX( "TN0_PERINT" , TN0->TN0_PERINT ) , ;	//TN0->TN0_PERINT,;//06.PERCENTUAL DO ADICIONAL
					0 , ;												//07.PERCENTUAL EM FOLHA
					dDataIni , ;										//08.DATA DE INICIO DE EXPOSIÇÃO AO RISCO
					StoD( Space( 8 ) ) , ;								//09.DATA FIM DE EXPOSIÇÃO AO RISCO
					"2" , ;												//10.1=CONFIRMADA A EXPOSICAO OU 2=NAO CONFIRMADA A EXPOSICAO
					StoD( Space( 8 ) ) , ;								//11.DATA DA CONFIRMACAO DA EXPOSICAO
					aOLDACOLS[ nA , nAux ] } )							//12.LINHA VALIDA

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTLauS2240
Função para validar o envio do evento S-2240 ao TAF, na pós validação
do cadastro valida os dados e após a gravação envia ao TAF

@type Function

@sample MDTLauS2240( .T. )

@param lValid, Lógico, indica se fará a validação dos dados ou o envio

@author  Luis Fellipy Bett
@since   22/04/2020
/*/
//-------------------------------------------------------------------
Function MDTLauS2240( aRiscos, lEnvio )

	Local aArea		:= GetArea()
	Local aCampos	:= {}
	Local aFuncs	:= {}
	Local lRet		:= .T.
	Local nCont		:= 0

	Default aRiscos	:= { { M->TO1_NUMRIS } } //Define por padrão como sendo o Risco vinculado ao laudo que está na memória (MDTA216)
	Default lEnvio := .T. //Define por padrão como sendo envio de informações

	//Monta a tabela temporária
	aCampos := {	{ "TMPA_MATRI", "C", TAMSX3( "RA_MAT" )[ 1 ], 0 }, ;
					{ "TMPA_NOMFU", "C", TAMSX3( "RA_NOME" )[ 1 ], 0 }, ;
					{ "TMPA_DTINI", "D", 8, 0 }, ;
					{ "TMPA_DTFIM", "D", 8, 0 }, ;
					{ "TMPA_TAREF", "C", TAMSX3( "TN5_NOMTAR" )[ 1 ], 0 }, ;
					{ "TMPA_CCUST", "C", TAMSX3( "CTT_DESC01" )[ 1 ], 0 }, ;
					{ "TMPA_FUNCA", "C", TAMSX3( "RJ_DESC" )[ 1 ], 0 }, ;
					{ "TMPA_NVFIL", "C", TAMSX3( "RA_FILIAL" )[ 1 ], 0 }, ;
					{ "TMPA_DEPTO", "C", TAMSX3( "TM0_DEPTO" )[ 1 ], 0 } }

	oTempFunc := FWTemporaryTable():New( "TMPA", aCampos )
	oTempFunc:AddIndex( "1", { "TMPA_NOMFU" } )
	oTempFunc:Create()

	//Posiciona na tabela de Riscos para buscar as informações
	dbSelectArea( "TN0" )
	dbSetOrder( 1 )

	//Percorre aCols para pegar os Riscos
	For nCont := 1 To Len( aRiscos )
		If dbSeek( xFilial( "TN0" ) + aRiscos[ nCont, 1 ] )

			RegToMemory( "TN0" )

			MDT180BFUN()

			dbSelectArea( "TMPA" )
			dbGoTop()
			While TMPA->( !Eof() )
				If aScan( aFuncs, { |x| x[1] == TMPA->TMPA_MATRI } ) == 0
					aAdd( aFuncs, { TMPA->TMPA_MATRI, , TN0->TN0_NUMRIS } )
				EndIf
				TMPA->( dbSkip() )
			End
		EndIf
	Next nCont

	oTempFunc:Delete() //Deleta a tabela temporária

	If Len( aFuncs ) > 0
		lRet := MDTIntEsoc( "S-2240", 4, , aFuncs, lEnvio ) //Envia informações ao Governo
	EndIf

	//Volta área posicionada
	RestArea( aArea )

Return lRet
