#Include "Protheus.ch"       
#INCLUDE "Shell.CH"
#Include "MDTR910.ch"

#DEFINE _nVERSAO 2 //Versao do fonte

#DEFINE _NCABQ    1 //cabecalho
#DEFINE _NGRUPO   2 //grupos    
#DEFINE _NRODAQ   3 //rodapé    

#DEFINE _NDATAQ   1
#DEFINE _NEMPRESA 2
#DEFINE _NNOMEQ   3
#DEFINE _NTEXTOQ  4
#DEFINE _NRESPONQ 5

#DEFINE _NCODGRU  1
#DEFINE _NPERG 2

#DEFINE _NDESPERG 1
#DEFINE _NCOMBOP  2
#DEFINE _NTIPOP   3
#DEFINE _NTAMP    4
#DEFINE _NQUESTAO 5
#DEFINE _NFORMULP 6

#DEFINE _NCOLUNAS 20

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTR910
Relatório de impressão das respostas dos questionários de Medicina e 
Segurança do Trabalho


@author Thiago Henrique dos Santos
@since 01/04/2013
@version P10

/*/
//---------------------------------------------------------------------

Function MDTR910()

	Local aNGBEGINPRM := NGBEGINPRM(_nVERSAO)
	Local lResposta := IF(FUNNAME()=="MDTA996",.T.,.F.)

	Private lok := .T.
	Private lSigaMdtPS := If( SuperGetMv( "MV_MDTPS",.F.,"N" ) == "S", .t. , .F. )

	Private cQuesti := If( IsInCallStack( "MDTA996" ),TJ1->TJ1_QUESTI,If( IsInCallStack( "MDTA999" ),TJ2->TJ2_QUESTI,"" ) )

	// Valida compatilibdade de dicionário
	If !MDT999COMPQ()
	Return Nil
	EndIf


	If !lResposta

		MDTR910QUE()
	
	Else

		MDTR910RES()
	
	Endif
	

	NGRETURNPRM(aNGBEGINPRM)

Return


//---------------------------------------------------------------------
/*/{Protheus.doc} MDTR910QUE
Gera o questionário em excel.


@author Thiago Henrique dos Santos
@since 01/04/2013
@version P10
@return Nil
/*/
//---------------------------------------------------------------------

Function MDTR910QUE()
	Local aQuest := AClone(GetQuest())
	Local cXml := ""
	Local cPath	     := AllTrim(GetTempPath())

	Local cTemp := ""
	Local nX := 1
	Local nY := 1
	Local nZ := 1

	Local aOpcoes := {}
	Local aColunas := {}

	// Recupera nome sequencial para arquivo .xml a ser gerado
	Local cGtNextAlias := GetNextAlias()

	Private nIndRow  := 1
	Private nIndCell := 1


	cArqPesq := cPath + "MDTR910" + "_" + cGtNextAlias + ".xml"
	nHandle  := FCREATE(cArqPesq, 0) //Cria arquivo no diretório


	cXml := MontaCab(aQuest)

	//-----------------------------------
	// PERGUNTAS
	//-----------------------------------
	
	//Secoes de grupos de perguntas

	For nX:= 1 to len(aQuest[_NGRUPO])

		DbSelectArea("TJ4")
		TJ4->(DbSetOrder(1))
		IF TJ4->(DbSeek(xFilial("TJ4")+aQuest[_NGRUPO][nX][_NCODGRU]))
	        
	   	//imprimindo titulo do grupo 
	   
			IF TJ4->TJ4_TIPREG == "1" //titulo central
	   
				
				If !Empty(TJ4->TJ4_DESCRI)
		
					cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
					cXml += 	'<Cell  ss:StyleID="sGrupo" ss:MergeAcross="'+Alltrim(Str(_NCOLUNAS-1))+;
						'"><Data ss:Type="String">'+Substr(Alltrim(TJ4->TJ4_DESCRI),1,60)+'</Data></Cell>' + CRLF
					cXml += '</Row>' + CRLF
					nIndRow ++
				Endif
			
				//Define impressao em duas colunas
			
				If len(aQuest[_NGRUPO][nX][_NPERG]) > 1 .AND. aScan(aQuest[_NGRUPO][nX][_NPERG],{|X|X[_NTIPOP] <> "4"}) < 1 .AND.;
						aScan(aQuest[_NGRUPO][nX][_NPERG],{|X| len(Alltrim(X[_NDESPERG])) > (_NCOLUNAS-2)*2 }) < 1
					
					For nY := 1 to len(aQuest[_NGRUPO][nX][_NPERG])
						                                              
						cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
						
						If  nY < len(aQuest[_NGRUPO][nX][_NPERG])
						
							nIndCell:= 1
							cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+Alltrim(Str(nIndCell))+'" ss:MergeAcross="'+Alltrim(Str(int((_NCOLUNAS-2)/2)-1))+;
								'"><Data ss:Type="String">'+Alltrim(aQuest[_NGRUPO][nX][_NPERG][nY][_NDESPERG])+'</Data></Cell>' + CRLF
							cXml +=	'<Cell  ss:StyleID="sTexto" />'
							nIndCell := int(_NCOLUNAS/2) +1
							
							cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+Alltrim(Str(nIndCell))+'" ss:MergeAcross="'+Alltrim(Str(int((_NCOLUNAS-2)/2)-1))+;
								'"><Data ss:Type="String">'+Alltrim(aQuest[_NGRUPO][nX][_NPERG][nY+1][_NDESPERG])+'</Data></Cell>' + CRLF
							cXml +=	'<Cell  ss:StyleID="sTexto" />'
							
							nY += 1
						
						Else
						
							nIndCell:= 1
							cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+Alltrim(Str(nIndCell))+'" ss:MergeAcross="'+Alltrim(Str(_NCOLUNAS-2))+;
								'"><Data ss:Type="String">'+Alltrim(aQuest[_NGRUPO][nX][_NPERG][nY][_NDESPERG])+'</Data></Cell>' + CRLF
							cXml +=	'<Cell  ss:StyleID="sTexto" />'
						
						
						Endif
						
						cXml += '</Row>' + CRLF
						nIndRow ++
					
					Next nY

				//impressao em linha
				Else
			
					For nY := 1 to len(aQuest[_NGRUPO][nX][_NPERG])
				                                                        
						//multiplas opcoes
						If aQuest[_NGRUPO][nX][_NPERG][nY][_NTIPOP] == "2"
					
						
							aOpcoes := StrTokArr (aQuest[_NGRUPO][nX][_NPERG][nY][_NCOMBOP],";")
					         
							cTemp := Alltrim(aQuest[_NGRUPO][nX][_NPERG][nY][_NDESPERG])+space(3)
							For nZ = 1 to len(aOpcoes)
					     
								If At("=", aOpcoes[nZ]) > 0
																											     
									cTemp += " []"+Alltrim(Substr(aOpcoes[nZ],At("=", aOpcoes[nZ])+1,At("*", aOpcoes[nZ])-1 - At("=", aOpcoes[nZ])))
								Endif
					     
							Next nZ
					     
					     
							nLinhas :=  MLCOUNT((cTemp),_NCOLUNAS*4-1) - 1
		
							If !Empty(cTemp)
	
								cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
								cXml += 	'<Cell  ss:StyleID="sTexto" ss:MergeAcross="'+Alltrim(Str(_NCOLUNAS-1))+;
									'" ss:MergeDown="'+Alltrim(Str(nLinhas))+'" ><Data ss:Type="String"> '+Alltrim(cTemp)+'</Data></Cell>' + CRLF
								cXml += '</Row>' + CRLF
								nIndRow += nLinhas + 1
							Endif
							
						Else
					   
							cTemp := Alltrim(aQuest[_NGRUPO][nX][_NPERG][nY][_NDESPERG])
							nLinhas :=  MLCOUNT((cTemp),_NCOLUNAS*4-1) - 1
		
							If !Empty(cTemp)
	
								cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
								cXml += 	'<Cell  ss:StyleID="sTexto" ss:MergeAcross="'+Alltrim(Str(_NCOLUNAS-1))+;
									'" ss:MergeDown="'+Alltrim(Str(nLinhas))+'" ><Data ss:Type="String"> '+Alltrim(cTemp)+'</Data></Cell>' + CRLF
								cXml += '</Row>' + CRLF
								nIndRow += nLinhas + 1
							Endif
					     
					
						Endif

					Next nY

				Endif
			
			ElseIf TJ4->TJ4_TIPREG == "2" //titulo de coluna

				If !Empty(TJ4->TJ4_DESCRI)
			
					aColunas := StrTokArr(TJ4->TJ4_DESCRI,'*')
				
					For nY := 1 to len (aColunas)
				
						If Empty(aColunas[nY])
					
							aDel(aColunas,nY)
							aSize(aColunas,len (aColunas)-1)
					
						Endif
				
				
					Next nY
		
					If Len(aColunas) > 1

						cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
					
						nIncrem := int(_NCOLUNAS/len(aColunas)) - 1
				 
						For nY := 1 to len(aColunas)
						 
							If nY == 1
								nPosIni := nY
							ElseIf nY == len(aColunas)
								nPosIni += nIncrem+1
								nIncrem += _NCOLUNAS-(nPosIni+nIncrem)
							Else
								nPosIni += nIncrem+1
							EndIf
						
							cPosIni := Alltrim(Str(nPosIni))
							cIncrem := Alltrim(Str(nIncrem))
						                         
							cXml += 	'<Cell  ss:StyleID="sGrupo" ss:Index="'+cPosIni+'" ss:MergeAcross="'+cIncrem+;
								'"><Data ss:Type="String">'+Substr(Alltrim(aColunas[nY]),1,60)+'</Data></Cell>' + CRLF
													
						Next nY
						cXml += '</Row>' + CRLF
						nIndRow ++
					
						//impressao de formulario de coluna para preenchimento, cria 5 linhas de colunas vazia
					
						For nZ := 1 to 5
					
							cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
						
							nIncrem := int(_NCOLUNAS/len(aColunas)) - 1
						
							For nY := 1 to len(aColunas)
						
								If nY == 1
									nPosIni := nY
								ElseIf nY == len(aColunas)
									nPosIni += nIncrem+1
									nIncrem += _NCOLUNAS-(nPosIni+nIncrem)
								Else
									nPosIni += nIncrem+1
								EndIf
							
								cPosIni := Alltrim(Str(nPosIni))
								cIncrem := Alltrim(Str(nIncrem))
							                   
								cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+cPosIni+'" ss:MergeAcross="'+cIncrem+;
									'"><Data ss:Type="String"></Data></Cell>' + CRLF
							
							Next nY
							cXml += '</Row>' + CRLF
							nIndRow ++
						next nZ
					
						nIndCell := 1
					
					ElseIf !Empty(aColunas[1])
				
						cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
					
						cPosIni := Alltrim(Str(1))
						cIncrem := Alltrim(Str(_NCOLUNAS-1))
					                         
						cXml += 	'<Cell  ss:StyleID="sGrupo" ss:Index="'+cPosIni+'" ss:MergeAcross="'+cIncrem+;
							'"><Data ss:Type="String">'+Substr(Alltrim(aColunas[1]),1,60)+'</Data></Cell>' + CRLF
							
							
						cXml += '</Row>' + CRLF
						nIndRow ++
					
						//impressao de formulario de coluna para preenchimento, cria 5 linhas de colunas vazia
					
						For nZ := 1 to 5
					
							cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
						 
							cPosIni := Alltrim(Str(1))
							cIncrem := Alltrim(Str(_NCOLUNAS-1))
						
							For nY := 1 to len(aColunas)
						                         
								cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+cPosIni+'" ss:MergeAcross="'+cIncrem+;
									'"><Data ss:Type="String"></Data></Cell>' + CRLF
							
							Next nY
							cXml += '</Row>' + CRLF
							nIndRow ++
						next nZ
					
						nIndCell := 1
					
					Endif
				
				Endif
		
			ElseIf TJ4->TJ4_TIPREG == "3" //total
			
				cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
				cXml += 	'<Cell  ss:StyleID="sTotal" ss:MergeAcross="'+Alltrim(Str(_NCOLUNAS-2))+;
					'" ><Data ss:Type="String">Total</Data></Cell>' + CRLF
				cXml +=	'<Cell  ss:StyleID="sTexto" />'
				cXml += '</Row>' + CRLF
				nIndRow ++
		
			ElseIf TJ4->TJ4_TIPREG == "4" //total de coluna
		
				If len(aColunas) > 1
			
					cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
				
					nIncrem := int(_NCOLUNAS/len(aColunas)) - 1
						
					For nY := 1 to len(aColunas)
						   
						If nY == 1
							nPosIni := nY
						ElseIf nY == len(aColunas)
							nPosIni += nIncrem+1
							nIncrem += _NCOLUNAS-(nPosIni+nIncrem)
						Else
							nPosIni += nIncrem+1
						EndIf
							
						cPosIni := Alltrim(Str(nPosIni))
						cIncrem := Alltrim(Str(nIncrem))
						   
						If nY == 1
							cXml += 	'<Cell  ss:StyleID="sNegrito" ss:Index="'+cPosIni+'" ss:MergeAcross="'+cIncrem+;
								'"><Data ss:Type="String">Total</Data></Cell>' + CRLF
						Else
							cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+cPosIni+'" ss:MergeAcross="'+cIncrem+;
								'"><Data ss:Type="String"></Data></Cell>' + CRLF
						Endif
							
					Next nY
					cXml += '</Row>' + CRLF
					nIndCell := 1
					nIndRow ++
						
				Endif
		
			Endif
	
		Endif

	Next

	//---------------------------------
	// RODAPÉ
	//---------------------------------
 
	cXml += MontaRod(aQuest)

	fWrite(nHandle, cXml)

	fClose(nHandle)

	ShellExecute("open", "excel", cArqPesq ,"" , SW_MAXIMIZE ) //- Microsoft Excel

Return Nil
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTR910RES
Gera o questionário respondido em excel.


@author Thiago Henrique dos Santos
@since 09/04/2013
@version P10
@return Nil
/*/
//---------------------------------------------------------------------

Function MDTR910RES()
	Local aQuest := {}

	Local cXml := ""
	Local cPath	     := AllTrim(GetTempPath())
	Local lSair := .F.
	Local lSeqRes:= NGCADICBASE( "TJ1_SEQRES", "A" , "TJ1", .F. )

	Local cTemp := ""
	Local cTempCom := ""
	Local cMergeAcr := ""
	Local nCol1a := 0
	Local nCol1b := 0
	Local nCol2a := 0
	Local nCol2b := 0
	Local nPosIni := 0
	Local nPosFim := 0
	Local nX := 1
	Local nY := 1
	Local nZ := 1
	Local cResp := ""

	Local cSeqRes:= If( lSeqRes , TJ1->TJ1_SEQRES , "" )
	Local nTotal := 0
	Local cChave := xFilial("TJ5")+TJ1->TJ1_QUESTI+DTOS(TJ1->TJ1_DTINC)+TJ1->TJ1_FUNC+TJ1->TJ1_TAR+TJ1->TJ1_CC+TJ1->TJ1_AMB+TJ1->TJ1_LOC+TJ1->TJ1_MAT+TJ1->TJ1_OSSIMU+cSeqRes

	Local aOpcoes := {}
	Local aColunas := {}
	Local aColResp := {}
                     
	Local aDados := {} // usado no cálculo de fórmulas das linhas de totais
	Local aDadosQst := {} // usado no cálculo de fórmulas de grupo tipo título de colunas

	// Recupera nome sequencial para arquivo .xml a ser gerado
	Local cGtNextAlias := GetNextAlias()
	Local cTxtAux := ""
	Local cQstAtu := ""

	Local cCodForm := ""
	Local cFormula := ""

	Local nPosRsp := 0

	Local nW := 0

	Local nResForm := 0
	Private nIndRow  := 1
	Private nIndCell := 1

	// Atribui nome ao arquivo a ser gerado.
	cArqPesq := cPath + "MDTR910" + "_" + cGtNextAlias + ".xml"
	nHandle  := FCREATE(cArqPesq, 0) //Cria arquivo no diretório

	//----------------------------------------------------------------------------------------
	// Recupera questões do tipo numérico e opção única, que podem ser utilizadas em fórmulas
	//----------------------------------------------------------------------------------------
	DbSelectArea( "TJ5" )
	DbSetOrder( 01 )
	DbSeek( cChave )
	While TJ5->( !EoF() ) .And. TJ5->( TJ5_FILIAL+TJ5_QUEST+DTOS( TJ5_DTRESP )+TJ5_FUNC+TJ5_TAR+TJ5_CC+TJ5_AMB+TJ5_LOC+TJ5_MAT+TJ5_OSSIMU+If(lSeqRes,TJ5->TJ5_SEQRES,"")) == ;
			cChave

		cTipoQst := NGSEEK( "TJ3",TJ5->TJ5_QUEST+TJ5->TJ5_PERG,01,"TJ3->TJ3_TPLIST" )

		If cTipoQst $ "14" // Opção única ou Numérico

			cCampoVlr := If( cTipoQst == "1","TJ5->TJ5_RSPSO","TJ5->TJ5_NUMERI" )
			aAdd( aDadosQst,{ TJ5->TJ5_PERG/*Questão*/,&( cCampoVlr )/*Valor*/,TJ5->TJ5_SEQGTD/*Sequencial GetDados*/ } )

			If Empty( TJ5->TJ5_SEQGTD )
				aAdd( aDados, { TJ5->TJ5_PERG,&( cCampoVlr ),"" } )
			EndIf

		EndIf

		NGDBSELSKIP( "TJ5" )
	End While


	DbSelectArea("TJ2")
	TJ2->(DbSetOrder(1))

	If TJ2->(DbSeek(xFilial("TJ2")+TJ1->TJ1_QUESTI))

		aQuest := AClone(GetQuest())
	
		cXml := MontaCab(aQuest)
	
		//-----------------------------------
		// PERGUNTAS
		//-----------------------------------
	
		//Secoes de grupos de perguntas

		For nX:= 1 to len(aQuest[_NGRUPO])

			DbSelectArea("TJ4")
			TJ4->(DbSetOrder(1))
			IF TJ4->(DbSeek(xFilial("TJ4")+aQuest[_NGRUPO][nX][_NCODGRU]))
	        
		   	//imprimindo titulo do grupo 
	   
				IF TJ4->TJ4_TIPREG == "1" //titulo central
	   
				
					If !Empty(TJ4->TJ4_DESCRI)
		
						cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
						cXml += 	'<Cell  ss:StyleID="sGrupo" ss:MergeAcross="'+Alltrim(Str(_NCOLUNAS-1))+;
							'"><Data ss:Type="String">'+Substr(Alltrim(TJ4->TJ4_DESCRI),1,60)+'</Data></Cell>' + CRLF
						cXml += '</Row>' + CRLF
						nIndRow ++
					Endif
			
					//Define impressao em duas colunas
			
					If len(aQuest[_NGRUPO][nX][_NPERG]) > 1 .AND. aScan(aQuest[_NGRUPO][nX][_NPERG],{|X|X[_NTIPOP] <> "4"}) < 1 .AND.;
							aScan(aQuest[_NGRUPO][nX][_NPERG],{|X| len(Alltrim(X[_NDESPERG])) > (_NCOLUNAS-2)*2 }) < 1
					
					      
						nTotal := 0
						
						For nY := 1 to len(aQuest[_NGRUPO][nX][_NPERG])
					
					    
						                                              
							cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
							
							If  nY < len(aQuest[_NGRUPO][nX][_NPERG])
							   
								cResp := ""
								
								DbSelectArea("TJ5")
								TJ5->(DbSetOrder(1))
								
								If TJ5->(dBSeek(cChave+aQuest[_NGRUPO][nX][_NPERG][nY][_NQUESTAO]))
								
									cResp := cValToChar(TJ5->TJ5_NUMERI)
									
									nTotal += TJ5->TJ5_NUMERI
								
								Endif
							
								nIndCell:= 1
					  
								cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+Alltrim(Str(nIndCell))+'" ss:MergeAcross="'+Alltrim(Str(int((_NCOLUNAS-2)/2)-1))+;
									'"><Data ss:Type="String">'+Alltrim(aQuest[_NGRUPO][nX][_NPERG][nY][_NDESPERG])+'</Data></Cell>' + CRLF
								cXml +=	'<Cell  ss:StyleID="sTexto"><Data ss:Type="Number">'+cResp+'</Data></Cell>' + CRLF
								nIndCell := int(_NCOLUNAS/2) +1
								
								cResp := ""
								
								DbSelectArea("TJ5")
								TJ5->(DbSetOrder(1))
								
								If TJ5->(dBSeek(cChave+aQuest[_NGRUPO][nX][_NPERG][nY+1][_NQUESTAO]))
								
									cResp := cValToChar(TJ5->TJ5_NUMERI)
									
									nTotal += TJ5->TJ5_NUMERI
								
								Endif
							
								cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+Alltrim(Str(nIndCell))+'" ss:MergeAcross="'+Alltrim(Str(int((_NCOLUNAS-2)/2)-1))+;
									'"><Data ss:Type="String">'+Alltrim(aQuest[_NGRUPO][nX][_NPERG][nY+1][_NDESPERG])+'</Data></Cell>' + CRLF
								cXml +=	'<Cell  ss:StyleID="sTexto"><Data ss:Type="Number">'+cResp+'</Data></Cell>' + CRLF
							
								nY += 1
						
							Else
							
								cResp := ""
								
								DbSelectArea("TJ5")
								TJ5->(DbSetOrder(1))
								
								If TJ5->(dBSeek(cChave+aQuest[_NGRUPO][nX][_NPERG][nY][_NQUESTAO]))
								
									cResp := cValToChar(TJ5->TJ5_NUMERI)
									
									nTotal += TJ5->TJ5_NUMERI
								
								Endif
						
								nIndCell:= 1
								cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+Alltrim(Str(nIndCell))+'" ss:MergeAcross="'+Alltrim(Str(_NCOLUNAS-2))+;
									'"><Data ss:Type="String">'+Alltrim(aQuest[_NGRUPO][nX][_NPERG][nY][_NDESPERG])+'</Data></Cell>' + CRLF
								cXml +=	'<Cell  ss:StyleID="sTexto"><Data ss:Type="Number">'+cResp+'</Data></Cell>' + CRLF
						
							Endif
						
							cXml += '</Row>' + CRLF
							nIndRow ++
					
						Next nY

					//impressao em linha
					Else
			
						For nY := 1 to len(aQuest[_NGRUPO][nX][_NPERG])
				                                                        
							// Múltiplas OpcÕes
							If aQuest[_NGRUPO][nX][_NPERG][nY][_NTIPOP] == "2"

								aOpcoes := StrTokArr (aQuest[_NGRUPO][nX][_NPERG][nY][_NCOMBOP],";")

								cDescPerg := AllTrim( aQuest[_NGRUPO][nX][_NPERG][nY][_NDESPERG] ) + Space( 3 )

								cTemp   := ""
								nLinhas := 0

								For nZ = 1 To Len( aOpcoes )
						     		
									If At("=", aOpcoes[nZ]) > 0
						     		             
										DbSelectArea("TJ5")
										TJ5->(DbSetOrder(1))
										If TJ5->(dBSeek(cChave+aQuest[_NGRUPO][nX][_NPERG][nY][_NQUESTAO]+Substr(aOpcoes[nZ],1,At("=", aOpcoes[nZ])-1)))
						     			
											cTemp += "[X]"
						     			
										Else
						     			
											cTemp += "[   ]"
						     				
										Endif

										If "*" $ aOpcoes[nZ]
											cTemp += PadR( AllTrim( SubStr( aOpcoes[nZ],At( "=",aOpcoes[nZ] ) + 1,At( "*",aOpcoes[nZ] ) - 1 - At( "=",aOpcoes[nZ] ) ) ),100 )
										Else
											cTemp += PadR( AllTrim( SubStr( aOpcoes[nZ],At( "=",aOpcoes[nZ] ) + 1,Len( aOpcoes[nZ] ) ) ),100 )
										EndIf
							     		
									EndIf

									nLinhas++

								Next nZ

								nColMOP1 := _NCOLUNAS - 12
								nColMOP2 := _NCOLUNAS - 10

						     // Imprime label da pergunta
								cXml += '<Row ss:Index="' + AllTrim( Str( nIndRow ) ) + '">' + CRLF
								cXml += 	'<Cell  ss:StyleID="sTextoVTOP" ss:MergeAcross="' + AllTrim( Str( nColMOP1 ) ) + ;
									'" ss:MergeDown="'+Alltrim(Str(nLinhas))+'" ><Data ss:Type="String"> '+Alltrim(cDescPerg)+'</Data></Cell>' + CRLF

								// Opções com conteúdo
								cXml += 	'<Cell  ss:StyleID="sTextoVTOP" ss:MergeAcross="'+Alltrim(Str(nColMOP2))+;
									'" ss:MergeDown="'+Alltrim(Str( nLinhas ))+'" ><Data ss:Type="String">'+Alltrim(cTemp)+'</Data></Cell>' + CRLF

								cXml += '</Row>' + CRLF
								nIndRow += nLinhas + 1

							// Opcao Única
							ElseIf aQuest[_NGRUPO][nX][_NPERG][nY][_NTIPOP] == "1"
						
								cResp := ""
								DbSelectArea("TJ5")
								TJ5->(DbSetOrder(1))
								If TJ5->(dBSeek(cChave+aQuest[_NGRUPO][nX][_NPERG][nY][_NQUESTAO]))
						   
									aOpcoes := StrTokArr (aQuest[_NGRUPO][nX][_NPERG][nY][_NCOMBOP],";")
						   	
									If aScan(aOpcoes,{|x| TJ5_RESPCD+"=" $ x}) > 0
						   	
										cResp := Alltrim(aOpcoes[aScan(aOpcoes,{|x| TJ5_RESPCD+"=" $ x})])
						   	
									Endif

									cResp := SubStr(cResp,At( TJ5->TJ5_RESPCD+"=",cResp)+2)
						   
								Endif
			
								cTemp := Alltrim(aQuest[_NGRUPO][nX][_NPERG][nY][_NDESPERG])//+': '+cResp
							
								cTempCom := cResp
							
								If At("*",cResp) > 0
									cTempCom := SubStr(cResp,1,At("*",cResp)-1)
								EndIf
							
								nLinhas :=  MLCOUNT((cTemp),_NCOLUNAS*4-1) - 1
		
								If !Empty(cTemp)
									
									nCol1a := _NCOLUNAS-12
									nCol1b := _NCOLUNAS-10
	
									cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
									cXml += 	'<Cell  ss:StyleID="sTexto" ss:MergeAcross="'+Alltrim(Str(nCol1a))+;
										'" ss:MergeDown="'+Alltrim(Str(nLinhas))+'" ><Data ss:Type="String"> '+Alltrim(cTemp)+'</Data></Cell>' + CRLF
									cXml += 	'<Cell  ss:StyleID="sTexto" ss:MergeAcross="'+Alltrim(Str(nCol1b))+;
										'" ss:MergeDown="'+Alltrim(Str(nLinhas))+'" ><Data ss:Type="String"> '+Alltrim(cTempCom)+'</Data></Cell>' + CRLF
									cXml += '</Row>' + CRLF
									nIndRow += nLinhas + 1
								Endif
						
						
							//Resultado de fórmula
							ElseIF aQuest[_NGRUPO][nX][_NPERG][nY][_NTIPOP] == "5"
						
								cTemp := Alltrim(aQuest[_NGRUPO][nX][_NPERG][nY][_NDESPERG])
								cTempCom := "0"
								DbSelectArea("TJ5")
								TJ5->(DbSetOrder(1))
								If TJ5->(dBSeek(cChave+aQuest[_NGRUPO][nX][_NPERG][nY][_NQUESTAO]))
						   
									cCodForm := NGSEEK( "TJ3",TJ5->TJ5_QUEST+TJ5->TJ5_PERG,01,"TJ3->TJ3_FORMUL" )
									cFormula := NGSEEK( "TG0",PadR( cCodForm,TAMSX3( "TG0_CODFOR" )[1] ),01,"TG0->TG0_FORMUL" )
									nResForm := 0
									nResForm := fCalFormula( cFormula,aDadosQst )

									nTotal += nResForm

									cTempCom := cValToChar( nResForm )
									DbSelectArea("TJ6")
									TJ6->(DbSetOrder(1))
									TJ6->(DbSeek(xFilial("TJ6")+aQuest[_NGRUPO][nX][_NPERG][nY][_NFORMULP]))
									lSair := .F.
						   	
									While TJ6->(!Eof()) .AND. TJ6->TJ6_FILIAL == xFilial("TJ6") .AND. TJ6->TJ6_CODFOR == aQuest[_NGRUPO][nX][_NPERG][nY][_NFORMULP];
											.AND. !lSair
						   					
										If TJ6->TJ6_ITDE <= nResForm .AND. nResForm <= TJ6->TJ6_ITATE
						   					
											lSair := .T.
 
											cTempCom += "("+Alltrim(TJ6->TJ6_RETOR)+")"
						   					
										EndIF

										TJ6->(DbSkip())
									Enddo
					   
								Endif
							
								nLinhas :=  MLCOUNT((cTemp),_NCOLUNAS*4-1) - 1
		
								If !Empty(cTemp)
									
									nCol1a := _NCOLUNAS-12
									nCol1b := _NCOLUNAS-10
	
									cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
									cXml += 	'<Cell  ss:StyleID="sTexto" ss:MergeAcross="'+Alltrim(Str(nCol1a))+;
										'" ss:MergeDown="'+Alltrim(Str(nLinhas))+'" ><Data ss:Type="String"> '+Alltrim(cTemp)+'</Data></Cell>' + CRLF
									cXml += 	'<Cell  ss:StyleID="sTexto" ss:MergeAcross="'+Alltrim(Str(nCol1b))+;
										'" ss:MergeDown="'+Alltrim(Str(nLinhas))+'" ><Data ss:Type="String"> '+Alltrim(cTempCom)+'</Data></Cell>' + CRLF
									cXml += '</Row>' + CRLF
									nIndRow += nLinhas + 1
								Endif
						
							//texto descritivo		
							Else
					               
								cTemp := Alltrim(aQuest[_NGRUPO][nX][_NPERG][nY][_NDESPERG])
								cTempCom := ""
							
								DbSelectArea("TJ5")
								TJ5->(DbSetOrder(1))
								If TJ5->(dBSeek(cChave+aQuest[_NGRUPO][nX][_NPERG][nY][_NQUESTAO]))
						   
									IF aQuest[_NGRUPO][nX][_NPERG][nY][_NTIPOP] == "4"
						   	
										cTempCom := CValToChar( TJ5->TJ5_NUMERI )
										nTotal += TJ5->TJ5_NUMERI
						   	
									Else
						   
						   			cTempCom := Alltrim(TJ5->TJ5_TEXTD)
						   		
									Endif
						   
								Endif
						   
								nCol1a := _NCOLUNAS-12
								nCol1b := _NCOLUNAS-10
							
								nLinhas :=  MLCOUNT((cTemp),_NCOLUNAS*4-1) - 1
		
								If !Empty(cTemp)
	
									cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
									cXml += 	'<Cell  ss:StyleID="sTexto" ss:MergeAcross="'+Alltrim(Str(nCol1a))+;
										'" ss:MergeDown="'+Alltrim(Str(nLinhas))+'" ><Data ss:Type="String"> '+Alltrim(cTemp)+'</Data></Cell>' + CRLF
									cXml += 	'<Cell  ss:StyleID="sTexto" ss:MergeAcross="'+Alltrim(Str(nCol1b))+;
										'" ss:MergeDown="'+Alltrim(Str(nLinhas))+'" ><Data ss:Type="String"> '+Alltrim(cTempCom)+'</Data></Cell>' + CRLF
									cXml += '</Row>' + CRLF
									nIndRow += nLinhas + 1
								Endif
				
							Endif

						Next nY
			
			
					Endif
			
				ElseIf TJ4->TJ4_TIPREG == "2" //titulo de coluna
		      
					If !Empty(TJ4->TJ4_DESCRI)
			   
						aColResp := {}
						aColunas := StrTokArr(TJ4->TJ4_DESCRI,'*')
				
						For nY := 1 to len (aColunas)
				
							If Empty(aColunas[nY])
					
								aDel(aColunas,nY)
								aSize(aColunas,len (aColunas)-1)
					
							Endif
				
						Next nY
				
						If Len(aColunas) > 1
			
							cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
					              
							nIncrem := int(_NCOLUNAS/len(aColunas)) - 1
					   
							For nY := 1 to len(aColunas)
						       
								If nY == 1
									nPosIni := nY
								ElseIf nY == len(aColunas)
									nPosIni += nIncrem+1
									nIncrem += _NCOLUNAS-(nPosIni+nIncrem)
								Else
									nPosIni += nIncrem+1
								EndIf
							
								cPosIni := Alltrim(Str(nPosIni))
								cIncrem := Alltrim(Str(nIncrem))
						                         
								cXml += 	'<Cell  ss:StyleID="sGrupo" ss:Index="'+cPosIni+'" ss:MergeAcross="'+cIncrem+;
									'"><Data ss:Type="String">'+Substr(Alltrim(aColunas[nY]),1,60)+'</Data></Cell>' + CRLF
							
							Next nY
							cXml += '</Row>' + CRLF
							nIndRow ++
						
							DbSelectArea("TJ5")
							TJ5->(DbSetOrder(1))
						
							For nY := 1 to len(aQuest[_NGRUPO][nX][_NPERG])
						
								If TJ5->(dBSeek(cChave+aQuest[_NGRUPO][nX][_NPERG][nY][_NQUESTAO]))

									While TJ5->(!Eof()) .AND. cChave+aQuest[_NGRUPO][nX][_NPERG][nY][_NQUESTAO] == TJ5->TJ5_FILIAL+TJ5->TJ5_QUEST+;
											DTOS( TJ5->TJ5_DTRESP )+TJ5->TJ5_FUNC+TJ5->TJ5_TAR+TJ5->TJ5_CC+TJ5->TJ5_AMB+TJ5->TJ5_LOC+TJ5->TJ5_MAT+TJ5->TJ5_OSSIMU+;
											If(lSeqRes,TJ5->TJ5_SEQRES,"")+TJ5->TJ5_PERG

										If nY == 1
										
											AADD(aColResp,Array(len(aColunas)))
											
										Endif
										
										If aQuest[_NGRUPO][nX][_NPERG][nY][_NTIPOP] == "1" //opcao exclusiva
										         
											cResp := ""
											aOpcoes := StrTokArr (aQuest[_NGRUPO][nX][_NPERG][nY][_NCOMBOP],";")
						   	
											If aScan(aOpcoes,{|x| TJ5->TJ5_RESPCD+"=" $ x}) > 0
							   	
												cResp := Alltrim(aOpcoes[aScan(aOpcoes,{|x| TJ5->TJ5_RESPCD+"=" $ x})])
												cResp := SubStr(cResp,At( TJ5->TJ5_RESPCD+"=",cResp)+2,At("*",cResp) - 3 )
							   	
											Endif
							   	
							   				
											If aScan(aColResp,{|x| x[nY] == nil }) > 0
							   				 
						   					//-------------------------------------------------------------------------------------
						   					// Os primeiros 4 caracteres serão reservados para guardar a informação de que questão
						   					// se refere a resposta em questão
						   					//-------------------------------------------------------------------------------------
												aColResp[aScan(aColResp,{|x| x[nY] == nil })][nY] := TJ5->TJ5_PERG + "*" + cResp
							   				
											Endif
										
																				
										ElseIf aQuest[_NGRUPO][nX][_NPERG][nY][_NTIPOP] == "4" // numérico
										
											If aScan(aColResp,{|x| x[nY] == nil }) > 0
						   				 
												aColResp[aScan(aColResp,{|x| x[nY] == nil })][nY]:= TJ5->TJ5_PERG + "*" + cValToChar( TJ5->TJ5_NUMERI )
						   				
											Endif

										ElseIF aQuest[_NGRUPO][nX][_NPERG][nY][_NTIPOP] == "5"

											nPosRsp := aScan( aColResp,{ |x| x[nY] == Nil } )

											cCodForm := NGSEEK( "TJ3",TJ5->TJ5_QUEST+TJ5->TJ5_PERG,01,"TJ3->TJ3_FORMUL" )
											cFormula := NGSEEK( "TG0",PadR( cCodForm,TAMSX3( "TG0_CODFOR" )[1] ),01,"TG0->TG0_FORMUL" )

											aColResp[nPosRsp][nY] := TJ5->TJ5_PERG + "*" + cValToChar( fCalFormula( cFormula,aDadosQst,TJ5->TJ5_SEQGTD ) )

											DbSelectArea("TJ6")
											TJ6->(DbSetOrder(1))
											TJ6->(DbSeek(xFilial("TJ6")+aQuest[_NGRUPO][nX][_NPERG][nY][_NFORMULP]))
											lSair := .F.

											While TJ6->(!Eof()) .AND. TJ6->TJ6_FILIAL == xFilial("TJ6") .AND. TJ6->TJ6_CODFOR == aQuest[_NGRUPO][nX][_NPERG][nY][_NFORMULP];
													.AND. !lSair

												If TJ6->TJ6_ITDE <= Val( fGetResposta( aColResp[nPosRsp][nY] ) ) .And. Val( fGetResposta( aColResp[nPosRsp][nY] ) ) <= TJ6->TJ6_ITATE

													lSair := .T.
													aColResp[nPosRsp][nY] += "(" + AllTrim( TJ6->TJ6_RETOR ) + ")"

												EndIF

												TJ6->(DbSkip())
											Enddo

										Else
										        
											If aScan(aColResp,{|x| x[nY] == nil }) > 0
						   				 
												aColResp[aScan(aColResp,{|x| x[nY] == nil })][nY]:=  TJ5->TJ5_PERG + "*" + Alltrim(TJ5->TJ5_TEXTD)
						   				
											Endif

										Endif
										
										TJ5->(dBSkip())
									Enddo
							
								Else
							
									If aScan(aColResp,{|x| x[nY] == nil }) > 0
							 	
										If aQuest[_NGRUPO][nX][_NPERG][nY][_NTIPOP] == "4" // numérico
						   				 
											aColResp[aScan(aColResp,{|x| x[nY] == nil })][nY] := 0
										
										Else
									
											aColResp[aScan(aColResp,{|x| x[nY] == nil })][nY] := ""
								  		
										EndIf
						   				
									Endif
							
								Endif
						
							Next nY

							//impressao das respostas
					
							For nZ := 1 to len(aColResp)
					
								cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
							
								nIncrem := int(_NCOLUNAS/len(aColunas)) - 1
							
								For nY := 1 to len(aColResp[nZ])
						      
									If nY == 1
										nPosIni := nY
									ElseIf nY == len(aColResp[nZ])
										nPosIni += nIncrem+1
										nIncrem += _NCOLUNAS-(nPosIni+nIncrem)
									Else
										nPosIni += nIncrem+1
									EndIf
								
									cPosIni := Alltrim(Str(nPosIni))
									cIncrem := Alltrim(Str(nIncrem))

									If fVerNum( fGetResposta( aColResp[nZ][nY] ) )
						      
										cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+cPosIni+'" ss:MergeAcross="'+cIncrem+;
											'"><Data ss:Type="Number">'+Alltrim( fGetResposta( aColResp[nZ][nY] ) )+'</Data></Cell>' + CRLF

									Else
										cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+cPosIni+'" ss:MergeAcross="'+cIncrem+;
											'"><Data ss:Type="String">'+Alltrim( fGetResposta( aColResp[nZ][nY] ) )+'</Data></Cell>' + CRLF
									Endif
									
									nIndCell += int(_NCOLUNAS/len(aColunas))
						
								Next nY
								cXml += '</Row>' + CRLF
								nIndRow ++
							next nZ
					
							nIndCell := 1
					
						ElseIf !Empty(aColunas[1])
					
							cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
					        
							cPosIni := Alltrim(Str(1))
							cIncrem := Alltrim(Str(_NCOLUNAS-1))
					                         
							cXml += 	'<Cell  ss:StyleID="sGrupo" ss:Index="'+cPosIni+'" ss:MergeAcross="'+cIncrem+;
								'"><Data ss:Type="String">'+Substr(Alltrim(aColunas[1]),1,60)+'</Data></Cell>' + CRLF
							
					
							cXml += '</Row>' + CRLF
							nIndRow ++
						
							DbSelectArea("TJ5")
							TJ5->(DbSetOrder(1))

							For nY := 1 to len(aQuest[_NGRUPO][nX][_NPERG])
						
								If TJ5->(dBSeek(cChave+aQuest[_NGRUPO][nX][_NPERG][nY][_NQUESTAO]))

									While TJ5->(!Eof()) .AND. cChave+aQuest[_NGRUPO][nX][_NPERG][nY][_NQUESTAO] == TJ5->TJ5_FILIAL+TJ5->TJ5_QUEST+;
											DTOS( TJ5->TJ5_DTRESP )+TJ5->TJ5_FUNC+TJ5->TJ5_TAR+TJ5->TJ5_CC+TJ5->TJ5_AMB+TJ5->TJ5_LOC+TJ5->TJ5_MAT+TJ5->TJ5_OSSIMU+;
											If(lSeqRes,TJ5->TJ5_SEQRES,"")+TJ5->TJ5_PERG
										
										If nY == 1
										
											AADD(aColResp,Array(len(aColunas)))

										Endif
										
										If aQuest[_NGRUPO][nX][_NPERG][nY][_NTIPOP] == "1" //opcao exclusiva
										         
											cResp := ""
											aOpcoes := StrTokArr (aQuest[_NGRUPO][nX][_NPERG][nY][_NCOMBOP],";")
						   	
											If aScan(aOpcoes,{|x| TJ5->TJ5_RESPCD+"=" $ x}) > 0
						   	
												cResp := Alltrim(aOpcoes[aScan(aOpcoes,{|x| TJ5->TJ5_RESPCD+"=" $ x})])
												cResp := SubStr(cResp,At( TJ5->TJ5_RESPCD+"=",cResp)+2,At("*",cResp) - 3 )
						   	
											Endif
						   	
						   				
											If aScan(aColResp,{|x| x[nY] == nil }) > 0
						   				 
												aColResp[aScan(aColResp,{|x| x[nY] == nil })][nY]:= TJ5->TJ5_PERG + "*" + cResp
						   				
											Endif

										ElseIf aQuest[_NGRUPO][nX][_NPERG][nY][_NTIPOP] == "4" // numérico
										
											If aScan(aColResp,{|x| x[nY] == nil }) > 0
						   				 
												aColResp[aScan(aColResp,{|x| x[nY] == nil })][nY]:= TJ5->TJ5_PERG + "*" + cValToChar( TJ5->TJ5_NUMERI )
						   				
											Endif
																
										Else
										        
											If aScan(aColResp,{|x| x[nY] == nil }) > 0
						   				 
												aColResp[aScan(aColResp,{|x| x[nY] == nil })][nY]:=  TJ5->TJ5_PERG + "*" + Alltrim(TJ5->TJ5_TEXTD)
						   				
											Endif
											
										Endif

										TJ5->(dBSkip())
									Enddo
							
								Endif
						
							Next nY
						 					
							//impressao das respostas
					
							For nZ := 1 to len(aColResp)
					
								cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
						
								cPosIni := Alltrim(Str(1))
								cIncrem := Alltrim(Str(_NCOLUNAS-1))
						      
					      // If ValType( Val( fGetResposta( aColResp[nZ][1] ) ) ) == "N"   
								If fVerNum( fGetResposta( aColResp[nZ][1] ) )
					      
									cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+cPosIni+'" ss:MergeAcross="'+cIncrem+;
										'"><Data ss:Type="Number">'+AllTrim( fGetResposta( aColResp[nZ][1] ) )+'</Data></Cell>' + CRLF
					      
								Else
									cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+cPosIni+'" ss:MergeAcross="'+cIncrem+;
										'"><Data ss:Type="String">'+AllTrim( fGetResposta( aColResp[nZ][1] ) )+'</Data></Cell>' + CRLF
								Endif
							
								cXml += '</Row>' + CRLF
								nIndRow ++
							next nZ
					
							nIndCell := 1
					
						Endif
				
					Endif
		
				ElseIf TJ4->TJ4_TIPREG == "3" //total
			
					cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
					cXml += 	'<Cell  ss:StyleID="sTotal" ss:MergeAcross="'+Alltrim(Str(_NCOLUNAS-2))+;
						'" ><Data ss:Type="String">Total</Data></Cell>' + CRLF
					cXml +=	'<Cell  ss:StyleID="sTexto"><Data ss:Type="Number">'+cValToChar(nTotal)+'</Data></Cell>' + CRLF
					cXml += '</Row>' + CRLF
					nIndRow ++
	
					nTotal := 0
		
				ElseIf TJ4->TJ4_TIPREG == "4" //total de coluna
		
					If len(aColunas) > 1
			
			
						cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF
						
						For nY := 1 to len(aColunas)
							   
							nTotal := nil
								
							For nZ := 1 to len(aColResp)
								   
								// recupero o código da questão relacionada a coluna atual (da qual estou somando os totais)
								If Empty( cQstAtu )
									cQstAtu := fGetQestao( aColResp[nZ][nY] )
								EndIf
								If nZ == 1
								   	
									If ValType( fGetResposta( aColResp[nZ][nY] ) ) == "C"
										nTotal := Val( fGetResposta( aColResp[nZ][nY] ) )
									ElseIf ValType( fGetResposta( aColResp[nZ][nY] ) ) == "N"
										nTotal := fGetResposta( aColResp[nZ][nY] )
									Else
										nTotal := 0
									EndIf

								Else
									If ValType( fGetResposta( aColResp[nZ][nY] ) ) == "C"
										nTotal += Val( fGetResposta( aColResp[nZ][nY] ) )
									EndIf

								Endif

							Next nZ

							//-------------------------------------------------------------------------------------------
							// Verifica se o total pertence a uma coluna de fórmula, neste caso, deve aplicar a fórmula 
							// com base nos valores de totais da linha de totais
							//-------------------------------------------------------------------------------------------
							cFormula  := NGSEEK( "TJ3",cQuesti + PadR( cQstAtu,TAMSX3( "TJ3_QUESTI" )[1] ),01,"TJ3->TJ3_FORMUL" ) // TJ3_FILIAL+TJ3_QUESTI+TJ3_QUESTA
							cCato     := NGSEEK( "TJ3",cQuesti + PadR( cQstAtu,TAMSX3( "TJ3_QUESTI" )[1] ),01,"TJ3->TJ3_CATOT" )  // verifica se deve calcular como formula
								
							cTipoPerg := NGSEEK( "TJ3",cQuesti + PadR( cQstAtu,TAMSX3( "TJ3_QUESTI" )[1] ),01,"TJ3->TJ3_TPLIST" )
							xImpTotal := Nil
								
							If !Empty( AllTrim( cFormula ) ) .And. AllTrim( cCato ) == "2"
								cContForm := NGSEEK( "TG0",PadR( cFormula,TAMSX3( "TG0_CODFOR" )[1] ),01,"TG0->TG0_FORMUL" )
								If !Empty( cContForm )
										// Executa a fórmula
									nTotal := fCalFormula( cContForm,aDados )
								EndIf
							EndIf
							If nTotal == nil
						      	// Só imprime o ultimo campo para mesclar a celula..
								If nY == len(aColunas)
									cIncrem := Alltrim(Str(_NCOLUNAS-nIndCell))
									cXml += 	'<Cell  ss:StyleID="sTotal" ss:Index="'+Alltrim(Str(nIndCell))+'" ss:MergeAcross="'+cIncrem+;
										'"><Data ss:Type="String"> </Data></Cell>' + CRLF
								EndIf
							ElseIf nY == len(aColunas)
								
								If ValType(nTotal) == "N"
									cTxtAux := Str(nTotal)
								Else
									cTxtAux := nTotal
								EndIf
									
								cTxtAux := If( cTipoPerg == "3"," ",cTxtAux )

								cIncrem := Alltrim(Str(_NCOLUNAS-nIndCell))
								cXml += 	'<Cell  ss:StyleID="sTotal" ss:Index="'+Alltrim(Str(nIndCell))+'" ss:MergeAcross="'+cIncrem+;
									'"><Data ss:Type="String">'+cTxtAux+'</Data></Cell>' + CRLF

							ElseIf ValType(nTotal) == "N"

								// Caso pergunta tipo texto, então, na linha de totais deve sair sem conteúdo
								xImpTotal := If( cTipoPerg == "3"," ",nTotal )
								cTipoCell := If( cTipoPerg == "3","String","Number" )

								If nY == 1

									cXml += 	'<Cell  ss:StyleID="sTotal" ss:Index="'+Alltrim(Str(nIndCell))+'" ss:MergeAcross="'+Alltrim(Str(int(_NCOLUNAS/len(aColunas)-1)))+;
										'"><Data ss:Type="String">Total    '+cValToChar(xImpTotal)+'</Data></Cell>' + CRLF

								Else
									cXml += 	'<Cell  ss:StyleID="sTotal" ss:Index="'+Alltrim(Str(nIndCell))+'" ss:MergeAcross="'+Alltrim(Str(int(_NCOLUNAS/len(aColunas)-1)))+;
										'"><Data ss:Type="' + cTipoCell + '">'+cValToChar(xImpTotal)+'</Data></Cell>' + CRLF
								Endif

								nIndCell += int(_NCOLUNAS/len(aColunas))

							Else
						      
								If nY == 1
									cXml += 	'<Cell  ss:StyleID="sTotal" ss:Index="'+Alltrim(Str(nIndCell))+'" ss:MergeAcross="'+Alltrim(Str(int(_NCOLUNAS/len(aColunas)-1)))+;
										'"><Data ss:Type="String">Total</Data></Cell>' + CRLF
								Else
									cXml += 	'<Cell  ss:StyleID="sTotal" ss:Index="'+Alltrim(Str(nIndCell))+'" ss:MergeAcross="'+Alltrim(Str(int(_NCOLUNAS/len(aColunas)-1)))+;
										'"><Data ss:Type="String"></Data></Cell>' + CRLF
								Endif
							
								nIndCell += int(_NCOLUNAS/len(aColunas))
						      
							Endif

							// Adiciona nTotal no array aDados que será utilizado no cálculo de fórmula
							aAdd( aDados,{ cQstAtu,nTotal,"" } )
							cQstAtu := ""
						Next nY
						cXml += '</Row>' + CRLF
						nIndCell := 1
						nIndRow ++
						
					Endif
		
				Endif
	
			Endif

		Next

	//---------------------------------
	// RODAPÉ
	//---------------------------------

		cXml += MontaRod(aQuest)
	
	Endif

	fWrite(nHandle, cXml)

	fClose(nHandle)

	ShellExecute("open", "excel", cArqPesq ,"" , SW_MAXIMIZE ) //- Microsoft Excel

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} GetQuest
Busca o Questionário e retorna o Array com os campos do mesmo.

@return aQuest - Array com o questionário
@author Thiago Henrique dos Santos
@since 01/04/2013
@version P10
@return Nil
/*/
//---------------------------------------------------------------------

Static Function GetQuest()
	Local aQuest := {{"","","","",""}}
  
	Local cGrupo := ""

	//adcionando cabecalho
	aQuest[_NCABQ][_NDATAQ]   := IF(TJ2->TJ2_INDDAT == "1",Alltrim(DTOC(dDataBase)),"")

	If lSigaMdtPS
		aQuest[_NCABQ][_NEMPRESA] := IF(TJ2->TJ2_INDEMP == "1",Alltrim(SA1->A1_NOME),"")
	Else
		aQuest[_NCABQ][_NEMPRESA] := IF(TJ2->TJ2_INDEMP == "1",Alltrim(SM0->M0_NOMECOM),"")
	Endif

	aQuest[_NCABQ][_NNOMEQ] 	:= IF(TJ2->TJ2_INDTIT == "1",Alltrim(TJ2->TJ2_NOMQUE),"")
	aQuest[_NCABQ][_NTEXTOQ] 	:= IF(TJ2->TJ2_INDTEX == "1",Alltrim(TJ2->TJ2_CDTEXT),"")
	aQuest[_NCABQ][_NRESPONQ] := IF(TJ2->TJ2_INDRES == "1",Alltrim(TJ2->TJ2_CODRES),"")


	//adcionando grupos e perguntas

	AADD(aQuest,{})

	DbSelectArea("TJ3")
	TJ3->(DbSetOrder(3))
	TJ3->(DbSeek(xFilial("TJ3")+TJ2->TJ2_QUESTI))

	While TJ3->(!Eof()) .AND. TJ3->TJ3_FILIAL == xFilial("TJ3") .AND. TJ3->TJ3_QUESTI == TJ2->TJ2_QUESTI

		If cGrupo <> TJ3->TJ3_CODGRU
	
			AADD(aQuest[_NGRUPO],{TJ3->TJ3_CODGRU,{}})
	
		Endif
		cGrupo := TJ3->TJ3_CODGRU
	
		AADD(aQuest[_NGRUPO][len(aQuest[_NGRUPO])][_NPERG],{TJ3->TJ3_PERGUN,TJ3->TJ3_COMBO,TJ3->TJ3_TPLIST, TJ3->TJ3_TAM,TJ3->TJ3_QUESTA,TJ3->TJ3_FORMUL})
     
		TJ3->(DbSkip())
	Enddo


	//adcionando rodapé
	AADD(aQuest,{"","","","",""})

	aQuest[_NRODAQ][_NDATAQ]   := IF(TJ2->TJ2_INDDAT == "2",Alltrim(DTOC(dDataBase)),"")

	If lSigaMdtPS
		aQuest[_NRODAQ][_NEMPRESA] := IF(TJ2->TJ2_INDEMP == "2",Alltrim(SA1->A1_NOME),"")
	Else
		aQuest[_NRODAQ][_NEMPRESA] := IF(TJ2->TJ2_INDEMP == "2",Alltrim(SM0->M0_NOMECOM),"")
	Endif
	aQuest[_NRODAQ][_NNOMEQ] 	:= IF(TJ2->TJ2_INDTIT == "2",Alltrim(TJ2->TJ2_NOMQUE),"")
	aQuest[_NRODAQ][_NTEXTOQ] 	:= IF(TJ2->TJ2_INDTEX == "2",Alltrim(TJ2->TJ2_CDTEXT),"")
	aQuest[_NRODAQ][_NRESPONQ] := IF(TJ2->TJ2_INDRES == "2",Alltrim(TJ2->TJ2_CODRES),"")

Return aQuest


//---------------------------------------------------------------------
/*/{Protheus.doc} MontaCab
Monta o cabeçalho do relatório                               

@param aQuest - Array com o questionário  
@return cXml  - Cabeçalho do relatório
@author Thiago Henrique dos Santos
@since 01/04/2013
@version P10
@return Nil
/*/
//---------------------------------------------------------------------

Static Function MontaCab(aQuest)
           
Local cTemp := ""
Local cXml  := ""

cXml := '<?xml version="1.0" encoding="ISO-8859-1" ?>' + CRLF  //Esta tag e' necessaria pois indica para o excel que este e' um arquivo xml
cXml += '<?mso-application progid="Excel.Sheet"?>' + CRLF //Esta tag informa que e' excel e utilizara' o Sheet (Folha)
cXml += '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"' + CRLF //Tag para montagem do workbook, que representa uma pasta de trabalho do excel
cXml += ' xmlns:o="urn:schemas-microsoft-com:office:office"' + CRLF 
cXml += ' xmlns:x="urn:schemas-microsoft-com:office:excel"' + CRLF 
cXml += ' xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet"' + CRLF 
cXml += ' xmlns:html="http://www.w3.org/TR/REC-html40">' + CRLF       


// -------------------------- ESTILOS --------------------------
cXml += '<Styles>' + CRLF 

// Texto tamanho 16, negrito, com bordas, centralizado do titulo principal
cXml += '    <Style ss:ID="sTitulo">'+ CRLF 
cXml += '     <Alignment ss:Horizontal="Center" ss:Vertical="Bottom"/>'+ CRLF 
cXml += '     <Borders>'+ CRLF 
cXml += '      <Border ss:Position="Bottom" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF
cXml += '      <Border ss:Position="Left" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '      <Border ss:Position="Right" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '      <Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '     </Borders>'+ CRLF 
cXml += '     <Font ss:FontName="Calibri" x:Family="Swiss" ss:Size="16" ss:Color="#000000"'+ CRLF 
cXml += '      ss:Bold="1"/>'+ CRLF 
cXml += '    </Style>'+ CRLF 


// Texto tamanho 11, negrito, com bordas, centralizado do titulo de grupo, fundo cinza claro
cXml += '    <Style ss:ID="sGrupo">'+ CRLF 
cXml += '     <Alignment ss:Horizontal="Center" ss:Vertical="Bottom"/>'+ CRLF 
cXml += '     <Borders>'+ CRLF 
cXml += '      <Border ss:Position="Bottom" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF
cXml += '      <Border ss:Position="Left" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '      <Border ss:Position="Right" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '      <Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '     </Borders>'+ CRLF 
cXml += '     <Font ss:FontName="Calibri" x:Family="Swiss" ss:Size="11" ss:Color="#000000"'+ CRLF 
cXml += '      ss:Bold="1"/>'+ CRLF 
cXml += '	  <Interior ss:Color="#D9D9D9" ss:Pattern="Solid"/>'+ CRLF 
cXml += '    </Style>'+ CRLF 


// Texto tamanho 11, negrito, com bordas, alinhado a direita 
cXml += '    <Style ss:ID="sTotal">'+ CRLF 
cXml += '     <Alignment ss:Horizontal="Right" ss:Vertical="Bottom"/>'+ CRLF 
cXml += '     <Borders>'+ CRLF 
cXml += '      <Border ss:Position="Bottom" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF
cXml += '      <Border ss:Position="Left" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '      <Border ss:Position="Right" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '      <Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '     </Borders>'+ CRLF 
cXml += '     <Font ss:FontName="Calibri" x:Family="Swiss" ss:Size="11" ss:Color="#000000"'+ CRLF 
cXml += '      ss:Bold="1"/>'+ CRLF 
cXml += '    </Style>'+ CRLF 


// Texto tamanho 11, negrito, com bordas, centralizado
cXml += '    <Style ss:ID="sNegrito">'+ CRLF 
cXml += '     <Alignment ss:Horizontal="Center" ss:Vertical="Bottom"/>'+ CRLF 
cXml += '     <Borders>'+ CRLF 
cXml += '      <Border ss:Position="Bottom" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF
cXml += '      <Border ss:Position="Left" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '      <Border ss:Position="Right" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '      <Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '     </Borders>'+ CRLF 
cXml += '     <Font ss:FontName="Calibri" x:Family="Swiss" ss:Size="11" ss:Color="#000000"'+ CRLF 
cXml += '      ss:Bold="1"/>'+ CRLF 
cXml += '    </Style>'+ CRLF


// Texto tamanho 11, normal, com bordas, ajustado a equerda
cXml += '    <Style ss:ID="sTexto">'+ CRLF 
cXml += '     <Alignment ss:Horizontal="Left" ss:Vertical="Bottom" ss:WrapText="1"/>'+ CRLF 
cXml += '     <Borders>'+ CRLF 
cXml += '      <Border ss:Position="Bottom" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF
cXml += '      <Border ss:Position="Left" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '      <Border ss:Position="Right" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '      <Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '     </Borders>'+ CRLF 
cXml += '     <Font ss:FontName="Calibri" x:Family="Swiss" ss:Size="11" ss:Color="#000000"/>'+ CRLF 
cXml += '    </Style>'+ CRLF 

// Texto tamanho 11, normal, com bordas, ajustado a equerda e com vertical 'TOP'
cXml += '    <Style ss:ID="sTextoVTOP">'+ CRLF
cXml += '     <Alignment ss:Horizontal="Left" ss:Vertical="Top" ss:WrapText="1"/>'+ CRLF 
cXml += '     <Borders>'+ CRLF 
cXml += '      <Border ss:Position="Bottom" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF
cXml += '      <Border ss:Position="Left" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '      <Border ss:Position="Right" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '      <Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '     </Borders>'+ CRLF 
cXml += '     <Font ss:FontName="Calibri" x:Family="Swiss" ss:Size="11" ss:Color="#000000"/>'+ CRLF 
cXml += '    </Style>'+ CRLF 

// Texto tamanho 11, normal, com bordas, ajustado a equerda
cXml += '    <Style ss:ID="sTextoNovo">'+ CRLF 
cXml += '     <Alignment ss:Horizontal="Left" ss:Vertical="Top" ss:WrapText="1"/>'+ CRLF 
cXml += '     <Borders>'+ CRLF 
cXml += '      <Border ss:Position="Bottom" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF
cXml += '      <Border ss:Position="Left" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '      <Border ss:Position="Right" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '      <Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="1"/>'+ CRLF 
cXml += '     </Borders>'+ CRLF 
cXml += '     <Font ss:FontName="Calibri" x:Family="Swiss" ss:Size="11" ss:Color="#000000"/>'+ CRLF 
cXml += '    </Style>'+ CRLF 
cXml += '</Styles>' + CRLF 

cXml += '<Worksheet ss:Name="MDTR190">' + CRLF //Declara a primeira pasta de trabalho como sendo 'MDTR190'
cXml += '<Table ss:DefaultRowHeight="15" ss:DefaultColumnWidth="22" x:FullColumns="1" x:FullRows="1">  ' + CRLF //Inicializa a table que sera criada na pasta 

     
/*********************************** CABECALHO **********************************************************************/

//Nome do questionário como título principal, quando possuir no cabeçalho:
If !Empty(aQuest[_NCABQ][_NNOMEQ])
                                   
	
	cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF 
	cXml += 	'<Cell  ss:StyleID="sTitulo" ss:MergeAcross="'+Alltrim(Str(_NCOLUNAS-1))+'" ss:MergeDown="1"><Data ss:Type="String">'+Alltrim(aQuest[_NCABQ][_NNOMEQ])+'</Data></Cell>' + CRLF 	 
	cXml += '</Row>' + CRLF                                    
	nIndRow += 2 
	
Endif
                          
//verifica as demais informações de cabeçalho Empresa e Data
If !Empty(aQuest[_NCABQ][_NEMPRESA]) .OR. !Empty(aQuest[_NCABQ][_NDATAQ])

	cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF  

	//impressao da empresa	
	If !Empty(aQuest[_NCABQ][_NEMPRESA])
		cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+Alltrim(Str(nIndCell))+'" ss:MergeAcross="'+Alltrim(Str(_NCOLUNAS-6))+'"><Data ss:Type="String">'+;
					Substr(Alltrim(aQuest[_NCABQ][_NEMPRESA]),1,(_NCOLUNAS-6)*4-1)+'</Data></Cell>' + CRLF 	 
					
	Else
	
		cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+Alltrim(Str(nIndCell))+'" ss:MergeAcross="'+Alltrim(Str(_NCOLUNAS-6))+'"><Data ss:Type="String"></Data></Cell>' + CRLF 	 
	
	Endif
	                      
	//impressao da data  
	nIndCell := _NCOLUNAS-4
	If !Empty(aQuest[_NCABQ][_NDATAQ]) 
		//cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+Alltrim(Str(nIndCell))+' ss:MergeAcross="'+Alltrim(Str(_NCOLUNAS-1))+'" ss:MergeDown="1"><Data ss:Type="String">'+Alltrim(aQuest[_NCABQ][_NNOMEQ])+'</Data></Cell>' + CRLF 	 	
		cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+Alltrim(Str(nIndCell))+;
						'" ss:MergeAcross="04"><Data ss:Type="String">Data: '+Alltrim(aQuest[_NCABQ][_NDATAQ])+'</Data></Cell>' + CRLF
		
	Else
		cXml += 	'<Cell  ss:StyleID="sTexto" ss:Index="'+Alltrim(Str(nIndCell))+;
						'" ss:MergeAcross="04"><Data ss:Type="String"></Data></Cell>' + CRLF 	 	
	Endif
	cXml += '</Row>' + CRLF
	nIndRow++
   nIndCell := 1
Endif

//verifica se responsável pelo questionário deve fazer parte do cabeçalho
If !Empty(aQuest[_NCABQ][_NRESPONQ])
             
   cTemp := ""    
   IF TJ2->TJ2_TPRES== "1"     
   
   	DbSelectArea("TMK")
   	TMK->(DbSetOrder(1))
   	IF TMK->(DbSeek(xFilial("TMK")+aQuest[_NCABQ][_NRESPONQ]))
   	
   		cTemp := TMK->TMK_NOMUSU
   	
   	Endif
   
   Else    
   
   	DbSelectArea("SRA")
   	SRA->(DbSetOrder(1))
   	IF SRA->(DbSeek(xFilial("SRA")+aQuest[_NCABQ][_NRESPONQ]))
   	
   		cTemp := SRA->RA_NOME
   	
   	Endif
   
   Endif
   
   If !Empty(cTemp)
	
		cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF 
		cXml += 	'<Cell  ss:StyleID="sTexto" ss:MergeAcross="'+Alltrim(Str(_NCOLUNAS-1))+;
						'"><Data ss:Type="String">RESPONSÁVEL: '+Substr(Alltrim(cTemp),1,60)+'</Data></Cell>' + CRLF 	 
		cXml += '</Row>' + CRLF                                    
		nIndRow ++   
	Endif
	
Endif  

//verifica textos adcionais no cabeçalho
If !Empty(aQuest[_NCABQ][_NTEXTOQ])  

	DbSelectArea("TMZ")
	TMZ->(DbSetOrder(1))
	If TMZ->(DbSeek(xFilial("TMZ")+aQuest[_NCABQ][_NTEXTOQ]))
	
		cTemp := TMZ->TMZ_NOMTER
		
		If !Empty(cTemp)
	
			cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF 
			cXml += 	'<Cell  ss:StyleID="sGrupo" ss:MergeAcross="'+Alltrim(Str(_NCOLUNAS-1))+;
						'"><Data ss:Type="String">'+Substr(Alltrim(cTemp),1,60)+'</Data></Cell>' + CRLF 	 
			cXml += '</Row>' + CRLF                                    
			nIndRow ++   
		Endif
		
		
		cTemp := Alltrim(TMZ->TMZ_DESCRI)             
		
		nLinhas :=  MLCOUNT((cTemp),_NCOLUNAS*4-1) - 1
		
		If !Empty(cTemp)
	
			cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF 
			cXml += 	'<Cell  ss:StyleID="sTexto" ss:MergeAcross="'+Alltrim(Str(_NCOLUNAS-1))+;
						'" ss:MergeDown="'+Alltrim(Str(nLinhas))+'" ><Data ss:Type="String"> '+Alltrim(cTemp)+'</Data></Cell>' + CRLF 	 
			cXml += '</Row>' + CRLF                                    
			nIndRow += nLinhas + 1   
		Endif
	
	Endif

Endif         

Return cXml


//---------------------------------------------------------------------
/*/{Protheus.doc} MontaRod
Monta o rodapé do relatório                               

@param aQuest - Array com o questionário  
@return cXml  - Cabeçalho do relatório
@author Thiago Henrique dos Santos
@since 01/04/2013
@version P10
@return Nil
/*/
//---------------------------------------------------------------------

Static Function MontaRod(aQuest)
           
Local cTemp := ""
Local cXml  := ""  
Local aLinhasTp := {}
Local nLinhas := 0

cTemp := ""

//Nome do questionário como título principal, quando possuir no cabeçalho:
If !Empty(aQuest[_NRODAQ][_NNOMEQ])
                                   
	cTemp += Alltrim(aQuest[_NRODAQ][_NNOMEQ])+CRLF 	 

Endif

                          
//verifica as demais informações de rodapé Empresa e Data
If !Empty(aQuest[_NRODAQ][_NEMPRESA]) .OR. !Empty(aQuest[_NRODAQ][_NDATAQ])


	//impressao da empresa	
	If !Empty(aQuest[_NRODAQ][_NEMPRESA])
		cTemp += Substr(Alltrim(aQuest[_NRODAQ][_NEMPRESA]),1,(_NCOLUNAS-6)*4-1)+Space(4)
					
	Endif
	If !Empty(aQuest[_NRODAQ][_NDATAQ]) 
		
		cTemp+= STR0001 + Alltrim(aQuest[_NRODAQ][_NDATAQ])+Space(4) // "Data: "
	
	Endif
	
Endif


//verifica se responsável pelo questionário deve fazer parte do rodapé
If !Empty(aQuest[_NRODAQ][_NRESPONQ])
             
   IF TJ2->TJ2_TPRES== "1"     
   
   	DbSelectArea("TMK")
   	TMK->(DbSetOrder(1))
   	IF TMK->(DbSeek(xFilial("TMK")+aQuest[_NRODAQ][_NRESPONQ]))
   	
   		cTemp += STR0002 + Alltrim(TMK->TMK_NOMUSU)+CRLF // Responsável: "
   	
   	Endif
   
   Else    
   
   	DbSelectArea("SRA")
   	SRA->(DbSetOrder(1))
   	IF SRA->(DbSeek(xFilial("SRA")+aQuest[_NRODAQ][_NRESPONQ]))
   	
   		cTemp += STR0002 + Alltrim(SRA->RA_NOME)+CRLF // Responsável: "
   	
   	Endif
   
   Endif
   
Endif  

//verifica textos adcionais no rodapé
If !Empty(aQuest[_NRODAQ][_NTEXTOQ])  

	DbSelectArea("TMZ")
	TMZ->(DbSetOrder(1))
	If TMZ->(DbSeek(xFilial("TMZ")+aQuest[_NRODAQ][_NTEXTOQ]))
	
		cTemp += AllTrim(TMZ->TMZ_NOMTER)+": " +CRLF
		
		cDescri := StrTran ( Alltrim(TMZ->TMZ_DESCRI), CRLF, "&#10" ) 
		
		cTemp += cDescri             
		
	Endif
      
Endif                                                              

//montagem do rodapé
If !Empty(cTemp)

	aLinhasTp := Separa(cTemp,"&#10",.T.)
	            
	nLinhas := Len(aLinhasTp)
	
	cXml += '<Row ss:Index="'+Alltrim(Str(nIndRow))+'">' + CRLF 
	cXml += 	'<Cell  ss:StyleID="sTextoNovo" ss:MergeAcross="'+Alltrim(Str(_NCOLUNAS-1))+;
				'" ss:MergeDown="'+Alltrim(Str(nLinhas))+'" ><Data ss:Type="String"> '+Alltrim(cTemp)+'</Data></Cell>' + CRLF 	 
	cXml += '</Row>' + CRLF                                    
	nIndRow += nLinhas + 1   
Endif
	
cXml += '</Table>' + CRLF
cXml += '</Worksheet>' + CRLF 
cXml += '</Workbook>' + CRLF

Return cXml

//---------------------------------------------------------------------
/*/{Protheus.doc} fCalFormula
Função para aplicar cálculo de fórmula no relatório.

@param String cFormula: indica a fórmula a ser usada para o cálculo
@param Array aDados: array multidimensional no seguinte formato:
	[x][1] String: indica código da questão usada na fórmula
	[x][2] Numerico: indica o valor referente a questão
	[x][3] String:  indica o sequencial da linha, caso questão de grupo titulo de colunas
@param cSeqGD: indica sequencial da linha, caso esteja calculando a formula, para uma 
pergunta que seja linha de get dados (grupo titulo de colunas)
@author André Felipe Joriatti
@since 27/07/2013
@return Numérico nResult: indica resultado da fórmula
@version MP11
/*/
//---------------------------------------------------------------------

Static Function fCalFormula( cFormula,aDados,cSeqGD )

	Local nResult     := 0
	Local nI          := 0
	Local cSubst      := ""
	Local cQst        := ""
	Local bError      := { |e| oError := e , Break( e ) }
	Local bErrorBlock := ErrorBlock( bError )
	Local oError

	Begin Sequence

		For nI := 1 To Len( aDados )

			If !Empty( aDados[nI][3] )
				If AllTrim( aDados[nI][3] ) != AllTrim( cSeqGD )
					Loop
				EndIf
			EndIf

			cSubst   := cValToChar( aDados[nI][2] )
			cQst     := AllTrim( aDados[nI][1] )
			cFormula := StrTran( cFormula,"#" + cQst + "#",cSubst )
		Next nI

		nResult := &( cFormula )
		//MsgStop( STR0003 + cFormula ) // "Erro de cálculo da fórmula: "
	Recover
		nResult := 0
	End Sequence

	ErrorBlock( bErrorBlock )
	
	If ValType( nResult ) <> "N"
		nResult := 0
	EndIf

Return nResult

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetResposta
Recupera a resposta retirando da string as 4 primeiras casas, que são
usadas para guardar a questão a que se refere a resposta

@param String cResposta: string no formato Codigo da resposta(questão) + valor da resposta
@author André Felipe Joriatti
@since 29/07/2013
@return String cResposta: apenas a resposta, sem o código da questão a que se refere
@version MP11
/*/
//---------------------------------------------------------------------

Static Function fGetResposta( cResposta )

	If ValType( cResposta ) == "C"
		cResposta := If( "*" $ cResposta,SubStr( cResposta,6,Len( cResposta ) - 5 ),cResposta )
	EndIf

Return cResposta

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetQestao
Recupera o código da questão a partir da resposta

@param String cResposta: string no formato Codigo da resposta(questão) + valor da resposta
@author André Felipe Joriatti
@since 29/07/2013
@return String cQst: indica código da questão da resposta.
@version MP11
/*/
//---------------------------------------------------------------------

Static Function fGetQestao( cResposta )

	Local cQst := ""

	If ValType( cResposta ) == "C"
		cQst := If( "*" $ cResposta,SubStr( cResposta,1,4 ),"" )
	EndIf

Return cQst

//---------------------------------------------------------------------
/*/{Protheus.doc} fVerNum
Verifica se a string informada no parametro contem apenas números 
(para ser considerada numérico).

@param String cVar:  indica variável que se deseja verificar
@author André Felipe Joriatti
@since 31/07/2013
@return Boolean lRet: conforme validação
@version MP11
/*/
//---------------------------------------------------------------------

Static Function fVerNum( cVar )

	Local lRet := .T.
	Local nI   := 0

	If ValType( cVar ) == "N"
		lRet := .T.
	ElseIf ValType( cVar ) != "C"
		lRet := .F.
	Else
		For nI := 1 To Len( cVar )
			// Se a posição da string não for um número
			If !( SubStr( cVar,nI,1 ) $ "0123456789" )
				lRet := .F.
				Exit
			EndIf
		Next nI
	EndIf

Return lRet
