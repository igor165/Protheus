#INCLUDE "MNTA545.ch"
#include "Protheus.ch"
#INCLUDE "FOLDER.CH"

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545
Cadastro de Complemento do Sinistro
@author Marcos Wagner Junior
@since 20/02/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545()

	//Guarda conteudo e declara variaveis padroes
	Local aNGBEGINPRM := {}

	If !FindFunction( 'MNTAmIIn' ) .Or. MNTAmIIn( 95 )

		aNGBEGINPRM := NGBEGINPRM()

		Private nSHEADER   := 0
		Private aRotina,cCadastro,aChkDel,oFolder,nDOCTO
		Private lStatus    := .T.
		Private cSit1 	   := "1", cSit2 := "2", cSit3 := "3"
		Private cAtivChg   := Alltrim(GetMV("MV_ATIVCHG"))
		Private cAtivSai   := Alltrim(GetMV("MV_ATIVSAI"))
		Private lNaoIntTMS := SuperGetMv("MV_NGMNTMS",.F.,"N") == "N"
		Private bNGGRAVA
		Private cFilTRH    := xFilial("TRH")
		Private cSitua01   := '01'
		Private cSitua02   := '02'
		Private cSitua03   := '03'
		Private cSitua04   := '04'
		Private cSitua05   := '05'
		Private cSitua06   := '06'
		Private cSitua07   := '07'
		Private cSitua08   := '08'
		Private cEventoAn  := ' '
		Private aRetornoOs := {}

		Private nTRODANOS := 0, nTROSEGUR := 0

		aRotina := MenuDef()

		//+-------------------------------------------------------------------+
		//| Define o cabecalho da tela de atualizacoes                   	  |
		//+-------------------------------------------------------------------+
		cCadastro := OemtoAnsi(STR0007) //"Cadastro de Complemento do Sinistro"
		aCHKDEL := {}

		//+-------------------------------------------------------------------+
		//| Endereca a funcao de BROWSE                                  	  |
		//+-------------------------------------------------------------------+
		DbSelectArea("TRH")
		DbSetOrder(1)
		mBrowse(6,1,22,75,"TRH",,,,,,NG545COR())

		//+-------------------------------------------------------------------+
		//| Retorna conteudo de variaveis padroes       					  |
		//+-------------------------------------------------------------------+
		NGRETURNPRM(aNGBEGINPRM)

	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545RAS
Limpa o campo de Tipo de Rastreamento
@author Marcos Wagner Junior
@since 20/02/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545RAS()

	If M->TRV_RASTRE == '2'
		M->TRV_TIPRAS := ''
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG545FOLD
Funcao para montatgem de folder
@author Marcos Wagner Junior
@since 20/02/07
@version undefined
@param cALIAS1, characters
@param nREG, numeric
@param nOPCX, numeric
@type function
/*/
//---------------------------------------------------------------------
Function NG545FOLD(cALIAS1,nREG,nOPCX)

	Local y, nx, ny
	Local nCONTROL  := 0
	Local oFONT
	Local cGet,oGet
	Local aNoFields := {}
	Local cCODMMSYP  := TRH->TRH_MMSYP
	Local cCODMMDAN2 := TRH->TRH_MMDAN2
	Local oSize      := FwDefSize():New(.T.) // Com enchoicebar
	Local nLinIniTla := oSize:aWindSize[1]
	Local nColIniTla := oSize:aWindSize[2]
	Local nLinFimTla := oSize:aWindSize[3]
	Local nColFimTla := oSize:aWindSize[4]

	Private aSize			:= MsAdvSize(,.f.,430)
	Private lOK			:= .F.
	Private nOPCAO		:= nOPCX
	Private aSVHEADER		:= { {}, {}, {}, {}, {}, {}, {}, {} }
	Private aSVCOLS		:= { {}, {}, {}, {}, {}, {}, {}, {} }
	Private aSVATELA1		:= {}, aSVAGETS1	:= {}
	Private aSVATELA2		:= {}, aSVAGETS2	:= {}
	Private aSVATELA3		:= {}, aSVAGETS3	:= {}
	Private aSVATELA4		:= {}, aSVAGETS4	:= {}
	Private aSVATELA5		:= {}, aSVAGETS5	:= {}
	Private aSVATELA6		:= {}, aSVAGETS6	:= {}
	Private aSVATELA7		:= {}, aSVAGETS7	:= {}
	Private aSVATELA8		:= {}, aSVAGETS8	:= {}
	Private aSVATELA9		:= {}, aSVAGETS9	:= {}
	Private aSVATELA10	:= {}, aSVAGETS10	:= {}
	Private INCLUI		:= ( nOPCAO == 3 )
	Private ALTERA		:= ( nOPCAO == 4 )
	Private nCONTROGD		:= 1
	Private oENC01,oDLG,oENC03
	Private cStatus
	Private cParam 		:= GetMv( "MV_NG1SERA" )
	Private cVerific
	Private cOs, lGETD 	:= .F.
	Private aTELA[0][0], aGETS[0] //,aHeader[0],Continua,nUsado:=0
	Private oMenu
	Private oGET01,oGET02,oGET03,oGET04,oGET05,oGET06,oGET07,oGET08
	Private aCamposNao	:= {}
	Private aPAGES		:= {}
	Private aTITLES		:= {}
	Private aDimens		:= {}
	Private aFolders	:= {} //Variavel utilizada para receber o conteudo do Ponto de Entrada MNTA5452
	Private aCampos		:= {} //Variavel utilizada para receber o conteudo do Ponto de Entrada MNTA5453
	Private aNgButton 	:= {}
	Private aColsInc	:= {}
	Private aObjects   := {}

	aAdd( aObjects , { 200 , 200 , .T. , .F. } )
	aInfo   := { aSize[ 1 ] , aSize[ 2 ] , aSize[ 3 ] , aSize[ 4 ] , 0 , 0 }
	aPosObj := MsObjSize( aInfo , aObjects , .T. )
	aDimens := { 13 , 0 , 89 , aPosObj[ 1 , 4 ] }

	Private aOLDCOLTRK := {}

	If nOPCX == 5
		If NGCADICBASE( "TRH_ORDEM", "A", "TRH", .F. ) .And. !Empty( TRH->TRH_ORDEM )
			dbSelectArea( "STJ" )
			dbSetOrder( 01 )
			If dbSeek( xFilial( "STJ" ) + TRH->TRH_ORDEM )
				If STJ->TJ_TERMINO == "N" .And. STJ->TJ_SITUACA <> 'C'
					MsgStop( STR0063 + TRH->TRH_ORDEM + STR0064, STR0012 )//"O sinistro está relacionado a OS: "###", que não foi finalizada!"###"Atenção"
					Return .F.
				EndIf
			EndIf
		EndIf
	EndIf

	DbSelectArea( "TRH" )
	AADD( aTITLES, Oemtoansi( STR0008 ) )  //"Sinistro"
	AADD( aPAGES, "HEADER 1" )
	nCONTROL++
	AADD( aTITLES, Oemtoansi( STR0009 ) )  //"Complemento"
	AADD( aPAGES, "HEADER 2" )
	nCONTROL++
	AADD( aTITLES, Oemtoansi( STR0015 ) )  //"Documentos"
	AADD( aPAGES, "HEADER 3" )
	nCONTROL++
	AADD( aTITLES, Oemtoansi( STR0017 ) ) //"Cargas"
	AADD( aPAGES, "HEADER 4" )
	nCONTROL++
	AADD( aTITLES, Oemtoansi( STR0018 ) ) //"Imóveis"
	AADD( aPAGES, "HEADER 5" )
	nCONTROL++
	AADD( aTITLES, Oemtoansi( STR0019 ) ) //"Testemunhas"
	AADD( aPAGES, "HEADER 6" )
	nCONTROL++
	AADD( aTITLES, Oemtoansi( STR0020 ) ) //"Veículos"
	AADD( aPAGES, "HEADER 7" )
	nCONTROL++
	AADD( aTITLES, Oemtoansi( STR0021 ) ) //"Vítimas"
	AADD( aPAGES, "HEADER 8" )
	nCONTROL++
	AADD( aTITLES, Oemtoansi( STR0016 ) ) //"Inquerito"
	AADD( aPAGES, "HEADER 9" )
	nCONTROL++
	AADD( aTITLES, Oemtoansi( STR0042 ) ) //"Animais"
	AADD( aPAGES, "HEADER 10" )
	nCONTROL++

	//Ponto de Entrada para criação de Folder
	If ExistBlock( "MNTA5452" )
		aFolders := ExecBlock( "MNTA5452", .F., .F. )
		If ValType( aFolders ) == "A" .And. !Empty( aFolders )
			AddFolder( aFolders, aTITLES, aPAGES )
			nCONTROL := Len( aTITLES )
		EndIf
	EndIf

	If nOPCX # 2 .OR. nOPCX # 5 // Visual
		lGETD := .T.
	EndIf

	If nOpcx = 4 .or. nOpcx = 5
		cEventoAn := TRH->TRH_EVENTO
		If TRH->TRH_FLGCOM = '3'
			MsgStop( STR0022 ) //"Sinistro já finalizado"
			Return .F.
		EndIf
	EndIf

	Define MSDialog oDlg Title cCadastro From nLinIniTla,nColIniTla TO nLinFimTla,nColFimTla Of oMainWnd Pixel STYLE nOR(WS_VISIBLE,WS_POPUP)
	oFOLDER := TFOLDER():New( 1, 0, aTITLES, aPAGES, oDLG,,,, .F., .F., 320, 200, )
	oFOLDER:aDIALOGS[1]:oFONT	:= oDLG:oFONT
	oFOLDER:aDIALOGS[2]:oFONT	:= oDLG:oFONT
	oFOLDER:aDIALOGS[3]:oFONT	:= oDLG:oFONT
	oFOLDER:aDIALOGS[4]:oFONT	:= oDLG:oFONT
	oFOLDER:aDIALOGS[5]:oFONT	:= oDLG:oFONT
	oFOLDER:aDIALOGS[6]:oFONT	:= oDLG:oFONT
	oFOLDER:aDIALOGS[7]:oFONT	:= oDLG:oFONT
	oFOLDER:aDIALOGS[8]:oFONT	:= oDLG:oFONT
	oFOLDER:aDIALOGS[9]:oFONT	:= oDLG:oFONT
	oFOLDER:aDIALOGS[10]:oFONT	:= oDLG:oFONT

	oFolder:bChange		:= { || ChangeGet() }
	oFOLDER:bSetOption	:= { || CheckCols() }

	//Ponto de Entrada para criação de Campos no Folder
	If ExistBlock( "MNTA5453" )
		aCampos := ExecBlock( "MNTA5453", .F., .F. )
		If ValType( aCampos ) == "A" .And. !Empty( aCampos )
			AddCampo( aCampos )
		Endif
	EndIf

	//+-------------------------------------------------------------------+
	//| GetDados 01	                                       				  |
	//+-------------------------------------------------------------------+

	aHeader := {}
	aCols := {}
	aAdd(aNoFields, 'TRI_NUMSIN')
	aAdd(aNoFields, 'TRI_CODBEM')
	aAdd(aNoFields, 'TRI_NOMBEM')
	cQuery := 	"SELECT * FROM "+RetSqlName("TRI")+" TRI WHERE TRI.TRI_FILIAL = '"+xFilial("TRI")+"' AND TRI.TRI_NUMSIN = '"+TRH->TRH_NUMSIN+"'"+;
	" AND TRI.D_E_L_E_T_ = ' '"
	FillGetDados( nOpcx, "TRI", 1, xFilial("TRI")+TRH->TRH_NUMSIN, {|| "TRI->TRI_FILIAL + TRI->TRI_NUMSIN"}, {|| .T.},aNoFields,,,cQuery)

	DbSelectArea("TRI")
	Dbgobottom()
	Dbskip()
	If Empty(aCOLS) .OR. nOPCAO == 3
		aCOLS := BLANKGETD(aHEADER)
	EndIf
	nTRICODDOC    := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRI_CODDOC"})
	nTRIDTREC     := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRI_DTREC"})
	nTRIHRREC     := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRI_HRREC"})
	aSVHEADER[1]	:= aCLONE(aHEADER)
	aSVCOLS[1]		:= aCLONE(aCOLS)
	n				:= Len(aCOLS)
	oGET01 := MSGETDADOS():New(0,0,135,315,nOPCAO,"NG545LINOK(1)","AllwaysTrue()",,lGETD,,1,,300,,,,,oFOLDER:aDIALOGS[3])
	oGET01:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
	oGET01:oBROWSE:Default()
	oGET01:oBROWSE:REFRESH()

	//+-------------------------------------------------------------------+
	//| GetDados 02	                                       				  |
	//+-------------------------------------------------------------------+

	aHeader := {}
	aCols := {}
	aAdd( aNoFields, 'TRK_NUMSIN' )
	aAdd( aNoFields, 'TRK_SEQCAR' )
	aAdd( aNoFields, 'TRK_CODBEM' )
	aAdd( aNoFields, 'TRK_DESBEM' )
	aAdd( aNoFields, 'TRK_CODCAR' )
	aAdd( aNoFields, 'TRK_VALCAR' )
	cQuery := 	"SELECT * FROM " + RetSqlName( "TRK" );
	+ " TRK WHERE TRK.TRK_FILIAL = '" + xFilial( "TRK" );
	+ "' AND TRK.TRK_NUMSIN = '" + TRH->TRH_NUMSIN + "'";
	+ " AND TRK.D_E_L_E_T_ = ' '"
	FillGetDados( nOpcx, "TRK", 1, xFilial( "TRK" ) + TRH->TRH_NUMSIN,;
	{ || "TRK->TRK_FILIAL + TRK->TRK_NUMSIN" }, { || .T. }, aNoFields,,, cQuery )

	DbSelectArea( "TRK" )
	Dbgobottom()
	Dbskip()
	If Empty( aCOLS ) .OR. nOPCAO == 3
		aCOLS := BLANKGETD(aHEADER)
	EndIf
	aSVHEADER[2]	:= aCLONE( aHEADER )
	aSVCOLS[2]		:= aCLONE( aCOLS )
	aOLDCOLTRK		:= aCLONE( aCOLS )
	n				:= Len( aCOLS )
	oGET02	:= MSGETDADOS():New(0,0,135,315,nOPCAO,"NG545LINOK(2)","AllwaysTrue()",,lGETD,,1,,300,,,,,oFOLDER:aDIALOGS[4])

	oGET02:oBrowse:Align			:= CONTROL_ALIGN_ALLCLIENT

	oGET02:oBROWSE:Default()
	oGET02:oBROWSE:REFRESH()

	//+-------------------------------------------------------------------+
	//| GetDados 03	                                       				  |
	//+-------------------------------------------------------------------+
	aHeader := {}
	aCols := {}
	aAdd(aNoFields, 'TRL_NUMSIN')
	aAdd(aNoFields, 'TRL_SEQIMO')
	cQuery := 	"SELECT * FROM "+RetSqlName("TRL")+" TRL WHERE TRL.TRL_FILIAL = '"+xFilial("TRL")+"' AND TRL.TRL_NUMSIN = '"+TRH->TRH_NUMSIN+"'"+;
	" AND TRL.D_E_L_E_T_ = ' '"
	If Inclui
		FillGetDados(nOpcx,"TRL",1,,,,aNoFields,,,cQuery,,,aHeader,aCols) //CARREGA COM TODOS SINISTROS
	Else
		cSeekKey:=xFilial("TRL")+TRH->TRH_NUMSIN
		bSeekWhile	:= {|| TRL->TRL_FILIAL+TRL->TRL_NUMSIN }
		FillGetDados(4						,; //1-nOpcx - número correspondente à operação a ser executada, exemplo: 3 - inclusão, 4 alteração e etc;
		"TRL"					,; //2-cAlias - area a ser utilizada;
		1		   				,; //3-nOrder - ordem correspondente a chave de indice para preencher o  acols;
		cSeekKey				,; //4-cSeekKey - chave utilizada no posicionamento da area para preencher o acols;
		bSeekWhile				,; //5-bSeekWhile - bloco contendo a expressão a ser comparada com cSeekKey na condição  do While.
		NIL						,; //6-uSeekFor - pode ser utilizados de duas maneiras:1- bloco-de-código, condição a ser utilizado para executar o Loop no While;2º - array bi-dimensional contendo N.. condições, em que o 1º elemento é o bloco condicional, o 2º é bloco a ser executado se verdadeiro e o 3º é bloco a ser executado se falso, exemplo {{bCondicao1, bTrue1, bFalse1}, {bCondicao2, bTrue2, bFalse2}.. bCondicaoN, bTrueN, bFalseN};
		aNoFields				,; //7-aNoFields - array contendo os campos que não estarão no aHeader;
		NIL				  		,; //8-aYesFields - array contendo somente os campos que estarão no aHeader;
		NIL				  		,; //9-lOnlyYes - se verdadeiro, exibe apenas os campos de usuário;
		NIL				  		,; //10-cQuery - query a ser executada para preencher o acols(Obs. Nao pode haver MEMO);
		NIL				 		,; //11-bMontCols - bloco contendo função especifica para preencher o aCols; Exmplo:{|| MontaAcols(cAlias)}
		NIL				 		,; //12-lEmpty  Caso True ( default é false ), inicializa o aCols com somente uma linha em branco ( como exemplo na inclusão).
		aHeader			 		,; //13-aHeaderAux, eh Caso necessite tratar o aheader e acols como variáveis locais ( várias getdados por exemplo; uso da MSNewgetdados )
		aCols			 		)  //14-aColsAux eh Caso necessite tratar o aheader e acols como variáveis locais ( várias getdados por exemplo; uso da MSNewgetdados )
	EndIf

	If Empty(aCOLS) .OR. nOPCAO == 3
		aCOLS := BLANKGETD(aHEADER)
	EndIf
	nTRLTIPIMO := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRL_TIPIMO"})
	nTRLDANOS  := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRL_DANOS"})
	nTRLVALPRE := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRL_VALPRE"})
	nTRLDESIMO := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRL_DESIMO"})
	nTRLENDPRO := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRL_ENDPRO"})
	nTRLCODPRO := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRL_CODPRO"})
	nTRLUF     := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRL_UF"})


	aSVHEADER[3] := aCLONE(aHEADER)
	aSVCOLS[3]	 := aCLONE(aCOLS)
	n            := Len(aCOLS)
	oGET03 := MSGETDADOS():New(0,0,135,315,nOPCAO,"NG545LINOK(3)","AllwaysTrue()",,lGETD,,1,,300,,,,,oFOLDER:aDIALOGS[5])
	oGET03:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
	oGET03:oBROWSE:Default()
	oGET03:oBROWSE:REFRESH()

	//+-------------------------------------------------------------------+
	//| GetDados 04	                                       				  |
	//+-------------------------------------------------------------------+
	aHeader := {}
	aCols := {}
	aAdd(aNoFields, 'TRN_NUMSIN')
	cQuery := 	"SELECT * FROM "+RetSqlName("TRN")+" TRN WHERE TRN.TRN_FILIAL = '"+xFilial("TRN")+"' AND TRN.TRN_NUMSIN = '"+TRH->TRH_NUMSIN+"'"+;
	" AND TRN.D_E_L_E_T_ = ' '"
	FillGetDados( nOpcx, "TRN", 1, xFilial("TRN")+TRH->TRH_NUMSIN, {|| "TRN->TRN_FILIAL + TRN->TRN_NUMSIN"}, {|| .T.},aNoFields,,,cQuery)

	DbSelectArea("TRN")
	Dbgobottom()
	Dbskip()
	If Empty(aCOLS) .OR. nOPCAO == 3
		aCOLS := BLANKGETD(aHEADER)
	EndIf
	nTRNNOMTES := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRN_NOMTES"})
	nTRNDOCTO  := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRN_DOCTO"})
	nTRNTIPDOC := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRN_TIPDOC"})
	nTRNQLFTES := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRN_QLFTES"})

	aSVHEADER[4] := aCLONE(aHEADER)
	aSVCOLS[4]	 := aCLONE(aCOLS)
	n            := Len(aCOLS)
	oGET04 := MSGETDADOS():New(0,0,135,315,nOPCAO,"NG545LINOK(4)","AllwaysTrue()",,lGETD,,1,,300,,,,,oFOLDER:aDIALOGS[6])
	oGET04:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
	oGET04:oBROWSE:Default()
	oGET04:oBROWSE:REFRESH()

	//+-------------------------------------------------------------------+
	//| GetDados 05	                                       				  |
	//+-------------------------------------------------------------------+

	aHeader := {}
	aCols := {}
	aAdd(aNoFields, 'TRO_NUMSIN')
	cQuery := 	"SELECT * FROM "+RetSqlName("TRO")+" TRO WHERE TRO.TRO_FILIAL = '"+xFilial("TRO")+"' AND TRO.TRO_NUMSIN = '"+TRH->TRH_NUMSIN+"'"+;
	" AND TRO.D_E_L_E_T_ = ' '"
	If Inclui
		FillGetDados(nOpcx,"TRO",1,,,,aNoFields,,,cQuery,,,aHeader,aCols) //CARREGA COM TODOS SINISTROS
	Else
		cSeekKey:=xFilial("TRO")+TRH->TRH_NUMSIN
		bSeekWhile	:= {|| TRO->TRO_FILIAL+TRO->TRO_NUMSIN }
		FillGetDados(4						,; //1-nOpcx - número correspondente à operação a ser executada, exemplo: 3 - inclusão, 4 alteração e etc;
		"TRO"					,; //2-cAlias - area a ser utilizada;
		1		   				,; //3-nOrder - ordem correspondente a chave de indice para preencher o  acols;
		cSeekKey				,; //4-cSeekKey - chave utilizada no posicionamento da area para preencher o acols;
		bSeekWhile				,; //5-bSeekWhile - bloco contendo a expressão a ser comparada com cSeekKey na condição  do While.
		NIL						,; //6-uSeekFor - pode ser utilizados de duas maneiras:1- bloco-de-código, condição a ser utilizado para executar o Loop no While;2º - array bi-dimensional contendo N.. condições, em que o 1º elemento é o bloco condicional, o 2º é bloco a ser executado se verdadeiro e o 3º é bloco a ser executado se falso, exemplo {{bCondicao1, bTrue1, bFalse1}, {bCondicao2, bTrue2, bFalse2}.. bCondicaoN, bTrueN, bFalseN};
		aNoFields				,; //7-aNoFields - array contendo os campos que não estarão no aHeader;
		NIL				  		,; //8-aYesFields - array contendo somente os campos que estarão no aHeader;
		NIL				  		,; //9-lOnlyYes - se verdadeiro, exibe apenas os campos de usuário;
		NIL				  		,; //10-cQuery - query a ser executada para preencher o acols(Obs. Nao pode haver MEMO);
		NIL				 		,; //11-bMontCols - bloco contendo função especifica para preencher o aCols; Exmplo:{|| MontaAcols(cAlias)}
		NIL				 		,; //12-lEmpty  Caso True ( default é false ), inicializa o aCols com somente uma linha em branco ( como exemplo na inclusão).
		aHeader			 		,; //13-aHeaderAux, eh Caso necessite tratar o aheader e acols como variáveis locais ( várias getdados por exemplo; uso da MSNewgetdados )
		aCols			 		)  //14-aColsAux eh Caso necessite tratar o aheader e acols como variáveis locais ( várias getdados por exemplo; uso da MSNewgetdados )
	EndIf

	If Empty(aCOLS) .OR. nOPCAO == 3
		aCOLS := BLANKGETD(aHEADER)
	EndIf
	nTROPLACA  := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRO_PLACA"})
	nTROTIPVEI := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRO_TIPVEI"})
	nTROVALPAG := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRO_VALTER"})
	nTROVALPRE := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRO_VALPRE"})
	nTROPERCEN := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRO_PERCEN"})
	nTRODESVEI := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRO_DESVEI"})
	nTRONOMPR  := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRO_NOMPR"})

	nTRODANOS := aScan(aHEADER,{|x| Trim(Upper(x[2])) == "TRO_DANOS"})
	nTROSEGUR := aScan(aHEADER,{|x| Trim(Upper(x[2])) == "TRO_SEGUR"})

	aSVHEADER[5] := aCLONE(aHEADER)
	aSVCOLS[5]	 := aCLONE(aCOLS)
	n            := Len(aCOLS)
	oGET05 := MSGETDADOS():New(0,0,135,315,nOPCAO,"NG545LINOK(5)","AllwaysTrue()",,lGETD,,1,,300,,,,,oFOLDER:aDIALOGS[7])
	oGET05:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
	oGET05:oBROWSE:Default()
	oGET05:oBROWSE:REFRESH()

	//+-------------------------------------------------------------------+
	//| GetDados 06	                                       				  |
	//+-------------------------------------------------------------------+
	aHeader := {}
	aCols := {}
	aAdd(aNoFields, 'TRM_NUMSIN')
	aAdd(aNoFields, 'TRM_SEQVIT')
	cQuery := 	"SELECT * FROM "+RetSqlName("TRM")+" TRM WHERE TRM.TRM_FILIAL = '"+xFilial("TRM")+"' AND TRM.TRM_NUMSIN = '"+TRH->TRH_NUMSIN+"'"+;
	" AND TRM.D_E_L_E_T_ = ' '"
	FillGetDados( nOpcx, "TRM", 1, xFilial("TRM")+TRH->TRH_NUMSIN, {|| "TRM->TRM_FILIAL + TRM->TRM_NUMSIN"}, {|| .T.},aNoFields,,,cQuery)

	DbSelectArea("TRM")
	Dbgobottom()
	Dbskip()
	If Empty(aCOLS) .OR. nOPCAO == 3
		aCOLS := BLANKGETD(aHEADER)
	EndIf

	nTRMNOMVIT := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRM_NOMVIT"})
	nTRMINDFUN := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRM_INDFUN"})
	nTRMMATVIT := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRM_MATVIT"})
	nTRMFATAL  := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRM_FATAL"})
	nTRMCODVIT := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRM_CODVIT"})
	nTRMVALVIT := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRM_VALVIT"})
	nTRMLESOES := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRM_LESOES"})
	nTRMDESFUN := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRM_DESFUN"})

	aSVHEADER[6] := aCLONE(aHEADER)
	aSVCOLS[6]	 := aCLONE(aCOLS)
	n            := Len(aCOLS)
	oGET06 := MSGETDADOS():New(0,0,135,315,nOPCAO,"NG545LINOK(6)","AllwaysTrue()",,lGETD,,1,,300,,,,,oFOLDER:aDIALOGS[8])
	oGET06:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
	oGET06:oBROWSE:Default()
	oGET06:oBROWSE:REFRESH()

	//+-------------------------------------------------------------------+
	//| GetDados 07	                                       				  |
	//+-------------------------------------------------------------------+

	aHeader := {}
	aCols := {}
	aAdd(aNoFields, 'TRJ_NUMSIN')
	cQuery := 	"SELECT * FROM "+RetSqlName("TRJ")+" TRJ WHERE TRJ.TRJ_FILIAL = '"+xFilial("TRJ")+"' AND TRJ.TRJ_NUMSIN = '"+TRH->TRH_NUMSIN+"'"+;
	" AND TRJ.D_E_L_E_T_ = ' '"
	If Inclui
		FillGetDados(nOpcx,"TRJ",1,,,,aNoFields,,,cQuery,,,aHeader,aCols) //CARREGA COM TODOS SINISTROS
	Else
		cSeekKey:=xFilial("TRJ")+TRH->TRH_NUMSIN
		bSeekWhile	:= {|| TRJ->TRJ_FILIAL+TRJ->TRJ_NUMSIN }
		FillGetDados(4			,; //1-nOpcx - número correspondente à operação a ser executada, exemplo: 3 - inclusão, 4 alteração e etc;
		"TRJ"					,; //2-cAlias - area a ser utilizada;
		1		   				,; //3-nOrder - ordem correspondente a chave de indice para preencher o  acols;
		cSeekKey				,; //4-cSeekKey - chave utilizada no posicionamento da area para preencher o acols;
		bSeekWhile				,; //5-bSeekWhile - bloco contendo a expressão a ser comparada com cSeekKey na condição  do While.
		NIL						,; //6-uSeekFor - pode ser utilizados de duas maneiras:1- bloco-de-código, condição a ser utilizado para executar o Loop no While;2º - array bi-dimensional contendo N.. condições, em que o 1º elemento é o bloco condicional, o 2º é bloco a ser executado se verdadeiro e o 3º é bloco a ser executado se falso, exemplo {{bCondicao1, bTrue1, bFalse1}, {bCondicao2, bTrue2, bFalse2}.. bCondicaoN, bTrueN, bFalseN};
		aNoFields				,; //7-aNoFields - array contendo os campos que não estarão no aHeader;
		NIL				  		,; //8-aYesFields - array contendo somente os campos que estarão no aHeader;
		NIL				  		,; //9-lOnlyYes - se verdadeiro, exibe apenas os campos de usuário;
		NIL				  		,; //10-cQuery - query a ser executada para preencher o acols(Obs. Nao pode haver MEMO);
		NIL				 		,; //11-bMontCols - bloco contendo função especifica para preencher o aCols; Exmplo:{|| MontaAcols(cAlias)}
		NIL				 		,; //12-lEmpty  Caso True ( default é false ), inicializa o aCols com somente uma linha em branco ( como exemplo na inclusão).
		aHeader			 		,; //13-aHeaderAux, eh Caso necessite tratar o aheader e acols como variáveis locais ( várias getdados por exemplo; uso da MSNewgetdados )
		aCols			 		)  //14-aColsAux eh Caso necessite tratar o aheader e acols como variáveis locais ( várias getdados por exemplo; uso da MSNewgetdados )
	EndIf

	If Empty(aCOLS) .OR. nOPCAO == 3
		aCOLS := BLANKGETD(aHEADER)
	Else
		aColsInc := aClone(aCOLS)
	EndIf
	nTRJDESCAU   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRJ_DESCAU"})
	nTRJNUMINQ   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRJ_NUMINQ"})
	nTRJENVMAN   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRJ_DTENMA"})
	nTRJRECMAN   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRJ_DTREMA"})
	nTRJTEMMAN   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRJ_TETOMA"})
	nTRJENVJUR   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRJ_DTENJU"})
	nTRJRECJUR   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRJ_DTREJU"})
	nTRJTEMJUR   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRJ_TETOJU"})
	nTRJDTFIPR   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRJ_DTFIPR"})
	nTRJTEMTOT   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRJ_TETOPR"})
	nTRJDESCUL   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRJ_DESCUL"})
	nTRJRECNO    := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TRJ_REC_WT"})

	aSVHEADER[7] := aCLONE(aHEADER)
	aSVCOLS[7]	 := aCLONE(aCOLS)
	n            := Len(aCOLS)
	oGET07 := MSGETDADOS():New(0,0,135,315,nOPCAO,"NG545LINOK(7)","AllwaysTrue()",,lGETD,,1,,300,,,,,oFOLDER:aDIALOGS[9])
	oGET07:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
	oGET07:oBROWSE:Default()
	oGET07:oBROWSE:REFRESH()


	//+-------------------------------------------------------------------+
	//| GetDados 08	                                       				  |
	//+-------------------------------------------------------------------+
	If NGCADICBASE("TU4_NOMPRO","A","TU4",.F.)
		aHeader := {}
		aCols := {}
		aAdd(aNoFields, 'TU4_NUMSIN')
		aAdd(aNoFields, 'TU4_SEQANI')
		cQuery := 	"SELECT * FROM "+RetSqlName("TU4")+" TU4 WHERE TU4.TU4_FILIAL = '"+xFilial("TU4")+"' AND TU4.TU4_NUMSIN = '"+TRH->TRH_NUMSIN+"'"+;
		" AND TU4.D_E_L_E_T_ = ' '"
		FillGetDados( nOpcx, "TU4", 1, xFilial("TU4")+TRH->TRH_NUMSIN, {|| "TU4->TU4_FILIAL + TU4->TU4_NUMSIN"}, {|| .T.},aNoFields,,,cQuery)

		DbSelectArea("TU4")
		Dbgobottom()
		Dbskip()
		If Empty(aCOLS) .OR. nOPCAO == 3
			aCOLS := BLANKGETD(aHEADER)
		EndIf
		nTU4NOMPRO   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TU4_NOMPRO"})
		nTU4ENDPRO   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TU4_ENDPRO"})
		nTU4CIDPRO   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TU4_CIDPRO"})
		nTU4UFPRO    := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TU4_UFPRO"})
		nTU4TELPRO   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TU4_TELPRO"})
		nTU4TIPANI   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TU4_TIPANI"})
		nTU4QTDANI   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TU4_QTDANI"})
		nTU4VALANI   := aSCAN(aHEADER,{|x| Trim(Upper(x[2])) == "TU4_VALANI"})
		aSVHEADER[8] := aCLONE(aHEADER)
		aSVCOLS[8]   := aCLONE(aCOLS)
		n            := Len(aCOLS)
		oGET08 := MSGETDADOS():New(0,0,135,315,nOPCAO,"NG545LINOK(8)","AllwaysTrue()",,lGETD,,1,,300,,,,,oFOLDER:aDIALOGS[10])
		oGET08:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
		oGET08:oBROWSE:Default()
		oGET08:oBROWSE:REFRESH()
	Endif

	//+-------------------------------------------------------------------+
	//| Enchoice 01                                          			  |
	//+-------------------------------------------------------------------+

	aTELA := {}
	aGETS := {}
	If !NGCADICBASE("TU4_NOMPRO","A","TU4",.F.)
		Aadd(aCamposNao,"TRH_NOMPRO")
		Aadd(aCamposNao,"TRH_ENDPRO")
		Aadd(aCamposNao,"TRH_CIDPRO")
		Aadd(aCamposNao,"TRH_UFPRO")
		Aadd(aCamposNao,"TRH_TELPRO")
		Aadd(aCamposNao,"TRH_TIPANI")
		Aadd(aCamposNao,"TRH_QTDANI")
		Aadd(aCamposNao,"TRH_VALANI")
	Else
		aCamposNao := {}
	Endif
	aChoice  := NGCAMPNSX3("TRH",aCamposNao)

	DbSelectArea("TRH")
	RegtoMemory("TRH",(nOPCAO == 3))
	If nOPCAO == 3
		M->TRH_FLGCOM := '1'
	Endif
	oENC01:= MsMGet():New("TRH",nREG,nOPCAO,,,,aChoice,aDimens,,,,,,oFOLDER:aDIALOGS[1],,,.F.,"aSVATELA1")
	oENC01:oBox:Align := CONTROL_ALIGN_ALLCLIENT
	oENC01:oBOX:bGOTFOCUS := {|| NGENTR545("TRH")}
	oFOLDER:bSETOPTION    := {|x| NGSAIEN545("TRH",x)}

	aSVATELA1 := aCLONE(aTELA)
	aSVAGETS1 := aCLONE(aGETS)

	//+-------------------------------------------------------------------+
	//| Enchoice 02                                          			  |
	//+-------------------------------------------------------------------+

	aTELA := {}
	aGETS := {}
	DbSelectArea("TRV")
	DbSetOrder(1)
	If DbSeek(xFilial("TRV")+M->TRH_NUMSIN)
		nRecTqs := Recno()
		RegToMemory("TRV",.F.)
	Else
		nRecTqs := 0
		RegToMemory("TRV",.T.)
	EndIf
	MNTA570VIA()
	oENC03:= MsMGet():New("TRV",nREG,nOPCAO,,,,,aDimens,,,,,,oFOLDER:aDIALOGS[2],,,.F.,"aSVATELA2")
	oENC03:oBox:Align := CONTROL_ALIGN_ALLCLIENT
	oENC03:oBOX:bGOTFOCUS := {|| NGENTR545("TRV")}
	oFOLDER:bSETOPTION    := {|x| NGSAIEN545("TRV",x)}

	aSVATELA2  := aCLONE(aTELA)
	aSVAGETS2  := aCLONE(aGETS)


	//+-------------------------------------------------------------------+
	//| Enchoice 03                                          			  |
	//+-------------------------------------------------------------------+
	If !NGCADICBASE("TU4_NOMPRO","A","TU4",.F.)
		Private aFields := {}
		aTELA := {}
		aGETS := {}

		//Private aSVATELA10 := {}, aSVAGETS10 := {}

		Aadd(aFields,"TRH_NOMPRO")
		Aadd(aFields,"TRH_ENDPRO")
		Aadd(aFields,"TRH_CIDPRO")
		Aadd(aFields,"TRH_UFPRO")
		Aadd(aFields,"TRH_TELPRO")
		Aadd(aFields,"TRH_TIPANI")
		Aadd(aFields,"TRH_QTDANI")
		Aadd(aFields,"TRH_VALANI")
		dbSelectArea("TRH")
		oENC04:= MsMGet():New("TRH",nREG,nOPCAO,,,,aFields,aDimens,,,,,,oFOLDER:aDIALOGS[10],,,.F.,"aSVATELA10")
		oENC04:oBox:Align := CONTROL_ALIGN_ALLCLIENT
		aSVATELA10  := aCLONE(aTELA)
		aSVAGETS10  := aCLONE(aGETS)
	Endif

	cStatus := M->TRH_STATUS

	@ 1000,1000 MsGet oGET Var cGET Picture "@!" Size 1,01 Of oFOLDER:aDIALOGS[8]

	If Len(asMenu) > 0
		NgPopUp(asMenu,@oMenu)
		oDlg:bRClicked:= { |o,x,y| oMenu:Activate(x,y,oDlg)}
		oEnc01:oBox:bRClicked := { |o,x,y| oMenu:Activate(x,y,oDlg)}
		oEnc03:oBox:bRClicked := { |o,x,y| oMenu:Activate(x,y,oDlg)}
	EndIf

	If ExistBlock("MNTA5455")
		aNgButton := ExecBlock("MNTA5455",.F.,.F.,{aNgButton})
	EndIf

	Activate MsDialog oDLG On Init (ENCHOICEBAR(oDLG,{|| lOK:=.T.,If(MNTA545CHK(),oDLG:End(),lOK := .F.)},{|| nOK:= 0,MNTA545CAN()},,aNgButton);
	,,AlignObject(oDlg,{oFolder},1))

	If lOK .AND. nOpcx != 2
		MNTA545INA()
		If M->TRH_EVENTO == '1' .AND. M->TRH_FLGDAN == '1' .AND. !Empty(cParam)
			dbSelectArea("TRT")
			dbSetOrder(02)
			If !dbSeek(xFilial("TRT")+M->TRH_NUMSIN)
				cVerific := If(NGVERIFY("STJ"),"0",0)
				aRetornoOs := NGGERAOS('C',M->TRH_DTDIG,M->TRH_CODBEM,cParam,cVerific,'N','N','N')
				If aRetornoOs[1][1] == 'N'
					MsgStop(aRetornoOs[1][2],STR0012)//"Atenção"
				Else
					If NGCADICBASE("TRH_ORDEM","D","TRH",.F.)
						M->TRH_ORDEM := aRetornoOs[1][3]
					Endif
					DbSelectArea("STJ")
					DbSetOrder(01)
					If DbSeek(xFilial("STJ")+aRetornoOs[1][3]+'000000')
						RecLock("STJ",.f.)
						MsMM(,80,,M->TRH_DANOS2,1,,,"STJ","TJ_MMSYP")
						MsUnLock("STJ")
					Endif
					DbSelectArea("TRT")
					DbSetOrder(01)
					If !DbSeek(xFilial("TRT")+aRetornoOs[1][3]+'000000')
						RecLock("TRT",.t.)
						TRT->TRT_FILIAL := xFilial("TRT")
						TRT->TRT_NUMOS  := aRetornoOs[1][3]
						TRT->TRT_PLANO  := '000000'
						TRT->TRT_NUMSIN := M->TRH_NUMSIN
						TRT->TRT_PARECE := M->TRH_DANOS2
						MsUnLock("TRT")
					Endif
				Endif
			Endif
		Endif

		M->TRH_FLGCOM := "2"

		DbSelectArea("TRH")
		If Altera .Or. nOpcx == 5
			RecLock("TRH",.F.)
		ElseIf Inclui
			dbSelectArea("TRH")
			dbSetOrder(1)
			If dbSeek(M->TRH_FILIAL+M->TRH_NUMSIN)
				M->TRH_NUMSIN := GetSXENUM("TRH","TRH_NUMSIN",M->TRH_FILIAL+x2path("TRH"))
			EndIf
			ConfirmSX8()
			RecLock("TRH",.T.)
			MNTW055()

			cFilAnt := M->TRH_FILIAL

		Endif

		If ExistBlock("MNTA5456")
			M->TRH_FILIAL := ExecBlock("MNTA5456",.F.,.F.)
			cFilTRH       := M->TRH_FILIAL
		EndIf

		lTUA := NGCADICBASE("TU4_NOMPRO","A","TU4",.F.)
		DbSelectArea("TRH")
		If nOpcx == 5
			DbDelete()
		Else
			For ny := 1 To FCOUNT()
				If (!lTUA) .OR. (;
				FieldName(ny)!="TRH_NOMPRO" .AND. FieldName(ny)!="TRH_ENDPRO" .AND. ;
				FieldName(ny)!="TRH_CIDPRO" .AND. FieldName(ny)!="TRH_UFPRO" .AND. ;
				FieldName(ny)!="TRH_TELPRO" .AND. FieldName(ny)!="TRH_TIPANI" .AND. ;
				FieldName(ny)!="TRH_QTDANI" .AND. FieldName(ny)!="TRH_VALANI")

					nx := "m->" + FieldName(ny)
					If "_FILIAL"$Upper(nx)
						&nx. := cFilTRH
					Endif
					FieldPut(ny, &nx.)
				Endif
			Next ny
		Endif

		nSMM := If(nOpcx == 3 .Or. nOpcx == 4,1,2)
		If(nOpcx = 3,MSMM(,,,M->TRH_DESCRI,nSMM,,,"TRH","TRH_MMSYP"),;
		MSMM(cCODMMSYP,,,M->TRH_DESCRI,nSMM,,,"TRH","TRH_MMSYP"))
		If(nOpcx = 3,MSMM(,,,M->TRH_DANOS2,nSMM,,,"TRH","TRH_MMDAN2"),;
		MSMM(cCODMMDAN2,,,M->TRH_DANOS2,nSMM,,,"TRH","TRH_MMDAN2"))
		EvalTrigger()  // Processa Gatilhos

		MsUnlock("TRH")

		AGR545TRV(nOpcx)
		AGR545TRI(nOpcx)
		AGR545TRK(nOpcx)
		AGR545TRL(nOpcx)
		AGR545TRN(nOpcx)
		AGR545TRO(nOpcx)
		AGR545TRM(nOpcx)
		AGR545TRJ(nOpcx)
		AGR545TRR(nOpcx)
		AGR545TRS(nOpcx)
		If NGCADICBASE("TU4_NOMPRO","A","TU4",.F.)
			AGR545TU4(nOpcx)
		Endif

		//------------------------------------------------------
		// Removido Workflow MNTW080 com o Relatorio de Sinistro
		// para os superiores do motorista
		// Remover este bloco de comentário em releases futuras
		//------------------------------------------------------

		If !Empty(NGSEEK("TRJ",M->TRH_NUMSIN,1,'TRV_NUMSIN'))
			cStatus := '04'
		ElseIf !Empty(NGSEEK("TRV",M->TRH_NUMSIN,1,'TRV_DESEVI'))
			cStatus := '02'
		Endif
		dbSelectArea("TRH")
		dbSetOrder(01)
		If dbSeek(xFilial("TRH")+M->TRH_NUMSIN)
			RecLock("TRH",.f.)
			//		TRH->TRH_STATUS := cStatus
			MsUnLock("TRH")
		Endif

		If cStatus != M->TRH_STATUS .OR. Inclui
			DbSelectArea("TRP")
			dbSetOrder(01)
			If !dbSeek(xFilial("TRP")+M->TRH_NUMSIN+DTOS(dDATABASE)+TIME())
				RecLock("TRP",.t.)
				TRP->TRP_FILIAL := xFilial("TRP")
				TRP->TRP_NUMSIN := M->TRH_NUMSIN
				TRP->TRP_DTOCOR := dDATABASE
				TRP->TRP_HROCOR := TIME()
				TRP->TRP_STATUS := M->TRH_STATUS
				TRP->TRP_CODUSU := SUBSTR(cUsuario,7,15)
			Else
				cHoraTRP := TRP->TRP_HROCOR
				While !Eof() .AND. TRP->TRP_FILIAL == xFilial("TRP") .AND. TRP->TRP_NUMSIN == M->TRH_NUMSIN .AND. TRP->TRP_DTOCOR == dDATABASE
					cHoraTRP := TRP->TRP_HROCOR
					dbSkip()
				End
				RecLock("TRP",.t.)
				TRP->TRP_FILIAL := xFilial("TRP")
				TRP->TRP_NUMSIN := M->TRH_NUMSIN
				TRP->TRP_DTOCOR := dDATABASE
				TRP->TRP_HROCOR := MTOH(HTOM(cHoraTRP)+1)
				TRP->TRP_STATUS := M->TRH_STATUS
				TRP->TRP_CODUSU := SUBSTR(cUsuario,7,15)
			Endif
			MsUnLock("TRP")
		Endif

	Else
		RollBackSX8()

	Endif
	//Ponto de entrada para customizacoes de gravacao especificas
	If(lOK .And. (nOpcx == 3 .Or. nOpcx == 4))
		If ExistBlock("MNTA5451")
			ExecBlock("MNTA5451",.F.,.F.,{cAlias1,nReg,nOpcx})
		EndIf
	EndIf
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545CHK
Consistencia do botao OK
@author Marcos Wagner Junior
@since 20/02/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545CHK()

	Local lRet := .t.
	Local aArea := GetArea()
	Local nI := 1
	Local lTU4 := NGCADICBASE("TU4_NOMPRO","A","TU4",.F.)
	Local nTotGet := If(lTU4, 8, 7)
	Local aColsAtu   := {}
	Local aHeaderAtu := {}
	Local nValOpt := 0 //Variavel para controle de Abas

	//Ponto de entrada para validações especificas de cliente.
	If ExistBlock("MNTA5454")

		If !ExecBlock("MNTA5454",.F.,.F.)
			Return .F.
		EndIf

	EndIf

	If nOpcao = 5
		Return .t.
	Endif

	If !OBRIGATORIO(aSVAGETS1,aSVATELA1)
		RestArea(aArea)
		oFolder:nOption := 1
		Return .f.
	Endif
	If !OBRIGATORIO(aSVAGETS2,aSVATELA2)
		RestArea(aArea)
		oFolder:nOption := 2
		Return .f.
	Endif

	If !MNTA545OBR() .OR. !MNTA545GUI() .OR. !MNTA545VLD()
		oFolder:nOption := 1
		Return .f.
	Endif
	If oFolder:nOption > 2  .AND. (lTU4 .or. oFolder:nOption != 10)
		nValOpt := If( oFolder:nOption > 10, oFolder:nOption - 10, 0 )
		If !NG545LINOK( oFolder:nOption - ( 2 + nValOpt ) )
			Return .f.
		EndIf
	Endif

	aColsAtu   := aClone(aCols)
	aHeaderAtu := aClone(aHeader)

	While nI <= nTotGet
		If !NG545LINOK(nI,'TUDOOK')

			Return .f.
		Endif
		nI++
	End

	aCols   := aClone(aColsAtu)
	aHeader := aClone(aHeaderAtu)

	If !MNTASINGRA()
		Return .F.
	EndIf


	If oFolder:nOption <= 2
		RestArea(aArea)
		Return .t.
	Endif

	RestArea(aArea)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545CAN
Desfaz a numeraçao sequencial no cancelamento da inclusao
@author Marcos Wagner Junior
@since 20/02/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Static Function MNTA545CAN()

	RollBackSX8()
	oDLG:End()

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545RES
Consistencia da Data de Ressarcimento
@author Marcos Wagner Junior
@since 20/02/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545RES()

	If !Empty(M->TRV_DTRESS) .AND. !Empty(M->TRH_DTACID)
		If M->TRV_DTRESS < M->TRH_DTACID
			Msgstop(STR0011,STR0012)  //"Data de Ressarcimento não poderá ser menor que Data do Acidente!"###"Atenção"
			Return .f.
		Endif
	Endif

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA570VIA
Carregas campos no folder Complemento a partir do Bem
@author Marcos Wagner Junior
@since 15/02/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA570VIA()

	Local aAreaOld := GetArea()

	Private cCidOri := ""
	Private cUfOri	:= ""
	Private cCidDes := ""
	Private cUfDes	:= ""

	//Se não for integrado com TMS não carrega os campos automaticamente.
	If FunName() == 'MNTA545'
		If lNaoIntTMS .Or. (!Inclui .And. Empty(ReadVar()))
			Return .T.
		EndIf
	Else
		Return .T.
	EndIf

	cAliasQry := GetNextAlias()
	cQuery := "SELECT DTQ.DTQ_VIAGEM, DTQ.DTQ_FILORI, DTQ.DTQ_FILDES, DUP.DUP_CODMOT, DA4.DA4_NOME, "
	cQuery += " 	   DTW.DTW_DATINI, DTW.DTW_HORINI, DUV.DUV_ODOSAI, DTQ.DTQ_DATFIM "
	cQuery += " FROM " + RetSqlName("ST9") + " ST9," + RetSqlName("DTR") + " DTR," + RetSqlName("DTQ") + " DTQ," +;
	RetSqlName("DUP") + " DUP," + RetSqlName("DA4") + " DA4," + RetSqlName("DUV") + " DUV," +;
	RetSqlName("DTW") + " DTW "
	cQuery += " WHERE ST9.T9_CODBEM = '"+M->TRH_CODBEM+"'"
	cQuery += " AND ST9.T9_CODTMS  = DTR.DTR_CODVEI"
	cQuery += " AND DTW_ATIVID IN ('"+cAtivSai+"','"+cAtivChg+"')"
	cQuery += " AND DTQ.DTQ_VIAGEM = DTR.DTR_VIAGEM"
	cQuery += " AND DTQ.DTQ_FILORI = DTR.DTR_FILORI"
	cQuery += " AND DTR_VIAGEM = DTW_VIAGEM"
	cQuery += " AND DTR_FILORI = DTW_FILORI"
	cQuery += " AND DTQ.DTQ_VIAGEM = DUP.DUP_VIAGEM"
	cQuery += " AND DTQ.DTQ_FILORI = DUP.DUP_FILORI"
	cQuery += " AND DTQ.DTQ_VIAGEM = DUV.DUV_VIAGEM"
	cQuery += " AND DTQ.DTQ_FILORI = DUV.DUV_FILORI"
	cQuery += " AND DUP.DUP_CODMOT = DA4.DA4_COD"
	cQuery += " AND DTR.D_E_L_E_T_ <> '*' "
	cQuery += " AND DTQ.D_E_L_E_T_ <> '*' "
	cQuery += " AND ST9.D_E_L_E_T_ <> '*' "
	cQuery += " AND DUP.D_E_L_E_T_ <> '*' "
	cQuery += " AND DA4.D_E_L_E_T_ <> '*' "
	cQuery += " AND DTW.D_E_L_E_T_ <> '*' "
	cQuery += " AND DTQ_VIAGEM IN (SELECT MAX(DTR_VIAGEM)"
	cQuery += " FROM " + RetSqlName("DTR") + " CPL," + RetSqlName("DTW") + " ALT1," + RetSqlName("DTW") + " ALT2 "
	cQuery += " WHERE CPL.DTR_FILORI = ALT1.DTW_FILORI"
	cQuery += " AND CPL.DTR_VIAGEM = ALT1.DTW_VIAGEM"
	cQuery += " AND CPL.DTR_FILORI = ALT2.DTW_FILORI"
	cQuery += " AND CPL.DTR_VIAGEM = ALT2.DTW_VIAGEM"
	cQuery += " AND CPL.DTR_CODVEI = DTR.DTR_CODVEI
	cQuery += " AND ALT1.DTW_ATIVID = '"+cAtivSai+"'"
	cQuery += " AND ALT2.DTW_ATIVID = '"+cAtivChg+"'"
	cQuery += " AND ALT1.DTW_DATINI <> ' ' "
	cQuery += " AND ALT2.DTW_DATINI <> ' ' "
	cQuery += " AND(ALT1.DTW_DATINI || ALT1.DTW_HORINI <= '"+DTOS(M->TRH_DTACID)+SubStr(M->TRH_HRACID,1,2)+SubStr(M->TRH_HRACID,4,2)+"')"
	cQuery += " AND(ALT2.DTW_DATINI || ALT2.DTW_HORINI >= '"+DTOS(M->TRH_DTACID)+SubStr(M->TRH_HRACID,1,2)+SubStr(M->TRH_HRACID,4,2)+"')"
	cQuery += " AND(CPL.DTR_DATINI  || CPL.DTR_HORINI  <= '"+DTOS(M->TRH_DTACID)+SubStr(M->TRH_HRACID,1,2)+SubStr(M->TRH_HRACID,4,2)+"')"
	cQuery += " AND CPL.D_E_L_E_T_ <> '*' "
	cQuery += " AND ALT1.D_E_L_E_T_ <> '*' "
	cQuery += " AND ALT2.D_E_L_E_T_ <> '*' )"
	cQuery += " ORDER BY DTQ.DTQ_DATINI, DTQ.DTQ_HORINI"
	cQuery := ChangeQuery(cQuery)
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)
	dbGoTop()

	If Eof()
		M->TRV_CODVIA := Space(Len(TRV->TRV_CODVIA))
		M->TRV_CODMOT := Space(Len(TRV->TRV_CODMOT))
		M->TRV_FILORI := Space(Len(TRV->TRV_FILORI))
		M->TRV_FILDES := Space(Len(TRV->TRV_FILDES))
		M->TRV_NOMMOT := Space(40)
		M->TRV_CIDORI := Space(Len(TRV->TRV_CIDORI))
		M->TRV_UFORI  := Space(Len(TRV->TRV_UFORI))
		M->TRV_CIDDES := Space(Len(TRV->TRV_CIDDES))
		M->TRV_UFDES  := Space(Len(TRV->TRV_UFDES))
		M->TRV_HRDIRI := Space(Len(TRV->TRV_HRDIRI))
		M->TRV_KMPERC := 0
	Else
		While !Eof()
			DbSelectArea("SM0")
			SM0->(DbSetOrder(1))
			If MsSeek(SM0->M0_CODIGO+(cAliasQry)->DTQ_FILORI)
				cCidOri := SM0->M0_CIDENT
				cUfOri  := SM0->M0_ESTENT
			Endif
			DbSelectArea("SM0")
			SM0->(DbSetOrder(1))
			If MsSeek(SM0->M0_CODIGO+(cAliasQry)->DTQ_FILDES)
				cCidDes := SM0->M0_CIDENT
				cUfDes  := SM0->M0_ESTENT
			Endif
			M->TRV_CODVIA := (cAliasQry)->DTQ_VIAGEM
			M->TRV_CODMOT := (cAliasQry)->DUP_CODMOT
			M->TRV_FILORI := (cAliasQry)->DTQ_FILORI
			M->TRV_FILDES := (cAliasQry)->DTQ_FILDES
			M->TRV_NOMMOT := (cAliasQry)->DA4_NOME
			M->TRV_CIDORI := cCidOri
			M->TRV_UFORI  := cUfOri
			M->TRV_CIDDES := cCidDes
			M->TRV_UFDES  := cUfDes
			cHoraIni := SubStr((cAliasQry)->DTW_HORINI,1,2)+":"+SubStr((cAliasQry)->DTW_HORINI,3,2)
			cHoras := NTOH(NGCALCH100(STOD((cAliasQry)->DTW_DATINI),cHoraIni,M->TRH_DTACID,M->TRH_HRACID))
			If Len(cHoras) = 5
				cHoras := '0'+cHoras
			Endif
			M->TRV_HRDIRI := cHoras
			If !Empty((cAliasQry)->DUV_ODOSAI) .AND. !Empty(M->TRH_KMACID)
				M->TRV_KMPERC := M->TRH_KMACID - (cAliasQry)->DUV_ODOSAI
			Endif
			dbSelectArea(cAliasQry)
			dbSkip()
		End
	Endif

	(cAliasQry)->(dbCloseArea())
	RestArea(aAreaOld)

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG545LEG
Cria uma janela contendo a legenda da mBrowse
@author Marcos Wagner Junior
@since 15/02/07
@version undefined

@type function
/*/
//---------------------------------------------------------------------
Function NG545LEG()

	If ExistBlock("MNT545L1")
		ExecBlock("MNT545L1",.f.,.f.)
	Else
		BrwLegenda(cCadastro,STR0006,{{"BR_VERDE",STR0013},;      //"Legenda"###"Sinistro não complementado"
									  {"BR_AZUL" ,STR0014},;      //"Sinistro complementado"
									  {"BR_VERMELHO" ,STR0039}} ) //"Sinistro finalizado"
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG545COR
Funcao para definir as cores do mBrowse
@author Marcos Wagner Junior
@since 15/02/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG545COR()

	Local aCores := {}
	Local _aCores

	aCores := {                                                                                          ;
	{"NGSEMAFARO('TRH->TRH_FLGCOM = cSit1')" , 'BR_VERDE' },;
	{"NGSEMAFARO('TRH->TRH_FLGCOM = cSit2')" , 'BR_AZUL'  },;
	{"NGSEMAFARO('TRH->TRH_FLGCOM = cSit3')" , 'BR_VERMELHO'}}

	If ExistBlock("MNT545L2")
		_aCores := ExecBlock("MNT545L2",.f.,.f.)
		If ValType(_aCores) == "A"
			aCores := _aCores
		EndIf
	EndIf

Return(aCores)

//---------------------------------------------------------------------
/*/{Protheus.doc} NG545LINOK
Critica se a linha digitada esta' Ok

@author Marcos Wagner Junior
@since 15/02/07
@version MP12

@param nG, Numérico, Numero da aba.
@param cTUDOOK, Caracter, Determina que é TudoOk.

@type function

@return lRet, Lógico, Variavel que determina se requisitos foram preenchidos.
/*/
//---------------------------------------------------------------------
Function NG545LINOK(nG,cTUDOOK)

	Local nx, nI
	Local lRet      := .T.
	Local lRet2     := .T.
	Local lVazio    := .T.
	Local cVAR      := "oGET"+Strzero(nG,2)

	// nG == 7 Folder/Aba de Inquérito.
	Local lFolderInq := nG != 7

	If cTUDOOK == Nil

		aSVHEADER[nG]  := aCLONE(aHEADER)
		aSVCOLS[nG]    := aCLONE(aCOLS)

		If nG == 1
			If !aCOLS[n][Len(aCOLS[n])] .And. !Empty(aCOLS[n][nTRICODDOC]) .And. !Empty(aCOLS[n][nTRIDTREC]) .And. !Empty(aCOLS[n][nTRIHRREC])
				If DtoS( aCOLS[n][nTRIDTREC] ) + SubStr(aCOLS[n][nTRIHRREC],1,5) > DtoS( dDataBase ) + Substr( Time() ,1,5)
					MsgInfo(STR0046) //"Data/Hora do documento maior que a Data/Hora atual."
					oFolder:nOption := 3
					Return .f.
				Endif
			Endif
		ElseIf nG == 8
			If !aCOLS[n][Len(aCOLS[n])]
				For nI := 1 to Len(aCols)
					If aCOLS[n][GDFIELDPOS("TU4_NOMPRO",aHeader)]+aCOLS[n][GDFIELDPOS("TU4_TIPANI",aHeader)] == aCOLS[nI][GDFIELDPOS("TU4_NOMPRO",aHeader)]+aCOLS[nI][GDFIELDPOS("TU4_TIPANI",aHeader)] .AND.;
					n != nI
						If !aCOLS[nI][Len(aCOLS[nI])]
							MsgStop(STR0086,STR0012)//"Registro duplicado no Folder de Animais"###"Atenção"
							oFolder:nOption := 10
							Return .f.
						Endif
					Endif
				Next
			EndIf
		Endif

		oFOLDER:REFRESH()
		&cVAR:oBROWSE:REFRESH()

		Return .t.
	Else
		aHEADER := aCLONE(aSVHEADER[nG])
		aCOLS   := aCLONE(aSVCOLS[nG])
		n       := Len(aCOLS)
	Endif

	For nI := 1 to Len(aCols)
		If !Empty( IIf( lFolderInq, aCols[ nI, 1 ], StrTran( aCols[ nI, 1 ], '/', '') ) )
			lVazio := .F.
			Exit
		EndIf
	Next

	If !lVazio
		For nx:=1 TO LEN(aCOLS)
			If !aCOLS[nx][Len(aCOLS[nx])]
				If ng = 1
					If Empty(aCOLS[nx][nTRICODDOC]) .OR. Empty(aCOLS[nx][nTRIDTREC]) .Or.;
					Empty(aCOLS[nx][nTRIHRREC])
						If Empty(aCOLS[nx][nTRICODDOC])
							cOBRIGCAM := NGSEEKDIC("SX3","TRI_CODDOC",2,"X3_TITULO")
						ElseIf Empty(aCOLS[nx][nTRIDTREC])
							cOBRIGCAM := NGSEEKDIC("SX3","TRI_DTREC",2,"X3_TITULO")
						ElseIf Empty(aCOLS[nx][nTRIHRREC])
							cOBRIGCAM := NGSEEKDIC("SX3","TRI_HRREC",2,"X3_TITULO")
						Endif
						lRet := .F.
						nNumFolder := 1
					ElseIf DtoS( aCOLS[nx][nTRIDTREC] ) + SubStr(aCOLS[nx][nTRIHRREC],1,5) > DtoS( dDataBase ) + Substr( Time() ,1,5)
						lRet2 := .F.
						lRet := .F.
						nNumFolder := 1
					Endif
				ElseIf ng = 3
					If Empty(aCOLS[nx][nTRLTIPIMO]) .Or. Empty(aCOLS[nx][nTRLDESIMO]) .Or.;
					Empty(aCOLS[nx][nTRLENDPRO]) .Or. Empty(aCOLS[nx][nTRLCODPRO]) .Or.;
					Empty(aCOLS[nx][nTRLUF])
						If Empty(aCOLS[nx][nTRLTIPIMO])
							cOBRIGCAM := NGSEEKDIC("SX3","TRL_TIPIMO",2,"X3_TITULO")
						Elseif Empty(aCOLS[nx][nTRLDESIMO])
							cOBRIGCAM := NGSEEKDIC("SX3","TRL_DESIMO",2,"X3_TITULO")
						Elseif Empty(aCOLS[nx][nTRLENDPRO])
							cOBRIGCAM := NGSEEKDIC("SX3","TRL_ENDPRO",2,"X3_TITULO")
						Elseif Empty(aCOLS[nx][nTRLCODPRO])
							cOBRIGCAM := NGSEEKDIC("SX3","TRL_CODPRO",2,"X3_TITULO")
						Elseif Empty(aCOLS[nx][nTRLUF])
							cOBRIGCAM := NGSEEKDIC("SX3","TRL_UF",2,"X3_TITULO")
						Endif
						lRet := .F.
						nNumFolder := 3
					EndIf
				ElseIf ng = 4
					If Empty(aCOLS[nx][nTRNNOMTES]) .Or. Empty(aCOLS[nx][nTRNDOCTO]) .Or.;
					Empty(aCOLS[nx][nTRNTIPDOC]) .Or. Empty(aCOLS[nx][nTRNQLFTES])
						If Empty(aCOLS[nx][nTRNNOMTES])
							cOBRIGCAM := NGSEEKDIC("SX3","TRN_NOMTES",2,"X3_TITULO")
						Elseif Empty(aCOLS[nx][nTRNDOCTO])
							cOBRIGCAM := NGSEEKDIC("SX3","TRN_DOCTO",2,"X3_TITULO")
						Elseif Empty(aCOLS[nx][nTRNQLFTES])
							cOBRIGCAM := NGSEEKDIC("SX3","TRN_QLFTES",2,"X3_TITULO")
						Elseif Empty(aCOLS[nx][nTRNTIPDOC])
							cOBRIGCAM := NGSEEKDIC("SX3","TRN_TIPDOC",2,"X3_TITULO")
						Endif
						lRet := .F.
						nNumFolder := 4
					EndIf
				ElseIf ng = 5
					If Empty(aCOLS[nx][nTROPLACA])  .Or. Empty(aCOLS[nx][nTROTIPVEI]) .Or.;
					Empty(aCOLS[nx][nTRODESVEI]) .Or. Empty(aCOLS[nx][nTRONOMPR])
						If Empty(aCOLS[nx][nTROPLACA])
							cOBRIGCAM := NGSEEKDIC("SX3","TRO_PLACA",2,"X3_TITULO")
						Elseif Empty(aCOLS[nx][nTROTIPVEI])
							cOBRIGCAM := NGSEEKDIC("SX3","TRO_TIPVEI",2,"X3_TITULO")
						Elseif Empty(aCOLS[nx][nTRODESVEI])
							cOBRIGCAM := NGSEEKDIC("SX3","TRO_DESVEI",2,"X3_TITULO")
						Elseif Empty(aCOLS[nx][nTRONOMPR])
							cOBRIGCAM := NGSEEKDIC("SX3","TRO_NOMPR",2,"X3_TITULO")
						Endif
						lRet := .F.
						nNumFolder := 5
					EndIf
				ElseIf ng = 6
					If Empty(aCOLS[nx][nTRMNOMVIT]) .Or. Empty(aCOLS[nx][nTRMLESOES])
						If Empty(aCOLS[nx][nTRMINDFUN])
							cOBRIGCAM := NGSEEKDIC("SX3","TRM_INDFUN",2,"X3_TITULO")
						Elseif Empty(aCOLS[nx][nTRMMATVIT]) .AND. aCOLS[nx][nTRMINDFUN] = '1'
							cOBRIGCAM := NGSEEKDIC("SX3","TRM_MATVIT",2,"X3_TITULO")
						Elseif Empty(aCOLS[nx][nTRMNOMVIT])
							cOBRIGCAM := NGSEEKDIC("SX3","TRM_NOMVIT",2,"X3_TITULO")
						Elseif Empty(aCOLS[nx][nTRMLESOES])
							cOBRIGCAM := NGSEEKDIC("SX3","TRM_LESOES",2,"X3_TITULO")
						Endif
						lRet := .F.
						nNumFolder := 6
					EndIf
				ElseIf ng = 7 //Aba Inquerito
					If aScan(aCOLS[nX], {|x| !Empty(x) }) > 0 //Verifica se existe algum registro.
						If Empty(aCOLS[nx][nTRJNUMINQ]) .Or. Empty(aCOLS[nx][nTRJENVJUR]) .Or. aCOLS[nx][nTRJNUMINQ] == "   /  /  "
							If Empty(aCOLS[nx][nTRJNUMINQ]) .Or. aCOLS[nx][nTRJNUMINQ] == "   /  /  "
								cOBRIGCAM := NGSEEKDIC("SX3","TRJ_NUMINQ",2,"X3_TITULO")
							Elseif Empty(aCOLS[nx][nTRJENVJUR])
								cOBRIGCAM := NGSEEKDIC("SX3","TRJ_DTENJU",2,"X3_TITULO")
							Endif
							lRet := .F.
							nNumFolder := 7
						EndIf
					EndIf
				ElseIf ng = 8
					If Empty(aCOLS[nx][nTU4NOMPRO]) .Or. Empty(aCOLS[nx][nTU4TIPANI])
						If Empty(aCOLS[nx][nTU4NOMPRO])
							cOBRIGCAM := NGSEEKDIC("SX3","TU4_NOMPRO",2,"X3_TITULO")
						Elseif Empty(aCOLS[nx][nTU4TIPANI])
							cOBRIGCAM := NGSEEKDIC("SX3","TU4_TIPANI",2,"X3_TITULO")
						Endif
						lRet := .F.
						nNumFolder := 8
					EndIf
				EndIf

				If !lRet
					If !lRet2
						MsgInfo(STR0046+" "+"Folder"+" '"+aTitles[nNumFolder+2]+"'") //"Data/Hora do documento maior que a Data/Hora atual."
						lRet2 := .t.
					Else
						HELP(" ",1,"OBRIGAT",,cOBRIGCAM+' - "'+'Folder '+aTitles[nNumFolder+2]+'"',05)
					Endif
					Exit
				Else
					aSVHEADER[nG]  := aCLONE(aHEADER)
					aSVCOLS[nG]    := aCLONE(aCOLS)
					n              := Len(aCOLS)
				Endif
			Else
				aSVHEADER[nG]  := aCLONE(aHEADER)
				aSVCOLS[nG]    := aCLONE(aCOLS)
				n              := Len(aCOLS)
			EndIf
		Next
		If !lRet
			If oFolder:nOption >= 3
				aHEADER  := aCLONE(aSVHEADER[oFolder:nOption-2])
				aCOLS    := aCLONE(aSVCOLS[oFolder:nOption-2])
				n        := Len(aCOLS)
			Endif
		Endif

	Endif

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} ENTRAG545
Retorna aCols e aHeader quando se foca a GETDADOS
@author Marcos Wagner Junior
@since 15/02/07
@version undefined
@param nG, numeric
@type function
/*/
//---------------------------------------------------------------------
Static Function ENTRAG545(nG)

	Local cVAR := "oGET"+STRZERO(nG,2)

	aHEADER    := aCLONE(aSVHEADER[nG])
	aCOLS      := aCLONE(aSVCOLS[nG])
	n := LEN(aCOLS)
	oFOLDER:REFRESH()
	&cVAR:oBROWSE:REFRESH()
	If cVar = "oGET01"
		oGet01:oBrowse:Refresh()
	ElseIf cVar = "oGET02"
		oGet02:oBrowse:Refresh()
	ElseIf cVar = "oGET03"
		oGet03:oBrowse:Refresh()
	ElseIf cVar = "oGET04"
		oGet04:oBrowse:Refresh()
	ElseIf cVar = "oGET05"
		oGet05:oBrowse:Refresh()
	ElseIf cVar = "oGET06"
		oGet06:oBrowse:Refresh()
	ElseIf cVar = "oGET07"
		oGet07:oBrowse:Refresh()
	ElseIf cVar = "oGET08"
		oGet08:oBrowse:Refresh()
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545VAL
Verifica se ja existe documento igual ao mencionado
@author Marcos Wagner Junior
@since 15/02/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545VAL()

	Local i,lRet := .t.,lRegIgual := .f.

	cNum := If(Inclui,M->TRH_NUMSIN,TRH->TRH_NUMSIN)
	If !EXISTCPO("TRU",M->TRI_CODDOC)
		lRet := .f.
	Endif
	If lRet
		dbSelectArea("TRU")
		dbSetOrder(01)
		dbSeek(xFilial("TRU")+M->TRI_CODDOC)
		While !Eof() .AND. TRU->TRU_FILIAL == xFilial("TRU") .AND. TRU->TRU_CODDOC == M->TRI_CODDOC
			If TRU->TRU_TIPEVE == M->TRH_EVENTO
				lRegIgual := .t.
			Endif
			dbskip()
		End
		If !lRegIgual
			MsgStop(STR0047,STR0012)  //"O evento do sinistro é divergente do evento do documento!"###"Atenção"
			Return .f.
		Endif
	Endif
	For i := 1 to Len(aCols)
		If M->TRI_CODDOC = aCols[i][nTRICODDOC] .AND. !aCols[n][Len(aHeader)+1] .AND. !aCols[i][Len(aHeader)+1]
			Help(" ",1,STR0023) //"JAGRAVADO"
			Return .f.
		Endif
	Next
	If lRet
		dbSelectArea("TRI")
		dbSetOrder(01)
		If dbSeek(xFilial("TRI")+cNum+M->TRI_CODDOC)
			Help(" ",1,STR0023) //"JAGRAVADO"
			lRet := .f.
		Endif
	Endif

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} A545TRMSEQ
Pega o numero sequencial referente ao Sinistro
@author Ricardo Dal Ponte
@since 09/04/07
@version undefined
@param cLinha, characters
@type function
/*/
//---------------------------------------------------------------------
Function A545TRMSEQ(cLinha)

	Local cSequencia
	Local lJaExiste := .f., ny

	cAliasQry := GetNextAlias()
	cQuery := " SELECT TRM.TRM_SEQVIT, TRM.TRM_INDFUN, TRM.TRM_MATVIT, TRM.TRM_NOMVIT, TRM.TRM_LESOES, TRM.R_E_C_N_O_ AS REGISTRO "
	cQuery += " FROM " + RetSqlName("TRM") + " TRM"
	cQuery += " WHERE TRM.TRM_NUMSIN = '"+M->TRH_NUMSIN+"'"
	cQuery += " AND   TRM.D_E_L_E_T_ <> '*' "
	cQuery := ChangeQuery(cQuery)
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)

	DbGoTop()
	If !Eof()
		While !Eof()
			If ((cAliasQry)->TRM_INDFUN = aSVCOLS[6][cLinha][nTRMINDFUN]) .AND. ((cAliasQry)->TRM_MATVIT  = aSVCOLS[6][cLinha][nTRMMATVIT]) .AND.;
			((cAliasQry)->TRM_NOMVIT = aSVCOLS[6][cLinha][nTRMNOMVIT]) .AND. ((cAliasQry)->TRM_LESOES  = aSVCOLS[6][cLinha][nTRMLESOES])
				lJaExiste := .t.
				//
				dbSelectArea("TRM")
				dbGoTo((cAliasQry)->REGISTRO)
				RecLock("TRM",.F.)
				dbSelectArea("TRM")
				For ny := 1 To FCOUNT()
					xx := aSCAN(aSVHEADER[6],{|x| AllTrim(x[2]) == AllTrim(FIELDNAME(ny))})
					If xx > 0
						vv   := "TRM->"+FIELDNAME(ny)
						&vv. := aSVCOLS[6][cLinha][xx]
					EndIf
				Next ny
				TRM->(MsUnlock())
				dbSelectArea(cAliasQry)
				//
			Endif
			cSequencia := Val((cAliasQry)->TRM_SEQVIT)
			dbSkip()
		End
		(cAliasQry)->(dbCloseArea())
		Return {lJaExiste,StrZero(cSequencia+1,3)}
	Else
		(cAliasQry)->(dbCloseArea())
		Return {lJaExiste,'001'}
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} A545TROSEQ
Pega o numero sequencial de chave
@author Ricardo Dal Ponte
@since 09/04/07
@version undefined
@param cLinha, characters
@type function
/*/
//---------------------------------------------------------------------
Function A545TROSEQ(cLinha)

	Local cSequencia
	Local lJaExiste := .f., ny

	cAliasQry := GetNextAlias()
	cQuery := " SELECT TRO.TRO_SEQVEI, TRO.TRO_PLACA, TRO.TRO_TIPVEI, TRO.TRO_DESVEI, TRO.TRO_NOMPR, TRO.R_E_C_N_O_ AS REGISTRO "
	cQuery += " FROM " + RetSqlName("TRO") + " TRO"
	cQuery += " WHERE TRO.TRO_NUMSIN = '"+M->TRH_NUMSIN+"'"
	cQuery += " AND   TRO.D_E_L_E_T_ <> '*' "
	cQuery := ChangeQuery(cQuery)
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)

	DbGoTop()
	If !Eof()
		While !Eof()
			If ((cAliasQry)->TRO_PLACA  = aSVCOLS[5][cLinha][nTROPLACA])  .AND. ((cAliasQry)->TRO_TIPVEI = aSVCOLS[5][cLinha][nTROTIPVEI]) .AND.;
			((cAliasQry)->TRO_DESVEI = aSVCOLS[5][cLinha][nTRODESVEI]) .AND. ((cAliasQry)->TRO_NOMPR  = aSVCOLS[5][cLinha][nTRONOMPR])
				lJaExiste := .t.
				//
				dbSelectArea("TRO")
				dbGoTo((cAliasQry)->REGISTRO)
				RecLock("TRO",.F.)
				dbSelectArea("TRO")
				For ny := 1 To FCOUNT()
					xx := aSCAN(aSVHEADER[5],{|x| AllTrim(x[2]) == AllTrim(FIELDNAME(ny))})
					If xx > 0
						vv   := "TRO->"+FIELDNAME(ny)
						&vv. := aSVCOLS[5][cLinha][xx]
					EndIf
				Next ny
				TRO->(MsUnlock())
				dbSelectArea(cAliasQry)
				//
			Endif
			cSequencia := Val((cAliasQry)->TRO_SEQVEI)
			dbSkip()
		End
		(cAliasQry)->(dbCloseArea())
		Return {lJaExiste,StrZero(cSequencia+1,3)}
	Else
		(cAliasQry)->(dbCloseArea())
		Return {lJaExiste,'001'}
	Endif


Return

//---------------------------------------------------------------------
/*/{Protheus.doc} A545TRNSEQ
Pega o numero sequencial de chave
@author Ricardo Dal Ponte
@since 09/04/07
@version undefined
@param cLinha, characters
@type function
/*/
//---------------------------------------------------------------------
Function A545TRNSEQ(cLinha)

	Local cSequencia
	Local lJaExiste := .f., ny

	cAliasQry := GetNextAlias()
	cQuery := " SELECT TRN.TRN_SEQTES, TRN.TRN_NOMTES, TRN.TRN_DOCTO, TRN.TRN_QLFTES, TRN.TRN_TIPDOC, TRN.R_E_C_N_O_ AS REGISTRO "
	cQuery += " FROM " + RetSqlName("TRN") + " TRN"
	cQuery += " WHERE TRN.TRN_NUMSIN = '"+M->TRH_NUMSIN+"'"
	cQuery += " AND   TRN.D_E_L_E_T_ <> '*' "
	cQuery := ChangeQuery(cQuery)
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)

	DbGoTop()
	If !Eof()
		While !Eof()
			If ((cAliasQry)->TRN_NOMTES = aSVCOLS[4][cLinha][nTRNNOMTES]) .AND. ((cAliasQry)->TRN_DOCTO  = aSVCOLS[4][cLinha][nTRNDOCTO]) .AND.;
			((cAliasQry)->TRN_QLFTES = aSVCOLS[4][cLinha][nTRNQLFTES]) .AND. ((cAliasQry)->TRN_TIPDOC = aSVCOLS[4][cLinha][nTRNTIPDOC])
				lJaExiste := .t.
				//
				dbSelectArea("TRN")
				dbGoTo((cAliasQry)->REGISTRO)
				RecLock("TRN",.F.)
				dbSelectArea("TRN")
				For ny := 1 To FCOUNT()
					xx := aSCAN(aSVHEADER[4],{|x| AllTrim(x[2]) == AllTrim(FIELDNAME(ny))})
					If xx > 0
						vv   := "TRN->"+FIELDNAME(ny)
						&vv. := aSVCOLS[4][cLinha][xx]
					EndIf
				Next ny
				TRN->(MsUnlock())
				dbSelectArea(cAliasQry)
				//
			Endif
			cSequencia := Val((cAliasQry)->TRN_SEQTES)
			dbSkip()
		End
		(cAliasQry)->(dbCloseArea())
		Return {lJaExiste,StrZero(cSequencia+1,3)}
	Else
		(cAliasQry)->(dbCloseArea())
		Return {lJaExiste,'001'}
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} A545TRLSEQ
Pega o numero sequencial de chave
@author Ricardo Dal Ponte
@since 09/04/07
@version undefined
@param cLinha, characters
@type function
/*/
//---------------------------------------------------------------------
Function A545TRLSEQ(cLinha)

	Local cSequencia
	Local lJaExiste := .f., ny

	cAliasQry := GetNextAlias()
	cQuery := " SELECT TRL.TRL_SEQIMO, TRL.TRL_TIPIMO, TRL.TRL_DESIMO, TRL.TRL_ENDPRO, TRL.TRL_CODPRO, TRL.TRL_UF, TRL.R_E_C_N_O_ AS REGISTRO  "
	cQuery += " FROM " + RetSqlName("TRL") + " TRL"
	cQuery += " WHERE TRL.TRL_NUMSIN = '"+M->TRH_NUMSIN+"'"
	cQuery += " AND   TRL.D_E_L_E_T_ <> '*' "
	cQuery := ChangeQuery(cQuery)
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)

	DbGoTop()
	If !Eof()
		While !Eof()
			If ((cAliasQry)->TRL_TIPIMO = aSVCOLS[3][cLinha][nTRLTIPIMO]) .AND. ((cAliasQry)->TRL_DESIMO = aSVCOLS[3][cLinha][nTRLDESIMO]) .AND.;
			((cAliasQry)->TRL_ENDPRO = aSVCOLS[3][cLinha][nTRLENDPRO]) .AND. ((cAliasQry)->TRL_CODPRO = aSVCOLS[3][cLinha][nTRLCODPRO]) .AND.;
			((cAliasQry)->TRL_UF     = aSVCOLS[3][cLinha][nTRLUF])
				lJaExiste := .t.
				//
				dbSelectArea("TRL")
				dbGoTo((cAliasQry)->REGISTRO)
				RecLock("TRL",.F.)
				dbSelectArea("TRL")
				For ny := 1 To FCOUNT()
					xx := aSCAN(aSVHEADER[3],{|x| AllTrim(x[2]) == AllTrim(FIELDNAME(ny))})
					If xx > 0
						vv   := "TRL->"+FIELDNAME(ny)
						&vv. := aSVCOLS[3][cLinha][xx]
					EndIf
				Next ny
				TRL->(MsUnlock())
				dbSelectArea(cAliasQry)
				//
			Endif
			cSequencia := Val((cAliasQry)->TRL_SEQIMO)
			dbSkip()
		End
		(cAliasQry)->(dbCloseArea())
		Return {lJaExiste,StrZero(cSequencia+1,3)}
	Else
		(cAliasQry)->(dbCloseArea())
		Return {lJaExiste,'001'}
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} A545TRKSEQ
Pega o numero sequencial de chave
@author Ricardo Dal Ponte
@since 09/04/07
@version undefined
@param nLinha, numeric
@type function
/*/
//---------------------------------------------------------------------
Function A545TRKSEQ(nLinha)

	Local nSeqTRK := 0
	Local nSequencia := 0
	Local lJaExiste := .f.

	cAliasQry := GetNextAlias()
	cQuery := " SELECT TRK.TRK_SEQCAR, TRK.TRK_VALAVA, TRK.TRK_VALREC "
	cQuery += " FROM " + RetSqlName("TRK") + " TRK"
	cQuery += " WHERE TRK.TRK_NUMSIN = '"+M->TRH_NUMSIN+"'"
	cQuery += " AND   TRK.D_E_L_E_T_ <> '*' "
	cQuery += " ORDER BY TRK.TRK_SEQCAR "
	cQuery := ChangeQuery(cQuery)
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)

	DbGoTop()
	If !Eof()
		While !Eof() .AND. nSequencia == 0
			If nLinha <= Len(aOLDCOLTRK)
				If ((cAliasQry)->TRK_VALAVA = aOLDCOLTRK[nLinha][1]) .AND. ((cAliasQry)->TRK_VALREC = aOLDCOLTRK[nLinha][2])
					lJaExiste := .t.
					nSequencia := Val((cAliasQry)->TRK_SEQCAR)
				Endif
			Endif
			nSeqTRK := Val((cAliasQry)->TRK_SEQCAR)
			dbSkip()
		End
		(cAliasQry)->(dbCloseArea())
		Return {lJaExiste,If(lJaExiste,StrZero(nSequencia,3),StrZero(nSeqTRK+1,3))}
	Else
		(cAliasQry)->(dbCloseArea())
		Return {lJaExiste,'001'}
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} A545TU4SEQ
Pega o numero sequencial de chave
@author Rafael Reinert
@since 18/04/11
@version undefined
@param cLinha, characters
@type function
/*/
//---------------------------------------------------------------------
Function A545TU4SEQ(cLinha)

	Local cSequencia
	Local lJaExiste := .f., ny

	cAliasQry := GetNextAlias()
	cQuery := " SELECT TU4.TU4_SEQANI, TU4.TU4_NOMPRO, TU4.TU4_TIPANI, TU4.R_E_C_N_O_ AS REGISTRO  "
	cQuery += " FROM " + RetSqlName("TU4") + " TU4"
	cQuery += " WHERE TU4.TU4_NUMSIN = '"+M->TRH_NUMSIN+"'"
	cQuery += " AND   TU4.D_E_L_E_T_ <> '*' "
	cQuery := ChangeQuery(cQuery)
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)

	DbGoTop()
	If !Eof()
		While !Eof()
			If ((cAliasQry)->TU4_NOMPRO = aSVCOLS[8][cLinha][nTU4NOMPRO]) .AND. ;
			((cAliasQry)->TU4_TIPANI = aSVCOLS[8][cLinha][nTU4TIPANI])

				lJaExiste := .t.
				dbSelectArea("TU4")
				dbGoTo((cAliasQry)->REGISTRO)
				RecLock("TU4",.F.)
				dbSelectArea("TU4")
				For ny := 1 To FCOUNT()
					xx := aSCAN(aSVHEADER[8],{|x| AllTrim(x[2]) == AllTrim(FIELDNAME(ny))})
					If xx > 0
						vv   := "TU4->"+FIELDNAME(ny)
						&vv. := aSVCOLS[8][cLinha][xx]
					EndIf
				Next ny
				TU4->(MsUnlock())
				dbSelectArea(cAliasQry)
			Endif
			cSequencia := Val((cAliasQry)->TU4_SEQANI)
			dbSkip()
		End
		(cAliasQry)->(dbCloseArea())
		Return {lJaExiste,StrZero(cSequencia+1,3)}
	Else
		(cAliasQry)->(dbCloseArea())
		Return {lJaExiste,'001'}
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} AGR545TRV
Grava tabela TRV
@author Ricardo Dal Ponte
@since 09/04/07
@version undefined
@param nOpcx, numeric
@type function
/*/
//---------------------------------------------------------------------
Function AGR545TRV(nOpcx)

	Local y, nx, ny
	DbSelectArea("TRV")
	DbSetOrder(01)
	If (dbSeek(xFilial("TRV")+M->TRH_NUMSIN)) .AND. (Altera .Or. nOpcx == 5)
		RecLock("TRV",.F.)
		If nOpcx == 5
			DbDelete()
			MsUnlock("TRV")
		Endif
	Else
		If nOpcx <> 5
			RecLock("TRV",.T.)
		Endif
	Endif

	If Altera .OR. Inclui
		For ny := 1 To FCOUNT()
			nx := "m->" + FieldName(ny)
			If "_FILIAL"$Upper(nx)
				&nx. := xFilial("TRV")
			Endif
			If "_NUMSIN"$Upper(nx)
				&nx. := M->TRH_NUMSIN
			Endif
			FieldPut(ny, &nx.)
		Next ny
	Endif
	If nOpcx <> 5
		MsUnlock("TRV")
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} AGR545TRI
Ricardo Dal Ponte
@author Ricardo Dal Ponte
@since 09/04/07
@version undefined
@param nOpcx, numeric
@type function
/*/
//---------------------------------------------------------------------
Function AGR545TRI(nOpcx)

	Local y, nx, ny

	If nOpcx == 5
		dbSelectArea("TRI")
		dbSetOrder(01)
		dbSeek(xFilial("TRI")+M->TRH_NUMSIN)
		While TRI->TRI_FILIAL == xFilial("TRI") .AND. TRI->TRI_NUMSIN == M->TRH_NUMSIN
			RecLock("TRI",.f.)
			dbDelete()
			TRI->(MsUnlock())
			dbSkip()
		End
	Endif

	If Altera .OR. Inclui
		dbSelectArea("TRI")
		dbSetOrder(01)
		dbSeek(xFilial("TRI")+M->TRH_NUMSIN)
		While !Eof() .And. xFilial("TRI") == TRI->TRI_FILIAL .And. TRI->TRI_NUMSIN == M->TRH_NUMSIN
			If aSCAN(aSVCOLS[1],{|x| x[1] == TRI->TRI_CODDOC}) == 0
				RecLock("TRI",.F.)
				DbDelete()
				TRI->(MsUnlock())
			Endif
			dbSkip()
		End
		For nx = 1 TO Len(aSVCOLS[1])
			If (!aSVCOLS[1][nx][Len(aSVCOLS[1][nx])])
				If (!Empty(aSVCOLS[1][nx][nTRICODDOC]))
					dbSelectArea("TRI")
					dbSetOrder(01)
					If dbSeek(xFilial("TRI")+M->TRH_NUMSIN+aSVCOLS[1][nx][nTRICODDOC])
						RecLock("TRI",.F.)
					Else
						RecLock("TRI",.T.)
						TRI->TRI_FILIAL := xFilial("TRI")
						TRI->TRI_NUMSIN := M->TRH_NUMSIN
					Endif

					For ny := 1 To FCOUNT()
						xx := aSCAN(aSVHEADER[1],{|x| AllTrim(x[2]) == AllTrim(FIELDNAME(ny))})
						If xx > 0
							vv   := "TRI->"+FIELDNAME(ny)
							&vv. := aSVCOLS[1][nx][xx]
						EndIf
					Next ny

					TRI->(MsUnlock())
				Endif
			Else
				dbSelectArea("TRI")
				dbSetOrder(01)
				dbSeek(xFilial("TRI")+M->TRH_NUMSIN+aSVCOLS[1][nx][nTRICODDOC])

				While !Eof() .And. xFilial("TRI") = TRI->TRI_FILIAL .And. TRI->TRI_NUMSIN = M->TRH_NUMSIN .And. aSVCOLS[1][nx][nTRICODDOC] = TRI->TRI_CODDOC
					RecLock("TRI",.F.)
					DbDelete()
					TRI->(MsUnlock())
					dbSkip()
				End
			EndIF
		Next nx
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} AGR545TRK
Grava tabela TRK
@author Ricardo Dal Ponte
@since 09/04/07
@version undefined
@param nOpcx, numeric
@type function
/*/
//---------------------------------------------------------------------
Function AGR545TRK(nOpcx)

	Local y, nx, ny, aSeqCar := {}

	If nOpcx == 5
		dbSelectArea("TRK")
		dbSetOrder(01)
		dbSeek(xFilial("TRK")+M->TRH_NUMSIN)
		While TRK->TRK_FILIAL == xFilial("TRK") .AND. TRK->TRK_NUMSIN == M->TRH_NUMSIN
			RecLock("TRK",.f.)
			dbDelete()
			TRK->(MsUnlock())
			dbSkip()
		End
	Endif

	If Altera .OR. Inclui
		For nx = 1 TO Len(aSVCOLS[2])
			If (!aSVCOLS[2][nx][Len(aSVCOLS[2][nx])])
				If (!Empty(aSVCOLS[2][nx][1]))
					aSeqCar := A545TRKSEQ(nx)
					dbSelectArea("TRK")
					If !aSeqCar[1]
						RecLock("TRK",.T.)
						TRK->TRK_FILIAL := xFilial("TRK")
						TRK->TRK_NUMSIN := M->TRH_NUMSIN
						TRK->TRK_SEQCAR := aSeqCar[2]
						TRK->TRK_CODCAR := MNTA545TRK()

						dbSelectArea("TRK")
						For ny := 1 To FCOUNT()
							xx := aSCAN(aSVHEADER[2],{|x| AllTrim(x[2]) == AllTrim(FIELDNAME(ny))})
							If xx > 0
								vv   := "TRK->"+FIELDNAME(ny)
								&vv. := aSVCOLS[2][nx][xx]
							EndIf
						Next ny
					Else
						dbSetOrder(01)
						If dbSeek(xFilial("TRK")+M->TRH_NUMSIN+aSeqCar[2])
							RecLock("TRK",.f.)
							TRK->TRK_VALAVA := aSVCOLS[2][nx][1]
							TRK->TRK_VALREC := aSVCOLS[2][nx][2]
						Endif
					Endif
					TRK->(MsUnlock())
				Endif
			Else
				cAliasQry := GetNextAlias()
				cQuery := " SELECT TRK.R_E_C_N_O_ AS REGISTRO FROM " + RetSqlName("TRK") + " TRK "
				cQuery += " WHERE TRK.TRK_NUMSIN = '"+M->TRH_NUMSIN+"'"
				cQuery += " AND   TRK.TRK_VALAVA = '"+Str(aSVCOLS[2][nx][1])+"'"
				cQuery += " AND   TRK.TRK_VALREC = '"+Str(aSVCOLS[2][nx][2])+"'"
				cQuery += " AND   TRK.D_E_L_E_T_ <> '*' "
				cQuery := ChangeQuery(cQuery)
				dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)
				dbGoTop()
				If !Eof()
					dbSelectArea("TRK")
					dbGoTo((cAliasQry)->REGISTRO)
					RecLock("TRK",.f.)
					dbDelete()
					MsUnlock("TRK")
				Endif
				(cAliasQry)->(dbCloseArea())
			EndIf
		Next nx
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} AGR545TRL
Grava tabela TRL
@author Ricardo Dal Ponte
@since 09/04/07
@version undefined
@param nOpcx, numeric
@type function
/*/
//---------------------------------------------------------------------
Function AGR545TRL(nOpcx)
	Local y, nx, ny, aSeqImo := {}

	If nOpcx == 5
		dbSelectArea("TRL")
		dbSetOrder(01)
		dbSeek(xFilial("TRL")+M->TRH_NUMSIN)
		While TRL->TRL_FILIAL == xFilial("TRL") .AND. TRL->TRL_NUMSIN == M->TRH_NUMSIN
			RecLock("TRL",.f.)
			dbDelete()
			TRL->(MsUnlock())
			dbSkip()
		End
	Endif

	If Altera .OR. Inclui
		For nx = 1 TO Len(aSVCOLS[3])
			If (!aSVCOLS[3][nx][Len(aSVCOLS[3][nx])])
				If (!Empty(aSVCOLS[3][nx][1]))
					aSeqImo := A545TRLSEQ(nx)
					dbSelectArea("TRL")
					If !aSeqImo[1]
						RecLock("TRL",.T.)
						TRL->TRL_FILIAL := xFilial("TRL")
						TRL->TRL_NUMSIN := M->TRH_NUMSIN
						TRL->TRL_SEQIMO := aSeqImo[2]

						dbSelectArea("TRL")
						For ny := 1 To FCOUNT()
							xx := aSCAN(aSVHEADER[3],{|x| AllTrim(x[2]) == AllTrim(FIELDNAME(ny))})
							If xx > 0
								vv   := "TRL->"+FIELDNAME(ny)
								&vv. := aSVCOLS[3][nx][xx]
							EndIf
						Next ny
						TRL->(MsUnlock())
					Endif
				Endif
			Else
				cAliasQry := GetNextAlias()
				cQuery := " SELECT TRL.R_E_C_N_O_ AS REGISTRO FROM " + RetSqlName("TRL") + " TRL "
				cQuery += " WHERE TRL.TRL_NUMSIN = '"+M->TRH_NUMSIN+"'"
				cQuery += " AND   TRL.TRL_TIPIMO = '"+aSVCOLS[3][nx][nTRLTIPIMO]+"'"
				cQuery += " AND   TRL.TRL_DESIMO = '"+aSVCOLS[3][nx][nTRLDESIMO]+"'"
				cQuery += " AND   TRL.TRL_ENDPRO = '"+aSVCOLS[3][nx][nTRLENDPRO]+"'"
				cQuery += " AND   TRL.TRL_CODPRO = '"+aSVCOLS[3][nx][nTRLCODPRO]+"'"
				cQuery += " AND   TRL.TRL_UF     = '"+aSVCOLS[3][nx][nTRLUF]+"'"
				cQuery += " AND   TRL.D_E_L_E_T_ <> '*' "
				cQuery := ChangeQuery(cQuery)
				dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)
				dbGoTop()
				If !Eof()
					dbSelectArea("TRL")
					dbGoTo((cAliasQry)->REGISTRO)
					RecLock("TRL",.f.)
					dbDelete()
					MsUnlock("TRL")
				Endif
				(cAliasQry)->(dbCloseArea())
			EndIf
		Next nx
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} AGR545TRN
Grava tabela TRN
@author Ricardo Dal Ponte
@since 09/04/07
@version undefined
@param nOpcx, numeric
@type function
/*/
//---------------------------------------------------------------------
Function AGR545TRN(nOpcx)

	Local y, nx, ny, aSeqTes := {}

	If nOpcx == 5
		dbSelectArea("TRN")
		dbSetOrder(01)
		dbSeek(xFilial("TRN")+M->TRH_NUMSIN)
		While TRN->TRN_FILIAL == xFilial("TRN") .AND. TRN->TRN_NUMSIN == M->TRH_NUMSIN
			RecLock("TRN",.f.)
			dbDelete()
			TRN->(MsUnlock())
			dbSkip()
		End
	Endif

	If Altera .OR. Inclui
		For nx = 1 TO Len(aSVCOLS[4])
			If (!aSVCOLS[4][nx][Len(aSVCOLS[4][nx])])
				If (!Empty(aSVCOLS[4][nx][nTRNNOMTES]))
					aSeqTes := A545TRNSEQ(nx)
					dbSelectArea("TRN")
					If !aSeqTes[1]
						RecLock("TRN",.T.)
						TRN->TRN_FILIAL := xFilial("TRN")
						TRN->TRN_NUMSIN := M->TRH_NUMSIN
						TRN->TRN_SEQTES := aSeqTes[2]

						dbSelectArea("TRN")
						For ny := 1 To FCOUNT()
							xx := aSCAN(aSVHEADER[4],{|x| AllTrim(x[2]) == AllTrim(FIELDNAME(ny))})
							If xx > 0
								vv   := "TRN->"+FIELDNAME(ny)
								&vv. := aSVCOLS[4][nx][xx]
							EndIf
						Next ny
						TRN->(MsUnlock())
					Endif
				Endif
			Else
				cAliasQry := GetNextAlias()
				cQuery := " SELECT TRN.R_E_C_N_O_ AS REGISTRO FROM " + RetSqlName("TRN") + " TRN "
				cQuery += " WHERE TRN.TRN_NUMSIN = '"+M->TRH_NUMSIN+"'"
				cQuery += " AND   TRN.TRN_NOMTES = '"+aSVCOLS[4][nx][nTRNNOMTES]+"'"
				cQuery += " AND   TRN.TRN_DOCTO  = '"+aSVCOLS[4][nx][nTRNDOCTO]+"'"
				cQuery += " AND   TRN.TRN_QLFTES = '"+aSVCOLS[4][nx][nTRNQLFTES]+"'"
				cQuery += " AND   TRN.TRN_TIPDOC = '"+aSVCOLS[4][nx][nTRNTIPDOC]+"'"
				cQuery += " AND   TRN.D_E_L_E_T_ <> '*' "
				cQuery := ChangeQuery(cQuery)
				dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)
				dbGoTop()
				If !Eof()
					dbSelectArea("TRN")
					dbGoTo((cAliasQry)->REGISTRO)
					RecLock("TRN",.f.)
					dbDelete()
					MsUnlock("TRN")
				Endif
				(cAliasQry)->(dbCloseArea())
			EndIf
		Next nx
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} AGR545TRO
Grava tabela TRO
@author Ricardo Dal Ponte
@since 09/04/07
@version undefined
@param nOpcx, numeric
@type function
/*/
//---------------------------------------------------------------------
Function AGR545TRO(nOpcx)

	Local y, nx, ny, aSeqVei := {}

	If nOpcx == 5
		dbSelectArea("TRO")
		dbSetOrder(01)
		dbSeek(xFilial("TRO")+M->TRH_NUMSIN)
		While TRO->TRO_FILIAL == xFilial("TRO") .AND. TRO->TRO_NUMSIN == M->TRH_NUMSIN
			RecLock("TRO",.f.)
			dbDelete()
			TRO->(MsUnlock())
			dbSkip()
		End
	Endif

	If Altera .OR. Inclui
		For nx = 1 TO Len(aSVCOLS[5])
			If (!aSVCOLS[5][nx][Len(aSVCOLS[5][nx])])
				If (!Empty(aSVCOLS[5][nx][nTROPLACA]))
					aSeqVei := A545TROSEQ(nx)
					dbSelectArea("TRO")
					If !aSeqVei[1]
						RecLock("TRO",.T.)
						TRO->TRO_FILIAL := xFilial("TRO")
						TRO->TRO_NUMSIN := M->TRH_NUMSIN
						TRO->TRO_SEQVEI := aSeqVei[2]

						dbSelectArea("TRO")
						For ny := 1 To FCOUNT()
							xx := aSCAN(aSVHEADER[5],{|x| AllTrim(x[2]) == AllTrim(FIELDNAME(ny))})
							If xx > 0
								vv   := "TRO->"+FIELDNAME(ny)
								&vv. := aSVCOLS[5][nx][xx]
							EndIf
						Next ny
						TRO->(MsUnlock())
					Endif
				Endif
			Else
				cAliasQry := GetNextAlias()
				cQuery := " SELECT TRO.R_E_C_N_O_ AS REGISTRO FROM " + RetSqlName("TRO") + " TRO "
				cQuery += " WHERE TRO.TRO_NUMSIN = '"+M->TRH_NUMSIN+"'"
				cQuery += " AND   TRO.TRO_PLACA  = '"+aSVCOLS[5][nx][nTROPLACA]+"'"
				cQuery += " AND   TRO.TRO_TIPVEI = '"+aSVCOLS[5][nx][nTROTIPVEI]+"'"
				cQuery += " AND   TRO.TRO_DESVEI = '"+aSVCOLS[5][nx][nTRODESVEI]+"'"
				cQuery += " AND   TRO.TRO_NOMPR  = '"+aSVCOLS[5][nx][nTRONOMPR]+"'"
				cQuery += " AND   TRO.D_E_L_E_T_ <> '*' "
				cQuery := ChangeQuery(cQuery)
				dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)
				dbGoTop()
				If !Eof()
					dbSelectArea("TRO")
					dbGoTo((cAliasQry)->REGISTRO)
					RecLock("TRO",.f.)
					dbDelete()
					MsUnlock("TRO")
				Endif
				(cAliasQry)->(dbCloseArea())
			EndIf
		Next nx
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} AGR545TRM
Grava tabela TRM
@author Ricardo Dal Ponte
@since  09/04/07
@version undefined
@param nOpcx, numeric
@type function
/*/
//---------------------------------------------------------------------
Function AGR545TRM(nOpcx)

	Local y, nx, ny, aSeqVit := {}

	If nOpcx == 5
		dbSelectArea("TRM")
		dbSetOrder(01)
		dbSeek(xFilial("TRM")+M->TRH_NUMSIN)
		While TRM->TRM_FILIAL == xFilial("TRM") .AND. TRM->TRM_NUMSIN == M->TRH_NUMSIN
			RecLock("TRM",.f.)
			dbDelete()
			TRM->(MsUnlock())
			dbSkip()
		End
	Endif

	If Altera .OR. Inclui
		For nx = 1 TO Len(aSVCOLS[6])
			If (!aSVCOLS[6][nx][Len(aSVCOLS[6][nx])])
				If (!Empty(aSVCOLS[6][nx][nTRMINDFUN]))
					aSeqVit := A545TRMSEQ(nx)
					dbSelectArea("TRM")
					If !aSeqVit[1]
						RecLock("TRM",.T.)
						TRM->TRM_FILIAL := xFilial("TRM")
						TRM->TRM_NUMSIN := M->TRH_NUMSIN
						TRM->TRM_SEQVIT := aSeqVit[2]

						dbSelectArea("TRM")
						For ny := 1 To FCOUNT()
							xx := aSCAN(aSVHEADER[6],{|x| AllTrim(x[2]) == AllTrim(FIELDNAME(ny))})
							If xx > 0
								vv   := "TRM->"+FIELDNAME(ny)
								&vv. := aSVCOLS[6][nx][xx]
							EndIf
						Next ny
						TRM->(MsUnlock())
					Endif
				Endif
			Else
				cAliasQry := GetNextAlias()
				cQuery := " SELECT TRM.R_E_C_N_O_ AS REGISTRO FROM " + RetSqlName("TRM") + " TRM "
				cQuery += " WHERE TRM.TRM_NUMSIN = '"+M->TRH_NUMSIN+"'"
				cQuery += " AND   TRM.TRM_INDFUN = '"+aSVCOLS[6][nx][nTRMINDFUN]+"'"
				cQuery += " AND   TRM.TRM_MATVIT = '"+aSVCOLS[6][nx][nTRMMATVIT]+"'"
				cQuery += " AND   TRM.TRM_NOMVIT = '"+aSVCOLS[6][nx][nTRMNOMVIT]+"'"
				cQuery += " AND   TRM.TRM_LESOES = '"+aSVCOLS[6][nx][nTRMLESOES]+"'"
				cQuery += " AND   TRM.D_E_L_E_T_ <> '*' "
				cQuery := ChangeQuery(cQuery)
				dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)
				dbGoTop()
				If !Eof()
					dbSelectArea("TRM")
					dbGoTo((cAliasQry)->REGISTRO)
					RecLock("TRM",.f.)
					dbDelete()
					MsUnlock("TRM")
				Endif
				(cAliasQry)->(dbCloseArea())
			EndIf
		Next nx
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} AGR545TRJ
Grava tabela TRJ

@author Ricardo Dal Ponte
@since 09/04/07
@version MP12

@param nOpcx, numeric

@type function

@return Vazio.
/*/
//---------------------------------------------------------------------
Function AGR545TRJ(nOpcx)

	Local y, nx, ny, aSeqVit := {}

	If nOpcx == 5
		dbSelectArea("TRJ")
		dbSetOrder(01)
		dbSeek(xFilial("TRJ")+M->TRH_NUMSIN)
		While TRJ->TRJ_FILIAL == xFilial("TRJ") .AND. TRJ->TRJ_NUMSIN == M->TRH_NUMSIN
			RecLock("TRJ",.f.)
			dbDelete()
			TRJ->(MsUnlock())
			dbSkip()
		End
	Endif

	If Altera .OR. Inclui
		For nx = 1 TO Len(aSVCOLS[7])
			If (!aSVCOLS[7,nx,Len(aSVCOLS[7,nx])])
				If !Empty( StrTran( aSVCOLS[ 7, nx, nTRJNUMINQ ], '/', '')  )
					DbSelectArea("TRJ")
					DbSetOrder(1)
					If dbSeek(xFilial("TRJ")+M->TRH_NUMSIN+aSvCols[7,nx,nTRJNUMINQ])
						RecLock("TRJ",.F.)
					Else
						If nx <= Len(aColsInc) .And. aSVCOLS[7,nx,nTRJRECNO] == aColsInc[nX,nTRJRECNO] .And. aColsInc[nX,nTRJRECNO] <> 0  //Caso seja o mesmo registro, realiza a alteração.
							If dbSeek(xFilial("TRJ")+M->TRH_NUMSIN+aColsInc[nx,nTRJNUMINQ])
								RecLock("TRJ",.F.)
							EndIf
						Else
							RecLock("TRJ",.T.)
						EndIf
					EndIf

					TRJ->TRJ_FILIAL := xFilial("TRJ")
					TRJ->TRJ_NUMSIN := M->TRH_NUMSIN

					DbSelectArea("TRJ")
					For ny := 1 To FCOUNT()
						xx := aSCAN(aSVHEADER[7],{|x| AllTrim(x[2]) == AllTrim(FIELDNAME(ny))})
						If xx > 0 .And. !Empty(aSVCols[7,nx,xx])
							vv   := "TRJ->"+FIELDNAME(ny)
							&vv. := aSVCOLS[7,nx,xx]
						Endif
					Next ny

					TRJ->(MsUnlock())
				Endif
			Else
				cAliasQry := GetNextAlias()
				cQuery := " SELECT TRJ.R_E_C_N_O_ AS REGISTRO FROM " + RetSqlName("TRJ") + " TRJ "
				cQuery += " WHERE TRJ.TRJ_NUMSIN = '"+M->TRH_NUMSIN+"'"
				cQuery += " AND   TRJ.TRJ_NUMINQ = '"+aSVCOLS[7][nx][nTRJNUMINQ]+"'"
				cQuery += " AND   TRJ.D_E_L_E_T_ <> '*' "
				cQuery := ChangeQuery(cQuery)
				dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)
				dbGoTop()
				If !Eof()
					dbSelectArea("TRJ")
					dbGoTo((cAliasQry)->REGISTRO)
					RecLock("TRJ",.f.)
					dbDelete()
					MsUnlock("TRJ")
				Endif
				(cAliasQry)->(dbCloseArea())
			EndIf
		Next nx
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} AGR545TU4
Grava tabela TU4
@author RAFAEL REINERT
@since 15/04/11
@version undefined
@param nOpcx, numeric
@type function
/*/
//---------------------------------------------------------------------
Function AGR545TU4(nOpcx)

	Local nI, y, nx, ny, aSeqAni := {}

	If nOpcx == 5
		dbSelectArea("TU4")
		dbSetOrder(01)
		dbSeek(xFilial("TU4")+M->TRH_NUMSIN)
		While TRL->TRL_FILIAL == xFilial("TU4") .AND. TU4->TU4_NUMSIN == M->TRH_NUMSIN
			RecLock("TU4",.f.)
			dbDelete()
			TU4->(MsUnlock())
			dbSkip()
		End
	Endif

	If Altera .OR. Inclui

		cAliasQry := GetNextAlias()
		cQuery := " SELECT TU4.TU4_SEQANI, TU4.TU4_NOMPRO, TU4.TU4_UFPRO, TU4.TU4_TIPANI, TU4.TU4_QTDANI, TU4.TU4_VALANI, TU4.R_E_C_N_O_ AS REGISTRO  "
		cQuery += " FROM " + RetSqlName("TU4") + " TU4"
		cQuery += " WHERE TU4.TU4_NUMSIN = '"+M->TRH_NUMSIN+"'"
		cQuery += " AND   TU4.D_E_L_E_T_ <> '*' "
		cQuery := ChangeQuery(cQuery)
		dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)
		DbGoTop()
		If !Eof()
			While (cAliasQry)->(!Eof())

				nPos := aSCan(aSVCOLS[8],{|x| x[nTU4NOMPRO] == (cAliasQry)->TU4_NOMPRO .and. x[nTU4TIPANI] == (cAliasQry)->TU4_TIPANI })
				If nPos > 0
					dbSelectArea("TU4")
					dbGoTo((cAliasQry)->REGISTRO)
					RecLock("TU4",.F.)
					dbSelectArea("TU4")
					For ny := 1 To FCOUNT()
						If !(FIELDNAME(ny) $ "TU4_FILIAL/TU4_NUMSIN/TU4_SEQANI")
							xx := aSCAN(aSVHEADER[8],{|x| AllTrim(x[2]) == AllTrim(FIELDNAME(ny))})
							If xx > 0
								vv   := "TU4->"+FIELDNAME(ny)
								&vv. := aSVCOLS[8][nPos][xx]
							EndIf
						EndIf
					Next ny
					TU4->(MsUnlock())
				Else
					dbSelectArea("TU4")
					dbGoTo((cAliasQry)->REGISTRO)
					RecLock("TU4",.F.)
					dbDelete()
					msUnlock("TU4")
				EndIf
				(cAliasQry)->(dbSkip())
			End
			(cAliasQry)->(dbCloseArea())
		Endif


		For nx = 1 TO Len(aSVCOLS[8])
			If (!aSVCOLS[8][nx][Len(aSVCOLS[8][nx])])
				If (!Empty(aSVCOLS[8][nx][1]))
					aSeqAni := A545TU4SEQ(nx)
					dbSelectArea("TU4")
					If !aSeqAni[1]
						RecLock("TU4",.T.)
						TU4->TU4_FILIAL := xFilial("TU4")
						TU4->TU4_NUMSIN := M->TRH_NUMSIN
						TU4->TU4_SEQANI := aSeqAni[2]

						dbSelectArea("TU4")
						For ny := 1 To FCOUNT()
							xx := aSCAN(aSVHEADER[8],{|x| AllTrim(x[2]) == AllTrim(FIELDNAME(ny))})
							If xx > 0
								vv   := "TU4->"+FIELDNAME(ny)
								&vv. := aSVCOLS[8][nx][xx]
							EndIf
						Next ny
						TU4->(MsUnlock())
					Endif
				Endif
			Else
				cAliasQry := GetNextAlias()
				cQuery := " SELECT TU4.R_E_C_N_O_ AS REGISTRO FROM " + RetSqlName("TU4") + " TU4 "
				cQuery += " WHERE TU4.TU4_NUMSIN = '"+M->TRH_NUMSIN+"'"
				cQuery += " AND   TU4.TU4_NOMPRO = '"+aSVCOLS[8][nx][nTU4NOMPRO]+"'"
				cQuery += " AND   TU4.TU4_TIPANI = '"+aSVCOLS[8][nx][nTU4TIPANI]+"'"
				cQuery += " AND   TU4.D_E_L_E_T_ <> '*' "
				cQuery := ChangeQuery(cQuery)
				dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)
				dbGoTop()
				If !Eof()
					dbSelectArea("TU4")
					dbGoTo((cAliasQry)->REGISTRO)
					RecLock("TU4",.f.)
					dbDelete()
					MsUnlock("TU4")
				Endif
				(cAliasQry)->(dbCloseArea())
			EndIf
		Next nx
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545TRK

@author Ricardo Dal Ponte
@since 11/04/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545TRK()

	Local cCODCAR := ""
	dbSelectArea("TRK")
	cCODCAR := Space(Len(TRK->TRK_CODCAR))

	cAliasQry := GetNextAlias()
	cQuery := " SELECT DAK.DAK_COD, DAK.DAK_VALOR"
	cQuery += " FROM " + RetSqlName("TRH") + " TRH," + RetSqlName("ST9") + " ST9," + RetSqlName("DAK") + " DAK"
	cQuery += " WHERE TRH.TRH_NUMSIN = '"+M->TRH_NUMSIN+"'"
	cQuery += " AND   TRH.TRH_FILIAL = ST9.T9_FILIAL "
	cQuery += " AND   TRH.TRH_FILIAL = DAK.DAK_FILIAL "
	cQuery += " AND   TRH.TRH_CODBEM = ST9.T9_CODBEM "
	cQuery += " AND   ST9.T9_CODTMS  = DAK.DAK_CAMINH "
	cQuery += " AND   DAK.D_E_L_E_T_ <> '*' "
	cQuery += " AND   TRH.D_E_L_E_T_ <> '*' "
	cQuery += " AND   ST9.D_E_L_E_T_ <> '*' "
	cQuery += " ORDER BY DAK.DAK_DATA, DAK.DAK_HORA "
	cQuery := ChangeQuery(cQuery)
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)

	dbGoTop()
	If Eof()
		cCODCAR := " "
	Else
		While !Eof()
			cCODCAR := (cAliasQry)->DAK_COD
			dbSkip()
		End
	Endif

	(cALIASQRY)->(dbCloseArea())

Return cCODCAR

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545DAN
Validacao da placa
@author Marcos Wagner Junior
@since 26/07/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545DAN()

	If aCols[n][nTRLDANOS] = '2'
		aCols[n][nTRLVALPRE] := 0
	Endif

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT545PLACA
Validacao da placa
@author Marcos Wagner Junior
@since 26/07/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNT545PLACA()

	Local lRETVH := .T.
	Local lAtivo := .F.

	DbSelectArea("ST9")
	DbSetOrder(14)
	DbSeek(M->TRH_PLACA)

	cFilBem := ST9->T9_FILIAL

	If M->TRH_PLACA <> ST9->T9_PLACA
		HELP(" ",1,STR0012,,STR0024,3,1) //"ATENÇÃO"###"Placa Invalida."
		lRETVH := .F.
	EndIf

	If ST9->T9_SITBEM $ 'IT'
		While !Eof() .and. ST9->T9_PLACA == M->TRH_PLACA
			If ST9->T9_SITBEM = 'A'
				cFilBem := ST9->T9_FILIAL
				lATIVO := .T.
			EndIf
			DbSkip()
		End
	Else
		lATIVO := .T.
	EndIf
	If !lATIVO
		HELP(" ",1,STR0012,,STR0025,3,1) //"ATENÇÃO" //"Veículo Inativo/Transferido!"
		lRETVH := .F.
	EndIf

Return lRETVH

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545DT
Nao permite a data de envio ser maior que a data de receb.
@author Marcos Wagner Junior
@since 15/02/07
@version undefined
@param nopc, numeric
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545DT(nopc)

	Local dDataEnv := IIf(nopc==1,M->TRJ_DTENJU,aCOLS[n][nTRJENVJUR])
	Local dDataRec := IIf(nopc==2,M->TRJ_DTREJU,aCOLS[n][nTRJRECJUR])

	If !Empty(dDataEnv) .AND. !Empty(dDataRec)
		If dDataRec < dDataEnv
			MsgStop(STR0026,STR0012)  //"Data Envio Manutenção terá de ser menor que Data Recebimento Manutenção!"###"Atenção"
			Return .f.
		Endif
		aCOLS[n][nTRJTEMJUR] := dDataRec - dDataEnv
	Endif


Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545DTF
Nao permite a data de envio ser maior que a data de receb.
@author Marcos Wagner Junior
@since 15/02/07
@version undefined
@param nopc, numeric
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545DTF(nopc)

	Local dDataRec := IIf(nopc==1,M->TRJ_DTREJU,aCOLS[n][nTRJRECJUR])
	Local dDataFPr := IIf(nopc==2,M->TRJ_DTFIPR,aCOLS[n][nTRJDTFIPR])

	If !Empty(dDataRec) .AND. !Empty(dDataFPr)
		If dDataRec > dDataFPr
			MsgStop(STR0027,STR0012)  //"Data Final não pode ser menor que Data de Recebimento!"###"Atenção"
			Return .f.
		Endif
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545CAU
Busca descricao da Causa do Acidente na SX5
@author Marcos Wagner Junior
@since 15/02/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545CAU()

	If !Inclui
		If !Empty(TRJ->TRJ_CAUJUR)
			Return NGSEEK("SX5",'CX'+TRJ->TRJ_CAUJUR,1,"SubStr(X5_DESCRI,1,30)")
		Else
			Return ''
		Endif
	Else
		Return Space(Len(TRJ->TRJ_CAUJUR))
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545DIS
Busca descricao da Causa do Acidente na SX5
@author Marcos Wagner Junior
@since 15/02/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545DIS()

	If !ExistCpo("SX5","CX"+M->TRJ_CAUJUR)
		Return .f.
	EndIf
	aCols[n][nTRJDESCAU] := NGSEEK("SX5","CX"+M->TRJ_CAUJUR,1,"SubStr(X5_DESCRI,1,30)")

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG545Fin
Busca descricao da Causa do Acidente na SX5
@author Marcos Wagner Junior
@since 15/02/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG545Fin

	If TRH->TRH_FLGCOM = '3'
		MsgStop(STR0022) //"Sinistro já finalizado"
		Return .f.
	EndIf

	If MsgYesNo(STR0028,STR0012) //"Deseja finalizar o sinistro?"###"Atenção"
		DbSelectArea("TRH")
		DbSetOrder(1)
		RecLock("TRH",.f.)
		TRH->TRH_FLGCOM := '3'
		MsUnLock("TRH")
	EndIf

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} NG545LVE
Busca descricao da Causa do Acidente na SX5
@author Marcos Wagner Junior
@since 15/02/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function NG545LVE()
	Local nx
	Local nQtd := 0
	Local cPlaca := ''
	Local nTROPLACA := 0

	nTROPLACA    := aScan( aHeader, { |x| Trim( Upper(x[2]) ) == 'TRO_PLACA'})

	If Empty(aCols[1][1])
		Return .t.
	Endif

	cPlaca := aCols[1][nTROPLACA]

	For nx:=1 To Len(aCols)
		If !aCols[nx][Len(aCols[nx])]
			If Empty(aCols[nx][1])
				Help(" ",1,"OBRIGAT")
				Return .T.
			Endif
		Endif
	Next

	If nTROPLACA > 0
		aEval( aCols, { |x| nQtd += iif( ! x[Len(aHeader)+1] .And. x[nTROPLACA] == cPlaca, 1, 0 ) } )
	EndIf

	If nQtd > 1
		Help(" ",1,STR0012,,STR0030,3,1) //"Atenção"##"Campo Placa Duplicado"
		Return .f.
	EndIf

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGENTR545
Atualiza aTela e aGets quando e focada a enchoice
@author Marcos Wagner Junior
@since 12/01/06
@version undefined
@param cALIAS, characters, descricao
@type function
/*/
//---------------------------------------------------------------------
Function NGENTR545(cALIAS)

	If cALIAS = "TRH"
		aSVATELA := aCLONE(aSVATELA1)
		aSVAGETS := aCLONE(aSVAGETS1)

		aTELA := aCLONE(aSVATELA1)
		aGETS := aCLONE(aSVAGETS1)
	Elseif cAlias = "TRV"
		aSVATELA := aCLONE(aSVATELA2)
		aSVAGETS := aCLONE(aSVAGETS2)

		aTELA := aCLONE(aSVATELA2)
		aGETS := aCLONE(aSVAGETS2)
	EndIf

	DbSelectArea(cALIAS)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545LIM
Limpa o campo Desc. Danos
@author Marcos Wagner Junior
@since 16/06/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545LIM()

	If M->TRH_FLGDAN = '2'
		M->TRH_DANOS2 = Space(Len(TRH->TRH_DANOS2))
	Endif

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545PER
Calcula o campo % do TRO
@author Marcos Wagner Junior
@since 20/06/07
@version undefined
@param nopc, numeric
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545PER(nopc)

	Local nPerPrej := IIf(nopc==1,M->TRO_VALPRE,aCOLS[n][nTROVALPRE])
	Local nPerPago := IIf(nopc==2,M->TRO_VALTER,aCOLS[n][nTROVALPAG])

	If !Empty(nPerPago) .AND. !Empty(nPerPrej)
		aCOLS[n][nTROPERCEN] := 100 - ((nPerPago*100)/nPerPrej)
	Endif

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545MAN
Validacao de Datas
@author Marcos Wagner Junior
@since 20/06/07
@version undefined
@param nopc, numeric
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545MAN(nopc)

	Local dDataEnv := IIf(nopc==1,M->TRJ_DTENMA,aCOLS[n][nTRJENVMAN])
	Local dDataRec := IIf(nopc==2,M->TRJ_DTREMA,aCOLS[n][nTRJRECMAN])

	If !Empty(dDataEnv) .AND. !Empty(dDataRec)
		If dDataRec < dDataEnv
			MsgStop(STR0031,STR0012)  //"Data Envio Manutenção terá de ser menor que Data Recebimento Manutenção!"###"Atenção"
			Return .f.
		Endif
		aCOLS[n][nTRJTEMMAN] := dDataRec - dDataEnv
	Endif

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545DFP
Calcula o Tempo Total do Processo
@author Marcos Wagner Junior
@since 20/06/07
@version undefined

@type function
/*/
//---------------------------------------------------------------------
Function MNTA545DFP()

	If !Empty(M->TRH_DTACID) .AND. !Empty(M->TRJ_DTFIPR)
		aCols[n][nTRJTEMTOT] := M->TRJ_DTFIPR - M->TRH_DTACID
	Endif

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGSAIEN545
Guarda aTela e aGets na saida do foco na enchoice
@author Marcos Wagner Junior
@since 20/06/07
@version undefined
@param cALIAS, characters
@param x
@type function
/*/
//---------------------------------------------------------------------
Function NGSAIEN545(cALIAS,x)

	Local lRETURN := .T.

	If nOPCAO == 3 .OR. nOPCAO == 4
		Do Case
			Case oFolder:nOption = 1
				If !MNTA545GUI() .OR. !MNTA545VLD()
					Return .f.
				Endif
			Case oFolder:nOption == 3
				NGSAIGET(1)
			Case oFolder:nOption == 4
				NGSAIGET(2)
			Case oFolder:nOption == 5
				NGSAIGET(3)
			Case oFolder:nOption == 6
				NGSAIGET(4)
			Case oFolder:nOption == 7
				NGSAIGET(5)
			Case oFolder:nOption == 8
				NGSAIGET(6)
			Case oFolder:nOption == 9
				NGSAIGET(7)
			Case oFolder:nOption == 10
				NGSAIGET(8)
		EndCase
	Endif
	dbSelectArea(cAlias)

Return(lRETURN)

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545GUI
Consistencia do Valor Guincho
@author Marcos Wagner Junior
@since 20/06/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545GUI()

	If Inclui .Or. Altera
		If Empty(M->TRH_VALGUI)	.AND. M->TRH_GUINCH = '1'
			Msgstop(STR0032,STR0012)  //"O Campo Val. Guincho deverá ser preenchido!"###"Atenção"
			Return .f.
		Endif
	Endif

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545PE
Pesquisa especifica
@author Rafael Diogo Richter
@since 24/07/2007
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545PE()

	Local nInd := 0
	local oDlgPesq, oOrdem, oChave, oBtOk, oBtCan, oBtPar
	Local cOrdem
	Local cChave	:= Space(255)
	Local aOrdens	:= {}
	Local nOrdem := 1
	Local nOpca
	Local cNumSin := ''
	Local aArea := GetArea()

	aAdd( aOrdens,STR0038)//"Inquérito"

	Define msDialog oDlgPesq Title STR0001 From 00,00 To 100,500 pixel //"Pesquisar"

	@ 005, 005 combobox oOrdem var cOrdem items aOrdens size 210,08 PIXEL OF oDlgPesq ON CHANGE nOrdem := oOrdem:nAt
	@ 020, 005 msget oChave var cChave size 210,08 of oDlgPesq pixel

	define sButton oBtOk  from 05,218 type 1 action (nOpcA := 1, oDlgPesq:End()) enable of oDlgPesq pixel
	define sButton oBtCan from 20,218 type 2 action (nOpcA := 0, oDlgPesq:End()) enable of oDlgPesq pixel
	define sButton oBtPar from 35,218 type 5 when .F. of oDlgPesq pixel

	Activate MsDialog oDlgPesq Center

	If nOpca == 1
		If nOrdem == 1
			cAliasQry := GetNextAlias()
			cQuery := " SELECT TRJ.TRJ_FILIAL, TRJ.TRJ_NUMSIN "
			cQuery += " FROM " + RetSqlName("TRJ") + " TRJ"
			cQuery += " WHERE TRJ.TRJ_NUMINQ LIKE '%"+AllTrim(cChave)+"%' "
			cQuery += " AND   TRJ.D_E_L_E_T_ <> '*' "
			cQuery += " ORDER BY TRJ.TRJ_NUMINQ "
			cQuery := ChangeQuery(cQuery)
			dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)
			dbGoTop()
			If !Eof()
				While !Eof()
					cNumSin := (cAliasQry)->TRJ_FILIAL+(cAliasQry)->TRJ_NUMSIN
					dbSkip()
				End
			Endif
			(cAliasQry)->(dbCloseArea())
			RestArea(aArea)
		Endif
		If !Empty(cNumSin)
			DbSelectArea("TRH")
			DbSetOrder(1)
			DbSeek(cNumSin)
		Else
			Msgstop(STR0035,STR0012)  //"Inquérito não existente!"###"Atenção"
			Return .f.
		Endif
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545INQ
Verifica se o Inquerito digitado já existe
@author Marcos Wagner Junior
@since 27/07/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545INQ()

	Local aArea := GetArea()

	cAliasQry := GetNextAlias()
	cQuery := " SELECT *"
	cQuery += " FROM " + RetSqlName("TRJ") + " TRJ"
	cQuery += " WHERE TRJ.TRJ_NUMINQ = '"+M->TRJ_NUMINQ+"'"
	cQuery += " AND   TRJ.D_E_L_E_T_ <> '*' "
	cQuery := ChangeQuery(cQuery)
	dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)
	dbGoTop()
	If !Eof()
		Msgstop(STR0036,STR0012)  //"Inquérito já existente!"###"Atenção"
		(cAliasQry)->(dbCloseArea())
		RestArea(aArea)
		Return .f.
	Endif

	(cAliasQry)->(dbCloseArea())
	RestArea(aArea)

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545VLD
Consistencia do Valor Danos
@author Marcos Wagner Junior
@since 31/07/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545VLD()

	/*If Inclui .Or. Altera
	If Empty(M->TRH_VALDAN)	.AND. M->TRH_FLGDAN = '1'
	Msgstop(STR0037,STR0012)  //"O Campo Valor Danos deverá ser preenchido!"###"Atenção"
	Return .f.
	Endif
	Endif*/

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545CUL
Busca descricao da Culpa Apurada na SX5
@author Marcos Wagner Junior
@since 31/07/07
@version undefined

@type function
/*/
//---------------------------------------------------------------------
Function MNTA545CUL()

	If !ExistCpo("SX5","KA"+M->TRJ_CULAPU)
		Return .f.
	EndIf
	aCols[n][nTRJDESCUL] := NGSEEK("SX5","KA"+M->TRJ_CULAPU,1,"SubStr(X5_DESCRI,1,40)")

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545DEC
Busca descricao da Culpa Apurada na SX5
@author Marcos Wagner Junior
@since 31/07/07
@version undefined

@type function
/*/
//---------------------------------------------------------------------
Function MNTA545DEC()

	If !Inclui
		If !Empty(TRJ->TRJ_CULAPU)
			Return NGSEEK("SX5",'KA'+TRJ->TRJ_CULAPU,1,"SubStr(X5_DESCRI,1,40)")
		Else
			Return ''
		Endif
	Else
		Return Space(Len(TRJ->TRJ_CULAPU))
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545APD
Chama o cadastro de APD
@author Marcos Wagner Junior
@since 02/10/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545APD()

	Local lINCLUIOLD := INCLUI
	Local lALTERAOLD := ALTERA
	Local aOldArea := GetArea()

	If M->TRV_ABEAPD = '1'
		INCLUI := .T.
		ALTERA := .F.
		nRet := NGCAD01("TRS",Recno(),3)
		If nRet = 1
			M->TRV_NUMAPD := TRS->TRS_NUMAPD
			M->TRV_STAPD  := TRS->TRS_STAPD
			MNTA970REL()
		Else
			M->TRV_ABEAPD := '2'
		Endif
	Endif

	INCLUI := lINCLUIOLD
	ALTERA := lALTERAOLD

	RestArea(aOldArea)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545OBR
Chama o cadastro de APD
@author Marcos Wagner Junior
@since 05/11/07
@version undefined

@type function
/*/
//---------------------------------------------------------------------
Function MNTA545OBR()

	/*If M->TRH_EVENTO = '1'
	If Empty(M->TRH_VELOC)
	MsgStop(STR0040+OemtoAnsi(NGSEEKDIC("SX3","TRH_VELOC",2,"X3_TITULO"))+STR0041,STR0012)//"O Campo "###" deverá ser preenchido!"###"Atenção"
	Return .f.
	Endif
	If Empty(M->TRH_KMACID)
	MsgStop(STR0040+OemtoAnsi(NGSEEKDIC("SX3","TRH_KMACID",2,"X3_TITULO"))+STR0041,STR0012)//"O Campo "###" deverá ser preenchido!"###"Atenção"
	Return .f.
	Endif
	Endif*/

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545INA
Inativa o Bem e muda o Status para Veiculo Roubado
@author Marcos Wagner Junior
@since 05/11/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545INA()

	Local aOldArea := GetArea()
	Local oDlgBE, oPanel
	Local oTmpTbl1

	Private cTRBE080 := GetNextAlias() //Alias Tab. Temp.
	Private aDBFBE   := {}
	Private cBEBem
	Private cBEDtBaixa
	Private cBEStatus
	Private cBECausa
	Private cBEMotivo
	Private dDATAMOV2
	Private nCONTADOR, nCONTADOR2
	Private cHORCON1, cHORCON2
	Private TIPOACOM, TIPOACOM2
	Private nOpcaBE  := .f.
	Private dDtBaixa := dDataBase, cMotBaixa := Space(04), cDesMot

	If M->TRH_VEIROU == '1' .AND. M->TRH_EVENTO == '2' .AND. M->TRH_RECVEL == '2' .AND. (Inclui .Or. Altera) .AND.;
	NGSEEK("ST9",M->TRH_CODBEM,1,"T9_SITBEM") == "A"

		If NGIFDBSEEK('STC',M->TRH_CODBEM,1)
			lRet := APMSGYESNO(STR0049+CHR(13)+STR0050+CHR(13)+STR0051,STR0052) //"O bem é pai de uma estrutura. Dessa forma é necessário que"#
			//"seja realizada a inativação dos filhos dessa estrutura."#"Deseja realizar a inativação dos filhos?"#"Baixa de Estrutura"
			If lRet
				Aadd(aDBFBE,{"OK"     , "C" ,02, 0 })
				Aadd(aDBFBE,{"CODBEM" , "C" ,16, 0 })
				Aadd(aDBFBE,{"NOMBEM" , "C" ,40, 0 })
				Aadd(aDBFBE,{"STATUS" , "C" ,02, 0 })
				Aadd(aDBFBE,{"DESTAT" , "C" ,30, 0 })
				Aadd(aDBFBE,{"CCUSTO" , "C" ,Len(SI3->I3_CUSTO), 0 })
				Aadd(aDBFBE,{"DESCUS" , "C" ,40, 0 })
				Aadd(aDBFBE,{"CTRABA" , "C" ,06, 0 })
				Aadd(aDBFBE,{"DESCTR" , "C" ,30, 0 })
				Aadd(aDBFBE,{"CODESTO", "C" ,15, 0 })
				Aadd(aDBFBE,{"ALMOXA" , "C" ,02, 0 })

				//Instancia classe FWTemporaryTable
				oTmpTbl1:= FWTemporaryTable():New( cTRBE080, aDBFBE )
				//Adiciona os Indices
				oTmpTbl1:AddIndex( "Ind01" , {"CODBEM"} )
				//Cria a tabela temporaria
				oTmpTbl1:Create()

				aArea := GetArea()
				dbSelectArea("ST9")
				dbSetOrder(1)
				If dbSeek(xFilial("ST9") + M->TRH_CODBEM )
					lRet  := MNTA080INA()
				Else
					MsgStop(STR0090) //"Bem não cadastrado."
					lRet := .F.
				EndIf
				oTmpTbl1:Delete()
			EndIf
			If lRet
				Msgstop(STR0056,STR0012) //"A inativação dos Bens não foi realizada!"###"Atenção"
			Endif
		Else
			Define MsDialog ODlgBE Title STR0052 From 6.5,0 To 17,72 Of oMainWnd //"Baixa de Estrutura"

			oDlgBE:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.

			oPanel := TPanel():New(0, 0, Nil, oDlg, Nil, .T., .F., Nil, Nil, 0, 0, .T., .F. )
			oPanel:Align := CONTROL_ALIGN_ALLCLIENT

			@ 0.5,01 Say STR0075 Color CLR_HBLUE Of oPanel //"Data Baixa"
			@ 0.5,05 MsGet dDtBaixa PICTURE '99/99/99';
			Valid NaoVazio() .And. NGCPDIAATU(dDtBaixa,"<=",.t.,.t.,.t.) SIZE 35,7 Of oPanel HASBUTTON

			@ 01.5,01 Say STR0076 Color CLR_HBLUE Of oPanel //"Motivo"
			@ 01.5,05 MsGet cMotBaixa F3 "TPJ" Valid MNTA545MOT () SIZE 35,7 Of oPanel HASBUTTON
			@ 01.5,10 MsGet cDesMot When .F. Size 195,7 Of oPanel

			Activate MsDialog ODlgBE On Init EnchoiceBar(ODlgBE,{||If(M545Baixa(),ODlgBE:End(),)},;
			{||If(M545CnclBx(),ODlgBE:End(),)}) Centered
			If nOpcaBE
				DbSelectArea("ST9")
				DbSetOrder(14)
				If DbSeek(M->TRH_PLACA+'A')
					RecLock("ST9",.f.)
					ST9->T9_SITBEM  := 'I'
					ST9->T9_STATUS  := AllTrim(GetMv("MV_NGSTARO"))
					ST9->T9_DTBAIXA := dDtBaixa
					ST9->T9_MTBAIXA := cMotBaixa
					MsUnLock("ST9")
				Endif
			Endif
		Endif
	Endif

	If M->TRH_VEIROU == '1' .AND. M->TRH_EVENTO == '2' .AND. M->TRH_RECVEL == '1' .AND. Altera .AND. NGSEEK("ST9",M->TRH_CODBEM,1,"T9_SITBEM") == "I"
		If NGIFDBSEEK('ST9',M->TRH_CODBEM,1)
			RecLock("ST9",.F.)
			ST9->T9_DTBAIXA := STOD("  /  /  ")
			ST9->T9_MTBAIXA := ' '
			ST9->T9_SITBEM := "A"
			ST9->T9_SITMAN := "A"
			MsUnLock("ST9")
		Endif
		If NGIFDBSEEK('STF',M->TRH_CODBEM,1)
			While !Eof() .And. Xfilial("STF") = stf->tf_filial .And.;
			stf->tf_codbem = M->TRH_CODBEM
				RecLock("STF",.F.)
				stf->tf_ativo := "S"
				MsUnlock("STF")
				Dbskip()
			End
		EndIf
		Msgstop(STR0057,STR0012) //"Deverá ser realizada uma inspeção no veículo e uma análise técnica para os pneus para possível reaproveitamento dos mesmos!"###"Atenção"
	Endif

	RestArea(aOldArea)

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT545ZERA
Zera campos relacionados com Funcionario, TRM_INDFUN = 2
@author Marcos Wagner Junior
@since 06/11/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNT545ZERA()

	If M->TRM_INDFUN = '2'
		aCols[n][nTRMMATVIT] := Space(Len(TRM->TRM_MATVIT))
		aCols[n][nTRMNOMVIT] := Space(Len(TRM->TRM_NOMVIT))
		aCols[n][nTRMDESFUN] := Space(Len(TRM->TRM_DESFUN))
	Elseif M->TRM_INDFUN = '1'
		aCols[n][nTRMNOMVIT] := Space(Len(TRM->TRM_NOMVIT))
		aCols[n][nTRMDESFUN] := Space(Len(TRM->TRM_DESFUN))
	Endif

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT545FUNC
Zera campos relacionados com Funcionario, TRM_INDFUN = 2
@author Marcos Wagner Junior
@since 06/11/07
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNT545FUNC()

	cCodFunc := NGSEEK("SRA",M->TRM_MATVIT,1,'RA_CODFUNC')
	aCols[n][nTRMDESFUN] := NGSEEK("SRJ",cCodFunc,1,'RJ_DESC')

Return .t.
//---------------------------------------------------------------------
/*/{Protheus.doc} MenuDef
Utilizacao de Menu Funcional
@author Rafael Diogo Richter
@since 02/02/2008
@version undefined
@return Array com opcoes da rotina.
@type function
/*/
//---------------------------------------------------------------------
Static Function MenuDef()

	Local lPyme   := Iif(Type("__lPyme") <> "U",__lPyme,.F.)
	Local aRotina := {{ STR0001,"AxPesqui"  ,0, 1     },; //"Pesquisar"
	{ STR0002,"NG545FOLD" ,0, 2     },; //"Visualizar"
	{ STR0003,"NG545FOLD" ,0, 3     },; //"Incluir"
	{ STR0004,"NG545FOLD" ,0, 4     },; //"Alterar"
	{ STR0005,"NG545FOLD" ,0, 5, 3  },; //"Excluir"
	{ STR0033,"NG545Fin"  ,0, 6, 3  },; //"Finalizar"
	{ STR0006,"NG545LEG"  ,0, 7,,.F.},; //"Legenda"
	{ STR0034,"MNTA545PE" ,0, 1,,.F.},; //"Pesq. Inquer."
	{ STR0087,"MNT545REAB",0, 4,    }}  //"Reabrir."

	//+----------------------------------------------------------+
	//	Parametros do array a Rotina:                 	     	 |
	//| 1. Nome a aparecer no cabecalho                          |
	//| 2. Nome da Rotina associada                              |
	//| 3. Reservado                                             |
	//| 4. Tipo de Transação a ser efetuada:                     |
	//|    1 - Pesquisa e Posiciona em um Banco de Dados         |
	//|    2 - Simplesmente Mostra os Campos                     |
	//|    3 - Inclui registros no Bancos de Dados               |
	//|    4 - Altera o registro corrente                        |
	//|    5 - Remove o registro corrente do Banco de Dados      |
	//| 5. Nivel de acesso                                       |
	//| 6. Habilita Menu Funcional                 		     	 |
	//+----------------------------------------------------------+

	If !lPyme
		AAdd( aRotina, {STR0079, "MsDocument", 0, 4 } )  //"Conhecimento"
	EndIf

	If ExistBlock("MNTA5457")
		aRotina := ExecBlock("MNTA5457",.F.,.F.,{aRotina})
	EndIf

Return aRotina

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTASINGRA
BNGGRAVA
@author Marcos Wagner Junior
@since 20/03/08
@version undefined
@obs USO MNTA545 e MNTA540
@type function
/*/
//---------------------------------------------------------------------
Function MNTASINGRA()

	Local lRet := .f.
	Local nOpca := 0, oDlgP
	Local aOldArea := GetArea()

	Private cCodServ := Space(Len(ST4->T4_SERVICO)), cDesServ := Space(Len(ST4->T4_NOME)), lCORRET := .t., cCodNada := ' '

	If FindFunction("NgFilTQ2")
		cFilTRH := xFilial('TRH',NgFilTQ2(M->TRH_CODBEM,M->TRH_DTACID,M->TRH_HRACID))
		M->TRH_FILIAL := cFilTRH
	Else
		DbSelectArea("ST9")
		DbSetOrder(14)
		DbSeek(M->TRH_PLACA)
		cFilBem := IIf(Empty(ST9->T9_FILIAL),cFilTRH,ST9->T9_FILIAL)
		If !lNaoIntTMS .And. ST9->T9_CATBEM == '2'
			cFilBem := NGSEEK("DA3",M->TRH_CODBEM,5,'DA3_FILIAL')
			cFilBem := IIf(Empty(cFilBem),cFilTRH,cFilBem)
		EndIf

		If FunName() = 'MNTA540'
			M->TRH_FILIAL := cFilBem
		Else
			aNgFilTPN := NgFilTPN(M->TRH_CODBEM,M->TRH_DTACID,M->TRH_HRACID)
			cFilTRH := If(!Empty(aNgFilTPN[1]),aNgFilTPN[1],cFilBem)
			M->TRH_FILIAL := cFilTRH
		EndIf
	EndIf

	cValidST4 := MNT545SERV()
	If M->TRH_EVENTO == '1' .AND. M->TRH_FLGDAN == '1' .AND. !Empty(cParam) .And. !Empty(cValidST4)
		lRet := APMSGYESNO(STR0065+CHR(13)+; //"O bem sofreu um sinistro com danos. Dessa forma será necessário"
		STR0066+CHR(13)+; //"a abertura de uma O.S. Corretiva, porém o parâmetro MV_NG1SERA"
		STR0067+CHR(13)+CHR(13)+; //"está divergente:"
		cValidST4+CHR(13)+CHR(13)+;
		STR0068) //"Deseja informar um serviço válido?"
		If lRet

			DEFINE Font oFontN Name "Arial" Size 07,17
			DEFINE MsDialog oDlgP Title STR0069 From 000,000 To 085,400 Pixel Style DS_MODALFRAME // "Campos Genericos"

				oDlgP:lEscClose := .F.

				// "Nome do Campo: "
				@ 010,005 Say OemToAnsi(STR0070) Font oFontN Size 47,07 Of oDlgP PIXEL color CLR_HBLUE
				@ 010,032 MsGet cCodServ Picture "@!" F3 "ST3" Valid MNT545SER() Size 38,08 HASBUTTON Of oDlgP PIXEL
				@ 010,075 MsGet cDesServ Picture "@!" When .F. Size 125,08 HASBUTTON Of oDlgP PIXEL

				DEFINE sButton FROM 030,005 Type 13 Enable Of oDlgP Action (lConfirma := .T.,oDlgP:End()) //Salvar
				DEFINE sButton FROM 030,035 Type 2  Enable Of oDlgP Action (lConfirma := .F.,oDlgP:End()) //Cancelar

			Activate MsDialog oDlgP Centered

			If lConfirma

				PutMV("MV_NG1SERA",cCodServ)

				cParam := cCodServ

			Else
				Return .F.
			Endif

		Endif
	Endif

	RestArea(aOldArea)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545HOR
Validacao de hora
@author Marcos Wagner Junior
@since 08/02/07
@version undefined

@type function
/*/
//---------------------------------------------------------------------
Function MNTA545HOR()

	If FunName() = 'MNTA545'
		dData := aCols[n][3]
		cHora := M->TRI_HRREC
	Else
		dData := M->TRI_DTREC
		cHora := M->TRI_HRREC
	Endif

	If dDATABASE == dData
		If	cHora > TIME()
			Msgstop(STR0044,STR0012) //"Hora digitada não poderá ser maior que a hora do sistema"###"Atenção"
			Return .f.
		Endif
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545FUN
Limpa a Funcao do funcionario
@author Marcos Wagner Junior
@since 15/02/07
@version undefined

@type function
/*/
//---------------------------------------------------------------------
Function MNTA545FUN()

	If M->TRM_INDFUN != '1'
		M->TRM_DESFUN := Space(Len(TRM->TRM_DESFUN))
	Endif

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545BEM
Carrega o nome do Bem
@author Marcos Wagner Junior
@since 14/07/08
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545BEM()

	Local aOldArea := GetArea()
	Local cNomBemTRH := ''

	dbSelectArea("ST9")
	dbSetOrder(14)
	If dbSeek(TRH->TRH_PLACA)
		cNomBemTRH := ST9->T9_NOME
	Endif
	RestArea(aOldArea)

Return cNomBemTRH

//---------------------------------------------------------------------
/*/{Protheus.doc} MNA545VALB
Valida o codigo do Bem
@author Marcos Wagner Junior
@since 18/07/08
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNA545VALB()

	Local aOldArea := GetArea()
	Local lRet := .t.

	dbSelectArea("ST9")
	dbSetOrder(01)
	If EXISTCPO('ST9',M->TRH_CODBEM)
		dbSetOrder(16)
		If dbSeek(M->TRH_CODBEM+"A")
			If ST9->T9_CATBEM != "2" .AND. ST9->T9_CATBEM != "4"
				Msgstop(STR0045,STR0012) //"A categoria do bem informado não é permitida!###"Atenção"
				lRet := .f.
			Endif
		Endif
	Else
		lRet := .f.
	Endif

	RestArea(aOldArea)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT545TQY
Valida o codigo do Status
@author Marcos Wagner Junior
@since 20/05/09
@version undefined
@param cBEStatus, characters
@type function
/*/
//---------------------------------------------------------------------
Function MNT545TQY(cBEStatus)

	Local lStatusOk := .f.

	If !Empty(cBEStatus)
		If !ExistCpo("TQY",cBEStatus)
			Return .F.
		Else
			cBEDStatus := NGSEEK("TQY",cBEStatus,1,"TQY_DESTAT")
		EndIf
		dbSelectArea("TQY")
		dbSetOrder(01)
		If dbSeek(xFilial("TQY")+cBEStatus)
			While xFilial("TQY") == TQY->TQY_FILIAL .AND. cBEStatus == TQY->TQY_STATUS .AND. !lStatusOk
				If Empty(TQY->TQY_CATBEM)
					cBEDStatus := TQY->TQY_DESTAT
					lStatusOk := .t.
				Endif
				dbSkip()
			End
			If !lStatusOk
				MsgStop(STR0048,STR0012)  //"O status não poderá pertencer a nenhuma Categoria de Bem!"###"Atenção"
				Return .f.
			Endif
		Endif
	Else
		cBEDStatus := Space(40)
	EndIf

	If lRet
		dbSelectArea(cTRBE080)
		nRec := Recno()
		dbGoTop()
		While !Eof()
			If IsMark('OK',cMarca) .And. !Empty(cBEStatus) .And. NGSEEK("ST9",(cTRBE080)->CODBEM,1,"T9_CATBEM") != "3"
				RecLock(cTRBE080,.F.)
				(cTRBE080)->STATUS := cBEStatus
				(cTRBE080)->DESTAT := NGSEEK("TQY",cBEStatus,1,"TQY_DESTAT")
				MsUnLock(cTRBE080)
			EndIf
			dbSkip()
		End
	Endif

	dbGoTo(nRec)
	oMark:oBrowse:Refresh()

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT545FLG
Carrega o nome do Bem
@author Marcos Wagner Junior
@since 26/05/09
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNT545FLG()

	Local aOldArea := GetArea()
	Local lRet := .t.

	If M->TRH_FLGDAN = '2'
		M->TRH_VALDAN := 0
	Endif

	If NGCADICBASE("TRH_ORDEM","A","TRH",.F.) .AND. !Empty(TRH->TRH_ORDEM) .AND. Altera .AND. M->TRH_FLGDAN == '2'
		dbSelectArea("STJ")
		dbSetOrder(01)
		If dbSeek(xFilial("STJ")+TRH->TRH_ORDEM)
			If STJ->TJ_TERMINO == "N" .And. STJ->TJ_SITUACA <> 'C'
				MsgStop(STR0063+TRH->TRH_ORDEM+STR0064,STR0012)//"O sinistro está relacionado a OS: "###", que não foi finalizada!"###"Atenção"
				lRet := .f.
			Endif
		Endif
	Endif

	RestArea(aOldArea)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT545SER
Validacao do Servico
@author Marcos Wagner Junior
@since 27/05/09
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNT545SER()

	Local lRet := .f.

	dbSelectArea("ST4")
	dbSetOrder(1)
	If dbSeek(xFilial("ST4")+cCodServ)
		If NGFUNCRPO("NGSERVBLOQ",.F.) .And. !NGSERVBLOQ(cCodServ)
			Return .f.
		EndIf
		dbSelectArea("STE")
		dbSetOrder(1)
		If dbSeek(xFilial('STE')+ST4->T4_TIPOMAN)
			If STE->TE_CARACTE == 'C'
				lRet := .t.
			Else
				MsgStop(STR0071,STR0012)  //"O serviço deverá ser do tipo Corretivo!"###"Atenção"
			EndIf
		Endif
	Endif

	If lRet
		cDesServ := NGSEEK("ST4",cCodServ,1,"T4_NOME")
	Endif

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT545SERV
Validacao do Servico
@author Marcos Wagner Junior
@since 27/05/09
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNT545SERV()

	Local cRetorno := ' '
	Local aOldArea := GetArea()

	dbSelectArea("ST4")
	dbSetorder(1)
	If !dbseek(xFilial("ST4")+cParam)
		cRetorno := STR0072 //"Código do Serviço não cadastrado!"
	Else
		If NGFUNCRPO("NGSERVBLOQ",.F.)
			vRetBlq := NGSERVBLOQ(cParam,.f.)
			If !vRetBlq[1]
				cRetorno := vRetBlq[2]
			Endif
		Else
			dbSelectArea("STE")
			dbSetorder(1)
			If !dbseek(xFilial("STE")+ST4->T4_TIPOMAN)
				cRetorno := STR0073 //"Tipo de Serviço não cadastrado!"
			Elseif STE->TE_CARACTE <> 'C'
				cRetorno := STR0071 //"O serviço deverá ser do tipo Corretivo!"
			Endif
		Endif
	Endif

	RestArea(aOldArea)

Return cRetorno

//---------------------------------------------------------------------
/*/{Protheus.doc} AGR545TRR
Deleta tabela TRR - Acoes Durante o Processo Juridico
@author Marcos Wagner Junior
@since 02/06/09
@version undefined
@param nOpcx, numeric
@type function
/*/
//---------------------------------------------------------------------
Function AGR545TRR(nOpcx)

	If nOpcx == 5
		dbSelectArea("TRR")
		dbSetOrder(01)
		dbSeek(xFilial("TRR")+M->TRH_NUMSIN)
		While TRR->TRR_FILIAL == xFilial("TRR") .AND. TRR->TRR_NUMSIN == M->TRH_NUMSIN
			RecLock("TRR",.f.)
			dbDelete()
			TRR->(MsUnlock())
			dbSkip()
		End
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} AGR545TRS
Deleta tabela TRS - APD de Sinistro
@author Marcos Wagner Junior
@since 02/06/09
@version undefined
@param nOpcx, numeric
@type function
/*/
//---------------------------------------------------------------------
Function AGR545TRS(nOpcx)

	If nOpcx == 5
		dbSelectArea("TRS")
		dbSetOrder(01)
		dbSeek(xFilial("TRS")+M->TRH_NUMSIN)
		While TRS->TRS_FILIAL == xFilial("TRS") .AND. TRS->TRS_NUMSIN == M->TRH_NUMSIN
			RecLock("TRS",.f.)
			dbDelete()
			TRS->(MsUnlock())
			dbSkip()
		End
	Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} M545BAIXA
Valida os campos obrigatorios para Baixa de Estrutura
@author Marcos Wagner Junior
@since 21/07/09
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Static Function M545BAIXA()

	Local lRet := .T.

	If Empty(cMotBaixa)
		lRet := .F.
		APMSGALERT(STR0077) //"Preencha os campos obrigatórios!"
	EndIf

	nOpcaBE := If(lRet,.t.,.f.)

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545MOT
Valida e Carrega a Descricao do Motivo
@author Marcos Wagner Junior
@since 21/07/09
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Static Function MNTA545MOT()

	If !Empty(cMotBaixa)
		If !ExistCpo("TPJ",cMotBaixa)
			Return .F.
		Else
			cDesMot := NGSEEK("TPJ",cMotBaixa,1,"TPJ_DESMOT")
		EndIf
	Else
		cDesMot := Space(40)
	EndIf

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} M545CnclBx
Cancela a Baixa do Bem
@author Marcos Wagner Junior
@since 21/07/09
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Static Function M545CnclBx()

	Local lRet := .T.
	lRet := APMSGYESNO(STR0078,STR0052) //"Deseja cancelar a inativação do bem?"###"Baixa de Estrutura"

	If lRet
		nOpcaBE := .f.
	EndIf

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTR545VGM
Função para validar a situação do campo TRV_CODMOT
@author Microsiga
@since 08/26/10
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNTR545VGM

	Local aAreaOld := GetArea()

	If lNaoIntTMS
		Return .T.
	Else
		If !Empty(M->TRH_CODBEM) .And. !Empty(M->TRH_DTACID) .And. !Empty(M->TRH_HRACID)
			cAliasQry := GetNextAlias()
			cQuery := "SELECT DTQ.DTQ_VIAGEM, DTQ.DTQ_FILORI, DTQ.DTQ_FILDES, DUP.DUP_CODMOT, DA4.DA4_NOME, "
			cQuery += " 	   DTW.DTW_DATINI, DTW.DTW_HORINI, DUV.DUV_ODOSAI, DTQ.DTQ_DATFIM "
			cQuery += " FROM " + RetSqlName("ST9") + " ST9," + RetSqlName("DTR") + " DTR," + RetSqlName("DTQ") + " DTQ," +;
			RetSqlName("DUP") + " DUP," + RetSqlName("DA4") + " DA4," + RetSqlName("DUV") + " DUV," +;
			RetSqlName("DTW") + " DTW "
			cQuery += " WHERE ST9.T9_CODBEM = '"+M->TRH_CODBEM+"'"
			cQuery += " AND ST9.T9_CODTMS  = DTR.DTR_CODVEI"
			cQuery += " AND DTW_ATIVID IN ('"+cAtivSai+"','"+cAtivChg+"')"
			cQuery += " AND DTQ.DTQ_VIAGEM = DTR.DTR_VIAGEM"
			cQuery += " AND DTQ.DTQ_FILORI = DTR.DTR_FILORI"
			cQuery += " AND DTR_VIAGEM = DTW_VIAGEM"
			cQuery += " AND DTR_FILORI = DTW_FILORI"
			cQuery += " AND DTQ.DTQ_VIAGEM = DUP.DUP_VIAGEM"
			cQuery += " AND DTQ.DTQ_FILORI = DUP.DUP_FILORI"
			cQuery += " AND DTQ.DTQ_VIAGEM = DUV.DUV_VIAGEM"
			cQuery += " AND DTQ.DTQ_FILORI = DUV.DUV_FILORI"
			cQuery += " AND DUP.DUP_CODMOT = DA4.DA4_COD"
			cQuery += " AND DTR.D_E_L_E_T_ <> '*' "
			cQuery += " AND DTQ.D_E_L_E_T_ <> '*' "
			cQuery += " AND ST9.D_E_L_E_T_ <> '*' "
			cQuery += " AND DUP.D_E_L_E_T_ <> '*' "
			cQuery += " AND DA4.D_E_L_E_T_ <> '*' "
			cQuery += " AND DTW.D_E_L_E_T_ <> '*' "
			cQuery += " AND DTQ_VIAGEM IN (SELECT MAX(DTR_VIAGEM)"
			cQuery += " FROM " + RetSqlName("DTR") + " CPL," + RetSqlName("DTW") + " ALT1," + RetSqlName("DTW") + " ALT2 "
			cQuery += " WHERE CPL.DTR_FILORI = ALT1.DTW_FILORI"
			cQuery += " AND CPL.DTR_VIAGEM = ALT1.DTW_VIAGEM"
			cQuery += " AND CPL.DTR_FILORI = ALT2.DTW_FILORI"
			cQuery += " AND CPL.DTR_VIAGEM = ALT2.DTW_VIAGEM"
			cQuery += " AND CPL.DTR_CODVEI = DTR.DTR_CODVEI
			cQuery += " AND ALT1.DTW_ATIVID = '"+cAtivSai+"'"
			cQuery += " AND ALT2.DTW_ATIVID = '"+cAtivChg+"'"
			cQuery += " AND ALT1.DTW_DATINI <> ' ' "
			cQuery += " AND ALT2.DTW_DATINI <> ' ' "
			cQuery += " AND(ALT1.DTW_DATINI || ALT1.DTW_HORINI <= '"+DTOS(M->TRH_DTACID)+SubStr(M->TRH_HRACID,1,2)+SubStr(M->TRH_HRACID,4,2)+"')"
			cQuery += " AND(ALT2.DTW_DATINI || ALT2.DTW_HORINI >= '"+DTOS(M->TRH_DTACID)+SubStr(M->TRH_HRACID,1,2)+SubStr(M->TRH_HRACID,4,2)+"')"
			cQuery += " AND(CPL.DTR_DATINI  || CPL.DTR_HORINI  <= '"+DTOS(M->TRH_DTACID)+SubStr(M->TRH_HRACID,1,2)+SubStr(M->TRH_HRACID,4,2)+"')"
			cQuery += " AND CPL.D_E_L_E_T_ <> '*' "
			cQuery += " AND ALT1.D_E_L_E_T_ <> '*' "
			cQuery += " AND ALT2.D_E_L_E_T_ <> '*' )"
			cQuery += " ORDER BY DTQ.DTQ_DATINI, DTQ.DTQ_HORINI"
			cQuery := ChangeQuery(cQuery)
			dbUseArea( .T., "TOPCONN", TCGENQRY(,,cQuery),cAliasQry, .F., .T.)
			dbGoTop()

			If Eof()
				(cAliasQry)->(dbCloseArea())
				RestArea(aAreaOld)
				Return .T.
			EndIf

			(cAliasQry)->(dbCloseArea())
			RestArea(aAreaOld)
		Else
			Return .T.
		EndIf
	EndIf

Return .F.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNTA545LGD
Limpa os campos da GetDados.
@author Wagner S. de Lacerda
@since 02/02/2011
@version undefined
@param cCpo, characters, Define o campo da validacao. Obrigatorio
@return .T. -> Campo alterado. / .F. -> Nao permite a alteracao.
@obs  ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL
@type function
/*/
//---------------------------------------------------------------------
Function MNTA545LGD(cCpo)

	Local nTROSEGCOR := aScan(aHEADER,{|x| Trim(Upper(x[2])) == "TRO_SEGCOR"})
	Local nTROAPOLIC := aScan(aHEADER,{|x| Trim(Upper(x[2])) == "TRO_APOLIC"})
	Local nTROTELSEG := aScan(aHEADER,{|x| Trim(Upper(x[2])) == "TRO_TELSEG"})

	cCpo := Upper(AllTrim(cCpo))

	If cCpo == "TRO_DANOS" .And. &(ReadVar()) == "2"
		If !Empty(aCols[n][nTROVALPRE])
			If MsgYesNo(STR0080+" '"+AllTrim(NGRETTITULO("TRO_VALPRE"))+"' "+STR0081+Chr(13)+Chr(10)+STR0082,STR0012) //"Na ausência de Danos, o campo"###"será limpo."###"Confirmar?"###"Atenção"
				aCols[n][nTROVALPRE] := 0.00
			Else
				Return .F.
			EndIf
		EndIf
	ElseIf cCpo == "TRO_SEGUR" .And. &(ReadVar()) == "2"
		If !Empty(aCols[n][nTROSEGCOR]) .Or. !Empty(aCols[n][nTROAPOLIC]) .Or. !Empty(aCols[n][nTROTELSEG])
			If MsgYesNo(STR0083+" '"+OemToAnsi(AllTrim(NGRETTITULO("TRO_SEGCOR")))+; //"Na ausência de Seguro, os campos"
			"', '"+OemToAnsi(AllTrim(NGRETTITULO("TRO_APOLIC")))+;
			"' "+STR0084+" '"+OemToAnsi(AllTrim(NGRETTITULO("TRO_TELSEG")))+; //"e"
			"' "+STR0085+Chr(13)+Chr(10)+STR0082,STR0012) //"Confirmar?"###"Atenção"
				aCols[n][nTROSEGCOR] := Space(aHeader[nTROSEGCOR][4])
				aCols[n][nTROAPOLIC] := Space(aHeader[nTROAPOLIC][4])
				aCols[n][nTROTELSEG] := Space(aHeader[nTROTELSEG][4])
			Else
				Return .F.
			EndIf
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MNT545REAB
Função para reabrir sinistro.
@author Bruno Souza
@since 09/02/12
@version undefined
@type function
/*/
//---------------------------------------------------------------------
Function MNT545REAB()

	If TRH->TRH_FLGCOM = '2'
		MsgStop(STR0089) //"Sinistro não esta finalizado"
		Return .f.
	EndIf

	If MsgYesNo(STR0088,STR0012) //"Deseja finalizar o sinistro?"###"Atenção"
		DbSelectArea("TRH")
		DbSetOrder(1)
		RecLock("TRH",.f.)
		TRH->TRH_FLGCOM := '2'
		MsUnLock("TRH")
	EndIf

Return .t.

//---------------------------------------------------------------------------------
/*/{Protheus.doc}  AddFolder
Adiciona Folders criado pelo usuario, utilizado no ponto de entrada MNTA5452.

@author Jean Pytter da Costa
@since 26/02/2015
@param aFolders - Array que recebe o conteudo do ponto de entrada MNTA5452
@param aArrAuxTit - Array que recebe os Folders criado pelo usuario.
@param aArrAuxPag - Array que recebe as Paginas de acordo com os folders criados.

@return .
/*/
//---------------------------------------------------------------------------------
Static Function AddFolder(aFolders, aArrAuxTit, aArrAuxPag)

	Local aArea    := GetArea()
	Local nFld

	For nFld := 1 To Len(aFolders)

		aAdd(aArrAuxTit , aFolders[nFld] )
		aAdd(aArrAuxPag , "HEADER " + AllTrim( Str( Len( aArrAuxTit ) ) ) )

	Next nFld

	RestArea(aArea)

Return

//---------------------------------------------------------------------------------
/*/{Protheus.doc}  AddCampo
Adiciona Campos criado pelo usuario, utilizado no ponto de entrada MNTA5453.

@author Jean Pytter da Costa
@since 26/02/2015
@param aCampos - Array que recebe o conteudo do ponto de entrada MNTA5453

@return .
/*/
//---------------------------------------------------------------------------------
Static Function AddCampo(aCampos)

	Local aArea    := GetArea()
	Local aAreaSX3 := SX3->(GetArea())
	Local nFld, nCont

	aTELA := {}
	aGETS := {}

	dbSelectArea("SX3")
	dbSetOrder(2)
	For nFld := 1 To Len( aCampos ) //Verifica os campos que não existem no dicionario e Deleta
		For nCont := Len( aCampos[ nFld, 2 ] ) To 1 Step -1
			If !dbSeek( aCampos[ nFld, 2 , nCont ] )
				aDel( aCampos[ nFld, 2 ], nCont )
				aSize( aCampos[ nFld, 2 ] , Len( aCampos[ nFld, 2 ] )-1 )
			EndIf
		Next nCont
	Next nFld

	For nCont := 1 To Len( aCampos ) //Adiciona os campos criados para o Folder correspondente
		aTELA := {}
		aGETS := {}
		DbSelectArea( aCampos[nCont,1] )
		RegToMemory( aCampos[nCont,1], Inclui )
		&( "oENC01"+cValToChar( nCont ) ):= MsMGet():New(aCampos[nCont,1],,nOPCAO,,,,aCampos[nCont,2],aDimens,,,,,,oFOLDER:aDIALOGS[aCampos[nCont,3]],,,.F.)
		&( "oENC01"+cValToChar( nCont ) ):oBox:Align := CONTROL_ALIGN_ALLCLIENT
	Next nCont

	RestArea(aAreaSX3)
	RestArea(aArea)

	Return

//----------------------------------------------------------------
/*/{Protheus.doc} ChangeGet()
Realiza backup do aCols modificado e carrega novo aCols de acordo
com mudança de Aba.
@author Bruno Lobo de Souza
@since	01/06/2015
@return Nil
/*/
//----------------------------------------------------------------
Static Function ChangeGet()

	Do Case
		Case oFolder:nOption == 3
			EntraG545(1)
		Case oFolder:nOption == 4
			EntraG545(2)
		Case oFolder:nOption == 5
			EntraG545(3)
		Case oFolder:nOption == 6
			EntraG545(4)
		Case oFolder:nOption == 7
			EntraG545(5)
		Case oFolder:nOption == 8
			EntraG545(6)
		Case oFolder:nOption == 9
			EntraG545(7)
		Case oFolder:nOption == 10
			EntraG545(8)
	EndCase
Return

//----------------------------------------------------------------
/*/{Protheus.doc} CheckCols()
Verifica se o aCols atual está de acordo com o que será validado
no linOk.
@author Bruno Lobo de Souza
@since	01/06/2015
@return Nil
/*/
//----------------------------------------------------------------
Static Function CheckCols()

	Local lRet := .T.
	Do Case
		Case oFolder:nOption == 3
			lRet := NG545LINOK(1)
		Case oFolder:nOption == 4
			lRet := NG545LINOK(2)
		Case oFolder:nOption == 5
			lRet := NG545LINOK(3)
		Case oFolder:nOption == 6
			lRet := NG545LINOK(4)
		Case oFolder:nOption == 7
			lRet := NG545LINOK(5)
		Case oFolder:nOption == 8
			lRet := NG545LINOK(6)
		Case oFolder:nOption == 9
			lRet := NG545LINOK(7)
		Case oFolder:nOption == 10
			lRet := NG545LINOK(8)
	EndCase

Return lRet
