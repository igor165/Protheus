#Include "MDTUTIL.ch"
#Include "Protheus.ch"
#Include "MSOLE.ch"
#Include "SHELL.ch"
#Include "Apwizard.ch"

Static __aUserLg := {} //Utilizado na funcao MDTDATALO

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTUTIL
Programa com funcoes genericas que sao utilizadas no modulo do SIGMDT (Medicina e Seguranca do Trabalho).

@author Inacio Luiz Kolling
@since 10/01/2000
/*/
//---------------------------------------------------------------------

//---------------------------------------------------------------------
/*/{Protheus.doc} VSAYMDT
Inicializadores Padrãoes (Função Centralizadora)

@return Lógico Sempre Verdadeiro

@param ARG1 Caracter Nome da variavel
@param ARG2 Indefinido Valor da Variavel

@author
@since
/*/
//---------------------------------------------------------------------
Function VSAYMDT(ARG1,ARG2)

	Local cRet

	If ARG1 == "01"                       //TMN_NOMFIC
		cRET := If( TM0->(DbSeek(xFilial('TM0') + M->TMN_NUMFIC)),TM0->TM0_NOMFIC, Space(TAMSX3("TMN_NOMFIC")[1]) )
	ElseIf ARG1 == "02"                   //TMF_NOMFIC
		cRET := If( TM0->(DbSeek(xFilial('TM0') + M->TMF_NUMFIC)),TM0->TM0_NOMFIC, Space(20) )
	ElseIf ARG1 == "03"                   //TNA_NOMFIC
		cRET := If( TM0->(DbSeek(xFilial('TM0') + M->TNA_NUMFIC)),TM0->TM0_NOMFIC, Space(20) )
	ElseIf ARG1 == "04"                   //TM5_NOMFIC
		If cPROGRAMA == "MDTA160"
			cRET := If( TM0->(DbSeek(xFilial('TM0') + M->TMT_NUMFIC)),TM0->TM0_NOMFIC, Space(20))
		ElseIf cPROGRAMA == "MDTC310"
			If !Empty(TM5->TM5_FILFUN)
				cRet := If( TM0->(DbSeek(xFilial('TM0',TM5->TM5_FILFUN) + TM5->TM5_NUMFIC)),TM0->TM0_NOMFIC, Space(20) )
			Else
				cRet := If( TM0->(DbSeek(xFilial('TM0') + TM5->TM5_NUMFIC)),TM0->TM0_NOMFIC, Space(20) )
			EndIf
		Else
			cRET := If( TM0->(DbSeek(xFilial('TM0') + M->TM5_NUMFIC)),TM0->TM0_NOMFIC, Space(20) )
		EndIf
	ElseIf ARG1 == "05"                   //TM4_NOMEXA
		cRET := If( TM4->(DbSeek(xFilial('TM4') + M->TN4_EXAME)),TM4->TM4_NOMEXA, Space(Len(TM4->TM4_NOMEXA)) )
	ElseIf ARG1 == "06"                   //TM4_UNIDAD
		cRET := If( TMB->(DbSeek(xFilial('TMB')+M->TN4_AGENTE+M->TN4_EXAME)),TMB->TMB_UNIDAD, Space(06))
	ElseIf ARG1 == "07"                   //TMT_NOMFIC
		If cPROGRAMA $ " MDTA155 / MDTA155A / MDTA160 / MDTA005 / MDTC355 / MDTC305 / MDTR990 / MDTA991 / MDTC990 / MDTC500 / MDTA076 / MDTA410 "
			cRET := If( TM0->(DbSeek(xFilial('TM0') + M->TMT_NUMFIC)),TM0->TM0_NOMFIC, Space(20))
		Else
			cRET := If( TM0->(DbSeek(xFilial('TM0') + M->TNC_NUMFIC)),TM0->TM0_NOMFIC, Space(20))
		EndIf
	ElseIf ARG1 == "08"                   //TMT_NOMUSU
		If cPrograma == "MDTC990"
			cRET := If( TMK->(DbSeek(xFilial('TMK') + TMT->TMT_CODUSU)),TMK->TMK_NOMUSU, Space(20))
		Else
			cRET := If( TMK->(DbSeek(xFilial('TMK') + M->TMT_CODUSU)),TMK->TMK_NOMUSU, Space(20))
		EndIf
	ElseIf ARG1 == "09"                   //TMJ_NOMUSU
		cRET := If( TMK->(DbSeek(xFilial('TMK') + M->TMJ_CODUSU)),TMK->TMK_NOMUSU, Space(Len(TMK->TMK_NOMUSU)) )
	ElseIf ARG1 == "10"                   //TM2_NOMFIC
		cRET := If( TM0->(DbSeek(xFilial('TM0') + M->TM2_NUMFIC)),TM0->TM0_NOMFIC, Space(20))
	ElseIf ARG1 == "11"                   //TNC_NOMFIC
		cRET := If( TM0->(DbSeek(xFilial('TM0') + M->TNC_NUMFIC)),TM0->TM0_NOMFIC, Space(20))
	ElseIf ARG1 == "12"                   //TMF_NOMFIC
		cRET := If( TM0->(DbSeek(xFilial('TM0') + M->TMF_NUMFIC)),TM0->TM0_NOMFIC, Space(20) )
	Else
		cRET := VDISP(ARG1,ARG2)
	Endif

Return cRET

//---------------------------------------------------------------------
/*/{Protheus.doc} NEXTCONVOC
Obtem o proximo numero da Convocacao.

@author Marcio Luiz Costa
@since 07/03/2000
/*/
//---------------------------------------------------------------------
Function NEXTCONVOC(lMulti)

	Local nCONVOC := 0,nContad
	Local aArea := TMV->(GetArea())
	Default lMulti := .F.//Varíavel que indica se é multi-convocação

	DbSelectArea("TMV")
	DbSetOrder(1)
	DbSeek(xFilial("TMV")+M->TMV_PCMSO)
	While !Eof() .and. TMV->TMV_FILIAL == xFilial("TMV") .and. TMV->TMV_PCMSO == M->TMV_PCMSO

		If Val(TMV->TMV_CONVOC) > nCONVOC
			nCONVOC := Val(TMV->TMV_CONVOC)
		Endif

		Dbskip()
	EndDo

	nCONVOC++
	Help := .T.	// Nao apresentar Help MayUse
	For nContad := 0 to 50

		If !FreeForUse("TMV",xFilial("TMV")+M->TMV_PCMSO+STR(nCONVOC,4),.f.)
			nCONVOC++
			Help := .T.	// Nao apresentar Help MayUse
			Loop
		EndIf

		Exit
	Next nContad
	Help := .F.	// Habilito o help novamente

	If lMulti
		Return StrZero(nCONVOC,4)
	Else
		M->TMV_CONVOC := STRZERO(nCONVOC,4)
	Endif

	If NGCADICBASE("TMV_FILDE","D","TMV",.F.) .And. NGCADICBASE("TMW_FILDE","D","TMW",.F.)
		M->TMV_FILDE := Space(Len(TMW->TMW_FILDE))
		M->TMV_FILATE:= Space(Len(TMW->TMW_FILATE))
		DbSelectArea("TMW")
		DbSetOrder(1)
		If DbSeek(xFilial("TMW")+M->TMV_PCMSO)
			M->TMV_FILDE  := TMW->TMW_FILDE
			M->TMV_FILATE := TMW->TMW_FILATE
		Endif
	Endif

	RestArea(aArea)
Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} NGUTILPER
Obter a Periodicidade para a realizacao do exame conforme
a idade do funcionario em relacao as faixas etarias defini-
das na tabela TMQ.
Recebe Faixa,Idade e Sexo
Envia  Numero de Meses p/exame periodico e pos admissiona

@return aPeriodic Array Retorna a qtde de meses para exames periodicos e pos admissional

@author Marcio Luiz Costa
@since 11/02/2000
/*/
//---------------------------------------------------------------------
Function  NGUTILPER(cFaixa,nIdade,cSexo)
	Local nPosadm   := 0
	Local nFrequenc := 0
	Local aAreaOld  := GetArea()//Salva Área posicionada.

	DbSelectArea("TMQ")
	DbSetOrder(1)
	IF DbSeek(xFilial("TMQ") + cFaixa)
		IF TMQ->TMQ_SEXO ==  "3" .OR. cSexo == TMQ->TMQ_SEXO
			IF     nIdade >= TMQ->TMQ_1DE .AND. nIdade <= TMQ->TMQ_1ATE
				nFrequenc := TMQ->TMQ_1QTMES
			ELSEIF nIdade >= TMQ->TMQ_2DE .AND. nIdade <= TMQ->TMQ_2ATE
				nFrequenc := TMQ->TMQ_2QTMES
			ELSEIF nIdade >= TMQ->TMQ_3DE .AND. nIdade <= TMQ->TMQ_3ATE
				nFrequenc := TMQ->TMQ_3QTMES
			ELSEIF nIdade >= TMQ->TMQ_4DE .AND. nIdade <= TMQ->TMQ_4ATE
				nFrequenc := TMQ->TMQ_4QTMES
			ENDIF
			nPosadm   := TMQ->TMQ_POSADM
			aPeriodic[1,1]:= nFrequenc
			aPeriodic[1,2]:= nPosadm
			aPeriodic[1,3]:= 1
			If TMQ->(FieldPos("TMQ_POSAD1")) > 0
				aPeriodic[1,4]:= TMQ->TMQ_POSAD1
			Endif
		ELSE
			aPeriodic[1,3]:= 0
		ENDIF
	ENDIF
	RestArea( aAreaOld  )
Return (aPeriodic)
//---------------------------------------------------------------------
/*/{Protheus.doc} NGUTILFOR
Obter o fornecedor do Exame. tabela preco exame - TMD.
Recebe codigo do Exame em cExame
Envia  codigo do Fornecedor e Loja em aFornec

@param cExame Caracter Exame a ser localizado
@param lAllFor Logico Indica se retornara todos os fornecedores do exame

@author Marcio Luiz Costa
@since 15/02/2000
/*/
//---------------------------------------------------------------------
Function  NGUTILFOR(cExame,lAllFor)
	Local cFornexa := Space(Len(TMD->TMD_FORNEC))
	Local cLoja    := Space(Len(TMD->TMD_LOJA))
	Local aAreaOld  := GetArea()//Salva Área posicionada.
	Local aTempFor := {}

	Default lAllFor := .F.

	dbSelectArea("TMD")
	dbSetOrder(2)
	dbSeek(xFilial("TMD")+cExame)
	If lAllFor
		While !Eof() .And. xFilial("TMD")+cExame == TMD->TMD_FILIAL+TMD->TMD_EXAME
			If TMD->(FieldPos("TMD_DTFIM")) > 0
				If dDataBase >= TMD->TMD_DTINIC .and. (dDataBase <= TMD->TMD_DTFIM .or. Empty(TMD->TMD_DTFIM))
					If aScan(aTempFor,{|aArray| aArray[1]+aArray[2] == TMD->TMD_FORNEC+TMD->TMD_LOJA}) == 0
						aAdd(aTempFor,{TMD->TMD_FORNEC,TMD->TMD_LOJA})
					EndIf
				Endif
			Else
				If aScan(aTempFor,{|aArray| aArray[1]+aArray[2] == TMD->TMD_FORNEC+TMD->TMD_LOJA}) == 0
					aAdd(aTempFor,{TMD->TMD_FORNEC,TMD->TMD_LOJA})
				EndIf
			Endif
			dbSelectArea("TMD")
			dbSkip()
		EndDo
		If Empty(aTempFor)
			aAdd(aTempFor,{cFornexa,cLoja})
		EndIf
	Else
		While !Eof() .And. xFilial("TMD")+cExame == TMD->TMD_FILIAL+TMD->TMD_EXAME
			If TMD->(FieldPos("TMD_DTFIM")) > 0
				If dDataBase >= TMD->TMD_DTINIC .and. (dDataBase <= TMD->TMD_DTFIM .or. Empty(TMD->TMD_DTFIM))
					cFornexa := TMD->TMD_FORNEC
					cLoja    := TMD->TMD_LOJA
					Exit
				Endif
			Else
				cFornexa := TMD->TMD_FORNEC
				cLoja    := TMD->TMD_LOJA
				Exit
			Endif
			dbSelectArea("TMD")
			dbSkip()
		EndDo
		aFornec[1,1]:= cFornexa
		aFornec[1,2]:= cLoja
		aTempFor := aFornec
	EndIf
	RestArea( aAreaOld  )
Return (aTempFor)
//---------------------------------------------------------------------
/*/{Protheus.doc} NGUTILUEX
Obter a Data de realizacao do Ultimo Exame em - TM5.
Recebe Ficha, Exame e Data inicio.
Envia  Data de Programacao do Ultimo Exame Realizado.
OBS.   Data de Inicio , deve ser a data que o programa
   assumira caso nao encontre um exame para o funcionario

@param cNumFic Caracter Ficha Medica
@param cExamePar Caracter Cod. Exame
@param dInicProg Data Data inicial de programacao a ser considerada
@param nTipoBusca Numerico Data Base da Programacao de Exames. Pode ser:1 = Data Programacao Exame; 2 = Data de Realizacao do Exame;3 = Data Último ASO;4 = Data Aniversário;5 = Data Admissão;6 = Data informada
@param cNatureza Caracter Natureza do Exame. Pode ser: 1 = Admissional;2 = Periódico;3 = Mudança de Função;4 = Retorno ao Trabalho;5 = Demissional;6 = Consulta
@param nTipProg Numerico Indica se os exames estão sendo reprogramados. 1 = Programados; 3 = Reprogramados

@author Marcio Luiz Costa
@since 17/02/2000
/*/
//---------------------------------------------------------------------
Function  NGUTILUEX(cNumfic,cExamePar,dInicProg,nTipoBusca,cNatureza,nTipProg)
	Local dUltExame := dInicProg
	Local aAreaOld  := GetArea()//Salva Área posicionada.
	Local cExame    := cExamePar
	Local aAreaXXX
	Local aAreaSRA
	Local aAreaTM0
	Local cFilMat := " "
	Local dNascDt := stod("")
	Local dAdmiDt := stod("")
	Local dDtAux  := stod("")
	Local nRecnoTm5 := 0

	Default nTipoBusca := 1

	If nTipoBusca == 3
		cExame := PadR("NR7",Len(cExamePar))
	Endif

	If nTipoBusca == 4 .And. nTipProg != 3   //Data de Aniversario //Nao é Reprogramacao
		aAreaXXX := GetArea()
		aAreaSRA := SRA->(GetArea())
		aAreaTM0 := TM0->(GetArea())

		cFilMat := Posicione("TM0",1,xFilial("TM0")+cNumfic,"TM0_FILFUN+TM0_MAT")
		dNascDt := Posicione("SRA",1,cFilMat,"RA_NASC")
		dAdmiDt := TMW->TMW_DTINIC
		If !Empty(dNascDt)
			dDtAux := STOD(Strzero(Year(dAdmiDt),4)+Substr(DTOS(dNascDt),5,4))
			If dDtAux < dAdmiDt
				dDtAux := STOD(Strzero(Year(dAdmiDt)+1,4)+Substr(DTOS(dNascDt),5,4))
			Endif
			If !Empty(dDtAux)
				dUltExame := dDtAux
			Else
				dUltExame := dNascDt
			Endif
		Endif
		RestArea(aAreaSRA)
		RestArea(aAreaTM0)
		RestArea(aAreaXXX)
	Else
		If nTipoBusca == 4  //Data de Aniversário
			aAreaXXX := GetArea()
			aAreaSRA := SRA->(GetArea())
			aAreaTM0 := TM0->(GetArea())

			cFilMat := Posicione("TM0",1,xFilial("TM0")+cNumfic,"TM0_FILFUN+TM0_MAT")
			dNascDt := Posicione("SRA",1,cFilMat,"RA_NASC")
			dAdmiDt := TMW->TMW_DTINIC
			If !Empty(dNascDt)
				dDtAux := STOD(Strzero(Year(dAdmiDt),4)+Substr(DTOS(dNascDt),5,4))
				If dDtAux < dAdmiDt
					dDtAux := STOD(Strzero(Year(dAdmiDt)+1,4)+Substr(DTOS(dNascDt),5,4))
				Endif
				If !Empty(dDtAux)
					dUltExame := dDtAux
				Else
					dUltExame := dNascDt
				Endif
			Endif
			RestArea(aAreaSRA)
			RestArea(aAreaTM0)
			RestArea(aAreaXXX)
		Elseif nTipoBusca == 5  //Data de Admissao
			aAreaXXX := GetArea()
			aAreaSRA := SRA->(GetArea())
			aAreaTM0 := TM0->(GetArea())

			cFilMat := Posicione("TM0",1,xFilial("TM0")+cNumfic,"TM0_FILFUN+TM0_MAT")
			dUltExame := Posicione("SRA",1,cFilMat,"RA_ADMISSA")

			RestArea(aAreaSRA)
			RestArea(aAreaTM0)
			RestArea(aAreaXXX)
		Elseif nTipoBusca == 6  //Data informada
			dUltExame := TMW->TMW_DTREFE
		Endif

		DbSelectArea("TM5")
		DbSetOrder(6)
		IF DbSeek(xFilial("TM5") + cNumfic + cExame)
			Do While !EOF()                               .AND. ;
					TM5->TM5_FILIAL == xFilial("TM5")    .and. ;
					TM5->TM5_NUMFIC == cNumfic           .and. ;
					TM5->TM5_EXAME  == cExame

				If ValType(cNatureza) == "C"
					If cNatureza <> TM5->TM5_NATEXA
						DbSelectArea("TM5")
						dbSkip()
						Loop
					Endif
				Endif

				If nTipoBusca == 1 //Base na data de programacao
					If !Empty(TM5->TM5_DTPROG)
						If TM5->TM5_DTPROG > dUltExame .or. SRA->RA_ADMISSA == dUltExame
							dUltExame := TM5->TM5_DTPROG
							nRecnoTm5 := TM5->(Recno())
						Endif
					Endif
				ElseIf nTipoBusca == 2 .or. nTipoBusca == 3  //Base na data da realizacao
					If !Empty(TM5->TM5_DTRESU)
						If TM5->TM5_DTRESU > dUltExame .or. SRA->RA_ADMISSA == dUltExame
							dUltExame := TM5->TM5_DTRESU
							nRecnoTm5 := TM5->(Recno())
						Endif
					Endif
				ElseIf nTipoBusca == 4 .or.; //Base na data de aniversário
					nTipoBusca == 5 .or.; //Base na data de admissao
					nTipoBusca == 6       //Base na data informada
					If !Empty(TM5->TM5_DTRESU)
						If TM5->TM5_DTRESU > dUltExame
							dUltExame := TM5->TM5_DTRESU
							nRecnoTm5 := TM5->(Recno())
						Endif
					Endif
				Endif

				DbSkip()
			EndDo
		ENDIF
	Endif

	If nRecnoTm5 > 0
		DbSelectArea("TM5")
		Dbgoto(nRecnoTm5)
	Endif

	RestArea( aAreaOld  )
Return (dUltExame)
//---------------------------------------------------------------------
/*/{Protheus.doc} NGUTILPRX
Obter a Data do Proximo Exame que devera ser realizado.
Recebe Data Ultimo Exame, Periodiciade do Exame.
Envia  Data de Programacao do Proximo Exame.

@param dUltExame Data do Ultimo Exame
@param nMeses Numerico Numero de meses a serem considerados

@author Marcio Luiz Costa
@since 17/02/2000
/*/
//---------------------------------------------------------------------
Function  NGUTILPRX(dUltExame,nMeses)
	nAnoUlt  := year(dUltExame)
	nMesUlt  := month(dUltExame)
	nDiaUlt  := day(dUltExame)
	nAnoProx := nAnoUlt
	nMesProx := 0
	nDiaProx := nDIaUlt
	nFrequen := nMeses
	nMesprox := nMesUlt + nFrequen

	Do While nMesProx  > 12
		nAnoProx := nAnoProx +1
		nMesProx := nMesProx - 12
	EndDo

	dPROXEXAM := CtoD( StrZero(nDiaProx,2) + "/" + StrZero(nMesProx,2) + "/"+ Str(nAnoProx,4) )
	Do While Empty(dProxExam)    // EQUANTO A DATA NAO FOR VALIDA O CAMPO FICA VAZIO.
		nDiaProx := nDiaProx -1
		dPROXEXAM := CtoD( StrZero(nDiaProx,2) + "/" + StrZero(nMesProx,2) + "/"+ Str(nAnoProx,4) )
	EndDo
Return (dProxExam)
//---------------------------------------------------------------------
/*/{Protheus.doc} NGMDT_H7
Obter Horario de trabalho do medico.

@param cCod Caracter Codigo do Calendario.

@return aDIA Array Com 3 Dimenssoes 1) Horario Inicial  ; 2) Horario Final ; 3) Horario Final

@author Paulo Pego
@since 17/02/2000
/*/
//---------------------------------------------------------------------
Function NGMDT_H7(cCod)

	Local aDIA    := {}, Hor, Qtd, Pos := 1, INI, FIM, Dia, Tot,x, i
	Local aOCI    := {}, lSIMULT := .T.
	Local nPreSel

	SH7->(DbSetOrder(1))
	SH7->(DbSeek(xFilial("SH7")))
	If !SH7->(DbSeek(xFilial("SH7") + cCod))
		Return aDIA
	EndIf

	aDia := {}
	Hor  := sh7->h7_aloc
	Qtd  := Len(Hor)/7

	nPreSel := Posicione("SX1",1,"MTA78001","X1_PRESEL") //X1_GRUPO

	If !Empty(nPreSel) .And. nPreSel != 1
		lSIMULT := .F.
	EndIf

	Rep := SubStr(Hor,pos,qtd)
	For i := 1 to 7
		Dia := SubStr(Hor,pos,qtd)
		Tot := 0
		Ini := 999
		Fim := 0
		pos+= qtd
		aOCI:= {}
		nOI := 999
		nOF := 0
		If (i < 6) .and. lSIMULT
			//Dia := Rep
		Endif
		For x := 1 to Len(Dia)
			If !Empty(SubStr(DIa,x,1))
				Tot += (1440/Len(Dia))
				Fim := ( (1440/Len(Dia)) * x )
				Ini := If(Ini == 999,(Fim - (1440/Len(Dia))),Ini)
				If nOI != 999
					AAdd(aOCI,{nOI, nOF})
					nOI := 999
					nOF := 0
				EndIf
			Else
				nOF := ( (1440/Len(Dia)) * x )
				nOI := If(nOI == 999,(nOF - (1440/Len(Dia))),nOI)
			Endif
		Next
		If nOI != 999
			AAdd(aOCI,{nOI, nOF})
			nOI := 999
			nOF := 0
		EndIf
		Ini := If(Ini == 999,0,Ini)
		AAdd(aDia,{MtoH(INI), MtoH(FIM), MtoH(TOT), aOCI })
	Next

Return aDIA

//---------------------------------------------------------------------
/*/{Protheus.doc} NEXTNUMASO
Obtem o proximo numero da ASO

@author Inacio Luiz Kolling
@since 24/03/2000
/*/
//---------------------------------------------------------------------
Function NEXTNUMASO( cFilSXE )

	Local cNumAso := ""

	Default cFilSXE := ""

	cNumAso	:= GETSXENUM( "TMY", "TMY_NUMASO", IIf( !Empty( cFilSXE ), cFilSXE, Nil ) )

	While MDTNumSQL( "TMY", "TMY_NUMASO", cNumAso )
		cNumAso := GETSXENUM( "TMY", "TMY_NUMASO", IIf( !Empty( cFilSXE ), cFilSXE, Nil ) )
	End

Return cNumAso

//---------------------------------------------------------------------
/*/{Protheus.doc} MEDIENFER
Valida o codigo do usuario ( medico ou infermeira(o)

@author Inacio Luiz Kolling
@since 24/03/2000
/*/
//---------------------------------------------------------------------
Function MEDIENFER()
	DbSelectArea("TMK")
	DbSetOrder(1)
	If !DbSeek(xFilial("TMK")+M->TMY_CODUSU) .Or. val(TMK->TMK_INDFUN) > 2
		Help(" ",1,"MSG_MEDIFE")
		Return .F.
	Endif
Return .t.
//---------------------------------------------------------------------
/*/{Protheus.doc} PERGBRW
Retorna o nome da pergunta (x3_inibrw -> TMI_PERGUN

@author Inacio Luiz Kolling
@since 06/04/2000
/*/
//---------------------------------------------------------------------
Function PERGBRW(cArq,nTipoVld)
	Local _RETOR
	Local aAreaOld  := GetArea()//Salva Área posicionada.
	Local lSigaMdtPS := If( SuperGetMv("MV_MDTPS",.F.,"N") == "S", .t. , .f. )
	Default nTipoVld := 1 //1=Init Brw 2=Relacao

	If lSigaMdtps
		nTMHi := NGRETORDEM("TMH","TMH_FILIAL+TMH_CLIENT+TMH_LOJA+TMH_QUESTI+TMH_QUESTA",.T.)
		If nTMHi == 0
			nTMHi := 1
		Endif
		IF cArq ="TMI"
			dbSelectArea("TMH")
			dbSetOrder(nTMHi)
			dbSeek(xFilial('TMH')+cCliMdtps+TMI->TMI_QUESTI+TMI->TMI_QUESTA)
			_RETOR := TMH->TMH_PERGUN
		ELSEIF cArq ="TO6"
			dbSelectArea("TMH")
			dbSetOrder(nTMHi)
			dbSeek(xFilial('TMH')+cCliMdtps+TO6->TO6_QUESTI+TO6->TO6_QUESTA)
			_RETOR := TMH->TMH_PERGUN
		ELSEIF cArq ="TOX"
			dbSelectArea("TMH")
			dbSetOrder(nTMHi)
			dbSeek(xFilial('TMH')+cCliMdtps+TOX->TOX_QUESTI+TOX->TOX_QUESTA)
			_RETOR := TMH->TMH_PERGUN
		ENDIF
	ELse
		IF cArq ="TMI"
			dbSelectArea("TMH")
			dbSetOrder(1)
			dbSeek(xFilial('TMH')+TMI->TMI_QUESTI+TMI->TMI_QUESTA)
			_RETOR := TMH->TMH_PERGUN
		ELSEIF cArq ="TO6"
			dbSelectArea("TMH")
			dbSetOrder(1)
			dbSeek(xFilial('TMH')+TO6->TO6_QUESTI+TO6->TO6_QUESTA)
			_RETOR := TMH->TMH_PERGUN
		ELSEIF cArq ="TOX"
			dbSelectArea("TMH")
			dbSetOrder(1)
			dbSeek(xFilial('TMH')+TOX->TOX_QUESTI+TOX->TOX_QUESTA)
			_RETOR := TMH->TMH_PERGUN
		ENDIF
	Endif

	RestArea( aAreaOld  )

Return _RETOR
//---------------------------------------------------------------------
/*/{Protheus.doc} NGVISUPOS
Posiciona no registro correspondente ao arquivo para visualizar

@param vARQUI -> Alias do arquivo para visualizar
@param vCHAVE -> Chave de acesso do arquivo

@author Inacio Luiz Kolling
@since 06/04/2000
/*/
//---------------------------------------------------------------------
Function NGVISUPOS(vARQUI,vCHAVE)
	Local aAreaOld  := GetArea()//Salva Área posicionada.

	dbSelectArea(vARQUI)
	dbSetOrder(1)
	DbSeek(xFilial(vARQUI)+vCHAVE)
	NGCAD01(vARQUI, RECNO(),2)
	RestArea( aAreaOld  )
Return
//---------------------------------------------------------------------
/*/{Protheus.doc} TMPNOMAGE
Mosta o nome do agente do TMP_NOMAGE no browse

@author Inacio Luiz Kolling
@since 12/04/2000
/*/
//---------------------------------------------------------------------
FUNCTION TMPNOMAGE(Vrisco)
	Local aAreaOld  := GetArea()//Salva Área posicionada.

	DbSelectArea("TN0")
	DbSetOrder(1)
	DbSeek(xFilial("TN0") + Vrisco)

	DbSelectArea("TMA")
	DbSetOrder(1)
	If !DbSeek(xFilial("TMA") + TN0->TN0_AGENTE)
		Return .f.
	Endif
	RestArea( aAreaOld  )
Return .t.
//---------------------------------------------------------------------
/*/{Protheus.doc} MOSTNOMAGE
Mosta o nome do agente do TMP_NOMAGE

@author Inacio Luiz Kolling
@since 12/04/2000
/*/
//---------------------------------------------------------------------
FUNCTION MOSTNOMAGE(Vrisco)
	Local aAreaOld  := GetArea()//Salva Área posicionada.
	Local cRet

	DbSelectArea("TN0")
	DbSetOrder(1)
	DbSeek(xFilial("TN0") + Vrisco)

	DbSelectArea("TMA")
	DbSetOrder(1)
	DbSeek(xFilial("TMA") + TN0->TN0_AGENTE)
	cRET := TMA->TMA_NOMAGE
	RestArea( aAreaOld  )
Return cRET
//---------------------------------------------------------------------
/*/{Protheus.doc} MOSTDESPAR
Mosta a descricao do parecer do TMY_INDPAR

@author Inacio Luiz Kolling
@since 12/04/2000
/*/
//---------------------------------------------------------------------
FUNCTION MOSTDESPAR(cINDPAR)
	Local cRet := Space(20)
	If cINDPAR = "1"
		cRET := STR0001 //'Apto'
	ElseIf cINDPAR == '2'
		cRET := STR0002 //'Inapto'
	Elseif cINDPAR == '3'
		cRET := STR0003 //'Apto Com Restrincoes'
	Endif
Return cRET

//---------------------------------------------------------------------
/*/{Protheus.doc} MOSTDESNAT
Mosta a descricao da natureza do TMY_NATEXA

@author Inacio Luiz Kolling
@since 12/04/2000
/*/
//---------------------------------------------------------------------
Function MOSTDESNAT( cNatExa )

	Local cRet := Space( 18 )

	If cNatExa = '1'
		cRet := STR0004 //"Admissional"
	ElseIf cNatExa = '2'
		cRet := STR0005 //"Periódico"
	ElseIf cNatExa = '3'
		cRet := STR0006 //"Mudança de Função"
	ElseIf cNatExa = '4'
		cRet := STR0007 //"Retorno ao Trabalho"
	ElseIf cNatExa = '5'
		cRet := STR0008 //"Demissional"
	ElseIf cNatExa = '6'
		cRet := STR1546 //"Monitoração Pontual"
	EndIf

Return cRet

//---------------------------------------------------------------------
/*/{Protheus.doc} VALMDR410
Validacao da pergunta do MDR410 ate pergunta

@author Inacio Luiz Kolling
@since 07/06/2000
/*/
//---------------------------------------------------------------------
FUNCTION VALMDR410(cmvpar01,cmvpar04,cmvpar05)

	If cmvpar05 < cmvpar04
		Help(" ",1,"DEATEINVAL")
		return .f.
	Else
		If !ExistCpo("TMH",cmvpar01+cmvpar05)
			return .f.
		Endif
	Endif
Return .t.
//---------------------------------------------------------------------
/*/{Protheus.doc} GETBROWTNJ
Validacao do campo TNJ_NUMRIS

@author Denis
@since 07/06/2000
/*/
//---------------------------------------------------------------------
Function GETBROWTNJ( cnumris, nnum )

	Local _ret 	   := space(20)
	Local aAreaOld := GetArea()//Salva Área posicionada.
	Local lPrest   := .F.
	Local nPosAge  := 0

	If nnum == 1
		nPosAge  := aScan( oGetDad:aHeader, { |x| AllTrim( Upper(x[2]) ) == "TNJ_NOMAGE"})
	EndIf

	If Type("cCliMdtPs") == "C"
		If !Empty(cCliMdtPs)
			lPrest := .T.
		Endif
	Endif

	dbSelectArea("TN0")
	dbSetOrder(1)
	If dbSeek(xFilial("TN0")+cnumris)
		dbSelectArea("TMA")
		dbSetOrder(1)
		If dbSeek(xFilial("TMA")+TN0->TN0_AGENTE)
			_RET := SubStr(TMA->TMA_NOMAGE,1,20)
		Endif
	Endif

	RestArea( aAreaOld  )
	If nnum == 1 // Se For validação
		If lPrest
			If !EXISTCPO("TN0",cCliMdtps+M->TNJ_NUMRIS,8)
				Return .F.
			Endif
		Else
			If !EXISTCPO("TN0",M->TNJ_NUMRIS)
				Return .F.
			Endif
		Endif
		aCols[oGetDad:oBrowse:nAt,nPosAge] := _RET
		Return .T.
	Else //Se for inicializador padrão do nome risco
		Return _RET
	Endif

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MdtDtRf190
Verifica se habilita o campo TMW_DTREFE

@author Denis
@since 04/08/2008
/*/
//---------------------------------------------------------------------
Function MdtDtRf190()
	If Type("lReprog") == "L"
		If lReprog .and. Empty(TMW->TMW_BASEDT)
			Return .t.
		ElseIf !lReprog .and. M->TMW_BASEDT="6"
			Return .t.
		Else
			Return .f.
		Endif
	Endif
Return .t.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTLOAD
Função executada para interações na abertura de sistema

@author Deivys Joenck
@since 19/10/2001
/*/
//---------------------------------------------------------------------
Function MDTLOAD()

	Local cErrosTMJ	 := GetNextAlias()
	Local cCamposTJB := GetNextAlias()
	Local cAliasTNH  := GetNextAlias()
	Local cTMJFil	 := xFilial("TMJ")
	Local cTJBFil    := xFilial("TJB")

	//Função para popular tabela TMY com dados da TY7 (Atestado ASO)
	//Criado um arquivo .TXT para controlar a execução
	MdtAjBase(cEmpAnt, cFilAnt, RetCodUsr(), cModulo)

	// Valida o tamanho dos campos de Código de Ambiente
	fVldCpoAmb()

	//Implementa nas tabelas TQC e TQD todas as opcoes do clique da direita
	NGTQCTQD()

	//Implementa nas tabelas TQC e TQD todas as opcoes do clique da direita (Exclusivo MDT)
	MdtClickR()

	//Eventos CIPA
	MDTA111(.T.)

	//Lembretes para Usuarios do Sistema
	fAgendaLem()

	//Cria automaticamente exame NR7 (Exame Clinico)
	fCriaNR7()

	//População dos eventos de inspeção (TK4)
	MdtEv13()

	//Alteração de Dicionário
	fAtuDic()

	//Gera a tabela TYZ caso ela não tenha sido criada pelo RUP_MDT
	fGeraTYZ()

	//Função para ajuste das informações já existentes no campo TNF_HRENTR
	fAtuSegEpi()

	//Função de ajuste das informações de Filial, CC, Funcao e CBO do Diagnóstico
	Processa( { | lEnd | fAtuFunDia() } )

	//Popula a tabela TYD (ASO x Tarefas)
	fGeraTYD()

	//Ajusta registros da TMJ que tenham sido gerados sem horario de início, sem matrícula ou sem duração
	If TMJ->(ColumnPos("TMJ_QTDHRS")) > 0

		BeginSQL Alias cErrosTMJ
			SELECT TMJ.TMJ_FILIAL, TMJ.TMJ_CODUSU, TMJ.TMJ_DTCONS, TMJ.TMJ_HRCONS
				FROM %table:TMJ% TMJ
			WHERE
				TMJ.TMJ_FILIAL = %exp:cTMJFil% AND
				TMJ.%notDel% AND
				(TMJ.TMJ_NUMFIC = '' OR
				TMJ.TMJ_HRCONS = '  :  ' OR
				TMJ.TMJ_QTDHRS = '00:00' OR
				TMJ.TMJ_QTDHRS = '')
		EndSQL

		dbSelectarea( cErrosTMJ )
		If ( cErrosTMJ )->( !EoF() ) .And. ( cErrosTMJ )->( !BoF() )
			Processa( { |lEnd| fAjusteTMJ( cTMJFil ) } , STR1430 )
		EndIf
		( cErrosTMJ )->( dbCloseArea() )

	EndIf

	//Passa conteúdo dos campos antigos da tabela TJB(Produto químico) e passa para os novos do tipo MEMO

	BeginSQL Alias cCamposTJB

		SELECT TJB.TJB_FILIAL, TJB.TJB_CODPRO
			FROM %table:TJB% TJB
		WHERE
			TJB.TJB_FILIAL = %exp:cTJBFil% AND
			TJB.%notDel% AND
			(TJB.TJB_RISCOS <> '' OR
			TJB.TJB_CARACT <> '' OR
			TJB.TJB_PRCATI <> '' OR
			TJB.TJB_ESTOCA <> '' OR
			TJB.TJB_DESCAR <> '' OR
			TJB.TJB_TRANSP <> '' OR
			TJB.TJB_LOCAL  <> '')

	EndSQL

	dbSelectarea( cCamposTJB )
	If ( cCamposTJB )->( !EoF() ) .And. ( cCamposTJB )->( !BoF() )
		fMemoTJB( cCamposTJB )
	EndIf
	( cCamposTJB )->( dbCloseArea() )

	If cPaisLoc <> "RUS"
		// Ajusta informações do TNH_ESOC
		BeginSQL Alias cAliasTNH
			SELECT TNH_FILIAL, TNH_CODOBJ
				FROM %table:TNH% TNH
				WHERE TNH.TNH_ESOC = '' AND TNH.TNH_ESOC1 <> ''
		EndSQL

		dbSelectArea( cAliasTNH )
		If ( cAliasTNH )->( !EoF() ) .And. ( cAliasTNH )->( !BoF() )
			Processa( { |lEnd| fAjusteTNH( cAliasTNH ) } , STR1430 )
		EndIf
	EndIf

	If ExistBlock("MDTLOAD1")
		ExecBlock("MDTLOAD1",.F.,.F.)
	Endif

	aArea := GetArea()
	If AliasInDic("TKP")
		dbSelectArea("TKP")
		dbSetOrder(1)
		If !dbSeek(xFilial("TKP"))
			MDTSBIS()
		Endif
		dbSelectArea( "TKP" )
		dbSetOrder( 1 )
		If dbSeek( xFilial( "TKP" ) + "MDTR700" )
			RecLock( "TKP" , .F. )
			TKP->( dbDelete() )
			TKP->( MsUnLock() )
		EndIf
		dbSelectArea( "TKP" )
		dbSetOrder( 1 )
		If dbSeek( xFilial( "TKP" ) + "MDTA070" )
			RecLock( "TKP" , .F. )
			TKP->( dbDelete() )
			TKP->( MsUnLock() )
		EndIf
		dbSelectArea( "TKP" )
		dbSetOrder( 1 )
		If dbSeek( xFilial( "TKP" ) + "MDTA680" )
			RecLock( "TKP" , .F. )
			TKP->( dbDelete() )
			TKP->( MsUnLock() )
		EndIf
	Endif
	RestArea(aArea)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fAtuDic
Ajusta campos do SX3

@author Luis Fellipy Bett
@since 29/06/2017
/*/
//---------------------------------------------------------------------
Static Function fAtuDic()

	//Retiradas todas a mudanças de dicionário e cadastradas no pacote 005020, para atender as regras do Sonarqube.
	If !AliasInDic('TYH')

		ShowHelpDlg( STR1451 ,     ; // "ATENÇÃO!"
		{ STR1452 }, 2, ; // "O dicionário de dados está desatualizado, o que pode comprometer a utilização de algumas rotinas."
		{ STR1453 }, 2 )  // "Favor aplicar as atualizações contidas no pacote da issue DNG-1847"
	EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fVldCpoAmb
Valida o tamanho dos campos de Código de Ambiente Físico

@author  Luis Fellipy Bett
@since   26/08/2019
/*/
//-------------------------------------------------------------------
Static Function fVldCpoAmb()

	Local nCont		:= 0
	Local cCampos	:= ""
	Local aCampos	:= { "TNE_CODAMB" , "TYG_CODAMB" , "TI7_CODAMB" ,;
		"TAF_CODAMB" , "TII_CODAMB" , "TIJ_CODAMB" ,;
		"TN0_CODAMB" , "TNK_CODAMB" , "TO5_CODAMB" ,;
		"TNC_CODAMB" , "TI0_LOCTRA" , "TJ1_AMB"	,;
		"TJ2_AMB"	  , "TJ5_AMB"	 }

	If GetRPORelease() == '12.1.025'
		For nCont := 1 To Len( aCampos )
			If TAMSX3( aCampos[ nCont ] )[1] <> 30
				cCampos += aCampos[ nCont ] + CRLF
			EndIf
		Next nCont
		If !Empty( cCampos )
			//"Os campos de código de ambiente físico tiveram seus tamanhos alterados de forma indevida"
			//"Para mais informações acesse a documentação no link abaixo"
			//"Campos""##Os campos de Código Ambiente Físico abaixo devem ser atualizados"
			MDTMSGLINK(STR1473,STR1474,"https://tdn.totvs.com/x/QIV9Hg",STR1472,{STR1475,cCampos})
			Final()
		EndIf
	EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTMSGLINK
Cria uma tela padrão de exibição de Inconsistências

@param [cMsg1], Caracter, Mensagem 1 a ser exibida
@param [cMsg2], Caracter, Mensagem 2 a ser exibida
@param [cLink], Caracter, Link da Documentação Liberada
@param [cTitulo], Caracter, Título do botão de Log
@param [aLogTx], Array, Título e conteúdo do Log

@author  Jackson Machado
@since   14/06/2019
/*/
//-------------------------------------------------------------------
Function MDTMSGLINK( cMsg1, cMsg2, cLink, cTitulo, aLogTx )

	Local oDlg
	Local oFont1	:= TFont():New( "Tahoma", , -12, .T., .T. )

	Default cMsg1   := STR1466 // "Há atualizações de dicionário a serem avaliadas."
	Default cMsg2   := ''
	Default cLink   := 'http://tdn.totvs.com'
	Default cTitulo := STR1471 // Log
	Default aLogTx  := {}

	DEFINE MSDIALOG oDlg TITLE OemToAnsi( STR0078 ) FROM 0, 0 TO 200, 760 PIXEL // "ATENÇÃO"

	TSay():New( 010, 010, { | | OemToAnsi( cMsg1 ) }, oDlg, , oFont1, .F., .F., .F., .T., CLR_BLACK )
	TSay():New( 025, 010, { | | OemToAnsi( cMsg2 ) }, oDlg, , oFont1, .F., .F., .F., .T., CLR_BLACK )
	TSay():New( 045, 010, { | | OemToAnsi( STR1463 ) }, oDlg, , oFont1, .F., .F., .F., .T., CLR_BLACK ) //"Consulte mais informações sobre esta alteração no TDN:"
	TGet():New( 060, 010, { | | cLink }, oDlg, 195, 09, "@!", , , , , , , .T., , , , , , , .T. )

	TButton():New( 060, 230, OemToAnsi( STR1464 ), oDlg, { | | shellExecute( "Open", cLink, "", "", SW_NORMAL ) }, 030, 011, , , .F., .T., .F., , .F., , , .F. ) //"Abrir Link"

	If !Empty( aLogTx ) //Se houver, cria botão para mostrar Log
		TButton():New( 060, 270, OemToAnsi( cTitulo ), oDlg, { | | NGMSGMEMO(aLogTx[1], aLogTx[2]) }, 030, 011, , , .F., .T., .F., , .F., , , .F. )
		TButton():New( 060, 310, OemToAnsi( STR1465 ), oDlg, { | | oDlg:End() }, 030, 011, , , .F., .T., .F., , .F., , , .F. ) //Fechar
	Else
		TButton():New( 060, 270, OemToAnsi( STR1465 ), oDlg, { | | oDlg:End() }, 030, 011, , , .F., .T., .F., , .F., , , .F. ) //Fechar
	EndIf

	ACTIVATE MSDIALOG oDlg CENTER

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fAgendaLem
Agenda de lembretes para usuarios do SIGAMDT

@author Thiago Olis Machado
@since 10/09/2001
/*/
//---------------------------------------------------------------------
Static Function fAgendaLem()
	Local oDlg1, oCheck
	Local dData := dDataBase
	Local Time  := Substr(Time(),1,5)
	lUmaVez := .F.

	dbSelectArea("TNW")
	dbSetOrder(3)
	If dbSeek(xFilial("TNW")+Trim(cUserName)) .or. dbSeek(xFilial("TNW")+Trim(Upper(cUserName)))
		While !Eof() .and. xFilial("TNW") == TNW->TNW_FILIAL .and. (Trim(TNW->TNW_LOGIN) == Trim(cUserName);
				.or. Trim(Upper(TNW->TNW_LOGIN)) == Trim(Upper(cUserName)))
			lUmaVez := .F.
			If TNW->(FieldPos("TNW_CODIGO")) > 0
				If !Empty(TNW->TNW_CODIGO)
					DbSelectArea("TNW")
					DbSkip()
					Loop
				Endif
			Endif

			If TNW->TNW_DTINIC > dData
				DbSelectArea("TNW")
				DbSkip()
				Loop
			EndIf
			If TNW->TNW_DTINIC == dData .and. TNW->TNW_HRINIC > Time
				DbSelectArea("TNW")
				DbSkip()
				Loop
			EndIf
			If !Empty(TNW->TNW_DTFIM) .and. TNW->TNW_DTFIM < dData
				DbSelectArea("TNW")
				DbSkip()
				Loop
			EndIf
			If TNW->TNW_DTFIM == dData .and. (!Empty(TNW->TNW_HRFIM) .And. TNW->TNW_HRFIM < Time)
				DbSelectArea("TNW")
				DbSkip()
				Loop
			EndIf
			If TNW->TNW_MOSTRA == "1"
				DbSelectArea("TMK")
				DbSetOrder(1)
				IF DbSeek(xFilial("TMK")+TNW->TNW_CODUSU)
					cNome := TMK->TMK_NOMUSU

					DEFINE MSDIALOG oDlg1 TITLE STR0009+ cNome FROM 00,00 TO 400,420 PIXEL//"Mensagem para "

					cMemo := TNW->TNW_MENSAG
					@ 005,005 GET oMemo  VAR cMemo MEMO SIZE 200,150 OF oDlg1 PIXEL
					oMemo:lReadOnly:=.t.

					@180,010 checkbox oCheck Var lUmaVez Prompt OemToAnsi(STR0010) Size 95,7 OF ODLG1 PIXEL //"Não mostrar mais essa mensagem"

					DEFINE SBUTTON FROM 180,170 TYPE 1 ENABLE action GRAVA(oDlg1)
					ACTIVATE MSDIALOG oDlg1 CENTERED
				EndIf
			EndIF
			DbSelectArea("TNW")
			DbSkip()
		End
	EndIF
Return

Static Function Grava(oDlg1)
	If lUmaVez
		DbSelectArea("TNW")
		RecLock("TNW",.f.)
		TNW->TNW_MOSTRA := "2"
		MsUnlock("TNW")
	EndIf
	oDlg1:End()
Return
//---------------------------------------------------------------------
/*/{Protheus.doc} fCriaNR7
Criar o exame NR7 Automaticamente na abertura do sistema

@author Thiago Olis Machado
@since 05/04/2002
/*/
//---------------------------------------------------------------------
Static Function fCriaNR7()
	Local lSigaMdtPS := If( SuperGetMv("MV_MDTPS",.F.,"N") == "S", .t. , .f. )
	Local nTamExa		:= If(TAMSX3("TM4_EXAME")[1] < 1, 6, TAMSX3("TM4_EXAME")[1])

	dbSelectArea("TM4")
	dbSetOrder(1)
	If !dbSeek( xFilial("TM4") + PadR("NR7", nTamExa, Space(1)) )
		RecLock("TM4",.t.)
		TM4->TM4_FILIAL := xFilial("TM4")
		TM4->TM4_EXAME  := "NR7"
		TM4->TM4_NOMEXA := STR0011 //"AVALIACAO CLINICA"
		TM4->TM4_DESEXA := STR0011 //"AVALIACAO CLINICA"
		TM4->TM4_INDRES := "1"
		TM4->TM4_ADMISS := "1"
		TM4->TM4_DEMISS := "1"
		TM4->TM4_RETORN := "1"
		MsUnlock("TM4")
	EndIf

	If lSigaMdtPS
		dbSelectArea("SB1")
		dbSetOrder(01)
		If !dbseek(xFilial("SB1")+ Padr("MDTENR7", Len(SB1->B1_COD)) )
			RecLock("SB1",.T.)
			SB1->B1_FILIAL   := xFilial("SB1")
			SB1->B1_COD      := "MDTENR7"
			SB1->B1_DESC     := STR0011 //"AVALIACAO CLINICA"
			SB1->B1_UM       := "UN"
			SB1->B1_LOCPAD   := "01"
			SB1->(MsUnlock())
		EndIf
	Endif

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} ExCpoMDT
Valida a existencia do codigo na tabela selecionada

@author Denis Hyroshi de Souza
@since 05/04/2002
/*/
//---------------------------------------------------------------------
Function ExCpoMDT(cTabela, cValor, nOrd, lMsgem, lBloq)

	Local lValid := .T.
	Local nOrdem := 1
	Local lMsgBox := .t.
	Local cCampoBLQ := PrefixoCpo(cTabela)+"_MSBLQL"
	Local cMSBLQL := ""
	Local lRelMDT := .F.
	Local nTamSRA := TAMSX3("RA_MAT")[1]

	// Adequa a variavel ao tamanho do campo para não ocorrer problemas em buscas
	If cTabela == "SRA"
		cValor := SubStr(cValor, 1, nTamSRA )
	EndIf

	Default lBloq := .T.

	If ValType(nOrd)=="N" .And. nOrd > 0
		nOrdem := nOrd
	Endif

	If ValType(lMsgem)=="L"
		lMsgBox := lMsgem
	Endif

	If SubStr(Alltrim(FunName()),1,4) == "MDTR"
		lRelMDT := .T.
	Endif

	dbSelectArea(cTabela)
	dbSetOrder(nOrdem)

	If !dbSeek( xFilial( cTabela ) + cValor )
		lValid := .F.

		If lMsgBox
			Help( " ", 1, "REGNOIS" )
		Endif

	ElseIf !lRelMDT .And. lBloq .And. FieldPos( cCampoBLQ ) > 0 // Verifica se o registro nao esta bloqueado
		cMSBLQL := &(cTabela+"->"+cCampoBLQ)

		If cMSBLQL == "1"
			lValid := .F.
		Endif

		If lMsgBox .and. !lValid
			Help( " ", 1, "REGBLOQ", , , 1, 0 )
		Endif

	Endif

Return lValid

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTProEpi
Verifica se um produto existe no cadastro de produtos, e se ele eh um EPI.

@param cCODEPI Caracter Codigo do EPI a ser validado
@param cTipoEPI Caracter Tipo que define se um produto eh EPI. O valor padrao eh o valor do parametro MV_MDTPEPI
@param lExistSX5 Logico Indica se o tipo definido no parametro MV_MDTPEPI existe na tabela generica "02" (dentro do SX5). Esta tabela contem todos os tipos de produtos que podem ser utilizados no campo B1_TIPO

@return lRet Logico

@author Andre E. Perez Alvarez
@since 27/09/2006
/*/
//---------------------------------------------------------------------
Function MDTProEpi( cCODEPI, cTipoEPI, lExistSX5 )

	Local aArea := GetArea()
	Local aAreaSB1 := SB1->( GetArea() )
	Local lRet := .T.

	//--------------------------------------------------------------------------
	// O tipo definido no parametro deve estar cadastrado na tabela generica "02"
	// (que contem os tipos de produtos).
	//--------------------------------------------------------------------------
	If !Empty( cTipoEPI ) .AND. ( lExistSX5 )
		DbSelectArea("SB1")
		DbSetOrder(1)
		DbSeek(XFILIAL("SB1")+cCODEPI)
		If ExistCpo("SB1",cCODEPI)
			If !( SB1->B1_TIPO $ cTipoEPI )
				MsgStop(;
					STR0020 + CHR(13)+CHR(10) +; //"Este produto não está cadastrado como EPI."
				STR0021 + CHR(13)+CHR(10) +; //'Para definí-lo como EPI, no cadastro de produtos'
				STR0022 + CHR(13)+CHR(10) +; //'é preciso definir o seu tipo (campo B1_TIPO) de acordo'
				STR0023 + CHR(13)+CHR(10) +; //'com o parâmetro MV_MDTPEPI. Este parâmetro define o tipo'
				STR0024 + CHR(13)+CHR(10) +; //'EPI. O valor deste parâmetro deve estar cadastrado na'
				STR0025 + CHR(13)+CHR(10) +; //'tabela genérica "02", que é a tabela que contém todos os'
				STR0026 + CHR(13)+CHR(10)  ; //'tipos de produto.'
				)
				lRet := .F.
			Endif
		Else
			lRet := .F.
		Endif

		//--------------------------------------------------------------------------
		// Se o parametro nao estiver configurado,
		// OU se o valor dele nao existir na tabela generica "02",
		// considera todos os produtos como sendo EPI.
		//--------------------------------------------------------------------------

	Else
		If !ExistCpo("SB1",cCODEPI)
			lRet := .F.
		Endif
	Endif

	//Valida se o EPI está vinculado a algum Fornecedor
	If !( "TN3_CODEPI" $ ReadVar() ) .And. !( "TL0_EPIFIL" $ ReadVar() )//Não valida se for a inclusão de EPI por Fornecedor
		If lRet
			dbSelectArea( "TN3" )
			dbSetOrder( 2 )
			lRet := dbSeek( xFilial( "TN3" ) + cCodEPI )
		EndIf
		//Valida se o EPI está vinculado a algum Pai (EPI Genérico)
		If !lRet
			dbSelectArea( "TL0" )
			dbSetOrder( 2 )
			lRet := dbSeek( xFilial( "TL0" ) + cCODEPI )
		EndIf

		If !lRet

			//------------------------------------------------------------------------------------
			// "Atenção"
			// "Equipamento de proteção individual informado não possui certificado de aprovação"
			// "Vincular o equipamento a um fornecedor"
			//------------------------------------------------------------------------------------

			Help( Nil, Nil, STR0013, Nil, STR1554 + '.', 1, 0, Nil, Nil, Nil, Nil, .T., { STR1555 + '.' } )

		EndIf

	EndIf

	RestArea( aAreaSB1 )
	RestArea( aArea )

Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} MdtAltFicha
Alterações de integracao do SIGAMDT com o SIGAGPE

@param cFilSRA, Caracter - Filial do Funcionario
@param cMatSRA, Caracter - Matricula do Funcionario

@obs SIGAGPE

@author Denis Hyroshi de Souza
@since 21/12/2005
/*/
//---------------------------------------------------------------------
Function MdtAltFicha( cFilSRA, cMatSRA )

	Local aAreaXXX := GetArea()
	Local aAreaTM0 := TM0->(GetArea())
	Local cIntegra := GetMv("MV_MDTGPE")
	Local cQuery, cAliasTRB := GetNextAlias()
	Local cOpcComb := ""

	Private lDefisTM0 := NGCADICBASE("TM0_TIPDEF","A","TM0",.F.)
	Private lMteste 	:= NGCADICBASE("TNC_MTEST1","A","TNC",.F.)

	If ValType(cIntegra) == "C" .And. cIntegra == "S"
		Dbselectarea("TM0")
		Dbsetorder(3) //TM0_FILFUN + TM0_MAT + TM0_NUMDEP
		If Dbseek(xFilial("SRA",cFilSRA)+cMatSRA)
			Reclock("TM0",.f.)
			If Type("M->RA_CODFUNC") == "C"
				TM0->TM0_CODFUN := M->RA_CODFUNC
			Endif
			If Type("M->RA_CC") == "C" .and. Empty(TM0->TM0_CC)
				TM0->TM0_CC := M->RA_CC
			Endif
			If NGCADICBASE( "TM0_DEPTO", "A" , "TM0" , .F. ) .And. Type("M->RA_DEPTO") == "C"
				TM0->TM0_DEPTO := M->RA_DEPTO
			Endif
			If Type("M->RA_NOME") == "C"
				If !Empty(M->RA_NOME)
					TM0->TM0_NOMFIC := M->RA_NOME
				Endif
			Endif
			If Type("M->RA_NASC") == "D"
				If !Empty(M->RA_NASC)
					TM0->TM0_DTNASC := M->RA_NASC
				Endif
			Endif
			If Type("M->RA_RG") == "C"
				TM0->TM0_RG := M->RA_RG
			Endif
			If Type("M->RA_CIC") == "C" .and. TM0->(FieldPos("TM0_CPF")) > 0
				TM0->TM0_CPF := M->RA_CIC
			Endif
			If Type("M->RA_ESTCIVI") == "C" .and. TM0->(FieldPos("TM0_ESTCIV")) > 0
				TM0->TM0_ESTCIV := M->RA_ESTCIVI
			Endif
			If Type("M->RA_SEXO") == "C"
				TM0->TM0_SEXO := If( M->RA_SEXO == "M" , "1" , "2" )
			Endif
			If Type("M->RA_RACACOR") == "C"
				If !Empty( M->RA_RACACOR )
					If M->RA_RACACOR == "1" //Indigena
						cOpcComb := "5"
					ElseIf M->RA_RACACOR == "2" //Branco
						cOpcComb := "1"
					ElseIf M->RA_RACACOR == "4" //Negro
						cOpcComb := "2"
					ElseIf M->RA_RACACOR == "6" //Amarelo
						cOpcComb := "4"
					ElseIf M->RA_RACACOR == "8" //Pardo
						cOpcComb := "3"
					EndIf
					TM0->TM0_CORPEL := cOpcComb
				EndIf
			EndIf
			If Type("M->RA_NUMCP") == "C"
				TM0->TM0_NUMCP := M->RA_NUMCP
			EndIf
			If Type("M->RA_SERCP") == "C"
				TM0->TM0_SERCP := M->RA_SERCP
			EndIf
			If Type("M->RA_UFCP") == "C"
				TM0->TM0_UFCP := M->RA_UFCP
			EndIf
			If Type("M->RA_CTPCD") == "C" .And. TM0->(ColumnPos("TM0_CTPCD")) > 0
				TM0->TM0_CTPCD	:= M->RA_CTPCD
			EndIf
			MsunLock("TM0")
		Else
			MdtAltTrf(cFilSRA,cMatSRA)
		Endif
		If lDefisTM0
			Dbselectarea("TM0")
			Dbsetorder(3)
			If Dbseek(xFilial("SRA",cFilSRA)+cMatSRA)
				Reclock("TM0",.f.)
				If Type("M->RA_TPDEFFI") == "C"
					TM0->TM0_TIPDEF := M->RA_TPDEFFI
				EndIf
				MsunLock("TM0")
			EndIf
		EndIf
		If lMteste
			cQuery := "SELECT TNC_ACIDEN ,TNC_MTEST1, TNC_MTEST2 "
			cQuery += "FROM " + RetSqlName("TNC") + " "
			cQuery += "WHERE D_E_L_E_T_ != '*' AND "
			cQuery += "TNC_FILIAL = '" + xFilial("TNC") + "' AND "
			cQuery += "(TNC_MTEST1 = '" + cMatSRA + "' OR TNC_MTEST2 = '" + cMatSRA + "')"

			cQuery := ChangeQuery(cQuery)
			MPSysOpenQuery( cQuery , cAliasTRB )

			dbSelectArea(cAliasTRB)
			dbGotop()
			While !Eof()
				dbSelectArea("TNC")
				dbSetOrder(1)
				If dbSeek(xFilial("TNC")+(cAliasTRB)->TNC_ACIDEN)
					RecLock("TNC",.F.)
					If TNC->TNC_MTEST1 == cMatSRA
						TNC->TNC_TESTE1 := SRA->RA_NOME
						TNC->TNC_ENDTE1 := SRA->RA_ENDEREC
						TNC->TNC_BAIRR1 := SRA->RA_BAIRRO
						TNC->TNC_CIDAD1 := SRA->RA_MUNICIP
						TNC->TNC_CEP1   := SRA->RA_CEP
						TNC->TNC_ESTAD1 := SRA->RA_ESTADO
						TNC->TNC_TELEF1 := SRA->RA_TELEFON
					ElseIf TNC->TNC_MTEST2 == cMatSRA
						TNC->TNC_TESTE2 := SRA->RA_NOME
						TNC->TNC_ENDTE2 := SRA->RA_ENDEREC
						TNC->TNC_BAIRR2 := SRA->RA_BAIRRO
						TNC->TNC_CIDAD2 := SRA->RA_MUNICIP
						TNC->TNC_CEP2   := SRA->RA_CEP
						TNC->TNC_ESTAD2 := SRA->RA_ESTADO
						TNC->TNC_TELEF2 := SRA->RA_TELEFON
					EndIf
					TNC->(MsUnLock())
				EndIf
				dbSelectArea(cAliasTRB)
				dbSkip()
			End
		EndIf

	EndIf

	RestArea(aAreaTM0)
	RestArea(aAreaXXX)

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MdtTransFicha
Transferencia dos dados do MDT ao transferir pelo GPE

@obs SIGAGPE

@author Denis Hyroshi de Souza
@since 21/12/2005
/*/
//---------------------------------------------------------------------
Function MdtTransFicha(cOemp, cDemp, cOfil, cDfil, cOmat, cDmat, cOcc, cDcc, cODepto, cDDepto)
	Local aAreaXXX := GetArea()
	Local aAreaTM0 := TM0->(GetArea())
	Local cIntegra := " "
	Local cCondTAF := ""
	Local lFunc	   := FindFunction("FWModeAccess")
	Local lDepto   := NGCADICBASE( "TM0_DEPTO", "A" , "TM0" , .F. )
	// Guarda a expressao atual da tabela SRA pois a partr do P12
	// é possível filtrar os funcionários, com isso é necessário limpar
	// o filtro antes de realizar as tratativas de MDT
	Local cFilSRA  := SRA->( dbFilter() )

	If lFunc
		cCond    := "FWModeAccess('TM0') == 'C'"
		cCondTAF := "FWModeAccess('TN0') == 'C'"
	Else
		cCond    := "Empty(xFilial('TM0'))"
		cCondTAF := "Empty(xFilial('TN0'))"
	EndIf

	cIntegra := GetMv("MV_MDTGPE")

	If ValType(cIntegra) == "C" .And. cIntegra == "S"
		//Limpa o Filtro da SRA para conseguir trabalhar com todos os registros
		dbSelectArea("SRA")
		Set Filter To
		If cOemp == cDemp .And. cOfil == cDfil .And. (cOcc <> cDcc .Or. cOmat <> cDmat .Or. If(lDepto,(cODepto <> cDDepto),.F.))
			//Atualiza  Matricula e Centro de Custo
			dbSelectArea("TM0")
			dbSetOrder(3)

			If dbSeek(xFilial("SRA",cOfil) + cOmat)
				Reclock("TM0", .F.)
				TM0->TM0_CC    := cDcc
				TM0->TM0_DEPTO := cDDepto
				TM0->TM0_MAT   := cDmat
				MsunLock("TM0")
			EndIf

			dbSelectArea("SRB")
			dbSetOrder(1)
			dbSeek(xFilial("SRB") + cOmat)

			while !Eof() .And. SRB->RB_FILIAL == xFilial("SRB") .And. SRB->RB_MAT == cOmat
				dbSelectArea("TM0")
				dbSetOrder(3)
				If dbSeek(cOfil+SRB->RB_MAT+SRB->RB_COD)
					Reclock("TM0",.f.)
					TM0->TM0_CC  := cDcc
					TM0->TM0_DEPTO := cDDepto
					TM0->TM0_MAT := cDmat
					MsUnLock("TM0")
				Endif
				dbSelectArea('SRB')
				dbSkip()
			End

		ElseIf cOemp == cDemp .And. (cOfil <> cDfil .Or. cOmat <> cDmat) .And. &(cCond)
			//Atualiza Filial, Matricula e Centro de Custo
			dbSelectArea("TM0")
			dbSetOrder(3)

			If !dbSeek(xFilial("SRA",cDfil)+cDmat)
				dbSelectArea("TM0")
				dbSetOrder(3)

				If dbSeek( xFilial("SRA",cOfil) + cOmat )
					Reclock("TM0",.f.)
					TM0->TM0_CC     := cDcc
					TM0->TM0_DEPTO  := cDDepto
					TM0->TM0_MAT    := cDmat
					TM0->TM0_FILFUN := cDfil
					MsunLock("TM0")
				EndIf

			EndIf

			dbSelectArea("SRB")
			dbSetOrder(1)
			dbseek(xFilial("SRB",cOfil) + cOmat)

			while !Eof() .And. SRB->RB_FILIAL == cOfil .And. SRB->RB_MAT == cOmat
				dbSelectArea("TM0")
				dbSetOrder(3)

				If dbSeek(cOfil + SRB->RB_MAT + SRB->RB_COD)
					Reclock("TM0",.f.)
					TM0->TM0_CC     := cDcc
					TM0->TM0_MAT    := cDmat
					TM0->TM0_DEPTO  := cDDepto
					TM0->TM0_FILFUN := cDfil
					MsunLock("TM0")
				Endif

				dbSelectArea('SRB')
				dbSkip()
			End

		ElseIf SuperGetMv("MV_NG2TRAN",.F.,"1") == "1" // Transfere os dados do MDT para outra empresa/filial
			AutoMdt970(cOemp, cDemp, cOfil, cDfil, cOmat, cDmat, cOcc, cDcc, cODepto, cDDepto)
		EndIf

		//Retorna o filtro da tabela SRA
		dbSelectArea("SRA")
		Set Filter To &(cFilSRA)
	EndIf

	RestArea(aAreaTM0)
	RestArea(aAreaXXX)

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MdtValESb1
Altera a funcao e c.custo da ficha do funcionario

@param cCod Caracter Codigo do produto

@obs SIGAEST

@author Denis Hyroshi de Souza
@since 21/12/2005
/*/
//---------------------------------------------------------------------
Function MdtValESb1(cCod)
	Local lPodeAPagar := .t.
	Local nBusca
	Local aFiliais
	Local aArea := GetArea()
	Local aSM0CodFil := {}
	Local lFunc	   := FindFunction("FWModeAccess")
	Local lSigaMdtPS := If( SuperGetMv("MV_MDTPS",.F.,"N") == "S", .t. , .f. )
	Local nTamCod := If((TAMSX3("B1_COD")[1]) < 1,15,(TAMSX3("B1_COD")[1]))

	dbSelectArea("SM0")
	aAreaSM0 := GetArea()
	dbGoTop()
	do While ! Eof()
		If SM0->M0_CODIGO == cEmpAnt
			Aadd(aSM0CodFil, SM0->M0_CODFIL)
		Endif
		dbSkip()
	Enddo
	RestArea(aAreaSM0)

	//Verificacoes nas tabelas do modulo SIGAMDT - Medicina e Seguranca do Trabalho
	dbSelectArea("TN3") //Fornecedores de Epi
	dbSetOrder(2)
	If lFunc
		cCond := "FWModeAccess('TN3') == 'E' .and. FWModeAccess('SB1') == 'C'"
	Else
		cCond := "!Empty(xFilial()) .and. Empty(xFilial('SB1'))"
	Endif

	aFiliais := If(&(cCond), aClone(aSM0CodFil), {xFilial()})
	For nBusca := 1 to Len(aFiliais)
		dbSeek(aFiliais[nBusca]+cCod)
		If Found()
			HELP(" ",1,STR0013,STR0013,STR0014+CHR(13)+CHR(10)+STR0015,3,4) //"ATENCAO"###"ATENCAO"###"O produto não pode ser excluido por"###"fazer parte de Fornecedores de Epi"
			dbSelectArea("SB1")
			MsUnLock()
			lPodeApagar := .F.
			Exit
		EndIf
	Next nBusca

	If !lPodeAPagar
		RestArea(aArea)
		Return .t.
	Endif

	dbSelectArea("TNB") //Epi x Funcao
	dbSetOrder(3)
	If lFunc
		cCond := "FWModeAccess('TNB') == 'E' .and. FWModeAccess('SB1') == 'C'"
	Else
		cCond := "!Empty(xFilial()) .and. Empty(xFilial('SB1'))"
	Endif

	aFiliais := If(&(cCond), aClone(aSM0CodFil), {xFilial()})
	For nBusca := 1 to Len(aFiliais)
		dbSeek(aFiliais[nBusca]+cCod)
		If Found()
			HELP(" ",1,STR0013,STR0013,STR0014+CHR(13)+CHR(10)+STR0016,3,4) //"ATENCAO"###"ATENCAO"###"O produto não pode ser excluido por"###"fazer parte de Epi x Função"
			dbSelectArea("SB1")
			MsUnLock()
			lPodeApagar := .F.
			Exit
		EndIf
	Next

	If !lPodeAPagar
		RestArea(aArea)
		Return .t.
	Endif

	dbSelectArea("TNF") //Epi x Funcionario
	dbSetOrder(2)
	If lFunc
		cCond := "FWModeAccess('TNF') == 'E' .and. FWModeAccess('SB1') == 'C'"
	Else
		cCond := "!Empty(xFilial()) .and. Empty(xFilial('SB1'))"
	Endif

	aFiliais := If(&(cCond), aClone(aSM0CodFil), {xFilial()})
	For nBusca := 1 to Len(aFiliais)
		dbSeek(aFiliais[nBusca]+cCod)
		If Found()
			HELP(" ",1,STR0013,STR0013,STR0014+CHR(13)+CHR(10)+STR0017,3,4) //"ATENCAO"###"ATENCAO"###"O produto não pode ser excluido por"###"fazer parte de Epi x Funcionario"
			dbSelectArea("SB1")
			MsUnLock()
			lPodeApagar := .F.
			Exit
		EndIf
	Next

	If !lPodeAPagar
		RestArea(aArea)
		Return .t.
	Endif

	dbSelectArea("TOH") //Epi x Centro de Custo
	dbSetOrder(2)
	If lFunc
		cCond := "FWModeAccess('TOH') == 'E' .and. FWModeAccess('SB1') == 'C'"
	Else
		cCond := "!Empty(xFilial()) .and. Empty(xFilial('SB1'))"
	Endif

	aFiliais := If(&(cCond), aClone(aSM0CodFil), {xFilial()})
	For nBusca := 1 to Len(aFiliais)
		dbSeek(aFiliais[nBusca]+cCod)
		If Found()
			HELP(" ",1,STR0013,STR0013,STR0014+CHR(13)+CHR(10)+STR0018,3,4) //"ATENCAO"###"ATENCAO"###"O produto não pode ser excluido por"###"fazer parte de Epi x Centro de Custo"
			dbSelectArea("SB1")
			MsUnLock()
			lPodeApagar := .F.
			Exit
		EndIf
	Next

	If !lPodeAPagar
		RestArea(aArea)
		Return .t.
	Endif

	dbSelectArea("TNX") //Epi x Risco
	dbSetOrder(3)
	If lFunc
		cCond := "FWModeAccess('TNX') == 'E' .and. FWModeAccess('SB1') == 'C'"
	Else
		cCond := "!Empty(xFilial()) .and. Empty(xFilial('SB1'))"
	Endif

	aFiliais := If(&(cCond), aClone(aSM0CodFil), {xFilial()})
	For nBusca := 1 to Len(aFiliais)
		dbSeek(aFiliais[nBusca]+cCod)
		If Found()
			HELP(" ",1,STR0013,STR0013,STR0014+CHR(13)+CHR(10)+STR0019,3,4) //"ATENCAO"###"ATENCAO"###"O produto não pode ser excluido por"###"fazer parte de Epi x Risco"
			dbSelectArea("SB1")
			MsUnLock()
			lPodeApagar := .F.
			Exit
		EndIf
	Next

	If !lPodeAPagar
		RestArea(aArea)
		Return .t.
	Endif

	If lSigaMdtPS
		dbSelectArea("TM4") //Exames
		dbSetOrder(1)
		If lFunc
			cCond := "FWModeAccess('TM4') == 'E' .and. FWModeAccess('SB1') == 'C'"
		Else
			cCond := "!Empty(xFilial()) .and. Empty(xFilial('SB1'))"
		Endif

		aFiliais := If(&(cCond), aClone(aSM0CodFil), {xFilial()})
		For nBusca := 1 to Len(aFiliais)

			dbSeek(aFiliais[nBusca]+SubStr(allTrim(cCod),5,nTamCod))
			If Found()
				HELP(" ",1,STR0013,STR0013,STR0014+CHR(13)+CHR(10)+STR0273,3,4) //"ATENCAO"###"ATENCAO"###"O produto não pode ser excluido por"###"fazer parte de Exames"
				dbSelectArea("SB1")
				MsUnLock()
				lPodeApagar := .F.
				Exit
			EndIf
		Next
		If !lPodeAPagar
			RestArea(aArea)
			Return .t.
		Endif
	EndIf

	RestArea(aArea)
Return .f.
//---------------------------------------------------------------------
/*/{Protheus.doc} MdtValESA2
Verifica se eh possivel deletar o fornecedor.

@param cCod Caracter Codigo do Fornecedor

@obs SIGAEST

@author André E. Perez Álvarez
@since 25/03/2008
/*/
//---------------------------------------------------------------------
Function MdtValESA2(cCod)
	Local lPodeAPagar := .t.
	Local nBusca
	Local aFiliais
	Local aSM0CodFil := FwLoadSM0()
	Local lFunc	   	 := FindFunction("FWModeAccess")
	Local nTamFil 	 := FWSizeFilial()
	Local aFilAtu 	 := { { cEmpAnt , cFilAnt } }

	//Verificacoes nas tabelas do modulo SIGAMDT - Medicina e Seguranca do Trabalho
	dbSelectArea("TN3") //Fornecedores de Epi
	dbSetOrder(1)
	If lFunc
		cCond := "FWModeAccess('TN3') == 'E' .and. FWModeAccess('SA2') == 'C'"
	Else
		cCond := "!Empty(xFilial()) .and. Empty(xFilial('SA2'))"
	Endif
	aFiliais := If(&(cCond), aClone(aSM0CodFil), aFilAtu)
	For nBusca := 1 to Len(aFiliais)
		If dbSeek( xFilial( "TN3", SubStr( aFiliais[nBusca,2], 1, nTamFil ) )+cCod )
			HELP(" ",1,STR0013,STR0013,STR0082+CHR(13)+CHR(10)+STR0015,3,4) //"ATENCAO"###"ATENCAO"###"O fornecedor não pode ser excluido por"###"fazer parte de Fornecedores de Epi"
			lPodeApagar := .F.
			Exit
		EndIf
	Next nBusca

	If !lPodeAPagar
		Return .f.
	Endif


	dbSelectArea("TNF") //Epi x Funcionario
	dbSetOrder(1)
	If lFunc
		cCond := "FWModeAccess('TNF') == 'E' .and. FWModeAccess('SA2') == 'C'"
	Else
		cCond := "!Empty(xFilial()) .and. Empty(xFilial('SA2'))"
	Endif

	aFiliais := If(&(cCond), aClone(aSM0CodFil), aFilAtu)
	For nBusca := 1 to Len(aFiliais)
		If dbSeek( xFilial( "TNF", SubStr( aFiliais[nBusca,2], 1, nTamFil ))+cCod )
			HELP(" ",1,STR0013,STR0013,STR0082+CHR(13)+CHR(10)+STR0017,3,4) //"ATENCAO"###"ATENCAO"###"O fornecedor não pode ser excluido por"###"fazer parte de Epi x Funcionario"
			lPodeApagar := .F.
			Exit
		EndIf
	Next

	If !lPodeAPagar
		Return .f.
	Endif

	dbSelectArea("TMD") //Preço dos Exames
	dbSetOrder(1)
	If lFunc
		cCond := "FWModeAccess('TMD') == 'E' .and. FWModeAccess('SA2') == 'C'"
	Else
		cCond := "!Empty(xFilial()) .and. Empty(xFilial('SA2'))"
	Endif

	aFiliais := If(&(cCond), aClone(aSM0CodFil), aFilAtu)
	For nBusca := 1 to Len(aFiliais)
		If dbSeek( xFilial("TMD", SubStr( aFiliais[nBusca,2], 1, nTamFil ) )+cCod )
			HELP(" ",1,STR0013,STR0013,STR0082+CHR(13)+CHR(10)+STR0083,3,4) //"ATENCAO"###"ATENCAO"###"O produto não pode ser excluido por"###"fazer parte de Preço dos Exames"
			lPodeApagar := .F.
			Exit
		EndIf
	Next

	If !lPodeAPagar
		Return .f.
	Endif

	If NGCADICBASE("TKS_FORNEC","A","TKS",.F.)
		dbSelectArea("TKS") //Conjuntos Hidráulicos
		dbSetOrder(4)
		If lFunc
			cCond := "FWModeAccess('TKS') == 'E' .and. FWModeAccess('SA2') == 'C'"
		Else
			cCond := "!Empty(xFilial()) .and. Empty(xFilial('SA2'))"
		Endif

		aFiliais := If(&(cCond), aClone(aSM0CodFil), aFilAtu)
		For nBusca := 1 to Len(aFiliais)
			If dbSeek( xFilial( "TKS", SubStr( aFiliais[nBusca,2], 1, nTamFil ) )+cCod )
				HELP(" ",1,STR0013,STR0013,STR0082+CHR(13)+CHR(10)+STR0303,3,4) //"ATENCAO"###"ATENCAO"###"O fornecedor não pode ser excluido por"###"fazer parte de Conjunto Hidráulico."
				lPodeApagar := .F.
				Exit
			EndIf
		Next

		If !lPodeAPagar
			Return .f.
		Endif
	Endif

Return .t.
//---------------------------------------------------------------------
/*/{Protheus.doc} ValAte
Valida a pergunta "Ate" de qualquer tabela

@param cPar01 Caracter Valor da pergunta "De ...   "
@param cPar02 Caracter Valor da pergunta "Ate ...  "
@param cTab Caracter Alias da tabela onde a pergunta busca os dados
@param cField Caracter Alias do campo onde a pergunta busca os dados

@author André E. Perez Álvarez
@since 07/03/2006
/*/
//---------------------------------------------------------------------
Function ValAte(cPar01,cPar02,cTab,cField)
	Local lRet := .T.
	Local nSizeField := (TAMSX3(cField)[1])

	If cPar02 == Replicate('Z',nSizeField)
		lRet := .T.
	Else
		If cTab != "SRA"
			lRet := ExistCpo(cTab,cPar02)
		Else
			lRet := ExCpoMDT("SRA",cPar02,,.T.,.F.)
		Endif
		If lRet
			If Empty(cPar02)
				Help(" ",1,"ATEINVALID")
				lRet := .F.
			Elseif cPar02 < cPar01
				Help(" ",1,"DEATEINVAL")
				lRet := .F.
			Endif
		EndIf
	Endif

Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} NGimgExtract
Extrai uma imagem do repositorio para uma pasta temporaria.

@param cCodImg - cod. da imagem armazenada no repositorio
@param cPath - Path onde sera gravada a imagem

@return IF( lFile, cPathPict, "" )
		- Retorna o caminho completo da imagem, caso ela seja extraida com sucesso.
		- Retorna "" caso ela nao exista ou nao seja extraida com sucesso.

@sample NGimgExtract( cCodImg, cPath )

@author André E. Perez Álvarez
@since 31/08/2006
/*/
//---------------------------------------------------------------------
Function NGimgExtract( cCodImg, cPath )

	Local cBmpPict := AllTrim( cCodImg )
	Local cPathPict	:= ""
	Local lFile := .F.


	//--------------------------------
	// Carrega a Imagem solicitada
	//--------------------------------
	cPathPict := ( cPath + cBmpPict+".BMP" )

	//----------------------------------------------------------------
	// Para impressao da imagem eh necessario abrir um dialogo para
	// extracao dela do repositorio. No entanto, na impressao nao
	// ha a necessidade de visualizar o dialogo. Por esta razao
	// ele sera montado nestas coordenadas fora da Tela
	//----------------------------------------------------------------
	DEFINE MSDIALOG oDlg8   FROM -1000000,-4000000 TO -10000000,-8000000  PIXEL
	@ -10000000, -1000000000000 REPOSITORY oBmp SIZE -6000000000, -7000000000 OF oDlg8
	If oBmp:ExistBmp( cBmpPict )
		oBmp:LoadBmp(cBmpPict)

		IF !Empty( cBmpPict )
			IF !File( cPathPict)
				lFile := oBmp:Extract( cBmpPict, cPathPict, .F. )
			Else  //Se o arquivo .bmp existir na estacao, apaga
				Ferase( cPathPict )
				lFile := oBmp:Extract( cBmpPict, cPathPict, .F. )
			EndIF
		EndIF
	EndIf
	ACTIVATE MSDIALOG oDlg8 ON INIT ( oBmp:lStretch := .T., oDlg8:End() )

Return (   IF( lFile, cPathPict, "" )   )

//---------------------------------------------------------------------
/*/{Protheus.doc} CompoeSesmt
Verifica se o medico pertence ao Sesmt

@param ARG1 -> Codigo do Medico que sera validado
@param ARG2 -> Indica se devera validar se o codigo existe na TMK
@param ARG3 -> Indica se devera apresentar mensagens de nao-conform

@sample CompoeSesmt(ARG1,ARG2,ARG3)

@author Denis Hyroshi De Souza
@since 04/09/2006
/*/
//---------------------------------------------------------------------
Function CompoeSesmt(cTML_CODUSU,lValCpo,lMsg)
	Local lRet := .t.
	Local aAreaXXX := GetArea()
	Local aAreaTMK := TMK->(GetArea())
	Local cMsg := STR0027 //"Não será possível relacioná-lo, pois o usuário não compõe mais o Sesmt."
	Local cTit := STR0013 //"ATENCAO"

	dbSelectArea("TMK")
	dbSetOrder(1)
	If !dbSeek(xFilial("TMK")+cTML_CODUSU)
		If lMsg .and. lValCpo
			Help(" ",1,"REGNOIS")
		Endif
		lRet := .f.
	Else
		If TMK->TMK_SESMT == "2" .and. !Empty(TMK->TMK_DTTERM)
			If lMsg
				HELP(" ",1,cTit,cTit,Alltrim(Memoline(cMsg,45,1))+CHR(13)+CHR(10)+Memoline(cMsg,45,2),3,4)
			Endif
			lRet := .f.
		Endif
	Endif

	RestArea(aAreaTMK)
	RestArea(aAreaXXX)
Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} SitFunFicha
Verifica se o funcionario esta demitido

@param ARG1 -> Codigo da Ficha Medica que sera validado
@param ARG2 -> Indica se devera validar se o codigo existe na TM0
@param ARG3 -> Indica se devera apresentar mensagens
@param ARG4 -> Devera perguntar se deseja continuar ou nao

@sample SitFunFicha(ARG1,ARG2,ARG3)

@author Denis Hyroshi De Souza
@since 04/09/2006
/*/
//---------------------------------------------------------------------
Function SitFunFicha(cFicha,lValCpo,lMsg,lYesNo)
	Local lRet := .t.
	Local aAreaXXX := GetArea()
	Local aAreaSRA := SRA->(GetArea())
	Local aAreaTM0 := TM0->(GetArea())
	Local cMsg1 := STR0028 //"Este funcionário está demitido. Deseja continuar?"
	Local cMsg  := STR0029 //"Não será possível selecioná-lo, pois o funcionário está demitido."
	Local cMsg2 := STR0229 //"Este funcionário foi transferido para a empresa/filial:"
	Local cMsg3 := STR0230 //"Este funcionário foi transferido."
	Local cMsg4 := STR0231 //"Deseja continuar?"
	Local cMsg5 := STR0232 //"Não será possível selecioná-lo, pois o funcionário foi transferido para a empresa/filial:"
	Local cMsg6 := STR0233 //"Não será possível selecioná-lo, pois o funcionário foi transferido."
	Local cTit  := STR0013 //"ATENCAO"
	Local lSemPonEnt := .t.

	If ExistBlock("MDTVALDEM")
		lSemPonEnt := ExecBlock('MDTVALDEM',.F.,.F.)
		If ValType(lSemPonEnt) <> "L"
			lSemPonEnt := .f.
		Endif
	Endif

	dbSelectArea("TM0")
	dbSetOrder(1)
	If !dbSeek(xFilial("TM0")+cFicha)
		If lMsg .and. lValCpo
			Help(" ",1,"REGNOIS")
		Endif
		lRet := .f.
	Else
		If lSemPonEnt
			dbSelectArea("SRA")
			dbSetOrder(1)
			If dbSeek(TM0->TM0_FILFUN+TM0->TM0_MAT)
				If SRA->RA_SITFOLH == "T" .OR. SRA->RA_RESCRAI $ "30/31"
					lRet := .f.
					If lMsg
						aRetSRE := MdtRetSRE(cEmpAnt,SRA->RA_FILIAL,SRA->RA_MAT)
						If lYesNo
							lRet := MsgYesNo(If(aRetSRE[1],cMsg2+" "+aRetSRE[2]+"/"+aRetSRE[3]+".",cMsg3)+" "+cMsg4,cTit)
						Else
							cMsgXX := If(aRetSRE[1],cMsg5+" "+aRetSRE[2]+"/"+aRetSRE[3]+".",cMsg6)
							HELP(" ",1,cTit,cTit,Alltrim(Memoline(cMsgXX,45,1))+;
								CHR(13)+CHR(10)+Memoline(cMsgXX,45,2)+;
								CHR(13)+CHR(10)+Memoline(cMsgXX,45,3),3,4)
						Endif
					Endif
				ElseIf SRA->RA_SITFOLH == "D" .or. !Empty(SRA->RA_DEMISSA)
					lRet := .f.
					If lMsg
						If lYesNo
							lRet := MsgYesNo(cMsg1,cTit)
						Else
							HELP(" ",1,cTit,cTit,Alltrim(Memoline(cMsg,45,1))+CHR(13)+CHR(10)+Memoline(cMsg,45,2),3,4)
						Endif
					Endif
				Endif
			Endif
		Endif
	Endif

	RestArea(aAreaSRA)
	RestArea(aAreaTM0)
	RestArea(aAreaXXX)
Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} SitMdtFunc
Verifica se o funcionario esta demitido

@param ARG1 -> Codigo da Matricula    que sera validado
@param ARG2 -> Indica se devera validar se o codigo existe na TM0
@param ARG3 -> Indica se devera apresentar mensagens
@param ARG4 -> Devera perguntar se deseja continuar ou nao

@sample SitMdtFunc(ARG1,ARG2,ARG3)

@author Denis Hyroshi De Souza
@since 04/09/2006
/*/
//---------------------------------------------------------------------
Function SitMdtFunc(cMatricula,lValCpo,lMsg,lYesNo,cCliMdtPS)
	Local lRet := .t.
	Local aAreaXXX := GetArea()
	Local aAreaSRA := SRA->(GetArea())
	Local cMsg1 := STR0028  //"Este funcionário está demitido. Deseja continuar?"
	Local cMsg  := STR0029  //"Não será possível selecioná-lo, pois o funcionário está demitido."
	Local cTit  := STR0013  //"ATENCAO"
	Local lSigaMdtPS := If( SuperGetMv("MV_MDTPS",.F.,"N") == "S", .t. , .f. )
	Local nSizeSA1  := If((TAMSX3("A1_COD")[1]) < 1,6,(TAMSX3("A1_COD")[1]))
	Local nSizeLo1  := If((TAMSX3("A1_LOJA")[1]) < 1,2,(TAMSX3("A1_LOJA")[1]))
	Local lSemPonEnt := .t.

	If ExistBlock("MDTVALDEM")
		lSemPonEnt := ExecBlock('MDTVALDEM',.F.,.F.)
		If ValType(lSemPonEnt) <> "L"
			lSemPonEnt := .f.
		Endif
	Endif

	If !ExCpoMDT("SRA",cMatricula,,(lValCpo .and. lMsg),.T.)
		lRet := .f.
	Else
		If lSemPonEnt
			If SRA->RA_SITFOLH == "D" .or. !Empty(SRA->RA_DEMISSA)
				lRet := .f.
				If lMsg
					If lYesNo
						lRet := MsgYesNo(cMsg1,cTit)
					Else
						HELP(" ",1,cTit,cTit,Alltrim(Memoline(cMsg,45,1))+CHR(13)+CHR(10)+Memoline(cMsg,45,2),3,4)
					Endif
				Endif
			Endif
		Endif
		If lSigaMdtps
			If SubSTR(SRA->RA_CC,1,nSizeSA1+nSizeLo1) <> cCliMdtps
				lRet := .f.
				If lMsg
					HELP(" ",1,STR0013,STR0013,STR0077,3,4)	//"ATENÇÃO"//"ATENÇÃO"
				Endif
			Endif
		Endif
	Endif

	RestArea(aAreaSRA)
	RestArea(aAreaXXX)
Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} fMdtAltExa
Rotina de reprogramacao dos exames depois que o funcionario transferiu de centro de custo, pois sua exposicao a riscos
pode ter mudado, consequentemente, mudado os exames necessarios ATENCAO: So deve ser utilizado quando a alteracao for de
centro de custo ou funcao, e nao de filial ou empresa.

@author Denis Hyroshi De Souza
@since 26/09/2006
/*/
//---------------------------------------------------------------------
Function fMdtAltExa(cFilMat,cMat)
	Local aAreaXXX := GetArea()
	Local aAreaSRA := SRA->(GetArea())
	Local aPCMSO   := {}
	Local nX

	If !MsgYesNo(STR0030 +;  //"Deseja verificar se existem exames necessários para o novo "
		STR0031 +;  //"Centro de Custo ou nova Função do funcionário e refazer a "
		STR0032 )   //"programação de exames?"
		Return .f.
	Endif

	PRIVATE  nMv_Par01 := 1
	PRIVATE  cExame    := space(6),     cExamant := space(6)
	PRIVATE  nTtexam   := 0,              nIdade := 0
	PRIVATE  nTottar   := 0
	PRIVATE  aTabexam  := {},          aPeriodic := {}
	PRIVATE  aTabtar   := {}
	PRIVATE  lPrivez   := .F.,          lJagravou := .F.
	PRIVATE  cSexo     := space(1)
	PRIVATE  lExclusao := .f.
	PRIVATE  lFirstNG  := .t.
	PRIVATE  nSizeSI3  := If((TAMSX3("I3_CUSTO")[1]) < 1,9,(TAMSX3("I3_CUSTO")[1]))

	dbSelectArea("TM0")
	dbSetOrder(3)
	If dbSeek(xFilial("SRA",cFilMat)+cMat)
		dbSelectArea("TM5")
		dbSetOrder(1)
		dbSeek(xFilial("TM5")+TM0->TM0_NUMFIC+DTOS(dDataBase),.t.)
		While !Eof() .and. xFilial("TM5")+TM0->TM0_NUMFIC == TM5->TM5_FILIAL+TM5->TM5_NUMFIC
			If Empty(TM5->TM5_DTRESU) .and. !Empty(TM5->TM5_PCMSO)
				If aScan(aPCMSO,{|x| x == TM5->TM5_PCMSO}) == 0
					aADD(aPCMSO,TM5->TM5_PCMSO)
				Endif
				RecLock("TM5",.f.)
				dbDelete()
				TM5->(MsUnLock())
			Endif
			dbSkip()
		End

		For nX := 1 to Len(aPCMSO)
			dbSelectArea("TMW")
			dbSetOrder(1)
			If dbSeek(xFilial("TMW")+aPCMSO[nX])
				NG190GERA(3,cMat)
			Endif
		Next nX
	Endif

	RestArea(aAreaSRA)
	RestArea(aAreaXXX)
Return
//---------------------------------------------------------------------
/*/{Protheus.doc} MdtDelExames
Mostra uma tela aonde o usuario pode escolher, para o funcionario demitido, estas opcoes (se ele possui exames sem resultado).
1)Deletar exames agendados que não possuem resultado
2)Informar resultado para os exames que não possuem resultado
3)Convocar o funcionário para a realização dos exames

@param cMatSRA - Matricula do Funcionario
@param cFilFun - Filial do Funcionario
@param dDemiss - Data de demissao do funcionario

@sample MdtDelExames( cMatSRA, cFilFun, dDemiss )

@author Andre E. Perez Alvarez
@since 24/08/2006
/*/
//---------------------------------------------------------------------
Function MdtDelExames( cMatSRA, cFilFun, dDemiss )

	Local aAreaXXX := GetArea()
	Local aAreaTM0 := TM0->( GetArea() )
	Local aAreaTM5 := TM5->( GetArea() )
	Local aAreaTM4 := TM4->( GetArea() )

	Local oDlgQdo,oRadio
	Local nRadio := 1,nOpc := 1
	Local lRet := .T.,lGrava
	Private aFuncExa := {}

	Dbselectarea( "TM0" )
	Dbsetorder( 3 )  //TM0_FILFUN + TM0_MAT + TM0_NUMDEP
	If Dbseek( cFilFun + cMatSRA )

		Dbselectarea( "TM5" )
		Dbsetorder( 1 )	 //TM5_FILIAL+TM5_NUMFIC+DTOS(TM5_DTPROG)+TM5_HRPROG+TM5_EXAME
		If Dbseek( xFilial( "TM5" ) + TM0->TM0_NUMFIC )

			While !Eof()									  .AND.;
					TM5->TM5_FILIAL == xFilial( "TM5" )        .AND.;
					TM5->TM5_NUMFIC == TM0->TM0_NUMFIC

				If !Empty( TM5->TM5_DTRESU )
					DbSelectArea( "TM5" )
					DbSkip()
					Loop
				Endif

				dbSelectArea("TM4")
				dbSetOrder(01)
				dbSeek( xFilial("TM4") + TM5->TM5_EXAME )
				If Empty(TM5->TM5_HRPROG)
					AADD(aFuncExa, {TM0->TM0_NUMFIC,TM5->TM5_DTPROG,"",TM5->TM5_EXAME,TM4->TM4_NOMEXA,TM5->TM5_PCMSO} )
				Else
					AADD(aFuncExa, {TM0->TM0_NUMFIC,TM5->TM5_DTPROG,TM5->TM5_HRPROG,TM5->TM5_EXAME,TM4->TM4_NOMEXA,TM5->TM5_PCMSO} )
				Endif
				DbSelectArea( "TM5" )
				DbSkip()
			End

		Endif

	Endif

	If Len(aFuncExa) > 0

		Define MsDialog oDlgQdo From 03.5,6 To 150,690 Title STR0013 Pixel  //"Atencao"
		Define FONT oBold NAME "Courier New" SIZE 0, -13 BOLD
		@ 0, 0 BITMAP oBmp RESNAME "PROJETOAP" oF oDlgQdo SIZE 35,250 NOBORDER WHEN .F. PIXEL

		@ 05,040 Say OemToAnsi(STR0033) Size 350,7 Of oDlgQdo Pixel Font oBold  //"Com relação aos exames não-realizados do funcionário, o que deseja fazer ?"

		//"Deletar os exames programados"
		//"Informar um resultado para os exames programados"
		//"Convocar o funcionário para a realização dos exames"
		@ 20,048 Radio oRadio Var nRadio Items STR0034,STR0035,STR0036 3d Size 200,10 Of oDlgQdo Pixel

		Define sButton From 055,145 Type 1 Enable Of oDlgQdo Action (lGrava := .T.,oDlgQdo:End())
		Define sButton From 055,175 Type 2 Enable Of oDlgQdo Action (lGrava := .F.,oDlgQdo:End())

		Activate MsDialog oDlgQdo Centered

		If lGrava
			If nRadio == 1
				MDTExa001(cMatSRA, cFilFun, dDemiss)
			ElseIf nRadio == 2
				MDTExa002(cMatSRA, cFilFun, dDemiss)
			ElseIf nRadio == 3
				MDTExa003(cMatSRA, cFilFun, dDemiss)
			EndIf
		EndIf

	Endif

	RestArea(aAreaTM5)
	RestArea(aAreaTM4)
	RestArea(aAreaTM0)
	RestArea(aAreaXXX)

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTExa001
Deleta os exames agendados que nao possuem resultado

@param cMatSRA - Matricula do Funcionario
@param cFilFun - Filial do Funcionario
@param dDemiss - Data de demissao do funcionario

@sample MDTExa001( cMatSRA, cFilFun, dDemiss )

@author Andre E. Perez Alvarez
@since 08/02/2007
/*/
//---------------------------------------------------------------------
Static Function MDTExa001(cMatSRA, cFilFun, dDemiss)

	Local aAreaTM5 := TM5->( GetArea() )
	Local nX

	Dbselectarea( "TM5" )
	Dbsetorder( 1 )	 //TM5_FILIAL+TM5_NUMFIC+DTOS(TM5_DTPROG)+TM5_HRPROG+TM5_EXAME
	For nX := 1 To Len(aFuncExa)
		If Dbseek( xFilial( "TM5" ) + aFuncExa[nX][1] + DtoS(aFuncExa[nX][2]) +  aFuncExa[nX][3] + aFuncExa[nX][4] )
			RecLock( "TM5", .F. )
			DbDelete()
			MsUnlock()
		Endif
	Next nX

	RestArea(aAreaTM5)
Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTExa002
Informa resultado para os exames que nao possuem resultado.

@param cMatSRA - Matricula do Funcionario
@param cFilFun - Filial do Funcionario
@param dDemiss - Data de demissao do funcionario

@sample MDTExa002( cMatSRA, cFilFun, dDemiss )

@author Andre E. Perez Alvarez
@since 08/02/2007
/*/
//---------------------------------------------------------------------
Static Function MDTExa002(cMatSRA, cFilFun, dDemiss)

	Local aAreaTM5 := TM5->( GetArea() )
	Local nX
	Local oTempTable
	Local opcao
	Local oDLG3
	Local oFont
	Local nOpca
	Local nTamExa

	Local aRotina := { 	{ STR0194 , "AxPesqui",  0,  1},;     //"Pesquisar"
	{ STR0195, "AxPesqui",  0,  2},; 	   //"Visualizar"
	{ STR0196   , "AxPesqui",  0,  3},; 	   //"Incluir"
	{ STR0197   , "AxPesqui",  0,  4},; 	//"Alterar"
	{ STR0198   , "AxPesqui",  0,  5, 3} }  //"Excluir"

	Private dDataResul := stod(space(8))
	Private cCodiResul := space(4)
	Private dIndiResul := space(8)
	Private cNomeResul := space(30)
	Private cMarca := GetMark(), lInverte := .F.

	nTamExa := If(TAMSX3("TM4_EXAME")[1] < 1, 6, TAMSX3("TM4_EXAME")[1])

	aDBF := {}
	AADD(aDBF,{"TM5_OK"    ,"C",02,0})
	AADD(aDBF,{"TM5_EXAME" ,"C",nTamExa,0})
	AADD(aDBF,{"TM5_NOMEXA","C",30,0})
	AADD(aDBF,{"TM5_DTPROG","D",08,0})
	AADD(aDBF,{"TM5_HRPROG","C",05,0})

	aTRB1 := {}
	AADD(aTRB1,{"TM5_OK"    ,NIL," "                 ,})
	AADD(aTRB1,{"TM5_EXAME" ,NIL,STR0069             ,})  //"Exame"
	AADD(aTRB1,{"TM5_NOMEXA",NIL,STR0070			  ,})  //"Descricao do Exame"
	AADD(aTRB1,{"TM5_DTPROG",NIL,STR0071			  ,})  //"Dt. Programacao"
	AADD(aTRB1,{"TM5_HRPROG",NIL,STR0072             ,})  //"Hora Programacao"

	oTempTable := FWTemporaryTable():New( "TRBEX", aDBF )
	oTempTable:AddIndex( "1", {"TM5_DTPROG","TM5_HRPROG","TM5_EXAME"} )
	oTempTable:Create()

	DEFINE FONT oFont NAME "Arial" SIZE 0,-12

	DEFINE MSDIALOG oDlg3 TITLE OemToAnsi(STR0037+" - "+Alltrim(TM0->TM0_NOMFIC)) From 9,0 To 38,85 OF oMainWnd //"Exames Pendentes"

	//Panel criado para correta disposicao da tela
	oPnlPai := TPanel():New( , , , oDlg3 , , , , , , , , .F. , .F. )
	oPnlPai:Align := CONTROL_ALIGN_ALLCLIENT


	@ 0.5,1   SAY OemToAnsi(STR0038) Of oPnlPai  //"Ficha Medica"
	@ 0.5,6   MSGET MDTHideCpo( TM0->TM0_NUMFIC, "TM0_NUMFIC" ) Picture "@!" SIZE 40,10 WHEN .f. Of oPnlPai
	@ 0.5,12  SAY OemToAnsi(STR0065) Of oPnlPai //"Nome Funcionario"
	@ 0.5,18  MSGET MDTHideCpo( TM0->TM0_NOMFIC, "TM0_NOMFIC" ) Picture "@!" SIZE 100,10 WHEN .f. Of oPnlPai

	@ 1.5,1.2 TO 3.5,41 OF oPnlPai
	@ 27.3,15 SAY STR0066  SIZE 300,10 of oPnlPai PIXEL FONT oFont  //"Estes são os exames pendentes deste funcionário. Selecione os exames que deseja informar um resultado."
	@ 37.3,15 SAY STR0067 SIZE 300,10 of oPnlPai PIXEL FONT oFont   //"Após confirmar esta operação, você será solicitado a informar um resultado para cada exame selecionado. "

	@ 4.2,0.5 TO 13,41.6 LABEL  STR0068 OF oPnlPai //"Exames"

	//                    1               2             3               4              5               6
	//aFuncExa, {TM0->TM0_NUMFIC,TM5->TM5_DTPROG,TM5->TM5_HRPROG,TM5->TM5_EXAME,TM4->TM4_NOMEXA,TM5->TM5_PCMSO}

	oMARK := MsSelect():NEW("TRBEX","TM5_OK",,aTRB1,@lINVERTE,@cMARCA,{75,10,179,325},/*cTopFun*/,/*cBotFun*/,oPnlPai)
	oMARK:bMARK := {|| MDT002MAQ(cMarca,lInverte)}
	oMARK:oBROWSE:lHASMARK := .T.
	oMARK:oBROWSE:lCANALLMARK := .T.
	oMARK:oBROWSE:bALLMARK := {|| MDT002INV(cMarca) }

	For nX := 1 To Len(aFuncExa)
		TRBEX->(DbAppend())
		TRBEX->TM5_EXAME  := aFuncExa[nX][4]
		TRBEX->TM5_NOMEXA := aFuncExa[nX][5]
		TRBEX->TM5_DTPROG := aFuncExa[nX][2]
		TRBEX->TM5_HRPROG := aFuncExa[nX][3]
	Next nX

	DbSelectArea("TRBEX")
	DBGOTOP()
	oMARK:oBROWSE:REFRESH(.T.)

	ACTIVATE MSDIALOG oDlg3 ON INIT EnchoiceBar(oDlg3,{|| nOpca := 1,oDlg3:End()},{|| nOpca := 2,oDlg3:End()}) Centered
	If nOpca == 1

		cAlias := "TM5" //Necessario para funcionar corretamente a tela de resultado de exame

		Dbselectarea("TRBEX")
		Dbgotop()
		While !eof()

			If Empty(TRBEX->TM5_OK)
				Dbskip()
				Loop
			Endif

			dbSelectArea("TM4")
			dbSetOrder(1)
			If dbSeek( xFilial("TM4") + TRBEX->TM5_EXAME)

				Dbselectarea("TM5")
				Dbsetorder(8)  //TM5_FILIAL+TM5_NUMFIC+DTOS(TM5_DTPROG)+TM5_HRPROG+TM5_EXAME
				If Dbseek(xFilial("TM5")+aFuncExa[1][1]+DTOS(TRBEX->TM5_DTPROG)+TRBEX->TM5_HRPROG+TRBEX->TM5_EXAME)

					dbSelectArea("TM0")
					dbSetOrder(1)
					dbSeek( xFilial("TM0") + aFuncExa[1][1])

					msgInfo(;
						STR0073 + CHR(13)+CHR(10) +; //"Informe um resultado para este exame: "
					AllTrim(TM5->TM5_EXAME) + " - " + SubSTR(TM4->TM4_NOMEXA,1,20)  + CHR(13)+CHR(10) +; // XXXXXX - XXXXXXXXXXXXXXXXXXXXXXX
					STR0074 + DtoC(TM5->TM5_DTPROG) + CHR(13)+CHR(10) +; //"Data de Programação: " XX/XX/XXXX
					STR0075 + TM5->TM5_HRPROG + CHR(13)+CHR(10)  ; //"Hora de Programação: " XX:XX
					)

					REXAME120()

				Endif

			Endif

			Dbselectarea("TRBEX")
			Dbskip()
		End
	Endif

	oTempTable:Delete()

	RestArea(aAreaTM5)
Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTExa003
Convoca o funcionario para realizar os exames pendentes

@param cMatSRA - Matricula do Funcionario
@param cFilFun - Filial do Funcionario
@param dDemiss - Data de demissao do funcionario

@sample MDTExa003( cMatSRA, cFilFun, dDemiss )

@author Andre E. Perez Alvarez
@since 08/02/2007
/*/
//---------------------------------------------------------------------
Static Function MDTExa003(cMatSRA, cFilFun, dDemiss)

	Local oDlg1,oScr,lRet
	Local nTamExa := If(TAMSX3("TM4_EXAME")[1] < 1, 6, TAMSX3("TM4_EXAME")[1])

	Private dINICIO   := CTOD("  /  /    ")
	Private dTERMINO  := CTOD("  /  /    ")


	Private M->TMV_PCMSO := Space(06)
	Private M->TMV_CONVOC := Space(04)

	Private M->TMV_DTINPR := CTOD("  /  /    ")
	Private M->TMV_DTFIPR := CTOD("  /  /    ")

	Private M->TMV_CODUSU := Space(12)
	Private M->TMV_NOMUSU := Space(40)

	Private M->TMV_DTINRE := dDataBase
	Private M->TMV_DTFIRE := CTOD("  /  /    ")

	Private M->TMV_EXAME  := Space(nTamExa)
	Private M->TMV_NOMEXA := Space(40)

	Private M->TMV_CALEND := Space(3)
	Private cCalendDes := Space(30)

	Private M->TMV_QTATEN  := Space(3)
	Private M->TMV_LOCAL   := Space(30)

	Private M->TMV_MOTIVO := Space(4)
	Private M->TMV_NOMOTI := Space(40)

	Private M->TMV_DTEXC1 := CTOD("  /  /    ")
	Private M->TMV_DTEXC2 := CTOD("  /  /    ")
	Private M->TMV_DTEXC3 := CTOD("  /  /    ")
	Private M->TMV_DTEXC4 := CTOD("  /  /    ")
	Private M->TMV_DTEXC5 := CTOD("  /  /    ")
	Private M->TMV_DTEXC6 := CTOD("  /  /    ")
	Private aDATEXC := {}

	Private cFilTMV := xFilial("TMV")

	DEFINE MSDIALOG oDlg1 TITLE OemToAnsi(STR0040) from 10,15 To 35.1,83 of oMainwnd //"Geração de Convocação de Exames para o Funcionário Demitido"

	@ 5,5 SCROLLBOX oScr SIZE 181.0,260 OF oDlg1 BORDER

	@ 1.0,1  SAY OemToAnsi(STR0059) OF oScr Color CLR_HBLUE //"PCMSO"
	@ 1.0,7.3  MSGET M->TMV_PCMSO OF oScr SIZE 45,08 Picture "@!" F3 "TMW" When .t.  VALID EXISTCPO("TMW",M->TMV_PCMSO) .AND. NEXTCONVOC() HasButton
	@ 1.0,14 SAY OemToAnsi(STR0060) OF oScr  //"Convocação"
	@ 1.0,20.8 MSGET M->TMV_CONVOC WHEN .F. SIZE 35,08 OF oScr Picture "@!" VALID EXISTCHAV("TMV",M->TMV_PCMSO+M->TMV_CONVOC)

	@ 2.0,1  SAY OemToAnsi(STR0057) OF oScr  //"Início Programação"
	@ 2.0,7.3  MSGET M->TMV_DTINPR WHEN .T. SIZE 45,08 OF oScr Picture "99/99/9999" HasButton
	@ 2.0,14 SAY OemToAnsi(STR0058) OF oScr  //"Término Programação"
	@ 2.0,20.8 MSGET M->TMV_DTFIPR WHEN .T. SIZE 45,08 OF oScr Picture "99/99/9999" VALID IF (!EMPTY(M->TMV_DTFIPR), VALDATA(M->TMV_DTINPR, M->TMV_DTFIPR, "DATAINVALI"), .T.) HasButton

	@ 3.0,1  SAY OemToAnsi(STR0041) OF oScr Color CLR_HBLUE //"Médico"
	@ 3.0,7.3  MSGET M->TMV_CODUSU OF oScr SIZE 45,08 Picture "@!" F3 "TMK" When .t.  VALID MDTCHKMED() .AND. EXISTCPO("TMK",M->TMV_CODUSU) .AND. MDT003AGE() HasButton
	@ 3.0,14 SAY OemToAnsi(STR0042) OF oScr  //"Nome Médico"
	@ 3.0,20.8 MSGET M->TMV_NOMUSU WHEN .F. SIZE 88,08 OF oScr Picture "@!"

	@ 4.0,1  SAY OemToAnsi(STR0043) OF oScr Color CLR_HBLUE  //"Início Realização"
	@ 4.0,7.3  MSGET M->TMV_DTINRE WHEN .T. SIZE 45,08 OF oScr Picture "99/99/9999" VALID NaoVazio() HasButton
	@ 4.0,14 SAY OemToAnsi(STR0044) OF oScr Color CLR_HBLUE  //"Término Realização"
	@ 4.0,20.8 MSGET M->TMV_DTFIRE WHEN .T. SIZE 45,08 OF oScr Picture "99/99/9999" VALID VALDATA(M->TMV_DTINRE,M->TMV_DTFIRE,"DATAINVALI") HasButton

	@ 5.0,1  SAY OemToAnsi(STR0061) OF oScr Color CLR_HBLUE  //"Exame"
	@ 5.0,7.3  MSGET M->TMV_EXAME WHEN .T. SIZE 45,08 OF oScr Picture "@!" VALID EXISTCPO("TM4",M->TMV_EXAME) .AND. MDT003EXA() F3 "TM4" HasButton
	@ 5.0,14 SAY OemToAnsi(STR0062) OF oScr  //"Nome Exame"
	@ 5.0,20.8 MSGET M->TMV_NOMEXA WHEN .F. SIZE 45,08 OF oScr Picture "@!"

	@ 6.0,1  SAY OemToAnsi(STR0053) OF oScr Color CLR_HBLUE //"Motivo"
	@ 6.0,7.3  MSGET M->TMV_MOTIVO WHEN .T. SIZE 45,08 OF oScr Picture "@!" F3 "TMS"  VALID EXISTCPO("TMS",M->TMV_MOTIVO) .AND. MDT003Mot() HasButton
	@ 6.0,14  SAY OemToAnsi(STR0056) OF oScr  //"Descr. Motivo"
	@ 6.0,20.8  MSGET M->TMV_NOMOTI WHEN .F. SIZE 78,08 OF oScr Picture "@!"

	@ 7.0,1 SAY OemToAnsi(STR0045) OF oScr Color CLR_HBLUE //"Calendário"
	@ 7.0,7.3 MSGET M->TMV_CALEND WHEN .T. SIZE 45,08 OF oScr 	Picture "@!" F3 "SH7" Valid EXISTCPO("SH7",M->TMV_CALEND) .AND. MDT003NOMECAL() HasButton
	@ 7.0,14  SAY OemToAnsi(STR0063) OF oScr  //"Desc. Calendário"
	@ 7.0,20.8  MSGET cCalendDes WHEN .F. SIZE 78,08 OF oScr Picture "@!"

	@ 8.0,1  SAY OemToAnsi(STR0046) OF oScr Color CLR_HBLUE //"Tempo (min.)"
	@ 8.0,7.3 MSGET M->TMV_QTATEN WHEN .T. SIZE 45,08 OF oScr Picture "999"	VALID NAOVAZIO()
	@ 8.0,14  SAY OemToAnsi(STR0064) OF oScr  //"Local Exame"
	@ 8.0,20.8  MSGET M->TMV_LOCAL WHEN .T. SIZE 78,08 OF oScr Picture "@!"

	@ 9.0,1  SAY OemToAnsi(STR0047) OF oScr  //"Data de Exceção 1"
	@ 9.0,7.3  MSGET M->TMV_DTEXC1 WHEN .T. SIZE 45,08 OF oScr Picture "99/99/9999" HasButton
	@ 9.0,14 SAY OemToAnsi(STR0048) OF oScr  //"Data de Exceção 2"
	@ 9.0,20.8 MSGET M->TMV_DTEXC2 WHEN .T. SIZE 45,08 OF oScr Picture "99/99/9999" HasButton

	@ 10.0,1  SAY OemToAnsi(STR0049) OF oScr  //"Data de Exceção 3"
	@ 10.0,7.3  MSGET M->TMV_DTEXC3 WHEN .T. SIZE 45,08 OF oScr Picture "99/99/9999" HasButton
	@ 10.0,14 SAY OemToAnsi(STR0050) OF oScr  //"Data de Exceção 4"
	@ 10.0,20.8 MSGET M->TMV_DTEXC4 WHEN .T. SIZE 45,08 OF oScr Picture "99/99/9999" HasButton

	@ 11.0,1  SAY OemToAnsi(STR0051) OF oScr  //"Data de Exceção 5"
	@ 11.0,7.3  MSGET M->TMV_DTEXC5 WHEN .T. SIZE 45,08 OF oScr Picture "99/99/9999" HasButton
	@ 11.0,14 SAY OemToAnsi(STR0052) OF oScr  //"Data de Exceção 6"
	@ 11.0,20.8 MSGET M->TMV_DTEXC6 WHEN .T. SIZE 45,08 OF oScr Picture "99/99/9999" HasButton

	DEFINE SBUTTON FROM 169.2,132 TYPE 1 ENABLE OF oDlg1 ACTION EVAL({|| lRET := MDTCHKMED(),If(lRET,oDlg1:End(),nil)})
	DEFINE SBUTTON FROM 169.2,162 TYPE 2 ENABLE OF oDlg1 ACTION oDlg1:END()

	ACTIVATE MSDIALOG oDlg1 CENTERED

	If lRET

		DbSelectArea("TMV")
		DbSetOrder(1)
		RecLock("TMV",.T.)
		TMV->TMV_FILIAL := cFilTMV
		TMV->TMV_PCMSO  := M->TMV_PCMSO
		TMV->TMV_CONVOC := M->TMV_CONVOC
		TMV->TMV_DTINPR := M->TMV_DTINPR
		TMV->TMV_DTFIPR := M->TMV_DTFIPR
		TMV->TMV_CODUSU := M->TMV_CODUSU
		TMV->TMV_DTINRE := M->TMV_DTINRE
		TMV->TMV_DTFIRE := M->TMV_DTFIRE
		TMV->TMV_EXAME  := M->TMV_EXAME
		TMV->TMV_CC     := ""
		TMV->TMV_CODFUN := ""
		TMV->TMV_CALEND := M->TMV_CALEND
		TMV->TMV_QTATEN := Val(M->TMV_QTATEN)
		TMV->TMV_MOTIVO := M->TMV_MOTIVO
		TMV->TMV_TNOTRA := ""
		TMV->TMV_LOCAL  := M->TMV_LOCAL
		TMV->TMV_DTEXC1 := M->TMV_DTEXC1
		TMV->TMV_DTEXC2 := M->TMV_DTEXC2
		TMV->TMV_DTEXC3 := M->TMV_DTEXC3
		TMV->TMV_DTEXC4 := M->TMV_DTEXC4
		TMV->TMV_DTEXC5 := M->TMV_DTEXC5
		TMV->TMV_DTEXC6 := M->TMV_DTEXC6
		MsUnlock()

		//----------------------------------------------------------------
		// Carrega array com os dias que o medico nao atende no ambulat.
		//----------------------------------------------------------------
		IF !EMPTY(M->TMV_DTEXC1)
			aAdd(aDATEXC,M->TMV_DTEXC1)
		ENDIF
		IF !EMPTY(M->TMV_DTEXC2)
			aAdd(aDATEXC,M->TMV_DTEXC2)
		ENDIF
		IF !EMPTY(M->TMV_DTEXC3)
			aAdd(aDATEXC,M->TMV_DTEXC3)
		ENDIF
		IF !EMPTY(M->TMV_DTEXC4)
			aAdd(aDATEXC,M->TMV_DTEXC4)
		ENDIF
		IF !EMPTY(M->TMV_DTEXC5)
			aAdd(aDATEXC,M->TMV_DTEXC5)
		ENDIF
		IF !EMPTY(M->TMV_DTEXC6)
			aAdd(aDATEXC,M->TMV_DTEXC6)
		ENDIF
		Processa({|lEnd| MDT003GERA()})          // MONTE TELA PARA ACOMPANHAMENTO DO PROCESSO.
	ENDIF

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MdtDelCandCipa
Deleta a candidatura a CIPA dos funcionários demitidos.

@obs MDT660DEMI - Verifica se funcionário é componente de CIPA.

@author Andre E. Perez Alvarez
@since 25/08/2006
@param cMatSRA - Matricula do funcionário
@return .T.
/*/
//---------------------------------------------------------------------

Function MdtDelCandCipa( cMatSRA )

	Local aAreaXXX := GetArea()
	Local aAreaTNO := TNO->( GetArea() )

	Dbselectarea( "TNO" )
	Dbsetorder( 1 ) //TNO_FILIAL + TNO_MANDAT + TNO_MAT + DTOS(TNO_DTCAND)
	Set Filter To TNO->TNO_FILIAL == xFilial("TNO")   .AND.;
		TNO->TNO_MAT == cMatSRA

	While !Eof() .And. TNO->TNO_MAT == cMatSRA
		Reclock( "TNO", .F. )
		DbDelete()
		MsUnlock()
		DbSkip()
	End

	Set Filter To

	//----------------------------------------------------
	// Chama função que verifica seo funcionário demitido
	// faz parte de CIPA.
	//----------------------------------------------------
	If FindFunction("MDT660DEMI")//Verifica a existencia da função
		MDT660DEMI()
	Endif

	RestArea(aAreaTNO)
	RestArea(aAreaXXX)
Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} GeraFicMed
Valida a pergunta 4 - Ate Categoria?

@param cFilMat  - Filial do Funcionario
@param cMat     - Matricula do Funcionario

@sample GeraFicMed(RA_FILIAL,RA_MAT)

@author Denis Hyroshi de Souza
@since 13/09/2006
/*/
//---------------------------------------------------------------------
Function GeraFicMed(cFilMat,cMat)
	Local aAreaXXX   := GetArea()
	Local aAreaSRA   := SRA->(GetArea())
	Local aAreaTM0   := TM0->(GetArea())
	Local lNovaFicha := .t.

	//Localiza matricula do funcionario que sera gerada a ficha medica
	dbSelectArea("SRA")
	dbSetOrder(1)
	If !dbSeek(cFilMat+cMat)
		RestArea(aAreaSRA)
		RestArea(aAreaXXX)
		Return .f.
	Endif

	dbSelectArea("TM0")
	dbSetOrder(3)
	If !dbSeek(SRA->RA_FILIAL+SRA->RA_MAT)

		//Verificando se tem ficha com o mesmo CPF da matricula
		dbSelectArea("TM0")
		dbSetOrder(10)
		If dbSeek(xFilial("TM0")+SRA->RA_CIC) .and. !Empty(SRA->RA_CIC)
			RecLock("TM0",.F.)
			TM0->TM0_FILFUN := SRA->RA_FILIAL
			TM0->TM0_NOMFIC := SRA->RA_NOME
			TM0->TM0_MAT    := SRA->RA_MAT
			TM0->TM0_CODFUN := SRA->RA_CODFUNC
			TM0->TM0_CC     := SRA->RA_CC
			If NGCADICBASE( "TM0_DEPTO", "A" , "TM0" , .F. )
				TM0->TM0_DEPTO  := SRA->RA_DEPTO
			EndIf
			TM0->TM0_RG     := SRA->RA_RG
			If TM0->(FieldPos("TM0_CODPOS")) > 0 .AND. SRA->(FieldPos("RA_POSTO")) > 0
				TM0->TM0_CODPOS := SRA->RA_POSTO
			Endif
			TM0->(MsUnLock())
			lNovaFicha := .f.
		Endif

		//Verificando se tem ficha com o mesmo RG da matricula
		If lNovaFicha
			dbSelectArea("TM0")
			dbSetOrder(06)
			If dbSeek(xFilial("TM0")+SRA->RA_RG) .and. !Empty(SRA->RA_RG)
				If Substr(TM0->TM0_NOMFIC,1,20) == Substr(SRA->RA_NOME,1,20)
					RecLock("TM0",.F.)
					TM0->TM0_FILFUN := SRA->RA_FILIAL
					TM0->TM0_NOMFIC := SRA->RA_NOME
					TM0->TM0_MAT    := SRA->RA_MAT
					TM0->TM0_CODFUN := SRA->RA_CODFUNC
					TM0->TM0_CC     := SRA->RA_CC
					If NGCADICBASE( "TM0_DEPTO", "A" , "TM0" , .F. )
						TM0->TM0_DEPTO  := SRA->RA_DEPTO
					EndIf
					TM0->TM0_CPF    := SRA->RA_CIC
					If TM0->(FieldPos("TM0_CODPOS")) > 0 .AND. SRA->(FieldPos("RA_POSTO")) > 0
						TM0->TM0_CODPOS := SRA->RA_POSTO
					Endif
					TM0->(MsUnLock())
					lNovaFicha := .f.
				Endif
			Endif
		Endif

		//Gerando Nova Ficha
		If lNovaFicha
			cNUMFIC := GETSXENUM("TM0","TM0_NUMFIC")
			CONFIRMSX8()
			RecLock('TM0',.T.)
			TM0->TM0_FILIAL := xfilial('TM0')
			TM0->TM0_FILFUN := SRA->RA_FILIAL
			TM0->TM0_NUMFIC := cNUMFIC
			TM0->TM0_DTIMPL := SRA->RA_ADMISSA
			TM0->TM0_NOMFIC := SRA->RA_NOME
			TM0->TM0_SANGUE := "5"
			TM0->TM0_FATORH := "1"
			TM0->TM0_DOADOR := "2"
			TM0->TM0_SEXO   := If(SRA->RA_SEXO = "M",'1','2')
			TM0->TM0_FUMA   := "2"
			TM0->TM0_ESTCIV := SRA->RA_ESTCIVI
			TM0->TM0_MAT    := SRA->RA_MAT
			TM0->TM0_DTNASC := SRA->RA_NASC
			TM0->TM0_RG     := SRA->RA_RG
			TM0->TM0_CPF    := SRA->RA_CIC
			TM0->TM0_CODFUN := SRA->RA_CODFUNC
			TM0->TM0_CC     := SRA->RA_CC
			If NGCADICBASE( "TM0_DEPTO", "A" , "TM0" , .F. )
				TM0->TM0_DEPTO  := SRA->RA_DEPTO
			EndIf
			If TM0->(FieldPos("TM0_CODPOS")) > 0 .and. SRA->(FieldPos("RA_POSTO")) > 0
				TM0->TM0_CODPOS  := SRA->RA_POSTO
			Endif
			If TM0->(FieldPos("TM0_CLIENT")) > 0 .and. TM0->(FieldPos("TM0_LOJA")) > 0
				TM0->TM0_CLIENT := Substr(SRA->RA_CC,1,Len(TM0_CLIENT))
				TM0->TM0_LOJA   := Substr(SRA->RA_CC,Len(TM0_CLIENT)+1,Len(TM0_LOJA))
			Endif
			TM0->(MsUnLock())
			lNovaFicha := .f.
		Endif
	Endif

	RestArea(aAreaTM0)
	RestArea(aAreaSRA)
	RestArea(aAreaXXX)
Return !lNovaFicha
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTCHKMED
Verifica se o nome do medico esta preenchido

@author Andre Perez Alvarez
@since 16/02/2007
/*/
//---------------------------------------------------------------------
Static Function MDTCHKMED()

	IF Empty(M->TMV_CODUSU)
		Help(" ",1,"NGSMEDOBR")
		return .F.
	Endif

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDT003GERA
Rotina principal de controle da geracao das Consultas na Agenda do Medico - Tabela (TMJ).

@author Andre Perez Alvarez
@since 16/02/2007
/*/
//---------------------------------------------------------------------
Static Function MDT003GERA()                            // CONTROLA A GERACAO DO EXAME PARA O FUNCIONARIO

	Local nX
	Local cFichAnt

	Private dDATANT := CtoD(" /  /     ")
	Private nFinal  := 0
	Private aOCI      := {}
	Private nUltCons  :=  0
	Private nDia      :=  1
	Private nInic     :=  0
	Private nHora     :=  0
	Private nQtaten   :=  0

	Private cFicha := aFuncExa[1][1]
	Private cExame
	Private dtProg
	Private cHRPROG
	Private cPCMSO

	ProcRegua( Len(aFuncExa) )

	//                    1               2             3               4              5               6
	//aFuncExa, {TM0->TM0_NUMFIC,TM5->TM5_DTPROG,TM5->TM5_HRPROG,TM5->TM5_EXAME,TM4->TM4_NOMEXA,TM5->TM5_PCMSO}

	//----------------------------------------------------------------
	// Obter horario de trabalho do medico conforme calendario.
	//----------------------------------------------------------------
	aDia := NGMDT_H7(M->TMV_CALEND)              // OBTER DADOS DO CALENDARIO

	For nX := 1 To Len(aFuncExa)
		IncProc()
		If aFuncExa[nX][2] < M->TMV_DTINPR .OR. aFuncExa[nX][2] > M->TMV_DTFIPR  //Se a data de Programacao do Exame nao esta dentro do intervalo de Programacao escolhido
			Loop
		Endif
		If aFuncExa[nX][6] != M->TMV_PCMSO
			Loop
		Endif
		If aFuncExa[nX][4] != M->TMV_EXAME
			Loop
		Endif
		IF dINICIO > M->TMV_DTFIRE          // Sai da Funao se a data de inicio
			Return .T.                      // ja passou a data de termino para
		ENDIF                               // atendimento das consultas.
		dtProg := aFuncExa[nX][2]
		cHRPROG := aFuncExa[nX][3]
		cExame := aFuncExa[nX][4]
		If cFichAnt != aFuncExa[nX][1]
			MDT003CALC()              // CALCULAR DATA E HORA EXAME.
			cFichAnt := aFuncExa[nX][1]
		Endif
	Next nX

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDT003CALC
Calcular data e hora da realizacao do exame.

@author Andre Perez Alvarez
@since 16/02/2007
/*/
//---------------------------------------------------------------------
Static Function MDT003CALC()

	Local lGravou   := .F.                       // Indica se gravou ou nao o registro na agenda
	Local i
	//----------------------------------------------------------------
	// verificar data de inicio em relacao a convocacao anterior.
	//----------------------------------------------------------------
	IF EMPTY(dINICIO)
		dINICIO   := M->TMV_DTINRE
		dInicatu  := M->TMV_DTINRE
		cConvoAtu := M->TMV_CONVOC
		cPcmsoAtu := M->TMV_PCMSO
		cCodusu   := M->TMV_CODUSU
		nQtAtual  := VAL(M->TMV_QTATEN)
		nConvoAtu := VAL(cConvoAtu)
		nConvoAnt := nConvoAtu - 1
		cUltHora  := "24:00"
		cConvoAnt := STRZERO(nConvoAnt,4)

		//----------------------------------------------------------------
		//  verificar data de inicio em relacao a convocacao anterior.
		//----------------------------------------------------------------

		IF nConvoAnt > 0
			MDT003REGAN()
		ENDIF
	ENDIF

	//----------------------------------------------------------------
	// Busca hora inicio e final se mudou de dia
	//----------------------------------------------------------------

	If dDatAnt != dINICIO

		MDT003DIA(dINICIO,nUltCons)

		IF nHora > nFinal
			nUltCons := 0
			dINICIO  := dINICIO + 1

			MDT003DIA(dINICIO,nUltCons)

		EndIf
	Endif
	nUltCons := 0
	lGravou  := .F.

	Do While !lGravou

		Do While nHORA <= nFinal
			For i := 1 to Len(aOCI)
				If aOCI[i][1] <= nHORA .and. aOCI[i][2] >= nHORA
					nHORA := aOCI[i][2]
				Endif
			Next

			If nHORA < 1440
				cHHMMIN := MtoH(nHORA)
				DbSelectArea("TMJ")
				Dbsetorder(1)
				IF !DbSeek(xFilial("TMJ") + M->TMV_CODUSU + DtoS(dINICIO) + cHHMMIN)
					lRet := MDT003GRAG()                             //  PROCESSA ROTINA PARA GRAVAR REGISTRO TMJ ( AGENDA )
					If lRet
						nHora := nHora + VAL(M->TMV_QTATEN)
					Endif
					lGravou := .T.
					Exit
				ENDIF
			Endif

			nHora := nHora + VAL(M->TMV_QTATEN)

		EndDo

		dDatAnt := dINICIO
		If !lGravou            // Se ainda nao gravou e a hora inicio maior que hora final
			dINICIO := dINICIO + 1

			MDT003DIA(dINICIO,0)

			IF dINICIO > M->TMV_DTFIRE            // Sai da Funao se a data de inicio
				Return .T.                           // ja passou a data de termino para
			ENDIF                                   // atendimento das consultas.
		Endif
	EndDo

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDT003DIA
Verifica se o dia cai em dia de trabalho do medico.

@author Andre Perez Alvarez
@since 16/02/2007
/*/
//---------------------------------------------------------------------
Static Function MDT003DIA(dInicio_temp,nUltCons)
	Local aAreaOld  := GetArea()//Salva Área posicionada.
	Local I
	nDia      := DOW(dInicio_temp)
	nDIA      := IF(nDIA == 1,7, nDIA-1)       // Adequa o calendario a microsica a funcao DOW
	Do While HtoM(aDIA[nDIA][3]) == 0          // total de horas de trabalho no dia
		dInicio_temp := dInicio_temp + 1
		nDia    := DOW(dInicio_temp)
		nDIA    := IF(nDIA == 1,7, nDIA-1)      // Adequa o calendario a microsica a funcao DOW
	EndDo
	//----------------------------------------------------------------
	// Verifica se o dia a ser gerado e dia valido, ou Escecao.
	//----------------------------------------------------------------
	For I :=  1 to Len(aDATEXC)
		IF dInicio_temp == aDATEXC[I]
			dInicio_temp := dInicio_temp + 1
			nDia    := DOW(dInicio_temp)
			nDIA    := IF(nDIA == 1,7, nDIA-1)         // Adequa o calendario a microsica a funcao DOW
			// DOW retorna 1 para domingo,na microsiga 1 eh Segunda
			Do While HtoM(aDIA[nDIA][3]) == 0          // total de horas de trabalho no dia
				dInicio_temp := dInicio_temp + 1
				nDia    := DOW(dInicio_temp)
				nDIA    := IF(nDIA == 1,7, nDIA-1)      // Adequa o calendario a microsica a funcao DOW
			EndDo
		ENDIF
	NEXT

	aOCI    := aDIA[nDia][4]
	nInic   := HtoM(aDIA[nDIA][1])
	nFinal  := HtoM(aDia[nDIA][2])
	nFinal  := nFinal - nQtAten              // Diminui tempo de atendimento.
	nHORA   := If( Empty(nUltCons), nINIC, nUltCons)

	dInicio := dInicio_temp
	RestArea( aAreaOld  )
Return .t.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDT003GRAG
Grava os Registros na agenda do Medico. tabela - TMJ .

@author Andre Perez Alvarez
@since 16/02/2007
/*/
//---------------------------------------------------------------------
Static Function MDT003GRAG()                            // GRAVAR AGENDA DO MEDICO
	Local aAreaOld  := GetArea()//Salva Área posicionada.
	Local lSave  := .t.
	Local lRe := .t.

	lSave := ! ( MDTChkSR8( "SR8", 1 ,; //Na Ver12 alterar verificação para MDTChkSR8
	SRA->RA_FILIAL+SRA->RA_MAT,;
		"SRA->RA_FILIAL == SR8->R8_FILIAL .and. SRA->RA_MAT == SR8->R8_MAT" ,;
		dINICIO , dINICIO ) )

	If lSave .and. MDT003INDI() .and. dINICIO >= M->TMV_DTINRE .and. dINICIO <= M->TMV_DTFIRE
		RecLock("TMJ",.T.)
		TMJ->TMJ_FILIAL  := xFilial("TMJ")
		TMJ->TMJ_CODUSU  := M->TMV_CODUSU
		TMJ->TMJ_DTCONS  := dINICIO
		TMJ->TMJ_HRCONS  := cHHMMIN
		TMJ->TMJ_NUMFIC  := cFicha
		TMJ->TMJ_MOTIVO  := M->TMV_MOTIVO
		TMJ->TMJ_PCMSO   := M->TMV_PCMSO
		TMJ->TMJ_MAT     := SRA->RA_MAT
		TMJ->TMJ_CONVOC  := M->TMV_CONVOC
		TMJ->TMJ_EXAME   := M->TMV_EXAME
		TMJ->TMJ_DTPROG  := dtProg
		MSUNLOCK('TMJ')
	Else
		lRe := .f.
	Endif
	RestArea( aAreaOld  )
Return lRe
//---------------------------------------------------------------------
/*/{Protheus.doc} MDT003INDI
Verifica se existe consulta p/ esse exame

@author Andre Perez Alvarez
@since 16/02/2007
/*/
//---------------------------------------------------------------------
Static Function MDT003INDI()
	Local aArea := GetArea()
	Local lRet  := .t.

	Dbselectarea("TMJ")
	Dbsetorder(8)
	Dbseek(xFilial("TMJ")+cFicha+DTOS(dtProg)+cExame)
	While !eof() .and. xFilial("TMJ") == TMJ->TMJ_FILIAL .and. cFicha == TMJ->TMJ_NUMFIC .and. ;
			dtProg == TMJ->TMJ_DTPROG .and. M->TMV_EXAME == TMJ->TMJ_EXAME

		If TMJ->TMJ_DTCONS < dDataBase
			lRet := .t.
		Else
			lRet := .f.
			exit
		Endif
		Dbskip()
	End

	RestArea(aArea)
Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} MDT003AGE
Verifica se o medico tem agenda medica

@author Andre Perez Alvarez
@since 16/02/2007
/*/
//---------------------------------------------------------------------
Static Function MDT003AGE()

	DbSelectArea("TML")
	DbSetOrder(1)
	If !DbSeek( xFilial("TML")+M->TMV_CODUSU)
		DbSelectArea("TMK")
		DbSetOrder(1)
		DbSeek(xFilial("TMK")+M->TMV_CODUSU)
		MsgStop(STR0054+AllTrim(TMK->TMK_NOMUSU)+STR0055) //"O usuário "###" não tem agenda médica"
		Return .f.
	EndIf

	DbSelectArea("TMK")
	DbSetOrder(1)
	DbSeek(xFilial("TMK")+M->TMV_CODUSU)
	M->TMV_NOMUSU := AllTrim(TMK->TMK_NOMUSU)
	lRefresh := .t.

Return .t.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDT003Mot
Atualiza a descricao do motivo.

@author Andre Perez Alvarez
@since 16/02/2007
/*/
//---------------------------------------------------------------------
Static Function MDT003Mot()

	dbSelectArea("TMS")
	dbSetOrder(1)
	dbSeek(xFilial("TMS")+M->TMV_MOTIVO)
	M->TMV_NOMOTI := TMS->TMS_NOMOTI

	lRefresh := .t.
Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDT003REGAN
Busca convocacao anterior

@author Andre Perez Alvarez
@since 16/02/2007
/*/
//---------------------------------------------------------------------
Static Function MDT003REGAN()
	Local nIndTMV := 2
	Local cKeyTMV := cFilTMV+M->TMV_CODUSU+M->TMV_CONVOC

	Dbselectarea("SIX")
	Dbsetorder(1)
	If Dbseek("TMV"+"3")
		nIndTMV := 3
		cKeyTMV := cFilTMV+M->TMV_CODUSU+M->TMV_PCMSO+M->TMV_CONVOC
	Endif

	Dbselectarea("TMV")                     // OBTER REGISTRO ANTERIOR.
	Dbsetorder(nIndTMV)
	If Dbseek(cKeyTMV)
		nQtaten := TMV->TMV_QTATEN
		Dbskip(-1)
		If TMV->TMV_FILIAL+TMV->TMV_CODUSU == cFilTMV+M->TMV_CODUSU
			//----------------------------------------------------------------
			// Busca hora ultma consulta para dar continuidade na agenda
			//----------------------------------------------------------------
			If TMV->TMV_DTFIRE >= dInicatu
				Dbselectarea("TMJ")               // OBTER ULTIMA CONSULTA MARCADA
				Dbsetorder(5)
				Dbseek(xFilial("TMJ")+TMV->TMV_PCMSO+TMV->TMV_CODUSU+DTOS(TMV->TMV_DTFIRE)+cUltHora,.t.)
				Dbskip(-1)
				If TMJ->TMJ_DTCONS >=  dInicAtu
					dINICIO  := TMJ->TMJ_DTCONS
					nUltCons := HtoM(TMJ_HRCONS)
					nUltCons := nUltCons + M->TMV_QTATEN
				Else
					dINICIO  := dInicAtu
					nQtaten  := nQtAtual
				Endif
			Endif
		Endif
	Endif

	DbSelectArea("TMV")                     // OBTER REGISTRO ANTERIOR.
	DbSetOrder(1)
	DbSeek(cFilTMV + cPcmsoAtu + cConvoAtu)

return .t.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDT003EXA
Atualiza o nome do exame.

@author Andre Perez Alvarez
@since 16/02/2007
/*/
//---------------------------------------------------------------------
Static Function MDT003EXA()

	dbSelectArea("TM4")
	dbSetOrder(01)
	If dbSeek( xFilial("TM4") + M->TMV_EXAME)
		M->TMV_NOMEXA := TM4->TM4_NOMEXA
	Endif

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDT003NOMECAL
Atualiza a descricao do calendario.

@author Andre Perez Alvarez
@since 16/02/2007
/*/
//---------------------------------------------------------------------
Static Function MDT003NOMECAL()

	dbSelectArea("SH7")
	dbSetOrder(01)
	If dbSeek( xFilial("SH7") + M->TMV_CALEND)
		cCalendDes := SH7->H7_DESCRI
	Endif

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDT002MAQ
Inverte a marcacao do browse

@author Andre Perez Alvarez
@since 19/02/2007
/*/
//---------------------------------------------------------------------
Static Function MDT002MAQ(cMarca,lInverte)
Return .t.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDT002INV
Inverte a marcacao do browse

@author Andre Perez Alvarez
@since 19/02/2007
/*/
//---------------------------------------------------------------------
Static Function MDT002INV(cMarca)
	Local aArea := GetArea()

	Dbselectarea("TRBEX")
	Dbgotop()
	While !eof()
		TRBEX->TM5_OK := IF(TM5_OK == "  ",cMARCA,"  ")
		Dbskip()
	End

	RestArea(aArea)
Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTUTIGRAV
Grava o registro

@param cAlias - Alias da tabela onde serao gravados os dados
@param nOpcao - Opcao utilizada na enchoice

@sample MDTUTIGRAV(cAlias,nOpcao)

@author Andre Perez Alvarez
@since 21/02/2007
/*/
//---------------------------------------------------------------------
Static Function MDTUTIGRAV(cAlias,nOpcao)

	Local ny
	//-------------------------------------------
	// Grava no arquivo de Ocorrencias   - TM5
	//-------------------------------------------

	dbSelectArea( "TM5" )
	RecLock("TM5",.F.)

	For ny := 1 To TM5->(FCOUNT())
		nx := "m->" + FieldName(ny)
		FieldPut(ny, &nx.)
	Next ny
	MSUNLOCK("TM5")

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} IniBrwNoFic
Inicializa o browse do campo TMY_NOMFIC

@author Denis Hyroshi de Souza
@since 21/02/2007
/*/
//---------------------------------------------------------------------
Function IniBrwNoFic()

	Local cFilTm0 := TMY->TMY_FILIAL
	Local cNome

	If Len(AllTrim(cFilTm0)) < Len(AllTrim(xFilial("TM0")))
		cFilTm0 := xFilial("TM0")
	EndIf

	cNome := If(TM0->(dBSEEK(cFilTm0+TMY->TMY_NUMFIC)),TM0->TM0_NOMFIC,"")

Return cNome

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTCCVAL
Verifica se o centro de custo eh do cliente.

@author Andre Perez Alvarez
@since 23/10/2007
/*/
//---------------------------------------------------------------------
Function MDTCCVAL(cCodCC, cCliTemp,lAte)

	Local nSizeSA1  := If((TAMSX3("A1_COD")[1]) < 1,6,(TAMSX3("A1_COD")[1]))
	Local nSizeLo1  := If((TAMSX3("A1_LOJA")[1]) < 1,2,(TAMSX3("A1_LOJA")[1]))
	Local nSizeSI3  := If((TAMSX3("I3_CUSTO")[1]) < 1,9,(TAMSX3("I3_CUSTO")[1]))
	Local lPrest := .F.
	Default lAte := .F.

	If Type("cCliMdtPs") == "C"
		If !Empty(cCliMdtPs)
			lPrest := .T.
		Endif
	Endif

	If !lPrest //Senão for Prestador, não faz a validação
		Return .T.
	Endif

	If ValType(cCliTemp) <> "C"
		cCliTemp := cCliMdtPs
	Endif

	If Alltrim(GETMV("MV_MCONTAB")) == "CTB"
		nSizeSI3 := If((TAMSX3("CTT_CUSTO")[1]) < 1,9,(TAMSX3("CTT_CUSTO")[1]))
	Endif

	If lAte .and. cCodCC == Replicate("Z",nSizeSI3)
		Return .T.
	Endif

	If SubStr(cCodCC,1,nSizeSA1+nSizeLo1) <> cCliTemp
		msgStop(STR0079,STR0078)  //"O centro de custo selecionado não pertence ao cliente."//"ATENÇÃO"//
		Return .F.
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} ValAte2
Valida a pergunta "Ate" de qualquer tabela

@param cPar01 - Valor da pergunta "De ...   "
@param cPar02 - Valor da pergunta "Ate ...  "
@param cTab   - Alias da tabela onde a pergunta busca os dados
@param cField - Alias do campo onde a pergunta busca os dados
@param nInd   - Indice de busca na tabela

@author Andre Perez Alvarez
@since 06/12/2007
/*/
//---------------------------------------------------------------------
Function ValAte2(cPar01,cPar02,cTab,cField,nInd)
	Local nSizeField := (TAMSX3(cField)[1])

	Do Case

	Case cPar02==Replicate('Z',nSizeField)
		Return .T.
	Case Empty(cPar02)
		Help(" ",1,"ATEINVALID")
		Return .F.
	Case cPar02 < cPar01
		Help(" ",1,"DEATEINVAL")
		Return .F.
	Case cTAB == "SRA" .AND. !ExCpoMDT(cTAB,cPar02)
		Return .F.
	Case !ExistCpo(cTab,cPar02,nInd)
		Return .F.
	OtherWise
		Return .T.

	EndCase

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MdtMovEst
Gera Movimento de Requisicao e/ou Devolucao nos Arquivos de Movimentacao Interna (SD3).

@param cCod, Caracter, PRO ou RE0
@param cAlm, Caracter, Almoxerifado
@param cProd, Caracter, Produto
@param nQuant, Numerico, Quantidade
@param dData, Date, Data
@param cCeCusto, Caracter, Centro de Custo
@param cFilMov, Caracter, Filial do Movimento (SD3)

@sample NgMovEstoque(cCod,cComb)

@author Denis
@since 14/03/2006
/*/
//---------------------------------------------------------------------
Function MdtMovEst(cCod,cAlm,cProd,nQuant,dData,cDocEst,cMatFun,cFilMov,lTemEstorno,cNumeroSeq,cLoteCtl,cNumLote,cLocaliz,cNumSeri)

	Local aCab := {}
	Local aAutoItens := {}
	Local aCampEstorno := {}

	Local cRet := ""
	Local cAlmoxa := CriaVar( 'D3_LOCAL', .F. )
	Local nQtdOco := 0
	Local cCodDev := SuperGetMv( 'MV_NG2D3DE', .F. )
	Local cCodReq := SuperGetMv( 'MV_NG2D3RE', .F. )
	Local _FilialAnt := cFilAnt // Salva filial corrente

	Local nz

	Local lExecEstorno	:= .F.

	Private lMsErroAuto := .F.

	Private nOpc := 0

	Default cLoteCtl := CriaVar('D3_LOTECTL',.F.)
	Default cNumLote := CriaVar('D3_NUMLOTE',.F.)
	Default cLocaliz := CriaVar('D3_LOCALIZ',.F.)
	Default cNumSeri := CriaVar('D3_NUMSERI',.F.)
	Default cNumeroSeq := Space( 1 )
	Default lTemEstorno := .F.

	If ExistBlock( "MDT695EPI" )
		cRet := ExecBlock( "MDT695EPI",.F.,.F. )
	Else

		If Substr(cCod,1,1) == "D" .And. !Empty(cNumeroSeq)
			dbSelectArea("SD3")
			dbSetOrder(4)

			If dbSeek(xFilial("SD3") + cNumeroSeq) .And. SD3->D3_ESTORNO == "S"
				Return Space(6)
			Endif

		Endif

		If nQuant <= 0
			Return Space(6)
		Endif

		If ValType(cFilMov) == "C" .And. !Empty(cFilMov) .And. Len(cFilMov) == Len(cFilAnt)
			cFilAnt := cFilMov // Troca a filial para a que será gerada a movimentação
		Endif

		cAlmoxa := cAlm
		cProduto := cProd
		SB1->(dbSetOrder(1))
		SB1->(dbSeek(xFilial('SB1') + cProduto))

		dbSelectArea("SRA")
		dbSetOrder(1)
		dbSeek(xfilial("SRA") + cMatFun)

		If Substr(cCod,1,1) == "D" .And. lTemEstorno .And. !Empty(cNumeroSeq)
			lExecEstorno := .T.
		EndIf

		If !lExecEstorno

			If Empty(cDocEst)
				cDocEst := GETSXENUM("SD3","D3_DOC")
			EndIf

			aCab := {;
				{ "D3_DOC", cDocEst, Nil },;
				{ "D3_TM", IIf( Substr( cCod, 1, 2 ) == 'RE', cCodReq, cCodDev ), Nil },;
				{ "D3_CC", MDTCCFunc( SRA->RA_MAT, SRA->RA_CC, dData ), Nil },;
				{ "D3_EMISSAO", dData, Nil };
				}

			aAutoItens := {;
				{ "D3_COD", cProduto, Nil },;
				{ "D3_UM", SB1->B1_UM, Nil },;
				{ "D3_QUANT", nQuant, Nil },;
				{ "D3_CF", cCod, Nil },;
				{ "D3_CONTA", SB1->B1_CONTA, Nil },;
				{ "D3_LOCAL", IIf( Empty( cAlmoxa ), SB1->B1_LOCPAD, cAlmoxa ), Nil },;
				{ "D3_SEGUM", SB1->B1_SEGUM, Nil },;
				{ "D3_QTSEGUM", ConvUm( SB1->B1_COD, nQtdOco, 0, 2 ), Nil },;
				{ "D3_GRUPO", SB1->B1_GRUPO, Nil },;
				{ "D3_TIPO", SB1->B1_TIPO, Nil },;
				{ "D3_CHAVE", SubStr( SD3->D3_CF, 2, 1 ) + IIf( SD3->D3_CF $ 'RE4|DE4', '9', '0' ), Nil },;
				{ "D3_USUARIO", cUserName, Nil },;
				{ "D3_ESTORNO", IIf( Substr( cCod, 1, 1 ) == "D" .and. lTemEstorno, "S", Space( 1 ) ), Nil };
				}

			nOpc := 3

			If Rastro(cProduto)

				If !Empty(cLoteCtl)
					aAdd( aAutoItens , {"D3_LOTECTL" , cLoteCtl , Nil} )
				Endif

				If !Empty(cNumLote)
					aAdd( aAutoItens , {"D3_NUMLOTE" , cNumLote , Nil} )
				Endif

			Endif

			If Localiza(cProduto)

				If !Empty(cLocaliz)
					aAdd( aAutoItens , {"D3_LOCALIZ" , cLocaliz , Nil} )
				Endif

				If !Empty(cNumSeri)

					If Empty(cLocaliz)
						aAdd( aAutoItens , {"D3_LOCALIZ" , Space(Len(SD3->D3_LOCALIZ)) , Nil} )
					Endif

					aAdd( aAutoItens , {"D3_NUMSERI" , cNumSeri , Nil} )
				Endif

			Endif

			aAdd( aAutoItens, { "INDEX", 2, Nil } )

			MSExecAuto( { | x, y, z | MATA241( x, y, z ) }, aCab, { aAutoItens }, nOpc )

			If lMsErroAuto

				Mostraerro()

				If Type("l695ExibeMsg") == "L"
					l695ExibeMsg := .F.
				EndIf

			EndIf

			If !lMsErroAuto
				dbSelectArea("SB2")
				dbSetOrder(01)

				If !dbSeek(xFilial("SB2") + cProduto + If(Empty(cAlmoxa), SB1->B1_LOCPAD, cAlmoxa ) )
					CriaSB2(cProduto, If( Empty( cAlmoxa ), SB1->B1_LOCPAD, cAlmoxa ) )
				EndIf

				__lSx8 := .f.
			Endif

		Else
			nOpc := 5
			dbSelectArea("SD3")
			dbSetOrder(4)

			If dbSeek(xFilial("SD3") + cNumeroSeq) .And. SD3->D3_ESTORNO != "S"
				RecLock("SD3", .f.)
				SD3->D3_ESTORNO := "S"
				SD3->(MsUnlock())
				dbSelectArea("SD3")

				For nz := 1 To FCount()
					aAdd(aCampEstorno,FieldGet(nz))
				Next nz

				// Grava Registro de Devolucao
				dbSelectArea("SD3")
				RecLock("SD3",.T.)

				For nz := 1 To FCount()
					FieldPut(nz,aCampEstorno[nz])
				Next nz

				SD3->D3_TM      := cCodDev
				SD3->D3_CF      := cCod
				SD3->D3_CHAVE   := SubStr(SD3->D3_CF,2,1)+If(SD3->D3_CF $ 'RE4|DE4','9','0')
				SD3->D3_USUARIO := cUsername
				SD3->(MsUnlock())

				// Pega os 5 custos medios atuais
				aCM := PegaCMAtu(SD3->D3_COD,SD3->D3_LOCAL)

				// Grava o custo da movimentacao
				aCusto := GravaCusD3(aCM)

				B2AtuComD3(aCusto,Nil,Nil,(SD3->D3_TM > '500'),Nil,.T.)

			Else
				lMsErroAuto := .F.
			EndIf

		EndIf

		If ExistBlock( "MDT630EPI" )
			ExecBlock( "MDT630EPI",.F.,.F. )
		Endif

		cFilAnt := _FilialAnt //Retorna a filial salva
		If !lMsErroAuto
			cRet := SD3->D3_NUMSEQ
		EndIf
	EndIf

Return cRet

//---------------------------------------------------------------------
/*/{Protheus.doc} NgQtEpiDv
Valida data/hora da devolucao do EPI

@author Denis Hyroshi de Souz
@since 15/01/09
/*/
//---------------------------------------------------------------------
Function NgQtEpiDv(cFornec, cLoja, cCodEpi, dDtEntreg, cHrEntreg, cNumCap, cMatSRA)
	Local nQuant := 0
	Local cChave := xFilial("TLW") + cFornec + cLoja + cCodEpi + cNumCap + cMatSRA + DtoS(dDtEntreg) + cHrEntreg

	dbSelectArea("TLW")
	dbSetOrder(1)
	dbSeek( cChave )
	While !Eof() .and. cChave == TLW->(TLW_FILIAL+TLW_FORNEC+TLW_LOJA+TLW_CODEPI+TLW_NUMCAP+TLW_MAT+DTOS(TLW_DTENTR)+TLW_HRENTR)
		nQuant += TLW->TLW_QTDEVO
		dbSkip()
	End

Return nQuant
//---------------------------------------------------------------------
/*/{Protheus.doc} NgRetMenu
Retorna o nome do arquivo XNU aberto.

@author Denis Hyroshi de Souz
@since 25/03/2010
/*/
//---------------------------------------------------------------------
Function NgRetMenu()
	Local cMenu := " "
	Local nPosMnu, nRat
	Local aRetUsr

	PswOrder(1)
	PswSeek(__CUSERID,.T.)
	aRetUsr := PswRet()

	If Len(aRetUsr) >= 3 .and. ValType(aRetUsr[3]) == "A"
		nPosMnu := aScan( aRetUsr[3], { |x| Val( SubStr( x, 1, 2 ) ) == nModulo } )
		If nPosMnu > 0
			nRat := Rat("\",aRetUsr[3,nPosMnu])
			If nRat == 0
				nRat := Rat("/",aRetUsr[3,nPosMnu])
			Endif
			If nRat > 0
				cMenu := Substr(aRetUsr[3,nPosMnu],nRat+1)
			Endif
		Endif
	Endif


Return cMenu
//---------------------------------------------------------------------
/*/{Protheus.doc} NgAcBrowse
Retorna informações do programa, com relação a variavel acBrowse, de acordo com suas configuracoes definadas no CFG

@param cProgMenu Caracter Nome do programa

@author Denis Hyroshi de Souz
@since 11/08/2009
/*/
//---------------------------------------------------------------------
Function NgAcBrowse(cProgMenu)
	Local nI,i,nPosA
	Local cFile := Alltrim(NgRetMenu())

	If Empty(cFile)
		Return acBrowse
	Endif

	Private aMenus   := {} //contem itens dos menus escolhidos
	Private aFathers := {}
	Private nNext    := 0
	Private aXnu     := XNULoad( cFile ) //Carrega Menu

	//Carrega variavel aMenus com o menu original
	For nI := 1 To Len( aXnu )
		If ( ValType( aXnu [nI][3] ) == 'A' )
			cCargo := Padr("@"+StrZero(1,3,0)+StrZero(nI,1)+"0",10)
			cTitle := aXnu [nI][1][1]
			cFather := StrZero(nI,1)+"0"
			Aadd( aFathers, cFather )
			MontaRecur( aXnu [nI][3], nI )
		Else
			cCargo := StrZero(1,1)+"0"+StrZero(nNext,6,0)
			cTitle := aXnu [nI][1][1]
		EndIf
	Next nI
	aMenus := Asort(aMenus,,,{|x,y| x[10]<y[10]})

	//Verifica existe a rotina no menu e altera o acBrowse
	nPosA := Ascan(aMenus,{|x| x[3] == cProgMenu })
	If nPosA > 0
		acBrowse := aMenus[nPosA][5]
	Endif

Return acBrowse
//---------------------------------------------------------------------
/*/{Protheus.doc} MontaRecur
Carrega variavel aMenus com as opcoes de Menu do SIGAMDT

@author Denis Hyroshi de Souz
@since 28/07/2008
/*/
//---------------------------------------------------------------------
Static Function MontaRecur( aXnu, nTipo)
	Local nI
	Local nX
	Local cTitle
	Local cTipo
	Local aReg
	Local cAlias
	Local cCargo
	Local cFather

	For nI := 1 To Len( aXnu )
		nNext 	:= nNext + 1
		cTipo	:= StrZero(nTipo,1)+"0"
		cTitle := aXnu [nI][1][1]

		If ( ValType( aXnu [nI][3] ) == 'A' )

			cFather := aFathers[Len(aFathers)]
			cCargo  := cTipo+StrZero(nNext,6,0)
			aReg := {Str(nTipo,1)+"0",;
				{Padr(aXnu[nI][1][1],25),Padr(aXnu[nI][1][2],25),Padr(aXnu[nI][1][3],25)},;
				Space(10),;
				Space(90),;
				Space(10),;
				Space(02),;
				cCargo,;
				cFather,;
				1,;
				"",;
				1}
			aReg[10] := StrZero(1,6,0)+aReg[7]

			Aadd(aMenus,Aclone(aReg))
			cFather := cCargo
			Aadd( aFathers, cFather )

			MontaRecur( aXnu [nI][3], nTipo )
			Adel( aFathers, Len(aFathers) )
			ASize( aFathers, Len(aFathers)-1 )
		Else
			cFather := aFathers[Len(aFathers)]
			cAlias := aXnu[nI,2]
			For nX:=1 To Len(aXnu[nI,4])
				cAlias += aXnu[nI,4,nX]
			Next nX
			aReg := {Str(nTipo,1)+"0",;
				{Padr(aXnu[nI][1][1],25),Padr(aXnu[nI][1][2],25),Padr(aXnu[nI][1][3],25)},;
				aXnu [nI][3],;
				cAlias,;
				aXnu [nI][5],;
				aXnu [nI][6],;
				cTipo+StrZero(nNext,6,0),;
				cFather,;
				1,;
				"",;
				aXnu [nI][7]}
			aReg[10] := StrZero(1,6,0)+aReg[7]
			If !Empty(cFather)
				aReg[8] := cFather
			EndIf
			Aadd(aMenus,Aclone(aReg))
		EndIf
	Next

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} MdtNomTM0
Mostra o nome do funcionario no browse da TM5.

@author Denis Hyroshi de Souza
@since 13/08/2009
/*/
//---------------------------------------------------------------------
Function MdtNomTM0()
	Local cDesc := ""
	Local aArea := GetArea()

	If !Empty(TM5->TM5_FILFUN)
		cDesc := Posicione("TM0",1,xFilial("TM0",TM5->TM5_FILFUN)+TM5->TM5_NUMFIC,"TM0_NOMFIC")
	Else
		cDesc := Posicione("TM0",1,xFilial("TM0")+TM5->TM5_NUMFIC,"TM0_NOMFIC")
	EndIf
	RestArea(aArea)
Return cDesc
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTESTVAL
Valida se o funcionario tem estabilidade e emite mensagem verificando a demissao do mesmo.

@obs SIGAMDT - Valid RA_SITFOLH (GPEA010)

@author Roger Rodrigues
@since 08/09/2009
/*/
//---------------------------------------------------------------------
Function MDTESTVAL()
	Local lRet := .T.
	Local cIntegra := SuperGetMv("MV_MDTGPE",.F.,"N"), cMsg := ""
	Local aArea := GetArea("SRA"), dDtUltReg := STOD("  /  /    "), dDataMan := STOD("  /  /    ")
	Local nTipo := 0//Se 1 candidato, se 2 mandato

	If M->RA_SITFOLH == "D"
		If cIntegra <> "S"
			lRet := .T.
		Else
			dbSelectArea("SRA")
			dbSetOrder(1)
			If dbSeek(xFilial("SRA")+M->RA_MAT)
				If SRA->RA_DTVTEST >= dDataBase
					cMsg := STR0099 + DTOC(SRA->RA_DTVTEST)//"O funcionário possui estabilidade até "
					dbSelectArea("TNN")
					dbSetOrder(1)
					dbGotop()
					//Percorre todos os mandatos
					While !eof() .and. xFilial("TNN") == TNN->TNN_FILIAL //Corre mandatos
						dbSelectArea("TNO")
						dbSetOrder(1)
						If dbSeek(xFilial("TNO")+TNN->TNN_MANDAT+SRA->RA_MAT)//Verifica se o funcionário tem candidatura ao mandato e datas
							If SRA->RA_DTVTEST == TNN->TNN_ELEICA .and. TNN->TNN_ELEICA >= dDtUltReg
								dDtUltReg := TNN->TNN_ELEICA
								nTipo := 1
							Endif
						Endif
						dbSelectArea("TNQ")
						dbSetOrder(1)
						If dbSeek(xFilial("TNQ")+TNN->TNN_MANDAT+SRA->RA_MAT)//Verifica se o funcionário foi eleito para mandato e valida datas
							dDataMan := DTOS(TNN->TNN_DTTERM)
							nAno := SubStr(dDataMan, 1, 4)
							nMes := SubStr(dDataMan, 5, 2)
							nDia := SubStr(dDataMan, 7, 2)
							nAno := Alltrim(STR(VAL(nAno) + 1))
							dDataMan := CTOD(ndia+"/"+nMes+"/"+nAno)
							//Se ano fim mandato for bissexto e terminar em 29/02, dia fim da estabilidade sera 28/02 do ano seguinte
							If Substr( DtoS(TNN->TNN_DTTERM) ,5,4) == "0229"
								dDataMan := CTOD("28"+"/"+"02"+"/"+nAno)
							Endif
							If SRA->RA_DTVTEST == dDataMan .and. dDataMan >= dDtUltReg
								dDtUltReg := dDataMan
								nTipo := 2
							Endif
						Endif
						dbSelectArea("TNN")
						dbSkip()
					End
					If nTipo == 1
						cMsg += STR0100//", pois é um candidato da CIPA"
					ElseIf nTipo == 2
						cMsg += STR0101//", pois é relacionado com um mandato da CIPA"
					Endif
					cMsg += "."
				Endif
			Endif
		Endif
		If !Empty(cMsg)
			lRet := MsgYesNo(cMsg+CHR(10)+STR0102)//"Deseja demiti-lo mesmo assim?"
		Endif
	Endif

	RestArea(aArea)
Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} WHENCCSRA
Caso Prestador de Servico, modifica o F3 dos campos RA_CC e RA_CODFUNC

@author Denis
@since 08/03/2010
/*/
//---------------------------------------------------------------------
Function WHENCCSRA()
	Local lSigaMdtps := .f.

	_SetOwnerPrvt("aTROCAF3",{})

	If Type("cCliMdtPs") == "C"
		If !Empty(cCliMdtPs)
			lSigaMdtps := .t.
		Endif
	Endif

	aTROCAF3 := {}
	If lSigaMdtps
		AADD(aTROCAF3,{"RA_CC","MDTPS2"})
		AADD(aTROCAF3,{"RA_CODFUNC","TOS"})
		AADD(aTROCAF3,{"TM0_CODFUN","TOS"})
		AADD(aTROCAF3,{"R7_FUNCAO","TOS"})
		AADD(aTROCAF3,{"R7_CARGO","SQ3PSS"})
		AADD(aTROCAF3,{"TNC_CODFUN","TOS"})
		AADD(aTROCAF3,{"TOB_CODFUN","TOS"})
		AADD(aTROCAF3,{"TOC_CODFUN","TOS"})
		AADD(aTROCAF3,{"TN0_CODFUN","TOS001"})
		AADD(aTROCAF3,{"TOS_CARGO","SQ3PSS"})
		AADD(aTROCAF3,{"TO5_CODFUN","TOS001"})
		AADD(aTROCAF3,{"TKF_CODCC","MDTPS2"})
		AADD(aTROCAF3,{"TKG_CODFUN","TOS"})
		AADD(aTROCAF3,{"TKH_MATFUN","MDTPSV"})
	Else
		AADD(aTROCAF3,{"RA_CC","CTT"})
		AADD(aTROCAF3,{"RA_CODFUNC","SRJ"})
		AADD(aTROCAF3,{"TM0_CODFUN","SRJ"})
		AADD(aTROCAF3,{"R7_FUNCAO","SRJ"})
		AADD(aTROCAF3,{"R7_CARGO","SQ3"})
		AADD(aTROCAF3,{"TNC_CODFUN","SRJ"})
		AADD(aTROCAF3,{"TOB_CODFUN","SRJ"})
		AADD(aTROCAF3,{"TOC_CODFUN","SRJ"})
		AADD(aTROCAF3,{"TN0_CODFUN","SRJ"})
		AADD(aTROCAF3,{"TOS_CARGO","SQ3"})
		AADD(aTROCAF3,{"TO5_CODFUN","SRJ"})
		AADD(aTROCAF3,{"TKF_CC","CTT"})
		AADD(aTROCAF3,{"TKG_CODFUN","SRJ"})
		AADD(aTROCAF3,{"TKH_MATFUN","SRAVAC"})
	Endif

Return .t.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTRETEXA
Retorna array com exames de cada perfil: Admissional, Demissional, Retorno ao Trabalho e Mudanca de Funcao

@param 1)cFuncao  -> Codigo da Funcao
@param 2)cTipoExa -> A=Admissional;D=Demissional;R=Retorno Trab
		              M=Mud. Funcao
@param 3)aRiscos  -> Array com os riscos da funcao
@param 4)cCliMdtps-> Codigo + Loja do cliente
@param 5)lVerTM4  -> Considera informacao na tabela TM4
@param 6)lRisc    -> Considera informacao em Exames por Risco
@param 7)lExaFil  -> Considera informacao em Exames por Filial
@param 8)lExaSau  -> Considera informacao em Exames por Saude
@param 9)cFichaFun-> Codigo da Ficha Medica

@author Roger Rodrigues
@since 11/06/2010
/*/
//---------------------------------------------------------------------
Function MDTRETEXA(cFuncao,cTipoExa,aRiscos,cCliMdtps,lVerTM4,lRisc,lExaFil,lExaSau,cFichaFun)

	Local aExames := {}, i
	Local lSigaMdtPS := If( SuperGetMv("MV_MDTPS",.F.,"N") == "S", .t. , .f. )
	Local cSeekProg := xFilial("TON")+cFuncao
	Local cLoopProg := 'TON->TON_FILIAL+TON->TON_CODFUN == "' + cSeekProg + '"'
	Default cFuncao := ""
	Default aRiscos := {}
	Default cCliMdtps := ""
	Default lVerTM4 := .T.
	Default lRisc   := .F.
	Default lExaFil := .F.
	Default lExaSau := .F.
	Default cFichaFun := ""

	If lSigaMdtps
		cSeekProg := xFilial("TON")+cFuncao+cCliMdtPs
		cLoopProg := 'TON->TON_FILIAL+TON->TON_CODFUN+TON->TON_CLIENT+TON->TON_LOJA == "' + cSeekProg + '"'
	Endif

	If cTipoExa == "A" .or. cTipoExa == "M" .or. cTipoExa == "D" .or. lRisc //Exames Por Risco
		For i := 1 to Len(aRiscos)//Verifica pelos riscos
			dbSelectArea("TN2")
			dbSetOrder(1)
			dbSeek(xFilial("TN2")+aRiscos[i][1])
			While !eof() .and. xFilial("TN2") == TN2->TN2_FILIAL .and. aRiscos[i][1] == TN2->TN2_NUMRIS .And. !Empty(TN2->TN2_TIPOEX)

				If  (cTipoExa == "A" .and. !(TN2->TN2_TIPOEX $ "1 -6 -8 -9 -10 -11-12-13-14-15-16")) .or. ;
						(cTipoExa == "M" .and. !(TN2->TN2_TIPOEX $ "3 -10-11-12-13-14-15-16")) .or. ;
						(cTipoExa == "R" .and. !(TN2->TN2_TIPOEX $ "4 -11-12-16")) .or. ;
						(cTipoExa == "D" .and. !(TN2->TN2_TIPOEX $ "5 -7 -8 -9 -11-14-15")) .or. ;
						(cTipoExa == "P" .and. !(TN2->TN2_TIPOEX $ "2 -6 -7 -8 -11-12-13-14"))

					dbSelectArea("TN2")
					dbSkip()
					Loop
				Endif

				dbSelectArea("TM4")
				dbSetOrder(1)
				If dbSeek(xFilial("TM4")+TN2->TN2_EXAME) .and. (aScan(aExames,{|x| Trim(Upper(x[1])) == TN2->TN2_EXAME}) == 0)
					aAdd(aExames,{TM4->TM4_EXAME, TM4->TM4_NOMEXA,TN2->TN2_FAIXA})
				Endif

				dbSelectArea("TN2")
				dbSkip()
			End
		Next i
	Endif

	If lVerTM4 .and. !IsInCallStack("MDTR870") .and. (cTipoExa == "D" .or. cTipoExa == "A")//Demissional ou admissional
		//Verifica na TM4 todos demissionais ou admissionais
		dbSelectArea("TM4")
		dbSetOrder(1)
		dbSeek(xFilial("TM4"))
		While !eof() .and. xFilial("TM4") == TM4->TM4_FILIAL
			If (cTipoExa == "D" .and. TM4->TM4_DEMISS != "1") .or. (cTipoExa == "A" .and. TM4->TM4_ADMISS != "1")
				dbSelectArea("TM4")
				dbSkip()
				Loop
			Endif
			If (aScan(aExames,{|x| Trim(Upper(x[1])) == TM4->TM4_EXAME}) == 0)
				aAdd(aExames,{TM4->TM4_EXAME, TM4->TM4_NOMEXA,""})
			Endif
			dbSelectArea("TM4")
			dbSkip()
		End
		//Procura os exames adicionados ao funcionário pela rotina de Exames Demissionais
		dbSelectArea("TM5")
		dbSetOrder(1)//TM5_FILIAL+TM5_NUMFIC+DTOS(TM5_DTPROG)+TM5_EXAME
		dbSeek(xFilial("TM5") + cFichaFun )
		While !eof() .and. xFilial("TM5") == TM5->TM5_FILIAL  .and. TM5->TM5_NUMFIC == cFichaFun
			If (TM5->TM5_NATEXA == "5" .and. cTipoExa == "D")//Quando exame é grava pelo MDTA280 o TM5_NATEXA é 5
				dbSelectArea("TM4")
				dbSetOrder(1)
				dbSeek(xFilial("TM4") + TM5->TM5_EXAME)
				If (aScan(aExames,{|x| Trim(Upper(x[1])) == TM4->TM4_EXAME}) == 0)//Verifica se o exame já não existe no array
					aAdd(aExames,{TM4->TM4_EXAME, TM4->TM4_NOMEXA,""})
				Endif
			Endif
			TM5->(dbSkip())
		End
	Endif

	If !Empty(cFuncao) .and. NGCADICBASE("TON_CODEXA","A","TON",.F.) //Exames Por Funcao
		If !lSigaMdtps .or. (lSigaMdtps .and. !Empty(cCliMdtps))
			//Verifica no Exames por funcao
			dbSelectArea("TON")
			DbSetOrder(If(lSigaMdtPS,1,3))
			dbSeek(cSeekProg)
			While !Eof() .AND. &(cLoopProg)

				If  (cTipoExa == "A" .and. !(TON->TON_TIPOEX $ "1 -6 -8 -9 -10-11-12-13-14-15-16")) .or. ;
						(cTipoExa == "M" .and. !(TON->TON_TIPOEX $ "3 -10-11-12-13-14-15-16")) .or. ;
						(cTipoExa == "R" .and. !(TON->TON_TIPOEX $ "4 -11-12-16")) .or. ;
						(cTipoExa == "D" .and. !(TON->TON_TIPOEX $ "5 -7 -8 -9 -11-14-15")) .or. ;
						(cTipoExa == "P" .and. !(TON->TON_TIPOEX $ "2 -6 -7 -8 -11-12-13-14"))

					dbSelectArea("TON")
					dbSkip()
					Loop
				Endif

				dbSelectarea("TM4")
				dbSetorder(01)
				If dbSeek(xFilial("TM4")+TON->TON_CODEXA) .and. (aScan(aExames,{|x| Trim(Upper(x[1])) == TON->TON_CODEXA}) == 0)
					aAdd(aExames,{TM4->TM4_EXAME, TM4->TM4_NOMEXA,TON->TON_FAIXA})
				Endif
				dbSelectArea("TON")
				dbSkip()
			End
		Endif
	Endif

	If lExaFil //Exames Por Filial
		nIndTN9  := 1  //TN9_FILIAL+TN9_EXAME+TN9_FAIXA
		cSeekTN9 := xFilial("TN9")
		cCondTN9 := "TN9->TN9_FILIAL"
		If lSigaMdtps
			nIndTN9  := 3  //TN9_FILIAL+TN9_CLIENT+TN9_LOJA+TN9_EXAME+TN9_FAIXA
			cSeekTN9 := xFilial("TN9")+cCliMdtps
			cCondTN9 := "TN9->TN9_FILIAL+TN9->TN9_CLIENT+TN9->TN9_LOJA"
		Endif
		dbSelectArea("TN9")
		dbSetOrder(nIndTN9)
		dbSeek(cSeekTN9)
		While !Eof() .And. cSeekTN9 == &(cCondTN9) .And. !Empty(TN9->TN9_TIPOEX)

			If  (cTipoExa == "A" .and. !(TN9->TN9_TIPOEX $ "1 -6 -8 -9 -10-11-12-13-14-15-16")) .or. ;
					(cTipoExa == "M" .and. !(TN9->TN9_TIPOEX $ "3 -10-11-12-13-14-15-16")) .or. ;
					(cTipoExa == "R" .and. !(TN9->TN9_TIPOEX $ "4 -11-12-16")) .or. ;
					(cTipoExa == "D" .and. !(TN9->TN9_TIPOEX $ "5 -7 -8 -9 -11-14-15")) .or. ;
					(cTipoExa == "P" .and. !(TN9->TN9_TIPOEX $ "2 -6 -7 -8 -11-12-13-14"))

				dbSelectArea("TN9")
				dbSkip()
				Loop
			Endif

			dbSelectArea("TM4")
			dbSetOrder(1)
			If dbSeek(xFilial("TM4")+TN9->TN9_EXAME) .and. (aScan(aExames,{|x| x[1] == TN9->TN9_EXAME}) == 0)
				aAdd(aExames,{TM4->TM4_EXAME, TM4->TM4_NOMEXA,TN9->TN9_FAIXA})
			Endif
			dbSelectArea("TN9")
			dbSkip()
		End
	Endif

	If lExaSau .and. !Empty(cFichaFun)
		//Busca exames por Programa de Saude
		dbSelectArea("TMN")
		dbSetOrder(2)
		dbSeek(xFilial("TMN") + cFichaFun)
		While !Eof() .AND. xFilial("TMN")+cFichaFun == TMN->TMN_FILIAL+TMN->TMN_NUMFIC

			nIndTN8  := 1 //TN8_FILIAL+TN8_CODPRO
			cSeekTN8 := xFilial("TN8") + TMN->TMN_CODPRO
			cCondTN8 := "TN8->TN8_FILIAL+TN8->TN8_CODPRO"
			If lSigaMdtps
				nIndTN8  := 4 //TN8_FILIAL+TN8_CLIENT+TN8_LOJA+TN8_CODPRO
				cSeekTN8 := xFilial("TN8") + TMN->TMN_CLIENT + TMN->TMN_LOJA + TMN->TMN_CODPRO
				cCondTN8 := "TN8->TN8_FILIAL+TN8->TN8_CLIENT+TN8->TN8_LOJA+TN8->TN8_CODPRO"
			Endif
			dbSelectArea("TN8")
			dbSetOrder(nIndTN8)
			dbSeek( cSeekTN8 )
			While !Eof() .And. cSeekTN8 == &(cCondTN8) .And.!Empty(TN8->TN8_TIPOEX)

				If  (cTipoExa == "A" .and. !(TN8->TN8_TIPOEX $ "1 -6 -8 -9 -10-11-12-13-14-15-16")) .or. ;
						(cTipoExa == "M" .and. !(TN8->TN8_TIPOEX $ "3 -10-11-12-13-14-15-16")) .or. ;
						(cTipoExa == "R" .and. !(TN8->TN8_TIPOEX $ "4 -11-12-16")) .or. ;
						(cTipoExa == "D" .and. !(TN8->TN8_TIPOEX $ "5 -7 -8 -9 -11-14-15")) .or. ;
						(cTipoExa == "P" .and. !(TN8->TN8_TIPOEX $ "2 -6 -7 -8 -11-12-13-14"))

					dbSelectArea("TN8")
					dbSkip()
					Loop
				Endif

				dbSelectArea("TM4")
				dbSetOrder(1)
				If dbSeek(xFilial("TM4")+TN8->TN8_EXAME) .and. (aScan(aExames,{|x| x[1] == TN8->TN8_EXAME}) == 0)
					aAdd(aExames,{TM4->TM4_EXAME, TM4->TM4_NOMEXA,TN8->TN8_FAIXA})
				Endif
				dbSelectArea("TN8")
				dbSkip()
			End
			dbSelectArea("TMN")
			dbSkip()
		End
	Endif

Return aExames

//---------------------------------------------------------------------
/*/{Protheus.doc} MdtClickR
Verifica e cria opções de Right Click nas rotinas:
MDTA160 - Atendimento Medico
MDTA155 - Diagnóstico Medico

@author Denis
@since 30/07/2010
/*/
//---------------------------------------------------------------------
Static Function MdtClickR()
	Local lAtivar := NGCADICBASE("TQD_ATIVAR","D","TQD",.F.)
	Local aClicks := {}
	Local nFor, cTemp
	Local nTamPgr := Len(TQD->TQD_PROGRA)
	Local nTamFun := Len(TQD->TQD_FUNCAO)
	Local aAreaTQC:= {}
	Local aAreaTQD:= {}

	aAdd( aClicks , { "MDTA160" , nil , "1" , "MDT160TL5"		, "" , STR0444	} )//"Atendimento de Enfermagem Vinculado"
	aAdd( aClicks , { "MDTA160" , nil , "1" , "MDTA925"			, "" , STR0445	} )//"Encaminhar ao Especialista"
	aAdd( aClicks , { "MDTA155" , nil , "1" , "MDT160TL5"		, "" , STR0444	} )//"Atendimento de Enfermagem Vinculado"
	aAdd( aClicks , { "MDTA155" , nil , "1" , "MDTA925"			, "" , STR0445	} )//"Encaminhar ao Especialista"

	If FindFunction( "MDTC990" )
		aAdd( aClicks , { "MDTA005" , Nil , "1" , "MDTC990" , "TM0->TM0_NUMFIC" 	, STR0446 } )//"Histórico Pregresso"
		dbSelectArea("TQC")
		dbSetOrder(1)
		If !dbSeek(xFilial("TQC")+"MDTA005")
			RecLock("TQC",.T.)
			TQC->TQC_FILIAL := xFilial("TQC")
			TQC->TQC_PROGRA := "MDTA005"
			TQC->TQC_DESCRI := STR0038//Ficha Médica
			TQC->(MsunLock())
		EndIf
		aAdd( aClicks , { "MDTA155" , Nil , "1" , "MDTC990" , "M->TMT_NUMFIC" 		, STR0446 } )//"Histórico Pregresso"
	EndIf

	For nFor := 1 To Len(aClicks)
		cTemp := TqdProxSeq( PadR(aClicks[nFor,1],nTamPgr) , PadR(aClicks[nFor,4],nTamFun) )
		If !Empty(cTemp)
			dbSelectArea("TQD")
			dbSetOrder(2)
			If !dbSeek( xFilial("TQD") + PadR(aClicks[nFor,1],nTamPgr) + cTemp )
				RecLock("TQD",.T.)
				TQD->TQD_FILIAL := xFilial("TQD")
				TQD->TQD_PROGRA := PadR(aClicks[nFor,1],nTamPgr)
				TQD->TQD_SEQUEN := cTemp
				TQD->TQD_TIPOFU := aClicks[nFor,3]
				TQD->TQD_FUNCAO := aClicks[nFor,4]
				TQD->TQD_PARAM  := aClicks[nFor,5]
				TQD->TQD_DESPOR := aClicks[nFor,6]
				TQD->TQD_DESING := aClicks[nFor,6]
				TQD->TQD_DESESP := aClicks[nFor,6]
				If lAtivar
					TQD->TQD_ATIVAR := '1'
				Endif
				MsunLock("TQD")
			EndIf
		EndIf
	Next nFor

	//Deleta a opção Funcionários por Programas do click da direita, evitando que apareça no Ações Relacionadas\\
	aAreaTQC := TQC->(getArea())
	aAreaTQD := TQD->(getArea())

	dbSelectArea("TQC")
	dbSetOrder(1)
	If dbSeek(xFilial("TQC") + "MDTA114") //Cadastros de Programas de Saude e Exames
		RecLock( "TQC" , .F. )
		dbDelete()
		MsUnlock("TQC")
	EndIf

	dbSelectArea("TQD")
	dbSetOrder(1)
	If dbSeek(xFilial("TQD") + "MDTA115") //Funcionários por Programas
		RecLock( "TQD" , .F. )
		dbDelete()
		MsUnlock("TQD")
	EndIf

	RestArea(aAreaTQC)
	RestArea(aAreaTQD)

Return .t.
//---------------------------------------------------------------------
/*/{Protheus.doc} TqdProxSeq
Calcula a proxima sequencia do programa para o click da direita.
Se retornar vazio, eh porque a funcao ja existe.

@author Denis
@since 30/07/2010
/*/
//---------------------------------------------------------------------
Function TqdProxSeq( cCodxPgr , cCodxFun )
	Local cTemp := "  "
	Local nTemp := 0

	dbSelectArea("TQD")
	dbSetOrder(1)
	If !dbSeek( xFilial("TQD") + cCodxPgr + cCodxFun )
		//Se não existir a função para o programa, calcula a proxima sequencia
		dbSelectArea("TQD")
		dbSetOrder(2)
		dbSeek( xFilial("TQD") + cCodxPgr + "99" , .T. )
		If !Found()
			dbSkip(-1)
		Endif
		If !Bof() .and. xFilial("TQD") + cCodxPgr == TQD->TQD_FILIAL + TQD->TQD_PROGRA
			nTemp := Val(TQD->TQD_SEQUEN) + 1
		Else
			nTemp := 1
		Endif
		If nTemp <= 99
			cTemp := StrZero(nTemp,2)
		Endif
	Endif

Return cTemp
//---------------------------------------------------------------------
/*/{Protheus.doc} MdtTemTOL
Verifica se o Cliente tem contrato ativo

@author Denis
@since 30/07/2010
/*/
//---------------------------------------------------------------------
Function MdtTemTOL(cCodTOL, cLojaTOL, cProdTOL, lMsgTOL )
	Local aAreaOld  := GetArea()//Salva Área posicionada.
	Local cCli     := " ", cUniTmp
	Local nSizeCli := If((TAMSX3("A1_COD")[1]) < 1,6,(TAMSX3("A1_COD")[1]))
	Local lTemTOL  := .T.

	Default lMsgTOL  := .T.
	Default cProdTOL := " "

	If ValType(cCodTOL) == "C" .and. ValType(cLojaTOL) == "C"
		cCli := cCodTOL+cLojaTOL
	ElseIf Type("cCliMdtPs") == "C"
		cCli := cCliMdtPs
	Endif

	If !Empty(cCli)
		lTemTOL := .f.
		dbSelectArea("TOL")
		dbSetOrder(2)
		dbSeek(xFilial("TOL")+cCli)
		While !Eof() .and. xFilial("TOL")+cCli == TOL->(TOL_FILIAL+TOL_CLIENT+TOL_LOJACL)
			If TOL->TOL_STATUS <> "4"
				If !Empty(cProdTOL)
					dbSelectArea("TOM")
					dbSetOrder(1)
					If dbSeek(xFilial("TOM")+TOL->TOL_NUMERO+PADR("MDTE"+cProdTOL,Len(TOM->TOM_SERVIC)))
						lTemTOL := .t.
						Exit
					Endif
				Else
					lTemTOL := .t.
					Exit
				Endif
			Endif
			dbSelectArea("TOL")
			dbSkip()
		End
		If !lTemTOL
			dbSelectArea("TOL")
			dbSetOrder(2)
			dbSeek(xFilial("TOL")+Substr(cCli,1,nSizeCli))
			cUniTmp := TOL->TOL_LOJACL
			While !Eof() .and. xFilial("TOL")+Substr(cCli,1,nSizeCli)+cUniTmp == TOL->(TOL_FILIAL+TOL_CLIENT+TOL_LOJACL)
				If TOL->TOL_STATUS <> "4"
					If !Empty(cProdTOL)
						dbSelectArea("TOM")
						dbSetOrder(1)
						If dbSeek(xFilial("TOM")+TOL->TOL_NUMERO+PADR("MDTE"+cProdTOL,Len(TOM->TOM_SERVIC)))
							lTemTOL := .t.
							Exit
						Endif
					Else
						lTemTOL := .t.
						Exit
					Endif
				Endif
				dbSelectArea("TOL")
				dbSkip()
			End

			If lMsgTOL .and. !lTemTOL
				If !Empty(cProdTOL)
					MsgStop("O Cliente não possui o exame no contrato.")
				Else
					MsgStop("O Cliente não possui contrato ativo.")
				Endif
			Endif
		Endif
	Endif

	RestArea( aAreaOld  )

Return lTemTOL

//---------------------------------------------------------------------
/*/{Protheus.doc} RetBoxTL5
Retorna a lista de opcoes do campo TL5_INDICA

@author Denis
@since 30/07/2010
/*/
//---------------------------------------------------------------------
Function RetBoxTL5()
	Local cRet
	cRet :=  "1="+STR0206+; //"Inalação"
	";2="+STR0207+; //"Acidente"
	";3="+STR0208+; //"Medicamento"
	";4="+STR0209+; //"Verificar P.A."
	";5="+STR0210+; //"Verificar Temperatura"
	";6="+STR0211+; //"Medicamento Injetável"
	";7="+STR0212+; //"Curativo"
	";8="+STR0213+; //"Massagem"
	";9="+STR0214+; //"Fisioterapia"
	";A="+STR0114+; //"Outros"
	";B="+STR0815 //"Vacinação"

Return cRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTRETFIL
Retorna filiais que nao sao prestador em um array

@author Roger Rodrigues
@since 03/09/2010
/*/
//---------------------------------------------------------------------
Function MDTRETFIL(cAlias, cFilDe, cFilAte)
	Local aFiliais := {}
	Local aAreaSM0 := SM0->(GetArea())

	If NGSX2MODO(cAlias) != "C"//Verifica se a tabela esta exclusiva
		dbSelectArea("SM0")
		dbGoTop()
		If Empty(cFilDe)
			dbSeek(cEmpAnt)
		Else
			dbSeek(cEmpAnt+cFilDe)
		Endif
		While !Eof() .and. SM0->M0_CODIGO == cEmpAnt .and. SM0->M0_CODFIL <= cFilAte
			//Verifica se a filial nao é prestadora
			If fVldParamPS( SM0->M0_CODFIL )
				aAdd( aFiliais , {SubStr(SM0->M0_CODFIL,1,SM0->M0_SIZEFIL), Upper(Substr(SM0->M0_NOME, 1, 40)) })
			Endif
			dbSelectArea("SM0")
			dbSkip()
		End
		RestArea(aAreaSM0)
	Else
		aAdd( aFiliais , {cFilAnt, Upper(Substr(SM0->M0_NOME, 1, 40)) })
	Endif

Return aFiliais
//---------------------------------------------------------------------
/*/{Protheus.doc} fVldParamPS
Valida o parâmetro de Prestador de Serviço - Retirada Sonarqube P.O.G.

@param cFilVld, Caracter, Filial a ser verificada

@return Lógico, Indicas se a Filial é Prestadora
@author Jackson Machado
@since 12/12/2018
/*/
//---------------------------------------------------------------------
Static Function fVldParamPS( cFilVld )
	Default cFilVld := SM0->M0_CODFIL
Return SuperGetMv( "MV_MDTPS", .F., "N", cFilVld ) != "S"
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTVLFIL
Valida De/Ate filial dos parametros de relatorios

@author Roger Rodrigues
@since 03/09/2010
/*/
//---------------------------------------------------------------------
Function MDTVLFIL(cFil1, cFil2, nOpc)
	Local lRet := .T.
	Local nSizeFil	:= If(FindFunction("FWSizeFilial"),FwSizeFilial(),Len(SRA->RA_FILIAL))

	//Valida o De Filial
	If nOpc == 1
		If Empty(cFil1) .or. FILCHKNEW(cEmpAnt, cFil1)
			lRet := .T.
		Endif
	Else//Valida o Ate Filial
		If NaoVazio(cFil2)
			If cFil2 == Replicate("Z", nSizeFil)
				lRet := .T.
			Else
				If cFil2 < cFil1
					Help(" ",1,"DEATEINVAL")
					lRet := .F.
				Else
					If !FILCHKNEW(cEmpAnt, cFil2)
						lRet := .F.
					Endif
				Endif
			Endif
		Endif
	Endif

Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTCCPSVL
Funcao para validacao de centro de custo no Prestador de Servico

@author Roger Rodrigues
@since 06/12/2010
/*/
//---------------------------------------------------------------------
Function MDTCCPSVL(cCusto,cTipo,lValCli)
	Local aSaveArea := GetArea()
	Local lRet	:= .T., lCusNil
	Default lValCli := .T.

	If (lCusNil := cCusto = Nil)
		cCusto := &(ReadVar())
	Endif

	//Verifica se a filial nao eh prestador
	If (SuperGetMv("MV_MDTPS",.F.,"N",cFilAnt) != "S")
		lRet := CTB105CC(cCusto,cTipo)
	Else
		If !CtbInUse()				// Compatilizacao para usar tambem com SigaCon
			Return ExistCpo("SI3",cCusto)	// Nao utilizo ValidaCusto por ser recursiva
		Endif

		If cTipo = Nil			// Chamada externa lancamentos contabeis nao passar tipo
			dDataLanc := dDataBase
		Endif

		ConvCusto(@cCusto)

		lRet := ValidaCusto(cCusto,cTipo,,,.T.)
		If lRet .and. cTipo <> Nil // Chamada externa lancamentos contabeis nao passar tipo
			C102ExbCC(cCusto)
		EndIf

		If lRet
			If cTipo = Nil .And. lCusNil		// Chamada externa lancamentos contabeis nao passar tipo
				&(ReadVar()) := cCusto
			Endif
		Endif
	Endif

	RestArea(aSaveArea)
Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTRetTar
Função gernérica que retorna as tarefas do funcionário

@return aTarefas, Array, Array contendo as tarefas realizadas pelo funcionário no período

@param	cNumMat, Caractere, Matrícula do funcionário
@param	dDataTar, Data, Data a ser considerada na busca das tarefas

@sample MDTRetTar( "000234", 01/01/2022 )

@author	Luis Fellipy Bett
@since	26/04/2022
/*/
//---------------------------------------------------------------------
Function MDTRetTar( cNumMat, dDataTar )

	//Salva a área
	Local aArea := GetArea()

	//Variável de busca das informações
	Local aTarFun := {}

	//Variáveis de tabelas temporárias
	Local cAliasTN6 := GetNextAlias()

	//Define o valor padrão dos parâmetros
	Default dDataTar := dDataBase

	//Transforma a data em caracter
	cDataTar := DToS( dDataTar )

	//------------------------------------------------------------------
	// Monta a query para busca das tarefas relacionadas ao funcionário
	//------------------------------------------------------------------
	BeginSQL Alias cAliasTN6

		SELECT
			TN6.TN6_CODTAR
		FROM
			%Table:TN6% TN6
		WHERE
			TN6.TN6_FILIAL = %xFilial:TN6% AND
			TN6.TN6_MAT = %Exp:cNumMat% AND
			TN6.TN6_DTINIC <= %Exp:cDataTar% AND
			( TN6.TN6_DTTERM >= %Exp:cDataTar% OR TN6.TN6_DTTERM = %Exp:Space( 8 )% ) AND
			TN6.%NotDel%

	EndSQL

	dbSelectArea( cAliasTN6 )
	( cAliasTN6 )->( dbGoTop() )
	While ( cAliasTN6 )->( !Eof() )

		//Caso a tarefa não existir no array
		If aScan( aTarFun, { |x| x[ 1 ] == ( cAliasTN6 )->TN6_CODTAR } ) == 0

			//Adiciona no array
			aAdd( aTarFun, { ( cAliasTN6 )->TN6_CODTAR } )

		EndIf

		//Pula o registro
		( cAliasTN6 )->( dbSkip() )

	End

	//Exclui a tabela temporária
	( cAliasTN6 )->( dbCloseArea() )

	//Retorna a área
	RestArea( aArea )

Return aTarFun

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTRETRIS
Posiciona e Retorna os riscos cujo funcionario esteve exposto

@param dDataVal, Data, Data a ser comparada com datas de tarefas e risco
@param cNumfic, Caracter, Numero da Ficha Medica a ser verificada
@param cNatExa, Caracter, Utilizada no ASO, natureza do exame
@param bBloco, Bloco, Bloco para execucao de funcoes especificas
@param cVal, Caracter, Adicao de validacoes no risco (bValRisco)
@param aTabTar, Array, Tarefas a serem verificadas
@param lCheckAll, Lógico, Indica se verifica riscos com tarefa "*"
@param lPosic, Lógico, Verifica se busca informações do CC e Função.
@param lTOB, Lógico, Utilização da tabel TOB.
@param lChumb, Lógico, Passar valores especifícos as variaveis de busca do risco.
@param aFixos, Array, Array com valores fixos para popular variaveis da busca do risco.
@param cVldEsp, Caracter, Validação específica para substituir a validaçõ padrão de risco (bValRisco)

@return Array - {Riscos,Candidato,Tarefas}

@obs Todos parametros sao opcionais. Uso - MDTA200/MDTR465/MDTA695 - Varios Fontes

@author Roger Rodrigues
@since 06/12/2010
/*/
//---------------------------------------------------------------------
Function MDTRETRIS(dDataVal,cNumFic,cNatExa,bBloco,cVal,aTabTar,lCheckAll,lPosic,lTOB,lChumb,aFixos,cVldEsp)
	Local i,j,k,nTotComb,nTotComTar
	Local tempCC, tempFun, tempTar, tempDep
	Local aRisExp   := {}
	Local bValRisco := '{|dData| !Empty(TN0->TN0_DTAVAL) .and. TN0->TN0_DTRECO <= dData .and. (TN0->TN0_DTELIM > dData .or. Empty(TN0->TN0_DTELIM))'
	Local lPosTrab  := .f., lCandid   := .f.
	Local nIndTN0   := 5
	Local lSigaMdtPS:= SuperGetMv("MV_MDTPS",.F.,"N") == "S"
	Local lDepto    := NGCADICBASE( "TN0_DEPTO", "A" , "TN0" , .F. )
	Local cEmpBkp	:= ""
	Local cFilBkp	:= ""
	Local aTblOpen 	:= { { "SRJ" , 01 } , { "CTT" , 01 }, { "SQB" , 01 }, { "TN5" , 01 } , { "TN6" , 01 } , { "TN0" , 01 } , { "TKD" , 01 } , { "TM0" , 01 } , { "SRA" , 01 } , { "TMX" , 01 } , { "TN7" , 01 } , { "TMA" , 01 } }

	Default dDataVal	:= dDataBase
	Default cNumFic		:= TM0->TM0_NUMFIC
	Default cNatExa 	:= ""
	Default bBloco  	:= {||}
	Default cVal		:= ""
	Default aTabTar		:= {}
	Default lCheckAll	:= .T.
	Default lPosic		:= .T.
	Default lTOB		:= .F.
	Default lChumb		:= .F.
	Default aFixos		:= {}
	Default cVldEsp		:= ""

	Private strCC    := space(9)
	Private strTar   := space(6)
	Private strFun   := space(5)
	Private strDep   := If( lDepto, Space(9), "")
	Private cCodFun  := "TN0->TN0_CODFUN"
	Private nSizeSI3 := If((TAMSX3("I3_CUSTO")[1]) < 1,9,(TAMSX3("I3_CUSTO")[1]))
	Private nSizeSRJ := If((TAMSX3("RJ_FUNCAO")[1]) < 1,5,(TAMSX3("RJ_FUNCAO")[1]))
	Private nSizeTN5 := If((TAMSX3("TN5_CODTAR")[1]) < 1,6,(TAMSX3("TN5_CODTAR")[1]))
	Private nSizeSQB := If((TAMSX3("QB_DEPTO")[1]) < 1,9,(TAMSX3("QB_DEPTO")[1]))

	//Verifica se utiliza Posto
	If  TM0->(FieldPos("TM0_CODPOS")) > 0 .and. SRA->(FieldPos("RA_POSTO")) > 0 .and. ;
			TN0->(FieldPos("TN0_CODPOS")) > 0 .and. (TAMSX3("ZZI_COD")[1]) > 0
		lPosTrab := .t.
		nIndTN0  := 8
		cCodFun  := "TN0->TN0_CODPOS"
		nSizeSRJ := (TAMSX3("ZZI_COD")[1])
	Endif

	//Adiciona validacao do usuario
	If Empty( cVldEsp )
		bValRisco += cVal

		If lSigaMdtps
			bValRisco += " .and. TN0->TN0_CODCLI+TN0->TN0_LOJACL == '"+If(Type("cCliMdtps") != "U", cCliMdtps, SA1->A1_COD+SA1->A1_LOJA)+"'"
		Endif
		bValRisco += "}"
	Else
		bValRisco := cVldEsp
	EndIf

	If lDepto
		nTotComb  := 9
		nTotComTar:= 8
	Else
		nTotComb  := 5
		nTotComTar:= 4
	EndIf

	//Busca informacoes de C.C. e Funcao do funcionario
	If lPosic
		//Busca informacoes de C.C. e Funcao do funcionario
		dbSelectArea("TM0")
		dbSetOrder(1)//TM0_FILIAL+TM0_NUMFIC
		dbSeek(xFilial("TM0")+cNumFic)
	EndIf

	If lPosic .And. ( Empty(TM0->TM0_MAT) .Or. cNatExa $ "1/3" )
		If Empty(TM0->TM0_MAT)
			lCandid := .t.
		EndIf
		If FieldPos("TM0_CC") > 0
			If !Empty(TM0->TM0_CC)
				strCC   := TM0->TM0_CC
			Endif
		Endif
		If FieldPos("TM0_CODFUN") > 0 .And. !lPosTrab
			If !Empty(TM0->TM0_CODFUN)
				strFun  := TM0->TM0_CODFUN
			Endif
		Endif
		If lPosTrab
			If !Empty(TM0->TM0_CODPOS)
				strFun  := TM0->TM0_CODPOS
			Endif
		Endif
		If FieldPos("TM0_DEPTO") > 0
			If !Empty(TM0->TM0_DEPTO)
				strDep   :=  If( !Empty( TM0->TM0_DEPTO ), TM0->TM0_DEPTO , Padr( TM0->TM0_DEPTO , nSizeSQB ) )
			Endif
		Endif
	Else
		If lPosic
			dbSelectArea("SRA")
			dbSetOrder(1)
			dbSeek(xFilial("SRA",TM0->TM0_FILFUN) + TM0->TM0_MAT)
		EndIf
		strCC   := SRA->RA_CC
		If !lPosTrab
			strFun  := SRA->RA_CODFUNC
		Else
			strFun  := SRA->RA_POSTO
		Endif
		If SRA->(FieldPos("RA_DEPTO")) > 0
			strDep := SRA->RA_DEPTO
		EndIf
	Endif

	If cNatExa == "3"
		lRelat := isInCallStack("NG200IMP") .Or. isInCallStack("NGIMPRASO")
		If TMY->(FieldPos("TMY_EMPFUT")) > 0 .And. TMY->(FieldPos("TMY_FILFUT")) > 0
			cEmpFut := ""
			cFilFut := ""
			If !lRelat
				cEmpFut := M->TMY_EMPFUT
				cFilFut := M->TMY_FILFUT
			Else
				cEmpFut := TMY->TMY_EMPFUT
				cFilFut := TMY->TMY_FILFUT
			Endif

			If cEmpFut <> cEmpAnt .And. !Empty( cEmpFut )
				cEmpBkp := cEmpAnt
				cFilBkp := cFilAnt

				NGPrepTBL( aTblOpen , cEmpFut , cFilFut )

				cEmpAnt := cEmpFut
				cFilAnt := cFilFut
			ElseIf cFilFut <> cFilAnt .And. !Empty( cFilFut )
				cFilBkp := cFilAnt
				cFilAnt := cFilFut
			EndIf
		EndIf
		If TMY->(FieldPos("TMY_NOVCC")) > 0
			If !lRelat
				strCC := If( !Empty(M->TMY_NOVCC) , Padr( M->TMY_NOVCC , nSizeSI3 ) , strCC )
			Else
				strCC := If( !Empty(TMY->TMY_NOVCC) , Padr( TMY->TMY_NOVCC , nSizeSI3 ) , strCC )
			Endif
		EndIf
		If TMY->(FieldPos("TMY_NOVFUN")) > 0
			If !lRelat
				strFun := If( !Empty(M->TMY_NOVFUN) , Padr( M->TMY_NOVFUN , nSizeSRJ ) , strFun )
			Else
				strFun := If( !Empty(TMY->TMY_NOVFUN) , Padr( TMY->TMY_NOVFUN , nSizeSRJ ) , strFun )
			Endif
		EndIf
		If TMY->(FieldPos("TMY_NOVDEP")) > 0
			If !lRelat
				strDep :=  If( !Empty(M->TMY_NOVDEP) , Padr( M->TMY_NOVDEP , nSizeSQB ) , strDep )
			Else
				strDep := If( !Empty(TMY->TMY_NOVDEP) , Padr( TMY->TMY_NOVDEP , nSizeSQB ) , strDep )
			Endif
		EndIf
		If TMY->(FieldPos("TMY_NOVTAR")) > 0
			If !lRelat
				If !Empty(M->TMY_NOVTAR)
					aADD(aTabtar, Padr( M->TMY_NOVTAR , nSizeTN5 ))
				EndIf
			Else
				If !Empty(TMY->TMY_NOVTAR)
					aADD(aTabtar, Padr( TMY->TMY_NOVTAR , nSizeTN5))
				EndIf
			EndIf
		EndIf
	Endif

	If lTOB
		strCC := TOB->TOB_CC
		strFun := TOB->TOB_CODFUN
		If lDepto
			strDep := TOB->TOB_DEPTO
		EndIf
	EndIf

	If lChumb//passa valores fixos as variaveis.
		strCC := aFixos[1]
		strFun := aFixos[2]
		If lDepto
			strDep := aFixos[3]
		Endif
	Endif

	If Len(aTabTar) == 0
		//Carrega todas tarefas executadas
		If !lCandid
			dbSelectArea("TN6")
			dbSetOrder(2)
			If dbSeek(xFilial("TN6") + SRA->RA_MAT)
				While !Eof() .AND. SRA->RA_FILIAL == xFilial("SRA") .AND. SRA->RA_MAT == TN6->TN6_MAT

					If IIf( M->TMY_NATEXA == '1', .T., TN6->TN6_DTINIC <= dDataVal ) .And.;
							( TN6->TN6_DTTERM >= dDataVal .Or. Empty( TN6->TN6_DTTERM ) )

						aAdd( aTabtar, TN6_CODTAR )

					Endif

					( 'TN6' )->( dbSkip() )

				End
			EndIf
		Else
			If lPosic .And. NGCADICBASE("TKD_NUMFIC","D","TKD",.F.)
				dbSelectArea("TKD")
				dbSetOrder(1)
				If dbSeek(xFilial("TKD") + TM0->TM0_NUMFIC)
					While !Eof() .AND. TKD->TKD_FILIAL == xFilial("TKD") .AND. TM0->TM0_NUMFIC == TKD->TKD_NUMFIC
						If TKD->TKD_DTINIC <= dDataVal .and. (TKD->TKD_DTTERM >= dDataVal .or. Empty(TKD->TKD_DTTERM))
							aADD(aTabtar, TKD_CODTAR)
						Endif
						dbSelectArea("TKD")
						dbSkip()
					End
				EndIf
			Endif
		Endif
	Endif

	//Verifica todos riscos possiveis relacionados ao funcionario
	For j:=1 to nTotComb
		If j==1//Verifica por tarefa
			For i:=1 to Len(aTabTar)
				tempTar	:= aTabTar[i]

				For k := 1 to nTotComTar
					If k==1
						tempCC	:= strCC
						tempFun	:= strFun
						tempDep := strDep
					ElseIf k==2
						tempCC	:= Padr("*",nSizeSI3)
						tempFun	:= strFun
						tempDep := strDep
					ElseIf k==3
						tempCC	:= Padr("*",nSizeSI3)
						tempFun	:= Padr("*",nSizeSRJ)
						tempDep := strDep
					ElseIf k==4
						tempCC	:= strCC
						tempFun	:= Padr("*",nSizeSRJ)
						tempDep := strDep
					ElseIf k==5
						tempCC	:= strCC
						tempFun	:= strFun
						tempDep := Padr("*",nSizeSQB)
					ElseIf k==6
						tempCC	:= Padr("*",nSizeSI3)
						tempFun	:= strFun
						tempDep := Padr("*",nSizeSQB)
					ElseIf k==7
						tempCC	:= strCC
						tempFun	:= Padr("*",nSizeSRJ)
						tempDep := Padr("*",nSizeSQB)
					Else
						tempCC	:= Padr("*",nSizeSI3)
						tempFun	:= Padr("*",nSizeSRJ)
						tempDep := Padr("*",nSizeSQB)
					Endif
					dbSelectArea("TN0")
					dbSetOrder(nIndTN0)
					If dbSeek(xFilial("TN0") + tempCC + tempFun + tempTar + tempDep)
						While !Eof() .AND. TN0->TN0_CC == tempCC .AND. &(cCodFun) == tempFun  .AND. ;
								TN0->TN0_CODTAR == tempTar .And. TN0->TN0_FILIAL == xFilial("TN0") .And.;
								If( lDepto,(TN0->TN0_DEPTO == tempDep), .T.)

								If Eval(&(bValRisco),dDataVal)
									//Adiciona no Array de retorno
									If aScan(aRisExp, {|x| x[1] == TN0->TN0_NUMRIS}) == 0
										aAdd(aRisExp, {TN0->TN0_NUMRIS, TN0->TN0_AGENTE})
									Endif
									Eval(bBloco)//Chamada para eventuais particularidades de outros fontes
								Endif

								dbSelectArea("TN0")
								dbSkip()
							End
						Endif
					Next k
				Next i
			ElseIf lCheckAll//Verifica com tarefa "*"
				tempTar	:= Padr("*",nSizeTN5)
				If j==2
					tempCC	:= strCC
					tempFun	:= strFun
					tempDep := strDep
				ElseIf j==3
					tempCC	:= Padr("*",nSizeSI3)
					tempFun	:= strFun
					tempDep := strDep
				ElseIf j==4
					tempCC	:= strCC
					tempFun	:= Padr("*",nSizeSRJ)
					tempDep := strDep
				ElseIf j==5
					tempCC	:= Padr("*",nSizeSI3)
					tempFun	:= Padr("*",nSizeSRJ)
					tempDep := strDep
				ElseIf j==6
					tempCC	:= strCC
					tempFun	:= strFun
					tempDep := Padr("*",nSizeSQB)
				ElseIf j==7
					tempCC	:= Padr("*",nSizeSI3)
					tempFun	:= strFun
					tempDep := Padr("*",nSizeSQB)
				ElseIf j==8
					tempCC	:= strCC
					tempFun	:= Padr("*",nSizeSRJ)
					tempDep := Padr("*",nSizeSQB)
				Else
					tempCC	:= Padr("*",nSizeSI3)
					tempFun	:= Padr("*",nSizeSRJ)
					tempDep := Padr("*",nSizeSQB)
				Endif
				dbSelectArea("TN0")
				dbSetOrder(nIndTN0)
				If dbSeek(xFilial("TN0") + tempCC + tempFun + tempTar + tempDep )
					While !Eof() .AND. TN0->TN0_CC == tempCC .AND. &(cCodFun) == tempFun .AND. ;
							TN0->TN0_CODTAR == tempTar .And. TN0->TN0_FILIAL == xFilial("TN0") .And. ;
							If( lDepto,(TN0->TN0_DEPTO == tempDep), .T.)

							If Eval(&(bValRisco),dDataVal)
								//Adiciona no Array de retorno
								If aScan(aRisExp, {|x| x[1] == TN0->TN0_NUMRIS}) == 0
									aAdd(aRisExp, {TN0->TN0_NUMRIS, TN0->TN0_AGENTE})
								Endif
								Eval(bBloco)//Chamada para eventuais particularidades de outros fontes
							Endif

							dbSelectArea("TN0")
							dbSkip()
						End
					Endif
				Endif
			Next j

			If !Empty( cEmpBkp ) .And. cEmpBkp <> cEmpAnt
				NGPrepTBL( aTblOpen , cEmpBkp , cFilBkp )

				cEmpAnt := cEmpBkp
				cFilAnt := cFilBkp
			ElseIf !Empty( cFilBkp ) .And. cFilBkp <> cFilAnt
				cFilAnt := cFilBkp
			EndIf

			Return {aRisExp,lCandid,aTabTar}
//---------------------------------------------------------------------
/*/{Protheus.doc} MdtRetSRE
Retorna a empresa, filial e centro de custo atual do funcionario transferido.

@param cEmpMDT - Empresa anterior.
@param cFilMDT - Filial anterior.
@param cMatMDT - Matricula anterior.

@return Array - {Riscos,Candidato,Tarefas}

@obs Todos parametros sao obrigatorios.

@author Denis Hyroshi de Souza
@since 17/01/2011
/*/
//---------------------------------------------------------------------
Function MdtRetSRE( cEmpMDT , cFilMDT , cMatMDT )
	Local lRet     := .F.

	Local aRet     := {.F.,"","","",""}
	Local aDadosTmp:= {}
	Local aAreaXXX := GetArea()
	Local aAreaSRA := SRA->(GetArea())

	Local cKeyEmp  := ""
	Local cKeyFil  := ""
	Local cKeyMat  := ""
	Local cKeyCus  := ""
	Local cCondALL := ""

	Local dDataSRE := CTOD("")

	dbSelectArea("SRA")
	dbSetOrder(1)
	dbSeek(cFilMDT+cMatMDT)
	cKeyEmp := cEmpMDT //Empresa origem
	cKeyFil := cFilMDT //Filial origem
	cKeyMat := cMatMDT //Matricula origem
	cKeyCus := SRA->RA_CC //Centro Custo origem

	While !lRet
		lPrimeiro := .T.
		cCondCus  := cKeyCus
		dbSelectArea("SRE")
		cCondALL  := PadR(cKeyEmp,Len(SRE->RE_EMPD))+PadR(cKeyFil,Len(SRE->RE_FILIALD))+PadR(cKeyMat,Len(SRE->RE_MATD))
		dbSelectArea("SRE")
		dbSetOrder(1)
		dbSeek(cCondALL)
		While !Eof() .and. cCondALL == SRE->(RE_EMPD+RE_FILIALD+RE_MATD)
			If SRE->RE_DATA < dDataSRE
				dbSelectArea("SRE")
				dbSkip()
				Loop
			Endif
			If SRE->RE_EMPP == SRE->RE_EMPD .and. SRE->RE_FILIALP == SRE->RE_FILIALD .and. ;
					SRE->RE_MATP == SRE->RE_MATD .and. SRE->RE_CCP == SRE->RE_CCD
				dbSelectArea("SRE")
				dbSkip()
				Loop
			Endif
			If SRE->RE_CCD != cCondCus
				dbSelectArea("SRE")
				dbSkip()
				Loop
			Endif
			If lPrimeiro
				dDataSRE := SRE->RE_DATA
				cKeyEmp := SRE->RE_EMPP
				cKeyFil := SRE->RE_FILIALP
				cKeyMat := SRE->RE_MATP
				cKeyCus := SRE->RE_CCP
				aADD(aDadosTmp,{SRE->RE_DATA,dDataBase,SRE->RE_FILIALD,SRE->RE_MATD,SRE->RE_CCD,SRE->RE_EMPD})
			Else
				If SRE->RE_DATA < aDadosTmp[Len(aDadosTmp)][1]
					dDataSRE := SRE->RE_DATA
					cKeyEmp := SRE->RE_EMPP
					cKeyFil := SRE->RE_FILIALP
					cKeyMat := SRE->RE_MATP
					cKeyCus := SRE->RE_CCP
					aDadosTmp[Len(aDadosTmp)][1] := SRE->RE_DATA
				Endif
			Endif
			lPrimeiro := .f.
			lRet := .f.
			dbSelectArea("SRE")
			dbSkip()
		End
		If lPrimeiro
			lRet := .t.
			aADD(aDadosTmp,{dDataBase,dDataBase,cKeyFil,cKeyMat,cKeyCus,cKeyEmp})
		Endif
	End

	If Len( aDadosTmp ) > 0
		nTotDados:= Len( aDadosTmp )
		cKeyEmp := aDadosTmp[ nTotDados , 6 ] // Empresa origem
		cKeyFil := aDadosTmp[ nTotDados , 3 ]// Filial origem
		cKeyMat := aDadosTmp[ nTotDados , 4 ]// Matricula origem
		cKeyCus := aDadosTmp[ nTotDados , 5 ]// Centro Custo origem
	Endif

	If cKeyEmp <> cEmpMDT .or. cKeyFil <> cFilMDT
		aRet := { .T. , Alltrim( cKeyEmp ),Alltrim( cKeyFil ) , cKeyMat , cKeyCus }
	Else
		aRet := { .F. , Alltrim( cKeyEmp ) , Alltrim( cKeyFil ) , cKeyMat , cKeyCus }
	Endif

	RestArea(aAreaSRA)
	RestArea(aAreaXXX)

Return aRet
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTVLDDTN
Verifica datas de nascimentos inválidas na base de dados

@author Hugo Rizzo Pereira
@since 08/02/2011
/*/
//---------------------------------------------------------------------
Function MDTVLDDTN()
	Local cQuery
	Local aArea := GetArea()

	#IFNDEF TOP

		dbSelectArea("TM0")
		Set Filter To DTOS(TM0->TM0_DTNASC) > DTOS(dDataBase)
		dbGoTop()

		While !Eof()
			RecLock("TM0",.F.)
			TM0->TM0_DTNASC := NGSubtAno(TM0->TM0_DTNASC,100)
			TM0->(MsUnlock())

			DbSelectArea("TM0")
			DbSkip()
		End

	#ELSE

		cQuery := "SELECT TM0_FILIAL,TM0_NUMFIC FROM " + RetSQLName("TM0")
		cQuery += " WHERE TM0_DTNASC > '" + DTOS(dDataBase) + "' AND D_E_L_E_T_ = ''"
		MPSysOpenQuery( cQuery , "TM0TMP" )

		dbSelectArea("TM0TMP")
		dbGoTop()
		While !Eof()

			DbSelectArea("TM0")
			DbSetOrder(1)
			If DbSeek(TM0TMP->TM0_FILIAL + TM0TMP->TM0_NUMFIC)
				RecLock("TM0",.F.)
				TM0->TM0_DTNASC := NGSubtAno(TM0->TM0_DTNASC,100)
				TM0->(MsUnlock())
			Endif

			dbSelectArea("TM0TMP")
			DbSkip()

		End

		dbSelectArea("TM0TMP")
		dbCloseArea()

	#ENDIF

	RestArea(aArea)

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTEV13
Popula tabela TK4

@author Pedro Furst
@since 01/08/2011
/*/
//---------------------------------------------------------------------
Function MDTEV13()
	//
	Local aEveNR
	Local nCont
	/* Define os 13 Eventos Padroes da NR23 */
	aEveNR	:=	{STR0282,;	// 1. -- "Substituição de Gatilho"
	STR0283,;	// 2. -- "Substituição de Difusor"
	STR0284,;	// 3. -- "Mangote"
	STR0285,;	// 4. -- "Válvula de Segurança"
	STR0286,;	// 5. -- "Válvula Completa"
	STR0287,;	// 6. -- "Válvula Cilindro Adicional"
	STR0288,;	// 7. -- "Pintura"
	STR0289,;	// 8. -- "Manômetro"
	STR0290,;	// 9. -- "Teste Hidrostático"
	STR0291,;	// 10. -- "Recarregado"
	STR0292,;	// 11. -- "Usado em Incêndio"
	STR0293,;	// 12. -- "Usado em Instrução"
	STR0294}	// 13. -- "Diversos"

	// Verifica, e cadastra caso necessario, os Eventos padroes da NR23
	dbSelectArea("SX2")
	dbSetOrder(1)
	If dbSeek("TK4")
		dbSelectArea("TK4")
		dbSetOrder(1)
		For nCont := 1 To Len(aEveNR)
			// Coloca 0's (zeros) a esquerda conforme tamanho do valor
			cCod := StrZero(nCont,3)
			// Se o registro nao existir
			If !dbSeek(xFilial("TK4")+cCod)
				// Grava
				RecLock("TK4",.T.)
				// Se existir
			Else
				// Altera
				RecLock("TK4",.F.)
			EndIf

			TK4->TK4_FILIAL := xFilial("TK4")
			TK4->TK4_CODIGO := cCod
			TK4->TK4_DESCRI := aEveNR[nCont]
			MsUnLock("TK4")
		Next nCont
	Endif
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTTIPEXA
Retorna combo com o Tipo de Exame

@author Rodrigo Soledade
@since 08/12/2011
/*/
//---------------------------------------------------------------------
Function MDTTIPEXA()

	Local cTipoExa := STR0334//"1=Admissional;2=Periodico;3=Mud.Funcao;4=Retorno Trabalho;5=Demissional;6=Admissional / Periodico;7=Periodico / Demissional;8=Admissional / Periodico / Demissional;9=Admissional / Demissional;10=Admissional / Mud.Funcao;11=Todos;12=Adm. / Ret.trabalho / Mud.Func. / Period.;13=Admissional / Periodico / Mud.Funcao;14=Admissional / Demissional / Periodico / Mud.Funcao;15=Admissional / Demissional / Mudança de Função;16=Admissional / Mudança de Função /  Ret.Trabalho"

Return cTipoExa
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTRESTRI
Define a restrição do usuario a Rotina
Uso Genérico

@return .T./.T.

@sample
MDTRESTRI("MDTA020")

@author Jackson Machado
@since 21/08/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTRESTRI(cPrograma)

	Local aArea  := GetArea()

	If SuperGetMV("MV_NG2SEG",.F.,"2") == "1" .AND. !(SuperGetMV("MV_MDTPS",.F.,"N") == "S")
		If !AliasInDic("TKP")
			If !NGINCOMPDIC("UPDMDT50","TGHVL0",.F.)
				Return .F.
			Endif
		Endif
		If !MDTVALUSR(cPrograma,cUserName)
			HELP(" ",1,"SEMPERM")
			Return .F.
		Endif
	Endif

	RestArea(aArea)

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTVALUSR
Valida o grupo do usuario
Uso Genérico

@return .T./.F.

@sample
MDTVALUSR("MDTA020","jackson")

@author Jackson Machado
@since 21/08/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTVALUSR(cPrograma,cUser)

	Local cGrupo := Space(1)
	Local lRet   := .T.
	Local aArea  := GetArea()
	//Local cEnt   := ""

	dbSelectArea("TMK")
	dbSetOrder(4)
	If dbSeek(cUser)
		cGrupo := TMK->TMK_INDFUN
		//cEnt   := TMK->TMK_ENTCLA
	Else
		lRet := .F.
	Endif

	If lRet
		dbSelectArea("TKP")
		dbSetOrder(1)
		If dbSeek(xFilial("TKP")+cPrograma)
			If !(cGrupo $ TKP->TKP_GRUPOS) .OR. Empty(cGrupo)
				lRet := .F.
			Endif
		Endif
	EndIf
	/* Caso seja implementada verificacao pelo CRM/COREN
	If lRet
		If (cGrupo $ "1/6/C" .AND. !("CRM" $ cEnt)) .OR. (cGrupo $ "2/7" .AND. !("COREN" $ cEnt))
			lRet := .F.
		EndIf
	EndIf
	*/
	RestArea(aArea)

Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTRESTUS
Valida se o usuario pode ou nao alterar o registro
Uso Genérico

@return .T./.F.

@sample
MDTRESTUS("jackson")

@author Jackson Machado
@since 21/08/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTRESTUS(cUser)

	Local aArea  := GetArea()

	If SuperGetMV("MV_NG2SEG",.F.,"2") == "1" .AND. AllTrim(cUserName) <> AllTrim(cUser) .AND. AllTrim(cUser) <> AllTrim(cUserName) .AND. ;
			!(SuperGetMV("MV_MDTPS",.F.,"N") == "S")
		ShowHelpDlg("SEMPERM",	{STR0335},2,;//"Usuário sem permissão para alterar o registro."
		{STR0336},2)//"Acesse o sistema com o usuário de inclusão/alteração do registro."
		Return .F.
	Endif
	RestArea(aArea)

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTUSRLOG
Retorna o código do usuario logado no sistema
Uso Genérico

@return cCodRet

@sample
MDTUSRLOG()

@author Jackson Machado
@since 21/08/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTUSRLOG(nRet,lTNP)
	Local cCodRet := SPACE(LEN(TMK->TMK_CODUSU))

	Default nRet := 1
	Default lTNP := .F.

	If nRet <> 1
		cCodRet := SPACE(LEN(TMK->TMK_NOMUSU))
	Endif

	If SuperGetMV("MV_NG2SEG",.F.,"2") == "1" .AND. !(SuperGetMV("MV_MDTPS",.F.,"N") == "S")
		dbSelectArea("TMK")
		dbSetOrder(4)
		If dbSeek(cUserName)
			If nRet == 1
				cCodRet := TMK->TMK_CODUSU
			Else
				If Type("INCLUI") == "L" .AND. INCLUI
					cCodRet := TMK->TMK_NOMUSU
				Endif
			Endif
		Endif
		If Empty(cCodRet) .AND. lTNP
			dbSelectArea("TNP")
			dbSetOrder(3)
			If dbSeek(cUserName)
				If nRet == 1
					cCodRet := TNP->TNP_EMITEN
				Else
					If Type("INCLUI") == "L" .AND. INCLUI
						cCodRet := TNP->TNP_NOME
					Endif
				Endif
			Endif
		Endif
	Endif

Return cCodRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTSXBSBI
Retorna se o usuario pode ou nao incluir registro pelo SXB
Uso Genérico

@return .T./.F.

@sample
MDTSXBSBI(cAlias,cFuncao)

@author Jackson Machado
@since 21/08/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTSXBSBI(cAlias,cFuncao,cInclui)

	If FindFunction("MDTRESTRI") .AND. !MDTRESTRI(cFuncao)
		Return .F.
	Endif

	If cInclui == "01"
		AxInclui(cAlias,0,3,,,,,.T.)
	Else
		&(cInclui)
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTEXCSBI
Retorna se o usuario pode ou nao excluir o registro apos a data
Uso Genérico

@return .T./.F.

@sample
MDTEXCSBI('21/08/2012')

@author Jackson Machado
@since 21/08/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTEXCSBI(dDtVal)

	Local aArea   := GetArea()
	Local dDtComp := If(ValType(dDtVal) == "C",If("/" $ dDtVal,CTOD(dDtVal),STOD(dDtVal)),dDtVal)
	Local nQtdDia := SuperGetMV("MV_NG2DEXC",.F.,2)

	nQtdDia := If( nQtdDia < 1 , 0 , nQtdDia - 1 )
	dDtComp := dDtComp + nQtdDia

	If SuperGetMV("MV_NG2SEG",.F.,"2") == "1" .AND. dDtComp < dDataBase .AND. !(SuperGetMV("MV_MDTPS",.F.,"N") == "S")
		ShowHelpDlg("SEMPERM",	{STR0335},2,;//"Usuário sem permissão para alterar o registro."
		{STR0337},2)//"Período para exclusão deste Registro Clínico já ultrapassado."
		Return .F.
	Endif
	RestArea(aArea)

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTWHNSBI
Retorna se o campo é editavel no conceito SBIS
Uso Genérico

@return .T./.F.

@sample
MDTWHNSBI()

@author Jackson Machado
@since 21/08/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTWHNSBI()

Return SuperGetMV("MV_NG2SEG",.F.,"2") == "2" .OR. SuperGetMV("MV_MDTPS",.F.,"N") == "S"
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTSBIS
Carrega as tabelas com as alterações do SBIS
Uso Genérico

@return

@sample
MDTSBIS()

@author Jackson Machado
@since 21/08/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTSBIS()

	Local nX, nY
	Local cSeqClick := "", cFilOld := ""
	Local aPrograma := {}
	Local aClickDir := {}
	Local aFiliais := {}

	//Cadastros
	aAdd(aPrograma,{"MDTA001",STR0338,"1;6;"				})//"Gerar Fichas Med."
	aAdd(aPrograma,{"MDTA005",STR0038,"1;6;"				})//"Ficha Medica"
	aAdd(aPrograma,{"MDTA010",STR0340,"1;2;3;6;7;8;9;"	})//"Medicamentos"
	aAdd(aPrograma,{"MDTA020",STR0068,"1;2;3;6;7;8;9;"	})//"Exames"
	aAdd(aPrograma,{"MDTA035",STR0342,"1;6;"				})//"Exames Por Agente"
	aAdd(aPrograma,{"MDTA045",STR0343,"1;6;"				})//"Fornecedor Exames"
	aAdd(aPrograma,{"MDTA050",STR0344,"1;2;3;6;7;8;9;"	})//"Restrições"
	aAdd(aPrograma,{"MDTA075",STR0346,"1;2;3;6;7;8;9;"	})//"Agenda Medica"
	aAdd(aPrograma,{"MDTA080",STR0347,"1;6;"				})//"CID"
	aAdd(aPrograma,{"MDTA081",STR0348,"1;6;"        		})//"Grupos de CID"
	aAdd(aPrograma,{"MDTA105",STR0349,"1;2;3;6;7;8;9;"	})//"Movto Medicament"
	aAdd(aPrograma,{"MDTA110",STR0350,"1;6;"  			})//"Ocorrencias Ficha"
	aAdd(aPrograma,{"MDTA114",STR0351,"1;6;"				})//"Exames Progr.saude"
	aAdd(aPrograma,{"MDTA115",STR0352,"1;6;"				})//"Prog.saude Func."
	aAdd(aPrograma,{"MDTA120",STR0353,"1;6;"				})//"Exames do Func."
	aAdd(aPrograma,{"MDTA145",STR0354,"1;6;"  			})//"Questionario Func."
	aAdd(aPrograma,{"MDTA155",STR0355,"1;6;"  			})//"Diagnostico Medico"
	aAdd(aPrograma,{"MDTA160",STR0356,"1;6;" 				})//"Atendimento Medico"
	aAdd(aPrograma,{"MDTA161",STR0357,"1;2;3;6;7;8;9;"	})//"Atend. Enfermagem"
	aAdd(aPrograma,{"MDTA170",STR0358,"1;6;"				})//"Exames Por Filial"
	aAdd(aPrograma,{"MDTA185",STR0359,"1;6;" 				})//"Exames Por Risco"
	aAdd(aPrograma,{"MDTA188",STR0360,"1;6;" 				})//"Gerar Exames Risco"
	aAdd(aPrograma,{"MDTA190",STR0361,"1;6;" 				})//"Gerar Programacao"
	aAdd(aPrograma,{"MDTA195",STR0362,"1;6;" 				})//"Gerar Convocacao"
	aAdd(aPrograma,{"MDTA200",STR0363,"1;6;" 				})//"Atestado (aso)"
	aAdd(aPrograma,{"MDTA275",STR0364,"1;6;" 				})//"Exames P/ Admissao"
	aAdd(aPrograma,{"MDTA280",STR0365,"1;6;" 				})//"Exames P/ demissao"
	aAdd(aPrograma,{"MDTA285",STR0366,"1;6;" 				})//"Exames P/ Mud.fun."
	aAdd(aPrograma,{"MDTA290",STR0367,"1;6;" 				})//"Resultado Simplif."
	aAdd(aPrograma,{"MDTA450",STR0368,"1;6;" 				})//"Exames Por Função"
	aAdd(aPrograma,{"MDTA520",STR0369,"1;2;3;6;7;8;9;"	})//"Vacinas"
	aAdd(aPrograma,{"MDTA525",STR0370,"1;6;" 				})//"Calendario Vacinaç"
	aAdd(aPrograma,{"MDTA530",STR0371,"1;6;" 				})//"Vacinas Funcionari"
	aAdd(aPrograma,{"MDTA535",STR0372,"1;6;" 				})//"Gerar Prog. Vacina"
	aAdd(aPrograma,{"MDTA685",STR0374,"1;6;C;" 			})//"Atestado Medico"
	aAdd(aPrograma,{"MDTA920",STR0375,"1;6;" 				})//"Licen. Maternidade"
	aAdd(aPrograma,{"MDTA925",STR0376,"1;6;" 				})//"Enc. Especialista"
	aAdd(aPrograma,{"MDTA930",STR0377,"1;2;3;6;7;8;9;"	})//"Especialid. Medica"

	//Consultas
	aAdd(aPrograma,{"MDTC300",STR0378,"1;6;"				})//"F.m. Saude/Doenca"
	aAdd(aPrograma,{"MDTC305",STR0379,"1;6;"				})//"F.m. Diagn/Exames"
	aAdd(aPrograma,{"MDTC310",STR0380,"1;6;"				})//"Programacao Exames"
	aAdd(aPrograma,{"MDTC315",STR0381,"1;6;"				})//"Program Por Exames"
	aAdd(aPrograma,{"MDTC340",STR0382,"1;6;"				})//"Questionario Medic"
	aAdd(aPrograma,{"MDTC345",STR0346,"1;6;"				})//"Agenda Medica"
	aAdd(aPrograma,{"MDTC350",STR0383,"1;6;"				})//"Programas de Saude"
	aAdd(aPrograma,{"MDTC355",STR0384,"1;6;"				})//"Doencas  ( Cid )"
	aAdd(aPrograma,{"MDTC365",STR0363,"1;6;"				})//"Atestado ( Aso )"
	aAdd(aPrograma,{"MDTC370",STR0385,"1;6;"				})//"Convocacao  Exames"
	aAdd(aPrograma,{"MDTC720",STR0386,"1;6;"				})//"Comp. Exame Audit."

	//Relatórios
	aAdd(aPrograma,{"MDTR400",STR0038,"1;6;"				})//"Ficha Medica"
	aAdd(aPrograma,{"MDTR405",STR0340,"1;6;"				})//"Medicamentos"
	aAdd(aPrograma,{"MDTR406",STR0387,"1;6;"				})//"Receita Medica"
	aAdd(aPrograma,{"MDTR407",STR0387,"1;6;"				})//"Receita Medica"
	aAdd(aPrograma,{"MDTR410",STR0388,"1;6;"				})//"Respostas Question"
	aAdd(aPrograma,{"MDTR415",STR0389,"1;6;"				})//"Cid X Funcionarios"
	aAdd(aPrograma,{"MDTR420",STR0390,"1;6;"				})//"Cid X Funcao"
	aAdd(aPrograma,{"MDTR425",STR0391,"1;6;"				})//"Cid X C.custo"
	aAdd(aPrograma,{"MDTR430",STR0392,"1;6;"				})//"Atend. X Motivo"
	aAdd(aPrograma,{"MDTR435",STR0393,"1;6;"				})//"Func. Afastados"
	aAdd(aPrograma,{"MDTR440",STR0394,"1;6;"				})//"Aso's Emitidos"
	aAdd(aPrograma,{"MDTR443",STR0395,"1;6;"				})//"Audiom. P/ C.custo"
	aAdd(aPrograma,{"MDTR450",STR0380,"1;6;"				})//"Programacao Exames"
	aAdd(aPrograma,{"MDTR455",STR0385,"1;6;"				})//"Convocacao  Exames"
	aAdd(aPrograma,{"MDTR460",STR0397,"1;6;"				})//"Encaminhamento"
	aAdd(aPrograma,{"MDTR465",STR0363,"1;6;"				})//"Atestado ( Aso )"
	aAdd(aPrograma,{"MDTR470",STR0343,"1;6;"				})//"Fornecedor Exames"
	aAdd(aPrograma,{"MDTR475",STR0398,"1;6;"				})//"Pcmso Anual"
	aAdd(aPrograma,{"MDTR482",STR0399,"1;6;"				})//"Exames P/C.custo"
	aAdd(aPrograma,{"MDTR484",STR0400,"1;6;"				})//"Exames Itens Quant"
	aAdd(aPrograma,{"MDTR486",STR0342,"1;6;"				})//"Exames Por Agente"
	aAdd(aPrograma,{"MDTR487",STR0401,"1;6;"				})//"Comp. Exames. Aud."
	aAdd(aPrograma,{"MDTR488",STR0402,"1;6;"				})//"Exames Auditivos"
	aAdd(aPrograma,{"MDTR489",STR0403,"1;6;"				})//"Evolucao Audiomet."
	aAdd(aPrograma,{"MDTR490",STR0404,"1;2;3;6;7;8;9;"	})//"Custo Pcmso"
	aAdd(aPrograma,{"MDTR494",STR0405,"1;2;3;6;7;8;9;"	})//"Custo Por Fornec."
	aAdd(aPrograma,{"MDTR510",STR0406,"1;6;"				})//"Atest. Falta Trab"
	aAdd(aPrograma,{"MDTR540",STR0407,"1;2;3;6;7;8;9;"	})//"Custo Exam. Realiz"
	aAdd(aPrograma,{"MDTR545",STR0408,"1;6;"				})//"Estat. Diagnostico"
	aAdd(aPrograma,{"MDTR560",STR0359,"1;6;" 				})//"Exames Por Risco"
	aAdd(aPrograma,{"MDTR575",STR0409,"1;6;"				})//"Conv. Progr. Saude"
	aAdd(aPrograma,{"MDTR700",STR0410,"1;2;3;6;7;8;9;"	})//"P.P.P."
	aAdd(aPrograma,{"MDTR710",STR0411,"1;6;"				})//"Atestado Clinico"
	aAdd(aPrograma,{"MDTR720",STR0412,"1;2;3;6;7;8;9;"	})//"Atend. Ambulat."
	aAdd(aPrograma,{"MDTR725",STR0413,"1;2;3;6;7;8;9;"	})//"Atend. Diário Enfe"
	aAdd(aPrograma,{"MDTR730",STR0414,"1;6;"				})//"Ficha Clinica"
	aAdd(aPrograma,{"MDTR740",STR0374,"1;6;C;"			})//"Atestado Medico"
	aAdd(aPrograma,{"MDTR745",STR0415,"1;6;"				})//"Analise Audiomet."
	aAdd(aPrograma,{"MDTR755",STR0346,"1;2;3;6;7;8;9;"	})//"Agenda Medica"
	aAdd(aPrograma,{"MDTR785",STR0416,"1;6;"				})//"Validade Medicam."
	aAdd(aPrograma,{"MDTR870",STR0417,"1;6;"				})//"Rel. Geral (PCMSO)"
	aAdd(aPrograma,{"MDTR900",STR0369,"1;6;"				})//"Vacinas"
	aAdd(aPrograma,{"MDTR960",STR0341,"1;2;3;6;7;8;9;"	})//"Registro Mtb"
	aAdd(aPrograma,{"MDTR961",STR0396,"1;2;3;6;7;8;9;"	})//"Dimensionamento"

	aFiliais := FWLoadSM0()

	For nX := 1 To Len(aPrograma)
		dbSelectArea("TKP")
		dbSetOrder(1)
		If !dbSeek(xFilial("TKP")+aPrograma[nX,1])
			RecLock("TKP",.T.)
			TKP->TKP_FILIAL := xFilial("TKP")
			TKP->TKP_ROTINA := aPrograma[nX,1]
			TKP->TKP_DESCRI := aPrograma[nX,2]
			TKP->TKP_DESSPA := aPrograma[nX,2]
			TKP->TKP_DESENG := aPrograma[nX,2]
			TKP->TKP_GRUPOS := aPrograma[nX,3]
			TKP->(MsUnLock())
		Endif
	Next nX

	aAdd(aClickDir,{"MDTA005",STR0038,"TM0"})//"Ficha Médica"
	aAdd(aClickDir,{"MDTA075",STR0346,"TML"})//"Agenda Medica"
	aAdd(aClickDir,{"MDTA120",STR0353,"TM5"})//"Exames do Func."
	aAdd(aClickDir,{"MDTA155",STR0355,"TMT"})//"Diagnostico Medico"
	aAdd(aClickDir,{"MDTA200",STR0363,"TMY"})//"Atestado (aso)"
	aAdd(aClickDir,{"MDTA530",STR0371,"TL9"})//"Vacinas Funcionari"
	aAdd(aClickDir,{"MDTA685",STR0374,"TNY"})//"Atestado Medico"
	aAdd(aClickDir,{"MDTA920",STR0375,"TOF"})//"Licen. Maternidade"

	For nY := 1 To Len(aFiliais)
		If aFiliais[nY,1] == cEmpAnt
			For nX := 1 To Len(aClickDir)
				dbSelectArea("TQC")
				dbSetOrder(1)
				If !dbSeek(xFilial("TQC",aFiliais[nY,2])+aClickDir[nX,1])
					RecLock("TQC",.T.)
					TQC->TQC_FILIAL := xFilial("TQC",aFiliais[nY,2])
					TQC->TQC_PROGRA := aClickDir[nX,1]
					TQC->TQC_DESCRI := aClickDir[nX,2]
					TQC->(MsunLock())
				EndIf
				dbSelectArea("TQD")
				dbSetOrder(1)
				If !dbSeek(xFilial("TQD",aFiliais[nY,2])+Padr(aClickDir[nX,1],Len(TQD->TQD_PROGRA))+"MDTRELHIS")
					cFilOld   := cFilAnt
					cFilAnt   := aFiliais[nY,2]
					cSeqClick := NGULTTQD(aClickDir[nX,1])
					cFilAnt   := cFilOld
					RecLock("TQD",.T.)
					TQD->TQD_FILIAL := xFilial("TQD",aFiliais[nY,2])
					TQD->TQD_PROGRA := aClickDir[nX,1]
					TQD->TQD_SEQUEN := cSeqClick
					TQD->TQD_TIPOFU := "1"
					TQD->TQD_FUNCAO := "MDTRELHIS"
					TQD->TQD_PARAM  := "'"+aClickDir[nX,3]+"'"
					TQD->TQD_DESPOR := STR0418//"Histórico do Registro"
					TQD->TQD_DESING := STR0418//"Histórico do Registro"
					TQD->TQD_DESESP := STR0418//"Histórico do Registro"
					If NGCADICBASE("TQD_ATIVAR","D","TQD",.F.)
						TQD->TQD_ATIVAR := "1"
					EndIf
					TQD->(MsunLock())
				EndIf
			Next nX
		Endif
	Next nY
Return
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTRELHIS
Geração de relatório de histórico do registro
Uso Genérico

@return

@sample
MDTRELHIS()

@author Jackson Machado
@since 21/08/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTRELHIS(cAlias,lHist,nRecno)
	Local nPos
	Local cFilter
	Local _cErro, _cTitulo
	Local _cDBCONECT
	Local _nCon
	Local cPorta, cIpAud, cPortAud
	Local aRecnos := {}
	Local aAlias  := {}

	Default cAlias := "TM0"
	Default lHist  := .F.

	#IFNDEF TOP
		MsgInfo(STR0428)//"Funcionalidade apenas disponível para ambientes TOP CONNECT."
		Return .F.
	#ENDIF

	If SuperGetMv("MV_MDTPS",.F.,"N") == "S"
		ShowHelpDlg(STR0078,;
			{STR0434},2,;//"Opção não disponível para Prestador de Serviço."
		{STR0435},2)//"Favor contate administrador de sistema."
		Return .F.
	EndIf

	aAlias  := GetArea()
	cFilter := dbFilter()

	If Type("INCLUI") == "L" .AND. INCLUI
		ShowHelpDlg(STR0078,;//"ATENÇÃO"
		{STR0426},2,;//"Opção não disponível no modo de Inclusão."
		{STR0427},2)//"Para acessar esta opção, favor visualizar/alterar/excluir o registro."
		Return .F.
	Endif

	If SuperGetMv("MV_NG2AUDI",.F.,"2") == "2"
		ShowHelpDlg(STR0078,;
			{STR0419},2,;//"Parâmetro de auditoria não ativado."
		{STR0420},2)//"Para utilização deste recurso é necessaria a ativacao do parametro MV_NG2AUDI juntamente com a auditoria de sistema."
		Return .F.
	Endif

	cPorta     := AllTrim(SuperGetMv("MV_NG2PRIP",.F.," "))
	_cDBCONECT := AllTrim(SuperGetMv("MV_NG2DBAU",.F.," "))

	If !MDT990VSX6(cPorta,.F.)
		Return .F.
	ElseIf !MDT990VSX6(_cDBCONECT,.T.)
		Return .F.
	Endif

	nPos     := At("/",cPorta)
	cIpAud   := SubStr(cPorta,1,nPos-1)
	cPortAud := AllTrim(SubStr(cPorta,nPos+1))

	//Seta a conexao padrao
	TcConType("TCPIP")

	_nCon := TCLink( _cDBCONECT , cIpAud , Val(cPortAud) ) //MSSQL/Auditoria ##192.168.0.167 ##7890

	//Eliminar mensagem de erro depois...
	If (_nCon < 0)
		_cTitulo := STR0421 + Str( _nCon , 4 , 0 )//"Falha Conexao na Base - Erro: "
		_cErro   := _cTitulo + ( CHR(13) + CHR(10) ) + ;
			STR0425 + cIpAud + ( CHR(13) + CHR(10) ) + ;//"IP:"
		STR0422 + cPortAud + ( CHR(13) + CHR(10) ) + ;//"Porta:"
		STR0423 + AllTrim(_cDBCONECT) + ( CHR(13) + CHR(10) ) + ;//"DBMS/Base de Dados:"
		STR1469 + ": " + ( CHR(13) + CHR(10) ) + ;
			"http://tdn.totvs.com/display/public/PROT/Configurar+Embedded+Audit+Trail" + ( CHR(13) + CHR(10) ) + ;
			STR0424 + ( CHR(13) + CHR(10) ) + "---------------------------------------------" + ; //"Contate o Administrador de Sistemas."
		( CHR(13) + CHR(10) ) + TcSqlError()

		NGMSGMEMO(_cTitulo,_cErro)

		//Retorna a conexao inicial
		TCSETCONN(AdvConnection())

		Return .F.
	Endif

	//Retorna a conexao inicial
	TCSETCONN(AdvConnection())
	TCUNLINK(_nCon)

	If cAlias == "TM5" .AND. !lHist
		MDT120HIMP(@aRecnos)
	ElseIf cAlias == "TMT" .AND. !lHist
		MDT155HIMP(@aRecnos)
	ElseIf cAlias == "TMY" .AND. !lHist
		MDT200HIMP(@aRecnos,_cDBCONECT,cIpAud,Val(cPortAud))
	ElseIf cAlias == "TNY" .AND. !lHist
		MDT685HIMP(@aRecnos)
	Else
		//TM0,TML,TMJ,TOF,TL5,TL9,TMF,TMN,TNA
		aRecnos := {{cAlias,{If(lHist,nRecno,(cAlias)->(RECNO()))}}}
	Endif

	MDTR990(cAlias,aRecnos,_cDBCONECT,cIpAud,Val(cPortAud))

	//Retorna a conexao inicial
	TCSETCONN(AdvConnection())
	If _nCon > 0
		TCUNLINK(_nCon)
	Endif
	RestArea(aAlias)
	If !Empty(cFilter)
		Set Filter To &(cFilter)
	EndIf
Return
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTBUSCADEL
Busca registros deletados
Uso MDTUTIL

@return

@sample
MDTBUSCADEL()

@author Jackson Machado
@since 21/08/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTBUSCADEL(aArrayAdd,cAlias,aChaves,aConteu,aNotIn)
	Local nX
	Local _nErro
	Local _cErro    := "", _cTitulo := ""
	Local lLogExp   := .F.
	Local cCmpLgP   := PrefixoCpo( cAlias ) + "_USERGI"
	Local cCmpLgF   := PrefixoCpo( cAlias ) + "_USERGI"
	Local cNewAlias := GetNextAlias()
	Local lFiltro   := .F.
	Local lRecnos   := .F.

	cQuery := " SELECT R_E_C_N_O_ AS RECID FROM "+NGRETX2(cAlias)
	If (ValType(aChaves) == "A" .AND. Len(aChaves) > 0) .Or. (ValType(aConteu) == "A" .AND. Len(aConteu) > 0) .Or.;
			(ValType(aNotIn) == "A" .AND. Len(aNotIn) > 0)
		cQuery += " WHERE "
	Endif
	If ValType(aChaves) == "A" .AND. Len(aChaves) > 0 .AND. ValType(aConteu) == "A" .AND. Len(aConteu) > 0
		For nX := 1 To Len(aChaves)
			If !( "_USERGI" $ cValToChar( aConteu[ nX ] ) ) .And. !( "_USERLGI" $ cValToChar( aConteu[ nX ] ) )
				If nX <> 1
					cQuery += " AND "
				EndIf
				cQuery += aConteu[nX]+" = "+ValToSql(aChaves[nX])
			Else
				lLogExp := .T.
				cCmpLgP := cValToChar( aConteu[ nX ] )
				cCmpLgF := cValToChar( aChaves[ nX ] )
			EndIf
		Next nX
		lFiltro := .T.
	EndIf
	If lFiltro
		cQuery += " AND "
	EndIf
	If ValType(aNotIn) == "A" .AND. Len(aNotIn) > 0
		cQuery += " R_E_C_N_O_ NOT IN ( "
		For nX := 1 TO Len(aNotIn)
			If nX <> 1
				cQuery += ","
			Endif
			cQuery += cValToChar(aNotIn[nX])
		next nX
		cQuery += " ) "
		lRecnos := .T.
	EndIf
	If lRecnos
		cQuery += " AND "
	EndIf
	cQuery += " D_E_L_E_T_ = '*' "

	If Select(cNewAlias) > 0
		dbSelectArea(cNewAlias)
		(cNewAlias)->(dbCloseArea())
	EndIf

	cQuery := ChangeQuery(cQuery)

	MPSysOpenQuery( cQuery , cNewAlias )

	dbSelectArea(cNewAlias)
	dbGoTop()
	While (cNewAlias)->( !Eof() )
		dbSelectArea(cAlias)
		dbGoTo((cNewAlias)->RECID)
		If !lLogExp .Or. If ( (cAlias)->( FieldPos(cCmpLgP) ) > 0 , ;
				MDTDATALO( (cAlias)->&(cCmpLgP) , .T. , .F. ) < cCmpLgF , ;
				MDT990VDL( cAlias , (cNewAlias)->RECID , cCmpLgF ) )

			If (nPos := aScan(aArrayAdd,{|x| x[1] == cAlias })) > 0
				aAdd(aArrayAdd[nPos][2],(cNewAlias)->RECID)
			Else
				aAdd(aArrayAdd,{cAlias,{(cNewAlias)->RECID}})
			EndIf

		EndIf

		(cNewAlias)->( dbSkip() )
	End

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTDATALO
Retorna data ou usuario de campo criptografado
Uso Genérico

@return

@sample
MDTDATALO("acjksno",.F.,.F.)

@param 	cCampoUsa - Campo/Conteudo criptografado - Obrigatório
		lData     - Indica se deve retornar a data criptografada - Não Obrigatório - Default .T.
		lExec     - Indica se o cCampoUsa deve ser executado ou so utilizado - Não Obrigatório - Default .T.
		lVerInc   - Indica se deve verificar a variavel de inclusao

@author Jackson Machado
@since 21/08/2012
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTDATALO(cCampoUsa,lData,lExec,lVerInc)
	Local nPos
	Local cRet  := ""
	Local cAux  := "", cID := "", cUsrName := ""
	Local aArea := GetArea()

	Default lData := .T.
	Default lExec := .T.
	Default lVerInc := .T.

	cAux := Embaralha(If(lExec,&cCampoUsa,cCampoUsa),1)//Desembaralha a string criptografada

	If !Empty(cAux) .AND. If(lVerInc,!(Type("INCLUI") == "L" .AND. INCLUI),.T.)//Caso na seja inclusao
		If Subs(cAux, 1, 2) == "#@"//Se for nova criptografia os dois primeiros caracteres serão "#@" e os próximos 6, o ID do usuário
			cID := Subs(cAux,3,6)
			If Empty(__aUserLg) .OR. aScan(__aUserLg, {|x| x[1] == cID}) == 0//Array __aUserLg e' estatico do MDTUTIL
				PSWORDER(1)//Seleciona a ordem de pesquisa 1 no arquivo de senhas (ID do usuário/grupo)
				If ( PSWSEEK(cID) )//Realiza a pesquisa no arquivo de senhas pelo ID do usuário
					cUsrName := AllTrim(PSWRET()[1][2])//Caso encontre, pega a posicao do nome do usuário
				EndIf
				aAdd(__aUserLg, {cID, cUsrName})
			EndIf

			If !lData//Caso nao for data, retorna o nome do usuário
				nPos := aScan(__aUserLg, {|x| x[1] == cID})
				cRet := __aUserLg[nPos][2]
			Else
				//Criptografia de datas seguem o seguinte padrão:
				// Utilizar a função Load2In4 que retornará, a partir do caracter criptografado, a quantidade de dias que devem ser somadas
				// com a data 01/01/96.
				//Todos os caracteres após o 15, servem para o calculo
				cRet := Dtoc(CTOD("01/01/96","DDMMYY") + Load2In4(Substr(cAux,16)))
			Endif
		Else
			//Caso criptografia antiga, retorna direto o nome do usuário
			If !lData
				cRet := Subs(cAux,1,15)
			Else
				cRet := Dtoc(CTOD("01/01/96","DDMMYY") + Load2In4(Substr(cAux,16)))
			Endif
		EndIf
	EndIf

	RestArea(aArea)
Return If(lData,If(Type(cRet) <> "D",CTOD(cRet),cRet),SubStr(cRet,1,15))
//---------------------------------------------------------------------
/*{Protheus.doc} MdtValTip
Valida o valor dos campos de FLAG, para que, caso o módulo seja Medicina, não possibilitar a inclusão do registro como somente SGA
ou, caso o módulo seja Gestão Ambiental, não possibilitar a inclusão de registro como somente MDT

@return Lógico - Caso valor da flag esteja correto, retorna verdadeiro, se não, falso

@param cTipo - Vetor com o número do módulo a ser considerado, caso vazio, considera para todos os modulos
@param cTab  - Indica a tabela que esta manipulando

@sample MdtValTip( '1' )

@author Jackson Machado
@since 20/03/2013
@version 1.0
//---------------------------------------------------------------------
*/
Function MdtValTip( cTipo , cTab )

	Local lRet		:= .T.
	Local cSoluc	:= ""

	If ( cTipo == "2" .AND. nModulo <> 35 ) .OR. ( cTipo == "1" .AND. nModulo <> 56 )
		cSoluc := If( nModulo == 35 , ;
			STR0462 , ;//"Para o Módulo de Medicina e Segurança do Trabalho, apenas estão disponíveis as opções 2 (MDT) e 3 (Ambos)."
		STR0463 )//"Para o Gestão Ambienta, apenas estão disponíveis as opções 1 (SGA) e 3 (Ambos)."

		ShowHelpDlg( STR0078 , ; //"ATENÇÃO"
		{ STR0464 } , 2 , ;//"Opção não disponível."
		{ cSoluc } , 2 )

		lRet := .F.
	EndIf

	If lRet
		If cTab == "TCD"
			If cTipo == "1"
				M->TCD_ASPECT := Space( Len( M->TCD_ASPECT ) )
				M->TCD_DESASP := Space( Len( M->TCD_DESASP ) )
				M->TCD_IMPACT := Space( Len( M->TCD_IMPACT ) )
				M->TCD_DESIMP := Space( Len( M->TCD_DESIMP ) )
			ElseIf cTipo == "2"
				M->TCD_ASPECT := Space( Len( M->TCD_CODPER ) )
				M->TCD_DESASP := Space( Len( M->TCD_NOMPER ) )
				M->TCD_IMPACT := Space( Len( M->TCD_CODDAN ) )
				M->TCD_DESIMP := Space( Len( M->TCD_DESDAN ) )
			EndIf
		ElseIf cTab == "TCO"
			If cTipo == "1"
				M->TCO_CODDAN := Space( Len( M->TCO_CODDAN ) )
				M->TCO_DESDAN := Space( Len( M->TCO_DESDAN ) )
				M->TCO_CODFUN := Space( Len( M->TCO_CODFUN ) )
				M->TCO_NOMFUN := Space( Len( M->TCO_NOMFUN ) )
			ElseIf cTipo == "2"
				M->TCO_CODIMP := Space( Len( M->TCO_CODIMP ) )
				M->TCO_DESIMP := Space( Len( M->TCO_DESIMP ) )
				M->TCO_CODRES := Space( Len( M->TCO_CODRES ) )
				M->TCO_DESRES := Space( Len( M->TCO_DESRES ) )
			EndIf
		EndIf
	EndIf

Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTEstFunc
Busca código de Estabilidade para ser gravada na RFX - Estabilidade

@return
@param @ nTipoEst  -	Código que será procurado para o retorno do motivo
								de estabilidade.
@sample	MDTEstFunc( 1 ) -	01 - Acidente de Trabalho;
										07 - Candidato da CIPA;
										08 - Eleito Titular CIPA;
										09 - Eleito Suplente CIPA;

@author Guilherme Benkendorf
@since 17/02/2014
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTEstFunc( nTipoEst )
	Local nTamCod := 3
	Local nTamPos := 1//Inicia a posição em 1 para cortar corretamente a string ( Tamanho dos campos + 1 )
	Local nTamTipo := 2
	Local cQueryRCB
	Local cQueryRCC
	Local cTRBRCB := GetNextAlias()
	Local cTRBRCC := GetNextAlias()
	Local cSubString := "SUBSTR"

	//Verifica banco de dados para alterar o corte de string
	If "MSSQL" $ Upper(TCGetDB())
		cSubString := "SUBSTRING"
	Endif

	//Monta query de busca da RCB
	//Busca as configurações de parâmetros viculados ao código S053(Estabilidade)
	cQueryRCB := " SELECT * FROM " + RetSqlName( "RCB" ) + " RCB"
	cQueryRCB += " WHERE"
	cQueryRCB +=   " RCB.RCB_CODIGO = " + ValToSql( "S053" )
	cQueryRCB +=   " AND RCB.RCB_FILIAL = " + ValToSql( xFilial( "RCB" ) )
	cQueryRCB +=   " AND RCB.D_E_L_E_T_ <> '*' "
	cQueryRCB +=   " ORDER BY RCB.RCB_ORDEM"//Ordena pelas posições dos campos
	cQueryRCB := ChangeQuery(cQueryRCB)
	MPSysOpenQuery( cQueryRCB , cTRBRCB )

	//Busca os valores para corte de string
	dbSelectArea( cTRBRCB )
	While ( cTRBRCB )->( !Eof() )
		If AllTrim( ( cTRBRCB )->RCB_CAMPOS ) <> "MOTEST"//Passa por todos os campos até localizar o motivo
			If AllTrim( ( cTRBRCB )->RCB_CAMPOS ) == "TPESTB"//Caso seja o campo TIPO salva o tamanho para verificar qual é o código
				nTamCod := ( cTRBRCB )->RCB_TAMAN
			EndIf
			nTamPos += ( cTRBRCB )->RCB_TAMAN//Incrementa a quantidade dos tamanhos dos campos
		Else
			nTamTipo := ( cTRBRCB )->RCB_TAMAN//Salva o tamanho do Tipo
			Exit
		EndIf
		( cTRBRCB )->( dbSkip() )
	End

	If nTamPos == 1//Caso não localize campos, atribui um tamanho padrão
		nTamPos := 104
	EndIf

	//Busca os valores correspondentes a estabilidade
	cQueryRCC := "SELECT "+cSubString+"( RCC.RCC_CONTEU , 1 , " + ValToSql( nTamCod ) + ") AS CODEST "//Corta a string do início do conteúdo até o tamanho do campo código
	cQueryRCC += " FROM "+RetSqlName("RCC")+" RCC "
	cQueryRCC += " WHERE "
	// Converte para caractere o valor do motivo para verificar se é igual a estabilidade indicada no eSocial (1 - Acidente;7 - Candidato CIPA;8 - Titula CIPA;9 - Suplente CIPA)
	cQueryRCC +=   cSubString + "( RCC.RCC_CONTEU , " + ValToSql( nTamPos ) + " , " + ValToSql( nTamTipo ) + " ) = " + ValToSql( Str( nTipoEst, nTamTipo ) )
	cQueryRCC +=   " AND RCC.RCC_CODIGO = " + ValToSql( "S053" )
	cQueryRCC +=   " AND RCC.RCC_FILIAL = " + ValToSql( xFilial( "RCC" ) )
	cQueryRCC +=   " AND RCC.D_E_L_E_T_ <> '*' "
	cQueryRCC := ChangeQuery(cQueryRCC)
	MPSysOpenQuery( cQueryRCC , cTRBRCC )

	dbSelectArea( cTRBRCC )
	cCodEst := Alltrim( ( cTRBRCC )->CODEST )//Salva o primeiro código encontrado com o Motivo necessários

	//Deleta os TRB's
	(cTRBRCB)->( dbCloseArea() )

	(cTRBRCC)->( dbCloseArea() )

Return cCodEst
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTeSocVal
Funcao de validacao do modulo de TAF

@return
@param @ cAlsChk  - Indica o alias a ser validado no SIGATAF
		  @ cAlsKey  - Indica o alias a sera feito a verificação no SIGAMDT,
		   pelo código (cCodeSoc).
		  @ IndChk   - Indice de verificação para o cAlsChk.
		  @ IndKey   - Indice de verificação para o cAlsKey.
        @ cCodeSoc - Referenciado o valor da memória. Para pegar valor
         correto da memória.
@sample

@author Guilherme Benkendorf
@since 03/07/2013
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTeSocVal( cAlsChk, cAlsKey, nIndChk, nIndKey, cCodeSoc )
	Local lRet     := .T.

	If Empty(cCodeSoc)
		Return .T.
	EndIf

	lRet := EXISTCPO( cAlsChk , cCodeSoc , nIndChk )

	If cAlsKey <> 'TMA'
		lRet := If( lRet, ExistChav( cAlsKey, cCodeSoc, nIndKey ), lRet )
	EndIf

Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTRisFun
Retorna todos os riscos que o funcionario (SRA) esta exposto.

@return
@param @ cMatricula  - Matricula do funcionario que seá realizado a busca

@sample MDTRisFun( SRA->RA_MAT )

@author Guilherme Benkendorf
@since 24/02/2014
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTRisFun( cMatricula, cCusto, cFuncao, cTarefa , cDepto )
	Local aAreaRis := GetArea()

	Local ni,nj,nk
	Local nTotComb, nTotComTar
	Local nSizeSI3 := If((TAMSX3("I3_CUSTO")[1]) < 1  , 9 , (TAMSX3("I3_CUSTO")[1])  )
	Local nSizeSRJ := If((TAMSX3("RJ_FUNCAO")[1]) < 1 , 5 , (TAMSX3("RJ_FUNCAO")[1]) )
	Local nSizeTN5 := If((TAMSX3("TN5_CODTAR")[1]) < 1, 6 , (TAMSX3("TN5_CODTAR")[1]))
	Local nSizeSQB := If((TAMSX3("QB_DEPTO")[1]) < 1, 9 , (TAMSX3("QB_DEPTO")[1]))

	Local cStrFun , cStrCC, cStrDpt
	Local cTempFun, cTempCC , cTempTar, cTempDpt

	Local aTabtar   := {}
	Local aRisExp   := {}
	Local dDataVal	:= dDataBase
	Local cRisTAF	:= SuperGetMv( "MV_NG2RIST" , .F. , "3" )

	Local bValRisco := '{ |dData|	( TN0->TN0_DTRECO < SRA->RA_DEMISSA .Or. Empty( SRA->RA_DEMISSA ) ) .And. '
	bValRisco += '( TN0->TN0_DTELIM > SRA->RA_ADMISSA .Or. Empty( TN0->TN0_DTELIM ) ) }

	Default cMatricula := SRA->RA_MAT

	dbSelectArea("SRA")
	dbSetOrder(1)
	dbSeek(xFilial("SRA") + cMatricula)

	cStrCC     := If( ValType(cCusto) <> "U"  , cCusto , SRA->RA_CC )
	cStrFun    := If( ValType(cFuncao) <> "U" , cFuncao , SRA->RA_CODFUNC )
	cStrDpt    := If( ValType(cDepto) <> "U" , cDepto , SRA->RA_DEPTO )
	nTotComb   := 9
	nTotComTar := 8

	// Carrega todas tarefas executadas
	If ValType( cTarefa ) <> "U"
		aAdd( aTabtar , cTarefa )
	Else
		dbSelectArea("TN6")
		dbSetOrder( 2 ) //TN6_FILIAL + TN6_MAT

		If dbSeek(xFilial("TN6") + SRA->RA_MAT)

			While !Eof() .And. SRA->RA_FILIAL == xFilial("SRA") .And. SRA->RA_MAT == TN6->TN6_MAT

				If TN6->TN6_DTINIC <= dDataVal .And. (TN6->TN6_DTTERM >= dDataVal .Or. Empty(TN6->TN6_DTTERM))
					aAdd(aTabtar, TN6->TN6_CODTAR)
				Endif

				dbSelectArea("TN6")
				dbSkip()
			End

		EndIf

	EndIf

	// Verifica todos riscos possiveis relacionados ao funcionario
	For nj:= 1 to nTotComb

		If nj == 1 // Verifica por tarefa

			For ni:= 1 to Len(aTabTar)
				cTempTar	:= aTabTar[ni]

				For nk := 1 to nTotComTar

					If nk==1
						cTempCC	   := cStrCC
						cTempFun   := cStrFun
						cTempDepto := cStrDpt
					ElseIf nk==2
						cTempCC	   := Padr("*", nSizeSI3)
						cTempFun   := cStrFun
						cTempDepto := cStrDpt
					ElseIf nk==3
						cTempCC	   := Padr("*", nSizeSI3)
						cTempFun   := Padr("*", nSizeSRJ)
						cTempDepto := cStrDpt
					ElseIf nk==4
						cTempCC	   := cStrCC
						cTempFun   := Padr("*", nSizeSRJ)
						cTempDepto := cStrDpt
					ElseIf nk==5
						cTempCC	   := cStrCC
						cTempFun   := cStrFun
						cTempDepto := Padr("*", nSizeSQB)
					ElseIf nk==6
						cTempCC	   := Padr("*", nSizeSI3)
						cTempFun   := cStrFun
						cTempDepto := Padr("*", nSizeSQB)
					ElseIf nk==7
						cTempCC	   := cStrCC
						cTempFun   := Padr("*", nSizeSRJ)
						cTempDepto := Padr("*", nSizeSQB)
					Else
						cTempCC	   := Padr("*", nSizeSI3)
						cTempFun   := Padr("*", nSizeSRJ)
						cTempDepto := Padr("*", nSizeSQB)
					EndIf

					dbSelectArea("TN0")
					dbSetOrder( 5 ) //TN0_FILIAL+TN0_CC+TN0_CODFUN+TN0_CODTAR+TN0_DEPTO

					If dbSeek(xFilial("TN0") + cTempCC + cTempFun + cTempTar + cTempDepto)

						While !Eof() .And. TN0->TN0_CC == cTempCC .And. TN0->TN0_CODFUN == cTempFun .And. ;
								TN0->TN0_CODTAR == cTempTar .And. TN0->TN0_FILIAL == xFilial("TN0") .And. ;
								TN0->TN0_DEPTO == cTempDepto

							If Eval( &( bValRisco ) , dDataVal )

								// Adiciona no Array de retorno
								If IsInCallStack( "MDTM004" )
									dbSelectarea( "TMA" )
									dbSetOrder( 1 )
									dbSeek( xFilial( "TMA" ) + TN0->TN0_AGENTE )
									//----------------
									// 4 - Ergonômico
									// 5 - Acidente
									// 6 - Mecanico
									//----------------
									// 1 - Ergonômico
									// 2 - Mecânico/Acidente
									// 3 - Ambos
									//----------------
									If TMA->TMA_GRISCO == "4"
										If cRisTAF == "1" .Or. cRisTAF == "3"
											If aScan(aRisExp, {|x| x[1] == TN0->TN0_NUMRIS}) == 0
												aAdd(aRisExp, {TN0->TN0_NUMRIS})
											EndIf
										EndIf
									ElseIf TMA->TMA_GRISCO == "5" .Or. TMA->TMA_GRISCO == "6"
										If cRisTAF == "2" .Or. cRisTAF == "3"
											If aScan(aRisExp, {|x| x[1] == TN0->TN0_NUMRIS}) == 0
												aAdd(aRisExp, {TN0->TN0_NUMRIS})
											Endif
										Endif
									ElseIf aScan(aRisExp, {|x| x[1] == TN0->TN0_NUMRIS}) == 0
										aAdd(aRisExp, {TN0->TN0_NUMRIS})
									Endif
								ElseIf aScan(aRisExp, {|x| x[1] == TN0->TN0_NUMRIS}) == 0
									aAdd(aRisExp, {TN0->TN0_NUMRIS})
								Endif
							Endif

							dbSelectArea("TN0")
							dbSkip()
						End

					EndIf

				Next nk

			Next ni

		Else
			// Verifica com tarefa "*"
			cTempTar	:= Padr("*",nSizeTN5)

			If nj == 2
				cTempCC	   := cStrCC
				cTempFun   := cStrFun
				cTempDepto := cStrDpt
			ElseIf nj == 3
				cTempCC    := Padr("*",nSizeSI3)
				cTempFun   := cStrFun
				cTempDepto := cStrDpt
			ElseIf nj == 4
				cTempCC	   := Padr("*",nSizeSI3)
				cTempFun   := Padr("*",nSizeSRJ)
				cTempDepto := cStrDpt
			ElseIf nj==5
				cTempCC	   := cStrCC
				cTempFun   := Padr("*",nSizeSRJ)
				cTempDepto := cStrDpt
			ElseIf nj==6
				cTempCC	   := cStrCC
				cTempFun   := cStrFun
				cTempDepto := Padr("*",nSizeSQB)
			ElseIf nj==7
				cTempCC	   := Padr("*",nSizeSI3)
				cTempFun   := cStrFun
				cTempDepto := Padr("*",nSizeSQB)
			ElseIf nj==8
				cTempCC	   := cStrCC
				cTempFun   := Padr("*",nSizeSRJ)
				cTempDepto := Padr("*",nSizeSQB)
			Else
				cTempCC	   := Padr("*",nSizeSI3)
				cTempFun   := Padr("*",nSizeSRJ)
				cTempDepto := Padr("*",nSizeSQB)
			EndIf

			dbSelectArea("TN0")
			dbSetOrder( 5 ) // TN0_FILIAL+TN0_CC+TN0_CODFUN+TN0_CODTAR

			If dbSeek(xFilial("TN0") + cTempCC + cTempFun + cTempTar + cTempDepto)

				While !Eof() .AND. TN0->TN0_CC == cTempCC .AND. TN0->TN0_CODFUN == cTempFun .AND. ;
						TN0->TN0_CODTAR == cTempTar .AND. TN0->TN0_FILIAL == xFilial("TN0") .And. ;
						TN0->TN0_DEPTO == cTempDepto

					If Eval( &( bValRisco ) , dDataVal )
						//Adiciona no Array de retorno
						If IsInCallStack( "MDTM004" )
							dbSelectarea( "TMA" )
							dbSetOrder( 1 )
							dbSeek( xFilial( "TMA" ) + TN0->TN0_AGENTE )
							//----------------
							// 4 - Ergonômico
							// 5 - Acidente
							// 6 - Mecanico
							//----------------
							// 1 - Ergonômico
							// 2 - Mecânico/Acidente
							// 3 - Ambos
							//----------------
							If TMA->TMA_GRISCO == "4"
								If cRisTAF == "1" .Or. cRisTAF == "3"
									If aScan(aRisExp, {|x| x[1] == TN0->TN0_NUMRIS}) == 0
										aAdd(aRisExp, {TN0->TN0_NUMRIS})
									Endif
								Endif
							ElseIf TMA->TMA_GRISCO == "5" .Or. TMA->TMA_GRISCO == "6"
								If cRisTAF == "2" .Or. cRisTAF == "3"
									If aScan(aRisExp, {|x| x[1] == TN0->TN0_NUMRIS}) == 0
										aAdd(aRisExp, {TN0->TN0_NUMRIS})
									Endif
								Endif
							ElseIf aScan(aRisExp, {|x| x[1] == TN0->TN0_NUMRIS}) == 0
								aAdd(aRisExp, {TN0->TN0_NUMRIS})
							Endif
						ElseIf aScan(aRisExp, {|x| x[1] == TN0->TN0_NUMRIS}) == 0
							aAdd(aRisExp, { TN0->TN0_NUMRIS })
						Endif
					Endif

					dbSelectArea("TN0")
					dbSkip()
				End

			Endif

		EndIf

	Next nj

	RestArea( aAreaRis )

Return aRisExp

//--------------------------------------------------------------------------------------------------------
//               Funções relacionadas ao modo de prestador de serviço                                   //
//                      MV_MDTPS = S     ou      MV_NGMDTPS = S                                         //
//              Esta funções devem ficar por ultimo dentro do fonte para adequação                      //
//--------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------
/*/{Protheus.doc} ValidCli
Valida as perguntas "De Cliente", "De Loja", "Ate Cliente", "Ate Loja".

@param nP1 - Campo a validar.
	          1 = "De Cliente"
	          2 = "Ate Cliente"
	          3 = "De Loja"
	          4 = "Ate Loja"
@param cP2 - Valor atual da pergunta "De Cliente"
@param cP3 - Nome da variavel que contem o valor atual da pergunta
			 "De Loja"
@param cP4 - Valor atual da pergunta "Ate Cliente"
@param cP5 - Nome da variavel que contem o valor atual da pergunta
			 "Ate Loja"
@param nP6 - Tamanho do campo "Codigo do Cliente"
@param nP7 - Tamanho do campo "Loja do Cliente"

@obs Deverá ser definido no programa chamador as seguintes variveis, com estes valores pre-definidos:                     º±±
-----------------------------------------------------------------
| Variavel | Valor |         Descricao
-----------------------------------------------------------------
| lVdeCli  |  .F.  |Denota se o campo "De Cliente" foi validado
| lVateCli |  .F.  |Denota se o campo "Ate Cliente" foi validado
| lVdeLojC |  .F.  |Denota se o campo "De Loja" foi validado
| lVateLoC |  .F.  |Denota se o campo "Ate Loja" foi validado
| lCliVazio|  .T.  |Denota se o campo "De Cliente" esta' vazio
| lAteCliZ |  .T.  |Denota se o campo "Ate Cliente" esta'	prenchido com "ZZZZZZ"
| cDeCli   |  " "  |Valor validado do campo "De Cliente"
| cDeCliL  |  " "  |Valor validado do campo "De Loja"
| cAteCli  |  " "  |Valor validado do campo "Ate Cliente"
| cAteCliL |  " "  |Valor validado do campo "Ate Loja"

@author Andre Perez Alvarez
@since 09/02/2006
/*/
//---------------------------------------------------------------------
Function ValCli(nP1,cP2,cP3,cP4,cP5,nP6,nP7)

	Do Case

	Case nP1 == 1		//Valida "De Cliente?"
		If !Empty(cP2)
			If Empty(&(cP3))
				dbSelectArea("SA1")
				dbSetOrder(1)
				dbSeek(xFilial("SA1")+cP2)
				&(cP3) := SA1->A1_LOJA
			Endif
			Return ExistCPO('SA1',cP2+&(cP3))
		Endif
		Return .t.
	Case nP1 == 2		//Valida "Ate Cliente?"
		If &(cP5) == Replicate("Z",nP7)
			Return AteCodigo ('SA1', cP2, cP4, Len(cP4))
		Else
			If cP4 == Replicate("Z",nP6)
				Return .T.
			Endif
			Return AteCodigo ('SA1', cP2+&(cP3), cP4+&(cP5), Len(cP4+&(cP5)))
		Endif
	Case nP1 == 3 		//Valida "De Loja"
		If !Empty(cP2 + &(cP3))
			Return ExistCPO ('SA1', cP2 + &(cP3))
		Else
			Return .T.
		EndIf
	Case nP1 == 4		//Valida "Ate Loja"
		If NaoVazio(&(cP5))
			If Replicate("Z",nP7) == &(cP5)
				Return .T.
			Endif
			If !AteCodigo ('SA1', cP2+&(cP3), cP4+&(cP5), Len(cP4+&(cP5)))
				&(cP5) := Replicate("Z",nP7)
				Return .F.
			Endif
		Else
			Return .f.
		Endif
	EndCase

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} ValCre
Valida as perguntas "De Credenciado", "De Loja", "Ate Credenciado", "Ate Loja".

@param nP1 - Campo a validar.
	          1 = "De Credenciado"
	          2 = "Ate Credenciado"
	          3 = "De Loja"
	          4 = "Ate Loja"
@param cP2 - Valor atual da pergunta "De Credenciado"
@param cP3 - Nome da variavel que contem o valor atual da pergunta
			 "De Loja"
@param cP4 - Valor atual da pergunta "Ate Credenciado"
@param cP5 - Nome da variavel que contem o valor atual da pergunta
			 "Ate Loja"
@param nP6 - Tamanho do campo "Codigo do Credenciado"
@param nP7 - Tamanho do campo "Loja do Credenciado"

@obs Deverá ser definido no programa chamador as seguintes variveis, com estes valores pre-definidos:                     º±±
-----------------------------------------------------------------
| Variavel | Valor |         Descricao
-----------------------------------------------------------------
| lVdeCre  |  .F.  |Denota se o campo "De Cred." foi validado
| lVateCre |  .F.  |Denota se o campo "Ate Cred." foi validado
| lVdeLojF |  .F.  |Denota se o campo "De Loja" foi validado
| lVateLoF |  .F.  |Denota se o campo "Ate Loja" foi validado
| lCreVazio|  .T.  |Denota se o campo "De Cred." esta' vazio
| lAteCreZ |  .T.  |Denota se o campo "Ate Cred." esta'	prenchido com "ZZZZZZ"
| cDeCre   |  " "  |Valor validado do campo "De Cred."
| cDeCreL  |  " "  |Valor validado do campo "De Loja"
| cAteCre  |  " "  |Valor validado do campo "Ate Cred."
| cAteCreL |  " "  |Valor validado do campo "Ate Loja"

@author Andre Perez Alvarez
@since 09/02/2006
/*/
//---------------------------------------------------------------------
Function ValCre(nP1,cP2,cP3,cP4,cP5,nP6,nP7)

	Do Case

	Case nP1 == 1		//Valida "De Credenciado"
		If !Empty(cP2)
			Return ExistCPO('SA2',cP2)
		Endif
		Return .t.
	Case nP1 == 2		//Valida "Ate Credenciado"
		Return AteCodigo ('SA2', cP2, cP4, Len(cP4))
	Case nP1 == 3 		//Valida "De Loja"
		If !Empty(cP2 + &(cP3))
			Return ExistCPO ('SA2', cP2 + &(cP3))
		Else
			Return .T.
		EndIf
	Case nP1 == 4		//Valida "Ate Loja"
		If NaoVazio(&(cP5))
			If Replicate("Z",nP7) == &(cP5)
				Return .T.
			Endif
			Return AteCodigo ('SA2', cP2+&(cP3), cP4+&(cP5), Len(cP4+&(cP5)))
		Else
			Return .f.
		Endif
	EndCase

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTMATVAL
Verifica se o funcionario pertence ao cliente.

@author Andre Perez Alvarez
@since 31/01/2008
/*/
//---------------------------------------------------------------------
Function MDTMATVAL(cMat,cCliMdtps)

	Local nSizeSA1  := If((TAMSX3("A1_COD")[1]) < 1,6,(TAMSX3("A1_COD")[1]))
	Local nSizeLo1  := If((TAMSX3("A1_LOJA")[1]) < 1,2,(TAMSX3("A1_LOJA")[1]))
	Local nSizeTD := nSizeSA1+nSizeLo1

	dbSelectArea("SRA")
	dbSetOrder(1)
	If dbSeek(xFilial("SRA")+cMat)
		If SubSTR(SRA->RA_CC,1,nSizeTD) <> cCliMdtps
			msgStop(STR0080,STR0078)  //"O funcionário selecionado não pertence ao cliente."//"ATENÇÃO"
			Return .F.
		Endif
	Endif

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTTO0VAL
Verifica se o laudo pertence ao cliente.

@author Andre Perez Alvarez
@since 31/01/2008
/*/
//---------------------------------------------------------------------
Function MDTTO0VAL(cLaudo,cCliMdtps)

	dbSelectArea("TO0")
	dbSetOrder(6)  //TO0_FILIAL+TO0_CLIENT+TO0_LOJA+TO0_LAUDO
	If !dbSeek(xFilial("TO0")+cCliMdtps+cLaudo)
		msgStop(STR0081,STR0078)  //"O laudo selecionado não pertence ao cliente."//"ATENÇÃO"
	Endif

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} ValAte3
Valida a pergunta "Ate" de qualquer tabela (somente p/ prestador de serv.)

@param cPar01 - Valor da pergunta "De ...   "
@param cPar02 - Valor da pergunta "Ate ...  "
@param cTab   - Alias da tabela onde a pergunta busca os dados
@param cField - Alias do campo onde a pergunta busca os dados
@param nInd   - Indice de busca na tabela

@author Andre Perez Alvarez
@since 12/02/2008
/*/
//---------------------------------------------------------------------
Function ValAte3(cPar01,cPar02,cTab,cField,cCliMdtps,nInd)
	Local nSizeField := (TAMSX3(cField)[1])

	Do Case

	Case cPar02==Replicate('Z',nSizeField)
		Return .T.
	Case Empty(cPar02)
		Help(" ",1,"ATEINVALID")
		Return .F.
	Case cPar02 < cPar01
		Help(" ",1,"DEATEINVAL")
		Return .F.
	Case !ExistCpo(cTab,cCliMdtps+cPar02,nInd)
		Return .F.
	OtherWise
		Return .T.

	EndCase

Return .T.
//---------------------------------------------------------------------
/*/{Protheus.doc} ValidReg
Valida a pergunta "Ate Regiao"

@param cDeReg  - Valor da pergunta "De Regiao"
@param cAteReg - Valor da pergunta "Ate Regiao"

@author Andre Perez Alvarez
@since 10/02/2006
/*/
//---------------------------------------------------------------------
Function ValidReg(cDeReg,cAteReg)

	Do Case
	Case cAteReg=='ZZZ'
		Return .T.
	Case ExistCPO('SX5','A2'+cAteReg)
		If AteCodigo('SX5','A2'+cDeReg,'A2'+cAteReg,3)
			Return .T.
		Else
			Return .F.
		EndIf
	OtherWise
		Return .F.
	EndCase

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} ValEstad
Valida a pergunta "Ate Estado"

@param cDeEst  - Valor da pergunta "De Estado"
@param cAteEst - Valor da pergunta "Ate Estado"

@author Andre Perez Alvarez
@since 10/02/2006
/*/
//---------------------------------------------------------------------
Function ValEstad(cDeEst,cAteEst)

	Do Case
	Case cAteEst=='ZZ'
		Return .T.
	Case ExistCpo('SX5','12'+cAteEst)
		If AteCodigo('SX5','12'+cDeEst,'12'+cAteEst,2)
			Return .T.
		Else
			Return .F.
		EndIf
	OtherWise
		Return .F.
	EndCase

Return
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTREGIAO
Traz o codigo da regiao de acordo com o Estado (funcao especifica de prestador de serviço)

@param cEstado - Código do Estado

@author Andre Perez Alvarez
@since 19/08/2008
/*/
//---------------------------------------------------------------------
Function MDTREGIAO(cEstado,nOpt)

	Local cRegiao := ""

	//Estados da regiao Norte
	Local aNorte := {"AC","AM","AP","PA","RO","RR","TO"}

	//Estados da regiao Nordeste
	Local aNE := {"AL","BA","CE","MA","PB","PE","PI","RN","SE"}

	//Estados da regiao Centro Oeste
	Local aCO := {"DF","GO","MS","MT"}

	//Estados da regiao Sudeste
	Local aSudeste := {"ES","MG","RJ","SP"}

	//Estados da regiao Sul
	Local aSul := {"PR","RS","SC"}

	//Estados de outros países
	Local aOutras := {"EX"}  //Estado estrangeiro

	//Códigos da regiões no sistema da Engemed
	//001 - norte, 002-nordeste, 003 sul, 004 - centro oeste, 005 sudeste

	Do Case
	Case ( aSCAN(aNorte, {|x| x == cEstado }) ) > 0
		cRegiao := '001'
	Case ( aSCAN(aNE, {|x| x == cEstado }) ) > 0
		cRegiao := '002'
	Case ( aSCAN(aCO, {|x| x == cEstado }) ) > 0
		cRegiao := '004'
	Case ( aSCAN(aSudeste, {|x| x == cEstado })	) > 0
		cRegiao := '005'
	Case ( aSCAN(aSul, {|x| x == cEstado })	) > 0
		cRegiao := '003'
	Case ( aSCAN(aOutras, {|x| x == cEstado }) ) > 0
		cRegiao := ''
	End Case

	If nOpt == 1
		M->A1_REGIAO := cRegiao
	Else
		M->A2_REGIAO := cRegiao
	Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} NGMDT_H9
Obter Data de Excessao do Calendario.

@param dDat Data Data da Excessao do Calendario.

@return aDIA Array 1) Horario Inicial  ; 2) Horario Final ; 3) Totalcarga Horaria

@author Paulo Pego
@since 17/02/2000
/*/
//---------------------------------------------------------------------
Function NGMDT_H9(dDat)
	Local aDIA := {}, Hor, INI, FIM, Dia, Tot, x
	Local aOCI := {}

	SH9->(DbSetOrder(2))
	SH9->(DbSeek(xFilial("SH9")))
	If !SH9->(DbSeek(xFilial("SH9") + "E" + DTOS(dDAT) ))
		SH9->(DbSetOrder(1))
		Return aDIA
	EndIf

	aDia := {}
	Hor  := sh9->h9_aloc
	Dia  := Hor                      //SubStr(Hor,pos,qtd)
	Tot  := 0
	Ini  := 999
	Fim  := 0
	aOCI := {}
	nOI  := 999
	nOF  := 0
	Tot  := 0
	For x := 1 to Len(Dia)
		If !Empty(SubStr(DIa,x,1))
			Tot += (1440/Len(Dia))
			Fim := ( (1440/Len(Dia)) * x )
			Ini := If(Ini == 999,(Fim - (1440/Len(Dia))),Ini)
			If nOI != 999
				AAdd(aOCI,{nOI, nOF})
				nOI := 999
				nOF := 0
			EndIf
		Else
			nOF := ( (1440/Len(Dia)) * x )
			nOI := If(nOI == 999,(nOF - (1440/Len(Dia))),nOI)
		Endif
	Next
	If nOI != 999
		AAdd(aOCI,{nOI, nOF})
		nOI := 999
		nOF := 0
	EndIf

	Ini  := If(Ini == 999,0,Ini)
	aDia := { MtoH(INI), MtoH(FIM), MtoH(TOT), aOCI }
Return aDIA

//---------------------------------------------------------------------
/*/{Protheus.doc} CHECKINTER
Consitencia do intervalo

@author Inacio Luiz Kolling
@since 02/02/2000
/*/
//---------------------------------------------------------------------
Function CHECKINTER(nVALOR)
	Local aVALOR := {0,10,20,30,40,50,60,70,80,90,100,110,120,130},ix
	Local lACHOU := .F.

	FOR IX := 1 TO LEN(aVALOR)
		If aVALOR[IX] == nVALOR
			lACHOU := .T.
			EXIT
		Endif
	Next
	If !lACHOU
		Return .f.
	Endif
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTChkSR8

Verifica a existência de ausencia no periodo de dDataIni a dDataFim.

@Obs Função de unificação da verificação da SR8, conforme periodo.
@Obs Utilizado nas rotinas:	MDTA190, MDTA195, MDTUTIL, MDTR610,
											MDTR850, MDTR865, MDTR868, MDTR870

@param cAliSR8		Caracter	Indica Alias a ser trabalhado, Default SR8
@param nOrdSR8		Numerico	Indica a ordem a ser trabalhado, Default 1
@param cSeekSR8		Caracter	Indica a chave a ser trabalhado, Default xFilial( cAliSR8 )
@param cWhileSR8	Caracter	Indica a o clico de repetição a ser trabalho na macro,
											Default "xFilial( cAliSR8 ) == SR8->R8_FILIAL"
@param dDataIni		Date			Indica a Data início a ser verificada
@param dDataFim		Date			Indica a Data final a ser verificada

@sample MDTChkSR8( "SR8", 1 , xFilial("SR8"), "xFilial('SR8') == SR8->SR8_FILIAL ;
							dDataBase, dDataBase+5 )
@return lRet Boolean Indica a existência de alguma ausência.

@author Guilherme Benkendorf
@since 08/09/2014
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTChkSR8( cAliSR8, nOrdSR8, cSeekSR8, cWhileSR8 , dDataIni , dDataFim )

	Local lRet 		:= .F.
	Local aArea 	:= GetArea()
	Local aAreaSR8 	:= ( cAliSR8 )->( GetArea() )
	//MV_NG2AUSE foi cadastrado de forma errada no AtuSX, não remover a conversão
	Local lConsAuse := cValToChar(SuperGetMv( "MV_NG2AUSE" , .F. , "2" )) == "1" //Verifica se deverá considerar Funcionários ausentes(Afastado ou Férias)

	Private cAliAux	:= ""

	Default cAliSR8		:= "SR8"
	Default nOrdSR8		:= 1 //R8_FILIAL+R8_MAT+DTOS(R8_DATAINI)+R8_TIPO+R8_TIPOAFA
	Default cSeekSR8	:= xFilial( cAliSR8 )
	Default cWhileSR8	:= "xFilial( cAliAux ) == SR8->R8_FILIAL"

	cAliAux := cAliSR8

	dbSelectArea( cAliSR8 )
	dbSetOrder( nOrdSR8 )
	dbSeek( cSeekSR8 )
	While ( cAliSR8 )->( !Eof() ) .and. &cWhileSR8

		If IsInCallStack("MDTA195")
			//Verifica se possui conflitos de data de Afastamento com data de geração de convocação
			If ( dDataIni >= SR8->R8_DATAINI .AND. dDataIni <= SR8->R8_DATAFIM ) .Or. ;
					( dDataFim > SR8->R8_DATAINI .AND. dDataFim <= SR8->R8_DATAFIM )
				//Se parametro habilitado deverá add no array para ser definido qual será possivel realizar o exame
				If lConsAuse
					If !Empty( SR8->R8_DATAFIM )
						aAdd( aDtAusen , { SR8->R8_DATAINI, SR8->R8_DATAFIM, SR8->R8_CONTAFA } )
					Else
						aAdd( aDtAusen , { SR8->R8_DATAINI, SR8->R8_DATAFIM + 999, SR8->R8_CONTAFA } ) //Se data fim estiver vazia deverá somar 999.
					Endif
					lRet := .T.
				Else
					lRet := .F.
					Exit
				EndIf
			Else //Se não possuir Afastamento no periodo de convocação deverá gravar com a data informada
				lRet := .F.
				Exit
			EndIf
		Else
			If dDataIni >= SR8->R8_DATAINI .AND. ( dDataFim <= SR8->R8_DATAFIM .Or. Empty( SR8->R8_DATAFIM ) )
				lRet := .T.
			Endif
		EndIf

		( cAliSR8 )->( dbSkip() )
	End

	RestArea( aArea )
	RestArea( aAreaSR8 )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTFunAti

Analisa se é permetido a entrega de EPI para funcionarios fora de atividade,
através do parâmetro MV_NGEPIEN

@Obs Utilizado nas rotinas:	MDTA630, MDTA695

@param cMatricula	Caracter	Indica o código da matricula do funcionário.
@param l695Auto		Boolean		Indica se a rotina esta trabalhando com rotina
											automática.

@sample MDTFunAti( "0000001" , .F. )
@return lRet Boolean Indica a existência de alguma obstrução.

@author Guilherme Benkendorf
@since 08/09/2014
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTFunAti( cMatricula , l695Auto )

	Local lPerEntEPI:= SuperGetMv("MV_NGEPIEN",.F.,"S") == "N"
	Local lRetEPI		:= .F.
	Local lAusSR8		:= .F.

	Local cTextoMsg	:= ""
	Local cMsgInfo1	:= ""
	Local cMsgInfo2	:= ""
	Local cMsgInfo3	:= ""

	Local cTipoSR8  := "If( Empty( SR8->R8_TIPOAFA ), SR8->R8_TIPO , NGSeek( 'RCM' , SR8->R8_TIPOAFA , 1 , 'RCM->RCM_CODSEF' ) )"

	Local aArea := GetArea()
	Local aAreaSRA := SRA->( GetArea() )
	Local aAreaSRH := SRH->( GetArea() )
	Local aAreaSR8 := SR8->( GetArea() )

	Default l695Auto := .F.

	dbSelectArea("SRA")
	dbSetOrder( 1 )//RA_FILIAL+RA_MAT
	If dbSeek( xFilial("SRA") + cMatricula )

		If lPerEntEPI
			cMsgInfo1 := "O funcionário " + AllTrim( SRA->RA_MAT ) + " - " + AllTrim( SRA->RA_NOME ) + " está demitido, não é possível a entrega de EPI's."
			cMsgInfo2 := "O funcionário " + AllTrim( SRA->RA_MAT ) + " - " + AllTrim( SRA->RA_NOME ) + " está de férias, não é possível a entrega de EPI's."
			cMsgInfo3 := "O funcionário " + AllTrim( SRA->RA_MAT ) + " - " + AllTrim( SRA->RA_NOME ) + " está afastado, não é possível a entrega de EPI's."
		Else
			cMsgInfo1 := "O funcionário " + AllTrim( SRA->RA_MAT ) + " - " + AllTrim( SRA->RA_NOME ) + " está demitido, deseja efetuar as entregas de EPIs?"
			cMsgInfo2 := "O funcionário " + AllTrim( SRA->RA_MAT ) + " - " + AllTrim( SRA->RA_NOME ) + " está de férias, deseja efetuar as entregas de EPIs?"
			cMsgInfo3 := "O funcionário " + AllTrim( SRA->RA_MAT ) + " - " + AllTrim( SRA->RA_NOME ) + " está afastado temporariamente, deseja efetuar as entregas de EPIs?"
		EndIf

		dbSelectArea("SRA")
		If !EMPTY(SRA->RA_SITFOLH)
			If SRA->RA_SITFOLH == "D" .And. (SRA->RA_DEMISSA < dDataBase)
				cTextoMsg := cMsgInfo1
			Endif
		Endif
		//Verifica se funcionário está de férias
		If Empty(cTextoMsg)
			dbSelectArea( "SRH" )
			dbSetOrder( 1 ) //RH_FILIAL+RH_MAT+DTOS(RH_DATABAS)+DTOS(RH_DATAINI)
			dbSeek( xFilial("SRH") + SRA->RA_MAT )

			While !Eof() .and. SRH->RH_FILIAL+SRH->RH_MAT == xFilial("SRH")+SRA->RA_MAT
				If !Empty( SRH->RH_DATAINI ) .And. dDataBase >= SRH->RH_DATAINI .AND. (dDataBase <= SRH->RH_DATAFIM .or. Empty(SRH->RH_DATAFIM))
					cTextoMsg := cMsgInfo2
					Exit
				Endif
				dbSelectArea("SRH")
				dbSkip()
			End
		EndIf

		//Verifica se funcionário está ausente
		If Empty(cTextoMsg)
			dbSelectArea( "SR8" )
			dbSetOrder( 1 )//R8_FILIAL+R8_MAT+DTOS(R8_DATAINI)+R8_TIPO+R8_TIPOAFA
			dbSeek( xFilial("SR8") + SRA->RA_MAT )
			While !Eof() .AND. SR8->R8_FILIAL+SR8->R8_MAT == xFilial("SR8")+SRA->RA_MAT .And. !lAusSR8

				If SR8->R8_DATAINI <= dDataBase .AND. ( Empty(SR8->R8_DATAFIM) .OR. SR8->R8_DATAFIM >= dDataBase )
					cTextoMsg := If( SubStr( SR8->( cTipoSR8 ) , 1 , 1 ) == "F", cMsgInfo2, If( SubStr( SR8->( cTipoSR8 ) , 1 , 1 ) == "D", cMsgInfo1 , cMsgInfo3 ) )
					lAusSR8 := .T.
				EndIf

				dbSelectArea("SR8")
				dbSkip()
			End
		Endif

		//Exibe Mensagem
		If !Empty( cTextoMsg )
			If lPerEntEPI
				Help(" ",1,"Aviso",,cTextoMsg,4,5) //Aviso
				lRetEPI := .T.
			Else
				If !l695Auto .And. !MsgYesNo(cTextoMsg,STR0078) //"ATENÇÃO"
					lRetEPI := .T.
				EndIf
			EndIf
		EndIf
	EndIf

	RestArea( aArea )
	RestArea( aAreaSRA )
	RestArea( aAreaSRH )
	RestArea( aAreaSR8 )

Return lRetEPI .Or. ( l695Auto .And. !Empty( cTextoMsg ) )

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTGravSR8

Função de unificação do Módulo de Segurança e Medicina do Trabalho
para a gravação da tabela SR8 - Ausencias.

@Obs Utilizado nas rotinas:	MDTA685, MDTA910 , MDTA920

@param cAliRec		Caracter	Indica Alias a ser trabalhado.
@param nOpcx			Numerico	Indica o tipo de operação.
@param aRecordSR8	Array			Array multidimensional N x 2, primeira posição
											da coluna indica, em caracter, o nome do campo
											a ser gravado. Segunda posição, é o registro a
											ser gravado.

@param nRecnoSR8	Numerico	Posicionamento através do Recno.
@param cCondSR8		Caracter	Caso contenha alguma condição para ser efetuado a
											gravação.


@sample MDTGravSR8( "SR8" , 1 , 5 ,  , , 50 , "SR8->R8_TIPO == 'P'" )
@sample MDTGravSR8( "SR8" , 1 , nOpc , xFilial( "SR8" )+SRA->RA_MAT  , {	{ "R8_FILIAL"	, xFilial("SR8")	} ,;
																											{ "R8_MAT"		, SRA->RA_MAT		} ,;
																											{ "R8_DATAINI"	, DTOS(dDataBase)	} ,;
																											{ "R8_TIPO"		, "P"					} } )

@return lRet Boolean Indica se foi realizado uma Inclusão (.T.) ou alteração (.F.)

@author Guilherme Benkendorf
@since 08/09/2014
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTGravSR8( cAliRec, nOpcx, aRecordSR8, nRecnoSR8, cCondSR8, oModSR8, lModel, aErrAfa )

	Local aLog := {}
	Local aCabSR8 := {}

	Local cEmpBkp := cEmpAnt // A mensagem única disparada no GPE está desposicionando da filial logada
	Local cFilBkp := cFilAnt // Por isso, necessário realizar um backup da empresa e filial

	Local oGridSR8

	Local lRet := .F.
	Local lAtt := .F. // Determina se executará Commit
	Local lInclui := .F.

	Local nX
	Local nSeq := 0
	Local nTYZ := 0
	Local nDtIni := 0
	Local nDtFim := 0

	Default aRecordSR8 := {}

	Default cAliRec := ""

	Default cCondSR8 := ".T."

	Default lModel := .F.

	Default nOpcx := 0
	Default nRecnoSR8 := 0

	Default oModSR8 := FWLoadModel( "GPEA240" ) // Chama modelo do GPE

	If !lModel // Caso não passou o Modelo de Dados.

		//Montagem do modelo do GPEA240

		oModSR8:SetOperation( 4 ) // Seta Alteração
		oModSR8:Activate() // Ativa Modelo.
		oGridSR8 := oModSR8:GetModel( "GPEA240_SR8" ) // Grid par inclusão dos registros.

		// Percorre todos os registros da SR8.
		For nX := 1 To oGridSR8:Length()

			oGridSR8:GoLine( nX )

			If !Empty( oGridSR8:GetValue( "R8_SEQ" ) )

				aAdd( aCabSR8, {;
					{ "R8_SEQ", oGridSR8:GetValue( "R8_SEQ" ) },;
					{ "R8_DATAINI", oGridSR8:GetValue( "R8_DATAINI" ) },;
					{ "R8_DATAFIM", oGridSR8:GetValue( "R8_DATAFIM" ) },;
					{ "R8_CONTAFA", oGridSR8:GetValue( "R8_CONTAFA" ) };
					} )

			EndIf

		Next nX

		nSeq := aScan( aRecordSR8, { | x | x[ 1 ] == "R8_SEQ" } )
		nDtIni := aScan( aRecordSR8, { | x | x[ 1 ] == "R8_DATAINI" } )
		nDtFim := aScan( aRecordSR8, { | x | x[ 1 ] == "R8_DATAFIM" } )
		nConAf := aScan( aRecordSR8, { | x | x[ 1 ] == "R8_CONTAFA" } )

		If ValType( nRecnoSR8 ) != "U" .And. nRecnoSR8 > 0

			( cAliRec )->( DbGoTo( nRecnoSR8 ) )

			lRet := ( nOpcx != 3 )

		Else

			dbSelectArea( cAliRec )

			nRecnoSR8 := MDTRecnoSR8( aRecordSR8 )

			If nRecnoSR8 > 0

				( cAliRec )->( DbGoTo( nRecnoSR8 ) )

				lRet := ( nOpcx != 3 )

			EndIf

		EndIf

		If &( cCondSR8 )

			dbSelectArea( cAliRec )

			If nOpcx == 5

				If lRet

					nTYZ := aScan( aCabSR8, { | x | x[ 1, 2 ] == SR8->R8_SEQ } )

					If nTYZ > 0

						oGridSR8:GoLine( nTYZ )
						oGridSR8:DeleteLine()

						lAtt := .T.

					EndIf

				EndIf

			Else

				nTYZ := aScan( aCabSR8 , { | x | x[ 1, 2 ] == aRecordSR8[ nSeq, 2 ] } )

				If nTYZ > 0

					oGridSR8:GoLine( nTYZ )

					If aScan( aCabSR8, { | x | x[ 2, 2 ] == aRecordSR8[ nDtIni, 2 ] } ) == 0 .Or. ;
							aScan( aCabSR8, { | x | x[ 3, 2 ] == aRecordSR8[ nDtFim, 2 ] } ) == 0 .Or. ;
							aScan( aCabSR8, { | x | x[ 4, 2 ] == aRecordSR8[ nConAf, 2 ] } ) == 0

						lAtt := .T.

					EndIf

				Else

					If Len( aCabSR8 ) == 0

						oGridSR8:GoLine( 1 )

						lAtt := .T.

					Else

						oGridSR8:AddLine()

						lAtt := .T.

					EndIf

				EndIf

				For nX := 1 To Len( aRecordSR8 )

					If oGridSR8:GetValue( aRecordSR8[ nX, 1 ] ) != aRecordSR8[ nX, 2 ]

						oGridSR8:LoadValue( aRecordSR8[ nX, 1 ]  ,  aRecordSR8[ nX, 2 ] )

					EndIf

				Next nX

			EndIf

			If lAtt

				If( oModSR8:VldData() ) // Verifica as Validações do sistema.

					oModSR8:CommitData() // Grava as Alterações.

				Else

					aLog := oModSR8:GetErrorMessage() // Identifica erros.

					If ValType( aErrAfa ) == "A"

						aAdd( aErrAfa, { aLog[ 5 ], aLog[ 6 ] } )

					Else

						Help( , , aLog[ 5 ] , , aLog[ 6 ], 5 , 5 )

					EndIf

					lRet := .T.

				EndIf

			EndIf

		EndIf

	Else

		If( oModSR8:VldData() ) //Verifica as Validações do sistema.

			oModSR8:CommitData() //Grava as Alterações.

		Else

			aLog := oModSR8:GetErrorMessage() //Identifica erros.

			If ValType( aErrAfa ) == "A"

				aAdd( aErrAfa, { aLog[ 5 ], aLog[ 6 ] } )

			Else

				Help( , , aLog[ 5 ], , aLog[ 6 ], 1, 0, , , , , , { IIf( Empty( aLog[ 7 ] ), Nil, aLog[ 7 ] ) } )

			EndIf

			lRet := .T.

		EndIf

	EndIf

	cEmpAnt := cEmpBkp // Retorna para empresa salva
	cFilAnt := cFilBkp // Retorna para filial salva

	oModSR8:DeActivate()

	lInclui := !lRet

Return lInclui
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTGravSRE

Função de unificação do Módulo de Segurança e Medicina do Trabalho
para a gravação da tabela SRE - Transferencias

@Obs Utilizado nas rotinas:	MDTA910, MDTA950

@param cAliRec		Caracter	Indica Alias a ser trabalhado.
@param nOrdRec		Numerico	Indica a Ordem a ser feito o posicionamento.
@param nOpcx			Numerico	Indica o tipo de operação.
@param cSeekRec		Caracter	Indica a chave a ser posicionada.
@param aRecordSR8	Array			Array multidimensional N x 2, primeira posição
											da coluna indica, em caracter, o nome do campo
											a ser gravado. Segunda posição, é o registro a
											ser gravado.

@sample MDTGravSRE( "SRE" , 1 , nOpc , cEmpAnt+cFilAnt+"000001"+DTOS(dDataBase)  ,;
																		{	{ "RE_EMPD"		, cEmpAnt			} ,;
																			{ "RE_FILIALD"	, cFilAnt			} ,;
																			{ "MATD"			, "000001"			} ,;
																			{ "RE_DATA"		, DTOS(dDataBase)	} } )
@return lRet Boolean Indica a existência de alguma obstrução.

@author Guilherme Benkendorf
@since 08/09/2014
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTGravSRE( cAliRec , nOrdRec , nOpcx , cSeekRec , aRecordSRE )

	Local nX
	Local nSizeFil := FWSizeFilial()

	Local lRet
	Local lInclui := .F.

	Local aArea		:= GetArea()
	Local aAreaRec	:= ( cAliRec )->( GetArea() )

	Default nOpcx			:= 3
	Default aRecordSRE	:= {}

	Dbselectarea( cAliRec )
	Dbsetorder( nOrdRec )
	lRet:= Dbseek( cSeekRec )

	Reclock( cAliRec , !lRet)

	If nOpcx == 5 .And. lRet
		( cAliRec )->( dbDelete() )
	Else
		For nX := 1 To Len( aRecordSRE )
			&( cAliRec + "->" + ( aRecordSRE[ nX][ 1 ] ) ) := aRecordSRE[ nX ][ 2 ]
		Next nX

		If SRA->( FieldPos( "RA_PROCES" ) ) > 0

			nPosMat := aScan( aRecordSRE , { | x | AllTrim( UPPER( x[1] ) ) == "RE_MATD" } )
			If nPosMat > 0
				dbSelectArea( "SRA" )
				dbSetOrder( 1 ) //RA_FILIAL+RA_MAT
				If dbSeek( PadR( xFilial( "SRA", SRE->RE_FILIALD ), nSizeFil ) + PADR( aRecordSRE[ nPosMat ][ 2 ] , Len( SRA->RA_MAT ) ) ) .And. !Empty( SRA->RA_PROCES )
					SRE->RE_PROCESD := SRA->RA_PROCES
				EndIf
			EndIf

			nPosMat := aScan( aRecordSRE , { | x | AllTrim( UPPER( x[1] ) ) == "RE_MATP" } )
			If nPosMat > 0
				dbSelectArea( "SRA" )
				dbSetOrder( 1 ) //RA_FILIAL+RA_MAT
				If dbSeek( PadR( xFilial( "SRA", SRE->RE_FILIALP ), nSizeFil ) + PADR( aRecordSRE[ nPosMat ][ 2 ] , Len( SRA->RA_MAT ) ) ) .And. !Empty( SRA->RA_PROCES )
					SRE->RE_PROCESP := SRA->RA_PROCES
				EndIf
			EndIf
		EndIf
	EndIf

	( cAliRec )->( MsUnLock() )

	lInclui := !lRet

	RestArea( aArea )
	RestArea( aAreaRec )

Return lInclui

//---------------------------------------------------------------------
/*/{Protheus.doc} SRExpRisco

Analisa se a data inicio de exposição do Risco foi a partir de uma
transferencia de Empresa/Filial/Centro de Custo.

@Obs Utilizado nas rotinas:	MDTA180 , MDTA210 , MDTA215

@param nOrdSRE	Numerico
@param cSeekSRE Caracter
@param cCondSRE Caracter
@param dDataIni Data
@param cCusto		Caracter
@param lCCusto	Boolean

@sample
@return lRet Boolean Indica a existência de alguma obstrução.

@author Guilherme Benkendorf
@since 08/09/2014
@version 1.0
/*/
//---------------------------------------------------------------------
Function SRExpRisco( nOrdSRE , cSeekSRE , cCondSRE , dDataIni , cCusto, lCCusto )

	Local lRet			:= .F.
	Local cCondWhile:= "SRE->RE_CCP == cCusto .AND. SRE->RE_DATA > dDataIni"

	Local aArea		:= GetArea()
	Local aAreaSRE	:= SRE->( GetArea() )

	Default nOrdSRE := 1
	Default cCondSRE:= ".T."
	Default lCCusto := .T.

	If !lCCusto
		cCondWhile := "(SRE->RE_EMPD <> cEmpAnt .OR. SRE->RE_FILIALD <> cFilAnt) .AND. SRE->RE_DATA > dDataIni"
	EndIf

	DbSelectArea("SRE")
	SRE->(DbSetOrder(2))
	IF SRE->( DbSeek( cSeekSRE ) ) .AND. &( cCondSRE )

		While SRE->(!Eof()) .AND. SRE->RE_EMPP == cEmpAnt .AND. SRE->RE_FILIALP == cFilAnt .AND. SRE->RE_MATP == SRA->RA_MAT

			If &( cCondWhile )
				dDataIni := SRE->RE_DATA
			Endif

			SRE->(DbSkip())
		Enddo
		lRet := .T.
	Endif

	RestArea( aArea )
	RestArea( aAreaSRE )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} SXBMDTEPI
Filtro da consulta padrão MDTEPI

@author Guilherme Benkendorf
@since 04/11/2014
@version 1.0
/*/
//---------------------------------------------------------------------
Function SXBMDTEPI()

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTRecnoSR8
Função para busca do recno da SR8. Realizado tal operação pois não
havia indice para posicionamento correto do registro. Foi encaminhado
email ao responsaveis da tabela, mas não retornaram, em um periodo de
mais de 3 meses.

@author Guilherme Benkendorf
@since 06/12/2014
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTRecnoSR8( aRegSR8 )
	Local nRecSR8 := 0
	Local nPosSR8
	Local nX

	Local cQrySR8 := ""
	Local cTRBSR8 := GetNextAlias()
	//Variavel de controle da chave unica da SR8
	Local aKeySR8 := { "R8_FILIAL" , "R8_MAT" , "R8_DATAINI" , "R8_TIPOAFA" }

	cQrySR8 := " SELECT ISNULL( SR8.R_E_C_N_O_ , 0 ) AS RECNO FROM " + RetSqlName( "SR8" ) + " SR8"
	cQrySR8 += " WHERE SR8.D_E_L_E_T_ <> '*' "

	For nX := 1 To Len( aKeySR8 )
		nPosSR8 := aScan( aRegSR8 , { | x | x[1] == aKeySR8[nX] } )
		//
		If nPosSR8 > 0
			cQrySR8 += " AND SR8." + aRegSR8[nPosSR8][1] + " = " + ValToSQL( aRegSR8[nPosSR8][2] )
		EndIf
	Next nX

	cQrySR8 := ChangeQuery(cQrySR8)
	MPSysOpenQuery( cQrySR8 , cTRBSR8 )

	nRecSR8 := (cTRBSR8)->RECNO

	//Deleta os TRB
	(cTRBSR8)->( dbCloseArea() )

Return nRecSR8
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTGPEAfas
Função que verifica a consistencia de CIDs no Afastamento(GPEA240) com
o Acidente(MDTA640).

@Obs Uso GPEA240

@author Guilherme Benkendorf
@since 24/04/2015
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTGPEAfas( oModelGPE )

	Local oGrid := IIf( ValType( oModelGPE ) <> "U", oModelGPE:GetModel( "GPEA240_SR8" ), Nil )
	Local lCposRec := MDT640Rcb() //Verifica se existem os campos de recibo no dicionário de dados
	Local cQryCAT
	Local cAliasQry
	Local cSEQ
	Local cCAT
	Local cCID
	Local cREC := ""

	If ValType( oGrid ) <> "U"

		//Todas essas informações deverão existir no cabeçalho da SR8
		If oGrid:HasField( "R8_SEQ" ) .And. oGrid:HasField( "R8_CODCAT" ) .And. oGrid:HasField( "R8_CID" )

			cSEQ := oGrid:GetValue( "R8_SEQ" )
			cCAT := oGrid:GetValue( "R8_CODCAT" )
			cCID := oGrid:GetValue( "R8_CID" )

			//Caso existam os campos de recibo no dicionário de dados
			If lCposRec .And. oGrid:HasField( "R8_RECIBO" )
				cREC := oGrid:GetValue( "R8_RECIBO" )
			EndIf

			//Verifica se no cadastro de Acidente não há uma acidente que possua
			// o mesmo CAT INSS da SR8. E que a informação do SR8.CID seja diferente
			If !Empty( cCAT ) .Or. !Empty( cREC )

				cAliasQry := GetNextAlias()

				cQryCAT := "SELECT TNC.TNC_ACIDEN AS ACIDENTE FROM " + RetSQLTab( "TNC" )
				cQryCAT += " WHERE " + RetSQLFil( "TNC" )
				If lCposRec .And. !Empty( cREC ) //Caso existam os campos de recibo no dicionário de dados e o recibo esteja preenchido
					cQryCAT += " AND TNC.TNC_RECIBO = " + ValToSQL( cREC )
				Else
					cQryCAT += " AND TNC.TNC_CATINS = " + ValToSQL( cCAT )
				EndIf
				cQryCAT += " AND TNC.TNC_CID <> " + ValToSQL( cCID )
				cQryCAT += " AND " + RetSQLDel( "TNC" )

				cQryCAT := ChangeQuery( cQryCAT )
				MPSysOpenQuery( cQryCAT, cAliasQry )

				// Se a query corresponder será exibido a mensagem para questionar se deseja replicar as informações para o acidente.
				dbSelectArea( "TNC" )
				dbSetOrder( 1 )
				If dbSeek( xFilial( "TNC" ) + ( cAliasQry )->ACIDENTE )
					If MsgYesNo( STR1266 + cSEQ + STR1267 + AllTrim( TNC->TNC_ACIDEN ) + STR1268 ) //"O registro de Afastamento (" //") está relacionado ao Acidente "//", deseja replicar as informações para este?"
						RecLock( "TNC", .F. )
						TNC->TNC_CID := cCID
						If !Empty( TNC->TNC_GRPCID ) .And. TNC->TNC_GRPCID <> Substr( cCID, 1, 3 )
							TNC->TNC_GRPCID := Space( Len( TNC->TNC_GRPCID ) )
						EndIf
						MsUnLock()
					EndIf
				EndIf

				//Fecha a tabela temporária
				( cAliasQry )->( dbCloseArea() )

			EndIf
		EndIf
	EndIf

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTCCFunc
 Função que verifica o Centro de Custo do Funcionário em uma data especifica.


 @Obs Uso MDTUTIL - MdtMovEst | MDTA695 - MdtMovSA

@param cMatricula - Matricula atual do funcionário
@param cCenCusto  - Centro de custo atual do funcionário
@param dDtPesq    - Data de pesquisa que deseja consultar

@author Guilherme Benkendorf
@since 11/09/2015
@version 1.0
@return cRetCC
/*/
//---------------------------------------------------------------------
Function MDTCCFunc( cMatricula , cCenCusto , dDtPesq )

	Local cKeyEmp
	Local cKeyFil
	Local cKeyMat
	Local cRetCC

	Local lComparCTT := FWModeAccess("CTT") == "C"
	Local lRet := .F.

	dbSelectArea("SRA")
	dbSetOrder( 1 )
	dbSeek( xFilial( "SRA" ) + cMatricula )

	dbSelectArea( "SRE" )
	dbSetOrder( 2 )//RE_EMPP+RE_FILIALP+RE_MATP

	cKeyEmp := PadR( cEmpAnt        , Len(SRE->RE_EMPP))
	cKeyFil := PadR( SRA->RA_FILIAL , Len( SRE->RE_FILIALP ))
	cKeyMat := PadR( SRA->RA_MAT    , Len(SRE->RE_MATP))
	cRetCC  := PadR( cCenCusto      , Len(SRE->RE_CCP))
	dDtAnt  := CTOD( "" )

	//É posicionado na última tranferencia
	If dbSeek( cKeyEmp + cKeyFil + cKeyMat )
		While SRE->( !Eof() ) .And. cKeyEmp == SRE->RE_EMPP .And. cKeyFil == SRE->RE_FILIALP .And. cKeyMat == SRE->RE_MATP

			lRet := SRE->RE_DATA >= dDtPesq .And. dDtAnt <= dDtPesq

			cKeyEmp := SRE->RE_EMPD
			cKeyFil := SRE->RE_FILIALD
			cKeyMat := SRE->RE_MATD
			dDtAnt  := SRE->RE_DATA

			//Quando a dDtPesq estiver no periodo
			If lRet
				//A empresa for a mesma
				If cKeyEmp == Padr( cEmpAnt , Len( cKeyEmp ) )
					//A Filial ser a mesma
					// Ou se for diferente a Centro de Custo deverá ser compartilhado
					If Padr( cFilAnt , Len(cKeyFil) ) == cKeyFil .Or.;
							( Padr( cFilAnt , Len(cKeyFil) ) <> cKeyFil .And. lComparCTT )

						cRetCC  := SRE->RE_CCD
						Exit
					EndIf
				EndIf
			EndIf
			SRE->( dbSkip() )
		End

	EndIf

Return cRetCC
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTValEst
 Função de validação nos fontes do módulo de Estoque (SIGAEST).

 @Obs Uso MATA240
 @Obs Uso MATA241

@author Guilherme Benkendorf
@since 04/09/2015
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTValEst( cPosicTNF , cFilInt , nChamada )
	Local lRet      := .T.
	Local lIntMdtEst:= SuperGetMv( "MV_NGMDTES" , .F. , ""  ) == "S"
	Local lGeraSA   := SuperGetMv( "MV_NG2SA" , .F. , ""  ) == "S"

	Local aGetArea  := GetArea()

	Local cAliasQry:= ""
	Local cFilialAux:= ""

	Default nChamada := 1
	Default cFilInt  := ""

	If lIntMdtEst .And. ValType( cPosicTNF ) == "C" .And. !Empty( cPosicTNF )

		If nChamada == 1//MATA240/MATA241
			cAliasQry := TNFQrySD3( cPosicTNF , cFilInt )

			If Select( cAliasQry ) > 0 .And. ( cAliasQry )->TNF_RECNO > 0
				dbSelectArea("TNF")
				dbGoTo( ( cAliasQry )->TNF_RECNO )

				lRet := NG695EXCC( , .T. )

			EndIf

			(cAliasQry)->( dbCloseArea() )
		ElseIf nChamada == 2 .And. lGeraSA//MATA185

			cFilialAux := If( !Empty( cFilInt ) , cFilInt , "" )
			dbSelectArea( "TNF" )
			dbSetOrder( 6 ) //TNF_FILIAL+TNF_NUMSA+TNF_ITEMSA
			If dbSeek( xFilial( "TNF" , cFilialAux ) + cPosicTNF )
				lRet := NG695EXCC( , .T. )
			EndIf

		EndIf
	EndIf

	RestArea( aGetArea )

Return lRet
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTAtuEst
 Função de atualização das tabelas (TNF) em ações do módulo de Estoque (SIGAEST).

 @Obs Uso MATA240 - a240DesAtu

@author Guilherme Benkendorf
@since 09/09/2015
/*/
//---------------------------------------------------------------------
Function MDTAtuEst( cPosicTNF , cFilInt )

	Local aAreaAux  := GetArea()
	Local lRet      := .T.
	Local lGeraSA   := SuperGetMv( 'MV_NG2SA' , .F. , ''  ) == 'S'

	Local lCallEs240:= IsInCallStack( 'MATA240' ) .Or. IsInCallStack( 'MATA241' )
	Local lCallEs185:= IsInCallStack( 'MATA185' ) .And. lGeraSA

	Local cAliasQry:= ''

	Default cFilInt  := ''

	// Verifica se foi passado conteúdo no cPosicTNF
	If ValType( cPosicTNF ) == 'C' .And. !Empty( cPosicTNF )

		If lCallEs240 .Or. lCallEs185
			// Cria TRB com TNFQrySD3, conforme parametros, para depois buscar
			// a TNF correspondente e alterar seu status, caracterizando o estorno.
			cAliasQry := TNFQrySD3( cPosicTNF ,cFilInt )

			If Select( cAliasQry ) > 0 .And. ( cAliasQry )->TNF_RECNO > 0
				dbSelectArea('TNF')
				dbGoTo( ( cAliasQry )->TNF_RECNO )

				RecLock( 'TNF' , .F. )

				If lCallEs185
					TNF->TNF_QTDEVO := SCP->CP_QUANT // Quantidade dev.
					TNF->TNF_INDDEV := '1' // Situação EPI
					TNF->TNF_DTDEVO := dDataBase // Data dev.
					TNF->TNF_LOCDV := SCP->CP_LOCAL // Armazem dev
					TNF->TNF_TIPODV := '1' // Repor estoq.
				Else
					TNF->TNF_QTDEVO := SD3->D3_QUANT // Quantidade dev.
					TNF->TNF_INDDEV := '1' // Situação EPI
					TNF->TNF_DTDEVO := dDataBase // Data dev.
					TNF->TNF_LOCDV := SD3->D3_LOCAL // Armazem dev
					TNF->TNF_TIPODV := '1' // Repor estoq.
				EndIf

				MsUnLock()

			EndIf

			(cAliasQry)->( dbCloseArea() )

		EndIf

	EndIf

	RestArea( aAreaAux )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} TNFQrySD3
 Função para retornar Alias da tabela temporaria. Sua estrutura é formada
 pelo campo TNF_RECNO, que possui o Recno referente ao relacionamento da
 SD3. Que por sua vez, é passada a chave relacional pelos parametros

@Obs Uso MDTUTIL - MDTValEst

@param cNumSeqSD3 Caracter Número da sequencia da SD3 obrigatório
@param cFilialSD3 Caracter Código da filial da SD3 não obrigatório

@author Guilherme Benkendorf
@since 09/09/2015
@version 1.0

@return cAliasQry Caracter Alias da tabela temporaria.
/*/
//---------------------------------------------------------------------
Function TNFQrySD3( cNumSeqSD3 , cFilialSD3 )

	Local cQryAux
	Local cAliasQry := GetNextAlias()

	cQryAux := " SELECT DISTINCT( TNF.R_E_C_N_O_ ) AS TNF_RECNO FROM" + RetSQLTab( "TNF" )
	cQryAux += " JOIN " + RetSQLTab( "SD3" )
	cQryAux += " ON TNF.TNF_NUMSEQ = " + ValToSql( cNumSeqSD3 )
	cQryAux += " AND " + RetSQLDel( "SD3" )

	If ValType( cFilialSD3 ) == "C" .And. !Empty( cFilialSD3 )
		cQryAux += " AND SD3.D3_FILIAL = " + ValToSql( cFilialSD3 )
		cQryAux += " WHERE TNF.TNF_FILIAL = " + ValToSql( xFilial( "TNF" , cFilialSD3 ) )
	Else
		cQryAux += " AND " + RetSQLFil( "SD3" )
		cQryAux += " WHERE " + RetSQLFil( "TNF" )
	EndIf

	cQryAux += " AND " + RetSQLDel( "TNF" )

	cQryAux := ChangeQuery( cQryAux )
	MPSysOpenQuery( cQryAux , cAliasQry )

Return cAliasQry

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTRiscPerc
Retorna o Tipo e o Percentual Máximo de Exposição a Insalubridade e
Periculosidade de um Funcionário

@param cMatricula Obrigatório Matricula do Funcionário
@param dDataMov Opcional Data em que ocorreu a Movimentação
@param cCusto Opcional Código do Centro de Custo
@param cFuncao Opcional Código da Função
@param cDepto Opcional Código do Departamento
@param cFilFun Opcional Filial do Funcionário
@param nOpcRet Opcional Indica o tipo de retorno do adicional
						(0 - Maior; 1 - Insalubridade; 2 - Periculosidade)

@sample MDTRiscPerc('0000001')

@return aPercent Array Array bidimensional indicando o Tipo de Exposição ( 1 -Insalubridade e 2 - Periculosidade ) e o Percentual

@Obs Uso SIGAGPE

@author Jackson Machado
@since 12/05/2016
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTRiscPerc( cMatricula , dDataMov , cCusto , cFuncao , cDepto , cFilFun , nOpcRet )

	Local aValFix	:= {}
	Local aPercent := { 0 , 0 }
	Local lDepto    := NGCADICBASE( "TN0_DEPTO", "A" , "TN0" , .F. )

	Default dDataMov 	:= dDataBase
	Default cCusto		:= ""
	Default cFuncao		:= ""
	Default cDepto		:= ""
	Default cFilFun		:= ""
	Default nOpcRet		:= 0

	//Verifica se as informações do funcionário foram passadas, se alguma não foi, considera tudo como atual
	If Empty( cCusto ) .or. Empty( cFuncao ) .or. ( lDepto .And. Empty( cDepto ) )
		cCusto		:= ""
		cFuncao		:= ""
		cDepto		:= ""
		dDataMov	:= dDataBase
	Else
		aAdd( aValFix, cCusto  )
		aAdd( aValFix, cFuncao )
		aAdd( aValFix, cDepto  )
	EndIf

	dbSelectArea( "TN0" )
	MDTRetRis( dDataMov , /*cNumFic*/ , /*cNatExa*/ , ;
		{ | | MDTAdicPerc( @aPercent , nOpcRet ) } , ;
				/*cVal*/ , /*aTabTar*/ , .T. , .F. ,.F., Len( aValFix ) > 0, aValFix )


Return aPercent
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTAdicPerc
Função auxiliar para buscar o adicional

@param aPercent Array Array bidimensional indicando o Tipo de
						Exposição ( 1 -Insalubridade e 2 - Periculosidade ) e o Percentual
@param nOpcRet Opcional Indica o tipo de retorno do adicional
						(0 - Maior; 1 - Insalubridade; 2 - Periculosidade)

@sample MDTRiscPerc( { 0 , 0 } )

@Obs Uso MDTRiscPerc

@author Jackson Machado
@since 12/05/2016
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTAdicPerc( aPercent , nOpcRet )

	Local nTipRAdc	:= 0
	Local nPercRis	:= 0
	Local nPercent	:= aPercent[ 2 ]
	Local cAgeTipo	:= ""

	//Variaveis de Backup
	Local aArea		:= GetArea()
	Local aAreaTMA	:= TMA->( GetArea() )
	Local aAreaTN0	:= TN0->( GetArea() )

	Default nOpcRet := 0

	cRisInt := TN0->TN0_PERINT //Intensidade do risco 1-10% 2-20% 3-30% 4-40% 5-Não caracteriza
	cRisPer := TN0->TN0_ATIPER //Risco  1-Não periculoso 2-Periculoso
	cRisIns := TN0->TN0_ATISAL //Risco  1- Salubre 2-Insalubre
	cRisAge := TN0->TN0_AGENTE

	DbSelectArea("TMA")
	DbSetOrder(1) //TMA_FILIAL+TMA_AGENTE
	If DbSeek( xFilial("TMA") + cRisAge )
		If !Empty( TMA->TMA_TIPADI ) //1-Insalubridade 2-Periculosidade
			cAgeTipo := TMA->TMA_TIPADI
		EndIf
	EndIf

	//Trata os valores de Intensidade
	If cAgeTipo == "1" .And. ( nOpcRet == 0 .Or. nOpcRet == 1 ) //Agente insalubre
		Do Case
		Case cRisIns == "1" //Salubre

			nTipRAdc := 0
			nPercRis := 0

		Case cRisIns == "2" //Insalubre
			nTipRAdc := 1
			If cRisInt == "1"
				nPercRis := 10 //Leve - 10%
			ElseIf cRisInt == "2"
				nPercRis := 20 //Média - 20%
			ElseIf cRisInt == "4"
				nPercRis := 40 //Alta - 40%
			ElseIf cRisInt == "5"
				nPercRis := 0 //Não tem % de intensidade
			EndIf

		EndCase
	ElseIf cAgeTipo == "2" .And. ( nOpcRet == 0 .Or. nOpcRet == 2 ) //Agente periculoso
		Do Case
		Case cRisPer == "1" //Não periculoso

			nTipRAdc := 0
			nPercRis := 0

		Case cRisPer == "2" //Periculoso
			nTipRAdc := 2
			If cRisInt == "3"
				nPercRis := 30 //Sim - 30%
			ElseIf cRisInt == "5"
				nPercRis := 0 //Não
			EndIf

		EndCase
	EndIf

	If nPercRis > nPercent
		aPercent[ 1 ] := nTipRAdc
		aPercent[ 2 ] := nPercRis
	EndIf

	RestArea( aAreaTN0 )
	RestArea( aAreaTMA )
	RestArea( aArea )
Return
//---------------------------------------------------------------------
/*/{Protheus.doc} MDTFILDEP
 Realiza filtro da consulta padrao MDTSQB

@Obs Uso - XB_COLUNA = 6 do Alias MDTSQB

@author Guilherme Benkendorf
@since 22/10/2015
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTFilDEP()
	Local cFiltro  := ""
	Local cMemoryCC:= ""
	Local lCallRis := IsInCallStack( "MDTA180" )
	Local lCallASO := IsInCallStack( "MDTA200" )
	Local lCallFic := IsInCallStack( "MDTA410" ) .Or. IsInCallStack( "MDTA005" )
	Local lCallArv := IsInCallStack( "MNTA902" )
	Local lCallPET := IsInCallStack( "MDTA992" )
	Local lCallOS  := IsInCallStack( "MDTA305" )
	Local lCallTYA := IsInCallStack( "MDTA166" )

	Do Case
	Case lCallRis ; cMemoryCC := M->TN0_CC
	Case lCallASO ; cMemoryCC := M->TMY_NOVCC
	Case lCallFic ; cMemoryCC := M->TM0_CC
	Case lCallArv ; cMemoryCC := M->TAF_CCUSTO
	Case lCallPET ; cMemoryCC := M->TI0_CCUSTO
	Case lCallOS  ; cMemoryCC := M->TOB_CC
	Case lCallTYA ; cMemoryCC := M->TYA_CC
	End Case

	If !Empty( cMemoryCC )
		If lCallRis
			If AllTrim( cMemoryCC ) <> "*" //Todos
				If AllTrim( cMemoryCC ) <> "#"
					cFiltro := "SQB->QB_CC == '" + Padr(cMemoryCC, Len(SQB->QB_CC))+ "' .OR. Empty(SQB->QB_CC)"
				Else
					MDT180Fil( 2 , .T. , @cFiltro )
				EndIf
			EndIf
		Else
			cFiltro := "SQB->QB_CC == '" + Padr(cMemoryCC, Len(SQB->QB_CC))+ "' .OR. Empty(SQB->QB_CC)"
		EndIf
	EndIf

Return "@#" + cFiltro + "@#"
//-------------------------------------------------------------------
/*/{Protheus.doc} MDTExCAGED
Realiza a busca dos exames para Integração com o CAGED (SIGAGPE)
Calculos e buscas realizados conforme portarias:
Portaria MTPS Nº 116 DE 13/11/2015
Portaria Nº 945, de 1º DE Agosto DE 2017

@param  cFilFun, Caracter, Filial do Funcionário
@param  cMatric, Caracter, Matrícula do Funcionário
@param  dDtGera, Date, Data que servirá como base da geração
@param  cTipExa, Caracter, Tipo do Exame (1-Admissional,2-Demissional)
@param  nNvTransf, Number, Indica o nível de avaliação de transferência. 1 - Inicial, 2 - Segunda, 3 - Último

@return aReturn, Array, Array com as Informações:
						[n] Exame Realizado
							[1] Código do Exame no DENATRAN
							[2] Data Programada do Exame
							[3] Data Realização do Exame
							[4] CNPJ do Laboratório
							[5] U.F. do Médico Realizador
							[6] Código da Entidade de Classe do Médico (CRM)


@sample  MDTExCAGED( "D MG 01 ", "000001", SToD("20170208"), "1" )
@author  Jackson Machado
@since   02/08/2017
/*/
//-------------------------------------------------------------------
Function MDTExCAGED( cFilFun, cMatric, dDtGera, cTipExa , nNvTransf )

	Local nHist     := 0
	Local cCGCFor	:= "", cUFMed := "", cCRMMed := ""
	Local cQryAls 	:= GetNextAlias()
	Local aSM0		:= FwLoadSM0()
	Local nFil		:= aScan( aSM0 , { | x | x[ 1 ] == cEmpAnt .ANd. x[ 2 ] == cFilAnt } )
	Local cCGC		:= If( nFil > 0 , aSM0[ nFil , 18 ] , "" )
	Local cUFEmp	:= If( nFil > 0 , SubStr(AllTrim(aSM0[ nFil , 22 ]),-2) , "" )
	Local nSizeFil  := FwSizeFilial()

	Local dIniPer 	:= DaySub(dDtGera,90)//Deve-se buscar os exames realizados até 60 dias antes
	Local dFimPer 	:= dDtGera
	Local aReturn 	:= {}
	Local cTM4Fil	:= ""
	Local cSA2Fil	:= ""
	Local cTNPFil	:= ""
	Local cTM5Fil	:= ""
	Local cOldFil   := cFilAnt
	Local cOldEmp   := cEmpAnt

	Local aArea     := GetArea()
	Local aAreaSRA  := SRA->( GetArea() )
	Local cFilTrans := ""
	// Alias reais de Execução
	Local cAlsTM5   := "%" + RetFullName( "TM5", cEmpAnt ) + "%"
	Local cAlsTM0   := "%" + RetFullName( "TM0", cEmpAnt ) + "%"
	Local cAlsSA2   := "%" + RetFullName( "SA2", cEmpAnt ) + "%"
	Local cAlsTM4   := "%" + RetFullName( "TM4", cEmpAnt ) + "%"
	Local cAlsTNP   := "%" + RetFullName( "TNP", cEmpAnt ) + "%"

	Default nNvTransf := 1

	dbSelectArea( "SRA" )
	dbSetOrder( 1 )
	dbSeek( xFilial( "SRA" , cFilFun ) + cMatric )

	If nNvTransf == 2
		//Busca todo o histórico de Transferência do Funcionário
		aHist := fSrchHist()
		aSort( aHist, , , {|x,y| x[1] < y[1] } )

		//Percorre todas as filiais onde o funcionário estava para verificar se encontra o exame
		While Len( aReturn ) == 0 .And. nHist < Len( aHist )
			nHist++
			cFilTrans :=  SubStr( aHist[ nHist, 3 ], 1, FwSizeFilial() )
			If cEmpAnt <> aHist[ nHist, 6 ]
				NGPrepTBL({ {"TM4"}, {"SA2"}, {"TNP"}, {"TM5"} },aHist[ nHist, 6 ],cFilTrans)
				cEmpAnt := aHist[ nHist, 6 ]
			ElseIf cFilAnt <> cFilTrans
				cFilAnt := cFilTrans
			EndIf

			nNvTransf += 1
			aReturn := MDTExCAGED( cFilTrans, aHist[ nHist , 4 ], dDtGera, cTipExa, nNvTransf )
			nNvTransf -= 1

			If cOldEmp <> cEmpAnt
				NGPrepTBL({ {"TM4"}, {"SA2"}, {"TNP"}, {"TM5"} },cOldEmp,cOldFil)
				cEmpAnt := cOldEmp
			ElseIf cOldFil <> cFilAnt
				cFilAnt := cOldFil
			EndIf
		End

		//Força a saída da função com o último retorno
		cFilFun := ""
		cMatric := ""

	EndIf

	If !Empty( cFilFun ) .And. !Empty( cMatric )
		cTM4Fil	:= xFilial("TM4",cFilFun)
		cSA2Fil	:= xFilial("SA2",cFilFun)
		cTNPFil	:= xFilial("TNP",cFilFun)
		cTM5Fil	:= xFilial("TM5",cFilFun)

		BeginSQL Alias cQryAls
			SELECT TM5.TM5_CODDET, TM5.TM5_DTPROG, TM5.TM5_DTRESU,
				SA2.A2_CGC,TNP.TNP_UF,TNP.TNP_NUMENT
				FROM %exp:cAlsTM5% TM5
					JOIN %exp:cAlsTM0% TM0 ON	TM0.TM0_NUMFIC	= TM5.TM5_NUMFIC AND
										TM0.TM0_FILIAL		= TM5.TM5_FILIAL AND
										TM0.TM0_MAT			= %exp:cMatric% AND
										TM0.TM0_FILFUN		= %exp:cFilFun% AND
										TM0.%notDel%
					JOIN %exp:cAlsTM4% TM4 ON	TM4.TM4_EXAME 	= TM5.TM5_EXAME AND
										TM4.TM4_FILIAL		= %exp:cTM4Fil% AND
										TM4.%notDel%
					LEFT JOIN %exp:cAlsSA2% SA2 ON	SA2.A2_COD		= TM5.TM5_FORNEC AND
										SA2.A2_LOJA			= TM5.TM5_LOJA AND
										SA2.A2_FILIAL		= %exp:cSA2Fil% AND
										SA2.%notDel%
					LEFT JOIN %exp:cAlsTNP% TNP ON	TNP.TNP_EMITEN	= TM5.TM5_USUARI AND
										TNP.TNP_FILIAL		= %exp:cTNPFil% AND
										TNP.%notDel%
			WHERE 	TM5.TM5_FILIAL = %exp:cTM5Fil% AND
					TM5.TM5_CODDET <> ' ' AND
					TM5.TM5_ORIGEX = '1' AND
					TM5.%notDel%
		EndSQL

		//Prcessa a Tabela Temporaria para adicionar valores no retorno
		dbSelectArea( cQryAls )
		While ( cQryAls )->( !EoF() )

			cCGCFor := ( cQryAls )->A2_CGC
			cUFMed	:= ( cQryAls )->TNP_UF
			cCRMMed	:= ( cQryAls )->TNP_NUMENT

			//Se o exame estiver pendente ou recusado, assume os valores padrões.
			If "PENDENTE" $ ( cQryAls )->TM5_CODDET .Or. "RECUSA" $ ( cQryAls )->TM5_CODDET
				cCRMMed := "0000000001"
				cUFMed	:= cUFEmp
				If "RECUSA" $ ( cQryAls )->TM5_CODDET
					cCGCFor := cCGC
				EndIf
				If Empty((cQryAls)->TM5_DTPROG) .Or. ;
						SToD( (cQryAls)->TM5_DTPROG ) < dIniPer .Or. ;
						SToD( (cQryAls)->TM5_DTPROG ) > dFimPer
					(cQryAls)->(dbSkip())
					Loop
				EndIf
			Else
				//Filtra os exames realizados até 60 antes da data de geração do CAGED
				If Empty((cQryAls)->TM5_DTRESU) .Or. ;
						SToD( (cQryAls)->TM5_DTRESU ) < dIniPer
					(cQryAls)->(dbSkip())
					Loop
				EndIf
			EndIf

			If !Empty( cCGCFor ) .And. !Empty( cUFMed ) .And. !Empty( cCRMMed )
				aAdd( aReturn, { ;
					( cQryAls )->TM5_CODDET, ;
					( cQryAls )->TM5_DTPROG, ;
					( cQryAls )->TM5_DTRESU, ;
					cCGCFor, ;
					cUFMed, ;
					cCRMMed ;
					} )
			EndIf

			( cQryAls )->( dbSkip() )
		End

		// Caso não tenha localizado um exame, realiza novamente a busca, avaliando a transferência
		If Len( aReturn ) == 0 .And. nNvTransf == 1
			nNvTransf += 1
			aReturn := aClone( MDTExCAGED( cFilFun, cMatric, dDtGera, cTipExa , nNvTransf ) )
			nNvTransf -= 1
		EndIf

		aSort( aReturn, , , {|x,y| x[3] > y[3] } )

		( cQryAls )->( dbCloseArea() )
	EndIf

	RestArea( aAreaSRA )
	RestArea( aArea )

Return aReturn
//-------------------------------------------------------------------
/*/{Protheus.doc} fSrchHist
Busca o Histórico completo do Funcionário

@author  Jackson Machado
@since   07/02/2019
@obs Esta função foi uma copia simples da contida no MDTR700
/*/
//-------------------------------------------------------------------
Static Function fSrchHist()

	Local dFIMPPP     := dDataBase
	Local lFimPPP     := .F. // Verifica se acabou o historico de setores
	Local cKeyEmp     := SM0->M0_CODIGO // Empresa origem
	Local nSizeSRE    := If(TAMSX3("RE_FILIALD")[1] > 0, TAMSX3("RE_FILIALD")[1], Len(SRE->RE_FILIALD))
	Local cKeyFil     := Padr(SRA->RA_FILIAL,nSizeSRE)// Filial origem
	Local cKeyMat     := SRA->RA_MAT // Matricula origem
	Local cKeyCus     := SRA->RA_CC // Centro Custo origem
	Local cKeyDep     := SRA->RA_DEPTO // Departamento origem
	Local dINITMP     := SRA->RA_ADMISSA //Data Admissao
	Local cCondCus    := Space(Len(SRA->RA_CC))
	Local cCondDep    := Space(Len(SRA->RA_DEPTO))
	Local cCondALL    := Space(10)
	Local lFirstSRE   := .T. //Indica se eh o primeiro SRE
	Local lFirst      := .T.
	Local lAchouSRE   := .F.
	Local nTotRegPPP  := 0,nRegPPP := 0
	Local lPrimeiro   := .T.
	Local _dFimPPP    := ctod("  /  /  ")
	Local aHistory    := {}
	Local aDadosTmp    := {}
	Local dDataSRE    := CTOD("")

	While !lFimPPP
		lPrimeiro := .T.
		_dFimPPP  := ctod("  /  /  ")
		cCondCus  := cKeyCus
		cCondDep  := cKeyDep
		cCondALL  := cKeyEmp + cKeyFil + cKeyMat

		dbSelectArea("SRE")
		dbSetOrder(1)
		dbSeek(cCondALL)

		While !Eof() .And. cCondALL == SRE->RE_EMPD+SRE->RE_FILIALD+SRE->RE_MATD

			If SRE->RE_DATA < dDataSRE
				dbSelectArea("SRE")
				dbSkip()
				Loop
			EndIf

			If SRE->RE_EMPP == SRE->RE_EMPD .And. SRE->RE_FILIALP == SRE->RE_FILIALD .And. ;
					SRE->RE_MATP == SRE->RE_MATD .And. SRE->RE_CCP == SRE->RE_CCD .And. SRE->RE_DEPTOP == SRE->RE_DEPTOD
				dbSelectArea("SRE")
				dbSkip()
				Loop
			EndIf

			If (If(lFirstSRE,SRE->RE_DATA > dDataBase,SRE->RE_DATA >= dDataBase)) .Or. ;
					SRE->RE_DATA < dINITMP
				dbSelectArea("SRE")
				dbSkip()
				Loop
			EndIf

			If Alltrim(SRE->RE_CCD) <> Alltrim(cCondCus) .Or. (Alltrim(SRE->RE_DEPTOD) <> Alltrim(cCondDep) )
				dbSelectArea("SRE")
				dbSkip()
				Loop
			EndIf

			lFirstSRE := .F.

			If lPrimeiro
				dDataSRE := SRE->RE_DATA
				cKeyEmp := SRE->RE_EMPP
				cKeyFil := SRE->RE_FILIALP

				cKeyMat := SRE->RE_MATP
				cKeyCus := SRE->RE_CCP
				cKeyDep := SRE->RE_DEPTOP
				aADD(aDadosTmp,{SRE->RE_DATA,dDataBase,SRE->RE_FILIALD,SRE->RE_MATD,SRE->RE_CCD,SRE->RE_EMPD,SRE->RE_DEPTOD})
				_dFimPPP := SRE->RE_DATA

			ElseIf SRE->RE_DATA < aDadosTmp[Len(aDadosTmp)][1]

				dDataSRE := SRE->RE_DATA
				cKeyEmp := SRE->RE_EMPP
				cKeyFil := SRE->RE_FILIALP

				cKeyMat := SRE->RE_MATP
				cKeyCus := SRE->RE_CCP
				cKeyDep := SRE->RE_DEPTOD
				aDadosTmp[Len(aDadosTmp)][1] := SRE->RE_DATA
				_dFimPPP := SRE->RE_DATA

			EndIf

			lPrimeiro := .F.

			dbSelectArea("SRE")
			dbSkip()
		End

		If lPrimeiro
			lFimPPP := .T.

			If dINITMP < dFIMPPP
				aAdd(aDadosTmp,{dINITMP,dFIMPPP,cKeyFil,cKeyMat,cKeyCus,cKeyEmp,cKeyDep})
			EndIf

		Else
			dFimPPP := _dFimPPP
		EndIf

	End

	If Len(aDadosTmp) > 0
		aSRArea := SRA->(GetArea())
		cKeyEmp := aDadosTmp[Len(aDadosTmp),6] // Empresa origem
		cKeyFil := aDadosTmp[Len(aDadosTmp),3] // Filial origem
		cKeyMat := aDadosTmp[Len(aDadosTmp),4] // Matricula origem
		cKeyCus := aDadosTmp[Len(aDadosTmp),5] // Centro Custo origem
		cKeyDep := aDadosTmp[Len(aDadosTmp),7] // Departamento origem
		dFIMPPP := dDataBase
		RestArea(aSRArea)
	EndIf

	//------------------------------------------------------------------------
	// Busca informações do funcionario quando transferido para outro empresa
	//------------------------------------------------------------------------
	lFirstSRE := .T.
	lFimPPP   := .F.

	While !lFimPPP
		lPrimeiro := .T.
		_dFimPPP  := ctod("  /  /  ")
		cCondCus  := cKeyCus
		cCondDep  := cKeyDep
		cCondALL  := cKeyEmp + cKeyFil + cKeyMat
		dbSelectArea("SRE")
		dbSetOrder(2)
		dbSeek(cCondALL)

		While !Eof() .And. cCondALL == SRE->RE_EMPP + SRE->RE_FILIALP + SRE->RE_MATP

			If SRE->RE_EMPP == SRE->RE_EMPD .And. SRE->RE_FILIALP == SRE->RE_FILIALD .And. ;
					SRE->RE_MATP == SRE->RE_MATD .And. SRE->RE_CCP == SRE->RE_CCD .And. SRE->RE_DEPTOP == SRE->RE_DEPTOD
				dbSelectArea("SRE")
				dbSkip()
				Loop
			EndIf

			If (If(lFirstSRE,SRE->RE_DATA > dFIMPPP,SRE->RE_DATA >= dFIMPPP)) .Or. ;
					SRE->RE_DATA < dINITMP
				dbSelectArea("SRE")
				dbSkip()
				Loop
			EndIf

			If Alltrim(SRE->RE_CCP) <> Alltrim(cCondCus) .Or. ( Alltrim(SRE->RE_DEPTOP) <> Alltrim(cCondDep) )
				dbSelectArea("SRE")
				dbSkip()
				Loop
			EndIf

			lFirstSRE := .F.

			If lPrimeiro

				cKeyEmp := SRE->RE_EMPD
				cKeyFil := SRE->RE_FILIALD
				cKeyMat := SRE->RE_MATD
				cKeyCus := SRE->RE_CCD
				cKeyDep := SRE->RE_DEPTOD
				aAdd(aHistory,{SRE->RE_DATA,dFimPPP,SRE->RE_FILIALP,SRE->RE_MATP,SRE->RE_CCP,SRE->RE_EMPP,SRE->RE_DEPTOP})
				_dFimPPP := SRE->RE_DATA

			ElseIf SRE->RE_DATA > aHistory[Len(aHistory)][1]

				cKeyEmp := SRE->RE_EMPD
				cKeyFil := SRE->RE_FILIALD
				cKeyMat := SRE->RE_MATD
				cKeyCus := SRE->RE_CCD
				cKeyDep := SRE->RE_DEPTOD
				aHistory[Len(aHistory)][1] := SRE->RE_DATA
				_dFimPPP := SRE->RE_DATA

			EndIf

			lPrimeiro := .F.

			dbSelectArea("SRE")
			dbSkip()
		End

		If lPrimeiro
			lFimPPP := .T.

			If dINITMP < dFimPPP
				aAdd(aHistory,{dINITMP,dFimPPP,cKeyFil,cKeyMat,cKeyCus,cKeyEmp,cKeyDep})
			EndIf

		Else
			dFimPPP := _dFimPPP
		EndIf

	End

Return aHistory
//-------------------------------------------------------------------
/*/{Protheus.doc} fAjusteTNH
Ajusta registros da tabela de Objeto Causador

@type function

@param cAliasTNH, Caracter, Alias Temporário da TNH

@author  Jackson Machado
@since   19/06/2019
/*/
//-------------------------------------------------------------------
Static Function fAjusteTNH( cAliasTNH )

	dbSelectArea( cAliasTNH )
	While ( cAliasTNH )->( !EoF() )
		dbSelectArea( "TNH" )
		dbSetOrder( 1 )
		If dbSeek( ( cAliasTNH )->TNH_FILIAL + ( cAliasTNH )->TNH_CODOBJ )
			RecLock( "TNH", .F. )
			TNH->TNH_ESOC  := TNH->TNH_ESOC1
			TNH->TNH_ESOC1 := Space( Len( TNH->TNH_ESOC1 ) )
			TNH->( MsUnLock() )
		EndIf
		( cAliasTNH )->( dbSkip() )
	End
Return
//-------------------------------------------------------------------
/*/{Protheus.doc} fAjusteTMJ
A função corrige os registros da agenda de consultas médicas (TMJ).
Em casos em que registros tenham sido adicionados sem horário de início
(TMJ_HRCONS) por causa de um erro de produto, a função joga as consultas
para a meia noite do mesmo dia e do mesmo médico, ou no próximo horário
disponível. Se não há horários disponíveis tenta encaixar na primira
consulta que tenha duração maior que 10 minutos. Se não houver nenhum
lugar para encaixe, o registro é excluído. O campo também é atualizado
nas tabelas relacionadas.
Em casos em que o registro não possua numero da ficha médica o registro
é excluído.
Em casos de registros com tempo de duração (TMJ_QTDHRS) igual a 00:00,
é alterado para 5 minutos.

@return .T.

@param cTMJFil, caracter, Filial da Tabela TMJ

@sample  fAjusteTMJ( "SGC000001" )

@author  Julia Kondlatsch
@since   02/01/2018
/*/
//-------------------------------------------------------------------
Static Function fAjusteTMJ( cTMJFil )

	Local cQryTMJ	:= GetNextAlias()
	Local cDelTMJ	:= GetNextAlias()
	Local cUpdTMJ	:= ""
	Local cUpdTMJ3	:= ""
	Local cUpdTMT 	:= ""
	Local cUpdTM2 	:= ""
	Local cUpdTNY 	:= ""
	Local cUpdTKJ 	:= ""
	Local cNovoHor	:= "00:00"
	Local lMeiaNoi	:= .T. // Se está vago meia noite
	Local lTemHor	:= .F. // Se existe horário no memso dia para transferir o funcionário, que não seja meia noite.
	Local lEncaixe 	:= .F. // Se está tudo cheio mas dá para encaixar em algum horário
	Local cFuncEnc	:= ""  //Ficha do funcionário de encaixe
	Local cHrFuEnc	:= ""  //Horario do atendimento funcionário de encaixe
	Local cNovaDur	:= ""  //Nova duração do atendimento do funcionario de encaixe (-5 min)
	Local cHrFim	:= ""  //Hora final da consulta
	Local cFimAnter	:= ""  //Hora Final da consulta anterior
	Local cInterv	:= ""  //Intervalo entre horários

	//-------------------------------Registros sem ficha médica-------------------------------

	BeginSQL Alias cDelTMJ
		SELECT TMJ.TMJ_FILIAL, TMJ.TMJ_CODUSU, TMJ.TMJ_DTCONS, TMJ.TMJ_HRCONS, TMJ.TMJ_NUMFIC
			FROM %table:TMJ% TMJ
		WHERE
			TMJ.TMJ_FILIAL = %exp:cTMJFil% AND
			TMJ.%notDel% AND
			TMJ.TMJ_NUMFIC = ''
	EndSQL

	dbSelectArea( "TMJ" ) //Agenda de Atendimento Médico
	dbSetOrder( 1 ) //TMJ_FILIAL +TMJ_CODUSU + TMJ_DTCONS + TMJ_HRCONS
	While ( cDelTMJ )->( !EoF() )
		If dbSeek( (cDelTMJ)->TMJ_FILIAL + (cDelTMJ)->TMJ_CODUSU + (cDelTMJ)->TMJ_DTCONS + (cDelTMJ)->TMJ_HRCONS)
			RecLock( "TMJ", .F. )
			TMJ->( dbDelete() )
			TMJ->( MsUnLock() )
		EndIf
		( cDelTMJ )->( dbSkip() )
	End

	( cDelTMJ )->( dbCloseArea() )

	//-------------------------------Registros sem horário de atendimento-------------------------------

	BeginSQL Alias cQryTMJ
		SELECT TMJ.TMJ_FILIAL, TMJ.TMJ_CODUSU, TMJ.TMJ_DTCONS, TMJ.TMJ_HRCONS, TMJ.TMJ_NUMFIC
			FROM %table:TMJ% TMJ
		WHERE
			TMJ.TMJ_FILIAL = %exp:cTMJFil% AND
			TMJ.%notDel% AND
			TMJ.TMJ_HRCONS = '  :  '
	EndSQL

	While ( cQryTMJ )->( !EoF() )

		//--------------------Define o ajuste a ser feito nos registros--------------------

		lMeiaNoi	:= .T.
		cNovoHor	:= "00:00"
		lTemHor		:= .F.
		lEncaixe 	:= .F.
		cFuncEnc	:= ""
		cNovaDur	:= ""
		cHrFim		:= ""
		cFimAnter	:= ""
		cInterv		:= ""

		dbSelectArea("TMJ")
		dbSetOrder(1) //TMJ_FILIAL +TMJ_CODUSU + TMJ_DTCONS + TMJ_HRCONS
		dbSeek( (cQryTMJ)->TMJ_FILIAL + (cQryTMJ)->TMJ_CODUSU + (cQryTMJ)->TMJ_DTCONS )
		While TMJ->( !EoF() ) .And. TMJ->TMJ_FILIAL == (cQryTMJ)->TMJ_FILIAL .And. TMJ->TMJ_CODUSU == (cQryTMJ)->TMJ_CODUSU;
				.And. TMJ->TMJ_DTCONS == SToD((cQryTMJ)->TMJ_DTCONS)

			If TMJ->TMJ_HRCONS <> (cQryTMJ)->TMJ_HRCONS //Se não for no mesmo horário

				cHrInic := TMJ->TMJ_HRCONS
				cHrFim 	:= MTOH( HTOM( cHrInic ) + HTOM( TMJ->TMJ_QTDHRS ) )

				//Se o horário de meia noite não estiver vago
				If cHrInic == "00:00"
					lMeiaNoi := .F.
				ElseIf lMeiaNoi //Caso já tenha dado falso em outro registro não entra
					cNovoHor := "00:00"
					lTemHor  := .F.
					lEncaixe := .F.
					Exit
				EndIf

				//Subtrai o horario final do anterior com o próximo para verificar se há intervalo entre eles
				If !Empty(cFimAnter)
					cInterv := MTOH( HTOM( cHrInic ) - HTOM( cFimAnter ) )
					If cInterv >= "00:05"
						lTemHor  := .T.
						lEncaixe := .F.
						cNovoHor := cFimAnter
						Exit
					EndIf
				EndIf

				//Verifica se há possibilidade de encaixe de horário
				If TMJ->TMJ_QTDHRS >= "00:10" .And. !lEncaixe
					lEncaixe := .T.
					cNovoHor := MTOH( HTOM( cHrFim ) - HTOM( "00:05" ) )

					cFuncEnc := TMJ->TMJ_NUMFIC
					cHrFuEnc := TMJ->TMJ_HRCONS
					cNovaDur := MTOH( HTOM( TMJ->TMJ_QTDHRS ) - HTOM( "00:05" ) )
				EndIf

				cFimAnter := cHrFim

			EndIf

			TMJ->(dbSkip())

		End

		//A tabelá estará no ultimo registro e é verificado se não há horários disponíveis depois, caso
		//não tenha dado para colocar o fucionário meia noite nem encaixar entre dois horários
		If !lTemHor .And. !lMeiaNoi .And. cHrFim <= "23:59"
			lEncaixe := .F.
			lTemHor  := .T.
			cNovoHor := cHrFim
		EndIf

		//--------------------Atualiza os valores na base--------------------

		If !lMeiaNoi .And. !lTemHor .And. !lEncaixe //Se a ficha médica estiver vazia ou não tiver como transferir
			dbSelectArea("TMJ") //Agenda de Atendimento Médico
			dbSetOrder(1) //TMJ_FILIAL +TMJ_CODUSU + TMJ_DTCONS + TMJ_HRCONS
			If dbSeek( (cQryTMJ)->TMJ_FILIAL + (cQryTMJ)->TMJ_CODUSU + (cQryTMJ)->TMJ_DTCONS + (cQryTMJ)->TMJ_HRCONS )
				RecLock( "TMJ", .F. )
				TMJ->( dbDelete() )
				TMJ->( MsUnLock() )
			EndIf
		Else
			//Modifica o horário e a duração do funcionário sem hora da consulta
			cUpdTMJ := " UPDATE " + RetSqlName( "TMJ" )
			cUpdTMJ += " SET TMJ_HRCONS = '" + cNovoHor + "' ,"
			cUpdTMJ += " TMJ_QTDHRS = '00:05'"
			cUpdTMJ += " WHERE TMJ_FILIAL = '" + cTMJFil + "'"
			cUpdTMJ += " AND TMJ_CODUSU = '" + (cQryTMJ)->TMJ_CODUSU + "'"
			cUpdTMJ += " AND TMJ_DTCONS = '" + (cQryTMJ)->TMJ_DTCONS + "'"
			cUpdTMJ += " AND TMJ_HRCONS = '" + (cQryTMJ)->TMJ_HRCONS + "'"
			cUpdTMJ += " AND TMJ_NUMFIC = '" + (cQryTMJ)->TMJ_NUMFIC + "'"

			TCSQLExec( cUpdTMJ )

			If lEncaixe
				//Modifica duração do atendimento do funcionário de encaixe
				cUpdTMJ2 := " UPDATE " + RetSqlName( "TMJ" )
				cUpdTMJ2 += " SET TMJ_QTDHRS = '" + cNovaDur + "'"
				cUpdTMJ2 += " WHERE TMJ_FILIAL = " + cTMJFil + "'"
				cUpdTMJ2 += " AND TMJ_CODUSU = '" + (cQryTMJ)->TMJ_CODUSU + "'"
				cUpdTMJ2 += " AND TMJ_DTCONS = '" + (cQryTMJ)->TMJ_DTCONS + "'"
				cUpdTMJ2 += " AND TMJ_HRCONS = '" + cHrFuEnc + "'"
				cUpdTMJ2 += " AND TMJ_NUMFIC = '" + cFuncEnc + "'"

				TCSQLExec( cUpdTMJ2 )

			EndIf

		EndIf

		//Diagnóstico
		cUpdTMT := " UPDATE " + RetSqlName( "TMT" )
		cUpdTMT += " SET TMT_HRCONS = '" + cNovoHor + "' ,"
		cUpdTMT += " WHERE TMT_FILIAL = " + cTMJFil + "'"
		cUpdTMT += " AND TMT_NUMFIC = '" + (cQryTMJ)->TMJ_NUMFIC + "'"
		cUpdTMT += " AND TMT_DTCONS = '" + (cQryTMJ)->TMJ_DTCONS + "'"
		cUpdTMT += " AND TMT_HRCONS = '" + (cQryTMJ)->TMJ_HRCONS + "'"

		TCSQLExec( cUpdTMT )

		//Medicamentos Utilizados
		cUpdTM2 := " UPDATE " + RetSqlName( "TM2" )
		cUpdTM2 += " SET TM2_HRCONS = " + cNovoHor + "' ,"
		cUpdTM2 += " WHERE TM2_FILIAL = " + cTMJFil + "'"
		cUpdTM2 += " AND TM2_NUMFIC = '" + (cQryTMJ)->TMJ_NUMFIC + "'"
		cUpdTM2 += " AND TM2_DTCONS = '" + (cQryTMJ)->TMJ_DTCONS + "'"
		cUpdTM2 += " AND TM2_HRCONS = '" + (cQryTMJ)->TMJ_HRCONS + "'"

		TCSQLExec( cUpdTM2 )

		//Atestados Médicos
		cUpdTNY := " UPDATE " + RetSqlName( "TNY" )
		cUpdTNY += " SET TNY_HRCONS = '" + cNovoHor + "' ,"
		cUpdTNY += " WHERE TNY_FILIAL = " + cTMJFil + "'"
		cUpdTNY += " AND TNY_NUMFIC = '" + (cQryTMJ)->TMJ_NUMFIC + "'"
		cUpdTNY += " AND TNY_DTCONS = '" + (cQryTMJ)->TMJ_DTCONS + "'"
		cUpdTNY += " AND TNY_HRCONS = '" + (cQryTMJ)->TMJ_HRCONS + "'"

		TCSQLExec( cUpdTNY )

		//Cid Complementar
		cUpdTKJ := " UPDATE " + RetSqlName( "TKJ" )
		cUpdTKJ += " SET TKJ_HRCONS = '" + cNovoHor + "' ,"
		cUpdTKJ += " WHERE TKJ_FILIAL = " + cTMJFil + "'"
		cUpdTKJ += " AND TKJ_NUMFIC = '" + (cQryTMJ)->TMJ_NUMFIC + "'"
		cUpdTKJ += " AND TKJ_DTCONS = '" + (cQryTMJ)->TMJ_DTCONS + "'"
		cUpdTKJ += " AND TKJ_HRCONS = '" + (cQryTMJ)->TMJ_HRCONS + "'"

		TCSQLExec( cUpdTKJ )

		( cQryTMJ )->(DbSkip())
	End


	( cQryTMJ )->( dbCloseArea() )

	//--------------------Registros sem quantidade de horas de atendimento--------------------

	cUpdTMJ3 := " UPDATE " + RetSqlName( "TMJ" )
	cUpdTMJ3 += " SET TMJ_QTDHRS = '00:05'"
	cUpdTMJ3 += " WHERE TMJ_FILIAL = '" + cTMJFil + "'"
	cUpdTMJ3 += " AND TMJ_QTDHRS = '00:00'"
	cUpdTMJ3 += " OR TMJ_QTDHRS = ''"

	TCSQLExec( cUpdTMJ3 )

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} fMemoTJB
Função para transcrever o conteúdo dos campos tipo caractere antigos
da TJB (Produto químico), para os novos campos do tipo memo. A função
também passa os novos campos para usado e os antigos para não usado.

@author  Julia Kondlatsch
@since   23/04/2018
@param   cAlias, Caractere, Nome do Alias com registros incorretos

@return  Nil, Sempre nulo
/*/
//-------------------------------------------------------------------
Static Function fMemoTJB( cAlias )

	Local nX, nY
	Local cConteudo := ""
	Local aCampos 	:= { 	{ "TJB_MRISCO" , "TJB_RISCOS" , "TJB_RISSYP"  } , ;
		{ "TJB_MCARAC" , "TJB_CARACT" , "TJB_CARSYP"  } , ;
		{ "TJB_MPRCAT" , "TJB_PRCATI" , "TJB_PRCSYP"  } , ;
		{ "TJB_MESTOC" , "TJB_ESTOCA" , "TJB_ESTSYP"  } , ;
		{ "TJB_MDESCA" , "TJB_DESCAR" , "TJB_DESSYP"  } , ;
		{ "TJB_MTRANS" , "TJB_TRANSP" , "TJB_TRASYP"  } , ;
		{ "TJB_MLOCAL" , "TJB_LOCAL"  , "TJB_LOCSYP"  }   }

	//Passa o conteúdo do campo antigo para o novo

	dbSelectArea(cAlias)
	While (cAlias)->(!EoF())

		dbSelectArea("TJB")
		dbSetOrder(1)
		dbSeek((cAlias)->TJB_FILIAL+(cAlias)->TJB_CODPRO)

		For nX := 1 to Len(aCampos)

			cConteudo := ""
			//Se tiver conteúdo nos dois campos
			If !Empty( MSMM( &("TJB->"+aCampos[nX,3]) ) ) .And. !Empty( &("TJB->"+aCampos[nX,2]) )
				cConteudo := MSMM( &("TJB->"+aCampos[nX,3]) ) + CRLF + &("TJB->"+aCampos[nX,2])
				//Se só tiver conteúdono campo antigo
			ElseIf !Empty( &("TJB->"+aCampos[nX,2]) )
				cConteudo := &("TJB->"+aCampos[nX,2])
			EndIf

			If !Empty(cConteudo)
				MSMM(&("TJB->"+aCampos[nX,3]),TamSx3(aCampos[nX,1])[1],,cConteudo,1,,,"TJB",aCampos[nX,3])
				RecLock("TJB",.F.)
				&("TJB->"+aCampos[nX,2]) := ''
				TJB->(MsUnLock())
			EndIf

		Next nX
		(cAlias)->(dbSkip())
	EndDo

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} fGeraTYZ
População da tabela TYZ (Afastamento Atestado Médico) com os atestados
médicos que tenham datas de afastamento

@type    function
@author  Julia Kondlatsch
@since   26/11/2018
@sample  fGeraTYZ()

@return  Nil, Sempre Nulo
/*/
//-------------------------------------------------------------------
Static Function fGeraTYZ()

	Local cGenAls   := GetNextAlias()
	Local nSaid     := 0
	Local cMat      := ''
	Local nX        := 0
	Local nY        := 0
	Local dDtSeek   := SToD('')
	Local cSeq      := ''
	Local dDtaSaida := SToD('')
	Local dDtaAlta  := SToD('')
	Local cTipo     := ''
	Local nQtdDia   := 0
	Local aCont     := {}
	Local nPosCam   := 0

	If AliasInDic( "TYZ" )

		//Pega todos os Atestados com Afastamento que não tenham sido inseridos na TYZ
		BeginSQL Alias cGenAls

			SELECT TNY_FILIAL, TNY_NUMFIC, TNY_DTINIC, TNY_HRINIC
			FROM %table:TNY% TNY
			JOIN %table:TM0% TM0
				ON TNY_NUMFIC = TM0_NUMFIC AND
				TNY_FILIAL = TM0_FILIAL AND
				TM0.%notDel%
				JOIN %table:SR8% SR8 ON
					R8_FILIAL = TNY_FILIAL AND
					R8_MAT = TM0_MAT AND
					R8_DATAINI = TNY_DTSAID AND
					R8_SEQ <> '' AND
					SR8.%NotDel%
			WHERE ( TNY_DTSAID <> '' OR TNY_DTSAI2 <> '' OR TNY_DTSAI3 <> '' ) AND
				TNY_NATEST NOT IN ( SELECT TYZ_NATEST FROM %table:TYZ% TYZ WHERE %notDel% ) AND
				(TNY_CODAFA <> '' OR TNY_TIPAFA <> '') AND
				TNY.%notDel%
		EndSQL

		//Se houverem registros de atestado com afastamento, e se o usuário escolher atualizar os registros.
		If ( cGenAls )->( !Eof() ) .And. MsgYesNo( STR1462 ) // "Verificamos que os seus registrios de afastamento dos atestados
			// médicos, não foram transferidos para a nova tabela (TYZ) em sua base.
			// Deseja efetuar os ajustes necessários agora?"

			While ( cGenAls )->( !Eof() )
				dbSelectArea( "TNY" )
				dbSetOrder( 1 )
				dbSeek( ( cGenAls )->TNY_FILIAL + ( cGenAls )->TNY_NUMFIC + ( cGenAls )->TNY_DTINIC + ( cGenAls )->TNY_HRINIC )

				If Empty(TNY->TNY_ATEANT) //Caso não seja Continuação.
					If !Empty(TNY->TNY_DTSAID) .Or. !Empty(TNY->TNY_DTALTA)
						nSaid := 1
					EndIf
					If !Empty(TNY->TNY_DTSAI2) .Or. !Empty(TNY->TNY_DTALT2)
						nSaid := 2
					EndIf
					If !Empty(TNY->TNY_DTSAI3) .Or. !Empty(TNY->TNY_DTALT3)
						nSaid := 3
					EndIf
					If nSaid > 0
						cMat := Posicione("TM0",1,xFilial("TM0",( cGenAls )->TNY_FILIAL)+TNY->TNY_NUMFIC,"TM0_MAT") //Busca a Matricula.
						If !Empty( cMat ) //Somente gera afastamento se não for Candidato
							For nX := 1 To nSaid
								If nX == 1 //Caso tenha preenchido a primeira Saída.
									dDtSeek := TNY->TNY_DTSAID
								ElseIf nX == 2 //Caso tenha preenchido a segunda Saída.
									dDtSeek := TNY->TNY_DTSAI2
								ElseIf nX == 3//Caso tenha preenchido a terceira Saída.
									dDtSeek := TNY->TNY_DTSAI3
								EndIf

								dbSelectArea("SR8")
								dbSetOrder(6)//R8_FILIAL+R8_MAT+DTOS(R8_DATAINI)+R8_TIPOAFA+STR(R8_DIASEMP)
								If Dbseek(xFilial("SR8",( cGenAls )->TNY_FILIAL)+cMat+DTOS(dDtSeek))
									cSeq      := SR8->R8_SEQ 	  // Numero da Sequência da SR8.
									dDtaSaida := SR8->R8_DATAINI  // Data Saida para Afastamento.
									dDtaAlta  := SR8->R8_DATAFIM  // Data Fim do Afastamento.
								EndIf

								If !Empty(TNY->TNY_TIPAFA)
									cTipo := TNY->TNY_TIPAFA
								Else
									cTipo := SubStr(Posicione( "RCM", 1 , xFilial("RCM",( cGenAls )->TNY_FILIAL)+TNY->TNY_CODAFA , "RCM_CODSEF" ),1,1)
								EndIf

								If !MDTSeekTYZ(xFilial('TYZ',( cGenAls )->TNY_FILIAL),cMat,dDtaSaida,cTipo,TNY->TNY_CODAFA,TNY->TNY_NATEST) .And. ;
										!Empty( cSeq )
									RecLock( "TYZ" , .T. )
									TYZ->TYZ_FILIAL :=  xFilial('TYZ',( cGenAls )->TNY_FILIAL) //Filial Utilizada.
									TYZ->TYZ_MAT    := cMat  // Matricula do Funcionário.
									TYZ->TYZ_TIPO   := cTipo  // Tipo de Afastamento.
									TYZ->TYZ_NATEST := TNY->TNY_NATEST // Numero de Atestado.
									TYZ->TYZ_TIPOAF := TNY->TNY_CODAFA // Código de Afastamento.
									TYZ->TYZ_SEQ    := cSeq 	   // Numero da Sequência da SR8.
									TYZ->TYZ_DTSAID := dDtaSaida  // Data Saida para Afastamento.
									TYZ->TYZ_DTALTA := dDtaAlta   // Data Fim do Afastamento.
									TYZ->(MsUnLock())
								EndIf
							Next nX
						EndIf
					EndIf
					//Zera valores para próximo registro
					cSeq		:= ''		 // Numero da Sequência da SR8.
					dDtaSaida	:= SToD('') // Data Saida para Afastamento.
					dDtaAlta	:= SToD('') // Data Fim do Afastamento.
					nSaid 		:= 0
					cMat 		:= ""
				Else //Caso seja Continuação.
					cMat := Posicione("TM0",1,xFilial("TM0",( cGenAls )->TNY_FILIAL)+TNY->TNY_NUMFIC,"TM0_MAT") //Busca a Matricula.

					aAdd( aCont , { TNY->TNY_NATEST, TNY->TNY_ATEANT, TNY->TNY_FILIAL, cMat, ;
						If(Empty(TNY->TNY_TIPAFA),SubStr(Posicione( "RCM", 1 , xFilial("RCM",( cGenAls )->TNY_FILIAL)+TNY->TNY_CODAFA , "RCM_CODSEF" ),1,1),TNY->TNY_TIPAFA),;
							TNY->TNY_CODAFA, { TNY->TNY_DTSAID, TNY->TNY_DTSAI2, TNY->TNY_DTSAI3 } } )
						//Deleta o Registro da Tabela.
						RecLock( "TNY" , .F. )
						dbDelete()
						TNY->(MsUnLock())
					EndIf

					( cGenAls )->(dbSkip())
				End

				//Ordena o registro do por numero do atestado.
				aSORT(aCont,,,{|x,y| x[2] < y[2] })
				//Caso tenha alguma continuação de Atestado.
				If Len(aCont) > 0
					For nX := Len(aCont) To 1 Step -1
						nPosCam := aSCAN(aCont,{|x| x[1] == aCont[nX,2]})
						If nPosCam > 0  //Caso encontre alguma outra continuação.
							For nY := 1 To Len(aCont[nX,7])
								aAdd( aCont[nPosCam,7] , aCont[nX,7,nY] )
							Next nY
							//Deleta a continuação do Atestado.
							aDel(aCont,nX)
							aSize(aCont,Len(aCont)-1)
						EndIf
					Next nX
				EndIf

				If Len(aCont) > 0
					For nX := 1 To Len(aCont)
						nQtdDia := 0
						For nY := 1 To Len(aCont[nX,7])
							dbSelectArea("SR8")
							dbSetOrder(1)//R8_FILIAL+R8_MAT+DTOS(R8_DATAINI)+R8_TIPO
							If Dbseek(aCont[nX,3]+aCont[nX,4]+DTOS(aCont[nX,7,nY])+SubSTR(aCont[nX,5],1,2))
								dbSelectArea("TYZ")
								dbSetOrder(1)//TYZ_FILIAL+TYZ_MAT+DTOS(TYZ_DTSAID)+TYZ_TIPO+TYZ_TIPOAF
								If !dbSeek(xFilial("TYZ", aCont[nX,3] )+aCont[nX,4]+DTOS(SR8->R8_DATAINI)+aCont[nX,5]+aCont[nX,6])
									RecLock( "TYZ" , .T. )
									TYZ->TYZ_FILIAL := xFilial("TYZ", aCont[nX,3] ) //Filial Utilizada.
									TYZ->TYZ_MAT    :=  aCont[nX,4] // Matricula do Funcionário.
									TYZ->TYZ_TIPO   :=  aCont[nX,5] // Tipo de Afastamento.
									TYZ->TYZ_NATEST :=  aCont[nX,2] // Numero de Atestado.
									TYZ->TYZ_TIPOAF :=  aCont[nX,6] // Código de Afastamento.
									TYZ->TYZ_SEQ    := SR8->R8_SEQ 	   // Numero da Sequência da SR8.
									TYZ->TYZ_DTSAID := SR8->R8_DATAINI // Data Saida para Afastamento.
									TYZ->TYZ_DTALTA := SR8->R8_DATAFIM // Data Fim do Afastamento.
									TYZ->(MsUnLock())
									nQtdDia += SR8->R8_DATAFIM - SR8->R8_DATAINI
								EndIf
							EndIf
						Next nY
						dbSelectArea("TNY")
						dbSetOrder(2)//TNY_FILIAL+TNY_NATEST
						If dbSeek(xFilial("TNY",( cGenAls )->TNY_FILIAL)+aCont[nX,2]) .And. nQtdDia > 0
							RecLock( "TNY" , .F. )
							TNY->TNY_QTDIAS := nQtdDia
							TNY->(MsUnLock())
						EndIf
					Next nX
				EndIf
			EndIf
		EndIf

		Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTSeekTYZ
Função responsavel por verificar a existencia do registro na TYZ

@author  Julia Kondlatsch
@since   20/04/2018
@sample  MDTSeekTYZ(cFilTYZ,cMat,dDtaSaida,cTipo,cCodAFA,cNAtest)

@param cFilTYZ, Caractere, Filial
@param cMat, Caractere , Matricula
@param dDtaSaida, Data , Data da Saida
@param cTipo, Caractere , Tipo
@param cCodAFA, Caractere , Codigo Afastamento
@param cNAtest, Caractere , Numero do atestado

@return lRet, Lógico, Verdadeiro se foram encontrado registros
/*/
//-------------------------------------------------------------------
Function MDTSeekTYZ( cFilTYZ , cMat, dDtaSaida, cTipo, cCodAFA, cNAtest)

	Local lRet    := .F.
	Local cQryAls := GetNextAlias()

	//Efetua a consulta para verificar a existencia do registro
	BeginSQL Alias cQryAls
		SELECT COUNT( TYZ.TYZ_NATEST ) QTDREG FROM %table:TYZ%  TYZ
			WHERE 	TYZ.TYZ_FILIAL	= %exp:cFilTYZ% 			AND
					TYZ.TYZ_MAT		= %exp:cMat% 				AND
					TYZ.TYZ_DTSAID	= %exp:dDtaSaida% 			AND
					TYZ.TYZ_TIPO	= %exp:cTipo% 				AND
					TYZ.TYZ_TIPOAF	= %exp:cCodAFA% 			AND
					TYZ.TYZ_NATEST	= %exp:cNAtest% 			AND
					TYZ.%NotDel%
	EndSql

	//Se encontrou registro seta a variavel para verdadeiro
	If ( cQryAls )->QTDREG > 0
		lRet := .T.
	EndIf

	( cQryAls )->( dbCloseArea() )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTValSX6
Função para validação de SX6 no módulo de Medicina e Segurança do
 Trabalho.

@Obs Uso X6_VALID

@author Guilherme Benkendorf
@since 22/07/2015
@version 1.0
/*/
//---------------------------------------------------------------------
Function MDTValSX6( cParamSX6 )

	Local lRet := .T.
	Local cConteuPor := If(Type("M->X6_CONTEUD") == "C",(Alltrim( M->X6_CONTEUD )),"")
	Local cConteuSpa := If(Type("M->X6_CONTSPA") == "C",(Alltrim( M->X6_CONTSPA )),"")
	Local cConteuEng := If(Type("M->X6_CONTENG") == "C",(Alltrim( M->X6_CONTENG )),"")

	Default cParamSX6 := ""

	If cParamSX6 == "MV_NG2INTE"
		If ( "1" $ cConteuPor .And. Len( cConteuPor ) > 1 ) .Or.;
				( "1" $ cConteuSpa .And. Len( cConteuSpa ) > 1 ) .Or.;
				( "1" $ cConteuEng .And. Len( cConteuEng ) > 1 )

			ShowHelpDlg(STR0013,; //"ATENÇÃO"
			{ STR1287 },2,; //"Conteúdo do parâmetro inválido."
			{ STR1288 } , 3 ) //"Quando informado o conteúdo '1 = Não Contém' só poderá conter, exclusivamente, o valor 1."

			lRet := .F.
		EndIf
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}
Função que verifica o tamanho do campo TJ7_CODIGO, para não permitir
utilizar as rontinas que usam o campos caso ele esteja com o tamanho
errado

@type    function
@author  Julia Kondlatsch
@since   29/08/2019
@sample  MDTChkTJ7()

@return  Lógico, Verdadeiro quando o tamanho do campo TJ7_CODIGO
estiver correto no dicionário de dados
/*/
//-------------------------------------------------------------------
Function MDTChkTJ7()

	Local lRet := .T.

	If TAMSX3( 'TJ7_CODIGO' )[1] <> 30
		MDTMSGLINK( STR1476 , ; //"O tamanho do campo Código (TJ7_CODIGO) da tabela de Serviços (TJ7) está incorreto."
		STR1477 , ; //"Efetue a aplicação do pacote de correção antes de utilizar esta rotina."
		"https://tdn.totvs.com/x/TSaaHg")
		lRet := .F.
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTHideCpo

Troca o valor do campo por asteriscos para cumprir as normas da LGPD

@return	 cValue, Caracter, Valor do campo a ser mostrado ou asteriscos

@param	 cValCpo, Caracter, Valor do campo
@param	 cNomeCpo, Caracter, Nome do campo

@author  Luis Fellipy Bett
@since   04/02/2020
/*/
//-------------------------------------------------------------------
Function MDTHideCpo( cValCpo, cNomeCpo )

	Local aCampos	:= {}
	Local cValue	:= ""
	Local nCont		:= 0

	Default cValCpo	:= Space(TamSX3(cNomeCpo)[1])

	//Caso for versão a partir da 12.1.27
	If FindFunction( "FwPDCanUse" ) .And. FwPDCanUse()

		aCampos := FwProtectedDataUtil():UsrAccessPDField( RetCodUsr(), { cNomeCpo } )

		For nCont := 1 To Len( aCampos )
			aCampos[ nCont ] := AllTrim( aCampos[ nCont ] )
		Next nCont

		If aScan( aCampos, { | x | x == cNomeCpo } ) > 0
			cValue := cValCpo
		Else
			cValue := FwProtectedDataUtil():ValueAsteriskToAnonymize( cValCpo )
		EndIf

	Else
		cValue := cValCpo
	EndIf

Return cValue

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTVldFldAcc

Verifica se o usuário corrente tem permissão de visualização do campo

@return	 lAccess, Lógico, .T. caso o usuário tenha permissão de visualização do campo, senão .F.

@param	 cNomeCpo, Caracter, Nome do campo

@author  Luis Fellipy Bett
@since   21/02/2020
/*/
//-------------------------------------------------------------------
Function MDTVldFldAcc( cNomeCpo )

	Local aCampos	:= {}
	Local lAccess	:= .T.
	Local nCont		:= 0

	//Caso for versão a partir da 12.1.27
	If FindFunction( "FwPDCanUse" ) .And. FwPDCanUse()

		aCampos := FwProtectedDataUtil():UsrAccessPDField( RetCodUsr(), { cNomeCpo } )

		For nCont := 1 To Len( aCampos )
			aCampos[ nCont ] := AllTrim( aCampos[ nCont ] )
		Next nCont

		If aScan( aCampos, { | x | x == cNomeCpo } ) == 0
			lAccess	:= .F.
		EndIf

	EndIf

Return lAccess

//-------------------------------------------------------------------
/*/{Protheus.doc} MDTMrkFil

Função genérica que cria um MarkBrowse para selecionar as filiais a
que o usuário tem acesso

@sample	MDTMrkFil()

@return	aFilMrk, Array, Array com as filiais selecionadas pelo usuário

@author	Luis Fellipy Bett
@since	27/04/2020
/*/
//-------------------------------------------------------------------
Function MDTMrkFil()

	Local aArea			:= GetArea()
	Local cAliasTRB		:= GetNextAlias()
	Local aSM0			:= FWLoadSM0( .T., .T. )
	Local cPesquisar	:= Space( 200 ) //Valor a ser pesquisado
	Local lOk			:= .F.
	Local lInverte		:= .F.
	Local nCont			:= 0
	Local aFilMrk		:= {}
	Local aDBF			:= {}
	Local aTRB			:= {}
	Local aDescIdx		:= {}
	Local oTempTRB

	Private cMarca		:= GetMark()

	aAdd( aDBF , { "OK"     , "C" , 02 , 0 } )
	aAdd( aDBF , { "CODFIL" , "C" , FwSizeFilial() , 0 } )
	aAdd( aDBF , { "FILIAL" , "C" , 40  , 0 } )

	aAdd( aTRB , { "OK"     , NIL , " "	  , } )
	aAdd( aTRB , { "CODFIL" , NIL , STR1482, } ) //"Código da Filial"
	aAdd( aTRB , { "FILIAL" , NIL , STR1483, } ) //"Filial"

	aAdd( aDescIdx , STR1482 ) //"Código da Filial"
	aAdd( aDescIdx , STR1483 ) //"Filial"
	aAdd( aDescIdx , STR1484 ) //"Marcados"

	oTempTRB := FWTemporaryTable():New( cAliasTRB, aDBF )
	oTempTRB:AddIndex( "1", { "CODFIL" }  )
	oTempTRB:AddIndex( "2", { "FILIAL" } )
	oTempTRB:AddIndex( "3", { "OK" } )
	oTempTRB:Create()

	//Alimenta a TRB
	For nCont := 1 To Len( aSM0 )

		RecLock( cAliasTRB, .T. )
		( cAliasTRB )->CODFIL := Upper( Substr( aSM0[ nCont, 2 ], 1, FwSizeFilial() ) )
		( cAliasTRB )->FILIAL := Upper( SubStr( aSM0[ nCont, 7 ], 1, 40 ) )
		( cAliasTRB )->( MsUnlock() )

	Next nCont

	dbSelectArea( cAliasTRB )
	dbGoTop()

	DEFINE MSDIALOG oDialog TITLE OemToAnsi( STR1485 ) From 064, 160 To 550, 690 OF oMainWnd Pixel //"Filiais"

	oPnlTot := TPanel():New( , , , oDialog, , , , , , , , .F., .F. )
	oPnlTot:Align := CONTROL_ALIGN_ALLCLIENT

	oPanel := TPanel():New( 0, 0, , oPnlTot, , .T., .F., , , 0, 070, .T., .F. )
	oPanel:Align := CONTROL_ALIGN_TOP

	//Descrição
	@ 005, 010 TO 020, 255 OF oPanel Pixel
	TSay():New( 009, 014, { | | OemtoAnsi( STR1486 ) }, oPanel, , , .F., .F., .F., .T., CLR_BLACK, CLR_WHITE, 279, 010 ) //"Estas são as filiais disponíveis. Selecione entre elas as filiais desejadas."

	//Pesquisa/Ordenação
	@ 025, 010 TO 065, 255 OF oPanel PIXEL
	aCbxPesq := aClone( aDescIdx )
	cCbxPesq := aCbxPesq[ 1 ]

	oCbxPesq := TComboBox():New( 033, 016, { | u | If( PCount() > 0, cCbxPesq := u, cCbxPesq ) }, aCbxPesq, 235, 08, oPanel, , ;
		{ | | }, , , , .T., , , , , , , , , "cCbxPesq" )

	oCbxPesq:bChange := { | | fSetIndex( cAliasTRB, aCbxPesq, @cPesquisar, oMark ) }

	oPesquisar := TGet():New( 048, 016, { | u | If( PCount() > 0, cPesquisar := u, cPesquisar ) }, oPanel, 180, 010, "", { | | .T. } , ;
		CLR_BLACK, CLR_WHITE, , .F., , .T. /*lPixel*/, , .F., { | | .T. }/*bWhen*/, .F., .F., , .F. /*lReadOnly*/, ;
		.F., "", "cPesquisar", , , , .F. /*lHasButton*/ )

	oBtnPesq := TButton():New( 048 , 200 , "Pesquisar" , oPanel , { | | fPesqTRB( cAliasTRB, oMark, cPesquisar ) } , 049 , 012 , , , .F. , .T. , .F. , ;
		, .F., , , .F. )

	oMark := MsSelect():New( cAliasTRB, "OK", , aTRB, @lInverte, @cMarca, { 45, 5, 254, 281 }, , , oPnlTot )
	oMark:oBrowse:lHasMark		:= .T.
	oMark:oBrowse:lCanAllMark	:= .T.
	oMark:oBrowse:bAllMark		:= { | | fInverte( cMarca , cAliasTRB , oMark ) } //Funcao inverte marcadores
	oMark:oBrowse:Align			:= CONTROL_ALIGN_ALLCLIENT

	ACTIVATE MSDIALOG oDialog ON INIT EnchoiceBar( oDialog, { || lOk := .T., oDialog:End() }, { || oDialog:End() } ) CENTERED

	If lOk
		dbSelectArea( cAliasTRB )
		dbGoTop()
		While !Eof()
			If !Empty( ( cAliasTRB )->OK )
				aAdd( aFilMrk, { ( cAliasTRB )->CODFIL } )
			EndIf
			dbSkip()
		End
	EndIf

	//Exclui a TRB
	oTempTRB:Delete()

	//Volta a área posicionada
	RestArea( aArea )

Return aFilMrk

//---------------------------------------------------------------------
/*/{Protheus.doc} fSetIndex
Seta o indice para pesquisa

@param cAliasTRB, Caracter, Alias do TRB ( Obrigatório )
@param aCbxPesq, Array, Indices de pesquisa do markbrowse ( Obrigatório )
@param cPesquisar, Caracter, Valor da Pesquisa ( Obrigatório )
@param oMark, Objeto, Objeto do MarkBrowse ( Obrigatório )

@author	Luis Fellipy Bett
@since	23/03/2020
/*/
//---------------------------------------------------------------------
Static Function fSetIndex( cAliasTRB, aCbxPesq, cPesquisar, oMark )

	Local nIndice := fRetInd( aCbxPesq ) //Retorna numero do indice selecionado

	//Efetua ordenacao do alias do markbrowse, conforme indice selecionado
	dbSelectArea( cAliasTRB )
	dbSetOrder( nIndice )
	dbGoTop()

	// Se o indice selecionado for o ultimo [Marcados]
	If nIndice == Len( aCbxPesq )
		cPesquisar := Space( Len( cPesquisar ) ) //Limpa campo de pesquisa
		oPesquisar:Disable()	 //Desabilita campo de pesquisa
		oBtnPesq:Disable()		 //Desabilita botao de pesquisa
		oMark:oBrowse:SetFocus() //Define foco no markbrowse
	Else
		oPesquisar:Enable()		 //Habilita campo de pesquisa
		oBtnPesq:Enable()		 //Habilita botao de pesquisa
		oBtnPesq:SetFocus()		 //Define foco no campo de pesquisa
	Endif

	oMark:oBrowse:Refresh()

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fRetInd
Retorna o indice, em numero, do item selecionado no combobox

@return nIndice, Numérico, Retorna o valor do Indice

@param aIndMrk, Array, Indices de pesquisa do markbrowse ( Obrigatório )

@author	Luis Fellipy Bett
@since	23/03/2020
/*/
//---------------------------------------------------------------------
Static Function fRetInd( aIndMrk )

	Local nIndice := aScan( aIndMrk , { | x | AllTrim( x ) == AllTrim( cCbxPesq ) } )

	// Se o indice nao foi encontrado nos indices pre-definidos, apresenta mensagem
	If nIndice == 0
		ShowHelpDlg( STR1451, { STR1489 } , 1 , { STR1490 } , 1 ) //"Índice não encontrado"##"Contate o administrador do sistema"
		nIndice := 1
	Endif

Return nIndice

//---------------------------------------------------------------------
/*/{Protheus.doc} fInverte
Inverte as marcacoes ( bAllMark )

@param cMarca 		- Valor da marca do TRB ( Obrigatório )
@param cAliasTRB	- Alias do TRB ( Obrigatório )
@param oMark		- Objeto do MarkBrowse ( Obrigatório )
@param lAll			- Indica se eh AllMark

@author	Luis Fellipy Bett
@since	23/03/2020
/*/
//---------------------------------------------------------------------
Static Function fInverte( cMarca, cAliasTRB, oMark )

	Local aArea := GetArea()

	dbSelectArea( cAliasTRB )
	dbGoTop()
	While ( cAliasTRB )->( !Eof() )
		( cAliasTRB )->OK := IIf( Empty( ( cAliasTRB )->OK ), cMarca, Space( Len( cMarca ) ) )
		(cAliasTRB)->( dbskip() )
	End

	RestArea( aArea )

	// Atualiza markbrowse
	oMark:oBrowse:Refresh()

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fPesqTRB
Funcao de Pesquisar no Mark Browse.

@return lRet, Lógico, .T. caso encontrar o registro

@param cAliasTRB, Caracter, Alias do MarkBrowse ( Obrigatório )
@param oMark, Objeto, Objeto do MarkBrowse ( Obrigatório )
@param cPesquisar, Caracter, Valor digitado no campo de pesquisa ( Obrigatório )

@author	Luis Fellipy Bett
@since	23/03/2020
/*/
//---------------------------------------------------------------------
Static Function fPesqTRB( cAliasTRB, oMark, cPesquisar )

	Local nRecNoAtu := 1 //Variavel para salvar o recno
	Local lRet		:= .T.

	//Posiciona no TRB e salva o recno
	dbSelectArea( cAliasTRB )
	nRecNoAtu := RecNo()

	dbSelectArea( cAliasTRB )
	If dbSeek( AllTrim( Upper( cPesquisar ) ) )
		//Caso exista a pesquisa, posiciona
		oMark:oBrowse:SetFocus()
	Else
		//Caso nao exista, retorna ao primeiro recno e exibe mensagem
		dbGoTo( nRecNoAtu )
		Help( ' ', 1, STR1451, , STR1487, 2, 0, , , , , , { STR1488 } ) //"Valor não encontrado"##"Favor digitar outro valor para pesquisa"
		oPesquisar:SetFocus()
		lRet := .F.
	EndIf

	//Atualiza o MarkBrowse
	oMark:oBrowse:Refresh( .T. )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fAtuSegEpi
Ajuste do campo TNF_HRENTR (EPI's entregues do funcionário)

@type    Static function
@author  Milena Leite de Oliveira
@since   19/05/2020

@sample  fAtuSegEpi()

@return  Nil, Sempre Nulo
/*/
//---------------------------------------------------------------------
Static Function fAtuSegEpi()

	Local cGetDB  := Upper( TcGetDb() ) //Traz a base de dados
	Local cRTrim  := IIf( cGetDB $ "OPENEDGE", "RIGHT-TRIM", "RTRIM" )
	Local cExpLen := " WHERE LEN( " + cRTrim + "( TNF_HRENTR ) ) < 8" //Expressão de tamanho
	Local cExpStr := " SET TNF_HRENTR = CONCAT( SUBSTRING( TNF_HRENTR, 1, 5 ), ':00' )" //Expressão de corte da string

	//Verifica expressões dos bancos
	If cGetDB $ "ORACLE/POSTGRES/OPENEDGE/INFORMIX" .Or. "DB2" $ cGetDB
		cExpLen := " WHERE LENGTH( " + cRTrim + "( TNF_HRENTR ) ) < 8"
		If cGetDB $ "ORACLE" .Or. "DB2" $ cGetDB
			cExpStr := " SET TNF_HRENTR = CONCAT( SUBSTR( TNF_HRENTR, 1, 5 ), ':00' )"
		EndIf
	EndIf

	//Entrega de EPI
	cUpdTNF := " UPDATE " + RetSqlName( "TNF" )
	cUpdTNF += cExpStr
	cUpdTNF += cExpLen
	cUpdTNF += " AND D_E_L_E_T_ <> '*'"

	TCSQLExec( cUpdTNF ) //Executa a query

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} fGeraTYD

Função que popula a tabela TYD (ASO x Tarefas) com as tarefas
cadastradas no campo TMY_NOVTAR do ASO

@sample	fGeraTYD()

@return	Nil, Nulo

@author	Luis Fellipy Bett
@since	19/05/2020
/*/
//-------------------------------------------------------------------
Static Function fGeraTYD()

	Local cAliasTMY := GetNextAlias()

	//Repasse do valor do campo TMY_NOVTAR para a tabela TYD
	If AliasInDic( "TYD" ) .And. NGCADICBASE( "TMY_NOVTAR", "A", "TMY", .F. )

		dbSelectArea( "TYD" )
		dbGoTop()
		If TYD->( RecCount() ) <= 0 //Caso a tabela TYD esteja vazia

			BeginSQL Alias cAliasTMY
				SELECT TMY.TMY_FILIAL, TMY.TMY_NUMASO, TMY.TMY_NOVTAR
					FROM %table:TMY% TMY
					WHERE TMY.TMY_NOVTAR <> '' AND
					TMY.%notDel%
			EndSql

			dbSelectArea( cAliasTMY )
			dbGoTop()
			While ( cAliasTMY )->( !Eof() )
				dbSelectArea( "TYD" )
				dbSetOrder( 1 )
				If !dbSeek( ( cAliasTMY )->TMY_FILIAL + ( cAliasTMY )->TMY_NUMASO + ( cAliasTMY )->TMY_NOVTAR )
					RecLock( "TYD", .T. )
					TYD->TYD_FILIAL := ( cAliasTMY )->TMY_FILIAL
					TYD->TYD_NUMASO := ( cAliasTMY )->TMY_NUMASO
					TYD->TYD_CODTAR := ( cAliasTMY )->TMY_NOVTAR
					TYD->( MsUnlock() )
				EndIf
				( cAliasTMY )->( dbSkip() )
			End

		EndIf
	EndIf

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTNumSQL
Verifica se o registro existe na tabela montada pela query
(funcionamento semelhante a função ExistChav)

@return	lRet, Lógico, .T. caso o registro exista na tabela montada
pela query

@sample	MDTNumSQL( "TMY", "TMY_NUMASO", "000002" )

@parama	cTbl, Caracter, Tabela a ser consultada
@param	cCampo, Caracter, Campo a ser consultado
@param	cValCpo, Caracter, Valor a ser buscado no campo

@author	Luis Fellipy Bett
@since	26/08/2020
/*/
//---------------------------------------------------------------------
Function MDTNumSQL( cTbl, cCampo, cValCpo )

	Local aArea := GetArea()

	Local cAliasQry := GetNextAlias()
	Local cQuery := ""

	Local lRet := .T.

	cQuery += " SELECT " + cCampo
	cQuery += " FROM " + RetSQLName( cTbl )
	cQuery += " WHERE " + RetSQLFil( cTbl )
	cQuery += " AND " + cCampo + " = " + ValToSQL( cValCpo )

	cQuery := ChangeQuery( cQuery )
	dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasQry, .T., .T. )

	dbSelectArea( cAliasQry )
	If Eof()
		lRet := .F.
	EndIf

	( cAliasQry )->( dbCloseArea() )
	RestArea( aArea )

Return lRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fAtuFunDia
Ajuste do campo TMT_CODFUN que não estava sendo populado ao ser chamado
pelo MDTA110.

Observação: Função feita para efeito da versão 12.1.27

@type    Static function
@author  Luis Fellipy Bett
@since   07/10/2020

@sample  fAtuFunDia()

@return  Nil, Sempre Nulo
/*/
//---------------------------------------------------------------------
Static Function fAtuFunDia()

	Local cAlsDiag	:= GetNextAlias()
	Local cAlsTran	:= GetNextAlias()
	Local cAlsTran2 := GetNextAlias()
	Local cAlsFunc	:= GetNextAlias()
	Local cFilAux	:= ""
	Local cFunAux	:= ""
	Local cCCAux	:= ""
	Local cMatric	:= ""
	Local lVldSRE	:= .T.
	Local lQryAux	:= .F.

	BeginSQL Alias cAlsDiag
		SELECT TMT_FILIAL, TMT_NUMFIC, TMT_DTCONS, TMT_HRCONS, TMT_CC, TMT_CBO, TMT_CODFUN, TMT_FILFUN
			FROM %Table:TMT% TMT
			WHERE TMT.TMT_CC = '' AND
			TMT.TMT_CBO = '' AND
			TMT.TMT_CODFUN = '' AND
			TMT.TMT_FILFUN = '' AND
			TMT.%NotDel%
	EndSQL

	ProcRegua( Contar( cAlsDiag, "!Eof()" ) ) //Define a régua de processamento

	dbSelectArea( cAlsDiag )
	( cAlsDiag )->( dbGoTop() )
	If ( cAlsDiag )->( !Eof() ) //Se houver diagnósticos com os campos em branco

		While ( cAlsDiag )->( !Eof() )

			IncProc() //Incrementa a régua

			dbSelectArea( "TM0" )
			TM0->( dbSetOrder( 1 ) )
			TM0->( dbSeek( ( cAlsDiag )->TMT_FILIAL + ( cAlsDiag )->TMT_NUMFIC ) )

			cFilAux	:= TM0->TM0_FILIAL
			cCCAux	:= TM0->TM0_CC
			cFunAux	:= TM0->TM0_CODFUN

			If !Empty( TM0->TM0_MAT ) //Caso a matrícula não estiver preenchida

				cMatric := TM0->TM0_MAT //Atribui a matrícula da ficha

				While lVldSRE //Enquanto a matrícula de destino for diferente da origem

					BeginSQL Alias cAlsTran
						SELECT RE_FILIALD, RE_FILIALP, RE_CCD, RE_CCP, RE_MATD, RE_MATP
							FROM %Table:SRE% SRE
							WHERE SRE.RE_MATD = %Exp:cMatric% AND
							SRE.RE_DATA <= %Exp:( cAlsDiag )->TMT_DTCONS% AND
							SRE.%NotDel%
							ORDER BY RE_DATA DESC
					EndSQL

					//Verifica a data de transferência que ta dentro do diagnóstico
					dbSelectArea( cAlsTran )
					( cAlsTran )->( dbGoTop() )
					If ( cAlsTran )->( !Eof() )
						cMatric := ( cAlsTran )->RE_MATP
						cFilAux	:= ( cAlsTran )->RE_FILIALP
						cCCAux	:= ( cAlsTran )->RE_CCP
						If ( cAlsTran )->RE_MATD == ( cAlsTran )->RE_MATP .Or. lQryAux
							lVldSRE := .F.
						EndIf
						( cAlsTran )->( dbCloseArea() ) //Exclui tabela temporária
					Else

						BeginSQL Alias cAlsTran2
							SELECT RE_FILIALD, RE_FILIALP, RE_CCD, RE_CCP, RE_MATD, RE_MATP
								FROM %Table:SRE% SRE
								WHERE SRE.RE_MATP = %Exp:cMatric% AND
								SRE.RE_DATA <= %Exp:( cAlsDiag )->TMT_DTCONS% AND
								SRE.%NotDel%
								ORDER BY RE_DATA DESC
						EndSQL

						dbSelectArea( cAlsTran2 )
						( cAlsTran2 )->( dbGoTop() )
						If ( cAlsTran2 )->( !Eof() )
							cMatric := ( cAlsTran2 )->RE_MATD
							lQryAux := .T.
						Else
							lVldSRE := .F.
						EndIf
						( cAlsTran2 )->( dbCloseArea() ) //Exclui tabela temporária
						( cAlsTran )->( dbCloseArea() ) //Exclui tabela temporária
					EndIf
				End

				BeginSQL Alias cAlsFunc
					SELECT R7_FUNCAO
						FROM %Table:SR7% SR7
						WHERE SR7.R7_MAT = %Exp:cMatric% AND
						SR7.R7_DATA <= %Exp:( cAlsDiag )->TMT_DTCONS% AND
						SR7.%NotDel%
						ORDER BY R7_DATA DESC
				EndSQL

				//Verifica a data de histórico da função que ta dentro do diagnóstico
				dbSelectArea( cAlsFunc )
				( cAlsFunc )->( dbGoTop() )
				If ( cAlsFunc )->( !Eof() )
					cFunAux	:= ( cAlsFunc )->R7_FUNCAO
				EndIf
				( cAlsFunc )->( dbCloseArea() ) //Exclui tabela temporária

				lVldSRE := .T. //Volta para .T. para verificar o próximo registro
			EndIf

			dbSelectArea( "TMT" )
			dbSetOrder( 3 )
			TMT->( dbSeek( ( cAlsDiag )->TMT_FILIAL + ( cAlsDiag )->TMT_NUMFIC + ( cAlsDiag )->TMT_DTCONS + ( cAlsDiag )->TMT_HRCONS ) )
			RecLock( "TMT", .F. )
			TMT->TMT_CC := cCCAux
			TMT->TMT_CBO := Posicione( "SRJ", 1, xFilial( "SRJ" ) + cFunAux, "RJ_CODCBO" )
			TMT->TMT_CODFUN := cFunAux
			TMT->TMT_FILFUN := cFilAux
			TMT->( MsUnLock() )
			dbSelectArea( cAlsDiag )
			( cAlsDiag )->( dbSkip() )

		End

	EndIf

	( cAlsDiag )->( dbCloseArea() ) //Exclui tabela temporária da query

Return Nil

//---------------------------------------------------------------------
/*/{Protheus.doc} MDTMEMOLINK
Apresenta uma tela com um campo memo e um botão de link

@param	cTitJan, Caracter, Título da janela
@param	cTxtLink, Caracter, Texto a ser apresentado indicando o link
@param	cLink, Caracter, Link para que será aberto ao clicar no botão 'Abrir'
@param	cTxtMemo, Caracter, Texto a ser apresentado no campo memo

@return Nil, Sempre nulo

@sample MDTMEMOLINK()

@author Luis Fellipy Bett
@since  25/06/2021
/*/
//---------------------------------------------------------------------
Function MDTMEMOLINK( cTitJan, cTxtLink, cLink, cTxtMemo )

	Local oDlg
	Local oPnlTot
	Local oPnlTop

	DEFINE MSDIALOG oDlg TITLE cTitJan From 0, 0 to 416, 550 PIXEL

	//Painel total do Dialog
	oPnlTot := TPanel():New( , , , oDlg, , , , , , , , .F., .F. )
	oPnlTot:Align := CONTROL_ALIGN_ALLCLIENT

	//Painel superior
	oPnlTop := TPanel():New( 0, 0, , oPnlTot, , .T., .F., , , 0, 070, .T., .F. )
	oPnlTop:Align := CONTROL_ALIGN_TOP

	//Texto indicando a execução do botão 'Abrir'
	@ 005, 005 TO 038, 240 OF oPnlTop Pixel
	TSay():New( 008, 008, { | | OemtoAnsi( cTxtLink ) }, oPnlTop, , , .F., .F., .F., .T., CLR_BLACK, CLR_WHITE, 220, 035 )

	//Botão 'Abrir'
	TButton():New( 012, 243, OemToAnsi( STR1536 ), oPnlTop, { | | ShellExecute( "Open", cLink, "", "", SW_NORMAL ) }, 030, 011, , , .F., .T., .F., , .F., , , .F. ) //"Abrir"

	//Memo
	TMultiGet():New( 041, 005, { |u| IIf( Pcount() > 0, cTxtMemo := u, cTxtMemo ) }, oPnlTot, 265, 150, , , , , ,.T., , , , , , .T. )

	//Botão 'Fechar'
	TButton():New( 194, 243, OemToAnsi( STR1537 ), oPnlTot, { | | oDlg:End() }, 030, 011, , , .F., .T., .F., , .F., , , .F. ) //"Fechar"

	ACTIVATE MSDIALOG oDlg CENTER

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} MdtPopUp
Cria um pop-up com opções de escolha

@author Gabriel Sokacheski
@since 16/06/2022

@param cTitulo, Caractere, Pergunta a ser realizada
@param aItem, Array, Opções de resposta
@param nMulti, Numérico, Multiplicador do tamanho padrão do pop-up

@sample MdtPopUp(;
	'Modelo do relatório',;
	{ 'Html', 'TReport' },;
	{;
		{ 80, 150 },; // pop-up
		{ 10, 10 },; // texto
		{ 30, 10, 50, 20 },; // opções
		{ 60, 10, 60, 20 },; // botão de cancelar
		{ 60, 80, 60, 20 }; // botão de confirmar
	};
)

@return array
	array[ 1 ] Verdadeiro se confirmou
	array[ 2 ] Número da opção respondida
*/
//-------------------------------------------------------------------
Function MdtPopUp( cTitulo, aItem, nMulti )

	Local cCSS

	Local lRetorno := .F.

	Local nAltura
	Local nLargura
	Local nResposta

	Local oMenu
	Local oTela := FwDialogModal():new()
	Local oBotao1
	Local oBotao2
	Local oBotoes
	Local oTitulo
	Local oContainer

	Default nMulti := 1

	nAltura := 100 * nMulti
	nLargura := 150 * nMulti

	oTela:setEscClose( .T. )
    oTela:setSize( nAltura, nLargura )
	oTela:enableFormBar( .F. )

	oTela:createDialog() // Cria a tela conforme especifícações definidas via métodos anteriormente

    oContainer := tPanel():create( oTela:getPanelMain() )
	oContainer:Align := CONTROL_ALIGN_ALLCLIENT

	oTitulo := TSay():create(;
		oContainer,;
		{ || cTitulo },;
		10,;
		10,;
		Nil,;
		Nil,;
		Nil,;
		Nil,;
		Nil,;
		Nil,;
		Nil,;
		Nil,;
		nLargura - 10;
	)

	cCSS := ''

	cCSS += 'QLabel {'
		cCSS += 'font-family: arial;'
		cCSS += 'font-size: 14px;'
		cCSS += 'color: #30252b;'
	cCSS += '}'

	oTitulo:SetCss( cCSS )

	oMenu := TRadMenu():create(;
		oContainer,;
		{ | u | IIf( PCount() == 0, nResposta, nResposta := u ) },;
		30,;
		10,;
		aItem,;
		Nil,;
		Nil,;
		Nil,;
		Nil,;
		Nil,;
		Nil,;
		Nil,;
		nLargura,;
		10 * Len( aItem );
	)

	cCSS := ''

	cCSS += 'QRadioButton {'
		cCSS += 'font-family: arial;'
		cCSS += 'font-size: 12px;'
		cCSS += 'color: #30252b;'
	cCSS += '}'

	cCSS += 'QRadioButton::indicator {'
		cCSS += 'width: 15px;'
		cCSS += 'height: 15px;'
		cCSS += 'padding: 2px;'
	cCSS += '}'

	// Implementação futura
	/*cCSS += 'QRadioButton::indicator:checked {'
		cCSS += 'image: url(C:/Protheus/http/radio_on.png);'
	cCSS += '}'

	cCSS += 'QRadioButton::indicator:unchecked {'
		cCSS += 'image: url(C:/Protheus/http/radio_off.png);'
	cCSS += '}'*/

	oMenu:SetCss( cCSS )

	oBotoes := tPanel():create(;
		oTela:getPanelMain(),;
		nAltura - 30,;
		0,;
		Nil,;
		Nil,;
		Nil,;
		Nil,;
		Nil,;
		Nil,;
		nLargura,;
		40;
	)

	cCSS := ''

	cCSS += 'QLabel {'
		cCSS += 'background-color: #f1f3f3;'
	cCSS += '}'

	oBotoes:SetCss( cCSS )

	oBotao1 := TButton():new(;
		10,;
		nLargura - 140,;
		STR1552,;
		oBotoes,;
		{ || lRetorno := .F., oTela:deActivate() },;
		60,;
		20,;
		Nil,;
		Nil,;
		.F.,;
		.T.,;
		.F.,;
		Nil,;
		.F.,;
		Nil,;
		Nil,;
		.F.;
	)
	oBotao2 := TButton():new(;
		10,;
		nLargura - 70,;
		STR1553,;
		oBotoes,;
		{ || lRetorno := .T., oTela:deActivate()  },;
		60,;
		20,;
		Nil,;
		Nil,;
		.F.,;
		.T.,;
		.F.,;
		Nil,;
		.F.,;
		Nil,;
		Nil,;
		.F.;
	)

	cCSS := ''

	cCSS += 'QPushButton {'
		cCSS += 'font-family: arial;'
		cCSS += 'font-size: 14px;'
		cCSS += 'background-color: #ffffff;'
		cCSS += 'color: #8b9fb2;'
		cCSS += 'border: 2px solid #efefef;'
		cCSS += 'border-radius: 5px;'
	cCSS += '}'

	cCSS += 'QRadioButton::indicator {'
		cCSS += 'width: 15px;'
		cCSS += 'height: 15px;'
		cCSS += 'padding: 2px;'
	cCSS += '}'

	oBotao1:SetCss( cCSS )

	cCSS := ''

	cCSS += 'QPushButton {'
		cCSS += 'font-family: arial;'
		cCSS += 'font-size: 14px;'
		cCSS += 'background-color: #2aa8c7;'
		cCSS += 'color: white;'
		cCSS += 'border: 2px solid #46c2e1;'
		cCSS += 'border-radius: 5px;'
	cCSS += '}'

	cCSS += 'QRadioButton::indicator {'
		cCSS += 'width: 15px;'
		cCSS += 'height: 15px;'
		cCSS += 'padding: 2px;'
	cCSS += '}'

	oBotao2:SetCss( cCSS )

    oTela:Activate()

Return { lRetorno, nResposta }


//---------------------------------------------------------------------
/*/{Protheus.doc} MDTFwBrwse
Função genérica que realiza a montagem de telas com o objeto FwBrowse

@sample	MDTFwBrwse()

@param	lTotScr, Boolean, Indica se a dialog ocupará a tela inteira
@param	cTitDlg, Caracter, Indica o título a ser impresso na dialog
@param	cOpcCrt, Caracter, Indica qual a opção de criação será considerada na montagem do browse/markbrowse
	Opções: "Array", "Query", "Table", "Text"
@param	xObjCrt, Array/Caracter, Indica qual o objeto de criação utilizado na montagem do browse/markbrowse
	cOpcCrt igual a "Array": Array - Array contendo as informações a serem utilizadas na montagem do browse/markbrowse
	cOpcCrt igual a "Query": Caracter - Query que contém as informações a serem utilizadas na montagem do browse/markbrowse
	cOpcCrt igual a "Table": Caracter - Tabela que contém as informações a serem utilizadas na montagem do browse/markbrowse
	cOpcCrt igual a "Text": Caracter - Caminho do arquivo que contém as informações a serem utilizadas na montagem do browse/markbrowse
@param	aCpsCab, Array, Array contendo os campos a serem apresentados no cabeçalho
@param	lInsBrw, Boolean, Indica se poderão ser adicionadas novas linhas no browse/markbrowse
@param	lEdtCel, Caracter, Indica se poderão ser alterados células no browse/markbrowse
@param	aLegBrw, Array, Array contendo a legenda do browse/markbrowse
@param	lMrkBrw, Boolean, Indica se é montagem de markbrowse
@param	cChgLin, Caracter, Indica o bloco de código que será executado na mudança de linha
@param	aHeaCol, Array, Array contendo os campos do header das colunas
@param	cButEnc, Caracter, Indica os botões que deverão ser desativados na enchoice
@param	aCpoLmp, Array, Array contendo os campos que devem ser limpos ao desselecionar um registro no markbrowse
@param	cVldCnf, Caracter, Indica a função de validação que será chamada ao confirmar a tela (em string)
@param	lJstOne, Boolean, No caso de montagem de markbrowse indica se apenas um registro ficará selecionado
@param	cVldLin, Caracter, Indica o bloco de código que será executado na validação da linha
@param	cAftAdd, Caracter, Indica o bloco de código que será executado ao adicionar uma nova linha
@param	lDelLin, Boolean, Indica se será permitida a exclusão de linhas
@param	cVldExc, Caracter, Indica o bloco de código a ser executado na exclusão de um registro do browse
@param	aCpsPsq, Array, Array contendo as informações para definir o campo de pesquisa

@author	Luis Fellipy Bett
@since	11/04/2022

@return lConfirm, Boolean, Indica se a tela foi confirmada

@obs	Quando essa função foi criada em 11/04/2022 foram feitos alguns questionamentos a cerca do objeto
FWBrowse à equipe do framework pois ele não funcionava corretamente em alguns cenários, como na edição de
registros quando o objeto era criado a partir de um array e na deleção de registros que não funcionava
tanto para objeto criado a partir de array e a partir de tabela temporária (mesmo existindo um método
na documentação exclusivo para isso). Talvez um dia o framework implemente corretamente os métodos do
objeto para que ele funcione corretamente como se espera e como está documentado, mas hoje não é assim.
Portanto, essa função foi criada pensando sempre na melhor gambiarra possível a ser feita para que ela
funcione da maneira que se espera já que o framework não garante isso (que seria o básico).
/*/
//---------------------------------------------------------------------
Function MDTFwBrwse( lTotScr, cTitDlg, cOpcCrt, xObjCrt, aCpsCab, lInsBrw, lEdtCel, aLegBrw, lMrkBrw, cChgLin, aHeaCol, cButEnc, aCpoLmp, cVldCnf, lJstOne, cVldLin, cAftAdd, lDelLin, cVldExc, aCpsPsq )

	//Salva a área
	Local aArea := GetArea()

	//Variáveis de controle
	Local cMarca := IIf( lMrkBrw, GetMark(), "" )
	Local lConfirm := .F.

	//Variáveis padrões de montagem do browse/markbrowse
	Local oDialog
	Local lCabBrw
	Local lLegBrw
	Local lPsqBrw

	//Variáveis de montagem do cabeçalho
	Local nLinSay
	Local nColSay
	Local bSayNam
	Local nSayWid
	Local nSayHgh
	Local nLinGet
	Local nColGet
	Local bGetCon
	Local nGetWid
	Local nGetHgh
	Local cGetPic
	Local bGetVld
	Local bGetWhe
	Local lGetRea
	Local lGetPsw
	Local cGetVar
	Local lGetHBu

	//Variáveis de dimensionamento da tela
	Local aTamTel := {}
	Local nLinIni := 0
	Local nLinFim := 0
	Local nColIni := 0
	Local nColFim := 0

	//Variáveis contadoras
	Local nCont := 0

	//Variáveis private utilizadas no fluxo
	Private lDataArr := Upper( cOpcCrt ) == "ARRAY"
	Private lDataTab := Upper( cOpcCrt ) == "TABLE"

	//Variável private de montagem do browse/markbrowse
	Private oObjBrw

	//Define o valor padrão dos parâmetros
	Default lTotScr := .T.
	Default cTitDlg := ""
	Default aCpsCab := {}
	Default aLegBrw := {}
	Default lMrkBrw := .F.
	Default cChgLin := "{ || }"
	Default cButEnc := "C/F/L/R/S"
	Default aCpoLmp := {}
	Default cVldCnf := ".T."
	Default lJstOne := .F.
	Default cVldLin := "{ || .T. }"
	Default cAftAdd := "{ || .T. }"
	Default lDelLin := .F.
	Default cVldExc := ".T."
	Default aCpsPsq := {}

	//Define as variáveis após passar pelos valores default
	lCabBrw := Len( aCpsCab ) > 0
	lLegBrw := Len( aLegBrw ) > 0
	lPsqBrw := Len( aCpsPsq ) > 0

	//Define o tamanho da dialog de acordo com o parâmetro
	If lTotScr

		//Busca o tamanho da tela
		aTamTel := MsAdvSize( .T., .F., 430 )

		//Define as coordenadas da dialog
		nLinIni := aTamTel[ 7 ]
		nLinFim := aTamTel[ 6 ]
		nColIni := 0
		nColFim := aTamTel[ 5 ]

	Else

		//Define as coordenadas da dialog
		nLinIni := 0
		nLinFim := 500
		nColIni := 0
		nColFim := 800

	EndIf

	//------------------------------
	// Criação do browse/markbrowse
	//------------------------------
	//Define a dialog
	oDialog := MSDialog():New( nLinIni, nColIni, nLinFim, nColFim, cTitDlg, , , , , , , , , .T., , , , .T. )

	//Cria o painel principal
	oPnlTot := TPanel():New( , , , oDialog )
	oPnlTot:Align := CONTROL_ALIGN_ALLCLIENT

	//Caso deva ser criado um cabeçalho no browse
	If lCabBrw

		//Cria o painel do topo referente ao cabeçalho
		oPnlTop := TPanel():New( , , , oPnlTot , , , , , , , 40 )
		oPnlTop:Align := CONTROL_ALIGN_TOP

		//Cria o cabeçalho do markbrowse
		For nCont := 1 To Len( aCpsCab )

			//Define as variáveis para montagem dos campos Say e Get
			nLinSay := aCpsCab[ nCont, 1 ]
			nColSay := aCpsCab[ nCont, 2 ]
			bSayNam := aCpsCab[ nCont, 3 ]
			nSayWid := aCpsCab[ nCont, 4 ]
			nSayHgh := aCpsCab[ nCont, 5 ]
			nLinGet := aCpsCab[ nCont, 6 ]
			nColGet := aCpsCab[ nCont, 7 ]
			bGetCon := aCpsCab[ nCont, 8 ]
			nGetWid := aCpsCab[ nCont, 9 ]
			nGetHgh := aCpsCab[ nCont, 10 ]
			cGetPic := aCpsCab[ nCont, 11 ]
			bGetVld := aCpsCab[ nCont, 12 ]
			bGetWhe := aCpsCab[ nCont, 13 ]
			lGetRea := aCpsCab[ nCont, 14 ]
			lGetPsw := aCpsCab[ nCont, 15 ]
			cGetVar := aCpsCab[ nCont, 16 ]
			lGetHBu := aCpsCab[ nCont, 17 ]
			lGetNBu := aCpsCab[ nCont, 18 ]
			cGetPHo := aCpsCab[ nCont, 19 ]

			//Define os campos de Say e Get
			TSay():New( nLinSay, nColSay, bSayNam, oPnlTop, , , .F., .F., .F., .T., CLR_BLACK, CLR_WHITE, nSayWid, nSayHgh )
			TGet():New( nLinGet, nColGet, bGetCon, oPnlTop, nGetWid, nGetHgh, cGetPic, bGetVld, CLR_BLACK, CLR_WHITE, , .F., , .T., , .F., bGetWhe, .F., .F., , lGetRea, lGetPsw, "", cGetVar, , , , lGetHBu, lGetNBu, , , , , , cGetPHo )

		Next nCont

	EndIf

	//Cria o objeto do browse/markbrowse
	oObjBrw := FwBrowse():New()

	//Define o objeto pai
	oObjBrw:SetOwner( oPnlTot )

	//Caso for criação do objeto a partir de um array
	If lDataArr

		//Define a utilização por array
		oObjBrw:SetDataArray()

		//Define o array
		oObjBrw:SetArray( xObjCrt )

	EndIf

	//Caso for criação do objeto a partir de uma tabela
	If lDataTab

		//Define a utilização por tabela
		oObjBrw:SetDataTable()

		//Define o alias
		oObjBrw:SetAlias( xObjCrt )

	EndIf

	//Define a legenda (caso necessário)
	If lLegBrw

		//Percorre as legendas
		For nCont := 1 To Len( aLegBrw )

			//Define a legenda
			oObjBrw:AddLegend( aLegBrw[ nCont, 1 ], aLegBrw[ nCont, 2 ], aLegBrw[ nCont, 3 ] )

		Next nCont

	EndIf

	//Caso for montagem de markbrowse
	If lMrkBrw

		//Define a coluna de marcação
		oObjBrw:AddMarkColumns( { || fMark( 1, cMarca, xObjCrt, lJstOne ) }, ; //bMark
		{ || fMark( 2, cMarca, xObjCrt, lJstOne, aCpoLmp ) }, ; //bLDblClick
		{ || fMark( 3, cMarca, xObjCrt, lJstOne, aCpoLmp ) } ) //bHeaderClick

	EndIf

	//Define as colunas do browse/markbrowse
	oObjBrw:SetColumns( fCrtColBrw( aHeaCol, xObjCrt ) ) //Chama a função de estruturação das colunas

	//Define se será permitido a adição de novas linhas
	oObjBrw:SetInsert( lInsBrw )

	//Define se será permitido a edição de células
	oObjBrw:SetEditCell( lEdtCel )

	//Define o bloco de código executado na validação da linha
	oObjBrw:SetLineOk( &( cVldLin ) )

	//Define o bloco de código executado na mudança de linha
	oObjBrw:SetChange( &( cChgLin ) )

	//Define o bloco de código a ser executado ao adicionar uma linha nova
	oObjBrw:SetAfterAddLine( &( cAftAdd ) )

	//Caso o browse deva aceitar a deleção de registros
	If lDelLin

		//Define a cor das linhas do browse
		oObjBrw:SetBlkBackColor( { || fGetCorLin( oObjBrw, xObjCrt ) } )

		//Define a função a ser chamada para excluir os registros
		oObjBrw:SetDelete( .T., { || IIf( &( cVldExc ), fExcLin( oObjBrw, xObjCrt ), .F. ) } )

	EndIf

	//Define os itens de pesquisa do browse (caso necessário)
	If lPsqBrw

		//Define os itens da pesquisa
		oObjBrw:SetSeek( { || .T. }, aCpsPsq )

	EndIf

	//------------------------------------------------------
	// Define os botões que não serão mostrados na enchoice
	//------------------------------------------------------
	//Caso o botão de configuração deva ser desabilitado
	If "C" $ cButEnc
		oObjBrw:DisableConfig()
	EndIf

	//Caso o botão de filtro deva ser desabilitado
	If "F" $ cButEnc
		oObjBrw:DisableFilter()
	EndIf

	//Caso o botão de localização deva ser desabilitado
	If "L" $ cButEnc
		oObjBrw:DisableLocate()
	EndIf

	//Caso o botão de impressão deva ser desabilitado
	If "R" $ cButEnc
		oObjBrw:DisableReport()
	EndIf

	//Caso o botão de salvar a configuração deva ser desabilitado
	If "S" $ cButEnc
		oObjBrw:DisableSaveConfig()
	EndIf

	//Ativa o browse/markbrowse
	oObjBrw:Activate()

	oDialog:Activate( , , , .T., , , EnchoiceBar( oDialog, ;
		{ || IIf( &( cVldCnf ), ( lConfirm := .T., oDialog:End() ), ) }, ;
		{ || lConfirm := .F., oDialog:End() } ) )

	//Retorna a área
	RestArea( aArea )

Return lConfirm

//---------------------------------------------------------------------
/*/{Protheus.doc} fCrtColBrw
Função genérica que realiza a criação dos campos das colunas do browse/markbrowse

@sample	fCrtColBrw( { { "TNF_CODEPI", "TNF_DSCEPI" } } )

@param	aHeaCol, Array, Array contendo os campos pra que deverão ser criadas as colunas
@param	xObjCrt, Array/Caracter, Objeto utilizado na montagem do browse/markbrowse

@author	Luis Fellipy Bett
@since	12/04/2022

@return aColunas, Array, Array contendo as colunas do browse/markbrowse
/*/
//---------------------------------------------------------------------
Static Function fCrtColBrw( aHeaCol, xObjCrt )

	//Salva a área
	Local aArea := GetArea()

	//Variáveis de busca das informações
	Local aColunas := {}
	Local cTitCpo := ""
	Local cTipCpo := ""
	Local cPicCpo := ""
	Local nTamCpo := 0
	Local cDatCpo := ""
	Local cVldCpo := ""

	//Variáveis contadoras
	Local nCont := 0

	//Percorre os campos do header
	For nCont := 1 To Len( aHeaCol )

		//Posiciona no SX3 para verifica se o campo existe no dicionário
		dbSelectArea( "SX3" )
		dbSetOrder( 2 )

		//Caso o campo exista no dicionário
		If dbSeek( aHeaCol[ nCont, 1 ] )

			lEdtCpo := aHeaCol[ nCont, 2 ]
			cTitCpo := X3Titulo( aHeaCol[ nCont, 1 ] )
			cDatCpo := IIf( !Empty( X3CBox( aHeaCol[ nCont, 1 ] ) ), '{ || NGRetSX3Box( "' + aHeaCol[ nCont, 1 ] + '", Eval( ' + aHeaCol[ nCont, 4 ] + ' ) ) }', aHeaCol[ nCont, 4 ] )
			cTipCpo := GetSx3Cache( aHeaCol[ nCont, 1 ], "X3_TIPO" )
			cPicCpo := X3Picture( aHeaCol[ nCont, 1 ] )
			nTamCpo := TAMSX3( aHeaCol[ nCont, 1 ] )[1]
			nTamDec := TAMSX3( aHeaCol[ nCont, 1 ] )[2]
			aCboBox := IIf( cTipCpo == "C" .And. !Empty( X3Cbox() ), StrTokArr( X3Cbox(), ";" ), {} )
			cVldCpo := aHeaCol[ nCont, 10 ]

		Else

			lEdtCpo := aHeaCol[ nCont, 2 ]
			cTitCpo := aHeaCol[ nCont, 3 ]
			cDatCpo := aHeaCol[ nCont, 4 ]
			cTipCpo := aHeaCol[ nCont, 5 ]
			cPicCpo := aHeaCol[ nCont, 6 ]
			nTamCpo := aHeaCol[ nCont, 7 ]
			nTamDec := aHeaCol[ nCont, 8 ]
			aCboBox := aHeaCol[ nCont, 9 ]
			cVldCpo := aHeaCol[ nCont, 10 ]

		EndIf

		//Cria uma nova coluna
		oColuna := FWBrwColumn():New()

		//Define o título da coluna
		oColuna:SetTitle( cTitCpo )

		//Define o tipo da coluna
		oColuna:SetType( cTipCpo )

		//Define a picture da coluna
		oColuna:SetPicture( cPicCpo )

		//Define o tamanho da coluna
		oColuna:SetSize( nTamCpo + nTamDec )

		//Define o alinhamento da coluna
		oColuna:SetAlign( IIf( cTipCpo == "N", CONTROL_ALIGN_RIGHT, CONTROL_ALIGN_LEFT ) )

		//Define o conteúdo da coluna
		oColuna:SetData( &( cDatCpo ) )

		//Define se a coluna pode ser editada
		oColuna:SetEdit( lEdtCpo )

		//Define o nome da coluna
		oColuna:SetReadVar( aHeaCol[ nCont, 1 ] )

		//Define a validação da coluna
		If lDataArr //Caso for montagem a partir de array

			//Define a função que valida e adiciona o valor ao campo
			oColuna:SetValid( fVldSetVal( &( cVldCpo ) ) )

		ElseIf lDataTab //Caso for montagem a partir de tabela

			//Seta direto o bloco de código de validação
			oColuna:SetValid( &( cVldCpo ) )

		EndIf

		//Define o combobox do campo
		If Len( aCboBox ) > 0
			oColuna:SetOptions( aCboBox )
		EndIf

		//Adiciona a coluna no array de retorno
		aAdd( aColunas, oColuna )

	Next nCont

	//Retorna a área
	RestArea( aArea )

Return aColunas

//---------------------------------------------------------------------
/*/{Protheus.doc} fExcLin
Realiza a exclusão da linha

@return	lDelLin, Boolean, Indica se a linha pode ser deletada ou não

@param	oObjBrw, Objeto, Objeto do browse/markbrowse gerado a partir da função MDTFwBrwse
@param	xObjCrt, Array/Caracter, Objeto utilizado na montagem do browse/markbrowse

@sample	fExcLin( oObjBrw, "SGC00236" )

@author	Luis Fellipy Bett
@since	22/05/2022
/*/
//---------------------------------------------------------------------
Static Function fExcLin( oObjBrw, xObjCrt )

	//----------------------------------------------------------
	// Exclui/recupera a linha de acordo com o campo de deleção
	//----------------------------------------------------------
	If lDataArr //Caso a criação do objeto seja a partir de um array

		//Caso a última posição do array for igual a .T.
		If xObjCrt[ oObjBrw:nAt, Len( xObjCrt[ 1 ] ) ]

			//Define a linha como não deletada
			xObjCrt[ oObjBrw:nAt, Len( xObjCrt[ 1 ] ) ] := .F.

		Else

			//Define a linha como deletada
			xObjCrt[ oObjBrw:nAt, Len( xObjCrt[ 1 ] ) ] := .T.

		EndIf

	ElseIf lDataTab //Caso a criação do objeto seja a partir de uma tabela

		//Caso a última posição do array for igual a .T.
		If ( xObjCrt )->REGDEL

			//Define a coluna como não deletada
			( xObjCrt )->REGDEL := .F.

		Else

			//Define a coluna como deletada
			( xObjCrt )->REGDEL := .T.

		EndIf

	EndIf

	//Atualiza a cor da linha
	oObjBrw:SetBlkBackColor( { || fGetCorLin( oObjBrw, xObjCrt ) } )

	//Atualiza o browse
	oObjBrw:Refresh()

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fGetCorLin
Função responsável por retornar a cor das linhas do browse. Foi necessária
a implementação dessa função pois o objeto FWBrowse não está preparado para
fazer a atualização da cor de acordo com a exclusão da linha como deveria.
Um dia talvez eles implementem isso e funcione sem gambiarra mas hoje 
(06/06/2022) não funciona.

@return	cCorLin, Caracter, Cor da linha a ser pintada

@param	oObjBrw, Objeto, Objeto do browse/markbrowse gerado a partir da função MDTFwBrwse
@param	xObjCrt, Array/Caracter, Objeto utilizado na montagem do browse/markbrowse

@sample	fGetCorLin( oObjBrw, "SCG000236" )

@author	Luis Fellipy Bett
@since	06/06/2022
/*/
//---------------------------------------------------------------------
Static Function fGetCorLin( oObjBrw, xObjCrt )

	//------------------------------------------------------------------
	// Define a cor da linha deletada de acordo com o objeto de criação
	//------------------------------------------------------------------
	If lDataArr //Caso a criação do objeto seja a partir de um array

		//Caso a linha esteja deletada
		If xObjCrt[ oObjBrw:nAt, Len( xObjCrt[ 1 ] ) ]

			//Define a cor como cinza claro
			cCorLin := CLR_HGRAY

		Else

			//Caso a linha for par
			If oObjBrw:nAt % 2 == 0

				//Define a cor como azul claro
				cCorLin := RGB( 178, 203, 231 )

			Else //Caso a linha for ímpar

				//Define a cor como branco
				cCorLin := CLR_WHITE

			EndIf

		EndIf

	ElseIf lDataTab //Caso a criação do objeto seja a partir de uma tabela

		//Caso a linha esteja deletada
		If ( xObjCrt )->REGDEL

			//Define a cor como cinza claro
			cCorLin := CLR_HGRAY

		Else

			//Caso a linha for par
			If ( xObjCrt )->( Recno() ) % 2 == 0

				//Define a cor como azul claro
				cCorLin := RGB( 178, 203, 231 )

			Else //Caso a linha for ímpar

				//Define a cor como branco
				cCorLin := CLR_WHITE

			EndIf

		EndIf

	EndIf

Return cCorLin

//---------------------------------------------------------------------
/*/{Protheus.doc} fVldSetVal
Valida o valor inputado no campo e realiza uma gambiarra para adicionar
o valor na posição do array. Essa POG (programação orientada a gambiarra)
foi necessária pois o objeto FWBrowse simplesmente não funciona a ponto
de salvar o valor digitado na coluna quando o objeto de criação é um
array. Um dia talvez eles implementem isso e funcione sem gambiarra mas
hoje (02/06/2022) não funciona.

@return	Bloco de código, Expressão responsável por validar o valor e adicionar à posição do array

@param	bVal, Bloco de código, Indica qual o bloco de código a ser executada para validação do campo

@sample	fVldSetVal( { || fVldDado() } )

@author	Luis Fellipy Bett
@since	02/06/2022
/*/
//---------------------------------------------------------------------
Static Function fVldSetVal( bVal )

Return { || IIf( Eval( bVal ), ( oObjBrw:oData:aArray[ oObjBrw:At(), oObjBrw:ColPos() ] := &( ReadVar() ), .T. ), .F. ) }

//---------------------------------------------------------------------
/*/{Protheus.doc} fMark
Realiza marcações no markbrowse

@return	Nil, Nulo

@param	nOpcClk, Numérico, Indica qual opção de click está sendo executada (1- bMark, 2- bLDblClick, 3- bHeaderClick)
@param	cMarca, Caracter, Valor da marca
@param	xObjCrt, Array/Caracter, Objeto utilizado na montagem do markbrowse
@param	lJstOne, Boolean, Indica se apenas um registro do markbrowse ficará selecionado
@param	aCpoLmp, Array, Array contendo os campos a serem limpos ao deselecionar uma linha do mark

@sample	fMark( 2, "AC", "SGC00236", { FORNEC } )

@author	Luis Fellipy Bett
@since	11/04/2022
/*/
//---------------------------------------------------------------------
Static Function fMark( nOpcClk, cMarca, xObjCrt, lJstOne, aCpoLmp )

	//Salva a área
	Local aArea := GetArea()

	//Variáveis de busca das informações
	Local cRet := ""
	Local nReg := 1

	//Variáveis contadoras
	Local nCont := 0

	//-----------------------------------------------------------------------------------------
	// Define os trechos de marcação de acordo com cada opção de montagem do browse/markbrowse
	//-----------------------------------------------------------------------------------------
	If lDataArr //Caso a criação do objeto seja a partir de um array

		If nOpcClk == 1 //bMark

			//Verifica se o registro está selecionado
			cRet := IIf( xObjCrt[ oObjBrw:nAt, 1 ], "LBTIK", "LBNO" )

		ElseIf nOpcClk == 2 .Or. nOpcClk == 3 //bLDblClick ou bHeaderClick

			//bLDblClick
			If nOpcClk == 2

				//Inverte o conteúdo do campo de marcação
				xObjCrt[ oObjBrw:nAt, 1 ] := !xObjCrt[ oObjBrw:nAt, 1 ]

				//Caso apenas um registro deva estar selecionado no mark
				If lJstOne
					fJstOneSel( xObjCrt )
				EndIf

			ElseIf nOpcClk == 3 //bHeaderClick

				//Percorre o array invertendo as marcações
				For nCont := 1 To Len( xObjCrt )

					//Inverte o conteúdo do campo de marcação
					xObjCrt[ nCont, 1 ] := !xObjCrt[ nCont, 1 ]

				Next nCont

			EndIf

			//Atualiza o markbrowse
			oObjBrw:Refresh()

		EndIf

	ElseIf lDataTab //Caso a criação do objeto seja a partir de uma tabela

		If nOpcClk == 1 //bMark

			//Verifica se o registro está selecionado
			cRet := IIf( ( xObjCrt )->OK == cMarca, "LBTIK", "LBNO" )

		ElseIf nOpcClk == 2 .Or. nOpcClk == 3 //bLDblClick ou bHeaderClick

			//Salva o registro posicionado
			nReg := ( xObjCrt )->( Recno() )

			//bLDblClick
			If nOpcClk == 2

				RecLock( xObjCrt, .F. )

				( xObjCrt )->OK := IIf( Empty( ( xObjCrt )->OK ), cMarca, "  " )

				//Caso o registro foi desmarcado
				If Empty( ( xObjCrt )->OK )

					//Caso existam campos a serem limpos
					If Len( aCpoLmp ) > 0

						//Limpa os campos do registro desselecionado
						fClearCpos( xObjCrt, aCpoLmp )

					EndIf

				EndIf

				( xObjCrt )->( MsUnLock() )

				//Caso apenas um registro deva estar selecionado no mark
				If lJstOne
					fJstOneSel( xObjCrt )
				EndIf

			ElseIf nOpcClk == 3 //bHeaderClick

				//Posiciona no alias do browse
				dbSelectArea( xObjCrt )
				( xObjCrt )->( dbGoTop() )

				//Percorre os registros da tabela invertendo as marcações
				While ( xObjCrt )->( !Eof() )

					//Percorre toda a tabela temporária invertendo as marcações
					RecLock( xObjCrt, .F. )

					( xObjCrt )->OK := IIf( Empty( ( xObjCrt )->OK ), cMarca, "  " )

					//Caso o registro foi desmarcado
					If Empty( ( xObjCrt )->OK )

						//Caso existam campos a serem limpos
						If Len( aCpoLmp ) > 0

							//Limpa os campos do registro desselecionado
							fClearCpos( xObjCrt, aCpoLmp )

						EndIf

					EndIf

					( xObjCrt )->( MsUnLock() )

					//Pula o registro
					( xObjCrt )->( dbSkip() )

				End

			EndIf

			//Posiciona novamente no registro posicionado
			dbSelectArea( xObjCrt )
			( xObjCrt )->( dbGoTo( nReg ) )

			//Define se será permitido a edição de células no browse
			oObjBrw:SetEditCell( !Empty( ( xObjCrt )->OK  ) )

			//Atualiza o markbrowse
			oObjBrw:Refresh()

		EndIf

	EndIf

	//Retorna a área
	RestArea( aArea )

Return cRet

//---------------------------------------------------------------------
/*/{Protheus.doc} fClearCpos
Limpa os campos passados por parâmetro quando o registro for desselecionado

@return	Nil, Nulo

@param	xObjCrt, Array/Caracter, Objeto utilizado na montagem do markbrowse
@param	aCpoLmp, Array, Array com os campos a serem limpos/zerados

@sample	fClearCpos( "SGC00236", { "FORNEC", "EPIFIL" } )

@author	Luis Fellipy Bett
@since	11/05/2022
/*/
//---------------------------------------------------------------------
Static Function fClearCpos( xObjCrt, aCpoLmp )

	//Variáveis contadoras
	Local nCont := 0

	//Percorre os campos limpando
	For nCont := 1 To Len( aCpoLmp )

		//Limpa o conteúdo do campo
		If ValType( ( xObjCrt )->( &( aCpoLmp[ nCont ] ) ) ) == "C"

			( xObjCrt )->( &( aCpoLmp[ nCont ] ) ) := ""

		ElseIf ValType( ( xObjCrt )->( &( aCpoLmp[ nCont ] ) ) ) == "D"

			( xObjCrt )->( &( aCpoLmp[ nCont ] ) ) := SToD( "" )

		ElseIf ValType( ( xObjCrt )->( &( aCpoLmp[ nCont ] ) ) ) == "N"

			( xObjCrt )->( &( aCpoLmp[ nCont ] ) ) := 0

		EndIf

	Next nCont

Return

//---------------------------------------------------------------------
/*/{Protheus.doc} fJstOneSel
Desmarca todos os registros menos o posicionado para manter apenas um
registro selecionado no mark

@return	Nil, Nulo

@param	xObjCrt, Array/Caracter, Objeto utilizado na montagem do markbrowse

@sample	fJstOneSel( "SGC00236" )

@author	Luis Fellipy Bett
@since	22/04/2022
/*/
//---------------------------------------------------------------------
Static Function fJstOneSel( xObjCrt )

	//Salva a área
	Local aArea := GetArea()

	//Variáveis de controle
	Local nLinPos := 0

	//Variáveis contadoras
	Local nCont := 0

	//--------------------------------------------------------------
	// Define os trechos para manter apenas um registro selecionado
	// de acordo com cada opção de montagem do browse/markbrowse
	//--------------------------------------------------------------
	If lDataArr //Caso a criação do objeto seja a partir de um array

		//Pega a linha posicionada
		nLinPos := oObjBrw:nAt

		//Percorre as linhas do markbrowse desmarcando todas menos a posicionada
		For nCont := 1 To Len( xObjCrt )

			//Caso a linha do laço for diferente da posicionada
			If nCont != nLinPos

				//Define a linha como desmarcada
				xObjCrt[ nCont, 1 ] := .F.

			EndIf

		Next nCont

	ElseIf lDataTab //Caso a criação do objeto seja a partir de uma tabela

		//Pega a linha posicionada
		nLinPos := ( xObjCrt )->( Recno() )

		//Posiciona no alias do browse
		dbSelectArea( xObjCrt )
		( xObjCrt )->( dbGoTop() )

		//Percorre as linhas do markbrowse desmarcando todas menos a posicionada
		While ( xObjCrt )->( !Eof() )

			//Caso a linha do laço for diferente da posicionada
			If ( xObjCrt )->( Recno() ) != nLinPos

				//Define a linha como desmarcada
				RecLock( xObjCrt, .F. )

				( xObjCrt )->OK := "  "

				( xObjCrt )->( MsUnLock() )

			EndIf

			//Pula o registro
			( xObjCrt )->( dbSkip() )

		End

	EndIf

	//Retorna a área
	RestArea( aArea )

Return

//-------------------------------------------------------------------------
/*/{Protheus.doc} MdtAjBase
Função responsável por inicar uma Thread para realizar ajustes ao entrar
no modulo de manutenção de ativos.

Funções com Versão igual a 0 é que devem sempre ser executadas.

@author  Elisson França
@since   30/08/2022
@version undefined

@param cEmpAnt,    Caractér, Código Empresa
@param cFilAnt,    Caractér, Código Filial
@param cCodUser,   Caractér, Código Usuário
@param cMod, Caractér, Modulo MDT (35)

@type function
/*/
//-------------------------------------------------------------------------
Function MdtAjBase(cEmpAnt,cFilAnt,cCodUser,cMod)

	Local nX        := 0
	Local cArqFun   := 'mdtatu.ngi'
	Local aFunctOld := {}

	Default cCodUser := ""

	If !File(cArqFun) 	//Verifica se o arquivo de atualização existe, caso não exista cria o mesmo.
		
		nArqAtu := fCreate(cArqFun) // Cria arquivo.

		fWrite(nArqAtu, cEmpAnt + cFilAnt + "#" + "fMdtTy7Tmy" )

		fClose(nArqAtu) // Fecha arquivo.
		
		//Executa o compatibilizador
		fMdtTy7Tmy()

	Else

		// Abre o arquivo
		nArqAtu := FT_FUse(cArqFun)

		// Posiciona na primeira linha
		FT_FGoTop()

		While !FT_FEOF()

			cLine  := FT_FReadLn()

			// Salva na primeira posição do array a Empresa e Filial, na segunda posição as funções.
			aAdd( aFunctOld , {SubStr(cLine,1,At( "#", cLine )-1), SubStr(cLine,At( "#", cLine ),Len(cLine))})

			FT_FSKIP()
		End

		// Fecha o arquivo
		FT_FUSE()

		// Busca a empresa e filial.
		If aScan( aFunctOld,{ |x| AllTrim( x[1] ) == AllTrim( cEmpAnt+cFilAnt ) } ) == 0

			fClose(nArqAtu) // Fecha arquivo.

			FErase(cArqFun) // Realiza a exclusão do arquivo.

			nArqAtu := fCreate(cArqFun) // Cria o arquivo novo.

			For nX := 1 To Len(aFunctOld)
				fWrite(nArqAtu, aFunctOld[nX,1] + aFunctOld[nX,2]  )
				fWrite(nArqAtu,chr(13)+chr(10))
			Next nX

			fWrite(nArqAtu, cEmpAnt + cFilAnt + "#" + "fMdtTy7Tmy")

			//Executa o compatibilizador
			fMdtTy7Tmy()
			
			fClose(nArqAtu) // Fecha o arquivo.
		EndIf
	EndIf
	
Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc} fMdtTy7Tmy
Verifica a existência das permissões de trabalho na tabela TY7 e 
preenche a tabela TMY caso vinculada a permissão de trabalho no ASO
com os novos campos da TMY

@author Elisson França
@since  30/08/2022

@return Vazio.
/*/
//---------------------------------------------------------------------

Static Function fMdtTy7Tmy()

	Local cQuery := ''

	If TMY->(ColumnPos("TMY_PLAT")) > 0

		cQuery += "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_PLAT = '1' "
		cQuery += "WHERE TMY_NUMASO "
		cQuery += "IN ( "
		cQuery += "SELECT TY7.TY7_NUMASO "
		cQuery += "FROM " + RetSqlName("TY7") + " TY7 "
		cQuery += "WHERE TY7.D_E_L_E_T_ = '' "
		cQuery += "AND TMY_NUMASO = TY7.TY7_NUMASO "
		cQuery += "AND TY7.TY7_FILIAL = " + ValToSql(xFilial("TY7"))
		cQuery += "AND TY7.TY7_TIPERM = '1'  )"
		cQuery += "AND D_E_L_E_T_ = '' "
		cQuery += "AND TMY_FILIAL =  " + ValToSql(xFilial("TMY"))
		TcSqlExec( cQuery )

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_PLAT = '2' "
		cQuery += "WHERE TMY_PLAT = '' AND D_E_L_E_T_ = '' "
		TcSqlExec( cQuery )

	EndIf

	// Atualizacao do Valor do campo TMY_MANCIV de acordo com a existencia de permissoes
	If TMY->(ColumnPos("TMY_MANCIV")) > 0

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_MANCIV = '1' "
		cQuery += "WHERE TMY_NUMASO "
		cQuery += "IN ( "
		cQuery += "SELECT TY7.TY7_NUMASO "
		cQuery += "FROM " + RetSqlName("TY7") + " TY7 "
		cQuery += "WHERE TY7.D_E_L_E_T_ = '' "
		cQuery += "AND TMY_NUMASO = TY7.TY7_NUMASO "
		cQuery += "AND TY7.TY7_FILIAL = " + ValToSql(xFilial("TY7"))
		cQuery += "AND TY7.TY7_TIPERM = '2'  )"
		cQuery += "AND D_E_L_E_T_ = '' "
		cQuery += "AND TMY_FILIAL =  " + ValToSql(xFilial("TMY"))
		TcSqlExec( cQuery )

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_MANCIV = '2' "
		cQuery += "WHERE TMY_MANCIV = '' AND D_E_L_E_T_ = '' "
		TcSqlExec( cQuery )

	EndIf

	// Atualizacao do Valor do campo TMY_EXPLO de acordo com a existencia de permissoes
	If TMY->(ColumnPos("TMY_EXPLO")) > 0

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_EXPLO = '1' "
		cQuery += "WHERE TMY_NUMASO "
		cQuery += "IN ( "
		cQuery += "SELECT TY7.TY7_NUMASO "
		cQuery += "FROM " + RetSqlName("TY7") + " TY7 "
		cQuery += "WHERE TY7.D_E_L_E_T_ = '' "
		cQuery += "AND TMY_NUMASO = TY7.TY7_NUMASO "
		cQuery += "AND TY7.TY7_FILIAL = " + ValToSql(xFilial("TY7"))
		cQuery += "AND TY7.TY7_TIPERM = '3'  )"
		cQuery += "AND D_E_L_E_T_ = '' "
		cQuery += "AND TMY_FILIAL =  " + ValToSql(xFilial("TMY"))
		TcSqlExec( cQuery )

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_EXPLO = '2' "
		cQuery += "WHERE TMY_EXPLO = '' AND D_E_L_E_T_ = '' "
		TcSqlExec( cQuery )

	EndIf

	// Atualizacao do Valor do campo TMY_ALTURA de acordo com a existencia de permissoes
	If TMY->(ColumnPos("TMY_ALTURA")) > 0

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_ALTURA = '1' "
		cQuery += "WHERE TMY_NUMASO "
		cQuery += "IN ( "
		cQuery += "SELECT TY7.TY7_NUMASO "
		cQuery += "FROM " + RetSqlName("TY7") + " TY7 "
		cQuery += "WHERE TY7.D_E_L_E_T_ = '' "
		cQuery += "AND TMY_NUMASO = TY7.TY7_NUMASO "
		cQuery += "AND TY7.TY7_FILIAL = " + ValToSql(xFilial("TY7"))
		cQuery += "AND TY7.TY7_TIPERM = '4'  )"
		cQuery += "AND D_E_L_E_T_ = '' "
		cQuery += "AND TMY_FILIAL =  " + ValToSql(xFilial("TMY"))
		TcSqlExec( cQuery )

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_ALTURA = '2' "
		cQuery += "WHERE TMY_ALTURA = '' AND D_E_L_E_T_ = '' "
		TcSqlExec( cQuery )

	EndIf

	// Atualizacao do Valor do campo TMY_ESCAV de acordo com a existencia de permissoes
	If TMY->(ColumnPos("TMY_ESCAV")) > 0

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_ESCAV = '1' "
		cQuery += "WHERE TMY_NUMASO "
		cQuery += "IN ( "
		cQuery += "SELECT TY7.TY7_NUMASO "
		cQuery += "FROM " + RetSqlName("TY7") + " TY7 "
		cQuery += "WHERE TY7.D_E_L_E_T_ = '' "
		cQuery += "AND TMY_NUMASO = TY7.TY7_NUMASO "
		cQuery += "AND TY7.TY7_FILIAL = " + ValToSql(xFilial("TY7"))
		cQuery += "AND TY7.TY7_TIPERM = '5'  )"
		cQuery += "AND D_E_L_E_T_ = '' "
		cQuery += "AND TMY_FILIAL =  " + ValToSql(xFilial("TMY"))
		TcSqlExec( cQuery )

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_ESCAV = '2' "
		cQuery += "WHERE TMY_ESCAV = '' AND D_E_L_E_T_ = '' "
		TcSqlExec( cQuery )

	EndIf

	// Atualizacao do Valor do campo TMY_ELETRI de acordo com a existencia de permissoes
	If TMY->(ColumnPos("TMY_ELETRI")) > 0

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_ELETRI = '1' "
		cQuery += "WHERE TMY_NUMASO "
		cQuery += "IN ( "
		cQuery += "SELECT TY7.TY7_NUMASO "
		cQuery += "FROM " + RetSqlName("TY7") + " TY7 "
		cQuery += "WHERE TY7.D_E_L_E_T_ <> '*' "
		cQuery += "AND TMY_NUMASO = TY7.TY7_NUMASO "
		cQuery += "AND TY7.TY7_FILIAL = " + ValToSql(xFilial("TY7"))
		cQuery += "AND TY7.TY7_TIPERM = '6'  )"
		cQuery += "AND D_E_L_E_T_ <> '*' "
		cQuery += "AND TMY_FILIAL =  " + ValToSql(xFilial("TMY"))
		TcSqlExec( cQuery )

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_ELETRI = '2' "
		cQuery += "WHERE TMY_ELETRI = '' AND D_E_L_E_T_ <> '*' "
		TcSqlExec( cQuery )

	EndIf

	// Atualizacao do Valor do campo TMY_SOLDA de acordo com a existencia de permissoes
	If TMY->(ColumnPos("TMY_SOLDA")) > 0

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_SOLDA = '1' "
		cQuery += "WHERE TMY_NUMASO "
		cQuery += "IN ( "
		cQuery += "SELECT TY7.TY7_NUMASO "
		cQuery += "FROM " + RetSqlName("TY7") + " TY7 "
		cQuery += "WHERE TY7.D_E_L_E_T_ = '' "
		cQuery += "AND TMY_NUMASO = TY7.TY7_NUMASO "
		cQuery += "AND TY7.TY7_FILIAL = " + ValToSql(xFilial("TY7"))
		cQuery += "AND TY7.TY7_TIPERM = '7'  )"
		cQuery += "AND D_E_L_E_T_ = '' "
		cQuery += "AND TMY_FILIAL =  " + ValToSql(xFilial("TMY"))
		TcSqlExec( cQuery )

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_SOLDA = '2' "
		cQuery += "WHERE TMY_SOLDA = '' AND D_E_L_E_T_ = '' "
		TcSqlExec( cQuery )

	EndIf

	// Atualizacao do Valor do campo TMY_CONFIN de acordo com a existencia de permissoes
	If TMY->(ColumnPos("TMY_CONFIN")) > 0

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_CONFIN = '1' "
		cQuery += "WHERE TMY_NUMASO "
		cQuery += "IN ( "
		cQuery += "SELECT TY7.TY7_NUMASO "
		cQuery += "FROM " + RetSqlName("TY7") + " TY7 "
		cQuery += "WHERE TY7.D_E_L_E_T_ = '' "
		cQuery += "AND TMY_NUMASO = TY7.TY7_NUMASO "
		cQuery += "AND TY7.TY7_FILIAL = " + ValToSql(xFilial("TY7"))
		cQuery += "AND TY7.TY7_TIPERM = '8'  )"
		cQuery += "AND D_E_L_E_T_ = '' "
		cQuery += "AND TMY_FILIAL =  " + ValToSql(xFilial("TMY"))
		TcSqlExec( cQuery )

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_CONFIN = '2' "
		cQuery += "WHERE TMY_CONFIN = '' AND D_E_L_E_T_ = '' "
		TcSqlExec( cQuery )

	EndIf

	// Atualizacao do Valor do campo TMY_FRIO de acordo com a existencia de permissoes
	If TMY->(ColumnPos("TMY_FRIO")) > 0

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_FRIO = '1' "
		cQuery += "WHERE TMY_NUMASO "
		cQuery += "IN ( "
		cQuery += "SELECT TY7.TY7_NUMASO "
		cQuery += "FROM " + RetSqlName("TY7") + " TY7 "
		cQuery += "WHERE TY7.D_E_L_E_T_ = '' "
		cQuery += "AND TMY_NUMASO = TY7.TY7_NUMASO "
		cQuery += "AND TY7.TY7_FILIAL = " + ValToSql(xFilial("TY7"))
		cQuery += "AND TY7.TY7_TIPERM = '9'  )"
		cQuery += "AND D_E_L_E_T_ = '' "
		cQuery += "AND TMY_FILIAL =  " + ValToSql(xFilial("TMY"))
		TcSqlExec( cQuery )

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_FRIO = '2' "
		cQuery += "WHERE TMY_FRIO = '' AND D_E_L_E_T_ = '' "
		TcSqlExec( cQuery )

	EndIf

	// Atualizacao do Valor do campo TMY_RADIA de acordo com a existencia de permissoes
	If TMY->(ColumnPos("TMY_RADIA")) > 0

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_RADIA = '1' "
		cQuery += "WHERE TMY_NUMASO "
		cQuery += "IN ( "
		cQuery += "SELECT TY7.TY7_NUMASO "
		cQuery += "FROM " + RetSqlName("TY7") + " TY7 "
		cQuery += "WHERE TY7.D_E_L_E_T_ = '' "
		cQuery += "AND TMY_NUMASO = TY7.TY7_NUMASO "
		cQuery += "AND TY7.TY7_FILIAL = " + ValToSql(xFilial("TY7"))
		cQuery += "AND TY7.TY7_TIPERM = 'A'  )"
		cQuery += "AND D_E_L_E_T_ = '' "
		cQuery += "AND TMY_FILIAL =  " + ValToSql(xFilial("TMY"))
		TcSqlExec( cQuery )

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_RADIA = '2' "
		cQuery += "WHERE TMY_RADIA = '' AND D_E_L_E_T_ = '' "
		TcSqlExec( cQuery )

	EndIf

	// Atualizacao do Valor do campo TMY_PRESS de acordo com a existencia de permissoes
	If TMY->(ColumnPos("TMY_PRESS")) > 0

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_PRESS = '1' "
		cQuery += "WHERE TMY_NUMASO "
		cQuery += "IN ( "
		cQuery += "SELECT TY7.TY7_NUMASO "
		cQuery += "FROM " + RetSqlName("TY7") + " TY7 "
		cQuery += "WHERE TY7.D_E_L_E_T_ = '' "
		cQuery += "AND TMY_NUMASO = TY7.TY7_NUMASO "
		cQuery += "AND TY7.TY7_FILIAL = " + ValToSql(xFilial("TY7"))
		cQuery += "AND TY7.TY7_TIPERM = 'B'  )"
		cQuery += "AND D_E_L_E_T_ = '' "
		cQuery += "AND TMY_FILIAL =  " + ValToSql(xFilial("TMY"))
		TcSqlExec( cQuery )

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_PRESS = '2' "
		cQuery += "WHERE TMY_PRESS = '' AND D_E_L_E_T_ = '' "
		TcSqlExec( cQuery )

	EndIf

	// Atualizacao do Valor do campo TMY_OUTROS de acordo com a existencia de permissoes
	If TMY->(ColumnPos("TMY_OUTROS")) > 0

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_OUTROS = '1' "
		cQuery += "WHERE TMY_NUMASO "
		cQuery += "IN ( "
		cQuery += "SELECT TY7.TY7_NUMASO "
		cQuery += "FROM " + RetSqlName("TY7") + " TY7 "
		cQuery += "WHERE TY7.D_E_L_E_T_ = '' "
		cQuery += "AND TMY_NUMASO = TY7.TY7_NUMASO "
		cQuery += "AND TY7.TY7_FILIAL = " + ValToSql(xFilial("TY7"))
		cQuery += "AND TY7.TY7_TIPERM = 'X'  )"
		cQuery += "AND D_E_L_E_T_ = '' "
		cQuery += "AND TMY_FILIAL =  " + ValToSql(xFilial("TMY"))
		TcSqlExec( cQuery )

		cQuery := "UPDATE " + RetSqlName("TMY") + " "
		cQuery += "SET TMY_OUTROS = '2' "
		cQuery += "WHERE TMY_OUTROS = '' AND D_E_L_E_T_ = '' "
		TcSqlExec( cQuery )

	EndIf

Return
