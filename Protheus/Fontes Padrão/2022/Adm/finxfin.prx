#INCLUDE "PROTHEUS.CH"
#INCLUDE "finxfin.ch"
#INCLUDE "FWCSS.CH"
#INCLUDE "SHELL.CH"

Static lMT103DRF	:= !ExistBlock("MT103DRF")
Static __lRelat	    := FwIsInCallStack( 'FINR130' ) .or. FwIsInCallStack( 'FINR150' ) .or. FwIsInCallStack( 'FINR350' )
Static lPLSTITPF	:= NIL
Static __oFlBxFK1	:= Nil
Static __oFlBxFK2	:= Nil
Static __lDicInDB	:= NIL
Static aGetFlBxSE5  := {}
Static __aTmpFils 	:= {}
Static __lTemFK6	:= NIL
Static __lPccBx     := NIL
Static __IssBx	    := NIL
Static __cProc      := ""
Static __cUltFil 
Static __cUltEmp
Static __cIdDoc
Static __cChvFK7
Static __nMoeda	
Static __nDecs	
Static __cQryFK6P   := ""
Static __cQryFK6R   := ""
Static __oPreparB	:= NIL
Static __lFK7Cpos	:= Nil
Static __lCmpoFK1	:= Nil
Static __lCmpoFK2	:= Nil
Static __cQryBxP	:= ""
Static __cQryBxR	:= ""
Static __oPrepFK6	:= NIL
Static __oSomaFK6R	:= Nil 
Static __oSomaFK6P	:= Nil 
Static __oSldtit	:= NIL
Static __cMVFinFix  := NIL
Static _cQryAbtRV	:= ""	//Query E1_VALOR
Static _cQryAbtRS	:= ""	//Query E1_SALDO
Static _aBindAbtR	As Array
Static nOrdTitPai   := 28
Static __cRelease	:= Nil
Static __lTCGQry2	:= Nil
Static __cMVDESCFIN	:= Nil
Static __cMVDTDESCF	:= Nil
Static __lTemFKD	:= NIL
Static __lRpoR33	:= NIL
Static __aSEVstru	:= Nil
Static __aSEZstru	:= Nil
Static __lIncNat	:= .F.

//--- revisão performance UNIFIQUE
Static __lM040Se1	:= NIL
Static __lM040CSSR	:= NIL
Static __lF040MIRF	:= NIL
Static __lF040GER	:= NIL
Static __lF040IRF 	:= NIL
Static __lF040INS 	:= NIL
Static __lF040COF 	:= NIL
Static __lF040PIS 	:= NIL
Static __lF040CSL 	:= NIL
Static __lF040MISS 	:= NIL
Static __lFVldIns	:= NIL
Static __lNTFUNR 	:= NIL
Static __nTamFor	:= NIL
Static __nTamLoja	:= NIL
Static __nTamParc	:= NIL
Static __nTamNat	:= NIL
Static __nMinRetIR	:= NIL
Static __lRMClass	:= NIL
Static __lLjAtuSa	:= NIL
Static __cCliPad    := NIL
Static __cLojaPad   := NIL
Static __lVcAntIss	:= NIL
Static __nMinISS	:= NIL
Static __cModRIss	:= NIL
Static __lVRetIrf	:= NIL
Static __lPccBxCr	:= NIL
Static __lIrPjBxCr	:= NIL
Static __lIRMP232 	:= NIL
Static __nVlInsRet 	:= NIL
Static __lTrfIssF 	:= NIL
Static __nVlMinImp	:= NIL
Static __nDiaUtIss	:= NIL
Static __nDiaIss 	:= NIL
Static __cVencIss 	:= NIL
Static __lFINCTAL	:= NIL
Static __nVRetCOF	:= NIL
Static __nVRetPIS 	:= NIL
Static __nVRetCSLL	:= NIL
Static __lECCia		:= NIL
Static __lIssMunic	:= NIL
Static __lCodRtPCC	:= NIL
Static __nVencto	:= NIL
Static __cCSSNAT	:= NIL
Static __cCSLNAT	:= NIL
Static __cPISNAT	:= NIL
Static __CCOFNAT	:= NIL
Static __lAgFETHA	:= NIL
Static __lLocBRA	:= NIL
Static __lMoedTit	:= NIL
Static __nMCusto 	:= NIL
Static __lCposIMA	:= NIL
Static __lA1RECFMD	:= NIL
Static __lCalcFMP	:= NIL
Static lFumipeq		:= NIL
Static __lFina986 	:= NIL
Static __nTamFJV	:= NIL
Static __cTipAbat   := Nil
//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINXFIN

Funções genéricas do módulo financeiro

@Author Vários
@version 12
@since   09/12/2014

/*/
//-----------------------------------------------------------------------------------------------------
//FINXFUN
#DEFINE DECIMALDECALCULO 12
//FINXFUN
Static aMoedaFin  // Array contendo as descricoes das moedas
Static lF070DES		:= NIL
Static lF070DSCF	:= NIL
Static lDiaDesc		:= NIL
Static __lPFin002	:= NIL
Static lNatSA 		:= NIL
Static nTamBco 		:= 0
Static nTamAge 		:= 0
Static nTamCta 		:= 0
Static nTamChq 		:= 0
Static nTamCPo 		:= 0
Static lCxJurxFin 	:= NIL
//Melhoria Performance CHG
Static lSPBInUse	:= NIL
Static lFADTMOV		:= NIL
Static dDataFin		:= NIL
Static nTamSeq		:= NIL
Static oPrepared	:= NIL
Static __oTXSeek 	:= Nil		// utilizado como Statement
//FINXATU
Static lF040ADLE
Static lFinaleg
Static lF040URET
Static __lFaLegPares
//MATXFUNB
Static __aLayCNAB	:= {}
Static __lPFin001	:= NIL
//MATXATU
Static lTravaSA1	:= ExistBlock("F040TRVSA1")
Static dLastPcc		:= CTOD("22/06/2015")
Static lIsIssBx		:= FindFunction("IsIssBx")
Static lF420ICNB 	:= ExistBlock("F420ICNB")
Static __cBD		As Character // Define banco de dados para procedure SomaAbat utilizar sintaxe correta ("||" ou "+")
Static lFamad 		:= Nil
Static __lAtuSlBco	:= ExistBlock("ATUSLBCO")
//Motor de Retenções
Static __lMotRet    := ExistFunc("FTemMotor") .And. FTemMotor()
Static __cRuPrf 		:='' // used for filters  FINXFIN02_FILFilter(),  Function FINXFIN01_BCOFilter()

Static aAdianta		:= NIL
Static bFilFIE		:= NIL
Static lAdComPart	:= NIL
Static __cSGBD      := Nil 
Static __cQrySE8    := Nil

/*
----------------------------------------------------------------------------
	            Funcoes retiradas do arquivo FINXATU.PRX
----------------------------------------------------------------------------
*/

//-------------------------------------------------------------------
/*/{Protheus.doc} FaGetCodFJV
obtém o código para chave única da tabela FJV
Arquivo original: FINXATU.PRX

@author pequim
@since 09/09/2014
@version 1.0
/*/
//-------------------------------------------------------------------
Function FaGetCodFJV()
Local cCodFJV	 := ""
Local aArea		 := GetArea()
Local cTab		 := ""
Local cQuery	 := ""
Local cCodFJVSx8 := ""
Local cFVJInd2   := FJV->(IndexKey(2))
Local nOrder     := Iif(!Empty(cFVJInd2) .and. Alltrim(cFVJInd2) == "FJV_CODIGO" ,2,0)

If nOrder == 2
	FJV->(DbSetOrder(nOrder))
	While Empty(cCodFJV) .OR. FJV->(DBSEEK(cCodFJV))
		cCodFJV := GetSx8Num("FJV","FJV_CODIGO","FJV_CODIGO"+cEmpAnt,nOrder)
		ConfirmSx8()
	EndDo
Else

	If __nTamFJV == NIL
		__nTamFJV  := TamSX3("FJV_CODIGO")[1]
	Endif

	cTab := GetNextAlias()
    cQuery := "SELECT MAX(FJV_CODIGO) MAXFJV"
    cQuery += " FROM "+RetSqlName("FJV")+" FJV"
    cQuery += " WHERE D_E_L_E_T_ = ' ' "
    cQuery := ChangeQuery(cQuery)

    If Select(cTab) > 0
        (cTab)->(dbCloseArea())
    EndIf

    dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cTab, .T., .T.)
		
    // Tratamento para formatação do Valor retornado na consulta
    cCodFJV := Left((cTab)->MAXFJV, __nTamFJV)
    If Len(AllTrim(cCodFJV)) < __nTamFJV
        cCodFJV := PadL(cCodFJV,__nTamFJV,"0")
    EndIf
    (cTab)->(dbCloseArea())
	
    While EMPTY(cCodFJVSx8) .OR. cCodFJVSx8 <= cCodFJV
        cCodFJVSx8 := GetSx8Num("FJV","FJV_CODIGO","FJV_CODIGO"+cEmpAnt)
        ConfirmSx8()
    EndDo
    cCodFJV := cCodFJVSx8
EndIf

RestArea(aArea)

Return cCodFJV

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINSOMALOTE

Soma Lote Financeiro com tratamento para possivel aumento do campo de 4 para 8 posicoes (Retorno CNAB).
Arquivo original: FINXATU.PRX

@param cLoteFin - número do lote par cálculo da Soma1.

@Author	Gustavo Henrique
@since	15/09/09
/*/
//-----------------------------------------------------------------------------------------------------
Function FinSomaLote(cLoteFin)

Local cRet		:= ""
Local nTamLote	:= TamSX3("EE_LOTE")[1]
Local nTamLtFin := Len(Alltrim(cLoteFin))

cRet	:= AllTrim( cLoteFin )
If nTamLtFin < nTamLote
	cRet:= Soma1(cRet)
Else
	cRet := Soma1( PadL( cRet, nTamLote ) )
EndIf
Return cRet


//-------------------------------------------------------------------
/*/{Protheus.doc} FINMsgCnab
Função para validação dos campos de mensagem para CNAB (Tabela SEE)
Arquivo original: FINXATY.PRX

@sample FINMsgCnab()
@author Mauricio Pequim Jr
@since 15/05/13
@version 1.0

@return lRet	Fórmula válida ou não
/*/
//-------------------------------------------------------------------
Function FINMsgCnab()
Local xResult	:= NIL
Local cForm		:= &(ReadVar())
Local lRet		:=.T.
Local aRetSyntax:= {}
Local cLine		:= ""
Local lExec		:= .T.
Local bBlock	:= {||.T.}
Local nPos		:= 0

aRetSyntax := ParAnalise(cForm)	// Analise estrutural de sintaxe

IF !Empty(aRetSyntax[1])
	Help(" ",1,"ERROFORM",,OemToAnsi( STR0001 + aRetSyntax[1]),1,0)  //"Estrutura Inconsistente : "
	lRet := .f.
Endif

If lRet
	For nPos := 1 to len(aRetSyntax[2])
		cLine	:= upper(aRetSyntax[2][nPos])
		If "M->" $ cLine .or. "m->" $ cLine
			lExec := .F.
		Endif
	Next nX

	If lExec
		bBlock := ErrorBlock( { |e| ChecErro(e) } )
		BEGIN SEQUENCE
			xResult := &cForm
		RECOVER
			lRet := .F.
		END SEQUENCE
		ErrorBlock(bBlock)
	Endif
Endif

Return lRet


//------------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ParAnalise
Função static auxiliar da validação dos campos de mensagem para CNAB (Tabela SEE)
Valida a sintaxe da fórmula digitada.

Arquivo original: FINXATU.PRX

@sample ParAnalise(cTexto)
@author Mauricio Pequim Jr
@since 15/05/13
@version 1.0

@param cTexto		Expresão ou fórmula a ser validada
@return aVetor		Vetor [1] cStack -> Se preenchido, indica qual caracter na estrutura não está  coerente com a mesma.
					Vetor [2] aParam -> Array com os textos correspondentes dentro das estruturas.
/*/
//------------------------------------------------------------------------------------------------------------------------
Static Function ParAnalise(cTexto)

Local cStack:=""  , cAspas:=""
Local aSepFunc:={"()","[]","{}"}, aParam:={}
Local nPosAt:=1 , uLastPar:=1 , cPosAtual
Local uAbre , uFecha , cSeparador:=","

// Arranca os caracteres da esquerda se forem 'espa‡o' ou 'TAB'
While left(cTexto,1)==" " .or. left(cTexto,1)==chr(9)
   cTexto:=right(cTexto,len(cTexto)-1)
EndDo
While nPosAt<=len(cTexto)
   cPosAtual:=substr(cTexto,nPosAt,1)
   If cPosAtual==chr(34) .or. cPosAtual==chr(39)	// Achou "ASPAS"
		cAspas:=If(empty(cAspas),cPosAtual,If(cAspas == cPosAtual,"",cAspas))
   Endif
   If empty(cAspas)			// Apenas analiza a estrutura caso nao esteja entre aspas
      uAbre :=ascan(aSepFunc,{|_v|  left(_v,1) == cPosAtual})
      uFecha:=ascan(aSepFunc,{|_v| right(_v,1) == cPosAtual})
      If uAbre+uFecha>0		// Abriu ou Fechou uma estrutura
         If uAbre>0	// Abriu uma estrutura ! Acrescenta no STACK
            If !empty(substr(cTexto,uLastPar,nPosAt-uLastPar))
               aadd(aParam,substr(cTexto,uLastPar,nPosAt-uLastPar))
            Endif
	         uLastPar:=nPosAt+1	 ; cStack:=cStack+cPosAtual
         Else			// Fechou uma estrutura : Checa o STACK
            If right(cStack,1)==Left(aSepFunc[uFecha],1)	// Se fechou certo, tira do Stack
               cStack:=left(cStack,len(cStack)-1)
				Else	// Estrutura fechada incorretamente
					cStack:=right(aSepFunc[uFecha],1)
					EXIT
            Endif
            If !empty(substr(cTexto,uLastPar,nPosAt-uLastPar))
               aadd(aParam,substr(cTexto,uLastPar,nPosAt-uLastPar))
            Endif
	         uLastPar:=nPosAt+1
         Endif
      Else	// Verifica separador
			If cPosAtual==cSeparador
            aadd(aParam,substr(cTexto,uLastPar,nPosAt-uLastPar))
            uLastPar:=nPosAt+1
         Endif
      Endif
   Endif
	nPosAt++
EndDo
IF !empty(cTexto) .and. len(aParam) == 0
	aadd(aParam,alltrim(cTexto))
Endif
cStack+=if(empty(cAspas),"",cAspas)
Return {cStack,aParam}


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FMsgCnab
Função para macroexecução do conteúdo dos campos de mensagem do chab (Tabela SEE):
EE_FORMEN1, EE_FORMEN2, EE_FOREXT1, EE_FOREXT2

Arquivo original: FINXATU.PRX

@sample FMsgCnab(cCampo)
@author Mauricio Pequim Jr
@since 15/05/13
@version 1.0

@param cCampo	Nome do campo a ser macroexecutado
@return cTexto	Texto resultante da macroexecução do campo
/*/
//---------------------------------------------------------------------------------------------------------
Function FMsgCnab(cCampo)

Local cRet		:= ""
Local aRetSyntax:= {}

Default cCampo := ""

aRetSyntax := ParAnalise(cCampo)	// Analise estrutural de sintaxe

IF Empty(aRetSyntax[1])

	bBlock := ErrorBlock( { |e| ChecErro(e) } )
	BEGIN SEQUENCE
		cRet := &cCampo
	RECOVER
		cRet := STR0002 //"Falha de configuração. Verifique configuração da mensagem."
	END SEQUENCE
	ErrorBlock(bBlock)
Else
	cRet := STR0002		//"Falha de configuração. Verifique configuração da mensagem."
Endif

Return cRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA040LEGENDA

Legenda do SE1 - Contas a Receber
Arquivo original: FINXATU.PRX

@param cLoteFin - número do lote par cálculo da Soma1.

@Author	Wagner Mobile Costa
@since	22/10/2001
/*/
//-----------------------------------------------------------------------------------------------------
Function Fa040Legenda(cAlias, nReg)
Local lPrjCni		:= ValidaCNI()
Local aLegenda		:= {{"BR_VERDE", 	STR0003 },;	//1.  "Titulo em aberto"
						{"BR_AZUL", 	STR0004 },;	//2.  "Baixado parcialmente"
						{"BR_VERMELHO", STR0005 },;	//3.  "Titulo Baixado"
						{"BR_PRETO", 	STR0006 },;	//4.  "Titulo em Bordero"
						{"BR_BRANCO", 	STR0007 },;	//5.  "Adiantamento com saldo"
						{"BR_CINZA",	STR0008 },; //6. "Titulo baixado parcialmente e em bordero"
						{"BR_AMARELO", STR0072} } 	//7. "Adiantamento de Imp. Bx. com saldo"
Local uRetorno		:= .T.
Local aLegNew		:= {}

Default __lFaLegPares	:= ExistBlock("FaLegPARes") .And. ExecBlock("FaLegPARes",.f.,.f.) // Ponto de Entrada permite visualizar na legenda se um titulo de PA possue residuos de saldo.
Default lF040ADLE		:= ExistBlock("F040ADLE")
Default lFinaleg		:= ExistBlock("FINALEG")
Default lF040URET		:= ExistBlock("F040URET")

If __lFaLegPares	.And. cAlias = "SE2"
	Aadd(aLegenda,{"BR_MARROM",STR0009}) //"Adiantamento com resíduo no saldo"
EndIf

/*
	Sem Recno --> Retornar array com as regras para o Browse colocar as cores na coluna.
	Com Recno --> Chamada via botão Legendas do browse -> Abrir telinha de Legendas (BrwLegenda)
*/
If nReg = Nil	// Retornar as regras de legenda

	uRetorno := {}

	If cAlias = "SE1"

		Aadd(aLegenda, {"BR_VERDE_ESCURO", STR0012})  //8. "Titulo Protestado"
		Aadd(aLegenda, {"BR_AZUL_CLARO", STR0090}) //9. "Fatura Cancelada (SIGAPFS)"

		If cPaisLoc == "MEX" .And. X3Usado("ED_OPERADT")
			Aadd(aLegenda, {"BR_PINK"	,STR0010}) //10.  "Adiantamento gerado por Nota Fiscal"
			Aadd(aLegenda, {"BR_LARANJA",STR0011}) //11.  "Titulo com operacão de adiantamento"
		EndIf

		If cPaisLoc == "BRA" .And. FindFunction("FINA890")
			aAdd(aLegenda, { "BR_LARANJA" , STR0092 })  //10. "Título em PIX"
			aAdd(aLegenda, { "BR_MARROM" , STR0093 }) //11. "Título baixado parcialmente e em PIX"
			aAdd(aLegenda, { "BR_PINK" , STR0094 }) //12. "Título em PIX e Borderô"
			aAdd(aLegenda, { "BR_VIOLETA" , STR0095 }) //13. "Título baixado parcialmente e em PIX e Borderô"			
		EndIf

		Aadd(uRetorno, { 'Iif(FindFunction("JurCNF"), JurCNF(SE1->(Recno())), .F.)'					, aLegenda[9][1]				 }) // "Fatura Cancelada (SIGAPFS)"
		Aadd(uRetorno, { 'ROUND(E1_SALDO,2) = 0'													, aLegenda[3][1]				} ) //"Titulo Baixado"
		If cPaisLoc == "BRA" .And. FindFunction("FINA890")
			aAdd(uRetorno, { 'TitTemPIX(E1_FILIAL) .And. !Empty(E1_NUMBOR) .and.(ROUND(E1_SALDO,2) # ROUND(E1_VALOR,2))', aLegenda[13][1] }) // "Título baixado parcialmente e em PIX e Borderô"
			aAdd(uRetorno, { 'TitTemPIX(E1_FILIAL) .And.(ROUND(E1_SALDO,2) # ROUND(E1_VALOR,2))', aLegenda[11][1] }) // "Título baixado parcialmente e em PIX"
			aAdd(uRetorno, { 'TitTemPIX(E1_FILIAL) .And. !Empty(E1_NUMBOR)', aLegenda[12][1] }) // "Título em PIX e Borderô"
			aAdd(uRetorno, { 'TitTemPIX(E1_FILIAL)', aLegenda[10][1] }) // "Título em PIX"
		EndIf
		Aadd(uRetorno, { '!Empty(E1_NUMBOR) .and.(ROUND(E1_SALDO,2) # ROUND(E1_VALOR,2))'			, aLegenda[6][1]				} ) //"Titulo baixado parcialmente e em bordero"
		Aadd(uRetorno, { 'E1_TIPO == "'+MVRECANT+'".and. ROUND(E1_SALDO,2) > 0 .And. !FXAtuTitCo()'	, aLegenda[5][1]				} ) //"Adiantamento com saldo"
		Aadd(uRetorno, { '!Empty(E1_NUMBOR)'														, aLegenda[4][1]				} ) //"Titulo em Bordero"
		Aadd(uRetorno, { '!(ROUND(E1_SDACRES,2) > ROUND(E1_ACRESC,2)) .And. ROUND(E1_SALDO,2) + ROUND(E1_SDACRES,2) # ROUND(E1_VALOR,2) + ROUND(E1_ACRESC,2) .And. !FXAtuTitCo()', aLegenda[2][1]} ) //"Baixado parcialmente"				
		Aadd(uRetorno, { 'ROUND(E1_SALDO,2) == ROUND(E1_VALOR,2) .and. AllTrim(E1_SITUACA)== "F"'			, aLegenda[8][1]	} ) //"Titulo Protestado"

		If cPaisLoc == "MEX" .And. X3Usado("ED_OPERADT")
			Aadd(uRetorno, {	'E1_ORIGEM == "MATA467N" .And. ROUND(E1_SALDO,2) > 0 .And. FXAtuTitCo()'									, aLegenda[10][1] } )
			Aadd(uRetorno, {	'E1_ORIGEM == "FINA087A" .And. ROUND(E1_SALDO,2) > 0 .And. FXAtuTitCo() .And. E1_TIPO == "'+MVRECANT+'"'	, aLegenda[11][1] } )
		EndIf

	Else // SE2

		If lPrjCni
			IF !Empty(SuperGetMv("MV_APRPAG",.F.,"")) .or. SuperGetMv("MV_CTLIPAG",.F.,.F.)
				Aadd(aLegenda, {"BR_PINK", STR0013})  //"Titulo aguardando liberacao"
				Aadd(uRetorno, { ' EMPTY(E2_DATALIB) .AND. (SE2->E2_SALDO+SE2->E2_SDACRES-SE2->E2_SDDECRE) > GetMV("MV_VLMINPG") .AND. E2_SALDO > 0', aLegenda[Len(aLegenda)][1] } )
			EndIf
		Else
			IF SuperGetMv("MV_CTLIPAG",.F.,.F.)
				Aadd(aLegenda, {"BR_PINK", STR0074})	//"Titulo aguardando liberacao"
				Aadd(uRetorno, { ' !( SE2->E2_TIPO $ MVPAGANT ).and. EMPTY(E2_DATALIB) .AND. (SE2->E2_SALDO+SE2->E2_SDACRES-SE2->E2_SDDECRE) > SuperGetMV("MV_VLMINPG",.F.,0) .AND. E2_SALDO > 0', aLegenda[Len(aLegenda)][1] } )
			EndIf
		EndIf

		Aadd(aLegenda, {"BR_LARANJA", STR0073}) //"Adiantamento de Viagem sem taxa"
		Aadd(uRetorno, { ' (ALLTRIM(SE2->E2_ORIGEM) $ "FINA667|FINA677") .and. SE2->E2_MOEDA > 1 .AND. SE2->E2_TXMOEDA == 0 .AND. SE2->E2_SALDO > 0', aLegenda[Len(aLegenda)][1] } )

		IF __lFaLegPares
			Aadd(aLegenda,{"BR_MARROM",STR0046})
			Aadd(uRetorno, { 'E2_TIPO == "'+MVPAGANT+'" .and. ROUND(E2_SALDO,2) > 0 .And. (ROUND(E2_SALDO,2) < ROUND(E2_VALOR,2))', aLegenda[Len(aLegenda)][1] } )
		Endif

		//Validação para uso do documento hábil - SIAFI
		If FinUsaDH()
			Aadd(aLegenda,{"BR_VIOLETA",STR0070}) // "Titulo Vinculado a Docto Hábil"
			Aadd(uRetorno, { 'ROUND(E2_SALDO,2) > 0 .And. !EMPTY(E2_DOCHAB)'	, aLegenda[Len(aLegenda)][1]				} ) //"Titulo relacionado ao Documento hábil"
		Endif
		Aadd(uRetorno, { 'E2_TIPO $ "INA/'+MVTXA+'" .and. ROUND(E2_SALDO,2) > 0 .And. E2_OK == "TA"  ', aLegenda[7][1] } )
		Aadd(uRetorno, { 'E2_TIPO == "'+MVPAGANT+'" .and. ROUND(E2_SALDO,2) > 0', aLegenda[5][1] } )
		Aadd(uRetorno, { 'ROUND(E2_SALDO,2) + ROUND(E2_SDACRES,2)  = 0', aLegenda[3][1] } )
		Aadd(uRetorno, { '!Empty(E2_NUMBOR) .and.(ROUND(E2_SALDO,2)+ ROUND(E2_SDACRES,2) # ROUND(E2_VALOR,2)+ ROUND(E2_ACRESC,2))', aLegenda[6][1] } )
		Aadd(uRetorno, { '!Empty(E2_NUMBOR)', aLegenda[4][1] } )
		Aadd(uRetorno, { 'ROUND(E2_SALDO,2)+ ROUND(E2_SDACRES,2) # ROUND(E2_VALOR,2)+ ROUND(E2_ACRESC,2)', aLegenda[2][1] } )
		
	Endif


	// PE que Adiciona regra de legendas do usuário --> adiciona sempre no final, antes da { .T. , BR_VERDE }
	If lF040URET 
		uRetNew := ExecBlock("F040URET",.F.,.F.,{uRetorno,aLegenda})
		If ValType(uRetNew) = "A"
			aEval(uRetNew,{|J| aAdd(uRetorno,{J[1],J[2]}) })
		Endif
	Endif
	// --> Legenda BR_VERDE -> Última regra de legenda, tanto para SE1 e SE2
	Aadd(uRetorno, { '.T.', aLegenda[1][1] } )

	If lFinaleg // Ponto de entrada para manipular toda a regra de legendas
		uRetorno := ExecBlock("FINALEG",.F.,.F.,{nReg,cAlias,uRetorno,{}})
	EndIf


Else // Abrir telinha de Legendas (BrwLegenda)

	If cAlias = "SE1"
		If cPaisLoc == "MEX" .And. X3Usado("ED_OPERADT")
			Aadd(aLegenda, {"BR_PINK"	,STR0010}) //7.  "Adiantamento gerado por Nota Fiscal"
			Aadd(aLegenda, {"BR_LARANJA",STR0014}) //8.  "Titulo com operacão de adiantamento"
		EndIf
		Aadd(aLegenda,{"BR_VERDE_ESCURO", STR0012}) //"Titulo Protestado"
		Aadd(aLegenda,{"BR_AZUL_CLARO", STR0090}) //"Fatura Cancelada (SIGAPFS)"
		aAdd(aLegenda, { "BR_LARANJA" , STR0092 }) // "Título em PIX"
		aAdd(aLegenda, { "BR_MARROM" , STR0093 }) // "Título baixado parcialmente e em PIX"
		aAdd(aLegenda, { "BR_PINK" , STR0094 }) // "Título em PIX e Borderô"
		aAdd(aLegenda, { "BR_VIOLETA" , STR0095 })	// "Título baixado parcialmente e em PIX e Borderô"
	Else
		If lPrjCni
			If !Empty(SuperGetMv("MV_APRPAG",.F.,"")) .or. SuperGetMv("MV_CTLIPAG",.F.,.F.)
				Aadd(aLegenda, {"BR_PINK",  STR0013})		//"Titulo aguardando liberacao"
			EndIf
		Else
			IF SuperGetMv("MV_CTLIPAG",.F.,.F.)
				Aadd(aLegenda, {"BR_PINK",  STR0013})		//"Titulo aguardando liberacao"
			EndIf
		Endif

		Aadd(aLegenda, {"BR_LARANJA", STR0073}) //"Adiantamento de Viagem sem taxa"

		IF __lFaLegPares
			Aadd(aLegenda,{"BR_MARROM",STR0046})
		Endif

		//Validação para uso do documento habil (SIAFI)
		If FinUsaDH()
			Aadd(aLegenda,{"BR_VIOLETA",STR0070}) // "Titulo Vinculado a Docto Hábil"
		EndIf
	EndIf

	If lF040ADLE
		aLegNew := ExecBlock("F040ADLE",.F.,.F.,aLegenda)
		If ValType(aLegNew) = "A"
			aEval(aLegNew,{|J| aAdd(aLegenda,{J[1],J[2]}) })
		Endif
	EndIf

	If lFinaleg
		ExecBlock("FINALEG",.F.,.F.,{nReg,cAlias,{},aLegenda})
	Else
		BrwLegenda(cCadastro, STR0066, aLegenda)		//"Legenda"
	EndIf

EndIf

Return uRetorno


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINSEQSE5

Encontra a proxima sequencia para o movto bancario (CR) (FINA191).
Arquivo original: FINXATU.PRX

@Author	Claudio D. de Souza
@since	06/11/2003
/*/
//-----------------------------------------------------------------------------------------------------
Function FinSeqSe5(cPrefixo,cNum,cParcela,cTipo,lQuery)
Local cSequencia	:= ""
Local aAreaSE1		:= SE1->(GetArea())

Default cPrefixo	:= SE1->E1_PREFIXO
Default cNum		:= SE1->E1_NUM
Default cParcela	:= SE1->E1_PARCELA
Default cTipo		:= SE1->E1_TIPO
Default lQuery		:= .F.

SE1->(dbSetOrder(1))
SE1->(MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+cTipo))

cSequencia := FinSeqFK1()

RestArea(aAreaSE1)
FwFreeArray(aAreaSE1)

Return cSequencia


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FBXLOTAUT

Baixa Automatica em lotes (Chama FINA110 e FINA090).
Arquivo original: FINXATU.PRX

@param cAlias - Alias (SE1 ou SE2)
@param aRecnos - Array contendo o Recno dos arquivos a serem baixados
@param cBanco - Banco para baixa
@param cAgencia - Agencia para Baixa
@param cConta - Conta para Baixa
@param cCheque - Cheque para Baixa
@param cLoteFin - Lote para agrupamento das baixas (loteFin)
@param cNatureza - Natureza do movimento bancario (C.Pagar)
@param dBaixa


@Author	Mauricio Pequim Jr.
@since	11/05/2010
/*/
//-----------------------------------------------------------------------------------------------------
Function FBxLotAut(cAlias,aRecnos,cBanco,cAgencia,cConta,cCheque,cLoteFin,cNatureza,dBaixa)

Local aTitulos		:= {}
Local lRet			:= .T.
Local dBKPDTBase	:= dDataBase	// Copia para restaurar no final
Local lBaixaVenc	:= .F.
Local nThreads		:= 0
Local lSitef		:= FwIsInCallStack("FINA910") .Or. FWIsInCallStack("FINA918")

PRIVATE lMSHelpAuto	:= .T.
PRIVATE lMsErroAuto	:= .F.

Default cAlias		:= ""
Default aRecnos		:= {}
Default cBanco		:= ""
Default cAgencia	:= ""
Default cConta		:= ""
Default cCheque		:= ""
Default cLoteFin	:= ""
Default cNatureza	:= ""
Default dBaixa		:= dDatabase

If lSitef .and. Type("LUSEFIFDTCRED") == "L" .AND. lUseFIFDtCred
	//se deve gravar a data de credito na E1_BAIXA
	lBaixaVenc := .T.
EndIf

nThreads := If( (nThreads > 20) , 20 , nThreads )
//Gero numeracao automatica de lote
If Empty(cLoteFin)
	cLoteFin := GetNewLote()
Endif

cBanco		:= PADR(cBanco,TAMSX3("A6_COD")[1])
cAgencia	:= PADR(cAgencia,TAMSX3("A6_AGENCIA")[1])
cConta		:= PADR(cConta,TAMSX3("A6_NUMCON")[1])
cCheque		:= PADR(cCheque,TAMSX3("EF_NUM")[1])
cNatureza	:= PADR(cNatureza,TAMSX3("ED_CODIGO")[1])

SED->(dbSetOrder(1))

//Verifico informacoes para processo
If Empty(cAlias) .or. Empty(cBanco) .or. Empty(cAgencia) .or. Empty(cConta)
	Help(" ",1,"BXLTAUT1",,STR0015, 1, 0 ) //"Informações incorretas não permitem a baixa automática em lote. Verifique as informações passadas para a função FBXLOTAUT()"
	lRet		:= .F.
ElseIf !CarregaSa6(@cBanco,@cAgencia,@cConta,IIf( nThreads > 1, .F., .T. ),,.T.,,,lSitef)
	lRet		:= .F.
ElseIf Empty(aRecnos)
	Help(" ",1,"RECNO")
	lRet		:= .F.
ElseIf !Empty(cNatureza) .and. !ExistCpo("SED",cNatureza,,STR0016) //"Natureza Informada não Existe."
	lRet		:= .F.
ElseIf !Empty(cCheque) .and. cAlias == "SE2" .and. !(FVerCheq(cBanco,cAgencia,cConta,cCheque))
	lRet		:= .F.
Else
	aTitulos := {aRecnos,cBanco,cAgencia,cConta,cCheque,cLoteFin,cNatureza,dBaixa,lBaixaVenc}
	VALOR := 0

	If cAlias == "SE1"
		FINA110( 3 , aTitulos )
	Else
		FINA090( 3 , aTitulos )
	Endif
Endif

If lMsErroAuto
	MOSTRAERRO()
	RollBackSx8()
	lRet := .F.
EndIf

lMSHelpAuto := .F.
lMsErroAuto := .F.

//volta a database
dDataBase := dBKPDTBase

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FVERCHEQ

Valida cheque informado.se digitado e diferente de '*' (chamada da FBxLotAut).
Arquivo original: FINXATU.PRX

@Author	Mauricio Pequim Jr.
@since	13/05/2010
/*/
//-----------------------------------------------------------------------------------------------------
Function FVerCheq(cBanco,cAgencia,cConta,cCheque )
Local lRet    := .t.

lRet := VldUser("EF_NUM") // Chama a validacao de usuario
If lRet .And. !Empty(cCheque) .And. Substr(cCheque,1,1) # "*"
	SEF->(dbSetOrder(1))
	If SEF->( (dbSeek( xFilial("SEF") + cBanco + cAgencia + cConta + cCheque ) ) )
		Help( " ",1,"F090Cheq" )
		lRet := .f.
	Endif
Endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FINSITCOP

Apresenta tela para selecao de situacoes de cobranca (finr721/finr730/finr731)
Arquivo original: FINXATU.PRX

@author pequim

@since 13/12/2013
@version 1.0
/*/
//-------------------------------------------------------------------
Function FinSitCob()

Local oQual
Local oDlg
Local oOk			:= LoadBitmap( GetResources(), "LBOK" )
Local oNo			:= LoadBitmap( GetResources(), "LBNO" )
Local cCapital		:= ""
Local cVar			:= "  "
Local cTitulo		:= STR0018 //"Situações de Cobrança"
Local cSituaca		:= ""
Local nX			:= 0
Local nOpca			:= 0
Local aArea			:= GetArea()
Local aTipoBack		:={}
Local aSituaca		:={}
Local lRunDblClick	:= .T.

//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
// Monta a tabela de tipos de T¡tulos
//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
dbSelectArea("FRV")
dbSeek(xFilial("FRV"))
While !EOF() .and. FRV->FRV_FILIAL == xFilial("FRV")
	cCapital := Capital(FRV->FRV_DESCRI)
	Aadd(aSituaca,{.T.,FRV->FRV_CODIGO,PadR(cCapital,20)})
	dbSkip()
EndDo

aTipoBack := aClone(aSituaca)

nOpca := 0

DEFINE MSDIALOG oDlg TITLE cTitulo From 9,0 To 35,50 OF oMainWnd

@ 0.5,  0.3 TO 13.6, 20.0 LABEL cTitulo OF oDlg
@ 2.3,3 Say OemToAnsi("  ")
@ 1.0,.7 LISTBOX oQual VAR cVar Fields HEADER "",STR0019,STR0020 SIZE 150,170 ON DBLCLICK (aTipoBack:=FA060Troca(oQual:nAt,aTipoBack),oQual:Refresh()) NOSCROLL //"Código"###"Descrição"

oQual:SetArray(aTipoBack)
oQual:bLine := { || {if(aTipoBack[oQual:nAt,1],oOk,oNo),aTipoBack[oQual:nAt,2],aTipoBack[oQual:nAt,3]}}
oQual:bHeaderClick := {|oObj,nCol| If(lRunDblClick .And. nCol==1, aEval(aTipoBack, {|e| e[1] := !e[1]}),Nil), lRunDblClick := !lRunDblClick, oQual:Refresh()}

DEFINE SBUTTON FROM 10  ,166  TYPE 1 ACTION (nOpca := 1,oDlg:End()) ENABLE OF oDlg
DEFINE SBUTTON FROM 22.5,166  TYPE 2 ACTION oDlg:End() ENABLE OF oDlg

ACTIVATE MSDIALOG oDlg CENTERED

IF nOpca == 1
	aSituaca := Aclone(aTipoBack)
EndIF

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta a string de tipos para filtrar o arquivo               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cTipos :=""

For nX := 1 To Len(aSituaca)
	If aSituaca[nX,1]
		cSituaca += aSituaca[nX,2]+"|"
	Endif
Next nX

DeleteObject(oOk)
DeleteObject(oNo)

RestArea(aArea)

Return cSituaca

//-------------------------------------------------------------------
/*/{Protheus.doc} NEWTIPCART

Função utilizada para verificar carteira do tipo de titulo contido no
arquivo SES (tipos de documentos) (FINA040/FINA050/FINA280/FINA290).
Arquivo original: FINXATU.PRX

@author Mauricio Pequim Jr.
@since 22/08/2000
/*/
//-------------------------------------------------------------------
Function NEWTIPCART(cTipo,cCarteira)
Local lRet := .T.
SES->(dbSetOrder(1))
If cTipo == NIL .or. cCarteira == NIL
	lRet := .F.
Elseif SES->(dbSeek(xFilial("SES")+cTipo))
	If !(SES->ES_CARTEIR $ cCarteira+"/3")
		lRet := .F.
	Endif
Endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FA040NUM

Validação do numero do titulo CR.
Arquivo original: FINXATU.PRX

@author Wagner Xavier
@since 22/04/1992
/*/
//-------------------------------------------------------------------
Function FA040Num()
Local lRetorna := .T., nOrder, cAlias
Local nRecNo := SE1 -> (RecNo())
Local nPos := 0
Local cTipo := ""
Local lInclTit	:= IIF(TYPE("INCLUI")<>"U",INCLUI,.F.)
Local AGETS := {}

If cPaisLoc == "EQU" .and. !lInclTit //somente para equador e se nao for inclusão
	If Type("lF040Auto")=="L" .and. lF040Auto
		nPos := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "E1_TIPO"})
		If nPos > 0
			cTipo := aAutoCab[nPos] [2]
		EndIf
		M->E1_PREFIXO 	:= SE1->E1_PREFIXO
		M->E1_NUM 		:= SE1->E1_NUM
		M->E1_TIPO 		:= cTipo
		M->E1_PARCELA 	:= SE1->E1_PARCELA
		M->E1_CLIENTE	:= SE1->E1_CLIENTE
		M->E1_LOJA 		:= SE1->E1_LOJA
	EndIf
EndIF
cAlias := Alias()
nOrder := IndexOrd()

If IIf(Type("lF040Auto")=="U",.T.,lF040Auto==.F.)
	If (!Empty(M->E1_CLIENTE))
		If cPaisLoc $ "BRA|MEX"
			If Readvar() == "M->E1_CLIENTE"
				If Type("aRecnoAdt") != "U" .and. (FunName() = "MATA410" .or. FunName() = "MATA460A" .or. FunName() = "MATA460B")
					If IIf(FunName() = "MATA410" .and. Type("M->C5_CLIENTE") != "U",M->E1_CLIENTE != M->C5_CLIENTE,IIf(FunName() = "MATA460A" .and. SC5->(!Eof()),M->E1_CLIENTE != SC5->C5_CLIENTE,.F.))
						Aviso(STR0067,STR0021,{ "Ok" })  //"Atenção"###"Por tratar-se de título para processo de adiantamento, é obrigatório que o código do cliente seja o mesmo do 'Pedido de Venda/Documento de Saída'."
						Return(.F.)
					Endif
				Endif
			Endif
		Endif
	Endif
Endif

If ( !Empty(M->E1_CLIENTE) .And. !Empty(M->E1_LOJA) )
	If Readvar() == "M->E1_CLIENTE"

		If IIf(Type("lF040Auto")=="U",.T.,lF040Auto==.F.)
			If cPaisLoc $ "BRA|MEX"
				If Type("aRecnoAdt") != "U" .and. (FunName() = "MATA410" .or. FunName() = "MATA460A" .or. FunName() = "MATA460B")
					If IIf((FunName() = "MATA410" .or. FunName() = "MATA460B") .and. Type("M->C5_CLIENTE") != "U" .and. Type("M->C5_LOJACLI") != "U" ,(M->E1_CLIENTE+M->E1_LOJA != M->C5_CLIENTE+M->C5_LOJACLI),IIf(FunName() = "MATA460A" .and. SC5->(!Eof()),(M->E1_CLIENTE+M->E1_LOJA != SC5->C5_CLIENTE+SC5->C5_LOJACLI),.F.))
						Aviso(STR0067,STR0021,{ "Ok" }) 	//"Atenção"###"Por tratar-se de título para processo de adiantamento, é obrigatório que o código do cliente seja o mesmo do 'Pedido de Venda/Documento de Saída'."
						Return(.F.)
					Endif
				Endif
			Endif
		Endif

		If ( SA1->A1_COD != M->E1_CLIENTE )
			dbSelectArea("SA1")
			dbSetOrder(1)
			dbSeek(xFilial()+M->E1_CLIENTE,.F.)
		EndIf
		M->E1_LOJA := SA1->A1_LOJA
	Else
		If IIf(Type("lF040Auto")=="U",.T.,lF040Auto==.F.)
			If Readvar() == "M->E1_LOJA"
				If cPaisLoc $ "BRA|MEX"
					If Type("aRecnoAdt") != "U" .and. (FunName() = "MATA410" .or. FunName() = "MATA460A" .or. FunName() = "MATA460B")
						If IIf(FunName() = "MATA410" .and. Type("M->C5_CLIENTE") != "U" .and. Type("M->C5_LOJACLI") != "U" ,(M->E1_CLIENTE+M->E1_LOJA != M->C5_CLIENTE+M->C5_LOJACLI),IIf((FunName() = "MATA460A"  .or. FunName() = "MATA460B") .and. SC5->(!Eof()),(M->E1_CLIENTE+M->E1_LOJA != SC5->C5_CLIENTE+SC5->C5_LOJACLI),.F.))
							Aviso(STR0067,STR0022,{ "Ok" })  //"Atenção"###"Por tratar-se de título para processo de adiantamento, é obrigatório que o código do cliente e loja sejam os mesmos do 'Pedido de Venda/Documento de Saída'."
							Return(.F.)
						Endif
					Endif
				Endif
			Endif
		Endif

		dbSelectArea("SA1")
		dbSetOrder(1)
		IF !dbSeek(xFilial("SA1")+M->E1_CLIENTE+M->E1_LOJA)
			lRetorna := .F.
			M->E2_LOJA := "  "
		Endif
	Endif
	lRefresh:=.T.
Endif

If SA1->A1_MSBLQL == "1" .And. "E1_CLIENTE" $ READVAR() .And. M->E1_CLIENTE == SA1->A1_COD .And. M->E1_LOJA == SA1->A1_LOJA
	HELP(" ",1,"REGBLOQ")
	Return .F.
Endif

If !Empty(m->e1_num) .And. !Empty(m->e1_tipo)
	dbSelectArea("SE1")
	dbSetOrder(1)
	If (dbSeek(xFilial("SE1")+m->e1_prefixo+m->e1_num+m->e1_parcela+m->e1_tipo) )
		Help(" ",1,"FA040NUM")
		dbGoTo( nRecNo )
		Return .F.
	ElseIf m->e1_tipo $ MVABATIM
		If ! (dbSeek(xFilial("SE1")+m->e1_prefixo+m->e1_num+m->e1_parcela))
			Help(" ",1,"FA040TIT")
			dbGoTo( nRecNo )
			Return .f.
		End
	ElseIf m->e1_tipo $ MVRECANT
		dbSelectArea("SE5")
		dbSetOrder(7)
		If dbSeek(xFilial("SE5")+m->e1_prefixo+m->e1_num+m->e1_parcela+m->e1_tipo)
			Help(" ",1,"RA_EXISTIU")
			lRetorna := .F.
		Endif
	Else
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "E1_OCORREN" } )
		If nEndereco > 0
			nEnd1 := Val(Subs(aGets[nEndereco],1,2))
			nEnd2 := Val(Subs(aGets[nEndereco],3,1))*2
			nTam	:= Len(aTela[nEnd1][nEnd2])
			IF M->E1_TIPO $ MVABATIM+"/"+MVIRABT+"/"+MVINABT+"/"+MVPIABT+"/"+;
				MVCFABT+"/"+MVCSABT
				m->e1_ocorren := "04"
				aTela[nEnd1][nEnd2] := "04"
			Else
				m->e1_ocorren := "01"
				aTela[nEnd1][nEnd2] := "01"
			End
			lRefresh := .T.
		EndIf
		lRetorna := .T.
	EndIf
EndIf
dbSelectArea(cAlias)
dbSetOrder(nOrder)
SE1->(dbGoTo( nRecNo ))
Return lRetorna

//-------------------------------------------------------------------
/*/{Protheus.doc} FA050NUM

Validação do numero do titulo CP.
Arquivo original: FINXATU.PRX

@author Wagner Xavier
@since 27/04/1992
@Return lRetorna, Logical, Validação OK
/*/
//-------------------------------------------------------------------
Function FA050Num() As Logical
Local lRetorna	As Logical
Local nOrder 	As Numeric
Local cAlias	As Character
Local nRecNo	As Numeric
Local lLoja		As Logical
Local nTamLoja	As Numeric
Local cChaveSe2	As Character
Local nPos		As Numeric
Local cTipo		As Character
Local lInclTit	As Logical
Local aFornBco	As Array
Local cFilOpe	As Character
Local aArea		As Array
Local lJurRest  As Logical

lRetorna	:= .T. 
nRecNo		:= SE2->(RecNo())
lLoja		:= .F.
nTamLoja	:= nPosLoja1 := nPosLoja2 := 0
cChaveSe2	:= ""
nPos		:= 0
cTipo		:= ""
lInclTit	:= IIF(TYPE("INCLUI")<>"U",INCLUI,.F.)
aFornBco	:= {}
cFilOpe		:= ''
aArea		:= SE2->(GetArea())
lJurRest    := .F.

If Type("lF050Auto")=="U"
	lF050Auto:=.F.
EndIf

If ( lF050Auto ) .And. cPaisLoc == "EQU" .AND. !lInclTit // QUANDO FOR INCLUSAO, ESTA VALIDAÇÃO NAO PODERA SER CHAMADA.
	nPos := Ascan(aAutoCab,{|x| Alltrim(x[1]) == "E2_TIPO"})
	If nPos > 0
		cTipo := aAutoCab[nPos] [2]
	EndIf
	M->E2_PREFIXO 		:= SE2->E2_PREFIXO
	M->E2_NUM 				:= SE2->E2_NUM
	M->E2_TIPO 				:= cTipo
	M->E2_PARCELA 	:= SE2->E2_PARCELA
	M->E2_FORNECE	:= SE2->E2_FORNECE
	M->E2_LOJA 				:= SE2->E2_LOJA
EndIF

//Quando rotina automatica usa informação passada pelo chamador
cFilOpe := If(lF050Auto,'M->E2_FILIAL','xFilial("SE2")')

cChaveSe2 := cFilOpe + " + M->E2_PREFIXO + M->E2_NUM + M->E2_PARCELA +" +;
			" M->E2_TIPO + M->E2_FORNECE + M->E2_LOJA"

nOrder := IndexOrd()
cAlias := Alias()

//-----------------------------------------------------------
// Em chamadas automaticas do FINA050 para inclusao eh
// necessario alimentar as variaveis do fornecedor para
// validacao adequada de bloqueio do mesmo. 
//-----------------------------------------------------------
If Empty(M->E2_FORNECE) .OR. Empty(M->E2_LOJA)
	If FwIsInCallStack("FINA050") .AND. FunName() # "FINA050" .AND. Type("lF050Auto") == "L" .AND. lF050Auto .AND. INCLUI .AND. Type("aAutoCab") # "U"
		If aScan(aAutoCab,{|x| x[1] == "E2_FORNECE"}) > 0 .AND. aScan(aAutoCab,{|x| x[1] == "E2_LOJA"}) > 0
			M->E2_FORNECE := aAutoCab[aScan(aAutoCab,{|x| x[1] == "E2_FORNECE"})][2]
			M->E2_LOJA := aAutoCab[aScan(aAutoCab,{|x| x[1] == "E2_LOJA"})][2]
		Endif
	Endif
Endif

If !lF050Auto
	If (!Empty(M->E2_FORNECE))
		If cPaisLoc $ "BRA|MEX"
			If Readvar() == "M->E2_FORNECE"
				If Type("aRecnoAdt") != "U" .and. (FunName() = "MATA121" .or. FunName() = "MATA103")
					If IIf(FunName() = "MATA121" .and. Type("cA120Forn") != "U",M->E2_FORNECE != cA120Forn,IIf(FunName() = "MATA103" .and. Type("cA100For") != "U",M->E2_FORNECE != cA100For,.F.))
						Aviso(STR0067,STR0035,{ "Ok" })		//"Atenção"###"Por tratar-se de título para processo de adiantamento, é obrigatório que o código do fornecedor seja o mesmo do 'Pedido de Compra/Documento de Entrada'."
						Return(.F.)
					Endif
				Endif
			Endif
		Endif
	Endif
Endif

If (!Empty(M->E2_FORNECE) .And. !Empty(M->E2_LOJA))

	If !lF050Auto
		If cPaisLoc $ "BRA|MEX"
			If Type("aRecnoAdt") != "U" .and. (FunName() = "MATA121" .or. FunName() = "MATA103")
				If Readvar() == "M->E2_FORNECE"
					If IIf(FunName() = "MATA121" .and. Type("cA120Forn") != "U" .and. Type("cA120Loj") != "U" ,(M->E2_FORNECE+M->E2_LOJA != cA120Forn+cA120Loj),IIf(FunName() = "MATA103" .and. Type("cA100For") != "U" .and. Type("cLoja") != "U",(M->E2_FORNECE+M->E2_LOJA != cA100For+cLoja),.F.))
						Aviso(STR0067,STR0035,{ "Ok" })	//"Atenção","Por tratar-se de título para processo de adiantamento, é obrigatório que o código do fornecedor seja o mesmo do 'Pedido de Compra/Documento de Entrada'."
						Return(.F.)
					Endif
				Elseif ReadVar() == "M->E2_LOJA"
					If IIf(FunName() = "MATA121" .and. Type("cA120Forn") != "U" .and. Type("cA120Loj") != "U" ,(M->E2_FORNECE+M->E2_LOJA != cA120Forn+cA120Loj),IIf(FunName() = "MATA103" .and. Type("cA100For") != "U" .and. Type("cLoja") != "U",(M->E2_FORNECE+M->E2_LOJA != cA100For+cLoja),.F.))
						Aviso(STR0067,STR0025,{ "Ok" }) //"Atenção"###"Por tratar-se de título para processo de adiantamento, é obrigatório que o código do fornecedor e loja sejam os mesmos do 'Pedido de Compra/Documento de Entrada'."
						Return(.F.)
					Endif
				Endif
			Endif
		Endif
	Endif

	dbSelectArea("SA2")
	dbSetOrder(1)
	If dbSeek(xFilial()+M->E2_FORNECE+M->E2_LOJA,.T.)
		If M->E2_LOJA != SA2->A2_LOJA .And. !Empty(M->E2_LOJA)
			Help(" ",1,"FA050NUM")
			lRetorna := .F.
		EndIf
		
		If lRetorna .And.SA2->A2_MSBLQL == "1" .And. M->E2_FORNECE == SA2->A2_COD .And. M->E2_LOJA == SA2->A2_LOJA
			HELP(" ",1,"REGBLOQ")
			lRetorna := .F.
		Endif
	Else
		// Limpa o codigo da loja, se estiver editando o codigo do fornecededor e
		// a loja estiver preenchida. Isto ocorre qdo. o usu rio volta ao campo
		// com a seta.
		IF !EMPTY(M->E2_LOJA) .AND. "E2_FORNECE" $ READVAR()
			M->E2_LOJA := SPACE(LEN(M->E2_LOJA))
		ENDIF
		If dbSeek(xFilial()+M->E2_FORNECE+M->E2_LOJA,.T.)
			If M->E2_LOJA != SA2->A2_LOJA .And. !Empty(M->E2_LOJA)
				Help(" ",1,"FA050NUM")
				lRetorna := .F.
			EndIf
		EndIf
	Endif
Endif

If SA2->A2_MSBLQL == "1" .And. "E2_FORNECE" $ READVAR() .And. M->E2_FORNECE == SA2->A2_COD .And. M->E2_LOJA == SA2->A2_LOJA
	HELP(" ",1,"REGBLOQ")
	lRetorna := .F.
Endif

If ! Empty(m->e2_num) .and. !Empty(m->e2_tipo) .And. !Empty(m->e2_fornece) .And. !Empty(m->e2_loja)
	dbSelectArea("SE2")
	dbSetOrder(1)
	dbSeek(&cChaveSe2)
	If Found()
		If !(lF050Auto .and. ALTERA)
			Help(" ",1,"FA050NUM")
			lRetorna := .F.
		Endif
	else 
		RestArea(aArea)
	EndIf

	//-----------------------------------------------------------
	// Verifica se numeração já  havia sido utilizada - PA
	//-----------------------------------------------------------
	If m->e2_tipo $ MVPAGANT
		DbSelectArea("SE5")
		DbSetOrder(7)
		If DbSeek(xFilial("SE5")+m->e2_prefixo+m->e2_num+m->e2_parcela+m->e2_tipo+m->e2_fornece+m->e2_loja)
			Help(" ",1,"PA_EXISTIU")
			DbSelectArea(cAlias)
			dbSetOrder(nOrder)
			Return .f.
		Endif
		DbSelectArea("SE2")
	Endif

	If (cPaisLoc <> "PER" .And. M->E2_TIPO $ MVABATIM) .And. (cPaisLoc == "PER" .And. M->E2_TIPO $ StrTran( MVABATIM , "IR-|" , "" ))
		DbSetOrder(6)
		If ! dbSeek(xFilial("SE2") + m->e2_fornece + m->e2_loja + m->e2_prefixo +;
			m->e2_num + m->e2_parcela)
			Help(" ",1,"FA040TIT")
			DbSetOrder(1)
			dbGoTo( nRecNo )
			Return .f.
		End
		DbSetOrder(1)
	End
End

// RFC - Validação para o Codigo de retenção da DIRF
IF ( M->E2_DIRF == "1" ) .And. Empty( M->E2_CODRET )
	Help( " " , 1 , "FA050CODRET" ,, STR0023, 1, 0 )  //"Código de retenção não informado!"
	RETURN .F.
ENDIF

dbSelectArea(cAlias)
dbSetOrder(nOrder)
If ( lLoja .And. !lRetorna )
	M->E2_LOJA := ""
	aTela[nPosLoja1][nPosLoja2] := PadL(M->E2_LOJA,nTamLoja)
EndIf
lRefresh := .T.

If cPaisLoc != "RUS" .And. !Empty(M->E2_FORNECE) .and. !Empty(M->E2_LOJA) .and. (readvar() == "M->E2_FORNECE" .or. readvar() == "M->E2_LOJA") .or. lF050Auto
	
	lJurRest := FindFunction("JurIsRest") .And. JurIsRest() .And. !Empty(M->E2_FORBCO)

	If !lJurRest
		aFornBco := F050CBCO(M->E2_FORNECE, M->E2_LOJA)
		If !Empty(aFornBco)
			M->E2_FORBCO	:=	aFornBco[1]
			M->E2_FORAGE	:=	aFornBco[2]
			M->E2_FAGEDV	:=	aFornBco[3]
			M->E2_FORCTA	:=	aFornBco[4]
			M->E2_FCTADV	:=	aFornBco[5]
			If !lF050Auto
				M->E2_FORMPAG := aFornBco[6]
			Endif
		EndIf
	EndIf

EndIf

If lInclTit .And. M->E2_TIPO $ MVABATIM .And. nRecNo > 0
	RestArea(aArea)
EndIf
FwFreeArray(aArea)

Return lRetorna
//-------------------------------------------------------------------
/*/{Protheus.doc} F050CBCO

Busca dados do banco do fornecedor.

@author Lucas de Oliveira
@since 27/02/2015
/*/
//-------------------------------------------------------------------
Function F050CBCO(cE2_Forn, cE2_Loja)
Local aFornBco := {}

Default cE2_Forn := ""
Default cE2_Loja := ""

//Verifica primeiro na tabela FIL se existe o banco cadastrado no fornecedor, se não busca os valores que estão na SA2
DBSelectArea("FIL")
DBSetOrder(1)
If FIL->(DBSeek(xFilial("FIL") + cE2_Forn + cE2_Loja))

	Aadd(aFornBco, FIL->FIL_BANCO)
	Aadd(aFornBco, FIL->FIL_AGENCI)
	Aadd(aFornBco, FIL->FIL_DVAGE)
	Aadd(aFornBco, FIL->FIL_CONTA)
	Aadd(aFornBco, FIL->FIL_DVCTA)
Else
	DBSelectArea("SA2")
	DBSetOrder(1)
	If SA2->(DBSeek(xFilial("SA2") + cE2_Forn + cE2_Loja))

		Aadd(aFornBco, SA2->A2_BANCO)
		Aadd(aFornBco, SA2->A2_AGENCIA)
		Aadd(aFornBco, SA2->A2_DVAGE)
		Aadd(aFornBco, SA2->A2_NUMCON)
		Aadd(aFornBco, SA2->A2_DVCTA)
		Aadd(aFornBco, SA2->A2_FORMPAG)
	Endif
EndIf

//Verifica se existe forma de pagamento cadastrada no fornecedor
DBSelectArea("SA2")
DBSetOrder(1)
If SA2->(DBSeek(xFilial("SA2") + cE2_Forn + cE2_Loja))
	Aadd(aFornBco, SA2->A2_FORMPAG)
Endif

Return aFornBco

//-------------------------------------------------------------------
/*/{Protheus.doc} FINOKDIACTB

Funcao para validação do botão OK ref ao Diario de Contabil (fina100/fina088).
Utilizado apenas em PTG, retorna o codigo do diário

Arquivo original: FINXATU.PRX

@author Marcelo Celi Marques
@since 06/06/2008
/*/
//-------------------------------------------------------------------
Function FinOkDiaCTB(cDiaCtb)

Default cDiaCtb := ""

If cPaisLoc == "PTG" .And. !Empty( cDiaCtb )

	cCodDiario := CTBAVerDia()

	If Empty( cCodDiario )
		Return(.F.)
	Endif
Endif

Return(.T.)


//-------------------------------------------------------------------
/*/{Protheus.doc} XCXFINA

Retorna o Caixa/Agencia/Conta geral do Financeiro

Arquivo original: FINXATU.PRX

@author Mauricio Pequim Jr.
@since 17/11/1998
/*/
//-------------------------------------------------------------------
Function xCxFina(cCaixa,cDesc)
Local aCaixaRet := {}
Local cAlias := Alias()
Local nReg	 := Recno()
Local nOrdem := IndexOrd()
Local cBcoCx := CriaVar("E1_PORTADO")
Local cAgeCx := CriaVar("E1_AGEDEP")
Local cCtaCx := CriaVar("E1_CONTA")
Local lCria

Default cCaixa	:= GetMv("MV_CXFIN")
Default cDesc	:= STR0079 //"CAIXA GERAL"

cBcoCx := Substr(cCaixa,1,At("/",cCaixa) - 1)
cBcoCx += Space(Len(SE1->E1_PORTADO)-Len(cBcoCx))

cAgeCx := Substr(cCaixa,At("/",cCaixa) +1 ,(Rat("/",cCaixa)-At("/",cCaixa)-1))
cAgeCx += Space(Len(SE1->E1_AGEDEP)-Len(cAgeCx))

cCtaCx := Substr(cCaixa,Rat("/",cCaixa) +1,Len(SE1->E1_CONTA))
cCtaCx += Space(Len(SE1->E1_CONTA)-Len(cCtaCx))

Aadd( aCaixaRet, cBcoCx )
Aadd( aCaixaRet, cAgeCx )
Aadd( aCaixaRet, cCtaCx )

dbSelectArea("SA6")
dbSetOrder(1)		//A6_FILIAL+A6_COD+A6_AGENCIA+A6_NUMCON
// Verifica se os dados sao validos para criacao do banco.
lCria :=	!Empty(aCaixaRet[1]) .And.;
			!Empty(aCaixaRet[2]) .And.;
			!Empty(aCaixaRet[3])

If lCria .And. !SA6->(dbSeek(xFilial("SA6")+aCaixaRet[1]+aCaixaRet[2]+aCaixaRet[3]))
	RecLock("SA6",.T.)
	SA6->A6_FILIAL  := xFilial("SA6")
	SA6->A6_COD 	  := aCaixaRet[1]
	SA6->A6_AGENCIA := aCaixaRet[2]
	SA6->A6_NUMCON  := aCaixaRet[3]
	SA6->A6_NOME	  := cDesc
	SA6->A6_NREDUZ  := cDesc
	SA6->A6_MOEDA   := 01
	MsUnLock()
EndIf

dbSelectArea(cAlias)
dbSetOrder(nOrdem)
dbGoto(nReg)

Return aCaixaRet


//-------------------------------------------------------------------
/*/{Protheus.doc} FXATUTITCO

Define se o titulo é de adiantamento para compensacao - Manejo de Anticipo
México

Arquivo original: FINXATU.PRX

@author TOTVS
@since 07/02/2012
/*/
//-------------------------------------------------------------------
Function FXAtuTitCo()
Local aArea	:= GetArea()
Local lRet	:= .F.

If cPaisLoc == "MEX" .And. X3Usado("ED_OPERADT")
	If GetAdvFVal("SED","ED_OPERADT",XFilial("SED")+SE1->E1_NATUREZ,1,"") == "1"
		lRet := .T.
	EndIf
EndIf

RestArea(aArea)

Return lRet

/*
----------------------------------------------------------------------------
	            Funcoes retiradas do arquivo FINXFUN.PRX
----------------------------------------------------------------------------
*/

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINADISPLAY

Atualiza tela de seleção de registros da baixa automática (markbrowse especifica FINA070/080/110)
Arquivo original: FINXFUN.PRX

@Author	Vinicius S. Barreira
@since	14/12/1995
/*/
//-----------------------------------------------------------------------------------------------------
Function FinaDisplay(cMarca,lInverte,oValor,oQtda,cArquivo,oPrazoMed,lBaixa)
Local cFieldMarca := "E1_OK"
Local cArea := "R"
Local cTipo := SE1->E1_TIPO
Local lBxTitPag 	:= .T.
Local lBxTitRec		:= .T.
Local lRet			:= .T.
Local lFinVDoc		:= IIF(GetNewPar("MV_FINVDOC","2")=="1",.T.,.F.)		//Controle de validacao de documentos obrigatorios
Local nVlImp		:= 0

Private nValorMarca	:= 0

Default lBaixa := .F.
If cArquivo == "R"
	cFieldMarca := "E1_OK"
	nValorMarca := SE1->(E1_SALDO+E1_SDACRES-E1_SDDECRE)
	cArea       := "R"
	cTipo       := SE1->E1_TIPO

ElseIF cArquivo == "P"
	cFieldMarca := "E2_OK"
	nValorMarca := SE2->(E2_SALDO+E2_SDACRES-E2_SDDECRE)
	cArea       := "P"
	cTipo       := SE2->E2_TIPO
	nVlImp		:= SE2->(E2_IRRF+E2_INSS+E2_ISS+E2_PIS+E2_COFINS+E2_CSLL)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso esteja ligado o controle de solicitacao de notas de credito e exista alguma ³
//³ pendencia para este titulo                                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPaisLoc <> "BRA"
    SCU->(DbSetOrder(2))
Endif
If lBaixa .And. cPaisloc <> "BRA" .And. SuperGetMv('MV_SOLNCP') .And. SE2->E2_TIPO == MVNOTAFIS ;
   .And. SCU->(MsSeek(xFilial()+SE2->E2_FORNECE+SE2->E2_LOJA+SE2->E2_NUM+SE2->E2_PREFIXO)).And. Empty(SCU->CU_NCRED)
	HELP(" ",1,"SOLNCPAB")
	RecLock("SE2",.F.)
	Replace &cFieldMarca With ""
	SE2->(MsUnLock())
	Return
Else
	If IsMark(cFieldMarca,cMarca,lInverte)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ PONTO DE ENTRADA F090TIT                                      ³
		//³ Verifica se titulo pode ser marcado para baixa ou nÆo. Caso	³
		//³ tenha sido alterada a marca‡Æo do titulo, ExecBlock dever     ³
		//³ retornar .F., para nÆo haver altera‡Æo dos acumuladores de    ³
		//³ valores e numero de titulos. Apenas para FINA080 e FINA090    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF (ExistBlock("F090TIT")) .and. cFieldMarca == "E2_OK" .and. !Empty(&cFieldMarca)
			// Bloqueio antes de chamar o ponto de entrada, pois no momento da chamada deste mesmo PE no
			// FINA090, funcoes Fa090Marca e Fa090Inverte o registro da SE2 jah estah bloqueado.
			RecLock("SE2",.F.)
			lBxTitPag := ExecBlock("F090TIT",.F.,.F.,{ nValorMarca })
			If !lBxTitPag
				SE2->&(cFieldMarca) := ""
			EndIf
			SE2->(MsUnlock())
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ PONTO DE ENTRADA F110TIT                                      ³
		//³ Verifica se titulo pode ser marcado para baixa. Caso tenha    ³
		//³ sido alterada a marca‡Æo do titulo, ExecBlock dever           ³
		//³ retornar .F., para nÆo haver altera‡Æo dos acumuladores de    ³
		//³ valores e numero de titulos. Apenas para FINA070 e FINA110 	  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF (ExistBlock("F110TIT")) .and. cFieldMarca == "E1_OK" .and. !Empty(&cFieldMarca)
			// Bloqueio antes de chamar o ponto de entrada, pois no momento da chamada deste mesmo PE no
			// FINA110, funcoes Fa110Marca e Fa110Inverte o registro da SE1 jah estah bloqueado.
			RecLock("SE1",.F.)
			lBxTitRec := ExecBlock("F110TIT",.F.,.F., { nValorMarca })
			SE1->(MsUnlock())
		Endif

		If lBxTitPag .And. lBxTitRec
			If cTipo $ MVABATIM
				nValor -= Moeda(nValorMarca,1,cArea)
				nValImp -= nVlImp
				If ! Empty(oPrazoMed)
					nData    := SE1->E1_VENCTO - SE1->E1_EMISSAO
					nPrazo   -= ( nData * Moeda(nValorMarca,nMoeda,"R") )
				EndIf
			Else
				nValor += Moeda(nValorMarca,1,cArea)
				nValImp += nVlImp
				If !Empty(oPrazoMed)
					nData  := SE1->E1_VENCTO - SE1->E1_EMISSAO
					nPrazo += ( nData * Moeda(nValorMarca,nMoeda,"R") )
				EndIf
			EndIf
			nQtdTit++
		Endif
	Else
		If cTipo $ MVABATIM
			nValor += Moeda(nValorMarca,1,cArea)
			nValImp += nVlImp
			If !Empty(oPrazoMed)
				nData  := SE1->E1_VENCTO - SE1->E1_EMISSAO
				nPrazo += ( nData * Moeda(nValorMarca,nMoeda,"R") )
			EndIF
		Else
			nValor -= Moeda(nValorMarca,1,cArea)
			nValImp -= nVlImp
			If !Empty(oPrazoMed)
				nData  := SE1->E1_VENCTO - SE1->E1_EMISSAO
				nPrazo += ( nData * Moeda(nValorMarca,nMoeda,"R") )
			EndIf
		EndIf
		nQtdTit--
		nQtdTit:= Iif(nQtdTit<0,0,nQtdTit)
	EndIf
EndIf


//Controle de documentos apresentados
If cArquivo == "P"
	If SE2->E2_OK == cMarca
		IF  lFinVDoc
			lRet := .T.
			SE2->(dbGoTo(RECNO()))
			If !CN062ValDocs("01",.F.)
				//Help(" ",1,"CN062NODOC")		//"Exite(m) documento(s) não apresentado(s) para o(s) título(s)."##"Não é permitida a liberação / movimentação do(s) título(s)."
				lRet := .F.
			EndIf
		EndIf
	EndIf
	If lRet
		If SE2->E2_OK == cMarca
		nValor += Round(NoRound(xMoeda(SE2->(E2_SALDO+E2_SDACRES-E2_SDDECRE),SE2->E2_MOEDA,1,,3),3),2)
		nQtdTit++
			nValImp += nVlImp
		Else
		nValor -= Round(NoRound(xMoeda(SE2->(E2_SALDO+E2_SDACRES-E2_SDDECRE),SE2->E2_MOEDA,1,,3),3),2)
		nQtdTit--
			nValImp -= nVlImp
		Endif
		nQtdTit:= Iif(nQtdTit<0,0,nQtdTit)
		//oValor:Refresh()
		//oQtdTit:Refresh()
	Else
		RecLock("SE2")
		IF SE2->E2_OK == cMarca
			SE2->E2_OK	:= "  "
		Else
			SE2->E2_OK	:= cMarca
		Endif
		MsUnlock()
		nQtdTit:= Iif(nQtdTit<0,0,nQtdTit)
		//oValor:Refresh()
		//oQtdTit:Refresh()
		//oMark:oBrowse:Refresh(.t.)
	EndIf
EndIf

oValor:Refresh()
oQtda:Refresh()
oMark:oBrowse:Refresh(.t.)
If !Empty(oPrazoMed)
	If nValor != 0
		nPrazoMed := nPrazo / nValor
	Else
		nPrazoMed := 0
	EndIf
	oPrazoMed:Refresh()
EndIf
Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FDESCMOED

Carrega array com as descrioes das moedas utilizadas no sistema.
Arquivo original: FINXFUN.PRX

@Author	Mauricio Pequim Jr.
@since	26/08/2002
/*/
//-----------------------------------------------------------------------------------------------------
Function FDescMoed()
Local cVar	 := ""
Local nX

If aMoedaFin == NIL
	// Inicializa array com as moedas existentes
	aMoedaFin := {}
	For nX := 1 to 99	// Limite de moedas possiveis atraves do CtbWizMoedas
		cVar := SuperGetMV("MV_MOEDA"+cValtoChar(nX),.F.,"")
		If Empty(cVar)
			Exit
		Else
			aAdd(aMoedaFin, StrZero(nX,2)+" "+Upper(cVar))
		EndIf
	Next
	aSort(aMoedaFin)
Endif

Return (aMoedaFin)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} DATAWINDOW

Converte a data em formato Windows para Clipper
Arquivo original: FINXFUN.PRX

@Author	Eduardo Riera
@since	12/03/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function DataWindow(_Data)

Local dRetorno := Ctod("01/01/1980","ddmmyy")

If ( ValType(_Data)=="N" )
	_Data := _Data - 29221 // Corresponde a 01/01/80
	dRetorno := dRetorno + _Data
Else
	If ( ValType(_Data)=="C" )
		dRetorno := Ctod(_Data,"ddmmyy")
	Else
		dRetorno := _Data
	EndIf
EndIf
Return(dRetorno)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} BOOLWINDOW

Converte um valor logico do Window p/ um valor do Clipper.
Arquivo original: FINXFUN.PRX

@Author	Eduardo Riera
@since	12/03/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function BoolWindow(Logic)

Local lRetorno

If ( ValType(Logic)=="N" )
	If ( Logic <= 0 )
		lRetorno := .F.
	Else
		lRetorno := .T.
	EndIf
Else
	If ( ValType(Logic)=="L" )
		lRetorno := Logic
	Else
		If ( ValType(Logic)=="C" )
			If ( LOGIC $ "VERDADEIRO#TRUE#.T.#0#SIM" )
				lRetorno := .T.
			Else
				lRetorno := .F.
			EndIf
		Else
			lRetorno := .T.
		EndIf
	EndIf
EndIf
Return(lRetorno)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FNATSAISON

Define se tratamento de naturezas estruturadas esta ativo (MV_NATSINT)
Arquivo original: FINXFUN.PRX

@Author	Mauricio Pequim Jr.
@since	17/12/2012
/*/
//-----------------------------------------------------------------------------------------------------
Function FNatSAIsOn()

If lNatSA == NIL  //Variavel estatica (vide topo
	lNatSA := SuperGetMv("MV_NATSINT",.T.,"2") == "1"
Endif

Return lNatSA


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} MASCNAT

Devolve a natureza editada de acordo com a mascara .
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	01/06/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function MascNat(cNatur)
Local j,i
Local cMascara := SuperGetmv("MV_MASCNAT",.F.,"")
Local cNatured :=""
Local nDesl    :=0

Default cNatur := ""
If  !Empty(cMascara )
	For i = 1 To Len(cMascara)

		For j=1 To Val(Substr(cMascara,i,1))
			cNatured+=Substr(cNatur,nDesl+j,1)
		NEXT j
		If Substr(cNatur,nDesl+j,1)== " " .OR. (nDesl+j) = 15
			j=99
			i=99
			nDesl := nDesl+Val(Substr(cMascara,i,1))
		Else
			cNatured+="."
			nDesl := nDesl+Val(Substr(cMascara,i,1))
		EndIf
	Next I

	//Retira ultimo caracter se for um ponto(.)
	IF Right(AllTrim(cNatured),1) == "."
		cNatured := Substr(cNatured,1,Len(cNatured)-1)
	EndIf
Else
	cNatured:= cNatur
EndIf

Return cNatured


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FAPRNUMCHQ

Executa o Ponto de Entrada PAGNUMCHEQ para sugerir o proximo numero valido para cheque do banco informado.
 (FINA050, FINA080, FINA090, FINA190 e FINA390).
Arquivo original: FINXFUN.PRX

@Author	Cristiano Denardi
@since	22/06/2005
/*/
//-----------------------------------------------------------------------------------------------------
Function FaPrNumChq(cBco,cAg,cNum,oChq,cChq,lVal)

Local lRet        := .T.
Local nPosBlock   := 0

Static aCodeBlock := {}

Default lVal := .F.

If ExistBlock("PAGNUMCHEQ")
	If !Empty(cBco) .And. !Empty(cAg) .And. !Empty(cNum) .And. ( lVal .Or. Empty(cChq) )
		cChq := ExecBlock("PAGNUMCHEQ",.F.,.F.,{cBco,cAg,cNum,cChq})
		oChq:Refresh()
	Endif
Endif


//Ponto de entrada para validacao do Banco
If ExistBlock("F080KCO")
	lRet := ExecBlock("F080KCO",.F.,.F.,{cBco,cAg,cNum})
Endif



// Ponto de entrada para desabilitação do objeto GET do numero do cheque

// Guarda o Codigo de bloco na primeira chamada deste ponto pela da rotina para posteriormente se
// for o caso restaura-la
If ( nPosBlock := aScan( aCodeBlock, { |x| x[1] == Alltrim( FunName() ) } ) ) == 0
	aAdd( aCodeBlock, { FunName(), oChq:bWhen } )
	nPosBlock := Len( aCodeBlock )
EndIf

If ExistBlock("PAGOBJCH")
	If !Empty(cBco) .And. !Empty(cAg) .And. !Empty(cNum)
		If !ExecBlock("PAGOBJCH",.F.,.F.,{cBco,cAg,cNum,cChq,oChq,lRet})
			// O bWhen sobrepuja a definicao de oChq:Disable() pois ele é a ultimo a ser executado
			// se o bwhen retornar vedadeiro mesmo definindo oChq:Disable() o campo fica habilitado
			// por isso eh desabilitado o bwhen
			oChq:Disable()
			oChq:bWhen := { || .F. }
		Else
		    // Habilita e volta o bWhen existente no oChq da rotina que chamou este pontos
			oChq:Enable()
			oChq:bWhen := aCodeBlock[nPosBlock][2]
		EndIf
		oChq:Refresh()
	EndIf
Endif

Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} DELTRBIR

Funcao de EXCLUSAO do arquivo do IRRF em transacao.
Arquivo original: FINXFUN.PRX

@Author	Mauricio Pequim Jr.
@since	21/10/2008
/*/
//-----------------------------------------------------------------------------------------------------
Function DELTRBIR(cEmp,cFil,lRPC,nTread,cArqTmp)
Return EXCTRBIR(cEmp,cFil,lRPC,nTread,cArqTmp) 



//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA060TROCA

Função de inversão de marcação ligada a FINATIPOS().
Arquivo original: FINXFUN.PRX

@Author	Marcos Patricio
@since	11/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function FA060Troca(nIt,aArray)
aArray[nIt,1] := !aArray[nIt,1]
Return aArray


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINATIPOS

Monta tela para seleção dos tipos de titulos as serem considerados em determinado processamento.
Arquivo original: FINXFUN.PRX

@Author	Eveli Morasco
@since	06/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function FinaTipos()
	
	FinRTipos(.T.)

Return


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINRTIPOS

Monta tela para seleção dos tipos de titulos as serem considerados em determinado processamento
(Relatorios).
Arquivo original: FINXFUN.PRX

@Author	Eveli Morasco
@since	06/05/1992
@param 	lFinATipos, logical, se a chamada foi efetuada pela função FinATipos
/*/
//-----------------------------------------------------------------------------------------------------
Function FinrTipos(lFinATipos As Logical)

	Local aTipos		As Array
	Local aTipoBack		As Array
	Local aFwSX5		As Array

	Local cAlias		As Character
	Local cCad			As Character
	Local cCapital		As Character
	Local cSX5Key		As Character
	Local cVar			As Character

	Local lRunDblClick	As Logical

	Local nChave		As Numeric
	Local nOpca			As Numeric
	Local nSeleciona	As Numeric
	Local nSX5			As Numeric
	Local nSX5Descri	As Numeric
	Local nSX5Filial	As Numeric
	Local nSX5Key		As Numeric
	Local nTipo			As Numeric

	Local oDlg			As Object
	Local oOk			As Object
	Local oNo			As Object
	Local oQual			As Object

	Default lFinATipos	:= .F.

	aFwSX5 			:= FwGetSX5("05")
	aTipoBack		:= {}
	aTipos			:= {}

	cAlias			:= Alias()
	cCad			:= OemToAnsi(STR0024) //"Tipos de títulos"
	cCapital		:= ""
	cSX5Key			:= ""
	cVar			:= "  "

	lRunDblClick	:= .T.

	nChave			:= 2
	nOpca			:= 0
	nSeleciona		:= 1
	nSX5			:= 0
	nSX5Descri		:= 4
	nSX5Filial		:= 1
	nSX5Key			:= 3
	nTipo			:= 0

	oDlg			:= Nil
	oOk				:= LoadBitmap(GetResources(), "LBOK")
	oNo				:= LoadBitmap(GetResources(), "LBNO")
	oQual			:= Nil

	For nSX5 := 1 To Len(aFwSX5)
		cSX5Key := SubStr(aFwSX5[nSX5][nSX5Key], 1, 3)
		If !lFinATipos .And. cSX5Key == "PR "
			Loop
		EndIf
		cCapital := Capital(AllTrim(aFwSX5[nSX5][nSX5Descri]))

		AAdd(aTipos, {.T., cSX5Key + " " + IIf(Len(cCapital) > 50, SubStr(cCapital, 1, 50), cCapital + Space(50 - Len(cCapital)))})
	Next nSX5

	aTipoBack := AClone(aTipos)

	nOpca := 0

	DEFINE MSDIALOG oDlg TITLE cCad From 9, 0 To 35, 50 OF oMainWnd

	@0.5, 0.3 TO 13.6, 20.0 LABEL cCad OF oDlg
	@2.3,3 Say OemToAnsi("  ")
	@1.0,.7 LISTBOX oQual VAR cVar Fields HEADER "", OemToAnsi( STR0024 ) SIZE 150,170 ON DBLCLICK (aTipoBack := FA060Troca(oQual:nAt, aTipoBack), oQual:Refresh()) NOSCROLL //"Tipos de títulos"
	oQual:SetArray(aTipoBack)
	oQual:bLine := {|| {If(aTipoBack[oQual:nAt][1], oOk, oNo), aTipoBack[oQual:nAt][2]}}
	oQual:bHeaderClick := {|oObj, nCol| If(lRunDblClick .And. nCol == 1, AEval(aTipoBack, {|e| e[1] := !e[1]}), Nil), lRunDblClick := !lRunDblClick, oQual:Refresh()}

	DEFINE SBUTTON FROM 10  , 166  TYPE 1 ACTION (nOpca := 1, oDlg:End()) ENABLE OF oDlg
	DEFINE SBUTTON FROM 22.5, 166  TYPE 2 ACTION oDlg:End() ENABLE OF oDlg

	ACTIVATE MSDIALOG oDlg CENTERED

	If nOpca == 1
		FwFreeArray(aTipos)
		aTipos := AClone(aTipoBack)
	EndIf

	//Monta a string de tipos para filtrar o arquivo
	cTipos := ""
	For nTipo := 1 To Len(aTipos)
		If aTipos[nTipo][nSeleciona]
			cTipos += SubStr(aTipos[nTipo][nChave], 1, 3) + "/"
		EndIf
	Next nTipo

	FreeObj(oOk)
	FreeObj(oNo)

	FwFreeArray(aTipos)
	FwFreeArray(aTipoBack)
	FwFreeArray(aFwSX5)

	DbSelectArea(cAlias)

Return Nil

//------------------------------------------------------------------------------------------
/*/{Protheus.doc} FGetSE5Seq

Retorna a última sequencia de baixa do SE5
Arquivo original: FINXFUN.PRX

@author    Marcos Berto
@since     16/01/13

@return cSeq 	- Última sequência de baixa
/*/
//------------------------------------------------------------------------------------------
Function FGetSE5Seq(cFil,cPrefixo,cNum,cParcela,cTipo,cCliFor,cLoja)

Local nTamSeq		:= TamSX3("FK1_SEQ")[1]
Local cSeq			:= Replicate("0",nTamSeq)
Local aAreaSE1		:= SE1->(GetArea())

Default cFil		:= ""
Default cPrefixo	:= ""
Default cNum		:= ""
Default cParcela	:= ""
Default cTipo		:= ""
Default cCliFor		:= ""
Default cLoja		:= ""

SE1->(dbSetOrder(1))
If SE1->(MSSeek(cFil+cPrefixo+cNum+cParcela+cTipo))
	cSeq := FaNxtSeqBx()
Endif

RestArea(aAreaSE1)
FwFreeArray(aAreaSE1)

Return cSeq


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SLDBCO

Retorna o Saldo Bancario em uma data .
Arquivo original: FINXFUN.PRX

@Author	Eduardo Riera
@since	12/03/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function SldBco(cBanco,cAgencia,cConta,dData,nMoeda,lLimite)
Local aArea     := { Alias() , IndexOrd() , Recno() }
Local aAreaSA6  := { SA6->(IndexOrd()), SA6->(Recno()) }
Local aBcoSA6   := {}
Local nSaldo    := 0
Local bCondSA6
Local nCntFor   := 0
Local nMaxFor   := 0
Local lFirst := .T.
Local nLimite := 0

lLimite := IIF(lLimite == NIL, .F., lLimite)

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Testa os parametros vindos do Excel                  ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cBanco   := If(Empty(cBanco),"",cBanco)
cAgencia := If(Empty(cAgencia),"",cAgencia)
cConta   := If(Empty(cConta),"",cConta)
cConta   := If(Empty(cConta),"",cConta)
dData    := If(Empty(dData),dDataBase,dData)
nMoeda      := If(Empty(nMoeda),1,nMoeda)
If ( ValType(cBanco)=="N" )
	cBanco := StrZero(cBanco,TamSX3("A6_COD")[1])
EndIf
If ( ValType(cAgencia)=="N" )
	cAgencia := StrZero(cAgencia,TamSX3("A6_AGENCIA")[1])
Else
	cAgencia := PadR(cAgencia,TamSX3("A6_AGENCIA")[1])
EndIf
If ( ValType(cConta)=="N" )
	cConta := StrZero(cConta,TamSX3("A6_NUMCON")[1])
Else
	cConta := PadR(cConta,TamSX3("A6_NUMCON")[1])
EndIf
If ( ValType(nMoeda)=="C" )
	nMoeda := Val(nMoeda)
EndIf
dData := DataWindow(dData)
If ( Upper(cBanco) $ "TODOS#ALL")
	cBanco := ""
EndIf
If ( Upper(cAgencia) $ "TODOS#ALL")
	cAgencia := ""
EndIf
If ( Upper(cConta) $ "TODOS#ALL")
	cConta := ""
EndIf

dbSelectArea("SA6")
dbSetOrder(1)
dbSeek(xFilial()+cBanco+cAgencia+cConta,.T.)
bCondSA6 := {|| !Eof() .And. xFilial("SA6")== SA6->A6_FILIAL .And.;
	(Empty(cBanco).Or.cBanco==SA6->A6_COD) .And.;
	(Empty(cAgencia).Or.cAgencia==SA6->A6_AGENCIA).And.;
	(Empty(cConta).Or.cConta==SA6->A6_NUMCON) }
While ( Eval(bCondSA6) )

	// Se considerar limite do chq especial para composicao do saldo
	If lLimite .and. lFirst
		nLimite := SA6->A6_LIMCRED
		lFirst := .F.
	Endif

	aadd(aBcoSA6,{ SA6->A6_COD , SA6->A6_AGENCIA , SA6->A6_NUMCON })
	dbSelectArea("SA6")
	dbSkip()
EndDo
nMaxFor := Len(aBcoSA6)
For nCntFor := 1 To nMaxFor
	nSaldo += RecSalBco(aBcoSa6[nCntFor,1],aBcoSa6[nCntFor,2],aBcoSa6[nCntFor,3],dData)
Next

If lLimite
	nSaldo += nLimite
Endif

dbSelectArea("SA6")
dbSetOrder(aAreaSA6[1])
dbGoto(aAreaSA6[2])

dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])

Return(xMoeda(nSaldo,1,nMoeda,dData))


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ADMABRESMO

Retorna um array com as informacoes das filias das empresas (funções fc020Venda/fc020Compra/FLOJASIRRF).
Arquivo original: FINXFUN.PRX

@Author	Orizio
@since	22/01/2010
/*/
//-----------------------------------------------------------------------------------------------------
Static Function AdmAbreSM0()
	Local aArea			:= SM0->( GetArea() )
	Local aAux			:= {}
	Local aRetSM0		:= {}
	Local lFWLoadSM0	:= .T.
	Local lFWCodFilSM0 	:= .T.

	If lFWLoadSM0
		aRetSM0	:= FWLoadSM0()
	Else
		DbSelectArea( "SM0" )
		SM0->( DbGoTop() )
		While SM0->( !Eof() )
			aAux := { 	SM0->M0_CODIGO,;
						IIf( lFWCodFilSM0, FWGETCODFILIAL, SM0->M0_CODFIL ),;
						"",;
						"",;
						"",;
						SM0->M0_NOME,;
						SM0->M0_FILIAL }

			aAdd( aRetSM0, aClone( aAux ) )
			SM0->( DbSkip() )
		End
	EndIf

	RestArea( aArea )
Return aRetSM0


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINDPESQ

Retorna um array contendo todas as descricoes de indice para o alias solicitado. (FINA060/FINA061).
Arquivo original: FINXFUN.PRX

@Author	Pedro Pereira Lima
@since	04/08/2010
/*/
//-----------------------------------------------------------------------------------------------------
Function FIndPesq(cAliasPesq)
Local aArea := GetArea()
Local aRet  := {}

Default cAliasPesq := ""

If !Empty(cAliasPesq)
	SIX->(dbSetOrder(1))
	SIX->(DbSeek(cAliasPesq))
	While !SIX->(Eof()) .And. SIX->INDICE == cAliasPesq
		If cAliasPesq == "SE1"
			aAdd(aRet,{"Filial + " + SIX->DESCRICAO,1})
		Else
			aAdd(aRet,{SIX->DESCRICAO,1})
		EndIf
		SIX->(dbSkip())
	EndDo
EndIf

RestArea(aArea)

Return aRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINADTSLD

Retorna verdadeiro se existe saldo de adiantamento relacionado com pedido de compras/vendas.
Arquivo original: FINXFUN.PRX

@Author	Gustavo Henrique
@since	15/09/2011
/*/
//-----------------------------------------------------------------------------------------------------
Function FinAdtSld( cCart, cChave )

Local bChave
Local nSaldo	:= 0
Local aArea     := GetArea()
Local cFilFIE	:= xFilial( "FIE" )

If aAdianta == NIL
	aAdianta := ProtCfgAdt()
	bFilFIE := Iif(aAdianta[1,4],{|| FIE_FILORI==cFilAnt .Or. Empty(FIE_FILORI)},{||.T.})
	lAdComPart := aAdianta[1,5] .And. 'C' $ aAdianta[1,1]+aAdianta[1,2]+aAdianta[1,3]
Endif

If cCart == "P"
	FIE->( DBSetOrder( 3 ) )
	bChave := { || FIE->( cFilFIE + cCart + cChave == FIE_FILIAL + FIE_CART + FIE_FORNEC + FIE_LOJA + FIE_PREFIX + FIE_NUM + FIE_PARCEL + FIE_TIPO ) }
Else
	FIE->( DBSetOrder( 2 ) )
	bChave := { || FIE->( cFilFIE + cCart + cChave == FIE_FILIAL + FIE_CART + FIE_CLIENT + FIE_LOJA + FIE_PREFIX + FIE_NUM + FIE_PARCEL + FIE_TIPO ) }
EndIf

FIE->( MsSeek( xFilial( "FIE" ) + cCart + cChave ) )

// Percorre os pedidos relacionados ao adiantamento 
Do While FIE->( ! Eof() .And. Eval( bChave ) ) 
	If FIE->(Eval(bFilFIE))
		nSaldo += FIE->FIE_SALDO
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se achou uma ocorrencia com saldo, nao precisa verificar as proximas ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nSaldo > 0
			Exit
		EndIf
	EndIf
	FIE->( DBSkip() )
EndDo

lRet := ( nSaldo > 0 )

RestArea( aArea )

Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} TAMPARCELA

Verifica o tamanho do campo parcela e retorna valor desejado dependendo do tamanho da parcela.
Arquivo original: FINXFUN.PRX

@Author	Claudio D. de Souza
@since	29/05/2002
/*/
//-----------------------------------------------------------------------------------------------------
Function TamParcela(cCampo,uPar1,uPar2,uPar3)
Static cCampoAnt
Static aTamParc
// Carrega o tamanho do campo, somente quando este ainda não estiver carregado para
// evitar leitura do SX3 desnecessaria.
If cCampoAnt == Nil .Or. cCampoAnt != cCampo .Or. aTamParc == Nil
	aTamParc := TamSx3(Upper(cCampo))
	cCampoAnt := cCampo
Endif

Return If(aTamParc[1]==1,uPar1,If(aTamParc[1]==2,uPar2,uPar3))


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA080JUROS

Calcula juros de um determinado titulo.
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	06/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function fa080Juros(nMoeda, nVlrTit, cAlias, dUltBaixa, nTxMoeda, nCasDec)

Local nAtraso 		:= 0
Local lRet 			:= .F.
Local cAliasAnt 	:= Alias()
Local nMVFINJRTP 	:= SuperGetMv("MV_FINJRTP",,1)
Local cTpDocJR		:= PadR("JR",TamSX3("FK2_TPDOC")[1])
Local cDataBase 	:= DtoS(dDataBase)

Default cAlias 		:= "SE2" 
Default nMoeda 		:= 1
Default nVlrTit 	:= (cAlias)->E2_SALDO 
Default dUltBaixa 	:= (cAlias)->E2_BAIXA
Default nTxMoeda 	:= 0
Default nCasDec  	:= 2 

nJuros := 0
dbSelectArea(cAlias)

If __lRpoR33 == NIL
	__lRpoR33 := GetRpoRelease() >= "12.1.033"
Endif

IF !(Empty(E2_VALJUR) .and. Empty(E2_PORCJUR))

	If Empty(dUltBaixa)
		If DataValida((cAlias)->E2_VENCTO,.T.) < dBaixa
			dVencto := (cAlias)->E2_VENCTO
		Else
			dVencto := DataValida((cAlias)->E2_VENCTO,.t.)
		Endif
	Else
		If DataValida((cAlias)->E2_VENCTO,.T.) < dUltBaixa
			dVencto := dUltBaixa
		Else
			dVencto := DataValida((cAlias)->E2_VENCTO,.t.)
		Endif
	Endif

	nAtraso := dBaixa - dVencto

	IF Dow((cAlias)->E2_VENCTO) == 1 .Or. Dow((cAlias)->E2_VENCTO) == 7
		IF Dow(dBaixa) == 2 .and. nAtraso <= 2
			nAtraso := 0
		EndIF
	EndIF
	nAtraso := IIF(nAtraso < 0, 0, nAtraso)

	If nAtraso != 0
		If nMVFINJRTP <> 1 .and. !Empty(E2_VALJUR) .and. !Empty(E2_PORCJUR)
			If nMVFINJRTP == 2    // soh juros
				nJuros := nVlrTit * (E2_PORCJUR * nAtraso)/100
			Else   //nMVFINJRTP == 3    ambos
				nJuros:=(E2_VALJUR * nAtraso) + (nVlrTit * (E2_PORCJUR*nAtraso)/100)
			EndIf
		Else  // soh taxa de permanencia

			If __lRpoR33		//Release 12.1.33 e posteriores FKS
				If FINFK2Atv(cAlias)
					IF !Empty((cAlias)->E2_VALJUR)
						lRet := .T.
					EndIf
				Endif
			Else
				dbSelectArea("SE5")
				dbSetOrder(2)

				cSeq := ""
				If SE5->(dbSeek(xFilial("SE5")+ cTpDocJR +(cAlias)->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+cDataBase+E2_FORNECE+E2_LOJA)))

					While SE5->(!Eof()) .AND. xFilial("SE5")+ cTpDocJR +(cAlias)->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+cDataBase+E2_FORNECE+E2_LOJA) ==;
							E5_FILIAL+E5_TIPODOC+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+cDataBase+E5_CLIFOR+E5_LOJA 
						If E5_SITUACA <> "C"
							cSeq := E5_SEQ
						EndIf
						SE5->(DbSkip())
					End

					If !SE5->(dbSeek(xFilial("SE5")+PadR("JR",TamSX3("E5_TIPODOC")[1])+(cAlias)->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+DtoS(dDataBase)+E2_FORNECE+E2_LOJA+cSeq))).Or.SE5->E5_SITUACA=="C"
						IF !Empty((cAlias)->E2_VALJUR)
							lRet := .T.
						Endif
					EndIf
				Else
					IF !Empty((cAlias)->E2_VALJUR)
						lRet := .T.
					Endif
				EndIf
			Endif	

			//Calculo dos Juros
			If lRet
				nJuros := (cAlias)->E2_VALJUR * nAtraso
			ElseIf !Empty((cAlias)->E2_PORCJUR)
				nJuros := nVlrTit * ((cAlias)->E2_PORCJUR * nAtraso)/100
			Endif

		EndIf
		//Permite a alteracao dos Juros em Ponto de Entrada
		If ExistBlock("F080JUR")
			nJuros := ExecBlock("F080JUR",.f.,.f.)
		Endif

		If nJuros > 0 .And. (cAlias)->E2_MOEDA != nMoeda
			If (cAlias)->E2_MOEDA > 1 .And. nMoeda > 1  
				nJuros := xMoeda(nJuros, (cAlias)->E2_MOEDA, nMoeda, dDataBase, nCasDec, (cAlias)->E2_TXMOEDA, nTxMoeda)
			ElseIf (cAlias)->E2_MOEDA > 1
				nJuros := xMoeda(nJuros, (cAlias)->E2_MOEDA, nMoeda, dDataBase, nCasDec, nTxMoeda, 0)
			Else
				nJuros := xMoeda(nJuros, (cAlias)->E2_MOEDA, nMoeda, dDataBase, nCasDec, 0, nTxMoeda)
			EndIf
			
			If nCasDec <= 2
				nJuros := Round(nJuros, 2)
			EndIf 
		EndIf
	EndIf
EndIf

DbSelectArea(cAliasAnt)

Return nJuros


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINFK2Atv

Verifica se o título tem uma baixa ativa em uma determinada data. 

Utilizada, por exemplo, para verificar se tenho ou não que calcular juros numa determinada baixa 
Caso já tenha uma outra baixa parcial do título na data, não calcula
Caso não tenha uma outra baixa parcial do título na data, calcula

@Author	Mauricio Pequim Jr
@since	28/01/2021
/*/
//-----------------------------------------------------------------------------------------------------
Function FINFK2Atv(cAlias,dData)

Local lRet := .T.
Local cChaveFK7 As Character
Local cChaveTit As Character
Local cAliasFK2 As Character
Local cDataBase As Character

DEFAULT cAlias := ''
DEFAULT dData := dDataBase

//Dados da tabela auxiliar com o código do título a pagar
cChaveTit := xFilial("SE2", (cAlias)->E2_FILORIG) + "|" + (cAlias)->E2_PREFIXO + "|" + (cAlias)->E2_NUM     + "|" + (cAlias)->E2_PARCELA + "|" + ;
	              			(cAlias)->E2_TIPO     + "|" + (cAlias)->E2_FORNECE + "|" + (cAlias)->E2_LOJA
cChaveFK7 := FINGRVFK7( "SE2", cChaveTit )

cDataBase := DtoS(dData)

cAliasFK2 := ""

If __oPreparB == NIL

	cQuery 	:= "SELECT FK2_FILORI, FK2_IDFK2, FK2_SEQ FROM "+ RetSqlName("FK2") +" FK2 "
	cQuery 	+= "WHERE FK2_IDDOC = ? AND"
	cQuery 	+= " FK2_RECPAG = 'P' AND"
	cQuery 	+= " FK2_DATA = ? AND"
	cQuery 	+= " D_E_L_E_T_ = ' ' "

	cQuery	+= " AND NOT EXISTS( "
	cQuery	+= " SELECT FK2EST.FK2_IDDOC FROM " + RetSqlName("FK2") +" FK2EST"
	cQuery	+= " WHERE FK2EST.FK2_IDDOC = ? "
	cQuery	+= " AND FK2EST.FK2_SEQ = FK2.FK2_SEQ "
	cQuery	+= " AND FK2EST.FK2_TPDOC = 'ES' "
	cQuery	+= " AND FK2EST.D_E_L_E_T_ = ' ') "

	cQuery 	:= ChangeQuery(cQuery)
	__oPreparB:=FWPreparedStatement():New(cQuery)
Endif

__oPreparB:SetString(1,cChaveFK7)
__oPreparB:SetString(2,cDataBase)
__oPreparB:SetString(3,cChaveFK7)

cQuery := __oPreparB:GetFixQuery()

cAliasFK2 := mpsysopenquery(cQuery)

IF !( cAliasFK2 )->(Eof())
	lRet := .F.
Endif

( cAliasFK2 )->( dbCloseArea() )

dbSelectArea(cAlias)

Return lRet



//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FADESCFIN

Calcula o desconto Financeiro de um determinado titulo.
Arquivo original: FINXFUN.PRX

@Author	Eduardo Riera
@since	24/11/1997
/*/
//-----------------------------------------------------------------------------------------------------
Function FaDescFin(cAliasSE1,dDtBaixa,nValor,nMoeda,lVerBxado,lTemGEM)
Local aArea     := GetArea()
Local nDesconto := 0
Local dDtLimite := 0
Local nPosData  := 0
Local nJuros	:= 0
Local nDias
Local nVPA

Default lF070DSCF	:= ExistBlock("F070DSCF")
Default lF070DES	:= ExistBlock("F070DES")
Default lDiaDesc	:= SuperGetMv("MV_DIADESC",.F.,.F.)
Default cAliasSE1	:= "SE1"
Default lVerBxado	:= .F. //Quando .T., devera retornar o valor do desconto financeiro de titulos baixados.
Default lTemGEM		:= ExistTemplate("GEMDESCTO") .And. HasTemplate("LOT")

If lTemGEM
	nCM1		:= iIf(Type("nCM1")     != "N",0,nCM1)
	nProRata	:= iIf(Type("nProRata") != "N",0,nProRata)
EndIf

If __cMVDESCFIN	== Nil
	__cMVDESCFIN := SuperGetMV("MV_DESCFIN",,"I")
EndIf
If __cMVDTDESCF	== Nil
	__cMVDTDESCF:= SuperGetMv("MV_DTDESCF")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso a baixa seja parcial, o desconto ser  concedido totalmente na pri-³
//³ meira baixa.                                                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea(cAliasSE1)
If Empty ((cAliasSE1)->E1_BAIXA) .Or. lVerBxado .Or.(__cMVDESCFIN =="P")
	nPosData := FieldPos(&(__cMVDTDESCF))
	dDtBaixa := If(Empty(dDtBaixa),dDataBase,dDtBaixa)
	nMoeda   := If(Empty(nMoeda),1,nMoeda)
	nValor   := If(Empty(nValor),(cAliasSE1)->E1_VALOR,nValor)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcula a Data Limite para desconto do Titulo                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty((cAliasSE1)->E1_LIDESCF) // Se existir a data limite para pagto. com desconto, apos o
													// vencto. do titulo, utiliza esta data.
		dDtLimite := (cAliasSE1)->E1_LIDESCF // Data fixa
	Else
		If ( nPosData == 0 )
			dDtLimite := (cAliasSE1)->E1_VENCREA - (cAliasSE1)->E1_DIADESC
		Else
			dDtLimite := FieldGet(nPosData) - (cAliasSE1)->E1_DIADESC
		Endif
	EndIf
	If lDiaDesc
		dDtLimite := DataValida(dDtLimite,.T.)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcula o Valor do Desconto do Titulo                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF (cAliasSE1)->E1_TIPODES $ " 1" // Desconto fixo ate a data limite
		If ( !Empty(dDtLimite) .And. dDtBaixa <= dDtLimite ) .Or.;
			(AllTrim((cAliasSE1)->E1_ORIGEM) $ 'S|L|T' .And. (cAliasSE1)->E1_IDLAN > 0)

			If FwIsInCallStack("TK271CallCenter")
				nDesconto := (cAliasSE1)->E1_SALDO * ((cAliasSE1)->E1_DESCFIN / 100 )
				If 	(cAliasSE1)->(FieldPos("E1_DESCJUR")) > 0
					nJuros 		:= nValor - (cAliasSE1)->E1_SALDO
					nDesconto	+= nJuros * ((cAliasSE1)->E1_DESCJUR / 100 )
				EndIf
			ElseIF FUNNAME()=="FINR130" .AND. (cAliasSE1)->E1_DESCONT<> 0 .AND. (cAliasSE1)->E1_DESCFIN == 0
				nDesconto:=0
			Else
				nDesconto := nValor * ((cAliasSE1)->E1_DESCFIN / 100 )
			EndIf
		Endif
	ElseIf (cAliasSE1)->E1_TIPODES == "2"	// Desconto por dia de antecipacao
		If ( nPosData == 0 )
			nDias := (cAliasSE1)->E1_VENCREA - dDtBaixa
		Else
			nDias := FieldGet(nPosData) - dDtBaixa
		Endif
		If nDias > 0
			// Calcula o novo valor da prestacao
			nVPA := nValor / (((1+((cAliasSE1)->E1_DESCFIN / 100 )))^(nDias/30))
			// Calcula o desconto
			nDesconto := nValor - nVPA
		Endif
	EndIf
	If ( nDesconto > nValor )
		nDesconto := nValor
	EndIf
	nDesconto := Round(NoRound(xMoeda(nDesconto,(cAliasSE1)->E1_MOEDA,nMoeda,,3),3),2)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ PONTO DE ENTRADA F070DES                                      ³
	//³ Recalculo do desconto financeiro.                          	  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF lF070DES
		nDesconto := ExecBlock("F070DES",.F.,.F.,nDesconto)
	EndIf

EndIf

//
// Template GEM
//
// Executa os calculos das variaveis private:
//		nCM1
//		nProRata
//
If lTemGEM
	nDesconto := ExecTemplate("GEMDESCTO",.F.,.F.,{cAliasSE1 ,dDatabase ,nDesconto ,(cAliasSE1)->E1_BAIXA ,(cAliasSE1)->E1_SALDO})
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ PONTO DE ENTRADA F070DES                                      ³
//³ Recalculo do desconto financeiro.                          	  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
IF lF070DSCF
	nDesconto := ExecBlock("F070DSCF",.F.,.F.,nDesconto)
EndIf


RestArea(aArea)
Return(nDesconto)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA171CALC

Calcula o Valor Atual da Aplicacao/Emprestimo Financeiro.
Arquivo original: FINXFUN.PRX

Parametro
Deve estar posicionado no SEH
ExpD1 : Data do Saldo
ExpN2 : Moeda do Saldo
ExpL3 : Considera data de resgate
ExpN3 : Valor da Moeda do Saldo
ExpD5 : Ultima Apropriacao
ExpN4 : Valor da cota anterior
ExpN5 : Valor da cota atual
ExpN6 : Valor do resgate
ExpL1 : Por Filial/Empresa


@Author	Eduardo Riera
@since	01/04/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function Fa171Calc(	dDtSaldo,nSaldo,lResgate,nVlMoeda,dUltApr,nCotaAnt,nCotaAtual,;
					nVlResgate, lFilial, lDeduzIR, nTaxaIrf, lFinr820 )

LOCAL aRetorno	:= {}
LOCAL aAglutina	:= {}
LOCAL aArea		:= { Alias() , IndexOrd() , Recno() }
LOCAL aAreaSEH	:= { SEH->(IndexOrd()) , SEH->(Recno()) }
LOCAL cNumero	:= SEH->EH_NUMERO
LOCAL nCntFor	:= 0
LOCAL nCntFor2	:= 0
LOCAL nMaxFor	:= 0
Local lL11033	:= SuperGetMv("MV_L11033",,.F.)

Default lFilial	:= .T.
Default lDeduzIR	:= .T.
Default lFinr820	:= .F.

nCotaAnt		:= Iif(nCotaAnt==Nil,0,nCotaAnt)
nCotaAtual		:= Iif(nCotaAtual==Nil,0,nCotaAtual)
nVlResgate		:= Iif(nVlResgate==Nil,0,nVlResgate)
dbSelectArea("SEH")

If lFilial
	dbSetOrder(1)
	If ( SEH->EH_REVISAO !="01" )
		dbSeek(xFilial("SEH")+SEH->EH_NUMERO)
	EndIf
Endif

While ( !Eof() .And. If(lFilial, xFilial() == SEH->EH_FILIAL, .T.) .And.;
		SEH->EH_NUMERO == cNumero )
	If ( SEH->EH_APLEMP == "APL" )
		aAglutina := Fa171CalAp(dDtSaldo,nSaldo,lResgate,nVlMoeda,dUltApr,nCotaAnt,;
								 	   nCotaAtual,nVlResgate,, lFilial,,lDeduzIR,nTaxaIrf,lFinr820)
	Else
		If lL11033
			aAglutina := Fa171CalEp(dDtSaldo,nSaldo,lResgate,nVlMoeda,dUltApr,lFilial, lDeduzIR, nTaxaIrf)
		Else
			aAglutina := Fa171CalEp(dDtSaldo,nSaldo,lResgate,nVlMoeda,dUltApr,lFilial)
		EndIf
	EndIf
	If ( !Empty(aRetorno) )
		nMaxFor := Len(aAGlutina)
		For nCntFor := 1 To nMaxFor
			If ( SEH->EH_APLEMP == "EMP" )
				For nCntFor2 := 1 To Len(aAGlutina[nCntFor])
					aRetorno[nCntFor][nCntFor2] += aAglutina[nCntFor][nCntFor2]
				Next
			Else
				aRetorno[nCntFor] += aAglutina[nCntFor]
			Endif
		Next nMaxFor
	Else
		aRetorno := aAglutina
	EndIf
	dbSelectArea("SEH")
	dbSkip()
EndDo

//Caso nao tenha se LOCALizado a aplicacao para resgate
//Preenche-se o array com zeros para que nao ocorram problemas de
//verificacao dos valores em processos complementares
If Empty(aRetorno)
	aRetorno := { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
Endif

dbSelectArea("SEH")
dbSetOrder(aAreaSEH[1])
dbGoto(aAreaSEH[2])

dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])

Return ( aRetorno )


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA171CALAP

Calcula o Valor da Aplicacao Financeira  (Fa171Calc).
Arquivo original: FINXFUN.PRX

Parametro
Deve estar posicionado no SEH
ExpD1 : Data do Saldo
ExpN2 : Moeda do Saldo
ExpL3 : Considera data de resgate
ExpN4 : Valor da cota anterior
ExpD5 : Data da Ultima apropriacao
ExpN6 : Valor da Ultima cota registrada
ExpL4 : Por Filial/Empresa

@Author	Eduardo Riera
@since	30/03/1998
/*/
//-----------------------------------------------------------------------------------------------------
Static Function Fa171CalAp(	dDtSaldo,nSaldo,lResgate,nVlMoeda,dUltApr,nCotaAnt,nCotaAtual,;
										nVlResgate,nVlrCota,lFilial,nTaxa,lDeduzIR,nTaxaIrf,lFinr820)
Local cDiasUtCo as Character
Local nDiasCalc as Numeric
Local nDiasCor	as Numeric
Local dDtCont	as Numeric
Local nDiaCont	as Numeric
Local nDiasAno	as Numeric
										
Local aArea			:= GetArea()
Local dDtCalculo	:= DataValida(SEH->EH_DATA,.T.)
Local nPosMoeda		:= SM2->(FieldPos("M2_MOEDA"+AllTrim(Str(SEH->EH_MOEDA,2))))
Local nFatorDia		:= 1 // Rentabilidade no Dia
Local nFatorAtu		:= 1 // Rentabilidade atual
Local nVlrAplAnt	:= 0 
Local nVlrAplAtu	:= 0 // Valor da Aplicacao no Mes
Local nJurAplAtu	:= 0 // Juros da Aplicacao no Mes
Local nIrfAplAtu	:= 0 // I.R.  da Aplicacao no Mes
Local nIofAplAtu  	:= 0 // IOF sobre os rendimentos da aplicação
Local lClsIof   	:= SEH->EH_CLSIOF == "1"
Local lRetorna      := .F.
Local nProporcao	:= 0
Local dData			:= Ctod("")
Local nAjVarCab		:= GetMv("MV_APLVCAB")
Local nUltCota		:= 0
Local nRdBruto                  // Redimento bruto
Local nIRRdBruto                // Ir sobre o rendimento bruto
Local nVlLiquido                // Valor liquido subtraindo o Ir sobre o rendimento bruto
Local nDelta                    // Aliquota apurado entre os valores das cotas
Local nBaseCalc                 // Base de calculo para o valor do Ir
Local nResgBruto                // Resgate bruto
Local nSldAplicado				// Saldo a ser aplicado
Local nDias			:= IF(FwIsInCallStack("FINR820"),(dDTsaldo - SEH->EH_DATA),(dDataBase - SEH->EH_DATA))
Local cTabIof		:= "A0"
Local cFilAp  		:= If(lFilial, xFilial(), SEH->EH_FILIAL)
Local nTaxaSEI		:= 0
Local cBaseCdi		:= GetMv("MV_BASECDI",,"2") // 1-Base mensal, 2-Base Anual
Local nRendAprop	:= 0
Local nIRAprop		:= 0
Local dFerMunic		:= Ctod("")
Local lFerMunic		:= .F.
Local cDate			:= SET(_SET_DATEFORMAT)
Local aSA6          := SA6->(GetArea())
Local nValorCotas	:= 0 // Valor em cotas
Local nValorReais	:= 0 // Valor em Reais
Local nRendimento	:= 0 // Valor do rendimento proporcional ao resgate
Local dDtCota
Local nRdMes		:= 0
Local aTabIrf		:= {{ 180, 22.5 },{ 360, 20.0 },{ 720, 17.5 },{ 1000000, 15.0 }}
Local nDiasCTB		:= GetNewPar("MV_DIASCTB", 360) //Quantidade de dias para o ano contábil
Local nFatorUm		:= DEC_CREATE("1",64,0)
Local nResultParc	:= DEC_CREATE("1",64,16)
Local nValor1		:= 0
Local nValor2		:= 0
Local nFormula1		:= 0
Local nFormula2		:= 0
Local nDec1			:= 0
Local nDec2			:= 0
Local lAplImune		:= SuperGetMv("MV_APLIMUN",,"1") $ "2|3"
Local lZeraIRApr	:= .F.
Local nRendAux		:= 0
Local lAniverMes	:= .T.
Local nPeriodo		:= 0
Local nQtdMeses		:= 0
Local lNewCalc		:= TableInDic('FO3')
Local aAnivCP		:= {}
Local nX			:= 0
Local aTaxas		:= {}
Local nSaldoCP		:= 0
Local lOldCP		:= .F.
Local nTaxaCP		:= 0
Local oFerMunic		:= FerMunic()
Local oVal			:= NIL
Local aUltComeCotas	:= {}
Local nVlrUltCome	:= 0
Local cTpRenApl4	:= SuperGetMv("MV_RENAPL4",,"1") 	//Tipo de Rendimento Apl. FAF: 1= Acumulado;2=Mensal
Local lF171RdMn		:= Iif(ExistBlock("F171RDMN"),.T.,.F.)
Local lF171RdBr		:= Iif(ExistBlock("F171RDBR"),.T.,.F.)
local fAux			:= DEC_CREATE("1",64,16)

Default nVlrCota	:= 0
Default nTaxa		:= SEH->EH_TAXA
// A taxa de IR sera: Se o campo estiver vazio, utiliza a tabela AR se ela existir ou a tabela acima caso contrario.
// Se o campo de TAXA de IR estiver preenchido no cadastro, utiliza esta taxa.
Default nTaxaIrf	:= TxIRResgate( nDias , aTabIrf )  
Default lDeduzIR	:= .T.
Default lFinr820	:= .F.

nCotaAnt	:= Iif(nCotaAnt==Nil,0,nCotaAnt)
nCotaAtual	:= Iif(nCotaAtual==Nil,0,nCotaAtual)
nVlMoeda  	:= If(nVlMoeda==Nil,0,nVlMoeda)
nVlResgate	:= Iif(nVlResgate==Nil,0,nVlResgate)
nRdBruto	:= 0
nIRRdBruto	:= 0
nVlLiquido	:= 0
nDelta		:= 0
nBaseCalc	:= 0
nResgBruto	:= 0
nSldAplicado:= 0
cDiasUtCo	:= SuperGetMV("MV_APLUTCO",,'1') // 1 - Dias Corridos, 2 - Dias Uteis
nDiasCor	:= 0

If lNewCalc
	If AllTrim(SEH->EH_TIPO) != "CP"
		lNewCalc := .F.
	EndIf
EndIf

//Ponto de entrada para validacao do dias CTB
If ExistBlock("FADIACTB")
	nDiasCTB := ExecBlock("FADIACTB",.F.,.F.,{nDiasCTB})
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Calcula a data de Ultima apropriacao                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( dUltApr != Nil )
	DbSelectArea("SEI")
	DbSetOrder(1)
	If lResgate
		DbSeek(cFilAP+SEH->EH_APLEMP+SEH->EH_NUMERO+SEH->EH_REVISAO)
		While ( !Eof() .And. SEI->EI_FILIAL == cFilAP .And.;
				SEI->EI_APLEMP == SEH->EH_APLEMP .And.;
				SEI->EI_NUMERO == SEH->EH_NUMERO .And.;
				SEI->EI_REVISAO== SEH->EH_REVISAO )
			If ( SEI->EI_DATA <= dUltApr .And. SEI->EI_STATUS!="C" )
				dData := Max(dData,SEI->EI_DATA)
				nTaxaSEI	:= SEI->EI_TAXA
				nUltCota := SEI->EI_VLRQTA
			EndIf
			dbSelectArea("SEI")
			dbSkip()
		EndDo
	EndIf
	If ( Empty(dData) )
		dData := dDtCalculo
	Else
		nSaldo := Fa171CalAp(dData,SEH->EH_SALDO,lResgate,,,,,,, lFilial,nTaxaSEI)[1]
	EndIf
EndIf

dUltApr := If(Empty(dData),dUltApr,dData)
dDtCalculo := If(Empty(dUltApr),dDtCalculo,dUltApr)
dDtSaldo := If(Empty(dDtSaldo),dDataBase,dDtSaldo)
nSaldo   := If(Empty(nSaldo ) ,SEH->EH_SALDO,nSaldo)
lResgate := If(lResgate==Nil,.F.,lResgate)

dbSelectArea("SEH")
If ( dDtSaldo == SEH->EH_DATARES .Or.;
		(Empty(SEH->EH_DATARES) ) .Or.;
		lResgate )
	Do Case
	Case !Empty(SEH->EH_FORMULA)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ A formula deve utilizar as variaveis PRIVATES dFormula,nFormu-³
		//³ la e lFormula para calcular o multiplicador da aplicacao.     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dFormula := dDtSaldo
		nFormula := nSaldo
		lFormula := lResgate
		nFatorAtu:= Formula(SEH->EH_FORMULA)
	Case SEH->EH_TIPO $ GETMV("MV_APLCAL1") .And. !lNewCalc
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calculo da Aplicacao pelo CDI diario. A taxa informado refe-  ³
		//³ re-se ao %do valor do CDI que o banco paga pela aplicacao.    ³
		//³ Para uma melhor entendimento a taxa e' um percetual sobre uma ³
		//³ moeda cadastrada, sendo que o calculo e' atualizado dia a dia.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		/*
		Metodologia de calculo acumulado

		O calculo do DI-CETIP acumulado entre datas eh efetuado atraves da seguinte formula:
		    n
		C = ä  (1+TDIk x (p / 100)), onde:
		    k-1

		C -  Produtorio das taxas DI-CETIP Over com uso do percentual destacado, da data inicial (inclusive) ate a data final (exclusive), calculado com arredondamento de 8 (oito) casas decimais.
		n -  Numero total de taxas DI-CETIP Over, sendo "n" um numero inteiro.
		p -  Percentual destacado para a remuneracao, informado com 4 (quatro) casas decimais.
		TDIk- Taxa DI-CETIP Over, expressa ao dia, calculada com arredondamento de 8 (oito) casas decimais.

		--------------------------------------------

		Expressao de TDIk ate 31/12/1997

		TDIk = DIk / 3000, onde: k = 1, 2, ..., n

		--------------------------------------------

		Expressao de TDIk a partir de 01/01/1998

		TDIk = (((DIk / 100) + 1) ^(1/252)) - 1, onde: k = 1, 2, ..., n


		DIk - Taxa DI-CETIP Over, informada com 2 (duas) casas decimais.

		Observacoes:

		1)    O fator resultante da expressao eh considerado com 16 (dezesseis) casas sem arredondamento.

		2)    Efetua-se o produtorio dos fatores diarios , sendo que a cada fator diario acumulado, trunca-se o resultado com 16 (dezesseis) casas decimais e
				aplica-se o proximo fator diario, assim por diante ate o ultimo fator diario considerado.

		3)    Uma vez os fatores diarios estando acumulados como descrito acima, considera-se o fator resultante C com 8 (oito) decimais com arredondamento.
		*/

			While ( dDtCalculo < dDtSaldo )

				dbSelectArea("SM2") // Cadastro de Moedas
				dbSetOrder(1)
				dbSeek( dDtCalculo )
				If ( Found() )

					nFatorDia := DEC_CREATE("1",64,16)

					If (cBaseCdi=="1") .Or. dDtCalculo <= Ctod("31/12/1997") // Ate 31/12/1997 a taxa do DI era divulgada ao mes, depois a taxa comecou a ser divulgada ao ano.

						nFormula1 := SEH->EH_TAXA/100 //Percentual destacado - Precisao 4
						nFormula2 := SM2->(FieldGet(nPosMoeda))/3000 ////TDIk - Precisao 8

					Else

					   	nFormula1 := SEH->EH_TAXA/100 //Percentual destacado - Precisao 4

					    nValor1 := (1+(SM2->(FieldGet(nPosMoeda))/100))
					    nValor2 := (1/252)

					    nFormula2 = (nValor1 ^ nValor2)-1   //TDIk - Precisao 8

					Endif

					nDec1   := DEC_CREATE(Str(nFormula1),64,4)
					nDec2   := DEC_CREATE(Str(nFormula2),64,8)

					nFatorDia   :=  DEC_MUL(nDec1,nDec2)
					nFatorDia   :=  DEC_RESCALE(nFatorDia,16,2) // Produtorio das taxas (C) - Precisao 16

					nFatorDia   :=  DEC_ADD(nFatorUm,nFatorDia) // Soma 1 no Produtorio das taxas (C)

					nResultParc := DEC_MUL(nFatorDia,nResultParc)
					nResultParc := DEC_RESCALE(nResultParc,16,2) // Produtorio das taxas (C) - Precisao 16
				EndIf

				/*###############################
				* VALIDAÇÃO FERIADO MUNICIPAL   *
				################################*/
				SET(_SET_DATEFORMAT, "DD/MM/YY")

				lFerMunic := .F.
				dFerMunic := dDtCalculo+1

				// Deixa a data de verificação de feriado municipal com o próximo dia útil
				While (DOW(dFerMunic) == 1 .Or. DOW(dFerMunic) == 7)
					dFerMunic++
				EndDo

				If !Empty(oFerMunic)
					If !HMGet(oFerMunic,xFilial("SX5")+SubSTR(DTOC(dFerMunic),1,8)+"M",oVal)  
						If HMGet(oFerMunic,xFilial("SX5")+(SubSTR(DTOC(dFerMunic),1,5)+"   "+"M"),oVal)
							lFerMunic := .T.
						Endif
					Else
						lFerMunic := .T.
					Endif
				Endif

				SET(_SET_DATEFORMAT, cDate)

				If lFerMunic // FERIADO MUNICIPAL É CONSIDERADO NO CALCULO
					dDtCalculo := dFerMunic
				Else
					dDtCalculo := DataValida(dDtCalculo+1,.T.)
				EndIf

			EndDo

			//Fator resutante - Precisao 8
			nResultParc := DEC_RESCALE(nResultParc,8,0)
			nFatorAtu := Val(cValToChar(nResultParc)) //Transforma para numerico

		If ( nFatorAtu == 0 )
			nFatorAtu := 1
		EndIf
	Case SEH->EH_TIPO $ GETMV("MV_APLCAL2") .And. !lNewCalc
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calculo da Aplicacao pela formula de juros composto diario    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( dDtCalculo <= dDtSaldo )
			nFatorDia := NoRound(nTaxa/100, DECIMALDECALCULO )+1
			lAniverMes := Alltrim(SEH->EH_TIPO) $ "CP"
			If lAniverMes
				nPeriodo++
				While (dDtSaldo >= Monthsum(dDtCalculo,nPeriodo))
					nPeriodo++
					nQtdMeses++
				EndDo
				if ValType(nFatorDia) == "F"	
					fAux := (nQtdMeses/12)			
					nFatorAtu := NoRound( DEC_POW( nFatorDia , fAux), DECIMALDECALCULO )					
				else
					nFatorAtu := NoRound(nFatorDia**(nQtdMeses/12), DECIMALDECALCULO )
				endIf
			Else						
				nDiasCalc 	:= dDtSaldo-dDtCalculo
				nDiasAno	:= nDiasCTB
				If cDiasUtCo == '2' //1 - Dias Corridos, 2 - Dias Uteis
					nDiasCor := dDtSaldo-dDtCalculo
					nDiasCalc := 0
					dDtCont := dDtCalculo
					nDiasAno := 252

					For nDiaCont := 1 To nDiasCor
						dDtCont ++

						If dDtCont == DataValida(dDtCont,.T.)
							nDiasCalc ++
						EndIf							
					Next nDiaCont
				EndIf
				if ValType(nFatorDia) == "F"
					fAux := ((nDiasCalc)/nDiasAno)		
					nFatorAtu := NoRound( DEC_POW(nFatorDia , fAux) , DECIMALDECALCULO )
				else
					nFatorAtu := NoRound(nFatorDia**((nDiasCalc)/nDiasAno), DECIMALDECALCULO )
				endIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Efetua a Convercao Monetaria                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF ( SEH->EH_MOEDA >= 2 )
				nFatorAtu := NoRound(nFatorAtu/RecMoeda(DataValida(dDtCalculo-nAjVarCab,.F.),SEH->EH_MOEDA)*;
					RecMoeda(DataValida(dDtSaldo-nAjVarCab,.F.),SEH->EH_MOEDA), DECIMALDECALCULO )
			Else
				nFatorAtu := NoRound(nFatorAtu, DECIMALDECALCULO )
			EndIf
		Else
			nFatorAtu := 0
		EndIf
		If ( nFatorAtu == 0 )
			nFatorAtu := 1
		EndIf
	Case SEH->EH_TIPO $ GETMV("MV_APLCAL3") .And. !lNewCalc
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calculo da Aplicacao pela formula de juros simples mensal     ³
		//³ Dias Corridos.                                                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( nDias > 0 )
			nFatorDia := NoRound(nTaxa/100, DECIMALDECALCULO )
			lAniverMes := Alltrim(SEH->EH_TIPO) $ "CP"
			If lAniverMes
				nPeriodo++
				While (dDtSaldo >= Monthsum(dDtCalculo,nPeriodo))
					nPeriodo++
					nQtdMeses++
				EndDo
				nFatorAtu := NoRound(nFatorDia/12*nQtdMeses,DECIMALDECALCULO )+1
			Else
				nFatorAtu := NoRound(nFatorDia/nDiasCTB*nDias,DECIMALDECALCULO )+1
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Efetua a Convercao Monetaria                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			// posiciona o banco da aplicação para verificar a moeda dele
			SA6->(DbSetOrder(1))
			SA6->(DbSeek(SEH->(xFilial("SA6")+EH_BANCO+EH_AGENCIA+EH_CONTA)))

			// encontrou no arquivo e moedas são diferentes verifica variacao cambial
			IF ( SA6->(!Eof()) .And. SEH->EH_MOEDA != SA6->A6_MOEDA )
				nFatorAtu := NoRound(nFatorAtu/RecMoeda(DataValida(dDtCalculo-nAjVarCab,.F.),SEH->EH_MOEDA)*;
					RecMoeda(DataValida(dDtSaldo-nAjVarCab,.F.),SEH->EH_MOEDA), DECIMALDECALCULO )
			Else
				nFatorAtu := NoRound(nFatorAtu, DECIMALDECALCULO )
			EndIf
		Else
			nFatorAtu := 0
		EndIf
		If ( nFatorAtu == 0 )
			nFatorAtu := 1
		EndIf
	OtherWise
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calculo da Aplicacao por valores fixos por cota, ou seja nao  ³
		//³ ha taxa pre-fixada. Normalmente utilizado para Fundos ou acoes³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea("SE9")
		DbSetOrder(1)
		DbSeek(cFilAP+SEH->EH_CONTRAT+SEH->EH_BCOCONT+SEH->EH_AGECONT)

		nProporcao	:= 0
		nFatorAtu	:= 1

	EndCase
Else
	nFatorAtu := 1
EndIf

If SEH->EH_TIPO $ (GetMv("MV_APLCAL1")+GetMv("MV_APLCAL2")+GetMv("MV_APLCAL3")) .And. !lNewCalc
	nVlrAplAtu := Round(Round(nSaldo*nFatorAtu,TamSX3("EH_SALDO")[2]+1),TamSX3("EH_SALDO")[2])
	If ( nVlrAplAtu <= 0.01 .And. SEH->EH_GARANTE=="S" )
		nVlrAplAtu := nSaldo
	EndIf
	If ( nFatorAtu != 0 )
		nJurAplAtu := nVlrAplAtu - nSaldo
	EndIf
	If !Empty(SEH->EH_TAXAIOF) .Or. SEH->EH_TIPO $ GetMv("MV_APLCAL3")
		nIofAplAtu	:= NoRound(nJurAplAtu*SEH->EH_TAXAIOF/100,TamSX3("EH_SALDO")[2])
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calcula o IOF conforme a tabela cadastrada no SX5, ou a taxa de IOF cadastrada na aplicacao          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nDias := (IIf(!lFinr820,dDataBase,dDtSaldo) - SEH->EH_DATA) // Data da Inclusao da Aplicacao
		If ABS(nDias) <= 29 .AND. !EMPTY(cTabIOF) .And. nDias > 0
  			nIofAplAtu := NoRound((Round(NoRound((nJurAplAtu),3),2) * VAL(TABELA(cTabIof, STRZERO(nDias,2)))/100),TamSX3("EH_SALDO")[2])
		Endif

		If SEH->EH_TIPO == "CDI" .and. lClsIof
		 	nIofAplAtu := 0
	  		lRetorna := .T.
		EndIf
	Endif

	//Para aplicacoes do Tipo - CP (Caderneta de Poupança), nao existe incidencia de IR
	If (Alltrim(SEH->EH_TIPO) $ "CP")
		nIrfAplAtu	:= 0
	Else
		nIrfAplAtu	:= NoRound((nJurAplAtu-nIofAplAtu)*nTaxaIrf/100,TamSX3("EH_SALDO")[2])
	EndIf

	nOutAplAtu	:= NoRound(nJurAplAtu*SEH->EH_IMPOSTO/100,TamSX3("EH_SALDO")[2])
	If lAplImune
		FA181Imune(@nIofAplAtu,@nIrfAplAtu)
	EndIf
	nVlrRegAtu	:= ( nVlrAplAtu-nIrfAplAtu-nIofAplAtu-nOutAplAtu )
	nRdBruto		:= 0
	nIRRdBruto	:= 0
	nVlLiquido	:= 0
	nDelta		:= 0
	nBaseCalc	:= 0
	nResgBruto	:= 0
	nSldAplicado:= 0
Else
	If lNewCalc
		//-------------------------------------------------
		//Efetuo o cálculo da Caderneta de Pupança 
		//utilizando os índices cadastrados na tabela FO3
		//-------------------------------------------------		
		
		//Para cadernetas de poupança que tenham sido abertas até dia 03/05/2012, o rendimento será
		//sobre TR + o percentual emitido pelo BCB
		//Para cadernetas de poupança que tenham sido abertas a partir do dia 04/05/2012, o rendimento será de
		//TR + 0,5% caso a Taxa Meta Selic seja igual ou superior à 8,5%
		//Caso a Taxa Meta Selic seja inferior à 8,5%, o rendimento será de TR + 70% da Taxa Meta Selic
		If SEH->EH_DATA <= CtoD( '03/05/2012' )
			lOldCP := .T.
		EndIf
		
		aAnivCP := RetAnivCP( SEH->EH_DATA, dDtSaldo )

		FO3->( DbSetOrder( 1 ) )
		For nX := 1 To Len( aAnivCP )
			If FO3->( DbSeek( xFilial( 'FO3' ) + aAnivCP[nX] ) )
				aAdd( aTaxas, { FO3->FO3_DATA,;
								FO3->FO3_IDXCPA,;
								FO3->FO3_IDXCPN,;
								FO3->FO3_IDXSLM,;
								FO3->FO3_PERC,;
								FO3->FO3_IDXTR } )
			EndIf
		Next nX

		nSaldoCP := nSaldo

		For nX := 1 To Len( aTaxas )
			If lOldCP
				nTaxaCP := aTaxas[nX][2]
			Else
				//Verifico se a taxa para poupança cadastrada confere com a taxa da meta selic
				If Round( ( ( (1 + ( aTaxas[nX][4] * ( aTaxas[nX][5] / 100 ) )/100 ) ^ (1/12) - 1) * 100 ), 4) == aTaxas[nX][3]
					nTaxaCP := aTaxas[nX][3]
				Else
					nTaxaCP := Round( ( ( (1 + ( aTaxas[nX][4] * ( aTaxas[nX][5] / 100 ) )/100 ) ^ (1/12) - 1) * 100 ), 4)
				EndIf

				If aTaxas[nX][4] > 8.5
					nTaxaCP := 0.5
				EndIf

			EndIf
			
			//Cálculo do rendimento da poupança com juros compostos
			nSaldoCP := nSaldoCP * ( 1 +  ( nTaxaCP + aTaxas[nX][6] ) / 100  )
		
		Next nX

		nVlrAplAtu := Round( nSaldoCP, 2)
		nJurAplAtu := nVlrAplAtu - nSaldo

		nIrfAplAtu	:= 0 //Caderneta de Poupança é isenta de IR
		nResgBruto	:= nVlResgate
		nOutAplAtu	:= nJurAplAtu * SEH->EH_IMPOSTO / 100
		nVlrRegAtu	:= 0
	Else
		
		aUltComeCotas	:= UltComeCotas()	// Busca data do ultimo come-cotas

		If AllTrim(SEH->EH_TIPO) == "FIC" .AND. AllTrim(FunName()) == "FINA183"	.AND. lDeduzIR .AND. !Empty(aUltComeCotas[1])

			/*
				Cálculo diferenciado para Apropriação por cotas 
				Rendimento do último come-cotas até o come-cotas atual
			*/

			/*
				Valor atual da Aplicação
			*/
			nVlrAplAtu	:= nSaldo * nCotaAtual

			/*
				Valor da aplicação no último come-cotas
			*/
			nVlrUltCome := nSaldo * aUltComeCotas[2]

			/*
				Rendimento do último come-cotas até hoje
			*/
			nRendimento := nVlrAplAtu - nVlrUltCome
			nRdBruto	:= nRendimento
			nRdMes		:= nRendimento

			nIRRdBruto	:= ((nRdBruto-nIofAplAtu) * (nTaxaIrf/100))
			nIrfAplAtu	:= nIrRdBruto

			nVlLiquido	:= (nVlResgate - nIRRdBruto)

			nDelta		:= (nCotaAtual / aUltComeCotas[2]) - 1			

		Else
			nVlrAplAtu	:= nSaldo*nCotaAtual
			nVlrAplAnt	:= nSaldo*nCotaAnt

			nDelta		:= (nCotaAtual / nCotaAnt) - 1
			If Empty(SEH->EH_ULTPGIR)	// Se a data do ultimo pagto do IR estiver vazia,
										// verifica a data da ultima apropriacao
				dDtCota := If(Empty(SEH->EH_ULTAPR),SEH->EH_DATA,SEH->EH_ULTAPR)
			Else
				dDtCota := If(lDeduzIR,SEH->EH_ULTPGIR,SEH->EH_ULTAPR)
			Endif
			// LOCALiza a cotacao da ultima apropriacao para calcular os
			// rendimentos desde esta data ate data atual
			If SE0->E0_DATA == dDtcota .Or. SEH->EH_TIPO $ SuperGetMv("MV_APLCAL4",.F.,"FAF|FIC")
				If lFinr820
					SE0->(dbSeek(xFilial("SE0")+SE9->(E9_BANCO+E9_AGENCIA+E9_CONTA+E9_NUMERO+Dtos(dDtcota))))
				Else
					SE0->(MsSeek(xFilial("SE0")+ SEH->(EH_BCOCONT+EH_AGECONT+EH_CTACONT+EH_CONTRAT+Str(21001231-Val(DTOS(dDtcota)),11))))
				Endif
			Else
				SE0->(MsSeek(xFilial("SE0")+ SEH->(EH_BCOCONT+EH_AGECONT+EH_CTACONT+EH_CONTRAT+Str(21001231-Val(DTOS(SE0->E0_DATA)),11))))
			Endif
			// Calcula rendimento
			nValorCotas := nVlResgate / nCotaAtual // Valor em cotas referente ao resgate
			nValorReais	:= nValorCotas * ( nVlrAplAnt/ SEH->EH_SLDCOTA)	 	

			If 	nValorReais > 0
				nRendimento := Round(nVlResgate  - nValorReais,2) // Rendimento
			Else
				nRendimento := Round(nVlResgate  - nValorCotas,2) // Rendimento
			EndIf

			If lF171RdBr
				//Ponto de Entrada F171RDBR para alterar o valor do nRendimento, recebendo o valor calculado até o ponto
				nRendAux	:= ExecBlock( "F171RDBR", .F., .F., { nRendimento } )

				If ValType(nRendAux) == "N"
					nRendimento := nRendAux
					nRendAux := 0
				EndIf
			EndIf
			nRdMes		:= nRendimento // Rendimento Bruto do mes

			dDtCota := SEH->EH_DATA

			If lFinr820
				SE0->(dbSeek(xFilial("SE0")+SE9->(E9_BANCO+E9_AGENCIA+E9_CONTA+E9_NUMERO+Dtos(dDtcota))))
			Else
				// Localiza a cotacao da Aplicacao para Calcular o Rendimento
				SE0->(MsSeek(xFilial("SE0")+ SEH->(EH_BCOCONT+EH_AGECONT+EH_CTACONT+EH_CONTRAT+Str(21001231-Val(DTOS(dDtcota)),11))))
			EndIf

			// Calcula rendimento
			nValorCotas	:= nVlResgate / nCotaAtual // Valor em cotas referente ao resgate
			nValorReais	:= nValorCotas * If(SE0->E0_VALOR=0,SEH->EH_VLRCOTA,SE0->E0_VALOR) // Valor em Reais atualizado

			If 	nValorReais > 0
				nRendimento := Round(nVlResgate  - nValorReais,2) // Rendimento
			Else
				nRendimento := Round(nVlResgate  - nValorCotas,2) // Rendimento
			EndIf

			If lF171RdMn
				//Ponto de Entrada F171RDBR para alterar o valor do nRendimento, recebendo o valor calculado até o ponto
				nRendAux	:= ExecBlock( "F171RDMN", .F., .F., { nRendimento } )

				If ValType(nRendAux) == "N"
					nRendimento := nRendAux
					nRendAux := 0
				EndIf
				nRdMes		:= nRendimento 
			EndIf

			//Só verifica o parametro MV_RENAPL4, se não tiver nenhum dos dois pontos de entrada: 
			//F171RDMN e F171RDBR			
			If ( !lF171RdMn .And. !lF171RdBr ) 
				If cTpRenApl4 == "2"	//Se for mensal	 				
					nRendimento	:= nRdMes
				Else
					nRdMes	:= nRendimento
				EndIf
			else
				nRendimento := nRdMes
			EndIf 
				
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Calcula o IOF conforme a tabela cadastrada no SX5, ou a taxa de IOF cadastrada na aplicacao          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nDias := dDataBase - SEH->EH_DATA // Data da Inclusao da Aplicacao
			If AllTrim(FunName()) != "FINA183" // Não realiza o calculo de IOF para apropriação.
			nIofAplAtu := FIN_IOF(SEH->EH_APLEMP, nRdMes, nDias)
			EndIf

			//Acumulado dos rendimentos e IR de apropriacao
			dbSelectArea("SEI")
			SEI->(dbSetOrder(2))		//EI_FILIAL, EI_APLEMP, EI_NUMERO, EI_REVISAO, EI_MOTBX

			If SEI->(dbSeek(xFilial("SEI")+SEH->(EH_APLEMP+EH_NUMERO+EH_REVISAO)+"APR"))
				While !SEI->(Eof()) .And. xFilial("SEI")+SEH->(EH_APLEMP+EH_NUMERO+EH_REVISAO)+"APR" == SEI->(EI_FILIAL+EI_APLEMP+EI_NUMERO+EI_REVISAO+EI_MOTBX)
					If SEI->EI_DATA == SEH->EH_ULTAPR
						If SEI->EI_TIPODOC == "I6" .And. SEI->EI_STATUS != "C"
							nIRAprop += SEI->EI_VALOR
						EndIf

						If SEI->EI_TIPODOC == "I7" .And. SEI->EI_STATUS != "C"
							nRendAprop += SEI->EI_VALOR
						EndIf
					EndIf

					SEI->(dbSkip())
				EndDo
			Endif

			DbSelectArea("SEI")
			DbSetOrder(1)		//EI_FILIAL, EI_APLEMP, EI_NUMERO, EI_REVISAO, EI_SEQ

			If SEI->(DbSeek(xFilial("SEI") + SEH->(EH_APLEMP+EH_NUMERO+EH_REVISAO)))
				While !SEI->(Eof()) .AND. xFilial("SEI")+SEH->(EH_APLEMP+EH_NUMERO+EH_REVISAO) == SEI->(EI_FILIAL+EI_APLEMP+EI_NUMERO+EI_REVISAO)
					If SEI->EI_TIPODOC == "I1" .AND. SEI->EI_DATA >= SEH->EH_ULTAPR .AND. SEI->EI_STATUS != "C"
						lZeraIRApr := .T.
					EndIf

					SEI->(DbSkip())
				End
			EndIf

			//So Desconta o IR apropriado se não houve resgate após a ultima apropriação
			If lZeraIRApr
				nIRAprop 	:= 0
				nRendAprop	:= 0
			Endif

			nRdBruto		:= nRendimento // Rendimento Bruto do periodo

			// IR da última apropriação
			nIRAprop := IRAprCotas( nValorCotas , aUltComeCotas )

			nIRRdBruto := ROUNDFIN(((nRdBruto-nIofAplAtu) * (nTaxaIrf/100)),2,.T.) - ROUNDFIN(nIRAprop,2,.T.)
			
	EndIf
		
		If lAplImune
			FA181Imune(@nIofAplAtu,@nIRRdBruto)
		EndIf
		nVlLiquido	:= (nVlResgate - nIRRdBruto)
		nBaseCalc	:= 0

		If nVlrAplAtu <= 0.01 .And. SEH->EH_GARANTE=="S"
			nVlrAplAtu := nSaldo
		EndIf
		If nCotaAtual > 0
			nJurAplAtu := nRdBruto
		EndIf
		nIrfAplAtu	:= nIrRdBruto
		nResgBruto	:= nVlResgate + nIrfAplAtu
		nSldAplicado:= nVlrAplAtu - nResgBruto
		nOutAplAtu	:= nJurAplAtu*SEH->EH_IMPOSTO/100
		nVlrRegAtu	:= ( nVlrAplAtu-nIrfAplAtu-nIofAplAtu-nOutAplAtu )
		
	EndIf
Endif

// Restaura a area de trabalho
SA6->(RestArea(aSA6))
RestArea(aArea)

If !Empty(oFerMunic)
	FwFreeObj(oFerMunic)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ajustar os valores para nao deixar Impostos negativos         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nIrfAplAtu := If( nIrfAplAtu < 0, 0, nIrfAplAtu )
nIofAplAtu := If( nIofAplAtu < 0, 0, nIofAplAtu )
nOutAplAtu := If( nOutAplAtu < 0, 0, nOutAplAtu )
nVlrRegAtu := If( nVlrRegAtu < 0, 0, nVlrRegAtu )

Return({ nVlrAplAtu,nIrfAplAtu,nIofAplAtu,nOutAplAtu,nJurAplAtu,nVlrRegAtu,nRdMes,nIrRdBruto,nVlLiquido,nDelta,nBaseCalc })


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA171CALEP

Calcula o Valor da Aplicacao Financeira  (Fa171Calc).
Arquivo original: FINXFUN.PRX

Parametro
Deve estar posicionado no SEH
ExpD1 : Data do Saldo
ExpN2 : Moeda do Saldo
ExpL3 : Considera data de resgate
ExpN4 : Valor da Moeda do Saldo
ExpD5 : Data da Ultima apropriacao (somente para recalculo)
ExpL1 : Por Filial/Empresa

@Author	Eduardo Riera
@since	13/04/1998
/*/
//-----------------------------------------------------------------------------------------------------
Static Function Fa171CalEp(dDtSaldo,nSaldo,lResgate,nVlMoeda,dUltApr,lFilial,lDeduzIR,nTaxaIrf)

Local dDtCalculo	:= SEH->EH_DATA
Local nVlEmpAtu2	:= 0 // Valor atualizado na moeda do emprestimo
Local nVlEmpAtu1	:= 0 // Valor atualizado na moeda 1
Local nVlEmpJur2	:= 0 // Juros na moeda do emprestimo
Local nVlEmpJur1	:= 0 // Juros na moeda 1
Local nVlEmpVC		:= 0 // Variacao Cambial
Local nVlEmpCVC		:= 0 // Variacao Cambial a Curto Prazo
Local nVlEmpLVC		:= 0 // Variacao Cambial a Longo Prazo
Local nVlEmpJVC		:= 0 // Variacao Cambial do Juros
Local nAcEmpJur2	:= SEH->EH_ACUJUR2 // Acumulado do Juros na moeda do Emprestimo
Local nAcEmpJur1	:= SEH->EH_ACUJUR  // Acumulado do juros na moeda corrente
Local nAcEmpCVC		:= SEH->EH_ACUVCCP // Acumulado da Variacao Cambial a Curto Prazo
Local nAcEmpLVC		:= SEH->EH_ACUVCLP // Acumulado da Variacao Cambial a Longo Prazo
Local nAcEmpJVC		:= SEH->EH_ACUVCJR // Acumulado da Variacao Cambial dos Juros
Local nTxIOF		:= SEH->EH_TAXAIOF
Local nIofAtu		:= 0
Local dData			:= Ctod("")
Local cFilAp		:= If(lFilial, xFilial(), SEH->EH_FILIAL)
Local nDiasCTB		:= GetNewPar("MV_DIASCTB", 360) //Quantidade de dias para o ano contábil
Local nDias			:= If(FwIsInCallStack('FINR820'),(dDtSaldo - SEH->EH_DATA),(dDataBase - SEH->EH_DATA))
Local cTabIrf		:= "AR"
Local aTabIrf		:= {	{ 180, 22.5 },;
							{ 360, 20.0 },;
							{ 720, 17.5 },;
							{ 1000000, 15.0 } }
Local nAscan		:= Ascan( aTabIrf, { |e| e[1] >= nDias } ) // Pesquisa a aliquota conforme o tempo da aplicacao
Local lL11033		:= SuperGetMv("MV_L11033",,.F.)

Default nTaxaIrf	:= If(Empty(SEH->EH_TAXAIRF), If(SX5->(MsSeek(xFilial("SX5")+"AR")),;
								Val(TabelaIrf(cTabIrf,nDias)),aTabIrf[nAscan][2]), SEH->EH_TAXAIRF)
Default lDeduzIR	:= .T.

//Ponto de entrada para validacao do dias CTB
If ExistBlock("FADIACTB")
	nDiasCTB := ExecBlock("FADIACTB",.F.,.F.,{nDiasCTB})
Endif

dUltApr := If(dUltApr == Nil , SEH->EH_ULTAPR , dUltApr )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Calculo do Valores Acumulados                                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SEI")
dbSetOrder(1)
dbSeek(cFilAp+SEH->EH_APLEMP+SEH->EH_NUMERO+SEH->EH_REVISAO)
While ( !Eof() .And. SEI->EI_FILIAL == cFilAp .And.;
		SEI->EI_APLEMP == SEH->EH_APLEMP .And.;
		SEI->EI_NUMERO == SEH->EH_NUMERO .And.;
		SEI->EI_REVISAO== SEH->EH_REVISAO )
	If ( SEI->EI_DATA <= dUltApr .And. SEI->EI_STATUS!="C" )
		If ( SEI->EI_MOTBX=="APR" )
			If ( SEI->EI_TIPODOC == "JR" )
				nAcEmpJur2 += SEI->EI_VLMOED2
				nAcEmpJur1 += SEI->EI_VALOR
			EndIf
			If ( SEI->EI_TIPODOC == "V2" )
				nAcEmpCVC += SEI->EI_VALOR
			EndIf
			If ( SEI->EI_TIPODOC == "V1" )
				nAcEmpLVC += SEI->EI_VALOR
			EndIf
			If ( SEI->EI_TIPODOC == "V3" )
				nAcEmpJVC += SEI->EI_VALOR
			EndIf
		Else
			If ( SEI->EI_TIPODOC == "JR" )
				nAcEmpJur2 -= SEI->EI_VLMOED2
				nAcEmpJur1 -= SEI->EI_VALOR
			EndIf
			If ( SEI->EI_TIPODOC == "V2" )
				nAcEmpCVC -= SEI->EI_VALOR
			EndIf
			If ( SEI->EI_TIPODOC == "V1" )
				nAcEmpLVC -= SEI->EI_VALOR
			EndIf
			If ( SEI->EI_TIPODOC == "V3" )
				nAcEmpJVC -= SEI->EI_VALOR
			EndIf
		EndIf
		dData := Max(dData,SEI->EI_DATA)
	EndIf
	dbSelectArea("SEI")
	dbSkip()
EndDo

dUltApr	 := If(Empty(dData),SEH->EH_ULTAPR,dData)
dDtCalculo:= If(Empty(dUltApr),dDtCalculo,dUltApr)
dDtSaldo  := If(Empty(dDtSaldo),dDataBase,dDtSaldo)
nSaldo    := If(Empty(nSaldo ) ,SEH->EH_SALDO,nSaldo)
lResgate  := If(lResgate==Nil,.F.,lResgate)
nVlMoeda  := If(nVlMoeda==Nil,RecMoeda(dDtSaldo,SEH->EH_MOEDA),nVlMoeda)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Calculo do Numero de Dias para apropriacao.                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SEH")
Do Case
Case SEH->EH_TIPO $ GetMv("MV_EMPAPRO")
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calculo do emprestimo Euro Notes. Sua principal caracteristica³
	//³ e'que o juros sempre sao calculados com trinta dias uteis,    ³
	//³ independente do numero de dias do mes.                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nDias    := 0
	If ( dDtCalculo != dDtSaldo )
		While ( dDtCalculo < dDtSaldo )
			Do Case
			Case Day(dDtCalculo) == 28 .AND.;
					Month(dDtCalculo) == 02
				nDias += 2
			Case Day(dDtCalculo) == 29 .AND.;
					Month(dDtCalculo) == 02 .AND.;
					nDias == 0
				nDias ++
			Case ( Day(dDtCalculo) != 31 )
				nDias ++
			EndCase
			dDtCalculo++
		EndDo
	EndIf
OtherWise
	nDias := ( dDtSaldo - dDtCalculo )
	If ( nDias < 0 )
		nDias := 0
	EndIf
EndCase
Do Case
Case ( !Empty(SEH->EH_FORMULA) )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ A formula deve utilizar as variaveis PRIVATES dFormula,nFormu-³
	//³ la e lFormula para calcular o multiplicador da aplicacao.     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dFormula := dDtSaldo
	nFormula := nSaldo
	lFormula := lResgate

	nVlEmpJur2 := Formula(SEH->EH_FORMULA)
	nVlEmpJur1 := Round(nVlEmpJur2 * nVlMoeda,TamSX3("EH_VALOR")[2])
	nVlEmpAtu2 := SEH->EH_SALDO+nVlEmpJur2
	nVlEmpAtu1 := Round(nVlEmpAtu2*nVlMoeda,TamSX3("EH_VALOR")[2])

	nAcEmpJur2 += nVlEmpJur2
	nAcEmpJur1 += nVlEmpJur1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ A variacao cambial e'calculada sobre a diferenca entre o saldo do em-   ³
	//³ prestimo e o valor original em moeda corrente                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nVlEmpVC  := Round((nSaldo * nVlMoeda)-SEH->EH_VLCRUZ,TamSX3("EH_SALDO")[2])
	nVlEmpCVC := Round((nVlEmpVC*SEH->EH_PERCPLP/100),TamSX3("EH_SALDO")[2]) - nAcEmpCVC
	nVlEmpLVC := nVlEmpVC - nVlEmpCVC - nAcEmpLVC

	nAcEmpCVC += nVlEmpCVC
	nAcEmpLVC += nVlEmpLVC

	nVlEmpJVC := Round(((nAcEmpJur2 * nVlMoeda)-nAcEmpJur1),TamSX3("EH_SALDO")[2]) - nAcEmpJVC
	nACEmpJVC += nVlEmpJVC
Case ( SEH->EH_MOEDA != 1 .And.;
		SEH->EH_TIPO $ GetMv("MV_EMPCAL1")+"|"+GetMv("MV_EMPCAL4") )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Emprestimos Estrangeiros                                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ O juros e'calculado sobre o saldo do emprestimo que esta na moeda da    ³
	//³ operacao financeira.                                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( SEH->EH_TIPO $ GetMv("MV_EMPCAL4") )
		nVlEmpJur2 := Round(nSaldo*((((SEH->EH_TAXA/100)+1)**(nDias/nDiasCTB))-1),TamSX3("EH_SALDO")[2])
	Else
		nVlEmpJur2 := Round((SEH->EH_TAXA/100)*(nSaldo/nDiasCTB)*nDias,TamSX3("EH_SALDO")[2])
	EndIf
	nVlEmpJur1 := Round(nVlEmpJur2 * nVlMoeda,TamSX3("EH_VALOR")[2])
	nVlEmpAtu2 := SEH->EH_SALDO+nVlEmpJur2
	nVlEmpAtu1 := Round(nVlEmpAtu2*nVlMoeda,TamSX3("EH_VALOR")[2])

	nAcEmpJur2 += nVlEmpJur2
	nAcEmpJur1 += Round(nVlEmpJur1,TamSX3("EH_VALOR")[2])
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ A variacao cambial e'calculada sobre a diferenca entre o saldo do em-   ³
	//³ prestimo e o valor original em moeda corrente                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nVlEmpVC  := Round((nSaldo * nVlMoeda)-SEH->EH_VLCRUZ,TamSX3("EH_SALDO")[2])
	nVlEmpCVC := Round((nVlEmpVC*SEH->EH_PERCPLP/100),TamSX3("EH_SALDO")[2])-nAcEmpCVC
	nVlEmpLVC := nVlEmpVC - nVlEmpCVC - nAcEmpLVC

	nAcEmpCVC += nVlEmpCVC
	nAcEmpLVC += nVlEmpLVC

	nVlEmpJVC := Round(((nAcEmpJur2 * nVlMoeda)-nAcEmpJur1),TamSX3("EH_SALDO")[2])-nAcEmpJVC
	nAcEmpJVC += nVlEmpJVC
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Emprestimos Nacionais.                                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case ( SEH->EH_TIPO $ GetMv("MV_EMPCAL2")+"|"+GetMv("MV_EMPCAL3") )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calculo do emprestimo Hot Money. Sua principal  caracteristica³
	//³ e'que o juros sao simples e o resgate e quase imediato.       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( SEH->EH_TIPO $ GetMv("MV_EMPCAL2") )
		nVlEmpJur1 := Round((SEH->EH_TAXA/100)*(nSaldo/nDiasCTB)*nDias,TamSX3("EH_SALDO")[2])
	Else
		nVlEmpJur1 := DEC_FIN(nSaldo + nAcEmpJur1,(((SEH->EH_TAXA/100)+1)**(nDias/nDiasCTB))-1)
	EndIf
	nVlEmpJur2 := nVlEmpJur1
	nVlEmpAtu1 := SEH->EH_SALDO+nVlEmpJur1
	nVlEmpAtu2 := nVlEmpAtu1
	nAcEmpJur2 += nVlEmpJur2
	nAcEmpJur1 += nVlEmpJur1
EndCase

If FwIsInCallStack("FINA181")// Calculo feito pelo FINA181
	// Calcula o IOF conforme a tabela cadastrada no SX5, ou a taxa de IOF cadastrada na aplicacao
	nDias := dDataBase - SEH->EH_DATA // Data da Inclusao da Aplicacao
	nIOFAtu := FIN_IOF(SEH->EH_APLEMP,nA181VPLP1,ndias,nTxIOF)
EndIf

If lL11033
	nA181VlIrf	:= NoRound( (nVlEmpJur1) * nTaxaIrf/100, TamSX3("EH_SALDO")[2] )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ajustar os valores para nao deixar Impostos negativos         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nA181VlIrf := If( nA181VlIrf < 0, 0, nA181VlIrf )
EndIf

Return( {	{ nVlEmpAtu2, nAcEmpJur2, 0, 0, 0, nVlEmpJur2, 0, 0, 0 }, ;
			{ nVlEmpAtu1, nAcEmpJur1, nAcEmpLVC, nAcEmpCVC, nAcEmpJVC, nVlEmpJur1, nVlEmpLVC, nVlEmpCVC, nVlEmpJVC, nIofAtu } } )


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} OPENCMC7

Abre porta para a leitora de cheques (CMC7).
Arquivo original: FINXFUN.PRX

@Author	Mauricio Pequim Jr.
@since	13/08/2001
/*/
//-----------------------------------------------------------------------------------------------------
Function OpenCMC7()

Local cModelo	:= Alltrim(GetMv("MV_CMC7MOD",.F.,""))
Local cPrtCMC7	:= AllTrim(GetMv("MV_CMC7PRT",.F.,""))

nHdlCMC7	:= IIF(nHdlCMC7==NIL,-1,nHdlCMC7)

If !Empty(cModelo) .and. !Empty(cPrtCMC7)
	If CheckDLLLj()
		nHdlCMC7 := CMC7Abr(cModelo,cPrtCMC7,"N")
	EndIf
EndIf
Return


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} READCMC7

Efetua a leitura dos dados da leitora de cheques (CMC7)
Arquivo original: FINXFUN.PRX

@Author	Mauricio Pequim Jr.
@since	13/08/2001
/*/
//-----------------------------------------------------------------------------------------------------
Function ReadCmC7()

Local aCmC7 := {}

nHdlCMC7	:= IIF(nHdlCMC7==NIL,-1,nHdlCMC7)
AADD(aCMC7,nHdlCMC7)
AADD(aCMC7,GetMv("MV_CMC7FIN"))

Return aCmC7


//888.03 Leitora de cheques ARGENTINA

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinVldCMC7

Funcao para a validar o código capturado pelo leitor de CMC7. (ARGENTINA)
Arquivo original: FINXFUN.PRX

@author    Mauricio Pequim Jr
@version   11.80
@since     05/02/13

@return ExpL1 = Confirma se os dados lidos sao validos

/*/
//-----------------------------------------------------------------------------------------------------
Function FinVldCMC7( cCmc7 )
Local lRet := .F.		// Retorno da validacao da string
Local nTamCmc7 := 31

Default cCmc7	:= ""	//Codigo do CMC7

If !Empty(cCmc7)
	nPosIni := AT("<", cCmc7)
	If nPosIni == 0
		nPosIni := AT("C", cCmc7)
	Endif
	If nPosIni > 0
		cCmc7	:= SubStr(Alltrim(cCmc7), nPosIni , Len(Alltrim(cCmc7)) - 1)
	Endif
EndIf

If Empty( cCmc7 ) // Caso nao leia nada
	MsgAlert( STR0026 ) //"Passe o cheque novamente no leitor."
Elseif ( "?" $ cCmc7 ) .or. ( ":" $ cCmc7 ) .or. Len( AllTrim( cCmc7 ) ) <> nTamCmc7  // Se encontrar o caracter de erro (? ou :) ou tamnaho menor que o correto (34)
	MsgAlert( STR0027 + " " + STR0026) //"Falha na leitura."  ### "Passe o cheque novamente no leitor."
	cCmc7 := Padr(cCmc7,35)
Else
	lRet := .T.
Endif

Return ( lRet )


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinCmc7Tc

Funcao para a captura do código CMC7 pelo leitor via teclado.(ARGENTINA)
Arquivo original: FINXFUN.PRX

@author    Mauricio Pequim Jr
@version   11.80
@since     05/02/13

@return aCmc7Tc	- Array contendo as informações de Banco, Agencia, Conta e Codigo Postal do cheque

/*/
//-----------------------------------------------------------------------------------------------------
Function FinCmc7Tc(lFazPerg)
Local cCmc7 	:= Space(35)	// Recebera o conteudo lido do cheque
Local oCmc7						// Objeto do get do CMC7
Local oDlg						// Monta a tela de captura do codigo
Local aCmc7Tc	:= {}			// Armazena os dados do cheque; retorno da funcao
Local nOpcx 	:= 0

Default lFazPerg := .T.

If nTamBco == 0
	nTamBco := TamSX3("EF_BANCO")[1]
Endif
If nTamAge == 0
	nTamAge := TamSX3("EF_AGENCIA")[1]
Endif
If nTamCta == 0
	nTamCta := TamSX3("EF_CONTA")[1]
Endif
If nTamChq == 0
	nTamChq := TamSX3("EF_NUM")[1]
Endif
If nTamCPo == 0
	nTamCPo := TamSX3("EF_POSTAL")[1]
Endif

If cPaisloc == "ARG" .and. (!lFazPerg .or. MsgYesNo(STR0028,STR0029))	//"Deseja utilizar a leitora de cheques?"###"Leitura de cheques"

	If ExistBlock("FINLRCHQ")
		cCmC7 := ExecBlock("FINLRCHQ",.F.,.F.,{})
	EndIf

	DEFINE MSDIALOG oDlg TITLE STR0030 FROM 200 , 001 TO 300 , 300 OF oMainWnd PIXEL	 //"Leitura do código do cheque"
	@ 008 , 018 Say STR0031 SIZE 200 , 10 OF oDlg PIXEL								 //"Por favor, passe o cheque pelo leitor..."
	@ 018 , 018 MSGET oCmc7 VAR cCmc7 PICTURE "@!" SIZE 120,009 OF oDlg PIXEL

	DEFINE SBUTTON FROM 35 , 080 TYPE 1 ACTION (Iif (FinVldCMC7(@cCmc7), (oDlg:End(), nOpcx := 1), oCmc7:SetFocus()) )  ENABLE OF oDlg
	DEFINE SBUTTON FROM 35 , 110 TYPE 2 ACTION oDlg:End()  ENABLE OF oDlg

	ACTIVATE MSDIALOG oDlg CENTERED

	If nOpcx == 1  //Confirmou cheque

		If ExistBlock("FINCMTC")
			aCmc7Tc := ExecBlock("FINCMTC",.F.,.F.,{cCmc7})
		Else

			Aadd( aCmc7Tc, PadR(SubStr(cCmc7,  2,  3),nTamBco) )	//Banco
			Aadd( aCmc7Tc, PadR(SubStr(cCmc7,  5,  3),nTamAge) )	//Agencia
			Aadd( aCmc7Tc, PadR(SubStr(cCmc7,  8,  4),nTamCPo) )	//Codigo Postal
			Aadd( aCmc7Tc, PadR(SubStr(cCmc7, 12,  8),nTamChq) )	//Cheque
			Aadd( aCmc7Tc, PadR(SubStr(cCmc7, 20, 10),nTamCta) )	//Conta
			Aadd( aCmc7Tc,      SubStr(cCmc7, 30,  1)          )	//DV Conta

		Endif

	Endif
Endif

Return( aCmc7Tc )


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FC020FORM

Intrepreta a Formula de Reajuste (Fluxos de caixa - Pedidos de compra / venda).
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	01/02/1994
/*/
//-----------------------------------------------------------------------------------------------------
Function Fc020Form(cFormula,dDataReaj)
Local xAlias, cForm:=" ", xValor:=0, nPos, nLen
Local cErros := ""
Private dDtReaj:=dDataReaj,lFormula:=.T.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Salva a integridade dos dados                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
xAlias := Alias()

dbSelectArea("SM4")
dbSeek(cFilial+cFormula)
IF Found()
	cForm := Upper(AllTrim(M4_FORMULA))
	nPos  := At("RECMOEDA(",cForm)
	If nPos > 0
		nPos += 9
		nLen := 0
		While SubStr(cForm,nPos+nLen,1) != ","
			nLen++
		End
		cVarData := SubStr(cForm,nPos,nLen)
		cForm    := strtran(cForm,cVarData,"dDtReaj")
	End
	If At("C9_",cForm) > 0
		cForm := StrTran(cForm,"C9_","C6_")
	End
	If At("C9->",cForm) > 0
		cForm := StrTran(cForm,"C9->","C6->")
	End
	dbSelectArea(xAlias)

	IF At( cForm, cErros ) = 0
		lFormula := fa020TestF( cForm, @xValor )
		IF !( lFormula )
			cErros +=cForm+"ü"
		End
	End
Else
	xValor := 0
End
dbSelectArea(xAlias)
Return xValor


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA020TESTF

Intrepreta a Formula de Reajuste (Fluxos de caixa - Pedidos de compra / venda).
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	10/11/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function fa020TestF( cForm, xValor )
Local bErro := ErrorBlock( { |e| ChecErr260(e,cForm) } )
PRIVATE lRet := .T.

BEGIN SEQUENCE
	xValor := &cForm
END SEQUENCE
ErrorBlock(bErro)
Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FC020COMPR

Monta array com Pedidos de Compra (Fluxos de caixa).
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	06/07/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function fc020Compra(cAliasPc, aTotais, lRegua, nMoeda, aPeriodo, cFilIni, cFilFin, cPedidos, lConsDtBase, aCCustos, aSelFil, lAnalitic)

	Local cNumPed
	Local cCond
	Local i
	Local nPrcCompra
	Local dData
	Local nValIPILiq
	Local nTotDesc
	Local cFilDe
	Local cFilAte
	Local cFilPed
	Local bSelFil
	Local cSaveFil		:= cFilAnt
	Local nAscan		:= 0
	Local dDataFluxo	:= {}
	Local aDataAux		:= {}
	Local nPosData 		:= 0
	Local nValTot		:= 0
	Local nValIpi		:= 0
	Local aVenc			:= {}
	Local nDespFrete	:= 0
	Local lFc020Com		:= ExistBlock("FC020COM")
	Local lFC020CQR		:= ExistBlock("FC020CQR")
	Local lF021DtFl		:= ExistBlock("FC021DTF")
	Local nDecimais		:= TamSx3("C7_PRECO")[2]
	Local nInc			:= 0
	Local aSM0			:= AdmAbreSM0()
	Local nTaxaMoed		:= 0
	Local cCustos		:= ''
	Local nX			:= 0
	Local lFincFluxo	:= FwIsInCallStack("FINC021") .OR. FwIsInCallStack("FINC022") .OR. FwIsInCallStack("FINR140")
	Local lFinc024		:= FwIsInCallStack("FINC024")
	Local nValPagAnt	:= 0
	Local lPACalc		:= .F. //Controle do calc do PA, para não duplic no fluxo de cx quando o pedid tem mais de um item.
	Local nTotRegSC7	:= 0
	Local lSE2Excl		:= FwModeAccess("SE2",1) == "E" .And. FwModeAccess("SE2",2) == "E" .And. FwModeAccess("SE2",3) == "E"
	Local nI			:= 0
	Local cQuery		:= ""
	Local aStru			:= SC7->(dbStruct())
	Local aData 		:= {}
	Local nPos  		:= 0
	Local cTblTmp
	Local lTES			:= .F.
	Local __oMovPA		:= NIL
	Local nValFIE		:= 0
	Local nValAdto 		:= 0 
	Local nVlPAItem     := 0
	Local lInclusao		:= .T.
	Local lSC7Exclus	:= FwModeAccess("SC7", 3) == "E"
	Local nOrdTmp		:= 3
	Local cChaveTmp		:= "DToS(dDataFluxo) + SC7->C7_NUM + SC7->C7_ITEM"

	Default nMoeda		:= 1
	Default cFilIni		:= "  "
	Default cFilFin		:= "zz"
	Default cPedidos	:= "3" // Todos os pedidos
	Default aCCustos	:= {}
	Default aSelFil		:= {}
	Default lAnalitic	:= .F.

	If aAdianta == NIL
		aAdianta := ProtCfgAdt()
		bFilFIE := Iif(aAdianta[1,4],{|| FIE_FILORI==cFilAnt .Or. Empty(FIE_FILORI)},{||.T.})
		lAdComPart := aAdianta[1,5] .And. 'C' $ aAdianta[1,1]+aAdianta[1,2]+aAdianta[1,3]
	Endif

	If lSC7Exclus
		nOrdTmp		:= 4
		cChaveTmp	:= 'FwXFilial("SC7") + DToS(dDataFluxo) + SC7->C7_NUM + SC7->C7_ITEM' 																	
	EndIf

	// Verifica o tipo de filtro de filial.
	If empty(aSelFil)
		bSelFil := {|cFilInc| aScan(aSelFil, cFilInc) > 0}
	Else
		If mv_par03 == 2		// por empresa
			cFilDe	:= cFilIni
			cFilAte	:= cFilFin
		Else					// por filial
			cFilDe	:= cFilAnt
			cFilAte	:= cFilAnt
		Endif
		bSelFil := {|cFilInc| AllTrim(cFilInc) >= Alltrim(cFilDe) .And. AllTrim(cFilInc) <= Alltrim(cFilAte)}
	Endif

	If lFinc024
		For nX := 1 To Len(aCCustos)
			cCustos += "'" + aCCustos[nX] + "',"
		Next nX
		cCustos := Substr(cCustos, 1, Len(cCustos) - 1)
	EndIf

	For nInc := 1 To Len( aSM0 )
		If aSM0[nInc][1] == cEmpAnt .And. Eval(bSelFil, aSM0[nInc][2])
			cFilAnt := aSM0[nInc][2]
			//--------------------------
			// Ler Pedidos de Compra
			//--------------------------
			DbSelectArea("SC7")
			SC7->(DbSetOrder(1))
			DbSeek(xFilial())

			If lF021DtFl
				cQuery := "SELECT * "
			Else
				cQuery := "SELECT C7_FILIAL,C7_NUM,C7_COND,C7_TOTAL,C7_VLDESC,C7_RESIDUO,C7_QUANT,C7_QUJE,C7_CONAPRO,C7_FLUXO,C7_PRODUTO,"
				cQuery += "C7_TES,C7_DATPRF,C7_MOEDA,C7_PRECO,C7_TXMOEDA,C7_REAJUST,C7_VALFRE,C7_SEGURO,C7_DESPESA,C7_DESC1,"
				cQuery += "C7_DESC2,C7_DESC3,C7_VLDESC,C7_ITEM,C7_FORNECE,C7_LOJA,C7_EMISSAO,C7_TIPO,C7_SEQUEN,C7_IPI,C7_IPIBRUT "
				If lFincFluxo
					cQuery += " ,D1_FILIAL,D1_PEDIDO,D1_FORNECE,D1_LOJA,SUM(ISNULL(D1_VALDESC,0)) D1_VALDESC,(C7_VLDESC - SUM(ISNULL(D1_VALDESC,0))) SALDO "
				EndIf
			EndIf

			cQuery += " FROM " + RetSqlName("SC7") + " SC7 "

			If lFincFluxo .and. !lF021DtFl
				cQuery += " LEFT JOIN " + RetSqlName("SD1") + " SD1 " 
				cQuery += " ON SD1.D_E_L_E_T_ = '' "
				cQuery += " AND SD1.D1_FILIAL  = C7_FILIAL "
				cQuery += " AND SD1.D1_PEDIDO  = C7_NUM " 
				cQuery += " AND SD1.D1_ITEMPC  = C7_ITEM "
				cQuery += " AND SD1.D1_COD     = C7_PRODUTO "
				cQuery += " AND SD1.D1_FORNECE = C7_FORNECE " 
				cQuery += " AND SD1.D1_LOJA    = C7_LOJA "
			EndIf

			cQuery += " WHERE C7_FILIAL = '" + xFilial("SC7") + "'"
			cQuery += " AND SC7.D_E_L_E_T_ = ' ' "
			cQuery += " AND C7_QUJE < C7_QUANT"
			cQuery += " AND C7_RESIDUO <> 'S'"
			cQuery += " AND C7_FLUXO   <> 'N'"

			If lFC020CQR
				cQuery += ExecBlock("FC020CQR",.F.,.F.)
			EndIf

			If lFincFluxo .and. !lF021DtFl
				cQuery += " GROUP BY D1_FILIAL, D1_PEDIDO, D1_FORNECE, D1_LOJA, C7_FILIAL,C7_NUM,C7_COND,C7_TOTAL,C7_VLDESC,C7_RESIDUO,C7_QUANT,C7_QUJE, "
				cQuery += " C7_CONAPRO,C7_FLUXO,C7_PRODUTO,C7_TES,C7_DATPRF,C7_MOEDA,C7_PRECO,C7_TXMOEDA,C7_REAJUST,C7_VALFRE,C7_SEGURO,C7_DESPESA, "
				cQuery += " C7_DESC1,C7_DESC2,C7_DESC3,C7_VLDESC,C7_ITEM,C7_FORNECE,C7_LOJA,C7_EMISSAO,C7_TIPO,C7_SEQUEN,C7_IPI,C7_IPIBRUT " 
			EndIf

			If lFinc024
				cQuery += "AND C7_RATEIO = '2'" //Rateio SCH é filtrado na outra query.
				If !Empty(cCustos)
					cQuery += "AND C7_CC IN (" + cCustos + ")"
				EndIf
			EndIf

			If lFinc024
				cQuery +=	"UNION ALL"

				If lF021DtFl
					cQuery := "SELECT * "
				Else
					cQuery := "SELECT C7_FILIAL,C7_NUM,C7_COND,C7_TOTAL,C7_VLDESC,C7_RESIDUO,C7_QUANT,C7_QUJE,C7_CONAPRO,C7_FLUXO,C7_PRODUTO,"
					cQuery += "C7_TES,C7_DATPRF,C7_MOEDA,C7_PRECO,C7_TXMOEDA,C7_REAJUST,C7_VALFRE,C7_SEGURO,C7_DESPESA,C7_DESC1,"
					cQuery += "C7_DESC2,C7_DESC3,C7_VLDESC,C7_ITEM,C7_FORNECE,C7_LOJA,C7_EMISSAO,C7_TIPO,C7_SEQUEN,C7_IPI,C7_IPIBRUT "
				EndIf

				cQuery += " FROM "+	RetSQLTab("SC7")
				cQuery += " JOIN "+	RetSQLTab("SCH") + " ON SCH.CH_PEDIDO = SC7.C7_NUM AND SCH.CH_ITEMPD = SC7.C7_ITEM "
				If (!Empty(cCustos), cQuery += "AND SCH.CH_CC IN (" + cCustos + ")", Nil)
				cQuery += " WHERE C7_FILIAL = '" + xFilial("SC7") + "'"
				cQuery += " AND C7_QUJE < C7_QUANT"
				cQuery += " AND C7_RESIDUO <> 'S'"
				cQuery += " AND C7_FLUXO   <> 'N' AND "
				cQuery += 	RetSqlCond("SC7,SCH")
			Else
				cQuery += " ORDER BY "+ SqlOrder(IndexKey())
			EndIf
			cQuery := ChangeQuery(cQuery)
			DbSelectArea("SC7")
			DbCloseArea()
			DbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), 'SC7', .F., .T.)

			For nI := 1 to Len(aStru)
				If aStru[nI,2] != 'C'
					TCSetField('SC7', aStru[nI,1], aStru[nI,2],aStru[nI,3],aStru[nI,4])
				Endif
			Next nI

			While SC7->(!Eof())

				cFilPed		:= SC7->C7_FILIAL
				cNumPed		:= SC7->C7_NUM
				nValTot		:= 0
				nValIpi		:= 0
				aVenc		:= {}
				cCond		:= SC7->C7_COND
				nTotDesc	:= SC7->C7_VLDESC
				nDespFrete	:= 0
				nValFIE	 	:= 0 //Ler adiantamentos do pedido somente uma vez

				While SC7->(!Eof()) .And. SC7->C7_NUM==cNumPed .and. xFilial("SC7") == SC7->C7_FILIAL
					If lRegua != Nil .and. lRegua
						IncProc(STR0032) // Processando Pedidos de compras
					Endif
					IF SC7->C7_QUJE >= SC7->C7_QUANT .or. SC7->C7_RESIDUO == "S" .or. SC7->C7_FLUXO == "N"
						SC7->(dbSkip())
						Loop
					Endif
					If (SC7->C7_CONAPRO == "B" .And. Left(cPedidos,1) == "1") .Or. (SC7->C7_CONAPRO != "B" .And. Left(cPedidos,1) == "2")
						SC7->(dbSkip())
						Loop
					Endif

					SB1->(dbSeek( xFilial("SB1") + SC7->C7_PRODUTO)) // Posiciona Produto
					If !Empty(SC7->C7_TES)
						lTES := SF4->(dbSeek( xFilial("SF4") + SC7->C7_TES ))  // Posiciona TES
					Else
						lTES := SF4->(dbSeek( xFilial("SF4") + RetFldProd(SB1->B1_COD,"B1_TE") ))  // Posiciona TES
					Endif

					// Se nao houver TES no Pedido ou Produto serah considerado pois o tes no PC nao eh obrigatorio ou comum.
					IF lTES .and. SF4->F4_DUPLIC == "N"
						dbSelectArea("SC7")
						dbSkip()
						Loop
					Endif

					SE2->(Dbsetorder(1))

					If nValFIE == 0//Ler adiantamentos do pedido somente uma vez
						FIE->(dbSetOrder(1))// Tabela Pedidos x Adiantamentos
						FIE->(MsSeek(xFilial("FIE")+"P"+cNumPed))
						While FIE->(!EOF()) .And. FIE->FIE_PEDIDO == cNumPed .And. !lPACalc
							If FIE->(Eval(bFilFIE))
								If SE2->(Dbseek(xFilial("SE2")+FIE->(FIE_PREFIX+FIE_NUM+FIE_PARCEL+FIE_TIPO+FIE_FORNEC+FIE_LOJA)))
									If F340MovPA(Nil, "SE2",.T.)[1] //Verifica se a PA possui movimentação bancária
										IF SE2->E2_MOEDA <> nMoeda
											If SE2->E2_TIPO $ MVPAGANT
												nValFIE += SE2->E2_VLCRUZ
											Endif
										Else
											If FIE->FIE_TIPO $ MVPAGANT
												nValFIE += FIE->FIE_VALOR  	// Valor do Adiantamento
											EndIf
										Endif
									EndIf
								EndIf
							EndIf
							FIE->(dbSkip())
						EndDo
						nValAdto += nValFIE
					EndIf

					//para que o calc da PA não seja executado com base na qtd de itens do pedido
					lPACalc := (FunName() == "FINC021" .or. FunName() == "FINA701")

					If lPACalc .And. nValPagAnt > 0 .And. TcSrvType() != "AS/400" .And. nTotRegSC7 == 0 .And. lSE2Excl
						aReaAt := GetArea()

						If __oMovPA == Nil
							cQuery := "SELECT COUNT(DISTINCT SC7.C7_DATPRF) TOTREGSC7 "
							cQuery += "FROM " + RetSqlName("SC7") + " SC7 "
							cQuery += "JOIN " + RetSqlName("FIE") + " FIE "
							cQuery += "ON (SC7.C7_NUM = FIE.FIE_PEDIDO AND SC7.C7_FILIAL = FIE.FIE_FILIAL) "
							cQuery += "JOIN " + RetSqlName("SE2") + " SE2 "
							cQuery += "ON (FIE.FIE_PREFIX = SE2.E2_PREFIXO AND FIE.FIE_NUM = SE2.E2_NUM AND "
							cQuery += "FIE.FIE_PARCEL = SE2.E2_PARCELA AND FIE.FIE_LOJA = SE2.E2_LOJA AND "
							cQuery += "FIE.FIE_FILIAL = SE2.E2_FILIAL AND "
							cQuery += "FIE.FIE_TIPO = SE2.E2_TIPO AND FIE.FIE_FORNEC = SE2.E2_FORNECE ) "
							cQuery += "JOIN " + RetSqlName("SE4") + " SE4 "
							cQuery += "ON (SC7.C7_COND = SE4.E4_CODIGO) "
							cQuery += "WHERE SC7.C7_NUM = ? AND "
							cQuery += "SC7.C7_FILIAL = ? AND "
							cQuery += "FIE.FIE_CART = 'P' AND FIE.FIE_TIPO IN('PA') AND "
							If lAdComPart
								cQuery += " ((FIE_FILORI = '"+cFilant+"') OR (FIE_FILORI = ' '))"
							EndIf
							cQuery += "SC7.D_E_L_E_T_ = ' ' AND "
							cQuery += "SE2.D_E_L_E_T_ = ' ' AND "
							cQuery += "FIE.D_E_L_E_T_ = ' ' AND "
							cQuery += "SE4.D_E_L_E_T_ = ' ' "

							cQuery := ChangeQuery(cQuery)
							__oMovPA := FWPreparedStatement():New(cQuery)
						EndIf

						__oMovPA:SetString(1, cNumPed)
						__oMovPA:SetString(2, xFilial("SC7"))

						cQry := __oMovPA:GetFixQuery()
						cTblTmp := MpSysOpenQuery(cQry)

						If (cTblTmp)->(!Eof())
							nTotRegSC7 := (cTblTmp)->TOTREGSC7
						EndIf
						(cTblTmp)->(DbCloseArea())

						If nTotRegSC7 > 1
							nValPagAnt := (nValPagAnt/nTotRegSC7)
						ElseIf nTotRegSC7 == 0
							SC7->(dbSkip())
							Loop
						EndIf

						RestArea(aReaAt)
					EndIf

					dbSelectArea("SC7")

					//------------------------------------------
					// Calcula o reajuste do pedido de compra
					//------------------------------------------
					dData := SC7->C7_DATPRF
					nPos := Ascan(aData, { |x| x[1] == SC7->C7_DATPRF } )
					If nPos == 0
						dData := DataValida(SC7->C7_DATPRF)
						aadd(aData, {SC7->C7_DATPRF, dData})
					Else
						dData := aData[nPos, 2]
					EndIf

					If lF021DtFl
						dData := Execblock("FC021DTF",.F.,.F.,{"SC7","SC7"})
					ElseIf lConsDtBase
						dData := Iif(SC7->C7_DATPRF < dDataBase, dDataBase, dData)
					Endif

					If SC7->C7_MOEDA != nMoeda .or. SC7->C7_MOEDA > 1
						nTaxaMoed:= If(Empty(SC7->C7_TXMOEDA), RecMoeda(dData,SC7->C7_MOEDA), SC7->C7_TXMOEDA)
					EndIf

					nPrcCompra := SC7->C7_PRECO
					If SC7->C7_MOEDA != nMoeda
						nPrcCompra := xMoeda(SC7->C7_PRECO,SC7->C7_MOEDA,nMoeda,dData,nDecimais, nTaxaMoed)
					EndIf

					If !Empty(SC7->C7_REAJUST)
						nPrcCompra := fc020Form(SC7->C7_REAJUST, dData)
					Endif

					nDespFrete := SC7->C7_VALFRE + SC7->C7_SEGURO + SC7->C7_DESPESA
					If SC7->C7_MOEDA != nMoeda
						nDespFrete := xMoeda(SC7->C7_VALFRE + SC7->C7_SEGURO + SC7->C7_DESPESA,SC7->C7_MOEDA,nMoeda,dData,nDecimais, nTaxaMoed)
					EndIf
					
					//Reiniciando variaveis
					nValTot	  	:= ((SC7->C7_QUANT-SC7->C7_QUJE) * nPrcCompra ) + nDespFrete
					nValIPILiq  := nValTot				
					nValIPI	  	:= 0				
					nTotDesc	:= SC7->C7_VLDESC

					If nTotDesc == 0
						nTotDesc := CalcDesc(nValTot,SC7->C7_DESC1,SC7->C7_DESC2,SC7->C7_DESC3)
					Else
					
						//-----------------------------------------------------------
						// Consulta o desconto de pedidos com entrega parcial
						//-----------------------------------------------------------			

						If lFincFluxo .and. !lF021DtFl
							If (nTotDesc := SC7->SALDO) < 0	//Consulta o Saldo de desconto não aplicado, considerando C7_VLDESC - D1_VALDESC.
								nTotDesc := 0				//Se o desconto D1_VALDESC está acima do planejado em C7_VLDESC, o sistema não vai considerar desconto p/ o saldo restante do pedido.			
							EndIf
						Else
													
							nTotDesc := ((SC7->C7_VLDESC * (nValTot - nDespFrete))/SC7->C7_TOTAL)

						Endif

					EndIf

					nValTot	  := nValTot - nTotDesc

					IF SC7->C7_IPI > 0
						If SC7->C7_IPIBRUT != "L"
							nBaseIPI := nValTot
						Else
							nBaseIPI := nValIPILiq
						Endif
						IF SF4->F4_BASEIPI > 0
							nBaseIPI *= SF4->F4_BASEIPI / 100
						Endif
						nValIPI := IIf(nBaseIPI = 0, 0, nBaseIPI * SC7->C7_IPI / 100)
					Endif
					nValTot  += nValIPI
					dbSelectArea("SE4")
					dbSeek(xFilial("SE4")+SC7->C7_COND)
					nValTot  *= (SE4->E4_ACRSFIN/100)+1
					dbSelectArea("SC7")
					If lFc020Com		// Retornar a condicao do Item e do Total
						aVenc := ExecBlock("FC020COM",.F.,.F.,{SC7->C7_NUM,SC7->C7_ITEM,nValTot,cCond,nValIpi,dData})
					Else
						aVenc := Condicao(nValTot,cCond,nValIpi,dData)
					Endif

					IF Len(aVenc) > 0
						// Posiciona no fornecedor para buscar a natureza
						DbSelectArea("SA2")
						DbSetOrder(1)
						MsSeek(xFilial("SA2")+SC7->C7_FORNECE+SC7->C7_LOJA)
						cNatureza := PAd(If(Empty(SA2->A2_NATUREZ), "PC", SA2->A2_NATUREZ ), Len(SED->ED_CODIGO))

						For i:=1 To Len(aVenc)

							If i==1 //Só deve considerar o adiantamento na primeira parcela, para refletir o processo de compensação automatica
								If (nValAdto-nValPagAnt) > aVenc[i][2]
									nVlPAItem := aVenc[i][2]
								Else
									nVlPAItem := (nValAdto-nValPagAnt)
								EndIf
								
								nValPagAnt += nVlPAItem

								If nValPagAnt > nValAdto
									nValPagAnt := nValAdto
								Endif	
							ELSE
								nVlPAItem := 0
							EndIf

							nPosData := Ascan(aDataAux, {|e| e[1] == aVenc[i][1]})
							If nPosData == 0
								dDataFluxo := DataValida(aVenc[i][1])
								AADD(aDataAux, {aVenc[i][1], dDataFluxo})
							Else
								dDataFluxo := aDataAux[nPosData][2]
							Endif
								
							// Verifico se a data já foi validada
							If lAnalitic
								nL := Ascan(aCompras, {|e| e[1] == dDataFluxo .And. e[3] == cNatureza .And. e[5] == cNumPed .And. e[6] == cFilPed})
							Else
								nL := Ascan(aCompras, {|e| e[1] == dDataFluxo .And. e[3] == cNatureza } )
							Endif

							IF nL != 0
								aCompras[nL][2] += aVenc[i][2]
								aCompras[nL][4] += nVlPAItem
							Else
								AADD(aCompras, {dDataFluxo, aVenc[i][2], cNatureza, nVlPAItem, cNumPed, cFilPed})
								AADD(adCompras, dDataFluxo)
							Endif

							// Se foi enviado o arquivo temporario para geracao do fluxo de caixa analitico, gera o pedido de compra neste arquivo
							If cAliasPc != Nil
								DbSelectArea(cAliasPc)
								nAscan := AScan(aPeriodo, {|e| e[1] == dDataFluxo})
								// Se a data do pedido ja venceu, insere na primeira data do fluxo
								If dDataFluxo < aPeriodo[1][1]
									dDataFluxo := aPeriodo[1][1]
									nAscan := 1
								EndIf
								If nAscan > 0
									lInclusao := .T.
									(cAliasPc)->(DbSetOrder(nOrdTmp)) 
									If (cAliasPc)->(DbSeek(&(cChaveTmp)))
										lInclusao := .F.
									EndIf																			

									RecLock(cAliasPc, lInclusao)
									If lInclusao
										If lSC7Exclus
											(cAliasPc)->FILIAL	:= SC7->C7_FILIAL
										EndIf
										(cAliasPc)->DATAX	:= dDataFluxo
										(cAliasPc)->PERIODO	:= aPeriodo[nAscan][2]
										(cAliasPc)->NUMERO	:= SC7->C7_NUM
										(cAliasPc)->EMISSAO	:= SC7->C7_EMISSAO
										(cAliasPc)->CLIFOR	:= SC7->C7_FORNECE
										(cAliasPc)->TIPO	:= SC7->C7_TIPO
										(cAliasPc)->ITEM	:= SC7->C7_ITEM
										// Posiciona no fornecedor para buscar o nome
										SA2->(DbSetOrder(1))
										SA2->(MsSeek(FwXFilial("SA2") + SC7->C7_FORNECE + SC7->C7_LOJA))
										(cAliasPc)->NOMCLIFOR	:= SA2->A2_NOME
										(cAliasPc)->PRODUTO		:= SC7->C7_PRODUTO
										(cAliasPc)->NATUREZA	:= SA2->A2_NATUREZ
										(cAliasPc)->CHAVE		:= FwXFilial("SC7") + SC7->C7_NUM + SC7->C7_ITEM + SC7->C7_SEQUEN
									EndIf

									(cAliasPc)->SALDO += aVenc[i][2]
									If i == 1
										(cAliasPc)->VALPAGANT := nValPagAnt
									EndIf

									(cAliasPc)->(MsUnlock())

									// Pesquisa na matriz de totais, os totais de pedidos de compra da data de trabalho.
									If aTotais # Nil
										nAscan := Ascan( aTotais[3], {|e| e[1] == (cAliasPc)->DATAX})
										If nAscan == 0
											Aadd( aTotais[3], {(cAliasPc)->DATAX,aVenc[i][2]})
										Else
											aTotais[3][nAscan][2] += aVenc[i][2] //(cAliasPc)->SALDO // Totaliza os pedidos de compra
										EndIf
									EndIf
								EndIf
								(cAliasPc)->(DbSetOrder(1))
							EndIf
						Next i
					EndIf
					DbSelectArea("SC7")
					SC7->(DbSkip())
				EndDo
				nValPagAnt	:= 0
				lPACalc		:= .F.
				nTotRegSC7	:= 0
				nValAdto	:= 0
			EndDo

			DbSelectArea("SC7")
			DbCloseArea()
			ChKFile("SC7")
			DbSelectArea("SC7")
			DbSetOrder(1)

			If Empty(xFilial("SC7"))
				Exit
			Endif
		EndIf
	Next

	If __oMovPA <> Nil
		__oMovPA:Destroy()
	EndIf
	cFilAnt := cSaveFil // recupera variavel cFilAnt

Return .T.

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FC020VENDA

Monta array com Pedidos de Venda (Fluxos de caixa).
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	06/07/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function fc020Venda(cMoedas, cAliasPv, aTotais, lRegua, nMoeda, aPeriodo, cFilIni, cFilFin, aCCustos, cRiscoDe, cRiscoAte, aSelFil, lAnalitic,lTxMoePed)

Local cNumPed
Local cCond
Local nValTot		:= 0
Local nValIpi		:= 0
Local aVenc			:= {}
Local i
Local nPrcVen
Local dData
Local lFc020Vda		:= ExistBlock("FC020VDA")
Local lFc020Vdb		:= ExistBlock("FC020VDB")
Local lFc020Vdc		:= ExistBlock("FC020VDC")
Local lFC020VQR		:= ExistBlock("FC020VQR")
Local cFilDe
Local cFilAte
Local cFilPed
Local bSelFil
Local cSaveFil		:= cFilAnt
Local nAscan
Local dDataFluxo	:= {}
Local aDataAux		:= {}
Local nPosData 		:= 0
Local aDesp			:= {}
Local lPedido		:= .T.
Local lFirst		:= .T.
Local nDespFrete	:= 0
Local lMoedaFre		:= (SuperGetMv("MV_FRETMOE") == "S")
Local nDecimais		:= TamSx3("C6_PRCVEN")[2]
Local cAliasSc6		:= "SC6"
Local nInc			:= 0
Local aSM0			:= AdmAbreSM0()
Local lF021DtFl		:= Existblock("FC021DTF")
Local cCustos		:= ''
Local lFinc024		:= FwIsInCallStack("FINC024")
Local nX			:= 0
Local nI			:= 0
Local aStru			:= SC6->(dbStruct())
Local cQuery
Local nValRecAnt	:= 0
Local nTaxaMoeda    := 0
Local lSldPcFIe		:= FindFunction("SldPcFIe")

Default nMoeda		:= 1
Default cFilIni		:= Space( FWGETTAMFILIAL)
Default cFilFin		:= Replicate( "Z", FWGETTAMFILIAL)
Default aCCustos	:= {}
Default cRiscoDe	:= ''
Default cRiscoAte	:= ''
Default lAnalitic   := .F.
Default cMoedas		:= "012345"
Default lTxMoePed   := .F.

// Verifica o tipo de filtro de filial.
If empty(aSelFil)
	bSelFil := {|cFilInc| aScan(aSelFil, cFilInc) > 0}
Else
	If mv_par03 == 2		// por empresa
		cFilDe	:= cFilIni
		cFilAte := cFilFin
	Else					// por filial
		cFilDe	:= cFilAnt
		cFilAte := cFilAnt
	Endif
	bSelFil := {|cFilInc| AllTrim(cFilInc) >= Alltrim(cFilDe) .And. AllTrim(cFilInc) <= Alltrim(cFilAte)}
Endif

If lFinc024
	For nX := 1 To Len(aCCustos)
		cCustos += "'" + aCCustos[nX] + "',"
	Next nX
	cCustos := Substr(cCustos, 1, Len(cCustos) - 1)
EndIf

For nInc := 1 To Len( aSM0 )
	If aSM0[nInc][1] == cEmpAnt .And. Eval(bSelFil, aSM0[nInc][2])
		cFilAnt := aSM0[nInc][2]

		//--------------------------
		// Ler Pedidos de Venda
		//--------------------------
		dbSelectArea("SC6")
		dbSetOrder(1)
		dbSeek(xFilial())

		cAliasSc6 := GetNextAlias()

		If lFinc024
			If lF021DtFl
				cQuery := "SELECT * "
			Else
				cQuery := "SELECT C6_FILIAL, C6_NUM, C6_ITEM, C6_BLQ,C6_QTDENT,C6_QTDVEN, C6_TES, C6_ENTREG, C6_PRODUTO,C6_PRCVEN "
			EndIf

			cQuery += "  FROM "+	RetSqlName("SC5") + " SC5
			//Filtra o cliente pelo risco.
			cQuery += " JOIN "+ RetSqlName("SA1")  + " ON A1_COD = C5_CLIENT AND A1_LOJA = C5_LOJACLI AND "
			cQuery += " A1_RISCO >='" + cRiscoDe  + "' AND "
			cQuery += " A1_RISCO <='" + cRiscoAte +"',"

			cQuery +=           	RetSqlName("SC6") + " SC6 "
			cQuery += " WHERE SC6.C6_FILIAL = '" + xFilial("SC6") + "'"
			cQuery += " AND SC6.C6_BLQ <> 'R'"
			cQuery += " AND SC6.C6_BLQ <> 'S'"
			cQuery += " AND SC6.C6_QTDENT < SC6.C6_QTDVEN"
			cQuery += " AND SC5.C5_FILIAL = '" + xFilial("SC5") + "'"
			cQuery += " AND SC6.C6_NUM = SC5.C5_NUM "
			cQuery += " AND SC6.C6_RATEIO = '2' AND " // Não filtra itens que tiveram rateio.
			If (!Empty(cCustos), cQuery += " SC6.C6_CCUSTO IN (" + cCustos + ") AND ", Nil)
			cQuery += 	RetSqlCond("SC6,SC5")

			//Faz relacionamento com a tabela AGG para filtrar o centro de custo.
			cQuery += " UNION ALL "

			cQuery += "SELECT C6_FILIAL, C6_NUM, C6_ITEM, C6_BLQ,C6_QTDENT,C6_QTDVEN, C6_TES, C6_ENTREG, C6_PRODUTO, "
			cQuery += "(C6_PRCVEN * AGG_PERC)/100"
			cQuery += "  FROM "+	RetSqlName("SC5") + " SC5
							//Filtra o cliente pelo risco.
			cQuery += " JOIN "+ RetSqlName("SA1")  + " ON A1_COD = C5_CLIENT AND A1_LOJA = C5_LOJACLI AND "
			cQuery += " A1_RISCO >='" + cRiscoDe  + "' AND "
			cQuery += " A1_RISCO <='" + cRiscoAte +"',"

			cQuery +=          	RetSqlName("SC6") + " SC6  "
			cQuery += "  JOIN "+	RetSqlName("AGG") + " AGG ON AGG_PEDIDO = C6_NUM AND AGG_ITEMPD = C6_ITEM "
			If (!Empty(cCustos), cQuery += " AND AGG_CC IN (" + cCustos + ") ", Nil)
			cQuery += " WHERE SC6.C6_FILIAL = '" + xFilial("SC6") + "'"
			cQuery += " AND SC6.C6_BLQ <> 'R'"
			cQuery += " AND SC6.C6_BLQ <> 'S'"
			cQuery += " AND SC6.C6_QTDENT < SC6.C6_QTDVEN"
			cQuery += " AND SC5.C5_FILIAL = '" + xFilial("SC5") + "'"
			cQuery += " AND SC6.C6_NUM = SC5.C5_NUM AND "
			cQuery += 	RetSqlCond("SC6,SC5,AGG")

		Else
			If lF021DtFl
				cQuery := "SELECT * "
			Else
				cQuery := "SELECT DISTINCT C6_FILIAL, C6_NUM, C6_ITEM, C6_BLQ,C6_QTDENT,C6_QTDVEN, C6_TES, C6_PRCVEN, C6_ENTREG, C6_PRODUTO "
			EndIf

			cQuery += "  FROM " +	RetSqlName("SC6") + " SC6, "
			cQuery +=           	RetSqlName("SC5") + " SC5 "
			cQuery += " WHERE SC6.C6_FILIAL = '" + xFilial("SC6") + "'"
			cQuery += " AND SC6.C6_BLQ <> 'R'"
			cQuery += " AND SC6.C6_BLQ <> 'S'"
			cQuery += " AND SC6.C6_QTDENT < SC6.C6_QTDVEN"
			cQuery += " AND SC5.C5_FILIAL = '" + xFilial("SC5") + "'"
			cQuery += " AND SC6.C6_NUM = SC5.C5_NUM "
			cQuery += " AND SC5.D_E_L_E_T_ = ' ' "
			cQuery += " AND SC6.D_E_L_E_T_ = ' ' "
		EndIf

		If lFC020VQR
			cQuery += ExecBlock("FC020VQR",.F.,.F.)
		EndIf

		cQuery += " ORDER BY C6_FILIAL, C6_NUM, C6_ITEM "
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasSc6, .F., .T.)

		For nI := 1 to Len(aStru)
			If aStru[nI,2] != 'C'  .And. FieldPos(aStru[nI,1]) > 0
				TCSetField(cAliasSc6, aStru[nI,1], aStru[nI,2],aStru[nI,3],aStru[nI,4])
			Endif
		Next nI

		While (cAliasSc6)->(!Eof()) .AND. (cAliasSc6)->C6_FILIAL == xFilial("SC6")

			cFilPed := (cAliasSc6)->C6_FILIAL
			cNumPed := (cAliasSc6)->C6_NUM
			nValTot := 0
			nValIpi := 0
			aVenc := {}
			aDesp := {}
			lPedido := .T.
			lFirst:= .T.
			While (cAliasSc6)->(!Eof()) .and. (cAliasSc6)->C6_NUM == cNumPed .and. xFilial("SC6") == (cAliasSc6)->C6_FILIAL
				If lRegua != Nil .And. lRegua
					IncProc(STR0069)  // "Processando Pedidos de vendas"
				Endif
				If lFc020Vdb
					SF4->(dbSetOrder(1))
					If SF4->(!dbSeek(xFilial() + (cAliasSc6)->C6_TES, .F.) .Or. F4_DUPLIC == "N")
						(cAliasSc6)->(dbSkip())
						Loop
					Endif
				Endif
				dbSelectArea("SC5")
				SC5->(MsSeek( xFilial("SC5")+cNumPed ))
				If (STR(SC5->C5_MOEDA,1) $ cMoedas)
					cCond := SC5->C5_CONDPAG
					
					//Verifica se existe a função SldPCFIE
					If lSldPcFIe
						nValRecAnt += SldPCFIE(cNumPed,'R',0,{|| FIE->FIE_TIPO $ MVRECANT } )
					Else
						dbSelectArea("FIE")  // Tabela Pedidos x Adiantamentos
						FIE->(dbSetOrder(1))
						FIE->(dbGoTop())
						FIE->(MsSeek(xFilial("FIE")+"R"+cNumPed))
						While FIE->(!EOF()) .And. FIE->FIE_PEDIDO == cNumPed
							If FIE->FIE_TIPO $ MVRECANT
								nValRecAnt += FIE->FIE_VALOR  	// Valor do Adiantamento
							EndIf
							FIE->(dbSkip())
						EndDo
					Endif

					If lFc020Vdc	
						/*
							Este PE foi criado para substituir os PEs FC021DTF(para Vendas) e FC020VDA/FC020VDB
							Recomenda-se o uso/migração para este novo PE FC020VDC -> onde se espera o retorno de todos os valores do pedido inteiro, semelhante ao aVenc := Ma410Fluxo(cNumPed,.F.)

							Motivo da substituição: 
							1) A data do PE FC021DTF não é utilizada para o fluxo em si, somente utilizada somente para reajuste de preço e fluxo dos valores de frete/despesa/seguro ( função condição() ) . Diferente do 
							2) Para vendas é passado apenas 1 vez por pedido no laço e não por item,  como os PEs FC020VDA/FC020VDB sugerem
							3) O tratamento para Frete/Despesa/Seguro logo após os PEs não é possível manipular pelo PE, sendo utilizada condicao(), podendo ficar "descasado" do tratamento do PE
						*/
						aVenc := ExecBlock("FC020VDC",.F.,.F.,{(cAliasSc6)->C6_NUM})
						If ValType(aVenc) <> 'A' .OR. Len(aVenc) <= 0
							aVenc := Ma410Fluxo((cAliasSc6)->C6_NUM,.F.)
						EndIf

					ElseIf lFc020Vdb
						dbSelectArea(cAliasSc6)

						//----------------------------------------
						// Calcula o reajuste do pedido de venda
						//----------------------------------------
						nPrcVen := (cAliasSc6)->C6_PRCVEN
						If lF021DtFl
							dData := Execblock("FC021DTF",.F.,.F.,{"SC6",cAliasSc6})
						Else
							dData := Iif( (cAliasSc6)->C6_ENTREG < dDataBase, dDataBase, (DataValida((cAliasSc6)->C6_ENTREG)))
						Endif

						IF !Empty(SC5->C5_REAJUST)
							nPrcVen := fc020Form(SC5->C5_REAJUST,dData)
						Endif
						nPrcVen := xMoeda(nPrcVen,SC5->C5_MOEDA,nMoeda,dData,nDecimais)

						nValTot	:= ((cAliasSc6)->(C6_QTDVEN-C6_QTDENT)) * nPrcVen
						cProd 	:= (cAliasSc6)->C6_PRODUTO
						dbSelectArea("SB1")
						dbSeek(xFilial("SB1")+cProd)
						dbSelectArea(cAliasSc6)
						nValIPI	:= 0
						IF SF4->F4_IPI == "S" .And. SB1->B1_IPI > 0
							nBaseIPI :=((cAliasSc6)->(C6_QTDVEN-C6_QTDENT))*nPrcVen
							If SF4->F4_BASEIPI > 0
								nBaseIPI*=(SF4->F4_BASEIPI/100)
							Endif
							nValIpi  :=IIf(nBaseIPI=0,0,(nBaseIPI*SB1->B1_IPI)/100)
						Endif
						nValTot += nValIPI
						nValTot *= (SC5->C5_ACRSFIN/100)+1
						dbSelectArea(cAliasSc6)

						If lFc020Vda // Retornar a condicao do Item e do Total
							aVenc := ExecBlock("FC020VDA",.F.,.F.,{(cAliasSc6)->C6_NUM,(cAliasSc6)->C6_ITEM,nValTot,cCond,nValIpi,dData})
						Else
						  	aVenc := ExecBlock("FC020VDB",.F.,.F.,{(cAliasSc6)->C6_NUM,(cAliasSc6)->C6_ITEM,nValTot,cCond,nValIpi,dData})
						Endif
						If Len(aVenc) > 0
							If lPedido
								//Despesas, Seguro e Frete
								nDespFrete := xMoeda(SC5->C5_FRETE+SC5->C5_SEGURO+SC5->C5_DESPESA,If(lMoedaFre,SC5->C5_MOEDA,1),mv_par02,dData,nDecimais)
								aDesp := Condicao(nDespFrete,cCond,,dData)
								lPedido := .F.
								If Len(aDesp) > 0
									DbSelectArea("SA1")
									DbSetOrder(1)
									MsSeek(xFilial("SA1")+SC5->C5_CLIENTE+SC5->C5_LOJACLI)
									cNatureza := Pad(If(Empty(SA1->A1_NATUREZ), "PV", SA1->A1_NATUREZ ), Len(SED->ED_CODIGO))
									For i := 1 To Len(aDesp)
										dDataFluxo := DataValida(aDesp[i][1])
										If lAnalitic
											nL := Ascan(aVendas, {|e| e[1] == dDataFluxo .And. e[3] == cNatureza .And. e[5] == cNumPed .And. e[6] == cFilPed})
										Else
											nL := Ascan(aVendas, {|e| e[1] == dDataFluxo .And. e[3] == cNatureza})
										Endif
										IF nL != 0
											aVendas[nL][2]+=aDesp[i][2]
											aVendas[nL][4]+=nValRecAnt
										Else
											AADD(aVendas, {dDataFluxo, aDesp[i][2], cNatureza, nValRecAnt, cNumPed, cFilPed})
											AADD(aDVendas, dDataFluxo)
										Endif
									Next i
								Endif
							Endif
						Endif
					Else
						aVenc := Ma410Fluxo(cNumPed,.F.)						
						For i := 1 To Len(aVenc)
							If SC5->C5_MOEDA != nMoeda .or. SC5->C5_MOEDA > 1
								If lTxMoePed
									nTaxaMoeda := SC5->C5_TXMOEDA
								Else
									nTaxaMoeda := RecMoeda(aVenc[i][1],SC5->C5_MOEDA)
								EndIf
							EndIf
							
							If SC5->C5_MOEDA != nMoeda
								aVenc[i][2] := xMoeda(aVenc[i][2], SC5->C5_MOEDA, nMoeda, aVenc[i][1], nDecimais,nTaxaMoeda)
							Endif
						Next
					Endif

					// Parcelas do Pedido
					DbSelectArea("SA1")
					DbSetOrder(1)
					MsSeek(xFilial("SA1")+SC5->C5_CLIENTE+SC5->C5_LOJACLI)
					cNatureza := Pad(If(Empty(SA1->A1_NATUREZ), "PV", SA1->A1_NATUREZ ), Len(SED->ED_CODIGO))

					dbSelectArea("FIE")  // Tabela Pedidos x Adiantamentos
					FIE->(dbSetOrder(1))
					If FIE->(dbSeek(xFilial("FIE")+"R"+cNumPed))
						nValRecAnt := 0
						While FIE->(FIE_FILIAL+FIE_CART+FIE_PEDIDO) == xFilial("FIE")+"R"+cNumPed
							If FIE->FIE_TIPO $ MVRECANT
							/* - Moeda do RA for diferente da moeda solicitada na consulta
								- Posiciono na RA no SE1 para verifica a moeda do RA							    */
								dbSelectArea("SE1")
								dbSetOrder(1)
								If dbSeek(xFilial("SE1")+FIE->(FIE_PREFIX+FIE->FIE_NUM+FIE_PARCEL+FIE_TIPO))
									If SE1->E1_MOEDA != nMoeda
										nValRecAnt += xMoeda(FIE->FIE_VALOR, SE1->E1_MOEDA, nMoeda, dDataFluxo)
									Else	
										nValRecAnt += FIE->FIE_VALOR
									EndIf
								Endif
							EndIf
							FIE->(dbSkip())
						Enddo
					EndIf

					For i := 1 To Len(aVenc)

						If i==1 //Só deve considerar o adiantamento na primeira parcela, como é feito no compras
							If nValRecAnt > aVenc[i][2]
								nValRecAnt := aVenc[i][2]
							EndIf
						Else
							nValRecAnt := 0
						EndIf

						nPosData := Ascan(aDataAux, {|e| e[1] == aVenc[i][1]})
						If nPosData == 0
							dDataFluxo := DataValida(aVenc[i][1])
							AADD(aDataAux, {aVenc[i][1], dDataFluxo})
						Else
							dDataFluxo := aDataAux[nPosData][2]
						Endif

						If lAnalitic
							nL := Ascan(aVendas, {|e| e[1] == dDataFluxo .And. e[3] == cNatureza .And. e[5] == cNumPed .And. e[6] == cFilPed})
						Else
							nL := Ascan(aVendas, {|e| e[1] == dDataFluxo .And. e[3] == cNatureza})
						Endif
						IF nL != 0
							aVendas[nL][2]+=aVenc[i][2]
							aVendas[nL][4]+=nValRecAnt
						Else
							AADD(aVendas, {dDataFluxo, aVenc[i][2], cNatureza, nValRecAnt, cNumPed, cFilPed})
							AADD(aDVendas, dDataFluxo)
						Endif

						// Se foi enviado o arquivo temporario para geracao do fluxo
						// de caixa analitico, gera o pedido de venda neste arquivo
						If cAliasPv != Nil
							DbSelectArea(cAliasPv)
							nAscan := Ascan(aPeriodo, {|e| e[1] == dDataFluxo})
							// Se a data do pedido ja venceu, insere na primeira data do fluxo
							If dDataFluxo < aPeriodo[1][1]
								dDataFluxo := aPeriodo[1][1]
								nAscan := 1
							Endif
							If nAscan > 0
								If !dbSeek(dTos(dDataFluxo)+SC5->C5_NUM)
									RecLock(cAliasPv,.T.)
									(cAliasPv)->DATAX  := dDataFluxo
									(cAliasPv)->Periodo:= aPeriodo[nAscan][2]
									(cAliasPv)->NUMERO := SC5->C5_NUM
									(cAliasPv)->EMISSAO:= SC5->C5_EMISSAO
									(cAliasPv)->CLIFOR := SC5->C5_CLIENTE
									(cAliasPv)->LOJAENT:= SC5->C5_LOJAENT
									(cAliasPv)->LOJACLI:= SC5->C5_LOJACLI
									(cAliasPv)->TIPO   := SC5->C5_TIPO
									// Posiciona no cliente para buscar o nome
									If SC5->C5_TIPO=="D"
										DbSelectArea("SA2")
										DbSetOrder(1)
										MsSeek(xFilial("SA2")+SC5->C5_CLIENTE+SC5->C5_LOJACLI)
										DbSelectArea(cAliasPv)
										(cAliasPv)->NOMCLIFOR:= SA2->A2_NOME
										(cAliasPv)->CHAVE  := xFilial("SC5")+SC5->C5_NUM
									Else
										DbSelectArea("SA1")
										DbSetOrder(1)
										MsSeek(xFilial("SA1")+SC5->C5_CLIENTE+SC5->C5_LOJACLI)
										DbSelectArea(cAliasPv)
										(cAliasPv)->NOMCLIFOR:= SA1->A1_NOME
										(cAliasPv)->CHAVE  := xFilial("SC5")+SC5->C5_NUM
									Endif
								Else
									RecLock(cAliasPv,.F.)
								Endif

								//Somo a despesa/Frete/Seguro relativa a parcela apenas uma vez
								//Se refere ao valor da parcela e nao do item
								IF Len(aDesp) > 0 .and. lFirst
									nValDfs := aDesp[i][2]
									lFirst := .F.
								Else
									nValDfs := 0
								Endif
	         					(cAliasPv)->SALDO  += aVenc[i][2]+ nValDfs
	         					(cAliasPv)->VALRECANT += nValRecAnt

								// Pesquisa na matriz de totais, os totais de pedidos de compra
								// da data de trabalho.
								nAscan := Ascan( aTotais[4], {|e| e[1] == (cAliasPv)->DATAX})
								If nAscan == 0
									Aadd( aTotais[4], {(cAliasPv)->DATAX,aVenc[i][2]+ nValDfs})
								Else
									aTotais[4][nAscan][2] += aVenc[i][2]+ nValDfs // Totaliza os pedidos de venda
								Endif
							Endif
						Endif
					Next i
				Endif
				dbSelectArea(cAliasSc6)

				// Vai para o proximo pedido, pois a Ma410Fluxo ja processou todos
				// o itens, e se nao for para proximo pedido, os dados ficarao duplicados
				While (cAliasSc6)->(!Eof()) .And. (cAliasSc6)->C6_NUM == cNumPed .And. xFilial("SC6") == (cAliasSc6)->C6_FILIAL
					dbSkip()
				EndDo

			EndDo
			nValRecAnt := 0
		EndDo

		dbSelectArea(cAliasSc6)
		dbCloseArea()
		dbSelectArea("SC6")
		dbSetOrder(1)

		If Empty(xFilial("SC6"))
			Exit
		Endif
	EndIf
Next nInc

cFilAnt := cSaveFil // recupera variavel cFilAnt

Return .T.

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} GATCLI

Funcao da regra dos gatilhos do campo E1_CLIENTE..
Arquivo original: FINXFUN.PRX

@Author	Adrianne Furtado
@since	15/06/2008
/*/
//-----------------------------------------------------------------------------------------------------
Function GatCli(cDomin)
Local cRet

If cDomin == "E1_NOMCLI"
	If SA1->(A1_COD) == M->(E1_CLIENTE) .And. SA1->A1_LOJA == M->(E1_LOJA)
		cRet := SA1->A1_NREDUZ
	Else
		cRet := Posicione("SA1", 1, xFilial("SA1")+M->E1_CLIENTE+If(Empty(M->(E1_LOJA)),SA1->A1_LOJA,M->(E1_LOJA)), "SA1->A1_NREDUZ")
	EndIf
ElseIf cDomin == "E1_LOJA"
	cRet := If(Empty(M->(E1_LOJA)),SA1->A1_LOJA,M->(E1_LOJA))
EndIf

Return cRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} GATFORN

Funcao da regra dos gatilhos do campo E2_FORNECE.
Arquivo original: FINXFUN.PRX

@Author	Adrianne Furtado
@since	15/06/2008
/*/
//-----------------------------------------------------------------------------------------------------
Function GatForn(cDomin)
Local cRet

If cDomin == "E2_NOMFOR"
	If SA2->(A2_COD) == M->(E2_FORNECE)// .and. !Empty(M->E2_LOJA)
		cRet := SA2->A2_NREDUZ
	Else
		cRet := Posicione("SA2", 1, xFilial("SA2")+M->E2_FORNECE , "SA2->A2_NREDUZ" )
	EndIf
ElseIf cDomin == "E2_LOJA"
	cRet := SA2->A2_LOJA
EndIf

Return cRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA050NOME

Mostra o nome do fornecedor se a loja e codigo estiverem  preenchidos corretamente. (Gatilho).
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	27/04/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function FA050Nome(cCodOuLoj)

Local lRetorna := .T.
Local nValor 	:= 0
Local nPercIss := 0

If lRetorna
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso altere o Fornecedor e este n†o recolha ISS							³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(m->e2_naturez)
		nValor		:= m->e2_valor + m->e2_iss + m->e2_irrf + m->e2_inss
		m->e2_valor += m->e2_iss
		m->e2_iss	:= 0
		nOldIss		:= 0
		If SED->ED_CALCISS == "S" .And. SA2->A2_RECISS != "S"
			nPercIss := GetMV("MV_ALIQISS")
			If ExistBlock("F050PISS")
				nPercIss := ExecBlock("F050PISS",.F.,.F.)
			Endif
			m->e2_iss := (nValor) * nPercIss / 100
		EndIf
		If m->e2_tipo $ MVPROVIS+"/"+MVRECANT+"/"+MVPAGANT+"/"+MV_CRNEG+"/"+MV_CPNEG
			m->e2_iss	:= 0
			nOldIss		:= 0
		EndIf
		m->e2_valor += m->e2_inss
		m->e2_inss	:= 0
		nOldInss		:= 0
		If SED->ED_CALCINS == "S" .And. SA2->A2_RECINSS == "S"
			m->e2_inss := (nValor) * SED->ED_PERCINS / 100
		EndIf
		If m->e2_tipo $ MVPROVIS+"/"+MVRECANT+"/"+MVPAGANT+"/"+MV_CRNEG+"/"+MV_CPNEG
			m->e2_inss	:= 0
			nOldInss		:= 0
		EndIf
		m->e2_valor -= m->e2_iss + m->e2_inss

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Inicializa o valor em Real como sugestao									³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nSavRec := SX3->(Recno())
		cMascara:=PesqPict("SE2","E2_VLCRUZ",19)
		SX3->(DbGoto(nSavRec))
		M->E2_VLCRUZ:=xMoeda(M->E2_VALOR,M->E2_MOEDA,1,M->E2_EMISSAO,,M->E2_TXMOEDA)
		lRetorna := .T.
	EndIf
EndIf
If lRetorna
	lRefresh := .T.
EndIf
nOldValor := m->e2_valor
Return lRetorna


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ORDTITPAI

Função que retorna a ordem do indice E1_FILIAL + E1_TITPAI
Arquivo original: FINXFUN.PRX

@Author	Pâmela Bernardo
@since	30/10/2012
/*/
//-----------------------------------------------------------------------------------------------------
Function OrdTitpai()
Return nOrdTitPai


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RECSALBCO

Recupera o saldo bancário em uma determinada data.
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	25/07/1997
/*/
//-----------------------------------------------------------------------------------------------------
Function RecSalBco( cBanco, cAgencia, cConta, dData )

Local cAlias 		:= ALIAS()
Local nRecnoSE8		:= 0

dbSelectArea("SE8")
dbSetOrder(1)
dbSeek(xFilial()+cBanco+cAgencia+cConta+DtoS(dData),.T.)
If SE8->E8_DTSALAT==dData.and.E8_FILIAL+E8_BANCO+E8_AGENCIA+E8_CONTA==xFilial()+cBanco+cAgencia+cConta
	nSaldo := SE8->E8_SALATUA
Else
	nRecnoSE8 := SE8->(RECNO())
	SE8->(DbSkip(-1))
	If SE8->(RECNO()) <> nRecnoSE8 // DbSkip(-1) no primeiro registro
		If E8_FILIAL+E8_BANCO+E8_AGENCIA+E8_CONTA == xFilial()+cBanco+cAgencia+cConta
			nSaldo := SE8->E8_SALATUA
		Else
			nSaldo := 0
		Endif
	Else
		nSaldo := 0
	Endif
Endif
dbSelectArea( cAlias )
Return nSaldo


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FRVLCOMPFIL

Funcao que retorna o valor da compensacao de um título que  foi compensado em filiais diferentes
(FINR130/FINR150/FINR340).
Arquivo original: FINXFUN.PRX

Parametros
EXPC1 - Tipo da carteira:"R" - Contas a Receber; "P" - Contas a Pagar
EXPC2 - Prefixo do titulo principal
EXPC3 - Numero do titulo principal
EXPC4 - Parcela do titulo principal
EXPC5 - Tipo do titulo principal
EXPC6 - Fornecedor do titulo principal
EXPC7 - Loja do titulo principal
EXPC8 - Tipo de data a ser utilizada para compor o saldo do
		0 = Data Da Baixa (E5_DATA)
		1 = Data de Disponibilidade (E5_DTDISPO)
		2 = Data de Contabilidação (E5_DTDIGIT)
EXPA9  - Vetor com todas as filiais da empresa
EXPC10 - Vetor com as filiais diferentes da filial atual

@Author	Marcio Menon
@since	24/03/2008
/*/
//-----------------------------------------------------------------------------------------------------
Function FRVlCompFil(cRecPag,cPrefixo,cNumero,cParcela,cTipo,cCliFor,cLoja,nTipoData,aFiliais,cFilQry,lAS400,nMoeda,nMoedaTit,nTxMoeda,dDataTx,lNovoCalc)
	Local aArea     := GetArea()
	Local nValor    := 0
	Local cTipoData := "0"
	Local nX        := 0
	Local cFilSE5	:= xFilial("SE5")
	Local cCpoQry   := ""
	Local cWhere    := ""
	Local nLenFil	:= 0

	Default cFilQry	:= ""
	Default lAS400	:= .T.
	Default aFiliais  := {}
	Default nMoeda    := 1
	Default nMoedaTit := 1
	Default nTxMoeda  := 1
	Default dDataTx   := dDataBase
	Default lNovoCalc := .F.

	//Caso já tenha sido rodado o FIX 11 na base, esta função se torna desnecessária
	If __cMVFinFix   == NIL
		__cMVFinFix := SuperGetMv("MV_FINFIX",.F.,"")
	Endif	

	If lNovoCalc
		If cRecPag == "R"
			aFiliais := GetFlBxSE5( SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_NATUREZ, SE1->E1_FILORIG, "R", 2, __lRelat )
		Else
			aFiliais := GetFlBxSE5( SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ, SE2->E2_FILORIG, "P", 2, __lRelat )
		EndIf
	EndIf

	nLenFil := Len( aFiliais )

	// tratativa para a leitura de aFiliais. Usados nos relatorios do Financeiro
	If (!lNovoCalc .And. nLenFil <= 1) .Or. (lNovoCalc .And. nLenFil == 0)
		Return nValor
	EndIf

	nTipoData  := Iif( nTipoData == Nil, 0, nTipoData )

	//Tipos de Data (cTipoData)
	// 0 = Data Da Baixa (E5_DATA)
	// 1 = Data de Disponibilidade (E5_DTDISPO)
	// 2 = Data de Contabilidação (E5_DTDIGIT)
	If nTipoData == 1
		cTipoData := "0"
	ElseIf nTipodata == 2
		cTipoData := "1"
	Else
		cTipoData := "2"
	Endif

	//Não foi convertido para FKs devido
	//- A stored procedure da saldotit não foi convertida para FKs
	//- Caso não possua stored instalada e rodou os fixes das FKs, essa função não será chamada
	//- Caso não possua stored instalada e não rodou os fixes das FKs, essa função será chamada
	For nX := 1 To nLenFil
		If aFiliais[nX] != cFilSE5
			If !Empty( cFilQry )
				cFilQry += ", "
			Endif
			cFilQry += "'" + aFiliais[nX] + "'"
		Endif
	Next nX

	If Empty(cFilQry)
		cFilQry := "''"
	EndIf

	cQuery  := "SELECT "

	cCpoQry := "R_E_C_N_O_ "
	cCpoQry += "FROM " +RetSqlName("SE5") + " SE5 "

	//Movimentos
	cWhere := "WHERE "
	cWhere += "SE5.E5_FILIAL IN ( " + cFilQry  + " ) AND "
	cWhere += "SE5.E5_PREFIXO = '"  + cPrefixo + "' AND "
	cWhere += "SE5.E5_NUMERO = '"   + cNumero  + "' AND "
	cWhere += "SE5.E5_PARCELA = '"  + cParcela + "' AND "
	cWhere += "SE5.E5_TIPO = '"     + cTipo    + "' AND "
	cWhere += "SE5.E5_CLIFOR = '"   + cCliFor  + "' AND "
	cWhere += "SE5.E5_LOJA = '"     + cLoja    + "' AND "
	cWhere += "SE5.D_E_L_E_T_ = ' ' AND "
	cWhere += "SE5.E5_TIPODOC <> 'ES' AND "

	If cTipo <> "RA "
		cWhere += "SE5.E5_RECPAG = '" + cRecPag + "' AND "
	EndIf
	// Falta tratativa do PA ?? // TODO
	cWhere += "SE5.E5_SEQ NOT IN ("

	//Estorno.
	cWhere += "SELECT EST.E5_SEQ FROM " + RetSqlName("SE5") + " EST "
	cWhere += "WHERE EST.E5_FILIAL IN ( " + cFilQry  + " ) AND "
	cWhere += "EST.E5_PREFIXO = '"  + cPrefixo + "' AND "
	cWhere += "EST.E5_NUMERO = '"   + cNumero  + "' AND "
	cWhere += "EST.E5_PARCELA = '"  + cParcela + "' AND "
	cWhere += "EST.E5_TIPO = '"     + cTipo    + "' AND "
	cWhere += "EST.E5_CLIFOR = '"   + cCliFor  + "' AND "
	cWhere += "EST.E5_LOJA = '"     + cLoja    + "' AND "
	cWhere += "EST.D_E_L_E_T_ = ' ' AND "	
	cWhere += "EST.E5_RECPAG = '" + IIF(cRecPag == "P", "R", "P") + "' AND "
	cWhere += "EST.E5_TIPODOC = 'ES' AND E5_DATA <= '" + DTOS(dDataBase) + "') "

	cQuery  += cCpoQry
	cQuery  += cWhere

	cQuery := ChangeQuery( cQuery )

	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), "TRB", .T., .T. )

	// Se existir compensacao em outras filiais, realiza query completa (performance)
	If TRB->( !EoF() )

		If cRecPag == "R"

			dbSelectArea( "SE1" )

			TRB->( dbCloseArea() )

			cQuery	:= "SELECT "

			cCpoQry	:= "SE5.E5_FILIAL, SE5.E5_TIPODOC, SE5.E5_FILORIG, "
			cCpoQry	+= "SE5.E5_TIPO, SE5.E5_VALOR, SE5.E5_MOTBX, SE5.E5_RECPAG, SE5.E5_SITUACA, "
			cCpoQry	+= "SE5.E5_VLMULTA, SE5.E5_VLJUROS, SE5.E5_VLDESCO, "

			If cTipoData == "0"
				cCpoQry += "SE5.E5_DATA "
			ElseIf cTipoData == "1"
				cCpoQry += "SE5.E5_DTDISPO "
			Else
				cCpoQry += "SE5.E5_DTDIGIT "
			Endif

			cCpoQry  += "FROM " + RetSqlName("SE5") + " SE5, " + RetSqlName("SE1") + " SE1 "

			cWhere  += "AND "
			cWhere  += "SE1.E1_FILIAL = '"  + xFilial("SE1") + "' AND "
			cWhere  += "SE1.E1_PREFIXO = SE5.E5_PREFIXO AND "
			cWhere  += "SE1.E1_NUM = SE5.E5_NUMERO AND "
			cWhere  += "SE1.E1_PARCELA = SE5.E5_PARCELA AND "
			cWhere  += "SE1.E1_TIPO = SE5.E5_TIPO AND "
			cWhere  += "SE1.E1_CLIENTE = SE5.E5_CLIFOR AND "
			cWhere  += "SE1.E1_LOJA = SE5.E5_LOJA AND "
			cWhere  += "SE1.D_E_L_E_T_ = ' ' "

			cQuery  += cCpoQry
			cQuery  += cWhere

			cQuery := ChangeQuery( cQuery )

			dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), "TRB", .T., .T. )
			TCSetField( "TRB", "E5_VALOR", "N", TamSX3("E5_VALOR")[1], TamSX3("E5_VALOR")[2] )

			If cTipoData == "0"
				TCSetField( "TRB", "E5_DATA", "D" )
			ElseIf cTipoData == "1"
				TCSetField( "TRB", "E5_DTDISPO", "D" )
			Else
				TCSetField( "TRB", "E5_DTDIGIT", "D" )
			Endif

			Do While TRB->( !Eof() )

				If TRB->E5_MOTBX $ "CMP|CEC" .And. TRB->E5_FILORIG == cFilSE5 .And. TRB->E5_SITUACA != 'C'

					If cTipoData == "0"
						lOk := ( DtoS(TRB->E5_DATA) <= DtoS(dDataBase) )
					ElseIf cTipoData == "1"
						lOk := ( DtoS(TRB->E5_DTDISPO) <= DtoS(dDataBase) )
					Else
						lOk := ( DtoS(TRB->E5_DTDIGIT) <= DtoS(dDataBase) )
					EndIf

					If lOk
						If TRB->E5_RECPAG == cRecPag
							If TRB->E5_TIPO $ MVRECANT+"|"+MV_CRNEG
								If TRB->E5_TIPODOC $ "BA|VL"
									nValor += TRB->E5_VALOR
								EndIf
							ElseIf (TRB->E5_TIPODOC $ "CP" .Or. (TRB->E5_TIPODOC $ "BA" .And. TRB->E5_MOTBX $ "CMP|CEC")) .Or. TRB->E5_TIPODOC == 'CEC'
								nValor += TRB->E5_VALOR - (TRB->E5_VLMULTA + TRB->E5_VLJUROS - TRB->E5_VLDESCO)
							EndIf
						EndIf
						
						If (TRB->E5_RECPAG == "P" .And. TRB->E5_TIPODOC == "ES")
							nValor -= TRB->E5_VALOR
						ElseIf (cTipo == "RA " .And. TRB->E5_RECPAG == "P" .And. TRB->E5_TIPODOC == "BA")
							nValor += TRB->E5_VALOR
						EndIf
					EndIf
				EndIf
				
				TRB->(dbSkip())
			EndDo
		ElseIf cRecPag == "P"

			dbSelectArea( "SE2" )

			TRB->( dbCloseArea() )

			cQuery	:= "SELECT "

			cCpoQry	:= "SE5.E5_FILIAL, SE5.E5_TIPODOC, SE5.E5_FILORIG, "
			cCpoQry	+= "SE5.E5_TIPO, SE5.E5_VALOR, SE5.E5_MOTBX, SE5.E5_RECPAG, SE5.E5_SITUACA, "
			cCpoQry	+= "SE5.E5_VLMULTA, SE5.E5_VLJUROS, SE5.E5_VLDESCO, SE5.E5_TXMOEDA, SE5.E5_MOEDA, SE5.E5_BANCO, SE5.E5_VLMOED2, SE5.E5_DATA, "

			If cTipoData == "1"
				cCpoQry += "SE5.E5_DTDISPO "
			Else
				cCpoQry += "SE5.E5_DTDIGIT "
			Endif

			cCpoQry  += "FROM " + RetSqlName("SE5") + " SE5, " + RetSqlName("SE2") + " SE2 "

			cWhere  += "AND "
			cWhere  += "SE2.E2_FILIAL = '"  + xFilial("SE2") + "' AND "
			cWhere  += "SE2.E2_PREFIXO = SE5.E5_PREFIXO AND "
			cWhere  += "SE2.E2_NUM = SE5.E5_NUMERO AND "
			cWhere  += "SE2.E2_PARCELA = SE5.E5_PARCELA AND "
			cWhere  += "SE2.E2_TIPO = SE5.E5_TIPO AND "
			cWhere  += "SE2.E2_FORNECE = SE5.E5_CLIFOR AND "
			cWhere  += "SE2.E2_LOJA = SE5.E5_LOJA AND "
			cWhere  += "SE5.E5_MOTBX IN ('CMP', 'CEC') AND "
			cWhere  += "SE5.E5_SITUACA <> 'C' AND "
			cWhere  += "SE2.D_E_L_E_T_ = ' ' AND " 
			cWhere  += "SE5.D_E_L_E_T_ = ' ' "

			cQuery  += cCpoQry
			cQuery  += cWhere
			cQuery := ChangeQuery( cQuery )

			dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), "TRB", .T., .T. )

			TCSetField( "TRB", "E5_VALOR", "N", TamSX3("E5_VALOR")[1], TamSX3("E5_VALOR")[2] )
			TCSetField( "TRB", "E5_DATA", "D" )

			If cTipoData == "1"
				TCSetField( "TRB", "E5_DTDISPO", "D" )
			Else
				TCSetField( "TRB", "E5_DTDIGIT", "D" )
			Endif

			Do While TRB->( !Eof() )
				If TRB->E5_FILORIG == cFilSE5
					If cTipoData == "0"
						lOk := ( DtoS(TRB->E5_DATA) <= DtoS(dDataBase) )
					ElseIf cTipoData == "1"
						lOk := ( DtoS(TRB->E5_DTDISPO) <= DtoS(dDataBase) )
					Else
						lOk := ( DtoS(TRB->E5_DTDIGIT) <= DtoS(dDataBase) )
					EndIf

					If lOk
						If TRB->E5_RECPAG == cRecPag
							If TRB->E5_TIPO $ MVPAGANT+"|"+MV_CPNEG
								If TRB->E5_TIPODOC $ "BA|VL"
									If !lNovoCalc
										nValor += TRB->E5_VALOR
									Else
										nValor += IIF((nMoedaTit < 2.And.cPaisLoc=="BRA").Or. (cPaisLoc <>"BRA" .And. nMoedaTit > 1 .And. (!Empty(TRB->E5_BANCO) .OR. TRB->E5_MOEDA=="0"+cValtoChar(nMoedaTit))),TRB->E5_VALOR,TRB->E5_VLMOED2)
										nValor -= xMoeda(TRB->E5_VLMULTA+TRB->E5_VLJUROS-TRB->E5_VLDESCO,1,nMoedaTit,TRB->E5_DATA,3,,IIF(TRB->E5_TXMOEDA==0,nTxMoeda,TRB->E5_TXMOEDA))
									EndIf
								EndIf
							ElseIf (TRB->E5_TIPODOC $ "CP" .Or. (TRB->E5_TIPODOC $ "BA" .And. TRB->E5_MOTBX $ "CEC")) .Or. TRB->E5_TIPODOC == 'CEC'
								If !lNovoCalc
									nValor += TRB->E5_VALOR
								Else
									nValor += IIF((nMoedaTit < 2.And.cPaisLoc=="BRA").Or. (cPaisLoc <>"BRA" .And. nMoedaTit > 1 .And. (!Empty(TRB->E5_BANCO) .OR. TRB->E5_MOEDA=="0"+cValtoChar(nMoedaTit))),TRB->E5_VALOR,TRB->E5_VLMOED2)
									nValor -= xMoeda(TRB->E5_VLMULTA+TRB->E5_VLJUROS-TRB->E5_VLDESCO,1,nMoedaTit,TRB->E5_DATA,3,,IIF(TRB->E5_TXMOEDA==0,nTxMoeda,TRB->E5_TXMOEDA))
								EndIf
							EndIf
						EndIf
						
						If TRB->E5_RECPAG == "R" .And. TRB->E5_TIPODOC == "ES"
							If !lNovoCalc
								nValor -= TRB->E5_VALOR
							Else
								nValor += IIF((nMoedaTit < 2.And.cPaisLoc=="BRA").Or. (cPaisLoc <>"BRA" .And. nMoedaTit > 1 .And. (!Empty(TRB->E5_BANCO) .OR. TRB->E5_MOEDA=="0"+cValtoChar(nMoedaTit))),TRB->E5_VALOR,TRB->E5_VLMOED2)
								nValor -= xMoeda(TRB->E5_VLMULTA+TRB->E5_VLJUROS-TRB->E5_VLDESCO,1,nMoedaTit,TRB->E5_DATA,3,,IIF(TRB->E5_TXMOEDA==0,nTxMoeda,TRB->E5_TXMOEDA))
							EndIf
						EndIf
					EndIf
				EndIf
				
				TRB->(dbSkip())
			EndDo

			If lNovoCalc
				nValor := Round(NoRound(xMoeda(nValor,nMoedaTit,nMoeda,dDataTx,Msdecimais(nMoeda)+1,nTxMoeda),Msdecimais(nMoeda)+1),Msdecimais(nMoeda))
			EndIf
		EndIf
	EndIf

	dbSelectArea("TRB")
	dbCloseArea()

	RestArea(aArea)

Return nValor


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINRETFIL

Retorna vetor com as filiais da empresa atual (SM0) (FINR130, FINR150, FINR340).
Arquivo original: FINXFUN.PRX


@Author	Gustavo Henrique
@since	16/10/2008
/*/
//-----------------------------------------------------------------------------------------------------
Function FinRetFil()

Local aFiliais 		:= {}
Local nInc			:= 0
Local aSM0			:= AdmAbreSM0()

For nInc := 1 To Len( aSM0 )
	If aSM0[nInc][1] == cEmpAnt
		aAdd( aFiliais, aSM0[nInc][2] )
	EndIf
Next

Return( aFiliais )


//------------------------------------------------------------------------------------------
/*/{Protheus.doc} FUNLOCKDOC

Atualiza o status do arquivo para validação de alias em uso

IMPORTANTE: Estas funções são utilizadas para processamentos multiusuários e que envolvem
a utilização de tabelas temporárias criadas diretamente no banco de dados, para garantir que
as mesmas sejam excluídas no final do processamento dos relatórios/consultas

Arquivo original: FINXFUN.PRX

@author    Marcos Berto
@version   11.80
@since     16/01/13

@param nHandle	- Handle do arquivo
@param cTabTRB	- Tabela

/*/
//------------------------------------------------------------------------------------------
Function FUnlockDoc(nHandle,cStatus)

Default nHandle 	:= 0
Default cStatus	:= ""

FWrite(nHandle,cStatus +Chr(13) + Chr(10))
FClose(nHandle)

Return


//------------------------------------------------------------------------------------------
/*/{Protheus.doc} FTRBAlias

Busca o próximo alias disponível

IMPORTANTE: Estas funções são utilizadas para processamentos multiusuários e que envolvem
a utilização de tabelas temporárias criadas diretamente no banco de dados, para garantir que
as mesmas sejam excluídas no final do processamento dos relatórios/consultas

Arquivo original: FINXFUN.PRX

@author    Marcos Berto
@version   11.80
@since     16/01/13

@param nHandle	- Handle do arquivo

@return lErase 	- Indica se a tabela temporária foi excluída.

/*/
//------------------------------------------------------------------------------------------
Function FTRBAlias()

Local cNextAlias := ""
Local aArea := GetArea()

While .T.
	cNextAlias := GetNextAlias()
	If !TCCanOpen(cNextAlias) .And. Select(cNextAlias) == 0
		Exit
	EndIf
EndDo

RestArea(aArea)

Return cNextAlias


//------------------------------------------------------------------------------------------
/*/{Protheus.doc} FLockDoc

Cria ou abre o arquivo de controle do semáforo

IMPORTANTE: Estas funções são utilizadas para processamentos multiusuários e que envolvem
a utilização de tabelas temporárias criadas diretamente no banco de dados, para garantir que
as mesmas sejam excluídas no final do processamento dos relatórios/consultas


Arquivo original: FINXFUN.PRX


@author    Marcos Berto
@version   11.80
@since     16/01/13

@param cFile	- Arquivo

@return cNomeArq 	- Nome do Arquivo que será gerado

/*/
//------------------------------------------------------------------------------------------
Function FLockDoc(cFile)

Local nHandle := 0

Default cFile := ""

If File(cFile)
	nHandle := FOpen(cFile,2)
Else
	nHandle:= FCreate(cFile)
EndIf

Return nHandle


//------------------------------------------------------------------------------------------
/*/{Protheus.doc} FCloseTRB

Gerencia a exclusao da tabela temporária no banco

IMPORTANTE: Estas funções são utilizadas para processamentos multiusuários e que envolvem
a utilização de tabelas temporárias criadas diretamente no banco de dados, para garantir que
as mesmas sejam excluídas no final do processamento dos relatórios/consultas

Arquivo original: FINXFUN.PRX

@author    Marcos Berto
@version   11.80
@since     16/01/13

@param cFile		- Arquivo de controle do alias.
@param cPrefixo	- Prefixo/Alias

/*/
//------------------------------------------------------------------------------------------
Function FCloseTRB(cFile,cPrefixo)

Local aProc 		:= {}
Local aFiles		:= {}
Local cTabTRB		:= ""
Local cFileName	:= ""
Local cMessage	:= ""
Local cDir  		:= "\Semaforo\"
Local nX			:= 0

Default cFile 	:= ""
Default cPrefixo	:= ""

//Adiciona todos os arquivos que serão processados
If !Empty(cFile)
	aAdd(aProc,cFile)
Else
	//Busca todos os arquivos do mesmo prefixo para exclusão de tabelas que não estão em uso
	aFiles := Directory(cDir+cPrefixo+"*.*")

	For nX := 1 to Len(aFiles)
		aAdd(aProc,cDir+aFiles[nX][1])
	Next nX
EndIf

For nX := 1 to Len(aProc)
	If FT_FUse(aProc[nX]) > 0

		FT_FGoTop()

		While !FT_fEof()
			cMessage := FT_FReadLn()
			FT_FSkip()
		EndDo

		cFileName 	:= RetFileName(aProc[nX])
		cTabTRB	:= SubStr(cFileName,Len(cPrefixo)+1)

		If (AllTrim(cMessage) == "OPEN" .And. TCCanOpen(cTabTRB) .And. Select(cTabTRB) == 0)
			MsErase(cTabTRB,,"TOPCONN")
		ElseIf AllTrim(cMessage) == "CLOSE"
			If Select(cPrefixo) > 0
				dbSelectArea(cPrefixo)
				(cPrefixo)->(dbClearIndex())
				(cPrefixo)->(dbCloseArea())
				MsErase(cTabTRB,,"TOPCONN")
			EndIf)
		EndIf

		//Fecha o arquivo
		FT_FUse()
		FErase(aProc[nX])

	EndIf
Next

Return


//------------------------------------------------------------------------------------------
/*/{Protheus.doc} FPrepDoc

Prepara os dados para criação dos arquivos para controle do semaforo na emissao de
relatórios e consultas

IMPORTANTE: Estas funções são utilizadas para processamentos multiusuários e que envolvem
a utilização de tabelas temporárias criadas diretamente no banco de dados, para garantir que
as mesmas sejam excluídas no final do processamento dos relatórios/consultas

Arquivo original: FINXFUN.PRX

@author    Marcos Berto
@version   11.80
@since     16/01/13

@param cTRBTab	- Tabela temporaria
@param cFilArq	- Filial em que o arquivo esta sendo processado

@return cNomeArq 	- Nome do Arquivo que será gerado

/*/
//------------------------------------------------------------------------------------------
Function FPrepDoc(cAlias,cTRBTab)

Local cDir  		:= "\Semaforo\"
Local cFileName	:= ""

Default cAlias 	:= ""
Default cTRBTab	:= ""

If !ExistDir(cDir)
	MontaDir(cDir)
EndIf

cFileName := cDir+cAlias+cTRBTab+ '.txt'

Return cFileName


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} VERIDPROC

Identifica a sequencia de controle do fonte ADVPL com a stored procedure, qualquer alteracao que envolva
diretamente a stored procedure a variavel sera incrementada. Procedure FIN002  (Ligada a SALDOTIT).
Arquivo original: FINXFUN.PRX

@Author	Marcelo Pimentel
@since	24/07/2007
/*/
//-----------------------------------------------------------------------------------------------------

Static Function VerIDProc()
Return '015'


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SALDOTIT

Retorna saldo retroativo do titulo em uma determinada data (com procedure).
Arquivo original: FINXFUN.PRX

@param cPrefixo   - Numero do Prefixo
@param cNumero    - Numero do Titulo
@param cParcela   - Parcela
@param cTipo      - Tipo
@param cNatureza  - Natureza
@param cCart      - Carteira  (R/P)
@param cCliFor    - Fornecedor(se cCart = 'R')
@param nMoeda     - Moeda
@param dData      - Data para conversao
@param dDataBaixa - Data data baixa a ser considerada (retroativa)
@param cLOja      - Loja do titulo
@param cFilTit    - Filial do titulo
@param nTxMoeda   - Taxa da Moeda
@param nTipoData  - Tipo de data para compor saldo (baixa/dispo/digit)
@param lIsTxContr - Define se a taxa contratada é taxa contratada

@Author	Vicente Sementilli
@since	05/08/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function SaldoTit(cPrefixo,cNumero,cParcela,cTipo,cNatureza,cCart,cCliFor,nMoeda,;
						dData,dDataBaixa,cLoja,cFilTit,nTxMoeda,nTipoData,lFinR,__oTBxCanc,lIsTxContr, lCmpMulFil)
//Tipos de Data (cTipoData ou xTipoData)
// 0 = Data Da Baixa (E5_DATA) (Default)
// 1 = Data de Disponibilidade (E5_DTDISPO)
// 2 = Data de Contabilidação (E5_DTDIGIT)

Local cErrStrPr		:= ""
Local nSaldo		:= 0
Local nVa			:= 0
Local cTipoData		:= "0"
Local cFiliOrig		:= ""
Local cIdDoc		:= ""
Local cAliasTit
Local lIRPFBaixa 	:= IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)
Local cIssBx 		:= ""
Local cIrfBx    	:= Iif(lIRPFBaixa,"1","0")
Local cPCCBaixa		:= ""
Local cAdiant		:= Iif( (cTipo $ MVRECANT+"/"+MVPAGANT+"/"+MV_CRNEG+"/"+MV_CPNEG), "1","0")
Local cFilialSE 	:= ""
Local aAreaAnt		:= {}

If __lTemFK6 == NIL
	__lTemFK6	:= ExistFunc('FxLoadFK6')
Endif
	
If __nMoeda == NIL .or. __nMoeda <> nMoeda
	__nMoeda := nMoeda
	__nDecs  := Msdecimais(nMoeda)
Endif	

If (__cUltFil == NIL) .or. !(__cUltEmp+__cUltFil == cEmpAnt+cFilAnt )
	__cUltEmp := cEmpAnt
	__cUltFil := cFilAnt

	__lPccBx	:= SuperGetMv("MV_BX10925",.T.,"2") == "1"
	__IssBx		:= SuperGetMv("MV_MRETISS",.T.,"2") == "2"
	__cProc 	:= GetSPName("FIN002","10")
	
Endif

If type("ltxZero") == "U"
	ltxZero   := .F.	
Else
	Default ltxZero   := .F.
Endif

cIssBx 	:= Iif(__IssBx,"1","0")
cPCCBaixa	:= Iif(__lPccBx,"1","0")

Default cFilTit		:= Iif(cFilTit == Nil,xFilial("SE5"),cFilTit)
Default nTxMoeda	:= 0
Default __lPFIN002	:= ExistProc( __cProc, VerIDProc() )
Default lFinR		:= FwIsInCallStack("FINR350")
Default lIsTxContr	:= .F.		// Define se a taxa passada é taxa contratada
Default lCmpMulFil  := .F.

dDataBaixa  := Iif( dDataBaixa == Nil , dDataBase, dDataBaixa )
dData       := Iif( dData      == Nil , dDataBase, dData )
nMoeda      := Iif( nMoeda     == Nil , 1        , nMoeda )
cLoja       := Iif( cLoja      == Nil , Iif( cCart == "R" , SE1->E1_LOJA , SE2->E2_LOJA ) , cLoja )
nTipoData   := Iif( nTipoData  == Nil , 1 , nTipoData )

If nTipoData == 1
	cTipoData := "0"  // E5_DATA
ElseIf nTipodata == 2
	cTipoData := "1"  // E5_DTDISPO
Else
	cTipoData := "2"  // E5_DTDIGIT
Endif

If __lTemFKD == NIL
	__lTemFKD	:= TableInDic("FKD")
Endif

If __lPFin002 .and. !lFinR
	aResult    := {}
	lCmpMulFil := .T.	
	cCliFor    := Iif(cCliFor = NIL, Iif(cCart == "R", SE1->E1_CLIENTE, SE2->E2_FORNECE), cCliFor)
	cLoja      := Iif(cLoja   = NIL, Iif(cCart == "R", SE1->E1_LOJA, SE2->E2_LOJA), cLoja)
	
	If cCart = "R"
		cAliasTit := "SE1"
		dbSelectArea("SE1")
		nSaldo    := (SE1->(E1_VALOR+E1_ACRESC) - SE1->E1_DECRESC)
		nMoedaTit := SE1->E1_MOEDA
		cCliFor   := Iif(Empty(cCliFor),SE1->E1_CLIENTE,cCliFor)
		cLoja     := Iif(Empty(cLoja  ),SE1->E1_LOJA,cLoja)
		cFiliOrig := SE1->E1_FILORIG
		cFilialSE := SE1->E1_FILIAL
		cIdDoc 	  := FINGRVFK7("SE1",;
							cFilialSE +"|"+ cPrefixo +"|"+ cNumero +"|"+;
					 		cParcela  +"|"+ cTipo +"|"+ cCliFor +"|"+ cLoja)

	Else
		cAliasTit := "SE2"
		dbSelectArea("SE2")
		nSaldo    := (SE2->(E2_VALOR + E2_ACRESC) - SE2->E2_DECRESC)
		nMoedaTit := SE2->E2_MOEDA
		cFiliOrig := SE2->E2_FILORIG
		cFilialSE := SE2->E2_FILIAL

		cIdDoc 	  := FINGRVFK7("SE2",;
							cFilialSE +"|"+ cPrefixo +"|"+ cNumero +"|"+;
					 		cParcela  +"|"+ cTipo +"|"+ cCliFor +"|"+ cLoja)
	Endif

	nMoeda    := ((nMoeda+1.00)-1.00)
	nMoedaTit := ((nMoedaTit+1.00)-1.00)

	aResult := TcSpExec( xProcedures(__cProc),;
			cPrefixo,                cNumero,;
			cParcela,                cTipo,;
			cCliFor,                 DTOS(dData),;
			DTOS(dDataBaixa),        cLoja,;
			DTOS(dDataBase),         cFilTit,;
			nSaldo,                  nMoedaTit,;
			cPaisLoc,                cTipoData,;
			cPCCBaixa,               cCart, cAdiant, cIrfBx, nTxMoeda, cIssBx, cFiliOrig )

	If aResult == Nil
		cErrStrPr := TcSqlError()
		Final( STR0089 + Iif( !Empty( cErrStrPr ) , cErrStrPr , "" ) )
	Endif

	nSaldo := aResult[1]

	// Zera o Saldo devido problema de arredondamento nos juros, ou seja, o valor dos juros que eh gravado com
	// 2 casas decimais, gera diferena na recomposicao do saldo no titulo
	// Exemplo: Titulo com valor de 24.450, com E1_PORCJUR de 0.13 e tres dias de atraso, grava em E5_JUROS o valor
	// de 95.36, sendo que o valor dos juros seria 95.355
	// Movimentacao no SE5:
	//	      Baixa	Juros	       Saldo
	//		 		            24.450,00
	//-------------------------------
	//		4.001,04	95,36 	20.544,32 3 dias apos vencto.
	//		2.100,95		      18.443,37 mesma data
	//		3.474,23		      14.969,14 mesma data
	//		6.000,00		       8.969,14 5 dias apos vencto
	//		5.060,00		       3.909,14 10 dias apos vencto
	//		3.919,29	10,16	        0,01 12 dias apos vencto
	If Empty((cAliasTit)->&(Right(cAliasTit,2)+"_SALDO")) .And. nSaldo <= 0.009
		nSaldo := 0
	Else
		If nMoeda <> nMoedaTit .AND. !lIsTxContr .AND. RecMoeda(dData,nMoedaTit) == 0
			ltxZero  := .T.
		Endif
		nSaldo := Round(NoRound(xMoeda(nSaldo,nMoedaTit,nMoeda,dData,__nDecs+1,nTxMoeda),__nDecs+1),__nDecs)
	EndIf

	If __lTemFKD .and. Select("FKD") == 0
		aAreaAnt := GetArea()
		dbSelectArea("FKD")
	EndIf

	//Valores Acessorios do titulo
	FKD->(dbSetOrder(2))	//FILIAL+IDDOC
	If !Empty(cIdDoc) .and. FKD->(dbSeek( cFilTit+cIdDoc ) )
		If __cRelease == Nil .Or. __lTCGQry2 == Nil
			__cRelease := GetRPORelease()
			__lTCGQry2 := FindFunction("TCGenQry2")
		EndIf

		If __cRelease > "12.1.017" .and. __lTCGQry2
			nVa := FinSomaFK6(cFilTit, cIdDoc, cCart, dDataBaixa, cTipoData, cAdiant, dDataBase, cFiliOrig, nMoedaTit, nTxMoeda)
		Else
			nVa := FinFK6V2(cFilTit, cIdDoc, cCart, dDataBaixa, cTipoData, cAdiant, dDataBase, cFiliOrig, nMoedaTit, nTxMoeda)
		EndIf

		nSaldo += nVa
	EndIf

	If !Empty(aAreaAnt)
		RestArea(aAreaAnt)
	EndIf

	Return (nSaldo)
Else
	Return xSaldoTit(@cPrefixo,@cNumero,@cParcela,@cTipo,@cNatureza,@cCart,@cCliFor,@nMoeda,;
		@dData,@dDataBaixa,@cLoja,@cFilTit,nTxMoeda,nTipoData,__oTBxCanc,lIsTxContr,@lCmpMulFil)
Endif


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} XSALDOTIT

Retorna sado retroativo do titulo em uma determinada data (sem procedure).
Arquivo original: FINXFUN.PRX

@param cPrefixo   - Numero do Prefixo
@param cNumero    - Numero do Titulo
@param cParcela   - Parcela
@param cTipo      - Tipo
@param cNatureza  - Natureza
@param cCart      - Carteira  (R/P)
@param cCliFor    - Fornecedor(se cCart = 'R')
@param nMoeda     - Moeda
@param dData      - Data para conversao
@param dDataBaixa - Data data baixa a ser considerada (retroativa)
@param cLOja      - Loja do titulo
@param cFilTit    - Filial do titulo
@param nTxMoeda   - Taxa da Moeda
@param nTipoData  - Tipo de data para compor saldo (baixa/dispo/digit)
@param lIsTxContr - Define se a taxa contratada é taxa contratada

@Author	Vicente Sementilli
@since	05/08/1998
/*/
//-----------------------------------------------------------------------------------------------------

Function xSaldoTit(cPrefixo,cNumero,cParcela,cTipo,cNatureza,cCart,cCliFor,nMoeda,;
							 dData,dDataBaixa,cLoja,cFilTit,nTxMoeda,nTipoData,__oTBxCanc,lIsTxContr, lCmpMulFil)

//Tipos de Data (cTipoData)
// 0 = Data Da Baixa (E5_DATA)
// 1 = Data de Disponibilidade (E5_DTDISPO)
// 2 = Data de Contabilidação (E5_DTDIGIT)
Local cAlias		:= Alias()
Local nSaldo		:= 0
Local dDataMoeda
Local nMoedaTit
Local cCarteira
Local dDtFina
Local cAliasTit
Local cFOrigE1		:= ""
//Controla o Pis Cofins e Csll na baixa
Local aFilBaixa 	:= {}
Local aRelat		:= {}
Local lRelat		:= .F.
Local lConsult		:= FwIsInCallStack("Fc040Con")
Local lFinR130		:= FwIsInCallStack("FINR130") .or. FunName() $ "FINR130" //FunName para não quebrar o Robo
Local lFinR150		:= FwIsInCallStack("FINR150") .or. FunName() $ "FINR150" //FunName para não quebrar o Robo
Local lFinR350		:= FwIsInCallStack("FINR350")
Local lFinR13H		:= FwIsInCallStack("FINR13H")
Local lFinR340		:= FwIsInCallStack("FINR340") .or. FunName() $ "FINR340"
Local nI            := 0
Local lMovM2        := .F.
Local lIRPFBaixa	:= IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)
Local cFilSE5		:= ""
Local cTabOri		:= ""
Local cTipoDocs		:= Iif(cPaisLoc=="ARG" .AND. lFinR13H, "VL|BA|V2|CP|LJ|DC","VL|BA|V2|CP|LJ")

If type("ltxZero") == "U"
	ltxZero   := .F.	
Else
	Default ltxZero   := .F.
Endif

AADD(aRelat,"FINR150")
AADD(aRelat,"FINR130")
AADD(aRelat,"FINR340")

Default nTxMoeda  	:= 0
Default lIsTxContr	:= .F.

//Verifica se Relatórios estão na Pilha //
For nI := 1 To Len(aRelat)
	If FwIsInCallStack(aRelat[nI])
		lRelat:=.t.
		exit
	EndIf
Next nI

cCliFor    := Iif( cCliFor=NIL,Iif(cCart=="R",SE1->E1_CLIENTE,SE2->E2_FORNECE),cCliFor )
cLoja      := Iif( cLoja  =NIL,Iif(cCart=="R",SE1->E1_LOJA   ,SE2->E2_LOJA   ),cLoja   )
nMoeda     := IIF( nMoeda==NIL,1,nMoeda )
dDataMoeda := IIF( dData==NIL,dDataBase,dData )
dDataBaixa := IIF( dDataBaixa==NIL,dDataBase,dDataBaixa )
nTipoData  := IIF( nTipoData  ==nil, 0 , nTipoData )
lCmpMulFil := .T.

If nTipoData == 1
	cTipoData := "0"  // E5_DATA
ElseIf nTipodata == 2
	cTipoData := "1"  // E5_DTDISPO
Else
	cTipoData := "2"  // E5_DTDIGIT
Endif

// cFiltit somente e' usado no caso de relatorios que podem ser tirados
// por empresa (opcional)
cFilTit := Iif(cFilTit==Nil,xFilial("SE5"),cFilTit)

If __cMVFinFix   == NIL
	__cMVFinFix := SuperGetMv("MV_FINFIX",.F.,"")
Endif

dbSelectArea("SE5")
If Empty( xFilial() )
	cFilTit := Space( FWGETTAMFILIAL)
Endif

If cCart = "R"
	cAliasTit := "SE1"
	dbSelectArea("SE1")
	If lConsult
		nSaldo := SE1->E1_VALOR
	Else
   		nSaldo := SE1->E1_VALOR+SE1->E1_ACRESC-SE1->E1_DECRESC
	EndIf
	nMoedaTit := SE1->E1_MOEDA
	cCliFor   := Iif(Empty(cCliFor),SE1->E1_CLIENTE,cCliFor)
	cLoja     := Iif(Empty(cLoja  ),SE1->E1_LOJA,cLoja)
	cFilSE1   := xFilial("SE1")
	cFOrigE1  := SE1->E1_FILORIG

	If AllTrim(SE1->E1_TIPO) $ MVRECANT + "|" + MV_CRNEG .AND. !(lFinR130 .and. __cMVFinFix >= "20")// Contem todos os tipos que podem ser compensa‡?o
		aFilBaixa :=  GetFlBxSE5( SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_NATUREZ, SE1->E1_FILORIG, cCart, 2, __lRelat )
	ElseIf cPaisLoc $ "ARG|MEX" // Busca filial da baixa do t¡tulo para localizado Argentina ou M‚xico no caso da baixa ser realizada em filial diferente das inclus?o
		aFilBaixa :=  GetFlBxSE5( SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_NATUREZ, SE1->E1_FILORIG, cCart, 1, __lRelat )
	EndIf
Else
	cAliasTit := "SE2"
	dbSelectArea("SE2")
	nSaldo    := SE2->E2_VALOR+SE2->E2_ACRESC-SE2->E2_DECRESC
	nMoedaTit := SE2->E2_MOEDA
	cFilSE2   := xFilial("SE2")

	If AllTrim(SE2->E2_TIPO) $ MVPAGANT + "|" + MV_CPNEG // Contem todos os tipos que podem ser compensa‡?o
		aFilBaixa := GetFlBxSE5(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ, SE2->E2_FILORIG, cCart, 2, __lRelat )
	Endif
Endif

If Empty(aFilBaixa)
	aAdd(aFilBaixa,cFilTit)
EndIf

If (lFinR130 .OR. lFinR150) .and. __cMVFinFix >= "20"
	nSaldo := SldTitFK (cPrefixo,cNumero,cParcela,cTipo,cNatureza,cCliFor,nMoedaTit,dData,dDataBaixa,;
						cLoja,cFilTit,nTxMoeda,cTipoData,@lCmpMulFil,nSaldo, cCart )

	If nSaldo <= 0.009
		nSaldo := 0
	Endif
Else
	If Select("__BAIXA") == 0
		ChkFile("SE5",.F.,"__BAIXA")
	Else
		dbSelectArea("__BAIXA")
	EndIf

	cFilSE5 := FWxFilial("SE5")

	dbSetOrder(7)
	For nI := 1 To Len(aFilBaixa)
		cFilTit := aFilBaixa[nI]

		dbSeek(cFilTit+cPrefixo+cNumero+cParcela+cTipo)

		While !__BAIXA->(EOF()) .and. __BAIXA->(E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO) == cFilTit + cPrefixo + cNumero + cParcela + cTipo		
			SE5->(DbGoTo(__BAIXA->(Recno()))) //Posicionar o SE5 pois dentro da TEMBXCANC condulta o SE5 e nao o __BAIXA
			
			IF AllTrim(SE5->E5_SITUACA) == "C" .AND. IF(EMPTY(SE5->E5_DTCANBX), .T., SE5->E5_DTCANBX <= dDataBaixa)
				__BAIXA->(dbSkip())
				Loop
			Endif

			IF !(SE5->E5_TIPODOC $ cTipoDocs)
				__BAIXA->(dbSkip())
				Loop
			Endif

			If TemBxCanc(SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO+SE5->E5_CLIFOR+SE5->E5_LOJA+SE5->E5_SEQ,,SE5->E5_FILIAL,__oTBxCanc)
				__BAIXA->(dbskip())
				Loop
			EndIf

			// se a origem da Baixa é do SIGALOJA e TipoDoc for VL , não usa na composicao do Saldo a receber
			IF AllTrim(SE5->E5_ORIGEM) == 'LOJXREC' .AND. SE5->E5_TIPODOC $ "VL" 
				__BAIXA->(dbskip())
				Loop
			EndIf
			
			cCarteira := cCart
			
			If cCart == "R" 
				If (SE5->E5_TIPO $ MVRECANT + "/" + MV_CRNEG).and. SE5->E5_TIPODOC $ "BA|VL|MT|JR|CM" ;
						.and. Empty(SE5->E5_DOCUMEN) .and. IIF(!(MovBcoBx(SE5->E5_MOTBX)), .T. , !Empty(E5_BANCO) )
					cCarteira := "P"        //Baixa de adiantamento (inverte)
					cLoja     := SE1->E1_LOJA
				Endif
			Endif

			//TRATAMENTO PARA MVPAGANT ou MVCPNEG COMPENSADO ENTRE CARTEIRAS
			If lFinR350 .And. dDatabase >= SE5->E5_DATA .And. ALLTRIM(SE5->E5_TIPO) $ MVPAGANT+"/"+MV_CPNEG .And. SE5->E5_MOTBX $ "CEC" .And. SE5->E5_TIPODOC == "BA"
				nSaldo -= SE5->E5_VALOR
			Endif

			If cCart == "R" .AND. !Empty(SE5->E5_FILORIG) .And. cFOrigE1 <> SE5->E5_FILORIG
				__BAIXA->(dbskip())
				Loop
			EndIf

			If cCart == "P" .AND. SE5->E5_TIPO $ MVPAGANT .and. (Alltrim(SE5->E5_ORIGEM) == 'FINA050')	
				__BAIXA->(dbskip())
				Loop
			Endif

			//Tratamento para NDF's baixadas pela rotina de Faturas (FINA290)
			If lFinR350 .AND. AllTrim(E5_TIPO) $ MV_CPNEG .AND. AllTrim(E5_MOTBX) == "FAT" .AND. AllTrim(E5_TIPODOC) == "BA"
				nSaldo -= E5_VALOR
			EndIf

			If cCart == "P"
				If (SE5->E5_TIPO $ MVPAGANT+"/"+MV_CPNEG).and. SE5->E5_TIPODOC $ "BA|VL|MT|JR|CM" .and. ;
						SE5->E5_RECPAG =='R' .and. IIF(!(MovBcoBx(SE5->E5_MOTBX)), .T. , !Empty(SE5->E5_BANCO) )
					cCarteira := "R"        //Baixa de adiantamento (inverte)
				Endif
			Endif

			// Colocado este tratamento para conseguir compor o saldo no relatório de titulos a receber. Antes do Tratamento, fazia skip e ignorava o registro nos relatórios
			If !lRelat .Or. (lRelat .And. !Empty(SE5->E5_NUMCHEQ))
				IF (cCarteira == "P" .and. SE5->E5_RECPAG == "R") .or. (cCarteira == "R" .and. SE5->E5_RECPAG == "P")
					__BAIXA->(dbskip())
					Loop
				Endif
			EndIf

			IF cCliFor + cLoja  != SE5->(E5_CLIFOR + E5_LOJA)
				__BAIXA->(dbskip())
				Loop
			EndIF

			// Tratamento para diferenciar títulos com a mesma chave e filiais diferentes com SE5 compartilhado
			If Empty( cFilSE5) .And. Iif( cCart == "R", ! Empty( cFilSE1), ! Empty( cFilSE2) )
				If SE5->E5_FILORIG <> Iif( cCart == "R", cFilSE1, cFilSE2 )
					__BAIXA->(dbskip())
					Loop
				EndIf
			EndIf
			
			//Defino qual o tipo de data a ser utilizado para compor o saldo do titulo
			If cTipoData == "0"
				dDtFina := SE5->E5_DATA
			ElseIf cTipoData == "1"
				dDtFina := SE5->E5_DTDISPO
			Else
				dDtFina := SE5->E5_DTDIGIT
			Endif
			
			IF dDtFina <= dDataBaixa
				IF SE5->E5_TIPODOC $ cTipoDocs
					lCmpMulFil := .F.
					lMovM2 := SE5->E5_MOTBX == "CMP" .And. MovMoedEs(SE5->E5_MOEDA, SE5->E5_TIPODOC, SE5->E5_MOTBX, DTOS(dDtFina), SE5->E5_RECPAG)

					If	(lFinR130 .And. SE5->E5_RECPAG == "R") .Or. (lFinR130 .And. SE5->E5_RECPAG == "P" .And. SE5->E5_TIPO $ MVRECANT+"/"+MV_CRNEG ) .Or.;
						(lFinR150 .And. SE5->E5_RECPAG == "P" .And. cCarteira # "R") .Or. (lFinR150 .And. SE5->E5_RECPAG == "R" .And. SE5->E5_TIPO $ MVPAGANT+"/"+MV_CPNEG ) .Or. ;
						(lFinR130 .And. SE5->E5_RECPAG == "P" .And. SE5->E5_TIPO $ MVRECANT+"/"+MV_CRNEG )
						
						If SE5->E5_MOTBX =="CMP"
							nSaldo -= IIF((nMoedaTit < 2.And.cPaisLoc=="BRA").Or. (cPaisLoc <>"BRA" .And. nMoedaTit > 1 .And. (!Empty(SE5->E5_BANCO) .OR. SE5->E5_MOEDA=="0"+cValtoChar(nMoedaTit))),SE5->E5_VALOR,IIF(cPaisLoc=="BRA",IIF(lMovM2,SE5->E5_VALOR,SE5->E5_VLMOED2),SE5->E5_VALOR))
							nSaldo += Round(NoRound(xMoeda(SE5->E5_VLMULTA + SE5->(E5_VLJUROS-E5_VLACRES) - SE5->(E5_VLDESCO-E5_VLDECRE),1,nMoedaTit,SE5->E5_DATA,3,,IIF(SE5->E5_TXMOEDA==0,nTxMoeda,SE5->E5_TXMOEDA)),3),2)
						ElseiF VAL(SE5->E5_MOEDA) < 2
							nSaldo -= IIF((nMoedaTit < 2.And.cPaisLoc=="BRA").Or. (cPaisLoc <>"BRA" .And. nMoedaTit > 1 .And. (!Empty(SE5->E5_BANCO) .OR. SE5->E5_MOEDA=="0"+cValtoChar(nMoedaTit))),SE5->E5_VALOR,SE5->E5_VLMOED2)
							nSaldo += Round(NoRound(xMoeda(SE5->E5_VLMULTA + SE5->(E5_VLJUROS-E5_VLACRES) - SE5->(E5_VLDESCO-E5_VLDECRE),1,nMoedaTit,SE5->E5_DATA,3,,IIF(SE5->E5_TXMOEDA==0,nTxMoeda,SE5->E5_TXMOEDA)),3),2)
						Else //para moeda estrangeira os valores na se5 estão na moeda do banco, mesma moeda da nSaldo
							nSaldo -= IIF((nMoedaTit < 2.And.cPaisLoc=="BRA").Or. (cPaisLoc <>"BRA" .And. nMoedaTit > 1 .And. (!Empty(SE5->E5_BANCO) .OR. SE5->E5_MOEDA=="0"+cValtoChar(nMoedaTit))),SE5->E5_VALOR,SE5->E5_VLMOED2)
							nSaldo += SE5->E5_VLMULTA + SE5->(E5_VLJUROS-E5_VLACRES) - SE5->(E5_VLDESCO-E5_VLDECRE)
						EndIf
					ElseIf !lFinR150 .And. !lFinR130
						If (cPaisLoc == "RUS" .Or. (cPaisLoc $ "MEX|PER|COL" .And. lFinR340)) .And. nMoedaTit > 1 .And. SE5->E5_MOEDA == '01' // Valid only in Russia|Valido somente para russia
							nSaldo -= SE5->E5_VLMOED2
						ELSE				
							If lMovM2
								nSaldo -= SE5->E5_VALOR
							Else
								If cPaisLoc $ 'MEX|COL|PER|PAR' .AND.  cTipo ==  PADR("RA",TamSx3("E1_TIPO")[1]) .AND.  nMoedaTit < 2 .And. val(SE5->E5_MOEDA) > 1 
									nSaldo -= xMoeda(SE5->E5_VLMOED2 + SE5->E5_VLDESCO - SE5->E5_VLACRES,vAL(SE5->E5_MOEDA),nMoedaTit,SE5->E5_DATA, TamSx3("E1_TXMOEDA")[2],,nTxMoeda  )
								Else
									If  cPaisLoc == "ARG"
										If  ( nMoedaTit <> 1 )  .OR. (nMoedaTit == 1 .and. !(SE5->E5_TIPODOC $ "DC"))							  
											nSaldo -= If(nMoedaTit > 1 .And. !Empty(SE5->(E5_BANCO+E5_ORDREC)), SE5->E5_VALOR, SE5->E5_VLMOED2 + SE5->E5_VLDESCO - SE5->E5_VLACRES)
										Endif
									Else									
										nSaldo -= If((nMoedaTit < 2 .And. cPaisLoc == "BRA") .Or. (!(cPaisLoc $ "BRA|MEX") .And. nMoedaTit > 1 .And. !Empty(SE5->(E5_BANCO+E5_ORDREC))), SE5->E5_VALOR, SE5->E5_VLMOED2 + SE5->E5_VLDESCO - SE5->E5_VLACRES)
									EndIf
								Endif
							EndIf
						ENDIF					
						
						If !lFinR13H
							nSaldo += Round(NoRound(xMoeda(SE5->E5_VLMULTA+SE5->(E5_VLJUROS-E5_VLACRES)-SE5->(E5_VLDESCO-E5_VLDECRE),1,nMoedaTit,SE5->E5_DATA,3,,IIF(SE5->E5_TXMOEDA==0,nTxMoeda,SE5->E5_TXMOEDA)),3),2)
						EndIf
						
					EndIf
					//Retencao de impostos na baixa
					If __lPccBx .and. cCarteira == "P" .and. SE5->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSLL) > 0   .and. !(SE5->E5_MOTBX == "PCC")				
						nSaldo -= Round(NoRound(xMoeda(SE5->E5_VRETPIS+SE5->E5_VRETCOF+SE5->E5_VRETCSLL,1,nMoedaTit,SE5->E5_DATA,3,,IIF(SE5->E5_TXMOEDA==0,nTxMoeda,SE5->E5_TXMOEDA)),3),2)
					Endif

					//Retenção de Irrf na baixa 
					If lIRPFBaixa .and. cCarteira == "P" .and. Empty(SE5->E5_PRETIRF) .and. !(SE5->E5_MOTBX == "IRF")
						nSaldo -= Round(NoRound(xMoeda(SE5->E5_VRETIRF,1,nMoedaTit,SE5->E5_DATA,3,,IIF(SE5->E5_TXMOEDA==0,nTxMoeda,SE5->E5_TXMOEDA)),3),2)	 	
					Endif
						
					//Retenção de ISS na baixa 
					If __IssBx .and. cCarteira == "P" 
						nSaldo -= Round(NoRound(xMoeda(E5_VRETISS,1,nMoedaTit,E5_DATA,3,,IIF(E5_TXMOEDA==0,nTxMoeda,E5_TXMOEDA)),3),2) 	
					Endif
						
					If (lFinR350 .Or. lFinR150) .And. cCarteira == "P"
						nSaldo -= Round(NoRound(xMoeda(E5_VRETISS,1,nMoedaTit,E5_DATA,3,,IIF(E5_TXMOEDA==0,nTxMoeda,E5_TXMOEDA)),3),2)
					EndIf

					//Valores Acessorios
					cTabOri := IIf(SE5->E5_RECPAG == "P", "FK2", "FK1")
					nVA		:= IIf(__lTemFK6, FxLoadFK6(cTabOri, SE5->E5_IDORIG, "VA")[1][2], 0) //Pego o valor Informado
					nVA := Round(NoRound(xMoeda(nVA,1,nMoedaTit,SE5->E5_DATA,3,,IIF(SE5->E5_TXMOEDA==0,nTxMoeda,SE5->E5_TXMOEDA)),3),2)
					nSaldo += nVA

					If nSaldo <= 0.009
						nSaldo := 0
					Endif
				Endif
			EndIF
			__BAIXA->(dbSkip())
		Enddo
	Next nI
EndIf

// Zera o Saldo devido problema de arredondamento nos juros, ou seja, o valor dos juros que eh gravado com
// 2 casas decimais, gera diferena na recomposicao do saldo no titulo
// Exemplo: Titulo com valor de 24.450, com E1_PORCJUR de 0.13 e tres dias de atraso, grava em SE5->E5_JUROS o valor
// de 95.36, sendo que o valor dos juros seria 95.355
// Movimentacao no SE5:
//	      Baixa	Juros	       Saldo
//		 		            24.450,00
//-------------------------------
//		4.001,04	95,36 	20.544,32 3 dias apos vencto.
//		2.100,95		      18.443,37 mesma data
//		3.474,23		      14.969,14 mesma data
//		6.000,00		       8.969,14 5 dias apos vencto
//		5.060,00		       3.909,14 10 dias apos vencto
//		3.919,29	10,16	        0,01 12 dias apos vencto
If Empty((cAliasTit)->&(Right(cAliasTit,2)+"_SALDO")) .And. Abs(nSaldo) <= 0.009
	nSaldo := 0
Else
	If nMoeda <> nMoedaTit .AND. !lIsTxContr .AND. RecMoeda(dData,nMoedaTit) == 0
		ltxZero  := .T.
	Endif
	
	nSaldo := Round(NoRound(xMoeda(nSaldo,nMoedaTit,nMoeda,dData,__nDecs+1,nTxMoeda),__nDecs+1),__nDecs)
Endif
If !Empty(cAlias)
	dbSelectArea(cAlias)
EndIf

Return ( nSaldo )


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FXIBAN

Atualiza campos de memória com o calculo do digito verificador de conta corrente (A6_DV)
Arquivo original: FINXFUN.PRX

@param cCod: numero do banco (A6_COD)
@param cAgencia: numero da agencia (A6_AGENCIA)
@param cNumCon: numero da conta (A6_NUMCON)

@Author	Edvin Zimmermann
@since	09/11/2009
/*/
//-----------------------------------------------------------------------------------------------------
Function fxIBAN( cCod, cAgencia, cNumCon )

	Local cNum := ""
	Local cIBAN := ""

	if !( empty(cCod) .or. empty(cAgencia)  .or. empty(cNumCon) )
		cIBAN := cCod + cAgencia + cNumCon
		cNum := FINMod9710(@cIBAN)
		If cPaisLoc $ "ANG|EQU|HAI"
			M->A6_DV := cNum
		EndIf
		M->A6_IBAN := cIBAN
	endIf

Return .t.


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINMOD9710

Calculo do digito verificador de conta corrente (A6_DV e A6_IBAN)
Arquivo original: FINXFUN.PRX

@param cNum: Numero a ser calculado.Pode conter caracteres de "0" a "9" e de "A" a "Z". Se passado por referencia, eh atualizado com os digitos verificadores

@Author	TOTVS
@since	09/11/2009
/*/
//-----------------------------------------------------------------------------------------------------
Function FINMod9710(cNum)

	Local nX, nY
	Local nTot := 0
	Local cAux
	Local nNum
	Local cRet
	Local cNumAux
	Local aW := {1, 10, 3, 30, 9, 90, 27, 76, 81, 34, 49, 5, 50, 15, 53, 45, 62, 38, 89, 17, 73, 51, 25, 56, 75, 71, 31, 19, 93, 57, 85, 74, 61, 28, 86, 84, 64, 58, 95, 77, 91, 37, 79, 14, 43, 42, 32, 29, 96, 87, 94, 67, 88, 7, 70, 21, 16, 63, 48, 92, 47, 82, 44, 52, 35, 59, 8, 80, 24, 46, 72, 41, 22, 26, 66, 78, 4, 40, 12, 23, 36, 69, 11, 13, 33, 39, 2, 20, 6, 60, 18, 83, 54, 55, 65, 68} // Os pesos já foram calculados usando a fórmula aW[i] = mod( 10^(i-1), 97) para melhoria de performance. A partir da posição 97 a seqüência se repete

	cNum := Alltrim(Upper(cNum))
	cNumAux := ""

	nX := len(cNum)
	nY := mod(nX, 97) + 1
	Do While nX >= 3
		cAux := subs(cNum, nX, 1)
		If cAux >= "0" .and. cAux <= "9"
			nNum := val(cAux)
			cNumAux := cNumAux +cAux
		ElseIf cAux >= "A" .and. cAux <= "Z"
			nNum := ASC(cAux) - 55
			cNumAux := cNumAux + cAux
		Else
			nNum := 0
			cNumAux := cNumAux +"0"
		EndIf
		nTot := nTot + ( nNum * aW[nY])
		nX := nX - 1
		If nY > 1
			nY := nY - 1
		Else
			nY := 98
		EndIf
	Enddo

	nTot := mod(nTot, 97)
	nTot := 98 - nTot
	cRet := strzero(nTot, 2)
	cNum := cNumAux + cRet

Return cRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINVLDNAT

Valida a natureza  (utilizado em vários fontes e campos).
Arquivo original: FINXFUN.PRX


@param lVazio: Se valia o campo vazio
@param cCampo: conteudo a ser validado
@param nUso: Onde a natureza vai ser usada
@param nTipoOK: Tipo de natureza permitida

@Author	TOTVS
@since	23/11/2009
/*/
//-----------------------------------------------------------------------------------------------------
Function FinVldNat( lVazio as Logical, cCampo as Character, nUso as Numeric, nTipoOk as Numeric) as Logical
	Local lRet		as Logical
	Local aArea		as Array
	Local cFunName	as Character

	Default cCampo	:= &( ReadVar() )
	Default nTipoOk	:= 0
	lRet		:= .T.
	aArea		:= SED->( GetArea() )
	cFunName	:= FunName()

	//Caso não seja passado o nUso é inicializado. (X3_VALID EV_NATUREZ rateio por execauto)
	If nUso == Nil
		If FwIsInCallStack("FINA040") .or. FwIsInCallStack("FINA070")
			nUso := 1  // A receber.
		ElseIf FwIsInCallStack("FINA050") .or. FwIsInCallStack("FINA080")
			nUso := 2  // A pagar.
		else
			nUso := 0 //Default
		Endif
	Endif

	If !lVazio .AND. Empty( cCampo )
		Help( " ", 1, "NATVAZIA",, STR0033, 1, 0 ) //"É necessário que seja informada uma natureza para esse processo.!"
		lRet	:= .F.
	EndIf

	If lRet .AND. !Empty( cCampo )
		DbSelectArea( "SED" )
		SED->( DbSetOrder( 1 ) )
		If SED->( DbSeek( xFilial( "SED" ) + cCampo ) )
			If Val( SED->ED_TIPO ) == 1 .AND. nTipoOk == 0
				Help( " ", 1, "NATUREZ1",, STR0034, 1, 0 )  //"Verifique se a natureza informada está classificada corretamente. Apenas naturezas do titpo analítico serão aceitas para este processo.!"
				lRet	:= .F.
			EndIf

			If lRet .AND. nTipoOk > 0 .AND. Val( SED->ED_TIPO ) <> nTipoOk
				Help( " ", 1, "NATUREZ2",, STR0036, 1, 0 ) //###"Verifique o tipo da natureza!"
				lRet	:= .F.
			EndIf

			If lRet .and. nUso <> 0 .and. !Empty(SED->ED_USO) .and. SED->ED_USO <> "0"
				//Validação do nUso 
				If nUso <> Val( SED->ED_USO )
					// Valida contas a receber.
					If lRet .AND. cFunName $ "FINA040|FINA740|FINA070|FINA460"
						If 	!SED->ED_USO $ '0|1'
							Help( " ", 1, "USONATCR",, STR0037, 1, 0 ) //"A natureza não poderá ser usada nesta rotina!"
							lRet	:= .F.
						EndIf
					EndIf

					// Valida contas a pagar.
					If lRet .AND. cFunName $ "FINA050|FINA750|FINA080|FINA565"
						If  !SED->ED_USO $ '0|2'
							Help( " ", 1, "USONATCP",, STR0037, 1, 0 )  //"A natureza não poderá ser usada nesta rotina!"
							lRet	:= .F.
						EndIf
					EndIf

					// Valida outras rotinas.
					If lRet .AND. !IsInCallStack("MATA103") .and. !(cFunName $	"FINA040|FINA050|FINA740|FINA750|FINA070|FINA080|FINA090|FINA110|FINA190|FINA191|FINA280|FINA290|FINA450|FINA460|FINA565|MATA103|FINA330|FINA340|FINA390|FINA470|FINA473|FINA430")
						Help( " ", 1, "USONATGR",, STR0037, 1, 0 )	 //"A natureza não poderá ser usada nesta rotina!"
						lRet	:= .F.
					EndIf
				EndIf
			EndIf
		Else
			Help( " ", 1, "NATNAOENC",, STR0038, 1, 0 )   //"A natureza não foi encontrada!!"
			lRet	:= .F.
		EndIf
	EndIf
	
	If lRet .AND. cPaisLoc $ 'URU|ARG|CHI|BOL|PAR' .AND. FwIsInCallStack("FINA100")
		If !(ExistCpo("SED",cCampo))
			lRet := .F.
		EndIf
	EndIf
	RestArea( aArea )

Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FCKRESEXT

Valida o conteúdo digitado no campos (validação dos campos A2_PAISEX/A2_BREEX/A2_TPREX/A2_TRBEX)
Arquivo original: FINXFUN.PRX

@Author	Adrianne Furtado
@since	17/02/2011
/*/
//-----------------------------------------------------------------------------------------------------
Function FCkResExt(cCpo, uConteudo)
Local lRet := .F.
Local aTabela1
Local aTabela2
Local aTabela3

//1. Informações sobre os rendimentos
aTabela1 := {"100","110","120","130","140","150","160","170","180","190","200","210","220","230","300"}

//2. Informações sobre a forma de tributação
aTabela2 := {"10","11","12","13","30","40","41","42","43","44","50"}

//3. Informações sobre os beneficiários dos rendimentos
aTabela3 := {"500","510","520","530","540","550","560","570","900"}

Do Case
	Case cCpo == 'A2_PAISEX'
		lRet := .T.
	Case cCpo == 'A2_BREEX'
		lRet := Ascan(aTabela3, {|x| x == uConteudo}) > 0
	Case cCpo == 'A2_TPREX'
		lRet := Ascan(aTabela1, {|x| x == uConteudo}) > 0
	Case cCpo == 'A2_TRBEX'
		lRet := Ascan(aTabela2, {|x| x == uConteudo}) > 0
EndCase

Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA390BANCO

Valida banco digitado (FINA190/FINA390).
Arquivo original: FINXFUN.PRX

@param nGet - Indica sequencia que vou montar minha chave
@param lVldBloq - Valido ou nao o bloqueio da conta

@Author	Wagner Xavier
@since	21/03/1994
/*/
//-----------------------------------------------------------------------------------------------------
Function fa390Banco(nGet As Numeric, lVldBloq As Logical)
Local cChave 	As Character	
Local lRet	 	As Logical
Local cCampo 	As Character

DEFAULT nGet     := 0
DEFAULT lVldBloq := .F.

cChave 	:= "" 
lRet	:= .T.
cChave	:= cBanco390+cAgencia390+cConta390

DbSetOrder(1)

If nGet > 0 .And. !Empty(cChave)
  	If !SA6->(DbSeek( xFilial("SA6") + cChave ))
		Help( " ",1,"fa390Banco" )
		lRet := .f.
	Endif

  	If lRet .and. SA6->A6_BLOCKED == "1"
		Help(" ",1,"CCBLOCKED")
		lRet := .f.
	Endif
Else
	lAchou := !Empty(cConta390) .And. SA6->(DbSeek(xFilial("SA6")+cChave))
	cCampo := ReadVar()

	If !lAchou 
		If cCampo == "CBANCO390"
			cChave := cBanco390
		Elseif cCampo =="CAGENCIA390"
			cChave := cBanco390+cAgencia390
		Endif

		lAchou := SA6->(DbSeek(xFilial("SA6")+cChave))
	Endif

	If lAchou
		cBanco390 	:= SA6->A6_COD
		cAgencia390 := SA6->A6_AGENCIA
		cConta390 	:= SA6->A6_NUMCON
	Else
		Help(" ",1,"fa390banco" )
		lRet := .F.
	Endif

	If lRet .And. lVldBloq .And. SA6->A6_BLOCKED == "1"
		Help(" ",1,"CCBLOCKED")
		lRet := .f.
	Endif	
Endif

If lRet .And. SA6->(ColumnPos("A6_MSBLQL")) > 0
	If SA6->A6_MSBLQL == "1"
		Help(" ",1,"REGBLOQ",,,1,0)
		lRet := .F.
	Endif
Endif

//-----------------------------------------------------------------
// Ponto de Entrada para controle da numeracao do cheque no
// FINA390 e tambem sera retornado o Banco, Agencia e Conta.
//-----------------------------------------------------------------
If ExistBlock("F390NCHQ") .And. !Empty(cBanco390) .And. !Empty(cAgencia390) .And. !Empty(cConta390)
	cCheque390 := Padr(ExecBlock("F390NCHQ",.F.,.F.,{cBanco390,cAgencia390,cConta390}),TamSX3("EF_NUM")[1])
EndIf

Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA390CHEQ

Valida cheque digitado (FINA190/FINA390).
Arquivo original: FINXFUN.PRX

@Author	Wagner Xavier
@since	21/03/1994
/*/
//-----------------------------------------------------------------------------------------------------
Function fa390Cheq(nNum)
Local cAlias:= Alias( )
Local lRet  := .t.
Local nReg  := Recno()

If Empty( cCheque390 )
	Return .f.
Endif
dbSelectArea( "SEF" )
dbSetOrder(1)
If (dbSeek( cFilial + cBanco390 + cAgencia390 + cConta390 + cCheque390 ) )
	If nNum == 1
		Help( " ",1,"fa390Cheq" )
		lRet := .f.
	Endif
Else
	If nNum == 2
		Help( " ",1,"fa390NoXeq" )
		lRet := .f.
	Endif
	dbGoto(nReg)
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ PE F390VCH                                              ³
//³ Utilizado para validacoes extras ao nro. do chq s/ tit. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("F390VCH")
	lRet := ExecBlock("F390VCH",.F.,.F.)
Endif

dbSelectArea( cAlias )
Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINVLACDC

Valida se o acrescimo e descrecimo estao preenchidos (validação de campos E1_ACRESC, E1_DECRES, E2_ACRESC,
E2_DECRES).
Arquivo original: FINXFUN.PRX

@Author	TOTVS
@since	17/05/2012
/*/
//-----------------------------------------------------------------------------------------------------
Function FinVlAcDc(cTipo)

Local lRet := .T.
Local aArea := SE2->( GetArea() )

If cTipo == "P"
	If M->E2_ACRESC>0 .And. M->E2_DECRESC>0
		Help(" ",1,"ACRES/DECRES")
		lRet := .F.
	ElseIf M->E2_ACRESC>0 .And. M->E2_DECRESC==0
		lRet := .T.
	ElseIf M->E2_DECRESC>0 .And. M->E2_ACRESC==0
		lRet := .T.
	EndIf
ElseIf cTipo == "R"
	If M->E1_ACRESC>0 .And. M->E1_DECRESC>0
		Help(" ",1,"ACRES/DECRES",,"")
		lRet := .F.
	ElseIf M->E1_ACRESC>0 .And. M->E1_DECRESC==0
		lRet := .T.
	ElseIf M->E1_DECRESC>0 .And. M->E1_ACRESC==0
		lRet := .T.
	EndIf
EndIf

RestArea( aArea )
Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FXVLDBXBCO

Valida se o banco selecionado por ser usado na baixa..
Arquivo original: FINXFUN.PRX

@param cBco      - Banco
@param cAg       - Agencia
@param cCnta     - Numero da Conta
@param cNatureza - Natureza
@param nMoedTit  - Moeda do titulo
@param lAlerta   - Se exibe o alerta em situacao de erro

@Author	TOTVS
@since	11/11/2009
/*/
//-----------------------------------------------------------------------------------------------------
Function FXVldBxBco( cBco, cAg, cCnta, cNatureza, nMoedTit, lAlerta )
Local aArea		:= GetArea()
Local lRet 		:= .T.
Local lMoedaBco	:= SuperGetMv("MV_MOEDBCO",, .F.)
Local lNatBcEx	:= SuperGetMv("MV_NATBCEX",, .T.)

Default cCnta	:= ""
Default lAlerta	:= .T.

// Verifica se o banco selecionado pode ser usado para baixa do titulo
If cPaisLoc == "BRA" .AND. !Empty( cCnta )
	DbSelectArea( "SA6" )
	SA6->( DbSetOrder( 1 ) )
	If SA6->( DbSeek( xFilial( "SA6" ) + cBco + cAg + cCnta ) )
		If SA6->A6_MOEDA > 1 .AND. lNatBcEx
			If FXCalcImp( cNatureza )
				If lAlerta
					Help( " ", 1, "FA100NAT",, STR0039, 1, 0 )  //"A baixa de titulos cuja configuração da natureza calcula impostos só é permitida em conta bancáia com moeda corrente!"
				EndIf

				lRet 		:= .F.
			EndIf

			If lRet .AND. SA6->A6_MOEDA <> nMoedTit .AND. !lMoedaBco
				If lAlerta
					Help( " ", 1, "FA100BCO2",, STR0040, 1, 0 )  //"O banco para baixa deve ser em moeda corrente ou na moeda do titulo!"
				EndIf

				lRet 		:= .F.
			EndIf
		EndIf
	EndIf
	If lRet
		nMoedaBco := SA6->A6_MOEDA
	Endif

EndIf

RestArea( aArea )

Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FXMULSLD

Verifica  se  o ambiente  esta preparado  para  controle de saldos bancarios em multiplas moedas.
(função utilizada para saber se existiam campos A6_MOEDA e a tabela FIJ).
Arquivo original: FINXFUN.PRX

@Author	TOTVS
@since	12/11/2009
/*/
//-----------------------------------------------------------------------------------------------------
Function FXMultSld()
	Local lRet := .F.

	If cPaisLoc $ "BRA|PER|BOL"
		lRet	:= .T.
	EndIf

Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FXVLDBCO

Valida se o bordero foi feito em moeda nacional  ou na moeda da conta bancária (FINA060/FINA061).
Arquivo original: FINXFUN.PRX

@Author	TOTVS
@since	09/11/2009
/*/
//-----------------------------------------------------------------------------------------------------
Function FXVldBco( cPort, cAgen, cConta, nMoeda, lBord )
Local lRet		:= .T.
Local aArea		:= SA6->( GetArea() )
Local cMensa	:= ""

Default nMoeda := 0
Default lBord	:= .F.

If cPaisLoc == "BRA"
	DbSelectArea( "SA6" )
	SA6->( DbSetOrder( 1 ) )
	If SA6->( DbSeek( xFilial( "SA6" ) + cPort + cAgen + cConta ) )

		nMoedaBco	:= Max(SA6->A6_MOEDA,1)
		nMoeda		:= If (nMoeda == 0, nMoedaBco, nMoeda)
		cMensa	   := If (lBord, STR0041 + CHR(10) + STR0042, STR0043) //"Moeda do borderô e Moeda do Banco são diferentes."###"Para contas correntes com moeda diferente de 1 somente poderão ser gerados borderos na mesma moeda da conta corrente."###"O banco para baixa deve ser em moeda corrente ou na moeda do portador do bordero!"


		If  nMoedaBco > 1 .and. nMoedaBco != nMoeda
			Help( " ", 1, "A6_MOEDA",, cMensa, 1, 0 )
			Return .F.
		EndIf
	EndIf
EndIf

RestArea( aArea )
Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} CCBLOCKED

Verifica se conta corrente esta bloqueada.
Arquivo original: FINXFUN.PRX

@Author	Mauricio Pequim Jr.
@since	03/07/2003
/*/
//-----------------------------------------------------------------------------------------------------
FUNCTION CCBlocked(cBanco,cAgencia,cConta,lHelp,lVldData,cXFilial)
	Local aArea		As Array    
	Local aAreaSA6  As Array
	Local lRet		As Logical

	Default lVldData 	:= .F.
	Default cBanco		:= ""
	Default cAgencia	:= ""	
	Default cConta		:= ""
	Default cXFilial    := cFilAnt
	Default lHelp		:= .T.

	aArea    := GetArea()
	aAreaSA6 := SA6->(GetArea())
	lRet	 := .F.	

	SA6->( DbSetOrder(1) )
	If SA6->( DbSeek(xFilial("SA6",cXFilial)+cBanco+cAgencia+cConta))

		If SA6->A6_BLOCKED == "1" .and. If(lVldData,SA6->A6_DTBLOQ <= dDataBase,.T.)
			If lHelp
				Help(" ",1,"CCBLOCKED",,STR0091,1,0)
			Endif	
			
			lRet := .T.
		ElseIf SA6->(ColumnPos("A6_MSBLQL")) > 0 .And. SA6->A6_MSBLQL == "1" 
			If lHelp
				Help(" ",1,"REGBLOQ",,,1,0)
			Endif

			lRet := .T.
		Endif
	Endif	

	RestArea(aAreaSA6)
	RestArea(aArea)
	FwFreeArray(aAreaSA6)
	FwFreeArray(aArea)

Return lRet
//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FXCALCIMP

Verifica se natureza calcula impostos (ligada a FXVldBxBco)
Arquivo original: FINXFUN.PRX

@Author	TOTVS
@since	11/11/2009
/*/
//-----------------------------------------------------------------------------------------------------
Function FXCalcImp( cNatureza )
	Local lRet	:= .T.
	Local aArea	:= SED->( GetArea() )

	If cPaisLoc == "BRA"
		dbSelectArea("SED")
		SED->( DbSetOrder( 1 ) )
		If SED->( DbSeek( xFilial( "SED" ) + cNatureza ) )
			lRet :=	SED->ED_CALCCOF == "S" .OR. ;
					SED->ED_CALCCSL == "S" .OR. ;
					SED->ED_CALCINS == "S" .OR. ;
					SED->ED_CALCIRF == "S" .OR. ;
					SED->ED_CALCISS == "S" .OR. ;
					SED->ED_CALCPIS == "S"
		EndIf
	EndIf

	RestArea( aArea )
Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FXCalImp2

Verifica se natureza calcula determinado imposto.

@Param 	cNatureza = Código da Natureza
		cCpo = Nome do campo do imposto a ser consultado na tabela SED

@Author	TOTVS
@since	19/03/15
/*/
//-----------------------------------------------------------------------------------------------------

Function FXCalImp2( cNatureza, cCpo )
	Local lRet	:= .T.
	Local aArea	:= SED->( GetArea() )

	If cPaisLoc == "BRA"
		dbSelectArea("SED")
		SED->( DbSetOrder( 1 ) )
		If SED->( DbSeek( xFilial( "SED" ) + cNatureza ) )
			lRet :=	&("SED->" + cCpo) == "S"
		EndIf
	EndIf

	RestArea( aArea )
Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} MOVBCOBX

Verifica se o motivo de baixa gera movimento bancário.
Arquivo original: FINXFUN.PRX

@Author	Andreia Santos
@since	25/11/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function MovBcoBx( cMotBx, lDescricao )
Local nPos
Local lRet := .F.
Local aMotBx:= ReadMotBx()

lDescricao := If(lDescricao = Nil, .F., lDescricao)

If lDescricao
	nPos := Ascan(aMotBx, {|x| Substr(x,7,10) = Upper(cMotBx) })
Else
	nPos := Ascan(aMotBx, {|x| Substr(x,1,3) = Upper(cMotBx) })
Endif

If nPos > 0
	lRet := Iif(Substr(aMotBx[nPos],19,1) == "S",.T.,.F.)
Endif
Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SPBINUSE

Verifica se o SPB (Sistema de pagamentos brasileiro) está ativo no Financeiro.
Arquivo original: FINXFUN.PRX

@Author	Mauricio Pequim Jr.
@since	25/02/2002
/*/
//-----------------------------------------------------------------------------------------------------
Function SpbInUse()

If lSPBInUse == NIL
	If cPaisLoc == "BRA" .and. SuperGetMv("MV_USASPB",,"N") == "S"
		lSPBInUse := .T.
	Else
		lSPBInUse := .F.
	Endif
Endif

Return lSPBInUse

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SPBTIPO

Verifica se o tipo do SPB está valido (TED ou STR) (FINA070/FINA080/FINA100).
Arquivo original: FINXFUN.PRX

@param cAlias - Alias
@param cModSpb - Modalidade do SPB
@param cTipoTit - Tipo do titulo utilizado no movimento
@param cTipoMov

@Author	Mauricio Pequim Jr.
@since	25/02/2002
/*/
//-----------------------------------------------------------------------------------------------------
Function SpbTipo (cAlias,cModSpb,cTipoTit,cTipoMov)

Local lRet := .T.
Local aSaveArea := GetArea()
Local cAlias2 := cAlias
Local lValidCpo := .T.

cMotBx := Iif(Type("cMotBx")!="C",Space(3),cMotBx)
cTipoMov := IIF(cTipoMov == NIL,"  ",cTipoMov)	// Tipo de movimentacao manual

//Verifica se validacao no campo _MODSPB - Inclusao
If cModSpb == NIL .and. cTipoTit == NIL .and. cAlias $ "SE1/SE2"
	dbSelectArea(cAlias)
	cAlias2 := Right(cAlias,2)
	cTipoTit := M->&(cAlias2+"_TIPO")
	cModSpb  := M->&(cAlias2+"_MODSPB")
	If Empty(cTipoTit)
		lValidCpo := .F.
	Endif
Endif
//Verifica se validacao no campo _MODSPB - Inclusao movimentação Rec/Pag
//Esse trecho não foi convertido pois a FINA100 ainda está toda baseada na SE5.
If cModSpb == NIL .and. cTipoTit == NIL .and. cAlias == "SE5"
	dbSelectArea(cAlias)
	cTipoTit := M->E5_MOEDA
	cModSpb  := M->E5_MODSPB
	If Empty(cTipoTit)
		lValidCpo := .F.
	Endif
Endif


//Titulos de adiantamento sempre serao STR pois considera como valor disponível
//e nao como eventual futura baixa
If lValidCpo
	If cTipoTit $ MVRECANT+"/"+MV_CRNEG .and. cModSpb != "1"
		Help(" ",1,"ADTINSPB")	//"Titulos de adiantamento sempre serao modalidade "
										//"TED pois considera-se como valor disponível "
										//"e nao como eventual baixa futura"
		lRet := .F.

	// Baixa de titulos a receber com data de credito posterior a baixa
	ElseIf !Empty(cMotBx).and.cAlias == "SE1".and. MovBcoBx(cMotbx,.T.) .and. ;
			dDtCredito > dBaixa .and. cModSpb != "3"
		Help(" ",1,"MODSPBCR")	//"Modalidade invalida para esse tipo de movimento. "
										//"Para essa modalidade de SPB, utilize motivo de baixa "
										//"que aceite retencao (COMP)"

		lRet := .F.

	// Baixa de titulos a receber com data de credito igual a baixa
	ElseIf !Empty(cMotBx).and.cAlias == "SE1".and. MovBcoBx(cMotbx,.T.) .and. ;
			dDtCredito == dBaixa .and. cModSpb == "3"
		Help(" ",1,"MODSPBSR")	//"Modalidade invalida para esse tipo de movimento. "
										//"Para essa modalidade de SPB, utilize motivo de baixa "
										//"sem retencao (STR ou CIP)"

		lRet := .F.

	// Apenas para baixas a pagar
	ElseIf !Empty(cMotBx).and. cAlias == "SE2" .and. MovBcoBx(cMotbx,.T.) .and.;
			 ChqMotBx(cMotBx) .and. cModSpb != "3"
		Help(" ",1,"MODSPBCP")	//"Modalidade invalida para esse tipo de movimento. "
										//"Para essa modalidade de SPB, utilize motivo de baixa "
										//"que nao gere cheques"

		lRet := .F.

	// Apenas para baixas a pagar
	ElseIf !Empty(cMotBx).and. cAlias == "SE2" .and. MovBcoBx(cMotbx,.T.) .and.;
			!ChqMotBx(cMotBx) .and. cModSpb == "3"
		Help(" ",1,"MODSPBCPR")	//"Modalidade invalida para esse tipo de movimento. "
										//"Para essa modalidade de SPB, utilize motivo de baixa "
										//"que gere cheques (COMP)."

		lRet := .F.


	// Apenas para Mov. Manual Pagar ou Receber
	ElseIf cAlias == "SE5" .and. cTipoTit $ "C1/C2/C3/C4/C5/CH" .and. Empty(cTipoMov).and. ;
		cModSpb != "3"
		Help(" ",1,"MODSPBC1")	 //"Modalidade invalida para esse tipo de movimento. "
										 //"Para essa modalidade de SPB, utilize movimentacao "
										 //"que gere cheques (COMP)."

		lRet := .F.

	// Apenas para Mov. Manual Pagar ou Receber
	ElseIf cAlias == "SE5" .and. cTipoTit $ "M1/M2/M3/M4/M5" .and. Empty(cTipoMov).and. ;
		cModSpb == "3"
		Help(" ",1,"MODSPBM1")	//"Modalidade invalida para esse tipo de movimento. "
										//"Para essa modalidade de SPB, utilize movimentacao "
										//"que nao gere cheques (TED ou CIP)."

		lRet := .F.

	// Apenas para Transferencia - Mov. sem documento
	ElseIf cAlias == "SE5" .and. !(cTipoTit $ "TB /CH /DOC") .and. cTipoMov == "TR" .and. ;
		cModSpb == "3"
		Help(" ",1,"MODSPBT1")	//"Modalidade invalida para esse tipo de movimento. "
										//"Para essa modalidade de SPB, utilize movimentacao "
										//"que nao gere cheques (STR ou CIP)."

		lRet := .F.

	// Apenas para Transferencia - Mov. com documento
	ElseIf cAlias == "SE5" .and. cTipoTit $ "TB /CH " .and. cTipoMov == "TR" .and. ;
		cModSpb != "3"
		Help(" ",1,"MODSPBT2")	//"Modalidade invalida para esse tipo de movimento. "
										//"Para essa modalidade de SPB, utilize movimentacao "
										//"que gere cheques (COMP)."

		lRet := .F.
	Endif

Endif
RestArea(aSaveArea)
Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FVldJurxFin

Verificacao da integração Caixinha Financeiro x SigaPFS
Arquivo original: FINXFUN.PRX

@author    Mauricio Pequim Jr
@version   11.80
@since     12/03/13

@return ExpL1 = Confirma a integração Caixinha Financeiro x SigaPFS

/*/
//-----------------------------------------------------------------------------------------------------
Function FVldJurxFin()
Local lIntSJURI		:= SuperGetMv("MV_JURXFIN",.T.,.F.)

If lCxJurxFin == NIL
	lCxJurxFin := lIntSJURI
Endif

Return lCxJurxFin

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINMODPROC

Função que define qual processo será utilizado nos contas a receber e contas a pagar no módulo do
Financeiro (modelo 1ou model
o II - Argentina).
Processos:
FINA087A - Recebimentos Diversos - Modelo I
FINA840	- Recebimentos Diversos - Modelo II
FINA085A - Ordem de Pagamento - Modelo I
FINA850	- Ordem de Pagamento - Modelo II
FINA095	- Cheques Emitidos
FINA096	- Cheques de Terceiros
FINA025	- Modo de Pago
FINA585	- Solicitação de Fundos
FINA085P	- Pré-Ordem de Pago - Modelo I
FINA855	- Pré-Ordem de Pago - Modelo II
FINA845	- Entrada de Documentos em Trânsito
FINA841	- Manutenção de Recibos de Cobrança Modelo II

Arquivo original: FINXFUN.PRX

@Author	Marylly A. Silva
@since	06/01/2012
/*/
//-----------------------------------------------------------------------------------------------------
Function FinModProc(lMsg,cTexto)

Local lRet 		:= .T.
Local aAreaSX6 	:= {}
Local nModProc	:= 1
Local cNomRotin := AllTrim(FunName())
Local lRotina	:= FwIsInCallStack(cNomRotin)
Local cMsg := ""

Default lMsg := .T.
Default cTexto := ""

DbSelectArea("SX6")
aAreaSX6 := SX6->(GetArea("SX6"))
nModProc := GetMV("MV_FINCTMD",.T.,1)

If lRotina .AND. cPaisLoc <> "BRA"
	lRet := .F.
	Do Case
		Case cNomRotin $ "FINA025|FINA585|FINA845|FINA841" .AND. nModProc == 1
			cMsg += STR0044 //"O processo do financeiro está configurado para o Modelo I, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo II."
		Case cNomRotin == "FINA087A" .AND. nModProc == 2
			cMsg += STR0045 //"O processo do financeiro está configurado para o Modelo II, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046 + "FINA840 - " + STR0047 //"Utilize a rotina "###" Recebimentos Diversos Mod.II"
		Case cNomRotin $ "FINA840|FINA846" .AND. nModProc == 1
			cMsg += STR0044 //"O processo do financeiro está configurado para o Modelo I, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo II."
			cMsg := cMsg + CRLF + STR0046 + "FINA087A - " + STR0048 //"Utilize a rotina "###" Recebimentos Diversos."
		Case cNomRotin == "FINA085A" .AND. nModProc == 2
			cMsg += STR0045 //"O processo do financeiro está configurado para o Modelo II, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046 + "FINA850 - " + STR0049 //"Utilize a rotina "###" Ordem Pago Mod. II."
		Case cNomRotin $ "FINA850|FINA847" .AND. nModProc == 1
			cMsg += STR0044 //"O processo do financeiro está configurado para o Modelo I, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo II."
			cMsg := cMsg + CRLF + STR0046 + "FINA085A - " + STR0050 //"Utilize a rotina "###" Ordem Pago."
		Case cNomRotin == "FINA855" .AND. nModProc == 1
			cMsg+= "O processo do financeiro está configurado para o Modelo I, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo II."
			cMsg := cMsg + CRLF + STR0046 + "FINA085P - " + STR0051 //"Utilize a rotina "###" Pré-Ordem Pago."
		Case cNomRotin == "FINA085P" .AND. nModProc == 2
			cMsg+= "O processo do financeiro está configurado para o Modelo II, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046+ "FINA855 - " + STR0052 //"Utilize a rotina "###" Pré-Ordem Mod. II."
		Case cNomRotin == "FINA090" .AND. nModProc == 2
			cMsg+= "O processo do financeiro está configurado para o Modelo II, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046 + "FINA095 - " + STR0053 //"Utilize a rotina "###" Cheques emitidos"
		Case cNomRotin == "FINA095" .AND. nModProc == 1
			cMsg += "O processo do financeiro está configurado para o Modelo I, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046 + "FINA090 - " + STR0054 //"Utilize a rotina "###" Debitar Cheques"
		Case cNomRotin == "FINA089" .AND. nModProc == 2
			cMsg += "O processo do financeiro está configurado para o Modelo II, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046 + "FINA096 - " + STR0055 //"Utilize a rotina "###" Cheques Recebidos"
		Case cNomRotin == "FINA096" .AND. nModProc == 1
			cMsg += "O processo do financeiro está configurado para o Modelo I, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046 + "FINA089 - " + STR0056 //"Utilize a rotina "###" Liquidar Cheques "
		Case cNomRotin == "FINA472" .AND. nModProc == 1
			cMsg += "O processo do financeiro está configurado para o Modelo I, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo II."
			cMsg := cMsg + CRLF + STR0046 + "FINA470 - " + STR0057 //"Utilize a rotina "###"Concil. Automatica"
		Case cNomRotin == "FINA470" .AND. nModProc == 2
			cMsg += "O processo do financeiro está configurado para o Modelo II, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046 + "FINA472 - " + STR0088 //"Utilize a rotina "###"Concil. Bancária"
 		Case cNomRotin == "FINR470" .AND. nModProc == 2
			cMsg += "O processo do financeiro está configurado para o Modelo II, conforme parâmetro MV_FINCTMD. Esta rotina não pode ser utilizada, porque pertence ao modelo de processo I."
			cMsg := cMsg + CRLF + STR0046 + "FINR856 - " + STR0088 //"Utilize a rotina "###"Concil. Bancária"
		Otherwise
			lRet := .T.
	EndCase
	If lMsg .And. !Empty(cMsg)
		MsgAlert(cMsg)
	Else
		cTexto += cMsg
	EndIf
EndIf

RestArea(aAreaSX6)
Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINEntBc

Verificacao e gravacao das entidades bancarias (ARGENTINA)
Arquivo original: FINXFUN.PRX

@author    Mauricio Pequim Jr
@version   11.80
@since     05/02/13

@param cBanco	- Código do Banco
@param cAgencia	- Código da Agência
@param cCodPost	- Código Postal

@return ExpL1 = Confirma a gravacao da entidade bancaria

/*/
//-----------------------------------------------------------------------------------------------------
Function FINEntBc(cBanco,cAgencia,cCodPost)

Local aArea := GetArea()
Local aAreaFJO := FJO->(GetArea())
Local aAreaFJN := FJN->(GetArea())

Default cBanco   := ""
Default cAgencia := ""
Default cCodPost := ""

//Cadastro de entidades bancarias (bancos)
dbSelectArea("FJO")
FJO->(DbSetOrder(1))
IF !(MsSeek(xfilial("FJO")+cBanco))
	RecLock("FJO",.T.)
	FJO->FJO_FILIAL := xFilial("FJO")
	FJO->FJO_COD 	:= cBanco
	MsUnlock()
Endif

dbSelectArea("FJN")
FJN->(DbSetOrder(2))
IF !(MsSeek(xFilial("FJN")+cCodPost+cBanco+cAgencia))
	RecLock("FJN",.T.)
	FJN->FJN_FILIAL := xFilial("FJN")
	FJN->FJN_POSTAL := cCodPost
	FJN->FJN_COD 	:= cBanco
	FJN->FJN_AGENCI := cAgencia
	MsUnlock()
Endif

RestArea(aAreaFJN)
RestArea(aAreaFJO)
RestArea(aArea)

Return .T.


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} EDITAPLIC

Editar o valor da cota do dia das aplicacoes por cotas (ligada a função Aplicacoes).
Arquivo original: FINXFUN.PRX

@author    Claudio D. de Souza
@since     03/10/2001
/*/
//-----------------------------------------------------------------------------------------------------
Static Function EditAplic(nCol,oAplic,aAplic)
Local nClick := 0

nClick := oAplic:nAtCol(nCol)

If nClick <> 1
	// Transforma para numerico para que o usuario possa editar o campo com entrada
	// de numeros apenas.
	aAplic[oAplic:nAt][nCol] := Val(StrTran(StrTran(aAplic[oAplic:nAt][nCol],".",""),",","."))
	lEditCell(@aAplic,oAplic,PesqPict("SE9","E9_VLRCOTA",18),nCol)
	// Volta para caracter o numero editado para que possa ser exibido corretamente
	// pela LISTBOX.
	aAplic[oAplic:nAt][nCol] := Transform(aAplic[oAplic:nAt][nCol],PesqPict("SE9","E9_VLRCOTA",18))
	oAplic:SetFocus()
EndIf
Return


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} APLICACOES

Exibe aplicacoes para selecao/informacao das cotas diarias.
Arquivo original: FINXFUN.PRX

@param lConsFil - considera filiais
@param nMoeda - código da moeda
@param lAvisa

@return aAplic (.f.,banco,agencia,conta,ome,saldo)

@author    Claudio D. de Souza
@since     03/10/2001
/*/
//-----------------------------------------------------------------------------------------------------
Function Aplicacoes(lConsFil, nMoeda, lAvisa)
Local oDlgAplic
Local aAplic
Local nX
Local aArea    := GetArea()
Local aAreaSe9 := SE9->(GetArea())

Default lAvisa := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa array com os bancos existentes.						  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aAplic := GetAplic(lConsFil)
If !IsBlind()
	If Len(aAplic) == 0
		If lAvisa
			ApMsgAlert(STR0058) //"Nao existem aplicações financeiras"
		Endif
	Else
		ASort(aAplic)

		DEFINE MSDIALOG oDlgAplic TITLE STR0059 From 5,5 To 20,87 OF oMainWnd  //"Informe os valores das cotas diarias"
		@	.8, .5 LISTBOX oAplic FIELDS HEADER STR0060,STR0061,STR0062,STR0063,STR0064,STR0065 FIELDSIZES 14,25,31,31,60,40,40 SIZE 275, 100 OF oDlgAplic  //"Contrato"###"Banco"###"Agencia"###"Saldo"###"Vlr. Cota Atual"###"Vlr. Cota do dia"
		oAplic:SetArray(aAplic)
		oAplic:bLine      := {|| {	aAplic[oAplic:nAt,1],;
								   		aAplic[oAplic:nAt,2],;
								   		aAplic[oAplic:nAt,3],;
								   		aAplic[oAplic:nAt,4],;
								   		aAplic[oAplic:nAt,5],;
								   		aAplic[oAplic:nAt,6]}}

		oAplic:bLDblClick := {|| EditAplic(6,@oAplic,@aAplic),oAplic:GoRight(),oAplic:GoLeft()}

		DEFINE SBUTTON FROM 05, 290 TYPE 1 ACTION oDlgAplic:End() ENABLE OF oDlgAplic
		ACTIVATE MSDIALOG oDlgAplic

	Endif
	// Transforma o ultimo elemento da matriz (Valor da cota do dia) para numerico
	// Eliminando a picture deste campo e grava valor da cota do dia, caso exista o campo
	For nX := 1 To Len(aAplic)
		aAplic[nX][6] := Val(StrTran(StrTran(aAplic[nX][6],".",""),",","."))
		dbSelectArea("SE9")
		dbSetOrder(1)
		IF MsSeek(xFilial("SE9")+aAplic[nX][1]+aAplic[nX][2]+aAplic[nX][3]) .And. ;
			Str(SE9->E9_COTADIA,17,4) != Str(aAplic[nX][6],17,4)
			RecLock("SE9")
			SE9->E9_COTADIA := aAplic[nX][6]
		Endif
	Next
Endif
SE9->(RestArea(aAreaSe9))
RestArea(aArea)

Return aAplic


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} GETAPLIC

Obter as aplicacoes do cadastro de aplicações (ligada a função Aplicacoes)
Arquivo original: FINXFUN.PRX

@param lConsFil - considera filiais
@param nMoeda - código da moeda
@param lAvisa

@return aAplic (.f.,banco,agencia,conta,ome,saldo)

@author    Claudio D. de Souza
@since     03/10/2001
/*/
//-----------------------------------------------------------------------------------------------------
Static Function GetAplic(lConsFil)
Local aRet     := {},;
		aArea    := GetArea(),;
		aAreaSeh := Seh->(GetArea()),;
		aAreaSe9 := Se9->(GetArea()),;
		cAplCotas:= GetMv("MV_APLCAL4"),;
		cIndSEH  := "",;
		cFiltro
DbSelectArea("SEH")
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Filtra o arquivo de aplicacoes  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SEH")
cIndSEH := CriaTrab(,.F.)
If lConsFil
	cFiltro := "EH_TIPO$'"+&cAplCotas+"' .And. EH_FILIAL='"+xFilial("SEH")+"'"
Else
	cFiltro := "EH_TIPO$'"+&cAplCotas+"'"
Endif
IndRegua("SEH",cIndSEH,If(lConsFil, "EH_FILIAL+","")+"EH_NUMERO+EH_REVISAO",,cFiltro)
nIndSEH := RetIndex("SEH")
nIndSEH++

While !Eof() // Processa arquivo filtrado
	dbSelectArea("SE9")
	dbSetOrder(1)
	MsSeek(xFilial("SE9")+SEH->EH_CONTRAT+SEH->EH_BCOCONT+SEH->EH_AGECONT)
	dbSelectArea("SEH")

	Aadd(aRet,{	SEH->EH_CONTRAT,SEH->EH_BCOCONT,SEH->EH_AGECONT,Transform(SEH->EH_SALDO,PesqPict("SEH","EH_SALDO")),Transform(SE9->E9_VLRCOTA,PesqPict("SE9","E9_VLRCOTA",18)),;
					If(SE9->E9_COTADIA > 0,;
						Transform(SE9->E9_COTADIA,PesqPict("SE9","E9_COTADIA",18)),;
						Transform(SE9->E9_VLRCOTA,PesqPict("SE9","E9_VLRCOTA",18)))})
	DbSkip()
End

If !Empty(cIndSEH)
	dbSelectArea("SEH")
	RetIndex("SEH")
	dbClearFilter()
	Ferase(cIndSEH+OrdBagExt())
EndIf

SEH->(RestArea(aAreaSeh))
SE9->(RestArea(aAreaSe9))
RestArea(aArea)

Return aRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} TABELAIRF

Devolve o conteudo da tabela de IRF conforme a chave (FINA181 - Tabela AR do SX5)
Arquivo original: FINXFUN.PRX

@param cTab - conteudo da tabela
@param nChave - código da tabela

@author    Claudio D. de Souza
@since     24/04/2006
/*/
//-----------------------------------------------------------------------------------------------------
Function TabelaIrf(cTab,nChave)
Local cRet:="",xAlias
xAlias:=Alias()
DbSelectArea("SX5")
MsSeek(xFilial("SX5") + cTab)

While cTab == SX5->X5_TABELA .And. SX5->(!Eof())
	If Val(SX5->X5_CHAVE) >= nChave
		cRet := AllTrim(X5Descri())
		Exit
	Endif
	SX5->(dbSkip())
End

DbSelectArea(xAlias)

Return cRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} LOTECONT

Recupera o número do lote contábil.
Arquivo original: FINXFUN.PRX

@author    Wagner Xavier
@since     16/04/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function LoteCont( cChave )
	Local aArea := GetArea()

	dbSelectArea( "SX5" )
	MsSeek( xFilial("SX5") + "09" + Trim( cChave ) )
	If Eof()
		Help( " ", 1, "NOLOTCONT" )
		cLote := Space(Iif(CtbInUse(),6,4))
	Else
		If CtbInUse()
			cLote := Alltrim(SX5->X5_DESCRI)
		Else
			cLote := Substr(SX5->X5_DESCRI,1,4)
		Endif
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se ‚ um EXECBLOCK e caso sendo, executa-o                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If At(UPPER("EXEC"),SX5->X5_DESCRI) > 0
		cLote := &(SX5->X5_DESCRI)
		cLote := Substr(cLote,1,Iif(CtbInUse(),6,4))
	Endif
	RestArea(aArea)

Return cLote


/*
----------------------------------------------------------------------------
	            Funcoes retiradas do arquivo MATXATU.PRX
----------------------------------------------------------------------------
*/

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} A050DUPPAG

Gravações complementares da inclusão de C.Pagar.
Arquivo original: MATXATU.PRX

@Author	Wagner Xavier
@since	28/02/1994
/*/
//-----------------------------------------------------------------------------------------------------
Function A050DupPag( cOrigem,lUpDate,nTotIrrf,nTotINSS,lRtPICFCS,nTotISS,nBasISS,lRatImp,lFina050,cRecIss,aCodR,aMotRet,lPccMR,lIrfMR,lInsMR,lIssMR,lCidMR,lSestMR, aRatIRF )
Local nValForte		:= 0
Local nIrrf			:= 0
Local nIss			:= 0
Local nInss			:= 0
Local nSEST			:= 0
Local cParcela
Local dEmissao
Local dVencto
Local dVencRea
Local cPrefixo
Local cNum
Local cTipoE2
Local nMoeda		:= SE2->E2_MOEDA
Local nRegSe2
Local nRegSA2
Local nRegSED
Local cNatureza
Local lCond
Local lSA2			:= .T.
Local nTamData		:= 0
Local lZeraIrrf		:= .F.
Local cLa			:= SE2->E2_LA
Local nDiaUtil		:= 0
Local nDia			:= 0
Local nMCusto		:= 0
Local nOrdSe2		:= SE2->(IndexOrd())
Local cSEST			:= GetMv("MV_SEST",,"")
Local cForSEST		:= PadR( GetMv("MV_FORSEST",,""), Len( SE2->E2_FORNECE ) )
Local aTamParc		:= TamSx3("E2_PARCELA")
Local lM050CSSP		:= ExistBlock("M050CSSP")
Local cMunIss		:= GetMv("MV_MUNIC")
Local cNome			:= ""
Local cForLojISS	:= ""
Local dVenISS		:= CtoD("")
Local dEmis1		:= SE2->E2_EMIS1
Local dVctoReal		:= SE2->E2_VENCREA
Local cFornSe2		:= SE2->E2_FORNECE
Local cLojaSe2		:= SE2->E2_LOJA
Local cFilDeb		:= SE2->E2_FILDEB
Local cGeraDirf		:= If(cPaisLoc=="BRA",SE2->E2_DIRF,"")
Local cCodRetIr		:= If(cPaisLoc=="BRA",SE2->E2_CODRET,"")
Local cMultNat		:= SE2->E2_MULTNAT
Local cFornUni		:= ""
Local cLojaUni		:= ""
Local cLojaImpos	:= PadR( "00", Len( SE2->E2_LOJA ), "0" )
Local cLojaIss		:= PadR( "00", Len( SE2->E2_LOJA ), "0" )
Local nCofins		:= 0
Local nPis			:= 0
Local nCsll			:= 0
Local nFethab		:= 0
Local nFabov		:= 0
Local nFacs			:= 0
Local nFamad		:= 0
Local cParcFet		:= ""
Local cParcFab		:= ""
Local cParcFac		:= ""
Local cParcIMA		:= ""
Local cParcFmd		:= ""
Local aTamParcI		:= {}
Local cRecFet		:= ""
Local cRecFab		:= ""
Local cRecFac		:= ""
Local cRecIMA		:= ""
Local cRecFmd		:= ""
Local dDtRec		:= CtoD("")
Local lPCCBaixa		:= SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local lIRPFBaixa	:= Iif(cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)
Local lDesMinIR		:= Iif(cPaisLoc == "BRA", SA2->A2_MINIRF == "1", .F.) // Carrega variavel de verificacao de consideracao de valor minimo de retencao de IR.
Local nMinRetIR		:= GetMv("MV_VLRETIR")
Local xMinRetIR		:= 0
Local lCalcIssBx	:= IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
Local aRatSev		:= {}
Local aRatSez		:= {}
Local nImpostos		:= 0
Local nCIDE			:= 0
Local lVcAntIss		:= (SuperGetMV("MV_ANTVISS",.T.,"2") == "1")  //Antecipa ou nao o vencimento do ISS em caso de vencimento em dia nao util
Local dVencRIss		:= CTOD("//")
Local cFornCD		:= GetNewPar("MV_FORNCD","  ")
Local cTipoFor		:= ""
Local lIrfRetAnt	:= .F.
Local cTitPai		:= SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
Local cFilOrig		:= SE2->E2_FILORIG
Local lF050GER		:= ExistBlock("F050GER")
Local aRecImpos		:= {}
Local lFinVldIns	:= Existblock("FinVldIns")
Local cCodAprov		:= SE2->E2_CODAPRO
Local nDiaUtIss		:= SuperGetMv("MV_DIAUISS",.T.,0) //Nro de dias uteis que deve ser gerado o vencimento do titulo do ISS.
Local nI			:= 0
Local lInssBx		:= SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
Local aAreaFor		:= {}
Local cForPai		:= ""
Local cLojPAi		:= ""
Local cCNPJRET		:= ""
Local lAplMinP		:= SA2->A2_MINPUB == "2"
Local lEmpPub		:= IsEmpPub() .And. lAplMinP
Local nVlMPub		:= SuperGetMv("MV_VLMPUB" ,.T.,10)
Local lCallMT103	:= IsInCallStack("MATA103")
Local lPercINP		:= SED->( ColumnPos("ED_PERCINP") ) > 0
Local lCalcINP		:= SED->( ColumnPos("ED_CALCINP") ) > 0
Local cCodINSS		:= SUBSTR(GetMv("MV_FORINSS"),1, TAMSX3("A2_COD")[1])
Local nDiaISS       := SuperGetMv("MV_DIAISS",.F.,10,)
Local cDiaISS       := StrZero(nDiaISS,2)
Local nVlrCruz 		:= 0
Local lAtuForn      := SuperGetMv("MV_ATUFORN",.F.,.T.)
Local lFina986 		:= FindFunction("Fa986grava") .and. AliasInDic("FKG")
Local lInsss		:= .F.
Local nMinIns       := 0
Local nTamFor		:= TamSx3("E2_FORNECE")[1]
Local lDedInss		:= .T.
Local nValInss		:= 0
Local cMVInsAcpj    := SuperGetMv("MV_INSACPJ", .F., "1")
Local lMata103		:= FUNNAME() == "MATA103"
Local lVerMinIn		:= .T.
Local nIMA			:= 0
Local lCposIMA		:= (SE2->(ColumnPos("E2_IMA"))   > 0 .And. SE2->(ColumnPos("E2_PARCIMA")) > 0)
Local lBtrISS		:= SE2->(ColumnPos("E2_BTRISS")) > 0 .and. SE2->(ColumnPos("E2_VRETBIS")) > 0 .and. SE2->(ColumnPos("E2_CODSERV")) > 0
Local nBtrISS		:= 0
Local lValBtrISS	:= .F.
Local lValISS		:= .F.
Local cCodServ		:= ""
Local cCodMVINS		:= GetMv("MV_FORINSS")
Local cCodMVRES  	:= GetMV("MV_RECEST")
Local lRetPer		:= .F.
Local aForISSCPM    := {}
Local cCodForISS	:= ""
Local cLojForISS	:= ""
Local lParcLivre	:= .F.
Local lContinua     := .T.
Local lRatInss		:= SuperGetMV("MV_RATINSS",.F.,.F.)
Local nMesIss		:= 0
Local cVencIss		:= ""
Local aImpostos		:= {}
Local lAgFETHA		:=  SuperGetMv("MV_AGFETHA",,.F.) 

Default cOrigem 	:= ""
Default lUpDate 	:= .T. 
Default nTotINSS 	:= 0
Default lRtPICFCS 	:= .T.
Default nTotISS 	:= SE2->E2_ISS
Default nBasISS 	:= IIf(nTotISS>0,SE2->E2_VALOR+nTotISS,0)
Default lRatImp  	:= .F.
Default lFina050  	:= .F.
Default nTotIrrf  	:= SE2->E2_IRRF
Default cRecIss	  	:= ""
Default aCodR		:= {}
Default aRatIRF		:= {}
//=== Motor de Retenções
Default lPccMR  	:= .F.
Default lIrfMR  	:= .F.
Default lInsMR  	:= .F.
Default lIssMR  	:= .F.
Default lCidMR  	:= .F.
Default lSestMR 	:= .F.
Default aMotRet 	:= {}
//====================//

cOrigem := Iif( !Empty(cOrigem), Upper(cOrigem), Space(8) )

If !__lIncNat
	//-- Carrega as naturezas de impostos
	__lIncNat:=.T.
	FININCNAT()
EndIF

If lPLSTITPF == NIL
	lPLSTITPF	:= ('PLS' $ SE2->E2_ORIGEM) .and. FindFunction("PLSTITPF")
EndIf

DbSelectArea("SA2")
nRegSA2 := RecNo()
DbSelectArea("SE2")
nRegSE2 := RecNo()

// Verifica se o ambiente esta configurado com Multiplos Vinculos de ISS
cNome := "MUNICIPIO"
If !Empty( SE2->E2_CODISS )
	DbSelectArea( "FIM" )
	FIM->( DbSetOrder( 1 ) )
	If FIM->( DbSeek( xFilial( "FIM" ) + SE2->E2_CODISS ) )
		cMunIss 	:= FIM->FIM_CODFOR
		cLojaIss	:= FIM->FIM_FORLOJ
		cNome	+= "-" + AllTrim( FIM->FIM_MUN )
	EndIf

	If AliasInDic("CC2")
		CC2->(DbSetOrder( 1 ))
		If CC2->(DbSeek(xFilial("CC2") + FIM->FIM_EST + FIM->FIM_CODMUN))
			dDtRec := CC2->CC2_DTRECO
		EndIf
	EndIf
EndIf

// Se o titulo estiver rateado em multiplas naturezas,
If lRatImp .And. MV_MULNATP .And. SE2->E2_MULTNAT == "1"

	If __aSEVstru == NIL
		__aSEVstru	:=SEV->(DbStruct())
		__aSEZstru	:=SEZ->(DbStruct())	
	EndIF

	nImpostos := If(lIRPFBaixa,0,SE2->E2_IRRF)+;
				    If(!lCalcIssBx,SE2->E2_ISS,0)+;
				    SE2->E2_INSS+;
				    If(lPccBaixa,0,SE2->(E2_PIS+E2_COFINS+E2_CSLL))+SE2->E2_RETENC+SE2->E2_SEST
	// Carrega os rateios do titulo principal, para repassar aos titulos de impostos
	SEV->(DbSetOrder(2))
	SEZ->(DbSetOrder(1))
	SEV->(MsSeek(xFilial("SEV")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA+"1")))		//1=Inclusao
	While SEV->(EV_FILIAL+EV_PREFIXO+EV_NUM+EV_PARCELA+EV_TIPO+EV_CLIFOR+EV_LOJA+EV_IDENT) ==;
			xFilial("SEV")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA+"1")	//1 = Inclusao

		//Doc de Entrada ja desconsidera os impostos (quando parametrizado assim)
		//Não necessita atualizar o valor, mas é preciso carregar os dados (aRatSev e aRatSez) para gravar o rateio dos impostos 
		If !lCallMT103 .And. nImpostos > 0 
			// Recalcula os rateios, desconsiderando os impostos
			RecLock("SEV", .F.)
			SEV->EV_VALOR := SEV->EV_VALOR - (nImpostos*SEV->EV_PERC)
			msUnlock()
		EndIF

		// Adiciona todos os campos do SEV
		AAdd(aRatSev, {} )
		Aeval( __aSEVstru , { |e,i| Aadd(aRatSev[Len(aRatSev)], { e[1], SEV->(FieldGet(i)) } ) } )

		SEZ->(MsSeek(xFilial("SEZ")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA+SEV->EV_NATUREZ)))
		While SEZ->(EZ_FILIAL+EZ_PREFIXO+EZ_NUM+EZ_PARCELA+EZ_TIPO+EZ_CLIFOR+EZ_LOJA+EZ_NATUREZ) ==;
			xFilial("SEZ")+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA+SEV->EV_NATUREZ)

			If !lCallMT103 .And. nImpostos > 0
				// Recalcula os rateios, desconsiderando os impostos
				RecLock("SEZ", .F.)
				SEZ->EZ_VALOR := (SEV->EV_VALOR * SEZ->EZ_PERC)
				msUnlock()
			EndIF

			AAdd(aRatSez, {} )
			Aeval( __aSEZstru , { |e,i| Aadd(aRatSez[Len(aRatSez)], { e[1], SEZ->(FieldGet(i)) } ) } )
			SEZ->(DbSkip())
		End
		SEV->(DbSkip())
	End
Endif
DbSelectArea("SED")
SED->(MsSeek(xFilial("SED")+SE2->E2_NATUREZ))
nRegSED := RecNo()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verificar o Municipio de ISS deste Fornecedor   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//FieldPos adicionado pois não foi encontrado a origem da criação deste campo – NÃO RETIRAR
If SA2->(FieldPos("A2_MUNIC")) > 0 .And. !Empty(SA2->A2_MUNIC)
	cMvMunic := SA2->A2_MUNIC
	cForLojISS := Pad(cMvMunic,Len(SA2->A2_COD))+cLojaIss
Else
	cForLojISS := Pad(cMunIss,Len(SA2->A2_COD))+cLojaIss
EndIf

If lBtrISS
	If  FunName() $ "FINA050|FINA750"	// FINA050 ainda nao encerrou o commit do titulo
		cCodServ := M->E2_CODSERV		
	Else
		cCodServ := SE2->E2_CODSERV
	EndIf
	aForISSCPM := BtrISSMun( cCodServ, SA2->A2_EST, SA2->A2_COD_MUN )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Transfere titulo de ISS para fornecedor de origem ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(SE2->E2_FORNISS) .And. !Empty(SE2->E2_LOJAISS)
	cForLojISS := SE2->E2_FORNISS+SE2->E2_LOJAISS
	IF !Empty(cForLojISS)
		aAreaSA2 := SA2->(GetArea())
		DbSelectArea("SA2")
		DbSetOrder(1)
		If DbSeek(xFilial("SA2")+SE2->E2_FORNISS+SE2->E2_LOJAISS)
			cNome := SA2->A2_NREDUZ
		EndIF
		RestArea(aAreaSA2)
	ENDIF
EndIf

If !Empty(SE2->E2_VENCISS)
	dVenISS := SE2->E2_VENCISS
EndIf

If Empty(cRecIss)
	cRecIss	:=	SA2->A2_RECISS
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza dados do Fornecedor 			   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SE2")
lCond := .F.

If ( cRecIss$"1S" .And. lSA2)     // Fornecedor recolhe ISS
	If !E2_NATUREZ$&(GetMv("MV_ISS")) .Or. !E2_NATUREZ$&(GetMv("MV_IRF")) .or.;
		!E2_NATUREZ$&(GetMv("MV_INSS")) .or. !E2_NATUREZ$AllTrim(cSEST)
		lCond := .T.
	EndIf
ElseIf SA2->A2_RECINSS == "S" .Or. (lCalcINP .And. SED->ED_CALCINP == "1")      // Fornecedor recolhe INSS
	If !E2_NATUREZ$&(GetMv("MV_ISS")) .Or. !E2_NATUREZ$&(GetMv("MV_IRF")) .or.;
		!E2_NATUREZ$&(GetMv("MV_INSS"))
		lCond := .T.
	EndIf
ElseIf cPaisLoc == "BRA" .And. SA2->A2_RECSEST $ "S1"      // Fornecedor recolhe SEST
	If !E2_NATUREZ$&(GetMv("MV_ISS")) .Or. !E2_NATUREZ$&(GetMv("MV_IRF")) .or.;
		!E2_NATUREZ$AllTrim(cSEST)
		lCond := .T.
	EndIf
ElseIf ( !E2_NATUREZ$&(GetMv("MV_IRF")) )
  	lCond := .T.
EndIf

If SED->ED_DEDINSS == "2"
	lDedInss := .F. // Não Deduz
Else
	lDedInss := .T. // Deduz
EndIf

If lFina986
	//realiza a gravacao do model
	Fa986grava("SE2",cOrigem)
EndIf

cTipoFor := SA2->A2_TIPO
If cTipoFor == "J"
	nMinIns := SuperGetMv("MV_VLRETIN", .T., 25) // Valor minimo para Pessoa Juridica
ElseIf cTipoFor == "F"
	nMinIns := SuperGetMv("MV_MININSS", .T., 0) // Valor minimo para Pessoa Fisica
EndIf

If ( lCond )
	//Ponto de entrada para tratamento do valor minimo para IRRF.
	If ExistBlock("F040MIRF")
		xMinRetIR := 0
		xMinRetIR := Execblock("F040MIRF",.F.,.F.,{SA2->A2_COD,SA2->A2_LOJA})
		nMinRetIR := If(ValType(xMinRetIR)=="N",xMinRetIR,nMinRetIR)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza dados do Cta Pagar					  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPaisLoc == "BRA"
		//Verificacao do valor minimo de IRRF - Nao gerados pelo FINANCEIRO
		If !lIrfMR .And. !lFina050
			nTotIrrf := FCalcIr(0,cTipoFor,.F.,@lIrfRetAnt,.F.)
			If ( cOrigem == "MATA100" ) .And. nTotIrrf != Nil .And. GetMv("MV_VENCIRF") == "E"
				// Verifica se o fornecedor trata o valor minimo de retencao e se a regra se aplica.
				If lEmpPub .and. !lIrfRetAnt .And. SE2->(E2_IRRF+E2_PIS+E2_COFINS+E2_CSLL)+nTotIrrf < nVlMPub
					lZeraIrrf	:= .T.
				ElseiF !lDesMinIR .And. (nTotIrrf <= nMinRetIR .and. !lIrfRetAnt)
					lZeraIrrf	:= .T.
				EndIf
			Else
				// Verifica se o fornecedor trata o valor minimo de retencao , se a regra se aplica e se o titulo nao foi gerado pelo fina050
				If lEmpPub .and. !lIrfRetAnt .And. SE2->(E2_IRRF+E2_PIS+E2_COFINS+E2_CSLL)+nTotIrrf < nVlMPub
					lZeraIrrf	:= .T.
				ElseiF !lDesMinIR .And. (nTotIrrf <= nMinRetIR .and. !lIrfRetAnt)
					lZeraIrrf	:= .T.
				Endif	
			EndIf
			If lZeraIrrf .and. !lIRPFBaixa
				DbSelectArea("SE2")
				RecLock("SE2",.F.)
				SE2->E2_VALOR	+= SE2->E2_IRRF
				SE2->E2_SALDO	+= SE2->E2_IRRF
				SE2->E2_VLCRUZ  := Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
				SE2->E2_VRETIRF := SE2->E2_IRRF
				SE2->E2_IRRF	:= 0
			ElseIf !lFina050 .and. nTotIrrf > SE2->E2_IRRF
				//Recompoem o valor do IRRF no saldo e desconta o valor acumulado
				DbSelectArea("SE2")
				RecLock("SE2",.F.)
				SE2->E2_VALOR	+= SE2->E2_IRRF - nTotIrrf
				SE2->E2_SALDO	+= SE2->E2_IRRF - nTotIrrf
				SE2->E2_VLCRUZ  := Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
				SE2->E2_VRETIRF := SE2->E2_IRRF
				SE2->E2_IRRF	:= nTotIrrf
			ElseIf lIRPFBaixa
				RecLock("SE2",.F.)
				SE2->E2_PRETIRF := '1'
			Else
				DbSelectArea("SE2")
				RecLock("SE2",.F.)
				SE2->E2_VRETIRF := SE2->E2_IRRF
			EndIf
		Endif

		nVlrCruz := Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))

		If lFina050
			If nVlrCruz > SE2->E2_VLCRUZ .And. Abs(nVlrCruz - SE2->E2_VLCRUZ) != 0.01
				SE2->E2_VLCRUZ	:= nVlrCruz
			Else
				nVlrCruz := SE2->E2_VLCRUZ
			EndIf
		EndIf

		// Faço somente para o Compras, pois no Mata103 não consideram que o minimo de retenção de Pessoa Fisica e juridica possa ser diferentes
		If lMata103
			dDataFim  := LastDay( SE2->E2_VENCREA  )
			dDataIni  := FirstDay( SE2->E2_VENCREA  )
			dEmissao  := E2_EMISSAO
			dVencRea  := E2_VENCREA
			lInsss	  := .F.

			 
			If ( SA2->A2_TIPO == "J" .And. cMVInsAcpj == "1") .Or. SA2->A2_TIPO == "F"//Cumulatividade
				nValInss := VerInssCalc( SA2->A2_COD, SA2->A2_LOJA, SA2->A2_NREDUZ, SE2->E2_EMISSAO, SE2->E2_VENCREA,,,@lRetPer )
				//Necess rio passar pela fun‡?o VerInssCalc para verificar se houve reten‡?o no mesmo per¡odo (retorno da vari vel lRetPer). 
				If lRatInss 	
					nValInss := 0
				EndIf
			Else
				nValInss := 0
			EndIf

			If nMinIns > 0
				lVerMinIn	:= .T.
			Else
				lVerMinIn	:= .F.
			EndIf

			If nValInss < nMinIns
				lInsss:= .T.
			Endif

			If lInsss .And. (If(lFinVldIns, Execblock("FinVldIns",.F.,.F., {} ), .T. ))
				DbSelectArea("SE2")
				RecLock("SE2", .F.)

				If !lRetPer .And. lVerMinIn .And. (nValInss + nTotINSS) < nMinIns
					If lDedInss
						SE2->E2_VALOR	+= SE2->E2_INSS // Somo o valor do imposto no valor do titulo devido ao compras realizar a subtração sem verificar cumulatividade
						SE2->E2_SALDO	+= SE2->E2_INSS
						SE2->E2_VLCRUZ	:= nVlrCruz
					EndIf

					//Verifico se o valor Acumulado somado ao valor do INSS do titulo atual é igual ao valor E2_INSS
					//pois se a soma dos dois está igual é necessario corrigir para não impactar no valor a ser retido no futuro.
					If cMVInsAcpj == "1"
						If SE2->E2_INSS <> 0
							If nValInss + nTotINSS == SE2->E2_INSS
								SE2->E2_VRETINS := nTotINSS
							Else
								SE2->E2_VRETINS := SE2->E2_INSS
							EndIf
						Else
							SE2->E2_VRETINS := nTotINSS
						EndIf
					Else
						SE2->E2_VRETINS := If(SE2->E2_INSS == 0, nTotINSS, SE2->E2_INSS )
					EndIf
					SE2->E2_PRETINS := "1"
					SE2->E2_INSS	:= 0
				EndIf
			EndIf
			lRetPer	:= .F.
		Endif

		If !lIrfMR .And. lIRPFBaixa
			RecLock("SE2",.F.)
			SE2->E2_PRETIRF	:= "1"
		EndIf

		If !lIrfMR .And. ( cOrigem == "MATA100" ) .And. !lIRPFBaixa
			// Ajuste de cumulatividade de IRRF que ultrapassa valor do título
			If SE2->E2_IRRF > SE2->E2_VALOR .And. SE2->E2_VALOR < 0
				SE2->E2_IRRF  += SE2->E2_VALOR - 0.01
				SE2->E2_VALOR := 0.01
				SE2->E2_SALDO := 0.01
			EndIf
		EndIf

		If !lIssMR .And. lCalcIssBx
			If nTotISS > 0 .And. nTotISS <= SuperGetMv("MV_VRETISS",.T.,0)
				SE2->E2_ISS	:= 0
			EndIf
		EndIf
	ElseIf ( cPaisLoc <> "RUS" )
		nVlrCruz := Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,MsDecimais(1)+1,SE2->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))

		DbSelectArea("SE2")
		RecLock("SE2",.F.)
		SE2->E2_VLCRUZ := nVlrCruz
	EndIf
	If ExistBlock("ATUDPPAG")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de Entrada para Atualiza‡”es no SE2   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ExecBlock("ATUDPPAG",.f.,.f.,cOrigem)
	EndIf
	nRegSe2	  := RecNo()
	cPrefixo  := SE2->E2_PREFIXO
	cNum	  := SE2->E2_NUM
	cTipoE2	  := SE2->E2_TIPO
	nValForte := ConvMoeda(SE2->E2_EMISSAO,SE2->E2_VENCTO,SE2->E2_VALOR,GetMv("MV_MCUSTO"))

	// Criado o parametro MV_FORNCD para possibilitar um grande volume de notas SEM LOCK do SA2 para definir, por exemplo, notas de um centro de
	// distruicao (ponto de gargalo)
	If !SE2->E2_TIPO $ MVABATIM .And. cFornCD != SE2->E2_FORNECE + SE2->E2_LOJA .And. lAtuForn
		RecLock(If(lSA2,"SA2","SA1"))
		If ! ( SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG )
			If lSA2 .and. SA2->(!Eof())
				SA2->A2_SALDUP +=Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3,SE2->E2_TXMOEDA),3),2)
				SA2->A2_SALDUPM+=Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,Val(GetMv("MV_MCUSTO")),SE2->E2_EMISSAO,3),3),2)
			EndIf
		ElseIf SE2->E2_TIPO $ MV_CPNEG .and. cPaisLoc = "ARG" .and. funname()== "MATA466N" .and. SA2->(!Eof()) 
			SA2->A2_SALDUP -=Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,1,SE2->E2_EMISSAO,3,SE2->E2_TXMOEDA),3),2)
		ElseIf ( !lSA2 ) .and. SA2->(!Eof())			
			AtuSalDup("-",SE2->E2_VALOR,SE2->E2_MOEDA,SE2->E2_TIPO,,SE2->E2_EMISSAO)
		EndIf
		nValForte:=ConvMoeda(SE2->E2_EMISSAO,SE2->E2_VENCTO,If(lSA2,A2_SALDUP,A1_SALDUP),GetMv("mv_mcusto"))
		nMCusto:=Val(GetMV("MV_MCUSTO"))
		If ( lSA2 ) .AND. SA2->(!Eof())
			DbSelectArea( "SA2" )
			If ( SA2->A2_SALDUPM > A2_MSALDO )
				SA2->A2_MSALDO := SA2->A2_SALDUPM
			EndIf
			SA2->A2_PRICOM  := Iif(SE2->E2_EMISSAO<A2_PRICOM .Or. Empty(SA2->A2_PRICOM),SE2->E2_EMISSAO,SA2->A2_PRICOM)
			SA2->A2_ULTCOM  := Iif(SA2->A2_ULTCOM<SE2->E2_EMISSAO,SE2->E2_EMISSAO,SA2->A2_ULTCOM)
			SA2->A2_NROCOM  := SA2->A2_NROCOM + If( lUpDate,1,0 )
			If ( SA2->A2_MCOMPRA < Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMCusto,SE2->E2_EMISSAO,3),3),2) )
				SA2->A2_MCOMPRA := Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMCusto,SE2->E2_EMISSAO,3),3),2)
			EndIf
			If SubStr(SE2->E2_ORIGEM,1,3) == "FIN"
				SA2->A2_MNOTA   := Max(SA2->A2_MNOTA,Round(NoRound(xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMCusto,SE2->E2_EMISSAO,3),3),2) )
			ElseIf SubStr(cOrigem,1,7) $ "MATA100"
                aArea := SF1->(GetArea())
				DbSelectArea("SF1")
				DbSetOrder(1)
				DbSeek(xFilial("SF1")+SE2->E2_NUM+SE2->E2_PREFIXO+SE2->E2_FORNECE+SE2->E2_LOJA)
				SA2->A2_MNOTA   := Max(SA2->A2_MNOTA,Round(NoRound(xMoeda(SF1->F1_VALBRUT,SE2->E2_MOEDA,nMCusto,SF1->F1_EMISSAO,3),3),2) )
				RestArea(aArea)
			EndIf
		EndIf
		If lSA2
			If lAtuForn
				 SA2->(MsUnlock())
			EndIf
		Else
			SA1->(MsUnlock())
		EndIf
	EndIf

	DbSelectArea( "SE2" )
	cParcela := E2_PARCELA
	dEmissao := E2_EMISSAO
	dVencto	 := E2_VENCREA
	If !lIrfMR
		nIrrf 	 := E2_IRRF
	EndIf
	If !lIssMR
		lValISS	 := (nIss := E2_ISS) > 0
		If lBtrISS
			nBtrISS    := E2_BTRISS
			lValBtrISS := nBtrISS > 0
			cCodServ   := E2_CODSERV
		EndIf
	EndIf
	If !lInsMR
		nInss 	 := E2_INSS
	EndIf
	If !lSestMR
		nSEST 	 := E2_SEST
	EndIf
	If !lCidMR .And. cPaisLoc == "BRA"
		nCIDE 	 := E2_CIDE
	EndIf

	If !lPccMR
		nCofins  := SE2->E2_COFINS
		nPis     := SE2->E2_PIS
		nCsll    := SE2->E2_CSLL

		If lEmpPub
			If (lPCCBaixa  .And. nPis + nCofins + nCsll + nIrrf < nVlMPub) .Or. (!lPCCBaixa .And. lZeraIrrf )
				nPis := nCofins := nCsll := nIrrf := 0
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera titulo de IRRF para PAs 				  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lIrfMR .And. nIrrf > 0 .and. (!lIRPFBaixa .or. (lIRPFBaixa .And. SE2->E2_TIPO $ MVPAGANT))

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Calculo do vencimento do imposto³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If !Empty(aCodR) .And. aScan( aCodR, {|aX|aX[4]=="IRR"})>0 .And. lMT103DRF
			cCodRetIR := aCodR[aScan( aCodR, {|aX|aX[4]=="IRR"})][2]
		Endif

		dVencRea := F050VIMP("IRRF",dEmissao,dEmis1,dVctoReal,cCodRetIr,cTipoFor,lIRPFBaixa)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Grava título do IRRF e informações relacionadas ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		FGrvIRRF(cOrigem,dVencRea,dEmissao,cPrefixo,cNum,cTipoE2,nIrrf,nMoeda,cLa,cGeraDIRF,cCodRetIR,lRatImp,;
		aRatSev,aRatSEZ,nRegSE2,'SE2',lIRPFBaixa,aRecImpos,aRatIRF,@aImpostos )

	EndIf

	//Gravação dos impostos motor retenções
	If __lMotRet .And. Len(aMotRet) > 0
		FinGrvImp("1", nRegSE2, aMotRet, cOrigem, lRatImp, aRatSev, aRatSez, .T., .F., .F., dEmissao, "", "")
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera titulo de INSS 							  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lInsMR .And. nInss > 0
		//Caso inss na baixa nao devo gravar o titulo do imposto na inclusao do titulo pai no financeiro ou em outros modulos.
		If  (!lInssBx) .Or. ( lInssBx .And. !(FwIsInCallStack("FINA050")) .And. Subst(cOrigem,1,4) <> "MATA")
			//Forcar o posicionamento do fornecedor para evitar que o tipo de fornecedor que a funcao fGrvINSS passara para determinar o vencimento do imposto (MP447)
			//seja determinado incorretamente.

			If !Empty(aCodR) .And. aScan( aCodR, {|aX|aX[4]=="INS"})>0 .And. lMT103DRF
				cCodRetIR := aCodR[aScan( aCodR, {|aX|aX[4]=="INS"})][2]
			Endif

			SA2->(dbGoto(nRegSA2))
			FGrvINSS(cPrefixo,cNum,cParcela,cLojaImpos,cOrigem,nMoeda,nRegSED,nRegSE2,dEmissao,dEmis1,dVctoReal,nInss,;
						lRatImp,aRatSev,aRatSez,cGeraDIRF,cCodRetIR,,,aRecImpos)

			If !Empty(SE2->E2_CODRET) .and. SA2->A2_TIPO = "J" .and. nIrrf == 0 .and. ( nPis + nCofins + nCsll ) == 0
				Reclock("SE2", .F.)
				SE2->E2_DIRF := "1"
				SE2->(MsUnlock())
			EndIf
		Endif
	ElseIf !lInsMR .And. nInss = 0
		SA2->(dbGoto(nRegSA2))
		SED->(dbGoto(nRegSED))
		If  !Empty(SE2->E2_CODRET) .And. SE2->E2_DIRF = "1" .And. SA2->A2_RECINSS = "S" .And. SA2->A2_TIPO="F" .And. SED->ED_CALCINS="S"
			Reclock("SE2", .F.)
			SE2->E2_DIRF := "2"
			SE2->(MsUnlock())
		Endif

		If SE2->E2_VRETINS > 0 .And. SA2->A2_RECINSS = "S" .And. SED->ED_CALCINS="S"
			Reclock("SE2", .F.)
			SE2->E2_PRETINS := "1" // Se possui valor a reter, grava 1 pendente de retenção
			SE2->(MsUnlock())
		EndIf
	EndIf

	//Titulo de Pessoa Fisica com natureza para reter Inss mas que não foi gerado o titulo do imposto.
	If !lInsMR .And. !Empty(SE2->E2_CODRET) .And. SA2->A2_TIPO="F" .And. SED->ED_CALCINS="S" .And. ;
					SED->ED_CALCIRF $ "N " .And. SED->ED_CALCISS $ "N " .And. ;
					SED->ED_CALCCSL $ "N " .And. SED->ED_CALCCOF $ "N " .And. SED->ED_CALCPIS $ "N "
		If nInss > 0 .AND. !lInssBx
			Reclock("SE2", .F.)
			SE2->E2_DIRF := "2" //Titulo do imposto Inss foi gerado.
			SE2->(MsUnlock())
		Else
			Reclock("SE2", .F.)
			SE2->E2_DIRF := "1" //Titulo pai retém Inss mas não gerou titulo do imposto.
			SE2->(MsUnlock())
		Endif
	Endif

	// Para títulos PJ que retenham apenas INSS
	If !Empty(SE2->E2_CODRET) .And. SA2->A2_TIPO = "J" .And. SED->ED_CALCINS = "S" .And.;
		SED->ED_CALCIRF = "N" .And. SED->ED_CALCISS = "N" .And. SED->ED_CALCCSL = "N" .And.;
		SED->ED_CALCCOF = "N" .And.	SED->ED_CALCPIS = "N"

		Reclock("SE2", .F.)
			SE2->E2_DIRF := "1"
		SE2->(MsUnlock())
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera titulo de SEST 					   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lSestMR .And. nSEST > 0
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Cria o Fornecedor, caso nao exista 	       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea("SA2")
		If !(DbSeek(xFilial() + cForSEST + cLojaImpos ))
			Reclock("SA2",.T.)
			SA2->A2_FILIAL := cFilial
			SA2->A2_COD 	:= cForSEST
			SA2->A2_LOJA	:= cLojaImpos
			SA2->A2_NOME	:= STR0068  //Servico Social do Transporte
			SA2->A2_NREDUZ :=  "SEST"
			SA2->A2_BAIRRO := "."
			SA2->A2_MUN 	:= "."
			SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
			SA2->A2_End 	:= "."
			SA2->A2_TIPO	:= "J"
			MsUnlock()
			FKCOMMIT()
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Cria a natureza SEST caso nao exista		  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cNatureza		:= cSEST
		cNatureza		:= cNatureza+Space(10-Len(cNatureza))
		DbSelectArea("SED")
		If !DbSeek(cFilial+cNatureza)
			RecLock("SED",.T.)
			SED->ED_FILIAL  := cFilial
			SED->ED_CODIGO  := cNatureza
			SED->ED_CALCIRF := "N"
			SED->ED_CALCISS := "N"
			SED->ED_CALCINS := "N"
			SED->ED_CALCCSL := "N"
			SED->ED_CALCCOF := "N"
			SED->ED_CALCPIS := "N"
			SED->ED_DESCRIC := STR0068 //Servico Social do Transporte
			SED->ED_TIPO	:= "2"
			MsUnlock()
			Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
			FKCOMMIT()
		EndIf
		DbGoTo(nRegSED)

		cParcela := STRZERO(1,aTamParc[1])
		While .T.
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ VerIfica se ja' ha' titulo de SEST com esta numera‡„o ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SE2")
			DbSetOrder(1)
			If (DbSeek(cFilial+cPrefixo+cNum+cParcela+"SES"+cForSEST))
				cParcela := Soma1( cParcela,,.t. )
				Loop
			EndIf
			Exit
		End
		DbGoTo( nRegSe2 )

		// Calcula o vencto do imposto
		// Na mesma data do titulo de INSS
		dVencRea := F050VIMP("INSS",dEmissao,dEmis1,dVctoReal,,cTipoFor)

		RecLock("SE2",.T.)
		SE2->E2_FILIAL  := xFilial()
		SE2->E2_PREFIXO := cPrefixo
		SE2->E2_NUM 	 := cNum
		SE2->E2_PARCELA := cParcela
		SE2->E2_TIPO	 := "SES"
		SE2->E2_EMISSAO := dEmissao
		SE2->E2_VALOR	 := nSEST
		SE2->E2_VENCREA := dVencrea
		SE2->E2_SALDO	 := nSEST
		SE2->E2_VENCTO  := dVencRea
		SE2->E2_VENCORI := dVencRea
		SE2->E2_MOEDA	 := If(cPaisLoc=="BRA",1,nMoeda)
		SE2->E2_EMIS1	 := dDataBase
		SE2->E2_FORNECE := cForSEST
		SE2->E2_VLCRUZ  := Round( SE2->E2_VALOR, MsDecimais(1) )
		SE2->E2_LOJA	 := SA2->A2_LOJA
		SE2->E2_NOMFOR  := SA2->A2_NREDUZ
		SE2->E2_ORIGEM  := cOrigem
		SE2->E2_NATUREZ := cNatureza
		SE2->E2_LA      := "S"
		SE2->E2_TITPAI  := cTitPai
		SE2->E2_FORMPAG := SA2->A2_FORMPAG
		If !Empty(cFilDeb)
			SE2->E2_FILDEB := cFilDeb
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava a filial de origem quando existir o campo no SE2            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SE2->E2_FILORIG := cFilorig //filial origem do titulo pai
		SE2->E2_MULTNAT := cMultNat
		SE2->E2_CODAPRO := cCodAprov
		//Grava Retenção INSS
		SE2->E2_RETINS := GetAdvFval("SE2","E2_RETINS",cTitPai,1,"")

		//Grava CNPJ da Retenção INSS
		cForPai	:= GetAdvFval("SE2","E2_FORNECE",cTitPai,1,"")
		cLojPAi	:= GetAdvFval("SE2","E2_LOJA",cTitPai,1,"")
		cTipoFor 	:= ALLTRIM(GetAdvFval("SA2","A2_TIPO",xFilial("SA2")+cForPai+cLojPAi,1,""))
		If cTipoFor == "J"
			cCNPJRET := GetAdvFval("SA2","A2_CGC",xFilial("SA2")+cForPai+cLojPAi,1,"")
		Else
			cCNPJRET := GetAdvFval("SM0","M0_CGC",cEmpAnt+xFilial("SE2"),1,"")
		EndIf
		cRETINS := GetAdvFval("SE2","E2_RETINS",xFilial("SE2")+cPrefixo+cNum+cParcela,1,"")

		SE2->E2_CNPJRET := cCNPJRET
		MsUnlock()
		FKCOMMIT()

        if lPLSTITPF
            PLSTITPF('SE2',cTitPai)
        endIf

		AADD(aRecImpos,{"SE2",Recno()})

		If ExistBlock("F050SES")
			Execblock("F050SES",.F.,.F.,nRegSE2)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava lançamento do imposto SEST/SENAT no SIGAPCO se a rotina foi chamada do contas a pagar ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If "FINA050" $ cOrigem
			PCODetLan("000002","08","FINA050")
		EndIf
		// Se rateia os impostos, grava o rateio multipla natureza/centro de custo
		If lRatImp
			// Grava SEV e SEZ dos impostos, baseado nos percentuais do rateio do titulo principal
			GrvSevSezImp(aRatSev,aRatSez,SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_VALOR)
		Else
			AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"))
		Endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava parcela do SEST na parcela do titulo ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea( "SE2" )
		DbGoTo( nRegSe2 )
		Reclock( "SE2" ,.F.)
		SE2->E2_PARCSES := cParcela
		MsUnlock()

	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera titulo de CIDE 					   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lCidMR .And. nCIDE > 0

		// Calcula o vencto do imposto
		dVencRea := F050VIMP("CIDE",dEmissao,dEmis1,dVctoReal)

		// Gravação do Título de CIDE
		nRecTit := FGrvCIDE( nCIDE, dEmissao, dVencRea, nRegSe2, , cOrigem )

        If lPLSTITPF
            PLSTITPF('SE2',cTitPai)
		endIf

		AADD(aRecImpos,{"SE2",nRecTit})

		// Se rateia os impostos, grava o rateio multipla natureza/centro de custo
		If lRatImp
			// Grava SEV e SEZ dos impostos, baseado nos percentuais do rateio do titulo principal
			GrvSevSezImp(aRatSev,aRatSez,SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_VALOR)
		Else
			AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"))
		EndIf

	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera titulo de ISS						   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lIssMR .And. (( lValISS .And. (!lCalcIssBx .or. (lCalcIssBx .And. SE2->E2_TIPO $ MVPAGANT))) .or. lValBtrISS)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Cria o fornecedor, caso nao exista 		   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lValISS
			DbSelectArea("SA2")
			MsSeek(cFilial+cForLojISS)
			If ( EOF() )
				Reclock("SA2",.T.)
				SA2->A2_FILIAL   := cFilial
				SA2->A2_COD 	  := Left(cForLojISS,Len(SA2->A2_COD))
				SA2->A2_LOJA	  := Right(cForLojISS,Len(SA2->A2_LOJA))
				SA2->A2_NOME	  := cNome //"MUNICIPIO"
				SA2->A2_NREDUZ   := cNome //"MUNICIPIO"
				SA2->A2_BAIRRO   := "."
				SA2->A2_MUN 	  := "."
				SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
				SA2->A2_End 	  := "."
				MsUnlock()
				FKCOMMIT()
			EndIf

			cParcela := STRZERO(1,aTamParc[1])
			While ( .T. )
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ VerIfica se ja' ha' titulo de ISS com esta numera‡„o ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SE2")
				DbSetOrder(1)
				If (DbSeek(cFilial+cPrefixo+cNum+cParcela+"ISS"+cForLojISS))
					cParcela := Soma1( cParcela,,.t.)
					Loop
				EndIf
				Exit
			EndDo
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Cria a natureza ISS caso nao exista		  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cNatureza	:= &(GetMv("MV_ISS"))
		cNatureza	:= cNatureza + Space( 10 - Len( cNatureza ) )
		cVencIss	:= GetNewPar("MV_VENCISS","E")
		nMesIss		:= GetNewPar( "MV_MESISS", 1 )
		nMesIss		:= If( nMesIss > 0, nMesIss, 1 )
		If Empty(dVenISS)
			Do Case
				Case nDiaUtIss > 0 //Vencimento do ISS deve ser gerado por dias uteis.

					nMesIss		:= If( nMesIss == 1, 0, nMesIss - 1 )
					
					If lCalcIssBx // Mes subsequente de acordo com o momento de retenção do imposto.
						dVenISS	:= LastDay( MonthSum( dVencto, nMesIss ) )
					Else
						dVenISS	:= LastDay( MonthSum( dEmissao, nMesIss ) )
					Endif

					For nI:= 1 To nDiaUtIss
						dVenISS ++
						dVenISS := DataValida(dVenISS)
					Next nI

				Case cVencIss == "E" //E=Emissão

					dVenISS		:= MonthSum( dEmissao, nMesIss )

					nTamData	:= If( Len( Dtoc( dVenISS ) ) == 10, 7, 5 )

					//Caso o mes do vcto seja Fevereiro e o parametro MV_DIAISS estiver 30 ou 31
					If Month(dVenISS) == 2 .And. cDiaISS $ "30/31"
						dVenISS := LastDay(dVenISS)
					Else
						If !Empty(dDtRec)
							dVenISS	:= Ctod( StrZero( dDtRec, 2 ) + "/" + Subs( Dtoc( dVenISS ), 4, nTamData ) )
						Else
							dVenISS	:= Ctod( cDiaISS + "/" + Subs( Dtoc( dVenISS ), 4, nTamData ) )
						Endif
					Endif

				Case cVencIss == "Q" //Ultimo dia util da quinzena subsequente a dEmissao
					
					If Day(dEmissao) <= 15
						nMesIss	:= If( nMesIss == 1, 0, nMesIss - 1 )
						dVenISS	:= LastDay( MonthSum( dEmissao, nMesIss ) )
						dVenISS := DataValida( dVenISS, .F. )
					Else
						//dVenISS := DataValida( ( LastDay(dEmissao) + 1 ) + 14, .F. )
						dVenISS := DataValida( FirstDate( MonthSum( dEmissao, nMesIss ) ) + 14, .F. )
					EndIf

				Case cVencIss == "U" //Ultimo dia util do mes subsequente da dEmissao
					//ok
					dVenISS := DataValida( LastDay( MonthSum( dEmissao, nMesIss ) ), .F. )
					
				Case cVencIss == "D"
					
					dVenISS		:= FirstDay( MonthSum( dEmissao, nMesIss ) )
					nDiaUtil	:= nDiaISS
					
					For nDia := 1 To nDiaUtil-1
						If !(dVenISS == DataValida(dVenISS,.T.))
							nDia-=1
						EndIf
						dVenISS+=1
					Next nDia

				Case cVencIss == "F" //Qtd de dia do parametro MV_DIAISS apos o fechamento da quinzena.
					/*F =	Se a data de emissão for menor que 15 (primeira quinzena) a data 
							de vencimento será 15 mais o conteúdo do MV_DIAISS (considerando 
							o primeiro dia do mês na conta), se a data de emissão for maior que 
							15 (segunda quinzena) será no dia informado no MV_DIAISS do mês subsequente.*/

					If Day(dEmissao) <= 15
						nMesIss	:= If( nMesIss == 1, 0, nMesIss - 1 )
						dVenISS := CtoD("15" + SUBSTR( DtoC( MonthSum( dEmissao, nMesIss ) ), 3, Len( DtoC( dEmissao ) ) ) ) + nDiaISS
					Else
						nMesIss	:= If( nMesIss == 1, 0, nMesIss - 1 )
						dVenISS := LastDay( MonthSum( dEmissao, nMesIss ) ) + nDiaISS
					EndIf

				OtherWise //V=Vencimento
					//Ok
					dVenISS		:= MonthSum( dVencto, nMesIss )
					nTamData	:= If( Len( Dtoc(dVenISS) ) == 10, 7, 5 )
					dVenISS		:= Ctod( cDiaISS + "/" + Subs( Dtoc(dVenISS), 4, nTamData ) )

			EndCase
		EndIf

		dVencRIss := DataValida(dVenISS,IIF(lVcAntIss,.F.,.T.))
		dVenISS := IIF(dVenIss > dVencRIss, dVencRISS, dVenIss)

		If Alltrim(SM0->M0_ESTENT) == "SC" .And. ;
			( ( Len( Alltrim( SM0->M0_CODMUN ) ) == 5 .And. Alltrim( SM0->M0_CODMUN ) == "09102" ) .Or. ( Len( Alltrim( SM0->M0_CODMUN ) ) == 7 .And. SubStr( Alltrim( SM0->M0_CODMUN ) , 3 , 5 ) == "09102" ) )
			aAreaFor:= getArea("SA2")
			DbSelectArea("SA2")
			DbSetOrder(1)
			If SA2->(DbSeek(xFilial("SA2")+cFornSe2+cLojaSe2)) .And. Alltrim(SA2->A2_EST) == "SC"
				dVenISS := fCRetCal(6,dEmissao)
				dVencRIss := dVenISS
			EndIf
			restArea(aAreaFor)
		EndIf

		dVencRea := DataValida(dVenISS,.T.)
		If lValISS
			RecLock("SE2",.T.)
			SE2->E2_FILIAL  := cFilial
			SE2->E2_PREFIXO := cPrefixo
			SE2->E2_NUM		:= cNum
			SE2->E2_PARCELA := cParcela
			SE2->E2_TIPO	:= MVISS
			SE2->E2_EMISSAO := dEmissao
			SE2->E2_EMIS1	:= dDataBase
			SE2->E2_VALOR	:= nIss
			SE2->E2_VENCTO  := dVenISS
			SE2->E2_SALDO	:= nIss
			SE2->E2_VENCREA := dVencRIss
			SE2->E2_VENCORI := dVenISS
			SE2->E2_FORNECE := Left(cForLojISS,Len(SE2->E2_FORNECE))
			SE2->E2_LOJA    := Right(cForLojISS,Len(SE2->E2_LOJA))
			SE2->E2_NOMFOR  := SA2->A2_NREDUZ
			SE2->E2_MOEDA	:= If(cPaisLoc=="BRA",1,nMoeda)
			SE2->E2_VLCRUZ  := Round(SE2->E2_VALOR, MsDecimais(1))
			SE2->E2_ORIGEM  := cOrigem
			SE2->E2_NATUREZ := cNatureza
			SE2->E2_LA      := cLA			// Herda do principal
			SE2->E2_FORMPAG := SA2->A2_FORMPAG
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava a filial de origem quando existir o campo no SE2            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SE2->E2_FILORIG := cFilorig //filial origem do titulo pai

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava o fornecedor de origem quando existir o campo no SE2        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SE2->E2_TITPAI  := cTitPai
			SE2->E2_MULTNAT := cMultNat
			SE2->E2_CODAPRO := cCodAprov
			If lBtrISS
				SE2->E2_CODSERV := cCodServ
			EndIf
			MsUnlock()
			FKCOMMIT()

            if lPLSTITPF
                PLSTITPF('SE2',cTitPai)
            endIf

			AADD(aRecImpos,{"SE2",Recno()})

			If ExistBlock("F050ISS")
				Execblock("F050ISS",.F.,.F.,nRegSE2)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava lançamento do imposto ISS no SIGAPCO se a rotina foi chamada do contas a pagar ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If "FINA050" $ cOrigem
				PCODetLan("000002","09","FINA050")
			EndIf
			// Se rateia os impostos, grava o rateio multipla natureza/centro de custo
			If lRatImp
				// Grava SEV e SEZ dos impostos, baseado nos percentuais do rateio do titulo principal
				GrvSevSezImp(aRatSev,aRatSez,SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_VALOR)
			Else
				AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"))
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava parcela do IRF na parcela do titulo  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea( "SE2" )
			DbGoTo( nRegSe2 )
			Reclock( "SE2" , .F. )
			SE2->E2_PARCISS := cParcela
			MsUnlock()
		Endif

		If lValBtrISS
			
			If Len(aForISSCPM) >= 2
				cCodForISS := aForISSCPM[1]
				cLojForISS := aForISSCPM[2]
				FwFreeArray(aForISSCPM)
				lContinua := .T.
			Else
				lContinua := .F.
			EndIf
			
			If lContinua
				cParcela := STRZERO( 1, aTamParc[1] )
				lParcLivre := .F.			
				SE2->( dbSetOrder(1) ) //E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA			
				While !lParcLivre
					If SE2->( msSeek( cFilial + cPrefixo + cNum + cParcela + "ISS" + cCodForISS + cLojForISS ) )
						cParcela := Soma1( cParcela,, .T. )
					Else
						lParcLivre := .T.
					EndIf
				EndDo
	
				// Grava TX da bitributacao do ISS
				RecLock("SE2", .T.)
				SE2->E2_FILIAL  := cFilial
				SE2->E2_PREFIXO := cPrefixo
				SE2->E2_NUM		:= cNum
				SE2->E2_PARCELA := cParcela
				SE2->E2_TIPO	:= MVISS
				SE2->E2_EMISSAO := dEmissao
				SE2->E2_EMIS1	:= dDataBase
				SE2->E2_VALOR	:= nBtrISS
				SE2->E2_VENCTO  := dVenISS
				SE2->E2_SALDO	:= nBtrISS
				SE2->E2_VENCREA := dVencRIss
				SE2->E2_VENCORI := dVenISS
				SE2->E2_FORNECE := cCodForISS
				SE2->E2_LOJA    := cLojForISS
				SE2->E2_NOMFOR  := SA2->A2_NREDUZ
				SE2->E2_MOEDA	:= Iif(cPaisLoc=="BRA",1,nMoeda)
				SE2->E2_VLCRUZ  := Round(SE2->E2_VALOR, MsDecimais(1))
				SE2->E2_ORIGEM  := cOrigem
				SE2->E2_NATUREZ := cNatureza
				SE2->E2_LA      := cLA // Herda do principal
				SE2->E2_FORMPAG := SA2->A2_FORMPAG
				SE2->E2_FILORIG := cFilorig //filial origem do titulo pai
				SE2->E2_TITPAI 	:= cTitPai
				SE2->E2_MULTNAT := cMultNat
				SE2->E2_CODAPRO := cCodAprov
				If lBtrISS
					SE2->E2_CODSERV := cCodServ
				EndIf
				SE2->( MsUnlock() )
				FKCOMMIT()
	
	            if lPLSTITPF
	                PLSTITPF('SE2',cTitPai)
	            endIf
	
				AADD(aRecImpos,{"SE2",Recno()})
	
				AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"))
			EndIf
			
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera titulo Funrural					   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nValFun := Iif(Type("nValFun")=="U",0,nValFun)

	If ( nValFun > 0 )
		cParcela := STRZERO(1,aTamParc[1])
		While .T.
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ VerIfica se ja' ha' titulo de FunRural com esta numera‡„o ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SE2")
			DbSetOrder(1)
			If (DbSeek(cFilial + cPrefixo + cNum + cParcela + "TX " + PadR(cCodMVINS,6)))
				cParcela := Soma1( cParcela,,.t. )
				Loop
			EndIf
			Exit
		End
		dVenFun := dEmissao + 28
		If Month(dVenFun) == Month(dEmissao)
			dVenFun := dVenFun+28
		EndIf
		nTamData := Iif(Len(Dtoc(dVenFun)) == 10, 7, 5)
		dVenFun	:= Ctod(StrZero(GetMv("mv_DiaFun"),2)+"/"+Subs(Dtoc(dVenFun),4,nTamData))
		dVencRea := DataValida(dVenFun,.F.)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Cria o Fornecedor, caso nao exista 		   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea("SA2")
		If !(MsSeek(xFilial() + cCodMVINS + Space(Len(A2_COD) - Len(cCodMVINS)) + cLojaImpos))
			Reclock("SA2",.T.)
			SA2->A2_FILIAL := cFilial
			SA2->A2_COD 	:= cCodMVINS
			SA2->A2_LOJA	:= cLojaImpos
			SA2->A2_NOME	:= "Instituto Nacional de Previdencia Social"
			SA2->A2_NREDUZ := "INPS"
			SA2->A2_BAIRRO := "."
			SA2->A2_MUN 	:= "."
			SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
			SA2->A2_End 	:= "."
			SA2->A2_TIPO	:= "J"
			MsUnlock()
			FKCOMMIT()
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Cria a natureza CSS caso nao exista		   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cNatureza		:= GetMv("MV_CSS")
		IF ExistBlock("NTFUNR")
			cNatureza   := ExecBlock("NTFUNR",.f.,.f.,{cOrigem,cPrefixo})
		Endif
		cNatureza		:= cNatureza+Space(10-Len(cNatureza))
		DbSelectArea("SED")
		DbSeek(cFilial+cNatureza)
		If ( EOF() )
			RecLock("SED",.T.)
			SED->ED_FILIAL 	:= cFilial
			SED->ED_CODIGO 	:= cNatureza
			SED->ED_CALCIRF	:= "N"
			SED->ED_CALCISS	:= "N"
			SED->ED_CALCINS	:= "N"
			SED->ED_CALCCSL	:= "N"
			SED->ED_CALCCOF	:= "N"
			SED->ED_CALCPIS	:= "N"
			SED->ED_DESCRIC	:= "CONTRIBUICAO SEGURIDADE SOCIAL"
			SED->ED_TIPO	:= "2"
			MsUnlock()
			Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
			FKCOMMIT()
		EndIf

		DbSelectArea("SE2")
		RecLock("SE2",.T.)
		SE2->E2_FILIAL 	:= cFilial
		SE2->E2_PREFIXO  := cPrefixo
		SE2->E2_NUM 	  := cNum
		SE2->E2_PARCELA  := cParcela
		SE2->E2_TIPO	  := MVTAXA
		SE2->E2_EMISSAO  := dEmissao
		SE2->E2_VALOR	  := nValFun
		SE2->E2_VENCREA  := dVencrea
		SE2->E2_SALDO	  := nValFun
		SE2->E2_VENCTO   := dVencRea
		SE2->E2_VENCORI  := dVencRea
		SE2->E2_MOEDA	  := If(cPaisLoc=="BRA",1,nMoeda)
		SE2->E2_EMIS1	  := dDataBase
		SE2->E2_FORNECE  := cCodMVINS
		SE2->E2_VLCRUZ   := Round( SE2->E2_VALOR, MsDecimais(1) )
		SE2->E2_LOJA	  := SA2->A2_LOJA
	 	SE2->E2_NOMFOR   := SA2->A2_NREDUZ
		SE2->E2_ORIGEM   := cOrigem
		SE2->E2_NATUREZ  := cNatureza
		SE2->E2_LA       := cLA			// Herda do principal
		SE2->E2_FILORIG := cFilorig //filial origem do titulo pai
		SE2->E2_TITPAI  := cTitPai
		SE2->E2_MULTNAT  := cMultNat
		SE2->E2_CODAPRO := cCodAprov
		SE2->E2_FORMPAG := SA2->A2_FORMPAG
		MsUnlock()
		FKCOMMIT()

        if lPLSTITPF
            PLSTITPF('SE2',cTitPai)
        endIf

		AADD(aRecImpos,{"SE2",Recno()})

		If lM050CSSP
			ExecBlock("M050CSSP",.F.,.F.,nRegSe2)
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava parcela do CSS na parcela do titulo  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea( "SE2" )
		DbGoTo( nRegSe2 )
		Reclock( "SE2" , .F. )
		SE2->E2_PARCCSS := cParcela
		MsUnlock()
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera titulo INSS Patronal				   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nValINP := Iif(Type("nValINP")=="U",0,nValINP)

	If ( nValINP > 0 ) .Or. ( Type("lF050Auto") != "U" .And. lF050Auto .And. (lCalcINP .And. SED->ED_CALCINP == "1") )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Cria o Fornecedor, caso nao exista 		   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nValINP == 0 .And. lPercINP
			nValINP := ( ( M->E2_BASEINS * SED->ED_PERCINP ) / 100 )
		EndIf
		DbSelectArea("SA2")
		If !(MsSeek(xFilial()+cCodINSS+Space(Len(A2_COD)-Len(cCodINSS))+cLojaImpos))
			Reclock("SA2",.T.)
			SA2->A2_FILIAL := xFilial("SA2")
			SA2->A2_COD 	:= cCodINSS
			SA2->A2_LOJA	:= cLojaImpos
			SA2->A2_NOME	:= "Instituto Nacional de Previdencia Social"
			SA2->A2_NREDUZ := "INPS"
			SA2->A2_BAIRRO := "."
			SA2->A2_MUN 	:= "."
			SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
			SA2->A2_End 	:= "."
			SA2->A2_TIPO	:= "J"
			MsUnlock()
			FKCOMMIT()
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Cria a natureza INSS caso nao exista		  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cNatureza	:= &(SuperGetMv("MV_INSP",,"'INSP'"))
		cNatureza	:= cNatureza+Space(10-Len(cNatureza))
		DbSelectArea("SED")
		If !DbSeek(cFilial+cNatureza)
			RecLock("SED",.T.)
			SED->ED_FILIAL  := cFilial
			SED->ED_CODIGO  := cNatureza
			SED->ED_CALCIRF := "N"
			SED->ED_CALCISS := "N"
			SED->ED_CALCINS := "N"
			SED->ED_CALCCSL := "N"
			SED->ED_CALCCOF := "N"
			SED->ED_CALCPIS := "N"
			SED->ED_DESCRIC := "RETENCAO P/ SEGURIDADE SOCIAL"
			SED->ED_TIPO	:= "2"
			MsUnlock()
			Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
			FKCOMMIT()
		EndIf
		DbGoTo(nRegSED)

		cParcela := STRZERO(1,aTamParc[1])
		DbSelectArea("SE2")
		DbSetOrder(1)
		While .T.
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ VerIfica se ja' ha' titulo de INSS com esta numera‡„o ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (DbSeek(cFilial + cPrefixo + cNum + cParcela + "INP" + PadR(cCodMVINS,6)))
				cParcela := Soma1( cParcela,,.t. )
				Loop
			EndIf
			Exit
		End

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava a parcela do INSS no titulo pai fazendo ³
		//³ a amarracao titulo x titulo INSS			  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbGoTo( nRegSe2 )
		cLa := SE2->E2_LA

		// Calcula o vencto do imposto
		dVencRea := F050VIMP("INSS",dEmissao,dEmis1,dVctoReal,cCodRetIr,cTipoFor)

		RecLock("SE2",.T.)
		SE2->E2_FILIAL  := xFilial()
		SE2->E2_PREFIXO := cPrefixo
		SE2->E2_NUM 	 := cNum
		SE2->E2_PARCELA := cParcela
		SE2->E2_TIPO	 := "INP"
		SE2->E2_EMISSAO := dEmissao
		SE2->E2_VALOR	 := nValINP
		SE2->E2_VENCREA := dVencrea
		SE2->E2_SALDO	 := nValINP
		SE2->E2_VENCTO  := dVencRea
		SE2->E2_VENCORI := dVencRea
		SE2->E2_MOEDA	 := If(cPaisLoc=="BRA",1,nMoeda)
		SE2->E2_EMIS1	 := dDataBase
		SE2->E2_FORNECE := cCodMVINS
		SE2->E2_VLCRUZ  := Round( SE2->E2_VALOR, MsDecimais(1) )
		SE2->E2_LOJA	 := SA2->A2_LOJA
		SE2->E2_NOMFOR  := SA2->A2_NREDUZ
		SE2->E2_ORIGEM  := cOrigem
		SE2->E2_NATUREZ := cNatureza
		SE2->E2_LA      := cLA			// Herda do principal
		SE2->E2_FORMPAG := SA2->A2_FORMPAG

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava a filial de origem quando existir o campo no SE2            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SE2->E2_FILORIG := cFilorig //filial origem do titulo pai


		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava os dados do titulo de origem do imposto se existir o campo no SE2 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SE2->E2_TITPAI := cTitPai


		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o campo E2_MULTNAT = '1' para que seja possivel a        ³
		//³ visualizacao do roteio atraves da rotina FINA050 (FA050Rateio)    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lRatImp .And. lCallMT103 .And. SuperGetMV("MV_MULNATP",.F.,.F.)
			SE2->E2_MULTNAT := "1"
		EndIf

		SE2->(MsUnlock())
		FKCOMMIT()

        if lPLSTITPF
            PLSTITPF('SE2',cTitPai)
        endIf

		AADD(aRecImpos,{"SE2",Recno()})

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava lançamento do imposto INSS no SIGAPCO se a rotina foi chamada do contas a pagar ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		// Se rateia os impostos, grava o rateio multipla natureza/centro de custo
		If lRatImp
			// Grava SEV e SEZ dos impostos, baseado nos percentuais do rateio do titulo principal
			GrvSevSezImp(aRatSev,aRatSez,SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_VALOR)
		Else
			AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"))
		Endif
		DbSelectArea( "SE2" )
		DbGoTo( nRegSE2 )
	EndIf

	// Posiciono novamente no fornecedor do título principal
	DbSelectArea("SA2")
	DbGoTo( nRegSA2 )

	//Gravacao dos titulos de Pis, Cofins e Csll
	If !lPccBaixa
		FGrvImpPcc(nPis,nCofins,nCsll,nRegSe2,.T.,lRtPICFCS,"",cOrigem,nMoeda,cGeraDirf,nIrrf,,lRatImp,aRatSev,aRatSez,lPccMR,lIrfMR,lInsMR,lIssMR,lCidMR,lSestMR)
	Endif
EndIf

DbSelectArea("SA2")
DbGoTo( nRegSA2 )

If cPaisLoc == "BRA"
	cRecFet := SA2->A2_RECFET
	cRecFab := SA2->A2_RFABOV
	cRecFac := SA2->A2_RFACS
	cRecIMA := SA2->A2_RIMAMT
EndIf
nFethab := SE2->E2_FETHAB
nFabov  := SE2->E2_FABOV
nFacs   := SE2->E2_FACS

If lFamad == Nil
	lFamad := SA2->(ColumnPos("A2_RECFMD")) > 0 .and. SE2->(ColumnPos("E2_FAMAD")) > 0
EndIf

If lFamad
	cRecFmd := SA2->A2_RECFMD
	nFamad  := SE2->E2_FAMAD
Endif

If lCposIMA
	nIma := SE2->E2_IMA
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Gera titulo de FETHAB                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lAgFETHA
	If nFethab > 0
		If cRecFet=="2"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria o Fornecedor, caso nao exista 		   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SA2")
			SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
			If ( EOF() )
				Reclock("SA2",.T.)
				SA2->A2_FILIAL := cFilial
				SA2->A2_COD 	:= cCodMVRES
				SA2->A2_LOJA	:= cLojaImpos
				SA2->A2_NOME	:= "RECEITA ESTADUAL"
				SA2->A2_NREDUZ := "RECEITA"
				SA2->A2_BAIRRO := "."
				SA2->A2_MUN 	:= "."
				SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
				SA2->A2_End 	:= "."
				SA2->A2_TIPO	:= "J"
				MsUnlock()
			EndIf

			cFornUni  := SA2->A2_COD
			cLojaUni  := SA2->A2_LOJA
			cPrefixo  := SE2->E2_PREFIXO
			cNum	  := SE2->E2_NUM
			cTipoE2   := SE2->E2_TIPO
			dEmissao  := SE2->E2_EMISSAO
			dEmis1	  := SE2->E2_EMIS1
			dVctoReal := SE2->E2_VENCREA

			DbSelectArea("SE2")
			SE2->(DbSetOrder(1))
			aTamParcI := TamSx3("E2_PARCELA")
			cParcFet  := StrZero(1,aTamParcI[1])
			While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFet + MVTAXA + PadR(cCodMVRES,nTamFor) + cLojaImpos)
				cParcFet := Soma1(cParcFet,aTamParcI[1])
			EndDo

			RecLock("SE2",.T.)
			SE2->E2_FILIAL 	:= cFilial
			SE2->E2_FILORIG := cFilAnt
			SE2->E2_PREFIXO	:= cPrefixo
			SE2->E2_NUM    	:= cNum
			SE2->E2_PARCELA	:= cParcFet
			SE2->E2_TIPO 	:= MVTAXA
			SE2->E2_EMISSAO	:= dEmissao
			SE2->E2_EMIS1  	:= dDataBase
			SE2->E2_VALOR  	:= nFethab+nFabov+nFacs+nFamad 
			SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
			SE2->E2_SALDO  	:= nFethab+nFabov+nFacs+nFamad
			SE2->E2_VENCREA	:= DTVenIcms()
			SE2->E2_VENCORI	:= dEmissao
			SE2->E2_FORNECE	:= cCodMVRES
			SE2->E2_LOJA   	:= cLojaImpos
			SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
			SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
			SE2->E2_VLCRUZ 	:= Round(nFethab+nFabov+nFacs+nFamad, MsDecimais(1) )
			SE2->E2_ORIGEM 	:= Upper(cOrigem)
			cNatureza      	:= SuperGetMV("MV_FETNAT",.F.,"FETHAB")
			IF ExistBlock("NTFETHAB")
				cNatureza   := 	ExecBlock("NTFETHAB",.f.,.f.,{cOrigem,cPrefixo})
			Endif
			SE2->E2_NATUREZ	:= Alltrim(cNatureza)
			SE2->E2_CODAPRO := cCodAprov
			SE2->E2_FORMPAG := SA2->A2_FORMPAG
			SE2->E2_TITPAI  := cTitPai
			MsUnLock()

            if lPLSTITPF
                PLSTITPF('SE2',cTitPai)
            endIf

			AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"))
			AADD(aRecImpos,{"SE2",Recno()})

			//Gravar a parcela do Fethab no titulo principal
			DbSelectArea("SE2")
			DbGoTo( nRegSe2 )
			Reclock( "SE2" , .F. )
			SE2->E2_PARCFET := cParcFet
			MsUnlock()

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria a natureza Fethab caso nao exista     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SED")
			If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
				RecLock("SED",.T.)
				SED->ED_FILIAL  := cFilial
				SED->ED_CODIGO  := cNatureza
				SED->ED_CALCIRF := "N"
				SED->ED_CALCISS := "N"
				SED->ED_CALCINS := "N"
				SED->ED_CALCCSL := "N"
				SED->ED_CALCCOF := "N"
				SED->ED_CALCPIS := "N"
				SED->ED_DESCRIC := "FETHAB"
				SED->ED_TIPO	:= "2"
				MsUnlock()
				Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera titulo de IMA                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nIMA > 0
		If cPaisLoc == "BRA" .And. cRecIMA == "2"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria o Fornecedor, caso nao exista 		   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SA2")
			SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
			If ( EOF() )
				Reclock("SA2",.T.)
				SA2->A2_FILIAL 	:= cFilial
				SA2->A2_COD 	:= cCodMVRES
				SA2->A2_LOJA	:= cLojaImpos
				SA2->A2_NOME	:= "RECEITA ESTADUAL"
				SA2->A2_NREDUZ	:= "RECEITA"
				SA2->A2_BAIRRO 	:= "."
				SA2->A2_MUN 	:= "."
				SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
				SA2->A2_End 	:= "."
				SA2->A2_TIPO	:= "J"
				MsUnlock()
			EndIf

			cFornUni  := SA2->A2_COD
			cLojaUni  := SA2->A2_LOJA
			cPrefixo  := SE2->E2_PREFIXO
			cNum	  := SE2->E2_NUM
			cTipoE2   := SE2->E2_TIPO
			dEmissao  := SE2->E2_EMISSAO
			dEmis1	  := SE2->E2_EMIS1
			dVctoReal := SE2->E2_VENCREA

			DbSelectArea("SE2")
			SE2->(DbSetOrder(1))
			aTamParcI := TamSx3("E2_PARCELA")
			cParcIMA  := SE2->E2_PARCELA

			While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcIMA + MVTAXA + PadR(cCodMVRES,nTamFor) + cLojaImpos)
				cParcIMA := Soma1(cParcIMA,aTamParcI[1])
			EndDo

			RecLock("SE2",.T.)
			SE2->E2_FILIAL 	:= cFilial
			SE2->E2_FILORIG := cFilAnt
			SE2->E2_PREFIXO	:= cPrefixo
			SE2->E2_NUM    	:= cNum
			SE2->E2_PARCELA	:= cParcIMA
			SE2->E2_TIPO 	:= MVTAXA
			SE2->E2_EMISSAO	:= dEmissao
			SE2->E2_EMIS1  	:= dDataBase
			SE2->E2_VALOR  	:= nIMA
			SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do IMA, coincidem com o vencimento do ICMS
			SE2->E2_SALDO  	:= nIMA
			SE2->E2_VENCREA	:= DTVenIcms()
			SE2->E2_VENCORI	:= dEmissao
			SE2->E2_FORNECE	:= cCodMVRES
			SE2->E2_LOJA   	:= cLojaImpos
			SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
			SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
			SE2->E2_VLCRUZ 	:= Round(nIMA, MsDecimais(1) )
			SE2->E2_ORIGEM 	:= Upper(cOrigem)
			cNatureza      	:= SuperGetMV("MV_IMANAT",.F.,"IMA")
			SE2->E2_NATUREZ	:= Alltrim(cNatureza)
			SE2->E2_CODAPRO := cCodAprov
			SE2->E2_FORMPAG := SA2->A2_FORMPAG
			SE2->E2_TITPAI  := cTitPai

			If lCposIMA
				SE2->E2_IMA		:= Round(nIma,MsDecimais(1))
				SE2->E2_PARCIMA := cParcIMA
			Endif

			MsUnLock()

            if lPLSTITPF
                PLSTITPF('SE2',cTitPai)
            endIf

			AADD(aRecImpos,{"SE2",Recno()})

			//Gravar a parcela do IMA no titulo principal
			If lCposIMA
				DbSelectArea("SE2")
				DbGoTo( nRegSe2 )
				Reclock( "SE2" , .F. )
				SE2->E2_PARCIMA := cParcIMA
				MsUnlock()
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria a natureza IMA caso nao exista       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SED")
			If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
				RecLock("SED",.T.)
				SED->ED_FILIAL  := cFilial
				SED->ED_CODIGO  := cNatureza
				SED->ED_CALCIRF := "N"
				SED->ED_CALCISS := "N"
				SED->ED_CALCINS := "N"
				SED->ED_CALCCSL := "N"
				SED->ED_CALCCOF := "N"
				SED->ED_CALCPIS := "N"
				SED->ED_DESCRIC := "IMA"
				SED->ED_TIPO	:= "2"
				MsUnlock()
				Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
			EndIf
		EndIf
	EndIf
Else
	If nFethab > 0
		If cRecFet=="2"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria o Fornecedor, caso nao exista 		   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SA2")
			SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
			If ( EOF() )
				Reclock("SA2",.T.)
				SA2->A2_FILIAL := cFilial
				SA2->A2_COD 	:= cCodMVRES
				SA2->A2_LOJA	:= cLojaImpos
				SA2->A2_NOME	:= "RECEITA ESTADUAL"
				SA2->A2_NREDUZ := "RECEITA"
				SA2->A2_BAIRRO := "."
				SA2->A2_MUN 	:= "."
				SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
				SA2->A2_End 	:= "."
				SA2->A2_TIPO	:= "J"
				MsUnlock()
			EndIf

			cFornUni  := SA2->A2_COD
			cLojaUni  := SA2->A2_LOJA
			cPrefixo  := SE2->E2_PREFIXO
			cNum	  := SE2->E2_NUM
			cTipoE2   := SE2->E2_TIPO
			dEmissao  := SE2->E2_EMISSAO
			dEmis1	  := SE2->E2_EMIS1
			dVctoReal := SE2->E2_VENCREA

			DbSelectArea("SE2")
			SE2->(DbSetOrder(1))
			aTamParcI := TamSx3("E2_PARCELA")
			cParcFet  := StrZero(1,aTamParcI[1])
			While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFet + MVTAXA + PadR(cCodMVRES,nTamFor) + cLojaImpos)
				cParcFet := Soma1(cParcFet,aTamParcI[1])
			EndDo

			RecLock("SE2",.T.)
			SE2->E2_FILIAL 	:= cFilial
			SE2->E2_FILORIG := cFilAnt
			SE2->E2_PREFIXO	:= cPrefixo
			SE2->E2_NUM    	:= cNum
			SE2->E2_PARCELA	:= cParcFet
			SE2->E2_TIPO 	:= MVTAXA
			SE2->E2_EMISSAO	:= dEmissao
			SE2->E2_EMIS1  	:= dDataBase
			SE2->E2_VALOR  	:= nFethab
			SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
			SE2->E2_SALDO  	:= nFethab
			SE2->E2_VENCREA	:= DTVenIcms()
			SE2->E2_VENCORI	:= dEmissao
			SE2->E2_FORNECE	:= cCodMVRES
			SE2->E2_LOJA   	:= cLojaImpos
			SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
			SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
			SE2->E2_VLCRUZ 	:= Round(nFethab, MsDecimais(1) )
			SE2->E2_ORIGEM 	:= Upper(cOrigem)
			cNatureza      	:= SuperGetMV("MV_FETNAT",.F.,"FETHAB")
			IF ExistBlock("NTFETHAB")
				cNatureza   := 	ExecBlock("NTFETHAB",.f.,.f.,{cOrigem,cPrefixo})
			Endif
			SE2->E2_NATUREZ	:= Alltrim(cNatureza)
			SE2->E2_CODAPRO := cCodAprov
			SE2->E2_FORMPAG := SA2->A2_FORMPAG
			SE2->E2_TITPAI  := cTitPai
			MsUnLock()

            if lPLSTITPF
                PLSTITPF('SE2',cTitPai)
            endIf

			AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"))
			AADD(aRecImpos,{"SE2",Recno()})

			//Gravar a parcela do Fethab no titulo principal
			DbSelectArea("SE2")
			DbGoTo( nRegSe2 )
			Reclock( "SE2" , .F. )
			SE2->E2_PARCFET := cParcFet
			MsUnlock()

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria a natureza Fethab caso nao exista     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SED")
			If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
				RecLock("SED",.T.)
				SED->ED_FILIAL  := cFilial
				SED->ED_CODIGO  := cNatureza
				SED->ED_CALCIRF := "N"
				SED->ED_CALCISS := "N"
				SED->ED_CALCINS := "N"
				SED->ED_CALCCSL := "N"
				SED->ED_CALCCOF := "N"
				SED->ED_CALCPIS := "N"
				SED->ED_DESCRIC := "FETHAB"
				SED->ED_TIPO	:= "2"
				MsUnlock()
				Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera titulo de FABOV                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nFabov > 0
		If cRecFab =="2"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria o Fornecedor, caso nao exista 		   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SA2")
			SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
			If ( EOF() )
				Reclock("SA2",.T.)
				SA2->A2_FILIAL := cFilial
				SA2->A2_COD 	:= cCodMVRES
				SA2->A2_LOJA	:= cLojaImpos
				SA2->A2_NOME	:= "RECEITA ESTADUAL"
				SA2->A2_NREDUZ := "RECEITA"
				SA2->A2_BAIRRO := "."
				SA2->A2_MUN 	:= "."
				SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
				SA2->A2_End 	:= "."
				SA2->A2_TIPO	:= "J"
				MsUnlock()
			EndIf

			cFornUni  := SA2->A2_COD
			cLojaUni  := SA2->A2_LOJA
			cPrefixo  := SE2->E2_PREFIXO
			cNum	  := SE2->E2_NUM
			cTipoE2   := SE2->E2_TIPO
			dEmissao  := SE2->E2_EMISSAO
			dEmis1	  := SE2->E2_EMIS1
			dVctoReal := SE2->E2_VENCREA

			DbSelectArea("SE2")
			SE2->(DbSetOrder(1))
			aTamParcI := TamSx3("E2_PARCELA")
			cParcFab  := StrZero(1,aTamParcI[1])
			While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFab + MVTAXA + PadR(cCodMVRES,nTamFor) + cLojaImpos)
				cParcFab := Soma1(cParcFab,aTamParcI[1])
			EndDo

			RecLock("SE2",.T.)
			SE2->E2_FILIAL 	:= cFilial
			SE2->E2_FILORIG := cFilAnt
			SE2->E2_PREFIXO	:= cPrefixo
			SE2->E2_NUM    	:= cNum
			SE2->E2_PARCELA	:= cParcFab
			SE2->E2_TIPO 	:= MVTAXA
			SE2->E2_EMISSAO	:= dEmissao
			SE2->E2_EMIS1  	:= dDataBase
			SE2->E2_VALOR  	:= nFabov
			SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
			SE2->E2_SALDO  	:= nFabov
			SE2->E2_VENCREA	:= DTVenIcms()
			SE2->E2_VENCORI	:= dEmissao
			SE2->E2_FORNECE	:= cCodMVRES
			SE2->E2_LOJA   	:= cLojaImpos
			SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
			SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
			SE2->E2_VLCRUZ 	:= Round(nFabov, MsDecimais(1) )
			SE2->E2_ORIGEM 	:= Upper(cOrigem)
			cNatureza      	:= SuperGetMV("MV_FABNAT",.F.,"FABOV")
			SE2->E2_NATUREZ	:= Alltrim(cNatureza)
			SE2->E2_CODAPRO := cCodAprov
			SE2->E2_FORMPAG := SA2->A2_FORMPAG
			SE2->E2_TITPAI  := cTitPai
			MsUnLock()

            if lPLSTITPF
                PLSTITPF('SE2',cTitPai)
            endIf

			AADD(aRecImpos,{"SE2",Recno()})

			//Gravar a parcela do FABOV no titulo principal
			DbSelectArea("SE2")
			DbGoTo( nRegSe2 )
			Reclock( "SE2" , .F. )
			SE2->E2_PARCFAB := cParcFab
			MsUnlock()

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria a natureza FABOV caso nao exista      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SED")
			If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
				RecLock("SED",.T.)
				SED->ED_FILIAL  := cFilial
				SED->ED_CODIGO  := cNatureza
				SED->ED_CALCIRF := "N"
				SED->ED_CALCISS := "N"
				SED->ED_CALCINS := "N"
				SED->ED_CALCCSL := "N"
				SED->ED_CALCCOF := "N"
				SED->ED_CALCPIS := "N"
				SED->ED_DESCRIC := "FABOV"
				SED->ED_TIPO	:= "2"
				MsUnlock()
				Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera titulo de FACS                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nFacs > 0
		If cRecFac=="2"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria o Fornecedor, caso nao exista 		   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SA2")
			SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
			If ( EOF() )
				Reclock("SA2",.T.)
				SA2->A2_FILIAL := cFilial
				SA2->A2_COD 	:= cCodMVRES
				SA2->A2_LOJA	:= cLojaImpos
				SA2->A2_NOME	:= "RECEITA ESTADUAL"
				SA2->A2_NREDUZ := "RECEITA"
				SA2->A2_BAIRRO := "."
				SA2->A2_MUN 	:= "."
				SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
				SA2->A2_End 	:= "."
				SA2->A2_TIPO	:= "J"
				MsUnlock()
			EndIf

			cFornUni  := SA2->A2_COD
			cLojaUni  := SA2->A2_LOJA
			cPrefixo  := SE2->E2_PREFIXO
			cNum	  := SE2->E2_NUM
			cTipoE2   := SE2->E2_TIPO
			dEmissao  := SE2->E2_EMISSAO
			dEmis1	  := SE2->E2_EMIS1
			dVctoReal := SE2->E2_VENCREA

			DbSelectArea("SE2")
			SE2->(DbSetOrder(1))
			aTamParcI := TamSx3("E2_PARCELA")
			cParcFac  := StrZero(1,aTamParcI[1])

			While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFac + MVTAXA + PadR(cCodMVRES,nTamFor) + cLojaImpos)
				cParcFac := Soma1(cParcFac,aTamParcI[1])
			EndDo

			RecLock("SE2",.T.)
			SE2->E2_FILIAL 	:= cFilial
			SE2->E2_FILORIG := cFilAnt
			SE2->E2_PREFIXO	:= cPrefixo
			SE2->E2_NUM    	:= cNum
			SE2->E2_PARCELA	:= cParcFac
			SE2->E2_TIPO 	:= MVTAXA
			SE2->E2_EMISSAO	:= dEmissao
			SE2->E2_EMIS1  	:= dDataBase
			SE2->E2_VALOR  	:= nFacs
			SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
			SE2->E2_SALDO  	:= nFacs
			SE2->E2_VENCREA	:= DTVenIcms()
			SE2->E2_VENCORI	:= dEmissao
			SE2->E2_FORNECE	:= cCodMVRES
			SE2->E2_LOJA   	:= cLojaImpos
			SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
			SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
			SE2->E2_VLCRUZ 	:= Round(nFacs, MsDecimais(1) )
			SE2->E2_ORIGEM 	:= Upper(cOrigem)
			cNatureza      	:= SuperGetMV("MV_FACNAT",.F.,"FACS")
			SE2->E2_NATUREZ	:= Alltrim(cNatureza)
			SE2->E2_CODAPRO := cCodAprov
			SE2->E2_FORMPAG := SA2->A2_FORMPAG
			SE2->E2_TITPAI  := cTitPai
			MsUnLock()

            if lPLSTITPF
                PLSTITPF('SE2',cTitPai)
            endIf

			AADD(aRecImpos,{"SE2",Recno()})

			//Gravar a parcela do FACS no titulo principal
			DbSelectArea("SE2")
			DbGoTo( nRegSe2 )
			Reclock( "SE2" , .F. )
			SE2->E2_PARCFAC := cParcFac
			MsUnlock()

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria a natureza FACS caso nao exista       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SED")
			If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
				RecLock("SED",.T.)
				SED->ED_FILIAL  := cFilial
				SED->ED_CODIGO  := cNatureza
				SED->ED_CALCIRF := "N"
				SED->ED_CALCISS := "N"
				SED->ED_CALCINS := "N"
				SED->ED_CALCCSL := "N"
				SED->ED_CALCCOF := "N"
				SED->ED_CALCPIS := "N"
				SED->ED_DESCRIC := "FACS"
				SED->ED_TIPO	:= "2"
				MsUnlock()
				Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera titulo de IMA                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nIMA > 0
		If cPaisLoc == "BRA" .And. cRecIMA == "2"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria o Fornecedor, caso nao exista 		   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SA2")
			SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
			If ( EOF() )
				Reclock("SA2",.T.)
				SA2->A2_FILIAL 	:= cFilial
				SA2->A2_COD 	:= cCodMVRES
				SA2->A2_LOJA	:= cLojaImpos
				SA2->A2_NOME	:= "RECEITA ESTADUAL"
				SA2->A2_NREDUZ	:= "RECEITA"
				SA2->A2_BAIRRO 	:= "."
				SA2->A2_MUN 	:= "."
				SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
				SA2->A2_End 	:= "."
				SA2->A2_TIPO	:= "J"
				MsUnlock()
			EndIf

			cFornUni  := SA2->A2_COD
			cLojaUni  := SA2->A2_LOJA
			cPrefixo  := SE2->E2_PREFIXO
			cNum	  := SE2->E2_NUM
			cTipoE2   := SE2->E2_TIPO
			dEmissao  := SE2->E2_EMISSAO
			dEmis1	  := SE2->E2_EMIS1
			dVctoReal := SE2->E2_VENCREA

			DbSelectArea("SE2")
			SE2->(DbSetOrder(1))
			aTamParcI := TamSx3("E2_PARCELA")
			cParcIMA  := SE2->E2_PARCELA

			While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcIMA + MVTAXA + PadR(cCodMVRES,nTamFor) + cLojaImpos)
				cParcIMA := Soma1(cParcIMA,aTamParcI[1])
			EndDo

			RecLock("SE2",.T.)
			SE2->E2_FILIAL 	:= cFilial
			SE2->E2_FILORIG := cFilAnt
			SE2->E2_PREFIXO	:= cPrefixo
			SE2->E2_NUM    	:= cNum
			SE2->E2_PARCELA	:= cParcIMA
			SE2->E2_TIPO 	:= MVTAXA
			SE2->E2_EMISSAO	:= dEmissao
			SE2->E2_EMIS1  	:= dDataBase
			SE2->E2_VALOR  	:= nIMA
			SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do IMA, coincidem com o vencimento do ICMS
			SE2->E2_SALDO  	:= nIMA
			SE2->E2_VENCREA	:= DTVenIcms()
			SE2->E2_VENCORI	:= dEmissao
			SE2->E2_FORNECE	:= cCodMVRES
			SE2->E2_LOJA   	:= cLojaImpos
			SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
			SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
			SE2->E2_VLCRUZ 	:= Round(nIMA, MsDecimais(1) )
			SE2->E2_ORIGEM 	:= Upper(cOrigem)
			cNatureza      	:= SuperGetMV("MV_IMANAT",.F.,"IMA")
			SE2->E2_NATUREZ	:= Alltrim(cNatureza)
			SE2->E2_CODAPRO := cCodAprov
			SE2->E2_FORMPAG := SA2->A2_FORMPAG
			SE2->E2_TITPAI := cTitPai

			If lCposIMA
				SE2->E2_IMA		:= Round(nIma,MsDecimais(1))
				SE2->E2_PARCIMA := cParcIMA
			Endif

			MsUnLock()

            if lPLSTITPF
                PLSTITPF('SE2',cTitPai)
            endIf

			AADD(aRecImpos,{"SE2",Recno()})

			//Gravar a parcela do IMA no titulo principal
			If lCposIMA
				DbSelectArea("SE2")
				DbGoTo( nRegSe2 )
				Reclock( "SE2" , .F. )
				SE2->E2_PARCIMA := cParcIMA
				MsUnlock()
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria a natureza IMA caso nao exista       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SED")
			If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
				RecLock("SED",.T.)
				SED->ED_FILIAL  := cFilial
				SED->ED_CODIGO  := cNatureza
				SED->ED_CALCIRF := "N"
				SED->ED_CALCISS := "N"
				SED->ED_CALCINS := "N"
				SED->ED_CALCCSL := "N"
				SED->ED_CALCCOF := "N"
				SED->ED_CALCPIS := "N"
				SED->ED_DESCRIC := "IMA"
				SED->ED_TIPO	:= "2"
				MsUnlock()
				Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera titulo de FAMAD                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nFamad > 0
		If cRecFmd=="2"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria o Fornecedor, caso nao exista 		   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SA2")
			SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
			If ( EOF() )
				Reclock("SA2",.T.)
				SA2->A2_FILIAL := cFilial
				SA2->A2_COD 	:= cCodMVRES
				SA2->A2_LOJA	:= cLojaImpos
				SA2->A2_NOME	:= "RECEITA ESTADUAL"
				SA2->A2_NREDUZ := "RECEITA"
				SA2->A2_BAIRRO := "."
				SA2->A2_MUN 	:= "."
				SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
				SA2->A2_End 	:= "."
				SA2->A2_TIPO	:= "J"
				MsUnlock()
			EndIf

			cFornUni  := SA2->A2_COD
			cLojaUni  := SA2->A2_LOJA
			cPrefixo  := SE2->E2_PREFIXO
			cNum	  := SE2->E2_NUM
			cTipoE2   := SE2->E2_TIPO
			dEmissao  := SE2->E2_EMISSAO
			dEmis1	  := SE2->E2_EMIS1
			dVctoReal := SE2->E2_VENCREA

			DbSelectArea("SE2")
			SE2->(DbSetOrder(1))
			aTamParcI := TamSx3("E2_PARCELA")
			cParcFmd  := StrZero(1,aTamParcI[1])

			While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFmd + MVTAXA + PadR(cCodMVRES,nTamFor) + cLojaImpos)
				cParcFmd := Soma1(cParcFmd,aTamParcI[1])
			EndDo

			RecLock("SE2",.T.)
			SE2->E2_FILIAL 	:= cFilial
			SE2->E2_FILORIG := cFilAnt
			SE2->E2_PREFIXO	:= cPrefixo
			SE2->E2_NUM    	:= cNum
			SE2->E2_PARCELA	:= cParcFmd
			SE2->E2_TIPO 	:= MVTAXA
			SE2->E2_EMISSAO	:= dEmissao
			SE2->E2_EMIS1  	:= dDataBase
			SE2->E2_VALOR  	:= nFamad
			SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
			SE2->E2_SALDO  	:= nFamad
			SE2->E2_VENCREA	:= DTVenIcms()
			SE2->E2_VENCORI	:= dEmissao
			SE2->E2_FORNECE	:= cCodMVRES
			SE2->E2_LOJA   	:= cLojaImpos
			SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
			SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
			SE2->E2_VLCRUZ 	:= Round(nFamad, MsDecimais(1) )
			SE2->E2_ORIGEM 	:= Upper(cOrigem)
			cNatureza      	:= SuperGetMV("MV_FAMNAT",.F.,"FAMAD")
			SE2->E2_NATUREZ	:= Alltrim(cNatureza)
			SE2->E2_CODAPRO := cCodAprov
			SE2->E2_FORMPAG := SA2->A2_FORMPAG
			SE2->E2_TITPAI := cTitPai
			MsUnLock()

            if lPLSTITPF
                PLSTITPF('SE2',cTitPai)
            endIf

			AADD(aRecImpos,{"SE2",Recno()})

			//Gravar a parcela do FACS no titulo principal
			DbSelectArea("SE2")
			DbGoTo( nRegSe2 )
			Reclock( "SE2" , .F. )
			SE2->E2_PARCFAM := cParcFmd
			MsUnlock()

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Cria a natureza FACS caso nao exista       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SED")
			If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
				RecLock("SED",.T.)
				SED->ED_FILIAL  := cFilial
				SED->ED_CODIGO  := cNatureza
				SED->ED_CALCIRF := "N"
				SED->ED_CALCISS := "N"
				SED->ED_CALCINS := "N"
				SED->ED_CALCCSL := "N"
				SED->ED_CALCCOF := "N"
				SED->ED_CALCPIS := "N"
				SED->ED_DESCRIC := "FAMAD"
				SED->ED_TIPO	:= "2"
				MsUnlock()
				Iif(FindFunction("JurCompSED"), JurCompSED(SED->(Recno())), Nil) //Integração SIGAPFS - Complemento da Natureza
			EndIf
		EndIf
	EndIf
EndIf

//Ponto se entrada para gravacoes genericas a todos os titulos de impostos
If lF050GER
	ExecBlock("F050GER",.F.,.F.,aRecImpos)
Endif

If !lPccMR .And. !lPccBaixa

	SE2->( MsGoto( nRegSE2 ) )
	Reclock( "SE2" , .F. )

	If lRtPICFCS
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava os campos de valor retido              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SE2->E2_VRETPIS := SE2->E2_PIS
		SE2->E2_VRETCOF := SE2->E2_COFINS
		SE2->E2_VRETCSL := SE2->E2_CSLL

		SE2->E2_PRETPIS := " "
		SE2->E2_PRETCOF := " "
		SE2->E2_PRETCSL := " "
	EndIf

	MsUnlock()

EndIf

//Gravação da FK3/FK4 para os impostos da emissão
If __lMotRet .AND. !Empty(aImpostos)
	FxGrvImpE("SE2", nRegSE2, aImpostos, aRecImpos,.F. )
Endif	

DbSelectArea("SA2")
DbGoTo( nRegSA2 )
DbSelectArea("SED")
DbGoTo( nRegSED )
DbSelectArea("SE2")
DbSetOrder(nOrdSe2)
DbGoTo(nRegSE2)
RecLock("SE2")
SE2->E2_ORIGEM := cOrigem

Return


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} A040DUPREC

Gravações complementares da inclusão de C.Receber.
Arquivo original: MATXATU.PRX

@Author	Ary Medeiros
/*/
//-----------------------------------------------------------------------------------------------------
Function A040DupRec( cOrigem AS Character, lUpDate AS Logical, nValTot AS Numeric, lAbate AS Logical,;
					 lGerAbtISS AS Logical, lAtuSalDup AS Logical, nTotISS AS Numeric, cRecIss AS Character,;
					 lFina040 AS Logical, aMedicao AS Array, nProp AS Numeric, lTitFim AS Logical,;
					 lLojaDin AS Logical, cRetCli AS Character, cTitpai AS Character, nValFetR AS Numeric,; 
					 cCodIrrf AS Character, aMotRet AS Array, lPccMR AS Logical, lIrfMR AS Logical, lInsMR AS Logical,; 
					 lIssMR AS Logical, lFunMR AS Logical, lFetMR AS Logical, lFabMR AS Logical, lFacMR AS Logical,;
					 lTpdMR AS Logical ) AS Logical

Local nSavRec		AS Numeric
Local nRecSE1		AS Numeric
Local nValForte		AS Numeric
Local nIss			AS Numeric
Local nIrrf			AS Numeric
Local cParcela		AS Character
Local cCliente		AS Character
Local cLoja			AS Character
Local dEmissao		AS Date
Local dVencto		AS Date
Local dVencRea		AS Date
Local cPrefixo		AS Character
Local cNum			AS Character
Local cTipoE1		AS Character
Local dVenISS		AS Date
Local dVenFun		AS Date
Local nMoeda		AS Numeric
Local nSalvCli		AS Numeric
Local cNatur		AS Character
Local dNextDay		AS Date
Local cNatureza		AS Character
Local nInss			AS Numeric
Local nTamData		AS Numeric
Local nPis			AS Numeric
Local nCofins		AS Numeric
Local nCsll			AS Numeric
Local nDiaUtil		AS Numeric
Local nDia			AS Numeric
Local nVRetISS		AS Numeric
Local cLA			AS Character
Local cFatura		AS Character
Local cMunIss		AS Character
Local lAbateuPIS	AS Logical
Local lAbateuCOF	AS Logical
Local lAbateuCSLL	AS Logical
Local lAbateuIRF	AS Logical
Local lAtuAcum		AS Logical	// Verifica se deve alterar os campos A1_VACUM e A1_NROCOM qdo modulo for o loja
Local xMinRetIR		AS Numeric
Local cParcIRF		AS Character
Local cParcFet		AS Character
Local cParcFab		AS Character
Local cParcFac		AS Character
Local cParTPDP		AS Character
Local cParcFam	    AS Character

Local lLojaCartao	AS Logical	// Indica se eh rotina chamada pelo modulo sigaloja e se forma de pagamento eh cartao.
Local nModOrig		AS Numeric	// modulo origem quando recebimento de titulo do loja via web service
Local lLojxRec		AS Logical // Verifica se esta na rotina de recebimento de titulos
Local dVencRIss		AS Date
Local nFamad		AS Numeric
Local nFumipeq		AS Numeric
Local nFetHab		AS Numeric
Local nFabov		AS Numeric
Local nFacs			AS Numeric
Local nTPDP			AS Numeric
Local nIMA			AS Numeric
Local lIrfRetAnt	AS Logical
Local nCalcIr		AS Numeric
Local aArea			AS Array
Local lOriFatura	AS Logical
Local cNatImp		AS Character
Local aRecImpos		AS Array
Local cNome			AS Character
Local nTaxaTit		AS Numeric
Local aAreaSAE		AS Array
Local lFINA460		AS Logical
Local cChaveSE1		AS Character
Local cCodAprov		AS Character
//.T. - Gera o titulo de ISS (se houver) na filial de destino juntamente com o titulo NF, baixando o titulo ISS na origem
//.F. - NÃ£ gera o titulo de ISS na filial de destino, permanecendo o titulo ISS na origem em aberto.
Local lFINA630		AS Logical
Local lTrfISSf		AS Logical
Local nBase061		AS Numeric    //Base utilizada para calcular os impostos no FINA061.
Local lGeraTitMin	AS Logical //Gera imposto de titulo com valor minimo para retencao.
Local lIRBx			AS Logical
Local lIsVendaVP	AS Logical	// Indica se eh venda de Vale Presente (SIGALOJA / FRONTLOJA)
Local lIsVdRecCP	AS Logical	// Indica se eh venda de Recarga de Cartao Presente (Gift Card) - SIGALOJA
Local cForniss		AS Character
Local nI			AS Numeric
Local cMun			AS Character
Local cUf			AS Character
Local cConsulta		AS Character
Local cAliasQry		AS Character
Local lMat460		AS Logical
Local lGrvSa1		AS Logical
Local cFilSE1		AS Character
Local aAreaSA2		AS Array
Local aAreaSED		AS Array
Local cTipoFor		AS Character //Topo do fornecedor para INSS
Local cCNPJRET		AS Character //CNPJ fornecedor para INSS
Local cRETINS		AS Character
Local lECCiaPed		AS Logical //Pedido CiaShop
Local lRecFun		AS Logical
Local lCdRetInd		AS Logical
Local dRef			As Date
Local nBtrISS		AS Numeric
Local lValBtrISS	AS Logical
Local lAplTxMoeda	AS Logical	//Define se aplica taxa da moeda no cálculo de IR. ==> .F. para quando a base de IR já vem com a taxa da moeda aplicada
Local dVencReaAux	AS Date
Local lRetPIX		AS Logical
Local lBorde		AS Logical
Local lDescISS      AS Logical
Local lM460Iren		AS Logical
Local cOrigImp		AS Character
Local cLojaIrf		AS Character
Local cLojaImpos	AS Character
Local cUniao		AS Character
Local cCodMVRES  	AS Character
Local cCodMVINS		AS Character
Local cMVMUNIC		AS Character
Local lCposIMA		AS Logical
Local nTamFor		AS Numeric
Local nDiaUtIss		AS Numeric
Local nTamParc		AS Numeric
LOCAL nVRetPIS      AS NUMERIC
LOCAL nVRetCOF      AS NUMERIC
LOCAL nVRetCSLL     AS NUMERIC

Default lGerAbtISS	:= .T.
Default lAbate		:= .T.
Default lAtuSalDup	:= .T.
Default nTotISS		:= SE1->E1_ISS
Default cRecISS		:= ""
Default lFina040	:= .F.
Default aMedicao	:= {}
Default nProp		:= 0
Default lTitFim		:= .F.
Default lLojaDin	:= .F. //Pagamento da loja em dinheiro
Default cRetCli		:= ""
Default cTitPai		:= ""
Default nValFetR	:= 0  //Campo criado para tratar retenÃ§Ã£o do FETHAB. Campo utilizado quando operaÃ§Ãµespossui nota fiscal
Default cCodIrrf	:= "" // Codigo de retenÃ§Ã£o do TX de Irrf.
Default aMotRet 	:= {}
Default lPccMR 		:= .F.
Default lIrfMR 		:= .F.
Default lInsMR 		:= .F.
Default lIssMR 		:= .F.
Default lFunMR 		:= .F.
Default lFetMR 		:= .F.
Default lFabMR 		:= .F.
Default lFacMR 		:= .F.
Default lTpdMR 		:= .F.

nSavRec			:= 0
nRecSE1			:= 0
nValForte		:= 0
nIss			:= 0
nIrrf			:= 0
cParcela		:= ""
cCliente		:= ""
cLoja			:= ""
dEmissao		:= CTOD('//')
dVencto			:= CTOD('//')
dVencRea		:= CTOD('//')
cPrefixo		:= ""
cNum			:= ""
cTipoE1			:= ""
dVenISS			:= CTOD('//')
dVenFun			:= CTOD('//')
nMoeda			:= SE1->E1_MOEDA
nSalvCli		:= 0
cNatur			:= ""
dNextDay		:= CTOD('//')
cNatureza		:= ""
nInss			:= 0
nTamData		:= 0
nPis			:= 0
nCofins			:= 0
nCsll			:= 0
nDiaUtil		:= 0
nDia			:= 0
nVRetISS		:= 0
cLA				:= SE1->E1_LA
cFatura			:= SE1->E1_FATURA
cMunIss			:= ''
lAbateuPIS		:= .F.
lAbateuCOF		:= .F.
lAbateuCSLL		:= .F.
lAbateuIRF		:= .F.
lAtuAcum		:= .T.	// Verifica se deve alterar os campos A1_VACUM e A1_NROCOM qdo modulo for o loja
xMinRetIR		:= 0
cParcIRF		:= ""
cParcFet		:= ""
cParcFab		:= ""
cParcFac		:= ""
cParTPDP		:= ""
cParcFam	    := ""
lLojaCartao		:= .F.	// Indica se eh rotina chamada pelo modulo sigaloja e se forma de pagamento eh cartao.
nModOrig		:= LjGetModOr()	// modulo origem quando recebimento de titulo do loja via web service
lLojxRec		:= LjGetLjRec() // Verifica se esta na rotina de recebimento de titulos
dVencRIss		:= CTOD("//")
nFamad			:= 0
nFumipeq		:= 0
nFetHab			:= 0
nFabov			:= 0
nFacs			:= 0
nTPDP			:= 0
nIMA			:= 0
lIrfRetAnt		:= .F.
nCalcIr			:= 0
aArea			:= {}
lOriFatura		:= Iif("FINA280" $ SE1->E1_ORIGEM,.T.,.F.)
cNatImp			:= ""
aRecImpos		:= {}
cNome			:= ""
nTaxaTit		:= 0
aAreaSAE		:= SAE->(GetArea())
lFINA460		:= FunName() == "FINA460"
cChaveSE1		:= ""
cCodAprov		:= ""
lFINA630		:= FwIsInCallStack("FINA630")
lTrfISSf		:= .F.
nBase061		:= 0    //Base utilizada para calcular os impostos no FINA061.
lGeraTitMin		:= .F. //Gera imposto de titulo com valor minimo para retencao.
lIRBx			:= .F.
lIsVendaVP		:= If(Lj7VPNew(), Lj7VPYesNo() == "S",.F.)	// Indica se eh venda de Vale Presente (SIGALOJA / FRONTLOJA)
lIsVdRecCP		:= If(FindFunction("Lj7CP_OK") .And. Lj7CP_OK(),Lj7CPGetSt()=="S",.F.)	// Indica se eh venda de Recarga de Cartao Presente (Gift Card) - SIGALOJA
cForniss		:= ""
nI				:= 0
cMun			:= ""
cUf				:= ""
cConsulta		:= ""
cAliasQry		:= ""
lMat460			:= Alltrim(FUNNAME()) $ "MATA460A_MATA461_MATA460"
lGrvSa1			:= .T.
cFilSE1			:= FWXFILIAL("SE1")
aAreaSA2		:= {}
aAreaSED		:= SED->(getArea())
cTipoFor		:= "" //Topo do fornecedor para INSS
cCNPJRET		:= "" //CNPJ fornecedor para INSS
cRETINS			:= ""
lECCiaPed		:= .F. //Pedido CiaShop
lRecFun			:=	.T.
lCdRetInd		:= .F.
dRef			:= dDatabase
nBtrISS			:= 0
lValBtrISS		:= .F.
lAplTxMoeda		:= .T.				//Define se aplica taxa da moeda no cálculo de IR. ==> .F. para quando a base de IR já vem com a taxa da moeda aplicada
dVencReaAux		:= CTOD('//')
lRetPIX			:= Alltrim(FunName()) $ "FINA890"
lBorde			:= (Alltrim(FunName()) $ "FINA061_FINA590" .or. FwIsInCallStack("FA061Borde")) .or. lRetPIX
lDescISS      	:= GetNewPar("MV_DESCISS",.F.)
lM460Iren		:= .F.
cOrigImp		:= Iif (FwIsInCallStack("FINA891"),"FINA890","FINA061")
cLojaIrf		:= ""
cLojaImpos		:= ""
cUniao			:= If(!EMPTY(GetMV("MV_UNIAO")),GetMV("MV_UNIAO"),'UNIAO')
cCodMVRES  		:= If(!EMPTY(GetMV("MV_RECEST")),GetMV("MV_RECEST"),'RECEITA')
cCodMVINS		:= If(!EMPTY(GetMV("MV_FORINSS")),GetMV("MV_FORINSS"),'INSS')
cMVMUNIC		:= AllTrim(SuperGetMv("MV_MUNIC"))
lCposIMA		:= .F.
nTamFor			:= 0
nDiaUtIss		:= 0
nTamParc		:= 0
nVRetPIS        := 0
nVRetCOF        := 0
nVRetCSLL       := 0

FININCNAT() //cria as naturezas que possuem retenção na baixa
RestArea(aAreaSED)

If __lLocBRA == NIL
	__lLocBRA	:= cPaisLoc == "BRA"
Endif

If __lTrfIssF == NIL
	__lTrfIssF 	:= GetNewPar("MV_TRFISSF",.T.)
Endif

lTrfISSf := lFINA630 .And. __lTrfIssF

If __nTamFor == NIL
	__nTamFor	:= TamSx3("E2_FORNECE")[1]
Endif

If __nTamLoja == NIL
	__nTamLoja	:= TamSx3("E2_LOJA")[1]
Endif

If __nTamParc == NIL
	__nTamParc	:= TamSx3("E2_PARCELA")[1]
Endif

If __nTamNat == NIL
	__nTamNat	:= TamSx3("E2_NATUREZ")[1]
Endif

If __lF040GER == NIL
	__lF040GER	:= ExistBlock("F040GER")
Endif

If __lM040Se1 == NIL
	__lM040Se1	:= Existblock("M040SE1")
Endif

If __nMinRetIR == NIL
	__nMinRetIR	:= SuperGetMV("MV_VLRETIR")
Endif
	
If __lF040MIRF == NIL
	__lF040MIRF	:= ExistBlock("F040MIRF")
Endif

If __nMinISS == NIL
	__nMinISS	:= SuperGetMv("MV_VRETISS",.T.,0)
Endif

If __lPccBxCr == NIL
	__lPccBxCr	:= FPccBxCr(.T.)
Endif

If __lIrPjBxCr == NIL
	__lIrPjBxCr	:= FIrPjBxCr(.T.)
Endif

If __nVlMinImp == NIL
	__nVlMinImp	:= GetNewPar("MV_VL10925",5000)
Endif

If __nDiaUtIss == NIL
	__nDiaUtIss	:= SuperGetMv("MV_DIAUISS",.T.,0)
Endif

If __lFINCTAL == NIL
	__lFINCTAL	:= (SuperGetMV( "MV_FINCTAL", .T., "1" ) == "2")
Endif

cCodAprov	:= If(__lFINCTAL, FA050Aprov(If(__lLocBRA,1,nMoeda))," ")

// A leitura deve ser efetuada a cada acesso, pois estas variáveis 
// estão sendo alteradas em razão do título atual
__nVRetCOF	:= SuperGetMV("MV_VRETCOF")
__nVRetPIS 	:= SuperGetMV("MV_VRETPIS")
__nVRetCSLL	:= SuperGetMV("MV_VRETCSL")
// ---------------------------------------------------------------

cLojaImpos	:= PadR( "00", __nTamLoja, "0" )
cLojaIrf	:= Padr( "00", __nTamLoja, "0" )
cUniao		:= PadR(cUniao,__nTamFor)
cCodMVRES	:= PadR(cCodMVRES,__nTamFor)
cCodMVINS	:= PadR(GetMv("MV_FORINSS"),__nTamFor)

If __lAgFETHA == NIL
	__lAgFETHA	:= SuperGetMv("MV_AGFETHA",,.F.) 
Endif

If __lMoedTit == NIL
	__lMoedTit	:= SuperGetMv("MV_MOEDTIT",.F.,"N") == "S"
Endif

If __nMCusto == NIL
	__nMCusto := Val(SuperGetMV("MV_MCUSTO"))
Endif

If __lFina986 == NIL
	__lFina986 	:= __lLocBRA  .and. FindFunction("Fa986grava") .and. AliasInDic("FKG")
Endif

If lPLSTITPF == NIL
	lPLSTITPF	:= ('PLS' $ SE1->E1_ORIGEM) .and. FindFunction("PLSTITPF")
EndIf

If !lPccMR
	
	If __nVencto == NIL
		__nVencto	:= SuperGetMv("MV_VCPCCR",.T.,1)
	Endif

	If (lBorde .and. dDataBase >= dLastPcc) .or. (SE1->E1_EMISSAO >= dLastPcc)
		__nVlMinImp	:= 0
		nVRetPIS	:= __nVRetPIS
		nVRetCOF	:= __nVRetCOF
		nVRetCSLL	:= __nVRetCSLL
		__nVRetPIS	:= 0
		__nVRetCOF	:= 0
		__nVRetCSLL	:= 0
	EndIf

	If __nVencto == 2
		dRef := SE1->E1_VENCREA
	ElseIf __nVencto == 1 .OR. EMPTY(__nVencto)
		dRef := SE1->E1_EMISSAO
	ElseIf __nVencto == 3
		dRef := SE1->E1_EMIS1
	EndIf
EndIf

If __lFina986 .and. !( SE1->E1_TIPO $ MV_CRNEG)
	//realiza a gravacao do model
	Fa986grava("SE1",cOrigem)
EndIf

If __lLocBRA .and. Alltrim(FUNNAME()) $ "MATA460A_MATA461_MATA460"
	DbSelectArea("SA2")
	aAreaSA2:=SA2->(GetArea())
	SA2->(Dbsetorder(1))
	If SA2->(DbSeek(xFilial("SA2") + SC5->C5_FORNISS))
		If SA2->A2_COD = SC5->C5_FORNISS .And. SA2->A2_FILIAL = xFilial("SA2")
			cLojaImpos := SA2->A2_LOJA
		Endif
	EndIf
	RestArea(aAreaSA2)
Endif

If SA1->(Eof())
   	SA1->(Dbsetorder(1))
	SA1->(DbSeek(xFilial("SA1") + SE1->E1_CLIENTE))
EndIf

nBase061	:=	0    //Base utilizada para calcular os impostos no FINA061.
If lBorde
	If !lPccMR .And. __lPccBxCr
		nBase061	:=	nValRec
		lGeraTitMin	:=  lRetTitMin
	EndIf
	If !lIrfMR
		lIRBx:=	__lLocBRA .And. ;
				Posicione("SA1",1,xfilial("SA1") + SE1->(E1_CLIENTE+E1_LOJA),"A1_IRBAX") == "1" .And. ;
				!(Posicione("SA1",1,xfilial("SA1") + SE1->(E1_CLIENTE+E1_LOJA),"A1_ENTID")) $ "00_02_10" .And. ;
				Posicione("SA1",1,xFilial("SA1")+SE1->(E1_CLIENTE+E1_LOJA),"A1_PESSOA") == "J" .And.;
				Posicione("SED",1,xfilial("SED") + SE1->(E1_NATUREZ),"ED_CALCIRF") = "S"
		nBase061	:=	nValRec
	Else
		lIRBx := .F.
	EndIf
Else
	nBase061	:=	0
	lIRBx			:= .F.
Endif
cOrigem := Iif(cOrigem==NIL,Space(8),cOrigem)

// Valor de IRRF referente ao recolhimento pelo Emitente;
nRecIRRF	:= Iif(Type("nRecIRRF") <> "N", 0, nRecIRRF)

lAltera	:=	.F.
lUpDate	:=	If( (lUpDate == NIL),.T.,lUpDate )

If Upper(subs(cOrigem,1,3)) == "LOJ"
	If ALLTRIM( SE1->E1_TIPO)  $ "CC;VA;CO;CD;FI"		// Cartao Credito, Vales, Convenio, Cartao de Debito, Financiamento Proprio
		lLojaCartao := .T.

		If __lECCia == NIL
			__lECCia := SuperGetMv("MV_LJECOMO", .T., .F.) .AND. SuperGetMv("MV_LJECOMS",.T., .F.) //EC CiaShop Implantado
		Endif

		If __lECCia
			lECCiaPed := SL1->L1_ECFLAG == "1" //Venda EC CiaShop
		EndIf
	Endif
Endif

DbSelectArea("SA1")
DbSetOrder(1)
Do Case
	Case lLojaCartao .AND. SL1->L1_TIPO <> "P"	.AND. ( SAE->AE_FINPRO == "N" .OR. Empty(SAE->AE_FINPRO) ) .AND. nModOrig <> 23 .And. !lLojxRec
		DbSeek(cFilial + SE1->E1_CLIENTE + SE1->E1_LOJA)
	Case lLojaCartao .AND. SL1->L1_TIPO <> "P" .AND. nModOrig <> 23 .And. !lLojxRec .And. !lIsVendaVP .And. !lIsVdRecCP .and. !lECCiaPed
		DbSeek(cFilial + SF2->F2_CLIENTE + SF2->F2_LOJA)
	Case lLojaCartao .AND. nModOrig <> 23 .And. !lLojxRec
		DbSeek(cFilial + SL1->L1_CLIENTE + SL1->L1_LOJA)
	OtherWise
		DbSeek(cFilial + SE1->E1_CLIENTE + SE1->E1_LOJA)
EndCase

// No SIGALOJA quando for cliente ADM Finan e o parametro estiver habilitado nao trava o registro do cliente
aAreaSAE := SAE->(GetArea())
SAE->(DbSetOrder(2))
If SAE->(DbSeek(xFilial("SAE")+SA1->A1_COD))
	If __lLjAtuSa == NIL
		__lLjAtuSa	:= SuperGetMv("MV_LJATUSA",,.F.)
	Endif
	If __lLjAtuSa
		lAtuSalDup 	:= .F.
		lAtuAcum	:= .F.
    EndIf
EndIf
SAE->(RestArea(aAreaSAE))

If !lIssMR
	If __lLocBRA .and. Empty(cRecISS)
		cRecISS := SA1->A1_RECISS
		If !Empty(SE1->E1_PEDIDO) .And. Alltrim(SE1->E1_ORIGEM) == "FINA630"
			SC5->(Dbsetorder(3)) //C5_FILIAL+C5_CLIENTE+C5_LOJACLI+C5_NUM
			If SC5->(Dbseek(xFilial("SC5",SE6->E6_FILORIG) + SE1->E1_CLIENTE + SE1->E1_LOJA + SE1->E1_PEDIDO )) .And. !Empty(SC5->C5_RECISS)
				cRecIss := (SC5->C5_RECISS)
		    Endif
		Endif
		If nModulo == 43 //TMS
			If type('nDTCRECISS') <> 'U'
				If nDTCRECISS == 2 
					cRecISS := "2"
				ElseIf nDTCRECISS == 1
					cRecISS := "1"
				EndIf
			EndIf
		EndIf
	EndIf

	nSalvCli := RecNo()
	If Empty(cMVMUNIC) .and. !Empty(SA1->A1_MUNC)
	   cMunISS := SA1->A1_MUNC
	Else
		If __lRMClass == NIL
			__lRMClass	:= SuperGetMV("MV_RMCLASS",,.F.)
		Endif

		If !__lRMClass
			// Validação para buscar o fornecdor e a loja do titulo de ISS
			// Olhar primeiro para o pedido de venda, se não econtrar olhar para
			// o cadastro de aliquotas e se não encontrar busca do parametro.

			// o campo C5_FORNISS existe apenas na localização BRA
			If __lLocBRA .And. !(Empty(SC5->C5_FORNISS))
				cForniss := SC5->C5_FORNISS
			EndIf

			If __lIssMunic == NIL
				__lIssMunic	:= SuperGetMv("MV_ISSXMUN",.T.,.F.)
			Endif

			aAreaSA2:=SA2->(GetArea())
			SA2->(DbSetOrder(1))

			If __lLocBRA .And. !(Empty(cForniss))
				SA2->(DbSeek(xFilial("SA2") + SC5->C5_FORNISS))
				cMunIss	:= SC5->C5_FORNISS
				cLojaImpos	:= SA2->A2_LOJA
			ElseIf __lLocBRA .And. __lIssMunic
				If !(Empty(SC5->C5_MUNPRES) .And. Empty(SC5->C5_ESTPRES))
					cMun 	:= Alltrim(SC5->C5_MUNPRES)
					cUf 	:= SC5->C5_ESTPRES
				Else
					cMun 	:= Alltrim(SA1->A1_COD_MUN)
					cUf 	:= SA1->A1_EST
				EndIf
				If (CE1->(dbSeek(xFilial("CE1") + SD2->D2_CODISS + cUf + cMun + SD2->D2_COD))) .Or. ;
				 	(CE1->(dbSeek(xFilial("CE1") + SD2->D2_CODISS + cUf + cMun )))
			   		SA2->(DbSeek(xFilial("SA2") + CE1->CE1_FORISS ))
			   		cMunIss := CE1->CE1_FORISS
			   		cLojaImpos	:= SA2->A2_LOJA
			   	Else
			   	   cAliasQry := GetNextAlias()

			   	   cConsulta := ""
			   	   cConsulta := "SELECT CE1_LOJISS, CE1_FORISS FROM "+RetSqlName("CE1")
			   	   cConsulta += " WHERE CE1_FILIAL = '" + xFilial("CE1") + "'"
			   	   cConsulta += "   AND CE1_ESTISS = '" + cUf + "'"
			   	   cConsulta += "   AND CE1_CMUISS = '" + cMun + "'"
			   	   cConsulta += "   AND CE1_PROISS = '" + SD2->D2_COD + "'"
			   	   cConsulta := ChangeQuery( cConsulta )

			   	   dbUseArea( .T., "TOPCONN", TcGenQry(,,cConsulta), cAliasQry, .F., .T. )

			   	   If !( cAliasQRY )->( Eof())
					  cMunIss := (cAliasQRY)->CE1_FORISS
					  cLojaImpos	:= (cAliasQRY)->CE1_LOJISS
					EndIf
				   ( cAliasQRY )->( dbCloseArea() )
			   	EndIf
			EndIf
			RestArea(aAreaSA2)

			If Empty(cMunIss)
				cMunIss := cMVMUNIC
			EndIf
		Else
			cMunIss := cMVMUNIC
		EndIf
	EndIf
EndIf

// Verifica se aplica-se o valor mÃ­nimo de retecao do Ir pode ser retido
If __lLocBRA .and. !lIrfMR
	If	SA1->A1_MINIRF == "1"
		__nMinRetIR := 0
	Endif
Endif

If cRetCli <> "2"
	cRetCli := IIf(Empty(SA1->A1_ABATIMP),"1",SA1->A1_ABATIMP)
Endif

If __lLocBRA .and. !lIssMR
	cMunISS := IIF(!Empty(SE1->E1_FORNISS),SE1->E1_FORNISS,cMunISS)
Endif

//Ponto de entrada para tratamento do valor minimo para IRRF.
If !lIrfMR .And. __lF040MIRF	
	xMinRetIR := 0
	xMinRetIR := Execblock("F040MIRF",.F.,.F.,{SA2->A2_COD,SA2->A2_LOJA})
	__nMinRetIR := If(ValType(xMinRetIR)=="N",xMinRetIR,__nMinRetIR)
EndIf

If !lIssMR
	// Verifica se o ambiente esta configurado com Multiplos Vinculos de ISS
	cNome := "MUNICIPIO"

	If __lLocBRA
		If !Empty( SE1->E1_CODISS )
			DbSelectArea( "FIM" )
			FIM->( DbSetOrder( 1 ) )
			If FIM->( DbSeek( xFilial( "FIM" ) + SE1->E1_CODISS ) )
				cMunIss := FIM->FIM_CODMUN
				cNome	+= "-" + AllTrim( FIM->FIM_MUN )
			EndIf
		EndIf
	EndIf

	If __lF040MISS == NIL
		__lF040MISS := ExistBlock("F040MISS")
	Endif

	If __lF040MISS
		__nMinISS := Execblock("F040MISS",.F.,.F.,{cMunISS})
	EndIf
EndIf

If nModulo == 43 .And. FindFunction("RetMunISS")	//-- TMS
	RetMunISS(SE1->E1_CLIENTE,SE1->E1_LOJA,@cMunIss,@cLojaImpos)
EndIf

// Atualiza Contas a Receber
aArea := SE1->(GetArea())

If cOrigem == "MATA460" .AND. __lMoedTit .AND. SE1->E1_MOEDA <> 1  
	lAplTxMoeda := .F.	// Define se aplica taxa da moeda no cÃ¡lculo de IR. .F. para quando a base de IR jah vem com a taxa da moeda aplicada
EndIf

If ExistBlock("M460IREN")
	lM460Iren	:= .T.
EndIf

If !lIrfMR .And. !lFina040 .And. !lBorde

	If __lVRetIrf == NIL
		__lVRetIrf	:= !(cPaisLoc == "RUS") .and. !Empty(SE1->(FieldPos("E1_VRETIRF")))
	Endif

	If __lVRetIrf .And. SED->ED_CALCIRF == "S" .And. !lM460Iren
		nCalcIr := F040CalcIr(0,,.F.,SE1->E1_IRRF,@lIrfRetAnt ,, lAplTxMoeda)
	Endif
EndIf
SE1->(RestArea(aArea))

DbSelectArea("SE1")
RecLock("SE1",.F.)

// Avalia as medicoes de contrato - SIGAGCT
If len(aMedicao) > 0
	CNTAvalSC5(aMedicao,nProp,lTitFim)
EndIf

If __lLocBRA
	SE1->E1_RELATO := Iif(Empty(SE1->E1_RELATO),"2",SE1->E1_RELATO)
	SE1->E1_TPDESC := Iif(Empty(SE1->E1_TPDESC),"C",SE1->E1_TPDESC)
	//Verificacao do valor minimo de IRRF - Nao gerados pelo FINANCEIRO
	If !lIrfMR .And. !lFina040 .and. !lBorde  .And. !lM460Iren
		SE1->E1_IRRF := nCalcIr
		// Verifica se o Ir pode ser retido. Valor menor que MV_VLRETIR e' dispensado de recolhimento
		If ( SE1->E1_IRRF <= __nMinRetIR .and. !lIrfRetAnt .And. cRetCli <> "2")  .or. cRetCli == "3"
			SE1->E1_IRRF	:= 0
			If cRetCli == "3"
				SE1->E1_VRETIRF := 0
			EndIf
		EndIf
	Endif

	If __lFVldIns == NIL
		__lFVldIns	:= Existblock("FinVldIns")
	Endif

	If __nVlInsRet == NIL
		__nVlInsRet := SuperGetMV("MV_VLRETIN")
	Endif

	If !lInsMR .And. ( SE1->E1_INSS < __nVlInsRet )  .AND. (IIF(__lFVldIns, Execblock("FinVldIns",.F.,.F., {} ), .T. )) 	// VerIfica se o Inss pode ser retido
		SE1->E1_INSS := 0	// Valor menor que MV_VLRETIN e' dispensado de recolhimento
	EndIf

	If !lPccMR

		If __lCodRtPCC == NIL
			__lCodRtPCC	:= !__lPccBxCr .And. SE1->(FieldPos("E1_CODRET")) > 0 .And. SED->(FieldPos("ED_PCCINDV")) > 0
		Endif

		If SE1->E1_EMISSAO < dLastPcc
			If cRetCli == "3" .OR. ( SE1->E1_COFINS <= __nVRetCOF .And. cRetCli <> "2" ) // VerIfica se o Cofins pode ser retido
				If lMat460
					SE1->E1_SABTCOF	:= SE1->E1_COFINS
				EndIf
				SE1->E1_COFINS	:= 0							 // Valor menor que MV_VRETCOF e' dispensado de recolhimento.
			EndIf
			If cRetCli == "3" .OR. ( SE1->E1_PIS <= __nVRetPIS .And. cRetCli <> "2" ) // VerIfica se o Pis pode ser retido
				If lMat460
					SE1->E1_SABTPIS	:= SE1->E1_PIS
				EndIf
				SE1->E1_PIS	:= 0							 // Valor menor que MV_VRETPIS e' dispensado de recolhimento.
			EndIf
			If cRetCli == "3" .OR. ( SE1->E1_CSLL <= __nVRetCSLL .And. cRetCli <> "2" ) // VerIfica se o Csll pode ser retido
				If lMat460
					SE1->E1_SABTCSL	:= SE1->E1_CSLL
				EndIf
				SE1->E1_CSLL	:= 0							 // Valor menor que MV_VRETCSL e' dispensado de recolhimento.
			EndIf
		ElseIf lAbate .And. __lCodRtPCC .And. SED->ED_PCCINDV == '1' .And. ( SE1->E1_COFINS == 0 .Or. SE1->E1_PIS == 0 .Or. SE1->E1_CSLL == 0 )
			If cRetCli == "3" .OR. ( SE1->E1_COFINS <= nVRetCOF .And. cRetCli <> "2" ) // VerIfica se o Cofins pode ser retido
				If lMat460
					SE1->E1_SABTCOF	:= SE1->E1_COFINS
				EndIf
				SE1->E1_COFINS	:= 0							 // Valor menor que MV_VRETCOF e' dispensado de recolhimento.
			EndIf

			If cRetCli == "3" .OR. ( SE1->E1_PIS <= nVRetPIS .And. cRetCli <> "2" ) // VerIfica se o Pis pode ser retido
				If lMat460
					SE1->E1_SABTPIS	:= SE1->E1_PIS
				EndIf
				SE1->E1_PIS	:= 0							 // Valor menor que MV_VRETPIS e' dispensado de recolhimento.
			EndIf

			If cRetCli == "3" .OR. ( SE1->E1_CSLL <= nVRetCSLL .And. cRetCli <> "2" ) // VerIfica se o Csll pode ser retido
				If lMat460
					SE1->E1_SABTCSL	:= SE1->E1_CSLL
				EndIf
				SE1->E1_CSLL	:= 0							 // Valor menor que MV_VRETCSL e' dispensado de recolhimento.
			EndIf
		EndIf
	EndIf
	// Se o cliente abate o ISS, gera abatimento. Senao, gera titulo para pagamento do tributo.
	If !lIssMR .And. cRecISS == "1" .And. lDescIss
		If lGerAbtISS
			If __cModRIss == NIL
				__cModRIss	:= SuperGetMv("MV_MODRISS",,"1")
			Endif		
			SomaTitISS("SE1",SE1->E1_CLIENTE,SE1->E1_LOJA,SE1->E1_VENCREA,@nTotISS,@nVRetISS)
			If ( SE1->E1_FRETISS=="1" .Or.;	//Se a opcao no cadastro de clientes existir e estiver como 1=Considera Valor Minimo, respeito o tratamento padrao.
				(SE1->E1_FRETISS=="2" .And. __cModRIss == "2") .Or.; //Se a opcao no cadastro de clientes existir, estiver como 2=Sempre reter e a Modalidade de retencao for 1=Por titulo, desconsidero o Valor minimo e gero o titulo normalmente.
				(nTotISS > 0 .And. nTotISS <= __nMinISS ))
			    If SE1->E1_VLMINIS == "2" //Tratamento para a cidade de Cascavel-PR Decreto n.Âº 8.230
   	   			    If (SE1->E1_ISS+nVRetISS) > (SE1->E1_VALOR)-0.01
					    SE1->E1_VRETISS := (SE1->E1_ISS+nVRetISS) - ((SE1->E1_VALOR)-0.01)
					    SE1->E1_ISS := (SE1->E1_VALOR)-0.01
				    Else
					    SE1->E1_ISS := (SE1->E1_ISS+nVRetISS)
				    EndIf
				Else
   				    If (nTotISS > 0 .And. (nTotISS >= __nMinISS .OR. SE1->E1_FRETISS == "2"))
   				    	SE1->E1_VRETISS := SE1->E1_ISS
   				    Else
   				    	SE1->E1_ISS := 0
   				    EndIf
			    Endif
			Else
				If (SE1->E1_ISS+nVRetISS) > (SE1->E1_VALOR)-0.01
					SE1->E1_VRETISS := (SE1->E1_ISS+nVRetISS) - ((SE1->E1_VALOR)-0.01)
					SE1->E1_ISS := (SE1->E1_VALOR)-0.01
					Else
					SE1->E1_ISS := (SE1->E1_ISS+nVRetISS)
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
SE1->E1_NOMCLI  := SA1->A1_NREDUZ

//Se a origem for o LOJA e a carteira jah estiver definida, nao alterar.
If AllTrim(Upper(cOrigem)) $ "LOJA010|LOJA701|FATA701"
	If Empty(SE1->E1_SITUACA) .AND. !Upper(AllTrim(SE1->E1_SITUACA)) $ "I|J"
		SE1->E1_SITUACA := "0"
	Endif
Else
	SE1->E1_SITUACA := "0"
Endif

If EMPTY(SE1->E1_EMIS1)
	SE1->E1_EMIS1	 := dDataBase
EndIF

If !lBorde
	SE1->E1_BAIXA	 := CtoD("  /  /  ")
Endif

If !(SE1->E1_SALDO < SE1->E1_VALOR .And. lBorde)
	SE1->E1_SALDO	 := SE1->E1_VALOR
Endif
SE1->E1_STATUS  := Iif(E1_SALDO>0.01,"A","B")

If !lBorde
	SE1->E1_ORIGEM  := UPPER(cOrigem)
EndIf

If SE1->E1_TIPO $ MVABATIM		 // Se for abatimento
	SE1->E1_OCORREN := "04"
	SE1->E1_TITPAI  := cTitpai
EndIf
SE1->E1_FILORIG  := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)

if lPLSTITPF
    PLSTITPF('SE1',cTitPai)
endIf

If __lM040Se1
	Execblock("M040SE1",.F.,.F.)
Endif

// NÃO atualiza acumuladores quando operacao de adiantamento no mexico.
If cPaisLoc == "MEX" .AND. FunName() == "MATA467N" .AND. SF2->F2_TIPO == "A"
	lAtuAcum 		:= .F.
	lAtuSalDup 	:= .F.
EndIf

nSavRec   := RecNo()
__nMCusto := If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, __nMCusto)

// Atualiza Acumulado de Clientes
If SA1->(eof())
   	SA1->(Dbsetorder(1))
	SA1->(DbSeek(xFilial("SA1") + SE1->E1_CLIENTE))
EndIf

If !( SE1->E1_TIPO $ MVRECANT + "/"+MV_CRNEG)
	DbSelectArea("SA1")

	If __cCliPad == NIL
		__cCliPad    := SuperGetMv("MV_CLIPAD",,"")
	Endif

	If __cLojaPad == NIL
		__cLojaPad   := SuperGetMv("MV_LOJAPAD",,"")	
	Endif

	// Nao atualizar os campos A1_VACUM e A1_NROCOM se o modulo for o loja ou frontloja (via RPC) e o cliente = cliente padrao.
	If ((Upper(subs(cOrigem,1,3)) == "LOJ") .AND. (__cCliPad + __cLojaPad == SA1->A1_COD + SA1->A1_LOJA));
	    .Or. (FunName() == "FINA074")
		lAtuAcum := .F.
	EndIf

	If lTravaSA1
	  	lGrvSa1:= ExecBlock("F040TRVSA1",.F.,.F.)
	Endif

	If lAtuAcum .And. !lOriFatura .and. !lFINA460 .and. lGrvSa1
		Reclock("SA1",.F.)
		SA1->A1_PRICOM  := Iif(SE1->E1_EMISSAO<SA1->A1_PRICOM .Or. Empty(SA1->A1_PRICOM),SE1->E1_EMISSAO,SA1->A1_PRICOM)
		SA1->A1_ULTCOM  := Iif(SA1->A1_ULTCOM<SE1->E1_EMISSAO .And. SE1->E1_TIPO != "NDC",SE1->E1_EMISSAO,SA1->A1_ULTCOM)
		SA1->A1_NROCOM  := SA1->A1_NROCOM + If( lUpDate,1,0 )
		If !IsInCallStack("FA040Subst")//Caso seja uma substuiÃ§Ã£o não somar o valor novamente
			SA1->A1_VACUM	:= SA1->A1_VACUM + Round(NoRound(xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,__nMCusto,SE1->E1_EMISSAO,3,SE1->E1_TXMOEDA),3),2)
		EndIf
		SA1->(MsUnlock())
	EndIf
EndIf

DbSelectArea("SE1")
If !( SE1->E1_TIPO $ MVABATIM )

	If __cCSLNAT == NIL
		__cCSLNAT	:= PadR(SuperGetMV("MV_CSLL",.F.,"CSLL"),__nTamNat)
	Endif

	If __cPISNAT == NIL
		__cPISNAT	:= PadR(SuperGetMV("MV_PISNAT",.F.,"PIS"),__nTamNat)
	Endif

	If __cCOFNAT == NIL
		__cCOFNAT	:= PadR(SuperGetMV("MV_COFINS",.F.,"COFINS"),__nTamNat)
	Endif

	cNatImp += "|" + If(!Empty(SuperGetMV("MV_ISS")),PADR(&(SuperGetMV("MV_ISS")),__nTamNat),"")
	cNatImp += "|" + If(!Empty(SuperGetMV("MV_IRF")),PADR(&(SuperGetMV("MV_IRF")),__nTamNat),"")
	cNatImp += "|" + If(!Empty(SuperGetMV("MV_INSS")),PADR(&(SuperGetMV("MV_INSS")),__nTamNat),"")
	cNatImp += "|" + If(!Empty(__cCSLNAT),__cCSLNAT,"")
	cNatImp += "|" + If(!Empty(__cPISNAT),__cPISNAT,"")
	cNatImp += "|" + If(!Empty(__cCOFNAT),__cCOFNAT,"")

	If !__lLocBRA .Or. !(SE1->E1_NATUREZ $ cNatImp)

		cPrefixo  	:= E1_PREFIXO
		cNum		:= E1_NUM
		cTipoE1   	:= E1_TIPO

		// Atualiza Acumulado Financeiros do Cliente 
		If nValTot == Nil
			nValTot := 0
			DbSelectArea("SE1")
			DbSetOrder(1)
			DbSeek(cFilial+cPrefixo+cNum)
			While ( !EOF() .And. E1_FILIAL+E1_PREFIXO+E1_NUM+E1_TIPO == ;
				cFilial+cPrefixo+cNum+cTipoE1 )
				nValTot := nValTot + xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,__nMCusto,SE1->E1_EMISSAO,3,SE1->E1_TXMOEDA)
				DbSkip()
			EndDo
			DbGoTo( nSavRec )
		EndIf

		// Nao Atualiza Caso seja um RA / NCC / PR
		If lAtuSalDup .And. !( SE1->E1_TIPO $ MVRECANT+"/"+MVPROVIS+"/"+MV_CRNEG ) 

			// No caso dos modulos Sigaloja e Front Loja na atualiza os saldos de duplicatas para o cliente padrao
			If !( (Upper(subs(cOrigem,1,3)) == "LOJ") .AND. (__cCliPad + __cLojaPad == SE1->E1_ClIENTE + SE1->E1_LOJA) ) .And. FunName() <> "FINA074"
				nValForte := xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,1,SE1->E1_EMISSAO,3,SE1->E1_TXMOEDA)
				If !lLojaDin
					AtuSalDup("+",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,SE1->E1_TXMOEDA,SE1->E1_EMISSAO,,,lGrvSa1)
				EndIf
				nValForte := xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,__nMCusto,SE1->E1_EMISSAO,3,SE1->E1_TXMOEDA)
			  	If lGrvSa1
					nValForte := xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,__nMCusto,SE1->E1_EMISSAO,3,SE1->E1_TXMOEDA)
					RecLock("SA1",.F.)
					SA1->A1_MSALDO :=Iif(SA1->A1_SALDUPM>SA1->A1_MSALDO,SA1->A1_SALDUPM,SA1->A1_MSALDO)
					If ( nValForte > SA1->A1_MAIDUPL )
						SA1->A1_MAIDUPL := nValForte
					EndIf
					DbSelectArea("SA1")
					If ( nValTot > SA1->A1_MCOMPRA )
						SA1->A1_MCOMPRA := nValTot
					EndIf
					MsUnlock()
				EndIf
			EndIf
		EndIf
		If __lLocBRA
			DbSelectArea( "SE1" )
			cParcela 	:= SE1->E1_PARCELA
			dEmissao 	:= SE1->E1_EMISSAO
			dVencto		:= SE1->E1_VENCTO
			dVencRea	:= SE1->E1_VENCREA
			If lBorde .and. AllTrim(FunName()) <> "FINA890"
				dEmissao 	:= SEA->EA_DATABOR
			EndIf
			If !lIrfMR
				nIrrf 	:= SE1->E1_IRRF
			EndIf
			If !lIssMR
				nIss		:= SE1->E1_ISS
				nBtrIss		:= SE1->E1_BTRISS
				lValBtrISS 	:= nBtrIss > 0

				If Alltrim(SE1->E1_ORIGEM) $ "TMSA491/TMSA850" .And. Type('nDTCISS') <> 'U' .And. nModulo == 43 //TMS
					nIss 	:= nDTCISS
				EndIf
			EndIf
			If !lInsMR
				nInss 		:= SE1->E1_INSS
			EndIf
			cNatur		:= SE1->E1_NATUREZ
			cCliente 	:= SE1->E1_CLIENTE
			cLoja 		:= SE1->E1_LOJA
			If !lPccMR
				nCofins  	:= SE1->E1_COFINS
				If nBase061 > 0	//Chamado pela rotina de criacao de bordero de imposto a receber e PCC na baixa	os valores do PCC estarao preenchidos.
					If lRetPIX
						nCofins := nCofFin891
						nPis    := nPisFin891
						nCsll   := nCslFin891
						nIrrf   := nIrfFin891
					Else
						nCofins	:=	nCofFina061
						nPis	:=	nPisFina061
						nCsll	:= 	nCslFina061
					EndIf
				ElseIf nBase061 = 0
					nCofins 	:= SE1->E1_COFINS
					nPis     	:= SE1->E1_PIS
					nCsll    	:= SE1->E1_CSLL
				EndIf
				If !lRetPIX .and. lIRBx .and. lBorde
					nIrrf		:= nIrrfFina061
				EndIf
			EndIf

			//Tratamento loja para manter a chave do titulo pai informado no parametro
			If Upper(subs(cOrigem,1,3)) == "LOJ"
				If Empty(cTitPai)
					cTitPai := SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA)
				EndIf
			Else
				cTitPai := SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA)
			EndIf

			// Gravação da taxa contratada para gravação no titulo de imposto (abatimento)
			// que poderá ser gerado futuramente na moeda 1
			If SE1->E1_MOEDA <> 1
				nTaxaTit := SE1->E1_TXMOEDA
			Endif
			nFetHab := SE1->E1_FETHAB
			nFabov  := SE1->E1_FABOV
			nTPDP   := SE1->E1_TPDP
			nFacs   := SE1->E1_FACS

			If lFamad == Nil
				lFamad := SE1->(ColumnPos("E1_PARCFAM")) > 0 .and. SE1->(ColumnPos("E1_FAMAD")) > 0
			EndIf

			If lFamad
				nFamad  := SE1->E1_FAMAD
			Endif

			If lFumipeq == NIL
				lFumipeq	:= (SE1->(ColumnPos("E1_FMPEQ")) > 0 .And. SE1->(ColumnPos("E1_PARCFMP")) > 0)
			Endif

			If __lCposIMA == NIL
				__lCposIMA	:= (SE1->(ColumnPos("E1_IMA"))   > 0 .And. SE1->(ColumnPos("E1_PARCIMA")) > 0)
			Endif

			If __lCposIMA
				nIMA := SE1->E1_IMA
			Endif
						
			If lFumipeq
				nFumipeq := SE1->E1_FMPEQ
			EndIf

			//Gravação dos impostos pelo motor de retenções
			If __lMotRet .And. Len(aMotRet) > 0
				FinGrvImp( "2", SE1->(RECNO()), aMotRet, cOrigem, .F., {}, {}, .T., .F., .F., , "", "", SE1->E1_TIPO $ MVRECANT)
			EndIf
			//----------------------------------------------
			// Gera titulo de IRRF
			//----------------------------------------------
			If !lIrfMR .And. ( nIrrf > 0 .And.  Iif(lBorde,lIRBx ,!__lIrPjBxCr))
				If ( SED->ED_RECIRRF == "2" .OR. ( SA1->A1_RECIRRF == "2" .AND. SED->ED_RECIRRF $ "3| " ) )
					
					// Cria o Fornecedor, caso nao exista
					DbSelectArea("SA2")
					SA2->(DbSetOrder(1))
					If !DbSeek(xFilial("SA2")+cUniao+cLojaIrf)
						Reclock("SA2",.T.)
						SA2->A2_FILIAL  := cFilial
						SA2->A2_COD 	:= cUniao
						SA2->A2_LOJA	:= cLojaIrf
						SA2->A2_NOME	:= "UNIAO"
						SA2->A2_NREDUZ  := "UNIAO"
						SA2->A2_BAIRRO  := "."
						SA2->A2_MUN 	:= "."
						SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
						SA2->A2_End 	:= "."
						SA2->A2_TIPO	:= "J"
						MsUnlock()
					EndIf
					
					cParcIRF := ParcImposto(cPrefixo,cNum,MVTAXA)
					dNextDay := F050vImp("IRRF",dEmissao,dDataBase,dVencrea)
					dVencRea := dNextDay
					RecLock("SE2",.T.)
					SE2->E2_FILIAL	:= cFilial
					SE2->E2_PREFIXO	:= cPrefixo
					SE2->E2_NUM		:= cNum
					SE2->E2_PARCELA	:= cParcIRF
					SE2->E2_TIPO	:= MVTAXA
					SE2->E2_EMISSAO	:= dEmissao
					SE2->E2_VALOR	:= nIrrf
					SE2->E2_VENCREA	:= dVencrea
					SE2->E2_SALDO	:= nIrrf
					SE2->E2_VENCTO	:= dVencRea
					SE2->E2_VENCORI	:= dVencRea
					SE2->E2_MOEDA	:= If(__lLocBRA,1,nMoeda)
					SE2->E2_EMIS1	:= dDataBase
					SE2->E2_FORNECE	:= cUniao
					SE2->E2_VLCRUZ	:= Round(nIrrf, MsDecimais(1) )
					SE2->E2_LOJA	:= SA2->A2_LOJA
					SE2->E2_NOMFOR	:= SA2->A2_NREDUZ
					SE2->E2_ORIGEM	:= Upper(cOrigem)
					cNatureza		:= &(GetMv("MV_IRF"))
					SE2->E2_NATUREZ	:= cNatureza
					SE2->E2_LA		:= cLA			// Herda do principal
					SE2->E2_CODAPRO	:= cCodAprov
					SE2->E2_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
					SE2->E2_TITPAI  := cTitpai
					If __lLocBRA .and. !Empty(SED->ED_CODRET)
						SE2->E2_DIRF		:= "1"
						SE2->E2_CODRET		:= SED->ED_CODRET
					EndIf

					MsUnLock()

                    if lPLSTITPF
                        PLSTITPF('SE2',cTitPai)
                    endIf

					AADD(aRecImpos,{"SE2",Recno()})

					//GRAVAR A PARCELA DO IRRF NO TITULO PRINCIPAL NO SE1
					DbSelectArea("SE1")
					DbGoTo(nSavRec)
					RecLock("SE1",.F.)
					SE1->E1_PARCIRF	:= cParcIRF
					SE1->(MsUnLock())

					// Gera lançamento do IRRF no SIGAPCO a partir do contas a pagar
					If Upper(cOrigem) == "FINA040"
						PCODetLan("000001","12",Upper(cOrigem))
					EndIf
				Endif

				If  ( SED->ED_RECIRRF == "1" .OR.( SA1->A1_RECIRRF == "1" .AND. SED->ED_RECIRRF $ "3| " ) )

					If __lIRMP232 == NIL
						__lIRMP232 	:= (GetNewPar("MV_IRMP232","2") != "1")
					Endif

					If __lIRMP232

						cNatureza	:= &(SuperGetMV("MV_IRF"))
						cNatureza	:= PadR(cNatureza, __nTamNat)

						// Busca a parcela IR de acordo com o titulo
						dbSelectArea("SE1")
						dbSetOrder(1)

						cParcela := SE1->E1_PARCELA
						While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+left(MVIRABT,3))
							cParcela := Soma1(cParcela,__nTamParc)
						EndDo

						DbSelectArea("SE1")
						RecLock("SE1",.T.)
						SE1->E1_FILIAL  := cFilSE1
						SE1->E1_PREFIXO := cPrefixo
						SE1->E1_NUM 	:= cNum
						SE1->E1_EMISSAO := dEmissao
						SE1->E1_VALOR	:= nIrrf
						SE1->E1_VENCREA := dVencRea
						SE1->E1_VENCTO  := dVencto
						SE1->E1_VENCORI := dVencto
						SE1->E1_EMIS1	:= dDataBase
						SE1->E1_CLIENTE := cCliente
						SE1->E1_LOJA	:= cLoja
						SE1->E1_SITUACA := "0"
						SE1->E1_NOMCLI  := SA1->A1_NREDUZ
						SE1->E1_MOEDA	:= If(__lLocBRA,1,nMoeda)
						SE1->E1_VLCRUZ  := Round( nIrrf , MsDecimais(1) )

						If (lIRBx .And. lBorde)
							SE1->E1_STATUS	 	:= "B"
							SE1->E1_ORIGEM		:= cOrigImp
							SE1->E1_TIPO	  	:= "IRF"
							SE1->E1_PARCELA		:= ParcImpRec(cPrefixo,cNum,"IRF")
							SE1->E1_SALDO	 	:= 0
							SE1->E1_OCORREN 	:= Space(2)
						Else
							SE1->E1_PARCELA		:= cParcela
							SE1->E1_STATUS 		:= Iif(SE1->E1_SALDO>0.01,"A","B")
							SE1->E1_ORIGEM 		:= UPPER(cOrigem)
							SE1->E1_TIPO		:= MVIRABT
							SE1->E1_SALDO	 	:= nIrrf
							SE1->E1_OCORREN 	:= "04"
						Endif
						SE1->E1_NATUREZ 	:= cNatureza
						SE1->E1_LA      	:= cLa
						SE1->E1_FATURA		:= cFatura
						SE1->E1_TXMOEDA 	:= nTaxaTit
						SE1->E1_FILORIG  	:= If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
						SE1->E1_TITPAI 		:= cTitpai
						SE1->E1_CODIRRF 	:= cCodIrrf
						If __lLocBRA .and. !Empty(SED->ED_CODRET)
							SE1->E1_CODRET	:= SED->ED_CODRET
						EndIf

						lAbateuIRF	:=	.T.

						AADD(aRecImpos,{"SE1",Recno()})

						If __lF040IRF == NIL
							__lF040IRF 	:= ExistBlock("F040IRF")
						Endif

						If __lF040IRF
							Execblock("F040IRF",.F.,.F.,nSavRec)
						EndIf

						AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))

                        if lPLSTITPF
                            PLSTITPF('SE1',cTitPai)
                        endIf

						// Baixa do Saldo do cliente o valor do IR.
						DbSelectArea("SA1")
						If lAtuSalDup .and. ( DbSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA ))
							If !lLojaDin
								AtuSalDup("-",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,SE1->E1_TXMOEDA,SE1->E1_EMISSAO,,,lGrvSa1)
							EndIf
						EndIf

						// Gera lançamento do IRRF no SIGAPCO a partir do contas a receber
						If Upper(cOrigem) == "FINA040"
	    					PCODetLan("000001","06",Upper(cOrigem))
						EndIf

					Else
						lAbateuIRF	:=	.F.
					EndIf
				Endif
		    Endif
			//----------------------------------------------
			// Gera titulo de INSS 
			//----------------------------------------------
			If !lInsMR .And. ( nInss > 0 ) .And. !lBorde
				
				// Busca a parcela INSS de acordo com o titulo
				dbSelectArea("SE1")
				dbSetOrder(1)

				cParcela := SE1->E1_PARCELA
				nRecSE1 := SE1->(Recno())

				While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+left(MVINABT,3))
					cParcela := Soma1(cParcela,__nTamParc)
				EndDo

				cNatureza	:= &(SuperGetMV("MV_INSS"))
				cNatureza	:= PadR(cNatureza, __nTamNat)

				If SE1->(Eof())
					SE1->(dbGoTo(nRecSE1))
				EndIf

				SA1->(DbSetOrder(1))
				cChaveSE1 := IIf(!Empty(SE1->(E1_CLIENTE+E1_LOJA)),SE1->(E1_CLIENTE+E1_LOJA),IIf(Type("M->E1_CLIENTE") != "U",M->(E1_CLIENTE+E1_LOJA),""))
				SA1->(DbSeek(xFilial("SA1")+cChaveSE1))

				If SA1->A1_RECINSS == "S" .Or. AllTrim(cOrigem) == "FINA040"
					RecLock("SE1",.T.)
					SE1->E1_FILIAL  := cFilSE1
					SE1->E1_PREFIXO := cPrefixo
					SE1->E1_NUM 	:= cNum
					SE1->E1_PARCELA := cParcela
					SE1->E1_TIPO	:= MVINABT
					SE1->E1_EMISSAO := dEmissao
					SE1->E1_VALOR	:= nInss
					SE1->E1_VENCREA := dVencRea
					SE1->E1_SALDO	:= nInss
					SE1->E1_VENCTO  := dVencto
					SE1->E1_VENCORI := dVencto
					SE1->E1_EMIS1	:= dDataBase
					SE1->E1_CLIENTE := cCliente
					SE1->E1_LOJA	:= cLoja
					SE1->E1_SITUACA := "0"
					SE1->E1_NOMCLI  := SA1->A1_NREDUZ
					SE1->E1_MOEDA	:= If(__lLocBRA,1,nMoeda)
					SE1->E1_VLCRUZ  := Round( nInss, MsDecimais(1) )
					SE1->E1_STATUS  := Iif(SE1->E1_SALDO > 0.01,"A","B")
					SE1->E1_ORIGEM  := UPPER(cOrigem)
					SE1->E1_OCORREN := "04"
					SE1->E1_NATUREZ := cNatureza
					SE1->E1_LA      := cLa
					SE1->E1_FATURA  := cFatura
					SE1->E1_TXMOEDA := nTaxaTit
					SE1->E1_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
					SE1->E1_TITPAI  := cTitpai

   					AADD(aRecImpos,{"SE1",Recno()})

					If __lF040INS == NIL
						__lF040INS 	:= ExistBlock("F040INS")
					Endif

 					If __lF040INS
						Execblock("F040INS",.F.,.F.,nSavRec)
					EndIf

                    MsUnlock()

                    if lPLSTITPF
                        PLSTITPF('SE1',cTitPai)
                    endIf

					// Baixa do Saldo do cliente o valor do Inss
					DbSelectArea("SA1")
					If lAtuSalDup .AND. ( DbSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA ))
						If !lLojaDin
							AtuSalDup("-",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,SE1->E1_TXMOEDA,SE1->E1_EMISSAO,,,lGrvSa1)
						EndIf
					EndIf

					AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))

				ElseIf !lFINA460
               		//Cria o fornecedor caso não encontre
					DbSelectArea("SA2")
					If !(MsSeek(xFilial() + cCodMVINS + cLojaImpos))		
						Reclock("SA2",.T.)
						SA2->A2_FILIAL	:= xFilial("SA2")
						SA2->A2_COD		:= cCodMVINS
						SA2->A2_LOJA	:= If(Alltrim(cLojaImpos)<>"",cLojaImpos,PadR("00",TamSX3("A2_LOJA")[1],"0"))
						SA2->A2_NOME	:= "Instituto Nacional de Previdencia Social"
						SA2->A2_NREDUZ	:= "INPS"
						SA2->A2_BAIRRO	:= "."
						SA2->A2_MUN		:= "."
						SA2->A2_EST		:= SuperGetMv("MV_ESTADO")
						SA2->A2_END		:= "."
						SA2->A2_TIPO	:= "J"
						MsUnlock()
						FKCOMMIT()
					EndIf

					cNatureza	:= &(GetMv("MV_INSS"))
					cNatureza	:= PadR(cNatureza, __nTamNat)

					If Type("CA100FOR") <> "U"
						cTipoFor 	:= ALLTRIM(GetAdvFval("SA2","A2_TIPO",xFilial("SA2")+CA100FOR+cLoja,1,""))
						If cTipoFor == "J"
							cCNPJRET := GetAdvFval("SA2","A2_CGC",xFilial("SA2")+CA100FOR+cLoja,1,"")
						Else
							cCNPJRET := GetAdvFval("SM0","M0_CGC",cEmpAnt+xFilial("SE2"),1,"")
						EndIf
					Else
						cCNPJRET := ""
					EndIf
					cRETINS := GetAdvFval("SE2","E2_RETINS",xFilial("SE2")+cPrefixo+cNum+cParcela,1,"")

					dVencReaAux := dVencRea
					dVencRea	:= F050vImp("INSS",dEmissao,dDataBase,dVencrea)

					If "LOJ" $ cOrigem
						dbSelectArea("SE2")
						dbSetOrder(1)

						cParcela := SE2->E2_PARCELA
						nTamParc := Len(SE2->E2_PARCELA)
						While MSSeek(xFilial("SE2")+cPrefixo+cNum+cParcela+left(MVINSS,3))
							cParcela := Soma1(cParcela,nTamParc)
						EndDo
					EndIf

					RecLock("SE2",.T.)
					SE2->E2_FILIAL  := xFilial("SE2")
					SE2->E2_PREFIXO := cPrefixo
					SE2->E2_NUM 	:= cNum
					SE2->E2_PARCELA := cParcela
					SE2->E2_TIPO	:= MVINSS
					SE2->E2_EMISSAO := dEmissao
					SE2->E2_VALOR	:= nInss
					SE2->E2_VENCREA := dVencrea
					SE2->E2_SALDO	:= nInss
					SE2->E2_VENCTO  := dVencRea
					SE2->E2_VENCORI := dVencRea
					SE2->E2_MOEDA	:= If(__lLocBRA,1,nMoeda)
					SE2->E2_EMIS1	:= dDataBase
					SE2->E2_FORNECE := cCodMVINS
					SE2->E2_VLCRUZ  := nInss
					SE2->E2_LOJA	:= cLojaImpos
					SE2->E2_NOMFOR  := "INPS"
					SE2->E2_ORIGEM  := cOrigem
					SE2->E2_NATUREZ := cNatureza
					SE2->E2_LA      := cLA
					SE2->E2_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG) //filial origem do titulo pai
					SE2->E2_TITPAI  := cTitpai
					SE2->E2_CODAPRO	:= cCodAprov
					SE2->E2_RETINS  := cRETINS
					SE2->E2_CNPJRET := cCNPJRET

					MsUnLock()

                    if lPLSTITPF
                        PLSTITPF('SE2',cTitPai)
                    endIf

					AADD(aRecImpos,{"SE2",Recno()})

					AtuSldNat(SE2->E2_NATUREZ, SE2->E2_VENCREA, SE2->E2_MOEDA, "2", "P", SE2->E2_VALOR, SE2->E2_VLCRUZ, If(SE2->E2_TIPO $ MVABATIM,"-","+"))

					dVencRea := dVencReaAux
				EndIf

				//Gera lançamento do INSS no SIGAPCO a partir do contas a receber
				If Upper(cOrigem) == "FINA040"
   					PCODetLan("000001","07",Upper(cOrigem))
				EndIf

			EndIf

			//--------------------------------------------------------
			//Gera titulo de ISS
			//--------------------------------------------------------
			If !lIssMR .And. ( nIss > 0 ) .And. !lBorde
				//Cria o fornecedor, caso nao exista
				DbSelectArea("SA2")
				Dbsetorder (1)
				If !( DbSeek(xFilial("SA2")+PadR(cMunIss,__nTamFor)+cLojaImpos) )
					Reclock("SA2",.T.)
					SA2->A2_FILIAL	:= cFilial	
					SA2->A2_COD 	:= cMunIss
					SA2->A2_LOJA	:= cLojaImpos
					SA2->A2_NOME	:= cNome // MUNICIPIO
					SA2->A2_NREDUZ	:= cNome // MUNICIPIO
					SA2->A2_BAIRRO	:= "."
					SA2->A2_MUN 	:= "."
					SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
					SA2->A2_End 	:= "."
					MsUnlock()
					FKCOMMIT()
				EndIf

				cNatureza	:= &(SuperGetMV("MV_ISS"))
				cNatureza	:= PadR(cNatureza, __nTamNat)

				// Se o cliente abate o ISS, gera abatimento. Senao, gera titulo para pagamento do tributo.
				If cRecISS == "1" .And. lDescIss .And. IIF(lFINA630, lTrfISSf, .T.)

					If lGerAbtISS
						//Busca a parcela ISS de acordo com o titulo
						dbSelectArea("SE1")
						dbSetOrder(1)

						cParcela := SE1->E1_PARCELA
						nTamParc := Len(SE1->E1_PARCELA)
						While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+left(MVISABT,3))
							cParcela := Soma1(cParcela,nTamParc)
						EndDo

						If Alltrim(SM0->M0_ESTENT) == "SC" .And. ;
							( ( Len( Alltrim( SM0->M0_CODMUN ) ) == 5 .And. Alltrim( SM0->M0_CODMUN ) == "09102" ) .Or. ( Len( Alltrim( SM0->M0_CODMUN ) ) == 7 .And. SubStr( Alltrim( SM0->M0_CODMUN ) , 3 , 5 ) == "09102" ) )
							aAreaFor:= getArea("SA1")
							DbSelectArea("SA1")
							DbSetOrder(1)
							If SA1->(DbSeek(xFilial("SA1")+cCliente+cLoja)) .And. Alltrim(SA1->A1_EST) == "SC"
								dVenISS := fCRetCal(6,dEmissao)
								dVencRIss := dVenISS
								nDiaUtIss := 1
							EndIf
							restArea(aAreaFor)
						EndIf

						__nDiaUtIss := If(nDiaUtIss > 0, nDiaUtIss, __nDiaUtIss)

						RecLock("SE1",.T.)
						SE1->E1_FILIAL	:= cFilSE1
						SE1->E1_PREFIXO := cPrefixo
						SE1->E1_NUM		:= cNum
						SE1->E1_PARCELA := cParcela

						cNatureza:= &(SuperGetMV("MV_ISS"))
						SE1->E1_NATUREZ := PadR(cNatureza, __nTamNat)
						SE1->E1_TIPO	:= MVISABT
						SE1->E1_EMISSAO := dEmissao
						SE1->E1_VALOR	:= nIss
						SE1->E1_VENCREA := Iif(__nDiaUtIss == 1 .And. ValType(dVenISS) != "U",dVenISS,dVencRea)
						SE1->E1_SALDO	:= nIss
						SE1->E1_VENCTO  := Iif(__nDiaUtIss == 1 .And. ValType(dVenISS) != "U",dVenISS,dVencto)
						SE1->E1_VENCORI := Iif(__nDiaUtIss == 1 .And. ValType(dVenISS) != "U",dVenISS,dVencto)
						SE1->E1_EMIS1	:= dDataBase
						SE1->E1_CLIENTE := cCliente
						SE1->E1_LOJA	:= cLoja
						SE1->E1_NOMCLI  := SA1->A1_NREDUZ
						SE1->E1_MOEDA	:= If(__lLocBRA,1,nMoeda)
						SE1->E1_VLCRUZ  := Round( nIss, MsDecimais(1) )
						SE1->E1_STATUS  := Iif(SE1->E1_SALDO > 0.01,"A","B")
						SE1->E1_ORIGEM  := UPPER(cOrigem)
						SE1->E1_LA      := cLa
						SE1->E1_FATURA	:= cFatura
						SE1->E1_SITUACA := "0"
						SE1->E1_OCORREN := "04"
						SE1->E1_SITUACA := "0"
						SE1->E1_TXMOEDA := nTaxaTit
						SE1->E1_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
						SE1->E1_TITPAI  := cTitpai

						AADD(aRecImpos,{"SE1",Recno()})

						// Baixa do Saldo do cliente o valor do Iss
						DbSelectArea("SA1")
						If lAtuSalDup .and. ( MsSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA ))
							If !lLojaDin
								AtuSalDup("-",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,SE1->E1_TXMOEDA,SE1->E1_EMISSAO,,,lGrvSa1)
							EndIf
						EndIf

						AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))

                        if lPLSTITPF
                            PLSTITPF('SE1',cTitPai)
                        endIf

						// Gera lançamento do ISS no SIGAPCO a partir do contas a receber
						If Upper(cOrigem) == "FINA040"
	    					PCODetLan("000001","08",Upper(cOrigem))
						EndIf
					Elseif !lGerAbtISS .and. nTotISS > 0 .And. nTotISS <= __nMinISS .And. Upper(cOrigem) != "MATA460"
						SE1->E1_VALOR+= nTotISS
						SE1->E1_SALDO+= nTotISS
					EndIf

				Else
					If (!lFINA460 .And. !(cOrigem = "FINA460" .And. Funname()="FINA740")) .And. (!lFINA630 .Or. lTrfISSf)

						If __nDiaIss == NIL
							__nDiaIss := SuperGetMv("MV_DIAISS", .F., 10, )
						Endif

						If __cVencIss == NIL
							__cVencIss 	:= GetNewPar("MV_VENCISS","E")
						Endif

						Do Case
							Case __nDiaUtIss > 0 //Vencimento do ISS deve ser gerado por dias uteis.
								dVenISS	:=	LastDay(dEmissao)

								For nI:= 1 To __nDiaUtIss
									dVenISS ++
									dVenISS := DataValida(dVenISS)
								Next

							Case __cVencIss == "E"
								dVenISS := dEmissao
								dVenISS += 28
								If ( Month(dVenISS) == Month(dEmissao) )
									dVenISS := dVenISS + 28
								EndIf
								nTamData := Iif(Len(Dtoc(dVenISS)) == 10, 7, 5)
								dVenISS	:= Ctod(StrZero(__nDiaIss,2)+"/"+Subs(Dtoc(dVenISS),4,nTamData))
							Case __cVencIss == "Q" //Ultimo dia util da quinzena subsequente a dEmissao
								If Day(dEmissao) <= 15
									dVenISS	:= LastDay(dEmissao)
									dVenISS := DataValida(dVenISS,.F.)
								Else
									dVenISS := DataValida((LastDay(dEmissao)+1)+14,.F.)
								EndIf
							Case __cVencIss == "U" //Ultimo dia util do mes subsequente da dEmissao
								dVenISS := DataValida(LastDay(LastDay(dEmissao)+1),.F.)
							Case __cVencIss == "D"
								dVenISS := (LastDay(dEmissao)+1)
								nDiaUtil:= __nDiaIss
								For nDia := 1 To nDiaUtil-1
									If !(dVenISS == DataValida(dVenISS,.T.))
										nDia-=1
									EndIf
									dVenISS+=1
								Next nDia
							Case __cVencIss == "F" //Qtd de dia do parametro MV_DIAISS apos o fechamento da quinzena.
								If Day(dEmissao) <= 15
									dVenISS := CtoD("15"+SUBSTR(DtoC(dEmissao),3,Len(DtoC(dEmissao))))+__nDiaIss
								Else
									dVenISS := LastDay(dEmissao)+__nDiaIss
								EndIf
							OtherWise
								dVenISS := dVencto
								dVenISS += 28
								If ( Month(dVenISS) == Month(dVencto) )
									dVenISS := dVenISS+28
								EndIf
								nTamData := Iif(Len(Dtoc(dVenISS)) == 10, 7, 5)
								dVenISS	:= Ctod(StrZero(__nDiaIss,2)+"/"+Subs(Dtoc(dVenISS),4,nTamData))
						EndCase

						dbSelectArea("SE2")
						dbSetOrder(1)

						If "LOJ" $ cOrigem
							cParcela := SE2->E2_PARCELA
							nTamParc := Len(SE2->E2_PARCELA)
							While MSSeek(xFilial("SE2")+cPrefixo+cNum+cParcela+left(MVTAXA,3))
								cParcela := Soma1(cParcela,nTamParc)
							EndDo
						EndIf

						If __lVcAntIss == NIL
							__lVcAntIss	:= (SuperGetMV("MV_ANTVISS",.T.,"2") == "1")
						Endif

						dVencRIss := DataValida(dVenISS,IIF(__lVcAntIss,.F.,.T.))
						dVenISS := IIF(dVenIss > dVencRIss, dVencRISS, dVenIss)

						If Alltrim(SM0->M0_ESTENT) == "SC" .And. ;
						( ( Len( Alltrim( SM0->M0_CODMUN ) ) == 5 .And. Alltrim( SM0->M0_CODMUN ) == "09102" ) .Or. ( Len( Alltrim( SM0->M0_CODMUN ) ) == 7 .And. SubStr( Alltrim( SM0->M0_CODMUN ) , 3 , 5 ) == "09102" ) )
							aAreaFor:= getArea("SA1")
							DbSelectArea("SA1")
							DbSetOrder(1)
							If SA1->(DbSeek(xFilial("SA1")+cCliente+cLoja)) .And. Alltrim(SA1->A1_EST) == "SC"
								dVenISS := fCRetCal(6,dEmissao)
								dVencRIss := dVenISS
							EndIf
							restArea(aAreaFor)
						EndIf

						RecLock("SE2",.T.)
						SE2->E2_FILIAL	:= cFilial
						SE2->E2_PREFIXO := cPrefixo
						SE2->E2_NUM 	:= cNum
						SE2->E2_PARCELA := cParcela
						SE2->E2_TIPO	:= MVTAXA
						SE2->E2_EMISSAO := dEmissao
						SE2->E2_EMIS1	:= dDataBase
						SE2->E2_VALOR	:= nIss
						SE2->E2_VENCREA := dVencRIss
						SE2->E2_VENCTO  := dVenISS
						SE2->E2_SALDO	:= nIss
						SE2->E2_VENCORI := dVenISS
						SE2->E2_FORNECE := cMunIss
						SE2->E2_LOJA	:= cLojaImpos
						SE2->E2_NOMFOR  := SA2->A2_NREDUZ
						SE2->E2_MOEDA	:= If(__lLocBRA,1,nMoeda)
						SE2->E2_VLCRUZ	:= Round(SE2->E2_VALOR,MsDecimais(1))
						SE2->E2_ORIGEM  := Upper(cOrigem)
						SE2->E2_TITPAI 	:= cTitpai

						cNatureza:= &(SuperGetMV("MV_ISS"))
						SE2->E2_NATUREZ := Padr(cNatureza,__nTamNat)

						SE2->E2_LA      := cLA
						SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
						SE2->E2_CODAPRO	:= cCodAprov

						AADD(aRecImpos,{"SE2",Recno()})

						//Gera lançamento do ISS no SIGAPCO a partir do contas a pagar
						If Upper(cOrigem) == "FINA040"
	    					PCODetLan("000001","13",Upper(cOrigem))
						EndIf
					Endif
				Endif
				MsUnLock()

				If ExistBlock("F040ISS")
					Execblock("F040ISS",.F.,.F.,nSavRec)
				EndIf
			EndIf

			//--------------------------------------
			//Bitributacao ISS
			//--------------------------------------
			If lValBtrISS

				dbSelectArea("SE1")
				dbSetOrder(1)

				cParcela := SE1->E1_PARCELA
				nTamParc := __nTamParc

				While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+left(MVISABT,3))
					cParcela := Soma1(cParcela,nTamParc)
				EndDo

				cNatureza:= &(SuperGetMV("MV_ISS"))

				RecLock("SE1",.T.)
				SE1->E1_FILIAL  := cFilSE1
				SE1->E1_PREFIXO := cPrefixo
				SE1->E1_NUM 	:= cNum
				SE1->E1_PARCELA := cParcela
				SE1->E1_NATUREZ := Padr(cNatureza,__nTamNat)
				SE1->E1_TIPO	:=  "I2-"
				SE1->E1_EMISSAO := dEmissao
				SE1->E1_VALOR	:= nbtrIss
				SE1->E1_VENCREA := Iif(__nDiaUtIss == 1 .And. ValType(dVenISS) != "U",dVenISS,dVencRea)
				SE1->E1_SALDO	:= nbtrIss
				SE1->E1_VENCTO  := Iif(__nDiaUtIss == 1 .And. ValType(dVenISS) != "U",dVenISS,dVencto)
				SE1->E1_VENCORI := Iif(__nDiaUtIss == 1 .And. ValType(dVenISS) != "U",dVenISS,dVencto)
				SE1->E1_EMIS1	:= dDataBase
				SE1->E1_CLIENTE := cCliente
				SE1->E1_LOJA	:= cLoja
				SE1->E1_NOMCLI  := SA1->A1_NREDUZ
				SE1->E1_MOEDA	:= If(__lLocBRA,1,nMoeda)
				SE1->E1_VLCRUZ  := Round( nIss, MsDecimais(1) )
				SE1->E1_STATUS  := Iif(SE1->E1_SALDO>0.01,"A","B")
				SE1->E1_ORIGEM  := UPPER(cOrigem)
				SE1->E1_LA      := cLa
				SE1->E1_FATURA	:= cFatura
				SE1->E1_SITUACA := "0"
				SE1->E1_OCORREN := "04"
				SE1->E1_SITUACA := "0"
				SE1->E1_TXMOEDA := nTaxaTit
				SE1->E1_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
				SE1->E1_TITPAI  := cTitpai

				AADD(aRecImpos,{"SE1",Recno()})

				SE1->(MsUnLock())

                if lPLSTITPF
                    PLSTITPF('SE1',cTitPai)
                endIf

			Endif

			//-----------------------------------------------
			// Gera titulo Funrural
			//-----------------------------------------------
			If !lFunMR
				nValFun := Iif(Type("nValFun")=="U",0,nValFun)
				If ( nValFun > 0 ) .And. !lBorde

					If __lLocBRA
						If SED->(DbSeek(xFilial("SED")+cNatur))
							lRecFun	:=	If(SED->ED_RECFUN=="1",.T.,.F.) //cliente recolhe o imposto funrural
						Endif
					Endif

					If __cCSSNAT == NIL
						__cCSSNAT	:= PadR(SuperGetMV("MV_CSS",.F.,"CSS"),__nTamNat)
					Endif

					If __lNTFUNR == NIL
						__lNTFUNR 	:= ExistBlock("NTFUNR")
					Endif					

					IF __lNTFUNR
						__cCSSNAT := ExecBlock("NTFUNR",.f.,.f.,{cOrigem,cPrefixo})
						__cCSSNAT := PADR( __cCSSNAT, __nTamNat )					
					Endif

					// Cria a natureza FUNRURAL caso nao exista					
					cNatureza := __cCSSNAT
						
					If !SED->(DbSeek(cFilial+__cCSSNAT))
						RecLock("SED",.T.)
						SED->ED_FILIAL  := cFilial
						SED->ED_CODIGO  := cNatureza
						SED->ED_CALCIRF := "N"
						SED->ED_CALCISS := "N"
						SED->ED_CALCINS := "N"
						SED->ED_CALCCSL := "N"
						SED->ED_CALCCOF := "N"
						SED->ED_CALCPIS := "N"
						SED->ED_DESCRIC := "CONTRIBUICAO SEGURIDADE SOCIAL"
						SED->ED_TIPO	:= "2"
						MsUnlock()
						FKCOMMIT()
					EndIf

					dVenFun := dEmissao + 28
					If Month(dVenFun) == Month(dEmissao)
						dVenFun := dVenFun+28
					EndIf
					nTamData := If(Len(Dtoc(dVenFun)) == 10, 7, 5)
					dVenFun	:= Ctod(StrZero(SuperGetMV("MV_DIAFUN"),2)+"/"+Subs(Dtoc(dVenFun),4,nTamData))
					dVencRea := DataValida(dVenFun,.F.)
					DbSelectArea("SA1")
					DbGoTo(nSalvCli)
					//Caso o cliente seja do tipo revendedor e a natureza esteja configurada para o cliente recolher o funrural
					//ou o tipo de cliente não seja L ou F deve ser gerado um titulo a receber para o imposto.
					//Porem se o cliente for do tipo revendedor e natureza esteja configurada para que o cliente não recolha o funrural
					//ou o tipo do cliente seja L ou F	deve ser gerado um titulo a pagar para o imposto.
					If (__lLocBRA .And. lRecFun .And. SM0->M0_PRODRUR $ "FL13" .and. SA1->A1_PESSOA == "J" .and. SA1->A1_TIPO == "R") 
						
						//Busca a parcela Funrural de acordo com o titulo
						dbSelectArea("SE1")
						dbSetOrder(1)

						cParcela := SE1->E1_PARCELA
						nTamParc := Len(SE1->E1_PARCELA)

						While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+left(MVFUABT,3))
							cParcela := Soma1(cParcela,nTamParc)
						EndDo

						RecLock("SE1",.T.)
						SE1->E1_FILIAL  := cFilSE1
						SE1->E1_PREFIXO := cPrefixo
						SE1->E1_NUM 	:= cNum
						SE1->E1_PARCELA := cParcela
						SE1->E1_NATUREZ := cNatureza
						SE1->E1_TIPO	:= MVFUABT
						SE1->E1_EMISSAO := dEmissao
						SE1->E1_VALOR	:= nValFun
						SE1->E1_VENCREA := dEmissao
						SE1->E1_SALDO	:= nValFun
						SE1->E1_VENCTO  := dEmissao
						SE1->E1_VENCORI := dEmissao
						SE1->E1_EMIS1	:= dDataBase
						SE1->E1_CLIENTE := SA1->A1_COD
						SE1->E1_LOJA	:= SA1->A1_LOJA
						SE1->E1_NOMCLI  := SA1->A1_NREDUZ
						SE1->E1_MOEDA	:= If(cPaisLoc=="BRA",1,nMoeda)
						SE1->E1_VLCRUZ  := Round( nValFun, MsDecimais(1) )
						SE1->E1_STATUS  := Iif(SE1->E1_SALDO>0.01,"A","B")
						SE1->E1_ORIGEM  := UPPER(cOrigem)
						SE1->E1_LA      := cLa
						SE1->E1_FATURA	:= cFatura
						SE1->E1_SITUACA := "0"
						SE1->E1_TXMOEDA := nTaxaTit
						SE1->E1_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
						SE1->E1_TITPAI  := cTitpai

						AADD(aRecImpos,{"SE1",Recno()})

						// Baixa do Saldo do cliente o valor do Funrural
						DbSelectArea("SA1")
						If ( MsSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA )) .And. lAtuSalDup
							If !lLojaDin
								AtuSalDup("-",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,SE1->E1_TXMOEDA,SE1->E1_EMISSAO,,,lGrvSa1)
							EndIf
						EndIf

						AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))

						MsUnLock()

                        if lPLSTITPF
                            PLSTITPF('SE1',cTitPai)
                        endIf

					Else

						// Cria o fornecedor, caso nao exista
						DbSelectArea("SA2")
						DbSetOrder(1)
						If !(DbSeek(xFilial() + cCodMVINS + cLojaImpos))
							Reclock("SA2",.T.)
							SA2->A2_FILIAL := cFilial
							SA2->A2_COD 	:= cCodMVINS
							SA2->A2_LOJA	:= cLojaImpos
							SA2->A2_NOME	:= "Instituto Nacional de Previdencia Social"
							SA2->A2_NREDUZ := "INPS"
							SA2->A2_BAIRRO := "."
							SA2->A2_MUN 	:= "."
							SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
							SA2->A2_End 	:= "."
							SA2->A2_TIPO	:= "J"
							MsUnlock()
							FKCOMMIT()
						EndIf

						// Gera titulo para uniao, pois quando a venda é para pessoa fisica quem recolhe o funrural é quem vende
						DbSelectArea("SE2")
						RecLock("SE2",.T.)
						SE2->E2_FILIAL  := cFilial
						SE2->E2_PREFIXO := cPrefixo
						SE2->E2_NUM 	:= cNum
						SE2->E2_PARCELA := cParcela
						SE2->E2_NATUREZ := cNatureza
						SE2->E2_TIPO	:= MVTAXA
						SE2->E2_EMISSAO := dEmissao
						SE2->E2_VALOR	:= nValFun
						SE2->E2_VENCTO  := dVenFun
						SE2->E2_SALDO	:= nValFun
						SE2->E2_VENCREA := dVencRea
						SE2->E2_VENCORI := dVenFun
						SE2->E2_EMIS1	:= dDataBase
						SE2->E2_FORNECE := cCodMVINS
						SE2->E2_LOJA	:= cLojaImpos
						SE2->E2_NOMFOR  := SA2->A2_NREDUZ
						SE2->E2_MOEDA	:= If(__lLocBRA,1,nMoeda)
						SE2->E2_VLCRUZ	:= Round(SE2->E2_VALOR,MsDecimais(1))
						SE2->E2_ORIGEM  := Upper(cOrigem)
						SE2->E2_LA      := cLa
						SE2->E2_CODAPRO	:= cCodAprov
						SE2->E2_FILORIG := cFilAnt

						AADD(aRecImpos,{"SE2",Recno()})

						If __lM040CSSR == NIL
							__lM040CSSR	:= ExistBlock("M040CSSR")
						Endif

						If __lM040CSSR
							ExecBlock("M040CSSR",.F.,.F.)
						Endif

						MsUnlock()
					EndIf
				EndIf
			EndIf

			If !lPccMR
				If lFina040 .And. __lCodRtPCC
					lCdRetInd := ( nPis <= 0 .Or. nCofins <= 0 .Or. nCsll <= 0 ) .And. M->E1_CODRET $ "5987|5960|5979"
				ElseIf __lLocBRA .And. __lCodRtPCC .And. Alltrim(FUNNAME()) $ "MATA460A_MATA461_MATA460"
					aPcc		:= newMinPcc(dRef, SE1->E1_VALOR,SE1->E1_NATUREZ,"R",SA1->A1_COD+SA1->A1_LOJA,nil,nil,nil,.F.,nil,nil)
	   				lCdRetInd	:= ( aPcc[2] <= 0 .Or. aPcc[3] <= 0 .Or. aPcc[4] <= 0 ) .And. SED->ED_PCCINDV == '1'
	   				If lCdRetInd
	   					If Alias() == "SE1"
	   						Replace E1_CODRET with "5952"
	   					EndIf
	   					nPis 	:= Iif( aPCC[2] <= nVRetPIS	, 0, aPCC[2] )
	   					nCofins	:= Iif( aPCC[3] <= nVRetCOF	, 0, aPCC[3] )
	   					nCsll	:= Iif( aPCC[4] <= nVRetCSLL, 0, aPCC[4] )
					EndIf
	   			EndIf

				// Caso nao exista os tres impostos, o codigo de retencao sera diferenciado para cada imposto
				If	lCdRetInd
					cCodRetPis := "5979"
					cCodRetCof := "5960"
					cCodRetCsl := "5987"
				Else
					// Se os 3 impostos juntos for maior que a media de retencao, o codigo sera o mesmo para os tres.
					If SE1->(E1_PIS+E1_COFINS+E1_CSLL) > ((__nVRetPIS+__nVRetCOF+__nVRetCSLL) / 3)
						cCodRetPis := "5952"
						cCodRetCof := "5952"
						cCodRetCsl := "5952"
					Endif
				Endif

				//-------------------------------------------------------------
				// Gera titulo de COFINS
				//-------------------------------------------------------------
				If ( nCofins > 0 .And. ((!__lPccBxCr .And. !lBorde ) .Or. (nBase061 > __nVlMinImp .Or.  lGeraTitMin )  ) )

					If lAbate
						
						// Busca a parcela Cofins de acordo com o titulo
						dbSelectArea("SE1")
						dbSetOrder(1)

						cParcela := SE1->E1_PARCELA
						While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+left(MVCFABT,3))
							cParcela := Soma1(cParcela,__nTamParc)
						EndDo

						RecLock("SE1",.T.)
						SE1->E1_FILIAL  := cFilSE1
						SE1->E1_PREFIXO := cPrefixo
						SE1->E1_NUM     := cNum
						SE1->E1_PARCELA := cParcela
						SE1->E1_EMISSAO := dEmissao
						SE1->E1_EMIS1   := dDataBase
						SE1->E1_VALOR   := nCofins
						SE1->E1_VENCTO  := dVencto
						SE1->E1_VENCREA := dVencRea
						SE1->E1_VENCORI := dVencto
						SE1->E1_CLIENTE := cCliente
						SE1->E1_LOJA    := cLoja
						SE1->E1_NOMCLI  := SA1->A1_NREDUZ
						SE1->E1_MOEDA   := If(__lLocBRA,1,nMoeda)
						SE1->E1_VLCRUZ  := Round(SE1->E1_VALOR,MsDecimais(1))
						SE1->E1_NATUREZ := __cCOFNAT
						SE1->E1_SITUACA := "0"

						If nBase061 > 0
							SE1->E1_STATUS  	:= "B"
							SE1->E1_ORIGEM		:= cOrigImp
							SE1->E1_PARCELA 	:= ParcImpRec(cPrefixo,cNum,"COF")
							SE1->E1_TIPO    	:= "COF"
							SE1->E1_SALDO		:= 0
							SE1->E1_OCORREN 	:= Space(2)
						Else
							SE1->E1_STATUS  	:= "A"
							SE1->E1_ORIGEM  	:= Upper(cOrigem)
							SE1->E1_PARCELA 	:= cParcela
							SE1->E1_TIPO    	:= MVCFABT
							SE1->E1_SALDO   	:= nCofins
							SE1->E1_OCORREN 	:= "04"
						Endif
						SE1->E1_LA      := cLa
						SE1->E1_FATURA  := cFatura
						SE1->E1_TXMOEDA := nTaxaTit
						SE1->E1_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
						SE1->E1_TITPAI  := cTitpai

						AADD(aRecImpos,{"SE1",Recno()})

						// Baixa do Saldo do cliente o valor do COFINS
						DbSelectArea("SA1")
						If ( MsSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA )) .And. lAtuSalDup
							If !lLojaDin
								AtuSalDup("-",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,SE1->E1_TXMOEDA,SE1->E1_EMISSAO,,,lGrvSa1)
							EndIf
						EndIf

						AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))

                        if lPLSTITPF
                            PLSTITPF('SE1',cTitPai)
                        endIf

						lAbateuCOF := .T.

						If __lF040COF == NIL
							__lF040COF 	:= ExistBlock("F040COF")
						Endif

						If __lF040COF
							Execblock("F040COF",.F.,.F.,nSavRec)
						EndIf

						// Gera lançamento do COFINS no SIGAPCO a partir do contas a receber
						If Upper(cOrigem) == "FINA040"
	    					PCODetLan("000001","09",Upper(cOrigem))
						EndIf
					Else
						lAbateuCOF := .F.
					EndIf

				EndIf

				//---------------------------------------------------------------------
				// Gera titulo de PIS
				//---------------------------------------------------------------------
				If ( nPis > 0 .And. ( (!__lPccBxCr  .And. !lBorde)  .Or. (nBase061 > __nVlMinImp .Or. lGeraTitMin) ) )

					If lAbate

						//Busca a parcela PIS de acordo com o titulo
						dbSelectArea("SE1")
						dbSetOrder(1)

						cParcela := SE1->E1_PARCELA

						While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+left(MVPIABT,3))
							cParcela := Soma1(cParcela,__nTamParc)
						EndDo

						RecLock("SE1",.T.)
						SE1->E1_FILIAL  := cFilSE1
						SE1->E1_PREFIXO := cPrefixo
						SE1->E1_NUM     := cNum
						SE1->E1_EMISSAO := dEmissao
						SE1->E1_EMIS1   := dDataBase
						SE1->E1_VALOR   := nPis
						SE1->E1_VENCTO  := dVencto
						SE1->E1_VENCREA := dVencRea
						SE1->E1_VENCORI := dVencto
						SE1->E1_CLIENTE := cCliente
						SE1->E1_LOJA    := cLoja
						SE1->E1_NOMCLI  := SA1->A1_NREDUZ
						SE1->E1_MOEDA   := If(__lLocBRA,1,nMoeda)
						SE1->E1_VLCRUZ  := Round(SE1->E1_VALOR,MsDecimais(1))
						SE1->E1_NATUREZ := __cPISNAT

						If nBase061 > 0
							SE1->E1_STATUS  	:= "B"
							SE1->E1_ORIGEM		:= cOrigImp
							SE1->E1_PARCELA 	:= ParcImpRec(cPrefixo,cNum,"PIS")
							SE1->E1_TIPO    	:= "PIS"
							SE1->E1_SALDO   	:= 0
							SE1->E1_OCORREN   := Space(2)
						Else
							SE1->E1_STATUS  	:= "A"
							SE1->E1_ORIGEM  	:= Upper(cOrigem)
							SE1->E1_PARCELA 	:= cParcela
							SE1->E1_TIPO    	:= MVPIABT
							SE1->E1_SALDO   	:= nPis
							SE1->E1_OCORREN 	:= "04"
						Endif

						SE1->E1_SITUACA := "0"
						SE1->E1_LA      := cLa
						SE1->E1_FATURA	:= cFatura
						SE1->E1_TXMOEDA := nTaxaTit
						SE1->E1_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
						SE1->E1_TITPAI 	:= cTitpai

						AADD(aRecImpos,{"SE1",Recno()})

						// Baixa do Saldo do cliente o valor do PIS
						DbSelectArea("SA1")
						If ( MsSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA )) .And. lAtuSalDup
							If !lLojaDin
								AtuSalDup("-",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,SE1->E1_TXMOEDA,SE1->E1_EMISSAO,,,lGrvSa1)
							EndIf
						EndIf

						AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))

                        if lPLSTITPF
                            PLSTITPF('SE1',cTitPai)
                        endIf

						lAbateuPIS := .T.

						If __lF040PIS == NIL
							__lF040PIS 	:= ExistBlock("F040PIS")
						Endif

						If __lF040PIS
							Execblock("F040PIS",.F.,.F.,nSavRec)
						EndIf

						// Gera lançamento do PIS no SIGAPCO a partir do contas a receber
						If Upper(cOrigem) == "FINA040"
	    					PCODetLan("000001","10",Upper(cOrigem))
						EndIf

					Else
						lAbateuPIS := .F.
					EndIf

				EndIf

				//----------------------------------------------
				// Gera titulo de CSLL
				//----------------------------------------------
				If ( nCsll > 0 .And. ( (!__lPccBxCr .And. !lBorde) .Or. (nBase061 > __nVlMinImp .Or.  lGeraTitMin ) ) )

					If lAbate
						//Busca a parcela CSLL de acordo com o titulo
						dbSelectArea("SE1")
						dbSetOrder(1)

						cParcela := SE1->E1_PARCELA

						While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+left(MVCSABT,3))
							cParcela := Soma1(cParcela,__nTamParc)
						EndDo

						RecLock("SE1",.T.)
						SE1->E1_FILIAL  := cFilSE1
						SE1->E1_PREFIXO := cPrefixo
						SE1->E1_NUM     := cNum
						SE1->E1_EMISSAO := dEmissao
						SE1->E1_EMIS1   := dDataBase
						SE1->E1_VALOR   := nCsll
						SE1->E1_VENCTO  := dVencto
						SE1->E1_VENCREA := dVencRea
						SE1->E1_VENCORI := dVencto
						SE1->E1_CLIENTE := cCliente
						SE1->E1_LOJA    := cLoja
						SE1->E1_NOMCLI  := SA1->A1_NREDUZ
						SE1->E1_MOEDA   := If(__lLocBRA,1,nMoeda)
						SE1->E1_VLCRUZ  := Round(SE1->E1_VALOR,MsDecimais(1))
						SE1->E1_NATUREZ := __cCSLNAT

						If nBase061 > 0
							SE1->E1_STATUS  	:= "B"
							SE1->E1_ORIGEM		:= cOrigImp
							SE1->E1_TIPO    	:= "CSL"
							SE1->E1_PARCELA 	:= ParcImpRec(cPrefixo,cNum,"CSL")
							SE1->E1_SALDO   	:= 0
							SE1->E1_OCORREN 	:= Space(2)
						Else
							SE1->E1_STATUS  	:= "A"
							SE1->E1_ORIGEM  	:= Upper(cOrigem)
							SE1->E1_PARCELA 	:= cParcela
							SE1->E1_TIPO    	:= MVCSABT
							SE1->E1_SALDO   	:= nCsll
							SE1->E1_OCORREN 	:= "04"
						Endif

						SE1->E1_SITUACA := "0"
						SE1->E1_LA      := cLa
						SE1->E1_FATURA	:= cFatura
						SE1->E1_TXMOEDA := nTaxaTit
						SE1->E1_FILORIG := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
						SE1->E1_TITPAI  := cTitpai

						AADD(aRecImpos,{"SE1",Recno()})

						//Baixa do Saldo do cliente o valor do csll
						DbSelectArea("SA1")
						If ( MsSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA )) .And. lAtuSalDup
							If !lLojaDin
								AtuSalDup("-",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,SE1->E1_TXMOEDA,SE1->E1_EMISSAO,,,lGrvSa1)
							EndIf
						EndIf

						AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))

                        if lPLSTITPF
                            PLSTITPF('SE1',cTitPai)
                        endIf

						lAbateuCSLL := .T.

						If __lF040CSL == NIL
							__lF040CSL 	:= ExistBlock("F040CSL")
						Endif

						If __lF040CSL
							Execblock("F040CSL",.F.,.F.,nSavRec)
						EndIf

						//Gera lançamento do CSLL no SIGAPCO a partir do contas a receber
						If Upper(cOrigem) == "FINA040"
	    					PCODetLan("000001","11",Upper(cOrigem))
						EndIf

					Else
						lAbateuCSLL := .F.
					EndIf
				EndIf
			EndIf

			//--------------------------------------------------------
			//Titulo do FETHAB
			//--------------------------------------------------------
			If __lAgFETHA

				If !lFetMR

					//Aglutina titulos do FETHAB
					If nFethab > 0  .And. !lBorde
						If cPaisLoc == "BRA" .And. SA1->A1_RECFET=="2" .And. Iif( "FIN" $ FunName(),SA1->A1_RECFET=="2",nValFetR == 0)
							//Cria o Fornecedor, caso nao exista
							DbSelectArea("SA2")
							SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
							If ( EOF() )
								Reclock("SA2",.T.)
								SA2->A2_FILIAL	:= cFilial
								SA2->A2_COD 	:= cCodMVRES
								SA2->A2_LOJA	:= cLojaImpos
								SA2->A2_NOME	:= "RECEITA ESTADUAL"
								SA2->A2_NREDUZ	:= "RECEITA"
								SA2->A2_BAIRRO	:= "."
								SA2->A2_MUN 	:= "."
								SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
								SA2->A2_End 	:= "."
								SA2->A2_TIPO	:= "J"
								MsUnlock()
							EndIf
			                DbSelectArea("SE2")
							SE2->(DbSetOrder(1))
			                aTamParcI := TamSx3("E2_PARCELA")
			                cParcFet  := StrZero(1,aTamParcI[1])
							While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFet + MVTAXA + PadR(cCodMVRES,__nTamFor) + cLojaImpos)
								cParcFet := Soma1(cParcFet,aTamParcI[1])
							EndDo

							RecLock("SE2",.T.)
							SE2->E2_FILIAL 	:= cFilial
							SE2->E2_FILORIG := cFilAnt
							SE2->E2_PREFIXO	:= cPrefixo
							SE2->E2_NUM    	:= cNum
							SE2->E2_PARCELA	:= cParcFet
							SE2->E2_TIPO 	:= MVTAXA
							SE2->E2_EMISSAO	:= dEmissao
							SE2->E2_EMIS1  	:= dDataBase
							SE2->E2_VALOR  	:= nFethab+nFabov+nFacs+nFamad 
							SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
							SE2->E2_SALDO  	:= nFethab+nFabov+nFacs+nFamad
							SE2->E2_VENCREA	:= DTVenIcms()
							SE2->E2_VENCORI	:= dEmissao
							SE2->E2_FORNECE	:= cCodMVRES
							SE2->E2_LOJA   	:= cLojaImpos
							SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
							SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
							SE2->E2_VLCRUZ 	:= Round(nFethab+nFabov+nFacs+nFamad, MsDecimais(1) )
							SE2->E2_ORIGEM 	:= Upper(cOrigem)
							cNatureza      	:= SuperGetMV("MV_FETNAT",.F.,"FETHAB")
							IF ExistBlock("NTFETHAB")
								cNatureza   := 	ExecBlock("NTFETHAB",.f.,.f.,{cOrigem,cPrefixo})
							Endif
							SE2->E2_NATUREZ	:= Alltrim(cNatureza)
							SE2->E2_CODAPRO	:= cCodAprov
							MsUnLock()

							AADD(aRecImpos,{"SE2",Recno()})

							//Gravar a parcela do Fethab no titulo principal
							DbSelectArea("SE1")
							SE1->(DbGoTo(nSavRec))
							RecLock("SE1",.F.)
							SE1->E1_PARCFET	:= cParcFet
							MsUnLock()

							//Cria a natureza Fethab caso nao exista
							DbSelectArea("SED")
							If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
								RecLock("SED",.T.)
								SED->ED_FILIAL  := cFilial
								SED->ED_CODIGO  := cNatureza
								SED->ED_CALCIRF := "N"
								SED->ED_CALCISS := "N"
								SED->ED_CALCINS := "N"
								SED->ED_CALCCSL := "N"
								SED->ED_CALCCOF := "N"
								SED->ED_CALCPIS := "N"
								SED->ED_DESCRIC := "FETHAB"
								SED->ED_TIPO	:= "2"
								MsUnlock()
							EndIf
						Else
							//Busca a parcela Fethab de acordo com o titulo
							dbSelectArea("SE1")
							dbSetOrder(1)

							cParcela := SE1->E1_PARCELA
							nTamParc := Len(SE1->E1_PARCELA)
							While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+"FE-")
								cParcela := Soma1(cParcela,nTamParc)
							EndDo

							RecLock("SE1",.T.)
							SE1->E1_FILIAL	:= cFilSE1
							SE1->E1_FILORIG := cFilAnt
							SE1->E1_PREFIXO	:= cPrefixo
							SE1->E1_NUM 	:= cNum
							SE1->E1_PARCELA	:= cParcela
							SE1->E1_TIPO   	:= "FE-"
							SE1->E1_EMISSAO	:= dEmissao
							SE1->E1_EMIS1  	:= dDataBase
							SE1->E1_VALOR  	:= nFetHab+nFabov+nFacs+nFamad 
							SE1->E1_VENCTO 	:= dVencto
							SE1->E1_SALDO  	:= nFethab+nFabov+nFacs+nFamad
							SE1->E1_VENCREA	:= dVencRea
							SE1->E1_VENCORI	:= dVencto
							SE1->E1_CLIENTE	:= cCliente
							SE1->E1_LOJA   	:= cLoja
							SE1->E1_NOMCLI 	:= SA1->A1_NREDUZ
							SE1->E1_MOEDA  	:= If(cPaisLoc=="BRA",1,nMoeda)
							SE1->E1_VLCRUZ 	:= Round(SE1->E1_VALOR,MsDecimais(1))
							SE1->E1_ORIGEM 	:= Upper(cOrigem)
							cNatureza      	:= SuperGetMV("MV_FETNAT",.F.,"FETHAB")
							IF ExistBlock("NTFETHAB")
								cNatureza   := 	ExecBlock("NTFETHAB",.f.,.f.,{cOrigem,cPrefixo})
							Endif
							SE1->E1_NATUREZ	:= Alltrim(cNatureza)
							SE1->E1_STATUS 	:= "A"
							SE1->E1_SITUACA	:= "0"
							SE1->E1_OCORREN	:= "04"
							SE1->E1_LA     	:= cLa
							SE1->E1_FATURA	:= cFatura
							SE1->E1_TITPAI  := cTitPai

							AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))

							AADD(aRecImpos,{"SE1",Recno()})

                            if lPLSTITPF
                                PLSTITPF('SE1',cTitPai)
                            endIf

							//Cria a natureza Fethab caso nao exista
							DbSelectArea("SED")
							cNatureza := AllTrim(cNatureza)
							If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
								RecLock("SED",.T.)
								SED->ED_FILIAL  := cFilial
								SED->ED_CODIGO  := cNatureza
								SED->ED_CALCIRF := "N"
								SED->ED_CALCISS := "N"
								SED->ED_CALCINS := "N"
								SED->ED_CALCCSL := "N"
								SED->ED_CALCCOF := "N"
								SED->ED_CALCPIS := "N"
								SED->ED_DESCRIC := "FETHAB"
								SED->ED_TIPO	:= "2"
							EndIf

							If ExistBlock("F040FET")
								Execblock("F040FET",.F.,.F.,nSavRec)
							Endif

						Endif
					EndIf
				EndIf
			Else
				If !lFetMR

					If nFethab > 0 .And. !lBorde
						If cPaisLoc == "BRA" .And. SA1->A1_RECFET=="2" .And. Iif( "FIN" $ FunName(),SA1->A1_RECFET=="2",nValFetR == 0)
							//Cria o Fornecedor, caso nao exista
							DbSelectArea("SA2")
							SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
							If ( EOF() )
								Reclock("SA2",.T.)
								SA2->A2_FILIAL	:= cFilial
								SA2->A2_COD 	:= cCodMVRES
								SA2->A2_LOJA	:= cLojaImpos
								SA2->A2_NOME	:= "RECEITA ESTADUAL"
								SA2->A2_NREDUZ	:= "RECEITA"
								SA2->A2_BAIRRO	:= "."
								SA2->A2_MUN 	:= "."
								SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
								SA2->A2_End 	:= "."
								SA2->A2_TIPO	:= "J"
								MsUnlock()
							EndIf
							DbSelectArea("SE2")
							SE2->(DbSetOrder(1))
							aTamParcI := TamSx3("E2_PARCELA")
							cParcFet  := StrZero(1,aTamParcI[1])
							While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFet + MVTAXA + PadR(cCodMVRES,__nTamFor) + cLojaImpos)
								cParcFet := Soma1(cParcFet,aTamParcI[1])
							EndDo

							RecLock("SE2",.T.)
							SE2->E2_FILIAL 	:= cFilial
							SE2->E2_FILORIG := cFilAnt
							SE2->E2_PREFIXO	:= cPrefixo
							SE2->E2_NUM    	:= cNum
							SE2->E2_PARCELA	:= cParcFet
							SE2->E2_TIPO 	:= MVTAXA
							SE2->E2_EMISSAO	:= dEmissao
							SE2->E2_EMIS1  	:= dDataBase
							SE2->E2_VALOR  	:= nFethab
							SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
							SE2->E2_SALDO  	:= nFethab
							SE2->E2_VENCREA	:= DTVenIcms()
							SE2->E2_VENCORI	:= dEmissao
							SE2->E2_FORNECE	:= cCodMVRES
							SE2->E2_LOJA   	:= cLojaImpos
							SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
							SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
							SE2->E2_VLCRUZ 	:= Round(nFethab, MsDecimais(1) )
							SE2->E2_ORIGEM 	:= Upper(cOrigem)
							cNatureza      	:= SuperGetMV("MV_FETNAT",.F.,"FETHAB")
							IF ExistBlock("NTFETHAB")
								cNatureza   := 	ExecBlock("NTFETHAB",.f.,.f.,{cOrigem,cPrefixo})
							Endif
							SE2->E2_NATUREZ	:= Alltrim(cNatureza)
							SE2->E2_CODAPRO	:= cCodAprov
							MsUnLock()

							AADD(aRecImpos,{"SE2",Recno()})

							//Gravar a parcela do Fethab no titulo principal
							DbSelectArea("SE1")
							SE1->(DbGoTo(nSavRec))
							RecLock("SE1",.F.)
							SE1->E1_PARCFET	:= cParcFet
							MsUnLock()

							//Cria a natureza Fethab caso nao exista
							DbSelectArea("SED")
							If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
								RecLock("SED",.T.)
								SED->ED_FILIAL  := cFilial
								SED->ED_CODIGO  := cNatureza
								SED->ED_CALCIRF := "N"
								SED->ED_CALCISS := "N"
								SED->ED_CALCINS := "N"
								SED->ED_CALCCSL := "N"
								SED->ED_CALCCOF := "N"
								SED->ED_CALCPIS := "N"
								SED->ED_DESCRIC := "FETHAB"
								SED->ED_TIPO	:= "2"
								MsUnlock()
							EndIf
						Else
							//Busca a parcela Fethab de acordo com o titulo
							dbSelectArea("SE1")
							dbSetOrder(1)

							cParcela := SE1->E1_PARCELA
							nTamParc := Len(SE1->E1_PARCELA)
							While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+"FE-")
								cParcela := Soma1(cParcela,nTamParc)
							EndDo

							RecLock("SE1",.T.)
							SE1->E1_FILIAL	:= cFilSE1
							SE1->E1_FILORIG := cFilAnt
							SE1->E1_PREFIXO	:= cPrefixo
							SE1->E1_NUM 	:= cNum
							SE1->E1_PARCELA	:= cParcela
							SE1->E1_TIPO   	:= "FE-"
							SE1->E1_EMISSAO	:= dEmissao
							SE1->E1_EMIS1  	:= dDataBase
							SE1->E1_VALOR  	:= nFetHab
							SE1->E1_VENCTO 	:= dVencto
							SE1->E1_SALDO  	:= nFethab
							SE1->E1_VENCREA	:= dVencRea
							SE1->E1_VENCORI	:= dVencto
							SE1->E1_CLIENTE	:= cCliente
							SE1->E1_LOJA   	:= cLoja
							SE1->E1_NOMCLI 	:= SA1->A1_NREDUZ
							SE1->E1_MOEDA  	:= If(cPaisLoc=="BRA",1,nMoeda)
							SE1->E1_VLCRUZ 	:= Round(SE1->E1_VALOR,MsDecimais(1))
							SE1->E1_ORIGEM 	:= Upper(cOrigem)
							cNatureza      	:= SuperGetMV("MV_FETNAT",.F.,"FETHAB")
							IF ExistBlock("NTFETHAB")
								cNatureza   := 	ExecBlock("NTFETHAB",.f.,.f.,{cOrigem,cPrefixo})
							Endif
							SE1->E1_NATUREZ	:= Alltrim(cNatureza)
							SE1->E1_STATUS 	:= "A"
							SE1->E1_SITUACA	:= "0"
							SE1->E1_OCORREN	:= "04"
							SE1->E1_LA     	:= cLa
							SE1->E1_FATURA	:= cFatura
							SE1->E1_TITPAI  := cTitPai

							AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO $ MVABATIM,"-","+"))

							AADD(aRecImpos,{"SE1",Recno()})

							if lPLSTITPF
								PLSTITPF('SE1',cTitPai)
							endIf

							//Cria a natureza Fethab caso nao exista
							DbSelectArea("SED")
							cNatureza := AllTrim(cNatureza)
							If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
								RecLock("SED",.T.)
								SED->ED_FILIAL  := cFilial
								SED->ED_CODIGO  := cNatureza
								SED->ED_CALCIRF := "N"
								SED->ED_CALCISS := "N"
								SED->ED_CALCINS := "N"
								SED->ED_CALCCSL := "N"
								SED->ED_CALCCOF := "N"
								SED->ED_CALCPIS := "N"
								SED->ED_DESCRIC := "FETHAB"
								SED->ED_TIPO	:= "2"
							EndIf
							If ExistBlock("F040FET")
								Execblock("F040FET",.F.,.F.,nSavRec)
							Endif
						Endif
					EndIf
				EndIf

				//----------------------------------------------
				//Titulo do FABOV
				//----------------------------------------------
				If !lFabMR
					If nFabov > 0 .And. !lBorde
						If SA1->A1_RFABOV == "2"
							//Cria o Fornecedor, caso nao exista
							DbSelectArea("SA2")
							SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
							If ( EOF() )
								Reclock("SA2",.T.)
								SA2->A2_FILIAL	:= cFilial
								SA2->A2_COD 	:= cCodMVRES
								SA2->A2_LOJA	:= cLojaImpos
								SA2->A2_NOME	:= "RECEITA ESTADUAL"
								SA2->A2_NREDUZ	:= "RECEITA"
								SA2->A2_BAIRRO	:= "."
								SA2->A2_MUN 	:= "."
								SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
								SA2->A2_End 	:= "."
								SA2->A2_TIPO	:= "J"
								MsUnlock()
							EndIf

							DbSelectArea("SE2")
							SE2->(DbSetOrder(1))
							aTamParcI := TamSx3("E2_PARCELA")
							cParcFab  := StrZero(1,aTamParcI[1])
							While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFab + MVTAXA + PadR(cCodMVRES,__nTamFor) + cLojaImpos)
								cParcFab := Soma1(cParcFab,aTamParcI[1])
							EndDo

							RecLock("SE2",.T.)
							SE2->E2_FILIAL 	:= cFilial
							SE2->E2_FILORIG := cFilAnt
							SE2->E2_PREFIXO	:= cPrefixo
							SE2->E2_NUM    	:= cNum
							SE2->E2_PARCELA	:= cParcFab
							SE2->E2_TIPO 	:= MVTAXA
							SE2->E2_EMISSAO	:= dEmissao
							SE2->E2_EMIS1  	:= dDataBase
							SE2->E2_VALOR  	:= nFabov
							SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
							SE2->E2_SALDO  	:= nFabov
							SE2->E2_VENCREA	:= DTVenIcms()
							SE2->E2_VENCORI	:= dEmissao
							SE2->E2_FORNECE	:= cCodMVRES
							SE2->E2_LOJA   	:= cLojaImpos
							SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
							SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
							SE2->E2_VLCRUZ 	:= Round(nFabov, MsDecimais(1) )
							SE2->E2_ORIGEM 	:= Upper(cOrigem)
							cNatureza      	:= SuperGetMV("MV_FABNAT",.F.,"FABOV")
							SE2->E2_NATUREZ	:= Alltrim(cNatureza)
							SE2->E2_CODAPRO	:= cCodAprov
							MsUnLock()
							AADD(aRecImpos,{"SE2",Recno()})

							//Gravar a parcela do Fabov no titulo principal
							DbSelectArea("SE1")
							SE1->(DbGoTo(nSavRec))
							RecLock("SE1",.F.)
							SE1->E1_PARCFAB	:= cParcFab
							MsUnLock()

							//Cria a natureza Fabov caso nao exista
							DbSelectArea("SED")
							If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
								RecLock("SED",.T.)
								SED->ED_FILIAL  := cFilial
								SED->ED_CODIGO  := cNatureza
								SED->ED_CALCIRF := "N"
								SED->ED_CALCISS := "N"
								SED->ED_CALCINS := "N"
								SED->ED_CALCCSL := "N"
								SED->ED_CALCCOF := "N"
								SED->ED_CALCPIS := "N"
								SED->ED_DESCRIC := "FABOV"
								SED->ED_TIPO	:= "2"
								MsUnlock()
							EndIf
						Else
							//Busca a parcela Fabov de acordo com o titulo
							dbSelectArea("SE1")
							dbSetOrder(1)

							cParcela := SE1->E1_PARCELA
							nTamParc := Len(SE1->E1_PARCELA)
							While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+"FB-")
								cParcela := Soma1(cParcela,nTamParc)
							EndDo

							RecLock("SE1",.T.)
							SE1->E1_FILIAL	:= cFilSE1
							SE1->E1_PREFIXO	:= cPrefixo
							SE1->E1_NUM 	:= cNum
							SE1->E1_PARCELA	:= cParcela
							SE1->E1_TIPO   	:= "FB-"
							SE1->E1_EMISSAO	:= dEmissao
							SE1->E1_EMIS1  	:= dDataBase
							SE1->E1_VALOR  	:= nFabov
							SE1->E1_VENCTO 	:= dVencto
							SE1->E1_SALDO  	:= nFabov
							SE1->E1_VENCREA	:= dVencRea
							SE1->E1_VENCORI	:= dVencto
							SE1->E1_CLIENTE	:= cCliente
							SE1->E1_LOJA   	:= cLoja
							SE1->E1_NOMCLI 	:= SA1->A1_NREDUZ
							SE1->E1_MOEDA  	:= If(cPaisLoc=="BRA",1,nMoeda)
							SE1->E1_VLCRUZ 	:= Round(SE1->E1_VALOR,MsDecimais(1))
							SE1->E1_ORIGEM 	:= Upper(cOrigem)
							cNatureza      	:= SuperGetMV("MV_FABNAT",.F.,"FABOV")
							SE1->E1_NATUREZ	:= Alltrim(cNatureza)
							SE1->E1_STATUS 	:= "A"
							SE1->E1_SITUACA	:= "0"
							SE1->E1_OCORREN	:= "04"
							SE1->E1_LA     	:= cLa
							SE1->E1_FATURA	:= cFatura
							SE1->E1_TITPAI 	:= cTitPai
							SE1->E1_FILORIG	:= cFilAnt

							AADD(aRecImpos,{"SE1",Recno()})

							if lPLSTITPF
								PLSTITPF('SE1',cTitPai)
							endIf

							//Cria a natureza Fabov caso nao exista
							DbSelectArea("SED")
							cNatureza := AllTrim(cNatureza)
							If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
								RecLock("SED",.T.)
								SED->ED_FILIAL  := cFilial
								SED->ED_CODIGO  := cNatureza
								SED->ED_CALCIRF := "N"
								SED->ED_CALCISS := "N"
								SED->ED_CALCINS := "N"
								SED->ED_CALCCSL := "N"
								SED->ED_CALCCOF := "N"
								SED->ED_CALCPIS := "N"
								SED->ED_DESCRIC := "FABOV"
								SED->ED_TIPO	:= "2"
							EndIf
							If ExistBlock("F040FAB")
								Execblock("F040FAB",.F.,.F.,nSavRec)
							Endif
						Endif
					EndIf
				EndIf

				If !lFacMR
					//---------------------------------------------
					//Titulo do FACS
					//---------------------------------------------
					If nFacs > 0 .And. !lBorde
						If cPaisLoc == "BRA" .And. SA1->A1_RFACS == "2"

							//Cria o Fornecedor, caso nao exista
							DbSelectArea("SA2")
							SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
							If ( EOF() )
								Reclock("SA2",.T.)
								SA2->A2_FILIAL	:= cFilial
								SA2->A2_COD 	:= cCodMVRES
								SA2->A2_LOJA	:= cLojaImpos
								SA2->A2_NOME	:= "RECEITA ESTADUAL"
								SA2->A2_NREDUZ	:= "RECEITA"
								SA2->A2_BAIRRO	:= "."
								SA2->A2_MUN 	:= "."
								SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
								SA2->A2_End 	:= "."
								SA2->A2_TIPO	:= "J"
								MsUnlock()
							EndIf

							DbSelectArea("SE2")
							SE2->(DbSetOrder(1))
							aTamParcI := TamSx3("E2_PARCELA")
							cParcFac  := StrZero(1,aTamParcI[1])
							While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFac + MVTAXA + PadR(cCodMVRES,__nTamFor) + cLojaImpos)
								cParcFac := Soma1(cParcFac,aTamParcI[1])
							EndDo

							RecLock("SE2",.T.)
							SE2->E2_FILIAL 	:= cFilial
							SE2->E2_FILORIG := cFilAnt
							SE2->E2_PREFIXO	:= cPrefixo
							SE2->E2_NUM    	:= cNum
							SE2->E2_PARCELA	:= cParcFac
							SE2->E2_TIPO 	:= MVTAXA
							SE2->E2_EMISSAO	:= dEmissao
							SE2->E2_EMIS1  	:= dDataBase
							SE2->E2_VALOR  	:= nFacs
							SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
							SE2->E2_SALDO  	:= nFacs
							SE2->E2_VENCREA	:= DTVenIcms()
							SE2->E2_VENCORI	:= dEmissao
							SE2->E2_FORNECE	:= cCodMVRES
							SE2->E2_LOJA   	:= cLojaImpos
							SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
							SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
							SE2->E2_VLCRUZ 	:= Round(nFacs, MsDecimais(1) )
							SE2->E2_ORIGEM 	:= Upper(cOrigem)
							cNatureza      	:= SuperGetMV("MV_FACNAT",.F.,"FACS")
							SE2->E2_NATUREZ	:= Alltrim(cNatureza)
							SE2->E2_CODAPRO	:= cCodAprov
							MsUnLock()
							AADD(aRecImpos,{"SE2",Recno()})

							//Gravar a parcela do Facs no titulo principal
							DbSelectArea("SE1")
							SE1->(DbGoTo(nSavRec))
							RecLock("SE1",.F.)
							SE1->E1_PARCFAC	:= cParcFac
							MsUnLock()

							//Cria a natureza Facs caso nao exista
							DbSelectArea("SED")
							If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
								RecLock("SED",.T.)
								SED->ED_FILIAL  := cFilial
								SED->ED_CODIGO  := cNatureza
								SED->ED_CALCIRF := "N"
								SED->ED_CALCISS := "N"
								SED->ED_CALCINS := "N"
								SED->ED_CALCCSL := "N"
								SED->ED_CALCCOF := "N"
								SED->ED_CALCPIS := "N"
								SED->ED_DESCRIC := "FACS"
								SED->ED_TIPO	:= "2"
								MsUnlock()
							EndIf
						Else
							//Busca a parcela Facs de acordo com o titulo
							dbSelectArea("SE1")
							dbSetOrder(1)

							cParcela := SE1->E1_PARCELA
							nTamParc := Len(SE1->E1_PARCELA)
							While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+"FC-")
								cParcela := Soma1(cParcela,nTamParc)
							EndDo

							RecLock("SE1",.T.)
							SE1->E1_FILIAL	:= cFilSE1
							SE1->E1_FILORIG := cFilAnt
							SE1->E1_PREFIXO	:= cPrefixo
							SE1->E1_NUM 	:= cNum
							SE1->E1_PARCELA	:= cParcela
							SE1->E1_TIPO   	:= "FC-"
							SE1->E1_EMISSAO	:= dEmissao
							SE1->E1_EMIS1  	:= dDataBase
							SE1->E1_VALOR  	:= nFacs
							SE1->E1_VENCTO 	:= dVencto
							SE1->E1_SALDO  	:= nFacs
							SE1->E1_VENCREA	:= dVencRea
							SE1->E1_VENCORI	:= dVencto
							SE1->E1_CLIENTE	:= cCliente
							SE1->E1_LOJA   	:= cLoja
							SE1->E1_NOMCLI 	:= SA1->A1_NREDUZ
							SE1->E1_MOEDA  	:= If(cPaisLoc=="BRA",1,nMoeda)
							SE1->E1_VLCRUZ 	:= Round(SE1->E1_VALOR,MsDecimais(1))
							SE1->E1_ORIGEM 	:= Upper(cOrigem)
							cNatureza      	:= SuperGetMV("MV_FACNAT",.F.,"FACS")
							SE1->E1_NATUREZ	:= Alltrim(cNatureza)
							SE1->E1_STATUS 	:= "A"
							SE1->E1_SITUACA	:= "0"
							SE1->E1_OCORREN	:= "04"
							SE1->E1_LA     	:= cLa
							SE1->E1_FATURA	:= cFatura
							SE1->E1_TITPAI	:= cTitPai

							AADD(aRecImpos,{"SE1",Recno()})

							if lPLSTITPF
								PLSTITPF('SE1',cTitPai)
							endIf

							// Cria a natureza Facs caso nao exista
							DbSelectArea("SED")
							cNatureza := AllTrim(cNatureza)
							If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
								RecLock("SED",.T.)
								SED->ED_FILIAL  := cFilial
								SED->ED_CODIGO  := cNatureza
								SED->ED_CALCIRF := "N"
								SED->ED_CALCISS := "N"
								SED->ED_CALCINS := "N"
								SED->ED_CALCCSL := "N"
								SED->ED_CALCCOF := "N"
								SED->ED_CALCPIS := "N"
								SED->ED_DESCRIC := "FACS"
								SED->ED_TIPO	:= "2"
							EndIf
							If ExistBlock("F040FAC")
								Execblock("F040FAC",.F.,.F.,nSavRec)
							EndIf
						EndIf
					EndIf
				EndIf
				//-------------------------------------------------------------
				// titulo do FAMAD
				//-------------------------------------------------------------
				If lFamad .and. nFamad > 0 .And. !lBorde

					If SA1->(FieldPos("A1_RECFMD"))>0 .And. SA1->A1_RECFMD != "1"
						// Cria o Fornecedor, caso nao exista
						DbSelectArea("SA2")
						SA2->(DbSeek(xFilial("SA2")+GetMV("MV_RECEST")+Space(Len(A2_COD)-Len(GetMV("MV_RECEST")))+cLojaImpos))
						If ( EOF() )
							Reclock("SA2",.T.)
							SA2->A2_FILIAL	:= xFilial("SA2")
							SA2->A2_COD 	:= GetMV("MV_RECEST")
							SA2->A2_LOJA	:= cLojaImpos
							SA2->A2_NOME	:= "RECEITA ESTADUAL"
							SA2->A2_NREDUZ	:= "RECEITA"
							SA2->A2_BAIRRO	:= "."
							SA2->A2_MUN 	:= "."
							SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
							SA2->A2_End 	:= "."
							SA2->A2_TIPO	:= "J"
							MsUnlock()
						EndIf            
		
						DbSelectArea("SE2")
						SE2->(DbSetOrder(1))                
						aTamParcI := TamSx3("E2_PARCELA")
						cParcFam  := StrZero(1,aTamParcI[1])
						nTamFor	:= TamSx3("E2_FORNECE")[1]                      
						While MSSeek(xFilial("SE2")+cPrefixo+cNum+cParcFam+MVTAXA+PadR(GetMv("MV_RECEST"),nTamFor)+cLojaImpos)
							cParcFam := Soma1(cParcFam,aTamParcI[1])
						EndDo 			          

						RecLock("SE2",.T.)
						SE2->E2_FILIAL 	:= cFilial
						SE2->E2_PREFIXO	:= cPrefixo
						SE2->E2_NUM    	:= cNum
						SE2->E2_PARCELA	:= cParcFam
						SE2->E2_TIPO 	:= MVTAXA
						SE2->E2_EMISSAO	:= dEmissao
						SE2->E2_EMIS1  	:= dDataBase
						SE2->E2_VALOR  	:= nFamad
						SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
						SE2->E2_SALDO  	:= nFamad
						SE2->E2_VENCREA	:= DTVenIcms()
						SE2->E2_VENCORI	:= dEmissao
						SE2->E2_FORNECE	:= GetMv("MV_RECEST")
						SE2->E2_LOJA   	:= cLojaImpos
						SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
						SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
						SE2->E2_VLCRUZ 	:= Round(nFamad, MsDecimais(1) )
						SE2->E2_ORIGEM 	:= Upper(cOrigem)
						cNatureza      	:= SuperGetMV("MV_FAMNAT",.F.,"FAMAD") 
						SE2->E2_NATUREZ	:= Alltrim(cNatureza)
						SE2->E2_FILORIG	:= cFilAnt
						MsUnLock()
						
						AADD(aRecImpos,{"SE2",Recno()})
						
						//Gravar a parcela do Famad no titulo principal
						DbSelectArea("SE1")
						If SE1->(FieldPos("E1_PARCFAM")>0)
							SE1->(DbGoTo(nSavRec))
							RecLock("SE1",.F.)
							SE1->E1_PARCFAM	:= cParcFam
							MsUnLock()
						Endif
						
						// Cria a natureza Famad caso nao exista 
						DbSelectArea("SED")
						If !SED->(DbSeek(xFilial("SED")+avKey(cNatureza,"ED_CODIGO")))
							RecLock("SED",.T.)
							SED->ED_FILIAL  := xFilial("SED")
							SED->ED_CODIGO  := cNatureza
							SED->ED_CALCIRF := "N"
							SED->ED_CALCISS := "N"
							SED->ED_CALCINS := "N"
							SED->ED_CALCCSL := "N"
							SED->ED_CALCCOF := "N"
							SED->ED_CALCPIS := "N"
							SED->ED_DESCRIC := "FAMAD"
							SED->ED_TIPO	:= "2"
							MsUnlock()
						EndIf
					Else  
						// Busca a parcela Fabov de acordo com o titulo
						dbSelectArea("SE1")
						dbSetOrder(1)
					
						cParcela := SE1->E1_PARCELA
						nTamParc := Len(SE1->E1_PARCELA)
						While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+"FM-")
							cParcela := Soma1(cParcela,nTamParc)
						EndDo 			          
						
						RecLock("SE1",.T.)
						SE1->E1_FILIAL	:= cFilial
						SE1->E1_PREFIXO	:= cPrefixo
						SE1->E1_NUM 	:= cNum
						SE1->E1_PARCELA	:= cParcela
						SE1->E1_TIPO   	:= "FM-"
						SE1->E1_EMISSAO	:= dEmissao
						SE1->E1_EMIS1  	:= dDataBase
						SE1->E1_VALOR  	:= nFamad
						SE1->E1_VENCTO 	:= dVencto
						SE1->E1_SALDO  	:= nFamad
						SE1->E1_VENCREA	:= dVencRea
						SE1->E1_VENCORI	:= dVencto                                           
						SE1->E1_CLIENTE	:= cCliente
						SE1->E1_LOJA   	:= cLoja
						SE1->E1_NOMCLI 	:= SA1->A1_NREDUZ
						SE1->E1_MOEDA  	:= If(cPaisLoc=="BRA",1,nMoeda)
						SE1->E1_VLCRUZ 	:= Round(SE1->E1_VALOR,MsDecimais(1))
						SE1->E1_ORIGEM 	:= Upper(cOrigem)
						cNatureza      	:= SuperGetMV("MV_FAMNAT",.F.,"FAMAD") 
						SE1->E1_NATUREZ	:= Alltrim(cNatureza)
						SE1->E1_STATUS 	:= "A"
						SE1->E1_SITUACA	:= "0"
						SE1->E1_OCORREN	:= "04"
						SE1->E1_LA     	:= cLa
						SE1->E1_FATURA	:= cFatura
						SE1->E1_FILORIG	:= cFilAnt
						
						SE1->E1_TITPAI := cTitPai
		
						AADD(aRecImpos,{"SE1",Recno()})
		
						//Cria a natureza FAMAD caso nao exista
						DbSelectArea("SED")
						cNatureza := AllTrim(cNatureza)
						If !SED->(DbSeek(xFilial("SED")+avKey(cNatureza,"ED_CODIGO")))
							RecLock("SED",.T.)
							SED->ED_FILIAL  := xFilial("SED")
							SED->ED_CODIGO  := cNatureza
							SED->ED_CALCIRF := "N"
							SED->ED_CALCISS := "N"
							SED->ED_CALCINS := "N"
							SED->ED_CALCCSL := "N"
							SED->ED_CALCCOF := "N"
							SED->ED_CALCPIS := "N"			
							SED->ED_DESCRIC := "FAMAD"
							SED->ED_TIPO	:= "2"
						EndIf				
						If ExistBlock("F040FAM")
							Execblock("F040FAM",.F.,.F.,nSavRec)
						Endif
					Endif
				EndIf
			EndIf //If lAgFETHA

			If !lTpdMR
				//---------------------------------------
				// titulo do Imposto IMA
				//---------------------------------------
				If nIma > 0 .And. !lBorde

					lCposIMA := __lCposIMA
					nTamFor := __nTamFor

					If __lLocBRA .And. SA1->A1_RIMAMT == "2"
						// Cria o Fornecedor, caso nao exista
						DbSelectArea("SA2")
						SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
						If ( EOF() )
							Reclock("SA2",.T.)
							SA2->A2_FILIAL 	:= cFilial
							SA2->A2_COD 	:= cCodMVRES
							SA2->A2_LOJA	:= cLojaImpos
							SA2->A2_NOME	:= "RECEITA ESTADUAL"
							SA2->A2_NREDUZ	:= "RECEITA"
							SA2->A2_BAIRRO 	:= "."
							SA2->A2_MUN 	:= "."
							SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
							SA2->A2_End 	:= "."
							SA2->A2_TIPO	:= "J"
							MsUnlock()
						EndIf

						DbSelectArea("SE2")
						SE2->(DbSetOrder(1))
						aTamParcI := TamSx3("E2_PARCELA")
						cParcFac  := StrZero(1,aTamParcI[1])
						While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParcFac + MVTAXA + PadR(cCodMVRES,nTamFor) + cLojaImpos)
							cParcFac := Soma1(cParcFac,aTamParcI[1])
						EndDo

						RecLock("SE2",.T.)
						SE2->E2_FILIAL 	:= cFilial
						SE2->E2_FILORIG := cFilAnt
						SE2->E2_PREFIXO	:= cPrefixo
						SE2->E2_NUM    	:= cNum
						SE2->E2_PARCELA	:= cParcFac
						SE2->E2_TIPO 	:= MVTAXA
						SE2->E2_EMISSAO	:= dEmissao
						SE2->E2_EMIS1  	:= dDataBase
						SE2->E2_VALOR  	:= nIma
						SE2->E2_VENCTO 	:= DTVenIcms(.T.) //Vencimento do FETHAB, FACS e FABOV, coincidem com o vencimento do ICMS
						SE2->E2_SALDO  	:= nIma
						SE2->E2_VENCREA	:= DTVenIcms()
						SE2->E2_VENCORI	:= dEmissao
						SE2->E2_FORNECE	:= cCodMVRES
						SE2->E2_LOJA   	:= cLojaImpos
						SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
						SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
						SE2->E2_VLCRUZ 	:= Round(nIma, MsDecimais(1) )
						SE2->E2_ORIGEM 	:= Upper(cOrigem)
						cNatureza      	:= SuperGetMV("MV_IMANAT",.F.,"IMA")
						SE2->E2_NATUREZ	:= Alltrim(cNatureza)
						SE2->E2_CODAPRO	:= cCodAprov
						MsUnLock()
						AADD(aRecImpos,{"SE2",Recno()})

						//Gravar a parcela do IMA no titulo principal
						If lCposIMA
							DbSelectArea("SE1")
							SE1->(DbGoTo(nSavRec))
							RecLock("SE1",.F.)
							SE1->E1_PARCIMA	:= cParcFac
							MsUnLock()
						Endif

						//Cria a natureza IMA caso nao exista
						DbSelectArea("SED")
						If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
							RecLock("SED",.T.)
							SED->ED_FILIAL  := cFilial
							SED->ED_CODIGO  := cNatureza
							SED->ED_CALCIRF := "N"
							SED->ED_CALCISS := "N"
							SED->ED_CALCINS := "N"
							SED->ED_CALCCSL := "N"
							SED->ED_CALCCOF := "N"
							SED->ED_CALCPIS := "N"
							SED->ED_DESCRIC := "IMA"
							SED->ED_TIPO	:= "2"
							MsUnlock()
						EndIf
					else
						//Busca a parcela IMA de acordo com o titulo
						dbSelectArea("SE1")
						dbSetOrder(1)

						cParcela := SE1->E1_PARCELA
						nTamParc := Len(SE1->E1_PARCELA)
						While MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+"IM-")
							cParcela := Soma1(cParcela,nTamParc)
						EndDo

						RecLock("SE1",.T.)
						SE1->E1_FILIAL	:= cFilSE1
						SE1->E1_FILORIG := cFilAnt
						SE1->E1_PREFIXO	:= cPrefixo
						SE1->E1_NUM 	:= cNum
						SE1->E1_PARCELA	:= cParcela
						SE1->E1_TIPO   	:= "IM-"
						SE1->E1_EMISSAO	:= dEmissao
						SE1->E1_EMIS1  	:= dDataBase
						SE1->E1_VALOR  	:= nIma
						SE1->E1_VENCTO 	:= dVencto
						SE1->E1_SALDO  	:= nIma
						SE1->E1_VENCREA	:= dVencRea
						SE1->E1_VENCORI	:= dVencto
						SE1->E1_CLIENTE	:= cCliente
						SE1->E1_LOJA   	:= cLoja
						SE1->E1_NOMCLI 	:= SA1->A1_NREDUZ
						SE1->E1_MOEDA  	:= If(cPaisLoc=="BRA",1,nMoeda)
						SE1->E1_VLCRUZ 	:= Round(nIma,MsDecimais(1))
						SE1->E1_ORIGEM 	:= Upper(cOrigem)
						cNatureza      	:= SuperGetMV("MV_IMANAT",.F.,"IMA")
						SE1->E1_NATUREZ	:= Alltrim(cNatureza)
						SE1->E1_STATUS 	:= "A"
						SE1->E1_SITUACA	:= "0"
						SE1->E1_OCORREN	:= "04"
						SE1->E1_LA     	:= cLa
						SE1->E1_FATURA	:= cFatura
						SE1->E1_TITPAI	:= cTitPai
						If __lCposIMA
							SE1->E1_IMA 	:= Round(nIma,MsDecimais(1))
							SE1->E1_PARCIMA	:= cParcela
						Endif

						AADD(aRecImpos,{"SE1",Recno()})

                        if lPLSTITPF
                            PLSTITPF('SE1',cTitPai)
                        endIf

						//Cria a natureza IMA caso nao exista
						DbSelectArea("SED")
						cNatureza := AllTrim(cNatureza)
						If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
							RecLock("SED",.T.)
							SED->ED_FILIAL  := cFilial
							SED->ED_CODIGO  := cNatureza
							SED->ED_CALCIRF := "N"
							SED->ED_CALCISS := "N"
							SED->ED_CALCINS := "N"
							SED->ED_CALCCSL := "N"
							SED->ED_CALCCOF := "N"
							SED->ED_CALCPIS := "N"
							SED->ED_DESCRIC := "IMA"
							SED->ED_TIPO	:= "2"
						EndIf
						If ExistBlock("F040IMA")
							Execblock("F040IMA",.F.,.F.,nSavRec)
						Endif
					Endif
				EndIf

				//--------------------------------------------------
				// Titulo do TPDP
				//--------------------------------------------------
				If nTPDP > 0 .And. SE1->E1_VALOR >= 100 .And. !lBorde

					//Cria o Fornecedor, caso nao exista
					DbSelectArea("SA2")
					SA2->(DbSeek(xFilial("SA2") + cCodMVRES + Space(Len(A2_COD) - Len(cCodMVRES)) + cLojaImpos))
					If ( EOF() )
						Reclock("SA2",.T.)
						SA2->A2_FILIAL  := cFilial
						SA2->A2_COD 	:= cCodMVRES
						SA2->A2_LOJA	:= cLojaImpos
						SA2->A2_NOME	:= "RECEITA ESTADUAL"
						SA2->A2_NREDUZ  := "RECEITA"
						SA2->A2_BAIRRO  := "."
						SA2->A2_MUN 	:= "."
						SA2->A2_EST 	:= SuperGetMv("MV_ESTADO")
						SA2->A2_End 	:= "."
						SA2->A2_TIPO	:= "J"
						MsUnlock()
					EndIf

	                DbSelectArea("SE2")
					SE2->(DbSetOrder(1))
	                aTamParcI := TamSx3("E2_PARCELA")
	                cParTPDP  := StrZero(1,aTamParcI[1])

					While MSSeek(xFilial("SE2") + cPrefixo + cNum + cParTPDP + MVTAXA + PadR(cCodMVRES,__nTamFor) + cLojaImpos)
						cParTPDP := Soma1(cParTPDP,aTamParcI[1])
					EndDo

					RecLock("SE2",.T.)
					SE2->E2_FILIAL 	:= cFilial
					SE2->E2_FILORIG := cFilAnt
					SE2->E2_PREFIXO	:= cPrefixo
					SE2->E2_NUM    	:= cNum
					SE2->E2_PARCELA	:= cParTPDP
					SE2->E2_TIPO 	:= MVTAXA
					SE2->E2_EMISSAO	:= dEmissao
					SE2->E2_EMIS1  	:= dDataBase
					SE2->E2_VALOR  	:= nTPDP
					SE2->E2_VENCTO 	:= DataValida(IIF(SE1->E1_VENCTO > dDataBase+3,SE1->E1_VENCTO-3,SE1->E1_VENCTO),.t.)
					SE2->E2_SALDO  	:= nTPDP
					SE2->E2_VENCREA	:= DataValida(IIF(SE1->E1_VENCTO > dDataBase+3,SE1->E1_VENCTO-3,SE1->E1_VENCTO),.t.)
					SE2->E2_VENCORI	:= DataValida(IIF(SE1->E1_VENCTO > dDataBase+3,SE1->E1_VENCTO-3,SE1->E1_VENCTO),.t.)
					SE2->E2_FORNECE	:= cCodMVRES
					SE2->E2_LOJA   	:= cLojaImpos
					SE2->E2_NOMFOR 	:= SA2->A2_NREDUZ
					SE2->E2_MOEDA 	:= If(cPaisLoc=="BRA",1,nMoeda)
					SE2->E2_VLCRUZ 	:= Round(nTPDP, MsDecimais(1) )
					SE2->E2_ORIGEM 	:= Upper(cOrigem)
					cNatureza      	:= SuperGetMV("MV_APTPDP",.F.,"TPDP")
					SE2->E2_NATUREZ	:= Alltrim(cNatureza)
					SE2->E2_CODAPRO	:= cCodAprov
					MsUnLock()
					AADD(aRecImpos,{"SE2",Recno()})

					//Gravar a parcela da TPDP no titulo principal
					DbSelectArea("SE1")
					SE1->(DbGoTo(nSavRec))
					RecLock("SE1",.F.)
					SE1->E1_PARTPDP	:= cParTPDP
					MsUnLock()

					// Cria a natureza TPDP caso nao exista
					DbSelectArea("SED")
					If !SED->(DbSeek(cFilial+avKey(cNatureza,"ED_CODIGO")))
						RecLock("SED",.T.)
						SED->ED_FILIAL  := cFilial
						SED->ED_CODIGO  := cNatureza
						SED->ED_CALCIRF := "N"
						SED->ED_CALCISS := "N"
						SED->ED_CALCINS := "N"
						SED->ED_CALCCSL := "N"
						SED->ED_CALCCOF := "N"
						SED->ED_CALCPIS := "N"
						SED->ED_DESCRIC := "TPDP"
						SED->ED_TIPO	:= "2"
						MsUnlock()
					EndIf
				EndIf
			EndIf
    
			//-------------------------------------------------
			//Titulo do FUMIPEQ
			//-------------------------------------------------
			If lFumipeq .and. nFumipeq > 0 .And. !lBorde
				aResSED := getArea("SED")
				//Para garantir que estara no titulo principal.
				SE1->(DbGoTo(nSavRec))
				If SED->(ColumnPos("ED_CALCFMP"))>0 .And. SED->(DbSeek(xFilial("SED")+SE1->E1_NATUREZ)) .And. SED->ED_CALCFMP=="1"
					// Busca a parcela FUMIPEQ de acordo com o titulo
					dbSelectArea("SE1")
					dbSetOrder(1)

					cParcela := SE1->E1_PARCELA
					nTamParc := Len(SE1->E1_PARCELA)
					While !SE1->(Eof()) .And. MSSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+"FP-")
						cParcela := Soma1(cParcela,nTamParc)
					EndDo

					RecLock("SE1",.T.)
					SE1->E1_FILIAL	:= cFilial
					SE1->E1_PREFIXO	:= cPrefixo
					SE1->E1_NUM 	:= cNum
					SE1->E1_PARCELA	:= cParcela
					SE1->E1_TIPO   	:= "FP-"
					SE1->E1_EMISSAO	:= dEmissao
					SE1->E1_EMIS1  	:= dDataBase
					SE1->E1_VALOR  	:= nFumipeq
					SE1->E1_VENCTO 	:= dVencto
					SE1->E1_SALDO  	:= nFumipeq
					SE1->E1_VENCREA	:= dVencRea
					SE1->E1_VENCORI	:= dVencto
					SE1->E1_CLIENTE	:= cCliente
					SE1->E1_LOJA   	:= cLoja
					SE1->E1_NOMCLI 	:= SA1->A1_NREDUZ
					SE1->E1_MOEDA  	:= If(cPaisLoc=="BRA",1,nMoeda)
					SE1->E1_VLCRUZ 	:= Round(SE1->E1_VALOR,MsDecimais(1))
					SE1->E1_ORIGEM 	:= Upper(cOrigem)
					cNatureza      	:= SuperGetMV("MV_FMPNAT",.F.,"FUMIPEQ")
					SE1->E1_NATUREZ	:= Alltrim(cNatureza)
					SE1->E1_STATUS 	:= "A"
					SE1->E1_SITUACA	:= "0"
					SE1->E1_OCORREN	:= "04"
					SE1->E1_LA     	:= cLa
					SE1->E1_FATURA	:= cFatura
					SE1->E1_FILORIG	:= cFilAnt
					SE1->E1_TITPAI 	:= cTitPai

					AADD(aRecImpos,{"SE1",Recno()})

                    if lPLSTITPF
                        PLSTITPF('SE1',cTitPai)
                    endIf

					// Cria a natureza FUMIPEQ caso nao exista
					DbSelectArea("SED")
					cNatureza := AllTrim(cNatureza)
					If !SED->(DbSeek(xFilial("SED")+avKey(cNatureza,"ED_CODIGO")))
						RecLock("SED",.T.)
						SED->ED_FILIAL  := xFilial("SED")
						SED->ED_CODIGO  := cNatureza
						SED->ED_CALCIRF := "N"
						SED->ED_CALCISS := "N"
						SED->ED_CALCINS := "N"
						SED->ED_CALCCSL := "N"
						SED->ED_CALCCOF := "N"
						SED->ED_CALCPIS := "N"
						SED->ED_DESCRIC := "FUMIPEQ"
						SED->ED_TIPO	:= "2"
					EndIf
					If ExistBlock("F040FMP")
						Execblock("F040FMP",.F.,.F.,nSavRec)
					Endif
				Endif
				RestArea(aResSED)
			EndIf
		EndIf
		//Ponto se entrada para gravacoes genericas a todos os titulos de impostos
		If __lF040GER
			ExecBlock("F040GER",.F.,.F.,aRecImpos)
		Endif
	EndIf
EndIf

//Caso nao tenha efetuado os abatimentos, grava os campos de saldo a abater
If !lPccMR .And. ( __lPccBxCr .Or. lAbateuPIS .Or. lAbateuCOF .Or. lAbateuCSLL .Or. lAbateuIRF )
	SE1->( MsGoto( nSavREC ) )
	RecLock( "SE1", .F. )

	If lAbateuPIS .or. __lPccBxCr
		SE1->E1_SABTPIS := 0
	EndIf

	If lAbateuCOF .or. __lPccBxCr
		SE1->E1_SABTCOF := 0
	EndIf

	If lAbateuCSLL .or. __lPccBxCr
		SE1->E1_SABTCSL := 0
	EndIf

	If lAbateuIRF
		SE1->E1_SABTIRF := 0
	EndIf
	SE1->( MsUnlock() )

ElseIf !lIrfMR .And. __lIrPjBxCr
	SE1->( MsGoto( nSavREC ) )

	RecLock( "SE1", .F. )
	SE1->E1_SABTIRF := 0
	SE1->( MsUnlock() )

EndIf

__lIrPjBxCr := NIL
DbSelectArea( "SA1" )
DbGoTo( nSalvCli )
DbSelectArea( "SE1" )
DbGoTo( nSavRec )

Return(.T.)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ATUSALBCO

Atualização de saldo bancário.
Arquivo original: MATXATU.PRX

@Author	Wagner Xavier
@since 16/04/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function AtuSalBco(cBanco, cAgencia, cConta, dData, nValor, cSinal,lReconc, lSalatu)
Local cAlias := Alias()
Local nRecNo := 0
Local nSalIni:=0
Local cMoeda := "  "
Local nRecBco := SA6->(Recno())
Local nSalIniRec :=0
Local cQuery  := ""
Local cFilSE8 := ""
Local cTblTmp := ""

Default lReconc := .F.  //Atualiza saldo concilialdo
Default lSalAtu  := .T. //Atualiza saldo principal Atual

If Empty(cBanco)
	Return
EndIf

// Ponto de Entrada bloquear atualização do saldo bancário
If __lAtuSlBco
	If !ExecBlock('ATUSLBCO',.F.,.F.,{cBanco, cAgencia, cConta, dData, nValor, cSinal})
		Return
	EndIf
Endif

If __cSGBD == Nil
	__cSGBD := TcGetDb()
EndIf

DbSelectArea("SA6")
SA6->(DbSetOrder(1))

If !SA6->(MsSeek(xFilial("SA6")+cBanco+cAgencia+cConta))
	Reclock( "SA6", .T. )
	SA6 -> A6_FILIAL := xFilial("SA6")
	SA6 -> A6_COD	  := cBanco
	SA6 -> A6_AGENCIA:= cAgencia
	SA6 -> A6_NUMCON := cConta
	SA6 -> A6_NOME   := "."
	SA6 -> A6_NREDUZ := "."
	SA6 -> A6_MOEDA  := 1
	IF cPaisLoc $ "ANG|EQU|HAI" //Campo existente apenas nos países ANG, EQU e HAI
		SA6 -> A6_DV := FINMod9710( cBanco + cAgencia + cConta )
	ENDIF

	MsUnlock()
Endif

cMoeda := STR(MAX(SA6->A6_MOEDA,1),2)

DbSelectArea("SE8")
SE8->(DbSetOrder(1))
cFilSE8 := FWxFilial("SE8")

If !SE8->(MsSeek(cFilSE8+cBanco+cAgencia+cConta+DtoS(dData),.t.))
	Reclock('SE8',.T.)
	SE8 -> E8_FILIAL := xFilial("SE8")
	SE8 -> E8_BANCO	:= cBanco
	SE8 -> E8_AGENCIA:= cAgencia
	SE8 -> E8_CONTA	:= cConta
	SE8 -> E8_DTSALAT:= dData
	SE8->(MsUnlock())

	Reclock('SE8',.F.)
	nRecNo := SE8->(Recno())
	
	DbSeek(cFilSE8+cBanco+cAgencia+cConta+DtoS(dData),.t.)
	DbSkip(-1)
	
	If E8_FILIAL+E8_BANCO+E8_AGENCIA+E8_CONTA == cFilSE8+cBanco+cAgencia+cConta .and. dData >= SE8->E8_DTSALAT
		nSalIni := E8_SALATUA
		nSalIniRec := E8_SALRECO
	Else
		nSalIni := 0
		nSalIniRec := 0
	EndIf
	
	SE8->(DBGoto(nRecNo))
Else
	Reclock('SE8',.F.)
	nSalIni    := SE8->E8_SALATUA
	nSalIniRec := SE8->E8_SALRECO
EndIf

RecLock("SE8",.F.)

If lSalAtu
	SE8->E8_SALATUA := nSalini + (Iif(cSinal=="+",nValor,nValor*-1))
Endif

If lReconc
	SE8->E8_SALRECO := nSaliniRec + (Iif(cSinal=="+",nValor,nValor*-1))
ElseIf SE8->E8_SALRECO == 0
	SE8->E8_SALRECO := nSaliniRec
Endif

SE8 -> E8_MOEDA  := cMoeda

SE8->(MsUnlock())
nRecNo := SE8->(RecNo())
DbSkip()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Recalcula os saldos do diante em diante, se necess rio. 	  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (lSalAtu .Or. lReconc)
	cQuery := "UPDATE " + RetSqlName("SE8") + " SET "

	If lSalAtu
		cQuery += "E8_SALATUA = (E8_SALATUA " + cSinal + " " + cValToChar(nValor) + ") "
	EndIf 

	If lReconc
		If lSalAtu
			cQuery += ","
		EndIf 
		
		cQuery += "E8_SALRECO = (E8_SALRECO " + cSinal + " " + cValToChar(nValor) + ") "
	EndIf
	
	cQuery += "WHERE E8_FILIAL = '" + cFilSE8 + "' "
	cQuery += "AND E8_BANCO    = '" + cBanco + "' "
	cQuery += "AND E8_AGENCIA  = '" + cAgencia + "' "
	cQuery += "AND E8_CONTA    = '" + cConta + "' "
	cQuery += "AND E8_DTSALAT  > '" + DtoS(dData) + "' "
	cQuery += "AND D_E_L_E_T_  = ' ' "
	
	If TcSqlExec(cQuery) != 0 
		UserException("Erro ao atualizar saldo" + CRLF + TcSqlError())
	EndIf 
EndIf

//Busca o ultimo saldo 
If __cQrySE8 == Nil
	__cQrySE8 := "SELECT "
	
	If __cSGBD == "MSSQL"
		__cQrySE8 := "SELECT TOP 1 "
	EndIf
	
	__cQrySE8 += "E8_DTSALAT,E8_SALATUA, R_E_C_N_O_ RECSE8 "
	__cQrySE8 += "FROM " + RetSqlName("SE8") + " "
	__cQrySE8 += "WHERE E8_FILIAL = ? "
	__cQrySE8 += "AND E8_BANCO    = ? "
	__cQrySE8 += "AND E8_AGENCIA  = ? "
	__cQrySE8 += "AND E8_CONTA    = ? "
	__cQrySE8 += "AND D_E_L_E_T_  = ' ' "
	
	If __cSGBD == "ORACLE"
		__cQrySE8 += " AND ROWNUM = 1 "
	EndIf 
	
	__cQrySE8 += "ORDER BY E8_DTSALAT DESC "
	
	If __cSGBD == "POSTGRES"
		__cQrySE8 += "LIMIT 1"
	EndIf 
	
	__cQrySE8 := ChangeQuery(__cQrySE8)
EndIf 

cTblTmp := GetNextAlias()
DbUseArea(.T., "TOPCONN", TCGenQry2(Nil, Nil, __cQrySE8, {cFilSE8, cBanco, cAgencia, cConta}), cTblTmp, .F., .T.)

//Efetua a atualização do saldo no banco 
Reclock("SA6")
SA6->A6_SALATU  := (cTblTmp)->E8_SALATUA
MsUnlock()

//POSICIONA O REGISTRO DO SE8
SE8->(DbGoTo((cTblTmp)->RECSE8))

(cTblTmp)->(DbCloseArea())


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada para Reconciliacao Bancaria					  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (ExistBlock( "FAATUBCO" ) )
	ExecBlock("FAATUBCO",.F.,.F.,{cBanco, cAgencia, cConta, dData, nValor, cSinal,lReconc , lSalatu})
EndIf

SA6->(DbGoTo(nRecBco))   // Reposiciona no Banco da entrada da funcao
DbSelectArea(cAlias)
Return



/*
----------------------------------------------------------------------------
	            Funcoes retiradas do arquivo MATXFUNA.PRX
----------------------------------------------------------------------------
*/

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SUMABATREC

Soma titulos de abatimento relacionado a um determinado titulo a receber.
Arquivo original: MATXFUNA.PRX

@Author	Wagner Xavier
@since 23/03/1993
/*/
//-----------------------------------------------------------------------------------------------------
Function SumAbatRec(cPrefixo, cNumero, cParcela, nMoeda, cCpo, dData, nTotAbImp, nTotIrAbt, nTotCsAbt, nTotPisAbt, nTotCofAbt,;
					nTotInsAbt, cFilAbat, nTxMoeda, nTotISS, lFuncNova)
	
	Local cAlias     := ""
	Local nTotAbat   := 0
	Local nRec       := 0
	Local cCliLj     := ""
	Local lTitpaiSE1 := .F.
	Local cTipo      := ""
	Local nOrdTitPai := 0
	Local lIrPjBxCr  := .F.
	Local lProc		 := .T.
	Local lMotImp	 := .F.
	Local aOutImp	 := {}
	Local nY		 := 0
	Local aImpConf	 := {}
	Local lTemTtPai	 := .F.
	
	Default nTotAbImp  := 0
	Default nTotIrAbt  := 0
	Default nTotCsAbt  := 0
	Default nTotPisAbt := 0
	Default nTotCofAbt := 0
	Default nTotInsAbt := 0
	Default cFilAbat   := xFilial("SE1")
	Default nTxMoeda   := 0
	Default nTotISS    := 0 // --Transferencia de titulos parametrizado para nao tranferir o ISS	
	Default lFuncNova  := .F.
	
	If lFuncNova //Cálculo dos abatimentos pela SumAbatRec restruturada para melhor performance
		nTotAbat := FinAbatRec(cPrefixo, cNumero, cParcela, nMoeda, cCpo, dData, @nTotAbImp, @nTotIrAbt, @nTotCsAbt, @nTotPisAbt, @nTotCofAbt,;
					@nTotInsAbt, cFilAbat, nTxMoeda, @nTotISS)
	Else
		cAlias     := Alias()
		nRec       := RecNo()		
		lTitpaiSE1 := (SE1->(FieldPos("E1_TITPAI")) > 0)
		lIrPjBxCr  := FIrPjBxCr(.T.)
		lMotImp	   := FindFunction("FinImpConf")
		
		//Proteção para casos da SE1 compartilhada e o cFilAbat foi informado nos parâmetros com a cFilAnt
		cFilAbat := xFilial( "SE1" , cFilAbat )
		dData    := IIF(dData==NIL,dDataBase,dData)

		If Valtype(dData)=="C"
			dData := StoD(dData)
		Endif
		
		nMoeda  := IIF(nMoeda == NIL, 1, nMoeda)
		cCampo	:= IIF(cCpo == "V", "E1_VALOR", "E1_SALDO")
		
		If cAlias == "__SE1"
			cCliLj := __SE1->(E1_CLIENTE+E1_LOJA)
			cTipo	:=__SE1->E1_TIPO
		Else
			cCliLj := SE1->(E1_CLIENTE+E1_LOJA)
			cTipo  := SE1->E1_TIPO
		EndIf
		
		If Select("__SE1") == 0
			ChkFile("SE1",.F.,"__SE1")
		Else
			dbSelectArea("__SE1")
		Endif
		
		//RFC: se não informei os dados do titulo, retorno sem abatimento
		If Empty(cPrefixo + cNumero + cParcela )
			dbSelectArea( cAlias )
			dbGoTo(nRec)
			Return 0
		Endif
		
		If __lMotRet .And. lMotImp
			aImpConf	:=  FinImpConf("2", cFilAbat, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_NATUREZ)
			
			For nY := 1 To Len(aImpConf)
				If aImpConf[nY,4] == "1"
					Aadd(aOutImp,aImpConf[nY,8])
				EndIf
			Next nY
		Endif
		
		dbSetOrder( 1 )
		lProc := dbSeek( cFilAbat+cPrefixo+cNumero+cParcela+cTipo+cCliLj )
		
		If lProc
			//Países localizados não possuem impostos que geram títulos a partir de um título pai
			If cPaisLoc == "BRA" .And. lTitpaiSE1
				If FindFunction("OrdTitpai") .and. (nOrdTitPai:= OrdTitpai()) > 0
					DbSetOrder(nOrdTitPai)
					If	DbSeek(cFilAbat+cPrefixo+cNumero+cParcela+cTipo+cCliLj)
						lProc 		:= .T.
						lTemTtPai	:= .T.
					Else
						DbSetOrder(1)
						lProc := DbSeek(cFilAbat+cPrefixo+cNumero+cParcela)
					Endif
				Endif
			EndIf
		EndIf
		
		If lProc
			While !Eof() .And. (Iif(!lTemTtPai, E1_FILIAL == cFilAbat .And. E1_PREFIXO == cPrefixo .And. E1_NUM == cNumero .And. E1_PARCELA == cParcela .and. E1_TIPO = cTipo .and. E1_CLIENTE+E1_LOJA = cCliLj, ;
				!Empty(E1_TITPAI) .And. E1_FILIAL+E1_TITPAI == cFilAbat+Padr(cPrefixo+cNumero+cParcela+cTipo+cCliLj,Len(E1_TITPAI)) ) )
				If lTitpaiSE1
					If (!Empty(E1_TITPAI) .and. (E1_TITPAI!=Padr(cPrefixo+cNumero+cParcela+cTipo+cCliLj,Len(E1_TITPAI))) ) .or. Empty(E1_TITPAI)
						DbSkip()
						Loop
					EndIf
				EndIf

				If !Empty( cCliLj ) .And. (E1_CLIENTE+E1_LOJA == cCliLj)
					If E1_TIPO $ MVABATIM+"/"+MVIRABT+"/"+MVINABT+"/"+MVFUABT .And. !E1_TIPO $(MVPIABT+"/"+MVCFABT+"/"+MVCSABT)
						nTotAbat+= Iif(lIrPjBxCr, xMoeda(&cCampo.,E1_MOEDA, nMoeda,dData,,,nTxMoeda), xMoeda(&cCampo.,E1_MOEDA, nMoeda,E1_EMISSAO,,,))
					EndIf
					
					If E1_TIPO $(MVPIABT+"/"+MVCFABT+"/"+MVCSABT) 
						nTotAbat+=xMoeda(&cCampo.,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					EndIf
					
					If E1_TIPO $ MVIRABT+"/"+MVINABT+"/"+MVISABT+"/"+MVFUABT
						If (E1_TIPO $ MVIRABT .Or. E1_TIPO $ MVABATIM) .And. !lIrPjBxCr .And. nMoeda <> 1 .And. cPaisLoc == "BRA"
							nTotAbImp+=xMoeda(&cCampo.,E1_MOEDA, nMoeda,E1_EMISSAO,,,)
						Else
							nTotAbImp +=xMoeda(&cCampo,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
						Endif
					ElseIf  aScan(aOutImp, {|x| x == E1_TIPO}) > 0
						nTotAbImp +=xMoeda(&cCampo,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					Endif

					If E1_TIPO $(MVPIABT+"/"+MVCFABT+"/"+MVCSABT) 
						nTotAbImp+=xMoeda(&cCampo.,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					EndIf	
										
					//Irrf
					If E1_TIPO $ MVIRABT .And. E1_TIPO $ MVABATIM
						nTotIrAbt +=xMoeda(&cCampo,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					Endif
					//Csll
					If E1_TIPO $ MVCSABT .And. E1_TIPO $ MVABATIM
						nTotCsAbt +=xMoeda(&cCampo,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					Endif
					//PIS
					If E1_TIPO $ MVPIABT .And. E1_TIPO $ MVABATIM
						nTotPisAbt +=xMoeda(&cCampo,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					Endif
					//COFINS
					If E1_TIPO $ MVCFABT .And. E1_TIPO $ MVABATIM
						nTotCofAbt +=xMoeda(&cCampo,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					Endif
					//INSS
					If E1_TIPO $ MVINABT .And. E1_TIPO $ MVABATIM
						nTotInsAbt +=xMoeda(&cCampo,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					Endif
					//ISS
					IF E1_TIPO $ MVISABT .And. E1_TIPO $ MVABATIM
						nTotISS += xMoeda(&cCampo,E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					EndIf
				ElseIf Empty( cCliLj )
					Exit
				Endif
				dbSkip()
			Enddo
		Endif
		
		dbSetOrder( 1 )
		dbSelectArea( cAlias )
		dbGoTo(nRec)
	EndIf
Return (NoRound(nTotAbat))

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SUMABATPAG

Soma titulos de abatimento relacionado a um determinado titulo a pagar.
Arquivo original: MATXFUNA.PRX

@Author	Wagner Xavier
@since 23/03/1993
/*/
//-----------------------------------------------------------------------------------------------------
Function SumAbatPag(cPrefixo,cNumero,cParcela,cFornece,nMoeda,cCpo,dData,cLoja,cTipoData,dDataIni,dDataFim,dDataTxConv,cTipo)
Local aArea	   := GetArea()
Local cTmp	   := "ABATPAG"
Local cQuery   := ""
Local cFilTit  := If( Type("E2_FILIAL") <> "U", xFilial("SE2",E2_FILIAL), xFilial("SE2") )
Local nTotAbat := 0

Default cPrefixo  	:= If( Type("E2_PREFIXO") <> "U", E2_PREFIXO, "" )
Default cNumero	  	:= If( Type("E2_NUM") <> "U", E2_NUM, "" )
Default cParcela  	:= If( Type("E2_PARCELA") <> "U", E2_PARCELA, "" )
Default cFornece  	:= If( Type("E2_TIPO") <> "U", E2_TIPO, "" )
Default nMoeda 	  	:= 1
Default cCpo	  	:= ""
Default dData  	  	:= dDatabase
Default cLoja  	  	:= If( Type("E2_LOJA") <> "U", E2_LOJA, "" )
Default cTipoData 	:= ""
Default dDataIni 	:= StoD("")
Default dDataFim 	:= dDataBase
Default dDataTxConv := dDataBase
Default cTipo 		:= If( Type("E2_TIPO") <> "U", E2_TIPO, "" )

cQuery := "SELECT E2_MOEDA"
If cCpo == "V"
	cQuery += ",E2_VALOR AS VLRET"
Else
	cQuery += ",E2_SALDO AS VLRET"
EndIf
If cTipoData == "1"
	cQuery += ",E2_EMISSAO AS DTEMIS"
ElseIf cTipoData == "2"
	cQuery += ",E2_EMIS1 AS DTEMIS"
EndIf
cQuery += " FROM " + RetSqlName("SE2")
cQuery += " WHERE E2_FILIAL = '" +cFilTit+ "' AND"
cQuery += " E2_TITPAI = '" +cPrefixo+cNumero+cParcela+cTipo+cFornece+cLoja+ "' AND"
cQuery += " E2_TIPO IN " +FormatIn(MVABATIM,"|")+ " AND"
If cTipoData == "1"
	cQuery += " E2_EMISSAO BETWEEN '" +DtoS(dDataIni)+ "' AND '" +DtoS(dDataFim)+ "' AND"
ElseIf cTipoData == "2"
	cQuery += " E2_EMIS1 BETWEEN '" +DtoS(dDataIni)+ "' AND '" +DtoS(dDataFim)+ "' AND"
EndIf
cQuery += " D_E_L_E_T_ = ' '"
cQuery := ChangeQuery(cQuery)
cTmp   := MpSysOpenQuery(cQuery,cTmp)

While (cTmp)->(!EoF())
	nTotAbat += xMoeda((cTmp)->VLRET,(cTmp)->E2_MOEDA, nMoeda, dDataTxConv)
	(cTmp)->(dbSkip())
EndDo

(cTmp)->(dbCloseArea())
RestArea(aArea)

Return (NoRound(nTotAbat))

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA280VISUA

Função para visualizacao de contas a receber (FINA040/FINA280/fina281/FINA740/TmsA500) .
Arquivo original: MATXFUNA.PRX

@Author	Wagner Xavier
@since 16/04/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function FA280Visua(cAlias,nReg,nOpc)
Local nOpca
Local aBut040 	:= {}
Local aUsButtons
Local lFina040 	:= FwIsInCallStack("FINA040")
Local lMotRet 	:= ExistFunc("FTemMotor") .And. FTemMotor()
Local aSE1Field := {}

PRIVATE aRatAFT		:= {}

bPMSDlgRC := IF(Type("bPMSDlgRC") == "U",  {||PmsDlgRC(2,M->E1_PREFIXO,M->E1_NUM,M->E1_PARCELA,M->E1_TIPO,M->E1_CLIENTE,M->E1_LOJA)}, bPMSDlgRC)

If lFina040
	aBut040 := fa040BAR('SE1->E1_PROJPMS == "1"',bPmsDlgRC)
ElseIf ExistBlock( "F040BUT" ) // Adiciona botoes do usuario na EnchoiceBar 
	aUsButtons := ExecBlock( "F040BUT", .F., .F. )
	AEval( aUsButtons, { |x| AAdd( aBut040, x ) } )
EndIf

//inclusao do botao Posicao
If FindFunction("Fc040Con")
	AADD(aBut040, {"HISTORIC", {|| Fc040Con() }, "Posição"})
Endif

//inclusao do botao Rastreamento
If FindFunction("Fin250Rec")
	AADD(aBut040, {"HISTORIC", {|| Fin250Rec(2) }, "Rastreamento"})
EndIf

//Motor de retenções
If lMotRet
	Aadd( aBut040, { "MTRRETIMP", { || FINCRET("SE1") }, STR0087, STR0087 } ) //"Consulta de Retenções"
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Salva a Integridade dos dados de Entrada              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

DbSelectArea("SA1")
DbSeek(cFilial+SE1->E1_CLIENTE+SE1->E1_LOJA)

If (ExistBlock("FA40Prot"))
	ExecBlock("FA40Prot",.f.,.f.)
EndIf

DbSelectArea(cAlias)
If cPaisLoc   == "RUS"
	aSE1Field := FINXFIN03(cAlias) // FINXFIN03_FlView
	nOpca := AxVisual(cAlias,nReg,nOpc,aSE1Field,4,SA1->A1_NOME,, aBut040)
Else
	nOpca := AxVisual(cAlias,nReg,nOpc,,4,SA1->A1_NOME,, aBut040)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura a Integridade dos dados de Entrada             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} CARREGASA6

Validação genérica de Banco Agência e C/C.
Arquivo original: MATXFUNA.PRX

@Author	Wagner Xavier
@since 21/03/1996
/*/
//-----------------------------------------------------------------------------------------------------
Function CarregaSa6(cBanco,cAgencia,cConta,lHelp,cBenef100,lValidBloq,cNatureza, cMoeda,lSitef, cOldBanco, cOldAgenc,cOldConta, cChmSA6)
Local cAlias	:= Alias()
Local cChave	:= ""
Local lRet		:=.T.
Local nTamBen	:= Iif(cBenef100=NIL,0,Len(cBenef100))
Local lBenefi	:= .T.
Local lFinBenef	:= Existblock ("FINBENEF")
Local lChmPor	:= .T.

Default cBanco		:= ""
Default cAgencia	:= ""
Default cConta		:= ""
Default lHelp		:= .T.
Default cBenef100	:= ""
Default lValidBloq  := .F.
Default cMoeda		:= ""
Default cNatureza	:= ""
Default lSitef 		:= .F.
Default cOldBanco	:= ""
Default cOldAgenc   := ""
Default cOldConta	:= ""
Default cChmSA6		:= ""

If cChmSA6 = "cChmBco"
	If !Empty(cBanco) .And. Empty(cAgencia) .And. Empty(cConta)
		cChave:= cBanco
		If !SA6->(DbSeek(xFilial("SA6")+cChave))
			Help(" ",1,"FA100BCO")
			Return .F.
		EndIf
		cAgencia := ""
		cConta   := ""
	ElseIf cBanco <> cOldBanco .And. !Empty(cAgencia) .And. !Empty(cConta)
		If cAgencia <> cOldAgenc .And. cConta <> cOldConta
			cChave:= cBanco + cAgencia + cConta
			If !SA6->(DbSeek(xFilial("SA6")+cChave))
				Help(" ",1,"FA100BCO")
				Return .F.
			EndIf
			lChmPor		:= .F.
			cOldBanco := cBanco
			cOldAgenc := cAgencia
			cOldConta := cConta
		Else
			cChave:= cBanco
			cOldBanco := cBanco
			lChmPor		:= .F.
		EndIf
	EndIf
ElseIf cChmSA6 = "cChmAge"
	If cBanco = cOldBanco .And. cAgencia <> cOldAgenc
		cChave:= cBanco + cAgencia
		If !SA6->(DbSeek(xFilial("SA6")+cChave))
			Help(" ",1,"FA100BCO")
			Return .F.
		EndIf
		lChmPor	  := .F.
		cOldBanco := cBanco
		cOldAgenc := cAgencia
	ElseIf cBanco = cOldBanco .And. cAgencia = cOldAgenc .And. cConta <> cOldConta
		cChave:= cBanco + cAgencia
		lChmPor	  := .F.
		cOldBanco := cBanco
		cOldAgenc := cAgencia
	ElseIf cBanco <> cOldBanco .And. cAgencia <> cOldAgenc .And. cConta = cOldConta
		cChave:= cBanco + cAgencia + cConta
		If !SA6->(DbSeek(xFilial("SA6")+cChave))
			Help(" ",1,"FA100BCO")
			Return .F.
		EndIf
		lChmPor	  := .F.
		cOldBanco := cBanco
		cOldAgenc := cAgencia
		cOldConta := cConta
	EndIf
ElseIf cChmSA6 = "cChmCta"
	If cBanco = cOldBanco .And. cAgencia = cOldAgenc .And. cConta <> cOldConta
		cChave:= cBanco + cAgencia + cConta
		If !SA6->(DbSeek(xFilial("SA6")+cChave))
			Help(" ",1,"FA100BCO")
			Return .F.
		EndIf
		lChmPor	  := .F.
		cOldBanco := cBanco
		cOldAgenc := cAgencia
		cOldConta := cConta
	Else 
		cChave:= cBanco + cAgencia + cConta
		If !SA6->(DbSeek(xFilial("SA6")+cChave))
			Help(" ",1,"FA100BCO")
			Return .F.
		EndIf
		lChmPor	  := .F.
	Endif
Else
	If FunName() == 'FINA110' .And. !Empty(cAgencia) .And. !Empty(cConta) .AND. (cBanco <> cOldBanco .OR. cAgencia <> cOldAgenc .OR. cConta <> cOldConta) .AND. SA6->(DbSeek(xFilial("SA6")+ cBanco + cAgencia + cConta))// Quando alterado banco, agência e conta via F3
		cChave := cBanco + cAgencia + cConta
	Else
		If cOldBanco <> cBanco .And. cOldBanco <> ""
			cAgencia := ""
			cConta   := ""
		ElseIf cOldAgenc <> cAgencia .And. cOldAgenc <> ""
			cConta := ""
		EndIf
	EndIf
Endif

If lChmPor
	cChave:= cBanco+Iif(Empty(cAgencia),"",cAgencia)+Iif(Empty(cConta),"",cConta)
Endif
nTamBen := Len(cBenef100)

lHelp := Iif( lHelp=Nil,.T.,lHelp)
cFilOld:= cFilAnt
If !(FunName() $ "FINA091") .AND. !lSitef
	cFilAnt:= SM0->M0_CODFIL
Endif
DbSelectArea("SA6")
DbSetOrder(1)

If FunName() $ "FINA080|FINA750"
	If Type("oBanco") == "O"
		If oBanco:lModiFied
			cChave:=cBanco+IIF(!Empty(cAgencia),cAgencia,"")+IIF(!Empty(cConta),cConta,"")
			If DbSeek(cFilial+cChave)
				If cAgencia<>SA6->A6_AGENCIA
					cAgencia:=SA6->A6_AGENCIA
					cConta:=SA6->A6_NUMCON
				Else
					If cConta<>SA6->A6_NUMCON
						cConta:=SA6->A6_NUMCON
					EndIf
				EndIf
			Else
				cAgencia:=""
				cConta:=""
				cChave:=cBanco
			EndIf
		Endif
	EndIf
EndIf

If FunName() $ "FINA080|FINA750"
	If Type("oAgencia") == "O"
		If oAgencia:lModiFied
			cChave:=(cBanco+cAgencia+cConta)
			If DbSeek(cFilial+cChave)
				If cConta<>SA6->A6_NUMCON
					cConta:=SA6->A6_NUMCON
				Endif
			Else
			cConta:=""
		EndIf
		EndIf
  	EndIf
EndIf

If !DbSeek(xFilial("SA6")+cChave)
	lRet := .F.
	If lHelp
		Help(" ",1,"FA100BCO")
	EndIf
Else
	cBanco		:= Iif(cBanco	== NIl .or.  Empty( cBanco ),  SA6->A6_COD,     cBanco )
	cAgencia	:= Iif(cAgencia == NIl .or. Empty( cAgencia ), SA6->A6_AGENCIA	, cAgencia )
	cConta		:= Iif(cConta   == Nil .or. Empty( cConta   ), SA6->A6_NUMCON	, cConta   )
	If cPaisLoc == "BRA" .And. SA6->A6_MOEDA > 0
		cMoeda := SA6->A6_MOEDA
	EndIf
EndIf

cOldBanco := cBanco
cOldAgenc := cAgencia
cOldConta := cConta
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Carrega o nome do beneficiario, caso banco destino  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

// Carrega o nome do beneficiario, caso banco destino
If	lFinBenef
	lBenefi := ExecBlock ("FINBENEF",.F.,.F.)
Endif

If lRet .and. cBenef100 != Nil .and. lBenefi   // FINA100
	cBenef100 := Padr(SUBSTR(SM0->M0_NOMECOM,1,nTamBen),nTamben)
EndIf

If lRet .And. lValidBloq
	If SA6->A6_BLOCKED == "1"  //Conta Bloqueada
		Help(" ",1,"CCBLOCKED",,STR0091,1,0)
		lRet := .F.
	ElseIf FieldPos("A6_MSBLQL") > 0 .And. SA6->A6_MSBLQL == "1" // campo de bloqueio ativado e banco bloqueado
		Help(" ",1,"REGBLOQ",,,1,0)
		lRet := .F.
	Endif
EndIf

If lRet .and. ExistBlock("PE_LOADSA6")
	cNatureza := Execblock("PE_LOADSA6",.F.,.F.)
EndIf
cFilAnt:=cFilOld
DbSelectArea( cAlias )
Return lRet


/*
----------------------------------------------------------------------------
	            Funcoes retiradas do arquivo MATXFUNB.PRX
----------------------------------------------------------------------------
*/

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} READCNAB2

CNAB Modelo 2.
Arquivo original: MATXFUNB.PRX

@param nHandle - Handle do Arquivo a ser lido
@param cLayaout - Nome do arquivo de configuracao
@param nMaxLn - Tamanho maximo da linha
@param aLayout - Atributos do arquivo de configuracao
@param nLinRead

@Author	Eduardo Riera
@since 16/04/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function ReadCnab2(nHandle,cLayOut,nMaxLn,aLayOut,nLinRead)

Local nHdlLay		:= 0
Local lContinua		:= .T.
Local cBuffer		:= ""
Local nCntFor		:= 0
Local nPosIni		:= 0
Local nPosFim		:= 0
Local nTamanho		:= 0
Local nDecimal		:= 0
Local nPosSeg		:= 0
Local aSegmento		:= {}
Local aDetalhe		:= {}
Local cLinUlt		:= ""
Local cLinAtu		:= ""
Local nCntFor2		:= 0
Local cIdent		:= ""
Local xTITULO		:= ""
Local xTIPO			:= ""
Local xOCORRENCI	:= ""
Local xDATA     	:= "000000"
Local xVALOR    	:= 0.00
Local xDESPESA  	:= 0.00
Local xDESCONTO 	:= 0.00
Local xABATIMENT	:= 0.00
Local xJUROS    	:= 0.00
Local xMULTA    	:= 0.00
Local xNOSSONUM 	:= ""
Local xRESERVADO	:= ""
Local xValIof   	:= 0.00
Local xValCC    	:= 0.00
Local xDATACRED 	:= "000000"
Local xMOTIVO   	:= ""
Local xBuffer   	:= ""
Local nLeitura  	:= 0			// Numero de Leituras Efetuadas
Local lSegValido	:= .F.			// Controle de Leitura de segmentos validos
Local nLidosBco 	:= 0			// Numero de Bytes lidos do Arquivo de Retorno
Local xAUTENTICA	:= ""
Local aBuffer		:= {}
Local xCGC			:= ""
Local cChave    	:= ""
Local aDirTmp   	:= {}
Local xBANCO		:= ""
Local xAGENCIA		:= ""
Local xCONTA		:= ""
Local aHeadL		:= Array(4,5)	//Array das posicoes de Banco, Agencia e Conta no Header para a baixa
Local aBanco		:= Array(3)		//Dados bancarios para a baixa (coletados no header)
Local lHeadL		:= .F.
Local xCGCH			:= ""
Local xCODBAR		:= ""
Local xContOpt		:=""
Local nPosj52		:= 0
Local cSegmento		:= ''
Local cSeg52		:= ''
Local lReadJ		:= .F.
Local aReadSeg		:= {}
Local xCGCEMP		:= ""			//CNPJ da empresa utilizada no DDA para posicionar a SM0
Local cTipoReg      := ""
Local lBuffer       := .F.
Local cHeader       := ""

Default nMaxLn		:= 1000
Default aLayOut		:= {}
Default nLinRead	:= 0

Private xConteudo  := ""

If ( File(cLayOut) )

	If Len(aLayOut) == 0
		aDirTmp	:= Directory(cLayOut)
	ELse
		aDirTmp := AClone(aLayOut)
	EndIf

	// Inicializa flag que indica se possui dados bancarios para baixa - Header de Lote
	For nCntFor := 1 to Len(aHeadL)
		aHeadL[ nCntFor, 5 ] := .F.
	Next

	cChave := aDirTmp[1][1]+str(aDirTmp[1][2])+DtoC(aDirTmp[1][3])+aDirTmp[1][4]

	If Empty(__aLayCNAB) .Or. cChave != __aLayCNAB[1]
	   nHdlLay := FOpen(cLayOut,64)
	   While ( lContinua )
			cBuffer := FreadStr(nHdlLay,502)
			If ( !Empty(cBuffer) )
				If ( SubStr(cBuffer,1,1)=="1" )
					If ( SubStr(cBuffer,3,1)=="D" )
						aadd(aSegmento,{AllTrim(SubStr(cBuffer,02,03)),;
						AllTrim(SubStr(cBuffer,35,255)),0,0,0,0})
						aadd(aDetalhe,Array(20,4))
					EndIf
				Else
					If ( SubStr(cBuffer,3,1)=="D" )
						nPosIni  := Val(SubStr(cBuffer,20,03))
						nPosFim  := Val(SubStr(cBuffer,23,03))
						nDecimal := Val(SubStr(cBuffer,26,01))
						nTamanho := nPosFim - nPosIni +1
						xConteudo:= AllTrim(SubStr(cBuffer,27,255))
						nPosSeg := AScan(aSegmento,{|x| x[1]==Alltrim(SubStr(cBuffer,02,03))})
			      		If ( nPosSeg != 0 )
							Do Case
							Case xConteudo=="TITULO"
								aDetalhe[nPosSeg,1,1] := "TITULO"
								aDetalhe[nPosSeg,1,2] := nPosIni
								aDetalhe[nPosSeg,1,3] := nTamanho
								aDetalhe[nPosSeg,1,4] := nDecimal
							Case  xConteudo=="ESPECIE"
								aDetalhe[nPosSeg,2,1] := "ESPECIE"
								aDetalhe[nPosSeg,2,2] := nPosIni
								aDetalhe[nPosSeg,2,3] := nTamanho
								aDetalhe[nPosSeg,2,4] := nDecimal
							Case xConteudo=="OCORRENCIA"
								aDetalhe[nPosSeg,3,1] := "OCORRENCIA"
								aDetalhe[nPosSeg,3,2] := nPosIni
								aDetalhe[nPosSeg,3,3] := nTamanho
								aDetalhe[nPosSeg,3,4] := nDecimal
							Case xConteudo=="DATA"
								aDetalhe[nPosSeg,4,1] := "DATA"
								aDetalhe[nPosSeg,4,2] := nPosIni
								aDetalhe[nPosSeg,4,3] := nTamanho
								aDetalhe[nPosSeg,4,4] := nDecimal
							Case xConteudo=="VALOR"
								aDetalhe[nPosSeg,5,1] := "VALOR"
								aDetalhe[nPosSeg,5,2] := nPosIni
								aDetalhe[nPosSeg,5,3] := nTamanho
								aDetalhe[nPosSeg,5,4] := nDecimal
							Case xConteudo=="DESPESA"
								aDetalhe[nPosSeg,6,1] := "DESPESA"
								aDetalhe[nPosSeg,6,2] := nPosIni
								aDetalhe[nPosSeg,6,3] := nTamanho
								aDetalhe[nPosSeg,6,4] := nDecimal
							Case xConteudo=="DESCONTO"
								aDetalhe[nPosSeg,7,1] := "DESCONTO"
								aDetalhe[nPosSeg,7,2] := nPosIni
								aDetalhe[nPosSeg,7,3] := nTamanho
								aDetalhe[nPosSeg,7,4] := nDecimal
							Case xConteudo=="ABATIMENTO"
								aDetalhe[nPosSeg,8,1] := "ABATIMENTO"
								aDetalhe[nPosSeg,8,2] := nPosIni
								aDetalhe[nPosSeg,8,3] := nTamanho
								aDetalhe[nPosSeg,8,4] := nDecimal
							Case xConteudo=="JUROS"
								aDetalhe[nPosSeg,9,1] := "JUROS"
								aDetalhe[nPosSeg,9,2] := nPosIni
								aDetalhe[nPosSeg,9,3] := nTamanho
								aDetalhe[nPosSeg,9,4] := nDecimal
							Case xConteudo=="MULTA"
								aDetalhe[nPosSeg,10,1] := "MULTA"
								aDetalhe[nPosSeg,10,2] := nPosIni
								aDetalhe[nPosSeg,10,3] := nTamanho
								aDetalhe[nPosSeg,10,4] := nDecimal
							Case xConteudo=="IOF"
								aDetalhe[nPosSeg,11,1] := "IOF"
								aDetalhe[nPosSeg,11,2] := nPosIni
								aDetalhe[nPosSeg,11,3] := nTamanho
								aDetalhe[nPosSeg,11,4] := nDecimal
							Case xConteudo=="OUTROSCREDITOS"
								aDetalhe[nPosSeg,12,1] := "OUTROSCREDITOS"
								aDetalhe[nPosSeg,12,2] := nPosIni
								aDetalhe[nPosSeg,12,3] := nTamanho
								aDetalhe[nPosSeg,12,4] := nDecimal
							Case xConteudo=="DATACREDITO"
								aDetalhe[nPosSeg,13,1] := "DATACREDITO"
								aDetalhe[nPosSeg,13,2] := nPosIni
								aDetalhe[nPosSeg,13,3] := nTamanho
								aDetalhe[nPosSeg,13,4] := nDecimal
							Case xConteudo=="MOTIVO"
								aDetalhe[nPosSeg,14,1] := "MOTIVO"
								aDetalhe[nPosSeg,14,2] := nPosIni
								aDetalhe[nPosSeg,14,3] := nTamanho
								aDetalhe[nPosSeg,14,4] := nDecimal
							Case xConteudo=="NOSSONUMERO"
								aDetalhe[nPosSeg,15,1] := "NOSSONUMERO"
								aDetalhe[nPosSeg,15,2] := nPosIni
								aDetalhe[nPosSeg,15,3] := nTamanho
								aDetalhe[nPosSeg,15,4] := nDecimal
							Case xConteudo=="RESERVADO"
								aDetalhe[nPosSeg,16,1] := "RESERVADO"
								aDetalhe[nPosSeg,16,2] := nPosIni
								aDetalhe[nPosSeg,16,3] := nTamanho
								aDetalhe[nPosSeg,16,4] := nDecimal
							Case xConteudo=="SEGMENTO"
								aSegmento[nPosSeg,3] := nPosIni
								aSegmento[nPosSeg,4] := nTamanho
							Case xConteudo=="AUTENTICACAO"
								aDetalhe[nPosSeg,17,1] := "AUTENTICACAO"
								aDetalhe[nPosSeg,17,2] := nPosIni
								aDetalhe[nPosSeg,17,3] := nTamanho
								aDetalhe[nPosSeg,17,4] := nDecimal
							Case xConteudo=="CGC"
								aDetalhe[nPosSeg,18,1] := "CGC"
								aDetalhe[nPosSeg,18,2] := nPosIni
								aDetalhe[nPosSeg,18,3] := nTamanho
								aDetalhe[nPosSeg,18,4] := nDecimal
							Case xConteudo=="CGCH"
								aDetalhe[nPosSeg,19,1] := "CGCH"
								aDetalhe[nPosSeg,19,2] := nPosIni
								aDetalhe[nPosSeg,19,3] := nTamanho
								aDetalhe[nPosSeg,19,4] := nDecimal
							Case xConteudo=="CODBAR"
								aDetalhe[nPosSeg,20,1] := "CODBAR"
								aDetalhe[nPosSeg,20,2] := nPosIni
								aDetalhe[nPosSeg,20,3] := nTamanho
								aDetalhe[nPosSeg,20,4] := nDecimal
							Case xConteudo=="SEGJ52"
								aSegmento[nPosSeg,5] := nPosIni
								aSegmento[nPosSeg,6] := nTamanho
							EndCase
						EndIf
					//Dados bancarios para a baixa
					ElseIf ( SubStr(cBuffer,3,1)=="H" )
						nPosIni  := Val(SubStr(cBuffer,20,03))
						nPosFim  := Val(SubStr(cBuffer,23,03))
						nDecimal := Val(SubStr(cBuffer,26,01))
						nTamanho := nPosFim - nPosIni +1
						xConteudo:= AllTrim(SubStr(cBuffer,27,255))
						lHeadL   := .T.
						Do Case
							Case xConteudo=="BANCO"
								aHeadL[1,1] := "BANCO"
								aHeadL[1,2] := nPosIni
								aHeadL[1,3] := nTamanho
								aHeadL[1,4] := nDecimal
								aHeadL[1,5] := .T.
							Case xConteudo=="AGENCIA"
								aHeadL[2,1] := "AGENCIA"
								aHeadL[2,2] := nPosIni
								aHeadL[2,3] := nTamanho
								aHeadL[2,4] := nDecimal
								aHeadL[2,5] := .T.
							Case xConteudo=="CONTA"
								aHeadL[3,1] := "CONTA"
								aHeadL[3,2] := nPosIni
								aHeadL[3,3] := nTamanho
								aHeadL[3,4] := nDecimal
								aHeadL[3,5] := .T.
							Case xConteudo=="CGCEMP"
								aHeadL[4,1] := "CGCEMP"
								aHeadL[4,2] := nPosIni
								aHeadL[4,3] := nTamanho
								aHeadL[4,4] := nDecimal
								aHeadL[4,5] := .T.
						EndCase
					EndIf
				EndIf
			Else
				lContinua := .F.
			EndIf
		EndDo
		FClose(nHdlLay)
		__aLayCNAB	:=	{}
		Aadd(__aLayCNAB,cChave)
		Aadd(__aLayCNAB,aSegmento)
		Aadd(__aLayCNAB,aDetalhe)
		Aadd(__aLayCNAB,aHeadL)
		Aadd(__aLayCNAB,aBanco)
	Else
		aSegmento	:= aClone(__aLayCNAB[2])
		aDetalhe	:= aClone(__aLayCNAB[3])
		aHeadL		:= aClone(__aLayCNAB[4])
		aBanco		:= aClone(__aLayCNAB[5])
	EndIf

EndIf

lContinua := .T.

While ( lContinua )
	aLinha		:= LerLinha(nHandle,nMaxLn)
	cBuffer 	:= aLinha[1]
	nLidosBco 	:= aLinha[2]
	lSegValido	:= .F.
	nLeitura++
	nLinRead++
	cSegmento	:= ""
	lBuffer     := .F.
	cHeader     := ""
	
	If (lBuffer := !Empty(cBuffer))
		cTipoReg := Substr(cBuffer, 8, 1)
	EndIf
	
	//Para o tratamento de CNPJ no Header de Lote, verifico as informações do Header se o mesmo foi configurado
	If nMaxLn < 1000 .And. !lHeadL
		lHeadL  := Len(aHeadL) > 0
	EndIf
	
	If lBuffer
		//Layout 150 posições débito automático
		If lBuffer .And. (nMaxLn >= 150 .And. nMaxLn <= 152)
			cHeader := Substr(cBuffer, 1, 1)
		EndIf		
		
		//Lendo no Header de Lote o Banco, Agencia e Conta para baixa
		If (cHeader == "A") .Or. (cTipoReg == "1" .And. lHeadL .And. cHeader != "F")
			For nCntFor := 1 To Len(aHeadL)
				If aHeadL[nCntFor,5]
					nPosIni := aHeadL[nCntFor,2]
					nTamanho:= aHeadL[nCntFor,3]
					nDecimal:= aHeadL[nCntFor,4]
					Do Case
					Case aHeadL[nCntFor,1]=="BANCO"
						xBANCO	:= SubStr(cBuffer,nPosIni,nTamanho)
						aBanco[1] := xBANCO
					Case aHeadL[nCntFor,1]=="AGENCIA"
						xAGENCIA	:= SubStr(cBuffer,nPosIni,nTamanho)
						aBanco[2] := xAGENCIA
					Case aHeadL[nCntFor,1]=="CONTA"
						xCONTA	:= SubStr(cBuffer,nPosIni,nTamanho)
						aBanco[3] := xCONTA
					Case aHeadL[nCntFor,1]=="CGCEMP"
						xCGCEMP	:= SubStr(cBuffer,nPosIni,nTamanho)
					EndCase
				EndIf
			Next
			__aLayCNAB[5] := aClone( aBanco )
		Else
			//Recarrego os dados bancarios quando estiver processando o detalhe
			//Esses dados estao apenas no header e somente serao trocados quando
			//lido um novo header
			If Empty(xBanco) .and. !Empty(aBanco[1])
				xBanco	:= aBanco[1]
				xAgencia := aBanco[2]
				xConta	:= aBanco[3]
			Endif

			// Posição do SEGMENTO J52
			nPosJ52 := Ascan(aSegmento,{|x| x[2] = "J52" })
			lReadJ  := Ascan(aReadSeg, {|x| x == "J" }) > 0

			// Busca o segmento da linha atual no array(aSegmento)
			For nCntFor := 1 To Len(aSegmento)
				If Empty(cSegmento)
					cSegmento := If(SubStr(cBuffer,aSegmento[nCntFor,3],aSegmento[nCntFor,4]) == aSegmento[nCntFor,2], aSegmento[nCntFor,2],"")
				ElseIf cSegmento == "J" .And. lReadJ .And. nPosJ52 != 0 .And. nPosJ52 == nCntFor // Verifica se existe SEGMENTO J52 (Opicional)
					cSeg52 := Alltrim(SubStr(cBuffer,aSegmento[nCntFor,3],aSegmento[nCntFor,4])) + SubStr(cBuffer,aSegmento[nCntFor,5],aSegmento[nCntFor,6])
					cSegmento := If(cSeg52 == aSegmento[nPosJ52,2], aSegmento[nCntFor,2],cSegmento)
				EndIf
			Next
			
			// Caso o segmento ja foi processado por uma linha do arquivo de
			// retorno, saio da função com os dados carregados até o momento.
			If !Empty(cSegmento) .And. aScan(aReadSeg, {|x| x == cSegmento}) > 0
				
				// Retorna a linha atual para ser relida na proxima interacao.
				nLinRead--
				FSeek(nHandle,-2*(nLidosBco),1)
				cBuffer := LerLinha(nHandle,nMaxLn)[1]
				lContinua := .F.
				Exit
			ElseIf !Empty(cSegmento)
				AADD(aReadSeg,cSegmento)
			EndIf

			For nCntFor := 1 To Len(aSegmento)
				//-----------------------------------------------------------------
				//                      Teste de Quebra
				//  1D(n)
				//  ------------------------------
				//  |(n)-------------------------  -> Linha Detalhe  =  Conj.
				//  | 1 |------------------------A - Identificador    | da
				//  | 2 |------------------------B - Identificador    | Linha
				//  | 3 |------------------------C - Identificador    | Detalhe
				//  |   -------------------------                    =
				//  |
				//  ------------------------------
				//  2D(n)
				//  ------------------------------
				//  |(n)-------------------------  -> Linha Detalhe  =  Conj.
				//  | 1 |------------------------A - Identificador    | da
				//  | 2 |------------------------B - Identificador    | Linha
				//  | 3 |------------------------C - Identificador    | Detalhe
				//  |   -------------------------                    =
				//  |
				//  ------------------------------
				//
				//-----------------------------------------------------------------
				xConteudo  := Alltrim(SubStr(cBuffer,aSegmento[nCntFor,3],aSegmento[nCntFor,4]))
				If ( nPosj52 ) > 0
					If !Empty(cSeg52)
					 	If nCntFor == nPosj52
							xContOpt   := SubStr(cBuffer,aSegmento[nCntFor,5],aSegmento[nCntFor,6])
	                
							If !Empty(xContOpt) .And. xContOpt == "52"
								xConteudo := Alltrim( xConteudo ) + xContOpt
							EndIf
						Else
							xConteudo  := ""
						EndIf
					EndIf
				EndIf
				
				// Verifica a qual linha detalhe o segmento valido pertence.
				If If( nPosj52 > 0, ( xConteudo == aSegmento[nCntFor,2] ), ( xConteudo $ aSegmento[nCntFor,2] ) )
					cLinAtu := SubStr(aSegmento[nCntFor][1],1,1)
				EndIf

				// Verifica se houve quebra de linha detalhe, ou se o houve repeticao do mesmo conjunto da linha detalhe. 
				// A repeticao ocorre quando o identificador de linha repete-se.
				If ( (cIdent == xConteudo .Or. cLinAtu<>cLinUlt ) .And. ;
					 !Empty(cIdent) .And. !Empty(cLinUlt) .And. nLeitura > 1 ) //.And.;

					// Retorna a linha atual para ser relida na proxima interacao.
					nLinRead--
					FSeek(nHandle,-2*(nLidosBco),1)
					cBuffer := LerLinha(nHandle,nMaxLn)[1]
					lContinua := .F.
					Exit
				EndIf
				If ( lContinua )
					If If( nPosj52 > 0, xConteudo == aSegmento[nCntFor,2], xConteudo $ aSegmento[nCntFor,2] )
						lSegValido := .T.
						xBuffer    += cBuffer
						Aadd(aBuffer,cBuffer)
						If (Empty(cIdent))
							nLeitura := 1
							cIdent 	:= xConteudo
							cLinUlt := SubStr(aSegmento[nCntFor][1],1,1)
						EndIf
						For nCntFor2 := 1 To Len(aDetalhe[nCntFor])
							nPosIni := aDetalhe[nCntFor,nCntFor2,2]
							nTamanho:= aDetalhe[nCntFor,nCntFor2,3]
							nDecimal:= aDetalhe[nCntFor,nCntFor2,4]
							Do Case
							Case aDetalhe[nCntFor,nCntFor2,1]=="TITULO"
								xTITULO := SubStr(cBuffer,nPosIni,nTamanho)
							Case aDetalhe[nCntFor,nCntFor2,1]=="NOSSONUMERO"
								xNOSSONUM := SubStr(cBuffer,nPosIni,nTamanho)
							Case aDetalhe[nCntFor,nCntFor2,1]=="ESPECIE"
								xTIPO     := SubStr(cBuffer,nPosIni,nTamanho)
							Case aDetalhe[nCntFor,nCntFor2,1]=="OCORRENCIA"
								xOCORRENCI := SubStr(cBuffer,nPosIni,nTamanho)
							Case aDetalhe[nCntFor,nCntFor2,1]=="DATA"
								xDATA := SubStr(cBuffer,nPosIni,nTamanho)
							Case aDetalhe[nCntFor,nCntFor2,1]=="VALOR"
								xVALOR := SubStr(cBuffer,nPosIni,nTamanho)
								xVALOR := Val(xVALOR)/(Val("1"+Repl("0",nDecimal)))
							Case aDetalhe[nCntFor,nCntFor2,1]=="DESPESA"
								xDESPESA := SubStr(cBuffer,nPosIni,nTamanho)
								xDESPESA := Val(xDESPESA)/(Val("1"+Repl("0",nDecimal)))
							Case aDetalhe[nCntFor,nCntFor2,1]=="DESCONTO"
								xDESCONTO := SubStr(cBuffer,nPosIni,nTamanho)
								xDESCONTO := Val(xDESCONTO)/(Val("1"+Repl("0",nDecimal)))
							Case aDetalhe[nCntFor,nCntFor2,1]=="ABATIMENTO"
								xABATIMENT := SubStr(cBuffer,nPosIni,nTamanho)
								xABATIMENT := Val(xABATIMENT)/(Val("1"+Repl("0",nDecimal)))
							Case aDetalhe[nCntFor,nCntFor2,1]=="JUROS"
								xJUROS := SubStr(cBuffer,nPosIni,nTamanho)
								xJUROS := Val(xJUROS)/(Val("1"+Repl("0",nDecimal)))
							Case aDetalhe[nCntFor,nCntFor2,1]=="MULTA"
								xMULTA := SubStr(cBuffer,nPosIni,nTamanho)
								xMULTA := Val(xMULTA)/(Val("1"+Repl("0",nDecimal)))
							Case aDetalhe[nCntFor,nCntFor2,1]=="OUTROSCREDITOS"
								xValCC := SubStr(cBuffer,nPosIni,nTamanho)
								xValCC := Val(xValCC)/(Val("1"+Repl("0",nDecimal)))
							Case aDetalhe[nCntFor,nCntFor2,1]=="IOF"
								xValIof := SubStr(cBuffer,nPosIni,nTamanho)
								xValIof := Val(xValIof)/(Val("1"+Repl("0",nDecimal)))
							Case aDetalhe[nCntFor,nCntFor2,1]=="DATACREDITO"
								xDATACRED := SubStr(cBuffer,nPosIni,nTamanho)
							Case aDetalhe[nCntFor,nCntFor2,1]=="MOTIVO"
								xMOTIVO := SubStr(cBuffer,nPosIni,nTamanho)
							Case aDetalhe[nCntFor,nCntFor2,1]=="RESERVADO"
								xRESERVADO:= SubStr(cBuffer,nPosIni,nTamanho)
							Case aDetalhe[nCntFor,nCntFor2,1]=="AUTENTICACAO"
								xAUTENTICA := SubStr(cBuffer,nPosIni,nTamanho)
							Case aDetalhe[nCntFor,nCntFor2,1]=="CGC"
								xCGC:= SubStr(cBuffer,nPosIni,nTamanho)
							Case aDetalhe[nCntFor,nCntFor2,1]=="CGCH"
								xCGCH:= SubStr(cBuffer,nPosIni,nTamanho)
							Case aDetalhe[nCntFor,nCntFor2,1]=="CODBAR"
								xCODBAR:= SubStr(cBuffer,nPosIni,nTamanho)
							Case aDetalhe[nCntFor,nCntFor2,1]=="IDENT REG OPCIO"
								xIdent:= SubStr(cBuffer,nPosIni,nTamanho)
							EndCase
						Next
					EndIf
				EndIf
			Next nCntFor
			cSeg52 := ""
			If ( !lSegValido .And. !Empty(cIdent) )
				lContinua := .F.
			EndIf
		Endif
	Else
		lContinua := .F.
	EndIf
EndDo
Return({	xTITULO,xTIPO,xOCORRENCI,xDATA,xVALOR,;
			xDESPESA,xDESCONTO,xABATIMENT,xJUROS,xMULTA,;
			xNOSSONUM,xValIof,xValCC,xDATACRED,xMOTIVO,;
			xRESERVADO,xBuffer,xAUTENTICA,aBuffer,xCGC,;
			xBanco,xAgencia,xConta,xCGCH,xCODBAR, xCGCEMP})


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} HEADLOTE2

CNAB Modelo 2 - Cria Header do lote de registro no arq Cnab Modelo 2
Arquivo original: MATXFUNB.PRX

@param nHandle - Handle do Arquivo a ser lido
@param cLayout - Atributos do arquivo de configuracao

@Author	Claudio Donizete
@since 27/12/2005
/*/
//-----------------------------------------------------------------------------------------------------
Function HeadLote2(nHdlSaida,cLayOut)

Local nHdlLay	 := 0
Local lContinua := .T.
Local cBuffer	 := ""
Local aLayOut	 := {}
Local aDetalhe  := {}
Local nCntFor	 := 0
Local nCntFor2  := 0
Local lFormula  := ""
Local nPosIni	 := 0
Local nPosFim	 := 0
Local nTamanho  := 0
Local nDecimal  := 0
Local bBlock	 := ErrorBlock()

Private xConteudo := ""

If ( File(cLayOut) )
	nHdlLay := FOpen(cLayOut,64)
	While ( lContinua )
		cBuffer := FreadStr(nHdlLay,502)
		If ( !Empty(cBuffer) )
			If ( SubStr(cBuffer,1,1)=="1" )
				If ( SubStr(cBuffer,2,1)$"1/2/3/4/5/6/7/8/9" )
					If ( SubStr(cBuffer,3,1) == "H" )
						aadd(aLayOut, {SubStr(cBuffer,02,03), SubStr(cBuffer,05,30), SubStr(cBuffer,35,255) } )
					EndIf
				Endif
			Else
				If ( SubStr(cBuffer,3,1) == "H" )
					aadd(aDetalhe,{SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,15),;
					SubStr(cBuffer,20,03),;
					SubStr(cBuffer,23,03),;
					SubStr(cBuffer,26,01),;
					SubStr(cBuffer,27,255)})
				EndIf
			EndIf
		Else
			lContinua := .F.
		EndIf
	End
	FClose(nHdlLay)
EndIf
For nCntFor := 1 To Len(aLayOut)
	Begin Sequence
	lFormula := &(AllTrim(aLayOut[nCntFor,3]))
	If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="H" )
		cBuffer := ""
		For nCntFor2 := 1 To Len(aDetalhe)
			If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
				xConteudo := (AllTrim(aDetalhe[nCntFor2,6]))
				If ( Empty(xConteudo) )
					xConteudo := ""
				Else
					xConteudo := &(AllTrim(xConteudo))
				EndIf
				nPosIni   := Val(aDetalhe[nCntFor2,3])
				nPosFim   := Val(aDetalhe[nCntFor2,4])
				nDecimal  := Val(aDetalhe[nCntFor2,5])
				nTamanho  := nPosFim-nPosIni+1
				Do Case
					Case ValType(xConteudo) == "D"
						xConteudo := GravaData(xConteudo,.F.)
					Case ValType(xConteudo) == "N"
						xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
				EndCase
				xConteudo := SubStr(xConteudo,1,nTamanho)
				xConteudo := PadR(xConteudo,nTamanho)
				cBuffer += xConteudo
			EndIf
		Next nCntFor2
		cBuffer += Chr(13)+Chr(10)
		Fwrite(nHdlSaida,cBuffer,Len(cBuffer))
	EndIf
	End Sequence
Next nCntFor
ErrorBlock(bBlock)
Return(nHdlSaida)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} HEADCNAB2

CNAB Modelo 2 - Cria o Arquivo padrao Cnab Modelo 2.
Arquivo original: MATXFUNB.PRX

@param nArquivo - nome do arquivo a ser gerado
@param cLayout - nome do arquivo de configuração

@Author	Eduardo Riera
@since 16/04/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function HeadCnab2(cArquivo,cLayOut)

Local nHandle	 := 0
Local lContinua := .T.
Local cBuffer	 := ""
Local aLayOut	 := {}
Local aDetalhe  := {}
Local nCntFor	 := 0
Local nCntFor2  := 0
Local lFormula  := ""
Local nPosIni	 := 0
Local nPosFim	 := 0
Local nTamanho  := 0
Local nDecimal  := 0
Local bBlock	 := ErrorBlock()
Local lUtilizaMI := cPaisLoc $ "PER|MEX|COL|EQU"
Private xConteudo := ""

If Type("nDecTotal") == "U"
	Private nDecTotal:= 0
EndIf

If ( File(cLayOut) )
	nHandle := FOpen(cLayOut,64)
	While ( lContinua )
		cBuffer := FreadStr(nHandle,502)
		If ( !Empty(cBuffer) )
			If ( SubStr(cBuffer,1,1)=="1" )
				If ( SubStr(cBuffer,3,1) == "H" )
					aadd(aLayOut,{ SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,30),;
					SubStr(cBuffer,35,255)})
				EndIf
			Else
				If ( SubStr(cBuffer,3,1) == "H" )
					aadd(aDetalhe,{SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,15),;
					SubStr(cBuffer,20,03),;
					SubStr(cBuffer,23,03),;
					SubStr(cBuffer,26,01),;
					SubStr(cBuffer,27,255)})
				EndIf
			EndIf
		Else
			lContinua := .F.
		EndIf
	End
	FClose(nHandle)
EndIf
nHandle := FCreate(cArquivo)
If nHandle > 0
	For nCntFor := 1 To Len(aLayOut)
		Begin Sequence
		lFormula := &(AllTrim(aLayOut[nCntFor,3]))
		If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="H" )
			cBuffer := ""
			For nCntFor2 := 1 To Len(aDetalhe)
				If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
					xConteudo := (AllTrim(aDetalhe[nCntFor2,6]))
					If ( Empty(xConteudo) )
						xConteudo := ""
					Else
						If "NTOTFUNC" $ xConteudo
							xConteudo := &(AllTrim(xConteudo))
							xConteudo := replicate("^",len(xConteudo))
						Elseif "NTOTAL" $ xConteudo .And. lUtilizaMI
							xConteudo := &(AllTrim(xConteudo))
							xConteudo := replicate("#",len(xConteudo))	
						Else 
							xConteudo := &(AllTrim(xConteudo))
						EndIf
					EndIf
					nPosIni   := Val(aDetalhe[nCntFor2,3])
					nPosFim   := Val(aDetalhe[nCntFor2,4])
					nDecimal  := Val(aDetalhe[nCntFor2,5])
					If "NTOTAL" $ aDetalhe[nCntFor2,6] .And. lUtilizaMI
						nDecTotal:=nDecimal
					EndIF
					nTamanho  := nPosFim-nPosIni+1
					Do Case
						Case ValType(xConteudo) == "D"
							xConteudo := GravaData(xConteudo,.F.)
						Case ValType(xConteudo) == "N"
							xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
					EndCase
					xConteudo := SubStr(xConteudo,1,nTamanho)
					xConteudo := PadR(xConteudo,nTamanho)
					cBuffer += xConteudo
				EndIf
			Next nCntFor2
			cBuffer += Chr(13)+Chr(10)
			Fwrite(nHandle,cBuffer,Len(cBuffer))
		EndIf
		End Sequence
	Next nCntFor
	ErrorBlock(bBlock)
Endif
Return(nHandle)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} DETCNAB2

CNAB Modelo 2 - Inseri as linhas de detalhe do CNAB Modelo 2.
Arquivo original: MATXFUNB.PRX

@Author	Eduardo Riera
@since 16/04/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function DetCnab2(nHandle,cLayOut,lIdCnab,cAlias)

Local nHdlLay	 := 0
Local lContinua := .T.
Local cBuffer	 := ""
Local aLayOut	 := {}
Local aDetalhe  := {}
Local nCntFor	 := 0
Local nCntFor2  := 0
Local lFormula  := ""
Local nPosIni	 := 0
Local nPosFim	 := 0
Local nTamanho  := 0
Local nDecimal  := 0
Local bBlock	 := ErrorBlock()
Local aGetArea  := GetArea()
Local cChaveID  := ""
Local cIdCnab
Local aArea
Local nOrdem

Default cAlias 	:= ""
Default lIdCnab 	:= .F.
Private xConteudo := ""

nQtdLinLote := If(Type("nQtdLinLote") != "N", 0, nQtdLinLote)
nQtdLnLote  := If(Type("nQtdLnLote")  != "N", 0, nQtdLnLote)

If ( File(cLayOut) )
	nHdlLay := FOpen(cLayOut,64)
	While ( lContinua )
		cBuffer := FreadStr(nHdlLay,502)
		If ( !Empty(cBuffer) )
			If ( SubStr(cBuffer,1,1)=="1" )
				If ( SubStr(cBuffer,3,1) == "D" )
					aadd(aLayOut,{ SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,30),;
					SubStr(cBuffer,35,255)})
				EndIf
			Else
				If ( SubStr(cBuffer,3,1) == "D" )
					aadd(aDetalhe,{SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,15),;
					SubStr(cBuffer,20,03),;
					SubStr(cBuffer,23,03),;
					SubStr(cBuffer,26,01),;
					SubStr(cBuffer,27,255)})
				EndIf
			EndIf
		Else
			lContinua := .F.
		EndIf
	End
	FClose(nHdlLay)
EndIf
If nHandle > 0
	For nCntFor := 1 To Len(aLayOut)
		Begin Sequence
		lFormula := &(AllTrim(aLayOut[nCntFor,3]))

		If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="D" )
			cBuffer := ""
			// So gera outro identificador, caso o titulo ainda nao o tenha, pois pode ser um re-envio do arquivo
			If !Empty(cAlias) .And. lIdCnab .And. Empty((cAlias)->&(Right(cAlias,2)+"_IDCNAB"))
				// Gera identificador do registro CNAB no titulo enviado
				cIdCnab := GetSxENum(cAlias, Right(cAlias, 2 ) + "_IDCNAB", Right(cAlias,2) + "_IDCNAB" + cEmpAnt, nOrdem)
				nOrdem := If(Alltrim(Upper(cAlias)) == "SE1",19,13)
				cChaveID := cIdCnab

				// Garante que o identificador gerado nao existe na base
				dbSelectArea(cAlias)
				aArea := (cAlias)->(GetArea())
				dbSetOrder(nOrdem)

				While (cAlias)->(MsSeek(cChaveID))
					ConOutR("Id CNAB " + cIdCnab + " já existe para o arquivo " + cAlias + ". Gerando novo número ")

					If ( __lSx8 )
						ConfirmSX8()
					EndIf

					cIdCnab	:= GetSxENum(cAlias, Right(cAlias,2)+"_IDCNAB",Right(cAlias,2)+"_IDCNAB"+cEmpAnt,nOrdem)
					cChaveID := cIdCnab

				EndDo

				//+----------------------------------------------------------+
				//¦ Ponto de entrada para tratamento da variavel cIdCnab     ¦
				//+----------------------------------------------------------+
				If lF420ICNB
					cIdCnab := ExecBlock("F420ICNB",.F.,.F.,{cIdCnab})
				EndIf

				(cAlias)->(RestArea(aArea))
				Reclock(cAlias)
				(cAlias)->&(Right(cAlias,2)+"_IDCNAB") := cIdCnab
				MsUnlock()
				ConfirmSx8()
				lIdCnab := .F. // Gera o identificacao do registro CNAB apenas uma vez no titulo enviado
			Endif

			For nCntFor2 := 1 To Len(aDetalhe)
				If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
					xConteudo := aDetalhe[nCntFor2,6]
					If ( Empty(xConteudo) )
						xConteudo := ""
					Else
						xConteudo := &(AllTrim(xConteudo))
					EndIf
					nPosIni   := Val(aDetalhe[nCntFor2,3])
					nPosFim   := Val(aDetalhe[nCntFor2,4])
					nDecimal  := Val(aDetalhe[nCntFor2,5])
					nTamanho  := nPosFim-nPosIni+1
					Do Case
						Case ValType(xConteudo) == "D"
							xConteudo := GravaData(xConteudo,.F.)
						Case ValType(xConteudo) == "N"
							xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
					EndCase
					xConteudo := SubStr(xConteudo,1,nTamanho)
					xConteudo := PadR(xConteudo,nTamanho)
					cBuffer += xConteudo
				EndIf
			Next nCntFor2

			cBuffer += Chr(13)+Chr(10)
			Fwrite(nHandle,cBuffer,Len(cBuffer))
			nQtdLinLote++
		EndIf
		End Sequence
	Next nCntFor
	ErrorBlock(bBlock)
Endif
RestArea(aGetArea)
Return(.T.)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RODACNAB2

CNAB Modelo 2 -  Fecha o arquivo CNAB Modelo 2.
Arquivo original: MATXFUNB.PRX

@param nHandle - handle do arquivo criado pela HeadCnab2
@param cLayout - nome do arquivo de configuração
@param lQuebra

@Author	Eduardo Riera
@since 16/04/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function RodaCnab2(nHandle,cLayOut,lQuebra)

Local nHdlLay	:= 0
Local lContinua	:= .T.
Local cBuffer	:= ""
Local aLayOut	:= {}
Local aDetalhe  := {}
Local nCntFor	:= 0
Local nCntFor2  := 0
Local lFormula  := .F.
Local nPosIni	:= 0
Local nPosFim	:= 0
Local nTamanho  := 0
Local nDecimal  := 0
Local bBlock	:= ErrorBlock()

//-- Variaveis para tratamento de geracao de Chr(10) + Chr(13) para ultima linha gerada
Local nLHead 	:= nCntFor
Local nLDet		:= nCntFor2
Local nLUltLin	:= nCntFor2

//-- Determina se gera Chr(10) + Chr(13) para as linhas geradas
DEFAULT	lQuebra	:= .T.

Private xConteudo := ""

If ( File(cLayOut) )
	nHdlLay := FOpen(cLayOut,64)
	While ( lContinua )
		cBuffer := FreadStr(nHdlLay,502)
		If ( !Empty(cBuffer) )
			If ( SubStr(cBuffer,1,1)=="1" )
				If ( SubStr(cBuffer,3,1) == "T" )
					aadd(aLayOut,{ SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,30),;
					SubStr(cBuffer,35,255)})

				EndIf
			Else
				If ( SubStr(cBuffer,3,1)=="T" )
					aadd(aDetalhe,{SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,15),;
					SubStr(cBuffer,20,03),;
					SubStr(cBuffer,23,03),;
					SubStr(cBuffer,26,01),;
					SubStr(cBuffer,27,255)})
				EndIf
			EndIf
		Else
			lContinua := .F.
		EndIf
	End
	FClose(nHdlLay)
EndIf
aSort(aLayOut,,,{|x,y| x[1]>y[1]})
If nHandle > 0

	//-- Obtem a ultima posicao da linha gerada no arquivo
	IF !lQuebra
		For nCntFor := 1 To Len(aLayOut)
			Begin Sequence
			lFormula := &(aLayOut[nCntFor,3])
			If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="T" )
				cBuffer := ""
				For nCntFor2 := 1 To Len(aDetalhe)
					If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
						xConteudo := (aDetalhe[nCntFor2,6])
						If ( Empty(xConteudo) )
							xConteudo := ""
						Else
							xConteudo := &(AllTrim(xConteudo))
						EndIf
						nPosIni   := Val(aDetalhe[nCntFor2,3])
						nPosFim   := Val(aDetalhe[nCntFor2,4])
						nDecimal  := Val(aDetalhe[nCntFor2,5])
						nTamanho  := nPosFim-nPosIni+1
						Do Case
							Case ValType(xConteudo) == "D"
								xConteudo := GravaData(xConteudo,.F.)
							Case ValType(xConteudo) == "N"
								xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
						EndCase
						xConteudo := SubStr(xConteudo,1,nTamanho)
						xConteudo := PadR(xConteudo,nTamanho)
						cBuffer += xConteudo
						//- Obtem a ultima posicao da linha gerada no arquivo
					 	nLDet	:= nCntFor2
					 	nLHead 	:= nCntFor
					EndIf
				Next nCntFor2

			EndIf
			End Sequence
		Next nCntFor
	Endif

 	nLUltLin:= 0

	For nCntFor := 1 To Len(aLayOut)
		Begin Sequence
		lFormula := &(aLayOut[nCntFor,3])
		If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="T" )
			cBuffer := ""
			For nCntFor2 := 1 To Len(aDetalhe)
				If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
					xConteudo := (aDetalhe[nCntFor2,6])
					If ( Empty(xConteudo) )
						xConteudo := ""
					Else
						xConteudo := &(AllTrim(xConteudo))
					EndIf
					nPosIni   := Val(aDetalhe[nCntFor2,3])
					nPosFim   := Val(aDetalhe[nCntFor2,4])
					nDecimal  := Val(aDetalhe[nCntFor2,5])
					nTamanho  := nPosFim-nPosIni+1
					Do Case
						Case ValType(xConteudo) == "D"
							xConteudo := GravaData(xConteudo,.F.)
						Case ValType(xConteudo) == "N"
							xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
					EndCase
					xConteudo := SubStr(xConteudo,1,nTamanho)
					xConteudo := PadR(xConteudo,nTamanho)
					cBuffer += xConteudo
					nLUltLin:= nCntFor2
				EndIf

			Next nCntFor2

			//-- Gera Chr(13)+Chr(10) para todas as linhas ou para as N-1 linhas
			If ( lQuebra ) .OR. ( !lQuebra .AND. !( (nLUltLin == nLDet) .and. (nCntFor == nLHead)) )
				cBuffer += Chr(13)+Chr(10)
			EndIf
			Fwrite(nHandle,cBuffer,Len(cBuffer))
		EndIf
		End Sequence
	Next nCntFor

	ErrorBlock(bBlock)
	FClose(nHandle)
Endif
Return(.T.)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RODALOTE2

CNAB Modelo 2 -  Gera Trailler de Lote CNAB Modelo  2.
Arquivo original: MATXFUNB.PRX

@param nHandle - handle do arquivo criado pela HeadCnab2
@param cLayout - nome do arquivo de configuração

@Author	Claudio DOnizete
@since 27/12/2005
/*/
//-----------------------------------------------------------------------------------------------------
Function RodaLote2(nHandle,cLayOut)

Local nHdlLay	 := 0
Local lContinua := .T.
Local cBuffer	 := ""
Local aLayOut	 := {}
Local aDetalhe  := {}
Local nCntFor	 := 0
Local nCntFor2  := 0
Local lFormula  := .F.
Local nPosIni	 := 0
Local nPosFim	 := 0
Local nTamanho  := 0
Local nDecimal  := 0
Local bBlock	 := ErrorBlock()

Private xConteudo := ""

If ( File(cLayOut) )
	nHdlLay := FOpen(cLayOut,64)
	While ( lContinua )
		cBuffer := FreadStr(nHdlLay,502)
		If ( !Empty(cBuffer) )
			If ( SubStr(cBuffer,1,1)=="1" )
				If ( SubStr(cBuffer,2,1) != "0" )		 //	If ( SubStr(cBuffer,2,1)=="1" )
					If ( SubStr(cBuffer,3,1) == "T" )
						aadd(aLayOut,{ SubStr(cBuffer,02,03),;
						SubStr(cBuffer,05,30),;
						SubStr(cBuffer,35,255)})
					EndIf
				Endif
			Else
				If ( SubStr(cBuffer,3,1)=="T" )
					aadd(aDetalhe,{SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,15),;
					SubStr(cBuffer,20,03),;
					SubStr(cBuffer,23,03),;
					SubStr(cBuffer,26,01),;
					SubStr(cBuffer,27,255)})
				EndIf
			EndIf
		Else
			lContinua := .F.
		EndIf
	End
	FClose(nHdlLay)
EndIf
aSort(aLayOut,,,{|x,y| x[1]>y[1]})
If nHandle > 0
	For nCntFor := 1 To Len(aLayOut)
		Begin Sequence
		lFormula := &(aLayOut[nCntFor,3])
		If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="T" )
			cBuffer := ""
			For nCntFor2 := 1 To Len(aDetalhe)
				If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
					xConteudo := (aDetalhe[nCntFor2,6])
					If ( Empty(xConteudo) )
						xConteudo := ""
					Else
						xConteudo := &(AllTrim(xConteudo))
					EndIf
					nPosIni   := Val(aDetalhe[nCntFor2,3])
					nPosFim   := Val(aDetalhe[nCntFor2,4])
					nDecimal  := Val(aDetalhe[nCntFor2,5])
					nTamanho  := nPosFim-nPosIni+1
					Do Case
						Case ValType(xConteudo) == "D"
							xConteudo := GravaData(xConteudo,.F.)
						Case ValType(xConteudo) == "N"
							xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
					EndCase
					xConteudo := SubStr(xConteudo,1,nTamanho)
					xConteudo := PadR(xConteudo,nTamanho)
					cBuffer += xConteudo
				EndIf
			Next nCntFor2
			cBuffer += Chr(13)+Chr(10)
			Fwrite(nHandle,cBuffer,Len(cBuffer))
		EndIf
		End Sequence
	Next nCntFor
	ErrorBlock(bBlock)
Endif
Return(.T.)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SOMAABAT

Soma todos os titulos de abatimento ate uma data limite
Arquivo original: MATXFUNB.PRX

@Author	Eduardo Riera
@since 17/03/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function SomaAbat(cPrefixo,cNumero,cParcela,cCart,nMoeda,dData,cFornCli,cLoja,cFilAbat,dDataRef,cTipo)

Local cProcedure := GetSPName("FIN001","08") //'SUMABAT'
Local aResult
Local nTotAbat 	:= 0
Default cTipo:= ""

Default __lPFin001 := ExistProc ( cProcedure, STATICCALL(MATXFUNB,VERIDPROC2))

nMoeda	 := If( nMoeda	 == NIL, 1 ,nMoeda )
dData  	 := If( dData	 == NIL, dDataBase,dData )
cFilAbat := If( cFilAbat == NIL, If( cCart == "R", xFilial("SE1"),xFilial("SE2")), cFilAbat)
cFornCli := If( cFornCli == Nil, If( cCart == "R", SE1->E1_CLIENTE, SE2->E2_FORNECE), cFornCli)
cLoja    := If( cLoja	 == Nil, If( cCart == "R", SE1->E1_LOJA, SE2->E2_LOJA), cLoja)
dDataRef := If( dDataRef == NIL, dDataBase, dDataRef )
cTipo	 := If( Empty(cTipo), If( cCart=="R", SE1->E1_TIPO, SE2->E2_TIPO), cTipo)

If __lPFin001 .and. !(FwIsInCallStack("FINR340")) .and. !Empty(cNumero)

	// Define banco de dados para procedure SomaAbat utilizar sintaxe correta ("||" ou "+")
	If __cBD == Nil
		__cBD := IIf((Alltrim(Upper(TcGetDb()))) $ 'ORACLE.POSTGRES.DB2.INFORMIX' ,'2','1')
	EndIf

	If cCart == "R"	.and. !Empty(SE1->E1_TITPAI)
		If(Alltrim(SE1->E1_TITPAI) == Alltrim(cPrefixo+cNumero+cParcela+cTipo+cFornCli+cLoja))
			aResult := TCSPEXEC(xProcedures(cProcedure), cPrefixo,;
					     cNumero, cParcela, cCart,nMoeda,DTOS(dData),cFornCli,cLoja,cFilAbat,;
						  DTOS(dDataRef), cTipo, __cBD)
			Return aResult[1]
		Else
			Return nTotAbat
		EndIf
	Else
		aResult := TCSPEXEC(xProcedures(cProcedure), cPrefixo,;
				     cNumero, cParcela, cCart,nMoeda,DTOS(dData),cFornCli,cLoja,cFilAbat,;
					  DTOS(dDataRef), cTipo, __cBD)
		Return Iif( ValType(aResult) == "A" .And. Len(aResult) > 0, aResult[1], nTotAbat )
	Endif
Else
	Return xSomaAbat(cPrefixo,cNumero,cParcela,cCart,nMoeda,dData,cFornCli,cLoja,cFilAbat, dDataRef, cTipo)
EndIf


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} XSOMAABAT

Soma todos os titulos de abatimento ate uma data limite (Filha da SomaAbat).
Arquivo original: MATXFUNB.PRX

@Author	TOTVS
@since 17/03/1998
/*/
//-----------------------------------------------------------------------------------------------------

Static Function xSomaAbat(cPrefixo,cNumero,cParcela,cCart,nMoeda,dData,cFornCli,cLoja,cFilAbat, dDataRef, cTipo)

	Local nTotAbat  := 0
	Local cAliasAbt := Alias()
	Local nOrdem    := indexord()
	//controle de abatimento pelo titpai
	Local cAliasSoma := GetNextAlias()
	Local cAbatiment 

	DEFAULT cCart    := If(cCart="R",cCart,"P")
	DEFAULT nMoeda   := 1
	DEFAULT dData    := dDataBase
	DEFAULT cFilAbat := If(cCart=="R", xFilial("SE1"), xFilial("SE2"))
	DEFAULT cFornCli := If(cCart=="R", SE1->E1_CLIENTE, SE2->E2_FORNECE)
	DEFAULT cLoja    := If(cCart=="R", SE1->E1_LOJA, SE2->E2_LOJA)
	DEFAULT cTipo	 := If(cCart=="R", SE1->E1_TIPO, SE2->E2_TIPO)
	DEFAULT dDataRef := dDataBase
	Default cTipo:= ""

	If cCart == "R"
		If Select("__SE1") == 0
			ChkFile("SE1",.F.,"__SE1")
		Else
			DbSelectArea("__SE1")
		EndIf
		cAbatiment := " E1_TIPO LIKE '%-' "
		IF FwIsInCallStack("FINR340")
			cAbatiment := "("+cAbatiment + " OR E1_TIPO = '"+MVIRF+"')"
		EndIf 

		cAbatiment := "%" + cAbatiment + "%"

		BeginSql Alias cAliasSoma
		Column EMISSAO As Date
		select E1_EMISSAO EMISSAO, E1_TIPO TIPO,E1_MOEDA MOEDA, E1_TXMOEDA TXMOEDA, E1_VALOR VALOR, E1_SALDO SALDO
			from %Table:SE1% SE1
			where E1_FILIAL    = %Exp:cFilAbat%
			and E1_PREFIXO   = %Exp:cPrefixo%
			and E1_NUM       = %Exp:cNumero%
			and E1_PARCELA   = %Exp:cParcela%
			and %Exp:cAbatiment%
			and (E1_CLIENTE  = %Exp:cFornCli% or E1_CLIENTE  = 'UNIAO ')
			and (E1_LOJA     = %Exp:cLoja%    or E1_CLIENTE  = 'UNIAO ')
			and E1_EMISSAO  <= %Exp:dDataRef%
			and E1_TITPAI	   = %Exp:cPrefixo+cNumero+cParcela+cTipo+cFornCli+cLoja%
			AND SE1.%NotDel%
		EndSql
	ELSE
		IF SELECT("__SE2") == 0
			ChkFile("SE2",.F.,"__SE2")
		Else
			DbSelectArea("__SE2")
		EndIf
		cAbatiment := " E2_TIPO LIKE '%-' "

		cAbatiment := "%" + cAbatiment + "%"

		BeginSql Alias cAliasSoma
		Column EMISSAO As Date
		select E2_EMISSAO EMISSAO, E2_TIPO TIPO,E2_MOEDA MOEDA, E2_TXMOEDA TXMOEDA, E2_VALOR VALOR, E2_SALDO SALDO
		from %Table:SE2% SE2
		where E2_FILIAL   = %Exp:cFilAbat%
			and E2_PREFIXO  = %Exp:cPrefixo%  
			and E2_NUM      = %Exp:cNumero%
			and E2_PARCELA  = %Exp:cParcela%
			and %Exp:cAbatiment%
			and E2_FORNECE  = %Exp:cFornCli%
			and E2_LOJA     = %Exp:cLoja%
			and E2_EMISSAO <= %Exp:dDataRef%
			and SE2.%NotDel%
		EndSql

	ENDIF
	DbSelectArea(cAliasSoma)


	While (cAliasSoma)->(!Eof())
		//----------------------------------------------------------------------
		// Validacao inserida para o processo de baixa parcial da Ordem de Pago
		// evitando que o titulo de abatimento seja descontado mais de uma vez
		//----------------------------------------------------------------------
		If (cAliasSoma)->SALDO > 0 .Or. !(FwIsInCallStack("FINA085A") .Or. FwIsInCallStack("FINA850"))
			nTotAbat += xMoeda((cAliasSoma)->VALOR,(cAliasSoma)->MOEDA,nMoeda,;
						Iif(AllTrim((cAliasSoma)->TIPO) == "IR-", (cAliasSoma)->EMISSAO, dData),,If(cPaisLoc=="BRA",(cAliasSoma)->TXMOEDA,0))
		EndIf
		(cAliasSoma)->(dbSkip())
	EndDo
	(cAliasSoma)->(dbCloseArea())

	If !Empty(cAliasAbt)
		DbSelectArea(cAliasAbt)
		DbSetOrder(nOrdem)
	Endif

Return(nTotAbat)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} DTMOVFIN

Data limite para realização de Movimento no Financeiro.
Arquivo original: MATXFUNB.PRX

@Author	Mauricio Pequim Jr.
@since 06/11/1997
/*/
//-----------------------------------------------------------------------------------------------------
Function DtMovFin(dData,lHelp,cFunct)

Local lRet		:= .T.
Local lValBloq	:= (cPaisLoc == "MEX" .AND. FunName() == "FISA817" .AND. FindFunction("FS817VlCnt"))

Default dData := dDatabase
Default lHelp := .T.

If lFADTMOV == NIL
	lFADTMOV := ExistBlock("FADTMOV")
Endif

dDataFin := SuperGetMv("MV_DATAFIN",.T.,StoD("19800101"),cFilAnt)

If dData < dDataFin .And. !lFADTMOV
	If lHelp
		Help ( " ", 1, "DTMOVFIN")
	EndIf
	lRet:=.F.
EndIf

/*Ponto de entrada para controlar datas diferentes para movimento bancario,
contas a pagar entre outras funcionalidades em que é aplicado a DtMovFin*/
If lFADTMOV
	lRet :=	ExecBlock("FADTMOV",.F.,.F.,{dData})
EndIf

If lRet .And. !lValBloq
	lRet := CtbValiDt(,dData,lHelp,,,IIF(cFunct == "1",{"FIN001"},IIF(cFunct == "2",{"FIN002"},IIF(cFunct == "3",{"FIN001","FIN002"},""))),)
Endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}IsEmpPub
Programa p/ verificar o minimo de irrf e pcc esta configurado
corretamente para empresas publicas.
@author Caique Bispo Ferreira
@since  19/02/2015
/*/
//-------------------------------------------------------------------

Function IsEmpPub()

Local lRet := .F.
Local lEmpPub := SuperGetMv("MV_ISPPUBL" ,.T.,"2") == "1"
Local nVlMinPCC := SuperGetMv("MV_VL10925" ,.T.,5000)
Local nVlMinIR := SuperGetMv("MV_VLRETIR" ,.T.,10)

If lEmpPub .And. nVlMinPCC == 0 .And. nVlMinIR == 0
	lRet := .T.
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}fCRetCal
Programa p/ calcular data vencimento de Impostos.

@param nTipo
	1 - diario
	2 - Semanal add 3 dias.
	3 - Decendio add 3 dias.
	4 - Até o ultima dia da Quinzena SubSequente
	5 - Até Dia 20 do mês subsequente
	6 - Até o Décimo quinto dia util do mês subsequente

@param dEmissao -

@author Marjorie
@since  26/02/15
/*/
//-------------------------------------------------------------------
Function fCRetCal(nTipo,dEmissao)

Local nNextMes 	:= 0
Local dData 		:= CtoD("//")
Local nI 			:= 1

Default dEmissao := dDatabase
Default nTipo := 0

dData 				:= dEmissao
nNextMes 			:= Month(dData) + 1

If nTipo == 1
	//na data de ocorrência
	dData	:= dData

ElseIf nTipo == 2
	//Semanal add 3 dias.
	For nI:=1 To 7
		If Dow( dData ) = 1
			Exit
		End
		dData++
	Next nI

ElseIf nTipo == 3
	//Decendio add 3 dias.
	If Day(dData) >= 1 .And. Day(dData) <= 10
		dData := CTOD("11/"+StrZero(Month(dData),2)+"/"+Str(Year(dData)))
	ElseIf Day(dData) >= 11 .And. Day(dData) <= 20
		dData := CTOD("21/"+StrZero(Month(dData),2)+"/"+Str(Year(dData)))
	Else
		dData := CTOD("01/"+If(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+;
					Str(If(nNextMes==13,Year(dData)+1,Year(dData))))
	EndIf

ElseIf nTipo == 4
	//Até o ultima dia da Quinzena SubSequente
	If Day(dData) <= 15
		dData := CTOD("01/"+;  //dia
		Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+; //mes
			Substr(Str(Iif(nNextMes==13,Year(dData)+1,Year(dData))),2))    //ano
	Else
		dData := CTOD("16/"+;  //dia
		Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+; //mes
			Substr(Str(Iif(nNextMes==13,Year(dData)+1,Year(dData))),2))    //ano

	EndIf
	dData -= 1

ElseIf nTipo == 5
	//Até Dia 20 do mês subsequente
	dData := CTOD("20/"+Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/";
			+Substr(Str(Iif(nNextMes==13,Year(dData)+1,Year(dData))),2))
ElseIf nTipo == 6
	//Até o décimo quinto dia util do mês subsequente
	dData := CTOD("15/"+;  //dia
		Iif(nNextMes==13,"01",StrZero(nNextMes,2))+"/"+; //mes
			Substr(Str(Iif(nNextMes==13,Year(dData)+1,Year(dData))),2))    //ano
EndIf


//Valida Data Valida
If nTipo == 5 .Or. nTipo == 4 .Or. nTipo == 6
	//Subtrai dia
	While .T.
		If DataValida(dData,.T.) == dData
			Exit
		Else
			dData -= 1
		Endif
	Enddo

ElseIf nTipo == 2 .Or. nTipo == 3
	//Adiciona 3 dias.
	nI := 1
	While nI <= 3
		If DataValida(dData,.T.) == dData
			If nI < 3
				dData += 1
			EndIf
			nI +=1
		Else
			dData += 1
		Endif
	EndDo
EndIf

Return dData

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ LerLinha ³ Autor ³ J£lio Wittwer         ³ Data ³ 20.12.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Le mais uma linha do Arquivo de Retorno CNAB               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ cRet := LerLinha(nHandleRet)                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ ReadCnab2()                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Static Function LerLinha(nHandle,nMaxLn)
Local cString	:= ""
Local nTotLidos	:= 0
Local lCRLF		:= .T.

Default nMaxLn := 1000

cString := Space(nMaxLn)
FReadLn(nHandle, @cString, nMaxLn, @lCRLF) // Le uma linha ate CR+LF.

//Se a linha possuir CRLF no seu final
If lCRLF
	nTotLidos := Len(cString)+2
//Se a linha NAO possuir CRLF no seu final
Else
	nTotLidos := Len(cString)
Endif

Return {cString,nTotLidos}

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinaCONC
faz a concatenação das mensagens de LOG para criação de Histórico de Cobrança
@author Alexandre Felicio
@since  02/07/2015
@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Function FinaCONC(aAlt As Array, cAlias As Character)
Local nCx           As Numeric           
Local cHistorico    As Character    
Local cProcesso     As Character    

Default cAlias      := Alias() //Procura chave do titulo SE1 ou SE2
//Rotinas do ADM que devem ser revisadas para subir passando alias FIN887EventDEF, FINA040, FINA050, FINA060, FINA061, FINA070, FINA080, FINA110
//FINA330, FINA450, FINA460, FINA460a, FINA590, FINA620, FINA630, FINA770, FINA771, FINA087A 

nCx         := 0
cHistorico  := ''
cProcesso   := ''

For nCx := 1 to LEN(aAlt)

    cProcesso := aAlt[nCx][1]

    If !Empty(aAlt[nCx][2])
	    cHistorico += aAlt[nCx][2] + CRLF
	endif
	If !Empty(aAlt[nCx][3])
	    cHistorico += aAlt[nCx][3] + CRLF
	endif
	If !Empty(aAlt[nCx][4])
	    cHistorico += aAlt[nCx][4] + CRLF
	endif
	 If !Empty(aAlt[nCx][5])
	    cHistorico += aAlt[nCx][5] + CRLF
	endif

	cHistorico += CRLF

Next nCx

FinaLog(cProcesso,cHistorico, cAlias)

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinaLog
Faz inclusão de registros de LOG a partir do Processo e Histórico informados
@author Alexandre Felicio
@since  01/07/2015
@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Function FinaLog(cProcesso As Character, cHistorico As Character, cAlias As Character)
Local cIdDoc    As Character 
Local cIdCV8    As Character 
Local cChaveTit As Character    
Local cFilOrig  As Character 
Local cAliasAtu As Character 

Default cProcesso  := ''
Default cHistorico := ''
Default cAlias      := Alias()

cIdDoc      := ''
cIdCV8      := ''
cChaveTit   := ''
cFilOrig    := ''
cAliasAtu   := cAlias

//Validar se e criacao de bordero
If cAliasAtu == "SEA"
	If SEA->EA_CART == "R"
		cAliasAtu := "SE1"
	ElseIf SEA->EA_CART == "P"
		cAliasAtu := "SE2"
	EndIf
EndIf

If !Empty(cProcesso) .and. !Empty(cHistorico)
	//Obtenho o ID do título
	//Dados da tabela auxiliar com o código do título a receber
	If cAliasAtu == "SE1"
		cChaveTit := xFilial("SE1") + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" +;
					 SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
		cFilOrig := SE1->E1_FILORIG
	ElseIf cAliasAtu == "SE2"
		cChaveTit := xFilial("SE2") + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM + "|" + SE2->E2_PARCELA + "|" +;
					 SE2->E2_TIPO + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
		cFilOrig := SE2->E2_FILORIG
	EndIf

	If cAliasAtu $ "SE1|SE2"
		cIdDoc := FINGRVFK7(cAliasAtu, cChaveTit)

		//Gravo o log para histórico do título
		ProcLogIni( {}, cIdDoc,   , @cIdCV8 )
		ProcLogAtu( "MENSAGEM", cProcesso, cHistorico, , .T., cFilOrig )
	EndIf
EndIf

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINSEQFK1

Encontra a proxima sequencia para o movto bancario (CR)

@Author	TOTVS
@since	15/09/2015
/*/
//-----------------------------------------------------------------------------------------------------
Function FinSeqFK1()
Local aArea			:= GetArea()
Local cIDFK1		:= ""
Local cChave		:= ""
Local cAliasFK1		:= GetNextAlias()
Local cSequencia	:= ""

//Inicializa Staticas
If nTamSeq == NIL
	nTamSeq		:= TamSX3("FK1_SEQ")[1]
Endif
cSequencia	:= Replicate("0",nTamSeq)

cChave :=	XFilial("SE1")+"|"+SE1->E1_PREFIXO+"|"+SE1->E1_NUM+"|"+SE1->E1_PARCELA+"|"+;
			SE1->E1_TIPO+"|"+SE1->E1_CLIENTE+"|"+SE1->E1_LOJA

cIDFK1 := FINBuscaFK7(cChave, "SE1")

BeginSQL Alias cAliasFK1
	SELECT MAX(FK1_SEQ) FK1_SEQ
	FROM	%Table:FK1% FK1
	WHERE	FK1.FK1_FILIAL = %XFilial:FK1%
			AND FK1.FK1_IDDOC = %Exp:cIDFK1%
			AND FK1.%NotDel%
EndSQL

If !(cAliasFK1)->(Eof())
	cSequencia := Left((cAliasFK1)->FK1_SEQ,nTamSeq) //left incluido para corrigir problema em banco postgres - nao remover
EndIf

(cAliasFK1)->(DbCloseArea())

cSequencia := Soma1(cSequencia,nTamSeq)

RestArea(aArea)

Return cSequencia


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINSEQFK5

Encontra a proxima sequencia para o movto bancario (CR) - Compensação de cheques CR

@Author	TOTVS
@since	15/09/2015
/*/
//-----------------------------------------------------------------------------------------------------
Function FinSeqFK5()
Local aArea			:= GetArea()
Local cAliasFK5		:= GetNextAlias()
Local cSequencia	:= ""

cChave :=	XFilial("SE1")+"|"+SE1->E1_PREFIXO+"|"+SE1->E1_NUM+"|"+SE1->E1_PARCELA+"|"+;
			SE1->E1_TIPO+"|"+SE1->E1_CLIENTE+"|"+SE1->E1_LOJA

cIdDoc := FINBuscaFK7(cChave, "SE1")

//Inicializa Staticas
If nTamSeq == NIL
	nTamSeq		:= TamSX3("FK5_SEQ")[1]
Endif
cSequencia	:= Replicate("0",nTamSeq)

BeginSQL Alias cAliasFK5
	SELECT MAX(FK5_SEQ) FK5_SEQ
	FROM	%Table:FK5% FK5
	WHERE	FK5.FK5_FILIAL = %XFilial:FK5%
			AND FK5.FK5_IDDOC  = %Exp:cIdDoc%
			AND FK5.%NotDel%
EndSQL

If !(cAliasFK5)->(Eof())
	cSequencia := Left((cAliasFK5)->FK5_SEQ,nTamSeq) //left incluido para corrigir problema em banco postgres - nao remover
EndIf

(cAliasFK5)->(DbCloseArea())

cSequencia := Soma1(cSequencia,nTamSeq)

RestArea(aArea)

Return cSequencia



//-------------------------------------------------------------------
/*/{Protheus.doc} IsIssBx
Programa p/ verificar se o Iss está na baixa.

@author TOTVS S/A
@since  08/04/15
/*/
//-------------------------------------------------------------------
Function IsIssBx(cCart)

Local lCalcIssBx := .F.
Default cCart := "P"

If cPaisLoc == "BRA"
	If cCart == "P"
		lCalcIssBx := SuperGetMv("MV_MRETISS",.F.,"1") == "2" //Retencao do ISS pela emissao (1) ou baixa (2)
	EndIf
EndIf

Return lCalcIssBx


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinRetSix
Apresenta uma lista com os índices de uma determinada tabela, permitindo a seleção para o uso, por
exemplo, na indexação de arquivos temporários. A lista é feita a partir do dicionário de dados (SIX).

@param cAlias - Alias do arquivo do qual serão selecionados os índices.
@param aIndices - Array onde serão colocados os índices selecionados (enviar "por referência"). Cada
elemento (array) possui a seguinte estrutura:
ordem do índice, descrição (campo1 + campo2 + ...), expressão do índice, campos que formam o índice (array).
@param cMsg - texto explicativo

@return true - se há índice selecionado; false - não há índice selecinado.

@Author	Marcello Gabriel
@since	29/10/2015
/*/
//-----------------------------------------------------------------------------------------------------
Function FinRetSix(cAlias, aIndices, cMsg, lCancela, nF240Index)
	Local nX			:= 0
	Local aTitulos		:= {}
	Local aChaves		:= {}
	Local aCampos		:= {}
	Local aCposAlias	:= {}
	Local cTitulo		:= ""
	Local cDesc			:= ""
	Local cCampo		:= ""
	Local cCposInd		:= ""
	Local oPnlMaster	:= Nil
	Local oPnlMsg		:= Nil
	Local oDlg			:= Nil
	Local oSize			:= Nil
	Local oBrwSix		:= Nil
	Local oOk 			:= Nil
	Local oNo 			:= Nil
	Local lF240IND		:= ExistBlock("F240IND") .And. FwIsInCallStack('FINA240')
	Local nF240Ind  	:= 0
	Local cIndexSE2		:= ""

	Default aIndices	:= {}
	Default lCancela 	:= .F.
	Default cAlias		:= ""
	Default cMsg		:= STR0075		//"Selecione o(s) índice(s) desejado(s)."
	Default nF240Index	:= 0

	aIndices := {}

	cAlias := AllTrim(cAlias)

	If SIX->(DbSeek(cAlias))
		While !(SIX->(Eof())) .And. SIX->INDICE == cAlias
			aCampos := StrToKArr(SIX->CHAVE,"+")
			aTitulos := StrToKArr(SixDescricao(),"+")
			
			cDesc := ""
			aCposAlias := {}
			cCposInd := ""
			For nX := 1 To Len(aCampos)
				cCampo := FinExtCpo(cAlias,aCampos[nX])
				cCposInd += cCampo + "+"
				If nX > 1
					cDesc += " + "
				Endif
				cTitulo := AllTrim(SX3->(RetTitle(cCampo)))
				If Empty(cTitulo)
					cDesc += AllTrim(aTitulos[nX - 1])
				Else
					cDesc += cTitulo
				Endif
				Aadd(aCposAlias,cCampo)
			Next
			Aadd(aChaves,{.F.,cDesc,Substr(cCposInd,1,Len(cCposInd)-1)/*SIX->CHAVE*/,Aclone(aCposAlias)})
			SIX->(DbSkip())
		Enddo

		oSize := FwDefSize():New(.T.)
		oSize:lLateral := .F.
		oSize:AddObject("MASTER",100,100,.T.,.T.)
		oSize:lProp := .T.
		oSize:Process()

		oOk := LoadBitmap( GetResources(), "LBOK" )
		oNo := LoadBitmap( GetResources(), "LBNO" )
		DEFINE MSDIALOG oDlg TITLE STR0076 From oSize:aWindSize[1]*0.6,oSize:aWindSize[2]*0.6 To oSize:aWindSize[3]*0.6,oSize:aWindSize[4]*0.6 OF oMainWnd PIXEL //"Índices"
			oSize := FwDefSize():New(.T.,,,oDlg)
			oSize:lLateral := .F.
			oSize:AddObject("MENSAGEM",100,15,.T.,.T.)
			oSize:AddObject("MASTER",100,85,.T.,.T.)
			oSize:lProp := .T.
			oSize:Process()

			oPnlMsg := TPanel():New(oSize:GetDimension("MENSAGEM","LININI"),oSize:GetDimension("MENSAGEM","COLINI"),cMsg,oDlg,, .F., .F.,, ,oSize:GetDimension("MENSAGEM","XSIZE"),oSize:GetDimension("MENSAGEM","YSIZE"))

			oPnlMaster := TPanel():New(oSize:GetDimension("MASTER","LININI"),oSize:GetDimension("MASTER","COLINI"),,oDlg,, .T., .T.,, ,oSize:GetDimension("MASTER","XSIZE"),oSize:GetDimension("MASTER","YSIZE"))
				oBrwSix:= TCBrowse():New(0,0,10,10,,,,oPnlMaster,,,,,,,,,,,,,,.T.,,,,.T.,)
					oBrwSix:AddColumn(TCColumn():New("  ",{|| If(aChaves[oBrwSix:nAt,1],oOk,oNo)},,,,,010,.T.,.F.,,,,,))
					oBrwSix:AddColumn(TCColumn():New("Índices",{|| aChaves[oBrwSix:nAt,2]},,,,,040,.F.,.F.,,,,,))
					oBrwSix:Align := CONTROL_ALIGN_ALLCLIENT
					oBrwSix:SetArray(aChaves)
					oBrwSix:bLDblClick := {|| aChaves[oBrwSix:nAT,1] := !aChaves[oBrwSix:nAT,1]}
					oBrwSix:Refresh()
		ACTIVATE DIALOG oDlg ON INIT (EnchoiceBar(oDlg,{|| oDlg:End()},{|| lCancela:= .T. ,oDlg:End()},,,,,.F.,.F.,.F.),oBrwSix:Refresh()) CENTERED
	
		FreeObj(oDlg)
		FreeObj(oBrwSix)
		FreeObj(oSize)
		FreeObj(oPnlMsg)
		FreeObj(oPnlMaster)
		FreeObj(oOk)
		FreeObj(oNo)

		If lF240IND
			nF240Ind := ExecBlock("F240IND", .F., .F., {.F., {}})
			
			If !(FwSIXUtil():ExistIndex("SE2", (RetAsc(nF240Ind, 1, .T.))))
				nF240Ind := 1
			EndIf
			
			cIndexSE2 := SE2->(IndexKey(nF240Ind))

			If (nPosChave := AScan(aChaves, {|chave| AllTrim(chave[3]) == AllTrim(cIndexSE2)})) > 0
				aChaves[nPosChave][1] := .T. //Marca índice para que o mesmo seja adicionado no array aIndices
			EndIf
		EndIf

		For nX := 1 To Len(aChaves)
			If aChaves[nX][1]
				AAdd(aIndices, {nX, aChaves[nX][2], aChaves[nX][3], AClone(aChaves[nX][4])})
			EndIf			
		Next nX

		If lF240IND
			//Busca posição do índice selecionado via PE para ordenação
			nF240Index := AScan(aIndices, {|indice| indice[1] == nF240Ind})
		Endif

		FwFreeArray(aCampos)
		FwFreeArray(aChaves)
		FwFreeArray(aTitulos)
		FwFreeArray(aCposAlias)
	EndIf

Return (Len(aIndices) > 0)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinCposSix
"Quebra" a expressão dos índices de uma tabela nos campos que os formam. Também, baseado em uma array
de campos, verifica se os dos índices estão nessa array e os inclui caso não estejam.

@param cAlias - Alias do arquivo do qual serão selecionados os índices.
@param aOrdem - Array onde serão colocados os índices "quebrados" (enviar "por referência").
Cada elemento (array) possui a seguinte estrutura: descrição (campo1 + campo2 + ...), Campos (array), expressão do índice.
Estutura da array Campos: "" (vazio),tipo do campo,tamanho,decimais,título,picture
@param aCposBase - Array com os campos dos índices "quebrados".
@param cMsg - Texto explicando o uso dos índices.

@return true - se há índice selecionado; false - não há índice selecinado.

@Author	Marcello Gabriel
@since	29/10/2015
/*/
//-----------------------------------------------------------------------------------------------------
Function FinCposSix(cAlias, aOrdem, aCposBase, cMsg, lCancela, lAutomatico, nF240Index)
	Local nCpo		:= 0
	Local nChv		:= 0
	Local aTamSX3	:= {}
	Local aCpos		:= {}
	Local aIndices	:= {}
	Local aArea		:= {}

	Default lCancela 	:= .F.
	Default aCposBase	:= {}
	Default aOrdem		:= {}
	Default cAlias		:= ""
	Default cMsg		:= STR0077 + CRLF + STR0078		//"Selecione os índices que deseja usar na pesquisa para os registros selecionados." ###"Caso nenhum seja selecionado, será considerado o primeiro da lista."
	Default lAutomatico := .F.
	Default nF240Index	:= 0

	If AliasInDic(cAlias)
		aArea := GetArea()
		If !lAutomatico
			FinRetSix(cAlias, @aIndices, cMsg, @lCancela, @nF240Index)
		Endif
		If Empty(aIndices)
			SIX->(DbSeek(cAlias))
			
			Aadd(aIndices,{1,AllTrim(SX3->(RetTitle("E2_FILIAL"))) + "+" + SixDescricao() ,SIX->CHAVE,{}})
			
			aCpos := StrToKArr(SIX->CHAVE,"+")
			For nCpo := 1 To Len(aCpos)
				Aadd(aIndices[1,4],FinExtCpo(cAlias,aCpos[nCpo]))
			Next
			Asize(aCpos,0)
		Endif
		For nChv := 1 To Len(aIndices)
			For nCpo := 1 To Len(aIndices[nChv,4])
				aTamSX3 := TamSX3(aIndices[nChv,4,nCpo])
				Aadd(aCpos,{"",ValType(aIndices[nChv,4,nCpo]),aTamSX3[1],aTamSX3[2],AllTrim(SX3->(RetTitle(aIndices[nChv,4,nCpo]))),X3PICTURE(aIndices[nChv,4,nCpo]),aIndices[nChv,4,nCpo]})
				If Ascan(aCposBase,{|ccpo| AllTrim(ccpo) == Alltrim(aIndices[nChv,4,nCpo])}) == 0
					Aadd(aCposBase,aIndices[nChv,4,nCpo])
				Endif
			Next nCpo
			If !Empty(aCpos)
				Aadd(aOrdem,{aIndices[nChv,2],Aclone(aCpos),aIndices[nChv,3]})
			Endif
			Asize(aCpos,0)
		Next nChv
		RestArea(aArea)
		FwFreeArray(aCpos)
		FwFreeArray(aTamSX3)
		FwFreeArray(aArea)
		FwFreeArray(aIndices)
	Endif

Return(Len(aOrdem) > 0)


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinExtCpo
Verifica se há um campo de uma tabela em um expressão. Caso haja, retorna o primeiro campoa encontrado.

@param cAlias - Alias do arquivo do qual serão verificados os campos.
@param cCampo - expressão que contém o campo

@return cCpo - primeiro campo encontrado; vazio caso não haja campos na expressão.

@Author	Marcello Gabriel
@since	29/10/2015
/*/
//-----------------------------------------------------------------------------------------------------
Function FinExtCpo(cAlias,cCampo)
Local cCpo		:= ""
Local nPos		:= 0
Local cPrefixo	:= ""

cPrefixo := cAlias + "_"
nPos := At(cPrefixo,cCampo)
If nPos == 0
	cPrefixo := Substr(cPrefixo,2)
	nPos := At(cPrefixo,cCampo)
Endif
If nPos > 0
	cCpo := Substr(cCampo,nPos,10)
	nPos := (calias)->(FieldPos(cCpo))
	While nPos == 0 .And. !Empty(cCpo)
		cCpo := AllTrim(Substr(cCpo,1,Len(cCpo) - 1))
		nPos := (calias)->(FieldPos(cCpo))
	Enddo
Endif
Return(cCpo)


//-------------------------------------------------------------------
/*/{Protheus.doc} FINBuscaNF
Função que busca nota fiscal com base nas informações. Utilizado pela nova estrutura do campo Serie.
Retorna o recno da nota para posicionar

@author Alvaro Camillo Neto
@since  03/11/15
/*/
//-------------------------------------------------------------------
Function FINBuscaNF(cFilTit,cDoc,cPrefix,cCliente,cLoja,cTabNF,lPrefix)
Local nRec 	:= 0
Local cQuery	:= ""
Local cTab		:= GetNextAlias()
Local aArea	:= GetArea()

Default cFilTit := cFilAnt
Default lPrefix := .T.

If cTabNF == "SF1"
	cQuery	+= " SELECT R_E_C_N_O_ RECNO " + CRLF
	cQuery	+= " FROM "+RetSQLName("SF1")+" SF1 " + CRLF
	cQuery	+= " WHERE " + CRLF
	cQuery	+= " SF1.F1_FILIAL = '"+xFilial("SF1",cFilTit)+"' AND " + CRLF
	cQuery	+= " SF1.F1_DOC = '"+cDoc+"' AND " + CRLF
	If lPrefix
		cQuery	+= " SF1.F1_PREFIXO = '"+cPrefix+"' AND " + CRLF
	Else
		cQuery	+= SerieNfId('SF1',3,'F1_SERIE') + " = '"+cPrefix+"' AND " + CRLF
	EndIf
	cQuery	+= " SF1.F1_FORNECE = '"+cCliente+"' AND " + CRLF
	cQuery	+= " SF1.F1_LOJA = '"+cLoja+"' AND " + CRLF
	cQuery	+= " SF1.D_E_L_E_T_ = ' ' " + CRLF

ElseIf cTabNF == "SF2"
	cQuery	+= " SELECT R_E_C_N_O_ RECNO " + CRLF
	cQuery	+= " FROM "+RetSQLName("SF2")+" SF2 " + CRLF
	cQuery	+= " WHERE " + CRLF
	cQuery	+= " SF2.F2_FILIAL = '"+xFilial("SF2",cFilTit)+"' AND " + CRLF
	cQuery	+= " SF2.F2_DOC = '"+cDoc+"' AND " + CRLF
	If lPrefix
		cQuery	+= " SF2.F2_PREFIXO = '"+cPrefix+"' AND " + CRLF
	Else
		cQuery	+= SerieNfId('SF2',3,'F2_SERIE') + " = '"+cPrefix+"' AND " + CRLF
	EndIf
	cQuery	+= " SF2.F2_CLIENTE = '"+cCliente+"' AND " + CRLF
	cQuery	+= " SF2.F2_LOJA = '"+cLoja+"' AND " + CRLF
	cQuery	+= " SF2.D_E_L_E_T_ = ' ' " + CRLF
ElseIf cTabNF == "SFE"
	cQuery	+= " SELECT R_E_C_N_O_ RECNO " + CRLF
	cQuery	+= " FROM "+RetSQLName("SFE")+" SFE " + CRLF
	cQuery	+= " WHERE " + CRLF
	cQuery	+= " SFE.FE_FILIAL = '"+xFilial("SFE",cFilTit)+"' AND " + CRLF
	cQuery	+= " SFE.FE_NFISCAL = '"+cDoc+"' AND " + CRLF
	cQuery	+= SerieNfId('SFE',3,'FE_SERIE') + " = '"+cPrefix+"' AND " + CRLF
	cQuery	+= " SFE.FE_FORNECE = '"+cCliente+"' AND " + CRLF
	cQuery	+= " SFE.FE_LOJA = '"+cLoja+"' AND " + CRLF
	cQuery	+= " SFE.D_E_L_E_T_ = ' ' " + CRLF
EndIF

If !Empty(cQuery)
	cQuery := ChangeQuery(cQuery)

	If Select(cTab) > 0
		dbSelectArea(cTab)
		dbCloseArea()
	Endif

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cTab,.T.,.F.)

	If (cTab)->(!EOF())
		nRec := (cTab)->RECNO
	EndIf

	dbSelectArea(cTab)
	dbCloseArea()

EndIf

RestArea(aArea)
Return nRec


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³ADMGTUSFL ºAutor  ³Totvs                  º Data ³  19/11/15   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Define as filiais que o usuário tem permissão.                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ finxfun                                                       º±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ lTodasFil					                                       ³±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function ADMGTUSFL(lTodasFil)

Local cEmpresa 	:= cEmpAnt
Local cTitulo	:= ""
Local MvParDef	:= ""
Local nI 		:= 0
Local aArea 	:= GetArea() 					 // Salva Alias Anterior
Local nReg	    := 0
Local nSit		:= 0
Local aSit		:= {}
Local aFil 		:= {}
Local nTamFil	:= Len(xFilial("CT2"))
Local lDefTop 	:= IIF( FindFunction("IfDefTopCTB"), IfDefTopCTB(), .F.) // verificar se pode executar query (TOPCONN)
Local nInc		:= 0
Local aSM0		:= AdmAbreSM0()
Local aFilAtu	:= {}
Local lFWCodFil := FindFunction( "FWCodFil" )
Local lGestao	:= Iif( lFWCodFil, ( "E" $ FWSM0Layout() .And. "U" $ FWSM0Layout() ), .F. )	// Indica se usa Gestao Corporativa

Default lTodasFil := .F.

If lDefTop
	If !IsBlind()
		PswOrder(1)
		If PswSeek( __cUserID, .T. )

			aSit		:= {}
			aFilNome	:= {}
			aFilAtu		:= FWArrFilAtu( cEmpresa, cFilAnt )
			If Len( aFilAtu ) > 0
				cTxtAux := IIF(lGestao,STR0047,STR0048)//"Empresa/Unidade/Filial de "##"Filiais de "
				cTitulo := cTxtAux + AllTrim( aFilAtu[6] )
			EndIf

			// Adiciona as filiais que o usuario tem permissão
			For nInc := 1 To Len( aSM0 )
				//DEFINES da SMO encontra-se no arquivo FWCommand.CH
				//Na função FWLoadSM0(), ela retorna na posicao [SM0_USEROK] se esta filial é válida para o user
				If (aSM0[nInc][SM0_GRPEMP] == cEmpAnt .And. ((ValType(aSM0[nInc][SM0_EMPOK]) == "L" .And. aSM0[nInc][SM0_EMPOK]) .Or. ValType(aSM0[nInc][SM0_EMPOK]) <> "L") .And. aSM0[nInc][SM0_USEROK] )
					AAdd(aSit, aSM0[nInc][SM0_CODFIL] + " - " +aSM0[nInc][SM0_NOMRED] )
					MvParDef += aSM0[nInc][SM0_CODFIL]
					nI++
				Endif

			Next
			If Len( aSit ) <= 0
				// Se não tem permissão ou ocorreu erro nos dados do usuario, pego a filial corrente.
				Aadd(aSit, aFilAtu[2]+" - "+aFilAtu[7] )
				MvParDef := aFilAtu[2]
				nI++
			EndIf
		EndIf

		aFil := {}
		nSit := 1
		For nReg := 1 To len(mvpardef) Step nTamFil  // Acumula as filiais num vetor
			If SubSTR(mvpardef, nReg, nTamFil) <> Replicate("*",nTamFil)
		 		AADD(aFil, SubSTR(mvpardef, nReg, nTamFil) )
			endif
			nSit++
		next
		If Len(aFil) == Len(aSit)
			lTodasFil := .T.
		EndIf
	Else
		aFil := {cFilAnt}
	EndIf
EndIf

RestArea(aArea)

Return(aFil)

//-------------------------------------------------------------------
/*/{Protheus.doc} GetFlBxSE5
Pesquisa as filiais de baixa de um título
@author Daniel Mendes
@since  08/03/2016
/*/
//-------------------------------------------------------------------
Function GetFlBxSE5( cPrefixo, cNumero, cParcela, cTipo, cCliFor, cLoja, cNatureza, cFilOrig, cCart, nTipo, lRelat )
	Local aArea			:= NIL
	Local aFilsSE5		:= {}
	Local cAliasQry		:= ""
	Local cQueryFK1		:= ""
	Local cQueryFK2		:= ""
	Local cChvFK7		:= Iif(cCart == 'R', xFilial("SE1", cFilOrig), xFilial("SE2", cFilOrig)) + "|" ;
							+ cPrefixo +"|"+ cNumero +"|"+ cParcela +"|"+ cTipo +"|"+ cCliFor +"|"+ cLoja
	Local cFilOld		:= ""

	Default lRelat	:= .F.

	If __cChvFK7 == Nil
		__cChvFK7 	:= ""
	EndIf
	
	If __cChvFK7 != cChvFK7
		cFilOld		:= cFilAnt
		cFilAnt		:= cFilOrig
		__cIdDoc 	:= FINBuscaFK7(cChvFK7, Iif(cCart == 'R', "SE1", "SE2"))
		__cChvFK7 	:= cChvFK7
		cFilAnt		:= cFilOld
	EndIf
	
    // Verifica se já tem um resultado armazenado para a mesma chave 
    IF lRelat .AND. !EMPTY(aGetFlBxSE5) .AND.;
		(aGetFlBxSE5[1] == (cPrefixo+cNumero+cParcela+cTipo+cCliFor+cLoja+cNatureza+cFilOrig+cCart))
		
       aFilsSE5 := ACLONE(aGetFlBxSE5[2])
    ELSE
		aArea  := GetArea()
		
		If lRelat // Qd chamado pelo FINR150 ou FINR130 deve avaliar sem carteria para ter os movimento de compensação
			
			If __oFlBxFK1 == Nil
				cQueryFK1 := " SELECT DISTINCT FK1.FK1_FILIAL AS FILS"
				cQueryFK1 += " FROM " + RetSqlName("FK1") + " FK1"
				cQueryFK1 += " WHERE FK1_IDDOC = ?"
				cQueryFK1 += " AND ( FK1_MOTBX = 'CEC' OR FK1_MOTBX = 'CMP')"
				cQueryFK1 += " AND ( FK1_TPDOC = 'CP' OR FK1_TPDOC = 'BA')"
				cQueryFK1 += " AND FK1_NATURE = ?"
				cQueryFK1 += " AND FK1.D_E_L_E_T_ = ' '"
				
				cQueryFK2 := " SELECT DISTINCT FK2.FK2_FILIAL AS FILS"
				cQueryFK2 += " FROM " + RetSqlName("FK2") + " FK2"
				cQueryFK2 += " WHERE FK2_IDDOC = ?"
				cQueryFK2 += " AND ( FK2_MOTBX = 'CEC' OR FK2_MOTBX = 'CMP')
				cQueryFK2 += " AND ( FK2_TPDOC = 'CP' OR FK2_TPDOC = 'BA')
				cQueryFK2 += " AND FK2_NATURE = ?"
				cQueryFK2 += " AND FK2.D_E_L_E_T_ = ' '"
				
				cQueryFK1 := ChangeQuery(cQueryFK1)
				cQueryFK2 := ChangeQuery(cQueryFK2)
				__oFlBxFK1 := FWPreparedStatement():New(cQueryFK1)
				__oFlBxFK2 := FWPreparedStatement():New(cQueryFK2)
			EndIf

			__oFlBxFK1:SetString(1, __cIdDoc)
			__oFlBxFK1:SetString(2, cNatureza)
			__oFlBxFK2:SetString(1, __cIdDoc)
			__oFlBxFK2:SetString(2, cNatureza)
			
			cQueryFK1 := __oFlBxFK1:GetFixQuery()
			cAliasQry := MpSysOpenQuery(cQueryFK1)

			While !(cAliasQry)->(EoF())
				AAdd(aFilsSE5, (cAliasQry)->FILS)
				(cAliasQry)->(DbSkip())
			EndDo

			(cAliasQry)->(DbCloseArea())

			cQueryFK2 := __oFlBxFK2:GetFixQuery()
			cAliasQry := MpSysOpenQuery(cQueryFK2)

			While !(cAliasQry)->(EoF())
				If (AScan(aFilsSE5, {|filial| filial == (cAliasQry)->FILS})) == 0
					AAdd(aFilsSE5, (cAliasQry)->FILS)
				EndIf
				(cAliasQry)->(DbSkip())
			EndDo
			(cAliasQry)->(DbCloseArea())
		Else
			cAliasQry := GetNextAlias()

			If nTipo == 2 //Compensacao - não avalia carteira devido a Compensação em carteira.
				BeginSql Alias cAliasQry
					SELECT
						DISTINCT FK1.FK1_FILIAL AS FILS
					FROM
						%Table:FK1% FK1
					WHERE
						FK1_IDDOC = %Exp:__cIdDoc%
						AND ( FK1_MOTBX = 'CEC' OR FK1_MOTBX = 'CMP')
						AND ( FK1_TPDOC = 'CP' OR FK1_TPDOC = 'BA')
						AND FK1_NATURE = %Exp:cNatureza%
						AND FK1.%NotDel%
					UNION
					SELECT
						DISTINCT FK2.FK2_FILIAL AS FILS
					FROM
						%Table:FK2% FK2
					WHERE
						FK2_IDDOC = %Exp:__cIdDoc%
						AND ( FK2_MOTBX = 'CEC' OR FK2_MOTBX = 'CMP')
						AND ( FK2_TPDOC = 'CP' OR FK2_TPDOC = 'BA')
						AND FK2_NATURE = %Exp:cNatureza%
						AND FK2.%NotDel%
				EndSql
			Else
				If cCart == "R"
					BeginSql Alias cAliasQry
						SELECT
							DISTINCT FK1.FK1_FILIAL AS FILS
						FROM
							%Table:FK1% FK1
						WHERE
							FK1_IDDOC = %Exp:__cIdDoc%
							AND FK1_NATURE = %Exp:cNatureza%
							AND FK1.%NotDel%
					EndSql
				Else
					BeginSql Alias cAliasQry
						SELECT
							DISTINCT FK2.FK2_FILIAL AS FILS
						FROM
							%Table:FK2% FK2
						WHERE
							FK2_IDDOC = %Exp:__cIdDoc%
							AND FK2_NATURE = %Exp:cNatureza%
							AND FK2.%NotDel%
					EndSql
				EndIf
			EndIf
			While !(cAliasQry)->( Eof() )
				aAdd( aFilsSE5 , (cAliasQry)->FILS )
				(cAliasQry)->( dbSkip() )
			EndDo
			(cAliasQry)->( dbCloseArea() )
		EndIf

		RestArea(aArea)
    ENDIF

	// Guarda o resultado para possivel aproveitamento em novas chamadas com a mesma chave
	IF lRelat
		aGetFlBxSE5 := {cPrefixo+cNumero+cParcela+cTipo+cCliFor+cLoja+cNatureza+cFilOrig+cCart,ACLONE(aFilsSE5)}
	ENDIF
Return aFilsSE5

//-------------------------------------------------------------------
/*/{Protheus.doc} FA181Imune
Zera os valores do IR e IOF para aplicações de empresas Imunes.
@author Rodrigo Oliveira
@since  04/04/2016
/*/
//-------------------------------------------------------------------
Function FA181Imune(nIofAplAtu,nIR,lPerg)

Local cImune			:= SuperGetMv("MV_APLIMUN",,"1")

If Type("lPergAplIm") == "U"
	lPergAplIm	:= .F.
EndIf

If cImune == "3" .And. (lPerg # Nil .And. lPerg)
	lPergAplIm	:= MsgYesNo(STR0080,STR0081) // "Esta aplicação é Imune de IR e IOF?" ### "Aplic. Imune"
EndIf

If cImune == "2" .Or. lPergAplIm
	nIR	:= nIofAplAtu := 0
EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc}ValParFin
Valida o conteudo dos parametros MV_INSS, MV_ISS, MV_IRF

@param X6_CONTEUD- conteudo em portugues
@param 	X6_CONTSPA- conteudo em espanhol
@param X6_CONTENG- conteudo em ingles

@return lRet - Retorna .T. se conteudo estiver correto

@author Karen Honda
@since  27/06/2016
/*/
//-------------------------------------------------------------------

Function ValParFin(cExpPor,cExpSpa,cExpEng)
Local lRet := .T.

cExpPor := Alltrim(cExpPor)
cExpSpa := Alltrim(cExpSpa)
cExpEng := Alltrim(cExpEng)

If !Empty(cExpPor)
	If Type(cExpPor) == "U"
		Alert(STR0082)//"Conteúdo deve conter aspas!"
		lRet := .F.
	EndIf
EndIf

If lRet .and. !Empty(cExpSpa)
	If Type(cExpSpa) == "U"
		Alert(STR0083)//"Conteúdo em espanhol deve conter aspas!"
		lRet := .F.
	EndIf
EndIf

If lRet .and. !Empty(cExpEng)
	If Type(cExpEng) == "U"
		Alert(STR0084)//"Conteúdo em inglês deve conter aspas!"
		lRet := .F.
	EndIf
EndIf
Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SumRetRec
Retorna os valores retidos na baixa de um determinado título

@Author	Totvs
@since	29/07/2016
/*/
//-----------------------------------------------------------------------------------------------------
Function SumRetRec(cPrefixo,cNumero,cParcela,cTipo,cCli, cLj,nMoeda,nTotImp,nTotIrrf,nTotCsll,nTotPis,nTotCof,nTxMoeda,dDtDe,dDtAte)
Local lIrrfBxPj 	:= .F.
Local lPccBxCr		:= FPccBxCr(.T.)
Local aBaixa		:= {}
Local nx			:= 0

Default cPrefixo	:= ""
Default cNumero		:= ""
DEFAULT	cParcela	:= ""
Default cTipo		:= ""
Default cCli 		:= ""
Default cLj			:= ""
Default nMoeda		:= 0
Default nTotImp 	:= 0
Default nTotIrrf 	:= 0
Default nTotCsll 	:= 0
Default nTotPis		:= 0
Default nTotCof		:= 0
Default nTxMoeda  	:= 0
Default dDtDe		:= dDataBase
Default dDtAte		:= dDataBase

Private aBaixaSE5 	:= {}

dbSelectArea("SA1")
SA1->(MsSeek(xFilial("SA1")+cCli+cLj))

lIrrfBxPj 	:= IIf(FindFunction("FIrPjBxCr"),FIrPjBxCr(.T.),.F.)


If SE1->E1_CLIENTE+SE1->E1_LOJA == cCli+cLj
	aBaixa := Sel070Baixa( "VL /V2 /BA /RA /CP /LJ /" + MV_CRNEG, cPrefixo, cNumero, cParcela, cTipo,,, cCli, cLj,,,,,,)
	For nx := 1 To Len(aBaixaSE5)
		If aBaixaSE5[nx][7] >= dDtDe .AND. aBaixaSE5[nx][7] <= dDtAte
			If lPccBxCr
				//CSLL
				nTotCsll 	+= xMoeda(aBaixaSE5[nx][20] ,VAL(aBaixaSE5[nx][24]), nMoeda,aBaixaSE5[nx][7],,,nTxMoeda)
				nTotImp 	+= xMoeda(aBaixaSE5[nx][20] ,VAL(aBaixaSE5[nx][24]), nMoeda,aBaixaSE5[nx][7],,,nTxMoeda)
				//PIS
				nTotPis 	+= xMoeda(aBaixaSE5[nx][18] ,VAL(aBaixaSE5[nx][24]), nMoeda,aBaixaSE5[nx][7],,,nTxMoeda)
				//nTotImp 	+= xMoeda(aBaixaSE5[nx][18] ,VAL(aBaixaSE5[nx][24]), nMoeda,aBaixaSE5[nx][7],,,nTxMoeda)
				//COFINS
				nTotCof 	+= xMoeda(aBaixaSE5[nx][19] ,VAL(aBaixaSE5[nx][24]), nMoeda,aBaixaSE5[nx][7],,,nTxMoeda)
				//nTotImp 	+= xMoeda(aBaixaSE5[nx][19] ,VAL(aBaixaSE5[nx][24]), nMoeda,aBaixaSE5[nx][7],,,nTxMoeda)
			EndIf
			If lIrrfBxPj
				//IRRF
				nTotIrrf 	+= xMoeda(aBaixaSE5[nx][30] ,VAL(aBaixaSE5[nx][24]), nMoeda,aBaixaSE5[nx][7],,,nTxMoeda)
				nTotImp 	+= xMoeda(aBaixaSE5[nx][30] ,VAL(aBaixaSE5[nx][24]), nMoeda,aBaixaSE5[nx][7],,,nTxMoeda)

			EndIf
		EndIf
	Next
EndIf

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FDelQuery
Destroy o objeto criado na FinSeqSe5()

@Author	Mauricio Pequim Jr
@since	02/01/2017
/*/
//-----------------------------------------------------------------------------------------------------
Function FDelQuery( lGetFlBx )

Default lGetFlBx := .F.

If oPrepared != NIL
	oPrepared:Destroy()
	oPrepared := NIL
Endif

If lGetFlBx
	If __oFlBxFK1 != Nil
		__oFlBxFK1:Destroy()
		__oFlBxFK1 := Nil
		__oFlBxFK2:Destroy()
		__oFlBxFK1 := Nil
		FWFreeArray(aGetFlBxSE5)
		aGetFlBxSE5 := {}
	EndIf
EndIf

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FilsUsr
Retorna uma string com as filiais de acesso do operador

@Parâm.    	FlIni = Filial de (par. MV) FlFim = Filial Até (par. MV)
			cFils = String com filiais autorizadas
@Retorno   	lRet  = se .T., usuario acessa todas as filiais do range
@Author	Rodrigo Oliveira
@since	06/04/2017
/*/
//-----------------------------------------------------------------------------------------------------
Function FilsUsr(FlIni, FlFim, cFils)

Local aSM0		:= FwAllFilial()
Local lAdmUsFl	:= FindFunction("ADMGTUSFL")
Local nQtde		:= 0
Local nQtdUsr	:= 0
Local lRet		:= .T.
Local nI		:= 0
Local aFlUsr	:= {}

nQtde	:= ContaFil(FlIni, FlFim, aSM0, aFlUsr)

If lAdmUsFl
	aFlUsr 	:= ADMGTUSFL()
	nQtdUsr := ContaFil(FlIni, FlFim, aSm0, aFlUsr)
EndIf

If nQtde > nQtdUsr
	lRet := .F.
	For nI := 1 to Len(aFlUsr)
		cFils += "'" + aFlUsr[nI] + Iif(nI == Len(aFlUsr), "'", "',")
	Next
EndIf

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ContaFil
Retorna o total de filiais que o operador tem acesso

@Parâm.    	FlIni = Filial de (par. MV) FlFim = Filial Até (par. MV)
			aSM0 = array contendo o Sigamat
@Retorno   	nTotal  = Total de filiais encontradas
@Author	Rodrigo Oliveira
@since	06/04/2017
/*/
//-----------------------------------------------------------------------------------------------------
Static Function ContaFil(FlIni, FlFim, aSM0, aFlUsr)

Local nPosIni	:= 0
Local nPosFim	:= 0
Local nTotal	:= 0
Local nI		:= 0
Local aFlUsr1	:= {}

If Len(aFlUsr) > 0
	If ( aFlUsr[1] < FlIni .Or. aFlUsr[Len(aFlUsr)] > FlFim )
		For nI := 1 to Len(aFlUsr)
			If  aFlUsr[nI] >= FlIni .And. aFlUsr[nI] <= FlFim
				aAdd(aFlUsr1,aFlUsr[nI])
			EndIf
		Next
		aFlUsr := aClone(aFlUsr1)
		nTotal	:= Len(aFlUsr)
	Else
		nTotal	:= Len(aFlUsr)
	EndIf
Else
	If Empty(Alltrim(FlIni))
		FlIni	:= aSM0[1]
		nPosIni := 1
	Else
		nPosIni	:= aScan(aSM0,{|x| x == FlIni})
	EndIf

	If "ZZ" $ UPPER(FlFim)
		FlFim	:= aSM0[Len(aSm0)]
		nPosFim := Len(aSm0)
	Else
		nPosFim	:= aScan(aSM0,{|x| x == FlFim})
	EndIf

	nTotal := (nPosFim + 1) - nPosIni
EndIf

Return nTotal

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} GetFKDCOD
Função responsavel por verificar se o codigo do valor acessorio digitado esta correto e se esta ativo
@type function
@author jose.aribeiro
@since 27/09/2016
@version 1.0
@param cCod , caracter, Codigo do valor acessorio para ser validado
@return lRet, logico  , .T. para encontrado e ativo e .F. para nao encontradoou nao validado
/*/
//-----------------------------------------------------------------------------------------------------
Function GetFKDCOD(cCod)
Local lRet := .T.

	DbSelectArea("FKC")
	FKC->(DbSetOrder(1))
	If(FKC->(DbSeek(xFilial("FKC")+cCod)))
		If(FKC->FKC_ATIVO == "2")

			lRet := .F.
			Help(" ",1,"GETFKDCOD",,STR0085, 1, 0 ) //O Codigo de valor acessorio informado, esta bloqueado , Verifique

		EndIf
	Else

		lRet := .F.
		Help(" ",1,"GETFKDCOD",,STR0086, 1, 0 ) //O Codigo de valor acessorio informado, não foi encontrado , Verifique

	EndIf
Return lRet

//-------------------------------------------------------------------
/*{Protheus.doc} TTFtIndex
Formata indice que possui campo numerico/data
obs: necessario para classe FWTemporaryTable, metodo AddIndex
@author Igor Sousa do Nascimento
@version 12.1.17
@since   31/10/2017
*/
//-------------------------------------------------------------------
Function TTFtIndex(aFields) As Array

	Local nX   	  As Numeric
	Local nAt  	  As Numeric

	Default aFields := {}

	For nX := 1 to Len(aFields)
		If "DTOS" $ aFields[nX] 	  // Verifica se existe conversao de campo data (DTOS)
			// Remove funcao de conversao
			aFields[nX] := StrTran(aFields[nX],"DTOS","")
			// Remove parenteses
			aFields[nX] := StrTran(aFields[nX],"(","")
			aFields[nX] := StrTran(aFields[nX],")","")
		ElseIf "STR" $ aFields[nX]	  // Verifica se existe conversao de campo numerico (STR)
			// Remove funcao de conversao
			aFields[nX] := StrTran(aFields[nX],"STR","")
			// Remove parenteses
			aFields[nX] := StrTran(aFields[nX],"(","")
			nAt := At(",",aFields[nX])
			If nAt > 0	// Ignora virgula e parametros da funcao STR
				aFields[nX] := SubStr(aFields[nX],1,nAt-1)
			Else		// Caso nao encontre parametros, remove parentese
				aFields[nX] := StrTran(aFields[nX],")","")
			EndIf
		EndIf
	Next nX

Return aFields

//-------------------------------------------------------------------
/*{Protheus.doc} TTGetStru

Retorna string dos campos de determinada estrutura de tabela(SX2).
obs: necessario para classe FWTemporaryTable, metodo SetFields

@param aStruct - Estrutura da tabela (Array referencia)
@param cAlias - Alias da Tabela
@param cSepara - Caractere separador

@return cFields - String com a estrutura dos campos.
@author Leonardo Castro
@version 12.1.17
@since   04/04/2018
*/
//-------------------------------------------------------------------
Function TTGetStru(aStruct As Array, cAlias As Character, cSepara As Character) As Character

	Local aAux As Array
	Local cFields As Character
	Local nX As Numeric

	Default cAlias := Alias()
	Default aStruct := {}
	Default cSepara := ","

	aAux := Array(0)
	cFields := ""
	aStruct := If(Empty(aStruct),&(cAlias)->(DbStruct()),aStruct)

	For nX := 1 To Len(aStruct)

		// Remove da estrutura campos do tipo MEMO
		If aStruct[nX,2] != "M"

			/*
			-----------------------------------------------------------
			Estrutura Montada
			aStruct = Array contendo os campos da estrutura
			cFields = String dos campos concatenados por separador
			-----------------------------------------------------------
			*/
			aAdd(aAux,aStruct[nX])
			cFields += IF(nX == 1, aStruct[nX,1], cSepara + aStruct[nX,1])

		EndIf

	Next nX

	aStruct := aClone(aAux)

Return cFields


//------------------------------------------------------------------------
/*/{Protheus.doc}Fr381Rel
Programa para retornar a filial completa para trocar o conteudo da variavel
cFilAnt.
Quando a filial está compartilhada e realizavam a troca do conteudo da cFilAnt
usando os campos E2_FILIAL ou E5_FILIAL ocorriam erros de validação em tabelas
onde a filial não é compartilhada.
@author	Rodrigo Pirolo
@since		23/11/2017
@version	12
@param		cTabela	-	Tabela para a qual os modos de acessos serão feitos
@param		aLayoutGC	-	Array contendo o retorno da função FWLoadSM0()
@param		cFil		-	Filial que deverá ser pesquizada para retornar
@param						a filial completa
/*/
//------------------------------------------------------------------------

Function FXRetFil( cTabela, cFil, lComple )

Local aModAc	:= {}
Local aLayoutGC	:= {}

Local nPosGC	:= 0

Local cFilRet	:= SE2->E2_FILORIG

Local lTudoExc	:= .F.
Local lFilComp	:= .F.
Local lUNFilCom	:= .F.
Local lTudoCom	:= .F.
Default cTabela	:= "SE2"
Default cFil	:= SE2->E2_FILORIG
Default lComple	:= .T.

If ( "E" $ FWSM0Layout() .OR. "U" $ FWSM0Layout() .OR. "F" $ FWSM0Layout() )

	aLayoutGC	:= FWLoadSM0()

	AAdd( aModAc, FWModeAccess( cTabela, 1 ) )
	AAdd( aModAc, FWModeAccess( cTabela, 2 ) )
	AAdd( aModAc, FWModeAccess( cTabela, 3 ) )

	If aModAc[1] == "E" .AND. aModAc[2] == "E" .AND. aModAc[3] == "C"
		lFilComp := .T.
	ElseIf aModAc[1] == "E" .AND. aModAc[2] == "E" .AND. aModAc[3] == "E"
		lTudoExc := .T.
	ElseIf aModAc[1] == "E" .AND. aModAc[2] == "C" .AND. aModAc[3] == "C"
		lUNFilCom := .T.
	ElseIf aModAc[1] == "C" .AND. aModAc[2] == "C" .AND. aModAc[3] == "C"
		lTudoCom := .T.
	EndIf

	If lTudoExc .OR. lTudoCom
		nPosGC := Ascan( aLayoutGC,{ |x| x[2] == cFil } )
	ElseIf lFilComp
		nPosGC := Ascan( aLayoutGC,{ |x| x[3] + x[4] == Left(cFil, Len(x[3] + x[4] ) ) } )
	ElseIf lUNFilCom
		nPosGC := Ascan( aLayoutGC,{ |x| x[3] == Left(cFil, Len(x[3]) ) } )
	EndIf

	If lComple
		If nPosGC > 0
			cFilRet := aLayoutGC[nPosGC][2]
		EndIf
	Else
		If nPosGC > 0
			If lTudoCom
				cFilRet := xFilial( cTabela, aLayoutGC[nPosGC][2] ) //empresa
			Else
				cFilRet := aLayoutGC[nPosGC][3] //empresa
				If lTudoExc
					cFilRet += aLayoutGC[nPosGC][4] //unidade de negócio
					cFilRet += aLayoutGC[nPosGC][5] //filial
				ElseIf lFilComp
					cFilRet += aLayoutGC[nPosGC][4] //unidade de negócio
					cFilRet += Space( Len( aLayoutGC[nPosGC][5] ) ) //filial
				ElseIf lUNFilCom
					cFilRet += Space( Len( aLayoutGC[nPosGC][4] ) ) //unidade de negócio
					cFilRet += Space( Len( aLayoutGC[nPosGC][5] ) ) //filial
				EndIf
			EndIf
		EndIf
	EndIf
Else
	cFilRet := cFil
EndIf

Return cFilRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FINRDME
Motivo de Baixa Financeiro (Esta função retorno os motivos de baixa que sejam do tipo ESPECIE)

@author francisco.carmo
@since 09/03/2018
@version 12.1.20
/*/
//-------------------------------------------------------------------
Function MotBxEsp() As Array

	Local cBuffer	As Character
	Local aMotBx	As Array
	Local cFile		As Character
	Local nHdl		As Numeric

	cBuffer	:= ""
	aMotBx	:= {}
	cFile	:= "SIGAADV.MOT"
	nHdl	:= 0

	If File(cFile)

		nHdl := fOpen(cFile)

		FT_FUSE(cFile)
		FT_FGOTOP()
		ProcRegua(FT_FLASTREC())

		While !FT_FEOF()
			IncProc()
			cBuffer := FT_FREADLN()
			If SubStr(cBuffer,18,1) == "S" .And. SubStr(cBuffer,14,1) $ "AR"
				aADD(aMotBx, {SubStr(cBuffer,1,3), SubStr(cBuffer,4,10), SubStr(cBuffer,18,1) })
			Endif
			FT_FSKIP()
		EndDo

		fClose(nHdl)
		FT_FUSE()

	Endif

Return aMotBx

//-------------------------------------------------------------------
/*/{Protheus.doc} MovMoedEs
Verifica se o movimentos de fatura, compensação e liquidação ocorreu
em moeda estrangeira, para efeito de visualização nas consultas e relatórios

@author Sivaldo Oliveira
@since 06/04/2018
@version P12
/*/
//-------------------------------------------------------------------
Function MovMoedEs(cMoeda As Character, cTipoDoc As Character, cMotBx As Character, cDtMov As Character, cCart As Character) As Logical

Local lRet As Logical
Local nMoeda As Numeric

Default cMoeda   := "1"
Default cTipoDoc := ""
Default cMotBx   := ""
Default cDtMov   := DTOS(DATE())
Default cCart    := "P"

// Inicializa variáveis.
lRet := .F.
nMoeda := Val(cValToChar(cMoeda))

If cMotBx $ "LIQ|FAT|CMP" .And. nMoeda > 1 .And. !Empty(cTipoDoc) .And. !Empty(cMotBx)
	cTipoDoc := AllTrim(cTipoDoc)
	cMotBx   := AllTrim(cMotBx)
	cCart    := AllTrim(cCart)

	// A partir destas datas foram alteradas as gravações dos movimentos (E5_VALOR e E5_VLMOED2) em moeda estrangeira
	// dos processos de fatura, liquidação e compensação CP
	If cCart == "P"
		lRet := ((cDtMov >= "20180413") .Or. (cDtMov >= "20171227" .And. cTipoDoc $ "ES|CP" .And. cMotBx == "CMP"))
	Else
		lRet := (cDtMov >= "20181129" .And. cTipoDoc $ "BA|CP|ES" .And. cMotBx == "CMP")
	Endif

	If lRet
		If cTipoDoc $ "CP|BA|ES" .And. cMotBx == "CMP"
			// Compensação
			lRet := .T.
		ElseIf cTipoDoc $ "BA|ES" .And. cMotBx $ "LIQ|FAT"
			// Liquidação ou fatura.
			lRet := .T.
		Else
			lRet := .F.
		EndIf
	EndIf
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} HelpSX1

Busca o help das perguntas (SX1) no arquivo de Help da System

@author Fabio Casagrande Lima
@since  17/04/2018
@param	cGrupo - Grupo de pergunta a ser pesquisado (X1_GRUPO)
@param	cOrdem - Ordem da pergunta a ser pesquisada (X1_ORDEM)
/*/
//-------------------------------------------------------------------

Function HelpSX1(cGrupo As Character, cOrdem As Character) As Character

	Local cRet     As Character
	Local cChave   As Character
	Local cChaveP  As Character
	Local cChave1  As Character
	Local cChave2  As Character
	Local cChave3  As Character
	Local cHelp	   As Character
	Local cLine    As Character
	Local lError   As Logical
	Local ni	   As Numeric
	Local aHelp	   As Array

	Default cGrupo := ""

	cGrupo 	   := PadR(cGrupo, Len(SX1->X1_GRUPO), " ") //Adiciona espaços a direita para utilização no DbSeek
	cRet       := ""
	cChave     := "." + AllTrim(cGrupo) + AllTrim(cOrdem) + "."  //Define o nome da pergunta
	cChaveP    := ''
	cChave1	   := ''
	cChave2	   := ''
	cChave3	   := ''
	cHelp	   := ''
	lError	   := .F.
	aHelp	   := {}
	cLine      := ""

	If __lDicInDB	== NIL
		__lDicInDB := MPDicInDb()
	Endif

	If !__lDicInDB
		cChave := "P" + cChave
	Endif

	DbSelectArea('SX1')
	SX1->(DbSetOrder(1)) // Grupo + Ordem
	If SX1->(DbSeek(cGrupo + cOrdem))
		aHelp := FWReadHelp( RetHlpFile(), cChave, /*cMensagem*/, /*nLinha1*/, /*nColuna*/, /*lSubHelp*/, /*lSoluc*/, .T./*l40Col*/ )
	Endif

	For ni := 1 to Len(aHelp)
		cRet += aHelp[ni]
	Next

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FinSelFil(nRecno)
Retorna filtro dos campos e2_filial ou e2_filorig

@param aFil - Vetor com as filiais a serem consideradas na seleção dos títulos a serem liquidados
@param cAlias - Alias da tabela 
@param lFilOrig - Indica se o filtro sera pelo T - FILORIG ou F- FILIAL
@param lCriaTmp - .T. indica se cria a tabela temporaria se o limite de filiais ultrapassar nLimTmp, .F. não cria a tabela temporaria
@param nLimTmp - Quantidade limite de filias, para montar a temporaria
@Return cRet - condição dos campos e2_filial ou e2_filorig

@author Sivaldo Oliveira
@since 25/04/2018
@version P12
/*/
//-------------------------------------------------------------------
Function FinSelFil(aFil As Array, cAlias As Character, lFilOrig As Logical, lCriaTmp As Logical,nLimTmp As Numeric) As Character
	Local cRet As Character
	Local nY As Numeric
	Local nAfil As Numeric
	Local cCampoFil As Character
	Local cCampoFilO As Character
	Local nTamFil As Numeric
	Local cTmpFil As Character
	Local cTable As Character
	Local cInsert As Character
	Local nX As Numeric
	Local cAtualxFil As Character
	Local aStruTmp As Array
	Local oTmpFil as Object
	Local lTotComp as Logical

	Default aFil := {}
	Default cAlias := "SE2"
	Default nLimTmp := 50
	Default lFilOrig := .T.
	Default lCriaTmp := .F.


	//Inicializa variáveis.
	cRet := ""
	nY := 0
	nAfil := Len(aFil)
	oTmpFil := NIL
	lTotComp := (len(allTrim(xFilial(cAlias, if(nAfil>0, aFil[1], NIL)))) == 0)


	If cAlias == "SE1"
		cCampoFil := "E1_FILIAL"
		cCampoFilO := "E1_FILORIG"
	ElseIf cAlias == "SE5"
		cCampoFil := "E5_FILIAL"
		cCampoFilO := "E5_FILORIG"
	ElseIf cAlias == "FK4"
		cCampoFil := "FK4_FILIAL"
		cCampoFilO := "FK4_FILORI"
	ElseIf cAlias == "SE2"
		cCampoFil := "E2_FILIAL"
		cCampoFilO := "E2_FILORIG"
	Else 	
		cCampoFil := ""
		cCampoFilO := ""
	EndIf
	
	If lTotComp
		return cCampoFil + " = " + "'" + xFilial(cAlias, if(nAfil>0, aFil[1], NIL)) + "' "
	EndIf

	If nAfil <= nLimTmp .or. !lCriaTmp
		If nAfil > 1 
			cRet := Iif(lFilOrig, cCampoFilO,cCampoFil) + " IN ('" + Iif(lFilOrig, aFil[1], xFilial(cAlias,aFil[1]) ) + "'"

			For nY := 2 To nAfil
				cRet += ", '" + Iif(lFilOrig, aFil[nY], xFilial(cAlias,aFil[nY]) ) + "'"
			Next nY

			cRet += ") "
		ElseIf nAfil == 1
			cRet := IIf(lFilOrig, cCampoFilO + " = '" + aFil[1], cCampoFil + " = '" + xFilial(cAlias, aFil[1])) + "' "
		Else
			cRet := IIf(lFilOrig, cCampoFilO + " = '" + cFilAnt, cCampoFil + " = '" + xFilial(cAlias)) + "' "
		EndIf
	Else	
		cTmpFil := GetNextAlias()
		nTamFil = CtbTamSXG("033",2)
		cTable := ""
		aStruTmp := {}

		If len(__aTmpFils) > 9
			__aTmpFils[1]:delete()
			ADel(__aTmpFils,1)
			ASize(__aTmpFils, len(__aTmpFils)-1)
		EndIf

		aAdd( aStruTmp, {'TMPFIL','C',nTamFil,0} )
			
		oTmpFil := FwTemporaryTable():New( cTmpFil )
		oTmpFil:SetFields( aStruTmp )
		oTmpFil:AddIndex( '01', {'TMPFIL'} )
		oTmpFil:Create()
		aAdd(__aTmpFils, oTmpFil)
			
		cTable	:= oTmpFil:GetRealName()
			 
		cInsert := " INSERT INTO " + cTable  + "  (TMPFIL)  "
		For nX := 1 to Len(aFil)
			cAtualxFil := Iif(lFilOrig, aFil[nX], xFilial(cAlias,aFil[nX]) ) 
			cInsertValue := " VALUES ('" + cAtualxFil + "')  "
			TcSqlExec( cInsert + cInsertValue)
		Next nX                      

		( cTmpFil )->(DbGoTop())

		If Upper(TcGetDb()) $ "MSSQL7"
			cTable := StrTran (cTable,'dbo.') 
		EndIf

		cRet := Iif(lFilOrig, cCampoFilO,cCampoFil) + " IN (SELECT TMPFIL FROM " + cTable + ")"
	EndIf	
Return cRet
//-------------------------------------------------------------------
/*/{Protheus.doc} FinEraseTmpFil()
Limpa o objeto da temporaria da selecao de filiais, criado na funcao FinSelFil()

@author Karen Honda
@since 16/09/2020
@version P12
/*/
//-------------------------------------------------------------------
Function FinEraseTmpFil() As Character
	Local nX as Numeric
	nX := 1

	For nX := 1 to len(__aTmpFils)
		if __aTmpFils[nX] != NIL
			__aTmpFils[nX]:delete()
			FreeObj(__aTmpFils[nX])
		EndIf
	Next nX

	FWFreeArray(__aTmpFils)
	__aTmpFils := {}
Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} TXSeek

Posiciona em um titulo de imposto (TX) especifico baseado na natureza

@param cNatImp: Natureza do TX
@param cChave: Chave do titulo pai
@param lDelStmt: Indica se o objeto statement sera deletado
		(obrigatorio mandar .T. quando nao for chamar esta funcao novamente)

@Author	Igor Sousa do Nascimento
@since	08/05/2018
/*/
//-----------------------------------------------------------------------------------------------------
Function TXSeek(cNatImp,cChave,lDelStmt)

	Local cAlias	 := Alias()
	Local cQry		 := ""
	Local nRecnoTX	 := 0
	Local lRet		 := .F.
	Default cNatImp  := ""
	Default cChave   := SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
	Default lDelStmt := .F.

	If !Empty(cNatImp) .and. !Empty(cChave)
		If __oTXSeek == Nil
			cQry := "SELECT SE2.R_E_C_N_O_ RECNO "
			cQry += "FROM " + RetSqlName("SE2") + " SE2 "
			cQry += "WHERE SE2.E2_FILIAL = ? AND "
			cQry += "SE2.E2_TITPAI = ? AND "
			cQry += "SE2.E2_NATUREZ = ? AND "
			cQry += "SE2.E2_TIPO IN " + FormatIn( MVISS +"|"+ MVTAXA +"|"+ MVTXA +"|"+ MVINSS +"|"+ 'SES' +"|"+ 'CID' + "|"+ 'INA', "|") + " AND "
			cQry += "SE2.D_E_L_E_T_ = ' ' "
			cQry := ChangeQuery(cQry)

			__oTXSeek:=FWPreparedStatement():New(cQry)
		EndIf

		__oTXSeek:SetString(1,xFilial("SE2"))
		__oTXSeek:SetString(2,cChave)
		__oTXSeek:SetString(3,cNatImp)

		cQry 	 := __oTXSeek:GetFixQuery()
		nRecnoTX := MpSysExecScalar(cQry,"RECNO")

		If nRecnoTX > 0
			dbSelectArea("SE2")
			dbGoTo(nRecnoTX)
			lRet := .T.
		EndIf
		dbSelectArea(cAlias)
	EndIf

	If lDelStmt .and. __oTXSeek <> Nil
		__oTXSeek:Destroy()
		__oTXSeek:= Nil
	EndIf

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ISSCPOM

Verifica se o municipio exige CPOM e se havera bitributacao do ISS

@param cTpEnt: Tipo da entidade, P - Prestador, T - Tomador
@param cEnt: Fornecedor ou Cliente + Loja
@param cCodServ: Codigo do tipo de servico (SX5)
@return aRet: Vetor com UF, municipio, aliquota, vlr.min e cod.munic
@author	Igor Sousa do Nascimento
@since	16/10/2018
/*/
//-----------------------------------------------------------------------------------------------------
Function ISSCPOM(cTpEnt,cEnt,cCodServ)

	Local aArea		:= GetArea()
	Local aRet		:= {}
	Local cMunSM0 := Iif(Len(Alltrim(SM0->M0_CODMUN))==5, Alltrim(SM0->M0_CODMUN), Substr(Alltrim(SM0->M0_CODMUN),3,5))
	Local lVerCPOM	:= .F.
	Local lCC2VlMin := CC2->(ColumnPos("CC2_ISSMIN")) > 0

	Default cTpEnt  := ""
	Default cEnt 	:= ""
	Default cCodServ:= ""

	If cTpEnt == "T"	// Tomador de Servicos - CP
		dbSelectArea("SA2")
		dbSetOrder(1)
		If dbSeek(xFilial("SA2")+cEnt)
			lVerCPOM := Upper(AllTrim(cMunSM0)) <> Upper(AllTrim(SA2->A2_COD_MUN))
			cMunSM0  := AllTrim(SA2->A2_COD_MUN)
		EndIf
	ElseIf cTpEnt == "P"	// Prestador de Servicos - CR
		dbSelectArea("SA1")
		dbSetOrder(1)
		If dbSeek(xFilial("SA1")+cEnt)
			lVerCPOM := Upper(AllTrim(cMunSM0)) <> Upper(AllTrim(SA1->A1_COD_MUN))
			cMunSM0  := AllTrim(SA1->A1_COD_MUN)
		EndIf
	EndIf

	If lVerCPOM
		dbSelectArea("CLI")
		dbSetOrder(1)
		If cTpEnt == "T"
			If dbSeek(xFilial("CLI")+"1"+cCodServ+SA2->A2_EST+cMunSM0+cEnt)
				dbSelectArea("CE1")
				dbSetOrder(1)
				If dbSeek(xFilial("CE1")+CLI->CLI_CODISS+CLI->CLI_UF+CLI->CLI_CODMUN)
					If CE1->CE1_RETISS == "1"
						aAdd(aRet,CE1->CE1_ESTISS)
						aAdd(aRet,CE1->CE1_MUNISS)
						aAdd(aRet,CE1->CE1_ALQISS)
						If lCC2VlMin
							dbSelectArea("CC2")
							dbSetOrder(1)
							If dbSeek(xFilial("CC2")+SA2->A2_EST+cMunSM0)
								aAdd(aRet,CC2->CC2_ISSMIN)
							EndIf
						EndIf
						aAdd(aRet,cMunSM0)
					EndIf
				EndIf
			EndIf
		ElseIf cTpEnt == "P"
			If dbSeek(xFilial("CLI")+"2"+cCodServ+SA1->A1_EST+cMunSM0)
				dbSelectArea("CE1")
				dbSetOrder(1)
				If dbSeek(xFilial("CE1")+CLI->CLI_CODISS+CLI->CLI_UF+CLI->CLI_CODMUN)
					If CE1->CE1_RETISS == "1"
						aAdd(aRet,CE1->CE1_ESTISS)
						aAdd(aRet,CE1->CE1_MUNISS)
						aAdd(aRet,CE1->CE1_ALQISS)
						If lCC2VlMin
							dbSelectArea("CC2")
							dbSetOrder(1)
							If dbSeek(xFilial("CC2")+SA1->A1_EST+cMunSM0)
								aAdd(aRet,CC2->CC2_ISSMIN)
							EndIf
						EndIf
						aAdd(aRet,cMunSM0)
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	RestArea(aArea)

Return aRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} BtrISSMun
Função para buscar o fornecedor e loja para pagamento do ISS, conforme
código de serviço, estado e munícipio cadastrado nas alíquotas do ISS

@author caio.martins
@since 26/10/2018
@type function

@param cCodISS, characters, Código de serviço do ISS
@param cEstado, characters, Código do estado ao qual pertence o município
@param cMunicipio, characters, Código do municcío ao qual se aplica a alíquota

@return aRet, Vetor com as informações do fornecedor para pagamento do ISS bitributado
@sample aRet[1] = Código do Fornecedor
		aRet[2] = Loja do Fornecedot
/*/
//-----------------------------------------------------------------------------------------------------
Function BtrISSMun( cCodISS, cEstado, cMunicipio )
	Local aRet := {}
	Local aAreaCE1 := CE1->( GetArea() )
	
	Default cCodISS := ""
	Default cEstado := ""
	Default cMunicipio := ""

	CE1->( dbSetOrder(1) ) //CE1_FILIAL+CE1_CODISS+CE1_ESTISS+CE1_CMUISS+CE1_PROISS
	If CE1->( MsSeek( FWxFilial("CE1") + cCodISS + cEstado + cMunicipio ) )
		aRet := { CE1->CE1_FORISS, CE1->CE1_LOJISS }
	EndIf

	RestArea(aAreaCE1)
	FwFreeArray(aAreaCE1)
Return aRet

//--------------------------------------------------------------------------
/*/{Protheus.doc} RetAnivCP()
Função que retorna todas as datas de aniversário da respectiva caderneta
de poupança, da data de cadastro até a data do resgate

@author Pedro Pereira Lima
@since 20/12/2018
@version 12.1.17
/*/
//--------------------------------------------------------------------------
Static Function RetAnivCP( dDataCP As Date, dDtSaldo As Date ) As Array
	Local aAniv		As Array
	Local nDiaAniv	As Numeric
	Local nX		As Numeric
	Local nDifData	As Numeric
	Local nTo		As Numeric
	Local nDia		As Numeric	
	Local lUltAniv	As Logical
	Local lResgate	As Logical

	aAniv := {}

	nDiaAniv := 0
	nX := 0
	nDifData := 0
	nTo := 1
	nDia := Day( dDataCP )

	lUltAniv := .F.
	lResgate := !Empty( SEH->EH_DATARES )

	// Caso o dia da data de aniversário seja maior que 28
	// assumo que o dia do aniversário da poupança será
	// sempre o dia 01 do mês seguinte (Regra do BCB)
	If nDia > 28
		nDiaAniv := 1
		// Forço o laço para começar sempre a partir do dia 2
		// caso o aniversário da poupança seja no dia 1 por causa
		// da regra do dia 28 estabelecida pelo BCB caso não tenha
		// havido nenhum resgate nesta caderneta de poupança
		If !lResgate
			If nDia == 29
				nTo := 4
			ElseIf nDia == 30
				nTo := 3
			Else
				nTo := 2
			EndIf
		EndIf
	Else
		nDiaAniv := nDia
	EndIf

	// Verifico se o resgate está sendo feito no dia do aniversário ou posterior
	If Day( dDtSaldo ) - nDiaAniv >= 0 .And. DataValida( dDtSaldo, .T. ) == dDtSaldo
		lUltAniv := .T.
	Else
		lUltAniv := .F.
	EndIf

	// Caso tente efetuar resgate no mesmo dia ou em data anterior a outro resgate
	// evito que os rendimentos anteriores sejam calculados novamente em cima
	// do saldo restante na caderneta de poupança
	If lResgate
		nDifData := dDtSaldo - SEH->EH_DATARES
		dDataCP := SEH->EH_DATARES
	Else
		nDifData := dDtSaldo - dDataCP
	EndIf

	For nX := nTo To nDifData
		If Day( dDataCP + nX ) == nDiaAniv
			// Caso o aniversário da poupança caia num final de semana ou feriado,
			// neste mês, o aniversário será no dia útil seguinte ao dia do aniversário
			// da caderneta de poupança
			If lResgate .And. !lUltAniv
				If DataValida( dDataCP + nX, .T. ) <= dDtSaldo
					aAdd( aAniv, DtoS( DataValida( dDataCP + nX, .T. ) ) )
				EndIf
			Else
				aAdd( aAniv, DtoS( DataValida( dDataCP + nX, .T. ) ) )
			EndIf
		EndIf
	Next nX

Return aAniv

Static Function ProtCfgAdt()	
Local aRet := {}
If FindFunction('CfgAdianta')
	aRet := CfgAdianta()
Else
	aRet := {;
			{FwModeAccess('FIE',1),;
 			 FwModeAccess('FIE',2),;
			 FwModeAccess('FIE',3),;
			 FWSIXUtil():ExistIndex( 'FIE', '4' ),;
			 FWSIXUtil():ExistIndex( 'FIE', '5' )},;
			{FwModeAccess('FR3',1),;
			 FwModeAccess('FR3',2),;
			 FwModeAccess('FR3',3),;
			 FWSIXUtil():ExistIndex( 'FR3' , '8' ),;
			 FWSIXUtil():ExistIndex( 'FR3' , '9' )},;
			{FwModeAccess('SE1',3),;
			 FwModeAccess('SE2',3)} }
EndIf
Return(aRet)

//------------------------------------------------------------------------------------------
	/*/{Protheus.doc} TemChqCr
	Verifica se existe cheque amarrado ao título aguardando compensação. (MV_SLDBXCR = C)
	@type  Function
	@author Renato.ito
	@since 30/01/2020
	@param cFilOrig, Character, E1_FILIAL
	@param cPrefixo, Character, E1_PREFIXO
	@param cTitulo, Character, E1_NUM
	@param cParcela, Character, E1_PARCELA
	@param cTipo, Character, E1_TIPO
	@return lAchou, Logical, retorna se existe um cheque para o título
	/*/
//------------------------------------------------------------------------------------------
Function TemChqCr(cFilOrig As Character, cPrefixo As Character, cTitulo As Character, cParcela As Character, cTipo As Character) As Logical

	Local cQuery As Character
	Local lAchou As Logical

	Default cFilOrig	:= ""
	Default cPrefixo	:= ""
	Default cTitulo		:= ""
	Default cParcela	:= ""
	Default cTipo		:= ""

	cQuery := "SELECT COUNT(EF_NUM) CHEQUE FROM " + RetSqlName("SEF") + " WHERE "
	cQuery += "EF_FILORIG = ? "
	cQuery += "AND EF_PREFIXO = ? "
	cQuery += "AND EF_TITULO =  ? "
	cQuery += "AND EF_PARCELA = ? "
	cQuery += "AND EF_TIPO = ? "
	cQuery += "AND EF_CART = ? "
	cQuery += "AND EF_LIBER  = ? "
	cQuery += "AND EF_DTCOMP = ? "
	cQuery += "AND EF_CHDEVOL != ? "
	cQuery += "AND D_E_L_E_T_ = ? "

	cQuery := ChangeQuery(cQuery)

	oPrepared:=FWPreparedStatement():New(cQuery)
	oPrepared:SetString(1, xFilial('SEF',cFilOrig))
	oPrepared:SetString(2, cPrefixo)
	oPrepared:SetString(3, cTitulo)
	oPrepared:SetString(4, cParcela)
	oPrepared:SetString(5, cTipo)
	oPrepared:SetString(6, 'R')
	oPrepared:SetString(7, Nil)
	oPrepared:SetString(8, Nil)
	oPrepared:SetString(9, 'S')
	oPrepared:SetString(10, Nil)

	cQuery:=oPrepared:GetFixQuery()

	lAchou := !Empty(MpSysExecScalar(cQuery,"CHEQUE"))

Return lAchou

/*/{Protheus.doc} FinHelp
Rotina para exibir HELP com direcionamento para o TDN/KCS
@type  Function
@author renato.campos
@since 06/06/2019
@version 12.1.17
@return 
/*/
Function FinHelp(cTitulo AS Character, cMsg AS Character, aBtLinks AS Array, nLargura As Numeric, nAltura As Numeric)
Local oDlg 		AS Object
Local oPanel 	AS Object
Local oTextDesc AS Object
Local oBtnLink1 AS Object
Local oBtnLink2 AS Object
Local oBtnLink3 AS Object
Local oFont		AS Object

Default cTitulo := ""
Default cMsg := ""
Default aBtLinks := {}
Default nLargura := 500
Default nAltura  := 800

oFont := TFont():New('Arial',,-12,.T.)

// Limite de 3 links externos para não estourar a tela
DEFINE MSDIALOG oDlg FROM 0,0 TO nLargura,nAltura TITLE OemToAnsi(cTitulo) PIXEL  
oDlg:lMaximized := .F.

oPanel := TPanelCss():New(0,0,"",oDlg,,.F.,.F.,,,oDlg:nWidth/2,oDlg:nHeight/2,.T.,.F.)

oTextDesc := tSimpleEditor():New(2,2, oPanel,(oPanel:nWidth/2)-7,(oPanel:nHeight/2)-17,,.T.,,,.T. )
oTextDesc:Setcss("background-color : transparent; border: 1px solid #DCDCDC;  border-radius: 4px; ") 
oTextDesc:Load(cMsg)

If Len(aBtLinks) >= 1
	oBtnLink1 := TButton():New( (oPanel:nHeight/2)-60, 5, aBtLinks[1,1]   ,oPanel,, 400 ,12,,,.F.,.T.,.F.,,.F.,,,.F. ) 
	oBtnLink1:SetCSS("QPushButton {text-decoration: underline; color: blue; border: 0px solid #DCDCDC; border-radius: 0px;Text-align:left}")
	oBtnLink1:bLClicked := {|| ShellExecute("open", aBtLinks[1,2] ,"","",SW_SHOW) }
EndIf

If Len(aBtLinks) >= 2
	oBtnLink2 := TButton():New( (oPanel:nHeight/2)-48, 5, aBtLinks[2,1]   ,oPanel,, 400 ,12,,,.F.,.T.,.F.,,.F.,,,.F. ) 
	oBtnLink2:SetCSS("QPushButton {text-decoration: underline; color: blue; border: 0px solid #DCDCDC; border-radius: 0px;Text-align:left}")
	oBtnLink2:bLClicked := {|| ShellExecute("open", aBtLinks[2,2] ,"","",SW_SHOW) }
EndIf

If Len(aBtLinks) >= 3
	oBtnLink3 := TButton():New( (oPanel:nHeight/2)-36, 5, aBtLinks[3,1]   ,oPanel,, 400 ,12,,,.F.,.T.,.F.,,.F.,,,.F. ) 
	oBtnLink3:SetCSS("QPushButton {text-decoration: underline; color: blue; border: 0px solid #DCDCDC; border-radius: 0px;Text-align:left}")
	oBtnLink3:bLClicked := {|| ShellExecute("open", aBtLinks[3,2] ,"","",SW_SHOW) }
EndIf

ACTIVATE MSDIALOG oDlg CENTERED

Return

//------------------------------------------------------------------------------------------
/*/{Protheus.doc} DEC_FIN
Função que utiliza o tipo de dado F (fixed) para multiplicações 
que necessitem maior precisão matemática.

@type  Function
@author Fabio Casagrandre/Norberto M de Melo
@since 10/Mar/2020
@param nSaldo, Numeric
@param nTaxa, Numeric
@return nRet, Numeric
/*/
//------------------------------------------------------------------------------------------
Function DEC_FIN(nSaldo as Numeric,nTaxa as Numeric) as Numeric
	Local nRet as Numeric
	Local fDCSaldo //Variavel de ponto flutuante, não possui tipagem
	Local fDCTaxa  //Variavel de ponto flutuante, não possui tipagem
	Local fDCProduto //Variavel de ponto flutuante, não possui tipagem

	DEFAULT nSaldo := 0.0
	DEFAULT nTaxa := 0.0

	If !EMPTY(nSaldo+nTaxa)
		// Transforma os dados numericos em Fixed Size Decimal (ValType() = 'F')
		fDCSaldo := DEC_CREATE(ALLTRIM(STR(nSaldo)),15,8)
		fDCTaxa := DEC_CREATE(nTaxa,15,8)
		// Obtém o produto do Saldo pela Taxa
		fDCProduto := DEC_MUL(fDCSaldo,fDCTaxa)
		// Arredondamento
		nRet := RoundFIN(fDCProduto,8)
	else
		nRet := 0
	Endif

Return nRet
//------------------------------------------------------------------------------------------
/*/{Protheus.doc} RoundFIN
Arredondamento com suporte ao tipo de dado F (fixed) e à norma ABNT NBR 5891.

@type  Function
@author Fabio Casagrandre/Norberto M de Melo
@since 10/Mar/2020
@param uValor, Undefined (Numeric/Fixed)
@param nDec, Numeric
@param lABNT, Logical
@return nRet, Numeric
/*/
//------------------------------------------------------------------------------------------
Function RoundFIN(uValor as Variant, nDec as Numeric, lABNT as Logical) as Numeric
	Local nRet as Numeric
	Local nInt as Numeric
	Local nFrac as Numeric
	Local cNumToInc as Character
	Local cNumToChk as Character
	Local lIncrementa as Logical
	Local cFixed as Character

	Default uValor := 0
	Default nDec := 0
	Default lABNT := .F.

	nRet := If(VALTYPE(uValor)=='N',uValor,VAL(cValToChar(uValor)))

	nFrac := CTOD('')

	// Se os algarismos decimais seguintes 
	// forem menores que 50, 500, 5000..., o anterior não se modifica.
	lIncrementa := .F.

	If !EMPTY(MOD(uValor,1))
		If VALTYPE(uValor) == 'N'
			nInt := INT(uValor)
			nFrac := MOD(uValor,1)
			cNumToInc := SUBSTR(STRTRAN(ALLTRIM(STR(nFrac)),'0.',''),1,nDec)
			cNumToChk := SUBSTR(STRTRAN(ALLTRIM(STR(nFrac)),'0.',''),nDec+1)
		ElseIf VALTYPE(uValor) == 'F'
			nInt := INT(VAL(cValToChar(uValor)))
			cFixed := SUBSTR(cValToChar(uValor),AT('.',cValToChar(uValor))+1)
			cNumToInc := SUBSTR(cFixed,1,nDec)
			cNumToChk := STRTRAN(cFixed,cNumToInc)
		EndIf
		
		If VAL(cNumToChk) > VAL('5'+REPLICATE('0',LEN(cNumToChk)-1))
			// Se os algarismos decimais seguintes 
			// forem maiores a 50, 500, 5000..., o anterior incrementa-se em uma unidade.
			lIncrementa := .T.
		elseif VAL(cNumToChk) == VAL('5'+REPLICATE('0',LEN(cNumToChk)-1))
			// Para os casos ABNT: ------------------------------------ 
			// Se os algarismos decimais seguintes 
			// forem iguais a 50, 500, 5000..., verifica-se o anterior;
			// se for par, o anterior não se modifica;
			// se for impar, o anterior incrementa-se em uma unidade.
			lIncrementa := If(lABNT, MOD(VAL(cNumToInc),2) > 0, .T.)
		EndIf

		nRet := nInt + VAL('0.' + cNumToInc)
		If lIncrementa
			nRet := nRet + (1/(10^nDec))
		EndIf	
	EndIf

Return nRet

/*/{Protheus.doc} FerMunic
	Monta array com os feriados municipais cadastrados na tabela 63 (SX5)
	@type  Static Function
	@author Vitor Duca
	@since 02/06/2020
	@version version
	@param param, param_type, param_descr
	@return oRet, Object, HashMap com os feriados municipais
/*/
Static Function FerMunic()
	Local aFeriado As Array
	Local aRet	   As Array
	Local cTpFeriado As Character
	Local nPosFer	As Numeric
	Local nX		As Numeric
	Local oRet 		As Object

	aRet 	 	:= {}
	aFeriado 	:= FWGetSX5( "63",,"pt-br")
	nPosFer  	:= 0
	cTpFeriado	:= ""
	oRet 		:= NIL

	For nX := 1 to Len(aFeriado)
		nPosFer	 := At("[",aFeriado[nX][4])
		cTpFeriado := If( nPosFer != 0, SubSTR(aFeriado[nX][4],nPosFer+1,1),"U")
		If cTpFeriado == "M"
			Aadd(aRet,{aFeriado[nX][1]+SubSTR(aFeriado[nX][4],1,8)+cTpFeriado})
		Endif	
	Next nX
	
	If !Empty(aRet)
		oRet := AtoHM(aRet)
		FwFreeArray(aRet)
	Endif	

	FwFreeArray(aFeriado)

Return oRet

//------------------------------------------------------------------------------
/*/	{Protheus.doc} IRCurtoPrazo()
Retorna a Taxa de IR para Fundos de Curto Prazo (FIC)
SEH deve posicionada

@param nDiasApl - Dias corridos de Aplicação
@author	rafael rondon
@since 08/07/2020
@version	12.1.30
@return nTaxaIrf - Taxa de IR para FIC - Fundos de Curto Prazo (FIC)
/*/
//------------------------------------------------------------------------------
Function IRCurtoPrazo( nDiasApl As Numeric )  As Numeric

Local nTaxaIrf	As Numeric

Default nDiasApl	:= dDataBase - SEH->EH_DATA

nTaxaIrf := 0

If nDiasApl <= 180
	nTaxaIrf := 22.5
Else
	nTaxaIrf := 20
EndIf

Return nTaxaIrf


//------------------------------------------------------------------------------
/*/	{Protheus.doc} IRCurtoPrazo()
Retorna a Taxa de IR para Fundos de Curto Prazo (FIC)
SEH deve posicionada

@param nDiasApl - Dias corridos de Aplicação
@author	rafael rondon
@since 08/07/2020
@version	12.1.30
@return nTaxaIrf - Taxa de IR para FIC - Fundos de Curto Prazo (FIC)
/*/
//------------------------------------------------------------------------------
Static Function TxIRResgate( nDias As Numeric , aTabIrf As Array ) As Numeric

Local nTaxaIR		As Numeric
Local nAscan		As Numeric	

Default nDias		:= dDataBase - SEH->EH_DATA
Default aTabIrf		:= {{ 180, 22.5 },{ 360, 20.0 },{ 720, 17.5 },{ 1000000, 15.0 }}

Do Case
	Case !Empty(SEH->EH_TAXAIRF)

		nTaxaIR := SEH->EH_TAXAIRF

	Case AllTrim(SEH->EH_TIPO) == "FIC" // Fundos de Curto prazo

		nTaxaIR := IRCurtoPrazo(nDias)

	Case SX5->(MsSeek(xFilial("SX5")+"AR"))

		nTaxaIR := Val( TabelaIrf( 'AR' , nDias ) )

	OtherWise

		nAscan := Ascan( aTabIrf, { |e| e[1] >= nDias } ) // Pesquisa a aliquota conforme o tempo da aplicacao
		nTaxaIR := aTabIrf[nAscan][2]

EndCase

Return nTaxaIR


//------------------------------------------------------------------------------
/*/	{Protheus.doc} IRAprCotas()
Caso tenha ocorrido come-cotas, retorna o IR referente ao rendimento que já foi deduzido pelo come-cotas para subtrair no IR do rendimento atual (diferencial do IR)
SEH deve posicionada

@param nValorCotas - Valor em cotas referente ao resgate atual
@author	rafael rondon
@since 08/07/2020
@version	12.1.30
@return nIRAprop - 
/*/
//------------------------------------------------------------------------------
Static Function IRAprCotas( nValorCotas As Numeric , aUltComeCotas As Array) As Numeric

Local nIRAprop		As Numeric
Local nTaxaIR		As Numeric
Local nRendCome		As Numeric
Local nValIni		As Numeric
Local nValCome		As Numeric

Default aUltComeCotas	:= UltComeCotas()	// Busca data do ultimo come-cotas

nIRAprop		:= 0

If !Empty(aUltComeCotas[1])
	nTaxaIR := StaticCall(FINA183,TaxaIRAp,.T./*IsComeCotas*/)
	/*		
		Valor R$ das cotas a serem resgatas na cotação inicial
	*/
	nValIni := nValorCotas * SEH->EH_VLRCOTA
	/*
		Valor R$ das cotas a serem resgatas na cotação do último Come-Cotas
	*/
	nValCome := nValorCotas * aUltComeCotas[2]
	/*
		Rendimento inicial até último Come-Cotas
	*/
	nRendCome := nValCome - nValIni

	// Deduz IOF antes de calcular IR
	IF !EMPTY(aUltComeCotas) .AND. SEH->(EH_APLEMP == 'APL' .AND. EH_TIPO == 'FAF')
 		nRendCome -= FIN_IOF(SEH->EH_APLEMP, nRendCome, aUltComeCotas[1]-SEH->EH_DATA)
		nRendCome := RoundFIN(nRendCome,2,.T.)
	ENDIF

	nIRAprop := nRendCome * nTaxaIR/100
EndIf

Return nIRAprop


//------------------------------------------------------------------------------
/*/	{Protheus.doc} UltComeCotas()
Retorna a Data e Cotação do Último come-cotas
SEH deve posicionada

@param nRendimento - Rendimento da aplicação 
@author	rafael rondon
@since 08/07/2020
@version	12.1.30
@return aRet[1] - Data do último come-cotas
		aRet[2} - Cotação da data do último come-cotas
/*/
//------------------------------------------------------------------------------
Static Function UltComeCotas() As Numeric

Local aArea			As Array
Local aAreaSE0		As Array
Local cQuery		As Character
Local aRet			As Array

aRet		:= {}
aArea		:= GetArea()
aAreaSE0	:= SE0->(GetArea())
cQuery 		:= ""

AADD(aRet , CToD("")	)
AADD(aRet , 0			)

cQuery := " SELECT EI_DATA FROM " + RetSqlName("SEI")
cQuery += " WHERE EI_FILIAL = '" + xFilial("SEI") + "' "
cQuery += " AND EI_APLEMP = '" + SEH->EH_APLEMP + "' "
cQuery += " AND EI_NUMERO = '" + SEH->EH_NUMERO + "' "
cQuery += " AND EI_REVISAO = '" + SEH->EH_REVISAO + "' "
cQuery += " AND EI_MOTBX = 'APR' "
cQuery += " AND EI_TIPODOC = 'I6' " // "I6" // Retencao do IRF  -- gravado no come-cotas (FINA183)
cQuery += " AND EI_QTDCOTA > 0 "	//	Quantidade de cotas "comidas" subtraídas
cQuery += " AND EI_STATUS = ' ' "
cQuery += " AND D_E_L_E_T_ = ' ' "
cQuery += " ORDER BY EI_DATA DESC "

cQuery	:= ChangeQuery(cQuery)

aRet[1]	:= SToD( MpSysExecScalar(cQuery,"EI_DATA") )

If !Empty(aRet[1])
	DbSelectArea('SE0')
	SE0->(DbSetOrder(2)) // E0_FILIAL+E0_BANCO+E0_AGENCIA+E0_CONTA+E0_CONTRAT+DTOS(E0_DATA)+E0_SUBCTA
	If SE0->(MsSeek(xFilial("SE0")+ SEH->(EH_BCOCONT + EH_AGECONT + EH_CTACONT + EH_CONTRAT + DToS(aRet[1]) )))
		aRet[2] := SE0->E0_VALOR
	EndIf
EndIf

RestArea(aAreaSE0)
RestArea(aArea)

Return aRet

//-------------------------------------
/*/{Protheus.doc}SeqBxFKs
Busca a última sequência de baixa do título nas tabelas FK1 ou FK2

@param cTabFk, char, Tabela FK na qual será feita a busca na sequencia de baixa
@param cFil, char, Filial de inclusão do título
@param cPref, char, Prefixo do título
@param cNro, char, Número do título
@param cParc, char, Parcela do título
@param cTipo, char, Tipo do título
@param cCliFor, char, Cliente / Fornecedor do título
@param cLoja, char, Loja do Cliente / Fornecedor do título
@param oQryFk1, char, Objeto de consulta da tabela FK1
@param oQryFk1, char, Objeto de consulta da tabela FK2
@return cSeqMax, char, retorna a última sequência de baixa do título

@author Sivaldo Oliveira
@since  09/09/2020
@version 12
@type  Function	
/*/
//-------------------------------------
Function SeqBxFKs(cTabFk As Char, cFil As Char, cPref As Char, cNro As Char, cParc As Char, cTipo As Char, cCliFor As Char, cLoja As Char,;
oQryFk1 As Object, oQryFk2 As Object) As Char
	Local cChaveTit As Char
	Local cChaveFk7 As Char
	Local cQuery As Char 
	Local cSeqMax As Char
	Local cSequen As Char
	Local cTipDoc As Char
	Local cTblTmp As Char
	
	Default cTabFk  := "" 
	Default cFil    := ""
	Default cPref   := ""
	Default cNro    := ""
	Default cParc   := ""
	Default cTipo   := ""
	Default cCliFor := ""
	Default cLoja   := ""
	Default oQryFk1 := Nil
	Default oQryFk2 := Nil
	
	//Inicializa variáveis.
	cChaveTit := ""
	cChaveFk7 := ""
	cQuery    := ""
	cSeqMax   := ""
	cSequen   := ""
	cTipDoc   := ""
	cTblTmp   := ""
	
	If !Empty(cTabFk) .And. cTabFk $ "FK1|FK2" 	
		cChaveTit := cFil + "|" + cPref + "|" + cNro + "|" + cParc + "|" + cTipo + "|" + cCliFor + "|" + cLoja
    	cChaveFk7 := FINGRVFK7(Iif(cTabFk == "FK1", "SE1", "SE2"), cChaveTit)
		
		If cTabFk == "FK1"
			cSequen := AllTrim(PadR("0", TamSX3("FK1_SEQ")[1], "0"))
			
			If oQryFk1 == Nil								
				cQuery := "SELECT ISNULL(MAX(FK1_SEQ), '" + cSequen + "') MAXSEQ "
				cQuery += "FROM " + RetSqlName("FK1") + " FK1 WHERE "
				cQuery += "FK1_FILIAL = ? "			
				cQuery += "AND FK1_IDDOC = ? "			
				cQuery += "AND FK1.D_E_L_E_T_ = ' ' "				
				cQuery  := ChangeQuery(cQuery)
				oQryFk1 := FWPreparedStatement():New(cQuery)
			EndIf
			
			oQryFk1:SetString(1, xFilial(cTabFk) )
			oQryFk1:SetString(2, cChaveFk7)
			cQuery := oQryFk1:GetFixQuery()
		Else
			cSequen := AllTrim(PadR("0", TamSX3("FK2_SEQ")[1], "0"))
			
			If oQryFk2 == Nil 
				cQuery := "SELECT ISNULL(MAX(FK2_SEQ), '" + cSequen + "') MAXSEQ "
				cQuery += "FROM " + RetSqlName("FK2") + " FK2 WHERE "
				cQuery += "FK2_FILIAL = ? "
				cQuery += "AND FK2_IDDOC = ? "			
				cQuery += "AND FK2.D_E_L_E_T_ = ' ' "
				cQuery  := ChangeQuery(cQuery)
				oQryFk2 := FWPreparedStatement():New(cQuery)
			EndIf
			
			oQryFk2:SetString(1, xFilial(cTabFk))
			oQryFk2:SetString(2, cChaveFk7)
			cQuery := oQryFk2:GetFixQuery()
		EndIf
		
		cTblTmp := MpSysOpenQuery(cQuery)
		cSeqMax := AllTrim((cTblTmp)->MAXSEQ) 
		(cTblTmp)->(DbCloseArea())
		cSeqMax := Iif(cSequen == cSeqMax, "", cSeqMax)
	EndIf
Return cSeqMax

/*/
{Protheus.doc} FIN_IOF()
Retorna o Calculo de IOF sobre Operações de Crédito, Câmbio e Seguro ou relativas a Títulos ou Valores Mobiliários 

@param cAplEmp - Caracter - Identifica tipo Operação 
@param nBaseCalculo - Valor monetário - Montante onde será aplicado o calculado de IOF  
@param nDiasAcumulados - Quantidade de dias a ser aplicado o IOF diario 
@param nIOFAdicional - Percentual - Atualmente este valor muda quando aplicado:
									para empréstimo e financiamento	de 0,38% a 3,38%
									para cartão de crédito	6,38%
									para seguro	até 25%
									para câmbio de moedas	1,1% sobre o total
@param nIOFDiario - Percentual - IOF incidente sobre operações de crédito.
@author	Norberto M de Melo
@since 03/09/2020
@version 1.0
@return nValorIOF - Valor calculado do IOF
/*/
FUNCTION FIN_IOF(cAPlEmp AS CHARACTER, nBaseCalculo AS NUMERIC, nDiasAcumulados AS NUMERIC, nIOFAdicional AS NUMERIC, nIOFDiario AS NUMERIC) AS NUMERIC
	LOCAL nValorIOF AS NUMERIC
	LOCAL nRet AS NUMERIC
	LOCAL nTaxaIOF as Variant// Tipo (F)IXED

	DEFAULT cAplEmp := 'EMP'
	DEFAULT nBaseCalculo := 0.00
	DEFAULT nDiasAcumulados := 0
	DEFAULT nIOFAdicional := 0.38
	DEFAULT nIOFDiario := IF(FWSM0Util():GetSM0Data(cEmpAnt,cFilAnt,{'M0_TPINSC'})[1][2]==2,0.0041,0.0082)

	nRet := 0.00
	nBaseCalculo := ABS(nBaseCalculo)
	nDiasAcumulados := ABS(nDiasAcumulados)
	nIOFAdicional := ABS(nIOFAdicional)
	nIOFDiario := ABS(nIOFDiario)

	IF !EMPTY(nBaseCalculo)	
		nTaxaIOF := DEC_CREATE(0,12,8)
		nBaseCalculo := DEC_CREATE(nBaseCalculo,15,8)

		IF cAplEmp == 'EMP' .AND. !EMPTY(nIOFAdicional)
			// Converte as taxas de porcentagem para decinal
			nIOFAdicional := DEC_DIV(DEC_CREATE(nIOFAdicional,12,8),DEC_CREATE(100,6,0))

			If !EMPTY(nIOFDiario) .AND. !EMPTY(nDiasAcumulados)
				nIOFDiario := DEC_DIV(DEC_CREATE(nIOFDiario,12,8),DEC_CREATE(100,6,0))
				// Multiplica IOF diario pelos dias acumulados
				nIOFDiario := DEC_MUL(nIOFDiario,DEC_CREATE(MIN(nDiasAcumulados,365),6,0))
			ELse	// Garantir que o tipo seja (f)ixed para o correto uso na DEC_ADD()
				nIOFDiario := DEC_CREATE(nIOFDiario,12,8)
			EndIf

			// Soma os fatores IOF Adicional e Diario
			nTaxaIOF := DEC_ADD(nIOFAdicional,nIOFDiario)
		ELSEIF cAplEmp == 'APL' .AND. !EMPTY(nDiasAcumulados) .AND. ABS(nDiasAcumulados) <= 29
			nTaxaIOF := DEC_CREATE((VAL(TABELA('A0'/*Tabela IOF SX5*/, STRZERO(nDiasAcumulados,2)))/100),12,8)
		ENDIF

		// Multiplica para encontrar o valor do IOF
		nValorIOF := DEC_MUL(nBaseCalculo,nTaxaIOF)
		// Aplica arredondamento
		nRet := RoundFIN(nValorIOF,2,.T.)
	ENDIF
RETURN nRet

//--------------------------------------
/*/{Protheus.doc}FinTotAb
Retorna o total de abatimento de um título.

@Param cTabela, tabela de títulos a pagar ou receber
@Param cChaTitPai, chave do titulo pai (E1/E1 - TITPAI)
@Param cFilialOri, Filial de origem do título pai
@Param nMoedaDest, moeda na qual deve retornar o valor do abatimento
@Param dDataRef, data de referência a ser usada na conversão de moeda
@Param nCasDec, Casas decimais a ser considerada no arredondamento
@Param oObjAb, objeto com a consulta do abatimento, um objeto por carteira.
@Param cListaAb, Char lista dos abatimentos
@Param cSeparador Char caracter separador dos abatimentos
@return nTotal, retorna o total de abatimento.

@author Sivaldo Oliveira
@since  07/10/2020
@version 12
/*/
//----------------------------------------
Function FinTotAb(cTabela As Char, cChaTitPai As Char, cFilialOri As Char, nMoedaDest As Numeric, dDataRef As Date, nCasDec As Numeric,;
																	oObjAb As Object, cListaAb As Char, cSeparador As Char) As Numeric
	Local nTotal As Numeric
	Local nVlrAb As Numeric
	Local cQry   As Char
	
	//Inicializa variáveis.
	nTotal := 0	
	nVlrAb := 0
	cQry   := ""
	
	Default cTabela    := ""
	Default cChaTitPai := ""
	Default cFilialOri := cFilAnt
	Default nMoedaDest := 1
	Default dDataRef   := dDataBase
	Default oObjAb     := Nil
	Default nCasDec    := 2
	Default cListaAb   := MVABATIM 
	Default cSeparador := "|"
	
	cTabela := AllTrim(cTabela)
	
	If cTabela $ "SE1|SE2" .And. !Empty(cChaTitPai)
		If cTabela == "SE1"
			cChaTitPai := PadR(cChaTitPai, TamSx3("E1_TITPAI")[1], "")
			
			If oObjAb == Nil 
				cQry := "SELECT E1_VALOR VALORINC, ISNULL(E1_MOEDA, 0) MOEDAINC, ISNULL(E1_TXMOEDA, 0) TAXAINC FROM ? "
				cQry += "WHERE E1_TITPAI = ? AND E1_FILORIG = ? AND E1_TIPO IN (?) "
				cQry += "AND D_E_L_E_T_ = '' "
				cQry := ChangeQuery(cQry)
			EndIf
		Else
			cChaTitPai := PadR(cChaTitPai, TamSx3("E2_TITPAI")[1], "") 
			
			If oObjAb == Nil 
				cQry := "SELECT E2_VALOR VALORINC, ISNULL(E2_MOEDA, 0) MOEDAINC, ISNULL(E2_TXMOEDA, 0) TAXAINC FROM ? "
				cQry += "WHERE E2_TITPAI = ? AND E2_FILORIG = ? AND E2_TIPO IN (?) "
				cQry += "AND D_E_L_E_T_ = '' "
				cQry := ChangeQuery(cQry)
			EndIf
		EndIf
		
		If oObjAb == Nil
			oObjAb := FwPreparedStatement():New(cQry)
		EndIf
		
		oObjAb:SetNumeric(1, RetSqlName(cTabela))
		oObjAb:SetString(2, cChaTitPai)
		oObjAb:SetString(3, cFilialOri)
		oObjAb:SetIn(4, FinSetIn(cListaAb, cSeparador))
		cQry := oObjAb:GetFixQuery()
		cTblTmp := MpSysOpenQuery(cQry)
		
		While (cTblTmp)->(!Eof())
			If (cTblTmp)->MOEDAINC == 0
				(cTblTmp)->(DbSkip())
				Loop
			EndIf
			
			nVlrAb := (cTblTmp)->VALORINC
			
			If (cTblTmp)->MOEDAINC != nMoedaDest
				nVlrAb := Round(xMoeda(nVlrAb, (cTblTmp)->MOEDAINC, nMoedaDest, dDataRef, 4, (cTblTmp)->TAXAINC, Nil), 2)
			EndIf				
			
			nTotal += nVlrAb				
			(cTblTmp)->(DbSkip())
		EndDo
		
		(cTblTmp)->(DbCloseArea())
	EndIf
Return nTotal

//--------------------------------------------
/*/{Protheus.doc}FinSetIn
Cria um vetor com os tipos de títulos, o objetivo é , 
que esse vetor seja usado na função SetIn da instância
da classe FwPreparedStatement.

@Param cString, lista dos tipos
@Param cSeparador, caracter que separa os tipos
@return aTipo, retorna um vetor com os tipos

@author Sivaldo Oliveira
@since  07/10/2020
@version 12
/*/
//--------------------------------------------
Function FinSetIn(cString As Char, cSeparador As Char, nLenTipo As Numeric) As Array	
	Local cTipo      As Character
	Local cCaract    As Character
	Local nY         As Numeric
	Local nLenString As Numeric
	Local nQuant     As Numeric
	Local aTipo      As array
	
	Default cString    := ""
	Default cSeparador := ""
	Default nLenTipo   := 0
	
	//Inicializa variáveis
	cTipo      := ""
	cCaract    := ""
	nY         := 0
	nLenString := 0
	nQuant     := 0
	aTipo      := {}
	cSeparador := AllTrim(cSeparador)
	
	If !Empty(cSeparador)
		cString    := AllTrim(cString)		
		
		If (nLenString := Len(cString)) > 0
			If nLenTipo == 0
				nLenTipo := TamSx3("E2_TIPO")[1]
			EndIf
		EndIf
		
		For nY := 1 To nLenString
			cCaract := SUBSTR(cString, nY, 1)
			
			If cCaract == cSeparador
				If nY < nLenString 
					Loop
				EndIf				
				cCaract := ""
			EndIf
			
			cTipo  += cCaract 
			nQuant += 1
			
			If ((nQuant == nLenTipo) .Or. (nY == nLenString))
				Aadd(aTipo,  Padr(AllTrim(cTipo), nLenTipo, ""))
				cTipo  := ""
				nQuant := 0
			EndIf
		Next nY
	EndIf
	
	If Len(aTipo) == 0
		aTipo := {""}
	EndIf
Return aTipo

/*/{Protheus.doc} NewSumAbat
	Realiza o calculo dos abatimentos para processos massivos,
	(relatorios e baixas automaticas), a função não realiza a conversão 
	pelo xMoeda(), sendo responsabilidade da função chamadora efetuar a conversão
	
	@type  Function
	@author Vitor Duca
	@since 30/10/2020
	@version 1.0
	@param cTable, Character, Tabela temporaria que recebera o UPDATE
	@param aUpdField, Array, Array com os campos da temporaria que receberão o UPDATE
	@param cCarteira, Character, Carteira do titulo (Pagar = P, Receber = R)
	@param aFieldsTmp, Array, Array contendo os campos da temporaria que possuem a informação do _TITPAI (chave do titulo)
	@return nError, Numeric, Codigo de erro na execução da função TcSqlExec()
	@example
	(examples)
	@see (links_or_references)
/*/
Function NewSumAbat(cTable As Character,aUpdField As Character,cCarteira As Character,aFieldsTmp As Array)
	Local nError   As Numeric
	Local cQry 	   As Character
	Local cNulo	   As Character
	Local cBDname  As Character
	Local cTblAbt  As Character
	Local cFieldAbt As Character
	Local cSelect As Character
	Local nX		As Numeric

	Default cTable	  := RetSqlName("SE1")
	DEFAULT aUpdField := {}
	DEFAULT cCarteira := "R"
	DEFAULT aFieldsTmp := {}

	nError    := 0
	cQry 	  := ""
	cNulo	  := ""
	cSelect   := ""
	cBDname   := Upper( TCGetDB() )
	cAliasTMP := IIF( cBDname $ "POSTGRES", "", cTable + "." )
	cTblAbt   := "SE1"
	cFieldAbt := "E1"

	Do CASE
		CASE cBDname $ "ORACLE|INFORMIX|DB2"
			cNulo := "NVL"
		CASE cBDname $ "POSTGRES|MYSQL"
			cNulo := "COALESCE"
		OTHERWISE
			cNulo := "ISNULL"
	End CASE
	
	If cCarteira == "P"
		cTblAbt := "SE2"
		cFieldAbt := "E2"
	Endif	

	nFieldUpd := Len(aUpdField)

	If nFieldUpd == 3
		For nX := 1 to nFieldUpd
			If nError == 0
				Do Case 
					Case nX == 1
						cSelect := "((SELECT SUM(" + cTblAbt + "." + cFieldAbt + "_VALOR" + ") "
					Case nX == 2	
						cSelect := "((SELECT " + cTblAbt + "." + cFieldAbt + "_MOEDA" + " "
					OtherWise
						cSelect := "((SELECT " + cTblAbt + "." + cFieldAbt + "_TXMOEDA" + " "
				EndCase		

				cQry := " UPDATE " + cTable
				cQry += " SET "+ cAliasTMP + aUpdField[nX] + " = "
				cQry += cNulo + cSelect
				cQry += " FROM " + RetSqlName(cTblAbt) + " " + cTblAbt
				cQry += " WHERE " + cTblAbt + "." + cFieldAbt + "_FILIAL = "+ cTable + "." + aFieldsTmp[1] + " AND "
				cQry += cTblAbt + "." + cFieldAbt + "_TITPAI = " + cTable + "." + aFieldsTmp[2] + " + " + cTable + "." + aFieldsTmp[3] 
				cQry += " + " + cTable + "." + aFieldsTmp[4] + " + " + cTable + "." + aFieldsTmp[5]
				cQry += " + " + cTable + "." + aFieldsTmp[6] + " + " + cTable + "." + aFieldsTmp[7] + " AND "
				cQry += " " + cTblAbt+"."+"D_E_L_E_T_ = ' ' AND "
				cQry += cTable+ ".D_E_L_E_T_ = ' '),0) "
				
				nError := TcSQLExec(cQry)
			Endif	
		Next	
	Endif

Return nError

/*/{Protheus.doc} FxBcoBloq
	Função responsavel por verificar se banco esta bloqueado para processos massivos, 
	funcionamento semelhante ao da função CCBlocked() 

	@type  Function
	@author Vitor Duca
	@since 20/11/2020
	@version 1.0
	@param cTable, Character, Tabela temporaria que recebera o UPDATE
	@param cUpdField, Character, Campo da tabela temporaria que ira receber o UPDATE
	@param aFieldsTmp, Array, Array contendo os campos da temporaria que possuem a do ID da baixa e Filial de acordo com a carteira
	@return nError, Numeric, Codigo de erro na execução da função TcSqlExec()
	@example
	FxBcoBloq(_oFINA0902:GetRealName(),{FK2_FILIAL,FK2_IDFK2})
	@see 
/*/
Function FxBcoBloq(cTable As Character,aFieldsTmp As Array) As Numeric
	Local nError   As Numeric
	Local cQry 	   As Character
	Local cBDname  As Character
	Local nTamFilA6 As Numeric
	Local cSubs		As Character	

	Default cTable	  := RetSqlName("SE1")
	DEFAULT aFieldsTmp := {}

	nError    := 0
	cQry 	  := ""
	cBDname   := Upper( TCGetDB() )
	nTamFilA6 := Len(AllTrim(xFilial("SA6")))
	cSubs     := "SUBSTRING"

	If cBDname $ "ORACLE|POSTGRES"
		cSubs 	:= "SUBSTR"
	EndIf

	cQry := "DELETE FROM "+cTable+" "
	cQry += "WHERE "+cTable+".R_E_C_N_O_ IN (SELECT TEMP.R_E_C_N_O_ FROM "+cTable+" TEMP "
	cQry += "INNER JOIN "+RetSqlName("FKA")+" FKA1 ON FKA1.FKA_FILIAL = TEMP."+aFieldsTmp[1]+" AND FKA1.FKA_IDORIG = TEMP."+aFieldsTmp[2]+" AND FKA1.D_E_L_E_T_ = '' "
 	cQry += "LEFT JOIN "+RetSqlName("FKA")+" FKA2 ON FKA2.FKA_FILIAL = FKA1.FKA_FILIAL AND FKA2.FKA_IDPROC = FKA1.FKA_IDPROC AND FKA2.D_E_L_E_T_ = '' "
	cQry += "INNER JOIN "+RetSqlName("FK5")+" FK5  ON  FK5.FK5_FILIAL = FKA2.FKA_FILIAL AND FKA2.FKA_TABORI = 'FK5' AND FK5.FK5_IDMOV = FKA2.FKA_IDORIG AND FK5.D_E_L_E_T_ = '' "
	cQry += "INNER JOIN "+RetSqlName("SA6")+" SA6 ON SA6.A6_FILIAL = "+cSubs+"(FK5.FK5_FILORI,1,"+cValTochar(nTamFilA6)+") AND SA6.A6_COD = FK5.FK5_BANCO AND SA6.A6_AGENCIA = FK5.FK5_AGENCI AND SA6.A6_NUMCON = FK5.FK5_CONTA AND SA6.D_E_L_E_T_ = '' "
	cQry += "WHERE " 
	cQry += "SA6.A6_BLOCKED = '1' AND SA6.A6_DTBLOQ <= '"+Dtos(dDataBase)+"' "
	cQry += "AND TEMP.D_E_L_E_T_ = ' ' "
	
	IF SA6->(ColumnPos("A6_MSBLQL")) > 0
		cQry += " OR (SA6.A6_MSBLQL = '1' AND TEMP.D_E_L_E_T_ = ' ')"
	ENDIF	
	
	cQry += ")"

	nError := TcSQLExec(cQry)

Return nError

/*/{Protheus.doc} FinSqlLog
	Função para logar os erros de execução do TcSQLExec.
	@type  Function
	@author Vitor Duca
	@since 20/11/2020
	@version 1.0
	@param cLogName, Character, Nome do log a ser gravado
	@param cLogText, Character, Identificação do erro
	@param cSQLControl, Character, Erro retornado pela função TcSqlExec
	@return return_var, return_type, return_description
	@example
	FinSqlLog("FR090LOG","UPDATE_TEMPORARIA",tcSqlError())
	@see (links_or_references)
/*/
Function FinSqlLog(cLogName As Character, cLogText As Character, cSQLControl As Character) 
	Local cFunction As Character 
	Local cLogFile  As Character 
	Local cLogHead  As Character 
	Local cPath     As Character
	Local cProcLine As Character
	Local cThreadID As Character 
	Local lContinua As Logical 
	Local nHandle   As Numeric 

	lContinua := .T. 
	cPath := "\SYSTEM\"
	cLogFile := cPath + cLogName +Alltrim(cEmpAnt+cFilant)+"_"+Dtos(Date())+".log"

	If !File(cLogFile)
		nHandle := FCreate( cLogFile ) 
		If nHandle == -1 
			lContinua := .F. 
		Else 
			cLogHead:= DToC(date()) + CRLF
			FSeek ( nHandle, 0, 2 )	// Posiciona no final do arquivo.
			FWrite( nHandle, cLogHead, Len(cLogHead) )
			FClose(nHandle)

		EndIf 
	EndIf 

	If lContinua

		cThreadID 	:= AllTrim(Str(ThreadID())) 	//Retorna o ID (número de identificação) da thread em que a chamada da função foi realizada
		cProcLine 	:= AllTrim(Str(ProcLine(1))) 	//Retorna o número da linha do código fonte executado que fez a chamada da geração do LOG
		cFunction 	:= ProcName(1) 					//Retorna o nome da funcao em execução que fez a chamada da geração do LOG

		cFunction := " Function " + cFunction
		
		cLogText := Time() + " " + "["+cThreadID+"]" + cFunction + " Line " + cProcLine + CRLF +;
					Space(5) +  "[" + cSQLControl + "] " + cLogText + CRLF

		// Grava o texto no Arquivo de LOG
		nHandle := FOpen(cLogFile, 2 )
		FSeek ( nHandle, 0, 2 )	// Posiciona no final do arquivo.
		FWrite( nHandle, cLogText, Len(cLogText) )
		FClose( nHandle )
	EndIf 

Return

/*/{Protheus.doc} FinSomaFK6
Rotina que soma os valores acessórios para SaldoTit (procedure).

@type       function
@author     Rafael Riego
@since      19/01/2020
@param      cFilMov, character, filial do movimento (FK5_FILIAL/E5_FILIAL)
@param      cFilTit, character, filial do título (E1_FILIAL/E2_FILIAL) 
@param      cIdDoc, character, Id do titulo na FK7
@param      cCarteira, character, carteira do título
@param      dDataBaixa, date, data da baixa
@param      cTipoData, character, tipo da data a ser utilizada na pesquisa {"0" = E5_DATA; "1" = E5_DTDISPO; "2" = E5_DTDIGIT}
@param      cAdiant, character, IIf(cTipo $ MVRECANT+"/"+MVPAGANT+"/"+MV_CRNEG+"/"+MV_CPNEG), "1","0")
@param      dDataBase, date, database utilizada na soma
@param      cFilOri, character, filial de origem do título
@param      nMoedaTit, numeric, moeda do título
@param      nTaxaMoeda, numeric, taxa da moeda
@return     numeric, valor acessório somado
/*/
Function FinSomaFK6(cFilMov As Character, cIdDoc As Character,; 
					cCarteira As Character, dDataBaixa As Date, cTipoData As Character,;
					cAdiant As Character, dDataBase As Date, cFilOri As Character,;
					nMoedaTit As Numeric, nTaxaMoeda As Numeric) As Numeric

	Local aArea			As Array
    Local aBind         As Array
    Local cAliasTMP     As Character
    Local cCartAux      As Character
    Local cDataBaixa    As Character
    Local cDataBase     As Character
    Local cQuery        As Character
    Local nVA           As Numeric

	nVa := 0

	aArea		:= GetArea()
	cCartAux    := cCarteira
	cDataBaixa  := DToS(dDataBaixa)
	cDataBase   := DToS(dDataBase)

	If __lCmpoFK1 == Nil .Or. __lCmpoFK2 == Nil
		__lCmpoFK1	:= FK1->(FieldPos("FK1_DTDISP")) > 0 .And. FK1->(FieldPos("FK1_DTDIGI")) > 0
		__lCmpoFK2	:= FK2->(FieldPos("FK2_DTDISP")) > 0 .And. FK2->(FieldPos("FK2_DTDIGI")) > 0 
	EndIf

	If cAdiant == "1"
		If cCartAux == "P"
			cCartAux := "R"
		Else
			cCartAux := "P"
		EndIf
	EndIf

	//cTipoData := "0"  // FK1_DATA/FK2_DATA
	//cTipoData := "1"  // FK1_DTDISP/FK2_DTDISP
	//cTipoData := "2"  // FK1_DTDIGI/FK2_DTDIGI
	If cCartAux == "P"
		If !__lCmpoFK2 .And. cTipoData $ "1|2"
			Return nVa
		EndIf
		If Empty(__cQryFK6P)
			__cQryFK6P := FinFK6Pag()
		EndIf
		cQuery := __cQryFK6P
	Else
		If !__lCmpoFK1 .And. cTipoData $ "1|2"
			Return nVa
		EndIf
		If Empty(__cQryFK6R)
			__cQryFK6R := FinFK6Rec()
		EndIf
		cQuery := __cQryFK6R
	EndIf

	If (__lCmpoFK1 .And. cCartAux == "R") .Or. (__lCmpoFK2 .And. cCartAux == "P")
		aBind := {;
			FWxFilial("FK1",cFilMov)	        ,;//#01
			cIdDoc			,;//#02
			cFilOri         ,;//#03
			cDataBaixa      ,;//#04
			cTipoData       ,;//#05
			cDataBaixa      ,;//#06
			cTipoData       ,;//#07
			cDataBaixa      ,;//#08
			cTipoData       ,;//#09
			cCartAux        ,;//#10
			cCartAux        ,;//#11
			cCarteira       ,;//#12
			cDataBase       ,;//#13
			cTipoData       ,;//#14
			cDataBase       ,;//#15
			cTipoData       ,;//#16
			cDataBase       ,;//#17
			cTipoData       } //#18
	Else
		aBind := {;
			FWxFilial("FK1",cFilMov)	        ,;//#01
			cIdDoc			,;//#02
			cFilOri         ,;//#03
			cDataBaixa      ,;//#04
			cCartAux        ,;//#05
			cCartAux        ,;//#06
			cCarteira       ,;//#07
			cDataBase       }//#08
	EndIf

	cAliasTMP := GetNextAlias()

	DbUseArea(.T., "TOPCONN", TCGenQry2(Nil, Nil, cQuery, aBind), cAliasTMP, .F., .T.)

	If __nMoeda != nMoedaTit
		While (cAliasTMP)->(!(EoF()))
			nVa += Round(NoRound(xMoeda((cAliasTMP)->VA, 1, nMoedaTit, (cAliasTMP)->FKDATA, 3,, IIf((cAliasTMP)->TXMOEDA == 0, nTaxaMoeda, (cAliasTMP)->TXMOEDA)), 3), 2)
			(cAliasTMP)->(DbSkip())
		End
	Else
		While (cAliasTMP)->(!(EoF()))
			nVa += (cAliasTMP)->VA
			(cAliasTMP)->(DbSkip())
		End
	EndIf

	(cAliasTMP)->(DbCloseArea())
	FwFreeArray(aBind)
	RestArea(aArea)

Return nVA

/*/{Protheus.doc} FinFK6Rec
Construção da query de soma do VA para títulos a receber (SE1).

@type       function
@author     Rafael Riego
@since      19/01/2020
@return     character, query para somatória do VA
/*/
Static Function FinFK6Rec() As Character

    Local cQuery    As Character

	cQuery := " SELECT FK1.FK1_DATA FKDATA, FK1.FK1_TXMOED TXMOEDA, COALESCE(SUM(CASE WHEN FK6.FK6_ACAO = '1' THEN FK6.FK6_VALMOV ELSE -FK6.FK6_VALMOV END), 0) VA"
    cQuery += " FROM " + RetSQLName("FK1") + " FK1 "
    cQuery += " INNER JOIN " + RetSQLName("FK6") + " FK6 ON "
    // Filtros JOIN FK1 x FK6
    cQuery += " FK6.FK6_FILIAL = FK1.FK1_FILIAL "
    cQuery += " AND FK6.FK6_IDORIG = FK1.FK1_IDFK1 "
    cQuery += " AND FK6.FK6_TABORI = 'FK1' "
    cQuery += " AND FK6.FK6_TPDOC = 'VA' "
    cQuery += " AND FK6.D_E_L_E_T_ = ' ' "
    // Filtros FK1
    cQuery += " WHERE "

	cQuery += " FK1.FK1_FILIAL = ? " //#01
    cQuery += " AND FK1.FK1_IDDOC = ? " //#02
    cQuery += " AND FK1.D_E_L_E_T_ = ' ' "
    cQuery += " AND FK1.FK1_FILORI = ? "		//#03 
    cQuery += " AND FK1.FK1_TPDOC IN ('VL', 'BA', 'V2', 'CP', 'LJ') "

	If __lCmpoFK1
    	cQuery += " AND ((FK1.FK1_DATA <= ? AND ? = '0') "	//(#10/#11) ou (#04/#05)
    	cQuery += " OR (FK1.FK1_DTDISP <= ? AND ? = '1') "	//(#12/#13) ou (#06/#07)
    	cQuery += " OR (FK1.FK1_DTDIGI <= ? AND ? = '2')) "	//(#14/#15) ou (#08/#09)
	Else
		cQuery += " AND FK1.FK1_DATA <= ? "
	EndIf
    cQuery += " AND NOT (FK1.FK1_TPDOC = 'VL' AND FK1.FK1_ORIGEM = 'LOJXREC' AND ? = 'R') "		//#16 ou #10
    cQuery += " AND ((FK1.FK1_RECPAG = ?) OR (FK1.FK1_RECPAG = ? AND FK1.FK1_DOC != ' ' )) "	//(#17/#18) ou (#11/#12)
    cQuery += " AND NOT EXISTS( "
    cQuery += " SELECT FK1EST.FK1_IDDOC FROM " + RetSQLName("FK1") +" FK1EST"
    cQuery += " WHERE FK1EST.FK1_FILIAL = FK1.FK1_FILIAL"
    cQuery += " AND FK1EST.FK1_IDDOC = FK1.FK1_IDDOC "
    cQuery += " AND FK1EST.FK1_SEQ = FK1.FK1_SEQ "
    cQuery += " AND FK1EST.FK1_DOC = FK1.FK1_DOC "
    cQuery += " AND FK1EST.FK1_TPDOC = 'ES' "
	If __lCmpoFK1
    	cQuery += " AND ((FK1EST.FK1_DATA <= ? AND ? = '0') "	//(#19/#20) ou (#13/#14)
    	cQuery += " OR (FK1EST.FK1_DTDISP <= ? AND ? = '1') "	//(#21/#22) ou (#15/#16)
    	cQuery += " OR (FK1EST.FK1_DTDIGI <= ? AND ? = '2')) "	//(#23/#24) ou (#17/#18)
	Else
		cQuery += " AND FK1EST.FK1_DATA <= ? "
	EndIf
    cQuery += " AND FK1EST.D_E_L_E_T_ = ' ') "
    cQuery += " GROUP BY FK1.FK1_FILIAL, FK1.FK1_IDFK1, FK1.FK1_DATA, FK1.FK1_TXMOED"

    cQuery := ChangeQuery(cQuery)

Return cQuery

/*/{Protheus.doc} FinFK6Pag
Construção da query de soma do VA para títulos a pagar (SE2).

@type       function
@author     Rafael Riego
@since      19/01/2020
@return     character, query para somatória do VA
/*/
Static Function FinFK6Pag() As Character

    Local cQuery    As Character

	cQuery := " SELECT FK2.FK2_DATA FKDATA, FK2.FK2_TXMOED TXMOEDA, COALESCE(SUM(CASE WHEN FK6.FK6_ACAO = '1' THEN FK6.FK6_VALMOV ELSE -FK6.FK6_VALMOV END), 0) VA"
    cQuery += " FROM " + RetSQLName("FK2") + " FK2 "
    cQuery += " INNER JOIN " + RetSQLName("FK6") + " FK6 ON "
    // Filtros JOIN FK2 x FK6
    cQuery += " FK6.FK6_FILIAL = FK2.FK2_FILIAL "
    cQuery += " AND FK6.FK6_IDORIG = FK2.FK2_IDFK2 "
    cQuery += " AND FK6.FK6_TABORI = 'FK2' "
    cQuery += " AND FK6.FK6_TPDOC = 'VA' "
    cQuery += " AND FK6.D_E_L_E_T_ = ' ' "
    // Filtros FK2
    cQuery += " WHERE "
    cQuery += " FK2.FK2_FILIAL = ? " //#1
	cQuery += " AND FK2.FK2_IDDOC = ?"		//#02
    cQuery += " AND FK2.D_E_L_E_T_ = ' ' "
    cQuery += " AND FK2.FK2_FILORI = ? "		//#09 ou #03 
    cQuery += " AND FK2.FK2_TPDOC IN ('VL', 'BA', 'V2', 'CP', 'LJ') "
	If __lCmpoFK2
    	cQuery += " AND ((FK2.FK2_DATA <= ? AND ? = '0') "		//(#10/#11) ou (#04/#05)
    	cQuery += " OR (FK2.FK2_DTDISP <= ? AND ? = '1') "		//(#12/#13) ou (#06/#07)
    	cQuery += " OR (FK2.FK2_DTDIGI <= ? AND ? = '2')) "		//(#14/#15) ou (#08/#09)
	Else
		cQuery += " AND FK2.FK2_DATA <= ? "
	EndIf
    cQuery += " AND NOT (FK2.FK2_TPDOC = 'VL' AND FK2.FK2_ORIGEM = 'LOJXREC' AND ? = 'R') "		//#16 ou #10
    cQuery += " AND ((FK2.FK2_RECPAG = ?) OR (FK2.FK2_RECPAG = ? AND FK2.FK2_DOC != ' ' )) "	//(#17/#18) ou (#11/#12)
    cQuery += " AND NOT EXISTS( "
    cQuery += " SELECT FK2EST.FK2_IDDOC FROM " + RetSQLName("FK2") +" FK2EST"
    cQuery += " WHERE FK2EST.FK2_FILIAL = FK2.FK2_FILIAL"
    cQuery += " AND FK2EST.FK2_IDDOC = FK2.FK2_IDDOC "
    cQuery += " AND FK2EST.FK2_SEQ = FK2.FK2_SEQ "
    cQuery += " AND FK2EST.FK2_DOC = FK2.FK2_DOC "
    cQuery += " AND FK2EST.FK2_TPDOC = 'ES' "
	If __lCmpoFK2
    	cQuery += " AND ((FK2EST.FK2_DATA <= ? AND ? = '0') "		//(#19/#20) ou (#13/#14)
    	cQuery += " OR (FK2EST.FK2_DTDISP <= ? AND ? = '1') "		//(#21/#22) ou (#15/#16)
    	cQuery += " OR (FK2EST.FK2_DTDIGI <= ? AND ? = '2')) "		//(#23/#24) ou (#17/#18)
	Else
		cQuery += " AND FK2EST.FK2_DATA <= ? "
	EndIf
    cQuery += " AND FK2EST.D_E_L_E_T_ = ' ') "
    cQuery += " GROUP BY FK2.FK2_FILIAL, FK2.FK2_IDFK2, FK2.FK2_DATA, FK2.FK2_TXMOED"

    cQuery := ChangeQuery(cQuery)

Return cQuery


//-------------------------------------------------------------------------------
/*/{Protheus.doc} FExecFixN
Verifica se uma rotina de atualização de base (FIX) já foi executada

@author 	Pâmela Bernardo
@since 		01/10/2020
@version	P12
@param 		cEmp, characters, código da empresafilial
@return 	logical, Lógico indicado se a rotina ja foi executada anteriormente
/*/
//-------------------------------------------------------------------------------
Function FExecFixN(cFix As Character) as Logical

	Local cMVFinFix As Character
	Local lRet  	As Logical
	
	lRet	    := .F.
    cMVFinFix   := GetMV("MV_FINFIX")       //Verifico se tenho o novo parâmetro
	
	//Verifico se existe o parâmetro e se já a rotina já foi executada
	If !Empty(cMVFinFix)
		If Val(cMVFinFix) >= Val(cFix)	//Se executou a rotina
			lRet	:= .T.
		EndIf	
	EndIf

Return lRet


/*/{Protheus.doc} FinxMsgE
Apresenta tela de Mensagem para que seja possivel ver e gravar o erro.

@author 	Reene Julian
@since 		04/02/2021
@version	P12
@param 		cMensagem caracter com a mensagem a ser apresentada e salva
@return 	
/*/
Function  FinxMsgE(cMensagem )

    Local oGroup As Object 
    Local oTBitmap1 As Object
    Local oGroup1 As Object
    Local oTFont1 As Object
    Local oSay1 As Object
    Local oScr2 As Object     
    Local oButton1 As Object  
    Local oButton2 As Object 
    Local oButton3 As Object 
    Local lDetalhe As Logical  
    Local cTexto1 As Character  

    Default  cMensagem := ""

    cTexto1 :=  STR0096 // "Ocorreu um erro no processamento, o que impede a conclusão do processo atual, por favor salvar as informações abaixo e encaminhar ao administrador do sistema."
    lDetalhe := .F. 
  
    
    DEFINE DIALOG oDlg TITLE STR0100 FROM 180,180 TO 365,580 PIXEL //180,180 TO 530,580 PIXEL

    oGroup := TGroup():New(00,00,30,202,'',oDlg,,,.T.)
     

     oTBitmap1 := TBitmap():New(00,00,260,184,,"OPENCLOSING_MDI.PNG",.T.,oGroup,;
    {|| .T. },,.F.,.F.,,,.F.,,.T.,,.F.)        
    oTBitmap1:lAutoSize := .T.
    

    oGroup1:= TGroup():New(33,01,091,200,'',oDlg,,,.T.)
    oTFont1 := TFont():New('Arial',,-15,.F.)
    oTFont2 := TFont():New('Arial',,-11,.F.)
    oSay1:= TSay():New(36,05,{||cTexto1},oGroup1,,oTFont1,,,,.T.,CLR_BLACK,CLR_WHITE,198,60)


     oScr2 := TScrollBox():New(oGroup1,59,05,100,190,.T.,.F.,.T.)      
     oScr2:hide()    
     oSay2:= TSay():New(05,05,{||cMensagem},oScr2,,oTFont2,,,,.T.,CLR_BLACK,CLR_WHITE,200,1000)


    oButton1 := TButton():New( 075,05, STR0097 ,oGroup1,{|| If(lDetalhe, lDetalhe := .F.,lDetalhe := .T.) ,;
                                                              If(!lDetalhe,oScr2:hide(),oScr2:Show() ) ,;                                                               
                                                              oSay1:oFont := If(lDetalhe , oTFont2 , oTFont1 ) ,;
                                                              oButton1:nTop := if(lDetalhe, 320 , 150 ),; 
                                                              oButton2:nTop := if(lDetalhe, 320 , 150 ),; 
                                                              oButton3:nTop := if(lDetalhe, 320 , 150 ),; 
                                                              oGroup1:nHeight := If( lDetalhe, 289 , 119 ) ,;
                                                              oDlg:nHeight := If( lDetalhe, 385 , 215 ) ,;
                                                              oDlg:Refresh()  },40,015,,,.F.,.T.,.F.,,.F.,,,.F.)    
    
    oButton2 := TButton():New( 075,155,STR0099 ,oGroup1,{|| oDlg:End() },40,015,,,.F.,.T.,.F.,,.F.,,,.F.)

    oButton3 := TButton():New( 075,55,STR0098 ,oGroup1,{|| FinxSArq(cMensagem) },40,015,,,.F.,.T.,.F.,,.F.,,,.F.) //160,55
 
    ACTIVATE DIALOG oDlg CENTERED
Return


/*/{Protheus.doc} FinxSArq
Apresenta tela para seleção de pasta e gravação do arquivo com a mensagem.

@author 	Reene Julian
@since 		04/02/2021
@version	P12
@param 		cMensagem caracter com a mensagem a ser salva
@return 	Logico verdadeiro mensagem salva falso mensagem nao pode ser salva.
/*/
Function FinxSArq(cMensagem) as Logical 
Local lRet As Logical 
local cDir As Character
local cParq As Character 
local nHandle As Numeric 

Default cMensagem := ""

lRet  := .F. 
ctmp := ""
cParq := ""
nHandle := 0

cDir  := getTempPath()
cParq := tFileDialog( "All files (*.*) | All Text files (*.txt) ",;
        STR0101,, cDir, .T., GETF_MULTISELECT   )

nHandle := FCREATE(cParq)        

If nHandle = -1
        MsgAlert(STR0102+ CRLF + STR0103 + Str(Ferror()))
    Else
        FWrite(nHandle, cMensagem )
        FClose(nHandle)
        lRet := .T.
        If File(cParq) 
            MsgInfo(STR0104)
        EndIf    
    Endif

Return lRet 

//------------------------------------------------------------------------------------------------
/*/{Protheus.doc}SldTitFK
Retorna o saldo do títulos na data informada para as baixas

@param cPrefixo   - Numero do Prefixo
@param cNumero    - Numero do Titulo
@param cParcela   - Parcela
@param cTipo      - Tipo
@param cNatureza  - Natureza
@param cCliFor    - Cliente
@param nMoedaTit  - Moeda do título
@param dData      - Data para conversao
@param dDataBaixa - Data data baixa a ser considerada (retroativa)
@param cLOja      - Loja do titulo
@param cFilTit    - Filial do titulo
@param nTxMoeda   - Taxa da Moeda
@param cTipoData  - Tipo de data para compor saldo (baixa/dispo/digit)
@param nSaldo  	  - Saldo bruto do título
@param Carteira	  - Carteira do título a ser processada


@author Pâmela Bernardo
@since  02/02/2021
@version 12
/*/
//------------------------------------------------------------------------------------------------
Static Function SldTitFK(cPrefixo,cNumero,cParcela,cTipo,cNatureza,cCliFor,nMoedaTit,dData,;
						 dDataBaixa,cLoja,cFilTit,nTxMoeda,cTipoData,lCmpMulFil,nSaldo,cCart,aMotBx)

	Local cQuery	As Character
	Local cChaveTit	As Character
	Local cIdDoc	As Character
	Local cAliasTMP As Character
	Local nRet		As Numeric
	Local nVa		As Numeric
	Local nMoedBx	As Numeric
	Local laMotBx	As Logical
	Local lMovM2	As Logical

	cQuery 		:= ""
	cIdDoc 		:= ""
	cAliasTMP	:= ""
	nRet 		:= nSaldo
	nVa 		:= 0
	nMoedBx		:= 1
	lMovM2		:= .F.

	Default aMotBx := {}
	laMotBx	:= !Empty(aMotBx)
	
	If cCart == "R"
		cChaveTit := xFilial("SE1",cFilTit ) + "|" + cPrefixo + "|" + cNumero + "|" + cParcela+ "|" +;
					cTipo  + "|" + cCliFor + "|" + cLoja

		cIdDoc    := FINBuscaFK7(cChaveTit, "SE1") 

		If __oSldtit == Nil
			cQuery := " SELECT FK1_IDFK1, FK1_VALOR, FK1_VLMOE2, FK1_DATA, FK1_TXMOED,FK1_MOEDA, "
			cQuery +=  " FK1_MOTBX, FK1_TPDOC, FK1_RECPAG "
			cQuery += "FROM " + RetSqlName("FK1") + " FK1 "
			cQuery += "WHERE FK1.FK1_IDDOC = ? "
			If cTipoData == "0"
				cQuery += "AND FK1.FK1_DATA <= ? "
			ElseIf cTipoData == "1"
				cQuery += "AND FK1.FK1_DTDISP <= ? "
			Else
				cQuery += "AND FK1.FK1_DTDIGI <= ? "
			EndIf

			If laMotBx
				cQuery += "AND FK1.FK1_MOTBX IN (?) "	
			EndIF

			cQuery += "AND FK1.FK1_ORIGEM <> 'LOJXREC' "
			cQuery += "AND FK1.D_E_L_E_T_ = ''  "
			cQuery += "AND NOT EXISTS( SELECT FK1EST.FK1_IDDOC "
			cQuery += 	"FROM " + RetSqlName("FK1") + " FK1EST  "
			cQuery += 	"WHERE "
			cQuery += 	"FK1EST.FK1_IDDOC = ?  "
			cQuery += 	"AND FK1EST.FK1_SEQ = FK1.FK1_SEQ   "
			cQuery += 	"AND FK1EST.FK1_TPDOC = 'ES'   "
				
			If cTipoData == "0"
				cQuery += "AND FK1EST.FK1_DATA <= ? "
			ElseIf cTipoData == "1"
				cQuery += "AND FK1EST.FK1_DTDISP <= ? "
			Else
				cQuery += "AND FK1EST.FK1_DTDIGI <= ? "
			EndIf

			If laMotBx
				cQuery += "AND FK1EST.FK1_MOTBX IN (?) "	
			EndIF

			cQuery += "AND FK1EST.D_E_L_E_T_ = ' '  ) "

			cQuery := ChangeQuery(cQuery)
			__oSldtit:=FWPreparedStatement():New(cQuery)
			
		EndIf
	Else
		cChaveTit := xFilial("SE2",cFilTit ) + "|" + cPrefixo + "|" + cNumero + "|" + cParcela+ "|" +;
					cTipo  + "|" + cCliFor + "|" + cLoja

		cIdDoc    := FINBuscaFK7(cChaveTit, "SE2") 

		If __oSldtit == Nil
			cQuery := " SELECT FK2_IDFK2, FK2_VALOR, FK2_VLMOE2, FK2_DATA, FK2_TXMOED, FK2_MOEDA, "
			cQuery +=  " FK2_MOTBX, FK2_TPDOC, FK2_RECPAG "
			cQuery += "FROM " + RetSqlName("FK2") + " FK2 "
			cQuery += "WHERE FK2.FK2_IDDOC = ? "
			If cTipoData == "0"
				cQuery += "AND FK2.FK2_DATA <= ? "
			ElseIf cTipoData == "1"
				cQuery += "AND FK2.FK2_DTDISP <= ? "
			Else
				cQuery += "AND FK2.FK2_DTDIGI <= ? "
			EndIf

			If laMotBx
				cQuery += "AND FK2.FK2_MOTBX IN (?) "	
			EndIF

			cQuery += "AND FK2.D_E_L_E_T_ = ''  "
			cQuery += "AND NOT EXISTS( SELECT FK2EST.FK2_IDDOC "
			cQuery += 	"FROM " + RetSqlName("FK2") + " FK2EST  "
			cQuery += 	"WHERE "
			cQuery += 	"FK2EST.FK2_IDDOC = ?  "
			cQuery += 	"AND FK2EST.FK2_SEQ = FK2.FK2_SEQ   "
			cQuery += 	"AND FK2EST.FK2_TPDOC = 'ES'   "
				
			If cTipoData == "0"
				cQuery += "AND FK2EST.FK2_DATA <= ? "
			ElseIf cTipoData == "1"
				cQuery += "AND FK2EST.FK2_DTDISP <= ? "
			Else
				cQuery += "AND FK2EST.FK2_DTDIGI <= ? "
			EndIf

			If laMotBx
				cQuery += "AND FK2EST.FK2_MOTBX IN (?) "	
			EndIF

			cQuery += "AND FK2EST.D_E_L_E_T_ = ' '  ) "

			cQuery := ChangeQuery(cQuery)
			__oSldtit:=FWPreparedStatement():New(cQuery)
			
		EndIf
	EndIf

	If laMotBx
		__oSldtit:SetString(1,cIdDoc)
		__oSldtit:SetString(2,dToS(dDataBaixa))
		__oSldtit:SetIn(3,aMotBx)
		__oSldtit:SetString(4,cIdDoc)
		__oSldtit:SetString(5,dToS(dDataBaixa))
		__oSldtit:SetIn(6,aMotBx)	
	Else
		__oSldtit:SetString(1,cIdDoc)
		__oSldtit:SetString(2,dToS(dDataBaixa))
		__oSldtit:SetString(3,cIdDoc)
		__oSldtit:SetString(4,dToS(dDataBaixa))
	Endif
	
	cQuery := __oSldtit:GetFixQuery()
	cAliasTMP := mpsysopenquery(cQuery)

	If !(cAliasTMP)->(Eof())
		If cCart == "R" .and. (SE1->E1_ACRESC+SE1->E1_DECRESC) > 0
			nRet-=SE1->E1_ACRESC
			nRet+=SE1->E1_DECRESC
		ElseIf cCart == "P" .and. (SE2->E2_ACRESC+SE2->E2_DECRESC) > 0
			nRet-=SE2->E2_ACRESC
			nRet+=SE2->E2_DECRESC
		EndIf
	EndIf

	While !(cAliasTMP)->(Eof()) 
		
		lCmpMulFil := .F.

		If cCart == "R"
			lMovM2 := (cAliasTMP)->FK1_MOTBX == "CMP" .And. MovMoedEs((cAliasTMP)->FK1_MOEDA, (cAliasTMP)->FK1_TPDOC, (cAliasTMP)->FK1_MOTBX, DTOS(dDataBaixa), (cAliasTMP)->FK1_RECPAG)
			IF(cPaisLoc=="BRA" .and. (nMoedaTit < 2 .Or. lMovM2)) .Or.; 
				(cPaisLoc <>"BRA" .And. nMoedaTit > 1 .And. (cAliasTMP)->FK1_MOEDA=="0"+cValtoChar(nMoedaTit))
				nRet -= (cAliasTMP)->FK1_VALOR
			Else
				nRet -= (cAliasTMP)->FK1_VLMOE2
				nMoedBx := Val((cAliasTMP)->FK1_MOEDA)
			EndIf
			
			nVa := FinTotFK6((cAliasTMP)->FK1_IDFK1, "FK1") 
			nVA := Round(NoRound(xMoeda(nVA,nMoedBx,nMoedaTit,(cAliasTMP)->FK1_DATA,3,,IIF((cAliasTMP)->FK1_TXMOED==0,nTxMoeda,(cAliasTMP)->FK1_TXMOED)),3),2)
		Else
			lMovM2 := (cAliasTMP)->FK2_MOTBX == "CMP" .And. MovMoedEs((cAliasTMP)->FK2_MOEDA, (cAliasTMP)->FK2_TPDOC, (cAliasTMP)->FK2_MOTBX, DTOS(dDataBaixa), (cAliasTMP)->FK2_RECPAG)
			IF(cPaisLoc=="BRA" .and. (nMoedaTit < 2 .Or. lMovM2)) .Or.;
				(cPaisLoc <>"BRA" .And. nMoedaTit > 1 .And. (cAliasTMP)->FK2_MOEDA == "0"+cValtoChar(nMoedaTit))
				nRet -= (cAliasTMP)->FK2_VALOR
			Else
				nRet -= (cAliasTMP)->FK2_VLMOE2
				nMoedBx := Val((cAliasTMP)->FK2_MOEDA)
			EndIf
			
			nVa := FinTotFK6((cAliasTMP)->FK2_IDFK2, "FK2") 
			nVA := Round(NoRound(xMoeda(nVA,nMoedBx,nMoedaTit,(cAliasTMP)->FK2_DATA,3,,IIF((cAliasTMP)->FK2_TXMOED==0,nTxMoeda,(cAliasTMP)->FK2_TXMOED)),3),2)
		EndIF	

		nRet += nVA

		(cAliasTMP)->(dbSkip())
	EndDo
	
	(cAliasTMP)->(dbCloseArea())
	MsErase(cAliasTMP)


Return nRet

//------------------------------------------------------------------------------------------------
/*/{Protheus.doc}FinTotFK6
Retorna o total de valores acessórios que afetam o os valores de baixas, juros, multas, descontos e VA

@param cIdFKs - ID da baixa (FK1/FK2)
@param cTabOri - tabela de origem do ID(FK1/FK2)
@author Pâmela Bernardo
@since  15/01/2021
@version 12
/*/
//------------------------------------------------------------------------------------------------
Function FinTotFK6(cIdFKs As Character, cTabOri As Character) As Numeric

	Local nTotFk6  	As Numeric
	Local cQuery	As Character
	Local cAliasFK6 As Character

	Default cIdFKs := ""
	Default cTabOri := ""
	
	nTotFk6 := 0
	cQuery  := ""
	cAliasFK6 := ""

	If __oPrepFK6 == Nil
		cQuery := " SELECT COALESCE(SUM(CASE WHEN FK6.FK6_TPDOC NOT IN ('DC', 'D2' ) THEN FK6.FK6_VALMOV ELSE -FK6.FK6_VALMOV END),0) TOTFK6 "
		cQuery += "From " + RetSqlName("FK6") + " FK6 "
		cQuery += "Where FK6.FK6_FILIAL = ?  "
		cQuery += "AND FK6.FK6_IDORIG = ? "
		cQuery += "AND FK6.FK6_TABORI = ? "
		cQuery += "AND FK6.FK6_TPDOC NOT IN ('CM', 'VM','C2'  ) "
		cQuery += "AND FK6.D_E_L_E_T_ = ' '  "
		
		cQuery := ChangeQuery(cQuery)
		__oPrepFK6:=FWPreparedStatement():New(cQuery)
		
	EndIf

	__oPrepFK6:SetString(1,xFilial("FK6" ))
	__oPrepFK6:SetString(2,cIdFKs)
	__oPrepFK6:SetString(3,cTabOri)
	
	cQuery := __oPrepFK6:GetFixQuery()
	cAliasFK6 := mpsysopenquery(cQuery)

	If !(cAliasFK6)->(Eof()) 
		nTotFk6 := (cAliasFK6)->(TOTFK6)
	EndIf

	(cAliasFK6)->(dbCloseArea())


Return nTotFk6


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} DelSldTit
Destroy o objeto criado na FinTotFK6() e SldTitFK()

@Author	Pâmela Bernardo
@since	03/02/2021
/*/
//-----------------------------------------------------------------------------------------------------
Function DelSldTit()

	If __oSldtit != NIL
		__oSldtit:Destroy()
		__oSldtit := NIL
	Endif

	If __oPrepFK6 != NIL
		__oPrepFK6:Destroy()
		__oPrepFK6 := NIL
	Endif

Return

/*/{Protheus.doc} FinExistBx
Verifica se o título possui baixa com desconto até a data informada. Rotina utilizada para definir qual campo (valor ou saldo) do Decréscimo deverá ser utilizado para retroagir o saldo.

@type       function
@author     Rafael Riego
@since      10/02/2020
@param      cFilMov, character, filial do movimento (FK5_FILIAL/E5_FILIAL)
@param      cFilTit, character, filial do título (E1_FILIAL/E2_FILIAL) 
@param      cPrefixo, character, prefixo do título
@param      cNumero, character, número do título
@param      cParcela, character, parcela do título
@param      cTipo, character, tipo do título
@param      cCliFor, character, cliente/fornecedor do título
@param      cLoja, character, loja do título
@param      cCarteira, character, carteira do título
@param      dDataBaixa, date, data da baixa
@param      cTipoData, character, tipo da data a ser utilizada na pesquisa {"0" = E5_DATA; "1" = E5_DTDISPO; "2" = E5_DTDIGIT}
@param      cAdiant, character, IIf(cTipo $ MVRECANT+"/"+MVPAGANT+"/"+MV_CRNEG+"/"+MV_CPNEG), "1","0")
@param      dDataBase, date, database utilizada na soma
@param      cFilOri, character, filial de origem do título
@return     logical, verdadeiro caso exista alguma baixa igual ou inferior a data informada
/*/
Function FinExistBx(cFilMov As Character, cFilTit As Character, cPrefixo As Character, cNumero As Character, cParcela As Character, cTipo As Character, cCliFor As Character, cLoja As Character, cCarteira As Character, dDataBaixa As Date, cTipoData As Character, cAdiant As Character, dDataBase As Date, cFilOri As Character) As Logical

	Local aArea			As Array
    Local aBind			As Array

    Local cAliasTMP		As Character
    Local cCartAux		As Character
	Local cChaveFK7		As Character
    Local cDataBaixa	As Character
    Local cDataBase		As Character
    Local cFilialFK7	As Character
    Local cQuery		As Character

	Local lPossuiBx		As Logical

	If __lFK7Cpos == Nil
		__lFK7Cpos	:= FK7->(ColumnPos("FK7_CLIFOR")) > 0 .And. FindFunction("FinFK7Cpos") .And. FExecFixN("2")
	EndIf

	aArea		:= GetArea()
	cCartAux	:= cCarteira
	cDataBaixa	:= DToS(dDataBaixa)
	cDataBase	:= DToS(dDataBase)
	cFilialFK7	:= FwXFilial("FK7", cFilMov)
	lPossuiBx	:= .F.

	If __lCmpoFK1 == Nil .Or. __lCmpoFK2 == Nil
		__lCmpoFK1 := FK1->(FieldPos("FK1_DTDISP")) > 0 .And. FK1->(FieldPos("FK1_DTDIGI")) > 0
		__lCmpoFK2 := FK2->(FieldPos("FK2_DTDISP")) > 0 .And. FK2->(FieldPos("FK2_DTDIGI")) > 0 
	EndIf

	If cAdiant == "1"
		If cCartAux == "P"
			cCartAux := "R"
		Else
			cCartAux := "P"
		EndIf
	EndIf

	//cTipoData := "0"  // FK1_DATA/FK2_DATA
	//cTipoData := "1"  // FK1_DTDISP/FK2_DTDISP
	//cTipoData := "2"  // FK1_DTDIGI/FK2_DTDIGI
	If cCartAux == "P"
		If !__lCmpoFK2 .And. cTipoData $ "1|2"
			Return lPossuiBx
		EndIf
		If Empty(__cQryBxP)
			__cQryBxP := FinBxPag()
		EndIf
		cQuery := __cQryBxP
	Else
		If !__lCmpoFK1 .And. cTipoData $ "1|2"
			Return lPossuiBx
		EndIf
		If Empty(__cQryBxR)
			__cQryBxR := FinBxRec()
		EndIf
		cQuery := __cQryBxR
	EndIf

	//Necessário aplicação do FIX para liberação deste trecho
	If __lFK7Cpos
		If (__lCmpoFK1 .And. cCartAux == "R") .Or. (__lCmpoFK2 .And. cCartAux == "P")
			aBind := {;
				cFilialFK7      ,;//#01
				cFilTit         ,;//#02
				cPrefixo        ,;//#03
				cNumero         ,;//#04
				cParcela        ,;//#05
				cTipo           ,;//#06
				cCliFor         ,;//#07
				cLoja           ,;//#08
				cFilOri         ,;//#09 
				cDataBaixa      ,;//#10 
				cTipoData       ,;//#11
				cDataBaixa      ,;//#12
				cTipoData       ,;//#13
				cDataBaixa      ,;//#14
				cTipoData       ,;//#15
				cCartAux        ,;//#16
				cCartAux        ,;//#17
				cCarteira       ,;//#18
				cDataBase       ,;//#19
				cTipoData       ,;//#20
				cDataBase       ,;//#21
				cTipoData       ,;//#22
				cDataBase       ,;//#23
				cTipoData       } //#24
		Else
			aBind := {;
				cFilialFK7      ,;//#01
				cFilTit         ,;//#02
				cPrefixo        ,;//#03
				cNumero         ,;//#04
				cParcela        ,;//#05
				cTipo           ,;//#06
				cCliFor         ,;//#07
				cLoja           ,;//#08
				cFilOri         ,;//#09 
				cDataBaixa      ,;//#10
				cCartAux        ,;//#11
				cCartAux        ,;//#12
				cCarteira       ,;//#13
				cDataBase       } //#14
		EndIf
	Else
		cChaveFK7 := cFilTit + "|" + cPrefixo + "|" + cNumero + "|" + cParcela + "|" + cTipo + "|" + cCliFor + "|" + cLoja
		If (__lCmpoFK1 .And. cCartAux == "R") .Or. (__lCmpoFK2 .And. cCartAux == "P")
			aBind := {;
				cFilialFK7      ,;//#01
				cChaveFK7		,;//#02
				cFilOri         ,;//#03
				cDataBaixa      ,;//#04
				cTipoData       ,;//#05
				cDataBaixa      ,;//#06
				cTipoData       ,;//#07
				cDataBaixa      ,;//#08
				cTipoData       ,;//#09
				cCartAux        ,;//#10
				cCartAux        ,;//#11
				cCarteira       ,;//#12
				cDataBase       ,;//#13
				cTipoData       ,;//#14
				cDataBase       ,;//#15
				cTipoData       ,;//#16
				cDataBase       ,;//#17
				cTipoData       } //#18
		Else
			aBind := {;
				cFilialFK7      ,;//#01
				cChaveFK7		,;//#02
				cFilOri         ,;//#03
				cDataBaixa      ,;//#04
				cCartAux        ,;//#05
				cCartAux        ,;//#06
				cCarteira       ,;//#07
				cDataBase       } //#08
		EndIf
	EndIf

	cAliasTMP := GetNextAlias()

	DbUseArea(.T., "TOPCONN", TCGenQry2(Nil, Nil, cQuery, aBind), cAliasTMP, .F., .T.)

	If (cAliasTMP)->(!(EoF()))
		lPossuiBx := .T.
	EndIf

	(cAliasTMP)->(DbCloseArea())
	FwFreeArray(aBind)
	RestArea(aArea)

Return lPossuiBx

/*/{Protheus.doc} FinBxPag
Efetua a montagem da query para verificação de baixas de títulos a pagar.

@type       function
@author     Rafael Riego
@since      10/02/2020
@return     character, query montada com bind para pesquisa de baixa
/*/
Static Function FinBxPag() As Character

	Local cQuery	As Character

	If __lFK7Cpos == Nil
		__lFK7Cpos	:= FK7->(ColumnPos("FK7_CLIFOR")) > 0 .And. FindFunction("FinFK7Cpos") .And. FExecFixN("2")
	EndIf

    cQuery := " SELECT FK2.FK2_FILIAL "
    cQuery += " FROM " + RetSQLName("FK7") + " FK7 "
    cQuery += " INNER JOIN " + RetSQLName("FK2") + " FK2 ON "
    // Filtros JOIN FK7 x FK2
    cQuery += " FK2.FK2_FILIAL = FK7.FK7_FILIAL "
    cQuery += " AND FK2.FK2_IDDOC = FK7.FK7_IDDOC "
    cQuery += " AND FK2.D_E_L_E_T_ = ' ' "
	cQuery += " INNER JOIN " + RetSQLName("FK6") + " FK6 ON "
    // Filtros JOIN FK2 x FK6
    cQuery += " FK6.FK6_FILIAL = FK2.FK2_FILIAL "
    cQuery += " AND FK6.FK6_IDORIG = FK2.FK2_IDFK2 "
    cQuery += " AND FK6.FK6_TABORI = 'FK2' "
    cQuery += " AND FK6.FK6_TPDOC IN ('DC', 'D2') "
    cQuery += " AND FK6.D_E_L_E_T_ = ' ' "
    // Filtros FK7
    cQuery += " WHERE "
    cQuery += " FK7.FK7_FILIAL = ? " //#01

    If __lFK7Cpos
		cQuery += " AND FK7.FK7_FILTIT = ? "	//#02
    	cQuery += " AND FK7.FK7_PREFIX = ? "	//#03
    	cQuery += " AND FK7.FK7_NUM = ? "	 	//#04	
    	cQuery += " AND FK7.FK7_PARCEL = ? "	//#05
    	cQuery += " AND FK7.FK7_TIPO = ? "		//#06
    	cQuery += " AND FK7.FK7_CLIFOR = ? "	//#07
    	cQuery += " AND FK7.FK7_LOJA = ? "		//#08
	Else
		cQuery += " AND FK7.FK7_CHAVE = ?"		//#02
	EndIf

    cQuery += " AND FK7.FK7_ALIAS = 'SE2' "
    cQuery += " AND FK7.D_E_L_E_T_ = ' ' "
    // Filtros FK2
    cQuery += " AND FK2.FK2_FILORI = ? "		//#09 ou #03 
    cQuery += " AND FK2.FK2_TPDOC IN ('VL', 'BA', 'V2', 'CP', 'LJ') "
	If __lCmpoFK2
    	cQuery += " AND ((FK2.FK2_DATA <= ? AND ? = '0') "		//(#10/#11) ou (#04/#05)
    	cQuery += " OR (FK2.FK2_DTDISP <= ? AND ? = '1') "		//(#12/#13) ou (#06/#07)
    	cQuery += " OR (FK2.FK2_DTDIGI <= ? AND ? = '2')) "		//(#14/#15) ou (#08/#09)
	Else
		cQuery += " AND FK2.FK2_DATA <= ? "
	EndIf
    cQuery += " AND NOT (FK2.FK2_TPDOC = 'VL' AND FK2.FK2_ORIGEM = 'LOJXREC' AND ? = 'R') "		//#16 ou #10
    cQuery += " AND ((FK2.FK2_RECPAG = ?) OR (FK2.FK2_RECPAG = ? AND FK2.FK2_DOC != ' ' )) "	//(#17/#18) ou (#11/#12)
    cQuery += " AND NOT EXISTS( "
    cQuery += " SELECT FK2EST.FK2_IDDOC FROM " + RetSQLName("FK2") +" FK2EST"
    cQuery += " WHERE FK2EST.FK2_FILIAL = FK2.FK2_FILIAL"
    cQuery += " AND FK2EST.FK2_IDDOC = FK2.FK2_IDDOC "
    cQuery += " AND FK2EST.FK2_SEQ = FK2.FK2_SEQ "
    cQuery += " AND FK2EST.FK2_DOC = FK2.FK2_DOC "
    cQuery += " AND FK2EST.FK2_TPDOC = 'ES' "
	If __lCmpoFK2
    	cQuery += " AND ((FK2EST.FK2_DATA <= ? AND ? = '0') "		//(#19/#20) ou (#13/#14)
    	cQuery += " OR (FK2EST.FK2_DTDISP <= ? AND ? = '1') "		//(#21/#22) ou (#15/#16)
    	cQuery += " OR (FK2EST.FK2_DTDIGI <= ? AND ? = '2')) "		//(#23/#24) ou (#17/#18)
	Else
		cQuery += " AND FK2EST.FK2_DATA <= ? "
	EndIf
    cQuery += " AND FK2EST.D_E_L_E_T_ = ' ') "

    cQuery := ChangeQuery(cQuery)

Return cQuery

/*/{Protheus.doc} FinBxRec
Efetua a montagem da query para verificação de baixas de títulos a receber.

@type       function
@author     Rafael Riego
@since      10/02/2020
@return     character, query montada com bind para pesquisa de baixa
/*/
Static Function FinBxRec() As Character

	Local cQuery	As Character

	If __lFK7Cpos == Nil
		__lFK7Cpos	:= FK7->(ColumnPos("FK7_CLIFOR")) > 0 .And. FindFunction("FinFK7Cpos") .And. FExecFixN("2")
	EndIf

    cQuery := " SELECT FK1.FK1_FILIAL "
    cQuery += " FROM " + RetSQLName("FK7") + " FK7 "
    cQuery += " INNER JOIN " + RetSQLName("FK1") + " FK1 ON "
    // Filtros JOIN FK7 x FK1
    cQuery += " FK1.FK1_FILIAL = FK7.FK7_FILIAL "
    cQuery += " AND FK1.FK1_IDDOC = FK7.FK7_IDDOC "
    cQuery += " AND FK1.D_E_L_E_T_ = ' ' "
	cQuery += " INNER JOIN " + RetSQLName("FK6") + " FK6 ON "
    // Filtros JOIN FK1 x FK6
    cQuery += " FK6.FK6_FILIAL = FK1.FK1_FILIAL "
    cQuery += " AND FK6.FK6_IDORIG = FK1.FK1_IDFK1 "
    cQuery += " AND FK6.FK6_TABORI = 'FK1' "
    cQuery += " AND FK6.FK6_TPDOC IN ('DC', 'D2') "
    cQuery += " AND FK6.D_E_L_E_T_ = ' ' "
    // Filtros FK7
    cQuery += " WHERE "
    cQuery += " FK7.FK7_FILIAL = ? " //#01

    If __lFK7Cpos
		cQuery += " AND FK7.FK7_FILTIT = ? "	//#02
    	cQuery += " AND FK7.FK7_PREFIX = ? "	//#03
    	cQuery += " AND FK7.FK7_NUM = ? "	 	//#04	
    	cQuery += " AND FK7.FK7_PARCEL = ? "	//#05
    	cQuery += " AND FK7.FK7_TIPO = ? "		//#06
    	cQuery += " AND FK7.FK7_CLIFOR = ? "	//#07
    	cQuery += " AND FK7.FK7_LOJA = ? "		//#08
	Else
		cQuery += " AND FK7.FK7_CHAVE = ?"		//#02
	EndIf

    cQuery += " AND FK7.FK7_ALIAS = 'SE1' "
    cQuery += " AND FK7.D_E_L_E_T_ = ' ' "
    // Filtros FK1
    cQuery += " AND FK1.FK1_FILORI = ? "		//#09 ou #03 
    cQuery += " AND FK1.FK1_TPDOC IN ('VL', 'BA', 'V2', 'CP', 'LJ') "
	If __lCmpoFK1
    	cQuery += " AND ((FK1.FK1_DATA <= ? AND ? = '0') "	//(#10/#11) ou (#04/#05)
    	cQuery += " OR (FK1.FK1_DTDISP <= ? AND ? = '1') "	//(#12/#13) ou (#06/#07)
    	cQuery += " OR (FK1.FK1_DTDIGI <= ? AND ? = '2')) "	//(#14/#15) ou (#08/#09)
	Else
		cQuery += " AND FK1.FK1_DATA <= ? "
	EndIf
    cQuery += " AND NOT (FK1.FK1_TPDOC = 'VL' AND FK1.FK1_ORIGEM = 'LOJXREC' AND ? = 'R') "		//#16 ou #10
    cQuery += " AND ((FK1.FK1_RECPAG = ?) OR (FK1.FK1_RECPAG = ? AND FK1.FK1_DOC != ' ' )) "	//(#17/#18) ou (#11/#12)
    cQuery += " AND NOT EXISTS( "
    cQuery += " SELECT FK1EST.FK1_IDDOC FROM " + RetSQLName("FK1") +" FK1EST"
    cQuery += " WHERE FK1EST.FK1_FILIAL = FK1.FK1_FILIAL"
    cQuery += " AND FK1EST.FK1_IDDOC = FK1.FK1_IDDOC "
    cQuery += " AND FK1EST.FK1_SEQ = FK1.FK1_SEQ "
    cQuery += " AND FK1EST.FK1_DOC = FK1.FK1_DOC "
    cQuery += " AND FK1EST.FK1_TPDOC = 'ES' "
	If __lCmpoFK1
    	cQuery += " AND ((FK1EST.FK1_DATA <= ? AND ? = '0') "	//(#19/#20) ou (#13/#14)
    	cQuery += " OR (FK1EST.FK1_DTDISP <= ? AND ? = '1') "	//(#21/#22) ou (#15/#16)
    	cQuery += " OR (FK1EST.FK1_DTDIGI <= ? AND ? = '2')) "	//(#23/#24) ou (#17/#18)
	Else
		cQuery += " AND FK1EST.FK1_DATA <= ? "
	EndIf

    cQuery += " AND FK1EST.D_E_L_E_T_ = ' ') "

    cQuery := ChangeQuery(cQuery)

Return cQuery

//----------------------------------------
/*/{Protheus.doc} FinAbatRec
Soma titulos de abatimento relacionado a um determinado titulo a receber.

@author Igor Nascimento
@since  04/02/2021
@version 12
/*/
//----------------------------------------
Static Function FinAbatRec(cPrefixo As Char, cNumero As Char, cParcela As Char, nMoeda As Numeric,;
					cCpo As Char, dData As Date, nTotAbImp As Numeric, nTotIrAbt As Numeric,;
					nTotCsAbt As Numeric, nTotPisAbt As Numeric, nTotCofAbt As Numeric,;
					nTotInsAbt As Numeric, cFilAbat As Char, nTxMoeda As Numeric, nTotISS As Numeric) As Numeric
	
	Local aArea     As Array
	Local aAreaSE1  As Array
	Local aTiposAbt	As Array
	Local cAlias    As Char
	Local cCliente  As Char
	Local cTipo     As Char
	Local cQuery    As Char
	Local cTmp      As Char
	Local cLoja     As Char	
	Local nTotAbat  As Numeric
	Local nI		As Numeric
	Local nY		As Numeric
	Local nLenTipos	As Numeric
	Local lIrPjBxCr As Logical
	Local lProc		As Logical
	Local lTemFilho As Logical
	
	//Parâmetros de entrada entrada da função.
	Default cPrefixo   := SE1->E1_PREFIXO
	Default cNumero    := SE1->E1_NUM
	Default cParcela   := SE1->E1_PARCELA
	Default nMoeda     := SE1->E1_MOEDA
	Default cCpo       := "V"
	Default dData      := dDatabase
	
	Begin Sequence
		cAlias     := Alias()
		aArea      := GetArea()
		cFilAbat   := xFilial("SE1", cFilAbat)
		nTotAbat   := 0
		nI         := 0
		nY         := 0
		lTemFilho  := .F.
		lIrPjBxCr  := FIrPjBxCr(.T.)
		lProc      := .T.
		
		If __cTipAbat == Nil
			__cTipAbat := PadR("AB-", TamSX3("E1_TIPO")[1])
		EndIf
		
		If Valtype(dData) == "C"
			dData := StoD(dData)
		EndIf
		
		If cAlias == "__SE1"
			cCliente := __SE1->E1_CLIENTE
			cLoja    := __SE1->E1_LOJA
			cTipo	 := __SE1->E1_TIPO
			dbSelectArea("__SE1")
		Else
			cCliente := SE1->E1_CLIENTE
			cLoja    := SE1->E1_LOJA
			cTipo    := SE1->E1_TIPO
			
			If Select("__SE1") == 0
				ChkFile("SE1", .F., "__SE1")
			Else
				dbSelectArea("__SE1")
			Endif
		Endif
		
		//RFC: se nao informei os dados do titulo, retorno sem abatimento
		If Empty(cPrefixo + cNumero + cParcela)
			BREAK
		Endif
		
		__SE1->(DbSetOrder(1))
		aAreaSE1 := __SE1->(GetArea())
		lProc    := __SE1->(MsSeek(cFilAbat+cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja))
		
		If lProc
			//Países localizados não possuem impostos que geram títulos a partir de um título pai
			If cPaisLoc == "BRA"
				If E1_TIPO $ MVABATIM .and. !Empty(AllTrim(E1_TITPAI))
					If MsSeek(cFilAbat+RTrim(E1_TITPAI),.T.)
						cPrefixo := E1_PREFIXO
						cNumero  := E1_NUM
						cParcela := E1_PARCELA
						cTipo    := E1_TIPO
						cCliente := E1_CLIENTE
						cLoja    := E1_LOJA
					Else
						RestArea(aAreaSE1)
						BREAK
					EndIf
				EndIf
			Endif
			
			If _aBindAbtR == Nil
				//Cache do bind para nao precisar montar o IN do MVABATIM toda chamada
				_aBindAbtR := { cFilAbat,; //#01
						PadR(cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja, TamSX3("E1_TITPAI")[1]) } //#02
				
				aTiposAbt := StrTokArr2(MVABATIM,"|")
				nLenTipos := Len(aTiposAbt)
				
				For nI := 1 To nLenTipos
					Aadd(_aBindAbtR,aTiposAbt[nI])	//Ordenacao dinamica do bind a partir da posicao #03
				Next nI
			Else	//Atualiza array do bind
				_aBindAbtR[1] := cFilAbat
				_aBindAbtR[2] := PadR(cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja, TamSX3("E1_TITPAI")[1])
			EndIf
			
			cTmp := GetNextAlias()
			
			If cCpo == "V" //E1_VALOR
				cQuery := AbatRecVal()
			Else //E1_SALDO
				cQuery := AbatRecSal()
			EndIf
			
			DbUseArea(.T., "TOPCONN", TCGenQry2(Nil, Nil, cQuery, _aBindAbtR), cTmp, .F., .T.)
			
			While (cTmp)->(!EoF())
				Do Case
					Case (cTmp)->E1_TIPO == MVIRABT
						nTotIrAbt += (cTmp)->VALOR
					
					Case (cTmp)->E1_TIPO == MVPIABT
						nTotPisAbt += (cTmp)->VALOR
					
					Case (cTmp)->E1_TIPO == MVCFABT
						nTotCofAbt += (cTmp)->VALOR
					
					Case (cTmp)->E1_TIPO == MVCSABT
						nTotCsAbt += (cTmp)->VALOR
					
					Case (cTmp)->E1_TIPO == MVINABT
						nTotInsAbt += (cTmp)->VALOR
					
					Case (cTmp)->E1_TIPO == MVISABT
						nTotISS += (cTmp)->VALOR
				EndCase
				
				If (cTmp)->E1_TIPO != __cTipAbat
					nTotAbImp += (cTmp)->VALOR
				EndIf
				
				nTotAbat += (cTmp)->VALOR
				(cTmp)->(DbSkip())
			EndDo
			
			(cTmp)->(dbCloseArea())
			
			If nMoeda > 1
				If nTotIrAbt > 0
					nTotIrAbt  := xMoeda(nTotIrAbt,(cAlias)->E1_MOEDA, nMoeda,dData,,,nTxMoeda)
				EndIf
				If nTotPisAbt > 0
					nTotPisAbt := xMoeda(nTotPisAbt,(cAlias)->E1_MOEDA, nMoeda,dData,,,nTxMoeda)
				EndIf
				If nTotCofAbt > 0
					nTotCofAbt := xMoeda(nTotCofAbt,(cAlias)->E1_MOEDA, nMoeda,dData,,,nTxMoeda)
				EndIf
				If nTotCsAbt > 0
					nTotCsAbt  := xMoeda(nTotCsAbt,(cAlias)->E1_MOEDA, nMoeda,dData,,,nTxMoeda)
				EndIf
				If nTotInsAbt > 0
					nTotInsAbt := xMoeda(nTotInsAbt,(cAlias)->E1_MOEDA, nMoeda,dData,,,nTxMoeda)
				EndIf
				If nTotISS > 0
					nTotISS    := xMoeda(nTotISS,(cAlias)->E1_MOEDA, nMoeda,dData,,,nTxMoeda)
				EndIf
				If lIrPjBxCr
					If nTotAbImp > 0
						nTotAbImp := xMoeda(nTotAbImp,(cAlias)->E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					EndIf
					If nTotAbat > 0
						nTotAbat  := xMoeda(nTotAbat,(cAlias)->E1_MOEDA, nMoeda,dData,,,nTxMoeda)
					EndIf
				Else
					If nTotAbImp > 0
						nTotAbImp := xMoeda(nTotAbImp,(cAlias)->E1_MOEDA, nMoeda,(cAlias)->E1_EMISSAO,,,)
					EndIf
					If nTotAbat > 0
						nTotAbat  := xMoeda(nTotAbat,(cAlias)->E1_MOEDA, nMoeda,(cAlias)->E1_EMISSAO,,,)
					EndIf
				EndIf
			EndIf
		Endif
		
		RestArea(aAreaSE1)
		FwFreeArray(aAreaSE1)
	End Sequence
	
	RestArea(aArea)
	FwFreeArray(aArea)
Return nTotAbat

//----------------------------------------
/*/{Protheus.doc}AbatRecVal
Monta a query da SumAbatRec utilizando o campo E1_VALOR, para 
	mante-la em cache

@return cQuery - String da query final para montar a temporaria da SumAbatRec
@author Igor Nascimento
@since  04/02/2021
@version 12
/*/
//----------------------------------------
Static Function AbatRecVal() As Char
	Local nLenTipos As Numeric
	Local nI		As Numeric
	
	If Empty(_cQryAbtRV)
		nLenTipos  := Len(_aBindAbtR)
		_cQryAbtRV += "SELECT SUM(E1_VALOR) VALOR, E1_TIPO FROM " + RetSQLName("SE1") 
		_cQryAbtRV += " WHERE E1_FILIAL = ?"    //#01
		_cQryAbtRV += " AND E1_TITPAI = ?"      //#02
		_cQryAbtRV += " AND E1_TIPO IN ("		//# A partir do 03
		
		For nI := 3 To nLenTipos
			_cQryAbtRV += "?,"	//# ordenacao dinamica do bind para o IN
		Next nI
		
		_cQryAbtRV := SubStr(_cQryAbtRV,1,Len(_cQryAbtRV)-1)	// Remove ultima virgula
		_cQryAbtRV += ") AND D_E_L_E_T_ = ' '"
		_cQryAbtRV += " GROUP BY E1_TIPO"
		_cQryAbtRV := ChangeQuery(_cQryAbtRV)
	EndIf
Return _cQryAbtRV

//----------------------------------------
/*/{Protheus.doc}AbatRecSal
Monta a query da SumAbatRec utilizando o campo E1_SALDO, para mante-la em cache

@return cQuery - String da query final para montar a temporaria da SumAbatRec
@author Igor Nascimento
@since  04/02/2021
@version 12
/*/
//----------------------------------------
Static Function AbatRecSal() As Char
	Local nLenTipos As Numeric
	Local nI		As Numeric
	
	If Empty(_cQryAbtRS)
		nLenTipos  := Len(_aBindAbtR)
		_cQryAbtRS += "SELECT SUM(E1_SALDO) VALOR, E1_TIPO FROM " + RetSQLName("SE1") 
		_cQryAbtRS += " WHERE E1_FILIAL = ?"    //#01
		_cQryAbtRS += " AND E1_TITPAI = ?"      //#02
		_cQryAbtRS += " AND E1_TIPO IN ("		//# A partir do 03
		
		For nI := 3 To nLenTipos
			_cQryAbtRS += "?,"	//# ordenacao dinamica do bind para o IN
		Next nI
		
		_cQryAbtRS := SubStr(_cQryAbtRS, 1, Len(_cQryAbtRS) - 1)	// Remove ultima virgula
		_cQryAbtRS += ") AND D_E_L_E_T_ = ' '"
		_cQryAbtRS += " GROUP BY E1_TIPO"
		_cQryAbtRS := ChangeQuery(_cQryAbtRS)
	EndIf
Return _cQryAbtRS



/*/{Protheus.doc} FinFK6V2
Rotina que soma os valores acessórios para SaldoTit (procedure).

@type       function
@author     Rafael Riego
@since      19/01/2020
@param      cFilMov, character, filial do movimento (FK5_FILIAL/E5_FILIAL)
@param      cFilTit, character, filial do título (E1_FILIAL/E2_FILIAL) 
@param      cPrefixo, character, prefixo do título
@param      cNumero, character, número do título
@param      cParcela, character, parcela do título
@param      cTipo, character, tipo do título
@param      cCliFor, character, cliente/fornecedor do título
@param      cLoja, character, loja do título
@param      cCarteira, character, carteira do título
@param      dDataBaixa, date, data da baixa
@param      cTipoData, character, tipo da data a ser utilizada na pesquisa {"0" = E5_DATA; "1" = E5_DTDISPO; "2" = E5_DTDIGIT}
@param      cAdiant, character, IIf(cTipo $ MVRECANT+"/"+MVPAGANT+"/"+MV_CRNEG+"/"+MV_CPNEG), "1","0")
@param      dDataBase, date, database utilizada na soma
@param      cFilOri, character, filial de origem do título
@param      nMoedaTit, numeric, moeda do título
@param      nTaxaMoeda, numeric, taxa da moeda
@return     numeric, valor acessório somado
/*/
Function FinFK6V2(cFilMov As Character, cIdDoc As Character,; 
					cCarteira As Character, dDataBaixa As Date, cTipoData As Character,; 
					cAdiant As Character, dDataBase As Date, cFilOri As Character,; 
					nMoedaTit As Numeric, nTaxaMoeda As Numeric) As Numeric

	Local aArea			As Array
    Local cAliasTMP     As Character
    Local cCartAux      As Character
    Local cDataBaixa    As Character
    Local cDataBase     As Character
    Local cFilialFK7    As Character
    Local cQuery        As Character
    Local nVA           As Numeric
	Local oSomaFK6		As Object

	nVa := 0

	aArea		:= GetArea()
	cCartAux    := cCarteira
	cDataBaixa  := DToS(dDataBaixa)
	cDataBase   := DToS(dDataBase)
	cFilialFK7  := FwXFilial("FK7", cFilMov)

	If __lCmpoFK1 == Nil .Or. __lCmpoFK2 == Nil
		__lCmpoFK1	:= FK1->(FieldPos("FK1_DTDISP")) > 0 .And. FK1->(FieldPos("FK1_DTDIGI")) > 0
		__lCmpoFK2	:= FK2->(FieldPos("FK2_DTDISP")) > 0 .And. FK2->(FieldPos("FK2_DTDIGI")) > 0 
	EndIf

	If cAdiant == "1"
		If cCartAux == "P"
			cCartAux := "R"
		Else
			cCartAux := "P"
		EndIf
	EndIf

	//cTipoData := "0"  // FK1_DATA/FK2_DATA
	//cTipoData := "1"  // FK1_DTDISP/FK2_DTDISP
	//cTipoData := "2"  // FK1_DTDIGI/FK2_DTDIGI
	If cCartAux == "P"
		If !__lCmpoFK2 .And. cTipoData $ "1|2"
			Return nVa
		EndIf
		If Empty(__cQryFK6P)
			__cQryFK6P	:= FinFK6Pag()
			__oSomaFK6P	:= FwPreparedStatement():New(__cQryFK6P)
		EndIf
		oSomaFK6 := __oSomaFK6P
	Else
		If !__lCmpoFK1 .And. cTipoData $ "1|2"
			Return nVa
		EndIf
		If Empty(__cQryFK6R)
			__cQryFK6R	:= FinFK6Rec()
			__oSomaFK6R	:= FwPreparedStatement():New(__cQryFK6R)
		EndIf
		oSomaFK6 := __oSomaFK6R
	EndIf

	If (__lCmpoFK1 .And. cCartAux == "R") .Or. (__lCmpoFK2 .And. cCartAux == "P")
		oSomaFK6:SetString(01, FWxFilial("FK1",cFilMov))
		oSomaFK6:SetString(02, cIdDoc)
		oSomaFK6:SetString(03, cFilOri)
		oSomaFK6:SetString(04, cDataBaixa)
		oSomaFK6:SetString(05, cTipoData)
		oSomaFK6:SetString(06, cDataBaixa)
		oSomaFK6:SetString(07, cTipoData)
		oSomaFK6:SetString(08, cDataBaixa)
		oSomaFK6:SetString(09, cTipoData)
		oSomaFK6:SetString(10, cCartAux)
		oSomaFK6:SetString(11, cCartAux)
		oSomaFK6:SetString(12, cCarteira)
		oSomaFK6:SetString(13, cDataBase)
		oSomaFK6:SetString(14, cTipoData)
		oSomaFK6:SetString(15, cDataBase)
		oSomaFK6:SetString(16, cTipoData)
		oSomaFK6:SetString(17, cDataBase)
		oSomaFK6:SetString(18, cTipoData)
	Else
		oSomaFK6:SetString(01, FWxFilial("FK1",cFilMov))
		oSomaFK6:SetString(02, cIdDoc)
		oSomaFK6:SetString(03, cFilOri)
		oSomaFK6:SetString(04, cDataBaixa)
		oSomaFK6:SetString(05, cCartAux)
		oSomaFK6:SetString(06, cCartAux)
		oSomaFK6:SetString(07, cCarteira)
		oSomaFK6:SetString(08, cDataBase)
	EndIf

	cQuery := oSomaFK6:GetFixQuery()

	cAliasTMP := GetNextAlias()

	DbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasTMP, .F., .T.)

	If __nMoeda != nMoedaTit
		While (cAliasTMP)->(!(EoF()))
			nVa += Round(NoRound(xMoeda((cAliasTMP)->VA, 1, nMoedaTit, (cAliasTMP)->FKDATA, 3,, IIf((cAliasTMP)->TXMOEDA == 0, nTaxaMoeda, (cAliasTMP)->TXMOEDA)), 3), 2)
			(cAliasTMP)->(DbSkip())
		End
	Else
		While (cAliasTMP)->(!(EoF()))
			nVa += (cAliasTMP)->VA
			(cAliasTMP)->(DbSkip())
		End
	EndIf

	(cAliasTMP)->(DbCloseArea())
	RestArea(aArea)

Return nVA

//-----------------------------------------------------------------------
/*/{Protheus.doc} FinhlpUrl
Modal para ser exebida quando for não for localizado nenhum título com a taxa
contrada do título de partida e quando o parâmetro  for Falso
@author  Bruno Horvat
@since   27/07/2021
@version 1.0
/*/
//-----------------------------------------------------------------------
Function FinhlpUrl(cTitle,cHelp,cLink,cUrl)

local oModal 		:= nil
local oContainer	:= nil
local oSay1			:= nil
local oSay2			:= nil
Local cRmtType 		:= ""

GetRemoteType(@cRmtType)

If "WIN" $ cRmtType
	bBlock :=  {|| ShellExecute("open",cUrl,"","",1) }
Else
	bBlock :=  {|| ShellExecute("Browser", "/usr/bin/firefox",cUrl, "/", 1 ) }
EndIf

oModal := FWDialogModal():New()       
oModal:SetEscClose(.T.)
oModal:setTitle(cTitle)

oModal:setSize(110, 203)

oModal:createDialog()
oModal:addCloseButton(nil, "Fechar")
oContainer := TPanel():New( ,,, oModal:getPanelMain() )
oContainer:Align := CONTROL_ALIGN_ALLCLIENT

@ 010,005 SAY oSay1 PROMPT cHelp SIZE 190,110 COLORS CLR_BLACK,CLR_WHITE OF oContainer HTML PIXEL
@ 050,005 SAY oSay2 PROMPT cLink              COLORS CLR_BLACK,CLR_WHITE OF oContainer HTML PIXEL

oSay2:bLClicked := {|| MsgRun( STR0105, "URL", bBlock ) }	//"Abrindo o link... Aguarde..."

oModal:Activate()

return

//-----------------------------------------------------------------------
/*/{Protheus.doc} EngSPS10Signature
Função para retornar assinatura da rotina - Processo 10 - SALDO DO TÍTULO
@author  Norberto M de Melo
@since   20/12/2021
@version 1.0
/*/
//-----------------------------------------------------------------------
Function EngSPS10Signature(cProcess as character)
Local cAssinatura as character

cAssinatura := STATICCALL(FINXFIN,VERIDPROC)

Return cAssinatura
//-----------------------------------------------------------------------

/*/{Protheus.doc} VldExtCNAB
Valida as extensões dos arquivos de remessa/retorno CNAB.

@type  		Function
@author 	Rafael Riego
@since 		18/03/2022
@param		cExtensao, character, extensão do arquivo a ser validada
@param 		cRotina, character, rotina que está sendo executada. Determina qual parâmetro (SX6) será utilizado para validação
@return 	logical, verdadeiro caso a extensão informada para o arquivo de configuração seja válida
/*/
Function VldExtCNAB(cExtensao As Character, cRotina As Character) As Logical

	Local cExtensoes	As Character
	Local cExtLower		As Character
	Local cHelpExt		As Character
	Local cMVExtCNAB	As Character

	Local lExtensVld	As Logical

	Default cExtensao	:= ""
	Default cRotina		:= "FINA150"

	cMVExtCNAB	:= ""
	lExtensVld	:= .T.
	cExtLower	:= Lower(AllTrim(cExtensao))

	If !(Empty(cExtLower))
		If cRotina == "FINA150"			//Geração de Remessa (Receber)
			cMVExtCNAB 	:= "MV_FEXREMR"
		ElseIf cRotina == "FINA200"		//Retorno de Remessa (Receber)
			cMVExtCNAB := "MV_FEXRETR"
		ElseIf cRotina == "FINA420"		//Geração de Remessa (Pagar)
			cMVExtCNAB := "MV_FEXREMP"
		Else //FINA430					//Retorno de Remessa (Pagar)
			cMVExtCNAB := "MV_FEXRETP"
		EndIf

		//Somente valida a extensão do arquivo caso o parâmetro esteja preenchido com as extensões permitidas
		If !(Empty(cExtensoes := Lower(AllTrim(SuperGetMV(cMVExtCNAB,, "")))))
			If !(cExtLower $ cExtensoes)
				cHelpExt := STR0110 + " '" + cMVExtCNAB + "' " + STR0111 + "'" + AllTrim(cExtensao) + "'."
				Help(,, "ARQCFGCNAB",, STR0107 + " '" + AllTrim(cExtensao) + "' " + STR0108, 1, 0,,,,,, {cHelpExt})
				lExtensVld := .F.
			EndIf
		EndIf
	EndIf

Return lExtensVld
