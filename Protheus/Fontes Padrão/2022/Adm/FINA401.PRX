#include "FINA401.ch"  
#include "PROTHEUS.ch"
#Include "FWBROWSE.CH"

#DEFINE CNPJ			1
#DEFINE VALORDOIMPOSTO	2
#DEFINE CODIGORETENCAO	3
#DEFINE MES				4
#DEFINE BASEDECALCULO	5
#DEFINE CHAVETITULO		6
#DEFINE VALORDOINSS		7
#DEFINE ANO				8
#DEFINE ISENTONAOTRIB	9
#DEFINE NIFEX           10

#DEFINE TAM_FIL			FinTamSXG("033",TAMSX3("E2_FILIAL")[1])[1]
#DEFINE TAM_PREF		10
#DEFINE TAM_NUM 		TamSX3("E2_NUM")[1]
#DEFINE TAM_PARC		10
#DEFINE TAM_TIPO		5
#DEFINE TAM_NAT			10
#DEFINE TAM_VALOR		17
#DEFINE LOG_VALOR		11

#DEFINE SA2_SQL_JOIN  1
#DEFINE SA2_SQL_WHERE 2

Static cQryConcat	:= ""
Static lPlsAtiv		:= .F.
Static cVenctoPJ 	:= SuperGetMv("MV_ACMIRPJ",.T.,"3")  //1 = Emissao    2= Vencimento Real	3=Data Contabilizacao
Static cUniao 		:= GetMv("MV_UNIAO")
Static aStru 		:= {}
Static cVenctoPF 	:= SuperGetMv("MV_ACMIRPF",.T.,"3")  //1 = Emissao    2= Vencimento Real	3=Data Contabilizacao

Static lFa401Cmp 	:= ExistBlock("FA401CMP")
Static lINSIRF   	:= (SuperGetMv("MV_INSIRF",.F.,"2") == "1")
Static lMRETISS  	:= GetNewPar( "MV_MRETISS", "1" ) == "2"
Static	nTamFor 	:= TamSx3("E2_FORNECE")[1]
Static nTamLj  		:= TamSx3("E2_LOJA")[1]
Static nTamTit 		:= ( TamSx3( "E2_PREFIXO" )[1] + TamSx3( "E2_NUM" )[1] + TamSx3( "E2_PARCELA" )[1] + TamSx3( "E2_TIPO" )[1]) + 1
Static nTMSVDEP		:= GetMV("MV_TMSVDEP",,0)
Static cBDname		:= Upper( TCGetDB() )
Static lF401QRY2 	:= ExistBlock("F401QRY2")
Static lF401QRY3 	:= ExistBlock("F401QRY3")
Static lFA401PROC 	:= ExistBlock("FA401PROC")

Static lFA401SR4 	:= ExistBlock("FA401SR4")
Static lF401REX 	:= ExistBlock("F401REX")
Static lF401Qry4 	:= ExistBlock("F401Qry4")
Static lFA401QRY 	:= ExistBlock("FA401QRY")
Static lF401Qry5 	:= ExistBlock("F401Qry5")

Static cSrvType 	:= TcSrvType()
Static lISNIF 		:= SR4->(ColumnPos( "R4_ISNIF")) > 0
Static nTamTpRen 	:= TamSx3( "R4_TIPOREN" )[1]
Static nTamPref 	:= TamSx3( "E2_PREFIXO" )[1]
Static nTamNum 		:=  TamSx3( "E2_NUM" )[1]
Static nTamPar  	:=  TamSx3( "E2_PARCELA" )[1]
Static nTamTipo 	:=  TamSx3( "E2_TIPO" )[1]
Static lFina992 	:= FindFunction("F992RetVal")  .and. AliasInDic("FKI")
Static lExistFKJ 	:= FindFunction("FINA993") .and.  AliasInDic("FKJ")
Static lFina405 	:= AliasInDic("FOM").AND. AliasInDic("FON") .AND. FindFunction("FINA405")
Static lTpEnt 		:= SA2->( ColumnPos( "A2_TPENT") ) > 0
Static lIrBx	  	:= .F.
Static lCalcIssBx 	:= .F.

Static __lPaBruto   := NIL
Static __lPrImPA	:= NIL

Static __lPCCBaixa	:= NIL
Static cFilSel		:= NIL
Static _oFINA4011
Static _oFINA4012
Static c401QryIr1 	:= F401QryIr(1)
Static c401QryIr2 	:= F401QryIr(2)
Static c401QryMes 	:= F401QryMes()
Static __LVALPGTO 	:= NIl
Static cFilSA2	 	:= NIL	
Static aEmptyCPF 	:= {}
Static __oPrepIrf	:= NIL

/*ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FINA401    ³ Autor ³ Claudio D. de Souza   ³ Data ³ 24.08.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera dados para DIRF na Folha                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ FINA401()                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIN                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Eduardo Ju  ³06/03/03³----- ³ Criacao de Queries para filtros em TOP.    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FINA401(lAutomato)
Local lPanelFin := IsPanelFin()
Local nOpca := 0
Local aButtons := {}
Local aSays := {}
Local nRegEmp	:= SM0->(Recno())

Local aNatVar	:= {"cMVIRNAT","cMVINSNAT","cMVPISNAT","cMVCOFNAT","cMVCSLNAT"}
Local nx		:= 0
Local aSE2Stru := SE2->(dbStruct())

//Gestao
Local aSelFil	:= {}
Local aTmpFil	:= {}
Local cTmpSE2Fil := ""

Private cCadastro 	:= STR0001  //"Gera dados para DIRF"
Private cMVIRNAT	:= Eval({|| SuperGetMv("MV_IRF",.T.,"IRF")})
Private cMVINSNAT	:= Eval({|| SuperGetMv("MV_INSS",.T.,"INSS")})
Private cMVPISNAT	:= Eval({|| SuperGetMv("MV_PISNAT",.T.,"PIS")})
Private cMVCOFNAT	:= Eval({|| SuperGetMv("MV_COFINS",.T.,"COFINS")})
Private cMVCSLNAT	:= Eval({|| SuperGetMv("MV_CSLL",.T.,"CSLL")})
Private cPccTit		:= Alltrim("('"+GetMV("MV_PISNAT"))+"','"+ALLTRIM(GETMV("MV_COFINS"))+"','"+ALLTRIM(GETMV("MV_CSLL"))+"')"

Default lAutomato := .F.

If cPaisLoc != "BRA"
	MsgStop(STR0041,STR0031) //"Atenção" "Rotina somente para o país Brasil."
	Return
EndIf

If GetHlpLGPD({"A2_CGC"})
	Return
EndIf

If Len(aStru) == 0
	For nX := 1 To len(aSE2Stru)
		If aSE2Stru[nX,2] != 'C'
			aAdd(aStru,{aSE2Stru[nX,1], aSE2Stru[nX,2], aSE2Stru[nX,3],aSE2Stru[nX,4]})
		EndIf
	Next nX
EndIf

//Gestao
//Carregar variaveis
//__lPccBaixa
__lPCCBaixa	:= NIL
__lPaBruto	:= NIL
F401PccBx()

//Variavel para armazenar a natureza do IRRF,INSS,PIS,COFINS e CSLL, resultado de formula e/ou string, garantindo-se que o retorno sera sempre do tipo caracter,
//evitando falhas de validacao por tipo de dados.
For nx := 1 to Len(aNatVar) Step 1
	bOk := .F.
	If At('"', &(aNatVar[nx])) > 0
		bOk = .T.
	ElseIf At('(', &(aNatVar[nx])) > 0
		bOk := .T.
	ElseIf At("'", &(aNatVar[nx])) > 0
		bOk := .T.
	Endif
	//O conteudo do parametro eh uma formula ou esta declarado com aspas ou apostrofo, precisa de macrosubstituicao
	If bOk
		&(aNatVar[nx]) := &(&(aNatVar[nx]))
	Endif
	If ValType(&(aNatVar[nx])) # "C"
		&(aNatVar[nx]) := cValToChar(&(aNatVar[nx]))
	Endif
Next nx

/*
------------------------------------------------
01	Considera Data ?
02	Data inicial ?
03	Data final ?
04	Tipo de Fornecedor ?
05	Verifica data ?
06	Centralizar na filial ?
07	Gerar Log de Processamento ?
08  Seleciona Filiais ?
09  Qual data usar para processar Tit. PCC ?
10  Considera Pagto Antecipado(PA)?
---------------------------------------------------
*/
//Define valor padrao para o novo parâmetro, caso nao exista na base
MV_PAR10 := 2
pergunte("FIN401",.F.)

nOpcA := 0
aSays := {}

AADD(aSays, STR0002) //"Este programa tem como objetivo gerar os dados necessarios  "
AADD(aSays, STR0003) //"para DIRF na folha, utilizando os titulos a pagar que tenham"
AADD(aSays, STR0004) //"sido informados o campo E2_DIRF como 1-Sim"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa o log de processamento                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ProcLogIni( aButtons )

If !lAutomato
	If lPanelFin  //Chamado pelo Painel Financeiro
		aButtonTxt := {}
		If Len(aButtons) > 0
			AADD(aButtonTxt,{STR0006,STR0006,aButtons[1][3]}) // Visualizar
		Endif
		AADD(aButtonTxt,{STR0007,STR0007, {||Pergunte("FIN401",.T. )}}) // Parametros
		FaMyFormBatch(aSays,aButtonTxt,{||If(F401VldCtz(),nOpca:= 1,nOpca:=0)},{||nOpca:=0})
	Else
		AADD(aButtons, { 5,.T.,{|| Pergunte("FIN401",.T. ) } } )
		AADD(aButtons, { 1,.T.,{|o| If(F401VldCtz(),(nOpca:= 1,o:oWnd:End()),nOpca:=0)}} )
		AADD(aButtons, { 2,.T.,{|o| o:oWnd:End() }} )
		FormBatch( cCadastro, aSays, aButtons ,,,390)
	Endif
Else
	nOpca:= 1
Endif
If nOpcA == 1

	//Gestao
	//Selecao de filiais
	If MV_PAR08 == 1 .And. Len( aSelFil ) <= 0
		If !lAutomato
			aSelFil := AdmGetFil(.F.,.T.,"SE2")
		Else
			If FindFunction("GetParAuto")
				aRetAuto 		:= GetParAuto("FINA401TESTCASE")
				aSelFil := aRetAuto[2]
			EndIf
		EndIf
		If Len( aSelFil ) <= 0
			Return
		EndIf
	Else
		aSelFil := { cFilAnt }
	EndIf

	cFilSel := FinSelFil( aSelFil, "SE2", .F., .T., 3)
	cFilSel := Replace(cFilSel,"E2_FILIAL","") //Mantem cFilSel s/ E2_FILIAL (pareando c/ o retorno antigo da GetRngFil)

	aAdd(aTmpFil, cTmpSE2Fil)

	ProcLogAtu("INICIO")

	Processa({|lEnd| fa401Processa(aSelFil,lAutomato)})
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o log de processamento   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ProcLogAtu("FIM")

	//Gestao
  	For nX := 1 TO Len(aTmpFil)
		CtbTmpErase(aTmpFil[nX])
    Next

	FinEraseTmpFil()

	SM0->(dbGoTo(nRegEmp))
	cFilAnt := FWGETCODFILIAL

Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³O codigo abaixo eh utilizado nesse ponto para garantir que tanto o alias³
//³quanto o browse serao recriados sem problemas na utilizacao do painel   ³
//|financeiro quando a rotina nao eh chamada de forma semi-automatica pois |
//|esse tratamento eh realizado na rotina T											|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lPanelFin //Chamado pelo Painel Financeiro
	dbSelectArea(FinWindow:cAliasFile)
	ReCreateBrow(FinWindow:cAliasFile,FinWindow)
Endif

Return .T.

/*
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fa401Process³ Autor ³ Claudio D. de Souza   ³ Data ³ 24.08.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Processa geracao dos dados da DIRF para folha                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fa401Processa()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nao ha'                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIN                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa401Processa(aSelFil,lAutomato)
Local cRaMat
Local aArea := GetArea()
Local cChave   := ""
Local lF401dcmp := ExistBlock("F401DCMP")
Local aTitulo := {}
Local cTipoFj
Local cFiltro
Local cCampo
Local cCampoP
Local lAchouPai := .T.
Local cAliasPai
Local aRecno := {}
Local cRecno := ""
Local nX
Local nY
Local cAliasTrb
Local cChaveSr4
Local cQuery := ""
Local nI := 0
Local cIndex

Local lDelFisico	:=	GetNewPar('MV_FIN401D',.T.)
Local aTitPLS   := {}
Local lContinua := .T.
Local dDtIni


Local lReproc   := .F.
Local nRendTributavel := 0
Local aTitPai := {}
Local aBxPai := {} //usado para o PCC na baixa.
Local aUltPCC := {}//usado para verificar se já foi composta a base de calculo da ultima baixa com pcc.
Local aFornec := {}
Local aTitJaProc := {}
Local nNaoTributavel := 0
Local bAscan
Local nDedDep := 0
Local cFilAtu := cFilAnt
Local cTitsSum	:= ""
Local lF401GRV := Existblock("lF401GRV")
Local cFilSR4	:= xFilial("SR4")
Local cTmpSA2Fil := "" //Gestao

Local cDtPgt
Local cNat		:= ""
Local lGerLog	:= (MV_PAR07 == 1)
Local nRecMin := 0
Local nRecMax := 0
Local aLog		:= {}
Local cArqLog	:= ""
Local nPosLog	:= 0
Local nTotREG	:= 0
Local aCRIN480 := {}
Local lGrvDIRF := .T.
Local lPCCbxado
Local lRetemPCC  := .F.
Local lPJIRPrg := .F.
Local cFilInic := cFilAnt//Filial atual do sistema, essa variável não deve ser alterada em momento algum da rotina
//Cria arquivo temporário para controle que os titulos não sejam enviados com duplicidade.
Local cArqTMP1	:= ""
Local cArqINDEX1	:= CriaTrab(,.F.)
Local aCampos		:= {}
Local cAbatim 	 := MV_CRNEG+"|"+MV_CPNEG+"|"+MVIRABT+"|"+MVCSABT+"|"+MVCFABT+"|"+MVPIABT+"|"+MVABATIM
Local cImpostos := MVISS+"|"+ MVTAXA+"|"+MVINSS+"|"+"SES"
Local cTipoIn	 := ""
Local lErroUpd := .F.

//fornecedor exterior
Local lTemNIF := .F.
Local cNIFEX := ""
Local lForExt := .F.
Local nTamNIF := 0
Local lGeraNIF := .F.

Local lF401VldPai	:= Existblock("F401VldPai")
Local lVldPai		:= .F.
Local nK := 0
Local aCPFs := {}
Local nValCalc := 0
Local nValOriIR := 0
Local lPa := .F.

Local nSomaBxPA := 0
Local nImpEmis := 0
Local lInssPA := .F.
Local aRetBaseIR := {}
Local cMesAnt := ""
Local aRecnoFon := {}
Local cTpRen 	:= ""
Local cFilCen := cFilAnt
Local cFilSE2 := ""
Local aFilProc := {}

Static cChavePF, cTipoP

Default lAutomato := .F.

If FindFunction( 'IsIssBx' )
	lCalcIssBx :=	IsIssBx( "P" )
Else
	lCalcIssBx :=	SA2->A2_TIPO == "J" .And. GetNewPar("MV_MRETISS","1") == "2" //Retencao do ISS pela emissao (1) ou baixa (2)
EndIf

cFilSA2 := FinSelFil( aSelFil, "SA2", .F., .T., 3)
nTamNIF := TamSx3("RL_NIFEX")[1]

Do Case
	Case "MSSQL"$cBDname
		cQryConcat := "+"
	Case "MYSQL"$cBDname
		cQryConcat := "CONCAT("
	Otherwise
		cQryConcat := "||"
Endcase

//Gestao
//Carregar variaveis
//__lPccBaixa

F401PccBx()

If MV_PAR10 == 1
	If !__lPccBaixa
		MV_PAR10 := 2
	EndIf
	MsgAlert(STR0042) //"Somente será considerado o TX gerado de PA, se a configuração de retenção de IR e PCC for na baixa!"
EndIf

If ExistBlock("FINCDRET")
	aCRIN480 :=ExecBlock("FINCDRET")
End

AADD(aCampos,{"NROREG"  	,"N",9,0})
AADD(aCampos,{"TITIPAI"  	,"L",1,0})
CriaTMP(aCampos,@cArqTMP1,"TMP1",cArqINDEX1,"NROREG")

// Se existir o campo da data de processamento, questiona se trata-se de reprocessamento

If !lAutomato
	lReproc := MsgNoYes(	STR0033+Chr(13)+Chr(13)+;		//'Deseja reprocessar a geração dos dados para o ano do periodo solicitado?'
						STR0034+;						//'Se optar por "Sim", os dados já registrados no periodo serão processados. Será '
						STR0035+;						//'efetuada a exclusão apenas dos dados do financeiro já  processados no período e serão '
						STR0036+Chr(13)+;				//'considerados todos os itens do periodo. Reprocessar primeiro a filial centralizadora e depois, as demais.'
						STR0037+;						//'Se optar por "Não", nenhum dado será excluido e apenas os titulos ainda não processados '
						STR0038,STR0031)				//'serão enviados a DIRF.'###"Atenção"
Else
	If FindFunction("GetParAuto")
		aRetAuto 		:= GetParAuto("FINA401TESTCASE")
		lReproc := aRetAuto[1]
	EndIf
EndIf

If lReproc
	If lDelFisico

		// Se possuir filial centralizadora, posiciona nesta filial
		If !Empty(MV_PAR06) .And. SM0->(MsSeek(cEmpAnt+MV_PAR06))
			cFilAnt := MV_PAR06
		Endif

		cQuery := "SELECT min(R_E_C_N_O_) MINREC , MAX(R_E_C_N_O_) MAXREC FROM " + RetSqlName( "SR4" ) + " "
		cQuery += " WHERE R_E_C_N_O_ IN ( "
		cQuery += " SELECT B.R_E_C_N_O_ FROM "
		cQuery += RetSqlName("SR4") + " B , "
		cQuery += RetSqlName("SA2")+" A "
		cQuery += " WHERE B.R4_FILIAL  = '"	+ xFilial("SR4") 	+ "'"
		cQuery += "   AND (B.R4_ANO >= '"	+ StrZero(Year(MV_PAR02),4)	+ "'"
		cQuery += "   AND B.R4_ANO <= '"	+ StrZero(Year(MV_PAR03),4)	+ "')"
		cQuery += "   AND B.R4_ORIGEM = '2' "
		cQuery += "   AND B.D_E_L_E_T_ = ' ' "

		cQuery += "   AND A.A2_FILIAL  " + cFilSA2

		cQuery += "   AND ( (A.A2_CGC = B.R4_CPFCGC OR A.A2_CPFIRP = B.R4_CPFCGC )  "
		If lExistFKJ
			cQuery += " OR EXISTS(SELECT FKJ.FKJ_COD, FKJ.FKJ_LOJA FROM " + RETSQLNAME('FKJ')
			cQuery += " FKJ WHERE FKJ.FKJ_FILIAL = A.A2_FILIAL "
			cQuery += " AND FKJ.FKJ_COD = A.A2_COD "
			cQuery += " AND FKJ.FKJ_LOJA = A.A2_LOJA "
			cQuery += " AND FKJ.FKJ_CPF = B.R4_CPFCGC "
			cQuery += " AND FKJ.D_E_L_E_T_ = ' ' ) "
		EndIf
		cQuery += " ) AND "

		cQuery += Fa401SqlA2( SA2_SQL_WHERE , "A" )

		cQuery += " A.D_E_L_E_T_ = ' ' ) "

		cQuery := ChangeQuery(cQuery)

		dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"SR4DEL",.F.,.T.)

		SR4DEL->(DbGoTop())
		nRecMin := SR4DEL->(MINREC)
		nRecMax := SR4DEL->(MAXREC)

		SR4DEL->(dbCloseArea())

		While nRecMin <= nRecMax
			cQuery := "DELETE FROM " + RetSqlName( "SR4" ) + " "
			cQuery += " WHERE R_E_C_N_O_ BETWEEN " + Str(nRecMin) + " AND " + Str(nRecMin + 1000) + " AND "
			cQuery += " R_E_C_N_O_ IN ( "
			cQuery += " SELECT B.R_E_C_N_O_ FROM "
			cQuery += RetSqlName("SR4") + " B , "
			cQuery += RetSqlName("SA2")+" A "
			cQuery += " WHERE B.R4_FILIAL  = '"	+ xFilial("SR4") 	+ "'"
			cQuery += "   AND (B.R4_ANO >= '"	+ StrZero(Year(MV_PAR02),4)	+ "'"
			cQuery += "   AND B.R4_ANO <= '"	+ StrZero(Year(MV_PAR03),4)	+ "')"
			cQuery += "   AND B.R4_ORIGEM = '2' "

			cQuery += "   AND B.D_E_L_E_T_ = ' ' "

			cQuery += "   AND A.A2_FILIAL " + cFilSA2

			cQuery += "   AND ( (A.A2_CGC = B.R4_CPFCGC OR A.A2_CPFIRP = B.R4_CPFCGC )  "
			If lExistFKJ
				cQuery += " OR EXISTS(SELECT FKJ.FKJ_COD, FKJ.FKJ_LOJA FROM " + RETSQLNAME('FKJ')
				cQuery += " FKJ WHERE FKJ.FKJ_FILIAL = A.A2_FILIAL "
				cQuery += " AND FKJ.FKJ_COD = A.A2_COD "
				cQuery += " AND FKJ.FKJ_LOJA = A.A2_LOJA "
				cQuery += " AND FKJ.FKJ_CPF = B.R4_CPFCGC "
				cQuery += " AND FKJ.D_E_L_E_T_ = ' ' ) "
			EndIf
			cQuery += " ) "

			If MV_PAR04 == 1 //Fisico
				//Se for PJ com IR Progressivo, será tratado como Pessoa Física.
				cQuery +=	" AND (A.A2_TIPO = 'F' OR (A.A2_TIPO = 'J' AND A.A2_IRPROG = '1')) "

			Else
				cQuery +=	" AND (A.A2_TIPO = 'X'  OR (A.A2_TIPO = 'J' AND A.A2_IRPROG != '1') )"
			Endif

			cQuery += " AND A.D_E_L_E_T_ = ' ' ) "

			nResult := TcSqlExec(cQuery)

			nRecMin += 1000

			//Restauro a filial do sistema quando processar com filial centralizadora
			If !Empty(MV_PAR06)
				cFilAnt := cFilAtu
			Endif

		EndDo
	Else

		cQuery := "UPDATE "+RetSqlName("SR4")+" "
		cQuery += "SET D_E_L_E_T_ = '*', R_E_C_D_E_L_ = R_E_C_N_O_ "
		cQuery += "WHERE R_E_C_N_O_ IN ( "
		cQuery += "SELECT B.R_E_C_N_O_ FROM "
		cQuery += RetSqlName("SR4") + " B , "
		cQuery += RetSqlName("SA2")+" A "
		cQuery += " WHERE B.R4_FILIAL  = '"	+ cFilSR4 	+ "'"
		cQuery += " AND (B.R4_ANO >= '"	+ StrZero(Year(MV_PAR02),4)	+ "'"
		cQuery += " AND B.R4_ANO <= '"	+ StrZero(Year(MV_PAR02),4)	+ "')"
		cQuery += "   AND B.R4_ORIGEM = '2' "

		cQuery += " AND B.D_E_L_E_T_ = ' ' "

		cQuery += "   AND A.A2_FILIAL " + cFilSA2

		cQuery += "   AND (A.A2_CGC = B.R4_CPFCGC OR A.A2_CPFIRP = B.R4_CPFCGC ) "

		If MV_PAR04 == 1 //Fisico
			//Se for PJ com IR Progressivo, será tratado como Pessoa Física.
			cQuery +=	" AND (A.A2_TIPO = 'F' OR (A.A2_TIPO = 'J' AND A.A2_IRPROG = '1')) "
		Else
			cQuery +=	" AND (A.A2_TIPO = 'X'  OR (A.A2_TIPO = 'J' AND A.A2_IRPROG != '1')) "
		Endif

		cQuery += " AND A.D_E_L_E_T_ = ' ' ) "

		nResult := TcSqlExec(cQuery)

	Endif
Endif

// Posiciona no ultimo registro do Cadastro de funcionarios
// para verificar a ultima matricula na filial atual
DbSelectArea("SRA")
DbSetOrder(1)
DbSeek(IncLast(xFilial("SRA")),.T.)
DbSkip(-1)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Abre o SE2 com outro alias para ser localizado o titulo 	 ³
//³ principal do imposto                   							 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !( ChkFile("SE2",.F.,"NEWSE2") )
	Return(Nil)
EndIf

lQuery := .T.

DbSelectArea("SRL")
DbSetOrder(2)

DbSelectArea("SR4")
DbSetOrder(1)

DbSelectArea("SE2")
DbSetOrder(1)

DbSelectArea("NEWSE2")
DbSetOrder(1)

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³  Variaveis utilizadas para parametros									³
³  MV_PAR01		 // Considera data                                      ³
³  MV_PAR02		 // Data Inicial										³
³  MV_PAR03		 // Data final  			                            ³
³  MV_PAR04		 // Tipo de Fornecedor							        ³
³  MV_PAR05		 // Verifica data										³
³  MV_PAR06      // Centralizar na filial						        |
³  MV_PAR07      // Gerar Log de Processamento ?  				        |
³  MV_PAR08      // Seleciona Filial							        |
³  MV_PAR09      // Qual data usar para processar Tit. PCC		        |
³  MV_PAR10      // Considera Pagto. Antecipado?							        |
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/

If MV_PAR10 == 2 // NAO-mantem a atual
	cTipoIn := FormatIn(cAbatim+"|"+cImpostos+"|"+MVPROVIS+"|"+MVPAGANT + "|" +MVTXA  ,"|")
Else
	cTipoIn := FormatIn(cAbatim+"|"+cImpostos+"|"+MVPROVIS ,"|")
EndIf

if lReproc .and. lQuery
	//faz a limpeza de E2_DTDIRF
	f401LimpaDt(cTipoIn,@lErroUpd)
EndIf

If lFina405 .and. lReproc .and. MV_PAR04 == 2 // PJ
	//atualiza flag dos registro de repasse de IR
	Fa405Limpa(MV_PAR06,MV_PAR02,MV_PAR03, MV_PAR08)
EndIf


Fa401SqlCImp(@cAliasTrb,@cQuery,@lPlsAtiv,@lReproc,@cPccTit,@cCampo,@cCampoP,@cChave,@ni,@nTotREG,@cIndex,,@cFiltro,cTipoIn)
ProcRegua(nTotREG)

aTitPLS := {}
aTitPai := {}
SFQ->(dbSetOrder(1))

While (cAliasTrb)->(!Eof()) //.And. (cAliasTrb)->E2_FILIAL == xFilial("SE2")

	IncProc()

	aRetBaseIR := {}
	lPCCbxado := .F.
	lAchouPai := .F.
	lTemNIF := .F.
	cNIFEX := Space(nTamNIF)
	lForExt := .F.	
	cNat := AllTrim( (cAliasTrb)->E2_NATUREZ )

	//Seto a filial atual para a filial de origem do titulo TX
	If !Empty(MV_PAR06)
		If !Empty((cAliasTrb)->E2_FILORIG)
			cFilAnt := (cAliasTrb)->E2_FILORIG
			cFilAtu := (cAliasTrb)->E2_FILORIG
		ElseIf Empty(cFilAnt) .And. Alltrim(cFilAnt)<>Alltrim((cAliasTrb)->E2_FILIAL)
			cFilAnt := (cAliasTrb)->E2_FILIAL
			cFilAtu := (cAliasTrb)->E2_FILIAL
		Endif
	Endif

	// Posiciona no titulo pai para obter o valor total do titulo
	If !Empty((cAliasTrb)->(RECNOPAI))
		cAliasPai := "NEWSE2"
		(cAliasPai)->(DBGoto((cAliasTrb)->(RECNOPAI) ))
		lAchouPai :=  (cAliasPai)->(Recno()) == (cAliasTrb)->(RECNOPAI)
	EndIf
	If !lAchouPai
		lAchouPai := Fa401Pai(cAliasTrb)
		cAliasPai := If( lAchouPai , "NEWSE2" , cAliasTrb)
	EndIf
	If !lAchouPai
		If lFA401PROC
			ExecBlock("FA401PROC",.F.,.F.)
		EndIf
		(cAliasTrb)->(dbSkip())
		Loop
	EndIf

	dbSelectArea("SA2")
	dbSetOrder(1)
	If !dbSeek(xFilial("SA2")+(cAliasPai)->(E2_FORNECE+E2_LOJA))
		(cAliasTrb)->(dbSkip())
		Loop
	EndIf

	dbSetOrder(1)
	If ! SED->(dbSeek(xFilial("SED")+(cAliasPai)->(E2_NATUREZ)))
		(cAliasTrb)->(dbSkip())
		Loop
	EndIf

	lIrBx := SA2->A2_CALCIRF == "2" .And. SED->ED_CALCIRF = "S"
	lRetemPCC := __lPccbaixa .and. ( SA2->A2_RECPIS == "2" .OR. SA2->A2_RECCOFI == "2" .OR. SA2->A2_RECCSLL == "2")
	lInssPA := SED->ED_RINSSPA = "1"


	// PE para ignorar determinados registros do SE2 que não devem fazer parte da gravação da DIRF.
	If lF401GRV
		lGrvDIRF := ExecBlock("lF401GRV",.F.,.F.,{cAliasTrb})
	Endif

	//Verifico o tipo da pessoa do Fornecedor (Fisico ou Juridico.
	//Em branco ou X - Outros, serao verificados pelo CGC
	If Empty(SA2->A2_TIPO) .or. !(SA2->A2_TIPO $ "F/J")
		If SA2->A2_TIPO == 'X' // Fornecedor exterior processa como PJ
			cTipoFj := "2"
		ElseIf SA2->A2_IRPROG == '1'
			cTipoFj := "1"
		Else
			cTipoFj := Iif(Len(AllTrim(SA2->A2_CGC	)) > 11 .or. Empty(SA2->A2_CGC),"2","1")
		EndIf
	Else
		cTipoFj := IIf( SA2->A2_TIPO = "F" , "1" , If(SA2->A2_TIPO == 'J' .AND. SA2->A2_IRPROG == '1',"1","2") )
	Endif
    IIF( SA2->A2_TIPO == "F" , cTipoP := "1" , cTipoP := "2" )
	// Se for um fornecedor definido no parametro
	If Val(cTipoFj) == MV_PAR04

		lContinua := .T.

		If !(cNat$cPccTit) //Titulo de Pcc
			If MV_PAR05 == 1 // Verifica Data Titulo Principal
				Do Case
					Case MV_PAR01 == 3 // Considera Data Vencto Real
						If (cAliasPai)->(E2_VENCREA) < MV_PAR02 .OR. (cAliasPai)->(E2_VENCREA) > MV_PAR03
							lContinua := .F.
						EndIf
					Case MV_PAR01 == 2 // Considera Data Vencto
						If (cAliasPai)->(E2_VENCTO) < MV_PAR02 .OR. (cAliasPai)->(E2_VENCTO) > MV_PAR03
							lContinua := .F.
						EndIf
					Case MV_PAR01 == 1 // Considera Emissão Digit.
						If (cAliasPai)->(E2_EMIS1) < MV_PAR02 .OR. (cAliasPai)->(E2_EMIS1) > MV_PAR03
							lContinua := .F.
						EndIf
					Case MV_PAR01 == 4 // Considera Data baixa
						If (!Empty((cAliasPai)->(E2_BAIXA)) .AND. ((cAliasPai)->(E2_BAIXA) < MV_PAR02 .OR. (cAliasPai)->(E2_BAIXA) > MV_PAR03)) .OR.;
						   ( Empty((cAliasPai)->(E2_BAIXA)) .AND. ((cAliasPai)->(E2_EMIS1) < MV_PAR02 .OR. (cAliasPai)->(E2_EMIS1) > MV_PAR03))
							lContinua := .F.
						EndIf
					Case MV_PAR01 == 5 // Considera Emissão Real.
						If (cAliasPai)->(E2_EMISSAO) < MV_PAR02 .OR. (cAliasPai)->(E2_EMISSAO) > MV_PAR03
							lContinua := .F.
						EndIf
				EndCase
			EndIf
		Else
			If MV_PAR05 == 1 // Verifica Data Titulo Principal
				Do Case
					Case MV_PAR09 == 3 // Considera Data Vencto Real
						If (cAliasPai)->(E2_VENCREA) < MV_PAR02 .OR. (cAliasPai)->(E2_VENCREA) > MV_PAR03
							lContinua := .F.
						EndIf
					Case MV_PAR09 == 2 // Considera Data Vencto
						If (cAliasPai)->(E2_VENCTO) < MV_PAR02 .OR. (cAliasPai)->(E2_VENCTO) > MV_PAR03
							lContinua := .F.
						EndIf
					Case MV_PAR09 == 1 // Considera Emissão
						If (cAliasPai)->(E2_EMIS1) < MV_PAR02 .OR. (cAliasPai)->(E2_EMIS1) > MV_PAR03
							lContinua := .F.
						EndIf
					Case MV_PAR09 == 4 // // Considera Data baixa, se for PA considera data de emissao
						If __lPccBaixa
							//se for PCC na baixa, considera data de emissao do TX 
							If ( (cAliasTrb)->(E2_EMIS1) < MV_PAR02 .OR. (cAliasTrb)->(E2_EMIS1) > MV_PAR03 ) .and. !(cAliasPai)->E2_TIPO $ MVPAGANT
								lContinua := .F.
							EndIF
						Else
							If (( (cAliasPai)->(E2_BAIXA) < MV_PAR02 .OR. (cAliasPai)->(E2_BAIXA) > MV_PAR03 ) .and. !(cAliasPai)->E2_TIPO $ MVPAGANT) .OR.;
							(( (cAliasPai)->(E2_EMIS1) < MV_PAR02 .OR. (cAliasPai)->(E2_EMIS1) > MV_PAR03 ) .and. (cAliasPai)->E2_TIPO $ MVPAGANT)

								lContinua := .F.
								EndIf
						EndIF
					Case MV_PAR09 == 5 // Considera Emissão Real
						If (cAliasPai)->(E2_EMISSAO) < MV_PAR02 .OR. (cAliasPai)->(E2_EMISSAO) > MV_PAR03
							lContinua := .F.
						EndIf
				EndCase
			EndIf
		Endif
		nSomaBxPA := 0
		nImpEmis  := 0
		//tratamento para PA
		//MV_PAR10 = Nao - Mantem legado, nao envia pa somente titulos principais
		//MV_PAR10 = Sim - Toda PA sera enviada, e será tratado a NF que foi compensada, nao deve ir
		If lContinua .and. MV_PAR10 == 1 //sim -considera pagamento antecipado

			If !(cAliasPai)->E2_TIPO $ MVPAGANT
				lPa := .F.
			Else
				lPa := .T.
				If !lIrBx .or. SA2->A2_TIPO != 'J' .OR. !lRetemPCC
					lContinua := .F.
				EndIf
			EndIf

			If lContinua
				If ((lIrBx .and. cNat$cMVIRNAT) .or. (__lPccbaixa .and. cNat$cPccTit) ) .and. !lPa
					//verifica se NF foi compensada
					nSomaBxPA := RetValCMP(cAliasPai,,lIrBx,lCalcIssBx,@nImpEmis)

					//Se Imposto é na baixa e houve compensacao da NF, desconsiderar a NF, pois será enviado a PA
					If nSomaBxPA > 0
						If nSomaBxPA == (cAliasTrb)->E2_VALOR + Iif(lIrBx,0, (cAliasTrb)->E2_IRRF) + Iif(__lPccbaixa,0,(cAliasTrb)->(E2_PIS+E2_COFINS+E2_CSLL)) +  (cAliasTrb)->E2_INSS + If(lCalcIssBx,0,(cAliasTrb)->E2_ISS)
							lContinua := .F.
						EndIf
					EndIf

				ElseIf lPa

					// verifica se PA nao está baixada, o que significa o seu cancelamento
					nSomaBxPA := RetValCMP(cAliasPai,(cAliasTrb)->E2_TIPO $ MVTXA ,lIrBx,lCalcIssBx,@nImpEmis)

					If nSomaBxPA > 0
						If nSomaBxPA == (cAliasPai)->E2_VALOR + If(__lPaBruto,If(lInssPA,(cAliasPai)->E2_INSS,0),(cAliasPai)->(E2_IRRF + E2_PIS + E2_COFINS + E2_CSLL) + Iif(__lPrImPA, (cAliasPai)->(E2_ISS + E2_PRISS + E2_INSS + E2_PRINSS),0 ))
							//PA foi baixada, devolucao da PA desconsiderar PA
							lContinua := .F.
						EndIf
					EndIf
				EndIf
			EndIf

		EndIf

		If lContinua .and. lGrvDIRF

			// Se possuir filial centralizadora, posiciona nesta filial
			If !Empty(MV_PAR06)
				SM0->(MsSeek(cEmpAnt+MV_PAR06))
				cFilAnt := MV_PAR06
			Endif

			aCPFs 		:= {}
			nValOriIR 	:= (cAliasTrb)->E2_VALOR
			lPJIRPrg 	:= SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG == '1'
			If (lPJIRPrg .or. FKJ->(MsSeek(xFilial("FKJ") + SA2->A2_COD + SA2->A2_LOJA) )) .And. (cNat$cMVIRNAT)
				aCPFs := VerCPFProg(cAliasPai,cAliasTrb,.F.)
			Else
				Aadd(aCPFs, {Padr(SA2->A2_CGC,Len(SRL->RL_CPFCGC)),100,SA2->A2_NOME, SA2->A2_COD, SA2->A2_LOJA,.F.})
			EndIf

			//tratamento para fornecedor
			lGeraNIF := .F. 
			If !EMPTY(SA2->A2_PAISEX) 
				If IsCodResExt((cAliasTrb)->E2_CODRET)
					lForExt := .T.
					lGeraNIF := .T.
				ElseIf SA2->A2_TIPO $ "J|X" .and. (Empty(SA2->A2_CGC) .or. SA2->A2_CGC =="00000000000000")
					// Se for um fornecedor exterior gerando titulo com cod retenção sem ser do exterior
					// com cgc em branco ou zerado, gera a chave nif para separar os fornecedores, mas este deve tratar como brasil
					lGeraNIF := .T.
				EndIf
				If lGeraNIF
					// fornecedor exterior sem NIF, envia cod+loja como chave
					If Empty(SA2->A2_NIFEX)
						cNIFEX := SA2->A2_COD +  SA2->A2_LOJA
						lTemNIF := .F.
					Else
						cNIFEX := SA2->A2_NIFEX
						lTemNIF := .T.
					EndIf
				EndIf
			EndIf

			For nK := 1 To Len(aCPFs)

				//RL_FILIAL, RL_CGCFONT, RL_CODRET, RL_TIPOFJ, RL_CPFCGC, R_E_C_N_O_, D_E_L_E_T_
				// Pesquisa cabecalho da DIRF
				If !SRL->(MsSeek(xFilial("SRL")+Padr(SM0->M0_CGC,Len(SRL->RL_CGCFONT))+ ;
						(cAliasTrb)->E2_CODRET +cTipoFj+aCPFs[nK][1] + cNIFEX   ))

					Reclock("SRL", .T.)

					cRaMat := GetSxENum( "SRL" , "RL_MAT")

					SRL->RL_FILIAL  := xFilial("SRL")
					SRL->RL_MAT     := If(Val(SRA->RA_MAT) < 900000 .And. Val(cRaMat) < 900000, "900000",cRaMat)
					SRL->RL_CODRET  := (cAliasTrb)->E2_CODRET
					SRL->RL_TIPOFJ  := cTipoFj
					SRL->RL_CPFCGC  := aCPFs[nK][1] 
					SRL->RL_BENEFIC := aCPFs[nK][3]
					SRL->RL_ENDBENE := Alltrim(SA2->A2_END) + Alltrim(SA2->A2_NR_END)
					SRL->RL_UFBENEF := SA2->A2_EST
					SRL->RL_COMPLEM := SA2->A2_BAIRRO
					SRL->RL_CGCFONT := SM0->M0_CGC
					SRL->RL_NOMFONT := SM0->M0_NOMECOM
					SRL->RL_ORIGEM := "2"
					SRL->RL_NIFEX := cNIFEX

					If IsCodResExt(SRL->RL_CODRET)

						SRL->RL_CGCEX := SA2->A2_CGCEX
						SRL->RL_PAIS  := SA2->A2_PAISEX
						SRL->RL_NEMPR := SA2->A2_NEMPR
						SRL->RL_TPCON := SA2->A2_TPCON
						SRL->RL_DTINI := SA2->A2_DTINIR
						SRL->RL_DTFIM := SA2->A2_DTFIMR
						SRL->RL_LOGEX := SA2->A2_LOGEX
						SRL->RL_NUMEX := SA2->A2_NUMEX
						SRL->RL_COMPL := SA2->A2_COMPLR
						SRL->RL_BAIEX := SA2->A2_BAIEX
						SRL->RL_POSEX := SA2->A2_POSEX
						SRL->RL_CIDEX := SA2->A2_CIDEX
						SRL->RL_ESTEX := SA2->A2_ESTEX
						SRL->RL_TELEX := SA2->A2_TELRE
						SRL->RL_BREEX := SA2->A2_BREEX
						SRL->RL_TPREX := SA2->A2_TPREX
						SRL->RL_TRBEX := SA2->A2_TRBEX
						If !lTemNIF
							If SA2->A2_MOTNIF == "1"                                                                         
								SRL->RL_BEDINI := "1" //Fornecedor dispensado do NIF   
								SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
							Elseif SA2->A2_MOTNIF == "2"             
								SRL->RL_PAEXNI := "2" //País do fornecedor nao exige NIF   
							Endif
						Else
							SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
						Endif
					EndIf

					SRL->(MsUnlock())
				Endif

				//Restauro a filial do sistema quando processar com filial centralizadora
				If !Empty(MV_PAR06)
					cFilAnt := cFilAtu
				Endif

				//Se for pela data da baixa, verifico qual data a ser considerada
				//Se titulo baixado, considero data da baixa
				//Se titulo não baixado, considero data da emissao
				If !cNat$cPccTit	 // Título não PCC
					If MV_PAR01 == 4
						//Data da Baixa
						cCampo := "E2_BAIXA"

						If MV_PAR05 == 1
							If Empty((cAliasPai)->&(cCampo))
								cCampo := "E2_EMIS1"
							Endif
						Else
							If Empty((cAliasTrb)->&(cCampo))
								cCampo := "E2_EMIS1"
							Endif
						Endif
					Endif
				Else  // Título de PCC
					If MV_PAR09 == 4
						//Data da Baixa
						If lPa
							cCampoP := "E2_EMIS1"
						Else
							If __lPccbaixa
								cCampoP := "E2_EMIS1"
							Else
								cCampoP := "E2_BAIXA"
							Endif	
						EndIf

					Endif
				Endif
				If !cNat$cPccTit
					If MV_PAR05 == 1 //se for pelo titulo principal pega data do principal
						cMes := STRZERO(MONTH((cAliasPai)->&(cCampo)),2)
						cAno := STRZERO(YEAR((cAliasPai)->&(cCampo)),4)
						cDtPgt := (cAliasPai)->&(cCampo)
					Else
						cMes := STRZERO(MONTH((cAliasTrb)->&(cCampo)),2)
						cAno := STRZERO(YEAR((cAliasTrb)->&(cCampo)),4)
						cDtPgt := (cAliasTrb)->&(cCampo)
					EndIf
				Else // Tratamento para títulos de pcc
					If MV_PAR05 == 1 //se for pelo titulo principal pega data do principal
						If __lPccbaixa .and. !lPa .and. MV_PAR09 == 4
							cMes := STRZERO(MONTH((cAliasTrb)->&(cCampoP)),2)
							cAno := STRZERO(YEAR ((cAliasTrb)->&(cCampoP)),4)
							cDtPgt := (cAliasTrb)->&(cCampoP)
						Else
							cMes := STRZERO(MONTH((cAliasPai)->&(cCampoP)),2)
							cAno := STRZERO(YEAR ((cAliasPai)->&(cCampoP)),4)
							cDtPgt := (cAliasPai)->&(cCampoP)
						EndIf	
					Else
						cMes := STRZERO(MONTH((cAliasTrb)->&(cCampoP)),2)
						cAno := STRZERO(YEAR ((cAliasTrb)->&(cCampoP)),4)
						cDtPgt := (cAliasTrb)->&(cCampoP)
					EndIf
					IIF(cMes=="00",lPCCbxado:=.T.,lPCCbxado:=.F.)	// Título PCC não foi baixado
				Endif

				If MV_PAR05!=1 .and. !"NF"$(cAliasPai)->E2_TIPO
					If lPCCbxado
						dbSelectArea(cAliasTrb)
						(cAliasTrb)->(dbSkip())
						Loop
					Endif
				Endif

				If cMes = "00" .and. MV_PAR05 == 1
					If lPCCbxado
						dbSelectArea(cAliasTrb)
						(cAliasTrb)->(dbSkip())
						Loop
					Else
						cMes := STRZERO(MONTH((cAliasPai)->&(cCampo)),2)
						cAno := STRZERO(YEAR ((cAliasPai)->&(cCampo)),4)
						cDtPgt := (cAliasPai)->&(cCampo)
					Endif
				Endif

					aTitulo	:= {	aCPFs[nK][1],;
									0					,;
									(cAliasTrb)->E2_CODRET	,;
									cMes,;
									0              ,;
									{}             ,;
									0 /* Valor do INSS */,;
									cAno,;
									0/* Valor Nao Tributado ou Isento */ ,;
									cNIFEX }

				//Se possuir filial centralizadora, posiciona nesta filial
				If !Empty(MV_PAR06)
					cFilAnt := MV_PAR06
				Endif

				// Tipo do rendimento considera tipo da entidade
				If lTpEnt
					If Empty((cAliasTrb)->A2_TPENT)
						cTpRen := "A"
					Else
						If (cAliasTrb)->A2_TPENT == "1"	 // Fornecedores Imunes
							cTpRen := "I2"
						ElseIf (cAliasTrb)->A2_TPENT == "2"  // Fornecedores Isentos
							cTpRen := "I3"
						EndIf
					EndIf
				Else
					cTpRen := "A"
				EndIf

				// Se existir o ano na chave do SR4
				// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
				cChaveSr4 := xFilial("SR4")+SRL->RL_MAT+ Padr(aTitulo[CNPJ],Len(SR4->R4_CPFCGC)) + aTitulo[CODIGORETENCAO]+aTitulo[ANO]+aTitulo[MES]
				cChavePF := cChaveSr4 + padr(cTpRen,nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX
				// Mudou o mes, fornecedor ou codigo de retencao
				// Gera Valor do Imposto do titulo
				//R4_FILIAL, R4_MAT, R4_CPFCGC, R4_CODRET, R4_ANO, R4_MES, R4_TIPOREN, R4_PAIS, R4_NIFEX, R_E_C_N_O_, D_E_L_E_T_
				If !(cAliasTrb)->E2_TIPO $ MVINSS+"|"+"INA"
					If !SR4->( MsSeek( cChaveSr4 + padr("D",nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX ))

						Reclock("SR4", .T.)

						SR4->R4_FILIAL  := xFilial("SR4")
						SR4->R4_MAT     := SRL->RL_MAT
						SR4->R4_CPFCGC  := aTitulo[CNPJ]
						SR4->R4_MES     := aTitulo[MES]
						SR4->R4_TIPOREN := "D"
						SR4->R4_CODRET  := aTitulo[CODIGORETENCAO]
						SR4->R4_ANO  := aTitulo[ANO]
						SR4->R4_ORIGEM := "2"
						SR4->R4_NIFEX := SRL->RL_NIFEX

						If !Empty(SRL->RL_PAIS)
							SR4->R4_PAIS := SRL->RL_PAIS
							
							SR4->R4_DTPGT := cDtPgt
							If lISNIF
								SR4->R4_ISNIF := IIF(lTemNIF,"1","2")
							EndIf

						EndIf

					Else
						Reclock("SR4", .F.)
					Endif
					//se NÃO é pela BAIXA do TIT PRINCIPAL
					If !(MV_PAR01 == 4 .and. MV_PAR05 == 1)	.Or. !(MV_PAR09 == 4 .and. MV_PAR05 == 1)
						//Calculo antigo do rateio de CPF's Ir Progressivo, legado
						If !aCPFs[nK][6]
							nValCalc := Round( ( (cAliasTrb)->E2_VALOR * aCPFs[nK][2]) / 100,2 )

							If Len(aCPFs) == nK
								nValCalc := nValOriIR
							Else
								nValOriIR -= nValCalc
							EndIf
						//Novo calculo do rateio de Ir Progressivo
						Else
							nValCalc := (cAliasTrb)->E2_VALOR	
						Endif

						SR4->R4_VALOR   += nValCalc

						nRegPai	:=	(cAliasPai)->(Recno())
						If !TMP1->(Dbseek(nRegPai))
							Reclock("TMP1", .T.)
							TMP1->NROREG 		:= nRegPai
							TMP1->TITIPAI		:= ((cAliasTrb)->(RECNOPAI) == nRegPai)
							TMP1->(MSUNLOCK())
						Endif

						If !Empty(SRL->RL_PAIS)
							SR4->R4_DTPGT := cDtPgt
						EndIf
						SR4->(MsUnlock())
						Fa401AddLog(	@aLog, lGerLog, SR4->R4_CPFCGC, SR4->R4_CODRET, SR4->R4_MES, SR4->R4_TIPOREN, (cAliasTRB)->E2_FILIAL, (cAliasTRB)->E2_PREFIXO,;
											(cAliasTRB)->E2_NUM, (cAliasTRB)->E2_PARCELA, (cAliasTRB)->E2_TIPO, (cAliasTRB)->E2_NATUREZ, nValCalc, cNIFEX, SA2->A2_COD, SA2->A2_LOJA ,;
											SA2->A2_FILIAL , SA2->A2_NOME )
					//se É pela BAIXA do TIT PRINCIPAL
					//vejo se o principal/pai está baixado no período
					//ou, se nao estiver baixado, vejo de a data de emissao está dentro do período solicitado
					Else
						If !cNat$cPccTit  .Or. (cNat$cPccTit .And. MV_PAR09 == 4 .And. MV_PAR05 == 1) //Quando nao for titulo de PCC ou Titulo de PCC e data selecionada for BAIXA.

							If (((cAliasPai)->E2_BAIXA >= MV_PAR02 .AND. (cAliasPai)->E2_BAIXA <= MV_PAR03) .OR.;
								((cAliasPai)->E2_BAIXA == CToD('') .AND. (cAliasPai)->E2_EMIS1 >= MV_PAR02 .AND. (cAliasPai)->E2_EMIS1 <= MV_PAR03))
								SR4->R4_VALOR   += (cAliasTrb)->E2_VALOR

								nRegPai	:=	(cAliasPai)->(Recno())
								If !TMP1->(Dbseek(nRegPai))
									Reclock("TMP1", .T.)
									TMP1->NROREG 		:= nRegPai
									TMP1->TITIPAI		:= ((cAliasTrb)->(RECNOPAI) == nRegPai)
									TMP1->(MSUNLOCK())
								Endif

								If !Empty(SRL->RL_PAIS)
									SR4->R4_DTPGT := cDtPgt
								EndIf
								Fa401AddLog(	@aLog, lGerLog, SR4->R4_CPFCGC, SR4->R4_CODRET, SR4->R4_MES, SR4->R4_TIPOREN, (cAliasTRB)->E2_FILIAL, (cAliasTRB)->E2_PREFIXO,;
												(cAliasTRB)->E2_NUM, (cAliasTRB)->E2_PARCELA, (cAliasTRB)->E2_TIPO, (cAliasTRB)->E2_NATUREZ, (cAliasTRB)->E2_VALOR, cNIFEX, SA2->A2_COD,;
													SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
							Endif
						Endif
					EndIf

				Else // Eh um titulo de INSS
					If (cAliasTrb)->E2_VALOR  > 0 .And. MV_PAR04 ==1 // Somente se for pessoa fisica (MV_PAR04 = 1)
						If !SR4->(MsSeek(cChaveSr4+padr("B",nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX ))
							Reclock("SR4", .T.)
							SR4->R4_FILIAL  := xFilial("SR4")
							SR4->R4_MAT     := SRL->RL_MAT
							SR4->R4_CPFCGC  := aTitulo[CNPJ]
							SR4->R4_MES     := aTitulo[MES]
							SR4->R4_TIPOREN := "B"
							SR4->R4_CODRET  := aTitulo[CODIGORETENCAO]
							SR4->R4_ANO  := aTitulo[ANO]
							SR4->R4_ORIGEM := "2"
							SR4->R4_NIFEX := SRL->RL_NIFEX
							If  !Empty(SRL->RL_PAIS)
								SR4->R4_PAIS := SRL->RL_PAIS
								
								SR4->R4_DTPGT := cDtPgt
								If lISNIF
									SR4->R4_ISNIF :=  IIF(lTemNIF,"1","2")
								EndIf
							EndIf
						Else
							Reclock("SR4", .F.)
						Endif

						If  !Empty(SRL->RL_PAIS)
							SR4->R4_DTPGT := cDtPgt
						EndIf

						SR4->R4_VALOR   += (cAliasTrb)->E2_VALOR

						nRegPai	:=	(cAliasPai)->(Recno())
						If !TMP1->(Dbseek(nRegPai))
							Reclock("TMP1", .T.)
							TMP1->NROREG 		:= nRegPai
							TMP1->TITIPAI		:= ((cAliasTrb)->(RECNOPAI) == nRegPai)
							TMP1->(MSUNLOCK())
						Endif

						Fa401AddLog(	@aLog, lGerLog, SR4->R4_CPFCGC, SR4->R4_CODRET, SR4->R4_MES, SR4->R4_TIPOREN, (cAliasTRB)->E2_FILIAL, (cAliasTRB)->E2_PREFIXO,;
										(cAliasTRB)->E2_NUM, (cAliasTRB)->E2_PARCELA, (cAliasTRB)->E2_TIPO, (cAliasTRB)->E2_NATUREZ, (cAliasTRB)->E2_VALOR, cNIFEX, SA2->A2_COD, ;
											SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )

					Endif
				EndIf

				If lFa401Cmp
					// Utilizado para gravar campos complementares do SR4
					ExecBlock("FA401CMP", .F.,.F.)
				Endif

				SR4->(MsUnlock())

				// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
				cChaveSr4 := xFilial("SR4")+SRL->RL_MAT+ Padr(aTitulo[CNPJ],Len(SR4->R4_CPFCGC)) + aTitulo[CODIGORETENCAO] + aTitulo[ANO] + aTitulo[MES]

				nRendTributavel := 0
				nNaoTributavel  := 0

				// Tipo do rendimento considera tipo da entidade
				If lTpEnt
					If Empty((cAliasTrb)->A2_TPENT)
						cTpRen := "A"
					Else
						If (cAliasTrb)->A2_TPENT == "1"	 // Fornecedores Imunes
							cTpRen := "I2"
						ElseIf (cAliasTrb)->A2_TPENT == "2"  // Fornecedores Isentos
							cTpRen := "I3"
						EndIf
					EndIf
				Else
					cTpRen := "A"
				EndIf

				//Restauro a filial do sistema quando processar com filial centralizadora
				If !Empty(MV_PAR06)
					cFilAnt := cFilAtu
				Endif
				//lTitRet	:=	.F.
				// se nao é INSS, nem IR, entao é PCC - AQUI calcula o Rendimento Tributável do PCC
					// Se utilizar codigo único de retenção  - (Empresa Pública - exemplo: Dataprev) e o título tiver IR
					// nao calcular o Rendimento Tributável pois já será calculado no IR
					// dessa forma o valor do rendimento nao ficará em dobro
				If !(cAliasTrb)->E2_TIPO $ MVINSS+"|"+"INA" .And.	!(AllTrim((cAliasTrb)->E2_NATUREZ ) $ cMVIRNAT) .and.;
					( (cAliasPai)->E2_IRRF == 0 .or. ((cAliasPai)->E2_IRRF > 0 .and. !f401CodUn(cAliasTrb,cAliasPai,aCRIN480)))

					If AllTrim((cAliasTrb)->E2_SEQBX) == "" .and. ;    //isso significa que o PCC nao foi gerado na baixa e sim na emissão do título
						SFQ->(MsSeek(xFilial("SFQ")+"SE2"+(cAliasPai)->E2_PREFIXO+(cAliasPai)->E2_NUM+(cAliasPai)->E2_PARCELA+(cAliasPai)->E2_TIPO+(cAliasPai)->E2_FORNECE+(cAliasPai)->E2_LOJA)) .and.;
						Ascan(aTitPai,(cAliasTrb)->E2_CODRET + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)) == 0

						nCalcRend  := ValRenPCC(cAliasPai, cAliasTrb)

						nRendTributavel += nCalcRend

							Fa401AddLog(	@aLog, lGerLog, aTitulo[CNPJ] , aTitulo[CODIGORETENCAO], cMes, cTpRen, (cAliasPai)->E2_FILIAL, (cAliasPai)->E2_PREFIXO,;
											(cAliasPai)->E2_NUM, (cAliasPai)->E2_PARCELA, (cAliasPai)->E2_TIPO, (cAliasPai)->E2_NATUREZ, nCalcRend,aTitulo[NIFEX], SA2->A2_COD,;
												SA2->A2_LOJA  , SA2->A2_FILIAL , SA2->A2_NOME )

						Aadd(aTitPai,(cAliasTrb)->E2_CODRET + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))

						//ver se a baixa está no SFQ para varrer as baixas que compuseram a base desse imposto.
					ElseIf AllTrim((cAliasTrb)->E2_SEQBX) <> "" .and. ; //isso significa que o PCC FOI gerado na baixa
							Ascan(aBxPai,(cAliasTrb)->E2_CODRET + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)+(cAliasTrb)->E2_SEQBX) == 0

						/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Posiciono na baixa que gerou o TX.³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ*/
						SE5->(DbSetOrder(7))
						SE5->(DbSeek(xFilial("SE5")+(cAliasPai)->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)+(cAliasTrb)->E2_SEQBX))

						Do While !SE5->(Eof()) .AND. SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) == ;
							(cAliasPai)->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)

							//Posiciono no movimento de baixa do titulo pai, caso exista por exemplo um DC (desconto) com a mesma chave do titulo pai
							If AllTrim(SE5->E5_TIPODOC) $ "CP/BA/PA/VL"
								Exit
							Endif
							SE5->(dbSkip())
						EndDo

						/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Nao posso somar os impostos da emissão aqui, pois se o  ³
						//³mesmo título tiver várias baixas, vai somar os impostos ³
						//³da emissão varias vezes.                                ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ*/
						//Somar os juros, multa, correcao e desconto para formar o valor total do titulo pai
						nCalcRend  := ValRenPCC(cAliasPai, cAliasTrb, @aUltPCC, SE5->E5_SEQ)

						nRendTributavel += nCalcRend

						nPosLog	:= AScan( aLog, {	|x| x[1] + x[2] + x[3] + x[4] + x[5] + x[6] + x[7] + x[8] + x[9] + x[10] == ;
														Iif(!Empty(cNIFEX),cNIFEX,aTitulo[CNPJ]) + aTitulo[CODIGORETENCAO] + aTitulo[MES] + cTpRen +;
													(cAliasPai)->( E2_FILIAL + E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_NATUREZ ) } )

						If nPosLog == 0
							Fa401AddLog( @aLog, lGerLog, aTitulo[CNPJ], aTitulo[CODIGORETENCAO], aTitulo[MES], cTpRen, (cAliasPai)->E2_FILIAL, (cAliasPai)->E2_PREFIXO,;
												(cAliasPai)->E2_NUM, (cAliasPai)->E2_PARCELA, (cAliasPai)->E2_TIPO, (cAliasPai)->E2_NATUREZ, nCalcRend,aTitulo[NIFEX] , SA2->A2_COD,;
												SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
							nPosLog	:= Len(aLog)
						Else
							Fa401EdtLog( @aLog, lGerLog, nPosLog, LOG_VALOR, nCalcRend, "+" )
						EndIf

						Aadd( aBxPai ,(cAliasTrb)->E2_CODRET + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)+(cAliasTrb)->E2_SEQBX )

						/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Os impostos gerados na emissão serão somados          ³
						//³na ultima baixa.                                      ³
						//³Também os impostos que são deduzidos do valor da baixa³
						//³na gravação do SE5 serão somados na ultima baixa.     ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						If (cAliasPai)->E2_SALDO == 0 .and. lPa .and. ;
							(MV_PAR05 == 1 .and. Ascan(aUltPCC,Alltrim((cAliasTrb)->E2_CODRET) + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)) == 0) .and.;
							IsTheLastPost((cAliasPai)->E2_PREFIXO,(cAliasPai)->E2_NUM,(cAliasPai)->E2_PARCELA,(cAliasPai)->E2_TIPO,(cAliasPai)->E2_FORNECE,(cAliasPai)->E2_LOJA)
								If __lPaBruto
									nCalcRend := (cAliasPai)->(E2_VALOR) + IIf(lInssPa,  (cAliasPai)->(E2_INSS), 0 )
								Else
									nCalcRend := (cAliasPai)->(E2_VALOR+E2_RETENC+E2_SEST+E2_IRRF+E2_PIS+E2_COFINS+E2_CSLL)
									If __lPrImPA
										nCalcRend += (cAliasPai)->(E2_ISS+E2_INSS+E2_PRINSS+E2_PRISS)
									EndIf
								EndIf

								If 	nSomabxPa > 0
									nCalcRend -= nImpEmis
								EndIf

								nRendTributavel += nCalcRend

								nPosLog	:= AScan( aLog, {	|x| x[1] + x[2] + x[3] + x[4] + x[5] + x[6] + x[7] + x[8] + x[9] + x[10] == ;
														Iif(!Empty(cNIFEX),cNIFEX,aTitulo[CNPJ]) + aTitulo[CODIGORETENCAO] + aTitulo[MES] + cTpRen +;
													(cAliasPai)->( E2_FILIAL + E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_NATUREZ ) } )

								If nPosLog == 0
									Fa401AddLog( @aLog, lGerLog, aTitulo[CNPJ], aTitulo[CODIGORETENCAO], cMes, cTpRen, (cAliasPai)->E2_FILIAL, (cAliasPai)->E2_PREFIXO,;
													(cAliasPai)->E2_NUM, (cAliasPai)->E2_PARCELA, (cAliasPai)->E2_TIPO, (cAliasPai)->E2_NATUREZ, nCalcRend,aTitulo[NIFEX], SA2->A2_COD,;
													SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
								Else

									Fa401EdtLog( @aLog, lGerLog, nPosLog, LOG_VALOR, nCalcRend, "+" )
								EndIf
								Aadd(aUltPCC,Alltrim((cAliasTrb)->E2_CODRET) + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
						ElseIf (cAliasPai)->E2_SALDO == 0 .and. ;
								(MV_PAR05 == 2) .and. lPa .and. ; //se a dirf esta sendo processada pelo imposto  ////							   (MV_PAR01 == 1 .and. MV_PAR05 == 2) .and. ; //se a dirf esta sendo processada pela emissao X imposto
								aTitulo[MES] == STRZERO(Month(cDtPgt),2) .and.;
								IsTheLastPost((cAliasPai)->E2_PREFIXO,(cAliasPai)->E2_NUM,(cAliasPai)->E2_PARCELA,(cAliasPai)->E2_TIPO,(cAliasPai)->E2_FORNECE,(cAliasPai)->E2_LOJA).and.;
								Ascan(aUltPCC,Alltrim((cAliasTrb)->E2_CODRET) + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)) == 0
								nPosLog	:= AScan( aLog, {	|x| x[1] + x[2] + x[3] + x[4] + x[5] + x[6] + x[7] + x[8] + x[9] + x[10] == ;
														Iif(!Empty(cNIFEX),cNIFEX,aTitulo[CNPJ])+ aTitulo[CODIGORETENCAO] + aTitulo[MES] + cTpRen +;
													(cAliasPai)->( E2_FILIAL + E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_NATUREZ ) } )

								If __lPaBruto
									nCalcRend := (cAliasPai)->(E2_VALOR) + IIf(lInssPa,  (cAliasPai)->(E2_INSS), 0 )
								Else
									nCalcRend := (cAliasPai)->(E2_VALOR+E2_RETENC+E2_SEST+E2_IRRF+E2_PIS+E2_COFINS+E2_CSLL)
									If __lPrImPA
										nCalcRend += (cAliasPai)->(E2_ISS+E2_INSS+E2_PRINSS+E2_PRISS)
									EndIf
								EndIf

								If 	nSomabxPa > 0
									nCalcRend -= nImpEmis//aqui
								EndIf


								nRendTributavel += nCalcRend
								If nPosLog == 0
										Fa401AddLog( @aLog, lGerLog,aTitulo[CNPJ], aTitulo[CODIGORETENCAO], aTitulo[MES], cTpRen, (cAliasPai)->E2_FILIAL, (cAliasPai)->E2_PREFIXO,;
														(cAliasPai)->E2_NUM, (cAliasPai)->E2_PARCELA, (cAliasPai)->E2_TIPO, (cAliasPai)->E2_NATUREZ, nCalcRend,aTitulo[NIFEX], SA2->A2_COD, ;
														SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
								Else
									Fa401EdtLog( @aLog, lGerLog, nPosLog, LOG_VALOR, nCalcRend, "+" )
								EndIf
								Aadd(aUltPCC,Alltrim((cAliasTrb)->E2_CODRET) + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
						EndIf

						Aadd( aTitPai,(cAliasTrb)->E2_CODRET + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) )

					Else
						If Ascan(aTitPai,(cAliasTrb)->E2_CODRET + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)) == 0

							If lPa
								If __lPaBruto
									nCalcRend := (cAliasPai)->(E2_VALOR) + IIf(lInssPa,  (cAliasPai)->(E2_INSS), 0 )
								Else
									nCalcRend := (cAliasPai)->(E2_VALOR+E2_RETENC+E2_SEST+E2_IRRF+E2_PIS+E2_COFINS+E2_CSLL)
									If __lPrImPA
										nCalcRend += (cAliasPai)->(E2_ISS+E2_INSS+E2_PRINSS+E2_PRISS)
									EndIf
								EndIf
							Else
								nCalcRend := ValRenPCC(cAliasPai, cAliasTrb)
							EndIf

							nRendTributavel += nCalcRend

							Fa401AddLog(	@aLog, lGerLog, aTitulo[CNPJ], aTitulo[CODIGORETENCAO], aTitulo[MES], cTpRen, (cAliasPai)->E2_FILIAL, (cAliasPai)->E2_PREFIXO,;
											(cAliasPai)->E2_NUM, (cAliasPai)->E2_PARCELA, (cAliasPai)->E2_TIPO, (cAliasPai)->E2_NATUREZ, nCalcRend,aTitulo[NIFEX], SA2->A2_COD,;
												SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )

							// Somo o valor do rendimento tributavel, apenas uma vez, pois o titulo pode ser pai de varios impostos
							Aadd(aTitPai,(cAliasTrb)->E2_CODRET + (cAliasPai)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
						Endif
					EndIf

				//processa 'IRRF' ou 'INSS sem a presenca de IRRF no titulo'
				Elseif !(cAliasTrb)->E2_TIPO $ MVINSS .Or. ((cAliasTrb)->E2_TIPO $ MVINSS .And. Empty((cAliasPai)->E2_IRRF))

					// Apuro o valor do rendimento tributavel para IRRF PJ e PF, pois o valor do tributo
					// pode fazer referencia a soma de outros titulos.
						dDtIni := FirstDay(MV_PAR02)
						cMes := F401CMES(dDtIni,LastDay(dDtIni),cMes,aTitulo[CODIGORETENCAO], lReproc, cFilAtu )
						cMesAnt := ""

					While dDtIni <= MV_PAR03
						bAscan := { || If( SA2->A2_TIPO == "F" .or. SA2->A2_IRPROG == '1' ,;
							Ascan(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1]+DTOS(dDtIni)+DTOS(LastDay(dDtIni))+aTitulo[CODIGORETENCAO]+cNIFEX) == 0,;
							Ascan(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1]+DTOS(dDtIni)+aTitulo[CODIGORETENCAO]+cNIFEX) == 0) }

						If Eval(bAscan) // Se ainda nao apurou o rendimento para este fornecedor no periodo

							// Tipo do rendimento considera tipo da entidade
							If lTpEnt
								If Empty((cAliasTrb)->A2_TPENT)
									cTpRen := "A"
								Else
									If (cAliasTrb)->A2_TPENT == "1"	 // Fornecedores Imunes
										cTpRen := "I2"
									ElseIf (cAliasTrb)->A2_TPENT == "2"  // Fornecedores Isentos
										cTpRen := "I3"
									EndIf
								EndIf
							Else
								cTpRen := "A"
							EndIf

							//Restauro a filial do sistema para a centralizadora
							If !Empty(MV_PAR06)
								SM0->(MsSeek(cEmpAnt+MV_PAR06))
								cFilAnt := MV_PAR06
							Endif

							// Se existir o ano na chave do SR4
							// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
							cChaveSr4 := xFilial("SR4")+SRL->RL_MAT+ Padr(aTitulo[CNPJ],Len(SR4->R4_CPFCGC)) +aTitulo[CODIGORETENCAO]+STRZERO(YEAR(dDtIni),4)+cMes

							// Gera valor do Rendimento do IR
							If !SR4->( MsSeek( cChaveSr4 + padr(cTpRen,nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX ))

								If cMesAnt <> cMes
									nRendTributavel := 0
									nNaoTributavel  := 0
									aRetBaseIR := F401BaseIr(	dDtIni,LastDay(dDtIni),@nNaoTributavel,cAliasTrb,@nDedDep,cFilAtu,aTitulo[CODIGORETENCAO],;
																@cTitsSum,lReproc,@aLog,aTitulo[CNPJ],cMes,lGerLog,aSelfil, cArqTMP1,lForExt,cNIFEX, lTemNIF, aCPFs[nK][2],@cDtPgt,aCPFs[nK][6],(cAliasPai)->(Recno()) )
								EndIf
								If ( SA2->A2_TIPO == "F" .or. (SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG == '1'))
									aEval(aRetBaseIR, {|x| nRendTributavel += x[2]})
									aEval(aRetBaseIR, {|x| nNaoTributavel += x[3]})
								Else
									aEval(aRetBaseIR, {|x| Iif(x[1] == dTos(dDtIni),nRendTributavel += x[2],0)})
									aEval(aRetBaseIR, {|x| Iif(x[1] == dTos(dDtIni),nNaoTributavel  += x[3],0)})
								EndIf

								If !(MV_PAR01 == 2  .and. MV_PAR05 == 2) .AND. !(MV_PAR01 == 4  .and. MV_PAR05 == 2)  // Vencimento e tit de imposto e baixa e tit de imposto

									If nRendTributavel > 0
										Reclock("SR4", .T.)

										SR4->R4_FILIAL  := xFilial("SR4")
										SR4->R4_MAT     := SRL->RL_MAT
										SR4->R4_CPFCGC  := aTitulo[CNPJ]
										SR4->R4_MES     := cMes
										SR4->R4_TIPOREN := cTpRen
										SR4->R4_CODRET  := aTitulo[CODIGORETENCAO]
										SR4->R4_ANO  := STRZERO(YEAR(dDtIni),4)
										SR4->R4_VALOR   := nRendTributavel

										nRegPai	:=	(cAliasPai)->(Recno())
										If !TMP1->(Dbseek(nRegPai))
											Reclock("TMP1", .T.)
											TMP1->NROREG 		:= nRegPai
											TMP1->TITIPAI		:= ((cAliasTrb)->(RECNOPAI) == nRegPai)
											TMP1->(MSUNLOCK())
										Endif

										SR4->R4_ORIGEM := "2"
										SR4->R4_NIFEX := SRL->RL_NIFEX
										If  !Empty(SRL->RL_PAIS)
											SR4->R4_PAIS := SRL->RL_PAIS
											
											SR4->R4_DTPGT := cDtPgt
											If lISNIF
												SR4->R4_ISNIF := IIF(lTemNIF,"1","2")
											EndIf
										EndIf

										If lFa401Cmp
											// Utilizado para gravar campos complementares do SR4
											ExecBlock("FA401CMP", .F.,.F.)
										Endif

										SR4->(MsUnlock())


										If SA2->A2_TIPO == "F" .or. SA2->A2_IRPROG == '1'
												If Ascan(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1]+DTOS(dDtIni)+DTOS(LastDay(dDtIni))+aTitulo[CODIGORETENCAO] + cNIFEX) == 0
													Aadd(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1]+DTOS(dDtIni)+DTOS(LastDay(dDtIni))+aTitulo[CODIGORETENCAO] + cNIFEX )
											Endif
										Else
												If Ascan(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1] +DTOS(dDtIni)+aTitulo[CODIGORETENCAO]+cNIFEX) == 0
													Aadd(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1] +DTOS(dDtIni)+aTitulo[CODIGORETENCAO]+cNIFEX)
											Endif
										Endif

									Endif
								EndIf

								If nNaoTributavel > 0
									If !SR4->(MsSeek(cChaveSr4+padr("I",nTamTpRen)+SRL->RL_PAIS + SRL->RL_NIFEX ))

										Reclock("SR4", .T.)

										SR4->R4_FILIAL  := xFilial("SR4")
										SR4->R4_MAT     := SRL->RL_MAT
										SR4->R4_CPFCGC  := aTitulo[CNPJ]
										SR4->R4_MES     := STRZERO(MONTH(dDtIni),2)
										SR4->R4_TIPOREN := "I"
										SR4->R4_CODRET  := aTitulo[CODIGORETENCAO]
										SR4->R4_ANO  := STRZERO(YEAR(dDtIni),4)
										SR4->R4_VALOR   := nNaoTributavel

										SR4->R4_ORIGEM := "2"
										SR4->R4_NIFEX := SRL->RL_NIFEX
										If !Empty(SRL->RL_PAIS)
											SR4->R4_PAIS := SRL->RL_PAIS
											
											SR4->R4_DTPGT := dDtIni
											If lISNIF
												SR4->R4_ISNIF := IIF(lTemNIF,"1","2")
											EndIf

										EndIf

										If lFa401Cmp
											// Utilizado para gravar campos complementares do SR4
											ExecBlock("FA401CMP", .F.,.F.)
										Endif

										SR4->(MsUnlock())

										//-- Função para gravar tabela RCS
										FinGrvRCS(cTipoFJ,aTitulo,nNaoTributavel,cAliasTrb)

									Endif
								Endif

								If nDedDep > 0
									If !SR4->(MsSeek(cChaveSr4+padr("T",nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX ))

										Reclock("SR4", .T.)

										SR4->R4_FILIAL  := xFilial("SR4")
										SR4->R4_MAT     := SRL->RL_MAT
										SR4->R4_CPFCGC  := aTitulo[CNPJ]
										SR4->R4_MES     := STRZERO(MONTH(dDtIni),2)
										SR4->R4_TIPOREN := "T"
										SR4->R4_CODRET  := aTitulo[CODIGORETENCAO]
										SR4->R4_ANO  := STRZERO(YEAR(dDtIni),4)
										SR4->R4_VALOR   := nDedDep
										SR4->R4_ORIGEM := "2"
										SR4->R4_NIFEX := SRL->RL_NIFEX

										If !Empty(SRL->RL_PAIS)
											SR4->R4_PAIS := SRL->RL_PAIS
											SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
											If lISNIF
												SR4->R4_ISNIF :=  IIF(lTemNIF,"1","2")
											EndIf
										EndIf

										If lFa401Cmp
											// Utilizado para gravar campos complementares do SR4
											ExecBlock("FA401CMP", .F.,.F.)
										Endif

										SR4->(MsUnlock())

										Fa401AddLog(	@aLog, lGerLog, SR4->R4_CPFCGC, SR4->R4_CODRET, SR4->R4_MES, SR4->R4_TIPOREN, (cAliasTRB)->E2_FILIAL, "",;
														"", "", "", "", nDedDep,SR4->R4_NIFEX,SA2->A2_COD, SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
									Endif
								Endif
								// depende de retornar corretamente os titulos do dia que serao considerados
								While Len(cTitsSum) > 0
									//Restura a filial para a original para o uso do DbSeek
									If !Empty(MV_PAR06)
										cFilAnt := cFilAtu
									Endif
									SE2->(DbSeek(xFilial("SE2")+SubStr(cTitsSum,1,AT("|",cTitsSum)-(Len((cAliasTrb)->E2_CODRET)+1)))) //			cTitsSum += TRBIRF->( E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA ) + cCodRet + "|"
									//Restauro a filial do sistema para a centralizadora
									If !Empty(MV_PAR06)
										cFilAnt := MV_PAR06
									Endif

									Aadd(aRecno, SE2->(Recno()))

									cTitsSum := SubStr(cTitsSum,AT("|",cTitsSum)+1,Len(cTitsSum))
								EndDo
							Else// se nao é PF e não é PJ com IR Progressivo
								If ( SA2->A2_TIPO != "F" .and. !SA2->A2_IRPROG == '1' ) .Or. MV_PAR08 == 1

									If cMesAnt <> cMes
										nRendTributavel := 0
										nNaoTributavel  := 0

										aRetBaseIR := F401BaseIr(	dDtIni,LastDay(dDtIni),@nNaoTributavel,cAliasTrb,,cFilAtu,aTitulo[CODIGORETENCAO],;
																			@cTitsSum,lReproc,@aLog,aTitulo[CNPJ],cMes,lGerLog,aSelFil,cArqTMP1,lForExt, cNIFEX,lTemNIF,aCPFs[nK][2],@cDtPgt,aCPFs[nK][6],(cAliasPai)->(Recno()) )
									EndIf

									If ( SA2->A2_TIPO == "F" .or. (SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG == '1'))
										aEval(aRetBaseIR, {|x| nRendTributavel += x[2]})
										aEval(aRetBaseIR, {|x| nNaoTributavel += x[3]})
									Else
										aEval(aRetBaseIR, {|x| Iif(x[1] == dTos(dDtIni),nRendTributavel += x[2],0)})
										aEval(aRetBaseIR, {|x| Iif(x[1] == dTos(dDtIni),nNaoTributavel  += x[3],0)})
									EndIf

									If !(MV_PAR01 == 4  .and. MV_PAR05 == 2)
										If nRendTributavel > 0
											Reclock("SR4", .F.)
											SR4->R4_VALOR   += nRendTributavel

											nRegPai	:=	(cAliasPai)->(Recno())
											If !TMP1->(Dbseek(nRegPai))
												Reclock("TMP1", .T.)
												TMP1->NROREG 		:= nRegPai
												TMP1->TITIPAI		:= ((cAliasTrb)->(RECNOPAI) == nRegPai)
												TMP1->(MSUNLOCK())
											Endif

											SR4->(MsUnlock())
										Endif
									EndIf

									If nNaoTributavel > 0

										If !SR4->(MsSeek(cChaveSr4+padr(cTpRen,nTamTpRen)+ SRL->RL_PAIS + SRL->RL_NIFEX))

											Reclock("SR4", .T.)

											SR4->R4_FILIAL  := xFilial("SR4")
											SR4->R4_MAT     := SRL->RL_MAT
											SR4->R4_CPFCGC  := aTitulo[CNPJ]
											SR4->R4_MES     := STRZERO(MONTH(dDtIni),2)
											SR4->R4_TIPOREN := cTpRen
											SR4->R4_CODRET  := aTitulo[CODIGORETENCAO]
											SR4->R4_ANO  := STRZERO(YEAR(dDtIni),4)
											SR4->R4_ORIGEM := "2"
											SR4->R4_NIFEX := SRL->RL_NIFEX

											If  !Empty(SRL->RL_PAIS)
												SR4->R4_PAIS := SRL->RL_PAIS												
												SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
												If lISNIF
													SR4->R4_ISNIF :=  IIF(lTemNIF,"1","2")
												EndIf

											EndIf

										Else
											Reclock("SR4", .F.)
										Endif

										SR4->R4_VALOR   += nNaoTributavel

										If lFa401Cmp
											// Utilizado para gravar campos complementares do SR4
											ExecBlock("FA401CMP", .F.,.F.)
										Endif

										SR4->(MsUnlock())
										//-- Função para gravar tabela RCS
										FinGrvRCS(cTipoFJ,aTitulo,nNaoTributavel,cAliasTrb)
									Endif
								Else
									//certeza que ainda nao somou para esse fornecedor+mes+codret

									If !lReproc .and. Ascan(aFornec, (cAliasTrb)->E2_FILIAL + aTitulo[CNPJ]+DTOS(dDtIni)+DTOS(LastDay(dDtIni))+aTitulo[CODIGORETENCAO] + cNIFEX ) == 0//Ascan(aFornec, aTitulo[1]) == 0

											If cMesAnt <> SR4->R4_MES
												nRendTributavel := 0
												nNaoTributavel  := 0

												aRetBaseIR := F401BaseIr(	dDtIni,LastDay(dDtIni),@nNaoTributavel,cAliasTrb,@nDedDep,cFilAtu,aTitulo[CODIGORETENCAO],;
																					@cTitsSum,lReproc,@aLog,aTitulo[CNPJ],SR4->R4_MES,lGerLog,aSelfil,cArqTMP1,lForExt,cNIFEX,lTemNIF,aCPFs[nK][2],@cDtPgt,aCPFs[nK][6],(cAliasPai)->(Recno()) )

											EndIf
											If ( SA2->A2_TIPO == "F" .or. (SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG == '1'))
												aEval(aRetBaseIR, {|x| nRendTributavel += x[2]})
												aEval(aRetBaseIR, {|x| nNaoTributavel += x[3]})
											Else
												aEval(aRetBaseIR, {|x| Iif(x[1] == dTos(dDtIni),nRendTributavel += x[2],0)})
												aEval(aRetBaseIR, {|x| Iif(x[1] == dTos(dDtIni),nNaoTributavel  += x[3],0)})
											EndIf

											If nRendTributavel > 0
												Reclock("SR4", .F.)
												SR4->R4_VALOR  += nRendTributavel
												SR4->(MsUnlock())

												nRegPai	:=	(cAliasPai)->(Recno())
												If !TMP1->(Dbseek(nRegPai))
													Reclock("TMP1", .T.)
													TMP1->NROREG 		:= nRegPai
													TMP1->TITIPAI		:= ((cAliasTrb)->(RECNOPAI) == nRegPai)
													TMP1->(MSUNLOCK())
												Endif

											EndIf
											If nNaoTributavel > 0
												// Tipo do rendimento considera tipo da entidade
												If lTpEnt
													If Empty((cAliasTrb)->A2_TPENT)
														cTpRen := "I"
													Else
														If (cAliasTrb)->A2_TPENT == "1"	 // Fornecedores Imunes
															cTpRen := "I2"
														ElseIf (cAliasTrb)->A2_TPENT == "2"  // Fornecedores Isentos
															cTpRen := "I3"
														EndIf
													EndIf
												Else
													cTpRen := "I"
												EndIf
												If !SR4->(MsSeek(cChaveSr4+padr(cTpRen,nTamTpRen)+ SRL->RL_PAIS + SRL->RL_NIFEX ))

													Reclock("SR4", .T.)

													SR4->R4_FILIAL  := xFilial("SR4")
													SR4->R4_MAT     := SRL->RL_MAT
													SR4->R4_CPFCGC  := aTitulo[CNPJ]
													SR4->R4_MES     := STRZERO(MONTH(dDtIni),2)
													SR4->R4_TIPOREN := cTpRen
													SR4->R4_CODRET  := aTitulo[CODIGORETENCAO]
													SR4->R4_ANO  := STRZERO(YEAR(dDtIni),4)
													SR4->R4_ORIGEM := "2"
													SR4->R4_NIFEX := SRL->RL_NIFEX

													If !Empty(SRL->RL_PAIS)
														SR4->R4_PAIS := SRL->RL_PAIS														
														SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
														If lISNIF
															SR4->R4_ISNIF :=  IIF(lTemNIF,"1","2")
														EndIf
													EndIf

												Else
													Reclock("SR4", .F.)
												Endif

												SR4->R4_VALOR   += nNaoTributavel

												If lFa401Cmp
													// Utilizado para gravar campos complementares do SR4
													ExecBlock("FA401CMP", .F.,.F.)
												Endif

												SR4->(MsUnlock())
											Endif
									EndIf
								Endif
							Endif

							//Restauro a filial do sistema quando processar com filial centralizadora
							If !Empty(MV_PAR06)
								cFilAnt := cFilAtu
							Endif

							If SA2->A2_TIPO == "F" .or. SA2->A2_IRPROG == '1'
									If Ascan(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1]+DTOS(dDtIni)+DTOS(LastDay(dDtIni))+aTitulo[CODIGORETENCAO] + cNIFEX ) == 0 .And.;
									(aTitulo[MES] == STRZERO(MONTH(dDtIni),2))
										Aadd(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1]+DTOS(dDtIni)+DTOS(LastDay(dDtIni))+aTitulo[CODIGORETENCAO]+ cNIFEX )
								Endif

								cMesAnt:= STRZERO(MONTH(dDtini),2)
								dDtIni += 40
								dDtIni := FirstDay(dDtIni)
								cMes := F401CMES(dDtIni,LastDay(dDtIni),cMes,aTitulo[CODIGORETENCAO],lReproc, cFilAtu )
							Else
									If Ascan(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1] +DTOS(dDtIni)+aTitulo[CODIGORETENCAO] + cNIFEX ) == 0
										Aadd(aFornec, (cAliasTrb)->E2_FILIAL + aCPFs[nk][1] +DTOS(dDtIni)+aTitulo[CODIGORETENCAO]+ cNIFEX)
								Endif

								cMesAnt:= STRZERO(MONTH(dDtini),2)
								dDtIni++
								cMes:=F401CMES(dDtIni,LastDay(dDtIni),cMes,aTitulo[CODIGORETENCAO],lReproc, cFilAtu )
							Endif

						Else
							cMesAnt:= STRZERO(MONTH(dDtini),2)
							dDtIni := FirstDay(MsSomaMes(dDtIni, 1, .F.))

							If SR4->( MsSeek( cChaveSr4 + padr(cTpRen,nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX ))
								If !Empty(SRL->RL_PAIS)
									Reclock("SR4", .F.)
									SR4->R4_DTPGT := cDtPgt
									SR4->(MsUnlock())

								EndIf
							EndIf

						Endif
						nRendTributavel := 0
						nNaoTributavel	 := 0
					EndDo

				Endif

				If nRendTributavel > 0
					//Restauro a filial do sistema para a centralizadora
					If !Empty(MV_PAR06)
						cFilAnt := MV_PAR06
					Endif

					// Tipo do rendimento considera tipo da entidade
					If lTpEnt
						If Empty((cAliasTrb)->A2_TPENT)
							cTpRen := "A"
						Else
							If (cAliasTrb)->A2_TPENT == "1"	 // Fornecedores Imunes
								cTpRen := "I2"
							ElseIf (cAliasTrb)->A2_TPENT == "2"  // Fornecedores Isentos
								cTpRen := "I3"
							EndIf
						EndIf
					Else
						cTpRen := "A"
					EndIf

					// Gera valor do Rendimento do IR
					If !SR4->(MsSeek(cChaveSr4+padr(cTpRen,nTamTpRen)+ SRL->RL_PAIS + SRL->RL_NIFEX))

						Reclock("SR4", .T.)

						SR4->R4_FILIAL  := xFilial("SR4")
						SR4->R4_MAT     := SRL->RL_MAT
						SR4->R4_CPFCGC  := aTitulo[CNPJ]
						SR4->R4_MES     := aTitulo[MES]
						SR4->R4_TIPOREN := cTpRen
						SR4->R4_CODRET  := aTitulo[CODIGORETENCAO]
						SR4->R4_ANO  := aTitulo[ANO]
						SR4->R4_ORIGEM := "2"
						SR4->R4_NIFEX := SRL->RL_NIFEX

						If  !Empty(SRL->RL_PAIS)
								SR4->R4_PAIS := SRL->RL_PAIS
								
								SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
								If lISNIF
									SR4->R4_ISNIF :=  IIF(lTemNIF,"1","2")
								EndIf
						EndIf

						If lFa401Cmp
							// Utilizado para gravar campos complementares do SR4
							ExecBlock("FA401CMP", .F.,.F.)
						Endif

						SR4->R4_VALOR += nRendTributavel

					Else
						If lF401VldPai

							lVldPai:= ExecBlock("F401VldPai",.F.,.F.,{(cAliasTrb)->RECNOPAI})

							If lVldPai

								nRegPai	:=	(cAliasPai)->(Recno())
								If !TMP1->(Dbseek(nRegPai))
									Reclock("SR4", .F.)
									SR4->R4_VALOR += nRendTributavel
								Endif

							Else
								Reclock("SR4", .F.)
								SR4->R4_VALOR += nRendTributavel
							EndIf
						Else
							Reclock("SR4", .F.)
							SR4->R4_VALOR += nRendTributavel
						EndIf
					Endif

					nRegPai	:=	(cAliasPai)->(Recno())
					If !TMP1->(Dbseek(nRegPai))
						Reclock("TMP1", .T.)
						TMP1->NROREG 		:= nRegPai
						TMP1->TITIPAI		:= ((cAliasTrb)->(RECNOPAI) == nRegPai)
						TMP1->(MSUNLOCK())
					Endif

					SR4->(MsUnlock())

				Endif

				//Restauro a filial do sistema quando processar com filial centralizadora
				If !Empty(MV_PAR06)
					cFilAnt := cFilAtu
				Endif

				ConfirmSx8()

				Aadd(aRecno, (cAliasTrb)->R_E_C_N_O_)

				//limpa array
				//EXISTE CENÁRIO EM QUE O ARRAY NÃO É INSTANCIADO CAUSANDO ERROR LOG, ESSA VALIDAÇÃO VISA NÃO CAUSAR ERROR.LOG
				If ValType(aRetBaseIR) != "U"
					aSize(aRetBaseIR,0)
					aRetBaseIR := Nil
				EndIf

			Next nK
		EndIf
	EndIf

	//RESTAURO PARA A FILIAL DO WHILE, FILIAL DE ENTRADA NO SISTEMA
	If !Empty(MV_PAR06)
		cFilAnt := cFilAtu
	Endif

	dbSelectArea(cAliasTrb)
	(cAliasTrb)->(dbSkip())
Enddo

(cAliasTrb)->(dbCloseArea())
dbSelectArea("SE2")
dbSetOrder(1)

// Atualiza o flag de geracao da DIRF.
For nX := 1  To Len(aRecno)
	cRecno := ""

	// Monta a string limitando a 500 registros por vez
	For nY := nX To (499+nX)
		If nY > Len(aRecno)
			Exit
		Endif
		cRecno += Alltrim(Str(aRecno[nY],20))+","
	Next

	// Atualiza o flag de geracao da DIRF para nao gerar novamente em novo processamento.
	cQuery := "UPDATE "
	cQuery += RetSqlName("SE2")+" "
	cQuery += "SET E2_DTDIRF = '" + Dtos(dDataBase) + "'"
	cQuery += " WHERE R_E_C_N_O_ IN ("+SubStr(cRecno,1,rat(",",cRecno)-1)+") AND "
	cQuery += "D_E_L_E_T_ = ' ' "

	TcSqlExec(cQuery)

	nX := nY
Next

//Array com os titulos pais já processados
Aadd( aTitJaProc , aTitPai )
Aadd( aTitJaProc , aBxPai  )
Aadd( aTitJaProc , aUltPCC )

// Processa todos os forncedores que não
// tiveram impostos no periodo
// ou  titulos que possuem fatura com retencao de IRRF ou PCC na baixa.
// Na gestão de filiais, a rotina será executada uma vez para cada filial selecionada
If MV_PAR08 == 1 
	For nX := 1 To Len( aSelFil )
		cFilSE2 := xFilial("SE2",aSelFil[nX])
		If Ascan(aFilProc, cFilSE2 ) == 0 //Verifica se filial já foi processada
			Aadd(aFilProc, cFilSE2 )
			cFilAnt  := aSelFil[ nX ]
			cFilAtu  := aSelFil[ nX ]
			// Processa todos os titulos que possuirem retencao de IR ou PCC mas nao geraram titulos de impostos e nao estao retidos em outros titulos.
			// No final desta função já é feito a exclusao das datas da dirf no caso de reprocessamento para os titulos selecionados (igual Fa401UpDtDirf).
			Fa401SemRet(aRecno,lReproc,cFilAtu,@aLog,lGerLog,cArqTMP1)
			Fa401SemImp(aRecno,lReproc,cFilAtu,@aLog,lGerLog,aTitJaProc,cArqTMP1)
		Endif
	Next nX
	
	cFilAnt := cFilInic
Else
	cFilAnt := cFilInic
	cFilAtu := cFilInic
	// Processa todos os titulos que possuirem retencao de IR ou PCC mas nao geraram titulos de impostos e nao estao retidos em outros titulos.
	// No final desta função já é feito a exclusao das datas da dirf no caso de reprocessamento para os titulos selecionados (igual Fa401UpDtDirf).
	Fa401SemRet(aRecno,lReproc,cFilAtu,@aLog,lGerLog,cArqTMP1)
	Fa401SemImp(aRecno,lReproc,cFilAtu,@aLog,lGerLog,aTitJaProc,cArqTMP1)
EndIf

//Gera o repasse do IR
If lFina405 .and. MV_PAR04 == 2 // PJ
	cFilCen := If(Empty(MV_PAR06), cFilCen, MV_PAR06)
	aRecnoFon := Fa405DIRF("FINA401", @aLog, lGerLog, cFilCen, MV_PAR02, MV_PAR03, aSelFil )
EndIf

If lErroUpd .or. !lQuery
	Fa401UpDtDirf(lPlsAtiv,lReproc,cPccTit,cCampo,cCampoP,cChave,ni,nTotREG,cIndex)
EndIf
NEWSE2->(dbCloseArea())

WrDtDirf(aRecno, cIndex)

// Zera o valor do rendimento de fornecedores que nao reteram IR, mas reteram INSS
// e o valor do rendimento ficou inferior a 6000.
// Alteração feita conforme resposta da nossa consultoria tributária.
// Caso haja necessidade de desfazer esse procedimento, basta desviar essa chamada ou excluí-la.
// Também zera o proprio INSS conforme nossa consulta jurídica - JIRA - 02/fev/10

//NAO DEVE ZERAR OS VALORES, ESTES DEVEM IR PARA SR4 ONDE O RH IRÁ FILTRAR PARA A DIRF
//Fa401ZRINSS(@aLog)

If lF401dcmp
	// Utilizado para gravar DADOS COMPLEMENTARES
	ExecBlock("F401DCMP", .F.,.F.)
Endif


If !Empty(aEmptyCPF) .and. !lAutomato
	ForSemCPF()
EndIf


If lGerLog
	If Len(aLog) > 0
		// Grava arquivo de LOG em formato .CSV
		cArqLog := Fa401GerLog( aLog )
		// Deseja visualizar relatorio de log com os titulos processados? ### Atencao
		If MsgYesNo( STR0030, STR0031 )
			Fa401ImpLog( aLog, cArqLog )
		EndIf
	Endif

	If Len(aRecnoFon) > 0 .AND. lFina405
		If MsgYesNo( STR0043, STR0031 )  //"Deseja visualizar o relatório de log com os repasses de IR processados?"
			FINR405(aRecnoFon)
		EndIf
	EndIF
EndIf

If Select("__NEWSE2") > 0
	__NEWSE2->(DbCloseArea())
Endif

//Restauro a filial do sistema quando processar com filial centralizadora
If !Empty(MV_PAR06)
	cFilAnt := cFilInic
Endif

RestArea(aArea)
TMP1->(DbCloseArea())

FWFReeArray(aFilProc)

//Deleta tabela temporária no banco de dados, caso exista
If _oFINA4011 <> Nil
	_oFINA4011:Delete()
	_oFINA4011 := Nil
Endif

Return


//***************
// Soma um no ultimo byte de uma string, normalmente
// para ser utilizado em pesquisas com softseek on, para posicionar no
// ultimo registro + 1, de uma chave. Ex.:
// cChave := "CLAUDIO"
// DbSeek(IncLast(cChave)),.T.) // DbSeek("CLAUDIP")
// Se na base tiver:
// CLAUDIO <-- Ponteiro atual    (1)
// CLAUDIO
// CLAUDIO
// CLAUDIO
// DANIELA <-- Apos o DbSeek     (2)
STATIC FUNCTION IncLast( cString )
Return Left(cString, Len(cString)-1)+;
       CHR(ASC(RIGHT(cString,1))+1)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Fa401Pai  ºAutor  ³Microsiga           º Data ³  02/19/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
STATIC FUNCTION Fa401Pai(cAliasTrb)
Local nRegSE2	:= NEWSE2->(Recno())
Local lAchou	:= .F.
Local cPrefixo 	:= (cAliasTrb)->E2_PREFIXO
Local cNum		:= (cAliasTrb)->E2_NUM
Local cParcela 	:= (cAliasTrb)->E2_PARCELA
Local cTipoPai 	:= (cAliasTrb)->E2_TIPO
Local cParcPai 	:= ""
Local aArea 	:= GetArea()
Local lPai 		:= .F.
Local lPis		:= .F.
Local lCofins	:= .F.
Local lCsll		:= .F.
Local cTitPai	:= (cAliasTrb)->E2_TITPAI
Local lNatPCC	:= 	AllTrim(GetMv("MV_PISNAT")) == AllTrim(GetMv("MV_COFINS")) .And.;	//Verifica se a natureza é a
					AllTrim(GetMv("MV_COFINS")) == AllTrim(GetMv("MV_CSLL"))				//mesma para o Pis, Cofins e Csll.

If lNatPCC //Quando utilizar a mesma natureza nos títulos de PCC.

	//Como os títulos de impostos possuem o mesmo nome, é necessário encontrar o título principal mesmo não
	//existindo uma chave completa de pesquisa.
	dbSelectArea( "NEWSE2" )
	dbSetOrder(1)

	If MsSeek( xFilial("SE2") + cPrefixo + cNum )

		While !Eof() .And. NEWSE2->( E2_FILIAL + E2_PREFIXO + E2_NUM ) == xFilial("SE2") + cPrefixo + cNum

			If NEWSE2->E2_PARCPIS == cParcela
				If NEWSE2->E2_PIS == (cAliasTrb)->E2_VALOR
					lPis := .T.
					Exit
				EndIf

			ElseIf NEWSE2->E2_PARCCOF == cParcela
				If NEWSE2->E2_COFINS == (cAliasTrb)->E2_VALOR
					lCofins := .T.
					Exit
				EndIf

			ElseIf NEWSE2->E2_PARCSLL == cParcela
				If NEWSE2->E2_CSLL == (cAliasTrb)->E2_VALOR
					lCsll := .T.
					Exit
				EndIf

			EndIf

			NEWSE2->(DbSkip())
		Enddo
	EndIf

	If (cAliasTrb)->E2_TIPO $ MVTAXA + "/" + MVTXA .Or. (cAliasTrb)->E2_TIPO $ MVINSS+"|"+"INA"

		If (cAliasTrb)->E2_FORNECE == GetMv("MV_MUNIC")
			cValorPai := "NEWSE2->E2_ISS"
			cParcPai  := "E2_PARCISS"

		Else
			Do Case
			Case lPis
				cValorPai := "NEWSE2->E2_PIS"
				cParcPai  := "E2_PARCPIS"

			Case lCofins
				cValorPai := "NEWSE2->E2_COFINS"
				cParcPai  := "E2_PARCCOF"

			Case lCsll
				cValorPai := "NEWSE2->E2_CSLL"
				cParcPai  := "E2_PARCSLL"

			Case Alltrim((cAliasTrb)->E2_NATUREZ) $ cMVINSNAT
				cValorPai := "NEWSE2->E2_INSS"
				cParcPai  := "E2_PARCINS"

			OtherWise
				cValorPai := "NEWSE2->E2_IRRF"
				cParcPai  := "E2_PARCIR"
			EndCase
		Endif
	Else
		lPai := .T.
	Endif

Else
	If (cAliasTrb)->E2_TIPO $ MVTAXA + "/" + MVTXA .Or. (cAliasTrb)->E2_TIPO $ MVINSS+"|"+"INA"

	 	If AllTrim((cAliasTrb)->E2_TITPAI) <> ""
			cTitPai	:= (cAliasTrb)->E2_TITPAI
		EndIf

		If (cAliasTrb)->E2_FORNECE == GetMv("MV_MUNIC")
			cValorPai := "NEWSE2->E2_ISS"
			cParcPai := "E2_PARCISS"
		Else
			Do Case
			Case Alltrim((cAliasTrb)->E2_NATUREZ) $ cMVPISNAT
				cValorPai := "NEWSE2->E2_PIS"
				cParcPai := "E2_PARCPIS"

			Case Alltrim((cAliasTrb)->E2_NATUREZ) $ cMVCOFNAT
				cValorPai := "NEWSE2->E2_COFINS"
				cParcPai := "E2_PARCCOF"

			Case Alltrim((cAliasTrb)->E2_NATUREZ) $ cMVCSLNAT
				cValorPai := "NEWSE2->E2_CSLL"
				cParcPai := "E2_PARCSLL"

			Case Alltrim((cAliasTrb)->E2_NATUREZ) $ cMVINSNAT
				cValorPai := "NEWSE2->E2_INSS"
				cParcPai := "E2_PARCINS"

			OtherWise
				cValorPai := "NEWSE2->E2_IRRF"
				cParcPai := "E2_PARCIR"

			EndCase
		Endif
	Else
		lPai := .T.
	Endif
EndIf

// Se nao estiver no titulo pai, procura o titulo Pai.
If !lPai
	dbSelectArea("NEWSE2")
	dbSetOrder(1)
	nRegSE2:= Recno()

	If !EMPTY(cTitPai)
		If MsSeek(xFilial("SE2")+cTitPai)
			lAchou := .T.
		EndIf

	ElseIf MsSeek( xFilial("SE2") + cPrefixo + cNum )
		While !Eof() .and. NEWSE2->( E2_FILIAL + E2_PREFIXO + E2_NUM ) == xFilial( "SE2" ) + cPrefixo + cNum

			If &(cParcPai) == cParcela .and. IIF( cTipoPai $ MVTXA , NEWSE2->E2_TIPO $ MVPAGANT + "/" + MV_CPNEG , .T. )
				If &(cValorPai) != 0
					lAchou := .T.
					Exit
				EndIf
			EndIf

			NEWSE2->(DbSkip())
		Enddo

	EndIf
Endif

dbSelectArea("NEWSE2")

// Se nao encontrou o registro pai, restaura o ponteiro do alias alternativo
// Pois o registro pode ja estar posicionado no titulo principal.
If !lAchou .And. !lPai
	dbGoto(nRegSE2)

ElseIf !lAchou
	NEWSE2->(MsSeek(xFilial("SE2")+(cAliasTrb)->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))

Endif

RestArea(aArea)

Return lAchou

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³F401BaseIr³ Autor ³ Claudio D. de Souza   ³ Data ³ 05/01/07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Base de caclculo do IR Pessoa Fisica e Juridica			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FBaseIr(dDtIni,dDtFin)							          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpD1 = Data Inicial        								  ³±±
±±³			 ³ ExpD2 = Data Final										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA401													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function F401BaseIr(	dDtIni, dDtFin, nNaoTributavel, cAliasTrb, nDedDep, cFilAtu,;
							cCodRet, cTitsSum, lReproc, aLog, cCGCCPF, cMes,;
							lGerLog, aSelFil ,TMP1, lForExt,cNIFEX, lTemNIF , nPercIR, dDtPgt, lNovoCalc, nRegPai)

Local aArea := GetArea()
Local aAreaTRB := {}
Local nTotTit := 0
Local nTotInss := 0
Local nTotIrrf := 0
Local nX := 0


// Carrega variavel de verificacao de consideracao de valor minimo de retencao de IR.




Local nBaseIr   := 0
Local lAtuDep   := .F.
Local aTabIr[6,3]
Local dData   	:= dtos(dDtIni)
Local cChaveSr4

Local lIRPFBaixa := If(SA2->A2_CALCIRF == "2", .T., .F.)
Local lAbatINSS	:=  lINSIRF .And. MV_PAR04 == 1
Local nLenLog	:= 0
Local nTotPLS	:= 0
Local lUnidNeg	:= FWGETTAMFILIAL > 2	// Indica se usa Gestao Corporativa

//--
Local lPesJur	:= SA2->A2_TIPO == "J"
Local lCalcIssBx:= .F.
Local cA2CGC	:= SA2->A2_CGC
Local aAreaSR4 := SR4->(GetArea())

Local cAno := STR(YEAR(dDtIni),4)
Local cSepRec := If("|"$MVPAGANT,"|",",")

Local nSomaBxPA := 0
Local nImpEmis := 0
Local lRetemPCC := __lPccbaixa .and. ( SA2->A2_RECPIS == "2" .OR. SA2->A2_RECCOFI == "2" .OR. SA2->A2_RECCSLL == "2")
Local aRetBase := {}
Local cCampoD  := ""
Local dDataAnt := dData
Local nTotNaoTrib := 0
Local nPercReduz:= 0
Local nValNTrib	:= 0
Local cTpRen	:= ""
Local aBaixas 	:= {}
Local lRatIRRF	:= SuperGetMV("MV_RATIRRF",.F.,.T.)
local lFK4OK	:= ( getRpoRelease() >= '12.1.033' ) .and. ( val(SuperGetMV("MV_FINFIX", .F., '0')) > 12 ) //FIX 012 - Ajusta a tabela FK4 gravando os campos FK4_CGC e FK4_RAICGC

Default lTemNIF := .F.
Default lForExt := .F.
Default cNIFEX := ""
Default nPercIR := 100
Default lNovoCalc := .F.
Default nRegPai	:= 0

//Quando IR Progressivo
If SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG = '1'
	If Len(cCGCCPF) < 14
		cCGCCPF	:= cCGCCPF + Replicate( " ", 14-Len(cCGCCPF) )
	Endif
Endif

//Carregar variaveis
//__lPccBaixa
If __lpccbaixa == nil
	F401PccBx()
EndIf
lCalcIssBx :=	lPesJur .and. lMRETISS //Retencao do ISS pela emissao (1) ou baixa (2)

If FindFunction( 'IsIssBx' )
	lCalcIssBx :=	IsIssBx( "P" )
EndIf


nNaoTributavel  := 0
nDedDep         := 0

cFilAnt := cFilAtu

DEFAULT aSelFil := { cFilAnt }

cQuery := c401QryIr1
cQuery += " AND SE2.E2_FILIAL = '" + xFilial("SE2") + "'"
cQuery += " AND SA2.A2_FILIAL = '" + xFilial("SA2") + "'"

If !Empty( Iif( lUnidNeg, FWFilial("SED") , xFilial("SED") ) )  .And. Empty( Iif( lUnidNeg, FWFilial("SE2") , xFilial("SE2") ) )
	cQuery += "   AND SED.ED_FILIAL =  SE2.E2_FILORIG "
Else
	cQuery += "   AND SED.ED_FILIAL = '" + xFilial( "SED" ) + "'"
Endif

//--
If	lPesJur .and. !lForExt
	/*
	// Tratamento para multiplos fornecedores com Mesmo CNPJ
	If "MYSQL" $ Upper(TCGetDB())
		cQuery += " AND "+cQryConcat+"SE2.E2_FORNECE,SE2.E2_LOJA) IN (SELECT "+cQryConcat+"SA2.A2_COD,SA2.A2_LOJA) FROM "
	Else
		cQuery += "   AND (SE2.E2_FORNECE "+cQryConcat+" SE2.E2_LOJA) IN (SELECT (SA2.A2_COD "+cQryConcat+" SA2.A2_LOJA) FROM "
	Endif
	cQuery += RetSQLname("SA2") + " SA2 WHERE SA2.A2_CGC = '" + cA2CGC + "'
	cQuery += " )"
	*/
	cQuery += " AND SA2.A2_CGC = '" + cA2CGC + "' "
	cQuery += " AND SA2.A2_PAISEX = ' ' "
	If SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG = '1'
		cQuery += " AND SA2.A2_CPFIRP	= '" + SA2->A2_CPFIRP +	"'"
	Endif

Else
	cQuery += "   AND SE2.E2_FORNECE = '" + SA2->A2_COD + "'"
	cQuery += "   AND SE2.E2_LOJA = '" + SA2->A2_LOJA + "' "
EndIf

// Para Pessoa fisica totaliza os titulos emitidos no mes
If SA2->A2_TIPO == "F" .or. (SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG == '1')
	Do Case
		Case MV_PAR01 == 1 // Data de emissao digitada
			cQuery += " AND SE2.E2_EMIS1 >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_EMIS1 <= '" + Dtos(dDtFin) + "' "
			cCampoD := "E2_EMIS1"
		Case MV_PAR01 == 2// Vencimento
			cQuery += " AND SE2.E2_VENCTO >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_VENCTO <= '" + Dtos(dDtFin) + "' "
			cCampoD := "E2_VENCTO"
		Case MV_PAR01 == 3 //Vencimento real
			cQuery += " AND SE2.E2_VENCREA >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_VENCREA <= '" + Dtos(dDtFin) + "' "
			cCampoD := "E2_VENCREA"
		Case MV_PAR01 == 4 //Data de Baixa ³  MV_PAR01		 // Considera data                                      ³
			cQuery += " AND ((SE2.E2_BAIXA >= '" + Dtos(dDtIni) + "' AND "
			cQuery += "   SE2.E2_BAIXA <= '" + Dtos(dDtFin) + "') OR "
			cQuery += "  (SE2.E2_BAIXA = ' ' AND "
			cQuery += "   SE2.E2_EMIS1 >= '" + Dtos(dDtIni) + "' AND "
			cQuery += "   SE2.E2_EMIS1 <= '" + Dtos(dDtFin)	+ "') ) "
			cCampoD := "E2_BAIXA"
		Case MV_PAR01 == 5 // Data de emissao real
			cQuery += " AND SE2.E2_EMISSAO >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_EMISSAO <= '" + Dtos(dDtFin) + "' "
			cCampoD := "E2_EMISSAO"
	EndCase
Else
	Do Case
		Case MV_PAR01 == 1 // Data de emissao digit.
			cQuery += " AND SE2.E2_EMIS1 >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_EMIS1 <= '" + Iif(dDtFin < MV_PAR03,Dtos(dDtFin), Dtos(MV_PAR03)) + "' "
			cCampoD := "E2_EMIS1"
		Case MV_PAR01 == 2// Vencimento
			cQuery += " AND SE2.E2_VENCTO >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_VENCTO <= '" + Iif(dDtFin < MV_PAR03,Dtos(dDtFin), Dtos(MV_PAR03)) + "' "
			cCampoD := "E2_VENCTO"
		Case MV_PAR01 == 3 //Vencimento real
			cQuery += " AND SE2.E2_VENCREA >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_VENCREA <= '" + Iif(dDtFin < MV_PAR03,Dtos(dDtFin), Dtos(MV_PAR03)) + "' "
			cCampoD := "E2_VENCREA"
		Case MV_PAR01 == 4 //Data de Baixa
			cQuery += " AND ((SE2.E2_BAIXA >= '" + Dtos(dDtIni) + "' AND "
			cQuery += "   SE2.E2_BAIXA <= '" + Iif(dDtFin < MV_PAR03,Dtos(dDtFin), Dtos(MV_PAR03)) + "') OR "
			cQuery += "  (SE2.E2_BAIXA = ' ' AND "
			cQuery += "   SE2.E2_EMIS1 >= '" + Dtos(dDtIni) + "' AND "
			cQuery += "   SE2.E2_EMIS1 <= '" + Iif(dDtFin < MV_PAR03,Dtos(dDtFin), Dtos(MV_PAR03))	+ "') ) "
			cCampoD := "E2_BAIXA"

		Case MV_PAR01 == 5 // Data de emissao real
			cQuery += " AND SE2.E2_EMISSAO >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_EMISSAO <= '" + Iif(dDtFin < MV_PAR03,Dtos(dDtFin), Dtos(MV_PAR03)) + "' "
			cCampoD := "E2_EMISSAO"
	EndCase
Endif


//O valor do rendimento tributavel sera calculado por codigo de retencao, portanto todas as notas que
//não tiverem codigo de rentencao, não entrarao na somatoria do mês.
cQuery += " AND SE2.E2_CODRET = '" + cCodRet + "'"

// Se existir a data de processamento da DIRF, verifica se trata-se de reprocessamento
If !lReproc
	// filtra os titulos que nao foram processados
	cQuery += "AND SE2.E2_DTDIRF = ' '"
Endif
If MV_PAR10 == 2
	cQuery += " AND SE2.E2_TIPO NOT IN " + FormatIn(MVPAGANT,cSepRec)
EndIf

If lF401QRY2
		cQuery := ExecBlock("F401QRY2",.F.,.F.,{cQuery})
Endif

//cQuery := ChangeQuery(cQuery)

dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBIRF", .F., .T.)
If TRBIRF->(!Eof())
	For nX := 1 to Len(aStru)
		If aStru[nX,2] != 'C' .And. FieldPos(aStru[nX,1]) > 0 // Se existir o campo na Query
			TCSetField('TRBIRF', aStru[nX,1], aStru[nX,2],aStru[nX,3],aStru[nX,4])
		Endif
	Next
EndIf
dbSelectArea("TRBIRF")
While !(TRBIRF->(Eof()))

	dData   	:= DtoS(TRBIRF->&(cCampoD))
	If cCampoD == "E2_BAIXA" .and. Empty(dData)
		dData   	:= DtoS(TRBIRF->E2_EMIS1)
	EndIf
	dDataAnt := dData
	dDtPgt := stod(dData)

	// verifica se existe IR baixado, se existir, pula o titulo
	If ( MV_PAR01 == 4 .AND. MV_PAR05 == 2 ) .AND. VerIRBx( TRBIRF->( E2_PREFIXO ) , TRBIRF->( E2_NUM ) , TRBIRF->( E2_PARCIR ) , TRBIRF->( E2_PARCINS ) , dDtFin ).AND. !Empty(TRBIRF->( E2_PARCIR )) .AND. SA2->A2_TIPO=="J"
		TRBIRF->(dbSkip())
		Loop
	EndIf

	IF AScan( aLog, {	|x| x[1] + x[2] + x[3] + x[4] + x[5] + x[6] + x[7] + x[8] + x[9] + x[10] + x[12] + DTOS(dDtIni) == ;
													cCGCCPF + 	cCodRet + cMes + "A" +;
													TRBIRF->E2_FILIAL + TRBIRF->(E2_PREFIXO) + TRBIRF->(E2_NUM) + TRBIRF->(E2_PARCELA) + TRBIRF->(E2_TIPO) + TRBIRF->(E2_NATUREZ) + cNIFEX + DTOS(TRBIRF->&(cCampoD)) }) <>0
		TRBIRF->(dbSkip())
		Loop
	EndIf

	If Alltrim(TRBIRF->(E2_NATUREZ)) $ alltrim(cMVPISNAT) .Or. Alltrim(TRBIRF->(E2_NATUREZ) ) $ Alltrim(cMVCOFNAT) .Or. Alltrim(TRBIRF->(E2_NATUREZ) ) $ alltrim(cMVCSLNAT)

		TRBIRF->(dbSkip())
		Loop
	EndIf

	If F401PDesd(TRBIRF->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
		TRBIRF->(dbSkip())
		Loop
	EndIf

	nSomaBxPA := 0
	If MV_PAR10 == 1 // considera PA
		// se for NF e imposto eh na baixa , somente considerar o PA caso nf foi compensada.

		If (!lIRPFBaixa .or. SA2->A2_TIPO != 'J' .OR. !lRetemPCC) .and. TRBIRF->E2_TIPO $ MVPAGANT
			TRBIRF->(dbSkip())
			Loop
		EndIf

		If lIRPFBaixa .and. !TRBIRF->E2_TIPO $ MVPAGANT

			//verifica se NF foi compensada
			nSomaBxPA := RetValCMP("TRBIRF",.F.,lIRPFBaixa,lCalcIssBx,@nImpEmis)

			//Se Imposto é na baixa e houve compensacao da NF, desconsiderar a NF, pois será enviado a PA
			If nSomaBxPA > 0
				If nSomaBxPA == TRBIRF->E2_VALOR + Iif(lIRPFBaixa,0, TRBIRF->E2_IRRF) + Iif(__lPccbaixa,0,TRBIRF->(E2_PIS+E2_COFINS+E2_CSLL)) +  TRBIRF->E2_INSS + If(lCalcIssBx,0,TRBIRF->E2_ISS)
					TRBIRF->(dbSkip())
					Loop
				EndIf
			EndIf

		ElseIf TRBIRF->E2_TIPO $ MVPAGANT

			// verifica se PA nao está baixada, o que significa o seu cancelamento
			nSomaBxPA := RetValCMP("TRBIRF",!lIRPFBaixa ,lIRPFBaixa,lCalcIssBx,@nImpEmis)

			If nSomaBxPA > 0
				If nSomaBxPA == TRBIRF->E2_VALOR + If(__lPaBruto,0,TRBIRF->(E2_IRRF + E2_PIS + E2_COFINS + E2_CSLL) + Iif(__lPrImPA, TRBIRF->(E2_ISS + E2_PRISS + E2_INSS + E2_PRINSS),0 ))
					//PA foi baixada, devolucao da PA desconsiderar PA
					TRBIRF->(dbSkip())
					Loop
				EndIf

			EndIf
		EndIf

	EndIf

	If lFina992
		nTMSVDEP := F992RetVal(cMes, cAno)
		nDedDep :=  nTMSVDEP* SA2->A2_NUMDEP
	Else
		nDedDep :=  nTMSVDEP* SA2->A2_NUMDEP
	EndIf
	If lTpEnt
		If Empty(TRBIRF->A2_TPENT)
			cTpRen := "A"
		Else
			If TRBIRF->A2_TPENT == "1"	 // Fornecedores Imunes
				cTpRen := "I2"
			ElseIf TRBIRF->A2_TPENT == "2"  // Fornecedores Isentos
				cTpRen := "I3"
			EndIf
		EndIf
	Else
		cTpRen := "A"
	EndIf
	If TRBIRF->ED_BASEIRC > 0
		nBaseIr := (TRBIRF->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) + If(!lCalcIssBx,E2_ISS,0) + E2_SEST +;
			E2_INSS + if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL)) * TRBIRF->( ED_BASEIRC / 100 )) 

		nBaseIr := nBaseIr - nSomaBxPA
		If !lNovoCalc
			nBaseIr := Round((nBaseIr * nPercIR)/100,2)
		Endif	

		Fa401AddLog( @aLog, lGerLog, cCGCCPF, cCodRet, cMes, cTpRen, TRBIRF->E2_FILIAL, TRBIRF->E2_PREFIXO, TRBIRF->E2_NUM, TRBIRF->E2_PARCELA, TRBIRF->E2_TIPO, ;
				TRBIRF->E2_NATUREZ, nBaseIr, cNIFEX,SA2->A2_COD, SA2->A2_LOJA  , SA2->A2_FILIAL , SA2->A2_NOME )

		nValNTrib := TRBIRF->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) +;
				E2_INSS + If(!lCalcIssBx,E2_ISS,0) + E2_SEST + if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL)) - nBaseIr

		// Gera log para rendimentos nao tributaveis
		Fa401AddLog(	@aLog, lGerLog, cCGCCPF, cCodRet, cMes, "I", TRBIRF->E2_FILIAL, TRBIRF->E2_PREFIXO, TRBIRF->E2_NUM, TRBIRF->E2_PARCELA, TRBIRF->E2_TIPO,;
						TRBIRF->E2_NATUREZ, nValNTrib,cNIFEX,SA2->A2_COD, SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
	Else
		nPercReduz := Posicione("SED",1,xfilial("SED") + TRBIRF->E2_NATUREZ,"ED_BASEIRF")
		If nPercReduz > 0
			nBaseIr := (TRBIRF->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) + If(!lCalcIssBx,E2_ISS,0) + E2_SEST +;
				E2_INSS + if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL)) * nPercReduz / 100 )

			nBaseIr := nBaseIr - nSomaBxPA
			If !lNovoCalc
				nBaseIr := Round((nBaseIr * nPercIR)/100,2)
			Endif	

			nValNTrib := TRBIRF->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) +;
				E2_INSS + If(!lCalcIssBx,E2_ISS,0) + E2_SEST + if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL)) - nBaseIr

			// Gera log para rendimentos nao tributaveis
			Fa401AddLog(	@aLog, lGerLog, cCGCCPF, cCodRet, cMes, "I", TRBIRF->E2_FILIAL, TRBIRF->E2_PREFIXO, TRBIRF->E2_NUM, TRBIRF->E2_PARCELA, TRBIRF->E2_TIPO,;
						TRBIRF->E2_NATUREZ, nValNTrib,cNIFEX,SA2->A2_COD, SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
		Else
			If !Empty(TRBIRF->E2_BAIXA) .and. lIrBx
				aAreaTRB   := GetArea()
				dbSelectArea("SE5")
				aBaixas := GetPosts( xFilial("SE5",TRBIRF->E2_FILIAL),TRBIRF->E2_PREFIXO,;
									TRBIRF->E2_NUM,TRBIRF->E2_PARCELA,TRBIRF->E2_TIPO,;
									TRBIRF->E2_FORNECE,TRBIRF->E2_LOJA,"E5_TIPODOC IN ('VL','BA','CP')" )
									
				If SA2->A2_IRPROG == '1' .And. !Empty(SA2->A2_CPFIRP)
					nBaseIr := F401IrProg(cCGCCPF,aBaixas,lNovoCalc)
				else
					If TRBIRF->E2_SALDO > 0 .or. Len(aBaixas) == 1
						SE5->(dbGoTo(aBaixas[Len(aBaixas)]))
						nBaseIr := FGetImpRet(SE5->E5_IDORIG,"FK4_BASIMP",{ {"FK4_FILIAL",SE5->E5_FILIAL}, {"FK4_CGC",cCGCCPF}, {"FK4_IMPOS","IRF"} })
						if !lFK4OK .and. Empty(nBaseIR)
							nBaseIr := SE5->E5_BASEIRF
						endIf
					Else
						nBaseIr := 0
						For nX := 1 to Len(aBaixas)
							SE5->(dbGoTo(aBaixas[nX]))
							If !AllTrim(SE5->E5_MOTBX) $ "PCC|ISS"
								nBaseIr += FGetImpRet(SE5->E5_IDORIG,"FK4_BASIMP",{ {"FK4_FILIAL",SE5->E5_FILIAL}, {"FK4_CGC",cCGCCPF}, {"FK4_IMPOS","IRF"} })
								if !lFK4OK .and. Empty(nBaseIR)
									nBaseIr += SE5->E5_BASEIRF
								endIf
							Endif
						Next nX		
					EndIf
				endIf
				RestArea(aAreaTRB)	
			Else
				If 	TRBIRF->E2_BASEIRF > 0
					
					nBaseIr := TRBIRF->E2_BASEIRF

					If lINSIRF .And. MV_PAR04 == 1
						//Conforme legislacao, para PF o rendimento tributavel deve ser o valor bruto e nao o valor reduzido
						If nBaseIr + TRBIRF->E2_INSS > TRBIRF->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) + E2_INSS + If(lCalcIssBx,0,E2_ISS)+ E2_SEST +if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL))
							//se a soma da base do ir + o valor do inss for maior que o valor do titulo, mando o valor do titulo
							nBaseIr := TRBIRF->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) + E2_INSS + If(lCalcIssBx,0,E2_ISS)+ E2_SEST +if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL))
						Else
							nBaseIr += TRBIRF->E2_INSS
						EndIf
					EndIf
				Else
					If lIRPFBaixa .AND. TRBIRF->E2_SALDO > 0
						nBaseIr := TRBIRF->( E2_SALDO + E2_VRETIRF +;
						E2_INSS + If(lCalcIssBx,0,E2_ISS)+ E2_SEST +if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL))
					Else
						nBaseIr := TRBIRF->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) +;
						E2_INSS + If(lCalcIssBx,0,E2_ISS)+ E2_SEST +if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL))
					EndIf
				EndIf
				If TRBIRF->E2_MOEDA > 1 // Converte valores do titulo para Moeda 1
					nBaseIr := Round(NoRound(xMoeda(nBaseIr,TRBIRF->E2_MOEDA,1,TRBIRF->E2_EMISSAO,MsDecimais(1)+1,TRBIRF->E2_TXMOEDA),MsDecimais(1)+1),MsDecimais(1))
				EndIf
			EndIf
		EndIf

		nBaseIr := nBaseIr - nSomaBxPA

		If !lNovoCalc .or. (lNovoCalc .and. Empty(TRBIRF->E2_BAIXA)) 
			nBaseIr := Round((nBaseIr * nPercIR)/100,2)
		Endif

		If Empty(TRBIRF->E2_VRETIRF) .AND. TRBIRF->ED_CALCIRF="N"
			cMes:=STRZERO(MONTH(dDtini),2)
		Else
			cMes:=F401CMES(dDtIni,LastDay(dDtIni),cMes,cCodRet,lReproc, cFilAtu )
		EndIf
		If (MV_PAR01 == 2  .and. MV_PAR05 == 2) .OR. (MV_PAR01 == 4  .and. MV_PAR05 == 2)
			//Se possuir filial centralizadora, posiciona nesta filial
			If !Empty(MV_PAR06)
				cFilAnt := MV_PAR06
			Endif

			// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
			cChaveSr4 := xFilial("SR4")+SRL->RL_MAT+ Padr(cCGCCPF,Len(SR4->R4_CPFCGC)) +cCodRet+STRZERO(YEAR(dDtIni),4)+cMes

			If !SR4->( MsSeek( cChaveSr4 + padr(cTpRen,nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX  ))

				If nBaseir > 0
					Reclock("SR4", .T.)

					SR4->R4_FILIAL  := xFilial("SR4")
					SR4->R4_MAT     := SRL->RL_MAT
					SR4->R4_CPFCGC  := cCGCCPF
					SR4->R4_MES     := cMes
					SR4->R4_TIPOREN := cTpRen
					SR4->R4_CODRET  := cCodRet
					SR4->R4_ANO  := STRZERO(YEAR(dDtIni),4)
					SR4->R4_VALOR   := nBaseir
					SR4->R4_ORIGEM := "2"
					SR4->R4_NIFEX := SRL->RL_NIFEX

					If  !Empty(SRL->RL_PAIS)
						SR4->R4_PAIS := SRL->RL_PAIS
						
						SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
						If lISNIF
							SR4->R4_ISNIF :=  IIF(lTemNIF,"1","2")
						EndIf
					EndIf

					If lFa401Cmp
						// Utilizado para gravar campos complementares do SR4
						ExecBlock("FA401CMP", .F.,.F.)
					Endif

					SR4->(MsUnlock())
				EndIf
			Else
				If nBaseir > 0
					Reclock("SR4", .F.)
					SR4->R4_VALOR  += nBaseir
					SR4->(MsUnlock())
				EndIf
			EndIf
			//Restauro a filial do sistema quando processar com filial centralizadora
			If !Empty(MV_PAR06)
				cFilAnt := cFilAtu
			Endif
		EndIf
		If nBaseir > 0
			// Gera log para rendimentos tributaveis
			Fa401AddLog( @aLog, lGerLog, cCGCCPF, cCodRet, cMes, cTpRen, TRBIRF->E2_FILIAL, TRBIRF->E2_PREFIXO, TRBIRF->E2_NUM, TRBIRF->E2_PARCELA,;
						TRBIRF->E2_TIPO, TRBIRF->E2_NATUREZ, nBaseIr, cNIFEX,SA2->A2_COD, SA2->A2_LOJA  , SA2->A2_FILIAL , SA2->A2_NOME )
		EndIf
	Endif
	If nBaseIr > 0
		If !TMP1->(Dbseek( TRBIRF->RECNO ))
			Reclock("TMP1", .T.)
			TMP1->NROREG 		:= TRBIRF->RECNO
			TMP1->TITIPAI		:= (TRBIRF->RECNO == nRegPai)
			TMP1->(MSUNLOCK())
		Endif
	EndIf	


	nTotTit	+= nBaseIr
	nTotNaoTrib += nValNTrib
	nLenLog := Len( aLog )

	nTotInss += TRBIRF->E2_INSS
	nTotIrrf += TRBIRF->E2_IRRF

	If nBaseIr > 0
		cTitsSum += TRBIRF->( E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA ) + cCodRet + "|"
	EndIf	

	TRBIRF->(dbSkip())

	dData   	:= DtoS(TRBIRF->&(cCampoD))
	If cCampoD == "E2_BAIXA" .and. Empty(dData)
		dData   	:= DtoS(TRBIRF->E2_EMIS1)
	EndIf

	If TRBIRF->(Eof()) .or. dDataAnt <> dData
		aAdd(aRetBase, {dDataAnt, nTotTit,nTotNaoTrib})
		nTotTit := 0
		nTotNaoTrib := 0
	EndIf

Enddo

TRBIRF->(dbCloseArea())

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³SELECIONA OS DADOS TODOS OS DADOS DE SE2 COM BAIXA                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( MV_PAR01 = 4 .AND. MV_PAR05 = 2 )  //SE ESTÁ SENDO PROCESSADO PELA BAIXA DO TÍTULO DE IMPOSTO

	// QUERY PRINCIPAL DE BUSCA DOS TITULOS
	cQuery := c401QryIr2
	If lPesJur
		cQuery += " AND SE2.E2_FILIAL = '" + xFilial("SE2") + "'"
		cQuery += " AND SA2.A2_FILIAL = '" + xFilial( "SA2" ) + "'"
	Endif

	// Para Pessoa fisica totaliza os titulos baixados no mes
	If SA2->A2_TIPO == "F" .or. (SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG == '1')
		cQuery += " AND SE2.E2_BAIXA BETWEEN '" + Dtos(FirstDay(dDtIni)) + "' AND '" + Dtos(LastDay(dDtFin))+ "'"
	Else
		// Para Pessoa juridica totaliza os titulos baixados no dia
		cQuery += " AND SE2.E2_BAIXA BETWEEN '" + Dtos(dDtIni) + "' AND '" + Dtos(MV_PAR03)+ "'"
	Endif
	If !lReproc
		// Senao filtra os titulos que nao foram processados
		cQuery += " AND SE2.E2_DTDIRF = ' '"
	Endif

	//O valor do rendimento tributavel sera calculado por codigo de retencao, portanto todas as notas que
	//não tiverem codigo de rentencao, não entrarao na somatoria do mês.
	cQuery += " AND SE2.E2_CODRET = '" + cCodRet + "'"

	cQuery += " AND '" + SA2->A2_COD + "' = SA2.A2_COD "
	cQuery += " AND '" + SA2->A2_LOJA + "' =  SA2.A2_LOJA"

	cQuery := ChangeQuery( cQuery )

	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBIRF", .F., .T.)

	For nX := 1 to Len(aStru)
		If aStru[nX,2] != 'C' .And. FieldPos(aStru[nX,1]) > 0 // Se existir o campo na Query
			TCSetField('TRBIRF', aStru[nX,1], aStru[nX,2],aStru[nX,3],aStru[nX,4])
		Endif
	Next

	DbSelectArea("TRBIRF")
	While !(TRBIRF->(Eof()))

		dData   	:= DtoS(TRBIRF->E2_BAIXA)
		dDataAnt := dData
		dDtPgt := stod(dData)

		SE2->(DbSetOrder(1))
		SE2->(DbSeek(xFilial("SE2")+TRBIRF->(E2_PREFIXO+E2_NUM)))
		While SE2->E2_PARCIR <> TRBIRF->E2_PARCELA .AND.;
				SE2->(E2_PREFIXO+E2_NUM) == TRBIRF->(E2_PREFIXO+E2_NUM)
			SE2->(DbSkip())
		EndDo
		SED->(DbSetOrder(1))
		SED->(DbSeek(xFilial("SED")+SE2->(E2_NATUREZ)))
		cMes:=STRZERO(MONTH(dDtini),2)
			IF AScan( aLog, {	|x| x[1] + x[2] + x[3] + x[4] + x[5] + x[6] + x[7] + x[8] + x[9] + x[10] + x[12]== ;
												cCGCCPF + 	cCodRet + cMes + "A" +;
												xFilial("SE2") + SE2->(E2_PREFIXO) + SE2->(E2_NUM) + SE2->(E2_PARCELA) + SE2->(E2_TIPO) + SE2->(E2_NATUREZ) + cNIFEX  }) <>0
			TRBIRF->(dbSkip())
			Loop
		EndIf

		If SED->ED_BASEIRC > 0 // Se houver base de reducao de carreteiro
			nBaseIr := SE2->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) +;
					E2_INSS + If(!lCalcIssBx,E2_ISS,0) + E2_SEST+ if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL)) * SED->( ED_BASEIRC / 100 )
				If lINSIRF .And. MV_PAR04 == 1
					nBaseIr :=nBaseIr -SE2->E2_INSS
				EndIf
			Fa401AddLog(  @aLog, lGerLog, cCGCCPF, cCodRet, cMes, "A", SE2->E2_FILIAL, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO,;
							SE2->E2_NATUREZ, nBaseIr, cNIFEX,SA2->A2_COD, SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME  )

			nNaoTributavel := SE2->( E2_VALOR + If(lIRPFBaixa,0,E2_IRRF) +;
				E2_INSS + If(!lCalcIssBx,E2_ISS,0) + E2_SEST+ if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL)) - nBaseIr
			// Gera log para rendimentos nao tributaveis
			Fa401AddLog(	@aLog, lGerLog, cCGCCPF, cCodRet, cMes, "I", SE2->E2_FILIAL, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO,;
							SE2->E2_NATUREZ, nNaoTributavel, cNIFEX,SA2->A2_COD, SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME  )
		Else
			If lIRPFBaixa .AND. SE2->E2_SALDO > 0
				nBaseIr := SE2->( E2_SALDO + E2_VRETIRF +;
					E2_INSS + If(lCalcIssBx,0,E2_ISS)+ E2_SEST +if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL))
			Else
				nBaseIr := SE2->(E2_VALOR + If(lIRPFBaixa,0,E2_IRRF)+;
					E2_INSS+If(!lCalcIssBx,E2_ISS,0)+E2_SEST+ if(__lPCCBaixa,0,E2_VRETPIS+E2_VRETCOF+E2_VRETCSLL))
			Endif
			// Gera log para rendimentos tributaveis
			Fa401AddLog(	@aLog, lGerLog, cCGCCPF, cCodRet, cMes, "A", SE2->E2_FILIAL, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA,;
							SE2->E2_TIPO, SE2->E2_NATUREZ, nBaseIr, cNIFEX,SA2->A2_COD, SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME  )
		EndIf
		If MV_PAR01 == 4  .and. MV_PAR05 == 2 .and. SA2->A2_TIPO=="J"
			//Se possuir filial centralizadora, posiciona nesta filial
			If !Empty(MV_PAR06)
				cFilAnt := MV_PAR06
			Endif

			If lTpEnt
				If Empty(TRBIRF->A2_TPENT)
					cTpRen := "A"
				Else
					If TRBIRF->A2_TPENT == "1"	 // Fornecedores Imunes
						cTpRen := "I2"
					ElseIf TRBIRF->A2_TPENT == "2"  // Fornecedores Isentos
						cTpRen := "I3"
					EndIf
				EndIf
			Else
				cTpRen := "A"
			EndIf

			// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
			cChaveSr4 := xFilial("SR4")+SRL->RL_MAT+ Padr(cCGCCPF,Len(SR4->R4_CPFCGC)) +cCodRet+STRZERO(YEAR(dDtIni),4)+cMes
			If !SR4->( MsSeek( cChaveSr4 + padr(cTpRen,nTamTpRen) + SRL->RL_PAIS + SRL->RL_NIFEX ))
				If nBaseir > 0
					Reclock("SR4", .T.)

					SR4->R4_FILIAL  := xFilial("SR4")
					SR4->R4_MAT     := SRL->RL_MAT
					SR4->R4_CPFCGC  := cCGCCPF
					SR4->R4_MES     := cMes
					SR4->R4_TIPOREN := cTpRen
					SR4->R4_CODRET  := cCodRet
					SR4->R4_ANO  := STRZERO(YEAR(dDtIni),4)
					SR4->R4_VALOR   := nBaseir
					SR4->R4_ORIGEM := "2"
					SR4->R4_NIFEX := SRL->RL_NIFEX

					If !Empty(SRL->RL_PAIS)
						SR4->R4_PAIS := SRL->RL_PAIS
						
						SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
						If lISNIF
							SR4->R4_ISNIF :=  IIF(lTemNIF,"1","2")
						EndIf
					EndIf

					If lFa401Cmp
						// Utilizado para gravar campos complementares do SR4
						ExecBlock("FA401CMP", .F.,.F.)
					Endif

					SR4->(MsUnlock())
				EndIf

			Else
				If nBaseir > 0
					Reclock("SR4", .F.)
					SR4->R4_VALOR  += nBaseir
					SR4->(MsUnlock())
				EndIf
			EndIf
			//Restauro a filial do sistema quando processar com filial centralizadora
			If !Empty(MV_PAR06)
				cFilAnt := cFilAtu
			Endif
		Endif

		nTotTit	+= nBaseIr
		nTotNaoTrib += nNaoTributavel
		nLenLog := Len( aLog )

		nTotInss += SE2->(E2_INSS)
		nTotIrrf += SE2->(E2_IRRF)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Somente gera log com abatimento do INSS da base de calculo   ³
		//³ se for fornecedor do tipo pessoa fisica.                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea("SED")
		SED->(DbSetOrder(1))
		SED->(DbSeek(xFilial("SED")+ NEWSE2->E2_NATUREZ))

		If lAbatINSS .And. SED->ED_BASEIRC == 0
			Fa401EdtLog( @aLog, lGerLog, nLenLog, LOG_VALOR, SE2->E2_INSS, "-" )
		EndIf

		If nBaseIr > 0
			cTitsSum += SE2->( E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA ) + cCodRet + "|"
		EndIf
		
		TRBIRF->(dbSkip())

		dData   	:= DtoS(TRBIRF->&(cCampoD))
		If cCampoD == "E2_BAIXA" .and. Empty(dData)
			dData   	:= DtoS(TRBIRF->E2_EMIS1)
		EndIf

		If TRBIRF->(Eof()) .or. dDataAnt <> dData
			aAdd(aRetBase, {dDataAnt, nTotTit,nTotNaoTrib})
			nTotTit := 0
			nTotNaoTrib := 0
		EndIf		

	Enddo

	TRBIRF->(dbCloseArea())
EndIf

nBaseIr := nTotTit

dbSelectArea("SE2")

//Restauro a filial do sistema quando processar com filial centralizadora
If !Empty(MV_PAR06)
	cFilAnt := MV_PAR06
Endif

RestArea(aArea)
SR4->(RestArea(aAreaSR4))
Return aClone(aRetBase)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MsSomaMes ºAutor  ³Microsiga           º Data ³  16/05/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Soma meses em determinada data                              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Generico                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function MsSomaMes( dGivenDate, nAddMonths, lMakeEOM)
// Baseada em FT_MADD da Nanfor
  LOCAL nAdjDay, dTemp, i

  IF(VALTYPE(dGivenDate) != 'D', dGivenDate := DATE(), )
  IF(VALTYPE(nAddMonths) != 'N', nAddMonths := 0, )
  IF(VALTYPE(lMakeEOM)   != 'L', lMakeEom := .F., )

  nAdjDay := DAY( dGivenDate ) - 1

  dTemp := dGivenDate - nAdjDay     // first of month

  /* Trabalha sempre com o primeiro dia dos meses.*/
  For i := 1 To Abs(nAddMonths)
      dTemp += If( nAddMonths > 0, 31, -1 )
      dTemp += 1 - DAY( dTemp )
  Next

  If lMakeEom
     dTemp += 31 - DAY( dTemp + 31 )
  Else
     dTemp := MIN( (dTemp + nAdjday), (dTemp += 31 - DAY( dTemp + 31 )))
  Endif

Return dTemp

/*
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³ f401TotPLS ³ Autor ³ Sandro Hoffman Lopes  ³ Data ³ 10.03.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Totaliza os valores pagos por fornecedor no mes - PLS        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ f401TotPLS(cAliasPai, cAliasTrb)	 				                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cAliasPai: Alias do Titulo Principal                         ³±±
±±³          ³ cAliasTrb: Alias do Titulo de Imposto                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function f401TotPLS(cAliasPai, cAliasTrb)

Local aArea := GetArea()
Local nRendTributavel := 0
Local aCodLan
Local nI

If Alltrim((cAliasTrb)->E2_NATUREZ) $ cMVIRNAT .or. Alltrim((cAliasTrb)->E2_NATUREZ) $ cMVINSNAT
	If lINSIRF .And. MV_PAR04 == 1
	    aCodLan := {"198","195","193","197","1A1"}
	Else
	    aCodLan := {"198"}
	EndIf
Else // PIS, COFINS e CSLL
	If (cAliasTrb)->(E2_CODRET) == "5979" // PIS
		aCodLan := { "186" }
	ElseIf (cAliasTrb)->(E2_CODRET) == "5960" // COFINS
		aCodLan := { "188" }
	ElseIf (cAliasTrb)->(E2_CODRET) == "5987" // CSL
		aCodLan := { "190" }
	Else // 5952 --> PIS + COFINS + CSLL
		aCodLan := { "186" }
	EndIf
EndIf

// Indice 1: BMR_FILIAL+BMR_OPERDA+BMR_CODRDA+BMR_OPELOT+BMR_ANOLOT+BMR_MESLOT+BMR_NUMLOT+BMR_CODLAN
BMR->(DbSetOrder(1))
For nI := 1 To Len(aCodLan)
 	If BMR->(MsSeek(xFilial("BMR")+(cAliasPai)->(E2_PLOPELT+E2_CODRDA+E2_PLOPELT+E2_PLLOTE)+aCodLan[nI]))
		nRendTributavel += BMR->BMR_VLRPAG
	EndIf
Next nI

RestArea(aArea)

Return nRendTributavel

/*
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³Fa401SemImp ³ Autor ³ Claudio D. de Souza   ³ Data ³ 24.04.07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Totaliza titulos sem impostos cujo valor seja maior que 6000 ³±±
±±³e gera titulos que possuem fatura com retencao de IRRF ou PCC na baixa  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Fa401SemImp()										                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa401SemImp(aRecno,lReproc,cFilAtu,aLog,lGerLog,aTitPai,TMP1)
Local cQuery 	 := ""
Local cAbatim 	 := MV_CRNEG+"|"+MV_CPNEG+"|"+MVIRABT+"|"+MVCSABT+"|"+MVCFABT+"|"+MVPIABT+"|"+MVABATIM
Local cImpostos := MVISS+"|"+MVTAXA+"|"+MVTXA+"|"+MVINSS+"|"+"SES"+ "|" + "INA"
Local cNotIn	 := ""
Local cAliasTrb := GetNextAlias()
Local cTipoFj

Local nX, nY
Local bWhile 	 	 := { || .T. }
Local bFor   	 	 := { || .T. }
Local cFornUniao 	 := GetMv("MV_UNIAO")
Local aRendimentos := {}
Local nRendAnual	 := 0
Local cChaveAnt	 := ""
Local nAscan
Local lQuery 	:= .F.
Local cCondicao := ""
Local cCampo
Local cCampoP
Local nPosLog	:= 0
Local aDadosLog	:= {}

Local nIRRet
Local nValor	:= 0
Local lCalcIssBx :=	SA2->A2_TIPO == "J" .And. GetNewPar("MV_MRETISS","1") == "2" //Retencao do ISS pela emissao (1) ou baixa (2)
Local lIrBx		:=	.F.
Local cCodRet		:= ' '
Local cRaMat		:=	''
Local lEnvia		:=	.T.
Local nOrdSe2		:= SE2->(IndexOrd())
Local aAreaSe2 	:= SE2->(GetArea())
Local lFatBx		:=	.F.
Local cData		:= ""
Local lTemNIF := .F.
Local cNIFEX := ""
Local nTamNIF := TamSx3("RL_NIFEX")[1]
Local nSomaBxPA := 0
Local lInssPA := .F.
Local lRetemPCC  := .F.
Local cTpRen	 := ""

If FindFunction( 'IsIssBx' )
	lCalcIssBx :=	IsIssBx( "P" )
EndIf


// Se possuir filial centralizadora, posiciona nesta filial
If !Empty(MV_PAR06)
	cFilAnt := cFilAtu
Endif

Do Case //Titulos de outros impostos
	Case MV_PAR01 == 1 // Data de emissao digitada
		cData  := "E2_EMIS1"
	Case MV_PAR01 == 2// Vencimento
		cData  := "E2_VENCTO"
	Case MV_PAR01 == 3 //Vencimento real
		cData  := "E2_VENCREA"
	Case MV_PAR01 == 4 //Data de Baixa
		cData := "E2_BAIXA"
	Case MV_PAR01 == 5 // Data de emissao real
		cData  := "E2_EMISSAO"
EndCase
//campo data de titulos de pcc
Do Case
	Case MV_PAR09 == 1 // Data de emissao
		cCampoP  := "E2_EMIS1"
	Case MV_PAR09 == 2// Vencimento
		cCampoP  := "E2_VENCTO"
	Case MV_PAR09 == 3 //Vencimento real
		cCampoP  := "E2_VENCREA"
	Case MV_PAR09 == 4 //Data de Baixa
		cCampoP := "E2_BAIXA"
	Case MV_PAR09 == 5 //Data de Emissao
		cCampoP := "E2_EMISSAO"

EndCase
Fa401SqlSImp(@cNotIn,@lQuery,@cAbatim,@cImpostos,@cQuery,@lReproc,@cFornUniao,@cAliasTrb,@nX,@cCondicao,@bWhile,@bFor,@cCampo)

While (cAliasTrb)->(!Eof()) .And. Eval(bWhile)

	If TMP1->(Dbseek((cAliasTrb)->R_E_C_N_O_))
		(cAliasTrb)->(Dbskip())
		Loop
	Endif

	//Caso titulo seja retido em outro que já foi gravado para a DIRF durante esta execução não deve duplicar.
	SFQ->(DbSetOrder(2)) //FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
	If SFQ->(DbSeek(xFilial("SFQ")+ Iif(__lPCCBaixa,"SE5","SE2") + (cAliasTrb)->E2_PREFIXO + (cAliasTrb)->E2_NUM + (cAliasTrb)->E2_PARCELA + (cAliasTrb)->E2_TIPO +;
							 (cAliasTrb)->E2_FORNECE + (cAliasTrb)->E2_LOJA ))
		aAreaSe2 := SE2->(GetArea())
		SE2->(DbSetOrder(1))
		If SE2->(Dbseek(xFilial("SE2")+ SFQ->FQ_PREFORI + SFQ->FQ_NUMORI + SFQ->FQ_PARCORI + SFQ->FQ_TIPOORI + SFQ->FQ_CFORI + SFQ->FQ_LOJAORI))
			If (SE2->&(cData) <= MV_PAR03 .And. SE2->&(cData) >= MV_PAR02)
				(cAliasTrb)->(Dbskip())
				Loop
			Endif
		Endif
		SE2->(RestArea(aAreaSe2))
	Endif

	If Eval(bFor) .And. !Fa401PaiProc( aTitPai , (cAliasTrb)->(E2_CODRET+E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) )

		SA2->(MsGoto((cAliasTrb)->RECNOSA2))
		SED->(DBSeek(xFilial("SED") + (cAliasTrb)->(E2_NATUREZ)))
		lIrBx:=	SA2->A2_CALCIRF == "2" .And. SED->ED_CALCIRF = "S"
		lRetemPCC := __lPccbaixa .and. ( SA2->A2_RECPIS == "2" .OR. SA2->A2_RECCOFI == "2" .OR. SA2->A2_RECCSLL == "2")

		lInssPa:= SED->ED_RINSSPA = "1"

		nSomaBxPA := 0
		//tratamento para PA
		//MV_PAR10 = Nao - Mantem legado, nao envia pa somente titulos principais
		//MV_PAR10 = Sim - Toda PA sera enviada, e será tratado a NF que foi compensada, nao deve ir
		If MV_PAR10 == 1 //sim -considera pagamento antecipado

			If (!lIrBx .or. SA2->A2_TIPO != 'J' .OR. !lRetemPCC) .and. (cAliasTrb)->E2_TIPO $ MVPAGANT
				(cAliasTrb)->(Dbskip())
				Loop
			EndIf


			If (lIrBx .and. lRetemPCC ) .and. !(cAliasTrb)->E2_TIPO $ MVPAGANT

				//verifica se NF foi compensada
				nSomaBxPA := RetValCMP(cAliasTrb,.F.,lIrBx,lCalcIssBx,)

				//Se Imposto é na baixa e houve compensacao da NF, desconsiderar a NF, pois será enviado a PA
				If nSomaBxPA > 0
					If nSomaBxPA == (cAliasTrb)->E2_VALOR + Iif(lIrBx,0, (cAliasTrb)->E2_IRRF) + Iif(__lPccbaixa,0,(cAliasTrb)->(E2_PIS+E2_COFINS+E2_CSLL)) +  (cAliasTrb)->E2_INSS + If(lCalcIssBx,0,(cAliasTrb)->E2_ISS)
						(cAliasTrb)->(Dbskip())
						Loop
					EndIf
				EndIf

			ElseIf (cAliasTrb)->E2_TIPO $ MVPAGANT

				// verifica se PA nao está baixada, o que significa o seu cancelamento
				nSomaBxPA := RetValCMP(cAliasTrb, (!lIrBx .or. !__lPccbaixa),lIrBx,lCalcIssBx,)

				If nSomaBxPA > 0
					If nSomaBxPA == (cAliasTrb)->E2_VALOR + If(__lPaBruto, IIf(lInssPa,  (cAliasTrb)->(E2_INSS), 0 ),(cAliasTrb)->(E2_IRRF + E2_PIS + E2_COFINS + E2_CSLL) + Iif(__lPrImPA, (cAliasTrb)->(E2_ISS + E2_PRISS + E2_INSS + E2_PRINSS),0 ))
						//PA foi baixada, devolucao da PA desconsiderar PA
						(cAliasTrb)->(Dbskip())
						Loop
					EndIf
				EndIf
			EndIf

		EndIf

		lTemNIF := .F.
		cNIFEX := Space(nTamNIF)
		//Verifico o tipo da pessoa do Fornecedor (Fisico ou Juridico.
		//Em branco ou X - Outros, serao verificados pelo CGC
		If Empty(SA2->A2_TIPO) .or. !(SA2->A2_TIPO $ "F/J")
			If SA2->A2_TIPO == "X"
				cTipoFj := "2"
			ElseIf SA2->A2_IRPROG == '2'
				cTipoFj := "1"
			Else
				cTipoFj := Iif(Len(AllTrim(SA2->A2_CGC	)) > 11,"2","1")
			EndIf
		Else
			cTipoFj := IIf( SA2->A2_TIPO = "F" , "1" , If(SA2->A2_TIPO == 'J' .AND. SA2->A2_IRPROG == '1',"1","2") )
		Endif

		// Se for um fornecedor definido no parametro
		If Val(cTipoFj) == MV_PAR04

			// Se possuir filial centralizadora, posiciona nesta filial
			If !Empty(MV_PAR06)
				cFilAnt := MV_PAR06
			Endif

			If MV_PAR01 == 4
				/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Se for pela data da baixa, verifico qual data a ser considerada³
				//³Se titulo baixado, considero data da baixa                     ³
				//³Se titulo não baixado, considero data da emissao			            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				//Data da Baixa
				If Empty((cAliasTrb)->E2_BAIXA)
					cCampo := "E2_EMIS1"
				Else
					cCampo := "E2_BAIXA"
				Endif
			Endif

			//tratamento para fornecedor exterior sem NIF
			If !Empty(SA2->A2_PAISEX) 
				If IsCodResExt((cAliasTrb)->E2_CODRET) .or. (SA2->A2_TIPO $ "J|X" .and. (Empty(SA2->A2_CGC) .or. SA2->A2_CGC =="00000000000000"))
					If Empty(SA2->A2_NIFEX)
						cNIFEX := SA2->A2_COD +  SA2->A2_LOJA
						lTemNIF := .F.
					Else
						cNIFEX := SA2->A2_NIFEX
						lTemNIF := .T.
					EndIf
				EndIf					
			EndIf


			// Gera novo numero de matricula, caso ainda nao exista no cabecalho (SRL)
			If !SRL->(MsSeek(xFilial("SRL")+Padr(SM0->M0_CGC,Len(SRL->RL_CGCFONT))+;
			 (cAliasTrb)->E2_CODRET +cTipoFj+If(SA2->A2_TIPO == "J"  .and. SA2->A2_IRPROG = '1',Padr(SA2->A2_CPFIRP,14),Padr(SA2->A2_CGC,Len(SRL->RL_CPFCGC))) + cNIFEX ))

				If (nAscan:=Ascan(aRendimentos, {|e| e[5]+e[2]+e[3]+e[13]== (cAliasTrb)->E2_CODRET+cTipoFj+If(SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG = '1',SA2->A2_CPFIRP,SA2->A2_CGC)+ cNIFEX  })) == 0
					cRaMat := GetSxENum("SRL", "RL_MAT")
					cRaMat := If(Val(SRA->RA_MAT) < 900000 .And. Val(cRaMat) < 900000, "900000",cRaMat)
					ConfirmSx8()
				Else
					cRaMat := aRendimentos[nAscan,12]
				Endif
			Else
				cRaMat := SRL->RL_MAT
			Endif
			// Se existir o ano na chave do SR4
	  		// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
	  		cChaveSr4 := xFilial("SR4")+cRaMat+If(SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG = '1',Padr(SA2->A2_CPFIRP,Len(SR4->R4_CPFCGC)),SA2->A2_CGC)+(cAliasTrb)->E2_CODRET+STRZERO(YEAR((cAliasTrb)->&(cCampo)),4)+STRZERO(MONTH((cAliasTrb)->&(cCampo)),2)

			//Restauro a filial do sistema quando processar com filial centralizadora
			If !Empty(MV_PAR06)
				cFilAnt := cFilAtu
			Endif

			lEnvia		:=	.T.
			cCodRet	:= (cAliasTrb)->E2_CODRET
			lFatBx		:=	.F.
			//Titulo que possua fatura que retenha IRRF ou PCC na baixa.
			//se fatura estiver baixada e tiver imposto na baixa, envia a fatura, caso contrario envia a nf
			If ((lIrBx .And. (cAliasTrb)->E2_IRRF > 0) .Or.;
				 (__lPCCBaixa .And. ((cAliasTrb)->E2_COFINS+(cAliasTrb)->E2_PIS+(cAliasTrb)->E2_CSLL) > 0)) .And.;
					!Empty((cAliasTrb)->E2_FATURA)
				If Alltrim((cAliasTrb)->E2_FATURA) != "NOTFAT"
					nOrdSe2	:= SE2->(IndexOrd())
					aAreaSe2 	:= SE2->(GetArea())

					//Procurar a fatura deste titulo.
					SE2->(Dbsetorder(6)) //FILIAL+FORNECE+LOJA+PREFIXO+NUM//+PARCELA+TIPO
					If SE2->(Dbseek( xFilial("SE2") + (cAliasTrb)->E2_FATFOR + (cAliasTrb)->E2_FATLOJ + (cAliasTrb)->E2_FATPREF + (cAliasTrb)->E2_FATURA  ))
						While !SE2->(Eof()) .And.;
								SE2->E2_FILIAL = xFilial("SE2") .And. ;
								(SE2->E2_FORNECE + SE2->E2_LOJA + SE2->E2_PREFIXO + SE2->E2_NUM) = ((cAliasTrb)->E2_FATFOR + (cAliasTrb)->E2_FATLOJ + (cAliasTrb)->E2_FATPREF + (cAliasTrb)->E2_FATURA)

							If SE2->E2_TIPO = (cAliasTrb)->E2_TIPOFAT
								If !Empty(SE2->E2_BAIXA)
									lFatBx	:=	.T.
									lEnvia	:=	.F.
								Endif
							Endif
							SE2->(Dbskip())
						Enddo
					Endif

					SE2->(Dbsetorder(nOrdSe2))
					SE2->(RestArea(aAreaSe2))
				Else
					If Empty((cAliasTrb)->E2_BAIXA)
						//se o título for uma fatura e estiver em aberto, não enviar para DIRF, pois deverá enviar as NFs que a compoe
						lEnvia	:=	.F.
					EndIf
				EndIf

				If lEnvia
					SA2->(MsSeek(xFilial("SA2")+(cAliasTrb)->(E2_FORNECE+E2_LOJA)))

					nValor		:=	0

					//Gravar dados do IRRF
					If !Empty(cCodRet) .And. (cAliasTrb)->E2_IRRF > 0  .And. lIrBx
						nValor		:=	(cAliasTrb)->E2_IRRF
						If !Empty(cCodRet) .And. nValor > 0
							GravTitFat(cCodRet,nValor,cRaMat,cTipoFj,cAliasTrb,cCampo,aLog,lGerLog,@aRendimento,@aDadosLog,lFatBx)
						Endif
					Endif

					//Gravar dados do PCC
					If (cAliasTrb)->E2_PIS + (cAliasTrb)->E2_COFINS + (cAliasTrb)->E2_CSLL > 0 .And. __lPccBaixa
						cCodRet	:=	'5952'
						nValor		:=	(cAliasTrb)->E2_PIS + (cAliasTrb)->E2_COFINS + (cAliasTrb)->E2_CSLL
						If nValor > 0
							GravTitFat(cCodRet,nValor,cRaMat,cTipoFj,cAliasTrb,cCampoP,aLog,lGerLog,@aRendimento,@aDadosLog,lFatBx)
						Endif
					Endif
				Endif
			Else
				If lTpEnt
					If Empty((cAliasTrb)->A2_TPENT)
						cTpRen := "A"
					Else
						If (cAliasTrb)->A2_TPENT == "1"	 // Fornecedores Imunes
							cTpRen := "I2"
						ElseIf (cAliasTrb)->A2_TPENT == "2"  // Fornecedores Isentos
							cTpRen := "I3"
						EndIf
					EndIf
				Else
					cTpRen := "A"
				EndIf
				// Gera valor do Rendimento do IR
				If (nAscan:=Ascan(aRendimentos, {|e| e[1] == cChaveSr4+padr(cTpRen,nTamTpRen)+SRL->RL_PAIS + SRL->RL_NIFEX })) == 0
					//recompoe o valor bruto onde foi descontado o ISS na emissão e INSS, pois deve ser gerado pelo valor bruto
				 	nValor := (cAliasTrb)->E2_VALOR + IIf(!lCalcIssBx .and. (cAliasTrb)->E2_ISS > 0, (cAliasTrb)->E2_ISS,0) + (cAliasTrb)->E2_INSS

					Aadd(aRendimentos, {	cChaveSr4+padr(cTpRen,nTamTpRen)+ SRL->RL_PAIS + SRL->RL_NIFEX ,;
												cTipoFj,;
												If(SA2->A2_TIPO == "J".and. SA2->A2_IRPROG = '1',SA2->A2_CPFIRP,SA2->A2_CGC),;
												STRZERO(MONTH((cAliasTrb)->&(cCampo)),2),;
												(cAliasTrb)->E2_CODRET,;
												STRZERO(YEAR((cAliasTrb)->&(cCampo)),4),;
												nValor,;
												SA2->A2_NOME,;
												Alltrim(SA2->A2_END) + Alltrim(SA2->A2_NR_END),;
												SA2->A2_EST,;
												SA2->A2_BAIRRO,;
												cRaMat,;
												cNIFEX,;
												lTemNIF,;
												cTpRen } )
					nPosLog := Len(aRendimentos)
				Else

				 	nValor := (cAliasTrb)->E2_VALOR + IIf(!lCalcIssBx .and. (cAliasTrb)->E2_ISS > 0, (cAliasTrb)->E2_ISS,0) + (cAliasTrb)->E2_INSS

					aRendimentos[nAscan,7] += nValor
					nPosLog := nAscan
				Endif

				If lGerLog
					(cAliasTrb)->( AAdd( aDadosLog, {	aRendimentos[nPosLog,3], aRendimentos[nPosLog,5], aRendimentos[nPosLog,4], "A",;
														E2_FILIAL, E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, E2_NATUREZ, nValor, SRL->RL_NIFEX,SA2->A2_COD , SA2->A2_LOJA,;
														SA2->A2_FILIAL, SA2->A2_NOME  } ) )
				EndIf

			Endif

			Aadd(aRecno, (cAliasTrb)->R_E_C_N_O_)

		Endif

	Endif

	(cAliasTrb)->(DbSkip())

	// Se possuir filial centralizadora, posiciona nesta filial
	If !Empty(MV_PAR06)
		cFilAnt := cFilAtu
	Endif
Enddo

// Se possuir filial centralizadora, posiciona nesta filial
If !Empty(MV_PAR06)
	cFilAnt := MV_PAR06
Endif

nRendAnual	:= 0
cChaveAnt	:= ""
nLen        := Len(aRendimentos)

// Ordena por Fornecedor + Codigo de retencao
aSort(aRendimentos,,,{ |x,y| x[3]+x[13]+x[5] <  y[3]+y[13]+y[5] } )
aSort(aDadosLog,,,{ |x,y| x[1]+x[12]+x[2] < y[1]+y[12]+y[2] } )

//Se possuir filial centralizadora, posiciona nesta filial
If !Empty(MV_PAR06)
	cFilAnt := MV_PAR06
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ So grava para quem teve rendimento superior a 6.000 no ano,  ³
//³ conforme artigo 1o. da IN. SRF No. 511/2005.		         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX := 1 To nLen

	If Len(aRendimentos[nX]) > 14
		cTpRen := aRendimentos[nX,15]
	ElseIf Empty(cTpRen)
		cTpRen := "A"
	EndIf

	// Soma os rendimentos do ano do mesmo fornecedor
	If Empty(nRendAnual) .Or. cChaveAnt != aRendimentos[nX,3] + aRendimentos[nX,13]

		cQuery := "SELECT SUM(R4_VALOR) RENDIMENTO "
		cQuery += "FROM " + RetSqlName("SR4") + " A "
		cQuery += "WHERE R4_CPFCGC = '" + aRendimentos[nX,3] + "' AND "
		cQuery += "R4_CODRET = '"+ aRendimentos[nX,5] + "' AND "
		cQuery += "R4_TIPOREN = '" + cTpRen + "' AND "
		cQuery += "R4_FILIAL = '" + xFilial("SR4") + "' AND "
		cQuery += "R4_NIFEX = '"+ aRendimentos[nX,13] + "' AND "
		cQuery += "D_E_L_E_T_ = ' ' "

		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "REND", .F., .T.)

		nRendAnual := 0 + REND->RENDIMENTO
		REND->(DbCloseArea())
		cChaveAnt  := (aRendimentos[nX,3] + aRendimentos[nX,13] + aRendimentos[nX,5])
		For nY := nX To nLen
			// Mudou de fornecedor ou codigo de retencao
			If cChaveAnt != (aRendimentos[nY,3]+aRendimentos[nY,13] + aRendimentos[nY,5])
				Exit
			Endif
			nRendAnual += aRendimentos[nY,7]
		Next
	Endif

	cQuery := "SELECT SUM(R4_VALOR) IRRETIDO "
	cQuery += "FROM " + RetSqlName("SR4") + " A "
	cQuery += "WHERE R4_CPFCGC = '" + aRendimentos[nX,3] + "' AND "
	cQuery += "R4_CODRET = '"+ aRendimentos[nX,5] + "' AND "
	cQuery += "R4_TIPOREN = 'D' AND "
	cQuery += "R4_FILIAL = '" + xFilial("SR4") + "' AND "
	cQuery += "R4_NIFEX = '"+ aRendimentos[nX,13] + "' AND "
	cQuery += "D_E_L_E_T_ = ' ' "

	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "IMPOST", .F., .T.)

	nIRRet := 0 + IMPOST->IRRETIDO
	IMPOST->(DbCloseArea())

	// Grava SR4 apenas para fornecedores com rendimento anual maior que 6.000,00
	If nRendAnual > 0 .or. nIRRet > 0
		If !SR4->(MsSeek(aRendimentos[nX,1]))
			// Pesquisa cabecalho da DIRF
			If !SRL->(MsSeek(xFilial("SRL")+SM0->M0_CGC+aRendimentos[nX,5]+aRendimentos[nX,2]+aRendimentos[nX,3] + aRendimentos[nX,13]) )
				PosSA2Log(aRendimentos[nX,3], aRendimentos[nX,13])
				Reclock("SRL", .T.)
				SRL->RL_FILIAL  := xFilial("SRL")
				SRL->RL_MAT     := aRendimentos[nX,12]
				SRL->RL_CODRET  := aRendimentos[nX,5]
				SRL->RL_TIPOFJ  := aRendimentos[nX,2]
				SRL->RL_CPFCGC  := aRendimentos[nX,3]
				SRL->RL_BENEFIC := aRendimentos[nX,8]
				SRL->RL_ENDBENE := aRendimentos[nX,9]
				SRL->RL_UFBENEF := aRendimentos[nX,10]
				SRL->RL_COMPLEM := aRendimentos[nX,11]
				SRL->RL_CGCFONT := SM0->M0_CGC
				SRL->RL_NOMFONT := SM0->M0_NOMECOM
				SRL->RL_ORIGEM := "2"
				SRL->RL_CGCEX := SA2->A2_CGCEX
				SRL->RL_PAIS  := SA2->A2_PAISEX
				SRL->RL_NIFEX := aRendimentos[nX,13] //SA2->A2_NIFEX

				If  IsCodResExt(SRL->RL_CODRET)
					SRL->RL_NEMPR := SA2->A2_NEMPR
					SRL->RL_TPCON := SA2->A2_TPCON
					SRL->RL_DTINI := SA2->A2_DTINIR
					SRL->RL_DTFIM := SA2->A2_DTFIMR
					SRL->RL_LOGEX := SA2->A2_LOGEX
					SRL->RL_NUMEX := SA2->A2_NUMEX
					SRL->RL_COMPL := SA2->A2_COMPLR
					SRL->RL_BAIEX := SA2->A2_BAIEX
					SRL->RL_POSEX := SA2->A2_POSEX
					SRL->RL_CIDEX := SA2->A2_CIDEX
					SRL->RL_ESTEX := SA2->A2_ESTEX
					SRL->RL_TELEX := SA2->A2_TELRE
					SRL->RL_BREEX := SA2->A2_BREEX
					SRL->RL_TPREX := SA2->A2_TPREX
					SRL->RL_TRBEX := SA2->A2_TRBEX
					If !lTemNIF
						If SA2->A2_MOTNIF == "1"                                                                         
							SRL->RL_BEDINI := "1" //Fornecedor dispensado do NIF   
							SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
						Elseif SA2->A2_MOTNIF == "2"             
							SRL->RL_PAEXNI := "2" //País do fornecedor nao exige NIF   
						Endif
					Else
						SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
					Endif
				EndIf
				SRL->(MsUnlock())
				ConfirmSx8()
			Endif
			Reclock("SR4", .T.)
			SR4->R4_FILIAL  := xFilial("SR4")
			SR4->R4_MAT     := aRendimentos[nX,12]
			SR4->R4_CPFCGC  := aRendimentos[nX,3]
			SR4->R4_MES     := aRendimentos[nX,4]
			SR4->R4_TIPOREN := cTpRen
			SR4->R4_CODRET  := aRendimentos[nX,5]
			SR4->R4_ANO  := aRendimentos[nX,6]
			SR4->R4_ORIGEM := "2"

			If  !Empty(SRL->RL_PAIS)
				SR4->R4_PAIS := SRL->RL_PAIS
				SR4->R4_NIFEX := SRL->RL_NIFEX
				SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
				If lISNIF
					SR4->R4_ISNIF :=  IIF(aRendimentos[nX,14],"1","2")
				EndIf
			EndIf

			If lFa401Cmp
				// Utilizado para gravar campos complementares do SR4
				ExecBlock("FA401CMP", .F.,.F.)
			Endif
		Else
			Reclock("SR4", .F.)
		Endif

		SR4->R4_VALOR += aRendimentos[nX,7]

		SR4->(MsUnlock())

		// Processa gravacao dos titulos que geraram este acumulo na SR4
		If lGerLog
			nPosLog := aScan( aDadosLog, { |x| x[1] + Alltrim(x[12])+ x[2] == aRendimentos[nX,3] + Alltrim(aRendimentos[nX,13]) + aRendimentos[nX,5] } )
			If nPosLog > 0
				For nY := nPosLog To Len(aDadosLog)
					cChaveAnt := ( aDadosLog[nPosLog,1] +aDadosLog[nPosLog,12]+ aDadosLog[nPosLog,2] )
					If cChaveAnt != ( aDadosLog[nY,1] +aDadosLog[nY,12]+ aDadosLog[nY,2] )
						Exit
					EndIf
					Fa401AddLog(	@aLog, lGerLog,;
				                aDadosLog[ nY, 1 ], aDadosLog[ nY, 2 ], aDadosLog[ nY, 3 ], aDadosLog[ nY, 4 ],;
								aDadosLog[ nY, 5 ], aDadosLog[ nY, 6 ], aDadosLog[ nY, 7 ], aDadosLog[ nY, 8 ],;
								aDadosLog[ nY, 9 ], aDadosLog[ nY, 10], aDadosLog[ nY, 11], aDadosLog[ nY, 12],;
								aDadosLog[ nY, 13], aDadosLog[ nY, 14], aDadosLog[ nY, 15], aDadosLog[ nY, 16])
								
				Next nY
			EndIf
		EndIf
	Endif
	cChaveAnt	:= (aRendimentos[nX,3] + aRendimentos[nX,13] + aRendimentos[nX,5])
Next

// Restauro a filial do sistema quando processar com filial centralizadora
If !Empty(MV_PAR06)
	cFilAnt := cFilAtu
Endif
(cAliasTrb)->(DbCloseArea())

Fa401SImpDtUptDirf(cNotIn,lQuery,cAbatim,cImpostos,lReproc,cFornUniao,nX,cCondicao,bWhile,bFor,cCampo)

Return Nil


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ VerIRBx      ³ Autor ³                       ³ Data ³ 11/07/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Ver se tem IR Baixado em outro mês   						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ FINA401                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function VerIRBx( cPrefixo , cNum , cParcIR , cParInss , dDtFin)
Local lRet := .F.
Local aArea		:= GetArea()
Local aAreaSE2 	:= SE2->(GetArea())
Local cLojaImp	:= PadR( "00", TamSX3( "A2_LOJA" )[1], "0" )
Local cFornUniao:= Padr( Alltrim( GetMv( 'MV_UNIAO' ) ) , Len( SE2->E2_FORNECE ) ) + cLojaImp
Local cFornInss := PADR( Alltrim( StrTran( cMVINSNAT , '"' , '' )) , LEN(SE2->E2_FORNECE) ) + cLojaImp

SE2->(DbSetOrder(1))

If !Empty( cParcIR )
	If SE2->( DbSeek( xFilial("SE2") + cPrefixo + cNum + cParcIR + MVTAXA + cFornUniao ))
		If SE2->E2_BAIXA <> CtoD( "" )
			lRet := .T.
		EndIf
	EndIf
Endif

If !lRet .And. !Empty( cParInss )
	If SE2->( DbSeek( xFilial("SE2") + cPrefixo + cNum + cParInss + MVTAXA + cFornInss ))
		If SE2->E2_BAIXA <> CtoD( "" )
			lRet := .T.
		EndIf
	EndIf
Endif

RestArea(aAreaSE2)
RestArea(aArea)

Return lRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Fa401ZRINSS ºAutor  ³Adrianne Furtado  º Data ³  04/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Processa todos os fornecedores da DIRF e caso encontre     º±±
±±º          ³ casos em que o fornecedor nao reteve IR e o somatório dos  º±±
±±º          ³ rendimentos tributáveis seja inferior a 6000, zera toda a  º±±
±±º          ³ coluna de rendimentos tributáveis, conforme orientação da  º±±
±±º          ³ nossa acessoria jurídica - Liz                             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Fa401ZRINSS(aLog)

Local cQuery := ""
Local aRecnos := {}
Local nX
Local cAnoIni := STRZERO(YEAR (MV_PAR02),4)
Local cAnoFim := STRZERO(YEAR (MV_PAR03),4)
Local lGerLog	:= (MV_PAR07 == 1)
Local nScanLog := 0
Local cFilSA2	:= xFilial("SA2")
Local aAreaSA2 := SA2->(GetArea())
Local nI

cQuery := "SELECT R4_FILIAL, R4_MAT, R4_CPFCGC, R4_ANO, R4_TIPOREN, R4_CODRET "
cQuery += "FROM " + RetSQLname("SR4") + " SR4 "
cQuery += " WHERE "
cQuery += "R4_TIPOREN = 'A' AND "
cQuery += "R4_ANO between '"+ cAnoIni+"' AND '"+ cAnoFim +"' AND "
cQuery += "D_E_L_E_T_ = ' ' AND "
//filtro para nao levar registros que tenham equivalentes referente a IR (TIPOREN = "D")
cQuery += "NOT EXISTS(SELECT B.R4_CPFCGC, B.R4_MAT, B.R4_CODRET, B.R4_TIPOREN FROM "+ RetSQLname("SR4")+ " B "
cQuery += 			 "WHERE  B.R4_FILIAL = SR4.R4_FILIAL AND "
cQuery +=					"B.R4_CPFCGC = SR4.R4_CPFCGC AND "
cQuery +=					"B.R4_MAT	 = SR4.R4_MAT AND "
cQuery +=					"B.R4_ANO	 = SR4.R4_ANO AND "
cQuery +=					"B.R4_CODRET = SR4.R4_CODRET AND "
cQuery +=					"B.R4_TIPOREN = 'D' AND "
cQuery +=					"B.D_E_L_E_T_ = '' ) AND "
cQuery +="EXISTS(SELECT C.R4_CPFCGC, C.R4_MAT, C.R4_CODRET, C.R4_TIPOREN FROM "+ RetSQLname("SR4")+ " C "
cQuery += 			 "WHERE  C.R4_FILIAL = SR4.R4_FILIAL AND "
cQuery +=					"C.R4_CPFCGC = SR4.R4_CPFCGC AND "
cQuery +=					"C.R4_MAT	   = SR4.R4_MAT AND "
cQuery +=					"C.R4_ANO	   = SR4.R4_ANO AND "
cQuery +=					"C.R4_CODRET = SR4.R4_CODRET AND "
cQuery +=					"C.R4_TIPOREN = 'B' AND "
cQuery +=					"C.D_E_L_E_T_ = '' ) "
cQuery +="GROUP BY R4_MAT, R4_CPFCGC, R4_CODRET, R4_TIPOREN, R4_ANO, R4_FILIAL "
cQuery +="HAVING SUM(R4_VALOR) < 6000 "
cQuery := ChangeQuery(cQuery)

If lFA401SR4
	cQuery := ExecBlock("FA401SR4",.F.,.F.,{cQuery})
Endif

dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBZRINS",.F.,.T.)

/*	For nX := 1 to Len(aStruSR4)
If aStruSR4[nX,2] != 'C' .and. FieldPos(aStruSR4[nX,1]) > 0
	TCSetField("TRBZRINS", aStruSR4[nX,1], aStruSR4[nX,2],aStruSR4[nX,3],aStruSR4[nX,4])
Endif
Next
*/
SA2->(DbSetOrder(3)) //A2_FILIAL+A2_CGC
dbSelectArea("TRBZRINS")
While !(TRBZRINS->(Eof()))
	//zera os rendimentos tributáveis
	//apagar o registro que tem TIPOREN = "A "
	SR4->(DbSetOrder(1))
	SR4->(DbSeek(TRBZRINS->(R4_FILIAL + R4_MAT + R4_CPFCGC + R4_CODRET + R4_ANO)))
	SA2->(MsSeek(cFilSA2+TRBZRINS->R4_CPFCGC))
	While SR4->(R4_FILIAL + R4_MAT + R4_CPFCGC + R4_CODRET + R4_ANO) == ;
			TRBZRINS->(R4_FILIAL + R4_MAT + R4_CPFCGC + R4_CODRET + R4_ANO)
		If AllTrim(SR4->R4_TIPOREN) == "A"
			Aadd(aRecnos,SR4->(Recno()))
		EndIf
		SR4->(DbSkip())
	EndDo

	//zera as contribuições previdenciarias
	//apagar o registro que tem TIPOREN = "B "
	For nX := 1 to Len(aRecnos)
		SR4->(DbGoTo(aRecnos[nX]))
		cChINSS := SR4->(R4_FILIAL + R4_MAT + R4_CPFCGC + R4_CODRET + R4_ANO)
		SR4->(DbSeek(cChINSS))
		While SR4->(R4_FILIAL + R4_MAT + R4_CPFCGC + R4_CODRET + R4_ANO) == cChINSS
			If AllTrim(SR4->R4_TIPOREN) <> "A"
				Aadd(aRecnos,SR4->(Recno()))
			EndIf
			SR4->(DbSkip())
		EndDo
	Next nX

	For nX := 1 to Len(aRecnos)
		SR4->(DbGoTo(aRecnos[nX]))
		If lGerLog
			cChaveTit := SR4->(R4_CPFCGC+R4_CODRET+R4_MES+AllTrim(R4_TIPOREN))
			nScanLog := AScan( aLog, { |x| Alltrim(x[1] + x[2] + x[3] + x[4]) == Alltrim(cChaveTit) } )
			If nScanLog > 0
				For nI:= 1 To Len(aLog)
					If aLog[nI,1] + aLog[nI,2] + aLog[nI,3] + aLog[nI,4] = cChaveTit
						// o ideal era corrigir a gravacao do log para ficar tudo dentro do mesmo padrao
						// mas por segurança fiz assim.
						// qdo tiver oportunidade, fazer a alteracao mais adequada.
						//Fa401EdtLog( @aLog, lGerLog, nScanLog, LOG_VALOR, 0, "=" )
						Fa401EdtLog( @aLog, lGerLog, nI, LOG_VALOR, 0, "=" )
					Endif
				Next
			ElseIf nScanLog = 0
				cChaveTit := SR4->(R4_CPFCGC+R4_CODRET+R4_MES+R4_TIPOREN)
				//zera E2_DTDIRF
				nScanLog := AScan( aLog, { |x| x[1] + x[2] + x[3] + x[4] == cChaveTit } )
			Endif
		EndIf
		RecLock("SR4",.F.)
		dBDelete()
		SR4->(MsUnLock())
	Next nX
	LmpDtDirf()
	aRecnos := {}
	TRBZRINS->(DbSkip())
EndDo
TRBZRINS->(dbCloseArea())
RestArea(aAreaSA2)

Return


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ Fa401AddLog ºAutor ³ Gustavo Henrique º Data ³  29/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Adiciona dados do titulo no vetor de log para posterior    º±±
±±º          ³ impressao do relatorio e geracao do arquivo de log (.CSV)  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ EXPA01 - Array com os dados dos titulos                    º±±
±±º          ³ EXPL02 - Indicar se deve gerar log de acordo com a perguntaº±±
±±º          ³         "Gera Log de Processamento?" (MV_PAR07)            º±±
±±º          ³ EXPC03 - CNPJ/CPF do fornecedor                            º±±
±±º          ³ EXPC04 - Codigo de retencao do titulo                      º±±
±±º          ³ EXPC05 - Mes em que o titulo sera gerado na DIRF           º±±
±±º          ³ EXPC06 - Tipo de retencao                                  º±±
±±º          ³ EXPC07 - Filial do titulo                                  º±±
±±º          ³ EXPC08 - Prefixo                                           º±±
±±º          ³ EXPC09 - Numero                                            º±±
±±º          ³ EXPC10 - Parcela                                           º±±
±±º          ³ EXPC11 - Tipo                                              º±±
±±º          ³ EXPC12 - Natureza                                          º±±
±±º          ³ EXPC13 - Valor                                             º±±
±±º          ³ EXPC14 - Numero NIFEX                                      º±±
±±º          ³ EXPC15 - A2_COD                                            º±±
±±º          ³ EXPC16 - A2_LOJA                                           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA401                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa401AddLog( aLog, lGerLog, cCPFCGC, cCodRet, cMes, cTipoRen, cFilTit,;
								cPrefixo, cNum, cParcela, cTipo, cNatureza, nValor,cNIFEX,cCodFor, cLoja, cFilFor , cNomeFor  )

Local aArea		:= GetArea()
Local aAreaSR4	:= SR4->(GetArea())
Local aAreaSED	:= SED->(GetArea())
Local cChaveTit	:= ""
Local lGravRend	:= .F.
Local cMV_INSS	:= GetMv("MV_INSS")
 
Default aLog	 := {}
Default lGerLog	 := .F.
Default cNIFEX	 := ""
Default cCodFor	 := SA2->A2_COD
Default cLoja	 := SA2->A2_LOJA
Default cFilFor  := SA2->A2_FILIAL 
Default cNomeFor := SA2->A2_NOME 

cNIFEX := Alltrim(cNIFEX)

Iif( TYPE("cAno") == "U" , cAno := SR4->R4_ANO , NIL )

If !SR4->( dbSeek( xFilial("SR4") + SRL->RL_MAT + Padr(cCPFCGC,Len(SR4->R4_CPFCGC)) + cCodRet + cAno + cMes + padr(cTipoRen,nTamTpRen) + SRL->RL_PAIS + cNIFEX) )
	lGravRend := .T.
Endif

If lGerLog
	// Somente inclui o titulo se nao existir no vetor de log
	cChaveTit	:= cCPFCGC + cCodRet + cMes + cTipoRen + cFilTit + cPrefixo + cNum + cParcela + cTipo + cNatureza + cNIFEX
	If AScan( aLog, { |x| x[1] + x[2] + x[3] + x[4] + x[5] + x[6] + x[7] + x[8] + x[9] + x[10] + x[12] == cChaveTit } ) == 0
		If cTipoRen == "A" .or. cTipoRen == "I2" .or. cTipoRen == "I3"
			If lGravRend
				AAdd( aLog, { cCPFCGC, cCodRet, cMes, cTipoRen, cFilTit, cPrefixo, cNum, cParcela, cTipo, cNatureza, nValor, cNIFEX, cCodFor, cLoja } )
			ElseIf nValor == SR4->R4_VALOR
				AAdd( aLog, { cCPFCGC, cCodRet, cMes, cTipoRen, cFilTit, cPrefixo, cNum, cParcela, cTipo, cNatureza, nValor, cNIFEX, cCodFor, cLoja  } )
			ElseIf !lGravRend .and. (AllTrim(cNatureza)$cMV_INSS .or. Posicione("SED",1,xfilial("SED") + cNatureza,"ED_CALCINS") = "S")
				AAdd( aLog, { cCPFCGC, cCodRet, cMes, cTipoRen, cFilTit, cPrefixo, cNum, cParcela, cTipo, cNatureza, nValor, cNIFEX, cCodFor, cLoja  } )
			ElseIf IsInCallStack("Fa401SemRet") .Or. IsInCallStack("Fa401SemImp")
				AAdd( aLog, { cCPFCGC, cCodRet, cMes, cTipoRen, cFilTit, cPrefixo, cNum, cParcela, cTipo, cNatureza, nValor, cNIFEX, cCodFor, cLoja  } )
			Else
				AAdd( aLog, { cCPFCGC, cCodRet, cMes, cTipoRen, cFilTit, cPrefixo, cNum, cParcela, cTipo, cNatureza, nValor, cNIFEX, cCodFor, cLoja  } )
			Endif
		Else
			AAdd( aLog, { cCPFCGC, cCodRet, cMes, cTipoRen, cFilTit, cPrefixo, cNum, cParcela, cTipo, cNatureza, nValor, cNIFEX, cCodFor, cLoja  } )
		Endif
	EndIf
	
	If MV_PAR04 == 1 .and. Empty(cCPFCGC) 
		If aScan(aEmptyCPF,{|x| x[1] + x[2] + x[3]  == cFilFor + cCodFor + cLoja  }) == 0
			aAdd(aEmptyCPF, {cFilFor , cCodFor , cLoja ,  cNomeFor,SA2->(Recno()) })	
		EndIf		
	EndIf
EndIf

RestArea(aAreaSED)
RestArea(aAreaSR4)
RestArea(aArea)

Return


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ Fa401EdtLog ºAutor ³ Gustavo Henrique º Data ³  29/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Edita valores do jah existentes no log. Possibilita somar  º±±
±±º          ³ ou modificar valores.									  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ EXPA1 - Array com os dados dos titulos                     º±±
±±º          ³ EXPL2 - Indicar se deve gerar log de acordo com a pergunta º±±
±±º          ³         "Gera Log de Processamento?" (MV_PAR07)            º±±
±±º          ³ EXPN3 - Linha no vetor de log (titulo)                     º±±
±±º          ³ EXPN4 - Coluna na linha encontrada no log (dado do titulo) º±±
±±º          ³ EXPU5 - Dado a ser somado ou atribuido na posicao          º±±
±±º          ³ EXPL6 - Indica a operacao que deve ser realizada:          º±±
±±º          ³         "=" - Atribuicao de conteudo caracter ou valor     º±±
±±º          ³         "+" - Acrescenta ao conteudo da posicao            º±±
±±º          ³         "-" - Subtrai do conteudo da posicao               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA401                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa401EdtLog( aLog, lGerLog, nPosLog, nPosEdt, xConteudo, cOper )

Local aArea		:= GetArea()
Local aAreaSR4	:= SR4->(GetArea())
Local aAreaSED	:= SED->(GetArea())

Default aLog	:= {}
Default lGerLog	:= .F.
Default cOper	:= "="

If lGerLog .And. nPosLog > 0 .And. nPosEdt > 0
	If cOper == "+" .or. cOper == "||" .or. "CONCAT"$cQryConcat
		If cTipoP=="1"
			If !SR4->( dbSeek (cChavePF) )
				aLog[ nPosLog, nPosEdt ] += xConteudo
			Endif
		Else
			aLog[ nPosLog, nPosEdt ] += xConteudo
		Endif
	ElseIf cOper == "="
		aLog[ nPosLog, nPosEdt ] := xConteudo
	ElseIf cOper == "-"
		aLog[ nPosLog, nPosEdt ] -= xConteudo
	EndIf
EndIf

RestArea(aAreaSED)
RestArea(aAreaSR4)
RestArea(aArea)

Return


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ Fa401ImpLog º Autor ³ Gustavo Henriqueº Data ³  19/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Imprimir relatorio com o log dos titulos processados na    º±±
±±º          ³ geracao dos valores da DIRF                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ EXPA1 - Vetor com os titulos a serem impressos no relatorioº±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA401                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa401ImpLog( aLog, cArqLog )

Local aImpLog	:= {}
Local aLogTitle	:= {}
Local aTotMes	:= { 0, 0, 0, 0, 0 }
Local nX		:= 0
Local cCGCCPF	:= ""
Local cCodRet	:= ""
Local cMes		:= ""
Local cTipoRen	:= ""
Local cSep		:= Space( 2 )
Local cPictVal	:= PesqPict( "SE2", "E2_VALOR", TAM_VALOR )



// Estrutura do vetor aLog
//
// aLog[ 01 ] - CPF/CGC do fornecedor do titulo
// aLog[ 02 ] - Codigo de retencao do titulo informado no cadastro
// aLog[ 03 ] - Numero do mes que o valor foi gerado na DIRF
// aLog[ 04 ] - Tipo de Retencao:
//				A-Rendimento Tributavel;
//				D-Imposto Retido;
//				B-Contrib. Previdenciaria;
//				I-Outros Nao Tributavel;
//				T-Dependentes
// aLog[ 05 ] - Filial
// aLog[ 06 ] - Prefixo
// aLog[ 07 ] - Numero
// aLog[ 08 ] - Parcela
// aLog[ 09 ] - Tipo
// aLog[ 10 ] - Valor

aSort( aLog,,,{ |x,y| x[1] + x[12] + x[2] + x[3] + x[4] < y[1] + y[12] + y[2] + y[3] + y[4] } )

AAdd( aLogTitle,	PadR( STR0011, TAM_FIL	 	) + cSep +;		// Filial
  					PadR( STR0012, TAM_PREF	 	) + cSep +;		// Prefixo
  					PadR( STR0013, TAM_NUM	 	) + cSep +;		// Numero
  					PadR( STR0014, TAM_PARC	 	) + cSep +;		// Parcela
  					PadR( STR0015, TAM_TIPO  	) + cSep +;		// Tipo
  					PadR( STR0016, TAM_NAT  	) + cSep +;		// Natureza
  					PadL( STR0017, TAM_VALOR	) + cSep +;		// Rendimentos Trib. 	"A"
  					PadL( STR0018, TAM_VALOR	) + cSep +;		// Contrib. Previd.		"B"
  					PadL( STR0019, TAM_VALOR	) + cSep +;		// Val.Dependentes		"T"
  					PadL( STR0020, TAM_VALOR	) + cSep +;		// Imposto Retido		"D"
  					PadL( STR0021, TAM_VALOR	) )        		// Outros Não Trib.		"I"

Fa401ImpCab( @aImpLog, aLog[1,1], aLog[1,2], aLog[1,3],,,aLog[1,12], aLog[1,13],aLog[1,14] )

cCGCCPF	:= aLog[1,1]+aLog[1,12]
cCodRet	:= aLog[1,2]
cMes	:= aLog[1,3]

For nX := 1 to Len( aLog )

	// Quebrou por Fornecedor
	If	cCGCCPF != aLog[nX,1]+aLog[nX,12]

		Fa401ImpTot( STR0022 + " " + MesExtenso( Val( cMes ) ) + " : ", cSep, cPictVal, @aTotMes, @aImpLog )	// Total

		Fa401ImpCab( @aImpLog, aLog[nX,1], aLog[nX,2], aLog[nX,3],,,aLog[nX,12],aLog[nX,13], aLog[nX,14] )

		cCGCCPF := aLog[nX,1]+aLog[nX,12]
		cCodRet := aLog[nX,2]
		cMes	:= aLog[nX,3]

	// Quebrou por Codigo de Retencao
	ElseIf cCodRet != aLog[nX,2]

		Fa401ImpTot( STR0022 + " " + MesExtenso( Val( cMes ) ) + " : ", cSep, cPictVal, @aTotMes, @aImpLog )	// Total

		Fa401ImpCab( @aImpLog, aLog[nX,1], aLog[nX,2], aLog[nX,3], .F.,,aLog[nX,12] ,aLog[nX,13], aLog[nX,14])

		cCodRet := aLog[nX,2]
		cMes	:= aLog[nX,3]

	// Quebrou por Mes
	ElseIf cMes != aLog[nX,3]

		Fa401ImpTot( STR0022 + " " + MesExtenso( Val( cMes ) ) + " : ", cSep, cPictVal, @aTotMes, @aImpLog )	// Total

		Fa401ImpCab( @aImpLog, aLog[nX,1], aLog[nX,2], aLog[nX,3], .F., .F., aLog[nX,12],aLog[nX,13], aLog[nX,14])

		cMes := aLog[nX,3]

	EndIf

	cTipoRen := AllTrim( aLog[nX,4] )

	AAdd( aImpLog,	PadR( aLog[nX,5] , TAM_FIL	) + cSep +;
					PadR( aLog[nX,6] , TAM_PREF	) + cSep +;
					PadR( aLog[nX,7] , TAM_NUM	) + cSep +;
					PadR( aLog[nX,8] , TAM_PARC	) + cSep +;
					PadR( aLog[nX,9] , TAM_TIPO	) + cSep +;
					PadR( aLog[nX,10], TAM_NAT 	) + cSep +;
					PadR( Transform( IIf( cTipoRen == "A" .or. cTipoRen == "I2" .or. cTipoRen == "I3", aLog[nX,LOG_VALOR], 0 ), cPictVal ), TAM_VALOR ) + cSep +;
					PadR( Transform( IIf( cTipoRen == "B", aLog[nX,LOG_VALOR], 0 ), cPictVal ), TAM_VALOR ) + cSep +;
					PadR( Transform( IIf( cTipoRen == "T", aLog[nX,LOG_VALOR], 0 ), cPictVal ), TAM_VALOR ) + cSep +;
					PadR( Transform( IIf( cTipoRen == "D", aLog[nX,LOG_VALOR], 0 ), cPictVal ), TAM_VALOR ) + cSep +;
					PadR( Transform( IIf( cTipoRen == "I", aLog[nX,LOG_VALOR], 0 ), cPictVal ), TAM_VALOR ) + cSep )

	If cTipoRen == "A" .or. cTipoRen == "I2" .or. cTipoRen == "I3"
		aTotMes[1] += aLog[nX,LOG_VALOR]
	ElseIf cTipoRen == "B"
		aTotMes[2] += aLog[nX,LOG_VALOR]
	ElseIf cTipoRen == "T"
		aTotMes[3] += aLog[nX,LOG_VALOR]
	ElseIf cTipoRen == "D"
		aTotMes[4] += aLog[nX,LOG_VALOR]
	ElseIf cTipoRen == "I"
		aTotMes[5] += aLog[nX,LOG_VALOR]
	EndIf

Next nX

Fa401ImpTot( STR0022 + " " + MesExtenso( Val( cMes ) ) + " : ", cSep, cPictVal, @aTotMes, @aImpLog, .F. )	// Total

// DIRF - Relacao de Titulos Processados - Arquivo
fMakeLog( { aImpLog }, aLogTitle, NIL, NIL, "DIRF" + DtoS(dDataBase), STR0023 + " (" + cArqLog + ")", "G", "L", , .F. )

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ Fa401ImpCab ºAutor ³ Gustavo Henrique º Data ³  21/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Imprime cabecalho do relatorio de log dos titulos          º±±
±±º          ³ processados na geracao da DIRF                             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ EXPA1 - Vetor com as linhas a serem impressas no relatorio º±±
±±º          ³ EXPC2 - CGCCPF do fornecedor                               º±±
±±º          ³ EXPC3 - Codigo de retencao                                 º±±
±±º          ³ EXPA4 - Mes a ser impresso                                 º±±
±±º          ³ EXPL5 - Indicar se deve imprimir o cab. de fornecedor      º±±
±±º          ³ EXPL6 - Indicar se deve imprimir o cab. de cod. retencao   º±±
±±º          ³ EXPL7 - COdigo NIFEX, caso fornecedor exterior             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA401                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
	ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa401ImpCab( aImpLog, cCGCCPF, cCodRet, cMes, lImpFor, lImpRet, cNIFEX, cCodFor, cLoja )

Local cPictCNPJ := ""
Local cNome := ""

Default lImpFor := .T.
Default lImpRet := .T.

If lImpFor
	If ! Empty( cCGCCPF ) .or. !Empty(cNIFEX)

		PosSA2Log(cCGCCPF,cNIFEX, cCodFor, cLoja, @cNome)

		cPictCNPJ := AllTrim( PicPes( If(SA2->A2_IRPROG == "1" .AND. LEN( ALLtrim(cCGCCPF))<= 11, "F", SA2->A2_TIPO) ) )
		cPictCNPJ := SubStr( cPictCNPJ, 1, ( Len( cPictCNPJ ) - 2 ) )
		Aadd( aImpLog, STR0024 + "  : " + AllTrim( SA2->A2_COD ) + " - " + AllTrim( cNome ) +;		// Fornecedor + CGC
						" - CNPJ/CPF: " + Transform( cCGCCPF, cPictCNPJ ) )
	Else
		Aadd( aImpLog, STR0024 + "  : ")	// Fornecedor
	EndIf
EndIf

If lImpRet
	Aadd( aImpLog, STR0025 + ": " + cCodRet )	// Cod.Retencao
EndIf

Aadd( aImpLog, STR0026 + "         : " + MesExtenso( Val( cMes ) ) )	// Mes
Aadd( aImpLog, "" )

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ Fa401ImpTot ºAutor ³ Gustavo Henrique º Data ³  21/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Imprime total do relatorio de log de titulos processados   º±±
±±º          ³ na geracao da DIRF                                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ EXPC1 - Texto da linha de total;                           º±±
±±º          ³ EXPC2 - Separador (espacos)                                º±±
±±º          ³ EXPC3 - Picture para o valor impresso                      º±±
±±º          ³ EXPA4 - Vetor com os valores totalizados por tipo de       º±±
±±º          ³         retencao (R4_TIPOREN)                              º±±
±±º          ³ EXPA5 - Vetor com as linhas a serem impressas no relatorio º±±
±±º          ³ EXPA6 - Indicar se deve imprimir a linha continua          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA401                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa401ImpTot( cTotal, cSep, cPictVal, aTotal, aImpLog, lImpLin )

Local bTabTotal	:= { |x| PadR( " ", ( TAM_FIL + TAM_PREF + TAM_NUM + TAM_PARC + TAM_TIPO + TAM_NAT + ( Len( cSep ) * 6 ) ) - x ) }

Default lImpLin	:= .T.

Aadd( aImpLog, 	"" )


Aadd( aImpLog,	cTotal + Eval( bTabTotal, Len( cTotal ) ) +;
				PadR( Transform( aTotal[1], cPictVal ), TAM_VALOR ) + cSep +;
				PadR( Transform( aTotal[2], cPictVal ), TAM_VALOR ) + cSep +;
				PadR( Transform( aTotal[3], cPictVal ), TAM_VALOR ) + cSep +;
				PadR( Transform( aTotal[4], cPictVal ), TAM_VALOR ) + cSep +;
				PadR( Transform( aTotal[5], cPictVal ), TAM_VALOR ) + cSep )

If lImpLin
	Aadd( aImpLog, 	Replicate( "-", 220 ) )
EndIf

aTotal := { 0, 0, 0, 0, 0 }

Return


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ Fa401GerLog ºAutor ³ Gustavo Henrique º Data ³  21/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Gera arquivo de log em formato de planilha Excel (.CSV)    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ EXPA1 - Vetor com os titulos processados que geraram DIRF  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA401                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa401GerLog( aLog )

Local cPath		:= ""
Local cBarra	:= If( isSrvUnix(), "/", "\" )
Local cDirAnt   := CurDir()
Local cSeqArq	:= "01"
Local cArqLog	:= ""
Local cTexto	:= ""
Local cSep		:= ";"
Local cTipoRen	:= ""
Local cPictCNPJ := ""

Local aDirLog	:= {}
Local aX1Def 	:= {}

Local nHandle	:= 0
Local nX		:= 0
Local nValPerg	:= 0

Local lRet		:= .T.
Local cNome := ""

// Caso nao exista, cria pasta \DIRF para armazenamento do log.
cPath	:= GetSrvProfString("StartPath", "") + If( Right( GetSrvProfString("StartPath",""), 1 ) == cBarra, "", cBarra ) + "DIRF"
cArqLog	:= "DIRF" + DtoS(dDataBase) + cSeqArq + ".CSV"

aSort( aLog,,,{ |x,y| x[1] + x[12] + x[2] + x[3] + x[4] < y[1] + y[12] + y[2] + y[3] + y[4] } )

// Cria a pasta DIRF caso nao exista.
If !File( cPath )
	MakeDir(cPath)
EndIf

// Muda para pasta DIRF
CurDir( cPath )

// Se o arquivo de log jah existe, gera outro arquivo com nova sequencia inicial
If File(cArqLog)
	aDirLog := Directory( "DIRF" + AllTrim( Str( Year(dDataBase) ) ) + StrZero( Month(dDataBase), 2 ) + StrZero( Day(dDataBase), 2 ) + "??.CSV" )
	aSort( aDirLog,,,{|x,y| x[1] < y[1]} )
	cSeqArq := SubStr( aDirLog[ Len(aDirLog), 1 ], 1, At( ".", aDirLog[ Len(aDirLog), 1 ] ) -1 )
	cSeqArq := Soma1( Right( cSeqArq, 2 ) )
	cArqLog := "DIRF" + DtoS(dDataBase) + cSeqArq + ".CSV"
EndIf

// Tratamento para criacao do arquivo
If !File(cArqLog)
	nHandle := fCreate(cArqLog)
	If nHandle < 0
		nError := fError()
		// Nao foi possivel criar o arquivo de Log ### Erro numero:
		MsgAlert( STR0027 + cArqLog + ". " + STR0028 + PadR( Str(nError), 4 ) )
		lRet := .F.
	Else
		fClose(nHandle)
	EndIf
Endif

// Se conseguiu criar o arquivo, grava os dados do vetor aLog
If lRet

	nHandle := fOpen( cArqLog, 2 )
	fSeek( nHandle, 0, 2 )     // Posiciona no final do arquivo

    // Percorre o grupo de perguntas e grava no arquivo .CSV
	SX1->( dbSetOrder( 1 ) )
	SX1->( MsSeek( "FIN401" ) )

	Do While SX1->( ! EoF() .And. X1_GRUPO == PadR( "FIN401", Len( X1_GRUPO ) ) )

		cTexto := STR0029 + SX1->X1_ORDEM + ":" + cSep + SX1->X1_PERGUNT + cSep	// Pergunta

		If SX1->X1_TIPO == "D"
			cTexto += ToXLSFormat( DtoC( StoD( SX1->X1_CNT01 ) ) )
		ElseIf SX1->X1_GSC == "C"	// Combo box
			aX1Def   := { X1Def01(), X1Def02(), X1Def03(), X1Def04(), X1Def05() }
			nValPerg := &( SX1->X1_VAR01 )
			cTexto += ToXLSFormat( aX1Def[ nValPerg ] )
		Else
			cTexto += ToXLSFormat( SX1->X1_CNT01 )
		EndIf

		fWrite( nHandle, cTexto + Chr(13) + Chr(10), Len( cTexto ) + 2 )
		fSeek(  nHandle, 0, 2 )     // Posiciona no final do arquivo

		SX1->( dbSkip() )

	EndDo

	fWrite( nHandle, Chr(13) + Chr(10), 2 )
	fSeek(  nHandle, 0, 2 )     // Posiciona no final do arquivo

	// Grava titulo das colunas
	cTexto :=	STR0024 + cSep + "CNPJ/CPF"	+ cSep + STR0025 + cSep + STR0026 + cSep + STR0011 + cSep +;	// Fornecedor ### Cod.Retencao ### Mes ### Filial
				STR0012 + cSep + STR0013	+ cSep + STR0014 + cSep + STR0015 + cSep + STR0016 + cSep +;	// Prefixo ### Numero ### Parcela ### Tipo ### Natureza
				STR0017	+ cSep + STR0018	+ cSep + STR0019 + cSep + STR0020 + cSep + STR0021	// Rendimentos Trib. ### Contrib. Previd. ### Val.Dependentes
																								// Imposto Retido ### Outros Nao Trib.

	fWrite( nHandle, cTexto + Chr(13) + Chr(10), Len(cTexto) + 2 )
	fSeek(  nHandle, 0, 2 )     // Posiciona no final do arquivo

	cCGCCPF	:= aLog[1,1]+aLog[1,12]
	cCodRet	:= aLog[1,2]
	cMes	:= aLog[1,3]

	// Realiza a gravação dos dados do array no arquivo .CSV
	For nX := 1 To Len( aLog )

 		cTexto := ""

		If	cCGCCPF != aLog[nX,1]+aLog[nX,12] .Or. cCodRet != aLog[nX,2] .Or. cMes != aLog[nX,3]
			cCGCCPF	:= aLog[nX,1]+aLog[nX,12]
			cCodRet	:= aLog[nX,2]
			cMes	:= aLog[nX,3]
			cTexto  += CRLF
		EndIf

		cTipoRen := AllTrim( aLog[nX,4] )

		If !Empty( aLog[ nX, 1 ] + aLog[nX,12] )

			PosSA2Log(aLog[ nX, 1 ],aLog[nX,12],aLog[nX,13],aLog[nX,14],@cNome)
			cTexto		+= RTrim(SA2->A2_COD) + " - " + cNome + cSep
			cPictCNPJ   := AllTrim( PicPes( If(SA2->A2_IRPROG == "1", "F", SA2->A2_TIPO) ) )
			cPictCNPJ	:= SubStr( cPictCNPJ, 1, ( Len( cPictCNPJ ) - 2 ) )
		Else
			cTexto += cSep
		EndIf

		cTexto += 	Iif( !Empty( aLog[nX, 1] ), Transform( aLog[nX,1], cPictCNPJ ), " " ) + cSep +;
					ToXLSFormat( aLog[nX, 2] )	+ cSep + ToXLSFormat( MesExtenso( aLog[nX, 3] ) ) + cSep +;
					ToXLSFormat( aLog[nX, 5] )	+ cSep + ToXLSFormat( aLog[nX, 6] ) + cSep + ToXLSFormat( aLog[nX, 7] ) + cSep +;
					ToXLSFormat( aLog[nX, 8] )	+ cSep + ToXLSFormat( aLog[nX, 9] ) + cSep + ToXLSFormat( aLog[nX,10] ) + cSep +;
					ToXLSFormat( IIf( cTipoRen == "A" .or. cTipoRen == "I2" .or. cTipoRen == "I3", aLog[nX,LOG_VALOR], 0 ) ) + cSep +;
					ToXLSFormat( IIf( cTipoRen == "B", aLog[nX,LOG_VALOR], 0 ) ) + cSep +;
					ToXLSFormat( IIf( cTipoRen == "T", aLog[nX,LOG_VALOR], 0 ) ) + cSep +;
					ToXLSFormat( IIf( cTipoRen == "D", aLog[nX,LOG_VALOR], 0 ) ) + cSep +;
					ToXLSFormat( IIf( cTipoRen == "I", aLog[nX,LOG_VALOR], 0 ) )

		fWrite( nHandle, cTexto + Chr(13) + Chr(10), Len( cTexto ) + 2 )
		fSeek(  nHandle, 0, 2 )     // Posiciona no final do arquivo

	Next nX

	fClose( nHandle )

EndIf

// Volta para pasta \system
CurDir( cBarra + cDirAnt )

Return( cArqLog )


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FINA401   ºAutor  ³Microsiga           º Data ³  02/04/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function LmpDtDirf()
//só para limpar os DtDIrf dos titulos que tiveram INSS + rendimento zerado.

Local cQuery := ""
Local cAliasTrb := GetNextAlias()

cQuery := "SELECT "
cQuery += "SE2.E2_FILIAL, SE2.E2_FORNECE, SE2.E2_LOJA, SE2.E2_VENCREA, SE2.E2_PREFIXO, "
cQuery += "SE2.E2_NUM, SE2.E2_PARCELA, SE2.E2_TIPO, SE2.E2_BAIXA, SE2.E2_EMIS1, SE2.E2_PARCINS, "
cQuery += "SE2.E2_VENCTO, SE2.E2_INSS, SE2.R_E_C_N_O_ "
cQuery += " FROM " + RetSqlName("SE2") +" SE2 "
cQuery += " WHERE SE2.E2_FILIAL = '" + xFilial("SE2") + "'"
cQuery += "   AND SE2.E2_DIRF IN ('1','S')"
cQuery += "   AND SE2.E2_CODRET != ' '"
cQuery += "   AND SE2.E2_DTDIRF != ' '"
//vou trazer só os pais, os TX de inss procuro a partir do pai
cQuery += " AND SE2.E2_TIPO NOT IN " + FormatIn(MVINSS+"|"+"INA","|") +" "
cQuery += " AND SE2.E2_FORNECE = '" + SA2->A2_COD +"'"


If MV_PAR05 == 2 .OR. MV_PAR01 == 1
	cQuery += " AND SE2.E2_EMIS1 >= '" + Dtos(MV_PAR02) + "'"
	cQuery += " AND SE2.E2_EMIS1 <= '" + Dtos(MV_PAR03) + "'"
ElseIf MV_PAR05 == 2 .OR. MV_PAR01 == 5
	cQuery += " AND SE2.E2_EMISSAO >= '" + Dtos(MV_PAR02) + "'"
	cQuery += " AND SE2.E2_EMISSAO <= '" + Dtos(MV_PAR03) + "'"
else  //pelo titulo principal
	Do Case
	Case MV_PAR01 == 2// Vencimento
		cQuery += " AND SE2.E2_VENCTO >= '" + Dtos(MV_PAR02) + "'"
		cQuery += " AND SE2.E2_VENCTO <= '" + Dtos(MV_PAR03) + "'"
	Case MV_PAR01 == 3 //Vencimento real
		cQuery += " AND SE2.E2_VENCREA >= '" + Dtos(MV_PAR02) + "'"
		cQuery += " AND SE2.E2_VENCREA <= '" + Dtos(MV_PAR03) + "'"
	Case MV_PAR01 == 4 //Data de Baixa
		cQuery += " AND ((SE2.E2_BAIXA >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += "       SE2.E2_BAIXA <= '" + Dtos(MV_PAR03) + "' ) OR"
		cQuery += "      (SE2.E2_BAIXA = ' ' AND "
		cQuery += "       SE2.E2_EMIS1 >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += " 		SE2.E2_EMIS1 <= '" + Dtos(MV_PAR03) + "' ) ) "
	EndCase
EndIF

cQuery += " AND SE2.D_E_L_E_T_ = ' '"

cQuery := ChangeQuery(cQuery)

dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasTrb,.F.,.T.)
/*
		For ni := 1 to Len(aStru)
			If aStru[ni,2] != 'C' .and. FieldPos(aStru[ni,1]) > 0
				TCSetField(cAliasTrb, aStru[ni,1], aStru[ni,2],aStru[ni,3],aStru[ni,4])
			Endif
		Next
*/
SE2->(DBSetOrder(1))
While !(cAliasTrb)->(Eof())
	//		grava dtdirf do pai
	SE2->(DbSeek((cAliasTrb)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))
	RecLock("SE2")
	SE2->E2_DTDIRF := Ctod("  /  /  ")
	SE2->(MsUnlock())
	If (cAliasTrb)->E2_INSS <> 0
		SE2->(DbSeek((cAliasTrb)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCINS)))
		RecLock("SE2",.F.)
		SE2->E2_DTDIRF := Ctod("  /  /  ")
		SE2->(MsUnlock())
	EndIf
	(cAliasTrb)->(DbSkip())
EndDo

(cAliasTrb)->(DbCloseArea())

Return



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FINA401   ºAutor  ³Microsiga           º Data ³  02/06/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function WrDtDirf(aRecno, cIndex)
Local nX, nY := 0

dbSelectArea("SE2")
dbSetOrder(1)

// Atualiza o flag de geracao da DIRF.
For nX := 1  To Len(aRecno)
	cRecno := ""

	// Monta a string limitando a 500 registros por vez
	For nY := nX To (499+nX)
		If nY > Len(aRecno)
			Exit
		Endif
		cRecno += Alltrim(Str(aRecno[nY],20))+","
	Next

	// Atualiza o flag de geracao da DIRF para nao gerar novamente em novo processamento.
	cQuery := "UPDATE "
	cQuery += RetSqlName("SE2")+" "
	cQuery += "SET E2_DTDIRF = '" + Dtos(dDataBase) + "'"
	cQuery += " WHERE R_E_C_N_O_ IN ("+SubStr(cRecno,1,rat(",",cRecno)-1)+") AND "
	cQuery += "D_E_L_E_T_ = ' ' "

	TcSqlExec(cQuery)

	nX := nY
Next

Return
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³FinAtuSXD ³ Autor ³ Totvs	³ Data ³ 27/03/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao de processamento da gravacao do SXD                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
	±±³ Uso      ³FINA401                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function FinTamSXG(cGrupo,nTamPad)
Local aRet

DbSelectArea("SXG")
DbSetOrder(1)

IF DbSeek(cGrupo)
	aRet := TamSXG(cGrupo)
Else
	aRet := {nTamPad,"@!",nTamPad,nTamPad}
Endif

Return aRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³F401PDesd ³ Autor ³ Adrianne              ³ Data ³ 19/10/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao de verificação de titulos PAI de desdobramento      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³FINA401                                            			  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function F401PDesd(cChave)
Local lPDesd := .F.
Local aArea := SE5->(GetArea())

SE5->(DbSetOrder(7))
If SE5->(DbSeek(xFilial("SE5")+cChave))
	While !lPDesd .and. SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) == cChave
		If SE5->E5_MOTBX == 'DSD' .and. SE5->E5_SITUACA == " "
			lPDesd := .T.
		EndIf
		SE5->(DbSkip())
	EndDo
EndIf

RestArea(aArea)
Return lPDesd

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³IsTheLastPost ³ Autor ³ Adrianne Furtado  ³ Data ³ 13/01/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao de verificação de titulos PAI de desdobramento      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³FINA401                                            			  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function IsTheLastPost(cPrefixo,cNum,cParcela,cTipo,cFornece,cLoja)
Local lRet := .F.
Local cSeq := SE5->E5_SEQ
Local aAreaSE5 := GetArea("SE5")
Local cQuery

cQuery := "SELECT MAX(SE5.E5_SEQ) SEQMAX"
cQuery += " FROM " + RetSqlName("SE5") +" SE5 "
cQuery += " WHERE SE5.E5_FILIAL = '" + xFilial("SE5") + "' AND"
cQuery += "    	SE5.E5_RECPAG = 'P' AND "
cQuery += "    	SE5.E5_SITUACA != 'C' AND "
cQuery += "    	SE5.D_E_L_E_T_ = ' ' AND "
cQuery += "       SE5.E5_PREFIXO = '" + cPrefixo + "' AND"
cQuery += "       SE5.E5_NUMERO  = '" + cNum + "' AND"
cQuery += "       SE5.E5_PARCELA = '" + cParcela + "' AND"
cQuery += "       SE5.E5_TIPO = '" + cTipo + "' AND"
cQuery += "       SE5.E5_CLIFOR = '" + cFornece + "' AND"
cQuery += "       SE5.E5_LOJA = '" + cLoja + "' "
//cQuery += "ORDER BY SE5.E5_SEQ"

cQuery := ChangeQuery(cQuery)

dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"SEQUEN",.F.,.T.)


/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se a maior sequencia de baixa desse título for igual  ³
//³a sequencia que está sendo tratada, significa que é a ³
//³ultima baixa que ocorreu no título.                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ*/
If SEQUEN->SEQMAX == cSeq
	lRet := .T.
EndIf

SEQUEN->(dbCloseArea())

RestArea(aAreaSE5)

Return lRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³f401CodUn ºAutor  ³Adrianne Furtado    º Data ³  20/01/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Verifica se esse título utiliza código único de retenção.   º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function f401CodUn(cAliasTrb,cAliasPai,aCRIN480)
Local lRet := .F.
Local lIRPFBaixa := If(SA2->A2_CALCIRF == "2", .T., .F.)

//Carregar variaveis
//__lPccBaixa

If __lpccbaixa == nil
	F401PccBx()
EndIf

/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Validação de uso do codigo de retenção único.³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ*/
If SA2->A2_TIPO $ 'J|X'
	/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄç
	//³Para PJ, haverá codigo único quando o código de retenção ³
	//³utilizado estiver no array de códigos únicos e houver    ³
	//³IR no título.                                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ*/
	If	aScan(aCRIN480,(cAliasTrb)->E2_CODRET) > 0
		lRet := .T.
	EndIf
Else //Pessoa Física
	/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Quando o PCC e o IR são na baixa.                   ³
	//³Os títulos de impostos da PF assumem o mesmo código ³
	//³de retenção.                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ*/
	If lIRPFBaixa .and. __lPCCBaixa
		If SR4->( dbSeek (cChavePF) )
			lRet := .T.
		Endif
	EndIf
EndIf

Return lRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³IsCodResExt  ³ Autor ³ Adrianne Furtado  ³ Data ³ 22/02/11  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao retorna se o codigo utilizado é referente a residen-³±±
±±³          ³ te exterior.                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³FINA401                                            			  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function IsCodResExt(cCodRet)
Local aCodREx := {"0422","0490","0481","9453","9478","5286","0473","9412","9466","9427","5192"}
Local lRet := .F.

/* lista de códigos retirada do documento de layout da DIRF 2011/2010 diponibilizado pela receita
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ)
//³0422 Royalties e Pagamentos de Assistência Técnica            ³
//³0490 Aplicações em Fundos de Conversão de Débitos externos    ³
//³0481 Juros e Comissões em Geral                               ³
//³9453 Juros Sobre o Capital Próprio                            ³
//³9478 Aluguel e Arrendamento                                   ³
//³5286 Aplicações Financeiras/Entidades de Investimento Coletivo³
//³0473 Rendas e Proventos de Qualquer Natureza                  ³
//³9412 Fretes Internacionais                                    ³
//³9466 Previdência Privada e Fapi                               ³
//³9427 Remuneração de Direitos                                  ³
//³5192 Obras Audiovisuais                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ)
*/

If lF401REX
	aCodREx := ExecBlock("F401REX",.F.,.F.,{aCodREx})
EndIf

If Ascan(aCodREx,cCodRet)<>0
	lRet :=.T.
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FinGrvRCS ºAutor  ³Fabricio Pequeno    º Data ³  03/18/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função para gravar a tabela RCS com informações para        º±±
±±º          ³rendimentos não tributáveis.                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function FinGrvRCS(cTipoFJ,aTitulo,nNaoTributavel,cAliasTrb)

Local aArea		:= GetArea()
Local cDescri	:= " "

dbSelectArea("SED")
dbSetOrder(1)
If ( SED->(DbSeek(xFilial("SED")+AllTrim(NEWSE2->E2_NATUREZ))) )
	cDescri := AllTrim(SED->ED_DESCRIC)
EndIf

dbSelectArea("RCS")
dbSetOrder(1)
If( RCS->(DbSeek(xFilial("RCS")+SRL->RL_MAT+cTipoFJ+aTitulo[CNPJ]+aTitulo[CODIGORETENCAO]+SR4->R4_ANO+SR4->R4_TIPOREN)) )
	RecLock("RCS",.F.)
		dBDelete()
	MsUnLock()
EndIf
If!( RCS->(DbSeek(xFilial("RCS")+SRL->RL_MAT+cTipoFJ+aTitulo[CNPJ]+aTitulo[CODIGORETENCAO]+SR4->R4_ANO+SR4->R4_TIPOREN)) )
	RecLock("RCS",.T.)
		RCS->RCS_FILIAL		:= xFilial("RCS")
		RCS->RCS_MAT 		:= SRL->RL_MAT
		RCS->RCS_TIPOFJ		:= cTipoFJ
		RCS->RCS_CPFBEN		:= aTitulo[CNPJ]
		RCS->RCS_CODRET		:= aTitulo[CODIGORETENCAO]
		RCS->RCS_ANO		:= SR4->R4_ANO
		RCS->RCS_VERBA		:= SR4->R4_TIPOREN
		RCS->RCS_TIPORE		:= "I"
		RCS->RCS_NOME		:= SA2->A2_NOME
		RCS->RCS_CPFCGC		:= " "
		RCS->RCS_VALOR		:= nNaoTributavel
		RCS->RCS_DESCRI		:= cDescri //-- Conversado com equipe do SLA e definido o campo cDescri
		RCS->RCS_OUTROS		:= cDescri //-- para RCS_DESCRI e RCS_OUTROS.
		RCS->RCS_ORIGEM:= "2" //--ORIGEM LACTO: 1 FOL,2 FIN
	MsUnlock()
EndIf

RestArea(aArea)

Return Nil
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³PosSA2Log ºAutor  ³Adrianne Furtado    º Data ³  19/04/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função para posicionar o SA2 no registro do fornecedor da   º±±
±±º          ³linha de log corrente.                                		  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function PosSA2Log(cCGCCPF, cNIFEX, cCodFor, cLoja, cNome)
Local cAliasTmp

Default cNIFEX := ""
Default cLoja := ""
Default cCodFor := ""

cAliasTmp := GetNextAlias()

	If !Empty(cNIFEX)
		cQuery := "SELECT "
		cQuery += "SA2.A2_FILIAL, SA2.A2_COD, SA2.A2_LOJA, SA2.A2_CGC,SA2.A2_CPFIRP, "
		cQuery += "SA2.R_E_C_N_O_ RECSA2"
		cQuery += " FROM " + RetSqlName("SA2") +" SA2 "
		cQuery += " WHERE SA2.A2_FILIAL = '" + xFilial( "SA2" ) + "'"
		cQuery += " AND ( (SA2.A2_NIFEX != ' ' AND SA2.A2_NIFEX = '" + Alltrim(cNIFEX) + "') OR "
		cQuery += " ( SA2.A2_NIFEX = ' ' AND SA2.A2_COD || SA2.A2_LOJA = '" + Alltrim(cNIFEX) + "'))"
	  	cQuery += " AND SA2.D_E_L_E_T_ = ' '"
		cQuery += " ORDER BY A2_FILIAL, A2_COD, A2_LOJA"
		cQuery := ChangeQuery(cQuery)
	 	dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasTmp,.F.,.T.)

		SA2->( DBGOTO( (cAliasTmp)->RECSA2 ) )
		cNome := SA2->A2_NOME
		(cAliasTmp)->(DbCloseArea())

	Else

		SA2->( dbSetOrder( 3 ) )
		If (!SA2->( MsSeek( xFilial( "SA2" ) + cCGCCPF ) ) )  //.OR.  LEN( ALLtrim(cCGCCPF))> 11
			//procurar no campo de CPF IR Progressivo
			cQuery := "SELECT "
			cQuery += "SA2.A2_FILIAL, SA2.A2_COD, SA2.A2_LOJA, SA2.A2_CGC,SA2.A2_CPFIRP, "
			cQuery += "SA2.R_E_C_N_O_ RECSA2"
			cQuery += " FROM " + RetSqlName("SA2") +" SA2 "
			cQuery += " WHERE "
			If LEN( ALLtrim(cCGCCPF))<= 11
				cQuery += " SA2.A2_CPFIRP	= '" + cCGCCPF +	"'"
			Else
				cQuery += " SA2.A2_CPFIRP	= ' ' "
				cQuery += " AND SA2.A2_CGC	= '" + cCGCCPF +	"'"
			Endif
			cQuery += " AND SA2.A2_COD	= '"+cCodFor+"'"
			cQuery += " AND SA2.A2_LOJA	= '"+cLoja+"'"
			cQuery += " AND SA2.A2_IRPROG	= '1'"
	  		cQuery += " AND SA2.D_E_L_E_T_ = ' '"
			cQuery += " ORDER BY A2_FILIAL, A2_COD, A2_LOJA"
			cQuery := ChangeQuery(cQuery)
	 		dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasTmp,.F.,.T.)

			SA2->( DBGOTO( (cAliasTmp)->RECSA2 ) )
			cNome := SA2->A2_NOME
			(cAliasTmp)->(DbCloseArea())

			If SA2->(Eof()) .or. SA2->(Bof())
				//procura o CGC sem filial na SA2
				cQuery := "SELECT "
				cQuery += "SA2.A2_FILIAL, SA2.A2_COD, SA2.A2_LOJA, SA2.A2_CGC,SA2.A2_CPFIRP, "
				cQuery += "SA2.R_E_C_N_O_ RECSA2"
				cQuery += " FROM " + RetSqlName("SA2") +" SA2 "
				cQuery += " WHERE "
				cQuery += " SA2.A2_CPFIRP	= ' ' "
				cQuery += " AND SA2.A2_CGC	= '" + cCGCCPF +	"'"
				cQuery += " AND SA2.A2_IRPROG	<> '1'"
			  	cQuery += " AND SA2.D_E_L_E_T_ = ' '"
				cQuery += " ORDER BY A2_FILIAL, A2_COD, A2_LOJA"
				cQuery := ChangeQuery(cQuery)
			 	dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasTmp,.F.,.T.)

				SA2->( DBGOTO( (cAliasTmp)->RECSA2 ) )
				cNome := SA2->A2_NOME
				(cAliasTmp)->(DbCloseArea())

				// se ainda nao encontrou o CGC/CPF procura na  FKJ
				If lExistFKJ .and. SA2->(Eof()) .or. SA2->(Bof())
					cQuery := "SELECT "
					cQuery += "FKJ.FKJ_NOME, FKJ.FKJ_FILIAL, FKJ.FKJ_COD, FKJ.FKJ_LOJA  "
					cQuery += " FROM " + RetSqlName("FKJ") +" FKJ "
					cQuery += " WHERE "
					cQuery += " FKJ.FKJ_COD = '"+cCodFor+"'"
					cQuery += " AND FKJ.FKJ_LOJA = '"+cLoja+"'"
					cQuery += " AND FKJ.FKJ_CPF	= '" + cCGCCPF +	"'"
				  	cQuery += " AND FKJ.D_E_L_E_T_ = ' '"
					cQuery += " ORDER BY FKJ.FKJ_FILIAL, FKJ.FKJ_COD, FKJ.FKJ_LOJA"
					cQuery := ChangeQuery(cQuery)
				 	dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasTmp,.F.,.T.)
					SA2->( dbSetOrder( 1 ) )
					SA2->( dbSeek(  (cAliasTmp)->FKJ_FILIAL +  (cAliasTmp)->FKJ_COD + (cAliasTmp)->FKJ_LOJA ) )
					cNome := (cAliasTmp)->FKJ_NOME

					(cAliasTmp)->(DbCloseArea())

				EndIf
			ElseIf lExistFKJ
				//se encontrou verifica se o CPF esta cadastrado na FKJ
				FKJ->( dbSetOrder( 1 ) ) //FKJ_FILIAL, FKJ_COD, FKJ_LOJA, FKJ_CPF, R_E_C_N_O_, D_E_L_E_T_
				If FKJ->(DBseek(SA2->(A2_FILIAL + A2_COD + A2_LOJA + A2_CPFIRP) ))
					cNome := FKJ->FKJ_NOME
				EndIf

			EndIf
		Else
			cNome := SA2->A2_NOME
		EndIf


	EndiF

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FINA401   ºAutor  ³Pamela Bernardo     º Data ³  11/30/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³   Função para definir o conteúdo do cMes                   º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA401                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function F401CMES(dDtIni,dDtFin,cMes,cCodRet,lReproc,cFilAtu)
Local cQuery	:= ""
Local cAlias := "SE2SED"
Local cFilAux := cFilAnt

//Caso a filial esteja como centralizadora, a filial é alterada para a que esteja sendo usada na query
If cFilAnt <> cFilAtu
	cFilAtu := cFilAnt
EndIf

If MV_PAR05 == 1
	cMes:=STRZERO(MONTH(dDtini),2)
Else

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³SELECIONA OS DADOS PARA PROCESSAMENTO                                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	cQuery := c401QryMes
	cQuery += "   AND SE2.E2_FILIAL = '" + xFilial( "SE2" ) + "'"
	cQuery += "   AND SED.ED_FILIAL = '" + xFilial( "SED" ) + "'"
	cQuery += "   AND SE2.E2_FORNECE = '" + SA2->A2_COD + "'"
	cQuery += "   AND SE2.E2_LOJA = '" + SA2->A2_LOJA + "' "

	Do Case
		Case MV_PAR01 == 1 // Data de emissao digitada
			cQuery += " AND (( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_EMIS1 >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_EMIS1 <= '" + Dtos(dDtFin) + "' ) OR "
		Case MV_PAR01 == 2// Vencimento
			cQuery += " AND (( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_VENCTO >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_VENCTO <= '" + Dtos(dDtFin) + "' ) OR "
		Case MV_PAR01 == 3 //Vencimento real
			cQuery += " AND (( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_VENCREA >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_VENCREA <= '" + Dtos(dDtFin) + "' ) OR "
		Case MV_PAR01 == 4 //Data de Baixa ³  MV_PAR01		 // Considera data
			cQuery += " AND (( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND ((SE2.E2_BAIXA >= '" + Dtos(dDtIni) + "' AND "
			cQuery += "   SE2.E2_BAIXA <= '" + Dtos(dDtFin) + "') OR "
			cQuery += "  (SE2.E2_BAIXA = ' ' AND "
			cQuery += "   SE2.E2_EMIS1 >= '" + Dtos(dDtIni) + "' AND "
			cQuery += "   SE2.E2_EMIS1 <= '" + Dtos(dDtFin)	+ "') ) ) OR "
		Case MV_PAR01 == 5 // Data de emissao real
			cQuery += " AND (( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_EMISSAO >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_EMISSAO <= '" + Dtos(dDtFin) + "' ) OR "
	EndCase

	Do Case
		Case MV_PAR09 == 1 // Data de emissao
			cQuery += " ( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_EMIS1 >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_EMIS1 <= '" + Dtos(dDtFin) + "') )"
		Case MV_PAR09 == 2// Vencimento
			cQuery += " ( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_VENCTO >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_VENCTO <= '" + Dtos(dDtFin) + "') )"
		Case MV_PAR09 == 3 //Vencimento real
			cQuery += " ( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_VENCREA >= '" + Dtos(dDtIni) + "' AND "
			cQuery +=     " SE2.E2_VENCREA <= '" + Dtos(dDtFin) + "') )"
		Case MV_PAR09 == 4 //Data de Baixa ³  MV_PAR01		 // Considera data
			cQuery += " ( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND ((SE2.E2_BAIXA >= '" + Dtos(dDtIni) + "' AND "
			cQuery += "   SE2.E2_BAIXA <= '" + Dtos(dDtFin) + "') )) )"
		Case MV_PAR09 == 5 //Data de Emissao Real
			cQuery += " ( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND ((SE2.E2_EMISSAO >= '" + Dtos(dDtIni) + "' AND "
			cQuery += "   SE2.E2_EMISSAO <= '" + Dtos(dDtFin) + "') ))) "
	EndCase

	//O valor do rendimento tributavel sera calculado por codigo de retencao, portanto todas as notas que
	//não tiverem codigo de rentencao, não entrarao na somatoria do mês.
	cQuery += " AND SE2.E2_CODRET = '" + cCodRet + "'"

	// Se existir a data de processamento da DIRF, verifica se trata-se de reprocessamento
	If !lReproc
		// filtra os titulos que nao foram processados
		cQuery += "AND SE2.E2_DTDIRF = ' '"
	Endif

	If lF401Qry4
		cQuery := ExecBlock("F401Qry4",.F.,.F.,{cQuery})
	EndIf

	//cQuery := ChangeQuery(cQuery)

	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), (cAlias), .F., .T.)

	dbSelectArea(cAlias)

	dbSelectArea("SE2")
	dbSetOrder(1)
	While !((cAlias)->(Eof()))

		If dbSeek(xFilial("SE2")+(cAlias)->(E2_PREFIXO+E2_NUM+E2_PARCIR)+"TX "+cUniao)

			Do Case
				Case MV_PAR01 == 1 .AND.  MV_PAR05 == 2
					If VAL(STRZERO(MONTH(SE2->E2_EMIS1),2))>=VAL(cMes)+1
							cMes:=STRZERO(MONTH(SE2->E2_EMIS1),2)
					EndIf
				Case MV_PAR01 == 2 .AND.  MV_PAR05 == 2
				If VAL(STRZERO(MONTH(SE2->E2_VENCTO),2))>=VAL(cMes)+1
						cMes:=STRZERO(MONTH(SE2->E2_VENCTO),2)
					EndIf
				Case MV_PAR01 == 3 .AND.  MV_PAR05 == 2
				If VAL(STRZERO(MONTH(SE2->E2_VENCREA),2))>=VAL(cMes)+1
						cMes:=STRZERO(MONTH(SE2->E2_VENCREA),2)
					EndIf
				Case MV_PAR01 == 4 .AND.  MV_PAR05 == 2
					If Empty(SE2->E2_BAIXA)
						//	cMes:=STRZERO(MONTH(dDtini),2)
						cMes := StrZero(Month(SE2->E2_EMIS1),2)			
					ElseIf VAL(STRZERO(MONTH(SE2->E2_BAIXA),2))>=VAL(cMes)+1
						cMes:=STRZERO(MONTH(SE2->E2_BAIXA),2)

					EndIf
				Case MV_PAR01 == 5 .AND.  MV_PAR05 == 2
					If VAL(STRZERO(MONTH(SE2->E2_EMISSAO),2))>=VAL(cMes)+1
							cMes:=STRZERO(MONTH(SE2->E2_EMISSAO),2)
					EndIf
					
				EndCase
				(cAlias)->(dbSkip())
		Else
				If	MV_PAR05 == 2 .AND. MV_PAR01 <> 2
					cMes:=STRZERO(MONTH(dDtini),2)
				Endif
			(cAlias)->(dbSkip())
		EndIf
	EndDo

	(cAlias)->(dbCloseArea())
EndIf

//Restaura a filial que estava antes de entrar na rotina
cFilAnt := cFilAux

Return(cMes)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³F401VldCtz³ Autor ³ Mauricio Pequim Jr    ³ Data ³ 13/08/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Validacao da pergunta Centralizar na filial ? (MV_PAR06)   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³FINA401                                            		  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function F401VldCtz()

Local lGestao   := FWSizeFilial() > 2	// Indica se usa Gestao Corporativa
Local cEmpFil	:= FWCodEmp()
Local nTamEmp	:= Len(cEmpFil)
Local lRet		:= .T.

If !Empty( MV_PAR06 )
	If	!FWFilExist(,MV_PAR06)
		Help(" ",1,"FILIALNOEXIST",,STR0008+CRLF+STR0009+CRLF+STR0010 ,1,0)
		lRet := .F.

	ElseIf lGestao
		If Substr(cFilAnt,1,nTamEmp) != Substr(MV_PAR06,1,nTamEmp)
			Help(" ",1,"OUTRA_EMP",,STR0039+CRLF+"  "+CRLF+STR0040 ,1,0)	//"A filial selecionada para centralização das informações e a filial corrente não pertencem a mesma empresa."
																			//"Selecione uma filial centralizadora que pertença a mesma empresa da filial corrente."
			lRet := .F.
		Endif
	EndIf
EndIf

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ F450PccBx    ³ Autor ³ Mauricio Pequim Jr    ³ Data ³ 27/08/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Vericicacoes referentes ao PCC e PCC-CC           			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ F450PccBx()												 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ FINA450                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function F401PccBx()

If __lPCCBaixa == NIL
	__lPCCBaixa	:= SuperGetMv( "MV_BX10925" ,.T.,"2") == "1"

	__lPaBruto:= SuperGetMv("MV_PABRUTO",.T.,"2") == "1"  //Indica se o PA terá o valor dos impostos descontados do seu valor

	__lPrImPA := !__lPaBruto .And. (SuperGetMv("MV_PAPRIME",.T.,"2") == "1")

	__lValPgto := SuperGetMv("MV_BP10925",.T.,"1") == "2" //1- Valor bruto da baixa parcial / 2- Valor da baixa parcial menos os impostos
Endif

Return


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GravTitFat ºAutor ³Andrea Verissimo Santiago º Data 02/01/14 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função que grava dados da DIRF e gerar relatorio de log paraº±±
±±º           titulos que possuam fatura e retenham IRRF ou PCC na baixa. º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Financeiro                                                 º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function GravTitFat(cCodRet,nValor,cRaMat,cTipoFj,cAliasTrb,cCampo,aLog,lGerLog,;
									aRendimento,aDadosLog,lFatBx)
Local cChaveSr4 := ''
Local nPosLog	  :=	0
Local lCalcIssBx  :=	SA2->A2_TIPO == "J" .And. GetNewPar("MV_MRETISS","1") == "2" //Retencao do ISS pela emissao (1) ou baixa (2)
Local nAscan	  :=	0
Local cTpRen	  := ""

Local lForExt := .F.
Local cNIFEX  := ""
Local lTemNIF := .F.
Local lGeraNIF := .F.

If FindFunction( 'IsIssBx' )
	lCalcIssBx :=	IsIssBx( "P" )
EndIf

//tratamento para fornecedor exterior sem NIF
If !Empty(SA2->A2_PAISEX) 
	If IsCodResExt(cCodRet)
		lForExt := .T.
		lGeraNIF := .T.
	ElseIf SA2->A2_TIPO $ "J|X" .and. (Empty(SA2->A2_CGC) .or. SA2->A2_CGC =="00000000000000")
		lGeraNIF := .T.
	EndIf	
	If lGeraNIF
		If Empty(SA2->A2_NIFEX)
			cNIFEX := SA2->A2_COD +  SA2->A2_LOJA
			lTemNIF := .F.
		Else
			cNIFEX := SA2->A2_NIFEX
			lTemNIF := .T.
		EndIf
	EndIf
EndIf

// Tipo do rendimento considera tipo da entidade
If lTpEnt
	If Empty(SA2->A2_TPENT)
		cTpRen := "A"
	Else
		If SA2->A2_TPENT == "1"	 // Fornecedores Imunes
			cTpRen := "I2"
		ElseIf SA2->A2_TPENT == "2"  // Fornecedores Isentos
			cTpRen := "I3"
		EndIf
	EndIf
Else
	cTpRen := "A"
EndIf

If !SRL->(MsSeek(xFilial("SRL")+SM0->M0_CGC+ cCodRet +cTipoFj+If(SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG = '1',Padr(SA2->A2_CPFIRP,14),SA2->A2_CGC) + cNIFEX))

	Reclock("SRL", .T.)

	cRaMat := GetSxENum("SRL", "RL_MAT")

	SRL->RL_FILIAL  := xFilial("SRL")
	SRL->RL_MAT     := If(Val(SRA->RA_MAT) < 900000 .And. Val(cRaMat) < 900000, "900000",cRaMat)
	SRL->RL_CODRET  := cCodRet
	SRL->RL_TIPOFJ  := cTipoFj
	SRL->RL_CPFCGC  := If(SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG = '1',Padr(SA2->A2_CPFIRP,14),SA2->A2_CGC)
	SRL->RL_BENEFIC := Substr(SA2->A2_NOME,1,60)
	SRL->RL_ENDBENE := Alltrim(SA2->A2_END) + Alltrim(SA2->A2_NR_END)
	SRL->RL_UFBENEF := SA2->A2_EST
	SRL->RL_COMPLEM := SA2->A2_BAIRRO
	SRL->RL_CGCFONT := SM0->M0_CGC
	SRL->RL_NOMFONT := SM0->M0_NOMECOM
	SRL->RL_ORIGEM := "2"
	SRL->RL_CGCEX := SA2->A2_CGCEX
	SRL->RL_PAIS  := SA2->A2_PAISEX
	SRL->RL_NIFEX := cNIFEX //SA2->A2_NIFEX

	If IsCodResExt(SRL->RL_CODRET)

		SRL->RL_NEMPR := SA2->A2_NEMPR
		SRL->RL_TPCON := SA2->A2_TPCON
		SRL->RL_DTINI := SA2->A2_DTINIR
		SRL->RL_DTFIM := SA2->A2_DTFIMR
		SRL->RL_LOGEX := SA2->A2_LOGEX
		SRL->RL_NUMEX := SA2->A2_NUMEX
		SRL->RL_COMPL := SA2->A2_COMPLR
		SRL->RL_BAIEX := SA2->A2_BAIEX
		SRL->RL_POSEX := SA2->A2_POSEX
		SRL->RL_CIDEX := SA2->A2_CIDEX
		SRL->RL_ESTEX := SA2->A2_ESTEX
		SRL->RL_TELEX := SA2->A2_TELRE
		SRL->RL_BREEX := SA2->A2_BREEX
		SRL->RL_TPREX := SA2->A2_TPREX
		SRL->RL_TRBEX := SA2->A2_TRBEX
		If !lTemNIF
			If SA2->A2_MOTNIF == "1"                                                                         
				SRL->RL_BEDINI := "1" //Fornecedor dispensado do NIF   
				SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
			Elseif SA2->A2_MOTNIF == "2"             
				SRL->RL_PAEXNI := "2" //País do fornecedor nao exige NIF   
			Endif
		Else
			SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
		Endif	
	EndIf

	SRL->(MsUnlock())
Endif

// Se existir o ano na chave do SR4
// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
cChaveSr4 := xFilial("SR4")+ SRL->RL_MAT+ SRL->RL_CPFCGC + cCodRet + STRZERO(YEAR((cAliasTrb)->&(cCampo)),4) + STRZERO(MONTH((cAliasTrb)->&(cCampo)),2)

If lFatBx //Gera valores dos impostos (IRRF ou PCC) porque a fatura foi baixada e os titulos gerados.
	If !SR4->( MsSeek( cChaveSr4 + padr("D",nTamTpRen)+ SRL->RL_PAIS + SRL->RL_NIFEX ))
		If nValor > 0
			Reclock("SR4", .T.)
			SR4->R4_FILIAL  := xFilial("SR4")
			SR4->R4_MAT     := SRL->RL_MAT
			SR4->R4_CPFCGC  := SRL->RL_CPFCGC
			SR4->R4_MES     := STRZERO(MONTH((cAliasTrb)->&(cCampo)),2)
			SR4->R4_TIPOREN := "D"
			SR4->R4_CODRET  := cCodRet
			SR4->R4_ANO  := STRZERO(YEAR((cAliasTrb)->&(cCampo)),4)
			SR4->R4_VALOR   := nValor
			SR4->R4_ORIGEM := "2"
			SR4->R4_PAIS 	:= SRL->RL_PAIS
			SR4->R4_NIFEX := SRL->RL_NIFEX

			If  !Empty(SRL->RL_PAIS) .And. IsCodResExt(SRL->RL_CODRET)
				SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
				If lISNIF
					SR4->R4_ISNIF := IIF(lTemNIF,"1","2")
				EndIf
			EndIf
			SR4->(MsUnlock())

			If Alltrim(cCodRet) = '5952'
			 	Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCodRet , STRZERO(MONTH((cAliasTrb)->&(cCampo)),2) 	, "D",;
								(cAliasTrb)->E2_FILIAL,(cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM, (cAliasTrb)->E2_PARCELA,;
								'TX',GetMv("MV_PISNAT"), (cAliasTrb)->E2_PIS, cNIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )

				Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCodRet , STRZERO(MONTH((cAliasTrb)->&(cCampo)),2) 	, "D",;
								(cAliasTrb)->E2_FILIAL,(cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM, (cAliasTrb)->E2_PARCELA,;
								'TX', GetMv("MV_COFINS") , (cAliasTrb)->E2_COFINS, cNIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )

				Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCodRet , STRZERO(MONTH((cAliasTrb)->&(cCampo)),2) 	, "D",;
								(cAliasTrb)->E2_FILIAL,(cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM, (cAliasTrb)->E2_PARCELA,;
								'TX', GetMv("MV_CSLL"), (cAliasTrb)->E2_CSLL,cNIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
			Else// IRRF
				Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCodRet , STRZERO(MONTH((cAliasTrb)->&(cCampo)),2) 	, "D",;
									(cAliasTrb)->E2_FILIAL,(cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM, (cAliasTrb)->E2_PARCELA,;
									'TX', &(SuperGetMv("MV_IRF")), nValor,cNIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
			Endif
		EndIf
	Else
		Reclock("SR4", .F.)
		SR4->R4_VALOR   += nValor
		SR4->(MsUnlock())

		If Alltrim(cCodRet) = '5952'
		 	Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCodRet , STRZERO(MONTH((cAliasTrb)->&(cCampo)),2) 	, "D",;
								(cAliasTrb)->E2_FILIAL,(cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM, (cAliasTrb)->E2_PARCELA,;
								'TX',GetMv("MV_PISNAT"), (cAliasTrb)->E2_PIS , cNIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )

			Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCodRet , STRZERO(MONTH((cAliasTrb)->&(cCampo)),2) 	, "D",;
								(cAliasTrb)->E2_FILIAL,(cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM, (cAliasTrb)->E2_PARCELA,;
								'TX', GetMv("MV_COFINS") , (cAliasTrb)->E2_COFINS, cNIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )

			Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCodRet , STRZERO(MONTH((cAliasTrb)->&(cCampo)),2) 	, "D",;
								(cAliasTrb)->E2_FILIAL,(cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM, (cAliasTrb)->E2_PARCELA,;
								'TX', GetMv("MV_CSLL"), (cAliasTrb)->E2_CSLL, cNIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
		Else// IRRF
			Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCodRet , STRZERO(MONTH((cAliasTrb)->&(cCampo)),2) 	, "D",;
									(cAliasTrb)->E2_FILIAL,(cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM, (cAliasTrb)->E2_PARCELA,;
									'TX', &(SuperGetMv("MV_IRF")), nValor, cNIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME )
		Endif

	Endif
Endif

// Gera valor do Rendimento do imposto.
If lFatBx .Or. (!lFatBx .And. Alltrim(cCodRet) == Alltrim((cAliasTrb)->E2_CODRET))
	If (nAscan:=Ascan(aRendimentos, {|e| e[1] == cChaveSr4+padr(cTpRen,nTamTpRen)+SRL->RL_PAIS + SRL->RL_NIFEX})) == 0

		//recompoe o valor bruto onde foi descontado o ISS na emissão e INSS, pois deve ser gerado pelo valor bruto
		nValor := (cAliasTrb)->E2_VALOR + IIf(!lCalcIssBx .and. (cAliasTrb)->E2_ISS > 0, (cAliasTrb)->E2_ISS,0) + (cAliasTrb)->E2_INSS
		Aadd(aRendimentos, {	cChaveSr4+padr(cTpRen,nTamTpRen)+SRL->RL_PAIS + SRL->RL_NIFEX,;
								cTipoFj,;
								If(SA2->A2_TIPO == "J".and. SA2->A2_IRPROG = '1',SA2->A2_CPFIRP,SA2->A2_CGC),;
								STRZERO(MONTH((cAliasTrb)->&(cCampo)),2),;
								cCodRet,;
								STRZERO(YEAR((cAliasTrb)->&(cCampo)),4),;
								nValor,;
								SA2->A2_NOME,;
								Alltrim(SA2->A2_END) + Alltrim(SA2->A2_NR_END),;
								SA2->A2_EST,;
								SA2->A2_BAIRRO,;
								cRaMat,;
								SRL->RL_NIFEX } )
		nPosLog := Len(aRendimentos)
	Else
		nValor := (cAliasTrb)->E2_VALOR + IIf(!lCalcIssBx .and. (cAliasTrb)->E2_ISS > 0, (cAliasTrb)->E2_ISS,0) + (cAliasTrb)->E2_INSS
		aRendimentos[nAscan,7] += nValor
		nPosLog := nAscan
	Endif

	If lGerLog
		(cAliasTrb)->( AAdd( aDadosLog, {	aRendimentos[nPosLog,3], aRendimentos[nPosLog,5], aRendimentos[nPosLog,4], cTpRen,;
												(cAliasTrb)->E2_FILIAL, (cAliasTrb)->E2_PREFIXO, (cAliasTrb)->E2_NUM,;
												(cAliasTrb)->E2_PARCELA, (cAliasTrb)->E2_TIPO, (cAliasTrb)->E2_NATUREZ, nValor,SRL->RL_NIFEX,SA2->A2_COD , SA2->A2_LOJA , SA2->A2_FILIAL , SA2->A2_NOME } ) )
	EndIf
Endif

Return Nil



/*     */
Static function F401QryMes()
Local cQuery 	:= ""
Local cSepNeg := If("|"$MV_CPNEG,"|",",")
Local cSepProv:= If("|"$MVPROVIS,"|",",")
Local cSepRec := If("|"$MVPAGANT,"|",",")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³SELECIONA OS DADOS TODOS OS DADOS DE SE2.                                       ³
//³EFETUA A TRATATIVA PARA A NÃO INCLUSÃO DOS ITENS BAIXADOS NESTE PRIMEIRO MOMENTO³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cQuery := "SELECT DISTINCT SE2.E2_VALOR";
			           + ", SE2.E2_IRRF";
			           + ", SE2.E2_INSS";
			           + ", SE2.E2_ISS";
			           + ", SE2.E2_SEST";
			           + ", SE2.E2_PRETPIS";
			           + ", SE2.E2_PRETCOF";
			           + ", SE2.E2_PRETCSL";
			           + ", SE2.E2_VRETPIS";
			           + ", SE2.E2_VRETCOF";
			           + ", SE2.E2_VRETCSL";
	  	               + ", SE2.E2_VRETIRF";
			           + ", SE2.E2_INSS";
			           + ", SE2.E2_IRRF";
			           + ", SE2.E2_PREFIXO";
			           + ", SE2.E2_NUM";
			           + ", SE2.E2_TIPO";
			           + ", SE2.E2_PARCELA";
			           + ", SE2.E2_FORNECE";
			           + ", SE2.E2_LOJA";
			           + ", SE2.E2_PARCIR";
			           + ", SE2.E2_PARCINS";
		 		       + ", SE2.E2_BAIXA";
		 		       + ", SE2.E2_SALDO";
		 		       + ", SE2.E2_NATUREZ";
		 		       + ", SED.ED_BASEIRC"

		cQuery += " FROM " + RetSQLname("SE2") + " SE2, "
		cQuery +=           RetSQLname("SED") + " SED "
		cquery += " WHERE SE2.E2_TIPO NOT IN " + FormatIn(MVABATIM,"|")
		cQuery += " AND SE2.E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)
		cQuery += " AND SE2.E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv)
		cQuery += " AND SE2.E2_TIPO NOT IN " + FormatIn(MVPAGANT,cSepRec)
		cQuery += " AND SE2.E2_NATUREZ = SED.ED_CODIGO "
		cQuery += " AND SE2.D_E_L_E_T_ = ' '"
		cQuery += " AND SED.D_E_L_E_T_ = ' '"

		//cQuery:=ChangeQuery(cQuery)
Return cQuery

/*
{Protheus.doc} F401QryIr
@description Retorna query com os dados para processamento de IR
@param nTipo 1 = Query normal, 2 = Query para processamento pela baixa do título de imposto
@author Totvs
*/
Static Function F401QryIr(nTipo as numeric)
	Local cQuery as Character
	Local cSepNeg as Character
	Local cSepProv as Character
	
	cQuery 		:= ""
	cSepNeg 	:= If("|"$MV_CPNEG,"|",",")
	cSepProv	:= If("|"$MVPROVIS,"|",",")

	cQuery := "SELECT DISTINCT SE2.E2_VALOR";
		+ ", SE2.E2_BASEIRF";
		+ ", SE2.E2_IRRF";
		+ ", SE2.E2_INSS";
		+ ", SE2.E2_ISS";
		+ ", SE2.E2_SEST";
		+ ", SE2.E2_PRETPIS";
		+ ", SE2.E2_PRETCOF";
		+ ", SE2.E2_PRETCSL";
		+ ", SE2.E2_VRETPIS";
		+ ", SE2.E2_VRETCOF";
		+ ", SE2.E2_VRETCSL";
		+ ", SE2.E2_VRETIRF";
		+ ", SE2.E2_INSS";
		+ ", SE2.E2_IRRF";
		+ ", SE2.E2_PREFIXO";
		+ ", SE2.E2_NUM";
		+ ", SE2.E2_TIPO";
		+ ", SE2.E2_PARCELA";
		+ ", SE2.E2_FORNECE";
		+ ", SE2.E2_LOJA";
		+ ", SE2.E2_PARCIR";
		+ ", SE2.E2_PARCINS";
		+ ", SE2.E2_BAIXA";
		+ ", SE2.E2_SALDO";
		+ ", SE2.E2_NATUREZ";
		+ ", SE2.E2_FILIAL";
		+ ", SE2.E2_PIS";
		+ ", SE2.E2_CSLL";
		+ ", SE2.E2_COFINS";
		+ ", SE2.E2_ORIGEM";
		+ ", SE2.R_E_C_N_O_ RECNO ";
		+ ", SE2.E2_PRISS ";
		+ ", SE2.E2_PRINSS ";
		+ ", SE2.E2_MOEDA ";
		+ ", SE2.E2_TXMOEDA ";
		+ ", SE2.E2_EMIS1 "

	If lTpEnt
		cQuery += ", SA2.A2_TPENT"
	EndIf

	If nTipo == 1
		cQuery +=", SED.ED_BASEIRC"
		cQuery +=", SED.ED_CALCIRF";
				+ ", SE2.E2_EMISSAO";
				+ ", SE2.E2_VENCTO";
				+ ", SE2.E2_VENCREA";

		cQuery += " FROM " + RetSQLname("SE2") + " SE2, "
		cQuery +=             RetSQLname("SED") + " SED, "
		cQuery +=             RetSQLname("SA2") + " SA2 "

		cQuery += " WHERE SE2.E2_TIPO NOT IN " + FormatIn(MVTXA+"|"+MVTAXA,"|")
		cQuery += " AND SE2.E2_TIPO NOT IN " + FormatIn(MVABATIM,"|")
		cQuery += " AND SE2.E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)
		cQuery += " AND SE2.E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv)

		cQuery += " AND SE2.E2_NATUREZ = SED.ED_CODIGO"
		cQuery += " AND SE2.E2_FORNECE = SA2.A2_COD "
		cQuery += " AND SE2.E2_LOJA = SA2.A2_LOJA "
		cQuery += " AND SE2.D_E_L_E_T_ = ' '"
		cQuery += " AND SED.D_E_L_E_T_ = ' '"
		cQuery += " AND SA2.D_E_L_E_T_ = ' '"

	ElseIf nTipo == 2

		cQuery += " FROM " + RetSQLname("SE2") + " SE2"
		cQuery += " JOIN " + RetSQLname("SA2") + " SA2 "
		cQuery += " ON SA2.A2_COD = SUBSTRING( SE2.E2_TITPAI ," + Str(nTamTit) + ","+ Str(nTamFor)+ ")"
		cQuery += " AND SA2.A2_LOJA = SUBSTRING( SE2.E2_TITPAI ," + Str(nTamTit+nTamFor)+","+ Str(nTamLj)+ ")"

		cQuery += " WHERE SE2.E2_FORNECE = '"+ cUniao + "'"
		cQuery += " AND SE2.E2_TIPO = " + FormatIn(MVTAXA,"|")	
		cQuery += " AND SE2.D_E_L_E_T_ = ' '"
		cQuery += " AND SA2.D_E_L_E_T_ = ' '"
		
	EndIf

Return cQuery


//----------------------------------------------------------------
/*/{Protheus.doc} Fa401UpDtDirf
Faz a exclusao das datas da dirf no caso de reprocessamento - Com imposto
@sample Fa401UpDtDirf(lPlsAtiv,lReproc,cPccTit,cCampo,cChave,ni,nTotREG,cIndex,UPDATE_COM_IMPOSTO)
@param
	lPlsAtiv - Parametro MV_PLSATIV
	lReproc - Se a rotina é de reprocessamento
	cPccTit - Parametros de Pis, Cofins e Csll
	cCampo - Armazena o campo de data que sera utilizado
	cChave - Chave ( PK ) da tabela
	ni - Variavel usado para o loop
	nTotREG - Total de registros da tabela
	cIndex - Index da tabela
@author  Daniel.Mendes
@since 26/03/2014
@version P11
/*/
//----------------------------------------------------------------
Static Function Fa401UpDtDirf(lPlsAtiv,lReproc,cPccTit,cCampo,cCampoP,cChave,ni,nTotREG,cIndex)
Local cQuery    := ""
Local cAliasTrb := ""
Local aAreaSE2  := {}
Local aAreaSA2  := {}
Local lUpdate   := .T.
Local bDbSeek   := {||}

	If lReproc .And. FWModeAccess( "SA2" , 3 ) == "C"
		aAreaSE2 := SE2->(GetArea())
		aAreaSA2 := SA2->(GetArea())
		bDbSeek  := {||SE2->(DbSeek((cAliasTrb)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))}
		Fa401SqlCImp(@cAliasTrb,@cQuery,lPlsAtiv,lReproc,cPccTit,cCampo,cCampoP,cChave,ni,nTotREG,cIndex,lReproc)
		SE2->(DBSetOrder(1))
		SA2->(DBSetOrder(1))

		While !(cAliasTrb)->(Eof())
			Eval(bDbSeek)
			lUpdate := .T.

			/// QUANDO FOR PCC OU INSS, PESQUISAR O TIPO DE FORNECEDOR DO DOCUMENTO PAI E VERIFICAR COM O PARAMETRO DE TELA INFORMADO
			If AllTrim(SE2->E2_NATUREZ)$cPccTit+cMVINSNAT
				SE2->(DbSeek((cAliasTrb)->(E2_FILIAL+E2_TITPAI)))
				If SA2->(DbSeek(xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA)))
					If MV_PAR04 == 1
						If !(SA2->A2_TIPO == "F" .Or. (SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG == "1"))
							lUpdate := .F.
						EndIf
					Else
						If !(SA2->A2_TIPO == "J" .Or. (SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG <> "1"))
							lUpdate := .F.
						EndIf
					EndIf
				Else
					lUpdate := .F.
				EndIf

				Eval(bDbSeek)
			EndIf

			If lUpdate
				RecLock("SE2")
				SE2->E2_DTDIRF := Ctod("  /  /  ")
				SE2->(MsUnlock())
			EndIf

			(cAliasTrb)->(DbSkip())
		EndDo

		(cAliasTrb)->(DbCloseArea())
		SA2->(RestArea(aAreaSA2))
		SE2->(RestArea(aAreaSE2))
	EndIf

Return

//----------------------------------------------------------------
/*/{Protheus.doc} Fa401SImpDtUptDirf
Faz a exclusao das datas da dirf no caso de reprocessamento - Sem imposto
@sample Fa401SImpDtUptDirf(cNotIn,lQuery,cAbatim,cImpostos,lReproc,cFornUniao,nX,cCondicao,bWhile,bFor,cCampo)
@param
	cNotIn - String que guarda os valores do not in, usados no where do E2_TIPO
	lQuery - Se será utilizado uma query ou nao
	cAbatim - String que guarda os tipos de abatimentos - usado no not in
	cImpostos - String que guarda os tipos de impostos - usado no not in
	lReproc - Se a rotina é de reprocessamento
	cFornUniao - Nome do fornecedor UNIAO
	nX - Variavel usado para o loop
	cCondicao - Condicao/Where
	bWhile - Bloco de codigo do while
	bFor - Bloco de codigo do for
	cCampo - Armazena o campo de data que sera utilizado
@author  Daniel.Mendes
@since 28/04/2014
@version P11
/*/
//----------------------------------------------------------------
Static Function Fa401SImpDtUptDirf(cNotIn,lQuery,cAbatim,cImpostos,lReproc,cFornUniao,nX,cCondicao,bWhile,bFor,cCampo)
Local cQuery    := ""
Local cAliasTrb := ""
Local aArea     := {}
Local lGestao		:= FWSizeFilial() > 2
Local lSE2Access	:= Iif( lGestao .And. FWModeAccess("SE1",1) == "E",.T.,.F.)

	If lReproc .And. FWModeAccess( "SA2" , 3 ) == "C"
		cAliasTrb := GetNextAlias()
		aArea := SE2->(GetArea())
		Fa401SqlSImp(cNotIn,lQuery,cAbatim,cImpostos,@cQuery,lReproc,cFornUniao,@cAliasTrb,nX,cCondicao,@bWhile,@bFor,cCampo,lReproc)
		SE2->(DBSetOrder(1))

		While !(cAliasTrb)->(Eof()) .And. Eval(bWhile)
			SE2->(DbSeek((cAliasTrb)->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)))

			//Respeitar a gestão de emepresas para não apagar campos de outras empresas
			If lSE2Access  .And. Len(FWSM0Layout(, 1))>0 .And. (FWCOMPANY() != Substr((cAliasTrb)->E2_FILIAL,1,Len(FWSM0Layout(, 1))))
				(cAliasTrb)->(DbSkip())
				Loop
			EndIf
			RecLock("SE2")
			SE2->E2_DTDIRF := Ctod("  /  /  ")
			SE2->(MsUnlock())
			(cAliasTrb)->(DbSkip())

		EndDo

		(cAliasTrb)->(DbCloseArea())
		SE2->(RestArea(aArea))
	EndIf

Return

//----------------------------------------------------------------
/*/{Protheus.doc} Fa401SqlCImp
Cria uma query conforme os parametros informados na SE2 - Com imposto
@sample Fa401SqlCImp(cAliasTrb,cQuery,lPlsAtiv,lReproc,cPccTit,cCampo,cChave,ni,nTotREG,cIndex,lExclusao)
@param
	cAliasTrb - Alias para ser usado na query
	cQuery - Armazena o select
	lPlsAtiv - Parametro MV_PLSATIV
	lReproc - Se a rotina é de reprocessamento
	cPccTit - Parametros de Pis, Cofins e Csll
	cCampo - Armazena o campo de data que sera utilizado
	cCampoP - Armazena o campo de data que sera utilizado quando for PCC
	cChave - Chave ( PK ) da tabela
	ni - Variavel usado para o loop
	nTotREG - Total de registros da tabela
	cIndex - Index da tabela
	lExclusao - Se a query e para efetuar a exclusao da data da dirf
	cFiltro - filtro para base DBF
	cTipoIn - Filtro para o tipos de titulos
@author  Daniel.Mendes
@since 25/04/2014
@version P11
/*/
//----------------------------------------------------------------
Static Function Fa401SqlCImp(cAliasTrb,cQuery,lPlsAtiv,lReproc,cPccTit,cCampo,;
									cCampoP,cChave,ni,nTotREG,cIndex,lExclusao,cFiltro,cTipoIn)

Local cCompSA2 := FWModeAccess( "SA2" , 1 ) + FWModeAccess( "SA2" , 2 ) + FWModeAccess( "SA2" , 3 )
Local nTamFilSA2 := If( "E" $ cCompSA2, Len(Alltrim(xFilial("SA2"))) , 0 )

Default lExclusao := .F.
Default cTipoIn := ""

cAliasTrb := GetNextAlias()

cQuery := "SELECT "
cQuery += "SE2.E2_FILIAL, SE2.E2_FORNECE, SE2.E2_LOJA, SE2.E2_CODRET,SE2.E2_VENCREA, SE2.E2_PREFIXO, "
cQuery += "SE2.E2_NUM, SE2.E2_PARCELA, SE2.E2_TIPO, SE2.E2_NATUREZ, SE2.E2_BAIXA, SE2.E2_EMIS1,SE2.E2_SEQBX, "
cQuery += "SE2.E2_EMISSAO,SE2.E2_VENCTO, SE2.E2_VALOR, SE2.E2_INSS, SE2.E2_IRRF, SE2.E2_ISS, SE2.E2_PIS, SE2.E2_COFINS, SE2.E2_CSLL, "
cQuery += "SE2.E2_PARCIR, SE2.E2_PARCPIS,SE2.E2_FILORIG,SE2.E2_CNPJRET,SE2.E2_NOMERET,SE2.E2_TITPAI,SE2.E2_FILORIG,SE2.R_E_C_N_O_ "
If !lExclusao
	If cBDname $ "INFORMIX*ORACLE"
		cQuery += ", NVL(PAI.R_E_C_N_O_,0) RECNOPAI "
	ElseIf  cBDname $ "DB2*POSTGRES" .OR. ( cBDname == "DB2/400" .And. Upper(cSrvType) == "ISERIES" )
		cQuery += ", COALESCE(PAI.R_E_C_N_O_,0) RECNOPAI "
	Else
		cQuery += ", ISNULL(PAI.R_E_C_N_O_,0) RECNOPAI  "
	EndIf
EndIf

cQuery += ", SE2.E2_TITPAI "
If lTpEnt
	cQuery += ", SA2.A2_TPENT"
EndIf
cQuery += " FROM " + RetSqlName("SE2") +" SE2 "

cQuery += " LEFT JOIN " + RetSqlName("SE2") +" PAI ON "
cQuery += " (SE2.E2_FILIAL = PAI.E2_FILIAL AND "
If "MYSQL" $ cBDname
	cQuery += cQryConcat+" PAI.E2_PREFIXO,PAI.E2_NUM,PAI.E2_PARCELA,PAI.E2_TIPO,PAI.E2_FORNECE,PAI.E2_LOJA) = SE2.E2_TITPAI AND "
ElseIf cBDname $ "DB2|POSTGRES|MSSQL"  .OR. ( cBDname == "DB2/400" .And. Upper(cSrvType) == "ISERIES" )
	cQuery += " PAI.E2_PREFIXO = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI ,1," +STR(nTamPref) + "))"
	cQuery += " AND PAI.E2_NUM = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI ,"+STR(nTamPref+1) +"," + STR(nTamNum) + "))"
	cQuery += " AND PAI.E2_PARCELA =  RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI ,"+STR(nTamPref+nTamNum+1)+","+STR(nTamPar)+"))"
	cQuery += " AND PAI.E2_TIPO = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI ,"+STR(nTamPref+nTamNum+nTamPar+1)+","+STR(nTamTipo)+"))"
	cQuery += " AND PAI.E2_FORNECE = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI,"+STR(nTamPref+nTamNum+nTamPar+nTamTipo+1)+","+STR(nTamFor)+"))"
	cQuery += " AND PAI.E2_LOJA = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI,"+STR(nTamPref+nTamNum+nTamPar+nTamTipo+nTamFor+1)+","+STR(nTamLj)+")) AND"

Else
	cQuery += " PAI.E2_PREFIXO" +cQryConcat+"PAI.E2_NUM"+cQryConcat+"PAI.E2_PARCELA"+cQryConcat+"PAI.E2_TIPO"+cQryConcat+"PAI.E2_FORNECE"+cQryConcat+"PAI.E2_LOJA = SE2.E2_TITPAI AND "
EndIf
If !Empty(cTipoIn)
	cQuery += " PAI.E2_TIPO NOT IN " + cTipoIn + " AND "
EndIf
cQuery += " PAI.D_E_L_E_T_= ' ' )"
cQuery += " JOIN " +  RetSqlName("SA2") + " SA2 ON "

If MV_PAR08 == 1
	cQuery += "( SA2.A2_FILIAL " + cFilSA2 + " AND PAI.E2_FORNECE = SA2.A2_COD AND PAI.E2_LOJA = SA2.A2_LOJA AND SA2.D_E_L_E_T_ = ' ' "
Else
	cQuery += "( SA2.A2_FILIAL = '" + xFilial("SA2") + "' AND PAI.E2_FORNECE = SA2.A2_COD AND PAI.E2_LOJA = SA2.A2_LOJA AND SA2.D_E_L_E_T_ = ' ' "
EndIf

If nTamFilSA2 > 0
		If cBDname $ "ORACLE|DB2|POSTGRES|INFORMIX"
		cQuery += " AND SUBSTR(SA2.A2_FILIAL,1," + str(nTamFilSA2) +" ) = SUBSTR(PAI.E2_FILORIG,1,"+Str(nTamFilSA2)+")  "
	Else
		cQuery += " AND SUBSTRING(SA2.A2_FILIAL,1,"+ str(nTamFilSA2)+") = SUBSTRING(PAI.E2_FILORIG,1,"+Str(nTamFilSA2)+") "
	EndIf
EndIf

If MV_PAR04 == 1 //Fisico
	//Se for PJ com IR Progressivo, será tratado como Pessoa Física.
	cQuery +=	" AND (SA2.A2_TIPO = 'F'  OR (SA2.A2_TIPO = 'J' AND SA2.A2_IRPROG = '1')) "
Else
	cQuery +=	" AND (SA2.A2_TIPO = 'X' OR (SA2.A2_TIPO = 'J' AND SA2.A2_IRPROG != '1')) "
Endif
cQuery += ") "



//If lExclusao
//	cQuery += Fa401SqlA2( SA2_SQL_JOIN , "SA2" , "PAI" , lExclusao )
//EndIf

/// QUANDO FOR EXCLUSAO, DEVE PEGAR TODAS AS FILIAIS DIFERENTES NA FILIAL ATUAL, CASO CONTRARIO SOMENTE DA FILIAL ATUAL
//Gestao
If MV_PAR08 == 1
	If !lExclusao
		cQuery += " WHERE SE2.E2_FILIAL " + cFilSel + " "
	Else
		cQuery += " WHERE SE2.E2_FILIAL " + Iif( " IN " $ cFilSel , " NOT " + cFilSel , "!= '" + cFilAnt + "'" )
	EndIf
Else
	cQuery += " WHERE SE2.E2_FILIAL " + Iif( !lExclusao , ("= '" + xFilial("SE2")) , ("!= '" + cFilAnt) ) + "'"
Endif

cQuery += "   AND SE2.E2_DIRF IN ('1','S' " + Iif( lExclusao , ",'2'" , "" ) + ")"
cQuery += "   AND SE2.E2_CODRET != ' ' AND "
If !Empty(cTipoIn)
	If MV_PAR10 == 2
		cQuery += " SE2.E2_TIPO IN " + cTipoIn + " AND "
	Else

		cQuery += " ( SE2.E2_TIPO IN  " + cTipoIn + " OR "
		cQuery += " (SE2.E2_TIPO IN " + FormatIn(MVTXA+"|"+"INA","|") + " AND SE2.E2_BAIXA != ' ' "
		cQuery += " AND EXISTS (SELECT SE5.R_E_C_N_O_ FROM " + RetSqlName("SE5") + " SE5 WHERE "
		cQuery += " SE5.E5_FILORIG = SE2.E2_FILORIG AND "
		cQuery += " SE5.E5_PREFIXO = SE2.E2_PREFIXO AND "
		cQuery += " SE5.E5_NUMERO = SE2.E2_NUM AND "
		cQuery += " SE5.E5_PARCELA = SE2.E2_PARCELA AND "
		cQuery += " SE5.E5_CLIFOR = SE2.E2_FORNECE AND "
		cQuery += " SE5.E5_LOJA = SE2.E2_LOJA AND "
		cQuery += " SE5.E5_TIPODOC IN ('BA','VL') AND "
		cQuery += " SE5.E5_MOTBX NOT IN ('CMP','DSD') AND "
		cQuery += " SE5.E5_SITUACA NOT IN ( 'C' , 'E' , 'X' )"
		cQuery += " AND SE5.E5_TIPODOC <> 'ES'"
		cQuery += " AND SE5.D_E_L_E_T_ = ' '))) AND "
	EndIf

EndIf

/// QUANDO FOR EXCLUSAO, DEVE PEGAR TODAS AS DATAS JA PREENCHIDAS
If lExclusao
	cQuery += "SE2.E2_DTDIRF != ' ' AND "
Else
	// Se existir a data de processamento da DIRF, verifica se trata-se de reprocessamento
	// Se for reprocessamento, filtra apenas os titulos que ja foram processados
	If !lReproc
		// Senao filtra os titulos que nao foram processados
		cQuery += "SE2.E2_DTDIRF = ' ' AND "
	Endif
EndIf

/// DESSA FORMA A EXCLUSAO FICA O CONTRARIO DA EXCLUSAO SEM IMPOSTOS, NAO PESQUISANDO DOCUMENTOS IGUAIS
If lExclusao
	cQuery += Fa401SqlA2( SA2_SQL_WHERE , "SA2" , "SE2" , lExclusao , .T. )
EndIf

Do Case
	Case MV_PAR01 == 1 // Data de emissao digitada
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND ( PAI.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) OR "
		EndIf
		cCampo  := "E2_EMIS1"

	Case MV_PAR01 == 2// Vencimento
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_VENCTO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND ( PAI.E2_VENCTO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) OR "
		Endif
		cCampo  := "E2_VENCTO"

	Case MV_PAR01 == 3 //Vencimento real
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_VENCREA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND ( PAI.E2_VENCREA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) OR "
		Endif
		cCampo  := "E2_VENCREA"

	Case MV_PAR01 == 4 //Data de Baixa
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND ((SE2.E2_BAIXA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
			cQuery += " (SE2.E2_BAIXA = ' ' AND "
			cQuery += " SE2.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) ) ) OR "
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND ( (PAI.E2_BAIXA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR "
			cQuery += " (PAI.E2_BAIXA = ' ' AND "
			cQuery += " PAI.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) )) OR "
		EndIf
		cCampo := "E2_BAIXA"

	Case MV_PAR01 == 5 // Data de emissao real
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_EMISSAO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND ( PAI.E2_EMISSAO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) OR "
		EndIf
		cCampo  := "E2_EMISSAO"

EndCase

Do Case
	Case MV_PAR09 == 1 // Data de emissao
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) "
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND PAI.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) AND "
		EndIf
		cCampoP  := "E2_EMIS1"

	Case MV_PAR09 == 2// Vencimento
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_VENCTO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) "
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND PAI.E2_VENCTO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) AND "
		Endif
		cCampoP  := "E2_VENCTO"

	Case MV_PAR09 == 3 //Vencimento real
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_VENCREA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) "
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND PAI.E2_VENCREA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) AND "
		Endif
		cCampoP  := "E2_VENCREA"

	Case MV_PAR09 == 4 //Data de Baixa
		cCampoP := "E2_BAIXA"
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND (SE2.E2_BAIXA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ))) "
			
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			If MV_PAR10 == 1 // considera PA
				cQuery += " AND ((PAI.E2_BAIXA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' "
				cQuery += " AND PAI.E2_TIPO NOT IN " + FormatIn(MVPAGANT,"|") + ") OR "
				cQuery += " (PAI.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' "
				cQuery += " AND PAI.E2_TIPO IN " + FormatIn(MVPAGANT,"|") + ")))) AND  "
				
			Else
				If __lPccBaixa
					cQuery += " AND (SE2.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ))) AND "
					cCampoP := "E2_EMIS1"				
				Else
					cQuery += " AND (PAI.E2_BAIXA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ))) AND "
				EndIf	
				
			EndIf
		EndIf
		

	Case MV_PAR09 == 5 //Data de Emissao Real
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND (SE2.E2_EMISSAO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ))) "
		ElseIf MV_PAR05 == 1 .and. !lExclusao
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND (PAI.E2_EMISSAO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ))) AND "
		EndIf
		cCampoP := "E2_EMISSAO"
EndCase

cChave := "SE2.E2_FILIAL , SE2.E2_FORNECE,SE2.E2_LOJA , SE2.E2_CODRET ,SE2."+cCampo+" , SE2.E2_PREFIXO , SE2.E2_NUM , SE2.E2_PARCELA , SE2.E2_TIPO"
IF MV_PAR05 == 2
	cQuery += " AND SE2.D_E_L_E_T_ = ' '"
Else
	cQuery += " SE2.D_E_L_E_T_ = ' '"
Endif
cQuery += " ORDER BY " + cChave

//cQuery := ChangeQuery(cQuery)

If lFA401QRY
	cQuery := ExecBlock("FA401QRY",.F.,.F.,{cQuery})
Endif

dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasTrb,.F.,.T.)
//MPSysOpenQuery( cQuery , cAliasTrb ,aStru )

For ni := 1 to Len(aStru)
	If aStru[ni,2] != 'C' .and. FieldPos(aStru[ni,1]) > 0
		TCSetField(cAliasTrb, aStru[ni,1], aStru[ni,2],aStru[ni,3],aStru[ni,4])
	Endif
Next

//Com o arquivo temporario da query, a contagem precisa ser feita registro a registro
(cAliasTrb)->(dbEval({|| nTotREG++}))
(cAliasTrb)->(dbGoTop())

Return

//----------------------------------------------------------------
/*/{Protheus.doc} Fa401SqlSImp
Cria uma query conforme os parametros informados na SE2 - Sem imposto
@sample Fa401SqlSImp(cNotIn,lQuery,cAbatim,cImpostos,cQuery,lReproc,cFornUniao,cAliasTrb,nX,cCondicao,bWhile,bFor,cCampo,lExclusao)
@param
	cNotIn - String que guarda os valores do not in, usados no where do E2_TIPO
	lQuery - Se será utilizado uma query ou nao
	cAbatim - String que guarda os tipos de abatimentos - usado no not in
	cImpostos - String que guarda os tipos de impostos - usado no not in
	cQuery - Armazena o select
	lReproc - Se a rotina é de reprocessamento
	cFornUniao - Nome do fornecedor UNIAO
	cAliasTrb - Alias para ser usado na query
	nX - Variavel usado para o loop
	cCondicao - Condicao/Where
	bWhile - Bloco de codigo do while
	bFor - Bloco de codigo do for
	cCampo - Armazena o campo de data que sera utilizado
	lExclusao - Se a query e para efetuar a exclusao da data da dirf
@author  Daniel.Mendes
@since 28/04/2014
@version P11
/*/
//----------------------------------------------------------------
Static Function Fa401SqlSImp(cNotIn,lQuery,cAbatim,cImpostos,cQuery,lReproc,cFornUniao,cAliasTrb,nX,cCondicao,bWhile,bFor,cCampo,lExclusao)

Default lExclusao := .F.

cNotIn := FormatIn(cAbatim+"|"+cImpostos+"|"+MVPROVIS+"|"+MVPAGANT,"|")
lQuery := .T.

cQuery := "SELECT A.E2_FILIAL, A.E2_VALOR, A.E2_CODRET, A.E2_EMIS1, A.E2_FORNECE, A.E2_LOJA, A.E2_IRRF, A.E2_PREFIXO, A.E2_NUM, "
cQuery += " A.E2_PARCELA, A.E2_TIPO, A.E2_PARCIR, A.E2_PIS, A.E2_PARCPIS, A.E2_COFINS, A.E2_CSLL, "
cQuery += " A.E2_VENCTO, A.E2_VENCREA, A.E2_BAIXA, A.E2_NATUREZ, "
cQuery += " A.E2_FATURA, A.E2_FATFOR, A.E2_FATLOJ, A.E2_FATPREF, A.E2_TIPOFAT, "
cQuery += " A.R_E_C_N_O_, SA2.A2_CGC, A.E2_ISS, A.E2_INSS ,A.E2_EMISSAO,"
cQuery += " SA2.A2_CPFIRP, "
cQuery += " A.E2_ISS , A.E2_SALDO ,  A.E2_INSS , A.E2_PRINSS, A.E2_PRISS,"

If lTpEnt
	cQuery += "	SA2.A2_TPENT,"
EndIf
cQuery += " SA2.R_E_C_N_O_ RECNOSA2 "
cQuery += "FROM " + RetSqlName("SE2") + " A "

cQuery += Fa401SqlA2( SA2_SQL_JOIN , "SA2" , "A" , lExclusao )
cQuery += "WHERE 	"

/// QUANDO FOR EXCLUSAO, DEVE PEGAR TODAS AS FILIAIS DIFERENTES NA FILIAL ATUAL, CASO CONTRARIO SOMENTE DA FILIAL ATUAL
If !lExclusao
	cQuery += " A.E2_FILIAL = '" + xFilial("SE2") + "' AND "
Else
	//Gestão
	If MV_PAR08 == 1 .And. "IN" $ cFilSel
		cQuery += " A.E2_FILIAL " + Iif( " IN " $ cFilSel , " NOT " , "" ) + cFilSel + " AND "
	Else
		cQuery += " A.E2_FILIAL != '" + cFilAnt + "' AND "
	EndIf
EndIf

Do Case
	Case MV_PAR01 == 1 // Data de emissao digitada
		cQuery += "( A.E2_NATUREZ NOT IN " + cPccTit + "  AND "
		cQuery += " A.E2_EMIS1 >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += " A.E2_EMIS1 <= '" + Dtos(MV_PAR03) + "') "
		cCampo := "E2_EMIS1"
	Case MV_PAR01 == 2// Vencimento
		cQuery += "( A.E2_NATUREZ NOT IN " + cPccTit  + "  AND "
		cQuery += " A.E2_VENCTO >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += " A.E2_VENCTO <= '" + Dtos(MV_PAR03) + "') "
		cCampo := "E2_VENCTO"
	Case MV_PAR01 == 3 //Vencimento real
		cQuery += "( A.E2_NATUREZ NOT IN " + cPccTit   + "  AND "
		cQuery += " A.E2_VENCREA >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += " A.E2_VENCREA <= '" + Dtos(MV_PAR03) + "') "
		cCampo := "E2_VENCREA"
	Case MV_PAR01 == 4 //Data de Baixa
		cQuery += "( A.E2_NATUREZ NOT IN " +  cPccTit  + "  AND "
		cQuery += " (A.E2_BAIXA >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += "   A.E2_BAIXA <= '" + Dtos(MV_PAR03) + "' ) OR"
		cQuery += "  (A.E2_BAIXA = ' ' AND "
		cQuery += "   A.E2_EMIS1 >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += "   A.E2_EMIS1 <= '" + Dtos(MV_PAR03) + "' ) ) "
		cCampo := "E2_EMIS1"
	Case MV_PAR01 == 5 // Data de emissao real
		cQuery += "( A.E2_NATUREZ NOT IN " + cPccTit + "  AND "
		cQuery += " A.E2_EMISSAO >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += " A.E2_EMISSAO <= '" + Dtos(MV_PAR03) + "') "
		cCampo := "E2_EMISSAO"
EndCase
// Desconsidera titulo baixado por desdobramento
cQuery += "AND NOT EXISTS (SELECT SE5.R_E_C_N_O_ FROM " + RetSqlName("SE5") + " SE5 WHERE "
cQuery += " SE5.E5_FILORIG = A.E2_FILORIG AND "
cQuery += " SE5.E5_PREFIXO = A.E2_PREFIXO AND "
cQuery += " SE5.E5_NUMERO = A.E2_NUM AND "
cQuery += " SE5.E5_PARCELA = A.E2_PARCELA AND "
cQuery += " SE5.E5_CLIFOR = A.E2_FORNECE AND "
cQuery += " SE5.E5_LOJA = A.E2_LOJA AND "
cQuery += " SE5.E5_MOTBX IN ('DSD') AND "
cQuery += " SE5.E5_SITUACA NOT IN ( 'C' , 'E' , 'X' )"
cQuery += " AND SE5.D_E_L_E_T_ = ' ')

cQuery += " AND "
cQuery += " A.E2_TIPO NOT IN " + cNotIn + " AND "
cQuery += " A.E2_CODRET != ' ' AND "
If !lExclusao
	cQuery += " A.E2_DIRF = '1' AND "
Else
	cQuery += " A.E2_DIRF IN ( '1' , '2' ) AND "
	cQuery += Fa401SqlA2( SA2_SQL_WHERE , "SA2" , "A" , lExclusao )
EndIf

/// QUANDO FOR EXCLUSAO, DEVE PEGAR TODAS AS DATAS JA PREENCHIDAS
If lExclusao
	cQuery += "A.E2_DTDIRF != ' ' AND "
// Se existir a data de processamento da DIRF, verifica se trata-se de reprocessamento
ElseIf !lReproc
	// filtra os titulos que nao foram processados
	cQuery += "A.E2_DTDIRF = ' ' AND "
Endif

cQuery += "NOT EXISTS ( SELECT	B.E2_NUM FROM " + RetSqlName("SE2") + " B "

If !lExclusao
	cQuery += "			        WHERE  B.E2_FILIAL = '"+xFilial("SE2") + "' AND "
Else
	cQuery += "			        WHERE  B.E2_FILIAL = A.E2_FILIAL AND "
EndIf

cQuery += "           				B.E2_PREFIXO = A.E2_PREFIXO AND "
cQuery += "				B.E2_NUM = A.E2_NUM AND "
cQuery += "				(B.E2_PARCELA = A.E2_PARCIR OR B.E2_PARCELA = A.E2_PARCPIS OR B.E2_PARCELA = A.E2_PARCCOF OR B.E2_PARCELA = A.E2_PARCSLL) AND "
cQuery += "	  			B.E2_TIPO = '"+MVTAXA +"' AND "
cQuery += "				B.E2_FORNECE = '"+cFornUniao+"' AND "
cQuery += "				B.E2_LOJA = '00' AND
cQuery += " 			B.D_E_L_E_T_ = ' ') AND "
cQuery += " A.D_E_L_E_T_ = ' ' "

If lF401Qry5
	cQuery := ExecBlock("F401Qry5",.F.,.F.,{cQuery})
EndIf

cQuery := ChangeQuery(cQuery)
dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasTrb, .F., .T.)

For nX := 1 to Len(aStru)
	If aStru[nX,2] != 'C' .And. FieldPos(aStru[nX,1]) > 0 // Se existir o campo na Query
		TCSetField(cAliasTrb, aStru[nX,1], aStru[nX,2],aStru[nX,3],aStru[nX,4])
	Endif
Next

Return

//----------------------------------------------------------------
/*/{Protheus.doc} Fa401SqlA2
Cria e retorna o join ou where da tabela SA2 conforme parametros informados
@sample Fa401SqlA2( nTipo , cAliasSA2 , cAliasSE2 , lExclusao )
@param
	nTipo - Tipo de retorna, join das tabelas ou where da tabela SA2
	cAliasSA2 - Alias da tabela SA2 na query
	cAliasSE2 - Alias da tabela SE2 na query
	lExclusao - Se e para efetuar a rotina de exclusao
@return Valor do where ou join da tabela SA2
@author  Daniel.Mendes
@since 28/04/2014
@version P11
/*/
//----------------------------------------------------------------
Static Function Fa401SqlA2( nTipo , cAliasSA2 , cAliasSE2 , lExclusao , lComImposto )
Local   cSql        := ""
Local   lSA2Compar  := .F.
Local   cAbatim     := ""
Local   cImpostos   := ""
Local   cWhereTpJF  := ""
Local   cTpWhereJ   := ""
Default cAliasSE2   := "SE2"
Default lExclusao   := .F.
Default lComImposto := .F.

	If nTipo == SA2_SQL_JOIN
		lSA2Compar := FWModeAccess( "SE2" , 3 ) <> FWModeAccess( "SA2" , 3 )
		cSql += " JOIN " + RetSqlName("SA2") + " SA2 ON "

		If lSA2Compar .Or. !lExclusao
			cSql += " " + cAliasSA2 + ".A2_FILIAL = '" + xFilial("SA2") + "' AND "
		Else
			cSql += " " + cAliasSA2 + ".A2_FILIAL = " + cAliasSE2 + ".E2_FILIAL AND "
		EndIf
		cSql += " " + cAliasSE2 + ".E2_FORNECE = " + cAliasSA2 + ".A2_COD AND "
		cSql += " " + cAliasSE2 + ".E2_LOJA = " + cAliasSA2 + ".A2_LOJA AND "
		cSql += " " + cAliasSA2 + ".D_E_L_E_T_ = ' ' "
	ElseIf nTipo == SA2_SQL_WHERE
		If MV_PAR04 == 1 //Fisico
				cWhereTpJF := " ("+cAliasSA2+".A2_TIPO = 'F' OR ("+cAliasSA2+".A2_TIPO = 'J' AND "+cAliasSA2+".A2_IRPROG = '1'))"
				cTpWhereJ  := " (" + cAliasSA2 + ".A2_TIPO = 'X' OR (" + cAliasSA2  + ".A2_TIPO = 'J' AND "+cAliasSA2+".A2_IRPROG != '1')) "

				If lExclusao .And. lComImposto
					cAbatim   := MV_CRNEG+"|"+MV_CPNEG+"|"+MVIRABT+"|"+MVCSABT+"|"+MVCFABT+"|"+MVPIABT+"|"+MVABATIM
					cImpostos := MVISS+"|"+MVTXA+"|"+MVINSS+"|"+"SES"+"|" + "INA"
					cSql      += "( ( " + cAliasSE2 + ".E2_TIPO IN " + FormatIn(cAbatim+"|"+cImpostos+"|"+MVPROVIS+"|"+MVPAGANT,"|") + " AND "
					cSql      += cTpWhereJ + " ) OR "
					cSql      += "( "+cTpWhereJ+" AND "+cAliasSE2+".E2_TIPO = '"+MVTAXA+"' AND "+cAliasSE2+".E2_NATUREZ IN "+cPccTit+") OR"
					cSql      += cWhereTpJF + ") AND "
				Else
					//Se for PJ com IR Progressivo, será tratado como Pessoa Física.
					cSql += cWhereTpJF + " AND "
				EndIf
		Else
			cSql += " (" + cAliasSA2 + ".A2_TIPO = 'X' OR (" + cAliasSA2  + ".A2_TIPO = 'J'  AND " + cAliasSA2 + ".A2_IRPROG != '1')) AND "
		Endif
	EndIf

Return cSql

//----------------------------------------------------------------------
/*/{Protheus.doc} Fa401PaiProc
Verifica se a chave informada existe no array dos titulos pais
@sample Fa401PaiProc( aTitulos , cChaveSE2 )
@param
	aTit - Array dos titulos pais
	cChave - Chave da SE2 concatenada
@return Boolean, .T. se encontrar o titulo no array, .F. caso contrário
@author  Daniel.Mendes
@since 30/07/2014
@version P12
/*/
//----------------------------------------------------------------------
Static Function Fa401PaiProc( aTit , cChave )
Local lRet := .F.
Local nX := 0

For nX := 1 To Len( aTit )
	If !Empty( aTit[nX] )
		If aScan( aTit[nX] , cChave ) > 0
			lRet := .T.
			Exit
		EndIf
	EndIf
Next nX

Return lRet
/*
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³Fa401SemRet ³ Autor ³ Andrea V. Santiago   ³ Data ³ 03.07.14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Processa todos os titulos que possuirem retencao de IR ou PCC³±±
±±³mas que nao geraram titulos de impostos e nao estao retidos em outros.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Fa401SemRet()										        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa401SemRet(aRecno,lReproc,cFilAtu,aLog,lGerLog,TMP1)
Local cQuery 	 	:= ""
Local cAbatim 	:= MV_CRNEG+"|"+MV_CPNEG+"|"+MVIRABT+"|"+MVCSABT+"|"+MVCFABT+"|"+MVPIABT+"|"+MVABATIM
Local cImpostos 	:= MVISS+"|"+MVTAXA+"|"+MVTXA+"|"+MVINSS+"|"+"SES"+ "|" + "INA"
Local cNotIn	 	:= ""
Local cAliasRet 	:= GetNextAlias()

Local nX
Local nRendTributavel	:=	0
Local cTipoFj		:=	""
Local cRaMat		:=	""
Local lGrava		:=	 .F.
Local cData		:= ""
Local lExclusao	:=	.F.
Local aAreaSe2 	:= 	{}
Local lOk			:=	.T.
Local cArqTMP	:= ""
Local cArqINDEX	:= CriaTrab(,.F.)
Local aCampos	:= {}


Local cCampo		:=	""
Local aCodRet	:=	{}
Local cCdRet	:= ""
Local nI		:= 0
Local lIRPFBaixa := If(SA2->A2_CALCIRF == "2", .T., .F.)
Local lCalcIssBx :=	SA2->A2_TIPO == "J" .And. GetNewPar("MV_MRETISS","1") == "2" //Retencao do ISS pela emissao (1) ou baixa (2)
Local nPos	:=	0
Local lExc	:=	.F.
Local cNIFEX := ""
Local lTemNIF := .F.
Local lForExt := .F.
Local lGeraNIF := .F.
Local lF401arec	:= ExistBlock("F401arec")
Local lARec		:= .F.
Local nz		:= 0
Local cRec		:= ""
Local cTpRen	:= ""
Local lEnvia	:=	.T.
Local lRetPis	:= .F.
Local lRetCof	:= .F.
Local lRetCSL	:= .F.
Local lRetIR 	:= .F.
Local aCPFs		:= {}
Local lPJIRPrg	:= .F.

If FindFunction( 'IsIssBx' )
	lCalcIssBx :=	IsIssBx( "P" )
EndIf


AADD(aCampos,{"NROREG"  	,"N",9,0})
AADD(aCampos,{"TITIPAI"  	,"L",1,0})
CriaTMP(aCampos,@cArqTMP,"TMP",cArqINDEX,"NROREG")

If !Empty(MV_PAR06) // Se possuir filial centralizadora, posiciona nesta filial
	cFilAnt := cFilAtu
Endif

Do Case //Titulos de outros impostos
	Case MV_PAR01 == 1 // Data de emissao digitada
		cData  := "E2_EMIS1"
	Case MV_PAR01 == 2// Vencimento
		cData  := "E2_VENCTO"
	Case MV_PAR01 == 3 //Vencimento real
		cData  := "E2_VENCREA"
	Case MV_PAR01 == 4 //Data de Baixa
		cData := "E2_BAIXA"
	Case MV_PAR01 == 5 // Data de emissao real
		cData  := "E2_EMISSAO"
EndCase

cNotIn := FormatIn(cAbatim+"|"+cImpostos+"|"+MVPROVIS+"|"+MVPAGANT,"|")

lQuery := .T.

cQuery := "SELECT DISTINCT A.E2_FILIAL, A.E2_VALOR, A.E2_CODRET, A.E2_EMIS1, A.E2_FORNECE, A.E2_LOJA, A.E2_IRRF, A.E2_PREFIXO, A.E2_NUM, "
cQuery += " A.E2_PARCELA, A.E2_TIPO, A.E2_PARCIR, A.E2_PIS, A.E2_PARCPIS, A.E2_COFINS, A.E2_CSLL, "
cQuery += " A.E2_VENCTO, A.E2_VENCREA, A.E2_BAIXA, A.E2_NATUREZ, "
cQuery += " A.E2_FATURA, A.E2_FATFOR, A.E2_FATLOJ, A.E2_FATPREF, A.E2_TIPOFAT, "
cQuery += " A.E2_PRETPIS, A.E2_PRETCOF, A.E2_PRETCSL, A.E2_PRETIRF, A.E2_VRETCOF , A.E2_VRETPIS, A.E2_VRETCSL, A.E2_VRETIRF,"
cQuery += " A.R_E_C_N_O_, SA2.A2_CGC, A.E2_ISS, A.E2_INSS , A.E2_EMISSAO, A.E2_NUMBOR, A.E2_SALDO, "
cQuery += " A.E2_BASEIRF,A.E2_FILORIG, A.E2_BASEPIS,A.E2_BASECOF,A.E2_BASECSL, A.E2_VRETISS, A.E2_SEST, A.E2_RETENC, A.E2_DECRESC, "

cQuery += " SA2.A2_CPFIRP, A.E2_VRETINS, "

cQuery += "	SA2.R_E_C_N_O_ RECNOSA2, COALESCE(FKJ.FKJ_COD,'"+ space(TamSx3("FKJ_COD")[1]) +"') FKJ_COD "
If lTpEnt
	cQuery += ", SA2.A2_TPENT"
EndIf
cQuery += "FROM " + RetSqlName("SE2") + " A "

cQuery += Fa401SqlA2( SA2_SQL_JOIN , "SA2" , "A" , lExclusao )
cQuery += " LEFT JOIN " + RetSqlName("FKJ") + " FKJ " 
cQuery += " ON SA2.A2_FILIAL = FKJ.FKJ_FILIAL "
cQuery += " AND SA2.A2_COD = FKJ.FKJ_COD "
cQuery += " AND SA2.A2_LOJA = FKJ.FKJ_LOJA "
cQuery += "WHERE 	"
cQuery += " A.E2_FILIAL = '" + xFilial("SE2") + "' AND "

Do Case
	Case MV_PAR01 == 1 // Data de emissao digitada
		cQuery += "( A.E2_NATUREZ NOT IN " + cPccTit + "  AND "
		cQuery += " A.E2_EMIS1 >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += " A.E2_EMIS1 <= '" + Dtos(MV_PAR03) + "') "
		cCampo := "E2_EMIS1"
	Case MV_PAR01 == 2// Vencimento
		cQuery += "( A.E2_NATUREZ NOT IN " + cPccTit  + "  AND "
		cQuery += " A.E2_VENCTO >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += " A.E2_VENCTO <= '" + Dtos(MV_PAR03) + "') "
		cCampo := "E2_VENCTO"
	Case MV_PAR01 == 3 //Vencimento real
		cQuery += "( A.E2_NATUREZ NOT IN " + cPccTit   + "  AND "
		cQuery += " A.E2_VENCREA >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += " A.E2_VENCREA <= '" + Dtos(MV_PAR03) + "') "
		cCampo := "E2_VENCREA"
	Case MV_PAR01 == 4 //Data de Baixa
		cQuery += "( A.E2_NATUREZ NOT IN " +  cPccTit  + "  AND "
		cQuery += " (A.E2_BAIXA >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += "   A.E2_BAIXA <= '" + Dtos(MV_PAR03) + "' ) OR"
		cQuery += "  (A.E2_BAIXA = ' ' AND "
		cQuery += "   A.E2_EMIS1 >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += "   A.E2_EMIS1 <= '" + Dtos(MV_PAR03) + "' ) ) "
		cCampo := "E2_EMIS1"
	Case MV_PAR01 == 5 // Data de emissao real
		cQuery += "( A.E2_NATUREZ NOT IN " + cPccTit + "  AND "
		cQuery += " A.E2_EMISSAO >= '" + Dtos(MV_PAR02) + "' AND "
		cQuery += " A.E2_EMISSAO <= '" + Dtos(MV_PAR03) + "') "
		cCampo := "E2_EMISSAO"
EndCase

If !lReproc .or. lF401arec
	// filtra os titulos que nao foram processados
	If lF401arec
		If Len(aRecno) > 0
			lARec	:= ExecBlock("F401arec",.F.,.F.,)
		EndIf
		If lARec
			cQuery += " AND (A.E2_DTDIRF = ' '  "
			For nz := 1 to Len(aRecno)
				If nz == 1
					cRec	:= "("
				Else
					cRec	+= ","
				EndIf
				cRec	+= Alltrim(STR(aRecno[nz]))
			Next
			cRec	+= ")"
			cQuery += "OR A.R_E_C_N_O_ IN " + cRec + " ) "
		Else
			cQuery += " AND A.E2_DTDIRF = ' '  "
		EndIf
	Else
		cQuery += " AND A.E2_DTDIRF = ' '  "
	EndIf

Endif
cQuery += " AND A.E2_TIPO NOT IN " + cNotIn + " AND "
cQuery += " A.E2_CODRET != ' ' AND "  //Titulo definido para ir na DIRF.

//Titulos de PCC que estejam pendentes de retenção. Neste caso pode ser um titulo de valor minimo de retenção ou
//que o momento de retenção do imposto esteja na baixa e ainda não foi efetuada a mesma.
cQuery += "  ( A.E2_VRETPIS + A.E2_VRETCOF + A.E2_VRETCSL = 0 )  AND "
cQUery += "  (E2_VRETIRF = 0 OR (E2_IRRF = 0 AND E2_VRETIRF <> 0) OR "
cQuery += "   FKJ.FKJ_CPF <> '') AND "
cQuery += " A.D_E_L_E_T_ = ' ' AND "
cQuery += " COALESCE(FKJ.D_E_L_E_T_,' ') = ' ' "

cQuery := ChangeQuery(cQuery)

If lF401QRY3
	cQuery := ExecBlock("F401QRY3",.F.,.F.,{cQuery})
Endif

dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasRet, .F., .T.)

For nX := 1 to Len(aStru)
	If aStru[nX,2] != 'C' .And. FieldPos(aStru[nX,1]) > 0 // Se existir o campo na Query
		TCSetField(cAliasRet, aStru[nX,1], aStru[nX,2],aStru[nX,3],aStru[nX,4])
	Endif
Next

SA2->(Dbsetorder(1))

While (cAliasRet)->(!Eof())

	If !Empty(MV_PAR06)
		cFilAnt := cFilAtu
	Endif

	//titulos que ainda nao reteve PCC e estão em abertos não enviar se data pcc for dt baixa
	If ((cAliasRet)->E2_PRETPIS = '1' .And. (cAliasRet)->E2_PRETCOF = '1' .And. (cAliasRet)->E2_PRETCSL = '1' ) .and. ((cAliasRet)->(E2_PIS + E2_COFINS + E2_CSLL )> 0);
		.And. (cAliasRet)->E2_IRRF = 0 .and.  MV_PAR09 == 4 .and. Empty((cAliasRet)->E2_BAIXA)
			(cAliasRet)->(Dbskip())
			Loop
	EndIf

	//Para titulos com natureza sem retencao devem ser selecionados em outra query.
	SED->(Dbseek( xFilial("SED") + (cAliasRet)->E2_NATUREZ ))
	If SED->ED_CALCIRF == "N" .And. SED->ED_CALCISS == "N" .And. SED->ED_CALCINS == "N" .And. SED->ED_CALCCSL == "N" .And.;
		SED->ED_CALCPIS == "N" .And. SED->ED_CALCCOF == "N"
		(cAliasRet)->(Dbskip())
		Loop
	Endif

	lOk	:=	.T.
	aCodRet	:=	{}
	cCdRet		:= ""
	lForExt := .f.
	cNIFEX := ""
	lTemNIF := .F.
	lGrava	:=	 .F.
	aCPFs	:= {}

	//Caso titulo seja retido em outro que já foi gravado para a DIRF durante esta execução não deve duplicar.
	SFQ->(DbSetOrder(2)) //FQ_FILIAL+FQ_ENTDES+FQ_PREFDES+FQ_NUMDES+FQ_PARCDES+FQ_TIPODES+FQ_CFDES+FQ_LOJADES
	If SFQ->(DbSeek(xFilial("SFQ")+ Iif(__lPCCBaixa,"SE5","SE2") + (cAliasRet)->E2_PREFIXO + (cAliasRet)->E2_NUM + (cAliasRet)->E2_PARCELA + (cAliasRet)->E2_TIPO +;
							 (cAliasRet)->E2_FORNECE + (cAliasRet)->E2_LOJA ))
		aAreaSe2 := SE2->(GetArea())
		SE2->(DbSetOrder(1))
		If SE2->(Dbseek(xFilial("SE2")+ SFQ->FQ_PREFORI + SFQ->FQ_NUMORI + SFQ->FQ_PARCORI + SFQ->FQ_TIPOORI + SFQ->FQ_CFORI + SFQ->FQ_LOJAORI))
			If (SE2->&(cData) <= MV_PAR03 .And. SE2->&(cData) >= MV_PAR02)
				lOk	:=	.F.
			Endif
		Endif
		SE2->(RestArea(aAreaSe2))
	Endif

	//Titulo que possua fatura que retenha IRRF ou PCC na baixa.
	//Se fatura estiver baixada, envia a fatura e não envia a NF, somente envia a NF se ela tiver impostos na emissao
	lEnvia	:=	.T.
	If ((lIrBx .And. (cAliasRet)->E2_IRRF > 0) .Or.;
		 (__lPCCBaixa .And. ((cAliasRet)->E2_COFINS+(cAliasRet)->E2_PIS+(cAliasRet)->E2_CSLL) > 0)) .And.;
			!Empty((cAliasRet)->E2_FATURA)
		If 	Alltrim((cAliasRet)->E2_FATURA) != "NOTFAT"
			aAreaSe2 	:= SE2->(GetArea())

			//Procurar a fatura deste titulo.
			SE2->(Dbsetorder(6)) //FILIAL+FORNECE+LOJA+PREFIXO+NUM//+PARCELA+TIPO
			If SE2->(Dbseek( xFilial("SE2") + (cAliasRet)->E2_FATFOR + (cAliasRet)->E2_FATLOJ + (cAliasRet)->E2_FATPREF + (cAliasRet)->E2_FATURA  ))
				While !SE2->(Eof()) .And.;
						SE2->E2_FILIAL = xFilial("SE2") .And. ;
						(SE2->E2_FORNECE + SE2->E2_LOJA + SE2->E2_PREFIXO + SE2->E2_NUM) = ((cAliasRet)->E2_FATFOR + (cAliasRet)->E2_FATLOJ + (cAliasRet)->E2_FATPREF + (cAliasRet)->E2_FATURA)

					If SE2->E2_TIPO = (cAliasRet)->E2_TIPOFAT
						If !Empty(SE2->E2_BAIXA)
							lEnvia	:=	.F.
						Endif
					Endif
					SE2->(Dbskip())
				Enddo
			Endif
			RestArea(aAreaSe2)
		Else
			If Empty((cAliasRet)->E2_BAIXA)
				//se o título for uma fatura e estiver em aberto, não enviar para DIRF, pois deverá enviar as NFs que a compoe
				lEnvia	:=	.F.
			EndIf
		EndIf
	EndIf

	If !lEnvia
		(cAliasRet)->(Dbskip())
		Loop
	EndIf

	SA2->(Dbseek(xFilial("SA2")+(cAliasRet)->(E2_FORNECE+E2_LOJA)))
	//Verifico o tipo da pessoa do Fornecedor (Fisico ou Juridico.	Em branco ou X - Outros, serao verificados pelo CGC
	If Empty(SA2->A2_TIPO) .or. !(SA2->A2_TIPO $ "F/J")
		If SA2->A2_TIPO == 'X'
			cTipoFj := "2"
		ElseIf SA2->A2_IRPROG == '1'
			cTipoFj := "1"
		Else
			cTipoFj := Iif(Len(AllTrim(SA2->A2_CGC	)) > 11,"2","1")
		EndIf
	Else
		cTipoFj := IIf( SA2->A2_TIPO = "F" , "1" , If(SA2->A2_TIPO == 'J' .AND. SA2->A2_IRPROG == '1',"1","2") )
	Endif

	lPJIRPrg 	:= SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG = '1'

	lIRPFBaixa := If(SA2->A2_CALCIRF == "2", .T., .F.)

	lRetPis 	:= (SED->ED_CALCPIS == "S" .and. SA2->A2_RECPIS  == "2" )
	lRetCof 	:= (SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2" )
	lRetCSL		:= (SED->ED_CALCCSL == "S" .and. SA2->A2_RECCSLL == "2" )
	lRetIR		:= (SED->ED_CALCIRF == "S" .and. SA2->A2_CALCIRF $ "1|2" )

	lCalcIssBx :=	SA2->A2_TIPO == "J" .And. GetNewPar("MV_MRETISS","1") == "2" //Retencao do ISS pela emissao (1) ou baixa (2)

	If FindFunction( 'IsIssBx' )
		lCalcIssBx :=	IsIssBx( "P" )
	EndIf

	//Para titulos que retenham IRRF e PCC devo verificar se o código de retencao gerada foi somente para um destes impostos.
	//Retencao de PCC
	If  lRetPis .and. lRetCof .and. lRetCSL
		//If !__lPCCBaixa .OR. (__lPCCBaixa .and. (!Empty((cAliasRet)->E2_BAIXA) .or. !Empty((cAliasRet)->E2_NUMBOR )  ))
			Aadd(aCodRet,"5952")
		//EndIf
	Else
		If lRetPis
			Aadd(aCodRet,"5979")	
		EndIF
		If lRetCof
			Aadd(aCodRet,"5960")
		EndIF	
		If lRetCSL
			Aadd(aCodRet,"5987")	
		Endif
	Endif

	// Se possuir filial centralizadora, posiciona nesta filial
	If !Empty(MV_PAR06)
		SM0->(MsSeek(cEmpAnt+MV_PAR06))
		cFilAnt := MV_PAR06
	Endif

	//tratamento para fornecedor exterior sem NIF
	If !Empty(SA2->A2_PAISEX) 
		If IsCodResExt((cAliasRet)->E2_CODRET)
			lForExt := .T.
			lGeraNIF := .T.
		ElseIf SA2->A2_TIPO $ "J|X" .and. (Empty(SA2->A2_CGC) .or. SA2->A2_CGC =="00000000000000")
			lGeraNIF := .T.			
		EndIf	
		If lGeraNIF
			If Empty(SA2->A2_NIFEX)
				cNIFEX := SA2->A2_COD +  SA2->A2_LOJA
				lTemNIF := .F.
			Else
				cNIFEX := SA2->A2_NIFEX
				lTemNIF := .T.
			EndIf
		EndIf	
	EndIf

	//Retencao de IRRF
	If ( ( (cAliasRet)->E2_PRETIRF = '1') .Or. ( ((cAliasRet)->E2_PRETIRF == ' ' .Or. (cAliasRet)->E2_PRETIRF ='6')   .And. (cAliasRet)->E2_IRRF == 0 .And. (cAliasRet)->E2_VRETIRF > 0 .or.(!Empty((cAliasRet)->FKJ_COD))) ) //E2_PRETIRF = 6 borderô
		If SED->ED_CALCIRF == "S"
			If MV_PAR04 == 1 // PF
				If FKJ->(MsSeek(xFilial("FKJ") + SA2->A2_COD + SA2->A2_LOJA) )
					aCPFs := VerCPFProg(,, .T.)
					If Len(aCPFs) >= 1
						// função para verificar se existe CPF sem titulo de IR gerado
						lGrava := CPFSemRet(cAliasRet,lIRPFBaixa, aCPfs, (cAliasRet)->E2_CODRET, cTipoFj, cNIFEX, cData, @aLog,lGerLog, lTemNIF)
					EndIf	
				EndIf
			EndIf
			If Empty(aCPFs) 
				Aadd(aCodRet, (cAliasRet)->E2_CODRET )
			EndIf	
		Endif
	Endif

	//Caso titulo já tenha sido gerado não deve ser duplicado.
	//Ou se não tiver natureza que retenha o imposto (Len(aCodRet)==0 ).
	//Caso titulo já tenha sido gerado para a DIRF não deve ir novamente.
	If TMP1->(Dbseek((cAliasRet)->R_E_C_N_O_)) .and. (TMP1->(TITIPAI) .or. (lRetIR .and. !(lRetPis .and. lRetCof .and. lRetCSL) ) )
		If (Len(aCodRet)==0 .Or. (Len(aCodRet)==1 .And. Alltrim((cAliasRet)->E2_CODRET)== Alltrim(aCodRet[1])))		
			(cAliasRet)->(Dbskip())
			Loop
		ElseIf Len(aCodRet)>= 1 .and. aCodRet[1] == "5952" .and. (( (__lPCCBaixa .and. (Empty((cAliasRet)->E2_BAIXA) .or. Empty((cAliasRet)->E2_NUMBOR )  ) .and. !lF401arec) .or.;
		(!__lPCCBaixa .and. !lF401arec)) .or. (lF401arec .and. !lARec))
			//Se for PCC e o PCC ainda nao foi gerado e ja gerou o rendimento em outro imposto
			(cAliasRet)->(Dbskip())
			Loop
		ElseIf Len(aCodRet)>= 1 .and. aCodRet[Len(aCodRet)] == (cAliasRet)->E2_CODRET .and. (lIRPFBaixa .and. (Empty((cAliasRet)->E2_BAIXA) .or. Empty((cAliasRet)->E2_NUMBOR  ) ))
			//Se for IR e o IR ainda nao foi gerado e ja gerou o rendimento em outro imposto
			(cAliasRet)->(Dbskip())
			Loop
		EndIf	
	Endif

	//Caso o titulo possua retencao de IRRF e PCC mas nao tenha retido o IRRF os rendimentos jah foram gerados anteriormente.
	If Len(aCodRet) > 1 .and. (cAliasRet)->E2_VRETIRF > 0
		nPos	:= Ascan(aCodRet,(cAliasRet)->E2_CODRET)
		lExc	:=	.F.
		If nPos > 0
			If TMP1->(Dbseek((cAliasRet)->R_E_C_N_O_))
				lExc	:=	.T.
			Endif
			If lExc
				Adel(aCodRet,nPos)
				Asize(aCodRet,Len(aCodRet)-1)
			Else
				//se tiver mais de 1 imposto e nenhum foi gerado ainda, gerar somente 1 retenção
				aCodRet := {}
				Aadd(aCodRet, (cAliasRet)->E2_CODRET )
			Endif
		Endif
	Endif	

	If !lOk
		(cAliasRet)->(Dbskip())
		Loop
	Endif

	If Val(cTipoFj) == MV_PAR04	// Se for um fornecedor definido no parametro

		If !Empty(MV_PAR06) // Se possuir filial centralizadora, posiciona nesta filial
			cFilAnt := MV_PAR06
		Endif

		For nI:=1 to Len(aCodRet)

			cCdRet	:= aCodRet[nI]

			// Pesquisa cabecalho da DIRF
			If !SRL->(MsSeek(xFilial("SRL")+Padr(SM0->M0_CGC,Len(SRL->RL_CGCFONT))+ cCdRet +;
				cTipoFj+If(SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG = '1',PADR(SA2->A2_CPFIRP,14),Padr(SA2->A2_CGC,Len(SRL->RL_CPFCGC)))+ cNIFEX  ))

				Reclock("SRL", .T.)

				cRaMat := GetSxENum("SRL", "RL_MAT")

				SRL->RL_FILIAL  := xFilial("SRL")
				SRL->RL_MAT     := If(Val(SRA->RA_MAT) < 900000 .And. Val(cRaMat) < 900000, "900000",cRaMat)
				SRL->RL_CODRET  := cCdRet
				SRL->RL_TIPOFJ  := cTipoFj
				SRL->RL_CPFCGC  := If(SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG = '1',Padr(SA2->A2_CPFIRP,14),SA2->A2_CGC)
				SRL->RL_BENEFIC := Substr(SA2->A2_NOME,1,60)
				SRL->RL_ENDBENE := Alltrim(SA2->A2_END) + Alltrim(SA2->A2_NR_END)
				SRL->RL_UFBENEF := SA2->A2_EST
				SRL->RL_COMPLEM := SA2->A2_BAIRRO
				SRL->RL_CGCFONT := SM0->M0_CGC
				SRL->RL_NOMFONT := SM0->M0_NOMECOM
				SRL->RL_ORIGEM := "2"
				SRL->RL_NIFEX := cNIFEX //SA2->A2_NIFEX

				If  IsCodResExt(cCdRet)
					SRL->RL_CGCEX := SA2->A2_CGCEX
					SRL->RL_PAIS  := SA2->A2_PAISEX
					SRL->RL_NEMPR := SA2->A2_NEMPR
					SRL->RL_TPCON := SA2->A2_TPCON
					SRL->RL_DTINI := SA2->A2_DTINIR
					SRL->RL_DTFIM := SA2->A2_DTFIMR
					SRL->RL_LOGEX := SA2->A2_LOGEX
					SRL->RL_NUMEX := SA2->A2_NUMEX
					SRL->RL_COMPL := SA2->A2_COMPLR
					SRL->RL_BAIEX := SA2->A2_BAIEX
					SRL->RL_POSEX := SA2->A2_POSEX
					SRL->RL_CIDEX := SA2->A2_CIDEX
					SRL->RL_ESTEX := SA2->A2_ESTEX
					SRL->RL_TELEX := SA2->A2_TELRE
					SRL->RL_BREEX := SA2->A2_BREEX
					SRL->RL_TPREX := SA2->A2_TPREX
					SRL->RL_TRBEX := SA2->A2_TRBEX
					If !lTemNIF
						If SA2->A2_MOTNIF == "1"                                                                         
							SRL->RL_BEDINI := "1" //Fornecedor dispensado do NIF   
							SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
						Elseif SA2->A2_MOTNIF == "2"             
							SRL->RL_PAEXNI := "2" //País do fornecedor nao exige NIF   
						Endif
					Else
						SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
					Endif				
				EndIf
				SRL->(MsUnlock())
			Endif	

			// Se for pela data baixa e nao houve o pagamento, considerar data E2_EMIS1
			If MV_PAR01 == 4 .and. STRZERO(MONTH((cAliasRet)->&(cData)),2) == "00"
				cData := "E2_EMIS1"
			EndIf

			// Se existir o ano na chave do SR4
			// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
			cChaveSr4 := xFilial("SR4")+ SRL->RL_MAT+ SRL->RL_CPFCGC + cCdRet + STRZERO(YEAR((cAliasRet)->&cData),4) + STRZERO(MONTH((cAliasRet)->&cData),2)

			// Gera valor do Rendimento
			nRendTributavel	:=	(cAliasRet)->E2_VALOR

			If (cAliasRet)->E2_PRETPIS = '1' .And. (cAliasRet)->E2_PRETCOF = '1' .And. (cAliasRet)->E2_PRETCSL = '1'
				If (cAliasRet)->E2_SALDO == 0 .And. !Empty((cAliasRet)->E2_BAIXA) //Trata-se da ultima baixa.
					nRendTributavel	+=	(cAliasRet)->E2_VRETPIS + 	(cAliasRet)->E2_VRETCOF + 	 (cAliasRet)->E2_VRETCSL
				Endif
			ElseIf Empty((cAliasRet)->E2_PRETPIS) 	.and. Empty((cAliasRet)->E2_PRETCOF) .and. Empty((cAliasRet)->E2_PRETCSL)
				If !__lPccBaixa
					nRendTributavel += (cAliasRet)->E2_PIS + (cAliasRet)->E2_COFINS + (cAliasRet)->E2_CSLL
				EndIf
			Endif

			nRendTributavel	+=	(cAliasRet)->E2_INSS

			If !lIRPFBaixa
				nRendTributavel	+=	(cAliasRet)->E2_IRRF
			Endif

			If !lCalcIssBx
				nRendTributavel	+=	(cAliasRet)->E2_ISS
			Endif

			lGrava	:=	 .F.

			// Tipo do rendimento considera tipo da entidade
			If lTpEnt
				If Empty((cAliasRet)->A2_TPENT)
					cTpRen := "A"
				Else
					If (cAliasRet)->A2_TPENT == "1"	 // Fornecedores Imunes
						cTpRen := "I2"
					ElseIf (cAliasRet)->A2_TPENT == "2"  // Fornecedores Isentos
						cTpRen := "I3"
					EndIf
				EndIf
			Else
				cTpRen := "A"
			EndIf

			If !SR4->( MsSeek( cChaveSr4 + padr(cTpRen,nTamTpRen) +SRL->RL_PAIS + SRL->RL_NIFEX ))

				If nRendTributavel > 0

					Reclock("SR4", .T.)

					SR4->R4_FILIAL  := xFilial("SR4")
					SR4->R4_MAT     := SRL->RL_MAT
					SR4->R4_CPFCGC  := SRL->RL_CPFCGC
					SR4->R4_MES     := STRZERO(MONTH((cAliasRet)->&(cData)),2)
					SR4->R4_TIPOREN := cTpRen
					SR4->R4_CODRET  := cCdRet
					SR4->R4_ANO  := STRZERO(YEAR((cAliasRet)->&(cData)),4)
					SR4->R4_VALOR   := nRendTributavel
					SR4->R4_ORIGEM := "2"
					SR4->R4_PAIS 	:= SRL->RL_PAIS
					SR4->R4_NIFEX := SRL->RL_NIFEX

					If !Empty(SRL->RL_PAIS) .And. IsCodResExt(SRL->RL_CODRET)
						SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
						If lISNIF
							SR4->R4_ISNIF := Iif(lTemNIF,"1","2")
						EndIf
					EndIf

					SR4->(MsUnlock())

					Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCdRet , STRZERO(MONTH((cAliasRet)->&(cData)),2) 	, "A",;
												(cAliasRet)->E2_FILIAL,(cAliasRet)->E2_PREFIXO, (cAliasRet)->E2_NUM, (cAliasRet)->E2_PARCELA,;
												(cAliasRet)->E2_TIPO,(cAliasRet)->E2_NATUREZ, nRendTributavel, cNIFEX )

					lGrava	:=	 .T.
				EndIf
			Else
				Reclock("SR4", .F.)
				SR4->R4_VALOR   += nRendTributavel
				SR4->(MsUnlock())

				Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCdRet , STRZERO(MONTH( (cAliasRet)->&(cData)),2) 	, "A",;
													(cAliasRet)->E2_FILIAL,(cAliasRet)->E2_PREFIXO, (cAliasRet)->E2_NUM, (cAliasRet)->E2_PARCELA,;
													(cAliasRet)->E2_TIPO,(cAliasRet)->E2_NATUREZ, nRendTributavel, cNIFEX )

				lGrava	:=	 .T.
			Endif
		
			//Restauro a filial do sistema quando processar com filial centralizadora
			If !Empty(MV_PAR06)
				cFilAnt := cFilAtu
			Endif
		Next

		If	lGrava
			Reclock("TMP1", .T.)
			TMP1->NROREG 		:= (cAliasRet)->R_E_C_N_O_
			TMP1->TITIPAI		:= .F.
			TMP1->(MSUNLOCK())

			Reclock("TMP", .T.)
			TMP->NROREG 		:= (cAliasRet)->R_E_C_N_O_
			TMP1->TITIPAI		:= .F.
			TMP->(MSUNLOCK())
		Endif
		Aadd(aRecno, (cAliasRet)->R_E_C_N_O_)
	Endif

	(cAliasRet)->(DbSkip())

	If !Empty(MV_PAR06) // Se possuir filial centralizadora, posiciona nesta filial
		cFilAnt := cFilAtu
	Endif
Enddo

If !Empty(MV_PAR06) // Restauro a filial do sistema quando processar com filial centralizadora.
	cFilAnt := cFilAtu
Endif

If TMP->(Eof()) .And. lReproc//Faz a exclusao das datas da dirf no caso de reprocessamento.
	aAreaSE2 := SE2->(GetArea())
	While !(TMP->(Eof()))
		SE2->(Dbgoto(TMP->NROREG))
		SE2->(RecLock())
		SE2->E2_DTDIRF := Ctod("  /  /  ")
		SE2->(MsUnlock())
		TMP->(DbSkip())
	EndDo
	SE2->(RestArea(aAreaSE2))
Endif

TMP->(DbCloseArea())
(cAliasRet)->(DBCloseArea())

//Deleta tabela temporária no banco de dados, caso exista
If _oFINA4012 <> Nil
	_oFINA4012:Delete()
	_oFINA4012 := Nil
Endif

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CriaTMPºAutor  ³  Totvs             º Data ³  07/08/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Cria tabela temporaria para armazenar registro conciliados, º±±
±±º          ³não conciliadas evitando ascan em array                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function CriaTMP(aCampos,cArq,cAlias,cArqINDEX,cChave)
Local aSaveArea	:= GetArea()

If ALLTRIM(cAlias) == "TMP1"

	If Select(cAlias) > 0
		(cAlias)->(DbCloseArea())
	EndIf

	//------------------
	//Criação da tabela temporaria
	//------------------
	If _oFINA4011 <> Nil
		_oFINA4011:Delete()
		_oFINA4011 := Nil
	Endif

	_oFINA4011 := FWTemporaryTable():New( cAlias )
	_oFINA4011:SetFields(aCampos)
	_oFINA4011:AddIndex("1", {cChave})
	_oFINA4011:Create()

Else

	If Select(cAlias) > 0
		(cAlias)->(DbCloseArea())
	EndIf

	//------------------
	//Criação da tabela temporaria
	//------------------
	If _oFINA4012 <> Nil
		_oFINA4012:Delete()
		_oFINA4012 := Nil
	Endif

	_oFINA4012 := FWTemporaryTable():New( cAlias )
	_oFINA4012:SetFields(aCampos)
	_oFINA4012:AddIndex("1", {cChave})
	_oFINA4012:Create()

Endif

RestArea( aSaveArea )

Return nil

Static Function f401LimpaDt(cTipoIn,lErroUpd)
Local cQuery := ""
Local cUpdate := ""
Local cCompSA2 := FWModeAccess( "SA2" , 1 ) + FWModeAccess( "SA2" , 2 ) + FWModeAccess( "SA2" , 3 )
Local nTamFilSA2 := If( "E" $ cCompSA2, Len(Alltrim(xFilial("SA2"))) , 0 )


cQuery += " LEFT JOIN " + RetSqlName("SE2") +" PAI ON "
cQuery += " (SE2.E2_FILIAL = PAI.E2_FILIAL AND "
If "MYSQL" $ cBDname
	cQuery += cQryConcat+" PAI.E2_PREFIXO,PAI.E2_NUM,PAI.E2_PARCELA,PAI.E2_TIPO,PAI.E2_FORNECE,PAI.E2_LOJA) = SE2.E2_TITPAI AND "
ElseIf cBDname $ "DB2|POSTGRES|MSSQL"  .OR. ( cBDname == "DB2/400" .And. Upper(cSrvType) == "ISERIES" )
	cQuery += " PAI.E2_PREFIXO = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI ,1," +STR(nTamPref) + "))"
	cQuery += " AND PAI.E2_NUM = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI ,"+STR(nTamPref+1) +"," + STR(nTamNum) + "))"
	cQuery += " AND PAI.E2_PARCELA =  RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI ,"+STR(nTamPref+nTamNum+1)+","+STR(nTamPar)+"))"
	cQuery += " AND PAI.E2_TIPO = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI ,"+STR(nTamPref+nTamNum+nTamPar+1)+","+STR(nTamTipo)+"))"
	cQuery += " AND PAI.E2_FORNECE = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI,"+STR(nTamPref+nTamNum+nTamPar+nTamTipo+1)+","+STR(nTamFor)+"))"
	cQuery += " AND PAI.E2_LOJA = RTRIM(" + Iif(cBDname $ "DB2|POSTGRES","SUBSTR","SUBSTRING") + "(SE2.E2_TITPAI,"+STR(nTamPref+nTamNum+nTamPar+nTamTipo+nTamFor+1)+","+STR(nTamLj)+")) AND"

Else
	cQuery += " PAI.E2_PREFIXO" +cQryConcat+"PAI.E2_NUM"+cQryConcat+"PAI.E2_PARCELA"+cQryConcat+"PAI.E2_TIPO"+cQryConcat+"PAI.E2_FORNECE"+cQryConcat+"PAI.E2_LOJA = SE2.E2_TITPAI AND "
EndIf
If !Empty(cTipoIn)
	cQuery += " PAI.E2_TIPO NOT IN " + cTipoIn + " AND "
EndIf
cQuery += " PAI.D_E_L_E_T_= ' ' )"

cQuery += " JOIN " +  RetSqlName("SA2") + " SA2 ON "
cQuery += "(PAI.E2_FORNECE = SA2.A2_COD AND PAI.E2_LOJA = SA2.A2_LOJA AND SA2.D_E_L_E_T_ = ' ' "
If nTamFilSA2 > 0
		If cBDname $ "ORACLE|DB2|POSTGRES|INFORMIX"
		cQuery += " AND SUBSTR(SA2.A2_FILIAL,1," +str(nTamFilSA2) +" ) = SUBSTR(PAI.E2_FILORIG,1,"+str(nTamFilSA2)+") "
	Else
		cQuery += " AND SUBSTRING(SA2.A2_FILIAL,1,"+str(nTamFilSA2)+") = SUBSTRING(PAI.E2_FILORIG,1,"+str(nTamFilSA2)+") "
	EndIf
EndIf

If MV_PAR04 == 1 //Fisico
	//Se for PJ com IR Progressivo, será tratado como Pessoa Física.
	cQuery +=	" AND (SA2.A2_TIPO = 'F' OR (SA2.A2_TIPO = 'J' AND SA2.A2_IRPROG = '1')) "
Else
	cQuery +=	" AND (SA2.A2_TIPO = 'X' OR (SA2.A2_TIPO = 'J' AND SA2.A2_IRPROG != '1')) "
Endif
cQuery += ") "


cQuery += " WHERE "
If MV_PAR08 <> 1
	cQuery += " SE2.E2_FILIAL = '" + cFilAnt + "' AND "
Endif

cQuery += "   SE2.E2_DIRF IN ('1','S','2') AND "
cQuery += "   SE2.E2_CODRET != ' ' AND "
If !Empty(cTipoIn)
	cQuery += " SE2.E2_TIPO IN " + cTipoIn + " AND "
EndIf

Do Case
	Case MV_PAR01 == 1 // Data de emissao digitada
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
		EndIf
	Case MV_PAR01 == 2// Vencimento
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_VENCTO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
		Endif

	Case MV_PAR01 == 3 //Vencimento real
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_VENCREA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
		Endif

	Case MV_PAR01 == 4 //Data de Baixa
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND ((SE2.E2_BAIXA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
			cQuery += " (SE2.E2_BAIXA = ' ' AND "
			cQuery += " SE2.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) ) ) OR "
		EndIf

	Case MV_PAR01 == 5 // Data de emissao real
		If MV_PAR05 == 2
			cQuery += "(( SE2.E2_NATUREZ NOT IN " + cPccTit
			cQuery += " AND SE2.E2_EMISSAO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ) OR"
		EndIf
EndCase

Do Case
	Case MV_PAR09 == 1 // Data de emissao
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_EMIS1 BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) "
		EndIf

	Case MV_PAR09 == 2// Vencimento
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_VENCTO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) "
		Endif

	Case MV_PAR09 == 3 //Vencimento real
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND SE2.E2_VENCREA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' )) "
		Endif

	Case MV_PAR09 == 4 //Data de Baixa
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND (SE2.E2_BAIXA BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ))) "
		EndIf

	Case MV_PAR09 == 5 //Data de Emissao Real
		If MV_PAR05 == 2
			cQuery += "( SE2.E2_NATUREZ IN " + cPccTit
			cQuery += " AND (SE2.E2_EMISSAO BETWEEN '" + Dtos(MV_PAR02) + "' AND '" + Dtos(MV_PAR03) + "' ))) "
		EndIf
EndCase

IF MV_PAR05 == 2
  	cQuery += " AND SE2.D_E_L_E_T_ = ' '"
Else
  	cQuery += " SE2.D_E_L_E_T_ = ' '"
Endif


cUpdate := "UPDATE " + RetSqlName("SE2")  + " SET E2_DTDIRF = ' ' "
cUpdate += "WHERE R_E_C_N_O_ IN(  SELECT PAI.R_E_C_N_O_  FROM " + RetSqlName("SE2") + " SE2 "
cUpdate += cQuery + ")"
If TcSqlExec(cUpdate) <> 0
	MsgStop( "Erro ao limpar registros Pai: " + TCSQLError() )
	lErroUpd := .T.
EndIf


cUpdate := "UPDATE " + RetSqlName("SE2")  + " SET E2_DTDIRF = ' ' "
cUpdate += "WHERE R_E_C_N_O_ IN(  SELECT SE2.R_E_C_N_O_  FROM " + RetSqlName("SE2") + " SE2 "
cUpdate += cQuery + ")"
If TcSqlExec(cUpdate) <> 0
	MsgStop( "Erro ao limpar registros: " + TCSQLError() )
	lErroUpd := .T.
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RetValCMPºAutor  ³  Karen Honda       º Data ³  14/12/16    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna o valor compensado do titulo.                       ¹±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function RetValCMP(cAliasPai, lImpEmissao,lIrBx,lCalcIssBx,nImpEmis)
Local nSomaBxPA := 0
Local aAreaSE2 := SE2->(GetArea())
Local nImpEmisPa := 0
Local lBaixaTotNF := .F.
Local cPrefixo := (cAliasPai)->E2_PREFIXO
Local cNum := (cAliasPai)->E2_NUM
Local cParcela := (cAliasPai)->E2_PARCELA
Local cTipo := (cAliasPai)->E2_TIPO
Local cFornece := (cAliasPai)->E2_FORNECE
Local cLoja := (cAliasPai)->E2_LOJA
Local nValorTotPA	:= 0
Local nProp	:= 0
Local nPropImpEmis := 0
Local nRecSe5NF := 0
Local lCheqLib := .F.
Local nTotSomaBx := 0

Default lImpEmissao := .F.

nImpEmis := 0
If cTipo $ MVPAGANT
	nValorTotPA := (cAliasPai)->E2_VALOR
	If !__lPaBruto

		nValorTotPA += (cAliasPai)->(E2_INSS+ E2_PRINSS)
		nValorTotPA += (cAliasPai)->(E2_ISS+ E2_PRISS)
		nValorTotPA += (cAliasPai)->(E2_PIS+E2_COFINS+E2_CSLL)
		nValorTotPA += (cAliasPai)->(E2_IRRF)

	EndIf
EndIf

SE2->(DBSetOrder(1))
SE5->(DBSetOrder(7)) //E5_FILIAL, E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_CLIFOR, E5_LOJA, E5_SEQ, R_E_C_N_O_, D_E_L_E_T_
If SE5->(DbSeek(xFilial("SE5") + cPrefixo + cNum + cParcela + cTipo + cFornece + cLoja ))

	While SE5->(!Eof()) .and. SE5->(E5_FILIAL+ E5_PREFIXO+ E5_NUMERO+ E5_PARCELA+ E5_TIPO+ E5_CLIFOR+ E5_LOJA) == xFilial("SE5") + cPrefixo + cNum + cParcela + cTipo + cFornece + cLoja
		If !SE5->E5_SITUACA $ ( 'C' , 'E' , 'X' ) .AND. SE5->E5_TIPODOC <> 'ES' .and. !TemBxCanc2()
			nPropImpEmis := 0
			If !cTipo $ MVPAGANT
	 			// Se for NF, verifica se houve compensacao com alguma PA e retorna o valor compensado
				If SE5->E5_MOTBX == 'CMP' .and. SE5->E5_TIPODOC $ 'CP|BA|VL'
					nSomaBxPA += SE5->(E5_VALOR)


					nSomaBxPA += SE5->(E5_VRETPIS + E5_VRETCOF+E5_VRETCSL+E5_VRETIRF)

					//Verificar se houve uma compensacao total, se sim, soma os impostos da emissao

					If (cAliasPai)->E2_SALDO == 0
						nImpEmisPa := 0
						nImpEmisPa += (cAliasPai)->(E2_INSS+ E2_PRINSS)

						If !lCalcIssBx
							nImpEmisPa += (cAliasPai)->(E2_ISS+ E2_PRISS)
						EndIf
						If !__lPccBaixa
							nImpEmisPa += (cAliasPai)->(E2_PIS+E2_COFINS+E2_CSLL)
						EndIf
						If !lIrBx
							nImpEmisPa += (cAliasPai)->(E2_IRRF)
						EndIf

						//se foi a ultima baixa soma os impostos da emissao
						If IsTheLastPost((cAliasPai)->E2_PREFIXO,(cAliasPai)->E2_NUM,(cAliasPai)->E2_PARCELA,(cAliasPai)->E2_TIPO,(cAliasPai)->E2_FORNECE,(cAliasPai)->E2_LOJA)
							nSomaBxPA += nImpEmisPa
							lBaixaTotNF := .T.
						Else
							nSomaBxPA := 0
						EndIf
					Else
						nSomaBxPA := 0
					EndIf

					//Se nao for baixa total , procura o PA com o qual foi compensado para ver se houve baixa total da PA
					If !lBaixaTotNF .and. SE2->(DBSeek(xFilial("SE2")+ Rtrim(SE5->E5_DOCUMEN)))

						nValorTotPA := SE2->E2_VALOR

						If !__lPaBruto

							nImpEmisPa := 0
							nImpEmisPa += SE2->(E2_INSS+ E2_PRINSS)
							nImpEmisPa += SE2->(E2_ISS+ E2_PRISS)
							nImpEmisPa += SE2->(E2_PIS+E2_COFINS+E2_CSLL)
							nImpEmisPa += SE2->(E2_IRRF)

							nValorTotPA += 	nImpEmisPa

						EndIf

						//localiza a SE5 da compensacao da PA
						nRecSe5NF := SE5->(Recno())
						If SE5->(DBSeek(xFilial("SE5")+ SE2->(E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA ) + SE5->E5_SEQ ))

							nSomaBxPA += SE5->(E5_VALOR)

							//pega a proporcao para obter o valor do INSS e ISS proporcional, pois o mesmo nao eh gravado na SE5 e nem na SE2
							If SE2->E2_IRRF > 0
								nProp := (SE5->E5_VRETIRF/SE2->E2_IRRF)
							ElseIf (cAliasPai)->E2_PIS > 0
								nProp := (SE5->E5_VRETPIS/SE2->E2_PIS)
							EndIf


							If !__lPaBruto
								nPropImpEmis += SE2->(E2_INSS+E2_PRINSS) * nProp
								nPropImpEmis += SE2->(E2_ISS+E2_PRISS) * nProp

								nImpEmis +=  nPropImpEmis
								//nSomaBxPA += nPropImpEmis
								nSomaBxPA += SE5->(E5_VRETPIS + E5_VRETCOF+E5_VRETCSL+E5_VRETIRF )
							EndIf

							//se a baixa foi total da PA, reomponho o valor dos impostos da emissao
							If SE2->E2_SALDO == 0 .and. nSomaBxPA +If(!__lPaBruto, nPropImpEmis ,0)== nValorTotPA
								nSomaBxPA += nPropImpEmis
							Else
								nImpEmis := 0

								If __lPccBaixa
									nImpEmis += SE5->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)
								EndIf
								If lIrBx
									nImpEmis += SE5->E5_VRETIRF
								EndIf
							EndIf
						EndIf
						SE5->(DBGoto(nRecSe5NF))
					EndIf

					nTotSomaBx += nSomaBxPA
				EndIf
			Else

				//se imposto for na emissao, sera gerado na NF, logo se a PA for compensada, deve ser desconsiderada
				If lImpEmissao
					If SE5->E5_MOTBX == 'CMP' .AND. SE5->E5_TIPODOC $ 'CP|BA|VL'
						nSomaBxPA += SE5->E5_VALOR

						//faz a regra de 3 para achar a proporcao para pegar o valor do ISS e INSS descontado do saldo
						//pois este valor nao sao gravados na compensacao
						nProp := 0
						If (cAliasPai)->E2_IRRF > 0
							nProp := (SE5->E5_VRETIRF/(cAliasPai)->E2_IRRF)
						ElseIf (cAliasPai)->E2_PIS > 0
							nProp := (SE5->E5_VRETPIS/(cAliasPai)->E2_PIS)
						EndIf

						If !__lPaBruto
							nPropImpEmis += (cAliasPai)->(E2_INSS+E2_PRINSS) * nProp
							nPropImpEmis += (cAliasPai)->(E2_ISS+E2_PRISS) * nProp

						EndIf
						//verifica se houve compensacao total
						If (cAliasPai)->E2_SALDO == 0 .and. SE5->(E5_VALOR+ E5_VRETPIS + E5_VRETCOF+E5_VRETCSL+E5_VRETIRF) +If(!__lPaBruto, nPropImpEmis ,0)== nValorTotPA
							nSomaBxPA += nPropImpEmis
							nSomaBxPA += SE5->( E5_VRETPIS + E5_VRETCOF+E5_VRETCSL+E5_VRETIRF)
						EndIf

					EndIf
				EndIf

				//se for PA verifica se PA foi baixada sem ser por compensacao, o que significa o seu cancelamento
				//e retorna o valor da baixa
				If SE5->E5_MOTBX <> 'CMP' .AND. SE5->E5_TIPODOC $ 'VL'
					If (cAliasPai)->E2_SALDO == 0 .and. SE5->E5_VALOR == (cAliasPai)->E2_VALOR
						nSomaBxPA := nValorTotPA
					EndIf

				Else

					//Verifica se houve movimentacao bancaria para envio da pa
					If (SE5->E5_TIPODOC $ "BA/CH" .And. !Empty(SE5->E5_NUMCHEQ) .And. SubStr(SE5->E5_NUMCHEQ,1,1) <> "*") .OR. SE5->E5_TIPODOC $ "VL"
						lCheqLib := .T.
					EndIf

					If SE5->E5_TIPODOC $ "PA"
						lCheqLib	:= .T.
					EndIf

				Endif

				nTotSomaBx += nSomaBxPA
			EndIf

		EndIf
		SE5->(DBSkip())
	EndDo
EndIf
//nao houve movimentacao bancaria da PA, nao enviar
If cTipo $ MVPAGANT .and. !lCheqLib
	nTotSomaBx := nValorTotPA
EndIf
nImpEmis := abs(nImpEmis)
RestArea(aAreaSE2)
Return nTotSomaBx

//-------------------------------------------------------------------
/*/{Protheus.doc} ValRenPCC
Retorna valor de rendimento do PCC
@author Igor Sousa do Nascimento
@since  05/01/2018
/*/
//-------------------------------------------------------------------
Function ValRenPCC( cAlias1, cAlias2, aUltPCC, cSeqBX, lRendIR )

Local aArea		:= GetArea()
Local aAlias1	:= {}
Local aAreaTRB	:= {}
Local aBaixas	:= {}
Local lConsVA	:= SuperGetMv("MV_IMPBAIX",.T.,"2") == "1"
Local lRetEmis	:= .F.
Local nValRend	:= 0

Local nX		:= 0

Local nProp		:= 1
Local nValOri	:= 0
Local lUltBx	:= .F.

Default cAlias1	:= Alias()
Default cAlias2	:= cAlias1
Default cSeqBX	:= ""
Default lRendIR	:= .F.


aAlias1	 := (cAlias1)->( GetArea() )
If !lRendIR
	aAreaTRB := (cAlias2)->( GetArea() )

	DbSelectArea(cAlias1)
	(cAlias1)->( DbSetOrder(1) )
EndIf	
DbSelectArea("SE5")
SE5->( DbSetOrder(1) )

aBaixas := GetPosts( xFilial("SE5", (cAlias1)->E2_FILORIG),;
					(cAlias1)->E2_PREFIXO,;
					(cAlias1)->E2_NUM,;
					(cAlias1)->E2_PARCELA,;
					(cAlias1)->E2_TIPO,;
					(cAlias1)->E2_FORNECE,;
					(cAlias1)->E2_LOJA,;
					"SE5.E5_TIPODOC IN ('VL','BA','CP')")

// Verifica se a ultima baixa teve seu valor abatido de retencao de imposto de baixas anteriores
If Len(aBaixas) > 0
	For nX := 1 to Len(aBaixas)

		SE5->(dbGoTo(aBaixas[nX]))
		//desconsidera o registro de IR gerado na baixa pelo bordero, pois está somando o valor do IR 2x
		If AllTrim(SE5->E5_MOTBX) $ "IRF|ISS" .and. AllTrim(SE5->E5_ORIGEM) $ "FINA241|FINA750"
			Loop
		EndIf
		lUltBx := .F.
		If Empty(cSeqBX) .or. (!EMPTY(cSeqBX) .AND. SE5->E5_SEQ == cSeqBX)
			lUltBx := (cAlias1)->E2_SALDO == 0 .and. IsTheLastPost(SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA)
			
			If __lPccBaixa
				If SE5->E5_VRETPIS+SE5->E5_VRETCOF+SE5->E5_VRETCSL > 0
					If AllTrim(SE5->E5_MOTBX) $ "PCC" .and. AllTrim(SE5->E5_ORIGEM) $ "FINA241|FINA590|FINA750" 	// PCC gerado no bordero de impostos
						If !Empty(aAreaTRB)
							RestArea(aAreaTRB)
						EndIf
						nValRend += (cAlias1)->E2_VALOR
						If !lIrBx
							nValRend += (cAlias1)->E2_IRRF
						EndIf
						If !lCalcIssBx
							nValRend += (cAlias1)->E2_ISS
						EndIf
						nValRend += (cAlias1)->E2_INSS
						nX++
						Exit
					Else
						If __lValPgto 
							nValRend += SE5->E5_VRETPIS+SE5->E5_VRETCOF+SE5->E5_VRETCSL
						ElseIf lUltBx
							nValRend += (cAlias1)->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL)
						EndIf
					EndIf
				EndIf
			Else
				nValRend += (cAlias1)->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL)
			EndIf
			nValRend += SE5->E5_VALOR
			If lIrBx
				If __lValPgto 
					nValRend += SE5->E5_VRETIRF
				ElseIf lUltBx
					nValRend += (cAlias1)->E2_VRETIRF
				EndIf
			ElseIf lUltBx .or. !__lPccBaixa
				If SA2->A2_MINIRF == "1" .Or. (cAlias1)->E2_IRRF > GetMv("MV_VLRETIR") .or. ;
					 ((cAlias1)->E2_IRRF == (cAlias1)->E2_VRETIRF .and. !Empty((cAlias1)->E2_PARCIR ) )
					nValRend += (cAlias1)->E2_IRRF
				EndIf
			EndIf
			If lCalcIssBx
				If __lValPgto 
					nValRend += SE5->E5_VRETISS
				ElseIf 	lUltBx
					nValRend += (cAlias1)->E2_ISS
				EndIf
			ElseIf lUltBx
				nValRend += (cAlias1)->E2_ISS
			EndIf
			If lUltBx
				nValRend += (cAlias1)->E2_VRETINS
			EndIf	
			nValRend += SE5->E5_VLCORRE
			If !lConsVA
				If Upper(SE5->E5_TPDESC) == "I" .or. (cAlias1)->E2_DECRESC > 0
					nValRend += SE5->E5_VLDESCO
				EndIf
				nValRend -= SE5->E5_VLJUROS
				nValRend -= SE5->E5_VLMULTA
			EndIf

			//Se for uma fatura, verifica se foi a ultima baixa para pegar o rendimento correto
			If Alltrim((cAlias1)->E2_FATURA) == "NOTFAT" .and. lUltBx
				If Alltrim((cAlias2)->E2_NATUREZ) $ cMVPISNAT
					nValRend += (cAlias1)->E2_BASEPIS - (cAlias1)->E2_VALOR
				ElseIf Alltrim((cAlias2)->E2_NATUREZ) $ cMVCOFNAT
					nValRend += (cAlias1)->E2_BASECOF - (cAlias1)->E2_VALOR
				ElseIf Alltrim((cAlias2)->E2_NATUREZ) $ cMVCSLNAT
					nValRend += (cAlias1)->E2_BASECSL - (cAlias1)->E2_VALOR
				ElseIf lRendIR 
					nValRend += (cAlias1)->E2_BASEIRF - (cAlias1)->E2_VALOR
				EndIf
			EndIf

			If !lRetEmis .and. !lRendIR	// Desposiciona SE2 para nao contar os impostos da emissao novamente se houver + baixas
				aAreaTRB := (cAlias1)->(GetArea())
				(cAlias1)->(dbGoBottom())
				(cAlias1)->(dbSkip())
				lRetEmis := .T.
			EndIf

		EndIf
	Next nX
	If !lRendIR .and. ValType(aUltPCC) == "A"
		Aadd(aUltPCC,Alltrim((cAlias2)->E2_CODRET) + SE5->(E5_FILIAL + E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA))
	EndIf
	If !Empty(aAreaTRB)
		RestArea(aAreaTRB)
	EndIf	
	nValOri := (cAlias1)->E2_VALOR
	
	//Recompoe valor original com impostos na emissão
	nValOri += Iif(!lCalcIssBx, (cAlias1)->E2_ISS, 0)
	nValOri += Iif(!lIrBx, (cAlias1)->E2_IRRF, 0)
	nValOri += Iif(!__lPccBaixa,  (cAlias1)->(E2_PIS+E2_COFINS+E2_CSLL), 0)
	nValOri += (cAlias1)->E2_INSS
	//Aplica a proporcionalidade da base do pcc sobre o valor pago
	If Alltrim((cAlias2)->E2_NATUREZ) $ cMVPISNAT
		nProp := (cAlias1)->E2_BASEPIS / nValOri
	ElseIf Alltrim((cAlias2)->E2_NATUREZ) $ cMVCOFNAT
		nProp := (cAlias1)->E2_BASECOF / nValOri
	ElseIf Alltrim((cAlias2)->E2_NATUREZ) $ cMVCSLNAT
		nProp := (cAlias1)->E2_BASECSL / nValOri
	ElseIf 	lRendIR
		nProp := (cAlias1)->E2_BASEIRF / nValOri
	EndIf

	nValRend := nValRend * nProp

Else
	If !lIrBx
		nValRend += (cAlias1)->E2_VRETIRF
	EndIf
	If !__lPccBaixa
		nValRend += (cAlias1)->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL)
	EndIf
	If !lCalcIssBx
		nValRend += (cAlias1)->E2_VRETISS
	EndIf
	nValRend += (cAlias1)->E2_VRETINS
	nValRend += (cAlias1)->E2_SEST
	nValRend += (cAlias1)->E2_RETENC
	nValRend += (cAlias1)->E2_VALOR
	// Verifica base reduzida
	If nValRend <> (cAlias1)->E2_BASEPIS .and. (cAlias1)->E2_VRETPIS > 0 .and. (cAlias1)->E2_BASEPIS > 0
		nValRend := (cAlias1)->E2_BASEPIS
	ElseIf nValRend <> (cAlias1)->E2_BASECOF .and. (cAlias1)->E2_VRETCOF > 0 .and. (cAlias1)->E2_BASECOF > 0
		nValRend := (cAlias1)->E2_BASECOF
	ElseIf nValRend <> (cAlias1)->E2_BASECSL .and. (cAlias1)->E2_VRETCSL > 0 .and. (cAlias1)->E2_BASECSL > 0
		nValRend := (cAlias1)->E2_BASECSL
	ElseIf lIrBx .and. nValRend <> (cAlias1)->E2_BASEIRF
		nValRend := (cAlias1)->E2_BASEIRF
	EndIf
EndIf

RestArea(aArea)
RestArea(aAlias1)

Return nValRend


//-------------------------------------------------------------------
/*/{Protheus.doc} GetPosts
Retorna array com recnos das baixas de um titulo
@param cChave - Chave unica do titulo
@param cFiltro - Filtro para baixas especificas
@author Igor Sousa do Nascimento
@since  05/01/2018
/*/
//-------------------------------------------------------------------
Static Function GetPosts(cXFilial,cPrefixo,cNum,cParcela,cTipo,cFornec,cLoja,cFiltro)

	Local aArea    := GetArea()
	Local aBaixas  := {}
	Local cTmp	   := CriaTrab(,.F.)
	Local cQuery   := ""

	Default cXFilial := ""
	Default cPrefixo := ""
	Default cNum 	 := ""
	Default cParcela := ""
	Default cTipo 	 := ""
	Default cFornec  := ""
	Default cLoja    := ""
	Default cFiltro  := ""

	If Empty(cXFilial) .and. Empty(cPrefixo) .and. Empty(cNum) .and.; 
		Empty(cParcela) .and. Empty(cTipo) .and. Empty(cFornec) .and. Empty(cLoja)
		If "SE2" $ Alias()
			cXFilial := xFilial("SE2")
			cPrefixo := E2_PREFIXO
			cNum 	 := E2_NUM
			cParcela := E2_PARCELA
			cTipo 	 := E2_TIPO
			cFornec  := E2_FORNECE
			cLoja 	 := E2_LOJA
		ElseIf "SE5" $ Alias()
			cXFilial := xFilial("SE5")
			cPrefixo := E5_PREFIXO
			cNum 	 := E5_NUMERO
			cParcela := E5_PARCELA
			cTipo 	 := E5_TIPO
			cFornec  := E5_CLIFOR
			cLoja 	 := E5_LOJA
		EndIf
	EndIf
	cQuery := "SELECT SE5.R_E_C_N_O_ RECNOBX "
	cQuery += "FROM " + RetSqlName("SE5") + " SE5 "
	cQuery += "WHERE "
	cQuery += "SE5.E5_FILIAL = '" + cXFilial + "' "
	cQuery += "AND SE5.E5_PREFIXO = '" + cPrefixo + "' "
	cQuery += "AND SE5.E5_NUMERO = '" + cNum + "' "
	cQuery += "AND SE5.E5_PARCELA = '" + cParcela + "' "
	cQuery += "AND SE5.E5_TIPO = '" + cTipo + "' "
	cQuery += "AND SE5.E5_CLIFOR = '" + cFornec + "' "
	cQuery += "AND SE5.E5_LOJA = '" + cLoja + "' "
	If !Empty(cFiltro)
		cQuery += "AND " + cFiltro
	EndIf
	cQuery += " AND SE5.E5_SITUACA NOT IN ( 'C' , 'E' , 'X' ) "
	cQuery += "AND SE5.E5_NUMERO NOT IN ( "
	cQuery += 			"SELECT SUBSE5.E5_NUMERO FROM " + RetSqlName("SE5") + " SUBSE5 "
	cQuery +=			"WHERE SUBSE5.E5_FILIAL = SE5.E5_FILIAL "
	cQuery += 			"AND SUBSE5.E5_PREFIXO = SE5.E5_PREFIXO "
	cQuery += 			"AND SUBSE5.E5_NUMERO = SE5.E5_NUMERO "
	cQuery += 			"AND SUBSE5.E5_PARCELA = SE5.E5_PARCELA "
	cQuery += 			"AND SUBSE5.E5_TIPO = SE5.E5_TIPO "
	cQuery += 			"AND SUBSE5.E5_CLIFOR = SE5.E5_CLIFOR "
	cQuery += 			"AND SUBSE5.E5_LOJA = SE5.E5_LOJA "
	cQuery += 			"AND SUBSE5.E5_TIPODOC = 'ES' "
	cQuery += 			"AND SUBSE5.E5_SEQ = SE5.E5_SEQ "
	cQuery += 			"AND SUBSE5.D_E_L_E_T_ = ' ' ) "
	cQuery += "AND SE5.D_E_L_E_T_ = ' '"
	cQuery := ChangeQuery(cQuery)
	MPSysOpenQuery(cQuery, cTmp)
	dbSelectArea(cTmp)
	While !(cTmp)->(EoF())
		Aadd(aBaixas, (cTmp)->RECNOBX)
		(cTmp)->(dbSkip())
	EndDo
	(cTmp)->(dbCloseArea())
	RestArea(aArea)

Return aBaixas


//-------------------------------------------------------------------
/*/{Protheus.doc} ForSemCPF
Exibe os fornecedores do tipo pessoa fisica, que contem CPF em branco.
@author  Luiz Henrique Oliveira Silva
@since   05/11/2019
@version 1
/*/
//-------------------------------------------------------------------
Static Function ForSemCPF()
	Local oBrowse
	Local oColumn
	Local oSair
	Local oDlg
	

	//Existem Fornecedores com CPF em branco
	//Para geração da Dirf, os seus valores serão aglutinados. Deseja visualizar os Fornecedores?
	If MsgYesNo(STR0044,STR0045) 
		DEFINE DIALOG oDlg FROM 0,0 TO 600,800 PIXEL TITLE STR0050 //Fornecedores com CPF em Branco !

		DEFINE FWFORMBROWSE oBrowse DATA ARRAY ARRAY aEmptyCPF NO SEEK NO CONFIG NO REPORT NO LOCATE Of oDlg

		ADD COLUMN oColumn DATA { || aEmptyCPF[oBrowse:At(),1] } TITLE STR0011 SIZE TamSX3("A2_FILIAL")[1] OF oBrowse // Filial
		ADD COLUMN oColumn DATA { || aEmptyCPF[oBrowse:At(),2] } TITLE STR0046 SIZE TamSX3("A2_COD")[1] OF oBrowse // Codigo do Fornecedor
		ADD COLUMN oColumn DATA { || aEmptyCPF[oBrowse:At(),3] } TITLE STR0047 SIZE TamSX3("A2_LOJA")[1] OF oBrowse // Loja
		ADD COLUMN oColumn DATA { || aEmptyCPF[oBrowse:At(),4] } TITLE STR0048 SIZE TamSX3("A2_NOME")[1] OF oBrowse // Nome
		ADD BUTTON oSair TITLE STR0049 Action { || oDlg:End()} Of oBrowse // Sair

		ACTIVATE FWFORMBROWSE oBrowse

		ACTIVATE DIALOG oDlg CENTERED
	EndIf

	FwFreeArray(aEmptyCPF)	

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} F401IrProg
Função para recompor a base do IR Progressivo

@Param cCnpjCpf, CNPJ/CPF do fornecedor
@Param aBaixas, Array com recnos da tabela SE5
@Return nIrBase, Valor bruto da base do IR 
@author  Vitor Duca
@since   27/12/2019
@version 12
/*/
//-------------------------------------------------------------------
Static Function F401IrProg(cCnpjCpf As Character, aBaixas As Array, lNovoCalc As Logical)
	Local nIrBase  As Numeric
	Local lRatFKJ  As Logical
	Local nY	   As Numeric
	Local aArea	   As Array
	Local aAreaSE5 As Array
	Local aAreaFKJ As Array
	Local lJurMulDes As Logical

	Default aBaixas 	:= {}
	Default cCnpjCpf 	:= ""
	Default lNovoCalc	:= .F.
	
	nIrBase  := 0
	lRatFKJ  := .F.
	nY	   	 := 0
	aArea	 := GetArea() 
	aAreaSE5 := SE5->(GetArea())
	aAreaFKJ := FKJ->(GetArea())
	lJurMulDes := SuperGetMv("MV_IMPBAIX",.t.,"2") == "1"

	FKJ->(DbSetOrder(1))
	If FKJ->(DbSeek(xFilial("FKJ",SA2->A2_FILIAL)+SA2->A2_COD+SA2->A2_LOJA))
		While FKJ->(!Eof()) .and. FKJ->(FKJ_FILIAL+FKJ_COD+FKJ_LOJA) == SA2->(A2_FILIAL+A2_COD+A2_LOJA)
			If AllTrim(cCnpjCpf) == AllTrim(FKJ->FKJ_CPF)
				lRatFKJ := .T.
				Exit
			Endif
			FKJ->(DbSkip())
		EndDo
	Endif	

	For nY := 1 to Len(aBaixas)
		SE5->(DbGoTo(aBaixas[nY]))
		nIrBase += SE5->E5_BASEIRF

		If lJurMulDes
			nIrBase -= SE5->E5_VLDESCO
			nIrBase += SE5->E5_VLJUROS
			nIrBase += SE5->E5_VLMULTA
		EndIf		
	Next nY
	

	If lRatFKJ .and. lNovoCalc
		nIrBase := nIrBase * (FKJ->FKJ_PERCEN/100)
	Endif	

	RestArea(aAreaFKJ)
	RestArea(aAreaSE5)
	RestArea(aArea)

Return nIrBase

//-------------------------------------------------------------------
/*/{Protheus.doc} VerCPFProg
Função que verifica se o calculo do IR Progressivo é legado ou novo calculo
gerando os impostos de acordo com o rateio cadastrado na FKJ

@Param cAliasPai, Tabela temporaria com as informações do titulo pai
@Param cAliasTrb, Tabela temporaria com as informações dos impostos
@aReturn aCPF, Array que sera utilizado na gravação da DIRF

Estrutura do aCPF
		[1]  = CNPJ/CPF de retenção
		[2]  = Percentual (Apenas para calculo do legado)
		[3]  = Nome do fornecedor
		[4]  = Codigo do fornecedor
		[5]  = Loja do fornecedor
		[6]  = Define se o calculo do IR progressivo sera legado ou novo (.T. = Novo, .F. = Legado)

@author  Vitor Duca
@since   30/12/2019
@version 12
/*/
//-------------------------------------------------------------------
Static Function VerCPFProg(cAliasPai As Character,cAliasTrb As Character, lPesqFKJ As Logical)
	Local aCPF 		As Array
	Local aTitulos 	As Array
	Local aArea 	As Array
	Local cCgc      As Character
	Local nPadr     As Numeric
	Default lPesqFKJ := .F.

	aCPF 		:= {}
	aTitulos 	:= {}
	aArea 		:= GetArea()
	cCgc 		:= PADR(SA2->A2_CPFIRP,14)
	nPadr       := 14

	If SA2->A2_TIPO == 'F'
		cCgc  := PADR(SA2->A2_CGC,11)
		nPadr := 11
	ENDIF

	DBSelectArea("FKJ")
	FKJ->(DBSetOrder(1))
	If !lPesqFKJ .AND. !Empty((cAliasTrb)->E2_CNPJRET) .and.  !Empty((cAliasTrb)->E2_NOMERET) // Título Novo
		If FKJ->(MsSeek(xFilial("FKJ") + SA2->A2_COD + SA2->A2_LOJA + Alltrim((cAliasTrb)->E2_CNPJRET)) )
			Aadd(aCPF, {PADR((cAliasTrb)->E2_CNPJRET,nPadr),FKJ->FKJ_PERCEN,(cAliasTrb)->E2_NOMERET, SA2->A2_COD, SA2->A2_LOJA, .T.})
		Else
			Aadd(aCPF, {cCgc,100,SA2->A2_NOME, SA2->A2_COD, SA2->A2_LOJA, .T.})
		EndIf	
	Else
		If FKJ->(MsSeek(xFilial("FKJ") + SA2->A2_COD + SA2->A2_LOJA) )
			While FKJ->(!Eof()) .and. FKJ->(FKJ_FILIAL + FKJ_COD + FKJ_LOJA) == xFilial("FKJ") + SA2->A2_COD + SA2->A2_LOJA
				Aadd(aCPF, {PADR(FKJ->FKJ_CPF,nPadr),FKJ->FKJ_PERCEN,FKJ->FKJ_NOME, SA2->A2_COD, SA2->A2_LOJA, .F.})
				FKJ->(DBSkip())
			EndDo
		Else
			Aadd(aCPF, {cCgc,100,SA2->A2_NOME,SA2->A2_COD, SA2->A2_LOJA,.F.})
		Endif	
	Endif

	RestArea(aArea)

Return aClone(aCPF)

//-------------------------------------------------------------------
/*/{Protheus.doc} CPFSemRet
Função que verifica se o calculo do IR Progressivo rateado em mais de um CPF, possui 
algum IR não retido por não atingir o mínimo

@Param 
@Param 
@aReturn 

@author  Karen Honda
@since   09/01/2020
@version 12
/*/
//-------------------------------------------------------------------
Static Function CPFSemRet(cAliasRet As Character,lIRPFBaixa As Logical, aCPfs As Array, cCdRet As Character, cTipoFj As Character, cNIFEX As Character,cData As Character, aLog As Array, lGerLog As Logical, lTemNif As Logical )

Local cQuery as Character
Local cTmp	 as Character
Local nK as Numeric
Local nRendTributavel as Numeric
Local nRendIR as Numeric
Local cRaMat as Character
Local lGrava as Logical
Local nScan	as Numeric
Local cChaveSr4 as Character
Local cTpRen as Character
Local aCPFRet as Array
Local cAno as Character
Local cMesIni as Character
Local cMesFim as Character

nRendTributavel := 0
nRendIR := 0
cRaMat := ""
lGrava := .F.
nScan := 0
cTpRen := ""
cChaveSr4 := ""
aCPFRet := aClone(aCPFs)
cAno := STRZERO(YEAR((cAliasRet)->&cData),4)
cMesIni := STRZERO(MONTH(MV_PAR02),2)
cMesFim := STRZERO(MONTH(MV_PAR03),2)

cTmp  := CriaTrab(,.F.)

For nk := 1 to Len(aCPFs)
	cQuery := "SELECT R4_CPFCGC, R4_CODRET "
	cQuery += " FROM " + RetSqlName("SR4")
	cQuery += " WHERE R4_FILIAL = '" + xFilial("SR4") + "' "
	cQuery += " AND R4_CPFCGC = '" + aCPFs[nK][1] + "' "
	cQuery += " AND R4_ANO = '" + cAno + "' "
	cQuery += " AND R4_MES BETWEEN '" + cMesIni + "' AND '" +  cMesFim + "' "
	cQuery += " AND R4_CODRET = '" + cCdRet + "' "
	cQuery += " AND R4_TIPOREN = 'D' "
	cQuery += " AND D_E_L_E_T_ = ' '"
	cQuery := ChangeQuery(cQuery)
	MPSysOpenQuery(cQuery, cTmp)

	dbSelectArea(cTmp)

	If (cTmp)->( !EoF() ) 
		// possui título de IR gerado. 
		nScan := Ascan(aCPFRet, {|x| Alltrim(x[1]) == Alltrim((cTmp)->R4_CPFCGC)})

		If nScan > 0
			Adel(aCPFRet,nScan)
			Asize(aCPFRet,Len(aCPFRet)-1)
		EndIf

	EndIf
	(cTmp)->( DBCloseArea() ) 	
Next nK

aCpfs := aClone(aCPFRet)

If Len(aCpfs) > 0
	
	nRendIR			:= ValRenPCC( cAliasRet, , , , .T. )
	//não foi gerado o IR
	For nK := 1 To Len(aCPFs)
		
		// Pesquisa cabecalho da DIRF
		If !SRL->(MsSeek(xFilial("SRL")+Padr(SM0->M0_CGC,Len(SRL->RL_CGCFONT))+ cCdRet +;
			cTipoFj+If(SA2->A2_TIPO == "J" .And. SA2->A2_IRPROG = '1',PADR(aCPFs[nK][1],14),Padr(aCPFs[nK][1],Len(SRL->RL_CPFCGC)))+ cNIFEX  ))

			Reclock("SRL", .T.)

			cRaMat := GetSxENum("SRL", "RL_MAT")

			SRL->RL_FILIAL  := xFilial("SRL")
			SRL->RL_MAT     := If(Val(SRA->RA_MAT) < 900000 .And. Val(cRaMat) < 900000, "900000",cRaMat)
			SRL->RL_CODRET  := cCdRet
			SRL->RL_TIPOFJ  := cTipoFj
			SRL->RL_CPFCGC  := If(SA2->A2_TIPO == "J" .and. SA2->A2_IRPROG = '1',Padr(aCPFs[nK][1],14),aCPFs[nK][1])
			SRL->RL_BENEFIC := Substr(aCPFs[nK][3],1,60)
			SRL->RL_ENDBENE := Alltrim(SA2->A2_END) + Alltrim(SA2->A2_NR_END)
			SRL->RL_UFBENEF := SA2->A2_EST
			SRL->RL_COMPLEM := SA2->A2_BAIRRO
			SRL->RL_CGCFONT := SM0->M0_CGC
			SRL->RL_NOMFONT := SM0->M0_NOMECOM
			SRL->RL_ORIGEM := "2"
			SRL->RL_CGCEX := SA2->A2_CGCEX
			SRL->RL_PAIS  := SA2->A2_PAISEX
			SRL->RL_NIFEX := cNIFEX //SA2->A2_NIFEX

			If  IsCodResExt(cCdRet)
				SRL->RL_NEMPR := SA2->A2_NEMPR
				SRL->RL_TPCON := SA2->A2_TPCON
				SRL->RL_DTINI := SA2->A2_DTINIR
				SRL->RL_DTFIM := SA2->A2_DTFIMR
				SRL->RL_LOGEX := SA2->A2_LOGEX
				SRL->RL_NUMEX := SA2->A2_NUMEX
				SRL->RL_COMPL := SA2->A2_COMPLR
				SRL->RL_BAIEX := SA2->A2_BAIEX
				SRL->RL_POSEX := SA2->A2_POSEX
				SRL->RL_CIDEX := SA2->A2_CIDEX
				SRL->RL_ESTEX := SA2->A2_ESTEX
				SRL->RL_TELEX := SA2->A2_TELRE
				SRL->RL_BREEX := SA2->A2_BREEX
				SRL->RL_TPREX := SA2->A2_TPREX
				SRL->RL_TRBEX := SA2->A2_TRBEX
				If !lTemNIF
					If SA2->A2_MOTNIF == "1"                                                                         
						SRL->RL_BEDINI := "1" //Fornecedor dispensado do NIF   
						SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
					Elseif SA2->A2_MOTNIF == "2"             
						SRL->RL_PAEXNI := "2" //País do fornecedor nao exige NIF   
					Endif
				Else
					SRL->RL_PAEXNI := "1" //País do fornecedor exige NIF   
				Endif
			EndIf
			SRL->(MsUnlock())
		Endif

		// Se for pela data baixa e nao houve o pagamento, considerar data E2_EMIS1
		If MV_PAR01 == 4 .and. STRZERO(MONTH((cAliasRet)->&(cData)),2) == "00"
			cData := "E2_EMIS1"
		EndIf

		// Se existir o ano na chave do SR4
		// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN
		cChaveSr4 := xFilial("SR4")+ SRL->RL_MAT+ SRL->RL_CPFCGC + cCdRet + cAno + STRZERO(MONTH((cAliasRet)->&cData),2)

		// Gera valor do Rendimento
		
		nRendTributavel := Round( ( nRendIR * aCPFs[nK][2]) / 100,2 )

		// Tipo do rendimento considera tipo da entidade
		If lTpEnt
			If Empty((cAliasRet)->A2_TPENT)
				cTpRen := "A"
			Else
				If (cAliasRet)->A2_TPENT == "1"	 // Fornecedores Imunes
					cTpRen := "I2"
				ElseIf (cAliasRet)->A2_TPENT == "2"  // Fornecedores Isentos
					cTpRen := "I3"
				EndIf
			EndIf
		Else
			cTpRen := "A"
		EndIf

		If !SR4->( MsSeek( cChaveSr4 + padr(cTpRen,nTamTpRen) +SRL->RL_PAIS + SRL->RL_NIFEX ))

			If nRendTributavel > 0

				Reclock("SR4", .T.)

				SR4->R4_FILIAL  := xFilial("SR4")
				SR4->R4_MAT     := SRL->RL_MAT
				SR4->R4_CPFCGC  := SRL->RL_CPFCGC
				SR4->R4_MES     := STRZERO(MONTH((cAliasRet)->&(cData)),2)
				SR4->R4_TIPOREN := cTpRen
				SR4->R4_CODRET  := cCdRet
				SR4->R4_ANO  := STRZERO(YEAR((cAliasRet)->&(cData)),4)
				SR4->R4_VALOR   := nRendTributavel
				SR4->R4_ORIGEM := "2"
				SR4->R4_PAIS 	:= SRL->RL_PAIS
				SR4->R4_NIFEX := SRL->RL_NIFEX

				If !Empty(SRL->RL_PAIS) .And. IsCodResExt(SRL->RL_CODRET)
					SR4->R4_DTPGT := CTOD("01/"+SR4->R4_MES+"/"+SR4->R4_ANO)
					If lISNIF
						SR4->R4_ISNIF := Iif(lTemNIF,"1","2")
					EndIf
				EndIf

				SR4->(MsUnlock())

				Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCdRet , STRZERO(MONTH((cAliasRet)->&(cData)),2) 	, "A",;
											(cAliasRet)->E2_FILIAL,(cAliasRet)->E2_PREFIXO, (cAliasRet)->E2_NUM, (cAliasRet)->E2_PARCELA,;
											(cAliasRet)->E2_TIPO,(cAliasRet)->E2_NATUREZ, nRendTributavel, cNIFEX )

				lGrava := .T.	
			EndIf
		Else
			Reclock("SR4", .F.)
			SR4->R4_VALOR   += nRendTributavel
			SR4->(MsUnlock())

			Fa401AddLog( @aLog, lGerLog, SRL->RL_CPFCGC , cCdRet , STRZERO(MONTH( (cAliasRet)->&(cData)),2) 	, "A",;
											(cAliasRet)->E2_FILIAL,(cAliasRet)->E2_PREFIXO, (cAliasRet)->E2_NUM, (cAliasRet)->E2_PARCELA,;
											(cAliasRet)->E2_TIPO,(cAliasRet)->E2_NATUREZ, nRendTributavel, cNIFEX )

			lGrava := .T.
		Endif

	Next nK 	

EndIf
	
Return lGrava
