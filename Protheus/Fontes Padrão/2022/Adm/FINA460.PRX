#Include "PROTHEUS.CH"
#Include "FONT.CH"
#Include "COLORS.CH"
#Include "FINA460.CH"
#Include "FILEIO.CH"
#Include "FWADAPTEREAI.CH"
#Include "FWMVCDEF.CH"
#INCLUDE "FWLIBVERSION.CH"

#DEFINE OPER_BLOQUEAR		10
#DEFINE OPER_DESBLOQUEAR    11
#DEFINE OPER_CANCELAR		12
#DEFINE OPER_INCLUI			13
#DEFINE OPER_ALTERA			14
#DEFINE OPER_EFETIVAR		15
#DEFINE OPER_LIQUIDAR		16
#DEFINE OPER_RELIQUIDAR		17
#DEFINE ENTER				Chr(13) + Chr(10)

Static lOpenCmc7
Static aPrefixo                              
Static dLastPcc	:= CTOD("22/06/2015")
Static nTamParc	:= NIL
Static lGeraSEF	:= NIL
Static cParc2Ger:= NIL
Static __lComiLiq	:= NIL
Static __lTpComis	:= NIL
Static __nFinFix := val(SUPERGETMV('MV_FINFIX', .F., '0'))
Static __lJurXFin := NIL
Static __cMV1Dup := NIL
Static __lSigaAGR := NIL
Static __lCMC7Fin := NIL

//Variáveis para integração via mensagem única
Static __aBaixados := {} 
Static __aNovosTit := {}
Static __cNroLiqui := ''
//Variáveis para integração via mensagem única

//Cancelamento chamado do Adapter FINI460
Static aFINI460SE1	:= {}

//Proteção de campo da FO1
Static lCpoFO1Ad := .F.

Static __lMetric	:= .F.
Static __cFunBkp    := ""
Static __cFunMet	:= ""

//Pontos de entrada
Static __lF460Fil	:= NIL
Static __lF460E1	:= NIL
Static __lF460E5	:= NIL
Static __lF460CAN	:= NIL
Static __lF460OWN	:= NIL
Static __lF460OK1	:= NIL
Static __l460Cmc7	:= NIL
Static __l460CMTC	:= NIL
Static __lF460Rot	:= NIL
Static __F460OUT	:= NIL
Static __oTmpSE5	:= Nil
Static __lExcImpo   := Nil
Static __oPagPix	:= Nil
Static __lCnabImp   := Nil
Static __lF070Tra   := nil 

//-------------------------------------------------------------------
/*/{Protheus.doc} FINA460
Liquidação

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
/*/
//-------------------------------------------------------------------
Function FINA460(nPosArotina,xAutoCab,xAutoItens,xOpcAuto,xAutoFil,xNumLiq,xRotAutoVa,xOutMoe,xTxNeg,xTpTaxa,xFunOrig, xTxCalJur, xAutoQuery)

Local lRet      := .F. 

SaveInter()

//------------------------------------------------------------------- 
// Alguns pontos de entrada foram incluidos para necessidades  
// especificas na empresa 4K, pois devido ao alto volume de cheques 
// a liquidar existe a necessidade de alguns controles paralelos
// em relacao a manipulacao dos registros e log de usuarios.
//------------------------------------------------------------------- 

Private aPos   		:= {  15,  1, 70, 315 }
Private cCadastro	:= STR0001 //"Liquidação"
Private cLote
Private lAltera		:= .F.
Private	lhlplog 	:= .T.
Private lOpcAuto	:= (xOpcAuto   <> Nil)
Private aAutoCab	:= If(xAutoCab   <> Nil	,xAutoCab  ,{})
Private aAutoItens	:= If(xAutoItens <> Nil ,xAutoItens,{})
Private nOpcAuto	:= If(xOpcAuto   <> Nil	,xOpcAuto  ,0)
Private cAutoFil	:= If(xAutoFil   <> Nil	,xAutoFil  ,"")
Private cNumLiqCan	:= If(xNumLiq    <> Nil	,xNumLiq   ,"")
Private aRotAutoVA	:= If(xRotAutoVA <> Nil	,xRotAutoVa,{})
Private nOutrMoed   := If(xOutMoe    <> Nil	,xOutMoe   ,2)
Private nTxNegoc    := If(xTxNeg     <> Nil	,xTxNeg    ,0)
Private nTpTaxa     := If(xTpTaxa    <> Nil	,xTpTaxa   ,2)
Private cFunOrig	:= If(xFunOrig   <> Nil	,xFunOrig  ,"")
Private nTxCalJur	:= If(xTxCalJur  <> Nil	,xTxCalJur ,0)
Private cAutoQuery	:= If(xAutoQuery <> Nil ,xAutoQuery  ,"")
Private lAutoQuery	:= cAutoQuery <> ""
Private lParcAuto   := .F.
Private nPergRepl	:= 0
Private lOracle		:= " ORACLE" $ Upper(TcGetDB())
Private cMatApl		:= " NULL "
Private nCodSer		:= " NULL "
Private lCmc7		:= .F.		//Variavel utilizada para verificar se na tela de liquidação o usuário utilizou a rotina de leitura de cheques.
Private lMsgUnq		:= FWHasEai('FINA460') .AND. FWHasEai('FINA040')//indica se usa geração de título por mensagem unica.
Private aRotina		:= MenuDef()
Private __nOpcOuMo  := 2

Default nPosArotina := 0

If !( TableIndic("FO0") .and. TableIndic("FO1") .and. TableIndic("FO2") .and. TableIndic("FKD") .and. TableIndic("FKC") )
	HELP(" ",1,STR0254 ,, STR0243 ,2,0,,,,,,{ STR0255 }) // "FINA460-ROTINA NOVA DE LIQUIDAÇÃO" # "Dicionário Desatualizado" # "Migrar para Protheus 12.1.17 - out 2017"
	Return .F.
Else
	dbSelectArea("FO1")
	lCpoFO1Ad := FO1->(ColumnPos("FO1_VLADIC")) > 0

	DbSelectArea("FO2")
	If ColumnPos( 'FO2_TIPO' ) == 0 

		HELP(" ",1,STR0001 ,, STR0243 ,2,0,,,,,,{STR0244 + CRLF + STR0245 + CRLF + CRLF + STR0246 + CRLF +;
			STR0247 + CRLF +   STR0248 + CRLF + STR0249 + CRLF +;
			STR0250 + CRLF +   STR0251 + CRLF + STR0252 + CRLF + STR0253 })
		
		//"LIQUIDAÇÃO" # "Dicionário Desatualizado" # "Favor criar um novo campo com as" # "caracteristicas abaixo:" # "Campo: FO2_TIPO" #
		//"Tipo: Caracter" # "Tamanho: 3" # " Formato: @! " # 
		//"Título: Tipo" # "Consulta Padrão: 05" # "Obrigatório" # "Usado"
		
		Return .F.
	EndIf 
Endif

Fa460MotBx("LIQ","LIQUIDACAO","ASSS")

HelpLog(.t.)

SetKey (VK_F12,{|a,b| AcessaPerg("AFI460",.T.)})

MV_PAR09 := 1
pergunte("AFI460",.F.)

__lMetric	:= FwLibVersion() >= "20210517"

If nPosArotina > 0
	dbSelectArea('SE1')
	bBlock := &( "{ |a,b,c,d,e| " + aRotina[ nPosArotina,2 ] + "(a,b,c,d,e) }" )
	Eval( bBlock, Alias(), (Alias())->(Recno()),nPosArotina)
Else
	If lOpcAuto
		If nOpcAuto == 3
			lRet := A460Liquid("SE1",SE1->(Recno()),2)//Liquidacao
		ElseIf nOpcAuto == 4
			lRet := A460Liquid("SE1",SE1->(Recno()),4)//Reliquidacao
		Elseif nOpcAuto == 5
			lRet:= FA460CAN("SE1",SE1->(Recno()),4)
		EndIf
	Else
		SetKey (VK_F12,{|a,b| AcessaPerg("AFI460",.T.)})
		mBrowse( 6, 1,22,75,"SE1",,,,,, Fa040Legenda("SE1"))
	EndIf
EndIf

If lCMC7Fin() .And. !lOpcAuto
	If nHdlCmC7 >= 0
		CMC7Fec(nHdlCmC7,SuperGetMv("MV_CMC7PRT"))
	EndIf
EndIf

RestInter()

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A460Liquid
Programa de Inclusao de Liquidação

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
/*/
//-------------------------------------------------------------------
Function A460Liquid(cAlias,nReg,nOpcx)
Local lRet				:= .T.
Local cAliasTMP			:= ""
Local aAreaSe1			:= SE1->(GetArea())
Local cMvJurTipo		:= SuperGetMv("MV_JURTIPO", ,"")  // calculo de Multa do Loja , se JURTIPO == L
Local lMulLoj			:= SuperGetMv("MV_LJINTFS", ,.F.) //Calcula multa conforme regra do loja, se integração com financial estiver habilitada
Local aCpoBro			:= {{ "FO1_MARK"  ,, " "    ,"@!"},;							
							{ "FO1_SALDO" ,, FO1->(RetTitle("FO1_SALDO")),"@E 999,999,999.999"},;	 	//Saldo negociado
							{ "FO1_TXJUR" ,, FO1->(RetTitle("FO1_TXJUR")),"@E 99.99"},;  				//Taxa de Juros
							{ "FO1_VLJUR" ,, FO1->(RetTitle("FO1_VLJUR")),"@E 9,999,999,999.99"},;  	//Valor do juros
							{ "FO1_TXMUL" ,, FO1->(RetTitle("FO1_TXMUL")),"@E 99.99"},;  				//Taxa da multa
							{ "FO1_VLMUL" ,, FO1->(RetTitle("FO1_VLMUL")),"@E 9,999,999,999.99"},;  	//Valor da multa
							{ "FO1_DESCON",, FO1->(RetTitle("FO1_DESCON")),"@E 9,999,999,999.99"},;  	//Descontos
							{ "FO1_ACRESC",, FO1->(RetTitle("FO1_ACRESC")),"@E 9,999,999,999.99"},;  	//Acrescimos
							{ "FO1_DECRES",, FO1->(RetTitle("FO1_DECRES")),"@E 9,999,999,999.99"},;  	//Decrescimos
							{ "FO1_VLABT" ,, FO1->(RetTitle("FO1_VLABT")),"@E 9,999,999,999.99"},;		//Valor abatido
							{ "FO1_TOTAL" ,, FO1->(RetTitle("FO1_TOTAL")),"@E 9,999,999,999.99"},;   	//Total 							
							{ "FO1_FILORI",, FO1->(RetTitle("FO1_FILORI")),"@!"},;  					//Filial de Origem	
							{ "FO1_MOEDA" ,, FO1->(RetTitle("FO1_MOEDA")),"@!"},;						//Moeda
							{ "FO1_TXMOED",, FO1->(RetTitle("FO1_TXMOED")),"@E 99.99"},;  				//Taxa da moeda 							
							{ "FO1_VALCVT",, SE1->(RetTitle("E1_VALOR")),"@E 9,999,999,999.99"},; 		//Valor convertido na moeda							
							{ "FO1_PREFIX",, SE1->(RetTitle("E1_PREFIXO")),"@X"},;   					//Prefixo
							{ "FO1_NUM"   ,, SE1->(RetTitle("E1_NUM")),"@!"},; 							//Número do título
							{ "FO1_PARCEL",, SE1->(RetTitle("E1_PARCELA")),"@!"},;  					//Parcela
							{ "FO1_TIPO"  ,, SE1->(RetTitle("E1_TIPO")),"@!"},;							//Tipo
							{ "FO1_NATURE",, SE1->(RetTitle("E1_NATUREZ")),"@!"},;	 					//Natureza
							{ "FO1_CLIENT",, SE1->(RetTitle("E1_CLIENTE")),"@!"},;  					//Cliente
							{ "FO1_LOJA"  ,, SE1->(RetTitle("E1_LOJA")),"@!"},;  						//Loja do cliente
							{ "FO1_EMIS"  ,, SE1->(RetTitle("E1_EMISSAO")),"@D"},;  					//Dt. Emissão
							{ "FO1_VENCTO",, SE1->(RetTitle("E1_VENCTO")),"@D"},;  						//Dt. de vencimento
							{ "FO1_VENCRE",, SE1->(RetTitle("E1_VENCREA")),"@D"},;  					//Dt. de vencimento
							{ "FO1_BAIXA" ,, SE1->(RetTitle("E1_NUM")),"@D"},;  						//Dt. Baixa
							{ "FO1_VLBAIX",, SE1->(RetTitle("E1_VALLIQ")),"@E 9,999,999,999.99"},; 		//Valor baixado
							{ "FO1_HIST"  ,, SE1->(RetTitle("E1_HIST")),"@!"},;  						//Histórico
							{ "FO1_CCUST" ,, SE1->(RetTitle("E1_CCUSTO")),"@!"},;						//Centro de Custo
							{ "FO1_ITEMCT",, SE1->(RetTitle("E1_ITEMCTA")),"@!"},;						//ITEM DA CONTA
							{ "FO1_CLVL"  ,, SE1->(RetTitle("E1_CLVL")),"@!"},;							//Classe de Valor		
							{ "FO1_CREDIT",, SE1->(RetTitle("E1_CREDIT")),"@!"},;						//Conta Credito
							{ "FO1_DEBITO",, SE1->(RetTitle("E1_DEBITO")),"@!"},;						//Conta Debito
							{ "FO1_CCC"	  ,, SE1->(RetTitle("E1_CCC")),"@!"},;							//CC Credito
							{ "FO1_CCD"   ,, SE1->(RetTitle("E1_CCD")),"@!"},;							//CC Debito
							{ "FO1_ITEMC" ,, SE1->(RetTitle("E1_ITEMC")),"@!"},;						//Item Credito
							{ "FO1_ITEMD" ,, SE1->(RetTitle("E1_ITEMD")),"@!"},;						//Item Debito
							{ "FO1_CLVLCR",, SE1->(RetTitle("E1_CLVLCR")),"@!"},;						//Classe de Valor Credito
							{ "FO1_CLVLDB",, SE1->(RetTitle("E1_CLVLDB")),"@!"}}						//Classe de Valor Debito
Local lAutMrkPix		:= .T.

Private cCliente 		:= Criavar ("E1_CLIENTE",.F.)
Private cLoja    		:= Criavar ("E1_LOJA",.F.)
Private cCli460			:= ""
Private cCliDE			:= Criavar ("E1_CLIENTE",.F.)
Private cLojaDE  		:= Criavar ("E1_LOJA",.F.)
Private cCliAte 		:= Criavar ("E1_CLIENTE",.F.)
Private cLojaAte 		:= Criavar ("E1_LOJA",.F.)
Private cNomeCli		:= CriaVar ("E1_NOMCLI")
Private cNatureza		:= Criavar ("E1_NATUREZ")
Private cTipo			:= Criavar ("E1_TIPO")
Private cCondicao		:= Space(3)			// numero de parcelas automaticas
Private cNumDe			:= CriaVar("E1_NUM")
Private cNumAte			:= CriaVar("E1_NUM")
Private cPrefDe			:= CriaVar("E1_PREFIXO")
Private cPrefAte		:= CriaVar("E1_PREFIXO")
Private cMarca			:= GetMark()
Private cParc460		:= F460Parc()		// controle de parcela (E1_PARCELA)
Private aTmpFil			:= {} 
Private cChvRaNDoc  	:= ""
Private cTurma	 		:= ""
Private cCodDiario		:= ""    
Private nUsado2			:= 0
Private nIntervalo		:= 1
Private nMoeda			:= 1
Private nValor	 		:= 0
Private nQtdTit 		:= 0
Private nValorMax		:= 0				// valor maximo de liquidacao (digitado)
Private nValorDe		:= 0 			   	// valor inicial dos titulos
Private nValorAte		:= 999999999.99 	// Valor final dos titulos
Private nValorLiq		:= 0				// valor da liquidacao ap¢s mBrowse
Private nNroParc		:= 0				// numero de parcelas digitadas
Private nPosAtu			:= 0
Private nPosAnt			:= 9999
Private nColAnt			:= 9999
Private nValorAcr		:= 0				// valor da liquidacao ap¢s mBrowse
Private nValorDcr		:= 0				// valor da liquidacao ap¢s mBrowse
Private nValorTot		:= 0
Private nSaldoBx		:= 0
Private nIDAPLIC 		:= 0				//Integracao Protheus x RM Classis
Private nContrato   	:= 0
Private dData460I 		:= dDataBase
Private dData460F 		:= dDataBase
Private aHeader 		:= {}
Private aCols  			:= {}
Private lInverte		:= .F.
Private lReliquida 		:= IIF(nOpcx == 2,.F.,.T.)
Private oGet
Private oValorLiq
Private oValorAcr
Private oValorDcr
Private oValorTot
Private oNroParc
Private oCliAte
Private oLojaAte
Private cFilMsg		:= "2" //Filtra movimentos de msg unica

If FindFunction("FINTP01") 
	If FINTP01(.T.) //Restringe o uso do programa Financeiro Quando a origem do titulo for de origem Totvs Incorporação - RM
		Return .F.
	EndIf
Endif

if __lSigaAGR == NIL
	__lSigaAGR := SuperGetMv("MV_SIGAAGR",,.F.)
endIf
//Validação quando utiliza módulo do agro
If !lOpcAuto .And. __lSigaAGR
	If FindFunction("AGRTITFIN")
		If !AGRTITFIN()
			return .F.
		EndIf
	EndIf  
Endif	
//------------------------------------------------------------------- 
// Verifica se data do movimento não é menor que data limite de 
// movimentacao no financeiro    								 
//------------------------------------------------------------------- 
If !DtMovFin(,,"2")
	Return .F.
EndIf

//------------------------------------------------------------------- 
// Recupera o numero do lote contabil.							 
//------------------------------------------------------------------- 
LoteCont( "FIN" )

//Metricas - Acessos a Liquidação
__cFunBkp   := FunName()
__cFunMet	:= Iif(AllTrim(__cFunBkp)=='RPC',"RPCFINA460",__cFunBkp)

If __lMetric
	SetFunName(__cFunMet)
	FwCustomMetrics():setSumMetric(Alltrim(ProcName()), "financeiro-protheus_qtd-por-acesso_total", 1)
	SetFunName(__cFunBkp)
Endif

//------------------------------------------------------------------- 
// Inicializa array com as moedas existentes.					 
//------------------------------------------------------------------- 
DbSelectArea(cAlias)
cAlias    	:= "SE1"
cCliente  	:= SE1->E1_CLIENTE
cCli460		:= cCliente
cLoja     	:= SE1->E1_LOJA
cCliDE 		:= SE1->E1_CLIENTE
cLojaDE   	:= SE1->E1_LOJA
cCliAte   	:= SE1->E1_CLIENTE
cLojaAte  	:= SE1->E1_LOJA
cNomeCli  	:= SE1->E1_NOMCLI
dData460I 	:= Iif(SE1->E1_EMISSAO > dDataBase, dDataBase, SE1->E1_EMISSAO)
dData460F 	:= Iif(dData460I > dDataBase, dData460I, dDataBase)

If Empty(cPrefAte)
	cPrefAte := Replicate("Z",TamSx3("E1_PREFIXO")[1])
EndIf

If Empty(cNumAte)
	cNumAte := Replicate("Z",TamSx3("E1_NUM")[1])
EndIf

M->E1_TIPO := cTipo

If cMvJurTipo == "L" .Or. lMulLoj
	aAdd( aCpoBro , {"MULTALJ",,STR0208,"@E 9,999,999,999.99"} )
EndIf

lRet := F460BuscSE1(cAlias,nOpcx,aCpoBro, @cAliasTMP , 1, @lAutMrkPix)
//------------------------------------------------------------------- 
// Faz o calculo automatico de dimensoes de objetos     
// Chamada rotina de seleção de títulos -
// Função - F460SelTit 
// Param 1 - Alias da tabela TMP utilizada, 
// Param 2 - se trata-se de uma execauto ou não, 
// Param 3 - retorno da MarkBrowse
//-------------------------------------------------------------------
If lRet
	lRet := F460SelTit(@cAliasTMP, nOpcX, lAutMrkPix)
	If lOpenCmc7
		While !lRet
			lRet := F460SelTit(@cAliasTMP, nOpcX)
		End
	EndIf
EndIf

SE1->(RestArea(aAreaSe1))

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A460Cli
Verifica dados do Cliente

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
																				
/*/
//-------------------------------------------------------------------
STATIC Function A460Cli ( cCliente, cLoja )
Local cAlias
cAlias:=Alias()
dbSelectArea("SA1")
dbSetOrder(1)
cLoja:=Iif(cLoja == Nil,"",cLoja)
If !(MsSeek(xFilial("SA1")+cCliente+cLoja))
	Return .f.
EndIf
cNomeCli := A1_NREDUZ
dbSelectArea(cAlias)
Return ( .T. )

//-------------------------------------------------------------------
/*/{Protheus.doc} a460PreNum
Numera cheques automaticamente se parcelamento automatico

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
																				
/*/
//-------------------------------------------------------------------
Function a460PreNum(cCampo as Character,cCpoVld as Character, cSeqTipo as Character) as Logical

Local oModel 	As Object
Local oView		As Object
Local oModelFO2 As Object
Local oModelFO1 As Object
Local oModelFO0 As Object
Local cBco		As Character
Local cAge		As Character
Local cNCon		As Character
Local cNum		As Character
Local cParcel	As Character
Local cPrefixo 	As Character
Local cTipoTit 	As Character
Local cCondicao	As Character
Local nLinAtu  	As Numeric
Local cAlias 	As Character
Local nOrdem	As Numeric
Local nRegistro	As Numeric
Local lRet 		As Logical
Local cKeyChq	As Character
Local nX		As Numeric
Local nJ		As Numeric
Local cLastParc	As Character
Local nLinhas	As Numeric
Local cValidCh  As Character
Local cNumAuxAt	As Character
Local cNumAuxAn As Character
Local cPrefAnt	As Character
Local cPrefAtu	As Character
Local cNumPos   As Character
Local cParc2Ger As Character
Local lVldParc  As Logical
Local cMaxParc	As Character

oModel 		:= FWModelActive()
oView		:= FWViewActive()
oModelFO2	:= oModel:GetModel("TITGERFO2")
oModelFO1	:= oModel:GetModel('TITSELFO1')
oModelFO0	:= oModel:GetModel("MASTERFO0")
cBco		:= oModelFO2:GetValue("FO2_BANCO")
cAge		:= oModelFO2:GetValue("FO2_AGENCI")
cNCon		:= oModelFO2:GetValue("FO2_CONTA")
cNum		:= oModelFO2:GetValue("FO2_NUM") 
cParcel		:= Upper(oModelFO2:GetValue("FO2_PARCEL"))
cPrefixo 	:= Upper(oModelFO2:GetValue("FO2_PREFIX"))
cTipoTit 	:= ""
cCondicao	:= oModelFO0:GetValue("FO0_COND")
nLinAtu  	:= oModelFO2:GetLine()
cAlias 		:= Alias()
nOrdem		:= IndexOrd()
nRegistro	:= Recno()
lRet 		:= .T.
cKeyChq		:= ""
nX			:= 1
nJ			:= 1
cLastParc	:= ""
nLinhas		:= oModelFO2:Length()
cValidCh  	:= '' 
cNumAuxAt	:= ''
cNumAuxAn 	:= ''
cPrefAnt	:= ''
cPrefAtu	:= ''
cNumPos   	:= ''
cParc2Ger 	:= cMV1Dup()
lVldParc  	:= .T.
cMaxParc	:= ""

Default cCampo 	:= "1"	//"1" = Prefixo  - "2"=Número do titulo - "3" = Parcela - "4" = Tipo
Default cCpoVld	:= "0"

oModelFO2:LoadValue("FO2_PREFIX", cPrefixo )

If nTamParc == NIL
	nTamParc := TamSx3("E1_PARCELA")[1]
Endif

If nTamParc > Len(cParc2Ger)
	cParc2Ger := cParc2Ger + SPACE( nTamParc-Len(cParc2Ger) )
ElseIf nTamParc < Len(cParc2Ger)
	cParc2Ger := Substr(cParc2Ger,1,nTamParc)
EndIf

If lGeraSEf == NIL
	lGeraSEF := SuperGetMv("MV_GRSEFLQ",.F., .F. )
Endif

If cCampo <> "1"
	cLastParc := cParcel
Endif

If Empty(oModelFO2:GetValue("FO2_TIPO")) .OR. cCampo == "1"
	cTipoTit := oModelFO0:GetValue("FO0_TIPO")
	If Empty(oModelFO2:GetValue("FO2_TIPO"))
		oModelFO2:LoadValue("FO2_TIPO",cTipoTit)
	Endif
Else
	cTipoTit := oModelFO2:GetValue("FO2_TIPO")	
EndIf

cPrefixo := Iif(cPrefixo == nil, Space(03), cPrefixo)

If lRet .And. (cCampo == "1" .Or. cCampo == "2" .Or. cCampo == "5") .And. ((!Empty(cCondicao) .And.  !Empty(cPrefixo)) .Or. (!Empty(cCondicao)))
	If Empty(cPrefixo) .AND. !Empty(MV_PAR08)
		cPrefixo := Upper(MV_PAR08)
	EndIf
	If F460VldCar(cTipoTit,oModelFO2:GetValue("FO2_NUM"),oModelFO2:GetValue("FO2_PREFIX"),oModelFO2:GetValue("FO2_PARCEL"),oModelFO2:GetValue("FO2_TIPO"))
		cNum := a460PrxNum(oModelFO1:GetValue("FO1_FILORI"),cTipoTit,cPrefixo)
	Else
		oModel:SetErrorMessage("",,oModel:GetId(),"","A460CARACTER",STR0259 + CRLF + " "   )
		lRet := .F.
		Return lRet
	Endif
EndIf

cKeyChq := xFilial("SE1") + cPrefixo + cNum + cTipoTit

//-------------------------------------------------------------------
// Verifica se o titulo ja existe no SE1
//-------------------------------------------------------------------
DbSelectArea("SE1")
SE1->(DbSetOrder(1))

If !lOpcAuto 
	If SE1->(MsSeek(xFilial("SE1")+cPrefixo+cNum+cParcel+cTipoTit))
			
		cValidCh := SE1->(E1_BCOCHQ+E1_AGECHQ+E1_CTACHQ) 
		
		If Empty(cValidCh) 
			
			While SE1->(!Eof()) .and. xFilial("SE1")+SE1->(E1_PREFIXO+E1_NUM+E1_TIPO) == cKeyChq  
				If SE1->(E1_BCOCHQ+E1_AGECHQ+E1_CTACHQ) == cBco+cAge+cNCon 
					lRet := .F.
					oModel:SetErrorMessage("",,oModel:GetId(),"","A460EXISTE",STR0220 + CRLF + " " + CRLF + STR0069 + " - " + oModelFO2:GetValue("FO2_PREFIX") + CRLF + STR0168 + " - ";
					+ oModelFO2:GetValue("FO2_NUM") + CRLF + STR0258 + " - " + oModelFO2:GetValue("FO2_PARCEL") + CRLF + STR0163 + " - " + oModelFO2:GetValue("FO2_TIPO") )
					Exit
				Endif
				SE1->(dbSkip())
			End
		
		Else 
			While SE1->(!Eof()) .and. xFilial("SE1")+SE1->(E1_PREFIXO+E1_NUM+E1_TIPO) == cKeyChq  
				If SE1->(E1_BCOCHQ+E1_AGECHQ+E1_CTACHQ) == cValidCh 
					lRet := .F.
					oModel:SetErrorMessage("",,oModel:GetId(),"","A460EXISTE",STR0220 + CRLF + " " + CRLF + STR0069 + " - " + oModelFO2:GetValue("FO2_PREFIX") + CRLF + STR0168 + " - ";
					+ oModelFO2:GetValue("FO2_NUM") + CRLF + STR0258 + " - " + oModelFO2:GetValue("FO2_PARCEL") + CRLF + STR0163 + " - " + oModelFO2:GetValue("FO2_TIPO") )
					Exit
				Endif
				SE1->(dbSkip())
			End
		EndIf 
	EndIf
EndIf
//Carregamento e validacao dos valores quando preenchida uma condicao de pagamento

If !lOpcAuto
	If nPergRepl == 0 .And. cCpoVld == cCampo
		If MsgYesNo(STR0260,STR0051)// "Deseja replicar a informação para as linhas abaixo?. Essa pergunta será exibida somente no próximo acesso."
			nPergRepl := 1 // Sim
		Else
			nPergRepl := 2 // não
		Endif
	Endif
Endif
	
If lRet .And. cCampo == "1" .And. !Empty(cCondicao) .And. (!Empty(cNum) .Or. !Empty(cPrefixo)) .And. !Empty(oModelFO0:GetValue("FO0_TIPO"))
	
	For nX := nLinAtu to nLinhas
		oModelFO2:GoLine(nX)
		If !Empty(cNum) .And. (cCampo == "1" .Or. Empty(oModelFO2:GetValue("FO2_PARCEL")))  
			
			If F460VldCar(cTipoTit,oModelFO2:GetValue("FO2_NUM"),oModelFO2:GetValue("FO2_PREFIX"),oModelFO2:GetValue("FO2_PARCEL"),oModelFO2:GetValue("FO2_TIPO"))
				If F460VldE1(oModelFO2:GetValue("FO2_PREFIX"), cNum, oModelFO2:GetValue("FO2_PARCEL"), oModelFO2:GetValue("FO2_TIPO"))
					oModel:SetErrorMessage("",,oModel:GetId(),"","A460EXISTE",STR0220 + CRLF + " " + CRLF + STR0069 + " - " + oModelFO2:GetValue("FO2_PREFIX") + CRLF + STR0168 + " - ";
					+ oModelFO2:GetValue("FO2_NUM") + CRLF + STR0258 + " - " + oModelFO2:GetValue("FO2_PARCEL") + CRLF + STR0163 + " - " + oModelFO2:GetValue("FO2_TIPO") )
					lRet := .F.
					Exit
				Endif
			Else
				oModel:SetErrorMessage("",,oModel:GetId(),"","A460CARACTER",STR0259 + CRLF + " "   )
				lRet := .F.
				Return lRet
			Endif

			//Gero numero da Parcela
			If FunName() == "TMKA350" .or. lOpcAuto
				F460GerParc(oModelFO2,nLinAtu,cPrefixo,@cNum,cTipoTit,@cLastParc,.T.)
			Else
				If nPergRepl == 1 .or. nX == nLinAtu
					oModelFO2:LoadValue("FO2_PREFIX",cPrefixo)
					oModelFO2:LoadValue("FO2_NUM",cNum)
				ElseIf nPergRepl == 0
					oModelFO2:LoadValue("FO2_TIPO", cTipoTit)
					oModelFO2:LoadValue("FO2_PREFIX",Iif(Empty(MV_PAR08), oModelFO2:GetValue("FO2_PREFIX"), Upper(MV_PAR08) ))				
				Endif
			Endif

		Endif

		If nPergRepl == 2
			Exit
		EndIf
	Next nX
	oModelFO2:GoLine(nLinAtu)
	If !lOpcAuto .And. lRet
		oModelFO2:GoLine(nLinAtu)
		oView:Refresh()
	EndIf
ElseIf lRet .and. !Empty(cNum) .And. cCampo == "2"
	
	cNumAuxAt := oModelFO2:GetValue("FO2_NUM")
	oModelFO2:GoLine(nLinAtu - 1)
	cNumAuxAn := oModelFO2:GetValue("FO2_NUM")
	oModelFO2:GoLine(nLinAtu)

	If nLinAtu > 1
		If cNumAuxAt <> cNumAuxAn
			cNum     := cNumAuxAt
			lVldParc := .F.
			If Empty(oModelFO2:GetValue("FO2_PARCEL"))
				If nPergRepl = 1
					oModelFO2:LoadValue("FO2_PARCEL",cParc2Ger)
				Else
					cParc2Ger := Space(nTamParc)
					oModelFO2:LoadValue("FO2_PARCEL",cParc2Ger)
				Endif
			Else
				cParc2Ger := oModelFO2:GetValue("FO2_PARCEL")
				oModelFO2:LoadValue("FO2_PARCEL",cParc2Ger)
			Endif
		Else
			cNum     := cNumAuxAt
			cParc2Ger:= oModelFO2:GetValue("FO2_PARCEL")
		Endif
	Else
		If Empty(oModelFO2:GetValue("FO2_PARCEL"))
			If nPergRepl <> 1
				cParc2Ger := Space(nTamParc)
			Endif
		Else
			cParc2Ger := oModelFO2:GetValue("FO2_PARCEL")
		Endif
					
		oModelFO2:LoadValue("FO2_PARCEL",cParc2Ger)
		cNum := cNumAuxAt
	Endif

	For nX := nLinAtu to nLinhas
		oModelFO2:GoLine(nX)
		cNumAlt := oModelFO2:GetValue("FO2_NUM")
		If F460VldCar(cTipoTit,oModelFO2:GetValue("FO2_NUM"),oModelFO2:GetValue("FO2_PREFIX"),oModelFO2:GetValue("FO2_PARCEL"),oModelFO2:GetValue("FO2_TIPO"))
			If F460VldE1(oModelFO2:GetValue("FO2_PREFIX"), oModelFO2:GetValue("FO2_NUM"), oModelFO2:GetValue("FO2_PARCEL"), oModelFO2:GetValue("FO2_TIPO"), ,@cMaxParc)
				If Aviso( STR0051 ,STR0220 + CRLF + " " + CRLF + STR0069 + " - " + oModelFO2:GetValue("FO2_PREFIX") + CRLF + STR0168 + " - ";
					+ oModelFO2:GetValue("FO2_NUM") + CRLF + STR0258 + " - " + oModelFO2:GetValue("FO2_PARCEL") + CRLF + STR0163 + " - " + oModelFO2:GetValue("FO2_TIPO");
					+ CRLF + CRLF + STR0271 + "'" + cMaxParc + "'" + STR0272 , {STR0273,STR0274}, 3) = 2 // "A proxima parcela disponivel é " # ". Deseja usar essa parcela para essa liquidação?"

					oModel:SetErrorMessage("",,oModel:GetId(),"","A460EXISTE",STR0220 + CRLF + " " + CRLF + STR0069 + " - " + oModelFO2:GetValue("FO2_PREFIX") + CRLF + STR0168 + " - ";
					+ oModelFO2:GetValue("FO2_NUM") + CRLF + STR0258 + " - " + oModelFO2:GetValue("FO2_PARCEL") + CRLF + STR0163 + " - " + oModelFO2:GetValue("FO2_TIPO"))
					lRet := .F.
					Exit
				Else
					If nPergRepl = 1
						For nJ := nX To oModelFO2:Length()
							oModelFO2:GoLine(nJ)
							oModelFO2:LoadValue("FO2_NUM"   , cNumAlt)
							oModelFO2:LoadValue("FO2_PARCEL", cMaxParc)
							cMaxParc := Soma1(Alltrim(cMaxParc))
						Next nJ
						Exit
					Else
						oModelFO2:LoadValue("FO2_NUM"   , cNumAlt)
						oModelFO2:LoadValue("FO2_PARCEL", cMaxParc)
					Endif
				Endif
			Endif
		Else
			oModel:SetErrorMessage("",,oModel:GetId(),"","A460CARACTER",STR0259 + CRLF + " "   )
			lRet := .F.
			Return lRet
		Endif

		If !Empty(cNum) .And. (cCampo == "2" .Or. Empty(oModelFO2:GetValue("FO2_PARCEL")))  
			//Gero numero da Parcela
			If FunName() == "TMKA350" .or. lOpcAuto
				F460GerParc(oModelFO2,nLinAtu,cPrefixo,@cNum,cTipoTit,@cLastParc,.T.)
			Else
				If nPergRepl == 1
					oModelFO2:LoadValue("FO2_NUM",cNum)
					If !lVldParc
						If nX != nLinAtu
							oModelFO2:LoadValue("FO2_PARCEL",cParc2Ger := Soma1(Alltrim(cParc2Ger)))
						Endif
					Else
						If nLinAtu = nX
							oModelFO2:LoadValue("FO2_PARCEL",cParc2Ger )
						EndIf
					Endif	
				Endif	
			Endif
		Endif
		If nPergRepl == 2
			Exit
		EndIf
	Next nX
	oModelFO2:GoLine(nLinAtu)
	If !lOpcAuto
		oView:Refresh()
	EndIf

ElseIf lRet .and. !Empty(cNum) .And. cCampo == "4"
	
	cNumAuxAt := oModelFO2:GetValue("FO2_PARCEL")
	cPrefAtu  := Upper(oModelFO2:GetValue("FO2_PREFIX"))	
	If oModelFO2:GetLine() > 1 
		oModelFO2:GoLine(nLinAtu - 1)
		cNumAuxAn := oModelFO2:GetValue("FO2_PARCEL")
		cPrefAnt  := Upper(oModelFO2:GetValue("FO2_PREFIX"))
		cNumPos	  := oModelFO2:GetValue("FO2_NUM")
		oModelFO2:GoLine(nLinAtu)
	Endif

	If Empty(oModelFO2:GetValue("FO2_PARCEL"))
		If nPergRepl == 1
			If cCampo == "4"
				cParc2Ger := oModelFO2:GetValue("FO2_PARCEL")
			Endif
		Else
			cParc2Ger := oModelFO2:GetValue("FO2_PARCEL")
		Endif
	Else
		If cPrefAnt <> cPrefAtu 
			cParc2Ger := oModelFO2:GetValue("FO2_PARCEL")
			oModelFO2:LoadValue("FO2_PARCEL",cNumAuxAt)
		ElseIf oModelFO2:GetValue("FO2_NUM") = cNumPos
			cParc2Ger := oModelFO2:GetValue("FO2_PARCEL")
		Endif
	Endif

	If nLinAtu > 1
		If cNumAuxAt <> cNumAuxAn
			cNum     := cNumAuxAt
			lVldParc := .F.
			oModelFO2:LoadValue("FO2_PARCEL",oModelFO2:GetValue("FO2_PARCEL"))
		Endif
	Else
		oModelFO2:LoadValue("FO2_PARCEL",cParc2Ger)
		cNum := cNumAuxAt
	Endif

	For nX := nLinAtu to nLinhas
		oModelFO2:GoLine(nX)
		
		If nX == nLinAtu
			cNumAuxAt := oModelFO2:GetValue("FO2_PARCEL")
			cPrefAtu  := Upper(oModelFO2:GetValue("FO2_PREFIX"))	
		ElseIf nX > nLinAtu
			oModelFO2:GoLine(nX - 1)
			cNumAuxAn := oModelFO2:GetValue("FO2_PARCEL")
			cPrefAnt  := Upper(oModelFO2:GetValue("FO2_PREFIX"))
			oModelFO2:GoLine(nX)
		Endif

		If !Empty(cNum) .And. (cCampo == "4" .Or. Empty(oModelFO2:GetValue("FO2_PARCEL")))  
			//Gero numero da Parcela
			If FunName() == "TMKA350" .or. lOpcAuto
				F460GerParc(oModelFO2,nLinAtu,cPrefixo,@cNum,cTipoTit,@cLastParc,.T.)
			Else
				If nPergRepl == 1
					If !lVldParc
						If nX != nLinAtu
							oModelFO2:LoadValue("FO2_PARCEL",cNumAuxAt := Soma1(Alltrim(cNumAuxAt)))
						Endif
					Else
						If nX > nLinAtu
							If cPrefAnt <> cPrefAtu
								oModelFO2:LoadValue("FO2_PARCEL",cNumAuxAt)
							Else
								If !Empty(cNumAuxAt)
									oModelFO2:LoadValue("FO2_PARCEL",cNumAuxAt := Soma1(Alltrim(cNumAuxAt)))
								Endif
							Endif
						Endif
					Endif	
				Endif	
			Endif

			If F460VldCar(cTipoTit,oModelFO2:GetValue("FO2_NUM"),oModelFO2:GetValue("FO2_PREFIX"),oModelFO2:GetValue("FO2_PARCEL"),oModelFO2:GetValue("FO2_TIPO"))
				If F460VldE1(oModelFO2:GetValue("FO2_PREFIX"), oModelFO2:GetValue("FO2_NUM"), oModelFO2:GetValue("FO2_PARCEL"), oModelFO2:GetValue("FO2_TIPO"))
					oModel:SetErrorMessage("",,oModel:GetId(),"","A460EXISTE",STR0220 + CRLF + " " + CRLF + STR0069 + " - " + oModelFO2:GetValue("FO2_PREFIX") + CRLF + STR0168 + " - ";
					+ oModelFO2:GetValue("FO2_NUM") + CRLF + STR0258 + " - " + oModelFO2:GetValue("FO2_PARCEL") + CRLF + STR0163 + " - " + oModelFO2:GetValue("FO2_TIPO") )
					lRet := .F.
					Exit
				Endif
			Else
				oModel:SetErrorMessage("",,oModel:GetId(),"","A460CARACTER",STR0259 + CRLF + " "   )
				lRet := .F.
				Return lRet
			Endif

		Endif
	Next nX
	oModelFO2:GoLine(nLinAtu)
	If !lOpcAuto
		oView:Refresh()
	EndIf

ElseIf lRet .and. !Empty(cNum) .And. cCampo <> "4" .And. cCampo != "5"

	//Gero numero da Parcela
	If FunName() == "TMKA350" .or. lOpcAuto
		F460GerParc(oModelFO2,nLinAtu,cPrefixo,@cNum,cTipoTit,@cLastParc,.T.)
	Else
		F460GerParc(oModelFO2,nLinAtu,cPrefixo,@cNum,cTipoTit,@cLastParc,.F.)
	Endif

	If F460VldCar(cTipoTit,oModelFO2:GetValue("FO2_NUM"),oModelFO2:GetValue("FO2_PREFIX"),oModelFO2:GetValue("FO2_PARCEL"),oModelFO2:GetValue("FO2_TIPO"))
		If F460VldE1(oModelFO2:GetValue("FO2_PREFIX"), oModelFO2:GetValue("FO2_NUM"), oModelFO2:GetValue("FO2_PARCEL"), oModelFO2:GetValue("FO2_TIPO"))
			oModel:SetErrorMessage("",,oModel:GetId(),"","A460EXISTE",STR0220 + CRLF + " " + CRLF + STR0069 + " - " + oModelFO2:GetValue("FO2_PREFIX") + CRLF + STR0168 + " - ";
			+ oModelFO2:GetValue("FO2_NUM") + CRLF + STR0258 + " - " + oModelFO2:GetValue("FO2_PARCEL") + CRLF + STR0163 + " - " + oModelFO2:GetValue("FO2_TIPO") )
			lRet := .F.
		Endif
	Else
		oModel:SetErrorMessage("",,oModel:GetId(),"","A460CARACTER",STR0259 + CRLF + " "   )
		lRet := .F.
		Return lRet
	Endif

	If Empty(oModelFO2:GetValue("FO2_NUM"))		
		oModelFO2:LoadValue("FO2_NUM",cNum)
	Else
		cNum := oModelFO2:GetValue("FO2_NUM")
		oModelFO2:LoadValue("FO2_NUM",cNum)
	Endif

	cPrefixo := Iif(Empty(oModelFO2:GetValue("FO2_PREFIX")), Upper(MV_PAR08), oModelFO2:GetValue("FO2_PREFIX") )
	For nX := nLinAtu to nLinhas
		oModelFO2:GoLine(nX)
		If nPergRepl == 1
			If cCampo <> "1"
				oModelFO2:LoadValue("FO2_PARCEL",cLastParc)
			Else
				oModelFO2:LoadValue("FO2_PREFIX",cPrefixo)
			Endif
		Endif

		oModelFO2:GoLine(nLinAtu)

		If !lOpcAuto
			oView:Refresh()
		EndIf
	Next nX
	
	If !lOpcAuto
		oView:Refresh()
	EndIf

ElseIf lRet .and. Empty(cNum) .And. cCampo = "1"
			
	If F460VldCar(cTipoTit,oModelFO2:GetValue("FO2_NUM"),oModelFO2:GetValue("FO2_PREFIX"),oModelFO2:GetValue("FO2_PARCEL"),oModelFO2:GetValue("FO2_TIPO"))
		If F460VldE1(oModelFO2:GetValue("FO2_PREFIX"), oModelFO2:GetValue("FO2_NUM"), oModelFO2:GetValue("FO2_PARCEL"), oModelFO2:GetValue("FO2_TIPO"))
			oModel:SetErrorMessage("",,oModel:GetId(),"","A460EXISTE",STR0220 + CRLF + " " + CRLF + STR0069 + " - " + oModelFO2:GetValue("FO2_PREFIX") + CRLF + STR0168 + " - ";
			+ oModelFO2:GetValue("FO2_NUM") + CRLF + STR0258 + " - " + oModelFO2:GetValue("FO2_PARCEL") + CRLF + STR0163 + " - " + oModelFO2:GetValue("FO2_TIPO") )
			lRet := .F.
		Endif
	Else
		oModel:SetErrorMessage("",,oModel:GetId(),"","A460CARACTER",STR0259 + CRLF + " "   )
		lRet := .F.
		Return lRet
	Endif

	oModelFO2:LoadValue("FO2_PREFIX", Upper(oModelFO2:GetValue("FO2_PREFIX")) )

	oModelFO2:GoLine(nLinAtu)

	If !lOpcAuto
		oView:Refresh("VIEW_FO0")
		oView:Refresh("VIEW_FO1")
	EndIf
EndIf

cSeqTipo := cNum

If cAlias <> ""
	DbSelectArea(cAlias)
	DbSetOrder(nOrdem)
	DbGoTo(nRegistro)
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A460Emit
Repassa Nome do Emitente para as demais parcelas se parcelamento 
automatico

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	

/*/
//-------------------------------------------------------------------
Function A460Emit()

Local oModel	:= FWModelActive()
Local oView		:= FWViewActive()
Local oModelFO0	:= oModel:GetModel('MASTERFO0')
Local oModelFO2 := oModel:GetModel('TITGERFO2')
Local nLine		:= 0
Local cEmitent	:= ""
Local nX		:= 0
Local lRet		:= .T.

If AllTrim(oModelFO0:GetValue("FO0_TIPO")) == AllTrim(MVCHEQUE)

	//------------------------------------------------------------------- 
	// Se parcelamento automatico e se primeira linha do aCols		 
	// numera cheque automaticamente								 
	//------------------------------------------------------------------- 

	nLine		:= oModelFO2:GetLine()
	cEmitent	:= oModelFO2:GetValue("FO2_EMITEN")

	For nX := 1 to oModelFO2:Length()
		oModelFO2:GoLine(nX)
		If Empty(oModelFO2:GetValue("FO2_EMITEN"))
			oModelFO2:LoadValue("FO2_EMITEN",cEmitent)
		EndIf		
	Next nX
	
	oModelFO2:GoLine(nLine)
	If !lOpcAuto
		oView:Refresh()
	EndIf		
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A460CtaChq
Repassa Nome do Emitente para as demais parcelas se parcelamento 
automático quando Bco/Age/Cta iguais

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	

/*/
//-------------------------------------------------------------------
Function A460CtaChq()

Local oModel	:= FWModelActive()
Local oView		:= FWViewActive()
Local oModelFO2 := oModel:GetModel('TITGERFO2')
Local nLine		:= 0
Local cBco		:= ""
Local cAge		:= ""
Local cNCon		:= ""
Local nX		:= 0

//------------------------------------------------------------------- 
// Se parcelamento automatico e se primeira linha do aCols		 
// numera cheque automaticamente								 
//------------------------------------------------------------------- 
	
nLine	:= oModelFO2:GetLine()
cBco 	:= oModelFO2:GetValue("FO2_BANCO")
cAge 	:= oModelFO2:GetValue("FO2_AGENCI")
cNcon	:= oModelFO2:GetValue("FO2_CONTA")

If !lOpcAuto
	If nPergRepl == 0
		If MsgYesNo(STR0260,STR0051)// "Deseja replicar a informação para as linhas abaixo?. Essa pergunta será exibida somente no próximo acesso."
			nPergRepl := 1 // Sim
		Else
			nPergRepl := 2 // não
		Endif
	EndIf
EndIf

If nPergRepl = 1
	For nX := 1 to oModelFO2:Length() 
		oModelFO2:GoLine(nX)
		If 	Empty(oModelFO2:GetValue("FO2_BANCO")) .And. Empty(oModelFO2:GetValue("FO2_AGENCI")) .And. Empty(oModelFO2:GetValue("FO2_CONTA")) 
			oModelFO2:LoadValue("FO2_BANCO"	, cBco)
			oModelFO2:LoadValue("FO2_AGENCI", cAge)
			oModelFO2:LoadValue("FO2_CONTA"	, cNcon)
		EndIf
	Next nX
EndIf

oModelFO2:GoLine(nLine)

If !lOpcAuto
	oView:Refresh()
EndIf		

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} A460ChecF
Montagem da Query para seleção dos titulos a serem liquidados

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	

/*/
//-------------------------------------------------------------------
Function A460ChecF(nChoice,aSelFil,cEscrit,cFatura,nMoedSel)

Local cRet			:= ""
Local cFiltro 		:= ""
Local aTam    		:= TamSX3("E1_VALOR")
Local nTamLiq 		:= F460TamLiq()
Local nTamNum 		:= TamSx3('E1_NUM')[1]
Local lIntGem 		:= HasTemplate('LOT')
Local nTamCtr 		:= 0
Local cTmpSE1Fil	:= ""
Local aArea 		:= GetArea()

// Integração SIGAPFS x SIGAFIN
Local lIntPFS		:= lJurXFin()

//PCREQ-3782 - Bloqueio por situação de cobrança
Local cLstCart 	:= FN022LSTCB(1,'0006')	//Lista das situacoes de cobranca (Carteira)
Local cLstNoBlq := FN022LSTCB(6,'0006')	//Lista das situacoes de cobranca (Não bloqueadas para determinado processo)

Default cEscrit  := ""
Default cFatura  := ""
Default nMoedSel := 1

cNumDe  := Pad(cNumDe ,nTamNum)
cNumAte := Pad(cNumAte,nTamNum)

DbSelectArea("SED")
SED->(DbSetOrder(1)) //ED_FILIAL+ED_CODIGO

DbSelectArea("SA1")
SA1->(DbSetOrder(1)) //A1_FILIAL+A1_CODIGO+A1_LOJA

If lIntGEM
	nTamCtr := TamSx3('E1_NCONTR')[1] 
Endif

if __lF460OWN == NIL
	__lF460OWN := ExistBlock("FA460OWN")
endIf
if __lF460OWN .and. (nChoice <> 3) .and. (!lOpcAuto .OR. (lOpcAuto .AND. Empty(cAutoFil) .AND. Empty(cAutoQuery)))//Não executa o P.E. se selecionada a opção '3-Variação Monetária' no campo 'Outras Moedas' ou se tem filtro no ExecAuto
	cRet := ExecBlock("FA460OWN",.F.,.F.)
Else	
	cRet := "SELECT "
	cRet += "R_E_C_N_O_ RECNO "
	cRet += " FROM "+	RetSqlName("SE1") + " SE1 "
	cRet += " WHERE "
	If !lOpcAuto 
		//Gestao
		If mv_par06 == 1
			cFiltro += "E1_FILIAL " + GetRngFil( aSelFil, "SE1", .T., @cTmpSE1Fil ) + " AND "
			aAdd(aTmpFil, cTmpSE1Fil)
		Else
			cFiltro += "E1_FILIAL =  '" + xFilial("SE1") + "' AND "
		Endif

		cFiltro += " E1_CLIENTE BETWEEN '"+ cCliDe   + "' AND '" + cCliAte  + "' AND "
		cFiltro += " E1_LOJA BETWEEN '"   + cLojaDe  + "' AND '" + cLojaAte + "' AND "
		cFiltro += " E1_PREFIXO BETWEEN '"+ cPrefDe  + "' AND '" + cPrefAte + "' AND "
		cFiltro += " E1_NUM BETWEEN '"    + cNumDe   + "' AND '" + cNumAte  + "' AND "

		If nIntervalo = 1
			cFiltro += "E1_EMISSAO BETWEEN '" + DTOS(dData460I) + "' AND '" + DTOS(dData460F) + "' AND "
		Else
			cFiltro += "E1_VENCTO BETWEEN '"  + DTOS(dData460I) + "' AND '" + DTOS(dData460F) + "' AND "
		EndIf

		If nChoice = 2 .Or. nChoice = 3 //Nao converte outras moedas ou Variação Monetária
			cFiltro += "E1_MOEDA = " + Alltrim(Str(nMoeda,2)) + " AND "
		EndIf

		If mv_par04 = 1
			cFiltro += " E1_SITUACA IN "+FormatIn(cLstCart,'|')+" AND "	
		Else	
			//PCREQ-3782 - Bloqueio por situação de cobrança
			cFiltro += " E1_SITUACA IN "+FormatIn(cLstNoBlq,'|')+" AND "
		Endif

		//Se a integração com RM estiver ativa e o processo de baixas via RM estiver configurada para Modelo II
		//serão exibidos os títulos
		If lMsgUnq	//Verifica se os adapters estão configurados 
			If cFilMsg == "1"
				cFiltro	+= " E1_IDLAN > 0 AND "  
			Else
				cFiltro	+= " E1_IDLAN = 0 AND "
			EndIf
		Else	//Se os adapters não estão configurados, serão exibidos os títulos que não são de integração.
			cFiltro	+= " E1_IDLAN = 0 AND "
		EndIf
		cFiltro += "E1_SALDO > 0 AND "

		cFiltro += "E1_VALOR >= " + AllTrim(Str(nValorDe ,aTam[1],aTam[2])) + " AND "
		cFiltro += "E1_VALOR <= " + AllTrim(Str(nValorAte,aTam[1],aTam[2])) + " AND "

		cFiltro += "E1_TIPO NOT IN " + F460NotIN()  + " AND "

		If !lReliquida 	//Liquida titulos nÆo liquidados anteriormente
			cFiltro += " E1_NUMLIQ = '" + Space(nTamLiq) +"' AND "
		ElseIf lReliquida		// Reliquidaao
			cFiltro += " E1_NUMLIQ <> '" + Space(nTamLiq) +"' AND "
		Endif

		//Template GEM - nao podem ser liquidados/reliquidados os titulos do GEM pelo financeiro.
		If lIntGem
			cFiltro += " E1_NCONTR = '" + Space(nTamCtr) +"' AND "
		EndIf

		If SuperGetMV("MV_RMTINVE",,1) == 2 // MV_RMTINVE = 2  > Baixa bloqueada no BackOffice Protheus e sendo realizada pelo TOTVS Incorporação.
			cFiltro += " E1_ORIGEM <> 'FINI055' AND " // retornar o filtro de bloqueio do titulo do TIN RM  AND E1_ORIGEM <> 'FINI055'
		EndIf
		
		cFiltro += " D_E_L_E_T_ = ' ' "

		//Filtra faturas do SIGAPFS
		If lIntPFS 
			If FindFunction("Jur460Filt")
				cFiltro += Jur460Filt(cEscrit, cFatura, cFiltro)
			Else
				If Empty(cEscrit + cFatura)
					cFiltro += " AND E1_JURFAT = '' "
				Else
					cFiltro += " AND E1_JURFAT = '" + xFilial('NXA') + '-' + cEscrit + '-' + cFatura + '-' + cFilAnt + "' "
				EndIf
			EndIf
		EndIf
	ElseIf lAutoQuery 
		cFiltro := cAutoQuery
	EndIf
	cRet += cFiltro

	if lOpcAuto .AND. !lAutoQuery
		cRet := cAutoFil
	endif
	
	if __lF460Fil == NIL
		__lF460Fil := ExistBlock("FA460FIL")
	endIf
	If __lF460Fil
		cRet += ExecBlock("FA460FIL",.F.,.F.)
	Endif
Endif

RestArea(aArea)

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FA460CAN
Cancelamento da Liquidação

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	

/*/
//-------------------------------------------------------------------
Function FA460CAN(cAlias,cCampo,nOpcx,aCamposSE1,lAutoGem)

Local lOk    := .T.
Local lBlind := IsBlind()


//Metricas - Acessos a Cancelamento de Liquidação
__cFunBkp   := FunName()
__cFunMet	:= Iif(AllTrim(__cFunBkp)=='RPC',"RPCFINA460",__cFunBkp)

If __lMetric
	SetFunName(__cFunMet)
	FwCustomMetrics():setSumMetric(Alltrim(ProcName()), "financeiro-protheus_qtd-por-acesso_total", 1)
	SetFunName(__cFunBkp)
Endif

If lBlind
	lOk := FA460ECAN(cAlias,cCampo,nOpcx,aCamposSE1,lAutoGem,lBlind)
Else
	Processa( {|| lOk := FA460ECAN(cAlias,cCampo,nOpcx,aCamposSE1,lAutoGem,lBlind) }, STR0263 ) //Cancelando Liquidação...
EndIf

Return lOk

//-------------------------------------------------------------------
/*/{Protheus.doc} FA460ECAN
	Cancelamento da Liquidação

	@author Mauricio Pequim Jr
	@version P12.1.8
	@since	21/01/1998	
/*/
//-------------------------------------------------------------------
Function FA460ECAN(cAlias,cCampo,nOpcx,aCamposSE1,lAutoGem,lBlind)

	Local lPanelFin 	As Logical
	Local cArquivo		As Character
	Local nTotal		As Numeric
	Local nHdlPrv		As Numeric
	Local nOpcT			As Numeric
	Local nTitulos		As Numeric
	Local nParcelas		As Numeric
	Local cIndex		As Character
	Local cTitulo 		As Character
	Local cDadosSE1		As Character
	Local cDadosSe5		As Character
	Local lHeadProva 	As Logical
	Local lPadraoE1		As Logical // Exclusao de conta a receber
	Local lPadrao		As Logical
	Local cPadrao    	As Character
	Local lContabilizou As Logical
	Local lDigita 		As Logical
	Local lAglutina		As Logical
	Local lCtBaixa		As Logical
	Local lAcreDecre 	As Logical
	Local nAcresc 		As Numeric
	Local nDecresc	 	As Numeric   
	Local oDlg4         As Object            
	Local nGemMulta		As Numeric
	Local lRastro		As Logical
	Local aAlt   		As Array
	Local cChaveTit		As Character
	Local cChaveFK7		As Character
	Local nSe1Multa  	As Numeric
	Local cAliasTMPC 	As Character
	Local nRecFO2       As Numeric
	Local cFuncOri      As Character
	Local cCliLiq		As Character //Cliente destino da Liquidação
	Local cLojaLiq		As Character
	local aSalDup1      As Array //Atualização dos títulos baixados pela liquidação
	local aSalDup2      As Array //Atualização dos títulos gerados pela liquidação
	local nX			As Numeric
	Local aFK1VA		As Array
	Local lAtuCli       As Logical 

	//Tratamento para o template GEM - exclusao de renegociacao
	Local lOpcAuto2 	As Logical
	Local aFlagCTB		As Array

	//639.04 Base Impostos diferenciada
	Local _aTit			As Array
	Local lContinua		As Logical
	Local nRecSE1		As Numeric
	Local lAtuSldNat	As Logical   

	//Controle de abatimento
	Local lTitpaiSE1	As Logical
	Local nOrdTitPai	As Numeric
	Local bWhile 		As CodeBlock

	//Gestao
	Local cFilialAtu	As Character
	Local aDadosSE5		As Array

	//Resstruturacao SE5
	Local oModelEst		As Object
	Local cLog			As Character
	Local aValOrig		As Array
	Local aBaixas		As Array
	Local nCm			As Numeric
	Local nVaTot		As Numeric
	Local nTotalReg     As Numeric
	Local nAbatFO1      As Numeric
	Local cIdOriE5      As Character
	Local aDadosFO1     As Array

	//Parametrização dos Produtos utilizados pela RM
	Local cProdRM		As Character

	//Cancelamento chamado do Adapter FINI460
	Local lFINI460		As Logical
	Local lPodeCanc		As Logical

	//valor Acessorio
	Local lAutomato   	As Logical
	Local lSE1Comp  	As Logical

	// Variavel lAutoGem -> referente à rotina de exclusao de uma renegociacao do template GEM
	Local cInternalId 	As Character
	Local cFilOld		As Character
	Local aReturn		As Variant

	// Integração SIGAPFS x SIGAFIN
	Local lIntPFS       As Logical

	Local nInicio		As Numeric
	Local nFim			As Numeric
	Local nRecProc		As Numeric

	lPanelFin 		:= IsPanelFin()
	cArquivo		:= ""
	nTotal			:= 0
	nHdlPrv			:= 0
	nOpcT			:= 0
	nTitulos		:= 0
	nParcelas		:= 0
	cIndex			:= ""
	cTitulo 		:= STR0062  //"Cancel. Liquidação"
	cDadosSE1		:= ""
	cDadosSe5		:= ""
	lHeadProva 		:= .F.
	lPadraoE1		:= VerPadrao("505")  // Exclusao de conta a receber
	lPadrao			:= .F.
	cPadrao    		:= ""
	lContabilizou 	:= .F.
	lDigita 		:= .T.
	lAglutina		:= .T.
	lCtBaixa		:= .F.
	lAcreDecre 		:= .F.
	nAcresc 		:= 0
	nDecresc	 	:= 0   
	oDlg4         	:= nil                     
	nGemMulta		:= 0
	lRastro			:= FVerRstFin()
	aAlt   			:= {}
	cChaveTit		:= ""
	cChaveFK7		:= ""
	nSe1Multa  		:= 0
	cAliasTMPC 		:= GetNextAlias()
	nRecFO2       	:= 0
	cFuncOri      	:= ""
	cCliLiq			:= "" //Cliente destino da Liquidação
	cLojaLiq		:= ""
	aSalDup1      	:= {} //Atualização dos títulos baixados pela liquidação
	aSalDup2      	:= {} //Atualização dos títulos gerados pela liquidação
	nX				:= 1
	aFK1VA			:= {}
	lAtuCli			:= .T.

	//Tratamento para o template GEM - exclusao de renegociacao
	lOpcAuto2 		:= IIf (Type("lOpcAuto") == "U",.F.,lOpcAuto)  
	aFlagCTB		:= {}

	//639.04 Base Impostos diferenciada
	_aTit			:= {}
	lContinua		:= .T.
	nRecSE1			:= 0
	lAtuSldNat		:= .T.   

	//Controle de abatimento
	lTitpaiSE1		:= .T.
	nOrdTitPai		:= 0
	bWhile 			:= {||  !Eof() .and. cTitAnt == (SE1->E1_FILIAL+SE1->E1_CLIENTE+SE1->E1_LOJA+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA)}

	//Gestao
	cFilialAtu		:= ""
	aDadosSE5		:= {}

	//Resstruturacao SE5
	oModelEst		:= NIL	//FWLoadModel("FINM010")
	cLog			:= ""
	aValOrig		:= {}
	aBaixas			:= {}
	nCm				:= 0
	nVaTot			:= 0
	nTotalReg     	:= 0
	nAbatFO1      	:= 0
	cIdOriE5      	:= ""
	aDadosFO1     	:= {}

	//Parametrização dos Produtos utilizados pela RM
	cProdRM			:= GETNEWPAR('MV_RMORIG', "")

	//Cancelamento chamado do Adapter FINI460
	lFINI460		:= FwIsInCallStack("FINI460")
	lPodeCanc		:= .T. 

	//valor Acessorio
	lAutomato   	:= .F.
	lSE1Comp  		:= FWModeAccess("SE1",3) == "C" // Verifica se SE1 é compartilhada

	// Variavel lAutoGem -> referente à rotina de exclusao de uma renegociacao do template GEM
	cInternalId 	:= ""
	cFilOld			:= ""

	// Integração SIGAPFS x SIGAFIN
	lIntPFS       	:= lJurXFin()

	nInicio			:= 0
	nFim			:= 0
	nRecProc		:= 0		

	DEFAULT lAutoGem	:= .F.
	DEFAULT __lF070Tra  := ExistBlock("F070TRAVA")

	Private cLiqCan 	:= CriaVar("E1_NUMLIQ" , .F.) 
	Private aDiario		:= {}
	Private cCodDiario	:= ""
	Private nVA			:= 0 

	Private FO1VADI := 0

	//Controle de rotina automatica
	if Type("lMsErroAuto") == "U"
		private lMsErroAuto := .F.
	endIf
	if Type("lOpcAuto") == "U"
		private lMsHelpAuto := .F.
	endIf
	if Type("lAutoErrNoFile") == "U"
		private lAutoErrNoFile := .F.
	endIf

	// Zerar variaveis para contabilizar os impostos da lei 10925.
	VALOR5 := 0
	VALOR6 := 0
	VALOR7 := 0                   

	//Cancelamento chamado do Adapter FINI460
	aFINI460SE1	:= {}

	If FindFunction("FINTP01") 
		If FINTP01(.T.) //Restringe o uso do programa Financeiro Quando a origem do titulo for de origem Totvs Incorporação - RM
			Return .F.
		EndIf
	Endif

	if __lSigaAGR == NIL
		__lSigaAGR := SuperGetMv("MV_SIGAAGR",,.F.)
	endIf
	//Validação quando utiliza módulo do agro
	If !lOpcAuto .And. __lSigaAGR
		If FindFunction("AGRTITFIN")
			If !AGRTITFIN()
				return .F.
			EndIf
		EndIf  
	Endif	

	//------------------------------------------------------------------- 
	// Verifica se data do movimento não é menor que data limite de 
	// movimentacao no financeiro    										  
	//------------------------------------------------------------------- 
	If !DtMovFin(,,"2")
		If lPanelFin  //Chamado pelo Painel Financeiro						
			dbSelectarea(FinWindow:cAliasFile)
			FinVisual(FinWindow:cAliasFile,FinWindow,(FinWindow:cAliasFile)->(Recno()),.T.)	
		EndIf
		Return .F.
	EndIf

	//------------------------------------------------------------------- 
	// Verifica o numero do Lote 											  
	//------------------------------------------------------------------- 
	DbSelectArea("SX5")
	MsSeek(cFilial+"09FIN")

	Private cLote := Substr(X5DESCRI(),1,4)

	If lOpcAuto2
		cLiqCan:=cNumLiqCan
	Else
		If !Empty(SE1->E1_NUMLIQ)
			cLiqCan := SE1->E1_NUMLIQ
		ElseIf !Empty(SE1->E1_FATURA) 
			cLiqCan := SE1->E1_FATURA
			// Se FATURA gerada pelo FINA280, cancelar pela função do FINA280 
			FA280CAN("SE1",'41', 3, lAutomato,.T.)
			Return .t.
		EndIf	
	EndIf

	nValor		:= 0
	nValRec		:= 0
	nTitulos	:= 0
	nParcelas	:= 0
	nOpcT		:= 0

	//verifica se existem os capos de valores de acrescimo e decrescimo no SE5
	lAcreDecre := .T.

	If !lAutoGem
		If !lOpcAuto2
			If lPanelFin  //Chamado pelo Painel Financeiro			
				oPanelDados := FinWindow:GetVisPanel()
				oPanelDados:FreeChildren()
				aDim := DLGinPANEL(oPanelDados)
				DEFINE MSDIALOG oDlg4 OF oPanelDados:oWnd FROM 0,0 To 0,0 PIXEL STYLE nOR( WS_VISIBLE, WS_POPUP )							

				// -------------------------------------------------------------- 
				// Observacao Importante quanto as coordenadas calculadas abaixo:  
				// --------------------------------------------------------------  		
				// a funcao DlgWidthPanel() retorna o dobro do valor da area do	 
				// painel, sendo assim este deve ser dividido por 2 antes da  
				// subtracao e redivisao por 2 para a centralizacao. 					 		
				// -------------------------------------------------------------- 		
				nEspLarg := (((DlgWidthPanel(oPanelDados)/2) - 114) /2)-4
				nEspLin  := 0				
				
			Else   
				nEspLarg := 0 
				nEspLin  := 3  
				DEFINE MSDIALOG oDlg4 FROM	20,1 TO 160,340 TITLE cTitulo PIXEL
			EndIf       
		EndIf 
	Else
		cLiqCan	 := SE1->E1_NUMLIQ 
		nOpct	 := 1  
		nEspLarg := 0 
		nEspLin  := 3  
	EndIf     

	If !lOpcAuto2
		oPanel := TPanel():New(0,0,'',oDlg4,, .T., .T.,, ,20,20)
		oPanel:Align := CONTROL_ALIGN_ALLCLIENT   

		@ 006+nEspLin, 011+nEspLarg TO 036+nEspLin, 125+nEspLarg OF oPanel PIXEL                                                                            
		
		@ 011+nEspLin, 014+nEspLarg SAY STR0058 SIZE 49, 07 OF oPanel PIXEL //"Nro. Liquidao"
		@ 021+nEspLin, 014+nEspLarg MSGET cLiqCan Valid !Empty(cLiqCan) 	SIZE 49, 11 OF oPanel PIXEL hasbutton
		
		If !lAutoGem
			If lPanelFin  //Chamado pelo Painel Financeiro			
				// define dimenção da dialog
				oDlg4:nWidth := aDim[4]-aDim[2]

				ACTIVATE MSDIALOG oDlg4 ON INIT ( FaMyBar(oDlg4,;
				{||nOpct:=1,oDlg4:End()},;
				{||oDlg4:End()}),oDlg4:Move(aDim[1],aDim[2],aDim[4]-aDim[2], aDim[3]-aDim[1]))
			Else
				DEFINE SBUTTON FROM 10, 133 TYPE 1 ACTION (nOpct:=1,If(Fa460OK2() .And. !Empty(cLiqCan) ,oDlg4:End(),nOpct:=0)) ENABLE OF oPanel
				DEFINE SBUTTON FROM 23, 133 TYPE 2 ACTION oDlg4:End() ENABLE OF oPanel
				ACTIVATE MSDIALOG oDlg4 CENTERED
			EndIf
		EndIf		   
	EndIf
	// --------------------------------------------------------------
	// Salva a Area atual do SE1                                 
	// --------------------------------------------------------------
	DbSelectArea("SE1")
	nOrdemSe1 	:= SE1->(IndexOrd())
	nRegSE1 	:= SE1->(Recno())
	nRecSe5		:= SE5->(Recno())

	//---------------------------------------------------------------
	//Validando se pode excluir por causa da Integração RM X Classis
	//---------------------------------------------------------------
	If(!lOpcAuto)
		dbSelectArea("FO0")
		FO0->(DbSetOrder(2))
		If(FO0->(DbSeek(xFilial("FO0")+cLiqCan+SE1->E1_CLIENTE+SE1->E1_LOJA)))
			If(Alltrim(FO0->FO0_ORIGEM) $ cProdRM )
				HELP(" ",1,"ProtheusXClassis" ,, STR0230 ,2,0,,,,,,{STR0233})//"Liquidação gerada pela Integração Protheus X Classis não Pode ser alterado pelo Protheus" ## "Efetue alteração da liquidação pelo RM Classis"
				Return .F.
			EndIf
		EndIf
	EndIf

	if __lF460CAN == NIL
		__lF460CAN := Existblock("F460CANC")
	endIf
	If __lF460CAN
		nOpct := Execblock("F460CANC" ,.F.,.F.,{nOpct})
	Endif

	If nOpct == 1 .Or. lOpcAuto2
		
		Begin Transaction

		// --------------------------------------------------------------------------
		// POR MAIS ESTRANHO QUE PAREA, ESTA FUNCAO DEVE SER CHAMADA AQUI! 
		//                                                                  
		// A função SomaAbat reabre o SE1 com outro nome pela ChkFile para  
		// efeito de performance. Se o alias auxiliar para a SumAbat() não  
		// estiver aberto antes da IndRegua, ocorre Erro de & na ChkFile,   
		// pois o Filtro do SE1 uptrapassa 255 Caracteres.                  
		// --------------------------------------------------------------------------
		SomaAbat("","","","R")

		//Metricas - Cancelamento da Liquidação
		If __lMetric
			nInicio := Seconds()
		Endif

		// --------------------------------------------------------------------------
		// Seleciona os registros a serem processados no cancelamento
		// --------------------------------------------------------------------------
		lPodeCanc	:= A460Filtra(cLiqCan, cAliasTMPC, @nTotalReg ) 
		If lPodeCanc
			dbSelectArea(cAliasTMPC)
			(cAliasTMPC)->(DbGoTop())
			If !lBlind
				ProcRegua(nTotalReg)
			EndIf
			dbSelectArea("SE1")

			While (cAliasTMPC)->(!Eof())
		
				If !lBlind
					IncProc()
				EndIf

				//Metricas - Gravados
				nRecProc += 1	

				cFilialAtu := cFilAnt
				SE1->(dbGoto((cAliasTMPC)->CHAVE))
				
				cFilOrig  := SE1->E1_FILORIG
				cDadosSe1 := SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+ SE1->E1_TIPO
				cDadosSe5 := SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+ SE1->E1_TIPO+SE1->E1_CLIENTE+SE1->E1_LOJA
				aDadosSE5 := {SE1->E1_FILORIG,SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_CLIENTE,SE1->E1_LOJA}

				//Movimento dos titulos geradores de liquidacao
				If (SE1->E1_NUMLIQ<>cLiqCan) .OR. (Empty(SE1->E1_NUMLIQ) .And. !(SE1->E1_TIPO $ MV_CRNEG)) 

					// --------------------------------------------------------------------------
					// Se for um titulo que gerou a liquidacao, desfaz o processo
					// --------------------------------------------------------------------------
					nTotAbat := 0
					nJuros	 := 0
					nDescont := 0
					nGemMulta:= 0
					nVA		 := 0 	
					nCM		 := 0
					nAbatFO1 := 0
					cIdOriE5 := ""
					aDadosFO1:= {}
					FO1VADI  := 0

					//Gestao
					cFilAnt := cFilOrig
					
					dbSelectArea("SE1")
					nTotAbat := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,dDataBase,SE1->E1_CLIENTE,SE1->E1_LOJA,,,SE1->E1_TIPO)
					
					SE5->(dbSetOrder(7))

					//Achou o registro da baixa por liquidação
					If (cAliasTMPC)->CHAVESE5 > 0 
						SE5->(dbGoto((cAliasTMPC)->CHAVESE5))

						//Verifica se a filial atual é a filial do processo
						If xFilial("SE5",cFilialAtu) == SE5->E5_FILIAL
							cFilAnt := cFilialAtu
						Endif
					
						//--------------------------------------------------------------------------
						// Ponto de entrada para tratamento do titulo gerado pela  
						// liquidacao antes do cancelamento.                       
						//--------------------------------------------------------------------------
						if __lF460E5 == NIL
							__lF460E5 := ExistBlock("F460E5")
						endIf
						IF __lF460E5
							ExecBlock("F460E5", .F., .F.,{cDadosSE5})
						EndIf   

						aFK1VA := {} 

						While SE5->(!EoF()) .and. SE1->E1_FILORIG == SE5->E5_FILORIG .and. ;
							SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) == cDadosSE5;
							.AND. AllTrim(SE5->E5_DOCUMEN) == AllTrim(cLiqCan)

							If SE5->E5_SITUACA == "C" .or. cLiqCan != Alltrim(SE5->E5_DOCUMEN) .or. ;
								!SE5->E5_MOTBX $ "LIQ|VM " .or. !(SE5->E5_TIPODOC $ "DC#JR#BA#MT#CM#VA#VM")
								dbSKip()
								Loop
							EndIf

							// Verifica movimentacao de AVP
							FAVPValTit( "SE1", SE5->( Recno() ) )

							If SE5->E5_TIPODOC == "DC"
								nDescont := SE5->E5_VALOR
								RecLock("SE5")
									Replace E5_SITUACA with "C"
								SE5->(MSUNLOCK())
							ElseIf  SE5->E5_TIPODOC == "JR"
								nJuros 	:= SE5->E5_VALOR
								RecLock("SE5")
									Replace E5_SITUACA with "C"
								SE5->(MSUNLOCK())
							ElseIf  SE5->E5_TIPODOC == "CM"
								nCM 	:= SE5->E5_VALOR
								RecLock("SE5")
									Replace E5_SITUACA with "C"
								SE5->(MSUNLOCK())							
							ElseIf  SE5->E5_TIPODOC == "MT"
								nGemMulta:= SE5->E5_VALOR
								RecLock("SE5")
									Replace E5_SITUACA with "C"
								SE5->(MSUNLOCK())
							ElseIf  SE5->E5_TIPODOC == "VA"
								nVA:= SE5->E5_VALOR		
								nVaTot += nVa
								RecLock("SE5")
								Replace E5_SITUACA with "C"
								SE5->(MSUNLOCK())			
								aAdd(aFK1VA, SE5->E5_IDORIG)				
							ElseIf SE5->E5_TIPODOC == "BA"
								If SE5->E5_TIPODOC == "BA"
									cIdOriE5 := SE5->E5_IDORIG
									nValRec  := SE5->E5_VALOR
									nValorM2 := SE5->E5_VLMOED2
									nRecSE5  := SE5->( recno() )
									lCtBaixa := If("S"$SE5->E5_LA,.T.,lCtBaixa)
									If lAcreDecre
										nAcresc := SE5->E5_VLACRES
										nDecresc := SE5->E5_VLDECRE
									EndIf

									//Busca os dados do cliente destino na Liquidação.
									A460GetCli(cLiqCan, @cCliLiq, @cLojaLiq)

									//Buscar dados da FO1
									If !Empty(cIdOriE5)
										If FO0->FO0_NUMLIQ <> cLiqCan
											dbSelectArea("FO0")
											dbSetOrder(2)
											dbSeek( xFilial("FO0") + cLiqCan + cCliLiq + cLojaLiq )
										EndIf
										aDadosFO1 := F460AbFO1(FO0->FO0_PROCES,FO0->FO0_VERSAO,cIdOriE5)
										If Len(aDadosFO1) > 0
											nAbatFO1 := aDadosFO1[1,1]
											FO1VADI  := aDadosFO1[1,2]
										EndIf
									EndIf
								EndIf

								oModelEst := FWLoadModel("FINM010") //Recarrega o Model de baixa para pegar o campo do relacionamento (SE5->E5_IDORIG)							
								oModelEst:SetOperation( 4 ) //Alteração
								oModelEst:Activate()
								oModelEst:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
								//E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK2
								//E5_OPERACAO 2 = Grava E5 com E5_TIPODOC = 'ES' e gera estorno na FK2
								//E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK2
								oModelEst:SetValue( "MASTER", "E5_OPERACAO", 1 )
								oModelEst:SetValue( "MASTER", "HISTMOV"    , STR0062) 
								
								//Posiciona a FKA com base no IDORIG da SE5 posicionada
								oFKA := oModelEst:GetModel( "FKADETAIL" )
								oFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )	


								If oModelEst:VldData()
									oModelEst:CommitData()	
								Else
									cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
									cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
									cLog += cValToChar(oModelMov:GetErrorMessage()[6])        	

									Help(,,"F460CANBX",,cLog,1,0)
									lContinua := .F.
										
								EndIf
								oModelEst:DeActivate()
								oModelEst:Destroy()
								oModelEst := NIL

								//Caso ocorra algum problema com o cancelamento da baixa do titulo gerador
								//O processo de cancelamento das outras baixas é parado.
								If !lContinua
									Exit
								Endif

							ElseIf SE5->E5_TIPODOC == "VM"

								oModelE1 := FWLoadModel('FINM350')
								oModelE1:SetOperation(4)
								oModelE1:Activate() 
								oModelE1:SetValue( "MASTER", "E5_GRV"  , .T. ) //Habilita gravação de SE5
								oModelE1:SetValue( "MASTER", "E5_OPERACAO", 1 )
								oModelE1:SetValue( "MASTER", "HISTMOV" , STR0280) //VM.CAN.FINA460

								If oModelE1:VldData()
									oModelE1:CommitData()
								Else
									cLog := cValToChar(oModelE1:GetErrorMessage()[4]) + ' - '
									cLog += cValToChar(oModelE1:GetErrorMessage()[5]) + ' - '
									cLog += cValToChar(oModelE1:GetErrorMessage()[6])        	

									Help(,,"F460CANBX",,cLog,1,0)
									lContinua := .F.
								EndIf	

								oModelE1:DeActivate()
								oModelE1:Destroy()
								oModelE1 := NIL

								// Contabilização do estorno da variação monetária gerada pelo FINA350
								cPadrao := "59A"
								lPadrao := VerPadrao(cPadrao)
								nTotal := 0
								VALOR := FK6->FK6_VALMOV

								If lPadrao
									If !lHeadProva
										nHdlPrv := HeadProva(cLote, "FINA460", Substr(cUsuario, 7, 6), @cArquivo)
										lHeadProva := .T.
									Endif
									nTotal := DetProva(nHdlPrv, cPadrao, "FINA460", cLote)

									// Indica se a tela sera aberta para digitação
									lDigita := (mv_par02 == 1 .and. !isBlind())
									cA100Incl(cArquivo, nHdlPrv, 3, cLote, lDigita, .F.)
								Endif
								VALOR := 0							

							EndIf
							
							If UsaSeqCor() 
								aAdd(aDiario,{"SE5",SE5->(Recno()),cCodDiario,"E5_NODIA","E5_DIACTB"}) 
							EndIf
							SE5->(dbSkip())
						EndDo
					EndIf
					
					cFilAnt := cFilialAtu
					
					//Caso ocorra algum problema com o cancelamento da baixa do titulo gerador
					//O processo de cancelamento da liquidação é parado.
					If !lContinua
						Exit
					Endif

					SE5->( dbGoTo( nRecSE5 ) ) 
					
					if __lTpComis == NIL
						__lTpComis := SuperGetMv("MV_TPCOMIS") == "O"
					endIf
					if __lComiLiq == NIL
						__lComiLiq := ComisBx("LIQ") .AND. SuperGetMv("MV_COMILIQ",,"2") == "1"
					endIf
					If __lTpComis  .and. __lComiLiq 
						If ! SE1->E1_TIPO $ MV_CRNEG .And. ! SE1->E1_TIPO $ MV_CPNEG
							aadd(aBaixas,{SE5->E5_MOTBX,SE5->E5_SEQ,SE5->(Recno())})
							Fa440DeleB(aBaixas,.F.,.F.,"FINA460")
							aBaixas		:= {}			   			
						Endif				
					Endif

					// --------------------------------------------------------------------------
					//Verifica se foi utilizada taxa contratada para moeda > 1          
					// --------------------------------------------------------------------------
					If SE1->E1_MOEDA > 1  
						nTxMoeda := Iif (SE5->E5_TXMOEDA > 0, SE5->E5_TXMOEDA, RecMoeda(SE5->E5_DATA,SE1->E1_MOEDA) )
					Else
						nTxMoeda := RecMoeda(SE5->E5_DATA,SE1->E1_MOEDA)
					EndIf

					// --------------------------------------------------------------------------
					//Caso moeda == 1 a funcao RecMoeda iguala nTxMoeda = 0. Iguala-se   
					//nTxMoeda = 1 p/ evitar problema c/ calculos de abatimento e outros.
					// --------------------------------------------------------------------------
					nTxMoeda := Iif(nTxMoeda == 0 , 1 , nTxMoeda)
					DbSelectArea("SE1")
					DbSetOrder(1)
					If MsSeek(xFilial("SE1",cFilOrig)+cDadosSE1)
						// --------------------------------------------------------------------------
						//Gera backup dos valores da baixa (para cancelamento baixa parcial)
						// --------------------------------------------------------------------------
						nSe1ValLiq  := SE1->E1_VALLIQ
						nSe1Descont := SE1->E1_DESCONT
						nSe1Juros   := SE1->E1_JUROS
						nSe1Multa   := SE1->E1_MULTA
						// --------------------------------------------------------------------------
						//Grava novos valores do cancelamento da baixa parcial              
						// --------------------------------------------------------------------------
						RecLock("SE1")
						SE1->E1_VALLIQ  := 0
						SE1->E1_DESCONT := nDescont
						SE1->E1_JUROS   := nJuros
						SE1->E1_MULTA   := nGemMulta
						SE1->E1_CORREC	:= nCM	
						MsUnlock()
					EndIf
					DbSetOrder(1)
					
					aAdd(__aBaixados , {SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA, SE1->E1_TIPO})
					
					If SE1->E1_MOEDA > 1				
						nTotAbat := nTotAbat * NoRound(nTxMoeda,5)
					EndIf

					ABATIMENTO := nTotAbat

					//--------------------------------------------------------------------------
					//Gera lanamento contabil de estorno                               
					//--------------------------------------------------------------------------
					cPadrao := "527"    //cancelamento de baixa
					lPadrao := VerPadrao(cPadrao)
					
					SA1->(DbSetOrder(1))
					SA1->(MsSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA))

					DbSelectArea("SE1")
					
					If !lHeadProva .and. lPadrao 
						nHdlPrv := HeadProva( 	cLote,;
												"FINA460",;
												Substr( cUsuario, 7, 6 ),;
												@cArquivo )
						lHeadProva := .T.
					EndIf
						
					If lPadrao .and. lCtBaixa
						nTotal += DetProva( nHdlPrv,;
											cPadrao,;
											"FINA460",;
											cLote,;
											/*nLinha*/,;
											/*lExecuta*/,;
											/*cCriterio*/,;
											/*lRateio*/,;
											/*cChaveBusca*/,;
											/*aCT5*/,;
											/*lPosiciona*/,;
											@aFlagCTB,;
											/*aTabRecOri*/,;
											/*aDadosProva*/ )
						If UsaSeqCor()
							aAdd(aDiario,{"SE1",SE1->(Recno()),cCodDiario,"E1_NODIA","E1_DIACTB"}) 
						EndIf 

					EndIf	
					//--------------------------------------------------------------------------
					//Grava valores anteriores da contabilizacao do canc da baixa parcial
					//--------------------------------------------------------------------------
					RecLock("SE1")
					SE1->E1_VALLIQ  := 0
					SE1->E1_DESCONT := nSe1Descont
					
					//Retorna os valores de juros e multa
					If  nSe1Juros >= nJuros 
						SE1->E1_JUROS -= nJuros
					EndIf

					If nSe1Multa >= nGemMulta
						SE1->E1_MULTA -= nGemMulta
					EndiF
					
					SE1->( MsUnlock() )
					SE1->( DbSetOrder(1) )
					
					nSalvRec := SE1->( Recno() )

					If lAtuSldNat
						If lSE1Comp
							AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, "+",,FunName(),"SE1",SE1->(Recno()),4 , ,0, SE1->E1_FILORIG)
						Else
							AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, "+",,FunName(),"SE1",SE1->(Recno()),4 , ,0, SE1->E1_FILIAL)
						Endif	
					Endif
					//--------------------------------------------------------------------------
					//Verifica se há  abatimentos para voltar a carteira                 
					//--------------------------------------------------------------------------
					If nTotAbat > 0 .and. SE1->E1_SALDO == 0 
						SE1->(DbSetOrder(2))
						If MsSeek(xFilial("SE1",cFilOrig)+SE1->E1_CLIENTE+SE1->E1_LOJA+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA)
							cTitAnt := (SE1->E1_FILIAL+SE1->E1_CLIENTE+SE1->E1_LOJA+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA)     
							If lTitpaiSE1    
								If (nOrdTitPai:= OrdTitpai()) > 0
									SE1->(DbSetOrder(nOrdTitPai))
									If	DbSeek(xFilial("SE1",cFilOrig)+cDadosSe5)    
										bWhile  := {|| !Eof() .And. Alltrim(SE1->E1_TITPAI) == Alltrim(cDadosSe5)}  
									Else
										SE1->(DbSetOrder(2))
									EndIf
								EndIf
							EndIf

							While Eval(bWhile) 
								If !(SE1->E1_TIPO $ MVABATIM)
									SE1->( dbSkip() )
									Loop
								EndIf
								//--------------------------------------------------------------------------
								//Volta t¡tulo para carteira                                       
								//--------------------------------------------------------------------------
								Reclock("SE1", .F.)
								SE1->E1_BAIXA   := Ctod(" /  /  ")
								SE1->E1_SALDO	:= SE1->E1_VALOR
								SE1->E1_DESCONT := 0
								SE1->E1_JUROS   := 0
								SE1->E1_MULTA   := 0
								SE1->E1_CORREC  := 0
								SE1->E1_VARURV  := 0
								SE1->E1_VALLIQ  := 0
								SE1->E1_LOTE    := Space(Len(E1_LOTE))
								SE1->E1_DATABOR := Ctod(" /  /  ")
								SE1->E1_STATUS  := "A"
								SE1->E1_OK		:= "  "
								SE1->( msUnLock() )

								//--------------------------------------------------------------------------
								// Carrega variaveis para contabilizacao dos abatimentos 
								// (impostos da lei 10925).         			
								//--------------------------------------------------------------------------
								If SE1->E1_TIPO == MVPIABT
									VALOR5 := SE1->E1_VALOR			
								ElseIf SE1->E1_TIPO == MVCFABT
									VALOR6 := SE1->E1_VALOR
								ElseIf SE1->E1_TIPO == MVCSABT
									VALOR7 := SE1->E1_VALOR						
								EndIf			
								If lAtuSldNat
									If lSE1Comp
										AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, "+",,FunName(),"SE1",SE1->(Recno()),4 , ,0, SE1->E1_FILORIG)
									Else
										AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, "2", "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, "+",,FunName(),"SE1",SE1->(Recno()),4 , ,0, SE1->E1_FILIAL)
									Endif	
								EndIf
								SE1->(dbSkip())
							Enddo
						EndIf
						SE1->(DbSetOrder(1))
					EndIf
					SE1->( dbGoTo( nSalvRec ) )

					If lAutoGem .and. HasTemplate("LOT")
						nValor := SE1->E1_SALDO+(nValRec-nJuros+nDescont-nGemMulta+IIF(SE1->E1_SALDO==0,nTotAbat,0))+nVaTot
					Else
						If nAbatFO1 <> nTotAbat //Esse IF é um contorno e deve ser mantido ate a SPYKE sobre a definição da regra referente a ISSUE DSERFINR-16726
							If SE1->E1_MOEDA == 1
								nValor := SE1->E1_SALDO-(nJuros+nVaTot+nGemMulta-nValRec-nDescont-nAbatFO1)
							Else
								nValor := SE1->E1_SALDO-((nJuros+nVaTot+nGemMulta-nValRec-nDescont-nAbatFO1) / NoRound(nTxMoeda,5))
								//Corrige possiveis erros de arredondamento
								If Abs(Round(SE1->E1_VALOR - nValor,2)) == 0.01         
									nValor := SE1->E1_VALOR
								EndIf
							EndIf					
						Else
							If SE1->E1_MOEDA == 1 .Or. (SE1->E1_MOEDA == Val(SE5->E5_MOEDA))
								nValor := SE1->E1_SALDO-(nJuros+nVaTot+nGemMulta-nValRec-nDescont-IIF(SE1->E1_SALDO==0,nTotAbat,0))
							Else
								nValor := SE1->E1_SALDO-((nJuros+nVaTot+nGemMulta-nValRec-nDescont-IIF(SE1->E1_SALDO==0,nTotAbat,0)) / NoRound(nTxMoeda,5))
								//Corrige possiveis erros de arredondamento
								If Abs(Round(SE1->E1_VALOR - nValor,2)) == 0.01         
									nValor := SE1->E1_VALOR
								EndIf
							EndIf   
						EndIf
					EndIf
					nVaTot := 0 

					RecLock("SE1",.F.)
					SE1->E1_SALDO		:= nValor
					SE1->E1_MOVIMEN		:= dDataBase
					
					If !F460VldLiq(cDadosSE5)
						SE1->E1_TIPOLIQ	:= Space(3)
					Endif
					
					If lAcreDecre
						SE1->E1_SDACRES	:= Round(NoRound(xMoeda(nAcresc,1,SE1->E1_MOEDA,SE5->E5_DATA,3,nTxMoeda),3),2)
						SE1->E1_SDDECRE	:= Round(NoRound(xMoeda(nDecresc,1,SE1->E1_MOEDA,SE5->E5_DATA,3,nTxMoeda),3),2)
					Else
						SE1->E1_SDACRES	:= SE1->E1_ACRESC 
						SE1->E1_SDDECRE	:= SE1->E1_DECRESC		
					EndIf
					SE1->E1_STATUS	:= "A"
					SE1->E1_OK		:= "  "

					//639.04 Base Impostos diferenciada
					//O caso abaixo ocorrerá quando
					//Controlo base de impostos
					//Calculo do PCC - CR na emissao
					//Titulo Gerador da liquidacao eh retentor
					//Natureza da liquidacao calcula PCC
					If Str(SE1->E1_SALDO,17,2) > Str(SE1->E1_VALOR,17,2)
						SE1->E1_SALDO := SE1->E1_VALOR
					EndIf

					IF Str(SE1->E1_SALDO,17,2) == Str(SE1->E1_VALOR,17,2)
						SE1->E1_VALLIQ	:= 0				
						SE1->E1_BAIXA	  := Ctod("//")
					EndIf
					SE1->( MsUnlock() )
					
					//Atualiza saldo dos valores acessórios (FKD)
					cancAtuFKD(aFK1VA)
					FWFreeArray(aFK1VA)
					aFK1VA := {}
					
					///numbor			
					aAlt := {}
					aAdd( aAlt,{ STR0206,'','','',STR0207 +  Alltrim(Transform(SE1->E1_VALOR,PesqPict("SE1","E1_VALOR"))) })   
					///chamada da Função que cria o Histórico de Cobrança
					cFilOld := cFilAnt
					cFilAnt := SE1->E1_FILORIG
					FinaCONC(aAlt)							
					cFilAnt	:= cFilOld
					
									/*
					Atualiza o status do titulo no SERASA */
					If cPaisLoc == "BRA"
						cChaveTit := xFilial("SE1",SE1->E1_FILORIG) + "|" +;
													SE1->E1_PREFIXO + "|" +;
													SE1->E1_NUM		+ "|" +;
													SE1->E1_PARCELA + "|" +;
													SE1->E1_TIPO	+ "|" +;
													SE1->E1_CLIENTE + "|" +;
													SE1->E1_LOJA
						cChaveFK7 := FINGRVFK7("SE1",cChaveTit,SE1->E1_FILORIG)
						F770BxRen("3","",cChaveFK7)			
					EndIf				
					
					//--------------------------------------------------------------------------------
					// Função Específica do Modulo Sigapls para atualizar Status de Guias Compradas 
					//--------------------------------------------------------------------------------				
					PL090TITCP(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,"5")
					
					//--------------------------------------------------------------------------------
					//Integracao Protheus X RM Classis Net (RM Sistemas)³
					//--------------------------------------------------------------------------------
					If GetNewPar("MV_RMCLASS", .F.) .and. !Empty(SE1->E1_NUMRA)
						cNumRA 		:= SE1->E1_NUMRA 				 	//Pega o numero do RA do aluno para alimentar o campo E1_NUMRA com a inclusao do novo titulo
						nIDAPLIC 	:= SE1->E1_IDAPLIC 					//Pega o numero do IDENTIFICADOR DA MATRIZ APLICADA para alimentar o campo E1_IDAPLIC com a inclusao do novo titulo
						cTurma 		:= SE1->E1_TURMA 					//Pega a Turma do Aluno para alimentar o campo E1_TURMA com a inclusao do novo titulo
					endif		

					// Cancelamento do rastreamento(FI7/FI8)
					If lRastro
						FINRSTDEL("SE1",cDadosSe5,aDadosSE5)
					EndIf

					If !(SE1->E1_TIPO $ MV_CRNEG+"/"+MVRECANT)
						aAdd(aSalDup1,SE1->(RECNO()))
					endif

					//Instrução de Cobrança PCREQ-9881.
					FxBDelFI2()

				//Titulos Gerados pela Liquidacao
				ElseIf (SE1->E1_NUMLIQ = cLiqCan 	.Or. ;
						SE1->E1_TIPO $ MV_CRNEG)	.And.;
						SE1->E1_STATUS != "R"
					//--------------------------------------------------------------------------------
					// Se for uma parcela da liquidacao contabiliza o cancelamento e deleta.                            
					//--------------------------------------------------------------------------------
					cPadrao := "505"

					//--------------------------------------------------------------------------------
					//Posiciono FO2 para utilização na contabilização
					//--------------------------------------------------------------------------------
					nRecFO2 := 0
					nRecFO2 := F460PosFO2( (cAliasTMPC)->CHAVE , cLiqCan )
					dbSelectArea("FO2")
					If nRecFO2 > 0
						FO2->(dbGoto(nRecFO2))
						JUROS3 := FO2->FO2_VLJUR
					EndIf

					//--------------------------------------------------------------------------------
					// Posiciona o SE1 pois o arquivo de trabalgo pode ser resultado de uma Query.                                        
					//--------------------------------------------------------------------------------
					DbSelectArea("SE1")
					SE1->( DbSetOrder(1) )

					SE1->( MsSeek(xFilial("SE1", cFilOrig) + cDadosSE1) )
					cFilAnt := SE1->E1_FILORIG

					lContabilizou := Iif(SubStr(SE1->E1_LA,1,1)=="S",.T.,.F.)

					If !(SE1->E1_TIPO $ MV_CRNEG)
						Aadd(aSalDup2, SE1->(RECNO()))
					endif

					If !lHeadProva .and. lPadraoE1
						nHdlPrv := HeadProva( 	cLote,;
												"FINA460",;
												Substr( cUsuario, 7, 6 ),;
												@cArquivo )
						lHeadProva := .T.
					EndIf

					If lPadraoE1 .and. lContabilizou
						nTotal += DetProva( nHdlPrv,;
											cPadrao,;
											"FINA460",;
											cLote,;
											/*nLinha*/,;
											/*lExecuta*/,;
											/*cCriterio*/,;
											/*lRateio*/,;
											/*cChaveBusca*/,;
											/*aCT5*/,;
											/*lPosiciona*/,;
											@aFlagCTB,;
											/*aTabRecOri*/,;
											/*aDadosProva*/ )
					EndIf

					if __lF460E1 == NIL
						__lF460E1 := ExistBlock("FIN460E1")
					endIf
					If __lF460E1
						Execblock("FIN460E1",.F.,.F.)
					EndIf

					nRecSE1 := SE1->(Recno())
				
					DbSelectArea("SE1")
					Fa460ExcSef(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO)

					SE1->(dbGoto(nRecSE1))
					SE1->(DbSetOrder(1))

					//Cancelamento chamado do Adapter FINI460
					If lFINI460
						cValInt := IntTRcExt(, , SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO)[2]
						If !Empty(cValInt)
							AADD(aFINI460SE1, cValInt )
						Endif
					Endif

					_aTit := {}
					aAdd(_aTit , {"E1_PREFIXO"	,SE1->E1_PREFIXO	,NIL})
					aAdd(_aTit , {"E1_NUM"		,SE1->E1_NUM		,NIL})
					aAdd(_aTit , {"E1_PARCELA"	,SE1->E1_PARCELA	,NIL})
					aAdd(_aTit , {"E1_TIPO"  	,SE1->E1_TIPO		,NIL})
					aAdd(_aTit , {"E1_CLIENTE"	,SE1->E1_CLIENTE	,NIL})
					aAdd(_aTit , {"E1_LOJA"  	,SE1->E1_LOJA		,NIL})
					
					//Salva a funname original
					cFuncOri := Alltrim(Funname())
					
					//Cálculo diferenciado dos impostos - MV_RTIPFIN
					SetFunName("FINA460")
					MSExecAuto({|x, y| FINA040(x, y)}, _aTit, 5)

					cFilAnt := cFilialAtu

					//Restaura a funname original
					SetFunName(cFuncOri)

					//Em caso de falha na exclusao dos titulos o processo será parado.
					If lMsErroAuto
						If !IsBlind()
							MOSTRAERRO()
						ENDIF
						lContinua := .F.
						RollBackDelTran()
						Exit
					Else 
						aAdd(__aNovosTit ,{SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA, SE1->E1_TIPO}) // Alimenta aDischarge da mensagem unica no cancelamento
						cInternalId := IntTRcExt(, SE1->E1_FILIAL, SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO)[2]
						CFGA070Mnt('RM' /*cMarca*/, "SE1", "E1_NUM", , cInternalId , .T.)
					EndIf

				EndIf
				
				If lContinua .And. FindFunction("JCancBaixa")
					// Integração SIGAPFS x SIGAFIN
					JCancBaixa((cAliasTMPC)->CHAVE, (cAliasTMPC)->CHAVESE5)
				EndIf
				
				(cAliasTMPC)->(dbSkip())

			EndDo

			//Caso a exclusao tenha ocorrido sem problemas
			If lContinua	
				If nTotal > 0
					RodaProva(  nHdlPrv,;
								nTotal)

					lDigita		:= IIf( mv_par02 == 1, .T., .F. )
					lAglutina	:= IIf( mv_par03 == 1, .T., .F. )

					cA100Incl( cArquivo,;
								nHdlPrv,;
								3,;
								cLote,;
								lDigita,;
								lAglutina,;
								/*cOnLine*/,;
								/*dData*/,;
								/*dReproc*/,;
								@aFlagCTB,;
								/*aDadosProva*/,;
								aDiario )
					aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

				EndIf
			EndIf

		ElseIf lOpcAuto2 .Or. !lPodeCanc
			lMsErroAuto := .T.
			lContinua := .F. 
		EndIf

		If lContinua

			__cNroLiqui := cLiqCan
			//Integração via Mensagem Única
			If FWHasEAI('FINA460',.T.,,.T.)
				aValOrig := F460ChgVar() //Altera as variáveis INCLUI, ALTERA

				oAux := FwModelActive()

				oFINA460 := FwLoadModel("FINA460A")
				oFINA460:SetOperation( MODEL_OPERATION_INSERT ) //Define operação de inclusao
				oFINA460:Activate()

				aReturn := FWIntegDef('FINA460')

				If ValType(aReturn) == "A" .AND. Len(aReturn) >= 2 .AND. !aReturn[1]
					If ! IsBlind()
						Help( ,, "FINA460INTEG",, STR0241 + AllTrim( aReturn[2] ), 1, 0,,,,,, {STR0242} ) //"O registro não será gravado, pois ocorreu um erro na integração: ", "Verifique se a integração está configurada corretamente."  						
					Endif
					lContinua := .F.
					RollBackDelTran()
				Endif

				F460RetVar(aValOrig)
				oFINA460:DeActivate()
				oFINA460:Destroy()
				oFINA460 := NIL
				
			EndIf

			If lOpcAuto
				F460ABlqCan(3, xFilial("SE1"), cLiqCan) //Chama rotina de cancelamento
			EndIf

			If lIntPFS .And. FindFunction("JCancLiqCR")
				JCancLiqCR(xFilial("SE1"), cLiqCan)
			EndIf
		Endif

		End Transaction

		lAtuCli := .T.		
		If __lF070Tra
			lAtuCli := ExecBlock("F070TRAVA",.f.,.f.) //P.E que indica ser haverá atualização das informações do cliente
		EndIf

		//Ajusta saldo de duplicatas e atraso médio - Feito fora da transaction para não travar SA1
		if lContinua
			//Títulos baixados pela liquidação
			for nX := 1 to len(aSalDup1)
				SE1->(DbGoTo(aSalDup1[nX]))
				If SE1->(Recno()) == aSalDup1[nX]
					dbSelectArea("SA1")
					SA1->(dbSetOrder(1))
					If SA1->(MsSeek(FWxFilial("SA1",cFilOrig)+SE1->E1_CLIENTE+SE1->E1_LOJA))//Posiciona no registro do cliente e Estorna Atraso Medio
						If lAtuCli
							RecLock("SA1",.F.)
							SA1->A1_NROPAG := SA1->A1_NROPAG-1  //Numero de Duplicatas
							If ( SE1->E1_BAIXA - SE1->E1_VENCREA) > 0
								SA1->A1_PAGATR := IiF(SA1->A1_PAGATR ==0,0,SA1->A1_PAGATR-SE1->E1_VALLIQ)   // Pagamentos Atrasados
								SA1->A1_ATR    := SA1->A1_ATR + SE1->E1_VALLIQ
								SA1->A1_METR   :=  (SA1->A1_METR * (SA1->A1_NROPAG+1) - (SE1->E1_BAIXA - SE1->E1_VENCREA)) / SA1->A1_NROPAG
							EndIf
							SA1->(MsUnlock())
						EndIf
						AtuSalDup("+",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,,SE1->E1_EMISSAO)
					EndIf
				EndIf
			next nX

			//Títulos gerados pela liquidação
			for nX := 1 to len(aSalDup2)
				SE1->(DbGoTo(aSalDup2[nX]))
				If SE1->(Recno()) == aSalDup2[nX]
					DbSelectArea("SA1")
					SA1->(DbSetOrder(1))
					If SA1->(MsSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA))
						AtuSalDup("-",SE1->E1_VALOR,SE1->E1_MOEDA,SE1->E1_TIPO,,SE1->E1_EMISSAO)
					EndIf
				endIf
			next nX
		endIf
	EndIf

	If lContinua .and. !lOpcAuto .And.  nOpct == 1 

		MsgInfo(STR0240) //"Liquidação cancelada com sucesso!"
		//Verifica se serão canceladas as simulações da liquidação.
		If MsgYesNo(STR0214 , STR0051) //"Deseja cancelar as simulações desta liquidação ?"###"Atenção"
			F460ABlqCan(3, xFilial("SE1"), cLiqCan) //Chama rotina de cancelamento
		Else
			F460ABlqCan(4, xFilial("SE1"), cLiqCan) //Retorna o Status presente no campo FO0_BKPSTT para todas as simulações.
		EndIf
	EndIf	

	//Metricas - Cancelamento da Liquidação
	If __lMetric .and. nRecProc > 0
		nFim := Seconds() - nInicio
		nFim := nFim / nRecProc
		SetFunName(__cFunMet)
		FwCustomMetrics():setAverageMetric(Alltrim(ProcName())+" - TempoGravacao", "financeiro-protheus_tempo-conclusão-processo_seconds", nFim)
		SetFunName(__cFunBkp)
	Endif

	//------------------------------------------------------------
	// Restaura a area do SE1                                    
	//------------------------------------------------------------
	If Select(cAliasTMPC) > 0
		DbSelectArea(cAliasTMPC)
		DbCloseArea()
	EndIf

	If Select("SE1") > 0
		DbSelectArea("SE1")
		DbCloseArea()
	EndIf

	DbSelectArea("SE1")
	RetIndex("SE1")
	Set Filter to

	DbSelectArea("SE1")
	DbSetOrder(nOrdemSE1)
	DbGoToP()
	fErase (cIndex+OrdBagExt())
	cIndex := ""

	If lPanelFin  //Chamado pelo Painel Financeiro						
		dbSelectarea(FinWindow:cAliasFile)
		FinVisual(FinWindow:cAliasFile,FinWindow,(FinWindow:cAliasFile)->(Recno()),.T.)	
	EndIf

Return (lContinua)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³ A460FCan   ³ Autor ³ Mauricio Pequim Jr    ³ Data ³ 02/02/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Seleo para a criao do indice condicional no CANCELAMENTO ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Fina460														³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A460FCan()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Devera selecionar todos os registros que atendam a seguinte condio : 	³
//ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
//³ 2. Ou titulos que tenham originado a liquidacao selecionada 						³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local cFiltro
cFiltro := 'E1_FILIAL = "'+xFilial("SE1")+'"  .And. '
cFiltro += 'E1_NUMLIQ = "'+cLiqCan+'" '

Return cFiltro

//-------------------------------------------------------------------
/*/{Protheus.doc} A460Filtra
Cancelamento da Liquidação

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	

/*/
//-------------------------------------------------------------------
Function A460Filtra(cLiqCan, cAliasTMPC, nTotalReg)

Local lRetOk 	:= .T.
Local cQueryE5	:= ""

Default nTotalReg	:= 0

//-----------------------------------------------------------------
// Variaveis para a funcao da barra de status do processamento     
//-----------------------------------------------------------------
A460CalCan(cLiqCan, @lRetOK, cAliasTMPC, @cQueryE5,, @nTotalReg)

Return(lRetOk)

//-------------------------------------------------------------------

 /*/{Protheus.doc} getBxLiq
	Identifica o FK1_IDFK1 da baixa de liquidação ativa para o processo em questão.
	@type  Function
	@author guilherme.sordi
	@since 18/08/2021
	@version 12.1.27
	@param idDoc, string, ID do documento SE1, oriundo de FK7_IDDOC
	@param idDoc, string, Número da liquidação oriundo de FO0_NUMLIQ
	@return IdFK1, string, Id da baixa ativa referente à liquidação
	@example
	(examples)
	@see (links_or_references)
	/*/
static Function getBxLiq(idDoc, cLiqCan)
	local idFK1 as character
	local cAlias1 as character

	local cCompFO2 as character
	local cCompSE1 as character
	local cCompFK7 as character

	idFK1 := ""
	cAlias1 := getNextAlias()

	BEGINSQL alias cAlias1
		SELECT FK1_IDFK1
		FROM %table:FK1% FK1
		WHERE FK1.%notDel%
		AND FK1_MOTBX = 'LIQ'
		AND FK1_DOC = %exp:cLiqCan%
		AND FK1_IDDOC = %exp:idDoc%
		AND NOT EXISTS(
			SELECT FK1EST.FK1_IDDOC 
			FROM %table:FK1% FK1EST
			WHERE FK1EST.FK1_FILIAL = FK1.FK1_FILIAL
			AND FK1EST.FK1_IDDOC = FK1.FK1_IDDOC
			AND FK1EST.FK1_SEQ = FK1.FK1_SEQ 
			AND FK1EST.FK1_TPDOC = 'ES'
			AND FK1EST.%notDel%
		)
		ORDER BY FK1_SEQ DESC
	ENDSQL
	if !(cAlias1)->(Eof())
		idFK1 := (cAlias1)->FK1_IDFK1
	endif	 
	(cAlias1)->(DbCloseArea())	

	if Empty(idFK1)
		cCompFO2 := getComp("FO2")
		cCompSE1 := getComp("SE1")
		cCompFK7 := getComp("FK7")
		if (cCompFO2 != cCompSE1) .and. (cCompFO2 = "EEE") .and. (cCompFK7 != cCompSE1)
			/*
			Nesse cenário, a função FINGRVFK7 chamada com cFilMov = NIL causava a gravação errada na FK7, com FK7_FILIAL preenchido como se fosse compartilhado
			quando na verdade a tabela é exclusiva. Exemplo: FK7 exclusiva gravando FK7_FILIAL = 'D MG '
			Isso gera duplicidade na FK7, deixando o FO1_IDDOC diferente de FK1_IDDOC, para o mesmo processo. Para simular, veja o caso de teste GTSER-T66876. FINXSE5 24/02/2022 e FINA040 18/02/2022.
			O que segue abaixo é uma solução de contorno temporária para a essa situação.
			*/
			BEGINSQL alias cAlias1
				SELECT FK1_IDFK1
				FROM %table:FK1% FK1
				JOIN %table:FK7% FK7
					ON FK1_IDDOC = FK7_IDDOC
					AND FK7.%notDel%
				JOIN %table:FK7% FK7ERRADA
					ON FK7.FK7_CHAVE = FK7ERRADA.FK7_CHAVE
					AND FK7.FK7_FILIAL <> FK7ERRADA.FK7_FILIAL
					AND FK7ERRADA.%notDel%
				JOIN %table:FO1% FO1
					ON FK7ERRADA.FK7_IDDOC = FO1_IDDOC
					AND FO1.%notDel%
				WHERE FK1.%notDel%
				AND FK1_MOTBX = 'LIQ'
				AND FK1_DOC = %exp:cLiqCan%
				AND FO1_IDDOC = %exp:idDoc%
				AND NOT EXISTS(
					SELECT FK1EST.FK1_IDDOC 
					FROM %table:FK1% FK1EST
					WHERE FK1EST.FK1_FILIAL = FK1.FK1_FILIAL
					AND FK1EST.FK1_IDDOC = FK1.FK1_IDDOC
					AND FK1EST.FK1_SEQ = FK1.FK1_SEQ 
					AND FK1EST.FK1_TPDOC = 'ES'
					AND FK1EST.%notDel%
				)
				ORDER BY FK1_SEQ DESC
			ENDSQL
			if !(cAlias1)->(Eof())
				idFK1 := (cAlias1)->FK1_IDFK1
			endif	 
			(cAlias1)->(DbCloseArea())
		endIf
	endIf

Return idFk1

 /*/{Protheus.doc} getComp
	Retorna string de três posições indicando o comportilhamento da tabela em questão, 
	sendo as posições na ordem: EMPRESA, UNIDADE, FILIAL
	@type  Function
	@author guilherme.sordi
	@since 03/03/2022
	@version 12.1.33
	@param cAlias, character, Alias da tabela em questão
	@return cComp, character, String indicando o compartilhamento. Exemplos: EEE, EEC, CCC
/*/
static function getComp(cAlias as character) as character
	local cComp as character
	local lQuery as logical

	if cAlias == NIL
		return ""
	endIf

	lQuery := .T.
	aComp := FwSX2Util():GetSX2Data(cAlias, {"X2_MODOEMP", "X2_MODOUN", "X2_MODO"}, lQuery)
	cComp := aComp[1][2] + aComp[2][2] + aComp[3][2]
return cComp

//-------------------------------------------------------------------
/*/{Protheus.doc} A460CalCan
Calcula Parcelas, Nro.Titulos e valor da Liquidação a cancelar

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	

/*/
//-------------------------------------------------------------------
Function A460CalCan(cLiqCan,lRetOk, cAliasTMPC, cAlsF465, lComF440, nTotalReg)

	Local cLstCart 	:= FN022LSTCB(1)	//Lista das situacoes de cobranca (Carteira)
	local cQuery		:= ''
	local aFields 		:= {}
	local cFilCan		:= ''
	local cAliasFind	:= GetNextAlias()
	Local cAlsTMP		:= ""
	Local nTcSql		:= 0
	local cProces		:= ''
	local aRec			:= {}
	local nRecSE1		:= 0
	local nRecSE5		:= 0
	local cAlias1		:= getNextAlias()
	local aSeqLiq		:= {}
	local cChaveFK1		:= ''
	local nX			:= 1
	local cCliente		:= ''
	local cLoja			:= ''
	local cCompFO2		:= getComp("FO2")
	local cCompSE1		:= getComp("SE1")
	local cOnFil		:= ''

	Default lRetOk		:= .T.
	Default cAlsF465	:= ""
	Default lComF440	:= .F.
	Default nTotalReg	:= 0
	
	GetMv('MV_NUMLIQ') 
	if Empty(SX6->X6_FIL)
		BEGINSQL alias cAliasFind
			SELECT FO0_FILIAL, FO0_PROCES, FO0_CLIENT, FO0_LOJA
			FROM %table:FO0%	
			WHERE %notDel% 
			AND FO0_NUMLIQ = %exp:cLiqCan%
			ORDER BY 2 DESC
		ENDSQL
	else
		BEGINSQL alias cAliasFind
			SELECT FO0_FILIAL, FO0_PROCES, FO0_CLIENT, FO0_LOJA
			FROM %table:FO0%	
			WHERE %notDel% 
			AND FO0_NUMLIQ = %exp:cLiqCan% 
			AND FO0_FILIAL = %exp:xFilial("FO0")%
			ORDER BY 2 DESC
		ENDSQL
	endif

	if (cAliasFind)->(Eof())
		lRetOK := .F.
	else
		cFilCan := (cAliasFind)->FO0_FILIAL
		cProces := (cAliasFind)->FO0_PROCES
		cCliente := (cAliasFind)->FO0_CLIENT
		cLoja := (cAliasFind)->FO0_LOJA
	endif	
	(cAliasFind)->(DbCloseArea())

	//Títulos que deram origem à liquidação
	BEGINSQL alias cAliasFind
		SELECT FO1_IDDOC
		FROM %table:FO1% FO1
		WHERE %notDel%
		AND FO1_FILIAL = %exp:cFilCan%
		AND FO1_PROCES = %exp:cProces%
	ENDSQL

	while !(cAliasFind)->(Eof())	
		nRecSE1 := 0
		nRecSE5 := 0
		cChaveFK1 := ''
		aSeqLiq := {}
		cIdDoc := (cAliasFind)->FO1_IDDOC
		if __nFinFix < 2 
			BEGINSQL alias cAlias1
				SELECT SE1.R_E_C_N_O_ REC
				FROM %table:FK7% FK7
				INNER JOIN %table:SE1% SE1
					ON E1_FILIAL || '|' ||  E1_PREFIXO || '|' || E1_NUM || '|' || E1_PARCELA || '|' || E1_TIPO || '|' || E1_CLIENTE || '|' || E1_LOJA = FK7_CHAVE
				WHERE SE1.%notDel%
				AND FK7.%notDel%
				AND FK7_IDDOC = %exp:cIdDoc%
			ENDSQL
		else
			BEGINSQL alias cAlias1
				SELECT SE1.R_E_C_N_O_ REC
				FROM %table:FK7% FK7
				INNER JOIN %table:SE1% SE1
					ON E1_FILIAL = FK7_FILTIT
					AND E1_PREFIXO = FK7_PREFIX
					AND E1_NUM = FK7_NUM
					AND E1_PARCELA = FK7_PARCEL
					AND E1_TIPO = FK7_TIPO
					AND E1_CLIENTE = FK7_CLIFOR
					AND E1_LOJA = FK7_LOJA
				WHERE SE1.%notDel%
				AND FK7.%notDel%
				AND FK7_IDDOC = %exp:cIdDoc%
			ENDSQL	
		endif
		nRecSE1 := (cAlias1)->REC
		(cAlias1)->(DbCloseArea())

		cChaveFK1:= getBxLiq(cIdDoc,cLiqCan)
		
		BEGINSQL alias cAlias1
			SELECT SE5.R_E_C_N_O_ REC
			FROM %table:SE5% SE5
			WHERE SE5.%notDel%
			AND E5_TABORI = 'FK1'
			AND E5_IDORIG = %exp:cChaveFK1%
			AND E5_TIPODOC = 'BA'
		ENDSQL
		nRecSE5 := (cAlias1)->REC
		(cAlias1)->(DbCloseArea())

		aAdd(aRec,{nRecSE1, nRecSE5})
		(cAliasFind)->(DbSkip())
	enddo
	(cAliasFind)->(DbCloseArea())

	
	//Títulos gerados pela liquidação
	if cCompFO2 = cCompSE1 
		cOnFil := "FO2_FILIAL = E1_FILIAL"
	elseIf cCompFO2 = "EEE"
		cOnFil := "FO2_FILIAL = E1_FILORIG"
	else
		//Se o compartilhamento é diferente e FO2 não é exclusivo, não é possível relacionar com SE1. Pendente Spike para resolver essa situação.
		//Documentação atual diz que FO0, FO1 e FO2 devem ter o mesmo compartilhamento da SE1.
		//Mais detalhes, vaje a descrição da issue DFINCOM-12733 (03/03/2022).
		lRetOk := .F.
		Help(" ",1,"FO2SE1COMPERR")
	endIf
	cOnFil := "%" + cOnFil + "%"		
	
	if lRetOK
		BEGINSQL alias cAliasFind
			SELECT SE1.R_E_C_N_O_ REC
			FROM %table:FO2% FO2
			JOIN %table:SE1% SE1
				ON %exp:cOnFil% 
				AND FO2_PREFIX = E1_PREFIXO
				AND FO2_NUM = E1_NUM
				AND FO2_PARCEL = E1_PARCELA
				AND FO2_TIPO = E1_TIPO
			WHERE FO2.%notDel%
			AND SE1.%notDel%
			AND FO2_FILIAL = %exp:cFilCan%
			AND FO2_PROCES = %exp:cProces%
		ENDSQL
		while !(cAliasFind)->(Eof())	
			nRecSE1 := (cAliasFind)->REC
			aAdd(aRec,{nRecSE1, nRecSE1})
			(cAliasFind)->(DbSkip())
		enddo
		(cAliasFind)->(DbCloseArea())	

		//NCC gerada pela liquidação
		BEGINSQL alias cAliasFind
			SELECT SE1.R_E_C_N_O_ REC
			FROM %table:SE1% SE1
			WHERE SE1.%notDel%
			AND E1_FILIAL = %exp:cFilCan%
			AND E1_PREFIXO = 'LIQ'
			AND E1_NUM = %exp:cLiqCan%
			AND E1_TIPO = %exp:MV_CRNEG%
			AND E1_CLIENTE = %exp:cCliente%
			AND E1_LOJA = %exp:cLoja%
			AND E1_NUMLIQ = %exp:cLiqCan%
			AND E1_ORIGEM = 'FINA460'
		ENDSQL
		while !(cAliasFind)->(Eof())	
			nRecSE1 := (cAliasFind)->REC
			aAdd(aRec,{nRecSE1, nRecSE1})
			(cAliasFind)->(DbSkip())
		enddo
		(cAliasFind)->(DbCloseArea())	
	endIf
	
	If __oTmpSE5 <> Nil
		//-- Limpa registros para nova execução
		cAlsTMP := __oTmpSE5:GetAlias()		
		nTcSql := TcSQLExec("DELETE FROM " + __oTmpSE5:GetRealName() )
		If nTcSql < 0
			//-- Se ocorrer algum problema refaz a temporaria
			__oTmpSE5:Delete()
			__oTmpSE5 := Nil
		Else // Necessária para atualização do Alias após deleção dos dados 
			(cAlsTMP)->(dbGoTo(1))
		EndIf
	EndIf
	If __oTmpSE5 == Nil
		cAlsTMP	:= GetNextAlias()
		//Cria Alias Temporário com os RECNOs a excluir
		__oTmpSE5 := FWTemporaryTable():New(cAlsTMP)	
		AADD(aFields,{"CHAVE",	"N", 10, 0})
		AADD(aFields,{"CHAVESE5",	"N", 10, 0})
		__oTmpSE5:SetFields(aFields)
		__oTmpSE5:Create()
	
	EndIf

	for nX := 1 to len(aRec)
		(cAlsTMP)->(dbAppend())
		(cAlsTMP)->CHAVE := aRec[nx][1]
		(cAlsTMP)->CHAVESE5 := aRec[nx][2]
		(cAlsTMP)->(dbCommit())
	next nX
	
	cQuery := "SELECT CHAVE, CHAVESE5 FROM " + __oTmpSE5:GetRealName()
	cAlsF465 := cQuery
	
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasTMPC, .F., .T.)
	DbSelectArea(cAliasTMPC)

	//--------------------------------------------------------------------------
	// Certifica se foram encontrados registros na condicão selecionada		
	//--------------------------------------------------------------------------
	If Bof() .and. Eof()
		If !lComF440
			Help(" ",1,"RECNO")
		Endif
		//--------------------------------------------------------------------------
		// Restaura os indices do SE1 e deleta o arquivo de trabalho			
		//--------------------------------------------------------------------------
		If Select(cAliasTMPC) > 0
			DbSelectArea(cAliasTMPC)
			DbCloseArea()
		EndIf

		If Select("SE1") > 0
			DbSelectArea("SE1")
			DbCloseArea()
		EndIf

		DbSelectArea("SE1")
		RetIndex("SE1")
		DBClearFilter()
		DbSetOrder(1)
		DbGoTop()
		lRetOk:= .F.
	EndIf

	If lRetOk
		While (cAliasTMPC)->(!Eof())
			dbSelectArea(cAliasTMPC)
			SE1->(dbGoto((cAliasTMPC)->CHAVE))
			(cAliasTMPC)->(dbSkip())
			DbSelectArea("SE1")
			nTotalReg += 1
			//--------------------------------------------------------------------------
			// Caso tenha ocorrido a baixa de alguma parcela da liquidação , nao  
			// sera possivel a operação de cancelamento.						   
			//--------------------------------------------------------------------------
			If SE1->E1_NUMLIQ == cLiqCan .And. ;
					Str(SE1->E1_SALDO,17,2) != Str(SE1->E1_VALOR,17,2)

				Help(" ",1,"LIQJABX")   // Nao aceita se ja houve baixa em liquidacao
				lRetOk := .F.
				Exit
			EndIf
			If SE1->E1_NUMLIQ == cLiqCan .and. !(SE1->E1_SITUACA $ cLstCart) .and. ;
					(!Empty(SE1->E1_BCOCHQ) .and. SE1->E1_STATUS != "R" )
				Help(" ",1,"TITINCOB")
				lRetOk := .F.
				Exit
			EndIf
		End		
	EndIf

	If Select (cAliasTMPC) > 0 .and. !FwIsInCallStack("FINA460")
		(cAliasTMPC)->(DbCloseArea())
	Endif

Return lRetOk

//-------------------------------------------------------------------
/*/{Protheus.doc} A460Natur
Validacao da Natureza

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
																				
/*/
//-------------------------------------------------------------------
Function A460Natur(cNatureza)
Local lRet := .T.
//294 - Natureza sintetica/Analitica
Local lNatSa     := FNatSAIsOn()

DbSelectArea("SED")
If !(MsSeek(xFilial("SED")+cNatureza)) .or. Empty (cNatureza)
	HELP(" ",1,"F460NATUREZ", , STR0261 ,2,0,,,,,,{ STR0262 }) //"Código da natureza utilizado para identificar a procedência dos títulos, não é um código permitido para consolidação e nem para controle orçamentário." # "Informe Código de Natureza Valida"
	lRet := .F.
EndIf

//294 - Natureza sintetica/Analitica
If lRet .and. lNatSA .and. !FinVldNat( .F., cNatureza, 1 )
	lRet := .F.
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FA460Tipo
Validacao do tipo de titulo informado

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
																				
/*/
//-------------------------------------------------------------------

Function FA460Tipo(cCampo as Character,cCpoVld as Character) as Logical

Local lRetorna	as Logical
Local nX 		as Numeric
Local nLinAtu	as Numeric
Local oModel 	As Object
Local oView		As Object
Local oModelFO0	As Object
Local oSubFO1 	As Object
Local oSubFO2 	As Object
Local cNum		as Character
Local cPrefixo	as Character
Local cParcela	as Character
Local cTipo		as Character
Local cFilOrig	as Character
Local nGetLine	as Numeric
Local cParc2Ger as Character
Local cTipoTit  as Character


lRetorna	:= .T.
nX 			:= 0
nLinAtu		:= 0 
oModel 		:= FWModelActive()
oView		:= FWViewActive()
oModelFO0	:= oModel:GetModel('MASTERFO0')
oSubFO1 	:= oModel:GetModel("TITSELFO1")
oSubFO2 	:= oModel:GetModel("TITGERFO2")
cNum		:= oSubFO2:GetValue("FO2_NUM")
cPrefixo	:= oSubFO2:GetValue("FO2_PREFIX")
cParcela	:= oSubFO2:GetValue("FO2_PARCEL")
cTipo		:= oSubFO2:GetValue("FO2_TIPO")
cFilOrig	:= oSubFO1:GetValue("FO1_FILORI")
nGetLine	:= oSubFO2:GetLine()
cParc2Ger 	:= cMV1Dup()
cTipoTit  	:= ""


Default cCampo  := "1"
Default cCpoVld := "0"

If cCampo == "1"
	cTipo := oModelFO0:GetValue("FO0_TIPO")
Else
	cTipo := oSubFO2:GetValue("FO2_TIPO")
EndIf

If nTamParc == NIL
	nTamParc := TamSx3("E1_PARCELA")[1]
Endif

If nTamParc > Len(cParc2Ger)
	cParc2Ger := cParc2Ger + SPACE( nTamParc-Len(cParc2Ger) )
ElseIf nTamParc < Len(cParc2Ger)	
	cParc2Ger := Substr(cParc2Ger,1,nTamParc)
EndIf

If !Empty(cTipo)
	DbSelectArea("SX5")
	If !MsSeek(cFilial+"05"+cTipo)
		oModel:SetErrorMessage("",,oModel:GetId(),"","A460TPNAOEXISTE",STR0256 + CRLF + STR0257 + " " + cTipo) //"Codigo do Tipo não existe em tabela. Por favor, verifique." # "Codigo Tipo" 
		lRetorna := .F.
	Else
		If cTipo $ MVPAGANT+"/"+MV_CPNEG
			oModel:SetErrorMessage("",,oModel:GetId(),"","TIPODOC") //"Codigo do Tipo não existe em tabela. Por favor, verifique." # "Codigo Tipo" 
			lRetorna := .F.
		ElseIf cTipo $ MVRECANT+"/"+MVTAXA+"/"+MV_CRNEG .or. cTipo $ MVABATIM
			oModel:SetErrorMessage("",,oModel:GetId(),"","TIPODOC") //"Codigo do Tipo não existe em tabela. Por favor, verifique." # "Codigo Tipo" 
			lRetorna := .F.
		EndIf
	EndIf

	If lRetorna
		lRetorna := A460PreNum(cCampo, , @cNum)
	EndIf
	
	If lRetorna
		
		nLinAtu	:= oSubFO2:GetLine()
		If Empty(cPrefixo) .And. !Empty(MV_PAR08)
			cPrefixo := Upper(MV_PAR08)
		EndIf
		If cCampo == "1"
			If Empty(cNum)
				cNum := a460PrxNum(cFilOrig,cTipo,cPrefixo)
			Endif
			For nX := 1 To oSubFO2:Length() 
				oSubFO2:Goline(nX)
				If Alltrim(cTipo) <> AllTrim(MVCHEQUE)
			
					oSubFO2:LoadValue("FO2_NUMCH","")
					oSubFO2:LoadValue("FO2_EMITEN","")
					oSubFO2:LoadValue("FO2_BANCO","")
					oSubFO2:LoadValue("FO2_AGENCI","")
					oSubFO2:LoadValue("FO2_CONTA","")
				EndIf
				If nPergRepl == 1 .Or. nPergRepl == 0
					oSubFO2:LoadValue("FO2_TIPO",cTipo)
					oSubFO2:LoadValue("FO2_NUM" ,cNum )
				ElseIf nPergRepl == 2
					Exit			
				Endif
			Next
		ElseIf  cCampo == "5"
						
			If !lOpcAuto
				If nPergRepl == 0 .And. cCpoVld == cCampo
					If MsgYesNo(STR0260,STR0051)// "Deseja replicar a informação para as linhas abaixo?. Essa pergunta será exibida somente no próximo acesso."
						nPergRepl := 1 // Sim
					Else
						nPergRepl := 2 // não
					Endif
				Endif
			Endif	
			If Empty(cNum)
				cNum := a460PrxNum(cFilOrig,cTipo,cPrefixo)
			Endif
			cTipo := oSubFO2:GetValue("FO2_TIPO")
				
			For nX := nLinAtu To oSubFO2:Length() 
				
				oSubFO2:Goline(nX)
				
				cPrefixo	:= oSubFO2:GetValue("FO2_PREFIX")
				cParcela	:= oSubFO2:GetValue("FO2_PARCEL")
					
				If F460VldCar(cTipoTit, cNum, cPrefixo, cParcela, cTipo )
					If F460VldE1(cPrefixo, cNum, cParcela, cTipo )
						oModel:SetErrorMessage("",,oModel:GetId(),"","A460EXISTE",STR0220 + CRLF + " " + CRLF + STR0069 + " - " + oSubFO2:GetValue("FO2_PREFIX") + CRLF + STR0168 + " - ";
						+ oSubFO2:GetValue("FO2_NUM") + CRLF + STR0258 + " - " + oSubFO2:GetValue("FO2_PARCEL") + CRLF + STR0163 + " - " + oSubFO2:GetValue("FO2_TIPO") )
						lRet := .F.
						Exit
					Endif
				Else
					oModel:SetErrorMessage("",,oModel:GetId(),"","A460CARACTER",STR0259 + CRLF + " "   )
					lRet := .F.
					Return lRet
				Endif

				If Alltrim(cTipo) <> AllTrim(MVCHEQUE)
					oSubFO2:LoadValue("FO2_NUMCH","")
					oSubFO2:LoadValue("FO2_EMITEN","")
					oSubFO2:LoadValue("FO2_BANCO","")
					oSubFO2:LoadValue("FO2_AGENCI","")
					oSubFO2:LoadValue("FO2_CONTA","")
				EndIf
				
				If nPergRepl == 1 .or. nX == nLinAtu
					oSubFO2:LoadValue("FO2_TIPO",cTipo)
					oSubFO2:LoadValue("FO2_NUM" ,cNum )
				Endif
				
				If nPergRepl == 2
					Exit
				EndIf
			Next		
		Else
			If Alltrim(cTipo) <> AllTrim(MVCHEQUE)
				oSubFO2:LoadValue("FO2_NUMCH","")
				oSubFO2:LoadValue("FO2_EMITEN","")
				oSubFO2:LoadValue("FO2_BANCO","")
				oSubFO2:LoadValue("FO2_AGENCI","")
				oSubFO2:LoadValue("FO2_CONTA","")
			EndIf
			oSubFO2:LoadValue("FO2_TIPO",cTipo)
		EndIf
		If !lOpcAuto	
			If cCampo == "1"
				oSubFO2:GoLine(1)
			Else
				oSubFO2:GoLine(nGetLine)
			Endif
			oView:Refresh()
		EndIf
	EndIf
EndIf

If lRetorna
	oSubFO1:GoLine(1)
EndIf

Return lRetorna

//-------------------------------------------------------------------
/*/{Protheus.doc} FA460GerAr
Gera arquivo de trabalho

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
																				
/*/
//-------------------------------------------------------------------
Function Fa460Gerarq(aCampos, cAliasTMP )

Static oTmpTabFO1

If InTransaction()
	xRet := DBCreate( cAliasTMP , aCampos, "SQLITE_TMP" )
	DBUseArea( .T., 'SQLITE_TMP', cAliasTMP, cAliasTMP, .F., .F. )

	DBCreateIndex(cAliasTMP+"1", "CHAVE"  )

Else
	//-------------------
	//Criação do objeto
	//-------------------
	If oTmpTabFO1 <> Nil
		//-- Limpa registros para nova execução		
		nTcSql := TcSQLExec("DELETE FROM " + oTmpTabFO1:GetRealName() )
		If nTcSql < 0
			//-- Se ocorrer algum problema refaz a temporaria
			oTmpTabFO1:Delete()
			oTmpTabFO1 := Nil
		Else // Necessária para atualização do Alias após deleção dos dados 
			(cAliasTMP)->(dbGoTo(1))
		EndIf

	EndIf
	If oTmpTabFO1 == Nil		
	
		oTmpTabFO1 := FWTemporaryTable():New(cAliasTMP)
		oTmpTabFO1:SetFields( aCampos )
		oTmpTabFO1:AddIndex("1", {"CHAVE"} )
		oTmpTabFO1:AddIndex("2", {"CHAVE2"} )
		
		//------------------
		//Criação da tabela
		//------------------
		oTmpTabFO1:Create()
	EndIf
EndIf
Return cAliasTMP


//-------------------------------------------------------------------
/*/{Protheus.doc} Fa460OK1
Funcao que realiza a validacao do usuario na primeira tela
da Liquidação

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
																				
/*/
//-------------------------------------------------------------------
Static Function Fa460OK1()
Local lRet    := .T.
Local lIntPFS := lJurXFin()

//639.04 Base Impostos diferenciada
Local lBaseImp		:= F040BSIMP(2)

if __lF460OK1 == NIL
	__lF460OK1 := ExistBlock("F460OK1")
endIf
If __lF460OK1 
	lRet := ExecBlock("F460OK1",.f.,.f.)
EndIf

// Se Portugal, pega cod. Diario
If UsaSeqCor() .AND. lRet
	lRet := Fa460OK2()
EndIf

If lRet
	If cCliAte < cCliDe
		IW_MsgBox( STR0184, STR0051, "STOP" )	// "O código <Cliente Ate> deve ser maior ou igual ao código <Cliente De>."###"Atenção"
		oCliAte:SetFocus()
		lRet := .F.
	ElseIf cCliAte == cCliDe .And. cLojaAte < cLojaDe
		IW_MsgBox( STR0185, STR0051, "STOP" )	// "O código <Loja Ate> deve ser maior ou igual ao código <Loja De>."###"Atenção"
		oLojaAte:SetFocus()
		lRet := .F.
	EndIf
EndIf

//639.04 Base Impostos diferenciada
If lRet .and. lBaseImp
	lRet := A460NATUR(cNatureza)
EndIf

If lRet .And. lIntPFS .And. !ChkFile("OHT")
	If (Empty(cEscrit) .And. !Empty(cFatura)) .Or. (Empty(cFatura) .And. !Empty(cEscrit))
		Help(" ", 1, STR0264,, STR0276, 2, 0,,,,,,{ STR0277 }) //"Não Permitido" # "Chave da fatura incompleta!" # "Preencha o escritório e a fatura ou mantenha os dois campos vazios."
		lRet := .F.
	EndIf
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa460OK2
Funcao que solicita cod. diario para Portugal

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
																				
/*/
//-------------------------------------------------------------------
Static Function Fa460OK2()

lRetOK2 := .T.

If UsaSeqCor()
	cCodDiario := CTBAVerDia() 
EndIf

Return lRetOK2


//-------------------------------------------------------------------
/*/{Protheus.doc} F460CMC7
Programa destinado a efetuar a leitura de cheques a partir da 
leitora CMC7 e alimentar a rotina de liquidacao.

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
																				
/*/
//-------------------------------------------------------------------
Function F460CMC7( oModel )

Local lContinua		:= .T.			// Flag da leitura quando for por dispositivo serial
Local nNumCH		:= 1			// Numeral do cheque (qual cheque esta sendo lido. Se primeiro, segundo etc)
Local aCMC7			:= {}			// Array que guardara os dados do cheque vindos da leitora
Local dVenc460		:= dDataBase    // Data inicial do cheque
Local nValChq460	:= 0			// Valor inicial do cheque
Local cEmiten460	:= Space(40)	// Nome do emitente do cheque 
Local aCmc7Tc 		:= {}			// Armazena o retorno da funcao F460Cmc7Tc
Local nX			:= 2            // Variavel para comparar com o tamanho do aCols
Local lContLeit		:= .T.			// Verifica se a leitura (teclado) acabou ou nao
Local oModelFO0 	:= oModel:GetModel('MASTERFO0')
Local oModelFO2 	:= oModel:GetModel('TITGERFO2')
Local lCond 		:= .T.	
local lFa460Cmc7	:= l460Cmc7()
Local cDescCond   	:= ""
Local aAuxCond    	:= {}
Local aAuxParc		:= {}
Local nQtdCond      
Local nCountPag   	:= 0
Local nTotNeg 		:= 0
Local cParcel		:= ""
Local cParcAux		:= ""
Local cNumCH		:= ""
Local nPosScan		:= 0
Local nTamParc		:= TamSX3("FO2_PARCEL")[1]
Local cPrefFO2		:= Upper(oModelFO2:GetValue("FO2_PREFIX")) 
Local cMVPAR08		:= Alltrim(Upper(MV_PAR08))

If Empty(cPrefFO2) //Prioriza o inicializador padrão do campo
	cPrefFO2 := cMVPAR08
Endif

SE4->(DbSetOrder(1) )
If SE4->( DbSeek( xFilial("SE4")+Alltrim(oModelFO0:GetValue("FO0_COND") ) ) )
	cDescCond   := SE4->E4_COND
    aAuxCond    := STRTOKARR(cDescCond, ',')         
                
	If SE4->E4_TIPO == "1" // Tratamento para as condições de tipo 1 ao 7
		nQtdCond	:=	Len(aAuxCond)
    ElseIf SE4->E4_TIPO == "2"
        nQtdCond	:= Val(SubStr(SE4->E4_CODIGO,2,1))
    ElseIf SE4->E4_TIPO == "5"
        nQtdCond   	:= Val(aAuxCond[2])
    ElseIf SE4->E4_TIPO $ "3467"
        nQtdCond   	:= Val(aAuxCond[1])
    EndIf
EndIf

oModelFO2:SetNoInsertLine(.F.)
oModelFO2:SetNoDeleteLine(.F.)

If nHdlCMC7 < 0
	lContinua := .F. 	
	//---------------------------------------------------------
	// Leitura do cheque utilizando leitor via teclado
	//---------------------------------------------------------
	While lContLeit
		nCountPag++
			If oModelFO2:Length() = 1 .And. Empty( oModelFO2:GetValue("FO2_BANCO") ) .And. Empty( oModelFO2:GetValue("FO2_VENCTO") ) 
			aCmc7Tc		:= F460Cmc7Tc()
			If Len( aCmc7Tc ) > 0
				oModelFO2:GoLine(1)
				If !Empty(oModelFO2:GetValue("FO2_VALOR")) 
					nValChq460 := oModelFO2:GetValue("FO2_VALOR")
				EndIf	
				If F460GetChq(aCmC7Tc,@dVenc460,@nValChq460,@cEmiten460)
		    		//ALTERAR PARA O MODEL - DIEGO 30-10-2015
					oModelFO2:LoadValue("FO2_PREFIX" , cPrefFO2	)		    	
					oModelFO2:LoadValue("FO2_TIPO"   , "CH"	)
					oModelFO2:LoadValue("FO2_FILIAL" , Pad(cFilAnt,Len(oModelFO2:GetValue("FO2_FILIAL"))))					    	
					oModelFO2:LoadValue("FO2_BANCO"  , aCmc7Tc[1] )
					oModelFO2:LoadValue("FO2_AGENCI" , aCmc7Tc[3] )
					oModelFO2:LoadValue("FO2_CONTA"  , aCmc7Tc[4] )
					oModelFO2:LoadValue("FO2_NUMCH"  , Pad(aCmc7Tc[2],Len(oModelFO2:GetValue("FO2_NUM"))) )
					oModelFO2:LoadValue("FO2_NUM"  	 , Pad(aCmc7Tc[2],Len(oModelFO2:GetValue("FO2_NUM"))) )
					oModelFO2:LoadValue("FO2_VALOR"  , nValChq460 )
					oModelFO2:LoadValue("FO2_VLPARC" , nValChq460 )	
					oModelFO2:LoadValue("FO2_EMITEN" , cEmiten460 )
					oModelFO2:LoadValue("FO2_VENCTO" , dVenc460	 )
					oModelFO2:LoadValue("FO2_TOTAL"	 , nValChq460 )

					cParcAux	:= oModelFO2:GetValue("FO2_PARCEL")
					cParcel		:= cParcAux 
					If Empty(cParcel)
						cParcel := a460PrxPrc( aCmc7Tc[2] ,oModelFO2:GetValue("FO2_PREFIX"),  nTamParc )
					Endif

					oModelFO2:LoadValue("FO2_PARCEL" , cParcel )
					Aadd(aAuxParc, {oModelFO2:GetValue("FO2_NUMCH"), cParcel})
					nTotNeg += nValChq460

					If lFa460Cmc7
						oModelFO2 := ExecBlock("FA460CMC7", .F., .F., {oModelFO2} )
					EndIf
				EndIf	
			EndIf
		EndIf

		If IW_MsgBox(STR0125,STR0001,"YESNO")	//"Deseja incluir mais cheques?"###"Liquidação"
			aCmc7Tc	:= F460Cmc7Tc()

			If Len( aCmc7Tc ) > 0
			
				If !(oModelFO2:SeekLine({{"FO2_BANCO",aCmc7Tc[1]}, {"FO2_AGENCI",aCmc7Tc[3]}, {"FO2_CONTA",aCmc7Tc[4]}, {"FO2_NUMCH",aCmc7Tc[2]}} ))
					If nX <= oModelFO2:Length()//Len( aCols )
						If !Empty( oModelFO2:GetValue("FO2_VALOR") )
							nValChq460 := oModelFO2:GetValue("FO2_VALOR")
						EndIf
					EndIf	
					If F460GetChq(aCmC7Tc,@dVenc460,@nValChq460,@cEmiten460)
					
						aSort(aAuxParc)
						cNumCH   := Pad(aCmc7Tc[2],Len(oModelFO2:GetValue("FO2_NUM") ))
						nPosScan := aScan(aAuxParc, { |x| UPPER(x[1]) = UPPER(cNumCH)})

						If nPosScan > 0
							cParcel := Soma1(aAuxParc[nPosScan,2])
							aAuxParc[nPosScan,2] := cParcel
						Else
							cParcel := cParcAux
							If Empty(cParcel)
								cParcel :=  a460PrxPrc( aCmc7Tc[2] ,oModelFO2:GetValue("FO2_PREFIX"),  nTamParc )
							Endif
							Aadd(aAuxParc, {cNumCH, cParcel})
						Endif
											
						If Empty( cCondicao ) .OR. oModelFO2:Length() = 1 .OR. nX > oModelFO2:Length() .OR. !lCond				
							oModelFO2:AddLine()
							oModelFO2:LoadValue("FO2_PREFIX" , cPrefFO2	)
							oModelFO2:LoadValue("FO2_TIPO"   , "CH")
							oModelFO2:LoadValue("FO2_FILIAL" , Pad(cFilAnt,Len(oModelFO2:GetValue("FO2_FILIAL"))))						    		
							oModelFO2:LoadValue("FO2_BANCO"  , aCmc7Tc[1] )
							oModelFO2:LoadValue("FO2_AGENCI" , aCmc7Tc[3] )
							oModelFO2:LoadValue("FO2_CONTA"  , aCmc7Tc[4] )
							oModelFO2:LoadValue("FO2_NUMCH"  , Pad(aCmc7Tc[2],Len(oModelFO2:GetValue("FO2_NUM"))) )
							oModelFO2:LoadValue("FO2_NUM" 	 , Pad(aCmc7Tc[2],Len(oModelFO2:GetValue("FO2_NUM"))) )
							oModelFO2:LoadValue("FO2_VALOR"  , nValChq460 )
							oModelFO2:LoadValue("FO2_VLPARC" , nValChq460 )
							oModelFO2:LoadValue("FO2_EMITEN" , cEmiten460 )
							oModelFO2:LoadValue("FO2_VENCTO" , dVenc460	 )
							oModelFO2:LoadValue("FO2_ACRESC" , 0	)
							oModelFO2:LoadValue("FO2_DECRES" , 0	)
							oModelFO2:LoadValue("FO2_TOTAL"	 , nValChq460 )
							oModelFO2:LoadValue("FO2_PARCEL" , cParcel )
	
							nTotNeg += nValChq460
	
							lCond := .F.
						ElseIf lCond
							oModelFO2:LoadValue("FO2_PREFIX" , cPrefFO2	)
							oModelFO2:LoadValue("FO2_TIPO"   , "CH"	)					
							oModelFO2:LoadValue("FO2_FILIAL" , Pad(cFilAnt,Len(SE1->E1_PREFIXO)) )
							oModelFO2:LoadValue("FO2_BANCO"  , aCmc7Tc[1])
							oModelFO2:LoadValue("FO2_AGENCIA", aCmc7Tc[3])
							oModelFO2:LoadValue("FO2_CONTA"	 , aCmc7Tc[4])
							oModelFO2:LoadValue("FO2_NUMCH"	 , Pad(aCmc7Tc[2],Len(SE1->E1_NUM)) )
							oModelFO2:LoadValue("FO2_NUM"    , Pad(aCmc7Tc[2],Len(SE1->E1_NUM)) )
							oModelFO2:LoadValue("FO2_VALOR"	 , nValChq460)
							oModelFO2:LoadValue("FO2_VLPARC" , nValChq460 )							
							oModelFO2:LoadValue("FO2_EMITEN" , cEmiten460)
							oModelFO2:LoadValue("FO2_TOTAL"	 , nValChq460 )
							oModelFO2:LoadValue("FO2_PARCEL" , cParcel )	
							
							nTotNeg += nValChq460													  				
	
							If oModelFO2:GetValue("FO2_VENCTO") <> dVenc460			// Vencimento
								oModelFO2:LoadValue("FO2_VENCTO", dVenc460)//dVenc460
							Else
								oModelFO2:LoadValue("FO2_VENCTO", dVenc460)//dVenc460
							EndIf
							nX++  	
						EndIf			
						If lFa460Cmc7
							oModelFO2  := ExecBlock("FA460CMC7", .F., .F., {oModelFO2} )
						EndIf
					Endif
				Else
					IW_MsgBox(STR0124,STR0051,"STOP")	//""Cheque já Incluído ! Será Desprezado.""###"Atenção"	
				EndIf
			EndIf		
		Else
			lContLeit := .F.					
		EndIf	
		Loop
	End	
EndIf                              

While lContinua
	aCmc7 := {}
	aCmc7 := LjLeCmc7(nNumCH)
	If Len(aCmc7) > 0
		dVenc460		:= dDataBase
		nValChq460	:= 0
		If F460GetChq(aCmC7,@dVenc460,@nValChq460,@cEmiten460)
			If nNumCH == 1  // Se for o primeiro
				oModelFO2:LoadValue("FO2_PREFIX" , cPrefFO2	)
				oModelFO2:LoadValue("FO2_TIPO"   , "CH"	)
				oModelFO2:LoadValue("FO2_FILIAL" , Pad(cFilAnt,Len(SE1->E1_PREFIXO)) )		    		
				oModelFO2:LoadValue("FO2_BANCO"  , aCmc7[1])
				oModelFO2:LoadValue("FO2_AGENCIA", aCmc7[3])
				oModelFO2:LoadValue("FO2_CONTA"	 , aCmc7[4])
				oModelFO2:LoadValue("FO2_NUMCH"	 , Pad(aCmc7[2],Len(SE1->E1_NUM)) )
				oModelFO2:LoadValue("FO2_NUM"	 , Pad(aCmc7[2],Len(SE1->E1_NUM)) )
				oModelFO2:LoadValue("FO2_VALOR"	 , nValChq460)
				oModelFO2:LoadValue("FO2_VLPARC" , nValChq460 )	
				oModelFO2:LoadValue("FO2_EMITEN" , cEmiten460)
				oModelFO2:LoadValue("FO2_ACRESC" , 0	)							  				
				oModelFO2:LoadValue("FO2_DECRES" , 0	)
				oModelFO2:LoadValue("FO2_TOTAL"	 , nValChq460 )		    					

				nTotNeg += nValChq460
			
				nNumCH++
				If lFa460Cmc7
					oModelFO2 := ExecBlock("FA460CMC7", .F., .F., {oModelFO2} )
				EndIf
			Else
				//Pesquisa se cheque ja foi lido anteriormente (Banco/Agencia/Conta/Nro.Cheque)					
				If !(oModelFO2:SeekLine({{"FO2_BANCO",aCmc7Tc[1]}, {"FO2_AGENCI",aCmc7Tc[3]}, {"FO2_CONTA",aCmc7Tc[4]}, {"FO2_NUMCH",aCmc7Tc[2]}} ))
					oModelFO2:AddLine()
					oModelFO2:LoadValue("FO2_PREFIX", cPrefFO2	)
					oModelFO2:LoadValue("FO2_TIPO"  , "CH"	)
					oModelFO2:LoadValue("FO2_FILIAL", Pad(cFilAnt,Len(SE1->E1_PREFIXO)) )						
					oModelFO2:LoadValue("FO2_BANCO"	, aCmc7[1])
					oModelFO2:LoadValue("FO2_AGENCI", aCmc7[3])									 
					oModelFO2:LoadValue("FO2_CONTA" , aCmc7[4])
					oModelFO2:LoadValue("FO2_NUMCH"	, Pad(aCmc7[2],Len(SE1->E1_NUM)))
					oModelFO2:LoadValue("FO2_NUM"	, Pad(aCmc7[2],Len(SE1->E1_NUM)))
					oModelFO2:LoadValue("FO2_VENCTO", dVenc460)
					oModelFO2:LoadValue("FO2_EMITEN", cEmitent)									 
					oModelFO2:LoadValue("FO2_VALOR"	, nValChq460)
					oModelFO2:LoadValue("FO2_VLPARC", nValChq460 )
					oModelFO2:LoadValue("FO2_TOTAL"	, nValChq460 )
					oModelFO2:LoadValue("FO2_ACRESC", 0)									 
					oModelFO2:LoadValue("FO2_DECRES", 0)

					nTotNeg += nValChq460
					nNumCH++

					If lFa460Cmc7
						oModelFO2 := ExecBlock("FA460CMC7", .F., .F., {oModelFO2} )
					EndIf
				Else
					IW_MsgBox(STR0124,STR0051,"STOP") //"Cheque já Incluído ! Será Desprezado."###"Atenção"
				EndIf
			EndIf
		EndIf
		If !IW_MsgBox(STR0125,STR0001,"YESNO") //"Deseja incluir mais cheques?"###"Liquidação"
			Exit
		EndIf
	Else
		If IW_Msgbox(STR0126,STR0051,"YESNO")  //"Encerra leitura de Cheques ?"###"Atenção"
			Exit
		EndIf
	EndIf
End

oModelFO0:LoadValue("FO0_VLRNEG" , nTotNeg )

oModelFO2:SetNoInsertLine(.T.)
oModelFO2:SetNoDeleteLine(.T.)

oModelFO2:GoLine(oModelFO2:Length())

Return nTotNeg

//-------------------------------------------------------------------
/*/{Protheus.doc} F460GetChq
Entrada de dados do cheque 

Parametros: ExpA1=Array contendo dados do cheque (vindos da leitora)
			ExpD1=Data de vencto do cheque                          
			ExpC3=Valor do Cheque
			ExpC4=Nome do Emitente                                   

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
																				
/*/
//-------------------------------------------------------------------
Function F460GetChq(aCmC7,dVenc460,nValChq460,cEmiten460)

Local lCorrige := .F.
Local lRet := .F.
Local nOpca := 0
Local oBanco

// Criacao da Interface                                                
While .T.
	nOpca := 0
	DEFINE MSDIALOG oMkwdlg FROM	070,116 TO 344,380 TITLE STR0127 PIXEL  //"Dados do cheque"
	@ 010,010 SAY STR0128     	Size 25,08 OF oMkwdlg PIXEL	//"Banco"
	@ 025,010 SAY STR0129   	Size 25,08 OF oMkwdlg PIXEL	//"Agência"
	@ 040,010 SAY STR0130     	Size 25,08 OF oMkwdlg PIXEL	//"Conta"
	@ 055,010 SAY STR0131    	Size 25,08 OF oMkwdlg PIXEL	//"Cheque"
	@ 070,010 SAY STR0132		Size 35,08 OF oMkwdlg PIXEL	//"Vencimento"
	@ 085,010 SAY STR0133		Size 25,08 OF oMkwdlg PIXEL	//"Valor"
	@ 100,010 SAY STR0142		Size 25,08 OF oMkwdlg PIXEL	//"Emitente"
	@ 010,050 MSGET oBanco VAR aCmc7[1] WHEN lCorrige	Size 70,10 OF oMkwdlg PIXEL hasbutton
	@ 025,050 MSGET aCmc7[3] WHEN lCorrige	Size 70,08 OF oMkwdlg PIXEL hasbutton
	@ 040,050 MSGET aCmc7[4] WHEN lCorrige	Size 70,08 OF oMkwdlg PIXEL hasbutton
	@ 055,050 MSGET aCmc7[2] WHEN lCorrige	Size 70,08 OF oMkwdlg PIXEL hasbutton
	@ 070,050 MSGET dVenc460					Size 70,08 OF oMkwdlg PIXEL hasbutton
	@ 085,050 MSGET nValChq460 Valid nValChq460 > 0 Picture "@E 99,999,999.99" Size 70,08  OF oMkwdlg PIXEL hasbutton
	@ 100,050 MSGET cEmiten460 Picture "@!S40" Size 70,08  OF oMkwdlg PIXEL hasbutton
		
	DEFINE SBUTTON FROM 122, 035 TYPE 1 ACTION (nOpca:=1,oMkwdlg:End())ENABLE OF oMkwdlg PIXEL
	DEFINE SBUTTON FROM 122, 065 TYPE 2 ACTION (nOpca:=2,oMkwdlg:End())ENABLE OF oMkwdlg PIXEL
	DEFINE SBUTTON FROM 122, 095 TYPE 5 ACTION (nOpca:=3,	;
																aCmc7[1] := PADR(aCmc7[1],3," "),;
																aCmc7[3] := PADR(aCmc7[3],4," "),;
																aCmc7[4] := PADR(aCmc7[4],10," "),;
																aCmc7[2] := PADR(aCmc7[2],6," "),;
																lCorrige := .T.,;
																oBanco:SetFocus()) ENABLE OF oMkwdlg PIXEL
	
	ACTIVATE MSDIALOG oMkwdlg CENTERED
	
	If nOpca == 1  // Confirma Dados do Cheque
		lRet := .T.
		lCorrige := .F.
	ElseIf nOpca == 2 	// Finaliza inclusao de cheques
		lRet := .F.
		lCorrige := .F.
	EndIf	
	Exit	
End	
Return(lRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} NivelSX3
Retorna o nível de um campo no SX3 

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	

/*/
//-------------------------------------------------------------------
Function NivelSX3(cField)
Local nOrdem := SX3->(IndexOrd())
Local nRecno := SX3->(Recno())
Local nNivel := 0
SX3->(DbSetOrder(2))
If SX3->(MsSeek(cField))
	nNivel := SX3->X3_NIVEL
EndIf
SX3->(DbSetOrder(nOrdem))
SX3->(DbGoto(nRecno))
Return nNivel


//-------------------------------------------------------------------
/*/{Protheus.doc} F460PARC
Retorna a Parcela do Título

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	

/*/
//-------------------------------------------------------------------
Function F460PARC()

cParc460 := CriaVar("E1_PARCELA",.F.)

Return cParc460

//-------------------------------------------------------------------
/*/{Protheus.doc} FIN460ACUR
Ajusta o ComboBox de Cursos disponiveis de acordo com o RA  
escolhido (Gestao Educacional)

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
/*/
//-------------------------------------------------------------------
Function FIN460ACUR(cNumRa,oNrDoc,cNrDoc,aNrDoc,oClients,cCliCombo,aClients)
Local aTmpDoc 	:= {}
Local lDif 		:= .F.
Local lExitTit 	:= .F.
Local cQuery 	:= ""
Local lRet  	:= .T.

//Primeiro verifica se existe titulo para este aluno
cQuery := "SELECT COUNT(E1_NUM) QTD"
cQuery += "  FROM " + RetSQLName("SE1")
cQuery += " WHERE E1_FILIAL = '"+xFilial("SE1")+"'"
cQuery += "  AND E1_NUMRA = '"+cNumRa+"'"
cQuery += "  AND D_E_L_E_T_ = ' '"
cQuery := ChangeQuery(cQuery)
dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), '_460TITALU', .F., .T.)

lExitTit := _460TITALU->QTD > 0
_460TITALU->( dbCloseArea() )

if lExitTit
	JBE->(dbSetOrder(1))
	JBE->(MsSeek(xFilial("JBE")+cNumRA))
	WHILE xFilial("JBE") == xFilial("JBE") .and. JBE->JBE_NUMRA == cNumRa .and. ! JBE->(EOF())
		aadd(aTmpDoc,JBE->JBE_CODCUR+" "+JBE->JBE_PERLET+" "+JBE->JBE_TURMA+" - "+Posicione("JAH",1,xFilial("JAH")+JBE->JBE_CODCUR,"JAH_DESC"))
		If Len(aNrDoc) >= Len(aTmpDoc)
			If ! aNrDoc[Len(aTmpDoc)] == aTmpDoc[Len(aTmpDoc)]
				lDif := .T.
			EndIf
		EndIf
		JBE->(dbSkip())
	END
	aadd(aTmpDoc,STR0153)	//"Outros Títulos"
	If ! Len(aNrDoc) == Len(aTmpDoc) .or. lDif
		aNrDoc := aClone(aTmpDoc)
		oNrDoc:SetItems(aNrDoc)
		oNrDoc:Refresh()
	EndIf
	
	//Ajusta o ComboBox de Clientes disponiveis de acordo com o RA e Curso (NrDoc) escolhido
	FIN460ACli(cNumRa,cNrDoc,@oClients,@cCliCombo,@aClients)
else
	MsgAlert(STR0195) //"Não existem títulos para este aluno."
	lRet := .F.
endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa460ExcSef
Exclui cheques do SEF atrelados ao titulo liquidado

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
/*/
//-------------------------------------------------------------------
Function Fa460ExcSef(cPrefixo,cNum,cParcela,cTipo)
Local aArea := GetArea()

SEF->(dbSetOrder(7) )
If SEF->(MsSeek(xFilial("SEF")+"R"+cPrefixo+cNum+cParcela+cTipo))
	While SEF->(!Eof()) .And. ;
			xFilial("SEF")+"R"+cPrefixo+cNum+cParcela+cTipo==;
			SEF->(EF_FILIAL+EF_CART+EF_PREFIXO+EF_TITULO+EF_PARCELA+EF_TIPO)
		Reclock("SEF")
		SEF->(dbDelete())
		MsUnlock()
		FkCommit()
		SEF->(dbSkip())
	End
Endif
RestArea(aArea)

Return Nil 

//-------------------------------------------------------------------
/*/{Protheus.doc} F460Confirma
Funcao para a validar o código capturado pelo leitor de CMC7

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
/*/
//-------------------------------------------------------------------
Function F460Confirma( cCmc7 )
Local lRet := .F.		// Retorno da validacao da string

Default cCmc7	:= ""	//Codigo do CMC7

If SubStr(cCmc7,1,1) <> "<"
	cCmc7	:= SubStr(Alltrim(cCmc7),2,Len(Alltrim(cCmc7)) - 1)
EndIf

If Empty( cCmc7 ) // Caso nao leia nada
	MsgAlert( STR0178 )		// "Passe o cheque novamente no leitor." 
ElseIf ( "?" $ cCmc7 ) .OR. Len( AllTrim( cCmc7 ) ) <> 34 // Se encontrar o caracter de erro (?) ou tamnaho menor que o correto (34)
	MsgAlert( STR0179 + " " + STR0178 )		// "Erro na leitura." ### "Passe o cheque novamente no leitor."  
Else
	lRet := .T.
EndIf	

Return ( lRet )	    


//-------------------------------------------------------------------
/*/{Protheus.doc} F460Cmc7Tc
Funcao para a captura do código CMC7 pelo leitor via teclado.

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
/*/
//-------------------------------------------------------------------
Function F460Cmc7Tc()
Local cCmc7 	:= Space(35)	// Recebera o conteudo lido do cheque 
Local oCmc7						// Objeto do get do CMC7
Local oDlg						// Monta a tela de captura do codigo  
Local aCmc7Tc	:= {}			// Armazena os dados do cheque; retorno da funcao
Local nOpcx 	:= 0

DEFINE MSDIALOG oDlg TITLE STR0180 FROM 200 , 001 TO 300 , 300 OF oMainWnd PIXEL	// "Leitura do código do cheque"
@ 010 , 018 Say STR0181 SIZE 050 , 050 OF oDlg PIXEL								// "Passe o cheque:"
@ 018 , 018 MSGET oCmc7 VAR cCmc7 PICTURE "@!" SIZE 120,009 OF oDlg PIXEL

DEFINE SBUTTON FROM 35 , 080 TYPE 1 ACTION (Iif (F460Confirma(@cCmc7), (oDlg:End(), nOpcx := 1), oCmc7:SetFocus()) )  ENABLE OF oDlg
DEFINE SBUTTON FROM 35 , 110 TYPE 2 ACTION oDlg:End()  ENABLE OF oDlg

ACTIVATE MSDIALOG oDlg CENTERED	

If nOpcx == 1  //Confirmou cheque

	if __l460CMTC == NIL
		__l460CMTC := ExistBlock("F460CMTC")
	endIf
	If __l460CMTC
		aCmc7Tc := ExecBlock("F460CMTC",.F.,.F.,cCmC7)
	Else
		aAdd( aCmc7Tc, SubStr(cCmc7, 2,  3) )	//Banco
		aAdd( aCmc7Tc, SubStr(cCmc7, 14, 6) )	//Cheque
		aAdd( aCmc7Tc, SubStr(cCmc7, 5,  4) )	//Agencia  
		aAdd( aCmc7Tc, SubStr(cCmc7, 23, 10) )	//Conta
	EndIf	

Else
	lCMC7 := .F.
EndIf	

//Utilize os códigos abaixo para testes com CMC7
//<23701348<0180001265<577508114673:
//<23728016<0010002185>777500568207:
//<35612683<0180100215>800060056009:
Return( aCmc7Tc )

//-------------------------------------------------------------------
/*/{Protheus.doc} MenuDef
Utilizacao de menu Funcional 

@author Ana Paula N. Silva
@version P12.1.8
@since	21/01/1998	
/*/
//-------------------------------------------------------------------
Static Function MenuDef()

Local aRotina 	:= {}
Local lIntPFS   := lJurXFin() // Integração SIGAPFS

aRotina := {			{ STR0002 ,"AxPesqui"  , 0 , 1 ,,.F.},;	    //"Pesquisar"
						{ STR0003 ,"A460Liquid", 0 , 3 		},;   	// "Liquidar"
						{ STR0076 ,"A460Liquid", 0 , 3 		},;   	// "Reliquidar"
						{ STR0052 ,"FA460Can"  , 0 , 6 		},;		//"Cancelar"
						{ STR0200 ,"CTBC662"   , 0 , 7 		},;   	//"Tracker Contábil"
						{ STR0154 ,"FA040Legenda", 0 , 6, ,.F.},; 	//"Legenda"}  	 
						{ STR0234,'FA460Visul',0,4}}//"Visualizar Titulo"

if __lF460Rot == NIL
	__lF460Rot := Existblock("FA460ROT")
endIf
If __lF460Rot
	aRotina := Execblock("FA460ROT",.F.,.F.,aRotina)		//adiciona alguma rotina em aRotina
EndIf

If lIntPFS .And. ExistFunc("JurBtnReli") .And. !FwIsInCallStack("FINA740")
	JurBtnReli(@aRotina, STR0076)
EndIf

Return(aRotina)

/*/{Protheus.doc} FA460Visul
Visualização do Titulo na baixa
@type  Function
@author user
@since date
@version 1.0
/*/
Function FA460Visul

AxVisual( "SE1", SE1->( Recno() ), 2 )

Return
//-------------------------------------------------------------------
/*/{Protheus.doc} FinA460T
Chamada semi-automatica utilizado pelo gestor financeiro

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
/*/
//-------------------------------------------------------------------
Function FinA460T(aParam)	

	ReCreateBrow("SE1",FinWindow)      	
	cRotinaExec := "FINA460"
	FinA460(aParam[1])
	ReCreateBrow("SE1",FinWindow)      	

	dbSelectArea("SE1")
	
	INCLUI := .F.
	ALTERA := .F.

Return .T.	

//-------------------------------------------------------------------
/*/{Protheus.doc} FA460MotBX
Funcao criar automaticamente o motivo de baixa LIQ na tabela de
Motivo de Baixas

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
/*/
//-------------------------------------------------------------------                   
Static Function Fa460MotBx(cMot,cNomMot, cConfMot)
	Local lMotBxEsp	:= .F.
	Local aMotbx 	:= ReadMotBx(@lMotBxEsp)
	Local nHdlMot	:= 0
	Local I			:= 0
	Local cFile 	:= "SIGAADV.MOT"
	Local nTamLn	:= 19

	If lMotBxEsp
		nTamLn	:= 20
		cConfMot	:= cConfMot + "N"
	EndIf
	
	If ExistBlock("FILEMOT")
		cFile := ExecBlock("FILEMOT",.F.,.F.,{cFile})
	EndIf
	
	If Ascan(aMotbx, {|x| Substr(x,1,3) == Upper(cMot)}) < 1
		nHdlMot := FOPEN(cFile,FO_READWRITE)
		If nHdlMot <0
			HELP(" ",1,"SIGAADV.MOT")
			Final("SIGAADV.MOT")
		EndIf
		
		nTamArq:=FSEEK(nHdlMot,0,2)	// VerIfica tamanho do arquivo
		FSEEK(nHdlMot,0,0)			// Volta para inicio do arquivo

		For I:= 0 to  nTamArq step nTamLn // Processo para ir para o final do arquivo	
			xBuffer:=Space(nTamLn)
			FREAD(nHdlMot,@xBuffer,nTamLn)
		Next		
		
		fWrite(nHdlMot,cMot+cNomMot+cConfMot+chr(13)+chr(10))	
		fClose(nHdlMot)		
	EndIf	
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} F460VldCmp
Funcao criar automaticamente o motivo de baixa LIQ na tabela de
Motivo de Baixas

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
																				
/*/
//------------------------------------------------------------------- 
Static Function F460VldCmp( cCliDe, cLojaDe, cCliAte, cLojaAte, cCli460, cLoja )

cCliAte := cCliDe
cLojaAte := cLojaDe
cCli460 := cCliDe
cLoja := cLojaDe

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} Fn460ValIn
Realiza as validacoes da negociacao de titulos nativos do 
RM ClassisNet

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	

/*/
//------------------------------------------------------------------- 
Function Fn460ValIn(nOpca)
Local lRet := .T.

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F460NATIMP
Funcao para verifica o calculo de impostos para a natureza dos 
titulos a serem gerados

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
/*/
//-------------------------------------------------------------------
Function F460NATIMP()

//639.04 Base Impostos diferenciada
Local lBaseImp	:= F040BSIMP(2)
Local cImpPcc	:= ""

cNatureza := If(Type("cNatureza") != "C", "",cNatureza)

If lBaseImp .and. !Empty(cNatureza) .and. !Empty(cCliente)

	//Posiciona Cadastro de Naturezas
	SED->(dbSetOrder(1))
	SED->(MsSeek(xFilial("SED")+cNatureza))

	//Posiciona Cadastro de Clientes		
	SA1->(dbSetOrder(1))
	SA1->(MsSeek(xFilial("SA1")+cCliente+cLoja))

	//Verifico se a combinacao Cliente x Natureza calcula CSLL
	If (SED->ED_CALCCSL == "S" .and. SA1->A1_RECCSLL $ "S#P")
		cImpPcc += "CSL#"
	EndIf

	//Verifico se a combinacao Cliente x Natureza calcula COFINS	
	If	(SED->ED_CALCCOF == "S" .and. SA1->A1_RECCOFI $ "S#P")
		cImpPcc += "COF#"
	EndIf
			
	//Verifico se a combinacao Cliente x Natureza calcula PIS
	If	(SED->ED_CALCPIS == "S" .and. SA1->A1_RECPIS $ "S#P") 
		cImpPcc += "PIS#"
	EndIf

	If SED->ED_CALCIRF $ "1S" .And. If(cPaisLoc == "BRA", SA1->A1_RECIRRF $ "1", .T.)
		cImpPcc += "IRF#"
	EndIf
	If SED->ED_CALCINS $ "1S"
		cImpPcc += "INS#"
	EndIf
	If SED->ED_CALCISS $ "1S" .AND. SA1->A1_RECISS $ "1"
		cImpPcc += "ISS#"
	EndIf

EndIf	

Return (cImpPcc)


//-------------------------------------------------------------------
/*/{Protheus.doc} FIN460ACli
Ajusta o ComboBox de Clientes disponiveis de acordo com o RA e 
Curso (NrDoc) escolhido. (Gestao Educacional )

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
																				
/*/
//-------------------------------------------------------------------
Static Function FIN460ACli(cNumRa,cNrDoc,oClients,cCliCombo,aClients)
Local aTmpCli := {}
Local cQuery  := ""
Local lMSSQL := "MSSQL"$TCGetDB()
Local lMySQL := "MYSQL"$TCGetDB()

If !Empty(cNumRa)
	cQuery := "SELECT DISTINCT E1_CLIENTE, E1_NOMCLI"
	cQuery += "  FROM " + RetSQLNAme("SE1")
	cQuery += " WHERE E1_FILIAL = '"+xFilial("SE1")+"'"
	cQuery += "   AND E1_NUMRA  = '"+cNumRa+"'"
	If cNrDoc == STR0153 //"Outros Títulos"
		cQuery += "   AND E1_NRDOC  = '"+Space(TamSx3("E1_NRDOC")[1])+"'"
	Else
		If lMSSQL .or. lMySQL
			cQuery += " AND Substring(E1_NRDOC,1,"+alltrim(Str(TamSx3("JBE_CODCUR")[1]+TamSx3("JBE_PERLET")[1]))+") = '"+Substr(cNrDoc,1,TamSx3("JBE_CODCUR")[1])+Substr(cNrDoc,TamSx3("JBE_CODCUR")[1]+2,TamSx3("JBE_PERLET")[1])+"'"
		Else
			cQuery += " AND Substr(E1_NRDOC,1,"+alltrim(Str(TamSx3("JBE_CODCUR")[1]+TamSx3("JBE_PERLET")[1]))+") = '"+Substr(cNrDoc,1,TamSx3("JBE_CODCUR")[1])+Substr(cNrDoc,TamSx3("JBE_CODCUR")[1]+2,TamSx3("JBE_PERLET")[1])+"'"
		EndIf
	EndIf
	cQuery += "   AND D_E_L_E_T_ = ' '"
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), '_460CLI', .F., .T.)
	
	If _460CLI->( !EoF() )
		While _460CLI->( !EoF() )
			aAdd(aTmpCli,_460CLI->E1_CLIENTE+" - "+_460CLI->E1_NOMCLI)
			_460CLI->( dbSkip() )
		End
	Else
		aAdd(aTmpCli,"")
	EndIf
	
	_460CLI->( dbCloseArea() )
Else
	aAdd(aTmpCli,"")
EndIf

If cChvRaNDoc <> cNumRa+cNrDoc
	cChvRaNDoc 	:= cNumRa+cNrDoc
	aClients 	:= aClone(aTmpCli)
	oClients:SetItems(aClients)
	oClients:Refresh()
EndIf

Return .T.


//-------------------------------------------------------------------
/*/{Protheus.doc} fa460Corr
Calcula a correção monetária

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	

/*/
//-------------------------------------------------------------------
Function fa460Corr(nValorBx,nMoeda,nTxMoeda)

Local nCorrecao := 0
Local nValAtual := 0
Local nValEmiss := 0
Local nVlrMoeda	:= 0
Local nVlrConv	:= 0

DEFAULT nTxMoeda	:= If(SE1->E1_TXMOEDA > 0, SE1->E1_TXMOEDA,RecMoeda(dDataBase,SE1->E1_MOEDA))

nVlrMoeda := RecMoeda(dDataBase, nMoeda)
nVlrConv  := nValorBx

If Str(nValorBx,17,2) = Str(SE1->E1_VALOR,17,2) .And. Empty(SE1->E1_DTVARIA)
	nValEmiss := SE1->E1_VLCRUZ
Else
	If !Empty(SE1->E1_TXMDCOR)
		nValEmiss := xMoeda(nValorBx,SE1->E1_MOEDA,1,Iif(Empty(SE1->E1_DTVARIA),SE1->E1_EMISSAO,SE1->E1_DTVARIA),3,SE1->E1_TXMDCOR)
	Else
		If SE1->E1_TXMOEDA > 0
			nVlrMoeda := SE1->E1_TXMOEDA
		Else
			nVlrMoeda := RecMoeda(SE1->E1_EMISSAO, nMoeda)
		EndIf
		nValEmiss := xMoeda(nValorBx,SE1->E1_MOEDA,1,Iif(Empty(SE1->E1_DTVARIA),SE1->E1_EMISSAO,SE1->E1_DTVARIA), 3, nVlrMoeda, 1)
	EndIf
EndIf

nValAtual := xMoeda(nVlrConv, SE1->E1_MOEDA, 1 , dDataBase, 3, IIf(SE1->E1_TXMOEDA > 0 .And. SE1->E1_TXMOEDA == nTxMoeda,SE1->E1_TXMOEDA,nTxMoeda))

//--------------------------------------------------------------------------
// Verifica atraves do parametro MV_CALCCM se sera calculada a correcao 
// monetaria. Caso o parametro nao exista, sera assumido "S"					
//--------------------------------------------------------------------------
If SuperGetMv("MV_CALCCM",.F.,"S") == "S"
	nCorrecao := Round(nValAtual - nValEmiss, 2)
Else
	nCorrecao := 0
EndIf

Return (nCorrecao)


//-------------------------------------------------------------------
/*/{Protheus.doc} F460NotIn
Monta a expressão do NOT IN da query da liquidacao

@author Mauricio Pequim Jr
@version P12.1.8
@since	21/01/1998	
																				
/*/
//-------------------------------------------------------------------
Static Function F460NotIN(lMarkAbt)

Local cTipos := MVPROVIS+"/"+MVRECANT+"/"+MV_CRNEG+"/"+MVABATIM
			
cTipos	:=	StrTran(cTipos,',','/')
cTipos	:=	StrTran(cTipos,';','/')
cTipos	:=	StrTran(cTipos,'|','/')
cTipos	:=	StrTran(cTipos,'\','/')

cTipos := Formatin(cTipos,"/")

Return cTipos


//-------------------------------------------------------------------
/*/{Protheus.doc} F460GetTit
Função que verifica retorna os vetores com os títulos baixados e com 
os novos títulos gerados, para uso na mensagem única FinancialTrading
		
@return aBaixados - Vetor com os títulos baixados
@return aNovos - Vetor com os novos títulos gerados
@return cNroLiqui - Variável com o número da liquidação 

@author Pedro Pereira Lima
@version P12
@since	02/04/2014											
/*/
//-------------------------------------------------------------------

Function F460GetTit (_aBaixados,_aNovosTit,_cNroLiqui)

Default _aBaixados := __aBaixados
Default _aNovosTit := __aNovosTit
Default _cNroLiqui := __cNroLiqui

Return { _aBaixados, _aNovosTit, _cNroLiqui } 

//-------------------------------------------------------------------
/*/{Protheus.doc} IntegDef
Integração via mensagem única

@author Pedro Pereira Lima
@version P12
@since	02/04/2014											
/*/
//-------------------------------------------------------------------
Static Function IntegDef( cXml, nType, cTypeMsg, cVersion )  
Local aReturn := {}

aReturn := FINI460( cXml, nType, cTypeMsg, cVersion )

If cTypeMsg == EAI_MESSAGE_RESPONSE
	aRespInteg := aClone(aReturn)
EndIf

Return aReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} F460ChgVar
Altera o valor das variáveis INCLUI, ALTERA e EXCLUI, retornando um array
contendo os valores originais

@author Pedro Pereira Lima
@version P12
@since	04/01/2015											
/*/
//-------------------------------------------------------------------
Static Function F460ChgVar()
Local aRet := {,}

If Type("INCLUI") <> "U"
	aRet[1] := INCLUI
	If INCLUI
		INCLUI := .F.
	EndIf
EndIf

If Type("ALTERA") <> "U"
	aRet[2] := ALTERA
	If ALTERA
		ALTERA := .F.
	EndIf
EndIf

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F460RetVar
Retorna os valores originais das variáveis INCLUI, ALTERA e EXCLUI

@author Pedro Pereira Lima
@version P12
@since	04/01/2015											
/*/
//-------------------------------------------------------------------
Static Function F460RetVar(aValOrig)
Default aValOrig := {}

If !Empty(aValOrig)
	
	If ValType(aValOrig[1]) == "L"
		INCLUI := aValOrig[1]
	EndIf

	If ValType(aValOrig[2]) == "L"
		ALTERA := aValOrig[2]
	EndIf

EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} F460BuscSE1
Função para buscar os títulos para liquidação

@author Pâmela Bernardo
@version P12.1.8
@since	05/10/2015
@param cAlias = alias corrente para busca dos dados
@param nOpcx 2 = Liquidação, 6 = Reliquidação
@param aCpoBro Estrutura da tabela temporária
@param cOrigem Origem da chamada da função 1 = Liquidação, 2 = Simulação/Efetivação
											
/*/
//-------------------------------------------------------------------
Function F460BuscSE1(cAlias,nOpcx,aCpoBro, cAliasTMP,nOrigem, lAutMrkPix)

Local aMoedas		:= {}
Local cMoeda460		:= ""
Local cOutrMoed 	:= STR0136 //"2 - Nao Considera"
Local aOutrMoed 	:= {}
Local lPanelFin		:= IsPanelFin()
Local oDlg          := Nil
Local oValorMax
Local oValorDe
Local oValorAte
Local oFnt
Local aIntervalo	:= { STR0063, STR0064 }		//"01 EMISSAO   "###"02 VENCIMENTO"
Local cIntervalo	:= STR0063		//"01 EMISSAO   "
Local lBaseImp		:= F040BSIMP(2)
Local cVar			:= ""
Local cVar1 		:= STR0063		//"01 EMISSAO   "
Local cSimb			:= ""
Local nOpca 		:= 0

//Gestao
Local lGestao	  	:= FWSizeFilial() > 2	// Indica se usa Gestao Corporativa
Local lSE1Access	:= Iif( lGestao, FWModeAccess("SE1",1) == "E", FWModeAccess("SE1",3) == "E")
Local aSelFil		:= {}
Local cAliasSE1		:= GetNextAlias()
Local cQuery		:= ""
Local lRet			:= .T.
Local nX 			:= 0
Local aAreaSe1		:= SE1->(GetArea())
Local aCampos 		:= aClone(F460STRFO1())	// Cria a estrutura a ser utilizada no arquivo temporário

//Variáveis para integração via Mensagem Única
Local lRMClass	:= GetNewPar("MV_RMCLASS",.F.)
Local nRMBxEdu	:= GetNewPar("MV_RMBXEDU",0)
Local oFilInt
Local aFilInt	:=  {"1=Sim","2=Não"}
Local oJurEscrit	:= ""
Local oJurFat		:= ""

//Integração SIGAPFS x SIGAFIN
Local lIntPFS	:= lJurXFin()
Local lLojaAuto := lIntPFS .And. SuperGetMv( "MV_JLOJAUT", .F., "2", ) == "1" //Indica se a Loja do Caso deve ser preenchida automaticamente. (1-Sim; 2-Não)
Local nPicture	:= PesqPict( "SE1", "E1_VALOR")

Local nInicio	 := 0
Local nFim		 := 0
Local nRegProc	 := 0

Private cEscrit	:= Criavar("NS7_COD") //Variaveis modulo Juridico
Private cFatura	:= Criavar("NXA_COD") //Variaveis modulo Juridico

Default nOrigem    := 1
Default lAutMrkPix := .T. 

//Opção de variação monetária não disponível para rotina de simulação
aOutrMoed := IIf(nOrigem=1, {STR0135,STR0136,STR0267},{STR0135,STR0136}) //"1 - Converte"###"2 - Nao Considera"###"3 - Variac.Monet."

If Len(aRotina) == 0
	aRotina := MenuDef()
EndIf

If oTmpTabFO1 <> Nil
	cAliasTMP	:= oTmpTabFO1:GetAlias()
Else
	cAliasTMP 	:= GetNextAlias() //Alias da tabeça temporária
EndIf

aMoedas 	:= FDescMoed()  
nValTot		:= 0
nOpca   	:= 0
lProcessou	:= .F. 
	
If nOpcx == 6
	cCadastro := STR0074		// "Reliquidao"
Endif
	
DEFINE FONT oFnt NAME "Arial" SIZE 12,14 BOLD

If !lOpcAuto
	//Tela de parametros da rotina
	If lPanelFin  //Chamado pelo Painel Financeiro			
		dbSelectArea(cAlias)
		oPanelDados := FinWindow:GetVisPanel()
		oPanelDados:FreeChildren()
		aDim := DLGinPANEL(oPanelDados)
		DEFINE MSDIALOG oDlg OF oPanelDados:oWnd FROM 0,0 To 0,0 PIXEL STYLE nOR( WS_VISIBLE, WS_POPUP )							
		oDlg:Move(aDim[1],aDim[2],aDim[4]-aDim[2], aDim[3]-aDim[1])			
			
		//--------------------------------------------------------------------------
		// Observacao Importante quanto as coordenadas calculadas abaixo:  
		//--------------------------------------------------------------------------
		// a funcao DlgWidthPanel() retorna o dobro do valor da area do	 
		// painel, sendo assim este deve ser dividido por 2 antes da sub- 
		// tracao e redivisao por 2 para a centralizacao. 					 		
		//--------------------------------------------------------------------------
		nEspLarg := (((DlgWidthPanel(oPanelDados)/2) - 276) /2)-4
		nEspLin  := 0				
	Else   
		nEspLarg := 0 
		nEspLin  := 3
		DEFINE MSDIALOG oDlg FROM	85,0 TO 420,560 TITLE cCadastro PIXEL
	Endif     

	oDlg:lMaximized := .F.
	oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20)
	oPanel:Align := CONTROL_ALIGN_ALLCLIENT    			
	
	@ 004+nEspLin, 007+nEspLarg TO 145+nEspLin, 276+nEspLarg OF oPanel PIXEL
	If lIntPFS
		@ 010+nEspLin, 014+nEspLarg SAY STR0020 SIZE 40, 7 OF oPanel PIXEL //"Cliente"
		If !lLojaAuto
			@ 010+nEspLin, 070+nEspLarg SAY STR0014 SIZE 20, 7 OF oPanel PIXEL //"Loja"
		EndIf
		@ 010+nEspLin, 104+nEspLarg SAY STR0236 SIZE 100,7 PIXEL Of oPanel //"Escritório"
		@ 010+nEspLin, 194+nEspLarg SAY STR0237	SIZE 100,7 PIXEL Of oPanel //"Fat. Jurídico"
	Else
		@ 010+nEspLin, 014+nEspLarg SAY STR0070	SIZE 40, 7 OF oPanel PIXEL   //"Cliente De"
		@ 010+nEspLin, 070+nEspLarg SAY STR0072	SIZE 20, 7 OF oPanel PIXEL   //"Loja De"
		@ 010+nEspLin, 104+nEspLarg SAY STR0071	SIZE 40, 7 OF oPanel PIXEL   //"Cliente Ate"
		@ 010+nEspLin, 160+nEspLarg SAY STR0073	SIZE 20, 7 OF oPanel PIXEL   //"Loja Ate"
		@ 010+nEspLin, 194+nEspLarg SAY STR0013	SIZE 40, 7 OF oPanel PIXEL   //"Gerar p/ Cliente"
		@ 010+nEspLin, 250+nEspLarg SAY STR0014	SIZE 40, 7 OF oPanel PIXEL   //"Loja"
	EndIf
	@ 029+nEspLin, 014+nEspLarg SAY STR0015	SIZE 40, 7 OF oPanel PIXEL   //"Valor Maximo"
	@ 029+nEspLin, 104+nEspLarg SAY STR0107	SIZE 50, 7 OF oPanel PIXEL   //"Titulos no valor de"
	@ 029+nEspLin, 194+nEspLarg SAY STR0108	SIZE 40, 7 OF oPanel PIXEL   //"Ate o valor de"
	@ 048+nEspLin, 014+nEspLarg SAY STR0065 SIZE 40, 7 OF oPanel PIXEL   //"Intervalo por"
	@ 048+nEspLin, 104+nEspLarg SAY STR0066 SIZE 40, 7 OF oPanel PIXEL   //"Data de"
	@ 048+nEspLin, 194+nEspLarg SAY STR0067 SIZE 40, 7 OF oPanel PIXEL   //"Ate"
	@ 072+nEspLin, 014+nEspLarg SAY STR0161	SIZE 40, 7 OF oPanel PIXEL   //"Pref De"
	@ 072+nEspLin, 045+nEspLarg SAY STR0067 SIZE 40, 7 OF oPanel PIXEL   //"Ate"
	@ 072+nEspLin, 104+nEspLarg SAY STR0162 SIZE 40, 7 OF oPanel PIXEL   //"Titulo de"
	@ 072+nEspLin, 194+nEspLarg SAY STR0067 SIZE 40, 7 OF oPanel PIXEL   //"Ate"
	@ 091+nEspLin, 014+nEspLarg SAY STR0016	SIZE 40, 7 OF oPanel PIXEL   //"Moeda"
	@ 091+nEspLin, 104+nEspLarg SAY STR0137	SIZE 40, 7 OF oPanel PIXEL   //"Outras Moedas"

	//--------------------------------------------------------------------------
	//Integracao Protheus X RM Classis Net (RM Sistemas)
	//--------------------------------------------------------------------------
	If GetNewPar("MV_RMCLASS", .F.)
		@ 019+nEspLin, 014+nEspLarg MSGET cCliDe  F3 "SA1" Valid F460VldCmp(@cCliDe,@cLojaDe,@cCliAte,@cLojaAte,@cCli460,@cLoja) SIZE 52, 08 OF oPanel PIXEL hasbutton 
		@ 019+nEspLin, 070+nEspLarg MSGET cLojaDe 		   Valid F460VldCmp(@cCliDe,@cLojaDe,@cCliAte,@cLojaAte,@cCli460,@cLoja) SIZE 20, 08 OF oPanel PIXEL hasbutton
		@ 019+nEspLin, 104+nEspLarg MSGET oCliAte	VAR cCliAte		F3 "SA1" SIZE 52, 08 OF oPanel PIXEL hasbutton When .F.
		@ 019+nEspLin, 160+nEspLarg MSGET oLojaAte	VAR cLojaAte	SIZE 20, 08 OF oPanel PIXEL hasbutton When .F.
		@ 019+nEspLin, 194+nEspLarg MSGET cCli460 F3 "SA1" Valid a460Cli(cCli460)    	SIZE 52, 08 OF oPanel PIXEL hasbutton
		@ 019+nEspLin, 250+nEspLarg MSGET cLoja			   Valid a460Cli(cCli460,cLoja)	SIZE 20, 08 OF oPanel PIXEL hasbutton
	Else
		@ 019+nEspLin, 014+nEspLarg MSGET cCliDe	F3 "SA1" SIZE 52, 08 OF oPanel PIXEL hasbutton
		If !lLojaAuto
			@ 019+nEspLin, 070+nEspLarg MSGET cLojaDe	SIZE 20, 08 OF oPanel PIXEL hasbutton
		EndIf
		If lIntPFS
			@ 019+nEspLin, 104+nEspLarg MSGET oJurEscrit VAR cEscrit F3 "NS7" VALID Empty(cEscrit) .Or. ExistCpo("NS7", cEscrit) SIZE 60,8 hasbutton PIXEL Of oPanel
			oJurEscrit:bChange := {|| cFatura := CriaVar("NXA_COD"), oJurFat:Refresh()}
			@ 019+nEspLin, 194+nEspLarg MSGET oJurFat VAR cFatura F3 "NXA1" SIZE 60,8 hasbutton PIXEL Of oPanel WHEN ! Empty(cEscrit) ;
			VALID Empty(cFatura) .Or. ExistCpo("NXA", cEscrit + cFatura)
		Else
			@ 019+nEspLin, 104+nEspLarg MSGET oCliAte	VAR cCliAte		F3 "SA1" SIZE 52, 08 OF oPanel PIXEL hasbutton
			@ 019+nEspLin, 160+nEspLarg MSGET oLojaAte	VAR cLojaAte	SIZE 20, 08 OF oPanel PIXEL hasbutton
			@ 019+nEspLin, 194+nEspLarg MSGET cCli460	F3 "SA1" 	Valid a460Cli(cCli460)			SIZE 52, 08 OF oPanel PIXEL hasbutton
			@ 019+nEspLin, 250+nEspLarg MSGET cLoja					Valid a460Cli(cCli460,cLoja)	SIZE 20, 08 OF oPanel PIXEL hasbutton
		EndIf
		
	Endif

	@ 037+nEspLin, 014+nEspLarg MSGET oValorMax VAR nValorMax	Picture nPicture	SIZE 60, 08 OF oPanel PIXEL hasbutton
	@ 037+nEspLin, 104+nEspLarg MSGET oValorDe  VAR nValorDe	Picture nPicture	SIZE 60, 08 OF oPanel PIXEL hasbutton
	@ 037+nEspLin, 194+nEspLarg MSGET oValorAte VAR nValorAte	Picture nPicture	SIZE 60, 08 OF oPanel PIXEL hasbutton
	@ 056+nEspLin, 014+nEspLarg MSCOMBOBOX oCbx1 VAR cIntervalo ITEMS aIntervalo SIZE 60, 54 OF oPanel PIXEL
	@ 056+nEspLin, 104+nEspLarg MSGET dData460I	Valid !Empty(dData460I) SIZE 52, 08 OF oPanel PIXEL hasbutton
	@ 056+nEspLin, 194+nEspLarg MSGET dData460F	Valid !Empty(dData460F) .and. ;
		dData460F >= dData460I 	.and. ;
		If(Val(SubStr(cIntervalo,1,2))=1,dData460F <= dDataBase,.T.)	;
		SIZE 52, 08 OF oPanel PIXEL hasbutton

	@ 080+nEspLin, 014+nEspLarg MSGET cPrefDe	SIZE 20, 08 OF oPanel PIXEL hasbutton
	@ 080+nEspLin, 045+nEspLarg MSGET cPrefAte	VALID cPrefAte >= cPrefDe SIZE 20, 08 OF oPanel PIXEL hasbutton
	@ 080+nEspLin, 104+nEspLarg MSGET cNumDe	SIZE 52, 08 OF oPanel PIXEL hasbutton
	@ 080+nEspLin, 194+nEspLarg MSGET cNumAte	VALID cNumAte >= cNumDe SIZE 52, 08 OF oPanel PIXEL hasbutton
	@ 099+nEspLin, 014+nEspLarg MSCOMBOBOX oCbx  VAR cMoeda460	ITEMS aMoedas	Valid A460VldMoe(cMoeda460,cOutrMoed) SIZE 60, 54 OF oPanel PIXEL
	@ 099+nEspLin, 104+nEspLarg MSCOMBOBOX oCbx2 VAR cOutrMoed	ITEMS aOutrMoed Valid A460VldMoe(cMoeda460,cOutrMoed) SIZE 60, 54 OF oPanel PIXEL

	//639.04 Base Impostos diferenciada
	If lBaseImp
		@ 091+nEspLin, 194+nEspLarg SAY STR0210	SIZE 80,7 PIXEL Of oPanel  COLOR CLR_HBLUE //"Natureza  "
		@ 099+nEspLin, 194+nEspLarg MSGET cNatureza		F3 "SED" Valid A460NATUR(cNatureza) SIZE 60,8 hasbutton PIXEL Of oPanel
	EndIf	

	If lMsgUnq	//Verifica se os adapters estão configurados 
		//Se tiver integração com RM e o processo de baixas for modelo I, 
		//exibe opção para filtrar títulos de integração. 
		If  lRMClass .And. nRmBXEdu == 0 
			@ 115+nEspLin, 014+nEspLarg SAY STR0213 SIZE 100, 7 OF oPanel PIXEL //"Filtra Integração"
			@ 123+nEspLin, 014+nEspLarg MSCOMBOBOX oFilInt VAR cFilMsg ITEMS aFilInt SIZE 60,54 OF oPanel PIXEL
		EndIf	
	EndIf	

	If lPanelFin  //Chamado pelo Painel Financeiro			
		ACTIVATE MSDIALOG oDlg ON INIT FaMyBar(oDlg,;
		{||cVar:=cMoeda460,cVar1:=cIntervalo,cCliente:=cCli460,cTipo:=M->E1_TIPO,;
		IF(Fa460OK1(),(nOpca:=1,oDlg:End()),nOpca:=2)},;		
		{||oDlg:End(),nOpca:=0})	
	
	Else	
		DEFINE SBUTTON FROM 150, 214 TYPE 1 ACTION ;
			(cVar:=cMoeda460,cVar1:=cIntervalo,cCliente:=cCli460,cTipo:=M->E1_TIPO,F460PFSBok(lIntPFS, lLojaAuto),IF(Fa460OK1(),(nOpca:=1,oDlg:End()),nOpca:=2)) ENABLE OF oPanel
		DEFINE SBUTTON FROM 150, 249 TYPE 2 ACTION {||oDlg:End(),nOpca:=0} ENABLE OF oPanel
	
		ACTIVATE MSDIALOG oDlg CENTERED
	EndIf
	
	If nOpca == 0
		if __F460OUT == NIL
			__F460OUT := Existblock("FA460OUT")
		endIf
		If __F460OUT 
			Execblock("FA460OUT",.F.,.F.)
		EndIf
		lRet := .F.
	EndIf
	If nOpca == 2
		lRet := .F.
	EndIf
	nMoeda := Val(Substr(cVar,1,2))
Else
	If (nT := aScan(aAutoCab,{|x| UPPER(Alltrim(x[1]))=='CCONDICAO'})) > 0
		cCondicao :=	aAutoCab[nT,2]
	EndIf	
	If (nT := aScan(aAutoCab,{|x| UPPER(Alltrim(x[1]))=='CCLIENTE'})) > 0
		cCliente :=	aAutoCab[nT,2]
	EndIf
	If (nT := aScan(aAutoCab,{|x| UPPER(Alltrim(x[1]))=='CLOJA'})) > 0
		cLoja :=	aAutoCab[nT,2]
	EndIf	
	If (nT := aScan(aAutoCab,{|x| UPPER(Alltrim(x[1]))=='E1_TIPO'})) > 0
		M->E1_TIPO :=	aAutoCab[nT,2]
		cTipo:=M->E1_TIPO
	EndIf
	If (nT := aScan(aAutoCab,{|x| UPPER(Alltrim(x[1]))=='CNATUREZA'})) > 0
		cNatureza := aAutoCab[nT,2]
	EndIf
	If (nT := aScan(aAutoCab,{|x| UPPER(Alltrim(x[1]))=='NMOEDA'})) > 0
		nMoeda := aAutoCab[nT,2]
	EndIf
	
	__nOpcOuMo := nOutrMoed
	If nTxNegoc = 0
		nTxNegoc := RecMoeda(dDatabase,nMoeda)
	EndIf
	
	If (nT := AScan(aAutoCab,{|x| UPPER(Alltrim(x[1])) == "AUTMRKPIX"})) > 0
		lAutMrkPix := aAutoCab[nT,2]
	EndIf
EndIf

If lRet
	cSimb 	   := Pad(SuperGetmv("MV_SIMB"+Alltrim(STR(nMoeda))),4)
	nIntervalo := Val(Substr(cVar1,1,2))
	nChoice    := Val(Substr(cOutrMoed,1,1))
	If !lOpcAuto
		__nOpcOuMo := nChoice
	EndIf
	
	//Coloco o simbolo da moeda para qual vou gerar os titulos
	//no titulo das colunas
	For nX := 8 to 11
		aCpoBro [nX,3] += 	cSimb
	Next	

	// --------------------------------------------------------------------------
	// POR MAIS ESTRANHO QUE PAREA, ESTA FUNCAO DEVE SER CHAMADA AQUI! 
	//                                                                  
	// A função SomaAbat reabre o SE1 com outro nome pela ChkFile para  
	// efeito de performance. Se o alias auxiliar para a SumAbat() não  
	// estiver aberto antes da IndRegua, ocorre Erro de & na ChkFile,   
	// pois o Filtro do SE1 uptrapassa 255 Caracteres.                  
	// --------------------------------------------------------------------------
	SomaAbat("","","","R")

	//Gestao
	//Selecao de filiais
	If lSE1Access .and. mv_par06 == 1 .And. Len( aSelFil ) <= 0 
		aSelFil := AdmGetFil(.F.,.F.,"SE1")
		If Len( aSelFil ) <= 0
			lRet := .F.
		EndIf	
	Else
		aSelFil := { cFilAnt }
	EndIf
	
	if lRet .AND. lOpcAuto
		if !lAutoQuery .AND. Len(cAutoFil) >= 2000
			Help(NIL, NIL, STR0281) //Não é permitido filtro ADVPL com mais de 2000 caracteres. Verifique a utilização de filtro em SQL (décimo terceiro argumento da ExecAuto).
			lRet := .F.
		endif
	endif
	
	If lRet
		DbSelectArea ("SE1")
		DbSetOrder(1)	
	
		//Seleciona Contas a Receber (SE1)
		If lOpcAuto .AND. !lAutoQuery .AND. !Empty(cAutoFil) //Faz filtro em ADVPL apenas para preservar o legado do ExecAuto
			//------------------------------------------------------------------- 
			// Cria indice condicional									     
			//------------------------------------------------------------------- 
			cAliasSE1	:= "SE1"
			cAlias		:= "SE1"
			DbSelectArea(cAlias)

			cIndex		:= CriaTrab(nil,.f.)
			cChave		:= IndexKey()
			IndRegua("SE1",cIndex,cChave,,a460ChecF(nChoice,aSelFil,cEscrit,cFatura,nMoeda),STR0019)  //"Selecionando Registros..."
			nIndex := RetIndex("SE1")
			DbSelectArea(cAlias)
		
			DbSetOrder(nIndex+1)
			DbGoTop()  	
		Else    
			cQuery 		:= a460ChecF(nChoice,aSelFil,cEscrit,cFatura,nMoeda) 
			cQuery 		:= ChangeQuery(cQuery)
			dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasSE1, .F., .T.)
			dbSelectArea(cAliasSE1)	       
		EndIf
		
		If (cAliasSE1)->(Eof()) .and. (cAliasSE1)->(Bof())
			Help(" ",1,"RECNO")
			//Gestao
			If !lOpcAuto .OR. lAutoQuery
				
				If Select(cAliasSe1) > 0
					DbSelectArea(cAliasSe1)
					DbCloseArea()
				EndIf
				//Apaga a tabela temporaria das filiais
				For nX := 1 TO Len(aTmpFil)
					CtbTmpErase(aTmpFil[nX])
				Next
				dbSelectArea("SE1")
				dbSetOrder(1)
	
				FreeUsedCode()  //libera codigos de correlativos reservados pela MayIUseCode()
				lRet := .F.

			EndIf
		EndIf
	
		If lRet

			//Metricas - Carregamento da tela de seleção
			If __lMetric
				nInicio := Seconds()
			Endif

			//--------------------------------------------------------------------------------
			// Cria Arquivo Temporario						 
			//--------------------------------------------------------------------------------
			cTRB := Fa460Gerarq(aCampos, cAliasTMP ) /*DIEGO - Alterar geração do arquivo para as FO's*/
		
			nOpca		:= 0
			nValor  	:= 0	// Valor total dos titulos,mostrado no rodape do browse
			nValCruz	:= 0	// Acumula Valor original na moeda nacional
			nJuros		:= 0
			nDesc		:= 0
			nAbatim		:= 0
			nQtdTit 	:= 0	// Quantidade de titulos,mostrado no rodape do browse
			
			cAlias		:= cAliasTMP
			
			//--------------------------------------------------------------------------------
			// Carrega Registros do Arquivo Temporario       
			//--------------------------------------------------------------------------------
			Fa460Repl(cAliasSE1, cAliasTMP)

			//Metricas - Carregamento da tela de seleção
			If __lMetric
				nRegProc := (cAliasTMP)->(RecCount())

				If nRegProc > 0
					nFim := Seconds() - nInicio
					nFim := nFim / nRegProc

					SetFunName(__cFunMet)
					FwCustomMetrics():setAverageMetric(Alltrim(ProcName())+" - TempoEntrada", "financeiro-protheus_tempo-conclusão-processo_seconds", nFim)
					SetFunName(__cFunBkp)
				Endif
			Endif
		EndIf
	EndIf
EndIf
SE1->(RestArea(aAreaSe1))

Return lRet	

//-------------------------------------------------------------------
/*/{Protheus.doc} F460PFSBok()
Função utilizada no botão confirmar da tela de filtro de liquidação para atribuir
valor as variáveis private de cliente e loja.

@param Define se a integração com Jurídico (SIGAPFS) está habilitada

@author Abner Fogaça | Jonatas Martins
@since 30/06/20
/*/
//-------------------------------------------------------------------
Static Function F460PFSBok(lIntPFS, lLojaAuto)

If lIntPFS
	cCliAte  := cCliDe
	cCli460  := cCliDe
	If lLojaAuto
		cLojaDe := JurGetLjAt()
	EndIf
	cLojaAte := cLojaDe
	cLoja    := cLojaDe
EndIf

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} F460SelTit
Função que monta a tela de seleção de título

@author Diego Santos
@version P12.1.8
@since	05/10/2015		
@param cAliasTRB = Alias da tabela temporária com os títulos selecionados
@param nOpcx 2 = Liquidação, 6 = Reliquidação
@param aCpoBro Estrutura da tabela temporária
																				
/*/
//-------------------------------------------------------------------

Function F460SelTit(cAliasTMP, nOpcX, lAutMrkPix)
Local aSize
Local nX 	    := 0
Local nW		:= 0
Local nY		:= 0
Local oModelLiq
Local aEnableButtons	:= {}
Local bCancel
Local cLog				:= ""
Local cPrefix
Local cPrefixAux
Local cBanco
Local cAgencia
Local cContaC
Local cNum
Local cNumCh
Local cEmitCh
Local dVencto		:= CTOD("")
Local nPos		
Local nValParc
Local nValParT
Local nAcrescimo
Local nDecrescimo
Local nValCh
Local aFO2DePara	:= {}
Local aFO0DePara	:= {}
Local aParcelas		:= {}
Local cParcCli		:= ""
Local nValAux		:= 0
Local nValAuto		:= 0
Local nDifer		:= 0
Local nTxJrg	
Local nMoedaFO0
Local lRet			:= .T.
Local cMVPAR08		:= Alltrim(Upper(MV_PAR08))
Local lSitCobPix	:= .T.
Local lTemImpPix    := .F.
Local cIdDocFK7		:= ""
Local bEValPix		:= {||TtBxImpPix(SE1->(Recno()))} 

Default lAutMrkPix := .T.

lCmc7 	   := IIF(Type("lCmc7") == "L", lCmc7, .F.)

If lGeraSEf == NIL
	lGeraSEF	:= SuperGetMv("MV_GRSEFLQ",.F., .F. )
Endif

aAdd(aFO0DePara,{"cCondicao", "FO0_COND"	})
aAdd(aFO0DePara,{"cNatureza", "FO0_NATURE"	})
aAdd(aFO0DePara,{"E1_TIPO"	, "FO0_TIPO"	})
aAdd(aFO0DePara,{"cCLIENTE" , "FO0_CLIENT"	})
aAdd(aFO0DePara,{"nMoeda"   , "FO0_MOEDA"	})
aAdd(aFO0DePara,{"cLOJA"    , "FO0_LOJA"	})

aAdd(aFO2DePara,{"E1_PREFIXO"	,"FO2_PREFIX"})
aAdd(aFO2DePara,{"E1_BCOCHQ" 	,"FO2_BANCO" })
aAdd(aFO2DePara,{"E1_AGECHQ"	,"FO2_AGENCI"})
aAdd(aFO2DePara,{"E1_CTACHQ"	,"FO2_CONTA" })
aAdd(aFO2DePara,{"E1_NUM"		,"FO2_NUM"	 })
aAdd(aFO2DePara,{"E1_PARCELA"	,"FO2_PARCEL" })
aAdd(aFO2DePara,{"E1_EMITCHQ"	,"FO2_EMITEN"})
aAdd(aFO2DePara,{"E1_VENCTO"	,"FO2_VENCTO"})
If lOpcAuto .And. nOutrMoed = 3
	aAdd(aFO2DePara,{"E1_VALOR"	,"FO2_VLPARC"})
Else
	aAdd(aFO2DePara,{"E1_VLCRUZ","FO2_VLPARC"})
EndIf
aAdd(aFO2DePara,{"E1_ACRESC"	,"FO2_ACRESC"})
aAdd(aFO2DePara,{"E1_DECRESC"	,"FO2_DECRES"})
aAdd(aFO2DePara,{"E1_TOTAL"		,"FO2_TOTAL" })
aAdd(aFO2DePara,{"nValorJur"	,"FO2_VLJUR" })


If 	FwIsInCallStack("FINA460")
	aEnableButtons := {{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.T., STR0215 },{.T., STR0216},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil}}	//"Confirmar"###"Fechar"
Else
	aEnableButtons := {{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.T., STR0217 },{.T., STR0216 },{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil} }	//"Salvar Simulação"###
EndIf

If !lOpcAuto

	aSize := MSADVSIZE()
	If FwIsInCallStack("FINA460")
		_nOper 	  := OPER_LIQUIDAR
		If lCMC7Fin() .and. IW_MsgBox(STR0122,STR0001,"YESNO")  //"Deseja utilizar a leitora de cheques?"###"Liquidação"
			lCmc7 := .T.
		Else
			lCmc7 := .F.		
		Endif
	Else
		_nOper 	  := OPER_INCLUI	
	EndIf

	oModelLiq := FWLoadModel("FINA460A")//Carrega estrutura do model
	oModelLiq:SetOperation(MODEL_OPERATION_INSERT)//Define operação de inclusao
	oModelLiq:Activate()//Ativa o model	
	bCancel   :=  { |oModelLiq| F460NoAlt(oModelLiq)}
	
	F460Mtela(@cAliasTMP, oModelLiq, cCliente, cLoja, nMoeda, cNatureza, lCMC7 )//Carrega o model com os dados
	If FwIsInCallStack("FINA460")
		If lCmC7	
			// Abre porta para CMC7
			If lOpenCmc7 == Nil
				OpenCMC7()
				lOpenCmc7 := .T.
			EndIf	
			
			If F460CMC7( oModelLiq ) = 0
				Return .F.
			EndIf
			
			_lUserButton := .T.
			FWExecView( STR0218 , "FINA460B", 3,  /*oDlgKco*/, {|| .T. } , /*bOk*/ , /*nPercReducao*/, aEnableButtons, bCancel, /*cOperatId*/ , /*cToolBar*/ , oModelLiq )	//"Inclusão de Liquidação a receber"
			_lUserButton := .F.
		Else		 
			_lUserButton := .T.
			FWExecView( STR0218 , "FINA460A", 3,  /*oDlgKco*/, {|| .T. } , /*bOk*/ , /*nPercReducao*/, aEnableButtons, bCancel, /*cOperatId*/ , /*cToolBar*/ , oModelLiq )	//"Inclusão de Liquidação a receber"
			_lUserButton := .F.
		EndIf
	Else
		_lUserButton := .T.
		FWExecView( STR0212 , "FINA460A", 3,  /*oDlgKco*/, {|| .T. } , /*bOk*/ , /*nPercReducao*/, aEnableButtons, bCancel, /*cOperatId*/ , /*cToolBar*/ , oModelLiq )//"Inclusão de Simulação"
		_lUserButton := .F.
	EndIf
	
Else
   	If __lExcImpo == Nil
		__lExcImpo := FindFunction("ExcluiImpo")
	EndIf
	
	If __lCnabImp == Nil 
		__lCnabImp := SuperGetMV("MV_CNABIMP", .F., .F.)
	EndIf	
	//Grava a Area para posicionamento indice (2) na cAliasTMP
	aAreaTMP := GetArea()
   	
	//Marca todos os titulos do arquivo temporario
	DbSelectArea(cAliasTMP)
	SE1->(dbSetOrder(1)) 
	DbGoTop()
	
	While !Eof()
		SE1->(MSSeek((cAliasTMP)->CHAVE))
		
		If SE1->(MsRLock()) .And. SE1->E1_SALDO > 0
			If lAutMrkPix .And. __lExcImpo .And. !__lCnabImp
				lTemImpPix := BorderoImp(SE1->E1_FILORIG, SE1->E1_NUMBOR, "R", SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA)
				
				If !lTemImpPix
					lTemImpPix := HistPagPix(SE1->E1_FILORIG, SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), @__oPagPix)
					
					If !lTemImpPix .And. (lSitCobPix := IIf(!lSitCobPix, Eval(bEvalPix), lSitCobPix))
						If ExcluiImpo(SE1->E1_FILIAL, SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA, Nil)
							cIdDocFK7 := FinBuscaFK7(SE1->E1_FILIAL+"|"+SE1->E1_PREFIXO+"|"+SE1->E1_NUM+"|"+SE1->E1_PARCELA+"|"+SE1->E1_TIPO+"|"+SE1->E1_CLIENTE+"|"+SE1->E1_LOJA, "SE1", SE1->E1_FILORIG)
							PIXCancel(SE1->E1_FILIAL, cIdDocFK7)
							F460AtuFO1(nMoeda,cAliasTMP)				
						EndIf						
					EndIf
				EndIf
			EndIf	
			
			RecLock((cAliasTMP))			
			FO1_MARK := lAutMrkPix
			(cAliasTMP)->(MsUnlock())
			
			nValor += (cAliasTMP)->FO1_TOTAL
			nQtdTit++
		EndIf
		
		(cAliasTMP)->(dbSkip())
	End
	
	RestArea(aAreaTMP)	
	DbSelectArea(cAliasTMP)
	(cAliasTMP)->(DbGoTop())
	
	If (cAliasTMP)->(!Eof()) 
	
		/* Alterado para o ponto de entrada MODELCOMMITNTTS do MVC (FINA460A)
		If Existblock("F460GRV")
			Execblock("F460GRV",.F.,.F.)
		EndIf
		*/
		
		If nOpcX == 2
			_nOper 	:= OPER_LIQUIDAR
		ElseIf nOpcX == 4
			_nOper	:= OPER_RELIQUIDAR
		Else	
			_nOper := nOpcX
		EndIf
		
		oModelLiq := FWLoadModel("FINA460A")//Carrega estrutura do model
		oModelLiq:SetOperation( MODEL_OPERATION_INSERT ) //Define operação de inclusao
		oModelLiq:Activate()//Ativa o model	
		bCancel   :=  { |oModelLiq| F460NoAlt(oModelLiq) }
		F460Mtela(@cAliasTMP, oModelLiq, cCliente, cLoja, nMoeda, cNatureza )//Carrega o model com os dados
		
		oFO0	:=  oModelLiq:GetModel("MASTERFO0")
		oFO1	:=	oModelLiq:GetModel("TITSELFO1")
		oFO2	:=	oModelLiq:GetModel("TITGERFO2")
		
		//De Para entre tabela SE1 - Variaveis Private(Rotina Antiga) e FO0(Rotina Nova)	
		For nY := 1 To Len(aAutoCab)
			nPos := aScan( aFO0DePara ,{|x| Alltrim(x[1])== aAutoCab[nY][1] })
			If nPos > 0 .And. oFO0:CanSetValue(aFO0DePara[nPos][2])		
				oFO0:SetValue(aFO0DePara[nPos][2], aAutoCab[nY][2])
			ElseIf oFO0:HasField(aAutoCab[nY][1]) .And. oFO0:CanSetValue( aAutoCab[nY][1] )
				oFO0:SetValue(aAutoCab[nY][1], aAutoCab[nY][2])
			EndIf
		Next nY
		
		nTxJrg		:= oFO0:GetValue("FO0_TXJRG")
		nMoedaFO0	:= oFO0:GetValue("FO0_MOEDA")
		
		//--------------------------------------------------------------------------------
		// Corrige possiveis diferencas entre o valor selecionado e o 
		// apurado ap¢s a divisao das parcelas						   	
		//--------------------------------------------------------------------------------
		
		If ! Empty(cCondicao)
			oFO0:SetValue("FO0_COND", cCondicao)
			aParcelas 	:= Condicao(nValor,oFO0:GetValue("FO0_COND"),,oFO0:GetValue("FO0_DATA"))
			
			For nX := 1 to Len(aParcelas)
				nValAux += aParcelas [nX, 2]
			Next nX
			
			If nValAux != nValor
				nDifer := Round(nValor - nValAux,2)
				aParcelas [ Len(aParcelas), 2 ] += nDifer
			EndIf
			aParcelas := {}
		Endif
		
		oFO0:SetValue("FO0_TIPO", E1_TIPO )
		
		SE1->( dbClearFilter() )
				
		For nX := 1 To Len(aAutoItens)
			
			If nX <> 1 
				oFO2:AddLine()
				oFO2:GoLine(oFO2:Length())
			Else
				oFO2:GoLine(nX)
			EndIf
		
			//Prefixo
			If ExistIni("E1_PREFIXO")
				cPrefixAux := InitPad(SX3->X3_RELACAO)
			Else
				If !Empty(cMVPAR08)
					cPrefixAux := cMVPAR08
				Else
					cPrefixAux := Space(TamSx3("E1_PREFIXO")[1])
				Endif
			EndIf

			cNum	:= Iif((nW := aScan(aAutoItens[nX],{|x| Alltrim(x[1])=="E1_NUM" })) > 0	, aAutoItens[nX,nW,2] , Space(TamSx3("FO2_NUM")[1]))		// Número do Título.
			If oFO2:CanSetValue("FO2_NUM")
				oFO2:SetValue("FO2_NUM", cNum)
			EndIf
			
			cPrefix		:= Iif((nW := aScan(aAutoItens[nX],{|x| Alltrim(x[1])=="E1_PREFIXO" })) > 0 , aAutoItens[nX, nW, 2] , cPrefixAux )	//Prefixo.
			If oFO2:CanSetValue("FO2_PREFIX")
				oFO2:SetValue("FO2_PREFIX", cPrefix)
			EndIf		
			
			cBanco 		:= Iif((nW := aScan(aAutoItens[nX],{|x| Alltrim(x[1])=="E1_BCOCHQ" })) > 0 , aAutoItens[nX,nW,2] , Space(TamSx3("FO2_BANCO") [1])) 	// Banco
			If oFO2:CanSetValue("FO2_BANCO")
				oFO2:SetValue("FO2_BANCO", cBanco)
			EndIf
			
			cAgencia 	:= Iif((nW := aScan(aAutoItens[nX],{|x| Alltrim(x[1])=="E1_AGECHQ" })) > 0 , aAutoItens[nX,nW,2] , Space(TamSx3("FO2_AGENCI")[1]))	// Agencia
			If oFO2:CanSetValue("FO2_AGENCI")
				oFO2:SetValue("FO2_AGENCI", cAgencia)
			EndIf		
			
			cContaC 	:= Iif((nW := aScan(aAutoItens[nX],{|x| Alltrim(x[1])=="E1_CTACHQ" })) > 0 , aAutoItens[nX,nW,2] , Space(TamSx3("FO2_CONTA") [1]))	// Conta Corrente
			If oFO2:CanSetValue("FO2_CONTA")
				oFO2:SetValue("FO2_CONTA", cContaC)
			EndIf	
			
			cParcCli	:= Iif((nW := aScan(aAutoItens[nX],{|x| Alltrim(x[1])=="E1_PARCELA" })) > 0	, aAutoItens[nX,nW,2] , Space(TamSx3("FO2_PARCEL")[1]))		// Parcela do Cliente.
			If nW > 0
				If oFO2:CanSetValue("FO2_PARCEL")
					lParcAuto := .T.
					oFO2:SetValue("FO2_PARCEL", cParcCli)
				EndIf
			Else
				lParcAuto = .F.
			Endif	
			
			cNumCH		:= Iif((nW := aScan(aAutoItens[nX],{|x| Alltrim(x[1])=="E1_NUM" })) > 0 , aAutoItens[nX,nW,2] , Space(TamSx3("FO2_NUMCH")[1]))		// Número do Cheque.
			If oFO2:CanSetValue("FO2_NUMCH")
				oFO2:SetValue("FO2_NUMCH", cNumCh)
			EndIf		
			
			dVencto 	:= Iif((nW := aScan(aAutoItens[nX],{|x| Alltrim(x[1])=="E1_VENCTO" }))  > 0 , aAutoItens[nX,nW,2] , CTOD(SPACE(8)))	// Vencimento
			If oFO2:CanSetValue("FO2_VENCTO")
				oFO2:SetValue("FO2_VENCTO", dVencto)
			EndIf		
			
			cEmitCh 	:= Iif((nW := aScan(aAutoItens[nX],{|x| Alltrim(x[1])=="E1_EMITCHQ"}))  > 0 , aAutoItens[nX,nW,2] , space(40))			// Nome do emitente
			If oFO2:CanSetValue("FO2_EMITEN")
				oFO2:SetValue("FO2_EMITEN", cEmitCh)
			EndIf		  
			
			If lOpcAuto .And. nOutrMoed = 3
				nValParc := Iif((nW := aScan(aAutoItens[nX],{|x| Alltrim(x[1])=="E1_VALOR" }))  > 0 , aAutoItens[nX,nW,2] , VAL("0"))	// Valor da Parcela
			Else
				nValParc := Iif((nW := aScan(aAutoItens[nX],{|x| Alltrim(x[1])=="E1_VLCRUZ" }))  > 0 , aAutoItens[nX,nW,2] , VAL("0"))	// Valor da Parcela
			EndIf
			If oFO2:CanSetValue("FO2_VALOR")
				oFO2:SetValue("FO2_VALOR", nValParc)
			EndIf

			nAcrescimo	:= Iif((nW := aScan(aAutoItens[nX],{|x| Alltrim(x[1])=="E1_ACRESC" }))	> 0 , aAutoItens[nX,nW,2] , 0)					// Acrescimo        
			If nAcrescimo > 0 	//Se existe Acrecimo desconsidera Decrescimo
				nDecrescimo :=  0		// Decrescimo      		
				nValCh 		:= nValParc+nAcrescimo	// Valor do Cheque
			Else
				nDecrescimo := Iif((nW :=aScan(aAutoItens[nX],{|x| Alltrim(x[1])=="E1_DECRESC" })) > 0 , aAutoItens[nX,nW,2] , 0)		// Decrescimo      				
				nValCh		:= nValParc-nDecrescimo	// Valor do Cheque
			EndIf
			
			If oFO2:CanSetValue("FO2_DECRES")
				oFO2:SetValue("FO2_DECRES", nDecrescimo)
			EndIf
			
			If oFO2:CanSetValue("FO2_ACRESC")
				oFO2:SetValue("FO2_ACRESC", nAcrescimo)
			EndIf
			
			If oFO2:CanSetValue("FO2_TOTAL")
				oFO2:SetValue("FO2_TOTAL", nValCh)
			EndIf
			
			oFO2:LoadValue("FO2_IDSIM" ,FWUUIDV4() ) //Chave ID tabela FK1.
			oFO2:LoadValue("FO2_PROCES",oFO0:GetValue("FO0_PROCES")) //Processo
			oFO2:LoadValue("FO2_VERSAO",oFO0:GetValue("FO0_VERSAO")) //Versão
			
			nValJur := Iif((nW :=aScan(aAutoItens[nX],{|x| Alltrim(x[1])=="nValorJur" })) > 0 , aAutoItens[nX,nW,2] , 0) 
			If nValJur == 0 
				oFO2:LoadValue("FO2_TXJUR",nTxJrg)
				nValJur := faJuros(	oFO2:GetValue("FO2_VALOR"),oFO2:GetValue("FO2_VALOR"),oFO2:GetValue("FO2_VENCTO"),;
								, oFO2:GetValue("FO2_TXJUR"),oFO0:GetValue("FO0_MOEDA"),,dDatabase,,,;
								oFO2:GetValue("FO2_VENCTO"),,,,,,/*Recalculo .T. */ , .T. /*Liquidação*/)
			Else 
				oFO2:LoadValue("FO2_VLPARC", oFO2:GetValue("FO2_VLPARC") + nValJur )
			EndIf

			oFO2:LoadValue("FO2_VLJUR",  Round(NoRound(xMoeda(nValJur,nMoedaFO0,nMoedaFO0,,3),3),2))
			
			nValParT 	:= Iif((nW := aScan(aAutoItens[nX],{|x| Alltrim(x[1])=="E1_VLCRUZ" }))  > 0 , aAutoItens[nX,nW,2] , VAL("0"))	// Valor da Parcela
			oFO2:LoadValue("FO2_TOTAL",nValParT + oFO2:GetValue("FO2_VLJUR") + oFO2:GetValue("FO2_ACRESC") - oFO2:GetValue("FO2_DECRES") ) // valor total negociado
										
			//De Para entre tabela SE1(Rotina Antiga) e FO2(Rotina Nova)	
			For nY := 1 To Len(aFO2DePara)
				nPos := aScan(aAutoItens[nX],{|x| Alltrim(x[1]) == aFO2DePara[nY,1] })
				If nPos > 0 .And. oFO2:HasField(aFO2DePara[nY][2]) .And. oFO2:CanSetValue(aFO2DePara[nY][2])		
					oFO2:SetValue(aFO2DePara[nY][2], aAutoItens[nX,nPos,2])
				EndIf
			Next nY
																								
		Next nX
		
		//Chama ações para realizar o dinamismo da tela. Utilizado para atualização dos juros, multas, etc.
		F460JurMul(oModelLiq, "FO0_TXJUR" )
		F460JurMul(oModelLiq, "FO0_TXMUL" )
		F460JurMul(oModelLiq, "FO0_TXJRG" )		
		
		nValAuto := 0
		For nX := 1 To oFO1:Length()
			oFO1:GoLine(nX)
			nValAuto += oFO1:GetValue("FO1_TOTAL")
		Next nX 
		
		//--------------------------------------------------------------------------------
		// Corrige possiveis diferencas entre o valor selecionado e o 
		// apurado ap¢s a divisao das parcelas						   	
		//--------------------------------------------------------------------------------
		
		If ! Empty(cCondicao)
			aParcelas 	:= Condicao(nValAuto,oFO0:GetValue("FO0_COND"),,oFO0:GetValue("FO0_DATA"))
			
			nValAux := 0
			For nX := 1 to Len (aParcelas)
				nValAux += aParcelas [nX, 2]
			Next nX
		
			If nValAux != nValAuto
				nDifer := Round(nValAuto - nValAux,2)
				aParcelas [ Len(aParcelas), 2 ] += nDifer
			EndIf
			aParcelas := {}
		Endif
		
		For nX := 1 To oFO2:Length()
			oFO2:GoLine(nX)
			oFO2:LoadValue("FO2_TXJUR",nTxJrg)
			nValJur := faJuros(	oFO2:GetValue("FO2_VALOR"),oFO2:GetValue("FO2_VALOR"),oFO2:GetValue("FO2_VENCTO"),;
								, oFO2:GetValue("FO2_TXJUR"),oFO0:GetValue("FO0_MOEDA"),,dDatabase,,,;
								oFO2:GetValue("FO2_VENCTO"),,,,,,/*Recalculo .T. */ , .T. /*Liquidação*/)
			If oFO2:GetValue("FO2_VLJUR") == 0 .And. nValJur <> 0
				oFO2:LoadValue("FO2_VLJUR",  Round(NoRound(xMoeda(nValJur,nMoedaFO0,nMoedaFO0,,3),3),2))	
			EndIf
			nValParT 	:= Iif((nW := aScan(aAutoItens[nX],{|x| Alltrim(x[1])=="E1_VLCRUZ" }))  > 0 , aAutoItens[nX,nW,2] , VAL("0"))	// Valor da Parcela
			oFO2:LoadValue("FO2_TOTAL",nValParT + oFO2:GetValue("FO2_VLJUR") + oFO2:GetValue("FO2_ACRESC") - oFO2:GetValue("FO2_DECRES") ) // valor total negociado
			
			If oFO2:GetValue("FO2_TXJUR") == 0 .And. oFO0:GetValue("FO0_TXJUR") > 0 
				oFO2:LoadValue("FO2_TXJUR", oFO0:GetValue("FO0_TXJUR") )
				oFO2:LoadValue("FO2_VLJUR", Round(NoRound(xMoeda( oFO2:GetValue("FO2_TOTAL") - oFO2:GetValue("FO2_VALOR"),nMoedaFO0,nMoedaFO0,,3),3),2) )
			EndIf
			
		Next nX

		if lOpcAuto
			for nX := 1 to oFO2:GetQTDLine()
				oFO2:GoLine(nX)
				a460PreNum("1","1")
				a460PreNum("2","2")
				a460PreNum("4","4") 
			next nX
		endif
		oFO2:GoLine(1)
											
		If oModelLiq:VldData()
			oModelLiq:CommitData()
		Else
			aLog := oModelLiq:GetErrorMessage()
			For nX := 1 to Len(aLog)
				If !Empty(aLog[nX])
					cLog += Alltrim(aLog[nX]) + CRLF
				EndIf
			Next nX
			lMsErroAuto := .T.
			AutoGRLog(cLog)
			lRet := .F.	
		EndIf				
											
		oModelLiq:DeActivate()
		oModelLiq:Destroy()
		oModelLiq := NIL
	
	Else		
		lMsErroAuto := .T.
	EndIf

EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F460GerParc
Função que retorna a parcela do titulo

Caso seja atingido o número máximo de parcelas, será incrementado o 
número do titulo

@author Mauricio Pequim Jr
@version P12.1.8
@since	11/01/2016		
																				
/*/
//-------------------------------------------------------------------

Function F460GerParc(oModelFO2,nLinPos,cPrefixo,cNum,cTipoTit,cLastParc,lSomaPc)

Local nTamMV1DUP	:= 0
Local cUltParc   	:= TamParcela("E2_PARCELA","Z","ZZ","ZZZ")
Local nLenNum		:= Len(SE1->E1_NUM)
Local nTamFO2		:= oModelFO2:Length()
Local nX			:= 0
Local nPosAtu		:= 0 
Local lAchou		:= .T.
Local cNumFO2		:= ""
Local lTmka350      := FunName() == "TMKA350"
Local cParc2Ger		:= ""

DEFAULT lSomaPc := .T.

If nTamParc == NIL
	nTamParc := TamSx3("E1_PARCELA")[1]
Endif

cParc2Ger  := cMV1Dup()
nTamMV1DUP := Len(cParc2Ger)

If nTamParc > nTamMV1DUP
	cParc2Ger := cParc2Ger + SPACE( nTamParc-nTamMV1DUP )
ElseIf nTamParc < nTamMV1DUP
	cParc2Ger := Substr(cParc2Ger,1,nTamParc)
EndIf

If lTmka350 .or. lOpcAuto

    If oModelFO2:Length() == 1
		If lOpcAuto
			If !lParcAuto
				oModelFO2:LoadValue("FO2_PARCEL", cParc2Ger)
			EndIf
		Else
			oModelFO2:LoadValue("FO2_PARCEL", cParc2Ger)
		EndIf
    Else
		If !lParcAuto
			For nX := 1 To oModelFO2:Length()
				oModelFO2:GoLine(nX)
				cNumFO2 := OMODELFO2:GETVALUE("FO2_NUM")
				If oModelFO2:SeekLine({{"FO2_PREFIX", cPrefixo },{"FO2_NUM", cNumFO2 },{"FO2_PARCEL", cParc2Ger },{"FO2_TIPO", cTipoTit}})
					oModelFO2:LoadValue("FO2_PARCEL", cParc2Ger)
					If nX == oModelFO2:Length()
						Exit
					Else
						cParc2Ger := Soma1(OMODELFO2:GETVALUE("FO2_PARCEL"),,.T.)
					Endif
				Else
					If lTmka350
						cParc2Ger := Soma1(OMODELFO2:GETVALUE("FO2_PARCEL"),,.T.)
					Else
						oModelFO2:LoadValue("FO2_PARCEL", cParc2Ger)
					EndIf
					If nX == oModelFO2:Length()
						Exit
					Endif
				EndIf
			Next nX
		EndIf
	Endif
	cLastParc := cParc2Ger
	
Else

	If Empty(cLastParc)
		If !Empty(cParc2Ger)
			cLastParc := PADL(cParc2Ger,Len(cParc2Ger)/*nTamParc*/,"0")
		Else
			cLastParc := STRZero(1,nTamParc)
		EndIf
	ElseIf lSomaPc
		cLastParc := Soma1(cLastParc/*,nTamParc,.T.*/ ) 
	Endif
	
	cLastParc := Upper(cLastParc)

EndIf 

//-------------------------------------------------------------------
// Verifica se o titulo ja existe no SE1
//-------------------------------------------------------------------
DbSelectArea("SE1")
SE1->(DbSetOrder(1))
If SE1->(MsSeek(xFilial("SE1")+cPrefixo+cNum+cLastParc+cTipoTit))
	While ( SE1->(Found()) )
		If ( cLastParc == cUltParc )
			If !Empty(cParc2Ger)
				cLastParc := PADL(cParc2Ger,nTamParc,"0")
			Else
				cLastParc := STRZero(1,nTamParc)
			EndIf
			cNum := Soma1(cNum,nLenNum)
		Else
			cLastParc := Soma1(cLastParc,nTamParc)
		EndIf
		SE1->(MsSeek(xFilial("SE1")+cPrefixo+cNum+cLastParc+cTipoTit))
	EndDo
EndIf

//-------------------------------------------------------------------
// Verifica se o titulo ja existe no grid
//-------------------------------------------------------------------
If nTamFO2 > 1
	If nLinPos > 1 .And. !lSomaPc

		lAchou := oModelFO2:SeekLine( {  {"FO2_TIPO", cTipoTit },{"FO2_PREFIX", cPrefixo },{"FO2_NUM", cNum },{"FO2_PARCEL", cLastParc } } )

		nPosAtu := oModelFO2:GetLine()
		If lAchou
			For nx := 1 to oModelFO2:Length()
				oModelFO2:GoLine(nX)
				If nPosAtu <> nX
					If oModelFO2:GetValue("FO2_TIPO") == cTipoTit .And. oModelFO2:GetValue("FO2_PREFIX") == cPrefixo .And. oModelFO2:GetValue("FO2_NUM") == cNum .And. oModelFO2:GetValue("FO2_PARCEL") == cLastParc
						cLastParc := Soma1(cLastParc/*,nTamParc,.T.*/) 
					Endif
				EndIf	
			NExt nX
		EndIf		
	EndIf
EndIf

oModelFO2:Goline(nLinPos)

Return .T.

//------------------------------------------------------------------------------
/*/{Protheus.doc} F460STRFO1
Rotina que realiza a criação da estutura para a tabela temporária baseada na
tabela FO1, será utilizada pelos fontes FINA460 e TMKA271d

@sample 	F460STRFO1(aCampos)
@param		aCampos		Array passado por referência que irá receber a estrutura
				
@author 	Marcio Martins Pereira
@since		18/02/2015
@version	P12
/*/
//------------------------------------------------------------------------------
Function F460STRFO1()

Local nTamTit	:= TamSX3("E1_PREFIXO")[1]+TamSX3("E1_NUM")[1]+TamSX3("E1_PARCELA")[1]+TamSX3("E1_TIPO")[1]
Local nTamChave	:= TamSX3("E1_FILIAL")[1]+TamSX3("E1_CLIENTE")[1]+TamSX3("E1_LOJA")[1]+nTamTit
Local aCampos   := FO1->( DbStruct())

aAdd(aCampos,{"FO1_PREFIX","C",TamSX3("E1_PREFIXO")[1],0})
aAdd(aCampos,{"FO1_NUM"   ,"C",TamSX3("E1_NUM")[1],0})
aAdd(aCampos,{"FO1_PARCEL","C",TamSX3("E1_PARCELA")[1],0})
aAdd(aCampos,{"FO1_TIPO"  ,"C",TamSX3("E1_TIPO")[1],0})
aAdd(aCampos,{"FO1_NATURE","C",TamSX3("E1_NATUREZ")[1],0})
aAdd(aCampos,{"FO1_CLIENT","C",TamSX3("E1_CLIENTE")[1],0})
aAdd(aCampos,{"FO1_LOJA"  ,"C",TamSX3("E1_LOJA")[1],0})
aAdd(aCampos,{"FO1_EMIS"  ,"D",TamSX3("E1_EMISSAO")[1],0})
aAdd(aCampos,{"FO1_VENCTO","D",TamSX3("E1_VENCTO")[1],0})
aAdd(aCampos,{"FO1_VENCRE","D",TamSX3("E1_VENCREA")[1],0})
aAdd(aCampos,{"FO1_BAIXA" ,"D",TamSX3("E1_BAIXA")[1],0})
aAdd(aCampos,{"FO1_VALCVT","N",TamSX3("E1_VALOR")[1],2})
aAdd(aCampos,{"FO1_VLBAIX","N",TamSX3("E1_VALOR")[1],2})
aAdd(aCampos,{"FO1_HIST"  ,"C",TamSX3("E1_HIST")[1],2})
aAdd(aCampos,{"FO1_MARK"  ,"L", 1,0})
aAdd(aCampos,{"FO1_CCUST" ,"C",TamSX3("E1_CCUSTO")[1],2})
aAdd(aCampos,{"FO1_ITEMCT","C",TamSX3("E1_ITEMCTA")[1],2})
aAdd(aCampos,{"FO1_CLVL"  ,"C",TamSX3("E1_CLVL")[1],2})
aAdd(aCampos,{"FO1_CREDIT","C",TamSX3("E1_CREDIT")[1],2})
aAdd(aCampos,{"FO1_DEBITO","C",TamSX3("E1_DEBITO")[1],2})
aAdd(aCampos,{"FO1_CCC"   ,"C",TamSX3("E1_CCC")[1],2})
aAdd(aCampos,{"FO1_CCD"   ,"C",TamSX3("E1_CCC")[1],2})
aAdd(aCampos,{"FO1_ITEMC" ,"C",TamSX3("E1_ITEMC")[1],2})
aAdd(aCampos,{"FO1_ITEMD" ,"C",TamSX3("E1_ITEMD")[1],2})
aAdd(aCampos,{"FO1_CLVLCR","C",TamSX3("E1_CLVLCR")[1],2})
aAdd(aCampos,{"FO1_CLVLDB","C",TamSX3("E1_CLVLCR")[1],2})
aAdd(aCampos,{"CHAVE"	  ,"C",nTamChave,0})
aAdd(aCampos,{"CHAVE2"	  ,"C",nTamChave,0})
aAdd(aCampos,{"BASEIMP"	  ,"N",15,2})
aAdd(aCampos,{"PIS"		  ,"N",15,2})
aAdd(aCampos,{"COFINS"	  ,"N",15,2})
aAdd(aCampos,{"CSLL"	  ,"N",15,2})
aAdd(aCampos,{"OUTRIMP"	  ,"N",15,2})
aAdd(aCampos,{"TITPAI"	  ,"C",nTamChave,0})

Return aCampos

//------------------------------------------------------------------------------
/*/{Protheus.doc} F460IntId
Limpa o array de internal IDs dos titulos deletados pelo cancelamento da 
Liquidação quando chamado do adapter FINI460

@sample 	F460STRFO1()
				
@author 	Mauricio Pequim Jr
@since	03/08/2016
@version	P12
/*/
//------------------------------------------------------------------------------
Function F460IntId()

Return aFINI460SE1

//------------------------------------------------------------------------------
/*/{Protheus.doc} F460IArrSE1
Limpa o array de internal IDs dos titulos deletados pelo cancelamento da 
Liquidação quando chamado do adapter FINI460

@sample 	F460STRFO1()
@author 	Mauricio Pequim Jr
@since	03/08/2016
@version	P12
/*/
//------------------------------------------------------------------------------
Function F460IArrSE1()

aSize(aFINI460SE1,0)
aFINI460SE1 := Nil

Return 

//-------------------------------------------------------------------
/*/{Protheus.doc} A460PrxNum()
Calcula o proximo número 								  

@author Simone Mie Sato Kakinoana
@version P12.1.17
@since	07/02/2018	
/*/
//-------------------------------------------------------------------
Static Function a460PrxNum(cFilOrig,cTipo,cPrefixo)

	Local cQuery	:= ""
	Local cRet		:= ""
	Local cProxNum	:= ""
	Local cTMPNum	:= GetNextAlias()
	Local aArea	:= GetArea()
	cFilOrig := xFilial("SE1")
	
	cQuery := " SELECT MAX(E1_NUM) AS NUMMAX " 		+ CRLF
	cQuery += " FROM " + RetSqlName("SE1") + " SE1 "	+ CRLF
	cQuery += " WHERE " 								   + CRLF
	cQuery += " SE1.E1_FILIAL 	= '" + cFilOrig + "' AND " + CRLF
	cQuery += " SE1.E1_TIPO 	= '" + cTipo    + "' AND " + CRLF
	cQuery += " SE1.E1_PREFIXO 	= '" + cPrefixo + "' AND " + CRLF
	cQuery += " SE1.D_E_L_E_T_	= ''                     " + CRLF
	cQuery 	:= ChangeQuery(cQuery)
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cTMPNum, .F., .T.)
		
	cProxNum := Iif(!Empty((cTMPNum)->NUMMAX),SOMA1(Alltrim((cTMPNum)->NUMMAX)),SOMA1((cTMPNum)->NUMMAX))
	While !MayIUseCode( cfilOrig + cPrefixo + cProxNum)  //verifica se esta na memoria, sendo usado
		// busca o proximo numero disponivel 
		cProxNum := Soma1(cProxNum)
	EndDo
	(cTMPNum)->( dbCloseArea() )
	
	cRet	:= cProxNum	
	RestArea(aArea)

Return(cRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} FA460TXMoe
Validacao da taxa da moeda do titulo informado

@author Francisco Oliveira
@version P12.1.17
@since	12/07/2018	
/*/
//-------------------------------------------------------------------
Function FA460TXMOE()

Local aSvArea   := GetArea()
Local lRet		:= .T.
Local nX 		:= 0
Local nTotLiq	:= 0
Local nTotNeg	:= 0
Local nLenFO2	:= 0
Local nTtlMoeda	:= 0
Local nTxMoeDia	:= 0
Local nTxMoeFO0 := 0
Local oModel 	:= FWModelActive()
Local oView		:= FWViewActive()
Local oSubFO0 	:= oModel:GetModel('MASTERFO0')
Local oSubFO1 	:= oModel:GetModel("TITSELFO1")
Local oSubFO2 	:= oModel:GetModel("TITGERFO2")
Local nTxMoed	:= oSubFO0:GetValue("FO0_TXMOED")
Local nMoedaFO0	:= oSubFO0:GetValue("FO0_MOEDA")
Local nMoedaFO1	:= 0
Local cChaveFO1 := ""
Local nFO2Vladic:= 0

dbSelectArea("SE1")
SE1->(dbSetOrder(1))

For nX := 1 To oSubFO1:Length() 

	oSubFO1:Goline(nX)
	cChaveFO1 := xFilial("SE1",oSubFO1:GetValue("FO1_FILORI")) + oSubFO1:GetValue("FO1_PREFIX") + oSubFO1:GetValue("FO1_NUM") + oSubFO1:GetValue("FO1_PARCEL") + oSubFO1:GetValue("FO1_TIPO")
	nMoedaFO1 := oSubFO1:GetValue("FO1_MOEDA")

	If (nMoedaFO1 <> nMoedaFO0) .Or. __nOpcOuMo = 3
	
		nTxMoeDia := RecMoeda(dDataBase, oSubFO1:GetValue("FO1_MOEDA") )
		If nTxMoed > 0  
			nTxMoeFO0 := nTxMoed
			If nMoedaFO0 == 1
				nTtlMoeda := Round(NoRound(xMoeda(oSubFO1:GetValue("FO1_SALDO"),oSubFO1:GetValue("FO1_MOEDA"),nMoedaFO0,dDataBase,3,nTxMoed,nTxMoeDia),3),2)
			Else
				nTtlMoeda := Round(NoRound(xMoeda(oSubFO1:GetValue("FO1_SALDO"),oSubFO1:GetValue("FO1_MOEDA"),nMoedaFO0,dDataBase,3,nTxMoeDia, nTxMoed),3),2)
			Endif
		Else
			If oSubFO1:GetValue("FO1_MOEDA") == 1
				nTxMoeFO0 := 1
				If nMoedaFO0 == 1
					nTtlMoeda := Round(NoRound(xMoeda(oSubFO1:GetValue("FO1_SALDO"),oSubFO1:GetValue("FO1_MOEDA"),nMoedaFO0,dDataBase,3,nTxMoeFO0,nTxMoeDia),3),2)
				Else
					nTxMoeDia := RecMoeda(dDataBase, oSubFO0:GetValue("FO0_MOEDA") )
					nTtlMoeda := Round(NoRound(xMoeda(oSubFO1:GetValue("FO1_SALDO"),oSubFO1:GetValue("FO1_MOEDA"),nMoedaFO0,dDataBase,3,nTxMoeFO0,nTxMoeDia),3),2)
				Endif
			Else
				nTxMoeFO0 := RecMoeda(dDataBase, oSubFO1:GetValue("FO1_MOEDA") )
				If nMoedaFO0 == 1
					nTtlMoeda := Round(NoRound(xMoeda(oSubFO1:GetValue("FO1_SALDO"),oSubFO1:GetValue("FO1_MOEDA"),nMoedaFO0,dDataBase,3,nTxMoeDia, nTxMoeFO0),3),2)
				Else
					nTxMoeDia := RecMoeda(dDataBase, oSubFO0:GetValue("FO0_MOEDA") )
					nTtlMoeda := Round(NoRound(xMoeda(oSubFO1:GetValue("FO1_SALDO"),oSubFO1:GetValue("FO1_MOEDA"),nMoedaFO0,dDataBase,3,nTxMoeFO0,nTxMoeDia),3),2)
				Endif
			Endif
		Endif

		If SE1->(dbSeek(cChaveFO1)) .AND. SE1->E1_MOEDA > 1 .AND. __nOpcOuMo <> 3
			oSubFO1:LoadValue("FO1_ACRESC",SE1->E1_ACRESC  * nTxMoeFO0)
			oSubFO1:LoadValue("FO1_DECRES",SE1->E1_DECRESC * nTxMoeFO0)
		EndIf

		If lCpoFO1Ad
			nFO2Vladic	:= oSubFO1:GetValue("FO1_VLADIC")
		Endif
		
		oSubFO1:LoadValue("FO1_VALCVT",nTtlMoeda )   //valor convertido na moeda da liquidação
		nTtlMoeda := nTtlMoeda + ((oSubFO1:GetValue("FO1_VLJUR") + oSubFO1:GetValue("FO1_VLMUL") + nFO2Vladic + oSubFO1:GetValue("FO1_ACRESC")) - oSubFO1:GetValue("FO1_DESCON") - oSubFO1:GetValue("FO1_DECRES"))
		oSubFO1:LoadValue("FO1_TXMOED",nTxMoeFO0)    //taxa da moeda na liquidação
		oSubFO1:LoadValue("FO1_TOTAL" ,nTtlMoeda )   //valor negociado na moeda da liquidação
		
		If oSubFO1:GetValue("FO1_MARK")
			If __nOpcOuMo = 1
				nTotLiq  += oSubFO1:GetValue("FO1_VALCVT") / nTxMoeFO0
			Else
				nTotLiq += oSubFO1:GetValue("FO1_VALCVT")
			EndIf
			nTotNeg  := nTotNeg + ((oSubFO1:GetValue("FO1_VALCVT") + oSubFO1:GetValue("FO1_VLJUR") + oSubFO1:GetValue("FO1_VLMUL") + nFO2Vladic + oSubFO1:GetValue("FO1_ACRESC")) - oSubFO1:GetValue("FO1_DESCON") - oSubFO1:GetValue("FO1_DECRES"))
		Endif
	
	Else
	
		If oSubFO1:GetValue("FO1_MARK")
			nTotLiq  += oSubFO1:GetValue("FO1_VALCVT")
			nTotNeg  := nTotNeg + ((oSubFO1:GetValue("FO1_VALCVT") + oSubFO1:GetValue("FO1_VLJUR") + oSubFO1:GetValue("FO1_VLMUL") + nFO2Vladic + oSubFO1:GetValue("FO1_ACRESC") ) - oSubFO1:GetValue("FO1_DESCON") - oSubFO1:GetValue("FO1_DECRES"))
		Endif
	
	Endif				

Next nX

oSubFO0:LoadValue("FO0_VLRNEG", nTotNeg)
oSubFO0:LoadValue("FO0_VLRLIQ", nTotLiq)

nLenFO2 := oSubFO2:Length()
	
If nLenFO2 > 0 
	nTotLiq := Round(nTotNeg / nLenFO2, 2)
	For nX := 1 To nLenFO2
		oSubFO2:Goline(nX)
		If !oSubFO2:IsDeleted()
			oSubFO2:LoadValue("FO2_VALOR" , nTotLiq )
			oSubFO2:LoadValue("FO2_TOTAL" , nTotLiq )
			oSubFO2:LoadValue("FO2_VLPARC", nTotLiq )
		Endif
	Next nX
Endif
	
If !lOpcAuto	
	oSubFO1:GoLine(1)
	oSubFO2:Goline(1)
	oView:Refresh()
EndIf

RestArea(aSvArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A460PrxPrc()
Calcula o proxima Parcela 								  

@author Wesley Lossani
@version P12.1.17
@since	14/08/2018	
/*/
//-------------------------------------------------------------------
Static Function a460PrxPrc(cNum,cPrefix,nTamParc)

	Local cQuery	:= ""
	Local cRet		:= ""
	Local cTMPPrc	:= ""
	Local aArea		:= GetArea()
	Local nTamPrf	:= TamSx3("E1_PREFIXO")[1]
	Local nTamNum	:= TamSx3("E1_NUM")[1]
	Local nTamTp 	:= TamSx3("E1_TIPO") [1]
	Local cParcel 	:= cMV1Dup()
	Local nTamMV1DUP:= Len(cParcel)

	Default cNum 	:= ""
	Default cPrefix := ""

	If nTamParc > nTamMV1DUP
		cParcel := cParcel + SPACE( nTamParc-nTamMV1DUP )
	ElseIf nTamParc < nTamMV1DUP
		cParcel := Substr(cParcel,1,nTamParc)
	EndIf

	SE1->(DbSetOrder(1))  //E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO
	If SE1->( MsSeek(xFilial("SE1")+ Padr(cPrefix,nTamPrf) + Padr(cNum,nTamNum)+ Padr(cParcel,nTamParc) + Padr("CH",nTamTp)) )

		cQuery := " SELECT MAX(E1_PARCELA) AS PARCMAX " 		+ CRLF
		cQuery += " FROM " + RetSqlName("SE1") + " SE1 "	+ CRLF
		cQuery += " WHERE " 									+ CRLF
		cQuery += " SE1.E1_FILIAL 	= '" + xFilial("SE1") + "' AND " + CRLF
		cQuery += " SE1.E1_TIPO 		= 'CH' AND " + CRLF
		cQuery += " SE1.E1_PREFIXO 	= '" + cPrefix + "' AND " + CRLF
		cQuery += " SE1.E1_NUM 	= '" + cNum + "' AND " + CRLF
		cQuery += " SE1.D_E_L_E_T_	= ''                     " + CRLF
		cQuery 	:= ChangeQuery(cQuery)
		cTMPPrc	:= GetNextAlias()
		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cTMPPrc, .F., .T.)
		cParcel	:= SOMA1((cTMPPrc)->PARCMAX)
		(cTMPPrc)->( dbCloseArea() )
		
	EndIf
	
	cRet := cParcel	
	RestArea(aArea)

Return(cRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} F460VldCar()
Valida os caracteres " ' " e " " " " para não dar error log em query 							  

@author Francisco Oliveira
@version P12.1.17
@since	30/01/2019	
/*/
//-------------------------------------------------------------------

Function F460VldCar(cTipoTit,cNum,cPrefixo, cParcela, cTpFO2)

Local lRet 		:= .T.
Local cVarChk	:= ""

Default cTipoTit := ""
Default cNum	 := ""
Default cPrefixo := ""
Default cParcela := ""
Default cTpFO2	 := ""

cVarChk := cTipoTit + "|" + cNum + "|" + cPrefixo + "|" + cParcela + "|" + cTpFO2

If CHR(39) $ cVarChk .Or. CHR(34) $ cVarChk
	lRet := .F.
Endif

Return lRet

//-------------------------------------------------------------------
/*{Protheus.doc} F460VldLiq()
Valida se existe alguma liquidação para o título posicionado

@author Alberto Teixeira
@version P12.1.17
@since 13/02/2019
//-------------------------------------------------------------------*/

Static Function F460VldLiq(cDadosSE5 as Character) as Logical

Local lRet 		As Logical
Local aAreaAtu 	As Array
Local aAreaSe5 	As Array

lRet 		:= .F.
aAreaAtu 	:= GetArea()
aAreaSe5 	:= SE5->(GetArea())

SE5->(dbSetOrder(7))

If SE5->(dbSeek(xFilial("SE5") + cDadosSE5))
	While !SE5->(Eof()) .And. (xFilial("SE5") + cDadosSE5) == SE5->(E5_FILIAL + E5_PREFIXO + E5_NUMERO + E5_PARCELA + E5_TIPO + E5_CLIFOR + E5_LOJA)
		If SE5->E5_SITUACA <> 'C' .AND. SE5->E5_MOTBX == "LIQ"
			lRet := .T.
			Exit
		Endif
		SE5->(dbSkip())
	Enddo
Endif

RestArea(aAreaSe5)
RestArea(aAreaAtu)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A460VldMoe()
Valida a seleção dos campos 'Moeda' e 'Outras Moedas'. Só é permitida 
a utilização da opção '3-Variação monetária' qdo a 'Moeda' for diferente de 01.

@author Luis Felipe Geraldo
@version P12.1.17
@since	02/04/2019
/*/
//-------------------------------------------------------------------
Static Function A460VldMoe(cMoeda460,cOutrMoed)

Local lRet  := .T.
Local cMoed := Substr(cMoeda460,1,2)
Local cOutr := Substr(cOutrMoed,1,1)
Local lCpoTxMoed := FO0->(ColumnPos("FO0_TXMOED")) > 0
Local lIntPFS    := lJurXFin()//Integração SIGAPFS x SIGAFIN

If cOutr == "3" .And. cMoed == "01"
	lRet := .F.
	Help(" ",1,STR0264 ,, STR0265 ,2,0,,,,,,{ STR0266 }) //"Não Permitido" # "Não é permitido utilizar a opção '3 - Variação Monetária' com a Moeda '01'" # "Selecione outra opção e verifique o campo 'Moeda'"
ElseIf cOutr == "3" .And. !lCpoTxMoed
	lRet := .F.
	Help(" ",1,STR0264 ,, STR0268 ,2,0,,,,,,{ STR0269 }) //"Não Permitido" # "Para utilização dessa opção é necessária a criação do campo FO0_TXMOED" # "Escolha outra opção ou execute o compatibilizador UPDDISTR"	
EndIf

If lRet .And. lIntPFS .And. cOutr != "2" // Não permitir o campo Outras Moedas diferente de Não Considera
	lRet := .F.
	Help(" ", 1, STR0264,, STR0278, 2, 0,,,,,,{ STR0279 }) //"Não Permitido" # "Quando utilizada a integração entre SIGAPFS e Financeiro, a única opção permitida é a '2 - Não Considera'" # "Utilize a opção '2 - Não Considera'."
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A460GetCli()
Query para retornar dados da liquidação gerada.
Utilizada para verificar o cliente destino.

@author Leandro Fini
@version P12.1.17
@since	22/09/2020
/*/
//-------------------------------------------------------------------
Static Function A460GetCli(cLiqCan, cCliLiq, cLojaLiq)

Local cAliasQuery := GetNextAlias()
Local cQuery      := ""

Default cLiqCan  := ""
Default cCliLiq  := ""
Default cLojaLiq := ""

cQuery := "SELECT E1_FILIAL, "
cQuery += "E1_PREFIXO, "
cQuery += "E1_NUM, "
cQuery += "E1_PARCELA, "
cQuery += "E1_TIPO, "
cQuery += "E1_CLIENTE, "
cQuery += "E1_LOJA, "
cQuery += "E1_EMISSAO, "
cQuery += "E1_VENCTO, "
cQuery += "E1_NUMLIQ "
cQuery += "FROM " + RetSqlName("SE1") + " SE1 "
cQuery += "WHERE E1_FILIAL =  '" + fwxFilial("SE1") + "' "
cQuery += "  AND E1_NUMLIQ =  '" + cLiqCan + "'"
cQuery += "  AND SE1.D_E_L_E_T_ = ' ' "

cQuery 	:= ChangeQuery(cQuery)

dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasQuery, .F., .T.)

If (cAliasQuery)->(!Eof())
	cCliLiq := (cAliasQuery)->E1_CLIENTE
	cLojaLiq := (cAliasQuery)->E1_LOJA
EndIf

(cAliasQuery)->(DbCloseArea())

Return

/*/{Protheus.doc} lJurXFin
Conteúdo do parâmetro MV_JURTIPO
@author  Guilherme de Sordi
@since   28/01/2022
@version 12.1.37
/*/
static function lJurXFin() as character
	if __lJurXFin == NIL
		__lJurXFin := SuperGetMv("MV_JURXFIN", NIL, .F.) 
	endIf
return __lJurXFin

/*/{Protheus.doc} lJurXFin
Conteúdo do parâmetro MV_JURTIPO
@author  Guilherme de Sordi
@since   28/01/2022
@version 12.1.37
/*/
static function cMV1Dup() as character
	if __cMV1Dup == NIL
		__cMV1Dup := Alltrim(SuperGetMv("MV_1DUP"))
	endIf
return __cMV1Dup

/*/{Protheus.doc} lCMC7Fin
Conteúdo do parâmetro MV_CMC7FIN
@author  Guilherme de Sordi
@since   31/01/2022
@version 12.1.37
/*/
static function lCMC7Fin() as logical
	if __lCMC7Fin == NIL
		__lCMC7Fin := SuperGetMv("MV_CMC7FIN") == "S"
	endIf
return __lCMC7Fin

/*/{Protheus.doc} l460Cmc7
Verifica existência do P.E. FA460CMC7
@author  Guilherme de Sordi
@since   31/01/2022
@version 12.1.37
/*/
static function l460Cmc7() as logical
	if __l460Cmc7 == NIL
		__l460Cmc7 := ExistBlock("FA460CMC7")
	endIf
return __l460Cmc7


/*/{Protheus.doc} cancAtuFKD
	@description	Atualiza tabela FKD no cancelmento da liquidação.
	@author  		guilherme.sordi@totvs.com.br
	@since   		31/01/2022
	@version 		12.1.2210
	@params			aFK1, array, Vetor de string contendo campo FK1_IDFK1 da baixa de tipo doc VA que foi cancelada
	junto com a liquidação.
	@return			NIL
/*/
Static Function cancAtuFKD(aFK1 as Array) as Variant
	Local nX 		as Numeric
	Local lCancel 	as Logical
	Local cCart 	as Character
	Local nVlVa 	as Numeric
	Local cIdFKD 	as Character
	Local cIndexKey as Character

	nX 				:= 1
	lCancel 		:= .T.
	cCart 			:= "R"
	nVlVa 			:= 0
	cIdFKD 			:= ""
	cIndexKey 		:= ""

	FK6->(dbSetOrder(3)) //FK6_FILIAL+FK6_IDORIG+FK6_TABORI+FK6_TPDOC                                                                                                                      

	For nX := 1 to len(aFK1)
		cIndexKey := xFilial("FK6") + aFK1[nX] + "FK1" + "VA" 
		If FK6->(dbSeek(cIndexKey))
			While FK6->(!EOF()) .and. FK6->(FK6_FILIAL+FK6_IDORIG+FK6_TABORI+FK6_TPDOC) == cIndexKey
				nVlVa := FK6->FK6_VALMOV
				cIdFKD := FK6->FK6_IDFKD
				FAtuFKDBx(lCancel, cCart, NIL, nVlVa, cIdFKD)
				FK6->(dbSkip())
			EndDo
		EndIf
	Next Nx
Return Nil

/*/ {Protheus.doc} F460AtuFO1
	Função para atualizar os dados da FO1 com os valores dos impostos excluídos

	@author Simone Mie Sato Kakinoana
	@since 26/06/2022
	@version 1.0
/*/
Static Function F460AtuFO1(nMoeda As Numeric, cAliasTMP As Character)
	Local nTtlPos As Numeric
	Local nTtlNeg As Numeric
	
	Default nMoeda	:= 1
	
	//Inicializa variáveis.
	nTtlPos := (cAliasTMP)->(FO1_ACRESC+FO1_VLJUR+FO1_VLMUL+FO1_VACESS)
	nTtlNeg := (cAliasTMP)->(FO1_DECRES+FO1_VLABT+FO1_DESCON)
	
	Reclock(cAliasTMP,.F.)					
	(cAliasTMP)->FO1_BAIXA	:= SE1->E1_BAIXA
	(cAliasTMP)->FO1_SALDO	:= SE1->E1_SALDO
	(cAliasTMP)->FO1_VLBAIX	:= SE1->E1_VALOR - SE1->E1_SALDO
	(cAliasTMP)->FO1_VALCVT	:= Round(NoRound(xMoeda(SE1->E1_SALDO,SE1->E1_MOEDA,nMoeda,,3),3),2)
	(cAliasTMP)->FO1_TOTAL	:= (cAliasTMP)->FO1_VALCVT- nTtlNeg + nTtlPos
	Msunlock()	
return
