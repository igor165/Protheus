#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "finxbx.ch"
#INCLUDE "FILEIO.CH"

/* FINXATU.PRX */
Static lF070CM
Static lUltiLote
Static cTipoCM
Static __nValRA := 0

/* MATXFUNB.PRX */
Static __lGEMJUROS
Static __lE1_NCONTR
Static __lNewJuros
Static __lFJURCST
Static __lFJURREC
Static dLastPcc		:= CTOD("22/06/2015")

Static nLenPref		:= 0
Static nLenNume		:= 0
Static nLenParc		:= 0
Static nLenTipo		:= 0
Static nLenClie		:= 0
Static nLenLoja		:= 0
Static nLenNatu		:= 0
Static __nLenHist	:= 0
Static _lIniVar		:= .F.
//PCREQ-3768-Contas a Pagar_Valores Acessorios_CP
Static cNatIRF		:= NIL
Static nTamNat		:= NIL
//Inscrição de Cobrança.
Static __nMsgIns	:= 1 // 1 - Em lote, 2 - Em Lote confirmada, 3 - Em lote cancelado.

//Verificação de existência dos pontos de entrada
Static lFA070ADTSE5 := NIL
Static lf70GrSe1 	:= NIL
Static lF200GERA	:= NIL
Static lF070GerAb	:= NIL
Static lFinSalTit	:= NIL
Static lF070GrvHis	:= NIL
Static lFin70BxIr	:= NIL
Static lF070Imp2	:= NIL
Static lFa070Imp	:= NIL
Static lF070HIST	:= NIL
Static lFINAJURO	:= NIL
Static lF070DISS	:= NIL
Static lSE3FI070	:= NIL
Static lSE3F070		:= NIL
Static lF070MV1		:= NIL
Static lF70E5ADT	:= NIL
Static lSE5FI070	:= NIL
Static lF070VMOT	:= NIL
Static lFA070CMI	:= NIL
Static __lF191Alt   := NIL
Static __nTmFKOri 	:= TamSX3("FK1_ORIGEM")[1]
Static __lTemFK0
Static lPLSTITPF	:= findFunction("PLSTITPF")
Static __lPIXCanc 	:= FindFunction("PIXCancel")
Static __oMovPA 	:= NIL
Static __oExretR	:= NIL
Static __oExretP	:= NIL
Static __lFinm010	:= Nil 
Static __MV_IRF		:= Nil
Static __MV_PISNAT	:= Nil
Static __MV_COFINS	:= Nil
Static __MV_CSLL	:= Nil
Static __nTamHist 	:= Nil
Static __nTamCNAB   := Nil
Static __nToler	    := Nil
Static __cSldBxCr	:= Nil
Static oModelBxR	:= Nil
Static oModelBxRZ	:= Nil
Static __lF71IdBx	:= Nil

// Deixar sempre esta por ultimo
Static lF070IRAB	:= FxIniStat()

// Init Class Implementation -----------------------------------------------------------------------
Class BxImposto FROM LongNameClass
	DATA cChave
    DATA cCamposE5
    DATA nOper
    DATA lMovBco
    DATA oModelBx
    DATA cLog
    DATA cSequencia
    DATA nVlrBx
    DATA lGravaE5
    DATA cHistBx
    DATA cFilOrig
    DATA cMotBx
	DATA cDocumen

    METHOD New() CONSTRUCTOR
    METHOD Posiciona(cChave)
    METHOD SetHistorico(cHistBx)
    METHOD SetMotBx(cMotBx)
    METHOD SetFilorig(cFilOrig)
	METHOD SetSeqBx(cSequencia)
	METHOD SetDocumen(cDocumen)
	METHOD SetVlrBx(nVlrBx)
	METHOD SetCamposE5(cCamposE5)
    METHOD ModelOper(nOper)
    METHOD Activate()
    METHOD Grava()
    METHOD GetErrorGrava()
    METHOD Limpa()
    
ENDCLASS

METHOD New() CLASS BxImposto
    ::cChave        := ""
    ::cCamposE5     := ""
    ::nOper         := 0
    ::lMovBco       := .F.
    ::cLog          := ""
    ::cSequencia    := ""
    ::nVlrBx        := 0
    ::lGravaE5      := .F.
    ::cHistBx       := ""
    ::cFilOrig      := ""
    ::cMotBx        := "NOR"
	::cDocumen		:= ""

    If ::oModelBx <> NIL
        ::oModelBx:DeActivate()
        ::oModelBx:Destroy()
        ::oModelBx:= nil
    Endif    
RETURN NIL

METHOD Posiciona(cChave) CLASS BxImposto
    SE2->(DbsetOrder(1))
    SE2->(DbSeek(cChave))
RETURN NIL

METHOD SetHistorico(cHistBx) CLASS BxImposto
    ::cHistBx := cHistBx
RETURN NIL

METHOD SetMotBx(cMotBx) CLASS BxImposto
    ::cMotBx := cMotBx
RETURN NIL

METHOD SetFilorig(cFilOrig) CLASS BxImposto
    ::cFilOrig := cFilOrig
RETURN NIL 

METHOD SetSeqBx(cSequencia) CLASS BxImposto
    ::cSequencia := cSequencia
RETURN NIL

METHOD SetDocumen(cDocumen) CLASS BxImposto
    ::cDocumen := cDocumen
RETURN NIL

METHOD SetVlrBx(nVlrBx) CLASS BxImposto
    ::nVlrBx := nVlrBx
RETURN NIL

METHOD SetCamposE5(cCamposE5) CLASS BxImposto
    ::cCamposE5 := cCamposE5
RETURN NIL

METHOD ModelOper(nOper) CLASS BxImposto	
    ::nOper := nOper
RETURN

METHOD Activate() CLASS BxImposto
    Local oSubFKA   As Object
    Local oSubFK2   As Object
    Local oSubFK5   As Object
    Local cChaveTit As Character
    Local cChaveFK7 As Character
    Local cIdFK2    As Character

    oSubFKA   := NIL
    oSubFK2   := NIL
    oSubFK5   := NIL
    cChaveTit := xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
    cChaveFK7 := FINGRVFK7("SE2", cChaveTit)
    cIdFK2    := FWUUIDV4()

    If Empty(::cCamposE5)
		::cCamposE5 += "{"
		::cCamposE5 += "{'E5_DTDIGIT',  dDataBase}"
		::cCamposE5 += ",{'E5_PREFIXO', SE2->E2_PREFIXO}"
		::cCamposE5 += ",{'E5_NUMERO',  SE2->E2_NUM}"
		::cCamposE5 += ",{'E5_PARCELA', SE2->E2_PARCELA}"
		::cCamposE5 += ",{'E5_CLIFOR',  SE2->E2_FORNECE}"
		::cCamposE5 += ",{'E5_FORNECE', SE2->E2_FORNECE}"
		::cCamposE5 += ",{'E5_LOJA',    SE2->E2_LOJA}"
		::cCamposE5 += ",{'E5_BENEF',   SE2->E2_NOMFOR}"
		::cCamposE5 += ",{'E5_TIPO',    SE2->E2_TIPO}"
		::cCamposE5 += ",{'E5_DTDISPO', dDataBase}"
		::cCamposE5 += "}"
    Endif    

    ::oModelBx := FWLoadModel("FINM020")
    ::oModelBx:SetOperation( ::nOper )
    ::oModelBx:Activate()

    ::oModelBx:SetValue( "MASTER", "E5_GRV", .T. )
    ::oModelBx:SetValue( "MASTER", "NOVOPROC", .T. )
    ::oModelBx:SetValue( "MASTER", "E5_CAMPOS", ::cCamposE5 )
    oSubFKA := ::oModelBx:GetModel("FKADETAIL")
    oSubFK2 := ::oModelBx:GetModel("FK2DETAIL")
    oSubFK5 := ::oModelBx:GetModel("FK5DETAIL")
    
    If !oSubFKA:IsEmpty()
        oSubFKA:AddLine()
        oSubFKA:GoLine( oSubFKA:Length() )
    Endif
    
    oSubFKA:SetValue( 'FKA_IDORIG', cIdFK2 )
    oSubFKA:SetValue( 'FKA_TABORI', "FK2" )

    oSubFK2:SetValue( "FK2_IDFK2",  cIdFK2 )
    oSubFK2:SetValue( "FK2_DATA",   dDataBase )
    oSubFK2:SetValue( "FK2_VALOR",  ::nVlrBx )
    oSubFK2:SetValue( "FK2_VLMOE2", ::nVlrBx )
    oSubFK2:SetValue( "FK2_MOEDA",  StrZero(SE2->E2_MOEDA,2) )
    oSubFK2:SetValue( "FK2_NATURE", SE2->E2_NATUREZ )
    oSubFK2:SetValue( "FK2_RECPAG", "P" )
    oSubFK2:SetValue( "FK2_LOTE",	" ")
    
    If ::lMovBco
        oSubFK2:SetValue( "FK2_TPDOC",  "VL")
    Else
        oSubFK2:SetValue( "FK2_TPDOC",  "BA")
    EndIf

    oSubFK2:SetValue( "FK2_MOTBX",  ::cMotBx)
    oSubFK2:SetValue( "FK2_HISTOR", ::cHistBx)
    oSubFK2:SetValue( "FK2_ORIGEM", FunName())
    oSubFK2:SetValue( "FK2_SEQ",    ::cSequencia)
    oSubFK2:SetValue( "FK2_IDDOC",  cChaveFK7 )
    oSubFK2:SetValue( "FK2_DOC",    ::cDocumen)
    oSubFK2:SetValue( "FK2_CCUSTO", SE2->E2_CCUSTO)
    oSubFK2:SetValue( "FK2_FILORI",	SE2->E2_FILORIG)
    oSubFK2:SetValue( "FK2_LA", "N")

RETURN NIL
		
METHOD Grava() CLASS BxImposto
    Local lRet As Logical

    If ::oModelBx:VldData()
        ::oModelBx:CommitData()
        lRet := .T.
    Else
        lRet := .F.
        ::cLog := cValToChar(::oModelBx:GetErrorMessage()[4]) + ' - '
        ::cLog += cValToChar(::oModelBx:GetErrorMessage()[5]) + ' - '
        ::cLog += cValToChar(::oModelBx:GetErrorMessage()[6])
        Help( ,,"M340VALRE",,::cLog, 1, 0 )
    Endif

RETURN lRet

METHOD GetErrorGrava() CLASS BxImposto
RETURN ::cLog

METHOD Limpa() CLASS BxImposto
    ::oModelBx:DeActivate()
    ::oModelBx:Destroy()
    ::oModelBx:= nil
RETURN NIL
// End Class Implementation ------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINXBX

Funções  genéricas relacionadas as baixas CR e CP.

@Author Vários
@version 12
@since   08/12/2014

/*/
//-----------------------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------------------
// Funcoes retiradas do arquivo FINXATU.PRX
//-----------------------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FADIGICHQ

Funcao que abre ou não o get do número de cheque na baixa CP (FINA080).
Arquivo anterior: FINXATU.PRX

@Author	Mauricio Pequim Jr.
@since	15/10/1997
/*/
//-----------------------------------------------------------------------------------------------------
Function faDigiChq()
Local lRet := .T.

// Nao habilita o numero de cheque para :
// - Adiantamento, Banco Caixa, Carteira ou Motivo igual a D‚bito em C/C
If (SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG) .or. ;
	cBanco $ Left(SuperGetMv("MV_CXFIN",,""),TamSX3("A6_COD")[1])       .or. ;
	cBanco $ SuperGetMv("MV_CARTEIR",,"")     .or. ;
	TrazCodMot(cMotBx) $ "DEB/DAC"   .or. ;
	! ChqMotBx(cMotBx)				   .or. ;
	(SuperGetMv("MV_CHQBOR",,"") == "N" .and. !Empty(SE2->E2_NUMBOR))
	lRet := .F.
Endif
Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070CORR

Calculo de Correção monetária na baixa.
Arquivo anterior: FINXATU.PRX

@Author	Pilar S. Albaladejo
@since	30/01/1996
/*/
//-----------------------------------------------------------------------------------------------------
Function Fa070Corr(nEstOriginal As Numeric, nTxMoeda As Numeric) As Logical
	Local nValor1		As Numeric
	Local nBaseCorrecao As Numeric
	Local nTamVlCorre   As Numeric
	Local nTxTit		As Numeric
	Local nValorM		As Numeric
	
	nValor1			:= 0
	nBaseCorrecao 	:= 0
	nTamVlCorre     := TamSX3("FK6_VALMOV")[2]
	nTxTit			:= 0
	nValorM			:= 0

	Default cTipoCM	 := SuperGetMV("MV_TIPOCM",,"O")
	Default nTxMoeda := 0

	nEstOriginal := Iif(nEstOriginal==Nil,nValEstrang,nEstOriginal)

	If cTipoCM == "O"		// Pelo Original (O)
		nBaseCorrecao := nEstOriginal
	Else
		nBaseCorrecao := nValEstrang	// Pelo Total (T)
	EndIf

	If cPaisLoc <> "BRA"
		nCentMd1 := 4
		nTxMoeda := aTxMoedas[SE1->E1_MOEDA][2]
	EndIf

	// Taxa da inclusão do título
	If SE1->E1_TXMDCOR > 0
		nTxTit := SE1->E1_TXMDCOR
	ElseIf SE1->E1_TXMOEDA > 0
		nTxTit := SE1->E1_TXMOEDA
	Else
		nTxTit := RecMoeda(SE1->E1_EMISSAO,SE1->E1_MOEDA)
	EndIf

	// Só gera corração se a taxa da inclusão for diferente da baixa
	If nTxTit <> nTxMoeda

        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³ Calcula o valor na moeda escolhida na data da ultima variacao   ³
        //³ ou na data de emissao (caso nao tenha sofrido ainda nenhuma	    ³
        //³ variacao.														³
        //³ Calcula o valor na moeda escolhida para a database.				³
        //³ Subtrai um valor do outro para apurar a variacao. 				³
        //³ A Correcao pode ser parametrizada para ser calculada pelo Origi-³
        //³ nal ou pelo Total (Parametro MV_TIPOCM)           				³
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        If Str(nBaseCorrecao, 17, 2) == Str(SE1->E1_VALOR, 17, 2) .And. Empty(SE1->E1_DTVARIA)
            nValor1 := SE1->E1_VLCRUZ
        Else
            If !Empty(SE1->E1_TXMDCOR)
                nValor1 := xMoeda(nBaseCorrecao,SE1->E1_MOEDA,1,Iif(Empty(SE1->E1_DTVARIA),SE1->E1_EMISSAO,SE1->E1_DTVARIA),8,SE1->E1_TXMDCOR)
            Else
                nValor1 := xMoeda(nBaseCorrecao,SE1->E1_MOEDA,1,Iif(Empty(SE1->E1_DTVARIA),SE1->E1_EMISSAO,SE1->E1_DTVARIA),8,Iif(Empty(SE1->E1_DTVARIA),SE1->E1_TXMOEDA,0))
            EndIf
        EndIf

        If ( cPaisLoc<>"BRA" )
            nValor1 := xMoeda(nBaseCorrecao,SE1->E1_MOEDA,1,Iif(Empty(SE1->E1_DTVARIA),SE1->E1_EMISSAO,SE1->E1_DTVARIA),8,Iif(Empty(SE1->E1_DTVARIA),SE1->E1_TXMOEDA,0))
            If Type("aTxMoedas")#"U" .AND. !( aTxMoedas == Nil )
                nTxMoeda := aTxMoedas[SE1->E1_MOEDA][2]
            EndIf
        EndIf

        If TrazCodMot(cMotBx) == "DEV"
            nValorM := xMoeda(nBaseCorrecao,SE1->E1_MOEDA,1,SE1->E1_EMISSAO,8,If(SE1->E1_TXMOEDA > 0 .And. SE1->E1_TXMOEDA == nTxMoeda,SE1->E1_TXMOEDA,nTxMoeda))
        Else
            nValorM := xMoeda(nBaseCorrecao,SE1->E1_MOEDA,1,dBaixa,8,If(SE1->E1_TXMOEDA > 0 .And. SE1->E1_TXMOEDA == nTxMoeda,SE1->E1_TXMOEDA,nTxMoeda))
        EndIf

        nValor1 := Round(nValor1, nTamVlCorre)
        nValorM := Round(nValorM, nTamVlCorre)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica atraves do parametro MV_CALCCM se sera calculada a cor-³
	//³ recao monetaria.                                           	  ³
	//³ Caso o parametro nao exista, sera assumido "S"						  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	If ((Type("nMoedaBco") <> "U" .And. SE1->E1_MOEDA > 1 .And. SE1->E1_MOEDA <> nMoedaBco) .Or. ;
 		(Type("nMoedaBco") == "U" .And. SE1->E1_MOEDA > 1 .And. FUNNAME() $ "FINA330#FINA450#FINA740" )) .And. ;
		IIf(cPaisLoc == "BRA", SuperGetMv("MV_CALCCM",,"S") == "S" , .T.)

		If lF070CM
			nCm := ExecBlock("F070CM", .F., .F., {nTxMoeda})
		Else
            nCM := nValorM - nValor1
		EndIf
	Else
		nCM := 0
	EndIf
Return .T.

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SOMACHEQCR

Soma o valor dos cheques recebidos relacionados a um determinado titulo.
Arquivo anterior: FINXATU.PRX

@Author	Claudio D. de Souza
@since	06/11/2003
/*/
//-----------------------------------------------------------------------------------------------------
Function SomaCheqCr(lEstaNaBase,cPrefixo,cNum,cParcela,cTipo,cCliente,lConsUsBx,cSequencia)
Local aArea 	:= GetArea()
Local aAreaSEF	:= SEF->(GetArea())
Local nRet		:= 0
Local nX		:= 0

#IFDEF TOP
	Local cQuery
#ENDIF

Default lConsUsBx := .T.
Default cSequencia :=""

// Se nao estiver na base ainda, soma o aCols, onde estao os cheques que serao
// cadastrados
If !lEstaNaBase .And. (Type("aCols") == "A" .And. !Empty(aCols))
	For nX := 1 To Len(aCols)
		// Se o cheque nao estiver deletado, os dados forem validos
		If !aCols[nX][Len(aCols[1])]	.And.;
			!Empty(aCols[nX][1])		.And.;
			!Empty(aCols[nX][2])		.And.;
			!Empty(aCols[nX][3])		.And.;
			!Empty(aCols[nX][4])		.And.;
			!Empty(aCols[nX][5])		.And.;
			!Empty(aCols[nX][6])		.And.;
			!Empty(aCols[nX][7])		.And.;
			!Empty(aCols[nX][8])		.And.;
			!Empty(aCols[nX][9])

			// Se o identificador de que o cheque ja foi utilizado na baixa estiver como nao, devido as
			// baixas parciais, pois nas baixas futuras esses cheques nao podem mais serem utilizados
			// na geracao do movimento bancario, soma o valor do cheque
			If aCols[nX][15] != "Sim" .And. IIf(!Empty(cSequencia),cSequencia == aCols[nX][14],.T.)
		  		nRet += aCols[nX][6]
		  	Endif

		Endif
	Next
Else
	#IFDEF TOP
		cQuery := "SELECT Sum(EF_VALORBX) Soma FROM "+RetSqlName("SEF")+" WHERE "
		cQuery += "EF_FILIAL='"+xFilial("SEF")+"' AND "
		cQuery += "EF_PREFIXO='"+cPrefixo+"' AND "
		cQuery += "EF_TITULO='"+cNum+"' AND "
		cQuery += "EF_PARCELA='"+cParcela+"' AND "
		cQuery += "EF_TIPO='"+cTipo+"' AND "
		cQuery += "(EF_FORNECE='"+cCliente+"' OR "
		cQuery += " EF_CLIENTE='"+cCliente+"') AND "
		cQuery += "EF_NUM<>' ' AND "
		If lConsUsBx
			cQuery += "EF_USADOBX <>'S' AND "
		Endif
		If !Empty(cSequencia)
			cQuery += "EF_SEQUENC='"+cSequencia+"' AND "
		Endif
		cQuery += "D_E_L_E_T_ = ' '"
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"__SOMACHEQ",.T.,.T.)
		nRet := __SOMACHEQ->SOMA
		dbCloseArea()
	#ELSE
		dbSelectArea("SEF")
		SEF->(dbSetOrder(3))
		SEF->(MsSeek(xFilial("SEF")+cPrefixo+cNum+cParcela+cTipo))
		While SEF->(!Eof()) .And.;
				SEF->(EF_FILIAL+EF_PREFIXO+EF_TITULO+EF_PARCELA+EF_TIPO) ==;
				xFilial("SEF")+cPrefixo+cNum+cParcela+cTipo
			If (SEF->EF_FORNECE == cCliente .Or.;
				SEF->EF_CLIENTE == cCliente) .And. !Empty(SEF->EF_NUM)
				If lConsUsBx .Or. SEF->EF_USADOBX != "S"
					nRet += SEF->EF_VALORBX // Proporcionaliza o valor ref. a baixa, devido as baixas parciais
				EndIf
			Endif
			SEF->(dbSkip())
		EndDo
	#ENDIF
Endif
RestArea(aAreaSEF)
RestArea(aArea)
Return nRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070PAD

Verifica qual lançamento padrão será utilizado na Baixa CR dependendo da situação de cobrança do titulo.
Arquivo anterior: FINXATU.PRX

@Author	Wagner Xavier
@since	26/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function fA070Pad()
Local cPadrao:="520"

If AllTrim(SE1->E1_SITUACA) $ "0|F|G" .Or. Empty(SE1->E1_SITUACA)     //Carteira
	cPadrao := "520"
ElseIf AllTrim(SE1->E1_SITUACA) $ "1|H"     //Simples
	cPadrao := "521"
ElseIf AllTrim(SE1->E1_SITUACA) = "2"     //Descontada
	cPadrao := "522"
ElseIf AllTrim(SE1->E1_SITUACA) = "3"     //Caucionada
	cPadrao := "523"
ElseIf AllTrim(SE1->E1_SITUACA) = "4"     //Vinculada
	cPadrao := "524"
ElseIf AllTrim(SE1->E1_SITUACA) = "5"     //Advogado
	cPadrao := "525"
ElseIf AllTrim(SE1->E1_SITUACA) = "6"     //Judicial
	cPadrao := "526"
ElseIf AllTrim(SE1->E1_SITUACA) = "7"     //Caucao Descontada
	cPadrao := "528"
//Novas situacoes de cobranca do usuario
ElseIf FN022SITCB(SE1->E1_SITUACA)[1]		//Carteira cSituacao $ "0|F|G"
	cPadrao:="520"
ElseIf FN022SITCB(SE1->E1_SITUACA)[6]	//Simples e Cartorio   cSituacao $ "1|H"
	cPadrao:="521"
ElseIf FN022SITCB(SE1->E1_SITUACA)[3]	//Descontada 	cSituacao $ "2|7"
	cPadrao:="522"
ElseIf FN022SITCB(SE1->E1_SITUACA)[4]	//Cobranca em banco com protesto
	cPadrao:="526"
ElseIf FN022SITCB(SE1->E1_SITUACA)[2]	//Cobranca em banco sem protesto exceto Simples e Cartorio
	cPadrao:="524"
EndIf
Return cPadrao

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070GRV

Gravação da baixa de contas a receber.
Arquivo anterior: FINXATU.PRX

@Author	Wagner Xavier
@since	26/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function fA070Grv(lPadrao, lDesconto, lContabiliza, cNsNum, lExterno, dDtCredito, lJuros, cArqEnt, cOcorr,;
				  nTxMoeda, lGerChqAdt, aSeqSe5, aHdlPrv, lBloqSa1, lMultNat, oModelBxC, aMotRet, lPccMR,;
				  lIrfMR, lInsMR, lIssMR, lGlosaMr, lImpMR, aTitCalc, lPIX, cSituaCob, nBxaPrin,lIrPjBxCr,lPccBxCr)
Local nSalvRec		:= 0
Local cNum			:= ""
Local cPrefixo		:= ""
Local cParcela		:= ""
Local lAdiantamento	:= .f.
Local aBaixas		:= {}
Local nSE1Rec 		:= 0
Local nValClient  	:= 0
Local nAtraso		:= 0
Local nVlEstOri		:= 0
Local xF200GERA
Local aCamposSE1 	:= {}
Local nSomaCheq 	:= 0
Local nX 			:= 0
Local nSaldoAtu 	:= 0
Local lBxParc 		:= .F.
Local nValRa 		:= 0
Local lLj440Proc 	:= .F. // Se processa rotina do SIGALOJA
Local nTamSeq		:= TamSX3("FK1_SEQ")[1] 
Local cSequencia 	:= Replicate("0",nTamSeq)
Local lVendedor		:= .F.

Local nPisBaseA		:= 0
Local nCofBaseA		:= 0
Local nCslBaseA		:= 0
Local nIrfBaseA		:= 0
Local nTamHist 		:= TamSX3("E1_HIST")[1] // Tamanho do campo HISTORICO

//Controla o tipo original do titulo originador
Local cTipoOr		:= ""
Local lAtuSldNat	:= .T.
Local nOpcx 		:= 0
Local nValRealiz 	:= 0

//Controle de abatimento
Local lTitpaiSE1 	:= .T.
Local bWhile 		:= {|| !EOF() .And. E1_FILIAL==xFilial("SE1") .And. E1_CLIENTE = cCliente	.And. E1_LOJA = cLoja .And. E1_PREFIXO=cPrefixo .And. E1_NUM == cNum .And. E1_PARCELA==cParcela }
Local nOrdTitPai	:= 0
Local lRaRtImp  	:= FRaRtImp()
Local c070Hist		:= ""
Local aTitulos		:= {}

//.T. - Gera o titulo de ISS (se houver) na filial de destino juntamente com o titulo NF, baixando o titulo ISS na origem
//.F. - Nã gera o titulo de ISS na filial de destino, permanecendo o titulo ISS na origem em aberto.
Local lTrfISSf		:= GetNewPar("MV_TRFISSF",.T.)
Local cFilOrgTr 	:= ""//Filial de origem do documento de ISS, processo de transferência
Local nForIss   	:= 1//Auxiliar para o For de busca do ISS, processo de transferência
Local nValImp 		:= 0
Local nPosBx		:= 0
Local aMotBx		:= ReadMotBx()
Local lImpBxCr		:= GetNewPar( "MV_IMPBXCR", "1" ) == "2"
Local lJurMulDes	:= (SuperGetMv("MV_IMPBAIX",.t.,"2") == "1")
Local nTotJur		:= 0
Local nValForeing	:= 0
Local lFini055		:= IsInCallStack("FINI055")
Local lRet			:= .T.
Local cParcRA		:= SuperGetMv("MV_1DUP",,"")
Local lIntRm    	:= .F.
Local cPrefRM 		:= SuperGetMv("MV_PREFRM",,"TIN")
Local lIntegTIN		:= FindFunction( "GETROTINTEG" ) .and. FindFunction("FwHasEAI")
Local lFINA415		:= .F.
Local lCNABPix		:= .F.
Local cChaveTit		:= ""
Local cChaveFK7		:= ""

Local lGestao   	:= FWSizeFilial() > 2	// Indica se usa Gestao Corporativa
Local lSE1Comp  	:= FWModeAccess("SE1",3)== "C" // Verifica se SE1 é compartilhada
Local cTpComLj		:= SuperGetMV("MV_TPCOMLJ",,"B")

Local lIntPFS   	:= SuperGetMV("MV_JURXFIN",,.F.) // Integração SIGAPFS x SIGAFIN

// Motor de retenção de impostos
Local lMotorRet		:= .F.
Local aAreaF200		:= {}
Local nRecnoPai		:= 0
Local lUsaFlag 		:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
Local cFunName      := FunName()
Local lRetornAPI    := FwIsInCallStack("FIN892Proc")
Local lCallStack    := (lRetornAPI .Or. (cFunName == "FINA200") .Or.(cFunName == "FINA740" .And. FwIsInCallStack("FINA200")))

Private lRetParc	:= .T.
Private nValToler	:= 0

Default oModelBxC	:= NIL
Default lMultNat 	:= .F.
Default aMotRet		:= {}
Default lGlosaMr 	:= .F.
Default aTitCalc	:= {}
Default lPIX		:= .F.
Default cSituaCob   := "0"
Default nBxaPrin    := 0
//Controla o Pis Cofins e Csll na baixa (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default))
Default lPccBxCr		:= FPccBxCr(.T.)
//Controla IRPJ na baixa
Default lIrPjBxCr		:= FIrPjBxCr(.T.)

lMotorRet	:= Len(aMotRet) > 0

if findFunction("fa440temVe")
	lVendedor := fa440temVe("SE1") .Or. AllTrim(SE1->E1_ORIGEM) $ "FINA280|FINA460"
else
	lVendedor := !Empty(SE1->E1_VEND1) .Or. ;
					!Empty(SE1->E1_VEND2) .Or. ;
					!Empty(SE1->E1_VEND3) .Or. ;
					!Empty(SE1->E1_VEND4) .Or. ;
					!Empty(SE1->E1_VEND5) .Or. ;
					AllTrim(SE1->E1_ORIGEM) $ "FINA280|FINA460"
endIf

If Type("cFilAbat") == "U"
	Private cFilAbat := cFilAnt
EndIf
If Type("nTotAbImp") == "U"
	Private nTotAbImp := 0
EndIf

If Type("lVlrMaior") == "U"
	Private lVlrMaior := .F.
EndIf

If Type("nVlrMaior") == "U"
	Private nVlrMaior := 0
EndIf
If Type("lMonedaC") == "U"
	Private lMonedaC := .F.
EndIf

//Controle Numero Borderô - FINA200
If lCallStack
	Private cNumBor 	:= SE1->E1_NUMBOR
	If ! (lFini055 .or. AllTrim(SE1->E1_ORIGEM)=="FINI055") // Nao atualiza se for do TIN
		If !(FA070Integ(.F.))
			Return .F.
		EndIf
	EndIf
EndIf

//Integração baixa via cnab
If ( FWHasEAI("FINA070",.T.,,.T.) ) .And. ( lIntegTIN .and. AllTrim(SE1->E1_ORIGEM)=="FINI055" ) .Or.;
	( FWHasEAI("FINI070A",.T.,,.T.) .And. ( AllTrim(SE1->E1_ORIGEM) $ 'L|S|T' .Or. SE1->E1_IDLAN > 0 ) )
	lIntRm := .T.
Endif

// Zerar variaveis para contabilizar os impostos da lei 10925.
VALOR5 := 0
VALOR6 := 0
VALOR7 := 0

Default nTxMoeda 	:= 0
Default lGerChqAdt 	:= .F. // Gera cheque para Adiant ? Pergunta na baixa manual.
Default lBloqSa1 	:= .T.

If Funname() == "FINA070"
	Default nMoedaBco := 1
Else
	If cPaisLoc == "ARG"
		nMoedaBco := 1
    ElseIf Type("nMoedaBco") == "U" .or. nMoedaBco == 0 
        dbSelectArea("SA6")
        dbSetorder(1)
        If dbSeek(xFilial("SA6")+cBanco+cAgencia+cConta)
            nMoedaBco	:= SA6->A6_MOEDA
        ElseIf cPaisLoc $ "PER" .And. FunName() $ "FINA415"
			nMoedaBco := SE1->E1_MOEDA
		Else
            nMoedaBco	:= 1
        EndIf
	EndIf
EndIf
If cPaisLoc == "MEX" .AND. lMonedaC .AND.  FindFunction("fn450AsgMn") 
	fn450AsgMn(@nMoedaBco,@nTxMoeda )
EndIf

lDesconto	:= Iif(lDesconto=Nil,Iif(mv_par03==1,.T.,.F.),lDesconto)
lContabiliza:= Iif(lContabiliza=Nil,Iif(mv_par04==1,.T.,.F.),lContabiliza)
lJuros		:= Iif(lJuros == NIL, .F., lJuros )
cNsNum		:= Iif(cNsNum==NIL," ",cNsNum)
cArqEnt     := Iif(cArqEnt==Nil," ",cArqEnt)		// Oriundo do Fina200 (Arquivo Cnab)
nOtrGa      := If(Type("nOtrGa") != "N",0,nOtrGa)
nDifCambio  := IF (Type("nDifCambio") != "N",0,nDifCambio)
nAcresc     := If(Type("nAcresc") != "N",0,nAcresc)
nAcrescf    := If(Type("nAcrescf") != "N",nAcresc,nAcrescf)
nDecresc    := If(Type("nDecresc") != "N",0,nDecresc)
nPis		:= If(Type("nPis") != "N",0,nPis)
nCofins	    := If(Type("nCofins") != "N",0,nCofins)
nCsll	   	:= If(Type("nCsll") != "N",0,nCsll)
nIrrf	   	:= If(Type("nIrrf") != "N",0,nIrrf)
cOcorr      := Iif(cOcorr==Nil,"  ",cOcorr)
cModSpb		:= If (Type("cModSpb") != "C","1",cModSpb)
nOldIrrf 	:= If(Type("nOldIrrf") != "N",0,nOldIrrf)
nPisBaseR	:= Iif(Type("nPisBaseR") != "N",0,nPisBaseR)
nCofBaseR	:= Iif(Type("nCofBaseR") != "N",0,nCofBaseR)
nCslBaseR	:= Iif(Type("nCslBaseR") != "N",0,nCslBaseR)
nIrfBaseR	:= Iif(Type("nIrfBaseR") != "N",0,nIrfBaseR)
nVA			:= If(Type("nVA") != "N", 0, nVA)

__nValRA := 0

// Atualiza variáveis de retenção
lPccBaixa  := IiF( lPccMR, .T., Iif(Type("lPccBaixa")  == "U", .F., lPccBaixa) )
lIRPFBaixa := IiF( lIrfMR, .T., Iif(Type("lIRPFBaixa") == "U", .F., lIRPFBaixa) )
lCalcIssBx := IiF( lIssMR, .T., Iif(Type("lCalcIssBx") == "U", .F., lCalcIssBx) )

If FwIsInCallStack("FINA070")
    If mv_par04==1 .and. !lUsaFlag
        lContabiliza    := .T.
    Else
        lContabiliza    := .F.
    EndIf
EndIf

If Funname() == "FINA630" .and. SE1->E1_TIPO $ MVRECANT
	cPortado    := SE1->E1_PORTADO
	cBanco      := SE1->E1_PORTADO
	cAgencia    := SE1->E1_AGEDEP
	cConta      := SE1->E1_CONTA
	lGerChqAdt	:= .F.
EndIf

If __nToler==Nil
	__nToler := SuperGetMv("MV_TOLERPG",,0)
EndIF
If __cSldBxCr==Nil
	__cSldBxCr := SuperGetMv("MV_SLDBXCR",,"B")
EndIF

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Este parƒmetro informa se a fun‡„o foi chamada pelo pr¢prio Fina070	³
//³ou por outro programa externo, tal como o Fina200							³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ValType( lExterno ) # "L"
	lExterno := .F.
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza a baixa do titulo											  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lExterno
	If nTotAbat = SE1->E1_SALDO
		nValPadrao := nValRec + (nJuros + nVA +Iif(SE1->E1_MOEDA<=1,nCm,0)+nMulta-nDescont-nTotAbat+nAcresc-nDecresc-If(lPccBxCr,nPis+nCofins+nCsll,0)-Iif(lIrPjBxCr,nIrrf,0)-Iif(lImpMR,nlImpMR,0))
	Else
		nValPadrao := nValRec - (nJuros + nVA +Iif(SE1->E1_MOEDA<=1,nCm,0)+nMulta-nDescont-nTotAbat+nAcresc-nDecresc-If(lPccBxCr,nPis+nCofins+nCsll,0)-Iif(lIrPjBxCr,nIrrf,0)-Iif(lImpMR,nlImpMR,0))
	Endif

	nValPadrao := Round(NoRound(xMoeda(nValPadrao,1,SE1->E1_MOEDA,dBaixa,3,,SE1->E1_TXMOEDA),3),2)
	If nValPadrao < SE1->E1_SALDO
		nValpadrao -= nTotAbat
	Endif
Else
	If lRaRtImp
		If lJurMulDes .and. nValRec < nAcresc
			nValPadrao := nValRec
		Else
			nValPadrao := nValRec-(nJuros + nVA +Iif(SE1->E1_MOEDA<=1,nCm,0)+nMulta-nDescont-nOtrga-nTotAbat+nAcresc-nDecresc-If(lPccBxCr,nPis+nCofins+nCsll,0)-Iif(lIrPjBxCr,nIrrf,0)-Iif(lCalcIssBx,nIss,0)-Iif(lImpMR,nlImpMR,0))
		EndIf
		If nValPadrao < SE1->E1_SALDO
			nValpadrao -= nTotAbat
		Endif
	Else 
		If SE1->E1_MOEDA == 1 .And. nMoedaBco > 1 
			nValPadrao := nValEstrang-(nJuros + nVA +Iif(SE1->E1_MOEDA<=1,nCm,0)+nMulta-nDescont-nOtrga+nAcresc-nDecresc-If(lPccBxCr,nPis+nCofins+nCsll,0)-Iif(lIrPjBxCr,nIrrf,0)-Iif(lCalcIssBx,nIss,0)-Iif(lImpMR,nlImpMR,0))
		Else
			nValPadrao := nValRec-(nJuros + nVA +Iif(SE1->E1_MOEDA<=1,nCm,0)+nMulta-nDescont-nOtrga+nAcresc-nDecresc-If(lPccBxCr,nPis+nCofins+nCsll,0)-Iif(lIrPjBxCr,nIrrf,0)-Iif(lCalcIssBx,nIss,0)-Iif(lImpMR,nlImpMR,0))
		EndIf
	EndIf
Endif

If !lIrPjBxCr .and. lImpBxCr .and. lF070Imp2 .and. lFa070Imp .and. nOldIrrf == 0 .and. nIrrf > 0
	nValPadrao	:= nValPadrao + nIrrf
EndIf

If lFinSalTit
	nValPadrao += ExecBlock("FinSalTit")
Endif

If SE1->E1_MOEDA > 1
    nSalTit := Round(NoRound(xMoeda(SE1->E1_SALDO,SE1->E1_MOEDA,nMoedaBco,dBaixa,3,nTxMoeda),3),2) //Converte o saldo do titulo a moeda 1.
Else
    nSalTit := SE1->E1_SALDO
EndIf

If !lIntRm .and. SE1->E1_PREFIXO <> cPrefRM
	If nSalTit == 0 .or. (lExterno .and. nSalTit > 0 .and. ( nSalTit < nValPadrao .Or. lVlrMaior) )
		//Caso o Cliente pague o titulo mais de uma vez e o titulo ja se encontrava
		//baixado, gero um RA para informar o credito a maior em minha conta bancaria
		//e ao mesmo tempo disponibilizo o credito ao clientepara posterior devolucao ou
		//compensacao. Este processo somente sera "startado" se for num retorno
		//CNAB (lExterno = .T.) e se for parametrizado para tal (MV_REC2TIT = "1")
		If SuperGetMv("MV_REC2TIT",,"2") == "1" .And. lExterno
			//Gero RA no SE1 e seu movimento no SE5
			nSaldoAtu := nSalTit
			nValRa	 := IIF(lVlrMaior, nVlrMaior, nValRec)
			lBxParc	 := lVlrMaior
			//Verifico se o titulo sofreu apenas uma baixa parcial antes da recepcao do CNAB
			//Neste caso o valor da devolucao sera o valor do principal pago a maior
	        If nSalTit > 0 .and. nSalTit < nValPadrao
				nValRec		:= nSaldoAtu+(nJuros + nVA +Iif(SE1->E1_MOEDA<=1,nCm,0)+nMulta-nDescont-nTotAbat+nAcresc-nDecresc)
				nValRa		:= nValPadrao - nSalTit
				nValPadrao	:= nValRec-(nJuros + nVA +Iif(SE1->E1_MOEDA<=1,nCm,0)+nMulta-nDescont-nTotAbat+nAcresc-nDecresc)
				lBxParc		:= .T.
			Endif
			DbSelectArea("SE1")
			If lPccBxCr
				nPisBaseA := nPisBaseR
				nCofBaseA := nCofBaseR
				nCslBaseA := nCslBaseR
			EndIf

			If lIrPjBxCr
				nIrfBaseA := nIrfBaseR
			EndIf
			For nX := 1 To fCount()
				IF Alltrim(FieldName(nX)) $ "E1_PREFIXO#E1_NUM#E1_NATUREZ#E1_CLIENTE#E1_LOJA#E1_NOMCLI#E1_FILORIG#E1_NUMRA"
					Aadd(aCamposSE1, {FieldName(nX), FieldGet(nX)})
				Endif
			Next nX
		    nRecNow := SE1->(RECNO())
			nOrdNow := SE1->(IndexOrd())

			//Verifico se a parcela já existe na tabela SE1
			SE1->(dbSetOrder(1))
			While SE1->(dbSeek(xFilial("SE1")+SE1->(E1_PREFIXO+E1_NUM)+cParcRA+Substr(MVRECANT,1,3)))
				cParcRA := Soma1(cParcRA)
			Enddo

			// Descarrega aCamposSE1 no SE1 para que todos os campos preenchidos no titulo principal
			// sejam replicados para o RA
			For nX := 1 To Len(aCamposSE1)
				If !Empty(aCamposSE1[nX][2])
					aAdd(aTitulos,{aCamposSE1[nX,01], aCamposSE1[nX,02], Nil})
				Endif
			Next

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Ponto de Entrada para tratamento de Historico no titulo de RA³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lF070HIST
				c070Hist := PadR(ExecBlock("F070HIST",.F.,.F.,{SE1->(E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO),nRecNow}),nTamHist)
			Else
				c070Hist := STR0001 //"Adiant.Bx.Duplicada-CNAB"
			Endif

			If lIntPfs .And. FindFunction("JIncAdiant") .And. FindFunction("JurIsJuTit") .And. JurIsJuTit(nRecNow) // Integração SIGAPFS x SIGAFIN
				// Ocorrerá a criação de adiantamento do módulo SIGAPFS
				// somente se a integração estiver ativa e o título atual estiver vinculado ao uma fatura
				JIncAdiant(nRecNow, cBanco, cAgencia, cConta, c070Hist, nValRa, dDataBase)
			Else
				//Montagem do Array para ExecAuto
				aAdd(aTitulos,{"E1_PARCELA"	, cParcRA				, Nil })
				aAdd(aTitulos,{"E1_TIPO"	, Substr(MVRECANT,1,3)	, Nil })
				aAdd(aTitulos,{"E1_PORTADO"	, cBanco				, Nil })
				aAdd(aTitulos,{"E1_AGEDEP"	, cAgencia				, Nil })
				aAdd(aTitulos,{"E1_CONTA"	, cConta				, Nil })
				aAdd(aTitulos,{"E1_EMISSAO"	, dDataBase				, Nil })
				aAdd(aTitulos,{"E1_EMIS1"	, dDataBase				, Nil })
				aAdd(aTitulos,{"E1_VENCTO"	, dDataBase				, Nil })
				aAdd(aTitulos,{"E1_VENCREA"	, dDataBase				, Nil })
				aAdd(aTitulos,{"E1_VALOR"	, nValRa				, Nil })
				aAdd(aTitulos,{"E1_VLCRUZ"	, nValRa				, Nil })
				aAdd(aTitulos,{"E1_SALDO"	, nValRa				, Nil })
				aAdd(aTitulos,{"E1_MOEDA"	, 1						, Nil })
				aAdd(aTitulos,{"E1_SITUACA" , "0"					, Nil })
				aAdd(aTitulos,{"E1_STATUS"	, "A"					, Nil })
				aAdd(aTitulos,{"E1_ORIGEM"	, "FINA040"				, Nil })
				aAdd(aTitulos,{"E1_FLUXO"	, "S"					, Nil })
				aAdd(aTitulos,{"E1_MULTNAT" , "2"					, Nil })
				aAdd(aTitulos,{"E1_PROJPMS" , "2"					, Nil })
				aAdd(aTitulos,{"E1_HIST"	, c070Hist				, Nil })
				If SpbInUse()
					aAdd(aTitulos,{"E1_MODSPB"	, "1"				, Nil })
				Endif

				If lF200GERA
					xF200GERA := ExecBlock("F200GERA",.F.,.F.,{nRecNow,aTitulos})
					If ValType(xF200GERA) == "A"
						aTitulos := aClone(xF200GERA)
					EndIf
				EndIf

				lMsErroAuto := .F.
				MSExecAuto({|X,Y| FINA040(X,Y)},aTitulos,3)

				If lMsErroAuto
					MostraErro()
				EndIf
			EndIf

			If lPccBxCr
				nPisBaseR := nPisBaseA
				nCofBaseR := nCofBaseA
				nCslBaseR := nCslBaseA
			EndIf

			If lIrPjBxCr
				nIrfBaseR := nIrfBaseA
			EndIf

			If ExistTemplate("GEMSE1Grv")
				ExecTemplate("GEMSE1Grv",.F.,.F.)
			EndIf

			dbCommit()

			If ExistTemplate("GEMSE5Grv")
				ExecTemplate("GEMSE5Grv",.F.,.F.)
			EndIf

			//Atualiza Saldo do Titulo.
			If SE1->E1_TIPO $ MVRECANT+"/"+MVABATIM+"/"+MV_CRNEG
				AtuSalDup("-",SE1->E1_SALDO,SE1->E1_MOEDA,SE1->E1_TIPO,,SE1->E1_EMISSAO)
			Endif
			dbSelectArea("SE1")
			SE1->(dbSetOrder(nOrdNow))
			SE1->(dbGoto(nRecNow))
			If !lBxParc
				Return .f.
			EndIf
		Else
			Return .f.
		EndIf
	EndIf

Elseif lIntRm .and. lExterno

 	If nSalTit > 0 .And. ( nSalTit < nValPadrao .Or. lVlrMaior )
 		If SuperGetMv("MV_REC2TIT",,"2") == "1"
			nValRec := nSalTit + ( nJuros + Iif( SE1->E1_MOEDA <= 1, nCm, 0 ) + nMulta - nDescont - nTotAbat + nAcresc - nDecresc )
			__nValRA := nValPadrao - nSalTit //Guarda o valor de crédito (recebido a mais), para enviar no desconto no XML de baixa para a integração com RM Educacional
			nValPadrao := nValRec - ( nJuros + Iif( SE1->E1_MOEDA <= 1, nCm, 0 ) + nMulta - nDescont - nTotAbat + nAcresc - nDecresc )
		Else
			Return .F.
		EndIf
 	Endif
Endif

If lFINAJURO
	Execblock("FINAJURO",.F.,.F.)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se saldo estava em outra moeda, caso estiver, converte valor ³
//³recebido pela taxa diaria da moeda												 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SE1->E1_MOEDA > 1 .Or. (cPaisLoc<>"BRA" .And. nMoedaBco > 1)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se Taxa Moeda ‚ contratada                             ³
	//³Permite diferenca menor que 0.01 na compara‡„o...               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPaisLoc <> "BRA"
		nCalc := nValEstrang+(nDescont-nMulta-nJuros - nVA -nAcresc+nDecresc+nOtrga)
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Nao converte os valores no caso de compensacao entre carteiras ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !Empty(SE1->E1_IDENTEE)
			nCalc := nValEstrang+xMoeda(nDescont-nMulta-nJuros - nVA -nAcresc+nDecresc,1,SE1->E1_MOEDA,dBaixa,4,,nTxMoeda)
		Else
			// Retirado Round() para evitar diferenca de 0.01 em baixa total no caso de correcao monetaria negativa.
			nCalc := nValestrang+xMoeda(nDescont-nMulta-nJuros - nVA -nAcresc+nDecresc+If(lPccBxCr,nPis+nCofins+nCsll,0)+Iif(lIrPjBxCr,nIrrf,0),nMoedaBco,SE1->E1_MOEDA,dBaixa,4,,nTxMoeda)
		EndIf
	Endif
	If cPaisLoc == "MEX" .AND. lMonedaC .AND. FindFunction("fn450nSal") 
		nSaldo:= 0
		fn450nSal('SE1',nValRec,SE1->E1_MOEDA,nMoedaBco,nTxMoeda,nCalc,@nSaldo)
	Else
	    If SE1->E1_MOEDA > 1
	        If (SE1->E1_SALDO+SE1->E1_ACRESC-SE1->E1_DECRESC) - nCalc >= 0.01
	            nSaldo := SE1->E1_SALDO-nCalc
	        Else
	            nSaldo := 0
	        Endif
	    Else
	    	nSaldo := SE1->E1_SALDO - xMoeda(nValRec,nMoedaBco,SE1->E1_MOEDA,dBaixa,4,,nTxMoeda)
	    EndIf
	EndIf
Else
	// lExterno == .T. ==> CNAB
	If nValPadrao < 0
		nSaldo := SE1->E1_SALDO
	Else
		nSaldo := SE1->E1_SALDO - nValPadrao
	EndIf
	If Round(NoRound(nSaldo,3),2) <= 0.00999 .and. ;
		IIf (lExterno, ( IIf(SuperGetMv("MV_ZERASE1",,"S") == "S",.T.,.F.) ),.T.)
		nSaldo := 0
	Endif
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso o saldo restante  seja igual ao valor dos abatimentos,  ³
//³ considerar a baixa total do titulo.                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Str(nSaldo,16,2)=Str(nTotAbat,16,2)
	nSaldo := 0
Endif

//--------------------------------------------------------------------------------------
//Tolerância de Recebimento
nDescont := nDescont + nDecresc
nTotJur  := nJuros
nJuros 	 := nJuros + nAcresc
nJuros   := If(nValRec < nJuros-nDescont, nValrec, nJuros)

If nSaldo > 0

	//Valor recebido a menor
	If __nToler > 0 .And. nSaldo > 0
		If nSaldo <= __nToler
			nDescont := nDescont + (nSaldo - nTotAbat)
			nSaldo	 := 0
		EndIf
	EndIf

	//Valor recebido a maior
	If __nToler > 0 .and. nSaldo < 0
		nJuros 		:= nJuros + Abs(nSaldo)
		nValToler	:= Abs(nSaldo)
		nSaldo		:= nSaldo + Abs(nSaldo)
	Endif
Endif


//****Tratamento para integração do RM Classis x Protheus****
//caso a baixa seja do tipo "BOL" (bolsa de estudos) e o valor recebido seja 0
//gravo o saldo do título zerado para efetivar a baixa integral do mesmo
If FwHasEai("FINA070") .And. (AllTrim(SE1->E1_ORIGEM) $ "L|S|T" .Or. SE1->E1_IDLAN > 0)
	nPosBx := Ascan(aMotBx, {|x| AllTrim(SubStr(x,7,10)) == AllTrim(Upper(cMotBx))})
	If nPosBx > 0
		If SubStr(aMotBx[nPosBx],1,3) == "BOL" //Baixa do tipo BOL - Bolsa de estudos
			//Zero o saldo caso a baixa seja do tipo BOL
			nSaldo := 0
		EndIf
	EndIf
EndIf

Begin Transaction
	RecLock("SE1")
	nSE1Rec := Recno()
	Replace E1_BAIXA	  With If(E1_BAIXA <= dBaixa, dBaixa, E1_BAIXA)
	Replace E1_LOTE	  With cLoteFin
	Replace E1_MOVIMEN  With dBaixa
	If cPaisLoc == "MEX" .and. lMonedaC .and. FindFunction("fn450AgnBc")
	 	fn450AgnBc('1',nMoedaBco,SE1->E1_MOEDA, nTxMoeda )
	Else
		Replace E1_DESCONT  With nDescont
		Replace E1_MULTA	  With nMulta
		Replace E1_JUROS	  With nJuros
	EndIf

	If cPaisLoc == "BRA"
		If lPccBxCr .And. !FwIsInCallStack("FA450CMP")
			nValrec += nPis + nCofins + nCsll
		EndIf
		PIS	   := nPis
		COFINS := nCofins
		CSLL   := nCsll

		If (lIrPjBxCr .or. (lImpBxCr .and. lF070Imp2 .and. lFa070Imp .and. nOldIrrf == 0))
			nValrec += nIrrf
			nValImp += nIrrf
		Endif
		If lCalcIssBx
			nValrec += nIss
		Endif
		If lImpMR //Outros tipos de retenções pelo Motor
			nValrec += nlImpMR
		Endif
	EndIf

	If lFinSalTit .AND. FwIsInCallStack("FINA080")
		Replace E1_VALLIQ With nValRec + ExecBlock("FinSalTit", .F.,.F., 2)
	Else
		If cPaisLoc == "MEX"
			If FunName() == "FINA415" //Eliminación de residuos
				Replace E1_VALLIQ With E1_VALLIQ + xMoeda(nValRec,1,SE1->E1_MOEDA,dDatabase,MsDecimais(SE1->E1_MOEDA),,SE1->E1_TXMOEDA)
				lFINA415 := .T.
			EndIf
		EndIf

		If !lFINA415 .and. !(cPaisLoc $ "BRA|PER")
			If cPaisLoc == "MEX" .and. lMonedaC .and. FindFunction("fn450AgnBc")
				 fn450AgnBc('2',nMoedaBco,SE1->E1_MOEDA, nTxMoeda )
			Else
				Replace E1_VALLIQ With xMoeda(nValRec,1,SE1->E1_MOEDA,dDatabase,MsDecimais(SE1->E1_MOEDA),,SE1->E1_TXMOEDA)
			EndIF
        Else
			Replace E1_VALLIQ With nValrec
        EndIf
	Endif

	Replace E1_OK		With Iif(E1_OK == cMarca,"xx",cMarca)
	Replace E1_STATUS   With IIF(E1_STATUS != "R",Iif(nSaldo >= 0.01,"A","B"),"R")
	If cPaisLoc == "CHI"
		SE1->E1_OTRGA  := nOtrga
		SE1->E1_CAMBIO := SE1->E1_CAMBIO + nDifCambio
	ElseIf cPaisLoc == "MEX" .and. lMonedaC .and. FindFunction("fn450AgnBc")
		fn450AgnBc('3',nMoedaBco,SE1->E1_MOEDA, nTxMoeda )
	Else
		Replace E1_CORREC   With nCm
	EndIf

	If ExistTemplate("GEMSE1Grv")
		ExecTemplate("GEMSE1Grv",.F.,.F.)
	EndIf

	SE1->(MsUnlock())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava um registro para cada Movimenta‡„o Banc ria 			  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG
		lAdiantamento := .t.
	EndIf
	
	If nSaldo > 0
		If nValRec < ((nTotJur+nAcresc+nMulta)-nDescont) 
			If nAcresc > 0
				nAcresc =  nValRec - ((nTotJur+nMulta)-nDescont) 
			Else
				nAcresc = ((nTotJur+nMulta)-nDescont) - nValRec
			EndIf
		EndIF	
	EndIf

	// Controla saldo na compensacao do cheque
	If __cSldBxCr == "C"
		// Soma o total recebido em cheque
		nSomaCheq := SomaCheqCr(.F.,SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE)
	Endif

	//Movimento Bancário		
	If !(lRet := FA070Mov(lPadrao, lContabiliza, lAdiantamento, dDtCredito, @aBaixas, cArqEnt, cOcorr, nTxMoeda, nSomaCheq,;
						  aSeqSe5, @cSequencia, aHdlPrv, Nil, oModelBxC, lMultNat, aMotRet, lPccMR, lIrfMR, lInsMR, lIssMR,;
						  lImpMR, aTitCalc, cSituaCob, @nBxaPrin, lPIX))		
		DisarmTransaction()
	Else
		// Verifica se titulo esta no PIX e retira
		If cPaisLoc == "BRA"
			cChaveTit := SE1->E1_FILIAL + "|" +;
						SE1->E1_PREFIXO + "|" +;
						SE1->E1_NUM		+ "|" +;
						SE1->E1_PARCELA + "|" +;
						SE1->E1_TIPO	+ "|" +;
						SE1->E1_CLIENTE + "|" +;
						SE1->E1_LOJA
			cChaveFK7 := FINGRVFK7("SE1",cChaveTit)
			If lExterno
				lCNABPix  := lPIX
			EndIf
			If !lCNABPix  // Se eh Retorno CNAB do PIX, nao faz nada
				If __lPIXCanc
					If !PIXCancel(SE1->E1_FILIAL, cChaveFK7)
						DisarmTransaction()
						lRet := .F.
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	If (lRetornAPI .Or. IsInCallStack('FINA200'))
		If ValType(nAbatim) == "N" .And. nAbatim > 0
			aAreaF200 := SE1->(GetArea())
			nRecnoPai := SE1->(Recno())
			SE1->(DbSetOrder(1))
			If DbSeek(xFilial("SE1") + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + "AB-" )
				If SE1->E1_SALDO = nAbatim
					SE1->(RecLock("SE1", .F.))
					SE1->E1_BAIXA	:= dBaixa
					SE1->E1_SALDO	:= 0
					SE1->E1_MOVIMEN	:= dBaixa
					SE1->E1_VALLIQ	:= 0
					SE1->E1_STATUS	:= "B"
					SE1->(MsUnLock())

					SE1->(DbGoTo(nRecnoPai))
					SE1->(RecLock("SE1", .F.))
					SE1->E1_VALLIQ := SE1->E1_VALLIQ - nAbatim
					SE1->(MsUnLock())
				Endif
			Endif
			RestArea(aAreaF200)
		Endif
	Endif
End Transaction

If lRet
	If cSituaCob == "0" .And. lAtuSldNat .and. !lMultNat .AND. !IsInCallStack('Fa040Subst') .AND. FK1->FK1_MOTBX != 'TIN'
		// Nao precisa atualizar a baixa dos abatimentos, pois o valor recebido jah eh liquido dos abatimentos
		If nSaldo = 0
			nValpadrao += nTotAbat
		Endif

		nValRealiz := nValRec - If(lPccBxCr,nPis+nCofins+nCsll,0) - Iif(lIrPjBxCr,nIrrf,0)

		If (SE1->E1_MOEDA <> 1) .and. (nMoedaBco <> 1)
			nValForeing := Round(NoRound(xMoeda(nValEstrang,nMoedaBco,1,dBaixa,3,nTxMoeda),3),2)
		ElseIf (SE1->E1_MOEDA <> 1) .and. (nMoedaBco == 1)
			nValForeing := nValRealiz
			nValRealiz  := nValEstrang
		Else
			nValForeing := nValEstrang
		EndIf

		If lGestao
			If cFilAnt == SE1->E1_FILORIG
				If lSE1Comp
					AtuSldNat(SE1->E1_NATUREZ, dBaixa, SE1->E1_MOEDA, Iif(SE1->E1_TIPO $ MVPROVIS,"2","3"), "R", nValRealiz, nValForeing, Iif(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG+"/"+MVPROVIS,"-","+"),,FunName(),"SE1",SE1->(Recno()), , ,0, SE1->E1_FILORIG)
				Else
					AtuSldNat(SE1->E1_NATUREZ, dBaixa, SE1->E1_MOEDA, Iif(SE1->E1_TIPO $ MVPROVIS,"2","3"), "R", nValRealiz, nValForeing, Iif(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG+"/"+MVPROVIS,"-","+"),,FunName(),"SE1",SE1->(Recno()), , ,0, SE1->E1_FILIAL)
				Endif
			Else
				If lSE1Comp
					AtuSldNat(SE1->E1_NATUREZ, dBaixa, SE1->E1_MOEDA, Iif(SE1->E1_TIPO $ MVPROVIS,"2","3"), "R", nValRealiz, nValForeing, Iif(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG+"/"+MVPROVIS,"-","+"),,FunName(),"SE1",SE1->(Recno()), , ,0, cFilAnt)
				Else
					AtuSldNat(SE1->E1_NATUREZ, dBaixa, SE1->E1_MOEDA, Iif(SE1->E1_TIPO $ MVPROVIS,"2","3"), "R", nValRealiz, nValForeing, Iif(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG+"/"+MVPROVIS,"-","+"),,FunName(),"SE1",SE1->(Recno()), , ,0, SE1->E1_FILIAL)
				Endif
			Endif
		Else
			If cFilAnt == SE1->E1_FILORIG
				If lSE1Comp
					AtuSldNat(SE1->E1_NATUREZ, dBaixa, SE1->E1_MOEDA, Iif(SE1->E1_TIPO $ MVPROVIS,"2","3"), "R", nValRealiz, nValForeing, Iif(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG+"/"+MVPROVIS,"-","+"),,FunName(),"SE1",SE1->(Recno()), , ,0, SE1->E1_FILORIG)
				Else
					AtuSldNat(SE1->E1_NATUREZ, dBaixa, SE1->E1_MOEDA, Iif(SE1->E1_TIPO $ MVPROVIS,"2","3"), "R", nValRealiz, nValForeing, Iif(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG+"/"+MVPROVIS,"-","+"),,FunName(),"SE1",SE1->(Recno()), , ,0, SE1->E1_FILIAL)
				Endif
			Else
				If lSE1Comp
					AtuSldNat(SE1->E1_NATUREZ, dBaixa, SE1->E1_MOEDA, Iif(SE1->E1_TIPO $ MVPROVIS,"2","3"), "R", nValRealiz, nValForeing, Iif(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG+"/"+MVPROVIS,"-","+"),,FunName(),"SE1",SE1->(Recno()), , ,0, cFilAnt)
				Else
					AtuSldNat(SE1->E1_NATUREZ, dBaixa, SE1->E1_MOEDA, Iif(SE1->E1_TIPO $ MVPROVIS,"2","3"), "R", nValRealiz, nValForeing, Iif(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG+"/"+MVPROVIS,"-","+"),,FunName(),"SE1",SE1->(Recno()), , ,0, SE1->E1_FILIAL)
				Endif
			Endif
		Endif
	Endif

	dbSelectArea("SE1")
	nSalvRec	:= SE1->(RecNo())
	cNum	  	:= SE1->E1_NUM
	cPrefixo	:= SE1->E1_PREFIXO
	cParcela	:= SE1->E1_PARCELA
	cCliente	:= SE1->E1_CLIENTE
	cLoja   	:= SE1->E1_LOJA
	cTipoOr		:= SE1->E1_TIPO
	cTipo   	:= ""

	//------------------------------------------------------------------------------
	// Caso seja baixa de adiantamento, deverá ser estornado saldo
	// bancário. Apenas Baixa que gere movimentacao bancaria
	//------------------------------------------------------------------------------
	If !FwIsInCallStack("fA070Tit")
		If SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG
			If MovBcoBx(cMotBx, .T.) .And. !lGerChqAdt
				AtuSalBco( cBanco, cAgencia, cConta, dBaixa, nValRec, "-" )
			EndIf

			fa070Adiant( lPadrao, lContabiliza, IIF(cMotBx == "CEC", .T.,lGerChqAdt), @aBaixas, dDtCredito , nTxMoeda )

			If cPaisLoc == "COL"
				If FindFunction("FinProcITF") .And. FinProcITF( SE5->( Recno() ),1 ) .and. cTipoOr=='RA '
					FinProcITF( SE5->( Recno() ), 3, , .F.,, )
				EndIf
			EndIf
		EndIf

		If (!FN022SITCB(SE1->E1_SITUACA)[3]) .And. MovBcoBx(cMotBx, .T.) .And. !lAdiantamento .And. Empty( cLoteFin ) //Situacao de cobranca diferente de descontada

			//------------------------------------------------------------------------------
			// Gravar Saldo Bancário
			//------------------------------------------------------------------------------
			If cPaisLoc <> "BRA"
				nMoedaBco := Iif(Type("nMoedaBco") == "U", Max(Posicione('SA6',1,xFilial('SA6')+cBanco+cAgencia+cConta,"A6_MOEDA"),1),nMoedaBco)
				AtuSalBco(cBanco,cAgencia,cConta,dDtCredito,xMoeda(nValRec-nSomaCheq,SE1->E1_MOEDA,nMoedaBco,,,nTxMoeda),"+")
			Else
				AtuSalBco(cBanco,cAgencia,cConta,dDtCredito,nValRec-nSomaCheq,"+")
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ PTO DE ENTRADA para tratamento das datas de vencto do ISS	  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF lF070DISS
		ExecBlock("F070DISS",.f.,.f.)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Baixar titulos de abatimento se for baixa total				  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF nSaldo == 0 .Or. lGlosaMr
		//Atualiza status do adiantamento de viagem
		If (ALLTRIM(SE1->E1_ORIGEM) == "FINA677")
			FINATURES(SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA),.T.,SE1->E1_ORIGEM,"R")
		Endif

		If Select("__SE1") == 0
			SumAbatRec("","","",1,"")
		Endif
		dbSelectArea("__SE1")
		__SE1->(dbSetOrder(2))
		__SE1->(dbSeek(xFilial("SE1",SE1->E1_FILORIG)+cCliente+cLoja+cPrefixo+cNum+cParcela))
		If lTitpaiSE1
	 		If (nOrdTitPai:= OrdTitpai()) > 0
				__SE1-> (DbSetOrder(nOrdTitPai))
				If	DbSeek(xFilial("SE1",SE1->E1_FILORIG)+cPrefixo+cNum+cParcela+cTipoOr+cCliente+cLoja)
					bWhile := {|| !Eof() .And. Alltrim(XFILIAL("SE1",SE1->E1_FILORIG)+E1_TITPAI) == Alltrim(xFilial("SE1",SE1->E1_FILORIG)+cPrefixo+cNum+cParcela+cTipoOr+cCliente+cLoja) }
				Else
					__SE1->(dbSetOrder(2))
	  				__SE1->(dbSeek(xFilial("SE1",SE1->E1_FILORIG)+cCliente+cLoja+cPrefixo+cNum+cParcela))
				Endif
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verificações sobre a transferência de documento com o ISS na origem ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cFilOrgTr := FilISSTran()
				If !Empty( cFilOrgTr )
					nForIss := 2// -Somente para documentos que foram transferidos deixando o ISS na origem
				EndIf
			Endif
		Endif

		For nX := 1 To nForIss

			If nX == 2
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Alterações para efetuar a busca do ISS na filial de origem ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lTitpaiSE1 .And. nOrdTitPai == 0
					__SE1->( dbSetOrder( 2 ) )
					__SE1->(dbSeek(cFilOrgTr+cCliente+cLoja+cPrefixo+cNum+cParcela))
					bWhile := {|| !EOF() .And. E1_FILIAL==cFilOrgTr .And. E1_CLIENTE = cCliente	.And. E1_LOJA = cLoja .And. E1_PREFIXO=cPrefixo .And. E1_NUM == cNum .And. E1_PARCELA==cParcela }
				Else
					__SE1->(DbSeek(cFilOrgTr+cPrefixo+cNum+cParcela+cTipoOr+cCliente+cLoja))
					bWhile := {|| !Eof() .And. Alltrim(cFilOrgTr+E1_TITPAI) == Alltrim(cFilOrgTr+cPrefixo+cNum+cParcela+cTipoOr+cCliente+cLoja) }
				EndIf
			EndIf

			While Eval(bWhile)
				If lTitpaiSE1
					If !Empty(E1_TITPAI) .and.  (Alltrim(E1_TITPAI)!=Alltrim(cPrefixo+cNum+cParcela+cTipoOr+cCliente+cLoja))
						DbSkip()
						Loop
					EndIf
					If E1_TIPO $ "IS-/ISS" .And. IIF(IsInCallStack("FINA630"), !lTrfISSf, .F.)
						DbSkip()
						Loop
					EndIf
				EndIf

				//Trabalha somente com o ISS da filial de origem, somente em casos de documento transferido
				If nX == 2 .And. E1_TIPO <> MVISABT
					DbSkip()
					Loop
				EndIf

				IF E1_TIPO $ MVABATIM+"/"+MVIRABT+"/"+MVINABT+"/"+MVPIABT+"/"+;
					MVCFABT+"/"+MVCSABT+"/"+MVFUABT //adicionado a variável MVFUABT, pois a variável MVABATIM não está retornando FU-
					RecLock("__SE1")
					Replace E1_SALDO	With 0
					Replace E1_BAIXA	With dBaixa
					Replace E1_LOTE	With cLoteFin
					Replace E1_MOVIMEN With dBaixa
					Replace E1_STATUS  With "B"
					Replace E1_SDACRES With 0
					Replace E1_SDDECRE With 0

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Gravar o titulo que baixou o AB- para evitar estornos de ³
					//³abatimentos baixados por outras rotinas. Evita que um AB-³
					//³baixado pelo FINA070 / 110 seja estornado indevidamente  ³
					//³pelo FINA330, que gera erro na composicao do saldo do    ³
					//³titulo principal com abatimento.                         ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If Empty(SE1->E1_TITPAI) .OR. (!MV_CRNEG $ SE1->E1_TITPAI .AND. !MVRECANT $ SE1->E1_TITPAI)
						Replace E1_TITPAI	With (cPrefixo + cNum + cParcela + cTipoOr + cCliente + cLoja)
					
						if lPLSTITPF
							PLSTITPF('SE1', cPrefixo + cNum + cParcela + cTipoOr + cCliente + cLoja)
						endIf

					Endif

					If lF070GrvHis .and. E1_TIPO $ MVIRABT
						ExecBlock("F070GrvHis",.F.,.F.)
					ENDIF

					If lAtuSldNat
						If lGestao
							If cFilAnt == SE1->E1_FILORIG
								If lSE1Comp
									AtuSldNat(E1_NATUREZ, E1_BAIXA, E1_MOEDA, "3", "R", E1_VALOR, E1_VALOR, "-",,FunName(),"SE1",SE1->(Recno()),nOpcx, ,0, E1_FILORIG)
								Else
									AtuSldNat(E1_NATUREZ, E1_BAIXA, E1_MOEDA, "3", "R", E1_VALOR, E1_VALOR, "-",,FunName(),"SE1",SE1->(Recno()),nOpcx, ,0, E1_FILIAL)
								Endif
							Else
								If lSE1Comp
									AtuSldNat(E1_NATUREZ, E1_BAIXA, E1_MOEDA, "3", "R", E1_VALOR, E1_VALOR, "-",,FunName(),"SE1",SE1->(Recno()),nOpcx, ,0, cFilAnt)
								Else
									AtuSldNat(E1_NATUREZ, E1_BAIXA, E1_MOEDA, "3", "R", E1_VALOR, E1_VALOR, "-",,FunName(),"SE1",SE1->(Recno()),nOpcx, ,0, E1_FILIAL)
								Endif
							Endif
						Else
							If cFilAnt == SE1->E1_FILORIG
								If lSE1Comp
									AtuSldNat(E1_NATUREZ, E1_BAIXA, E1_MOEDA, "3", "R", E1_VALOR, E1_VALOR, "-",,FunName(),"SE1",SE1->(Recno()),nOpcx, ,0, E1_FILORIG)
								Else
									AtuSldNat(E1_NATUREZ, E1_BAIXA, E1_MOEDA, "3", "R", E1_VALOR, E1_VALOR, "-",,FunName(),"SE1",SE1->(Recno()),nOpcx, ,0, E1_FILIAL)
								Endif
							Else
								If lSE1Comp
									AtuSldNat(E1_NATUREZ, E1_BAIXA, E1_MOEDA, "3", "R", E1_VALOR, E1_VALOR, "-",,FunName(),"SE1",SE1->(Recno()),nOpcx, ,0, cFilAnt)
								Else
									AtuSldNat(E1_NATUREZ, E1_BAIXA, E1_MOEDA, "3", "R", E1_VALOR, E1_VALOR, "-",,FunName(),"SE1",SE1->(Recno()),nOpcx, ,0, E1_FILIAL)
								Endif
							Endif
						Endif
					Endif

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Carrega variavies para contabilizacao dos    ³
					//³ abatimentos (impostos da lei 10925).         ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If E1_TIPO == MVPIABT
						VALOR5 := E1_VALOR
					ElseIf E1_TIPO == MVCFABT
						VALOR6 := E1_VALOR
					ElseIf E1_TIPO == MVCSABT
						VALOR7 := E1_VALOR
					Endif
					MsUnlock()
				EndIF
				dbSkip()
			Enddo
		Next nX
		__SE1->(dbSetOrder(1))
	ElseIf lF070GerAb
		nSaldo -= EXECBLOCK("F070GerAb",.F.,.F., {cCliente+cLoja+cPrefixo+cNum+cParcela, dBaixa , cLoteFin , cTipoOr, } )
	Endif

	dbSelectArea("SE1")
	SE1->(dbGoto(nSE1Rec))

	IF nSaldo == 0
		If lFin70BxIr
			Execblock("Fin70BxIr", .F.,.F.)
		Endif
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona no registro de natureza									  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SED")
	SED->(dbSeek(xFilial("SED")+SE1->E1_NATUREZ))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o Cadastro de Clientes 									  ³
	//³ A pesquisa pelo SL1 e' do Loja no caso de adm <> "R$/CH"     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SA1")
	SA1->(DbSetOrder(1))
	If dbSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA)
		nValClient := nValPadrao
		IF SE1->E1_MOEDA > 1
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Caso a Moeda seja > 1, converte o valor para atualiza‡„o do  ³
			//³ cadastro do Cliente a partir do valor da moeda estrangeira   ³
			//³ convertida p/ moeda 1 na Data de Emiss„o do t¡tulo, pois pode³
			//³ ser efetuada uma baixa informando taxa contratada.           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nVlEstOri := nValEstrang-(Round(NoRound(xMoeda(nJuros + nVA +nMulta-nDescont-nOtrga,nMoedaBco,SE1->E1_MOEDA,dBaixa,3,,nTxMoeda),3),2))
			nValClient:= Round(NoRound(xMoeda(nVlEstOri,SE1->E1_MOEDA,nMoedaBco,SE1->E1_EMISSAO,3,nTxMoeda),3),2)
		EndIf
		If __cSldBxCr == "C"
			nValClient := nValClient-nSomaCheq
		Endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Para o SIGALOJA, executa a funcao de comissao por ³
		//³baixa chamada Lj440ProcB (LOJA440)                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nModulo == 12 .Or. nModulo == 72 .Or. (nModulo == 5 .And. AllTrim(Funname()) == "FATA701") // SIGALOJA //SIGAPHOTO // VENDA DIRETA
			If cTpComLj == "O" .AND. ComisBx( TrazCodMot(cMotBx) ) .AND. SE1->E1_COMIS1 > 0
				Fa440CalcB(aBaixas,lJuros,lDesconto,"FINA070",,,,.T.,nSE1Rec)
				lLj440Proc := .T.
			EndIf
		EndIf
		If lAdiantamento
			AtuSalDup("+",nValClient,nMoedaBco,SE1->E1_TIPO,,SE1->E1_EMISSAO,,lBloqSa1)
			If SuperGETMV("MV_TPCOMIS",,"O") == "O"  .and. ComisBx( TrazCodMot(cMotBx) ) .AND. !lLj440Proc .AND. lVendedor
				Fa440CalcB(aBaixas,lJuros,lDesconto,"FINA070","-",,,.T.,nSE1Rec)
			Endif
		ElseIf FunName() <> "FINA074"
			AtuSalDup("-",nValClient,1,SE1->E1_TIPO,nTxMoeda,SE1->E1_EMISSAO,nCm,lBloqSa1)
			If lBloqSa1
		    	RecLock("SA1")
				Replace A1_NROPAG With A1_NROPAG+1  //Numero de Duplicatas

				nAtraso:=dBaixa-SE1->E1_VENCTO
				If nAtraso > 1
					IF Dow(SE1->E1_VENCTO) == 1 .Or. Dow(SE1->E1_VENCTO) == 7
						If Dow(dBaixa) == 2 .and. nAtraso <= 2
							nAtraso := 0
						EndIf
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza atraso medio SA1->A1_ATR                            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If 	SE1->E1_VENCREA < dBaixa .AND. SA1->A1_ATR <> 0
				 		If SE1->E1_SALDO <> SE1->E1_VALOR
				   			SA1->A1_ATR := SA1->A1_ATR - nValRec
				   		ElseIf SA1->A1_ATR := SA1->A1_ATR + SE1->E1_SALDO
				   			SA1->A1_ATR := SA1->A1_ATR - nValRec
				   		EndIf
				  	EndIf

				  	If SE1->E1_VENCREA < dBaixa .AND. SA1->A1_ATR == 0
				   		SA1->A1_ATR := SA1->A1_ATR + SE1->E1_SALDO
				   		SA1->A1_ATR := SA1->A1_ATR - nValRec
				 	EndIf
					nAtraso:=IIF(nAtraso<0,0,nAtraso)
					If SA1->A1_MATR < nAtraso
						Replace A1_MATR With nAtraso
					EndIf
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza Atraso M‚dio.  Revisao em 07/12/95					     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If (SE1->E1_BAIXA - SE1->E1_VENCREA) > 0
					SA1->A1_PAGATR := A1_PAGATR+SE1->E1_VALLIQ   // Pagamentos Atrasados
				EndIf

				SA1->A1_METR	 :=	(A1_METR * (A1_NROPAG-1) + (SE1->E1_BAIXA - SE1->E1_VENCREA)) / (A1_NROPAG)

				SA1->(MsUnlock())	// Destrava SA1 apos alteracoes...
			EndIf

			If SuperGETMV("MV_TPCOMIS",,"O") == "O" .and. ComisBx( TrazCodMot(cMotBx) ) .AND. !lLj440Proc .AND. lVendedor
				Fa440CalcB(aBaixas,lJuros,lDesconto,Iif(!empty(SE1->E1_NUMLIQ),, Iif( ( nModulo == 12 .Or. nModulo == 23 ) .And. cTpComLj == "B", FunName(), "FINA070")),,,,.T.,nSE1Rec)
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ PONTO DE ENTRADA 									  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lSE3FI070
				ExecBlock('SE3FI070',.f.,.F.)
			EndIf

		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Complementa grava‡Æo da baixa tit. principal  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SE1")
	SE1->(dbGoto(nSE1Rec))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ PONTO DE ENTRADA 									  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lSE3F070
		ExecBlock('SE3F070',.f.,.F.)
	Endif

	RecLock("SE1")
	Replace E1_SALDO With nSaldo
	If cPaisLoc=="EUA" .and. FUNNAME() # "FINA884" .and. SE1->(FieldPos("E1_SLPLAID")) > 0
		E1_SLPLAID	:= nSaldo
	EndIF


	If (nAcrescF - xMoeda( (nValRec - ((nTotJur+nMulta)-nDescont)),nMoedaBco,SE1->E1_MOEDA,SE1->E1_EMISSAO,3,,nTxMoeda)) > 0
		Replace E1_SDACRES  With nAcrescF - xMoeda( (nValRec - ((nTotJur+nMulta)-nDescont)),nMoedaBco,SE1->E1_MOEDA,SE1->E1_EMISSAO,3,,nTxMoeda)
	Else
		Replace E1_SDACRES  With 0
	EndIf

	Replace E1_SDDECRE  With 0
	Replace E1_STATUS   With IIF(E1_STATUS != "R",Iif(E1_SALDO >= 0.01,"A","B"),"R")

	If __nToler > 0 .And. nSaldo > 0
		If nSaldo <= __nToler
			Replace E1_DESCONT	With E1_DESCONT+nSaldo
			Replace E1_SALDO		With 0
			Replace E1_STATUS   With IIF(E1_STATUS != "R",Iif(E1_SALDO >= 0.01,"A","B"),"R")
			nDescont := E1_DESCONT
		EndIf
	EndIf

	If __nToler > 0 .and. nSaldo < 0
		Replace E1_SALDO		With E1_SALDO+Abs(nSaldo)
		Replace E1_JUROS		With E1_JUROS+Abs(nSaldo)
		Replace E1_STATUS   With IIF(E1_STATUS != "R",Iif(E1_SALDO >= 0.01,"A","B"),"R")
		nValToler := Abs(nSaldo)
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se saldo for menor que zero, for‡a o seu zeramento pois ocorre de o u-³
	//³suario realmente receber o valor em real a maior que o saldo em dolar ³
	//³gerando uma cota‡„o a maior e consequente saldo negativo, indevido    ³
	//³SOMENTE PARA BAIXA MANUAL.                                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SE1->E1_SALDO < 0 .and. !lExterno 		// lExterno == .T. == CNAB
		Replace E1_SALDO With 0
		Replace E1_STATUS   With IIF(E1_STATUS != "R",Iif(E1_SALDO >= 0.01,"A","B"),"R")
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava "Nosso Numero" apenas se o campo for vazio e a variavel³
	//³ possuir conte£do. A variavel  "cNsNum" vem preenchida somente³
	//³ quando esta fun‡„o fa070grv for chamada pelo programa FINA200³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(cNsNum) .and. Empty(SE1->E1_NUMBCO)
		SE1->E1_NUMBCO := cNsNum
	Endif


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Executa funcao do PLS para gerar juros para      ³
	//³descontar no mes seguinte                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Substr(SE1->E1_ORIGEM,1,3) == "PLS"
		PLS510JR()
	Endif

	nIss := 0
	// Gravacao das retencoes - Motor de Retencoes
	If __lTemFK0 .And. lMotorRet
		FinGrvImp("2" , SE1->(Recno()), aMotRet, "FINA070", .F., {}, {}, .F., .F., .T./*lBaixa*/, dBaixa, "FK1",cSequencia,.T.)
	EndIf
	//Gravo os titulos de impostos Pis Cofins Csll quando controlados pela baixa
	// Os titulos de impostos devem ser desconsiderados quando C/C cuja moeda seja diferente da moda corrente
	If !lPccMR .And. cPaisLoc == "BRA" .and. lPCCBxCR .and. lRetParc
		//Imposto PCC sempre na moeda 1
		If FXMultSld()
			If SA6->A6_MOEDA <= 1
				FGrvPccRec(@nPis,@nCofins,@nCsll,nSalvRec,.F.,lRetParc,cSequencia,"FINA070",1)
			EndIf
	    Else
			FGrvPccRec(@nPis,@nCofins,@nCsll,nSalvRec,.F.,lRetParc,cSequencia,"FINA070",1)
	    EndIf
	Endif
	If !lIrfMR .And. cPaisLoc == "BRA" .and. lIrPjBxCr .and. nIrrf > 0
		If FXMultSld()
			If SA6->A6_MOEDA <= 1
				FGrvIrRec(@nIrrf,nSalvRec,.F.,cSequencia,"FINA070",SE1->E1_MOEDA)
			EndIf
	    Else
			FGrvIrRec(@nIrrf,nSalvRec,.F.,cSequencia,"FINA070",SE1->E1_MOEDA)
	    EndIf
	Endif

	If lf70GrSe1				// Ponto de entrada no final da baixa do titulo
		Execblock("F70GRSE1",.F.,.F.,{cOcorr})
	Endif

	//
	// Template GEM - Se todos os titulos foram pagos (E1_SALDO == 0 ) deve atualizar o STATUS do contrato.
	//
	If ExistTemplate("GMUpdStatContr")
		ExecTemplate("GMUpdStatContr",.F.,.F.,{SE1->E1_NUM ,SE1->E1_SERIE ,SE1->E1_PREFIXO } )
	EndIf

	//
	//Função Específica do Modulo Sigapls para atualizar Status de Guias Compradas
	//
	If GetNewPar("MV_PLSATIV",.F.)
		PL090TITCP(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,"1")
	EndIf

EndIf

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070MOV

Grava movimento de baixa CR.
Arquivo anterior: FINXATU.PRX

@Author	Wagner Xavier
@since	06/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function FA070Mov(lPadrao, lContabiliza, lAdiantamento, dDtCredito, aBaixas, cArqEnt, cOcorr, nTxMoeda, nSomaCheq,;
				  aSeqSe5, cSequencia, aHdlPrv, cProc, oModelBxC, lMultNat, aMotRet, lPccMR, lIrfMR, lInsMR, lIssMR,;
				  lImpMR, aTitCalc, cSituaCob, nBxaPrin, lPIX)

Local nI			:= 0
Local cTpDoc		:= ""
Local cAlias		:= ALIAS()
Local cHistMov		:= ""
Local lSpbInUse		:= SpbinUse()
Local bCampo		:= {|| }
Local nValMov		:= 0
Local nValCalc		:= 0
Local nX			:= 0
Local nIndexOrd		:= 0
Local nTamSeq		:= TamSX3("FK1_SEQ")[1] 
Local oModelBxRA	:= NIL
Local cLog			:= ""
Local cCamposE5		:= ""
Local nRecSE5		:= 0
Local aRecnos 		:= {}
Local aAuxFK6		:= {}
Local nRecOrig		:= 0
Local lRet			:= .T.
Local cFormPagto	:= ""
Local lAcolsType	:= Type("aCols") == "A"
Local lExistFK6		:= .F.
Local cNumChq       := ''
Local aRecAdd		:= {}
Local lSitCob       := .F.
LOCAL nVlMv         := 0
LOCAL nJrs          := 0
LOCAL nMlt          := 0
LOCAL nDsc          := 0
LOCAL nJrsSld       := 0
LOCAL nMltSld       := 0
LOCAL nDscSld       := 0
LOCAL bAbtDsp       := {|nMOV,nSDDSP,nDSP| nDSP:=IF(!EMPTY(nMOV) .AND. !EMPTY(nSDDSP),MIN(nMOV,nSDDSP),0),nSDDSP-=nDSP,nMOV-=nDSP}

//Variavel para compatibilidade do MVC
Private n			:= 0

Default nSomaCheq 	:= 0
Default aSeqSe5 	:= {}
Default cSequencia	:= Replicate("0",nTamSeq)
Default aHdlPrv		:= {}
Default cProc		:= ""
Default oModelBxC	:= NIL
Default lMultNat	:= .F.
Default aTitCalc	:= {}
Default cSituaCob   := "0"
Default nBxaPrin    := 0
Default lPIX		:= .F.

nIrrf := If( Type("nIrrf") != "N", 0, nIrrf )

nValToler := Iif(nValToler==Nil,0,nValToler)
lAdiantamento := Iif( lAdiantamento=Nil,.f.,lAdiantamento )

cArqEnt		:= Iif(cArqEnt==Nil," ",cArqEnt)
cOcorr		:= Iif(cOcorr==Nil,"  ",cOcorr)
cFormPagto	:= If(Type("cFormaPag") != "C","",cFormaPag)

nJurosCalc	:= If( Type("nJurosCalc") != "N", 0, nJurosCalc )
nMultaCalc	:= If( Type("nMultaCalc") != "N", 0, nMultaCalc )
nDescCalc	:= If( Type("nDescCalc") != "N", 0, nDescCalc )

cModSpb		:= If( Type("cModSpb") != "C", "1", cModSpb )
nVa			:= IIf( Type('nVA') != 'N', 0, nVa )

If lAdiantamento
	Return .T.
EndIf

If __cSldBxCr==Nil
	__cSldBxCr := SuperGetMv("MV_SLDBXCR",,"B")
EndIF

If lF070MV1
	aBxAcr := Iif(Type("aBxAcr") != "A", {}, aBxAcr)
	aBxDec := Iif(Type("aBxDec") != "A", {}, aBxDec)
EndIf

cSequencia 	:= FaNxtSeqBx("SE1",.T.)  // Sequencia da baixa do adiantamento + 1

//Desenvolvo aqui a logica nova da reestruturacao da SE5
//Instancio os models, sub models e models auxiliares que vou utilizar na gravacao, passando como parametro para a funcao Fa070GrvSe5
IF oModelBxC != NIL
	oModelBxR := oModelBxC
ELSE
	If oModelBxR == Nil
		oModelBxR := FWLoadModel("FINM010")
	EndIf
ENDIF

oModelBxR:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
oModelBxR:Activate()
oModelBxR:SetValue("MASTER","E5_GRV",.T.) //habilita gravação de SE5
oModelBxR:SetValue("MASTER","NOVOPROC", .T. ) //Novo processo

lSitCob := FN022SITCB(Iif(cSituaCob != "0", cSituaCob, SE1->E1_SITUACA))[3]

// Controle do Saldo para quando utilizar recebimento em Cheque(s) - MV_SLDBXCR
nJrsSld := nJuros
nMltSld := nMulta
nDscSld := nDescont

For nI := 1 To 8
	nValCalc := 0
	cTpDoc   := "BA"

	If nI == 1 //Atualiza a movimentação bancária
		nValMov := nValRec
		
		If lSitCob
			cTpDoc := "V2" 
		ElseIf Empty(cLoteFin) .And. !FwIsInCallStack("FA450CMP")
			cTpDoc := "VL"
		EndIf
		
		If cTpDoc != "BA" .And. !cSituaCob $ "2|7" .And. !MovBcoBx(cMotBx,.T.) .And. !AllTrim(SE1->E1_SITUACA) $ "2|7"
			cTpDoc := "BA"
		Endif
		
		If __cSldBxCr == "C" //Controla saldo na compensacao do cheque
			/*Do valor recebido deve ser subtraido o total pago em cheque, pois o valor referente a
			baixa efetuada em cheque sera movimentado apenas quando o cheque for compensado.*/
			nValMov := nValRec-nSomaCheq
		Endif
		
		cHistMov:= Iif(Empty(cHist070), STR0002, cHist070) //Valor recebido s/ titulo
	Elseif nI == 2
		nValMov := nSomaCheq
	Elseif nI == 3
		nValMov  := nMulta
		nValCalc := nMultaCalc
		cTpDoc   := IIF(lSitCob, "M2", "MT")	//sitcob
		cHistMov := STR0003 //Multa s/Receb.Titulo

		IF cPaisLoc == "ARG" .and.  cTpDoc == "MT" 
			nValMov := Round(NoRound(xMoeda(nMulta,1,SE1->E1_MOEDA,dBaixa,3,,ntxmoeda),3),2) // Desconto Arg deve considerar a moeda do titulo bem como o campo E5_VLMULTA
		EndIf
	Elseif nI == 4
		nValMov  := nCM
		nValCalc := nCM
		cTpDoc   := IIF(lSitCob, "C2", "CM")	//sitcob
		cHistMov := STR0004 //Correcao Monet s/Receb.Titulo
	Elseif nI == 5
		nValMov  := nDescont
		nValCalc := nDescCalc
		cTpDoc   := IIF(lSitCob, "D2", "DC")
		cHistMov := STR0005 //Desconto s/Receb.Titulo
		
		IF cPaisLoc == "ARG" .and.  cTpDoc == "DC" 
			nValMov := Round(NoRound(xMoeda(nDescont,1,SE1->E1_MOEDA,dBaixa,3,,ntxmoeda),3),2) // Desconto Arg deve considerar a moeda do titulo bem como o campo E5_VLDESCO
		EndIf
	Elseif nI == 6
		nValMov  := nValToler
		nValCalc := nValToler
		cTpDoc   := "TL"
		cHistMov := STR0006 //Toler Receb. s/ Titulo
	Elseif nI == 7
		nValMov  := nJuros
		nValCalc := nJurosCalc
		cTpDoc   := Iif(lSitCob, "J2", "JR")	//lsitcob
		cHistMov := STR0007 //Juros s/Receb.Titulo

		IF cPaisLoc == "ARG" .and.  cTpDoc == "JR" 
			nValMov := Round(NoRound(xMoeda(nJuros,1,SE1->E1_MOEDA,dBaixa,3,,ntxmoeda),3),2) // Desconto Arg deve considerar a moeda do titulo bem como o campo E5_VLJUROS
		EndIf
	Elseif nI == 8
		nValMov  := nVA
		nValCalc := nVA
		cTpDoc   := "VA"
		cHistMov := STR0027 //Valores Acessórios
	Endif
	
	// Grava o movimento bancario, se o campo for diferente de 0 ou se
	// for o valor recebido verifica se o valor nao foi pago totalmente em cheque,
	// para nao haver um registro do cheque e um registro com valor 0 da diferenca
	If nValMov != 0 .Or. ;		//Valor do movimento não é zero (positivo ou negativo)
		(nValMov == 0 .And. nValCalc != 0) .or. ; //Valor do movimento é zero, mas o valor calculado é diferente de zero (negativo ou positivo)
		(nI == 1 .And. (__cSldBxCr != "C" .or. (nValMov == 0 .And.( nDescont > 0 .Or. nVA < 0 ) ) )) .or. ; //Baixa por desconto
		 nI == 8 //Se for VA
		
		If nI == 2
			If lAcolsType .And. !Empty(aCols)
				// Para cada cheque, gera um movimento bancario
				For nX := 1 To Len(aCols)
					// Se o cheque nao estiver deletado, os dados forem validos
					If !aCols[nX][Len(aCols[1])]	.And.;
						!Empty(aCols[nX][1])		.And.;
						!Empty(aCols[nX][2])		.And.;
						!Empty(aCols[nX][3])		.And.;
						!Empty(aCols[nX][4])		.And.;
						!Empty(aCols[nX][5])		.And.;
						!Empty(aCols[nX][6])		.And.;
						!Empty(aCols[nX][7])		.And.;
						!Empty(aCols[nX][8])		.And.;
						!Empty(aCols[nX][9])
						
						// Se o identificador de que o cheque ja foi utilizado na baixa estiver diferente de Sim,
						// gera o movimento, devido as baixas parciais, pois nas baixas futuras esses cheques nao
						// podem mais serem utilizados
						If aCols[nX][15] != "Sim"
							// Gera nova sequencia, para o caso do cancelamento apenas da baixa do valor recebido em cheque nao cancelar todas as baixas
							cHistMov   := "Rec Ch-bco/ag/ch " + aCols[nX][1]+"/"+aCols[nX][2]+"/"+aCols[nX][4]
					  		bCampo     := { || aCols[nX][6] } // Valor Ref. Baixa
							cSequencia := Soma1(cSequencia,nTamSeq)
							nValMov    := Eval(bCampo)
							cNumchq    := aCols[nX][4]
							
							IF !empty(cCamposE5)
								cCamposE5 += "}"
							endIF

                            // Apenas casos onde o parâmetro MV_SLDBXCR = 'C' - Movimento Bancário de Cheques na (C)ompensação
                            nJrs := 0
                            nMlt := 0
                            nDsc := 0
                            IF (__cSldBxCr == "C")
                                nDsc := nDscSld
                                nDscSld := 0    // Após usar o Desconto abate do saldo remanescente.

                                // Considerar o Valor do Desconto
                                nVlMv := nValMov + nDsc
                                // Ajusta o valor dos Juros em função do valor do movimento
                                EVAL(bAbtDsp,@nVlMv,@nJrsSld,@nJrs)
                                // Ajusta o valor da Multa em função do valor do movimento
                                EVAL(bAbtDsp,@nVlMv,@nMltSld,@nMlt)
                            ENDIF

					  		Fa070GrvSe5(cBanco, cAgencia, cConta, dBaixa, nValMov, lPadrao, lContabiliza, cTpDoc, cHistMov, cLoteFin,;
							  			cMotBx, nValEstrang, cSequencia, lSpbInUse, cModSpb, dDtCredito, cArqEnt, cOcorr, nTxMoeda, nI,;
										nJrs, nMlt, nCm, nDsc, aBaixas, Nil, nSomaCheq, oModelBxR, oModelBxRA, cProc,;
										Nil, @cCamposE5, nVa, Nil, cFormPagto, lMultNat, aMotRet, lPccMR, lIrfMR, lInsMR,;
										lIssMR, lImpMR, cNumChq, aTitCalc, cSituaCob, lPIX)

							//Adiciona a sequencia para ser utilizado na gravacao do movimento do cheque.
							Aadd(aSeqSe5,cSequencia)
							dbSelectArea("SEF")
							SEF->(dbSetOrder(3))
							
							//>> Localizacao e marcacao do cheque. Processo de baixa.
							nIndexOrd := SEF->( IndexOrd() )
							SEF->(dbSetOrder( 1 ))
							
							//Banco -> aCols[nX][1] + Agencia -> aCols[nX][2] + Conta -> aCols[nX][3] + Numero do Cheque -> aCols[nX][4]
							If SEF->( MsSeek(xFilial("SEF") + aCols[nX][1] + aCols[nX][2] + aCols[nX][3] + aCols[nX][4]))
								If !aCols[nX][Len(aCols[nX])] //Se nao estiver deletado e ...
									RecLock("SEF", .F.)
									SEF->EF_USADOBX := "S"
									SEF->EF_SEQUENC := cSequencia
								Endif
							Endif
							
							SEF->( dbSetOrder( nIndexOrd ) )
						Else
							//Adiciona uma sequencia auxiliar para o cheque que está vinculado a outro título, para
							//que o array fique com a mesma quantidade do aCols na gravação dos cheques.
							Aadd(aSeqSe5,Replicate("0",nTamSeq))
						Endif
					else
						//Adiciona uma sequencia auxiliar para o cheque que está vinculado a outro título, para
						//que o array fique com a mesma quantidade do aCols na gravação dos cheques.
						Aadd(aSeqSe5,Replicate("0",nTamSeq))
					Endif
				Next
			Else
				dbSelectArea("SEF")
				SEF->(dbSetOrder(3))
				SEF->(MsSeek(xFilial("SEF")+SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)))
				
				While SEF->(!Eof()) .And.;
				SEF->(EF_FILIAL+EF_PREFIXO+EF_TITULO+EF_PARCELA+EF_TIPO) == xFilial("SEF")+SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)
					If (SEF->EF_FORNECE == SE1->E1_CLIENTE .Or. SEF->EF_CLIENTE == SE1->E1_CLIENTE) .And. !Empty(SEF->EF_NUM)
						If SEF->EF_USADOBX != "S"
							//Gera nova sequencia, para o caso do cancelamento apenas da baixa do valor recebido em cheque nao cancelar todas as baixas
							cHistMov   := "Rec Ch - bco/ag/ch " + SEF->(EF_BANCO+"/"+EF_AGENCIA+"/"+EF_NUM)
					  		nValMov    := SEF->EF_VALORBX
							cSequencia := Soma1(cSequencia,nTamSeq)
					  		
					  		Fa070GrvSe5(cBanco, cAgencia, cConta, dBaixa, nValMov, lPadrao, lContabiliza, cTpDoc, cHistMov, cLoteFin,;
										cMotBx, nValEstrang, cSequencia, lSpbInUse, cModSpb, dDtCredito, cArqEnt, cOcorr, nTxMoeda, nI,;
										nJuros, nMulta, nCm, nDescont, aBaixas, Nil, nSomaCheq, oModelBxR, oModelBxRA, cProc,;
										Nil, @cCamposE5, nVa, nValMov, cFormPagto, lMultNat, aMotRet, lPccMR, lIrfMR, lInsMR,;
										lIssMR, lImpMR, cNumChq, aTitCalc, cSituaCob, lPIX)
							
							//Adiciona a sequencia para ser utilizado na gravacao do movimento do cheque.
							Aadd(aSeqSe5,cSequencia)
							
							// Grava o identificador de que o cheque ja foi utilizado na baixa, devido as
							// baixas parciais, pois nas baixas futuras esses cheques nao podem mais serem utilizados
							RecLock("SEF",.F.)
							SEF->EF_USADOBX := "S"
							SEF->EF_SEQUENC := cSequencia
						Else
                     		//Adiciona uma sequencia auxiliar para o cheque que está vinculado a outro título, para
                     		//que o array fique com a mesma quantidade do aCols na gravação dos cheques.
							Aadd(aSeqSe5,Replicate("0",nTamSeq))
						Endif
					EndIf					
					SEF->(dbSkip())
				EndDo
				
				dbSelectArea(cAlias)
			Endif
		Else
			If AllTrim(Upper(SE1->E1_ORIGEM)) <> "FINA074" .or. (cPaisLoc$"ARG|ANG|COL|MEX|PER|URU" .And. cTpDoc<> "CM")
				// Este tratamento é para gerar "n" vezes o lançamento bancario de acordo com acrescimo/decrescimo
                If nI == 5 .Or. nI == 7
					IF lF070MV1						
						aHdlAux := ExecBlock("F070MV1", .F., .F., {nI, aBxAcr, aBxDec, cBanco, cAgencia, cConta, dBaixa, nValMov,;
							       lPadrao, lContabiliza, cTpDoc, cHistMov, cLoteFin, cMotBx, nValEstrang, cSequencia, lSpbInUse, cModSpb,;
								   dDtCredito, cArqEnt, cOcorr, nTxMoeda, nJuros, nMulta, nCm, nDescont, aBaixas, aHdlPrv})
					    
						If Valtype(aHdlAux) == "A"
							aHdlPrv	:= aClone(aHdlAux)
						EndIf
					EndIf
				EndIf

                nJrs := nJrsSld
                nMlt := nMltSld
                nDsc := nDscSld
                
                // Apenas casos onde o parâmetro MV_SLDBXCR = 'C' - Movimento Bancário de Cheques na (C)ompensação
                IF (__cSldBxCr == "C")
                    nDscSld -= nDsc    // Após usar o Desconto abate do saldo remanescente para não informar em outros lanctos.

                    // Desconsiderar o Valor do Desconto no abatimento de Juros e Multa 
                    // qdo o Valor do Movimento for Zero
                    nVlMv := IF(EMPTY(nValMov),0,nValMov + nDsc)
                    // Ajusta o valor dos Juros em função do valor do movimento
                    EVAL(bAbtDsp,@nVlMv,@nJrsSld,@nJrs)
                    // Ajusta o valor da Multa em função do valor do movimento
                    EVAL(bAbtDsp,@nVlMv,@nMltSld,@nMlt)
                ENDIF

				Fa070GrvSe5(cBanco, cAgencia, cConta, dBaixa, nValMov, lPadrao, lContabiliza, cTpDoc, cHistMov, cLoteFin,;
						cMotBx, nValEstrang, cSequencia, lSpbInUse, cModSpb, dDtCredito, cArqEnt, cOcorr, nTxMoeda, nI,;
						nJrs, nMlt, nCm, nDsc, aBaixas, Nil, nSomaCheq, oModelBxR, oModelBxRA, cProc,;
						Nil, @cCamposE5, nVa, nValCalc, cFormPagto, lMultNat, aMotRet, lPccMR, lIrfMR, lInsMR,;
						lIssMR, lImpMR, cNumChq, aTitCalc, cSituaCob, lPIX)
			EndIf
		Endif
	EndIf
Next nI

If !__lFinm010 .OR. !MovBcobx(cMotBx, .T.)
	If !Empty(cCamposE5)
		cCamposE5 += "}"
		oModelBxR:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )
	EndIf
Endif

//Grava os dados
If (lRet := oModelBxR:VldData())
	lExistFK6 := !oModelBxR:GetModel('FK6DETAIL'):IsEmpty() // Validação do Model antes do commit, pq a FK6DETAIL descarrega depois de comitar
	oModelBxR:CommitData()
	
	//Pega o Recno da SE5 referente a baixa principal e reposiciona para atualizar o valor com tratamento do IR
	nRecOrig := oModelBxR:GetValue( "MASTER", "E5_RECNO" )
	aAdd(aRecnos, nRecOrig)
	
	If cSituaCob != "0"
		nBxaPrin := nRecOrig
	EndIf
	
	If lExistFK6 //precisa dos recnos da FK6, para composição do abaixas para calculo da comissão
  		aAuxFK6 := FK6SE5Recs()
  		For nX := 1 to Len(aAuxFK6)
   			aAdd(aRecnos, aAuxFK6[nX])
  		Next nX
 	Endif
	
	//Busca mais baixas efetuadas para o mesmo processo, caso a baixa tenha vários cheques e valores, passar todos no aBaixas para comissão
	If __cSldBxCr == 'C'
		aRecAdd := GetRecAdd( oModelBxR:GetValue( "MASTER", "IDPROC" ) )
		For nX := 1 To Len(aRecAdd)
			If aScan(aRecnos , {|x| x= aRecAdd[nX] }) <= 0
				aAdd(aRecnos, aRecAdd[nX] )
			EndIf
		Next nX
	EndIf
	
	If cSituaCob == "0" //Não processa a comissão, pois será feito na rotina de 060
		For nX := 1 to Len(aRecnos)
			nRecSE5 := aRecnos[nX]
			If nRecSE5 > 0
				SE5->( DbGoTo( nRecSE5 ) )
				//Utilizado na rotina de comissão na baixa
				If ! SE1->E1_TIPO $ MV_CRNEG .And. !SE1->E1_TIPO $ MV_CPNEG
					//Não migrar trecho para as FK´s antes da conversão da função Fa440CalcB (FINA440)
					aAdd( aBaixas, { SE5->E5_MOTBX, SE5->E5_SEQ, nRecSE5 } ) 
				Endif
			Endif
		Next nX
	EndIf

 	SE5->(DbGoTo(nRecOrig))

Else

    cLog := cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_IDFIELDERR]) + ' - '
    cLog += cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_ID]) + ' - '
    cLog += cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_MESSAGE])

    Help( ,,"M010VLDI5",,cLog, 1, 0 )
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ PONTO DE ENTRADA			                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If lSE5FI070
	aRecnos:= FK6SE5Recs()
	//Não migrar para FK´s trecho de execução de ponto de entrada padrão
	aAdd(aRecnos, oModelBxR:GetValue( "MASTER", "E5_RECNO" ))
	For nX := 1 To Len( aRecnos )
		SE5->( DbGoto( aRecnos[nX] ) )
		ExecBlock('SE5FI070',.f.,.F.)
	Next nX
Endif

//Gravação do campos do template GEM
If ExistTemplate("GEMSE5Grv")
	SE5->( DbGoto(oModelBxR:GetValue( "MASTER", "E5_RECNO" )))
	ExecTemplate("GEMSE5Grv",.F.,.F.)
EndIf

oModelBxR:DeActivate()//Static, não Destroy aqui

DesFK6Recs()

If ValType(oModelBxRA) != 'U'
	oModelBxRA:DeActivate()
	oModelBxRA:Destroy()
	oModelBxRA := Nil
EndIf

dbSetOrder( 1 )
dbSelectArea(cAlias)

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070GRVSE5

Grava movimento de baixa CR (SE5).
Arquivo anterior: FINXATU.PRX

@Author	Claudio D. de Souza
@since	05/11/2003
/*/
//-----------------------------------------------------------------------------------------------------
Function Fa070GrvSe5(cBanco, cAgencia, cConta, dBaixa, nValor, lPadrao, lContabiliza, cTpDoc, cHistMov, cLoteFin,;
					 cMotBx, nValEstrang, cSequencia, lSpbInUse, cModSpb, dDtCredito, cArqEnt, cOcorr, nTxMoeda, i,;
					 nJuros, nMulta, nCm, nDescont, aBaixas, cRecPag, nSomaCheq, oModelBxR, oModelBxRA, cProc,;
					 cChaveSEF, cCamposE5, nVa, nValCalc, cFormPagto, lMultNat, aMotRet, lPccMR, lIrfMR, lInsMR,;
					 lIssMR, lImpMR, cNumChq, aTitCalc, cSituaCob, lPIX)

Local nRetencao		:= SA6->A6_RETENCA
Local dDataDisp		:= cToD("  /  /  ") 
Local nCont			:= 0

//Controla o Pis Cofins e Csll na baixa (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default))
Local lPccBxCr		:= FPccBxCr(.T.)
//Controla IRPJ na baixa
Local lIrPjBxCr		:= FIrPjBxCr(.T.)
Local cModRetPIS	:= SA1->A1_ABATIMP
Local nVlMinImp		:= GetNewPar("MV_VL10925",5000)
Local lAplVlMin		:= .T.
Local nBaseRet		:= 0  //Base de retencao
Local nLoop			:= 0

Local lFa070Tit		:= FwIsInCallStack("Fa070Tit")

//639.04 Base Impostos diferenciada
Local lBaseImp		:= F040BSIMP(2)
Local nPropPcc		:= 0
Local lTemMovCh		:= .F.
Local nPropPr		:= 0
Local lTpDesc		:= cPaisLoc == 'BRA' //Verifica campo TPDESC na tabela SE5 (<C>ondicional ou <I>ncondicional)
Local lDescFULL 	:= (nDescont > 0) .and. (nValor == 0) .and. (cTpDoc == "VL") //trato baixa 100% com desconto para gerar registro do tipo VL igual a E5_VALOR zerado!

//***Reestruturacao SE5***
Local oSubFK1
Local oSubFK3
Local oSubFK4
Local oSubFK5
Local oSubFK6
Local oSubFK7
Local oSubFKA
Local oSubFK9
Local oSubFKAux
Local nTxMoedAux	:= 0
Local nJurAux		:= 0
Local nMulAux		:= 0
Local nDesAux		:= 0
Local nValM2Aux		:= 0
Local nX			:= 0
Local cIdFK1		:= FWUUIDV4()
Local cChaveTit		:= ''
Local aImpostos		:= {}
Local aAreaAnt		:= {}
Local oModelMov 	:= NIL	//FWLoadModel("FINM030") 	//Model de Movimento bancario
Local oSubFKAMV
Local oSubFK5MV
Local oSubFK9MV
Local lMovCh		:= FwIsInCallStack("FINA191")
Local cCamposE5M	:= ""
Local cCheque		:= IIf(!Empty(SEF->EF_NUM),SEF->EF_NUM,'')
Local cIdDoc		:= ''
Local cIdFK4		:= ''
Local cIdFk4IR		:= ''
Local lFin70		:= ( FwIsInCallStack("FINA070") .Or. FwIsInCallStack("FINA740") ) .And. !FwIsInCallStack("FINA200") .And. !FwIsInCallStack("FIN892Proc")
Local nRecSE5		:= 0
Local lImpBxCr		:= GetNewPar( "MV_IMPBXCR", "1" ) == "2"
Local nY			:= 0
Local cOrigFK		:= Padr( FunName(), __nTmFKOri )
Local lMotorRet		:= .F.
Local cFilOriTit	:= ""
Local lFina415		:= (FwIsInCallStack("FINA415")) 

Private aDocAux     := {}

//***Reestruturacao SE5***
PRIVATE lRaRtImp  	:= FRaRtImp()     //Define se ha retencao de impostos PCC/IRPJ no R.A

Default cRecPag		:= "R"
Default nSomaCheq 	:= 0
Default cProc		:= 0 //Codigo do Processo Financeiro
Default cLoteFin	:= ""
Default cProc		:= ''
Default cChaveSEF	:= ''
Default cCamposE5	:= ''
Default nVA			:= 0			//Valores Acessorios
Default nValCalc	:= nValor
Default cFormPagto	:= ''
Default lMultNat	:= .F.
Default aMotRet		:= {}
Default cNumChq		:= ''
Default aTitCalc	:= {}
Default cSituaCob   := "0"
Default lPIX		:= .F.
Default nMoedaBco   := NIL

lMotorRet	:= Len(aMotRet) > 0

If lFin70
	Default cTpDesc := "C"
Endif
If Type("lMonedaC") == "U"
	Private lMonedaC := .F.
Endif
If __nTamHist==Nil .Or. __nTamCNAB==Nil
	__nTamHist	:= TamSX3("FK5_HISTOR")[1]
 	__nTamCNAB	:= TamSx3("FK1_ARCNAB")[1]
EndIF
If __MV_IRF==Nil .Or. __MV_PISNAT==Nil
	__MV_IRF	:=&(SuperGetMV("MV_IRF"))
	__MV_PISNAT	:=SuperGetMV("MV_PISNAT")
	__MV_COFINS	:=SuperGetMV("MV_COFINS")
	__MV_CSLL	:=SuperGetMV("MV_CSLL")
EndIF
If __cSldBxCr==Nil
	__cSldBxCr := SuperGetMv("MV_SLDBXCR",,"B")
EndIF

lTemMovCh	:= IIF( lFin70 .And. lFa070Tit, ((nValRec-nSomaCheq)==0 .And. __cSldBxCr == "C"), .f. )

nVlRetPis	:= Iif(Type("nVlRetPis") != "N",0,nVlRetPis)
nVlRetCof	:= Iif(Type("nVlRetCof") != "N",0,nVlRetCof)
nVlRetCsl	:= Iif(Type("nVlRetCsl") != "N",0,nVlRetCsl)

nPis		:= If(Type("nPis"   ) != "N",0,nPis)
nCofins		:= If(Type("nCofins") != "N",0,nCofins)
nCsll	   	:= If(Type("nCsll"  ) != "N",0,nCsll)
nIrrf	   	:= If(Type("nIrrf"  ) != "N",0,nIrrf)
nIss	   	:= If(Type("nIss"  ) != "N",0,nIss)
nOldIrrf 	:= If(Type("nOldIrrf" ) != "N",0,nOldIrrf)
nValRec	   	:= If(Type("nValRec") != "N",0,nValRec)
nTotAbat	:= If(Type("nTotAbat") != "N",0,nTotAbat)
cNumBor		:= If(Type("cNumBor") != "C",Space(6),cNumBor)

nPisCalc	:= Iif(Type("nPisCalc")  != "N",0,nPisCalc)
nCofCalc	:= Iif(Type("nCofCalc")  != "N",0,nCofCalc)
nCslcalc	:= Iif(Type("nCslcalc")  != "N",0,nCslcalc)
nIrfCalc	:= Iif(Type("nIrfCalc")  != "N",0,nIrfCalc)
nPisBaseC	:= Iif(Type("nPisBaseC") != "N",0,nPisBaseC)
nCofBaseC	:= Iif(Type("nCofBaseC") != "N",0,nCofBaseC)
nCslBaseC	:= Iif(Type("nCslBaseC") != "N",0,nCslBaseC)
nIrfBaseC	:= Iif(Type("nIrfBaseC") != "N",0,nIrfBaseC)
nPisBaseR	:= Iif(Type("nPisBaseR") != "N",0,nPisBaseR)
nCofBaseR	:= Iif(Type("nCofBaseR") != "N",0,nCofBaseR)
nCslBaseR	:= Iif(Type("nCslBaseR") != "N",0,nCslBaseR)
nIrfBaseR	:= Iif(Type("nIrfBaseR") != "N",0,nIrfBaseR)
lAlterImp	:= Iif(Type("lAlterImp") != "L",.F.,lAlterImp)
nOldPis     := Iif(Type("nOldPis")  != "N",0,nOldPis)
nOldCofins	:= Iif(Type("nOldCofins")  != "N",0,nOldCofins)
nOldCsll	:= Iif(Type("nOldCsll")  != "N",0,nOldCsll)

nAcresc		:= Iif(Type("nAcresc")  != "N",0,nAcresc)
nAcrescf	:= Iif(Type("nAcrescf") != "N",0,nAcrescf)

If Type("aDadosRet") != "A" .or. Empty(aDadosRet)
	aDadosRet := Array(7)
	AFill( aDadosRet, 0 )
Endif

If lPccBxCr .and. dDataBase >= dLastPcc
	nVlMinImp	:= 0
EndIf

//Verificar ou nao o limite de 5000 para Pis cofins Csll
// 1 = Verifica o valor minimo de retencao
// 2 = Nao verifica o valor minimo de retencao
If SE1->E1_APLVLMN == "2"
	lAplVlMin := .F.
Endif

nBaseRet := nValRec + nPis + nCofins + nCsll + nIrrf + nDescont + nTotAbat - nJuros - nVA - nMulta

//639.04 Base Impostos diferenciada
If lBaseImp .and. SE1->E1_BASEPIS > 0
	nPropPcc := nBaseRet/SE1->E1_VALOR
	nBaseRet	:= SE1->E1_BASEPIS * nPropPcc
Endif

If lFin70 .AND. cTpDoc <> "VL"
	If ( nValor == 0 .And. !( nTotAbat == nValTot ) ) .or. ( nValor == 0 .and. !( nDescont == nValTot ) )
		If (!lDescFULL .Or. nDescont == nValTot) .And. (TrazCodMot(cMotBx) $ "DAC" .And. cTpDoc != "BA")
			Return
		Endif
	EndIf
EndIf

If i == 1 .and. (( cPaisLoc == "BRA" .AND. (lIrPjBxCr .or. lPCCBxCR .or. lMotorRet) ) .OR. ( FXMultSld() .AND. lPCCBxCR .AND. SA6->A6_MOEDA <= 1 ))  
    If !FwisInCallStack("Fa450CMP") .and. lPCCBxCR
        nValor -= (nPis + nCofins + nCsll)
    EndIf
    If lIrPjBxCr .and. nIrrf > 0 
        nValor -= nIrrf
    EndIf

    If lImpMR
        nValor -= nlImpMR
    Endif
EndIf

dbSelectArea("SA6")
SA6->( msSeek(xFilial("SA6")+cBanco+cAgencia+cConta) )
dbSelectArea("SE5")

cHistMov :=  Left(cHistMov, __nTamHist)

If !(i == 0 .And. lMovCh)
	oSubFK1 := oModelBxR:GetModel('FK1DETAIL') //BAIXAS A RECEBER
	oSubFK3 := oModelBxR:GetModel('FK3DETAIL') //IMPOSTOS CALCULADOS
	oSubFK4 := oModelBxR:GetModel('FK4DETAIL') //IMPOSTOS RETIDOS
	oSubFK5 := oModelBxR:GetModel('FK5DETAIL') //MOVTO BANCARIO
	oSubFK6 := oModelBxR:GetModel('FK6DETAIL') //VALORES ACESSORIOS
	oSubFK7 := oModelBxR:GetModel('FK7DETAIL') //CONTROLE DOCTOS
	oSubFKA := oModelBxR:GetModel('FKADETAIL')
	oSubFK9 := oModelBxR:GetModel('FK9DETAIL')
	//Valida a existência da FK0 - Impostos Retidos
	If __lTemFK0 == NIL
		__lTemFK0 := AliasInDic("FK0")
	EndIF

	If __lTemFK0
		oSubFK0 := oModelBxR:GetModel("FK0DETAIL")
	Endif
EndIf

//Gravo aqui somente se o TipoDoc for igual a 'BA', 'VL' ou 'V2'
If i == 1 .Or. i == 2
	//Para movimentos de baixa e movimentos gerados em separado (localizações - movimentos N-N)
	//O número do processo deve ser o mesmo
	If cProc <> ""
		oModelBxR:SetValue( "MASTER", "IDPROC", cProc )
		oModelBxR:SetValue( "MASTER", "NOVOPROC", .F. ) //Informa que a inclusão não será feita com um novo número de processo
	Endif
	//Relacionamento FKA X FK1
	If !oSubFKA:IsEmpty()
		//Inclui a quantidade de linhas necessárias
		oSubFKA:AddLine()
		//Vai para linha criada
		oSubFKA:GoLine(oSubFKA:Length())
	EndIf

	oSubFKA:SetValue('FKA_IDORIG',cIdFK1)
	oSubFKA:SetValue('FKA_TABORI','FK1')

	//Caso seja PIX realiza a gravação do campo FK1_IDFK1
	If lPIX
		FGrvBxPIX(cIdFK1)
	EndIf

	If !Empty(cCamposE5)
		cCamposE5 += "|"
	Endif

	//Define os campos que não existem nas FKs e que serão gravados apenas na E5, para que a gravação da E5 continue igual
	If Empty(cCamposE5) .or. substr(cCamposE5,len(cCamposE5),1) == "|"
	    cCamposE5 += "{"
	Else
		cCamposE5 += ","
	Endif
	//Gravacao dos campos que nao estao no de/para do model
	cCamposE5 += " {'E5_BANCO','" + cBanco + "'}"
	cCamposE5 += ",{'E5_AGENCIA','" + cAgencia + "'}"
	cCamposE5 += ",{'E5_CONTA','" + cConta + "'}"
	cCamposE5 += ",{'E5_FORMAPG','" + cFormPagto + "'}"

	//Comeco a gravacao dos valores no submodel FK1
	oSubFK1:SetValue('FK1_DATA',dBaixa)
	oSubFK1:SetValue('FK1_ORIGEM',cOrigFK)

	nTxMoedAux := IIf(Type("aTxMoedas") == "A" .And. cPaisLoc <> 'BRA' .and. nTxMoeda == 0 ,aTxMoedas[nMoedaBco][2],nTxMoeda)
	
	If cPaisLoc <> "BRA"
		If !(TrazCodMot(cMotBx) $ "DAC") .And. !(lFina415 .And. cPaisLoc $ "PER")
			If Empty(cBanco+cAgencia+cConta) .And. !Empty(SE1->E1_RECIBO) .and. !lMonedaC 
				nMoedaBco	:= Max( SE1->E1_MOEDA, 1)
				nValor		:= Round(xMoeda(nValor,1,nMoedaBco,dbaixa,4,1,nTxMoedAux),2)
			ElseIf Empty(SA6->A6_MOEDA) 
				nMoedaBco	:= nTxMoedAux	:= nTxMoeda := 1
			Else
				nMoedaBco := Max( SA6->A6_MOEDA, 1)
			EndIf
		Else
			nMoedaBco := 1
		Endif		       
		If cPaisLoc $ "PER" .And. lFina415 .And. nMoedaBco <> SE1->E1_MOEDA
			nMoedaBco := SE1->E1_MOEDA
		EndIf	
	Else
		If MovBcobx(cMotBx, .T.)
			If Empty(SA6->A6_MOEDA)
				nMoedaBco	:= nTxMoedAux	:= nTxMoeda := 1
			Else 
				nMoedaBco := Max( SA6->A6_MOEDA, 1)
			EndIf
		Else
			nMoedaBco := 1
		Endif		
	EndIf

	If cPaisLoc <> "BRA" .and. FunName() != "FINA846"
		If ( Empty(cBanco+cAgencia+cConta) .And. !Empty(SE1->E1_RECIBO) ) .Or. Empty(SA6->A6_MOEDA) .Or. lFina415
			If cPaisLoc == "PER" .And. lFina415
				nTxMoedAux := SE1->E1_TXMOEDA
			Else
				nTxMoedAux := RecMoeda(dBaixa,SE1->E1_MOEDA)
			EndIf
		ElseIf nMoedaBco == 1 .And. SE1->E1_MOEDA == 1
			nTxMoedAux := 1
        ElseIf nMoedaBco > 1 .AND. SE1->E1_MOEDA = 1
            nTxMoedAux := RecMoeda(dBaixa,nMoedaBco)
		ElseIf SE1->E1_MOEDA > 1 .And. SE1->E1_TXMOEDA > 0   
			nTxMoedAux := SE1->E1_TXMOEDA
        Else
            nTxMoedAux := RecMoeda(dBaixa,SE1->E1_MOEDA)
        EndIf
	EndIf
	If cPaisLoc == "MEX" .AND. lMonedaC .AND. FindFunction("fn450AsgMn")
		fn450AsgMn(@nMoedaBco,@nTxMoeda,@nTxMoedAux )
	EndIf
    oSubFK1:SetValue('FK1_TXMOED',nTxMoedAux)
    oSubFK1:SetValue('FK1_VALOR',nValor)
    oSubFK1:SetValue('FK1_MOEDA',StrZero(Max(nMoedaBco,1),2))

	// Grava o valor de correção monetária no SE5 para ser visualizado na consulta
	If cPaisLoc == "MEX" .And. SEL->EL_MOEDA <> "1" .And. FunName() $ "FINA087A|FINA887"
		nTxCor:= Iif(SE1->E1_TXMOEDA > 0, SE1->E1_TXMOEDA, RecMoeda(SE1->E1_EMISSAO, SE1->E1_MOEDA))
		nValOrig:= xMoeda(SEL->EL_VALOR,Val(SEL->EL_MOEDA),1,,,nTxCor)
		nValAtu:= xMoeda(SEL->EL_VALOR,Val(SEL->EL_MOEDA),1,,,FK5->FK5_TXMOED) 
		cCamposE5 += ",{'E5_VLCORRE'," + Str(nValAtu - nValOrig) + "}"
	EndIf

	cCamposE5 += ",{'E5_TIPO'		,'" + SE1->E1_TIPO + "'}"
	cCamposE5 += ",{'E5_PREFIXO'	,'" + SE1->E1_PREFIXO + "'}"
	cCamposE5 += ",{'E5_NUMERO'		,'" + SE1->E1_NUM + "'}"
	cCamposE5 += ",{'E5_PARCELA'	,'" + SE1->E1_PARCELA + "'}"
	cCamposE5 += ",{'E5_CLIFOR'		,'" + SE1->E1_CLIENTE + "'}"
	cCamposE5 += ",{'E5_CLIENTE'	,'" + SE1->E1_CLIENTE + "'}"
	cCamposE5 += ",{'E5_LOJA'		,'" + SE1->E1_LOJA + "'}"
	cCamposE5 += ",{'E5_BENEF'		,'" + RemoveAsp(SE1->E1_NOMCLI) + "'}"
	cCamposE5 += ",{'E5_MULTNAT'	,'" + If(lMultNat,"1","2") + "'}"
	cCamposE5 += ",{'E5_DTDIGIT'	,STOD('" +  DTOS(dDataBase) + "')}"
	cCamposE5 += ",{'E5_NUMCHEQ'	, '" + cNumChq + "'}"

	oSubFK1:LoadValue('FK1_NATURE',SE1->E1_NATUREZ)
	oSubFK1:SetValue('FK1_RECPAG',cRecPag)
	oSubFK1:SetValue('FK1_LA',Iif(lPadrao .And. lContabiliza,"S","N"))
	oSubFK1:SetValue('FK1_TPDOC',cTpDoc)
	oSubFK1:SetValue('FK1_HISTOR',cHistMov)
	oSubFK1:SetValue('FK1_LOTE',cLoteFin)
	oSubFK1:SetValue('FK1_MOTBX',TrazCodMot(cMotBx))
	oSubFK1:SetValue('FK1_SERREC',SE1->E1_SERREC)
	    If  cPaisLoc == "RUS" .and. (Type("cOrdPag") <> "U" .AND. !Empty(cOrdPag))//Used to link the write-off to that specific account receivables/BS document.
        oSubFK1:SetValue( "FK1_ORDREC"   , cOrdPag )
        cCamposE5 += ",{'E5_ORDREC'   , '"+cOrdPag   +"' }"
    Else
		oSubFK1:SetValue('FK1_ORDREC',SE1->E1_RECIBO)
	EndIf
	oSubFK1:SetValue('FK1_FILORI',SE1->E1_FILORIG)
	oSubFK1:SetValue('FK1_CCUSTO',SE1->E1_CCUSTO)
	oSubFK1:SetValue('FK1_VENCTO',SE1->E1_VENCTO)
	oSubFK1:SetValue('FK1_MULNAT', If(lMultNat,"1","2"))

	If cSituaCob == "0" .And. lFin70  .And. lTpDesc
		cCamposE5 += ",{'E5_TPDESC','" + cTpDesc + "'}"
	Endif

	If (SE1->E1_MOEDA > 1 .OR. (SE1->E1_MOEDA == 1  .And. nMoedaBco > 0) ) .And. nValEstrang !=0 // somente para VL/BA
		nValM2Aux := nValEstrang
    Else
		If (SE1->E1_MOEDA == 1  .And. nMoedaBco > 0) .Or. lFina415
			nValM2Aux := Round(xMoeda(nValor,nMoedaBco,SE1->E1_MOEDA,dbaixa,4,nTxMoeda,SE1->E1_TXMOEDA),2)
		Else
			nValM2Aux := Iif(SE1->E1_MOEDA <= 1,Round(xMoeda(nValor,SE1->E1_MOEDA,nMoedaBco,dbaixa,4,SE1->E1_TXMOEDA,nTxMoeda),2),0)
		EndIf
	EndIf
	If cPaisLoc == "MEX" .AND.  lMonedaC .AND. FindFunction("fn450Fk1")
		fn450Fk1(@oSubFK1,nValor,SE1->E1_MOEDA,nMoedaBco, nTxMoeda)
	Else
		oSubFK1:SetValue('FK1_VLMOE2',nValM2Aux)
	EndIf

    oSubFK1:SetValue('FK1_SEQ',cSequencia)

	If cPaisLoc == "MEX" .and. FunName() $ "FINA087A|MATA465N"
		If Len(aDocAux) == 0
			For nY := 1 To Len(aDocument)	
				aAdd(aDocAux,{aDocument[nY,1], aDocument[nY,2], aDocument[nY,3], aDocument[nY,4], .F.})
			Next nY
		EndIf
		If !Empty(SE1->E1_NUM) .and. (Empty(cNumBor))
			For nY := 1 To Len(aDocAux)
				If Alltrim(aDocAux[nY,2]) $ cTipDocRA .AND. !(aDocAux[nY,4]) .AND.  SE1->E1_TIPO <> aDocAux[nY,2] .And. !aDocAux[nY,5]
					cCamposE5 += ",{'E5_DOCUMEN','" + aDocAux[nY,1] + "'}"
					aDocAux[nY,5] := .T.
					Exit
				ElseIf !(Alltrim(aDocAux[nY,2]) $ cTipDocRA) .AND. aDocAux[nY,4] .AND. SE1->E1_TIPO <> aDocAux[nY,2] .And. !aDocAux[nY,5]
					cCamposE5 += ",{'E5_DOCUMEN','" + aDocAux[nY,1] + "'}"
					aDocAux[nY,5] := .T.
					Exit
				EndIf
			Next
		EndIf
	EndIf

	If !(Empty(cNumBor)) // FINA200 - CNAB
		cCamposE5 += ",{'E5_DOCUMEN','" + cNumBor + "'}"
	EndIf

	//	Data de disponibilizacao -> considera dias de retencao
	nRetencao := SA6->A6_RETENCA
	dDataDisp := dBaixa

	If i == 1 .And. nCM <> 0
		If cPaisLoc == "MEX" .AND.  lMonedaC .AND. FindFunction("fn450CmMon")
			nCm := fn450CmMon(nCm,SE1->E1_MOEDA,nMoedaBco, nTxMoeda)
		EndIf
		cCamposE5 += ",{'E5_VLCORRE'," + Str(nCm) + "}"
	Endif

	If nRetencao > 0
		For nCont := 1 To nRetencao
			dDataDisp := DataValida(dDataDisp+1,.T.)
		Next nCont
	EndIf

	dDataAux := IIf(Empty(dDtCredito),dDataDisp,dDtCRedito)

	cCamposE5 += ",{'E5_DTDISPO',STOD('" + DTOS(dDataAux) + "') }"

	oSubFK1:SetValue('FK1_ARCNAB', Pad(cArqEnt,__nTamCNAB))
	oSubFK1:SetValue('FK1_CNABOC', cOcorr)
	oSubFK1:SetValue('FK1_SITCOB', Iif(cSituaCob == "0", SE1->E1_SITUACA, cSituaCob))
	
	//Dados da tabela auxiliar com o código do título a pagar
	cFilOriTit	:= xFilial("SE1", SE1->E1_FILORIG)
	cChaveTit 	:= cFilOriTit + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
	cIdDoc 		:= FINGRVFK7("SE1", cChaveTit)

	oSubFK1:SetValue("FK1_IDDOC",cIdDoc)

	// Grava valores quando o valor a receber for o mesmo que o do cheque, e a movimentação apenas quando o cheque for compensado
	If i == 2 .And. cPaisLoc == "BRA"
		cCamposE5 += ",{'E5_VLJUROS'," + Str(nJuros) + "}"
		cCamposE5 += ",{'E5_VLMULTA'," + Str(nMulta) + "}"
		cCamposE5 += ",{'E5_VLDESCO'," + Str(nDescont) + "}"
	EndIf
	
	If i == 1
		If cPaisLoc == "BRA"
			nJurAux := nJuros
			nMulAux := nMulta
			nDesAux := nDescont
		Else
			 If cPaisLoc == "MEX" .AND.  lMonedaC .AND. FindFunction("Fn450VlAux")
			 	Fn450VlAux(@nJurAux,@nMulAux,@nDesAux)
			 Else 
				nJurAux := Round(NoRound(xMoeda(nJuros,1,nMoedaBco,dBaixa,3,nTxMoedAux),3),2)
				nMulAux := Round(NoRound(xMoeda(nMulta,1,nMoedaBco,dBaixa,3,nTxMoedAux),3),2)
				nDesAux := Round(NoRound(xMoeda(nDescont,1,nMoedaBco,dBaixa,3,,nTxMoedAux),3),2)
			EndIf
		Endif

		cCamposE5 += ",{'E5_VLJUROS'," + Str(nJurAux) + "}"
		cCamposE5 += ",{'E5_VLMULTA'," + Str(nMulAux) + "}"
		cCamposE5 += ",{'E5_VLDESCO'," + Str(nDesAux) + "}"
		cCamposE5 += ",{'E5_VLACRES'," + Str(Round(NoRound(nAcresc,3),2)) +"}"
		cCamposE5 += ",{'E5_VLDECRE'," + Str(Round(NoRound(xMoeda(SE1->E1_SDDECRE,SE1->E1_MOEDA,nMoedaBco,dBaixa,3,SE1->E1_TXMOEDA),3),2)) +"}"

	    IF lRaRtImp .And. lFin70 .And. nTotAbat < (nTotAbImp-nTotAbLiq)
	    	nPropPr:= nTotAbat/(nTotAbImp-nTotAbLiq)
	    	cCamposE5 += ",{'E5_PRINSS'," + Str(SE1->E1_INSS * nPropPr) + "}"
	    	cCamposE5 += ",{'E5_PRISS'," + Str(SE1->E1_ISS * nPropPr) + "}"
		Endif

		//PCC BAIXA CR
		//GRAVACAO SFQ
		If lFa070Imp .and. lF070Imp2 .and. lImpBxCr
			If nOldIrrf == 0 .and. nIrrf > 0
				nIrfBaseC	:= nValor
				nIrfBaseR	:= nValor
			EndIf
			If nOldPis == 0 .and. nPis > 0
				nPisBaseC	:= nValor
				nPisBaseR	:= nValor
			EndIf
			If nOldCofins == 0 .and. nCofins > 0
				nCofBaseC	:= nValor
				nCofBaseR	:= nValor
			EndIf
			If nOldCsll == 0 .and. nCsll > 0
				nCslBaseC	:= nValor
				nCslBaseR	:= nValor
			EndIf
        EndIf
        
		If ( cPaisLoc == "BRA" .AND. (lPCCBxCR .or. lIrPjBxCr .or. lMotorRet) ) .OR. ( FXMultSld() .AND. lPCCBxCR .AND. SA6->A6_MOEDA <= 1 )

			oSubFK1:SetValue('FK1_VALOR', nValor)

			//Grava os campos de valores e base de retenção dos impostos							
			cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nPis)+" }"
			cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nCofins)+" }"
			cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nCsll)+" }"
			cCamposE5 += ",{'E5_VRETIRF' , "+cValToChar(nIrrf)+" }"
			cCamposE5 += ",{'E5_VRETISS' , "+cValToChar(nIss)+" }"

			//Na SE5 grava o valor da base do título e não a base total da retenção
			cCamposE5 += ",{'E5_BASEIRF' , "+cValToChar(nIrfBaseC)+" }"

			//Pendência de retenção
			If nIrfCalc > 0 .and. nIrrf == 0 
				cCamposE5 += ",{'E5_PRETIRF' , '1' }"
			Endif

			// Atualiza variaveis de retencao caso retencao ocorreu via Motor de Retencoes
			lPccBaixa := IiF( lPccMR, .T., lPccBaixa)
			lIRPFBaixa := IiF( lIrfMR, .T., lIRPFBaixa)
			lCalcIssBx := IiF( lIssMR, .T., lCalcIssBx)
			lInssBx := IiF( lInsMR, .T., Iif(Type("lInssBx") == "U", .F.,lInssBx) )

			//***Reestruturacao SE5***
			// Grava os valores agregados ao titulo no totalizador
			//aImpostos[1] = tipo do imposto
			//aImpostos[2] = imposto calculado
			//aImpostos[3] = natureza
			//aImpostos[4] = cIdFK4
			//aImpostos[5] = imposto retido
			//aImpostos[6] = base calculado
			//aImpostos[7] = base retencao
			//aImpostos[8] = codigo FKM(Tipo de retencao)

			// Gravacoes do Calculo de Retencoes FK3/FK4 - Motor de Retencoes
			If lMotorRet
				For nX := 1 To Len(aMotRet)
					aAdd(aImpostos,{aMotRet[nX,8], aMotRet[nX,3], aMotRet[nX,10],"", aMotRet[nX,5], aMotRet[nX,2], aMotRet[nX,4], aMotRet[nX,1], "M"})
				Next nX
				If !lPccMR
					aadd(aImpostos,{"PIS", nPisCalc ,__MV_PISNAT	,"", nPis    , nPisBaseC, nPisBaseR,"",""})
					aadd(aImpostos,{"COF", nCofCalc ,__MV_COFINS	,"", nCofins , nCofBaseC, nCofBaseR,"",""})
					aadd(aImpostos,{"CSL", nCslcalc ,__MV_CSLL		,"", nCsll   , nCslBaseC, nCslBaseR,"",""})
				ElseIf !lIrfMR
					If nIrrf > 0 .and. lIrPjBxCr
						nIrfCalc := If (nIrfCalc == 0, SE1->E1_VRETIRF, nIrfCalc)
						If nIrfBaseR == 0 .or. nIrfBaseC == 0
							nIrfBaseC := nIrfBaseR := SE1->E1_BASEIRF
						EndIf
					Endif
					aadd(aImpostos,{"IRF", nIrfCalc, __MV_IRF	,"", nIrrf, nIrfBaseC, nIrfBaseR,"",""})
				Endif
			Else
				If nIrrf > 0 .and. lIrPjBxCr
					nIrfCalc := If (nIrfCalc == 0, SE1->E1_VRETIRF, nIrfCalc)
					If nIrfBaseR == 0 .or. nIrfBaseC == 0
						nIrfBaseC := nIrfBaseR := SE1->E1_BASEIRF
					EndIf
				Endif

				aadd(aImpostos,{"IRF", nIrfCalc	,__MV_IRF		,"", nIrrf    , nIrfBaseC, nIrfBaseR,""})
				aadd(aImpostos,{"PIS", nPisCalc ,__MV_PISNAT	,"", nPis    , nPisBaseC, nPisBaseR,""})
				aadd(aImpostos,{"COF", nCofCalc ,__MV_COFINS	,"", nCofins , nCofBaseC, nCofBaseR,""})
				aadd(aImpostos,{"CSL", nCslcalc ,__MV_CSLL		,"", nCsll   , nCslBaseC, nCslBaseR,""})
			EndIf
			
			//Grava FK3 E/OU FK4
			For nX := 1 to Len(aImpostos)				
				If aImpostos[nX][2] > 0 //Gravar FK4 se os valores de PCC forem maiores que zero
					cIdFK4 := ""
					
					If aImpostos[nX][5] > 0 //Houve retencao
						cIdFK4:= FINFKSID('FK4', 'FK4_IDFK4')
						aImpostos[nX,4] := cIdFK4
						
						If lMotorRet .And. aImpostos[nX][9] == "M"
							aMotRet[nX,6] := cIdFK4
						EndIf
						
						//Guardo o IDFK4 do IRF para usar posteriormente
						If aImpostos[nX,1] == "IRF"
							cIdFk4IR := cIdFK4
						Endif
					Endif
					
					If !oSubFK3:IsEmpty()
						oSubFK3:AddLine()
						oSubFK3:GoLine( oSubFK3:Length() )
					Endif
					
					//Grava Imposto calculado
					oSubFK3:SetValue("FK3_IDFK3" , FINFKSID("FK3", "FK3_IDFK3"))
					oSubFK3:SetValue("FK3_DATA"  , dDataBase )
					oSubFK3:SetValue("FK3_ORIGEM", cOrigFK )
					oSubFK3:SetValue("FK3_IMPOS" , aImpostos[nX][1] )
					oSubFK3:SetValue("FK3_RECPAG", "R" )
					oSubFK3:SetValue("FK3_MOEDA" , "01" )
					oSubFK3:SetValue("FK3_VALOR" , aImpostos[nX][2] )
					oSubFK3:SetValue("FK3_NATURE", PadR(AllTrim(aImpostos[nX][3]),LEN(SED->ED_CODIGO)," ") )
					oSubFK3:SetValue("FK3_FILORI", SE1->E1_FILORIG  )
					oSubFK3:SetValue("FK3_BASIMP", aImpostos[nX][6] )
					oSubFK3:SetValue("FK3_IDORIG", cIdFK1 )
					oSubFK3:SetValue("FK3_TABORI", "FK1")
					oSubFK3:SetValue("FK3_IDRET" , aImpostos[nx,4] )
                    
					If __lTemFK0
						oSubFK3:SetValue( "FK3_CODFKM", aImpostos[nX,8] )
						oSubFK3:SetValue( "FK3_CLIFOR", SA1->A1_COD )
						oSubFK3:SetValue( "FK3_LOJA"  , SA1->A1_LOJA )
						oSubFK3:SetValue( "FK3_CGC"   , SA1->A1_CGC )
						oSubFK3:SetValue( "FK3_RAICGC", Substr(SA1->A1_CGC, 1, 8) )
                    Endif
					
					//Grava Imposto Retido
					If aImpostos[nX][5] > 0   //Houve retencao
						If !oSubFK4:IsEmpty()
							oSubFK4:AddLine()
							oSubFK4:GoLine( oSubFK4:Length() )
						Endif
						
						oSubFK4:SetValue( "FK4_IDFK4" , aImpostos[nx,4])
						oSubFK4:SetValue( "FK4_DATA"  , dDataBase )
						oSubFK4:SetValue( "FK4_ORIGEM", cOrigFK )
						oSubFK4:SetValue( "FK4_IMPOS" , aImpostos[nX,1] )
						oSubFK4:SetValue( "FK4_RECPAG", "R" )
						oSubFK4:SetValue( "FK4_MOEDA" , "01" )
						oSubFK4:SetValue( "FK4_VALOR" , aImpostos[nX,5] )
						oSubFK4:SetValue( "FK4_NATURE", PadR(AllTrim(aImpostos[nX][3]),LEN(SED->ED_CODIGO)," ") )
						oSubFK4:SetValue( "FK4_FILORI", SE1->E1_FILORIG )
						oSubFK4:SetValue( "FK4_BASIMP", aImpostos[nX][7] )
						
						If __lTemFK0
							oSubFK4:SetValue( "FK4_CODFKM", aImpostos[nX,8] )
							oSubFK4:SetValue( "FK4_CLIFOR", SA1->A1_COD )
							oSubFK4:SetValue( "FK4_LOJA"  , SA1->A1_LOJA )
							oSubFK4:SetValue( "FK4_CGC"   , SA1->A1_CGC )
							oSubFK4:SetValue( "FK4_RAICGC", Substr(SA1->A1_CGC, 1, 8) )
							
							//Atualizacao de retencao da FK3 - Cumulatividade
							If lMotorRet .And. aImpostos[nX][9] == "M" .And. Len(aMotRet[nX,7]) > 0 .And. aMotRet[nX,7,1] > 0
								FK3->(DbGoTo(aMotRet[nX,7,1]))
								RecLock("FK3")
								FK3->FK3_IDRET := aMotRet[nX,6]
								FK3->(MsUnlock())
							EndIf
						Endif
					Endif
				Endif
			Next nX
			
			//Gravo o relacionamento de retenção dos títulos que tiveram impostos retidos na baixa atual
			FinFk3BCR(aTitCalc, aImpostos)
			
			Do Case
			Case cModRetPIS == "1"
				If	aDadosRet[1] <> NIL .and. (aDadosRet[1] + nBaseRet > nVlMinImp .or. !lAplVlMin .OR. (nPis + nCofins + nCsll > 0 .and. lAlterImp)) .And. (nPis + nCofins + nCsll > 0)
					lRetParc := .T.

					nSavRec := SE5->( Recno() )

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Exclui a Marca de "pendente recolhimento" dos demais registros   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If aDadosRet[1] > 0
						If Type("lAlterImp")!="L"
							lAlterImp := .F.
						EndIf
						aRecnos		:= aClone(Iif(lAlterImp .and. !lPccBxCr,aDadosRet[5],aDadosRet[6]))
						cPrefOri	:= SE1->E1_PREFIXO
						cNumOri		:= SE1->E1_NUM
						cParcOri	:= SE1->E1_PARCELA
						cTipoOri	:= SE1->E1_TIPO
						cCfOri		:= SE1->E1_CLIENTE
						cLojaOri	:= SE1->E1_LOJA

						For nLoop := 1 to Len( aRecnos )

							SE5->( dbGoto( aRecnos[ nLoop ] ) )
							If !Empty(SE5->E5_PRETPIS) .And. !Empty(SE5->E5_PRETCOF) .And. !Empty(SE5->E5_PRETCSL)
								//Atualiza a informação de retencao de impostos em outro titulo
								//Carrego o Model
								aAreaAnt := GetArea()
								oModelBxRA := FWLoadModel("FINM010")
								oModelBxRA:SetOperation( MODEL_OPERATION_UPDATE ) //Alteração
								oModelBxRA:Activate()
								oModelBxRA:SetValue("MASTER","E5_GRV",.T.) //Habilita gravação SE5
								oSubFKAux := oModelBxRA:GetModel("FKADETAIL")
								oSubFKAux:SeekLine({{"FKA_IDORIG",SE5->E5_IDORIG}})

								//Atualizar o status de retencao de impostos
								oSubFK3A := oModelBxRA:GetModel( "FK3DETAIL" )
								For nX := 1 to Len(aImpostos)
									If oSubFK3A:SeekLine({{"FK3_IMPOS",aImpostos[nX,1]}}) //Nome do imposto
										If aImpostos[nX,1] != "IRF"
											oSubFK3A:SetValue("FK3_IDRET",aImpostos[nX,4]) //cIdFk4
										Endif
									Endif
								Next nX

								cCamposE5A := "{{'E5_PRETPIS' , '2'}"
								cCamposE5A += ",{'E5_PRETCOF' , '2'}"
								cCamposE5A += ",{'E5_PRETCSL' , '2'}}"

								oModelBxRA:SetValue("MASTER","E5_CAMPOS",cCamposE5A)
								//Grava os dados
								If oModelBxRA:VldData()
								    oModelBxRA:CommitData()
								Else
									lRet := .F.
								    cLog := cValToChar(oModelBxRA:GetErrorMessage()[4]) + ' - '
								    cLog += cValToChar(oModelBxRA:GetErrorMessage()[5]) + ' - '
								    cLog += cValToChar(oModelBxRA:GetErrorMessage()[6])
									Help( ,,"M010VLDI1",,cLog, 1, 0 )
									Exit
								Endif
								oModelBxRA:DeActivate()
								oModelBxRA:Destroy()
								oModelBxRA:= Nil
								RestArea(aAreaAnt)
							EndIf

							If nSavRec <> aRecnos[ nLoop ]
								dbSelectArea("SFQ")
								RecLock("SFQ",.T.)
								SFQ->FQ_FILIAL  := xFilial("SFQ")
								SFQ->FQ_ENTORI  := "E1B"
								SFQ->FQ_PREFORI := cPrefOri
								SFQ->FQ_NUMORI  := cNumOri
								SFQ->FQ_PARCORI := cParcOri
								SFQ->FQ_TIPOORI := cTipoOri
								SFQ->FQ_CFORI   := cCfOri
								SFQ->FQ_LOJAORI := cLojaOri
								SFQ->FQ_SEQORI  := cSequencia

								SFQ->FQ_ENTDES  := "E1B"
								SFQ->FQ_PREFDES := SE5->E5_PREFIXO
								SFQ->FQ_NUMDES  := SE5->E5_NUMERO
								SFQ->FQ_PARCDES := SE5->E5_PARCELA
								SFQ->FQ_TIPODES := SE5->E5_TIPO
								SFQ->FQ_CFDES   := SE5->E5_CLIFOR
								SFQ->FQ_LOJADES := SE5->E5_LOJA
								SFQ->FQ_SEQDES  := SE5->E5_SEQ

								//Grava a filial de destino caso o campo exista
								SFQ->FQ_FILDES := SE5->E5_FILIAL

								SFQ->(MsUnlock())
							Endif
						Next nLoop
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Retorna do ponteiro do SE1 para a parcela         ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					SE5->( MsGoto( nSavRec ) )

				Else
					If nVlRetPis + nVlRetCof + nVlRetCsl > 0
						//Atualiza a informação de retencao de impostos no titulo que está sendo baixado
						//Carrego o Model
						cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nVlRetPis)+"}"
						cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nVlRetCof)+"}"
						cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nVlRetCsl)+"}"
						cCamposE5 += ",{'E5_PRETPIS' , '1'}"
						cCamposE5 += ",{'E5_PRETCOF' , '1'}"
						cCamposE5 += ",{'E5_PRETCSL' , '1'}"

					EndIf
					lRetParc := .F.
				EndIf

			Case cModRetPIS == "2"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Efetua a retencao                                                 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nSavRec := SE5->( Recno() )

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Exclui a Marca de "pendente recolhimento" dos demais registros   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If aDadosRet[1] > 0
					aRecnos := aClone( Iif(ValType(lAlterImp)!="U" .And. lAlterImp .and. !lPccBxCr,aDadosRet[ 5 ],aDadosRet[ 6 ]) )

					cPrefOri  := SE5->E5_PREFIXO
					cNumOri   := SE5->E5_NUMERO
					cParcOri  := SE5->E5_PARCELA
					cTipoOri  := SE5->E5_TIPO
					cCfOri    := SE5->E5_CLIFOR
					cLojaOri  := SE5->E5_LOJA

				  	For nLoop := 1 to Len( aRecnos )

						SE5->( dbGoto( aRecnos[ nLoop ] ) )

						If !Empty(SE5->E5_PRETPIS) .And. !Empty(SE5->E5_PRETCOF) .And. !Empty(SE5->E5_PRETCSL)
							//Atualiza a informação de retencao de impostos em outro titulo
							//Carrego o Model
							aAreaAnt := GetArea()
							oModelBxRA := FWLoadModel("FINM010")
							oModelBxRA:SetOperation( MODEL_OPERATION_UPDATE ) //Alteração
							oModelBxRA:Activate()
							oModelBxRA:SetValue("MASTER","E5_GRV",.T.) //Habilita gravação SE5
							oSubFKAux := oModelBxRA:GetModel("FKADETAIL")
							oSubFKAux:SeekLine({{"FKA_IDORIG",SE5->E5_IDORIG}})

							//Atualizar o status de retencao de impostos
							oSubFK3A:= oModelBxRA:GetModel( "FK3DETAIL" )
							For nX := 1 to Len(aImpostos)
								If oSubFK3A:SeekLine({{"FK3_IMPOS",aImpostos[nX,1]}}) //Nome do imposto
									If aImpostos[nX,1] != "IRF"
										oSubFK3A:SetValue("FK3_IDRET",aImpostos[nX,4]) //cIdFk4
									Endif
								Endif
							Next nX

							cCamposE5A := "{{'E5_PRETPIS' , '2'}"
							cCamposE5A += ",{'E5_PRETCOF' , '2'}"
							cCamposE5A += ",{'E5_PRETCSL' , '2'}}"

							oModelBxRA:SetValue("MASTER","E5_CAMPOS",cCamposE5A)
							//Grava os dados
							If oModelBxRA:VldData()
							    oModelBxRA:CommitData()
							Else
								lRet := .F.
							    cLog := cValToChar(oModelBxRA:GetErrorMessage()[4]) + ' - '
							    cLog += cValToChar(oModelBxRA:GetErrorMessage()[5]) + ' - '
							    cLog += cValToChar(oModelBxRA:GetErrorMessage()[6])
								Help( ,,"M010VLDI1",,cLog, 1, 0 )
								Exit
							Endif
							oModelBxRA:DeActivate()
							oModelBxRA:Destroy()
							oModelBxRA:= Nil
							RestArea(aAreaAnt)
						EndIf

						If nSavRec <> aRecnos[ nLoop ]
							dbSelectArea("SFQ")
							RecLock("SFQ",.T.)
							SFQ->FQ_FILIAL  := xFilial("SFQ")
							SFQ->FQ_ENTORI  := "E1B"
							SFQ->FQ_PREFORI := cPrefOri
							SFQ->FQ_NUMORI  := cNumOri
							SFQ->FQ_PARCORI := cParcOri
							SFQ->FQ_TIPOORI := cTipoOri
							SFQ->FQ_CFORI   := cCfOri
							SFQ->FQ_LOJAORI := cLojaOri
							SFQ->FQ_SEQORI  := cSequencia

							SFQ->FQ_ENTDES  := "E1B"
							SFQ->FQ_PREFDES := SE5->E5_PREFIXO
							SFQ->FQ_NUMDES  := SE5->E5_NUMERO
							SFQ->FQ_PARCDES := SE5->E5_PARCELA
							SFQ->FQ_TIPODES := SE5->E5_TIPO
							SFQ->FQ_CFDES   := SE5->E5_CLIFOR
							SFQ->FQ_LOJADES := SE5->E5_LOJA
							SFQ->FQ_SEQDES  := SE5->E5_SEQ

							//Grava a filial de destino caso o campo exista
							SFQ->FQ_FILDES := SE5->E5_FILIAL
							SFQ->(MsUnlock())
						Endif
					Next nLoop

				Endif
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Retorna do ponteiro do SE1 para a parcela         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				SE5->( MsGoto( nSavRec ) )
				Reclock( "SE1", .F. )
				lRetParc := .T.
			Case cModRetPIS == "3"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava a Marca de "pendente recolhimento" dos demais registros    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If nVlRetPis + nVlRetCof + nVlRetCsl > 0
					//Atualiza a informação de retencao de impostos no titulo que está sendo baixado
					//Carrego o Model
					cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nVlRetPis)+"}"
					cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nVlRetCof)+"}"
					cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nVlRetCsl)+"}"
					cCamposE5 += ",{'E5_PRETPIS' , '1'}"
					cCamposE5 += ",{'E5_PRETCOF' , '1'}"
					cCamposE5 += ",{'E5_PRETCSL' , '1'}"
				EndIf
				lRetParc := .F.
			EndCase
		EndIf
		
		If cTpDoc $ 'VL'
			//Relacionamento FKA X FK5
			If !oSubFKA:IsEmpty()
				oSubFKA:AddLine()
				oSubFKA:GoLine(oSubFKA:Length())
			EndIf
			
			oSubFKA:SetValue('FKA_IDORIG',FWUUIDV4())
			oSubFKA:SetValue('FKA_TABORI','FK5')
			
			oSubFK5:SetValue( "FK5_RECPAG" , cRecPag )
			oSubFK5:SetValue( "FK5_HISTOR" , cHistMov )
			oSubFK5:SetValue( "FK5_DATA"   , dBaixa )
			oSubFK5:SetValue( "FK5_DTDISP" , dDataAux )
			oSubFK5:LoadValue( "FK5_NATURE" , SE1->E1_NATUREZ )
			oSubFK5:SetValue( "FK5_BANCO"  , cBanco )
			oSubFK5:SetValue( "FK5_AGENCI" , cAgencia )
			oSubFK5:SetValue( "FK5_CONTA"  , cConta )
			oSubFK5:SetValue( "FK5_SEQ"    , cSequencia )
			oSubFK5:SetValue( "FK5_MOEDA"  , StrZero(Max(nMoedaBco,1),2) )
			oSubFK5:SetValue( "FK5_ORIGEM" , cOrigFK )
			oSubFK5:SetValue( "FK5_TPDOC"  , cTpDoc )
			oSubFK5:SetValue( "FK5_CCUSTO" , SE1->E1_CCUSTO )
			oSubFK5:SetValue( "FK5_DOC"    , SE1->E1_NUMBOR )
			oSubFK5:SetValue( "FK5_FILORI" , SE1->E1_FILORIG )
			oSubFK5:SetValue( "FK5_VALOR" , nValor )
			oSubFK5:SetValue( "FK5_VLMOE2" , nValM2Aux )
            oSubFK5:SetValue( "FK5_TXMOED", nTxMoedAux )
            oSubFK5:SetValue( "FK5_MOEDA" , StrZero(nMoedaBco,2) )
            
			// Para baixas STR ou CIP eu ignoro os dias de rentencao, ja que sao on-line
			If lSpbInUse
				oSubFK5:SetValue( "FK5_MODSPB" , cModSpb )

				If cModSpb $ "1#2"
					dDataDisp := dBaixa
				Endif
			Endif

			oSubFK5:SetValue( "FK5_LA" , Iif(lPadrao.and.lContabiliza,"S","N") )

			If !Empty(cFormPagto)
				oSubFK9:SetValue('FK9_FORMPG',cFormPagto)
			EndIf
		EndIf
	EndIf
ElseIf i <> 0 //Gravo os valore acessorios ('D2', 'DC', 'J2', 'JR', 'M2', 'MT', 'C2', 'CM' ou 'TL')
	If __lFinm010
		cCamposE5 += "}"
		oModelBxR:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )
	Endif
	
	If oSubFKA:SeekLine({{'FKA_TABORI',"FK1"}})		
		If cTpDoc == "VA" //Valores Acessorios.
			//Grava Novos Valores Acessorios (FKD)
			cIdDoc := oSubFK1:GetValue("FK1_IDDOC")
            IF EMPTY(nMoedaBco)
                FSetFK6FKD( oSubFK6, cIdDoc, cIdFK1, "R" )
            ELSE    
                FSetFK6FKD( oSubFK6, cIdDoc, cIdFK1, "R", dBaixa, SE1->E1_MOEDA, nMoedaBco, nTxMoeda, MsDecimais(1)+1)
            ENDIF
		Else //Grava Valores Acessorios (juros, multas, descontos etc)			
			If !oSubFK6:IsEmpty()
				oSubFK6:AddLine()
				oSubFK6:GoLine( oSubFK6:Length() )
			Endif
			
			If cPaisLoc == "MEX" .AND. lMonedaC .AND. FindFunction("fn450fk6")
				fn450fk6(@oSubFK6,nValor,nValCalc,SE1->E1_MOEDA,nMoedaBco, nTxMoeda,cTpDoc)
			Else
				oSubFK6:SetValue("FK6_VALMOV",nValor)
				oSubFK6:SetValue("FK6_VALCAL",nValCalc)
			Endif
			
			oSubFK6:SetValue("FK6_TPDOC",cTpDoc)
			oSubFK6:SetValue("FK6_RECPAG","R")
			oSubFK6:SetValue("FK6_IDORIG",cIdFK1)
			oSubFK6:SetValue("FK6_TABORI","FK1")
			oSubFK6:SetValue("FK6_HISTOR",cHistMov)
		Endif
	EndIf

	If __lFinm010
		cCamposE5 := oModelBxR:GetModel("MASTER"):GetValue( "E5_CAMPOS" )
	Endif
EndIf

If i == 4
	cCamposE5 += ",{'E5_IDENTEE' ,'" + SE1->E1_IDENTEE + "'}"
Endif

//Não migrar trecho para FKs, pois faz parte da gravação da SE5
If cPaisloc =="EUA" .And. FUNNAME() $ "FINA884" .and. SE5->(FieldPos("E5_INTPLAI")) > 0 
	cCamposE5 += ",{'E5_ORIGEM' ,'" + FUNNAME() + "'}" 
	cCamposE5 += ",{'E5_INTPLAI' ,'" + "I"+ "'}"
EndIf

//Executo o movimento vindo do cheque
If i == 0 .And. lMovCh
	If cTpDoc $ "CH"
		//Dados da tabela auxiliar com o código do título a pagar
		cFilOriTit	:= xFilial("SE1", SE1->E1_FILORIG)
		cChaveTit 	:= cFilOriTit + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
		cIdDoc 		:= FINGRVFK7("SE1", cChaveTit)

		//Model de Movimento bancario
		oModelMov 	:= FWLoadModel("FINM030")
		oModelMov:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
		oModelMov:Activate()
		oSubFK5MV  := oModelMov:GetModel("FK5DETAIL")
		oSubFKAMV  := oModelMov:GetModel("FKADETAIL" )
		oSubFK9MV  := oModelMov:GetModel("FK9DETAIL" )

		// Inclui registro no SE5 para a geracao do cheque
		cCamposE5M += "{ {'E5_DTDIGIT',dDataBase     }"
		cCamposE5M += " ,{'E5_ARQNAB'	,'" + cArqEnt +"' }"
		cCamposE5M += " ,{'E5_CNABOC'	,'" + cOcorr +"' }"
		cCamposE5M += " ,{'E5_BENEF'	,'" + RemoveAsp(SE1->E1_NOMCLI) + "'}"
		cCamposE5M += " ,{'E5_TIPO'		, SE1->E1_TIPO}"
		cCamposE5M += " ,{'E5_LOTE'		,'" + cLoteFin + "'}"
		cCamposE5M += " ,{'E5_MOTBX'	,'" + TrazCodMot( cMotBx ) + "'}"
		cCamposE5M += " ,{'E5_SERREC'	, SE1->E1_SERREC}"
		cCamposE5M += " ,{'E5_ORDREC'	, SE1->E1_RECIBO}"
		cCamposE5M += " ,{'E5_SITCOB'	, SE1->E1_SITUACA}"
		cCamposE5M += " ,{'E5_PREFIXO'	, SE1->E1_PREFIXO}"
		cCamposE5M += " ,{'E5_NUMERO'	, SE1->E1_NUM}"
		cCamposE5M += " ,{'E5_PARCELA'	, SE1->E1_PARCELA}"
		cCamposE5M += " ,{'E5_TIPO'		, SE1->E1_TIPO}"
		cCamposE5M += " ,{'E5_CLIFOR'	, SE1->E1_CLIENTE}"
		cCamposE5M += " ,{'E5_CLIENTE'	, SE1->E1_CLIENTE}"
		cCamposE5M += " ,{'E5_LOJA'		, SE1->E1_LOJA} }"

		oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5M )
		oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
		oModelMov:SetValue( "MASTER", "NOVOPROC", .T. ) //Novo processo

		//Dados do movimento bancario do Cheque
		If !oSubFKAMV:IsEmpty()
			//Inclui a quantidade de linhas necessárias
			oSubFKAMV:AddLine()
			//Vai para linha criada
			oSubFKAMV:GoLine( oSubFKAMV:Length() )
		Endif

		cHistMov := Left(cHistMov, __nTamHist)

		oSubFKAMV:SetValue( 'FKA_IDORIG', FWUUIDV4() )
		oSubFKAMV:SetValue( 'FKA_TABORI', 'FK5' )

		oSubFK5MV:SetValue( "FK5_RECPAG" , "R" )
		oSubFK5MV:SetValue( "FK5_HISTOR" , cHistMov )
		oSubFK5MV:SetValue( "FK5_DATA"   , dBaixa )
		oSubFK5MV:SetValue( "FK5_NATURE" , SE1->E1_NATUREZ )
		oSubFK5MV:SetValue( "FK5_BANCO"  , cBanco )
		oSubFK5MV:SetValue( "FK5_AGENCI" , cAgencia )
		oSubFK5MV:SetValue( "FK5_CONTA"  , cConta )
		oSubFK5MV:SetValue( "FK5_NUMCH"  , cCheque )
		oSubFK5MV:SetValue( "FK5_SEQ"    , cSequencia )
		oSubFK5MV:SetValue( "FK5_IDDOC"  , cIdDoc )

		If ( cPaisLoc <> "BRA" )
			If Empty(cBanco+cAgencia+cConta) .And.  !Empty(SE1->E1_RECIBO)
			 	nMoedaBco := Max( SE1->E1_MOEDA, 1)
			Else
				nMoedaBco := Max( SA6->A6_MOEDA, 1)
			EndIf

			If Type("aTxMoedas") == "A"
		   		oSubFK5MV:SetValue( "FK5_TXMOED"	, aTxMoedas[nMoedaBco][2] )
		 	Else
		   		oSubFK5MV:SetValue( "FK5_TXMOED"	, nTxMoedAux )
		 	EndIf

			oSubFK5MV:SetValue( "FK5_VALOR"	, nValor)
			oSubFK5MV:SetValue( "FK5_MOEDA"  , StrZero( nMoedaBco ,2) )
		Else
			If SE1->E1_MOEDA > 1
				oSubFK5MV:SetValue( "FK5_TXMOED"	, nTxMoedAux )
			EndIf

			nMoedaBco := Max( SA6->A6_MOEDA, 1)
			oSubFK5MV:SetValue( "FK5_VALOR"	, nValor )
			oSubFK5MV:SetValue( "FK5_MOEDA"  , StrZero( Max( nMoedaBco , 1), 2 ) )
		EndIf

		oSubFK5MV:SetValue( "FK5_VLMOE2" , Iif(SE1->E1_MOEDA <= 1,Round(xMoeda( nValor, nMoedaBco, SE1->E1_MOEDA,dbaixa,4,,SE5->E5_TXMOEDA ),2),0) )
		oSubFK5MV:SetValue( "FK5_ORIGEM" , cOrigFK )
		oSubFK5MV:SetValue( "FK5_TPDOC"  , cTpDoc )
		oSubFK5MV:SetValue( "FK5_CCUSTO" , SE1->E1_CCUSTO )
		oSubFK5MV:SetValue( "FK5_FILORI" , SE1->E1_FILORIG )
		oSubFK5MV:SetValue( "FK5_LA"     , If( lPadrao .And. lContabiliza,"S","N") )

		nRetencao	:= SA6->A6_RETENCA
		dDataDisp	:= dBaixa 

		If nRetencao > 0
			For nCont := 1 To nRetencao
				dDataDisp := DataValida(dDataDisp+1,.T.)
			Next nCont
		EndIf

		If lSpbInUse
			oSubFK5MV:SetValue( "FK5_MODSPB" , cModSpb )
			If cModSpb $ "1#2"
				dDataDisp := dBaixa
			Endif
		Endif

		oSubFK5MV:SetValue( "FK5_DTDISP" , IIf(Empty(dDtCredito),dDataDisp,dDtCRedito) )

		//Dados do Cheque
		If !oSubFKAMV:IsEmpty()
			//Inclui a quantidade de linhas necessárias
			oSubFKAMV:AddLine()
			//Vai para linha criada
			oSubFKAMV:GoLine( oSubFKAMV:Length() )
		Endif
		oSubFKAMV:SetValue( 'FKA_IDORIG', cChaveSEF )
		oSubFKAMV:SetValue( 'FKA_TABORI', 'SEF' )

		If !Empty(cFormPagto)
			oSubFK9MV:SetValue('FK9_FORMPG',cFormPagto)
		EndIf

		//Grava os dados
		If oModelMov:VldData()
			oModelMov:CommitData()
			nRecSE5 := oModelMov:GetValue("MASTER","E5_RECNO")
			SE5->(dbGoTo(nRecSE5))
		Else
			lRet := .F.
		    cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
		    cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
		    cLog += cValToChar(oModelMov:GetErrorMessage()[6])

		    Help( ,,"GRVSE501",,cLog, 1, 0 )
		Endif
		oModelMov:DeActivate()
		oModelMov:Destroy()
		oModelMov:= Nil
	Else
		cHistMov := Left(cHistMov, __nTamHist)
		oModelMov 	:= FWLoadModel("FINM030")
		oSubFK5MV  := oModelMov:GetModel("FK5DETAIL")
		oModelMov:SetOperation( MODEL_OPERATION_UPDATE ) //Altera
		oModelMov:Activate()

		oSubFKAMV := oModelMov:GetModel( "FKADETAIL" )

		If __lF191Alt	// Grava tabelas para o ponto de entrada F191ALTEST
			nMoedaBco := Max( SA6->A6_MOEDA, 1)
			oSubFK5MV:SetValue( "FK5_DATA"	, dBaixa )
			oSubFK5MV:SetValue( "FK5_BANCO"  , cBanco )
			oSubFK5MV:SetValue( "FK5_AGENCI" , cAgencia )
			oSubFK5MV:SetValue( "FK5_CONTA"  , cConta )
			oSubFK5MV:SetValue( "FK5_VALOR" , nValor )
			oSubFK5MV:SetValue( "FK5_MOEDA" , StrZero(nMoedaBco,2) )
			oSubFK5MV:SetValue( "FK5_RECPAG" , cRecPag )
			oSubFK5MV:SetValue( "FK5_TPDOC"  , cTpDoc )

			cCamposE5M += " ,{'E5_DTDIGIT'	,STOD('" +  DTOS(dDataBase) + "')}"
			cCamposE5M += " ,{'E5_BANCO'	, '"+cBanco+"'}"
			cCamposE5M += " ,{'E5_AGENCIA'	, '"+cAgencia+"''}"
			cCamposE5M += " ,{'E5_CONTA'	, '"+cConta+"'}"
			cCamposE5M += " ,{'E5_ARQNAB'	,'" + cArqEnt +"' }"
			cCamposE5M += " ,{'E5_CNABOC'	,'" + cOcorr +"' }"
			cCamposE5M += " ,{'E5_BENEF'	,'" + RemoveAsp(SE1->E1_NOMCLI) + "'}"
			cCamposE5M += " ,{'E5_LOTE'		,'" + cLoteFin + "'}"
			cCamposE5M += " ,{'E5_MOTBX'	,'" + TrazCodMot( cMotBx ) + "'}"
			cCamposE5M += " ,{'E5_SERREC'	, SE1->E1_SERREC}"
			cCamposE5M += " ,{'E5_ORDREC'	, SE1->E1_RECIBO}"
			cCamposE5M += " ,{'E5_SITCOB'	, SE1->E1_SITUACA}"
			cCamposE5M += " ,{'E5_PREFIXO'	, SE1->E1_PREFIXO}"
			cCamposE5M += " ,{'E5_NUMERO'	, SE1->E1_NUM}"
			cCamposE5M += " ,{'E5_PARCELA'	, SE1->E1_PARCELA}"
			cCamposE5M += " ,{'E5_TIPO'		, 'ES'}"
			cCamposE5M += " ,{'E5_CLIFOR'	, SE1->E1_CLIENTE}"
			cCamposE5M += " ,{'E5_CLIENTE'	, SE1->E1_CLIENTE}"
			cCamposE5M += " ,{'E5_LOJA'		, SE1->E1_LOJA} }"
			oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5M )

		EndIf

		oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Informa se vai gravar SE5 ou não
		//E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
		//E5_OPERACAO 2 = Grava E5 com E5_TIPODOC = 'ES' e gera estorno na FK5
		//E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5
		oModelMov:SetValue( "MASTER", "E5_OPERACAO", 2 )
		oModelMov:SetValue( "MASTER", "HISTMOV", cHistMov)
		//Posiciona a FKA com base no IDORIG da SE5 posicionada
		If oSubFKAMV:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )

			If oModelMov:VldData()
				oModelMov:CommitData()
			Else
				lRet := .F.
				cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[6])

				Help( ,,"M030VALID",,cLog, 1, 0 )
			Endif
		Endif
		oModelMov:DeActivate()
		oModelMov:Destroy()
		oModelMov:= Nil
	EndIf
EndIf									 ³

//PTO DE ENTRADA F70E5ADT, Tratamento complementar da baixa de adiantamento
IF lF70E5ADT
	ExecBlock("F70E5ADT",.f.,.f.)
Endif

If GetNewPar("MV_FATDIST","N") == "S" // Apenas quando utilizado pelo modulo de Distribuicao
	DSe5Fi070()
EndIf

FZerSFQIr()

Return Nil

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070ADIANT

Processa baixa de adiantamento (RA).
Arquivo anterior: FINXATU.PRX

@Author	Vinicius S. Barreira
@since	26/10/1994
/*/
//-----------------------------------------------------------------------------------------------------
Function fa070Adiant( lPadrao, lContabiliza, lGerChqAdt, aBaixas, dDtCredito , nTxMoeda, lMultNat )
Local nTamSeq		:= TamSX3("FK1_SEQ")[1]
Local cSequencia 	:= Replicate("0",nTamSeq)
Local nRetencao		:= 0
Local dDataDisp		:= Ctod("//")
Local nCont			:= 0
Local lSpbInUse 	:= SpbInUse()
Local nMoedaBco 	:= Max(MoedaBco(cBanco,cAgencia,cConta),1)
Local nMoedaTit 	:= SE1->E1_MOEDA
Local nTxMdTit  	:= If( cPaisLoc<>"BRA", aTxMoedas[Max(SE1->E1_MOEDA	,1)][2]	, 0 )
Local nTxMdBco  	:= If( cPaisLoc<>"BRA", aTxMoedas[Max(nMoedaBco		,1)][2]	, 0 )
Local nRecBx		:= 0
//Reestrutura das tabelas do processo de movimento bancário
Local oSubFK1		:= Nil //BAIXAS A RECEBER
Local oSubFK5		:= Nil //MOVTO BANCARIO
Local oSubFK6		:= Nil //Valores complementares
Local cLog 			:= ""
Local cChaveFK7		:= ""
Local cCamposE5		:= ""
Local lRet 			:= .T.
Local oSubFKA		:= Nil //Baixas a receber para atualização de retenção
//Dados da tabela auxiliar com o código do título a receber (SE1)
Local cChaveTit		:= 	xFilial("SE1") + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" +	SE1->E1_PARCELA + "|" +;
							SE1->E1_TIPO	+ "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
Local cFilSE5		:= FWxFilial('SE5')
Local cIdFK1		:= ''
Local cIdFK5		:= ''
Local cTpDoc 		:= ""
Local cOrigem 		:= ""
Local lMovBcoBx 	:= MovBcoBx( cMotBx, .T. )
Local cChaveCH		:= ""
Local aRecsSe5 		:= {}
Local nI			:= 0
Local nVlAcres		:= 0
Local nVlDecre		:= 0
Local nTxMoedGrv    := 0
Local lUsaFlag		:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
Local cFlagCTB			:= ""

Default lGerChqAdt 	:= .F.
Default aBaixas 	:= {}
Default dDtCredito	:= CtoD("")
Default lMultNat 	:= .F.

if cPaisLoc $ "MEX|PER"
	If nMoedaBco != SE1->E1_MOEDA .AND. !lMovBcoBx
		nMoedaBco := SE1->E1_MOEDA
	EndIf
EndIf
If cPaisLoc <> "BRA"
	If ( Empty(cBanco+cAgencia+cConta) .And. !Empty(SE1->E1_RECIBO) ) .Or. Empty(SA6->A6_MOEDA)
		nTxMoedGrv := RecMoeda(dBaixa,SE1->E1_MOEDA)
	ElseIf nMoedaBco == 1 .And. SE1->E1_MOEDA == 1
		nTxMoedGrv := 1
    ElseIf nMoedaBco > 1 .AND. SE1->E1_MOEDA = 1
        nTxMoedGrv := RecMoeda(dBaixa,nMoedaBco)
	ElseIf SE1->E1_MOEDA > 1 .And. SE1->E1_TXMOEDA > 0   
        nTxMoedGrv := SE1->E1_TXMOEDA
    Else
        nTxMoedGrv := RecMoeda(dBaixa,SE1->E1_MOEDA)
   	EndIf
    EndIf

//Lipando o array aRecSe5 para conter somente o RECNO desta baixa.
FIM010CLRE5()

// Localiza a sequencia da baixa ( CP,BA,VL,V2,LJ )
cSequencia 	:= FaNxtSeqBx("SE1",.T.)

//Define os campos que não existem nas FKs e que serão gravados apenas na E5, para que a gravação da E5 continue igual
If !Empty(cCamposE5)
    cCamposE5 += "|"
Endif
cCamposE5 += " { "
cCamposE5 += "{'E5_FILIAL'		,'" + cFilSE5 + "'}"
cCamposE5 += ",{'E5_PREFIXO'	,'" +  SE1->E1_PREFIXO+ "'}"
cCamposE5 += ",{'E5_NUMERO'		,'" +  SE1->E1_NUM + "'}"
cCamposE5 += ",{'E5_PARCELA'	,'" +  SE1->E1_PARCELA + "'}"
cCamposE5 += ",{'E5_CLIENTE'	,'" +  SE1->E1_CLIENTE + "'}"
cCamposE5 += ",{'E5_CLIFOR'		,'" +  SE1->E1_CLIENTE + "'}"
cCamposE5 += ",{'E5_LOJA'		,'" +  SE1->E1_LOJA + "'}"
cCamposE5 += ",{'E5_BENEF'		,'" +  RemoveAsp(SE1->E1_NOMCLI) + "'}"
cCamposE5 += ",{'E5_TIPO'		,'" +  SE1->E1_TIPO + "'}"
cCamposE5 += ",{'E5_DTDIGIT'	, STOD('" + DTOS(dDataBase) + "')}"
cCamposE5 += ",{'E5_BANCO'		,'" +  cBanco + "'}"
cCamposE5 += ",{'E5_AGENCIA'	,'" + cAgencia + "'}"
cCamposE5 += ",{'E5_CONTA'		,'" +  cConta + "'}"
cCamposE5 += ",{'E5_DTDISPO'	, STOD('" + DTOS( Iif( Empty(dDtCredito), dBaixa, dDtCRedito ) ) + "')}"
cCamposE5 += ",{'E5_MULTNAT'	,'" + If(lMultNat,"1","2") + "'}"

If lSpbInUse
	cCamposE5 += ",{'E5_MODSPB'		, '1'}"
EndIf
cOrigem := FunName()

//Carrego model de Bx a Receber
If oModelBxRZ == Nil
	oModelBxRZ := FWLoadModel("FINM010")
EndIf
oModelBxRZ:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
oModelBxRZ:Activate()
oModelBxRZ:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
oModelBxRZ:SetValue( "MASTER", "NOVOPROC", .T. ) //Novo processo

oSubFK1 := oModelBxRZ:GetModel("FK1DETAIL")
oSubFK5 := oModelBxRZ:GetModel("FK5DETAIL")
oSubFK6 := oModelBxRZ:GetModel("FK6DETAIL")
oSubFKA := oModelBxRZ:GetModel("FKADETAIL")

cChaveFK7 := FINGRVFK7("SE1", cChaveTit)

//Baixa Principal
If !oSubFKA:IsEmpty()
	oSubFKA:AddLine()
EndIf

cIdFK1 := FWUUIDV4()
oSubFKA:SetValue( "FKA_IDORIG"	, cIdFK1 )
oSubFKA:SetValue( "FKA_TABORI"	, 'FK1' )

If !oSubFK1:IsEmpty()
	oSubFK1:AddLine()
EndIf

If SE1->E1_TIPO $ MVRECANT .AND. cOrigem == "FINA630"
	cTpDoc := "VL"
Else
	cTpDoc := Iif( (lMovBcoBx .OR. SE1->E1_TIPO $ MVRECANT) .AND. !lGerChqAdt, "VL", "BA" )
EndIf

If lPadrao .And. lContabiliza .And. !lUsaFlag
	cFlagCTB := "S"
Else
	cFlagCTB := "N"	
EndIf

//Gera movimentação bancária a pagar - baixa do adiantamento
oSubFK1:SetValue( "FK1_DATA"	, dBaixa )
oSubFK1:SetValue( "FK1_NATURE"	, SE1->E1_NATUREZ )
oSubFK1:SetValue( "FK1_RECPAG"	, "P" )
oSubFK1:SetValue( "FK1_HISTOR"	, cHist070 )
oSubFK1:SetValue( "FK1_MOTBX"	, TrazCodMot( cMotBx ) )
oSubFK1:SetValue( "FK1_ORIGEM"	, cOrigem )
oSubFK1:SetValue( "FK1_SEQ"		, cSequencia )
oSubFK1:SetValue( "FK1_DOC"		, SE1->E1_NUMBOR )
oSubFK1:SetValue( "FK1_IDDOC"	, cChaveFK7 )
oSubFK1:SetValue( "FK1_TPDOC"	, cTpDoc )
oSubFK1:SetValue( "FK1_CCUSTO"	, SE1->E1_CCUSTO )
oSubFK1:SetValue( "FK1_FILORI"	, SE1->E1_FILORIG )
oSubFK1:SetValue( "FK1_VALOR"	, nValRec )
oSubFK1:SetValue( "FK1_MOEDA"	, StrZero(nMoedaBco,2) )
oSubFK1:SetValue( "FK1_LA"	   	, cFlagCTB) 
oSubFK1:SetValue( "FK1_LOTE"   	, cLoteFin )
oSubFK1:SetValue( "FK1_MULNAT"	, If(lMultNat,"1","2"))

If ( cPaisLoc<>"BRA" )
 	If AllTrim(Upper(SE1->E1_ORIGEM)) <> "FINA074"
    	If nValEstrang != 0
			oSubFK1:SetValue( "FK1_VLMOE2"	, nValEstrang )
		Else
			oSubFK1:SetValue( "FK1_VLMOE2"	, nValRec )
		Endif
		If cPaisLoc == "MEX"
			MovBanc(@oSubFK1,lMovBcoBx,nValEstrang,nValRec,nMoedaBco)
		EndIf
	Else
		oSubFK1:SetValue( "FK1_VLMOE2"	, nValRec)
	EndIf
	oSubFK1:SetValue( "FK1_TXMOED"	, nTxMoedGrv ) 
Else
	If SE1->E1_MOEDA > 1 .And. nValEstrang != 0
		oSubFK1:SetValue( "FK1_VLMOE2"	, nValEstrang )
		oSubFK1:SetValue( "FK1_TXMOED"	, nTxMoeda )
	Else
		oSubFK1:SetValue( "FK1_VLMOE2"	, xMoeda(nValRec,1,SE1->E1_MOEDA) )
	EndIf
EndIf

If nJuros <> 0
	//Adicionando valores acessórios (Juros)
	If !oSubFK6:IsEmpty()
		oSubFK6:AddLine()
	EndIf
	oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )
	oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
	oSubFK6:SetValue( 'FK6_TPDOC'	, 'JR' )
	oSubFK6:SetValue( 'FK6_VALCAL'	, nJuros )
	oSubFK6:SetValue( 'FK6_VALMOV'	, nJuros )
	oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
	oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
	oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0018) ) //JUROS DE ADIANTAMENTO"
	If ( If( cPaisLoc <> "CHI", nJuros > 0, nOtrga > 0 ) ) .AND. lMovBcoBx
		oSubFK6:SetValue( 'FK6_GRVSE5'	, .T. )
	Endif
	cCamposE5 += ",{'E5_VLJUROS' , Val('" + cValToChar( nJuros ) + "')}"
EndIf

If nMulta <> 0
	//Adicionando valores acessórios (Multa)
	If !oSubFK6:IsEmpty()
		oSubFK6:AddLine()
	EndIf
	oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )
	oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
	oSubFK6:SetValue( 'FK6_TPDOC'	, 'MT' )
	oSubFK6:SetValue( 'FK6_VALCAL'	, nMulta )
	oSubFK6:SetValue( 'FK6_VALMOV'	, nMulta )
	oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
	oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
	oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0019) )  //MULTA DE ADIANTAMENTO
	If lMovBcoBx
		oSubFK6:SetValue( 'FK6_GRVSE5'	, .T. )
	Endif
	cCamposE5 += ",{'E5_VLMULTA' , Val('" + cValToChar(nMulta) + "')}"
EndIf

If nDescont <> 0
	//Adicionando valores acessórios (Desconto)
	If !oSubFK6:IsEmpty()
		oSubFK6:AddLine()
	EndIf
	oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )
	oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
	oSubFK6:SetValue( 'FK6_TPDOC'	, 'DC' )
	oSubFK6:SetValue( 'FK6_VALCAL'	, nDescont )
	oSubFK6:SetValue( 'FK6_VALMOV'	, nDescont )
	oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
	oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
	oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0020) ) //DESCONTO DE ADIANTAMENTO
	If lMovBcoBx
		oSubFK6:SetValue( 'FK6_GRVSE5'	, .T. )
	Endif
	cCamposE5 += ",{'E5_VLDESCO' , Val('" + cValToChar( nDescont ) + "')}"
EndIf

If nCm <> 0
	//Adicionando valores acessórios (Juros)
	If !oSubFK6:IsEmpty()
		oSubFK6:AddLine()
	EndIf
	oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )
	oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
	oSubFK6:SetValue( 'FK6_TPDOC'	, 'CM' )
	oSubFK6:SetValue( 'FK6_VALCAL'	, nCm )
	oSubFK6:SetValue( 'FK6_VALMOV'	, nCm )
	oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
	oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
	oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0021) ) //CORREC.DE ADIANTAMENTO
	If lMovBcoBx
		oSubFK6:SetValue( 'FK6_GRVSE5'	, .T. )
	Endif
EndIf

nVlAcres := SE1->E1_SDACRES
If nVlAcres <> 0
	nVlAcres := Round( NoRound( xMoeda( nVlAcres, SE1->E1_MOEDA, 1, dBaixa, 3, SE1->E1_TXMOEDA ), 3 ), 2 )
	cCamposE5 += ",{'E5_VLACRES' , Val('" + cValToChar(nVlAcres) + "')}"
EndIf

nVlDecre := SE1->E1_SDDECRE
If nVlDecre <> 0
	nVlDecre := Round( NoRound( xMoeda( nVlDecre, SE1->E1_MOEDA, 1, dBaixa, 3, SE1->E1_TXMOEDA ), 3 ), 2 )
	cCamposE5 += ",{'E5_VLDECRE' , Val('" + cValToChar(nVlDecre) + "')}"
EndIf

//Verifica se a baixa movimenta extrato para gerar FK5
If cTpDoc == "VL"
	If !oSubFKA:IsEmpty()
		oSubFKA:AddLine()
	EndIf

	cIdFK5 := FWUUIDV4()
	oSubFKA:SetValue( "FKA_IDORIG"	, cIdFK5 )
	oSubFKA:SetValue( "FKA_TABORI"	, 'FK5' )

	oSubFK5:SetValue( "FK5_DATA"	, dBaixa )
	oSubFK5:SetValue( "FK5_DTDISP" 	, DTOS( Iif( EMpty(dDtCredito), dBaixa, dDtCRedito ) ) )
	oSubFK5:SetValue( "FK5_BANCO"  	, cBanco )
	oSubFK5:SetValue( "FK5_AGENCI" 	, cAgencia )
	oSubFK5:SetValue( "FK5_CONTA"  	, cConta )
	oSubFK5:SetValue( "FK5_ORIGEM" 	, cOrigem )
	oSubFK5:SetValue( "FK5_LA" 		, cFlagCTB)
	oSubFK5:SetValue( "FK5_MOEDA"	, StrZero(nMoedaBco,2) )
	oSubFK5:SetValue( "FK5_NATURE"	, SE1->E1_NATUREZ )
	oSubFK5:SetValue( "FK5_RECPAG"	, "P" )
	oSubFK5:SetValue( "FK5_HISTOR"	, cHist070 )
	oSubFK5:SetValue( "FK5_SEQ"		, cSequencia )
	oSubFK5:SetValue( "FK5_DOC"		, SE1->E1_NUMBOR )
	oSubFK5:SetValue( "FK5_TPDOC"	, cTpDoc )
	oSubFK5:SetValue( "FK5_CCUSTO"	, SE1->E1_CCUSTO )
	oSubFK5:SetValue( "FK5_FILORI"	, SE1->E1_FILORIG )
	oSubFK5:SetValue( "FK5_VALOR"	, nValRec )
EndIf

cCamposE5 += " } "

If cPaisLoc $ "ARG|ANG|COL"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gerar a Movimentacao Bancaria na 2a. Moeda.  		  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SA6->( dbSeek(xFilial("SA6")+cBanco+cAgencia+cConta) )
	If !Empty(SA6->A6_MOEDA) .and. ( SA6->A6_MOEDA != SE1->E1_MOEDA )
		//Define os campos que não existem nas FKs e que serão gravados apenas na E5, para que a gravação da E5 continue igual
		If !Empty(cCamposE5)
		    cCamposE5 += "|"
		Endif
		cCamposE5 += " { "
		cCamposE5 += "{'E5_FILIAL'		,'" + cFilSE5 + "'}"
		cCamposE5 += ",{'E5_PREFIXO'	,'" +  SE1->E1_PREFIXO+ "'}"
		cCamposE5 += ",{'E5_NUMERO'		,'" +  SE1->E1_NUM + "'}"
		cCamposE5 += ",{'E5_PARCELA'	,'" +  SE1->E1_PARCELA + "'}"
		cCamposE5 += ",{'E5_CLIENTE'	,'" +  SE1->E1_CLIENTE + "'}"
		cCamposE5 += ",{'E5_CLIFOR'		,'" +  SE1->E1_CLIENTE + "'}"
		cCamposE5 += ",{'E5_LOJA'		,'" +  SE1->E1_LOJA + "'}"
		cCamposE5 += ",{'E5_BENEF'		,'" +  SE1->E1_NOMCLI + "'}"
		cCamposE5 += ",{'E5_TIPO'		,'" +  SE1->E1_TIPO + "'}"
		cCamposE5 += ",{'E5_DTDIGIT'	, STOD('" + DTOS(dDataBase) + "')}"
		cCamposE5 += ",{'E5_BANCO'		,'" +  cBanco + "'}"
		cCamposE5 += ",{'E5_AGENCIA'	,'" + cAgencia + "'}"
		cCamposE5 += ",{'E5_CONTA'		,'" +  cConta + "'}"
		cCamposE5 += ",{'E5_DTDISPO'	, STOD('" + DTOS( Iif( Empty(dDtCredito), dBaixa, dDtCRedito ) ) + "')}"
		If lSpbInUse
			cCamposE5 += ",{'E5_MODSPB'		, '1'}"
		EndIf
		cCamposE5 += " } "

		//Baixa Principal
		If !oSubFKA:IsEmpty()
			oSubFKA:AddLine()
		EndIf

		cIdFK1 := FWUUIDV4()
		oSubFKA:SetValue( "FKA_IDORIG"	, cIdFK1 )
		oSubFKA:SetValue( "FKA_TABORI"	, 'FK1' )

		If !oSubFK1:IsEmpty()
			oSubFK1:AddLine()
		EndIf

		cTpDoc := Iif( lMovBcoBx, "VL", "BA" )

		//Gera movimentação bancária a pagar - baixa do adiantamento
		oSubFK1:SetValue( "FK1_DATA"	, dBaixa )
		oSubFK1:SetValue( "FK1_NATURE"	, SE1->E1_NATUREZ )
		oSubFK1:SetValue( "FK1_RECPAG"	, "P" )
		oSubFK1:SetValue( "FK1_HISTOR"	, cHist070 )
		oSubFK1:SetValue( "FK1_MOTBX"	, TrazCodMot( cMotBx ) )
		oSubFK1:SetValue( "FK1_ORIGEM"	, cOrigem )
		oSubFK1:SetValue( "FK1_SEQ"		, cSequencia )
		oSubFK1:SetValue( "FK1_DOC"		, SE1->E1_NUMBOR )
		oSubFK1:SetValue( "FK1_IDDOC"	, cChaveFK7 )
		oSubFK1:SetValue( "FK1_TPDOC"	, cTpDoc )
		oSubFK1:SetValue( "FK1_CCUSTO"	, SE1->E1_CCUSTO )
		oSubFK1:SetValue( "FK1_FILORI"	, SE1->E1_FILORIG )
		oSubFK1:SetValue( "FK1_MOEDA"	, StrZero( nMoedaBco, 2 ) )
		oSubFK1:SetValue( "FK1_LA"	   	, Iif( lPadrao .AND. lContabiliza, "S", "N" ) )
		oSubFK1:SetValue( "FK1_LOTE"   	, cLoteFin )
		oSubFK1:SetValue( "FK1_VALOR"	, xMoeda( nValRec, nMoedaTit, nMoedaBco, , , nTxMdTit, nTxMdBco ) )
		oSubFK1:SetValue( "FK1_TXMOED"	, nTxMoedGrv ) 
		If nValEstrang != 0
			oSubFK1:SetValue( "FK1_VLMOE2"	, nValEstrang )
		Else
			oSubFK1:SetValue( "FK1_VLMOE2"	, xMoeda( nValRec, 1, SA6->A6_MOEDA ) )
		EndIf

		If nJuros <> 0
			//Adicionando valores acessórios (Juros)
			If !oSubFK6:IsEmpty()
				oSubFK6:AddLine()
			EndIf
			oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )
			oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
			oSubFK6:SetValue( 'FK6_TPDOC'	, 'JR' )
			oSubFK6:SetValue( 'FK6_VALCAL'	, xMoeda(nJuros+nOtrga,nMoedaTit,nMoedaBco,,, nTxMdTit, nTxMdBco ) )
			oSubFK6:SetValue( 'FK6_VALMOV'	, xMoeda(nJuros+nOtrga,nMoedaTit,nMoedaBco,,, nTxMdTit, nTxMdBco ) )
			oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
			oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
			oSubFK6:SetValue( 'FK6_HISTOR'	, cHist070 )
			If nJuros > 0 .AND. lMovBcoBx
				oSubFK6:SetValue( 'FK6_GRVSE5'	, .T. )
			Endif
		EndIf

		If nCm <> 0
			//Adicionando valores acessórios (Juros)
			If !oSubFK6:IsEmpty()
				oSubFK6:AddLine()
			EndIf
			oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )
			oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
			oSubFK6:SetValue( 'FK6_TPDOC'	, 'CM' )
			oSubFK6:SetValue( 'FK6_VALCAL'	, xMoeda( nCM, nMoedaTit, nMoedaBco, , , nTxMdTit, nTxMdBco ) )
			oSubFK6:SetValue( 'FK6_VALMOV'	, xMoeda( nCM, nMoedaTit, nMoedaBco, , , nTxMdTit, nTxMdBco ) )
			oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
			oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
			oSubFK6:SetValue( 'FK6_HISTOR'	, cHist070 )
			If lMovBcoBx
				oSubFK6:SetValue( 'FK6_GRVSE5'	, .T. )
			Endif
		EndIf

		If nDescont <> 0
			//Adicionando valores acessórios (Desconto)
			If !oSubFK6:IsEmpty()
				oSubFK6:AddLine()
			EndIf
			oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )
			oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
			oSubFK6:SetValue( 'FK6_TPDOC'	, 'DC' )
			oSubFK6:SetValue( 'FK6_VALCAL'	, xMoeda( nDescont, nMoedaTit, nMoedaBco, , , nTxMdTit, nTxMdBco ) )
			oSubFK6:SetValue( 'FK6_VALMOV'	, xMoeda( nDescont, nMoedaTit, nMoedaBco, , , nTxMdTit, nTxMdBco ) )
			oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
			oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
			oSubFK6:SetValue( 'FK6_HISTOR'	, cHist070 )
			If lMovBcoBx
				oSubFK6:SetValue( 'FK6_GRVSE5'	, .T. )
			Endif
		EndIf

		If nMulta <> 0
			//Adicionando valores acessórios (Multa)
			If !oSubFK6:IsEmpty()
				oSubFK6:AddLine()
			EndIf
			oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )
			oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
			oSubFK6:SetValue( 'FK6_TPDOC'	, 'MT' )
			oSubFK6:SetValue( 'FK6_VALCAL'	, xMoeda( nMulta, nMoedaTit, nMoedaBco, , , nTxMdTit, nTxMdBco ) )
			oSubFK6:SetValue( 'FK6_VALMOV'	, xMoeda( nMulta, nMoedaTit, nMoedaBco, , , nTxMdTit, nTxMdBco ) )
			oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
			oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
			oSubFK6:SetValue( 'FK6_HISTOR'	, cHist070 ) //MULTA DE ADIANTAMENTO"
			If lMovBcoBx
				oSubFK6:SetValue( 'FK6_GRVSE5'	, .T. )
			Endif
		EndIf

		//Verifica se a baixa movimenta extrato para gerar FK5
		If cTpDoc == "VL"
			nRetencao	:= SA6->A6_RETENCA
			dDataDisp	:= dBaixa
			If nRetencao > 0
				For nCont := 1 To nRetencao
					dDataDisp 	:= DataValida(dDataDisp+1,.T.)
				Next nCont
			Endif

			If !oSubFKA:IsEmpty()
				oSubFKA:AddLine()
			EndIf

			cIdFK5 := FWUUIDV4()
			oSubFKA:SetValue( "FKA_IDORIG"	, cIdFK5 )
			oSubFKA:SetValue( "FKA_TABORI"	, 'FK5' )

			oSubFK5:SetValue( "FK5_DATA"	, dBaixa )
			oSubFK5:SetValue( "FK5_DTDISP" , dDataDisp  )
			oSubFK5:SetValue( "FK5_BANCO"  	, cBanco )
			oSubFK5:SetValue( "FK5_AGENCI" 	, cAgencia )
			oSubFK5:SetValue( "FK5_CONTA"  	, cConta )
			oSubFK5:SetValue( "FK5_ORIGEM" 	, cOrigem )
			oSubFK5:SetValue( "FK5_LA" 		, Iif( lPadrao .AND. lContabiliza, "S", "N" ) )
			oSubFK5:SetValue( "FK5_MOEDA"	, StrZero( nMoedaBco, 2 ) )
			oSubFK5:SetValue( "FK5_NATURE"	, SE1->E1_NATUREZ )
			oSubFK5:SetValue( "FK5_RECPAG"	, "P" )
			oSubFK5:SetValue( "FK5_HISTOR"	, cHist070 )
			oSubFK5:SetValue( "FK5_SEQ"		, cSequencia )
			oSubFK5:SetValue( "FK5_DOC"		, SE1->E1_NUMBOR )
			oSubFK5:SetValue( "FK5_TPDOC"	, cTpDoc )
			oSubFK5:SetValue( "FK5_CCUSTO"	, SE1->E1_CCUSTO )
			oSubFK5:SetValue( "FK5_FILORI"	, SE1->E1_FILORIG )
			oSubFK5:SetValue( "FK5_VALOR"	, xMoeda( nValRec, nMoedaTit, nMoedaBco, , , nTxMdTit, nTxMdBco ) )
			oSubFK5:SetValue( "FK5_TXMOED"	, nTxMoedGrv ) 
			If nValEstrang != 0
				oSubFK5:SetValue( "FK5_VLMOE2"	, nValEstrang )
				oSubFK5:SetValue( "FK5_MOEDA"	, StrZero( nMoedaBco, 2 ) )
			Else
				oSubFK5:SetValue( "FK5_VLMOE2"	, xMoeda( nValRec, 1, SA6->A6_MOEDA ) )
			EndIf
		EndIf

	EndIf

EndIf

If cPaisLoc == "RUS" .AND. Type("cItnUuidBs") == "C" .AND.;
   !Empty(cItnUuidBs)
	oSubFK5:SetValue( "FK5_IDBS" , cItnUuidBs)
	If cTpDoc == "VL"
		oSubFK5:SetValue("FK5_DTDISP",Iif(Empty(dDtCredito),dBaixa,dDtCRedito))
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se a baixa for menor que o valor adiantado emite-se um cheque para		³
//³ devolver o que sobrou, Se baixa n„o for GERAR MOVIMENTACAO BANCARIA, 	³
//³ esse cheque n„o ser  gerado, pois o valor adiantado n„o sera devolvido.³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lGerChqAdt .And. nValRec > 0 .and. lMovBcoBx .and. ChqMotBx(cMotBx)
	cChaveCH := FWUUIDV4()
	RecLock("SEF",.T.)
	SEF->EF_FILIAL	:= xFilial("SEF")
	SEF->EF_BANCO		:= cBanco
	SEF->EF_AGENCIA	:= cAgencia
	SEF->EF_CONTA		:= cConta
	SEF->EF_VALOR		:= nValRec
	SEF->EF_DATA		:= dBaixa
	SEF->EF_BENEF		:= SE1->E1_NOMCLI
	SEF->EF_HIST		:= OemToAnsi(STR0016) + SE1->E1_HIST//"Devolucao de Adiantamento"
	SEF->EF_PREFIXO	:= SE1->E1_PREFIXO
	SEF->EF_TITULO	:= SE1->E1_NUM
	SEF->EF_PARCELA	:= SE1->E1_PARCELA
	SEF->EF_FORNECE	:= SE1->E1_CLIENTE
	SEF->EF_LOJA		:= SE1->E1_LOJA
	SEF->EF_TIPO		:= SE1->E1_TIPO
	SEF->EF_SEQUENC	:= PadL( "1", TamSX3("EF_SEQUENC")[1], "0" )
	SEF->EF_ORIGEM	:= "FINA070"
	SEF->EF_IDSEF		:= cChaveCH

	//Vincula cheque ao processo na FKA
	If !oSubFKA:IsEmpty()
		oSubFKA:AddLine()
	Endif
	oSubFKA:SetValue( 'FKA_IDORIG', cChaveCH )
	oSubFKA:SetValue( 'FKA_TABORI', 'SEF' )
Endif

//Grava os dados da Baixa a Receber Automática
oModelBxRZ:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )
If oModelBxRZ:VldData()
	oModelBxRZ:CommitData()
	//Pega o Recno da baixa principal
	nRecBx := oModelBxRZ:GetValue("MASTER","E5_RECNO")
Else
	lRet := .F.
	cLog := cValToChar(oModelBxRZ:GetErrorMessage()[MODEL_MSGERR_IDFIELDERR]) + ' - '
	cLog += cValToChar(oModelBxRZ:GetErrorMessage()[MODEL_MSGERR_ID]) + ' - '
	cLog += cValToChar(oModelBxRZ:GetErrorMessage()[MODEL_MSGERR_MESSAGE])
	Help( ,,"M10F70AD01",,cLog, 1, 0 )
	nRecBx := 0
EndIf
oModelBxRZ:DeActivate()

//Chama o ponto de entrada "FA070ADTSE5" para cada registro gravado na SE5
If lFA070ADTSE5
	If nRecBx > 0
		SE5->( DbGoto( nRecBx ) )
		ExecBlock("FA070ADTSE5",.F.,.F.)
	Endif

	//Pega os Recnos dos registros de SE5 referentes a FK6
	aRecsSe5 := FK6SE5Recs()
	For nI := 1 To Len( aRecsSe5 )
		SE5->( DbGoto( aRecsSe5[nI] ) )
		ExecBlock("FA070ADTSE5",.F.,.F.)
	Next nI
EndIf

//Retorna posicionamento da E5
SE5->( DbGoto( nRecBx ))

//Guardo informacoes da baixa para calculo de comissao quando baixa de NCC gerada por liquidacao
If !( Empty(SE1->E1_NUMLIQ) )
	aAdd( aBaixas, { TrazCodMot( cMotBx ), cSequencia, nRecBx } )
EndIf

// Integração SIGAPFS x SIGAFIN
If lRet .And. FindFunction("JGrvBxRA")
	lRet := JGrvBxRA(SE1->(Recno())) // Atualiza valores de adiantamento
EndIf

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FILISSTRAN

Retorna a filial de origem do ISS, caso o mesmo não tenha sido transferido junto com os demais impostos.
Arquivo anterior: FINXATU.PRX

@Author	Daniel Mendes
@since	20/10/2014
/*/
//-----------------------------------------------------------------------------------------------------
Function FilISSTran()
Local cFilRetIss := ""
Local aArea      := GetArea()
Local aAreaSE6   := SE6->(GetArea())
Local aAreaSE1   := SE1->(GetArea())
Local lTrfISSf   := GetNewPar( "MV_TRFISSF" , .T. )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Busca origem do titulo baixado se foi originado pelo FINA630  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If "FINA630" $ SE1->E1_ORIGEM .And. !lTrfISSf
	DbSelectArea("SE6")
	SE6->(DbSetOrder(4))

	If SE6->(DbSeek(xFilial("SE1")+SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)))
		While !SE6->(Eof()) .And. SE6->(E6_FILIAL+E6_PREFIXO+E6_NUM+E6_PARCELA+E6_TIPO) == SE1->(E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)
			cFilRetIss := IIf( SE6->E6_SITSOL == "2" , SE6->E6_FILORIG , "" )
			SE6->(dbSkip())
		EndDo
	EndIf

	RestArea( aAreaSE1 )
	RestArea( aAreaSE6 )
	RestArea( aArea    )
EndIf

Return cFilRetIss

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070VALMO

Consiste o motivo de baixa em relação a situação de cobrança do t¡tulo (FINA070).
Arquivo anterior: FINXATU.PRX

@Author	Valter G. Nogueira Jr
@since	04/03/1994
/*/
//-----------------------------------------------------------------------------------------------------
Function Fa070ValMo()
Local lRet := .T.

//---------------------------------------------------------
// Ponto de Entrada para o usuário fazer	a sua própria
// validação a respeito do motivo da baixa.
//---------------------------------------------------------
If lF070VMOT
	lRet := ExecBlock("F070VMOT",.F.,.F.)
	Return lRet
Endif
//Situacao de cobranca diferente de Carteira e motivo de baixa nao movimenta banco
If !(FN022SITCB(SE1->E1_SITUACA)[1]) .and. !MovBcoBx(cMotBx, .T.)
	lRet := .F.
EndIf

If ! lRet
	Help(" ",1,"FA070MOTIN")
Endif

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070ESTRANG

Função utilizada para consistir o valor digitado em moeda estrangeira.
Arquivo anterior: FINXATU.PRX

@Author	Wilson Junior
@since	26/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function fa070Estrang(nTxMoeda)
Local lRet		:= .T.
Local nSaldtit	:= nValEstrang - Round(xMoeda(nJuros + nVA +nMulta-nDescont+nAcresc-nDecresc,nMoedaBco,SE1->E1_MOEDA,dBaixa,3,,nTxMoeda),2)

If lFA070CMI
	ExecBlock("FA070CMI",.F.,.F.)
Endif

If Int(nSaldtit) > Int(SE1->E1_SALDO)
	lRet := .F.
EndIf

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ULTILOTE

Ponto de entrada para buscar número do ultimo lote digitado (FINA070/FINA080/FINA090).
Arquivo anterior: FINXATU.PRX

@Author	Mauricio Pequim Jr.
@since	14/10/1997
/*/
//-----------------------------------------------------------------------------------------------------
Function Ultilote()
Default lUltiLote := ExistBlock("UltiLote")

//---------------------------------------------------------
// PONTO DE ENTRADA
//---------------------------------------------------------
If lUltiLote
	ExecBlock('UltiLote',.F.,.F.)
EndIf

Return .T.

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} CHECKLOTE

Verifica se um lote ja existe
Arquivo anterior: FINXATU.PRX

@Author	Wagner Xavier
@since	06/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function CheckLote(cRecPag, lHelp, cBco)
	Local aAreaAnt	:= {}
	Local aAreaSE5	:= {}
	Local lRet 	 	:= .T.
	Local lBxCnab	:= IIf( SuperGetMv( "MV_BXCNAB",,"S" ) == "S", .T., .F. )
	Local cFunName	:= FunName()
	Local lConvFks	:= FWSIXUtil():ExistIndex( "FK1" , "4" ) .and. FWSIXUtil():ExistIndex( "FK2" , "4" )

	Default cRecPag	:= "P"
	Default lHelp 	:= !(IsBlind())
	Default cBco    := ""

	cBco090 := If(Type("cBco090") == "U", cBco, cBco090)

	If cFunName $ "FINA090|FINA091" .AND. lBxCnab .AND. ( ( SubStr( cBco090, 1, 2 ) == "CX" .OR. cBco090 $ SuperGetMv("MV_CARTEIR",,"")  ) )
		lRet:= .T.
	Elseif Empty (cLoteFin)
		lRet:= .F.
	EndIF

	aAreaAnt := GetArea()

	If lRet
		If !lConvFks

			aAreaSe5 := SE5->( GetArea() )
			dbSelectArea("SE5")
			SE5->( dbSetOrder( 5 ) )
			If !Empty( cLoteFin )
				If msSeek( FWxFilial("SE5") + cLoteFin )
					While SE5->( !Eof() ) .AND. AllTrim(SE5->E5_LOTE) == AllTrim(cLoteFin) .AND. SE5->E5_FILIAL == FWxFilial("SE5")
						If SE5->E5_RECPAG == cRecPag
							If lHelp
								Help( "", 1, "LOTEEXIST" )
							EndIf
							lRet := .F.
							Exit
						Endif
						SE5->( dbSkip() )
					Enddo
				Endif
			Endif

			SE5->( RestArea(aAreaSe5) )

		Else
			If lRet
				dbSelectArea("FK1")
				FK1->( dbSetOrder( 4 ) )
				If FK1->(msSeek( FWxFilial("FK1") + cLoteFin ))
					If FK1->FK1_RECPAG == cRecPag
						lRet := .F.
					Endif
				Endif
			Endif
			If lRet
				dbSelectArea("FK2")
				FK2->( dbSetOrder( 4 ) )
				If FK2->(msSeek( FWxFilial("FK2") + cLoteFin ))
					If FK2->FK2_RECPAG == cRecPag
						lRet := .F.
					Endif
				Endif
			Endif
			If lRet
				dbSelectArea("FK5")
				FK5->( dbSetOrder( 2 ) )
				If FK5->(msSeek( FWxFilial("FK5") + cLoteFin ))
					If FK5->FK5_RECPAG == cRecPag
						lRet := .F.
					EndIf
				Endif
			Endif

			If !lRet .and. lHelp
				Help( "", 1, "LOTEEXIST" )
			EndIf

		Endif
	Endif

	RestArea( aAreaAnt )

Return lRet

//--------------------------------------------------------------------------------
// Funcoes retiradas do arquivo FINXFUN.PRX
//--------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SHOWMOTBX

Valida se mostra na tela a tabela de motivos da baixa (FINA090/FINA110).
Arquivo anterior: FINXFUN.PRX

@Author	Andreia Sandos
@since	25/11/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function ShowMotBx(cCarteira,lAut)
Local lRet  := .T.

lAut := IIF(lAut == NIL, .F.,lAut)

Return( lRet)

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} VLDBANCO

Validar a existencia dos codigos de Banco, Agencia e Conta e ainda se existe Bloqueio do registro.
Arquivo anterior: FINXFUN.PRX

@Author	Norberto M. Melo
@since	03/09/2007
/*/
//-----------------------------------------------------------------------------------------------------
Function VldBanco()
	LOCAL lRet := .T.

	If FindFunction ("VldBcold")
		lRet := VldBcold()
	Else
		Help( ,,"ATUXOLD",,STR0032, 1, 0 ) //'Por favor, solicite ao administrador do sistema que seja atualizado o fonte FINXOLD.PRX'
	Endif	

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} CHQMOTBX

Verifica se o motivo de baixa gera cheque.
Arquivo anterior: FINXFUN.PRX

@Author	Mauricio Pequim Jr.
@since	31/03/1999
/*/
//-----------------------------------------------------------------------------------------------------
Function ChqMotBx( cMotBx )
Local nPos		:= 0
Local lRet	 	:= .F.
Local aMotBx	:= ReadMotBx()

nPos := Ascan(aMotBx, {|x| Alltrim(Substr(x,7,10)) == Alltrim(Upper(cMotBx))})
If nPos > 0
	lRet := Iif(Substr(aMotBx[nPos],41,1) == "S",.T.,.F.)
Endif
Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} TRAZCODMOT

Retorna o codigo reduzido (sigla) do motivo de baixa.
Arquivo anterior: FINXFUN.PRX

@Author	Andreia Santos
@since	04/12/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function TrazCodMot( cMotBx )
Local nPos		:= 0
Local lRet 		:= cMotBx
Local aMotBx	:= ReadMotBx()

nPos := Ascan(aMotBx, {|x| AllTrim(Substr(x,7,10)) == Upper(AllTrim(cMotBx))})
If nPos>0
	lRet := Substr(aMotBx[nPos],1,3)
Else
	lRet := left(cMotBx,3)
EndIf
Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} BAIXAS

Retorna uma matriz com os valores pagos ou recebidos de um titulo (FINA040/FINR340).
Arquivo anterior: FINXFUN.PRX

@Author	Luis C. Cunha
@since	04/12/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function Baixas(cNatureza,cPrefixo,cNumero,cParcela,cTipo,nMoeda,cModo,cFornec,dData,cLoja,cFilTit,dDtIni,dDtFin,lConsDtBas,lMovM2,__oTBxCanc)

/*----------------------------------------------------------------
	Não converter para FKs.
	-----------------------
	Usado nos fontes FINA040 e FINA330
	F040TotMes: condicionado a retenção de impostos na emissão e 
				data anterior a 22/06/15
	F330ActImp: chamado no estono da compensação de NCC.
	Alinhado com Nagy em 20/01/2021
  ----------------------------------------------------------------*/

Static aMotBaixas
Static lFVerRstFin 	:= .t.
Static nTamTit		:= 0
Static lE5Origem
Static _lPCCBaixa
Static _lContrRet
Static _lImpComp
Static _lRastro
Static lVlAcreDesc

Local aRetorno		:= {0,0,0,0,0,0,0,0," ",0,0,0,0,0,0,0,0,0,0,0}
Local aArea			:= getArea()
Local nMoedaTit
Local lNaoConv
Local aMotBx 		:= {}
Local nI 			:= 0
Local nT 			:= 0
Local lDataNil 		:= ( dData == Nil )
Local nMoedaCalc	:= 0
Local cQuery		:= ""
Local cAliasSE5		:= getNextAlias()
Local nTxMDest		:= 0
Local nTxMOrig		:= 0
Local nTxContr		:= 0

Default _lImpComp 	:= SuperGetMv("MV_IMPCMP",,"2") == "1"
Default lVlAcreDesc := .T.
Default _lRastro 	:= If(lFVerRstFin, FVerRstFin(),.F.) .and. SuperGetMV("MV_NRASDSD",.T.,.F.) //Rastreamento
Default lE5Origem	:= .T.  //se a origem da Baixa é do SIGALOJA e TipoDoc for VL , não usa na composicao do valor da baixa
Default cFilTit		:= xFilial("SE5")
Default lConsDtBas 	:= .T.
Default nTamTit		:= TamSX3("E1_PREFIXO")[1]+TamSX3("E1_NUM")[1]+TamSX3("E1_PARCELA")[1]+1
Default _lPCCBaixa	:= SuperGetMv("MV_BX10925",.T.,"2") == "1"
Default _lContrRet	:= .T.
Default lMovM2		:= .F.

If aMotBaixas == NIL
	// Monto array com codigo e descricao do motivo de baixa
	aMotBx := ReadMotBx()
	aMotBaixas := {}
	For NI := 1 to Len(aMotBx)
		AADD( aMotBaixas,{substr(aMotBx[nI],01,03),substr(aMotBx[nI],07,10)})
	Next
Endif

// Quando eh chamada do Excel, estas variaveis estao em branco
IF Empty(MVABATIM) .Or.;
	Empty(MV_CRNEG) .Or.;
	Empty(MVRECANT) .Or.;
	Empty(MV_CPNEG) .Or.;
	Empty(MVPAGANT) .Or.;
	Empty(MVPROVIS)
	CriaTipos()
Endif

cFornec	:= IIF( cFornec == NIL , "", cFornec )
cLoja 	:= IIF( cLoja == NIL , "" , cLoja )
nMoeda	:= IIf( nMoeda == NIL , 1 , nMoeda )

dData	:= IIf( lDataNil , dDataBase , dData )
dDtIni	:= IIf( dDtIni == NIL ,CTOD("//") , dDtIni )
dDtFin	:= IIf( dDtFin == NIL ,CTOD("//") , dDtFin )

cQuery := " SELECT E5_FILIAL, E5_PREFIXO , E5_NUMERO , E5_PARCELA , E5_TIPO , E5_BANCO , E5_MOEDA , E5_RECPAG , E5_CLIFOR, E5_LOJA , "
cQuery += " E5_DATA , E5_TIPODOC, E5_VALOR , E5_TXMOEDA , E5_MOTBX , E5_VLMOED2 , E5_VRETPIS , E5_VRETCOF , E5_VRETCSL , "
cQuery += " E5_VLACRES , E5_VLDECRE , E5_SEQ, E5_PRETPIS, E5_DOCUMEN "
If lE5Origem
	cQuery += ", E5_ORIGEM "
EndIf
cQuery += " FROM "+RetSqlName("SE5")
cQuery += Iif(FunName() $ "FINR350|FINA410" .And. !Empty(cFilTit), " WHERE (E5_FILIAL = '"+cFilTit+"' OR E5_FILORIG = '"+cFilTit+"') ", " WHERE E5_FILIAL = '"+cFilTit+"' ")
cQuery += " AND E5_PREFIXO = '"+cPrefixo+"' "
cQuery += " AND E5_NUMERO = '"+cNumero+"' "
cQuery += " AND E5_PARCELA = '"+cParcela+"' "
cQuery += " AND E5_TIPO = '"+cTipo+"' "
cQuery += " AND E5_CLIFOR = '"+cFornec+"' "
cQuery += " AND E5_LOJA = '"+cLoja+"' "
cQuery += " AND E5_SITUACA != 'C' "
cQuery += " AND E5_TIPODOC != 'ES' "
IF lConsDtBas
	If lDataNil
		cQuery += " AND ( E5_DATA <= '" + DtoS(dDataBase) + "' "
	Else
		cQuery += " AND ( E5_DATA <= '" + Dtos(Min( dData , dDataBase) ) + "' "
	Endif
	cQuery += " ) "
Endif
If !Empty(dDtIni)
	cQuery += " AND ( E5_DATA BETWEEN '"+DtoS(dDtIni)+"' AND '"+DtoS(dDtFin)+"' ) "
Endif
cQuery += " AND D_E_L_E_T_ = ' ' "

dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasSE5 , .F., .T.)

nMoedaTit := Iif( cModo == "R", SE1-> E1_MOEDA , SE2 -> E2_MOEDA )

While (cAliasSE5)->( !EOF() )

	//Nas localizacoes e usada a movimentacao bancaria em mais de uma moeda
	//por isso, quando a baixa for contra um banco, devo pegar a E5_VLMOED2,
	//pois na E5_VALOR, estara grvado o movimento na moeda do banco.
	//Bruno. Paraguay 23/08/00
	lNaoConv	:=	(nMoeda == 1 .And.(cPaisLoc=="BRA".Or.Empty(E5_BANCO)).or.( nMoeda==Val( (cAliasSE5)->E5_MOEDA) .And. cPaisLoc<>"BRA" .And. !Empty(E5_BANCO)) )
	Do Case
		// Despresa as movimenta‡oes diferentes do tipo solicitado somente se
		// o tipo for != de RA e PA, pois neste caso o RECPAG sera invertido.
		Case (cAliasSE5)->E5_RECPAG != cModo .AND. !( (cAliasSE5)->E5_TIPO $ MVRECANT+"/"+MVPAGANT+"/"+MV_CRNEG+"/"+MV_CPNEG) ;
			.AND. E5_TIPODOC != "CM"
			dbSkip()
			Loop
		Case TemBxCanc( (cAliasSE5)->( E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ ),,(cAliasSE5)->E5_FILIAL, __oTBxCanc )
			dbSkip()
			Loop
		Case lE5Origem .AND. AllTrim((cAliasSE5)->E5_ORIGEM) == 'LOJXREC' .AND. (cAliasSE5)->E5_TIPODOC $ "VL"
			dbSkip()
			Loop
		Case (cAliasSE5)->E5_TIPODOC $ "VLüBA/V2/CP/LJ"
			IF cModo == "R"
				If Alltrim(FunName()) $ "FINR340"  .And. cPaisLoc == "MEX"
					aRetorno[5]+=xMoeda((cAliasSE5)->E5_VALOR,Val((cAliasSE5)->E5_MOEDA),nMoeda,(cAliasSE5)->E5_DATA,,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,))
				ElseIf  Alltrim(FunName()) $ "FINR340" .and. cPaisLoc == "BRA"

					nTxMDest := nTxMOrig := nTxContr := 0					
										
					if (cAliasSE5)->E5_TXMOEDA > 1 
						if (nMoeda == nMoedaTit .or. nMoeda == 1) 
							if nMoeda == 1 .and. Val((cAliasSE5)->E5_MOEDA) == nMoedaTit
								nTxMOrig := (cAliasSE5)->E5_TXMOEDA  
							elseIf nMoeda == nMoedaTit .and. Val((cAliasSE5)->E5_MOEDA) <> nMoedaTit
								nTxMDest := (cAliasSE5)->E5_TXMOEDA 
							endIf
						else 
							nTxMOrig := (cAliasSE5)->E5_TXMOEDA  
						endIf
					elseif nMoedaTit > 1 .And. Val((cAliasSE5)->E5_MOEDA) == nMoedaTit //Titulo e baixa na mesma moeda estrangeira o E5_TXMOEDA nao grava a taxa de conversão
						nTxContr := SE1->E1_TXMOEDA
						nTxMOrig := If(nTxContr > 0 , nTxContr , RecMoeda((cAliasSE5)->E5_DATA, Val((cAliasSE5)->E5_MOEDA))) // Se nao possuir taxa contratada no titulo, utiliza taxa do dia do movimento (SM2), se nao pega da SM2
					endIf
					aRetorno[5] += xMoeda( (cAliasSE5)->E5_VALOR, Val((cAliasSE5)->E5_MOEDA), nMoeda,(cAliasSE5)->E5_DATA, /*decimais*/, nTxMOrig, nTxMDest)
				
				else
					aRetorno[5]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda((cAliasSE5)->E5_VLMOED2,nMoedaTit,nMoeda,(cAliasSE5)->E5_DATA,,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,)))
				EndIf
				If (cAliasSE5)->E5_MOTBX == "CMP" .and. SUBSTR((cAliasSE5)->E5_DOCUMEN,nTamTit,3) == MV_CRNEG  //NCC
					aRetorno[13]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda((cAliasSE5)->E5_VALOR,nMoedaTit,nMoeda,(cAliasSE5)->E5_DATA,,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,)))
					If _lImpComp
						//Retorno valores de Pis e Cofins para as compensacoes
						aRetorno[14]+= (cAliasSE5)->E5_VRETPIS
						aRetorno[15]+= (cAliasSE5)->E5_VRETCOF
						aRetorno[18]+= (cAliasSE5)->E5_VRETCSL
					Endif
				Endif
				//Retorno valor baixado via liquidacao
				If (cAliasSE5)->E5_MOTBX == "LIQ"
					aRetorno[19]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda((cAliasSE5)->E5_VALOR,nMoedaTit,nMoeda,(cAliasSE5)->E5_DATA,,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,)))
				Endif

				//Retorno valor baixado via Desdobramento com rastro
				If (cAliasSE5)->E5_MOTBX == "DSD" .and. _lRastro
					aRetorno[20]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda((cAliasSE5)->E5_VALOR,nMoedaTit,nMoeda,(cAliasSE5)->E5_DATA,,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,)))
				Endif
			Else
				//Baixa PA nao deve ser considerada
				If !((cAliasSE5)->E5_TIPODOC == "BA" .and. (cAliasSE5)->E5_TIPO == "PA " .and. (cAliasSE5)->E5_RECPAG == "P" .and. (cAliasSE5)->E5_MOTBX <> "CMP")

					//Se nao converte
					If (lNaoConv .And. cPaisLoc == "BRA") .Or. (cPaisLoc <> "BRA" .And. nMoeda == nMoedaTit)
						If cPaisLoc == "BRA" .And. !lMovM2 .And. FwIsInCallStack("FINR350") .And. MovMoedEs((cAliasSE5)->E5_MOEDA, (cAliasSE5)->E5_TIPODOC, (cAliasSE5)->E5_MOTBX, (cAliasSE5)->E5_DATA)
							aRetorno[6] += (cAliasSE5)->E5_VLMOED2
						Else
							aRetorno[6]+=	If((cAliasSE5)->E5_TIPODOC == "BA" .and. (cAliasSE5)->E5_TIPO == "PA " .and. (cAliasSE5)->E5_RECPAG == "P" .and. (cAliasSE5)->E5_MOTBX <> "CMP",0,Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda(Iif(cpaisLoc=="BRA",(cAliasSE5)->E5_VLMOED2,(cAliasSE5)->E5_VALOR),Iif(!Empty((cAliasSE5)->E5_MOEDA).And. cPaisLoc<>"BRA",Val((cAliasSE5)->E5_MOEDA),nMoedaTit),nMoeda,(cAliasSE5)->E5_DATA,,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,))))
						EndIf
					Else
						//Se pais for Brasil ou
						// (Se a moeda do movimento estiver preenchida em outros paises ou
						//	 Se o registro for de compensacao
						//		(neste caso a moeda nao eh gravada e o valor na moeda do titulo esta no E5_VLMOED2)	)
						If cPaisLoc=="BRA" .Or. (( !Empty((cAliasSE5)->E5_MOEDA) .OR. (cAliasSE5)->E5_MOTBX == 'CMP') .And. cPaisLoc<>"BRA" )
							If FwIsInCallStack("FINR350") .And. MovMoedEs((cAliasSE5)->E5_MOEDA, (cAliasSE5)->E5_TIPODOC, (cAliasSE5)->E5_MOTBX, (cAliasSE5)->E5_DATA)
								nValor := Iif(lMovM2, (cAliasSE5)->E5_VALOR, (cAliasSE5)->E5_VLMOED2)
							Else
								nValor := (cAliasSE5)->E5_VLMOED2
							EndIf
						Else
							nValor := (cAliasSE5)->E5_VALOR
						Endif
						//Forço o valor para localização diferente de Brasil
						If cPaisLoc <> "BRA"
							nValor := (cAliasSE5)->E5_VALOR
						EndIf

						nMoedaCalc := IF(!Empty((cAliasSE5)->E5_MOEDA).And. cPaisLoc<>"BRA",Val((cAliasSE5)->E5_MOEDA),nMoedaTit)
						aRetorno[6]+= xMoeda(nValor,nMoedaCalc,nMoeda,STOD(((cAliasSE5)->E5_DATA)))
				Endif
			Endif

				If _lContrRet .And. _lPCCBaixa .And. ((cAliasSE5)->E5_PRETPIS $ " #3")
					aRetorno[12]+= (cAliasSE5)->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)
				Endif
			Endif
			aRetorno[10]+= (cAliasSE5)->E5_VALOR
			aRetorno[11]+= 1   // Numero de baixas

			If lVlAcreDesc
				aRetorno[16] += (cAliasSE5)->E5_VLACRES
				aRetorno[17] += (cAliasSE5)->E5_VLDECRE
			Endif

		Case (cAliasSE5)->E5_TIPODOC $ "DC/D2"
				aRetorno[2]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda((cAliasSE5)->E5_VLMOED2,nMoedaTit,nMoeda,STOD((cAliasSE5)->E5_DATA),Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,)))
		Case (cAliasSE5)->E5_TIPODOC $ "JR/J2"
				aRetorno[3]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda(Iif(cpaisLoc=="BRA",(cAliasSE5)->E5_VLMOED2,(cAliasSE5)->E5_VALOR),Iif(!Empty((cAliasSE5)->E5_MOEDA).And. cPaisLoc<>"BRA",Val((cAliasSE5)->E5_MOEDA),nMoedaTit),nMoeda,STOD((cAliasSE5)->E5_DATA),,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,)))
		Case (cAliasSE5)->E5_TIPODOC $ "MT/M2"
				aRetorno[4]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda((cAliasSE5)->E5_VLMOED2,nMoedaTit,nMoeda,STOD((cAliasSE5)->E5_DATA)))
		Case (cAliasSE5)->E5_TIPODOC $ "CM/C2/CX"
				aRetorno[1]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda(Iif(cpaisLoc=="BRA",(cAliasSE5)->E5_VLMOED2,(cAliasSE5)->E5_VALOR),Iif(!Empty((cAliasSE5)->E5_MOEDA) .And. cPaisLoc<>"BRA",Val((cAliasSE5)->E5_MOEDA),nMoedaTit),nMoeda,STOD((cAliasSE5)->E5_DATA),,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,)))
		Case (cAliasSE5)->E5_TIPODOC $ "RA /"+MV_CRNEG
				aRetorno[7]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda((cAliasSE5)->E5_VLMOED2,nMoedaTit,nMoeda,STOD((cAliasSE5)->E5_DATA)))
		Case ((cAliasSE5)->E5_TIPODOC = "PA" .Or. (cAliasSE5)->E5_TIPO = "PA") .or. (cAliasSE5)->E5_TIPODOC $ MV_CPNEG
				aRetorno[8]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda(Iif(cpaisLoc=="BRA",(cAliasSE5)->E5_VLMOED2,(cAliasSE5)->E5_VALOR),Iif(!Empty((cAliasSE5)->E5_MOEDA) .And. cPaisLoc<>"BRA",Val((cAliasSE5)->E5_MOEDA),nMoedaTit),nMoeda,STOD((cAliasSE5)->E5_DATA),,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,)))
	EndCase

	If ! Empty((cAliasSE5)->E5_MOTBX )
		If (cAliasSE5)->E5_MOTBX == "NOR"
			aRetorno[9] := OemToAnsi( STR0008) //"Normal"
		Elseif (cAliasSE5)->E5_MOTBX == "DEV"
			aRetorno[9] := OemToAnsi( STR0009) //"Devolução"
		Elseif (cAliasSE5)->E5_MOTBX == "DAC"
			aRetorno[9] := OemToAnsi( STR0017)	//"DAÇÃO"
		Elseif (cAliasSE5)->E5_MOTBX == "VEN"
			aRetorno[9] := OemToAnsi( STR0010) //"VENDOR"
		Elseif (cAliasSE5)->E5_MOTBX == "CMP"
			aRetorno[9] := OemToAnsi( STR0011) //"Compensação"
		Elseif (cAliasSE5)->E5_MOTBX == "CEC"
			aRetorno[9] := OemToAnsi( STR0012) //"Comp Carteiras"
		Elseif (cAliasSE5)->E5_MOTBX == "DEB"
			aRetorno[9] := OemToAnsi( STR0013) //"Débito C/C"
		Elseif (cAliasSE5)->E5_MOTBX == "LIQ"
			aRetorno[9] := OemToAnsi( STR0014) //"Liquidação"
		Elseif (cAliasSE5)->E5_MOTBX == "FAT"
			aRetorno[9] := OemToAnsi( STR0015) //"Faturado"
		Else
			IF (nT := ascan(aMotBaixas,{|x| x[1]= (cAliasSE5)->E5_MOTBX })) > 0
				aRetorno[9] := aMotBaixas [nT][2]
			Endif
		Endif
	Endif
	(cAliasSE5)->( dbSkip() )
Enddo
(cAliasSE5)->( dbCloseArea() )

RestArea(aArea)

Return(aRetorno)

//-----------------------------------------------------------------------------------------
// Funcoes retiradas do arquivo MATXFUNB.PRX
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FAJUROS

Calculo de juros.
Arquivo anterior: MATXFUNB.PRX

Parametros
ExpN1	: Valor do Titulo
ExpN2	: Saldo do Titulo a ser considerado Def.:E1_SALDO
ExpD3  	: Data de vencimento do Titulo.
ExpN4  	: Valor do Juros do Titulo
ExpN5  	: Taxa de Permanencia.
ExpN6  	: Moeda em que se encontra o Titulo
ExpD7  	: Data de Emissao.
ExpD8  	: Data de Baixa.


@Author	Eduardo Riera
@since	31/12/1999
/*/
//-----------------------------------------------------------------------------------------------------
Function faJuros(nVlrTit,nSaldo,dVencto,nValJur,nPerJur,nMoeda,dEmissao,dBaixa,nTxMoeda,dUltBaixa,dVencRea,cAliasSe1,cPrefixo,cNum,cParcela,cTipo,lRecalc,lLiquida, lJurDevido, nBaseJuros)
Local aAreaSE1		:= {}
Local nAtraso		:= 0
Local nTxPer		:= 0
Local nJuros		:= 0
Local nAtrSimp		:= 0
Local nSaldoC		:= 0
Local cMvJurTipo	:= SuperGetMv("MV_JURTIPO",,"M")
Local nMVFINJRTP	:= SuperGetMv("MV_FINJRTP",,1)
Local nDiasAtraso	:= 0
Local lSE1 			:= .F.
Local lRestSE1 		:= .F.

Default dUltBaixa 	:= dVencto
Default cNum        := ""
Default cPrefixo  	:= ""
Default cParcela  	:= ""
Default __lNewJuros	:= Existblock("NEWJUROS")
Default __lFJURREC	:= Existblock("FJURREC")
Default lRecalc		:= .T.
Default lLiquida	:= .F.
Default cAliasSe1	:= "SE1"
Default cTipo		:= (cAliasSe1)->E1_TIPO
Default nPerJur		:= 0
Default lJurDevido	:= .F.
Default nBaseJuros	:= 0

If FwIsInCallStack('MaIntBxCr') .And. AllTrim( cTipo ) $ "RA"
	Return nJuros
EndIf

//-------------------------------------------------------------------
// Se função que chamar a faJuros tiver posicionada no SE1
// deverá passar apenas o ALIAS do SE1, caso contrário não
// passar o alias e apenas a Chave do SE1 para o faJuros posicionar
//-------------------------------------------------------------------
nTxMoeda	:= If( nTxMoeda == Nil			, 0			, nTxMoeda										)
dBaixa		:= If( dBaixa == Nil			, dDataBase	, dBaixa										)
nVlrTit		:= If( nVlrTit == Nil			, nSaldo	, nVlrTit										)

If !lJurDevido
	dVencto		:= If( Day(dUltBaixa) == 0		, dVencto	, If(dUltBaixa > dVencto, dUltBaixa, dVencto)	)
EndIf
dVencRea	:= If( dVencRea == Nil			, dVencto	, dVencRea										)
nAcresc		:= If( Type("nAcresc") != "N"	, 0			, nAcresc										)
nDecresc	:= If( Type("nDecresc") != "N"	, 0			, nDecresc										)

If ( DataValida(dVencto,.T.) >= dBaixa ) .AND. cMvJurTipo <> "L"
	dVencto := DataValida(dVencto,.T.)
EndIf

// Verifico se são as funções de Liquidação, pois
// para a liquidação existe a baixa de um titulo porém
// ocorre a criação de novos titulos com datas de vencimentos
// futuras que necessita a cobraça de juros
If lLiquida
	nAtraso := dVencto - dBaixa
	cAliasSe1	:= ""
	If dVencRea <= dBaixa
		nAtraso := 0
	EndIf
Else
	nAtraso := dBaixa - dVencto
	//Se a data de pagamento for menor ou igual que o vencimento real nao calculo juros
	If dBaixa <= dVencRea
		nAtraso := 0
	EndIf
EndIf

If ( Dow(dVencto) == 1 .Or. Dow(dVencto) == 7 ) .AND. cMvJurTipo <> "L"
	If Dow(dBaixa) == 2 .and. nAtraso <= 2
		nAtraso := 0
	EndIf
EndIf
If __lNewJuros
	nAtraso := Execblock("NEWJUROS",.f.,.f.,{dBaixa,dVencto,nAtraso})
Endif

nAtraso:=Iif(nAtraso<0,0,nAtraso)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Compara dias de atraso com o parametro tolerancia de atraso  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nAtraso <= SuperGetMv("MV_TOLER",,0)
	nAtraso := 0
EndIf

//Ponto de entrada para cálculo de juros
Default __lFJURCST := Existblock("FJURCST")
If !__lFJURCST
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Quando nÆo houver percentual de juros no t¡tulo deve-se cal- ³
	//³ cular pela taxa de permanencia. Quando ha percentual ou ele  ³
	//³ se refere a taxa de permanencia ou ele foi informado manual- ³
	//³ mente na inclusao do titulo a receber.							  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( nAtraso != 0 .And. (!Empty(nValJur) .Or. !Empty(nPerJur)) )
		If !Empty( nValJur ) .and. nMVFINJRTP == 1 		//  MV_FINJRTP = 1.Tx Perm
			nJuros := nValJur * nAtraso
		Else //MV_FINJRTP = 2.Juros ou 3.Ambos
			nTxPer := nPerJur
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Calcula os juros compostos caso o parƒmetro seja "C";     ³
			//³ Calcula os juros simples caso o parametro seja "S"  ;     ³
			//³ Calcula os juros mistos  caso o parametro seja "M".       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cMvJurTipo == "M" .Or. cMvJurTipo == "S"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Calcula os juros simples											  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ( cMvJurTipo == "M")
					nAtrSimp := If( nAtraso > 30 , 30 , nAtraso )
				Else
					nAtrSimp := nAtraso
				EndIf
				nJuros := nSaldo*(1+(nAtrSimp*(nTxPer/100)))
				nDiasAtraso := nAtraso
				nAtraso := Iif(cMvJurTipo == "M", nAtraso-30, nAtraso )
			ElseIf nMVFINJRTP == 3 .and. !Empty( nValJur )  // MV_FINJRTP = 3.Ambos
				nDiasAtraso := nAtraso
			EndIf
			If ( cMvJurTipo=="M" .And. nAtraso > 0 ) .Or. cMvJurTipo=="C"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Calcula os juros compostos										  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If cMvJurTipo == "C"
					nSaldoC := nSaldo
				Else
					nSaldoC := nJuros
				EndIf
				nJuros := nSaldoC *( (1+( nTxPer/100 ) ) ** nAtraso )
			EndIf
			nJuros := nJuros - nSaldo
			If nMVFINJRTP == 3 .and. !Empty( nValJur )  // MV_FINJRTP = 3.Ambos
				nJuros := nJuros + (nValJur * nDiasAtraso)
      	  EndIf

      	  	//Integração TIN x PROTHEUS
      	  	If AllTrim(SE1->E1_ORIGEM) == "FINI055"
      	  		nTxPer := SE1->E1_VALJUR
     	  		If SuperGetMv("MV_JURTIN",,.F.)
					nJuros := (((nSaldo + nAcresc - nDecresc)*(1+(nAtrSimp*(nTxPer/100)))) - (nSaldo+ nAcresc - nDecresc))
					nMulta := (nPerJur/100) * (nSaldo + nAcresc - nDecresc)
      	  		Else
      	  			nJuros := ((nSaldo *(1+(nAtrSimp*(nTxPer/100)))) - nSaldo) + (nValJur * nDiasAtraso)
      	  			nMulta := (nPerJur/100) * nSaldo
      	  		EndIf
      	  	Endif
		EndIf
	EndIf

	//Calculo de Juros e Multas: SIGALOJA x SIGAFIN - Inicio
	If cMvJurTipo == "L" .AND. lRecalc .and. !(cTipo $ MVRECANT+"|"+MV_CRNEG)    //Calculo de Juros e dias de atraso, segundo o controle de Lojas

		nJuros := 0

		If cAliasSE1 == "SE1" .AND. !Empty(cPrefixo+cNum+cParcela)
			aAreaSE1 := GetArea(cAliasSE1)
			lRestSE1 := .T.
		    (cAliasSE1)->(dbSetOrder(1))   // E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO
			lSE1 := (cAliasSE1)->(MsSeek(xFilial(cAliasSe1)+cPrefixo+cNum+cParcela+cTipo))
		Else
			lSE1 := !Empty(cAliasSE1)
		EndIf

		If lSE1
			//-------------------------------------------------------
			// Calcula o Juros Função: LojxRJur - Lojxrec
			//-------------------------------------------------------
			//Caso o percentual de juros seja igual a zero, obtenho do parâmetro de % de juros do SigaLoja
			If Empty(nPerJur)
				nPerJur := SuperGetMV("MV_LJJUROS", NIL, 0)
			EndIf
			If nBaseJuros > 0
				nJuros := LojxRJur( , ,nPerJur, nAtraso, nBaseJuros, (cAliasSe1)->E1_ACRESC, cAliasSe1, , (cAliasSe1)->E1_MOEDA, dBaixa,(cAliasSE1)->E1_VENCREA)
			Else
		  		nJuros := LojxRJur( , ,nPerJur, nAtraso, (cAliasSe1)->E1_SALDO, (cAliasSe1)->E1_ACRESC, cAliasSe1, , (cAliasSe1)->E1_MOEDA, dBaixa,(cAliasSE1)->E1_VENCREA)
			EndIf
		ElseIf lLiquida .AND. !lSE1
	  		nJuros := FinxRJur( nPerJur, nAtraso, nSaldo, nMoeda, dBaixa, dVencto )
		EndIf

		If lRestSE1
			RestArea(aAreaSE1)
		EndIf

	EndIf
	//Calculo de Juros e Multas: SIGALOJA x SIGAFIN  - Final
Else
	nJuros := Execblock("FJURCST",.f.,.f.,{dBaixa,dVencto,nAtraso,nValJur,nPerJur})
EndIf

// Ponto de entrada para recalculo do Juros
If __lFJURREC
   nJuros := Execblock("FJURREC",.f.,.f.,{dBaixa,dVencto,nAtraso,nValJur,nPerJur,nJuros,cAliasSE1})
Endif

Return(nJuros)
//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070JUROS

Calculo de juros.
Arquivo anterior: MATXFUNB.PRX

@Param ExpN1	: Moeda
@Param ExpN2	: Valor do Titulo a ser considerado Def.:E1_SALDO
@Param dBaixa 	: Data em que o juros sera pago.
@Param nJuros 	: Valor do Juros do Titulo
@Param nTxMd	: Taxa da moeda
@Param lJurDevido : se chamada é do relatório de juros devidos (FINR290)
@param lSldRetro  : se verdadeiro, considera o parâmetro dUltBaixa para execução da função FaJuros.

Observacao
Os parametros dBaixa e nJuros devem ser variaveis Privates
declaradas antes da chamada da funcao. E o titulo deve estar
posicionado.

@Author	Wagner Xavier
@since	06/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function Fa070Juros(nMoeda, nVlrTit, cAlias, dUltBaixa, nTxMd, lJurDevido, lSldRetro)

	Local nTxMoeda	:= 0
	Local aArea		:= GetArea()
	Local aAreaSE1	:= SE1->(GetArea())
	Local aAreaSE5	:= SE5->(GetArea())
	Local cIdDoc	:= ""
	Local cChaveTit	:= ""

	If cAlias == NIL
		cAlias := "SE1"
	Endif

	nMoeda	:= If(nMoeda == Nil, 1, nMoeda)
	nVlrTit	:= If(nVlrTit == Nil, (cAlias)->E1_SALDO, nVlrTit)
	dBaixa	:= If(Type("dBaixa") == "U", dDataBase, dBaixa)

	If nTxMd == Nil
		nTxMoeda := If(cPaisLoc == "BRA", (cAlias)->E1_TXMOEDA, 0)
	Else
		nTxMoeda := nTxMd
	EndIf

	Default dUltBaixa 	:= (cAlias)->E1_BAIXA
	Default lJurDevido	:= .F.
	Default lSldRetro	:= .F.

	If !lSldRetro .And. !(Empty(dUltBaixa)) // indica que o título já sofreu baixa

		cChaveTit	 := xFilial("SE1") + "|" + (cAlias)->E1_PREFIXO + "|" + (cAlias)->E1_NUM + "|" + (cAlias)->E1_PARCELA + "|" +;
						(cAlias)->E1_TIPO   + "|" + (cAlias)->E1_CLIENTE + "|" + (cAlias)->E1_LOJA

		cIdDoc		:= FINBuscaFK7(cChaveTit, "SE1")

		dUltBaixa	:= fAUltBxcr(cIdDoc)//Chamar função que retorna a data da ultima baixa valida
	EndIf

	//Calculo de Juros e Multas: SIGALOJA x SIGAFIN
	nJuros := faJuros((cAlias)->E1_VALOR, nVlrTit, (cAlias)->E1_VENCTO, (cAlias)->E1_VALJUR, (cAlias)->E1_PORCJUR, (cAlias)->E1_MOEDA, (cAlias)->E1_EMISSAO, dBaixa, nTxMoeda, dUltBaixa, (cAlias)->E1_VENCREA, cAlias, /*cPrefixo*/, /*cNum*/, /*cParcela*/, /*cTipo*/, /*lRecalc*/, /*lLiquida*/, lJurDevido, IIf(lSldRetro, nVlrTit, 0))

	//Aplica desconto nos juros do titulo
	If (cAlias)->(FieldPos("E1_DESCJUR")) > 0
		If !Empty((cAlias)->E1_LIDESCF) .And. (dBaixa <= (cAlias)->E1_LIDESCF)
			nJuros := nJuros - Round((((cAlias)->E1_DESCJUR / 100) * nJuros), 2)
		EndIf
	EndIf

	// Converte o valor dos juros para moeda solicitada
	nJuros := xMoeda(nJuros, (cAlias)->E1_MOEDA, nMoeda, dDataBase,, nTxMoeda)
	nJuros := Round(nJuros,TamSx3('E5_VALOR')[2])

	// 
	// Template GEM - Executa os calculos das variaveis private: nCM1, nProRata, nMulta, nJuros
	Default __lGEMJUROS  := ExistTemplate("GEMJUROS")
	Default __lE1_NCONTR := ((cAlias)->(FieldPos("E1_NCONTR")) > 0)

	If __lGEMJUROS .And. __lE1_NCONTR .And. !Empty((cAlias)->E1_NCONTR)
		ExecTemplate("GEMJUROS", .F., .F., {cAlias, dBaixa, dUltBaixa, nVlrTit})
	EndIf

	RestArea(aAreaSE5)
	RestArea(aAreaSE1)
	RestArea(aArea)

Return(nJuros)

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} GetNewLote

Retorna um codigo valido para novo lote (E5_LOTE)
Obs: Recomendado utilizar esta funcao apos validacao da CheckLote()

@Author	igor.nascimento
@since	14/06/2016
/*/
//-----------------------------------------------------------------------------------------------------
Function GetNewLote() as Character

	Local cLote		as Character
	Local cQuery	as Character
	Local cMaxFk1   as Character
	Local cMaxFk2   as Character
	Local cMaxFk5   as Character
	Local cTmpFK1	as Character
	Local cTmpFK2	as Character
	Local cTmpFK5	as Character

	Local nTmFk1Mx  as Numeric
	Local nTmFk2Mx  as Numeric
	Local nTmFk3Mx  as Numeric
	Local nTmLoSx3  as Numeric	

	cLote		:= ""
	cQuery	    := ""
	cMaxFk1     := ""
	cMaxFk2     := ""
	cMaxFk5     := ""

	nTmFk1Mx    := 0
	nTmFk2Mx    := 0
	nTmFk3Mx    := 0	
	nTmLoSx3  := TamSx3("EE_LOTECP")[1]

	cTmpFK1	:= GetNextAlias()
	cTmpFK2	:= GetNextAlias()
	cTmpFK5	:= GetNextAlias()

	cQuery := "SELECT MAX(FK1_LOTE) FK1LOTE "
	cQuery += "FROM " + RetSqlName("FK1") + " FK1 "
	cQuery += "WHERE "
	cQuery += "FK1.FK1_FILIAL = '" + xFilial("FK1") + "' And "
	cQuery += "FK1.FK1_LOTE <> '' And "
	cQuery += "FK1.D_E_L_E_T_ = ' ' "
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TCGenQry(,,cQuery),cTmpFK1,.F.,.T.)

	cQuery := "SELECT MAX(FK2_LOTE) FK2LOTE "
	cQuery += "FROM " + RetSqlName("FK2") + " FK2 "
	cQuery += "WHERE "
	cQuery += "FK2.FK2_FILIAL = '" + xFilial("FK2") + "' And "
	cQuery += "FK2.FK2_LOTE <> '' And "
	cQuery += "FK2.D_E_L_E_T_ = ' ' "
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TCGenQry(,,cQuery),cTmpFK2,.F.,.T.)

	cQuery := "SELECT MAX(FK5_LOTE) FK5LOTE "
	cQuery += "FROM " + RetSqlName("FK5") + " FK5 "
	cQuery += "Where "
	cQuery += "FK5.FK5_FILIAL = '" + xFilial("FK5") + "' And "
	cQuery += "FK5.FK5_LOTE <> '' And "
	cQuery += "FK5.D_E_L_E_T_ = ' ' "
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TCGenQry(,,cQuery),cTmpFK5,.F.,.T.)

	If (cTmpFK1)->(Eof()) .AND. (cTmpFK2)->(Eof())  .AND. (cTmpFK5)->(Eof()) 
		cLote := StrZero( 1, nTmLoSx3 )
	Else
		If (cTmpFK5)->FK5LOTE >= (cTmpFK1)->FK1LOTE .AND. (cTmpFK5)->FK5LOTE >= (cTmpFK2)->FK2LOTE
			cMaxFk5 := AllTrim((cTmpFK5)->FK5LOTE)
			nTmFk5Mx := Len(cMaxFk5)
			If nTmFk5Mx < nTmLoSx3 .AND. Upper(cMaxFk5) == REPLICATE("Z",nTmFk5Mx) 		
				cLote := Padr(cMaxFk5, nTmLoSx3, "0")
			Else
				cLote := FinSomaLote((cTmpFK5)->FK5LOTE)		// Retorna um numero de lote valido
			Endif
		ElseIf (cTmpFK1)->FK1LOTE >= (cTmpFK2)->FK2LOTE
			cMaxFk1 := AllTrim((cTmpFK1)->FK1LOTE)
			nTmFk1Mx := Len(cMaxFk1)
			If nTmFk1Mx < nTmLoSx3 .AND. Upper(cMaxFk1) == REPLICATE("Z",nTmFk1Mx)
				cLote := Padr(cMaxFk1, nTmLoSx3, "0")
			Else
				cLote := FinSomaLote((cTmpFK1)->FK1LOTE)		// Retorna um numero de lote valido
			Endif
		Else
			cMaxFk2 := AllTrim((cTmpFK2)->FK2LOTE)
			nTmFk2Mx := Len(cMaxFk2)
			If nTmFk2Mx < nTmLoSx3 .AND. Upper(cMaxFk2) == REPLICATE("Z", nTmFk2Mx)
				cLote := Padr(cMaxFk2, nTmLoSx3, "0")
			Else				
				cLote := FinSomaLote((cTmpFK2)->FK2LOTE)		// Retorna um numero de lote valido
			Endif
		EndIf
	EndIf
	
	(cTmpFK1)->(dbCloseArea())
	(cTmpFK2)->(dbCloseArea())
	(cTmpFK5)->(dbCloseArea())		
	MsErase(cTmpFK1)
	MsErase(cTmpFK2)	
	MsErase(cTmpFK5)	

Return cLote


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FxIniStat
Inicializa Staticas

@Author	Mauricio Pequim Jr
@since	02/01/2017
/*/
//-----------------------------------------------------------------------------------------------------
Static Function FxIniStat()

If lFA070ADTSE5 == NIL
	lFA070ADTSE5	:= ExistBlock("FA070ADTSE5")
	lf70GrSe1	 	:= Existblock("F70GRSE1")
	lF200GERA		:= Existblock("F200GERA")
	lF070CM			:= ExistBlock("F070CM")
	lF070GerAb		:= ExistBlock("F070GerAb")
	lFinSalTit		:= ExistBlock("FinSalTit")
	lF070GrvHis		:= ExistBlock("F070GrvHis")
	lFin70BxIr		:= ExistBlock("Fin70BxIr")
	lF070IRAB		:= ExistBlock("FIN70IRAB")
	lF070Imp2		:= ExistBlock("F070Imp2")
	lFa070Imp		:= ExistBlock("Fa070Imp")
	lF070HIST		:= ExistBlock("F070HIST")
	lFINAJURO		:= ExistBlock("FINAJURO")
	lF070DISS		:= ExistBlock("F070DISS")
	lSE3FI070		:= ExistBlock("SE3FI070")
	lSE3F070		:= ExistBlock("SE3F070")
	lF070MV1		:= ExistBlock("F070MV1")
	lF70E5ADT		:= ExistBlock("F70E5ADT")
	lSE5FI070		:= ExistBlock("SE5FI070")
	lF070VMOT		:= ExistBlock("F070VMOT")
	lFA070CMI		:= ExistBlock("FA070CMI")
	__lF191Alt		:= ExistBlock("F191ALTEST")
	__lFinm010		:= ExistBlock("FINM010")	
Endif

Return lF070IRAB

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinFatAut

Geração de Fatura a Receber Automática

@Param aRec2Bx	: Array contendo os Recnos dos títulos a serem baixados
@Param aParcGer	: Array das Parcelas a serem Geradas
				aParcGer [nX,1]  = Prefixo
				aParcGer [nX,2]  = Numero
				aParcGer [nX,3]  = Parcela
				aParcGer [nX,4]  = Tipo
				aParcGer [nX,5]  = Cliente
				aParcGer [nX,6]  = Loja
				aParcGer [nX,7]  = Natureza
				aParcGer [nX,9]  = Valor Bruto da Parcela
				aParcGer [nX,9]  = Decréscimo
				aParcGer [nX,10] = Data Vencto da Parcela
				aParcGer [nX,11] = Historico da Parcela

@Author	Mauricio Pequim Junior
@since	09/04/2016
/*/
//-----------------------------------------------------------------------------------------------------

Function FinFatAut(aRec2Bx,aParcGer,aErroAuto)

Local lRet := .F.
Local aImpostos := Array(12)

If Len(aRec2Bx) > 0 .and.  Len(aParcGer) > 0

	//Inicializa array dos impostos utilizado para geração das parcelas
	AFill( aImpostos, 0 )

	//Inicializa as variáveis staticas utilizadas na geração das parcelas
	FinIniVar()

	BEGIN TRANSACTION

	//Baixa os títulos da Fatura
	If FinFtBx(aRec2Bx,aImpostos,@aErroAuto)

		//Gera as Parcelas da Fatura
		lRet := FinFtGer(aParcGer,aImpostos,@aErroAuto)

	Endif

	END TRANSACTION

Endif

aImpostos := NIL

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinFtBx

Baixa dos titulos GERADORES da fatura

@Param aRec2Bx		: Array contendo os Recnos dos títulos a serem baixados
@Param aImpostos	: Array dos impostos e base a serem repassados para as Parcelas (total dos impostos)
				aImpostos[01] = Base IRF
				aImpostos[02] = Valor IRF
				aImpostos[03] = Base INS
				aImpostos[04] = Valor INS
				aImpostos[05] = Base PIS
				aImpostos[06] = Valor PIS
				aImpostos[07] = Base COF
				aImpostos[08] = Valor COF
				aImpostos[09] = Base CSL
				aImpostos[10] = Valor CSL
				aImpostos[11] = Base ISS
				aImpostos[12] = Valor ISS

@Author	Mauricio Pequim Junior
@since	09/04/2016
/*/
//-----------------------------------------------------------------------------------------------------
Function FinFtBx(aRec2Bx,aImpostos,aErroAuto)

Local nX 		:= 0
Local nLenBx	:= Len(aRec2Bx)
Local lRet		:= .T.
Local cFilAtu	:= cFilAnt
Local _aTit		:= {}

Private lMsHelpAuto := .T.
Private lMsErroAuto := .F.

Default aErroAuto := {}

FCadMotBx("BFT", Padr("BAIXA FAT.", 10), "ANNN") //Inclusao motivo de baixa

For nX := 1 to nLenBx

	//Posiciono a SE1 para Baixar
	SE1->(dbGoto(aRec2Bx[nX]))

	aImpostos[1]  += SE1->E1_BASEIRF
	aImpostos[2]  += SE1->E1_IRRF
	aImpostos[3]  += SE1->E1_BASEINS
	aImpostos[4]  += SE1->E1_INSS
	aImpostos[5]  += SE1->E1_BASEPIS
	aImpostos[6]  += SE1->E1_PIS
	aImpostos[7]  += SE1->E1_BASECOF
	aImpostos[8]  += SE1->E1_COFINS
	aImpostos[9]  += SE1->E1_BASECSL
	aImpostos[10] += SE1->E1_CSLL
	aImpostos[11] += SE1->E1_BASEISS
	aImpostos[12] += SE1->E1_ISS

	//Baixa Titulos a Receber
	_aTit := {}

	cFilAnt := SE1->E1_FILORIG

	AADD(_aTit , {"E1_PREFIXO"	, SE1->E1_PREFIXO , Nil })
	AADD(_aTit , {"E1_NUM"    	, SE1->E1_NUM     , Nil })
	AADD(_aTit , {"E1_PARCELA"	, SE1->E1_PARCELA , Nil })
	AADD(_aTit , {"E1_TIPO"   	, SE1->E1_TIPO    , Nil })
	AADD(_aTit , {"E1_CLIENTE"	, SE1->E1_CLIENTE , Nil })
	AADD(_aTit , {"E1_LOJA"   	, SE1->E1_LOJA    , Nil })
	AADD(_aTit , {"AUTMOTBX"    , "BFT"           , Nil }) //Motivo de baixa
	AADD(_aTit , {"AUTDTBAIXA"  , dDataBase       , Nil }) //Data da baixa
	AADD(_aTit , {"AUTDTCREDITO", dDataBase       , Nil }) //Data do credito em conta corrente
	AADD(_aTit , {"AUTHIST"     , STR0025         , Nil }) //Historico da Baixa. STR0025: "Baixa de título gerador de fatura"

	//3 = Baixa de titulo
	MSExecAuto({|x, y| FINA070(x, y)}, _aTit, 3)

	If  lMsErroAuto
		lRet := .F.
		aErroAuto := GetAutoGRLog()
		//Verifica se está sendo executado por JOB
			If !(IsBlind())
				MOSTRAERRO()
			EndIf
			DisarmTransaction()
	    Exit
	EndIf

Next nX

cFilAnt := cFilAtu

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinFtGer

Inclusão dos títulos gerados pela Fatura

@Param aParcGer	: Array das Parcelas a serem Geradas
				aParcGer [nX,1]  = Prefixo
				aParcGer [nX,2]  = Numero
				aParcGer [nX,3]  = Parcela
				aParcGer [nX,4]  = Tipo
				aParcGer [nX,5]  = Cliente
				aParcGer [nX,6]  = Loja
				aParcGer [nX,7]  = Natureza
				aParcGer [nX,8]  = Valor Bruto da Parcela
				aParcGer [nX,9]  = Decréscimo
				aParcGer [nX,10] = Data Vencto da Parcela
				aParcGer [nX,11] = Historico da Parcela
@Param aImpostos	: Array dos impostos e base a serem repassados para as Parcelas (total dos impostos)
				aImpostos[01] = Base IRF
				aImpostos[02] = Valor IRF
				aImpostos[03] = Base INS
				aImpostos[04] = Valor INS
				aImpostos[05] = Base PIS
				aImpostos[06] = Valor PIS
				aImpostos[07] = Base COF
				aImpostos[08] = Valor COF
				aImpostos[09] = Base CSL
				aImpostos[10] = Valor CSL
				aImpostos[11] = Base ISS
				aImpostos[12] = Valor ISS

@Author	Mauricio Pequim Junior
@since	09/04/2016
/*/
//-----------------------------------------------------------------------------------------------------
Function FinFtGer(aParcGer,aImpostos,aErroAuto)

Local lRet			:= .T.
Local nLenPC		:= Len(aParcGer)
Local cCliente		:= ""
Local cLoja			:= ""
Local dEmiss		:= ""
Local dVencto		:= ""
Local nX			:= 0
Local nTotalGer		:= 0
Local nValDup		:= 0
Local nProp			:= 0
Local nPis			:= 0
Local nCofins		:= 0
Local nCsll			:= 0
Local nIrrf			:= 0
Local nInss			:= 0
Local nIss			:= 0
Local nBasePis		:= 0
Local nBaseCof		:= 0
Local nBaseCsl		:= 0
Local nBaseIrf		:= 0
Local nBaseIns		:= 0
Local nBaseIss		:= 0
Local nTotPis		:= 0
Local nTotCof		:= 0
Local nTotCsll		:= 0
Local nTotIrrf		:= 0
Local nTotInss		:= 0
Local nTotIss		:= 0
Local nTotBasePis	:= 0
Local nTotBaseCof	:= 0
Local nTotBaseCsl	:= 0
Local nTotBaseIrf	:= 0
Local nTotBaseIns	:= 0
Local nTotBaseIss	:= 0
Local _aTit			:= {}

Private lMsHelpAuto := .T.
Private lMsErroAuto := .F.

Default aErroAuto := {}

//Obtenho o valor total a gerar
For nX := 1 to nLenPC
	nTotalGer += aParcGer[nX,8]
Next

//Gero as parcelas
For nX := 1 to nLenPC

	SA1->(dbSeToRDER(1))
	SA1->(MsSeek(xFilial("SA1")+cCliente+cLoja))

	nValDup := aParcGer[nX,8] //Valor da Parcela
	nDecres := aParcGer[nX,9] //Valor do Decrescimo
	dVencto := aParcGer[nX,10] //Data de Vencimento da Parcela

	//Proporcionaliza impostos
	nProp := nValDup / nTotalGer

	If nX != nLenPC
		nBaseIrf	:= Round(NoRound(aImpostos[1]  * nProp,3),2)
		nIrrf 		:= Round(NoRound(aImpostos[2]  * nProp,3),2)
		nBaseIns	:= Round(NoRound(aImpostos[3]  * nProp,3),2)
		nInss 		:= Round(NoRound(aImpostos[4]  * nProp,3),2)
		nBasePis	:= Round(NoRound(aImpostos[5]  * nProp,3),2)
		nPis		:= Round(NoRound(aImpostos[6]  * nProp,3),2)
		nBaseCof	:= Round(NoRound(aImpostos[7]  * nProp,3),2)
		nCofins		:= Round(NoRound(aImpostos[8]  * nProp,3),2)
		nBaseCsl	:= Round(NoRound(aImpostos[9]  * nProp,3),2)
		nCsll 		:= Round(NoRound(aImpostos[10] * nProp,3),2)
		nBaseIss	:= Round(NoRound(aImpostos[11] * nProp,3),2)
		nIss		:= Round(NoRound(aImpostos[12] * nProp,3),2)

		nTotIrrf 	+= nIrrf
		nTotInss 	+= nInss
		nTotPis		+= nPis
		nTotCof		+= nCofins
		nTotCsll 	+= nCsll
		nTotIss		+= nIss

		nTotBaseIrf	+= nBaseIrf
		nTotBaseIns	+= nBaseIns
		nTotBasePis	+= nBasePis
		nTotBaseCof	+= nBaseCof
		nTotBaseCsl	+= nBaseCsl
		nTotBaseIss	+= nBaseIss
	Else
		nBaseIrf	:= aImpostos[1] - nTotBaseIrf
		nIrrf 		:= aImpostos[2] - nTotIrrf
		nBaseIns	:= aImpostos[3] - nTotBaseIns
		nInss 		:= aImpostos[4] - nTotInss
		nBasePis	:= aImpostos[5] - nTotBasePis
		nPis		:= aImpostos[6] - nTotPis
		nBaseCof	:= aImpostos[7] - nTotBaseCof
		nCofins		:= aImpostos[8] - nTotCof
		nBaseCsl	:= aImpostos[9] - nTotBaseCsl
		nCsll 		:= aImpostos[10] - nTotCsll
		nBaseIss	:= aImpostos[11] - nTotBaseIss
		nIss		:= aImpostos[12] - nTotIss
	Endif

	//Gera o titulo
	_aTit := {}

	dEmiss := dDataBase
	If dVencto < dEmiss
		dVencto := dEmiss
	Endif

	AADD(_aTit, {"E1_PREFIXO" , Padr(aParcGer[nX,1],nLenPref), NIL})
	AADD(_aTit, {"E1_NUM"     , Padr(aParcGer[nX,2],nLenNume), NIL})
	AADD(_aTit, {"E1_PARCELA" , Padr(aParcGer[nX,3],nLenParc), NIL})
	AADD(_aTit, {"E1_TIPO"    , Padr(aParcGer[nX,4],nLenTipo), NIL})
	AADD(_aTit, {"E1_CLIENTE" , Padr(aParcGer[nX,5],nLenClie), NIL})
	AADD(_aTit, {"E1_LOJA"    , Padr(aParcGer[nX,6],nLenLoja), NIL})
	AADD(_aTit, {"E1_NATUREZ" , Padr(aParcGer[nX,7],nLenNatu), NIL})
	AADD(_aTit, {"E1_VENCTO"  , dVencto                      , NIL})
	AADD(_aTit, {"E1_VENCREA" , DataValida(dVencto,.T.)      , NIL})
	AADD(_aTit, {"E1_VENCORI" , DataValida(dVencto,.T.)      , NIL})
	AADD(_aTit, {"E1_EMISSAO" , dEmiss                       , NIL})
	AADD(_aTit, {"E1_EMIS1"   , dEmiss                       , NIL})
	AADD(_aTit, {"E1_NOMCLI"  , SA1->A1_NREDUZ               , NIL})
	AADD(_aTit, {"E1_MOEDA"   , 1                            , NIL})
	AADD(_aTit, {"E1_VALOR"   , nValDup                      , NIL})
	AADD(_aTit, {"E1_SALDO"   , nValDup                      , NIL})
	AADD(_aTit, {"E1_VLCRUZ"  , nValDup                      , NIL})
	AADD(_aTit, {"E1_DECRESC" , nDecres                      , NIL})
	AADD(_aTit, {"E1_SDDECRE" , nDecres                      , NIL})
	AADD(_aTit, {"E1_ORIGEM"  , "FINI791"                    , NIL})
	AADD(_aTit, {"E1_IRRF"    , nIrrf                        , NIL})
	AADD(_aTit, {"E1_INSS"    , nInss                        , NIL})
	AADD(_aTit, {"E1_PIS"     , nPis                         , NIL})
	AADD(_aTit, {"E1_COFINS"  , nCofins                      , NIL})
	AADD(_aTit, {"E1_CSLL"    , nCsll                        , NIL})
	AADD(_aTit, {"E1_ISS"     , nIss                         , NIL})
	AADD(_aTit, {"E1_BASEIRF" , nBaseIrf                     , NIL})
	AADD(_aTit, {"E1_BASEINS" , nBaseIns                     , NIL})
	AADD(_aTit, {"E1_BASEPIS" , nBasePis                     , NIL})
	AADD(_aTit, {"E1_BASECOF" , nBaseCof                     , NIL})
	AADD(_aTit, {"E1_BASECSL" , nBaseCsl                     , NIL})
	AADD(_aTit, {"E1_BASEISS" , nBaseIss                     , NIL})
	AADD(_aTit, {"E1_HIST"    , Padr(aParcGer[nX,11],__nLenHist), NIL})

	MSExecAuto({|x, y| FINA040(x, y)}, _aTit, 3)

	//Verifica se a gravacao ocorreu normalmente, e possibilita o uso do PE FA280
	//para complementar a gravacao.
	If  lMsErroAuto
	    aErroAuto := GetAutoGRLog()
	    MOSTRAERRO()
	    DisarmTransaction()
	    lRet := .F.
	Endif

Next

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinIniVar

Inicializa Staticas da Geração de Fatura a Receber Automática

@Author	Mauricio Pequim Junior
@since	09/04/2016
/*/
//-----------------------------------------------------------------------------------------------------
Function FinIniVar()

If !_lIniVar
	nLenPref := TamSx3("E1_PREFIXO")[1]
	nLenNume := TamSx3("E1_NUM")[1]
	nLenParc := TamSx3("E1_PARCELA")[1]
	nLenTipo := TamSx3("E1_TIPO")[1]
	nLenClie := TamSx3("E1_CLIENTE")[1]
	nLenLoja := TamSx3("E1_LOJA")[1]
	nLenNatu := TamSx3("E1_NATUREZ")[1]
	__nLenHist := TamSx3("E1_HIST")[1]
	_lIniVar := .T.
Endif

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FCadMotBx
Efetua a insercao de motivos de baixa no arquivo SIGAADV.MOT
@param cMot, Motivo da baixa
@param cNomMot, Descricao do motivo da baixa
@param cConfMot, Configuracoes do motivo da baixa

@author  Totvs
@version P12.7
@since   14/09/2016
@return  Nil
/*/
//-----------------------------------------------------------------------------------------------------
Function FCadMotBx(cMot, cNomMot, cConfMot)
	Local lMotBxEsp	:= .F.
	Local aMotbx 	:= ReadMotBx(@lMotBxEsp)
	Local nHdlMot 	:= 0
	Local nI 		:= 0
	Local cFile 	:= "SIGAADV.MOT"
	Local nTamLn	:= 19

	If lMotBxEsp
		nTamLn   := 20
		cConfMot := cConfMot + "N"
	EndIf
	If ExistBlock("FILEMOT")
		cFile := ExecBlock("FILEMOT",.F.,.F.,{cFile})
	Endif

	If Ascan(aMotbx, {|x| Substr(x,1,3) == Upper(cMot)}) < 1
		nHdlMot := FOPEN(cFile,FO_READWRITE)
		If nHdlMot <0
			HELP(" ",1,"SIGAADV.MOT")
			Final("SIGAADV.MOT")
		Endif

		nTamArq := FSEEK(nHdlMot,0,2) //VerIfica tamanho do arquivo
		FSEEK(nHdlMot,0,0) //Volta para inicio do arquivo

		For nI := 0 To nTamArq step nTamLn //Processo para ir para o final do arquivo
			xBuffer := Space(nTamLn)
			FREAD(nHdlMot,@xBuffer,nTamLn)
	    Next nI

		fWrite(nHdlMot,cMot+cNomMot+cConfMot+chr(13)+chr(10))
		fClose(nHdlMot)
	EndIf
Return Nil

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc}PosicMov
Posiciona no movimento da carteira P ou R para gerar a seq de baixa correta. E no cancelamento
para não trazer mov. da carteira contrária quando o título possui  mesma chave
@author Sivaldo Santos Oliveira
@since  15/02/2017
@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Function PosicMov(cChave, cCart)

	//Não converter para FKs, antes da conversão das função fa070can e fa080Can, pois o retorno é posicionamento da SE5 para verificação de estorno.
	While SE5->(!Eof()) .And. cChave == SE5->(E5_FILIAL+E5_TIPODOC+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO)+Dtos(SE5->E5_DATA)+SE5->(E5_CLIFOR+E5_LOJA+E5_SEQ)
		If cCart == SE5->E5_RECPAG
			Exit
		Else
			SE5->(Dbskip())
		EndIf
	EndDo
Return Nil

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} IDProcFinXFun()
Retorna o ID da procedures que dá suporte às funções desta rotina
@type function
@author NORBERTOM
@since 22/02/2017
@version 1.0
@return cIDProc, Caracter, Versão da procedure que auporte a rotina FINXFUN
@example
cIDProcFinXFun := IDProcFinXFun()
/*/
//-----------------------------------------------------------------------------------------------------
FUNCTION IDProcFinXFun()
RETURN VerIDProc()


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} VerIDProc()
Identifica a sequencia de controle do fonte ADVPL com a stored procedure.
Qualquer alteracao que envolva diretamente a stored procedure a variavel sera incrementada. 
Procedure FIN002

@type function
@author Marcelo Pimentel
@since 24/07/2007
@version 1.0
@return cIDProc, Caracter, Versão da procedure que suporte a rotina FINXFUN

/*/
//-----------------------------------------------------------------------------------------------------
Static Function VerIDProc()
Return '011'


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FAValAces

Calculo de valores acessórios (versão básica)

@Author	Mauricio Pequim Jr
@since	20/08/2015
/*/
//-----------------------------------------------------------------------------------------------------
Function FAValAces(cPrefixo,cNum,cParcela,cTipo,cCliFor,cLoja,cNatureza, lBaixados,cCodVa)

Local nTotVlAces	:= 0
Local cQuery		:= ""
Local cChaveTit		:= ""
Local cChaveFK7		:= ""
Local aArea			:= GetArea()

Default cPrefixo	:= ""
Default cNum		:= ""
Default cParcela	:= ""
Default cTipo		:= ""
Default cCliFor		:= ""
Default cLoja		:= ""
Default cNatureza	:= ""
Default lBaixados 	:= .F.
Default cCodVa		:= ""

If TableInDic('FKD')
	If !Empty(cNum)
		//Apenas titulos de INSS e IRRF terão seus valores acessórios verificados
		If FaPodeTVA(cTipo,cNatureza,.F.,"P")

			//Dados da tabela auxiliar com o código do título a pagar
			cChaveTit := xFilial("SE2") + "|" + cPrefixo + "|" + cNum + "|" + cParcela + "|" + cTipo + "|" + cCliFor + "|" + cLoja
			cChaveFK7 := FINGRVFK7("SE2", cChaveTit)

			If lBaixados
				cQuery := "SELECT SUM(FKD_VLCALC) TOTSLDVA FROM " + RetSQLName("FKD")
			Else
				cQuery := "SELECT SUM(FKD_SALDO) TOTSLDVA FROM " + RetSQLName("FKD")
			EndIf
			cQuery += " WHERE  FKD_FILIAL = '" + FWxFilial("FKD") + "'"
			cQuery += " AND FKD_IDDOC = '" + cChaveFK7 + "'"

			//Monta o IN para seleção de códigos de Valores Acessórios específicos
			If !Empty(cCodVa)
				cQuery += " AND FKD_CODIGO IN " + FormatIn(cCodVa,"|")
			Endif

			cQuery += " AND D_E_L_E_T_ = ' ' "
			cQuery := ChangeQuery( cQuery )

			cAliasQry := GetNextAlias()
			dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )
			If ( cAliasQry )->( !EOF() )
				nTotVlAces := ( cAliasQry )->TOTSLDVA
			Endif
			( cAliasQry )->( DbCloseArea() )

		EndIf
	EndIf
EndIf

RestArea(aArea)

Return nTotVlAces

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FAPodeTVA

Valida se o título pode ter valores acessórios (versão básica)

@Author	Mauricio Pequim Jr
@since	20/08/2015
/*/
//-----------------------------------------------------------------------------------------------------
Function FAPodeTVA(cTipo,cNatureza,lHelp,cCarteira)

Local lRet := .F.

Default cTipo 		:= ""
Default cNatureza	:= ""
Default lHelp		:= .F.
Default cCarteira	:= "P"

	If cTipo $ MVPROVIS+"/"+MVRECANT+"/"+MV_CRNEG+"/"+MVABATIM+"/"+MVPAGANT+"/"+MV_CPNEG
		lRet 	:= .F.
		If lHelp
   	   		Help(,,"FVATIPO1",,STR0026,1,0)	//"Esse tipo de titulo não pode ter valores acessórios."
   	   	Endif
   	Else
   		lRet	:=	.T.
	Endif

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FSetFK6FKD
Insere os Novos Valores Acessorios (FKD) no submodel de valores acessórios (FK6)

@author Mauricio Pequim Jr
@since  24/08/2015
@version P12
/*/
//-----------------------------------------------------------------------------------------------------
FUNCTION FSetFK6FKD(oSubFK6 AS OBJECT,cChaveFK7 AS CHARACTER,cIdFK AS CHARACTER,cCart AS CHARACTER,;
                    dConversao AS DATE,nMoedaTit AS NUMERIC,nMoedaBco AS NUMERIC,nTxMoeda AS NUMERIC,;
                    nDecimais AS NUMERIC) AS LOGICAL
    LOCAL aArea		AS ARRAY
    LOCAL cTabOri	AS CHARACTER
    LOCAL nValCalc	AS NUMERIC
    LOCAL nValInfo	AS NUMERIC

    DEFAULT cCart     := "P"
    Default cChaveFK7 := ""
    Default cIdFK	  := ""
    DEFAULT oSubFK6   := NIL

    DEFAULT dConversao := CTOD("")
    DEFAULT nDecimais  := MsDecimais(1)
    DEFAULT nMoedaBco  := 1
    DEFAULT nMoedaTit  := 1
    DEFAULT nTxMoeda   := RecMoeda(dConversao, nMoedaTit)

    aArea := GetArea()

    If TableInDic('FKD')
        FKD->(DBSETORDER(2)) //FKD_FILIAL + FKD_IDDOC + FKD_CODIGO
        If FKD->(DBSeek(xFilial("FKD")+cChaveFK7))

            While xFilial("FKD") + cChaveFK7 == FKD->(FKD_FILIAL + FKD_IDDOC)
                cTabOri  := If(cCart == "R","FK1","FK2")
                IF EMPTY(dConversao)
                    nValInfo := FKD->FKD_VLINFO
                    nValCalc := FKD->FKD_VLCALC
                ELSE
                    nValInfo := Round(NoRound(xMoeda(FKD->FKD_VLINFO,nMoedaTit,nMoedaBco,dConversao,nDecimais+1,nTxMoeda),nDecimais+1),nDecimais)
                    nValCalc := Round(NoRound(xMoeda(FKD->FKD_VLCALC,nMoedaTit,nMoedaBco,dConversao,nDecimais+1,nTxMoeda),nDecimais+1),nDecimais)
                ENDIF

                If !EMPTY(nValInfo) .OR. !EMPTY(nValCalc)
                    //Grava Valores Acessorios (juros, multas, descontos etc)
                    If !oSubFK6:IsEmpty()
                        //Inclui a quantidade de linhas necessárias
                        oSubFK6:AddLine()

                        //Vai para linha criada
                        oSubFK6:GoLine( oSubFK6:Length() )
                    EndIf
                    oSubFK6:SetValue( "FK6_VALMOV" , nValInfo )
                    oSubFK6:SetValue( "FK6_VALCAL" , nValCalc )
                    oSubFK6:SetValue( "FK6_TPDESC" , "2" )
                    oSubFK6:SetValue( "FK6_TPDOC"  , "VA" )
                    oSubFK6:SetValue( "FK6_RECPAG" , cCart )
                    oSubFK6:SetValue( "FK6_TABORI" , cTabOri )
                    oSubFK6:SetValue( "FK6_IDORIG" , cIdFK )
                    oSubFK6:SetValue( "FK6_HISTOR" , FGetFKCDesc(FKD->FKD_CODIGO) )
                    oSubFK6:SetValue( "FK6_CODVAL" , FKD->FKD_CODIGO )
                    oSubFK6:SetValue( "FK6_ACAO"   , "1" )
                    If oSubFK6:HasField( "FK6_IDFKD" )
                        oSubFK6:SetValue( "FK6_IDFKD"   , FKD->FKD_IDFKD )
                    EndIf
                EndIf

                FKD->(dbSkip())
            EndDo
        EndIf
    EndIf

    RestArea(aArea)

    aSize ( aArea, 0 )
    aArea := Nil

Return .T.

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FGetFKCDesc
Obtém a descrição do valor acessório

@author Mauricio Pequim Jr
@since  24/08/2015
@version P12
/*/
//-----------------------------------------------------------------------------------------------------
Function FGetFKCDesc(cCodigo)

Local cRet := ""

FKC->(DBSetOrder(1))
If FKC->(MsSeek(xFilial("FKC")+cCodigo))
	cRet := FKC->FKC_DESC
Endif

Return cRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinGrvFI2
Função de gravação da tabela FI2 - Ocorrencias CNAB.
@example
	aItemsFI2[x][1]: Ocorrencia
	aItemsFI2[x][2]: Titulo do campo
	aItemsFI2[x][3]: Valor anterior
	aItemsFI2[x][4]: Novo valor
	aItemsFI2[x][5]: Nome do campo
	aItemsFI2[x][6]: Tipo do campo
@author Bruno Sobieski
@since  03/02/2005
/*/
//-----------------------------------------------------------------------------------------------------
Function FinGrvFI2()
Local nX		:=	1
Local aArea 	:= GetArea()
Local cChave 	:= ''
Local lF040GRCOM:= ExistBlock("F040GRCOM")

	lSubstFI2	:=	IIf(Type("lSubstFI2")=="L",lSubstFI2,.T.)

	FI2->(DbSetOrder(1))
	If Type('aItemsFI2') == "A" .And. !Empty(aItemsFI2)

		For nX := 1 To Len(aItemsFI2)

			If !Empty(aItemsFI2[nX][1])

				cChave	:=	xFilial("FI2",SE1->E1_FILORIG) + "1" + SE1->(E1_NUMBOR + E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO +;
				 								   E1_CLIENTE + E1_LOJA) + aItemsFI2[nX][1] + "2"

				// Pesquisa pela ocorrencia nao gerada (FI2_GERADO = 2 - Ja esta na chave)
				If lSubstFI2 .And. FI2->(DbSeek(cChave))
					RecLock('FI2',.F.)
				Else
					RecLock('FI2',.T.)
				Endif
				Replace FI2_FILIAL 	WITH xFilial("FI2",SE1->E1_FILORIG)
				Replace FI2_CARTEI 	WITH "1"
				Replace FI2_OCORR  	WITH aItemsFI2[nX][1]
				Replace FI2_GERADO 	WITH "2"
				Replace FI2_NUMBOR 	WITH SE1->E1_NUMBOR
				Replace FI2_PREFIX	WITH SE1->E1_PREFIXO
				Replace FI2_TITULO	WITH SE1->E1_NUM
				Replace FI2_PARCEL	WITH SE1->E1_PARCELA
				Replace FI2_TIPO  	WITH SE1->E1_TIPO
				Replace FI2_CODCLI	WITH SE1->E1_CLIENTE
				Replace FI2_LOJCLI	WITH SE1->E1_LOJA
				Replace FI2_DTOCOR	WITH dDataBase
				Replace FI2_DESCOC 	WITH Posicione('SEB',1,xFilial('SEB',SE1->E1_FILORIG)+SE1->E1_PORTADO+Pad(FI2->FI2_OCORR,;
										 Len(SEB->EB_REFBAN))+"E","SEB->EB_DESCRI")
				Replace FI2_VALANT	WITH aItemsFI2[nX][3]
				Replace FI2_VALNOV	WITH aItemsFI2[nX][4]
				Replace FI2_CAMPO 	WITH aItemsFI2[nX][5]
				Replace FI2_TIPCPO	WITH aItemsFI2[nX][6]
				MsUnLock()

				IF lF040GRCOM
					ExecBlock( "F040GRCOM", .F., .F., {aItemsFI2} )
			    Endif

			Endif
		Next nX
	EndIf

	RestArea(aArea)

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F070InsCob
Geração de instrução de cobrança.
@author William Gundim
@since  11/03/2016
@version P12.1.7
/*/
//-----------------------------------------------------------------------------------------------------
Function FxBInsCob(lManual,cInsc,lRest)
Local lInsCob		:= .F.
Local aArea			:= {}
Local aAux			:= {}
Local lRet			:= .T.
Private aItemsFI2	:= {}
Default lManual		:= .F.
Default cInsc		:= '1'
Default lRest		:= .F.

	lInsCob	:= SuperGetMv("MV_INSCOB",,"0") $ cInsc
	//
	If lInsCob
		//__nMsgIns 1 - Em lote, 2 - Em Lote confirmada, 3 - Em lote cancelado.
		If __nMsgIns == 1 .AND. !IsBlind() .AND. !lManual
			If MsgYesNo(STR0023,'')
				__nMsgIns := 2
			Else
				__nMsgIns := 3
			EndIf
		EndIf
		//
		If __nMsgIns != 3
			aArea	:= GetArea()
			aSize(aAux, 6)
			//
			If !(SE1->E1_TIPO $ MVRECANT+"/"+MVABATIM+"/"+MVPROVIS) .AND. !Empty(SE1->E1_IDCNAB) .AND. !Empty(SE1->E1_NUMBOR) .AND. SE1->E1_SITUACA $ FN022LSTCB(3)
				If lManual .AND. !IsBlind()
				  lRet := MsgYesNo(STR0024,'')
				EndIf
				If lRet
					aAux[1] := '02'
					aAdd(aItemsFI2,aAux)
					FinGrvFI2()
				EndIf
			EndIf
			RestArea(aArea)
			aSize(aAux, 0)
		EndIf
	EndIf

	If lRest
		__nMsgIns := 1 //Restaura o valor da variavel static.
	EndIf

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FxBDelFI2
Exclusão da FI2.
@author William Gundim
@since  15/03/2016
@version P12.1.7
/*/
//-----------------------------------------------------------------------------------------------------
Function FxBDelFI2()
Local aArea	:= GetArea()

	dbSelectArea('FI2')
	FI2->(dbSetOrder(1))
	If FI2->(dbSeek( xFilial('FI2',SE1->E1_FILORIG) + '1' + SE1->(E1_NUMBOR + E1_PREFIXO + E1_NUM +	 E1_PARCELA + E1_TIPO + E1_CLIENTE + E1_LOJA + '02' + '2')))

		Reclock("FI2",.F.)
		FI2->(DbDelete())
		FI2->(MsUnlock())

	EndIf

	RestArea(aArea)

Return

//-----------------------------------------------------------------------------------------------------
// Funções implementadas para cálculo de valores acessórios
//-----------------------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FValAcess

Calculo de valores acessórios (versão completa)

@Author Simone Mie Sato Kakinoana
@since	13/07/2016
/*/
//-----------------------------------------------------------------------------------------------------
Function FValAcess(cPrefixo,cNum,cParcela,cTipo,cCliFor,cLoja,cNatureza, lBaixados,cCodVa,cCarteira,dDtBaixa,aValAces,nMoedaTit,nMoedaBco,nTxMoeda,cIdFKD, lRetroativ)
Local aArea			:= GetArea()
Local nVlAces		:= 0
Local nTotVlAces	:= 0
Local nSaldo		:= 0
Local cChaveTit		:= ""
Local cChaveFK7		:= ""
Local cFilOriTit	:= ""
Local cFilOriFKC	:= ""
Local cAlias		:= ""
Local cChaveFKD		:= ""

Default cPrefixo	:= ""
Default cNum		:= ""
Default cParcela	:= ""
Default cTipo		:= ""
Default cCliFor		:= ""
Default cLoja		:= ""
Default cNatureza	:= ""
Default lBaixados	:= .F.
Default cCodVa		:= ""
Default cCarteira	:= "R"
Default dDtBaixa	:= dDataBase
Default aValAces	:= {}
Default nMoedaTit	:= SE1->E1_MOEDA
Default nMoedaBco	:= 1
Default nTxMoeda	:= RecMoeda(dDtBaixa,nMoedaTit)
Default cIdFKD		:= ""
Default lRetroativ	:= .F.

If !Empty(cNum)

	If TableInDic('FKD')

		If cCarteira == "P"
			cFilOriTit 	:= FWxFilial( "SE2", SE2->E2_FILORIG )
			cFilOriFKC 	:= FWxFilial( "FKC", SE2->E2_FILORIG )
			cChaveTit 	:= cFilOriTit + "|" + cPrefixo + "|" + cNum + "|" + cParcela + "|" + cTipo + "|" + cCliFor + "|" + cLoja
			cAlias		:= "SE2"
			nSaldo 		:= SE2->E2_SALDO
		Else
			cFilOriTit 	:= FWxFilial( "SE1", SE1->E1_FILORIG )
			cFilOriFKC 	:= FWxFilial( "FKC", SE1->E1_FILORIG )
			cChaveTit 	:= cFilOriTit + "|" + cPrefixo + "|" + cNum + "|" + cParcela + "|" + cTipo + "|" + cCliFor + "|" + cLoja
			cAlias		:= "SE1"
			nSaldo 		:= SE1->E1_SALDO
		EndIf

		dbSelectArea("FK7")
		FK7->(dbSetOrder(2))
		If FK7->(MsSeek(xFilial("FK7",cFilOriTit)+cAlias+cChaveTit))

			cChaveFK7 := FK7->FK7_IDDOC

			dbSelectArea("FKD")
			If !Empty( cIdFKD )
				FKD->( dbSetOrder(3) ) //FKD_FILIAL+FKD_IDFKD
				cChaveFKD := cFilOriTit + cIdFKD
			Else
				FKD->( dbSetOrder(2) ) //FKD_FILIAL+FKD_IDDOC+FKD_CODIGO
				cChaveFKD := cFilOriTit + cChaveFK7 + cCodVa
			EndIf
			If FKD->( msSeek( cChaveFKD ) )
				While FKD->( !Eof() ) .And. FKD->FKD_FILIAL == cFilOriTit .And. FKD->FKD_IDDOC == cChaveFK7
					FKC->( dbSetOrder(1) ) //FKC_FILIAL+FKC_CODIGO
					If FKC->( msSeek( cFilOriFKC + FKD->FKD_CODIGO ) )
						If FKC->FKC_ATIVO == "1"

							nVlAces := FCalcVA(cCarteira,dDtBaixa,nSaldo, lRetroativ)


							//Gravo o valor calculado e o valor informado para que gravações da FK6
							If !lRetroativ
								RecLock("FKD")
									FKD->FKD_VLCALC := nVlAces
									FKD->FKD_VLINFO := nVlAces
								FKD->(MSUnlock())
							EndIf

							//Converte os valores para a moeda corrente do pais
							If nMoedaTit != nMoedaBco
								nVlAces := xMoeda(nVlAces,nMoedaTit,nMoedaBco,dDtBaixa,3,nTxMoeda)
							Endif
							AADD(aValAces, {cChaveFK7,FKD->FKD_CODIGO,nVlAces})

							//Somo Total de VA
							nTotVlAces	+= nVlAces
						EndIf
						//Quando enviado um código específico, saio do While
						If !Empty(cCodVa) .OR. !Empty(cIdFKD)
							Exit
						Endif
					EndIf
					FKD->(dbSkip())
				End
			EndIf
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return nTotVlAces

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FCalcVA

Efetua o calculo dos valores acessorios,conforme regra cadastrada.

@Author	Simone Mie Sato Kakinoana
@since	14/07/2016
/*/
//-----------------------------------------------------------------------------------------------------
Function FCalcVA(cCarteira,dDtBaixa,nSaldo, lRetroativ)

Local nSaldoVA		:= 0
Local nValor		:= 0
Local nDias			:= 0
Local nFator		:= 0

Local dVencto		:= Iif(cCarteira == "P",SE2->E2_VENCTO,SE1->E1_VENCTO)
Local dVencrea		:= Iif(cCarteira == "P",SE2->E2_VENCREA,SE1->E1_VENCREA)
Local dEmissao		:= Iif(cCarteira == "P",SE2->E2_EMISSAO,SE1->E1_EMISSAO)

Local lCalcula		:= .T.

Default lRetroativ	:= .F.

If TableInDic('FKD')
    // Só é gravado o saldo para o periodo unico, o campo FKD_SALDO está armazenando o valor já baixado.

	If Abs(FKD->FKD_SALDO) == FKD->FKD_VALOR
		nSaldoVA := 0
	Else
		nSaldoVA := FKD->FKD_SALDO
	EndIf

	dDtBaixa	:= Iif(Empty(dDtBaixa),dDataBase,dDtBaixa)

	If ( cCarteira == "P" .And.  FKC->FKC_RECPAG == "2" ) .Or. ( cCarteira == "R" .And.  FKC->FKC_RECPAG =="1" )
		lCalcula	:= .F.
	EndIf

	If lCalcula

		//Para verificar se os valores acessórios devem ser calculados, verifica pela data de vencimento real.
		If FKC->FKC_APLIC == "1" 		//Até a data de vencimento
			If dDtBaixa > dVencrea - FKC->FKC_NDIAS
				lCalcula		:= .F.
			EndIf
		ElseIf FKC->FKC_APLIC == "2"		//Após o vencimento
			If dDtBaixa <= dVencrea	+ FKC->FKC_NDIAS
				lCalcula		:= .F.
			EndIf
		Endif

		If lCalcula

			//Cálculo do número de dias
			//Para verificar o número de dias, deve-se considerar a data de vencimento.
			If Empty(FKD->FKD_DTBAIX) //Ainda não houve baixa
				If FKC->FKC_PERIOD == "1" //Se o periodo for unico
					nDias	:= 1
				Else
					If FKC->FKC_APLIC == "1"	 //Ate a data de vencimento, periodo é calculado: database - data de emissão
						nDias	:= dDtBaixa - dEmissao
					ElseIf FKC->FKC_APLIC == "2" //Apos a data de vencimento, periodo é calculado: database - data de vencimento do titulo
						nDias	:= dDtBaixa - dVencto
					ElseIf FKC->FKC_APLIC == "3" //Sempre
						nDias	:= dDtBaixa - dEmissao
					EndIf

					If nDias < 0
						nDias := 0
					EndIf
				EndIf
			Else	//Houve baixa parcial
				If FKC->FKC_PERIOD == "1" //Se o periodo for unico, não calcula o VA novamente, pois já houve baixa parcial.
					If lRetroativ .And. dDtBaixa < FKD->FKD_DTBAIX
						nDias	:= 1
					Else
					nDias	:= 0
					EndIf
				Else
					If FKC->FKC_APLIC == "1"			//Ate a data de vencimento, periodo é calculado: FKD_DTBAIX - database
						nDias	:= dDtBaixa - FKD->FKD_DTBAIX
					ElseIf FKC->FKC_APLIC == "2"		//Apos a data de vencimento, periodo é calculado: FKD_DTBAIX - data de vencimento do titulo
						nDias	:= dDtBaixa - FKD->FKD_DTBAIX
					ElseIf FKC->FKC_APLIC == "3"		//Sempre
						nDias	:= dDtBaixa - FKD->FKD_DTBAIX
					EndIf
				EndIf
			EndIf

			If FKC->FKC_PERIOD $ "1/2"		//Se o período for único ou diário
				nFator	:= 1
			ElseIf FKC->FKC_PERIOD == "3"	//Mensal
				nFator	:= 30
			ElseIf FKC->FKC_PERIOD == "4"	//Anual
				nFator := 360
			EndIf

			If FKC->FKC_ACAO == "1" //Se soma

				If FKC->FKC_TPVAL == "1" //Se for percentual
					nValor +=  ( ( nSaldo * ( FKD->FKD_VALOR/100 )) / nFator )   * nDias
				ElseIf nSaldoVa <> 0 .AND. FKC->FKC_PERIOD == "1" //Se for valor com baixa parcial parcial
					nValor	+=  ( FKD->FKD_VALOR / nFator ) - nSaldoVa
				Else //Se for valor
					nValor	+=  ( FKD->FKD_VALOR / nFator)   * nDias
				EndIf
			Else //Subtrai
				If FKC->FKC_TPVAL == "1" //Se for percentual
					nValor -=  ( ( nSaldo * ( FKD->FKD_VALOR/100 )) / nFator ) * nDias
				ElseIf nSaldoVa <> 0 .AND. FKC->FKC_PERIOD == "1" //Se for valor com baixa parcial parcial
					nValor	-=  ( FKD->FKD_VALOR / nFator) - nSaldoVa
				Else //Se for valor
					nValor	-=  ( FKD->FKD_VALOR / nFator)   * nDias
				EndIf
			EndIf

			//Trata o campo regra do VA
			If !Empty(FKC->FKC_REGRA)
				If FKC->FKC_ACAO == "1"		//Se soma
					nValor += &(FKC->FKC_REGRA)
				Else
					nValor -= &(FKC->FKC_REGRA)
				EndIf
			EndIF
		EndIf

	EndIf

EndIf

Return(nValor)

//-------------------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FxLoadFK6
Função Responsavel por carregar a tabela FK6 e retorna-la no Vetor os dados somados dos campos FK6_VALCAL,FK6_VALMOV
@author jose.aribeiro
@since 04/08/2016
@version undefined
@param cTabOri , caracters, A Tabela de Origem do Dado (Obrigatorio)
@param cIdOrig , caracters, ID da Origem do Dado (Obrigatorio)
@param cTipo   , caracters, Tipodoc específico ( (JR, MT, DC, VA) (Opcional)
@return aRet   , Array    , Vetor com as somatorias dos campos FK6_VALCAL,FK6_VALMOV, sendo o vetor composto na mesma ordem
@example
FxLoadFK6("FK2","71297d3eb68640009595d22036c1b852")
/*/
//-------------------------------------------------------------------------------------------------------------------------------
Function FxLoadFK6(cTabOri,cIdOrig,cTipo)
Local aRet		:= {}
Local nValCal	:= 0
Local nValMov	:= 0
Local aArea		:= GetArea()
Local aAreaFK6	:= FK6->(GetArea())
Local aAreaFk2	:= FK2->(GetArea())
Local lVerTipo	:= .F.

Default cTipo	:= ""

If TableInDic('FKD')
	//Caso esteja vendo um tipo específico de valor acessório (JR, MT, DC, VA)
	If !Empty(cTipo)
		lVerTipo := .T.
	Endif

	If(cTabOri == "FK1")
		DbSelectArea("FK1")
		FK1->(DbSetOrder(1))
		If(FK1->(DbSeek(xFilial('FK1')+cIdOrig)))
			DbSelectArea("FK6")
			FK6->(DbSetOrder(2))
			If(Fk6->(DbSeek(xFilial('FK6') + FK1->FK1_IDFK1 + "FK1")))
				While(FK6->(!EOF()) .And. FK6->FK6_FILIAL+FK6->FK6_IDORIG+FK6->FK6_TABORI == xFilial('FK6') + FK1->FK1_IDFK1 + cTabOri )

					If !lVerTipo .or. (FK6->FK6_TPDOC == cTipo)
						If(FK6->FK6_ACAO == '1' )
							nValCal += FK6->FK6_VALCAL
							nValMov += FK6->FK6_VALMOV
						Else
							nValCal -= FK6->FK6_VALCAL
							nValMov -= FK6->FK6_VALMOV
						EndIf
					Endif
					FK6->(DbSkip())
				End
			EndIf
		EndIf

	Else
		DbSelectArea("FK2")
		FK2->(DbSetOrder(1))
		If(FK2->(DbSeek(xFilial('FK2')+cIdOrig)))
			DbSelectArea("FK6")
			FK6->(DbSetOrder(2))
			If(FK6->(DbSeek(xFilial('FK6') + FK2->FK2_IDFK2 + "FK2")))
				While(FK6->(!EOF()) .And. FK6->FK6_FILIAL+FK6->FK6_IDORIG+FK6->FK6_TABORI == xFilial('FK6') + FK2->FK2_IDFK2 + cTabOri )
					If !lVerTipo .or. (FK6->FK6_TPDOC == cTipo)
						If(FK6->FK6_ACAO == '1' )
							nValCal += FK6->FK6_VALCAL
							nValMov += FK6->FK6_VALMOV
						Else
							nValCal -= FK6->FK6_VALCAL
							nValMov -= FK6->FK6_VALMOV
						EndIf
					Endif
					FK6->(DbSkip())
				End
			EndIf
		EndIf
	EndIf

	aAdd(aRet,{nValCal,nValMov})
Else
	aAdd(aRet,{0,0})
EndIf

RestArea(aAreaFk2)
RestArea(aAreaFK6)
RestArea(aArea)

Return aRet

//--------------------------------------------------------------------------------------
/*/{Protheus.doc} FAtuFKDBx
Atualiza os valores de VA, informados na baixa, na tabela FKD
Acionada após a confirmação da baixa manual ou Lote.

@author pequim
@since 15/08/2016
@version undefined
@param lCancel
/*/
//--------------------------------------------------------------------------------------
Function FAtuFKDBx(lCancel, cCart, cCodVa, nVlVa, cIdFKD)
Local aArea		 := GetArea()
Local oModelVA 	 := NIL
Local oSubFKD 	 := NIL
Local nX 		 := 0
Local nTamFKD 	 := 0
Local dDtBaixa 	 := NIL
Local nRecSE1	 := SE1->(Recno())
Local nRecSE2	 := SE2->(Recno())
Local cFilOriTit := ""
Local cChaveTit  := ""
Local cChaveFK7  := ""
Local cChaveFKD  := ""
Local cModel	 := ""

Default lCancel		:= .F.
Default cCart		:= "R"
Default cCodVa		:= ""
Default nVlVa		:= 0
Default cIdFKD		:= ""


If TableInDic('FKD')
	cOldVA := Iif(Type("cOldVA") == 'U', "" , cOldVA)

	If lCancel
		dDTBaixa := CtoD("//")
	Else
		dDTBaixa := Iif(Type("dBaixa") == "U", dDataBase , dBaixa)
	EndIf

	If !Empty(cOldVA)
		cModel := If (cCart == 'R', "FINA070VA","FINA080VA")
		oModelVA := FWLoadModel(cModel)
		oModelVA:SetOperation( MODEL_OPERATION_UPDATE )
		oModelVA:Activate()
		oModelVA:LoadXMLData( cOldVA )

		//Atualiza Data da baixa
		oSubFKD := oModelVA:GetModel("FKDDETAIL")
		nTamFKD := oSubFKD:Length()

		For nX := 1 to nTamFKD
			oSubFKD:GoLine(nX)
            
            If oSubFKD:GetValue("FKD_VLINFO") <> 0 .OR. oSubFKD:GetValue("FKD_VLCALC") <> 0       //So grava data de baixa se existir valor calculado ou informado
				oSubFKD:LoadValue("FKD_DTBAIX", dDTBaixa)
            EndIf
			
            If oSubFKD:GetValue("FKD_PERIOD") == "1" .AND. oSubFKD:GetValue("FKD_TPVAL") == "2"		//Saldo só é controlado para FKC_TPVAL = 2 e FKC_PERIOD = 1
				oSubFKD:LoadValue("FKD_SALDO", oSubFKD:GetValue("FKD_SALDO") + oSubFKD:GetValue("FKD_VLINFO")) //campo FKD_SALDO está armazenando o valor baixado.
			EndIf
		Next

		If oModelVA:VldData()
			FWFormCommit( oModelVA )
		EndIf
		oModelVA:Deactivate()
		oModelVA:Destroy()
		oModelVa := NIL
		cOldVA := ""
	Else
		If cCart == "R"
			cFilOriTit	:= xFilial("SE1",SE1->E1_FILORIG)
			cChaveTit := cFilOriTit + '|' + SE1->E1_PREFIXO + '|' + SE1->E1_NUM + '|' + SE1->E1_PARCELA + '|' + SE1->E1_TIPO + '|' + SE1->E1_CLIENTE + '|' + SE1->E1_LOJA
			cChaveFK7 := FINGRVFK7("SE1", cChaveTit)
		Else
			cFilOriTit	:= xFilial("SE2",SE2->E2_FILORIG)
			cChaveTit := cFilOriTit + '|' + SE2->E2_PREFIXO + '|' + SE2->E2_NUM + '|' + SE2->E2_PARCELA + '|' + SE2->E2_TIPO + '|' + SE2->E2_FORNECE + '|' + SE2->E2_LOJA
			cChaveFK7 := FINGRVFK7("SE2", cChaveTit)
		EndIf

		DbSelectArea("FKD")
		If !Empty(cIdFKD)
			FKD->( DbSetOrder(3) ) //FKD_FILIAL+FKD_IDFKD
			cChaveFKD := cFilOriTit+cIdFKD
		Else
			FKD->( DbSetOrder(2) ) // FKD_FILIAL+FKD_IDDOC+FKD_CODIGO
			cChaveFKD := cFilOriTit+cChaveFK7+cCodVa
		EndIf

		If !Empty(cCodVa) .Or. !Empty(cIdFKD)
			
			If FKD->(DbSeek(cChaveFKD))
				If ABS(nVlVa) > ABS(FKD->FKD_SALDO)
					nVlVa := FKD->FKD_SALDO  //Ajusta para que o saldo não fique negativo. Pode ocorrer quando o valor baixado é superior ao valor do VA.
				EndIf
				RecLock("FKD")
					FKD->FKD_DTBAIX := dDTBaixa
					//Saldo só é controlado para FKC_TPVAL = 2 e FKC_PERIOD = 1
					If FKD->FKD_SALDO <> 0
						FKD->FKD_SALDO -= nVlVa
					EndIf
                FKD->(MSUnlock())
			EndIf

		ElseIf FKD->(DbSeek(cFilOriTit+cChaveFK7))
			
			While FKD->(!Eof()) .And. FKD->FKD_FILIAL == cFilOriTit .And. FKD->FKD_IDDOC == cChaveFK7
				//Gravo o valor calculado e o valor informado para que gravações da FK6
				RecLock("FKD")
					FKD->FKD_DTBAIX := dDTBaixa
				FKD->(MSUnlock())
				FKD->(DbSkip())
			EndDo

		EndIf

		If cCart == "R"
			SE1->(dbGoTo(nRecSE1))
		Else
			SE2->(dbGoTo(nRecSE2))
		EndIf
		
	EndIf
EndIf

RestArea(aArea)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} FormExpIn
Monta a expressão do IN/NOT IN da query

@author Mauricio Pequim Jr
@version P12.1.8
@since	05/09/2016

/*/
//-------------------------------------------------------------------
Function FormExpIn(cTipos)

Default cTipos := MVPROVIS + "/" + MVRECANT + "/" + MV_CRNEG + "/" + MVABATIM

cTipos	:=	StrTran(cTipos,',','/')
cTipos	:=	StrTran(cTipos,';','/')
cTipos	:=	StrTran(cTipos,'|','/')
cTipos	:=	StrTran(cTipos,'\','/')

cTipos := Formatin(cTipos,"/")

Return cTipos

//-------------------------------------------------------------------
/*/{Protheus.doc} MovBcoPA()
Verifica se PA ja teve sua movimentacao bancaria

@author Igor Sousa do Nascimento
@since 16/10/2017
@version 1.0
/*/
//-------------------------------------------------------------------
Function MovBcoPA(cPrefixo As Character, cNumero As Character, cParcela As Character, cTipo As Character, cFornec As Character, cLoja As Character)

	Local aArea As Array
	Local cTmp As Character
	Local lRet As Logical
	Local cIn As Character
	Local cQuery As Character
	Local cChaveFK7 As Character

	//Inicializa variáveis.
	aArea	:= {}
	cTmp	:= ""
	lRet  	:= .F.
	cIn   	:= ""
	cQuery	:= ""
	cChaveFK7 := ""

	Default cPrefixo := ""
	Default cNumero  := ""
	Default cParcela := ""
	Default cTipo := ""
	Default cFornec := ""
	Default cLoja := ""

	If cTipo $ MVPAGANT
		aArea := GetArea()
		If GetRpoRelease() >= "12.1.033"
			cChaveFK7 := xFilial("SE2", SE2->E2_FILORIG)+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
    		cChaveFK7 := FINBuscaFK7(cChaveFK7,"SE2")

			If __oMovPA == Nil
				cQuery := "SELECT FK5_IDDOC PAIDDOC FROM " + RetSqlName("FK5") + " FK5 "
				cQuery += "WHERE FK5_IDDOC = ? "
				cQuery += "UNION "
				cQuery += "SELECT EF_TITULO PAIDDOC "
				cQuery += "FROM " + RetSqlName("SEF") + " SEF "
				cQuery += "	WHERE SEF.EF_FILIAL = ? "
				cQuery += "	AND SEF.EF_NUM = ? "
				cQuery += "	AND SEF.EF_PREFIXO = ? "
				cQuery += "	AND SEF.EF_TITULO =  ? "
				cQuery += "	AND SEF.EF_PARCELA = ? "
				cQuery += "	AND SEF.EF_TIPO = ? "
				cQuery += "	AND SEF.EF_FORNECE = ? "
				cQuery += "	AND SEF.EF_LOJA = ? "
				cQuery += "	AND SEF.EF_NUM <> ' ' "
				cQuery += "	AND SEF.EF_LIBER = 'S' "
				cQuery += "	AND SEF.D_E_L_E_T_ = ' ' "
				cQuery := ChangeQuery(cQuery)
				__oMovPA := FWPreparedStatement():New(cQuery)
			EndIf

			__oMovPA:SetString(1, cChaveFK7)
			__oMovPA:SetString(2, xFilial("SEF",SE2->E2_FILORIG))
			__oMovPA:SetString(3, SE2->E2_NUMBCO)
			__oMovPA:SetString(4, SE2->E2_PREFIXO)
			__oMovPA:SetString(5, SE2->E2_NUM)
			__oMovPA:SetString(6, SE2->E2_PARCELA)
			__oMovPA:SetString(7, SE2->E2_TIPO)
			__oMovPA:SetString(8, SE2->E2_FORNECE)
			__oMovPA:SetString(9, SE2->E2_LOJA)

			cQuery := __oMovPA:GetFixQuery()
			cTmp := MpSysOpenQuery(cQuery)

		Else
			cTmp  := CriaTrab(,.F.)
			cIn := "%"
			cIn += "(SE5.E5_TIPODOC IN  " + FormExpIn(MVPAGANT) + " OR "
			//verifica a possibilidade de ser um BA com Cheque liberado.
			cIn += 		"(SE5.E5_TIPODOC = 'BA' and "
			cIn +=  	" SE5.E5_NUMCHEQ in ("
			cIn +=  		" SELECT EF_NUM"
			cIn += 			" FROM " + RetSqlName("SEF") + " SEF "
			cIn += 			" WHERE SEF.EF_FILIAL = SE5.E5_FILIAL "
			cIn += 				" AND SEF.EF_PREFIXO = SE5.E5_PREFIXO "
			cIn +=	 			" AND SEF.EF_TITULO = SE5.E5_NUMERO "
			cIn += 				" AND SEF.EF_NUM = SE5.E5_NUMCHEQ "
			cIn += 				" AND SEF.EF_PARCELA = SE5.E5_PARCELA "
			cIn += 				" AND SEF.EF_TIPO = SE5.E5_TIPO "
			cIn += 				" AND SEF.EF_FORNECE = SE5.E5_CLIFOR "
			cIn += 				" AND SEF.EF_LOJA = SE5.E5_LOJA "
			cIn += 				" AND SEF.EF_LIBER = 'S' "
			cIn += 				" AND SEF.D_E_L_E_T_ = ' ' "
			cIn += 							" ) "
			cIn += 		" ) "
			cIn += " ) "
			cIn += "%"
			BeginSQL Alias cTmp
				SELECT SE5.E5_TIPODOC
				FROM %table:SE5% SE5
				WHERE
					SE5.E5_FILIAL 	   = %xfilial:SE5%
					AND SE5.E5_PREFIXO = %exp:cPrefixo%
					AND SE5.E5_NUMERO  = %exp:cNumero%
					AND SE5.E5_PARCELA = %exp:cParcela%
					AND SE5.E5_TIPO    = %exp:cTipo%
					AND SE5.E5_CLIFOR  = %exp:cFornec%
					AND SE5.E5_LOJA    = %exp:cLoja%
					AND %Exp:cIn%
					AND SE5.E5_SITUACA = ' '
					AND SE5.%NotDel%
			EndSQL

		Endif
		
		If !(cTmp)->(EoF())
			lRet := .T.
		EndIf

		(cTmp)->(dbCloseArea())
		RestArea(aArea)
	Else
		lRet := .T.
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} GetPosts
Retorna array com recnos das baixas de um titulo
@param cChave - Chave unica do titulo
@param cFiltro - Filtro para baixas especificas
@author Igor Sousa do Nascimento
@since  05/01/2018
/*/
//-------------------------------------------------------------------
Function GetPosts(cXFilial,cIdDoc,cFiltro)

	Local aArea    := GetArea()
	Local aBaixas  := {}
	Local cTmp	   := CriaTrab(,.F.)
	Local cQuery   := ""

	Default cXFilial := ""
	Default cIdDoc	 := ""
	Default cFiltro  := ""

	cQuery := "SELECT FK2.R_E_C_N_O_ RECNOBX "
	cQuery += "FROM " + RetSqlName("FK2") + " FK2 "
	cQuery += "WHERE FK2.FK2_FILIAL = '" + cXFilial + "' "
	cQuery += 	"AND FK2.FK2_IDDOC = '" + cIdDoc + "' "
	If !Empty(cFiltro)
		cQuery += "AND " + cFiltro
	EndIf
	cQuery += 	"AND FK2.FK2_IDFK2 NOT IN ( "
	cQuery +=					" SELECT SUBFK2.FK2_IDFK2 FROM " + RetSqlName("FK2") + " SUBFK2 "
	cQuery +=					" WHERE SUBFK2.FK2_FILIAL = FK2.FK2_FILIAL "
	cQuery +=						" AND SUBFK2.FK2_IDFK2 = FK2.FK2_IDFK2 "
	cQuery +=						" AND SUBFK2.FK2_TPDOC = 'ES' AND SUBFK2.D_E_L_E_T_ = ' ' ) "
	cQuery += 	"AND FK2.D_E_L_E_T_ = ' '"
	cQuery := ChangeQuery(cQuery)
	MPSysOpenQuery(cQuery, cTmp)
	dbSelectArea(cTmp)
	While !(cTmp)->(EoF())
		Aadd(aBaixas, (cTmp)->RECNOBX)
		(cTmp)->(dbSkip())
	EndDo
	(cTmp)->(dbCloseArea())
	RestArea(aArea)

Return aBaixas

//-------------------------------------------------------------------
/*/{Protheus.doc} TemBxCanc2
Recriado a fun‡ao TemBxCanc para melhor performance de busca

@author Karen Honda
@since 14/12/16
@version 1.0
/*/
//-------------------------------------------------------------------
Function TemBxCanc2(cXFilial,cIdDoc)

	Local aArea    := GetArea()
	Local cTmp	   := CriaTrab(,.F.)
	Local cQuery   := ""
	Local lRet	   := .F.

	Default cXFilial := ""
	Default cIdDoc	 := ""

	cQuery := "SELECT FK2.R_E_C_N_O_ "
	cQuery += "FROM " + RetSqlName("FK2") + " FK2 "
	cQuery += "WHERE FK2.FK2_FILIAL = '" + cXFilial + "' AND "
	cQuery += "FK2.FK2_IDFK2 = '" + cIdDoc + "' AND "
	cQuery += "FK2.FK2_TPDOC = 'ES' AND FK2.D_E_L_E_T_ = ' ' "
	cQuery := ChangeQuery(cQuery)

	MPSysOpenQuery(cQuery, cTmp)
	dbSelectArea(cTmp)

	If !(cTmp)->(EoF())
		lRet := .T.
	EndIf

	(cTmp)->(dbCloseArea())
	RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}LimpResid
Ajusta o saldo do título, moeda estrangeira, quando
cancelamento total fica resíduo de 0.01 centavo
@author Sivaldo Oliveira
@since  16/03/2017
@version 12
/*/
//-------------------------------------------------------------------
Function LimpResid(cChave As Character, nIndice As Numeric, cCart As Character, lCancel As Logical)
Local aArea As Array
Local nVlrDif As Numeric

Default cChave := ""
Default nIndice := 0
Default cCart := ""

//Inicializa variáveis.
nVlrDif := 0

If !Empty(cChave) .And. !Empty(nIndice) .And. !Empty(cCart)
	aArea := GetArea()

	If cCart == "R"
		SE1->(DbSetOrder(nIndice))

		If SE1->(MsSeek(cChave))
			nVlrDif := Abs(If(lCancel, (SE1->E1_VALOR - SE1->E1_SALDO), SE1->E1_SALDO))

			If nVlrDif > 0 .And. nVlrDif <= 0.01
				RecLock("SE1")
				If	lCancel
					SE1->E1_SALDO := SE1->E1_VALOR
				ElseIf !lCancel
					SE1->E1_SALDO := 0
				EndIf
				SE1->(MsUnlock())
			EndIf
		EndIf
	Else
		SE2->(DbSetOrder(nIndice))

		If SE2->(MsSeek(cChave))
			nVlrDif := Abs(If(lCancel, (SE2->E2_VALOR - SE2->E2_SALDO), SE2->E2_SALDO))

			If nVlrDif > 0 .And. nVlrDif <= 0.01
				RecLock("SE2")
				If	lCancel
					SE2->E2_SALDO := SE2->E2_VALOR
				ElseIf !lCancel
					SE2->E2_SALDO := 0
				EndIf
				SE2->(MsUnlock())
			EndIf
		EndIf
	EndIf

	RestArea(aArea)
EndIf

Return Nil
//--------------------------------------------------------------------------------------
/*/{Protheus.doc} GetCredRM
Função para retornar o valor de crédito (recebido a mais via CNAB),
para envio de desconto no XML de baixa na integração RM Educacional x Protheus

@return __nValRA, Variável estática com o valor de crédito (recebido a mais via CNAB)

@author Pedro Alencar
@since 28/05/2018
@version 12.1.17
/*/
//--------------------------------------------------------------------------------------
Function GetCredRM()
Return __nValRA

//--------------------------------------------------------------------------------------
/*/{Protheus.doc}RemoveAsp
Remove aspas duplas e simples/apóstrofo
@author Sivaldo Oliveira
@since  31/07/2018
@version 12
/*/
//--------------------------------------------------------------------------------------
Function RemoveAsp(cConteudo) As Character
	Default cConteudo := ""
	If !Empty(AllTrim(cConteudo))
		cConteudo := StrTran(StrTran(StrTran(cConteudo, "'", ""), '"', ""),"|","")
	EndIf
Return cConteudo

//--------------------------------------------------------------------------------------
/*/{Protheus.doc}BxMovBco
Verifica se o titulo posicionado possui baixas, se sim, verifica se a baixas movimentaram
banco (Tipodoc VL, CH, BL ) 

@Return nValor, Retorna o valor de baixa do titulo
@see https://tdn.totvs.com/x/0gVcD
@author Vitor Duca
@since  12/12/2019
@version 12
/*/
//--------------------------------------------------------------------------------------
Function BxMovBco()
	Local cQuery As Character
	Local nValor As Numeric
	Local aArea  As Array

	//Inicialização das variaveis
	cQuery := ""
	nValor := 0
	aArea  := GetArea()

	//Não converter para FKs, antes do ajuste nas rotinas de baixa do TXA (zerando o saldo ou apenas gerando o movimento)
	//FINA080/FINA090/FINA091
	cQuery += "SELECT SUM(VAL) VLRBX " 
	cQuery += "FROM   (SELECT SUM(E5_VALOR) VAL "  
	cQuery +=		"FROM " + RetSqlName("SE5") + " "
	cQuery +=		"WHERE E5_FILIAL = '"+xFilial("SE5",SE2->E2_FILORIG)+"' "
	cQuery +=			"AND E5_PREFIXO = '"+SE2->E2_PREFIXO+"' "
	cQuery +=			"AND E5_NUMERO = '"+SE2->E2_NUM+"' "
	cQuery +=			"AND E5_PARCELA = '"+SE2->E2_PARCELA+"' "
	cQuery +=			"AND E5_TIPO = '"+SE2->E2_TIPO+"' "
	cQuery +=			"AND E5_FORNECE = '"+SE2->E2_FORNECE+"' "
	cQuery +=			"AND E5_LOJA = '"+SE2->E2_LOJA+"' "
	cQuery +=			"AND E5_TIPODOC IN ( 'VL', 'CH', 'BL' ) "
	cQuery +=			"AND E5_RECPAG = 'P' "
	cQuery +=			"AND E5_SITUACA <> 'C' "
	cQuery +=			"AND D_E_L_E_T_ = ' ' "
	cQuery +=		"UNION " 
	cQuery +=		"SELECT SUM(SE5.E5_VALOR) *- 1 VAL " 
	cQuery +=		"FROM " + RetSqlName("SE5") + " SE5 " 
	cQuery +=			"WHERE SE5.E5_FILIAL = '"+xFilial("SE5",SE2->E2_FILORIG)+"' "
	cQuery +=				"AND SE5.E5_DOCUMEN = '"+SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_NATUREZ+E2_FORNECE+E2_LOJA)+"' "
	cQuery +=			    "AND 0 = (SELECT COUNT(*) "
	cQuery +=					"FROM " + RetSqlName("SE5") + " EST "
	cQuery +=					"WHERE  EST.E5_FILIAL = SE5.E5_FILIAL "
	cQuery +=						"AND EST.E5_PREFIXO = SE5.E5_PREFIXO "
	cQuery +=						"AND EST.E5_NUMERO = SE5.E5_NUMERO "
	cQuery +=						"AND EST.E5_PARCELA = SE5.E5_PARCELA "
	cQuery +=						"AND EST.E5_TIPO = SE5.E5_TIPO "
	cQuery +=						"AND EST.E5_CLIFOR = SE5.E5_CLIFOR "
	cQuery +=						"AND EST.E5_LOJA = SE5.E5_LOJA "
	cQuery +=						"AND EST.E5_SEQ = SE5.E5_SEQ "
	cQuery +=						"AND EST.E5_RECPAG = 'R' "
	cQuery +=						"AND EST.E5_TIPODOC = 'ES' "
	cQuery +=						"AND EST.D_E_L_E_T_ = ' ' ) "
	cQuery +=			    "AND SE5.D_E_L_E_T_ = ' ') " + RetSqlName("SE5") + " " 
	cQuery := ChangeQuery(cQuery)

	nValor := MpSysExecScalar(cQuery,"VLRBX")

	nValor := If(EMPTY(nValor),0,nValor)

	RestArea(aArea)

Return nValor
	


//------------------------------------------------------------------------------------------------
/*/{Protheus.doc}FinFk3BCR
Ajusta FK3 de títulos com impostos pendentes que estão sendo retidos na baixa atual

@param aTitCalc - Baixas com PCC pendente de retenção que estão sendo retidos na baixa atual
@param aImpostos - Array de impostos da baixa (calculado e retido)

@author Pequim
@since  05/10/2020
@version 12
/*/
//------------------------------------------------------------------------------------------------
Function FinFk3BCR(aTitCalc As Array, aImpostos As Array)

	Local nX As Numeric
	Local aTitIrf As Array
	Local aAreaAtu As Array
	Local aAreaSE5 As Array

	Default aTitCalc := {}
	Default aImpostos := {}

	nX := 0
	aTitIRF := FGetSFQIr()
	aAreaAtu := GetArea()
	aAreaSE5 := SE5->(GetArea())

	For nX := 1 to len(aTitCalc)
		FINGFK3BOR(2,aTitCalc[nx,1],aTitCalc[nx,2],aImpostos,.F.)
	Next

	For nX := 1 to len(aTitIRF)
		FINGFK3BOR(2,aTitIRF[nx,1],aTitIRF[nx,2],aImpostos,.F.)
		SE5->(DBSetOrder(21))
		If SE5->(MsSeek(xFilial("SE5")+aTitIRF[nx,2]))
			Reclock("SE5")
			SE5->E5_PRETIRF := '2'
			MsUnLock()
		Endif
	Next

	SE5->(RestArea(aAreaSE5))
	RestArea(aAreaAtu)

	FWFreeArray(aAreaSE5)
	FWFreeArray(aAreaATU)
	FWFreeArray(aTitIRF)

Return

//------------------------------------------------------------------------------------------------
/*/{Protheus.doc}GetRecAdd
Retorna as baixas BA e VL para o Processo passado

@param cProcesso - Processo FKA
@author rafael.rondon
@since  28/12/2020
@version 12
/*/
//------------------------------------------------------------------------------------------------
Static Function GetRecAdd( cProcesso )

Local aArea	As	Array
Local aRetRecnos As Array
Local cQuery As Character
Local cAlias As Character

aArea		:= GetArea()
aRetRecnos	:= {}
cQuery		:= ""
cAlias		:= GetNextAlias()

Default cProcesso	:= ""

cQuery := " SELECT SE5.R_E_C_N_O_ SE5RECNO FROM " + RetSqlName("FKA") + " FKA "
cQuery += " INNER JOIN " + RetSqlName("FK1") + " FK1 "
cQuery += 		" ON FK1.FK1_FILIAL = FKA_FILIAL "
cQuery += 		" AND FK1.FK1_IDFK1 = FKA_IDORIG "
cQuery += 		" AND FK1_TPDOC IN ('VL','BA') "
cQuery += 		" AND FK1.D_E_L_E_T_ = ' ' "
cQuery += " INNER JOIN " + RetSqlName("SE5") + " SE5 "
cQuery += 		" ON SE5.D_E_L_E_T_ = ' ' "
cQuery += 		" AND SE5.E5_FILIAL = '" + xFilial('SE5') + "' "
cQuery += 		" AND SE5.E5_IDORIG = FK1_IDFK1 "
cQuery += " WHERE FKA.D_E_L_E_T_ = ' ' "
cQuery += 		" AND FKA.FKA_FILIAL = '" + xFilial("FKA") + "' "
cQuery += 		" AND FKA.FKA_IDPROC = '" + cProcesso + "' "
cQuery += 		" AND FKA.FKA_TABORI = 'FK1' "

cQuery := ChangeQuery(cQuery)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)

While (cAlias)->(!EOF())
	AADD( aRetRecnos , (cAlias)->SE5RECNO )
	(cAlias)->(DbSkip())
EndDo

(cAlias)->(DbCloseArea())

RestArea(aArea)

Return aRetRecnos

//------------------------------------------------------------------------------------------------
/*/{Protheus.doc}fAUltBxcr
Retorna a data da ultima baixa valida (sem estorno), com motivo de baixa diferente de compensação CR

@param cIdDoc - ID do título 
@author Pâmela Bernardo
@since  15/01/2021
@version 12
/*/
//------------------------------------------------------------------------------------------------
Static Function fAUltBxcr(cIdDoc)

	Local dUltBaixa As Date
	Local aArea		As Array
	Local cQuery	As Character
	Local cTmpFK	As Character

	Default cIdDoc	:= ""

	dUltBaixa	:= StoD("")
	aArea		:= GetArea()
	cQuery		:= ""
	cTmpFK		:= GetNextAlias()
	
	cQuery := "SELECT MAX(FK1_DATA) ULTBAIXA "
	cQuery += "From " + RetSqlName("FK1") + " FK1 "
	cQuery += "WHERE "
	cQuery += " FK1.FK1_FILIAL = '" + xFilial("FK1") + "' "
	cQuery += "AND FK1.FK1_IDDOC = '" +cIddoc +"' "
	cQuery += "AND FK1.FK1_MOTBX <> 'CMP' "
	cQuery += "AND FK1.D_E_L_E_T_ = ' ' "
		cQuery += "AND NOT EXISTS( SELECT FK1EST.FK1_IDDOC "
		cQuery += "From " + RetSqlName("FK1") + " FK1EST "
		cQuery += "Where "
		cQuery += " FK1EST.FK1_FILIAL = '" + xFilial("FK1") + "' "
		cQuery += "AND FK1EST.FK1_IDDOC = '" +cIddoc +"' "
		cQuery += "AND FK1EST.FK1_SEQ = FK1.FK1_SEQ   "
		cQuery += "AND FK1EST.FK1_TPDOC = 'ES' "
		cQuery += "AND FK1EST.D_E_L_E_T_ = ' ' ) "

	cQuery := ChangeQuery(cQuery)
	
	dbUseArea(.T.,"TOPCONN",TCGenQry(,,cQuery),cTmpFK,.F.,.T.)
	
	If !Eof()
		dUltBaixa := StoD((cTmpFK)->(ULTBAIXA))
	EndIf
	
	(cTmpFK)->(dbCloseArea())
	MsErase(cTmpFK)

	RestArea(aArea)


Return dUltBaixa


//------------------------------------------------------------------------------------------------
/*/{Protheus.doc}FTemBxParc
Retorna se o título já sofreu alguma baixa

Titulo precisa estar posicionado
@param cAlias - (SE1/SE2)
@param cFilOri - fILIAL

@author Ana Paula
@since  13/10/2021
@version 12
/*/
//------------------------------------------------------------------------------------------------
Function FTemBxParc(cAlias As Char, cFilOri As Char) As Logical
	Local lRet      As Logical
	Local cQuery    As Char
	Local cChaveFK7 As Char
	Local cWhere    As Char
	Local cTabela   As Char
	Local cTblFK    As Char
	
	Default cAlias	:= ""
	Default cFilOri := cFilAnt
	
	//Inicializa variáveis
	lRet      := .F.
	cQuery    := ""
	cChaveFK7 := ""
	cWhere    := ""
	cTabela   := ""
	cTblFK    := "FK1"
	
	If (cAlias := AllTrim(cAlias)) $ "SE1|SE2"		
		If cAlias == "SE1"
			cChaveFK7 := xFilial("SE1", SE1->E1_FILORIG)+"|"+SE1->E1_PREFIXO+"|"+SE1->E1_NUM+"|"+SE1->E1_PARCELA+"|"+SE1->E1_TIPO+"|"+SE1->E1_CLIENTE+"|"+SE1->E1_LOJA		
			
			If __oExretR == Nil
				cWhere := "WHERE FK1.FK1_IDDOC = ? AND FK1.FK1_FILORI = ? AND FK1.FK1_MOTBX NOT IN ('PCC', 'IRF', 'ISS', 'IMR') "
				cQuery := "SELECT COUNT(FK1.FK1_IDFK1) NIDFK FROM ? FK1 " + cWhere + "AND FK1.FK1_RECPAG = 'R' AND FK1.D_E_L_E_T_ = ' '"
				cQuery += "AND NOT EXISTS (SELECT FK1EST.FK1_IDDOC FROM ? " + " FK1EST " 
				cQuery += STRTRAN(cWhere, "FK1.", "FK1EST.") + "AND FK1.FK1_SEQ = FK1EST.FK1_SEQ "
				cQuery += "AND FK1EST.FK1_TPDOC = 'ES' AND FK1EST.FK1_RECPAG = 'P' AND FK1EST.D_E_L_E_T_ = ' '"
				cQuery := ChangeQuery(cQuery)
				__oExretR := FWPreparedStatement():New(cQuery)
			EndIf
		Else
			cTblFK    := "FK2"
			cChaveFK7 := xFilial("SE2", SE2->E2_FILORIG)+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
			
			If __oExretP == Nil
				cWhere := "WHERE FK2.FK2_IDDOC = ? AND FK2.FK2_FILORI = ? AND FK2.FK2_MOTBX NOT IN ('PCC', 'IRF', 'ISS', 'IMR') "
				cQuery := "SELECT COUNT(FK2.FK2_IDFK2) NIDFK FROM ? FK2 " + cWhere + "AND FK2.FK2_RECPAG = 'P' AND FK2.D_E_L_E_T_ = ' '"
				cQuery += "AND NOT EXISTS (SELECT FK2EST.FK2_IDDOC FROM ? " + " FK2EST " 
				cQuery += STRTRAN(cWhere, "FK2.", "FK2EST.") + "AND FK2.FK2_SEQ = FK2EST.FK2_SEQ "
				cQuery += "AND FK2EST.FK2_TPDOC = 'ES' AND FK2EST.FK2_RECPAG = 'R' AND FK2EST.D_E_L_E_T_ = ' '"
				cQuery := ChangeQuery(cQuery)
				__oExretP := FWPreparedStatement():New(cQuery)
			EndIf
		EndIf
    	
		cChaveFK7 := FINBuscaFK7(cChaveFK7, cAlias)
		cTabela   := RetSqlName(cTblFK)
		
		Iif(cAlias == "SE1", __oExretR, __oExretP):SetNumeric(1, cTabela)
		Iif(cAlias == "SE1", __oExretR, __oExretP):SetString(2,  cChaveFK7)
		Iif(cAlias == "SE1", __oExretR, __oExretP):SetString(3,  cFilOri)
		Iif(cAlias == "SE1", __oExretR, __oExretP):SetNumeric(4, cTabela)
		Iif(cAlias == "SE1", __oExretR, __oExretP):SetString(5,  cChaveFK7)
		Iif(cAlias == "SE1", __oExretR, __oExretP):SetString(6,  cFilOri)
		
		cQuery := Iif(cAlias == "SE1", __oExretR, __oExretP):GetFixQuery()
		lRet   := (MpSysExecScalar(cQuery, "NIDFK")) > 0
	EndIf
Return lRet

/*/{Protheus.doc} FinExpRot
	Apresenta uma tela informando que a rotina sera descontinuada
	@type  Function
	@author reynaldo
	@since 30/06/2021
	@version 1.0
	@param cExpirFunc, caracter, nome da rotina que deve ser descontinuada
	@param cDescrFunc, caracter, descricaod a rotina e nome da rotina que substitui a rotina descontinuada
	@param cExpiraData, caracter, data de experira??o a ser informada deve estar no formato AAAAMMDD
	@param cEndWeb, caracter, endere?o http referente a rotina que esta sendo descontinuada
/*/
Function FinExpRot(cExpirFunc as character, cDescrFunc as character, cEndWeb as character, cExpiraData as character, nPauseDays as numeric)
Local dDate      as date
Local oProfile   as object
Local aLoad      as array
Local cShow      as character
Local lCheck     as logical

//
// Data de expiração da rotina
//
DEFAULT cExpiraData := "20220404"

//
// numero de dias que pode ser desabilitada a mensagem
//
DEFAULT nPauseDays := 30

dDate := Date()
oProfile := FwProFile():New()
oProfile:SetTask("ESTExpired") //Nome da sess?o
oProfile:SetType(cExpirFunc) //Valor
aLoad := oProfile:Load()
If Empty(aLoad)
	cShow := "00000000"
Else
	cShow := aLoad[1]
Endif

// reseta o controle de nPauseDays dias e volta apresentar a tela de advertencia
If cShow <> "00000000" .and. STOD(cShow) + nPauseDays <= dDate
	cShow := "00000000"
	oProfile:SetProfile({cShow})
	oProfile:Save()
ENDIF

If cShow == "00000000"
	lCheck := DlgExpRot(cExpiraData, nPauseDays, cDescrFunc, cEndWeb)

	If lCheck
		cShow := dtos(date())
		oProfile:SetProfile({cShow})
		oProfile:Save()
	EndIf

EndIf

oProfile:Destroy()
oProfile := nil
aLoad := aSize(aLoad,0)
aLoad := nil

RETURN

/*/{Protheus.doc} DlgExpRot
	Apresenta uma tela informando que a rotina sera descontinuada
	@type  Function
	@author reynaldo
	@since 30/06/2021
	@version 1.0
	@param cExpiraData, caracter, data de experiração a ser informada deve estar no formato AAAAMMDD
	@param nPauseDays, numeric, numero de dias que a mensagem pode ser ocultada
	@param cDescrFunc, caracter, descricaod a rotina e nome da rotina que substitui a rotina descontinuada
	@param cEndWeb, caracter, endere?o http referente a rotina que esta sendo descontinuada
	@return lCheck, logico, Verdadeiro se foi escolhido para desabilitar a mensagem por 3O dias
/*/
Static Function DlgExpRot(cExpiraData as character, nPauseDays as numeric, cDescrFunc as character, cEndWeb as character)
local oSay1   as object
local oSay2   as object
local oSay3   as object
local oSay4   as object
local oCheck1 as object
local oModal  as object
Local cMsg1   as character
Local cMsg2   as character
Local cMsg3   as character
Local cMsg4   as character
Local lCheck  as logical

oModal := FWDialogModal():New()
oModal:SetCloseButton( .F. )
oModal:SetEscClose( .F. )
oModal:setTitle(STR0033) //"Comunicado Ciclo de Vida de Sofware - TOTVS Linha Protheus"

//define a altura e largura da janela em pixel
oModal:setSize(180, 250)

oModal:createDialog()

oModal:AddButton( STR0034, {||oModal:DeActivate()}, STR0034, , .T., .F., .T., ) // "Confirmar"

oContainer := TPanel():New( ,,, oModal:getPanelMain() )
oContainer:Align := CONTROL_ALIGN_ALLCLIENT

cMsg1 := i18n(STR0035,{cValToChar(stod(cExpiraData))}) // "Esta rotina será descontinuada em #1[04/04/2022]#"
cMsg2 := i18n("<b>" + cDescrFunc + "</b>", {} ) //"As Rotinas FINA090 (Baixa Automática) e FINA091 (Baixa Automática Multi Filiais) serão unificadas. "
cMsg4 := STR0036 //"Para maiores informações, favor contatar o administrador do sistema ou seu ESN TOTVS.",)

oSay1 := TSay():New( 10,10,{||cMsg1 },oContainer,,,,,,.T.,,,220,20,,,,,,.T.)

oSay2 := TSay():New( 30,10,{||cMsg2 },oContainer,,,,,,.T.,,,220,20,,,,,,.T.)

cMsg3 := Alltrim(STR0037)+space(01) // "Para conhecer mais sobre a convergência entre essas rotinas, "
If ! Empty(cEndWeb)
	cMsg3 += "<b><a target='_blank' href='"+cEndWeb+"'> "
	cMsg3 += Alltrim(STR0038) // "clique aqui"
	cMsg3 += " </a></b>."
	cMsg3 += "<span style='font-family: Verdana; font-size: 12px; color: #565759;' >" + ' ' +"</span>"
	oSay3 := TSay():New(50,10,{||cMsg3},oContainer,,,,,,.T.,,,220,20,,,,,,.T.)
	oSay3:bLClicked := {|| MsgRun( STR0039, "URL",{|| ShellExecute("open",cEndWeb,"","",1) } ) } // "Abrindo o link... Aguarde..."
EndIf
oSay4 := TSay():New( 70,10,{||cMsg4 },oContainer,,,,,,.T.,,,220,20,,,,,,.T.)

lCheck := .F.
oCheck1 := TCheckBox():New(100,10,i18n(STR0040,{strzero(nPauseDays,2)}) ,{|x|If(Pcount()==0,lCheck,lCheck:=x)},oContainer,220,21,,,,,,,,.T.,,,) // "Não apresentar esta mensagem nos proximos #1[30]# dias."

oModal:Activate()

Return lCheck

/*/{Protheus.doc} F070ClearM
	Função reponsável por distuir o model criado

	@type  Function
	@author Fabio Zanchim
	@since 25/02/2022
	@version 12.1.33
	@return Nil
	/*/
Function F070ClearM() 

	If oModelBxR != nil 
		oModelBxR:Destroy()
		oModelBxR:= nil 
	EndIf 

Return 

/*/{Protheus.doc} FGrvBxPIX
Função reponsável por distuir o model criado

@type	Function
@author Rafael Riego
@since	12/04/2022
@param	cIdFK1, character, id da baixa
@return Nil
/*/
Function FGrvBxPIX(cIdFK1 As Character)

	Default cIdFK1 := ""

	If __lF71IdBx == Nil
		__lF71IdBx := cPaisLoc == "BRA" .And. TableInDic("F71") .And. (F71->(FieldPos("F71_IDFK1")) > 0)
	EndIf

	If __lF71IdBx .And. !(Empty(cIdFK1))
		RecLock("F71", .F.)
		F71->F71_IDFK1 := cIdFK1
		F71->(MsUnlock())
	EndIf

Return Nil
