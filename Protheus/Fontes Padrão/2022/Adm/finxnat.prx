#INCLUDE "PROTHEUS.CH"
#INCLUDE "finxnat.ch"
 
//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINXNAT

Funções genéricas relacionadas a naturezas

@Author Vários
@version 12
@since   11/12/2014

/*/
//-----------------------------------------------------------------------------------------------------
 
/* FINXATU */
Static nTamNatur
Static __lFivAbati
Static __lFiwAbati
Static __lExistFJV

/* FINXFUN */
Static cArqSez  // Arquivo temporario do MultiNaturezas por C.Custo
Static cPictPerc := NIL

/*Variaveis para a criação das Tabelas Temporarias */

Static _oFINXNAT1
Static _oFINXNAT2
Static __cFin1Name
Static __cFin2Name
Static lCloseTbl := .F.

Static __lFASLDNAT	:= ExistBlock("FASLDNAT") 
Static __lF022GRA	:= ExistBlock("F022GRA") 
Static __lNatSevLoad:= ExistBlock("NATSEVLOAD") 
Static __lNatSezLoad:= ExistBlock("NATSEZLOAD") 

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±                                                                         ±±
±±            Funcoes retiradas do arquivo FINXATU.PRX                     ±±
±±                                                                         ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

//-------------------------------------------------------------------
/*/{Protheus.doc} ATUSLDNAT
Atualiza tabelas de saldo de naturezas
Arquivo original: FINXATU.PRX 

@param cNatureza - Codigo da natureza em que o saldo sera atualizado
@param dData - Data em que o saldo deve ser atualizado
@param cMoeda - Codigo da moeda do saldo
@param cTipoSld - Tipo de saldo (1=Orcado, 2=Previsto, 3=Realizado)
@param cCarteira - Codigo da carteira (P=Pagar, R=Receber)
@param nValor - Valor que atualizara o saldo na moeda do saldo
@param nVlrCor - Valor que atualizara o saldo na moeda corrente
@param cSinal - Sinal para atualizacao (+) ou (-)
@param cPeriodo - Saldo a ser atualizado (D = Diario, M = Mensal, NIL = Ambos	(importante apenas no recalculo)
@param cOrigem - Rotina de Origem do movimento de fluxo de caixa. Ex. FUNNAME()
@param cAlias - Alias onde ocorreu a movimentação de fluxo de caixa. Ex. SE2
@param nRecno - Número do registro no alias onde ocorreu a movimentação de fluxo de caixa.
@param nOpcRot - Opção de manipulação da rotina de origem da chamada da função AtuSldNat()	
@param cTipoDoc - Tipo do documento E5_TIPODOC
@param nVlAbat - Valor de abatimento E5_ABATI

@author Claudio Donizete de Souza
@since 16/04/2010
/*/
//-------------------------------------------------------------------
Function AtuSldNat(cNatureza,;		// 1 -> Codigo da natureza em que o saldo sera atualizado
						 dData,;	// 2 -> Data em que o saldo deve ser atualizado
						 cMoeda,;	// 3 -> Codigo da moeda do saldo
						 cTipoSld,;	// 4 -> Tipo de saldo (1=Orcado, 2=Previsto, 3=Realizado)
						 cCarteira,;// 5 -> Codigo da carteira (P=Pagar, R=Receber)
						 nValor,; 	// 6 -> Valor que atualizara o saldo na moeda do saldo
 						 nVlrCor,; 	// 7 -> Valor que atualizara o saldo na moeda corrente
						 cSinal,;	// 8 -> Sinal para atualizacao (+) ou (-)
						 cPeriodo,;	// 9 -> Saldo a ser atualizado (D = Diario, M = Mensal, NIL = Ambos	(importante apenas no recalculo)
						 cOrigem,;	// 10 -> Rotina de Origem do movimento de fluxo de caixa. Ex. FUNNAME()
						 cAlias,;	// 11-> Alias onde ocorreu a movimentação de fluxo de caixa. Ex. SE2
						 nRecno,;	// 12 -> Número do registro no alias onde ocorreu a movimentação de fluxo de caixa.
						 nOpcRot,;  // 13 -> Opção de manipulação da rotina de origem da chamada da função AtuSldNat()	
						 cTipoDoc,;	// 14 -> Tipo do documento E5_TIPODOC
						 nVlAbat,;  // 15 -> Valor de abatimento E5_ABATI
						 cFilSE1,;	// 16 -> Filial do registro compartilhado XX_FILORIG
						 lRatNat)	// 17 -> Indica se é rateio por natureza

Local cMovFlxCxNt	:= GetNewPar("MV_FINATFN","1") // Verifica se movimenta fluxo de caixa "1" - On-line / "2" - Off-Line
Local lRet			:= .F.
Local aArea			:= GetArea()
Local aAreaFIV		:= {}
Local aAreaFIW		:= {}
Local lAtuSldNat	:= .T.
Local cCodFJV 		:= ""
Local lGrvSld 		:= .T.
Local lIntPfs       := SuperGetMV("MV_JURXFIN",,.F.) //Habilita a integracao entre os modulos SIGAFIN - Financeiro e SIGAPFS - Juridico
Local cFilFIV		:= ""
Local cFilFIW		:= ""
Local cFilFJV		:= ""

DEFAULT cPeriodo	:= "A"					// Atualizar saldo Diario e Mensal do Fluxo de Caixa por Natureza Financeira
DEFAULT cOrigem		:= FunName()			// Função de Origem da Chamada da Função AtuSldNat()
DEFAULT cAlias		:= Alias()				// Alias posicionado no momento da chamada da função AtuSldNat()
DEFAULT nRecno		:= (cAlias)->(Recno())	// Número do Recno da tabela posicionada no momento da chamada da função AtuSldNat()
DEFAULT nOpcRot		:= 0					// Modo de Edição da rotina de origem da chamada da função AtuSldNat()
DEFAULT cTipoDoc    := ""
DEFAULT cMoeda		:= '01'					// Moeda Padrão utilizada no processso
DEFAULT nVlAbat     := 0                  // Valor do Abatimento
Default nTamNatur   := TamSX3("FIV_NATUR")[1]  
Default __lFivAbati := .T.
Default __lFiwAbati := .T.  
Default __lExistFJV := .T.
Default cFilSE1		:= Nil
Default lRatNat 	:= .F.

cFilFIV		:= xFilial("FIV", cFilSE1 )
cFilFIW		:= xFilial("FIW", cFilSE1 )
cFilFJV		:= xFilial("FJV", cFilSE1 )

If lIntPfs .And. !FwIsInCallStack("J241ExcAtu") .And. !FwIsInCallStack("JURSLDOHB")
	lRet := .T.

Else
	If !Empty(nVlrCor) .and. (cTipoSld == '3') .and. (nValor == nVlrCor) .and. (If(ValType(cMoeda) == "N",cMoeda,Val(cMoeda)) <> 1) 
		nVlrCor := xMoeda(nVlrCor,If(ValType(cMoeda) == "N",cMoeda,Val(cMoeda)),1,dData)
	EndIf

	/*
	* Se as tabelas não existirem no dicionário de dados, a atualização de saldos não é executada (Proteção)
	* E se Fluxo de Caixa somente para a localização BRASIL 
	*/ 
	aAreaFIV		:= FIV->(GetArea())
	aAreaFIW		:= FIW->(GetArea())

	If cPaisLoc == "BRA" .And. NatAtuSal(cAlias,nRecno) //Verifica se atualiza saldo
		DbSelectArea("FIV")
		aAreaFIV := FIV->(GetArea())
		DbSelectArea("FIW")
		aAreaFIW := FIW->(GetArea())
		
		// Esta rotina esta disponivel apenas para ambientes TOPCONNECT
		// Converte o codigo da moeda para facilitar as chamadas em que o codigo da moeda eh numerico, ex. Financeiro
		If EMPTY(cMoeda)
			cMoeda := '01'
		ElseIf ValType(cMoeda) != "C"
			cMoeda := StrZero(cMoeda,2)
		ElseIf Len(AllTrim(cMoeda)) < 2
			cMoeda := StrZero(VAL(cMoeda),2)  	
		Endif
		
		/*
		* Formatando o parâmetro da natureza para o tamanho do campo do banco de dados para efetuar a
		* pesquisa corretamente nos saldos do fluxo de caixa por natureza.
		*/
		cNatureza := PADR(cNatureza,nTamNatur," ")

		If cMovFlxCxNt == "1" .or. (cMovFlxCxNt == "2" .and. cOrigem == "FINA800")

			/*
			* Ponto de Entrada no processo de atualização do saldos do fluxo de caixa por natureza financeira.
			*/
			If __lFASLDNAT
				lAtuSldNat := ExecBlock("FASLDNAT",.F.,.F.,{cOrigem, cAlias, nRecno, nOpcRot})
				lAtuSldNat := IIF(Valtype(lAtuSldNat) == "L", lAtuSldNat, .T.)
			EndIf
				
			If lAtuSldNat
				/* Verifica se a movimentacao possui origem nas SEs.
				Movimentacoes avulsas relacionadas a natureza nao podem ter seu saldo gravado,
				pois nunca existiu saldo orcado e previsto ou 
				ja efetuaram movimentacao do saldo no momento de sua origem.
				obs: validacao exclusiva para FINA800()
				*/
				If cOrigem == "FINA800"  
					dbSelectArea("SE1")
					dbSetOrder(3)
					If !SE1->(dbSeek(xFilial("SE1") + Alltrim(cNatureza)))
						lGrvSld := .F.
					EndIf
					// Se nao encontrou na SE1, procura na SE2
					If !lGrvSld
						dbSelectArea("SE2")
						dbSetOrder(2)
						If SE2->(dbSeek(xFilial("SE2") + AllTrim(cNatureza)))
							lGrvSld := .T.
						EndIf
					EndIf
					//Se não achou na SE1 e na SE2, pode ser movimento bancário
					If !lGrvSld
						dbSelectArea("SE5")
						dbSetOrder(4)
						If SE5->(dbSeek(xFilial("SE5") + Alltrim(cNatureza)))
							If SE5->E5_IDMOVI <> ''
								lGrvSld := .T.
							EndIf 
						EndIf
					EndIf
					
					If !lGrvSld .And. lRatNat
						SEV->(DbSetOrder(3))
						If SEV->(dbSeek(xFilial("SEV") + Alltrim(cNatureza))) .OR. cAlias == "SEV"
							lGrvSld := .T.
						EndIf
					EndIf 
					
					RestArea(aAreaFIV)
				EndIf
			
				lRet := .T.

				If cPeriodo $ "A#D" .And. lGrvSld
					// Grava FIV (Movimentos diarios)
					FIV->(DbSetOrder(1)) // FIV_FILIAL+FIV_NATUR+FIV_MOEDA+FIV_TPSALD+FIV_CARTEI+DTOS(FIV_DATA)
					If FIV->(MsSeek(cFilFIV + cNatureza + cMoeda + cTipoSld + cCarteira + DTOS(dData))	)
						RecLock("FIV",.F.)
					Else	
						RecLock("FIV",.T.)
						FIV->FIV_FILIAL	:= cFilFIV
						FIV->FIV_NATUR		:= cNatureza
						FIV->FIV_MOEDA		:= cMoeda
						FIV->FIV_TPSALD	:= cTipoSld
						FIV->FIV_CARTEI	:= cCarteira
						FIV->FIV_DATA		:= dData
					Endif
					If cSinal == "+"
						FIV->FIV_VALOR += nValor
						If __lFivAbati 
							FIV->FIV_ABATI += nVlAbat
						Endif
					Else
						FIV->FIV_VALOR -= nValor
						If __lFivAbati
							FIV->FIV_ABATI -= nVlAbat
						Endif
					Endif
					MsUnlock()
					FIV->( dbCommit() )
				Endif

				If cPeriodo $ "A#M" .And. lGrvSld			
					// Grava FIW (Saldos mensais)
					FIW->(DbSetOrder(1)) // FIW_FILIAL+FIW_NATUR+FIW_MOEDA+FIW_TPSALD+FIW_CARTEI+DTOS(FIW_DATA)
					If FIW->(MsSeek(cFilFIW + cNatureza + cMoeda + cTipoSld + cCarteira + DTOS(LastDay(dData)))	)
						RecLock("FIW",.F.)
					Else	
						RecLock("FIW",.T.)
						FIW->FIW_FILIAL	:= cFilFIW
						FIW->FIW_NATUR		:= cNatureza
						FIW->FIW_MOEDA		:= cMoeda
						FIW->FIW_TPSALD	:= cTipoSld
						FIW->FIW_CARTEI	:= cCarteira
						FIW->FIW_DATA		:= LastDay(dData)
					Endif
					If cSinal == "+"
						FIW->FIW_VALOR += nValor
						If !Empty( __lFiwAbati )
							FIW->FIW_ABATI += nVlAbat
						Endif
					Else
						FIW->FIW_VALOR -= nValor
						If !Empty( __lFiwAbati )
							FIW->FIW_ABATI -= nVlAbat
						Endif
					Endif
					MsUnlock()
					FIW->( dbCommit() )
				Endif

				If cPeriodo $ "A#D" .and. Val(cMoeda) > 1 .AND. nVlrCor > 0
						AtuSldNat(cNatureza		,;	// 1  -> Codigo da natureza em que o saldo sera atualizado
									dData 	 	,;	// 2  -> Data em que o saldo deve ser atualizado
									"01"  	 	,;	// 3  -> Codigo da moeda do saldo
									cTipoSld 	,;	// 4  -> Tipo de saldo (1=Orcado, 2=Previsto, 3=Realizado)
									cCarteira	,;	// 5  -> Codigo da carteira (P=Pagar, R=Receber)
									nVlrCor  	,; 	// 6  -> Valor que atualizara o saldo na moeda do saldo
									0			,; 	// 7  -> Valor que atualizara o saldo na moeda corrente
									cSinal	 	,;	// 8  -> Sinal para atualizacao (+) ou (-)
									cPeriodo	,;  // 9  -> Saldo a ser atualizado (D = Diario, M = Mensal, A = Ambos	(default)
									cOrigem	,;	// 10 -> Rotina de Origem do movimento de fluxo de caixa. Ex. FUNNAME()
									cAlias		,;	// 11 -> Alias onde ocorreu a movimentação de fluxo de caixa. Ex. SE2
									nRecno		,;	// 12 -> Número do registro no alias onde ocorreu a movimentação de fluxo de caixa.
									nOpcRot	)	// 13 -> Opção de manipulação da rotina de origem da chamada da função AtuSldNat()
				Endif
				// Atualização da FJV
				// Gravação dos campos padrões da FJV   
				If __lExistFJV
					If cPeriodo $ "A#D"
						cCodFJV := FaGetCodFJV()

						FJV->(DbSetOrder(1)) 
						RecLock("FJV", .T.)
						FJV->FJV_FILIAL 	:= cFilFJV
						FJV->FJV_CODIGO 	:= cCodFJV
						FJV->FJV_NATUR		:= cNatureza
						FJV->FJV_MOEDA		:= cMoeda
						FJV->FJV_TPSALD		:= cTipoSld
						FJV->FJV_CARTEI		:= cCarteira
						FJV->FJV_DATA		:= dData
						FJV->FJV_ALIAS		:= cAlias
						FJV->FJV_RECNO		:= nRecno
						FJV->FJV_TPMOV		:= Iif( cSinal == '+', '1', '2' ) // cSinal "1"-ADICAO OU "2"-ESTORNO
						FJV->FJV_ORIGEM 	:= cOrigem // Rotina que gerou o movimento
						FJV->FJV_CLORIG 	:= RetOriAli(cAlias , cCarteira, Alltrim(cOrigem), cTipoDoc ) // ( cAlias, cCarteira )

						If cSinal == "+"
							FJV->FJV_VALOR	:= nValor
						Else
							FJV->FJV_VALOR	:= nValor * -1
						Endif

						MsUnLock()  
						FJV->( dbCommit() )

						// Ponto de entrada para dados complementares
						If __lF022GRA
							ExecBlock("F022GRA",.F.,.F.,{ cNatureza, dData, cMoeda, cAlias  })
						Endif
					Endif
				Endif
			Endif
		Endif
	Endif

	// Restauro a area anterior, se esta nao estava em branco
	If !Empty(cAlias)
		DbSelectArea(cAlias)
	Endif
	RestArea(aAreaFIW)
	RestArea(aAreaFIV)
	RestArea(aArea)
EndIf

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} RETSLDNAT
Retorna saldo de uma determinada natureza
Arquivo original: FINXATU.PRX 

@param cNatureza - Codigo da natureza que se deseja o saldo
@param dData - Data em que se deseja o saldo
@param cMoeda - Codigo da moeda que se deseja o saldo
@param cTipoSld - Tipo do saldo desejado (1=Orçado, 2=Previsto, 3=Realizado)
@param cCarteira - Codigo da carteira desejada (P=Pagar, R=Receber)

@author Claudio Donizete de Souza
@since 26/04/2010
/*/
//-------------------------------------------------------------------
Function RetSldNat(cNatureza,;	// -> Codigo da natureza que se deseja o saldo
						 dData,;			// -> Data em que se deseja o saldo
						 cMoeda,;		// -> Codigo da moeda que se deseja o saldo
						 cTipoSld,;		// -> Tipo do saldo desejado (1=Orçado, 2=Previsto, 3=Realizado)
						 cCarteira)		// -> Codigo da carteira desejada (P=Pagar, R=Receber)

Local dUltDiaAnt := (FirstDay(dData)-1)
Local nRet := 0

FIW->(DbSetOrder(1)) // FIW_FILIAL+FIW_NATUR+FIW_MOEDA+FIW_TPSALD+FIW_CARTEI+DTOS(FIW_DATA)
If FIW->(MsSeek(xFilial("FIW")+cNatureza+cMoeda+cTipoSld+cCarteira+DTOS(LastDay(dUltDiaAnt))))
	While FIW->(!Eof()) .And.;
			FIW->FIW_FILIAL == xFilial("FIW") .And.;
			FIW_NATUR 	== cNatureza 	.And.;
			FIW_MOEDA 	== cMoeda 		.And.;
			FIW_TPSALD	== cTipoSld 	.And.;
			FIW_CARTEI	== cCarteira	.And.;
			FIW_DATA		<= dData
		nRet += FIW->FIW_VALOR
		FIW->(DbSkip())
	End
Endif

Return nRet


//-------------------------------------------------------------------
/*/{Protheus.doc} RETMOVNAT

Retorna o valor do movimento de uma determinada natureza em uma determinada data
Arquivo original: FINXATU.PRX 

@param cNatureza - Codigo da natureza que se deseja o saldo
@param dData - Data em que se deseja o saldo
@param cMoeda - Codigo da moeda que se deseja o saldo
@param cTipoSld - Tipo do saldo desejado (1=Orçado, 2=Previsto, 3=Realizado)
@param cCarteira - Codigo da carteira desejada (P=Pagar, R=Receber)

@author Claudio Donizete de Souza
@since 26/04/2010
/*/
//-------------------------------------------------------------------
Function RetMovNat(cNatureza,;	// -> Codigo da natureza que se deseja o saldo
						 dData,;			// -> Data em que se deseja o saldo
						 cMoeda,;		// -> Codigo da moeda que se deseja o saldo
						 cTipoSld,;		// -> Tipo do saldo desejado (1=Orçado, 2=Previsto, 3=Realizado)
						 cCarteira)		// -> Codigo da carteira desejada (P=Pagar, R=Receber)

Local nRet := 0

FIV->(DbSetOrder(1)) // FIV_FILIAL+FIV_NATUR+FIV_MOEDA+FIV_TPSALD+FIV_CARTEI+DTOS(FIV_DATA)
If FIV->(MsSeek(xFilial("FIV")+cNatureza+cMoeda+cTipoSld+cCarteira+DTOS(dData)))
	nRet := FIV->FIV_VALOR
Endif

Return nRet


//-------------------------------------------------------------------
/*/{Protheus.doc} RETORIALI

Retorna a origem do movimento para o Alias informado.
Arquivo original: FINXATU.PRX 

@param cNatureza - Codigo da natureza que se deseja o saldo
@param dData - Data em que se deseja o saldo
@param cMoeda - Codigo da moeda que se deseja o saldo
@param cTipoSld - Tipo do saldo desejado (1=Orçado, 2=Previsto, 3=Realizado)
@param cCarteira - Codigo da carteira desejada (P=Pagar, R=Receber)

@author TOTVS
@since 28/11/2011
/*/
//-------------------------------------------------------------------
Static Function RetOriAli( cAlias, cCarteira, cOrigem, cTipoDoc )                   
Local cRet := ''
cAlias := Alltrim(cAlias)

/*
"	TITR = Títulos a receber
"	TITP = Títulos a pagar
"	COMV = Comissão de vendas
"	APL  = Transações referentes a Aplicações 
"   EMP  = Transações referentes a Empréstimos
"   MVBR = Movimentação bancaria a Receber
"   MVBP = Movimentação bancaria a Pagar
*/
   
/* condiçoes abaixo foram feitas conforme a ultima versao do fonte do sourcesafe DATA: 02/12/2011*/
Do case
   Case cAlias == 'SE1' // Titulos a Receber
       cRet := 'TITR'   

   Case cAlias == "SEV" .AND. cCarteira == "R"   //Titulos a Receber Multinatureza
	   cRet := 'TITR'
                        
   Case cAlias == 'SE2' // Titulos a Pagar
       cRet := 'TITP'  
                       
                       
   Case cAlias == 'SEV' .AND. cCarteira == "P" // Titulos a Pagar Multinatureza
       cRet := 'TITP' 
   
   Case cAlias == 'SE3' // Comissoes de vendas
       cRet := 'COMV'

   Case cAlias == 'SEH' .AND. cCarteira == 'P' // Aplicacao 
       cRet := 'APL'

   Case cAlias == 'SE5' .AND. cCarteira == 'P' .AND. ( cOrigem == 'FINA171' .OR. cTipoDoc == 'AP' )//Aplicacao com FINA171 SE5
       cRet := 'APL'

   Case cAlias == 'SEH' .AND. cCarteira == 'R' .AND. ( cOrigem == 'FINA181' .OR. cTipoDoc == 'AP' )// Resgaste da Aplicacao -- Testado porem com o parametro cAlias o valor "SE5" em vez de "SEH"
       cRet := 'APL'
  
   Case cAlias == 'SEH' .AND. cCarteira == 'R'  //Emprestimo 
       cRet := 'EMP' 

   Case cAlias == 'SE5' .AND. cCarteira == 'R' .AND. ( cOrigem == 'FINA171' .OR. cTipoDoc == 'EP' )//Emprestimo com Fina171 SE5
       cRet := 'EMP' 
   
   Case cAlias == 'SE5' .AND. cCarteira == 'P' .AND. ( cOrigem == 'FINA181' .OR. cTipoDoc == 'EP' )//Resgate do emprestimo
       cRet := 'EMP' 
   
   Case cAlias == 'SE5' .AND. cCarteira == 'R' // Movimento bancario a Receber
       cRet := 'MVBR'

   Case cAlias == 'SE5' .AND. cCarteira == 'P'  // Movimento Bancario a Pagar
       cRet := 'MVBP'
   
   OtherWise
       cRet := 'NIDENTIF'
       
End Case

Return cRet




/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±                                                                         ±±
±±            Funcoes retiradas do arquivo FINXFUN.PRX                     ±±
±±                                                                         ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

//-------------------------------------------------------------------
/*/{Protheus.doc} CTBENT050
Verifica se as entidades contabeis adicionais estão ativas e foram 
usadas (Tabela SEZ).
Arquivo original: FINXFUN.PRX 

@author Julio Saraiva
@since 08/12/2013
/*/
//-------------------------------------------------------------------
Function CTBent050()
Local lRet			:= .T.
Local nPosEC05		:= 0
Local nPosED05		:= 0
Local nPosEC06      := 0
Local nPosED06		:= 0
Local nPosEC07		:= 0
Local nPosED07		:= 0
Local nPosEC08		:= 0
Local nPosED08		:= 0
Local nPosEC09		:= 0
Local nPosED09		:= 0
LOCAL nPosCus   := Ascan(aHeader,{|e| AllTrim(e[2]) == AllTrim("EZ_CCUSTO") } )
LOCAL nPosCon   := Ascan(aHeader,{|e| AllTrim(e[2]) == AllTrim("EZ_CONTA") } )
LOCAL nPosItCta := Ascan(aHeader,{|e| AllTrim(e[2]) == AllTrim("EZ_ITEMCTA") } )
Local nPosclvl  := Ascan(aHeader,{|e| Alltrim(e[2]) == "EZ_CLVL"})
Local nAscan := 0

__lEnt05		:= CtbQtdEntd() >= 5
__lEnt06		:= CtbQtdEntd() >= 6
__lEnt07		:= CtbQtdEntd() >= 7
__lEnt08		:= CtbQtdEntd() >= 8
__lEnt09		:= CtbQtdEntd() >= 9

If __lEnt05
	nPosED05 := aScan(aHeader,{|x| AllTrim(x[2]) == "EZ_EC05DB"})
	nPosEC05 := aScan(aHeader,{|x| AllTrim(x[2]) == "EZ_EC05CR"})
	If lRet .AND. nPosED05 > 0 .AND. nPosEC05 > 0
		nAscan := Ascan( aCols, { |e| 	e[nPosCus] == aCols[n][nPosCus] .And. If(nPosCon>0,e[nPosCon] == aCols[n][nPosCon],.T.) .And. e[nPosItCta] == aCols[n][nPosItCta] .And.;
					e[nPosClVl] == aCols[n][nPosClVl] .And. e[nPosED05] == aCols[n][nPosED05]  .and. ;
					e[nPosEC05] == aCols[n][nPosEC05]  .and. !e[len(e)] } )
																		 	
		If nAscan > 0 .And. n != nAscan .And. !aCols[n][nNumCol+1] .And. !__lEnt06
			Help(' ',1,"COMBENTI" ,,STR0001,2,0,,,,,, {}) //"Combinação de entidades repetida"
			lRet := .F.
		Endif

	Endif
Endif
If lRet
	If __lEnt06
		nPosED06 := aScan(aHeader,{|x| AllTrim(x[2]) == "EZ_EC06DB"})
		nPosEC06 := aScan(aHeader,{|x| AllTrim(x[2]) == "EZ_EC06CR"})
		If lRet .AND. nPosED06 > 0 .AND. nPosEC06 > 0
			nAscan := Ascan( aCols, { |e| 	e[nPosCus] == aCols[n][nPosCus] .And. If(nPosCon>0,e[nPosCon] == aCols[n][nPosCon],.T.) .And. e[nPosItCta] == aCols[n][nPosItCta] .And.;
								e[nPosClVl] == aCols[n][nPosClVl] .And. e[nPosED05] == aCols[n][nPosED05] .And. e[nPosED06] == aCols[n][nPosED06]  .and. ;
								e[nPosEC05] == aCols[n][nPosEC05] .And. e[nPosEC06] == aCols[n][nPosEC06]  .and. !e[len(e)] } )
								
			If nAscan > 0 .And. n != nAscan .And. !aCols[n][nNumCol+1] .And. !__lEnt07
				Help(' ',1,"COMBENTI" ,,STR0001,2,0,,,,,, {}) //"Combinação de entidades repetida"
				lRet := .F.
			Endif
			
		Endif
	Endif
Endif
If lRet
	If __lEnt07
		nPosED07 := aScan(aHeader,{|x| AllTrim(x[2]) == "EZ_EC07DB"})
		nPosEC07 := aScan(aHeader,{|x| AllTrim(x[2]) == "EZ_EC07CR"})
		If lRet .AND. nPosED07 > 0 .AND. nPosEC07 > 0
			nAscan := Ascan( aCols, { |e| 	e[nPosCus] == aCols[n][nPosCus] .And. If(nPosCon>0,e[nPosCon] == aCols[n][nPosCon],.T.) .And. e[nPosItCta] == aCols[n][nPosItCta] .And.;
								e[nPosClVl] == aCols[n][nPosClVl] .And. e[nPosED05] == aCols[n][nPosED05] .And. e[nPosED06] == aCols[n][nPosED06] .And.; 
								e[nPosED07] == aCols[n][nPosED07]  .and. ;
								e[nPosEC05] == aCols[n][nPosEC05] .And. e[nPosEC06] == aCols[n][nPosEC06] .And. ;
								e[nPosEC07] == aCols[n][nPosEC07]  .and. !e[len(e)] } )
			
			If nAscan > 0 .And. n != nAscan .And. !aCols[n][nNumCol+1] .And. !__lEnt08
				Help(' ',1,"COMBENTI" ,,STR0001,2,0,,,,,, {}) //"Combinação de entidades repetida"
				lRet := .F.
			Endif

		Endif
	Endif
Endif
If lRet
	If __lEnt08
		nPosED08 := aScan(aHeader,{|x| AllTrim(x[2]) == "EZ_EC08DB"})
		nPosEC08 := aScan(aHeader,{|x| AllTrim(x[2]) == "EZ_EC08CR"})
		If lRet .AND. nPosED08 > 0 .AND. nPosEC08 > 0
			nAscan := Ascan( aCols, { |e| 	e[nPosCus] == aCols[n][nPosCus] .And. If(nPosCon>0,e[nPosCon] == aCols[n][nPosCon],.T.) .And. e[nPosItCta] == aCols[n][nPosItCta] .And.;
								e[nPosClVl] == aCols[n][nPosClVl] .And. e[nPosED05] == aCols[n][nPosED05] .And. e[nPosED06] == aCols[n][nPosED06] .And. ;
								e[nPosED07] == aCols[n][nPosED07] .And. e[nPosED08] == aCols[n][nPosED08]  .and. ;
								e[nPosEC05] == aCols[n][nPosEC05] .And. e[nPosEC06] == aCols[n][nPosEC06] .And. ;
								e[nPosEC07] == aCols[n][nPosEC07] .And. e[nPosEC08] == aCols[n][nPosEC08]  .and. !e[len(e)] } )
								
			If nAscan > 0 .And. n != nAscan .And. !aCols[n][nNumCol+1] .And. !__lEnt09
				Help(' ',1,"COMBENTI" ,,STR0001,2,0,,,,,, {}) //"Combinação de entidades repetida"
				lRet := .F.
			Endif
			
		Endif
	Endif
Endif
If lRet
	If __lEnt09
		nPosED09 := aScan(aHeader,{|x| AllTrim(x[2]) == "EZ_EC09DB"})
		nPosEC09 := aScan(aHeader,{|x| AllTrim(x[2]) == "EZ_EC09CR"})
		If lRet .AND. nPosED09 > 0 .AND. nPosEC09 > 0
			nAscan := Ascan( aCols, { |e| 	e[nPosCus] == aCols[n][nPosCus] .And. If(nPosCon>0,e[nPosCon] == aCols[n][nPosCon],.T.) .And. e[nPosItCta] == aCols[n][nPosItCta] .And.;
								e[nPosClVl] == aCols[n][nPosClVl] .And. e[nPosED05] == aCols[n][nPosED05] .And. e[nPosED06] == aCols[n][nPosED06] .And. ;
								e[nPosED07] == aCols[n][nPosED07] .And. e[nPosED08] == aCols[n][nPosED08] .And. e[nPosED09] == aCols[n][nPosED09]  .and. ;
								e[nPosEC05] == aCols[n][nPosEC05] .And. e[nPosEC06] == aCols[n][nPosEC06] .And. ;
								e[nPosEC07] == aCols[n][nPosEC07] .And. e[nPosEC08] == aCols[n][nPosEC08] .And. e[nPosEC09] == aCols[n][nPosEC09]  .and. !e[len(e)] } )
								
			If nAscan > 0 .And. n != nAscan .And. !aCols[n][nNumCol+1]
				Help(' ',1,"COMBENTI" ,,STR0001,2,0,,,,,, {}) //"Combinação de entidades repetida"
				lRet := .F.
			Endif
			
		Endif
	Endif
Endif
Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} MNATALTN

Altera a natureza no rateio por centro de custo .
Arquivo original: FINXFUN.PRX 

@author Wagner Mobile Costa
@since 11/12/2002
/*/
//-------------------------------------------------------------------
Function MNatAltN

LOCAL cAlias := Alias()
LOCAL nOrder

If __OPC = 4 .And. 	Select("SEZTMP") > 0 .And. aCols[n][4] = "1"
	nOrder := SEZTMP->(IndexOrd())
	dbSelectArea("SEZTMP")
	// busca natureza no arquivo TMP de Mult Nat C.Custo
	If dbSeek(aCols[n][1])
		SEZTMP->(DbSetOrder(0))
		While SEZTMP->(!Eof()) .And. SEZTMP->EZ_NATUREZ == aCols[n][1]
				SEZTMP->EZ_NATUREZ := &(ReadVar())
				SEZTMP->(DbSkip())
		End
		SEZTMP->(DbSetOrder(nOrder))
	Endif
	DbSelectArea(cAlias)
Endif

Return .T.


//-------------------------------------------------------------------
/*/{Protheus.doc} MNATLINOK

Analisa a linha digitada (multplas naturezas).
Arquivo original: FINXFUN.PRX 

@author Claudio Donizete Souza
@since 23/05/2001
/*/
//-------------------------------------------------------------------
Function MNatLinOk()
LOCAL lRet := .T.,;
		nX			  ,;
		nLen		  ,;
		nSoma := 0 ,;
		nAscan
LOCAL cPic  := PesqPict("SE2","E2_VALOR",19)

LOCAL lFaValidMNat 	:= ExistBlock("FaValidMNat")
LOCAL lFaVldMNat 	:= ExistBlock("FaVldMNat")

LOCAL aAreaSED		:= SED->( GetArea() )

IF lFaVldMNat

	lRet := ExecBlock("FaVldMNat",.F.,.F.,{FunName()})

Else

	// Nao permite natureza sintetica
	If !aCols[n][Len(aCols[n])]
		SED->( dbSetOrder( 1 ) )
		SED->( MsSeek( xFilial( "SED" ) + aCols[n][1] ) )
		If SED->ED_TIPO == "1"	// Natureza Sintetica
			Help( " ", 1, "NATUREZ",, STR0002, 1, 0 ) //"Verifique se a natureza informada está classificada corretamente. Apenas naturezas do titpo analítico serão aceitas para este processo.!"
			lRet := .F.
		EndIf
		SED->( RestArea( aAreaSED ) )
	EndIf

	// Se a natureza j  estiver registrada e nao estiver apagada, nao permite nova
	// distribuicao para a mesma natureza
	nAscan := Ascan( aCols, { |e| e[1] == aCols[n][1] .And. !e[len(e)] } )
	If nAscan > 0 .And. n != nAscan .And. !aCols[n][Len(aCols[1])]
		Alert( STR0003 ) //"Natureza já está cadastrada!"
		lRet := .F.
	ElseIf Empty(aCols[n][1]) .And. !aCols[n][Len(aCols[1])] // Se a Natureza estiver vazia, avisa o usuário
		Alert(STR0004) //"É necessário informar o código da natureza"
		lRet := .F.
	ElseIf !aCols[n][Len(aCols[n])] .And. IF(Valtype(aCols[n][3]) == "C", Val(STRTRAN(aCols[n][3],",",".")), aCols[n][3]) <= 0		//Se o percentual estiver zerado
			Alert(STR0005) //"Informar um valor para o rateio."
			lRet := .F.
	Else
		nLen := Len(aCols)
		For nX := 1 To nLen
			// Se a linha nao estiver deletada, soma o valor digitado
			If !aCols[nX][Len(aCols[nX])]
				nSoma += aCols[nX][2]
			EndIf
		Next

		// Se a soma for maior que o valor a ser distribuido ou se foi pressionado
		// Ok e a Soma for diferente do valor distribuido, avisa e invalida o valor
		// digitado
		If Val(Str(nSoma,17,2)) > Val(Str(nVlTit,17,2)) .Or. ;
		   ((nOpca == 1) .And. Str(nSoma,17,2) != Str(nVlTit,17,2).and. Type("aRatEvEz")=="U") .or.;
		   (Type("aRatEvEz")<>"U" .and. aRatEvEz<>Nil .and. Len(aRatEvEz) == nLen .and. Str(nSoma,17,2) != Str(nVlTit,17,2))//tratando rotina automatica
		  	Help(" ",1,"TOTDISTRIB",, Iif(Type("aTit")=="A",Pad( aTit[6], 21 )  + Space(1) ,"");
											  + Trans(nVlTit, cPic) +;
											  Chr(13)  + Pad( STR0006, 20 ) + Space(1) +; //"Total Distribuido"
											  Trans(nSoma , cPic), 4, 0)
			lRet := .F.
		Endif

		//Se rateia por CC, verifica se digitou os rateios.
		If lRet .and. acols[n][4] == "1"
			If Select("SEZTMP")<= 0 .or. (Select("SEZTMP") > 0 .and. SEZTMP->(!DbSeek(acols[n][1])))
				If !(MulNatCC())
					lRet:= .F.
				Endif
			EndIf
		EndIf

	EndIf

	IF lFaValidMNat .And. lRet
		lRet := ExecBlock("FaValidMNat",.F.,.F.,{FunName()})
	Endif

Endif

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} MNCCNOK

Analisa o conteudo digitado no botão Cancela (Ponto de entrada de 
usuário - MulNatCC).
Arquivo original: FINXFUN.PRX 

@author Mauricio Pequim Jr.
@since 14/08/2002
/*/
//-------------------------------------------------------------------
Function MnccNOk()
LOCAL lRet := .T.

If ExistBlock("MNCCNOK")
	lRet := ExecBlock("MNCCNOK",.F.,.F.)
Endif

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} DELMNATBX

Apaga os registros da distribuicao da Multiplas Naturexas no cancelamento 
da baixa.
Arquivo original: FINXFUN.PRX 

@author Mauricio Pequim Jr.
@since 28/10/2003
/*/
//-------------------------------------------------------------------
FUNCTION DelMNatBx(cAlias,nHdlPrv,nTotal,cArquivo,lExclui,cSeqSE5,lContabiliza,lUsaFlag,aFlagCTB)

LOCAL aSavArea 	:= 	GetArea()
LOCAL aSavArea1	:= 	(cAlias)->(GetArea())
LOCAL cPadrao		:= 	If(cAlias=="SE1","527","531")  // LP da Multi Nat sem C.Custo
LOCAL lPadrao		:= 	VerPadrao(cPadrao)
LOCAL cPadraoCC	:= 	If(cAlias=="SE1","538","539")  // LP da Multi Nat com C.Custo
LOCAL lPadraoCC	:= 	VerPadrao(cPadraoCC)
LOCAL cCarteira	:= 	If(cAlias=="SE1","R","P")
LOCAL cChaveSev	:= 	RetChaveBx(cAlias,"SEV")
LOCAL cChaveSez	:= 	RetChaveBx(cAlias,"SEZ")
LOCAL nVLCruz	:= If(cAlias=="SE1",SE1->E1_VLCRUZ,SE2->E2_VLCRUZ) // Valor CRUZ

DbSelectArea(cAlias)
nRecno := Recno()
DbGoBottom()
DbSkip()

DelBxSeZ(cAlias,cChaveSEZ,@nHdlPrv,@nTotal,@cArquivo,lPadrao,lPadraoCC,cPadraoCC,;
			cCarteira,lExclui,cSeqSE5,lContabiliza,lUsaFlag,@aFlagCTB)

DelBxSev(cAlias,cChaveSEV,@nHdlPrv,@nTotal,@cArquivo,lPadrao,cPadrao,cCarteira,;
			lExclui,cSeqSE5,lContabiliza,lUsaFlag,@aFlagCTB,nVLCruz)

RestArea( aSavArea )
(cAlias)->(RestArea(aSavArea1))

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} DELBXSEV

Apaga os registros da distribuicao da Multiplas Naturezas (SEV) no 
cancelamento da baixa (ligada a DelMNatBx()).
Arquivo original: FINXFUN.PRX 

@author Mauricio Pequim Jr.
@since 27/10/2003
/*/
//-------------------------------------------------------------------
Static Function DelBxSev(cAlias,cChave,nHdlPrv,nTotal,cArquivo,lPadrao,cPadrao,;
							cCarteira,lExclui,cSeqSe5,lContabiliza,lUsaFlag,aFlagCTB,nValorCRUZ)

LOCAL lContab 	:= .F.
LOCAL lAliasOK	:= .F.
LOCAL aSEV 		:= {}
LOCAL nProxReg 	:= 0
LOCAL nX 		:= 0
LOCAL cAliasAux	:= ""
LOCAL cCpoData	:= ""
LOCAL cCpoMoed	:= ""

nValor := 0

DbSelectArea("SEV")
dbSetOrder(2)  //Ajustar ordem após acertar o Atusx
MsSeek(cChave+"2"+cSeqSE5)

If cAlias == 'SE1'
	cAliasAux	:= "FK1"
	cCpoData	:= FK1->FK1_DATA
	cCpoMoed	:= FK1->FK1_MOEDA
ElseIf cAlias == 'SE2'
	cAliasAux	:= "FK2"
	cCpoData	:= FK2->FK2_DATA
	cCpoMoed	:= FK2->FK2_MOEDA
EndIf
lAliasOK	:= !Empty(cAliasAux)

While xFilial("SEV")+SEV->(EV_PREFIXO+EV_NUM+EV_PARCELA+EV_TIPO+EV_CLIFOR+;
								   EV_LOJA+EV_IDENT+EV_SEQ) == cChave+"2"+cSeqSE5 .And. !Eof()

	nRecAtu := Recno()
	dbskip()
	nProxReg := Recno()
	dbgoto(nRecAtu)

	If SEV->EV_RECPAG != cCarteira .or. SEV->EV_SITUACA $ "X/E"
		dbSkip()
		Loop
	Endif

	If lExclui  //Exclusao de baixa
		lContab := lPadrao .and. SEV->EV_LA == "S" .and. SEV->EV_RATEICC == "2"
	Else
		lContab := lPadrao .and. lContabiliza .and. SEV->EV_RATEICC == "2"
	Endif

		AtuSldNat(SEV->EV_NATUREZ,; 										// 1 - Codigo da natureza em que o saldo sera atualizado
					Iif(lAliasOK, cCpoData, SE5->E5_DATA),;					// 2 - Data em que o saldo deve ser atualizado
					Iif(lAliasOK, cCpoMoed, SE5->E5_MOEDA),;				// 3 - Codigo da moeda do saldo
					"3",;													// 4 - Tipo de saldo (1=Orcado, 2=Previsto, 3=Realizado)
					SEV->EV_RECPAG,;										// 5 - Codigo da carteira (P=Pagar, R=Receber)
					SEV->EV_VALOR,;											// 6 - Valor que atualizara o saldo na moeda do saldo
					SEV->EV_PERC * nValorCRUZ,;								// 7 - Valor que atualizara o saldo na moeda corrente
					If(SE5->E5_TIPO $ MVPAGANT+"/"+MV_CPNEG,"+","-"),;		// 8 - Sinal para atualizacao (+) ou (-)
					,;														// 9 - Saldo a ser atualizado (D = Diario, M = Mensal, NIL = Ambos	(importante apenas no recalculo)
					FunName(),;												// 10 - Rotina de Origem do movimento de fluxo de caixa. Ex. FUNNAME()
					"SEV",;													// 11 - Alias onde ocorreu a movimentação de fluxo de caixa. Ex. SE2
					SEV->(Recno()),;										// 12 - Número do registro no alias onde ocorreu a movimentação de fluxo de caixa.
					0 )														// 13 - Opção de manipulação da rotina de origem da chamada da função AtuSldNat()	
	//Contabilizacao da exclusao de Multi Naturezas sem Rateio C.Custo
	IF lContab
		If nHdlPrv <= 0
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Inicializa Lancamento Contabil                                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nHdlPrv := HeadProva( cLote,;
				                      If( cAlias == "SE1", "FINA070", "FINA080" ) /*cPrograma*/,;
				                      Substr( cUsuario, 7, 6 ),;
				                      @cArquivo )
		Endif
		If nHdlPrv > 0
			VALOR		:= SEV->EV_VALOR	// Valor Principal
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Prepara Lancamento Contabil                                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
					aAdd( aFlagCTB, {"EV_LA", "S", "SEV", SEV->( Recno() ), 0, 0, 0} )
				Endif
				nTotal += DetProva( nHdlPrv,;
				                    cPadrao,;
				                    If( cAlias == "SE1", "FINA070", "FINA080" ) /*cPrograma*/,;
				                    cLote,;
				                    /*nLinha*/,;
				                    /*lExecuta*/,;
				                    /*cCriterio*/,;
				                    /*lRateio*/,;
				                    /*cChaveBusca*/,;
				                    /*aCT5*/,;
				                    /*lPosiciona*/,;
				                    @aFlagCTB,;
				                    /*aTabRecOri*/,;
				                    /*aDadosProva*/ )

		Endif
	Endif

	//************************************
	//   Lançamentos de Rateio no PCO    *
	//************************************
	PcoDetLan("000005","03","FINA080",.T.)
	PcoDetLan("000006","02","FINA090",.T.)
	PcoDetLan("000004","09","FINA090",.T.)

   If lExclui
		RecLock("SEV")
		dbDelete()   // OU GRAVO CAMPO EV_SITUACA = "C"  ???
		MsUnLock()
	Else
		RecLock("SEV")
		SEV->EV_SITUACA := "X"   //Estornado no titulo principal
		MsUnlock()
		FKCOMMIT()
		aSEV := {}
		For nX := 1 to SEV->( Fcount() )
			 AAdd( aSEV, SEV->( FieldGet(nX) ) )
		NEXT
		//+-----------------------------------------------------+
		//¦ Grava o registro de estorno                         ¦
      //+-----------------------------------------------------+
      RecLock("SEV" ,.T.)
		For nX := 1 to SEV->(Fcount())
			SEV->( FieldPut( nX,aSEV[nX]))
		Next
		SEV->EV_SITUACA	:= "E"	//Marco Estornado no registro de estorno
		SEV->EV_LA 			:= If( !lUsaFlag .and. lContab .and. (nTotal > 0), "S", "N" )
		MsUnlock()
		FKCOMMIT()
	Endif
	dbGoto(nProxReg)
Enddo

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} DELBXSEZ

Apaga os registros da distribuicao da Multiplas Naturezas (SEZ) no 
cancelamento da baixa (ligada a DelMNatBx()).
Arquivo original: FINXFUN.PRX 

@author Mauricio Pequim Jr.
@since 28/10/2003
/*/
//-------------------------------------------------------------------
Static Function DelBxSEZ(cAlias,cChave,nHdlPrv,nTotal,cArquivo,lPadrao,lPadraoCC,;
									cPadraoCC,cCarteira,lExclui,cSeqSE5,lContabiliza,lUsaFlag,aFlagCTB)

LOCAL lContab := .F.
LOCAL aSEZ := {}
LOCAL nProxReg := 0
LOCAL nRegAtu := 0
LOCAL nX := 0
LOCAL aAreaSEZ := {}

nTotal := 0

DbSelectArea("SEZ")
MsSeek(cChave)
While xFilial("SEZ")+SEZ->(EZ_PREFIXO+EZ_NUM+EZ_PARCELA+EZ_TIPO+EZ_CLIFOR+;
								   EZ_LOJA) == cChave .And. !Eof()

	nRegAtu := Recno()
	dbSkip()
	nProxReg := Recno()
	dbGoto(nRegAtu)

	If SEZ->EZ_RECPAG == cCarteira .and. SEZ->EZ_IDENT == "2" .and. ;
		SEZ->EZ_SEQ == cSeqSE5 .and. !(SEZ->EZ_SITUACA $ "E/X")
		
		// Posiciona no registro PAI da tabela SEV. 
		aAreaSEZ := GetArea()
		DbSelectArea("SEV")
		SEV->(DbSetOrder(2))
		SEV->(MsSeek(cChave+SEZ->(EZ_IDENT+EZ_SEQ+EZ_NATUREZ)))
		RestArea(aAreaSEZ)

		If lExclui // Exclusao de baixas
			lContab := lPadrao .And. lPadraoCC .And. SEZ->EZ_LA == "S"
		Else
			lContab := lPadrao .And. lPadraoCC .And. lContabiliza
		Endif
		//Contabilizacao da exclusao de Multi Naturezas sem Rateio C.Custo
		IF lContab
			If nHdlPrv <= 0
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Inicializa Lancamento Contabil                                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					nHdlPrv := HeadProva( cLote,;
					                      If( cAlias == "SE1", "FINA070", "FINA080" ) /*cPrograma*/,;
					                      Substr( cUsuario, 7, 6 ),;
					                      @cArquivo )
			Endif
			If nHdlPrv > 0
				VALOR := SEZ->EZ_VALOR		// Valor Principal
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Prepara Lancamento Contabil                                      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
						aAdd( aFlagCTB, {"EV_LA", "S", "SEV", SEV->( Recno() ), 0, 0, 0} )
					Endif
					nTotal += DetProva( nHdlPrv,;
					                    cPadraoCC /*cPadrao*/,;
					                    If( cAlias == "SE1", "FINA070", "FINA080" ) /*cPrograma*/,;
					                    cLote,;
					                    /*nLinha*/,;
					                    /*lExecuta*/,;
					                    /*cCriterio*/,;
					                    /*lRateio*/,;
					                    /*cChaveBusca*/,;
					                    /*aCT5*/,;
					                    /*lPosiciona*/,;
					                    @aFlagCTB,;
					                    /*aTabRecOri*/,;
					                    /*aDadosProva*/ )
			Endif
		Endif

		//************************************
		//   Lançamentos de Rateio no PCO    *
		//************************************
		PcoDetLan("000005","04","FINA080",.T.)
		PcoDetLan("000006","03","FINA090",.T.)
		PcoDetLan("000004","10","FINA090",.T.)

	   If lExclui
			RecLock("SEZ")
			dbDelete()   // OU GRAVO CAMPO EV_SITUACA = "C"  ???
			MsUnLock()
		Else
			RecLock("SEZ")
			SEZ->EZ_SITUACA := "X"   //Estornado no titulo principal
			MsUnlock()
			FKCOMMIT()
			aSEZ := {}
			For nX := 1 to SEZ->( Fcount() )
				 AAdd( aSEZ, SEZ->( FieldGet(nX) ) )
			NEXT
			//+-----------------------------------------------------+
			//¦ Grava o registro de estorno                         ¦
			//+-----------------------------------------------------+
			RecLock("SEZ" ,.T.)
			For nX := 1 to SEZ->(Fcount())
				SEZ->( FieldPut( nX,aSEZ[nX]))
			Next
			SEZ->EZ_SITUACA	:= "E"   //Estorno no registro de estorno
			SEZ->EZ_LA			:= If( !lUsaFlag .and. lContab .and. (nTotal > 0), "S", "N" )
			MsUnlock()
			FKCOMMIT()
		Endif
	Endif
	Dbgoto(nProxReg)
Enddo

Return .T.


//-------------------------------------------------------------------
/*/{Protheus.doc} DELMULTNAT

Apaga os registros do rateio multinatureza quando o titulo for excluido.
Arquivo original: FINXFUN.PRX 

@author Claudio Donizete de Souza
@since 28/05/2001
/*/
//-------------------------------------------------------------------
FUNCTION DelMultNat( cAlias, nHdlPrv, nTotal, cArquivo, lSoContabiliza, aCols, lUsaFlag, aFlagCTB )
LOCAL aSavArea 	:= 	GetArea()
LOCAL aSavArea1	:= 	(cAlias)->(GetArea())
LOCAL cPadrao		:= 	If(cAlias=="SE1","505","515")  // LP da Multi Nat sem C.Custo
LOCAL lPadrao		:= 	VerPadrao(cPadrao)
LOCAL cPadraoCC	:= 	If(cAlias=="SE1","507","509")  // LP da Multi Nat com C.Custo
LOCAL lPadraoCC	:= 	VerPadrao(cPadraoCC)
LOCAL cCarteira	:= 	If(cAlias=="SE1","R","P")
LOCAL cChaveSev	:= 	RetChaveSev(cAlias,,"SEV")
LOCAL cChaveSez	:= 	RetChaveSev(cAlias,,"SEZ")
LOCAL cChaveIrf	:= 	If(cAlias = "SE2" .And. SE2->E2_IRRF > 0, SE2->E2_PREFIXO +;
				 				SE2->E2_NUM + SE2->E2_PARCIR +;
	 							Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA), "")
LOCAL cChaveIns	:= 	If(cAlias = "SE2" .And. SE2->E2_INSS > 0, SE2->E2_PREFIXO +;
								SE2->E2_NUM + SE2->E2_PARCINS +;
								Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"INA",MVINSS), "")
LOCAL cChaveIss	:= 	If(cAlias = "SE2" .And. SE2->E2_ISS > 0, SE2->E2_PREFIXO +;
								SE2->E2_NUM + SE2->E2_PARCISS + MVISS, "")


LOCAL cChavePis	:= 	If(cAlias = "SE2" .And. SE2->E2_PIS > 0, SE2->E2_PREFIXO +;
				 				SE2->E2_NUM + SE2->E2_PARCPIS +;
	 							Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA), "")

LOCAL cChaveCof	:= 	If(cAlias = "SE2" .And. SE2->E2_COFINS > 0, SE2->E2_PREFIXO +;
				 				SE2->E2_NUM + SE2->E2_PARCCOF +;
	 							Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA), "")

LOCAL cChaveCsl	:= 	If(cAlias = "SE2" .And. SE2->E2_CSLL > 0, SE2->E2_PREFIXO +;
				 				SE2->E2_NUM + SE2->E2_PARCSLL +;
	 							Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA), "")

LOCAL cChaveCid	:= 	If(cAlias = "SE2" .And. cPaisLoc == "BRA" .And. SE2->E2_CIDE > 0, SE2->E2_PREFIXO +;
				 				SE2->E2_NUM + SE2->E2_PARCCID + "CID", "")	 							

LOCAL cLojaImp	:= PadR( "00", TamSX3( "A2_LOJA" )[1], "0" )

LOCAL _cMvUniao := SuperGetMV("MV_UNIAO",.F.,"")   

LOCAL _cMvFInss := SuperGetMv("MV_FORINSS",.F.,"") 

LOCAL _cMvMunic := SuperGetMv("MV_MUNIC",.F.,"")

LOCAL _cMvFCide := SuperGetMV("MV_FORCIDE",.F.,"")

DEFAULT lSoContabiliza := .F.
DEFAULT nHdlPrv	:= 0
DEFAULT nTotal		:= 0

//Bloqueio a contabilizacao quando rotina chamada atraves dos modulos de Compras ou Faturamento
//A contabilizacao sera realizada atraves de LPs proprios
If cModulo $ "FAT#COM"
	lPadrao := .F.
	lPadraoCC := .F.
Endif

DbSelectArea(cAlias)
nRecno := Recno()

DelMultSev(	cAlias,cChaveSev,@nHdlPrv,@nTotal,@cArquivo,lPadrao,cPadrao,cCarteira,;
			lSoContabiliza, "1", nRecno)

DelMultSeZ(	cAlias,cChaveSez,@nHdlPrv,@nTotal,@cArquivo,lPadraoCC,cPadraoCC,cCarteira,;
			lSoContabiliza, "1", aCols, nRecno)

// Delete o rateio dos impostos vinculados ao titulo

If ! Empty(cChaveIrf)
	cChaveIrf += _cMvUniao + Space(Len(SE2->E2_FORNECE) - Len(_cMvUniao)) + cLojaImp
	DelMultSev(	cAlias,xFilial("SEV") + cChaveIrf,@nHdlPrv,@nTotal,@cArquivo,;
				lPadrao,cPadrao,cCarteira,, "2", nRecno)
	DelMultSeZ(	cAlias,xFilial("SEZ") + cChaveIrf,@nHdlPrv,@nTotal,@cArquivo,;
				lPadraoCC,cPadraoCC,cCarteira,, "2",, nRecno)
Endif

If ! Empty(cChaveIns)
	cChaveIns += _cMvFInss + Space(Len(SE2->E2_FORNECE) - Len(_cMvFInss)) + cLojaImp
	DelMultSev(	cAlias,xFilial("SEV") + cChaveIns,@nHdlPrv,@nTotal,@cArquivo,;
				lPadrao,cPadrao,cCarteira,, "3", nRecno)
	DelMultSeZ(	cAlias,xFilial("SEZ") + cChaveIns,@nHdlPrv,@nTotal,@cArquivo,;
				lPadraoCC,cPadraoCC,cCarteira,, "3",, nRecno)
Endif

If ! Empty(cChaveIss)
	cChaveIss += _cMvMunic + Space(Len(SE2->E2_FORNECE) - Len(_cMvMunic)) + cLojaImp
	DelMultSev(	cAlias,xFilial("SEV") + cChaveIss,@nHdlPrv,@nTotal,@cArquivo,;
				lPadrao,cPadrao,cCarteira,, "4", nRecno)
	DelMultSeZ(	cAlias,xFilial("SEZ") + cChaveIss,@nHdlPrv,@nTotal,@cArquivo,;
				lPadraoCC,cPadraoCC,cCarteira,, "4",, nRecno)
Endif


If ! Empty(cChavePis)
	cChavePis += _cMvUniao + Space(Len(SE2->E2_FORNECE) - Len(_cMvUniao)) + cLojaImp
	DelMultSev(	cAlias,xFilial("SEV") + cChavePis,@nHdlPrv,@nTotal,@cArquivo,;
				lPadrao,cPadrao,cCarteira,, "5", nRecno)
	DelMultSeZ(	cAlias,xFilial("SEZ") + cChavePis,@nHdlPrv,@nTotal,@cArquivo,;
				lPadraoCC,cPadraoCC,cCarteira,, "5",, nRecno)
Endif

If ! Empty(cChaveCof)
	cChaveCof += _cMvUniao + Space(Len(SE2->E2_FORNECE) - Len(_cMvUniao)) + cLojaImp
	DelMultSev(	cAlias,xFilial("SEV") + cChaveCof,@nHdlPrv,@nTotal,@cArquivo,;
				lPadrao,cPadrao,cCarteira,, "6", nRecno)
	DelMultSeZ(	cAlias,xFilial("SEZ") + cChaveCof,@nHdlPrv,@nTotal,@cArquivo,;
				lPadraoCC,cPadraoCC,cCarteira,, "6",, nRecno)
Endif

If ! Empty(cChaveCsl)
	cChaveCsl += _cMvUniao + Space(Len(SE2->E2_FORNECE) - Len(_cMvUniao)) + cLojaImp
	DelMultSev(	cAlias,xFilial("SEV") + cChaveCsl,@nHdlPrv,@nTotal,@cArquivo,;
				lPadrao,cPadrao,cCarteira,, "7", nRecno)
	DelMultSeZ(	cAlias,xFilial("SEZ") + cChaveCsl,@nHdlPrv,@nTotal,@cArquivo,;
				lPadraoCC,cPadraoCC,cCarteira,, "7",, nRecno)
Endif


If ! Empty(cChaveCid)
	cChaveCid += _cMvFCide + Space(Len(SE2->E2_FORNECE) - Len(_cMvFCide)) + cLojaImp
	DelMultSev(	cAlias,xFilial("SEV") + cChaveCid,@nHdlPrv,@nTotal,@cArquivo,;
				lPadrao,cPadrao,cCarteira,, "7", nRecno)
	DelMultSeZ(	cAlias,xFilial("SEZ") + cChaveCid,@nHdlPrv,@nTotal,@cArquivo,;
				lPadraoCC,cPadraoCC,cCarteira,, "7",, nRecno)
Endif

RestArea( aSavArea )
(cAlias)->(RestArea(aSavArea1))

Return Nil


//-------------------------------------------------------------------
/*/{Protheus.doc} DELMULTSEV

Apaga os registros do SEV, quando o titulo for excluido (ligada a DelMultNat).
Arquivo original: FINXFUN.PRX 

@author Wagner Mobile Costa
@since 19/11/2002
/*/
//-------------------------------------------------------------------
Static Function DelMultSev(	cAlias,cChave,nHdlPrv,nTotal,cArquivo,lPadrao,cPadrao,;
							cCarteira, lSoContabiliza, cTpCtb, nRecno)

LOCAL cPadOri 	:= If(cAlias=="SE1","500","510")
LOCAL lPadOri 	:= VerPadrao(cPadOri)
LOCAL lGrvSev 	:= ExistBlock("MULTSEV")
LOCAL lAtuSldNat := .T.
LOCAL cCampo   := Right(cAlias,2)

DEFAULT lSoContabiliza := .F.
DEFAULT nHdlPrv	:= 0
DEFAULT nTotal		:= 0

//Bloqueio a contabilizacao quando rotina chamada atraves dos modulos de Compras ou Faturamento
//A contabilizacao sera realizada atraves de LPs proprios
If cModulo $ "FAT#COM"
	lPadrao := .F.
	lPadraoCC := .F.
Endif

DbSelectArea("SEV")
MsSeek(cChave)
While xFilial("SEV")+SEV->(EV_PREFIXO+EV_NUM+EV_PARCELA+EV_TIPO+EV_CLIFOR+;
								   EV_LOJA) == cChave .And. !Eof()
	If SEV->EV_RECPAG == cCarteira
	    If ! lSoContabiliza
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Apaga os lancamentos gerados no PCO a partir do rateio por multi-natureza (05) ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cAlias == "SE1"
				PCODetLan( "000001", "04", "FINA040", .T. )
			Else
				PCODetLan( "000002", "04", "FINA050", .T. )
			EndIf
			RecLock("SEV" ,.F.,.T.)
		Endif
		//Contabilizacao da exclusao de Multi Naturezas sem Rateio C.Custo
		IF lPadrao .And. lPadOri .And. SEV->EV_LA == "S" .and. SEV->EV_RATEICC == "2"
			If nHdlPrv <= 0
				nHdlPrv:=HeadProva(cLote,If(cAlias=="SE1","FINA040","FINA050"),Substr(cUsuario,7,6),@cArquivo)
			Endif
			dbSelectArea( "SED" )
			MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
			dbSelectArea("SEV")
			If nHdlPrv > 0
				VALOR   := 0					// Valor Principal
				VALOR2  := 0					// Irf
				VALOR3  := 0					// Inss
				VALOR4  := 0					// Iss
				VALOR5  := 0					// Pis
				VALOR6  := 0					// Cofins
				VALOR7  := 0					// Csll

				If cTpCtb = "1"
					VALOR := SEV->EV_VALOR
				Endif
				If cTpCtb = "2"
					VALOR2 := SEV->EV_VALOR
				Endif
				If cTpCtb = "3"
					VALOR3 := SEV->EV_VALOR
				Endif
				If cTpCtb = "4"
					VALOR4 := SEV->EV_VALOR
				Endif
				If cTpCtb = "5"
					VALOR5 := SEV->EV_VALOR
				Endif
				If cTpCtb = "6"
					VALOR6 := SEV->EV_VALOR
				Endif
				If cTpCtb = "7"
					VALOR7 := SEV->EV_VALOR
				Endif

				nTotal+=DetProva(nHdlPrv,cPadrao,If(cAlias=="SE1","FINA040","FINA050"),cLote)
			Endif
		Endif
		If ! lSoContabiliza
			If lAtuSldNat
				DbSelectArea(cAlias)
				DbGoTo(nRecno)
				AtuSldNat(SEV->EV_NATUREZ, (cAlias)->&(cCampo + "_VENCREA"), (cAlias)->&(cCampo + "_MOEDA"), "2", If(cAlias=="SE1","R","P"), SEV->EV_VALOR,SEV->EV_PERC * (cAlias)->&(cCampo + "_VLCRUZ"), "-",,FunName(),"SEV",SEV->(Recno()),)
				DbSelectArea("SEV")
			Endif
			dbDelete()
			MsUnLock()
			If lGrvSev
				DbSelectArea(cAlias)
				DbGoTo(nRecno)
				ExecBlock("MULTSEV", .F., .F., { 5, Subs(cChave, 3), 0, 0, "" })
				DbSelectArea("SEV")
			Endif

		Endif
	EndIf
	DbSkip()
Enddo

Return .T.


//-------------------------------------------------------------------
/*/{Protheus.doc} DELMULTSEZ

Apaga os registros do SEZ, quando o titulo for excluido (ligada a DelMultNat).
Arquivo original: FINXFUN.PRX 

@author Wagner Mobile Costa
@since 19/11/2002
/*/
//-------------------------------------------------------------------
Static Function DelMultSez(	cAlias,cChave,nHdlPrv,nTotal,cArquivo,lPadrao,cPadrao,;
							cCarteira, lSoContabiliza, cTpCtb, aCols, nRecno)

LOCAL cPadOri 	:= If(cAlias=="SE1","500","510")
LOCAL lPadOri 	:= VerPadrao(cPadOri)
LOCAL lGrvSez 	:= ExistBlock("MULTSEZ")
Local nRegSed := SED->(Recno())
Local cFilSed := xFilial("SED")

DEFAULT lSoContabiliza := .F.
DEFAULT nHdlPrv	:= 0
DEFAULT nTotal		:= 0

//Bloqueio a contabilizacao quando rotina chamada atraves dos modulos de Compras ou Faturamento
//A contabilizacao sera realizada atraves de LPs proprios
If cModulo $ "FAT#COM"
	lPadrao := .F.
	lPadraoCC := .F.
Endif

// Deletar os Rateios de MultNat por C.Custo do titulo

SED->(DbSetOrder(1))
DbSelectArea("SEZ")
MsSeek(cChave)
While xFilial("SEZ")+SEZ->(EZ_PREFIXO+EZ_NUM+EZ_PARCELA+EZ_TIPO+EZ_CLIFOR+;
								   EZ_LOJA) == cChave .And. !Eof()
	If SEZ->EZ_RECPAG == cCarteira
		If aCols # Nil
			nAscan := Ascan( aCols, { |e| e[1] == SEZ->EZ_NATUREZ } )
		Endif

	    If ! lSoContabiliza .Or. (aCols # Nil .And. (nAscan = 0 .Or. aCols[nAScan][4] = "2"))
			//Gera o lancamento no PCO com os dados do lancamento de multi-natureza (05)
			If cAlias == "SE1"
				PCODetLan( "000001", "05", "FINA040", .T. )
			Else
				PCODetLan( "000002", "05", "FINA050", .T. )
			EndIf
			RecLock("SEZ" ,.F.,.T.)
		Endif
		
		//Contabilizacao da exclusao de Multi Naturezas sem Rateio C.Custo
		IF lPadrao .And. lPadOri .And. SEZ->EZ_LA == "S"
			If SED->ED_CODIGO <> SEZ->EZ_NATUREZ
				If !SED->(MsSeek(cFilSed + SEZ->EZ_NATUREZ))
					SED->(DbGoto(nRegSed))
				EndIf
			EndIf
			
			If nHdlPrv <= 0
				nHdlPrv:=HeadProva(cLote,If(cAlias=="SE1","FINA040","FINA050"),Substr(cUsuario,7,6),@cArquivo)
			Endif
			If nHdlPrv > 0
				VALOR 	:= 0					// Valor Principal
				VALOR2  := 0					// Irf
				VALOR3  := 0					// Inss
				VALOR4  := 0					// Iss
				VALOR5  := 0					// Pis
				VALOR6  := 0					// Cofins
				VALOR7  := 0					// Csll

				If cTpCtb = "1"
					VALOR := SEZ->EZ_VALOR
				Endif
				If cTpCtb = "2"
					VALOR2 := SEZ->EZ_VALOR
				Endif
				If cTpCtb = "3"
					VALOR3 := SEZ->EZ_VALOR
				Endif
				If cTpCtb = "4"
					VALOR4 := SEZ->EZ_VALOR
				Endif
				If cTpCtb = "5"
					VALOR5 := SEZ->EZ_VALOR
				Endif
				If cTpCtb = "6"
					VALOR6 := SEZ->EZ_VALOR
				Endif
				If cTpCtb = "7"
					VALOR7 := SEZ->EZ_VALOR
				Endif

				nTotal+=DetProva(nHdlPrv,cPadrao,If(cAlias=="SE1","FINA040","FINA050"),cLote)
			Endif
		Endif

	    If ! lSoContabiliza .Or. (aCols # Nil .And. (nAscan = 0 .Or. aCols[nAScan][4] = "2"))
			dbDelete()
			MsUnLock()
			If lGrvSez
				DbSelectArea(cAlias)
				DbGoTo(nRecno)
				ExecBlock("MULTSEZ", .F., .F., { 5, Subs(cChave, 3) })
				DbSelectArea(cAlias)
				DbGoBottom()
				DbSkip()
				DbSelectArea("SEZ")
			Endif
		Endif

	Endif
	DbSkip()
Enddo

SED->(DbGoto(nRegSed))
Return .T.


//-------------------------------------------------------------------
/*/{Protheus.doc} MNATCALCP

Calcula o Percentual digitado para natureza (Multiplas Naturezas).
Arquivo original: FINXFUN.PRX 

@author Claudio Donizete de Souza
@since 23/05/2001
/*/
//-------------------------------------------------------------------
Function MNatCalcP
LOCAL nX, nLen, lRet := .F., cAlias := Alias()

nValDist := 0
nValFal	:= 0
nPerFal	:= 0

If !Empty(m->ev_valor)

	aCols[n][2] := m->ev_valor
	// Calcula o percentual de acordo com o valor digitado
	aCols[n][3] := (m->ev_valor / nVlTit) * 100
	
	If 	Select("SEZTMP") > 0 .And. aCols[n][4] = "1"
		dbSelectArea("SEZTMP")

		// busca natureza no arquivo TMP de Mult Nat C.Custo
		If dbSeek(aCols[n][1])
			While !Eof() .and. SEZTMP->EZ_NATUREZ == aCols[n][1]
				SEZTMP->EZ_VALOR := m->ev_valor * SEZTMP->EZ_PERC
				SEZTMP->(DbSkip())
			EndDo
		Endif
		DbSelectArea(cAlias)
	Endif

	nLen := Len(aCols)
	For nX := 1 To nLen
		// Se a linha nao estiver deletada, acumula o valor digitado
		If !aCols[nX][Len(aCols[nX])]
			nValDist += aCols[nX][2]	//Valor Distribuido
			nPerFal	+= Iif(Valtype(aCols[nX][3]) == "C", Val(StrTran(aCols[nX][3], ",",".")), aCols[nX][3]) //Percentual Distribuido
			nValFal	:= nVlTit - nValDist //Valor que falta distribuir
		EndIf
	Next
	nPerFal	:= 100 - nPerFal		//Percentual que falta distribuir

	//Em função de numeração flutuante na gravação do Percentual.
	//Verifico se o Percentual que falta é maior que Valor que falta.
	If nPerfal > nValFal
	   nPerfal -= 0.01

	Endif

	if !Type("oMultNat") == "U"
		oMultNat:Refresh()
	endif
	if !Type("oValDist") == "U"
		oValDist:Refresh() // Atualiza o objeto na tela
	endif
	If !Type("oValFal") == "U"
		oValFal:Refresh() // Atualiza o objeto na tela
	Endif
	If !Type("oPerFal") == "U"
		oPerFal:Refresh() // Atualiza o objeto na tela
	Endif
	lRet := .T.

Else
	Alert(STR0022)		//"É necessario informar um valor maior que zero!"
Endif
Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} MNCCCALP

Calcula o Percentual equivalente ao valor digitado para C.Custo  
(Multiplas Naturezas).
Arquivo original: FINXFUN.PRX 

@author Mauricio Pequim Jr.
@since 14/08/2002
/*/
//-------------------------------------------------------------------
Function MnccCalP()
LOCAL lRet     := .F.
LOCAL nPosPer  := aScan(aHeader,{|x| x[2] == "EZ_PERC"})
LOCAL nPosVal  := aScan(aHeader,{|x| x[2] == "EZ_VALOR"})
Local nDif := 0 //diferença
Local nVlrRateio := 0

If Type( "nValNat" ) == "N"
	nVlrRateio := nValNat
Else
	nVlrRateio := nVlTit
EndIf

If m->ez_valor > 0
	// Calcula o percentual de acordo com o valor digitado
	nDif := (nVlrRateio - m->ez_valor) 
	aCols[n][nPosPer] := 100 - ((nDif * 100)/nVlrRateio)

	// Se a linha nao estiver deletada, acumula o valor digitado
	If !aCols[n][nNumCol+1]
		nValRat -= aCols[n][nPosVal]  //Valor anterior da acols
		nValRat += M->EZ_VALOR
	EndIf
	oValRat:Refresh() // Atualiza o objeto na tela
	lRet := .T.
Else
	Alert(STR0022)		//"É necessario informar um valor maior que zero!"
Endif
Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} MNATCALCV

Calcula o Valor digitado para natureza (Multiplas Naturezas)
Arquivo original: FINXFUN.PRX 

@author Claudio Donizete de Souza
@since 23/05/2001
/*/
//-------------------------------------------------------------------
Function MNatCalcV
LOCAL nX, nLen, lRet := .F., cAlias := Alias()
Local lCaract := .t.
Local nDec	:= GetSx3Cache("EV_VALOR","X3_DECIMAL")

nValDist := 0
nValFal	:= 0
nPerFal	:= 0

//Obtm a picture do campo EV_PERC ajustado de indice para percentual
cPictPerc		:= FPictPerc()

If !Empty(m->ev_perc)

	// Calcula o valor de acordo com o percentual digitado
	If Valtype(m->ev_perc) == "C"
		m->ev_perc := StrTran(m->ev_perc, " ", "", 1, 2)		
	Else	
		lCaract := .f.
	EndIf	
	
	aCols[n][2] := Iif(lCaract, Round(NoRound((VAL(StrTran(M->EV_PERC,",",".")) / 100)*nVlTit,3),2),(M->EV_PERC / 100)*nVlTit)
	aCols[n][2] := Round(NoRound(aCols[n][2],nDec+1),nDec)	
	aCols[n][3] := Iif(lCaract, Transform(Val(StrTran(m->ev_perc,",", ".")), cPictPerc ),M->EV_PERC)
	
	If 	Select("SEZTMP") > 0 .And. aCols[n][4] = "1"
		dbSelectArea("SEZTMP")

		// busca natureza no arquivo TMP de Mult Nat C.Custo
		If dbSeek(aCols[n][1])
			While !Eof() .and. SEZTMP->EZ_NATUREZ == aCols[n][1]
				SEZTMP->EZ_VALOR := aCols[n][2] * SEZTMP->EZ_PERC
				SEZTMP->(DbSkip())
			EndDo
		Endif
		DbSelectArea(cAlias)
	Endif

	nLen := Len(aCols)
	For nX := 1 To nLen
		// Se a linha nao estiver deletada, acumula o valor digitado
		If !aCols[nX][Len(aCols[nX])]
			nValDist += aCols[nX][2]	//Valor Distribuido			
			nPerFal  += IIF(ValType(aCols[nX][3])=="C", Val(StrTran(aCols[nX][3], ",", ".")), aCols[nX][3])	//Percentual Distribuido
			nValFal  := nVlTit - nValDist //Valor que falta distribuir

			IF nValfal <> 0 .AND. nPerFal == 100
				aCols[nX][2] := aCols[nX][2] + nValFal
				nValDist := nValDist + nValFal
				nValFal := 0
			ENDIF
		EndIf
	Next
	nPerFal	:= 100 - nPerFal		//Percentual que falta distribuir
	
	if !Type("oMultNat") == "U"
		oMultNat:Refresh()
	endif
	if !Type("oValDist") == "U"
		oValDist:Refresh() // Atualiza o objeto na tela
	endif
	If !Type("oValFal") == "U"
		oValFal:Refresh() // Atualiza o objeto na tela
	Endif
	If !Type("oPerFal") == "U"
		oPerFal:Refresh() // Atualiza o objeto na tela
	Endif
	lRet := .T.

Else
	Alert(STR0023)		//"É necessario informar um percentual maior que zero!"
Endif

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} MNCCCALV

Calcula o valor equivalente ao percentual digitado para C.Custo  
(Multiplas Naturezas).
Arquivo original: FINXFUN.PRX 

@author Mauricio Pequim Jr.
@since 14/08/2002
/*/
//-------------------------------------------------------------------
Function MnccCalV()
LOCAL lRet := .F.
LOCAL nValCus := 0
Local nCont := 0
Local nPosPer  := aScan(aHeader,{|x| x[2] == "EZ_PERC"})
Local nPosVal  := aScan(aHeader,{|x| x[2] == "EZ_VALOR"})
Local nTotPerc := 0
Local nDifTot  := 0

// Se percentual > 0
IF !Empty(m->ez_perc)
	// Calcula o valor de acordo com o percentual digitado	
	If ValType(m->ez_perc) == "C" 
		m->ez_perc := Val(m->ez_perc)
	EndIf	
	
	nValCus := Round(NoRound((M->EZ_PERC / 100)*nValNat,3),2)
	aCols[n][nPosPer] := m->ez_perc

	// Se a linha nao estiver deletada, acumula o valor digitado
	If !aCols[n][nNumCol+1]
		nValRat -= aCols[n][nPosVal]  // diminuo o valor anterior
		nValRat += nValCus      // Somo o valor atual
		aCols[n][nPosVal] := nValCus  // Atualizo no acols o valor
	EndIf
	oValRat:Refresh() // Atualiza o objeto na tela
	lRet := .T.

	For nCont := 1 to Len(aCols)
		If !(aCols[nCont][nNumCol+1])
			nTotPerc += aCols[nCont][nPosPer]
		Endif
	Next

	If nTotPerc == 100 //Atingiu 100% de percentual de rateio
		nValRat := 0
		For nCont := 1 to Len(aCols)
			If !(aCols[nCont][nNumCol+1])  // Verifica se linha esta deletada
				nValRat += aCols[ncont][nPosVal]
			Endif
		Next
		If (nDiftot := nValRat - nValNat) > 0 //Há diferença nos valores totais
			If !(aCols[Len(aCols)][nNumCol+1])
				aCols[Len(aCols)][nPosVal] := aCols[Len(aCols)][nPosVal] - nDifTot
				nValRat := 0
				For nCont := 1 to Len(aCols)
					If !(aCols[nCont][nNumCol+1])
						nValRat += aCols[ncont][nPosVal]
					Endif
				Next
				oValRat:Refresh()
			EndIf
		EndIf
	EndIf
Else
	Alert(STR0023)		//"É necessario informar um percentual maior que zero!"
Endif

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} CCCARREXT

Carrega definicoes do rateio externo baseado no CTJ (Multiplas Naturezas 
por C.Custo).
Arquivo original: FINXFUN.PRX 

@author Wagner Mobile Costa
@since 21/10/2002
/*/
//-------------------------------------------------------------------
Function CcCarrExt(aCols, aHeader, cItem, lPrimeiro)

LOCAL nPosCta   := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_CONTA") } )
LOCAL nPosCus   := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_CCUSTO") } )
LOCAL nPosVal   := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_VALOR") } )
LOCAL nPosPer   := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_PERC") } )
LOCAL nPosItCta := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_ITEMCTA") } )
LOCAL nPosClVl  := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_CLVL") } )

LOCAL nCols
Local nX 		:= 0
Local nRatTot  := 0
Local nPercTot := 0

Local lCtbIsCube    := .T.
Local aEntidades	:= {}
Local nEnt			:= 0
Local nDeb			:= 0
LOCAL lFNATRTEX	:= ExistBlock("FNATRTEX") // Ponto de Entrada Preenchimento aCols da tabela SEZ
LOCAL aFNATRTEX	:= {}
LOCAL nI			:= 0

If lPrimeiro
	Return .T.
Endif

// Varifica se ja existe um percentual informado, caso nao exista
// utiliza a linha atual para carregar os percentuais do CTJ. Senao
// Cria uma nova linha no aCols e le os percentuais do CTJ.
If aCols[Len(aCols)][nPosPer] = 0
	nCols := Len(aCols)
Else
	//Cria uma nova linha e grava o flag de deleção na ultima posição.
	Aadd(aCols, Array(Len(aHeader)))
	Aadd(aCols[Len(aCols)], .F.)
	nCols := Len(aCols)
Endif

If ! Empty(CTJ->CTJ_DEBITO)
	aCols[nCols][nPosCta] := Padl(CTJ->CTJ_DEBITO,  Len(CTJ->CTJ_DEBITO))
Else
	aCols[nCols][nPosCta] := Padl(CTJ->CTJ_CREDIT,  Len(CTJ->CTJ_CREDIT))
Endif

If ! Empty(CTJ->CTJ_CCD)
	aCols[nCols][nPosCus] := Padl(CTJ->CTJ_CCD,  Len(CTJ->CTJ_CCD))
Else
	aCols[nCols][nPosCus] := Padl(CTJ->CTJ_CCC,  Len(CTJ->CTJ_CCC))
Endif
aCols[nCols][nPosVal] := nValNat * (CTJ->CTJ_PERCEN / 100)
aCols[nCols][nPosPer] := CTJ->CTJ_PERCEN
If ! Empty(CTJ->CTJ_ITEMD)
	aCols[nCols][nPosItCta] := Padl(CTJ->CTJ_ITEMD,  Len(CTJ->CTJ_ITEMD))
Else
	aCols[nCols][nPosItCta] := Padl(CTJ->CTJ_ITEMC,  Len(CTJ->CTJ_ITEMC))
Endif

If ! Empty(CTJ->CTJ_CLVLDB)
	aCols[nCols][nPosClVl] := Padl(CTJ->CTJ_CLVLDB,  Len(CTJ->CTJ_CLVLDB))
Else
	aCols[nCols][nPosClVl] := Padl(CTJ->CTJ_CLVLCR,  Len(CTJ->CTJ_CLVLCR))
Endif

IF lFNATRTEX
	aFNATRTEX := ExecBlock("FNATRTEX",.F.,.F.,{aHeader, aCols[nCols]})
	IF VALTYPE(aFNATRTEX) == 'A' .AND. LEN(aFNATRTEX) > 0
		FOR nI := 1 TO LEN(aFNATRTEX)
			IF aFNATRTEX[nI][1] > 0 .AND. aFNATRTEX[nI][1] <= LEN(aCols[nCols])  
				aCols[nCols][aFNATRTEX[nI][1]] := aFNATRTEX[nI][2]
			ENDIF
		NEXT nI
	ENDIF
ENDIF

If lCtbIsCube
	aEntidades := CtbEntArr()
	For nEnt := 1 to Len(aEntidades)
		For nDeb := 1 to 2
			cCpo := "EZ_EC"+aEntidades[nEnt]
			cCTJ := "CTJ_EC"+aEntidades[nEnt]

			If nDeb == 1
				cCpo += "DB"
				cCTJ += "DB"
			Else
				cCpo += "CR"
				cCTJ += "CR"
			EndIf

			nPosHead := aScan(aHeader,{|x| AllTrim(x[2]) == Alltrim(cCpo) } )

			If nPosHead > 0 .And. CTJ->(FieldPos(cCTJ)) > 0
				aCols[nCols][nPosHead] := CTJ->(&(cCTJ))
			EndIf

		Next nDeb
	Next nEnt
EndIf


If !lPrimeiro
	For nX := 1 To Len(aCols)
		nPercTot += aCols[nX][nPosPer]
	Next nX

	If nPercTot == 100 //Atingiu 100% de rateio
		For nX := 1 To Len(aCols)
			nRatTot += Round(aCols[nX][nPosVal],TamSX3("EZ_VALOR")[2])
		Next nX

		If nRatTot > nValNat //Há diferença para mais
			aCols[Len(aCols)][nPosVal] := aCols[Len(aCols)][nPosVal] - (nRatTot - nValNat)
		EndIf

		If nValNat > nRatTot //Há diferença para menos
			aCols[Len(aCols)][nPosVal] := aCols[Len(aCols)][nPosVal] + (nValNat - nRatTot)
		EndIf

	EndIf
EndIf
Return .T.


//-------------------------------------------------------------------
/*/{Protheus.doc} MULNATCC

Distribui o valor da multinatureza em diversos C.Custo.
Arquivo original: FINXFUN.PRX 

@author Mauricio Pequim Jr.
@since 13/08/2002
/*/
//-------------------------------------------------------------------
Function MulNatCC(nOpc)
LOCAL aCposDB 	:= {}  // Campos para o arquivo temporario
LOCAL aSaveArea := GetArea()
LOCAL oDlg1		:= NIL
LOCAL aHead		:= {}  // Aheader da Getdados nova
LOCAL aColsNew	:= {} // aCols da Getdados nova
LOCAL aHeadOld	:= aClone(aHeader) //Guarda dados o Aheader da Getdados de onde foi chamada
LOCAL aColsOld	:= aClone(aCols) // Guarda colunas da Getdados anterior
LOCAL nOldPos	:= n  //Guard posição da GetDados de onde foi chamada
LOCAL aAltera	:= {}  // Campos da Getdb
LOCAL cCampo	:= IIf(Type("aTit[7]") <>"U",(Right(aTit[7],2))," ")// aTit[6] == SE1 ou SE2
LOCAL nCont		:= 0
LOCAL lDelFirst := .F.
LOCAL aRegs		:= {}
LOCAL aStruSez	:= {}
LOCAL nPosRec	:= 0
LOCAL nPosArq	:= n
LOCAL lMnatcc	:= Existblock("MNATCC")
LOCAL lConfirma := .T.
LOCAL lValF050C	:= .T.
LOCAL lF050VCMC	:= ExistBlock("F050VCMC")
LOCAL lPanelFin := IsPanelFin()
LOCAL oPanel	:= NIL
LOCAL oPanel2	:= NIL
LOCAL nPosCta   := 0
LOCAL nPosCus   := 0
LOCAL nPosVal   := 0
LOCAL nPosPer   := 0
LOCAL nPosItCta := 0
LOCAL nPosClVl  := 0
Local aRatCC	:= {}
Local nX		:= 0
Local nY		:= 0
Local lRet		:= .T.
Local nPosEv	:= 0
Local lAuto 	:=(((Type("lF040Auto")=="L" .and. lF040Auto).or. (Type("lF050Auto")=="L" .and. lF050Auto)) .and. Type ("aRatEvEz") <> "U" .and. aRatEvEz <> Nil)
Local nPosEC05	:= 0
Local nPosED05	:= 0
Local nPosEC06	:= 0
Local nPosED06	:= 0
Local nPosEC07	:= 0
Local nPosED07	:= 0
Local nPosEC08	:= 0
Local nPosED08	:= 0
Local nPosEC09	:= 0
Local nPosED09	:= 0
Local lTemEnt  	:= .F.
Local lConsulta	:= FwIsInCallStack("Fa050Rateio")
Local cOrigem 	:= FunName()
Local aMaior	:= {0,0}
Local nTotPerc	:= 0
Local lRutina   := Alltrim(FunName()) $ "MATA101N|MATA465N|MATA466N|MATA467N"
Local lMulNatCC := .F.
Local aColsUser	:= {}
Local nStatus	:= 0
Private aTELA	:= {}
Private aGETS	:= {}
Private oValRat	:= NIL
Private nValRat	:= 0		//Valor total rateado por C.Custo
Private nValNat := aCols[n][2] // Valor da natureza na Getdados de MultiNat
Private cNatur	:= aCols[n][1] // Natureza
Private nOpcC	:= 0
Private nNumCol := 0	// Numero de colunas do aCols
Private oGetDB	:= NIL

DEFAULT nOpc	:= 3

If cPaisLoc == "EUA" .AND. (Type("lLocxAuto")=="L" .AND. lLocxAuto)
	lMulNatCC :=  (Type("lMultNat")=="L" .AND. lMultNat) .AND. (Type("lProrrCC")=="L" .AND. lProrrCC) .AND. (Type("laRatEvEz")=="L" .AND. laRatEvEz)
	lAuto := lMulNatCC
Endif
// Se campos necessarios nao preenchidos
If Empty(aCols[n][1]) .or. Empty(aCols[n][2]) .or. Empty(aCols[n][3])
   aCols[n][4] := "2"
	Return .T.
Endif

//Obtm a picture do campo EV_PERC ajustado de indice para percentual
cPictPerc		:= FPictPerc()

__OPC := nOpc
//Campos a serem mostrados na Getdados
Aadd(aHead,{RetTitle("EZ_CCUSTO"),"EZ_CCUSTO","@!",;
				TamSx3("EZ_CCUSTO")[1],0,"Ctb105Cc()","û","C","SEZ" } )
Aadd(aHead,{RetTitle("EZ_VALOR"),"EZ_VALOR",PesqPict("SEZ","EZ_VALOR",TamSx3("EZ_VALOR")[1]),;
				TamSx3("EZ_VALOR")[1],TamSx3("EZ_VALOR")[2],"MnccCalP()","û","N","SEZ" } )
Aadd(aHead,{RetTitle("EZ_PERC"),"EZ_PERC",cPictPerc,;
				TamSx3("EZ_PERC")[1],TamSx3("EZ_PERC")[2],"MnccCalV()","û","N","SEZ" } )
Aadd(aHead,{RetTitle("EZ_CONTA"),"EZ_CONTA","@!",;
				TamSx3("EZ_CONTA")[1],0,"Ctb105Cta()","û","C","SEZ" } )
Aadd(aHead,{RetTitle("EZ_ITEMCTA"),"EZ_ITEMCTA","@!",;
				TamSx3("EZ_ITEMCTA")[1],0,"Ctb105Item()","û","C","SEZ" } )
Aadd(aHead,{RetTitle("EZ_CLVL"),"EZ_CLVL","@!",;
				TamSx3("EZ_CLVL")[1],0,"Ctb105Clvl()","û","C","SEZ" } )

//Campos a serem digitados
aadd(aAltera,"EZ_CCUSTO")
aadd(aAltera,"EZ_CONTA")
aadd(aAltera,"EZ_ITEMCTA")
aadd(aAltera,"EZ_CLVL")
aadd(aAltera,"EZ_VALOR")
aadd(aAltera,"EZ_PERC")

// Adiciona demais campos
SX3->(DbSetOrder(1))
SX3->(MsSeek("SEZ"))
While ! SX3->(EOF()) .And. (SX3->X3_Arquivo == "SEZ")
	If X3USO(SX3->X3_Usado) .And. cNivel >= SX3->X3_NIVEL .And.  !(AllTrim(SX3->X3_CAMPO) $ "EZ_IDDOC|EZ_TIPO|EZ_PORCENT") .AND. ;
		Ascan(aHead, {|e| Alltrim(e[2]) == Alltrim(SX3->X3_CAMPO) } ) == 0
		Aadd(aHead,{ AllTrim(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT } )
		aadd(aAltera,SX3->X3_CAMPO)
	Endif
	SX3->(DbSkip())
End

SX3->(DbSeek("SEZ_FILIAL"))
cUsado := SX3->X3_USADO
AADD( aHead, { "Alias WT","EZ_ALI_WT", "", 09, 0,, cUsado, "C", "SEZ", "V"} )
AADD( aHead, { "Recno WT","EZ_REC_WT", "", 09, 0,, cUsado, "N", "SEZ", "V"} )

aHeader := aClone(aHead)

nPosCta   := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_CONTA") } )
nPosCus   := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_CCUSTO") } )
nPosVal   := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_VALOR") } )
nPosPer   := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_PERC") } )
nPosItCta := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_ITEMCTA") } )
nPosClVl  := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_CLVL") } )

lTemEnt := .T.

If lTemEnt .and. CtbQtdEntd() > 4
	nPosEC05  := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_EC05DB") } )
	nPosED05  := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_EC05CR") } )
	nPosEC06  := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_EC06DB") } )
	nPosED06  := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_EC06CR") } )
	nPosEC07  := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_EC07DB") } )
	nPosED07  := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_EC07CR") } )
	nPosEC08  := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_EC08DB") } )
	nPosED08  := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_EC08CR") } )
	nPosEC09  := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_EC09DB") } )
	nPosED09  := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_EC09CR") } )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Adiciona mais um elemento em aCOLS, indicando se a	³
//³ a linha esta ou nao deletada							³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nNumCol := Len(aHeader)
Aadd(aColsNew,Array(nNumCol+1))
For nCont := 1 To nNumCol
    If !aHeader[nCont,2] $ "EZ_REC_WT|EZ_ALI_WT"
		aColsNew[1,nCont] := CriaVar(aHeader[nCont,2],.T.)
	Else
		If AllTrim(aHeader[nCont,2]) == "EZ_ALI_WT"
			aColsNew[1,nCont] := "SEZ"
		ElseIf AllTrim(aHeader[nCont,2]) == "EZ_REC_WT"
			aColsNew[1,nCont]:= 0
		EndIf
	EndIf

Next nCntFor
aColsNew [1,(nNumCol+1)] := .F.
aColsNew [1,nPosPer] := 0

aCols := aClone(aColsNew)

//Campos a serem digitados
aadd(aAltera,"EZ_CCUSTO")
aadd(aAltera,"EZ_CONTA")
aadd(aAltera,"EZ_ITEMCTA")
aadd(aAltera,"EZ_CLVL")
aadd(aAltera,"EZ_VALOR")
aadd(aAltera,"EZ_PERC")

If Select("SEZTMP") > 0 .And. !lConsulta .And. lCloseTbl
	FINXDETMP()
	lCloseTbl := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Gera arquivo de Trabalho      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If(_oFINXNAT1 == NIL)
	
	AAdd(aCposDB,{"EZ_NATUREZ","C",10,0})
	AAdd(aCposDB,{"EZ_CCUSTO","C",TamSx3("EZ_CCUSTO")[1],0})
	AAdd(aCposDB,{"EZ_CONTA","C",TamSx3("EZ_CONTA")[1],0})
	AAdd(aCposDB,{"EZ_ITEMCTA","C",TamSx3("EZ_ITEMCTA")[1],0})
	AAdd(aCposDB,{"EZ_CLVL","C",TamSx3("EZ_CLVL")[1],0})
	AAdd(aCposDB,{"EZ_VALOR","N",TamSx3("EZ_VALOR")[1],TamSx3("EZ_VALOR")[2]})
	AAdd(aCposDB,{"EZ_PERC","N",TamSx3("EZ_PERC")[1],TamSx3("EZ_PERC")[2]})	
	AAdd(aCposDB,{"EZ_FLAG","L",1,0})
	AAdd(aCposDB,{"EZ_RECNO","N",10,0})

	// Adiciona demais campos
	aStruSez := SEZ->(DbStruct())
	For nX := 1 To Len(aStruSez)
		If !(AllTrim(SX3->X3_CAMPO) $ "EZ_IDDOC|EZ_TIPO") .AND. Ascan(aCposDB, { |e| Alltrim(e[1]) == aStruSez[nX][1] } ) == 0
			Aadd(aCposDB,{aStruSez[nX][1],aStruSez[nX][2],aStruSez[nX][3],aStruSez[nX][4]})
		EndIf
	Next nX

	IIF(Select("SEZTMP") > 0, SEZTMP->(DbCloseArea()), Nil)

	//Cria o Objeto do FwTemporaryTable
	_oFINXNAT1 := FwTemporaryTable():New("SEZTMP")
	
	//Cria a estrutura do alias temporario
	_oFINXNAT1:SetFields(aCposDB)
	
	//Adiciona o indicie na tabela temporaria
	_oFINXNAT1:AddIndex("1",{"EZ_NATUREZ","EZ_CCUSTO"})
	
	//Criando a tabela temporaria
	_oFINXNAT1:Create()

	//Nome da tabela criada no BD
	__cFin1Name := _oFINXNAT1:GetRealName()
Endif

DbSelectArea("SEZTMP")
SEZTMP->( DbSetOrder(1) )
SEZTMP->( DbSeek( cNatur ) )

// Calcula o valor rateado anteriormente e alimenta a Getdados
nValRat := 0
nPosRec   := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_REC_WT") } )
nPosArq   := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_ALI_WT") } )

If !Eof() .and. !Bof()
	While !Eof() .and. SEZTMP->EZ_NATUREZ == cNatur
		
		For nCont := 1 To nNumCol
			If !aHeader[nCont,2] $ "EZ_REC_WT|EZ_ALI_WT"
				aCols[Len(aCols)][nCont] := SEZTMP->&(aHeader[nCont,2])	
			EndIf
		Next nCntFor

		aCols[Len(aCols)][nPosCus]		:= SEZTMP->EZ_CCUSTO  // Centro de Custo
		aCols[Len(aCols)][nPosVal]		:= SEZTMP->EZ_VALOR   //
		aCols[Len(aCols)][nPosPer]		:= If(lConsulta, SEZTMP->EZ_PERC, SEZTMP->EZ_PERC * 100)
		aCols[Len(aCols)][nPosCta]		:= SEZTMP->EZ_CONTA  // Conta
		aCols[Len(aCols)][nPosItCta]	:= SEZTMP->EZ_ITEMCTA  // Item
		aCols[Len(aCols)][nPosClVl]		:= SEZTMP->EZ_CLVL  // Classe de Valor

		If lTemEnt .and. CtbQtdEntd() > 4
			If nPosEC05 > 0
				aCols[Len(aCols)][nPosEC05] := SEZTMP->EZ_EC05DB
			EndIf
			If nPosED05 > 0
				aCols[Len(aCols)][nPosED05]	:= SEZTMP->EZ_EC05CR
			EndIf
			If nPosEC06 > 0
				aCols[Len(aCols)][nPosEC06] := SEZTMP->EZ_EC06DB
			EndIf
			If nPosED06 > 0
				aCols[Len(aCols)][nPosED06]	:= SEZTMP->EZ_EC06CR
			Endif
			If nPosEC07 > 0
				aCols[Len(aCols)][nPosEC07] := SEZTMP->EZ_EC07DB
			EndIf
			If nPosED07 > 0
		   		aCols[Len(aCols)][nPosED07]	:= SEZTMP->EZ_EC07CR
			EndIf
			If nPosEC08 > 0
		   		aCols[Len(aCols)][nPosEC08] := SEZTMP->EZ_EC08DB
			EndIf
			If nPosED08 > 0
		   		aCols[Len(aCols)][nPosED08]	:= SEZTMP->EZ_EC08CR
			EndIf
			If nPosEC09 > 0
		   		aCols[Len(aCols)][nPosEC09] := SEZTMP->EZ_EC09DB
			EndIf
			If nPosED09 > 0
		   		aCols[Len(aCols)][nPosED09]	:= SEZTMP->EZ_EC09CR
		    EndIf
		EndIf

		aCols[Len(aCols)][nPosRec]   := SEZTMP->(Recno())
		aCols[Len(aCols)][nPosArq]   := "SEZ"
		
		If aCols[Len(aCols)][nPosPer] > aMaior[2]
			aMaior[1]	:= Len(aCols)
			aMaior[2]	:= aCols[Len(aCols)][nPosPer]
		EndIf
		
		nTotPerc	+= aCols[Len(aCols)][nPosPer]
		
		//Se primeira linha for deletada, Forco o ultimo elemento da acols para .F.
		//e acerto apos a montagem da mesma
		If Len(aCols) == 1 .and. SEZTMP->EZ_FLAG
			aCols[Len(aCols)][nNumCol+1] := .F.  // Controle de delecao
			lDelFirst := .T.
		Else
			aCols[Len(aCols)][nNumCol+1] := SEZTMP->EZ_FLAG  // Controle de delecao
		Endif

		If !(SEZTMP->EZ_FLAG) .and. !lDelFirst
			nValRat += SEZTMP->EZ_VALOR
		EndIf
		AAdd(aRegs, SEZTMP->(Recno()))
		DbSkip()
		If !Eof() .and. SEZTMP->EZ_NATUREZ == cNatur
			AAdd(aCols,Array(nNumCol+1))
			For nCont := 1 To nNumCol
				If !aHeader[nCont,2] $ "EZ_REC_WT|EZ_ALI_WT"
					aCols[Len(aCols),nCont] := CriaVar(aHeader[nCont,2],.T.)
				Else
					If AllTrim(aHeader[nCont,2]) == "EZ_ALI_WT"
						aCols[Len(aCols),nCont] := "SEZ"
					ElseIf AllTrim(aHeader[nCont,2]) == "EZ_REC_WT"
						aCols[Len(aCols),nCont]:= 0
					EndIf
				EndIf
			Next nCont
			aCols[Len(aCols),(nNumCol+1)] := .F.
		EndIf
	EndDo
	lNewLine := .F.
	
	If nTotPerc > 100
		aCols[aMaior[1]][nPosPer]	:= aCols[aMaior[1]][nPosPer] - (nTotPerc-100) 	
	EndIf
	
EndIf

// Mostra o corpo da rateio
// Inicia como 2 pois só deve alterar o nOpcC no Confirmar da SEZ
nOpcC := 2

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de entrada para carregar regra de rateio especifica   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If __lNatSezLoad .And. nOpc==3
	If ValType(aColsUser:=ExecBlock("NATSEZLOAD",.F.,.F.,{aCols,aHeader,cNatur,nValNat})) == "A"
		aCols:=aClone(aColsUser)
	Endif
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de entrada para não permitir cancelar a tela |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lMNatCC
	lConfirma := ExecBlock("MNATCC",.F.,.F.)
EndIf

If !((Type("lF040Auto")=="L" .and. lF040Auto  ).or. (Type("lF050Auto")=="L" .and. lF050Auto  )) .and. !lMulNatCC
	While .T.

		DEFINE MSDIALOG oDlg1 TITLE STR0024 From 00,00 To 500,800 OF oMainWnd PIXEL			//"Multipla Natureza por C.Custo"

		oPanel := TPanel():New(0,0,'',oDlg1,, .T., .T.,, ,20,20,.T.,.T. )
		oPanel:Align := CONTROL_ALIGN_TOP

		@  002, 005 To  018,120 OF oPanel PIXEL
		@  002, 125 To  018,398 OF oPanel PIXEL

		If Alltrim(FunName()) $ "FINA040#FINA050#FINA750#FINA740" .and. nOpc == 3 .and. !(FwIsInCallStack("FINA080") .or. FwIsInCallStack("FINA070")) //Inclusao de titulos
			@ 006 , 010		Say aTit[1] + M->&(cCampo + If(aTit[7] == "SE1", "_CLIENTE","_FORNECE"))	FONT oDlg1:oFont OF oPanel  Pixel
			@ 006 , 080		Say aTit[2] + M->&(cCampo + "_LOJA")										FONT oDlg1:oFont OF oPanel  Pixel
			@ 006 , 130 	Say aTit[3] + M->&(cCampo + "_PREFIXO")										FONT oDlg1:oFont OF oPanel  Pixel
			@ 006 , 180		Say aTit[4] + M->&(cCampo + "_NUM")											FONT oDlg1:oFont OF oPanel  Pixel
			@ 006 , 250		Say aTit[5] + M->&(cCampo + "_PARCELA")										FONT oDlg1:oFont OF oPanel  Pixel
			@ 006 , 310 	Say STR0013 + cNatur														FONT oDlg1:oFont OF oPanel  Pixel		//"Natureza "  
		Elseif iif(cPaisLoc <> "BRA",!lRutina,.T.) //Rateio MultiNat por Centro de Custo na Baixa de titulos ou alteracao de titulo.
			@ 006 , 010		Say aTit[1] + (aTit[7])->&(cCampo + If(aTit[7] == "SE1", "_CLIENTE","_FORNECE"))	FONT oDlg1:oFont OF oPanel  Pixel
			@ 006 , 080		Say aTit[2] + (aTit[7])->&(cCampo + "_LOJA")   										FONT oDlg1:oFont OF oPanel  Pixel
			@ 006 , 130  	Say aTit[3] + (aTit[7])->&(cCampo + "_PREFIXO")										FONT oDlg1:oFont OF oPanel  Pixel
			@ 006 , 180  	Say aTit[4] + (aTit[7])->&(cCampo + "_NUM")											FONT oDlg1:oFont OF oPanel  Pixel
			@ 006 , 250  	Say aTit[5] + (aTit[7])->&(cCampo + "_PARCELA")										FONT oDlg1:oFont OF oPanel  Pixel
			@ 006 , 310  	Say STR0013 + cNatur																FONT oDlg1:oFont OF oPanel  Pixel		//"Natureza "
		Endif

		oPanel2 := TPanel():New(0,0,'',oDlg1,, .T., .T.,, ,20,20,.T.,.T. )

		@ 002, 005 To  018,200 OF oPanel2 PIXEL
		@ 002, 202 To  018,398 OF oPanel2 PIXEL
		@ 006 , 010 Say STR0019 OF oPanel2 PIXEL FONT oDlg1:oFont	//"Valor a Ratear " 
		@ 006 , 055 Say nValNat Picture PesqPict("SEZ","EZ_VALOR",TamSx3("EZ_VALOR")[1]) FONT oDlg1:oFont	 OF oPanel2 PIXEL
		@ 006 , 207 Say STR0020 OF oPanel2 PIXEL FONT oDlg1:oFont		//"Valor Rateado  " 
		@ 006 , 252 Say oValRat VAR nValRat Picture PesqPict("SEZ","EZ_VALOR",TamSx3("EZ_VALOR")[1]) OF oPanel2 PIXEL
		//MsGetDados():New( nTop, nLeft, nBottom, nRight, nOpc, cLinhaOk, cTudoOk, cIniCpos, lDeleta, aAlter, nFreeze, lEmpty, nMax, cFieldOk, cSuperDel, uPar, cDelOk, oWnd, lUseFreeze, cTela )
		
		n := 1	// Inicializa para acesso ao novo aCols - Centro de Custos.
		oGetDB := MSGetDados():New(34,5,128,315,nOpc,"MnccLin","AllWaysTrue","",nOpc # 2,aAltera,,,999,,,,"MnccCalc")
		oGetDB:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

		// Caso a primeira linha do acols for deletada (anteriormente), restauro
		// a situação de deleção apos a montagem da Getdados
		If lDelFirst
			aCols[1][nNumCol+1] := .T.
		Endif

		IF lPanelFin
			ACTIVATE MSDIALOG oDlg1 ON INIT ( FaMyBar( oDlg1,; 
									{|| nOpcC := 1, If(MnccTOk() .And. If(lF050VCMC, lValF050C := ExecBlock("F050VCMC",.F.,.F.),.T.), oDlg1:End(),)},;
									{|| nOpcC := 2, If(MnccNok() .And. lConfirma .And. If(!lF050VCMC,oDlg1:End(),IIF(lValF050C := ExecBlock("F050VCMC",.F.,.F.),oDlg1:End(),.T.)),,)},;
									If(nOpc # 2 .And. CtbInUse(),;
									{ {'AUTOM',{|| (AdmRatExt(aHeader, aCols, { |x,y,z,w| CcCarrExt(x,y,@z,w) } ), MnccLin()) },STR0021,STR0008} }, {}) ), oPanel2:Align := CONTROL_ALIGN_BOTTOM ) CENTERED	//"Rateio"###"Escolha de Rateio Pre-Configurado"

		Else
			ACTIVATE MSDIALOG oDlg1 ON INIT EnchoiceBar( oDlg1,;
									{ || nOpcC := 1, If(MnccTOk() .And. If(lF050VCMC,lValF050C := ExecBlock("F050VCMC",.F.,.F.),.T.),oDlg1:End(),)},;
									{ || nOpcC := 2, If(MnccNok() .And. lConfirma .And. If(!lF050VCMC, oDlg1:End(), If(lValF050C := ExecBlock("F050VCMC",.F.,.F.),oDlg1:End(),.T.)),,)},,;
									If(nOpc # 2 .And. CtbInUse(),;
									{ {'AUTOM',{|| (AdmRatExt(aHeader, aCols, { |x,y,z,w| CcCarrExt(x,y,@z,w) } ), MnccLin()) },STR0021,STR0008} }, {}), oPanel2:Align := CONTROL_ALIGN_BOTTOM ) CENTERED	//"Rateio"###"Escolha de Rateio Pre-Configurado" 
		Endif

		If lValF050C
			Exit
		Else
			Loop
		EndIf

	EndDo
ElseIf lAuto
	aRatCC := {}
	nPosEv := 0
	For nX := 1 To Len (aRatEvEz)
		If nPosEv > 0
			Exit
		EndIf
		For nY:=1 to Len(aRatEvEz[nX])
			If aRatEvEz[nX][nY][1]=="EV_NATUREZ" .and. RTrim(aRatEvEz[nX][nY][2])==RTrim(cNatur)
				nPosEv:=nX
				Exit
			Endif
		Next nY
	Next nX
	For nX:=1 to Len (aRatEvEz[nPosEv])
		If aRatEvEz[nPosEv][nX][1]=="AUTRATEICC"
			aRatCC:=aRatEvEz[nPosEv][nX][2]
			Exit
		Endif
	Next nX

	nOpcC := 1

	Multiauto(@aCols,@aHeader,Iif(IsInCallStack("FINA040"),"SE1","SE2"),"SEZ")
	If !(AutoSEZ(aRatCC,@aCols,@aHeader))
		lRet:= .F.
	Endif
Endif

If lRet
//Restaura posicao e Aheader da GetDados que chamou essa funcao
	If (!IsInCallStack("FINI055").and.(nOpcC == 2 .or. (FunName() == "FINA040" .AND. nOpcC == 0)) .And.;
			If(cOrigem $ "FINA050|FINA750" .And. nOpcC == 2, .T., Iif(Type("lF040Auto") == "U" .And. cOrigem <> "FINA040", .F., !lF040Auto))) .and. !lMulNatCC	
		dbSelectArea("SEZTMP")
		dbSetOrder(1)
		RestArea(aSaveArea)
		aHeader	:= aClone(aHeadOld)
		aCols		:= aClone(aColsOld)
		n:= nOldPos
		If Len(aRegs) = 0
			M->EV_RATEICC := "2"
		Endif
		lRet := .F. //Volta p/ a tela de rateio multi naturezas
		lCloseTbl := .F.
	Else
		// Grava a natureza no arquivo temporario
		MnccGrv(aRegs)
		dbSelectArea("SEZTMP")
		dbSetOrder(1)
		RestArea(aSaveArea)
		aHeader	:= aClone(aHeadOld)
		aCols		:= aClone(aColsOld)
		n:= nOldPos
		M->EV_RATEICC := "1"

		If lAuto
			aCols[n][4]:="1"
		EndIf
		lCloseTbl := .F.
	EndIf
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MULTNAT

Distribui o valor do titulo em varias naturezas.
Arquivo original: FINXFUN.PRX 

@author Claudio D Souza
@since 26/05/2001
/*/
//-------------------------------------------------------------------
Function MultNat(	cAlias, nHdlPrv, nTotal, cArquivo, lContabiliza, nOpc, nImpostos,;
					lRatImpostos, aHeaderM, aColsM, aRegs, lGrava, lMostraTela, lRotAuto,;
					lUsaFlag, aFlagCTB	)

Static __lEnt05		:= .F.
Static __lEnt06		:= .F.
Static __lEnt07		:= .F.
Static __lEnt08		:= .F.
Static __lEnt09		:= .F.

LOCAL lResult		:=	.T.
LOCAL aCampos		:=	{	"EV_NATUREZ",;
							"EV_VALOR",;
							"EV_PERC",;
							"EV_RATEICC" }	// Indica quais campos serao
											// exbididos na GetDados
											// e na ordem que devem aparecer
LOCAL cCampo    	:= Right(cAlias,2)
LOCAL nX
LOCAL bTit      	:= { |cChave| SX3->(DbSeek(cChave)), X3Titulo() }
LOCAL oDlg
LOCAL oGet
LOCAL aArea  		:= GetArea()
LOCAL aArea1 		:= (cAlias)->(GetArea())
LOCAL cPic  		:= PesqPict("SE2","E2_VALOR",19)
LOCAL cPadrao 		:= If(cAlias=="SE1","500","510")
LOCAL lPadrao 		:= VerPadrao(cPadrao)
LOCAL cPadraoCC 	:= If(cAlias=="SE1","506","508")
LOCAL lPadraoCC 	:= VerPadrao(cPadraoCC), aButton := {}
LOCAL lCtbRatCC 	:= .F.  // Controle de contabilizacao por Rateio C.Custo
LOCAL lGrvSev		:= ExistBlock("MULTSEV")
LOCAL lGrvSez		:= ExistBlock("MULTSEZ"), lInclui
LOCAL cChaveIrf		:= 	If(cAlias = "SE2" .And. M->E2_IRRF > 0, SE2->E2_PREFIXO +;
	 					SE2->E2_NUM + SE2->E2_PARCIR +;
	 					Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA), "")
LOCAL cChaveIns		:= 	If(cAlias = "SE2" .And. M->E2_INSS > 0,;
						SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCINS +;
						Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"INA",MVINSS), "")
LOCAL cChaveIss		:= 	If(cAlias = "SE2" .And. M->E2_ISS > 0,;
						SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCISS + MVISS, "")
LOCAL nRecno		:= (cAlias)->(Recno())
LOCAL aRatIrf		:= {}, aRatIns := {}, aRatIss := {}
LOCAL nRatIrf1		:= nRatIns1 := nRatIss1 := nPos := 0
LOCAL nRatIrf2		:= nRatIns2 := nRatIss2 := nCont := nCont1 := nCont2 := nCont3 := 0
LOCAL nTotSev		:= nTotSez := nPerSev := nPerSez := 0
LOCAL cChave		:= 	If(lGrvSez .Or. lGrvSev,;
						(cAlias)->&(cCampo + "_PREFIXO") +;
						(cAlias)->&(cCampo + "_NUM") +;
						(cAlias)->&(cCampo + "_PARCELA") +;
						(cAlias)->&(cCampo + "_TIPO") +;
						(cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE")) +;
						(cAlias)->&(cCampo + "_LOJA"), "")
LOCAL nDiff			:= 0
LOCAL nPosDiff		:= 0
LOCAL cOrigem		:= If(cAlias=="SE1","FINA040","FINA050")
LOCAL lRtNattel 	:= Existblock("RTNATTEL")

LOCAL cChavePis		:= If(cAlias = "SE2" .And. M->E2_PIS > 0, SE2->E2_PREFIXO +;
	 					SE2->E2_NUM + SE2->E2_PARCPIS +;
	 					Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA), "")

LOCAL cChaveCof		:=	If(cAlias = "SE2" .And. M->E2_COFINS > 0, SE2->E2_PREFIXO +;
	 					SE2->E2_NUM + SE2->E2_PARCCOF +;
	 					Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA), "")

LOCAL cChaveCsl		:=	If(cAlias = "SE2" .And. M->E2_CSLL > 0, SE2->E2_PREFIXO +;
	 					SE2->E2_NUM + SE2->E2_PARCSLL +;
	 					Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA), "")
	 					
LOCAL cChaveCid		:= 	If(cAlias = "SE2" .And. cPaisLoc == "BRA" .And. M->E2_CIDE > 0,;
						SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCCID + "CID", "")
						
LOCAL aRatPis		:= {}, aRatCof := {}, aRatCsl := {}, aRatCid := {}
LOCAL nRatPis1		:= nRatCof1 := nRatCsl1 := nRatCid1 := 0
LOCAL nRatPis2		:= nRatCof2 := nRatCsl2 := nRatCid2 := 0
LOCAL nCont4		:= nCont5 := nCont6 := nCont7 := 0
LOCAL nRecnoSx3		:= 0
LOCAL lPanelFin		:= IsPanelFin()
LOCAL lAtuSldNat	:= .T.
LOCAL cLojaImp		:= PadR( "00", TamSX3( "A2_LOJA" )[1], "0" )
LOCAL lRatF050		:= ExistBlock("RATF050")
LOCAL aRetRat		:= {}
Local aStructSEZ	:= {}
Local aStrucAux	    := {}
Local lIrf := lPis  := lCof := lCsl := lInss := lIss := lCid := .f.
Local cAgl10925     := SuperGetMv("MV_AG10925", .F., "1")
Local nVlrPisOld    := 0
Local lFina050Alt   := FwIsInCallStack("FA050AXALT") 
Local nRecSE2       := 0
Local lConsult      := IsInCallStack("Fa050Rateio")
Local lRatCCParcial	:= .F.
Local cChaveTit     := ""
Local cChaveFK7     := ""
Local lMulNat       := FwIsInCallStack("FA050ALTER") .And. M->E2_MULTNAT == "2"
Local _cMvUniao     := SuperGetMV("MV_UNIAO",.F.,"")  
LOCAL _cMvFInss     := SuperGetMv("MV_FORINSS",.F.,"") 
LOCAL _cMvMunic     := SuperGetMv("MV_MUNIC",.F.,"")
LOCAL _cMvFCide     := SuperGetMV("MV_FORCIDE",.F.,"")
LOCAL cCarteira		:= If(cAlias=="SE1", "R", "P")

PRIVATE oValDist
PRIVATE nValDist	:= 0
PRIVATE nVlTit
PRIVATE aTit		:= {}
PRIVATE nOpcA		:= 0
PRIVATE oValFal
PRIVATE oPerFal
PRIVATE nValFal		:= 0
PRIVATE nPerFal		:= 100

DEFAULT lUsaFlag 	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
DEFAULT aFlagCTB 	:= {}
DEFAULT nOpc	 	:= 3
DEFAULT nImpostos	:= 0
DEFAULT lRatImpostos:= .F.
DEFAULT lGrava		:= .T.
DEFAULT aColsM		:= {}
DEFAULT aHeaderM	:= {}
DEFAULT lMostraTela	:= .T.
DEFAULT aRegs		:= {}
DEFAULT lRotAuto  	:= .F.

If lMulNat
	Help(" ",1,"OPCMULTNAT",,STR0026 + ": " + SE2->E2_NUM,1,0)
	Return .F.
EndIf

If !lRotAuto
	PRIVATE aCols	:= {}
	PRIVATE aHeader	:= {}
EndIf

If ! Empty(cChaveIrf)
	cChaveIrf += _cMvUniao + Space(Len(SE2->E2_FORNECE) - Len(_cMvUniao)) + cLojaImp
Endif

If ! Empty(cChaveIns)
	cChaveIns += _cMvFInss + Space(Len(SE2->E2_FORNECE) - Len(_cMvFInss)) + cLojaImp
Endif

If ! Empty(cChaveIss)
	cChaveIss += _cMvMunic + Space(Len(SE2->E2_FORNECE) - Len(_cMvMunic)) + cLojaImp
Endif

If ! Empty(cChavePis)
	cChavePis += _cMvUniao + Space(Len(SE2->E2_FORNECE) - Len(_cMvUniao)) + cLojaImp
Endif

If ! Empty(cChaveCof)
	cChaveCof += _cMvUniao + Space(Len(SE2->E2_FORNECE) - Len(_cMvUniao)) + cLojaImp
Endif

If ! Empty(cChaveCsl)
	cChaveCsl += _cMvUniao + Space(Len(SE2->E2_FORNECE) - Len(_cMvUniao)) + cLojaImp
Endif

If ! Empty(cChaveCid)
	cChaveCid += _cMvFCide + Space(Len(SE2->E2_FORNECE) - Len(_cMvFCide)) + cLojaImp
Endif

//Converte os impostos para a moeda do título, para somar corretamente
If nImpostos > 0
	nImpostos := FMNCvMoed(cCampo, nImpostos)
EndIf

If nOpc # 3
	Aadd(aButton, {'S4WB013N',{||MulNatCC(nOpc) },STR0007,STR0007} ) //"Rateio Centro de Custo"###"Rateio"
	nVlTit	:= M->&(cCampo + "_VALOR") + nImpostos // Valor do titulo
Else
	nVlTit	:= (cAlias)->&(cCampo + "_VALOR") + nImpostos // Valor do titulo
Endif
nValFal 	:= M->&(cCampo + "_VALOR") + nImpostos // Valor do titulo

__OPC 	:= nOpc

//Obtm a picture do campo EV_PERC ajustado de indice para percentual
cPictPerc		:= FPictPerc()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Montagem da matriz aHeader e aCampos						 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

dbSelectArea("SX3")
dbSetOrder(2)

SEV->(dbSetOrder(4)) //EV_FILIAL+EV_PREFIXO+EV_NUM+EV_PARCELA+EV_TIPO+EV_CLIFOR+EV_LOJA+EV_RECPAG+EV_IDENT+EV_SEQ+EV_NATUREZ
If (nOpc # 3 .And. 	Len(aColsM) = 0 .and. ;
		SEV->(MsSeek(xFilial()+;
				(cAlias)->&(cCampo + "_PREFIXO")+;
		    	(cAlias)->&(cCampo + "_NUM")+;
	  	     	(cAlias)->&(cCampo + "_PARCELA")+;
				(cAlias)->&(cCampo + "_TIPO")+;
				(cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))+;
				(cAlias)->&(cCampo + "_LOJA")+;
				cCarteira +;
				"1")))		//1=Inclusao

	// Crio aHeader
	// Adiciona os campos na ordem em que devem aparecer
	For nX := 1 To Len(aCampos)
		SX3->(DbSetOrder(2))
		SX3->(MsSeek(Pad(aCampos[nX],10)))
		If Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim(SX3->X3_CAMPO) } )  == 0
			Aadd(aHeader,{ AllTrim(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT } )
		Endif
	Next
 	SX3->(dbSetOrder(1))
 	SX3->(dbSeek("SEV"))

	// Adiciono demais campos
	While ! SX3->(EOF()) .And. (SX3->X3_Arquivo == "SEV")
		If X3USO(SX3->X3_Usado) .And. cNivel >= SX3->X3_NIVEL .and. AllTrim(SX3->X3_CAMPO) != "EV_IDDOC"
			If Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim(SX3->X3_CAMPO) } )  == 0
				Aadd(aHeader,{ AllTrim(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT } )
			Endif
		Endif
		SX3->(DbSkip())
	EndDo

	SX3->(DbSeek("SEV_FILIAL"))
	cUsado := SX3->X3_USADO
	AADD( aHeader, { "Alias WT","EV_ALI_WT", "", 09, 0,, cUsado, "C", "SEV", "V"} )
	AADD( aHeader, { "Recno WT","EV_REC_WT", "", 09, 0,, cUsado, "N", "SEV", "V"} )

	While SEV->EV_FILIAL + SEV->EV_PREFIXO + SEV->EV_NUM +;
		  	SEV->EV_PARCELA + SEV->EV_TIPO + SEV->EV_CLIFOR +;
			SEV->EV_LOJA+SEV->EV_RECPAG+SEV->EV_IDENT == xFilial("SEV")+;
			(cAlias)->&(cCampo + "_PREFIXO")+;
			(cAlias)->&(cCampo + "_NUM")+;
		  	(cAlias)->&(cCampo + "_PARCELA")+;
			(cAlias)->&(cCampo + "_TIPO")+;
			(cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))+;
			(cAlias)->&(cCampo + "_LOJA")+;
			cCarteira +;
			"1"	//1 = Inclusao

		SX3->(DbSetOrder(2))
		Aadd(aCols,Array(Len(aHeader)))

		For nX := 1 To Len(aHeader)
			SX3->(MsSeek(Pad(aHeader[nX][2],10)))

			If Alltrim(SX3->X3_CAMPO) == "EV_PERC" // Percentual
				aHeader[nX][6] := "MNatCalcV()"
				// Inclui em aCols como caracter para ser possivel a visualizacao na
				// tela, por ser a ultima coluna da getdados
				aHeader[nX][8]	:= "N" 
				aHeader[nX][3]	:= cPictPerc
				aHeader[nX][5]	:= 2
				aCols[Len(aCols)][nX]	:=  CriaVar("EV_PERC")

			ElseIf Alltrim(SX3->X3_CAMPO) == "EV_VALOR"
				aCols[Len(aCols)][nX] := CriaVar("EV_VALOR")
				aHeader[nX][6] := "MNatCalcP()"
			ElseIf Alltrim(SX3->X3_CAMPO) == "EV_NATUREZ"
				aCols[Len(aCols)][nX] := CriaVar("EV_NATUREZ")
				aHeader[nX][6] := 'ExistCpo("SED") .And. MNatAltN() .and. FinVldNat( .T. )'
			ElseIf Alltrim(aHeader[nX][2]) == "EV_ALI_WT"
				aCols[Len(aCols)][nX] := "SEV"
			ElseIf Alltrim(aHeader[nX][2]) == "EV_REC_WT"
				aCols[Len(aCols)][nX] := SEV->(Recno())
			Else
				aCols[Len(aCols)][nX] := SEV->(FieldGet(FieldPos(aHeader[nX][2])))
			Endif
		Next

		aCols[Len(aCols)][1] := SEV->EV_NATUREZ
		aCols[Len(aCols)][2] := If(!lconsult,Round(NoRound(nVlTit * SEV->EV_PERC, 3), 2),SEV->EV_VALOR)
		aCols[Len(aCols)][3] := SEV->EV_PERC * 100
		aCols[Len(aCols)][4] := SEV->EV_RATEICC
		Aadd(aCols[Len(aCols)], .F.)

		nTotSev += aCols[Len(aCols)][2]
		nPerSev += SEV->EV_PERC * 100

		Aadd(aRegs, SEV->(Recno()))
		nValDist := nVlTit
		nValFal	:= 0
		nPerFal	:= 0

		SEV->(DbSkip())

	EndDo

	If(lRatF050)
		aRetRat := ExecBlock("RATF050", .F., .F., { aCols })
		If (Valtype(aRetRat) == "A")
			aCols := aClone(aRetRat)
		EndIF
	EndIf

	If !lConsult
		If nTotSev # nVlTit .Or. nPerSev # 100
			aCols[Len(aCols)][2] += nVlTit - nTotSev
			aCols[Len(aCols)][3] := aCols[Len(aCols)][3] + 100 - nPerSev	
		Endif
	Endif

	aCposDb := {}
	aadd(aCposDB,{"EZ_NATUREZ","C",10,0})
	aadd(aCposDB,{"EZ_CCUSTO","C",TamSx3("CTT_CUSTO")[1],0})
	aadd(aCposDB,{"EZ_CONTA","C",TamSx3("CT1_CONTA")[1],0})
	aadd(aCposDB,{"EZ_ITEMCTA","C",TamSx3("CTD_ITEM")[1],0})
	aadd(aCposDB,{"EZ_CLVL","C",TamSx3("CTH_CLVL")[1],0})
	aadd(aCposDB,{"EZ_VALOR","N",TamSx3("EZ_VALOR")[1],TamSx3("EZ_VALOR")[2]})
	aadd(aCposDB,{"EZ_PERC","N",TamSx3("EZ_PERC")[1],TamSx3("EZ_PERC")[2]})
	aadd(aCposDB,{"EZ_FLAG","L",1,0})
	aadd(aCposDB,{"EZ_RECNO","N",10,0})
	// Adiciona demais campos
	aStruSez := SEZ->(DbStruct())
	For nX := 1 To Len(aStruSez)
		If !(AllTrim(SX3->X3_CAMPO) $ "EZ_IDDOC|EZ_TIPO") .AND. Ascan(aCposDB, { |e| Alltrim(e[1]) == aStruSez[nX][1] } ) == 0
			Aadd(aCposDB,{aStruSez[nX][1],aStruSez[nX][2],aStruSez[nX][3],aStruSez[nX][4]})
		Endif
	Next

	If(_oFINXNAT2 <> NIL)
		nStatus := TCSQLEXEC("DELETE FROM "+__cFin2Name)
		
		If SELECT("SEZTMP") > 0 
			SEZTMP->(DBGOTO(1))
		Endif

		If nStatus < 0
			_oFINXNAT2:Delete()
			_oFINXNAT2 := NIL
			__cFin2Name := ""
		Endif
	EndIf

	If(_oFINXNAT2 == NIL)

		IIF(Select("SEZTMP") > 0, SEZTMP->(DbCloseArea()), Nil)

		//Cria o Objeto do FwTemporaryTable
		_oFINXNAT2 := FwTemporaryTable():New("SEZTMP")

		//Cria a estrutura do alias temporario
		_oFINXNAT2:SetFields(aCposDB)

		//Adiciona o indicie na tabela temporaria
		_oFINXNAT2:AddIndex("1",{"EZ_NATUREZ","EZ_CCUSTO"})

		//Criando a Tabela Temporaria
		_oFINXNAT2:Create()

		//Nome da tabela criada no BD
		__cFin2Name := _oFINXNAT2:GetRealName()
	Endif

	dbSetOrder(1)
	SEZ->(dbSetOrder(5))	//EZ_FILIAL, EZ_PREFIXO, EZ_NUM, EZ_PARCELA, EZ_TIPO, EZ_CLIFOR, EZ_LOJA, EZ_NATUREZ, EZ_RECPAG, EZ_IDENT, EZ_SEQ, EZ_CCUSTO
	SEZ->(MsSeek(xFilial("SEZ")+;
					(cAlias)->&(cCampo + "_PREFIXO")+;
					(cAlias)->&(cCampo + "_NUM")+;
					(cAlias)->&(cCampo + "_PARCELA")+;
					(cAlias)->&(cCampo + "_TIPO")+;
					(cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))+;
					(cAlias)->&(cCampo + "_LOJA")))

	While 	SEZ->EZ_FILIAL + SEZ->EZ_PREFIXO + SEZ->EZ_NUM +;
			SEZ->EZ_PARCELA + SEZ->EZ_TIPO + SEZ->EZ_CLIFOR +;
			SEZ->EZ_LOJA == xFilial("SEZ")+;
			(cAlias)->&(cCampo + "_PREFIXO")+;
			(cAlias)->&(cCampo + "_NUM")+;
			(cAlias)->&(cCampo + "_PARCELA")+;
			(cAlias)->&(cCampo + "_TIPO")+;
			(cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))+;
			(cAlias)->&(cCampo + "_LOJA")

		//Descarto rateios que nao sao de inclusao
		If SEZ->EZ_IDENT != "1" .or.  SEZ->EZ_RECPAG != cCarteira
			SEZ->(dbskip())
			Loop
		Endif

		RecLock("SEZTMP", .T.)
		nPos := Ascan(aCols, { |x| x[1] = SEZ->EZ_NATUREZ })
		SEZTMP->EZ_NATUREZ	:= SEZ->EZ_NATUREZ
		SEZTMP->EZ_CCUSTO	:= SEZ->EZ_CCUSTO
		SEZTMP->EZ_CONTA	:= SEZ->EZ_CONTA
		SEZTMP->EZ_ITEMCTA	:= SEZ->EZ_ITEMCTA
		SEZTMP->EZ_CLVL   	:= SEZ->EZ_CLVL
		SEZTMP->EZ_VALOR	:= Round(NoRound(SEZ->EZ_VALOR,3),2)
		SEZTMP->EZ_PERC		:= SEZ->EZ_PERC
		SEZTMP->EZ_RECNO	:= SEZ->(Recno())
		
		// Carregamento dos campos de novas entidades
		For nX:= 1 to Len(aCposDB)
			cCpoEC := aCposDB[nX][1]
			If "EZ_EC0" $ Alltrim(cCpoEC) 
				SEZTMP->(&cCpoEC) := SEZ->(&cCpoEC)	
			EndIf
		Next nX
					
		nTotSez += SEZTMP->EZ_VALOR
		nPerSez += SEZTMP->EZ_PERC
		MsUnLock()
		SEZ->(DbSkip())
	Enddo

ElseIf nOpc # 3
	aCols 	:= AClone(aColsM)
	aHeader := AClone(aHeaderM)
Endif

If (nOpc = 3 .Or. Len(aCols) = 0) .And. !lRotAuto
	dbSelectArea("SX3")
	dbSetOrder(1)
	dbSeek("SEV")
	nX := 1
	Do While SX3->(!EoF() .And. X3_ARQUIVO == "SEV")
		If X3USO(SX3->X3_Usado) .And. cNivel >= SX3->X3_NIVEL
			If nX == 1
				nRecnoSx3 := SX3->(Recno())
				
				// Adiciona mais um elemento em aCOLS, indicando se a linha esta ou nao deletada 
				Aadd(aCols,Array(Len(aCampos)))
				For nX := 1 To Len(aCampos)
					SX3->(dbSetOrder(2))
					SX3->(MsSeek(Pad(aCampos[nX],10)))
					Aadd(aHeader,{ AllTrim(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT } )
					If aHeader[nX][8] == "C"
						aCols[1][nX] := CriaVar(aHeader[nX][2])
					Else
						If Alltrim(aHeader[nX][2]) == "EV_PERC" // Percentual
							aHeader[nX][6] := "MNatCalcV()"
							// Inclui em aCols como caracter para ser possivel a visualizacao na
							// tela, por ser a ultima coluna da getdados
							aHeader[nX][8] := "N"
							aHeader[nX][3]	:= cPictPerc
							aHeader[nX][5] := 2							
							aCols[1][nX] := CriaVar("EV_PERC")
						ElseIf Alltrim(aHeader[nX][2]) == "EV_VALOR"
							aCols[1][nX] := CriaVar("EV_VALOR")
							aHeader[nX][6] := "MNatCalcP()"
						Else
							aCols[1][nX] := CriaVar(aHeader[nX][2])
						Endif
					EndIf
				Next
				SX3->(DbSetOrder(1))
				SX3->(DbGoto(nRecnoSx3))
				// Adiciona os demais campos
				If Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim(SX3->X3_CAMPO) } )  == 0 .AND. AllTrim(SX3->X3_CAMPO) != "EV_IDDOC"  
					Aadd(aHeader,{ AllTrim(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT } )
					Aadd(aCols[1], CriaVar(SX3->X3_CAMPO))
				Endif
			Else
				// Adiciona os demais campos
				If Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim(SX3->X3_CAMPO) } )  == 0 .AND. AllTrim(SX3->X3_CAMPO) != "EV_IDDOC"
					Aadd(aHeader,{ AllTrim(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT } )
					Aadd(aCols[1], CriaVar(SX3->X3_CAMPO))
				Endif
			Endif
		EndIf
		SX3->(dbSkip())
    EndDo
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Adiciona mais um elemento em aCOLS, indicando se a   ³
	//³ a linha esta ou nao deletada						 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Aadd(aCols[1], .F.)
Endif

IF lRtNattel
	Execblock("RTNATTEL",.f.,.f.)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Mostra o corpo da rateio 									 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nOpca := 0
dbSelectArea("SX3")
dbSetOrder(2)
// Cria os titulos do dialogo
Aadd( aTit, Eval(bTit, cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE")))
Aadd( aTit, Eval(bTit, cCampo + "_LOJA"))
Aadd( aTit, Eval(bTit, cCampo + "_PREFIXO"))
Aadd( aTit, Eval(bTit, cCampo + "_NUM"))
Aadd( aTit, Eval(bTit, cCampo + "_PARCELA"))
Aadd( aTit, Eval(bTit, cCampo + "_VALOR" ))
Aadd( aTit, cAlias)

If lMostraTela	.And. !lRotAuto
	aSize := MSADVSIZE()
	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0010) From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL //"Naturezas por Titulos"
	oDlg:lMaximized := .T.
	oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20,.T.,.T. )
	oPanel:Align := CONTROL_ALIGN_TOP

	@  001, 005 To  018,247 OF oPanel PIXEL
	@  001, 250 To  018,495 OF oPanel PIXEL

	@  005 , 010	Say aTit[1] + (cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))	FONT oDlg:oFont OF oPanel Pixel
	@  005 , 100	Say aTit[2] + (cAlias)->&(cCampo + "_LOJA")    	FONT oDlg:oFont	OF oPanel  Pixel
	@  005 , 257	Say aTit[3] + (cAlias)->&(cCampo + "_PREFIXO") 	FONT oDlg:oFont	OF oPanel  Pixel
	@  005 , 297	Say aTit[4] + (cAlias)->&(cCampo + "_NUM")	 		FONT oDlg:oFont	OF oPanel  Pixel
	@  005 , 367	Say aTit[5] + (cAlias)->&(cCampo + "_PARCELA") 	FONT oDlg:oFont	OF oPanel  Pixel

	oPanel2 := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,40,40,.T.,.T. )

	If !lPanelFin
		oPanel2:Align := CONTROL_ALIGN_BOTTOM
	Endif
	If lConsult
		nValDist := nTotSev
		nVlTit := nTotSev
	Endif

	@ 001, 005 To 035,247 OF oPanel2 PIXEL
	@ 001, 250 To 035,495 OF oPanel2 PIXEL

	@ 005, 010  Say aTit[6] FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10
	@ 005, 076  Say nVlTit	PICTURE cPic FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10

	@ 005, 257  Say STR0011	FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10 //"Valor a Distribuir"
	@ 005, 357  Say oValFal VAR nValFal PICTURE cPic	FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10

	@ 018, 010  Say OemToAnsi(STR0006) FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10  //"Total Distribuido"
	@ 018, 076  Say oValDist VAR nValDist PICTURE cPic	FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10

	@ 018, 257  Say STR0012	FONT oDlg:oFont OF oPanel2 PIXEL SIZE 90,10  //"Percentual a Distribuir"
	@ 018, 357  Say oPerFal VAR nPerFal PICTURE cPictPerc SIZE 50,10 FONT oDlg:oFont OF oPanel2 PIXEL //"@E 999.9999999"

	oGet := MSGetDados():New(34,5,128,315,nOpc,"MNatLinOk", "AllwaysTrue",,nOpc # 2,,,,999)
	oGet:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

	If lPanelFin
		ACTIVATE MSDIALOG oDlg ON INIT (FaMyBar(oDlg,{||nOpca:=1,If(oGet:TudoOk() .And. FaMNatOk(),;
				oDlg:End(),nOpca := 0)},{||nOpca:=0,oDlg:End()},aButton),	oPanel2:Align := CONTROL_ALIGN_BOTTOM )

	Else
		ACTIVATE 	MSDIALOG oDlg ON INIT EnchoiceBar (oDlg,{||nOpca:=1,If(oGet:TudoOk() .And. FaMNatOk(),;
				oDlg:End(),nOpca := 0)},{||nOpca:=0,oDlg:End()},,aButton)
	Endif
Else
	nOpcA := 1
Endif

If nOpca == 1 .And. lGrava .And. nOpc # 2
	DbSelectArea(cAlias)
	SE2->(DbSetOrder(1))

	//IRRF
	If ! Empty(cChaveIrf) .And. SE2->(DbSeek(xFilial() + cChaveIrf))
		Reclock(cAlias)
		Replace (cAlias)->&(cCampo + "_MULTNAT") With If(lRatImpostos, "1", "2")
		MsUnlock()

      If lRatImpostos
			// Armazeno o valor do rateio para os impostos ja arredondado no ultimo

			nDiff := nPosDiff := 0
			For nX := 1 To Len(aCols)
			   // Se a linha de aCols nao estiver deletada e o registro nao for
				// encontrado no SEV
				If ValType(aCols[nX][3]) == "C"
					aCols[nX][3]	:= Val(StrTran(aCols[nX][3], ",","."))
				EndIf

				If !aCols[nX][Len(aCols[nX])]
					Aadd(aRatIrf, { M->E2_IRRF * (aCols[nX][3] / 100), {} })	// Grava o valor informado
					nRatIrf1 += aRatIrf[Len(aRatIrf)][1]
		        	nCont := 0

					If Select("SEZTMP") > 0 .And. aCols[nX][4] == "1"

						dbSelectArea("SEZTMP")
						// busca natureza no arquivo TMP de Mult Nat C.Custo
						If dbSeek(aCols[nX][1])
							While !Eof() .and. SEZTMP->EZ_NATUREZ == aCols[nX][1]
								Aadd(aRatIrf[Len(aRatIrf)][2], Round(NoRound((M->E2_IRRF * (aCols[nX][3] / 100)) * SEZTMP->EZ_PERC, 2), 3)) // Grava o valor informado
								nCont ++
								nRatIrf2 += aRatIrf[Len(aRatIrf)][2][nCont]
								DbSkip()
							EndDo
							nDiff 		:= nCont
							nPosDiff    := Len(aRatIrf)
						Endif
					Else
						//Verifico se todas as naturezas foram rateadas por centro de custo.
						//Caso uma delas n?o tenha sido rateada por centro de custos, n?o vou apurar diferena de impostos nos rateios multinatureza por centro de custos
						lRatCCParcial := .T.
					Endif
				Endif
			Next

			If Len(aRatIrf) > 0 .And. nRatIrf1 <> M->E2_IRRF
				If nRatIrf1 > M->E2_IRRF
					aRatIrf[Len(aRatIrf)][1] -= nRatIrf1 - M->E2_IRRF
				Else
					aRatIrf[Len(aRatIrf)][1] += M->E2_IRRF - nRatIrf1
				Endif
			Endif

			If !lRatCCParcial .and. nDiff > 0 .And. Len(aRatIrf) > 0 .And. nRatIrf2 <> M->E2_IRRF .And. nRatIrf2 > 0
				If nRatIrf2 > M->E2_IRRF
					aRatIrf[nPosDiff][2][nDiff] -= nRatIrf2 - M->E2_IRRF
				Else
					aRatIrf[nPosDiff][2][nDiff] += M->E2_IRRF - nRatIrf2
				Endif
			Endif
		Endif
	Endif

	//Pis
	If ! Empty(cChavePis) .And. SE2->(DbSeek(xFilial() + cChavePis))
		Reclock(cAlias)
		Replace (cAlias)->&(cCampo + "_MULTNAT") With If(lRatImpostos, "1", "2")
		MsUnlock()

		If lRatImpostos

			// Armazeno o valor do rateio para os impostos ja arredondado no ultimo
			If cAgl10925 == "1" .And. lFina050Alt
				nRecSE2 := SE2->(Recno())
				//Cofins
				If !Empty(cChaveCof) .And. !SE2->(DbSeek(xFilial() + cChaveCof)) .And. M->E2_COFINS > 0
					nVlrPisOld := M->E2_PIS 
					M->E2_PIS += M->E2_COFINS	
				EndIf
				//Csll
				If !Empty(cChaveCsl) .And. !SE2->(DbSeek(xFilial() + cChaveCsl)) .And. M->E2_CSLL > 0
					nVlrPisOld := M->E2_PIS  
					M->E2_PIS += M->E2_CSLL
				EndIf 
				SE2->(dbGoto(nRecSE2))				
			EndIf
			
			nDiff := nPosDiff := 0
			For nX := 1 To Len(aCols)
			   // Se a linha de aCols nao estiver deletada e o registro nao for
				// encontrado no SEV
				If !aCols[nX][Len(aCols[nX])]
					Aadd(aRatPis, { M->E2_PIS * (aCols[nX][3] / 100), {} })	// Grava o valor informado
					nRatPis1 += aRatPis[Len(aRatPis)][1]
		        	nCont := 0

					If Select("SEZTMP") > 0 .And. aCols[nX][4] == "1"

						dbSelectArea("SEZTMP")
						// busca natureza no arquivo TMP de Mult Nat C.Custo
						If dbSeek(aCols[nX][1])
							While !Eof() .and. SEZTMP->EZ_NATUREZ == aCols[nX][1]
								Aadd(aRatPis[Len(aRatPis)][2], Round(NoRound((M->E2_PIS * (aCols[nX][3] / 100)) * SEZTMP->EZ_PERC, 2), 3)) // Grava o valor informado
								nCont ++
								nRatPis2 += aRatPis[Len(aRatPis)][2][nCont]
								DbSkip()
							EndDo
							nDiff 		:= nCont
							nPosDiff    := Len(aRatPis)
						Endif
					Else
						//Verifico se todas as naturezas foram rateadas por centro de custo.
						//Caso uma delas n?o tenha sido rateada por centro de custos, n?o vou apurar diferena de impostos nos rateios multinatureza por centro de custos
						lRatCCParcial := .T.
					Endif
				Endif
			Next

			If Len(aRatPis) > 0 .And. nRatPis1 <> M->E2_PIS
				If nRatPis1 > M->E2_PIS
					aRatPis[Len(aRatPis)][1] -= nRatPis1 - M->E2_PIS
				Else
					aRatPis[Len(aRatPis)][1] += M->E2_PIS - nRatPis1
				Endif
			Endif

			If !lRatCCParcial .and. nDiff > 0 .And. Len(aRatPis) > 0 .And. nRatPis2 <> M->E2_PIS .And. nRatPis2 > 0
				If nRatPis2 > M->E2_PIS
					aRatPis[nPosDiff][2][nDiff] -= nRatPis2 - M->E2_PIS
				Else
					aRatPis[nPosDiff][2][nDiff] += M->E2_PIS - nRatPis2
				Endif
			Endif
			//restaura o vlr ind.. do pis
			If nVlrPisOld > 0 
				M->E2_PIS := nVlrPisOld
			EndIf
		Endif
	Endif


	//COFINS
	If ! Empty(cChaveCof) .And. SE2->(DbSeek(xFilial() + cChaveCof))
		Reclock(cAlias)
		Replace (cAlias)->&(cCampo + "_MULTNAT") With If(lRatImpostos, "1", "2")
		MsUnlock()

      If lRatImpostos
			// Armazeno o valor do rateio para os impostos ja arredondado no ultimo

			nDiff := nPosDiff := 0
			For nX := 1 To Len(aCols)
			   // Se a linha de aCols nao estiver deletada e o registro nao for
				// encontrado no SEV
				If !aCols[nX][Len(aCols[nX])]
					Aadd(aRatCof, { M->E2_COFINS * (aCols[nX][3] / 100), {} })	// Grava o valor informado
					nRatCof1 += aRatCof[Len(aRatCof)][1]
		        	nCont := 0

					If Select("SEZTMP") > 0 .And. aCols[nX][4] == "1"

						dbSelectArea("SEZTMP")
						// busca natureza no arquivo TMP de Mult Nat C.Custo
						If dbSeek(aCols[nX][1])
							While !Eof() .and. SEZTMP->EZ_NATUREZ == aCols[nX][1]
								Aadd(aRatCof[Len(aRatCof)][2], Round(NoRound((M->E2_COFINS * (aCols[nX][3] / 100)) * SEZTMP->EZ_PERC, 2), 3)) // Grava o valor informado
								nCont ++
								nRatCof2 += aRatCof[Len(aRatCof)][2][nCont]
								DbSkip()
							EndDo
							nDiff 		:= nCont
							nPosDiff    := Len(aRatCof)
						Endif
					Else
						//Verifico se todas as naturezas foram rateadas por centro de custo.
						//Caso uma delas n?o tenha sido rateada por centro de custos, n?o vou apurar diferena de impostos nos rateios multinatureza por centro de custos
						lRatCCParcial := .T.
					Endif
				Endif
			Next

			If Len(aRatCof) > 0 .And. nRatCof1 <> M->E2_COFINS
				If nRatCof1 > M->E2_COFINS
					aRatCof[Len(aRatCof)][1] -= nRatCof1 - M->E2_COFINS
				Else
					aRatCof[Len(aRatCof)][1] += M->E2_COFINS - nRatCof1
				Endif
			Endif

			If !lRatCCParcial .and. nDiff > 0 .And. Len(aRatCof) > 0 .And. nRatCof2 <> M->E2_COFINS .And. nRatCof2 > 0
				If nRatCof2 > M->E2_COFINS
					aRatCof[nPosDiff][2][nDiff] -= nRatCof2 - M->E2_COFINS
				Else
					aRatCof[nPosDiff][2][nDiff] += M->E2_COFINS - nRatCof2
				Endif
			Endif
		Endif
	Endif


	//Csll
	If ! Empty(cChaveCsl) .And. SE2->(DbSeek(xFilial() + cChaveCsl))
		Reclock(cAlias)
		Replace (cAlias)->&(cCampo + "_MULTNAT") With If(lRatImpostos, "1", "2")
		MsUnlock()

      If lRatImpostos
			// Armazeno o valor do rateio para os impostos ja arredondado no ultimo

			nDiff := nPosDiff := 0
			For nX := 1 To Len(aCols)
			   // Se a linha de aCols nao estiver deletada e o registro nao for
				// encontrado no SEV
				If !aCols[nX][Len(aCols[nX])]
					Aadd(aRatCsl, { M->E2_CSLL * (aCols[nX][3] / 100), {} })	// Grava o valor informado
					nRatCsl1 += aRatCsl[Len(aRatCsl)][1]
		        	nCont := 0

					If Select("SEZTMP") > 0 .And. aCols[nX][4] == "1"

						dbSelectArea("SEZTMP")
						// busca natureza no arquivo TMP de Mult Nat C.Custo
						If dbSeek(aCols[nX][1])
							While !Eof() .and. SEZTMP->EZ_NATUREZ == aCols[nX][1]
								Aadd(aRatCsl[Len(aRatCsl)][2], Round(NoRound((M->E2_CSLL * (aCols[nX][3] / 100)) * SEZTMP->EZ_PERC, 2), 3)) // Grava o valor informado
								nCont ++
								nRatCsl2 += aRatCsl[Len(aRatCsl)][2][nCont]
								DbSkip()
							EndDo
							nDiff 		:= nCont
							nPosDiff    := Len(aRatCsl)
						Endif
					Else
						//Verifico se todas as naturezas foram rateadas por centro de custo.
						//Caso uma delas n?o tenha sido rateada por centro de custos, n?o vou apurar diferena de impostos nos rateios multinatureza por centro de custos
						lRatCCParcial := .T.
					Endif
				Endif
			Next

			If Len(aRatCsl) > 0 .And. nRatCsl1 <> M->E2_CSLL
				If nRatCsl1 > M->E2_CSLL
					aRatCsl[Len(aRatCsl)][1] -= nRatCsl1 - M->E2_CSLL
				Else
					aRatCsl[Len(aRatCsl)][1] += M->E2_CSLL - nRatCsl1
				Endif
			Endif

			If !lRatCCParcial .and. nDiff > 0 .And. Len(aRatCsl) > 0 .And. nRatCsl2 <> M->E2_CSLL .And. nRatCSL2 > 0
				If nRatCsl2 > M->E2_CSLL
					aRatCsl[nPosDiff][2][nDiff] -= nRatCsl2 - M->E2_CSLL
				Else
					aRatCsl[nPosDiff][2][nDiff] += M->E2_CSLL - nRatCsl2
				Endif
			Endif
		Endif  
	Endif

	If ! Empty(cChaveIns) .And. SE2->(DbSeek(xFilial() + cChaveIns))
		// Armazeno o valor do rateio para os impostos ja arredondado no ultimo
		Reclock(cAlias)
		Replace (cAlias)->&(cCampo + "_MULTNAT") With If(lRatImpostos, "1", "2")
		MsUnlock()

      If lRatImpostos
			nDiff := nPosDiff := 0
			For nX := 1 To Len(aCols)
			   // Se a linha de aCols nao estiver deletada e o registro nao for
				// encontrado no SEV
				If 	!aCols[nX][Len(aCols[nX])]
					Aadd(aRatIns, { M->E2_INSS * (aCols[nX][3] / 100), {} })	// Grava o valor informado
					nRatIns1 += aRatIns[Len(aRatIns)][1]

					If Select("SEZTMP") > 0 .And. aCols[nX][4] == "1"

						dbSelectArea("SEZTMP")

			        	nCont := 0
						// busca natureza no arquivo TMP de Mult Nat C.Custo
						If dbSeek(aCols[nX][1])
							While !Eof() .and. SEZTMP->EZ_NATUREZ == aCols[nX][1]
								Aadd(aRatIns[Len(aRatIns)][2], Round(NoRound((M->E2_INSS * (aCols[nX][3] / 100)) * SEZTMP->EZ_PERC, 3), 2)) // Grava o valor informado
								nCont ++
								nRatIns2 += aRatIns[Len(aRatIns)][2][nCont]
								DbSkip()
							EndDo
							nDiff 		:= nCont
							nPosDiff    := Len(aRatIns)
						Endif
					Else
						//Verifico se todas as naturezas foram rateadas por centro de custo.
						//Caso uma delas n?o tenha sido rateada por centro de custos, n?o vou apurar diferena de impostos nos rateios multinatureza por centro de custos
						lRatCCParcial := .T.
					Endif
				Endif
			Next

			If Len(aRatIns) > 0 .And. nRatIns1 <> M->E2_INSS
				If nRatIns1 > M->E2_INSS
					aRatIns[Len(aRatIns)][1] -= nRatIns1 - M->E2_INSS
				Else
					aRatIns[Len(aRatIns)][1] += M->E2_INSS - nRatIns1
				Endif
			Endif

			If !lRatCCParcial .and. nDiff > 0 .And. Len(aRatIns) > 0 .And. nRatIns2 <> M->E2_INSS .And. nRatIns2 > 0
				If nRatIns2 > M->E2_INSS
					aRatIns[nPosDiff][2][nDiff] -= nRatIns2 - M->E2_INSS
				Else
					aRatIns[nPosDiff][2][nDiff] += M->E2_INSS - nRatIns2
				Endif
			Endif
		Endif
	Endif

	If ! Empty(cChaveIss) .And. SE2->(DbSeek(xFilial() + cChaveIss))
		// Armazeno o valor do rateio para os impostos ja arredondado no ultimo

		Reclock(cAlias)
		Replace (cAlias)->&(cCampo + "_MULTNAT") With If(lRatImpostos, "1", "2")
		MsUnlock()

      If lRatImpostos
			nDiff := nPosDiff := 0
			For nX := 1 To Len(aCols)
			   // Se a linha de aCols nao estiver deletada e o registro nao for
				// encontrado no SEV
				If 	!aCols[nX][Len(aCols[nX])]
					Aadd(aRatIss, { M->E2_ISS * (aCols[nX][3] / 100), {} })	// Grava o valor informado
					nRatIss1 += aRatIss[Len(aRatIss)][1]

					If 	Select("SEZTMP") > 0 .And. aCols[nX][4] == "1"

						dbSelectArea("SEZTMP")
			        	nCont := 0
						// busca natureza no arquivo TMP de Mult Nat C.Custo
						If dbSeek(aCols[nX][1])
							While !Eof() .and. SEZTMP->EZ_NATUREZ == aCols[nX][1]
								Aadd(aRatIss[Len(aRatIss)][2], Round(NoRound((M->E2_ISS * (aCols[nX][3] / 100)) * SEZTMP->EZ_PERC, 3), 2)) // Grava o valor informado
								nCont ++
								nRatIss2 += aRatIss[Len(aRatIss)][2][nCont]
								DbSkip()
							EndDo
							nDiff 		:= nCont
							nPosDiff    := Len(aRatIss)
						Endif
					Else
						//Verifico se todas as naturezas foram rateadas por centro de custo.
						//Caso uma delas n?o tenha sido rateada por centro de custos, n?o vou apurar diferena de impostos nos rateios multinatureza por centro de custos
						lRatCCParcial := .T.
					Endif
				Endif
			Next

			If Len(aRatIss) > 0 .And. nRatIss1 <> M->E2_ISS
				If nRatIss1 > M->E2_ISS
					aRatIss[Len(aRatIss)][1] -= nRatIss1 - M->E2_ISS
				Else
					aRatIss[Len(aRatIss)][1] += M->E2_ISS - nRatIss1
				Endif
			Endif

			If !lRatCCParcial .and. nDiff > 0 .And. Len(aRatIss) > 0 .And. nRatIss2 <> M->E2_ISS .And. nRatIss2 > 0
				If nRatIss2 > M->E2_ISS
					aRatIss[nPosDiff][2][nDiff] -= nRatIss2 - M->E2_ISS
				Else
					aRatIss[nPosDiff][2][nDiff] += M->E2_ISS - nRatIss2
				Endif
			Endif
		Endif
	Endif

	//Cide
	If ! Empty(cChaveCid) .And. SE2->(DbSeek(xFilial() + cChaveCid))
		// Armazeno o valor do rateio para os impostos ja arredondado no ultimo

		Reclock(cAlias)
		Replace (cAlias)->&(cCampo + "_MULTNAT") With If(lRatImpostos, "1", "2")
		MsUnlock()

      If lRatImpostos
			nDiff := nPosDiff := 0
			For nX := 1 To Len(aCols)
			   // Se a linha de aCols nao estiver deletada e o registro nao for
				// encontrado no SEV
				If 	!aCols[nX][Len(aCols[nX])]
					Aadd(aRatCid, { M->E2_CIDE * (aCols[nX][3] / 100), {} })	// Grava o valor informado
					nRatCid1 += aRatCid[Len(aRatCid)][1]

					If 	Select("SEZTMP") > 0 .And. aCols[nX][4] == "1"

						dbSelectArea("SEZTMP")
			        	nCont := 0
						// busca natureza no arquivo TMP de Mult Nat C.Custo
						If dbSeek(aCols[nX][1])
							While !Eof() .and. SEZTMP->EZ_NATUREZ == aCols[nX][1]
								Aadd(aRatCid[Len(aRatCid)][2], Round(NoRound((M->E2_CIDE * (aCols[nX][3] / 100)) * SEZTMP->EZ_PERC, 3), 2)) // Grava o valor informado
								nCont ++
								nRatCid2 += aRatCid[Len(aRatCid)][2][nCont]
								DbSkip()
							EndDo
							nDiff 		:= nCont
							nPosDiff    := Len(aRatCid)
						Endif
					Else
						//Verifico se todas as naturezas foram rateadas por centro de custo.
						//Caso uma delas n?o tenha sido rateada por centro de custos, n?o vou apurar diferena de impostos nos rateios multinatureza por centro de custos
						lRatCCParcial := .T.
					Endif
				Endif
			Next

			If Len(aRatCid) > 0 .And. nRatCid1 <> M->E2_CIDE
				If nRatCid1 > M->E2_CIDE
					aRatCid[Len(aRatCid)][1] -= nRatCid1 - M->E2_CIDE
				Else
					aRatCid[Len(aRatCid)][1] += M->E2_CIDE - nRatCid1
				Endif
			Endif

			If !lRatCCParcial .and. nDiff > 0 .And. Len(aRatCid) > 0 .And. nRatCid2 <> M->E2_CIDE .And. nRatCid2 > 0
				If nRatCid2 > M->E2_CIDE
					aRatCid[nPosDiff][2][nDiff] -= nRatCid2 - M->E2_CIDE
				Else
					aRatCid[nPosDiff][2][nDiff] += M->E2_CIDE - nRatCid2
				Endif
			Endif
		Endif
	Endif
	
	(cAlias)->(DbGoto(nRecno))
	If nOpc = 4
		// Apaga as naturezas geradas para o titulo
		DelMultNat( cAlias, @nHdlPrv, @nTotal, @cArquivo, .T. /*lSoContabiliza*/, aCols, lUsaFlag, @aFlagCTB )
	Endif

	// Grava todas as naturezas e valores informados
	DbSelectArea("SEV")
	// Marca que ja foi contabilizado para nao contabilizar duas vezes, pois eh utilizado
	// o mesmo lancamento padrao

	If Len(aCols) > 1 .And. lContabiliza .and. !lUsaFlag
		Reclock(cAlias)
		Replace (cAlias)->&(cCampo + "_LA") With "S"
		MsUnlock()
		DbSelectArea("SEV")
	Endif

	nCont := 0

	If Select("SEZTMP") > 0
		//Salva a estrutura da tabela temporaria em um array auxiliar
		aStrucAux := SEZTMP->(dbStruct())
		For nX := 1 To Len(aStrucAux)
			If !( aStrucAux[ nX ][ 1 ] $ '|EZ_FILIAL|EZ_PREFIXO|EZ_NUM|EZ_PARCELA|EZ_CLIFOR|EZ_LOJA|EZ_TIPO|EZ_NATUREZ|'+;
											'EZ_VALOR|EZ_PERC|EZ_RECPAG|EZ_CCUSTO|EZ_ITEMCTA|EZ_CLVL|EZ_IDENT|EZ_CONTA|'+;
											'EZ_EC05DB|EZ_EC05CR|EZ_EC06DB|EZ_EC06CR|EZ_EC07DB|EZ_EC07CR|EZ_EC08DB|'+;
											'EZ_EC08CR|EZ_EC09DB|EZ_EC09CR|EZ_LA|EZ_SEQ|EZ_SITUACA|' ) .And.;
				SEZ->( FieldPos( aStrucAux[ nX ][ 1 ] ) ) > 0										
			    //O que nao faz parte do padrao e adicionado  
				aAdd( aStructSEZ , aStrucAux[ nX ][ 1 ] )
			EndIf
		Next nX
	EndIf
	
		//Gravação da chave FK7 para os rateios
	If cAlias=="SE1"	
		cChaveTit := xFilial("SE1",SE1->E1_FILORIG) + "|" +;
					SE1->E1_PREFIXO	+ "|" +;
					SE1->E1_NUM		+ "|" +;
					SE1->E1_PARCELA	+ "|" +;
					SE1->E1_TIPO		+ "|" +;
					SE1->E1_CLIENTE	+ "|" +;
					SE1->E1_LOJA
		cChaveFK7 := FINGRVFK7("SE1",cChaveTit)
	Else
		cChaveTit := xFilial("SE2",SE2->E2_FILORIG) + "|" +;
					SE2->E2_PREFIXO	+ "|" +;
					SE2->E2_NUM		+ "|" +;
					SE2->E2_PARCELA	+ "|" +;
					SE2->E2_TIPO		+ "|" +;
					SE2->E2_FORNECE	+ "|" +;
					SE2->E2_LOJA
		cChaveFK7 := FINGRVFK7("SE2",cChaveTit)
	Endif

	For nX := 1 To Len(aCols)
	   // Se a linha de aCols nao estiver deletada e o registro nao for
		// encontrado no SEV
		lCtbRatCC := .F.
		If	!aCols[nX][Len(aCols[nX])]
			If lGrvSev
				ExecBlock("MULTSEV", .F., .F., { 	nX, cChave, aCols[nX][2],;
													(aCols[nX][2] / nVlTit),;
													aCols[nX][1]  })
				DbSelectArea("SEV")
			Endif
			If Len(aRegs) >= nX
				DbGoTo(aRegs[nX])
				RecLock("SEV", .F. )
				lInclui := .F.
			Else
				RecLock("SEV", .T. )
				lInclui := .T.
			Endif

			// Grava todos os campos da tela
			aEval(aHeader, {|e,ni| If(e[8] <> "M" .And. e[10] <> "V" .And. Alltrim(e[2]) != "EV_PERC", FieldPut(FieldPos(e[2]),aCols[nX][ni]),Nil) } )

			SEV->EV_FILIAL   := xFilial("SEV")
			SEV->EV_PREFIXO  := (cAlias)->&(cCampo + "_PREFIXO")
			SEV->EV_NUM      := (cAlias)->&(cCampo + "_NUM")
			SEV->EV_PARCELA  := (cAlias)->&(cCampo + "_PARCELA")
			SEV->EV_CLIFOR   := (cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))
			SEV->EV_LOJA     := (cAlias)->&(cCampo + "_LOJA")
			SEV->EV_TIPO     := (cAlias)->&(cCampo + "_TIPO")
			SEV->EV_NATUREZ  := aCols[nX][1] // Grava a natureza
			SEV->EV_VALOR    := aCols[nX][2] // Grava o valor informado
			// Grava o percentual (Como indice multiplicador, por esta razao nao
			// multiplica por 100 na gravacao, apenas na exibicao)
			SEV->EV_PERC     := (aCols[nX][3] / 100)
			SEV->EV_RECPAG   := If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
			SEV->EV_RATEICC  := aCols[nX][4]  // Identificador de Rateio C Custo
			SEV->EV_IDENT	:= "1"   //rateio de inclusao
			SEV->EV_IDDOC    := cChaveFK7	
			MsUnLock()
			FKCOMMIT()

			If lAtuSldNat
				AtuSldNat(SEV->EV_NATUREZ, (cAlias)->&(cCampo + "_VENCREA"), (cAlias)->&(cCampo + "_MOEDA"), "2", If(cAlias=="SE1","R","P"), SEV->EV_VALOR,SEV->EV_PERC * (cAlias)->&(cCampo + "_VLCRUZ"), "+",,FunName(),"SEV", SEV->(Recno()),nOpc)
			Endif

			If lInclui
				Aadd(aRegs, SEV->(Recno()))
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Gera o lancamento no PCO com os dados do lancamento de multi-natureza (05) ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (cAlias)->&(cCampo + "_MULTNAT") == "1"	// Campo multi-natureza igual a "Sim"
				If cAlias == "SE1"
					PCODetLan( "000001", "04", "FINA040" )	// Contas a Receber
				Else
					PCODetLan( "000002", "04", "FINA050" )	// Contas a Pagar
				EndIf
			EndIf

			SEZ->(dbSetOrder(4))
			If Select("SEZTMP") > 0 .And. aCols[nX][4] == "1" .and.;   // Possui rateio c.Custo
        		(nOpc # 3 .Or. !SEZ->(MsSeek(xFilial("SEZ")+;
				(cAlias)->&(cCampo + "_PREFIXO")+;
				(cAlias)->&(cCampo + "_NUM")+;
				(cAlias)->&(cCampo + "_PARCELA")+;
				(cAlias)->&(cCampo + "_TIPO")+;
				(cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))+;
				(cAlias)->&(cCampo + "_LOJA")+;
				aCols[nX][1]+"1")))

				//Gravacao dos dados do rateio C.custo
				dbSelectArea("SEZTMP")

				// busca natureza no arquivo TMP de Mult Nat C.Custo
				If dbSeek(aCols[nX][1])
					nCont := nX
					nCont1 := nCont2 := nCont3 := nCont4 := nCont5 := nCont6 := nCont7 := 0
					lIrf :=  If(len(aRatIrf) > 0, If(len(aRatIrf[nCont]) > 1, ValType(aRatIrf[nCont,2]) == "A", .f.), .f.)
					lPis :=  If(len(aRatPIS) > 0, If(len(aRatPIS[nCont]) > 1, ValType(aRatPIS[nCont,2]) == "A", .f.), .f.)
					lCof :=  If(len(aRatCOF) > 0, If(len(aRatCOF[nCont]) > 1, ValType(aRatCOF[nCont,2]) == "A", .f.), .f.)
					lCsl :=  If(len(aRatCsl) > 0, If(len(aRatCsl[nCont]) > 1, ValType(aRatCsl[nCont,2]) == "A", .f.), .f.)
					lInss := If(len(aRatINS) > 0, If(len(aRatINS[nCont]) > 1, ValType(aRatINS[nCont,2]) == "A", .f.), .f.)
					lIss :=  If(len(aRatISS) > 0, If(len(aRatISS[nCont]) > 1, ValType(aRatISS[nCont,2]) == "A", .f.), .f.)
					lCid :=  If(len(aRatISS) > 0, If(len(aRatISS[nCont]) > 1, ValType(aRatISS[nCont,2]) == "A", .f.), .f.)  
					
					While !Eof() .and. SEZTMP->EZ_NATUREZ == aCols[nX][1]
						VALOR 	:= SEZ->EZ_VALOR		// Valor Principal
						VALOR2	:= 0		// Irf
						VALOR3	:= 0		// Inss
						VALOR4	:= 0		// Iss
						VALOR5	:= 0		// Pis
						VALOR6	:= 0		// Cofins
						VALOR7	:= 0		// Csll

						// Verifica se não foi um movimento deletado no acols Mult Nat C.Custo e
						If !(SEZTMP->EZ_FLAG)
							If lGrvSez
								If SEZTMP->EZ_RECNO = 0
									SEZ->(DbGoBottom())
									SEZ->(DbSkip())
								Else
									SEZ->(DbGoto(SEZTMP->EZ_RECNO))
								Endif
								ExecBlock("MULTSEZ", .F., .F., { nOpc, cChave })
								DbSelectArea("SEZ")
							Endif
							If SEZTMP->EZ_RECNO = 0
								SEZ->(RecLock("SEZ",.T.))
							Else
								SEZ->(DbGoto(SEZTMP->EZ_RECNO))
								If SEZ->(Deleted())			// Alteracao de natureza
									SEZ->(RecLock("SEZ",.T.))
								Else
									SEZ->(RecLock("SEZ",.F.))
								Endif
							Endif
							SEZ->EZ_FILIAL		:= xFilial("SEZ")
							SEZ->EZ_PREFIXO	:= (cAlias)->&(cCampo + "_PREFIXO")
							SEZ->EZ_NUM			:= (cAlias)->&(cCampo + "_NUM")
							SEZ->EZ_PARCELA	:= (cAlias)->&(cCampo + "_PARCELA")
							SEZ->EZ_CLIFOR		:= (cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))
							SEZ->EZ_LOJA		:= (cAlias)->&(cCampo + "_LOJA")
							SEZ->EZ_TIPO		:= (cAlias)->&(cCampo + "_TIPO")
							SEZ->EZ_NATUREZ	:= aCols[nX][1] // Grava a natureza
							SEZ->EZ_VALOR		:= IIf(SEZTMP->EZ_VALOR == (aCols[nX][2]*SEZTMP->EZ_PERC),SEZTMP->EZ_VALOR,aCols[nX][2]*SEZTMP->EZ_PERC) // Grava o valor informado
							SEZ->EZ_PERC		:= SEZTMP->EZ_PERC
							SEZ->EZ_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
							SEZ->EZ_CCUSTO		:= SEZTMP->EZ_CCUSTO  // Centro de Custo
							SEZ->EZ_ITEMCTA	:= SEZTMP->EZ_ITEMCTA  // Item
							SEZ->EZ_CLVL   	:= SEZTMP->EZ_CLVL     // Classe de Valor
							SEZ->EZ_IDENT	:= "1"   //rateio de inclusao
							SEZ->EZ_CONTA	:= SEZTMP->EZ_CONTA
							If __lEnt05
								SEZ->EZ_EC05DB := SEZTMP->EZ_EC05DB
								SEZ->EZ_EC05CR := SEZTMP->EZ_EC05CR
							Endif
							If __lEnt06
								SEZ->EZ_EC06DB := SEZTMP->EZ_EC06DB
								SEZ->EZ_EC06CR := SEZTMP->EZ_EC06CR
							Endif
							If __lEnt07
								SEZ->EZ_EC07DB := SEZTMP->EZ_EC07DB
								SEZ->EZ_EC07CR := SEZTMP->EZ_EC07CR
							Endif
							If __lEnt08
								SEZ->EZ_EC08DB := SEZTMP->EZ_EC08DB
								SEZ->EZ_EC08CR := SEZTMP->EZ_EC08CR
							Endif
							If __lEnt09
								SEZ->EZ_EC09DB := SEZTMP->EZ_EC09DB
								SEZ->EZ_EC09CR := SEZTMP->EZ_EC09CR
							Endif						
							aEval( aStructSEZ , { | aTmpSEZ | SEZ->&( aTmpSEZ ) := SEZTMP->&( aTmpSEZ ) } )
							
							SEZ->EZ_IDDOC    := cChaveFK7
							MsUnlock()
		                    FKCOMMIT()
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Gera o lancamento no PCO com os dados do lancamento de C.C. por natureza (06) ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If cAlias == "SE1"
								PCODetLan( "000001", "05", "FINA040" )
							Else
								PCODetLan( "000002", "05", "FINA050" )
							EndIf

							// Contabilizacao das MultiNat com Rateio C.Custo
							// Somente sera contabilizado se existir o LP 500/510 e o 506/508 ou
							// LP 520/530 e 536/537 se for baixa
							If lPadrao .and. lPadraoCC .And. aCols[nX][4] == "1" .And. lContabiliza
								VALOR 	:= SEZ->EZ_VALOR	// Valor Principal
								VALOR2	:= 0					// Irf
								VALOR3	:= 0					// Inss
								VALOR4	:= 0					// Iss
								VALOR5	:= 0					// Pis
								VALOR6	:= 0					// Cofins
								VALOR7	:= 0					// Csll

								// Contabiliza pelo SEZ
								If nHdlPrv <= 0
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Inicializa Lancamento Contabil                                   ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										nHdlPrv := HeadProva( cLote,;
										                      cOrigem /*cPrograma*/,;
										                      Substr(cUsuario,7,6),;
										                      @cArquivo )
								Endif
								dbSelectArea( "SED" )
								MsSeek( xFilial("SED")+SEZ->EZ_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
								dbSelectArea("SEZ")
								If nHdlPrv > 0
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Prepara Lancamento Contabil                                      ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
											aAdd( aFlagCTB, {"EZ_LA", "S", "SEZ", SEZ->( Recno() ), 0, 0, 0} )
										Endif

										nTotal += DetProva( nHdlPrv,;
										                    cPadraoCC /*cPadrao*/,;
										                    cOrigem /*cPrograma*/,;
										                    cLote,;
										                    /*nLinha*/,;
										                    /*lExecuta*/,;
										                    /*cCriterio*/,;
										                    /*lRateio*/,;
										                    /*cChaveBusca*/,;
										                    /*aCT5*/,;
										                    /*lPosiciona*/,;
										                    @aFlagCTB,;
										                    /*aTabRecOri*/,;
										                    /*aDadosProva*/ )
								Endif

								If !lUsaFlag
									SEZ->(RecLock("SEZ"))
									SEZ->EZ_LA    := "S"
									MsUnlock()
								Endif

								lCtbRatCC := .T.
							Endif

							If cAlias = "SE2" .And. lRatImpostos
								//Irrf								 
								If (M->E2_IRRF > 0) .and. (Len(aRatIRF) >= nCont) .and. (Len(aRatIrf[nCont]) >= ++nCont1 .OR. lIrf)
									// nCont1 ++
									If lGrvSez
										SEZTMP->EZ_NATUREZ	:= aCols[nX][1] // Grava a natureza
										SEZTMP->EZ_VALOR		:= aRatIrf[nCont][2][nCont1] // Grava o valor informado
										SEZTMP->EZ_PERC		:= SEZTMP->EZ_PERC
										ExecBlock("MULTSEZ", .F., .F., { nOpc, cChaveIrf })
										DbSelectArea("SEZ")
									Endif
									SEZ->(RecLock("SEZ",.T.))
									SEZ->EZ_FILIAL		:= xFilial("SEZ")
									SEZ->EZ_PREFIXO	:= (cAlias)->&(cCampo + "_PREFIXO")
									SEZ->EZ_NUM			:= (cAlias)->&(cCampo + "_NUM")
									SEZ->EZ_PARCELA	:= SE2->E2_PARCIR
									SEZ->EZ_CLIFOR		:= _cMvUniao
									SEZ->EZ_LOJA		:= cLojaImp
									SEZ->EZ_TIPO		:= Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
									SEZ->EZ_NATUREZ	:= aCols[nX][1] // Grava a natureza
									SEZ->EZ_VALOR		:= aRatIrf[nCont][2][nCont1] // Grava o valor informado
									SEZ->EZ_PERC		:= SEZTMP->EZ_PERC
									SEZ->EZ_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
									SEZ->EZ_CCUSTO		:= SEZTMP->EZ_CCUSTO  // Centro de Custo
									SEZ->EZ_ITEMCTA		:= SEZTMP->EZ_ITEMCTA  // Item
									SEZ->EZ_CLVL   		:= SEZTMP->EZ_CLVL     // Classe de Valor
									SEZ->EZ_IDENT		:= "1"  //Rateio de inclusao
									SEZ->EZ_CONTA	:= SEZTMP->EZ_CONTA
									aEval( aStructSEZ , { | aTmpSEZ | SEZ->&( aTmpSEZ ) := SEZTMP->&( aTmpSEZ ) } )
									lIrf := If(lIrf, nCont1 <= Len(aRatIrf[nCont,2]), .f.)
									//Gravação da chave FK7 para os rateios
									cChaveTit := xFilial(cAlias) 	+ "|" +;
												SEZ->EZ_PREFIXO	+ "|" +;
												SEZ->EZ_NUM		+ "|" +;
												SEZ->EZ_PARCELA	+ "|" +;
												SEZ->EZ_TIPO		+ "|" +;
												SEZ->EZ_CLIFOR	+ "|" +;
												SEZ->EZ_LOJA
									cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)
				
									SEZ->EZ_IDDOC := cChvImpFK7
									
									MsUnlock()
									FKCOMMIT()
									// Contabilizacao das MultiNat com Rateio C.Custo
									If lPadraoCC .And. aCols[nX][4] == "1" .And. lContabiliza
										// Contabiliza pelo SEZ
										dbSelectArea( "SED" )
										MsSeek( xFilial("SED")+SEZ->EZ_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
										dbSelectArea("SEZ")
										If nHdlPrv > 0
											VALOR		:= 0					// Valor Principal
											VALOR2	:= SEZ->EZ_VALOR	// Irf
											VALOR3	:= 0					// Inss
											VALOR4	:= 0					// Iss
											VALOR5	:= 0					// Pis
											VALOR6	:= 0					// Cofins
											VALOR7	:= 0					// Csll

											//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
											//³ Prepara Lancamento Contabil                                      ³
											//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
												If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
													aAdd( aFlagCTB, {"EZ_LA", "S", "SEZ", SEZ->( Recno() ), 0, 0, 0} )
												Endif

												nTotal += DetProva( nHdlPrv,;
												                    cPadraoCC /*cPadrao*/,;
												                    cOrigem /*cPrograma*/,;
												                    cLote,;
												                    /*nLinha*/,;
												                    /*lExecuta*/,;
												                    /*cCriterio*/,;
												                    /*lRateio*/,;
												                    /*cChaveBusca*/,;
												                    /*aCT5*/,;
												                    /*lPosiciona*/,;
												                    @aFlagCTB,;
												                    /*aTabRecOri*/,;
												                    /*aDadosProva*/ )

										Endif

										If !lUsaFlag
											SEZ->(RecLock("SEZ"))
											SEZ->EZ_LA    := "S"
											MsUnlock()
										Endif

									Endif
								Endif

								//Pis
								If (M->E2_PIS > 0) .and. (Len(aRatPIS) >= nCont) .and. (Len(aRatPIS[nCont]) >= ++nCont4 .OR. lPis)
									//nCont4 ++
									If lGrvSez
										SEZTMP->EZ_NATUREZ	:= aCols[nX][1] // Grava a natureza
										SEZTMP->EZ_VALOR		:= aRatPis[nCont][2][nCont4] // Grava o valor informado
										SEZTMP->EZ_PERC		:= SEZTMP->EZ_PERC
										ExecBlock("MULTSEZ", .F., .F., { nOpc, cChavePis })
										DbSelectArea("SEZ")
									Endif
									SEZ->(RecLock("SEZ",.T.))
									SEZ->EZ_FILIAL		:= xFilial("SEZ")
									SEZ->EZ_PREFIXO	:= (cAlias)->&(cCampo + "_PREFIXO")
									SEZ->EZ_NUM			:= (cAlias)->&(cCampo + "_NUM")
									SEZ->EZ_PARCELA	:= SE2->E2_PARCPIS
									SEZ->EZ_CLIFOR		:= _cMvUniao
									SEZ->EZ_LOJA		:= cLojaImp
									SEZ->EZ_TIPO		:= Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
									SEZ->EZ_NATUREZ	:= aCols[nX][1] // Grava a natureza
									SEZ->EZ_VALOR		:= aRatPis[nCont][2][nCont4] // Grava o valor informado
									SEZ->EZ_PERC		:= SEZTMP->EZ_PERC
									SEZ->EZ_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
									SEZ->EZ_CCUSTO		:= SEZTMP->EZ_CCUSTO  // Centro de Custo
									SEZ->EZ_ITEMCTA	:= SEZTMP->EZ_ITEMCTA  // Item
									SEZ->EZ_CLVL		:= SEZTMP->EZ_CLVL     // Classe de Valor
									SEZ->EZ_IDENT		:= "1"  //Rateio de inclusao
									SEZ->EZ_CONTA	:= SEZTMP->EZ_CONTA
									aEval( aStructSEZ , { | aTmpSEZ | SEZ->&( aTmpSEZ ) := SEZTMP->&( aTmpSEZ ) } )
									lPis := If(lPis, nCont4 <= Len(aRatPIS[nCont,2]), .f.)
									
									//Gravação da chave FK7 para os rateios
									cChaveTit := xFilial(cAlias) 	+ "|" +;
												SEZ->EZ_PREFIXO	+ "|" +;
												SEZ->EZ_NUM		+ "|" +;
												SEZ->EZ_PARCELA	+ "|" +;
												SEZ->EZ_TIPO		+ "|" +;
												SEZ->EZ_CLIFOR	+ "|" +;
												SEZ->EZ_LOJA
									cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)
				
									SEZ->EZ_IDDOC := cChvImpFK7
									MsUnlock()
									FKCOMMIT()
									// Contabilizacao das MultiNat com Rateio C.Custo
									If lPadraoCC .And. aCols[nX][4] == "1" .And. lContabiliza
										// Contabiliza pelo SEZ
										dbSelectArea( "SED" )
										MsSeek( xFilial("SED")+SEZ->EZ_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
										dbSelectArea("SEZ")
										If nHdlPrv > 0
											VALOR		:= 0					// Valor Principal
											VALOR2	:= 0					// Irf
											VALOR3	:= 0					// Inss
											VALOR4	:= 0					// Iss
											VALOR5	:= SEZ->EZ_VALOR	// Pis
											VALOR6	:= 0					// Cofins
											VALOR7	:= 0					// Csll

											//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
											//³ Prepara Lancamento Contabil                                      ³
											//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
												If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
													aAdd( aFlagCTB, {"EZ_LA", "S", "SEZ", SEZ->( Recno() ), 0, 0, 0} )
												Endif

												nTotal += DetProva( nHdlPrv,;
												                    cPadraoCC /*cPadrao*/,;
												                    cOrigem /*cPrograma*/,;
												                    cLote,;
												                    /*nLinha*/,;
												                    /*lExecuta*/,;
												                    /*cCriterio*/,;
												                    /*lRateio*/,;
												                    /*cChaveBusca*/,;
												                    /*aCT5*/,;
												                    /*lPosiciona*/,;
												                    @aFlagCTB,;
												                    /*aTabRecOri*/,;
												                    /*aDadosProva*/ )

										Endif

										If !lUsaFlag
											SEZ->(RecLock("SEZ"))
											SEZ->EZ_LA    := "S"
											MsUnlock()
										Endif

									Endif
								Endif

								//Cofins
								If (M->E2_COFINS > 0) .and. (Len(aRatCOF) >= nCont) .and. (Len(aRatCOF[nCont]) >= ++nCont5 .OR. lCof)
									//nCont5 ++
									If lGrvSez
										SEZTMP->EZ_NATUREZ	:= aCols[nX][1] // Grava a natureza
										SEZTMP->EZ_VALOR		:= aRatCof[nCont][2][nCont5] // Grava o valor informado
										SEZTMP->EZ_PERC		:= SEZTMP->EZ_PERC
										ExecBlock("MULTSEZ", .F., .F., { nOpc, cChaveCof })
										DbSelectArea("SEZ")
									Endif
									SEZ->(RecLock("SEZ",.T.))
									SEZ->EZ_FILIAL		:= xFilial("SEZ")
									SEZ->EZ_PREFIXO	:= (cAlias)->&(cCampo + "_PREFIXO")
									SEZ->EZ_NUM			:= (cAlias)->&(cCampo + "_NUM")
									SEZ->EZ_PARCELA	:= SE2->E2_PARCCOF
									SEZ->EZ_CLIFOR		:= _cMvUniao
									SEZ->EZ_LOJA		:= cLojaImp
									SEZ->EZ_TIPO		:= Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
									SEZ->EZ_NATUREZ	:= aCols[nX][1] // Grava a natureza
									SEZ->EZ_VALOR		:= aRatCof[nCont][2][nCont5] // Grava o valor informado
									SEZ->EZ_PERC		:= SEZTMP->EZ_PERC
									SEZ->EZ_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
									SEZ->EZ_CCUSTO		:= SEZTMP->EZ_CCUSTO  // Centro de Custo
									SEZ->EZ_ITEMCTA	:= SEZTMP->EZ_ITEMCTA  // Item
									SEZ->EZ_CLVL		:= SEZTMP->EZ_CLVL     // Classe de Valor
									SEZ->EZ_IDENT		:= "1"  //Rateio de inclusao
									SEZ->EZ_CONTA	:= SEZTMP->EZ_CONTA
									aEval( aStructSEZ , { | aTmpSEZ | SEZ->&( aTmpSEZ ) := SEZTMP->&( aTmpSEZ ) } )
									lCof := If(lCof, nCont5 <= Len(aRatCOF[nCont,2]), .f.)
									//Gravação da chave FK7 para os rateios
									cChaveTit := xFilial(cAlias) 	+ "|" +;
												SEZ->EZ_PREFIXO	+ "|" +;
												SEZ->EZ_NUM		+ "|" +;
												SEZ->EZ_PARCELA	+ "|" +;
												SEZ->EZ_TIPO		+ "|" +;
												SEZ->EZ_CLIFOR	+ "|" +;
												SEZ->EZ_LOJA
									cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)
				
									SEZ->EZ_IDDOC := cChvImpFK7
									
									MsUnlock()
									FKCOMMIT()
									// Contabilizacao das MultiNat com Rateio C.Custo
									If lPadraoCC .And. aCols[nX][4] == "1" .And. lContabiliza
										// Contabiliza pelo SEZ
										dbSelectArea( "SED" )
										MsSeek( xFilial("SED")+SEZ->EZ_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
										dbSelectArea("SEZ")
										If nHdlPrv > 0
											VALOR		:= 0					// Valor Principal
											VALOR2	:= 0					// Irf
											VALOR3	:= 0					// Inss
											VALOR4	:= 0					// Iss
											VALOR5	:= 0					// Pis
											VALOR6	:= SEZ->EZ_VALOR	// Cofins
											VALOR7	:= 0					// Csll

											//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
											//³ Prepara Lancamento Contabil                                      ³
											//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
												If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
													aAdd( aFlagCTB, {"EZ_LA", "S", "SEZ", SEZ->( Recno() ), 0, 0, 0} )
												Endif

												nTotal += DetProva( nHdlPrv,;
												                    cPadraoCC /*cPadrao*/,;
												                    cOrigem /*cPrograma*/,;
												                    cLote,;
												                    /*nLinha*/,;
												                    /*lExecuta*/,;
												                    /*cCriterio*/,;
												                    /*lRateio*/,;
												                    /*cChaveBusca*/,;
												                    /*aCT5*/,;
												                    /*lPosiciona*/,;
												                    @aFlagCTB,;
												                    /*aTabRecOri*/,;
												                    /*aDadosProva*/ )

										Endif

										If !lUsaflag
											SEZ->(RecLock("SEZ"))
											SEZ->EZ_LA    := "S"
											MsUnlock()
										Endif

									Endif
								Endif

								//CSLL
								If (M->E2_CSLL > 0) .and. (Len(aRatCsl) >= nCont) .and. (Len(aRatCsl[nCont]) >= ++nCont6 .OR. lCsl)
									//nCont6 ++
									If lGrvSez
										SEZTMP->EZ_NATUREZ	:= aCols[nX][1] // Grava a natureza
										SEZTMP->EZ_VALOR		:= aRatIrf[nCont][2][nCont6] // Grava o valor informado
										SEZTMP->EZ_PERC		:= SEZTMP->EZ_PERC
										ExecBlock("MULTSEZ", .F., .F., { nOpc, cChaveCsl })
										DbSelectArea("SEZ")
									Endif
									SEZ->(RecLock("SEZ",.T.))
									SEZ->EZ_FILIAL		:= xFilial("SEZ")
									SEZ->EZ_PREFIXO	:= (cAlias)->&(cCampo + "_PREFIXO")
									SEZ->EZ_NUM			:= (cAlias)->&(cCampo + "_NUM")
									SEZ->EZ_PARCELA	:= SE2->E2_PARCSLL
									SEZ->EZ_CLIFOR		:= _cMvUniao
									SEZ->EZ_LOJA		:= cLojaImp
									SEZ->EZ_TIPO		:= Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
									SEZ->EZ_NATUREZ	:= aCols[nX][1] // Grava a natureza
									SEZ->EZ_VALOR		:= aRatCsl[nCont][2][nCont6] // Grava o valor informado
									SEZ->EZ_PERC		:= SEZTMP->EZ_PERC
									SEZ->EZ_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
									SEZ->EZ_CCUSTO		:= SEZTMP->EZ_CCUSTO  // Centro de Custo
									SEZ->EZ_ITEMCTA	:= SEZTMP->EZ_ITEMCTA  // Item
									SEZ->EZ_CLVL		:= SEZTMP->EZ_CLVL     // Classe de Valor
									SEZ->EZ_IDENT		:= "1"  //Rateio de inclusao
									SEZ->EZ_CONTA	:= SEZTMP->EZ_CONTA
									aEval( aStructSEZ , { | aTmpSEZ | SEZ->&( aTmpSEZ ) := SEZTMP->&( aTmpSEZ ) } )
									lCsl := If(lCsl, nCont6 <= Len(aRatCsl[nCont,2]), .f.)
									//Gravação da chave FK7 para os rateios
									cChaveTit := xFilial(cAlias) 	+ "|" +;
												SEZ->EZ_PREFIXO	+ "|" +;
												SEZ->EZ_NUM		+ "|" +;
												SEZ->EZ_PARCELA	+ "|" +;
												SEZ->EZ_TIPO		+ "|" +;
												SEZ->EZ_CLIFOR	+ "|" +;
												SEZ->EZ_LOJA
									cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)
				
									SEZ->EZ_IDDOC := cChvImpFK7
									
									
									MsUnlock()

									// Contabilizacao das MultiNat com Rateio C.Custo
									If lPadraoCC .And. aCols[nX][4] == "1" .And. lContabiliza
										// Contabiliza pelo SEZ
										dbSelectArea( "SED" )
										MsSeek( xFilial("SED")+SEZ->EZ_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
										dbSelectArea("SEZ")
										If nHdlPrv > 0
											VALOR		:= 0					// Valor Principal
											VALOR2	:= 0					// Irf
											VALOR3	:= 0					// Inss
											VALOR4	:= 0					// Iss
											VALOR5	:= 0					// Pis
											VALOR6	:= 0					// Cofins
											VALOR7	:= SEZ->EZ_VALOR	// Csll

											//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
											//³ Prepara Lancamento Contabil                                      ³
											//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
												If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
													aAdd( aFlagCTB, {"EZ_LA", "S", "SEZ", SEZ->( Recno() ), 0, 0, 0} )
												Endif

												nTotal += DetProva( nHdlPrv,;
												                    cPadraoCC /*cPadrao*/,;
												                    cOrigem /*cPrograma*/,;
												                    cLote,;
												                    /*nLinha*/,;
												                    /*lExecuta*/,;
												                    /*cCriterio*/,;
												                    /*lRateio*/,;
												                    /*cChaveBusca*/,;
												                    /*aCT5*/,;
												                    /*lPosiciona*/,;
												                    @aFlagCTB,;
												                    /*aTabRecOri*/,;
												                    /*aDadosProva*/ )

										Endif

										If !lUsaFlag
											SEZ->(RecLock("SEZ"))
											SEZ->EZ_LA    := "S"
											MsUnlock()
										Endif

									Endif
								Endif

								If (M->E2_INSS > 0) .and. (Len(aRatINS) >= nCont) .and. (Len(aRatINS[nCont]) >= ++nCont2 .OR. lInss)
									//nCont2 ++
									If lGrvSez
										SEZTMP->EZ_NATUREZ	:= aCols[nX][1] // Grava a natureza
										SEZTMP->EZ_VALOR		:= aRatIns[nCont][2][nCont2] // Grava o valor informado
										SEZTMP->EZ_PERC		:= SEZTMP->EZ_PERC
										ExecBlock("MULTSEZ", .F., .F., { nOpc, cChaveIns })
										DbSelectArea("SEZ")
									Endif

									SEZ->(RecLock("SEZ",.T.))
									SEZ->EZ_FILIAL		:= xFilial("SEZ")
									SEZ->EZ_PREFIXO	:= (cAlias)->&(cCampo + "_PREFIXO")
									SEZ->EZ_NUM			:= (cAlias)->&(cCampo + "_NUM")
									SEZ->EZ_PARCELA	:= SE2->E2_PARCINS
									SEZ->EZ_CLIFOR		:= _cMvFInss
									SEZ->EZ_LOJA		:= cLojaImp
									SEZ->EZ_TIPO		:= IIf(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"INA",MVINSS)
									SEZ->EZ_NATUREZ	:= aCols[nX][1] // Grava a natureza
									SEZ->EZ_VALOR		:= aRatIns[nCont][2][nCont2] // Grava o valor informado
									SEZ->EZ_PERC		:= SEZTMP->EZ_PERC
									SEZ->EZ_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
									SEZ->EZ_CCUSTO		:= SEZTMP->EZ_CCUSTO  // Centro de Custo
									SEZ->EZ_ITEMCTA	:= SEZTMP->EZ_ITEMCTA  // Item
									SEZ->EZ_CLVL   	:= SEZTMP->EZ_CLVL     // Classe de Valor
									SEZ->EZ_IDENT		:= "1"  //Rateio de inclusao
									SEZ->EZ_CONTA	:= SEZTMP->EZ_CONTA
									aEval( aStructSEZ , { | aTmpSEZ | SEZ->&( aTmpSEZ ) := SEZTMP->&( aTmpSEZ ) } )
									lInss := If(lInss, nCont2 <= Len(aRatINS[nCont,2]), .f.)
									
									//Gravação da chave FK7 para os rateios
									cChaveTit := xFilial(cAlias) 	+ "|" +;
												SEZ->EZ_PREFIXO	+ "|" +;
												SEZ->EZ_NUM		+ "|" +;
												SEZ->EZ_PARCELA	+ "|" +;
												SEZ->EZ_TIPO		+ "|" +;
												SEZ->EZ_CLIFOR	+ "|" +;
												SEZ->EZ_LOJA
									cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)
				
									SEZ->EZ_IDDOC := cChvImpFK7
									
									MsUnlock()

									// Contabilizacao das MultiNat com Rateio C.Custo
									If lPadraoCC .And. aCols[nX][4] == "1" .And. lContabiliza
										// Contabiliza pelo SEZ
										dbSelectArea( "SED" )
										MsSeek( xFilial("SED")+SEZ->EZ_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
										dbSelectArea("SEZ")
										If nHdlPrv > 0
											VALOR 	:= 0					// Valor Principal
											VALOR2	:= 0					// Irf
											VALOR3	:= SEZ->EZ_VALOR	// Inss
											VALOR4	:= 0					// Iss
											VALOR5	:= 0					// Pis
											VALOR6	:= 0					// Cofins
											VALOR7	:= 0					// Csll

											//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
											//³ Prepara Lancamento Contabil                                      ³
											//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
												If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
													aAdd( aFlagCTB, {"EZ_LA", "S", "SEZ", SEZ->( Recno() ), 0, 0, 0} )
												Endif

												nTotal += DetProva( nHdlPrv,;
												                    cPadraoCC /*cPadrao*/,;
												                    cOrigem /*cPrograma*/,;
												                    cLote,;
												                    /*nLinha*/,;
												                    /*lExecuta*/,;
												                    /*cCriterio*/,;
												                    /*lRateio*/,;
												                    /*cChaveBusca*/,;
												                    /*aCT5*/,;
												                    /*lPosiciona*/,;
												                    @aFlagCTB,;
												                    /*aTabRecOri*/,;
												                    /*aDadosProva*/ )

										Endif

										If !lUsaFlag
											SEZ->(RecLock("SEZ"))
											SEZ->EZ_LA    := "S"
											MsUnlock()
										Endif

									Endif
								Endif
								
								If (M->E2_ISS > 0) .and. (Len(aRatISS) >= nCont) .and. (Len(aRatISS[nCont]) >= ++nCont3 .OR. lIss)
									//nCont3 ++
									If lGrvSez
										SEZTMP->EZ_NATUREZ	:= aCols[nX][1] // Grava a natureza
										SEZTMP->EZ_VALOR		:= aRatIss[nCont][2][nCont3] // Grava o valor informado
										SEZTMP->EZ_PERC		:= SEZTMP->EZ_PERC
										ExecBlock("MULTSEZ", .F., .F., { nOpc, cChaveIss })
										DbSelectArea("SEZ")
									Endif

									SEZ->(RecLock("SEZ",.T.))
									SEZ->EZ_FILIAL		:= xFilial("SEZ")
									SEZ->EZ_PREFIXO	:= (cAlias)->&(cCampo + "_PREFIXO")
									SEZ->EZ_NUM			:= (cAlias)->&(cCampo + "_NUM")
									SEZ->EZ_PARCELA	:= SE2->E2_PARCISS
									SEZ->EZ_CLIFOR		:= _cMvMunic
									SEZ->EZ_LOJA		:= cLojaImp
									SEZ->EZ_TIPO		:= MVISS
									SEZ->EZ_NATUREZ	:= aCols[nX][1] // Grava a natureza
									SEZ->EZ_VALOR		:= aRatIss[nCont][2][nCont3] // Grava o valor informado
									SEZ->EZ_PERC		:= SEZTMP->EZ_PERC
									SEZ->EZ_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
									SEZ->EZ_CCUSTO		:= SEZTMP->EZ_CCUSTO  // Centro de Custo
									SEZ->EZ_ITEMCTA	:= SEZTMP->EZ_ITEMCTA  // Item
									SEZ->EZ_CLVL   	:= SEZTMP->EZ_CLVL     // Classe de Valor
									SEZ->EZ_IDENT		:= "1"  //Rateio de inclusao
									SEZ->EZ_CONTA	:= SEZTMP->EZ_CONTA
									aEval( aStructSEZ , { | aTmpSEZ | SEZ->&( aTmpSEZ ) := SEZTMP->&( aTmpSEZ ) } )
									lIss := If(lIss, nCont3 <= Len(aRatISS[nCont,2]), .f.)
									//Gravação da chave FK7 para os rateios
									cChaveTit := xFilial(cAlias) 	+ "|" +;
												SEZ->EZ_PREFIXO	+ "|" +;
												SEZ->EZ_NUM		+ "|" +;
												SEZ->EZ_PARCELA	+ "|" +;
												SEZ->EZ_TIPO		+ "|" +;
												SEZ->EZ_CLIFOR	+ "|" +;
												SEZ->EZ_LOJA
									cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)
				
									SEZ->EZ_IDDOC := cChvImpFK7
									
									MsUnlock()

									// Contabilizacao das MultiNat com Rateio C.Custo
									If lPadraoCC .And. aCols[nX][4] == "1" .And. lContabiliza
										// Contabiliza pelo SEZ
										dbSelectArea( "SED" )
										MsSeek( xFilial("SED")+SEZ->EZ_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
										dbSelectArea("SEZ")
										If nHdlPrv > 0
											VALOR 	:= 0					// Valor Principal
											VALOR2	:= 0					// Irf
											VALOR3	:= 0					// Inss
											VALOR4	:= SEZ->EZ_VALOR	// Iss
											VALOR5	:= 0					// Pis
											VALOR6	:= 0					// Cofins
											VALOR7	:= 0					// Csll

											//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
											//³ Prepara Lancamento Contabil                                      ³
											//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
												If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
													aAdd( aFlagCTB, {"EZ_LA", "S", "SEZ", SEZ->( Recno() ), 0, 0, 0} )
												Endif

												nTotal += DetProva( nHdlPrv,;
												                    cPadraoCC /*cPadrao*/,;
												                    cOrigem /*cPrograma*/,;
												                    cLote,;
												                    /*nLinha*/,;
												                    /*lExecuta*/,;
												                    /*cCriterio*/,;
												                    /*lRateio*/,;
												                    /*cChaveBusca*/,;
												                    /*aCT5*/,;
												                    /*lPosiciona*/,;
												                    @aFlagCTB,;
												                    /*aTabRecOri*/,;
												                    /*aDadosProva*/ )

										Endif

										If !lUsaFlag
											SEZ->(RecLock("SEZ"))
											SEZ->EZ_LA    := "S"
											MsUnlock()
										Endif

									Endif
								Endif

								If cPaisLoc == "BRA" .And. (M->E2_CIDE > 0) .and. (Len(aRatCid) >= nCont) .and. (Len(aRatCid[nCont]) >= ++nCont7 .OR. lCid)
									//nCont7 ++
									If lGrvSez
										SEZTMP->EZ_NATUREZ	:= aCols[nX][1] // Grava a natureza
										SEZTMP->EZ_VALOR	:= aRatCid[nCont][2][nCont7] // Grava o valor informado
										SEZTMP->EZ_PERC		:= SEZTMP->EZ_PERC
										ExecBlock("MULTSEZ", .F., .F., { nOpc, cChaveCid })
										DbSelectArea("SEZ")
									Endif

									SEZ->(RecLock("SEZ",.T.))
									SEZ->EZ_FILIAL		:= xFilial("SEZ")
									SEZ->EZ_PREFIXO		:= (cAlias)->&(cCampo + "_PREFIXO")
									SEZ->EZ_NUM			:= (cAlias)->&(cCampo + "_NUM")
									SEZ->EZ_PARCELA		:= SE2->E2_PARCCID
									SEZ->EZ_CLIFOR		:= _cMvFCide
									SEZ->EZ_LOJA		:= cLojaImp
									SEZ->EZ_TIPO		:= "CID"
									SEZ->EZ_NATUREZ		:= aCols[nX][1] // Grava a natureza
									SEZ->EZ_VALOR		:= aRatCid[nCont][2][nCont7] // Grava o valor informado
									SEZ->EZ_PERC		:= SEZTMP->EZ_PERC
									SEZ->EZ_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
									SEZ->EZ_CCUSTO		:= SEZTMP->EZ_CCUSTO  // Centro de Custo
									SEZ->EZ_ITEMCTA		:= SEZTMP->EZ_ITEMCTA  // Item
									SEZ->EZ_CLVL   		:= SEZTMP->EZ_CLVL     // Classe de Valor
									SEZ->EZ_IDENT		:= "1"  //Rateio de inclusao
									SEZ->EZ_CONTA		:= SEZTMP->EZ_CONTA
									aEval( aStructSEZ , { | aTmpSEZ | SEZ->&( aTmpSEZ ) := SEZTMP->&( aTmpSEZ ) } )
									lCid := If(lCid, nCont7 <= Len(aRatCid[nCont,2]), .f.)
									//Gravação da chave FK7 para os rateios
									cChaveTit := xFilial(cAlias) 	+ "|" +;
												SEZ->EZ_PREFIXO	+ "|" +;
												SEZ->EZ_NUM		+ "|" +;
												SEZ->EZ_PARCELA	+ "|" +;
												SEZ->EZ_TIPO		+ "|" +;
												SEZ->EZ_CLIFOR	+ "|" +;
												SEZ->EZ_LOJA
									cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)
				
									SEZ->EZ_IDDOC := cChvImpFK7
									
									MsUnlock()

									// Contabilizacao das MultiNat com Rateio C.Custo
									If lPadraoCC .And. aCols[nX][4] == "1" .And. lContabiliza
										// Contabiliza pelo SEZ
										dbSelectArea( "SED" )
										MsSeek( xFilial("SED")+SEZ->EZ_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
										dbSelectArea("SEZ")
										If nHdlPrv > 0
											VALOR 	:= 0					// Valor Principal
											VALOR2	:= 0					// Irf
											VALOR3	:= 0					// Inss
											VALOR4	:= 0					// Iss
											VALOR5	:= 0					// Pis
											VALOR6	:= 0					// Cofins
											VALOR7	:= 0					// Csll

											//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
											//³ Prepara Lancamento Contabil                                      ³
											//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
												If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
													aAdd( aFlagCTB, {"EZ_LA", "S", "SEZ", SEZ->( Recno() ), 0, 0, 0} )
												Endif

												nTotal += DetProva( nHdlPrv,;
												                    cPadraoCC /*cPadrao*/,;
												                    cOrigem /*cPrograma*/,;
												                    cLote,;
												                    /*nLinha*/,;
												                    /*lExecuta*/,;
												                    /*cCriterio*/,;
												                    /*lRateio*/,;
												                    /*cChaveBusca*/,;
												                    /*aCT5*/,;
												                    /*lPosiciona*/,;
												                    @aFlagCTB,;
												                    /*aTabRecOri*/,;
												                    /*aDadosProva*/ )

										Endif

										If !lUsaFlag
											SEZ->(RecLock("SEZ"))
											SEZ->EZ_LA    := "S"
											MsUnlock()
										Endif

									Endif
								Endif
																								
							Endif
						ElseIf SEZTMP->EZ_RECNO > 0

							SEZ->(DbGoto(SEZTMP->EZ_RECNO))

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Apaga o lancamento no PCO com os dados de multi-natureza x centro de custo (05) ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If cAlias == "SE1"
								PCODetLan( "000001", "05", "FINA040", .T. )
							Else
								PCODetLan( "000002", "05", "FINA050", .T. )
							EndIf

							SEZ->(RecLock("SEZ",.F.))
							SEZ->(DbDelete())
							SEZ->(MsUnlock())

							If lGrvSez
								ExecBlock("MULTSEZ", .F., .F., { nOpc, SEZ->EZ_PREFIXO +;
								SEZ->EZ_NUM + SEZ->EZ_PARCELA + SEZ->EZ_TIPO + SEZ->EZ_CLIFOR +;
								SEZ->EZ_LOJA })
								DbSelectArea("SEZ")
							Endif
						Endif

						dbSelectArea("SEZTMP")
						DbSkip()
               Enddo
      		Endif
				//Informo contabilizacao para SEV - Multi Naturezas
				dbSelectArea("SEV")
				If nTotal > 0
					RecLock("SEV")
					SEV->EV_LA    := "S"
					MsUnlock()
				Endif
				(cAlias)->(RestArea(aArea1))
			Endif
			// Contabilizacao das MultiNat sem Rateio C.Custo
			If lPadrao .And. !lCtbRatCC .And. lContabiliza
				// Desposiciona para nao contabilizar pelo SE1/SE2, para nao duplicar o
				// LP caso utilize SE1/SE2->Valor
				// A sintaxe do LP deve ser:
				// If(Se1/Se2->E2/E2_Multnat#"2",SEV->EV_VALOR,Se1/S22->_E1/E2_Valor)
				// ou SE1/SE2->E1/E2_Valor.
				DbSelectArea(cAlias)
				DbGoBottom()
				DbSkip()
				// Contabiliza pelo SEV
				If nHdlPrv <= 0
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Inicializa Lancamento Contabil                                   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						nHdlPrv := HeadProva( cLote,;
						                      cOrigem /*cPrograma*/,;
						                      Substr(cUsuario,7,6),;
						                      @cArquivo )
				Endif
				dbSelectArea( "SED" )
				MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
				dbSelectArea("SEV")
				If nHdlPrv > 0
					VALOR 	:= SEV->EV_VALOR		// Valor Principal
					VALOR2	:= 0					// Irf
					VALOR3	:= 0					// Inss
					VALOR4	:= 0					// Iss
					VALOR5	:= 0					// Pis
					VALOR6	:= 0					// Cofins
					VALOR7	:= 0					// Csll

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Prepara Lancamento Contabil                                      ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
							aAdd( aFlagCTB, {"EV_LA", "S", "SEV", SEV->( Recno() ), 0, 0, 0} )
						Endif

						nTotal += DetProva( nHdlPrv,;
						                    cPadrao /*cPadrao*/,;
						                    cOrigem /*cPrograma*/,;
						                    cLote,;
						                    /*nLinha*/,;
						                    /*lExecuta*/,;
						                    /*cCriterio*/,;
						                    /*lRateio*/,;
						                    /*cChaveBusca*/,;
						                    /*aCT5*/,;
						                    /*lPosiciona*/,;
						                    @aFlagCTB,;
						                    /*aTabRecOri*/,;
						                    /*aDadosProva*/ )

				Endif
            If (nTotal > 0) .and. !lUsaFlag
					RecLock("SEV")
					SEV->EV_LA    := "S"
					MsUnlock()
				Endif
				(cAlias)->(RestArea(aArea1))
			Endif
			If cAlias = "SE2" .And. lRatImpostos
				//Irrf
				If (M->E2_IRRF > 0) .and. (Len(aRatIRF) >= nX)
					If lGrvSev
						ExecBlock("MULTSEV", .F., .F., { 	nX, cChaveIrf,;
															aRatIrf[nX][1],;
															(aCols[nX][3] / 100),;
															aCols[nX][1] })
						DbSelectArea("SEV")
					Endif
					SEV->(RecLock("SEV", .T.))
					SEV->EV_FILIAL		:= xFilial("SEV")
					SEV->EV_PREFIXO	:= (cAlias)->&(cCampo + "_PREFIXO")
					SEV->EV_NUM			:= (cAlias)->&(cCampo + "_NUM")
					SEV->EV_PARCELA	:= SE2->E2_PARCIR
					SEV->EV_CLIFOR		:= _cMvUniao
					SEV->EV_LOJA		:= cLojaImp
					SEV->EV_TIPO		:= Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
					SEV->EV_NATUREZ	:= aCols[nX][1] // Grava a natureza
					SEV->EV_VALOR		:= aRatIrf[nX][1]	// Grava o valor informado
					// Grava o percentual (Como indice multiplicador, por esta razao nao
					// multiplica por 100 na gravacao, apenas na exibicao)
					SEV->EV_PERC		:= aCols[nX][3] / 100
					SEV->EV_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
					SEV->EV_RATEICC	:= aCols[nX][4]  // Identificador de Rateio C Custo
					SEV->EV_IDENT		:= "1"  //Rateio de inclusao
					//Gravação da chave FK7 para os rateios
					cChaveTit := xFilial(cAlias) 	+ "|" +;
								SEV->EV_PREFIXO	+ "|" +;
								SEV->EV_NUM		+ "|" +;
								SEV->EV_PARCELA	+ "|" +;
								SEV->EV_TIPO		+ "|" +;
								SEV->EV_CLIFOR	+ "|" +;
								SEV->EV_LOJA
					cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

					SEV->EV_IDDOC := cChvImpFK7

					If lPadrao .And. !lCtbRatCC .And. aCols[nX][4] != "1" .And. lContabiliza
						dbSelectArea( "SED" )
						MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
						dbSelectArea("SEV")
						If nHdlPrv > 0
							VALOR 	:= 0					// Valor Principal
							VALOR2	:= SEV->EV_VALOR	// Irf
							VALOR3	:= 0					// Inss
							VALOR4	:= 0					// Iss
							VALOR5	:= 0					// Pis
							VALOR6	:= 0					// Cofins
							VALOR7	:= 0					// Csll

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Prepara Lancamento Contabil                                      ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
									aAdd( aFlagCTB, {"EV_LA", "S", "SEV", SEV->( Recno() ), 0, 0, 0} )
								Endif

								nTotal += DetProva( nHdlPrv,;
								                    cPadrao /*cPadrao*/,;
								                    cOrigem /*cPrograma*/,;
								                    cLote,;
								                    /*nLinha*/,;
								                    /*lExecuta*/,;
								                    /*cCriterio*/,;
								                    /*lRateio*/,;
								                    /*cChaveBusca*/,;
								                    /*aCT5*/,;
								                    /*lPosiciona*/,;
								                    @aFlagCTB,;
								                    /*aTabRecOri*/,;
								                    /*aDadosProva*/ )

						Endif

		            If ( nTotal > 0 ) .and. !lUsaFlag
							SEV->EV_LA    := "S"
						Endif

						(cAlias)->(RestArea(aArea1))
					Endif
					SEV->(MsUnlock())
					FKCOMMIT()
				Endif

				//Pis
				If (M->E2_PIS > 0) .and. (Len(aRatPIS) >= nX) 
					If lGrvSev
						ExecBlock("MULTSEV", .F., .F., { 	nX, cChavePis,;
															aRatIrf[nX][1],;
															aCols[nX][3] / 100,;
															aCols[nX][1] })
						DbSelectArea("SEV")
					Endif
					SEV->(RecLock("SEV", .T.))
					SEV->EV_FILIAL		:= xFilial("SEV")
					SEV->EV_PREFIXO	:= (cAlias)->&(cCampo + "_PREFIXO")
					SEV->EV_NUM			:= (cAlias)->&(cCampo + "_NUM")
					SEV->EV_PARCELA	:= SE2->E2_PARCPIS
					SEV->EV_CLIFOR		:= _cMvUniao
					SEV->EV_LOJA		:= cLojaImp
					SEV->EV_TIPO		:= Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
					SEV->EV_NATUREZ	:= aCols[nX][1] // Grava a natureza
					SEV->EV_VALOR		:= aRatPIS[nX][1]	// Grava o valor informado
					// Grava o percentual (Como indice multiplicador, por esta razao nao
					// multiplica por 100 na gravacao, apenas na exibicao)
					SEV->EV_PERC		:= aCols[nX][3] / 100
					SEV->EV_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
					SEV->EV_RATEICC	:= aCols[nX][4]  // Identificador de Rateio C Custo
					SEV->EV_IDENT		:= "1"  //Rateio de inclusao
					
					//Gravação da chave FK7 para os rateios
					cChaveTit := xFilial(cAlias) 	+ "|" +;
								SEV->EV_PREFIXO	+ "|" +;
								SEV->EV_NUM		+ "|" +;
								SEV->EV_PARCELA	+ "|" +;
								SEV->EV_TIPO		+ "|" +;
								SEV->EV_CLIFOR	+ "|" +;
								SEV->EV_LOJA
					cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

					SEV->EV_IDDOC := cChvImpFK7
					

					If lPadrao .And. !lCtbRatCC .And. aCols[nX][4] != "1" .And. lContabiliza
						dbSelectArea( "SED" )
						MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
						dbSelectArea("SEV")
						If nHdlPrv > 0
							VALOR 	:= 0					// Valor Principal
							VALOR2	:= 0					// Irf
							VALOR3	:= 0					// Inss
							VALOR4	:= 0					// Iss
							VALOR5	:= SEV->EV_VALOR	// Pis
							VALOR6	:= 0					// Cofins
							VALOR7	:= 0					// Csll

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Prepara Lancamento Contabil                                      ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
									aAdd( aFlagCTB, {"EV_LA", "S", "SEV", SEV->( Recno() ), 0, 0, 0} )
								Endif

								nTotal += DetProva( nHdlPrv,;
								                    cPadrao /*cPadrao*/,;
								                    cOrigem /*cPrograma*/,;
								                    cLote,;
								                    /*nLinha*/,;
								                    /*lExecuta*/,;
								                    /*cCriterio*/,;
								                    /*lRateio*/,;
								                    /*cChaveBusca*/,;
								                    /*aCT5*/,;
								                    /*lPosiciona*/,;
								                    @aFlagCTB,;
								                    /*aTabRecOri*/,;
								                    /*aDadosProva*/ )

						Endif

		            If ( nTotal > 0 ) .and. !lUsaFlag
							SEV->EV_LA    := "S"
						Endif

						(cAlias)->(RestArea(aArea1))
					Endif
					SEV->(MsUnlock())
					FKCOMMIT()
				Endif

				//Cofins
				If (M->E2_COFINS > 0) .and. (Len(aRatCOF) >= nX)
					If lGrvSev
						ExecBlock("MULTSEV", .F., .F., { 	nX, cChaveCof,;
															aRatIrf[nX][1],;
															aCols[nX][3] / 100,;
															aCols[nX][1] })
						DbSelectArea("SEV")
					Endif
					SEV->(RecLock("SEV", .T.))
					SEV->EV_FILIAL		:= xFilial("SEV")
					SEV->EV_PREFIXO	:= (cAlias)->&(cCampo + "_PREFIXO")
					SEV->EV_NUM			:= (cAlias)->&(cCampo + "_NUM")
					SEV->EV_PARCELA	:= SE2->E2_PARCCOF
					SEV->EV_CLIFOR		:= _cMvUniao
					SEV->EV_LOJA		:= cLojaImp
					SEV->EV_TIPO		:= Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
					SEV->EV_NATUREZ	:= aCols[nX][1] // Grava a natureza
					SEV->EV_VALOR		:= aRatCOF[nX][1]	// Grava o valor informado
					// Grava o percentual (Como indice multiplicador, por esta razao nao
					// multiplica por 100 na gravacao, apenas na exibicao)
					SEV->EV_PERC		:= aCols[nX][3] / 100
					SEV->EV_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
					SEV->EV_RATEICC	:= aCols[nX][4]  // Identificador de Rateio C Custo
					SEV->EV_IDENT		:= "1"  //Rateio de inclusao
					
					//Gravação da chave FK7 para os rateios
					cChaveTit := xFilial(cAlias) 	+ "|" +;
								SEV->EV_PREFIXO	+ "|" +;
								SEV->EV_NUM		+ "|" +;
								SEV->EV_PARCELA	+ "|" +;
								SEV->EV_TIPO		+ "|" +;
								SEV->EV_CLIFOR	+ "|" +;
								SEV->EV_LOJA
					cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

					SEV->EV_IDDOC := cChvImpFK7

					If lPadrao .And. !lCtbRatCC .And. aCols[nX][4] != "1" .And. lContabiliza
						dbSelectArea( "SED" )
						MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
						dbSelectArea("SEV")
						If nHdlPrv > 0
							VALOR		:= 0					// Valor Principal
							VALOR2	:= 0					// Irf
							VALOR3	:= 0					// Inss
							VALOR4	:= 0					// Iss
							VALOR5	:= 0					// Pis
							VALOR6	:= SEV->EV_VALOR	// Cofins
							VALOR7	:= 0					// Csll

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Prepara Lancamento Contabil                                      ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
									aAdd( aFlagCTB, {"EV_LA", "S", "SEV", SEV->( Recno() ), 0, 0, 0} )
								Endif

								nTotal += DetProva( nHdlPrv,;
								                    cPadrao /*cPadrao*/,;
								                    cOrigem /*cPrograma*/,;
								                    cLote,;
								                    /*nLinha*/,;
								                    /*lExecuta*/,;
								                    /*cCriterio*/,;
								                    /*lRateio*/,;
								                    /*cChaveBusca*/,;
								                    /*aCT5*/,;
								                    /*lPosiciona*/,;
								                    @aFlagCTB,;
								                    /*aTabRecOri*/,;
								                    /*aDadosProva*/ )

						Endif

		            If ( nTotal > 0 ) .and. !lUsaFlag
							SEV->EV_LA    := "S"
						Endif

						(cAlias)->(RestArea(aArea1))
					Endif
					SEV->(MsUnlock())
					FKCOMMIT()
				Endif

				//CSLL
				If (M->E2_CSLL > 0) .and. (Len(aRatCSL) >= nX)
					If lGrvSev
						ExecBlock("MULTSEV", .F., .F., { 	nX, cChaveCSL,;
															aRatIrf[nX][1],;
															aCols[nX][3] / 100,;
															aCols[nX][1] })
						DbSelectArea("SEV")
					Endif
					SEV->(RecLock("SEV", .T.))
					SEV->EV_FILIAL		:= xFilial("SEV")
					SEV->EV_PREFIXO	:= (cAlias)->&(cCampo + "_PREFIXO")
					SEV->EV_NUM			:= (cAlias)->&(cCampo + "_NUM")
					SEV->EV_PARCELA	:= SE2->E2_PARCSLL
					SEV->EV_CLIFOR		:= _cMvUniao
					SEV->EV_LOJA		:= cLojaImp
					SEV->EV_TIPO		:= Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
					SEV->EV_NATUREZ	:= aCols[nX][1] // Grava a natureza
					SEV->EV_VALOR		:= aRatCSL[nX][1]	// Grava o valor informado
					// Grava o percentual (Como indice multiplicador, por esta razao nao
					// multiplica por 100 na gravacao, apenas na exibicao)
					SEV->EV_PERC		:= aCols[nX][3] / 100
					SEV->EV_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
					SEV->EV_RATEICC	:= aCols[nX][4]  // Identificador de Rateio C Custo
					SEV->EV_IDENT		:= "1"  //Rateio de inclusao
					//Gravação da chave FK7 para os rateios
					cChaveTit := xFilial(cAlias) 	+ "|" +;
								SEV->EV_PREFIXO	+ "|" +;
								SEV->EV_NUM		+ "|" +;
								SEV->EV_PARCELA	+ "|" +;
								SEV->EV_TIPO		+ "|" +;
								SEV->EV_CLIFOR	+ "|" +;
								SEV->EV_LOJA
					cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

					SEV->EV_IDDOC := cChvImpFK7

					If lPadrao .And. !lCtbRatCC .And. aCols[nX][4] != "1" .And. lContabiliza
						dbSelectArea( "SED" )
						MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
						dbSelectArea("SEV")
						If nHdlPrv > 0
							VALOR 	:= 0					// Valor Principal
							VALOR2	:= 0					// Irf
							VALOR3	:= 0					// Inss
							VALOR4	:= 0					// Iss
							VALOR5	:= 0					// Pis
							VALOR6	:= 0					// Cofins
							VALOR7	:= SEV->EV_VALOR	// Csll

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Prepara Lancamento Contabil                                      ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
									aAdd( aFlagCTB, {"EV_LA", "S", "SEV", SEV->( Recno() ), 0, 0, 0} )
								Endif

								nTotal += DetProva( nHdlPrv,;
								                    cPadrao /*cPadrao*/,;
								                    cOrigem /*cPrograma*/,;
								                    cLote,;
								                    /*nLinha*/,;
								                    /*lExecuta*/,;
								                    /*cCriterio*/,;
								                    /*lRateio*/,;
								                    /*cChaveBusca*/,;
								                    /*aCT5*/,;
								                    /*lPosiciona*/,;
								                    @aFlagCTB,;
								                    /*aTabRecOri*/,;
								                    /*aDadosProva*/ )

						Endif

		            If ( nTotal > 0 ) .and. !lUsaFlag
							SEV->EV_LA    := "S"
						Endif

						(cAlias)->(RestArea(aArea1))
					Endif
					SEV->(MsUnlock())
					FKCOMMIT()
				Endif

				If (M->E2_INSS > 0) .and. (Len(aRatINS) >= nX)
					If lGrvSev
						ExecBlock("MULTSEV", .F., .F., { 	nX, cChaveIns,;
															aRatIns[nX][1],;
															aCols[nX][3] / 100,;
															aCols[nX][1] })
						DbSelectArea("SEV")
					Endif

					SEV->(RecLock("SEV", .T.))
					SEV->EV_FILIAL		:= xFilial("SEV")
					SEV->EV_PREFIXO	:= (cAlias)->&(cCampo + "_PREFIXO")
					SEV->EV_NUM			:= (cAlias)->&(cCampo + "_NUM")
					SEV->EV_PARCELA	:= SE2->E2_PARCINS
					SEV->EV_CLIFOR		:= _cMvFInss
					SEV->EV_LOJA		:= cLojaImp
					SEV->EV_TIPO		:= If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"INA",MVINSS)
					SEV->EV_NATUREZ	:= aCols[nX][1] // Grava a natureza
					SEV->EV_VALOR		:= aRatIns[nX][1]	// Grava o valor informado
					// Grava o percentual (Como indice multiplicador, por esta razao nao
					// multiplica por 100 na gravacao, apenas na exibicao)
					SEV->EV_PERC		:= aCols[nX][3] / 100
					SEV->EV_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
					SEV->EV_RATEICC	:= aCols[nX][4]  // Identificador de Rateio C Custo
					SEV->EV_IDENT		:= "1"  //Rateio de inclusao
					//Gravação da chave FK7 para os rateios
					cChaveTit := xFilial(cAlias) 	+ "|" +;
								SEV->EV_PREFIXO	+ "|" +;
								SEV->EV_NUM		+ "|" +;
								SEV->EV_PARCELA	+ "|" +;
								SEV->EV_TIPO		+ "|" +;
								SEV->EV_CLIFOR	+ "|" +;
								SEV->EV_LOJA
					cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

					SEV->EV_IDDOC := cChvImpFK7
					

					If lPadrao .And. !lCtbRatCC .And. aCols[nX][4] != "1" .And. lContabiliza
						dbSelectArea( "SED" )
						MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
						dbSelectArea("SEV")
						If nHdlPrv > 0
							VALOR 	:= 0					// Valor Principal
							VALOR2	:= 0					// Irf
							VALOR3	:= SEV->EV_VALOR	// Inss
							VALOR4	:= 0					// Iss
							VALOR5	:= 0					// Pis
							VALOR6	:= 0					// Cofins
							VALOR7	:= 0					// Csll

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Prepara Lancamento Contabil                                      ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
									aAdd( aFlagCTB, {"EV_LA", "S", "SEV", SEV->( Recno() ), 0, 0, 0} )
								Endif

								nTotal += DetProva( nHdlPrv,;
								                    cPadrao /*cPadrao*/,;
								                    cOrigem /*cPrograma*/,;
								                    cLote,;
								                    /*nLinha*/,;
								                    /*lExecuta*/,;
								                    /*cCriterio*/,;
								                    /*lRateio*/,;
								                    /*cChaveBusca*/,;
								                    /*aCT5*/,;
								                    /*lPosiciona*/,;
								                    @aFlagCTB,;
								                    /*aTabRecOri*/,;
								                    /*aDadosProva*/ )

						Endif

		            If ( nTotal > 0 ) .and. !lUsaFlag
							SEV->EV_LA    := "S"
						Endif

						(cAlias)->(RestArea(aArea1))
					Endif
					SEV->(MsUnlock())
					FKCOMMIT()
				Endif
				If (M->E2_ISS > 0) .and. (Len(aRatISS) >= nX)
					If lGrvSev
						ExecBlock("MULTSEV", .F., .F., { 	nX, cChaveIss,;
															aRatIss[nX][1],;
															aCols[nX][3] / 100,;
															aCols[nX][1] })
						DbSelectArea("SEV")
					Endif

					SEV->(RecLock("SEV", .T.))
					SEV->EV_FILIAL		:= xFilial("SEV")
					SEV->EV_PREFIXO	:= (cAlias)->&(cCampo + "_PREFIXO")
					SEV->EV_NUM			:= (cAlias)->&(cCampo + "_NUM")
					SEV->EV_PARCELA	:= SE2->E2_PARCISS
					SEV->EV_CLIFOR		:= _cMvMunic
					SEV->EV_LOJA		:= cLojaImp
					SEV->EV_TIPO		:= MVISS
					SEV->EV_NATUREZ	:= aCols[nX][1] // Grava a natureza
					SEV->EV_VALOR		:= aRatIss[nX][1]	// Grava o valor informado
					// Grava o percentual (Como indice multiplicador, por esta razao nao
					// multiplica por 100 na gravacao, apenas na exibicao)
					SEV->EV_PERC		:= aCols[nX][3] / 100
					SEV->EV_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
					SEV->EV_RATEICC	:= aCols[nX][4]  // Identificador de Rateio C Custo
					SEV->EV_IDENT		:= "1"  //Rateio de inclusao
					//Gravação da chave FK7 para os rateios
					cChaveTit := xFilial(cAlias) 	+ "|" +;
								SEV->EV_PREFIXO	+ "|" +;
								SEV->EV_NUM		+ "|" +;
								SEV->EV_PARCELA	+ "|" +;
								SEV->EV_TIPO		+ "|" +;
								SEV->EV_CLIFOR	+ "|" +;
								SEV->EV_LOJA
					cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

					SEV->EV_IDDOC := cChvImpFK7

					If lPadrao .And. !lCtbRatCC .And. aCols[nX][4] != "1" .And. lContabiliza
						dbSelectArea( "SED" )
						MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
						dbSelectArea("SEV")
						If nHdlPrv > 0
							VALOR 	:= 0					// Valor Principal
							VALOR2	:= 0					// Irf
							VALOR3	:= 0					// Inss
							VALOR4	:= SEV->EV_VALOR	// Iss
							VALOR5	:= 0					// Pis
							VALOR6	:= 0					// Cofins
							VALOR7	:= 0					// Csll

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Prepara Lancamento Contabil                                      ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
									aAdd( aFlagCTB, {"EV_LA", "S", "SEV", SEV->( Recno() ), 0, 0, 0} )
								Endif

								nTotal += DetProva( nHdlPrv,;
								                    cPadrao /*cPadrao*/,;
								                    cOrigem /*cPrograma*/,;
								                    cLote,;
								                    /*nLinha*/,;
								                    /*lExecuta*/,;
								                    /*cCriterio*/,;
								                    /*lRateio*/,;
								                    /*cChaveBusca*/,;
								                    /*aCT5*/,;
								                    /*lPosiciona*/,;
								                    @aFlagCTB,;
								                    /*aTabRecOri*/,;
								                    /*aDadosProva*/ )

						Endif

		            If ( nTotal > 0 ) .and. !lUsaFlag
							SEV->EV_LA    := "S"
						Endif

						(cAlias)->(RestArea(aArea1))
					Endif
					SEV->(MsUnlock())
					FKCOMMIT()
				Endif

				If cPaisLoc == "BRA" .And. (M->E2_CIDE > 0) .and. (Len(aRatCid) >= nX)
					If lGrvSev
						ExecBlock("MULTSEV", .F., .F., { 	nX, cChaveCid,;
															aRatCid[nX][1],;
															aCols[nX][3] / 100,;
															aCols[nX][1] })
						DbSelectArea("SEV")
					Endif

					SEV->(RecLock("SEV", .T.))
					SEV->EV_FILIAL		:= xFilial("SEV")
					SEV->EV_PREFIXO		:= (cAlias)->&(cCampo + "_PREFIXO")
					SEV->EV_NUM			:= (cAlias)->&(cCampo + "_NUM")
					SEV->EV_PARCELA		:= SE2->E2_PARCCID
					SEV->EV_CLIFOR		:= _cMvFCide
					SEV->EV_LOJA		:= cLojaImp
					SEV->EV_TIPO		:= "CID"
					SEV->EV_NATUREZ		:= aCols[nX][1] // Grava a natureza
					SEV->EV_VALOR		:= aRatCid[nX][1]	// Grava o valor informado
					// Grava o percentual (Como indice multiplicador, por esta razao nao
					// multiplica por 100 na gravacao, apenas na exibicao)
					SEV->EV_PERC		:= aCols[nX][3] / 100
					SEV->EV_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
					SEV->EV_RATEICC		:= aCols[nX][4]  // Identificador de Rateio C Custo
					SEV->EV_IDENT		:= "1"  //Rateio de inclusao
					//Gravação da chave FK7 para os rateios
					cChaveTit := xFilial(cAlias) 	+ "|" +;
								SEV->EV_PREFIXO	+ "|" +;
								SEV->EV_NUM		+ "|" +;
								SEV->EV_PARCELA	+ "|" +;
								SEV->EV_TIPO		+ "|" +;
								SEV->EV_CLIFOR	+ "|" +;
								SEV->EV_LOJA
					cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

					SEV->EV_IDDOC := cChvImpFK7

					If lPadrao .And. !lCtbRatCC .And. aCols[nX][4] != "1" .And. lContabiliza
						dbSelectArea( "SED" )
						MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
						dbSelectArea("SEV")
						If nHdlPrv > 0
							VALOR 	:= 0					// Valor Principal
							VALOR2	:= 0					// Irf
							VALOR3	:= 0					// Inss
							VALOR4	:= 0					// Iss
							VALOR5	:= 0					// Pis
							VALOR6	:= 0					// Cofins
							VALOR7	:= 0					// Csll

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Prepara Lancamento Contabil                                      ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
									aAdd( aFlagCTB, {"EV_LA", "S", "SEV", SEV->( Recno() ), 0, 0, 0} )
								Endif

								nTotal += DetProva( nHdlPrv,;
								                    cPadrao /*cPadrao*/,;
								                    cOrigem /*cPrograma*/,;
								                    cLote,;
								                    /*nLinha*/,;
								                    /*lExecuta*/,;
								                    /*cCriterio*/,;
								                    /*lRateio*/,;
								                    /*cChaveBusca*/,;
								                    /*aCT5*/,;
								                    /*lPosiciona*/,;
								                    @aFlagCTB,;
								                    /*aTabRecOri*/,;
								                    /*aDadosProva*/ )

						Endif

		            If ( nTotal > 0 ) .and. !lUsaFlag
							SEV->EV_LA    := "S"
						Endif

						(cAlias)->(RestArea(aArea1))
					Endif
					SEV->(MsUnlock())
					FKCOMMIT()
				Endif
								
			Endif
		ElseIf Len(aRegs) >= nX
			DbGoto(aRegs[nX])

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Apaga os lancamentos gerados no PCO a partir do rateio por multi-natureza (05) ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (cAlias)-> &(cCampo + "_MULTNAT") == "1"	// Campo multi-natureza igual a "Sim"
				If cAlias == "SE1"
					PCODetLan( "000001", "04", "FINA040", .T. )
				Else
					PCODetLan( "000002", "04", "FINA050", .T. )
				EndIf
    		EndIf

			RecLock("SEV", .F. )
			DbDelete()
			MsUnLock()
			If lGrvSev
				ExecBlock("MULTSEV", .F., .F., { 	nX, SEV->EV_PREFIXO +;
													SEV->EV_NUM + SEV->EV_PARCELA +;
													SEV->EV_TIPO + SEV->EV_CLIFOR + SEV->EV_LOJA, 0, 0, "" })
				DbSelectArea("SEV")
			Endif

			If Select("SEZTMP") > 0 .And. aCols[nX][4] == "1" // Possui rateio c.Custo
				dbSelectArea("SEZTMP")
				// busca natureza no arquivo TMP de Mult Nat C.Custo
				If dbSeek(aCols[nX][1])
					While !Eof() .and. SEZTMP->EZ_NATUREZ == aCols[nX][1]
						If SEZTMP->EZ_RECNO > 0
							SEZ->(DbGoto(SEZTMP->EZ_RECNO))
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Apaga o lancamento no PCO com os dados do lancamento de multi-natureza (05) ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					    	If cAlias == "SE1"
								PCODetLan( "000001", "05", "FINA040", .T. )
							Else
								PCODetLan( "000002", "05", "FINA050", .T. )
							EndIf
							SEZ->(RecLock("SEZ",.F.))
							SEZ->(DbDelete())
							SEZ->(MsUnlock())
							If lGrvSez
								ExecBlock("MULTSEZ", .F., .F., { nOpc, SEZ->EZ_PREFIXO +;
								SEZ->EZ_NUM + SEZ->EZ_PARCELA +;
								SEZ->EZ_TIPO + SEZ->EZ_CLIFOR + SEZ->EZ_LOJA } )
								DbSelectArea("SEZ")
							Endif
	                  	Endif
						dbSelectArea("SEZTMP")
						DbSkip()
	          		Enddo
	     		Endif
			EndIf
		EndIf
	Next
	DbSelectArea("SEV")
	DbGoBottom()
	DbSkip()

ElseIf nOpc == 3
	Reclock(cAlias)
		Replace (cAlias)->&(cCampo + "_MULTNAT") With "2"
	MsUnlock()
ElseIf nOpca == 0 .AND. nOpc == 4
	If Select("SEZTMP") > 0
		FINXDETMP()
	EndIf
EndIf

SX3->(DbSetOrder(1))
RestArea(aArea)
(cAlias)->(RestArea(aArea1))

//Se existir temporario para rateio c. custo, deleta
If lGrava .And. Select("SEZTMP") > 0
	FINXDETMP()
Endif

If nOpca == 0
	//zera o acols p/ não gavar valores incorretos caso seja confirm alterações no títlulo
	aCols := {}
Else
	aColsM 	 := AClone(aCols)
EndIf

aHeaderM := AClone(aHeader)
// Zera as variaveis de contabilizacao para nao ocorrer duplicidade em outra chamada a DetProva
VALOR	 := 0
VALOR2 := 0
VALOR3 := 0
VALOR4 := 0
VALOR5 := 0					// Pis
VALOR6 := 0					// Cofins
VALOR7 := 0					// Csll

Return ( lResult ) /*Function MultNat*/


//-------------------------------------------------------------------
/*/{Protheus.doc} MULTNAT2

Distribui o valor do titulo em varias naturezas (FINA050).
Arquivo original: FINXFUN.PRX 

@author Claudio D Souza
@since 22/05/2001
/*/
//-------------------------------------------------------------------
Function MultNat2(cAlias,nOpc,nImpostos,lRatImpostos,aColsParam, aHeaderParam,  lMostraTela)

LOCAL aCampos	:= { "EV_NATUREZ", "EV_VALOR", "EV_PERC", "EV_RATEICC" } 	// Indica quais campos serao exbididos na GetDados e na ordem que devem aparecer
LOCAL cCampo    := Right(cAlias,2)
LOCAL nX		:= 0
LOCAL bTit      := { |cChave| SX3->(DbSetOrder(2)), SX3->(DbSeek(cChave)), X3Titulo() }
LOCAL oDlg		:= NIL
LOCAL oGet		:= NIL
LOCAL aArea  	:= GetArea()
LOCAL aArea1 	:= (cAlias)->(GetArea())
lOCAL aAreaSED	:= SED->(GetArea())
LOCAL cPic  	:= PesqPict("SE2","E2_VALOR",19)
LOCAL nTotSev	:= nTotSez := nPerSev := nPerSez := 0
LOCAL lRtNattel := Existblock("RTNATTEL")
LOCAL aButton	:= {}
LOCAL lValF050	:= .T.
LOCAL lF050VCMN := ExistBlock("F050VCMN")
LOCAL lPanelFin := .T.
LOCAL lRet		:= .T.
LOCAL aColsUser :={}

PRIVATE aCols	:= {}
PRIVATE aHeader	:= {}
PRIVATE oValDist := NIL
PRIVATE nValDist := 0
PRIVATE nVlTit	:= 0	 
PRIVATE aTit	:= {}
PRIVATE nOpcA	:= 0
PRIVATE oValFal := NIL
PRIVATE oPerFal := NIL
PRIVATE nValFal	:= 0
PRIVATE nPerFal	:= 100
PRIVATE lCC		:= .F.

DEFAULT nOpc := 3
DEFAULT nImpostos := 0
DEFAULT lRatImpostos := .F.
DEFAULT aColsParam := {}
DEFAULT aHeaderParam := {}
DEFAULT lMostraTela	:= .T.

//Converte o valor dos impostos para a moeda do titulo
If nImpostos > 0
	nImpostos := FMNCvMoed(cCampo, nImpostos)
EndIf

If nOpc # 3
	Aadd(aButton, {'S4WB013N',{||MulNatCC(nOpc) },STR0007,STR0007} ) //"Rateio Centro de Custo"###"Rateio"
	nVlTit	:= M->&(cCampo + "_VALOR") + nImpostos // Valor do titulo
Else
	nVlTit	:= M->&(cCampo + "_VALOR") + nImpostos // Valor do titulo
Endif
nValFal 	:= M->&(cCampo + "_VALOR") + nImpostos // Valor do titulo

__OPC 	:= nOpc

//Obtm a picture do campo EV_PERC ajustado de indice para percentual
cPictPerc		:= FPictPerc()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Montagem da matriz aHeader e aCampos						 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

SEV->(dbSetOrder(2))
If (nOpc # 3 .And. 	Len(aColsParam) = 0 .and. ;
	SEV->(MsSeek(	xFilial("SEV")+;
					(cAlias)->&(cCampo + "_PREFIXO")+;
					(cAlias)->&(cCampo + "_NUM")+;
		  		    (cAlias)->&(cCampo + "_PARCELA")+;
					(cAlias)->&(cCampo + "_TIPO")+;
					(cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))+;
					(cAlias)->&(cCampo + "_LOJA")+;
					"1")))		//1=Inclusao

	While SEV->EV_FILIAL + SEV->EV_PREFIXO + SEV->EV_NUM +;
		  	SEV->EV_PARCELA + SEV->EV_TIPO + SEV->EV_CLIFOR +;
			SEV->EV_LOJA+SEV->EV_IDENT == xFilial("SEV")+;
			(cAlias)->&(cCampo + "_PREFIXO")+;
			(cAlias)->&(cCampo + "_NUM")+;
		  	(cAlias)->&(cCampo + "_PARCELA")+;
			(cAlias)->&(cCampo + "_TIPO")+;
			(cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))+;
			(cAlias)->&(cCampo + "_LOJA")+;
			"1"	//1 = Inclusao

		Aadd(aCols,Array(Len(aCampos)+1))
		If Len(aCols) = 1
			For nX := 1 To Len(aCampos)
				SX3->(dbSeek(Pad(aCampos[nX],10)))
				Aadd(aHeader,{ AllTrim(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT } )
				If Alltrim(aHeader[nX][2]) == "EV_PERC" // Percentual
					aHeader[nX][6] := "MNatCalcV()"
					// Inclui em aCols como caracter para ser possivel a visualizacao na
					// tela, por ser a ultima coluna da getdados
					aHeader[nX][8] := "N"
					aHeader[nX][5] := 2
					aHeader[nX][3] := cPictPerc
				ElseIf Alltrim(aHeader[nX][2]) == "EV_VALOR"
					aHeader[nX][6] := "MNatCalcP()"
				ElseIf Alltrim(aHeader[nX][2]) == "EV_NATUREZ"
					aHeader[nX][6] := 'ExistCpo("SED") .And. MNatAltN()'
				Endif
			Next
		Endif

		aCols[Len(aCols)][1] := SEV->EV_NATUREZ
		aCols[Len(aCols)][2] := Round(NoRound(nVlTit * SEV->EV_PERC, 3), 2)
		aCols[Len(aCols)][3] := SEV->EV_PERC * 100
		aCols[Len(aCols)][4] := SEV->EV_RATEICC
		aCols[Len(aCols)][Len(aCampos)+1] := .F.

		nTotSev += aCols[Len(aCols)][2]
		nPerSev += SEV->EV_PERC * 100

		Aadd(aRegs, SEV->(Recno()))
		nValDist := nVlTit
		nValFal	:= 0
		nPerFal	:= 0

		SEV->(DbSkip())
	EndDo

	If nTotSev # nVlTit .Or. nPerSev # 100
		aCols[Len(aCols)][2] += nVlTit - nTotSev
		aCols[Len(aCols)][3] := aCols[Len(aCols)][3] + 100 - nPerSev
	Endif

	dbSetOrder(1)
	SEZ->(dbSetOrder(1))
	SEZ->(MsSeek(xFilial("SEZ")+;
					(cAlias)->&(cCampo + "_PREFIXO")+;
					(cAlias)->&(cCampo + "_NUM")+;
					(cAlias)->&(cCampo + "_PARCELA")+;
					(cAlias)->&(cCampo + "_TIPO")+;
					(cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))+;
					(cAlias)->&(cCampo + "_LOJA")))

	While 	SEZ->EZ_FILIAL + SEZ->EZ_PREFIXO + SEZ->EZ_NUM +;
		  	SEZ->EZ_PARCELA + SEZ->EZ_TIPO + SEZ->EZ_CLIFOR +;
			SEZ->EZ_LOJA == xFilial("SEZ")+;
			(cAlias)->&(cCampo + "_PREFIXO")+;
			(cAlias)->&(cCampo + "_NUM")+;
		  	(cAlias)->&(cCampo + "_PARCELA")+;
			(cAlias)->&(cCampo + "_TIPO")+;
			(cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))+;
			(cAlias)->&(cCampo + "_LOJA")

		//Descarto rateios que nao sao de inclusao
		If SEZ->EZ_IDENT != "1"
			SEZ->(dbskip())
			Loop
		Endif

		RecLock("SEZTMP", .T.)
		nPos := Ascan(aCols, { |x| x[1] = SEZ->EZ_NATUREZ })
		SEZTMP->EZ_NATUREZ	:= SEZ->EZ_NATUREZ
		SEZTMP->EZ_CCUSTO	:= SEZ->EZ_CCUSTO
		SEZTMP->EZ_ITEMCTA	:= SEZ->EZ_ITEMCTA
		SEZTMP->EZ_CLVL   	:= SEZ->EZ_CLVL
		SEZTMP->EZ_VALOR	:= Round(NoRound(SEZ->EZ_VALOR,3),2)
		SEZTMP->EZ_PERC		:= SEZ->EZ_PERC
		SEZTMP->EZ_RECNO	:= SEZ->(Recno())
		// Carregamento dos campos de novas entidades
		For nX:= 1 to Len(aCposDB)
			cCpoEC := aCposDB[nX][1]
			If "EZ_EC0" $ Alltrim(cCpoEC) 
				SEZTMP->(&cCpoEC) := SEZ->(&cCpoEC)	
			EndIf
		Next nX
		nTotSez += SEZTMP->EZ_VALOR
		nPerSez += SEZTMP->EZ_PERC
		MsUnLock()
		SEZ->(DbSkip())
	Enddo

ElseIf nOpc # 3
	aCols 	:= AClone(aColsParam)
	aHeader := AClone(aHeaderParam)
Endif

If nOpc = 3 .Or. Len(aCols) = 0
	dbSelectArea("SX3")
	dbSetOrder(1)
	dbSeek("SEV")
	nX := 1
	While ! SX3->(EOF()) .And. (SX3->X3_Arquivo == "SEV")
		If X3USO(SX3->X3_Usado) .And. cNivel >= SX3->X3_NIVEL .and. !(AllTrim(SX3->X3_CAMPO) $ "EV_IDDOC|EV_PORCENT")
			If nX == 1
				nRecnoSx3 := SX3->(Recno())
				Aadd(aCols,Array(Len(aCampos)))
				// Adiciona os campos na ordem em que devem aparecer
				For nX := 1 To Len(aCampos)
					SX3->(DbSetOrder(2))
					SX3->(MsSeek(Pad(aCampos[nX],10)))
					Aadd(aHeader,{ AllTrim(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT } )
					If SX3->X3_TIPO == "C"                                  
						If Alltrim(SX3->X3_CAMPO) == "EV_NATUREZ" .and. !('EXISTCPO("SED")'$ Upper(aHeader[nX][6])) // Natureza
							aHeader[nX][6] := "existcpo('SED').and." + aHeader[nX][6]							
						Endif
						aCols[1][nX] := CriaVar(SX3->X3_CAMPO)
					Else
						If Alltrim(SX3->X3_CAMPO) == "EV_PERC" // Percentual
							aHeader[nX][6] := "MNatCalcV()"
							// Inclui em aCols como caracter para ser possivel a visualizacao na
							// tela, por ser a ultima coluna da getdados
							aHeader[nX][8]	:= "N"
							aHeader[nX][5]	:= 2
							aHeader[nX][3]	:= cPictPerc
							aCols[1][nX]	:=  CriaVar("EV_PERC")
						ElseIf Alltrim(SX3->X3_CAMPO) == "EV_VALOR"
							aCols[1][nX] := CriaVar("EV_VALOR")
							aHeader[nX][6] := "MNatCalcP()"
						Else
							aCols[1][nX] := CriaVar(SX3->X3_CAMPO)
						Endif
					EndIf
				Next
				SX3->(DbSetOrder(1))
				SX3->(DbGoto(nRecnoSx3))
				// Adiciona os demais campos
				If Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim(SX3->X3_CAMPO) } )  == 0
					Aadd(aHeader,{ AllTrim(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT } )
					Aadd(aCols[1], CriaVar(SX3->X3_CAMPO))
				Endif
			Else
				// Adiciona os demais campos
				If Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim(SX3->X3_CAMPO) } )  == 0
					Aadd(aHeader,{ AllTrim(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT } )
					If Alltrim(SX3->X3_CAMPO) == "EV_NATUREZ" .and. !('EXISTCPO("SED")'$ Upper(aHeader[nX][6])) // Natureza
						aHeader[nX][6] := "existcpo('SED').and." + aHeader[nX][6]							
					Endif	
					Aadd(aCols[1], CriaVar(SX3->X3_CAMPO))
				Endif
			Endif
		Endif
		SX3->(DbSkip())
	End
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Adiciona mais um elemento em aCOLS, indicando se a   ³
	//³ a linha esta ou nao deletada						 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Aadd(aCols[1], .F.)
Endif

IF lRtNattel
	Execblock("RTNATTEL",.f.,.f.)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de entrada para carregar regra de rateio especifica   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If __lNatSevLoad .And. nOpc==3
	If ValType(aColsUser:=ExecBlock("NATSEVLOAD",.F.,.F.,{aCols,aHeader})) == "A"
		aCols:=aClone(aColsUser)
	Endif
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Mostra o corpo da rateio 									 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nOpca := 0
// Cria os titulos do dialogo
Aadd( aTit, Eval(bTit, cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE")))
Aadd( aTit, Eval(bTit, cCampo + "_LOJA"))
Aadd( aTit, Eval(bTit, cCampo + "_PREFIXO"))
Aadd( aTit, Eval(bTit, cCampo + "_NUM"))
Aadd( aTit, Eval(bTit, cCampo + "_PARCELA"))
Aadd( aTit, Eval(bTit, cCampo + "_VALOR" ))
Aadd( aTit, cAlias)

If lMostraTela

	While .T.
		aSize := MSADVSIZE()
		DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0010) From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL		//"Naturezas por titulo"	
		oDlg:lMaximized := .T.

		oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20,.T.,.T. )
		oPanel:Align := CONTROL_ALIGN_TOP

		@  001, 005 To  018,247 OF oPanel PIXEL
		@  001, 250 To  018,495 OF oPanel PIXEL

		@  005 , 010	Say aTit[1] + M->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))	FONT oDlg:oFont OF oPanel Pixel
		@  005 , 100	Say aTit[2] + M->&(cCampo + "_LOJA")    	FONT oDlg:oFont	OF oPanel  Pixel
		@  005 , 257	Say aTit[3] + M->&(cCampo + "_PREFIXO") 	FONT oDlg:oFont	OF oPanel  Pixel
		@  005 , 297	Say aTit[4] + M->&(cCampo + "_NUM")	 	FONT oDlg:oFont	OF oPanel  Pixel
		@  005 , 367	Say aTit[5] + M->&(cCampo + "_PARCELA") 	FONT oDlg:oFont	OF oPanel  Pixel

		oPanel2 := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,40,40,.T.,.T. )

		If !lPanelFin
			oPanel2:Align := CONTROL_ALIGN_BOTTOM
		Endif

		@ 001, 005 To 035,247 OF oPanel2 PIXEL
		@ 001, 250 To 035,495 OF oPanel2 PIXEL

		@ 005, 010  Say aTit[6] FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10
		@ 005, 076  Say nVlTit	PICTURE cPic FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10

		@ 005, 257  Say STR0011 FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10		//"Valor a Distribuir"
		@ 005, 357  Say oValFal VAR nValFal PICTURE cPic	FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10

		@ 018, 010  Say OemToAnsi(STR0015) FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10		//"Total Distribuido: " 
		@ 018, 076  Say oValDist VAR nValDist PICTURE cPic	FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10

		@ 018, 257  Say STR0012 FONT oDlg:oFont OF oPanel2 PIXEL SIZE 90,10		//"Percentual a Distribuir"
		@ 018, 357  Say oPerFal VAR nPerFal PICTURE cPictPerc SIZE 50,10 FONT oDlg:oFont OF oPanel2 PIXEL //"@E 999.9999999"

		oGet := MSGetDados():New(34,5,128,315,nOpc,"MNatLinOk", "AllwaysTrue",,nOpc # 2,,,,999)		
		oGet:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

		If Funname() $ "FINA703|FINA050|FINA750|MATA121" .Or. FINXFIND(Funname()) // contas a pagar
			If lPanelFin
				ACTIVATE MSDIALOG oDlg ON INIT (FaMyBar(oDlg,{||nOpca:=1,If(oGet:TudoOk() .And. FaMNatOk() .And. IIF(lF050VCMN,lValF050 := ExecBlock("F050VCMN"),.T.),oDlg:End(),nOpca := 0)},;
							{|| nOpcA:=0,IIF(!lF050VCMN,oDlg:End(),IIF(lValF050 := ExecBlock("F050VCMN"),oDlg:End(),.T.))},aButton),	oPanel2:Align := CONTROL_ALIGN_BOTTOM)

			Else
				ACTIVATE MSDIALOG oDlg ON INIT (EnchoiceBar(oDlg,{||nOpca:=1,If(oGet:TudoOk() .And. FaMNatOk() .And. IIF(lF050VCMN,lValF050 := ExecBlock("F050VCMN"),.T.),oDlg:End(),nOpca := 0)},;
							{|| nOpcA:=0,IIF(!lF050VCMN,oDlg:End(),IIF(lValF050 := ExecBlock("F050VCMN"),oDlg:End(),.T.))},,aButton),	oPanel2:Align := CONTROL_ALIGN_BOTTOM)

			Endif

			If lValF050
				Exit
			Else
				Loop
			EndIf
		ElseIf Funname() $ "FINA704|FINA040|FINA740" // contas a receber
		
			If lPanelFin
				ACTIVATE MSDIALOG oDlg ON INIT (FaMyBar(oDlg,{||nOpca:=1,If(oGet:TudoOk() .And. FaMNatOk() ,oDlg:End(),nOpca := 0)},;
							{|| nOpcA:=0,oDlg:End() },aButton),	oPanel2:Align := CONTROL_ALIGN_BOTTOM)
	
			Else
				ACTIVATE MSDIALOG oDlg ON INIT (EnchoiceBar(oDlg,{||nOpca:=1,If(oGet:TudoOk() .And. FaMNatOk() ,oDlg:End(),nOpca := 0)},;
							{|| nOpcA:=0,oDlg:End() },,aButton),	oPanel2:Align := CONTROL_ALIGN_BOTTOM)
	
			Endif		
			Exit
		EndIf

	EndDo

Else
	nOpcA := 1
Endif

SX3->(DbSetOrder(1))
RestArea(aArea)
(cAlias)->(RestArea(aArea1))
SED->(RestArea(aAreaSED))
If nOpcA == 1
	aColsParam		:= AClone(aCols)
	aColsSev		:= AClone(aCols)
	aHeaderParam	:= AClone(aHeader)
	aHeaderSev		:= AClone(aHeader)
	lCloseTbl := .F.
Else
	aColsParam		:= {}
	aColsSev		:= {}
	aHeaderParam	:= {}
	aHeaderSev		:= {}
	If cCampo == "E2"
		M->E2_MULTNAT   := "2"	//Volta o campo Multipla Natureza para o status "2-Nao"
	Else
		M->E1_MULTNAT   := "2"	//Volta o campo Multipla Natureza para o status "2-Nao"
	Endif
	lRet := .F.
	lCloseTbl := .T.
Endif
// Zera as variaveis de contabilizacao para nao ocorrer duplicidade em outra chamada a DetProva
VALOR  := 0
VALOR2 := 0
VALOR3 := 0
VALOR4 := 0
VALOR5 := 0					// Pis
VALOR6 := 0					// Cofins
VALOR7 := 0					// Csll

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} MULTNATC

Distribui o valor do titulo em varias naturezas na Baixa (Gravação).
Arquivo original: FINXFUN.PRX 

@author Mauricio Pequim Jr.
@since 22/05/2001
/*/
//-------------------------------------------------------------------
Function MultNatC(cAlias,nHdlPrv,nTotal,cArquivo,lContabiliza,lBxLote,cReplica,nTotLtEZ,lOk,aCols,lBaixou,aGrvLctPco,lUsaFlag,aFlagCTB)
LOCAL cCampo		:= Right(cAlias,2)
LOCAL cPadrao		:= If(cAlias == "SE1", Fa070Pad(), IIf(Empty(SE2->E2_NUMBOR), "530", "532"))
LOCAL lPadrao 		:= VerPadrao(cPadrao)
LOCAL cPadraoCC		:= If(cAlias=="SE1","536","537")
LOCAL lPadraoCC		:= VerPadrao(cPadraoCC)
LOCAL cOrigem		:= If(cAlias=="SE1","FINA070","FINA080")
LOCAL nX
LOCAL aArea  		:= GetArea()
LOCAL aArea1 		:= (cAlias)->(GetArea())
LOCAL lCtbRatCC 	:= .F.  // Controle de contabilizacao por Rateio C.Custo
LOCAL nVlTit		:= If(cAlias == "SE1", nValRec,nValPgto)
LOCAL aGrvSEZPco 	:= {}
Local aStruSez 		:= SEZ->(DbStruct())
Local lCobMulNat 	:= FwIsInCallStack("fA200Ger") .And. FwIsInCallStack("MultNatC") .And. Len(aCols) > 1 .And. cPadrao == "528"
Local cChaveBx		:= ""
Local cChaveTit		:= ""
Local cCpoSeq		:= ""
Local cCpoMoed		:= ""
Local _lMultnatC    := ExistBlock("MULTNATC")

If !lPadrao .and. lPadraoCC .and. cPadraoCC $ "536|537"
	lPadrao := lPadraoCC
Endif

PRIVATE lCC			:= .F.
DEFAULT nTotLtEZ	:= 0		//Totalizador Bx Lote
DEFAULT aGrvLctPco := {}

If lOk .and. lBaixou //Se foi confirmada a ddistribuicao de multiplas naturezas
	
	//Gravacao da chave de baixa para os rateios
	If cAlias == "SE1"	
		cChaveTit := xFilial("SE1",SE1->E1_FILORIG) + "|" +;
					SE1->E1_PREFIXO	+ "|" +;
					SE1->E1_NUM		+ "|" +;
					SE1->E1_PARCELA	+ "|" +;
					SE1->E1_TIPO	+ "|" +;
					SE1->E1_CLIENTE	+ "|" +;
					SE1->E1_LOJA
		
		cCpoSeq		:= FK1->FK1_SEQ
		cCpoMoed	:= FK1->FK1_MOEDA
	Else
		cChaveTit := xFilial("SE2",SE2->E2_FILORIG) + "|" +;
					SE2->E2_PREFIXO	+ "|" +;
					SE2->E2_NUM		+ "|" +;
					SE2->E2_PARCELA	+ "|" +;
					SE2->E2_TIPO	+ "|" +;
					SE2->E2_FORNECE	+ "|" +;
					SE2->E2_LOJA
		
		cCpoSeq		:= FK2->FK2_SEQ
		cCpoMoed	:= FK2->FK2_MOEDA
	EndIf

	cChaveBx := FindBxKey(cAlias,cChaveTit, cCpoSeq)
	
	DbSelectArea(cAlias)
	SE2->(DbSetOrder(1))
	
	// Grava todas as naturezas e valores informados
	DbSelectArea("SEV")
	// Marca que ja foi contabilizado para nao contabilizar duas vezes, pois eh utilizado
	// o mesmo lancamento padrao
	nCont := 0
	For nX := 1 To Len(aCols)
	   // Se a linha de aCols nao estiver deletada e o registro nao for
		// encontrado no SEV
		lCtbRatCC := .F.
		If	!aCols[nX][Len(aCols[nX])]
			RecLock("SEV", .T. )
			SEV->EV_FILIAL   := xFilial("SEV")
			SEV->EV_PREFIXO  := (cAlias)->&(cCampo + "_PREFIXO")
			SEV->EV_NUM      := (cAlias)->&(cCampo + "_NUM")
			SEV->EV_PARCELA  := (cAlias)->&(cCampo + "_PARCELA")
			SEV->EV_CLIFOR   := (cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))
			SEV->EV_LOJA     := (cAlias)->&(cCampo + "_LOJA")
			SEV->EV_TIPO     := (cAlias)->&(cCampo + "_TIPO")
			SEV->EV_NATUREZ  := aCols[nX][1] // Grava a natureza
			SEV->EV_VALOR    := aCols[nX][2] // Grava o valor informado
			// Grava o percentual (Como indice multiplicador, por esta razao nao
			// multiplica por 100 na gravacao, apenas na exibicao)
			SEV->EV_PERC     := (aCols[nX][3] / 100)
			SEV->EV_RECPAG   := If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
			SEV->EV_RATEICC  := aCols[nX][4]  // Identificador de Rateio C Custo
			SEV->EV_IDENT	:= "2"   //rateio de baixa
			SEV->EV_SEQ		:= cCpoSeq
			SEV->EV_IDDOC	:= cChaveBx
			MsUnLock()

				AtuSldNat(SEV->EV_NATUREZ,; 										// 1 - Codigo da natureza em que o saldo sera atualizado
							dBaixa,;													// 2 - Data em que o saldo deve ser atualizado
							cCpoMoed,;													// 3 - Codigo da moeda do saldo
							"3",;														// 4 - Tipo de saldo (1=Orcado, 2=Previsto, 3=Realizado)
							SEV->EV_RECPAG,;											// 5 - Codigo da carteira (P=Pagar, R=Receber)
							SEV->EV_VALOR,;											// 6 - Valor que atualizara o saldo na moeda do saldo
							SEV->EV_PERC * nVlTit,;									// 7 - Valor que atualizara o saldo na moeda corrente
							If(SE5->E5_TIPO $ MVPAGANT+"/"+MV_CPNEG,"-","+"),;	// 8 - Sinal para atualizacao (+) ou (-)
							,;															// 9 - Saldo a ser atualizado (D = Diario, M = Mensal, NIL = Ambos	(importante apenas no recalculo)
							FunName(),;												// 10 - Rotina de Origem do movimento de fluxo de caixa. Ex. FUNNAME()
							"SEV",;													// 11 - Alias onde ocorreu a movimentação de fluxo de caixa. Ex. SE2
							SEV->(Recno()),;											// 12 - Número do registro no alias onde ocorreu a movimentação de fluxo de caixa.
							0 )
			If aCols[nX][4] $ "1"
				lCC := .T.
			EndIf

			If ! Empty(aGrvLctPco)
				aGrvSEVPco := aGrvLctPco[1]
    			/*
				aGrvSEVPco[1] = Cod.Processo
				aGrvSEVPco[2] = Item Processo
				aGrvSEVPco[3] = Programa
				*/
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				PcoDetLan(aGrvSEVPco[1],aGrvSEVPco[2],aGrvSEVPco[3])
			EndIf

			If !SE5->(EOF()) .And. SE5->E5_MULTNAT <> "1"
				Reclock("SE5",.F.)
				SE5->E5_MULTNAT := "1"
				SE5->(MsUnlock())
			EndIf

			SEZ->(dbSetOrder(4))
			If Select("SEZTMP") > 0 .And. aCols[nX][4] == "1" .and.;   // Possui rateio c.Custo
        		!(SEZ->(MsSeek(xFilial("SEZ")+;
				(cAlias)->&(cCampo + "_PREFIXO")+;
				(cAlias)->&(cCampo + "_NUM")+;
				(cAlias)->&(cCampo + "_PARCELA")+;
				(cAlias)->&(cCampo + "_TIPO")+;
				(cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))+;
				(cAlias)->&(cCampo + "_LOJA")+;
				aCols[nX][1]+"2"+SEV->EV_SEQ)))

				//Gravacao dos dados do rateio C.custo
				dbSelectArea("SEZTMP")

				// busca natureza no arquivo TMP de Mult Nat C.Custo
				If dbSeek(aCols[nX][1])
					nCont ++
					
					While !Eof() .and. SEZTMP->EZ_NATUREZ == aCols[nX][1]
						VALOR 	:= SEZ->EZ_VALOR		// Valor Principal
						If !(SEZTMP->EZ_FLAG)
							SEZ->(RecLock("SEZ",.T.))

							// Carregamento dos campos de novas entidades contabeis e campos especificos
							aEval(aStruSez, {|e,ni| If(Alltrim(e[2]) != "EV_PERC", SEZ->(FieldPut(FieldPos(e[1]),SEZTMP->(FieldGet(FieldPos(e[1]))))), Nil) } )

							SEZ->EZ_FILIAL		:= xFilial("SEZ")
							SEZ->EZ_PREFIXO		:= (cAlias)->&(cCampo + "_PREFIXO")
							SEZ->EZ_NUM			:= (cAlias)->&(cCampo + "_NUM")
							SEZ->EZ_PARCELA		:= (cAlias)->&(cCampo + "_PARCELA")
							SEZ->EZ_CLIFOR		:= (cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))
							SEZ->EZ_LOJA		:= (cAlias)->&(cCampo + "_LOJA")
							SEZ->EZ_TIPO		:= (cAlias)->&(cCampo + "_TIPO")
							SEZ->EZ_NATUREZ		:= aCols[nX][1] // Grava a natureza
							SEZ->EZ_VALOR		:= SEZTMP->EZ_VALOR // Grava o valor informado
							SEZ->EZ_PERC		:= SEZTMP->EZ_PERC
							SEZ->EZ_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
							SEZ->EZ_CCUSTO		:= SEZTMP->EZ_CCUSTO  // Centro de Custo
							SEZ->EZ_ITEMCTA		:= SEZTMP->EZ_ITEMCTA  // Item
							SEZ->EZ_CLVL		:= SEZTMP->EZ_CLVL     // Classe de Valor
							SEZ->EZ_IDENT		:= "2"   //rateio de baixa
							SEZ->EZ_SEQ			:= cCpoSeq
							SEZ->EZ_CONTA		:= SEZTMP->EZ_CONTA
							SEZ->EZ_IDDOC		:= cChaveBx

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Ponto de entrada antes da contabilizacao.           ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If _lMultnatC
								ExecBlock("MULTNATC",.F.,.F.)
							EndIf

							// Contabilizacao das MultiNat com Rateio C.Custo
							// Somente sera contabilizado se existir o LP 500/510 e o 506/508 ou
							// LP 520/530 e 536/537 se for baixa
							If lPadrao .and. lPadraoCC .And. aCols[nX][4] == "1" .And. lContabiliza
								If lBxLote
									nTotLtEZ += SEZ->EZ_VALOR
									VALOR 	:= 0
								Else
									VALOR 	:= SEZ->EZ_VALOR		// Valor Principal
								Endif
								// Contabiliza pelo SEZ
								If nHdlPrv <= 0
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Inicializa Lancamento Contabil                                   ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										nHdlPrv := HeadProva( cLote,;
										                      cOrigem /*cPrograma*/,;
										                      Substr( cUsuario, 7, 6 ),;
										                      @cArquivo )
								Endif
								dbSelectArea( "SED" )
								MsSeek( xFilial("SED")+SEZ->EZ_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
								dbSelectArea("SEZ")
								If nHdlPrv > 0
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Prepara Lancamento Contabil                                      ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
											aAdd( aFlagCTB, {"EZ_LA", "S", "SEZ", SEZ->( Recno() ), 0, 0, 0} )
										Endif
										nTotal += DetProva( nHdlPrv,;
										                    cPadraoCC /*cPadrao*/,;
										                    cOrigem /*cPrograma*/,;
										                    cLote,;
										                    /*nLinha*/,;
										                    /*lExecuta*/,;
										                    /*cCriterio*/,;
										                    /*lRateio*/,;
										                    /*cChaveBusca*/,;
										                    /*aCT5*/,;
										                    /*lPosiciona*/,;
										                    @aFlagCTB,;
										                    /*aTabRecOri*/,;
										                    /*aDadosProva*/ )
								Endif
								If !lUsaFlag
									SEZ->(RecLock("SEZ"))
									SEZ->EZ_LA    := "S"
									MsUnlock()
								Endif
								lCtbRatCC := .T.
							Endif
							If ! Empty(aGrvLctPco)
								aGrvSEZPco := aGrvLctPco[2]
				    			/*
								aGrvSEZPco[1] = Cod.Processo
								aGrvSEZPco[2] = Item Processo
								aGrvSEZPco[3] = Programa
								*/
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								PcoDetLan(aGrvSEZPco[1],aGrvSEZPco[2],aGrvSEZPco[3])
							EndIf
						Endif
						dbSelectArea("SEZTMP")
						DbSkip()
						
					Enddo
					
				Endif
				//Informo contabilizacao para SEV - Multi Naturezas
				dbSelectArea("SEV")
				If nTotal > 0 .and. !lUsaFlag
					RecLock("SEV")
					SEV->EV_LA    := "S"
					MsUnlock()
				Endif
				(cAlias)->(RestArea(aArea1))
			Endif
			// Contabilizacao das MultiNat sem Rateio C.Custo
			If lPadrao .And. !lCtbRatCC .And. lContabiliza
				// Desposiciona para nao contabilizar pelo SE1/SE2, para nao duplicar o
				// LP caso utilize SE1/SE2->Valor
				// A sintaxe do LP deve ser:
				// If(Se1/Se2->E2/E2_Multnat#"2",SEV->EV_VALOR,Se1/S22->_E1/E2_Valor)
				// ou SE1/SE2->E1/E2_Valor.
				DbSelectArea(cAlias)
				DbGoBottom()
				DbSkip()
				// Contabiliza pelo SEV
				If nHdlPrv <= 0
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Inicializa Lancamento Contabil                                   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						nHdlPrv := HeadProva( cLote,;
						                      cOrigem /*cPrograma*/,;
						                      Substr( cUsuario, 7, 6 ),;
						                      @cArquivo )
				Endif
				dbSelectArea( "SED" )
				MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
				dbSelectArea("SEV")
				If nHdlPrv > 0
					If lBxLote
						VALOR 	:= 0
					Else
						VALOR 	:= SEV->EV_VALOR		// Valor Principal
					Endif
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Prepara Lancamento Contabil                                      ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
							aAdd( aFlagCTB, {"EV_LA", "S", "SEV", SEV->( Recno() ), 0, 0, 0} )
						Endif
						nTotal += DetProva( nHdlPrv,;
						                    cPadrao,;
						                    cOrigem /*cPrograma*/,;
						                    cLote,;
						                    /*nLinha*/,;
						                    /*lExecuta*/,;
						                    /*cCriterio*/,;
						                    /*lRateio*/,;
						                    /*cChaveBusca*/,;
						                    /*aCT5*/,;
						                    /*lPosiciona*/,;
						                    @aFlagCTB,;
						                    /*aTabRecOri*/,;
						                    /*aDadosProva*/ )
						                       
						If lCobMulNat.And. nTotal > 0
							SE5->(DbGoBottom())
							SE5->(DbSkip())
							exit //Sai do laço para não gerar duplicidade na contabilização.					
						EndIf
				Endif
            If nTotal > 0 .and. !lUsaFlag
					RecLock("SEV")
					SEV->EV_LA := "S"
					MsUnlock()
				Endif
				(cAlias)->(RestArea(aArea1))
			Endif
		EndIf
	Next
	DbSelectArea("SEV")
	DbGoBottom()
	DbSkip()
Else
	//Nao confirmou o rateio Multi Nat. Neste caso a contabilizacao sera
	//de forma normal pelo LP da baixa s/rateio
	Reclock("SE5")
	Replace SE5->E5_MULTNAT With "2"
	MsUnlock()
Endif

//Se existir temporario para rateio c. custo, deleta
If Select("SEZTMP") > 0
	FINXDETMP()
Endif

SX3->(DbSetOrder(1))
RestArea(aArea)
(cAlias)->(RestArea(aArea1))

Return .T. /*Function MultNatC*/

//-------------------------------------------------------------------
/*/{Protheus.doc} MULTNATB

Distribui o valor do titulo em varias naturezas na Baixa (tela).
Arquivo original: FINXFUN.PRX 

@author Mauricio Pequim Jr.
@since 22/05/2001
/*/
//-------------------------------------------------------------------
Function MultNatB(cAlias,lBxLote,cReplica,lOk,aColsSEV,lMultNat,lBxAutomat,aRatAt)

// Indica quais campos serao exbididos na GetDados e na ordem que devem aparecer
LOCAL aCampos		:= {"EV_NATUREZ","EV_VALOR","EV_PERC","EV_RATEICC"}
LOCAL cCampo		:= Right(cAlias,2)
LOCAL nX
LOCAL bTit			:= { |cChave| SX3->(DbSeek(cChave)), X3Titulo() }
LOCAL oDlg
LOCAL oGet
LOCAL aArea			:= GetArea()
LOCAL aArea1		:= (cAlias)->(GetArea())
LOCAL aAreaSED		:= SED->(GetArea())
LOCAL cPic			:= PesqPict("SE2","E2_VALOR",19)
LOCAL nPos			:= 0
LOCAL nTotSev		:= 0
LOCAL nTotSez		:= 0
LOCAL nPerSev		:= 0
LOCAL nPerSez		:= 0
LOCAL lReplicou 	:= .F.
LOCAL lMultnatB 	:= Existblock("MULTNATB")
LOCAL lPanelFin 	:= IsPanelFin()
LOCAL aButton 		:= {}
Local nRecSez	:= 0
Local nTotNat	:= 0
Local aDecSez	:= {}
Local lMNBcancel	:= .F.
Local nRat			:= 0
Local nEz			:= 0
Local cNatRat		:= ""
Local nValorRat		:= 0
Local nPercRat		:= 0
Local cCCRat		:= ""
Local aRatEz		:= {}
Local lRet			:= .T.
Local nEzVlTot		:= 0
Local cEzCusto		:= ""
Local cEzConta		:= ""
Local cEzItem		:= ""
Local cEzClVl		:= ""
Local nEzValor		:= 0
Local nEzPerc		:= 0
Local nTotRat		:= 0

PRIVATE aCols		:= {}
PRIVATE aHeader		:= {}
PRIVATE oValDist
PRIVATE nValDist	:= 0
PRIVATE nVlTit		:= If(cAlias == "SE1", nValRec,nValPgto)
PRIVATE aTit      	:= {}
PRIVATE nOpcA 	   	:= 0
PRIVATE oValFal
PRIVATE oPerFal
PRIVATE nValFal		:= 0
PRIVATE nPerFal		:= 100

DEFAULT lBxLote		:= .F.
DEFAULT cReplica  	:= "2"  // replica rateio na baixa
DEFAULT lOk			:= .F.	//Confirmacao da distribuicao de multnat
DEFAULT lBxAutomat 	:= .F.
DEFAULT aRatAt		:= {}
__OPC 	:= 3

//Obtm a picture do campo EV_PERC ajustado de indice para percentual
cPictPerc		:= FPictPerc()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tratamento execauto											³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

dbSelectArea("SED")
If Len(aRatAt) > 0 //Rateio por execauto
	If Select("SEZTMP") = 0 //Cria a temporária para o rateio por centro de custo
		FINXTMP()
	EndIf
	
	For nRat := 1 to len(aRatAt)
		cNatRat		:= ""
		nValorRat	:= 0
		nPercRat	:= 0
		cCCRat		:= ""
		aRatEz		:= {}
		nEzVlTot	:= 0

		If (nPos := ascan(aRatAut[nRat],{|x,y| x[1] == "EV_NATUREZ"})) > 0
			cNatRat := aRatAut[nRat][nPos][2]
		EndIf
		If (nPos := ascan(aRatAut[nRat],{|x,y| x[1] == "EV_VALOR"})) > 0
			nValorRat := aRatAut[nRat][nPos][2]
		EndIf
		If (nPos := ascan(aRatAut[nRat],{|x,y| x[1] == "EV_PERC"})) > 0
			nPercRat := aRatAut[nRat][nPos][2]
		EndIf
		If (nPos := ascan(aRatAut[nRat],{|x,y| x[1] == "EV_RATEICC"})) > 0
			cCCRat := aRatAut[nRat][nPos][2]
		EndIf
		If (nPos := ascan(aRatAut[nRat],{|x,y| x[1] == "AUTRATEICC"})) > 0
			aRatEz := aRatAut[nRat][nPos][2]
		EndIf

		If Empty(cNatRat)
			Help( " ", 1, "FXNATVAZIO",, STR0004, 1, 0 ) //"É necessário informar o código da natureza"
			lRet := .F.
			Exit
		Else
			// Nao permite natureza sintetica
			SED->( dbSetOrder( 1 ) )
			If SED->( dbSeek( xFilial( "SED" ) + cNatRat ) )
				If SED->ED_TIPO == "1"	// Natureza Sintetica
					Help( " ", 1, "FXNATSINT",, STR0002, 1, 0 ) //"Verifique se a natureza informada está classificada corretamente. Apenas naturezas do titpo analítico serão aceitas para este processo.!"
					lRet := .F.
					Exit
				EndIf
			Else
				lRet := .F. 
				Exit
			EndIf
		EndIf
		
		// nao permite nova distribuicao para a mesma natureza
		If (nPos := ascan(aCols,{|x| x[1] == cNatRat })) > 0
			Help( " ", 1, "FXNATNAT",, STR0003, 1, 0 ) //"Natureza já está cadastrada!"
			lRet := .F.
			Exit
		EndIf
		
		If Empty(nValorRat)
			Help( " ", 1, "FXNATVALOR",, STR0005, 1, 0 ) //"Informar um valor para o rateio."
			lRet := .F.
			Exit
		EndIf

		aAdd(Acols ,{cNatRat ,nValorRat , nPercRat , cCCRat ,.F.})
		nTotRat += nValorRat
		If cCCRat == "1"
			For nEz := 1 to len(aRatEz)
				cEzCusto	:= ""
				cEzConta	:= ""
				cEzItem		:= ""
				cEzClVl		:= ""
				nEzValor	:= 0
				nEzPerc		:= 0
				
				If (nPos := aScan(aRatEz[nEz],{|x| x[1] == "EZ_CCUSTO"})) > 0
					cEzCusto := aRatEz[nEz][nPos][2]
				EndIf
				If (nPos := aScan(aRatEz[nEz],{|x| x[1] == "EZ_CONTA"})) > 0
					cEzConta := aRatEz[nEz][nPos][2]
				EndIf
				If (nPos := aScan(aRatEz[nEz],{|x| x[1] == "EZ_ITEMCTA"})) > 0
					cEzItem := aRatEz[nEz][nPos][2]
				EndIf
				If (nPos := aScan(aRatEz[nEz],{|x| x[1] == "EZ_CLVL"})) > 0
					cEzClVl := aRatEz[nEz][nPos][2]
				EndIf
				If (nPos := aScan(aRatEz[nEz],{|x| x[1] == "EZ_VALOR"})) > 0
					nEzValor := aRatEz[nEz][nPos][2]
				Else
					lRet := .F.
				EndIf
				If (nPos := aScan(aRatEz[nEz],{|x| x[1] == "EZ_PERC"})) > 0
					nEzPerc := aRatEz[nEz][nPos][2]
				EndIf

				If (Empty(cEzCusto) .And. Empty(cEzConta) .And. Empty(cEzItem) .And. Empty(cEzClVl) ) .or. !lRet
					lRet := .F.
				EndIf
				
				If lRet
					nEzVlTot += nEzValor
					If nEzPerc == 0
						nEzPerc := nEzValor / nValorRat
					ElseIf nEzPerc > 1	// Caso valor 70.00 % alterar para 0,7 %
						nEzPerc := nEzPerc / 100
					EndIf
					RecLock("SEZTMP", .T.)
					
					SEZTMP->EZ_NATUREZ	:= cNatRat
					SEZTMP->EZ_CCUSTO 	:= cEzCusto
					SEZTMP->EZ_CONTA	:= cEzConta
					SEZTMP->EZ_ITEMCTA	:= cEzItem
					SEZTMP->EZ_CLVL   	:= cEzClVl
					SEZTMP->EZ_VALOR 	:= nEzValor
					SEZTMP->EZ_PERC		:= nEzPerc

					MsUnLock()
				EndIf
			Next
			If nEzVlTot <> nValorRat // Valor do rateio por centro de custo diferente do rateio da natureza
				lRet := .F.
				Help( " ", 1, "FXNATTCCTOT",, STR0029, 1, 0 ) //"A soma do valor rateado no centro de custo é diferente do valor da natureza."
				Exit
			EndIf
		EndIf
	
	Next
	If nTotRat <> nValRec
		lRet := .F.
		Help( " ", 1, "FXNATNATTOT",, STR0028, 1, 0 ) //"A soma do valor rateado na natureza é diferente do valor recebido."
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Montagem da matriz aHeader e aCampos						³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SX3")
dbSetOrder(2)

If !(Len(aRatAt) > 0)
	SEV->(dbSetOrder(2))
	If SEV->(MsSeek(xFilial("SEV")+;
				(cAlias)->&(cCampo + "_PREFIXO")+;
				(cAlias)->&(cCampo + "_NUM")+;
				(cAlias)->&(cCampo + "_PARCELA")+;
				(cAlias)->&(cCampo + "_TIPO")+;
				(cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))+;
				(cAlias)->&(cCampo + "_LOJA")+;
				cReplica))		//1=Inclusao   2=Baixa

		cSequencia := SEV->EV_SEQ
		lReplicou := .F.
		While SEV->EV_FILIAL + SEV->EV_PREFIXO + SEV->EV_NUM +;
				SEV->EV_PARCELA + SEV->EV_TIPO + SEV->EV_CLIFOR +;
				SEV->EV_LOJA+SEV->EV_IDENT+SEV->EV_SEQ == xFilial("SEV")+;
				(cAlias)->&(cCampo + "_PREFIXO")+;
				(cAlias)->&(cCampo + "_NUM")+;
				(cAlias)->&(cCampo + "_PARCELA")+;
				(cAlias)->&(cCampo + "_TIPO")+;
				(cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))+;
				(cAlias)->&(cCampo + "_LOJA")+;
				cReplica+cSequencia

			If SEV->EV_SITUACA == "E"  //Estorno
				SEV->(dbSkip())
				Loop
			Endif

			//Verificar carteira do rateio
			If (cAlias == "SE1" .and. SEV->EV_RECPAG == "P") .or. (cAlias == "SE2" .and. SEV->EV_RECPAG == "R")
				SEV->(dbSkip())
				Loop
			Endif

			Aadd(aCols,Array(Len(aCampos)+1))
			If Len(aCols) = 1
				For nX := 1 To Len(aCampos)
					SX3->(dbSeek(Pad(aCampos[nX],10)))
					Aadd(aHeader,{ AllTrim(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT } )
					If Alltrim(aHeader[nX][2]) == "EV_PERC" // Percentual
						aHeader[nX][6] := "MNatCalcV()"
						// Inclui em aCols como caracter para ser possivel a visualizacao na
						// tela, por ser a ultima coluna da getdados
						aHeader[nX][5] := 2
						aHeader[nX][3] := cPictPerc
					ElseIf Alltrim(aHeader[nX][2]) == "EV_VALOR"
						aHeader[nX][6] := "MNatCalcP()"
					ElseIf Alltrim(aHeader[nX][2]) == "EV_NATUREZ"
						aHeader[nX][6] := 'ExistCpo("SED") .And. MNatAltN()'
					Endif
				Next
			Endif

			aCols[Len(aCols)][1] := SEV->EV_NATUREZ
			aCols[Len(aCols)][2] := Round(NoRound(nVlTit * SEV->EV_PERC, 3), 2)
			aCols[Len(aCols)][3] := SEV->EV_PERC * 100
			aCols[Len(aCols)][4] := SEV->EV_RATEICC
			aCols[Len(aCols)][Len(aCampos)+1] := .F.
			nTotSev += aCols[Len(aCols)][2]
			nPerSev += aCols[Len(aCols)][3]

			nValDist := nVlTit
			SEV->(DbSkip())
		EndDo

		If nTotSev # nVlTit .Or. nPerSev # 100
			aCols[Len(aCols)][2] += nVlTit - nTotSev
			aCols[Len(aCols)][3] := aCols[Len(aCols)][3] + 100 - nPerSev
		Endif

		aCposDb := {}
		aadd(aCposDB,{"EZ_NATUREZ","C",10,0})
		aadd(aCposDB,{"EZ_CCUSTO","C",TamSx3("CTT_CUSTO")[1],0})
		aadd(aCposDB,{"EZ_CONTA","C",TamSX3("CT1_CONTA")[1],0})
		aadd(aCposDB,{"EZ_ITEMCTA","C",TamSx3("CTD_ITEM")[1],0})
		aadd(aCposDB,{"EZ_CLVL","C",TamSx3("CTH_CLVL")[1],0})
		aadd(aCposDB,{"EZ_VALOR","N",TamSx3("EZ_VALOR")[1],TamSx3("EZ_VALOR")[2]})
		aadd(aCposDB,{"EZ_PERC","N",TamSx3("EZ_PERC")[1],TamSx3("EZ_PERC")[2]})				
		aadd(aCposDB,{"EZ_FLAG","L",1,0})
		aadd(aCposDB,{"EZ_RECNO","N",10,0})

		// Adiciona demais campos
		aStruSez := SEZ->(DbStruct())
		For nX := 1 To Len(aStruSez)
			If Ascan(aCposDB, { |e| Alltrim(e[1]) == aStruSez[nX][1] } ) == 0
				Aadd(aCposDB,{aStruSez[nX][1],aStruSez[nX][2],aStruSez[nX][3],aStruSez[nX][4]})
			Endif
		Next
		FINXTMP()
		dbSetOrder(1)
		SEZ->(dbSetOrder(1))
		SEZ->(MsSeek(	xFilial("SEZ")+;
					(cAlias)->&(cCampo + "_PREFIXO")+;
						(cAlias)->&(cCampo + "_NUM")+;
						(cAlias)->&(cCampo + "_PARCELA")+;
						(cAlias)->&(cCampo + "_TIPO")+;
						(cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))+;
						(cAlias)->&(cCampo + "_LOJA")))


		While 	SEZ->EZ_FILIAL + SEZ->EZ_PREFIXO + SEZ->EZ_NUM +;
				SEZ->EZ_PARCELA + SEZ->EZ_TIPO + SEZ->EZ_CLIFOR +;
				SEZ->EZ_LOJA == xFilial("SEZ")+;
				(cAlias)->&(cCampo + "_PREFIXO")+;
				(cAlias)->&(cCampo + "_NUM")+;
				(cAlias)->&(cCampo + "_PARCELA")+;
				(cAlias)->&(cCampo + "_TIPO")+;
				(cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))+;
				(cAlias)->&(cCampo + "_LOJA")

			If !(SEZ->EZ_IDENT+SEZ->EZ_SEQ == 	cReplica+cSequencia)
				SEZ->(dbskip())
				Loop
			Endif

			If SEZ->EZ_SITUACA == "E"  //Estorno
				SEZ->(dbSkip())
				Loop
			Endif

			RecLock("SEZTMP", .T.)
			
			// Carregamento dos campos de novas entidades contabeis e campos específicos
			aEval(aStruSez, {|e,ni| If(Alltrim(e[2]) != "EV_PERC", SEZTMP->(FieldPut(FieldPos(e[1]),SEZ->(FieldGet(FieldPos(e[1]))))), Nil) } )

			nPos := Ascan(aCols, { |x| x[1] = SEZ->EZ_NATUREZ })
			SEZTMP->EZ_NATUREZ	:= SEZ->EZ_NATUREZ
			SEZTMP->EZ_CCUSTO	:= SEZ->EZ_CCUSTO
			SEZTMP->EZ_CONTA 	:= SEZ->EZ_CONTA
			SEZTMP->EZ_ITEMCTA	:= SEZ->EZ_ITEMCTA
			SEZTMP->EZ_CLVL   	:= SEZ->EZ_CLVL
			SEZTMP->EZ_VALOR 	:= Round(NoRound(aCols[nPos,2]*SEZ->EZ_PERC,3),2)
			SEZTMP->EZ_PERC		:= SEZ->EZ_PERC
			SEZTMP->EZ_RECNO	:= SEZ->(Recno())
			MsUnLock()
			SEZ->(DbSkip())
		Enddo

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Realiza arredondamento no valor e % no ultimo item do rateio ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SEZTMP->( dbGoTop() )

		Do While SEZTMP->( ! EoF() )

			nTotSez := 0
			nPerSez := 0
			cCodNat := SEZTMP->EZ_NATUREZ
			nPos	:= Ascan( aCols, { |x| x[1] = SEZTMP->EZ_NATUREZ } )
			nTotNat	:= aCols[ nPos,2 ]

			Do While SEZTMP->( ! EoF() .And. EZ_NATUREZ == cCodNat )

				nRecSez	:= SEZTMP->( Recno() )
				nTotSez	+= SEZTMP->EZ_VALOR
				nPerSez += SEZTMP->EZ_PERC

				SEZTMP->( dbSkip() )

			EndDo

			If nPerSez < 1
				AAdd( aDecSez, { nRecSez, nTotNat, nTotSez, nPerSez } )
			EndIf

		EndDo

		For nX := 1 To Len( aDecSez )

			SEZTMP->( dbGoTo( aDecSez[ nX, 1 ] ) )

			RecLock( "SEZTMP", .F. )

			SEZTMP->EZ_VALOR += aDecSez[ nX, 2 ] - aDecSez[ nX, 3 ]
			SEZTMP->EZ_PERC  += ( 1 - aDecSez[ nX, 4 ] )

			SEZTMP->( MsUnlock() )

		Next nX
	EndIf
Endif
	
If Len(aCols) > 0
	lReplicou := .T.
Endif

If !lReplicou .And. lRet
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Adiciona os campos de usuário na tela de rateio.	 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SX3->(dbSetOrder(1))
	SX3->(dbSeek("SEV"))
	// Adiciono demais campos
	While ! SX3->(EOF()) .And. (SX3->X3_Arquivo == "SEV")
		If X3USO(SX3->X3_Usado) .And. cNivel >= SX3->X3_NIVEL .And. SX3->X3_PROPRI == "U"
			Aadd(aCampos,SX3->X3_CAMPO)
		Endif
		SX3->(DbSkip())
	EndDo

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Adiciona mais um elemento em aCOLS, indicando se a   ³
	//³ a linha esta ou nao deletada						 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Aadd(aCols,Array(Len(aCampos)+1))

	dbSelectArea("SX3")
	dbSetOrder(2)

	For nX := 1 To Len(aCampos)
		SX3->(dbSeek(Pad(aCampos[nX],10)))
		Aadd(aHeader,{ AllTrim(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT } )
		If aHeader[nX][8] == "C"
			aCols[1][nX] := CriaVar(aHeader[nX][2])
		Else
			If Alltrim(aHeader[nX][2]) == "EV_PERC" // Percentual
				aHeader[nX][6] := "MNatCalcV()"
				// Inclui em aCols como caracter para ser possivel a visualizacao na
				// tela, por ser a ultima coluna da getdados
				aHeader[nX][5] := 2
				aHeader[nX][3]	:= cPictPerc
				aCols[1][nX]	:= CriaVar("EV_PERC")

			ElseIf Alltrim(aHeader[nX][2]) == "EV_VALOR"
				aCols[1][nX] := CriaVar("EV_VALOR")
				aHeader[nX][6] := "MNatCalcP()"
			Else
				aCols[1][nX] := CriaVar(aHeader[nX][2])
			Endif
		EndIf
	Next

	// Indica que a linha nao esta deletada
	aCols[1][nX] := .F.
Endif

IF lMultnatB
	Execblock("MULTNATB",.f.,.f., {cAlias,lBxLote,cReplica} )
Endif

If lBxAutomat .Or. len(aRatAt) > 0
	nOpca := 1
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Mostra o corpo da rateio 									 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nOpca := 0
	// Cria os titulos do dialogo
	Aadd( aTit, Eval(bTit, cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE")))
	Aadd( aTit, Eval(bTit, cCampo + "_LOJA"))
	Aadd( aTit, Eval(bTit, cCampo + "_PREFIXO"))
	Aadd( aTit, Eval(bTit, cCampo + "_NUM"))
	Aadd( aTit, Eval(bTit, cCampo + "_PARCELA"))
	Aadd( aTit, Eval(bTit, cCampo + "_VALOR" ))
	Aadd( aTit, cAlias)

	aSize := MSADVSIZE()
	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0025) From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL		//"Titulos por natureza"
	oDlg:lMaximized := .T.

	oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20,.T.,.T. )
	oPanel:Align := CONTROL_ALIGN_TOP

	@  001, 005 To  018,247 OF oPanel PIXEL
	@  001, 250 To  018,495 OF oPanel PIXEL

	@  005 , 010	Say aTit[1] + (cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))	FONT oDlg:oFont OF oPanel Pixel
	@  005 , 100	Say aTit[2] + (cAlias)->&(cCampo + "_LOJA")    	FONT oDlg:oFont	OF oPanel  Pixel
	@  005 , 253	Say aTit[3] + (cAlias)->&(cCampo + "_PREFIXO") 	FONT oDlg:oFont	OF oPanel  Pixel
	@  005 , 293	Say aTit[4] + (cAlias)->&(cCampo + "_NUM")	 		FONT oDlg:oFont	OF oPanel  Pixel
	@  005 , 367	Say aTit[5] + (cAlias)->&(cCampo + "_PARCELA") 	FONT oDlg:oFont	OF oPanel  Pixel

	oPanel2 := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,40,40,.T.,.T. )

	If !lPanelFin
		oPanel2:Align := CONTROL_ALIGN_BOTTOM
	Endif

	@ 001, 005 To 035,247 OF oPanel2 PIXEL
	@ 001, 250 To 035,495 OF oPanel2 PIXEL

	@ 005, 010  Say aTit[6] FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10
	@ 005, 076  Say nVlTit	PICTURE cPic FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10

	@ 005, 257  Say STR0011	FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10		//"Valor a Distribuir"  
	@ 005, 357  Say oValFal VAR nValFal PICTURE cPic	FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10

	@ 018, 010  Say OemToAnsi(STR0015) FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10		//"Total Distribuido: " 
	@ 018, 076  Say oValDist VAR nValDist PICTURE cPic	FONT oDlg:oFont OF oPanel2 PIXEL SIZE 50,10

	@ 018, 257  Say STR0012	FONT oDlg:oFont OF oPanel2 PIXEL SIZE 90,10		//"Percentual a Distribuir"  
	@ 018, 357  Say oPerFal VAR nPerFal PICTURE cPictPerc SIZE 50,10 FONT oDlg:oFont OF oPanel2 PIXEL //"@E 999.9999999"

	oGet := MSGetDados():New(34,5,128,315,3,"MNatLinOk", "AllwaysTrue",,nOpca # 2)
	oGet:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

	If lPanelFin
		ACTIVATE MSDIALOG oDlg ON INIT (FaMyBar(oDlg,{||nOpca:=1,If(oGet:TudoOk() .And. FaMNatOk(),;
				oDlg:End(),nOpca := 0)},{||nOpca:=0,oDlg:End()},aButton),	oPanel2:Align := CONTROL_ALIGN_BOTTOM )

	Else
		ACTIVATE 	MSDIALOG oDlg ON INIT EnchoiceBar (oDlg,{||nOpca:=1,If(oGet:TudoOk() .And. FaMNatOk(),;
				oDlg:End(),nOpca := 0)},{||nOpca:=0,oDlg:End()},,aButton)
	Endif
Endif

If ExistBlock("MNBcancel")
	lMNBcancel := ExecBlock("MNBcancel",.F.,.F.,{aCols})
	lMNBcancel := iif(Valtype(lMNBcancel)=='L',lMNBcancel,.F.)
EndIf

If !lRet
	nOpca := 0
EndIf

If nOpca == 1 .OR. lMNBcancel
	lOk := .T.
	aColsSEV	:= AClone(aCols)
Else
	//Se existir temporario para rateio c. custo, deleta
	If Select("SEZTMP") > 0
		FINXDETMP()
	Endif
	SX3->(DbSetOrder(1))
	RestArea(aArea)
	(cAlias)->(RestArea(aArea1))

	lMultNat := .F.
Endif

SED->( RestArea( aAreaSED ) )
Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} FAMNATOK

Faz validacao de usuario no Ok do Multiplas Naturezas (ponto de entrada).
Arquivo original: FINXFUN.PRX 

@author Nilton Pereira
@since 04/03/2004
/*/
//-------------------------------------------------------------------
Function FaMNatOk()
LOCAL lRet := .T.

If ExistBlock("FIXVALMNAT")
	lRet := ExecBlock("FIXVALMNAT",.F.,.F.)
Endif

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} MULTIAUTO

Geração de aHeader e Acols para o rateio multinaturezas em Rotina automatica.
Arquivo original: FINXFUN.PRX 

@author TOTVS
/*/
//-------------------------------------------------------------------
Function Multiauto(aColsSEV,aHeaderSEV,cAlias,cAlias2)
Local aAreaSX3
Local aHeaderX:={}
Local aColsX:={}
Local aArea:=GetArea()
Local nX:=0
Local nRecnoSx3:=0
LOCAL aCampos		:=	If( cAlias2=="SEV",{	"EV_NATUREZ",;
							"EV_VALOR",;
							"EV_PERC",;
							"EV_RATEICC" },{	"EZ_CCUSTO",;
							"EZ_ITEMCTA",;
							"EZ_CLVL",;
							"EZ_PERC","EZ_VALOR","EZ_CONTA"})	// Indica quais campos serao
											// exbididos na GetDados
											// e na ordem que devem aparecer
Local aStructSEZ	:= SEZ->( dbStruct() )
Local cEntCont		:= "|EZ_EC05DB|EZ_EC05CR|EZ_EC06DB|EZ_EC06CR|EZ_EC07DB|EZ_EC07CR|EZ_EC08DB|EZ_EC08CR|EZ_EC09DB|EZ_EC09CR|"

If cAlias2 != "SEV"
	For nX:=1 To Len(aStructSEZ)
		If aStructSEZ[nX][1] $ cEntCont
			aAdd(aCampos,aStructSEZ[nX][1])
		EndIf
	Next nX
EndIf

dbSelectArea("SX3")
aAreaSX3:=SX3->(GetArea())
dbSetOrder(1)
dbSeek(cAlias2)
nX := 1
Do While SX3->(!EoF() .And. X3_ARQUIVO == cAlias2)
	If X3USO(SX3->X3_Usado) .And. cNivel >= SX3->X3_NIVEL
		If nX == 1
			nRecnoSx3 := SX3->(Recno())
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Adiciona mais um elemento em aCOLS, indicando se a linha esta ou nao deletada ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Aadd(aColsX,Array(Len(aCampos)))
			For nX := 1 To Len(aCampos)
				SX3->(dbSetOrder(2))
				SX3->(MsSeek(Pad(aCampos[nX],10)))
				Aadd(aHeaderX,{ AllTrim(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT } )
				If aHeaderX[nX][8] == "C"
					aColsX[1][nX] := CriaVar(aHeaderX[nX][2])
				Else
					If Alltrim(aHeaderX[nX][2]) == "EV_PERC" // Percentual
						aHeaderX[nX][6] := "MNatCalcV()"
						// Inclui em aCols como caracter para ser possivel a visualizacao na
						// tela, por ser a ultima coluna da getdados
						aHeaderX[nX][8] := "N"
						aHeaderX[nX][5] := 2
						aColsX[1][nX] := CriaVar("EV_PERC")

					ElseIf Alltrim(aHeaderX[nX][2]) == "EZ_PERC" // Percentual
						//aHeader[nX][6] := "MNatCalcV()"
						// Inclui em aCols como caracter para ser possivel a visualizacao na
						// tela, por ser a ultima coluna da getdados
						aHeaderX[nX][8] := "N"
						aHeaderx[nX][5] := 2
						aHeaderx[nX][3] := cPictPerc
						aColsX[1][nX] := CriaVar("EZ_PERC")

					ElseIf Alltrim(aHeaderX[nX][2]) == "EV_VALOR"
						aColsX[1][nX] := CriaVar("EV_VALOR")
						aHeaderX[nX][6] := "MNatCalcP()"
					Else
						aColsX[1][nX] := CriaVar(aHeaderX[nX][2])
					Endif
				EndIf
			Next
			SX3->(DbSetOrder(1))
			SX3->(DbGoto(nRecnoSx3))
			// Adiciona os demais campos
			If Ascan(aHeaderX, {|e| AllTrim(e[2]) == AllTrim(SX3->X3_CAMPO) } )  == 0 .and. cAlias2 <> "SEZ"
				Aadd(aHeaderX,{ AllTrim(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT } )
				Aadd(aColsX[1], CriaVar(SX3->X3_CAMPO))
			Endif
		Else
			// Adiciona os demais campos
			If Ascan(aHeaderX, {|e| AllTrim(e[2]) == AllTrim(SX3->X3_CAMPO) } )  == 0 .and. cAlias2 <> "SEZ"
				Aadd(aHeaderX,{ AllTrim(X3Titulo()),SX3->X3_CAMPO,SX3->X3_PICTURE,SX3->X3_TAMANHO,SX3->X3_DECIMAL,SX3->X3_VALID,SX3->X3_USADO,SX3->X3_TIPO,SX3->X3_ARQUIVO,SX3->X3_CONTEXT } )
				Aadd(aColsX[1], CriaVar(SX3->X3_CAMPO))
			Endif
		Endif
	EndIf
	SX3->(dbSkip())
EndDo
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Adiciona mais um elemento em aCOLS, indicando se a   ³
//³ a linha esta ou nao deletada						 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Aadd(aColsX[1], .F.)
aColsSev:=aClone(aColsX)
aHeaderSev:=aClone(aHeaderX)
If Type("nNumCol") == "N"
	nNumCol:=Len(aHeaderSev)
Endif
RestArea(aAreaSX3)
RestArea(aArea)
Return


//-------------------------------------------------------------------
/*/{Protheus.doc} MNCCGRV

Grava a Natureza no Arquivo temporario (Multiplas Naturezas por C.Custo).
Arquivo original: FINXFUN.PRX 

@author Mauricio Pequim Jr.
@since 14/8/2002
/*/
//-------------------------------------------------------------------
Function MnccGrv(aRegs)
LOCAL nCont := 1
LOCAL nX	:= 0
LOCAL nPosCta   := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_CONTA") } )
LOCAL nPosCus   := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_CCUSTO") } )
LOCAL nPosVal   := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_VALOR") } )
LOCAL nPosItCta := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_ITEMCTA") } )
LOCAL nPosClVl  := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_CLVL") } )

dbselectArea("SEZTMP")
// Gravo os dados do acols
For nCont := 1 to len(aCols)
	If Len(aRegs) >= nCont
		DbGoto(aRegs[nCont])
		RecLock("SEZTMP",.F.)
	Else
		RecLock("SEZTMP",.T.)
	Endif
	// Grava todos os campos
	For nX := 1 To Len(aHeader)
		If Alltrim(aHeader[nX][2]) != "EZ_PERC"
			SEZTMP->&(aHeader[nX][2])	:= aCols[nCont][nX]
		Endif
	Next
	// Grava demais campos
	SEZTMP->EZ_NATUREZ	:= cNatur
	SEZTMP->EZ_CCUSTO	:= aCols[nCont][nPosCus]
	SEZTMP->EZ_VALOR	:= aCols[nCont][nPosVal]
	SEZTMP->EZ_PERC		:= (aCols[nCont][nPosVal] / nValNat)
	SEZTMP->EZ_FLAG		:= aCols[nCont][nNumCol+1]
	SEZTMP->EZ_CONTA 	:= aCols[nCont][nPosCta]
	SEZTMP->EZ_ITEMCTA	:= aCols[nCont][nPosItCta]
	SEZTMP->EZ_CLVL   	:= aCols[nCont][nPosClVl]
	MsUnlock()
	dbSkip()
Next

Return .T.	


//-------------------------------------------------------------------
/*/{Protheus.doc} GRVSEVSEZ

Grava os arquivos referentes a multiplas naturezas (FINA040/FINA050).
Arquivo original: FINXFUN.PRX 

@author Claudio Donizete Souza
@since 08/03/2006
/*/
//-------------------------------------------------------------------
Function GrvSevSez(	cAlias, aColsSev, aHeaderSev, nVlrTit, nImpostos, lRatImpostos,;
					cOrigem, lContabiliza, nHdlPrv, nTotal, cArquivo, lDesdobr)

LOCAL cCampo    	:= Right(cAlias,2)
LOCAL cPadrao		:= If(cAlias=="SE1","500","510")
LOCAL lPadrao		:= VerPadrao(cPadrao)
LOCAL cPadraoCC		:= If(cAlias=="SE1","506","508")
LOCAL lPadraoCC		:= VerPadrao(cPadraoCC)
LOCAL lCtbRatCC		:= .F.  // Controle de contabilizacao por Rateio C.Custo
LOCAL aArea 		:= GetArea()
LOCAL aArea1 		:= (cAlias)->(GetArea())
LOCAL lGrvSev		:= ExistBlock("MULTSEV")
LOCAL lGrvSez		:= ExistBlock("MULTSEZ")
LOCAL cChaveIrf		:= If(cAlias = "SE2" .And. M->E2_IRRF > 0, SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCIR + Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA), "")
LOCAL cChavePis		:= If(cAlias = "SE2" .And. M->E2_PIS > 0, SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCPIS + Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA), "")
LOCAL cChaveCof		:= If(cAlias = "SE2" .And. M->E2_COFINS > 0, SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCCOF + Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA), "")
LOCAL cChaveCsl		:= If(cAlias = "SE2" .And. M->E2_CSLL > 0, SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCSLL + Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA), "")
LOCAL cChaveIns		:= If(cAlias = "SE2" .And. M->E2_INSS > 0, SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCINS + IIf(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"INA",MVINSS), "")
LOCAL cChaveIss		:= If(cAlias = "SE2" .And. M->E2_ISS > 0 , SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCISS + MVISS, "")
LOCAL cChaveCid		:= If(cAlias = "SE2" .And. cPaisLoc == "BRA" .And. M->E2_CIDE > 0 , SE2->E2_PREFIXO + SE2->E2_NUM + SE2->E2_PARCCID + "CID", "")
LOCAL cChave		:= If(lGrvSez .Or. lGrvSev,	(cAlias)->&(cCampo + "_PREFIXO") + ;
						(cAlias)->&(cCampo + "_NUM") + ;
						(cAlias)->&(cCampo + "_PARCELA") +;
						(cAlias)->&(cCampo + "_TIPO") +;
						(cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE")) +;
						(cAlias)->&(cCampo + "_LOJA"), "")
LOCAL nRecno		:= (cAlias)->(Recno())
LOCAL nX
LOCAL aDiff 		:= {0,0,0,0,0,0}
LOCAL aPosDiff 		:= {0,0,0,0,0,0}

LOCAL aRatPis		:= {}
LOCAL aRatCof 		:= {}
LOCAL aRatCsl 		:= {}
LOCAL aRatIrf		:= {}
LOCAL aRatIns 		:= {}
LOCAL aRatIss 		:= {}
Local aRatCid		:= {}

LOCAL nRatIrf1		:= nRatIns1 := nRatIss1 := nRatCid1 := 0
LOCAL nRatPis1		:= nRatCof1 := nRatCsl1 := 0
LOCAL nRatIrf2		:= nRatIns2 := nRatIss2 := nRatCid2 := 0
LOCAL nRatPis2		:= nRatCof2 := nRatCsl2 := 0
LOCAL nCont 		:= nCont1 := nCont2 := nCont3 := nCont4 := nCont5 := nCont6 := nCont7 := 0
LOCAL aDadosTit 	:= {}

LOCAL cLojaImp		:= PadR( "00", TamSX3( "A2_LOJA" )[1], "0" )
LOCAL lAtuSldNat 	:= .T.
LOCAL lRatG050		:= ExistBlock("RATG050")
Local lREt			:=.T.
Local lFINRATAUT 	:= ExistBlock("FINRATAUT")
Local aRatRet 		:= {}
Local lAuto040 		:= Iif( Type("lF040Auto")=="L" , lF040Auto , .F. )
Local lAglut		:= SuperGetMv("MV_AG10925",.F.,"2") == "1"
Local lRatCCParcial	:= .F.
Local cChaveTit 	:= ""
Local cChaveFK7 	:= ""
Local _cMvUniao     := SuperGetMV("MV_UNIAO",.F.,"")
LOCAL _cMvFInss     := SuperGetMv("MV_FORINSS",.F.,"") 
LOCAL _cMvMunic     := SuperGetMv("MV_MUNIC",.F.,"")   
LOCAL _cMvFCide     := SuperGetMV("MV_FORCIDE",.F.,"")
Local aStruEZTMP	:= {}

DEFAULT lRatImpostos:= .F.
DEFAULT lContabiliza:= .F.
DEFAULT nHdlPrv		:= 0
DEFAULT nTotal		:= 0
DEFAULT cArquivo	:= ""
DEFAULT cOrigem 	:= If(cAlias=="SE1","FINA040","FINA050")
DEFAULT nImpostos	:= 0
DEFAULT nVlrTit		:= (cAlias)->&(cCampo + "_VALOR") + nImpostos // Valor do titulo
DEFAULT lDesdobr 	:= .F.
Private nVlTit      := nVlrTit //utilizada dentro da validação do rateio

Begin TRANSACTION

If Type("aRatEvEz")<> "U" .and. aRatEvEz <> Nil //Rateio Multi-naturezas via rotina automatica
	aCols:=aClone(aColsSev)
	aHeader:=aClone(aHeaderSev)
	nOpca:=1
	If  MsGetDAuto(aRatEvEz,"MNatLinOk",{|| .T.},,3)
		aColsSev:=aClone(aCols)
		aHeaderSev:=aClone(aHeader)
	Else
		DisarmTransaction()//neste ponto o título do E1 já está gravado. Caso nao seja possível gravar o rateio, deve disarmar a transação
		lRet:=.F.
	Endif
Endif

If lRet
	If ! Empty(cChaveIrf)
		cChaveIrf += Pad(_cMvUniao, Len(SE2->E2_FORNECE)) + cLojaImp
	Endif

	If ! Empty(cChaveIns)
		cChaveIns += Pad(_cMvFInss, Len(SE2->E2_FORNECE)) + cLojaImp
	Endif

	If ! Empty(cChaveIss)	
		cChaveIss += Pad(_cMvMunic, Len(SE2->E2_FORNECE)) + cLojaImp
	Endif

	If ! Empty(cChavePis)
		cChavePis += Pad(_cMvUniao, Len(SE2->E2_FORNECE)) + cLojaImp
	Endif

	If ! Empty(cChaveCof)
		cChaveCof += Pad(_cMvUniao, Len(SE2->E2_FORNECE)) + cLojaImp
	Endif

	If ! Empty(cChaveCsl)
		cChaveCsl += Pad(_cMvUniao, Len(SE2->E2_FORNECE)) + cLojaImp
	Endif

	If ! Empty(cChaveCid)
		cChaveCid += Pad(_cMvFCide, Len(SE2->E2_FORNECE)) + cLojaImp
	Endif
	
	If cAlias == "SE2"
		// Armazeno o valor do rateio para os impostos ja arredondado no ultimo

		aDiff := {0,0,0,0,0,0}
		aPosDiff := {0,0,0,0,0,0}
		DbSelectArea(cAlias)
		SE2->(DbSetOrder(1))

		//IRRF
		If ! Empty(cChaveIrf) .And. SE2->(DbSeek(xFilial("SE2") + cChaveIrf))
			Reclock(cAlias)
			Replace (cAlias)->&(cCampo + "_MULTNAT") With If(lRatImpostos, "1", "2")
			MsUnlock()
		Endif
		//Pis
		If ! Empty(cChavePis) .And. SE2->(DbSeek(xFilial("SE2") + cChavePis))
			Reclock(cAlias)
			Replace (cAlias)->&(cCampo + "_MULTNAT") With If(lRatImpostos, "1", "2")
			MsUnlock()
		Endif
		//COFINS
		If ! Empty(cChaveCof) .And. SE2->(DbSeek(xFilial("SE2") + cChaveCof))
			Reclock(cAlias)
			Replace (cAlias)->&(cCampo + "_MULTNAT") With If(lRatImpostos, "1", "2")
			MsUnlock()
		Endif
		//Csll
		If ! Empty(cChaveCsl) .And. SE2->(DbSeek(xFilial("SE2") + cChaveCsl))
			Reclock(cAlias)
			Replace (cAlias)->&(cCampo + "_MULTNAT") With If(lRatImpostos, "1", "2")
			MsUnlock()
		Endif
		// INSS
		If ! Empty(cChaveIns) .And. SE2->(DbSeek(xFilial("SE2") + cChaveIns))
			// Armazeno o valor do rateio para os impostos ja arredondado no ultimo
			Reclock(cAlias)
			Replace (cAlias)->&(cCampo + "_MULTNAT") With If(lRatImpostos, "1", "2")
			MsUnlock()
		Endif
		//ISS
		If ! Empty(cChaveIss) .And. SE2->(DbSeek(xFilial("SE2") + cChaveIss))
			Reclock(cAlias)
			Replace (cAlias)->&(cCampo + "_MULTNAT") With If(lRatImpostos, "1", "2")
			MsUnlock()
		Endif
		//CIDE
		If ! Empty(cChaveCid) .And. SE2->(DbSeek(xFilial("SE2") + cChaveCid))
			Reclock(cAlias)
			Replace (cAlias)->&(cCampo + "_MULTNAT") With If(lRatImpostos, "1", "2")
			MsUnlock()
		Endif
		
		If lRatImpostos

			//Verifico se todas as naturezas foram rateadas por centro de custo.
			//Caso uma delas n?o tenha sido rateada por centro de custos, n?o vou apurar diferena de impostos nos rateios multinatureza por centro de custos
			lRatCCParcial := ((nPos := aScan( aColsSev, { |x| AllTrim( x[4] ) ==  "2" } ) ) > 0)

			For nX := 1 To Len(aColsSev)
			   // Se a linha de aCols nao estiver deletada e o registro nao for
				// encontrado no SEV
				If !aColsSev[nX][Len(aColsSev[nX])]
					If M->E2_IRRF > 0
						Aadd(aRatIrf, { M->E2_IRRF * (aColsSev[nX][3] / 100), {} })	// Grava o valor informado
						nRatIrf1 += aRatIrf[Len(aRatIrf)][1]
			        	nCont := 0

						If Select("SEZTMP") > 0 .And. aColsSev[nX][4] == "1"
							dbSelectArea("SEZTMP")
							// busca natureza no arquivo TMP de Mult Nat C.Custo
							If dbSeek(aColsSev[nX][1])
								While !Eof() .and. SEZTMP->EZ_NATUREZ == aColsSev[nX][1]
									Aadd(aRatIrf[Len(aRatIrf)][2], Round(NoRound((M->E2_IRRF * (aColsSev[nX][3] / 100)) * SEZTMP->EZ_PERC, 2), 3)) // Grava o valor informado
									nCont ++
									nRatIrf2 += aRatIrf[Len(aRatIrf)][2][nCont]
									DbSkip()
								EndDo
								aDiff[1] 	:= nCont
								aPosDiff[1] := Len(aRatIrf)
							Endif
						Endif
					Endif
					
					If !lAglut
						If M->E2_PIS > 0
							Aadd(aRatPis, { M->E2_PIS * (aColsSev[nX][3] / 100), {} })	// Grava o valor informado
							nRatPis1 += aRatPis[Len(aRatPis)][1]
				        	nCont := 0
			
							If Select("SEZTMP") > 0 .And. aColsSev[nX][4] == "1"
			
								dbSelectArea("SEZTMP")
								// busca natureza no arquivo TMP de Mult Nat C.Custo
								If dbSeek(aColsSev[nX][1]) 
									While !Eof() .and. SEZTMP->EZ_NATUREZ == aColsSev[nX][1]
										Aadd(aRatPis[Len(aRatPis)][2], Round(NoRound((M->E2_PIS * (aColsSev[nX][3] / 100)) * SEZTMP->EZ_PERC, 2), 3)) // Grava o valor informado								
										nCont ++
										nRatPis2 += aRatPis[Len(aRatPis)][2][nCont]
										DbSkip()
									EndDo
									aDiff[2]		:= nCont
									aPosDiff[2] := Len(aRatPis)
								Endif
							Endif
						Endif
						If M->E2_COFINS > 0
							Aadd(aRatCof, { M->E2_COFINS * (aColsSev[nX][3] / 100), {} })	// Grava o valor informado
							nRatCof1 += aRatCof[Len(aRatCof)][1]
				        	nCont := 0
			
							If Select("SEZTMP") > 0 .And. aColsSev[nX][4] == "1"
			
								dbSelectArea("SEZTMP")
								// busca natureza no arquivo TMP de Mult Nat C.Custo
								If dbSeek(aColsSev[nX][1]) 
									While !Eof() .and. SEZTMP->EZ_NATUREZ == aColsSev[nX][1]
										Aadd(aRatCof[Len(aRatCof)][2], Round(NoRound((M->E2_COFINS * (aColsSev[nX][3] / 100)) * SEZTMP->EZ_PERC, 2), 3)) // Grava o valor informado								
										nCont ++
										nRatCof2 += aRatCof[Len(aRatCof)][2][nCont]
										DbSkip()
									EndDo
									aDiff[3]		:= nCont
									aPosDiff[3] := Len(aRatCof)
								Endif
							Endif
						Endif
						If M->E2_CSLL > 0
							Aadd(aRatCsl, { M->E2_CSLL * (aColsSev[nX][3] / 100), {} })	// Grava o valor informado
							nRatCsl1 += aRatCsl[Len(aRatCsl)][1]
				        	nCont := 0
		
							If Select("SEZTMP") > 0 .And. aColsSev[nX][4] == "1"
			
								dbSelectArea("SEZTMP")
								// busca natureza no arquivo TMP de Mult Nat C.Custo
								If dbSeek(aColsSev[nX][1]) 
									While !Eof() .and. SEZTMP->EZ_NATUREZ == aColsSev[nX][1]
										Aadd(aRatCsl[Len(aRatCsl)][2], Round(NoRound((M->E2_CSLL * (aColsSev[nX][3] / 100)) * SEZTMP->EZ_PERC, 2), 3)) // Grava o valor informado								
										nCont ++
										nRatCsl2 += aRatCsl[Len(aRatCsl)][2][nCont]
										DbSkip()
									EndDo
									aDiff[4]		:= nCont
									aPosDiff[4] := Len(aRatCsl)
								Endif
							Endif
						EndIF
					Else
						Aadd(aRatPis, { (M->E2_PIS + M->E2_COFINS + M->E2_CSLL) * (aColsSev[nX][3] / 100), {} })	// Grava o valor informado					
						nRatPis1 += aRatPis[Len(aRatPis)][1]
			        	nCont := 0

						If Select("SEZTMP") > 0 .And. aColsSev[nX][4] == "1"

							dbSelectArea("SEZTMP")
							// busca natureza no arquivo TMP de Mult Nat C.Custo
							If dbSeek(aColsSev[nX][1])
								While !Eof() .and. SEZTMP->EZ_NATUREZ == aColsSev[nX][1]
									Aadd(aRatPis[Len(aRatPis)][2], Round(NoRound(((M->E2_PIS + M->E2_COFINS + M->E2_CSLL) * (aColsSev[nX][3] / 100)) * SEZTMP->EZ_PERC, 2), 3)) // Grava o valor informado
									nCont ++
									nRatPis2 += aRatPis[Len(aRatPis)][2][nCont]
									DbSkip()
								EndDo
								aDiff[2]		:= nCont
								aPosDiff[2] := Len(aRatPis)

							Endif
						Endif
					Endif
					
					If M->E2_INSS > 0
						Aadd(aRatIns, { M->E2_INSS * (aColsSev[nX][3] / 100), {} })	// Grava o valor informado
						nRatIns1 += aRatIns[Len(aRatIns)][1]

						If Select("SEZTMP") > 0 .And. aColsSev[nX][4] == "1"

							dbSelectArea("SEZTMP")

				        	nCont := 0
							// busca natureza no arquivo TMP de Mult Nat C.Custo
							If dbSeek(aColsSev[nX][1])
								While !Eof() .and. SEZTMP->EZ_NATUREZ == aColsSev[nX][1]
									Aadd(aRatIns[Len(aRatIns)][2], Round(NoRound((M->E2_INSS * (aColsSev[nX][3] / 100)) * SEZTMP->EZ_PERC, 3), 2)) // Grava o valor informado
									nCont ++
									nRatIns2 += aRatIns[Len(aRatIns)][2][nCont]
									DbSkip()
								EndDo
								aDiff[5]		:= nCont
								aPosDiff[5] := Len(aRatIns)
							Endif
						Endif
					Endif
					If M->E2_ISS > 0
						Aadd(aRatIss, { M->E2_ISS * (aColsSev[nX][3] / 100), {} })	// Grava o valor informado
						nRatIss1 += aRatIss[Len(aRatIss)][1]

						If 	Select("SEZTMP") > 0 .And. aColsSev[nX][4] == "1"

							dbSelectArea("SEZTMP")
				        	nCont := 0
							// busca natureza no arquivo TMP de Mult Nat C.Custo
							If dbSeek(aColsSev[nX][1])
								While !Eof() .and. SEZTMP->EZ_NATUREZ == aColsSev[nX][1]
									Aadd(aRatIss[Len(aRatIss)][2], Round(NoRound((M->E2_ISS * (aColsSev[nX][3] / 100)) * SEZTMP->EZ_PERC, 3), 2)) // Grava o valor informado
									nCont ++
									nRatIss2 += aRatIss[Len(aRatIss)][2][nCont]
									DbSkip()
								EndDo
								aDiff[6] 		:= nCont
								aPosDiff[6]    := Len(aRatIss)
							Endif
						Endif

					Endif

					If cPaisLoc == "BRA" .And. M->E2_CIDE > 0
						Aadd(aRatCid, { M->E2_CIDE * (aColsSev[nX][3] / 100), {} })	// Grava o valor informado
						nRatCid1 += aRatCid[Len(aRatCid)][1]

						If 	Select("SEZTMP") > 0 .And. aColsSev[nX][4] == "1"

							dbSelectArea("SEZTMP")
				        	nCont := 0
							// busca natureza no arquivo TMP de Mult Nat C.Custo
							If dbSeek(aColsSev[nX][1])
								While !Eof() .and. SEZTMP->EZ_NATUREZ == aColsSev[nX][1]
									Aadd(aRatCid[Len(aRatCid)][2], Round(NoRound((M->E2_CIDE * (aColsSev[nX][3] / 100)) * SEZTMP->EZ_PERC, 3), 2)) // Grava o valor informado
									nCont ++
									nRatCid2 += aRatCid[Len(aRatCid)][2][nCont]
									DbSkip()
								EndDo
								aDiff[6] 		:= nCont
								aPosDiff[6]    := Len(aRatCid)
							Endif
						Endif

					Endif					
				Endif
			Next

			If Len(aRatIrf) > 0 .And. nRatIrf1 <> M->E2_IRRF
				If nRatIrf1 > M->E2_IRRF
					aRatIrf[Len(aRatIrf)][1] -= nRatIrf1 - M->E2_IRRF
				Else
					aRatIrf[Len(aRatIrf)][1] += M->E2_IRRF - nRatIrf1
				Endif
			Endif

			If !lRatCCParcial .and. aDiff[1] > 0 .And. Len(aRatIrf) > 0 .And. nRatIrf2 <> M->E2_IRRF .And. nRatIrf2 > 0
				If nRatIrf2 > M->E2_IRRF
					aRatIrf[aPosDiff[1]][2][aDiff[1]] -= nRatIrf2 - M->E2_IRRF
				Else
					aRatIrf[aPosDiff[1]][2][aDiff[1]] += M->E2_IRRF - nRatIrf2
				Endif
			Endif

			If !lAglut			
				If Len(aRatPis) > 0 .And. nRatPis1 <> M->E2_PIS 
					If nRatPis1 > M->E2_PIS
						aRatPis[Len(aRatPis)][1] -= nRatPis1 - M->E2_PIS
					Else
						aRatPis[Len(aRatPis)][1] += M->E2_PIS - nRatPis1
					Endif
				Endif
			
				If !lRatCCParcial .and. aDiff[2] > 0 .And. Len(aRatPis) > 0 .And. nRatPis2 <> M->E2_PIS .And. nRatPis2 > 0
					If nRatPis2 > M->E2_PIS
						aRatPis[aPosDiff[2]][2][aDiff[2]] -= nRatPis2 - M->E2_PIS
					Else
						aRatPis[aPosDiff[2]][2][aDiff[2]] += M->E2_PIS - nRatPis2
					Endif
				Endif
				
				If Len(aRatCof) > 0 .And. nRatCof1 <> M->E2_COFINS
					If nRatCof1 > M->E2_COFINS
						aRatCof[Len(aRatCof)][1] -= nRatCof1 - M->E2_COFINS
					Else
						aRatCof[Len(aRatCof)][1] += M->E2_COFINS - nRatCof1
		
					Endif
				Endif
				
				If !lRatCCParcial .and. aDiff[3] > 0 .And. Len(aRatCof) > 0 .And. nRatCof2 <> M->E2_COFINS .And. nRatCof2 > 0
					If nRatCof2 > M->E2_COFINS
						aRatCof[aPosDiff[3]][2][aDiff[3]] -= nRatCof2 - M->E2_COFINS
					Else
						aRatCof[aPosDiff[3]][2][aDiff[3]] += M->E2_COFINS - nRatCof2
					Endif
				Endif
				
				If Len(aRatCsl) > 0 .And. nRatCsl1 <> M->E2_CSLL
					If nRatCsl1 > M->E2_CSLL
						aRatCsl[Len(aRatCsl)][1] -= nRatCsl1 - M->E2_CSLL
					Else
						aRatCsl[Len(aRatCsl)][1] += M->E2_CSLL - nRatCsl1
					Endif
				Endif

			
				If !lRatCCParcial .and. aDiff[4] > 0 .And. Len(aRatCsl) > 0 .And. nRatCsl2 <> M->E2_CSLL .And. nRatCSL2 > 0
					If nRatCsl2 > M->E2_CSLL
						aRatCsl[aPosDiff[4]][2][aDiff[4]] -= nRatCsl2 - M->E2_CSLL
					Else
						aRatCsl[aPosDiff[4]][2][aDiff[4]] += M->E2_CSLL - nRatCsl2
					Endif
				Endif								
			EndIf
			
			If Len(aRatIns) > 0 .And. nRatIns1 <> M->E2_INSS
				If nRatIns1 > M->E2_INSS
					aRatIns[Len(aRatIns)][1] -= nRatIns1 - M->E2_INSS
				Else
					aRatIns[Len(aRatIns)][1] += M->E2_INSS - nRatIns1

				Endif
			Endif
			If !lRatCCParcial .and. aDiff[5] > 0 .And. Len(aRatIns) > 0 .And. nRatIns2 <> M->E2_INSS .And. nRatIns2 > 0
				If nRatIns2 > M->E2_INSS
					aRatIns[aPosDiff[5]][2][aDiff[5]] -= nRatIns2 - M->E2_INSS
				Else
					aRatIns[aPosDiff[5]][2][aDiff[5]] += M->E2_INSS - nRatIns2
				Endif
			Endif

			If Len(aRatIss) > 0 .And. nRatIss1 <> M->E2_ISS
				If nRatIss1 > M->E2_ISS
					aRatIss[Len(aRatIss)][1] -= nRatIss1 - M->E2_ISS
				Else
					aRatIss[Len(aRatIss)][1] += M->E2_ISS - nRatIss1

				Endif
			Endif

			If !lRatCCParcial .and. aDiff[6] > 0 .And. Len(aRatIss) > 0 .And. nRatIss2 <> M->E2_ISS .And. nRatIss2 > 0
				If nRatIss2 > M->E2_ISS
					aRatIss[aPosDiff[6]][2][aDiff[6]] -= nRatIss2 - M->E2_ISS
				Else
					aRatIss[aPosDiff[6]][2][aDiff[6]] += M->E2_ISS - nRatIss2
				Endif
			Endif

			If Len(aRatCid) > 0 .And. nRatCid1 <> M->E2_CIDE
				If nRatIss1 > M->E2_CIDE
					aRatCid[Len(aRatCid)][1] -= nRatCid1 - M->E2_CIDE
				Else
					aRatCid[Len(aRatCid)][1] += M->E2_CIDE - nRatCid1

				Endif
			Endif

			If !lRatCCParcial .and. aDiff[6] > 0 .And. Len(aRatCid) > 0 .And. nRatCid2 <> M->E2_CIDE .And. nRatCid2 > 0
				If nRatCid2 > M->E2_CIDE
					aRatCid[aPosDiff[6]][2][aDiff[6]] -= nRatCid2 - M->E2_CIDE
				Else
					aRatCid[aPosDiff[6]][2][aDiff[6]] += M->E2_CIDE - nRatCid2
				Endif
			Endif
						
		Endif
	Endif

	// Inicia processo de gravacao das multiplas naturezas. O titulo deve estar gravado
	(cAlias)->(DbGoto(nRecno))
	nCont := 0


	If lFINRATAUT
		aRatRet := ExecBlock("FINRATAUT",.f.,.f.,{aHeaderSev, aColsSev})
		If ValType(aRatRet) == "A" .AND. Len(aRatRet) == 2
			aHeaderSev 	:= aRatRet[1]
			aColsSev 	:= aRatRet[2]
		Endif
	Endif
	
		//Gravação da chave FK7 para os rateios
	If cAlias=="SE1"	
		cChaveTit := xFilial("SE1",SE1->E1_FILORIG) + "|" +;
					SE1->E1_PREFIXO	+ "|" +;
					SE1->E1_NUM		+ "|" +;
					SE1->E1_PARCELA	+ "|" +;
					SE1->E1_TIPO		+ "|" +;
					SE1->E1_CLIENTE	+ "|" +;
					SE1->E1_LOJA
		cChaveFK7 := FINGRVFK7("SE1",cChaveTit)
	Else
		cChaveTit := xFilial("SE2",SE2->E2_FILORIG) + "|" +;
					SE2->E2_PREFIXO	+ "|" +;
					SE2->E2_NUM		+ "|" +;
					SE2->E2_PARCELA	+ "|" +;
					SE2->E2_TIPO		+ "|" +;
					SE2->E2_FORNECE	+ "|" +;
					SE2->E2_LOJA
		cChaveFK7 := FINGRVFK7("SE2",cChaveTit)
	Endif

	For nX := 1 To Len(aColsSev)
	   // Se a linha de aColsSev nao estiver deletada e o registro nao for
		// encontrado no SEV
		lCtbRatCC := .F.
		If	!aColsSev[nX][Len(aColsSev[nX])] .or. lAuto040
			If lGrvSev
				ExecBlock("MULTSEV", .F., .F., { 	nX, cChave, aColsSev[nX][2],;
													(aColsSev[nX][2] / nVlTit),;
													aColsSev[nX][1]  })
				DbSelectArea("SEV")
			Endif
			RecLock("SEV", .T. )

			// Grava todos os campos da tela
			aEval(aHeaderSev, {|e,ni| If(e[8] <> "M" .And. e[10] <> "V" .And. Alltrim(e[2]) != "EV_PERC", FieldPut(FieldPos(e[2]),aColsSev[nX][ni]),Nil) } )

			SEV->EV_FILIAL   := xFilial("SEV")
			SEV->EV_PREFIXO  := (cAlias)->&(cCampo + "_PREFIXO")
			SEV->EV_NUM      := (cAlias)->&(cCampo + "_NUM")
			SEV->EV_PARCELA  := (cAlias)->&(cCampo + "_PARCELA")
			SEV->EV_CLIFOR   := (cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))
			SEV->EV_LOJA     := (cAlias)->&(cCampo + "_LOJA")
			SEV->EV_TIPO     := (cAlias)->&(cCampo + "_TIPO")
			SEV->EV_NATUREZ  := aColsSev[nX][1] // Grava a natureza
			SEV->EV_VALOR    := aColsSev[nX][2] // Grava o valor informado
			// Grava o percentual (Como indice multiplicador, por esta razao nao
			// multiplica por 100 na gravacao, apenas na exibicao)
			SEV->EV_PERC     := If(ValType(aColsSev[nX][3]) <> "N", (Val(aColsSev[nX][3]) / 100), (aColsSev[nX][3] / 100))
			SEV->EV_RECPAG   := If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
			SEV->EV_RATEICC  := aColsSev[nX][4]  // Identificador de Rateio C Custo
			SEV->EV_IDENT	:= "1"   //rateio de inclusao
			SEV->EV_IDDOC    := cChaveFK7
			MsUnLock()

			If(lRatG050)
				ExecBlock("RATG050", .F., .F., { aColsSev })
			EndIf

			If lAtuSldNat
				AtuSldNat(SEV->EV_NATUREZ, (cAlias)->&(cCampo + "_VENCREA"), (cAlias)->&(cCampo + "_MOEDA"), "2", If(cAlias=="SE1","R","P"), SEV->EV_VALOR,SEV->EV_PERC * (cAlias)->&(cCampo + "_VLCRUZ"), "+",,FunName(),"SEV",SEV->(Recno()))
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Gera o lancamento no PCO com os dados do lancamento de multi-natureza (05) ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (cAlias)->&(cCampo + "_MULTNAT") == "1"	// Campo multi-natureza igual a "Sim"
				If cAlias == "SE1"
					PCODetLan( "000001", "04", "FINA040" )	// Contas a Receber
				Else
					PCODetLan( "000002", "04", "FINA050" )	// Contas a Pagar
				EndIf
			EndIf

			SEZ->(dbSetOrder(4))
			If Select("SEZTMP") > 0 .And. aColsSev[nX][4] == "1" .and.;   // Possui rateio c.Custo
	        		(!SEZ->(MsSeek(xFilial("SEZ")+;
				(cAlias)->&(cCampo + "_PREFIXO")+;
				(cAlias)->&(cCampo + "_NUM")+;
				(cAlias)->&(cCampo + "_PARCELA")+;
				(cAlias)->&(cCampo + "_TIPO")+;
				(cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))+;
				(cAlias)->&(cCampo + "_LOJA")+;
				aColsSev[nX][1]+"1")))

				//Gravacao dos dados do rateio C.custo
				dbSelectArea("SEZTMP")
				aStruEZTMP := SEZTMP->(DbStruct())

				// busca natureza no arquivo TMP de Mult Nat C.Custo
				If dbSeek(aColsSev[nX][1])
					nCont := nX
					nCont1 := nCont2 := nCont3 := nCont4 := nCont5 := nCont6 := nCont7 := 0
					While !Eof() .and. SEZTMP->EZ_NATUREZ == aColsSev[nX][1]
						VALOR 	:= SEZ->EZ_VALOR		// Valor Principal
						VALOR2	:= 0		// Irf
						VALOR3	:= 0		// Inss
						VALOR4	:= 0		// Iss
						VALOR5	:= 0		// Pis
						VALOR6	:= 0		// Cofins
						VALOR7	:= 0		// Csll

						// Verifica se não foi um movimento deletado no aColsSev Mult Nat C.Custo e
						If !(SEZTMP->EZ_FLAG)
							If lGrvSez
								If SEZTMP->EZ_RECNO = 0
									SEZ->(DbGoBottom())
									SEZ->(DbSkip())
								Else
									SEZ->(DbGoto(SEZTMP->EZ_RECNO))
								Endif
								ExecBlock("MULTSEZ", .F., .F., { 3, cChave })
								DbSelectArea("SEZ")
							Endif
							If SEZTMP->EZ_RECNO = 0
								SEZ->(RecLock("SEZ",.T.))
							Else
								SEZ->(DbGoto(SEZTMP->EZ_RECNO))
								If SEZ->(Deleted())			// Alteracao de natureza
									SEZ->(RecLock("SEZ",.T.))
								Else
									SEZ->(RecLock("SEZ",.F.))
								Endif
							Endif
							// Grava todos os campos do temporario no arquivo principal
							aEval(aStruEZTMP, { |e| If(  Alltrim(e[2]) != "EV_PERC", SEZ->(FieldPut(FieldPos(e[1]),SEZTMP->(FieldGet(FieldPos(e[1]))))), Nil) } )

							SEZ->EZ_FILIAL		:= xFilial("SEZ")
							SEZ->EZ_PREFIXO	:= (cAlias)->&(cCampo + "_PREFIXO")
							SEZ->EZ_NUM			:= (cAlias)->&(cCampo + "_NUM")
							SEZ->EZ_PARCELA	:= (cAlias)->&(cCampo + "_PARCELA")
							SEZ->EZ_CLIFOR		:= (cAlias)->&(cCampo + If(cAlias == "SE1", "_CLIENTE","_FORNECE"))
							SEZ->EZ_LOJA		:= (cAlias)->&(cCampo + "_LOJA")
							SEZ->EZ_TIPO		:= (cAlias)->&(cCampo + "_TIPO")
							SEZ->EZ_NATUREZ	:= aColsSev[nX][1] // Grava a natureza
							SEZ->EZ_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
							SEZ->EZ_IDENT	:= "1"   //rateio de inclusao
							SEZ->EZ_IDDOC		:= cChaveFK7
							MsUnlock()

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Gera o lancamento no PCO com os dados do lancamento de C.C. por natureza (06) ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If cAlias == "SE1"
								PCODetLan( "000001", "05", "FINA040" )
							Else
								PCODetLan( "000002", "05", "FINA050" )
							EndIf

							// Contabilizacao das MultiNat com Rateio C.Custo
							// Somente sera contabilizado se existir o LP 500/510 e o 506/508 ou
							// LP 520/530 e 536/537 se for baixa
							If lContabiliza .And. lPadrao .and. lPadraoCC .And. aColsSev[nX][4] == "1"
								VALOR 	:= SEZ->EZ_VALOR		// Valor Principal
								VALOR2	:= 0					// Irf
								VALOR3	:= 0					// Inss
								VALOR4	:= 0					// Iss
								VALOR5	:= 0					// Pis
								VALOR6	:= 0					// Cofins
								VALOR7	:= 0					// Csll

								// Contabiliza pelo SEZ
								If nHdlPrv <= 0
									nHdlPrv:=HeadProva(cLote,cOrigem,Substr(cUsuario,7,6),@cArquivo)
								Endif
								dbSelectArea( "SED" )
								MsSeek( xFilial("SED")+SEZ->EZ_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
								dbSelectArea("SEZ")
								If nHdlPrv > 0
									nTotal+=DetProva(nHdlPrv,cPadraoCC,cOrigem,cLote)
								Endif
								SEZ->(RecLock("SEZ"))
								SEZ->EZ_LA    := "S"
								MsUnlock()
								lCtbRatCC := .T.
							Endif

							If cAlias = "SE2" .And. lRatImpostos
								//Irrf
								If M->E2_IRRF > 0 .AND. LEN(aRatIrf[nCont][2]) > 0
									nCont1 ++
									If lGrvSez
										SEZTMP->EZ_NATUREZ		:= aColsSev[nX][1] // Grava a natureza
										SEZTMP->EZ_VALOR		:= aRatIrf[nCont][2][nCont1] // Grava o valor informado
										SEZTMP->EZ_PERC			:= SEZTMP->EZ_PERC
										ExecBlock("MULTSEZ", .F., .F., { 3, cChaveIrf })
										DbSelectArea("SEZ")
									Endif
									SEZ->(RecLock("SEZ",.T.))

									// Grava todos os campos do temporario no arquivo principal
									aEval(aStruEZTMP, { |e| If(  Alltrim(e[2]) != "EV_PERC", SEZ->(FieldPut(FieldPos(e[1]),SEZTMP->(FieldGet(FieldPos(e[1]))))), Nil) } )

									SEZ->EZ_FILIAL		:= xFilial("SEZ")
									SEZ->EZ_PREFIXO		:= (cAlias)->&(cCampo + "_PREFIXO")
									SEZ->EZ_NUM			:= (cAlias)->&(cCampo + "_NUM")
									SEZ->EZ_PARCELA		:= SE2->E2_PARCIR
									SEZ->EZ_CLIFOR		:= _cMvUniao
									SEZ->EZ_LOJA		:= cLojaImp
									SEZ->EZ_TIPO		:= Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
									SEZ->EZ_NATUREZ		:= aColsSev[nX][1] // Grava a natureza
									SEZ->EZ_VALOR		:= aRatIrf[nCont][2][nCont1] // Grava o valor informado
									SEZ->EZ_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
									SEZ->EZ_IDENT		:= "1"  //Rateio de inclusao
																		//Gravação da chave FK7 para os rateios
									cChaveTit := xFilial(cAlias) 	+ "|" +;
												SEZ->EZ_PREFIXO	+ "|" +;
												SEZ->EZ_NUM		+ "|" +;
												SEZ->EZ_PARCELA	+ "|" +;
												SEZ->EZ_TIPO		+ "|" +;
												SEZ->EZ_CLIFOR	+ "|" +;
												SEZ->EZ_LOJA
									cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

									SEZ->EZ_IDDOC := cChvImpFK7
									
									MsUnlock()

									// Contabilizacao das MultiNat com Rateio C.Custo
									If lContabiliza .And. lPadraoCC .And. aColsSev[nX][4] == "1"
										// Contabiliza pelo SEZ
										dbSelectArea( "SED" )
										MsSeek( xFilial("SED")+SEZ->EZ_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
										dbSelectArea("SEZ")
										If nHdlPrv > 0
											VALOR		:= 0					// Valor Principal
											VALOR2	:= SEZ->EZ_VALOR		// Irf
											VALOR3	:= 0					// Inss
											VALOR4	:= 0					// Iss
											VALOR5	:= 0					// Pis
											VALOR6	:= 0					// Cofins
											VALOR7	:= 0					// Csll
											nTotal+=DetProva(nHdlPrv,cPadraoCC,cOrigem,cLote)
										Endif
										SEZ->(RecLock("SEZ"))
										SEZ->EZ_LA    := "S"
										MsUnlock()
									Endif
								Endif
								//Pis
								If M->E2_PIS > 0 .AND. LEN(aRatPis[nCont][2]) > 0
									nCont4 ++
									If lGrvSez
										SEZTMP->EZ_NATUREZ		:= aColsSev[nX][1] // Grava a natureza
										SEZTMP->EZ_VALOR		:= aRatPis[nCont][2][nCont4] // Grava o valor informado
										SEZTMP->EZ_PERC			:= SEZTMP->EZ_PERC
										ExecBlock("MULTSEZ", .F., .F., { 3, cChavePis })
										DbSelectArea("SEZ")
									Endif
									SEZ->(RecLock("SEZ",.T.))

									// Grava todos os campos do temporario no arquivo principal
									aEval(aStruEZTMP, { |e| If(  Alltrim(e[2]) != "EV_PERC", SEZ->(FieldPut(FieldPos(e[1]),SEZTMP->(FieldGet(FieldPos(e[1]))))), Nil) } )

									SEZ->EZ_FILIAL		:= xFilial("SEZ")
									SEZ->EZ_PREFIXO		:= (cAlias)->&(cCampo + "_PREFIXO")
									SEZ->EZ_NUM			:= (cAlias)->&(cCampo + "_NUM")
									SEZ->EZ_PARCELA		:= SE2->E2_PARCPIS
									SEZ->EZ_CLIFOR		:= _cMvUniao
									SEZ->EZ_LOJA		:= cLojaImp
									SEZ->EZ_TIPO		:= Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
									SEZ->EZ_NATUREZ		:= aColsSev[nX][1] // Grava a natureza
									SEZ->EZ_VALOR		:= aRatPis[nCont][2][nCont4] // Grava o valor informado
									SEZ->EZ_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
									SEZ->EZ_IDENT		:= "1"  //Rateio de inclusao
									//Gravação da chave FK7 para os rateios
									cChaveTit := xFilial(cAlias) 	+ "|" +;
												SEZ->EZ_PREFIXO	+ "|" +;
												SEZ->EZ_NUM		+ "|" +;
												SEZ->EZ_PARCELA	+ "|" +;
												SEZ->EZ_TIPO		+ "|" +;
												SEZ->EZ_CLIFOR	+ "|" +;
												SEZ->EZ_LOJA
									cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

									SEZ->EZ_IDDOC := cChvImpFK7
									MsUnlock()

									// Contabilizacao das MultiNat com Rateio C.Custo
									If lContabiliza .And. lPadraoCC .And. aColsSev[nX][4] == "1"
										// Contabiliza pelo SEZ
										dbSelectArea( "SED" )
										MsSeek( xFilial("SED")+SEZ->EZ_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
										dbSelectArea("SEZ")
										If nHdlPrv > 0
											VALOR		:= 0					// Valor Principal
											VALOR2	:= 0					// Irf
											VALOR3	:= 0					// Inss
											VALOR4	:= 0					// Iss
											VALOR5	:= SEZ->EZ_VALOR	// Pis
											VALOR6	:= 0					// Cofins
											VALOR7	:= 0					// Csll
											nTotal+=DetProva(nHdlPrv,cPadraoCC,cOrigem,cLote)
										Endif
										SEZ->(RecLock("SEZ"))
										SEZ->EZ_LA    := "S"
										MsUnlock()
									Endif
								Endif

	
								If !lAglut
								//Cofins
								If M->E2_COFINS > 0 .AND. LEN(aRatCof[nCont][2]) > 0
									nCont5 ++
									If lGrvSez
										SEZTMP->EZ_NATUREZ	:= aColsSev[nX][1] // Grava a natureza
										SEZTMP->EZ_VALOR	:= aRatCof[nCont][2][nCont5] // Grava o valor informado
										SEZTMP->EZ_PERC		:= SEZTMP->EZ_PERC
										ExecBlock("MULTSEZ", .F., .F., { 3, cChaveCof })
										DbSelectArea("SEZ")
									Endif
									SEZ->(RecLock("SEZ",.T.))

									// Grava todos os campos do temporario no arquivo principal
									aEval(aStruEZTMP, { |e| If(  Alltrim(e[2]) != "EV_PERC", SEZ->(FieldPut(FieldPos(e[1]),SEZTMP->(FieldGet(FieldPos(e[1]))))), Nil) } )

									SEZ->EZ_FILIAL		:= xFilial("SEZ")
									SEZ->EZ_PREFIXO		:= (cAlias)->&(cCampo + "_PREFIXO")
									SEZ->EZ_NUM			:= (cAlias)->&(cCampo + "_NUM")
									SEZ->EZ_PARCELA		:= SE2->E2_PARCCOF
									SEZ->EZ_CLIFOR		:= _cMvUniao
									SEZ->EZ_LOJA		:= cLojaImp
									SEZ->EZ_TIPO		:= Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
									SEZ->EZ_NATUREZ		:= aColsSev[nX][1] // Grava a natureza
									SEZ->EZ_VALOR		:= aRatCof[nCont][2][nCont5] // Grava o valor informado
									SEZ->EZ_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
									SEZ->EZ_IDENT		:= "1"  //Rateio de inclusao
									//Gravação da chave FK7 para os rateios
									cChaveTit := xFilial(cAlias) 	+ "|" +;
												SEZ->EZ_PREFIXO	+ "|" +;
												SEZ->EZ_NUM		+ "|" +;
												SEZ->EZ_PARCELA	+ "|" +;
												SEZ->EZ_TIPO		+ "|" +;
												SEZ->EZ_CLIFOR	+ "|" +;
												SEZ->EZ_LOJA
									cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

									SEZ->EZ_IDDOC := cChvImpFK7
									MsUnlock()

									// Contabilizacao das MultiNat com Rateio C.Custo
									If lContabiliza .And. lPadraoCC .And. aColsSev[nX][4] == "1"
										// Contabiliza pelo SEZ
										dbSelectArea( "SED" )
										MsSeek( xFilial("SED")+SEZ->EZ_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
										dbSelectArea("SEZ")
										If nHdlPrv > 0
											VALOR		:= 0					// Valor Principal
											VALOR2	:= 0					// Irf
											VALOR3	:= 0					// Inss
											VALOR4	:= 0					// Iss
											VALOR5	:= 0					// Pis
											VALOR6	:= SEZ->EZ_VALOR // Cofins
											VALOR7	:= 0					// Csll
											nTotal+=DetProva(nHdlPrv,cPadraoCC,cOrigem,cLote)
										Endif
										SEZ->(RecLock("SEZ"))
										SEZ->EZ_LA    := "S"
										MsUnlock()
									Endif
								Endif

								//CSLL
								If M->E2_CSLL > 0 .AND. LEN(aRatCof[nCont][2]) > 0
									nCont6 ++
									If lGrvSez
										SEZTMP->EZ_NATUREZ	:= aColsSev[nX][1] // Grava a natureza
										SEZTMP->EZ_VALOR	:= aRatCsl[nCont][2][nCont6] // Grava o valor informado
										SEZTMP->EZ_PERC		:= SEZTMP->EZ_PERC
										ExecBlock("MULTSEZ", .F., .F., { 3, cChaveCsl })
										DbSelectArea("SEZ")
									Endif
									SEZ->(RecLock("SEZ",.T.))

									// Grava todos os campos do temporario no arquivo principal
									aEval(aStruEZTMP, { |e| If(  Alltrim(e[2]) != "EV_PERC", SEZ->(FieldPut(FieldPos(e[1]),SEZTMP->(FieldGet(FieldPos(e[1]))))), Nil) } )

									SEZ->EZ_FILIAL		:= xFilial("SEZ")
									SEZ->EZ_PREFIXO		:= (cAlias)->&(cCampo + "_PREFIXO")
									SEZ->EZ_NUM			:= (cAlias)->&(cCampo + "_NUM")
									SEZ->EZ_PARCELA		:= SE2->E2_PARCSLL
									SEZ->EZ_CLIFOR		:= _cMvUniao
									SEZ->EZ_LOJA		:= cLojaImp
									SEZ->EZ_TIPO		:= Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
									SEZ->EZ_NATUREZ		:= aColsSev[nX][1] // Grava a natureza
									SEZ->EZ_VALOR		:= aRatCsl[nCont][2][nCont6] // Grava o valor informado
									SEZ->EZ_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
									SEZ->EZ_IDENT		:= "1"  //Rateio de inclusao
									//Gravação da chave FK7 para os rateios
									cChaveTit := xFilial(cAlias) 	+ "|" +;
												SEZ->EZ_PREFIXO	+ "|" +;
												SEZ->EZ_NUM		+ "|" +;
												SEZ->EZ_PARCELA	+ "|" +;
												SEZ->EZ_TIPO		+ "|" +;
												SEZ->EZ_CLIFOR	+ "|" +;
												SEZ->EZ_LOJA
									cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

									SEZ->EZ_IDDOC := cChvImpFK7
		
									MsUnlock()

									// Contabilizacao das MultiNat com Rateio C.Custo
									If lContabiliza .And. lPadraoCC .And. aColsSev[nX][4] == "1"
										// Contabiliza pelo SEZ
										dbSelectArea( "SED" )
										MsSeek( xFilial("SED")+SEZ->EZ_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
										dbSelectArea("SEZ")
										If nHdlPrv > 0
											VALOR		:= 0					// Valor Principal
											VALOR2	:= 0					// Irf
											VALOR3	:= 0					// Inss
											VALOR4	:= 0					// Iss
											VALOR5	:= 0					// Pis
											VALOR6	:= 0					// Cofins
											VALOR7	:= SEZ->EZ_VALOR	// Csll
											nTotal+=DetProva(nHdlPrv,cPadraoCC,cOrigem,cLote)
										Endif
										SEZ->(RecLock("SEZ"))
										SEZ->EZ_LA    := "S"
										MsUnlock()
									Endif
								Endif
								Endif

								If M->E2_INSS > 0 .AND. LEN(aRatIns[nCont][2]) > 0
									nCont2 ++
									If lGrvSez
										SEZTMP->EZ_NATUREZ		:= aColsSev[nX][1] // Grava a natureza
										SEZTMP->EZ_VALOR		:= aRatIns[nCont][2][nCont2] // Grava o valor informado
										SEZTMP->EZ_PERC		:= SEZTMP->EZ_PERC
										ExecBlock("MULTSEZ", .F., .F., { 3, cChaveIns })
										DbSelectArea("SEZ")
									Endif

									SEZ->(RecLock("SEZ",.T.))

									// Grava todos os campos do temporario no arquivo principal
									aEval(aStruEZTMP, { |e| If(  Alltrim(e[2]) != "EV_PERC", SEZ->(FieldPut(FieldPos(e[1]),SEZTMP->(FieldGet(FieldPos(e[1]))))), Nil) } )

									SEZ->EZ_FILIAL		:= xFilial("SEZ")
									SEZ->EZ_PREFIXO		:= (cAlias)->&(cCampo + "_PREFIXO")
									SEZ->EZ_NUM			:= (cAlias)->&(cCampo + "_NUM")
									SEZ->EZ_PARCELA		:= SE2->E2_PARCINS
									SEZ->EZ_CLIFOR		:= _cMvFInss
									SEZ->EZ_LOJA		:= cLojaImp
									SEZ->EZ_TIPO		:= Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"INA",MVINSS)
									SEZ->EZ_NATUREZ		:= aColsSev[nX][1] // Grava a natureza
									SEZ->EZ_VALOR		:= aRatIns[nCont][2][nCont2] // Grava o valor informado
									SEZ->EZ_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
									SEZ->EZ_IDENT		:= "1"  //Rateio de inclusao
									//Gravação da chave FK7 para os rateios
									cChaveTit := xFilial(cAlias) 	+ "|" +;
												SEZ->EZ_PREFIXO	+ "|" +;
												SEZ->EZ_NUM		+ "|" +;
												SEZ->EZ_PARCELA	+ "|" +;
												SEZ->EZ_TIPO		+ "|" +;
												SEZ->EZ_CLIFOR	+ "|" +;
												SEZ->EZ_LOJA
									cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

									SEZ->EZ_IDDOC := cChvImpFK7
									MsUnlock()

									// Contabilizacao das MultiNat com Rateio C.Custo
									If lContabiliza .And. lPadraoCC .And. aColsSev[nX][4] == "1"
										// Contabiliza pelo SEZ
										dbSelectArea( "SED" )
										MsSeek( xFilial("SED")+SEZ->EZ_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
										dbSelectArea("SEZ")
										If nHdlPrv > 0
											VALOR 	:= 0					// Valor Principal
											VALOR2  := 0					// Irf
											VALOR3  := SEZ->EZ_VALOR		// Inss
											VALOR4  := 0					// Iss
											VALOR5	:= 0					// Pis
											VALOR6	:= 0					// Cofins
											VALOR7	:= 0					// Csll
											nTotal+=DetProva(nHdlPrv,cPadraoCC,cOrigem,cLote)
										Endif
										SEZ->(RecLock("SEZ"))
										SEZ->EZ_LA    := "S"
										MsUnlock()
									Endif
								Endif
								If M->E2_ISS > 0 .AND. LEN(aRatIss[nCont][2]) > 0
									nCont3 ++
									If lGrvSez
										SEZTMP->EZ_NATUREZ		:= aColsSev[nX][1] // Grava a natureza
										SEZTMP->EZ_VALOR		:= aRatIss[nCont][2][nCont3] // Grava o valor informado
										SEZTMP->EZ_PERC		:= SEZTMP->EZ_PERC
										ExecBlock("MULTSEZ", .F., .F., { 3, cChaveIss })
										DbSelectArea("SEZ")
									Endif

									SEZ->(RecLock("SEZ",.T.))

									// Grava todos os campos do temporario no arquivo principal
									aEval(aStruEZTMP, { |e| If(  Alltrim(e[2]) != "EV_PERC", SEZ->(FieldPut(FieldPos(e[1]),SEZTMP->(FieldGet(FieldPos(e[1]))))), Nil) } )

									SEZ->EZ_FILIAL		:= xFilial("SEZ")
									SEZ->EZ_PREFIXO		:= (cAlias)->&(cCampo + "_PREFIXO")
									SEZ->EZ_NUM			:= (cAlias)->&(cCampo + "_NUM")
									SEZ->EZ_PARCELA		:= SE2->E2_PARCISS
									SEZ->EZ_CLIFOR		:= _cMvMunic
									SEZ->EZ_LOJA		:= cLojaImp
									SEZ->EZ_TIPO		:= MVISS
									SEZ->EZ_NATUREZ		:= aColsSev[nX][1] // Grava a natureza
									SEZ->EZ_VALOR		:= aRatIss[nCont][2][nCont3] // Grava o valor informado
									SEZ->EZ_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
									SEZ->EZ_IDENT		:= "1"  //Rateio de inclusao
									//Gravação da chave FK7 para os rateios
									cChaveTit := xFilial(cAlias) 	+ "|" +;
												SEZ->EZ_PREFIXO	+ "|" +;
												SEZ->EZ_NUM		+ "|" +;
												SEZ->EZ_PARCELA	+ "|" +;
												SEZ->EZ_TIPO		+ "|" +;
												SEZ->EZ_CLIFOR	+ "|" +;
												SEZ->EZ_LOJA
									cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

									SEZ->EZ_IDDOC := cChvImpFK7
									MsUnlock()

									// Contabilizacao das MultiNat com Rateio C.Custo
									If lContabiliza .And. lPadraoCC .And. aColsSev[nX][4] == "1"
										// Contabiliza pelo SEZ
										dbSelectArea( "SED" )
										MsSeek( xFilial("SED")+SEZ->EZ_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
										dbSelectArea("SEZ")
										If nHdlPrv > 0
											VALOR 	:= 0					// Valor Principal
											VALOR2  := 0					// Irf
											VALOR3  := 0					// Inss
											VALOR4  := SEZ->EZ_VALOR		// Iss
											VALOR5	:= 0					// Pis
											VALOR6	:= 0					// Cofins
											VALOR7	:= 0					// Csll
											nTotal+=DetProva(nHdlPrv,cPadraoCC,cOrigem,cLote)
										Endif
										SEZ->(RecLock("SEZ"))
										SEZ->EZ_LA    := "S"
										MsUnlock()
									Endif
								Endif
								If cPaisLoc == "BRA" .And. M->E2_CIDE > 0 .AND. LEN(aRatCid[nCont][2]) > 0
									nCont7 ++
									If lGrvSez
										SEZTMP->EZ_NATUREZ		:= aColsSev[nX][1] // Grava a natureza
										SEZTMP->EZ_VALOR		:= aRatCid[nCont][2][nCont7] // Grava o valor informado
										SEZTMP->EZ_PERC			:= SEZTMP->EZ_PERC
										ExecBlock("MULTSEZ", .F., .F., { 3, cChaveCid })
										DbSelectArea("SEZ")
									Endif

									SEZ->(RecLock("SEZ",.T.))

									// Grava todos os campos do temporario no arquivo principal
									aEval(aStruEZTMP, { |e| If(  Alltrim(e[2]) != "EV_PERC", SEZ->(FieldPut(FieldPos(e[1]),SEZTMP->(FieldGet(FieldPos(e[1]))))), Nil) } )

									SEZ->EZ_FILIAL		:= xFilial("SEZ")
									SEZ->EZ_PREFIXO		:= (cAlias)->&(cCampo + "_PREFIXO")
									SEZ->EZ_NUM			:= (cAlias)->&(cCampo + "_NUM")
									SEZ->EZ_PARCELA		:= SE2->E2_PARCCID
									SEZ->EZ_CLIFOR		:= _cMvFCide
									SEZ->EZ_LOJA		:= cLojaImp
									SEZ->EZ_TIPO		:= "CID"
									SEZ->EZ_NATUREZ		:= aColsSev[nX][1] // Grava a natureza
									SEZ->EZ_VALOR		:= aRatCid[nCont][2][nCont7] // Grava o valor informado
									SEZ->EZ_RECPAG		:= If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
									SEZ->EZ_IDENT		:= "1"  //Rateio de inclusao
									//Gravação da chave FK7 para os rateios
									cChaveTit := xFilial(cAlias) 	+ "|" +;
												SEZ->EZ_PREFIXO	+ "|" +;
												SEZ->EZ_NUM		+ "|" +;
												SEZ->EZ_PARCELA	+ "|" +;
												SEZ->EZ_TIPO		+ "|" +;
												SEZ->EZ_CLIFOR	+ "|" +;
												SEZ->EZ_LOJA
									cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

									SEZ->EZ_IDDOC := cChvImpFK7
									MsUnlock()

									// Contabilizacao das MultiNat com Rateio C.Custo
									If lContabiliza .And. lPadraoCC .And. aColsSev[nX][4] == "1"
										// Contabiliza pelo SEZ
										dbSelectArea( "SED" )
										MsSeek( xFilial("SED")+SEZ->EZ_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
										dbSelectArea("SEZ")
										If nHdlPrv > 0
											VALOR 	:= 0					// Valor Principal
											VALOR2  := 0					// Irf
											VALOR3  := 0					// Inss
											VALOR4  := 0					// Iss
											VALOR5	:= 0					// Pis
											VALOR6	:= 0					// Cofins
											VALOR7	:= 0					// Csll
											nTotal+=DetProva(nHdlPrv,cPadraoCC,cOrigem,cLote)
										Endif
										SEZ->(RecLock("SEZ"))
										SEZ->EZ_LA    := "S"
										MsUnlock()
									Endif
								Endif								
							Endif
						ElseIf SEZTMP->EZ_RECNO > 0

							SEZ->(DbGoto(SEZTMP->EZ_RECNO))

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Apaga o lancamento no PCO com os dados de multi-natureza x centro de custo (05) ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If cAlias == "SE1"
								PCODetLan( "000001", "05", "FINA040", .T. )
							Else
								PCODetLan( "000002", "05", "FINA050", .T. )
							EndIf

							SEZ->(RecLock("SEZ",.F.))
							SEZ->(DbDelete())
							SEZ->(MsUnlock())

							If lGrvSez
								ExecBlock("MULTSEZ", .F., .F., { 3, SEZ->EZ_PREFIXO +;
								SEZ->EZ_NUM + SEZ->EZ_PARCELA + SEZ->EZ_TIPO + SEZ->EZ_CLIFOR +;
								SEZ->EZ_LOJA })
								DbSelectArea("SEZ")
							Endif
						Endif

						dbSelectArea("SEZTMP")
						DbSkip()
	               Enddo
	      		Endif
				//Informo contabilizacao para SEV - Multi Naturezas
				dbSelectArea("SEV")
				If nTotal > 0
					RecLock("SEV")
					SEV->EV_LA    := "S"
					MsUnlock()
				Endif
				(cAlias)->(RestArea(aArea1))
			Endif
			If cAlias == "SE2"
				aDadosTit := {	(cAlias)->&(cCampo + "_PREFIXO"),;
									(cAlias)->&(cCampo + "_NUM"),;
									SE2->E2_PARCIR,;
									SE2->E2_PARCPIS,;
									SE2->E2_PARCCOF,;
									SE2->E2_PARCSLL,;
									SE2->E2_PARCINS,;
									SE2->E2_PARCISS,;
									SE2->E2_TIPO,;
									Iif(cPaisLoc =="BRA",SE2->E2_PARCCID,"")}
			Endif
			// Contabilizacao das MultiNat sem Rateio C.Custo
			If lContabiliza .And. lPadrao .And. !lCtbRatCC
				// Antes de desposicionar o SE2, copia o Historico para a variável StrLctPad, de
				// forma que o histórico do SE2 possa ser utilizado na contabilizacao de
				// multiplas naturezas.
				StrLctPad := If(cAlias=="SE2",SE2->E2_HIST,"")
				// A sintaxe do LP deve ser:
				// If(Se1/Se2->E2/E2_Multnat#"2",SEV->EV_VALOR,Se1/S22->_E1/E2_Valor)
				// Não desposiciona mais a SE2, para pegar as informacoes da SE2 na LP 510.
				// Não se deve utilizar a SE2/E1->E2/E1_VALOR se for multinatureza, deve fazer o tratamento para pegar da SEV
				
				DbSelectArea(cAlias)

				// Contabiliza pelo SEV
				If nHdlPrv <= 0
					nHdlPrv:=HeadProva(cLote,cOrigem,Substr(cUsuario,7,6),@cArquivo)
				Endif
				dbSelectArea( "SED" )
				MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
				dbSelectArea("SEV")
				If nHdlPrv > 0
					VALOR 	:= SEV->EV_VALOR		// Valor Principal
					VALOR2	:= 0					// Irf
					VALOR3	:= 0					// Inss
					VALOR4	:= 0					// Iss
					VALOR5	:= 0					// Pis
					VALOR6	:= 0					// Cofins
					VALOR7	:= 0					// Csll

					nTotal+=DetProva(nHdlPrv,cPadrao,cOrigem,cLote)
				Endif
	            If nTotal > 0
					RecLock("SEV")
					SEV->EV_LA    := "S"
					MsUnlock()
				Endif
			Endif
			If cAlias = "SE2" .And. lRatImpostos
				//Irrf
				If M->E2_IRRF > 0
					If lGrvSev
						ExecBlock("MULTSEV", .F., .F., { 	nX, cChaveIrf,;
															aRatIrf[nX][1],;
															(aColsSev[nX][3] / 100),;
															aColsSev[nX][1] })
						DbSelectArea("SEV")
					Endif
					SEV->(RecLock("SEV", .T.))
					SEV->EV_FILIAL   := xFilial("SEV")
					SEV->EV_PREFIXO  := aDadosTit[1]
					SEV->EV_NUM      := aDadosTit[2]
					SEV->EV_PARCELA  := aDadosTit[3]
					SEV->EV_CLIFOR   := _cMvUniao
					SEV->EV_LOJA     := cLojaImp
					SEV->EV_TIPO     := Iif(aDadosTit[9] $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
					SEV->EV_NATUREZ  := aColsSev[nX][1] // Grava a natureza
					SEV->EV_VALOR    := aRatIrf[nX][1]	// Grava o valor informado
					// Grava o percentual (Como indice multiplicador, por esta razao nao
					// multiplica por 100 na gravacao, apenas na exibicao)
					SEV->EV_PERC     := (aColsSev[nX][3] / 100)
					SEV->EV_RECPAG   := If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
					SEV->EV_RATEICC  := aColsSev[nX][4]  // Identificador de Rateio C Custo
					SEV->EV_IDENT		:= "1"  //Rateio de inclusao
					
					//Gravação da chave FK7 para os rateios
					cChaveTit := xFilial(cAlias) 	+ "|" +;
								SEV->EV_PREFIXO	+ "|" +;
								SEV->EV_NUM		+ "|" +;
								SEV->EV_PARCELA	+ "|" +;
								SEV->EV_TIPO		+ "|" +;
								SEV->EV_CLIFOR	+ "|" +;
								SEV->EV_LOJA
					cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

					SEV->EV_IDDOC := cChvImpFK7
					

					If lContabiliza .And. lPadrao .And. !lCtbRatCC .And. aColsSev[nX][4] != "1"
						dbSelectArea( "SED" )
						MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
						dbSelectArea("SEV")
						If nHdlPrv > 0
							VALOR 	:= 0					// Valor Principal
							VALOR2	:= SEV->EV_VALOR	// Irf
							VALOR3	:= 0					// Inss
							VALOR4	:= 0					// Iss
							VALOR5	:= 0					// Pis
							VALOR6	:= 0					// Cofins
							VALOR7	:= 0					// Csll
							nTotal+=DetProva(nHdlPrv,cPadrao,cOrigem,cLote)
						Endif
		            If nTotal > 0
							SEV->EV_LA    := "S"
						Endif

					Endif
					SEV->(MsUnlock())
				Endif

				//Pis
				If M->E2_PIS > 0
					If lGrvSev
						ExecBlock("MULTSEV", .F., .F., { 	nX, cChavePis,;
															aRatIrf[nX][1],;
															(aColsSev[nX][3] / 100),;
															aColsSev[nX][1] })
						DbSelectArea("SEV")
					Endif
					SEV->(RecLock("SEV", .T.))
					SEV->EV_FILIAL   := xFilial("SEV")
					SEV->EV_PREFIXO  := aDadosTit[1]
					SEV->EV_NUM      := aDadosTit[2]
					SEV->EV_PARCELA  := aDadosTit[4]
					SEV->EV_CLIFOR   := _cMvUniao
					SEV->EV_LOJA     := cLojaImp
					SEV->EV_TIPO     := Iif(aDadosTit[9] $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
					SEV->EV_NATUREZ  := aColsSev[nX][1] // Grava a natureza
					SEV->EV_VALOR    := aRatPIS[nX][1]	// Grava o valor informado
					// Grava o percentual (Como indice multiplicador, por esta razao nao
					// multiplica por 100 na gravacao, apenas na exibicao)
					SEV->EV_PERC     := (aColsSev[nX][3] / 100)
					SEV->EV_RECPAG   := If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
					SEV->EV_RATEICC  := aColsSev[nX][4]  // Identificador de Rateio C Custo
					SEV->EV_IDENT		:= "1"  //Rateio de inclusao
										//Gravação da chave FK7 para os rateios
					cChaveTit := xFilial(cAlias) 	+ "|" +;
								SEV->EV_PREFIXO	+ "|" +;
								SEV->EV_NUM		+ "|" +;
								SEV->EV_PARCELA	+ "|" +;
								SEV->EV_TIPO		+ "|" +;
								SEV->EV_CLIFOR	+ "|" +;
								SEV->EV_LOJA
					cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

					SEV->EV_IDDOC := cChvImpFK7

					If lContabiliza .And. lPadrao .And. !lCtbRatCC .And. aColsSev[nX][4] != "1"
						dbSelectArea( "SED" )
						MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
						dbSelectArea("SEV")
						If nHdlPrv > 0
							VALOR 	:= 0					// Valor Principal
							VALOR2	:= 0					// Irf
							VALOR3	:= 0					// Inss
							VALOR4	:= 0					// Iss
							VALOR5	:= SEV->EV_VALOR	// Pis
							VALOR6	:= 0					// Cofins
							VALOR7	:= 0					// Csll
							nTotal+=DetProva(nHdlPrv,cPadrao,cOrigem,cLote)
						Endif
		            If nTotal > 0
							SEV->EV_LA    := "S"

						Endif

					Endif
					SEV->(MsUnlock())
				Endif

				If !lAglut
				//Cofins
				If M->E2_COFINS > 0
					If lGrvSev
						ExecBlock("MULTSEV", .F., .F., { 	nX, cChaveCof,;
															aRatIrf[nX][1],;
															(aColsSev[nX][3] / 100),;
															aColsSev[nX][1] })
						DbSelectArea("SEV")
					Endif
					SEV->(RecLock("SEV", .T.))
					SEV->EV_FILIAL   := xFilial("SEV")
					SEV->EV_PREFIXO  := aDadosTit[1]
					SEV->EV_NUM      := aDadosTit[2]
					SEV->EV_PARCELA  := aDadosTit[5]
					SEV->EV_CLIFOR   := _cMvUniao
					SEV->EV_LOJA     := cLojaImp
					SEV->EV_TIPO     := Iif(aDadosTit[9] $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
					SEV->EV_NATUREZ  := aColsSev[nX][1] // Grava a natureza
					SEV->EV_VALOR    := aRatCOF[nX][1]	// Grava o valor informado
					// Grava o percentual (Como indice multiplicador, por esta razao nao
					// multiplica por 100 na gravacao, apenas na exibicao)
					SEV->EV_PERC     := (aColsSev[nX][3] / 100)
					SEV->EV_RECPAG   := If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
					SEV->EV_RATEICC  := aColsSev[nX][4]  // Identificador de Rateio C Custo
					SEV->EV_IDENT		:= "1"  //Rateio de inclusao
					//Gravação da chave FK7 para os rateios
					cChaveTit := xFilial(cAlias) 	+ "|" +;
								SEV->EV_PREFIXO	+ "|" +;
								SEV->EV_NUM		+ "|" +;
								SEV->EV_PARCELA	+ "|" +;
								SEV->EV_TIPO		+ "|" +;
								SEV->EV_CLIFOR	+ "|" +;
								SEV->EV_LOJA
					cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

					SEV->EV_IDDOC := cChvImpFK7

					If lContabiliza .And. lPadrao .And. !lCtbRatCC .And. aColsSev[nX][4] != "1"
						dbSelectArea( "SED" )
						MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
						dbSelectArea("SEV")
						If nHdlPrv > 0
							VALOR		:= 0					// Valor Principal
							VALOR2	:= 0					// Irf
							VALOR3	:= 0					// Inss
							VALOR4	:= 0					// Iss
							VALOR5	:= 0					// Pis
							VALOR6	:= SEV->EV_VALOR	// Cofins
							VALOR7	:= 0					// Csll
							nTotal+=DetProva(nHdlPrv,cPadrao,cOrigem,cLote)
						Endif
		            If nTotal > 0
							SEV->EV_LA    := "S"
						Endif

					Endif
					SEV->(MsUnlock())
				Endif

				//CSLL
				If M->E2_CSLL > 0
					If lGrvSev
						ExecBlock("MULTSEV", .F., .F., { 	nX, cChaveCSL,;
															aRatIrf[nX][1],;
															(aColsSev[nX][3] / 100),;
															aColsSev[nX][1] })
						DbSelectArea("SEV")
					Endif
					SEV->(RecLock("SEV", .T.))
					SEV->EV_FILIAL   := xFilial("SEV")
					SEV->EV_PREFIXO  := aDadosTit[1]
					SEV->EV_NUM      := aDadosTit[2]
					SEV->EV_PARCELA  := aDadosTit[6]
					SEV->EV_CLIFOR   := _cMvUniao
					SEV->EV_LOJA     := cLojaImp
					SEV->EV_TIPO     := Iif(aDadosTit[9] $ MVPAGANT+"/"+MV_CPNEG,MVTXA,MVTAXA)
					SEV->EV_NATUREZ  := aColsSev[nX][1] // Grava a natureza
					SEV->EV_VALOR    := aRatCSL[nX][1]	// Grava o valor informado
					// Grava o percentual (Como indice multiplicador, por esta razao nao
					// multiplica por 100 na gravacao, apenas na exibicao)
					SEV->EV_PERC     := (aColsSev[nX][3] / 100)
					SEV->EV_RECPAG   := If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
					SEV->EV_RATEICC  := aColsSev[nX][4]  // Identificador de Rateio C Custo
					SEV->EV_IDENT		:= "1"  //Rateio de inclusao
					//Gravação da chave FK7 para os rateios
					cChaveTit := xFilial(cAlias) 	+ "|" +;
								SEV->EV_PREFIXO	+ "|" +;
								SEV->EV_NUM		+ "|" +;
								SEV->EV_PARCELA	+ "|" +;
								SEV->EV_TIPO		+ "|" +;
								SEV->EV_CLIFOR	+ "|" +;
								SEV->EV_LOJA
					cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

					SEV->EV_IDDOC := cChvImpFK7

					If lContabiliza .And. lPadrao .And. !lCtbRatCC .And. aColsSev[nX][4] != "1"
						dbSelectArea( "SED" )
						MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
						dbSelectArea("SEV")
						If nHdlPrv > 0
							VALOR 	:= 0					// Valor Principal
							VALOR2	:= 0					// Irf
							VALOR3	:= 0					// Inss
							VALOR4	:= 0					// Iss
							VALOR5	:= 0					// Pis
							VALOR6	:= 0					// Cofins
							VALOR7	:= SEV->EV_VALOR	// Csll
							nTotal+=DetProva(nHdlPrv,cPadrao,cOrigem,cLote)
						Endif
		            If nTotal > 0
							SEV->EV_LA    := "S"
						Endif

					Endif
					SEV->(MsUnlock())
				Endif
				Endif
				
				If M->E2_INSS > 0
					If lGrvSev
						ExecBlock("MULTSEV", .F., .F., { 	nX, cChaveIns,;
															aRatIns[nX][1],;
															(aColsSev[nX][3] / 100),;
															aColsSev[nX][1] })
						DbSelectArea("SEV")
					Endif

					SEV->(RecLock("SEV", .T.))
					SEV->EV_FILIAL   := xFilial("SEV")
					SEV->EV_PREFIXO  := aDadosTit[1]
					SEV->EV_NUM      := aDadosTit[2]
					SEV->EV_PARCELA  := aDadosTit[7]
					SEV->EV_CLIFOR   := _cMvFInss
					SEV->EV_LOJA     := cLojaImp
					SEV->EV_TIPO     := Iif(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"INA",MVINSS)
					SEV->EV_NATUREZ  := aColsSev[nX][1] // Grava a natureza
					SEV->EV_VALOR    := aRatIns[nX][1]	// Grava o valor informado
					// Grava o percentual (Como indice multiplicador, por esta razao nao
					// multiplica por 100 na gravacao, apenas na exibicao)
					SEV->EV_PERC     := (aColsSev[nX][3] / 100)
					SEV->EV_RECPAG   := If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
					SEV->EV_RATEICC  := aColsSev[nX][4]  // Identificador de Rateio C Custo
					SEV->EV_IDENT		:= "1"  //Rateio de inclusao
					//Gravação da chave FK7 para os rateios
					cChaveTit := xFilial(cAlias) 	+ "|" +;
								SEV->EV_PREFIXO	+ "|" +;
								SEV->EV_NUM		+ "|" +;
								SEV->EV_PARCELA	+ "|" +;
								SEV->EV_TIPO		+ "|" +;
								SEV->EV_CLIFOR	+ "|" +;
								SEV->EV_LOJA
					cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

					SEV->EV_IDDOC := cChvImpFK7
					

					If lContabiliza .And. lPadrao .And. !lCtbRatCC .And. aColsSev[nX][4] != "1"
						dbSelectArea( "SED" )
						MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
						dbSelectArea("SEV")
						If nHdlPrv > 0
							VALOR 	:= 0					// Valor Principal
							VALOR2  := 0					// Irf
							VALOR3  := SEV->EV_VALOR		// Inss
							VALOR4  := 0					// Iss
							VALOR5	:= 0					// Pis
							VALOR6	:= 0					// Cofins
							VALOR7	:= 0					// Csll
							nTotal+=DetProva(nHdlPrv,cPadrao,cOrigem,cLote)
						Endif
		            If nTotal > 0
							SEV->EV_LA    := "S"
						Endif

					Endif
					SEV->(MsUnlock())
				Endif
				If M->E2_ISS > 0
					If lGrvSev
						ExecBlock("MULTSEV", .F., .F., { 	nX, cChaveIss,;
															aRatIss[nX][1],;
															(aColsSev[nX][3] / 100),;
															aColsSev[nX][1] })
						DbSelectArea("SEV")
					Endif

					SEV->(RecLock("SEV", .T.))
					SEV->EV_FILIAL   := xFilial("SEV")
					SEV->EV_PREFIXO  := aDadosTit[1]
					SEV->EV_NUM      := aDadosTit[2]
					SEV->EV_PARCELA  := aDadosTit[8]
					SEV->EV_CLIFOR   := _cMvMunic
					SEV->EV_LOJA     := cLojaImp
					SEV->EV_TIPO     := MVISS
					SEV->EV_NATUREZ  := aColsSev[nX][1] // Grava a natureza
					SEV->EV_VALOR    := aRatIss[nX][1]	// Grava o valor informado
					// Grava o percentual (Como indice multiplicador, por esta razao nao
					// multiplica por 100 na gravacao, apenas na exibicao)
					SEV->EV_PERC     := (aColsSev[nX][3] / 100)
					SEV->EV_RECPAG   := If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
					SEV->EV_RATEICC  := aColsSev[nX][4]  // Identificador de Rateio C Custo
					SEV->EV_IDENT		:= "1"  //Rateio de inclusao
					//Gravação da chave FK7 para os rateios
					cChaveTit := xFilial(cAlias) 	+ "|" +;
								SEV->EV_PREFIXO	+ "|" +;
								SEV->EV_NUM		+ "|" +;
								SEV->EV_PARCELA	+ "|" +;
								SEV->EV_TIPO		+ "|" +;
								SEV->EV_CLIFOR	+ "|" +;
								SEV->EV_LOJA
					cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

					SEV->EV_IDDOC := cChvImpFK7

					If lContabiliza .And. lPadrao .And. !lCtbRatCC .And. aColsSev[nX][4] != "1"
						dbSelectArea( "SED" )
						MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
						dbSelectArea("SEV")
						If nHdlPrv > 0
							VALOR 	:= 0					// Valor Principal
							VALOR2  := 0					// Irf
							VALOR3  := 0					// Inss
							VALOR4  := SEV->EV_VALOR		// Iss
							VALOR5	:= 0					// Pis
							VALOR6	:= 0					// Cofins
							VALOR7	:= 0					// Csll
							nTotal+=DetProva(nHdlPrv,cPadrao,cOrigem,cLote)
						Endif
		    			If nTotal > 0
							SEV->EV_LA    := "S"
						Endif

					Endif
					SEV->(MsUnlock())
				Endif
				
				If cPaisLoc == "BRA" .And. M->E2_CIDE > 0
					If lGrvSev
						ExecBlock("MULTSEV", .F., .F., { 	nX, cChaveCid,;
															aRatCid[nX][1],;
															(aColsSev[nX][3] / 100),;
															aColsSev[nX][1] })
						DbSelectArea("SEV")
					Endif

					SEV->(RecLock("SEV", .T.))
					SEV->EV_FILIAL   := xFilial("SEV")
					SEV->EV_PREFIXO  := aDadosTit[1]
					SEV->EV_NUM      := aDadosTit[2]
					SEV->EV_PARCELA  := aDadosTit[10]
					SEV->EV_CLIFOR   := _cMvFCide
					SEV->EV_LOJA     := cLojaImp
					SEV->EV_TIPO     := "CID"
					SEV->EV_NATUREZ  := aColsSev[nX][1] // Grava a natureza
					SEV->EV_VALOR    := aRatCid[nX][1]	// Grava o valor informado
					// Grava o percentual (Como indice multiplicador, por esta razao nao
					// multiplica por 100 na gravacao, apenas na exibicao)
					SEV->EV_PERC     := (aColsSev[nX][3] / 100)
					SEV->EV_RECPAG   := If(cAlias=="SE1", "R", "P" ) // Grava a Carteira
					SEV->EV_RATEICC  := aColsSev[nX][4]  // Identificador de Rateio C Custo
					SEV->EV_IDENT		:= "1"  //Rateio de inclusao
					//Gravação da chave FK7 para os rateios
					cChaveTit := xFilial(cAlias) 	+ "|" +;
								SEV->EV_PREFIXO	+ "|" +;
								SEV->EV_NUM		+ "|" +;
								SEV->EV_PARCELA	+ "|" +;
								SEV->EV_TIPO		+ "|" +;
								SEV->EV_CLIFOR	+ "|" +;
								SEV->EV_LOJA
					cChvImpFK7 := FINGRVFK7(cAlias,cChaveTit)

					SEV->EV_IDDOC := cChvImpFK7

					If lContabiliza .And. lPadrao .And. !lCtbRatCC .And. aColsSev[nX][4] != "1"
						dbSelectArea( "SED" )
						MsSeek( xFilial("SED")+SEV->EV_NATUREZ ) // Posiciona na natureza, pois a conta pode estar la.
						dbSelectArea("SEV")
						If nHdlPrv > 0
							VALOR 	:= 0					// Valor Principal
							VALOR2  := 0					// Irf
							VALOR3  := 0					// Inss
							VALOR4  := 0					// Iss
							VALOR5	:= 0					// Pis
							VALOR6	:= 0					// Cofins
							VALOR7	:= 0					// Csll
							nTotal+=DetProva(nHdlPrv,cPadrao,cOrigem,cLote)
						Endif
		    			If nTotal > 0
							SEV->EV_LA    := "S"
						Endif

					Endif
					SEV->(MsUnlock())
				Endif				
			Endif
			If lContabiliza .And. lPadrao .And. !lCtbRatCC
				(cAlias)->(RestArea(aArea1))
			Endif
		Endif
	Next
Endif

VALOR 	:= 0					// Valor Principal
VALOR2  := 0					// Irf
VALOR3  := 0					// Inss
VALOR4  := 0					// Iss
VALOR5	:= 0					// Pis
VALOR6	:= 0					// Cofins
VALOR7	:= 0					// Csll

//Se existir temporario para rateio c. custo e a operação não for desdobramento, deleta
If !lDesdobr
	If Select("SEZTMP") > 0
		FINXDETMP()
	Endif
Endif

RestArea(aArea)
(cAlias)->(RestArea(aArea1))
End Transaction
Return lRet	


//-------------------------------------------------------------------
/*/{Protheus.doc} PESPICT

Pesquisa picture do campo no SX3 (ligada a MULTNAT e MultNatCC).
Arquivo original: FINXFUN.PRX 

@author Marcel Borges Ferreira
@since 19/07/2007
/*/
//-------------------------------------------------------------------
Static Function PesPict(cCampo)
	LOCAL aArea := GetArea()
	LOCAL cPic := ""

	SX3->(DbSetOrder(2))
	If SX3->(DbSeek(cCampo)) .and. !Empty(SX3->X3_PICTURE)
		cPic := Trim(SX3->X3_PICTURE)
	Else
		cPic := "@E 999.99"
	EndIf

	RestArea(aArea)
Return cPic	


//-------------------------------------------------------------------
/*/{Protheus.doc} FDELRATPR

Realiza exclusao das informacoes de rateio multiplas naturezas x centro 
de custo do titulo provisorio.
Arquivo original: FINXFUN.PRX 

@param cRecPag - carteira, R - contas a receber; P - contas a pagar

@author Gustavo Henrique
@since 19/09/2011
/*/
//-------------------------------------------------------------------
Function FDelRatPR( cRecPag )

Local cChave	:= ""
Local cFilSEZ	:= xFilial( "SEZ" )
Local cFilSEV	:= xFilial( "SEV" )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Busca registros para exclusao de rateio multiplas naturezas x centro de custo ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cRecPag == "P"
	cChave := SE2->( E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA )
ElseIf cRecPag == "R"
	cChave := SE1->( E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO + E1_CLIENTE + E1_LOJA )
EndIf

SEZ->( dbSetOrder( 1 ) )
SEZ->( MsSeek( cFilSEZ + cChave ) )

Do While SEZ->( ! EoF() .And. EZ_FILIAL + EZ_PREFIXO + EZ_NUM + EZ_PARCELA + EZ_TIPO + EZ_CLIFOR + EZ_LOJA == ( cFilSEZ + cChave ) )

	If SEZ->EZ_RECPAG == cRecPag
		RecLock( "SEZ", .F. )
		SEZ->( dbDelete() )
		SEZ->( MsUnlock() )
	EndIf

	SEZ->( dbSkip() )

EndDo

SEV->( dbSetOrder( 1 ) )
SEV->( MsSeek( cFilSEV + cChave ) )

Do While SEV->( ! EoF() .And. EV_FILIAL + EV_PREFIXO + EV_NUM + EV_PARCELA + EV_TIPO + EV_CLIFOR + EV_LOJA == ( cFilSEV + cChave ) )

	If SEV->EV_RECPAG == cRecPag
		RecLock( "SEV", .F. )
		SEV->( dbDelete() )
		SEV->( MsUnlock() )
	EndIf

	SEV->( dbSkip() )

EndDo

Return	


//-------------------------------------------------------------------
/*/{Protheus.doc} MNCCCALC

Recalcula o total rateado quando deletar linha (multinatureza por Centro 
de Custo).
Arquivo original: FINXFUN.PRX 

@author Mauricio Pequim Jr.
@since 14/08/2002
/*/
//-------------------------------------------------------------------
Function MnccCalc()

LOCAL nPosVal  := aScan(aHeader,{|x| x[2] == "EZ_VALOR"})

If __OPC = 2
	Return .T.
Endif

If !aCols[n][nNumCol+1]  // Linha Deletada
	nValRat -= aCols[n][nPosVal]
Else
	nValRat += aCols[n][nPosVal]   // Linha Ativa
Endif
oValRat:Refresh() // Atualiza o objeto na tela
Return .T.


//-------------------------------------------------------------------
/*/{Protheus.doc} RETCHAVEBX

Retorna a chave para pesquisa no SEV (naturezas do titulo) de acordo 
com o titulo posicionado.
Arquivo original: FINXFUN.PRX 

@author Claudio Donizete Souza
@since 31/05/2001
/*/
//-------------------------------------------------------------------
FUNCTION RetChaveBx(cAlias,cArqKey)
LOCAL cChave
LOCAL cCampo
cArqKey := IIf(cArqKey == NIL,"SEV",cArqKey)

If cAlias $ "SE1%SE2"
	cCampo := Right(cAlias,2)
Endif

cChave := xFilial(cArqKey)+(cAlias)->&(cCampo+"_PREFIXO")+(cAlias)->&(cCampo+"_NUM")+;
		  					    (cAlias)->&(cCampo+"_PARCELA")+(cAlias)->&(cCampo+"_TIPO")+;
		  					    (cAlias)->&(cCampo+If(cCampo=="E1","_CLIENTE","_FORNECE"))+;
					   	    (cAlias)->&(cCampo+"_LOJA")
Return cChave


//-------------------------------------------------------------------
/*/{Protheus.doc} RETCHAVESEV

Retorna chave de pesquisa no SEV (multinaturezas) de acordo com o titulo 
posicionado  (ligada a DelMultNat).
Arquivo original: FINXFUN.PRX 

@author Claudio Donizete Souza
@since 31/05/2001
/*/
//-------------------------------------------------------------------
FUNCTION RetChaveSev(cAlias,cCampo,cArqKey)
LOCAL cChave

cArqKey := IIf(cArqKey == NIL,"SEV",cArqKey)

If cAlias $ "SE1%SE2"
	cCampo := Right(cAlias,2)
Endif

If cArqKey == "SEV"
	cChave := SubStr(xFilial(cArqKey), 1, TamSX3("EV_FILIAL")[1])  
	cChave += SubStr( (cAlias)->&(cCampo+"_PREFIXO"), 1, TamSX3("EV_PREFIXO")[1])  
	cChave += SubStr( (cAlias)->&(cCampo+"_NUM"), 1, TamSX3("EV_NUM")[1]) 
	cChave += SubStr( (cAlias)->&(cCampo+"_PARCELA"), 1, TamSX3("EV_PARCELA")[1]) 
	cChave += SubStr( (cAlias)->&(cCampo+"_TIPO"), 1, TamSX3("EV_TIPO")[1]) 
	cChave += SubStr( (cAlias)->&(cCampo + If(cCampo=="E1","_CLIENTE","_FORNECE")), 1, TamSX3("EV_CLIFOR")[1]) 
	cChave += SubStr( (cAlias)->&(cCampo+"_LOJA"), 1, TamSX3("EV_LOJA")[1]) 
Else
	cChave := xFilial(cArqKey)+(cAlias)->&(cCampo+"_PREFIXO")+(cAlias)->&(cCampo+"_NUM")+;
		  					    (cAlias)->&(cCampo+"_PARCELA")+(cAlias)->&(cCampo+"_TIPO")+;
		  					    (cAlias)->&(cCampo+If(cCampo=="E1","_CLIENTE","_FORNECE"))+;
					   	    (cAlias)->&(cCampo+"_LOJA")	
EndIf

Return cChave


//-------------------------------------------------------------------
/*/{Protheus.doc} SDOTITNAT

Retorna o saldo to titulo de acordo com distribuicao por naturezas 
(multiplas naturezas - relatorios).
Arquivo original: FINXFUN.PRX 

@author Claudio Donizete Souza
@since 24/05/2001
/*/
//-------------------------------------------------------------------
Function SdoTitNat(cPrefixo, cNum, cParcela, cTipo, cCliFor, cLoja, cNatur, cCarteira, cAliasTit, nMoeda, lConsDtBas, dDataCons, dDataConv)
LOCAL aAreaSEV   := SEV->(GetArea())
Local cChavSEV   := ""
Local aRet 		 := {}	// Estrutura para dados da tabela SEV
LOCAL aRetAux    := {}	// Estrutura para dados da tabela SEZ
Local nSaldoProp := 0
Local nRealizado := 0
Local nValorProp := 0
Local nAbatProp  := 0

LOCAL aAreaSEZ   := SEZ->(GetArea())
LOCAL cChavSEZ   := ""
LOCAL nSEZSldProp := 0
LOCAL nSEZRealizado := 0
LOCAL nSEZVlProp := 0
LOCAL nSEZAbtProp := 0

Local nDifSaldo  := 0
Local nSaldoTit  := 0
Local nTotSaldo  := 0
Local aAreaSe1   := SE1->(GetArea())
Local aAreaSe2   := SE2->(GetArea())
Local cAlias     := Alias()
Local cCampo     := "" 
Local cFilTit    := Nil
Local lNoMuNat   := .F.
Local nTxMoeda   := 0

Default dDataCons := dDataBase
Default dDataConv := dDataBase
Default lConsDtBas := .F.
Default cNatur := ""

//Posiciona o SE1 ou SE2, pois SaldoTit utiliza estes arquivos posicionados
DbSelectArea(If(cCarteira == "R","SE1","SE2"))

If (cAliasTit)->(FieldPos("Recno")) > 0
	DbGoto((cAliasTit)->Recno)
Endif

If !Empty(cAlias)
	DbSelectArea(cAlias)
Endif

If cCarteira == "R"
	cCampo   := "E1" 
	lNoMuNat := (!MV_MULNATR .Or. (cAliasTit)->E1_MULTNAT != "1") 
	nTxMoeda := (cAliasTit)->E1_TXMOEDA
	cFilTit  := (cAliasTit)->E1_FILORIG
Else
	cCampo   := "E2"
	lNoMuNat := (!MV_MULNATP .Or. (cAliasTit)->E2_MULTNAT != "1")  
	nTxMoeda := (cAliasTit)->E2_TXMOEDA
	cFilTit  := (cAliasTit)->E2_FILORIG
EndIf 

// Para levar corretamente a Filial, na posição cFilTit para a SaldoTit
// Retorno sera uma matriz com n linhas e 3 colunas a sequir identificadas:
//	aRet[n][1] = Codigo da Natureza,
// aRet[n][2] = Saldo proporcionalizado
// aRet[n][3] = Realizado proporcionalizado
// aRet[n][4] = Valor proporcionalizado
// aRet[n][5] = Abatimento proporcionalizado

If !Empty(cFilTit)
	cFilTit := xFilial("SE5", cFilTit)
Else
	cFilTit := Nil
EndIf

If lNoMuNat
	If lConsDtBas
		nSaldoTit  := SaldoTit(cPrefixo, cNum, cParcela, cTipo, cNatur, cCarteira, cCliFor, nMoeda, dDataConv, dDataCons, cLoja, cFilTit, nTxMoeda)
	Else
		nSaldoTit  := (cAliasTit)->&(cCampo+"_SALDO")
		nSaldoTit  += (cAliasTit)->&(cCampo+"_SDACRES")-(cAliasTit)->&(cCampo+"_SDDECRE")
		nSaldoTit  := xMoeda(nSaldoTit, (cAliasTit)->&(cCampo+"_MOEDA"), nMoeda,,,nTxMoeda)
	Endif
	
	nRealizado := xMoeda((cAliasTit)->&(cCampo+"_VALOR"), (cAliasTit)->&(cCampo+"_MOEDA"), nMoeda,,,nTxMoeda) - nSaldoTit
	
	//Calcula o abatimento
	nAbatProp  := SomaAbat(cPrefixo, cNum, cParcela, cCarteira, nMoeda, dDataCons, cCliFor, cLoja)
	Aadd(aRet,{(cAliasTit)->&(cCampo+"_NATUREZ"), nSaldoTit, nRealizado, (cAliasTit)->&(cCampo+"_VALOR"), nAbatProp, aRetAux })
	aRetAux := {}	// Inicializa após o uso
Else
	dbSelectArea("SEV")
	SEV->(dbSetOrder(1))	// EV_FILIAL, EV_PREFIXO, EV_NUM, EV_PARCELA, EV_TIPO, EV_CLIFOR, EV_LOJA, EV_NATUREZ, R_E_C_N_O_, D_E_L_E_T_
	SEZ->(dbSetOrder(1))	// EZ_FILIAL, EZ_PREFIXO, EZ_NUM, EZ_PARCELA, EZ_TIPO, EZ_CLIFOR, EZ_LOJA, EZ_NATUREZ, EZ_CCUSTO, R_E_C_N_O_, D_E_L_E_T_
	
	If MsSeek(xFilial("SEV")+cPrefixo+cNum+cParcela+cTipo+cCliFor+cLoja+cNatur)
		// Processa todas as naturezas
		cChavSEV := SEV->(EV_FILIAL+EV_PREFIXO+EV_NUM+EV_PARCELA+EV_TIPO+EV_CLIFOR+EV_LOJA) + If(Empty(cNatur), "", SEV->EV_NATUREZA)
		
		While SEV->(!Eof()) .And. cChavSEV == xFilial("SEV")+cPrefixo+cNum+cParcela+cTipo+cCliFor+cLoja+cNatur
			If SEV->EV_IDENT == "1" // Considera apenas os registros gerado na inclusao do titulo
				dbSelectArea(cAliasTit)
				If (cAliasTit)->(!Eof())
					If lConsDtBase
						nSaldoTit  := SaldoTit(cPrefixo, cNum, cParcela, cTipo, Nil, cCarteira, cCliFor, nMoeda, dDataConv, dDataCons, cLoja, cFilTit, nTxMoeda)
					Else
						nSaldoTit  := (cAliasTit)->&(cCampo+"_SALDO")
						nSaldoTit  += (cAliasTit)->&(cCampo+"_SDACRES")-(cAliasTit)->&(cCampo+"_SDDECRE")
						nSaldoTit  := xMoeda(nSaldoTit, (cAliasTit)->&(cCampo+"_MOEDA"), nMoeda,,,nTxMoeda)
					Endif
					
					//Calcula o percentual (Ja esta gravado como indice multiplicador)
					//sobre o saldo do titulo na data base ou o saldo atual ou sobre o valor informado no parametro
					nSaldoProp := SEV->EV_PERC * nSaldoTit
					nValorProp := SEV->EV_PERC * (cAliasTit)->&(cCampo+"_VALOR")

					// Calcula o abatimento proporcional
					nAbatProp  := SomaAbat(cPrefixo, cNum, cParcela, cCarteira, nMoeda, dDataCons, cCliFor, cLoja )
					nAbatProp  *= SEV->EV_PERC
					nValorProp := xMoeda(nValorProp,(cAliasTit)->&(cCampo+"_MOEDA"),nMoeda,,,nTxMoeda)
					
					//Calcula o realizado (VALOR-SALDO=Baixado)
					nRealizado := (xMoeda(&(cCampo+"_VALOR"), &(cCampo+"_MOEDA"), nMoeda,,,nTxMoeda) * SEV->EV_PERC) - nSaldoProp
					nTotSaldo  += nSaldoProp

					// Quando existe rateio de Natureza por Centro de Custo
					IF SEZ->(MSSEEK(xFilial('SEZ')+SEV->(EV_PREFIXO+EV_NUM+EV_PARCELA+EV_TIPO+EV_CLIFOR+EV_LOJA+EV_NATUREZA)))
						// Processa todos os centros de custo
						cChavSEZ := SEZ->(EZ_FILIAL+EZ_PREFIXO+EZ_NUM+EZ_PARCELA+EZ_TIPO+EZ_CLIFOR+EZ_LOJA+EZ_NATUREZ)

						WHILE SEZ->(!EOF()) .AND. cChavSEZ == SEV->(EV_FILIAL+EV_PREFIXO+EV_NUM+EV_PARCELA+EV_TIPO+EV_CLIFOR+EV_LOJA+EV_NATUREZA)
							IF SEZ->EZ_IDENT == '1'	// Considera apenas os registros gerado na inclusao do titulo
								nSEZSldProp := SEZ->EZ_PERC * nSaldoProp
								nSEZVlProp := SEZ->EZ_PERC * nValorProp

								nSEZAbtProp := SEZ->EZ_PERC * nAbatProp
								nSEZVlProp := xMoeda(nSEZVlProp,(cAliasTit)->&(cCampo+"_MOEDA"),nMoeda,,,nTxMoeda)

								nSEZRealizado := (xMoeda(nValorProp, &(cCampo+"_MOEDA"), nMoeda,,,nTxMoeda) * SEZ->EZ_PERC) - nSEZSldProp

								AADD(aRetAux,{SEZ->EZ_CCUSTO, nSEZSldProp, nSEZRealizado, nSEZVlProp, nSEZAbtProp})
							ENDIF
							SEZ->(DBSKIP())
							cChavSEZ := SEZ->(EZ_FILIAL+EZ_PREFIXO+EZ_NUM+EZ_PARCELA+EZ_TIPO+EZ_CLIFOR+EZ_LOJA+EZ_NATUREZ)
						ENDDO
					ENDIF

					Aadd( aRet, { SEV->EV_NATUREZ, nSaldoProp, nRealizado, nValorProp, nAbatProp, aRetAux } )
					aRetAux := {}	// Inicializa após o uso
				Endif
			Endif
			
			SEV->(DbSkip())
			cChavSEV := SEV->(EV_FILIAL+EV_PREFIXO+EV_NUM+EV_PARCELA+EV_TIPO+EV_CLIFOR+EV_LOJA) + If(Empty(cNatur), "", SEV->EV_NATUREZA)
		EndDo
		
		//Totaliza a diferenca de saldo
		If nTotSaldo < (cAliasTit)->&(cCampo+"_SALDO")
			nDifSaldo := xMoeda( (cAliasTit)->&(cCampo+"_SALDO"), (cAliasTit)->&(cCampo+"_MOEDA"), nMoeda,,,(cAliasTit)->&(cCampo+"_TXMOEDA")) - nTotSaldo
			aRet[Len(aRet),2] += nDifSaldo
		Endif
	Endif
Endif

SE1->(RestArea(aAreaSe1))
SE2->(RestArea(aAreaSe2))
SEV->(RestArea(aAreaSEV))
SEZ->(RestArea(aAreaSEZ))

If !Empty(cAlias)
	DbSelectArea(cAlias)
Endif

Return aRet


//-------------------------------------------------------------------
/*/{Protheus.doc} MNCCLIN

Validação de linha OK da tela de rateio multinatureza por C.Custo.
Arquivo original: FINXFUN.PRX 

@author Mauricio Pequi Jr.
@since 14/08/2002
/*/
//-------------------------------------------------------------------
Function MnccLin()
Local lRet := .T.
Local nCont := 1
Local nPosPer  := aScan(aHeader,{|x| AllTrim(x[2]) == "EZ_PERC"})
Local nPosVal  := aScan(aHeader,{|x| AllTrim(x[2]) == "EZ_VALOR"})
Local nPosCon  := Ascan(aHeader,{|e| AllTrim(e[2]) == "EZ_CONTA"})
Local nPosCus  := aScan(aHeader,{|x| AllTrim(x[2]) == "EZ_CCUSTO"})
Local nPosItCta:= aScan(aHeader,{|x| AllTrim(x[2]) == "EZ_ITEMCTA"})
Local nPosClVl := aScan(aHeader,{|x| AllTrim(x[2]) == "EZ_CLVL"})
Local nTotPerc := 0
Local nDifTot  := 0
Local lAuto := ((Type("lF040Auto")=="L" .and. LF040Auto).or. (Type("lF050Auto")=="L" .and. LF050Auto))
Local lTemEnt := .F.
nValRat := 0

// Atualiza soma de valores
For nCont := 1 to Len(aCols)
	If !(aCols[nCont][nNumCol+1])  // Verifica se linha esta deletada
		nValRat += Round(aCols[nCont][nPosVal],TamSX3("EZ_VALOR")[2])
		nTotPerc += aCols[nCont][nPosPer]
	EndIf
Next nCont

If !lAuto
	oValRat:Refresh()
EndIf

If nTotPerc == 100 //Atingiu 100% de percentual de rateio
	If (nDiftot := nValRat - nValNat) > 0 //Há diferença nos valores totais para menos
		If !(aCols[Len(aCols)][nNumCol+1])
			aCols[Len(aCols)][nPosVal] := aCols[Len(aCols)][nPosVal] - nDifTot
			nValRat := 0
			
			For nCont := 1 to Len(aCols)
				If !(aCols[nCont][nNumCol+1])
					nValRat += Round(aCols[ncont][nPosVal],TamSX3("EZ_VALOR")[2])
				EndIf
			Next nCont
			
			If !lAuto
				oValRat:Refresh()
			EndIf
		EndIf
	EndIf
	
	If (nDiftot := nValNat - nValRat) > 0 //Há diferença nos valores totais para mais
		If !(aCols[Len(aCols)][nNumCol+1])
			aCols[Len(aCols)][nPosVal] := aCols[Len(aCols)][nPosVal] + nDifTot
			nValRat := 0
			
			For nCont := 1 to Len(aCols)
				If !(aCols[nCont][nNumCol+1])
					nValRat += Round(aCols[ncont][nPosVal],TamSX3("EZ_VALOR")[2])
				EndIf
			Next nCont
			
			If !lAuto
				oValRat:Refresh()
			EndIf
		EndIf
	EndIf
ElseIf nTotPerc > 100
	lRet := .F.
	Alert(STR0027) //"O percentual de rateio ultrapassou os 100%."
EndIf

If lRet
	//Verifico se os campos necessários foram preenchidos e se a linha não esta deletada
	If (Empty(aCols[n][nPosCus]) .or. Empty(aCols[n][nPosVal]) .or. Empty(aCols[n][nPosPer])) .and.;
		!aCols[n][nNumCol+1]
		Help(" ",1,"OBRIGAT2")
		lRet := .F.
	EndIf
	
	lTemEnt := .T.
	// Se o Centro de custo j  estiver registrada e nao estiver apagada, nao permite nova
	// distribuicao para o mesmo centro de custo
	If lTemEnt .and. CtbQtdEntd() > 4
	   lRet := CTBent050()
	Else
		If lRet
			nAscan := Ascan( aCols, { |e| 	e[nPosCus] == aCols[n][nPosCus] .And. If(nPosCon>0,e[nPosCon] == aCols[n][nPosCon],.T.) .And. e[nPosItCta] == aCols[n][nPosItCta] .And.;
														 	e[nPosClVl] == aCols[n][nPosClVl] .And. !e[len(e)] } )
			If nAscan > 0 .And. n != nAscan .And. !aCols[n][nNumCol+1]
				Alert(STR0001) //"Combinação de entidades repetida"
				lRet := .F.
			EndIf
		EndIf
	EndIf
EndIf

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} MNCCTOK

Validação de Tudo OK da tela de rateio multinatureza por C.Custo.
Arquivo original: FINXFUN.PRX 

@author Mauricio Pequi Jr.
@since 14/08/2002
/*/
//-------------------------------------------------------------------
Function MnccTOk()

LOCAL lRet := .T.
LOCAL nCont := 0
LOCAL nPosVal := Ascan(aHeader, {|e| AllTrim(e[2]) == AllTrim("EZ_VALOR") } )

nValRat := 0

// Atualiza soma de valores
For nCont := 1 to Len(aCols)
	If !(aCols[nCont][nNumCol+1])  // Verifica se linha esta deletada
		n := nCont
		nValRat += aCols[ncont][nPosVal]
		If ! MnccLin()
			Return .F.
		Endif
	Endif
Next
oValRat:Refresh()

// Se a soma for maior que o valor a ser distribuido ou se foi pressionado
// Ok e a Soma for diferente do valor distribuido, avisa e invalida o valor
// digitado
If lRet .And.	(Val(Str(nValRat,17,2)) > Val(Str(nValNat,17,2)) .Or. ;
			   	(nOpcC == 1 .And. Str(nValRat,17,2) != Str(nValNat,17,2)))
	Help(	" ",1,"TOTDISTRCC",, STR0014 + ;  //"Total Natureza:    "
			Trans(nValNat,PesqPict("SEZ","EZ_VALOR",19)) +;
			Chr(13)  + STR0015 +;  //"Total Distribuido: "
			Trans(nValRat,PesqPict("SEZ","EZ_VALOR",19)), 4, 0)

	lRet := .F.
Endif

If lRet .and. ExistBlock("MNCCOK")
	lRet := ExecBlock("MNCCOK",.F.,.F.)
Endif

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} AUTOSEZ

Validação dos campos do rateio multinaturezas - Centro de custo (MultNatCC)
Arquivo original: FINXFUN.PRX 

@author TOTVS
/*/
//-------------------------------------------------------------------
Function AutoSEZ(aRat,aCols,aHeader)
Local lRet			:= .T.
Local nX			:= 0
Local nY			:= 0
Local cCampo		:= ""
Local cCustNat		:= ""
Local nRateio		:= 0
Local nTValor		:= 0
Local nTCusto		:= 0
Local aColsAux		:= aClone(aCols)
local nPosCusto		:= Ascan(aHeader,{|e|Alltrim(e[2])=="EZ_CCUSTO"})
Local nPosValor		:= Ascan(aHeader,{|e|Alltrim(e[2])=="EZ_VALOR"})
Local nPosPerc		:= Ascan(aHeader,{|e|Alltrim(e[2])=="EZ_PERC"})
Local nPosItemCta	:= Ascan(aHeader,{|e|Alltrim(e[2])=="EZ_ITEMCTA"})
Local nPosclvl		:= Ascan(aHeader,{|e|Alltrim(e[2])=="EZ_CLVL"})
Local nPosConta		:= Ascan(aHeader,{|e|Alltrim(e[2])=="EZ_CONTA"})
Local nPosEc05DB	:= Ascan(aHeader,{|e|Alltrim(e[2])=="EZ_EC05DB"})
Local nPosEc05CR	:= Ascan(aHeader,{|e|Alltrim(e[2])=="EZ_EC05CR"})
Local nPosEc06DB	:= Ascan(aHeader,{|e|Alltrim(e[2])=="EZ_EC06DB"})
Local nPosEc06CR	:= Ascan(aHeader,{|e|Alltrim(e[2])=="EZ_EC06CR"})
Local nPosEc07DB	:= Ascan(aHeader,{|e|Alltrim(e[2])=="EZ_EC07DB"})
Local nPosEc07CR	:= Ascan(aHeader,{|e|Alltrim(e[2])=="EZ_EC07CR"})
Local nPosEc08DB	:= Ascan(aHeader,{|e|Alltrim(e[2])=="EZ_EC08DB"})
Local nPosEc08CR	:= Ascan(aHeader,{|e|Alltrim(e[2])=="EZ_EC08CR"})
Local nPosEc09DB	:= Ascan(aHeader,{|e|Alltrim(e[2])=="EZ_EC09DB"})
Local nPosEc09CR	:= Ascan(aHeader,{|e|Alltrim(e[2])=="EZ_EC09CR"})
Local xReadBkp
Local lOk			:= .F.
Local lValor		:= .F.
Local lPercent		:= .F.
Local nValor		:= 0
Local nPercent		:= 0
Local nRat			:= Len(aRat)
Local nPosRat		:= 0
Local lEntAdd		:= CtbQtdEntd() > 4

If Type("lF050Auto") == "U"
	lF050Auto := .F.					
EndIf

If Type("lF040Auto") == "U"
	lF040Auto := .F.					
EndIf

Begin Transaction
	If lRet
		For nX :=1 to nRat	
			If !lRet
				Exit
			Endif
			
			If 	nX >1
				aadd(aCols, aClone(aColsAux[1]))
			Endif
			
			//Limpa as variáveis de controle para cálculo de valor com base no percentual ou vice-versa
			lValor := .F.
			lPercent := .F.
			nValor := 0
			nPercent := 0	
			nPosRat := len(aRat[nX]) 
			
			For nY := 1 to nPosRat
				cCampo := UPPER(AllTrim(aRat[nX][nY][1]))
				xValor := aRat[nX][nY][2]
				Do Case
					Case cCampo == "EZ_CCUSTO"
						xValor:=UPPER(Padr(xValor,TamSx3("EZ_CCUSTO")[1]))
						M->EZ_CUSTO := xValor
						If !CTB105CC(xvalor)
							lRet := .F.
							Exit
						ElseIF  Empty (xValor)
							lRet := .F.
							Help("  ", 1, "NOCUSTO")
							Exit
						Else
							aCols[nX][nPosCusto]:=xValor
							nTCusto ++
							cCustNat+="|"+(xValor)
						Endif
					Case cCampo =="EZ_VALOR"
						If xValor > 0
							lValor := .T.
							nValor := xValor					
							aCols[nX][nPosValor] := nValor					
							nTValor++
							nRateio += nValor
						Endif				
					Case cCampo =="EZ_PERC"
						If xValor > 0
							lPercent := .T.
							nPercent := xValor
							aCols[nX][nPosPerc] := Str( nPercent )
						Endif								
					Case cCampo =="EZ_ITEMCTA"
						xValor:=UPPER(Padr(xValor,TamSx3("EZ_ITEMCTA")[1]))
						M->EZ_ITEMCTA := xValor
						
						IF !Empty(xValor)
							lOk := Iif(lF050Auto .or. lF040Auto, !(Ctb105Item(xValor)), !(Ctb105Item()))
							
							If lOk
								lRet :=.F.
								Exit
							Else
								aCols[nX][nPosItemCta]:=xValor
							Endif
						Endif
					Case cCampo =="EZ_CLVL"
						xValor:=UPPER(Padr(xValor,TamSx3("EZ_CLVL")[1]))
						M->EZ_CLVL := xValor
						If !Empty(xValor)
							xReadBkp := ReadVar()
							__ReadVar := "M->EZ_CLVL" //Correção Diego feita em virtude de problema ao ReadVar dentro da função CTB105CLVL
							If !(Ctb105CLVL())
								lRet :=.F.
								Exit
							Else
								aCols[nX][nPosCLVL]:=xValor
							Endif
							__ReadVar := xReadBkp
						Endif
					Case cCampo =="EZ_CONTA"
						xValor:=UPPER(Padr(xValor,TamSx3("EZ_CONTA")[1]))
						M->EZ_CONTA := xValor
						
						If !Empty(xValor)
							lOk := Iif(lF050Auto .or. lF040Auto, !(Ctb105Cta(xValor)), !(Ctb105Cta()))
							
							If lOk
								lRet :=.F.
								Exit
							Else
								aCols[nX][nPosConta]:=xValor
							Endif
						Endif
					Case lEntAdd .AND. cCampo =="EZ_EC05DB"
						xValor:=Padr(xValor,TamSx3("EZ_EC05DB")[1])
						M->EZ_EC05DB := xValor
						If !Empty(xValor)
							If !(CTB105EntC(,M->EZ_EC05DB,,'05'))
								lRet :=.F.
								Exit
							Else
								aCols[nX][nPosEc05DB]:=xValor
							Endif
						Endif
					Case lEntAdd .AND. cCampo =="EZ_EC05CR"
						xValor:=Padr(xValor,TamSx3("EZ_EC05CR")[1])
						M->EZ_EC05CR := xValor
						If !Empty(xValor)
							If !(CTB105EntC(,M->EZ_EC05CR,,'05'))
								lRet :=.F.
								Exit
							Else
								aCols[nX][nPosEc05CR]:=xValor
							Endif
						Endif
					Case lEntAdd .AND. cCampo =="EZ_EC06DB"
						xValor:=Padr(xValor,TamSx3("EZ_EC06DB")[1])
						M->EZ_EC06DB := xValor
						If !Empty(xValor)
							If !(CTB105EntC(,M->EZ_EC06DB,,'06'))
								lRet :=.F.
								Exit
							Else
								aCols[nX][nPosEc06DB]:=xValor
							Endif
						Endif
					Case lEntAdd .AND. cCampo =="EZ_EC06CR"
						xValor:=Padr(xValor,TamSx3("EZ_EC06CR")[1])
						M->EZ_EC06CR := xValor
						If !Empty(xValor)
							If !(CTB105EntC(,M->EZ_EC06CR,,'06'))
								lRet :=.F.
								Exit
							Else
								aCols[nX][nPosEc06CR]:=xValor
							Endif
						Endif
					Case lEntAdd .AND. cCampo =="EZ_EC07DB"
						xValor:=Padr(xValor,TamSx3("EZ_EC07DB")[1])
						M->EZ_EC07DB := xValor
						If !Empty(xValor)
							If !(CTB105EntC(,M->EZ_EC07DB,,'07'))
								lRet :=.F.
								Exit
							Else
								aCols[nX][nPosEc07DB]:=xValor
							Endif
						Endif
					Case lEntAdd .AND. cCampo =="EZ_EC07CR"
						xValor:=Padr(xValor,TamSx3("EZ_EC07CR")[1])
						M->EZ_EC07CR := xValor
						If !Empty(xValor)
							If !(CTB105EntC(,M->EZ_EC07CR,,'07'))
								lRet :=.F.
								Exit
							Else
								aCols[nX][nPosEc07CR]:=xValor
							Endif
						Endif
					Case lEntAdd .AND. cCampo =="EZ_EC08DB"
						xValor:=Padr(xValor,TamSx3("EZ_EC08DB")[1])
						M->EZ_EC08DB := xValor
						If !Empty(xValor)
							If !(CTB105EntC(,M->EZ_EC08DB,,'08'))
								lRet :=.F.
								Exit
							Else
								aCols[nX][nPosEc08DB]:=xValor
							Endif
						Endif
					Case lEntAdd .AND. cCampo =="EZ_EC08CR"
						xValor:=Padr(xValor,TamSx3("EZ_EC08CR")[1])
						M->EZ_EC08CR := xValor
						If !Empty(xValor)
							If !(CTB105EntC(,M->EZ_EC08CR,,'08'))
								lRet :=.F.
								Exit
							Else
								aCols[nX][nPosEc08CR]:=xValor
							Endif
						Endif
					Case lEntAdd .AND. cCampo =="EZ_EC09DB"
						xValor:=Padr(xValor,TamSx3("EZ_EC09DB")[1])
						M->EZ_EC09DB := xValor
						If !Empty(xValor)
							If !(CTB105EntC(,M->EZ_EC09DB,,'09'))
								lRet :=.F.
								Exit
							Else
								aCols[nX][nPosEc09DB]:=xValor
							Endif
						Endif
					Case lEntAdd .AND. cCampo =="EZ_EC09CR"
						xValor:=Padr(xValor,TamSx3("EZ_EC09CR")[1])
						M->EZ_EC09CR := xValor
						If !Empty(xValor)
							If !(CTB105EntC(,M->EZ_EC09CR,,'09'))
								lRet :=.F.
								Exit
							Else
								aCols[nX][nPosEc09CR]:=xValor
							Endif
						Endif
				EndCase

			Next nY

			//Se foi informado o valor do rateio de centro de custo e não foi informado o percentual, então calcula o percentual
			If lValor .AND.	!lPercent
				aCols[nX][nPosPerc] := Str( nValor / nValNat )
			ElseIf lPercent .AND. !lValor //Se foi informado o percentual do rateio de centro de custo e não foi informado o valor, então calcula o valor
				nValor := nValNat * ( nPercent / 100  )
				aCols[nX][nPosValor] := nValor				 
				nTValor++
				nRateio += nValor
			Endif

			// Posiciono o aCols na linha recem incluida para validar entidades contabeis adicionais
			n := nX
			If lEntAdd
				lRet := CTBent050()
			Else
				If lRet
					nAscan := Ascan( aCols, { |e|	e[nPosCusto] == aCols[n][nPosCusto] .And.;
													If( nPosConta > 0, e[nPosConta] == aCols[n][nPosConta], .T. ) .And.;
													e[nPosItemCta] == aCols[n][nPosItemCta] .And.;
													e[nPosclvl] == aCols[n][nPosclvl] .And. !e[len(e)] } )

					If nAscan > 0 .And. n != nAscan .And. !aCols[n][nNumCol+1]
						Help(' ',1,"COMBENTI" ,,STR0001,2,0,,,,,, {}) //"Combinação de entidades repetida"
						lRet := .F.
					EndIf
				EndIf
			EndIf

		Next Nx
		
		If lRet
			If nTCusto <> (nX-1) .or. nTValor <> (nX-1)
				Help(" ",1,"SEZVAZIO",,STR0017,3,1) //"Não foi enviado o Valor ou o Centro de Custo"
				lRet:=.F.
			Elseif  nRateio <> nValNat
				Help(" ",1,"SEZRAT",,STR0018,3,1) //"O Valor rateado para os centros de Custo é diferente do Valor rateado para a natureza."
				lRet := .F.
			Endif
		Endif
	EndIf
	
	If !lREt
		DisarmTransaction()
	Endif
End Transaction

Return lRet


/*/{Protheus.doc} FINXTMP
Função responsavel por criar a tabela temporaria
@author  jose.aribeiro
@since   05/01/2017
@version 1.0
/*/
Function FINXTMP()

	Local aCposDb  := {}
	Local aStruSez := {}
	Local nX	   := 0
	Local nStatus  := 0

	aAdd(aCposDB,{"EZ_NATUREZ","C",10,0})
	aAdd(aCposDB,{"EZ_CCUSTO","C",TamSx3("CTT_CUSTO")[1],0})
	aAdd(aCposDB,{"EZ_ITEMCTA","C",TamSx3("CTD_ITEM")[1],0})
	aAdd(aCposDB,{"EZ_CLVL","C",TamSx3("CTH_CLVL")[1],0})
	aadd(aCposDB,{"EZ_VALOR","N",TamSx3("EZ_VALOR")[1],TamSx3("EZ_VALOR")[2]})
	aadd(aCposDB,{"EZ_PERC","N",TamSx3("EZ_PERC")[1],TamSx3("EZ_PERC")[2]})
	aAdd(aCposDB,{"EZ_FLAG","L",1,0})
	aAdd(aCposDB,{"EZ_RECNO","N",10,0})

	// Adiciona demais campos
	aStruSez := SEZ->(DbStruct())
	For nX := 1 To Len(aStruSez)
		If Ascan(aCposDB, { |e| Alltrim(e[1]) == aStruSez[nX][1] } ) == 0
			Aadd(aCposDB,{aStruSez[nX][1],aStruSez[nX][2],aStruSez[nX][3],aStruSez[nX][4]})
		Endif
	Next

	If(_oFINXNAT1 <> NIL)
		nStatus := TCSQLEXEC("DELETE FROM "+__cFin1Name)
		
		If SELECT("SEZTMP") > 0 
			SEZTMP->(DBGOTO(1))
		Endif

		If nStatus < 0
            _oFINXNAT1:Delete()
            _oFINXNAT1 := NIL
            __cFin1Name := ""
        Endif
	EndIf

	If(_oFINXNAT1 == NIL)
		IIF(Select("SEZTMP") > 0, SEZTMP->(DbCloseArea()), Nil)

		//Cria o Objeto do FwTemporaryTable
		_oFINXNAT1 := FwTemporaryTable():New("SEZTMP")

		//Cria a estrutura do alias temporario
		_oFINXNAT1:SetFields(aCposDB)

		//Adiciona o indicie na tabela temporaria
		_oFINXNAT1:AddIndex("1",{"EZ_NATUREZ","EZ_CCUSTO"})

		//Criando a Tabela Temporaria
		_oFINXNAT1:Create()

		//Nome da tabela criada no BD
		__cFin1Name := _oFINXNAT1:GetRealName()
	EndIf

Return

/*/{Protheus.doc} FINXDETMP
Função responsavel para deltar a tabela temporaria
@type  Function
@author jose.aribeiro
@since 06/01/2017
@version 1.0
@example FINXDETMP
/*/
Function FINXDETMP()

If(_oFINXNAT1 <> NIL)
	TCSQLEXEC("DELETE FROM "+__cFin1Name)
	
	If SELECT("SEZTMP") > 0 
		SEZTMP->(DBGOTO(1))
	Endif
EndIf

If(_oFINXNAT2 <> NIL)
	TCSQLEXEC("DELETE FROM "+__cFin2Name)
	
	If SELECT("SEZTMP") > 0 
		SEZTMP->(DBGOTO(1))
	Endif
EndIf

Return NIL


/*/{Protheus.doc} FinPesPict()
Retorna a picture do campo EV_PERC para demonstra?o na tela

@author Mauricio Pequim Jr
@since 31/05/2017
@version 1.0
/*/
Function FPictPerc()

If cPictPerc == NIL
	cPictPerc	:= PesPict("EV_PERC")
	//Diminuidos 3 caracteres da picture pois o campo  informado em percentual e gravado como indice
	//Exemplo: Na tela est  13.5216 e no campo grava 0.135216
	//cPictPerc	:= Substr(cPictPerc,1,Len(cPictPerc)-3)	
Endif

Return cPictPerc

//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} FMNCvMoed()
Converte os impostos para a moeda do título, para somar corretamente 
na recomposição do valor a ratear no rateio multi naturezas

@param cCampo - Indicador da tabela a ser verificada (E1 ou E2)
@param nImpostos - Valor dos impostos a ser convertido para moeda do titulo (E1 ou E2)

@return nVlrImp - Retorna valor dos impostos convertidos para moeda do titulo

@author Mauricio Pequim Jr
@since 24/10/2019
@version 1.0
/*/
//--------------------------------------------------------------------------------------------
Function FMNCvMoed(cCampo, nImpostos)

	Local dEmissao := CTOD("//")
	Local nTxMoeda := 0
	Local nVlrImp  := 0
	Local nMoeda   := 0

	DEFAULT cCampo := ""
	DEFAULT nImpostos := 0

	If !Empty(cCampo) .and. nImpostos > 0
		//Converte os impostos para a moeda do título, para somar corretamente
		nMoeda := M->&(cCampo + "_MOEDA")
		If nMoeda > 1
			dEmissao := M->&(cCampo + "_EMISSAO")
			nTxMoeda := M->&(cCampo + "_TXMOEDA")
			nVlrImp	 := xMoeda( nImpostos, 1, nMoeda, dEmissao, MsDecimais(1),, nTxMoeda )
		Else
			nVlrImp  := nImpostos
		Endif
	Endif

Return nVlrImp

/*/{Protheus.doc} NatAtuSal
	Verifica se o movimento deve atualizar o saldo de Natureza
	@type  Function
	@author renato.ito
	@since 19/11/2019
	@version 12
	@param cAlias, Character, alias
	@param nRec, Numeric, recno a ser verificado
	@return lRet, Logical, retorno se deve ou não atualizar o saldo
/*/
Function NatAtuSal(cAlias As Character, nRec As Numeric) As Logical

	Local lRet	As Logical
	Local aArea As Array 
	lRet  := .T.
	aArea := (cAlias)->(Getarea())

	If !(Empty(cAlias) .Or. Empty(nRec))
		/*

		ATENÇÃO!!!
		Esse trecho não foi convertido para FKs, por necessitar da passagem
		do Recno FK5 na chamada da função AtuSldNat 
		
		*/
		If "SE5" $ cAlias
			DbSelectArea("SE5")
			SE5->(DbGoTo(nRec))
			If AllTrim(SE5->E5_ORIGEM) $ "FINA100" //Movimento bancário valida se o banco gera fluxo
				DbSelectArea("SA6")
				DbSetOrder(1)
				If SA6->(DbSeek(xFilial("SA6",SE5->E5_FILIAL) + SE5->(E5_BANCO + E5_AGENCIA + E5_CONTA) ))
					If "N" $ SA6->A6_FLUXCAI
						lRet := .F.
					EndIf
				EndIf
			EndIf
		ElseIf "SE2" $ cAlias
			DbSelectArea(cAlias)
			(cAlias)->(DbGoTo(nRec))
			If "N" $ (cAlias)->E2_FLUXO
				lRet := .F.
			EndIf
		ElseIf "SE1" $ cAlias
			DbSelectArea(cAlias)
			(cAlias)->(DbGoTo(nRec))
			If "N" $ (cAlias)->E1_FLUXO
				lRet := .F.
			EndIf
		EndIf
	EndIf
	RestArea(aArea)
Return lRet

//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINXFIND
Verifica se a função chamadora é do módulo EIC ou algum modulo da TradeEasy

@sample		[...] .Or. FINXFIND(Funname()) [...]
@param		cRotina - Nome do programa em execução
@return		.T. - Função pertence ao EIC ou TradeEasy
			.F. - Função pertence a outro modulo
@author		Ramon Prado
@since		11/02/2020
/*/
//--------------------------------------------------------------------------------------------

Static Function FINXFIND(cRotina As Character) As Logical

	Local lRet As Logical

	lRet := .F.

	If FindFunction("EasyEICOri")
		lRet := EasyEICOri(cRotina)
	EndIf

Return lRet

//--------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinxRatNat
Função para a gravação das informações das tabelas (SEV) e (SEZ) a prinicipio vindas do faturamento

@param		aMultNat - Array contendo os centros de custo e entidadas relacionados os produtos do documento de saida
			nRecnoTb - Recno da Tabela para posicionarmos
			cAliasTb - Alias da Tabela para posicionamento 
@return		.T. - gravação realizada | .F. - Problemas na gravação.
@author		Rene Julian
@since		18/01/2021
/*/

//-------------------------------------------------------------------------------------------
// Informações do primeiro centro de custo 002
//aMultNat[1][1] = "002" (Código do centro de custo) 
//aMultNat[1][2] = "" (Código do Item Contábil)
//aMultNat[1][3] = "" (Código da Classe de valor)
//aMultNat[1][4] = 0 (Percentual - Deve vim zerado pois o calculo será responsabilidade da nossa função) 
//aMultNat[1][5] = 10000 (Valor do rateio do centro de custo )
//aMultNat[1][6] = "" (Código da conta contábil)

//As próximas posições do array devem ser condicionadas aos campos de entidades contábeis adicionais
//aMultNat[1][7] = "" (Código da entidade contábil adicional EC05DB) 
//aMultNat[1][8] = "" (Código da entidade contábil adicional EC05CR) 
//aMultNat[1][9] = "" (Código da entidade contábil adicional EC06DB) 
//aMultNat[1][10] = "" (Código da entidade contábil adicional EC06CR)  
//aMultNat[1][11] = "" (Código da entidade contábil adicional EC07DB) 
//aMultNat[1][12] = "" (Código da entidade contábil adicional EC07CR) 
//aMultNat[1][13] = "" (Código da entidade contábil adicional EC08DB) 
//aMultNat[1][14] = "" (Código da entidade contábil adicional EC08CR) 
//aMultNat[1][15] = "" (Código da entidade contábil adicional EC09DB) 
//aMultNat[1][16] = "" (Código da entidade contábil adicional EC09CR)  
//-------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
Function FinxRatNat(aMultNat As Array, nRecnoTb As Numeric, cAliasTb As Character ) As Logical
Local lRet As Logical 
Local nX As Numeric 
lOCAL nY As Numeric 
Local lMulNatp As Logical 
Local lMulNatr As Logical  
Local aAreaTb As Array 
Local cPrefTb As Character
Local cChaveNF As Character
Local cIddoc  As Character
Local cCliFor As Character 
Local nValEV As Numeric 
Local cEntCC As Character 

Default aMultNat := {} 
Default nRecnoTb := 0
Default cAliasTb := ""

lRet := .F.
nX := 0 
nY := 0 
lMulNatp := SuperGetMv("MV_MULNATP", .F., .F. ) // Identifica se possui multiplas naturezas CP
lMulNatr := SuperGetMv("MV_MULNATR", .F., .F. ) // Identifica se possui multiplas naturezas CR
aAreaTb  := {}
cPrefTb  := ""
cChaveNF := ""
cCliFor  := ""
cIddoc   := ""
nValEV   := 0
cEntCC   := ""

If Len(aMultNat) > 0 .And.  !Empty(cAliasTb) .And. IIF(cAliasTb == "SE1", lMulNatr, lMulNatp) .And. nRecnoTb > 0
	
	aAreaTb := (cAliasTb)->(GetArea()) 
	(cAliasTb)->(DbGoto(nRecnoTb))
	
	cPrefTb  := IIf(cAliasTb == "SE2","E2_","E1_")
	cCliFor  := IIf(cAliasTb == "SE2",SE2->E2_FORNECE,SE1->E1_CLIENTE)
	
	cChaveNF := xFilial(cAliasTb)+"|"+ (cAliasTb)->&(cPrefTb+"PREFIXO") +"|"+ (cAliasTb)->&(cPrefTb+"NUM") +"|"+ (cAliasTb)->&(cPrefTb+"PARCELA") +"|"+ (cAliasTb)->&(cPrefTb+"TIPO") +"|"+ cCliFor +"|"+ (cAliasTb)->&(cPrefTb+"LOJA")
	cIddoc := FINBuscaFK7(cChaveNF, cAliasTb )
	
	RecLock("SEV", .T. )
	SEV->EV_FILIAL   := xFilial("SEV")
	SEV->EV_PREFIXO  := (cAliasTb)->&(cPrefTb+"PREFIXO")
	SEV->EV_NUM      := (cAliasTb)->&(cPrefTb+"NUM")
	SEV->EV_PARCELA  := (cAliasTb)->&(cPrefTb+"PARCELA")
	SEV->EV_CLIFOR   := cCliFor
	SEV->EV_LOJA     := (cAliasTb)->&(cPrefTb+"LOJA")
	SEV->EV_TIPO     := (cAliasTb)->&(cPrefTb+"TIPO") 
	SEV->EV_NATUREZ	 := (cAliasTb)->&(cPrefTb+"NATUREZ") 
	SEV->EV_PERC     := 1
	SEV->EV_RECPAG   := IIf(cAliasTb == "SE2","P","R")
	SEV->EV_LA       := ""
	SEV->EV_IDENT    := "1"
	SEV->EV_IDDOC    := cIddoc
	SEV->EV_RATEICC  := "1"
	MsUnLock()

	For nX := 1 To Len(aMultNat)
		RecLock("SEZ",.T.)
		SEZ->EZ_FILIAL := xFilial("SEZ")
		SEZ->EZ_PREFIXO:= SEV->EV_PREFIXO
		SEZ->EZ_NUM    := SEV->EV_NUM
		SEZ->EZ_PARCELA:= SEV->EV_PARCELA
		SEZ->EZ_CLIFOR := SEV->EV_CLIFOR
		SEZ->EZ_LOJA   := SEV->EV_LOJA
		SEZ->EZ_TIPO   := SEV->EV_TIPO
		SEZ->EZ_PERC   := (aMultNat[nX][5] / (cAliasTb)->&(cPrefTb+"VALOR")) 
		SEZ->EZ_VALOR  := aMultNat[nX][5]
		SEZ->EZ_NATUREZ:= SEV->EV_NATUREZ
		SEZ->EZ_CCUSTO := aMultNat[nX][1]
		SEZ->EZ_ITEMCTA:= aMultNat[nX][2]
		SEZ->EZ_CLVL   := aMultNat[nX][3]
		SEZ->EZ_CONTA  := aMultNat[nx][6]
		SEZ->EZ_RECPAG := SEV->EV_RECPAG
		SEZ->EZ_LA     := ""
		SEZ->EZ_IDENT  := SEV->EV_IDENT
		SEZ->EZ_IDDOC  := cIddoc 
		SEZ->EZ_SEQ    := SEV->EV_SEQ
		SEZ->EZ_SITUACA:= SEV->EV_SITUACA		

		nValEV := nValEV + aMultNat[nX][5]
		// Tratamento para entidades contabeis adicionais	
		cEntCC := "05"
		If 	Len(aMultNat[nX]) > 6
			For nY := 7 To Len(aMultNat[nX])
				SEZ->&("EZ_EC"+cEntCC+"DB") := aMultNat[nX][nY]
				nY ++
				SEZ->&("EZ_EC"+cEntCC+"CR") := aMultNat[nX][nY]
				cEntCC :=Soma1( cEntCC )
			Next nY
		EndIf	

		MsUnLock()

	Next nX	

	//Atualizo o valor da SEV 
	RecLock("SEV", .F. )
	SEV->EV_VALOR    := nValEV
	MsUnLock()

	RestArea(aAreaTb)
	lRet := .T.
EndIf

Return lRet
