#INCLUDE "FINA150.CH"
#include "PROTHEUS.ch"
#Include "fileio.ch"

Static __oTemp
Static __lPIXImp   := Nil
Static __lVldExtC  := Nil
Static __lFinPix   := Nil
Static __lBaImpPix := Nil   
Static __lIsBlind  := Nil
Static __lBordImp  := Nil
Static __lSitCPix  := Nil
Static __nCasasDc  := Nil
/*/


Ŀ
Funo     FINA150   Autor  Wagner Xavier          Data  26/05/92 
Ĵ
Descrio  Gerao do Arquivo de Envio de Titulos ao Banco            
Ĵ
Sintaxe    FINA150()                                                  
Ĵ
 Uso       Generico                                                   
ٱ


/*/
Function FINA150(nPosAuto)

Local lOk       := .F.
Local aSays     := {}
Local aButtons  := {}
Local lPanelFin := IsPanelFin()
Local lPergunte := .F.

PRIVATE cCadastro := OemToAnsi(STR0005)  // "Comunicao Bancria - Envio Cobrana"
PRIVATE cNomeSai  := ""
PRIVATE cArqBkp   := ""
PRIVATE lAborta   := .F.

If !IsBlind() .AND. GetHlpLGPD({"A1_NOME","A6_COD"})
	Return .F.
Endif

//Ŀ
// A funo SomaAbat reabre o SE1 com outro nome pela ChkFile, pois 
// o filtro do SE1, desconsidera os abatimentos					 |
//
SomaAbat("","","","R")

//Ŀ
// Variaveis utilizadas para parametros   
// mv_par01		 // Do Bordero 		   
// mv_par02		 // Ate o Bordero 	   
// mv_par03		 // Arq.Config 		   
// mv_par04		 // Arq. Saida    	   
// mv_par05		 // Banco     		   
// mv_par06		 // Agenciao     	   
// mv_par07		 // Conta   		   
// mv_par08		 // Sub-Conta  		   
// mv_par09		 // Cnab 1 / Cnab 2    
// MV_PAR10		 // Considera Filiais  
// MV_PAR11		 // De Filial   	   
// MV_PAR12		 // Ate Filial         
// MV_PAR13		 // Quebra por ?	   
// MV_PAR14		 // Seleciona Filial?  
//

//Ŀ
// Verifica as perguntas selecionadas                           
//
If lPanelFin
	lPergunte := PergInPanel("AFI150",.T.)
Else
	lPergunte := pergunte("AFI150",.T.)
Endif

If lPergunte
	dbSelectArea("SE1")
	dbSetOrder(1)
	
	//Ŀ
	// Inicializa o log de processamento                            
	//
	ProcLogIni( aButtons )
	
	If nPosAuto <> Nil
		lOk	:= .T.
	Else
		aADD(aSays,STR0015) // "Esta rotina permite gerar o arquivo de envio do CNAB de cobrana, com base nas ocorrncias"
		aADD(aSays,STR0016) // "cadastradas e com os borders de cobrana gerados."

		If lPanelFin  //Chamado pelo Painel Financeiro
			aButtonTxt := {}
			If Len(aButtons) > 0
				AADD(aButtonTxt,{STR0021,STR0021,aButtons[1][3]}) // Visualizar
			Endif
			AADD(aButtonTxt,{STR0003,STR0003, {||Pergunte("AFI150",.T. )}}) // Parametros
			FaMyFormBatch(aSays,aButtonTxt,{||lOk:=.T.},{||lOk:=.F.})
		Else
			aADD(aButtons, { 5,.T.,{|| Pergunte("AFI150",.T. ) } } )
			aADD(aButtons, { 1,.T.,{|| lOk := .T.,FechaBatch()}} )
			aADD(aButtons, { 2,.T.,{|| FechaBatch() }} )

			FormBatch( cCadastro, aSays, aButtons ,,,540)
		Endif
	Endif

	If lOk
		//Ŀ
		// Atualiza o log de processamento   
		//
		ProcLogAtu("INICIO")

		fa150Gera("SE1")

		//Ŀ
		// Atualiza o log de processamento   
		//
		ProcLogAtu("FIM")
	EndIf

	//Ŀ
	// Recupera a Integridade dos dados                             
	//
	dbSelectArea("SE1")
	dbSetOrder(1)
EndIf

Return

/*/


Ŀ
Funo     fA150Gera Autor  Wagner Xavier          Data  26/05/92 
Ĵ
Descrio  Comunicao Bancria - Envio                               
Ĵ
Sintaxe    fA150Gera(cAlias)                                          
Ĵ
 Uso       FINA150                                                    
ٱ


/*/
Function fa150Gera(cAlias)

PRIVATE cBanco,cAgencia,xConteudo
PRIVATE nHdlBco    	:= 0
PRIVATE nHdlSaida  	:= 0
PRIVATE nSeq       	:= 0
PRIVATE nSomaValor	:= 0
PRIVATE nSomaVlLote	:= 0
PRIVATE nQtdTotTit	:= 0
PRIVATE nQtdTitLote	:= 0
PRIVATE nSomaAcres	:= 0
PRIVATE nSomaDecre	:= 0
PRIVATE nBorderos	:= 0
PRIVATE xBuffer		:= ""
PRIVATE nLidos		:= 0
PRIVATE nTotCnab2	:= 0 // Contador de Lay-out nao deletar
PRIVATE nLotCnab2	:= 1 // Contador de Lotes do arquivo
PRIVATE nLinha		:= 0 // Contador de Linhas nao deletar
PRIVATE nQtdLinLote	:= 0 // Contador de linhas do detalhe do lote
PRIVATE nTotLinArq	:= 0 // Contador de linhas do CNAB

Processa({|lEnd| fa150Ger(cAlias)})  // Chamada com regua

nBorderos  := 0
nSeq       := 0
nSomaValor := 0
nSomaVlLote:= 0
nQtdTotTit := 0
nQtdTitLote:= 0
nLotCnab2  := 1
nTotLinArq := 0

FCLOSE(nHdlBco)
FCLOSE(nHdlSaida)

Return .T.

/*/


Ŀ
Funo     fA150Ger  Autor  Wagner Xavier          Data  26/05/92 
Ĵ
Descrio  Comunicao Bancria - Envio                               
Ĵ
Sintaxe    fA150Ger()                                                 
Ĵ
 Uso       FINA150                                                    
ٱ


/*/
Function fA150Ger(cAlias)
LOCAL nTamArq:=0
LOCAL lHeader:=.F.,lFirst:=.F.,lFirst2:=.F.
LOCAL nTam,nDec,nUltDisco:=0,nGrava:=0,aBordero:={}
LOCAL nSavRecno := recno()
Local lRecicl	:= GETMV("MV_RECICL")
Local cFile		:= ""
LOCAL lFIN150_1  := ExistBlock("FIN150_1")
LOCAL lFIN150_2  := ExistBlock("FIN150_2")
LOCAL lFIN150_3  := ExistBlock("FIN150_3")
LOCAL lFINA150   := ExistBlock("FIN150")
Local lFinCnab2  := ExistBlock("FINCNAB2")
LOCAL nRegEmp := SM0->(RecNo())
LOCAL cFilDe
LOCAL cFilAte
LOCAL cNumBorAnt := CRIAVAR("E1_NUMBOR",.F.)
LOCAL cCliAnt	  := CRIAVAR("E1_CLIENTE",.F.)
LOCAL lFirstBord := .T.
LOCAL lBorBlock := .F.
LOCAL lAchouBord := .F.
Local lF150Exc := ExistBlock("F150EXC")
LOCAL lIdCnab := .T.
Local cArqGerado := ""
Local lF150Sum := ExistBlock("F150SUM")
Local lAtuDsk := .F.
Local lCnabEmail := .F.
Local cFilBor := ""
Local nOrdSE1:=5
Local lF150Ord := ExistBlock("F150ORD")
Local lNovoLote := .F.
Local lF150SumA := ExistBlock("F150SUMA")
Local lF150SumD := ExistBlock("F150SUMD")
Local lF150BBCO := ExistBlock("F150BBCO")
Local lBCOBORD := .T.
Local lFimLin	:= .T.
Local lTrailler := .F.
Local cAliasTrb
Local lF150NoGrv := ExistBlock("F150NOGRV")
Local cLstSit := ""
Local aHlpSit := {}
Local cHlpSit := ""
Local nStatBkp := 0
//--- Tratamento Gestao Corporativa
Local lGestao	:= FWSizeFilial() > 2	// Indica se usa Gestao Corporativa
Local cFilFwSE1 := FwFilial("SE1")
Local cQuery 	:= ""
Local lHeadMod2 := .F.
Local bWhile2
Local cOrder
Local nValor
Local cCart	:= "R"
//Gestao
Local lQuery 	:= IfDefTopCTB() // verificar se pode executar query (TOPCONN)
Local aSelFil	:= {}
Local lSE1Acces := Iif( lGestao, FWModeAccess("SE1",1) == "C", FWModeAccess("SE1",3) == "C")
Local bWhile 	:= {||.T.}
Local nX		:= 1
Local lF150GRV  := ExistBlock("F150GRV")

ProcRegua(SE1->(RecCount()))

//Ŀ
// Posiciona no Banco indicado                                  
//
cBanco  := mv_par05
cAgencia:= mv_par06
cConta  := mv_par07
cSubCta := mv_par08

dbSelectArea("SA6")
If !(dbSeek(xFilial("SA6")+cBanco+cAgencia+cConta))
	Help(" ",1,"FA150BCO")

	//Ŀ
	// Atualiza o log de processamento com o erro  
	//
	ProcLogAtu("ERRO","FA150BCO",Ap5GetHelp("FA150BCO"))

	Return .F.
ElseIf Max(SA6->A6_MOEDA,1) > 1

	Help( "  ", 1, "MOEDACNAB" )

	//Ŀ
	// Atualiza o log de processamento com o erro  
	//
	ProcLogAtu("ERRO","FA150BCO",Ap5GetHelp("FA150BCO"))

	Return .F.
Endif

dbSelectArea("SEE")
SEE->( dbSeek(xFilial("SEE")+cBanco+cAgencia+cConta+cSubCta) )
If !SEE->( found() )
	Help(" ",1,"PAR150")

	//Ŀ
	// Atualiza o log de processamento com o erro  
	//
	ProcLogAtu("ERRO","PAR150",Ap5GetHelp("PAR150"))

	Return .F.
Else
	If !Empty(SEE->EE_FAXFIM) .and. !Empty(SEE->EE_FAXATU) .and. Val(SEE->EE_FAXFIM)-Val(SEE->EE_FAXATU) < 100
		Help(" ",1,"FAIXA150")
		//Ŀ
		// Atualiza o log de processamento com o erro  
		//
		ProcLogAtu("ERRO","FAIXA150",Ap5GetHelp("FAIXA150"))

	Endif
Endif

// Verifica se ser gerado uma linha no final do arquivo.
// Se nao existir o campo que determina se deve ou nao saltar
// a linha na gravacao do trailler do arquivo, ou se existir e
// estiver como "1-Sim", Grava o final de linha (Chr(13)+Chr(10))
If SEE->EE_FIMLIN == "1"
	lFimLin := .T.
Else
	lFimLin := .F.
EndIf

// MV_PAR10 - Considera filiais? -> 1-Sim / 2-No.
if MV_PAR10 == 2
	cFilDe := cFilAnt
	cFilAte:= cFilAnt
Else
	cFilDe := MV_PAR11
	cFilAte:= MV_PAR12
Endif

nTotCnab2 := 0
nSeq := 0

If lRecicl
	cFile := "RECICL" + Substr(cNumEmp,1,2) + ".TXT"
	If !File(cFile)
		lRecicl := .F.
	Else
		CArqRecicl(cFile, .T.)
	EndIf
EndIf

If lF150Ord
	nOrdSE1 := ExecBlock("F150ORD",.F.,.F.)
EndIf

//Gestao
If lQuery
	// MV_PAR14 - Seleciona filiais? -> 1-Sim / 2-No.
	If MV_PAR14 == 1
		// SE1 totalmente compartilhado nao habilita tela de selecao de filiais
		If lSE1Acces
			aSelFil := {cFilAnt}
		Else
			aSelFil := AdmGetFil(.F.,.T.,"SE1")
		Endif

		If Len(aSelFil) > 0
			cFilDe  := aSelFil[1]
			cFilAte := aTail(aSelFil)

			dbSelectArea("SM0")
			dbSetOrder(1) // M0_CODIGO, M0_CODFIL.
			MsSeek(cEmpAnt + cFilDe, .T.)
			bWhile := {|| Left(SM0->M0_CODFIL, FWSizeFilial()) <= cFilAte}
		Else
			bWhile := {|| .F.}  // Se no selecionou nenhuma filial, no processa nada.
		Endif
	Else
		dbSelectArea("SM0")
		dbSetOrder(1) // M0_CODIGO, M0_CODFIL.
		MsSeek(cEmpAnt + cFilDe, .T.)
		bWhile := {|| Left(SM0->M0_CODFIL, FWSizeFilial()) <= cFilAte}
	Endif
Else
	dbSelectArea("SM0")
	dbSetOrder(1) // M0_CODIGO, M0_CODFIL.
	MsSeek(cEmpAnt + cFilDe, .T.)
	lAchouBord := .F.
	bWhile := {|| FWGETCODFILIAL <= cFilAte}
Endif

While SM0->(!Eof()) .and. SM0->M0_CODIGO == cEmpAnt .and. Eval(bWhile)

	cFilAnt := FWGETCODFILIAL

	// Gestao
	// MV_PAR14 - Seleciona filiais? -> 1-Sim / 2-No.
	If lQuery .and. MV_PAR14 == 1
		// Verifico se a filial esta contida na matriz de filiais selecionadas pelo usuario
		If aScan(aSelFil, cFilAnt) = 0
			SM0->(dbSkip())
			Loop
		Endif
	Endif

	dbSelectArea("SE1")
	SE1->( dbSetOrder(nOrdSE1) )

	If (MV_PAR13 == 1 .And. mv_par09 == 2) .Or.;
		MV_PAR13 == 3 .Or. mv_par09 == 1 // Quebra por Bordero no CNAB modelo 2, ou se nao quebra ou se for CNAB modelo 1
		//Ŀ
		// Inicia a leitura do arquivo de Titulos                       
		//
		If lGestao
			SE1->( MSSeek( FWCompany("SE1") + FWUnitBusiness("SE1") + FWFilial("SE1") + mv_par01, .T. ) )
			bWhile2 := { || !SE1->( Eof()) .and. E1_NUMBOR >= mv_par01 .AND. E1_NUMBOR <= mv_par02 .and. FWCompany("SE1") + FWUnitBusiness("SE1") + FWFilial("SE1") == E1_FILIAL }
		Else
			SE1->( MSSeek(xFilial("SE1")+mv_par01,.T.))
			bWhile2 := { || !SE1->( Eof()) .and. E1_NUMBOR >= mv_par01 .AND. E1_NUMBOR <= mv_par02 .and. xFilial("SE1")==E1_FILIAL }
		EndIf

		cAliasTrb := "SE1"
	Elseif MV_PAR13 == 2 .And. mv_par09 == 2 // Quebra por Cliente no CNAB modelo 2
		//Ŀ
		// Inicia a leitura do arquivo de Titulos                       
		//
		cOrder := "E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO"

		cAliasTrb := GetNextAlias()
		cQuery := "SELECT SE1.R_E_C_N_O_ RECNOSE1 "
		cQuery += "FROM "+	RetSqlName("SE1") + " SE1"
		cQuery += " WHERE E1_FILIAL = '" + xFilial("SE1") + "'"
		cQuery += " AND E1_NUMBOR <> '" + Space(Len(SE1->E1_NUMBOR)) + "'"
		cQuery += " AND E1_NUMBOR between '" + mv_par01 + "' AND '" + mv_par02 + "'"
		cQuery += " AND D_E_L_E_T_ = ' ' "
		cQuery += " ORDER BY "+SqlOrder(cOrder)
		cQuery := ChangeQuery(cQuery)

		dbSelectArea("SA1")
		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasTrb, .F., .T.)
		bWhile2 := { || !(cAliasTrb)->( Eof()) }
	Endif

	// Processa SE1 filtrado por bordero em ordem de cliente ou em ordem de bordero
	While Eval(bWhile2)

		If MV_PAR13 == 2 .And. mv_par09 == 2 // quebra por cliente, CNAB modelo 2
			SE1->(MsGoto((cAliasTrb)->RECNOSE1))
		Endif

		lAchouBord := .T.
		IncProc()

		//PCREQ-3782 - Bloqueio por situao de cobrana
		cLstSit := F023VerBlq("2","0009")
		// Valida se est em situao de cobrana que bloqueia o envio de CNAB
		If SE1->E1_SITUACA $ cLstSit .AND. aScan(aHlpSit,SE1->E1_NUMBOR) == 0
			aadd(aHlpSit,SE1->E1_NUMBOR)//{SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA}
		Endif

		IF Empty(SE1->E1_NUMBOR) .or. SE1->E1_SITUACA $ cLstSit .or. (SE1->E1_NUMBOR == cNumBorAnt .and. lBorBlock )
			(cAliasTrb)->( dbSkip() )
			Loop
		EndIF

		If lF150BBCO
			lBCOBORD := Execblock("F150BBCO",.F.,.F.)
			lBCOBORD := IF(ValType(lBCOBORD) == "L", lBCOBORD, .T.)
		EndIf
		IF SE1->E1_PORTADO<>cBanco .And. cAgencia<>SE1->E1_AGEDEP .And. SE1->E1_CONTA<>cConta .And. lBCOBORD
			(cAliasTrb)->( dbSkip() )
			Loop
		EndIF

		//Ŀ
		// Verificacao do usuario se o bordero deve ser considerado     
		//
		If lF150Exc
			If !(ExecBlock("F150EXC",.F.,.F.))
				(cAliasTrb)->( dbSkip() )
				Loop
			Endif
		Endif

		//Ŀ
		// Verifica se o portador do bordero  o mesmo dos parametros   
		//
		// Se mudou o bordero ou se CNAB modelo 2, com quebra por cliente e mudou o cliente
		If SE1->E1_NUMBOR != cNumBorAnt .Or. (MV_PAR13 == 2 .And. mv_par09 == 2 .And. SE1->E1_CLIENTE != cCliAnt) .or. lFirstBord
			// Se CNAB modelo 2 e mudou o bordero ou cliente
			If (mv_par09 == 2 .And. (MV_PAR13 == 1 .And. SE1->E1_NUMBOR != cNumBorAnt) .Or. (MV_PAR13 == 2 .And. SE1->E1_CLIENTE != cCliAnt)) .And. !lFirstBord
				lNovoLote := .T. // Para criar Trailler de Lote e Header do novo lote
			Endif
			lFirstBord := .F.
			dbSelectArea("SEA")
			If Fa150PesqBord(SE1->E1_NUMBOR,@cFilBor,cCart)
				While SEA->EA_NUMBOR == SE1->E1_NUMBOR .and. SEA->EA_FILIAL == cFilBor .and. !Eof()
					If SEA->EA_CART == "R"
						cNumBorAnt := SE1->E1_NUMBOR
						cCliAnt	  := SE1->E1_CLIENTE
						lBorBlock := .F.
						If cBanco+cAgencia+cConta != SEA->(EA_PORTADO+EA_AGEDEP+EA_NUMCON) .And. lBCOBORD
							//Ŀ
							// Bordero pertence a outro Bco/Age/Cta 
							//
							Help(" ",1,"NOBCOBORD",,cNumBorAnt,4,1)

							//Ŀ
							// Atualiza o log de processamento com o erro  
							//
							ProcLogAtu("ERRO","NOBCOBORD",Ap5GetHelp("NOBCOBORD")+cNumBorAnt)

							lBorBlock := .T.
						Endif
						Exit
					Else
						//Ŀ
						// Bordero pertence a outra Carteira (Pagar) 
						//
						lBorBlock := .T.
						SEA->(dbSkip())
						Loop
					Endif
				Enddo
			Else
				//Ŀ
				// Bordero no foi achado no SEA        
				//
				Help(" ",1,"BORNOXADO",,SE1->E1_NUMBOR,4,1)

				//Ŀ
				// Atualiza o log de processamento com o erro  
				//
				ProcLogAtu("ERRO","BORNOXADO",Ap5GetHelp("BORNOXADO")+SE1->E1_NUMBOR)

				lBorBlock := .T.
			Endif
		Endif
		
		dbSelectArea(cAliasTrb)
		
		If lBorBlock
			(cAliasTrb)->( dbSkip() )
			Loop
		Endif

		IF SE1->E1_TIPO $ MVRECANT+"/"+MVPROVIS
			(cAliasTrb)->( dbSkip() )
			Loop
		EndIF

		IF SE1->E1_SALDO == 0
			(cAliasTrb)->( dbSkip() )
			Loop
		EndIF

		//Ŀ
	  	// Ponto de entrada para desprezar a gravao do ttulo que 
	  	// tenha algum impedimento no arquivo de envio.	         
		//
		If lF150NoGrv
			If !(Execblock("F150NOGRV",.F.,.F.))
				(cAliasTrb)->(dbSkip())
				Loop
			EndIf
		EndIf
	    
		//Posiciona no Contrato bancario
		dbSelectArea("SE9")
		SE9->(dbSetOrder(1))
		SE9->(MsSeek(xFilial("SE9")+SE1->(E1_CONTRAT+E1_PORTADO+E1_AGEDEP)))
	   
	    //Posiciona no cliente
		dbSelectArea("SA1")
		SA1->(DbSetOrder(1))
		SA1->(MsSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA))
		
		//Se o Header do arquivo nao foi criado, cria.
		If !lHeadMod2  //Modelo 2
			lHeadMod2:=AbrePar(@cArqGerado)	//Abertura Arquivo ASC II
			// Se houve erro na criacao do arquivo, abandona o processo
			If ! lHeadMod2
				Exit
			Endif
		Endif
		
		lCnabEmail := (SA1->A1_BLEMAIL == "1")
		
		If lFIN150_1
			Execblock("FIN150_1",.F.,.F.)
		Endif

		dbSelectArea(cAliasTrb)

		// Mudou de Bordero e nao eh o primeiro bordero. Cria Trailler de Lote e Novo Header de lote.
		If lNovoLote .And. mv_par09 == 2 .And. (MV_PAR13 == 1 .Or. MV_PAR13 == 2)
			nLotCnab2++
			nTotLinArq += nQtdLinLote  // Total das linhas do arquivo.

			// CNAB Modelo 2, gera Trailler do Lote anterior e Header do novo lote
			RodaLote2(nHdlSaida,MV_PAR03)
			HeadLote2(nHdlSaida,MV_PAR03)
			cNumBorAnt	:= SE1->E1_NUMBOR
			lNovoLote 	:= .F.
			nQtdTitLote := 0
			nQtdLinLote := 0
			nSomaVlLote := 0
		Endif

		If lRecicl
			dbSelectArea("CTEMP")
			If MsSeek(xFilial("SE1")+SE1->E1_NUMBCO)
				RecLock("CTEMP")
				dbDelete()
				MsUnLock()
			EndIf
		EndIf

		nSeq++
		nQtdTitLote ++
		nQtdTotTit ++

		If lF150Sum
			nValor := ExecBlock("F150SUM",.F.,.F.)
			nSomaValor	+= nValor
			nSomaVlLote += nValor
		Else
			nSomaValor	+= SE1->E1_SALDO+SE1->E1_SDACRES-SE1->E1_SDDECRE
			nSomaVlLote += SE1->E1_SALDO+SE1->E1_SDACRES-SE1->E1_SDDECRE
   		Endif
	   	If lF150SumA
			nSomaAcres += ExecBlock("F150SUMA",.F.,.F.)
		Else
		  	nSomaAcres += SE1->E1_SDACRES
		Endif

		If lF150SumD
			nSomaDecre += ExecBlock("F150SUMD",.F.,.F.)
		Else
		  	nSomaDecre += SE1->E1_SDDECRE
		Endif
		If ( MV_PAR09 == 1 )
			//Ŀ
			// Le Arquivo de Parametrizacao                                 
			//
			nLidos:=0
			FSEEK(nHdlBco,0,0)
			nTamArq:=FSEEK(nHdlBco,0,2)
			FSEEK(nHdlBco,0,0)
			lIdCnab := .T.

			While nLidos <= nTamArq

				//Ŀ
				// Verifica o tipo qual registro foi lido                       
				//
				xBuffer:=Space(85)
				FREAD(nHdlBco,@xBuffer,85)

				Do Case
					Case SubStr(xBuffer,1,1) == CHR(1)
						IF lHeader
							nLidos+=85
							Loop
						EndIF
					Case SubStr(xBuffer,1,1) == CHR(2)
						lFirst2 := .F. //Controle do detalhe tipo 5
						IF !lFirst
							lFirst := .T.
							FWRITE(nHdlSaida,CHR(13)+CHR(10))
							If lFINA150
								Execblock("FIN150",.F.,.F.)
							Endif
						EndIF
					Case SubStr(xBuffer,1,1) == CHR(4) .and.  lCnabEmail
						IF !lFirst2
							nSeq++
							lFirst2 := .T.
							FWRITE(nHdlSaida,CHR(13)+CHR(10))
						Endif
					Case SubStr(xBuffer,1,1) == CHR(3)
						nLidos+=85
						Loop
					Otherwise
						nLidos+=85
						Loop
				EndCase

				nTam := 1+(Val(SubStr(xBuffer,20,3))-Val(SubStr(xBuffer,17,3)))
				nDec := Val(SubStr(xBuffer,23,1))
				cConteudo:= SubStr(xBuffer,24,60)
				nGrava := fA150Grava(nTam,nDec,cConteudo,@aBordero,,lFinCnab2,@lIdCnab,cFilBor)
				If nGrava != 1
					nSeq--
					Exit
				Endif
				dbSelectArea("SE1")
				nLidos+=85
			EndDO
			If nGrava == 3
				Exit
			Endif
		Else
			nGrava := fA150Grava(,,,@aBordero,,lFinCnab2,@lIdCnab)
		EndIf

		If nGrava == 1
			lAtuDsk := .T.
			If ( MV_PAR09 == 1 )
				lIdCnab := .T.	// Para obter novo identificador do registro CNAB na rotina FA150GRAVA
	   			fWrite(nHdlSaida,CHR(13)+CHR(10))
				IF !lHeader
					lHeader := .T.
				EndIF
			Endif
			dbSelectArea("SEA")
			SEA->(DbSetOrder(1))
			If SEA->(MsSeek(cFilBor+SE1->E1_NUMBOR+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
				Reclock("SEA")
				SEA->EA_TRANSF := "S"
				MsUnlock()
			Endif
			If lRecicl
				dbSelectArea("SE1")
				RecLock("SE1")
				Replace E1_OCORREN With "01"
				MsUnLock()
			EndIf
		ElseIf nGrava == 3
			Exit
		Endif

		// Executa o ponto de entrada F150GRV somente para modelo 1
		If mv_par09 == 1 .And. lF150GRV
			//?
			//? Permite gravar linhas adicionais apos confirmar a gravacao da linha de     ?
			//? detalhe tipo "1", atendendo assim a IN09 da ANS (ABR/09) que dispoem sobre ?
			//? a informacao dos dados dos beneficiarios (dependentes) no boleto bancario  ?
			//??
			ExecBlock("F150GRV", .F., .F., { nHdlSaida } )
		EndIf

		If lFIN150_2
			nSeq++
			If !(Execblock("FIN150_2",.f.,.f.))		// No incrementou
				nSeq--
			Endif
		Endif
		dbSelectArea("SE1")
		(cAliasTrb)->( dbSkip())
	Enddo

	If lAborta
		Exit
	EndIf

	//PCREQ-3782 - Bloqueio por situao de cobrana
	//Informa quais ttulos no sero enviados por bloqueio de siuao de cobrana
	If len(aHlpSit) >= 1
			cHlpSit := CRLF
		For nX := 1 to len(aHlpSit)
			cHlpSit += aHlpSit[nX] + CRLF//aHlpSit[nX,1] +" - "+ aHlpSit[nX,2] +" - "+ aHlpSit[nX,3]
		Next nX
		Help(" ",1,"BLQENCNAB",,STR0024+CRLF+cHlpSit,1,0) //Os borders abaixo no foram enviados devido bloqueio por situao de cobrana
	Endif
	If MV_PAR13 == 2 .And. mv_par09 == 2 // Quebra por cliente CNAB modelo 2
		(cAliasTrb)->(DbCloseArea())
	Endif
	If lGestao
		If lAchouBord .And. Empty( cFilFwSE1 )
			Exit
		EndIf
	Else
		If Empty( cFilFwSE1 )
			Exit
		Endif
	EndIf
	dbSelectArea("SM0")
	dbSkip()
EndDO

SM0->(dbgoto(nRegEmp))
cFilAnt := FWGETCODFILIAL

If !lAchouBord
	Help(" ",1,"BORD150")

	//Ŀ
	// Atualiza o log de processamento com o erro  
	//
	ProcLogAtu("ERRO","BORD150",Ap5GetHelp("BORD150"))

	Return .F.
EndIF

// Se conseguiu criar o Header do arquivo, entao cria o Trailler
If lHeadMod2

	If ( mv_par09 == 1 )
		//Ŀ
		// Monta Registro Trailler                              		  
		//
		nSeq++
		nLidos:=0
		FSEEK(nHdlBco,0,0)
		nTamArq:=FSEEK(nHdlBco,0,2)
		FSEEK(nHdlBco,0,0)
		While nLidos <= nTamArq

			//Ŀ
			// Tipo qual registro foi lido                                  
			//
			xBuffer:=Space(85)
			FREAD(nHdlBco,@xBuffer,85)

			IF SubStr(xBuffer,1,1) == CHR(3)
				lTrailler := .T.
				nTam := 1+(Val(SubStr(xBuffer,20,3))-Val(SubStr(xBuffer,17,3)))
				nDec := Val(SubStr(xBuffer,23,1))
				cConteudo:= SubStr(xBuffer,24,60)
				nGrava:=fA150Grava( nTam,nDec,cConteudo,@aBordero,.T.,lFinCnab2,.F.,cFilBor)
			Endif
			nLidos+=85
		End
		If lTrailler .And. lFimLin
			FWRITE(nHdlSaida,CHR(13)+CHR(10))
		Endif
	Else
		nTotLinArq += nQtdLinLote  // Total das linhas do arquivo.
		RodaCnab2(nHdlSaida,MV_PAR03,lFimLin)
	EndIf
	//Ŀ
	// Atualiza Numero do ultimo Disco                              
	//
	dbSelectArea("SEE")
	IF !Eof() .and. nGrava != 3 .and. lAtuDsk
		Reclock("SEE")
		nUltDisco:=VAL(EE_ULTDSK)+1
		Replace EE_ULTDSK With StrZero(nUltDisco,TamSx3("EE_ULTDSK")[1])
		MsUnlock()
	EndIF

	dbSelectArea( cAlias )
	dbGoTo( nSavRecno )

	//Ŀ
	// Fecha o arquivos utilizados                                  
	//
	FCLOSE(nHdlBco)
	FCLOSE(nHdlSaida)

	If nGrava == 3 // Abandonou a rotina, quando o bordero ja foi enviado.
		// Apaga o arquivo de saida, para nao caracterizar um erro no programa a geracao incompleta do arquivo quando o usuario cancelar.
		If FErase(cArqGerado) = 0
			If !Empty(cArqBkp)
				nStatBkp := FRenameEx( cArqBkp , cNomeSai  )
				If nStatBkp <> 0
					Help(" ",1,"F150ERRREST",,Str(fError(),4),1,0)
				EndIf
			EndIf
		EndIf

		ProcLogAtu("ERRO","",STR0019) //"Processo Cancelado por usurio. Arquivo no gerado"
	Else
		ProcLogAtu("ALERTA","",STR0020+cArqGerado) //"Processo Finalizado. Arquivo gerado: "
	Endif

	If lRecicl
		dbSelectArea("CTEMP")
		Pack
		CArqRecicl(cFile, .F.)
	EndIF

	If lFIN150_3
		Execblock("FIN150_3",.F.,.F.)
	Endif

Endif

//Ponto de entrada para verificacao do conteudo da variavel nQtdTotTit
If ExistBlock ("F150QTDT")
	ExecBlock("F150QTDT",.F.,.F.,{nQtdTotTit,nGrava})
EndIf

dbSelectArea( cAlias )
dbGoTo( nSavRecno )
//Ŀ
// Recupera a Integridade dos dados                             
//
RetIndex("SE1")
dbSetOrder(1)
dbClearFilter()

Return(.T.)

/*/


Ŀ
Funo    AbrePar    Autor  Wagner Xavier          Data  26/05/92 
Ĵ
Descrio Abre arquivo de Parametros                                  
Ĵ
Sintaxe   AbrePar()                                                   
Ĵ
 Uso      FINA150                                                     
ٱ


/*/
Function AbrePar(cArqGerado As Character, lPix As Logical) As Logical

	Local aArea		As Array
	Local cArqEnt	As Character
	Local cArqSaida	As Character
	Local cDirEnvio	As Character
	Local cHoraBkp	As Character
	Local lF150Arq	As Logical
	Local nOpcArq	As Numeric
	Local nStatBkp	As Numeric

	Default lPix := .F.

	aArea		:= GetArea()
	cArqEnt		:= MV_PAR03
	cArqSaida	:= ""
	cDirEnvio	:= AllTrim(SuperGetMV("MV_LOCENV", .F., .F.))
	cHoraBkp	:= ""
	lF150Arq	:= ExistBlock("F150ARQ")
	nOpcArq		:= 0
	nStatBkp	:= 0

	If __lVldExtC == Nil
		__lVldExtC := FindFunction("VldExtCNAB")
	EndIf

	//MV_LOCENV - Parmetro onde ser gravado o diretrio
	If Empty(cDirEnvio) .or. (lPix .and. GetRemoteType() <> 2)	// Nao trata Unix

		If AT(".",mv_par04)>0 .and. (AT("/",mv_par04)>0 .or. AT("\",mv_par04)>0)
			cArqSaida:=SubStr(TRIM(mv_par04),1,AT(".",mv_par04)-1)+"."+TRIM(SEE->EE_EXTEN)

		elseif (AT("/",mv_par04)>0 .or. AT("\",mv_par04)>0)
			cArqSaida:= alltrim(mv_par04)+"."+TRIM(SEE->EE_EXTEN)
		else
			Help(" ",1,"F150ARQ",,STR0022,1,0) //"Nome do Arquivo de Saida Invlido
			Return .F.
		EndIf

	ElseIf !Empty(MV_PAR04) .And. At(":", MV_PAR04) == 0 .And. (At("/", MV_PAR04) == 0 .Or. At("\", MV_PAR04) == 0) ;
			.And. (At("/", cDirEnvio) > 0	.Or. At("\", cDirEnvio) > 0)

		If At("/", cDirEnvio) > 0 .And. RAt("/", SubStr(cDirEnvio, Len(cDirEnvio), 1)) == 0

			If AT(".",mv_par04)>0
				cArqSaida := cDirEnvio + "/" + SubStr(Trim(MV_PAR04), 1, At(".", MV_PAR04) - 1) + "." + Trim(SEE->EE_EXTEN)
			Else
				cArqSaida := cDirEnvio + "/" + Trim(MV_PAR04) + "." + Trim(SEE->EE_EXTEN)
			Endif

		ElseIf At("/", cDirEnvio) > 0 .And. RAt("/", SubStr(cDirEnvio, Len(cDirEnvio), 1)) > 0

			If AT(".",mv_par04)>0
				cArqSaida := cDirEnvio + SubStr(Trim(MV_PAR04), 1, At(".", MV_PAR04) - 1) + "." + Trim(SEE->EE_EXTEN)
			Else
				cArqSaida := cDirEnvio + Trim(MV_PAR04) + "." + Trim(SEE->EE_EXTEN)
			Endif

		ElseIf At("\" ,cDirEnvio) > 0 .And. RAt("\", SubStr(cDirEnvio, Len(cDirEnvio), 1)) == 0

			If AT(".",mv_par04)>0
				cArqSaida := cDirEnvio + "\" + SubStr(Trim(MV_PAR04), 1, At(".", MV_PAR04) - 1) + "." + Trim(SEE->EE_EXTEN)
			Else
				cArqSaida := cDirEnvio + "\" + Trim(MV_PAR04) + "." + Trim(SEE->EE_EXTEN)
			Endif

		ElseIf At("\", cDirEnvio) > 0 .And. RAt("\", SubStr(cDirEnvio, Len(cDirEnvio), 1)) > 0

			If AT(".",mv_par04)>0
				cArqSaida := cDirEnvio + SubStr(Trim(MV_PAR04), 1, At(".", MV_PAR04) - 1) + "." + Trim(SEE->EE_EXTEN)
			Else
				cArqSaida := cDirEnvio + Trim(MV_PAR04) + "." + Trim(SEE->EE_EXTEN)
			Endif
		 EndIf

	ElseIf Empty(MV_PAR04) .Or. (At("/", MV_PAR04) > 0 .Or. At("\", MV_PAR04) > 0 .Or. At(":", MV_PAR04) > 0)

		Help(" ",1,"F150ARQ",,STR0023,1,0) //"Nome do Arquivo de Saida Invlido
		Return .F.

	EndIf

	If lF150Arq .and. !FWIsInCallStack("FA150PIX")
		cArqSaida := ExecBlock("F150ARQ",.F.,.F.,cArqSaida)
	EndIf

	If GetRemoteType() == 2	// Linux / Unix
		cArqSaida := Lower(StrTran(cArqSaida,"\","/"))
	EndIf

	cArqGerado := cArqSaida

	nPosFim := RAt("/", cArqGerado)

	If !(nPosFim > 0)
		nPosFim := RAt("\", cArqGerado)
	EndIf

	If !(ExistDir(Left(cArqGerado, nPosFim)))
		Help("", 1, "NODIR")
		Return .F.
	EndIf

	IF !(File(cArqEnt))
		Help(" ",1,"NOARQPAR")
		//Atualiza o log de processamento com o erro
		ProcLogAtu("ERRO","NOARQPAR",Ap5GetHelp("NOARQPAR"))
		Return .F.
	ElseIf __lVldExtC .And. !(VldExtCNAB(SubStr(cArqEnt, At(".", cArqEnt) + 1), "FINA150"))
		Return .F.
	Else
		If (MV_PAR09 == 1)
			nHdlBco := FOpen(cArqEnt, 0 + 64)
		EndIf
	EndIf

	//Cria Arquivo Saida
	cNomeSai := AllTrim(cArqSaida)

	If File(cNomeSai)
		nOpcArq := Aviso(STR0028 + " !!!" , + ;
		STR0029 + " '" + Alltrim(cNomeSai) + "' " + STR0030 + CRLF + CRLF + ;
		STR0031 + CRLF + CRLF + ;
		STR0032 + CRLF + CRLF + ;
		STR0033 + CRLF + CRLF + CRLF + CRLF + ;
		STR0012 , {STR0034,STR0035,STR0001} )
		If nOpcArq == 2
			cHoraBkp := Time()
				cArqBkp  := AllTrim(cNomeSai) + "_" + DToS(ddatabase) + "_" + SubStr(cHoraBkp, 1, 2) + SubStr(cHoraBkp, 4, 2) + ".bkp"
			nStatBkp := FRenameEx( cNomeSai , cArqBkp )
			If nStatBkp <> 0
				Help(" ",1,"F150ERRBKP",,Str(fError(),4),1,0)
				lAborta := .T.
				Return .F.
			EndIf
		ElseIf nOpcArq == 3
			lAborta := .T.
			Return .F.
		EndIf
	EndIf

	If ( MV_PAR09 == 1 )
		nHdlSaida:=MSFCREATE(cArqSaida,0)
	Else
		nHdlSaida:=HeadCnab2(cArqSaida,MV_PAR03)
	Endif

	RestArea(aArea)

Return .T.

/*/


Ŀ
Funo    fA150Grava Autor  Wagner Xavier          Data  26/05/92 
Ĵ
Descrio Rotina de Geracao do Arquivo de Remessa de Comunicacao      
          Bancaria                                                    
Ĵ
Sintaxe   ExpL1:=fa150Grava(ExpN1,ExpN2,ExpC1)                        
Ĵ
 Uso       FINA150                                                    
ٱ


/*/
STATIC Function fA150Grava( nTam,nDec,cConteudo,aBordero,lTrailler,lFinCnab2,lIdCnab,cFilBor)
Local nRetorno := 1
Local nX       := 1
Local oDlg, oRad, nTecla
Local cIdCnab
Local aGetArea := GetArea()
Local aOrdSE1  := {}
Local lPanelFin := IsPanelFin()

Local cChaveID := ""
Local nOrdCNAB := 19

DEFAULT lIdCnab := .F.
DEFAULT cFilBor := xFilial("SEA")

lTrailler := IIF( lTrailler==NIL, .F., lTrailler ) // Para imprimir o trailler
                                                   // caso se deseje abandonar
                                                   // a gerao do arquivo
                                                   // de envio pela metade

lFinCnab2 := Iif( lFinCnab2 == Nil, .F., lFinCnab2 )

//Ŀ
// O retorno podera' ser :                                  
// 1 - Grava Ok                                             
// 2 - Ignora bordero                                       
// 3 - Abandona rotina                                      
//
//Ŀ
// Verifica se titulo ja' foi enviado                       
//
dbSelectArea("SEA")
SEA->(DbSetOrder(1))
If	(!SE1->( Eof()) .and. SE1->E1_NUMBOR >= mv_par01 .AND. SE1->E1_NUMBOR <= mv_par02 .and. xFilial("SE1")==SE1->E1_FILIAL) .And.;
	(SEA->(MsSeek(cFilBor+SE1->E1_NUMBOR+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO)))
	If SEA->EA_TRANSF == "S"
		nX := ASCAN(aBordero,SubStr(SE1->E1_NUMBOR,1,6))
		If nX == 0
			nOpc := 0
			aSize := MSADVSIZE()
			If lPanelFin  //Chamado pelo Painel Financeiro
				oPanelDados := FinWindow:GetVisPanel()
				oPanelDados:FreeChildren()
				aDim := DLGinPANEL(oPanelDados)
				DEFINE MSDIALOG oDlg OF oPanelDados:oWnd FROM 0,0 To 0,0 PIXEL STYLE nOR( WS_VISIBLE, WS_POPUP )

				//Ŀ
				// Observacao Importante quanto as coordenadas calculadas abaixo: 
				// -------------------------------------------------------------- 
				// a funcao DlgWidthPanel() retorna o dobro do valor da area do	 
				// painel, sendo assim este deve ser dividido por 2 antes da sub- 
				// tracao e redivisao por 2 para a centralizacao. 					 
				//
				nEspLarg := ((DlgWidthPanel(oPanelDados)/2) - 114) /2
				nEspLin  := 0

		   Else
		   	nEspLarg := 0
		   	nEspLin  := 0
				DEFINE MSDIALOG oDlg FROM  035,037 TO 188,383 TITLE OemToAnsi(STR0009) PIXEL  // "Bordero Existente"
			Endif
			oDlg:lMaximized := .F.
			oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20)
			oPanel:Align := CONTROL_ALIGN_ALLCLIENT

			@ 037+nEspLin,006+nEspLarg TO 069+nEspLin, 120+nEspLarg LABEL OemToAnsi(STR0012) OF oPanel  PIXEL  //"Para prosseguir escolha uma das opes"

			@ 011+nEspLin, 007+nEspLarg SAY OemToAnsi(STR0010) 			SIZE 058, 007 OF oPanel PIXEL  // "O border nmero:"
			@ 011+nEspLin, 068+nEspLarg MSGET SE1->E1_NUMBOR When .F. 	SIZE 037, 010 OF oPanel PIXEL
			@ 024+nEspLin, 007+nEspLarg SAY OemToAnsi(STR0011) 			SIZE 082, 007 OF oPanel PIXEL  // "j foi enviado ao banco."
			@ 045+nEspLin, 011+nEspLarg RADIO oRad VAR nTecla 3D	 		SIZE 065, 011 PROMPT OemToAnsi(STR0013),OemToAnsi(STR0014) OF oPanel PIXEL  // "Gera com esse border"###"Ignora esse border"

			If lPanelFin  //Chamado pelo Painel Financeiro
				ACTIVATE MSDIALOG oDlg CENTERED ON INIT FaMyBar(oDlg,{||nOpc:=1,oDlg:End()},{||nOpc:=0,oDlg:End()})

		   Else
				DEFINE SBUTTON FROM 011, 0140 TYPE 1 ENABLE OF oPanel Action (nOpc:=1,oDlg:End())
				DEFINE SBUTTON FROM 024, 0140 TYPE 2 ENABLE OF oPanel Action (nOpc:=0,oDlg:End())
				ACTIVATE MSDIALOG oDlg Centered
			Endif

			If nOpc == 1
				If nTecla == 1
					nRetorno := 1
					nBorderos++
				Else
					nRetorno := 2
				EndIf
			Else
				nRetorno := 3
				lAborta := .T.
			EndIf
		Else
			nRetorno := Int(Val(SubStr(aBordero[nX],7,1)))
		EndIf
	EndIf
EndIf

If nRetorno == 1 .or. ( lTrailler .and. nBorderos > 0 )

	If ( MV_PAR09 == 1 )
		If !lTrailler .and. lIdCnab .And. Empty(SE1->E1_IDCNAB) // So gera outro identificador, caso o titulo ainda nao o tenha, pois pode ser um re-envio do arquivo
			// Gera identificador do registro CNAB no titulo enviado
			cIdCnab := GetSxENum("SE1", "E1_IDCNAB","E1_IDCNAB"+cEmpAnt,nOrdCNAB)
			cChaveID := cIdCnab
			dbSelectArea("SE1")
			aOrdSE1 := SE1->(GetArea())
			dbSetOrder(nOrdCNAB)
			While SE1->(MsSeek(cChaveID))
				ConOut("Id CNAB " + cIdCnab + " j existe para o arquivo SE1. Gerando novo nmero ")
				If ( __lSx8 )
					ConfirmSX8()
				EndIf
				cIdCnab := GetSxENum("SE1", "E1_IDCNAB","E1_IDCNAB"+cEmpAnt,nOrdCNAB)
				cChaveID := cIdCnab
			EndDo

			//Ŀ
			// Ponto de entrada para tratamento da variavel cIdCnab     
			//
			If ExistBlock ("F150ICNB")
				cIdCnab := ExecBlock("F150ICNB",.F.,.F.,{cIdCnab})
			EndIf

			SE1->(RestArea(aOrdSE1))
			Reclock("SE1")
			SE1->E1_IDCNAB := cIdCnab
			MsUnlock()
			ConfirmSx8()
			lIdCnab := .F. // Gera o identificacao do registro CNAB apenas uma vez no
								// titulo enviado
		Endif
		//Ŀ
		// Analisa conteudo                                         
		//
		IF Empty(cConteudo)
			cCampo:=Space(nTam)
		Else
			lConteudo := fa150Orig( cConteudo )
			IF !lConteudo
				RestArea(aGetArea)
				Return nRetorno
			Else
				IF ValType(xConteudo)="D"
					cCampo := GravaData(xConteudo,.F.)
				Elseif ValType(xConteudo)="N"
					cCampo:=Substr(Strzero(xConteudo,nTam,nDec),1,nTam)
				Else
					cCampo:=Substr(xConteudo,1,nTam)
				EndIf
			EndIf
		EndIf
		If Len(cCampo) < nTam  //Preenche campo a ser gravado, caso menor
			cCampo:=cCampo+Space(nTam-Len(cCampo))
		EndIf
		Fwrite( nHdlSaida,cCampo,nTam )
	Else
		nTotCnab2++
		DetCnab2(nHdlSaida,MV_PAR03,lIdCnab,"SE1")
		lIdCnab := .T.	// Para obter novo identificador do registro CNAB na rotina
							// DetCnab2
		If lFinCnab2
			nSeq := Execblock("FINCNAB2",.F.,.F.,{nHdlSaida,nSeq,nTotCnab2})
		EndIf
	EndIf
EndIf
If nX == 0
	Aadd(aBordero,Substr(SE1->E1_NUMBOR,1,6)+Str(nRetorno,1))
EndIf
RestArea(aGetArea)

If lPanelFin  //Chamado pelo Painel Financeiro
	cAlias := FinWindow:cAliasFile
	dbSelectarea(cAlias)
	FinVisual(cAlias,FinWindow,(cAlias)->(Recno()),.T.)
Endif

Return nRetorno

/*/


Ŀ
Funo     NossoNum  Autor  Paulo Boschetti        Data  05/11/93 
Ĵ
Descrio  Retorna digito de controle                                 
Ĵ
Sintaxe    		                                                     
Ĵ
 Uso       Generico                                                   
ٱ


/*/
Function NossoNum( )

Local cNumero := ""
Local nTam := TamSx3("EE_FAXATU")[1]

While !MayIUseCode( SEE->(EE_FILIAL+EE_CODIGO+EE_AGENCIA+EE_CONTA+EE_SUBCTA))  //verifica se esta na memoria, sendo usado
	Sleep(100)
EndDo
// Reposiciona o registro da SEE devido a atualizao da outra Thread. 
SEE->(DbGoto(SEE->(Recno()))) 

cNumero := StrZero(Val(SEE->EE_FAXATU),nTam)

If Empty(SE1->E1_NUMBCO)

	RecLock("SE1",.F.)
	Replace SE1->E1_NUMBCO With cNumero
	SE1->( MsUnlock( ) )

	RecLock("SEE",.F.)
	Replace SEE->EE_FAXATU With Soma1(cNumero, nTam)
	SEE->( MsUnlock() )

EndIf

Leave1Code(SEE->(EE_FILIAL+EE_CODIGO+EE_AGENCIA+EE_CONTA+EE_SUBCTA))
DbSelectArea("SE1")

Return(SE1->E1_NUMBCO)
/*/

Ŀ
Funo     Fa150Chav Autor  Paulo Boschetti        Data  10/11/93 
Ĵ
Descrio                                                             
Ĵ
Sintaxe    Fa150Num()                                                 
Ĵ
 Uso       FINA130                                                    
ٱ


/*/
Function Fa150Chav()
LOCAL lRetorna := .T.
LOCAL cVar   := READVAR()

// Valida se existe a conta Oficial
If  (cVar == "M->EE_CTAOFI" .or. cVar == "M->EE_AGEOFI" .OR. cVar == "M->EE_CODOFI" )
	If !EMPTY(M->EE_CODOFI) .AND. !EMPTY(M->EE_AGEOFI).AND. !EMPTY(M->EE_CTAOFI)
		If FWIsInCallStack("FINA130") .and. !existcpo("SA6",M->EE_CODOFI+M->EE_AGEOFI+M->EE_CTAOFI)
			lRetorna := .F.
		EndIf
	EndIf
elseIf !Empty(m->ee_codigo) .And. !Empty(m->ee_agencia) .And. !Empty(m->ee_conta) .And. !Empty(m->ee_subcta)
	dbSelectArea("SEE")
	dbSetOrder(1)
	SEE->( MsSeek(xFilial("SEE")+m->ee_codigo+m->ee_agencia+m->ee_conta+m->ee_subcta) )
	If SEE->( Found() )
		Help(" ",1,"FA150NUM")

		//Ŀ
		// Atualiza o log de processamento com o erro  
		//
		ProcLogAtu("ERRO","FA150NUM",Ap5GetHelp("FA150NUM"))

		lRetorna := .F.
	EndIf
	If FunName() == "FINA130" .and. !existcpo("SA6",m->ee_codigo+m->ee_agencia+m->ee_conta)
		lRetorna := .F.
	EndIf

Endif
Return lRetorna


/*/

Ŀ
Funo    fa150Orig  Autor  Wagner Xavier          Data  10/11/92 
Ĵ
Descrio Verifica se expressao e' valida para Remessa CNAB.          
Ĵ
 Uso      FINA150                                                     
ٱ


/*/
Function fa150Orig( cForm )
Local bBlock:=ErrorBlock()
Private lRet := .T.

BEGIN SEQUENCE
	xConteudo := &cForm
END SEQUENCE
ErrorBlock(bBlock)
Return lRet


/*/


Ŀ
Funo     SomaValor Autor  Vinicius Barreira      Data  09/01/95 
Ĵ
Descrio  Retorna o valor total dos titulos remetidos                
Ĵ
Sintaxe    SomaValor()                                                
Ĵ
 Uso       Generico                                                   
ٱ


/*/
Function SomaValor()
Return nSomaValor * 100
/*/


Ŀ
Funo    SomaVlLote Autor  Claudio Donizete       Data  28/12/05 
Ĵ
Descrio  Retorna o valor dos titulos remetidos do lote              
Ĵ
Sintaxe    SomaVlLote()                                               
Ĵ
 Uso       Generico                                                   
ٱ


/*/
Function SomaVlLote()
Return nSomaVlLote * 100
/*/


Ŀ
Funo    QtdTotTit  Autor  Claudio Donizete       Data  28/12/05 
Ĵ
Descrio  Retorna a qtde. total dos titulos remetidos                
Ĵ
Sintaxe    QtdTotTit()  	                                            
Ĵ
 Uso       Generico                                                   
ٱ


/*/
Function QtdTotTit()
Return nQtdTotTit
/*/


Ŀ
Funo    QtdTitLote Autor  Claudio Donizete       Data  28/12/05 
Ĵ
Descrio  Retorna a qtde. dos titulos remetidos do lote              
Ĵ
Sintaxe    QtdTitLote()                                               
Ĵ
 Uso       Generico                                                   
ٱ


/*/
Function QtdTitLote()
Return nQtdTitLote

/*/


Ŀ
Funo    Fa150PesqB Autor  Claudio D. de Souza    Data  20/09/04 
Ĵ
Descrio  Pesquisa Bordero em todas as filiais e atualiza o parametro|
           cFilBor com a filial em que foi encontrada o bordero       |
Ĵ
Sintaxe    Fa420PesqBord(cNumBor,cFilBor)							  
Ĵ
 Uso       FINA420                                                    
ٱ


/*/
Function Fa150PesqBord(cNumBor,cFilBor,cCart)
Local cFilOld 	:= cFilAnt
Local lRet 		:= .F.
Local nInc		:= 0
Local cAlias	:= Alias()
Local aSM0		:= AdmAbreSM0()
Local aFiliais  := {}
Local nPos      := 0

//--- Tratamento Gestao Corporativa
Local cFilFwSEA := FwFilial("SEA")

Default cCart	:= ""

// Se deve pesquisar com a carteira do bordero "P" ou "R"
If !Empty( cCart )
	SEA->( dbSetOrder( 2 ) )
Else
	SEA->( dbSetOrder( 1 ) )
EndIf

If !Empty( cFilFwSEA ) // Se o SEA for exclusivo, pesquisa o bordero em todas as filiais
	For nInc := 1 To Len( aSM0 )
		If aSM0[nInc][1] == cEmpAnt
			cFilAnt := aSM0[nInc][2]
			If SEA->( MsSeek( xFilial( "SEA" ) + cNumBor + cCart ) )
				aadd(aFiliais,{SEA->EA_FILIAL,SEA->(Recno())})
				lRet	:= .T.
			EndIf
		EndIf
	Next
Else
	lRet := SEA->( MsSeek( xFilial( "SEA" ) + cNumBor + cCart ) )
	cFilBor := SEA->EA_FILIAL
Endif
nPos := aScan(aFiliais,{|x| x[1]== cFilOld})
If nPos > 0
	cFilBor := aFiliais[nPos,1]
	//Posiciono no border da filial corrente.
	SEA->(dbGoto(aFiliais[nPos,2]))
ElseIf Len(aFiliais)>=1
	cFilBor := aFiliais[1,1]
	//Posiciono no border da primeira filial.
	SEA->(dbGoto(aFiliais[1,2]))
Endif

// Restaura ambiente
cFilAnt := cFilOld

dbSelectArea( cAlias )

Return lRet


/*/

Ŀ
Funo    FINA150T    Autor  Marcelo Celi Marques  Data  15.05.08 
Ĵ
Descrio  Chamada semi-automatica utilizado pelo gestor financeiro   
Ĵ
 Uso       FINA150                                                    
ٱ


/*/
Function FINA150T(aParam)

	cRotinaExec := "FINA150"
	ReCreateBrow("SE1",FinWindow)
	FINA150()
	ReCreateBrow("SE1",FinWindow)

	dbSelectArea("SE1")

	INCLUI := .F.
	ALTERA := .F.

Return .T.

/*/


Ŀ
Funo    AdmAbreSM0 Autor  Orizio                 Data  22/01/10 
Ĵ
Descrio Retorna um array com as informacoes das filias das empresas 
Ĵ
 Uso       Generico                                                   
ٱ


/*/
Static Function AdmAbreSM0()
	Local aArea			:= SM0->( GetArea() )
	Local aRetSM0		:= FWLoadSM0()

	RestArea( aArea )
Return aRetSM0


/*/

Ŀ
Funo	 F150LinLot Autor  Gustavo Henrique      Data  08/08/11 
Ĵ
Descrio  Retorna o total de linhas do detalhe do lote		         
           Usado na configuracao do CNAB2 Receber   				 
Ĵ
 Uso		  Configurador do CNAB2 Receber	 						 
ٱ


/*/
Function F150LinLot()
Return nQtdLinLote+1		// esta variavel armazena o numero de linhas, considerando os segmentos do detalhe do lote

//-------------------------------------------------------------------
/*/{Protheus.doc}CARQRECICL
Cria arquivo temporrio / Txt com os nmeros reciclados dos ttulos
no processo de CNAB.

@param cFile - Nome do arquivo de reciclagem (.TXT)
@param lTemp - Define se cria o arquivo temporrio ou o prprio .TXT

@author Rodrigo Oliveira
@since  25/05/2018
/*/
//-------------------------------------------------------------------

Function CArqRecicl(cFile, lTemp)

	Local aArea		:= GetArea()
	Local nTmArqRec	:= 0
    Local nHdl		:= 0
    Local cFil		:= ""
    Local cNosNum	:= ""
    Local nTamFil	:= FWGETTAMFILIAL
    Local nTamNNum	:= TamSX3("E1_NUMBCO")[1]
    Local nLin		:= nTamFil + nTamNNum
    Local aStru		:= { {"FILIAL  ", "C", nTamFil, 0},;
    					{"NOSSONUM", "C", nTamNNum, 0}}
    Local nI		:= 0
    Local cBuf		:= Space(nLin)

	If lTemp
		If ( nHdl	:= fOpen(cFile, FO_READWRITE + FO_SHARED) ) == -1
			Help(" ",1,"F200RECICL",,STR0025 + str(ferror(),4),1,0) // 'Erro de abertura: FERROR n '
		Else
			If(__oTemp <> NIL)

				__oTemp:Delete()
				__oTemp := NIL

			EndIf

			//Criando a tabela temporaria
			__oTemp := FwTemporaryTable():New("CTEMP")
			//Setando as colunas
			__oTemp:SetFields(aStru)
			//Criando o indicie
			__oTemp:AddIndex("1",{"FILIAL", "NOSSONUM"})
			//Criando a Tabela Temporaria
			__oTemp:Create()

			nTmArqRec := FSeek(nHdl,0,2)
		  	FSeek(nHdl,0,0)
		  	For nI := 1 to nTmArqRec
		  		FRead(nHdl, @cBuf, nLin)
		  		cFil 	:= Left(cBuf,nTamFil)
		  		cNosNum	:= SubStr(cBuf, nTamFil + 1, nTamNNum)
		  		RecLock("CTEMP",.T.)
		  		Replace FILIAL		With xFilial("SE1")
		  		Replace NOSSONUM 	With cNosNum
		  		MsUnlock()
		  		FSeek(nHdl,2,1)
		  		nI	+= (nLin + 1)
		  	Next
		EndIf
	Else
		If FERASE(cFile) == -1
			Help(" ",1,"F150RECICL",,STR0026 + str(ferror(),4),1,0) // 'No foi possvel deletar o arquivo de reciclagem: FERROR n '
		Else
			If !(CTEMP->(BOF()) .And. CTEMP->(EOF()) )
				If ( nHdl := fCreate(cFile) ) == -1
					Help(" ",1,"F150RECICL",,STR0027 + str(ferror(),4),1,0) // 'Erro na gerao do arquivo de reciclagem: FERROR n '
				Else
					CTEMP->(DbGoTop())
					While !Eof()
						nTmArqRec := FSeek(nHdl,0,FS_END)
						If nTmArqRec > 0
							FWrite(nHdl, Chr(13) + Chr(10) + CTEMP->FILIAL + PadR(CTEMP->NOSSONUM, nTamNNum))
						Else
							FWrite(nHdl, CTEMP->FILIAL + PadR(CTEMP->NOSSONUM, nTamNNum))
						EndIf
						DbSkip()
					EndDo
					CTEMP->(DbCloseArea())
				EndIf
			EndIf
		Endif
	EndIf

	fClose(nHdl)
	RestArea(aArea)

Return


/*/


Ŀ
Funo     FA150PIX  Autor  Rodrigo Franco      Data  30/10/2020  
Ĵ
Descrio  Comunicao Bancria - Envio Arquivo PIX                   
Ĵ
Sintaxe    FA150PIX()                                                 
Ĵ
 Uso       FINA150                                                    
ٱ


/*/
Function FA150PIX(aBanSel, aTitSel)
	Local nI         := 0
	Local nTamArq    := 0
	Local lHeader    := .F.
	Local lFirst     := .F.
	Local lFirst2    := .F.
	LOCAL nTam       := 0
	Local nDec       := 0 
	Local nUltDisco  := 0
	Local nGrava     := 0
	Local lFinCnab2  := ExistBlock("FINCNAB2")
	Local nRegEmp    := SM0->(RecNo())
	Local cFilDe     := ""
	Local cFilAte    := ""
	Local lIdCnab    := .T.
	Local cArqGerado := ""
	Local lAtuDsk    := .F.
	Local lFimLin	 := .T.
	Local lTrailler  := .F.
	Local nStatBkp   := 0
	Local cFilFwSE1  := FwFilial("SE1")
	Local lHeadMod2  := .F.
	Local bWhile 	 := {||.T.}
	Local nVlrPix	 := 0
	Local nTxMoeda 	 := 0
	Local cMVFINPIX4 := SuperGetMV("MV_FINPIX4", .F., 'SSS')
	Local lMVCNABIMP := SuperGetMV("MV_CNABIMP", .F., .F.)
	Local lConsACDC  := Substr(cMVFINPIX4, 1, 1) == "S"
	Local lConsVA 	 := Substr(cMVFINPIX4, 2, 1) == "S"
	Local lConsImp 	 := Substr(cMVFINPIX4, 3, 1) == "S"
	Local nTitulos   := 0
	Local cMensagem  := STR0038 
	Local cTituloMsg := STR0042
	Local cTitulos   := ""
	Local lHaTitulo  := .F.
	Local nBaseImpos := 0	
	Local nVASoma    := 0
	Local nVASubtra  := 0
	Local lImposCalc := .T.
	Local cSituaCob  := ""
	Local nRecnoSE1  := 0
	Local nAbatImpos := 0
	Local nOutrosAba := 0
	
	Private cBanco
	Private cAgencia
	Private xConteudo
	Private nHdlBco    	:= 0
	Private nHdlSaida  	:= 0
	Private nSeq       	:= 0
	Private nSomaValor	:= 0
	Private nSomaVlLote	:= 0
	Private nQtdTotTit	:= 0
	Private nQtdTitLote	:= 0
	Private nSomaAcres	:= 0
	Private nSomaDecre	:= 0
	Private nBorderos	:= 0
	Private xBuffer		:= ""
	Private nLidos		:= 0
	Private nTotCnab2	:= 0 // Contador de Lay-out nao deletar
	Private nLotCnab2	:= 1 // Contador de Lotes do arquivo
	Private nLinha		:= 0 // Contador de Linhas nao deletar
	Private nQtdLinLote	:= 0 // Contador de linhas do detalhe do lote
	Private nTotLinArq	:= 0 // Contador de linhas do CNAB
	Private aFlagCTB   As Array
	Private cLote      As String
	Private cArquivo   As String
	Private nTotal     As Numeric
	Private nHdlPrv    As Numeric
	Private lCabec     As Logical
	Private lCtbPixOn  As Logical
	Private lMostraCtb As Logical
	Private lAglutCtb  As Logical
	Private lCancPix   As Logical

	Default aBanSel := {}
	Default aTitSel := {}
	
	ProcRegua(SE1->(RecCount()))
	Pergunte("FINA890",.F.)
	lMostraCtb := MV_PAR01 == 1
	lCtbPixOn  := MV_PAR02 == 1
	lAglutCtb  := MV_PAR03 == 1
	aFlagCTB   := {}	
	
	Pergunte("AFI150",.F. )
	MV_PAR01    := ""
	MV_PAR02    := ""
	MV_PAR03    := aBanSel[6]
	MV_PAR04    := aBanSel[7]
	MV_PAR05    := aBanSel[1]
	MV_PAR06    := aBanSel[2]
	MV_PAR07    := aBanSel[3]
	MV_PAR08    := aBanSel[5]
	MV_PAR09 	:= 1
	MV_PAR10    := 2
	MV_PAR11    := ""
	MV_PAR12    := ""
	MV_PAR13	:= 3
	MV_PAR14	:= 2
	
	cBanco  := mv_par05
	cAgencia:= mv_par06
	cConta  := mv_par07
	cSubCta := mv_par08
	cChvPix := AllTrim(aBanSel[4])
	lCabec   := .F.
	nTotal   := 0
	cArquivo := ""
	
	DbSelectArea("F70")
	F70->(DbSetOrder(2))
	F70->(DbSeek(FWxFilial("F70")+cChvPix))
	
	DbSelectArea("SA6")
	If !SA6->(DbSeek(xFilial("SA6")+cBanco+cAgencia+cConta))
		Help(" ",1,"FA150BCO")
		ProcLogAtu("ERRO","FA150BCO",Ap5GetHelp("FA150BCO"))
		Return .F.
	ElseIf Max(SA6->A6_MOEDA,1) > 1
		Help( "  ", 1, "MOEDACNAB" )
		ProcLogAtu("ERRO","FA150BCO",Ap5GetHelp("FA150BCO"))
		Return .F.
	Endif
	
	dbSelectArea("SEE")
	SEE->(DbSetOrder(1))
	
	If !SEE->(DbSeek(xFilial("SEE")+cBanco+cAgencia+cConta+cSubCta))
		Help(" ",1,"PAR150")
		ProcLogAtu("ERRO","PAR150",Ap5GetHelp("PAR150"))
		Return .F.
	ElseIf !Empty(SEE->EE_FAXFIM) .And. !Empty(SEE->EE_FAXATU) .And. Val(SEE->EE_FAXFIM) - Val(SEE->EE_FAXATU) < 100
		Help(" ", 1, "FAIXA150")
		ProcLogAtu("ERRO", "FAIXA150", Ap5GetHelp("FAIXA150"))
	Endif
	
	/*Verifica se ser gerado uma linha no final do arquivo.
	Se nao existir o campo que determina se deve ou nao saltar
	a linha na gravacao do trailler do arquivo, ou se existir e
	estiver como "1-Sim", Grava o final de linha (Chr(13)+Chr(10))*/
	lFimLin   := SEE->EE_FIMLIN == "1"
	cFilDe    := cFilAnt
	cFilAte   := cFilAnt
	nTotCnab2 := 0
	nSeq      := 0
	
	DbSelectArea("SM0")
	SM0->(DbSetOrder(1))
	SM0->(MsSeek(cEmpAnt + cFilDe, .T.))
	bWhile := {|| Left(SM0->M0_CODFIL, FWSizeFilial()) <= cFilAte}
	
	__lIsBlind  := IIf(__lIsBlind == Nil, IsBlind(), __lIsBlind)
	__lPIXImp   := IIf(__lPIXImp == Nil, FindFunction("PIXGerImp"), __lPIXImp)
	__lFinPix   := IIf(__lFinPix == Nil, ExistBlock("FINVLPIX"), __lFinPix)
	__lBaImpPix := IIf(__lBaImpPix == Nil, FindFunction("BaseImpPix"), __lBaImpPix)	
	__lBordImp  := IIf(__lBordImp == Nil, FindFunction("BorderoImp"), __lBordImp)	
	__lSitCPix  := IIf(__lSitCPix == Nil, FindFunction("F022SITPIX"), __lSitCPix)
	__nCasasDc  := IIf(__nCasasDc == Nil, TamSX3("FK1_TXMOED")[2], __nCasasDc)
	
	DbSelectArea("SA1")
	DbSelectArea("SE9")
	DbSelectArea("F71")
	F71->(DbSetOrder(3))
	
	BEGIN TRANSACTION
		nTitulos := Len(aTitSel) 
		
		While SM0->(!Eof()) .And. SM0->M0_CODIGO == cEmpAnt .And. Eval(bWhile)
			cFilAnt := FWGETCODFILIAL
			
			//Inicia a leitura do arquivo de Titulos
			For nI := 1 To nTitulos
				lCancPix   := aTitSel[nI,14] == 'C'
				cChaveF71  := aTitSel[nI,9]
				nVASoma    := 0
				nVASubtra  := 0
				nAbatImpos := 0
				nOutrosAba := 0
				nBaseImpos := 0
				lImposCalc := .T.
				
				F71->(dbSetOrder(3))
				If !F71->(MsSeek(cChaveF71))
					Loop
				EndIf
				
				DbSelectArea("SE1")
				SE1->(dbSetOrder(1))
				
				If !SE1->(MsSeek(FWxFilial("SE1")+aTitSel[nI,2]+aTitSel[nI,3]+aTitSel[nI,4]+aTitSel[nI,5]))
					Loop
				EndIf
				
				If SE1->E1_TIPO $ MVRECANT+"|"+MVPROVIS
					Loop
				EndIF
				
				If !lCancPix .And. SE1->E1_SALDO == 0
					Loop
				EndIf
				
				SE9->(DbSetOrder(1))
				SA1->(DbSetOrder(1))
				SE9->(MsSeek(xFilial("SE9")+SE1->(E1_CONTRAT+aBanSel[1]+aBanSel[2])))
				SA1->(MsSeek(xFilial("SA1", SE1->E1_FILORIG)+F71->F71_CODCLI+F71->F71_LOJCLI))
				
				If !lHeadMod2
					lHeadMod2 := AbrePar(@cArqGerado, .T.)
					
					If !lHeadMod2
						Exit	
					Endif
				Endif
				
				If !lCancPix
					nTxMoeda  := SE1->E1_TXMOEDA
					nRecnoSE1 := SE1->(Recno()) 
					
					If __lBordImp .And. !lMVCNABIMP
						lImposCalc := BorderoImp(SE1->E1_FILORIG, SE1->E1_NUMBOR, "R", SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA)
					EndIf					
					
					If SE1->E1_MOEDA > 1 .And. (Empty(nTxMoeda) .Or. !Empty(SE1->E1_DTVARIA))
						nTxMoeda := RecMoeda(Iif(Empty(SE1->E1_DTVARIA), dDataBase, SE1->E1_DTVARIA), SE1->E1_MOEDA)
					EndIf
					
					If __lBaImpPix
						nBaseImpos := BaseImpPix(nRecnoSE1, @nVASoma, @nVASubtra, @nAbatImpos, nTxMoeda, @nOutrosAba)
					EndIf
					
					If __lPIXImp .And. !lImposCalc
						If !PIXGerImp(nBaseImpos, nTxMoeda)
							Loop
						EndIf
					EndIf					
					
					If __lFinPix
						nVlrPix := ExecBlock("FINVLPIX")
					Else
						nVlrPix := SE1->E1_SALDO
						
						If lConsACDC .And. SE1->(E1_SDACRES+E1_SDDECRE) > 0
							nVlrPix += (SE1->E1_SDACRES - SE1->E1_SDDECRE)
						EndIf
						
						If lConsVA .And. ((nVASoma > 0) .Or. (nVASubtra != 0 ))							
							nVlrPix   += Round((nVASoma - Abs(nVASubtra)), 2)
						EndIf
						
						If lConsImp .And. (nAbatImpos+nOutrosAba) > 0
							If SE1->E1_MOEDA > 1
								If nAbatImpos > 0
									nAbatImpos := xMoeda(nAbatImpos, 1, SE1->E1_MOEDA, dDataBase, __nCasasDc, 0, nTxMoeda)
								EndIf
								
								If nOutrosAba > 0
									nOutrosAba := xMoeda(nOutrosAba, 1, SE1->E1_MOEDA, dDataBase, __nCasasDc, 0, nTxMoeda)
								EndIf
							EndIf
							
							nVlrPix -= (Round(nAbatImpos, 2) + Round(nOutrosAba, 2))
						EndIf					
					EndIf
					
					If nVlrPix < (nVASoma + SE1->E1_SDACRES)
						If !Empty(cTitulos) 
							cTitulos += CRLF
						EndIf
						
						cTitulos += SE1->E1_PREFIXO+"-"+SE1->E1_NUM+"-"+SE1->E1_PARCELA+"-"+SE1->E1_TIPO
						Loop
					EndIf
					
					If nVlrPix > 0
						Reclock("F71")
						F71->F71_VLRPIX := nVlrPix      
						F71->(MsUnlock())
					EndIf
				EndIf
				
				nQtdTitLote ++
				nQtdTotTit  ++
				nSomaValor	+= F71->F71_VLRPIX
				nSomaVlLote += F71->F71_VLRPIX
				nSomaAcres  += SE1->E1_SDACRES
				nSomaDecre  += SE1->E1_SDDECRE			
				lHaTitulo   := .T.
				
				//Le Arquivo de Parametrizacao
				nLidos := 0
				FSEEK(nHdlBco, 0, 0)
				nTamArq := FSEEK(nHdlBco, 0, 2)
				FSEEK(nHdlBco, 0, 0)
				lIdCnab := .T.
				
				While nLidos <= nTamArq
					xBuffer := Space(85)
					FREAD(nHdlBco, @xBuffer, 85)
					
					Do Case
						Case SubStr(xBuffer,1,1) == CHR(1)
							IF lHeader
								nLidos += 85
								Loop
							EndIF
						Case SubStr(xBuffer,1,1) == CHR(2)
							lFirst2 := .F. //Controle do detalhe tipo 5
							IF !lFirst
								lFirst := .T.
								nSeq++
								FWRITE(nHdlSaida,CHR(13)+CHR(10))
							EndIF
						Case SubStr(xBuffer,1,1) == CHR(4)
							IF !lFirst2
								nSeq++
								lFirst2 := .T.
								FWRITE(nHdlSaida,CHR(13)+CHR(10))
							Endif
						Case SubStr(xBuffer,1,1) == CHR(3)
							nLidos+=85
							Loop
						Otherwise
							nLidos+=85
							Loop
					EndCase
					
					nTam      := 1+(Val(SubStr(xBuffer,20,3))-Val(SubStr(xBuffer,17,3)))
					nDec      := Val(SubStr(xBuffer,23,1))
					cConteudo := SubStr(xBuffer,24,60)
					nGrava    := fA150GrPIX(nTam, nDec, cConteudo, Nil, lFinCnab2, @lIdCnab)
					
					If nGrava != 1
						nSeq--
						Exit
					Endif
					
					nLidos += 85
				EndDO
				
				If nGrava == 3
					Exit
				Endif
				
				If nGrava == 1
					lAtuDsk := .T.
					
					If MV_PAR09 == 1
						lIdCnab := .T.	// Para obter novo identificador do registro CNAB na rotina 
						
						fWrite(nHdlSaida,CHR(13)+CHR(10))
						
						IF !lHeader
							lHeader := .T.
						EndIF
					Endif
					
					F71->(DbSetOrder(3))
					If F71->(MsSeek(cChaveF71))
						Reclock("F71",.F.)
						F71->F71_CODBAN := aBanSel[1]
						F71->F71_AGENCI := aBanSel[2]
						F71->F71_NUMCON := aBanSel[3]
						F71->F71_FILBCO := aBanSel[8]  
						F71->F71_TPCHV  := aBanSel[9]  
						F71->F71_CHVPIX := aBanSel[4]
						
						If aTitSel[nI,13] == "1"
							F71->F71_STATUS := "6"
						Else
							F71->F71_STATUS := "2"
						Endif
						
						F71->F71_DTPSP  := ddatabase
						F71->F71_HRPSP  := TIME()            
						F71->(MsUnlock())
					Endif
					
					//Atualiza para Carteira PIX
                    SE1->(DbGoto(nRecnoSE1))
                    
					If SE1->E1_SITUACA == "0" 
						cSituaCob := IIf(__lSitCPix, F022SITPIX(), "")
						cSituaCob := IIf(Empty(cSituaCob), SE1->E1_SITUACA, cSituaCob)					
						
						Reclock("SE1", .F.)
						SE1->E1_SITUACA := cSituaCob
						SE1->(MsUnlock())
					EndIf
					
					If nI < nTitulos
						nSeq++
					EndIf
					
					//Contabilizao PIX
					F150CtbPix()
				ElseIf nGrava == 3
					Exit
				Endif
			Next
			
			If Empty(cFilFwSE1 )
				Exit
			Endif
			
			dbSelectArea("SM0")
			SM0->(DbSkip())
		EndDO
		
		SM0->(dbgoto(nRegEmp))
		cFilAnt := FWGETCODFILIAL
		
		If lHaTitulo .And. lHeadMod2 //Se h ttulos e conseguiu criar o Header do arquivo, entao cria o Trailler
			If nTotal > 0 //Contabilizao
				F150CtbInc(cArquivo, @nHdlPrv, cLote, nTotal, Nil, Nil)
			Endif			
			
			If mv_par09 == 1
				//Monta Registro Trailler
				nSeq   ++
				nLidos := 0
				FSEEK(nHdlBco, 0, 0)
				nTamArq := FSEEK(nHdlBco, 0, 2)
				FSEEK(nHdlBco, 0, 0)
				
				While nLidos <= nTamArq
					xBuffer := Space(85)
					FREAD(nHdlBco, @xBuffer, 85)
					
					If SubStr(xBuffer,1,1) == CHR(3)
						lTrailler := .T.
						nTam      := 1+(Val(SubStr(xBuffer,20,3))-Val(SubStr(xBuffer,17,3)))
						nDec      := Val(SubStr(xBuffer,23,1))
						cConteudo := SubStr(xBuffer,24,60)
						nGrava    := fA150GrPIX(nTam, nDec, cConteudo, .T., lFinCnab2, .F.)
					Endif
					
					nLidos+=85
				EndDo
				
				If lTrailler .And. lFimLin
					FWRITE(nHdlSaida, CHR(13)+CHR(10))
				Endif
			Else
				nTotLinArq += nQtdLinLote //Total das linhas do arquivo.
				RodaCnab2(nHdlSaida, MV_PAR03, lFimLin)
			EndIf
			
			//Atualiza Numero do ultimo Disco
			DbSelectArea("SEE")
			IF SEE->(!Eof()) .And. nGrava != 3 .and. lAtuDsk
				Reclock("SEE")
				nUltDisco := (VAL(EE_ULTDSK) + 1)
				SEE->EE_ULTDSK := StrZero(nUltDisco, TamSx3("EE_ULTDSK")[1])
				SEE->(MsUnlock())
			EndIF
			
			//Fecha o arquivos utilizados
			FCLOSE(nHdlBco)
			FCLOSE(nHdlSaida)

			If nGrava == 3 // Abandonou a rotina, quando o bordero ja foi enviado.
				// Apaga o arquivo de saida, para nao caracterizar um erro no programa a geracao incompleta do arquivo quando o usuario cancelar.
				If FErase(cArqGerado) = 0
					If !Empty(cArqBkp)
						nStatBkp := FRenameEx( cArqBkp , cNomeSai  )
						If nStatBkp <> 0
							Help(" ",1,"F150ERRREST",,Str(fError(),4),1,0)
						EndIf
					EndIf
				EndIf
				ProcLogAtu("ERRO","",STR0019) //"Processo Cancelado por usurio. Arquivo no gerado"
			Else
				ProcLogAtu("ALERTA","",STR0020+cArqGerado) //"Processo Finalizado. Arquivo gerado: "
			Endif
		Endif
	END TRANSACTION 
	
	If lHaTitulo .And. nGrava == 1
		cMensagem  := STR0036 + cArqGerado + STR0037
		cTituloMsg := STR0043 
	EndIf
	
	If !Empty(cTitulos)
		Help(Nil, Nil, "VLRENVIO", Nil, STR0039 + CRLF + cTitulos + CRLF + STR0040, 2, 0, Nil, Nil, Nil, Nil, Nil, {STR0041})
		
		If !lHaTitulo
			If !Empty(nHdlBco)
				FClose(nHdlBco)
			EndIf
			
			If !Empty(nHdlSaida)
				FClose(nHdlSaida)
			EndIf
		EndIf	
	EndIf
	
	If !__lIsBlind
		MsgAlert(cMensagem, cTituloMsg)
	EndIf
Return .T.

/*/


Ŀ
Funo    fA150GrPIX Autor  Wagner Xavier          Data  26/05/92 
Ĵ
Descrio Rotina de Geracao do Arquivo de Remessa de Comunicacao      
          Bancaria                                                    
Ĵ
Sintaxe   ExpL1:=fa150Grava(ExpN1,ExpN2,ExpC1)                        
Ĵ
 Uso       FINA150                                                    
ٱ


/*/
STATIC Function fA150GrPIX( nTam,nDec,cConteudo,lTrailler,lFinCnab2,lIdCnab)
	Local nRetorno := 1
	Local aGetArea := GetArea()
	Local lPanelFin := IsPanelFin()
	
	//Para imprimir o trailler caso se deseje abandonar a gerao do arquivo de envio pela metade
	lTrailler := Iif(lTrailler == Nil, .F., lTrailler)
	lFinCnab2 := Iif(lFinCnab2 == Nil, .F., lFinCnab2)
	
	//O retorno poder ser: 1->Grava Ok, 2->Ignora bordero, 3->Abandona rotina
	//Verifica se titulo ja' foi enviado
	If nRetorno == 1 .Or. (lTrailler .And. nBorderos > 0)
		If !lTrailler .and. lIdCnab			
			lIdCnab := .F. // Gera o identificacao do registro CNAB apenas uma vez no titulo enviado
		Endif
		
		//Analisa conteudo
		IF Empty(cConteudo)
			cCampo := Space(nTam)
		Else
			lConteudo := fa150Orig( cConteudo )
			
			If !lConteudo
				RestArea(aGetArea)
				Return nRetorno
			Else
				If ValType(xConteudo) == "D"
					cCampo := GravaData(xConteudo,.F.)
				ElseIf ValType(xConteudo) == "N"
					cCampo := Substr(Strzero(xConteudo, nTam, nDec), 1, nTam)
				Else
					cCampo := Substr(xConteudo, 1, nTam)
				EndIf
			EndIf
		EndIf
		
		If Len(cCampo) < nTam  //Preenche campo a ser gravado, caso menor
			cCampo := cCampo + Space(nTam - Len(cCampo))
		EndIf
		
		Fwrite( nHdlSaida,cCampo,nTam )
	EndIf
	
	RestArea(aGetArea)
	
	If lPanelFin
		cAlias := FinWindow:cAliasFile
		dbSelectarea(cAlias)
		FinVisual(cAlias,FinWindow,(cAlias)->(Recno()),.T.)
	Endif
Return nRetorno

/*/{Protheus.doc} F150CtbPix()
Efetua a contabilizao dos ttulos gerados para PIX
Necessrio ter a SE1 e F71 posicionados

@version    12.1.23/12.1.25/12.1.27
@author     Edson Melo
@return     lRet, Logical, .T. Cancela reteno do ttulo, .F. No cancela reteno do ttulo por estar em PIX
@since      13/11/2020
/*/
Function F150CtbPix()
	Local cPadrao   As String
	Local lPadrao   As Logical
	Local cCartAtu  As String
	Local cCartAnt  As String
	Local cBancoAnt As String
	Local cAgencAnt As String
	Local cContaAnt As String
	
	If !lCancPix
		cPadrao  := "54G" //Carteira para PIX
	Else
		cPadrao  := "54H" //PIX para Carteira
	EndIf
	
	lPadrao  := VerPadrao(cPadrao)
	
	If !lCancPix
		cCartAtu  := "K"
		cCartAnt  := SE1->E1_SITUACA
		cBancoAnt := SE1->E1_PORTADOI
		cAgencAnt := SE1->E1_AGEDEP
		cContaAnt := SE1->E1_CONTA
	Else
		//Verifica se o ttulo est em border
		cCartAtu  := SE1->E1_SITUACA
		cCartAnt  := "K"
		cBancoAnt := F71->F71_CODBAN
		cAgencAnt := F71->F71_AGENCI
		cContaAnt := F71->F71_NUMCON
	EndIf
	
	//[01] = FWI_LA ('S' ou 'N')
	//[02] = FWI_LANPAD (Lanamento Padro utilizado)
	//[03] = FWI_VALOR (Valor da Movimentao)
	//[04] = FWI_DESCON (Desconto da Movimentao)
	//[05] = FWI_IOF (Valor do IOF)
	//[06] = FWI_SITUAC (Carteira Atual)
	//[07] = FWI_SITANT (Carteira Anterior)
	//[08] = FWI_BCOANT (Portador Anterior)
	//[09] = FWI_AGEANT (Agncia Anterior)
	//[10] = FWI_CONANT (Nmero da Conta Anterior)
	//[11] = FWI_CONTRA (Contrato)
	//[12] = FWI_IDMOV (Id da Movimentao na FK5)
	//[13] = FWI_NUMBOR (Nmero do Border)
	
	FinAGrvFWI({"N", cPadrao, F71->F71_VLRPIX, 0, 0, cCartAtu, cCartAnt, cBancoAnt, cAgencAnt, cContaAnt, "", "", ""}, {.T.,lCancPix})
	
	aAdd(aFlagCTB, {"FWI_LA", "S", "FWI", FWI->(Recno()), 0, 0, 0})
	
	If lPadrao .and. lCtbPixOn
		If !lCabec
			cLote   := LoteCont("FIN")
			nHdlPrv := HeadProva(cLote, "FINA150", __cUserId, @cArquivo )
			lCabec := .T.
		EndIf
		
		If lCabec		
			nTotal += DetProva(nHdlPrv, cPadrao, "FINA150" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/,;
							/*lRateio*/, /*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, /*@aFlagCTB*/, /*aTabRecOri*/, /*aDadosProva*/)
		EndIf
	EndIf
Return

/*/{Protheus.doc} F150CtbInc()
Efetua a contabilizao dos ttulos gerados para PIX

@version    12.1.23/12.1.25/12.1.27
@author     Edson Melo
@return     lRet, Logical, .T. Cancela reteno do ttulo, .F. No cancela reteno do ttulo por estar em PIX
@since      13/11/2020
/*/

Static Function F150CtbInc(cArquivo,nHdlPrv,cLoteATF,nTotal,aDadosProva,aDiario)

Default aDadosProva := nil
Default aDiario	    := {}

//Ŀ
// Grava Rodap 									  	
//
If nHdlPrv > 0
	RodaProva( nHdlPrv , nTotal, aDadosProva )

	//Ŀ
	// Envia para Lanamento Contbil 						
	//

	cA100Incl( cArquivo, nHdlPrv, 3, cLoteATF, lMostraCtb, lAglutCtb,,,, @aFlagCTB, aDadosProva,aDiario )
	INCLUI := .F. //No tirar - Impede a abertura do wizard FINA891 aps o processamento do FA150PIX

	aFlagCTB := {}  
	aDiario  := {}
	nHdlPrv := 0
Endif

Return Nil

//----------------------------------------
/*/{Protheus.doc} UltimaRem
	Grava e retorna a ltima sequncia do
	arquivo de remessa gerado pelo modelo
	Pix.
	
	@author Sivaldo Oliveira
	@since 16/08/2021
	@version P12
	
	Return cUltimaRem, Char, ltima sequncia 
	de remessa gerada.
	/*/
//----------------------------------------
Function UltimaRem() As Char
	Local lTemCampo  As Logical
	Local cUltimaRem As Char	
	Local nUltimaRem As Numeric
	Local nTamCampo  As Numeric
	Local aAreaAtual As Array
	
	//Inicializa variveis.
	aAreaAtual := GetArea()
	lTemCampo  := SA6->(FieldPos("A6_ULTREM")) > 0 
	cUltimaRem := ""	
	nUltimaRem := 1
	nTamCampo  := 10
	
	If lTemCampo
		DbSelectArea("SA6")
		SA6->(DbSetOrder(1))
		nTamCampo  := TamSx3("A6_ULTREM")[1]
		nUltimaRem := (1 + Val(SA6->A6_ULTREM))
		cUltimaRem := StrZero(nUltimaRem, nTamCampo)
		
		If !Empty(SA6->A6_COD)
			RecLock("SA6")
			SA6->A6_ULTREM := cUltimaRem 
			SA6->(MsUnlock())
		EndIf
	Else
		cUltimaRem := StrZero(nUltimaRem, nTamCampo) 	
	EndIf
	
	RestArea(aAreaAtual)
	FwFreeArray(aAreaAtual)
Return cUltimaRem

//----------------------------------------
/*/{Protheus.doc} TotalVA
	Retorna o total de valores acessrios do 
	do ttulo.
	
	@author Sivaldo Oliveira
	@since 26/08/2021
	@version P12
	
	@Param cOperador, Char, indica qual totalizador
	do valor acessrio ser considerado.
	
	@Param cCarteira, Char, Indica qual a carteira do
	ttulo(P = Pagar, R = Receber).
	
	Return nTotalVa, Numeric, Total do(s) valor(es) acessrio(s). 
	/*/
//----------------------------------------
Function TotalVA(cOperador As Char, cCarteira As Char) As Numeic
	Local nTotalVa   As Numeric
	Local Quantidade As Numeric
	Local nContador  As Numeric	
	Local aValores   As Array
	
	//Parmetros padres da rotina
	Default cOperador := ""
	Default cCarteira := ""
	
	//Inicializa variveis	
	nTotalVa   := 0
	Quantidade := 0
	nContador  := 0
	aValores   := {}
	cCarteira  := AllTrim(cCarteira)
	
	If cCarteira $ "R|P"
		cOperador := AllTrim(cOperador)
		
		If cCarteira == "R"
			nTotalVa := FValAcess(SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_NATUREZ,; 
			.F., "", "R", dDataBase, aValores, SE1->E1_MOEDA, SE1->E1_MOEDA, 0, "", .F.)
		Else
			nTotalVa := FValAcess(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ,;
			.F., "", "P", dDataBase, aValores, SE2->E2_MOEDA, SE2->E2_MOEDA, 0, "", .F.)
		EndIf
		
		If (Quantidade := Len(aValores)) > 0
			If Type("nSomaValor") != "N"
				nSomaValor := 0
			EndIf
			
			If Type("nSomaVlLote") != "N"
				nSomaVlLote := 0
			EndIf			
			
			If cOperador $ "-|+"
				nTotalVa := 0
				
				For nContador := 1 To Quantidade
					If (cOperador == "+" .And. aValores[nContador,3] <= 0) .Or. (cOperador == "-" .And. aValores[nContador,3] > 0)
						Loop
					EndIf
					
					nTotalVa += aValores[nContador,3]
				Next
			EndIf
			
			nSomaValor  += nTotalVa
			nSomaVlLote += nTotalVa
			FwFreeArray(aValores)		
		EndIf
	EndIf
Return nTotalVa
