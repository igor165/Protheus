#INCLUDE "PROTHEUS.CH"
#INCLUDE "FILEIO.CH"
#INCLUDE "FINA090.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "SIGAWIN.CH"

STATIC __lFa090Bco	:= NIL
STATIC __lF090DESC	:= NIL
STATIC __dLastPcc	:= NIL
STATIC __oPrepared 	:= NIL
STATIC __lIntSJURI 	:= NIL
STATIC __lExistLGA 	:= NIL
STATIC __lF090TIT	:= NIL
STATIC __lSOLNCP 	:= NIL
STATIC __lCtLIPag 	:= NIL
STATIC __lFinVDoc	:= NIL
STATIC __lUsaPCO	:= NIL
STATIC __nTamHist	:= NIL
STATIC __oFIN0901	:= NIL
STATIC __oFIN0902	:= NIL
STATIC __cLstImp	:= NIL
STATIC __nIdxE2OK	:= 2
STATIC __lF90PSTIT  := NIL
STATIC __lFKDBx		:= NIL
STATIC __lF090QFIL  := NIL
STATIC __lF090FIL	:= NIL
STATIC __F090VLEX	:= NIL
STATIC __lFK7Cpos	:= NIL
//--- Tratamento Gestao Corporativa
STATIC __cLayout  	:= NIL
STATIC __lGestao	:= NIL
STATIC __cFilSE2	:= NIL
STATIC __cFilSEF	:= NIL
STATIC __cFilSA6	:= NIL
STATIC __cFilSEK	:= NIL
STATIC __cFilSED	:= NIL
STATIC __cFilSFQ	:= NIL
STATIC __cFilSA2	:= NIL
//Motor de Retencoes
STATIC __aImpMR		:= {}
STATIC __lPccMR 	:= .F.
STATIC __lIrfMR 	:= .F.
STATIC __lInsMR 	:= .F.
STATIC __lIssMR 	:= .F.
STATIC __lCidMR 	:= .F.
STATIC __lSesMR 	:= .F.
STATIC __nPisMR 	:= 0
STATIC __nCofMR 	:= 0
STATIC __nCslMR 	:= 0
STATIC __nIrfMR 	:= 0
STATIC __nInsMR 	:= 0
STATIC __nIssMR 	:= 0
STATIC __nCidMR 	:= 0
STATIC __nSesMR 	:= 0
STATIC __nImpMR 	:= 0
STATIC __lPccBxMR	:= .F.
STATIC __lTemMR		:= NIL
STATIC __nBasLeg	:= 0
STATIC __nTamMD2	:= NIL
STATIC __lJFilBco	:= NIL
STATIC __lF090ADDB	:= NIL
STATIC __lF090BROW	:= NIL
STATIC __lFINA095	:= NIL
STATIC __cPerg		:= "FIN090A"
STATIC __aTab23		:= NIL
STATIC __cMVCARTEIR	:= NIL
STATIC __cMVBXDTFIN := NIL
STATIC __nMVMCUSTO	:= NIL
STATIC __lMVBXAUTVE := NIL
STATIC __cModRetPIS := NIL
STATIC __oTemINA	:= NIL
STATIC __lF090ADFR	:= NIL
STATIC __lF090PABX	:= NIL
Static __oRatIRF 	:= Nil		// Rateio IR Progressivo
STATIC __lF090FLBR	:= NIL
STATIC __lF090BFIL	:= NIL

//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} function FinA090
Baixa Automática de Titulos a Pagar 

@Param nPosArotina	, Numeric, Posição a aRotina que deseja ser executada
@Param aTitulos		, Array  , array utilizado para rotina automatizada

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function FinA090(nPosArotina,aTitulos)

	Local bBlock
	Local oObj 		 := FWSX1Util():New()
	Local aPergunte	 := {}
	Local cFilCxCtr  := F090IsCaixa(.T.)
	Local lMvCheques := Type('MVCHEQUES')=='C'
	Local cMvCheques := F90FORMATIN( IIF(lMvCheques,MVCHEQUES,MVCHEQUE) )
	Local cStrTipos	 := F90FORMATIN( MVPROVIS+"/"+MVRECANT+"/"+MV_CRNEG+"/"+MVENVBCOR )
	Local cFilLogada := cFilAnt  // Salva a Filial corrente, porque na chamada da função "fA091Aut" o sistema perde a filial.
	Local lBlind     := IsBlind()

	Private aIndices	:= {} //Array necessario para a funcao FilBrowse
	Private bFilBrw		:= {|| }
	Private cFilter		:=	Nil
	Private aRotina		:= MenuDef()
	Private nIndTemp	:= 1
	Private dDataLanc	:= dDataBase
	Private cBordero	:= CriaVar("E2_NUMBOR")
	Private cBcoDe		:= CriaVar("E2_PORTADO")
	Private cBcoAte		:= CriaVar("E2_PORTADO")
	Private cPortado	:= CriaVar("E2_PORTADO")
	Private dVencIni	:= dDataBase
	Private dVencFim	:= dDataBase
	Private dBaixa		:= dDataBase
	Private dDebito		:= dDataBase
	Private nJuros		:= 0
	Private nVA			:= 0	// VALORES ACESSORIOS
	Private nCorrec		:= 0
	Private cCtBaixa	:= GetMv("MV_CTBAIXA")
	Private cMarca		:= GetMark()
	Private cKey1		:= ""
	Private cIndexNew	:= ""
	Private nAcresc		:= 0
	Private nDecresc	:= 0
	Private cNatMov		:= ''
	Private cCadastro	:= STR0003 // "Baixa de Titulos"
	Private cCodDiario	:= ""
	Private cMoedBco	:= CriaVar( "E2_MOEDA" )
	Private cLote
		
	LoteCont( "FIN" )

	DEFAULT nPosArotina := 0
	DEFAULT aTitulos 	:= {}
	DEFAULT __lF090ADDB := ExistBlock("F090ADDB")
	DEFAULT __lF090FLBR := ExistBlock("F090FLBR")
	DEFAULT __lF090BFIL := ExistBlock("F090FILB")
	DEFAULT __lF090BROW := ExistBlock("F090BROW")
	DEFAULT __lCtLIPag 	:= GetMv("MV_CTLIPAG")

	NUMCHEQUE 	:= ""		//para contabilizar o numero do cheque

	//Ponto de entrada para adicionar rotinas e botoes na aRotina
	If __lF090ADDB
		aRotina := ExecBlock( "F090ADDB",.F.,.F.,{aRotina})
	EndIf

	//Verificação do processo que está configurado para ser utilizado no Módulo Financeiro (Argentina)
	If !FinModProc()
		Return()
	EndIf

	//Verificar se o novo grupo de perguntas existe	
	oObj:AddGroup("FIN090A")
	oObj:SearchGroup()
	If Len(aPergunte := oObj:GetGroup("FIN090A")[2]) == 0
		cText := STR0186 + CRLF + STR0187 + CRLF + CRLF //"Seu dicionário encontra-se desatualizado. "###"Com isso NÃO será possível a seleção de filiais para a baixa automática."
		cText += STR0188	//"Deseja continuar mesmo assim?"
		cTitle := STR0189 	//"Dicionário desatualizado."
		If !lBlind 
			If MsgYesNo(cText, cTitle)
				__cPerg := "FIN090"
			Else
				Return()
			Endif
		Else
			__cPerg := "FIN090"
		Endif
	Endif

	//--------------------------------------------------------------
	// Variaveis utilizadas para parametros
	// mv_par01	Mostra Lan‡ Contabil
	// mv_par02 Aglutina Lancamentos
	// mv_par03 Contabiliza On-Line
	// mv_par04 Gera Cheque automaticamente
	// mv_par05 Ctb Bordero - Total/Por Bordero
	// mv_par06 Tipo de Desconto - 1 Condicional, 2 Incondicional
	// mv_par07 Seleciona Filiais
	// mv_par08 Contabiliza na Filial logada
	//--------------------------------------------------------------
	//Carrega função Pergunte
	SetKey (VK_F12,{|a,b| AcessaPerg(__cPerg,.T.)})
	Pergunte(__cPerg,.F.)

	//Proteção para caso o parâmetro mv_par08 não exista na base
	IF Empty(mv_par08)
		mv_par08 := 2
	Endif
	
	//Caso não tenha o novo grupo de perguntas, seto Considera Filiais = Não
	If __cPerg == "FIN090"
		mv_par06 := If(cPaisloc != "BRA", 2,mv_par06)
		mv_par07 := 2
	Endif	

	lDigita	:= IIF(mv_par01==1,.T.,.F.)
	lAglut	:= IIF(mv_par02==1,.T.,.F.)

	//POR MAIS ESTRANHO QUE PAREÇA, ESTA FUNCAO DEVE SER CHAMADA AQUI!
	//A função SomaAbat reabre o SE2 com outro nome pela ChkFile para
	//efeito de performance. Se o alias auxiliar para a SumAbat() não
	//estiver aberto antes da IndRegua, ocorre Erro de & na ChkFile,
	//pois o Filtro do SE2 ultrapassa 255 Caracteres.
	SomaAbat("","","","P")

	If nPosArotina > 0 // Sera executada uma opcao diretamento de aRotina, sem passar pela mBrowse
		dbSelectArea("SE2")
		bBlock := &( "{ |a,b,c,d,e| " + aRotina[ nPosArotina,2 ] + "(a,b,c,d,e) }" )
		Eval( bBlock, Alias(), (Alias())->(Recno()),nPosArotina,,aTitulos)
	Else
		//Cria indice condicianal para a Localizacoes
		If cPaisLoc <> "BRA"
			cFiltro :=	"E2_TIPO IN "+ cMvCheques +" AND "
			cFiltro +=	"E2_TIPO NOT IN "+ cStrTipos +" "
			If cPaisLoc $ "PER|DOM|ARG"
				cFiltro += " AND E2_PORTADO NOT IN " + cFilCxCtr + " "
			Endif
			cFiltro:= StrTran(cFiltro,",''","")
			If __lF090FLBR
				cFiltro := ExecBlock( "F090FLBR",.F.,.F.,{cFiltro})
			EndIf

			cFilter := cFiltro
		Else
			If !__lCtLIPag
				dbSelectArea("SE2")
				dbSetOrder(3)
				dbSeek( xFilial("SE2") )
				cKey1 := INDEXKEY()
			Else
				dbSelectArea("SE2")
				dbSetOrder(3)  //"E2_FILIAL+DTOS(E2_VENCREA)+E2_NOMFOR+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO"
				cFilter := "E2_FILIAL = '"+xFilial("SE2")+"' AND (E2_DATALIB <> '        ' OR (E2_SALDO+E2_SDACRES-E2_SDDECRE) <= "+Alltrim(Str(GetMv('MV_VLMINPG'),15,7))+")"
				If __lF090BFIL
					cFilter := ExecBlock( "F090FILB",.F.,.F.,{cFilter})
				EndIf
			Endif
		Endif

		//Ponto de entrada para ser utilizado antes do Browse
		If __lF090BROW
			ExecBlock( "F090BROW",.F.,.F.)
		EndIf

		//Endereca a função de BROWSE
		mBrowse( 6, 1,22,75,"SE2",,,,,, Fa040Legenda("SE2"),,,,,,,,cFilter)
	Endif

	//Recupera a Integridade dos dados
	RetIndex("SE2")
	dbSetOrder(1)
	Set Filter to

	If nPosArotina = 0
		dbSeek(xFilial())
		If cPaisLoc != "BRA"
			EndFilBrw("SE2",@aIndices)
		EndIf
	Endif
	
	cFilAnt := cFilLogada

Return


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} function fA090Aut
Baixa Automática de Titulos a Pagar 

@author  Wagner Xavier
@since   26/05/1992
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function fA090Aut(cAlias,cCampo,nOpcE,aM,aTitulos)

	Local nOpca			:= 0
	Local nX 			:= 0
	Local nI 			:= 0
	Local nRec			:= 0	
	Local nTotAger  	:= 0
	Local nTipoBx 		:= 1
	Local nSalvRec		:= SE2->(Recno())
	Local nTotCpos		:= 0
	Local nTamaTit		:= 0
	Local nTimeOut  	:= SuperGetMv("MV_FATOUT",,900)*1000	// Estabelece 15 minutos para que o usuarios selecione
	Local nTimeMsg  	:= SuperGetMv("MV_MSGTIME",,120)*1000 	// Estabelece 02 minutos para exibir a mensagem para o usuário
																// informando que a tela fechará automaticamente em XX minutos
	Local lInverte		:= .F.
	Local lCheque		:= .F.
	Local lPadrao		:= .F.
	Local lRet 			:= .T.
	Local lTEMP			:= .F.
	Local lContinua     := .T.
	Local lGerTotal 	:= .F.  // Gera mov.bancário totalizador nas baixas de borderos
	Local lBaixa    	:= .T.
	Local lMovBcoBx 	:= .F.
	Local lF90TotGrv 	:= ExistBlock("F90TOTGRV") // PE para gravacoes complementares no registro totalizador da baixa
	Local lMultNat		:= .F.
	Local lF090Auto		:= .F.	// Controle de Chamada Automatizada
	Local lF090Fil		:= .F.
	Local lSpbInUse 	:= SpbInUse()
	Local lF090CPOS 	:= ExistBlock("F090CPOS")
	Local lPeAddBtn		:= ExistBlock("F090AdBtn")
	Local lF090MTBX		:= ExistBlock("F090MTBX")	// F090MTBX - Altera motivo de baixa autom.
	Local lF090GAVE 	:= ExistBlock("F090GAVE")	// F090GAVE - Manipula filtro para montagem de baixa automática
	Local lFA090POS 	:= ExistBlock("FA090POS")
	Local lF091FBX		:= ExistBlock("F091FBX")
	Local lF090NatLot	:= IF(ExistBlock("F090NATLOT"),ExecBlock("F090NATLOT",.f.,.f.),.F.)
	Local lAtuSldBco 	:= SuperGetMv("MV_ATUSLBC",.F.,.T.)
	Local lUsaFlag		:= SuperGetMV("MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
	Local lAutoARG		:= Iif (cPaisloc == "ARG", IsBlind(), .F.) //Variable para verificar que se esta llegando a la función desde script de automatización
	Local lPCCBaixa 	:= (cPaisLoc == "BRA") .And. (SuperGetMv("MV_BX10925",.T.,"2") == "1")		//Controla o Pis Cofins e Csll na baixa
	Local lPanelFin 	:= IsPanelFin()
	Local lBcoExcl		:= Alltrim(FWModeAccess("SA6",1)) == "E" .Or. Alltrim(FWModeAccess("SA6",2)) == "E" .Or. Alltrim(FWModeAccess("SA6",3)) == "E"
	Local lConfirma		:= .F.		

	Local cFilLogada 	:= cFilAnt  // Salva a Filial corrente, porque na chamada da função "fA091Aut" o sistema perde a filial.
	Local cFilCxCtr 	:= F090IsCaixa()
	Local cDescrMo		:= " "
	Local cLog			:= ""
	Local cCamposE5 	:= ""
	Local cFilBaixa     := cFilAnt
	Local cBancoF3      := "SA6"
	Local cBord090I 	:= CRIAVAR("EA_NUMBOR")
	Local cBord090F 	:= CRIAVAR("EA_NUMBOR")
	Local cCheq090		:= CRIAVAR("E5_NUMCHEQ")
	Local cBenef090		:= CRIAVAR("EF_BENEF")
	Local cNatur090		:= CRIAVAR("E2_NATUREZ")
	Local cHistor090	:= CRIAVAR("E5_HISTOR")
	Local cPadrao 		:= "530"

	Local aDescMotbx 	:= {}
	Local aMotBx		:= ReadMotBx()
	Local aCampos		:= {}
	Local aEstruct		:= {}
	Local aButtons		:= {}
	Local aSize 		:= {}
	Local aRetAdBtn		:= {}
	Local aVars			:= {}
	Local aVarsOld		:= {}
	Local aAreaSE2		:= SE2->(GetArea())

	Local aSelFil		:= {}
	Local aTMPFil		:= {}
	Local aFilAux		:= {}
	Local aVendor		:= {}

	Local oDlg			:= NIL
	Local oDlg1			:= NIL
	Local oQtda			:= NIL
	Local oCbx			:= NIL
	Local oRadio		:= NIL
	Local oBcoDe		:= NIL
	Local oBco090		:= NIL
	Local oTimer		:= NIL
	Local oValor		:= NIL
	Local oCheq090		:= NIL
	Local bOk1			:= NIL
	Local bOk2			:= NIL
	Local bOk3			:= NIL
	Local bOk4			:= NIL
	Local bActWhen		:= NIL
	Local bValNumChq	:= NIL
	Local bMovBanco		:= NIL
	Local oMultNat		:= NIL
	Local oModelMov		:= Nil 	//Model de Movimento bancario
	Local oSubFKAM		:= NIL	//TABELA DE RASTREIO - Model de Movimento bancario
	Local oSubFK5M		:= NIL	//MOVTO BANCARIO - Model Movimento Bancario
	Local oPanel		:= NIL
	Local dAtuDtBase	:= dDataBase // Backup para database

	Local oObj 			:= FWSX1Util():New()
	Local aPergunte	 	:= {}

	Private cAliasSE2 	:= GetNextAlias()
	Private oGetLote
	Private lVldAD		:= .F.
	Private cMotBx		:= CriaVar("E5_MOTBX")
	Private nMulta   	:= 0
	Private nDescont 	:= 0
	Private cLoteFin 	:= Space(TamSX3("E2_LOTE")[1])
	Private nPis 		:= 0
	Private nCofins   	:= 0
	Private nCsll		:= 0
	Private aDadosRef 	:= Array(7)
	Private aDadosRet 	:= Array(7)
	Private nVlRetPis	:= 0
	Private nVlRetCof	:= 0
	Private nVlRetCsl	:= 0
	Private nDiferImp	:= 0
	Private nValPgto	:= 0
	Private nOldValPgto := 0
	Private nTotAbat	:= 0
	Private nVlRetIrf	:= 0
	Private nIrrf		:= 0
	Private nValAcres	:= 0
	Private nIss 		:= 0
	Private nValor    	:= 0
	Private nValImp		:= 0
	Private lBxCnab 	:= IIf(GETMV("MV_BXCNAB")== "S",.T.,.F.)
	Private lHabCampos	:= .T.
	Private nBaseIrpf 	:= 0
	Private nBaseITF	:= 0
	//Baixa Automatizada
	Private nMoedaBco	:= 1
	Private aDadosIR 	:= Array(3)
	Private cBco090 	:= ""
	Private cAge090 	:= ""
	Private cCta090 	:= ""
    Private dDebito		:= dDataBase
	Private nInss		:= 0
	//Reestruturacao SE5
	Private nDescCalc 	:= 0
	Private nJurosCalc 	:= 0
	Private nVACalc		:= 0
	Private nMultaCalc 	:= 0
	Private nCorrCalc	:= 0
	Private nDifCamCalc	:= 0
	Private nImpSubCalc	:= 0
	Private nPisCalc	:= 0
	Private nCofCalc	:= 0
	Private nCslCalc	:= 0
	Private nIrfCalc	:= 0
	Private nIssCalc	:= 0
	Private nPisBaseR 	:= 0
	Private nCofBaseR	:= 0
	Private nCslBaseR 	:= 0
	Private nIrfBaseR 	:= 0
	Private nIssBaseR 	:= 0
	Private nPisBaseC 	:= 0
	Private nCofBaseC 	:= 0
	Private nCslBaseC 	:= 0
	Private nIrfBaseC 	:= 0
	Private nIssBaseC 	:= 0
	Private lAplMinP 	:= .F.
	Private lEmpPub 	:= IsEmpPub()
	Private nVlMPub 	:= SuperGetMv("MV_VLMPUB" ,.T.,10)
	Private dDtDigit	:= dDatabase
	Private LanceiCTB 	:= .F.

	Default aTitulos	:= {}
	Default __lF090DESC	:= ExistBlock("F090DESC")
	Default __lF90PSTIT := ExistBlock("F090POSTIT")
	Default __lCtLIPag	:= GetMv("MV_CTLIPAG")
	Default __cMVCARTEIR:= GetMv("MV_CARTEIR")
	Default __cMVBXDTFIN:= SuperGetMv("MV_BXDTFIN",,"1")
	Default __lUsaPCO	:= SuperGetMV("MV_PCOINTE",.F.,"2") =="1"
	Default __lMVBXAUTVE:= SuperGetMv("MV_BXAUTVE",.F.,.F.)
	Default __lJFilBco 	:= SuperGetMv( "MV_JFILBCO", .F., .F. ) .And. FindFunction("JURF3SA6") .And. FindFunction("JurVldSA6") //Indica se filtra as contas correntes vinculadas ao escritório logado - SIGAPFS.
	Default __lFINA095	:= IsInCallStack("FINA095")

	//Verifica se data do movimento ‚ menor que data limite de movimentacao no financeiro
	If SuperGetMv("MV_BXDTFIN",,"1") == "2" .and. !DtMovFin(,,"1")
		Return
	Endif

	//Caso não tenha o novo grupo de perguntas, seto Considera Filiais = Não
	//Verificar se o novo grupo de perguntas existe	
	oObj:AddGroup("FIN090A")
	oObj:SearchGroup()
	If Len(aPergunte := oObj:GetGroup("FIN090A")[2]) == 0
		__cPerg := "FIN090"
	Endif
	//Carrega função Pergunte
	SetKey (VK_F12,{|a,b| AcessaPerg(__cPerg,.T.)})
	Pergunte(__cPerg,.F.)

	If __cPerg == "FIN090"
		mv_par06 := If(cPaisloc != "BRA", 2,mv_par06)
		mv_par07 := 2
	Endif	

	f090LRatIR(.T.) // Limpa objeto __oRatIRF IR Progressivo

	cBco090  := If((cPaisloc == "BRA"),CRIAVAR("A6_COD")    ,IIF( lAutoARG,CRIAVAR("A6_COD")    ,If(__lFINA095,cBco380,CRIAVAR("A6_COD"))))
	cAge090	 := If((cPaisloc == "BRA"),CRIAVAR("A6_AGENCIA"),IIF( lAutoARG,CRIAVAR("A6_AGENCIA"),If(__lFINA095,cAge380,CRIAVAR("A6_AGENCIA"))))
	cCta090	 := If((cPaisloc == "BRA"),CRIAVAR("A6_NUMCON") ,IIF( lAutoARG,CRIAVAR("A6_NUMCON") ,If(__lFINA095,cCta380,CRIAVAR("A6_NUMCON"))))
	cBancoF3 := Iif(__lJFilBco, "SA6JUR", "SA6")

	If __lFINA095
		IF lAutoARG
	       dVencIni	:= SEF->EF_DATA
		   dVencFim	:= SEF->EF_VENCTO
		   dDebito  := dDataBase
		   dBaixa   := dDataBase
		Else
			dVencIni	:= dIniDt380
			dVencFim	:= dFimDt380
		Endif
     EndIf
	//As variaveis cBenef090/cHistor090 não estavam sendo alimentadas quando a rotina de origem era a FINA095
	If __lFINA095 .OR. lAutoARG
		cBenef090  := SEF->EF_BENEF
		cHistor090 := SEF->EF_HIST
		cHistAux   := cHistor090
	EndIf

	aFill(aDadosRef,0)
	aFill(aDadosRet,0)
	aFill(aDadosIR ,0)

	//Verifico se houve chamada Automatizada
	If !Empty(aTitulos)
		//Composição de aTitulos
		//aTitulos [1] := aRecnos		(array contendo os Recnos dos registros a serem baixados)
		//aTitulos [2] := cBanco 		(Banco da baixa)
		//aTitulos [3] := cAgencia		(Agencia da baixa)
		//aTitulos [4] := cConta		(Conta da baixa)
		//aTitulos [5] := cCheque		(Cheque da Baixa - apenas Contas a Pagar)
		//aTitulos [6] := cLoteFin		(Lote Financeiro da baixa)
		//aTitulos [7] := cNatureza		(Natureza do movimento bancario - apenas Contas a Pagar)
		//aTitulos [8] := dBaixa		(Data da baixa)
		//aTitulos [9] := nTipoBx		(1 = Baixa somente titulos que não estao em bordero ou nTipoBx -> 2 = Baixa somente titulos em bordero)
		//aTitulos [10]:= cBcoDe 		(Portador de)
		//aTitulos [11]:= cBcoAte		(Portador Até)
		//aTitulos [12]:= dVencIni		(Vencimento Inicial)
		//aTitulos [13]:= dVencFim		(Vencimento Final)
		//aTitulos [14]:= cBord090I		(Borderô Inicial)
		//aTitulos [15]:= cBord090F		(Borderô  Final)
		//aTitulos [16]:= cBenef090		(Beneficiário do Cheque)
		//aTitulos [17]:= cHistor090	(Historico do Cheque)
		//aTitulos [18]:= lMultNat		(Rateio Multiplas naturezas)
		//aTitulos [19]:= aFilBx		(Array com filiais para a baixa) 
		//aTitulos [20]:= aVendor		(Array para a baixa de vendor)		

		lF090Auto := .T.	// Chamada Automatizada

		//Caso a contabilizacao seja online
		//E a tela de contabilizacao possa ser mostrada em caso de erro no lancamento
		//(falta de conta, debito/credito nao batem, etc)
		//A baixa automatica em lote nao podera ser utilizada.
		//Somente sera processada se:
		//MV_PRELAN = S
		//MV_CT105MS = N 
		//MV_ALTLCTO = N
		If mv_par03 == 1 .and. !CTBINTRAN(1,.F.)
			Return
		Endif
	Endif

	VAR_IXB    := .F.
	STRLCTPAD  := " "
	cBord090F  := IIf(Empty(cBord090F),Replicate("Z",Len(cBord090F)),cBord090F)

	If !__lFINA095
		cBcoAte    := IIf(Empty(cBcoAte),Replicate("Z",Len(cBcoAte)),cBcoAte)
	Endif

	//Retorna o Array aDescMotBx contendo apenas a descricao do motivo das Baixas
	For nI := 1 to len( aMotBx )
		If substr(aMotBx[nI],34,01) == "A" .or. substr(aMotBx[nI],34,01) =="P"
			If !(substr(aMotBx[nI],01,03) $ "FAT|LOJ|LIQ|CEC|CMP")
				AADD( aDescMotbx,substr(aMotBx[nI],07,10))
			Endif
		EndIf
	Next

	If GetNewPar("MV_VLTITAD",.F.)
		Aadd( aButtons, { 'PENDENTE', { || F090VlMark(.T.,cAliasSE2,cMarca,oValor,oQtda,oMark,nValor)}, STR0074, STR0075 } ) //"Verifica se ha Titulos com Adiantamento ou Devolucao"###"Validador"
	Endif

	If lPeAddBtn
		aRetAdBtn := Execblock("F090AdBtn",.F.,.F., {aButtons})
		If Valtype(aRetAdBtn)=="A"
			aButtons := aClone(aRetAdBtn)
		Endif
	Endif

	If ExistBlock("F090MNAT") .and. !lF090Auto	 // Verifica presença do PE e Chamada Automatizada
		lMultNat := ExecBlock("F090MNAT",.F.,.F.)	// F090MNAT - Opção de múltiplas Naturezas
	Endif

	//Inicia processo de integracao com o SIGAPCO
	If __lUsaPCO
		PCOIniLan("000006")
	Endif

	While .T.
		nRec      := SE2->( RecNo() )
		nOpca     := 0
		cMotBx    := "NORMAL"
		lTEMP  	  := .F.
		lConfirma := .F.

		//Permite alterar o motivo de baixa inicial por outro motivo disponivel para selecao
		If lF090MTBX
			cMotBx := ExecBlock( "F090MTBX", .F., .F., { aDescMotBx } )
			//Restaura motivo de baixa original se foi informado um motivo nao permitido
			If AScan( aDescMotBx, cMotBx ) == 0
				cMotBx := "NORMAL"
			EndIf
		EndIf

		UltiLote()

		//PONTO DE ENTRADA FA090POS
		//Permite tratamento das variáveis (CBCO090, CAGE090, CTA090, CCHEQ090)
		//apos carga de dados do titulo a ser baixado, antes das informacoes serem mostradas na tela
		If lFA090POS
			aDados   := ExecBlock("FA090POS",.F.,.F.,{cBco090, cAge090, cCta090, cCheq090})
			cBco090  := aDados[1]
			cAge090  := aDados[2]
			cCta090  := aDados[3]
			cCheq090 := aDados[4]
			SE2->(dbGoTo(nSalvRec))
		Endif

		If !lF090Auto	// Chamada Automatizada
			IF !lF090GAVE	// F090GAVE - Manipula filtro para montagem de baixa automática
				aSize := MSADVSIZE()

				If lPanelFin  //Chamado pelo Painel Financeiro
					dbSelectArea(cAlias)
					oPanelDados := FinWindow:GetVisPanel()
					oPanelDados:FreeChildren()
					aDim := DLGinPANEL(oPanelDados)
					DEFINE MSDIALOG oDlg OF oPanelDados:oWnd FROM 0,0 To 0,0 PIXEL STYLE nOR( WS_VISIBLE, WS_POPUP )
					nEspLarg := (((DlgWidthPanel(oPanelDados)/2) - 270) /2)-5
					nEspLin  := 0
					oDlg:lMaximized := .F.
					oPanel:= TScrollBox():New(oDlg,0,0,0,0)
					oPanel:Align := CONTROL_ALIGN_ALLCLIENT
				Else
					DEFINE MSDIALOG oDlg FROM 30,16 To 340,566  TITLE  STR0021 PIXEL //"Baixa Autom tica"
					nEspLarg := 0
					nEspLin  := 0
					oDlg:lMaximized := .F.
					oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20)
					oPanel:Align := CONTROL_ALIGN_ALLCLIENT
				EndIf

				If cPaisloc != "BRA" .AND. __lFINA095
					cBcoDe  := Criavar("EF_BANCO")
					cBcoAte := cBcoDe

					@ 000+nEspLin, 005+nEspLarg TO 029+nEspLin, 060+nEspLarg LABEL  STR0065	PIXEL OF oPanel	// "Baixar"
					@ 000+nEspLin, 065+nEspLarg TO 025+nEspLin, 165+nEspLarg LABEL  STR0009	PIXEL OF oPanel	// "Portador"
					@ 000+nEspLin, 170+nEspLarg TO 025+nEspLin, 270+nEspLarg LABEL  STR0011	PIXEL OF oPanel	// "Vencimento"
					@ 026+nEspLin, 170+nEspLarg TO 052+nEspLin, 270+nEspLarg LABEL  STR0012	PIXEL OF oPanel	// "Mot.Baixa"
					@ 007+nEspLin,007+nEspLarg Radio oRadio VAR nTipoBx ITEMS STR0066 3D ON CHANGE oBcoDe:SetFocus() SIZE 50,10 PIXEL OF oPanel 	//"Títulos"###"Borderôs"

					If UsaSeqCor()
						cCodDiario	:= Criavar("E5_DIACTB",.T.)
						cTitDiar	:= Alltrim(GetSx3Cache("E5_DIACTB","X3_TITULO"))
						@ 031+nEspLin,007+nEspLarg SAY cTitDiar PIXEL of oPanel   // "Codigo Diario"
						@ 039+nEspLin,007+nEspLarg MSGET cCodDiario F3 "CVL" SIZE 37,10 PIXEL of oPanel Valid VldCodSeq( cCodDiario ) When CtbWdia()
					Endif

					@ 009+nEspLin,070+nEspLarg MSGET oBcoDe VAR cBcoDe	F3 "BCO" When Empty(cBcoDe) VALID If(!Empty(cBcoDe),Eval({||cBcoAte:=cBcoDe, If(!cBcoDe $ cFilCxCtr ,.T.,Eval({||MsgAlert(STR0096, STR0072),.F.})) }),.F.) SIZE 37,10 PIXEL of oPanel HASBUTTON
					@ 009+nEspLin,110+nEspLarg SAY	 STR0010 SIZE 10,10 PIXEL of oPanel   // "at‚ "
					@ 009+nEspLin,122+nEspLarg MSGET cBcoAte	F3 "BCO" When .F. SIZE 37,10 PIXEL of oPanel HASBUTTON

					@ 009+nEspLin,175+nEspLarg MSGET dVencIni When nTipoBx == 1 SIZE 45,10 PIXEL of oPanel HASBUTTON
					@ 009+nEspLin,220+nEspLarg SAY	STR0010 SIZE 10,10 PIXEL of oPanel // "at‚ "
					@ 009+nEspLin,226+nEspLarg MSGET dVencFim When nTipoBx == 1 Valid dVencFim >= dVencIni SIZE 45,10 PIXEL of oPanel HASBUTTON
					@ 034+nEspLin,210+nEspLarg COMBOBOX oCbx VAR cMotBx ITEMS aDescMotBx SIZE 56, 47 PIXEL OF oPanel Valid (ShowMotBx("P",.T.))
				Else
					@ 000+nEspLin, 005+nEspLarg TO 029+nEspLin, 060+nEspLarg LABEL  STR0065	PIXEL OF oPanel	// "Baixar"
					@ 000+nEspLin, 065+nEspLarg TO 025+nEspLin, 165+nEspLarg LABEL  STR0009	PIXEL OF oPanel	// "Portador"
					@ 000+nEspLin, 170+nEspLarg TO 025+nEspLin, 270+nEspLarg LABEL  STR0011	PIXEL OF oPanel	// "Vencimento"
					@ 026+nEspLin, 065+nEspLarg TO 052+nEspLin, 165+nEspLarg LABEL  STR0013	PIXEL OF oPanel	// "Border“"
					@ 026+nEspLin, 170+nEspLarg TO 052+nEspLin, 270+nEspLarg LABEL  STR0012	PIXEL OF oPanel	// "Mot.Baixa"

					@ 007+nEspLin,007+nEspLarg Radio oRadio VAR nTipoBx ITEMS STR0066,STR0067 3D ON CHANGE (oBcoDe:SetFocus(),F090NLOTE(nTipoBx,cBord090I,cBord090F),oGetLote:refresh()) SIZE 50,10 PIXEL OF oPanel 	//"Títulos"###"Borderôs"

					If UsaSeqCor()
						cCodDiario	:= Criavar("E5_DIACTB",.T.)
						cTitDiar	:= Alltrim(GetSx3Cache("E5_DIACTB","X3_TITULO"))
						@ 031+nEspLin,007+nEspLarg SAY cTitDiar PIXEL of oPanel   // "Codigo Diario"
						@ 039+nEspLin,007+nEspLarg MSGET cCodDiario F3 "CVL" SIZE 37,10 PIXEL of oPanel Valid VldCodSeq( cCodDiario ) When CtbWdia()
					Endif

					@ 009+nEspLin,070+nEspLarg MSGET oBcoDe VAR cBcoDe F3 "BCO"  VALID If(cPaisLoc=="PER",If(!cBcoDe $ cFilCxCtr ,.T.,Eval({||MsgAlert(STR0096, STR0072),.F.})),.T.) SIZE 37,10 PIXEL of oPanel HASBUTTON
					@ 009+nEspLin,110+nEspLarg SAY	 STR0010 SIZE 10,10 PIXEL of oPanel   // "at‚ "
					@ 009+nEspLin,122+nEspLarg MSGET cBcoAte F3 "BCO" VALID If(cPaisLoc=="PER",If(!cBcoAte $ cFilCxCtr ,.T.,Eval({||MsgAlert(STR0096, STR0072),.F.})),.T.) SIZE 37,10 PIXEL of oPanel HASBUTTON

					@ 009+nEspLin,174+nEspLarg MSGET dVencIni When nTipoBx == 1 SIZE 45,10 PIXEL of oPanel HASBUTTON
					@ 009+nEspLin,217+nEspLarg SAY	STR0010 SIZE 10,8 PIXEL of oPanel // "a"
					@ 009+nEspLin,226+nEspLarg MSGET dVencFim When nTipoBx == 1 Valid dVencFim >= dVencIni SIZE 45,10 PIXEL of oPanel HASBUTTON

					@ 035+nEspLin,070+nEspLarg MSGET cBord090I When nTipoBx == 2 Picture "@S6" SIZE 37,10 PIXEL of oPanel
					@ 035+nEspLin,110+nEspLarg SAY	STR0010 SIZE 10,10 PIXEL of oPanel // "at‚ "
					@ 035+nEspLin,122+nEspLarg MSGET cBord090F When nTipoBx == 2 Picture "@S6" SIZE 37,10 PIXEL of oPanel
					@ 034+nEspLin,174+nEspLarg COMBOBOX oCbx VAR cMotBx ITEMS aDescMotBx SIZE 95, 13 PIXEL OF oPanel Valid (ShowMotBx("P",.T.))
				Endif

				bActWhen 	:= {|| MovBcoBx(cMotBx,.T.) .and. ChqMotBx(cMotBx) .and. mv_par04 == 1 .and. fa090CX(cBco090, nTipoBx==2) }
				bValNumChq 	:= {|| If( Eval(bActWhen), FaPrNumChq(cBco090,cAge090,cCta090,@oCheq090,@cCheq090), .T. ) }
				bMovBanco	:= {|| ( lHabCampos := VldBanco( cMotBx, @cBco090, @cAge090, @cCta090 ) ) }

				If __lFINA095
					@ 052+nEspLin,065+nEspLarg	SAY  STR0034 PIXEL of oPanel	//"Banco"
					If cPaisLoc=="ARG"
			  			@ 059+nEspLin,065+nEspLarg	MSGET oBco090 VAR cBco090 F3 cBancoF3  WHEN Eval(bMovBanco) Valid CarregaSa6(@cBco090,,,.T.) .And. Eval(bValNumChq) .and. fa090BcoCx(cBco090, cAge090, cCta090, cCheq090) .and. If(!cBco090 $ cFilCxCtr  ,.T.,Eval({||MsgAlert(STR0097, STR0072),.F.}))SIZE 10,08 PIXEL of oPanel HASBUTTON
					Else
						@ 059+nEspLin,065+nEspLarg	MSGET oBco090 VAR cBco090 F3 cBancoF3  WHEN Eval(bMovBanco) Valid CarregaSa6(@cBco090,,,.T.) .And. Eval(bValNumChq) .and. fa090BcoCx(cBco090, cAge090, cCta090, cCheq090) .and. If(!cBco090 $ cFilCxCtr .and. cBco090 == cBcoDe ,.T.,Eval({||MsgAlert(STR0097, STR0072),.F.})) .And. fa090BnkVl("1",cBco090,cAge090,cCta090) SIZE 10,08 PIXEL of oPanel HASBUTTON
					EndIf
					@ 052+nEspLin,105+nEspLarg	SAY  STR0035 PIXEL of oPanel	// "Agência"
					@ 059+nEspLin,105+nEspLarg	MSGET cAge090   WHEN Eval(bMovBanco) Valid CarregaSa6(@cBco090,@cAge090,,.T.) .And. Eval(bValNumChq) .And. fa090BnkVl("2",cBco090,cAge090,cCta090) SIZE 15,08 PIXEL of oPanel
					@ 052+nEspLin,150+nEspLarg	SAY  STR0036 PIXEL of oPanel	//"Conta"
					@ 059+nEspLin,150+nEspLarg	MSGET cCta090   WHEN Eval(bMovBanco) Valid If(CarregaSa6(@cBco090,@cAge090,@cCta090,.T.,,.T.),Eval(bValNumChq),oBco090:SetFocus()) .And. fa090BnkVl("3",cBco090,cAge090,cCta090) SIZE 50,08 PIXEL of oPanel
					@ 052+nEspLin,215+nEspLarg	SAY  STR0064 PIXEL of oPanel //"Cheque"
				Else
					@ 052+nEspLin,065+nEspLarg	SAY  STR0034 PIXEL of oPanel	//"Banco"
					@ 059+nEspLin,065+nEspLarg	MSGET oBco090 VAR cBco090 F3 cBancoF3  WHEN Eval(bMovBanco) Valid CarregaSa6(@cBco090,,,.T.) .And. Eval(bValNumChq) .and. fa090BcoCx(cBco090, cAge090, cCta090, cCheq090) .AND. If(cPaisLoc=="PER",If(!cBco090 $ cFilCxCtr ,.T.,Eval({||MsgAlert(STR0097, STR0072),.F.})),.T.) .And. fa090BnkVl("1",cBco090,cAge090,cCta090) SIZE 10,08 PIXEL of oPanel HASBUTTON
					@ 052+nEspLin,105+nEspLarg	SAY STR0035  PIXEL of oPanel	//"Agência"
					@ 059+nEspLin,105+nEspLarg	MSGET cAge090   WHEN Eval(bMovBanco) Valid CarregaSa6(@cBco090,@cAge090,,.T.) .And. Eval(bValNumChq) .And. fa090BnkVl("2",cBco090,cAge090,cCta090) SIZE 15,08 PIXEL of oPanel
					@ 052+nEspLin,150+nEspLarg	SAY  STR0036 PIXEL of oPanel	//"Conta"
					@ 059+nEspLin,150+nEspLarg	MSGET cCta090   WHEN Eval(bMovBanco) Valid If(CarregaSa6(@cBco090,@cAge090,@cCta090,.T.,,.T.),Eval(bValNumChq),oBco090:SetFocus()) .And. fa090BnkVl("3",cBco090,cAge090,cCta090) SIZE 50,08 PIXEL of oPanel
				Endif

				@ 052+nEspLin,215+nEspLarg	SAY  STR0064 PIXEL of oPanel //"Cheque"
				@ 059+nEspLin,215+nEspLarg	MSGET oCheq090 VAR cCheq090 When !RetGlbLGPD("EF_BENEF") .and. Eval(bActWhen) ;
				Valid (IIF(AllTrim(cCheq090)<>"" .and. AllTrim(cHistor090)=="",cHistor090 := STR0070,If(AllTrim(cCheq090)=="",cHistor090 := "", )),FA090Cheq(cBco090,cAge090,cCta090,cCheq090)) SIZE 53,08 PIXEL of oPanel

				@ 071+nEspLin,066+nEspLarg SAY STR0068 PIXEL of oPanel //"Beneficiario"
				@ 078+nEspLin,066+nEspLarg MSGET oBenef090 VAR cBenef090 Picture "@!" When (!RetGlbLGPD("EF_BENEF") .and. !Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*") SIZE 80,08 PIXEL of oPanel OBFUSCATED RetGlbLGPD("EF_BENEF")
				@ 071+nEspLin,150+nEspLarg SAY STR0069 PIXEL of oPanel //"Natureza do Movto"
				@ 078+nEspLin,150+nEspLarg MSGET cNatur090 F3 "SED" When lF090NatLot .or. (!Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*") .or. (lBxCnab) VALID FinVldNat( .T., cNatur090 ) SIZE 50,08 PIXEL of oPanel HASBUTTON
				@ 071+nEspLin,215+nEspLarg SAY STR0063 PIXEL of oPanel //"Lote"
				@ 078+nEspLin,215+nEspLarg GET oGetLote VAR cLoteFin Picture "@!" When lF090NatLot .or. lBxCnab .and.;
					((nTipoBx == 2) .or. ;
					((SubStr(cBco090,1,2) == "CX" .or. cBco090 $ __cMVCARTEIR).and. eval(bMovBanco))) ;
					Valid (!lBxCnab .Or. !Empty(cLoteFin)) .And. CheckLote("P") SIZE 53,08 PIXEL of oPanel

				@ 090+nEspLin,066+nEspLarg SAY STR0088 PIXEL of oPanel //"Historico do Cheque"
				@ 097+nEspLin,066+nEspLarg MSGET cHistor090 Picture "@!" When (!Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*" ) SIZE 203,08 PIXEL of oPanel

				@ 112+nEspLin,066+nEspLarg SAY STR0160  PIXEL of oPanel  //"Dt Baixa"
				@ 119+nEspLin,066+nEspLarg  MSGET DBAIXA When .T. 	SIZE 45,10 OF oPanel PIXEL HASBUTTON ;
				 													Valid ( !Empty(DBAIXA) .AND. Iif(__cMVBXDTFIN == "2", DtMovFin(DBAIXA,,"1"), .T.))

				//Somente exibe a opcao Rateio Multiplas Naturezas se parametro MV_MULNATP = .T.
				If MV_MULNATP
					@ 115+nEspLin,159+nEspLarg SAY STR0093 PIXEL of oPanel  //"Rateio Mult.Naturezas"
					@ 114+nEspLin,150+nEspLarg  CHECKBOX oMultNat VAR lMultNat PROMPT "" SIZE 203,08 OF oPanel PIXEL
				Endif

				If lPanelFin  //Chamado pelo Painel Financeiro
					oDlg:Move(aDim[1],aDim[2],aDim[4]-aDim[2], aDim[3]-aDim[1])
					ACTIVATE MSDIALOG oDlg ON INIT FaMyBar(oDlg,;
					{||nOpca := 1,If(F090VldBx(nTipoBx,lBxCnab,cBco090,cAge090,cCta090,cMotBx,oDlg,cCheq090,cBord090I,cBord090F,oRadio),oDlg:End(),nOpca:=0)}, {||oDlg:End()})
					FinVisual(cAlias,FinWindow,(cAlias)->(Recno()),.T.)
				Else
					@ 133, 000 TO 134, 340 PIXEL OF oPanel

					DEFINE SBUTTON FROM 138,210 TYPE 1 ACTION ( lConfirma := .T., nOpca := 1, Iif( F090vLDbX(nTipoBx,lBxCnab,cBco090,cAge090,cCta090,cMotBx,oDlg,cCheq090,cBord090I,cBord090F,,lBcoExcl), oDlg:End(), nOpca:=0 ) ) ENABLE OF oDlg
					DEFINE SBUTTON FROM 138,240 TYPE 2 ACTION ( lConfirma := .F., oDlg:End() ) ENABLE OF oDlg

	                If !lAutoARG
						ACTIVATE MSDIALOG oDlg CENTERED
					Else
						If FindFunction("GetParAuto")
							aRetAuto 	:= GetParAuto("FINA095TESTCASE")
							cBco090 	:= aRetAuto[1]
							cAge090 	:= aRetAuto[2]
							cCta090 	:= aRetAuto[3]
							cCheq090	:= aRetAuto[4]
							dBaixa		:= aRetAuto[5]
							cBcoDe		:= aRetAuto[6]
							cBcoAte		:= aRetAuto[7]
						Endif
						nOpca := 1
					EndIF
				Endif
			ELSE
				If UsaSeqCor()
					AADD(aVars,cCodDiario)
					nTotCpos := 17
				Endif

				AADD(aVars,nTipoBx)
				AADD(aVars,cBcoDe)
				AADD(aVars,cBcoAte)
				AADD(aVars,dVencIni)
				AADD(aVars,dVencFim)
				AADD(aVars,cBord090I)
				AADD(aVars,cBord090F)
				AADD(aVars,cMotBx)
				AADD(aVars,cBco090)
				AADD(aVars,cAge090)
				AADD(aVars,cCta090)
				AADD(aVars,cCheq090)
				AADD(aVars,cBenef090)
				AADD(aVars,cNatur090)
				AADD(aVars,cLoteFin)
				AADD(aVars,cHistor090)

				If MV_MULNATP
					AADD(aVars,lMultNat)
					nTotCpos := 19
				Endif

				AADD(aVars,nOpca)
				aVarsOld := aVars
				aVars := Execblock("F090GAVE",.F.,.F.,aVars)

				//Valida retorno do PE F240GAVE
				If ValType(aVars) != "A" .OR. Len(aVars) < nTotCpos
					aVars := aVarsOld
				Endif

				If UsaSeqCor()
					cCodDiario 	:= aVars[1]
					nTipoBx 	:= aVars[2]	//nTipoBx -> 1 = Baixa somente titulos que não estao em bordero  //nTipoBx -> 2 = Baixa somente titulos em bordero
					cBcoDe 		:= aVars[3]
					cBcoAte 	:= aVars[4]
					dVencIni 	:= aVars[5]
					dVencFim 	:= aVars[6]
					cBord090I 	:= aVars[7]
					cBord090F 	:= aVars[8]
					cMotBx 		:= aVars[9]
					cBco090 	:= aVars[10]
					cAge090 	:= aVars[11]
					cCta090 	:= aVars[12]
					cCheq090 	:= aVars[13]
					cBenef090 	:= aVars[14]
					cNatur090 	:= aVars[15]
					cLoteFin  	:= aVars[16]
					cHistor090 	:= aVars[17]

					If MV_MULNATP
						lMultNat := aVars[18]
					Endif

					nOpca      := aVars[19]
				Else
					nTipoBx 	:= aVars[1]	//nTipoBx -> 1 = Baixa somente titulos que não estao em bordero  //nTipoBx -> 2 = Baixa somente titulos em bordero
					cBcoDe 		:= aVars[2]
					cBcoAte 	:= aVars[3]
					dVencIni 	:= aVars[4]
					dVencFim 	:= aVars[5]
					cBord090I 	:= aVars[6]
					cBord090F 	:= aVars[7]
					cMotBx 		:= aVars[8]
					cBco090 	:= aVars[9]
					cAge090 	:= aVars[10]
					cCta090 	:= aVars[11]
					cCheq090 	:= aVars[12]
					cBenef090 	:= aVars[13]
					cNatur090 	:= aVars[14]
					cLoteFin  	:= aVars[15]
					cHistor090 	:= aVars[16]

					If MV_MULNATP
						lMultNat := aVars[17]
						nOpca    := aVars[18]
					Else
						nOpca 	:= aVars[17]
					Endif
				Endif
			ENDIF
		Else
			//-----------------------------------
			//Rotina Automatizada
			//-----------------------------------
			nOpca		:= 0
			nTamaTit	:= Len(aTitulos)
			nRec		:= SE2->( RecNo() )
			lGerTotal	:= lBxCnab
			cBco090		:= aTitulos[2]		// Banco
			cAge090		:= aTitulos[3]		// Agência
			cCta090		:= aTitulos[4]		// Conta Corrente
			cCheq090	:= aTitulos[5]		// Cheque
			cLoteFin	:= aTitulos[6]		// Lote
			cNatur090	:= aTitulos[7]		// Natureza do Movto
			nMoedaBco	:= Max(MoedaBco(cBco090,cAge090,cCta090),1)

			If nTamaTit > 7
				dBaixa	:= aTitulos[8]		//Data da Baixa
				dDebito := aTitulos[8]		//Data de Débito
			Endif
			If nTamaTit > 8
				nTipoBx := aTitulos[9]		// 1 = Baixa somente titulos que não estao em bordero ou nTipoBx -> 2 = Baixa somente titulos em bordero
			Endif
			If nTamaTit > 9
				cBcoDe := aTitulos[10]		// Portador de
			Endif
			If nTamaTit > 10
				cBcoAte := aTitulos[11]		// Portador Até
			Endif
			If nTamaTit > 11
				dVencIni := aTitulos[12]	// Vencimento Inicial
			Endif
			If nTamaTit > 12
				dVencFim := aTitulos[13]	// Vencimento Final
			Endif
			If nTamaTit > 13
				cBord090I := aTitulos[14]	// Borderô Inicial
			Endif
			If nTamaTit > 14
				cBord090F := aTitulos[15]	// Borderô  Final
			Endif
			If nTamaTit > 15
				cBenef090 := aTitulos[16]	// Beneficiário do Cheque
			Endif
			If nTamaTit > 16
				cHistor090 := aTitulos[17]	// Historico do Cheque
			Endif
			If nTamaTit > 17 .and. MV_MULNATP
				lMultNat := aTitulos[18]	// Rateio Multiplas naturezas
			Endif
			If nTamaTit > 18 .and. !Empty(aTitulos[19])
				aFilAux := aTitulos[19]	// Array contendo dados das filiais as serem consideradas para o processo
			Endif
			If nTamaTit > 19 .and. TrazCodMot(cMotBx) == "VEN"  .and. __lMVBXAUTVE
				aVendor := aTitulos[20]	// Array contendo dados para o Vendor
			Endif

			If F090VldBx(nTipoBx,lBxCnab,cBco090,cAge090,cCta090,cMotBx,oDlg,cCheq090,cBord090I,cBord090F,oRadio,lBcoExcl,lF090Auto,aVendor)
				nOpca	:= 1
			Endif

		Endif

		If nOpca == 0
			Exit
		EndIf

		nRec		:= SE2->( RecNo() )
		lMovBcoBx	:= MovBcoBx(cMotBx, .T.)
		dbSelectArea( cAlias )
		F090GetCampos(aCampos,aEstruct)

		If mv_par07 == 1 .and. !lF090GAVE		//Seleciona Filiais
			If !lF090Auto
				// Seleção de filiais
				aFilAux := AdmGetFil(.F.,.T.,"SE2")
				If Len( aFilAux ) <= 0
					nOpca := 0
					Exit
				EndIf
			Else
				If Empty(aFilAux)	
					aFilAux := AdmGetFil(.F.,.T.,"SE2",,,.F.)
					For nI := 1 to len( aFilAux )
						AADD(aSelFil, aFilAux[nI][1] )
					Next nI
					aFilAux := aSelFil
				Endif
			EndIf
		Else
			aFilAux := {cFilAnt}
		Endif

		If lF091FBX		//PE transferido do FINA091
			lF090Fil := EXECBLOCK("F091FBX",.F.,.F.,)
			If !Valtype(lF090Fil) == "L" 
				lF090Fil := .F.						
			EndIf
		EndIf	

		//Se o cadastro de bancos for exclusivo e motivo de baixa movimenta banco, filtra as filiais que possuam os mesmos códigos de banco + agência + conta
		cChaveBco := cBco090 + cAge090 + cCta090
		If lBcoExcl .And. lMovBcoBx .And. !lF090Fil
			aSelFil := FiltFilBco(aFilAux, cChaveBco)
			FwFreeArray(aFilAux)
		Else
			aSelFil := aFilAux
		EndIf

		//Monta expressao do Filtro para seleção
		nMoedaBco	:= Max(MoedaBco(cBco090,cAge090,cCta090),1)

		//Funcao para montar e processar a query
		lTEMP		:= .T.
		nMoedaBco	:= Max(MoedaBco(cBco090,cAge090,cCta090),1)
		cArqNew		:= f090QryA(aSelFil,aTMPFil,aCampos,aEstruct,nTipoBx,cBord090I,cBord090F,@cBco090,@cAge090,@cCta090)

		//Altera Database
		dDatabase 	:= dBaixa

		If cArqNew == "NOACESS"  // Caso o usuario não tenha nenhuma permissão aborta o processo do bordero
			Help(" ",1,"RECNO")
			F090Clean()
			lTEMP := .F.
			Exit
		EndIf

		If !Empty( cArqNew )
			dbselectarea(cAliasSE2)
			dbGoTop()
		EndIf

		If (cAliasSE2)->(Bof()) .And. (cAliasSE2)->(Eof())
			Help(" ",1,"RECNO")
			If lTEMP
				F090Clean()
			EndIf
			lTEMP := .F.
			Exit
		EndIf

		nValor	:= 0    // valor total dos titulos mostrado no cabecalho do browse
		nQtdTit	:= 0    // quantidade de titulos mostrado no cabecalho do browse
		nOpcA	:= 0

		//Ponto de entrada para tratamento dos campos a serem demonstrados na tela de selecao dos titulos
		If lF090CPOS
			aCampos := EXECBLOCK("F090CPOS",.F.,.F.,aCampos)
		Endif

		If __lF090DESC
			nDescont := EXECBLOCK("F090DESC",.F.,.F.)
		Endif

		If lF090Auto	// Chamada Automatizada
			nOpcA		:= 1
			Fa090Marca(cAliasSE2,cMarca,aTitulos[1],@nTipoBx)
			nI := Ascan(aMotBx, {|x| Substr(x,1,3) == TrazCodMot(cMotBx) })
			cDescrMo := if( nI > 0,Substr(aMotBx[nI],07,10),"" )
		Else
			dbSelectArea(cAliasSE2)
			Processa( {|| Fa090Marca(cAliasSE2,cMarca) }, STR0163, STR0164,.F.) //"Aguarde..."#"Selecionando registros..."
			(cAliasSE2)->(DbGoTop())

			oSize := FwDefSize():New(.T.)
			oSize:lLateral := .F.
			oSize:lProp	:= .T. // Proporcional
			oSize:AddObject( "1STROW" ,  100, 12, .T., .T. ) // Totalmente dimensionavel
			oSize:AddObject( "2NDROW" ,  100, 88, .T., .T. ) // Totalmente dimensionavel
			oSize:aMargins := { 2, 2, 1, 2 } // Espaco ao lado dos objetos 0, entre eles 3
			oSize:Process() // Dispara os calculos
			a1stRow := {oSize:GetDimension("1STROW","LININI"), oSize:GetDimension("1STROW","COLINI"), oSize:GetDimension("1STROW","LINEND"), oSize:GetDimension("1STROW","COLEND")}
			a2ndRow := {oSize:GetDimension("2NDROW","LININI"), oSize:GetDimension("2NDROW","COLINI"), oSize:GetDimension("2NDROW","LINEND"), oSize:GetDimension("2NDROW","COLEND")}

			DEFINE MSDIALOG oDlg1 TITLE STR0008 From oSize:aWindSize[1],oSize:aWindSize[2] to oSize:aWindSize[3],oSize:aWindSize[4] OF oMainWnd PIXEL //"Bordero de Cobran‡a"
			oTimer:= TTimer():New((nTimeOut-nTimeMsg),{|| MsgTimer(nTimeMsg,oDlg1) },oDlg1) // Ativa timer
			oTimer:Activate()
			oDlg1:lMaximized := .T.

			@ a1stRow[1] + 001, a1stRow[2] + 001  To a1stRow[3],a1stRow[4] PIXEL OF oDlg1
			@ a1stRow[1] + 003, a1stRow[2] + 005 SAY STR0026 SIZE 50,10 PIXEL Of oDlg1  // "Valor Total:"
			@ a1stRow[1] + 003, a1stRow[2] + 060 SAY oValor VAR nValor PICTURE  PesqPict("SE2","E2_SALDO",TamSx3("E2_SALDO")[1]) SIZE 50,10  PIXEL Of oDlg1
			@ a1stRow[1] + 012, a1stRow[2] + 005 SAY STR0027 SIZE 50,10  PIXEL Of oDlg1 // "Quantidade:"
			@ a1stRow[1] + 012, a1stRow[2] + 083 SAY oQtda VAR nQtdTit PICTURE "@E 99999" 	SIZE 50,10  PIXEL Of oDlg1

			oMark	:= MsSelect():New(cAliasSE2, "E2_OK", "!E2_SALDO", aCampos, @lInverte, @cMarca, {a2ndRow[1], a2ndRow[2], a2ndRow[3], a2ndRow[4]})
			oMark:bMark	:= {||FA090Display(cAliasSE2,cMarca,lInverte,oValor,oQtda,"P",lBaixa)}
			oMark:bAval	:= {||Fa090bAval(cAliasSE2, cMarca, oValor, oQtda, oMark)}
			oMark:oBrowse:lhasMark		:= .T.
			oMark:oBrowse:lCanAllmark	:= .T.
			oMark:oBrowse:bAllMark		:= { || Processa( {|| Fa090Inverte(cAliasSE2,cMarca,oValor,oQtda,.T.,oMark)}, STR0163, STR0164,.F.) }

			bOk1 := {|| If( !GetNewPar("MV_VLTITAD",.F.), lVldAD := .T., Nil ) }
			bOk2 := {|| If( FA090PcoLan(cMarca), (nOpca := 1,oDlg1:End()), Nil ) }
			bOk3 := {|| MsgInfo(STR0076, STR0072) }
			bOk4 := {|| IF( F090CHQOK(), Nil , (nOpca := 0)) }

			If __lF90PSTIT
			   ExecBlock("F090POSTIT", .F., .F., { cAliasSE2 } )
			Endif

			If lPanelFin  //Chamado pelo Painel Financeiro
				ACTIVATE MSDIALOG oDlg1 ON INIT FaMyBar( oDlg1,	{|| ( Eval(bOk1), If(lVldAD,Eval(bOk2),Eval(bOk3)) ) }, {|| nOpca := 0,ODlg1:End()}, aButtons )
			Else
				ACTIVATE MSDIALOG oDlg1 ON INIT EnchoiceBar( oDlg1, {|| ( Eval(bOk1),If(lVldAD,Eval(bOk2),Eval(bOk3)),Eval(bOk4),If(UsaSeqCor(),CTBvldDiario(cCodDiario,dDataBase),) ) },{|| nOpca := 0,ODlg1:End()},, aButtons ) //VALID (oTimer:End(),.T.)
			Endif

			ddatabase := dBaixa
			dDebito	  := dBaixa

			If nOpca != 1
				dbSelectArea(cAliasSE2)
				(cAliasSE2)->(dbGoTop())

				While (cAliasSE2)->(!EOF())
					SE2->(dbGoto((cAliasSE2)->NUM_REG))
					SE2->(MsUnlock())
					(cAliasSE2)->(MsUnlock())
					dbSkip()
				Enddo

				If Select(cAliasSE2) > 0
					F090Clean()
					lTEMP := .F.
				Endif

				DbSelectArea("SE2")
				dbSetOrder(1)

				//Zera os Arrays de Estruturas e Campos utilizados na contrução da MSSELECT
				aCampos := {}
				aEstruct := {}

				If __lSX8
					RollBackSX8()
				Endif

				Loop
			EndIf

			dbSelectArea("SE2")

			IF nValor == 0
				Exit
			EndIf

			nI       :=  Ascan(aMotBx, {|x| Substr(x,1,3) == TrazCodMot(cMotBx) })
			cDescrMo := If(nI > 0, Substr(aMotBx[nI],07,10), "")

			If nOpcA == 2
				RetIndex("SE2")
				Set Filter to

				If __lSX8
					RollBackSX8()
				Endif

				Loop
			Endif

		Endif

		If nOpca == 1
			cPadrao   := If(nTipoBx == 1, "530", "532")
			lPadrao   := MV_PAR03 == 1 .And. VerPadrao(cPadrao)
			lContinua := F090Baixa(lF090Auto,nTipoBx,lPCCBaixa,lMovBcoBx,cPadrao, lPadrao, cCheq090, cBenef090, cNatur090, ;
									cHistor090, lUsaFlag, lSpbInUse, lAtuSldBco, lMultNat, cFilBaixa, @lCheque,cDescrMo, @nTotAger, @lGerTotal, aVendor )
		Endif

		Exit
	Enddo

	//-------------------------------------------------------------------------------------------------------------
	// Caso nao confirme a baixa ou confirme sem selecionar nenhum titulo/bordero, forca finalizacao do processo
	// de validacao de bloqueio (PcoVldLan) do SIGAPCO
	//-------------------------------------------------------------------------------------------------------------
	If lContinua
		If __lUsaPCO
			If nOpca # 1 .Or. (nOpca == 1 .And. nValor == 0)
				PCOFinLan("000006")
			EndIf
		EndIf

		If __lSX8
			RollBackSX8()
		Endif

		//Grava no SE5 o numero do último lote recebido e gera movimentacao bancaria
		If nTotAger > 0 .and. lGerTotal
			If Empty(cNatur090)
				cNatur090 := FINNATMOV("P")
			Endif

			//Model de Movimento bancario
			oModelMov := FWLoadModel("FINM030")
			oModelMov:SetOperation(MODEL_OPERATION_INSERT) //Inclusao
			oModelMov:Activate()
			oSubFK5M  := oModelMov:GetModel("FK5DETAIL")
			oSubFKAM  := oModelMov:GetModel("FKADETAIL" )

			oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
			oModelMov:SetValue( "MASTER", "NOVOPROC", .T. ) //Novo processo

			// Inclui registro no SE5 para a geracao do cheque
			cCamposE5 := "{"
			cCamposE5 += " {'E5_DTDIGIT' , dDtDigit }"
			cCamposE5 += ",{'E5_BENEF'   , '"+StrTran(cBenef090,"'","")+"' } "
			cCamposE5 += ",{'E5_LOTE'    , '"+cLoteFin +"' }}"

			//Dados do movimento bancario do Cheque
			If !oSubFKAM:IsEmpty()
				//Inclui a quantidade de linhas necessárias
				oSubFKAM:AddLine()
				//Vai para linha criada
				oSubFKAM:GoLine( oSubFKAM:Length() )
			Endif

			oSubFKAM:SetValue( 'FKA_IDORIG', FWUUIDV4() )
			oSubFKAM:SetValue( 'FKA_TABORI', 'FK5' )

			oSubFK5M:SetValue( "FK5_RECPAG" , "P" )
			oSubFK5M:SetValue( "FK5_HISTOR" , STR0062+ cLoteFin) //"Baixa Automatica / Lote : "
			oSubFK5M:SetValue( "FK5_DATA"   , dDataBase )
			oSubFK5M:SetValue( "FK5_DTDISP" , dDataBase )
			oSubFK5M:SetValue( "FK5_NATURE" , cNatur090 )
			oSubFK5M:SetValue( "FK5_BANCO"  , cBco090 )
			oSubFK5M:SetValue( "FK5_AGENCI" , cAge090 )
			oSubFK5M:SetValue( "FK5_CONTA"  , cCta090 )
			oSubFK5M:SetValue( "FK5_VALOR"  , nTotAger )
			oSubFK5M:SetValue( "FK5_ORIGEM" , FunName() )

			If lCheque .And. mv_par04 == 1
				oSubFK5M:SetValue("FK5_TPDOC", "CH")
			Else
				oSubFK5M:SetValue("FK5_TPDOC"  , IF(!Empty(cLoteFin), "BL", "VL"))
			EndIf

			oSubFK5M:SetValue( "FK5_CCUSTO" , SE2->E2_CCUSTO )
			oSubFK5M:SetValue( "FK5_FILORI" , cFilAnt )
			oSubFK5M:SetValue( "FK5_MOEDA"  , StrZero(nMoedaBco,2) )
			oSubFK5M:SetValue( "FK5_LA"     , Iif(mv_par04==1 .and. lPadrao .and. !lUsaFlag .and. cCtBaixa$"AC","S"," ") )
			oSubFK5M:SetValue( "FK5_LOTE"   , cLoteFin )

			If lSpbInUse
				oSubFK5M:SetValue( "FK5_MODSPB" , "1" )
			Endif

			oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )

			If oModelMov:VldData()
				oModelMov:CommitData()
			Else
				lRet := .F.
				cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[6])

				Help( ,,"M020VLDI6",,cLog, 1, 0 )
			Endif

			oModelMov:DeActivate()
			oModelMov:Destroy()
			oModelMov := Nil

			//Atualiza saldo bancario.
			If lAtuSldBco
				AtuSalBco(cBco090,cAge090,cCta090,SE5->E5_DATA,SE5->E5_VALOR,"-")
			EndIf

			// Ponto de Entrada para manipular o registro totalizador da baixa automatica por lote
			If lF90TotGrv
				ExecBlock("F90TOTGRV")
			EndIf
		EndIf
	Endif

	dbSelectArea("SE2")
	RetIndex("SE2")

	If cPaisLoc =="BRA"
		If !__lCtLIPag
			dbSelectArea("SE2")
			dbSetOrder(3)
			dbSeek( cFilial )
			cKey1 := INDEXKEY()
		Else
			dbSelectArea("SE2")
			dbSetOrder(3)  //"E2_FILIAL+DTOS(E2_VENCREA)+E2_NOMFOR+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO"
			cFilter := "E2_FILIAL = '"+xFilial("SE2")+"' .AND. (DTOS(E2_DATALIB) <> '        ' .OR. E2_SALDO+E2_SDACRES-E2_SDDECRE <= "+Alltrim(Str(GetMv('MV_VLMINPG'),15,7))+")"
			Set Filter to &cFilter
			dbGotop()
		Endif
	Else
		Eval(bFilBrw)
		dbGoTo(nSalvRec)
	Endif

	//Libera os registros
	If lTEMP
		dbSelectArea(cAliasSE2)
		(cAliasSE2)->(dbGoTop())

		While (cAliasSE2)->(!EOF())	
			SE2->(dbGoto((cAliasSE2)->NUM_REG))
			SE2->(MsUnlock())
			(cAliasSE2)->(MsUnlock())
			dbSkip()
		Enddo

		If Select(cAliasSE2) > 0
			F090Clean()
		Endif
		SE2->(RestArea(aAreaSE2))
	Endif

	//Restaura Variaveis
	dDataBase := dAtuDtBase
	dBaixa 	  := dDataBase

	//Ponto de entrada apos a restauracao dos indices
	If ExistBlock("F090REST")
		ExecBlock( "F090REST",.F.,.F.)
	EndIf

	If nOpca == 1 .And. GetNewPar( "MV_NGMNTFI","N" ) == 'S'
		// Função que atualiza a TRX  - Multa (Integração SIGAFIN - SIGAMNT).
		If FindFunction( "NGBAIXASE2" ) //Verifica se a função está disponível no rpo ou no binário, do Application Server, para ser executada.
			NGBAIXASE2( 1 )
		Endif

		//Função que gera uma apropriação de débito da multa, (Integração SIGAFIN - SIGAMNT).
		If FindFunction( "MNT765CONF" ) //Se for executado a baixa automática de pagaento da multa;
			lPagAutFin := .F. //Variável utilizada em fonte especifico do SIGAMNT;
			MNT765CONF( 3 ) 	//Executa a função que gera APD;
		EndIf
	EndIf

	If __oPrepared != NIL
		__oPrepared:Destroy()
		__oPrepared := NIL
	Endif

	IF lF090Auto
		MBrChgLoop(.F.)
	ElseIf !lF090Auto .And. INCLUI
		MBrChgLoop(.F.) // Evita que a opera‡?o seja reiniciada pela mBrowse
	EndIf

	cFilAnt := Iif( lConfirma == .T., cFilBaixa, cFilLogada )

	For nX := 1 TO Len(aTmpFil)
		CtbTmpErase(aTmpFil[nX])
	Next

	f090LRatIR(.T.) // Limpa objeto __oRatIRF IR Progressivo

Return (.T.)

//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F090Baixa
Funcao para efetivar as baixas 

@Param lF090Auto  , Logical	  , Indica chamada automatizada da rotina
@Param nTipoBx	  , Numeric	  , Tipo de Baix: 1 = Título ou 2 = Borderô
@Param lPCCBaixa  , Logical	  , Indica cálculo de PCC na baixa
@Param nValorTotal, Numeric   , Valor total selecionado
@Param lMovBcoBx  , Logical   , Indica se o motivo de baixa gera movimento bancário
@Param cPadrao    , Character , Código do LP utilizado na contabilização
@Param lPadrao	  , Logical   , Indica se o LP utilizado está ativo
@Param cCheq090   , Character , Número do cheque informado
@Param cBenef090  , Character , Beneficiário do pagamento
@Param cNatur090  , Character , Natureza do pagamento
@Param cHistor090 , Character , Histórico do pagamento
@Param lUsaFlag	  , Logical   , Indica o uso de Flag Contábil
@Param lSpbInUse  , Logical   , Indica o uso do SPB
@Param lAtuSldBco , Logical   , Indica se o saldo bancário será atualizado
@Param lMultNat	  , Logical   , Indica o uso de rateio multinatureza
@Param cFilBaixa  , Character , Filial da Baixa
@Param lCheque	  , Logical   , Indica se o LP utilizado está ativo

@return lContinua , Logical   , Indica o funcionamento ou falha do processo

@author  Mauricio Pequim Jr
@since   08/11/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function F090Baixa(lF090Auto As Logical,nTipoBx As Numeric, lPCCBaixa As Logical, lMovBcoBx As Logical,;
					cPadrao As Character, lPadrao As Logical, cCheq090 As Character, cBenef090 As Character, cNatur090 As Character,;
					cHistor090 As Character, lUsaFlag As Logical, lSpbInUse As Logical, lAtuSldBco As Logical, lMultNat As Logical,;
					cFilBaixa As Character, lCheque As Logical, cDescrMo As Character, nTotAger As Numeric, lGerTotal As Logical, aVendor As Array )

	Local nX 			:= 0
	Local nY 			:= 0
	Local nZ			:= 0
	Local nI 			:= 0
	Local nTotal		:= 0
	Local nHdlPrv		:= 0
	Local nSaldo		:= 0
	Local nSaldoCru		:= 0
	Local nSalDup		:= 0
	Local nRegAtu		:= 0
	Local nTotAbtF 		:= 0
	Local nValorCheq	:= 0
	Local nRegPrinc 	:= 0
	Local nLen 			:= 0
	Local nOldRetPis	:= 0
	Local nOldRetCof	:= 0
	Local nOldRetCsl	:= 0
	Local nTotLtEZ		:= 0	//Totalizador da Bx Lote Mult Nat CC
	Local nValorTotal	:= 0
	Local nRecNoSE5		:= 0
	Local nRecNoSE2		:= 0
	Local nRecNoFK2		:= 0
	Local nRecnSE5		:= 0
	Local nOrderSEF		:= 0
	Local nValorSE5		:= 0
	Local nLstRecSE5 	:= 0
	Local nSalTit 		:= 0
	Local nGerPAMov 	:= 0
	Local nTotARet		:= 0
	Local nTamTitPai	:= TAMSX3("E2_TITPAI")[1]
	Local nRecPAInc 	:= 0
	Local nCentMd1		:= (MsDecimais(1) + 1)
	Local nVA			:= 0
	Local nTxMoedBx		:= 0 
	Local nValorSEF		:= 0
	Local nRecSE2		:= 0
	Local nDtContOn		:= SuperGetMv("MV_DTCNBXP",.F.,3) // Data para contabilização Online baixas pagar 1- Data Digitação; 2- Data Disponibilidade; 3- Data Pagamento
	Local nVlMinImp 	:= GetNewPar("MV_VL10925",5000)

	Local lPadAux 		:= .F.
	Local lRetParc 		:= .T.
	Local lBaixaPA		:= .F.
	Local lIsTitPA		:= .F.
	Local lAchouFor		:= .F.
	Local lGerPAMov		:= .F.
	Local lCtbIncPA 	:= .F.
	Local lPAMov		:= .F.
	Local lNewProc		:= .T.
	Local lRetBor		:= .T.
	Local lCalcPccBx 	:= .F.
	Local lIRPFBaixa 	:= .F.
	Local lCalcIssBx 	:= .F.
	Local lVendor		:= .F.
	Local lPadraoVd		:= .F.
	Local lAplVlMin 	:= .T.
	Local lBord241 		:= .F.
	Local lBord240		:= .F.
	Local lIsCaixa		:= .F.
	Local lTotPorBord	:= .F.
	Local lOk			:= .F.	//Controla se foi confirmada a distribuicao
	Local lSetAuto		:= .F.
	Local lSetHelp		:= .F.
	Local lDtBaixa		:= .F.
	Local lPCC241		:= .F.
	Local lRet 			:= .T.
	Local lDigita		:= IIF(mv_par01==1,.T.,.F.)
	Local lAglut		:= IIF(mv_par02==1,.T.,.F.)
	Local lFa080Sef 	:= ExistBlock("FA080SEF")
	Local lFa090Se5 	:= ExistBlock("FA090SE5")
	Local lF90Se5Grv 	:= ExistBlock("F90SE5GRV") // PE para gravacoes complementares da baixa
	Local lFa090Desc	:= ExistBlock("FA090DES")
	Local lFa090Juros	:= ExistBlock("FA090JUR")
	Local lFa090Mult	:= ExistBlock("FA090MUL")
	Local lFina090  	:= ExistBlock("FINA090" )
	Local lFa090Tx    	:= ExistBlock("FA090TX" )
	Local lFa090Tit		:= ExistBlock("FA090TIT")
	Local lFa090Corr	:= ExistBlock("FA090COR")
	Local lF090SE5		:= Existblock("F090SE5")
	Local lF091Natur    := Existblock("F091NATUR")
	Local lAtuForn		:= SuperGetMv("MV_ATUFORN",.F.,.T.)
	Local lCtMovPa		:= SuperGetMv("MV_CTMOVPA",.T.,"1") == "2" // Indica se a Contabilizacao do LP513 ocorrer  pelo T¡tulo(SE2) ou Mov.Bancario(SE5) do Pagamento Antecipado. 1="SE2" / 2="SE5"
	Local lBxTxa 		:= SuperGetMv("MV_BXTXA",.F.,"1") == "1"
	Local lExistFJU 	:= FJU->(ColumnPos("FJU_RECPAI")) >0 .and. FindFunction("FinGrvEx")
	Local lJGrvBxPag 	:= FindFunction("JGrvBxPag")	//Integração SIGAPFS x SIGAFIN
	Local lBaixaMnt		:= SuperGetMv("MV_NGMNTFI",,"N") == 'S' .And. FindFunction( "NGBAIXASE2" )	//Integração Manutenção de Ativos
	Local lFKCodRet		:= (cPaisLoc == "BRA" .and. FK3->(FieldPos("FK3_CODRET")) > 0 .and. FK4->(FieldPos("FK4_CODRET")) > 0)
	Local lContrRet		:= (cPaisLoc == "BRA")
	Local lEAIF080		:= FWHasEAI("FINA080",.T.,,.T.)
	Local lMvCheques    := Type('MVCHEQUES')=='C'
	Local lChqMotBx		:= ChqMotBx(cMotBx)
	Local lContinua		:= .T.
	Local llOpc			:= .F.
	
	Local cMvCheques	:= IIF(lMvCheques,MVCHEQUES,MVCHEQUE)
	Local cArquivo		:= ""
	Local cNumero		:= ""
	Local cPrefixo		:= ""
	Local cParcela		:= ""
	Local cFornece		:= ""
	Local cSeqFRF		:= ""
	Local cChaveFK7 	:= ""
	Local cCamposIR		:= ""
	Local cCamposPCC	:= ""
	Local cChaveCH		:= ""
	Local cIdFK4		:= ""
	Local cIdFk4IR		:= ""
	Local cBanco 		:= ""
	Local cAgencia		:= ""
	Local cConta		:= ""
	Local cTpDesc		:= "2"
	Local cTpDescSE5	:= "I"
	Local cModSpb		:= "1"
	Local cTitOrig		:= ""
	Local cChaveSE5		:= ""
	Local cRecPag		:= "P"
	Local cChavePai		:= ""
	Local cChaveTit 	:= ""	//Dados da tabela auxiliar com o código do título a pagar
	Local cNatIss		:= ""
	Local cE5TABORI		:= ''
	LOCAL cE5IDORIG		:= ''
	Local cCodRet		:= ""
	Local cSequencia 	:= Replicate("0",TamSX3("E5_SEQ")[1])
	Local cE5_Histor 	:= CRIAVAR("E5_HISTOR") // Historico retornado pelo PE FA090SE5
	Local cBcoTit		:= CRIAVAR("E5_BANCO")
	Local cAgeTit		:= CRIAVAR("E5_AGENCIA")
	Local cCtaTit		:= CRIAVAR("E5_CONTA")
	Local cChqTit		:= CRIAVAR("E5_NUMCHEQ")
	Local cCheque		:= CRIAVAR("E5_NUMCHEQ")
	Local cBordAnt 		:= Space(6)
	Local cFilCorr 		:= cFilAnt
	Local cLiberado		:= IIf(SuperGetMv("MV_LIBCHEQ")=="S","S"," ")

	Local aSE5Baixado	:= {}
	Local aTitBaixado	:= {}
	Local aSE2Pagant	:= {}
	Local aRegCtBor		:= {}	// Array com os recnos de Fornecedor e Banco para contabilizacao Bordero/Bordero
	Local aDiario		:= {}
	Local aColsSEV		:= {}
	Local aGrvLctPco 	:= {{"000006","02","FINA090"}, {"000006","03","FINA090"}}
	Local aFlagCTB		:= {}
	Local aRecSE2		:= {}
	Local aArea			:= {}	
	Local aAreaSEA		:= {}
	Local aRec090Se5	:= {}	
	Local aTitCalc		:= {}
	Local aImpostos		:= {}
	Local aPCC      	:= {}
	Local aAreaSE52		:= {}
	Local aCodRet		:= {}
	Local aOutImp		:= {}
	Local aEaiRet := {}

	Local oModelBxP		:= Nil	//Model de baixas a pagar
	Local oSubFK2		:= NIL	//BAIXAS A PAGAR - Model Baixa
	Local oSubFK3		:= NIL	//IMPOSTOS CALCULADOS - Model Baixa
	Local oSubFK4		:= NIL	//IMPOSTOS RETIDOS - Model Baixa
	Local oSubFK5		:= NIL	//MOVTO BANCARIO - Model Baixa
	Local oSubFK6		:= NIL	//VALORES COMPLEMENTARES - Model Baixa
	Local oSubFKA		:= NIL	//TABELA DE RASTREIO - Model Baixa
	Local oModelMov		:= Nil 	//Model de Movimento bancario
	Local oSubFKAM		:= NIL	//TABELA DE RASTREIO - Model de Movimento bancario
	Local oSubFK5M		:= NIL	//MOVTO BANCARIO - Model Movimento Bancario

	Local dDtLanc		:= dDataBase
	Local lFK4CLIFOR	:= FK4->(FieldPos("FK4_CLIFOR")) > 0
	Local cMV_PISNAT 	:= SuperGetMV("MV_PISNAT")
	Local cMV_COFINS	:= SuperGetMV("MV_COFINS")
	Local cMV_CSLL		:= SuperGetMV("MV_CSLL")
	Local cMV_ISS		:= &(GetMv("MV_ISS"))
	Local cFilOriCtb	:= ""

	PRIVATE cMFilial	:= ""

	DEFAULT lF090Auto	:= .F.
	DEFAULT nTipoBx		:= 1
	DEFAULT lPCCBaixa	:= .F.
	DEFAULT lMovBcoBx	:= .F.
	DEFAULT cPadrao		:= "530"
	DEFAULT lPadrao		:= .F.
	DEFAULT cCheq090	:= ""
	DEFAULT cBenef090	:= ""
	DEFAULT cNatur090	:= ""
	DEFAULT cHistor090	:= ""
	DEFAULT lUsaFlag	:= SuperGetMV("MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
	DEFAULT lSpbInUse	:= SpbInUse()
	DEFAULT lAtuSldBco	:= SuperGetMv("MV_ATUSLBC",.F.,.T.) 
	DEFAULT lMultNat	:= .F.
	DEFAULT cFilBaixa	:= cFilAnt
	DEFAULT lCheque		:= .F.
	DEFAULT cDescrMo	:= ""
	DEFAULT nTotAger	:= 0
	DEFAULT lGerTotal 	:= .F.
	DEFAULT aVendor		:= {}
	DEFAULT __dLastPcc	:= CTOD("22/06/2015")
	DEFAULT __lFinVDoc	:= GetNewPar("MV_FINVDOC","2") == "1" //Controle de validacao de documentos obrigatorios
	DEFAULT __cMVCARTEIR:= GetMv("MV_CARTEIR")
	DEFAULT __lUsaPCO	:= SuperGetMV("MV_PCOINTE",.F.,"2") =="1"
	DEFAULT __nMVMCUSTO	:= Val(GetMv("MV_MCUSTO"))
	DEFAULT __lMVBXAUTVE:= SuperGetMv("MV_BXAUTVE",.F.,.F.)
	DEFAULT __nTamHist	:= TamSx3("E5_HISTOR")[1]
	DEFAULT __lTemMR	:= FTemMotor()
	DEFAULT __lFKDBx	:= ExistFunc("FAtuFKDBx")
	DEFAULT __lFINA095	:= IsInCallStack("FINA095")
	DEFAULT __cLayout	:= FWSM0Layout()
	DEFAULT __lGestao	:= "E" $ __cLayout .Or. "U" $ __cLayout
	DEFAULT __cFilSE2	:= IIF( __lGestao , FwFilial("SE2") , xFilial("SE2") )
	DEFAULT __cFilSEF	:= IIF( __lGestao , FwFilial("SEF") , xFilial("SEF") )
	DEFAULT __cFilSA6	:= IIF( __lGestao , FwFilial("SA6") , xFilial("SA6") )
	DEFAULT __cFilSEK	:= IIF( __lGestao , FwFilial("SEK") , xFilial("SEK") )
	DEFAULT __cFilSED	:= IIF( __lGestao , FwFilial("SED") , xFilial("SED") )
	DEFAULT __cFilSA2	:= IIF( __lGestao , FwFilial("SA2") , xFilial("SA2") )

	If __lSX8
		ConfirmSX8()
	Endif

	If lPCCBaixa .and. dBaixa >= __dLastPcc .And. !lEmpPub
		nVlMinImp	:= 0
	EndIf

	cTpDescSE5 := If( mv_par06 == 1 , "C" , "I")
	cTpDesc	   := cValToChar(mv_par06)

	dbSelectArea(cAliasSE2)
	(cAliasSE2)->(dbGoTop())

	Valor      := 0		//TOTAL DAS BAIXAS
	Valor2     := 0		//TOTAL DOS ABATIMENTOS (por titulo)
	ABATIMENTO := 0

	dbSelectArea("SE2")
	nTotAGer := 0
	cBordAnt := Space(6)
	nValorCheq	:= 0

	BEGIN TRANSACTION
		(cAliasSE2)->(dbSetOrder(__nIdxE2OK))

		(cAliasSE2)->(dbSeek(cMarca))
		SE2->(dbGoto((cAliasSE2)->NUM_REG))

		While (cAliasSE2)->(!Eof()) .And. (cAliasSE2)->E2_OK == cMarca
			SE2->(dbGoto((cAliasSE2)->NUM_REG))
			
			//A gravação da E5_FILIAL = se a SA6 EXCLUSIVA gravar a Filial do BANCO, se SA6 Compartilhada gravar a Filial do TÍTULO
			cFilant := IIF(!EMPTY(__cFilSA6),cFilAnt,SE2->E2_FILORIG)
			cFilOriCtb := SE2->E2_FILORIG

			//Restaura o valor padrao
			lIRPFBaixa	:= .F.
			lBord240	:= (nTipoBx==2 .And. cBordAnt==SE2->E2_NUMBOR)

			If SE2->E2_MOEDA > 1
				nTxMoedBx := If(SE2->E2_TXMOEDA > 0, SE2->E2_TXMOEDA,RecMoeda(dBaixa, SE2->E2_MOEDA))
			Else
				nTxMoedBx := 0
			EndIf

			If SE2->E2_OK == cMarca
				IF nTipoBx == 2 .and. cBordAnt != SE2->E2_NUMBOR   //Baixas de bordero
					cBordAnt := SE2->E2_NUMBOR
					SEA->(dbSetOrder(4))

					If SEA->(dbSeek(SE2->E2_FILORIG + SE2->(E2_NUMBOR+"P"+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA), .F.))

						lBord240:=(Alltrim(SEA->EA_ORIGEM)=='FINA240')

						SA6->(dbSetOrder(1))

						If Empty( __cFilSA6 )
							cMFilial := xFilial("SA6")
						Else
							If Empty( __cFilSE2 )
								cMFilial := xFilial("SA6")
							Else
								cMFilial := SE2->E2_FILIAL
							EndIf
						EndIf

						SA6->(dbSeek(cMFilial+SEA->EA_PORTADO+SEA->EA_AGEDEP+SEA->EA_NUMCON))
					Else
						Help(" ",1,"BORDERO",,STR0119 + cBordAnt + STR0120,1,0) //"Nao é possivel realizar a baixa de pagamento antecipado sem movimentação bancária."
						aAreaBKPSE2 := GETAREA()
						dbSelectArea("SE2")
						SE2->(dbSetOrder(2))
						RESTAREA(aAreaBKPSE2)
						DisarmTransaction()
						lContinua := .F.
						EXIT
					Endif
					dbSelectArea(cAliasSE2)
				EndIf

				If lContinua
					If cPaisLoc != 'BRA' .And. !Empty(E2_ORDPAGO) .And. E2_TIPO $ cMvCheques .And. !(E2_TIPO $ MVPROVIS+"/"+MVRECANT+"/"+MV_CRNEG+"/"+MVENVBCOR)
						SEK->(DbSetOrder(1))

						If Empty( __cFilSEK )
							cMFilial := xFilial("SEK")
						Else
							If Empty( __cFilSE2 )
								cMFilial := xFilial("SEK")
							Else
								cMFilial := SE2->E2_FILIAL
							EndIf
						EndIf

						If SEK->(DbSeek(cMFilial+SE2->E2_ORDPAGO+"CP"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO)) .And. (IIF(cPaisLoc $"ARG|PAR|CHI|URU",.F.,Empty(SEK->EK_DOCREC)))
							(cAliasSE2)->(DbSkip())
							Loop
						Endif
					Endif

					//Ponto de Entrada - para confirmacao da baixa
					If lFa090Tit
						lRet	:= ExecBlock("FA090TIT",.F.,.F.,{cBco090,cAge090,cCta090,cCheq090})
						If !lRet
							(cAliasSE2)->(dbSkip())
							nY++		//Controle da baixa automatizada
							Loop
						EndIf
					Endif

					//Posiciona no Cadastro de Naturezas
					SED->(dbSetOrder(1))
					SED->(dbSeek(xFilial("SED",SE2->E2_FILORIG)+SE2->E2_NATUREZ))
					SA2->(dbSetOrder(1))
					SA2->(MSSeek(xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA)))

					If Empty( __cFilSED )
						cMFilial := xFilial("SED")
					Else
						If Empty( __cFilSE2 )
							cMFilial := xFilial("SED")
						Else
							cMFilial := SE2->E2_FILIAL
						EndIf
					EndIf

					__nBasLeg := 0

					//Motor de retenções
					If __lTemMR
						F090VldImp(.F.)
					EndIf

					lCalcPccBx := .F.
					lIRPFBaixa := .F.
					lAplMinP := .F.
					lCalcIssBx := .F.
					lIsTitPA := SE2->E2_TIPO $ MVPAGANT

					If !__lPccMR .And. lPccBaixa .And. cPaisLoc == "BRA"	
						//Verifico se a combinacao Cliente x Natureza calcula PCC
						If SA2->A2_TIPO == 'J'.and. ;
							((SED->ED_CALCCSL == "S" .and. SA2->A2_RECCSLL == "2") .or. ;
								(SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2") .or. ;
								(SED->ED_CALCPIS == "S" .and. SA2->A2_RECPIS  == "2") )

							lCalcPccBx := .T.
						EndIf
					EndIf

					lIRPFBaixa := !__lIrfMR .And. cPaisLoc == "BRA" .And. SA2->A2_CALCIRF == "2" .and. SED->ED_CALCIRF == "S" .and. !lIsTitPA

					lAplMinP := SA2->(ColumnPos('A2_MINPUB')) > 0 .And. SA2->A2_MINPUB == "2"

					lCalcIssBx := !__lIssMR .AND. IsIssBx("P")

					dbSelectArea("SE2")
					nRegAtu     := SE2->(RecNo())
					nSaldo		:= SE2->E2_SALDO
					nSaldoCru	:= Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoedaBco,,3,If(cPaisLoc == "BRA",SE2->E2_TXMOEDA,0)),3),2)
					nValorTotal += nSaldoCru
					cNumero		:= SE2->E2_NUM
					cPrefixo	:= SE2->E2_PREFIXO
					cParcela	:= SE2->E2_PARCELA
					cFornece	:= SE2->E2_FORNECE
					nTotAbat	:= 0
					nTotAbtF	:= 0   // Abatimento na moeda do titulo
					nMoeda		:= 2
					nJuros		:= 0
					nDescont	:= 0
					nVA			:= 0
					nMulta   	:= 0

					fa080Juros(nMoedaBco)

					nVA := FValAcess( SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NATUREZ, .T. ,, "P", dDatabase, , SE2->E2_MOEDA )					

					nCorrec		:= fa090Correc( )
					nAcresc     := Round(NoRound(xMoeda(SE2->E2_SDACRES,SE2->E2_MOEDA,nMoedaBco,,3,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0)),3),2)
					nDecresc    := Round(NoRound(xMoeda(SE2->E2_SDDECRE,SE2->E2_MOEDA,nMoedaBco,,3,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0)),3),2)
					nPis		:= 0
					nCofins		:= 0
					nCsll		:= 0
					nValPgto	:= 0
					nIrrf		:= 0
					lAplVlMin	:= .T.
					nIss		:= 0
					nBaseIrpf	:= 0
					lBaixaPA    := SE2->E2_TIPO $ MVPAGANT
					lCtbIncPA   := lBaixaPA .And. AllTrim(SE2->E2_LA) == "S"
					lGerPAMov	:= .F.
					nInss		:= 0
					nDescCalc 	:= 0
					nJurosCalc 	:= 0
					nVACalc		:= 0
					nMultaCalc 	:= 0
					nCorrCalc	:= 0
					nDifCboCalc	:= 0
					nImpSubCalc	:= 0
					nPisCalc	:= 0
					nCofCalc	:= 0
					nCslCalc	:= 0
					nIrfCalc	:= 0
					nIssCalc	:= 0
					nPisBaseR 	:= 0
					nCofBaseR	:= 0
					nCslBaseR 	:= 0
					nIrfBaseR 	:= 0
					nIssBaseR 	:= 0
					nPisBaseC 	:= 0
					nCofBaseC 	:= 0
					nCslBaseC 	:= 0
					nIrfBaseC 	:= 0
					nIssBaseC 	:= 0
					nRecSE2		:= SE2->(RecNo())
					//Dados da tabela auxiliar com o código do título a pagar
					cChaveTit := xFilial("SE2",SE2->E2_FILORIG) + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM + "|" + SE2->E2_PARCELA + "|" + SE2->E2_TIPO + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
					cChaveFK7 := FINGRVFK7("SE2", cChaveTit)

					f090LRatIR(.T.) // Limpa objeto __oRatIRF IR Progressivo

					If (ALLTRIM(SE2->E2_ORIGEM) $ "FINA667|FINA677")
						FINATURES(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA),.T.,SE2->E2_ORIGEM,"P")
					Endif

					If SE2->E2_APLVLMN == "2"
						lAplVlMin := .F.
					Endif

					If lPadrao .And. nTipoBx != 2
						lPadrao := (cCtBaixa $ "BA" .Or. !lMovBcoBx .Or.(lMovBcoBx .And. !lChqMotBx))

						If !lPadrao .And. cCtBaixa $ "C" .And. !Empty(cCheq090) .And. SubStr(cCheq090, 1, 1 ) != "*" .And. SE2->E2_IMPCHEQ != "S"
							lPadrao := .T.
						EndIf
					Endif

					lPadAux := lPadrao

					If lFa090Desc
						nDescont := Execblock("FA090DES",.F.,.F.)
					Endif

					If lFa090Juros
						nJuros := Execblock("FA090JUR",.F.,.F.)
					Endif

					If lFa090Mult
						nMulta := Execblock("FA090MUL",.F.,.F.)
					Endif

					If lFa090Corr
						nCorrec := Execblock("FA090COR",.F.,.F.)
					Endif

					//Verifica se existe cheque sobre titulo e busca os dados do cheque para gravacao no SE5
					If SE2->E2_IMPCHEQ == "S" .AND. !(cPaisloc != "BRA" .and. __lFINA095)
						SEF->(dbSetOrder(3))

						If Empty( __cFilSEF )
							cMFilial := xFilial("SEF")
						Else
							If Empty( __cFilSE2 )
								cMFilial := xFilial("SEF")
							Else
								cMFilial := SE2->E2_FILIAL
							EndIf
						EndIf

						If DbSeek(cMFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO)
							WHILE !(SEF->(EOF())) .And. (cMFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO ==  SEF->EF_FILIAL + SEF->EF_PREFIXO+SEF->EF_TITULO+SEF->EF_PARCELA+SEF->EF_TIPO)
								IF Empty(SEF->EF_SEQUENC) .and. SEF->EF_FORNECE+SEF->EF_LOJA == SE2->E2_FORNECE+SE2->E2_LOJA
									cBcoTit	:=SEF->EF_BANCO
									cAgeTit	:=SEF->EF_AGENCIA
									cCtaTit	:=SEF->EF_CONTA
									cChqTit	:=SEF->EF_NUM
									EXIT
								Endif
								SEF->(DbSkip())
							ENDDO
						Endif
					EndIf

					//Baixar titulos de abatimento se for baixa total
					If Select("__SE2") == 0
						ChkFile("SE2",.F.,"__SE2")
					Else
						DbSelectArea("__SE2")
					EndIf

					__SE2->(dbSetOrder(1))
					__SE2->(dbSeek(xFilial("SE2")+cPrefixo+cNumero+cParcela))

					While !__SE2->(EOF()) .And. __SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA) == (xFilial("SE2") + cPrefixo+cNumero+cParcela)
						If __SE2->E2_TIPO $ MVABATIM .And. __SE2->E2_FORNECE == cFornece
							nTotAbat += Round(NoRound(xMoeda(__SE2->E2_SALDO, __SE2->E2_MOEDA, nMoedaBco, Nil, 3, If(cPaisLoc == "BRA", __SE2->E2_TXMOEDA,0)), 3), 2)
							nTotAbtF += __SE2->E2_SALDO
							nValorTotal -= nTotAbat

							RecLock("__SE2")
							Replace E2_SALDO	With 0
							Replace E2_BCOPAG	With cBco090
							Replace E2_BAIXA	With dBaixa
							Replace E2_LOTE		With cLoteFin
							Replace E2_MOVIMEN	With dBaixa
							Replace E2_SDACRES	With 0
							Replace E2_SDDECRE	With 0
						Endif

						__SE2->(dbSkip())
					Enddo

					dbSelectArea("SE2")
					SE2->(dbGoto(nRegAtu))

					If !Empty(SE2->E2_NUMBOR)
						lRetBor := VLDBOR(SE2->E2_NUMBOR, "P", SE2->E2_FILORIG)
					Endif

					nValPgto	:= nSaldoCru - nTotAbat + nJuros + nVa + nMulta - nDescont + nAcresc - nDecresc - __nImpMR
					nValPgto	-= If(!__lPccMR .AND. lPccBaixa  .AND. nTipoBx == 1,(nPis+nCofins+nCsll),0)
					nValPgto	-= If(!__lIrfMR .AND. lIRPFBaixa .AND. nTipoBx == 1,nIrrf,0)
					nValPgto	-= If(!__lIssMR .AND. lCalcIssBx .AND. nTipoBx == 1,nIss ,0)
					nOldValPgto	:= nValPgto

					//--------------------------------------------------------------------
					// ISS
					//--------------------------------------------------------------------
					If !__lIssMR .and. lCalcIssBx .and. !lIsTitPA .and. (Empty(SE2->E2_NUMBOR) .or. (!Empty(SE2->E2_NUMBOR) .AND. lRetBor))
						F080IssBx()
					Endif

					//--------------------------------------------------------------------
					// IRRF
					//--------------------------------------------------------------------
					nOldValPgto := nValPgto
					nIRRF       := 0

					If !__lIrfMR .And. lIRPFBaixa .And. (nTipoBx == 1 .or. (nTipoBx == 2 .And. "FINA240" $ SEA->EA_ORIGEM)) .And. !( "MATA100" $ SE2->E2_ORIGEM .And. Empty( SE2->E2_BASEIRF ) .And. Empty( SE2->E2_IRRF ) )					
						//----------------------------------------------------------------------------------------
						// Calculo do IR para baixa de títulos ou baixa de borderô sem impostos (FINA240)
						//----------------------------------------------------------------------------------------
						nIRRF := FCalcIRBx(0,SA2->A2_TIPO,dBaixa,dDebito,/*lAltValor*/,/*nTxmoeda*/,cMotBx)

					ElseIf !__lIrfMR .And. lIRPFBaixa .And. nTipoBx == 2 .And. ("FINA241" $ SEA->EA_ORIGEM) .And. !Empty( SE2->E2_BASEIRF )
						//------------------------------------------------------------------------------------------------------------------------------------
						// O bordero de impostos controla a retenção, mas no momento da baixa precisa gravar o campo E5_BASEIRF para cenários de cumulatividade
						// Gravação ocorrerá na montagem dos campos do SE5 dentro de FGRVSFQIR()
						//------------------------------------------------------------------------------------------------------------------------------------
						nBaseIrpf := SE2->E2_BASEIRF
					EndIf
					//--------------------------------------------------------------------
					// PCC
					//--------------------------------------------------------------------
					nVlRetPis := 0
					nVlRetCof := 0
					nVlRetCsl := 0

					If SE2->E2_PIS <> 0 .AND. SE2->E2_COFINS <> 0.AND. SE2->E2_CSLL <> 0 .AND. nVlRetPis==0 .AND. nVlRetCof==0 .AND. nVlRetCsl==0 .AND. !Empty(SE2->E2_NUMBOR)
						nVlRetPis := SE2->E2_PIS
						nVlRetCof := SE2->E2_COFINS
						nVlRetCsl := SE2->E2_CSLL
					Endif
					aAreaSEA := SEA->(GetArea())

					//Valida se já houve retenção no borderô.
					lBord241 := If(__lPccMR, __lPccBxMR, lPCCBaixa) .And. lContrRet .And.; 
									!Empty(SE2->E2_NUMBOR) .And. ( SE2->E2_PRETPIS == '4' .OR. SE2->E2_PRETCOF == '4' .OR. SE2->E2_PRETCSL == '4') 


					aTitCalc := {}
					
					If !__lPccMR .And. !lBord241 .And. cPaisLoc == "BRA" .And. lPccBaixa .And. lCalcPccBx .And. !lIsTitPA .And. VLDBOR(SE2->E2_NUMBOR,"P",cFilAnt)
						If (dBaixa < __dLastPcc .Or. lEmpPub)
							f080TotMes(dBaixa,.T.,,.F.)
						Else
							If Empty(__nBasLeg)
								nSalTit := salRefPag(SE2->E2_FORNECE+SE2->E2_LOJA)
							Else
								nSalTit := __nBasLeg
							EndIf

							nSalTit  += F080JuMuDe()

							aPCC := newMinPcc(dBaixa, nSalTit, SE2->E2_NATUREZ, "P", SE2->(E2_FORNECE + E2_LOJA),nIss,nInss,nIRRF, /*lMin*/, /*lIgnrOrg*/, cMotBx )

							If aPCC[1]
								nPis 	:= aPCC[2]
								nCofins := aPCC[3]
								nCsll   := aPCC[4]
								If len(aPCC)>4
									aTitCalc := aPCC[5]
								Endif
							Endif
						EndIf
					Endif

					If !lEmpPub
						nTotARet := If(!__lPccMR, (nPis+nCofins+nCsll), 0) + If(!__lIrfMR, nIrrf, 0)
					Endif

					nDiferImp := nValPgto - nTotARet
					If nDiferImp < 0
						aOutImp := {}

						If !__lPccMR
							aAdd(aOutImp, {"PIS", nPis })
							aAdd(aOutImp, {"COF", nCofins })
							aAdd(aOutImp, {"CSL", nCsll })
						EndIf

						If !__lIrfMR .And. lIRPFBaixa
							aAdd(aOutImp, {"IRF", nIrrf })
						EndIf

						If !__lIssMR .And. lCalcIssBx .And. nIss == 0
							aAdd(aOutImp, {"ISS", (SE2->E2_ISS - SE2->E2_VRETISS) })
						EndIf

						aDadosPar := verVrAR(nValPgto, aOutImp )
						If !__lPccMR
							nPis    := aDadosPar[1]
							nCofins := aDadosPar[2]
							nCsll   := aDadosPar[3]
						EndIf
					Endif
					RestArea(aAreaSEA)

					If !!__lIrfMR .And. lEmpPub .And. lAplMinP .And. lIRPFBaixa .And. (nPis+nCoFins+nCsll+nIrrf+aDadosRet[2]+aDadosRet[3]+aDadosRet[4]+aDadosRet[5] < nVlMPub .And.;
						!(aDadosRet[2]+aDadosRet[3]+aDadosRet[4]+aDadosRet[5] == 0 .And. aDadosRet[1] > 0))
						nPis := nCoFins := nCsll := nIrrf := 0
					EndIf

					nValPgto	:= nSaldoCru - nTotAbat + nJuros + nVa + nMulta - nDescont + nAcresc - nDecresc - __nImpMR
					nValPgto	-=  If(!__lPccMR .AND. lPccBaixa .AND. !lBord241,(nPis+nCofins+nCsll),0)
					nValPgto	-=  If(!__lIrfMR .AND. lIRPFBaixa .AND. !lBord241,nIrrf,0)
					nValPgto	-=  If(!__lIssMR .AND. lCalcIssBx .AND. lRetBor,nIss ,0)
					nOldValPgto := nValPgto

					If !__lInsMR
						nInss	:= SE2->E2_INSS
					Endif

					If !__lIssMR .AND. !lIRPFBaixa .And. SA2->A2_TIPO == "J" .And. !lIsTitPA
						If nIrrf == 0
							nIrrf	:= SE2->E2_IRRF
						Endif
					Endif

					dbSelectArea( "SE2" )

					If !__lPccMR .And. !__lIrfMR .And. !lPccBaixa .And. !lIRPFBaixa .and. !lIsTitPA
						//Atualiza a data de vencimento dos titulos de impostos
						AltVencImp(dDataBase)

						//Altera valor dos impostos
						F080Impost(SE2->(RECNO()),.F.,nJuros,nMulta,nDescont,nSaldoCru - nTotAbat + nJuros + nVA + nMulta - nDescont + nAcresc - nDecresc, nVA)
					Endif

					nJuros   := nJuros   + nAcresc
					nDescont := nDescont + nDecresc

					//caso o titulo de PA nao tenha movimento, não deve baixar
					IF lBaixaPA
						aAreaSE52:= getarea()
						SE5->(DbSetOrder(7))
						cChaveSE5 := SE2->(E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO + E2_FORNECE + E2_LOJA) + SPACE(TAMSX3("E5_SEQ")[1])

						//verifica se PA possui movimentacao bancaria
						nRecPAInc := F080MovPA(.T.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)

						If nRecPAInc == 0
							lBaixaPA := .F.
							lGerPAMov := .T.
						Endif

						If lGerPAMov
							cPadrao := "513"
							lPadrao := !lCtbIncPA .And. lCtMovPa .And. MV_PAR03 == 1 .And. VerPadrao(cPadrao)
						EndIf

						RestArea(aAreaSE52)
					EndIf

					If lGerPAMov
						nGerPAMov++
					EndIf

					//Atualiza a Baixa do Titulo
					If !lGerPAMov .and. (!(SE2->E2_TIPO $ MVTXA+"#"+MVPAGANT+"#"+"INA") .Or. (SE2->E2_TIPO $ MVTXA+"#"+MVPAGANT .and. lBxTxa) .or. lBaixaPA)
						RecLock("SE2")
						SE2->E2_OK	:= "  "

						//Verifico se existe data baixa indicando alguma baixa no título a pagar
						lDtBaixa := .T.

						If EMPTY(SE2->E2_BAIXA)
							lDtBaixa := .F.
						EndIf

						SE2-> E2_BAIXA	 := iif(SE2->E2_BAIXA <= dDatabase, dDatabase, SE2->E2_BAIXA)
						SE2-> E2_VALLIQ	 := nValPgto
						SE2-> E2_SALDO	 := 0
						SE2-> E2_MOVIMEN := SE2->E2_BAIXA
						SE2-> E2_BCOPAG	 := cBco090
						SE2-> E2_LOTE	 := Iif(lBxCnab,cLoteFin,'')
						If !Empty(SE2->E2_PORTADO)
							SE2-> E2_BCOPAG	:= E2_PORTADO
						EndIf

						SE2-> E2_JUROS		:= nJuros
						SE2-> E2_CORREC		:= nCorrec
						SE2-> E2_DESCONT	:= nDescont
						SE2-> E2_MULTA		:= nMulta
						SE2-> E2_SDACRES	:= 0
						SE2-> E2_SDDECRE	:= 0

						If Empty(SE2->E2_NUMBCO) .And. !Empty(cCheq090)
							SE2->E2_NUMBCO   := cCheq090
						Endif

						If lContrRet .And. !__lPccMR .AND. lPCCBaixa .And. lBord241
							nOldRetPis := SE2->E2_VRETPIS
							nOldRetCof := SE2->E2_VRETCOF
							nOldRetCsl := SE2->E2_VRETCSL
						EndIf

						//Marco que o titulo tem os impostos calculados pela baixa (Pis, Cofins e Csll)
						If lContrRet .And. !__lPccMR .AND. lPCCBaixa
							//Nao alterar o valor dos PRET do PCC caso o mesmo tenha sido retido pelo FINA241
							If (SE2->E2_PRETPIS == "4" .OR. SE2->E2_PRETCOF == "4" .OR. SE2->E2_PRETCSL == "4")  .Or. (nPis+nCofins+nCsll>0)
								SE2->E2_PRETPIS := "3"
								SE2->E2_PRETCOF := "3"
								SE2->E2_PRETCSL := "3"
							EndIf
							//Gravo os valores de impostos retidos neste titulo
							SE2->E2_VRETPIS += nPis
							SE2->E2_VRETCOF += nCofins
							SE2->E2_VRETCSL += nCsll
						Endif

						// Atualiza o saldo da natureza. O valor jah esth liquido dos abatimentos, desta forma nao precisa atualizar na baixa dos abatimentos
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_BAIXA, SE2->E2_MOEDA, "3", "P", nValPgto, xMoeda(nValPgto,SE2->E2_MOEDA,1,SE2->E2_BAIXA,,,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0)), If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"-","+"),,FunName(),"SE2",SE2->(Recno()),0)

						//Na baixa de títulos em bordero, os campos de controle de retenção de IR não precisam ser alterados.
						If !__lIrfMR .AND. lIRPFBaixa .And. nTipoBx == 1
							If !Empty( SE2->E2_PRETIRF ) .And. nIrrf > 0
								SE2->E2_PRETIRF := " "
							EndIf

							If SA2->A2_TIPO == "F"
								SE2->E2_IRRF += nIRRF
							EndIf

							SE2->E2_VRETIRF += nIrrf
						EndIf

						//Array para Vendor ou Contabilizar bordero totalizando por bordero
						If Ascan(aTitBaixado,{|X| x[1] == SE2->(Recno())}) = 0
							Aadd(aTitBaixado, {SE2->(Recno()),SE2->E2_NUMBOR} )
						Endif

						//Verifica se existe solicitacao de NCP e caso exista atualiza o campo CU_DTBAIXA...
						If cPaisLoc <> "BRA"
							A055AtuDtBx("1",SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NUM,SE2->E2_PREFIXO,SE2->E2_BAIXA)
							If Upper(Left(SE2->E2_NUMBCO,5))=="CJCC_"
								Fa550CJCC(Substr(SE2->E2_NUMBCO,6),"A")
							Endif
						EndIf

						//PE para controlar novas taxas financeiras
						If lFa090Tx
							Execblock("FA090TX",.F.,.F.)
						Endif

						MsUnlock()
						FA373Bx(.T.)
					ElseIf !lBxTxa .and. SE2->E2_OK <> 'TA'
						RecLock("SE2")
						SE2->E2_OK = 'TA'
						MsUnlock()
					Endif

					If cPaisLoc =="BRA"

						//Processo Normal (nao automatizado)
						If !lF090Auto

							If nTipoBx == 1  //Baixa Titulos
								lCheque := ChqMotBx(cMotBx)
							Else //Bordero
								lCheque := (nTipoBx == 2 .and. ChqMotBx(cMotBx))
							Endif

							//--------------------------------------------------------------
							// Caso gere movimento de baixa aglutinadora igual a Bx Lote 
							//--------------------------------------------------------------
							//nTipoBx = 2 -> Bordero
							//lBxCnab -> Gera totalizador quando baixa CNAB
							//mv_par04 = 2 -> Gera cheque automaticamente
							//lMovBcoBx .and. !ChqMotBx(cMotBx) -> Movimenta banco sem cheque
							lGerTotal := IIf((nTipoBx == 2 .and. lBxCnab .and. lMovBcoBx .and. (mv_par04 == 2 .or. !ChqMotBx(cMotBx)) ), .T.,.F.)

							// Caso banco seja Caixa, nao deve gerar cheque 
							If	nTipoBx == 2 .and. ((Substr(SEA->EA_PORTADO,1,2) == "CX" .and. lMovBcoBx) .or. (SEA->EA_PORTADO $ __cMVCARTEIR .and. lMovBcoBx))
								lCheque := .F.
								lIsCaixa := .T.
							Endif

							//Baixa de titulos em banco caixa deve gerar movimento bancario sem cheque
							//ainda que o motivo de baixa exija
							If	nTipoBx == 1 .and. ((Substr(cBco090,1,2) == "CX" .and. lMovBcoBx) .or. (cBco090 $ __cMVCARTEIR .and. lMovBcoBx))
								lCheque := .F.
								lGerTotal := IIf(lBxCnab,.T.,.F.)
								lIsCaixa := .T.
							Endif
						Else
							//Processo automatizado
							lCheque := IIF((!Empty(cCheq090) .and. ChqMotBx(cMotBx)),.T., IIF( ChqMotBx(cMotBx),.T.,.F.))

							//Caso gere cheque, o totalizador sera o cheque Caso não gere cheque e MV_BXCNAB = S, gera totalizador
							lGerTotal := lBxCnab .and. !lCheque .and. lMovBcoBx

							If !Empty(cCheq090) .and. ((Substr(cBco090,1,2) == "CX" .and. lMovBcoBx) .or.;
								(cBco090 $ __cMVCARTEIR .and. lMovBcoBx))
								lCheque := .F.
								lIsCaixa := .T.
							Endif
						Endif

						VAR_IXB := lCheque
					Endif

					lNewProc  := .T.

					//Baixa de PA ou geração de Mov do mesmo não gera novo processo, utiliza o processo criado na inclusão
					If lIsTitPA .AND. lGerPAMov
						FKA->(dbSetOrder(3))
						If FKA->(MsSeek(xFilial("FKA") + "SE2" + cChaveFK7))
							lNewProc := .F.
							BxGerMovPA(.T.)
							cE5TABORI := "SE2"
							cE5IDORIG := cChaveFK7
							FinSetAPrc("SE2")
						EndIf
					EndIf
					//Dados da tabela auxiliar com o código do título a pagar
					cIdFK2 	  := FWUUIDV4()
					cCamposE5 := ""
					aImpostos := {}

					//REESTRUTURACAO SE5
					//Carrego model de Bx Pagar
					If !lGerPaMov
						oModelBxP	:= FWLoadModel("FINM020")	//Model de baixas a pagar
						oModelBxP:SetOperation(MODEL_OPERATION_INSERT) //Inclusao
						oModelBxP:Activate()
						oModelBxP:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
						oModelBxP:SetValue( "MASTER", "NOVOPROC", lNewProc) //Novo processo
						oSubFK2  := oModelBxP:GetModel("FK2DETAIL")
						oSubFK3  := oModelBxP:GetModel("FK3DETAIL")
						oSubFK4  := oModelBxP:GetModel("FK4DETAIL")
						oSubFK5  := oModelBxP:GetModel("FK5DETAIL")
						oSubFK6  := oModelBxP:GetModel("FK6DETAIL")
						oSubFKA  := oModelBxP:GetModel("FKADETAIL")
						//Para numerar as sequencias o sistema precisa procurar os registros com  tipodoc igual a VL, BA ou CP.
						cSequencia := FaNxtSeqBx("SE2", .T.)
						nValorTotal -= __nImpMR
						nValorTotal -= If(!__lPccMR .And. lPccBaixa, nPis + nCofins + nCsll, 0)
						nValorTotal -= If(!__lIrfMR .And. lIRPFBaixa, nIrrf, 0)
						nValorTotal -= If(!__lIssMR .And. lCalcIssBx, nIss, 0)
						nValorTotal += nJuros
						nValorTotal += nMulta
						nValorTotal += nVA
						nValorTotal -= nDescont
						nValorSEF	:= SE2->E2_VALLIQ
					Else
						oModelBxP	:= FWLoadModel("FINM050")	//Model de gravação do PA
						oModelBxP:SetOperation(MODEL_OPERATION_INSERT) //Inclusao
						oModelBxP:Activate()
						oModelBxP:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
						oModelBxP:SetValue( "MASTER", "NOVOPROC", lNewProc) //Novo processo
						oSubFK5  := oModelBxP:GetModel("FK5DETAIL")
						oSubFKA  := oModelBxP:GetModel("FKADETAIL")
						cSequencia := ""
						nValorTotal -= nSaldoCru
						nValorSEF	:= IIF(SE2->E2_MOEDA > 1 .And. nMoedaBco == 1, SE2->E2_VLCRUZ, SE2->E2_VALOR)
					Endif

					If cPaisLoc=="BRA"
						IF !lIsTitPA .and. lCheque .and. lMovBcoBx .and. SE2->E2_IMPCHEQ != "S" .and. !lGerTotal
							cChaveCH := FWUUIDV4()
							SA2->(dbSetOrder(1))
							SA2->(MSSeek(xFilial("SA2", SE2->E2_FILORIG) + SE2->E2_FORNECE + SE2->E2_LOJA))

							//Gravacao do cheque do titulo
							RecLock("SEF",.T.)
							SEF->EF_FILIAL		:= xFilial("SEF",cFilAnt)
							SEF->EF_PORTADO 	:= SE2->E2_PORTADO
							SEF->EF_VALOR		:= nValorSEF
							SEF->EF_DATA		:= dDataBase
							SEF->EF_HIST		:= IIF((!Empty(cCheq090) .And. Substr(cCheq090,1,1) != "*" ),IIF(AllTrim(cHistor090) != "",cHistor090,SE2->E2_HIST), SE2->E2_HIST) //"Cheque por Bx. Automatica"
							SEF->EF_PREFIXO		:= SE2->E2_PREFIXO
							SEF->EF_TITULO		:= SE2->E2_NUM
							SEF->EF_PARCELA		:= SE2->E2_PARCELA
							SEF->EF_TIPO		:= SE2->E2_TIPO
							SEF->EF_FORNECE		:= SE2->E2_FORNECE
							SEF->EF_LOJA		:= SE2->E2_LOJA
							SEF->EF_ORIGEM		:= "FINA090"
							SEF->EF_SEQUENC		:= cSequencia
							SEF->EF_BANCO		:= cBco090
							SEF->EF_AGENCIA		:= cAge090
							SEF->EF_CONTA		:= cCta090
							SEF->EF_BENEF		:= SA2->A2_NOME
							SEF->EF_LIBER		:= cLiberado

							If !Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*"
								SEF->EF_NUM		:= cCheq090
								SEF->EF_LA      := Iif(mv_par04==1 .and. mv_par01==1 .and. lPadrao .and. ( cCtBaixa $ "BA") .and. !lUsaFlag,"S"," ")
								SEF->EF_IMPRESS := "A"
							Endif

							SEF->EF_FILORIG := SE2->E2_FILORIG
							SEF->EF_FILCHQ	:= cFilCorr
							SEF->EF_IDSEF	:= cChaveCH		//ID do cheque

							If !Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*"
								SEF->EF_NUM		:= cCheq090
								SEF->EF_LA      := Iif(mv_par03==1 .and. mv_par04==1 .and. lPadrao .and. ( cCtBaixa $ "BA") .and. !lUsaFlag,"S"," ")
								SEF->EF_IMPRESS := "A"
							Endif

							//Dados do movimento bancario do Cheque
							If !oSubFKA:IsEmpty()
								//Inclui a quantidade de linhas necessárias
								oSubFKA:AddLine()
								//Vai para linha criada
								oSubFKA:GoLine( oSubFKA:Length() )
							Endif

							//Dados do Cheque  //revisar
							oSubFKA:SetValue( 'FKA_IDORIG', cChaveCH )
							oSubFKA:SetValue( 'FKA_TABORI', 'SEF' )

							If lFa080Sef
								Execblock("FA080SEF",.f.,.f.)
							Endif

							MsUnlock()
						Endif
					Endif

					If !lIsTitPA			
						nTotaGer    += SE2->E2_VALLIQ
						nValorCheq  += IIF(SE2->E2_IMPCHEQ == "S",0,SE2->E2_VALLIQ)
					EndIf

					//Reestruturacao SE5
					nDescCalc 	:= nDescont
					nJurosCalc 	:= nJuros
					nVACalc	 	:= nVA
					nMultaCalc 	:= nMulta
					nCorrCalc	:= nCorrec

					//Grava registro referente a movimentação bancaria
					For nZ := 1 To 6
						//Atualiza a Movimentação Bancaria
						If nZ == 1
							nCpoTp  := SE2->E2_VALLIQ
							cTpDoc  := IIF(lCheque .or. lGerTotal	.Or. SE2->E2_IMPCHEQ == "S" .or. !lMovBcoBx ,"BA"	,"VL"	)

							//Se for baixa de um TXA e o mesmo nao deve zerar o saldo
							If (!lBxTxa .and. SE2->E2_TIPO $ MVTXA ) .or. SE2->E2_TIPO $ "INA"
								nCpoTp  := SE2->E2_VALOR
							Endif

							IF lGerPaMov
								nCpoTp  := IIF(SE2->E2_MOEDA > 1 .And. nMoedaBco == 1, SE2->E2_VLCRUZ, SE2->E2_VALOR)
								cTpDoc  := "PA"
							Else
								If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
									cTpDoc := Iif(MovBcoBx(cMotBx, .T.),"VL","BA")
								EndIf
							EndIf
							cHistMov	:= IIF(lMovBcoBx,STR0029,cDescrMo) // "Valor pago s /Titulo"
						Elseif nZ == 2
							nCpoTp   := nDescont
							cTpDoc   := "DC"
							cHistMov := STR0032 //"Desconto s/Receb.Titulo"
							nCpoCalc := nDescCalc
						Elseif nZ == 3
							nCpoTp   := nJuros
							cTpDoc   := "JR"
							cHistMov := STR0030 //"Juros s/Receb.Titulo"
							nCpoCalc := nJurosCalc
						Elseif nZ == 4
							nCpoTp   := nMulta
							cTpDoc   := "MT"
							cHistMov := STR0033 //"Multa s/Receb.Titulo"
							nCpoCalc := nMultaCalc
						Elseif nZ == 5
							nCpoTp   := nCorrec
							cTpDoc   := "CM"
							cHistMov := STR0031 //"Correcao Monet s/Receb.Titulo"
							nCpoCalc := nCorrCalc
						Elseif nZ == 6 				// VALORES ACESSÓRIOS
							nCpoTp	 := nVA
							cTpDoc	 := "VA"
							cHistMov := ""			//Valores Acessórios (histórico virá da FKD)
							nCpoCalc := nVACalc
						Endif

						If nCpoTp != 0 .or. nZ == 1

							If lF091Natur
								cNatur090 := ExecBlock("F091Natur",.F.,.F.)
							EndIf

							aArea := SED->(GetArea())
							If !Empty(cNatur090)								
								dbselectArea("SED")
								dbsetorder(1)
								If !DbSeek(xFilial("SED")+cNatur090)
									cNatur090 := FINNATMOV("P")
								Endif
							Else
								cNatur090 := FINNATMOV("P")
							EndIf
							RestArea(aArea)

							If !Empty(SE2->E2_NUMBOR)
								lPCC241 := RetPCC241( cSequencia, SE2->E2_NUMBOR)
							Endif

							cPrefixo := SE2->E2_PREFIXO

							If cPaisloc != "BRA" .AND. __lFINA095
								cNumChq	 :=	SE2->E2_NUMBCO
								cPrefixo :=	SE2->E2_PREFIXO
							Endif

							cRecPag := Iif( lBaixaPA , "R" , "P" )

							//Define os campos que não existem nas FKs e que serão gravados apenas na E5, para que a gravação da E5 continue igual
							If !Empty(cCamposE5)
								cCamposE5 += "|"
							Endif
							cCamposE5 += "{"
							cCamposE5 += " {'E5_DTDIGIT' , dDtDigit  }"
							cCamposE5 += ",{'E5_PREFIXO' , '"+cPrefixo +"'}"
							cCamposE5 += ",{'E5_NUMERO'  , '"+SE2->E2_NUM+"'}"
							cCamposE5 += ",{'E5_PARCELA' , '"+SE2->E2_PARCELA+"'}"
							cCamposE5 += ",{'E5_TIPO'    , '"+SE2->E2_TIPO+"'}"
							cCamposE5 += ",{'E5_FORNECE' , '"+SE2->E2_FORNECE+"'}"
							cCamposE5 += ",{'E5_CLIFOR'  , '"+SE2->E2_FORNECE+"'}"
							cCamposE5 += ",{'E5_LOJA'    , '"+SE2->E2_LOJA+"'}"
							cCamposE5 += ",{'E5_BENEF'   , '"+RemoveAsp(SE2->E2_NOMFOR)+"' }"
							cCamposE5 += ",{'E5_TPDESC'  , '"+ cTpDescSE5 +"' }"
							cCamposE5 += ",{'E5_RECPAG'  , '"+ cRecPag +"' }"
							cCamposE5 += ",{'E5_DOCUMEN' , '"+ SE2->E2_NUMBOR +"' }"

							If (__lIssMR .Or. lCalcIssBx)
								cCamposE5 += ",{'E5_VRETISS' , " + cValToChar(If(__lIssMR, __nIssMR, nIss)) + " }"
							Endif

							If cPaisLoc = "MEX"
								cCamposE5 += ",{'E5_BANCO' , '"+SE2->E2_BCOCHQ +"'}"
								cCamposE5 += ",{'E5_AGENCIA' , '"+SE2->E2_AGECHQ +"'}"
								cCamposE5 += ",{'E5_CONTA' , '"+SE2->E2_CTACHQ +"'}"
							EndIF

							//Movimento principal (baixa e banco)
							If nZ == 1
								//Valores acessorios no registro principal da baixa
								cCamposE5 += ",{'E5_VLJUROS' , "+cValToChar(nJuros)+" }"
								cCamposE5 += ",{'E5_VLMULTA' , "+cValToChar(nMulta)+" }"
								cCamposE5 += ",{'E5_VLCORRE' , "+cValToChar(nCorrec)+" }"
								cCamposE5 += ",{'E5_VLDESCO' , "+cValToChar(nDescont)+" }"
								cCamposE5 += ",{'E5_VLACRES' , "+cValToChar(nAcresc)+" }"
								cCamposE5 += ",{'E5_VLDECRE' , "+cValToChar(nDecresc)+" }"
								nValorSE5	:= nCpoTp
								dDataSE5	:= dBaixa

								If (cPaisLoc	!=	"BRA"  .And. SE5->E5_TIPODOC == "VL") .OR. (cPaisLoc == "ARG".and. __lFINA095)

									SA6->(DbSetOrder(1))

									If Empty( __cFilSA6 )
										cMFilial := xFilial("SA6")
									Else
										If Empty( __cFilSE2 )
											cMFilial := xFilial("SA6")
										Else
											cMFilial := SE2->E2_FILIAL
										EndIf
									EndIf

									SA6->(dbSetOrder(1))
									If !Empty(SE2->E2_BCOCHQ) .And. !Empty(SE2->E2_AGECHQ) .And. !Empty(SE2->E2_CTACHQ)
										SA6->(DbSeek(cMFilial+SE2->E2_BCOCHQ+SE2->E2_AGECHQ+SE2->E2_CTACHQ))
										nMoedaBco   := Max(IIf(SA6->A6_MOEDAP > 0,SA6->A6_MOEDAP,SA6->A6_MOEDA),1)
										nValorSE5	:= If(nMoedaBco	<>	SE2->E2_MOEDA,xMoeda(E5_VALOR,1,nMoedaBco),nSaldo )
										cBanco 		:= SE2->E2_BCOCHQ
										cAgencia	:= SE2->E2_AGECHQ
										cConta		:= SE2->E2_CTACHQ
									Else
										SA6->(DbSeek(cMFilial+cBco090+cAge090+cCta090))
										nMoedaBco   := Max(IIf(SA6->A6_MOEDAP > 0,SA6->A6_MOEDAP,SA6->A6_MOEDA),1)
										nValorSE5	:= If(nMoedaBco <>	SE2->E2_MOEDA,xMoeda(E5_VALOR,1,nMoedaBco),nSaldo )
										cBanco 		:= cBco090
										cAgencia	:= cAge090
										cConta		:= cCta090
									Endif
								Endif

								If lGerTotal
									cBanco   := cBco090
									cAgencia := cAge090
									cConta	 := cCta090

									If nTipoBx == 2 .And. !Empty( SEA->(EA_PORTADO+EA_AGEDEP+EA_NUMCON))
										cBanco   := cBco090 := SEA->EA_PORTADO
										cAgencia := cAge090 := SEA->EA_AGEDEP
										cConta	 := cCta090 := SEA->EA_NUMCON
									EndIf
								Endif

								If lFa090Se5
									cE5_HISTOR := Execblock("FA090SE5",.F.,.F., {cE5_Histor})
									If ValType(cE5_HISTOR) == "C"
										cHistor090 := Left(cE5_HISTOR,__nTamHist)
									EndIf
								Endif

								If cPaisLoc == "BRA"
									If !lCheque .and. lMovBcoBx .and. SE2->E2_IMPCHEQ != "S" .and. !lGerTotal
										cBanco   := cBco090
										cAgencia := cAge090
										cConta   := cCta090
									ElseIf SE2->E2_IMPCHEQ == "S"
										cBanco		:= cBcoTit
										cAgencia	:= cAgeTit
										cConta		:= cCtaTit
										cCheque		:= cChqTit
									ElseIf lCheque
										cBanco		:= cBco090
										cAgencia	:= cAge090
										cConta		:= cCta090
										If !(lIsTitPA .and. lGerPaMov) .and. !Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*"
											cCheque := cCheq090
										Endif
									Endif
								Endif

								If cPaisLoc != "BRA"
									cCamposE5 += ",{'E5_FILORIG', '" + SE2->E2_FILORIG  + "'}"
								EndIf

								cCamposE5 += ",{'E5_BANCO'   , '" + cBanco + "'}"
								cCamposE5 += ",{'E5_AGENCIA' , '" + cAgencia + "'}"
								cCamposE5 += ",{'E5_CONTA'   , '" + cConta + "'}"
								cCamposE5 += ",{'E5_DTDISPO' , STOD('" + DTOS(dDebito) + "')}"

								If cPaisLoc == "CHI"
									cCamposE5 += ",{'E5_ORDREC'   , '" + SE2->E2_ORDPAGO + "'}"
								Endif

								//Relacionamento FKA X FK2
								If !oSubFKA:IsEmpty()
									//Inclui a quantidade de linhas necessárias
									oSubFKA:AddLine()
									//Vai para linha criada
									oSubFKA:GoLine( oSubFKA:Length() )
								Endif

								If !lGerPaMov
									oSubFKA:SetValue( 'FKA_IDORIG', cIdFK2 )
									oSubFKA:SetValue( 'FKA_TABORI', "FK2" )
									//Dados da baixa a pagar
									oSubFK2:SetValue( "FK2_DATA"   , dDataSE5 )
									oSubFK2:LoadValue( "FK2_NATURE" , SE2->E2_NATUREZ )
									oSubFK2:SetValue( "FK2_RECPAG" , cRecPag )
									oSubFK2:SetValue( "FK2_HISTOR" , If(!Empty(cHistor090) .and. !(lIsTitPA .and. lGerPAMov) ,cHistor090,cHistMov) )
									oSubFK2:SetValue( "FK2_MOTBX"  , If(Empty(cMotBx),"NOR", TrazCodMot( cMotBx )) )
									oSubFK2:SetValue( "FK2_ORIGEM" , FunName() )
									oSubFK2:SetValue( "FK2_SEQ"    , cSequencia )
									oSubFK2:SetValue( "FK2_IDDOC"  , cChaveFK7 )
									oSubFK2:SetValue( "FK2_LOTE"   , cLoteFin )
									oSubFK2:SetValue( "FK2_TPDOC"  , cTpDoc )
									oSubFK2:SetValue( "FK2_CCUSTO" , SE2->E2_CCUSTO )
									oSubFK2:SetValue( "FK2_DOC"    , SE2->E2_NUMBOR )	// Vem do Fina240()

									If lGerTotal
										oSubFK2:SetValue( "FK2_ARCNAB" , Iif(lMovBcoBx,"FINA090","") )
									Endif

									oSubFK2:SetValue( "FK2_FILORI" ,SE2->E2_FILORIG )
									oSubFK2:SetValue( "FK2_AUTBCO" ,"" )
									oSubFK2:SetValue( "FK2_MOEDA"  ,StrZero(nMoedaBco, 2))
									oSubFK2:SetValue( "FK2_VLMOE2" ,Round(xMoeda(nCpoTp, nMoedaBco,SE2->E2_MOEDA,SE2->E2_BAIXA,4,,nTxMoedBx),2))
									oSubFK2:SetValue( "FK2_VALOR"  ,nValorSE5 )
									oSubFK2:SetValue( "FK2_TXMOED" ,nTxMoedBx )
									oSubFK2:SetValue( "FK2_LOTE"   , cLoteFin )
									oSubFK2:SetValue( "FK2_LA"     , If( lPadrao .and. mv_par03 == 1 .and. !lUsaFlag, "S", "N" ) )

									//Gravo Marca da MultNat
									If SE2->E2_MULTNAT == "1" .and. lMultNat
										oSubFK2:SetValue( "FK2_MULNAT" , "1" )
									Else
										oSubFK2:SetValue( "FK2_MULNAT" , "2" )
									EndIf

									If __lTemMR
										nImpos := Len(__aImpMR)
										For nX := 1 To nImpos
											If lFKCodRet .and. Len(__aImpMR[nX])>=23
												cCodRet :=  __aImpMR[nX,23]
											Else
												cCodRet := ""
											EndIf
											aAdd(aImpostos,{__aImpMR[nX,8], __aImpMR[nX,3], __aImpMR[nX,10], "", __aImpMR[nX,5], __aImpMR[nX,2], __aImpMR[nX,4], __aImpMR[nX,1],SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, cCodRet})
										Next nX
									EndIf

									If !__lIrfMR .And. lIRPFBaixa .And. nIrfBaseC > 0
										If lFKCodRet
											cCodRet := SE2->E2_CODRET
										Else 
											cCodRet := ""
										Endif
										//Rateio IRPF progressivo
										If __oRatIRF == Nil .OR. Empty(__oRatIRF:aRatIRF)
											aAdd(aImpostos,{"IRF", nIrfCalc, &(SuperGetMV("MV_IRF")), "", nIrrf, nIrfBaseC, nIrfBaseR, "", SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, cCodRet})
										Else
											For nX := 1 To Len(__oRatIRF:aRatIRF)
												If __oRatIRF:aRatIRF[nX][6] != 0
													aAdd(aImpostos,{"IRF", __oRatIRF:aRatIRF[nX][6], &(SuperGetMV("MV_IRF")), "", __oRatIRF:aRatIRF[nX][6], __oRatIRF:aRatIRF[nX][5], __oRatIRF:aRatIRF[nX][5], "", SA2->A2_COD, SA2->A2_LOJA, __oRatIRF:aRatIRF[nX][3], cCodRet})
												EndIf
											Next nX
										EndIf
									EndIf

									If !__lPccMR .And. lContrRet .and. lPccBaixa .And. (nPisCalc+nCofCalc+nCslcalc) > 0
										aCodRet := getCodRet()
										If nPisCalc > 0 .And. nPisBaseC > 0
												aadd(aImpostos,{"PIS", nPisCalc ,cMV_PISNAT,"", nPis, nPisBaseC, nPisBaseR, '', SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, aCodRet[1]})
										EndIf

										If nCofCalc > 0 .And. nCofBaseC > 0
												aadd(aImpostos,{"COF", nCofCalc ,cMV_COFINS,"", nCofins, nCofBaseC, nCofBaseR, '', SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, aCodRet[2]})
										EndIf

										If nCslcalc > 0 .And. nCslBaseC > 0
												aadd(aImpostos,{"CSL", nCslcalc ,cMV_CSLL  ,"", nCsll, nCslBaseC, nCslBaseR, '', SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, aCodRet[3]})
										EndIf
									EndIf
									cCodRet := ""
									If !__lIssMR .And. lCalcIssBx .And. nIssBaseC > 0 .And. nIssCalc > 0
										aadd(aImpostos,{"ISS",nIssCalc,cMV_ISS,"", nIss, nIssBaseC, nIssBaseR,'', SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, cCodRet})
									EndIf

									//Grava FK3 E/OU FK4
									For nX := 1 to Len(aImpostos)
										//Gravar FK4 se os valores de PCC forem maiores que zero
										If aImpostos[nX][2] > 0 .OR. (lIRPFBaixa .AND. aImpostos[nX,1] == "IRF")
											cIdFK4 := ""

											If aImpostos[nX][5] > 0   //Houve retencao
												cIdFK4:= FINFKSID('FK4', 'FK4_IDFK4')
												aImpostos[nX,4] := cIdFK4

												If __lTemMR .And. nX <= nImpos
													__aImpMR[nX,6] := cIdFK4
												EndIF

												//Guardo o IDFK4 do IRF para usar posteriormente
												If aImpostos[nX,1] == "IRF"
													cIdFk4IR := cIdFK4
												Endif
											Endif

											If !oSubFK3:IsEmpty()
												oSubFK3:AddLine()
												oSubFK3:GoLine( oSubFK3:Length() )
											Endif

											// Grava Imposto calculado
											oSubFK3:SetValue( "FK3_IDFK3" , GetSx8Num('FK3', 'FK3_IDFK3'))
											oSubFK3:SetValue( "FK3_DATA"  , dDataBase )
											oSubFK3:SetValue( "FK3_ORIGEM", FunName() )
											oSubFK3:SetValue( "FK3_IMPOS" , aImpostos[nX,1] )
											oSubFK3:SetValue( "FK3_RECPAG", cRecPag )
											oSubFK3:SetValue( "FK3_MOEDA" , "01" )
											oSubFK3:SetValue( "FK3_VALOR" , aImpostos[nX,2] )
											oSubFK3:LoadValue( "FK3_NATURE", aImpostos[nX,3] )
											oSubFK3:SetValue( "FK3_FILORI", SE2->E2_FILORIG  )
											oSubFK3:SetValue( "FK3_BASIMP", aImpostos[nX,6] )
											oSubFK3:SetValue( "FK3_IDORIG", cIdFK2 )
											oSubFK3:SetValue( "FK3_TABORI", "FK2")
											oSubFK3:SetValue( "FK3_IDRET" , aImpostos[nx,4] )

											If lFKCodRet
												oSubFK3:SetValue( "FK3_CODRET" , aImpostos[nX,12] )
											EndIf

											If __lTemMR
												oSubFK3:SetValue( "FK3_CODFKM", aImpostos[nX,8] )
												oSubFK3:SetValue( "FK3_CLIFOR", aImpostos[nX,9] )
												oSubFK3:SetValue( "FK3_LOJA"  , aImpostos[nX,10] )
												oSubFK3:SetValue( "FK3_CGC"   , aImpostos[nX,11] )
												oSubFK3:SetValue( "FK3_RAICGC", Substr(aImpostos[nX,11], 1, 8) )

												If SE2->E2_MOEDA > 1
													oSubFK3:SetValue("FK3_VLMOE2", Round(xMoeda(aImpostos[nX][2],nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1,If(cPaisLoc == "BRA", SE2->E2_TXMOEDA, 0)),2))
												Else
													oSubFK3:SetValue("FK3_VLMOE2", aImpostos[nX][2])
												EndIf
											Endif

											// Grava Imposto Retido
											If aImpostos[nX][5] > 0   //Houve retencao
												If !oSubFK4:IsEmpty()
													oSubFK4:AddLine()
													oSubFK4:GoLine( oSubFK4:Length() )
												Endif

												oSubFK4:SetValue( "FK4_IDFK4" , aImpostos[nx,4])
												oSubFK4:SetValue( "FK4_DATA"  , dDataBase )
												oSubFK4:SetValue( "FK4_ORIGEM", FunName() )
												oSubFK4:SetValue( "FK4_IMPOS" , aImpostos[nx,1] )
												oSubFK4:SetValue( "FK4_RECPAG", cRecPag )
												oSubFK4:SetValue( "FK4_MOEDA" , "01" )
												oSubFK4:SetValue( "FK4_VALOR" , aImpostos[nX,5] )
												oSubFK4:LoadValue( "FK4_NATURE", aImpostos[nX,3])
												oSubFK4:SetValue( "FK4_FILORI", SE2->E2_FILORIG )
												oSubFK4:SetValue( "FK4_BASIMP", aImpostos[nX,7] )
												If lFK4CLIFOR
													oSubFK4:SetValue( "FK4_CLIFOR", aImpostos[nX,9] )
													oSubFK4:SetValue( "FK4_LOJA"  , aImpostos[nX,10] )
												EndIf
												If lFKCodRet
													oSubFK4:SetValue( "FK4_CODRET" , aImpostos[nx,12] )
												EndIf
												If __lTemMR
													oSubFK4:SetValue( "FK4_CODFKM", aImpostos[nX,8] )
													oSubFK4:SetValue( "FK4_CGC"   , aImpostos[nX,11] )
													oSubFK4:SetValue( "FK4_RAICGC", Substr(aImpostos[nX,11], 1, 8) )
													If SE2->E2_MOEDA > 1
														oSubFK4:SetValue("FK4_VLMOE2", Round(xMoeda(aImpostos[nX,5],nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1,If(cPaisLoc == "BRA", SE2->E2_TXMOEDA, 0)),2))
													Else
														oSubFK4:SetValue("FK4_VLMOE2", aImpostos[nX,5])
													EndIf

													If nX <= nImpos .And. Len(__aImpMR[nX,7]) > 0 .And. __aImpMR[nX,7,1] > 0
														FK3->(DbGoTo(__aImpMR[nX,7,1]))
														RecLock("FK3")
														FK3->FK3_IDRET := __aImpMR[nX,6]
														FK3->(MsUnlock())
													EndIf
												Endif
											Endif
										Endif
									Next

									For nx:= 1 to len(aTitCalc)
										FINGFK3BOR(2,aTitCalc[nx,1],aTitCalc[nx,2],aImpostos,.F.)
									Next

									If !__lIrfMR .AND. lIRPFBaixa
										FGRVSFQIR(nIrrf,nBaseIrpf,aDadosIr,cSequencia,@cCamposIR,cIdFk4IR)
										cCamposE5 += cCamposIr
									Endif

									If ((!__lPccMR .And. lContrRet .And. lPccBaixa) .Or. __lPccBxMR)
										If (dBaixa < __dLastPCC  .Or. lEmpPub)
											FGRVSFQPCC(aImpostos,aDadosRet,cSequencia,@cCamposPCC, @lRetParc, lIRPFBaixa, lAplVlMin, nVlMinImp, lPCC241)
											cCamposE5 += cCamposPCC
										Else
											cCamposE5 += ",{'E5_VRETPIS' , " + cValToChar(If(__lPccMR, __nPisMR, nPis)) + " }"
											cCamposE5 += ",{'E5_VRETCOF' , " + cValToChar(If(__lPccMR, __nCofMR, nCofins)) + " }"
											cCamposE5 += ",{'E5_VRETCSL' , " + cValToChar(If(__lPccMR, __nCslMR, nCsll)) + " }"
										Endif
									EndIf

									//Gravo os titulos de impostos Pis Cofins Csll quando controlados pela baixa - EXCETO PA
									If !lIsTitPA .AND. ((lContrRet .and. lPccBaixa .and. lRetParc) .or. (lCalcIssBx .and. nIss > 0) .OR. (lIRPFBaixa .AND. nIrrf > 0))
										If !(lRet := FGrvImpPcc(@nPis,@nCofins,@nCsll,nRegAtu,.F.,lRetParc,cSequencia,"FINA090",SE2->E2_MOEDA,,nIrrf,nIss,,,,,,,,,,IIF(__oRatIRF <> Nil,__oRatIRF:aRatIRF,Nil)))
											lContinua := .F.
											DisarmTransaction()
											Break
										EndIf
									Endif
								Endif	

								If cTpDoc $ "VL|PA"	//Se movimenta banco
									//Relacionamento FKA X FK5
									If !oSubFKA:IsEmpty()
										oSubFKA:AddLine()
										oSubFKA:GoLine( oSubFKA:Length() )
									Endif

									oSubFKA:SetValue( 'FKA_IDORIG', FWUUIDV4() )
									oSubFKA:SetValue( 'FKA_TABORI', "FK5" )

									//MOVIMENTO BANCARIO
									oSubFK5:SetValue( "FK5_RECPAG" , cRecPag )
									oSubFK5:SetValue( "FK5_HISTOR" , If(!Empty(cHistor090) .and. !(lIsTitPA.and. lGerPAMov) ,cHistor090,cHistMov) )
									oSubFK5:SetValue( "FK5_DATA"   , dDataSE5 )
									oSubFK5:SetValue( "FK5_DTDISP" , dDataSE5 )
									oSubFK5:LoadValue( "FK5_NATURE" , SE2->E2_NATUREZ )
									oSubFK5:SetValue( "FK5_BANCO"  , cBanco )
									oSubFK5:SetValue( "FK5_AGENCI" , cAgencia )
									oSubFK5:SetValue( "FK5_CONTA"  , cConta )
									oSubFK5:SetValue( "FK5_NUMCH"  , If(!lIsTitPA,cCheque,"") )		
									oSubFK5:SetValue( "FK5_SEQ"    , cSequencia )
									oSubFK5:SetValue( "FK5_MOEDA"  , StrZero(nMoedaBco,2) )
									oSubFK5:SetValue( "FK5_VALOR"  , nValorSE5 )
									oSubFK5:SetValue( "FK5_VLMOE2" , Round(xMoeda(nValorSE5,nMoedaBco,SE2->E2_MOEDA,SE2->E2_BAIXA,4,,nTxMoedBx),2))
									oSubFK5:SetValue( "FK5_ORIGEM" , FunName() )
									oSubFK5:SetValue( "FK5_TPDOC"  , cTpDoc )
									oSubFK5:SetValue( "FK5_CCUSTO" , SE2->E2_CCUSTO )
									oSubFK5:SetValue( "FK5_FILORI" , SE2->E2_FILORIG )
									oSubFK5:SetValue( "FK5_TXMOED" , If(SE2->E2_MOEDA > 1,nTxMoedBx, 0)  )
									oSubFK5:SetValue( "FK5_LA"     , If( lPadrao .and. mv_par03 == 1 .and. !lUsaFlag, "S", "N" ) )
									oSubFK5:SetValue( "FK5_LOTE"   , cLoteFin )
									oSubFK5:SetValue( "FK5_IDDOC"  , If(lIsTitPA,cChaveFK7,"") )		
									oSubFK5:SetValue( "FK5_MODSPB" , If(lSpbInUse, cModSpb, "" ) )

									If lGerPaMov
										cCamposE5 += ",{'E5_MOTBX'  , '"+ If(Empty(cMotBx),"NOR", TrazCodMot( cMotBx )) +"'}"
									EndIf

								Else
									cCamposE5 += ",{'E5_BANCO'   , '"+cBanco   +"' }"
									cCamposE5 += ",{'E5_AGENCIA' , '"+cAgencia +"' }"
									cCamposE5 += ",{'E5_CONTA'   , '"+cConta   +"' }"
									cCamposE5 += ",{'E5_NUMCHEQ' , '"+cCheque  +"' }"
									cCamposE5 += ",{'E5_DTDISPO' , STOD('" + DTOS(dDebito) + "')}"
								Endif

							Else	// Valores acessorios

								If	oSubFKA:SeekLine({{'FKA_TABORI',"FK2"}})
									If cTpDoc == "VA" .and. nVA != 0
										FSetFK6FKD(oSubFK6,cChaveFK7,cIdFK2)
									Else

										If !oSubFK6:IsEmpty()
											oSubFK6:AddLine()
											oSubFK6:GoLine( oSubFK6:Length() )
										Endif

										//Grava Valores acessórios (juros, multas, descontos etc)
										oSubFK6:SetValue( "FK6_VALMOV" , nCpoTp )
										oSubFK6:SetValue( "FK6_VALCAL" , nCpoCalc )
										oSubFK6:SetValue( "FK6_TPDESC" , cTpDesc )
										oSubFK6:SetValue( "FK6_TPDOC"  , cTpDoc )
										oSubFK6:SetValue( "FK6_RECPAG" , cRecPag )
										oSubFK6:SetValue( "FK6_IDORIG" , cIdFK2 )
										oSubFK6:SetValue( "FK6_TABORI" , "FK2" )
										oSubFK6:SetValue( "FK6_HISTOR" , cHistMov )
									Endif
								Endif
							Endif

							If __lFINA095
								nOrderSEF:=SEF->(IndexOrd())
								SEF->(DbSetOrder(6))
								If SEF->(DbSeek(xFilial("SEF")+"P"+SE2->E2_BCOCHQ+SE2->E2_AGECHQ+SE2->E2_CTACHQ+SUBSTR(IIf(Alltrim(SE2->E2_ORIGEM) == "FINA550", SE2->E2_NUM,SE2->E2_NUMBCO),1,TamSX3("EF_NUM")[1])+SE2->E2_PREFIXO))
									RecLock("SEF",.F.)
									SEF->EF_DATAPAG	:= dDataBase
									SEF->EF_REFTIP	:= "LP"
									SEF->EF_STATUS	:= "04"
									SEF->EF_BENEF	:=	SE2->E2_NOMFOR
									If !(cPaisLoc=="ARG")
										SEF->EF_HIST	:=	cHistor090
									Endif
									SEF->(MsUnLock())
									DbSelectArea("FRF")
									cSeqFRF := GetSx8Num("FRF","FRF_SEQ")
									RecLock("FRF",.T.)
									FRF->FRF_FILIAL	 := xFilial("FRF")
									FRF->FRF_BANCO	 := SEF->EF_BANCO
									FRF->FRF_AGENCIA := SEF->EF_AGENCIA
									FRF->FRF_CONTA	 := SEF->EF_CONTA
									FRF->FRF_NUM	 := SEF->EF_NUM
									FRF->FRF_PREFIX	 := SEF->EF_PREFIXO
									FRF->FRF_CART	 := "P"
									FRF->FRF_DATPAG	 :=	dDataBase
									FRF->FRF_MOTIVO	 := "10"
									FRF->FRF_DESCRI	 := "CHEQUE LIQUIDADO"
									FRF->FRF_SEQ	 := cSeqFRF
									FRF->FRF_FORNEC	 := SEF->EF_FORNECE
									FRF->FRF_LOJA	 := SEF->EF_LOJA
									FRF->FRF_NUMDOC	 := SEF->EF_ORDPAGO
									FRF->(MsUnLock())
									ConfirmSX8()
									SEF->(DbSetOrder(nOrderSEF))
								Endif
							Endif

							If !Empty(cCamposE5)
								cCamposE5 += "}"
							Endif

						Endif
					Next nZ
					//Encerro a gravacao da Baixa (oModelBxP)
					If lRet
						FWModelActive(oModelBxP)
						oModelBxP:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )

						//Grava os dados
						If oModelBxP:VldData()
							oModelBxP:CommitData()

							//Obtenho o recno do SE5 - Movimento principal (VL/BA)
							nRegPrinc := oModelBxP:GetValue("MASTER","E5_RECNO")
							SE5->(dbGoTo(nRegPrinc))
							AADD(aSE5Baixado,nRegPrinc)
							AADD(aRec090Se5,nRegPrinc)

							If lNewProc
								cE5TABORI := SE5->E5_TABORI
								cE5IDORIG := SE5->E5_IDORIG
							EndIf

							If !lBaixaPA .And. lGerPAMov
								AADD(aSE2Pagant,nRegAtu)
							Endif
							
							//Grava o lançamento de integração com o SIGAPCO
							If __lUsaPCO
								PcoDetLan("000006","01","FINA090")
							Endif

							If lF90Se5Grv
								ExecBlock("F90SE5GRV")
							Endif

							//Atualiza o saldo bancario quando movimento bancario gerado baixa a baixa
							If lAtuSldBco
								If SE5->E5_TIPODOC $ "VL|PA"
									AtuSalBco(cBanco,cAgencia,cConta,dDataSE5,nValorSE5,If(SE5->E5_RECPAG == 'P','-','+'))
								Endif
							EndIf

							//-----------------------------------------------------------
							// Valores Acessorios.
							//-----------------------------------------------------------
							If __lFKDBx
								FAtuFKDBx( .F., "P" )
							EndIf

							//Integração SIGAPFS x SIGAFIN
							If lRet .And. lJGrvBxPag

								lRet := JGrvBxPag(SE2->(RECNO()), 3, SE5->(RECNO()))

								If !lRet
									DisarmTransaction()
									Break
								EndIf
							EndIf
						Else
							lRet := .F.
							cLog := cValToChar(oModelBxP:GetErrorMessage()[4]) + ' - '
							cLog += cValToChar(oModelBxP:GetErrorMessage()[5]) + ' - '
							cLog += cValToChar(oModelBxP:GetErrorMessage()[6])
							Help( ,,"M020VLDI5",,cLog, 1, 0 )
							DisarmTransaction()
							Break
						Endif
					Else
						DisarmTransaction()
						Break
					Endif

					oModelBxP:DeActivate()
					oModelBxP:Destroy()
					oModelBxP := Nil
					FinSetAPrc("")

					//Gravação FK3/FK4 dos impostos via conf Motor Retenção
					If __lTemMR .And. lRet .And. !lGerPAMov
						If lIsTitPA
							FMRDelImp(cE5TABORI, cE5IDORIG)
							cE5TABORI := ""
							cE5IDORIG := ""
						ElseIf Len(__aImpMR) > 0
							FinGrvImp("1", SE2->(Recno()),__aImpMR,"FINA090",.F., {}, {},.F.,.F.,.T./*eh Baixa*/,dBaixa,"FK2",cSequencia,,SE2->E2_FILORIG)
						EndIf
					EndIf

					//Caso a retenção ocorreu na inclusão do pagamento antecipado efetua a exclusão dos títulos de impostos
					If !__lIrfMR .And. lIsTitPA .And. !lGerPAMov .and. SE2->E2_IRRF > 0
						F241DelTxIR("FINA080",SE2->(Recno()),SE2->E2_IRRF)
					EndIf

					If (lContrRet .and. lIsTitPA .And. (SE2->(E2_PIS + E2_COFINS + E2_CSLL) > 0 .Or. SE2->E2_ISS > 0))
						lPAMov := .F.

						//verifica se PA possui movimentacao bancaria
						nRecPAInc := F080MovPA(.T.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)

						If  nRecPAInc > 0
							SE5->(DBGoto(nRecPAInc))
							lPAMov := .T.
						EndIf

						//verifica se PA possui registro de inclusao
						nRecPAInc := F080MovPA(.F.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)

						If	nRecPAInc > 0
							SE5->(DBGoto(nRecPAInc))
							lPAMov := .T.
						EndIf

						If 	lPAMov .And. !lGerPAMov
							aRecSE5 := FImpDelTit("SE5",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)
							nRecSe5 := SE5->(Recno())

							For nY := 1 to Len(aRecSE5)
								SE5->(MSGoto(aRecSE5[nY]))
								RecLock("SE5",.F.)

								//Se nao reteve somente IRRF
								If 	(!Empty(SE5->E5_PRETPIS) .And. !Empty(SE5->E5_PRETCOF) .And. !Empty(SE5->E5_PRETCSL)) .and. SE5->E5_MOTBX <> "CMP"
									SE5->E5_PRETPIS := "1"
									SE5->E5_PRETCOF := "1"
									SE5->E5_PRETCSL := "1"
								Endif

								MsUnlock()
							Next

							//Exclui os registros de relacionamentos do SFQ
							SE5->(dbGoto(nRecSe5))
							FImpDelSFQ("SE5",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)
							aRecSE2 := FImpExcTit("SE2",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA)

							For nY := 1 to Len(aRecSE2)
								SE2->(MSGoto(aRecSE2[nY]))
								FaAvalSE2(4)
							Next

							//Exclui os registros de relacionamentos do SFQ
							SE5->(dbGoto(nRecSe5))
							FImpExcSFQ("SE2",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA)

							FDelTxBx(SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ,SE2->E2_PARCPIS,SE2->E2_PARCCOF,SE2->E2_PARCSLL)

							IF IsIssBx("P") .And. EMPTY(SE2->E2_NUMBOR) .And. SE2->E2_VRETISS != 0
								//Apaga tambem os registro de impostos-ISS
								SE5->(dbGoto(nRecSe5))
								SE2->(dbGoTo(nRecSE2))

								dbSelectArea("SE2")
								dbSetOrder(17)

								cChavePai := SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
								cChavePai := PadR(cChavePai, nTamTitPai)

								If MsSeek(xFilial("SE2") + cChavePai)

									cNatIss	:= AllTrim(F090GetNat("MV_ISS"))

									While !Eof() .And. E2_FILIAL+E2_TITPAI == xFilial("SE2") + cChavePai
										IF E2_TIPO $ MVISS .And. ;
											AllTrim(E2_NATUREZ) == cNatIss .And. ;
											STR(SE2->E2_SALDO,17,2) == STR(SE2->E2_VALOR,17,2) .and. ;
											(AllTrim(SE2->E2_ORIGEM) $ "FINA050|FINA080|FINA090|FINA091") .and. ;
											SE5->E5_SEQ == SE2->E2_SEQBX 
											If lExistFJU
												FinGrvEx("P")
											Endif

											RecLock( "SE2" ,.F.,.T.)
											dbDelete( )
										EndIf

										dbSkip()
									Enddo
								Endif
							EndIf

							SE5->(dbGoto(nRecSe5))

						EndIf
					Endif

					//Atualiza o Cadastro de Fornecedores
					dbSelectArea("SA2")
					If Empty( __cFilSA2 )    //Multi-Filial
						cMFilial := xFilial("SA2")
					Else
						If Empty( __cFilSE2 )
							cMFilial := xFilial("SA2")
						Else
							cMFilial := SE2->E2_FILIAL
						EndIf
					EndIf

					If !dbSeek(cMFilial+SE2->E2_FORNECE+SE2->E2_LOJA) .And. !Empty(xFilial("SA2"))
						//executará quando o forn estiver em filial diferente
						lAchouFor := dbSeek(xFilial("SA2", SE2->E2_FILORIG)+SE2->E2_FORNECE+SE2->E2_LOJA)
					else
						lAchouFor := .T.
					EndIf

					If lAtuForn .and. lAchouFor
						RecLock("SA2")
						nSalDup := xMoeda(nSaldo-nTotAbtF,SE2->E2_MOEDA,nMoedaBco,SE2->E2_EMISSAO,,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0))
						SA2->A2_SALDUP	-=	nSalDup
						SA2->A2_SALDUPM	-= xMoeda(nSaldo-nTotAbtF,SE2->E2_MOEDA,;
						__nMVMCUSTO,SE2->E2_EMISSAO,,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0))
						MsUnlock()
					Endif

					//Verifica qual o Lanc Padrao que sera utilizado
					dbSelectArea("SE2")

					VALOR2     := nTotAbat		// Valor para contabilizar
					ABATIMENTO := nTotAbat

					If cPaisLoc = "BRA" .And. lPccBaixa .And. lBord241					
						Reclock("SE2")
						SE2->E2_VRETPIS := nOldRetPis
						SE2->E2_VRETCOF := nOldRetCof
						SE2->E2_VRETCSL := nOldRetCsl
						MsUnlock()
					EndIf

					SA6->(DbSetOrder(1))
					SA6->(DbSeek(xFilial()+cBco090+cAge090+cCta090))

					// Baixa por bordero e totalizacao bordero a bordero
					If lPadrao .and. mv_par03==1 .and. nTipoBX == 2 .and. mv_par05 == 2 .and. !lGerPAMov
						AAdd( aRegCtBor, { SE2->(Recno()), SA2->(Recno()), SA6->(Recno()) , F090RcSE5(aSE5Baixado) } )
					EndIf

					If cPAISLOC $ "PER|DOM|BOL"
						nBaseITF := SE5->E5_VALOR
					EndIf

					//Rateio de Multi Naturezas/Centro de Custos
					If lMultNat .And. SE2->E2_MULTNAT == "1"
						If cPaisLoc <> "BRA"
							If !(cPaisLoc $ "BOL" ) .And. FinProcITF( nRecnSE5,1 )
								FinProcITF( nRecnSE5,3,nBaseITF, .F.,{} ,  )
							EndIf
						
							If cPaisLoc $ "BOL" .And. FinProcITF(  SE5->( Recno()),1 )
								FinProcITF(  SE5->( Recno()),3,nBaseITF, .F.,{} ,  )
							EndIf
						EndIf
						MultNatB("SE2", .F., "1", @lOk, @aColsSEV, @lMultNat, .T.)

						If lOk
							MultNatC("SE2" /*cAlias*/, @nHdlPrv /*@nHdlPrv*/, @nTotal /*@nTotal*/, @cArquivo /*@cArquivo*/, (mv_par03 == 1) /*lContabiliza*/, .T. /*lBxLote*/,;
							"1" /*cReplica*/, nTotLtEZ /*nTotLtEZ*/, lOk /*lOk*/, aColsSEV /*aCols*/, .T. /*lBaixou*/, aGrvLctPco /*aGrvLctPco*/, lUsaFlag /*lUsaFlag*/, @aFlagCTB /*@aFlagCTB*/)
						Endif
					Else
						If (cCtBaixa == "C" .And. lCheque .and. lMovBcoBx .And. MV_PAR04 == 1) .Or. ;
							(cCtBaixa $"B|A") .Or. (TrazCodMot(cMotBx) $ "VEN/DEB") .or. (MovBcoBx(cMotBx, .T.) .and. ;
							!ChqMotBx(cMotBx)) .or. lGerPAMov
							
							If nHdlPrv == 0 .And. lPadrao .And. MV_PAR03 == 1
								nHdlPrv := HeadProva( cLote, "FINA090" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo )
							EndIf

							If	lPadrao .And. mv_par03 == 1 .And. !(nTipoBx = 2 .And. mv_par05 == 2 .And. !lGerPAMov)
								dbSelectArea("SE5")
								SE5->(dbGoTo(nRegPrinc))

								If UsaSeqCor()
									AaDd(aDiario, {"SE5", SE5->(Recno()), cCodDiario, "E5_NODIA", "E5_DIACTB"})
								EndIf

								If cPaisLoc <> "BRA"
									If  !(cPaisLoc $ "BOL") .And. FinProcITF( nRecnSE5,1 )
										FinProcITF( nRecnSE5,3,nBaseITF, .F.,{nHdlPrv,cPadrao,"FINA090","FINA090",cLote} ,  )
									ElseIf  cPaisLoc $ "BOL" .And. FinProcITF( SE5->( Recno()),1 )
										FinProcITF( SE5->( Recno()),3,nBaseITF, .F.,{nHdlPrv,cPadrao,"FINA090","FINA090",cLote} ,  )
									EndIf
								EndIf

								If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
									aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
									If lGerPaMov
										aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
									EndIf
								Endif

								nTotal += F090DetPro(nHdlPrv,cPadrao,"FINA090",cLote,,,,@aFlagCTB,cFilCorr,cFilOriCtb)
							EndIf
						Else
							If cPaisLoc <> "BRA"
								If FinProcITF( SE5->( Recno() ),1 )
									FinProcITF( SE5->( Recno() ),3,nBaseITF, .F.,{} ,  )
								EndIf
							EndIf
						EndIf
					EndIf

					dbSelectArea("SE2")

					If lFina090
						Execblock("FINA090",.f.,.f.)
					Endif

					If FWHasEAI("FINA080",.T.,,.T.)
						FwIntegDef( 'FINA080' )
					Endif

					// Integração EAI.
					If lEAIF080
						llOpc  := ALTERA
						ALTERA := .T.  // Baixa de título.

						aEaiRet := FWIntegDef('FINA080',,,, 'FINA080')
						If !aEaiRet[1]
							Help(" ", 1, "HELP", STR0174, STR0175 + CRLF + aEaiRet[2], 3, 1)  // "Erro EAI" / "Problemas na integração EAI. Transação não executada."
							DisarmTransaction()
							Break
						Endif

						ALTERA := llOpc
					Endif

					IF __lFinVDoc
						CN062ValDocs("03",.F.,.T.)
					EndIf
				EndIf

				dbSelectArea("SE2")

				If lBaixaMnt
					// Função que atualiza a TRX  - Multa (Integração SIGAFIN - SIGAMNT).
					NGBAIXASE2( 1 )
				EndIf

			Endif

			(cAliasSE2)->(dbSkip())
			SE2->(dbGoto((cAliasSE2)->NUM_REG))

			//	Define data da contabilização on line
			Do Case 
				Case nDtContOn == 1 // 1- Data Digitação
					dDtLanc := dDtDigit
				Case nDtContOn == 2 // 2- Data Disponibilizadade
					dDtLanc := dDebito
				Case nDtContOn == 3 // 3- Data Pagamento
					dDtLanc := dBaixa
			EndCase

			If nHdlPrv > 0 .And. nTotal > 0 .And. mv_par03 == 1; 
				.and. (cFilAnt <> SE2->E2_FILORIG .OR. cBordAnt <> SE2->E2_NUMBOR)

				//Efetiva Lancamento Contabil
				F090Contab(cArquivo, @nHdlPrv, cLote, lDigita, lAglut, dDtLanc, @aFlagCTB, aDiario, cFilCorr, cFilOriCtb)

				aFlagCTB 	:= {}  // Limpa o coteudo apos a efetivacao do lancamento
				nHdlPrv 	:= 0
				nTotal		:= 0
				aDiario		:= {}
				lStartCTB 	:= .T.

				//Flag de contabilizacao dos titulos de bordero
				If LanceiCTB .and. !lUsaFlag
					For nX := 1 To Len( aSE5Baixado )
						SE5->( DbGoto( aSE5Baixado[nX] ) )
						Reclock( "SE5" )
						SE5-> E5_LA	:=	"S" + Substr( E5_LA, 2, 1 )
						MsUnlock( )
					Next nX

					// Flag contabilizacao Movimento PA
					For nX := 1 to Len( aSE2Pagant )
						SE2->( DbGoto( aSE2Pagant[nX] ) )
						Reclock( "SE2" )
						SE2-> E2_LA	:=	"S"
						MsUnlock( )
					Next nX
				Endif
			EndIf

		Enddo

		cFilAnt := cFilBaixa

		If nGerPAMov > 0 .AND. !lF090Auto// Verifico se houve a ocorrencia de PA sem Movimento bancario para acionar aviso ao usuario
			MsgAlert( STR0173 ) // "Durante o processo de baixa, foi verificada a existência de títulos de Pagamentos Antecipados sem movimento bancário. Para esses registros não foi alterado o saldo do título, mas apenas gerado o seu movimento bancário inicial."
			nGerPAMov := 0
		EndIf

		//Grava cheque totalizador no SEF e cheque no SE5
		If lCheque .and. !Empty(cCheq090) .And. Substr(cCheq090,1,1) != '*' .AND. nValorCheq > 0

			//Model de Movimento bancario
			oModelMov := FWLoadModel("FINM030")
			oModelMov:SetOperation(MODEL_OPERATION_INSERT) //Inclusao
			oModelMov:Activate()
			oSubFK5M  := oModelMov:GetModel("FK5DETAIL")
			oSubFKAM  := oModelMov:GetModel("FKADETAIL" )

			//Informar o novo campo EF_IDSEF nas inclusões de SEF:
			If SubStr( SEF->EF_NUM,1,1 ) != "*" .and. cLiberado == "S"
				cChaveCH := FWUUIDV4()
			Endif

			Reclock("SEF",.T.)
			EF_FILIAL	:= xFilial("SEF")
			EF_NUM		:= cCheq090
			EF_BANCO	:= cBco090
			EF_DATA		:= dDataBase
			EF_AGENCIA	:= cAge090
			EF_CONTA	:= cCta090
			EF_VALOR	:= nValorCheq
			EF_BENEF	:= cBenef090
			EF_LA		:= If(mv_par03==1 .and. mv_par04==1 .and. lPadrao .and. !lUsaFlag .and. cCtBaixa$"BA","S"," ")
			EF_LIBER	:= cLiberado
			EF_HIST		:= Iif(AllTrim(cHistor090)="",STR0070,cHistor090) //"Cheque por Bx. Automatica"
			EF_ORIGEM	:= "FINA090"
			EF_FILORIG	:= cFilAnt
			EF_FILCHQ	:= cFilCorr
			EF_IDSEF	:= cChaveCH		//ID do cheque
			MsUnlock()

			//Gero informacao de amarracao apenas se gerei movimento bancario
			If SubStr( SEF->EF_NUM,1,1 ) != "*" .and. cLiberado == "S"
				If !oSubFKAM:IsEmpty()
					oSubFKAM:AddLine()
					oSubFKAM:GoLine( oSubFKAM:Length() )
				Endif

				oSubFKAM:SetValue( 'FKA_IDORIG', cChaveCH )
				oSubFKAM:SetValue( 'FKA_TABORI', 'SEF' )

				//-----------------------------------------------------------------------
				// Atualização da Movimentação Bancaria, somente se o cheque for efetivo 
				// (sem * na primeira posição).
				// Obs: Se o cheque foi criado por uma devolução de adiantamento não 
				// precisa movimentar o saldo, pois isto foi feito pela rotina de baixa 
				// de adiantamentos.
				// Também só atualiza a Movimentação bancária se o parametro MV_LIBCHEQ 
				// for "S", caso contrário a movimentação bancária só será atualizada 
				// na opção Conf.Cheque do prg Cheq s/ Titulos (FINA390).
				//-----------------------------------------------------------------------
				// Inclui registro no SE5 para a geracao do cheque
				cCamposE5 := "{{'E5_DTDIGIT' , dDtDigit	}"
				cCamposE5 += ",{'E5_BENEF'   , '"+StrTran(cBenef090,"'","")+"' } }"

				oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )
				oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
				oModelMov:SetValue( "MASTER", "NOVOPROC", .T. ) //Novo processo

				//Relacionamento FKA X FK5
				If !oSubFKAM:IsEmpty()
					oSubFKAM:AddLine()
					oSubFKAM:GoLine( oSubFKAM:Length() )
				Endif

				oSubFKAM:SetValue( 'FKA_IDORIG', FWUUIDV4() )
				oSubFKAM:SetValue( 'FKA_TABORI', "FK5" )
				oSubFK5M:SetValue( "FK5_BANCO"  , cBco090 )
				oSubFK5M:SetValue( "FK5_AGENCI" , cAge090 )
				oSubFK5M:SetValue( "FK5_CONTA"  , cCta090 )
				oSubFK5M:SetValue( "FK5_NUMCH"  , cCheq090 )
				oSubFK5M:SetValue( "FK5_VALOR"  , nValorCheq )
				oSubFK5M:SetValue( "FK5_RECPAG" , "P" )
				oSubFK5M:SetValue( "FK5_HISTOR" , IIF(AllTrim(cHistor090)<>"",cHistor090,STR0070)) //"Cheque por Bx. Automatica"
				oSubFK5M:SetValue( "FK5_DATA"   , dDataBase )
				oSubFK5M:SetValue( "FK5_DTDISP" , dDataBase )
				oSubFK5M:SetValue( "FK5_NATURE" , cNatur090 )
				oSubFK5M:SetValue( "FK5_ORIGEM" , FunName() )
				oSubFK5M:SetValue( "FK5_TPDOC"  , Iif(lCheque,"CH","VL") )
				oSubFK5M:SetValue( "FK5_CCUSTO" , SE2->E2_CCUSTO )
				oSubFK5M:SetValue( "FK5_FILORI" , cFilAnt )
				oSubFK5M:SetValue( "FK5_MOEDA"  , StrZero(nMoedaBco,2) )
				oSubFK5M:SetValue( "FK5_LA"     , Iif(mv_par04==1 .and. lPadrao .and. !lUsaFlag .and. cCtBaixa$"AC","S"," ") )
				oSubFK5M:SetValue( "FK5_LOTE"   , cLoteFin )

				If lSpbInUse
					oSubFK5M:SetValue( "FK5_MODSPB" , "3" )
				Endif

				If oModelMov:VldData()
					oModelMov:CommitData()
					nRecSE5 := oModelMov:GetValue("MASTER","E5_RECNO")
					SE5->(dbGoTo(nRecSE5))
					Aadd(aRec090Se5,nRecSE5)
				Else
					lRet := .F.
					cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[6])
					Help( ,,"M020VLDI6",,cLog, 1, 0 )
				Endif

				oModelMov:DeActivate()
				oModelMov:Destroy()
				oModelMov := Nil

				//Atualização do Saldo Bancario
				If lAtuSldBco
					AtuSalBco( cBco090,cAge090,cCta090,SEF->EF_DATA,nValorCheq,"-" )
				EndIf
			Endif
		Endif

		If lF090SE5
			ExecBlock("F090SE5",.F.,.F.,{aRec090Se5})
		Endif

		//Finaliza processo de integracao com SIGAPCO
		If __lUsaPCO
			PCOFinLan("000006")
		EndIf

		// vai para EOF() para contabilizar apenas o total
		dbSelectArea("SE2")
		SE2->(dbGoBottom())
		SE2->(dbSkip())

		// Se for baixa de titulos e o motivo for VENDOR, nao existir o
		// parametro MV_BXAUTVE ou existir e retornar retornar .T. 
		// Cria titulo de vendor baseado no total baixado
		If TrazCodMot(cMotBx) == "VEN" .And. nTipoBx == 1 .And. __lMVBXAUTVE 	
			If !lF090Auto
				lVendor := Fa080Vdr(@aVendor, nValorTotal, Ctod(""))
			Else
				// Atualiza dados do vendor (matriz enviada por referencia)
				If Len(aVendor) > 0 
					lVendor := .T.
				Endif
			Endif
				
			If lVendor
				lPadraoVd := VerPadrao( "518" ) .And. cCtBaixa $ "BA"
				Fa080GrVen(@cTitOrig,lPadraoVd,Iif(mv_par03==1,"S","N"),aVendor, "FINA090")
				nLen := Len(aTitBaixado)

				Begin Transaction
					For nX := 1 To nLen
						SE2->(DbGoto(aTitBaixado[nX,1]))

						If lPadraoVd .and. mv_par03==1
							If UsaSeqCor()
								AaDd(aDiario,{"SE5",SE5->(Recno()),cCodDiario,"E5_NODIA","E5_DIACTB"})
							EndIf

							//Prepara Lancamento Contabil
							If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
								aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
							Endif

							nTotal += DetProva( nHdlPrv, "518" /*cPadrao*/, "FINA090" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/, /*lRateio*/,;
							/*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/ )
						Endif

						Reclock("SE2")
						SE2->E2_TITORIG	:= cTitOrig
						MsUnlock()
					Next
				End Transaction
			Endif
		ElseIf lPadAux .And. mv_par03 == 1 .and. nTipoBX == 2 .and. mv_par05 == 2 //Baixa por bordero e totalizacao bordero a bordero
			nLstRecSE5 := SE5->( RecNo() )
			nLen := Len(aTitBaixado)

			If nHdlPrv == 0
				nHdlPrv := HeadProva( cLote, "FINA090" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo )
			Endif

			aSort(aTitBaixado,,,{|x,y| x[2] < y[2]})
			nValorTotal := 0

			For nX := 1 To nLen
				SE2->(DbGoto(aTitBaixado[nX,1]))
				SED->(dbSeek(xFilial("SED")+SE2->E2_NATUREZ))

				If lPadAux
					If Len(aRegCtBor) > 0
						nI := aScan( aRegCtBor, { |x| x[1] == aTitBaixado[nX,1] } )
						SA2->(dbGoTo(aRegCtBor[nI,2]))
						SA6->(dbGoTo(aRegCtBor[nI,3]))

						//Posiona na SE5
						If aRegCtBor[nI,4] <> 0
							SE5->(dbGoTo(aRegCtBor[nI,4]))
						Else
							SE5->(dbGoTo(nLstRecSE5))
						EndIf
					EndIf

					If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
						aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
					Endif

					nTotal += DetProva( nHdlPrv, "532", "FINA090" /*cPrograma*/, cLote, 0 /*nLinha*/, .T. /*lExecuta*/, "FINA090" /*cCriterio*/, /*lRateio*/, /*cChaveBusca*/,;
					/*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/ )

					If UsaSeqCor()
						AaDd(aDiario,{"SE5",SE5->(Recno()),cCodDiario,"E5_NODIA","E5_DIACTB"})
					EndIf
				EndIF

				nValorTotal += SE2->E2_VALLIQ

				//Verifica se eh o mesmo bordero ou se eh o ultimo titulo
				If (nX+1 <= nLen .and. aTitBaixado[nX+1,2] != aTitBaixado[nX,2]) .or. (nX+1 > nLen)
					VALOR		:= nValorTotal
					VLRINSTR	:= nValorTotal
					VALOR2		:= 0
					ABATIMENTO 	:= 0
					STRLCTPAD	:= aTitBaixado[nX,2]

					If lPadAux
						nRecNoSE5 := SE5->( RecNO() )
						nRecNoSE2 := SE2->( RecNO() )
						nRecNoFK2 := FK2->( RecNO() )

						SE5->( DBGoBottom() )
						SE5->( DBSkip() )
						SE2->( dbGoBottom() )
						SE2->( dbSkip() )
						FK2->( dbGoBottom() )
						FK2->( dbSkip() )

						//Prepara Lancamento Contabil
						nTotal += DetProva( nHdlPrv, "532", "FINA090" /*cPrograma*/, cLote, 0 /*nLinha*/, .T. /*lExecuta*/, "FINA090" /*cCriterio*/, /*lRateio*/,;
						/*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, /*@aFlagCTB*/, /*aTabRecOri*/, /*aDadosProva*/ )

						//Restaura a posicao do arquivo
						SE5->( DBGoTo( nRecNoSE5 ) )
						SE2->( DBGoTo( nRecNoSE2 ) )
						FK2->( DBGoTo( nRecNoFK2 ) )

						If UsaSeqCor()
							AaDd(aDiario,{"SE5",SE5->(RecNo()),cCodDiario,"E5_NODIA","E5_DIACTB"})
						EndIf
					EndIF

					nValorTotal := 0
					VALOR		:= 0
					VLRINSTR	:= 0
					VALOR2		:= 0
					ABATIMENTO 	:= 0
					STRLCTPAD	:= "  "
				Endif
			Next

			VALOR := 0
			lTotPorBord := .T.

		EndIf

		If !lTotPorBord .And. nTipoBx == 2
			// Credito do Banco = Variavel VALOR
			//Zero as variáveis de impostos caso não gere movimento totalizador (MV_BXCNAB == S)
			If !lBxCnab
				FINVARCTB()
			Endif

			//Credito do Banco = Variavel VALOR
			VALOR		:= nValorTotal
			VLRINSTR	:= nValorTotal		// CONDICIONAL DA VARIAVEL VALOR
			Valor2		:= 0					// TOTAL DOS ABATIMENTOS (por titulo)
			ABATIMENTO	:= 0

			If (cCtBaixa == "C" .And. lCheque .and. lMovBcoBx .And. MV_PAR04==1) .or. (cCtBaixa $"B|A") .or. (TrazCodMot(cMotBx) $ "VEN/DEB") .or. (MovBcoBx(cMotBx, .T.) .and. !ChqMotBx(cMotBx))
				If lPadAux .and. mv_par03 == 1

					If nHdlPrv == 0
						nHdlPrv := HeadProva( cLote, "FINA090" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo )
					Endif

					//vai para EOF() para contabilizar apenas o total
					nRecNoSE5 := SE5->( RecNO() )
					nRecNoSE2 := SE2->( RecNO() )
					nRecNoFK2 := FK2->( RecNO() )

					SE5->( DBGoBottom() )
					SE5->( DBSkip() )
					SE2->( dbGoBottom() )
					SE2->( dbSkip() )
					FK2->( dbGoBottom() )
					FK2->( dbSkip() )

					//Prepara Lancamento Contabil
					nTotal += DetProva( nHdlPrv, "532", "FINA090" /*cPrograma*/, cLote, 0 /*nLinha*/, .T. /*lExecuta*/, "FINA090" /*cCriterio*/, /*lRateio*/, /*cChaveBusca*/,;
					/*aCT5*/, /*lPosiciona*/, /*@aFlagCTB*/, /*aTabRecOri*/, /*aDadosProva*/ )

					//Restaura a posicao do arquivo
					SE5->( DBGoTo( nRecNoSE5 ) )
					SE2->( DBGoTo( nRecNoSE2 ) )
					FK2->( DBGoTo( nRecNoFK2 ) )

					If UsaSeqCor()
						AaDd(aDiario,{"SE5",SE5->(Recno()),cCodDiario,"E5_NODIA","E5_DIACTB"})
					EndIf
				EndIF

				VALOR := 0
			Endif
		EndIf

		//Envia para Lancamento Contabil, se gerado arquivo
		If nHdlPrv > 0 .And. nTotal > 0 .And. mv_par03 == 1
			lDigita := If( mv_par01 == 1 .and. !lF090Auto , .T., .F. )
			lAglut  := If( mv_par02 == 1, .T., .F. )

			//Se for rotina automatica força exibir mensagens na tela, pois mesmo quando não exibe os lançametnos, a tela
			//sera exibida caso ocorram erros nos lançamentos padronizados
			If lF090Auto	// Chamada Automatizada
				lSetAuto := _SetAutoMode(.F.)
				lSetHelp := HelpInDark(.F.)
			EndIf

			//	Define data da contabilização on line
			Do Case 
				Case nDtContOn == 1 // 1- Data Digitação
					dDtLanc := dDtDigit
				Case nDtContOn == 2 // 2- Data Disponibilizadade
					dDtLanc := dDebito
				Case nDtContOn == 3 // 3- Data Pagamento
					dDtLanc := dBaixa
			EndCase

			//Efetiva Lancamento Contabil
			cA100Incl(cArquivo, nHdlPrv, /*nOpcx*/, cLote, lDigita, lAglut, /*cOnLine*/, dDtLanc, /*dReproc*/, @aFlagCTB, /*aDadosProva*/, aDiario )

			aFlagCTB := {}

			If lF090Auto	// Chamada Automatizada
				HelpInDark(lSetHelp)
				_SetAutoMode(lSetAuto)
			EndIf

			//Flag de contabilizacao dos titulos de bordero
			If ( nTotal > 0 ) .and. !lUsaFlag
				For nX := 1 To Len( aSE5Baixado )
					SE5->( DbGoto( aSE5Baixado[nX] ) )
					If !lUsaFlag
						Reclock( "SE5" )
						SE5-> E5_LA	:=	"S" + Substr( E5_LA, 2, 1 )
						MsUnlock( )
					Endif
				Next
			Endif

			// Flag Contabilizacao Movimento PA
			For nX := 1 to Len( aSE2Pagant )
				SE2->( DbGoto( aSE2Pagant[nX] ) )
				If !lUsaFlag
					Reclock( "SE2" )
					SE2-> E2_LA	:=	"S"
					MsUnlock( )
				Endif
			Next
		EndIf

	END TRANSACTION// Garante a transacao após a geração do cheque aglutinador

	dbSelectArea( "SE2" )
	RetIndex("SE2")
	Set Filter to

Return lContinua

//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa090ChecF
Funcao para montar e processar a query	

@Param nTipoBx	, Numeric	, Tipo de Baix: 1 = Título ou 2 = Borderô
@Param cBord090I, Character , Código do borderô inicial
@Param cBord090F, Character , Código do borderô final
@Param cBco090	, Character , Código do banco
@Param cAge090	, Character , Código da agência
@Param cCta090	, Character , Código do borderô final

@return cFiltro	, Character , Texto da Query

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function Fa090ChecF(nTipoBx,cBord090I,cBord090F,aSelFil,aTMPFil,cBco090,cAge090,cCta090)

	Local cFiltro   	:= ""
	Local cF090QFIL 	:= "" // Retorno do P.E. cFiltro
	Local cF090FIL	 	:= "" // Retorno do P.E. cFiltro
	Local lBxTxa    	:= SuperGetMv("MV_BXTXA",.F.,"1") == "1"
	Local lF090Tipo 	:= ExistBlock( "F090TIPO" )
	Local cNomeCpo  	:= ""
	Local aFiluser		:= {}
	Local cTmpSE1Fil	:= ""
	Local cFilCxCtr 	:= F090IsCaixa(.T.)
	Local lMvCheques 	:= Type('MVCHEQUES')=='C'
	Local cMvCheques 	:= F90FORMATIN( IIF(lMvCheques,MVCHEQUES,MVCHEQUE) )

	DEFAULT nTipoBx		:= 1
	DEFAULT cBord090I	:= ""
	DEFAULT cBord090F	:= ""
	DEFAULT aSelFil 	:= {cFilAnt}
	DEFAULT aTMPFil 	:= {}
	DEFAULT cBco090		:= ""
	DEFAULT cAge090		:= ""
	DEFAULT cCta090		:= ""
	Default __lF090QFIL := ExistBlock("F090QFIL")
	Default __lF090FIL  := ExistBlock("F090FIL")
	Default __lCtLIPag 	:= GetMv("MV_CTLIPAG")

	//nTipoBx -> 1 = Baixa somente titulos que não estao em bordero
	//nTipoBx -> 2 = Baixa somente titulos em bordero
	aFiluser := FA090CKUS(aSelFil) //Pega somente as filiais que o usuario tem acesso

	//alteracao efetuada para possibilitar baixa Multi-Filial
	If !aFiluser[1] .And. Len(aFiluser[2]) > 0	// verifica se o usuario tem restrições de acesso a alguma filial
		cFiltro := "E2_FILIAL IN " + F90FORMATIN(Fa090MnFil(aFiluser[2]))
	else
		cFiltro += "E2_FILIAL " + GetRngFil( aSelFil, "SE2", .T., @cTmpSE1Fil )
		aAdd(aTMPFil, cTmpSE1Fil)
	endIf

	cFiltro  += " AND "

	If ExistBlock("F090FILEMI")
		cNomeCpo := ExecBlock("F090FILEMI",.F.,.F.,{})
		If SE2->(ColumnPos(cNomeCpo)) > 0
			cFiltro += cNomeCpo + " <= '" + DTOS(dBaixa) + "' AND "
		EndIf
	EndIf

	cFiltro += " E2_EMISSAO <= '" + DTOS(dBaixa) + "' AND "
	If !Empty(cBcoDe) .And. !Empty(cBcoAte) .And. Alltrim(cBcoDe) == Alltrim(cBcoAte)
		cFiltro  += " E2_PORTADO = '" + cBcoDe + "' AND "
	Else
		cFiltro  += " E2_PORTADO >= '" + cBcoDe  + "' AND "
		cFiltro  += " E2_PORTADO <= '" + cBcoAte + "' AND "
	EndIf

	If cPaisLoc $ "PER|DOM|ARG"
		cFiltro += " E2_PORTADO NOT IN " + cFilCxCtr + " AND "
	Endif

	If nTipoBx == 1
		cFiltro += " E2_VENCREA >= '" + DTOS(dVencIni) + "' AND "
		cFiltro += " E2_VENCREA <= '" + DTOS(dVencFim) + "' AND "
		cFiltro += " E2_NUMBOR = '" + Space(TamSx3("E2_NUMBOR")[1]) + "' AND "
	Endif
	If nTipoBx == 2
		If !Empty(cBord090I) .And. !Empty(cBord090F) .And. Alltrim(cBord090I) == Alltrim(cBord090F)
			cFiltro  += " E2_NUMBOR = '" + cBord090I + "' AND "
		Else
			cFiltro  += " E2_NUMBOR >= '" + cBord090I + "' AND "
			cFiltro  += " E2_NUMBOR <= '" + cBord090F + "' AND "
			cFiltro  += " E2_NUMBOR != '" + Space(TamSx3("E2_NUMBOR")[1]) + "' AND "
		EndIf
	Endif

	/*Caso o !lBxTxa seja .T. por causa do parâmetro MV_BXTXA, será acrescentado no filtro a
		validação da flag E2_OK, para assim não exibir na janela de marcação um título do tipo TXA
		que já foi baixado, como solicitado no chamado TGACUL */
	If !lBxTxa
		cFiltro += " (E2_OK <> 'TA' ) AND "
	Endif
	cTipo := If(!Empty(MVPROVIS), MVPROVIS, '')
	cTipo += If(!Empty(MV_CPNEG),'/'+MV_CPNEG,'')
	cTipo += If(!Empty(MVABATIM),'/'+MVABATIM,'')
	cTipo += If(!Empty(MVENVBCOR),'/'+MVENVBCOR,'')

	If lF090Tipo
		cTipo := ExecBlock( 'F090TIPO' , .F. , .F. , { cTipo } )
	EndIf

	cFiltro += " E2_TIPO NOT IN " + F90FORMATIN( cTipo ) + " AND "

	If SuperGetMV("MV_EASYFIN",,"N") == "S" .And. FindFunction("EasyFinOri")
		cFiltro += EasyFinOri() + " AND "
	Else
		cFiltro  += " E2_ORIGEM NOT IN ('SIGAEEC','SIGAEDC','SIGAECO','SIGAEFF','SIGAESS', 'SIGAEIC') AND "
	EndIf

	If FindFunction("EasyOrigem") .And. FindFunction("F050EasyOrig")
		cFiltro  += " E2_TIPO NOT IN ('PR','PRE') AND "
	EndIf

	// Para o Brasil, apresenta somente os titulos cuja moeda e' a mesma do banco selecionado para baixa.
	// Caso a moeda do banco estiver vazia ou caso o motivo de baixa nao movimente banco, considero apenas a moeda forte
	If FXMultSld()
		If nMoedaBco > 1 .And. MovBcoBx(cMotBx,.T.)
			cFiltro  += " E2_MOEDA = " +  StrZero( nMoedaBco, 2 ) + " AND "
		Endif
	EndIf

	// Se trabalha com liberacao de pagto., filtra os registros que ultrapassem o valor minimo
	If __lCtLIPag
		cFiltro  += " ( E2_DATALIB !=  '        '  OR (E2_SALDO+E2_SDACRES-E2_SDDECRE) <= " + Str(GetMV("MV_VLMINPG"),17,2) + ") AND "
	Endif

	// Verifica se o titulo esta bloqueado - Gestao de Contratos
	If cPaisLoc == "CHI" .And. !Empty(SE2->(ColumnPos("E2_MSBLQL")))
		If !Empty(E2_CODOPE)
			cFiltro += " E2_CODOPE = '02' AND "
		Else
			cFiltro += " E2_MSBLQL != '1' AND "
		EndIf
	ElseIf !Empty(SE2->(ColumnPos("E2_MSBLQL")))
		cFiltro += " E2_MSBLQL != '1' AND "
	EndIf

	cFiltro += " E2_SALDO > 0 "

	// Para localizados deve ser apresentado apenas os titulos do tipo Cheque
	If cPaisLoc <> "BRA"
		cFiltro += " AND E2_TIPO IN " + cMvCheques + " "
	EndIf

	// PONTO DE ENTRADA PARA ALTERACAO DO FILTRO - ORIGINAL FINA090
	If __lF090QFIL
		cF090QFIL := ExecBlock("F090QFIL",.F.,.F.,{cFiltro, nTipoBx})
		If (ValType(cF090QFIL) == "C" .AND. !Empty(cF090QFIL))
			cFiltro := cF090QFIL
		EndIf
	// PONTO DE ENTRADA PARA ALTERACAO DO FILTRO - ORIGINAL FINA091
	ElseIf __lF090FIL
		cF090FIL := ExecBlock("F090FIL",.f.,.f.,{nTipoBx,cBco090,cAge090,cCta090,cBord090I,cBord090F,cFiltro})
		If (ValType(cF090QFIL) == "C" .AND. !Empty(cF090FIL))
			cFiltro := cF090FIL
		EndIf
	Endif

	// Complemento de filtro - SIAFI
	cFiltro  +=  FinTemDH(.T. /*lFiltro*/,/*cAlias*/,.F. /*lHelp*/, .T./*lTop*/)

Return cFiltro


//-------------------------------------------------------------------
/*{Protheus.doc} FA090CKUS
função ira verificar quais filais estão acessiveis pelo usuario logado

@param 	cFilIni - Filial Inicial
cFilFim - Filail Final

@author Caio Quiqueto
@since 21/07/2015
@version P11

@return Array{lAceCompl,aRet
lAceCompl - se o usuario tem acesso a todas as filais do Grupo de empresas
aRet - array com todas as filais que o usuario tem acesso no Grupo de empresas
*/
//-------------------------------------------------------------------
function FA090CKUS(aSelFil)

	Local aSM0		:= FWLoadSM0()	//Carrega as informações das filiais
	Local GrpCorr	:= FWGrpCompany ()	// Retorna o grupo de empresas utilizada pelo Sistema.
	Local nX		:= 1
	Local nGrpCont	:= 0
	Local aRet 		:= {}
	Local lAceCompl := .F.

	DEFAULT aSelFil := {}

	//ordena o array de filial por grupo e código de filial
	aSM0 := asort(aSM0,,,{|X,Y| X[1]+X[2] < Y[1]+Y[2]})

	//posiciona no primeiro registro do grupo logado
	nX := aScan(aSM0,{|X| X[1] == GrpCorr})

	while aSM0[nX][1] = GrpCorr
		If aSM0[nX][11] .AND. IF(LEN(aSelFil)>0,ASCAN(aSelFil,{|e| e == aSM0[nX][2]}) > 0,.T.)
			aADD(aRet, xFilial( "SE2", aSM0[nX][2] ))
		EndIf
		If nX == Len(aSM0)
			Exit
		EndIf
		nGrpCont ++
		nX ++
	enddo

	if nGrpCont = len(aRet)
		lAceCompl := .T.
	EndIf

return {lAceCompl,aRet}


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} fa090Correc
Calculo da Correção Monetária

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function fa090Correc( )

	Local nCorrecao := 0
	Local nValAtual := 0
	Local nValEmiss := 0
	Local nTxEmis	:= 0
	Local nTxBaix	:= 0

	IF SE2->E2_MOEDA > 1

		//Caso seja a primeira apuracao de variacao monetaria
		If Empty(SE2->E2_TXMOEDA) .and. Empty(SE2->E2_DTVARIA)
			nValEmiss := SE2->E2_VLCRUZ
		Else
			nTxEmis	:= If(SE2->E2_MOEDA > 1,If(SE2->E2_TXMOEDA > 0 .and. Empty(SE2->E2_DTVARIA) .And. RecMoeda(SE2->E2_EMISSAO,SE2->E2_MOEDA) == 0, SE2->E2_TXMOEDA,;
			IIf(RecMoeda(SE2->E2_EMISSAO,SE2->E2_MOEDA) > 0 .And. Empty(SE2->E2_TXMOEDA), RecMoeda(SE2->E2_EMISSAO,SE2->E2_MOEDA), SE2->E2_TXMOEDA)),0)
			If !Empty(SE2->E2_TXMDCOR)
				nValEmiss := Round(xMoeda( SE2->E2_SALDO, SE2->E2_MOEDA, 1, IF(Empty(SE2->E2_DTVARIA),SE2->E2_EMISSAO,SE2->E2_DTVARIA),3,SE2->E2_TXMDCOR ),2)
			Else
				nValEmiss := Round(xMoeda( SE2->E2_SALDO, SE2->E2_MOEDA, 1, If(Empty(SE2->E2_DTVARIA),SE2->E2_EMISSAO,SE2->E2_DTVARIA),3,nTxEmis),2)
			EndIf
		End

		nTxBaix :=  If(SE2->E2_MOEDA > 1,If(SE2->E2_TXMOEDA > 0 .and. Empty(SE2->E2_DTVARIA) .And. RecMoeda(dDataBase,SE2->E2_MOEDA) == 0, SE2->E2_TXMOEDA,;
		IIf(RecMoeda(dDataBase,SE2->E2_MOEDA) > 0 .And. Empty(SE2->E2_TXMOEDA), RecMoeda(dDataBase,SE2->E2_MOEDA), SE2->E2_TXMOEDA)),0)

		nValAtual := Round(xMoeda( SE2 -> E2_SALDO, SE2 -> E2_MOEDA, nMoedaBco, dDataBase, 3, nTxBaix ),2)

		//--------------------------------------------------------------------
		// Verifica atraves do parametro MV_CALCCM se sera calculada a 
		// correcao monetaria. Caso o parametro nao exista, sera assumido "S"
		//--------------------------------------------------------------------
		If SE2->E2_MOEDA != nMoedaBco .AND. GetMv("MV_CALCCM") == "S"
			nCorrecao := nValAtual - nValEmiss
		Else
			nCorrecao := 0
		Endif
	Endif

Return nCorrecao


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} fA090Par
Ativa Parâmetros do Programa 

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function fA090Par()
	pergunte(__cPerg,.T.)
Return .T.


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa090Marca
Trata o valor para marcar e desmarcar item

@Param cAlias	, Character , Alias utilizado para seleção de títulos
@Param cMarca	, Character , Código da marca do processo
@Param aTitulos , Array		, Array dos títulos a serem processados
@Param nTipoBx	, Numeric	, Tipo de Baix: 1 = Título ou 2 = Borderô

@return cFiltro	, Character , Texto da Query

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Static Function Fa090Marca(cAlias,cMarca,aTitulos,nTipoBx)

	Local nRec		 := 0
	Local cAliasAnt  := Alias()
	Local nY		 := 0
	Local lHelpBxTit := .F.

	Private nValorMarca	:= 0 // Permitir alterar valor do titulo marcado no PE F090TIT

	Default aTitulos := {}
	
	If cPaisLoc <> "BRA"
		nVA :=  IIF(Type("nVA") == "U" ,0,nVA)
		SCU->(DbSetOrder(2))
	Endif

	dbSelectArea("SE2")
	nRec := SE2->(Recno())

	//Rotina Normal (NAO Automatizada)
	If Empty(aTitulos)

		ProcRegua((cAlias)->(RecCount()))
		(cAlias)->(DbGoTop())
		While (cAlias)->(!Eof())

			SE2->(DBGoto((cAlias)->NUM_REG) )
			F090VldMrk(cAlias,aTitulos, @lHelpBxTit )
			IncProc(STR0164) //"Selecionando registros..."

			(cAlias)->(dbSkip())
		EndDo
	Else
		//Rotina Automatizada
		For nY := 1 to Len(aTitulos)
			(cAlias)->(DbSetOrder(3))

			If (cAlias)->(MsSeek(aTitulos[nY]))
				SE2->(dbGoto(aTitulos[nY]))
				F090VldMrk(cAlias,aTitulos, @lHelpBxTit )
			Endif
		Next nY

		If lHelpBxTit
			Help(" ",1,"F090PAMOV",,STR0172,1,0) //"Nao é possivel realizar a baixa de pagamento antecipado sem movimentação bancária."
		EndIf

		If !Empty((cAlias)->E2_NUMBOR)
			nTipoBx := 2
		EndIf
		(cAlias)->(DbSetOrder(4))
	Endif

	dbSelectArea("SE2")
	dbGoto(nRec)
	dbSelectArea(cAliasAnt)
Return


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F090VldMrk
	Efetua a gravação da Marca no título

	@author Pequim
	@since 18/11/2021

	@param aTitulos, Array, Lista dos títulos a serem marcados (Automatica)
	@return return_var, return_type, return_description
/*/
//---------------------------------------------------------------------------------------------------------
Static Function F090VldMrk (cAlias As Character, aTitulos AS Array, lHelpBxTit AS Logical)

	Local lTodos As Logical
	Local lRet AS Logical
	Local lBxTit AS Logical
	Local lPrimeiro AS Logical
	Local cUserLga AS Character
	Local nAbat	AS Numeric
	Local nRecPA AS Numeric

	Default __lF090TIT	:= ExistBlock("F090TIT")
	Default __lSOLNCP 	:= SuperGetMv('MV_SOLNCP')
	Default __lCtLIPag 	:= GetMv("MV_CTLIPAG")
	Default __lFinVDoc	:= GetNewPar("MV_FINVDOC","2") == "1" //Controle de validacao de documentos obrigatorios
	Default __nTamMD2	:= TamSx3("E2_TXMOEDA")[2]
	Default __lExistLGA := ColumnPos('E2_USERLGA') > 0
	
	lBxTit		:= .T.
	lPrimeiro	:= .T.
	lRet		:= .T.
	lTodos		:= Empty(aTitulos)
	cUserLga	:= ""
	nAbat		:= 0
	nRecPA		:= 0

	//-------------------------------------------------------------------
	// Caso esteja ligado o controle de solicitacao de notas de credito 
	// e exista alguma pendencia para este titulo
	//-------------------------------------------------------------------
	If cPaisloc <> "BRA" .And. __lSOLNCP .And. SE2->E2_TIPO == MVNOTAFIS .And. ;
		SCU->(MsSeek(xFilial("SCU")+SE2->E2_FORNECE+SE2->E2_LOJA+SE2->E2_NUM+SE2->E2_PREFIXO)).And. Empty(SCU->CU_NCRED)
		lRet := .F.
	EndIf

	// Documentos Apresentados
	IF lRet .and. __lFinVDoc
		If !CN062ValDocs("03",.F.,.F.,lTodos,@lPrimeiro)
			lRet := .F.
		EndIf
	Endif

	// Verifica se possui movimento de baixa valido
	If lRet .and. (cAlias)->E2_TIPO $ "INA"
		If F090PagINA( SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) )
			lRet := .F.
		EndIf
	EndIf

	If lRet
		lRet := Fa080Integ(.F.,.F.)
	Endif

	If lRet 
		lBxTit := .T.

		// Caso tenha integracao SIGAPFS (MV_JURXFIN = .T.), valida as regras para manipulacao do título.
		If !Fa090Juri(.F., .F.)
			lBxTit := .F.
		EndIf

		//Verifica motivo de baixa para titulo cancelado
		If __lCtLIPag .And. !Empty(SE2->E2_DATACAN) .And. MovBcoBx(cMotBx, .T.)
			IF !lTodos
				Help(" ",1,"F090SELCANC",,STR0117,1,0) //"Impossível selecionar este título, pois o motivo de baixa é inválido para títulos cancelados."
			EndIf
			lBxTit := .F.
		Endif

		//Verifica se PA possui movimentacao para permitir a baixa
		If SE2->E2_TIPO $ MVPAGANT .and. lBxTit
			nRecPA := F080MovPA(.T.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
			If nRecPA < 1
				//Verifica se ‚ PA de CNAB (Gera Ch para Adt = N?o / Mov. Banc. sem Cheque = N?o) - Nesse caso deve permitir a baixa para gerar mov. a pagar
				nRecPA := F080MovPA(.F.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
				If nRecPA > 0
					lBxTit := .F.
					If !lTodos
						lHelpBxTit	:= .T.
					Endif
				Else
					lBxTit := .T.
				Endif
			EndIf
		Endif

		If __lExistLGA
			cUserLga := SE2->E2_USERLGA
		EndIf

		If (cAlias)->(MsRLock()) .and. SE2->(MsRLock())// Se conseguir travar o registro
			(cAlias)->E2_OK := cMarca
			SE2->E2_OK := cMarca

			If __lExistLGA
				SE2->E2_USERLGA := 	cUserLga
			EndIf

			nAbat := F090GETABAT()

			nVA 	:= FValAcess( SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NATUREZ, .T. ,, "P", dDatabase, , SE2->E2_MOEDA )

			nValorMarca	:= xMoeda(Round(SE2->E2_SALDO+fa080Juros(nMoedaBco) + nVA + SE2->E2_SDACRES-SE2->E2_SDDECRE-nAbat,2) ,SE2->E2_MOEDA,nMoedaBco,,__nTamMd2,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0))

			//-------------------------------------------------------------------------------------------------------
			// PONTO DE ENTRADA F090TIT
			// Verifica se titulo pode ser marcado para baixa ou não caso tenha sido alterada a marcação do titulo.
			// Retornar .F. para não haver alteração dos acumuladores de valores e numero de titulos.
			// Importante:
			// Os valores passados como parãmetro para esse PE são apenas para manter a compatibilidade
			// com a chamada feita no FINA090.
			// Valores utilizados apenas na chamada da rotina automática do FINA090
			//-------------------------------------------------------------------------------------------------------
			If __lF090TIT
				lBxTit := ExecBlock("F090TIT",.F.,.F.,{nValorMarca,aTitulos})
			Endif
			If lBxTit
				nValor += nValorMarca - nDescont
				nQtdTit	++
			Else
				(cAlias)->E2_OK := "  "
				SE2->E2_OK := "  "
				(cAlias)->(MsUnlock())
				SE2->(MsUnlock())
			Endif
		Endif
	Endif

Return 


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa090Inverte
Marca / Desmarca todos os titulos

@Param cAliasSe2, Character , Alias utilizado para seleção de títulos
@Param cMarca	, Character , Código da marca do processo
@Param oValor 	, Object	, Objeto para atualização do valor selecionado para baixa
@Param oQtda 	, Object	, Objeto para atualização do numero de registros selecionado para baixa
@Param lTodos	, Logical	, Indica se está sendo chamada de um título ou da inverte
@Param oMark 	, Object	, Objeto para atualização da marcação

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function Fa090Inverte(cAliasSE2,cMarca,oValor,oQtda,lTodos,oMark)
	
	Local nAbat		 := 0
	Local nVa        := 0
	Local lBxTit	 := .T.
	Local aAreaSE2	 :=	SE2->(GetArea())
	Local aAreaAlias := (cAliasSe2)->(GetArea())
	Local lPrimeiro	 :=.T.
	Local lLibLock	 := .F.
	Local cUserLga   := ""
	
	Local nRecPA     := 0

	Private nValorMarca	:= 0 // Permitir alterar valor do titulo marcado no PE F090TIT
	
	DEFAULT lTodos	  	:= .T.
	Default __lF090DESC	:= ExistBlock("F090DESC")
	Default __lF090TIT	:= ExistBlock("F090TIT")
	Default __lCtLIPag 	:= GetMv("MV_CTLIPAG")
	Default __lFinVDoc	:= GetNewPar("MV_FINVDOC","2") == "1" //Controle de validacao de documentos obrigatorios
	Default __nTamMD2	:= TamSx3("E2_TXMOEDA")[2]
	Default __lExistLGA := ColumnPos('E2_USERLGA') > 0	

	dbSelectArea(cAliasSE2)
	If lTodos
		(cAliasSE2)->(dbSetOrder(1))		//E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA
		(cAliasSE2)->(DbGoTop())
		ProcRegua((cAliasSE2)->(RecCount()))
	EndIf

	While !lTodos .Or. !(cAliasSE2)->(Eof())

		SE2->(dbGoto((cAliasSE2)->NUM_REG))
		If __lExistLGA
			cUserLga := SE2->E2_USERLGA
		EndIF

		If SE2->(MsRLock()) .AND. (cAliasSE2)->(MsRLock())
			IF (cAliasSE2)->E2_OK == cMarca
				(cAliasSE2)->E2_OK := "  "
				SE2->E2_OK := "  "
				lLibLock := .T.
				nAbat := F090GETABAT()

				nVa	:= FValAcess(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NATUREZ, .T./*lBaixados*/,/*cCodVa*/,"P",dBaixa)

				nValor	-= xMoeda(Round(SE2->E2_SALDO+fa080Juros(nMoedaBco) + nVA +SE2->E2_SDACRES-SE2->E2_SDDECRE-nAbat-nDescont,2) ,SE2->E2_MOEDA,nMoedaBco,,__nTamMd2,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0))
				
				nQtdTit	--
			Else
				lBxTit := .T.
				
				// Caso tenha integracao SIGAPFS (MV_JURXFIN = .T.), valida as regras para manipulacao do título.
				If !Fa090Juri(lTodos, @lPrimeiro)
					lBxTit := .F.
					lLibLock := .T.
				EndIf

				//Verifica se motivo e valido no caso de titulo cancelado
				If lBxTit .and. __lCtLIPag .And. !Empty(SE2->E2_DATACAN) .And. MovBcoBx(cMotBx, .T.)
					IF !lTodos
						Help(" ",1,"F090SELCANC",,STR0117,1,0) //"Impossível selecionar este título, pois o motivo de baixa é inválido para títulos cancelados."
					EndIf
					lBxTit := .F.
					lLibLock := .T.
				EndIf

				// Caso tenha integracao Documentos
				If  lBxTit .and. __lFinVDoc
					If !CN062ValDocs("03",.F.,.F.,lTodos,@lPrimeiro)
						(cAliasSE2)->E2_OK := "  "
						SE2->E2_OK	:= "  "
						lBxTit := .F.
						lLibLock := .T.
					EndIf
				EndIf

				// Verifica se possui movimento de baixa valido
				If lBxTit .and. SE2->E2_TIPO $ "INA"
					If F090PagINA( SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA) )
						IF !lTodos
							HELP(" ",1,"SE2BLOQ")
						EndIf
						(cAliasSE2)->E2_OK := "  "
						SE2->E2_OK	:= "  "
						lBxTit := .F.
						lLibLock := .T.
					EndIf
				EndIf

				// Verifica se PA possui movimentacao bancaria
				If  lBxTit .and. SE2->E2_TIPO $ MVPAGANT
					nRecPA := F080MovPA(.T.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
					If nRecPA < 1
						//Verifica se é PA de CNAB (Gera Ch para Adt = Não / Mov. Banc. sem Cheque = Não) - Nesse caso deve permitir a baixa para gerar mov. a pagar
						nRecPA := F080MovPA(.F.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
						If nRecPA > 0
							IF !lTodos
								Help(" ",1,"F090PAMOV",,STR0172,1,0) //"Não é possível realizar a baixa de pagamento antecipado sem movimentação bancária."
							Endif
							lBxTit := .F.
							lLibLock := .T.
						Else
							lBxTit := .T.
							lLibLock := .F.
						Endif
					EndIf
				Endif

				//------------------------------------------------------------------------------------------
				// PONTO DE ENTRADA F090TIT
				// Verifica se titulo pode ser marcado para baixa ou nÆo. Caso tenha
				// sido alterada a marcação do titulo.
				// Retornar .F. para não haver alteração dos acumuladores de valores e numero de titulos.
				// Importante:
				// Os valores passados como parãmetro para esse PE são apenas para manter a compatibilidade
				// com a chamada feita no FINA090.
				// Valores utilizados apenas na chamada da rotina automática do FINA090
				//------------------------------------------------------------------------------------------
				IF __lF090TIT .and. !Empty(E2_OK)
					lBxTit := ExecBlock("F090TIT",.F.,.F.,{nValorMarca,{}})
				Endif
			   
				If lBxTit
					(cAliasSE2)->E2_OK := cMarca
					SE2->E2_OK	:= cMarca

					nAbat 		:= F090GETABAT()
					nVa	:= FValAcess(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NATUREZ, .T./*lBaixados*/,/*cCodVa*/,"P",dBaixa)
					nValorMarca := xMoeda(Round(SE2->E2_SALDO+fa080Juros(nMoedaBco) + nVA + SE2->E2_SDACRES-SE2->E2_SDDECRE-nAbat,2) ,SE2->E2_MOEDA,nMoedaBco,,__nTamMd2,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0))
					nValor += IIF(__lF090DESC, (nValorMarca - nDescont), nValorMarca)
					nQtdTit++
				Else
					(cAliasSE2)->E2_OK	:= "  "
					SE2->E2_OK	:= "  "
					lLibLock := .T.
				Endif
			EndIf
			If __lExistLGA
				SE2->E2_USERLGA := cUserLga
			EndIF
		EndIf
		IF lLibLock
			(cAliasSE2)->(MsUnlock())
			SE2->(MsUnlock())
		ENDIF

		If lTodos
			IncProc(STR0164) //"Selecionando registros..."
			(cAliasSE2)->(dbSkip())
		Else
			Exit
		EndIf

	Enddo

	RestArea(aAreaSE2)
	RestArea(aAreaAlias)

	oValor:Refresh()
	oQtda:Refresh()
	oMark:oBrowse:Refresh(.t.)

Return Nil



//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} fa090Busca
Pesquisa com indice temporario

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function fa090Busca()
	AxPesqui()
	Eval(bFilBrw)
Return


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F090VldBx
Valida dados para baixa automática

@Param nTipoBx	, Numeric	, Tipo de Baix: 1 = Título ou 2 = Borderô
@Param lBxCnab	, Logical	, Gera totalizador quando baixa CNAB
@Param cBco090	, Character , Código do banco
@Param cAge090	, Character , Código da agência
@Param cCta090	, Character , Código do borderô final
@Param cMotBx	, Character , Motivo de Baixa
@Param oDlg 	, Object	, Objeto que contém as informações a serem validadas
@Param cCheq090	, Character , Código do cheque 
@Param cBord090I, Character , Código do borderô inicial
@Param cBord090F, Character , Código do borderô final
@Param oRadio 	, Object	, Objeto que contém as informações do tipo de baixa (Título/Bordero)
@Param lBcoExcl	, Logical	, Indica se o cadastro de bancos é exclusivo ou compartilhado
@Param lF090Auto, Logical	, Indica se ExecAuto
@Param aVendor  , Array		, Array contendo dados para baixa por VENDOR

@Return lRet	, Logical	, Informa se a validação foi positiva ou não

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Static Function F090VldBx(nTipoBx,lBxCnab,cBco090,cAge090,cCta090,cMotBx,oDlg,cCheq090,cBord090I,cBord090F,oRadio,lBcoExcl,lF090Auto,aVendor)
	
	Local nX	:= 0
	Local lRet	:= .T.
	Local lWhen	

	DEFAULT lBcoExcl := .F.
	DEFAULT lF090Auto := .F.
	DEFAULT aVendor := {}
	DEFAULT __lMVBXAUTVE := SuperGetMv("MV_BXAUTVE",.F.,.F.)

	If !lF090Auto
		For nX := 1 To Len(oDlg:aControls)
			If ValType(oDlg:aControls[nX]) == "O" .And.;
					!Empty(oDlg:aControls[nX]:bValid)
				lWhen := Eval(oDlg:aControls[nX]:bWhen)
				// So valida a condicao Valid, se passou pela condicao When
				If ValType(lWhen) != "L" .Or. lWhen
					lRet:=Eval(oDlg:aControls[nX]:bValid)
					If ValType(lRet) != "L"
						lRet := .T.
					Endif
					If !lRet
						Help(" ",1,"F090Erro",,STR0073,1,0) // "Campos obrigatórios não preenchidos"+chr(13)+"ou com valores inválidos"
						Exit // Sai no primeiro campo invalido
					Endif
				Endif
			Endif
		Next
	Endif

	If ExistBlock("F090TOK")
		lRet := ExecBlock("F090TOK",.F.,.F.,{cBcoDe,cBcoAte,cBco090,cAge090,cCta090,cCheq090,cBord090I,cBord090F,dVencIni,dVencFim,nTipoBx,oRadio})
	Endif

	If lRet .and. nTipoBx == 2 .and. mv_par01 == 2 .and. lBxCnab
		If !Empty(cLoteFin)
			lRet := CheckLote("P", !lF090Auto, cBco090)
		Else
			lRet := .F.
		Endif
	Endif

	//Verifica a conta corrente e se a mesma não está bloqueada
	NUMCHEQUE:=""
	If lRet .And. MovBcoBx(cMotBx,.T.)
		If !CarregaSa6(@cBco090,@cAge090,@cCta090,.T.,,.T.)
			lRet := .F.
		EndIf
	Endif

	If lRet
		if !Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*"
			NUMCHEQUE := cCheq090
		Endif
	Endif

	If lRet .and. lF090Auto .and. TrazCodMot(cMotBx) == "VEN" .And. nTipoBx == 1 .And. __lMVBXAUTVE .and. Len(aVendor) > 0
		cContrato 	:= aVendor[1]
		cBancoV		:= aVendor[2]	
		cAgenciaV	:= aVendor[3]	
		cPrefV		:= aVendor[4]	
		cNumV	  	:= aVendor[5]
		cParcV		:= aVendor[6]	
		cTipV	  	:= aVendor[7]
		dDataVencV	:= aVendor[8]
		nTxAcresV 	:= aVendor[9]
		cNaturV	  	:= aVendor[10]
		nValTitV  	:= aVendor[11]

		If Empty(cContrato) .or. !Fa080Contr(cContrato)
			lRet := .F.
		ElseIf Empty(cNumV)
			lRet := .F.
		ElseIf Empty(cTipV) .or. !Fa080Tip(cTipV) .and. !Fa080NRV(cPrefV,cNumV,cParcV,cTipV)
			lRet := .F.
		ElseIf Empty(cNaturV) .or. !Fa080Nat(cNaturV)
			lRet := .F.
		ElseIf Empty(nTxAcresV)
			lRet := .F.
		ElseIf Empty(dDataVencV) .or. !Fa080DtVen(dDataVencV)
			lRet := .F.
		Endif

		If !lRet
			Help(" " , 1 , "FA080DADVEND")
		Endif

	EndIf

	If lRet .And. !IsBlind() .And. nTipoBx == 1 .And. lBcoExcl .and. MV_PAR07 == 1 .And. MovBcoBx(cMotBx,.T.)
		MsgAlert(STR0177, STR0180) //"Somente serão apresentados os títulos das filiais que tenham um cadastro de banco igual ao escolhido.", "Atenção"
	EndIf

Return lRet


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} fa090Cheq
Valida cheque digitado, se digitado é diferente de '*' e se não existe outro com mesmo número

@Param cBanco090	, Character , Código do banco
@Param cAgencia090	, Character , Código da agência
@Param cConta090	, Character , Código do borderô final
@Param cCheq090		, Character , Código do cheque 

@Return lRet	, Logical	, Informa se a validação foi positiva ou não

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Static Function fa090Cheq(cBanco090,cAgencia090,cConta090,cCheq090 )
	Local lRet    := .T.

	lRet := VldUser("EF_NUM") // Chama a validacao de usuario
	If lRet .And. !Empty(cCheq090) .And. Substr(cCheq090,1,1) != "*"
		SEF->(dbSetOrder(1))
		If SEF->( (dbSeek( cFilial + cBanco090 + cAgencia090 + cConta090 + cCheq090 ) ) )
			Help( " ",1,"F090Cheq" )
			lRet := .f.
		Endif
	Endif

Return lRet


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa090bAval
Bloco de marcação

@Param cAliasSe2, Character , Alias utilizado para seleção de títulos
@Param cMarca	, Character , Código da marca do processo
@Param oValor 	, Object	, Objeto para atualização do valor selecionado para baixa
@Param oQtda 	, Object	, Objeto para atualização do numero de registros selecionado para baixa
@Param oMark 	, Object	, Objeto para atualização da marcação
@Param nValor 	, Numeric	, Valor para a validação da marcação

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Static Function Fa090bAval(cAliasSE2,cMarca,oValor,oQtda,oMark,nValor)
	Local lRet	 := .T.
	Local lVld	 := .F.
	Local nRecPA := 0
	Default __lF90PSTIT := ExistBlock("F090POSTIT")

	SE2->(dbGoto((cAliasSE2)->NUM_REG))

	lRet:=IIF((cAliasSE2)->E2_OK==cMarca,.T.,FA080Integ(.F.,.T.))
	If lRet
		If (cAliasSE2)->(MsRLock())
			If GetNewPar("MV_VLTITAD",.F.) .And. ( (cAliasSE2)->E2_OK <> cMarca )
				If F090VlMark(.F.,cAliasSE2,cMarca,oValor,oQtda,oMark,nValor)
					lVld := .T.
				Endif
			Else
				lVld := .T.
			Endif
			If lVld
				If SE2->E2_TIPO $ MVPAGANT
					//Verifica se PA possui movimentacao para permitir a baixa
					nRecPA := F080MovPA(.T.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
					If nRecPA < 1
						//Verifica se ‚ PA de CNAB (Gera Ch para Adt = N?o / Mov. Banc. sem Cheque = N?o) - Nesse caso deve permitir a baixa para gerar mov. a pagar
						nRecPA := F080MovPA(.F.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
						If nRecPA > 0
							lVld := .F.
							IW_MsgBox(STR0172,STR0072,"STOP")  //"N?o ‚ poss¡vel realizar a baixa de pagamento antecipado sem movimenta‡?o banc ria."
						Else
							lVld := .T.
						Endif
					EndIf
				Endif
			EndIf
			If lVld
				Fa090Inverte(cAliasSe2,cMarca,oValor,oQtda,.F.,oMark) // Marca o registro e trava
				lRet := .T.
			Else
				lRet := .F.
			EndIf
		Else
			IW_MsgBox(STR0071,STR0072,"STOP")  //"Este titulo está sendo utilizado em outro terminal, não pode ser utilizado na fatura"###"Atenção"
			lRet := .F.
		EndIf
	EndIf

	If __lF90PSTIT
		ExecBlock("F090POSTIT", .F., .F., { cAliasSE2 } )//cAliasSE2
	EndIf

	oMark:oBrowse:Refresh(.t.)

Return lRet


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F090VlMark
Bloco de marcação

@Param lGeral	, Logical	, Define se verifica somente registro corrente ou todos registros
@Param cAliasA	, Character , Alias utilizado para seleção de títulos
@Param cMarca	, Character , Código da marca do processo
@Param oValor 	, Object	, Objeto para atualização do valor selecionado para baixa
@Param oQtda 	, Object	, Objeto para atualização do numero de registros selecionado para baixa
@Param oMark 	, Object	, Objeto para atualização da marcação
@Param nValor 	, Numeric	, Valor para a validação da marcação
@Param cProg	, Character	, Código da Rotinas que está chamando

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function F090VlMark(lGeral,cAliasA,cMarca,oValor,oQtda,oMark,nValor,cProg)
	Local aArea		:= GetArea()
	Local lMsg		:= .F.
	Local cMsg		:= ""
	Local lMarca 	:= .F.
	Local lRet	 	:= .T.
	Local lErro		:= .F.
	Local nPos		:= 1
	Local nBusca	:= 0
	Local nTamMark	:= 0
	Local aLog		:= {}
	Local lf090log 	:= ExistBlock("F090LOG")
	Local lF240		:= AllTrim(FunName()) == 'FINA240'
	Local cFilBckp	:= cFilAnt
	Local lTemFilOg := .F.
	Local aAreaAlias := (cAliasA)->(GetArea())
	Local aBuscaAD   := {}
	Local nPosBusca	:= 0

	Default lGeral := .T. // Define se verifica somente registro corrente ou todos registros
	Default cProg  := "FINA090"

	dbSelectArea(cAliasA)
	If "FINA090" $ Upper(Funname())
		dbSetOrder(1)
	Endif

	nTamMark	:= oMark:oBrowse:nLen

	If lGeral
		lMsg := .F.
		(cAliasA)->(DbGoTop())
	Else
		lMsg := .T.
	Endif

	If lGeral
		If MsgYesNo( STR0077 ) //"Gostaria que desmarque os titulos cujo Fornecedor possua Adiantamento ou Devolucao ?"
			lMarca := .T.
		Endif
	Endif

	//Como o alias pode ser um query, temporário, o campo de FILORIG pode não estar presente
	lTemFilOg := (cAliasA)->( ColumnPos( "E2_FILORIG" ) ) > 0

	While .T.

		// Condicao para sair do While - Troca de todos Registros
		If lGeral .And. ( nPos > nTamMark )
			Exit
		Endif

		If lGeral .And. (cAliasA)->E2_OK <> cMarca
			(cAliasA)->(DbSkip())
			nPos++
			Loop
		Endif

		If lTemFilOg
			cFilAnt := Iif( Empty( (cAliasA)->E2_FILORIG ) , cFilAnt , (cAliasA)->E2_FILORIG )
		EndIf
		SE2->(DBGoto( (cAliasA)->NUM_REG ))
		If (cAliasA)->E2_TIPO $ MVINSS
			If !Empty(SE2->E2_TITPAI)
				If F090LocINA( SE2->E2_TITPAI )
					If lMsg
						cMsg += STR0184	 //"Existem titulos de INSS retidos em pagamentos antecipados ainda pendentes de compensação para este fornecedor, efetua a baixa mesmo assim?"
					EndIf
					lRet := .F.
					nBusca := 9
				Endif
			Endif
		Else
			If lF240 .And. Select("__SE2") == 0
				ChkFile("SE2",.F.,"__SE2")
			EndIf

			nPosBusca := aScan(aBuscaAD, {|x| Alltrim(x[1]+x[2]+x[3]) == Alltrim((cAliasA)->E2_FILIAL+(cAliasA)->E2_FORNECE+(cAliasA)->E2_LOJA)})
			If nPosBusca == 0
				nBusca := F090BuscAD( "__SE2", (cAliasA)->E2_FORNECE, (cAliasA)->E2_LOJA )
				aAdd(aBuscaAD,{(cAliasA)->E2_FILIAL,(cAliasA)->E2_FORNECE,(cAliasA)->E2_LOJA,nBusca} )
			Else
				nBusca := aBuscaAD[nPosBusca][4]
			EndIf

			If lMsg .And. nBusca <> 0
				cMsg := STR0078 //"O Fornecedor para este titulo possui "
			Endif

			Do Case
				Case nBusca == 1 // Adiantamento
					lRet := .F.
					If lMsg
						cMsg += STR0079 //"Adiantamento."
					Endif
				Case nBusca == 2 // Devolucao
					lRet := .F.
					If lMsg
						cMsg += STR0080 //"Devolucao."
					Endif
				Otherwise
					lRet  := .T.
			End Case

		EndIf

		If lGeral .And. nBusca <> 0
			lErro := .T.
			If lMarca .And. (cAliasA)->E2_OK == cMarca .and. (cAliasA)->(MsRLock())
				If cProg == "FINA090"
					Fa090Inverte(cAliasA,cMarca,oValor,oQtda,.F.,oMark)	
				ElseIf cProg == "FINA240"
					FA240Inverte(cMarca,oValor,oQtda,.F.,cAliasA)
				Endif
			Endif

			// Adiciona Array de LOG.
			Aadd( aLog, { 	(cAliasA)->E2_PREFIXO, (cAliasA)->E2_NUM    , (cAliasA)->E2_PARCELA, (cAliasA)->E2_TIPO,;
							(cAliasA)->E2_SALDO  , (cAliasA)->E2_FORNECE, (cAliasA)->E2_LOJA} )
		Endif

		// Usuario define se seleciona registro com Adiantamento ou Devolucao.
		If !lRet .And. lMsg
			cMsg += CRLF
			cMsg += STR0081 //"Deseja mesmo assim seleciona-lo ?"
			If MsgYesNo( cMsg )
				lRet := .T.
				If lf090log
					ExecBlock( "F090LOG",.F.,.F.) // Ponto de Entrada para gravação do log.
				EndIf
			Else
				lRet := .F.
			Endif
		Else
			lRet := .T.
		Endif

		(cAliasA)->(DbSkip())
		nPos++

		// Condicao para sair do While - Troca do Registro atual
		If !lGeral
			Exit
		Endif
	Enddo

	cFilAnt := cFilBckp
	RestArea( aArea )
	RestArea( aAreaAlias )

	oValor:Refresh()
	oQtda:Refresh()
	oMark:oBrowse:Refresh(.T.)

	If lGeral
		lVldAD := .T.
		If !lErro
			MsgInfo(STR0082) //"Nao existem titulos selecionados, cujos Fornecedores possuam Adiantamento ou Devolucao."
		Else
			If MsgYesNo( STR0083 ) //"Gostaria de imprimir a lista de titulos cujos Fornecedores possuam Adiantamento ou Devolucao ?"
				F090PrtLog( aLog, cProg )
			Endif
		Endif
	Else
		lVldAD := .F.
	Endif

Return( lRet )


//-------------------------------------------------------------------------
/*/{Protheus.doc} F090BuscAD
Funcao que Busca para o fornecedor passado se existem Adiantamentos ou devolucoes 

@Param cAliasB	, Character , Alias utilizado para seleção de títulos
@Param cFor		, Character , Fornecedor
@Param cLoj		, Character , Loja

@Return nRet	, Numeric	, Número de adiantamentos existentes para
								o fornecedor

@author Mauricio Pequim Jr
@since  07/10/2021
@version 12.1.30
/*/
//-------------------------------------------------------------------------
Function F090BuscAD( cAliasB As Character, cFor As Character, cLj As Character ) As Numeric
	Local aArBusca		As Array
	Local nRet			As Numeric
	Local cIndexC		As Character
	Local cCondicao1	As Character
	Local cKey1  	 	As Character
	Local lMultFil		As Logical
	Local nIndexC		As Numeric
	Local cFilter		As Character
	Local lFiliais		As Logical
	Local lPaBx			As Logical
	Local nRegB			As Numeric
	Local cCompSE2	    As Character
	Local cCompSA2	    As Character
	Local aIndReg		As Array
	Local cChave		As Character
	
	Default cAliasB		:= ""
	Default cFor		:= ""
	Default cLj 		:= ""

	aArBusca			:= GetArea()
	nRet				:= 0
	cIndexC				:= ""
	cCondicao1			:= ""
	cKey1  	 			:= ""
	lMultFil			:= .F.
	nIndexC				:= 0
	cFilter				:= ""
	lFiliais			:= FunName() $ "FINA240|FINA090" //Utilizado pelas rotinas que possuem conceito de multi-filiais
	lPaBx				:= .F.
	nRegB				:= 0
	cCompSE2	    	:= FwModeAcces("SE2",1)
	cCompSA2	    	:= FwModeAcces("SA2",1)
	aIndReg				:= {}
	cChave				:= ""

	If Select(cAliasB) <= 0
		SomaAbat("","","","P")
	EndIf

	If __lF090ADFR = NIL
		__lF090ADFR	:= ExistBlock("F090ADFR")
		__lF090PABX	:= ExistBlock("F090PABX")
	Endif

	nRegB := (cAliasB)->(Recno())
	If !Empty(cAliasB) .And. !Empty(cFor) .And. !Empty(cLj)

		cFilter := (cAliasB)->(DbFilter())

		//-----------------------F090PABX----------------------------
		// Ponto de entrada utilizado para verificação da existência 
		// de títulos do tipo PA de um determinado fornecedor 
		// sem considerar a loja.
		//-----------------------------------------------------------
		If __lF090PABX
			lPaBx := ExecBlock("F090PABX",.F.,.F.)
		EndIf

		dbSelectArea(cAliasB)
		dbSetOrder(6)
		If dbSeek( xFilial("SE2")+ cFor + cLj )
			cIndexC := CriaTrab(nil,.f.)
			If !lFiliais
				cCondicao1 	:= "(E2_TIPO $ '"+MV_CPNEG + "/" + MVPAGANT+ "')"
				cCondicao1 	+= ' .AND. E2_SALDO > 0 '

				cKey1	   	:= "E2_FILIAL+E2_FORNECE"+iif(!lpaBx,"+E2_LOJA","")
				cChave 		:= xFilial("SE2")+cFor+iif(!lpaBx,cLj,"")
			Else
				cCondicao1 	:= "E2_FILIAL >= '  ' .And. E2_FILIAL <= 'ZZ' .And. "
				cCondicao1 	+= "(E2_TIPO $ '"+MV_CPNEG + "/" + MVPAGANT+ "')"
				cCondicao1 	+= ' .AND. E2_SALDO > 0 '
				
				cKey1	   	:= "E2_FORNECE"+iif(!lpaBx,"+E2_LOJA","")
				cChave 		:= cFor+iif(!lpaBx,cLj,"")
			EndIf

			//-----------------------F090ADFR----------------------------
			// Ponto de Entrada para manipulação o filtro que
			// seleciona os registros de abatimentos do fornecedor.
			//-----------------------------------------------------------
			If __lF090ADFR
				aIndReg := ExecBlock("F090ADFR", .F., .F., {cCondicao1,lMultFil})
				if len(aIndReg) > 1
					cCondicao1 := aIndReg[1]
					lMultFil := aIndReg[2]

					cKey1	:= iif(!lMultFil,"E2_FILIAL+"  ,"")	+"E2_FORNECE"	+iif(!lpaBx,"+E2_LOJA","")
					cChave 	:= iif(!lMultFil,xFilial("SE2"),"")	+cFor			+iif(!lpaBx,cLj,"")
				endif
			EndIf

			IndRegua(cAliasB,cIndexC,cKey1,,cCondicao1,STR0025) //"Selecionando Registros..."
			nIndexC := RetIndex("SE2",cAliasB)
			dbSelectArea(cAliasB)
			dbSetOrder(nIndexC + 1 )

			(cAliasB)->(dbSeek(cChave))

			While (cAliasB)->(!Eof()) .And. cChave == (cAliasB)->(&cKey1)
				// So Processa titulos
				// com saldo
				If (cAliasB)->E2_SALDO <= 0
					dbSkip()
					Loop
				Endif

				// Adiantamento
				If (cAliasB)->E2_TIPO $ MVPAGANT
					If cCompSE2 != cCompSA2 .And. xFilial("SE2") != (cAliasB)->E2_FILIAL .And. !lMultFil
						nRet := 0
					Else
						nRet := 1
					EndIf
				Endif

				// Devolucao
				If (cAliasB)->E2_TIPO $ MV_CPNEG
					nRet := 2
				Endif

				// Adiantamentos já relacionados com Pedidos
				if FinAdtSld("P", SE2->( (cAliasB)->(E2_FORNECE + E2_LOJA + E2_PREFIXO + E2_NUM + E2_PARCELA + E2_TIPO) ))
					nRet := 0
				Endif

				If nRet <> 0
					Exit
				Endif

				(cAliasB)->(DbSkip())
			EndDo
		EndIf
	EndIf

	//-----------------------------------------------------------
	// Recupera a Integridade dos dados   
	//-----------------------------------------------------------
	RetIndex("SE2",cAliasB)
	DbSelectArea(cAliasB)
	Set Filter to &cFilter
	(cAliasB)->(DbGoTo(nRegB))
	RestArea( aArBusca )
	FwFreeArray(aArBusca)
	FwFreeArray(aIndReg)

Return( nRet )


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F090PrtLog
Imprime array com informacoes dos titulos cujos Fornecedores possuem Adiantamentos ou Devolucoes.

@Param aPrtLog	, Array		, Array com o Log a ser impresso
@Param cProg	, Character	, Código da Rotinas que está chamando

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Static Function F090PrtLog( aPrtLog, cProg )

	Local cDesc1	:= STR0084 //"Imprime relacao de titulos selecionados para baixa, "
	Local cDesc2	:= STR0085 //"cujos Fornecedores possuam Adiantamento ou Devolucao."
	Local cDesc3	:= ""
	Local titulo	:= STR0086 //"Tit. com Adiantamento ou Devolucao."
	Local nLin		:= 80
	Local Cabec1	:= PadR("Prefixo", 8 ) + PadR("Numero", 15) + PadR("Parcela", 10 ) + PadR("Tipo", 17 ) + ;
					   PadR("Valor", 20) + " - " + PadR("Fornecedor", 15 ) + PadR("Loja", 4)
	Local Cabec2	:= ""
	Local aOrd 		:= {}

	Private lEnd		:= .F.
	Private lAbortPrint	:= .F.
	Private limite		:= 80
	Private tamanho		:= "M"
	Private nomeprog	:= cProg
	Private nTipo		:= 18
	Private aReturn		:= { "Zebrado", 1, "Administracao", 2, 2, 1, "", 1 }
	Private nLastKey	:= 0
	Private cbtxt		:= Space(10)
	Private cbcont		:= 00
	Private CONTFL		:= 01
	Private m_pag		:= 01
	Private wnrel		:= nomeprog
	Private cString 	:= ""

	wnrel := SetPrint( cString, NomeProg, "", @titulo, 		cDesc1, cDesc2, cDesc3, .T., aOrd, .T., Tamanho, , .T. )

	If nLastKey == 27
		Return
	EndIf

	SetDefault( aReturn, cString)

	If nLastKey == 27
		Return
	Endif

	nTipo := If( aReturn[4] == 1, 15, 18 )

	RptStatus({|| RunReport(Cabec1,Cabec2,Titulo,nLin,aPrtLog) },Titulo)
Return


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RunReport
Imprime o relatório

@Param Cabec1	, Character	, Cabeçalho 1 do relatório
@Param Cabec2	, Character	, Cabeçalho 2 do relatório
@Param Titulo	, Character	, Titulo do relatório
@Param nLin		, Numérico	, Número de linhas por página
@Param aPL		, Array		, Array com o Log a ser impresso

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Static Function RunReport(Cabec1,Cabec2,Titulo,nLin,aPL)

	Local nP		:= 0
	Local nTamLog	:= Len(aPL)
	Local cPict		:= PesqPict("SE2","E2_SALDO")

	SetRegua( nTamLog )

	For nP := 1 To nTamLog

		// Verifica o cancelamento pelo usuario...
		If lAbortPrint
			@nLin,00 PSAY STR0087 //"*** CANCELADO PELO OPERADOR ***"
			Exit
		Endif

		// Impressao do cabecalho do relatorio.
		If nLin > 55 // Salto de Página. Neste caso o formulario tem 55 linhas...
			Cabec(Titulo,Cabec1,Cabec2,NomeProg,Tamanho,nTipo)
			nLin := 8
		Endif

		@ nLin,01 PSAY aPL[nP][1] // Prefixo (8)
		@ nLin,08 PSAY aPL[nP][2] // Numero Tit (15)
		@ nLin,23 PSAY aPL[nP][3] // Parcela (10)
		@ nLin,33 PSAY aPL[nP][4] // Tipo (5)
		@ nLin,38 PSAY aPL[nP][5] Picture cPict // Saldo (20)
		@ nLin,58 PSAY " - "
		@ nLin,61 PSAY aPL[nP][6] // Fornecedor (15)
		@ nLin,76 PSAY aPL[nP][7] // Loja Fornecedor (4)

		nLin := nLin + 1 // Avanca a linha de impressao

	Next nP

	SET DEVICE TO SCREEN

	If aReturn[5]==1
		dbCommitAll()
		SET PRINTER TO
		OurSpool(wnrel)
	Endif

	MS_FLUSH()

Return


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} fa090CX
Funcao que abre ou não o get do nro de cheque na baixa

@Param cBanco	, Character	, Banco
@Param lBord	, Logical	, Informa se é uma baixa de Borderô

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Static Function fa090CX(cBanco, lBord)
	Local lRet := .T.
	Default __cMVCARTEIR := GetMv("MV_CARTEIR")
	// Nao habilita o numero de cheque para :
	// Banco Caixa, Carteira ou Motivo igual a D‚bito em C/C
	If SubStr(cBanco,1,2) == "CX"  	     .or. ;
		cBanco $ __cMVCARTEIR		     .or. ;
		TrazCodMot(cMotBx) $ "DEB/DAC"   .or. ;
		! ChqMotBx(cMotBx)				 .or. ;
		(lBord .And. GetMv("MV_CHQBOR") == "N")
		lRet := .F.
	Endif
Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} MenuDef
Utilizacao de menu Funcional

Parametros do array aRotina
1. Nome a aparecer no cabecalho
2. Nome da Rotina associada
3. Reservado
4. Tipo de Transação a ser efetuada:
	1 - Pesquisa e Posiciona em um Banco de Dados
	2 - Simplesmente Mostra os Campos
	3 - Inclui registros no Bancos de Dados
	4 - Altera o registro corrente
	5 - Remove o registro corrente do Banco de Dados
5. Nivel de acesso
6. Habilita Menu Funcional

@author Ana Paula N. Silva
@version P12
@since   29/11/2006
@return  Array com opcoes da rotina.
/*/
//-------------------------------------------------------------------
Static Function MenuDef()
	Local aRotina := {}
	If cPaisLoc == "BRA"
		aRotina	:=	{	{ STR0057, "AxPesqui"   ,0,1,,.F.},;	// "Pesquisar"
						{ STR0001,"fA090Par"    ,0,1},;  		// "Parƒmetros"
						{ STR0002,"fA090Aut"    ,0,3},;			// "Autom tica"
						{ STR0136,"FA090CAUT"   ,0,5},;			// "Cancelamento Automático de Baixas"
						{ STR0134,"CTBC662"     ,0,7},;			// "Tracker Contábil"
						{ STR0061,"FA040Legenda",0,6, ,.F.} }
	Else
		aRotina	:=	{	{ STR0057,"fA090Busca"	,0,1,,.F.},;	// "Pesquisar"
						{ STR0001,"fA090Par"	,0,1},;			// "Parƒmetros"
						{ STR0002,"fA090Aut"	,0,3},;			// "Autom tica"
						{ STR0058,"fA090Can"	,0,2},;			// "Cancela Chq"
						{ STR0136,"FA090CAUT"   ,0,5},;			// "Cancelamento Automático de Baixas"
						{ STR0134,"CTBC662"     ,0,7},;			// "Tracker Contábil"
						{ STR0061,"FA040Legenda",0,6, ,.F.} }	// "Legenda"
	EndIf
	//Rateio Multinatureza
	If FindFunction("F050CMNT") .and. MV_MULNATP
		aAdd( aRotina,	{ STR0162 ,"F050CMNT()", 0 , 2})	//"Consulta Rateio Multi Naturezas"
	Endif
	
	If cPaisLoc == "BRA"
		Aadd(aRotina, {STR0178,"FINCRET('SE2')", 0, 2}) //'Consulta de Retenções'
	EndIF

Return(aRotina)


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA090PcoLan
Verifica e efetua o bloqueio na confirmacao da tela de baixa automatica, se utilizada a integracao 
e configuracao de lancamento de bloqueio do SIGAPCO.

@Param cMarca	, Character	, Indica que o titulo/bordero esta marcado


@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function FA090PcoLan(cMarca)

Local lRet	:= .T.
Local aArea := GetArea()
Default __lUsaPCO	:= SuperGetMV("MV_PCOINTE",.F.,"2") =="1"

If __lUsaPCO
	(cAliasSE2)->(dbSetOrder(__nIdxE2OK))
	(cAliasSE2)->(dbSeek(cMarca))
	SE2->(DBGOTO((caliasSE2)->NUM_REG))

	Do While (cAliasSE2)->(!Eof() .AND. E2_OK == cMarca)
		SE2->(DBGOTO((caliasSE2)->NUM_REG))
		RegToMemory("SE2",.F.)
		lRet := PcoVldLan("000006","01","FINA090")
		If !lRet
			Exit
		EndIf
		(cAliasSE2)->(dbSkip())
	EndDo

	RestArea( aArea )
Endif

Return lRet


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinA090T
Chamada semi-automatica utilizado pelo gestor financeiro

@Param aParam	, Array	, Parametros da rotina

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function FinA090T(aParam)
	cRotinaExec := "FINA090"
	ReCreateBrow("SE2",FinWindow)
	FinA090(aParam[1])
	ReCreateBrow("SE2",FinWindow)
	dbSelectArea("SE2")

	INCLUI := .F.
	ALTERA := .F.

Return .T.


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} fa090BcoCx
Correção do número de cheque para banco caixa

@Param cBco090	, Character , Código do banco
@Param cAge090	, Character , Código da agência
@Param cCta090	, Character , Código do borderô final
@Param cCheq090	, Character , Código do cheque 

@Return lRet	, Logical	, Informa se a validação foi positiva ou não

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Function fa090BcoCx(cBco090, cAge090, cCta090, cCheq090)

	Local lRet := .T.
	Default __lFa090Bco	:= ExistBlock("FA090BCO")
	Default __cMVCARTEIR := GetMv("MV_CARTEIR")

	If SubStr(cBco090,1,2) == "CX" .or. cBco090 $ __cMVCARTEIR
		cCheq090 := Space(15)
		If Type("oCheque")=="O"
			oCheq090:Refresh()
		Endif
	Endif

	If __lFa090Bco
		lRet := ExecBlock("FA090BCO", .F., .F., {cBco090,cAge090,cCta090})
	Endif

Return lRet


//---------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} VldBanco
Valida se o motivo de baixa gera movimento bancário.
Caso não gere, limpa os campos 

@Param cMotBx	, Character , Motivo da Baixa
@Param cBco090	, Character , Código do banco
@Param cAge090	, Character , Código da agência
@Param cCta090	, Character , Código do borderô final
@Param cCheq090	, Character , Código do cheque 

@Return lRet	, Logical	, Informa se a validação foi positiva ou não

@author  Mauricio Pequim Jr
@since   06/10/2021
@version P12
/*/
//---------------------------------------------------------------------------------------------------------
Static Function VldBanco( cMotBx, cBco090, cAge090, cCta090 )
	
	Local lReturn := MovBcoBx(cMotBx,.T.)

	If !lReturn
		cBco090 := CriaVar( "A6_COD"     )
		cAge090 := CriaVar( "A6_AGENCIA" )
		cCta090 := CriaVar( "A6_NUMCON"  )
	EndIf
Return lReturn


//-------------------------------------------------------------------
/*/{Protheus.doc} Fa090Juri(lTodos, lPrimeiro)
Rotina para verifica se tem integracao com o SIGAPFS e realiza
realiza as validacoes da integracao.

@param lTodos    Se .T. indica se foi precionada a opção de selecionar todos os título
@param lPrimeiro  Quando encontrar o primeiro título que não atenda a validação e
					exibir a mensagem, retorna por referencia que não serão exibidas
					novas mensagens caso ocorram inconsistencias nos próximos títulos.

@Return lRet   .T. Se o título é valido para ser manipulado.

@author Luciano Pereira dos Santos
@since 09/10/2017
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function Fa090Juri(lTodos, lPrimeiro)
Local lRet      := .T.

Default lTodos    := .F.
Default lPrimeiro := .T.
Default __lIntSJURI := SuperGetMv("MV_JURXFIN",.T.,.F.)

If __lIntSJURI .And. FindFunction("JVldBxPag")
	lRet := JVldBxPag(SE2->(RECNO()), lTodos, @lPrimeiro)
EndIf

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} F090IsCaixa
Rotina para montar string com os códigos dos caixas do SIGALOJA,
Financeiro e bancos Carteira

@Return cStringCX   String contendo os códigos dos caixas

@author pequim
@since 20/10/2021
@version 1.0
/*/
//-------------------------------------------------------------------
Function F090IsCaixa(lFormatIN as Logical)
	
	Local nX AS Numeric
	Local nLen23 AS Numeric
	Local cMV_CXFIN AS Character
	Local cStringCX AS Character

	DEFAULT lFormatIN := .F.
	DEFAULT __cMVCARTEIR := GetMv("MV_CARTEIR")

	nX := 0
	nLen23 := 0

	cStringCX := ""

	If __aTab23 == NIL
		__aTab23 := FWGetSX5("23")
	Endif

	nLen23 := Len(__aTab23)

	For nX := 1 to nLen23
		cStringCX += Substr(__aTab23[nX,3],1,3)
		If nX != nLen23
			cStringCX += "/"
		Endif
	Next

	cMV_CXFIN 	:= Left(SuperGetMV("MV_CXFIN"),TamSX3("A6_COD")[1])

	If !Empty(cMV_CXFIN)
		cStringCX += "/" + cMV_CXFIN
	Endif	

	If !Empty(__cMVCARTEIR)
		cStringCX += "/" + __cMVCARTEIR
	Endif

	cStringCX := F90FORMATIN( cStringCX, lFormatIN ) 

Return cStringCX


//-------------------------------------------------------------------
/*/{Protheus.doc} FA090StChq
Filtro p/ Mbrowse do Controle de Cheques.  
Equador/Rep. Dominicana/Argentina

@author Wagner Montenegro
@since 30/09/2010
@version 1.0
/*/
//-------------------------------------------------------------------
Function FA090StChq(cBusca)
	Local lRet := .F.
	Local nOrdSEF:=SEF->(IndexOrd())
	SEF->(DbSetOrder(6))
	If SEF->(DBSeek(cBusca))
		If SEF->EF_IMPRESS=="S" .AND. (SEF->EF_STATUS=="03" .OR. SEF->EF_STATUS=="01")
			lRet:=.T.
		Endif
	Endif
	SEF->(DbSetOrder(nOrdSEF))

Return(lRet)


//-------------------------------------------------------------------
/*/{Protheus.doc} FA090VldMt
Validação dos Motivos de Cancelamento do Cheque 
Equador/Rep. Dominicana/Argentina

@author Wagner Montenegro
@since 30/09/2010
@version 1.0
/*/
//-------------------------------------------------------------------
Function FA090VldMt(nRecOld,lAnular)
	Local lRet :=.F.
	Local nRegMot:=SEF->(Recno())
	Local cInfoForn:="."
	Local aFina050:={}
	SEF->(DbGoTo(nRecOld))
	If SEF->EF_STATUS $ "01|04"
		If cChvLbx $ "11/12"
			If FRF->(DbSeek(xFilial("FRF")+SEF->EF_BANCO+SEF->EF_AGENCIA+SEF->EF_CONTA+SEF->EF_PREFIXO+SEF->EF_NUM+cChvLbx))
				MsgAlert(STR0103+cChvLbx+STR0104) //"O motivo '"+cChvLbx+"' já foi registrado para este cheque."
			Else
				If cChvLbx $ "12"
					If FRF->(DbSeek(xFilial("FRF")+SEF->EF_BANCO+SEF->EF_AGENCIA+SEF->EF_CONTA+SEF->EF_PREFIXO+SEF->EF_NUM+"11"))
						If cPaisLoc != "BRA" .and. lAnular
							SA2->(DbSetOrder(1))
							If SA2->(DbSeek(xFilial("SA2")+SEF->EF_FORNECE+SEF->EF_LOJA))
								cInfoForn:="["+SA2->A2_COD+"-"+SA2->A2_LOJA+" "+Rtrim(SA2->A2_NOME)+"]."
							Endif
							Help(" ",1,"HELP",STR0127,STR0128+cInfoForn,1,0)//"FA090 - DEVOLUCAO CHEQUE"   //"O cancelamento deste cheque gera automaticamente uma NDI a favor do fornecedor"
							If MsgYesNo(STR0129) //"Confirma a geração de NDI?"
								aAdd(aFina050,  {"E2_PREFIXO" , GetMv("MV_FINPXE2")  , Nil})
								aAdd(aFina050,  {"E2_NUM"     ,"" , Nil})//GetSx8Num("SE2","FINPRDB")    , Nil})
								aAdd(aFina050,  {"E2_TIPO"    , 'NDI'           , Nil})
								aAdd(aFina050,  {"E2_NATUREZ" , SEF->EF_NATUR   , Nil})
								aAdd(aFina050,  {"E2_FORNECE" , SA2->A2_COD		, Nil})
								aAdd(aFina050,  {"E2_LOJA"    , SA2->A2_LOJA    , Nil})
								aAdd(aFina050,  {"E2_EMISSAO" , dDataBase 		, Nil})
								aAdd(aFina050,  {"E2_VENCTO"  , dDataBase			, Nil})
								aAdd(aFina050,  {"E2_VALOR"   , SEF->EF_VALOR   , Nil})
								aAdd(aFina050,  {"E2_VLCRUZ"  , SEF->EF_VALOR   , Nil})
								aAdd(aFina050,  {"E2_ORIGEM"  , "FINA095"		   , Nil})
								aAdd(aDados050,aFina050)
								lRet:=.T.
							Endif
						Else
							lRet:=.T.
						Endif
					Else
						MsgAlert(STR0105) //"O motivo '11' não consta para este cheque"
					Endif
				Else
					lRet:=.T.
				Endif
			Endif
		Else
			lRet:=.T.
		Endif
	Else
		lRet:=.T.
	Endif
	SEF->(DbGoTo(nRegMot))
	lTOk:=lRet
Return(lRet)


//-------------------------------------------------------------------
/*/{Protheus.doc} F090NLOTE
Verificar a chamada do ponto de entrada F090NLOTE   

@Param nTipoBx	, Numeric	, Tipo de Baix: 1 = Título ou 2 = Borderô
@Param cBord090I, Character , Código do borderô inicial
@Param cBord090F, Character , Código do borderô final

@author Leandro Sousa
@since 30/09/2010
@version 1.0
/*/
//-------------------------------------------------------------------
Function F090NLOTE(nTipoBx,cBord090I,cBord090F)
	Local lF090NLote := ExistBlock ("F090NLOTE")

	IF lF090NLote
		ExecBlock ("F090NLOTE",.F.,.F.,{nTipoBx,cBord090I,cBord090F})
	EndIf

Return .T.


//-------------------------------------------------------------------
/*/{Protheus.doc} F090CHQOK
Ponto de entrada para a confirmaçao da baixas automaticas 
ao utilizar o botao ok da tela de seleçao dos titulos.

@author Leandro Sousa
@since 30/09/2010
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function F090CHQOK()
	Local lF090CHOK := ExistBlock("F090CHOK")
	Local lRetorno  := .T.

	If lF090CHOK
		lRetorno := ExecBlock("F090CHOK",.F.,.F.)
	Endif

Return lRetorno


//-------------------------------------------------------------------
/*/{Protheus.doc} F090NLOTE
Ponto de entrada para a confirmaçao da baixas automaticas 
ao utilizar o botao ok da tela de seleçao dos titulos.

@author Leandro Sousa
@since 30/09/2010
@version 1.0
/*/
//-------------------------------------------------------------------
Function FA090TPCH(cChave)

	Local aArea := GetArea()
	Local aAreaFRE := {}
	Local cRetorno := "1"

	DbSelectArea("FRE")

	aAreaFRE := FRE->(GetArea())

	FRE->(DbSetOrder(3)) //FRE_FILIAL+FRE_BANCO+FRE_AGENCI+FRE_CONTA+FRE_TALAO
	If FRE->(DbSeek(xFilial("FRE")+cChave))
		cRetorno := FRE->FRE_TIPO
	EndIf

	RestArea(aArea)
	RestArea(aAreaFRE)

Return cRetorno


//-------------------------------------------------------------------
/*/{Protheus.doc} F090LocINA
Funcao que Busca para o titulo passado se existem 
Adiantamentos de INSS

@author Andre Lago
@since 14/05/2012
@version 1.0
@params cPai, Character, titulo para pesquisa
/*/
//-------------------------------------------------------------------
Function F090LocINA(cPai)	
	Local aArBusca	As Array
	Local aSE2 	 	As Array
	Local lRet		As Logical
	Local cQry		As Character
	Local lFiliais	As Logical    //Utilizado pelas rotinas que possuem conceito de multi-filiais
	Local cFor	    As Character
	Local cLj 	    As Character
	Local nI		As Numeric
	Local cTblTmp	As Character

	Default cPai	:= ""

	aArBusca := GetArea()
	aSE2 	 := SE2->(GetArea())
	lRet	 := .F.
	cQry	 := ""
	lFiliais := FunName() $ "FINA240|FINA090"
	cFor	 := ""
	cLj 	 := ""
	nI		 := 0
	cTblTmp	 := ""

	If !Empty(cPai)

		dbSelectArea("SE2")
		dbSetOrder(1)
		If dbSeek( xFilial("SE2")+cPai )
			cFor := SE2->E2_FORNECE
			cLj  := SE2->E2_LOJA

			If __oTemINA == Nil
				cQry := "SELECT SE2.E2_FILIAL, SE2.E2_PREFIXO, SE2.E2_NUM, SE2.E2_PARCELA, SE2.E2_TIPO, SE2.E2_FORNECE, SE2.E2_LOJA, SE2.E2_PARCINS, SE2.E2_SALDO FROM " + RetSqlName("SE2") + " SE2 "
				cQry += "INNER JOIN " + RetSqlName("SE2") + " SE2A ON "
				cQry += "SE2.E2_FILIAL = SE2A.E2_FILIAL AND "
				cQry += "SE2.E2_PREFIXO = SE2.E2_PREFIXO AND "
				cQry += "SE2.E2_NUM = SE2A.E2_NUM AND "
				cQry += "SE2.E2_PARCINS = SE2A.E2_PARCELA "
				cQry += "WHERE "
				If !lFiliais
					cQry += "SE2.E2_FILIAL = ? AND "
				EndIf
				cQry += "SE2.E2_FORNECE = ? AND "
				cQry += "SE2.E2_LOJA = ? AND "
				cQry += "SE2.E2_INSS > 0 AND "
				cQry += "SE2.E2_SALDO > 0 AND "
				cQry += "SE2.E2_TIPO IN " + F90FORMATIN(MVPAGANT+"/"+MV_CPNEG) + " AND "
				cQry += "SE2A.E2_TIPO = 'INA' AND "
				cQry += "SE2A.E2_SALDO > 0 AND "
				cQry += "SE2.D_E_L_E_T_ = ' ' AND "
				cQry += "SE2A.D_E_L_E_T_ = ' ' "

				cQry := ChangeQuery(cQry)
				__oTemINA := FWPreparedStatement():New(cQry)
			EndIf

			nI := 1
			If !lFiliais
				__oTemINA:SetString(nI,xFilial("SE2",SE2->E2_FILORIG) )
				nI++
			Endif
			__oTemINA:SetString(nI, cFor)
			nI++
			__oTemINA:SetString(nI, cLj)

			cQry := __oTemINA:GetFixQuery()
			cTblTmp := MpSysOpenQuery(cQry)

			If (cTblTmp)->(!Eof())
				lRet := .T.
			EndIf

			(cTblTmp)->(dbCloseArea())
		EndIf
	EndIf

	// Recupera a Integridade dos dados
	RestArea(aSE2)
	RestArea(aArBusca)
	FwFreeArray(aSE2) 
	FwFreeArray(aArBusca)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F090PagINA
Funcao que Busca para o titulo passado se existem Movimentos 
bancarios para os Adiantamentos de INSS

@author Andre Lago
@since 14/05/2012
@version 1.0
/*/
//-------------------------------------------------------------------
Function F090PagINA( cPai )

	Local aArBusca	:= GetArea()
	Local lRet		:= .F.
	Local cAliasB   := "SE5"

	Default cPai	:= ""

	If !Empty(cPai)

		dbSelectArea(cAliasB)
		dbSetOrder(7)
		dbSeek( cPai )

		While !Eof() .And. cPai == (cAliasB)->(E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA )

			If TemBxCanc((cAliasB)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ))
				(cAliasB)->(Dbskip())
				Loop
			Endif
			lRet := ((cAliasB)->E5_RECPAG == "P" .and. (cAliasB)->E5_SITUACA <> "C")
			If lRet
				Exit
			EndIf
			dbSkip()

		EndDo

	EndIf

	RestArea( aArBusca )

Return( lRet )


//-------------------------------------------------------------------
/*/{Protheus.doc} RetPCC241
Rotina para verificar se o bordero baixado ja possui retencao 
via FINA241, com registro E5_MOTBX = 'PCC'.
Neste caso o registro SE5 deve constar como ja retido em bordero (4)

@author Clovis Magenta
@since 22/02/2013
@version 1.0
/*/
//-------------------------------------------------------------------
Function RetPCC241( cSequencia , cNumBor )
	Local aArea		:= GetArea()
	Local lAchou	:= .F.
	Local xSeqAnt	:= Val(cSequencia)-1
	Local cQuery 	:= ""

	xSeqAnt	:= Strzero(xSeqAnt, TamSx3("E5_SEQ")[1] )

	If __oPrepared == nil

		cQuery 	:= " SELECT E5_DOCUMEN FROM "+RetSqlName("SE5")+" WHERE "
		cQuery 	+= " E5_DOCUMEN = ? "
		cQuery 	+= " AND E5_MOTBX = ? "
		cQuery 	+= " AND E5_PREFIXO = ?"
		cQuery 	+= " AND E5_NUMERO = ? "
		cQuery 	+= " AND E5_PARCELA = ?"
		cQuery 	+= " AND E5_CLIFOR = ?"
		cQuery 	+= " AND E5_LOJA = ?"
		cQuery 	+= " AND E5_TIPO = ? "
		cQuery 	+= " AND E5_SITUACA != ?"
		cQuery 	+= " AND E5_SEQ = ?"
		cQuery 	+= " AND (E5_PRETPIS = ? OR E5_PRETCSL = ? OR E5_PRETCOF = ?)"
		cQuery 	+= " AND E5_FILORIG = ? "
		cQuery 	+= " AND D_E_L_E_T_=' ' "
		cQuery 	:= ChangeQuery(cQuery)
		__oPrepared:=FWPreparedStatement():New(cQuery)
	Endif

	__oPrepared:SetString(1,cNumBor)
	__oPrepared:SetString(2,"PCC")
	__oPrepared:SetString(3,SE2->E2_PREFIXO)
	__oPrepared:SetString(4,SE2->E2_NUM)
	__oPrepared:SetString(5,SE2->E2_PARCELA)
	__oPrepared:SetString(6,SE2->E2_FORNECE)
	__oPrepared:SetString(7,SE2->E2_LOJA)
	__oPrepared:SetString(8,SE2->E2_TIPO)
	__oPrepared:SetString(9,"C")
	__oPrepared:SetString(10,xSeqAnt)
	__oPrepared:SetString(11,"4")
	__oPrepared:SetString(12,"4")
	__oPrepared:SetString(13,"4")
	__oPrepared:SetString(14,SE2->E2_FILORIG)
	cQuery:=__oPrepared:GetFixQuery()

	lAchou := !Empty(MpSysExecScalar(cQuery,"E5_DOCUMEN"))
	RestArea(aArea)

Return lAchou


//-------------------------------------------------------------------
/*/{Protheus.doc} F090RcSE5
Retorna o RecNo do título principal conforme array populado
caso contrário retorna  posição da SE5 se a mesma estiver posicionada

@author Daniel Mendes
@since 31/10/2014
@version 1.0
/*/
//-------------------------------------------------------------------
Static Function F090RcSE5(aRecNosSE5)
	Local nRecSE5 := 0

	If !Empty( aRecNosSE5 )
		nRecSE5 := aRecNosSE5[ Len( aRecNosSE5 ) ]
	Else
		If !SE5->(Eof()) .And. !SE5->(Bof())
			nRecSE5 := SE5->(RecNo())
		EndIf
	EndIf

Return nRecSE5


//-------------------------------------------------------------------
/*/{Protheus.doc} DtValVcto
Funcion para validar fecha de vencimiento.   

@author Ivan Michael Gomez
@since 22/08/2016 
@version 1.0
/*/
//-------------------------------------------------------------------
Function DtValVcto(dDtVctoSub)

	If dDtVctoSub > Ddatabase + 360
		dDtVctoSub = dDataBase + 1
		MsgAlert(STR0158) //"La fecha de Vencimiento no puede exceder los 360 días de la fecha de emisión"
		lTipo := .F.
	ElseIf dDtVctoSub < dDataBase + 1
		dDtVctoSub = dDataBase + 1
		MsgAlert(STR0157) //"La fecha de Vencimiento debe ser mayor a la Fecha de emisión"
		lTipo := .F.
	Else
		lTipo := .T.
	EndIf

Return lTipo


//-------------------------------------------------------------------
/*/{Protheus.doc} f091QryA

Faz a query de filtro dos titulos

@author Karen Honda
@since 22/09/2017
@version P12
/*/
//-------------------------------------------------------------------
Static Function F090QryA(aSelFil,aTMPFil,aCampos,aEstruct,nTipoBX,cBord090I,cBord090F,cBco090,cAge090,cCta090)

	Local cQuery := ""
	Local cFiltro := ''				

	DEFAULT aEstruct := {}
	IF !EMPTY(aEstruct)
		// Constroi a clausula de filtro da seleção
		cFiltro := FA090ChecF(nTipoBx,cBord090I,cBord090F,aSelFil,aTMPFil,cBco090,cAge090,cCta090)
		cQuery  := "SELECT "
		aEval(aEstruct,{|x| cQuery += x[1] + ", "})
		If cPaisLoc = "ARG"
			cQuery += "SE2.R_E_C_N_O_ NUM_REG "
			cQuery += "FROM " + RetSqlName("SE2") + " SE2 "
			cQuery += "INNER JOIN " + RetSqlName("SEF") + " ON E2_PREFIXO||E2_NUM = EF_PREFIXO||EF_NUM AND E2_BCOCHQ||E2_AGECHQ||E2_CTACHQ = EF_BANCO||EF_AGENCIA||EF_CONTA "
			cQuery += "WHERE "
			cQuery += "SE2.D_E_L_E_T_ = ' ' AND "
		Else
			cQuery += "R_E_C_N_O_ NUM_REG "
			cQuery += "FROM " + RetSqlName("SE2") + " "
			cQuery += "WHERE "
			cQuery += "D_E_L_E_T_ = ' ' AND "
		EndIf
		cQuery += cFiltro + " "
		If cPaisLoc = "ARG"
			cQuery += "AND EF_STATUS = '03'"
		Endif
		cQuery += "ORDER BY " + SqlOrder(SE2->(indexkey()))
		cQuery := ChangeQuery(cQuery)

		cArqNew := F090MTTMP(cQuery,aCampos,aEstruct,cBord090I,cBord090F,@cBco090,@cAge090,@cCta090,nTipoBx)
	ENDIF

Return cArqNew

//-------------------------------------------------------------------
/*/{Protheus.doc} F090MTTMP

Monta a temporaria da query

@author Karen Honda
@since 22/09/2017
@version P12
/*/
//-------------------------------------------------------------------
Static Function F090MTTMP(cQuery,aCampos,aEstruct,cBord090I,cBord090F,cBco090,cAge090,cCta090,nTipoBx)

	Local nTcSql		:= 0
	Local aArea			:= GetArea()
	Local cQuery2		:= ''
	Local cCampos		:= ''
	Local cChave		:= ""
	Local nTamEFNUM		:= TamSX3('EF_NUM')[1]

	DEFAULT nTipoBx  	:= 1
	DEFAULT cBord090I	:= ""
	DEFAULT cBord090F	:= ""
	DEFAULT __F090VLEX  := ExistBlock("F090VLEX")
	DEFAULT __lTemMR	:= FTemMotor()

	If aScan(aEstruct, {|x| Alltrim(UPPER(x[1])) == Alltrim(UPPER("NUM_REG"))}) == 0
		AADD(aEstruct,{"NUM_REG","N",10,0})
	Endif

	AADD(aEstruct,{"VLSOMAABAT","N",14,2})
	AADD(aEstruct,{"HASCLCABAT","C",1,0})
	AADD(aEstruct,{"HASCLCTRIB","C",1,0})
	AADD(aEstruct,{"IMPCONF","C",250,0})

	If __oFIN0901 <> Nil
		//-- Limpa registros para nova execução
		cAliasSE2 := __oFIN0901:GetAlias()		
		nTcSql := TcSQLExec("DELETE FROM "+__oFIN0901:GetRealName())
		If nTcSql < 0
			//-- Se ocorrer algum problema refaz a temporaria
			__oFIN0901:Delete()
			__oFIN0901 := Nil
		else
			(cAliasSE2)->(dbGoTo(1))
		Endif
	EndIF	
	IF __oFIN0901 == Nil
		// Criação da Tabela Temporária >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
		__oFIN0901 := FWTemporaryTable():New( cAliasSE2 )
		__oFIN0901:SetFields(aEstruct)
		__oFIN0901:AddIndex("1", {"E2_FILIAL","E2_PREFIXO","E2_NUM","E2_PARCELA","E2_TIPO"})
		__oFIN0901:AddIndex(TRIM(STR(__nIdxE2OK)), {"E2_OK","E2_FILIAL","E2_PREFIXO","E2_NUM","E2_PARCELA","E2_TIPO"})
		__oFIN0901:AddIndex("3", {"NUM_REG"})
		__oFIN0901:AddIndex("4", TTFtIndex(StrToKarr(SE2->(indexkey()),"+"))) // Indice Ativo na Browse

		__oFIN0901:Create()
	EndIF

	cQuery2 := " INSERT "
	If ALLTRIM(tcGetdb()) == "ORACLE"
		cQuery2 += " /*+ APPEND */ "
	Endif

	aEval(aEstruct,{|x| cCampos += If( 'E2_' $ x[1] .OR. 'IMPOSTOS' == x[1], ALLTRIM(x[1]) + ',', '')})

	cCampos += ' NUM_REG'

	If AllTrim(TcGetDb()) == "DB2"
		cQuery := STRTRAN( cQuery, "FOR READ ONLY", "" )
	EndIf
	cQuery2 += " INTO "+__oFIN0901:GetRealName()+" ("+cCampos+") " + STRTRAN(cQuery,'IMPOSTOS','0 AS IMPOSTOS')

	Processa({|| nTcSql := TcSQLExec(cQuery2)})

	If nTcSql < 0   
		If ExistFunc("FinxMsgE")
			FinxMsgE(TCSQLError())            
		Else
			Help(" ",1,"F090MTTMP",, STR0167+ CRLF + CRLF + TCSQLError() ,1,0) //"Não foi possivel montar a tabela temporaria, favor verificar o seu ambiente Protheus."
		EndIf	
	EndIf

	(cAliasSE2)->(DBSETORDER(4))
	(cAliasSE2)->(DBGOTOP())
	// ---------------------------------------------------------------------------------------

	While !(cAliasSE2)->(EOF())

		SE2->(DBGoto((cAliasSE2)->NUM_REG))

		If cPaisLoc=="BRA"

			// Se for um titulo de adiantamento, verifica se existem cheques nao liberados, pois se existir, nao permitir a baixa
			// Isso ocorre quando o parametro MV_LIBCHEQ esta igual a N, foi gerado um cheque para o adiantamento e este
			// ainda nao foi liberado
			If Alltrim(SE2->E2_TIPO) $ MVPAGANT
				SEF->(DbSetOrder(3))
				SEF->(MsSeek(xFilial("SEF")+(cAliasSE2)->( E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+Pad(E2_NUMBCO,nTamEFNUM) )))
				If SEF->EF_LIBER == "N"
					(cAliasSE2)->(DbDelete())
					(cAliasSE2)->(DbSkip())
					Loop
				EndIf
			EndIf

			// Para o Brasil, apresenta somente os titulos cuja moeda e' a mesma do banco selecionado para baixa.
			// Caso a moeda do banco estiver vazia ou caso o motivo de baixa nao movimente banco, considero apenas a moeda forte
			If FXMultSld()
				If nMoedaBco > 1 .And. MovBcoBx(cMotBx,.T.)
					If !FXVldBxBco(cBco090,cAge090,cCta090,(cAliasSE2)->E2_NATUREZ, (cAliasSE2)->E2_MOEDA,.F.)
						(cAliasSE2)->(DbDelete())
						(cAliasSE2)->(DbSkip())
						Loop
					EndIf
				Endif
			EndIf

		EndIf

		If cPaisLoc $ "ARG|DOM|EQU" .and. FUNNAME()=="FINA095"
			If cPaisLoc=="ARG"
				cChave := xFilial('SEF') + "P" + cBco090 + cAge090 + cCta090 + SUBSTR((cAliasSE2)->E2_NUM,1,nTamEFNUM) + (cAliasSE2)->E2_PREFIXO
			Else
				cChave := xFilial('SEF') + "P" + cBco090 + cAge090 + cCta090 + SUBSTR((cAliasSE2)->E2_NUMBCO,1,nTamEFNUM) + (cAliasSE2)->E2_PREFIXO
			Endif

			If !FA090StChq(cChave)
				(cAliasSE2)->(DbDelete())
				(cAliasSE2)->(DbSkip())
				Loop
			EndIf

		Endif

		//Retenções geradas na emissão
		If __lTemMR
			(cAliasSE2)->IMPOSTOS := FMRGETRET("P", "SE2")
		Endif

		//Ponto de Entrada para tratamentos específicos de exclusão dos registros
		If (__F090VLEX)
			Execblock("F090VLEX", .F., .F., {cMotBx, nTipoBx, nMoedaBco})
		EndIf

		(cAliasSE2)->(DbSkip())
	EndDo

	RestArea(aArea)

Return cAliasSE2


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F090Clean

Limpa o objeto da temporarytable

@Author	Karen Yoshie Honda
@since	29/08/2017
/*/
//-----------------------------------------------------------------------------------------------------
Static Function F090Clean()

If __oTemINA <> Nil
    __oTemINA:Destroy()
    FwFreeObj(__oTemINA)
    __oTemINA := Nil
Endif

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa090Display

Atualiza a flag na tabela temporaria após atualização da SE2

@Author	Karen Yoshie Honda
@since	29/08/2017
/*/
//-----------------------------------------------------------------------------------------------------
Static Function Fa090Display(cAliasSE2,cMarca,lInverte,oValor,oQtda,cArquivo,lBaixa)
	FinaDisplay(cMarca,lInverte,oValor,oQtda,cArquivo,,lBaixa)

	If (cAliasSE2)->(MsRLock())
		(cAliasSE2)->E2_OK	:= SE2->E2_OK
		(cAliasSE2)->(MsUnlock())
	EndIf
Return


//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F090GETABAT
Esta função Verifica se o calculo da função SumAbatPag() já foi efetuado para o registro atual de cAliasSE2
@type function
@author Karen Yoshie Honda
@since 04/08/2017
@version 1.0
@return $numerico, $Valor de Abatimento do título posicionado, caso houver.
@example
	nTotAbat := F090GETABAT()
/*/
//-----------------------------------------------------------------------------------------------------------------------
STATIC Function F090GETABAT() As Numeric
	Local nRet		as NUMERIC

	//Inicialização
	nRet	:= 0

	IF (cAliasSE2)->HASCLCABAT == '1'
		nRet := (cAliasSE2)->VLSOMAABAT
	Else
		nRet := SumAbatPag(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_FORNECE, SE2->E2_MOEDA, "V", SE2->E2_BAIXA, SE2->E2_LOJA)
		(cAliasSE2)->VLSOMAABAT := nRet
		(cAliasSE2)->HASCLCABAT := '1'
	EndIf

Return nRet


//-------------------------------------------------------------------
/*/{Protheus.doc} F090GetCampos
Preenche 2 arrays de campos, sendo: 1 para exibição em MarkBrowse e 1 para criação de tabela temporaria.
@author  Norberto Monteiro de Melo
@since   12/01/2018
@version P12
/*/
//-------------------------------------------------------------------
STATIC FUNCTION F090GetCampos(aCampos as ARRAY, aEstruct as ARRAY )

	Local cIndex As Character
	Local cCampoSX3 As Character
	Local aRestrict As Array
	Local nX As Numeric
	Local aFields As Array

	Default aCampos  	:= {}	// Campos para o MarkBrowse - Deve ser passado por referência
	Default aEstruct 	:= {}	// Campos para a tabela temporária - Deve ser passado por referência
	Default __lTemMR	:= FTemMotor()
	Default __cLstImp	:= If (__lTemMR, FSE2ColImp(), "")
	DEFAULT __cLayout	:= FWSM0Layout()
	DEFAULT __lGestao	:= "E" $ __cLayout .Or. "U" $ __cLayout
	DEFAULT __cFilSE2	:= IIF( __lGestao , FwFilial("SE2") , xFilial("SE2") )

	//campos do indice do browse
	cIndex := SE2->(INDEXKEY())
	aRestrict := StrToKArr(cIndex,'+')
	cCampoSX3 := ""
	nX := 0
	aFields := SE2->(dbStruct())
	
	For nX := 1 To Len(aRestrict)
		aRestrict[nX] := FinExtCpo("SE2",aRestrict[nX])
	Next

	AADD(aCampos,{"E2_OK","","  ",""})
	AADD(aEstruct,{"E2_OK","C",2,0})

	// Sempre adiciona o campo E2_FILIAL na estrutura
	AADD(aEstruct,{"E2_FILIAL",GetSx3Cache("E2_FILIAL","X3_TIPO"),GetSx3Cache("E2_FILIAL","X3_TAMANHO"),GetSx3Cache("E2_FILIAL","X3_DECIMAL")})
	// Apenas adiciona o campo E2_FILIAL se SE2 estiver exclusiva.
	If !Empty( __cFilSE2 ) .Or. X3USO(GetSx3Cache("E2_FILIAL","X3_USADO")) .And. cNivel >= GetSx3Cache("E2_FILIAL","X3_NIVEL")
		AADD(aCampos,{"E2_FILIAL","",GetSx3Cache("E2_FILIAL","X3_TITULO"),GetSx3Cache("E2_FILIAL","X3_PICTURE")})
	EndIf

	For nX := 1 to Len(aFields)

		cCampoSX3 := AllTrim(Upper(aFields[nX,1]))

		//Campo E2_FILIAL já inserido anteriormente garantindo que fique na primeira posição após o E2_OK
		If !(cCampoSX3 $ "E2_FILIAL|E2_OK")
			// Processa o restante das colunas adicionando aquelas que passam pela regra.
			If ( (ASCAN(aRestrict,{|x| AllTrim(Upper(x)) == cCampoSX3 }) > 0) .Or. ;
				(aFields[nX,2] != "M" .And. X3USO(GetSx3Cache(aFields[nX,1],"X3_USADO")) .AND. ;
				cNivel >= GetSx3Cache(aFields[nX,1],"X3_NIVEL") .And. GetSx3Cache(aFields[nX,1],"X3_CONTEXT") != "V" ) .Or.;
				AllTrim(aFields[nX,1]) $ "E2_SALDO|E2_NUMBCO|E2_FATURA|E2_FATPREF|E2_NUMBOR" )

				IF !(TRIM(aFields[nX,1]) $ __cLstImp)
					AADD(aCampos,{aFields[nX,1],"",GetSx3Cache(aFields[nX,1],"X3_TITULO"),GetSx3Cache(aFields[nX,1],"X3_PICTURE")})
				ENDIF

				AADD(aEstruct,{aFields[nX,1],aFields[nX,2],aFields[nX,3],aFields[nX,4]})

				IF Trim(aFields[nX,1]) == "E2_VALOR"
					AADD(aCampos ,{'IMPOSTOS','','Retenções',GetSx3Cache(aFields[nX,1],"X3_PICTURE")})
					AADD(aEstruct,{'IMPOSTOS',aFields[nX,2],aFields[nX,3],aFields[nX,4]})
				ENDIF
			Endif
		Endif	
	Next nX 

RETURN NIL


//-------------------------------------------------------------------
/*/{Protheus.doc} F090VldImp()
Cálculo dos impostos a serem retidos
@author  Sivaldo Oliveira
@since 23/02/2018
@version 12
/*/
//-------------------------------------------------------------------
Static Function F090VldImp(lCancel As Logical)
	Local nZ As Numeric
	Local nImpos As Numeric
	Local nBasMR As Numeric
	Local aImpos As Array
	Local aBasMR As Array
	Local aImpConf As Array
	Local nCasDec as Numeric
	Local lBordero As Logical
	Local aBaseImp As Array
	Local nBaseDif As Numeric
	Local cIdFK0 As Character
	Local cChaveTit As Character

	Default lCancel := .F.

	//Inicilaiza variaveis
	nZ := 0
	nImpos := 0
	nBasMR := 0
	aImpos := {}
	aBasMR := {}
	aImpConf := {}
	nCasDec := (MsDecimais(1) + 1)
	lBordero := !Empty(SE2->E2_NUMBOR) .AND. ("FINA241" $ SEA->EA_ORIGEM)
	aBaseImp := {}
	nBaseDif := 0
	cIdFK0 := ""
	__aImpMR := {}
	__lPccMR := .F.
	__lIrfMR := .F.
	__lInsMR := .F.
	__lIssMR := .F.
	__lCidMR := .F.
	__lSesMR := .F.
	__nPisMR := 0
	__nCofMR := 0
	__nCslMR := 0
	__nIrfMR := 0
	__nInsMR := 0
	__nIssMR := 0
	__nCidMR := 0
	__nSesMR := 0
	__nImpMR := 0

	//Valida quais os impostos configurados pelo motor de retenções
	If !SE2->E2_TIPO $ MVPAGANT+"|"+MVABATIM+"|"+MVPROVIS+"|"+MV_CPNEG+"|"+MVTAXA+"|"+MVTXA+"|INA"
		aImpConf := FinImpConf("1", SE2->E2_FILORIG, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ, SE2->E2_TIPO)
		nImpos := Len(aImpConf)

		For nZ := 1 To nImpos
			Do Case
			Case aImpConf[nZ,1] $ "PIS|COF|CSL"
				__lPccMR := .T.
				__lPccBxMR := aImpConf[nZ,2] == "2"
			Case aImpConf[nZ,1] == "IRF"
				__lIrfMR := .T.
			Case aImpConf[nZ,1] == "INSS"
				__lInsMR := .T.
			Case aImpConf[nZ,1] == "ISS"
				__lIssMR := .T.
			Case aImpConf[nZ,1] == "CIDE"
				__lCidMR := .T.
			Case aImpConf[nZ,1] == "SEST"
				__lSesMR := .T.
			OtherWise
				_lImpMR := .T.
			EndCase

			//Retenção na primeira baixa
			If aImpConf[nZ,7] == "1"
				nBaseDif := SE2->E2_VALOR

				If SE2->E2_MOEDA > 1
					nBaseDif := NoRound(xMoeda(nBaseDif, SE2->E2_MOEDA, 1, dBaixa, nCasDec, SE2->E2_TXMOEDA), nCasDec)
				EndIf

				Aadd(aBaseImp, {aImpConf[nZ,1], nBaseDif})
			EndIf
		Next nZ

		//busca chave p/ verificar se já houve retenção, se conf retenção na 1ª baixa
		cChaveTit := xFilial("SE2", SE2->E2_FILORIG)+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA

		//Impostos gerado pelo fiscal
		If nImpos == 0
			nImpos := Len(aImpConf := FinImpFis(cChaveTit, SE2->E2_FILORIG, "SE2", .F., 0, Nil, SE2->E2_FORNECE, SE2->E2_LOJA))
		EndIf
	EndIf

	If !lCancel .And. !lBordero .And. nImpos > 0
		/*--------------------------------------------------
		Estrutura da aBasMR
		[1] = base de retenção
		[2] = Imp retidos na emissão motor de retenção
		[3] = Imp retidos Bx.MR e antigo que recompoem base
		----------------------------------------------------*/
		nBasMR := SE2->E2_SALDO

		aBasMR := FinBaseMR(nBasMR, .F., SE2->E2_FILIAL, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA,;
			__lPccMR, __lIrfMR, __lInsMR, __lIssMR, __lCidMR, __lSesMR, SE2->E2_MOEDA, SE2->E2_TXMOEDA, dBaixa)

		For nZ := 1 To Len(aBasMR)
			nBasMR := aBasMR[nZ]
			exit
		Next nZ

		If SE2->E2_MOEDA > 1
			nBasMR := NoRound(xMoeda(nBasMR, SE2->E2_MOEDA, 1, dBaixa, nCasDec, SE2->E2_TXMOEDA), nCasDec)
		EndIf

		If Len(aBaseImp) > 0
			cIdFK0 := FINGRVFK7("SE2", cChaveTit)
		EndIf

		//Cálculo motor de retenções.
		aImpos := FINCalImp("1", SE2->E2_NATUREZ, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_FILORIG, nBasMR, dBaixa, .T., aBaseImp, SE2->E2_TIPO, cChaveTit, cIdFK0, {})
		nImpos := Len(aImpos)

		For nZ := 1 To nImpos
			If (aImpos[nZ,9] != "2")
				Loop
			EndIf

			//Vlr de imps a ser abatido do valor a de pagto
			__nImpMR += aImpos[nZ,5]

			//Variáveis para gravar os Vrets.
			Do Case
			Case aImpos[nZ,8] == "PIS"
				__nPisMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "COF"
				__nCofMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "CSL"
				__nCslMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "IRF"
				__nIrfMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "INSS"
				__nInsMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "ISS"
				__nIssMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "CIDE"
				__nCidMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "SEST"
				__nSesMR += aImpos[nZ,5]
			EndCase
		Next nZ

		__nBasLeg := nBasMR

		__aImpMR := Aclone(aImpos)
	EndIf

Return Nil


//-------------------------------------------------------
/*/ Fa090BnkVl
Valida o banco selecionando quando integração SIGAPFS x SIGAFIN está ativa.

@Param cTipo    Indica se é campo Banco (1), Agência (2) ou Conta(3)
@param cBanco, Código do banco.
@param cAgencia, Agência do banco.
@param cNumCont, Conta do banco.

@author Bruno Ritter
@since 30/07/2018
@version P12
*/
//-------------------------------------------------------
Static Function Fa090BnkVl(cTipo, cBanco, cAgencia, cNumCont)
Local lRet     := .T.
Local cEscrit  := ""

	If __lJFilBco
		cEscrit := JurGetDados("NS7", 4, xFilial("NS7") + cFilant + cEmpAnt, "NS7_COD")
		lRet := JurVldSA6(cTipo, {cEscrit, cBanco, cAgencia, cNumCont})
	EndIf

Return lRet

/*/{Protheus.doc} F090DetPro
Função centralizadora para prepar lançamentos contábeis de acordo
com a filial logada.
@type function
@version 12
@author gabriel.asantos
@since 22/09/2022
/*/
Static Function F090DetPro( nHdlPrv AS Character, cPadrao AS Character, cPrograma AS Character,; 
							cLote AS Character, nLinha AS Numeric, lExecuta AS Logical,;
							cCriterio AS Character, aFlagCTB AS Array, cFilCorr as Character,; 
							cFilOriCtb as Character ) AS Numeric
	
	Local cFilBkp AS Character
	Local nTotal AS Numeric

	Default nHdlPrv 	:= 0
	Default cPadrao		:= "531"
	Default cLote		:= ""
	Default cPrograma	:= "FINA090"
	Default nLinha		:= 0
	Default lExecuta	:= .T.
	Default cCriterio	:= "FINA090"
	Default aFlagCTB	:= {}
	Default cFilCorr	:= cFilAnt
	Default cFilOriCtb	:= cFilAnt

	cFilBkp := cFilAnt
	
	//Prepara lançamento na filial logada
	IF mv_par08 == 1
		cFilAnt := cFilCorr
	Else
		cFilAnt := cFilOriCtb
	ENDIF
	
	nTotal := DetProva(nHdlPrv,cPadrao,cPrograma,cLote,nLinha,lExecuta,cCriterio,,,,,@aFlagCTB,,)

	//Restaura filial para não afetar os movimentos da SE5
	cFilAnt := cFilBkp
	
Return nTotal

/*/{Protheus.doc} F090Contab
Função centralizadora para efetivar lançamentos contábeis de acordo
com a filial logada.
@type function
@version 12
@author gabriel.asantos
@since 22/09/2022
/*/
Static Function F090Contab( cArquivo AS Character, nHdlPrv AS Numeric, cLote AS Character,; 
							lDigita AS Logical, lAglut AS Logical, dDtLanc AS Date, aFlagCTB AS Array,;
							aDiario AS Array, cFilCorr AS Character, cFilOriCtb AS Character)
	
	Local cFilBkp AS Character

	Default cArquivo 	:= ""
	Default nHdlPrv 	:= 0
	Default cLote		:= ""
	Default lDigita		:= IIF(mv_par01==1,.T.,.F.)
	Default lAglut		:= IIF(mv_par02==1,.T.,.F.)
	Default dDtLanc		:= dDataBase
	Default aFlagCTB	:= {}
	Default aDiario		:= {}
	Default cFilCorr	:= cFilAnt
	Default cFilOriCtb	:= cFilAnt
	
	cFilBkp := cFilAnt
	
	//Prepara lançamento na filial logada
	IF mv_par08 == 1
		cFilAnt := cFilCorr
	Else
		cFilAnt := cFilOriCtb
	ENDIF
	
	cA100Incl(cArquivo,nHdlPrv,,cLote,lDigita,lAglut,,dDtLanc,,@aFlagCTB,,aDiario)

	//Restaura filial para não afetar os movimentos da SE5
	cFilAnt := cFilBkp
Return

//-------------------------------------------- CANCELAMENTO AUTOMATICO DE BAIXAS -----------------------------------------------------------------

//--------------------------------------------------------------------------------------
/*/{Protheus.doc}FA090CAUT
Filtros para montagem do grid de Títulos a Pagar, visando cancelamento das suas baixas
@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//--------------------------------------------------------------------------------------
Function FA090CAUT(cAlias,cCampo,nOpcE,aM,aTitulos)

Local cBord1 	:= Space(6)
Local cBord2 	:= Space(6)
Local cDatB1 	:= CTOD("//")
Local cDatB2 	:= CTOD("//")
Local cFor1	 	:= Space(6)
Local cFor2  	:= Space(6)
Local nX 	 	:= 0
Local nRadio	:= 1
Local nOpca		:= 0
Local aRadio	:= {}
Local aSelFil	:= {}
Local aTmpFil	:= {}
Local lSelFil	:= .F.
Local oSize		:= NIL
Local oDlg1		:= NIL
Local oSelFil	:= NIL
Local oPanel1 	:= NIL
Local oMasterPanel := NIL
Local bProcessa
Local nTamaTits	:= 0
Local lAutomato := .F.

Private oBord1 	:= NIL
Private oBord2 	:= NIL
Private oDatB1 	:= NIL
Private oDatB2 	:= NIL
Private oFor1 	:= NIL
Private oFor2 	:= NIL

DEFAULT aTitulos := {}

nTamaTits := Len(aTitulos)
lAutomato := FindFunction("GetParAuto") .AND. nTamaTits > 0

If !lAutomato
	aAdd(aRadio, STR0066)	//"Títulos"
	aAdd(aRadio, STR0067)	//"Borderôs"

	DEFINE MSDIALOG oDlg1 TITLE STR0137 OF oMainWnd PIXEL FROM 050,010 TO 324,340 // "Cancelamento Automático de Baixas a Pagar"

	//Defino o tamanho dos componentes através do método FwDefSize(), amarrando ao objeto oDlg
	oSize := FwDefSize():New(.F.,,,oDlg1)

	oSize:lLateral := .F.
	oSize:lProp := .T.
	oSize:AddObject("MASTER",100,100,.T.,.T.)
	oSize:Process()

	//Instancio um painel "master" como container
	oMasterPanel := TPanel():New(oSize:GetDimension("MASTER","LININI"),oSize:GetDimension("MASTER","COLINI"),;
					,oDlg1,,,,,,oSize:GetDimension("MASTER","XSIZE"),oSize:GetDimension("MASTER","YSIZE"),.F.,.F.)

	oPanel1 := TPanel():New(0,0,'',oMasterPanel,, .T., .T.,, ,115,115,.f.,.f. )
	oPanel1:Align := CONTROL_ALIGN_ALLCLIENT

	@ 05,005 TO 117,158 PROMPT ""  PIXEL OF oPanel1

	@ 06,010 TO 33,150 PROMPT STR0138 PIXEL OF oPanel1		//  "Cancelar Baixas"
	@ 12,063 RADIO oRadio VAR nRadio ITEMS aRadio[1],aRadio[2]  SIZE 080,209 PIXEL OF oPanel1 ON CHANGE Fa090Radio(nRadio,@cBord1,@cBord2,@cDatB1,@cDatB2,@cFor1,@cFor2)

	@ 35,010 SAY STR0139	SIZE 555,10 PIXEL OF oPanel1  	// "Borderô De"
	@ 43,010 MSGET oBord1 	VAR cBord1	PICTURE  "@S6"  OF oPanel1  SIZE 060,10 PIXEL

	@ 35,085 SAY STR0140	SIZE 555,10 PIXEL OF oPanel1  // "Borderô Até"
	@ 43,085 MSGET oBord2	VAR cBord2	PICTURE  "@S6"  OF oPanel1  SIZE 060,10 PIXEL

	@ 55,010 SAY STR0141	SIZE 555,10 PIXEL OF oPanel1	//"Dt. Baixa De"
	@ 63,010 MSGET oDatB1	VAR cDatB1	   PICTURE "@!"	   OF oPanel1 SIZE 060,10 PIXEL HASBUTTON

	@ 55,085 SAY STR0142	SIZE 555,10 PIXEL 	OF oPanel1	//"Dt. Baixa Ate"
	@ 63,085 MSGET oDatB2	VAR cDatB2	PICTURE "@!"	   OF oPanel1 SIZE 060,10 PIXEL HASBUTTON

	@ 75,010 SAY STR0143	SIZE 555,10 PIXEL OF oPanel1	// "Fornecedor De"
	@ 83,010 MSGET oFor1	VAR cFor1   F3 "FOR" 	PICTURE "@!"  OF oPanel1  SIZE 060,10 PIXEL HASBUTTON

	@ 75,085 SAY STR0144	SIZE 555,10 PIXEL OF oPanel1	//"Fornecedor Ate"
	@ 83,093 MSGET oFor2	VAR cFor2	F3 "FOR"    PICTURE "@!"  OF oPanel1  SIZE 060,10 PIXEL HASBUTTON

	@ 100,010 CHECKBOX oSelFil VAR lSelFil PROMPT "" SIZE 11,11 OF oPanel1 PIXEL
	@ 100,020 SAY STR0168 SIZE 50, 07 OF oPanel1 PIXEL	//"Seleciona Filiais"

	DEFINE SBUTTON FROM 120,093 TYPE 1 ACTION (nOpca := 1,If(Fa090ValOk(nRadio,cBord1,cBord2,cDatB1,cDatB2,cFor1,cFor2), oDlg1:End(), nOpca:=0))  ENABLE OF oPanel1
	DEFINE SBUTTON FROM 120,122 TYPE 2 ACTION oDlg1:End()  ENABLE OF oPanel1

	oDatB1:disable()
	oDatB2:disable()
	oFor1:disable()
	oFor2:disable()
	oBord1:disable()
	oBord2:disable()

	If Empty(cFor2)
		cFor2 := Replicate("Z",Len(SE2->E2_FORNECE))
		cBord2 := Replicate("Z",Len(SEA->EA_NUMBOR))
	Endif

	ACTIVATE MSDIALOG oDlg1 CENTERED ON INIT Fa090Radio(nRadio,@cBord1,@cBord2,@cDatB1,@cDatB2,@cFor1,@cFor2)

Else	
	If nTamaTits > 0
		nRadio		:= aTitulos[1] //1 = Cancela Baixa de titulos titulos 	2 = cancela baixa somente titulos em bordero
		cBord1		:= aTitulos[2] // Borderõ De
		cBord2 		:= aTitulos[3] // Borderô Até
		cDatB1		:= aTitulos[4] // Dt. Baixa Inicial
		cDatB2		:= aTitulos[5] // Dt. Baixa Final
		cFor1		:= aTitulos[6] // Fornecedor De
		cFor2		:= aTitulos[7] // Fornecedor Até
		aSelFil		:= aTitulos[8] // Array com as filiais a serem consideradas na seleção dos titulos
		nOpca 		:= 1
	Endif
Endif

If nOpca == 1
	pergunte(__cPerg,.F.)

	bProcessa := {|| FA090STIT(nRadio, aSelFil, aTmpFil, lSelFil, cBord1, cBord2, cDatB1, cDatB2, cFor1, cFor2, lAutomato)}
	IF !lAutomato
		If lSelFil
			// Seleção de filiais
			aSelFil := AdmGetFil(, .F., "SE2")
			If Len( aSelFil ) <= 0
				nOpca := 0
			Endif
		Else
			aSelFil := {cFilAnt}
		EndIf
		If nOpca != 0
			Processa(bProcessa)
		Endif
	Else
		Eval(bProcessa)
	Endif
EndIF

For nX := 1 TO Len(aTmpFil)
	CtbTmpErase(aTmpFil[nX])
Next

Return


//---------------------------------------------------------------------
/*/{Protheus.doc}Fa090Radio
Validacao do RadioButtom - Tela de Filtros para selecao dos dados -
Cancelamento Automatico Baixas Titulo a Pagar

@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//---------------------------------------------------------------------
Static Function Fa090Radio(nRadio,cBord1,cBord2,cDatB1,cDatB2,cFor1,cFor2)

cBord1 := Space(TamSX3("EA_NUMBOR")[1])
cBord2 := Replicate("Z",TamSX3("EA_NUMBOR")[1] )

If nRadio == 1		//Opção TITULO
   	oDatB1:enable()
	oDatB2:enable()
	oFor1:enable()
	oFor2:enable()
	oBord1:disable()
	oBord2:disable()

	cDatB1 := dDataBase
	cDatB2 := dDataBase
	cFor1 := Space(TamSX3("E2_FORNECE")[1])
	cFor2 := Replicate("Z",TamSX3("E2_FORNECE")[1] )
    oDatB1:SetFocus()
Else				//Opção BORDERO
	oDatB1:disable()
	oDatB2:disable()
	oFor1:disable()
	oFor2:disable()
	oBord1:enable()
	oBord2:enable()

	cDatB1 := CtoD("01/01/1980","ddmmyy")
	cDatB2 := CtoD("31/12/2099","ddmmyy")
	cFor1 := Space(TamSX3("E2_FORNECE")[1])
	cFor2 := Replicate("Z",TamSX3("E2_FORNECE")[1])
	oBord1:SetFocus()
Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc}Fa090ValOk
Validacao dos Gets - Tela de Filtros para selecao dos dados -
Cancelamento Automatico Baixas Titulos a Pagar

@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//---------------------------------------------------------------------
Static Function Fa090ValOk(nRadio,cBord1,cBord2,cDatB1,cDatB2,cFor1,cFor2)

Local lRet := .T.

// Valida todos os gets
If Empty(cDatB1) .or. Empty(cDatB2) .or. (cDatB2 < cDatB1)
   	MsgAlert( STR0169 , STR0146 )	//"Por favor, verifique o intervalo de datas informado."###"Validação"
    lRet := .F.
Endif

If lRet .and. Empty(cFor2)
    MsgAlert( STR0145 , STR0146 )	//"Fornecedor Até não está preenchido"###"Validação"
    lRet := .F.
Endif

If lRet .and. nRadio == 2 .and. Empty(cBord2)
    MsgAlert( STR0147 , STR0146 )   //"Borderô Até não está preenchido"###"Validação"
    lRet := .F.
Endif

If lRet .and. nRadio == 2 .and. cBord2 < cBord1
	MsgAlert( STR0170 , STR0146 )   //"Por favor, verifique o intervalo de borderôs informado."###"Validação"
	lRet := .F.
EndIf

Return lRet

//--------------------------------------------------------------------------------------
/*/{Protheus.doc}FA090STIT
FWMarkBrowse contendo os Títulos a Pagar, visando o cancelamento das suas baixas,
a partir dos Filtros escolhidos

@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//--------------------------------------------------------------------------------------
Static Function FA090STIT(nRadio, aSelFil, aTmpFil, lSelFil, cBord1, cBord2, cDatB1, cDatB2, cFor1, cFor2, lAutomato)

Local cQuery 		:= ''
Local cArqTrab 		:= ""
Local cCampos		:= ""
Local cTmpSE2Fil	:= ""
Local cMarca		:= ""
Local nX 			:= 1
Local nTcSql		:= 0
Local aStruct		:= {}
Local aDadosBx		:= {}
Local aColumns		:= {}
Local aSize			:= {}
Local aRotAtu		:= Aclone(aRotina)
Local bOk 			:= {}
Local oDlgy			:= Nil
Local oSize			:= NIL
Local oMasterPanel	:= NIL
Local oFnt2S		:= TFont():New("Arial      ",7,15,.F.,.F.,,,,,.F.) 	  //NEGRITO SUBLINHADO
Local lRet			:= .T.

Private oMrkBrowse	:= FWMarkBrowse():New()

DEFAULT nRadio		:= 0
DEFAULT aSelFil		:= {cFilAnt}
DEFAULT aTmpFil	 	:= {}
DEFAULT lSelFil	 	:= .F.
DEFAULT cBord1	 	:= ''
DEFAULT cBord2	 	:= ''
DEFAULT cDatB1 		:= ''
DEFAULT cDatB2 		:= ''
DEFAULT cFor1 		:= ''
DEFAULT cFor2 		:= ''
DEFAULT lAutomato 	:= .F.
DEFAULT __lFK7Cpos	:= FK7->(ColumnPos("FK7_CLIFOR")) > 0 .And. FindFunction("FinFK7Cpos") .And. FExecFixN("2")

aRotina := {}

F090CnStru(aStruct, @cCampos)

//Filtra baixas realizadas nos Titulos a Pagar
cQuery := " SELECT DISTINCT "
cQuery += cCampos
cQuery += "SE2.E2_OK, SE2.R_E_C_N_O_ NUM_REG "
cQuery += "FROM " + RetSqlName("FK2") + " FK2 "

//Amarracao FK2 + FK7
cQuery += "Join " + RetSqlName("FK7") + " FK7 "
cQuery += "ON ( FK7.FK7_IDDOC = FK2.FK2_IDDOC ) "

//Amarracao FK2 + FKA
cQuery += "Join " + RetSqlName("FKA") + " FKA "
cQuery += "ON ( FKA.FKA_IDORIG = FK2.FK2_IDFK2 ) "

//Amarracao FK2 + SE2
cQuery += "Join " + RetSqlName("SE2") + " SE2 "

If __lFK7Cpos
	cQuery += "ON "
	cQuery += "SE2.E2_FILIAL = FK7.FK7_FILTIT AND "
	cQuery += "SE2.E2_PREFIXO = FK7.FK7_PREFIX AND "
	cQuery += "SE2.E2_NUM = FK7.FK7_NUM AND "
	cQuery += "SE2.E2_PARCELA = FK7.FK7_PARCEL AND "
	cQuery += "SE2.E2_TIPO = FK7.FK7_TIPO AND "
	cQuery += "SE2.E2_FORNECE = FK7.FK7_CLIFOR AND "
	cQuery += "SE2.E2_LOJA = FK7.FK7_LOJA  "
Else
	//Caso o banco seja Postgres ou MySQL dever  utilizar o Concat para tratamento do trecho de compara‡?o de chave
	If ALLTRIM(tcGetdb()) == "POSTGRES" .or. ALLTRIM(tcGetdb()) == "MYSQL"
		cQuery += "ON RTRIM(CONCAT(SE2.E2_FILIAL,'|', SE2.E2_PREFIXO,'|',SE2.E2_NUM,'|',SE2.E2_PARCELA,'|',SE2.E2_TIPO,'|',SE2.E2_FORNECE,'|',SE2.E2_LOJA)) = RTRIM(FK7.FK7_CHAVE) "
	Else
		cQuery += "ON ( SE2.E2_FILIAL || '|' || SE2.E2_PREFIXO || '|' || SE2.E2_NUM || '|' || SE2.E2_PARCELA || '|' ||  SE2.E2_TIPO || '|' ||  SE2.E2_FORNECE || '|' ||  SE2.E2_LOJA = FK7.FK7_CHAVE ) "
	EndIf
Endif

cQuery += "WHERE "
cQuery += "SE2.E2_FILIAL " + GetRngFil( aSelFil, "SE2", .T., @cTmpSE2Fil )
aAdd(aTMPFil, cTmpSE2Fil)

If nRadio == 1///Opção Titulo
	cQuery += " AND FK2.FK2_DATA BETWEEN '"+ DTOS(cDatB1) +"' AND '"+ DTOS(cDatB2) +"' "
	cQuery += " AND SE2.E2_FORNECE BETWEEN '"+ cFor1 +"' AND '"+ cFor2 +"' "
Else
	cQuery += " AND SE2.E2_NUMBOR BETWEEN '"+ cBord1 +"' AND '"+ cBord2 +"' "
Endif
cQuery += " AND (SE2.E2_VALOR <> SE2.E2_SALDO)  " 				// houve baixa em algum momento
cQuery += " AND FK2.FK2_TPDOC NOT IN('ES','PA') "   			// apenas Baixas realizadas e não registros estornados
cQuery += " AND FK2.FK2_MOTBX NOT IN ('DSD','LIQ','CEC','PCC','IRF','ISS','FAT','CMP','STP','IMR','IPA') "
cQuery += " AND FK2.D_E_L_E_T_ = ' ' "
cQuery += " AND FK7.FK7_ALIAS = 'SE2' "
cQuery += " AND FK7.D_E_L_E_T_ = ' ' "
cQuery += " AND SE2.D_E_L_E_T_ = ' ' "

cQuery += " AND NOT EXISTS ("
cQuery += "SELECT A.FK2_IDDOC "
cQuery += "FROM "+RetSqlName("FK2")+" A "

cQuery += "WHERE "
cQuery += "A.FK2_FILIAL = FK2.FK2_FILIAL AND "
cQuery += "A.FK2_IDDOC = FK2.FK2_IDDOC AND "
cQuery += "A.FK2_SEQ = FK2.FK2_SEQ AND "
cQuery += "A.FK2_TPDOC = 'ES' AND "
cQuery += "A.D_E_L_E_T_ = ' ')"

cQuery := ChangeQuery(cQuery)

If __oFIN0902 <> Nil
	//-- Limpa registros para nova execução
	cArqTrab := __oFIN0902:GetAlias()
	nTcSql := TcSQLExec("DELETE FROM "+__oFIN0902:GetRealName())
	If nTcSql < 0
		//-- Se ocorrer algum problema refaz a temporaria
		__oFIN0902:Delete()
		__oFIN0902 := Nil
	Else
		(cArqTrab)->(dbGoTo(1))
	Endif
EndIF

If __oFIN0902 == Nil
	// Criação da Tabela Temporária
	cArqTrab := GetNextAlias()
	__oFIN0902 := FWTemporaryTable():New( cArqTrab )
	__oFIN0902:SetFields(aStruct)
	__oFIN0902:AddIndex("1", {"FK2_FILIAL","FK2_DATA","E2_PREFIXO","E2_NUM","E2_PARCELA","E2_TIPO", "E2_FORNECE","E2_LOJA"})
	__oFIN0902:AddIndex("2", {"FK2_OK","FK2_FILIAL","FK2_DATA","E2_PREFIXO","E2_NUM","E2_PARCELA","E2_TIPO", "E2_FORNECE","E2_LOJA"})
	__oFIN0902:AddIndex("3", {"NUM_REG"})
	__oFIN0902:AddIndex("4", {"FK2_FILIAL","FK2_IDFK2"})

	__oFIN0902:Create()
EndIf

cQuery2 := " INSERT "
If ALLTRIM(tcGetdb()) == "ORACLE"
	cQuery2 += " /*+ APPEND */ "
Endif

cCampos += 'FK2_OK, NUM_REG'

If AllTrim(TcGetDb()) == "DB2"
	cQuery := STRTRAN( cQuery, "FOR READ ONLY", "" )
EndIf

cQuery2 += " INTO " + __oFIN0902:GetRealName() + " (" + cCampos + " ) " + cQuery

If lAutomato
	nTcSql := TcSQLExec(cQuery2)
Else
	Processa({|| nTcSql := TcSQLExec(cQuery2)})
Endif

If nTcSql < 0
	If FindFunction("FinSqlLog")
		FinSqlLog("FN090" ,TCSqlError() , "TEMPORARIA_TITULOS")
		lRet := .F.
	Endif	
Endif

//Verifica se o banco esta bloqueado e deleta os registros
iF lRet .and. FindFunction("FxBcoBloq") .and. FxBcoBloq(__oFIN0902:GetRealName(),{"FK2_FILIAL","FK2_IDFK2"}) < 0
	FinSqlLog("FN090" ,TCSqlError() , "DELETE_TEMPORARIA")
	lRet := .F.
Endif

If lRet	
	cArqTrab := __oFIN0902:GetAlias()

	(cArqTrab)->(DBGOTOP())

	If (cArqTrab)->(Eof())
		If !lAutomato
			MsgAlert( STR0149 , STR0146 )	//"Não existem dados a partir dos filtros mencionados."###"Validação"
		Endif
	Else
		If !lAutomato
			//----------------MarkBrowse----------------------------------------------------
			For nX := 1 To Len(aStruct)
				If	aStruct[nX][1] $ "FK2_FILIAL|E2_PREFIXO|E2_NUM|E2_PARCELA|E2_TIPO|E2_FORNECE|E2_LOJA|E2_NOMFOR|FK2_DATA|FK2_MOTBX|FK2_VALOR"
					AAdd(aColumns,FWBrwColumn():New())
					aColumns[Len(aColumns)]:SetData( &("{||"+aStruct[nX][1]+"}") )
					aColumns[Len(aColumns)]:SetTitle(Alltrim(RetTitle(aStruct[nX][1]))  )
					aColumns[Len(aColumns)]:SetSize(6)
					aColumns[Len(aColumns)]:SetDecimal(aStruct[nX][4])

					IF aStruct[nX][1] == 'FK2_VALOR'
						aColumns[Len(aColumns)]:SetPicture(PesqPict("FK2",aStruct[nX][1]))
						aColumns[Len(aColumns)]:SetAlign('RIGHT')
					Endif
				EndIf
			Next nX

			aSize := MSADVSIZE(.F.)

			DEFINE MSDIALOG oDlgy TITLE STR0137 From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL  //'Cancelamento Automático de Baixas de Títulos a Pagar'

			//Defino o tamanho dos componentes através do método FwDefSize(), amarrando ao objeto oDlg
			oSize := FwDefSize():New(.T.,,,oDlgy)
			oSize:lLateral := .F.
			oSize:lProp := .T.
			oSize:AddObject("MASTER",100,100,.T.,.T.)
			oSize:Process()

			//Instancio um painel "master" como container
			oMasterPanel := TPanel():New(oSize:GetDimension("MASTER","LININI"),oSize:GetDimension("MASTER","COLINI"),;
									,oDlgy,,,,,,oSize:GetDimension("MASTER","XSIZE"),oSize:GetDimension("MASTER","YSIZE"),.F.,.F.)

			oPanel1 := TPanel():New(0,0,'',oMasterPanel,, .T., .T.,, ,115,115,.F.,.F. )
			oPanel1:Align := CONTROL_ALIGN_ALLCLIENT

			oMrkBrowse:SetFieldMark("FK2_OK")
			oMrkBrowse:SetOwner(oPanel1)
			oMrkBrowse:SetAlias(cArqTrab)
			oMrkBrowse:bMark     := {||FI090Mark(cArqTrab )}
			oMrkBrowse:bAllMark  := {||FA090AllMk(oMrkBrowse,cArqTrab)}
			oMrkBrowse:SetDescription("")
			oMrkBrowse:SetColumns(aColumns)
			oMrkBrowse:SetMenuDef("")
			oMrkBrowse:DisableReport("")

			oMrkBrowse:Activate()

			oMrkBrowse:SetFontBrowse(oFnt2S)
			oMrkBrowse:SetLineHeight(25)

			bOk := {||Processa({||If(F090Grava(cArqTrab,aDadosBx), IIf(Fa090ExcA(aDadosBx),(oMrkBrowse:Deactivate(), oDlgy:End()), Nil), Nil)}) }

			ACTIVATE MSDIALOG oDlgy ON INIT EnchoiceBar( oDlgy,	{|| ( Eval(bOk) ) },;
																{|| nOpca := 0,oDlgy:End()},, ) CENTER
		Else

			FA090AllMk( ,cArqTrab,lAutomato,@cMarca)
			If F090Grava(cArqTrab,aDadosBx,lAutomato,cMarca)

				Fa090ExcA(aDadosBx,.T.)
			Endif
		Endif
	EndIf

Else
	IF !lAutomato
		HELP(" ",1,"SGDBInfo",,STR0181 ,2,0,,,,,, { STR0182 })  // Ocorreu erro no comando do banco de dados. ###  Avalie o log de incosistências gerado na pasta system arquivo FR110Log.
	Endif
Endif

aRotina := Aclone(aRotAtu)

Return aDadosBx


//---------------------------------------------------------------------
/*/{Protheus.doc}F090CnStru
Estrutura da Tabela Temporária apresentados no FWMarkBorwse

@author Mauricio Pequim Jr
@since  07/10/2021
@version 12
/*/
//---------------------------------------------------------------------
Static Function F090CnStru(aStruct As Array, cCampos As Character)

	Local aAux As Array

	DEFAULT aStruct := {}
	DEFAULT cCampos	:= ""

	//Cria estrutura e tabela tmp com os campos necessarios da SE2 e FK2
	aAux := TamSx3("FK2_FILIAL")
	cCampos += "FK2_FILIAL, "
	Aadd(aStruct, {"FK2_FILIAL",aAux[3],aAux[1],0})

	aAux := TamSx3("E2_PREFIXO")
	cCampos += "E2_PREFIXO, "
	Aadd(aStruct, {"E2_PREFIXO",aAux[3],aAux[1],0})

	aAux := TamSx3("E2_NUM")
	cCampos += "E2_NUM, "
	Aadd(aStruct, {"E2_NUM"    ,aAux[3],aAux[1],0})

	aAux := TamSx3("E2_PARCELA")
	cCampos += "E2_PARCELA, "
	Aadd(aStruct, {"E2_PARCELA",aAux[3],aAux[1],0})

	aAux := TamSx3("E2_TIPO")
	cCampos += "E2_TIPO, "
	Aadd(aStruct, {"E2_TIPO"   ,aAux[3],aAux[1],0})

	aAux := TamSx3("E2_FORNECE")
	cCampos += "E2_FORNECE, "
	Aadd(aStruct, {"E2_FORNECE",aAux[3],aAux[1],0})

	aAux := TamSx3("E2_LOJA")
	cCampos += "E2_LOJA, "
	Aadd(aStruct, {"E2_LOJA"   ,aAux[3],aAux[1],0})

	aAux := TamSx3("E2_NOMFOR")
	cCampos += "E2_NOMFOR, "
	Aadd(aStruct, {"E2_NOMFOR" ,aAux[3],aAux[1],0})

	aAux := TamSx3("FK2_MOTBX")
	cCampos += "FK2_MOTBX, "
	Aadd(aStruct, {"FK2_MOTBX" ,aAux[3],aAux[1],0})

	aAux := TamSx3("FK2_DATA")
	cCampos += "FK2_DATA, "
	Aadd(aStruct, {"FK2_DATA" ,aAux[3],aAux[1],0})

	aAux := TamSx3("FK2_VALOR")
	cCampos += "FK2_VALOR, "
	Aadd(aStruct, {"FK2_VALOR" ,aAux[3],aAux[1],aAux[2]})

	aAux := TamSx3("FK7_CHAVE")
	cCampos += "FK7_CHAVE, "
	Aadd(aStruct, {"FK7_CHAVE" ,aAux[3],aAux[1],0})

	aAux := TamSx3("FK2_IDDOC")
	cCampos += "FK2_IDDOC, "
	Aadd(aStruct, {"FK2_IDDOC" ,aAux[3],aAux[1],0})

	aAux := TamSx3("FK2_FILORI")
	cCampos += "FK2_FILORI, "
	Aadd(aStruct, {"FK2_FILORI",aAux[3],aAux[1],0})

	aAux := TamSx3("FK2_IDFK2")
	cCampos += "FK2_IDFK2, "
	Aadd(aStruct, {"FK2_IDFK2" ,aAux[3],aAux[1],0})

	aAux := TamSx3("FK2_TPDOC")
	cCampos += "FK2_TPDOC, "
	Aadd(aStruct, {"FK2_TPDOC" ,aAux[3],aAux[1],0})

	aAux := TamSx3("FK2_SEQ")
	cCampos += "FK2_SEQ, "
	Aadd(aStruct, {"FK2_SEQ"   ,aAux[3],aAux[1],0})

	Aadd(aStruct, {"FK2_OK","C",2,0})
	Aadd(aStruct, {"NUM_REG","N",10,0})

Return


//---------------------------------------------------------------------
/*/{Protheus.doc}F090Grava
Faz gravação na Tabela Temporária a partir dos dados selecionados e
apresentados no FWMarkBorwse

@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//---------------------------------------------------------------------
Static Function F090Grava(cArqTrab, aDadosBx, lAutomato, cMarca)

Local lRet := .T.
Local nRecNo := 0

DEFAULT lAutomato := .F.
DEFAULT cMarca := If(lAutomato, cMarca, oMrkBrowse:cMark)
DEFAULT __cLayout	:= FWSM0Layout()
DEFAULT __lGestao	:= "E" $ __cLayout .Or. "U" $ __cLayout
DEFAULT __cFilSA6	:= IIF( __lGestao , FwFilial("SA6") , xFilial("SA6") )

dbSelectArea(cArqTrab)
nRecno := (cArqTrab)->(RecNo())

(cArqTrab)->(dbSetOrder(2))
(cArqTrab)->(DbGoTop())

If (cArqTrab)->(DbSeek(cMarca))
	While !(cArqTrab)->(Eof())
		If (cMarca $ (cArqTrab)->FK2_OK)
			(cArqTrab)->( AADD(aDadosBx,{ FK7_CHAVE, FK2_IDDOC, IF(!EMPTY(__cFilSA6),FK2_FILIAL,FK2_FILORI), FK2_IDFK2, FK2_SEQ }) )
		EndIf
		(cArqTrab)->(DbSkip())
	Enddo
EndIF

(cArqTrab)->(dbSetOrder(1))
(cArqTrab)->(DbGoTo(nRecno))

lRet := If (Len(aDadosBx) > 0, .T., .F.)

Return lRet


//---------------------------------------------------------------------
/*/{Protheus.doc}FA090AllMk
Faz gravação no cmapo FK2_OK com a marcação.
@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//---------------------------------------------------------------------
Static Function FA090AllMk(oMrkBrowse,cArqTrab,lAutomato,cMarca)

Local nReg 	 := (cArqTrab)->(Recno())

Default cMarca := oMrkBrowse:cMark

If lAutomato
	cMarca := GetMark()
EndIf

dbSelectArea(cArqTrab)
(cArqTrab)->(DbGoTop())

While !(cArqTrab)->(Eof())
	SE2->(dbGoto((cArqTrab)->NUM_REG))
	If SE2->(MsRLock()) .AND. (cArqTrab)->(MsRLock())
		IF	(cArqTrab)->FK2_OK == cMarca
			(cArqTrab)->FK2_OK := "  "
			(cArqTrab)->(MsUnlock())
			SE2->(MsUnlock())
		Else
			(cArqTrab)->FK2_OK := cMarca
		Endif
	Endif
	(cArqTrab)->(dbSkip())
Enddo

(cArqTrab)->(dbGoto(nReg))

If !lAutomato
	oMrkBrowse:oBrowse:Refresh(.t.)
Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc}
Faz gravação no cmapo FK2_OK com a marcação.
@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//---------------------------------------------------------------------
Function FI090Mark(cAliasTRB)

Local lRet		:= .T.

SE2->(dbGoto((cAliasTRB)->NUM_REG))

If SE2->(MsRLock()) .AND. (cAliasTRB)->(MsRLock())
	// destravamos o mesmo para uso de outro terminal
	If Empty( (cAliasTRB)->FK2_OK )
		(cAliasTRB)->(MsUnlock())
		SE2->(MsUnlock())
	Endif
Else
	lRet := .F.
Endif

Return lRet


//--------------------------------------------------------------------------
/*/{Protheus.doc} Fa090ExcA
Rotina Automática(ExecAuto) para Cancelamento de Baixas de Titulo a Pagar

@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//--------------------------------------------------------------------------
Function Fa090ExcA(aDadosBx, lAutomato)

	Local nX			:= 0
	Local nRecSE2		:= 0
	Local nTotal    	:= 0
	Local nHdlPrv   	:= 0
	Local nTamDadosBx	:= 0
	Local cFilAtu		:= cFilAnt
	Local cFilOrig		:= ""
	Local cNextFil		:= ""
	Local cIDOrig		:= ""
	Local cSequencia	:= ""
	Local cArquivo  	:= ""
	Local cPadrao		:= "531"
	Local aAreaSEA		:= SEA->(GetArea())
	Local aArea			:= GetArea()
	Local aPerg			:= {}
	Local aFlagCtb		:= {}
	Local aVetor    	:= {}
	Local lRet			:= .T.
	Local lDigita   	:= mv_par01 == 1
	Local lAglut    	:= mv_par02 == 1
	Local lContabiliza	:= .F.
	Local lPadraoBx		:= .F.
	Local lPadraoVd		:= .F.
	Local lUsaFlag		:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
	Local aDiario		:= {}

	// VerIfica o numero do Lote
	PRIVATE cLote
	LoteCont( "FIN" )

	Private lMsErroAuto     := .F.
	Private lMsHelpAuto     := .T.
	Private lMostraErro     := .F.
	Private LanceiCTB 		:= .F.

	DEFAULT aDadosBx	:= {}
	DEFAULT lAutomato	:= .F.

	nTamDadosBx  := Len(aDadosBx)

	If nTamDadosBx > 0

		//Realiza o repasse dos perguntes conforme a o rotina informada.
		F90ResPerg(@aPerg)
		
		lDigita 	 := (aPerg[1] == 1) // Mostra Lançamento Contabil
		lAglut		 := (aPerg[2] == 1) // Aglutina Lançamento
		lContabiliza := (aPerg[3] == 1) // Contabiliza Online
		aPerg[3]	 := 2				// Ajusto para não contabilizar na FINA080 via ExecAuto
		lPadraoBx	 := VerPadrao("531")
		lPadraoVd	 := VerPadrao("519")

		ProcRegua(nTamDadosBx)

		For nX := 1 to nTamDadosBx

			aVetor 		:= {}
			lMsErroAuto := .F.
			cDadosTit 	:= FinFK7Key(aDadosBx[nX,1],"")
			cNextFil  	:= If (nX < nTamDadosBx, aDadosBx[nX+1,3], "")	
			cFilOrig	:= aDadosBx[nX,3]
			cFilAnt		:= cFilOrig

			If nHdlPrv == 0 .And. lContabiliza .And. (lPadraoBx .or. lPadraoVd)
				nHdlPrv := HeadProva( cLote, "FINA090" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo )
				If Len(aPerg) >= 4
					aPerg[4] := nHdlPrv 
				Endif
			Endif

			dbSelectArea('SE2')
			SE2->(dbSetOrder(1)) // Filial + Fornecedor + Loja + Prefixo + Número + Parcela + Tipo

			If SE2->(MsSeek( cDadosTit ) )

				BEGIN TRANSACTION
					nRecSE2 := SE2->(RECNO())

					IncProc(STR0183 + aDadosBx[nX,1]) //"Cancelando Baixa: "

					AADD(aVetor,{"E2_FILIAL"     , SE2->E2_FILIAL        ,Nil})
					AADD(aVetor,{"E2_PREFIXO"    , SE2->E2_PREFIXO       ,Nil})
					AADD(aVetor,{"E2_NUM"        , SE2->E2_NUM           ,Nil})
					AADD(aVetor,{"E2_PARCELA"    , SE2->E2_PARCELA       ,Nil})
					AADD(aVetor,{"E2_TIPO"       , SE2->E2_TIPO          ,Nil})
					AADD(aVetor,{"E2_FORNECE"    , SE2->E2_FORNECE       ,Nil})
					AADD(aVetor,{"E2_LOJA"       , SE2->E2_LOJA          ,Nil})

					//posiciona SE5 a partir do FK2_IDFK2
					cIDOrig		:= aDadosBx[nX,4]
					cSequencia	:= aDadosBx[nX,5]

					//posiciona SE5 a partir do FK2_IDFK2
					dbSelectArea('SE5')
					SE5->(dbSetOrder(21)) //  E5_FILORIG + E5_IDORIG + E5_TIPODOC
					SE5->(DbSeek((xFilial("SE5",cFilOrig)) + cIDOrig ) )
					lContabilizou := SE5->E5_LA = "S"

					MSExecAuto({|a,b,c,d,e,f,g,h,i,j,k,l| Fina080(a,b,c,d,e,f,g,h,i,j,k,l)},aVetor,5,,,,,cSequencia,,,,,aPerg)

					//Em caso de erro na baixa desarma a transação
					If lMsErroAuto
						lRet:= .F.
						If !IsBlind()
							MOSTRAERRO()
						EndIf
						DisarmTransaction()
						Break
					Endif
				END TRANSACTION

				If lRet
					lDigita 	 := (aPerg[1] == 1) // Mostra Lançamento Contabil
					lAglut		 := (aPerg[2] == 1) // Aglutina Lançamento

					If UsaSeqCor()
						aAdd(aDiario,{"SE5",SE5->(RecNo()),cCodDiario,"E5_NODIA","E5_DIACTB"})
					Else
						aDiario := {}
					EndIf

					If lUsaFlag  //Armazena em aFlagCTB para atualizar no modulo Contabil
						aAdd( aFlagCTB, {"E5_LA" , "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
						aAdd( aFlagCTB, {"FK2_LA", "S", "FK2", FK2->( Recno() ), 0, 0, 0} )
					Endif

					If lPadraoBx .and. lContabilizou .and. lContabiliza
						nTotal += F090DetPro(nHdlPrv,cPadrao,"FINA090",cLote,,,,@aFlagCTB,cFilAtu,cFilOrig)
						FINCARVAR() //Carrega as variáveis de contabilização e evita o desposicionamento (xFilial) da FK2
					EndIf

					If !lUsaFlag .AND. LanceiCTB
						RecLock("FK2",.F.)
						FK2->FK2_LA := "S"
						MsUnlock()

						RecLock("SE5",.F.)
						SE5->E5_LA := "S"
						MsUnlock()
					Endif

					If nHdlPrv > 0 .And. nTotal > 0 .And. lContabiliza .and. (cFilAnt != cNextFil)
						//Efetiva Lancamento Contabil
						F090Contab(cArquivo, @nHdlPrv, cLote, lDigita, lAglut, dDataBase, @aFlagCTB, aDiario, cFilAtu, cFilOrig)

						aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
						nHdlPrv  := 0
						nTotal	 := 0
						aDiario	 := {}
					Endif
				Endif
			EndIf
		Next nX

		//Restaurando o grupo de perguntas
		F90ResPerg()

		cFilAnt := cFilAtu //  restaura cFilAnt para Filial logada

		If lRet .and. !lAutomato
			MsgInfo( STR0150 , STR0151  )  ///"Cancelamento de Baixas de Títulos a Pagar foi realizado com sucesso."###"Cancelamento de Baixas a Pagar"
		Endif

		SEA->(RestArea(aAreaSEA))
		RestArea(aArea)
	Endif

Return lRet


//----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FiltFilBco
Função para remover as filiais selecionadas que não possuam o banco selecionado para
baixas multi-filiais. Utilizada quando a tabela de bancos (SA6) está exclusiva.

@author pedro.alencar
@since 06/02/2020
@version 1.0
@type static function

@param aFilAux, array, Vetor com as filiais selecionadas (AdmGetFil) para a baixa
@param cChaveBco, char, Chave do banco informado (Código + Agência + Conta)
@return aRet, Vetor com a relação de filiais selecionadas que possuem o cadastro do banco informado
/*/
//----------------------------------------------------------------------------------------------------
Static Function FiltFilBco( aFilAux As Array, cChaveBco As Char ) As Array
	Local aRet As Array
	Local aAreaSA6 As Array
	Local cFilSA6 As Char
	Local nI As Numeric
	Default aFilAux := {}
	Default cChaveBco := ""

	aRet := {}
	aAreaSA6 := SA6->( GetArea() )
	SA6->( dbSetOrder(1) ) //A6_FILIAL+A6_COD+A6_AGENCIA+A6_NUMCON

	For nI := 1 To Len(aFilAux)
		cFilSA6 := FWxFilial( "SA6", aFilAux[nI] )

		If SA6->( msSeek( cFilSA6 + cChaveBco ) )
			aAdd( aRet, aFilAux[nI] )
		EndIf
	Next nI

	RestArea(aAreaSA6)
	FwFreeArray(aAreaSA6)
Return aRet


//-------------------------------------------------------------------
/*/{Protheus.doc} function F90ResPerg
Restaura os perguntes.
@Param	aPerg, Array, array para o grupo de perguntas.
@author  Vincius do Prado
@since   06/03/2020
@version P12
/*/
//-------------------------------------------------------------------
Static Function F90ResPerg(aPerg as Array)

	//Realiza o repasse dos perguntes conforme a o rotina informada.
	SetKey (VK_F12,{|a,b| AcessaPerg(__cPerg,.T.)})
	Pergunte(__cPerg,.F.)
	
	If(ValType(aPerg)=="A")
		AADD(aPerg,mv_par01) // Mostra Lançamento Contabil
		AADD(aPerg,mv_par02) // Aglutina Lançamento
		AADD(aPerg,mv_par03) // Contabiliza Online
		AADD(aPerg,0       ) // nHdlPrv para controle de Contabilização Online
	EndIf

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} function F90FORMATIN
Formata separadores de string para uso em cláusula IN de queries.
@author  Norberto M de Melo
@since   03/01/2017
@version P12
/*/
//-------------------------------------------------------------------
Static Function F90FORMATIN(cString as character, lFormatIN as Logical) as character

	DEFAULT cString 	:= ''
	DEFAULT lFormatIN	:= .T.

	cString	:=	StrTran(cString,',','/')
	cString	:=	StrTran(cString,';','/')
	cString	:=	StrTran(cString,'|','/')
	cString	:=	StrTran(cString,'\','/')

	If lFormatIN
		cString := Formatin(cString,"/")
	Endif

Return cString


//-------------------------------------------------------------------
/*{Protheus.doc} Fa090MnFil
Função responsavel por criar filtro para Filiais a partir de um array

@param	aFiluser - array com todas as filais para criação o filtro

@author Caio Quiqueto
@since 21/07/2015
@version P11

@return cRet - string do filtro para todas as filiais
*/
//-------------------------------------------------------------------
FUNCTION Fa090MnFil(aFiluser)
	Local cRet		:= ''
	Local nX		:= 0
	Local cRetOld	:= ""
	Local nRecSM0	:= SM0->(Recno())

	For nX := 1 to len(aFiluser)  Step 1
		cRet += aFiluser[nX] + "|"
	next

	/*Esse tratamento só será executado em casos que o sigamat possua no mínimo
	de 400 filiais. Nesse caso monta o novo filtro com as filiais que o user não
	possui acesso a fim de usar o menor filtro na IndRegua*/
	If Len(cRet) > 1500
		cRetOld := cRet
		SM0->(dbGotop())

		While SM0->(!EOF())
			If !AllTrim(xFilial("SE2",SM0->M0_CODFIL)) $ cRetOld
				cRet += AllTrim(xFilial("SE2",SM0->M0_CODFIL)) + "|"
			EndIf
			SM0->(dbSkip())
		EndDo

		If Len(cRet) > Len(cRetOld)
			cRet := cRetOld
		EndIf

		SM0->(dbGoto(nRecSM0))
	EndIf

return cRet


//-------------------------------------------------------------------
/*{Protheus.doc} F090GetNat
Função responsavel por retornar as naturezas parametrizadas para os
títulos de impostos

@param	cParam - parâmetro o qual se deseja obter o valor

@author Mauricio Pequim Jr
@since 05/11/2021
@version P12

@return cValParam - string do valor do parâmetro
*/
//-------------------------------------------------------------------
Function F090GetNat(cParam As Character)

	Local cValParam As Character

	DEFAULT cParam := ""

	cValParam := ""

	If cParam $ "MV_IRF|MV_ISS"
		cValParam := &(SuperGetMV(cParam))
	Else
		cValParam := (SuperGetMV(cParam))
	Endif

Return cValParam


//------------------------------------------------------------------------------------------
/*/{Protheus.doc} FGRVSFQPCC
	
	Realiza a gravação dos relacionamentos de retenção de impostos PCC entre 
	o título retentor e os retidos

	@type  Function
	@author pequim
	@since 12/11/2021
	@version P12

	@param aImpostos , Array	, Prefixo do titulo retentor
	@param aDadosRet , Array	, Dados dos títulos cujo imposto foi retido nessa baixa
	@param cSequencia, Character, Sequência da baixa na qual o imposto foi retido
	@param cCamposPCC, Character, Dados da gravação dos campos de retenção (referência)
	@param lIRPFBaixa, Logical  , Define se a retenção do IRRF é na baixa
	@param lAplVlMin , Logical  , Fornecedor do titulo retentor
	@param nVlMinImp , Numeric  , Loja do titulo retentor
	@param lPCC241	 , Logical  , Sequência da baixa na qual o imposto foi retido

/*/
//------------------------------------------------------------------------------------------
Function FGRVSFQPCC(aImpostos As Array,aDadosRet As Array,cSequencia As Character,cCamposPCC As Character, lRetParc As Logical,; 
					lIRPFBaixa As Logical, lAplVlMin As Logical, nVlMinImp As Numeric, lPCC241 As Logical)

	Local aRecnos 	AS Array
	Local cPrefOri	AS Character
	Local cNumOri 	AS Character
	Local cParcOri	AS Character
	Local cTipoOri	AS Character
	Local cCfOri	AS Character
	Local cLojaOri	AS Character
	Local cPRet		AS Character
	Local nX		AS Numeric
	Local nLoop		AS Numeric
	Local nSavRec 	AS Numeric
	Local lEmpGImp 	AS Logical
	Local cNccRet  	AS Character

	DEFAULT aImpostos	:= {}
	DEFAULT aDadosRet 	:= {}
	DEFAULT cSequencia	:= ""
	DEFAULT cCamposPCC	:= ""
	DEFAULT lRetParc 	:= .T.
	DEFAULT lIRPFBaixa	:= .F.
	DEFAULT lAplVlMin	:= .T.
	DEFAULT nVlMinImp 	:= 0
	DEFAULT lPCC241		:= .F.
	DEFAULT __cModRetPIS := GetNewPar( "MV_RT10925", "1" )

	aRecnos	 := {}
	cPrefOri := ""
	cNumOri	 := ""
	cParcOri := ""
	cTipoOri := ""
	cCfOri	 := ""
	cLojaOri := ""
	cPRet	 := ""
	nX		 := 0
	nLoop	 := 0
	nSavRec  := 0
	//1-Cria NCC/NDF referente a diferenca de impostos entre emitidos (SE2) e retidos (SE5)
	//2-Nao Cria NCC/NDF, ou seja, controla a diferenca num proximo titulo
	//3-Nao Controla
	cNccRet  := SuperGetMv("MV_NCCRET",.F.,"1")

	lEmpGImp := !(lEmpPub .And. !__lIrfMR .AND. lIRPFBaixa .And. lAplMinP .And. ;
					(nPis + nCoFins + nCsll + nIrrf + aDadosRet[2] + aDadosRet[3] + aDadosRet[4] + aDadosRet[5] < nVlMPub .And.;
					!(aDadosRet[2]+aDadosRet[3]+aDadosRet[4]+aDadosRet[5] == 0 .And. aDadosRet[1] > 0) ) )

	cCamposPCC := ",{'E5_VRETPIS' , " + cValToChar(If(__lPccMR, __nPisMR, nPis)) + " }"
	cCamposPCC += ",{'E5_VRETCOF' , " + cValToChar(If(__lPccMR, __nCofMR, nCofins)) + " }"
	cCamposPCC += ",{'E5_VRETCSL' , " + cValToChar(If(__lPccMR, __nCslMR, nCsll)) + " }"

	Do Case
		Case __cModRetPIS == "1"
			If ((aDadosRet[ 1 ] + (nValPgto + nPis + nCofins + nCsll + nIrrf + nInss + nDescont + SE2->E2_ISS + nTotAbat - nJuros - nMulta)	> nVlMinImp) .or. !lAplVlMin) .And. lEmpGImp
				lRetParc := .T.

				//Rotina para gerar titulo de adiantamento
				If cNccRet == "1" .and. nDiferImp < 0
					FGerCredRt(Abs(nDiferImp),SE2->E2_MOEDA,SE5->E5_SEQ)
				Endif

				nSavRec := SE5->( Recno() )

				//Exclui a Marca de "pendente recolhimento" dos demais registros
				If aDadosRet[1] > 0
					aRecnos   := aClone( aDadosRet[ 6 ] )
					cPrefOri  := SE2->E2_PREFIXO
					cNumOri   := SE2->E2_NUM
					cParcOri  := SE2->E2_PARCELA
					cTipoOri  := SE2->E2_TIPO
					cCfOri    := SE2->E2_FORNECE
					cLojaOri  := SE2->E2_LOJA
					cPRet	  := " "

					For nLoop := 1 to Len( aRecnos )
						SE5->( dbGoto( aRecnos[ nLoop ] ) )	

						RecLock("SE5", .F.)
						E5_PRETPIS := '2'
						E5_PRETCOF := '2'
						E5_PRETCSL := '2'
						MsUnlock()

						FK3->(DbSetOrder(2))
						For nX := 1 to Len(aImpostos)
							If aImpostos[nX,1] != "IRF"
								If FK3->(MsSeek(xFilial("FK3", SE5->E5_FILORIG) + SE5->E5_TABORI + SE5->E5_IDORIG + aImpostos[nX,1]))
									If Empty(FK3->FK3_IDRET)
										RecLock("FK3", .F.)
										FK3->FK3_IDRET := aImpostos[nX,4] 		//cIdFk4
										MsUnlock()
									Endif
								Endif
							Endif
						Next
						
						F090SFQGrv(cPrefOri, cNumOri, cParcOri, cTipoOri, cCfOri, cLojaOri, cSequencia)

					Next nLoop
				Endif
			Else
				If nVlRetPis + nVlRetCof + nVlRetCsl + nVlRetIrf > 0 .Or. !lEmpGImp
					IF lPCC241
						cPRet := "4"
					Else
						cPRet := "1"
					Endif

					//Atualiza a informação de retencao de impostos no titulo que está sendo baixado
					cCamposPCC += ",{'E5_VRETPIS' , "+cValToChar(nVlRetPis)+"}"
					cCamposPCC += ",{'E5_VRETCOF' , "+cValToChar(nVlRetCof)+"}"
					cCamposPCC += ",{'E5_VRETCSL' , "+cValToChar(nVlRetCsl)+"}"
					cCamposPCC += ",{'E5_PRETPIS' , '"+cPRet+"'}"
					cCamposPCC += ",{'E5_PRETCOF' , '"+cPRet+"'}"
					cCamposPCC += ",{'E5_PRETCSL' , '"+cPRet+"'}"
				EndIf
				lRetParc := .F.
			EndIf

			//Atualiza o registro da SE2 baseado no registro da SE5, nos campos de retenção de PCC
			RecLock("SE2",.F.)
			SE2->E2_PRETPIS := If(lPCC241 .And. Empty(cPRet), "4", cPRet)
			SE2->E2_PRETCOF := If(lPCC241 .And. Empty(cPRet), "4", cPRet)
			SE2->E2_PRETCSL := If(lPCC241 .And. Empty(cPRet), "4", cPRet)
			SE2->(MsUnlock())

		Case __cModRetPIS == "2"
			//Exclui a Marca de "pendente recolhimento" dos demais registros
			If aDadosRet[1] > 0
				aRecnos  := aClone( aDadosRet [ 6 ] )
				cPrefOri := SE2->E2_PREFIXO
				cNumOri  := SE2->E2_NUM
				cParcOri := SE2->E2_PARCELA
				cTipoOri := SE2->E2_TIPO
				cCfOri   := SE2->E2_FORNECE
				cLojaOri := SE2->E2_LOJA

				For nLoop := 1 to Len( aRecnos )
					SE5->( dbGoto( aRecnos[ nLoop ] ) )

					If !Empty(SE5->E5_PRETPIS) .And. !Empty(SE5->E5_PRETCOF) .And. !Empty(SE5->E5_PRETCSL)
						RecLock("SE5", .F.)
						E5_PRETPIS := '2'
						E5_PRETCOF := '2'
						E5_PRETCSL := '2'
						MsUnlock()

						FK3->(DbSetOrder(2))
						For nX := 1 to Len(aImpostos)
							If aImpostos[nX,1] != "IRF"
								If FK3->(MsSeek(xFilial("FK3", SE5->E5_FILORIG) + SE5->E5_TABORI + SE5->E5_IDORIG + aImpostos[nX,1]))
									If Empty(FK3->FK3_IDRET)
										RecLock("FK3", .F.)
										FK3->FK3_IDRET := aImpostos[nX,4] 		//cIdFk4
										MsUnlock()
									Endif
								Endif
							Endif
						Next
					EndIf

					F090SFQGrv(cPrefOri, cNumOri, cParcOri, cTipoOri, cCfOri, cLojaOri, cSequencia)

				Next nLoop
			Endif

			lRetParc := .T.

		Case __cModRetPIS == "3"
			//Grava a Marca de "pendente recolhimento" dos demais registros
			If nVlRetPis + nVlRetCof + nVlRetCsl + nVlRetIrf > 0
				//Atualiza a informação de retencao de impostos no titulo que está sendo baixado
				//Carrego o Model
				cCamposPCC += ",{'E5_VRETPIS' , "+cValToChar(nVlRetPis)+"}"
				cCamposPCC += ",{'E5_VRETCOF' , "+cValToChar(nVlRetCof)+"}"
				cCamposPCC += ",{'E5_VRETCSL' , "+cValToChar(nVlRetCsl)+"}"
				cCamposPCC += ",{'E5_PRETPIS' , '1'}"
				cCamposPCC += ",{'E5_PRETCOF' , '1'}"
				cCamposPCC += ",{'E5_PRETCSL' , '1'}"
			EndIf

			lRetParc := .F.
	EndCase

Return


//------------------------------------------------------------------------------------
/*/{Protheus.doc} F090SFQGRV
	
	Realiza a gravação dos relacionamentos de retenção de impostos PCC entre 
	o título retentor e os retidos

	@type  Function
	@author pequim
	@since 12/11/2021
	@version p12
	@param cPrefOri	 , Character, Prefixo do titulo retentor
	@param cNumOri 	 , Character, Número do titulo retentor
	@param cParcOri  , Character, Parcela do titulo retentor
	@param cTipoOri  , Character, Tipo do titulo retentor
	@param cCfOri    , Character, Fornecedor do titulo retentor
	@param cLojaOri  , Character, Loja do titulo retentor
	@param cSequencia, Character, Sequência da baixa na qual o imposto foi retido

/*/
//------------------------------------------------------------------------------------
Function F090SFQGRV(cPrefOri AS Character, cNumOri AS Character, cParcOri AS Character, cTipoOri AS Character,cCfOri AS Character, cLojaOri AS Character, cSequencia AS Character)

	Local cMFilial As Character
	
	DEFAULT cPrefOri	:= ""
	DEFAULT cNumOri		:= ""
	DEFAULT cParcOri	:= ""
	DEFAULT cTipoOri	:= ""
	DEFAULT cCfOri		:= ""
	DEFAULT cLojaOri	:= ""
	DEFAULT cSequencia	:= ""
	DEFAULT __cLayout	:= FWSM0Layout()
	DEFAULT __lGestao	:= "E" $ __cLayout .Or. "U" $ __cLayout
	DEFAULT __cFilSE2	:= IIF( __lGestao , FwFilial("SE2") , xFilial("SE2") )
	DEFAULT __cFilSFQ	:= IIF( __lGestao , FwFilial("SFQ") , xFilial("SFQ") )
 
	If Empty( __cFilSFQ )   //Multi-Filial
		cMFilial := xFilial("SFQ")
	Else
		If Empty( __cFilSE2 )
			cMFilial := xFilial("SFQ")
		Else
			cMFilial := SE2->E2_FILIAL
		EndIf
	EndIf

	RecLock("SFQ",.T.)
	SFQ->FQ_FILIAL  := cMFilial
	SFQ->FQ_ENTORI  := "SE5"
	SFQ->FQ_PREFORI := cPrefOri
	SFQ->FQ_NUMORI  := cNumOri
	SFQ->FQ_PARCORI := cParcOri
	SFQ->FQ_TIPOORI := cTipoOri
	SFQ->FQ_CFORI   := cCfOri
	SFQ->FQ_LOJAORI := cLojaOri
	SFQ->FQ_SEQORI  := cSequencia
	SFQ->FQ_ENTDES  := "SE5"
	SFQ->FQ_PREFDES := SE5->E5_PREFIXO
	SFQ->FQ_NUMDES  := SE5->E5_NUMERO
	SFQ->FQ_PARCDES := SE5->E5_PARCELA
	SFQ->FQ_TIPODES := SE5->E5_TIPO
	SFQ->FQ_CFDES   := SE5->E5_CLIFOR
	SFQ->FQ_LOJADES := SE5->E5_LOJA
	SFQ->FQ_SEQDES  := SE5->E5_SEQ
	SFQ->FQ_FILDES	:= SE5->E5_FILIAL
	MsUnlock()

Return


//------------------- LOCALIZAÇÃO --------------------------
//-------------------------------------------------------------------
/*/{Protheus.doc} f090Talao
Validar a digitação do número do Talonário quando CH cheque for próprio.

@author Luis Samaniego
@since 04/08/2015 
@version 1.0
/*/
//-------------------------------------------------------------------
Function f090Talao(cBcoSub, cAgeSub, cCtaSub, cChqSub, cPrxSub, nRegChSub)

	Local aSavArea	:= GetArea()
	Local lRet		:= .T.
	Local nTamCta	:= TamSX3("A6_NUMCON")[1]

	DBSelectArea("FRE")
	FRE->(dbSetOrder(3)) // Filial + Banco + Agência + Conta + Talão
	If !FRE->(dbSeek(xFilial("FRE")+cBcoSub+cAgeSub+Substr(cCtaSub, 1, nTamCta)+cNumTalao))
		MsgAlert(STR0153 , STR0072 ) //"Talão de cheques não cadastrado."###"Atención" //
		lRet := .F.
	ElseIf cTipoTalao <> FRE->FRE_TIPO
		MsgAlert(STR0159 )  //"No se puede reemplazar un cheque que no sea del mismo tipo"
		lRet := .F.
	Else
		If  FRE->FRE_STATUS = "2"
			If  ObtTalCHQ(cBcoSub,cAgeSub,cCtaSub,cNumTalao)
				cChqSub := cNumCHQ
				cPrxSub := cPreCHQ
				nRegChSub := nTalCHQ
				cTipTalao := Lower(X3COMBO("FRE_TIPO",FRE->FRE_TIPO))
				If cChStatus $ "01|04"
					If oCBXMotiv != Nil
						oCBXMotiv:Enable()
					EndIf
				Else
					If oCBXMotiv != Nil
						oCBXMotiv:Disable()
					EndIf
				Endif
				lRet := .T.
			Else
				MsgAlert( STR0154 , STR0072 ) // "Chequera no disponible"
				lRet := .F.
			Endif
		Else
			MsgAlert( STR0154 , STR0072 ) // "Chequera no disponible"
			lRet := .F.
		Endif
	EndIf

	If !lRet
		lCheckSub:=.F.
		If !cChStatus $ "01/02/03/07"
			If oCBXMotiv != Nil
				oCBXMotiv:Enable()
			EndIf
		Endif
	EndIf

	If oBcoSub != Nil
		oBcoSub:Refresh()
	EndIf
	If oAgeSub != Nil
		oAgeSub:Refresh()
	EndIf
	If oCtaSub != Nil
		oCtaSub:Refresh()
	EndIf
	If oPrxSub != Nil
		oPrxSub:Refresh()
	EndIf
	If oChqSub != Nil
		oChqSub:Refresh()
	EndIf
	If oChkBoxSub != Nil
		oChkBoxSub:Refresh()
	EndIf
	If oChkBoxNul != Nil
		oChkBoxNul:Refresh()
	EndIf
	If oDtVctoSub != Nil
		oDtVctoSub:Refresh()
	EndIf
	If oCBXMotiv != Nil
		oCBXMotiv:Refresh()
	EndIf
	If oTalao != Nil
		oTalao:Refresh()
	EndIf
	If oTipTalao != Nil
		oTipTalao:Refresh()
	EndIf

	RestArea(aSavArea)

Return(lRet)


//-------------------------------------------------------------------
/*/{Protheus.doc} ObtTalCHQ
Validar a digitação do número do Talonário quando CH cheque for próprio.

@author Luis Samaniego
@since 04/08/2015 
@version 1.0
/*/
//-------------------------------------------------------------------

Static Function ObtTalCHQ(cBanco,cAgencia,cConta,cNumTalao,nOpc,nNCheque)

	Local cQrySEF	:= ""
	Local cTmpSEF	:= ""
	Local nX        := 0
	Local lRet      := .T.

	Default nOpc    := 1
	Default nNCheque:= 0

	cTmpSEF := GetNextAlias()
	cQrySEF	:= "Select EF_BANCO,EF_CONTA,EF_AGENCIA,EF_TALAO,EF_PREFIXO,EF_NUM,R_E_C_N_O_"
	cQrySEF	+= " from " + RetSqlName("SEF") + " SEF"
	cQrySEF += " where EF_FILIAL = '" + xFilial("SEF") + "'"
	cQrySEF += " and EF_CART	= 'P'"
	cQrySEF	+= " and EF_BANCO	= '" + cBanco + "'"
	cQrySEF += " and EF_AGENCIA	= '" + cAgencia + "'"
	cQrySEF += " and EF_CONTA 	= '" + cConta + "'"
	cQrySEF += " and EF_TALAO 	= '" + cNumTalao + "'"
	cQrySEF += " and EF_STATUS 	= '00' AND EF_LIBER = 'S'"
	cQrySEF	+= " and D_E_L_E_T_ = ' '"
	If  nOpc==2 //Buscar el cheque si esta disponible
		cQrySEF	+= " and EF_NUM	= '" + nNCheque + "'"
	Endif
	cQrySEF += " order by EF_BANCO,EF_AGENCIA,EF_CONTA,EF_TALAO,EF_PREFIXO,EF_NUM"
	cQrySEF	:= ChangeQuery(cQrySEF)
	DbUseArea(.T.,"TOPCONN",TCGenQry(,,cQrySEF),cTmpSEF,.F.,.T.)
	(cTmpSEF)->(dbGoTop())

	nX := 0
	While !((cTmpSEF)->(EOF()))
		nX++
		If  !(nOpc==2)
			cNumCHQ := (cTmpSEF)->EF_NUM
			cPreCHQ := (cTmpSEF)->EF_PREFIXO
			nTalCHQ := (cTmpSEF)->R_E_C_N_O_
			SEF->(DbGoTo(nTalCHQ))
			If (SEF->(DbRlock(nRecChqSub)))
				Exit
			EndIf
		Endif
		(cTmpSEF)->(dbSkip())
	Enddo
	dbSelectArea(cTmpSEF)
	DbCloseArea()
	If  nX==0
		If  !(nOpc==2)
			MsgAlert(STR0102)  //"Não foi encontrado cheque disponivel para este pagamento!"
		Endif
		lRet:=.F.
	Endif 

Return(lRet)

//-------------------------------------------------------------------------
/*/{Protheus.doc} F090CRatIR
Função para criar o objeto __oRatIRF

@author pequim
@since  17/02/2022
@version 12.1.33
@param 
/*/
//-------------------------------------------------------------------------
Function F090CRatIR() As Object

Local cCdRetIRRt	As Character

cCdRetIRRt    := SuperGetMv("MV_RETIRRT",.T.,"3208")

F090LRatIR(.F.)

If Alltrim(SE2->E2_CODRET) $ cCdRetIRRt
	If FindFunction("FinXRatIR")
		If __oRatIRF == Nil
			__oRatIRF := FinBCRateioIR():New()
		EndIf
		__oRatIRF:SetFilOrig(cFilAnt)
		__oRatIRF:SetForLoja(SE2->E2_FORNECE,SE2->E2_LOJA)
		__oRatIRF:SetIRBaixa(.T.)
	EndIf
EndIf	

Return __oRatIRF

//-------------------------------------------------------------------------
/*/{Protheus.doc} F090LRatIR
Função para limpar o objeto __oRatIRF

@author pequim
@since  17/02/2022
@version 12.1.33
@param lExclui, Logical, Define se ira excluir o Objeto da memoria
/*/
//-------------------------------------------------------------------------
Function F090LRatIR(lExclui as Logical)

    Default lExclui := .T.

    If __oRatIRF <> Nil
        __oRatIRF:Clean()
        If lExclui
            FwFreeObj(__oRatIRF)
            __oRatIRF := Nil
        EndIf    
    EndIf

Return

//-------------------------------------------------------------------------
/*/{Protheus.doc} F090SRatIR
Função para setar o objeto __oRatIRF

@author pequim
@since  17/02/2022
@version 12.1.33
@param oObj, Object, Objeto que sera atribuido ao oRatIrf
/*/
//-------------------------------------------------------------------------
Function F090SRatIR(obj as Object)
    __oRatIRF := obj
Return 


//-------------------------------------------------------------------------
/*/{Protheus.doc} FinExp090
	Apresenta uma tela informando que a rotina sera descontinuada
	@type  Function
	@author reynaldo
	@since 30/06/2021
	@version 1.0
	@param cExpirFunc, caracter, nome da rotina que deve ser descontinuada
/*/
//-------------------------------------------------------------------------
Function FinExp090(cExpirFunc)
Local dDate      	as date
Local oProfile   	as object
Local aLoad      	as array
Local cShow      	as character
Local lCheck     	as logical
Local cExpiraData	as character
Local nPauseDays	as numeric
Local cLinkTDN      as character
//
// Data de expiração da rotina
//
cExpiraData	:= "20220404"

//
// numero de dias que pode ser desabilitada a mensagem
//
nPauseDays	:= 30

cLinkTDN	:= "https://tdn.totvs.com/pages/viewpage.action?pageId=606846610"

dDate := Date()
oProfile := FwProFile():New()
oProfile:SetTask("ESTExpired") //Nome da sess?o
oProfile:SetType(cExpirFunc) //Valor
aLoad := oProfile:Load()
If Empty(aLoad)
	cShow := "00000000"
Else
	cShow := aLoad[1]
Endif

// reseta o controle de nPauseDays dias e volta apresentar a tela de advertencia
If cShow <> "00000000" .and. STOD(cShow) + nPauseDays <= dDate
	cShow := "00000000"
	oProfile:SetProfile({cShow})
	oProfile:Save()
ENDIF

If cShow == "00000000"
	lCheck := DlgExp090(cExpirFunc,cExpiraData, nPauseDays, cLinkTDN)

	If lCheck
		cShow := dtos(date())
		oProfile:SetProfile({cShow})
		oProfile:Save()
	EndIf

EndIf

oProfile:Destroy()
oProfile := nil
aLoad := aSize(aLoad,0)
aLoad := nil

RETURN

//----------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} DlgExp090
	Apresenta uma tela informando que a rotina sera descontinuada
	@type  Function
	@author reynaldo
	@since 30/06/2021
	@version 1.0
	@param cExpirFunc, caracter, função que está sendo expirada
	@param cExpiraData, caracter, data de experiração a ser informada deve estar no formato AAAAMMDD
	@param nPauseDays, numeric, numero de dias que a mensagem pode ser ocultada
	@param cDescrFunc, caracter, descricaod a rotina e nome da rotina que substitui a rotina descontinuada
	@param cLinkTDN, caracter, endere?o http referente a rotina que esta sendo descontinuada
	@return lCheck, logico, Verdadeiro se foi escolhido para desabilitar a mensagem por 3O dias
/*/
//----------------------------------------------------------------------------------------------------------------
Static Function DlgExp090(cExpirFunc as character, cExpiraData as character, nPauseDays as numeric, cLinkTDN as character)
local oSay1		as object
local oSay2		as object
local oSay3		as object
local oSay4		as object
local oCheck1	as object
local oModal	as object
Local cMsg1		as character
Local cMsg2		as character
Local cMsg3		as character
Local cMsg4		as character
Local cDescr	as character
Local lCheck	as logical
Local nLin2		as numeric	
Local nLin3		as numeric
Local nLin4		as numeric

oModal := FWDialogModal():New()
oModal:SetCloseButton( .F. )
oModal:SetEscClose( .F. )
oModal:setTitle(STR0190)	//"Comunicado Ciclo de Vida de Software - TOTVS Linha Protheus"

//define a altura e largura da janela em pixel
oModal:setSize(180, 250)

oModal:createDialog()

oModal:AddButton( STR0039, {||oModal:DeActivate()}, STR0039, , .T., .F., .T., ) // "Confirmar"

oContainer := TPanel():New( ,,, oModal:getPanelMain() )
oContainer:Align := CONTROL_ALIGN_ALLCLIENT


cMsg1  := STR0191	//'Essa rotina será descontinuada e não sofrerá mais manutenções em nenhum release a partir de 04/04/2022 e ficará indisponível a partir de 01/08/2022 para o release 12.1.33 e posteriores.'
cDescr := STR0192	//'Seus recursos e funcionalidades foram implementadas na rotina FINA090 (Baixa Automática).'
nLin2  := 40
nLin3  := 60
nLin4  := 80

cMsg2 := i18n("<b>" + cDescr + "</b>", {} ) 
cMsg4 := STR0195	//"Para maiores informações, favor contatar o administrador do sistema ou seu ESN TOTVS."

oSay1 := TSay():New( 10,10,{||cMsg1 },oContainer,,,,,,.T.,,,220,20,,,,,,.T.)

oSay2 := TSay():New( nLin2,10,{||cMsg2 },oContainer,,,,,,.T.,,,220,20,,,,,,.T.)

cMsg3 := STR0196 +space(01)	//"Para conhecer mais sobre a convergência entre essas rotinas,"
If ! Empty(cLinkTDN)
	cMsg3 += "<b><a target='_blank' href='"+cLinkTDN+"'> "
	cMsg3 += STR0197	//"clique aqui"
	cMsg3 += " </a></b>."
	cMsg3 += "<span style='font-family: Verdana; font-size: 12px; color: #565759;' >" + ' ' +"</span>"
	oSay3 := TSay():New(nLin3,10,{||cMsg3},oContainer,,,,,,.T.,,,220,20,,,,,,.T.)
	oSay3:bLClicked := {|| MsgRun( STR0198, "URL",{|| ShellExecute("open",cLinkTDN,"","",1) } ) } // "Abrindo o link... Aguarde..."
EndIf
oSay4 := TSay():New( nLin4,10,{||cMsg4 },oContainer,,,,,,.T.,,,220,20,,,,,,.T.)

lCheck := .F.
oCheck1 := TCheckBox():New(100,10,i18n(STR0199,{strzero(nPauseDays,2)}) ,{|x|If(Pcount()==0,lCheck,lCheck:=x)},oContainer,220,21,,,,,,,,.T.,,,) // "Não apresentar esta mensagem nos proximos #1[30]# dias."

oModal:Activate()

Return lCheck

