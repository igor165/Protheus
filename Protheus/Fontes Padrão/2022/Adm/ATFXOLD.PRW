#Include "Protheus.Ch"
#Include "AtfxOld.Ch"

Static __lVerKernel := .F.
STATIC cTipoFiscal	:= "01/02/03/04/05/06/07/11/"
STATIC cTipoIncent	:= "08/09"
STATIC cTipoGerenc	:= ""
Static __nQtdMoed
Static __lStruPrj
Static __lStruRat
Static __lAtfCusPrv := NIL
Static aATFMvPar	:= {}


STATIC lIsRussia	:= If(cPaisLoc$"RUS",.T.,.F.) // CAZARINI - Flag to indicate if is Russia location
/*


ͻ
Programa  ATFXKERNELAutor  TOTVS SA             Data   10/08/10   
͹
Desc.     Rotina que verifica se o Ativo fixo est atualizado corre   
          tamente.                                                    
͹
Uso        AP                                                        
ͼ


*/
Function ATFXKERNEL()
Local aAtfFunc := {}
Local lRet		:= .T.

If !__lVerKernel

	aAdd(aAtfFunc,"AF010ATXT")
	aAdd(aAtfFunc,"AF010AAQUI")
	aAdd(aAtfFunc,"AF010ACHV")
	aAdd(aAtfFunc,"AF010ATAXA")
	aAdd(aAtfFunc,"AF010ATIPO")
	aAdd(aAtfFunc,"AF010ADLAT")
	aAdd(aAtfFunc,"AF010AVLDL")
	aAdd(aAtfFunc,"AF010AGRP")
	aAdd(aAtfFunc,"AF010AAT32")
	aAdd(aAtfFunc,"AF010ACHAP")
	aAdd(aAtfFunc,"ATFXVISUAL")
	aAdd(aAtfFunc,"ATFXJACALC")
	aAdd(aAtfFunc,"ATFXPAcols")
	aAdd(aAtfFunc,"AF050DET")
	aAdd(aAtfFunc,"AF050NXMTH")
	aAdd(aAtfFunc,"ATFXSLDCTB")
	aAdd(aAtfFunc,"ATFXBXCIAP")
	aAdd(aAtfFunc,"ATFXGRCIAP")
	aAdd(aAtfFunc,"ATFXMVCIAP")
	aAdd(aAtfFunc,"ATFXRSCIAP")
	aAdd(aAtfFunc,"AF050DET")
	aAdd(aAtfFunc,"AF050NXMTH")
	aAdd(aAtfFunc,"ATFXSLDCTB")
	aAdd(aAtfFunc,"ATFXBXCIAP")
	aAdd(aAtfFunc,"ATFXGRCIAP")
	aAdd(aAtfFunc,"ATFXMVCIAP")
	aAdd(aAtfFunc,"ATFXRSCIAP")
	aAdd(aAtfFunc,"ATFCalcSD")
	aAdd(aAtfFunc,"ATFCalcRS")
	aAdd(aAtfFunc,"ATFCalcVR")
	aAdd(aAtfFunc,"ATFCalcSA")
	aAdd(aAtfFunc,"ATFCalcQC")

	__lVerKernel := lRet
EndIf

lRet := __lVerKernel

Return lRet

/*


ͻ
Programa  VerKernel  Autor  TOTVS SA             Data   15/10/10   
͹
Desc.      Valida se as funo do Kernel do Mdulo esto Presentes    
                                                                      
͹
Uso        AP                                                        
ͼ


*/
Static Function VerKernel()
Local lRet := .F.

lRet := ATFXKERNEL()

Return lRet

/*


ͻ
Programa  AFXVerRat Autor  Microsiga            Data   02/13/12   
͹
Desc.     Verifica se o ambiente est preparado para receber          
          a funcionalidade do rateio de movimentaes do Ativo        
͹
Uso        AP                                                        
ͼ


*/
Function AFXVerRat()
Local lRet := .T.

If __lStruRat == Nil
	__lStruRat := .T.
EndIf

lRet := __lStruRat

Return lRet

/*


ͻ
Programa  AFXAtCsPrv Autor  Mauricio Pequim Jr   Data   07/05/13   
͹
Desc.     Verifica se o ambiente est preparado para receber          
          a funcionalidade do filtro de ativos de custo/provisao      
͹
Uso        AP                                                        
ͼ


*/
Function AFXAtCsPrv(lHelp,nValPar)
Local lRet := .F.
Local lContinua := .F.

Default lHelp := .F.
Default nValPar := 2

If __lAtfCusPrv == Nil
	__lAtfCusPrv := Alltrim(SuperGetMV("MV_ATFSPRO",.F.,"1")) == "2"
EndIf

/* Criada trativa para o relatrio ATFR050, pois ao selecionar o ltimo pergunte do 
relatrio o sistema apresentava o help independente do contedo do parmetro MV_ATFSPRO */

If IsInCallStack("ATFR050")
	lContinua := Alltrim(SuperGetMV("MV_ATFSPRO",.F.,"1")) == "1"
	If lContinua
		lRet := .T.
	EndIf 	
Else
	lRet := __lAtfCusPrv
EndIf

If !lRet .and. lHelp
	If nValPar != 1
		Help(' ',1,"HELP","ATFCUSPRV",STR0001,1,0)	//"Esta pergunta somente ter efeito caso o parmetro MV_ATFSPRO estiver igual a <2 (No)>."
	Endif
	lRet := .T.
Endif

Return lRet


/*/


Ŀ
Funo    af010Texto Autor  Wagner Xavier          Data  30.03.93 
Ĵ
Descrio Recupera um texto do arquivo de descries extendidas       
Ĵ
Sintaxe   af010Texto( )                                               
Ĵ
 Uso       Genrico                                                   
ٱ


*/
Function af010Texto(cChave)
// Movida para o fonte ATFA010a.Prw
If !__lVerKernel
	__lVerKernel := VerKernel()
EndIf
Return AF010ATXT(cChave)

/*/

Ŀ
Funo    AF010Aquis Autor  Wagner Xavier          Data  10.01.94 
Ĵ
Descrio Verifica se lei 8.200 e Reavalio  valida.                
          Somente sero vlidas, se existir aquisio ou adiantamento.
Ĵ
Uso        ATFA010                                                    
ٱ


*/
Function AF010Aquis( )
// Movida para o fonte ATFA010a.Prw
If !__lVerKernel
	__lVerKernel := VerKernel()
EndIf
Return AF010AAQUI()

/*/

Ŀ
Funo    AF010Chav  Autor  Claudinei M. Benzi     Data  28.11.93 
Ĵ
Descrio Verifica se ha' chave duplicada                             
Ĵ
Uso        ATFA010                                                    
ٱ


*/
Function AF010Chav()
// Movida para o fonte ATFA010a.Prw
If !__lVerKernel
	__lVerKernel := VerKernel()
EndIf
Return AF010ACHV()

/*/

Ŀ
Funo     AF010Taxa   Autor  Wagner Xavier          Data  20.01.93 
Ĵ
Descrio  Preenche Taxa depreciao para todas das moedas.             
Ĵ
Uso        ATFA010                                                      
ٱ


*/
Function Af010Taxa(lGrupo)
// Movida para o fonte ATFA010a.Prw
If !__lVerKernel
	__lVerKernel := VerKernel()
EndIf
Return AF010ATAXA(lGrupo)


/*/

Ŀ
Funo     AF010Tipo   Autor  Claudinei M. Benzi     Data  22.01.92 
Ĵ
Descrio  Consiste tipo do bem                                         
Ĵ
Uso        ATFA010                                                      
ٱ


*/
Function AF010Tipo( cTipo, nLinha, lLinOk )
// Movida para o fonte ATFA010a.Prw
If !__lVerKernel
	__lVerKernel := VerKernel()
EndIf
Return AF010ATIPO( cTipo, nLinha, lLinOk )


/*/

Ŀ
Funo     AF010DelAtu Autor  Alice Y Yamamoto       Data 22.01.99  
Ĵ
Descrio  Atualiza os arquivos apos a exclusao                         
Ĵ
Sintaxe e  Void AF010AtuArq( )                                          
Ĵ
Uso        Af010Delet                                                   
ٱ


*/
Function Af010DelAtu(cAlias1, lCprova,lMostra,lContab,aCIAP,aRateio)
// Movida para o fonte ATFA010a.Prw
If !__lVerKernel
	__lVerKernel := VerKernel()
EndIf
Return AF010ADLAT(cAlias1, lCprova,lMostra,lContab,aCIAP, aRateio)

/*/

Ŀ
Funo     AF010VldDel Autor  Alice Y Yamamoto       Data 26.01.99  
Ĵ
Descrio  Verifica se o Ativo pode ser excluido                        
Ĵ
Sintaxe e  Void AF010Delet() / Mata100 -> Intergracao com compras       
Ĵ
Uso        Af010Delet ()                                                
ٱ


*/
Function Af010VldDel(cAlias1, lCompra,lHelp)
Default lHelp := .T.
// Movida para o fonte ATFA010a.Prw
If !__lVerKernel
	__lVerKernel := VerKernel()
EndIf
Return AF010AVLDL(cAlias1, lCompra,lHelp)

/*/

Ŀ
Funo     AF010Grupo  Autor  Wagner Mobile Costa    Data  25.03.02 
Ĵ
Descrio  Preenche entidades contabeis no bem de acordo com grupo [SNG]
Ĵ
Uso        ATFA010                                                      
ٱ


*/
Function Af010Grupo(cEntidade)
// Movida para o fonte ATFA012.Prw
If !__lVerKernel
	__lVerKernel := VerKernel()
EndIf
Return AF012AGRP(cEntidade)

/*/

Ŀ
Funo     Af010Art32  Autor  Adilson Soeiro         Data  20.02.10 
Ĵ
Descrio  Preenche Taxa depreciao para todas das moedas.             
Ĵ
Uso        Af010Art32                                                   
                                                                        
ٱ


*/
Function Af010Art32()
// Movida para o fonte ATFA010a.Prw
If !__lVerKernel
	__lVerKernel := VerKernel()
EndIf
Return AF010AAT32()


/*/

Ŀ
Funo    af010Chapa Autor  Alice Yaeko Yamamoto   Data  30.03.93 
Ĵ
Descrio  Verifica se a chapa informada ja existe e se pode repetila 
Ĵ
Sintaxe    af010Chapa(cChapa, lRepChapa)                              
Ĵ
 Uso       Criacao Automatica de bens.                                
ٱ


*/
FUNCTION AF010CHAPA(cChapa,lRepChapa)
// Movida para o fonte ATFA010a.Prw
If !__lVerKernel
	__lVerKernel := ATFXKERNEL()
EndIf
RETURN AF010ACHAP(cChapa,lRepChapa)

/*


Ŀ
Funo    ATFAtuSX1  Autor  TOTVS					 Data  04/05/11 
Ĵ
Descrio  Ajusta SX1				  				                  
Ĵ
 Uso       ATUALIZACAO SIGAATF                                        
ٱ


*/
Static Function ATFAtuSX1()

Local aHelpPor	:={}
Local aHelpEng	:={}
Local aHelpSpa	:={}
Local i			:=0
Local nTamFilial:= IIf( lFWCodFil, FWSIZEFILIAL(), 2 )

Return

/*


ͻ
Programa  ATFAtuSX3 Autor  Microsiga            Data   09/12/11   
͹
Desc.      Realiza ajustes no campos do SX3                           
                                                                      
͹
Uso        AP                                                        
ͼ


*/
Static Function ATFAtuSX3()

Return

/*


ͻ
Programa  AjCalcPis Autor  Microsiga            Data   05/06/12   
͹
Desc.     Ajuste no campo Calc Pis na tabela de movimentos SN4        
          conforme campo Calc Pis (N1_CALCPIS) do Bem                 
͹
Uso        AP                                                         
ͼ


*/

Static Function Aj_Calc_Pis()
Local cFiltro, cIndTmp, nIndex
Local cQuery 	:= ""
Local lCCBem 	:= SuperGetMv("MV_ATFCCMV",.F., .T.)  //.T. = Considera Centro Custo Cpo N3_CCUSTO (Padrao) .F. =Considera CC das Movimentacoes (SN4) N4_CCUSTO
Local lPopSN4 	:= SuperGetMv("MV_ATFCSN4",.F., .F.)  //.T. = ja populou tabela SN4 CAMPO N4_CALCPIS .F. =Nao Populado SN4
Local cFilOld := cFilAnt
Local nInc
Local aSM0		:= AdmAbreSM0()

//somente processa se for cc do movim. ativo-sn4 e existe o campo e nao populou o campo ainda (soh deve popular uma unica vez) 
Local lProcessa	:= ! lCCBem .And. ;   //se for cc de movimento SN4
					! lPopSN4 //se nao populou SN4 CAMPO N4_CALCPIS

If lProcessa
	//processa com base no sigamat.emp todas as filiais desta empresa
	For nInc := 1 To Len( aSM0 )
	
		If aSM0[nInc,1] == cEmpAnt
		
			cFilAnt := aSM0[nInc][2]  //seta a filial corrente
			
				cQuery := " UPDATE " + RetSqlName("SN4") + " SET N4_CALCPIS = N1_CALCPIS "
				cQuery += " FROM " + RetSqlName("SN1") 
				//CLAUSULA WHERE SN4
				cQuery += " WHERE N4_FILIAL = '" + xFilial("SN4") + "' "
				cQuery += " AND "+ RetSqlName("SN4") +".D_E_L_E_T_  = ' ' "
				cQuery += " AND N4_CALCPIS  = ' ' "  //somente para os que estao vazio na tabela SN4
				//LINKAR COM SN1
				cQuery += " AND N4_CBASE = N1_CBASE "
				cQuery += " AND N4_ITEM  = N1_ITEM  "
		        //CONDICOES SN1
				cQuery += " AND N1_FILIAL = '" + xFilial("SN1") + "' "
				cQuery += " AND "+ RetSqlName("SN1") +".D_E_L_E_T_  = ' ' "
				cQuery += " AND N1_CALCPIS  != ' ' "    //Somente os que estao preenchidos na tabela SN1
				
				If TcSqlExec(cQuery) != 0
					UserException( TCSqlError() )
				EndIf

				PutMvPar( "MV_ATFCSN4" , .T.)
							
			//se for compartilhado faz uma unica vez
			If Empty(xFilial("SN4"))
				Exit
			EndIf
        EndIf
   Next
EndIf

//restaura a filial corrente
cFilAnt := cFilOld

Return

/*/


Ŀ
Funo     MesAnoAtf Autor  Cesar C S Prado        Data  09/02/94 
Ĵ
Descrio  Devolve um campo caracter com o ano e mes de uma data AAMM 
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function MesAnoAtf( dData)
Return StrZero(Year(dData),4)+StrZero(Month(dData),2)

/*/

Ŀ
Funo     X3Decimal   Autor  Cesar C S Prado        Data  29/07/94 
Ĵ
Descrio  Devolve o numero de decimais de um campo numerico            
Ĵ
 Uso       Generico                                                     
ٱ


*/
Function X3Decimal(cCampo)
Local cAlias   := Alias()
Local nRetorno := 0
dbSelectArea( "SX3" )
dbSetOrder( 2 )
dbSeek( cCampo )
dbSetOrder( 1 )
IF Found( )
	nRetorno := X3_DECIMAL
End
dbSelectArea(cAlias)
Return ( nRetorno )
/*/

Ŀ
Funo     AtfMeses    Autor  Vinicius S Barreira    Data  21/09/94 
Ĵ
Descrio  Calcula quantos meses existem entre duas datas               
Ĵ
Utilizacao nMeses := AtfMeses(dInic,dFim,nTipo)                         
Parametros dInic ->  Data Inicial                                       
           dFim  ->  Data Final                                         
           nTipo ->  1 - Mes Cheio , 2 - Mes Simples                    
Ĵ
 Uso       Generico                                                     
ٱ


*/
Function AtfMeses(dInic,dFim,nTipo)
local nmeses := 0 , dVaraux := ctod("") , Retorno := 0

if ValType(dInic) # "D" .or. ;
    ValType(dFim)  # "D" .or. ;
    ValType(nTipo) # "N"
    return( 0 )
endif

If dInic > dFim  // erro do programador
    return( 0 )
Endif

If nTipo < 1 .or. nTipo > 2
    nTipo := 2  // Valor default para mes simples
Endif

// Este algoritmo pode ser um pouco lento, mas funciona bem.

dVaraux := dFim
While dVaraux >= dInic
    If nMeses # Month(dVaraux)
        nMeses := Month(dVaraux)
        Retorno ++
    endif
    dVaraux --
End

If nTipo == 2  // Mes simples
    If Retorno > 1  // Subtrai uma unidade para compensar os dias
        Retorno --  // excedentes do mes
    Endif
Endif

return( Retorno )


/*/

Ŀ
Funo     Atfx3       Autor  Vinicius S Barreira    Data  21/09/94 
Ĵ
Descrio  Le a estrutura do arquivo SX3                                
Ĵ
Utilizacao atfx3(cAlias1,@aHeader)                                      
Parametros alias   - > arquivo que sera' lido do sx3                    
           aHeader - > matriz com estrutura do arquivo                  
Ĵ
 Uso       Generico                                                     
ٱ


Observacao: variavel nUsado e' private.
*/
Function atfx3( cAlias1 , aHeader, lAuto )

Local nOrdSx3 := SX3->(IndexOrd())
Local cUsado

Default lAuto := .F. // Condio para criar novos campos no header que so tratados somente pela execauto.

dbSelectArea("SX3")
dbSetOrder(1)
SX3->(dbSeek( cAlias1 ))
While ! SX3->(Eof()) .And. (SX3->X3_ARQUIVO == cAlias1)
    IF X3USO(SX3->X3_USADO) .and. cNivel >= SX3->X3_NIVEL
        nUsado++
        AADD(aHeader,{ TRIM(X3Titulo()) ,;
        AllTrim(SX3->X3_CAMPO),;
        SX3->X3_PICTURE ,;
        SX3->X3_TAMANHO ,;
        SX3->X3_DECIMAL ,;
        SX3->X3_VALID ,;
        SX3->X3_USADO ,;
        SX3->X3_TIPO ,;
        SX3->X3_ARQUIVO ,;
        SX3->X3_CONTEXT,;
        SX3->X3_RELACAO } )
    End
    Sx3->(dbSkip())
End

SX3->(PrefixoCpo(cAlias1)+"_FILIAL")

cUsado := SX3->X3_USADO

If lAuto
	nUsado++
	AADD( aHeader, { "N3AVPPLAN","N3AVPPLAN", "", TamSX3("N3_VORIG1")[1], TamSX3("N3_VORIG1")[2],, cUsado, "N", cAlias1, "V", ""} )
	nUsado++
	AADD( aHeader, { "N3AVPREAL","N3AVPREAL", "", TamSX3("N3_VORIG1")[1], TamSX3("N3_VORIG1")[2],, cUsado, "N", cAlias1, "V", ""} )
EndIf

AADD( aHeader, { "Alias WT",PrefixoCpo(cAlias1)+"_ALI_WT", "", 03, 0,, cUsado, "C", cAlias1, "V", ""} )
AADD( aHeader, { "Recno WT",PrefixoCpo(cAlias1)+"_REC_WT", "", 10, 0,, cUsado, "N", cAlias1, "V", ""} )

SX3->(dbSetOrder(nOrdSx3))

return .t.

/*/

Ŀ
Funo     CposUsuario Autor  Claudio D. de Souza    Data  18/01/02 
Ĵ
Descrio Le a estrutura do arquivo SX3 para verificar os campos criados
          pelo usuario e adicionar na matriz de campos que poder ser    
          alterados                                                     
Ĵ
Utilizacao Cposusuario(aAlter,cAlias)                                   
Parametros aAlter  - > Campos que podem ser alterados                   
           cAlias  - > Arquivo a ser lido                               
Ĵ
 Uso       Generico                                                     
ٱ


*/
Function CposUsuario(aAlter,cAlias)
Local aArea := GetArea()
DEFAULT aAlter := {}
dbSelectArea("SX3")
DbSetOrder(1)
SX3->(dbSeek(cAlias))
While ! SX3->(Eof()) .And. (SX3->X3_arquivo == cAlias)
	If X3USO(SX3->X3_usado)    .And.;
		cNivel >= SX3->X3_NIVEL .And.;
		X3_PROPRI == "U"        .And.;
		X3_VISUAL != "V"
		If Ascan(aAlter, {|e| Alltrim(Upper(e))==AllTrim(Upper(X3_CAMPO))})==0
			Aadd(aAlter,SX3->X3_campo)
		Endif
	End
	Sx3->(dbSkip())
End
RestArea(aArea)

Return Nil

/*/

Ŀ
Funo     AtfLegenda  Autor  Wagner Mobile Costa  Data  18.04.02 
Ĵ
Descrio  Funcao utilizada para criacao de Legenda SigaAtf           
           Retorna a legenda para o Browse/Cria caixa da legenda      
Ĵ
 Uso       SigaAtf                                                    
ٱ


/*/
Function AtfLegenda(cAlias, nReg)

Local aLegenda 	:= {}
Local uRetorno 	:= .T.
Local aCoresNew := {}
Local aLegNew	:= {}

If ExistBlock("ATFLEG")
	uRetorno := ExecBlock("ATFLEG",.F.,.F.,{nReg,cAlias})
Else
	If nReg = Nil	// Chamada direta da funcao onde nao passa, via menu Recno eh passado
		uRetorno := {}
		If cAlias = "SN1"
			if cPaisLoc == "RUS"
				Aadd(uRetorno, { 	'ALLTRIM(N1_STATUS) == "0"'	,"f10_pink" 	} )	//"Schedule"			
				Aadd(uRetorno, { 	'ALLTRIM(N1_STATUS) == "1"'	, "BR_VERDE" 	} )	//"Active"
				Aadd(uRetorno, { 	'ALLTRIM(N1_STATUS) == "C"'	, "BR_AZUL"		} )	//"Conservation"
				Aadd(uRetorno, { 	'! Empty(N1_BAIXA)'			, "BR_VERMELHO"	} )	//"Write-off"
			ELse
				Aadd(uRetorno, { 	'ALLTRIM(N1_STATUS) == "4"'	,"BR_PINK" 		} )	//"Transferencia Interna de Filial"		  	
				Aadd(uRetorno, { 	'! Empty(N1_BAIXA)'			, "BR_VERMELHO"	} )	//"Custo de Emprstimo"
				Aadd(uRetorno, { 	'N1_PATRIM == "S"'			, "BR_AMARELO" 	} )	//"Patrimonio Liquido"
				Aadd(uRetorno, { 	'N1_PATRIM == "A"'			, "BR_CINZA" 	} )	//"Amortizacao"
				Aadd(uRetorno, { 	'N1_PATRIM == "C"'			, "BR_AZUL"		} )	//"Capital Social"
				Aadd(uRetorno, { 	'N1_PATRIM == "P"'			, "BR_MARROM" 	} )	//"Patrimonio (Prejuizo)"
				Aadd(uRetorno, { 	'N1_PATRIM == "D"'			, "f10_azul" 	} )	//"Ativo Diferido"
				Aadd(uRetorno, { 	'N1_PATRIM == "I"'			, "f10_null" 	} )	//"Ativo Intangvel"
				Aadd(uRetorno, { 	'N1_PATRIM == "O"'			, "f10_amar" 	} )	//"Oramento de Proviso de Despesa"
				Aadd(uRetorno, { 	'N1_PATRIM == "V"'			, "f10_verd" 	} )	//"Proviso de Despesa"
				Aadd(uRetorno, { 	'N1_PATRIM == "T"'			, "f10_cinz" 	} )	//"Custos de Transao"
				Aadd(uRetorno, { 	'N1_PATRIM == "E"'			, "f10_lara" 	} )	//"Bem Baixado"
				Aadd(uRetorno, { 	'ALLTRIM(N1_STATUS) == "0"'	,"f10_pink" 	} )	//"Pendente Classificao"			
				Aadd(uRetorno, { 	'N1_PENHORA == "1"'			, "BR_LARANJA" 	} )	//"Bem em Garantia"
				Aadd(uRetorno, { 	'N1_PENHORA == "2"'			, "BR_BRANCO" 	} )	//"Bem em Penhora"
				Aadd(uRetorno, { 	'N1_PENHORA == "3"'			, "BR_PRETO" 	} )	//"Bem Penhorado"
				Aadd(uRetorno, { 	'N1_PATRIM $ " N"'			, "BR_VERDE" 	} )	//"Ativo Fixo"
			Endif
		ElseIf cAlias = "SN3"
		  	Aadd(uRetorno, { 	'AfxLegTran()'				,"BR_PINK" 		} )	//"Transferencia Interna de Filial"
			Aadd(uRetorno, { 	'N3_BAIXA > "0" .And. ! Empty(N3_DTBAIXA)', "BR_VERMELHO" } )	//"Custo de Emprstimo"
			Aadd(uRetorno, { 	'.T.'							, "BR_VERDE" 		} ) //"Ativo Fixo"
		Endif				           			

		If ValType( uRetorno ) == 'A' .And. Len( uRetorno ) > 0 .And. Type("aRotina") == "A"
			If aScan(aRotina,{|x| Upper(AllTrim(x[2])) == Upper("AtfLegenda")}) == 0
				Aadd(aRotina, { OemToAnsi(STR0002) ,"AtfLegenda", 0 , 5} )	// "Legenda"
			EndIf
		Endif
	Else
		If cAlias = "SN1"
			if cPaisLoc == "RUS"
				aLegenda := { 	{ "f10_pink"	, STR0043 },;	//"Schedule"
								{ "BR_VERDE"	, STR0044 },; 	//"Active"
								{ "BR_AZUL"		, STR0045 },; 	//"Conservation"
								{ "BR_VERMELHO" , STR0012 }}	//"Write-off"
			else
				aLegenda := { 	{ "BR_VERDE"	, STR0003 },; 	//"Ativo Fixo"
								{ "BR_AMARELO"	, STR0004 },; 	//"Patrimonio Liquido"
								{ "BR_CINZA"	, STR0005 },; 	//"Amortizacao"
								{ "BR_AZUL"		, STR0006 },; 	//"Capital Social"
								{ "BR_MARROM"	, STR0007 },; 	//"Patrimonio (Prejuizo)"
								{ "f10_azul"	, STR0008 },; 	//"Ativo Diferido"
								{ "f10_null"	, STR0009 },; 	//"Ativo Intangvel"
								{ "f10_amar"	, STR0010 },; 	//"Oramento de Proviso de Despesa"
								{ "f10_verd"	, STR0011 },; 	//"Proviso de Despesa"
								{ "f10_cinz"	, STR0042 },; 	//"Custos de Transao"
								{ "f10_lara"	, STR0013 },;	//"Custo de Emprstimo"
								{ "BR_VERMELHO" , STR0012 },;	//"Bem Baixado"
								{ "BR_LARANJA"	, STR0014 },;	//"Bem em Garantia"
								{ "BR_BRANCO"	, STR0015 },;	//"Bem em Penhora"
								{ "BR_PRETO"	, STR0016 },;	//"Bem Penhorado"
								{ "BR_PINK"		, STR0017 },;	//"Transferencia Interna de Filial"
								{ "f10_pink"	, STR0018 }}	//"Pendente Classificao"
			endif				         					         	
		ElseIf cAlias = "SN3"
			aLegenda := { { "BR_VERDE"		, STR0003 },; //"Ativo Fixo"
							{ "BR_VERMELHO"	, STR0012 },; //"Bem Baixado"
							{ "BR_PINK"		, STR0017 }}	//"Transferencia Interna de Filial"
		Endif	

		//P.E Caixa de Legenda
		If ExistBlock("ATFLEGCX")
				aLegNew := ExecBlock("ATFLEGCX",.F.,.F.,{nReg,cAlias,aLegenda})
				If Len(aLegNew) > 0
					aLegenda  := aClone(aLegNew)
				EndIf
		Endif

		BrwLegenda(cCadastro, STR0002, aLegenda) 			//"Legenda"
	Endif
Endif

//P.E Legendas no browse
If ExistBlock("ATFLEGPOS")
	If nReg == Nil
		aCoresNew := ExecBlock("ATFLEGPOS",.F.,.F.,{nReg,cAlias,uRetorno})
		If Len(aCoresNew) > 0
			uRetorno  := aClone(aCoresNew)
		EndIf	
	EndIf	
EndIf	

Return uRetorno



/*/

Ŀ
Funo     RetDinDepr  Autor  Eduardo Fernandes      Data  26/07/06 
Ĵ
Descrio Retorna a data do primeiro dia do mes subsequente, para ser   
          utilizado quando o parametro MV_TIPDEPR estiver com conteudo  
          igual a 2(Tipo Depreciacao/Mes Subsequente)    				
Ĵ
 Uso       Dicionario(X3_RELACAO)/ATFA250 - AF250Rateio                 
ٱ


*/
Function RetDinDepr(dData)
Local dRetDt 		:= dData
Local cTipDepr 		:= SuperGetMv("MV_TIPDEPR",.F.,"0")
Local cCalcDep 		:= SuperGetMv("MV_CALCDEP",.F.,"0") // 0-MENSAL / 1-ANUAL
Local dAquisic		:= IIF(Type("M->N1_AQUISIC") == "D", M->N1_AQUISIC, dData)
Local lSetCentury 	:= __SetCentury()
Local nDiasPDI		:= SuperGetMv("MV_ATFDPDI",.F.,0) // Dias para considerar proporcional ou integral


If !lSetCentury
	SET CENTURY ON
EndIf

IF cTipDepr == "2" .or. lIsRussia // Tratamento para tipo de deprecao igual a 2 Ou Tratamento para todos os tipos na localizao Russia | Treatment for type of deprecation equal to 2 Or Treatment for all types in the location Russia
	dRetDt := FirstDay(MsSomaMes(dData, 1, .F.))
ElseIf cTipDepr == "5"
	dRetDt := STOD(StrZero(Year(GetMv("MV_ULTDEPR"))+1,4)+"0101")
Endif

IF cPaisLoc == "COL" .AND. cCalcDep == "0"
	dRetDt := IIF(dAquisic == FirstDay(dDatabase), dAquisic, FirstDay(MsSomaMes(dData, 1, .F.)))
ELSEIF cPaisLoc == "EQU" .AND. cCalcDep == "0" .AND. cTipDepr == "0"
	dRetDt	:= IIF(dData-FirstDay(dData) <= nDiasPDI, FirstDay(dData), dData)
ElseIf (cPaisLoc == "BRA" .And. (FwIsInCallStack("AF240CLASS") .And. cTipDepr == "0" ))
	
	AtfSaveMvVar()
	
	Pergunte("AFA240",.F.)

	If (Valtype(mv_par04) == "N"  .And. mv_par04 == 2 )
		dRetDt := dAquisic	
	Else
		dRetDt := Iif ( dRetDt >= dAquisic, dRetDt, dAquisic )
	EndIf

	AtfRestMvPar()

ENDIF

If !lSetCentury
	SET CENTURY OFF
EndIf

Return (dRetDt)

/*


ͻ
Programa  ATFDINDPREAutor  Alvaro Camillo Neto  Data   11/28/09   
͹
Desc.     Gatilho do campo N1_AQUISIC                                 
                                                                      
͹
Uso        AP                                                         
ͼ


*/
Function ATFDINDPRE()	
	Local dDIndDPre    := RetDinDepr(M->N1_AQUISIC)
	Local nX           := 1
	Local dUltDepr     := GetMV("MV_ULTDEPR")
	Local dRetDt
	Local lTemAviso    := .F.
	Local lClicouSim   := .F.
	Local cTipDepr     := SuperGetMv("MV_TIPDEPR",.F.,"0")	
	Local oModel       := Nil
	Local oView        := Nil
	Local oSN3         := Nil
	Local nSN3         := 0
	Local oSN1			:= Nil 


If !FwIsInCallStack("AF012ATDOK") //No atualizar gatilho no commit
	If cTipDepr == "2"
		dRetDt := dUltDepr+1
		If M->N1_AQUISIC <= dUltDepr .And. ;
			dDIndDPre < dRetDt
			If Aviso(STR0019, STR0020;  //"Atencao"##"Data calculada para inicio maior que ultima data de depreciacao."
							+CRLF+STR0021+DtoC(dDIndDPre);  //"Data calculada : "
							+CRLF+STR0022+DtoC(dUltDepr);  //"Data ultima depreciacao : "
							+CRLF+STR0023+DtoC(dRetDt)+STR0024,{STR0025, STR0026},3) == 1  //"Considera data [ "##" ] para inicio da depreciacao?"##"Sim"##"No"
				dDIndDPre := dRetDt
				lClicouSim := .T.		
			EndIf
			lTemAviso := .T.
		EndIf
	EndIf

	// pego o modelo ativo se ele existir
	oModel := FWModelActive()

	// pego o submodelo caso tenha um modelo ativo
	If !Empty(oModel)
		oSN3 := oModel:GetModel('SN3DETAIL')
		oSN1 := oModel:GetModel('SN1MASTER')
	EndIf

	// verifico se o submodelo foi encontrado
	If !Empty(oSN3)
		nSN3 := oSN3:GetLine()

		For nX := 1 To oSN3:Length()
			oSN3:GoLine(nX)
			AF012VLAEC(nX)
			
			If cTipDepr == "0"
				If oSN3:GetValue("N3_DINDEPR") <> oSN1:GetValue("N1_AQUISIC")
					If IsBlind()
						oSN3:SetValue("N3_DINDEPR", dDIndDPre)
					Else
						If Aviso(STR0019, STR0047, {STR0025,STR0026},3) == 1
							oSN3:SetValue("N3_DINDEPR", dDIndDPre)
						EndIf	
					EndIf
				EndIf	
			EndIf	

			If cTipDepr == "1"
				If oSN3:GetValue("N3_DINDEPR") == oSN1:GetValue("N1_AQUISIC")
					oSN3:SetValue("N3_DINDEPR", dDIndDPre)
				ElseIf oSN1:GetValue("N1_AQUISIC") <> dDatabase .And. oSN3:GetValue("N3_DINDEPR") == dDatabase
					oSN3:SetValue("N3_DINDEPR", dDIndDPre)		
				EndIf	
			Endif

			If cTipDepr == "2" 
				If !lTemAviso .Or. lClicouSim
					oSN3:SetValue("N3_DINDEPR", dDIndDPre)									
				EndIf	
			Endif
	
		Next nX
		
		oSN3:GoLine(nSN3)

		oView := FWViewActive()
		If oView <> Nil
			oView:Refresh()
		EndIf		
	EndIf
EndIf

Return .T.
/*/


Ŀ
Funo     DateComp  Autor  Pedro Pereira Lima     Data  19.06.2008 
Ĵ
Descrio  Calcula dias, meses ou anos de diferenca entre as duas datas 
Ĵ
Sintaxe    DateComp(dInicio,dFim,cDataPart)                             
Ĵ
Parametros dInicio = Data de Inicio                                     
           dFim    = Data de Fim                                        
           cDataPart = Retorno do valor em ano, mes ou dia. (YY,MM,DD)  
Ĵ
Retorno    nRetorno = Valor da diferenca no formado definido em         
           cDataPart.                                                   
Ĵ
Uso        ATFA050                                                      
ٱ


/*/
Function DateComp( dInicio ,dFim ,cDataPart )
Local nRetorno   := 0
Local dData      := stod("")
Local lInvertido := .F.

DEFAULT cDataPart := "D"

	If dInicio > dFim
		dData   := dInicio
		dInicio := dFim
		dFim    := dData
		dData   := stod("")
		lInvertido := .T.
	EndIf

	cDataPart := upper( cDataPart )

	Do Case
		// se quiser saber a diferenca em anos
		Case cDataPart = "YY" .OR. cDataPart = "YYYY"

			dData := dInicio
			While dData >= dInicio .AND. dData < dFim
				nRetorno++
				dData := stod(strzero(year(dData),4)+strzero(Month(dData)+1,2)+"01")
			EndDo

		// se quiser saber a diferenca em meses
		Case cDataPart = "M" .OR. cDataPart = "MM"

			dData := MsSomaMes( stod(left(dtos(dInicio),6)+"01"), 1)
			dFim  := stod(left(dtos(dFim),6)+"01")
			While dtos(dData) > dtos(dInicio) .AND. dtos(dData) <= dtos(dFim)
				nRetorno++
				dData := MsSomaMes( dData, 1)
			EndDo

		// se quiser saber a diferenca em dias
		Case cDataPart = "D" .OR. cDataPart = "DD"
			nRetorno := dFim - dInicio

	EndCase

	If lInvertido
		nRetorno := nRetorno*-1
	EndIf

Return( nRetorno )

/*


Ŀ
Funo    AtfGetMtvo Autor  Totvs                  Data  03.09.08 
Ĵ
Descrio  Retorna a descricao do motivo da baixa                     
Ĵ
 Uso       SIGAATF                                                    
ٱ


*/
Function AtfGetMtvo( aMotBaixa, cMotivo )
	Local cReturn 	:= ""
	Local nPos		:= aScan( aMotBaixa, { |x| Left( x, 02 ) == cMotivo } )

	If nPos > 0
		cReturn := aMotBaixa[ nPos ]
	EndIf
Return cReturn




/*


ͻ
Programa  ATFCustod Autor  Pedro Pereira Lima   Data   03/06/09   
͹
Desc.      Retorna o tipo de custodia por "extenso": 1 = CETIP;       
           2 = SELIC; 3 = CBLC; 4 = OUTROS                            
͹
Uso        DIOPS                                                      
ͼ


*/
Function ATFCustod(cCodCustodia)
Local cRet := ""
Default cCodCustodia := ""

Do Case
	Case cCodCustodia == "1"
		cRet := "CETIP"
	Case cCodCustodia == "2"
		cRet := "SELIC"
	Case cCodCustodia == "3"
		cRet := "CBLC"
	Case cCodCustodia == "4"
		cRet := "OUTROS"
	Otherwise
		cRet := ""
EndCase

Return cRet




/*


ͻ
Programa  AtfMultMoeAutor   Acacio Egas         Data   10/06/09   
͹
Desc.      Rotina de tratamento de multiplas moedas.                  
           Retorna um vetor com o valor de todas as moedas utilizadas 
͹
Uso        SIGAATF                                                    
            Funcao "AtfSaldo" parametro 4.                            
ͼ


*/
Function AtfMultMoe(cAlias,cCampo,Block,nMaxMoed,lUpdDepPer)

Local aRetMoedas := {}
Local nRet
Local __nX
// ********************************
// Controle de multiplas moedas  *
// ********************************
Local __nQuantas := AtfMoedas()

Local cCalcDep		:= SuperGetMv("MV_CALCDEP",.F.,"") // 0 = Monthly or 1 = Annually
Local nNewPerDep	:= 0

Default nMaxMoed := __nQuantas
Default lUpdDepPer	:= .F.

cCampo := Alltrim(cCampo) // O Campo no pode ter numero

If Valtype(Block)<>"B"
	If SubStr(cCampo,Len(cCampo)) $ "0123456789" .or. Len(cCampo)>9

		Aviso(STR0019,STR0027, {"Ok"})  //"Ateno"##"Inconsistencia no tratamento de multiplas Moedas"
		Return nil

	EndIf
EndIf
// ********************************
// Controle de multiplas moedas  *
// ********************************


If lIsRussia .and. cCampo=="N3_TXDEPR" .and. Valtype(Block)=="B" .and. lUpdDepPer // Calculate the depreciation period according to the new depreciation tax
	// Calculate the depreciation period according to the new depreciation tax
	nRet := Eval(Block,1) // Trata bloco de codigo

	If nRet > 0
		nNewPerDep := (100 * 12)  / nRet
		If cCalcDep == "1" // 1 = Annually
			If nNewPerDep / 12 == Int(nNewPerDep / 12)
				nNewPerDep := nNewPerDep / 12
			Else
				nNewPerDep := Int(nNewPerDep / 12) + 1					
			Endif	
		Endif
		SN3->N3_PERDEPR := NoRound( nNewPerDep, TAMSX3('N3_PERDEPR')[2])
	Endif
Endif
For __nX := 1 to __nQuantas
	If Valtype(Block)=="B"

		// ************************
		// Trata bloco de codigo *
		// ************************
		nRet := Eval(Block,__nX)
		aAdd(aRetMoedas, nRet )

		// ***********************************
		// Grava bloco de codigo no campo   *
		// ***********************************
		If !Empty(cCampo) .and. !Empty(cAlias) //.and. aScan(__TTSPush,)

			If Len(cCampo)==9 .and. __nX>9
				(cAlias)->(FieldPut(FieldPos(SubStr(cCampo,1,8) + Alltrim(Str(__nX)) 	), nRet ))
			Else
				(cAlias)->(FieldPut(FieldPos(cCampo + Alltrim(Str(__nX)) 				), nRet ))
			EndIf

		EndIf

	Else

		If Len(cCampo)==9 .and. __nX>9
			aAdd(aRetMoedas, (cAlias)->(FieldGet(FieldPos(SubStr(cCampo,1,8) + Alltrim(Str(__nX)) ))) )
		Else
			aAdd(aRetMoedas, (cAlias)->(FieldGet(FieldPos(cCampo + Alltrim(Str(__nX)) ))) )
		EndIf

	EndIf

	If nMaxMoed==__nX

		Exit

	EndIf
Next

Return aRetMoedas

/*


ͻ
Programa  AtfMultPosAutor   Acacio Egas         Data   10/06/09   
͹
Desc.      Monta vetor com posio dos campos moeda.                  
͹
Uso        SIGAATF                                                    
ͼ


*/
Function AtfMultPos(aHeader,cCampo, nY)

Local nX
Local aPosMoedas := {}
//********************************
// Controle de multiplas moedas  *
//********************************
Local __nQuantas := AtfMoedas()
Default nY := 2
cCampo := Alltrim(cCampo) // O Campo no pode ter numero

If SubStr(cCampo,Len(cCampo)) $ "0123456789" .or. Len(cCampo)>9

	Aviso(STR0019,STR0027, {"Ok"})  //"Ateno"##"Inconsistencia no tratamento de multiplas Moedas"
	Return nil

EndIf

For nX := 1 to __nQuantas
	If Len(cCampo)=9 .and. nX>9
		aAdd(aPosMoedas , Ascan( aHeader	, {|e| Alltrim(e[nY]) = SubStr(cCampo,1,8) + Alltrim(Str(nX))} ) )
	Else
		aAdd(aPosMoedas , Ascan( aHeader	, {|e| Alltrim(e[nY]) = cCampo + Alltrim(Str(nX))} ) )
	EndIf
Next

Return aPosMoedas

/*


ͻ
Programa  AtfMoedas Autor   Acacio Egas         Data   10/06/09   
͹
Desc.      Retorna o numero de moedas do Ativo Fixo.                  
͹
Uso        SIGAATF                                                    
ͼ


*/
Function AtfMoedas()

Local nX

If __nQtdMoed == NIL
	__nQtdMoed	:= 0

	For nX := 1 to 99
		If SN3->(FieldPos("N3_VORIG"+ cValtoChar(nX))) > 0
			__nQtdMoed++
		Else
			Exit
		EndIf
	Next nX

	__nQtdMoed := IIF(__nQtdMoed >= 5 , __nQtdMoed , 5)	// Valor Default

EndIf

Return __nQtdMoed

/*/

Ŀ
Funo     ATFXPAcols   Autor  Claudio D. de Souza    Data  04.09.03 
Ĵ
Descrio  Pesquisa em aCols o conteudo de um determinado campo         
Ĵ
Sintaxe    ATFXPAcols(cCampo,xDefault) -> xDefault=Conteudo default caso 
           o campo nao seja encontrado.                                 
Ĵ
Uso        SigaAtf                                                      
ٱ


*/
Function ATFXPAcols(cCampo,xDefault)
Local nAscan := Ascan(aHeader	, {|e| Alltrim(e[2]) == cCampo })
Return If(nAscan>0, aCols[n][nAscan], xDefault)










/*


ͻ
Programa  ATFXTpBem Autor  Alvaro Camillo Neto  Data   25/01/11   
͹
Desc.     Retorna os tipo de bens das categorias Fiscal Gerencial     
Desc.     ou incentivada                                              
Ĵ
Parametros 01-nTipo      = Tipo                                       
                           1 - Fiscal                                 
                           2 - Gerencial                              
                           3 - Incentivada                            
                                                                      
           02-lArray      = Se retorna eh um array                    
͹
Uso        AP                                                        
ͼ


*/
Function ATFXTpBem(nTipo,lArray)
Local xTipo :=""
Local cTypes10		:= IIF(lIsRussia,"/" + AtfNValMod({1}, "/"),"") // CAZARINI - 27/03/2017 - If is Russia, add new valuations models - main models
Local cTypes12		:= IIF(lIsRussia,"/" + AtfNValMod({2}, "/"),"") // CAZARINI - 10/04/2017 - If is Russia, add new valuations models - recoverable models
Local cTypes17		:= IIF(lIsRussia,"/" + AtfNValMod({3}, "/"),"") // CAZARINI - 27/03/2017 - If is Russia, add new valuations models - 17 and 16 models
Local cTypes16		:= IIF(lIsRussia,"/" + AtfNValMod({4}, "/"),"") // CAZARINI - 27/03/2017 - If is Russia, add new valuations models - 17 and 16 models
Default nTipo := 1
Default lArray:= .F.

If Empty(cTipoGerenc)
	cTipoGerenc := RetTipGer()
EndIf

If nTipo == 1 //Fiscal
	xTipo := cTipoFiscal
ElseIf nTipo == 2 //Gerencial
	xTipo := cTipoGerenc
ElseIf nTipo == 3 //Incentivada
	xTipo := cTipoIncent
ElseIf nTipo == 4 //Todos
	xTipo := cTipoFiscal+"/"+cTipoGerenc+"/"+cTipoIncent
EndIf

IF "10" $ xTipo
	xTipo += cTypes10
Endif

IF "12" $ xTipo
	xTipo += cTypes12
Endif

IF "17" $ xTipo
	xTipo += cTypes17
Endif

IF "16" $ xTipo
	xTipo += cTypes16
Endif
If lArray
	xTipo := StrToKarr(xTipo,"/")
EndIf

Return xTipo

/*


ͻ
Programa  RetTipGer  Autor  Microsiga            Data   01/20/11   
͹
Desc.     Retorna o tipo gerencial que so todos os tipos que no     
          so fiscais nem gerenciais                                  
͹
Uso        AP                                                        
ͼ


*/
Static Function RetTipGer()
Local cTipo := ""
Local aArea:= GetArea()

SX5->(dbSetOrder(1))//X5_FILIAL + X5_TABELA + X5_CHAVE
If SX5->(MsSeek( xFilial("SX5") + "G1" ))
	While SX5->(!EOF()) .And. SX5->(X5_FILIAL+X5_TABELA) == xFilial("SX5") + "G1"
		If ! ( Alltrim(SX5->X5_CHAVE) $ cTipoFiscal + "/" + cTipoIncent )
			cTipo += Alltrim(SX5->X5_CHAVE) + "/"
		EndIf
		SX5->(dbSkip())
	EndDo
EndIf

cTipo := Left(cTipo,Len(cTipo)-1)

RestArea(aArea)
Return cTipo


/*


ͻ
Programa  ATFXVUTIL Autor  Jair Ribeiro         Data   24/02/11   
͹
Desc.     Retorna o tipo gerencial que so todos os tipos que no     
          so fiscais nem gerenciais                                  
͹
Uso        AP                                                         
ͼ


*/
Function ATFXVUTIL(cTipoDpr,nTxMoeda,nPerDpr,nProdT,nProdM)
Local nVUtil := 0
Local cCalcDpr := 0

Default cTipoDpr:= ""
Default nTxMoeda:= 0
Default nPerDpr := 0
Default nProdT := 0
Default nProdM := 0

If !Empty(cTipoDpr)
	Do Case
		Case cTipoDpr == "1" .or. cTipoDpr == "7" .and. nTxMoeda > 0
			nVUtil:= (100/nTxMoeda)
		Case cTipoDpr == "2" .or. cTipoDpr == "6"
			cCalcDpr:= Alltrim(SUPERGETMV("MV_CALCDEP",,1)) //Calculo de Depreciacao
			If cCalcDpr == "0"
				nVUtil:= (nPerDpr/12)
			Else
				nVUtil:= nPerDpr
			EndIf
		Case cTipoDpr == "4" .or. cTipoDpr == "5" .and. nProdT > 0 .and. nProdM > 0
			nVUtil:=  nProdT/nProdM
	EndCase
EndIf
Return nVUtil


/*


ͻ
Programa  ATFXBAIXA Autor  Jair RIbeiro         Data   02/24/11   
͹
Desc.      Funcao retorna situacao do ativo (ativo, baixado, parcial) 
͹
Parametro: cChave: Chave para busca - FILIAL+CBASE+ITEM+TIPO    	  
͹
Retorno:   cRet: Caracter                                             
           Ativo                                                      
           Baixado                                                    
           Parcial                                                    
͹
Uso        Generico                                                   
ͼ


*/

Function ATFXBAIXA(cChave,dDataRef,cSeqReav)
Local aArea	:= SN3->(GetArea())
Local cRet  := 0
Local nAtivo:= 0
Local nBaixa:= 0
Local nReg  := 0

Default cChave 		:= ""
Default dDataRef	:= dDataBase
Default cSeqReav	:= ""

If !Empty(cChave)
	SN3->(DbSetOrder(1))
	SN3->(DbSeek(cChave))
	While SN3->(!EOF()) .and. SN3->(N3_FILIAL + N3_CBASE + N3_ITEM + N3_TIPO ) == cChave

		If !Empty(cSeqReav) .And. Alltrim(SN3->N3_SEQREAV) != Alltrim(cSeqReav)
			SN3->(DbSkip())
			Loop
		EndIf

		If SN3->N3_DTBAIXA > dDataRef .or. Empty(SN3->N3_DTBAIXA)
			nAtivo++
		Else
			nBaixa++
		EndIf
		nReg++
		SN3->(DbSkip())
	EndDo
	If nReg > 0
		Do Case
			Case nAtivo == nReg
				cRet := STR0028 //"Ativo"
			Case nBaixa == nReg
				cRet := STR0029//"Baixado"
			OtherWise
				cRet := STR0030//"Parcial"
		EndCase
	EndIf
EndIf
RestArea(aArea)
Return cRet
/*


ͻ
Programa  ATFxTpDescBem Autor  Fernando Radu Muscalu Data   02/24/11   
͹
Desc.      Funcao retorna a descricao do tipo em que o bem se enquadra 	   
͹
Parametro: cTipo: Parametro com o conteudo relacionado ao N3_TIPO  	       
͹
Retorno:   cRetorno: Descricao do tipo                                     
           - Fiscal                                                        
           - Gerencial                                                     
           - Incentivado                                               	   
           - Nao especificado                                          	   
͹
Uso        Generico                                                   	   
ͼ


*/
Function ATFXDTPBEM(cTipo)

Local cTpFiscais		:= AtfxTpBem(1)
Local cTpGerenciais		:= AtfxTpBem(2)
Local cTpIncentivados	:= AtfxTpBem(3)
Local cRetorno			:= ""

Do Case
	Case alltrim(cTipo) $ cTpFiscais
		cRetorno := STR0031 //"Fiscal"
	Case alltrim(cTipo) $ cTpGerenciais
		cRetorno := STR0032//"Gerencial"
	Case alltrim(cTipo) $ cTpIncentivados
		cRetorno := STR0033 //"Incentivado"
	Otherwise
		cRetorno := STR0034//"No especificado"
End Case

Return(cRetorno)

/*


ͻ
Programa  |ATFxMDP	Autor  Jair Ribeiro         Data   03/01/11   
͹
Desc.      Retorna o valor maximo de depreciacao do bem               
                                                                      
͹
ParametroscChave:Chave de busca FILIAL+CBASE+ITEM+TIPO+FLAGBAIXA+SEQ  
			 |nValOrig: Valor original do bem					          
͹
Retorno	 nValor: Valor maximo de depreciacao				          
͹
Uso        SIGAATF                                                    
ͼ


*/
Function ATFXMDP(cChave,nValOrig)

Local nVMaxDpr	:= 0
Local cMoedaDpr:= SuperGetMV("MV_ATFMDMX",,"1")
Local aArea  	:= SN3->(GetArea())

If Empty(cMoedaDpr)
	cMoedaDpr := "1"
EndIf

SN3->(DbSetOrder(1))
If SN3->(DbSeek(cChave))
	nVMaxDpr:=(SN3->N3_VMXDEPR)/SN3->&("N3_VORIG"+cMoedaDpr)
EndIf

nVMaxDpr := (nValOrig*nVMaxDpr)

RestArea(aArea)

Return nVMaxDpr


/*


Ŀ
Funo    RetTipDepr Autor  Jair RIbeiro           Data  27/04/11 
Ĵ
Desc.      Sugere criterio de depreciacao	                          
Ĵ
Uso        SIGAATF                                                    
Ĵ
 Sintaxe   RetTipDepr(cTipDepr) 					                  
Ĵ
Parametros cTipDepr: criterio a ser sugerido						  
ٱ


*/
Function RetTipDepr(cTipDepr)
Local cParTipDepr := Alltrim(SuperGetMv("MV_TIPDEPR",.F.,""))
Default cTipDepr := "01"

If cParTipDepr != "9"
	Do Case
		Case cParTipDepr == "0"
			cTipDepr :=	"00"
		Case cParTipDepr == "1"
			cTipDepr :=	"01"
		Case cParTipDepr == "2"
			cTipDepr :=	"02"
		Case cParTipDepr == "3"
			cTipDepr :=	"10"
		Case cParTipDepr == "4"
			cTipDepr :=	"11"
		Case cParTipDepr == "5"
			cTipDepr :=	"12"
		OtherWise
			cTipDepr :=	"01"
	EndCase
EndIf
Return cTipDepr



/*


Ŀ
Funo    ATFCBGener Autor  Marcelo Akama          Data  12/02/10 
Ĵ
Descrio  Retorna uma string com os itens da tabela generica         
           informada para uso no combo box                            
           X3_CBOX := "#AdmCBGener(cFil,cAlias,cTabela,cIdioma)"      
Ĵ
 Uso       Generico                                                   
Ĵ
 Sintaxe   AdmCBGener(cFil,cAlias,cTabela,cIdioma)                    
Ĵ
Parametros cAlias  - Alias ("SX5", "CW0" ou "SN0")                    
           cTabela - Codigo da tabela                                 
           cIdioma - Idioma                                           
                         "01" - Portugues                             
                         "02" - Espanhol                              
                         "03" - Ingles                                
           aChave  - Array para filtro de acordo com o campo _CHAVE   
ٱ


*/
Function ATFCBGener(cFil,cAlias,cTabela,cIdioma,aChave)
Local cRet		:= ''
Local aArea		:= GetArea()
Local aArea2
Local cPrefix
Local cFldDsc
// Variaveis especificas para projeto Rssia | Specific variables for project Russia
Local lTemMod10	:= .F.
Local lTemMod12	:= .F.
Local aValMod	:= {}
Local cValMod	:= ""
Local nValMod	:= 0
Local aAreaSX5	:= {}
Local lChk1012 	:= .F.
//
Default cIdioma := ""
Default cAlias  := "SX5"
Default cTabela := "01"
Default cFil    := xFilial(cAlias)
Default aChave	:= {}

If Valtype(aChave) != "A"
	aChave	:= {}
EndIf

If cAlias $ "SX5.CW0.SN0"

	If cAlias == "SX5"

        cPrefix := "X5"

		if ( FwRetIdiom()=="es" )
			cFldDsc := "_DESCSPA"
		else
			if ( FwRetIdiom()=="en" )
				cFldDsc := "_DESCENG"
			  else
				cFldDsc := "_DESCRI"
			  endif
		   endif 

	ElseIf cAlias=="SN0"
		cPrefix := "N0"
		cFldDsc := "_DESC01"
	Else
		cPrefix := cAlias
		cFldDsc := "_DESC01"
	EndIf

	DbSelectArea(cAlias)
	aArea2:=(cAlias)->(GetArea())

	(cAlias)->(DbSetOrder(1))
	(cAlias)->(MsSeek(cFil+cTabela))

	Do While cFil + cTabela == (cAlias)->( &(cPrefix + "_FILIAL") + &(cPrefix + "_TABELA") )
		lChk1012 := .F.
		If Empty(aChave)
			cRet := cRet + IIf(empty(cRet),'',';') + Alltrim(&(cPrefix + "_CHAVE")) + '=' + Alltrim(&(cPrefix + cFldDsc))
		    lChk1012 	:= lIsRussia // A variavel  atribuida como verdadeira apenas se a localizao for Russia |The variable is assigned as true only if the location is Russia
		Else
			If AsCan(aChave,{|aX| AllTrim(aX) == AllTrim((cAlias)->(&(cPrefix + "_CHAVE")))}) > 0
				cRet := cRet + IIf(empty(cRet),'',';') + Alltrim(&(cPrefix + "_CHAVE")) + '=' + Alltrim(&(cPrefix + cFldDsc))
				lChk1012 	:= lIsRussia // A variavel  atribuida como verdadeira apenas se a localizao for Russia |The variable is assigned as true only if the location is Russia
			EndIf
		EndIf
		If lChk1012 // CAZARINI - 10/03/2017 - If is Russia, add new valuations models - main models
			If cAlias == "SX5" .and. cTabela == "G1"	
				If Alltrim(SX5->X5_CHAVE) == "10"
					lTemMod10 := .T.
				Endif
				If Alltrim(SX5->X5_CHAVE) == "12"
					lTemMod12 := .T.
				Endif
			Endif		
		Endif		
		(cAlias)->(DbSkip())
	EndDo
	RestArea(aArea2)
EndIf
If lTemMod10 // CAZARINI - 10/03/2017 - If is Russia, add new valuations models - main models
	cValMod	:= ATFNValMod( {1}, '/' )
	aValMod	:= Separa(cValMod, '/', .f.) 

	aAreaSX5 := SX5->(GetArea())

	DbSelectArea("SX5")
	DbSetOrder(1) // X5_FILIAL+X5_TABELA+X5_CHAVE                                                                                                                                    
	For nValMod := 1 to len(aValMod)
		If MsSeek(cFil+cTabela+aValMod[nValMod])
			cRet := cRet + IIf(empty(cRet),'',';') + Alltrim(SX5->X5_CHAVE) + '=' + Alltrim(&(cPrefix + cFldDsc))
		Endif
	Next nValMod

	RestArea(aAreaSX5)
Endif

If lTemMod12 // CAZARINI - 10/04/2017 - If is Russia, add new valuations models - main models
	cValMod	:= ATFNValMod( {2}, '/' )
	aValMod	:= Separa(cValMod, '/', .f.) 

	aAreaSX5 := SX5->(GetArea())

	DbSelectArea("SX5")
	DbSetOrder(1) // X5_FILIAL+X5_TABELA+X5_CHAVE                                                                                                                                    
	For nValMod := 1 to len(aValMod)
		If MsSeek(cFil+cTabela+aValMod[nValMod])
			cRet := cRet + IIf(empty(cRet),'',';') + Alltrim(SX5->X5_CHAVE) + '=' + Alltrim(&(cPrefix + cFldDsc))
		Endif
	Next nValMod

	RestArea(aAreaSX5)
Endif


RestArea(aArea)
Return(cRet)



Function AtfXPerCal(dData,cCriterio,cCalend)

Local nI		:= 0
Local nAno		:= 0
Local nMes		:= 0
Local nAnoUso	:= 0
Local nQtdTri	:= 0

Local cPeriodo	:= ""
Local cDataIni	:= ""
Local cDataFim	:= ""

Local aAuxPer	:= {}
Local aPeriodo	:= {}
Local aMesCalTri:= {}

Local dDataIni	:= stod("")
Local dDataFim	:= stod("")

Local xRet		:= .t.

If Alltrim(cCriterio) $ "03|04"

	If !Empty(cCalend)

		cPeriodo := SN0->(GetAdvFVal("SN0","N0_DESC01",xFilial("SN0") + '06' + cCalend,1,""))

		If !Empty(cPeriodo)
			aAuxPer := Separa(cPeriodo,"|")

			For nI := 1 to len(aAuxPer)
				aAdd(aPeriodo,Separa(aAuxPer[nI],"/"))
				aPeriodo[len(aPeriodo),1] := Val(aPeriodo[len(aPeriodo),1])
				aPeriodo[len(aPeriodo),2] := Val(aPeriodo[len(aPeriodo),2])
			Next nI

			nAno := Year(dData)
			nMes := Month(dData)

			If nMes < aPeriodo[1,2]
				nAnoUso 	:= nAno - 1
			Else
				nAnoUso		:= nAno
			Endif

			cDataIni	:= Alltrim(str(nAnoUso)) + StrZero(aPeriodo[1,2],2) + StrZero(aPeriodo[1,1],2)

			If aPeriodo[2,2] < aPeriodo[1,2]
				nAnoUso++
			Endif

			cDataFim := Alltrim(str(nAnoUso)) + StrZero(aPeriodo[2,2],2) + StrZero(aPeriodo[2,1],2)

			dDataIni := stod(cDataIni)
			dDataFim := stod(cDataFim)

			If Alltrim(cCriterio) == "04"

				nMes := DateDiffMonth(dDataFim,dDataIni) + 1 //considerar o mes inicial

				If Mod(nMes,3) <> 0
					Help(" ",1,"AtfXPerCal_02",,"Critrio de depreciao, Prximo Trimestre, exige que o calendrio utilizado seja compatvel, ou seja mltiplo de trs. ",1,0)
					xRet := .f.
				Endif

				nQtdTri := 1
				aAuxPer	:= {}

				While dDataIni <= dDataFim
					aAdd(aAuxPer, Month(dDataIni))

					nQtdTri++

					dDataIni := LastDay(LastDay(dDataIni)+1)

					If nQtdTri > 3
						aAdd(aMesCalTri,aAuxPer)
						aAuxPer := {}
						nQtdTri := 1
					Endif
				EndDo

				nAnoUso := nAno

				For nI := 1 to len(aMesCalTri)

					nPos := aScan(aMesCalTri[nI],{|x| x == Month(dData)})

					If nPos > 0
						nPos := nI
						Exit
					Endif

				Next nI

				nPos++

				If nPos > len(aMesCalTri)
					nAnoUso++
					nMes := aMesCalTri[1,1]
				Else

					If nPos == 1 .and. Month(dData) > aMesCalTri[len(aMesCalTri),3]
						nAnoUso++
					Endif

					nMes := aMesCalTri[nPos,1]
				Endif

				cDataIni := Alltrim(Str(nAnoUso))+StrZero(nMes,2)+StrZero(aPeriodo[1,1],2)
				dDataIni := sTod(cDataIni)

				cDataFim := Alltrim(Str(nAnoUso)) + StrZero(aMesCalTri[len(aMesCalTri),3],2) + StrZero(aPeriodo[2,1],2)
				dDataFim := StoD(cDataFim)
			Endif

			xRet := {dDataIni,dDataFim}
		Else
			Help(" ",1,"AtfXPerCal_03",,"Calendrio de depreciao, " + alltrim(cCalend) + ", informado no existe.",1,0)
			xRet := .f.
		Endif

	Endif
Else
	Help(" ",1,"AtfXPerCal_01",,"Critrio de depreciao escolhido deve ser 03 - Exerccio Completo ou 04 -  Prximo Trimestre.",1,0)
	xRet := .f.
Endif

Return(xRet)



/*


ͻ
Programa  AtfGetSN0 Autor  Microsiga            Data   09/09/11   
͹
Desc.     Extrai conteudo do campo na tabela / chave especificada     
                                                                      
͹
Uso        AP                                                         
ͼ


*/

Function AtfGetSN0(cTabela,cChave, xCampo, xRetInv)
Local xRet

Default xCampo 		:= "N0_DESC01"
Default xRetInv 	:= ""
If !Empty(cTabela) .And. !Empty(cChave)
	xRet := SN0->(GetAdvFVal("SN0",xCampo,xFilial("SN0") + cTabela + cChave,1,xRetInv))
Else
	xRet := xRetInv
EndIf

Return(xRet)

/*


ͻ
Programa  AtfGetSN0 Autor  Microsiga            Data   09/09/11   
͹
Desc.     Atualiza tabela / chave / campo especificada c/ Conteudo    
          informado                                                   
͹
Uso        AP                                                         
ͼ


*/

Function AtfPutSN0(cTabela,cChave, cCampo, cConteudo)
Local lRet  := .F.
Local lGrava := .F.
Local nCpoAux

Default cCampo 		:= "N0_DESC01"

If !Empty(cTabela) .And. !Empty(cChave) .And. !Empty(cCampo)
	dbSelectArea("SN0")
	dbSetOrder(1)
	lGrava := SN0->(!dbSeek( xFilial("SN0")+ cTabela + cChave ))
	RecLock("SN0",lGrava)
	If lGrava
		SN0->N0_FILIAL	:= xFilial("SN0")
		SN0->N0_TABELA	:= cTabela
		SN0->N0_CHAVE	:= cChave
	EndIf
	If ( nCpoAux := FieldPos(Alltrim(Upper(cCampo))) ) > 0
		SN0->( FieldPut(nCpoAux, cConteudo) )
	EndIf
	MsUnLock()
EndIf

Return(lRet)

/*


ͻ
Programa  AfxLegTran   Autor  Microsiga            Data   09/12/11   
͹
Desc.     Retorna a legenda do ativo transferido para mbrows com      
          SN3                                                         
͹
Uso        AP                                                        
ͼ


*/
Function AfxLegTran()
Local aArea		:= GetArea()
Local lTransf	:= .F.
Local cAliasQry	:= GetNextAlias()

//---------------------------------------------------
// Query necessaria para identificar transferncias  
// parciais, onde a SN1 no fica com o N1_STATUS = 4
//---------------------------------------------------
BeginSQL Alias cAliasQry
SELECT FN7_CODBX
FROM %Table:FN7% FN7
WHERE	FN7.FN7_FILORI	= %Exp:SN3->N3_FILORIG%	AND
		FN7.FN7_CBASE	= %Exp:SN3->N3_CBASE%	AND
		FN7.FN7_CITEM	= %Exp:SN3->N3_ITEM%	AND
		FN7.FN7_TIPO	= %Exp:SN3->N3_TIPO%	AND
		FN7.FN7_SEQ		= %Exp:SN3->N3_SEQ%		AND
		FN7.FN7_TPSALD	= %Exp:SN3->N3_TPSALDO%	AND
		FN7.FN7_MOTIVO	= '18'					AND
		FN7.FN7_STATUS	= '1'					AND
		FN7.%NotDel%
EndSQL

If (cAliasQry)->(!Eof())
	lTransf := .T.
EndIf

//----------------------------------------------------------------
// Tratamento incluso devido registros migrados da verso 11 onde 
// no havia as tabelas FN6 e FN7, porem as baixas eram integrais
//----------------------------------------------------------------
If !lTransf
	SN1->(DBSetOrder(1))
	If SN1->(MsSeek(xFilial("SN1",SN3->N3_FILIAL) + SN3->( N3_CBASE + N3_ITEM )))
		lTransf := SN1->N1_STATUS == '4'
	EndIf
EndIf

(cAliasQry)->(DBCloseArea())

RestArea(aArea)
Return lTransf

/*


ͻ
Programa  ATFXProxItAutor  Alvaro Camillo Neto  Data   10/27/11   
͹
Desc.      Retorna Item (N1_ITEM) disponivel de acordo com codigo     
           base                                                       
͹
Uso        AP                                                        
ͼ


*/
Function ATFXProxIt(cFil,cBase,cItem)

Local aArea		 := SN1->(GetArea())
Local nLenN1Item := TamSx3("N1_ITEM")[1]
Local cNewItem	 := STRZERO(0,nLenN1Item)
Local l1z_Or_2z  := .F.

Default cFil 	 := cFilAnt
Default cBase	 := ""
Default cItem	 := ""

If !Empty(cFil) .and. !Empty(cBase)
	cQry := " SELECT"+chr(13)+chr(10)
	cQry += " COALESCE( MAX(N1_ITEM),'"+PadR(Space(1),nLenN1Item)+"') ITEM"+chr(13)+chr(10)
	cQry += " FROM "+RetSQlName("SN1")+ " N1 "+chr(13)+chr(10)
	cQry += " WHERE N1_FILIAL = '"+xFilial("SN1",cFil)+"'"+chr(13)+chr(10)
	cQry += " AND N1_CBASE = '"+cBase+"'"+chr(13)+chr(10)
	cQry += " AND N1.D_E_L_E_T_ = ' ' "

	cQry := ChangeQuery(cQry)

	If Select("SN1ITEM") > 0
		SN1ITEM->(DbCloseArea())
	Endif
	DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry), "SN1ITEM", .T., .F.)
	If Empty(SN1ITEM->ITEM)
		cNewItem := IiF(Empty(cItem),Soma1(Alltrim(cNewItem)),cItem)
	Else
		//Somente 1 digito Z OU Somente 2 digitos Z
		l1z_Or_2z := If( Upper(Alltrim(SN1ITEM->ITEM)) == "Z" .OR. Upper(Alltrim(SN1ITEM->ITEM)) == "ZZ", .T., .F.)
		cNewItem := If(!l1z_Or_2z , Soma1(Alltrim(SN1ITEM->ITEM)), Soma1(SN1ITEM->ITEM) )
	EndIf
	SN1ITEM->(DbCloseArea())

	//Tratamento pois a funo Soma1 no preserva o tamanho do campo
	cNewItem := PADR( cNewItem, nLenN1Item )
EndIf

SN1->(RestArea(aArea))

Return cNewItem

/*


ͻ
Funcao     AFXIndRev		Autor  Alvaro Camillo Neto     10/10/12
͹
Desc.      Busca a revisao de indice (FNI) valida para data passada pelo parametro      
͹
Uso        AP                                                         
ͼ


*/
Function AFXIndRev(cIndice,dDataRev)
Local aArea := GetArea()
Local cRev  := ""
Local cQuery   := ""
Local cTab     := GetNextAlias()

Default dDataRev := CTOD("")

// Atualiza apenas as curvas vlidas
cQuery   += " SELECT MAX(FNI_REVIS) ULTREV"
cQuery   += " FROM " + RetSQLTab("FNI")
cQuery   += " WHERE "
cQuery   += " FNI_FILIAL = '"+xFilial("FNI")+"' "
cQuery   += " AND FNI_CODIND = '"+cIndice+"' "
If !Empty(dDataRev)
	cQuery   += " AND FNI_DTREV <= '"+DTOS(LastDay(dDataRev))+"' "
EndIf
cQuery   += " AND D_E_L_E_T_ = ' ' "
cQuery   := ChangeQuery(cQuery)
If Select(cTab) > 0
	(cTab)->(dbCloseArea())
EndIf

dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cTab, .T., .T.)

If (cTab)->(!EOF())
	cRev := (cTab)->ULTREV
EndIf

(cTab)->(dbCloseArea())
RestArea(aArea)
Return cRev




/*


ͻ
Programa  AFXDesPatrAutor  Alvaro Camillo Neto  Data   16/11/11   
͹
Desc.     Retorna a descrio da classificacao do ativo fixo          
                                                                      
͹
Uso        AP                                                        
ͼ


*/
Function AFXDesPatr(cPatrim)
Local cDesc := ""
Local aArea := GetArea()

dbSelectArea("SN0")
SN0->(dbSetOrder(1)) //N0_FILIAL+N0_TABELA+N0_CHAVE
If SN0->(MsSeek( xFilial("SN0") + "07" + cPatrim ))
	cDesc := Alltrim(SN0->N0_DESC01)
EndIf

RestArea(aArea)
Return cDesc
/*


ͻ
Programa  ATFxUltSeq   Autor  Renan Guedes      Data   11/22/11   
͹
Desc.     Pesquisa e retorna a ltima sequncia dos itens do bem (SN3)
                                                                      
͹
Uso        AP                                                        
ͼ


*/
Function ATFxUltSeq(cBase,cItem)

Local cSeq			:= ""
Local aArea			:= {}
Local aAreaSN3		:= {}
Local cAliasTrb		:= ""
Local cQuery		:= ""

Default cBase		:= ""
Default cItem		:= ""

aArea := GetArea()

If (ValType(cBase) == "C") .And. (ValType(cItem) == "C")
	
		cQuery	+= "	SELECT	"
		cQuery	+= "		MAX(SN3.N3_SEQ)	N3_SEQ	"
		cQuery	+= "	FROM " + RetSqlTab("SN3")
		cQuery	+= "	WHERE	"
		cQuery	+= "			SN3.D_E_L_E_T_ != '*'	"
		cQuery	+= "		AND SN3.N3_FILIAL 	= '" + xFilial("SN3") + "'"
		cQuery	+= "		AND SN3.N3_CBASE	= '" + cBase + "'"
		cQuery	+= "		AND SN3.N3_ITEM		= '" + cItem + "'"

		//Executa a query
		cAliasTrb := GetNextAlias()
		cQuery := ChangeQuery(cQuery )
		dbUseArea( .T. , "TOPCONN" , TcGenQry(,,cQuery) , cAliasTrb , .T. , .F.)
		(cAliasTrb)->(dbGoTop())

		//Verifica se retornou algum registro e armazena na varivel
		If (cAliasTrb)->(!EOF())
			cSeq := (cAliasTrb)->N3_SEQ
		EndIf
	
EndIf

RestArea(aArea)

Return(cSeq)

/*


ͻ
Programa  ATFxCtrlAprov  Autor  Renan Guedes    Data   12/13/11   
͹
Desc.     Verifica se o controle de aprovao est implementado e	  
          ativo para determinada rotina/operao                      
                                                                      
͹
Uso        AP                                                        
ͼ


*/
Function ATFxCtrlAprov(cRotina,cOper)

Local lRet			:= .F.
Local aArea			:= GetArea()
Local aAreaFNH		:= {}
Local aAreaFNK		:= {}
Local aAreaFNL		:= {}
Local nTamRot, nTamOper
Local cRevis		:= ""

Default cRotina		:= ""
Default cOper		:= ""

If (ValType(cRotina) == "C") .And. (ValType(cOper) == "C")
	nTamRot		:= TamSX3("FNH_ROTINA")[1]
	nTamOper	:= TamSX3("FNH_OPER")[1]

	//Padroniza os strings da rotina e operao
	cRotina		:= PADR(AllTrim(cRotina), nTamRot)
	cOper		:= PADR(AllTrim(cOper), nTamOper)

	dbSelectArea("FNH")
	aAreaFNH := FNH->(GetArea())
	FNH->(dbSetOrder(1))		//FNH_FILIAL+FNH_ROTINA+FNH_OPER

	//Procura pela rotina e operao
	If FNH->(MsSeek(xFilial("FNH")+cRotina+cOper))
		//Verifica se a rotina/operao est com o controle de aprovao habilitado
		If FNH->FNH_STATUS == "1"		//Habilitado

			//Procura pela alada de aprovao
			cRevis := AFXAprRev(cRotina)

			dbSelectArea("FNK")
			aAreaFNK := FNK->(GetArea())
			FNK->(dbSetOrder(1))		//FNK_FILIAL+FNK_ROTINA+FNK_REVIS
			If FNK->(MsSeek(xFilial("FNK")+cRotina+cRevis))
				If FNK->FNK_STATUS == "1"		//Habilitado

					//Procura por aprovadores habilitados
					dbSelectArea("FNL")
					aAreaFNL := FNL->(GetArea())
					FNL->(dbSetOrder(1))		//FNL_FILIAL+FNL_ROTINA+FNL_REVIS+FNL_OPER+FNL_CODAPR
					If FNL->(MsSeek(xFilial("FNL")+cRotina+cRevis+cOper))
						lRet := .T.
					EndIf
					RestArea(aAreaFNL)
				EndIf
			EndIf
			RestArea(aAreaFNK)
		EndIf
	EndIf
	RestArea(aAreaFNH)

EndIf

RestArea(aArea)

Return lRet


/*


ͻ
Programa  AFXAprRev   Autor  AFXAprRev           Data   12/23/11   
͹
Desc.      Retorna a ultima reviso da operacao da rotina             
                                                                      
͹
Uso        AP                                                        
ͼ


*/
Function AFXAprRev(cRotina)
Local cRev  := ""
Local aArea := GetArea()

FNK->(dbSetOrder(1))		//FNK_FILIAL+FNK_ROTINA+FNK_REVIS
If FNK->(MsSeek(xFilial("FNK")+cRotina))
	While FNK->(!EOF()) .And. FNK->(FNK_FILIAL+FNK_ROTINA) == xFilial("FNK")+cRotina
		cRev := FNK->FNK_REVIS
		FNK->(dbSkip())
	EndDo
EndIf

RestArea(aArea)
Return cRev




/*


ͻ
Programa  AFXPeriodo Autor  Alvaro Camillo Neto  Data   04/04/11   
͹
Desc.     Rotina que retorna um array com a data inicial e final      
          de todos meses de um perodo                                
͹
Uso        AP                                                        
ͼ


*/
Function AFXPeriodo(dDataIni,dDataFim)
Local aPeriodo := {}
Local dDataAux := FirstDay(dDataIni)

While dDataAux <= LastDay(dDataFim)
	aAdd(aPeriodo,{FirstDay(dDataAux),LastDay(dDataAux)})
	dDataAux := LastDay(dDataAux)+1
EndDo


Return aPeriodo


/*


ͻ
Programa  AFXVLGer  Autor  Alvaro Camillo Neto  Data   05/31/12   
͹
Desc.     Verifica se no ativo existe apenas o tipo 10 - gerencial    
           ou 13 adiantamento gerencial                               
͹
Uso        AP                                                        
ͼ


*/
Function AFXVLGer(cXFil,cBase,cItem,cTipo,cTpSald)
Local lRet     := .T.
Local aArea    := GetArea()
Local aAreaSN3 := SN3->(GetArea())

Default cXFil := xFilial("SN3")

SN3->(dbSetOrder(1)) //N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_BAIXA+N3_SEQ

If SN3->(MsSeek(cXFil + cBase + cItem + "01" )) .Or. SN3->(MsSeek(cXFil + cBase + cItem + "03" ))
	lRet := .F.
EndIf

If lRet .And. cTpSald != '1'
	lRet := .F.
EndIf

RestArea(aAreaSN3)
RestArea(aArea)
Return lRet


/*


ͻ
Programa  ADMGETCLASAutor  Rodrigo Gimenes      Data   03/07/12   
͹
Desc.      Adm_Opcoes de pesquisa por classificaes patrimoniais     
           existentes na tabela auxiliar do Ativo SN0 - Tabela 7      
͹
Retorno    aSelClass(Contem todas as classeificaes selecionada)     
Ĵ
Uso        SIGACTB, SIGAATF, SIGAFIN                                  
ͼ


*/
Function ADMGETCLAS(lTodas,lFnb)

Local cTitulo	:= ""
Local MvPar		:= ""
Local MvParDef	:= ""
Local nI 		:= 0
Local aArea 	:= GetArea()
Local nReg	    := 0
Local nSit		:= 0
Local aSit		:= {}
Local aSelClass	:= {}
Local nTamClass	:= 0
Local lOk		:= .T.


Default lTodas := .F.
Default lFnb   := .F.

	If !IsBlind()
		nI := 1
		aSit	:= {}
		MvParDef := ""
		cTitulo :=  STR0035//" Selecione as Classificacoes Patrimoniais "
		nTamClass := TAMSX3("N0_CHAVE")[1]
		DbSelectArea("SN0")
		SN0->(dbSetOrder(1))
		If SN0->(dbSeek( xFilial("SN0")+ "07" ))
			While !SN0->(Eof()) .And. AllTrim(SN0->N0_TABELA) == "07"
				lOk := IIf(lFnb,AllTrim(SN0->N0_CHAVE) $ "N|D|I",.T.)
				If lOk
					cDesc := ""
					cDesc := SN0->N0_DESC01
					Aadd(aSit, cDesc )
				 	MvParDef += SN0->N0_CHAVE
					 nI++
				EndIf
				SN0->(dbSkip())
			End
		EndIf

		IF AdmOpcoes(@MvPar,cTitulo,aSit,MvParDef,,,.F.,nTamClass,nI,.T.)  // Chama funcao Adm_Opcoes
			nSit := 1
			For nReg := 1 To len(mvpar) Step nTamClass  // Acumula as classificaes
				If SubSTR(mvpar, nReg, nTamClass) <> Replicate("*",nTamClass)
			 		AADD(aSelClass, SubSTR(mvpar, nReg, nTamClass) )
				Endif
				nSit++
			next
			If Empty(aSelClass)
	 	  		Help(" ",1,"ADMGETCLAS",,STR0036,1,0)		//"Por favor selecionar pelo menos uma classificao"
			EndIF
			lTodas := Len(aSelClass) == Len(aSit)
		Endif
	Else
		aSelClass := {"N"}
	EndIf

RestArea(aArea)

Return(aSelClass)

/*


ͻ
Programa  FORMATCLASAutor  Rodrigo Gimenes      Data   06/07/12   
͹
Desc.      Formata o array de classificaes selecionadas para        
           utilizao em filtros dos relatrios ou nas queries        
͹
Retorno    cClassif Todas as classeificaes selecionadas e formatadas
Ĵ
Uso        SIGACTB, SIGAATF, SIGAFIN                                  
ͼ


*/
Function FORMATCLAS(aClassif,lQuery)

Local aArea 	:= GetArea()
Local nReg	    := 0
Local cClassif  := ""


Default lQuery := .F.

For nReg := 1 To Len(aClassif)
	cClassif += aClassif[nReg] + IIf(nReg < Len(aClassif),  "/" ,"")
Next


If lQuery
	cClassif := FormatIn(cClassif,"/")
EndIf

RestArea(aArea)

Return(cClassif)



/*


ͻ
Programa  CLASSN1FNBAutor  Rodrigo Gimenes      Data   18/07/12   
͹
Desc.      Formata a classificao patrimonial de acordo com a tabela 
           FNB.                                                       
͹
Retorno    aRet : Varivel contedo o valor correspondente na tabela FNB
Ĵ
Uso        SIGACTB, SIGAATF, SIGAFIN                                  
ͼ


*/
Function CLASSN1FNB(aClassif)


Local nReg := 0
Local aSubTipo := {}
Local cSubTipo := ""
Local cClassif := ""

For nReg := 1 To Len(aClassif)
	//As correspndncias dessa funo so baseadas nas i8nformaes da funo AF430GerAT() do fonte ATFA430.
	cClassif := AllTrim(aClassif[nReg])
	Do Case
		Case cClassif == "N" // Ativo Fixo
			cSubTipo := "1"
		Case cClassif == "I" // Intangvel
			cSubTipo := "2"
		Case cClassif == "D" //Diferido
			cSubTipo := "3"
	EndCase
	AADD(aSubTipo,cSubTipo)
Next

Return aSubTipo


/*


ͻ
Programa  ATFEXSTPTRAutor  Rodrigo Gimenes      Data   20/07/12   
͹
Desc.      Verifica se existe a tabela adicional de classif.          
           patrimonial                                                
͹
Retorno    lRet: Se a tebal existe ou no                             
Ĵ
Uso        SIGACTB, SIGAATF, SIGAFIN                                  
ͼ


*/
Function ATFEXSTPTR()

Local aAreaSN0 	:= {}
Local lRet		:= .F.

DbSelectArea("SN0")
aAreaSN0 := SN0->(GetArea())
lRet := SN0->(DbSeek(xFilial("SN0") + "07"))
RestArea(aAreaSN0)

Return lRet











/*/

Ŀ
Funo     FaVRelPrv  Autor  Mauricio Pequim Jr      Data  04/10/12 
Ĵ
Descrio  Verifica o relacionamento do imobilizado a um controle de    
           execucao de provisao                                         
Ĵ
 Uso       Generico                                                     
ٱ

*/
//PRV
Function FaVRelPrv(nIndice,cChave)

Local lRet := .F.
Local aAreaFNX := FNX->(GetArea())

DEFAULT nIndice := 1
DEFAULT cChave := ""

FNX->(dbSetOrder(nIndice))
If FNX->(MsSeek(cChave))
	lRet := .T.
Endif

RestArea(aAreaFNX)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} ATFGeTpDp
Funo que monta a tela de seleo de mtodos de depreciao para filtro genricos nas rotinas do ambiente Protheus
Utilizando no relatrio ATFR350 -> Relatrio de Simulao de Depreciao

@param		lTodas			Sinaliza se todos os mtodos de depreciao esto selecionados na tela
@return	aSelTpDep		Objeto criado com o formato do relatrio
@author	marylly.araujo
@since		18/09/2012
@version	MP11
/*/
//-------------------------------------------------------------------
Function ATFGeTpDp(lTodas)

Local cTitulo		:= ""
Local MvPar		:= ""
Local MvParDef	:= ""
Local nI			:= 1
Local aArea		:= GetArea()
Local aAreaSN0	:= {}
Local nReg			:= 0
Local nSit			:= 1
Local aSit			:= {}
Local aSelTpDep	:= {}
Local nTamTpDep	:= 0
Local cFilSN0		:= xFilial("SN0")

Default lTodas := .F. // Sinaliza se todos os mtodos de depreciao esto selecionados na tela

DbSelectArea("SN0") // Tabela Genricas do Mdulo Ativo Fixo
aAreaSN0 := SN0->(GetArea())

	If !IsBlind()
		aSit		:= {}
		MvParDef	:= ""
		cTitulo	:= STR0038 // "Selecione os mtodos de depreciao"
		nTamTpDep	:= TAMSX3("N0_CHAVE")[1]
		SN0->(dbSetOrder(1)) // Filial + Chave Tabela
		If SN0->( dbSeek( cFilSN0 + "04" ) )
			While !SN0->(Eof()) .And. AllTrim(SN0->N0_TABELA) == "04"
				cDesc := ""
				cDesc := AllTrim(SN0->N0_DESC01)
				Aadd(aSit, cDesc )
			 	MvParDef += SN0->N0_CHAVE
				nI++
				SN0->(dbSkip())
			EndDo
		EndIf

		IF AdmOpcoes(@MvPar,cTitulo,aSit,MvParDef,,,.F.,nTamTpDep,nI,.T.) // Funo que abre a tela com os checkbox para seleo das opes
			For nReg := 1 To len(mvpar) Step nTamTpDep  // Acumula as opes dos mtodos de depreciao
				If SubSTR(mvpar, nReg, nTamTpDep) <> Replicate("*",nTamTpDep)
			 		AADD(aSelTpDep, SubSTR(mvpar, nReg, nTamTpDep) )
				Endif
				nSit++
			Next nReg

			If Empty(aSelTpDep)
	 	  		Help(" ",1,"ATFGETTPDP",,STR0039,1,0) //"Por favor, selecionar pelo menos um mtodo de depreciao."
			EndIf
			lTodas := Len(aSelTpDep) == Len(aSit)
		EndIf
	Else
		aSelTpDep := {"1"}
	EndIf

RestArea(aAreaSN0)
RestArea(aArea)

Return(aSelTpDep)

//-------------------------------------------------------------------
/*/{Protheus.doc} AFULTSEQ
Funo que retornar a sequncia de saldos de bens de uma ficha de ativo.
Esta funo pode funcionar por:
- Filial/Cdigo Base/Item;
- Filial/Cdigo Base/Item/Tipo do Bem;
- Filial/Cdigo Base/Item/Tipo do Bem/Tipo de Saldo;
- Filial/Cdigo Base/Item/Tipo de Saldo;

@param cSN3Fil	Filial do Bem
@param cSN3BASE	Cdigo Base do Bem
@param cSN3ITEM	Cdigo do Item do Bem
@param cSN3TIPO	Tipo do Bem
@param cSN3TPSLD	Tipo de Saldo do Bem
@param lIncrem	Se a sequencia encontrada do Bem deve ser incrementada
@param nBaixa		0=Considera os registros no baixados, 1=Considera os registros baixados, 2 = Olha todos os registros (Baixados e No Baixados)

@return cSequencia Cdigo da sequencia de saldo de bens da ficha do ativo
@author marylly.araujo
@since 04/03/2013
@version MP11.8
/*/
//-------------------------------------------------------------------
Function AFULTSEQ(cSN3Fil,cSN3BASE,cSN3ITEM,cSN3TIPO,cSN3TPSLD,lIncrem,nBaixa)
Local aArea		:= GetArea()
Local aSN3Area	:= {}
Local cSN3Qry		:= ""
Local cSN3Als		:= ""
Local cSequencia	:= REPLICATE("0",TamSX3("N3_SEQ")[1])

DEFAULT cSN3TIPO	:= ''
DEFAULT cSN3TPSLD	:= ''
DEFAULT lIncrem	:= .F.
DEFAULT nBaixa	:= 0

DbSelectArea("SN3")
aSN3Area := SN3->(GetArea())

cSN3Qry := " SELECT "
cSN3Qry += " MAX(SN3.N3_SEQ) SEQUENCIA "
cSN3Qry += " FROM " + RetSqlName("SN3") + " SN3 "
cSN3Qry += " WHERE SN3.N3_FILIAL = '" + cSN3Fil + "' "
cSN3Qry += " AND SN3.N3_CBASE = '" + cSN3BASE + "' "
cSN3Qry += " AND SN3.N3_ITEM = '" + cSN3ITEM + "' "
If AllTrim(cSN3TIPO) <> ''
	cSN3Qry += " AND SN3.N3_TIPO = '" + cSN3TIPO + "' "
EndIf
If AllTrim(cSN3TPSLD) <> ''
	cSN3Qry += " AND SN3.N3_TPSALDO = '" + cSN3TPSLD + "' "
EndIf

If nBaixa == 1
	cSN3Qry += " AND SN3.N3_BAIXA > '0' " // Bens com baixa
ElseIf nBaixa == 0
	cSN3Qry += " AND SN3.N3_BAIXA = '0' " // Bens sem baixa
EndIf

cSN3Qry += " AND SN3.D_E_L_E_T_ = '' "

cSN3Qry := ChangeQuery(cSN3Qry)

cSN3Als := GetNextAlias()

dbUseArea(.T., "TOPCONN", TcGenQry(,, cSN3Qry ), cSN3Als, .T.,.F. )

While (cSN3Als)->(!Eof())
    cSequencia := (cSN3Als)->SEQUENCIA
    Exit
	(cSN3Als)->(DbSkip())
EndDo     
(cSN3Als)->(dbCloseArea())


/*
 * Se o parmetro para incrementar estiver habilitado, soma um para a sequncia encontrada.
 */
If lIncrem .OR. Val(cSequencia) == 0
	/*
	 * Incrementa a seqncia para incluso de novo item na tabela SN3.
	 */
	cSequencia := Soma1(cSequencia)
EndIf

RestArea(aArea)
RestArea(aSN3Area)
Return(cSequencia)

/*/

Ŀ
Funo     AFSelTpPrv  Autor Mauricio Pequim Jr.   Data  09/11/12 
Ĵ
Descricao  tela de selecao de ocorrencias dos movimentos da proviso  
Ĵ
 Uso       ATFR490                                                    
ٱ


/*/
Function AFSelTpPrv(lSelecao)

Local cTitulo	:= ""
Local cMvPar	:= ""
Local cMvParDef	:= ""
Local nI 		:= 0
Local aArea 	:= GetArea()
Local nReg	    := 0
Local nSit		:= 0
Local aSit		:= {}
Local cOcorSel	:= ""
Local cCodOcor	:= ""
Local nTamOcor	:= TAMSX3("N0_CHAVE")[1]
Local nTamOco2	:= TAMSX3("FNW_OCOR")[1]

Default lSelecao	:= .F.

nI := 1
aSit	:= {}
MvParDef := ""
cTitulo :=  STR0041  //"Selecione as Ocorrncias de Movimentos de Proviso"

DbSelectArea("SN0")
SN0->(dbSetOrder(1))
If SN0->(dbSeek( xFilial("SN0")+ "15" ))
	While !SN0->(Eof()) .And. AllTrim(SN0->N0_TABELA) == "15"
		Aadd(aSit, SN0->N0_DESC01 )
	 	cMvParDef += SN0->N0_CHAVE
		cCodOcor += SN0->N0_CHAVE +"/"
		nI++
		SN0->(dbSkip())
	EndDo
EndIf

lSelecao := AdmOpcoes(@cMvPar,cTitulo,aSit,cMvParDef,,,.F.,nTamOcor,nI,.T.)  // Chama funcao Adm_Opcoes

If lSelecao
	nSit := 1
	For nReg := 1 To len(cMvpar) Step nTamOcor  // Acumula as Ocorificaes
		If SubSTR(cMvpar, nReg, nTamOcor) <> Replicate("*",nTamOcor)
	 		cOcorSel += SubSTR(cMvpar, nReg, nTamOco2) + "/"
		Endif
		nSit++
	next
Endif

If !Empty(cOcorSel)
	cOcorSel := Left(cOcorSel,Len(cOcorSel)-1)
EndIf

RestArea(aArea)

Return(cOcorSel)

/*
	{Protheus.doc}AtfSaveMvVar
	Guarda os parmetros (mv_parXX)
	@author Fernando Radu Muscalu
	@since  19/07/2018
	@version 12
*/
Function AtfSaveMvVar()

aATFMvPar := RetMvPar()

Return()

/*
	{Protheus.doc}AtfRestMvPar
	Restaura os parmetros que foram guradados pela funo AtfSaveMvVar
	@author Fernando Radu Muscalu
	@since  19/07/2018
	@version 12
*/

Function AtfRestMvPar()

Local nI	:= 0

If ( Len(aATFMvPar) > 0 )
	
	For nI := 1 to Len(aATFMvPar)

		&("mv_par"+cValToChar(nI)) := aATFMvPar[nI]

	Next nI

EndIf

Return()

/*



???Programa  ?AF010CvCol?Autor  ?Alvaro Camillo Neto ? Data ?  05/12/09   ???

???Desc.     ? Realiza as operacoes de conversao de tipos para localiza  ???
???          ? cao da colombia                                            ???

???Uso       ? ATFA010                                                 ???

????????????????????????????????????????????????????????????????????????
?????????????????????????????????????????s?????????????????????????????????????????
*/
Function AF010CvCol(cAlias,nReg,nOpc)


If !__lVerKernel
	__lVerKernel := VerKernel()
EndIf

Return AF010ACVCL(cAlias,nReg,nOpc)
