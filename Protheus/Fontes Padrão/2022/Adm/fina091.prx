#INCLUDE "PROTHEUS.CH"
#INCLUDE "FILEIO.CH"
#INCLUDE "FINA090.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "SIGAWIN.CH"

STATIC dLastPcc		:= CTOD("22/06/2015")
STATIC _oFINA0901	:= NIL
STATIC _oFINA0902	:= NIL
Static lPodeTVA		:= ExistFunc("FAPodeTVA")
Static lExistVA		:= TableInDic("FKD") .and. TableInDic("FKC")
Static __lEAIF080	:= FWHasEAI("FINA080",.T.,,.T.)
STATIC lCtLIPag 	:= GetMv("MV_CTLIPAG")
STATIC __LstImp		:= ""
STATIC lExistLGA 	:= ColumnPos('E2_USERLGA') > 0
STATIC __lF090TIT	:= ExistBlock("F090TIT")
STATIC __nIdxE2OK	:= 2
STATIC __F090VLEX   := ExistBlock("F090VLEX")
Static __lFKD		:= TableInDic('FKD')

//--- Tratamento Gestao Corporativa
STATIC _lGestao   := (FWSizeFilial() > 2)	// Indica se usa Gestao Corporativa
STATIC _cFilFwSE2 := IIF( _lGestao , FwFilial("SE2") , xFilial("SE2") )
STATIC _cFilFwSEF := IIF( _lGestao , FwFilial("SEF") , xFilial("SEF") )
STATIC _cFilFwSA6 := IIF( _lGestao , FwFilial("SA6") , xFilial("SA6") )
STATIC _cFilFwSEK := IIF( _lGestao , FwFilial("SEK") , xFilial("SEK") )
STATIC _cFilFwSED := IIF( _lGestao , FwFilial("SED") , xFilial("SED") )
STATIC _cFilFwSFQ := IIF( _lGestao , FwFilial("SFQ") , xFilial("SFQ") )
STATIC _cFilFwSA2 := IIF( _lGestao , FwFilial("SA2") , xFilial("SA2") )

//Motor de Retenções
Static _aImpMR := {}
Static _lPccMR := .F.
Static _lIrfMR := .F.
Static _lInsMR := .F.
Static _lIssMR := .F.
Static _lCidMR := .F.
Static _lSesMR := .F.
Static _lImpMR := .F.
Static _lTemMR := .F.
Static _nImpMR := 0
Static _nTotImp := 0
Static _nPisMR := 0
Static _nCofMR := 0
Static _nCslMR := 0
Static _nIrfMR := 0
Static _nInsMR := 0
Static _nIssMR := 0
Static _nCidMR := 0
Static _nSesMR := 0
Static _lPccBxMR := .F.
Static _nBasLeg := 0

//Moeda 2 xMoeda
Static _nTamMD2 := TamSx3("E2_TXMOEDA")[2]
Static __oRatIRF := Nil		// Rateio IR Progressivo

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função    ³ FinA091  ³ Autor ³ Adilson H. Yamaguchi  ³ Data ³ 04/05/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Copiado da rotina de Baixa Automatica de Titulos a Pagar   ³±±
±±³          ³ Com a implemetacao de Multi-Filiais (em modo exclusivo)    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ FinA091()                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Gen‚rico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FinA091(nPosArotina, lAutomato)
	Local bBlock		:= NIL
	Local lBlind        := IsBlind()

	Private aIndices	:=	{} //Array necessario para a funcao FilBrowse
	Private bFilBrw		:= {|| }
	Private cFilter		:= NIL
	Private aRotina		:= MenuDef()
	Private nIndTemp	:= 1
	Private dDataLanc	:= dDataBase
	Private cBordero	:= CriaVar("E2_NUMBOR")
	Private cBcoDe		:= CriaVar("E2_PORTADO")
	Private cBcoAte		:= CriaVar("E2_PORTADO")
	Private cPortado	:= CriaVar("E2_PORTADO")
	Private dVencIni	:= dDataBase
	Private dVencFim	:= dDataBase
	Private dBaixa		:= dDataBase
	Private dDebito		:= dDataBase
	Private nJuros		:= 0
	Private cCtBaixa	:= GetMv("MV_CTBAIXA")
	Private cMarca		:= GetMark()
	Private cKey1		:= ""
	Private cIndexNew	:= ""
	Private nAcresc		:= 0
	Private nDecresc	:= 0
	Private nVA			:= 0
	Private cFilLogada	:= cFilAnt  // Salva a Filial corrente, porque na chamada da função "fA091Aut" o sistema perde a filial.
	Private lIRProg		:= "2"

	PRIVATE nIrrf		:= 0
	PRIVATE nIss		:= 0
	PRIVATE nPis		:= 0
	PRIVATE nCofins		:= 0
	PRIVATE nCsll		:= 0

	// Define o cabe‡alho da tela de baixas
	Private cCadastro	:=  STR0133	//"Baixa de Titulos a Pagar - Multi-Filiais"
	Private cLote		:= ""
	Private cPadrao		:= "530"
	Private aFlagCTB	:= {}
	Private lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
	Private lPadrao		:= .F.
	LoteCont( "FIN" )

	DEFAULT nPosArotina := 0
	DEFAULT lAutomato	:= .F.

	NUMCHEQUE 	:= ""

	_lTemMR := If(FindFunction("FTemMotor"), FTemMotor(), .F.)

	If _lTemMR
		__LstImp := FSE2ColImp()
	EndIf

	//Aviso da unificação da rotina - Atualizada
	If !lBlind
		If FindFunction("FinExp090")
			FinExp090("FINA091") 
		EndIf
	EndIf

	//Data limite de disponibilidade da rotina atingido.
	If Date() >= CTOD('01/08/2022') .AND. GetRPORelease() >= '12.1.033'
		RETURN
	Endif

	// Habilita acesso à função Pergunte
	SetKey (VK_F12,{|a,b| AcessaPerg("FIN091",.T.)})
	Pergunte("FIN091",.F.)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ POR MAIS ESTRANHO QUE PARE€A, ESTA FUNCAO DEVE SER CHAMADA AQUI! ³
	//³                                                                  ³
	//³ A função SomaAbat reabre o SE2 com outro nome pela ChkFile para  ³
	//³ efeito de performance. Se o alias auxiliar para a SumAbat() n„o  ³
	//³ estiver aberto antes da IndRegua, ocorre Erro de & na ChkFile,   ³
	//³ pois o Filtro do SE2 uptrapassa 255 Caracteres.                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SomaAbat("","","","P")

	dbSelectArea("SE2")
	If nPosArotina > 0 // Sera executada uma opcao diretamento de aRotina, sem passar pela mBrowse
		bBlock := &( "{ |a,b,c,d,e| " + aRotina[ nPosArotina,2 ] + "(a,b,c,d,e) }" )
		Eval( bBlock, Alias(), (Alias())->(Recno()),nPosArotina,lAutomato,0)
	Else
		If cPaisLoc <> "BRA"
			// Cria indice condicional para a Localizacoes
			cFiltro:="E2_TIPO$'"+IIF(Type('MVCHEQUES')=='C',MVCHEQUES,MVCHEQUE)+"' .AND. !(E2_TIPO$'"+MVPROVIS+"/"+MVRECANT+"/"+MV_CRNEG+"/"+MVENVBCOR+"')"
			If ExistBlock("F090FLBR")
				cFiltro := ExecBlock( "F090FLBR",.F.,.F.,{cFiltro})
			EndIf
			bFilBrw	:=	{|| FilBrowse("SE2",@aIndices,cFiltro )}
			Eval( bFilBrw )
		Else
			If !GetMv("MV_CTLIPAG")
				SE2->(dbSetOrder(3))	//"E2_FILIAL+DTOS(E2_VENCREA)+E2_NOMFOR+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO"
				SE2->(DBGoTop())
				cKey1 := SE2->(INDEXKEY())
			Else
				SE2->(dbSetOrder(3))	//"E2_FILIAL+DTOS(E2_VENCREA)+E2_NOMFOR+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO"
				cFilter := "(E2_FILIAL >= '  ' AND E2_FILIAL <= 'ZZ') AND (E2_DATALIB <> '        ' OR E2_SALDO+E2_SDACRES-E2_SDDECRE <= "+Alltrim(Str(GetMv('MV_VLMINPG'),15,7))+")"
				If ExistBlock("F090FILB")
					cFilter := ExecBlock( "F090FILB",.F.,.F.,{cFilter})
				EndIf
			Endif
		Endif

		// Ponto de entrada para ser utilizado antes do Browse
		If ExistBlock("F090BROW")
			ExecBlock( "F090BROW",.F.,.F.)
		EndIf

		// Endereca a função de BROWSE
		mBrowse( 6, 1,22,75,"SE2",,,,,, Fa040Legenda("SE2"),,,,,,,,cFilter)
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Recupera a Integridade dos dados                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RetIndex("SE2")
	dbSetOrder(1)
	Set Filter to

	If nPosArotina = 0
		dbSeek(xFilial())
	EndFilBrw("SE2",@aIndices)
Endif

cFilAnt := cFilLogada

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função    ³ fA091Aut ³ Autor ³ Adilson H. Yamaguchi  ³ Data ³ 04/05/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Baixa Automática                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Fa091Aut()                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Gen‚rico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fA091Aut(cAlias,cCampo,nOpcE, lAutomato)
	Local aButtons      := {}
	Local aCampos       := {}
	Local aEstruct		:= {}
	Local aDescMotBx    := {}
	Local aDiario		:= {}
	Local aFilial       := {}
	Local aMotBx        := ReadMotBx()
	Local aRecnos       := {}
	Local aRegCtBor		:= {}	// Array com os recnos de Fornecedor e Banco para contabilizacao Bordero/Bordero
	Local aSE5Baixado	:= {}
	Local aSM0          := AdmAbreSM0()
	Local aTitBaixado   := {}
	Local aVendor       := {}
	Local aDados		:= {}

	Local bActWhen		:= NIL
	Local bMovBanco		:= NIL
	Local bOk1			:= NIL
	Local bOk2			:= NIL
	Local bOk3			:= NIL
	Local bValNumChq	:= NIL

	Local cBco090		:= CRIAVAR("A6_COD")
	Local cAge090       := CRIAVAR("A6_AGENCIA")
	Local cCta090       := CRIAVAR("A6_NUMCON")
	Local cChaveBco		:= ""
	Local cAgeTit       := CRIAVAR("E5_AGENCIA")
	Local cArquivo      := NIL
	Local cBcoTit       := CRIAVAR("E5_BANCO")
	Local cBenef090     := CRIAVAR("EF_BENEF")
	Local cBord090F     := CRIAVAR("EA_NUMBOR")
	Local cBord090I     := CRIAVAR("EA_NUMBOR")
	Local cBordAnt      := Space(6)
	Local cCheq090      := CRIAVAR("E5_NUMCHEQ")
	Local cChqTit       := CRIAVAR("E5_NUMCHEQ")
	Local cCtaTit       := CRIAVAR("E5_CONTA")
	Local cDescrMo      := " "
	Local cE5_Histor    := CriaVar("E5_HISTOR") // Historico retornado pelo PE FA090SE5
	Local cFilBaixa     := cFilAnt
	Local cFilFin       := ""
	Local cFilIni       := ""
	Local cFils			:= ""
	Local cFilCorr      := cFilAnt
	Local nTamFil  		:= len(xFilial("SE2"))
	Local cFilSeq       := cFilAnt
	Local cFornece      := NIL
	Local cHistor090    := CRIAVAR("E5_HISTOR")
	Local cModRetPIS    := GetNewPar( "MV_RT10925", "1" )
	Local cNatur090     := CRIAVAR("E2_NATUREZ")
	//1-Cria NCC/NDF referente a diferenca de impostos entre emitidos (SE2) e retidos (SE5)
	//2-Nao Cria NCC/NDF, ou seja, controla a diferenca num proximo titulo
	//3-Nao Controla
	Local cNccRet       := SuperGetMv("MV_NCCRET",.F.,"1")
	Local cNumero       := NIL
	Local cParcela      := NIL
	Local cPrefixo      := NIL
	Local cSequencia    := NIL
	Local cTitOrig		:= NIL

	Local lAcreDecre    := .F.
	Local lAplVlMin     := .T.
	Local lAtuSldNat    := .T.
	Local lBaixa        := .T.
	Local lBordero      := .F.
	Local lBxCnab       := IIf(GETMV("MV_BXCNAB")== "S",.T.,.F.)
	Local lBxTxa        := SuperGetMv("MV_BXTXA",.F.,"1") == "1"
	Local lCalcIssBx    := .F.
	Local lCheque       := .F.
	Local lChqMotBx     := .F.
	Local lContrRet     :=  .T.
	Local lF90Se5Grv    := (ExistBlock("F90SE5GRV")) // PE para gravacoes complementares da baixa
	Local lF90TotGrv    := (ExistBlock("F90TOTGRV")) // PE para gravacoes complementares no registro totalizador da baixa
	Local lFa080Sef     := (ExistBlock("FA080SEF" ))
	Local lFa090Corr    := (ExistBlock("FA090COR" ))
	Local lFa090Desc    := (ExistBlock("FA090DES" ))
	Local lFa090Juros   := (ExistBlock("FA090JUR" ))
	Local lFa090Mult    := (ExistBlock("FA090MUL" ))
	Local lFa090Se5     := (ExistBlock("FA090SE5" ))
	Local lFa090Tit     := (ExistBlock("FA090TIT" ))
	Local lFa090Tx      := (ExistBlock("FA090TX"  ))
	Local lF090CPOS		:= (ExistBlock("F090CPOS" ))
	Local lF091FBX		:= (ExistBlock("F091FBX"  ))
	Local lF091Fil      := .F.
	Local lFinVDoc      := IIF(GetNewPar("MV_FINVDOC","2")=="1",.T.,.F.)        //Controle de validacao de documentos obrigatorios
	Local lFina090      := (ExistBlock("FINA090" ))
	Local lGerTotal     := .F.  // Gera mov.bancário totalizador nas baixas de borderos
	Local lIRPFBaixa    := .F.
	Local lInverte      := .f.
	Local lIsCaixa      := .F.
	Local lMovBcoBx     := .F.
	Local lAtuForn      := SuperGetMv("MV_ATUFORN",.F.,.T.)
	Local lAtuSldBco    := SuperGetMv("MV_ATUSLBC",.F.,.T.)
	Local lCtMovPa		:= SuperGetMv("MV_CTMOVPA",.T.,"1") == "2" // Indica se a Contabilizacao do LP513 ocorrer  pelo Titulo(SE2) ou Mov.Bancario(SE5) do Pagamento Antecipado. 1="SE2" / 2="SE5"

	//Controla o Pis Cofins e Csll na baixa
	Local lPCCBaixa     := SuperGetMv("MV_BX10925",.T.,"2") == "1"
	Local lCalcPccBx	:= .F.
	Local lRet          := .T.
	Local lRetParc      := .T.
	Local lTotPorBord   := (MV_PAR05 <> 1)
	Local lSpbInUse     := SpbInUse()
	Local lVendor       := .F.
	Local lContinua     := .T.

	LOCAL nCorrec       := 0
	Local nFil          := 0
	Local nHdlPrv       := 0
	Local nI            := NIL
	Local nLen          := NIL
	Local nLoop         := 0
	Local nOldRetCof    := 0
	Local nOldRetCsl    := 0
	Local nOldRetIrf    := 0
	Local nOldRetPis    := 0
	Local nOpca         := 0
	Local nProxReg      := NIL
	Local nRec          := NIL
	Local nRegAtu       := 0
	Local nRegSE2       := 0
	Local nRegPrinc     := 0
	Local nSalDup       := NIL
	Local nSaldo        := NIL
	Local nSaldoCru     := 0
	Local nSalvRec      := SE2->(Recno())
	Local nSavRec       := 0
	Local nTamSeq       := TamSX3("E5_SEQ")[1]
	// Estabelece 02 minutos para exibir a mensagem para o usuário informando que a tela fechará automaticamente em XX minutos
	Local nTimeMsg      := SuperGetMv("MV_MSGTIME",,120)*1000
	// Estabelece 15 minutos para que o usuarios selecione
	Local nTimeOut      := SuperGetMv("MV_FATOUT",,900)*1000
	Local nTipoBx       := 1
	Local nTotAbtF      := 0
	Local nTotAger      := 0
	Local nTotal        := 0
	Local nValorCheq    := 0
	Local nValorTotal   := 0
	Local nVlMinImp     := GetNewPar("MV_VL10925",5000)
	Local nX            := 0
	Local nY			:= 0
	Local oBco090       := NIL
	Local oBcoDe        := NIL
	Local oCbx          := NIL
	Local oCheq090		:= NIL
	Local oBenef		:= NIL
	Local oDlg          := NIL
	Local oDlg1         := NIL
	Local oQtda         := NIL
	Local oRadio        := NIL
	Local oTimer        := NIL
	Local oValor        := 0
	Local lF091Natur    := (Existblock("F091NATUR") )
	Local dBkdatabase	:= ddatabase // Backup para database
	Local aSE2Pagant 	:= {}
	Local cPadAux		:= ""
	Local lPadAux		:= .F.
	Local lBcoExcl		:=  Alltrim(FWModeAccess("SA6",1)) == "E" .Or. Alltrim(FWModeAccess("SA6",2)) == "E" .Or. Alltrim(FWModeAccess("SA6",3)) == "E"
	Local lConfirma		:= .F.

	//REESTRUTURACAO SE5
	Local oModelBxP	 := Nil						//Model de baixas a pagar
	Local oModelBxPA := Nil						//Model de baixas a pagar auxiliar
	Local oModelMov  := Nil						//Model de Movimento bancario
	Local oSubFK2  								//BAIXAS A PAGAR - Model Baixa
	Local oSubFK3								//IMPOSTOS CALCULADOS - Model Baixa
	Local oSubFK4								//IMPOSTOS RETIDOS - Model Baixa
	Local oSubFK5								//MOVTO BANCARIO - Model Baixa
	Local oSubFK6								//VALORES COMPLEMENTARES - Model Baixa
	Local oSubFKA								//TABELA DE RASTREIO - Model Baixa
	Local oSubFK3A								//IMPOSTOS CALCULADOS - Model Baixa Auxiliar (retencao impostos)
	Local oSubFKAM								//TABELA DE RASTREIO - Model de Movimento bancario
	Local oSubFK5M 								//MOVTO BANCARIO - Model Movimento Bancario
	Local cLog		:= ""
	Local cChaveFK7 := ""
	Local cCamposE5 := ""
	Local cCamposE5A:= ""
	Local cCamposIR	:= ""
	Local cChaveCH	:= ""
	Local nZ		:= 0
	Local aImpostos	:= {}
	Local cIdFK4	:= ""
	Local cIdFk4IR	:= ""
	Local nValorSE5	:= 0
	Local cBanco 	:= ""
	Local cAgencia	:= ""
	Local cConta	:= ""
	Local cPRet		:= ""
	Local cTpDesc	:= "2"
	Local cTpDescSE5 := "I"
	Local cCheque	:= CRIAVAR("E5_NUMCHEQ")
	Local aPCC  	:= {}
	Local aAreaSE52 := {}
	Local lEmpPub  	:= IsEmpPub()
	Local nLstRecSE5 := 0
	Local lBaixaPA 	:= .F.
	Local lIsTitPA	:= .F.
	Local lGerPAMov	:= .F.
	Local nGerPAMov := 0
	Local cRecPag	:= "P"
	Local lCtbIncPA := .F.
	Local cChaveTit := ""
	Local nRecNoSE2 := 0
	Local nRecNoSE5 := 0
	Local nRecNoFK2 := 0
	Local lAchou    := .T.
	Local lStartCTB := .T.
	Local nTxMoedBx	:= 0 
	Local aTitCalc	:= {}

	//Variaveis de uso Automação
	Local nRegAuto	:= 0
	Local lFA090POS	:= ExistBlock("FA090POS")
	Local aSelFil	:= {}
	Local aTMPFil	:= {}
	Local aFilAux	:= {}
	Local nImpos 	:= 0
	Local cE5TABORI	:= ''
	Local cE5IDORIG	:= ''
	Local lExistFJU	:= FJU->(ColumnPos("FJU_RECPAI")) >0 .and. FindFunction("FinGrvEx")
	Local nCentMd1 	:= (MsDecimais(1) + 1)
	Local cLiberado	:= IIf(SuperGetMv("MV_LIBCHEQ")=="S","S"," ")

	// Integração SIGAPFS x SIGAFIN
	Local lJGrvBxPag 	:= FindFunction("JGrvBxPag")
	Local lJFilBco      := SuperGetMv( "MV_JFILBCO", .F., .F. ) .And. FindFunction("JURF3SA6") .And. FindFunction("JurVldSA6") //Indica se filtra as contas correntes vinculadas ao escritório logado - SIGAPFS.
	Local cEscrit       := Iif(lJFilBco, JurGetDados("NS7", 4, xFilial("NS7") + cFilant + cEmpAnt, "NS7_COD"), "") // Código do escritório relacionado a filial logada - SIGAPFS.
	Local cF3Bco        := Iif(lJFilBco, "SA6JUR", "SA6")

	// Variáveis de integração EAI.
	Local llOpc := .F.
	Local aEaiRet := {}

	//Sonarqube
	Local lBxDtFin		:= SuperGetMv("MV_BXDTFIN",,"1") == "2"
	Local cMV_CARTEIR	:= GetMv("MV_CARTEIR")
	Local cMV_PISNAT 	:= SuperGetMV("MV_PISNAT")
	Local cMV_COFINS	:= SuperGetMV("MV_COFINS")
	Local cMV_CSLL		:= SuperGetMV("MV_CSLL")
	Local nMV_MCUSTO	:= Val(GetMv("MV_MCUSTO"))
	Local lMV_BXAUTVE 	:= SuperGetMv("MV_BXAUTVE",.F.,.F.)	// Se for baixa de titulos e o motivo for VENDOR, nao existir o paramatro MV_BXAUTVE ou existir e retornar retornar .T.
	Local nValorSEF		:= 0
	Local lRetBor		:= .T.
	Local lMvCheques    := Type('MVCHEQUES')=='C'
	Local cMV_IRF		:= &(SuperGetMV("MV_IRF"))
	Local cMV_ISS		:= &(GetMv("MV_ISS"))
	Local oObjSx1 		:= FWSX1Util():New()
	Local aPergSx1		:= {}
	Local aRecSE2		:= {}
	Local cChavePai		:= ""
	Local nTamTitPai	:= TAMSX3("E2_TITPAI")[1]
	Local nRecSE2		:= 0
	Local lFKCodRet		:= (cPaisLoc == "BRA" .and. FK3->(FieldPos("FK3_CODRET")) > 0 .and. FK4->(FieldPos("FK4_CODRET")) > 0)
	Local cCodRet		:= ""
	Local aCodRet		:= {}
	Local nDtContOn		:= SuperGetMv("MV_DTCNBXP",.F.,3) // Data para contabilização Online baixas pagar 1- Data Digitação; 2- Data Disponibilidade; 3- Data Pagamento
	Local dDtLanc		:= dDataBase
	Local lFK4CLIFOR	:= FK4->(FieldPos("FK4_CLIFOR")) > 0

	PRIVATE cAliasSE2 	:= GetNextAlias()
	PRIVATE aDadosIR    := Array(3)
	PRIVATE aDadosRef   := Array(7)
	PRIVATE aDadosRet   := Array(7)
	PRIVATE cLoteFin    := Space(TamSX3("E2_LOTE")[1])
	PRIVATE cMotBx      := CriaVar("E5_MOTBX")
	PRIVATE lVldAD      := .F.
	PRIVATE nBaseIrpf   := 0  //O valor da base do IRPF sera retornado pela funcao F241BsIRPF()

	PRIVATE nDescont    := 0
	PRIVATE nDiferImp   := 0
	PRIVATE nMoedaBco   := 1
	PRIVATE nMulta      := 0
	PRIVATE nOldValPgto := 0
	PRIVATE nTotAbat    := 0
	PRIVATE nValAcres   := 0
	PRIVATE nValPgto    := 0
	PRIVATE nVlRetCof   := 0
	PRIVATE nVlRetCsl   := 0
	PRIVATE nVlRetIrf   := 0
	PRIVATE nVlRetPis   := 0
	PRIVATE nValor      := 0

	//Reestruturacao SE5
	PRIVATE nDescCalc 	:= 0
	PRIVATE nVACalc 	:= 0
	PRIVATE nJurosCalc 	:= 0
	PRIVATE nMultaCalc 	:= 0
	PRIVATE nCorrCalc	:= 0
	PRIVATE nDifCamCalc	:= 0
	PRIVATE nImpSubCalc	:= 0
	PRIVATE nPisCalc	:= 0
	PRIVATE nCofCalc	:= 0
	PRIVATE nCslCalc	:= 0
	PRIVATE nIrfCalc	:= 0
	PRIVATE nIssCalc	:= 0
	PRIVATE nPisBaseR 	:= 0
	PRIVATE nCofBaseR	:= 0
	PRIVATE nCslBaseR 	:= 0
	PRIVATE nIrfBaseR 	:= 0
	PRIVATE nIssBaseR 	:= 0
	PRIVATE nPisBaseC 	:= 0
	PRIVATE nCofBaseC 	:= 0
	PRIVATE nCslBaseC 	:= 0
	PRIVATE nIrfBaseC 	:= 0
	PRIVATE nIssBaseC 	:= 0
	PRIVATE LanceiCTB := .F.
	Private dDtDigit	:= dDatabase
	Default lAutomato := .F.

	cSequencia	:= Replicate( '0', nTamSeq )

	f091LRatIR(.T.) // Limpa objeto __oRatIRF IR Progressivo

	aFill(aDadosRef,0)
	aFill(aDadosRet,0)
	aFill(aDadosIr,0)

	If lPCCBaixa .and. dBaixa >= dLastPcc .And. !lEmpPub
		nVlMinImp	:= 0
	EndIf

	//Busco o range de filiais da empresa
	For nFil := 1 to Len(aSM0)
		If aSM0[nFil][SM0_GRPEMP] != cEmpAnt
			Loop
		EndIf

		If Empty(cFilIni)
			cFilIni := aSM0[nFil][SM0_CODFIL]
		Endif

		AADD(aFilial, aSM0[nFil][SM0_CODFIL])
		cFilFin := aSM0[nFil][SM0_CODFIL]
	Next

	cFils := F240RetFils( cFilIni, cFilFin )

	If !Empty( cFils ) .and. !("@@" $ cFils)
		cFilIni :=  SubStr( cFils, 1, nTamFil)
		cFilFin := 	SubStr( cFils, (nTamFil+1)*((len(cFils)/(nTamFil+1))-1)+1, nTamFil)
	Endif

	//Verifica se data do movimento n„o ‚ menor que data limite de movimentacao no financeiro
	If !DtMovFin(,,"1")
		Return
	Endif

	//verifica se existem os campos de valores de acrescimo e decrescimo no SE5
	lAcreDecre := .T.

	VAR_IXB := .F.
	STRLCTPAD := " "
	cBord090F := IIf(Empty(cBord090F),Replicate("Z",Len(cBord090F)),cBord090F)
	cBcoAte := IIf(Empty(cBcoAte),Replicate("Z",Len(cBcoAte)),cBcoAte)

	//Retorna o Array aDescMotBx contendo apenas a descricao do motivo das Baixas
	For nI := 1 to len( aMotBx )
		If substr(aMotBx[nI],34,01) == "A" .or. substr(aMotBx[nI],34,01) =="P"
			If !(substr(aMotBx[nI],01,03) $ "FAT|LOJ|LIQ|CEC|CMP")
				AADD( aDescMotBx,substr(aMotBx[nI],07,10))
			Endif
		EndIf
	Next

	If GetNewPar("MV_VLTITAD",.F.)
		Aadd( aButtons, { 'PENDENTE', { || F090VlMark(.T.,cAliasSE2,cMarca,oValor,oQtda,oMark,nValor,"FINA091")}, STR0074, STR0075 } ) //"Verifica se ha Titulos com Adiantamento ou Devolucao"###"Validador"
	Endif

	//Inicia processo de integracao com o SIGAPCO
	PCOIniLan("000024")

	While .T.
		nRec   := SE2->(RecNo())
		nOpca  := 0
		cMotBx := "NORMAL"

		//PONTO DE ENTRADA FA090POS Permite tratamento das vari veis (CBCO090, CAGE090, CTA090, CCHEQ090)
		//apos carga de dados do titulo a ser baixado, antes das informacoes serem mostradas na tela
		If lFA090POS
			aDados   := ExecBlock("FA090POS",.F.,.F.,{cBco090, cAge090, cCta090, cCheq090})
			cBco090  := aDados[1]
			cAge090  := aDados[2]
			cCta090  := aDados[3]
			cCheq090 := aDados[4]
			SE2->(dbGoTo(nSalvRec))
		Endif

		UltiLote()

		If !lAutomato
			DEFINE MSDIALOG oDlg FROM 30,16 To 365,450  TITLE  STR0021 PIXEL //"Baixa Automática"
			//nTipoBx -> 1 = Baixa somente titulos que não estao em bordero
			//nTipoBx -> 2 = Baixa somente titulos em bordero
			@ 13,07.0 Radio oRadio VAR nTipoBx ITEMS STR0066,STR0067 3D ON CHANGE oBcoDe:SetFocus() SIZE 50,10 OF oDlg PIXEL	//"Títulos"###"Borderôs"

			@ 01.0,13.0	SAY  STR0160  //"Dt Baixa"
			@ 01.6,13.0	MSGET DBAIXA When .T. SIZE 45,10 HASBUTTON
			@ 01.6,13.0	MSGET dBaixa When .T. SIZE 45,10 HASBUTTON ;
				Valid ( !Empty(DBAIXA) .AND. If(lBxDtFin, DtMovFin(DBAIXA,,"1"), .T.))

			@ 03.9,01.0 MSGET oBcoDe VAR cBcoDe	F3 "BCO" SIZE 37,10 of oDlg  HASBUTTON
			@ 03.9,05.8	SAY	 STR0010 SIZE 10,10 of oDlg   // "at‚ "
			@ 03.9,07.0	MSGET cBcoAte	F3 "BCO" SIZE 37,10 of oDlg  HASBUTTON

			@ 03.9,13.0 MSGET dVencIni When nTipoBx == 1 SIZE 45,10 of oDlg HASBUTTON
			@ 03.9,18.8 SAY	STR0010 SIZE 10,10 of oDlg // "at‚ "
			@ 03.9,20.0 MSGET dVencFim When nTipoBx == 1 Valid dVencFim >= dVencIni SIZE 45,10 of oDlg  HASBUTTON

			@ 06.1,01.0 MSGET cBord090I When nTipoBx == 2 Picture "@S6" SIZE 37,10 of oDlg
			@ 06.1,05.8 SAY	STR0010 SIZE 10,10 of oDlg // "at‚ "
			@ 06.1,07.0 MSGET cBord090F When nTipoBx == 2 Picture "@S6" SIZE 37,10 of oDlg

			@ 06.1,13.0 COMBOBOX oCbx VAR cMotBx ITEMS aDescMotBx SIZE 100, 13 OF oDlg 	Valid (ShowMotBx("P",.T.))

			bActWhen 	:= {|| MovBcoBx(cMotBx,.T.).and.ChqMotBx(cMotBx) .and. mv_par01 == 1 .and. fa091CX(cBco090, nTipoBx==2) }
			bValNumChq 	:= {|| If( Eval(bActWhen), FaPrNumChq(cBco090,cAge090,cCta090,@oCheq090,@cCheq090), .T. ) }
			bMovBanco	:= {|| MovBcoBx(cMotBx,.T.) }

			@ 07.6,00.6	SAY  STR0034 SIZE 10,10 of oDlg	//"Banco"
			@ 08.3,00.6	MSGET oBco090 VAR cBco090 F3 cF3Bco WHEN Eval(bMovBanco) Valid CarregaSa6(@cBco090,,,.T.) .And. Iif(lJFilBco, JurVldSA6("1", {cEscrit, cBco090, cAge090, cCta090}), .T.) .And. Eval(bValNumChq) SIZE 10,10 of oDlg  HASBUTTON
			@ 07.6,06.0	SAY  STR0035 SIZE 10,10 of oDlg	//"Agência"
			@ 08.3,06.0	MSGET cAge090   WHEN Eval(bMovBanco) Valid CarregaSa6(@cBco090,@cAge090,,.T.) .And. Iif(lJFilBco, JurVldSA6("2", {cEscrit, cBco090, cAge090, cCta090}), .T.) .And. Eval(bValNumChq) SIZE 15,10 of oDlg
			@ 07.6,12.0	SAY  STR0036 SIZE 10,10 of oDlg	//"Conta"
			@ 08.3,12.0	MSGET cCta090   WHEN Eval(bMovBanco) Valid If(CarregaSa6(@cBco090,@cAge090,@cCta090,.T.,,.T.) .And. Iif(lJFilBco, JurVldSA6("3", {cEscrit, cBco090, cAge090, cCta090}), .T.),Eval(bValNumChq),oBco090:SetFocus()) SIZE 50,10 of oDlg
			@ 07.6,19.6	SAY  STR0064 SIZE 10,10 of oDlg //"Cheque"
			@ 08.3,19.6	MSGET oCheq090 VAR cCheq090 When !RetGlbLGPD("EF_NUM") .and. Eval(bActWhen) ;
				Valid (FA091Cheq(cBco090,cAge090,cCta090,cCheq090),IIF(AllTrim(cCheq090)<>"" .and. AllTrim(cHistor090)=="",cHistor090 := STR0070,If(AllTrim(cCheq090)=="",cHistor090 := "", ))) SIZE 53,10 of oDlg

			@ 09.3,00.6 SAY STR0068 //"Beneficiario"
			@ 10.0,00.6 MSGET oBenef VAR cBenef090 Picture "@!" When (!RetGlbLGPD("EF_BENEF") .and. !Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*") SIZE 80,10 of oDlg OBFUSCATED RetGlbLGPD("EF_BENEF")
			@ 09.3,12.0 SAY STR0069 //"Natureza do Movto"
			@ 10.0,12.0 MSGET cNatur090 F3 "SED" When (!Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*") .or. (lBxCnab) VALID FinVldNat( .T., cNatur090 ) SIZE 50,10 of oDlg HASBUTTON
			@ 09.3,19.6 SAY STR0063 //"Lote"
			@ 10.0,19.6 MSGET cLoteFin Picture "@!" When lBxCnab .and. ((nTipoBx == 2) .or.	(SubStr(cBco090,1,2) == "CX" .or. cBco090 $ cMV_CARTEIR .and. eval(bMovBanco))) ;
				Valid CheckLote("P", .T., cBco090) SIZE 53,10 of oDlg
			@ 11.0,00.6 SAY STR0088 //"Historico do Cheque"
			@ 11.7,00.6 MSGET cHistor090 Picture "@!" When (!Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*" ) SIZE 205,10 of oDlg//When (!Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*") SIZE 80,10 of oDlg

			@ 00.5,00.5 TO 02.5, 20 LABEL  STR0065		// "Baixar"
			@ 03.2,00.5 TO 04.7, 12 LABEL  STR0009		// "Portador"
			@ 03.2,12.5 TO 04.7, 26 LABEL  STR0011		// "Vencimento"
			@ 05.2,00.5 TO 06.7, 12 LABEL  STR0013		// "Border“"
			@ 05.2,12.5 TO 06.7, 26 LABEL  STR0012		// "Mot.Baixa"

			DEFINE SBUTTON FROM 05.0,180 TYPE 1 ACTION ( lConfirma := .T., nOpca := 1, Iif( F090vLDbX(nTipoBx,lBxCnab,cBco090,cAge090,cCta090,cMotBx,oDlg,cCheq090,cBord090I,cBord090F,,,lBcoExcl), oDlg:End(), nOpca:=0 ) ) ENABLE OF oDlg
			DEFINE SBUTTON FROM 17.9,180 TYPE 2 ACTION ( lConfirma := .F., oDlg:End() ) ENABLE OF oDlg

			ACTIVATE MSDIALOG oDlg CENTERED
		Else
			If FindFunction("GetParAuto")
				aRetAuto 	:= GetParAuto("FINA091TESTCASE")
				nTipoBx 	:= aRetAuto[1]	// 1 = Baixa somente titulos que não estao em bordero ou nTipoBx -> 2 = Baixa somente titulos em bordero
				cBcoDe		:= aRetAuto[2]	// Portador de
				cBcoAte 	:= aRetAuto[3]	// Portador Até
				dVencIni 	:= aRetAuto[4]	// Vencimento Inicial
				dVencFim 	:= aRetAuto[5]	// Vencimento Final
				cBord090I 	:= aRetAuto[6]	// Borderô Inicial
				cBord090F 	:= aRetAuto[7]	// Borderô  Final
				cMotBx 		:= aRetAuto[8]	// Motivo de baixa
				cBco090		:= aRetAuto[9]	// Banco de baixa
				cAge090		:= aRetAuto[10]	// Agencia de baixa
				cCta090		:= aRetAuto[11]	// Conta de baixa
				cCheq090 	:= aRetAuto[12]	// Número do Cheque
				cBenef090	:= aRetAuto[13]	// Beneficiário do Cheque
				cNatur090	:= aRetAuto[14]	// Natureza do Movto
				cLoteFin	:= aRetAuto[15]	// Lote
				cHistor090	:= aRetAuto[16]	// Historico do Cheque
				If Len(aRetAuto) >= 18
					dBaixa := aRetAuto[18]	// Data da baixa
				EndIf

				If F090vLDbX(nTipoBx,lBxCnab,cBco090,cAge090,cCta090,cMotBx,oDlg,cCheq090,cBord090I,cBord090F,lAutomato,oRadio,lBcoExcl)
					nOpca	:= 1
				Endif
			Endif
		Endif

		If nOpca == 0
			Exit
		EndIf

		nRec		:= SE2->( RecNo() )
		lMovBcoBx	:= MovBcoBx(cMotBx, .T.)
		lChqMotBx	:= ChqMotBx(cMotBx)
		nValor		:= 0    // valor total dos titulos,mostrado no rodap‚ do browse
		nQtdTit		:= 0    // quantidade de titulos,mostrado no rodap‚ do browse
		nOpcA		:= 0

		//Altera Database
		dDatabase := dBaixa
		dDebito	  := dBaixa

		//Prepara as estruturas para preencher com os dados do dicionario
		F091GetCampos(aCampos,aEstruct)

		If !lAutomato
			// Seleção de filiais
			aFilAux := AdmGetFil(.F.,.T.,"SE2")
			If Len( aFilAux ) <= 0
				nOpca := 0
				Exit
			EndIf
		Else
			aFilAux := AdmGetFil(.F.,.T.,"SE2",,,.F.)
			For nI := 1 to len( aFilAux )
				AADD(aSelFil, aFilAux[nI][1] )
			Next nI

			aFilAux := aSelFil
		EndIf

		If lF091FBX
			lF091Fil := EXECBLOCK("F091FBX",.F.,.F.,)
			If !Valtype(lF091Fil) == "L" 
				lF091Fil := .F.						
			EndIf
		EndIf	
		//Se o cadastro de bancos for exclusivo e motivo de baixa movimenta banco, filtra as filiais que possuam os mesmos códigos de banco + agência + conta
		cChaveBco := cBco090 + cAge090 + cCta090
		If lBcoExcl .And. lMovBcoBx .And. !lF091Fil
			aSelFil := FiltFilBco(aFilAux, cChaveBco)
			FwFreeArray(aFilAux)
		Else
			aSelFil := aFilAux
		EndIf

		// Monta a query para  seleção de dados
		nMoedaBco	:= Max(MoedaBco(cBco090,cAge090,cCta090),1)
		cArqNew		:= f091QryA(aSelFil,aTMPFil,aCampos,aEstruct,nTipoBx,cBord090I,cBord090F,@cBco090,@cAge090,@cCta090)

		If cArqNew == "NOACESS"  // Caso o usuario não tenha nenhuma permissão aborta o processo do bordero
			Help(" ",1,"RECNO")
			F091Clean()
			Exit
		EndIf

		If !Empty( cArqNew )
			dbselectarea(cAliasSE2)
			(cAliasSE2)->(dbGoTop())
			If (cAliasSE2)->(Bof()) .And. (cAliasSE2)->(Eof())
				Help(" ",1,"RECNO")
				If !Empty( cArqNew )
					dbCloseArea()
				EndIf
				F091Clean()
				Exit
			EndIf
		EndIf

		If lF090CPOS
			aCampos := EXECBLOCK("F090CPOS",.F.,.F.,aCampos)
		Endif

		If !lAutomato
			Processa( {|| Fa091Marca(cAliasSE2,cMarca) }, STR0163, STR0164,.F.) //"Aguarde..."#"Selecionando registros..."
			(cAliasSE2)->(DbGoTop())

			//Faz o calculo automatico de dimensoes de objetos
			oSize := FwDefSize():New(.T.)

			oSize:lLateral := .F.
			oSize:lProp	:= .T. // Proporcional

			oSize:AddObject( "1STROW" ,  100, 12, .T., .T. ) // Totalmente dimensionavel
			oSize:AddObject( "2NDROW" ,  100, 88, .T., .T. ) // Totalmente dimensionavel

			oSize:aMargins := { 2, 2, 1, 2 } // Espaco ao lado dos objetos 0, entre eles 3

			oSize:Process() // Dispara os calculos

			a1stRow := {oSize:GetDimension("1STROW","LININI"),;
				oSize:GetDimension("1STROW","COLINI"),;
				oSize:GetDimension("1STROW","LINEND"),;
				oSize:GetDimension("1STROW","COLEND")}

			a2ndRow := {oSize:GetDimension("2NDROW","LININI"),;
				oSize:GetDimension("2NDROW","COLINI"),;
				oSize:GetDimension("2NDROW","LINEND"),;
				oSize:GetDimension("2NDROW","COLEND")}

			DEFINE MSDIALOG oDlg1 TITLE STR0008 From oSize:aWindSize[1],oSize:aWindSize[2] to oSize:aWindSize[3],oSize:aWindSize[4] OF oMainWnd PIXEL  // "      Baixas Automáticas      "
			oTimer:= TTimer():New((nTimeOut-nTimeMsg),{|| MsgTimer(nTimeMsg,oDlg1) },oDlg1) // Ativa timer
			oTimer:Activate()
			oDlg1:lMaximized := .T.

			@ a1stRow[1] + 001, a1stRow[2] + 001  To a1stRow[3],a1stRow[4] PIXEL OF oDlg1
			@ a1stRow[1] + 003, a1stRow[2] + 005 SAY STR0026 SIZE 50,10 PIXEL Of oDlg1  // "Valor Total:"
			@ a1stRow[1] + 003, a1stRow[2] + 060 SAY oValor VAR nValor PICTURE  PesqPict("SE2","E2_SALDO",TamSx3("E2_SALDO")[1]) SIZE 50,10  PIXEL Of oDlg1
			@ a1stRow[1] + 012, a1stRow[2] + 005 SAY STR0027 SIZE 50,10  PIXEL Of oDlg1 // "Quantidade:"
			@ a1stRow[1] + 012, a1stRow[2] + 083 SAY oQtda VAR nQtdTit PICTURE "@E 99999" 	SIZE 50,10  PIXEL Of oDlg1

			oMark := MsSelect():New(cAliasSE2,"E2_OK","!E2_SALDO",aCampos,@lInverte,@cMarca,{a2ndRow[1],a2ndRow[2],a2ndRow[3],a2ndRow[4]})
			oMark:bMark	:= {||FA091Display(cAliasSE2,cMarca,lInverte,oValor,oQtda,"P",lBaixa)}
			oMark:bAval	:= {||FA091bAval(cAliasSE2,cMarca,oValor,oQtda,oMark)}
			oMark:oBrowse:lhasMark		:= .t.
			oMark:oBrowse:lCanAllmark	:= .t.
			oMark:oBrowse:bAllMark		:= {|| Processa( FA091Inverte(cAliasSE2,cMarca,oValor,oQtda,.T.   ,oMark,lAutomato,nTipoBx) )}

			bOk1 := {|| If( !GetNewPar("MV_VLTITAD",.F.), lVldAD := .T., Nil ) }
			bOk2 := {|| If(FA091PcoLan(cMarca), (nOpca := 1,oDlg1:End()), Nil) }
			bOk3 := {|| MsgInfo(STR0076, STR0072) } //"Antes de confirmar as baixas, execute o botao para validar titulos cujo Fornecedor possua Adiantamento ou Devolucao." / "Atenção"

			ACTIVATE MSDIALOG oDlg1 ON INIT EnchoiceBar( oDlg1,	{|| ( Eval(bOk1), If(lVldAD,Eval(bOk2),Eval(bOk3)) ) }, {|| nOpca := 0,oDlg1:End()},, aButtons ) CENTER
		Else
			If FindFunction("GetParAuto")
				nRegAuto := (cAliasSE2)->(Recno())
				(cAliasSE2)->(dbGoTop())

				While (cAliasSE2)->(!Eof())
					For nI := 1 to Len (aRetAuto[17])
						If 	(cAliasSE2)->(E2_FILIAL) 	== Padr(aRetAuto[17,nI,1],Len(SE2->E2_FILIAL))	.AND. ;//FILIAL
							(cAliasSE2)->(E2_PREFIXO) 	== Padr(aRetAuto[17,nI,2],Len(SE2->E2_PREFIXO)) 	.AND. ;//Prefixo
							(cAliasSE2)->(E2_NUM) 		== Padr(aRetAuto[17,nI,3],Len(SE2->E2_NUM)) 		.AND. ;//Numero
							(cAliasSE2)->(E2_PARCELA) 	== Padr(aRetAuto[17,nI,4],Len(SE2->E2_PARCELA)) 	.AND. ;//Parcela
							(cAliasSE2)->(E2_TIPO) 		== Padr(aRetAuto[17,nI,5],Len(SE2->E2_TIPO)) 		.AND. ;//Tipo
							(cAliasSE2)->(E2_FORNECE) 	== Padr(aRetAuto[17,nI,6],Len(SE2->E2_FORNECE)) 	.AND. ;//fornecedor
							(cAliasSE2)->(E2_LOJA) 		== Padr(aRetAuto[17,nI,7],Len(SE2->E2_LOJA))				//loja]

							//efetua a Marcação dos títulos
							RecLock(cAliasSE2,.F. )
							FA091Inverte(cAliasSE2,cMarca,/*oValor*/,/*oQtda*/,.F.,/*oMark*/,lAutomato)
							(cAliasSE2)->(MsUnlock())
							nOpca := 1
						EndIf
					Next nI

					(cAliasSE2)->(dbSkip())
				EndDo

				(cAliasSE2)->(dbGoto(nRegAuto))

				If nOpca != 1
					Exit
				EndIf
			Endif
		Endif

		If nOpca != 1
			(cAlias)->(DbCloseArea())
			dbSelectArea( cAlias )
			RetIndex("SE2")

			If cPaisLoc=="BRA"
				dbSetOrder(3)
			EndIf

			If __lSX8
				RollBackSX8()
			Endif

			F091Clean()
            aCampos     := {}
            aEstruct    := {}

			Loop
		Endif

		dbSelectArea( "SE2" )

		IF nValor == 0
			Exit
		EndIF

		nI :=  Ascan(aMotBx, {|x| Substr(x,1,3) == TrazCodMot(cMotBx) })
		cDescrMo := if( nI > 0,Substr(aMotBx[nI],07,10),"" )

		If nOpca == 1
			If __lSX8
				ConfirmSX8()
			Endif

			oObjSx1:AddGroup("FIN091")
			oObjSx1:SearchGroup()
			aPergSx1 := oObjSx1:GetGroup("FIN091")

			If Len(aPergSx1[2]) == 6
				cTpDescSE5 := If( mv_par06 == 1 , "C" , "I")
				cTpDesc	   := cValToChar(mv_par06)
			EndIf

			Valor		:= 0		//TOTAL DAS BAIXAS
			Valor2		:= 0		//TOTAL DOS ABATIMENTOS (por titulo)
			ABATIMENTO	:= 0
			nTotAGer	:= 0
			cBordAnt	:= Space(6)
			nValorCheq	:= 0

			BEGIN TRANSACTION
				(cAliasSE2)->(dbSetOrder(__nIdxE2OK))
				(cAliasSE2)->(dbSeek(cMarca))	// Localiza o primeiro registro marcado para baixa
				SE2->(dbGoto((cAliasSE2)->NUM_REG))

				While !(cAliasSE2)->(Eof()) .And. ((cAliasSE2)->E2_OK == cMarca)
					SE2->(dbGoto((cAliasSE2)->NUM_REG))
					cFilant := SE2->E2_FILORIG
					
					cPadrao := If(nTipoBx == 1, "530", "532")

					If SE2->E2_MOEDA > 1
						nTxMoedBx := If(SE2->E2_TXMOEDA > 0, SE2->E2_TXMOEDA,RecMoeda(dBaixa, SE2->E2_MOEDA))
					Else
						nTxMoedBx := 0
					EndIf

					//Restaura o valor padrao
					lIRPFBaixa := .F.

					IF nTipoBx == 2 .and. cBordAnt != SE2->E2_NUMBOR   //Baixas de bordero
						cBordAnt := SE2->E2_NUMBOR
						dbSelectArea( "SEA" )
						SEA->(dbSetOrder(4))

						If dbSeek(SE2->E2_FILORIG + SE2->(E2_NUMBOR+"P"+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA), .F.)
							dbSelectArea("SA6")
							SA6->(dbSetOrder(1))

							If Empty( _cFilFwSA6 )
								cMFilial := xFilial("SA6")
							Else
								If Empty( _cFilFwSE2 )
									cMFilial := xFilial("SA6")
								Else
									cMFilial := SE2->E2_FILIAL
								EndIf
							EndIf

							SA6->(dbSeek(cMFilial+SEA->EA_PORTADO+SEA->EA_AGEDEP+SEA->EA_NUMCON))
						Else
							Alert(STR0119 + cBordAnt + STR0120)
							aAreaBKPSE2 := GETAREA()
							dbSelectArea("SE2")
							SE2->(dbSetOrder(2))
							RESTAREA(aAreaBKPSE2)
							DisarmTransaction()
							lContinua := .F.
							EXIT
						Endif

						dbSelectArea(cAliasSE2)
					EndIf

					If lContinua
						nRegAtu := (cAliasSE2)->(Recno())
						nDescont:= 0
						nJuros  := 0
						nMulta  := 0
						nCorrec := 0
						nVA		:= 0
						(cAliasSE2)->(dbSkip())
						nProxReg := (cAliasSE2)->(RECNO())
						(cAliasSE2)->(dbGoto(nRegAtu))

						If cPaisLoc $ "ANG|ARG|AUS|BOL|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN" .And.;
								!Empty(E2_ORDPAGO) .And. E2_TIPO $ IIF(lMvCheques,MVCHEQUES,MVCHEQUE) .And. !(E2_TIPO $ MVPROVIS+"/"+MVRECANT+"/"+MV_CRNEG+"/"+MVENVBCOR)
							SEK->(DbSetOrder(1))

							If Empty( _c_cFilFwSEK )
								cMFilial := xFilial("SEK")
							Else
								If Empty( _cFilFwSE2 )
									cMFilial := xFilial("SEK")
								Else
									cMFilial := SE2->E2_FILIAL
								EndIf
							EndIf

							If SEK->(DbSeek(cMFilial+SE2->E2_ORDPAGO+"CP"+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO)) .And. Empty(SEK->EK_DOCREC)
								DbSkip()
								Loop
							Endif
						Endif

						If (cAliasSE2)->E2_OK == cMarca	//Registro selecionado para baixar
							//Ponto de Entrada - para confirmacao da baixa
							If lFa090Tit
								lRet	:= ExecBlock("FA090TIT",.F.,.F.,{cBco090,cAge090,cCta090,cCheq090})

								If !lRet
									(cAliasSE2)->(dbSkip())
									Loop
								EndIf
							Endif

							//Posiciona no Cadastro de Naturezas
							dbSelectArea("SED")
							dbSetOrder(1)

							If Empty( _cFilFwSED )
								cMFilial := xFilial("SED")
							Else
								If Empty( _cFilFwSE2 )
									cMFilial := xFilial("SED")
								Else
									cMFilial := SE2->E2_FILIAL
								EndIf
							EndIf

							SED->(dbSeek(xFilial("SED",SE2->E2_FILORIG)+SE2->E2_NATUREZ))
							SA2->(dbSetOrder(1))
							SA2->(MSSeek(xFilial("SA2")+SE2->(E2_FORNECE+E2_LOJA)))

							//Motor de retenções
							_nBasLeg := 0

							If _lTemMR
								F091VldImp(.F.)
							EndIf

							lCalcPccBx := .F.
							lIRPFBaixa := .F.
							lAplMinP := .F.
							lCalcIssBx := .F.
							lIsTitPA := SE2->E2_TIPO $ MVPAGANT

							If !_lPccMR .And. lPccBaixa .And. cPaisLoc == "BRA"	
								//Verifico se a combinacao Cliente x Natureza calcula PCC
								If SA2->A2_TIPO == 'J'.and. ;
									((SED->ED_CALCCSL == "S" .and. SA2->A2_RECCSLL == "2") .or. ;
										(SED->ED_CALCCOF == "S" .and. SA2->A2_RECCOFI == "2") .or. ;
										(SED->ED_CALCPIS == "S" .and. SA2->A2_RECPIS  == "2") )
		
									lCalcPccBx := .T.
								EndIf
							EndIf

							lIRPFBaixa := !_lIrfMR .And. cPaisLoc == "BRA" .And. SA2->A2_CALCIRF == "2" .and. SED->ED_CALCIRF == "S" .and. !lIsTitPA

							lAplMinP := SA2->(ColumnPos('A2_MINPUB')) > 0 .And. SA2->A2_MINPUB == "2"

							lCalcIssBx := !_lIssMR .AND. IsIssBx("P")

							dbSelectArea("SE2")
							nRegSE2		:= SE2->(RecNo())
							nSaldo		:= SE2->E2_SALDO
							nSaldoCru	:= Round(NoRound(xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,nMoedaBco,,_nTamMD2,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0)),3),2)
							nValorTotal	+= nSaldoCru
							cNumero		:= SE2->E2_NUM
							cPrefixo	:= SE2->E2_PREFIXO
							cParcela	:= SE2->E2_PARCELA
							cFornece	:= SE2->E2_FORNECE
							cLoja		:= SE2->E2_LOJA
							nTotAbat	:= 0
							nTotAbtF	:= 0   // Abatimento na moeda do titulo
							nMoeda		:= 2
							nJuros		:= 0
							fa080Juros(nMoedaBco)	// Calcula juros do titulo

							If __lFKD
								nVa		:= FValAcess(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ, /*lBaixados*/, /*cCodVa*/, "P", dBaixa, /*aValAces*/, SE2->E2_MOEDA, nMoedaBco, SE2->E2_TXMOEDA)
							EndIf

							nCorrec		:= FA091Correc(nMoedaBco)
							nAcresc		:= Round(NoRound(xMoeda(SE2->E2_SDACRES,SE2->E2_MOEDA,nMoedaBco,,_nTamMD2,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0)),3),2)
							nDecresc	:= Round(NoRound(xMoeda(SE2->E2_SDDECRE,SE2->E2_MOEDA,nMoedaBco,,_nTamMD2,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0)),3),2)
							nPis		:= 0
							nCofins 	:= 0
							nCsll		:= 0
							nValPgto	:= 0
							nIrrf		:= 0
							lAplVlMin	:= .T.
							nIss		:= 0
							nBaseIrpf	:= 0  //O valor da base do IRPF sera retornado pela funcao F241BsIRPF()
							lBaixaPA	:= SE2->E2_TIPO $ MVPAGANT
							lGerPAMov	:= .F.
							lCtbIncPA   := lBaixaPA .And. AllTrim(SE2->E2_LA) == "S"
							//Reestruturacao SE5
							nDescCalc 	:= 0
							nJurosCalc 	:= 0
							nMultaCalc 	:= 0
							nVACalc 	:= 0
							nCorrCalc	:= 0
							nDifCboCalc	:= 0
							nImpSubCalc	:= 0
							//O valor dessas variáveis serão carregadas pela NewMinPcc
							nPisCalc	:= 0
							nCofCalc	:= 0
							nCslCalc	:= 0
							nIrfCalc	:= 0
							nIssCalc	:= 0
							nPisBaseR 	:= 0
							nCofBaseR	:= 0
							nCslBaseR 	:= 0
							nIrfBaseR 	:= 0
							nIssBaseR 	:= 0
							nPisBaseC 	:= 0
							nCofBaseC 	:= 0
							nCslBaseC 	:= 0
							nIrfBaseC 	:= 0
							nIssBaseC 	:= 0
							cPadAux  :=	cPadrao
							lPadrao  := mv_par04 == 1 .And. VerPadrao(cPadrao)
							nRecSE2		:= SE2->(RecNo())
							//Dados da tabela auxiliar com o código do título a pagar
							cChaveTit := xFilial("SE2", SE2->E2_FILORIG) + "|" + SE2->E2_PREFIXO + "|" + SE2->E2_NUM + "|" + SE2->E2_PARCELA + "|" + SE2->E2_TIPO + "|" + SE2->E2_FORNECE + "|" + SE2->E2_LOJA
							cChaveFK7 := FINGRVFK7("SE2", cChaveTit)

							f091LRatIR(.T.) // Limpa objeto __oRatIRF IR Progressivo

							If (ALLTRIM(SE2->E2_ORIGEM) $ "FINA667|FINA677")
								FINATURES(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA),.T.,SE2->E2_ORIGEM,"P")
							Endif

							If lPadrao .And. nTipoBx != 2
								lPadrao := (cCtBaixa $ "BA" .or. !lMovBcoBx .or.(lMovBcoBx .and. !lChqMotBx))

								If !lPadrao .And. cCtBaixa $ "C"  .And. (!Empty( cCheq090 ) .and. SubStr( cCheq090, 1, 1 ) != "*" .and. SE2->E2_IMPCHEQ != "S")
									lPadrao := .T.
								EndIf
							Endif

							lPadAux := lPadrao

							If SE2->E2_APLVLMN == "2"
								lAplVlMin := .F.
							Endif

							If lFa090Desc
								nDescont := Execblock("FA090DES",.F.,.F.)
							Endif

							If lFa090Juros
								nJuros := Execblock("FA090JUR",.F.,.F.)
							Endif

							If lFa090Mult
								nMulta := Execblock("FA090MUL",.F.,.F.)
							Endif

							If lFa090Corr
								nCorrec := Execblock("FA090COR",.F.,.F.)
							Endif

							//Verifica se existe cheque sobre titulo e busca os dados do cheque para gravacao no SE5
							If SE2->E2_IMPCHEQ == "S"
								dbSelectArea("SEF")
								dbSetOrder(3)

								If Empty( _cFilFwSEF )
									cMFilial := xFilial("SEF")
								Else
									If Empty( _cFilFwSE2 )
										cMFilial := xFilial("SEF")
									Else
										cMFilial := SE2->E2_FILIAL
									EndIf
								EndIf

								If DbSeek(cMFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO)
									WHILE !(SEF->(EOF())) .And. (cMFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO ==  SEF->EF_FILIAL + SEF->EF_PREFIXO+SEF->EF_TITULO+SEF->EF_PARCELA+SEF->EF_TIPO)
										IF Empty(SEF->EF_SEQUENC) .and. SEF->EF_FORNECE+SEF->EF_LOJA == SE2->E2_FORNECE+SE2->E2_LOJA
											cBcoTit	:=SEF->EF_BANCO
											cAgeTit	:=SEF->EF_AGENCIA
											cCtaTit	:=SEF->EF_CONTA
											cChqTit	:=SEF->EF_NUM
											EXIT
										Endif

										SEF->(DbSkip())
									ENDDO
								Endif
							Endif

							//Baixar titulos de abatimento se for baixa total				  ³
							If Select("__SE2") == 0
								ChkFile("SE2",.F.,"__SE2")
							Else
								DbSelectArea("__SE2")
							EndIf

							dbSetOrder(1)
							dbSeek(SE2->E2_FILIAL+cPrefixo+cNumero+cParcela)

							While !EOF() .And. E2_PREFIXO == cPrefixo .And. E2_NUM == cNumero .And. E2_PARCELA == cParcela
								If E2_TIPO $ MVABATIM .And. E2_FORNECE == cFornece
									nTotAbat += Round(NoRound(xMoeda(E2_SALDO,E2_MOEDA,nMoedaBco,,_nTamMD2,If(cPaisLoc=="BRA",E2_TXMOEDA,0)),3),2)
									nTotAbtF += E2_SALDO
									nValorTotal-=nTotAbat

									RecLock("__SE2")
									Replace E2_SALDO	With 0
									Replace E2_BCOPAG	With cBco090
									Replace E2_BAIXA	With dBaixa
									Replace E2_LOTE		With cLoteFin
									Replace E2_MOVIMEN	With dBaixa
									Replace E2_SDACRES  With 0
									Replace E2_SDDECRE  With 0
								Endif

								dbSkip()
							Enddo

							(cAliasSE2)->(dbGoto(nRegAtu))
							SE2->(dbGoTo((cAliasSE2)->NUM_REG))

							If !Empty(SE2->E2_NUMBOR)
								lRetBor := VLDBOR(SE2->E2_NUMBOR, "P", SE2->E2_FILORIG)
							Endif

							//Controle de impostos Pis Cofins Csll na baixa
							nValPgto := nSaldoCru-nTotAbat+nJuros+nMulta-nDescont+nVA+nAcresc-nDecresc-nPis-nCofins-nCsll

							If !_lIrfMR .AND. !lIRPFBaixa
								nValPgto -= nIrrf
							EndIf

							If !_lIssMR .AND. !lCalcIssBx
								nValPgto -= nIss
							EndIf

							nOldValPgto := nValPgto

							//caso o titulo de PA não tenha movimento, não deve baixar
							IF lBaixaPA
								aAreaSE52:= getarea()
								nRecPAInc := F080MovPA(.T.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_FILIAL)

								If nRecPAInc == 0
									lBaixaPA := .F.
									lGerPAMov := .T.
								EndIf

								If lGerPAMov
									cPadrao := "513"
									lPadrao := !lCtbIncPA .And. lCtMovPa .And. mv_par04 == 1 .And. VerPadrao(cPadrao)
								EndIf

								Restarea(aAreaSE52)
							EndIf

							If lGerPAMov
								nGerPAMov++
							EndIf


							//--------------------------------------------------------------------
							// ISS
							//--------------------------------------------------------------------
							If !_lIssMR .and. lCalcIssBx .and. (Empty(SE2->E2_NUMBOR) .or. (!Empty(SE2->E2_NUMBOR) .AND. lRetBor)) .and. !lIsTitPA
								F080IssBx()
							Endif

							//--------------------------------------------------------------------
							// IRRF
							//--------------------------------------------------------------------
							nOldValPgto := nValPgto
							nIRRF       := 0

							If !_lIrfMR .AND. lIRPFBaixa .AND. !lIsTitPA .AND. (nTipoBx == 1 .or. (nTipoBx == 2 .and. "FINA240" $ SEA->EA_ORIGEM)) .And. !( "MATA100" $ SE2->E2_ORIGEM .And. Empty( SE2->E2_BASEIRF ) .And. Empty( SE2->E2_IRRF ) )
								nIRRF := FCalcIRBx(0,SA2->A2_TIPO,dBaixa,dDebito,/*lAltValor*/,/*nTxmoeda*/,cMotBx)
							EndIf

							//Controle de impostos Pis Cofins Csll na baixa
							nValPgto	:= nSaldoCru - nTotAbat + nJuros + nVA + nMulta - nDescont + nAcresc - nDecresc - nPis - nCofins - nCsll
							nValPgto	-= IIf(!_lIrfMR .AND. lIRPFBaixa .AND. nTipoBx == 1,nIrrf,0)
							nValPgto	-= IIf(!_lIssMR .AND. lCalcIssBx .AND. nTipoBx == 1,nIss ,0)
							nOldValPgto := nValPgto

							If (!_lIrfMR .AND. lIRPFBaixa) .OR. (!_lIssMR .AND. lCalcIssBx)
								nValPgto := nOldValPgto
							EndIf

							//Valida se já houve retenção no borderô.
							lBordero := If(_lPccMR, _lPccBxMR, lPCCBaixa) .And. ((!Empty(SE2->E2_NUMBOR)) .And. SE2->E2_PRETPIS == '4' .OR. SE2->E2_PRETCOF == '4' .OR. SE2->E2_PRETCSL == '4')

							//--------------------------------------------------------------------
							// PCC
							//--------------------------------------------------------------------
							aTitCalc := {}
							If !_lPccMR .And. !lBordero .And. cPaisLoc == "BRA" .And. lPccBaixa .And. lCalcPccBx .And. VLDBOR(SE2->E2_NUMBOR,"P",cFilAnt) .And. !lIsTitPA
								If (dBaixa < dLastPcc .Or. lEmpPub)
									f080TotMes(dBaixa,.T.,,.F.)
								Else
									If Empty(_nBasLeg)
										nSalImp := salRefPag(SE2->(E2_FORNECE + E2_LOJA),_lPccMR, _lIrfMR, _lInsMR, _lIssMR, _lCidMR, _lSesMR)
									Else
										nSalImp := _nBasLeg
									EndIf

									nSalImp	+= F080JuMuDe()

									aPCC := NewMinPcc(dBaixa, nSalImp, SE2->E2_NATUREZ, "P", SE2->(E2_FORNECE + E2_LOJA), /*nIss*/, /*nIns*/, /*nIrf*/, /*lMin*/, /*lIgnrOrg*/, cMotBx)
									If aPCC[1]
										nPis    := aPCC[2]
										nCofins := aPCC[3]
										nCsll   := aPCC[4]
										If len(aPCC)>4
											aTitCalc := aPCC[5]
										Endif
									Endif
								Endif
							EndIf

							nValPgto	:= nSaldoCru - nTotAbat + nJuros + nMulta - nDescont + nVA + nAcresc - nDecresc-If(!_lPccMR, (nPis+nCofins+nCsll), 0) - _nImpMR
							nValPgto	-= IIf(!_lIrfMR .And. lIRPFBaixa .And. nTipoBx == 1,nIrrf,0)
							nValPgto	-= IIf(!_lIssMR .And. lCalcIssBx .And. nTipoBx == 1 .OR. (nTipoBx == 2 .AND. !lBordero),nIss ,0)
							nOldValPgto := nValPgto

							dbSelectArea( "SE2" )

							If !_lPccMR .And. !lPccBaixa .And. !lIRPFBaixa .And. !lIsTitPA
								//Atualiza a data de vencimento dos titulos de impostos
								AltVencImp(dDataBase)
								//Altera impostos
								F080Impost(SE2->(RECNO()),.F.,nJuros,nMulta,nDescont,nSaldoCru-nTotAbat+nJuros+nMulta-nDescont+nAcresc-nDecresc,nVA)
							Endif

							nJuros   := nJuros   + nAcresc
							nDescont := nDescont + nDecresc

							// Efetua a baixa dos valores acessórios.
							If lPodeTVA .and. lExistVA
								FAtuFKDBx(.F., "P")
							Endif

							//Atualiza a Baixa do Titulo
							If  !lGerPAMov .and. (!(SE2->E2_TIPO $ MVTXA+"#"+MVPAGANT+"#"+"INA") .Or. (SE2->E2_TIPO $ MVTXA+"#"+MVPAGANT .and. lBxTxa) .Or. lBaixaPA)
								RecLock("SE2")
								SE2->E2_OK	:= "  "

								//Verifico se existe data baixa indicando alguma baixa no título a pagar
								If EMPTY(SE2->E2_BAIXA)
									lDtBaixa := .F.
								Else
									lDtBaixa := .T.
								EndIf

								If !_lIrfMR .And. lIRPFBaixa .AND. nTipoBx == 1
									SE2->E2_VRETIRF += nIrrf
									If SA2->A2_TIPO == "F"
										If EMPTY(SE2->E2_BAIXA)
											SE2->E2_IRRF := nIrrf
										Elseif SE2->E2_PRETIRF <> "7"
											SE2->E2_IRRF += nIrrf
										EndIf
									EndIf
								EndIf

								If !_lIssMR .AND. lCalcIssBx  .AND. nTipoBx == 1
									SE2->E2_VRETISS += nIss
								EndIf

								SE2-> E2_BAIXA		:= iif(SE2->E2_BAIXA <= dBaixa, dBaixa, SE2->E2_BAIXA)
								SE2-> E2_VALLIQ		:= nValPgto
								SE2-> E2_SALDO		:= 0
								SE2-> E2_MOVIMEN	:= dDataBase

								If !Empty(SE2->E2_PORTADO)
									SE2-> E2_BCOPAG	:= E2_PORTADO
								Else
									SE2-> E2_BCOPAG	:= cBco090
								EndIf

								SE2-> E2_JUROS		:= nJuros
								SE2-> E2_CORREC		:= nCorrec
								SE2-> E2_DESCONT	:= nDescont
								SE2-> E2_MULTA		:= nMulta
								SE2-> E2_SDACRES	:= 0
								SE2-> E2_SDDECRE	:= 0

								If Empty(SE2->E2_NUMBCO) .And. !Empty(cCheq090)
									SE2->E2_NUMBCO   := cCheq090
								Endif

								//Armazeno os valores retidos de impostos, se os mesmos foram gerados por um bordero
								If (SE2->E2_PRETPIS $ '4#2' .OR. SE2->E2_PRETCOF $ '4#2' .OR. SE2->E2_PRETCSL $ '4#2' .Or.!Empty(SE2->E2_NUMBOR))
									lBordero := .T.
								EndIf

								If lBordero
									nOldRetPis := SE2->E2_VRETPIS
									nOldRetCof := SE2->E2_VRETCOF
									nOldRetCsl := SE2->E2_VRETCSL
									nOldRetIrf := SE2->E2_VRETIRF
								EndIf

								//Marco que o titulo tem os impostos calculados pela baixa (Pis, Cofins e Csll)
								If !_lPccMR .And. lContrRet .And. lPCCBaixa
									If !lBordero
										SE2->E2_PRETPIS := "3"
										SE2->E2_PRETCOF := "3"
										SE2->E2_PRETCSL := "3"
									EndIf

									SE2->E2_VRETPIS += nPis
									SE2->E2_VRETCOF += nCofins
									SE2->E2_VRETCSL += nCsll
								Endif

								If lAtuSldNat
									//Atualiza o saldo da natureza. O valor jah esth liquido dos abatimentos, desta forma nao precisa atualizar na baixa dos abatimentos
									AtuSldNat(SE2->E2_NATUREZ, SE2->E2_BAIXA, SE2->E2_MOEDA, "3", "P", nValPgto, xMoeda(nValPgto,SE2->E2_MOEDA,1,SE2->E2_BAIXA,,,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0)), If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"-","+"),,FunName(),"SE2",SE2->(Recno()),0)
								EndIf

								If cPaisLoc = "BRA" .And. !_lPccMR .AND. lPccBaixa .And. lBordero
									Reclock("SE2")
									SE2->E2_VRETPIS := nOldRetPis
									SE2->E2_VRETCOF := nOldRetCof
									SE2->E2_VRETCSL := nOldRetCsl
									MsUnlock()
								EndIf

								//Array para Vendor ou Contabilizar bordero totalizando por bordero
								If Ascan(aTitBaixado,{|X| x[1] == SE2->(Recno())}) = 0
									Aadd(aTitBaixado, {SE2->(Recno()),SE2->(E2_FILORIG+E2_NUMBOR),SE2->E2_NUMBOR} )
								Endif

								//Verifica se existe solicitacao de NCP e caso exista atualiza o campo CU_DTBAIXA...
								If cPaisLoc <> "BRA"
									A055AtuDtBx("1",SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NUM,SE2->E2_PREFIXO,SE2->E2_BAIXA)

									If Upper(Left(SE2->E2_NUMBCO,5))=="CJCC_"
										Fa550CJCC(Substr(SE2->E2_NUMBCO,6),"A")
									Endif
								EndIf

								//PE para controlar novas taxas financeiras
								If lFa090Tx
									Execblock("FA090TX",.F.,.F.)
								Endif

								MsUnlock()
								FA373Bx(.T.)
							ElseIf !lBxTxa .and. SE2->E2_OK <> 'TA'
								RecLock("SE2")
								SE2->E2_OK := 'TA'
								SE2->E2_BAIXA	:= iif(SE2->E2_BAIXA <= dDataBase, dDataBase, SE2->E2_BAIXA)
								MsUnlock()
							Endif

							If cPaisLoc == "BRA"
								//Caso gere movimento de baixa aglutinadora igual a Bx Lote
								//nTipoBx = 2 -> Bordero, lBxCnab -> Gera totalizador quando baixa CNAB
								//mv_par01 = 2 -> Gera cheque automaticamente, lMovBcoBx .and. !ChqMotBx(cMotBx) -> Movimenta banco sem cheque

								If nTipoBx == 1  //Baixa Titulos
									lCheque := ChqMotBx(cMotBx)
								Else //Bordero
									lCheque := (nTipoBx == 2 .and. ChqMotBx(cMotBx))
								Endif

								lGerTotal := IIf((nTipoBx == 2 .and. lBxCnab .and. (mv_par01 == 2 .or. (lMovBcoBx .and. !ChqMotBx(cMotBx))) ), .T.,.F.)

								//Caso banco seja Caixa, nao deve gerar cheque
								If	nTipoBx == 2 .and. ((Substr(SEA->EA_PORTADO,1,2) == "CX" .and. lMovBcoBx) .or. (SEA->EA_PORTADO $ cMV_CARTEIR) .and. lMovBcoBx)
									lCheque := .F.
									lIsCaixa := .T.
								Endif

								//Baixa de titulos em banco caixa deve gerar movimento bancario sem cheque ainda que o motivo de baixa exija
								If	nTipoBx == 1 .and. ((Substr(cBco090,1,2) == "CX" .and. lMovBcoBx) .or. (cBco090 $ cMV_CARTEIR) .and. lMovBcoBx)
									lCheque := .F.
									lGerTotal := IIf(lBxCnab,.T.,.F.)
									lIsCaixa := .T.
								Endif

								VAR_IXB := lCheque
							Endif

							cFilSeq := cFilAnt

							If xFilial("SE2") != SE2->E2_FILIAL
								For nFil := 1 to Len(aFilial)
									cFilAnt := aFilial[nFil]
									If xFilial("SE2") == SE2->E2_FILIAL
										Exit
									Endif
								Next
							Endif

							//Obtém a nova sequencia de baixa
							cSequencia := ""

							If !lGerPAMov
								cSequencia := FaNxtSeqBx("SE2", .T.)  // Sequencia da baixa do titulo + 1
								nValorTotal -= _nImpMR
								nValorTotal -= If(!_lPccMR .And. lPccBaixa, nPis + nCofins + nCsll, 0)
								nValorTotal -= If(!_lIrfMR .And. lIRPFBaixa, nIrrf, 0)
								nValorTotal -= If(!_lIssMR .And. lCalcIssBx, nIss, 0)
								nValorTotal += nJuros
								nValorTotal += nMulta
								nValorTotal -= nDescont
								nValorTotal += nVA
								nValorSEF	:= SE2->E2_VALLIQ
							Else
								cSequencia := ""
								nValorTotal -= nSaldoCru
								nValorSEF	:= IIF(SE2->E2_MOEDA > 1 .And. nMoedaBco == 1, SE2->E2_VLCRUZ, SE2->E2_VALOR)
							EndIF

							//Restauro filial
							cFilAnt := cFilSeq
							lNewProc := .T.

							//Baixa de PA ou geração de Mov do mesmo não gera novo processo, utiliza o processo criado na inclusão
							If lIsTitPA .AND. lGerPAMov
								FKA->(dbSetOrder(3)) 
								If FKA->(MsSeek(xFilial("FKA") + "SE2" + cChaveFK7))
									lNewProc := .F.
									BxGerMovPA(.T.)
									cE5TABORI := "SE2"
									cE5IDORIG := cChaveFK7
									FinSetAPrc("SE2")
								EndIf
							EndIf

							//Dados da tabela auxiliar com o código do título a pagar	
							cIdFK2 	  := FWUUIDV4()
							cCamposE5 := ""
							aImpostos := {}

							If !lGerPaMov
								//Carrego model de Bx Pagar
								oModelBxP	:= FWLoadModel("FINM020")	//Model de baixas a pagar
								oModelBxP:SetOperation( 3 ) //Inclusao
								oModelBxP:Activate()
								oModelBxP:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
								oModelBxP:SetValue( "MASTER", "NOVOPROC", lNewProc) //Novo processo
								oSubFK2  := oModelBxP:GetModel("FK2DETAIL")
								oSubFK3  := oModelBxP:GetModel("FK3DETAIL")
								oSubFK4  := oModelBxP:GetModel("FK4DETAIL")
								oSubFK5  := oModelBxP:GetModel("FK5DETAIL")
								oSubFK6  := oModelBxP:GetModel("FK6DETAIL")
								oSubFKA  := oModelBxP:GetModel("FKADETAIL")
							Else
								oModelBxP	:= FWLoadModel("FINM050")	//Model de gravação do PA
								oModelBxP:SetOperation(MODEL_OPERATION_INSERT) //Inclusao
								oModelBxP:Activate()
								oModelBxP:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
								oModelBxP:SetValue( "MASTER", "NOVOPROC", lNewProc) //Novo processo
								oSubFK5  := oModelBxP:GetModel("FK5DETAIL")
								oSubFKA  := oModelBxP:GetModel("FKADETAIL")
								cSequencia := ""
								nValorTotal -= nSaldoCru
								nValorSEF	:= IIF(SE2->E2_MOEDA > 1 .And. nMoedaBco == 1, SE2->E2_VLCRUZ, SE2->E2_VALOR)
							Endif


							If cPaisLoc=="BRA"
								If !lIsTitPA .and. lCheque .And. lMovBcoBx .And. SE2->E2_IMPCHEQ != "S" .And. !lGerTotal
									//REESTRUTURACAO SE5
									cChaveCH := FWUUIDV4()

									//Geração do Cheque a ser impresso
									If Empty( _cFilFwSEF )   //Multi-Filial
										cMFilial := xFilial("SEF")
									Else
										If Empty( _cFilFwSE2 )
											cMFilial := xFilial("SEF")
										Else
											cMFilial := SE2->E2_FILIAL
										EndIf
									EndIf

									RecLock("SEF",.T.)
									SEF->EF_FILIAL		:= xFilial("SEF",cFilAnt)
									SEF->EF_PORTADO 	:= SE2->E2_PORTADO
									SEF->EF_VALOR		:= nValorSEF
									SEF->EF_DATA		:= dDataBase
									SEF->EF_HIST		:= IIF((!Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*" ),IIF(AllTrim(cHistor090)<>"",cHistor090,SE2->E2_HIST),SE2->E2_HIST) //"Cheque por Bx. Automatica"
									SEF->EF_PREFIXO		:= SE2->E2_PREFIXO
									SEF->EF_TITULO		:= SE2->E2_NUM
									SEF->EF_PARCELA		:= SE2->E2_PARCELA
									SEF->EF_TIPO		:= SE2->E2_TIPO
									SEF->EF_FORNECE		:= SE2->E2_FORNECE
									SEF->EF_LOJA		:= SE2->E2_LOJA
									SEF->EF_ORIGEM  	:= "FINA091"
									SEF->EF_SEQUENC		:= cSequencia
									SEF->EF_BANCO		:= cBco090
									SEF->EF_AGENCIA		:= cAge090
									SEF->EF_CONTA		:= cCta090
									SEF->EF_BENEF		:= SA2->A2_NOME
									SEF->EF_LIBER		:= cLiberado

									If !Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*"
										SEF->EF_NUM		:= cCheq090
										SEF->EF_LA      := Iif(mv_par04==1 .and. mv_par01==1 .and. lPadrao .and. ( cCtBaixa $ "BA") .and. !lUsaFlag,"S"," ")
										SEF->EF_IMPRESS := "A"
									Endif

									SEF->EF_FILORIG := SE2->E2_FILORIG
									SEF->EF_FILCHQ	:= cFilCorr
									SEF->EF_IDSEF	:= cChaveCH		//ID do cheque

									//Dados do movimento bancario do Cheque
									If !oSubFKA:IsEmpty()
										oSubFKA:AddLine()
										oSubFKA:GoLine( oSubFKA:Length() )
									Endif

									//Dados do Cheque  //revisar
									oSubFKA:SetValue( 'FKA_IDORIG', cChaveCH )
									oSubFKA:SetValue( 'FKA_TABORI', 'SEF' )

									If lFa080Sef
										Execblock("FA080SEF",.f.,.f.)
									Endif
									MsUnlock()
								Endif
							Endif

							If !lIsTitPA
								nTotaGer    += SE2->E2_VALLIQ
								nValorCheq  += IIF(SE2->E2_IMPCHEQ == "S",0,SE2->E2_VALLIQ)
							EndIf

							//Reestruturacao SE5
							nDescCalc 	:= nDescont
							nJurosCalc 	:= nJuros
							nMultaCalc 	:= nMulta
							nVACalc 	:= nVA
							nCorrCalc	:= nCorrec

							//Grava registro referente … movimentação bancaria
							For nZ := 1 To 6
								//Atualiza a Movimentação Banc ria
								If nZ==1
									nCpoTp  := SE2->E2_VALLIQ
									cTpDoc  := IIF(lCheque .or. lGerTotal	.Or. SE2->E2_IMPCHEQ == "S" .or. !lMovBcoBx ,"BA"	,"VL"	)

									//Se for baixa de um TXA e o mesmo nao deve zerar o saldo
									If !lBxTxa .and. SE2->E2_TIPO $ MVTXA+"#"+"INA"
										nCpoTp  := SE2->E2_VALOR
									Endif
									If lGerPaMov
										nCpoTp  := IIF(SE2->E2_MOEDA > 1 .And. nMoedaBco == 1, SE2->E2_VLCRUZ, SE2->E2_VALOR)
										cTpDoc  := "PA"
									Else
										If SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
											cTpDoc := Iif(MovBcoBx(cMotBx, .T.),"VL","BA")
										EndIf
									EndIf
									cHistMov	:= IIF(lMovBcoBx,STR0029,cDescrMo) // "Valor pago s /Titulo"

								Elseif nZ == 2
									nCpoTp  := nDescont
									cTpDoc  :="DC"
									cHistMov:=OemToAnsi( STR0032 ) //"Desconto s/Receb.Titulo"
									nCpoCalc := nDescCalc

								Elseif nZ == 3
									nCpoTp  := nJuros
									cTpDoc  := "JR"
									cHistMov:=OemToAnsi( STR0030 ) //"Juros s/Receb.Titulo"
									nCpoCalc := nJurosCalc

								Elseif nZ == 4
									nCpoTp  := nMulta
									cTpDoc  :="MT"
									cHistMov:=OemToAnsi( STR0033 ) //"Multa s/Receb.Titulo"
									nCpoCalc := nMultaCalc

								Elseif nZ == 5
									nCpoTp  := nCorrec
									cTpDoc  := "CM"
									cHistMov:=OemToAnsi( STR0031 )//"Correcao Monet s/Receb.Titulo"
									nCpoCalc := nCorrCalc

								Elseif nZ == 6
									nCpoTp	 := nVA
									cTpDoc	 := "VA"
									cHistMov := ""		// Valores Acessórios (histórico virá da FKD)
									nCpoCalc := nVACalc
								Endif

								If nCpoTp != 0 .Or. nZ == 1
									If lF091Natur
										cNatur090 := ExecBlock("F091Natur",.F.,.F.)
									EndIf

									If !Empty(cNatur090)
										aArea := GetArea()
										dbselectArea("SED")
										dbsetorder(1)

										If !DbSeek(xFilial("SED")+cNatur090)
											cNatur090 := FINNATMOV("P")
										Endif
										RestArea(aArea)
									Else
										cNatur090 := FINNATMOV("P")
									EndIf

									cRecPag := Iif( lBaixaPA , "R" , "P" )

									//Define os campos que não existem nas FKs e que serão gravados apenas na E5, para que a gravação da E5 continue igual
									If !Empty(cCamposE5)
										cCamposE5 += "|"
									Endif

									cCamposE5 += "{"
									cCamposE5 += " {'E5_DTDIGIT' , dDtDigit}"
									cCamposE5 += ",{'E5_PREFIXO' , '"+cPrefixo +"'}"
									cCamposE5 += ",{'E5_NUMERO'  , '"+SE2->E2_NUM+"'}"
									cCamposE5 += ",{'E5_PARCELA' , '"+SE2->E2_PARCELA+"'}"
									cCamposE5 += ",{'E5_TIPO'    , '"+SE2->E2_TIPO+"'}"
									cCamposE5 += ",{'E5_FORNECE' , '"+SE2->E2_FORNECE+"'}"
									cCamposE5 += ",{'E5_CLIFOR'  , '"+SE2->E2_FORNECE+"'}"
									cCamposE5 += ",{'E5_LOJA'    , '"+SE2->E2_LOJA+"'}"
									cCamposE5 += ",{'E5_BENEF'   , '"+StrTran(SE2->E2_NOMFOR,"'","")+"' }"
									cCamposE5 += ",{'E5_TPDESC'  , '"+ cTpDescSE5 +"' }"
									cCamposE5 += ",{'E5_RECPAG'  , '"+ cRecPag +"' }"
									cCamposE5 += ",{'E5_DOCUMEN' , '"+ SE2->E2_NUMBOR +"' }"

									If (_lIssMR .Or. lCalcIssBx)
										cCamposE5 += ",{'E5_VRETISS' , " + cValToChar(If(_nIssMR > 0, _nIssMR, nIss)) + " }"
									Endif

									//Grava registro referente … movimentação bancaria Movimento principal (baixa e banco)
									If nZ == 1
										//Valores acessorios no registro principal da baixa
										cCamposE5 += ",{'E5_VLJUROS' , "+cValToChar(nJuros)+" }"
										cCamposE5 += ",{'E5_VLMULTA' , "+cValToChar(nMulta)+" }"
										cCamposE5 += ",{'E5_VLCORRE' , "+cValToChar(nCorrec)+" }"
										cCamposE5 += ",{'E5_VLDESCO' , "+cValToChar(nDescont)+" }"
										cCamposE5 += ",{'E5_VLACRES' , "+cValToChar(nAcresc)+" }"
										cCamposE5 += ",{'E5_VLDECRE' , "+cValToChar(nDecresc)+" }"
										nValorSE5	:= nCpoTp
										dDataSE5	:= dBaixa

										If cPaisLoc <> "BRA" .And. SE5->E5_TIPODOC == "VL"
											SA6->(DbSetOrder(1))

											If Empty( _cFilFwSA6 )
												cMFilial := xFilial("SA6")
											Else
												If Empty( _cFilFwSE2 )
													cMFilial := xFilial("SA6")
												Else
													cMFilial := SE2->E2_FILIAL
												EndIf
											EndIf

											SA6->(DbSeek(cMFilial+SE2->E2_BCOCHQ+SE2->E2_AGECHQ+SE2->E2_CTACHQ))
											nMoedaBco   := Max(IIf(SA6->A6_MOEDAP > 0,SA6->A6_MOEDAP,SA6->A6_MOEDA),1)
											nMoedaBco   := Max(IIf(SA6->A6_MOEDAP > 0,SA6->A6_MOEDAP,SA6->A6_MOEDA),1)
											nValorSE5	:= If(nMoedaBco	<>	SE2->E2_MOEDA,xMoeda(E5_VALOR,1,nMoedaBco),nSaldo )
											cBanco 		:= SE2->E2_BCOCHQ
											cAgencia	:= SE2->E2_AGECHQ
											cConta		:= SE2->E2_CTACHQ
											If lAtuSldBco
												AtuSalBco(SE5->E5_BANCO,SE5->E5_AGENCIA,SE5->E5_CONTA,SE5->E5_DATA,SE5->E5_VALOR,"-")
											Endif
										Endif

										If lFa090Se5
											cE5_HISTOR := Execblock("FA090SE5",.F.,.F., {cE5_Histor})
											If ValType(cE5_HISTOR) == "C"
												RecLock("SE5")
												cHistMov := cE5_HISTOR
												MsUnlock()
											EndIf
										Endif

										If cPaisLoc =="BRA" //	#	"ARG"
											If !lCheque .and. lMovBcoBx .and. SE2->E2_IMPCHEQ != "S" .and. !lGerTotal
												cBanco		:= cBco090
												cAgencia	:= cAge090
												cConta		:= cCta090
											ElseIf SE2->E2_IMPCHEQ == "S"
												cBanco		:= cBcoTit
												cAgencia	:= cAgeTit
												cConta		:= cCtaTit
												cCheque		:= cChqTit
											ElseIf lCheque
												cBanco		:= cBco090
												cAgencia	:= cAge090
												cConta		:= cCta090
												If !(lIsTitPA .and. lGerPaMov) .and. !Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*"
													cCheque := cCheq090
												Endif
											Endif
										Endif

										If lGerTotal
											cBanco		:= cBco090
											cAgencia	:= cAge090
											cConta		:= cCta090
										EndIf

										cCamposE5 += ",{'E5_BANCO'   , '" + cBanco + "'}"
										cCamposE5 += ",{'E5_AGENCIA' , '" + cAgencia + "'}"
										cCamposE5 += ",{'E5_CONTA'   , '" + cConta + "'}"
										cCamposE5 += ",{'E5_DTDISPO' , STOD('" + DTOS(dDebito) + "')}"

										If cPaisLoc == "CHI"
											cCamposE5 += ",{'E5_ORDREC'   , '" + SE2->E2_ORDPAGO + "'}"
										Endif

										//Relacionamento FKA X FK2
										If !oSubFKA:IsEmpty()
											//Inclui a quantidade de linhas necessárias
											oSubFKA:AddLine()
											//Vai para linha criada
											oSubFKA:GoLine( oSubFKA:Length() )
										Endif
									
										If !lGerPaMov
											oSubFKA:SetValue( 'FKA_IDORIG', cIdFK2 )
											oSubFKA:SetValue( 'FKA_TABORI', "FK2" )
											//Dados da baixa a pagar
											oSubFK2:SetValue( "FK2_DATA"   , dDataSE5 )
											oSubFK2:SetValue( "FK2_NATURE" , SE2->E2_NATUREZ )
											oSubFK2:SetValue( "FK2_RECPAG" , cRecPag )
											oSubFK2:SetValue( "FK2_HISTOR" , If(!Empty(cHistor090) .and. !(lIsTitPA .and. lGerPAMov) ,cHistor090,cHistMov) )
											oSubFK2:SetValue( "FK2_MOTBX"  , If(Empty(cMotBx),"NOR", TrazCodMot( cMotBx )) )
											oSubFK2:SetValue( "FK2_ORIGEM" , FunName() )
											oSubFK2:SetValue( "FK2_SEQ"    , cSequencia )
											oSubFK2:SetValue( "FK2_IDDOC"  , cChaveFK7 )
											oSubFK2:SetValue( "FK2_LOTE"   , cLoteFin )
											oSubFK2:SetValue( "FK2_TPDOC"  , cTpDoc )
											oSubFK2:SetValue( "FK2_CCUSTO" , SE2->E2_CCUSTO )
											oSubFK2:SetValue( "FK2_DOC"    , SE2->E2_NUMBOR )	// Vem do Fina240()
											oSubFK2:SetValue( "FK2_ARCNAB" , Iif(lGerTotal .and. lMovBcoBx,"FINA090","") )
											oSubFK2:SetValue( "FK2_FILORI" , SE2->E2_FILORIG )
											oSubFK2:SetValue( "FK2_AUTBCO" , "" )
											oSubFK2:SetValue( "FK2_MOEDA"  , StrZero(nMoedaBco,2) )
											oSubFK2:SetValue( "FK2_VLMOE2" , xMoeda(	nCpoTp	,nMoedaBco,SE2->E2_MOEDA,SE2->E2_BAIXA,,,nTxMoedBx) )
											oSubFK2:SetValue( "FK2_VALOR"  , nValorSE5 )
											oSubFK2:SetValue( "FK2_TXMOED" , nTxMoedBx )
											oSubFK2:SetValue( "FK2_LOTE"   , If (lGerTotal,cLoteFin,"") )
											oSubFK2:SetValue( "FK2_LA"     , If( lPadrao .and. mv_par04 == 1 .and. !lUsaFlag, "S", "N" ) )

											//------------------------------------------------------
											// Grava os valores agregados ao titulo no totalizador
											//------------------------------------------------------
											//Reestruturacao SE5
											//aImpostos[1] = codigo imposto
											//aImpostos[2] = imposto calculado
											//aImpostos[3] = natureza
											//aImpostos[4] = cIdFK4
											//aImpostos[5] = imposto retido
											//aImpostos[6] = base calculado
											//aImpostos[7] = base retencao
											//aImpostos[8] = Código tipo de retenção (FKM)
											//aImpostos[9] = Código Fornecedor
											//aImpostos[10] = Código Loja
											//aImpostos[11] = CNPJ/CPF
											//aImpostos[12] = Código Retenção
											If _lTemMR
												nImpos := Len(_aImpMR)

												For nX := 1 To nImpos
													If lFKCodRet .and. Len(_aImpMR[nX])>=23
														cCodRet :=  _aImpMR[nX,23]
													Else
														cCodRet := ""
													EndIf
													aAdd(aImpostos,{_aImpMR[nX,8], _aImpMR[nX,3], _aImpMR[nX,10], "", _aImpMR[nX,5], _aImpMR[nX,2], _aImpMR[nX,4], _aImpMR[nX,1], SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, cCodRet})
												Next nX
											EndIf

											If !_lIrfMR .AND. lIRPFBaixa .And. nIrfBaseC > 0 
												If lFKCodRet
													cCodRet := SE2->E2_CODRET
												Else 
													cCodRet := ""
												Endif

												//Rateio IRPF progressivo
												If __oRatIRF == Nil .OR. Empty(__oRatIRF:aRatIRF)
													aAdd(aImpostos,{"IRF", nIrfCalc, cMV_IRF, "", nIrrf, nIrfBaseC, nIrfBaseR, "", SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, cCodRet})
												Else
													For nX := 1 To Len(__oRatIRF:aRatIRF)
														If __oRatIRF:aRatIRF[nX][6] != 0
															aAdd(aImpostos,{"IRF", __oRatIRF:aRatIRF[nX][6], cMV_IRF, "", __oRatIRF:aRatIRF[nX][6], __oRatIRF:aRatIRF[nX][5], __oRatIRF:aRatIRF[nX][5], "", SA2->A2_COD, SA2->A2_LOJA, __oRatIRF:aRatIRF[nX][3], cCodRet})
														EndIf
													Next nX
												EndIf

											Endif

											If !_lPccMR .AND. lContrRet .and. lPccBaixa .AND. !lBordero
												aCodRet := getCodRet()
												If nPisCalc > 0 .And. nPisBaseC > 0
													aadd(aImpostos,{"PIS", nPisCalc ,cMV_PISNAT,"", nPis, nPisBaseC, nPisBaseR, '', SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, aCodRet[1]})
												EndIf

												If nCofCalc > 0 .And. nCofBaseC > 0
													aadd(aImpostos,{"COF", nCofCalc ,cMV_COFINS,"", nCofins, nCofBaseC, nCofBaseR, '', SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, aCodRet[2]})
												EndIf

												If nCslcalc > 0 .And. nCslBaseC > 0
													aadd(aImpostos,{"CSL", nCslcalc ,cMV_CSLL  ,"", nCsll, nCslBaseC, nCslBaseR, '', SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, aCodRet[3]})
												EndIf
											Endif
											cCodRet := ""
											If !_lIssMR .And. lCalcIssBx .And. nIssBaseC > 0 .And. nIssCalc > 0
												aadd(aImpostos,{"ISS",nIssCalc,cMV_ISS,"", nIss, nIssBaseC, nIssBaseR,'', SA2->A2_COD, SA2->A2_LOJA, SA2->A2_CGC, cCodRet})
											Endif

											//Grava FK3 E/OU FK4
											For nX := 1 to Len(aImpostos)
												//Gravar FK4 se os valores de PCC forem maiores que zero
												If aImpostos[nX][2] > 0 .OR. (lIRPFBaixa .AND. aImpostos[nX,1] == "IRF")
													cIdFK4 := ""

													If aImpostos[nX][5] > 0   //Houve retencao
														cIdFK4 := FINFKSID('FK4', 'FK4_IDFK4')
														aImpostos[nX,4] := cIdFK4

														If _lTemMR .And. nX <= nImpos
															_aImpMR[nX,6] := cIdFK4
														EndIF

														//Guardo o IDFK4 do IRF para usar posteriormente
														If aImpostos[nX,1] == "IRF"
															cIdFk4IR := cIdFK4
														Endif
													Endif

													If !oSubFK3:IsEmpty()
														oSubFK3:AddLine()
														oSubFK3:GoLine( oSubFK3:Length() )
													Endif

													//Grava Imposto calculado
													oSubFK3:SetValue( "FK3_IDFK3" , GetSx8Num('FK3', 'FK3_IDFK3'))
													oSubFK3:SetValue( "FK3_DATA"  , dDataBase )
													oSubFK3:SetValue( "FK3_ORIGEM", FunName() )
													oSubFK3:SetValue( "FK3_IMPOS" , aImpostos[nX,1] )
													oSubFK3:SetValue( "FK3_RECPAG", cRecPag )
													oSubFK3:SetValue( "FK3_MOEDA" , "01" )
													oSubFK3:SetValue( "FK3_VALOR" , aImpostos[nX,2] )
													oSubFK3:LoadValue( "FK3_NATURE", aImpostos[nX,3] )
													oSubFK3:SetValue( "FK3_FILORI", SE2->E2_FILORIG  )
													oSubFK3:SetValue( "FK3_BASIMP", aImpostos[nX,6] )
													oSubFK3:SetValue( "FK3_IDORIG", cIdFK2 )
													oSubFK3:SetValue( "FK3_TABORI", "FK2")
													oSubFK3:SetValue( "FK3_IDRET" , aImpostos[nx,4] )

													If lFKCodRet
														oSubFK3:SetValue( "FK3_CODRET" , aImpostos[nX,12] )
													EndIf

													If _lTemMR
														oSubFK3:SetValue( "FK3_CODFKM", aImpostos[nX,8] )
														oSubFK3:SetValue( "FK3_CLIFOR", aImpostos[nX,9] )
														oSubFK3:SetValue( "FK3_LOJA"  , aImpostos[nX,10] )
														oSubFK3:SetValue( "FK3_CGC"   , aImpostos[nX,11] )
														oSubFK3:SetValue( "FK3_RAICGC", Substr(aImpostos[nX,11], 1, 8) )

														If SE2->E2_MOEDA > 1
															oSubFK3:SetValue("FK3_VLMOE2", Round(xMoeda(aImpostos[nX][2],nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1,If(cPaisLoc == "BRA", SE2->E2_TXMOEDA, 0)),2))
														Else
															oSubFK3:SetValue("FK3_VLMOE2", aImpostos[nX][2])
														EndIf
													Endif

													//Grava Imposto Retido
													If aImpostos[nX][5] > 0   //Houve retencao
														If !oSubFK4:IsEmpty()
															oSubFK4:AddLine()
															oSubFK4:GoLine( oSubFK4:Length() )
														Endif

														oSubFK4:SetValue( "FK4_IDFK4" , aImpostos[nx,4])
														oSubFK4:SetValue( "FK4_DATA"  , dDataBase )
														oSubFK4:SetValue( "FK4_ORIGEM", FunName() )
														oSubFK4:SetValue( "FK4_IMPOS" , aImpostos[nx,1])
														oSubFK4:SetValue( "FK4_RECPAG", cRecPag )
														oSubFK4:SetValue( "FK4_MOEDA" , "01" )
														oSubFK4:SetValue( "FK4_VALOR" , aImpostos[nX,5] )
														oSubFK4:LoadValue( "FK4_NATURE", aImpostos[nX,3])
														oSubFK4:SetValue( "FK4_FILORI", SE2->E2_FILORIG )
														oSubFK4:SetValue( "FK4_BASIMP", aImpostos[nX][7] )

														If lFK4CLIFOR
															oSubFK4:SetValue( "FK4_CLIFOR", aImpostos[nX,9] )
															oSubFK4:SetValue( "FK4_LOJA"  , aImpostos[nX,10] )
														EndIf
														If lFKCodRet
															oSubFK4:SetValue( "FK4_CODRET" , aImpostos[nx,12] )
														EndIf
														If _lTemMR
															oSubFK4:SetValue( "FK4_CODFKM", aImpostos[nX,8] )
															oSubFK4:SetValue( "FK4_CGC"   , aImpostos[nX,11] )
															oSubFK4:SetValue( "FK4_RAICGC", Substr(aImpostos[nX,11], 1, 8) )

															If SE2->E2_MOEDA > 1
																oSubFK4:SetValue("FK4_VLMOE2", Round(xMoeda(aImpostos[nX,5],nMoedaBco,SE2->E2_MOEDA,dBaixa,nCentMd1,If(cPaisLoc == "BRA", SE2->E2_TXMOEDA, 0)),2))
															Else
																oSubFK4:SetValue("FK4_VLMOE2", aImpostos[nX,5])
															EndIf

															If nX <= nImpos .And. Len(_aImpMR[nX,7]) > 0 .And. _aImpMR[nX,7,1] > 0
																FK3->(DbGoTo(_aImpMR[nX,7,1]))
																RecLock("FK3")
																FK3->FK3_IDRET := _aImpMR[nX,6]
																FK3->(MsUnlock())
															EndIf
														Endif
													Endif
												Endif
											Next

											For nx:= 1 to len(aTitCalc)
												FINGFK3BOR(2,aTitCalc[nx,1],aTitCalc[nx,2],aImpostos,.F.)
											Next

											//IMPOSTOS
											If !_lIrfMR .And. lIRPFBaixa
												FGRVSFQIR(nIrrf,nBaseIrpf,aDadosIr,cSequencia,@cCamposIR,cIdFk4IR)
												cCamposE5 += cCamposIr
											Endif

											If ((!_lPccMR .And. lPccBaixa) .Or. _lPccBxMR)
												cCamposE5 += ",{'E5_VRETPIS' , " + cValToChar(If(_nPisMR > 0, _nPisMR, nPis)) + " }"
												cCamposE5 += ",{'E5_VRETCOF' , " + cValToChar(If(_nCofMR > 0, _nCofMR, nCofins)) + " }"
												cCamposE5 += ",{'E5_VRETCSL' , " + cValToChar(If(_nCslMR > 0, _nCslMR, nCsll)) + " }"

												If cModRetPIS == "1"
													If (aDadosRet[ 1 ] + (nValPgto+nPis+nCofins+nCsll+nIrrf+nDescont+nTotAbat-nJuros-nMulta-nVA) > nVlMinImp) .Or. !lAplVlMin
														lRetParc := .T.

														//Rotina para gerar titulo de adiantamento
														If cNccRet == "1" .and. nDiferImp < 0
															FGerCredRt(Abs(nDiferImp),SE2->E2_MOEDA,SE5->E5_SEQ)
														Endif

														nSavRec := SE5->( Recno() )
														//Exclui a Marca de "pendente recolhimento" dos demais registros
														If aDadosRet[1] > 0
															aRecnos := aClone( aDadosRet[ 6 ] )
															cPrefOri  := SE2->E2_PREFIXO
															cNumOri   := SE2->E2_NUM
															cParcOri  := SE2->E2_PARCELA
															cTipoOri  := SE2->E2_TIPO
															cCfOri    := SE2->E2_FORNECE
															cLojaOri  := SE2->E2_LOJA
															cPRet	  := " "

															For nLoop := 1 to Len( aRecnos )
																SE5->( dbGoto( aRecnos[ nLoop ] ) )
																//Atualiza a informação de retencao de impostos em outro titulo
																aAreaAnt := GetArea()
																oModelBxPA := FWLoadModel("FINM020")
																oModelBxPA:SetOperation( 4 ) //Alteração
																oModelBxPA:Activate()
																oModelBxPA:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
																oSubFKAA := oModelBxPA:GetModel( "FKADETAIL" )
																oSubFKAA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )

																//Atualizar o status de retencao de impostos
																oSubFK3A:= oModelBxPA:GetModel( "FK3DETAIL" )
																For nX := 1 to Len(aImpostos)
																	If oSubFK3A:SeekLine({{"FK3_IMPOS",aImpostos[nX,1]}})		//Nome do imposto
																		If aImpostos[nX,1] != "IRF"
																			oSubFK3A:SetValue( "FK3_IDRET",aImpostos[nX,4] )		//cIdFk4
																		Endif
																	Endif
																Next

																cCamposE5A := "{{'E5_PRETPIS' , '2'}"
																cCamposE5A += ",{'E5_PRETCOF' , '2'}"
																cCamposE5A += ",{'E5_PRETCSL' , '2'}}"

																oModelBxPA:SetValue( "MASTER", "E5_CAMPOS", cCamposE5A )
																//Grava os dados
																If oModelBxPA:VldData()
																	oModelBxPA:CommitData()
																	oModelBxPA:DeActivate()
																Else
																	lRet := .F.
																	cLog := cValToChar(oModelBxPA:GetErrorMessage()[4]) + ' - '
																	cLog += cValToChar(oModelBxPA:GetErrorMessage()[5]) + ' - '
																	cLog += cValToChar(oModelBxPA:GetErrorMessage()[6])
																	Help( ,,"M020VLDI1",,cLog, 1, 0 )
																	Exit
																Endif

																RestArea(aAreaAnt)
																dbSelectArea("SFQ")

																If Empty( _cFilFwSFQ )    //Multi-Filial
																	cMFilial := xFilial("SFQ")
																Else
																	If Empty( _cFilFwSE2 )
																		cMFilial := xFilial("SFQ")
																	Else
																		cMFilial := SE2->E2_FILIAL
																	EndIf
																EndIf

																RecLock("SFQ",.T.)
																SFQ->FQ_FILIAL  := cMFilial
																SFQ->FQ_ENTORI  := "SE5"
																SFQ->FQ_PREFORI := cPrefOri
																SFQ->FQ_NUMORI  := cNumOri
																SFQ->FQ_PARCORI := cParcOri
																SFQ->FQ_TIPOORI := cTipoOri
																SFQ->FQ_CFORI   := cCfOri
																SFQ->FQ_LOJAORI := cLojaOri
																SFQ->FQ_SEQORI  := cSequencia
																SFQ->FQ_ENTDES  := "SE5"
																SFQ->FQ_PREFDES := SE5->E5_PREFIXO
																SFQ->FQ_NUMDES  := SE5->E5_NUMERO
																SFQ->FQ_PARCDES := SE5->E5_PARCELA
																SFQ->FQ_TIPODES := SE5->E5_TIPO
																SFQ->FQ_CFDES   := SE5->E5_CLIFOR
																SFQ->FQ_LOJADES := SE5->E5_LOJA
																SFQ->FQ_SEQDES  := SE5->E5_SEQ
																MsUnlock()
															Next nLoop
														Endif
													ElseIf !_lIrfMR .AND. lIRPFBaixa .AND. nIrrf > 0 .and. (SA2->A2_TIPO == "F" .OR. (SA2->A2_TIPO == "J" .AND. lIRProg == "1")) .AND. ;
														aDadosRet[1] + (nValPgto+nPis+nCofins+nCsll+nIrrf+nDescont+nTotAbat-nJuros-nMulta-nVA) > MaTbIrfPF(nIrrf)[4]
														lRetParc := .T.

														//Rotina para gerar titulo de adiantamento
														If cNCCRet == "1" .and. nDiferImp < 0
															FGerCredRt(Abs(nDiferImp),SE2->E2_MOEDA,SE5->E5_SEQ)
														Endif

														nSavRec := SE5->( Recno() )
														//Exclui a Marca de "pendente recolhimento" dos demais registros
														If aDadosRet[1] > 0
															aRecnos := aClone( aDadosRet[ 6 ] )
															cPrefOri  := SE5->E5_PREFIXO
															cNumOri   := SE5->E5_NUMERO
															cParcOri  := SE5->E5_PARCELA
															cTipoOri  := SE5->E5_TIPO
															cCfOri    := SE5->E5_CLIFOR
															cLojaOri  := SE5->E5_LOJA

															For nLoop := 1 to Len( aRecnos )
																SE5->( dbGoto( aRecnos[ nLoop ] ) )
																//Atualiza a informação de retencao de impostos em outro titulo
																aAreaAnt := GetArea()
																oModelBxPA := FWLoadModel("FINM020")
																oModelBxPA:SetOperation( 4 ) //Alteração
																oModelBxPA:Activate()
																oModelBxPA:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
																oSubFKAA := oModelBxPA:GetModel( "FKADETAIL" )
																oSubFKAA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )

																//Atualizar o status de retencao de impostos
																oSubFK3A:= oModelBxPA:GetModel( "FK3DETAIL" )

																For nX := 1 to Len(aImpostos)
																	If oSubFK3A:SeekLine({{"FK3_IMPOS",aImpostos[nX,1]}})		//Nome do imposto
																		oSubFK3A:SetValue( "FK3_IDRET",aImpostos[nX,4] )		//cIdFk4
																	Endif
																Next

																cCamposE5A := "{{'E5_PRETPIS' , '1'}"
																cCamposE5A += ",{'E5_PRETCOF' , '1'}"
																cCamposE5A += ",{'E5_PRETCSL' , '1'}"
																cCamposE5A += ",{'E5_PRETIRF' , '3'}}"

																oModelBxPA:SetValue( "MASTER", "E5_CAMPOS", cCamposE5A )

																//Grava os dados
																If oModelBxPA:VldData()
																	oModelBxPA:CommitData()
																	oModelBxPA:DeActivate()
																Else
																	lRet := .F.
																	cLog := cValToChar(oModelBxPA:GetErrorMessage()[4]) + ' - '
																	cLog += cValToChar(oModelBxPA:GetErrorMessage()[5]) + ' - '
																	cLog += cValToChar(oModelBxPA:GetErrorMessage()[6])
																	Help( ,,"M020VLDI1",,cLog, 1, 0 )
																	Exit
																Endif

																RestArea(aAreaAnt)
																dbSelectArea("SFQ")

																If Empty( _cFilFwSFQ )   //Multi-Filial
																	cMFilial := xFilial("SFQ")
																Else
																	If Empty( _cFilFwSE2 )
																		cMFilial := xFilial("SFQ")
																	Else
																		cMFilial := SE2->E2_FILIAL
																	EndIf
																EndIf

																RecLock("SFQ",.T.)
																SFQ->FQ_FILIAL  := cMFilial
																SFQ->FQ_ENTORI  := "SE5"
																SFQ->FQ_PREFORI := cPrefOri
																SFQ->FQ_NUMORI  := cNumOri
																SFQ->FQ_PARCORI := cParcOri
																SFQ->FQ_TIPOORI := cTipoOri
																SFQ->FQ_CFORI   := cCfOri
																SFQ->FQ_LOJAORI := cLojaOri
																SFQ->FQ_SEQORI  := cSequencia
																SFQ->FQ_ENTDES  := "SE5"
																SFQ->FQ_PREFDES := SE5->E5_PREFIXO
																SFQ->FQ_NUMDES  := SE5->E5_NUMERO
																SFQ->FQ_PARCDES := SE5->E5_PARCELA
																SFQ->FQ_TIPODES := SE5->E5_TIPO
																SFQ->FQ_CFDES   := SE5->E5_CLIFOR
																SFQ->FQ_LOJADES := SE5->E5_LOJA
																SFQ->FQ_SEQDES  := SE5->E5_SEQ
																MsUnlock()
															Next nLoop
														Endif

														//Atualiza a informação de retencao de impostos no titulo que está sendo baixado
														If !_lPccMR
															cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nVlRetPis)+"}"
															cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nVlRetCof)+"}"
															cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nVlRetCsl)+"}"
															cCamposE5 += ",{'E5_PRETPIS' , '1'}"
															cCamposE5 += ",{'E5_PRETCOF' , '1'}"
															cCamposE5 += ",{'E5_PRETCSL' , '1'}"
														EndIf
													Else
														If !_lPccMR .And. (nVlRetPis+nVlRetCof+nVlRetCsl+nVlRetIrf) > 0
															cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nVlRetPis)+"}"
															cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nVlRetCof)+"}"
															cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nVlRetCsl)+"}"
															cCamposE5 += ",{'E5_PRETPIS' , '1'}"
															cCamposE5 += ",{'E5_PRETCOF' , '1'}"
															cCamposE5 += ",{'E5_PRETCSL' , '1'}"
														EndIf

														lRetParc := .F.
													EndIf
												ElseIf cModRetPIS == "2"
													//Efetua a retencao
													//Exclui a Marca de "pendente recolhimento" dos demais registros
													If aDadosRet[1] > 0
														aRecnos := aClone( aDadosRet [ 6 ] )
														cPrefOri  := SE2->E2_PREFIXO
														cNumOri   := SE2->E2_NUM
														cParcOri  := SE2->E2_PARCELA
														cTipoOri  := SE2->E2_TIPO
														cCfOri    := SE2->E2_FORNECE
														cLojaOri  := SE2->E2_LOJA

														For nLoop := 1 to Len( aRecnos )
															SE5->( dbGoto( aRecnos[ nLoop ] ) )

															If !Empty(SE5->E5_PRETPIS) .And. !Empty(SE5->E5_PRETCOF) .And. !Empty(SE5->E5_PRETCSL)
																//Atualiza a informação de retencao de impostos em outro titulo
																//Carrego o Model
																aAreaAnt := GetArea()
																oModelBxPA := FWLoadModel("FINM020")
																oModelBxPA:SetOperation( 4 ) //Alteração
																oModelBxPA:Activate()
																oModelBxPA:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
																oSubFKAA := oModelBxPA:GetModel( "FKADETAIL" )
																oSubFKAA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )

																//Atualizar o status de retencao de impostos
																oSubFK3A:= oModelBxPA:GetModel( "FK3DETAIL" )

																For nX := 1 to Len(aImpostos)
																	If oSubFK3A:SeekLine({{"FK3_IMPOS",aImpostos[nX,1]}})		//Nome do imposto
																		If aImpostos[nX,1] != "IRF"
																			oSubFK3A:SetValue( "FK3_IDRET",aImpostos[nX,4] )		//cIdFk4
																		Endif
																	Endif
																Next

																cCamposE5A += "{{'E5_PRETPIS' , '2'}"
																cCamposE5A += ",{'E5_PRETCOF' , '2'}"
																cCamposE5A += ",{'E5_PRETCSL' , '2'}}"

																oModelBxPA:SetValue( "MASTER", "E5_CAMPOS", cCamposE5A )

																//Grava os dados
																If oModelBxPA:VldData()
																	oModelBxPA:CommitData()
																	oModelBxPA:DeActivate()
																Else
																	lRet := .F.
																	cLog := cValToChar(oModelBxPA:GetErrorMessage()[4]) + ' - '
																	cLog += cValToChar(oModelBxPA:GetErrorMessage()[5]) + ' - '
																	cLog += cValToChar(oModelBxPA:GetErrorMessage()[6])
																	Help( ,,"M020VLDI1",,cLog, 1, 0 )
																	Exit
																Endif

																RestArea(aAreaAnt)
															EndIf

															dbSelectArea("SFQ")

															If Empty( _cFilFwSFQ )   //Multi-Filial
																cMFilial := xFilial("SFQ")
															Else
																If Empty( _cFilFwSE2 )
																	cMFilial := xFilial("SFQ")
																Else
																	cMFilial := SE2->E2_FILIAL
																EndIf
															EndIf

															RecLock("SFQ",.T.)
															SFQ->FQ_FILIAL  := cMFilial
															SFQ->FQ_ENTORI  := "SE5"
															SFQ->FQ_PREFORI := cPrefOri
															SFQ->FQ_NUMORI  := cNumOri
															SFQ->FQ_PARCORI := cParcOri
															SFQ->FQ_TIPOORI := cTipoOri
															SFQ->FQ_CFORI   := cCfOri
															SFQ->FQ_LOJAORI := cLojaOri
															SFQ->FQ_SEQORI  := cSequencia
															SFQ->FQ_ENTDES  := "SE5"
															SFQ->FQ_PREFDES := SE5->E5_PREFIXO
															SFQ->FQ_NUMDES  := SE5->E5_NUMERO
															SFQ->FQ_PARCDES := SE5->E5_PARCELA
															SFQ->FQ_TIPODES := SE5->E5_TIPO
															SFQ->FQ_CFDES   := SE5->E5_CLIFOR
															SFQ->FQ_LOJADES := SE5->E5_LOJA
															SFQ->FQ_SEQDES  := SE5->E5_SEQ
															MsUnlock()
														Next nLoop
													Endif
												ElseIf cModRetPIS == "3"
													//Grava a Marca de "pendente recolhimento" dos demais registros
													If !_lPccMR .And. (nVlRetPis+nVlRetCof+nVlRetCsl) > 0
														//Atualiza a informação de retencao de impostos no titulo que está sendo baixado
														cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nVlRetPis)+"}"
														cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nVlRetCof)+"}"
														cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nVlRetCsl)+"}"
														cCamposE5 += ",{'E5_PRETPIS' , '1'}"
														cCamposE5 += ",{'E5_PRETCOF' , '1'}"
														cCamposE5 += ",{'E5_PRETCSL' , '1'}"
													EndIf

													lRetParc := .F.
												Endif
											EndIf

											//Gravo os titulos de impostos Pis Cofins Csll quando controlados pela baixa
											If ((lPccBaixa .and.	lRetParc) .OR. lIRPFBaixa .OR. lCalcIssBx) .And. !lIsTitPA
												If !(lIRPFBaixa) .OR. (nTipoBx != 1 .AND. !EMPTY(SE2->E2_NUMBOR))
													nIrrf := 0
												EndIf

												If !(lCalcIssBx) .OR. (nTipoBx != 1 .AND. !EMPTY(SE2->E2_NUMBOR) .AND. !lBordero)
													nIss := 0
												EndIf

												//Gravacao dos impostos PCC
												If !(lRet := FGrvImpPcc(@nPis,@nCofins,@nCsll,nRegSE2,.F.,lRetParc,cSequencia,"FINA091",SE2->E2_MOEDA,,nIrrf,nIss,,,,_lPccMR,_lIrfMR,_lInsMR,_lIssMR,_lCidMR,_lSesMR,IIF(__oRatIRF <> Nil,__oRatIRF:aRatIRF,Nil)))
													lContinua := .F.
													DisarmTransaction()
													Break
												EndIf
											Endif
										Endif

										If cTpDoc $ "VL|PA"	//Se movimenta banco
											//Relacionamento FKA X FK5
											If !oSubFKA:IsEmpty()
												oSubFKA:AddLine()
												oSubFKA:GoLine( oSubFKA:Length() )
											Endif

											oSubFKA:SetValue( 'FKA_IDORIG', FWUUIDV4() )
											oSubFKA:SetValue( 'FKA_TABORI', "FK5" )

											//MOVIMENTO BANCARIO
											oSubFK5:SetValue( "FK5_RECPAG" , cRecPag )
											oSubFK5:SetValue( "FK5_HISTOR" , If(!Empty(cHistor090) .and. !(lIsTitPA .and. lGerPAMov) ,cHistor090,cHistMov) )
											oSubFK5:SetValue( "FK5_DATA"   , dDataSE5 )
											oSubFK5:SetValue( "FK5_DTDISP" , dDataSE5 )
											oSubFK5:SetValue( "FK5_NATURE" , SE2->E2_NATUREZ )
											oSubFK5:SetValue( "FK5_BANCO"  , cBanco )
											oSubFK5:SetValue( "FK5_AGENCI" , cAgencia )
											oSubFK5:SetValue( "FK5_CONTA"  , cConta )
											oSubFK5:SetValue( "FK5_NUMCH"  , If(!lIsTitPA,cCheque,"") )	
											oSubFK5:SetValue( "FK5_SEQ"    , cSequencia )
											oSubFK5:SetValue( "FK5_MOEDA"  , StrZero(nMoedaBco,2) )
											oSubFK5:SetValue( "FK5_VALOR"  , nValorSE5 )
											oSubFK5:SetValue( "FK5_VLMOE2" , xMoeda(nValorSE5,nMoedaBco,SE2->E2_MOEDA,SE2->E2_BAIXA,,,nTxMoedBx) )
											oSubFK5:SetValue( "FK5_ORIGEM" , FunName() )
											oSubFK5:SetValue( "FK5_TPDOC"  , cTpDoc )
											oSubFK5:SetValue( "FK5_CCUSTO" , SE2->E2_CCUSTO )
											oSubFK5:SetValue( "FK5_FILORI" , SE2->E2_FILORIG )
											oSubFK5:SetValue( "FK5_TXMOED" , nTxMoedBx )
											oSubFK5:SetValue( "FK5_MOEDA"  , StrZero(nMoedaBco,2) )
											oSubFK5:SetValue( "FK5_LA"     , If( lPadrao .and. mv_par04 == 1 .and. !lUsaFlag, "S", "N" ) )
											oSubFK5:SetValue( "FK5_LOTE"   , cLoteFin )
											oSubFK5:SetValue( "FK5_IDDOC"  , If(lIsTitPA,cChaveFK7,"") )		
											oSubFK5:SetValue( "FK5_MODSPB" , If(lSpbInUse, cModSpb, "" ) )

											If lGerPaMov
												cCamposE5 += ",{'E5_MOTBX'  , '"+ If(Empty(cMotBx),"NOR", TrazCodMot( cMotBx )) +"'}"
											EndIf

										Else
											cCamposE5 += ",{'E5_BANCO'   , '"+cBanco   +"' }"
											cCamposE5 += ",{'E5_AGENCIA' , '"+cAgencia +"' }"
											cCamposE5 += ",{'E5_CONTA'   , '"+cConta   +"' }"
											cCamposE5 += ",{'E5_NUMCHEQ' , '"+cCheque  +"' }"
											cCamposE5 += ",{'E5_DTDISPO' , STOD('" + DTOS(dDebito) + "')}"
										Endif
									Else//Valores acessorios
										If	oSubFKA:SeekLine({{'FKA_TABORI',"FK2"}})
											If cTpDoc == "VA" .and. nVA != 0
												// Grava novos valores acessórios (FKD)
												FSetFK6FKD(oSubFK6, cChaveFK7, cIdFK2)
											Else
												If !oSubFK6:IsEmpty()
													oSubFK6:AddLine()
													oSubFK6:GoLine( oSubFK6:Length() )
												Endif

												//Grava Valores acessórios (juros, multas, descontos etc)
												oSubFK6:SetValue( "FK6_VALMOV" , nCpoTp )
												oSubFK6:SetValue( "FK6_VALCAL" , nCpoCalc )
												oSubFK6:SetValue( "FK6_TPDESC" , cTpDesc )
												oSubFK6:SetValue( "FK6_TPDOC"  , cTpDoc )
												oSubFK6:SetValue( "FK6_RECPAG" , cRecPag )
												oSubFK6:SetValue( "FK6_IDORIG" , cIdFK2 )
												oSubFK6:SetValue( "FK6_TABORI" , "FK2" )
												oSubFK6:SetValue( "FK6_HISTOR" , cHistMov )
											Endif
										EndIf
									Endif

									If !Empty(cCamposE5)
										cCamposE5 += "}"
									Endif
								Endif
							Next nZ

							//COMITAR MODEL
							//Encerro a gravacao da Baixa (oModelBxP)
							If lRet
								FWModelActive(oModelBxP)
								oModelBxP:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )

								//Grava os dados
								If oModelBxP:VldData()
									oModelBxP:CommitData()

									//Obtenho o recno do SE5 - Movimento principal (VL/BA)
									nRegPrinc := oModelBxP:GetValue("MASTER","E5_RECNO")
									SE5->(dbGoTo(nRegPrinc))
									AADD(aSE5Baixado,nRegPrinc)

									If !lBaixaPA .And. lGerPAMov
										AADD(aSE2Pagant,SE2->(RECNO()))
									Endif

									If lNewProc
										cE5TABORI := SE5->E5_TABORI
										cE5IDORIG := SE5->E5_IDORIG
									EndIf

									//Grava o lançamento de integração com o SIGAPCO
									PcoDetLan("000024", "01", "FINA091")

									If lF90Se5Grv
										ExecBlock("F90SE5GRV")
									Endif

									//Atualiza o saldo bancario quando movimento bancario gerado baixa a baixa
									If lAtuSldBco .and. SE5->E5_TIPODOC $ "VL;PA"
										AtuSalBco(cBanco,cAgencia,cConta,dDataSE5,nValorSE5,If(SE5->E5_RECPAG == 'P','-','+'))
									Endif

									// Integração SIGAPFS x SIGAFIN
									If lRet .And. lJGrvBxPag
										lRet := JGrvBxPag(SE2->(RECNO()), 3, SE5->(RECNO()))
										If !lRet
											DisarmTransaction()
											Break
										EndIf
									EndIf

									oModelBxP:DeActivate()
									oModelBxP:Destroy()
									oModelBxP := Nil
									FinSetAPrc("")
								Else
									lRet := .F.
									cLog := cValToChar(oModelBxP:GetErrorMessage()[4]) + ' - '
									cLog += cValToChar(oModelBxP:GetErrorMessage()[5]) + ' - '
									cLog += cValToChar(oModelBxP:GetErrorMessage()[6])

									Help( ,,"M020VLDI5",,cLog, 1, 0 )
									DisarmTransaction()
									Break
								Endif
							Else
								DisarmTransaction()
								Break
							Endif

							//Gravação FK3/FK4 dos impostos via conf Motor Retenção
							If _lTemMR .And. lRet .And. !lGerPAMov
								If lIsTitPA
									FMRDelImp(cE5TABORI, cE5IDORIG)
								ElseIf Len(_aImpMR) > 0
									FinGrvImp("1"/*Carteira Pagar*/, SE2->(Recno()),_aImpMR,"FINA091",.F., {}, {},.F.,.F.,.T.,dBaixa,"FK2",,,SE2->E2_FILORIG)
								EndIf
							EndIf

							//Caso a retenção ocorreu na inclusão do pagamento antecipado efetua a exclusão dos títulos de impostos
							If !_lIrfMR .And. lIsTitPA .And. !lGerPAMov .and. SE2->E2_IRRF > 0
								F241DelTxIR("FINA080",SE2->(Recno()),SE2->E2_IRRF)
							EndIf

							If (lContrRet .and. lIsTitPA .And. (SE2->(E2_PIS + E2_COFINS + E2_CSLL) > 0 .Or. SE2->E2_ISS > 0))
								//posicionar na SE5 gerada na inclusao da PA
								lPAMov := .F.

								//verifica se PA possui movimentacao bancaria
								nRecPAInc := F080MovPA(.T.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)

								If  nRecPAInc > 0
									SE5->(DBGoto(nRecPAInc))
									lPAMov := .T.
								EndIf

								//verifica se PA possui registro de inclusao
								nRecPAInc := F080MovPA(.F.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)

								If	nRecPAInc > 0
									SE5->(DBGoto(nRecPAInc))
									lPAMov := .T.
								EndIf

								If lPAMov .And. !lGerPAMov
									aRecSE5 := FImpDelTit("SE5",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)
									nRecSe5 := SE5->(Recno())

									If !_lPccMR
										For nY := 1 to Len(aRecSE5)
											SE5->(MSGoto(aRecSE5[nY]))
											RecLock("SE5",.F.)

											//Se nao reteve somente IRRF
											If (!Empty(SE5->E5_PRETPIS) .And. !Empty(SE5->E5_PRETCOF) .And. !Empty(SE5->E5_PRETCSL)) .and. SE5->E5_MOTBX<>"CMP"
												SE5->E5_PRETPIS := "1"
												SE5->E5_PRETCOF := "1"
												SE5->E5_PRETCSL := "1"
											Endif

											MsUnlock()
										Next nY
									EndIf

									//Exclui os registros de relacionamentos do SFQ
									SE5->(dbGoto(nRecSe5))
									FImpDelSFQ("SE5",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)
									aRecSE2 := FImpExcTit("SE2",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA)

									For nY := 1 to Len(aRecSE2)
										SE2->(MSGoto(aRecSE2[nY]))
										FaAvalSE2(4)
									Next

									//Exclui os registros de relacionamentos do SFQ
									SE5->(dbGoto(nRecSe5))
									FImpExcSFQ("SE2",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA)
									FDelTxBx(SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ,SE2->E2_PARCPIS,SE2->E2_PARCCOF,SE2->E2_PARCSLL)

									IF IsIssBx("P") .And. EMPTY(SE2->E2_NUMBOR) .And. SE2->E2_VRETISS != 0
										//Apaga tambem os registro de impostos-ISS
										SE5->(dbGoto(nRecSe5))
										SE2->(dbGoTo(nRecSE2))

										dbSelectArea("SE2")
										dbSetOrder(17)

										cChavePai := SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
										cChavePai := PadR(cChavePai, nTamTitPai)

										If MsSeek(xFilial("SE2") + cChavePai)

											cNatIss	:= AllTrim(&(GetMv("MV_ISS")))
				
											While !Eof() .And. E2_FILIAL+E2_TITPAI == xFilial("SE2") + cChavePai
												IF E2_TIPO $ MVISS .And. ;
													AllTrim(E2_NATUREZ) == cNatIss .And. ;
													STR(SE2->E2_SALDO,17,2) == STR(SE2->E2_VALOR,17,2) .and. ;
													(AllTrim(SE2->E2_ORIGEM) $ "FINA050|FINA080|FINA090|FINA091") .and. ;
													SE5->E5_SEQ == SE2->E2_SEQBX //.And. AllTrim(SE2->E2_TITPAI) == AllTrim(cChavePai)

													If lExistFJU
														FinGrvEx("P")
													Endif

													RecLock( "SE2" ,.F.,.T.)
													dbDelete( )
												EndIf

												dbSkip()
											Enddo
										Endif
									EndIf
									SE5->(dbGoto(nRecSe5))
									SE2->(dbGoTo(nSalvRec))
									/*
									Projeto FKs
									-------------------------------------------------------------
										Este trecho foi comentado conforme acordado com o Nagy
										Este tipo de movimento era gerado na emissão de um PA sem movimento mas foi descontinuado desde 2018, não tendo assim que ser convertido
											nos ajustes de gravação das FKs.
										Foi mantido no código apenas para que, caso exista algum cliente com esta situação, possa ser revertido facilmente.

									If !_lPccMR .And. SE5->E5_TIPODOC = "BA" .And. SE5->E5_MOTBX = "PCC"
										RecLock("SE5",.F.)
										SE5->E5_SITUACA := "C"

										If SE5->( ColumnPos( "E5_DTCANBX" ) ) > 0
											SE5->E5_DTCANBX := dDataBase
										EndIf

										SE5->(MsUnlock())
									EndIf
									--------------------------------------------------------------
									*/

								EndIf
							Endif

							If lStartCTB .And. lPadrao .And. MV_PAR04 == 1
								nHdlPrv := HeadProva(cLote, "FINA091" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo )
								lStartCTB := .F.
							Endif

							//Se existe lancto padrao e se contabiliza online e
							//[Se Baixa Borderos e totaliza geral (nao totaliza bordero a bordero) ou Se baixa titulos sem bordero]
							If	lPadrao .And. mv_par04 == 1 .And. !(nTipoBx = 2 .And. mv_par05 == 2 .And. !lGerPAMov)
								dbSelectArea( "SE5" )
								dbGoTo( nRegPrinc )
								SED->(dbSeek(xFilial("SED",SE5->E5_FILORIG)+SE5->E5_NATUREZ))

								//Prepara Lancamento Contabil
								If lUsaFlag // Armazena em aFlagCTB para atualizar no modulo Contabil
									aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
									If lGerPaMov
										aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
									EndIf
								Endif

								//Prepara Totalizador LP 530 - Quando selecionado Baixa por Títulos (nTipoBx == 1)
								If cPadrao == '530' .AND. ((nTotal + SE5->E5_VALOR) == nValor)
									VALOR := (nTotal + SE5->E5_VALOR)
								EndIf

								nTotal += DetProva(nHdlPrv, ;
											cPadrao, ;
											"FINA091" /*cPrograma*/, ;
											cLote, ;
											/*nLinha*/, ;
											/*lExecuta*/, ;
											/*cCriterio*/, ;
											/*lRateio*/, ;
											/*cChave*/, ;
											/*aCT5*/, ;
											/*lPosiciona*/, ;
											@aFlagCTB, ;
											/*aTabRecOri*/, ;
											/*aDadosProva*/ )
							EndIf

							//Atualiza o Cadastro de Fornecedores
							dbSelectArea("SA2")

							If Empty( _cFilFwSA2 )    //Multi-Filial
								cMFilial := xFilial("SA2")
							Else
								If Empty( _cFilFwSE2 )
									cMFilial := xFilial("SA2")
								Else
									cMFilial := SE2->E2_FILIAL
								EndIf
							EndIf

							If !dbSeek(cMFilial+SE2->E2_FORNECE+SE2->E2_LOJA) .And. !Empty(xFilial("SA2"))
								//executará quando o forn estiver em filial diferente
								lAchou := dbSeek(xFilial("SA2", SE2->E2_FILORIG)+SE2->E2_FORNECE+SE2->E2_LOJA)
							EndIf

							If lAchou .and. lAtuForn
								RecLock("SA2")
								nSalDup := xMoeda(Round(nSaldo-nTotAbtF,2),SE2->E2_MOEDA,nMoedaBco,SE2->E2_EMISSAO,_nTamMD2,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0))
								SA2->A2_SALDUP -= nSalDup
								SA2->A2_SALDUPM -= xMoeda(Round(nSaldo-nTotAbtF,2),SE2->E2_MOEDA, nMV_MCUSTO ,SE2->E2_EMISSAO,_nTamMD2,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0))
								MsUnlock()
							Endif

							SA6->(DbSetOrder(1))
							SA6->(DbSeek(xFilial()+cBco090+cAge090+cCta090))

							//Baixa por bordero e totalizacao bordero a bordero
							If lPadrao .and. mv_par04==1 .and. nTipoBX == 2 .and. mv_par05 == 2 .and. !lGerPAMov
								//Armazena recno do fornecedor e banco atual para posterior utilizacao na contabilizacao Bordero/Bordero (mv_par05 igual a 2)
								AAdd( aRegCtBor, { SE2->(Recno()), SA2->(Recno()), SA6->(Recno()) , F090RcSE5(aSE5Baixado) } )
							EndIf

							dbSelectArea("SE2")

							If lFina090
								Execblock("FINA090",.f.,.f.)
							Endif

							// Integração EAI.
							If __lEAIF080
								llOpc  := ALTERA
								ALTERA := .T.  // Baixa de título.

								aEaiRet := FWIntegDef('FINA080',,,, 'FINA080')
								If !aEaiRet[1]
									Help(" ", 1, "HELP", STR0174, STR0175 + CRLF + aEaiRet[2], 3, 1)  // "Erro EAI" / "Problemas na integração EAI. Transação não executada."
									DisarmTransaction()
									Break
								Endif

								ALTERA := llOpc
							Endif

							//Envio de e-mail pela rotina de checklist de documentos obrigatorios
							IF lFinVDoc
								CN062ValDocs("03",.F.,.T.)
							EndIf
						EndIf
					Endif


					(cAliasSE2)->(dbGoTo(nProxReg))
					SE2->(dbGoto((cAliasSE2)->NUM_REG))

					//	Define data da contabilização on line
					Do Case 
						Case nDtContOn == 1 // 1- Data Digitação
							dDtLanc := dDtDigit
						Case nDtContOn == 2 // 2- Data Disponibilizadade
							dDtLanc := dDebito
						Case nDtContOn == 3 // 3- Data Pagamento
							dDtLanc := dBaixa
					EndCase

					If nHdlPrv > 0 .And. nTotal > 0 .And. mv_par04 == 1 .and. (cFilAnt <> SE2->E2_FILORIG .OR. cBordAnt <> SE2->E2_NUMBOR)
						//Efetiva Lancamento Contabil
						cA100Incl(cArquivo,;
									nHdlPrv,;
									/*nOpcx*/,;
									cLote,;
									mv_par02 == 1 /*Mostra Lancamento*/,;
									mv_par03 == 1 /*Aglutina Lancamento*/,;
									/*cOnLine*/,;
									dDtLanc,;
							 		/*dReproc*/,;
									 @aFlagCTB,;
							  		/*aDadosProva*/,;
							   		aDiario   	)

						aFlagCTB 	:= {}  // Limpa o coteudo apos a efetivacao do lancamento
						nHdlPrv 	:= 0
						nTotal		:= 0
						aDiario		:= {}
						lStartCTB 	:= .T.

						//Flag de contabilizacao dos titulos de bordero
						If LanceiCTB .and. !lUsaFlag
							For nX := 1 To Len( aSE5Baixado )
								SE5->( DbGoto( aSE5Baixado[nX] ) )
								Reclock( "SE5" )
								SE5-> E5_LA	:=	"S" + Substr( E5_LA, 2, 1 )
								MsUnlock( )
							Next nX

							// Flag contabilizacao Movimento PA
							For nX := 1 to Len( aSE2Pagant )
								SE2->( DbGoto( aSE2Pagant[nX] ) )
								Reclock( "SE2" )
								SE2-> E2_LA	:=	"S"
								MsUnlock( )
							Next nX
						Endif
					EndIf

				Enddo

				cFilAnt := cFilBaixa

				If nGerPAMov > 0 // Verifico se houve a ocorrencia de PA sem Movimento bancario para acionar aviso ao usuario
					MsgAlert( STR0173 )	// "Durante o processo de baixa, foi verificada a existência de títulos de Pagamentos Antecipados sem movimento bancário. Para esses registros não foi alterado o saldo do título, mas apenas gerado o seu movimento bancário inicial."
					nGerPAMov := 0
				EndIf

				//Grava cheque totalizador no SEF e cheque no SE5
				If lCheque .and. !Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*" .and. lContinua .AND. nValorCheq > 0
					//Model de Movimento bancario
					oModelMov := FWLoadModel("FINM030")
					oModelMov:SetOperation( 3 ) //Inclusao
					oModelMov:Activate()
					oSubFK5M  := oModelMov:GetModel("FK5DETAIL")
					oSubFKAM  := oModelMov:GetModel("FKADETAIL" )

					//Informar o novo campo EF_IDSEF nas inclusões de SEF:
					If SubStr( SEF->EF_NUM,1,1 ) != "*" .and. cLiberado == "S"
						cChaveCH := FWUUIDV4()
					Endif

					Reclock("SEF",.T.)
					EF_FILIAL  := xFilial("SEF")
					EF_NUM     := cCheq090
					EF_BANCO   := cBco090
					EF_DATA    := dDataBase
					EF_AGENCIA := cAge090
					EF_CONTA   := cCta090
					EF_VALOR   := nValorCheq
					EF_BENEF   := cBenef090
					EF_LA      := If(mv_par04==1 .and. mv_par01==1 .and. lPadrao .and. !lUsaFlag .and. cCtBaixa$"BA","S"," ")
					EF_LIBER   := cLiberado
					EF_HIST    := IIF(AllTrim(cHistor090)="",STR0070,cHistor090) //"Cheque por Bx. Automatica"
					EF_ORIGEM  := "FINA091"
					EF_FILORIG := cFilAnt
					EF_FILCHQ  := cFilCorr
					EF_IDSEF   := cChaveCH		//ID do cheque
					MsUnlock()

					//-----------------------------------------------------------------------
					// Atualização da Movimentação Bancaria, somente se o cheque for efetivo 
					// (sem * na primeira posição).
					// Obs: Se o cheque foi criado por uma devolução de adiantamento não 
					// precisa movimentar o saldo, pois isto foi feito pela rotina de baixa 
					// de adiantamentos.
					// Também só atualiza a Movimentação bancária se o parametro MV_LIBCHEQ 
					// for "S", caso contrário a movimentação bancária só será atualizada 
					// na opção Conf.Cheque do prg Cheq s/ Titulos (FINA390).
					//-----------------------------------------------------------------------
					If SubStr( SEF->EF_NUM,1,1 ) != "*" .and. cLiberado == "S"
						//Dados do Cheque
						If !oSubFKAM:IsEmpty()
							oSubFKAM:AddLine()
							oSubFKAM:GoLine( oSubFKAM:Length() )
						Endif

						oSubFKAM:SetValue( 'FKA_IDORIG', cChaveCH )
						oSubFKAM:SetValue( 'FKA_TABORI', 'SEF' )

						// Inclui registro no SE5 para a geracao do cheque
						cCamposE5 := "{{'E5_DTDIGIT' , dDtDigit}"
						cCamposE5 += ",{'E5_BENEF'   , '"+StrTran(cBenef090,"'","")+"' } }"

						oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )
						oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
						oModelMov:SetValue( "MASTER", "NOVOPROC", .T. ) //Novo processo

						//Relacionamento FKA X FK5
						If !oSubFKAM:IsEmpty()
							oSubFKAM:AddLine()
							oSubFKAM:GoLine( oSubFKAM:Length() )
						Endif

						oSubFKAM:SetValue( 'FKA_IDORIG', FWUUIDV4() )
						oSubFKAM:SetValue( 'FKA_TABORI', "FK5" )
						oSubFK5M:SetValue( "FK5_BANCO"  , cBco090 )
						oSubFK5M:SetValue( "FK5_AGENCI" , cAge090 )
						oSubFK5M:SetValue( "FK5_CONTA"  , cCta090 )
						oSubFK5M:SetValue( "FK5_NUMCH"  , cCheq090 )
						oSubFK5M:SetValue( "FK5_VALOR"  , nValorCheq )
						oSubFK5M:SetValue( "FK5_RECPAG" , "P" )
						oSubFK5M:SetValue( "FK5_HISTOR" , IIF(AllTrim(cHistor090)<>"",cHistor090,STR0070)) //"Cheque por Bx. Automatica"
						oSubFK5M:SetValue( "FK5_DATA"   , dDataBase )
						oSubFK5M:SetValue( "FK5_DTDISP" , dDataBase )
						oSubFK5M:SetValue( "FK5_NATURE" , cNatur090 )
						oSubFK5M:SetValue( "FK5_ORIGEM" , FunName() )
						oSubFK5M:SetValue( "FK5_TPDOC"  , "CH" )
						oSubFK5M:SetValue( "FK5_CCUSTO" , SE2->E2_CCUSTO )
						oSubFK5M:SetValue( "FK5_FILORI" , cFilAnt )
						oSubFK5M:SetValue( "FK5_MOEDA"  , StrZero(nMoedaBco,2) )
						oSubFK5M:SetValue( "FK5_LA"     , Iif(mv_par01==1 .and. lPadrao .and. !lUsaFlag .and. cCtBaixa$"AC","S"," ") )
						oSubFK5M:SetValue( "FK5_LOTE"   , cLoteFin )

						If oModelMov:VldData()
							oModelMov:CommitData()
							nRecSE5 := oModelMov:GetValue("MASTER","E5_RECNO")
							SE5->(dbGoTo(nRecSE5))
							oModelMov:DeActivate()
						Else
							lRet := .F.
							cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
							cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
							cLog += cValToChar(oModelMov:GetErrorMessage()[6])
							Help( ,,"M020VLDI6",,cLog, 1, 0 )
						Endif

						// Atualização do Saldo Bancario
						If lAtuSldBco
							AtuSalBco( cBco090,cAge090,cCta090,SEF->EF_DATA,nValorCheq,"-" )
						Endif
					Endif
				Endif

				If lContinua
					//Finaliza processo de integracao com SIGAPCO
					PCOFinLan("000024")

					//vai para EOF() para contabilizar apenas o total
					dbSelectArea( "SE2" )
					dbGoBottom()
					dbSkip()

					If TrazCodMot(cMotBx) == "VEN" .And.;
						nTipoBx == 1 .And. lMV_BXAUTVE	// Se for baixa de titulos e o motivo for VENDOR, nao existir o paramatro MV_BXAUTVE ou existir e retornar retornar .T.

						// Cria titulo de vendor baseado no total baixado
						lVendor := Fa080Vdr(@aVendor, nValorTotal, Ctod(""))

						If lVendor
							lPadraoVd := VerPadrao( "518" ) .And. cCtBaixa $ "BA"
							Fa080GrVen(@cTitOrig,lPadraoVd,Iif(mv_par04==1,"S","N"),aVendor, "FINA091")
							nLen := Len(aTitBaixado)

							Begin Transaction
								For nX := 1 To nLen
									SE2->(DbGoto(aTitBaixado[nX][1]))

									If lPadraoVd .and. mv_par04 == 1
										If UsaSeqCor()
											AaDd(aDiario,{"SE5",SE5->(Recno()),cCodDiario,"E5_NODIA","E5_DIACTB"})
										EndIf

										//Prepara Lancamento Contabil
										If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
											aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
										Endif

										nTotal += DetProva(nHdlPrv, "518" /*cPadrao*/, "FINA091" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/, /*cCriterio*/, /*lRateio*/, /*cChaveBusca*/,;
											/*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/ )
									Endif

									Reclock("SE2")
									SE2->E2_TITORIG	:= cTitOrig
									MsUnlock()
								Next nX
							End Transaction
						Endif
					//Se existe LP 532, Se contabiliza online, Se baixa borderoes e Se totaliza por bordero
					ElseIf lPadAux .and. mv_par04 == 1 .and. nTipoBX == 2 .and. mv_par05 == 2 //Baixa por bordero e totalizacao bordero a bordero
						nLstRecSE5 := SE5->( RecNo() )
						nLen := Len(aTitBaixado)

						If nHdlPrv == 0
							//Inicializa Lancamento Contabil
							nHdlPrv := HeadProva( cLote, "FINA091" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo )
						Endif

						aSort(aTitBaixado,,,{|x,y| x[3]+x[2] < y[3]+y[2]})
						nValorTotal := 0

						For nX := 1 To nLen
							SE2->(DbGoto(aTitBaixado[nX,1]))
							SED->(DbSeek( xFilial('SED',SE2->E2_FILORIG) + SE2->E2_NATUREZ ))

							If lPadAux
								// Posiciona tabela de fornecedor e banco antes de chamar contabilizacao
								If Len(aRegCtBor) > 0
									nI := aScan( aRegCtBor, { |x| x[1] == aTitBaixado[nX,1] } )
									SA2->(dbGoTo(aRegCtBor[nI,2]))
									SA6->(dbGoTo(aRegCtBor[nI,3]))
								EndIf

								//Posiona na SE5
								If aRegCtBor[nI,4] <> 0
									SE5->(dbGoTo(aRegCtBor[nI,4]))
								Else
									SE5->(dbGoTo(nLstRecSE5))
								EndIf

								//Prepara Lancamento Contabil
								If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
									aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
								Endif

								nTotal += DetProva( nHdlPrv, "532", "FINA091" /*cPrograma*/, cLote, 0 /*nLinha*/, .T. /*lExecuta*/, "FINA091" /*cCriterio*/, /*lRateio*/, /*cChaveBusca*/,;
									/*aCT5*/, /*lPosiciona*/, @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/ )
								If UsaSeqCor()
									AaDd(aDiario,{"SE5",SE5->(Recno()),cCodDiario,"E5_NODIA","E5_DIACTB"})
								EndIf
							EndIF

							nValorTotal += SE2->E2_VALLIQ

							//Verifica se eh o mesmo bordero ou se eh o ultimo titulo
							If (nX+1 <= nLen .and. aTitBaixado[nX+1,3] != aTitBaixado[nX,3]) .or. (nX+1 > nLen)
								VALOR		:= nValorTotal
								VLRINSTR	:= nValorTotal 		// CONDICIONAL DA VARIAVEL VALOR
								VALOR2		:= 0				//TOTAL DOS ABATIMENTOS (por titulo)
								ABATIMENTO 	:= 0
								STRLCTPAD	:= aTitBaixado[nX,3]

								If lPadAux
									//vai para EOF() para contabilizar apenas o total
									nRecNoSE2 := SE2->( RecNo() )
									nRecNoSE5 := SE5->( RecNo() )
									nRecNoFK2 := FK2->( RecNo() )

									SE5->( dbGoTo(0) )
									SE2->( dbGoTo(0) )
									FK2->( DbGoto(0) )

									//Prepara Lancamento Contabil
									nTotal += DetProva( nHdlPrv, "532", "FINA091" /*cPrograma*/, cLote, 0 /*nLinha*/, .T. /*lExecuta*/, "FINA091" /*cCriterio*/, /*lRateio*/, /*cChaveBusca*/,;
										/*aCT5*/, /*lPosiciona*/, /*@aFlagCTB*/, /*aTabRecOri*/, /*aDadosProva*/ )

									//Restaura a posicao do arquivo
									SE2->( dbGoTo( nRecNoSE2 ) )
									SE5->( dbGoTo( nRecNoSE5 ) )
									FK2->( dbGoTo( nRecNoFK2 ) )

									If UsaSeqCor()
										AaDd(aDiario,{"SE5",SE5->(RecNo()),cCodDiario,"E5_NODIA","E5_DIACTB"})
									EndIf

								EndIF

								nValorTotal := 0
								VALOR		:= 0
								VLRINSTR	:= 0
								VALOR2		:= 0
								ABATIMENTO 	:= 0
								STRLCTPAD	:= "  "
							Endif
						Next nX

						VALOR := 0
						lTotPorBord := .T.
					Endif

					If !lTotPorBord .And. nTipoBX == 2

						If nHdlPrv == 0
							//Inicializa Lancamento Contabil
							nHdlPrv := HeadProva( cLote, "FINA091" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo )
						Endif

						//Zero as variáveis de impostos caso não gere movimento totalizador (MV_BXCNAB == S)
						If !lBxCnab
							FINVARCTB()
						Endif

						// Credito do Banco = Variavel VALOR
						VALOR		:= nValorTotal
						VLRINSTR	:= nValorTotal		// CONDICIONAL DA VARIAVEL VALOR
						Valor2		:= 0				// TOTAL DOS ABATIMENTOS (por titulo)
						ABATIMENTO	:= 0

						If	(cCtBaixa == "C" .And. lCheque .and. lMovBcoBx .And. MV_PAR01==1) .or. (cCtBaixa $"B|A") .or.;
							(TrazCodMot(cMotBx) $ "VEN/DEB") .or. (MovBcoBx(cMotBx, .T.) .and. !ChqMotBx(cMotBx))

							If lPadAux .and. mv_par04 == 1
								//vai para EOF() para contabilizar apenas o total
								nRecNoSE2 := SE2->( RecNo() )
								nRecNoSE5 := SE5->( RecNo() )
								nRecNoFK2 := FK2->( RecNo() )
								
								SE5->( dbGoTo(0) )
								SE2->( dbGoTo(0) )
								FK2->( DbGoto(0) )

								//Prepara Lancamento Contabil
								nTotal += DetProva(nHdlPrv, "532", "FINA091" /*cPrograma*/, cLote, 0 /*nLinha*/, .T. /*lExecuta*/, "FINA091" /*cCriterio*/, /*lRateio*/,;
									/*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/, /*@aFlagCTB*/, /*aTabRecOri*/, /*aDadosProva*/ )

								//Restaura a posicao do arquivo
								SE2->( dbGoTo( nRecNoSE2 ) ) 
								SE5->( dbGoTo( nRecNoSE5 ) )
								FK2->( dbGoTo( nRecNoFK2 ) )

								If UsaSeqCor()
									AaDd(aDiario,{"SE5",SE5->(Recno()),cCodDiario,"E5_NODIA","E5_DIACTB"})
								EndIf
							EndIF

							VALOR := 0

						EndIf
					Endif

					dbSelectArea( "SE2" )
				Endif

				//	Define data da contabilização on line
				Do Case 
					Case nDtContOn == 1 // 1- Data Digitação
						dDtLanc := dDtDigit
					Case nDtContOn == 2 // 2- Data Disponibilizadade
						dDtLanc := dDebito
					Case nDtContOn == 3 // 3- Data Pagamento
						dDtLanc := dBaixa
				EndCase

				If nHdlPrv > 0 .And. nTotal > 0 .And. mv_par04 == 1 
					//Efetiva Lancamento Contabil
					cA100Incl(cArquivo,;
								nHdlPrv,;
								/*nOpcx*/,;
								cLote,;
								mv_par02 == 1 /*Mostra Lancamento*/,;
								mv_par03 == 1 /*Aglutina Lancamento*/,;
								/*cOnLine*/,;
								dDtLanc,;
						 		/*dReproc*/,;
								 @aFlagCTB,;
						  		/*aDadosProva*/,;
						   		aDiario   	)
					
			
					//Flag de contabilizacao dos titulos de bordero
					If LanceiCTB .and. !lUsaFlag
						//Flag de contabilizacao dos titulos de bordero - BAIXAS
						For nX := 1 To Len( aSE5Baixado )
							SE5->( DbGoto( aSE5Baixado[nX] ) )
							Reclock( "SE5" )
							SE5-> E5_LA	:=	"S" + Substr( E5_LA, 2, 1 )
							MsUnlock( )
						Next nX
						// Flag contabilizacao Movimento PA
						For nX := 1 to Len( aSE2Pagant )
							SE2->( DbGoto( aSE2Pagant[nX] ) )
							Reclock( "SE2" )
							SE2-> E2_LA	:=	"S"
							MsUnlock( )
						Next nX
					Endif

					aFlagCTB 	:= {}  // Limpa o conteudo apos a efetivacao do lancamento
					nHdlPrv 	:= 0
					nTotal		:= 0
					aDiario		:= {}
					lStartCTB 	:= .T.

				EndIf				
			END TRANSACTION // Garante a transacao após a geração do titulo aglutinador
		EndIf
		Exit
	EndDo

	//Caso nao confirme a baixa ou confirme sem selecionar nenhum titulo/bordero, forca finalizacao do processo
	//de validacao de bloqueio (PcoVldLan) do SIGAPCO
	If nOpca # 1 .Or. (nOpca == 1 .And. nValor == 0) .and. lContinua
		PCOFinLan("000024")
	EndIf

	If __lSX8 .and. lContinua
		RollBackSX8()
	Endif

	// Grava no SE5 o número do último lote recebido e gera movimentacao bancaria.
	If nTotAger > 0 .and. lGerTotal .and. lContinua

		//Model de Movimento bancario
		oModelMov := FWLoadModel("FINM030")
		oModelMov:SetOperation( 3 ) //Inclusao
		oModelMov:Activate()
		oSubFK5M  := oModelMov:GetModel("FK5DETAIL")
		oSubFKAM  := oModelMov:GetModel("FKADETAIL" )

		oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
		oModelMov:SetValue( "MASTER", "NOVOPROC", .T. ) //Novo processo

		// Inclui registro no SE5 para a geracao do cheque
		cCamposE5 := "{"
		cCamposE5 += " {'E5_DTDIGIT' , dDtDigit}"
		cCamposE5 += ",{'E5_BENEF'   , '"+StrTran(cBenef090,"'","")+"' } "
		cCamposE5 += ",{'E5_LOTE'    , '"+cLoteFin +"' }}"

		//Dados do movimento bancario do Cheque
		If !oSubFKAM:IsEmpty()
			//Inclui a quantidade de linhas necessárias
			oSubFKAM:AddLine()
			//Vai para linha criada
			oSubFKAM:GoLine( oSubFKAM:Length() )
		Endif

		oSubFKAM:SetValue( 'FKA_IDORIG', FWUUIDV4() )
		oSubFKAM:SetValue( 'FKA_TABORI', 'FK5' )

		oSubFK5M:SetValue( "FK5_RECPAG" , "P" )
		oSubFK5M:SetValue( "FK5_HISTOR" , STR0062+ cLoteFin) //"Baixa Automatica / Lote : "
		oSubFK5M:SetValue( "FK5_DATA"   , dDataBase )
		oSubFK5M:SetValue( "FK5_DTDISP" , dDataBase )
		oSubFK5M:SetValue( "FK5_NATURE" , cNatur090 )
		oSubFK5M:SetValue( "FK5_BANCO"  , cBco090 )
		oSubFK5M:SetValue( "FK5_AGENCI" , cAge090 )
		oSubFK5M:SetValue( "FK5_CONTA"  , cCta090 )
		oSubFK5M:SetValue( "FK5_VALOR"  , nTotAger )
		oSubFK5M:SetValue( "FK5_ORIGEM" , FunName() )
		oSubFK5M:SetValue( "FK5_TPDOC"  , IF(!Empty(cLoteFin),"BL","VL") )
		oSubFK5M:SetValue( "FK5_CCUSTO" , SE2->E2_CCUSTO )
		oSubFK5M:SetValue( "FK5_FILORI" , cFilAnt )
		oSubFK5M:SetValue( "FK5_MOEDA"  , StrZero(nMoedaBco,2) )
		oSubFK5M:SetValue( "FK5_LA"     , Iif(mv_par04==1 .and. lPadrao .and. !lUsaFlag .and. cCtBaixa$"AC","S"," ") )
		oSubFK5M:SetValue( "FK5_LOTE"   , cLoteFin )

		If lSpbInUse
			oSubFK5M:SetValue( "FK5_MODSPB" , "1" )
		Endif

		oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )

		If oModelMov:VldData()
			oModelMov:CommitData()
			oModelMov:DeActivate()
		Else
			lRet := .F.
			cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
			cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
			cLog += cValToChar(oModelMov:GetErrorMessage()[6])

			Help( ,,"M020VLDI6",,cLog, 1, 0 )
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza saldo bancario.      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lAtuSldBco
			AtuSalBco(cBco090,cAge090,cCta090,SE5->E5_DATA,SE5->E5_VALOR,"-")
		Endif

		// Ponto de Entrada para manipular o registro totalizador da baixa automatica por lote
		If lF90TotGrv
			ExecBlock("F90TOTGRV")
		EndIf

	EndIf

	If lContinua

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Restaura os ¡ndices                                          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SE2")
		RetIndex("SE2")
		If cPaisLoc =="BRA"
			If !GetMv("MV_CTLIPAG")
				SE2->(dbSetOrder(3))	//"E2_FILIAL+DTOS(E2_VENCREA)+E2_NOMFOR+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO"
				SE2->(dbSeek( cFilial ))
				cKey1 := SE2->(INDEXKEY())
			Else
				SE2->(dbSetOrder(3))	//"E2_FILIAL+DTOS(E2_VENCREA)+E2_NOMFOR+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO"
				cFilter := "@E2_FILIAL = '"+xFilial("SE2")+"' AND (E2_DATALIB <> '        ' OR E2_SALDO+E2_SDACRES-E2_SDDECRE <= "+Alltrim(Str(GetMv('MV_VLMINPG'),15,7))+")"
				Set Filter to &cFilter
				SE2->(dbGotop())
			Endif
		Else
			Eval(bFilBrw)
			dbGoTo(nSalvRec)
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de entrada apos a restauracao dos indices.             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistBlock("F090REST")
			ExecBlock( "F090REST",.F.,.F.)
		EndIf

	Endif

	f091LRatIR(.T.) // Limpa objeto __oRatIRF IR Progressivo

	//Restaura Variaveis
	ddatabase := dBkdatabase
	dBaixa    := ddatabase

	cFilAnt := Iif( lConfirma == .T., cFilBaixa, cFilLogada )
Return (.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função	 ³fa091blank³ Autor ³ Wagner Xavier 		  ³ Data ³ 21/10/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³Limpa o campo E2_OK para efetuar marcação. 					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³fa091blank() 															  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³FINA090																	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fa091Blank()

	Reclock("SE2")
	Replace E2_OK with "  "
	MsUnlock()

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função	 ³fa091ChecF³ Autor ³ Adilson H. Yamaguchi  ³ Data ³ 21/03/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³Retorna Condição para Indice Condicional						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³fa091ChecF() 															  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Mauricio    ³18/11/97³11379A³ Tratamento E2_FILIAL na IndRegua         ³±±
±±³Marcos Cesar³07/08/98³SBPS  ³ Eliminacao dos Espacos em Branco         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Fa091ChecF(nTipoBx,cBord090I,cBord090F,aSelFil,aTMPFil,cBco090,cAge090,cCta090)
	Local cFiltro		:= ''
	Local lBxTxa		:= SuperGetMv("MV_BXTXA",.F.,"1") == "1"
	Local aFiluser		:= {}
	Local lF090Tipo		:= ExistBlock( "F090TIPO" )
	Local cTmpSE1Fil	:= ""

	DEFAULT aSelFil := {cFilAnt}
	DEFAULT aTMPFil := {}
	DEFAULT cBco090	:= ""
	DEFAULT cAge090	:= ""
	DEFAULT cCta090	:= ""

	//nTipoBx -> 1 = Baixa somente titulos que não estao em bordero
	//nTipoBx -> 2 = Baixa somente titulos em bordero

	aFiluser := FA091CKUS(aSelFil) //Pega somente as filiais que o usuario tem acesso

	//alteracao efetuada para possibilitar baixa Multi-Filial
	If !aFiluser[1] .And. Len(aFiluser[2]) > 0	// verifica se o usuario tem restrições de acesso a alguma filial
		cFiltro := "E2_FILIAL IN " + F91FORMATIN(Fa091MnFil(aFiluser[2]))
	else
		cFiltro += "E2_FILIAL " + GetRngFil( aSelFil, "SE2", .T., @cTmpSE1Fil )
		aAdd(aTMPFil, cTmpSE1Fil)
	endIf

	cFiltro += " AND E2_EMIS1 <= '"+DTOS(dDataBase)+"' and "
	cFiltro += "E2_PORTADO >= '"+cBcoDe  +"' and "
	cFiltro += "E2_PORTADO <= '"+cBcoAte +"' and "
	If nTipoBx == 1
		cFiltro += "E2_VENCREA >= '"+DTOS(dVencIni)+"' and "
		cFiltro += "E2_VENCREA <= '"+DTOS(dVencFim)+"' and "
		cFiltro += "E2_NUMBOR = '"+Space(TamSx3('E2_NUMBOR')[1]) +"' and "
	Endif
	If nTipoBx == 2
		cFiltro += "E2_NUMBOR >= '"+cBord090I      +"' and "
		cFiltro += "E2_NUMBOR <= '"+cBord090F      +"' and "
		cFiltro += "E2_NUMBOR <> '"+Space(TamSx3('E2_NUMBOR')[1]) +"' and "
	Endif
	/*Caso o !lBxTxa seja .T. por causa do parâmetro MV_BXTXA, será acrescentado no filtro a
	validação da flag E2_OK, para assim não exibir na janela de marcação um título do tipo TXA
	que já foi baixado, como solicitado no chamado TGACUL */
	If !lBxTxa
		cFiltro += " (E2_OK <> 'TA' ) AND "
	Endif

	cTipo := If(!Empty(MVPROVIS), MVPROVIS, '')
	cTipo += If(!Empty(MV_CPNEG),'/'+MV_CPNEG,'')
	cTipo += If(!Empty(MVABATIM),'/'+MVABATIM,'')
	cTipo += If(!Empty(MVENVBCOR),'/'+MVENVBCOR,'')

	If lF090Tipo
		cTipo := ExecBlock( 'F090TIPO' , .F. , .F. , { cTipo } )
	EndIf

	cFiltro += " E2_TIPO NOT IN " + F91FORMATIN( cTipo ) + " AND "

	// Para o Brasil, apresenta somente os titulos cuja moeda e' a mesma do banco selecionado para baixa.
	// Caso a moeda do banco estiver vazia ou caso o motivo de baixa nao movimente banco, considero apenas a moeda forte
	If FXMultSld() 
		If nMoedaBco > 1 .And. MovBcoBx(cMotBx,.T.)
			cFiltro  += " E2_MOEDA = " +  StrZero( nMoedaBco, 2 ) + " AND "
		Endif
	EndIf


	// Se trabalha com liberacao de pagto., filtra os registros que ultrapassem o valor minimo
	If lCtLIPag
		cFiltro  += " ( E2_DATALIB !=  '        '  OR (E2_SALDO+E2_SDACRES-E2_SDDECRE) <= " + Str(GetMV("MV_VLMINPG"),17,2) + ") AND "
	Endif

	cFiltro += " E2_SALDO > 0 AND "

	If SuperGetMV("MV_EASYFIN",,"N") == "S" .And. FindFunction("EasyFinOri")
		cFiltro += EasyFinOri()
	Else
		cFiltro += "E2_ORIGEM NOT IN ('SIGAEEC','SIGAEDC','SIGAECO','SIGAEFF','SIGAESS', 'SIGAEIC') "
	EndIf

	If FindFunction("EasyOrigem") .And. FindFunction("F050EasyOrig")
		cFiltro  += "AND E2_TIPO NOT IN ('PR','PRE') "
	EndIf

	// PONTO DE ENTRADA PARA ALTERACAO DO FILTRO
	If ExistBlock("F090FIL")
		cFiltro := ExecBlock("F090FIL",.f.,.f.,{nTipoBx,cBco090,cAge090,cCta090,cBord090I,cBord090F,cFiltro})
	Endif

	// Complemento de filtro do Documento Hábil - SIAFI
	cFiltro += FinTemDH(.T. /*lFiltro*/,/*cAlias*/,.F. /*lHelp*/, .F./*lTop*/)
Return cFiltro

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função	 ³fa091Corre³ Autor ³ Wagner Xavier 		  ³ Data ³ 04/03/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³Calcula a correção monet ria.										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³fa090Corr()																  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³Gen‚rico																	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fa091Correc(nMoedaBco)
	Local nCorrecao := 0
	Local nValAtual := 0
	Local nValEmiss := 0

	Default nMoedaBco := 1

	IF SE2->E2_MOEDA <> nMoedaBco
		//Caso seja a primeira apuracao de variacao monetaria
		If Empty(SE2->E2_TXMOEDA) .and. Empty(SE2->E2_DTVARIA)
			nValEmiss := SE2->E2_VLCRUZ
		Else
			If !Empty(SE2->E2_TXMDCOR)
				nValEmiss := xMoeda( SE2->E2_SALDO, SE2->E2_MOEDA, 1, IF(Empty(SE2->E2_DTVARIA),SE2->E2_EMISSAO,SE2->E2_DTVARIA),,SE2->E2_TXMDCOR )
			Else
				nValEmiss := xMoeda( SE2->E2_SALDO, SE2->E2_MOEDA, 1, If(Empty(SE2->E2_DTVARIA),SE2->E2_EMISSAO,SE2->E2_DTVARIA),,Iif(Empty(SE2->E2_DTVARIA),SE2->E2_TXMOEDA,0))
			EndIf
		End

		nValAtual := xMoeda( SE2->E2_SALDO, SE2->E2_MOEDA, 1, dDataBase,,SE2->E2_TXMOEDA )

		// Verifica atraves do parametro MV_CALCCM se sera calculada a correcao monetaria.
		// Caso o parametro nao exista, sera assumido "S"
		If GetNewPar("MV_CALCCM",'S') == "S"
			nCorrecao := nValAtual - nValEmiss
		Else
			nCorrecao := 0
		Endif
	Endif

Return nCorrecao

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função	 ³fA091Par	³ Autor ³ Adilson H. Yamaguchi  | Data ³ 04/05/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³Ativa Parƒmetros do Programa										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ 																			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Gen‚rico 																  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fA091Par()
	pergunte("FIN091",.T.)
Return .T.

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função	 ³Fa091Marca³ Autor ³ Alessandro B. Freire  ³ Data ³ 21/11/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Trata o valor	para marcar e desmarcar item					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ Fa091Marca(ExpN1,ExpD1,ExpD2) 									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA090																	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa091Marca(cAlias,cMarca)
	Local lBxTit	:= .T.
	Local nAbat		:= NIL
	Local nRec		:= NIL
	Local nVa       := 0
	Local cAliasAnt := Alias()
	Local lFinVDoc	:= IIF(GetNewPar("MV_FINVDOC","2")=="1",.T.,.F.)		//Controle de validacao de documentos obrigatorios
	Local lPrimeiro	:= .T.
	Local lRet		:= .T.
	Local lFA080	:= .T.
	Local nRecPA    := 0
	Local lMV_SOLNCP := SuperGetMv('MV_SOLNCP')

	If cPaisLoc <> "BRA"
		nVA :=  IIF(Type("nVA") == "U" ,0,nVA)
		SCU->(DbSetOrder(2))
	Endif

	dbSelectArea(cAlias)
	nRec := (cAlias)->(Recno())
	(cAlias)->(DbGoTop())

	While !(cAlias)->(Eof())

		SE2->(DBGoto((cAlias)->NUM_REG))

		// Caso esteja ligado o controle de solicitacao de notas de credito e exista alguma pendencia para este titulo
		If cPaisloc <> "BRA" .And. lMV_SOLNCP .And. SE2->E2_TIPO == MVNOTAFIS ;
				.And. SCU->(MsSeek(SE2->E2_FILIAL+SE2->E2_FORNECE+SE2->E2_LOJA+SE2->E2_NUM+SE2->E2_PREFIXO)).And. Empty(SCU->CU_NCRED)
			(cAlias)->(dbSkip())
			Loop
		EndIf
		// Documentos Apresentados
		IF lFinVDoc
			If !CN062ValDocs("03",.F.,.F.,.T.,@lPrimeiro)
				(cAlias)->(dbSkip())
				Loop
			EndIf
		EndIf

		lBxTit := .T.
		If lFA080
			lRet:=FA080Integ(.F.,.F.)
		Endif

		//Verifica se PA possui movimentacao para permitir a baixa
		If SE2->E2_TIPO $ MVPAGANT .and. lBxTit
			nRecPA := F080MovPA(.T.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
			If nRecPA < 1
				//Verifica se é PA de CNAB (Gera Ch para Adt = Não / Mov. Banc. sem Cheque = Não) - Nesse caso deve permitir a baixa para gerar mov. a pagar
				nRecPA := F080MovPA(.F.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
				If nRecPA > 0
					lBxTit := .F.
				Else
					lBxTit := .T.
				Endif
			EndIf
		Endif

		If lRet
			If (cAlias)->(MsRLock()) .and. SE2->(MsRLock())// Se conseguir travar o registro
				(cAlias)->E2_OK := cMarca
				SE2->E2_OK := cMarca
				//------------------------------------------------------------------------------------------
				// PONTO DE ENTRADA F090TIT
				// Verifica se titulo pode ser marcado para baixa ou nÆo. Caso tenha
				// sido alterada a marcação do titulo.
				// Retornar .F. para não haver alteração dos acumuladores de valores e numero de titulos.
				// Importante:
				// Os valores passados como parãmetro para esse PE são apenas para manter a compatibilidade
				// com a chamada feita no FINA090.
				// Valores utilizados apenas na chamada da rotina automática do FINA090
				//------------------------------------------------------------------------------------------
				If __lF090TIT
					lBxTit := ExecBlock("F090TIT",.F.,.F.,{0,{}})
				Endif
				If lBxTit
					nAbat  := F091GETABAT()

					If __lFKD
						nVa := SE2->(FValAcess(E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, E2_FORNECE, E2_LOJA, E2_NATUREZ, /*lBaixados*/, /*cCodVa*/, "P", dBaixa))
					EndIf
	
					nValor += SE2->(xMoeda(Round(E2_SALDO+nVa+fa080Juros(nMoedaBco)+E2_SDACRES-E2_SDDECRE-nAbat,2),E2_MOEDA,nMoedaBco,,_nTamMD2,If(cPaisLoc=="BRA",E2_TXMOEDA,0)))
					nQtdTit	++
				Else
					(cAlias)->E2_OK := "  "
					SE2->E2_OK := "  "
					(cAlias)->(MsUnlock())
				Endif
			Endif
		Endif
		(cAlias)->(dbSkip())
	EndDo

	(cAlias)->(dbGoto(nRec))
	dbSelectArea(cAliasAnt)
Return NIL

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função	 ³FA091Inver³ Autor ³ Wagner Xavier 		  ³ Data ³23/05/97³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Marca / Desmarca todos os titulos						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA091													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Fa091Inverte(cAliasSE2,cMarca,oValor,oQtda,lTodos,oMark,lAutomato,nTipoBx)
	Local nReg		:= (cAliasSE2)->(Recno())
	Local nAbat		:= NIL
	Local lBxTit	:= .T.
	Local lFinVDoc	:= IIF(GetNewPar("MV_FINVDOC","2")=="1",.T.,.F.)		//Controle de validacao de documentos obrigatorios
	Local lPrimeiro	:=.T.
	Local nRecPA    := 0
	Local lLibLock	:= .F.
	Local nVa       := 0

	DEFAULT lTodos		:= .T.
	DEFAULT lAutomato	:= .F.
	DEFAULT nTipoBx	  := 1

	dbSelectArea(cAliasSE2)
	If lTodos
		(cAliasSE2)->(DbGoTop())
		SE2->(dbGoto((cAliasSE2)->NUM_REG))
	Endif

	While !lTodos .Or. !(cAliasSE2)->(Eof())

		SE2->(dbGoto((cAliasSE2)->NUM_REG))
		If lExistLGA
			cUserLga := SE2->E2_USERLGA
		EndIF

		If SE2->(MsRLock()) .AND. (cAliasSE2)->(MsRLock())
			IF (cAliasSE2)->E2_OK == cMarca
				(cAliasSE2)->E2_OK := "  "
				SE2->E2_OK := "  "
				lLibLock := .T.
				nAbat  := F091GETABAT()

				If __lFKD
					nVa    := SE2->(FValAcess(E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, E2_FORNECE, E2_LOJA, E2_NATUREZ, /*lBaixados*/, /*cCodVa*/, "P", dBaixa))
				EndIf
				
				nValor -= SE2->(xMoeda(Round(E2_SALDO+nVa+fa080Juros(nMoedaBco)+E2_SDACRES-E2_SDDECRE-nAbat,2),E2_MOEDA,nMoedaBco,,_nTamMD2,If(cPaisLoc=="BRA",E2_TXMOEDA,0)))
				nQtdTit	--
			Else
				lBxTit := .T.

				// Caso tenha integracao Documentos
				If lFinVDoc
					If !CN062ValDocs("03",.F.,.F.,lTodos,@lPrimeiro)
						(cAliasSE2)->E2_OK := "  "
						SE2->E2_OK := "  "
						lLibLock := .T.
						lBxTit := .F.
					EndIf
				EndIf

				// Verifica se PA possui movimentacao bancaria
				If SE2->E2_TIPO $ MVPAGANT .and. lBxTit
					nRecPA := F080MovPA(.T.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
					If nRecPA < 1
						//Verifica se é PA de CNAB (Gera Ch para Adt = Não / Mov. Banc. sem Cheque = Não) - Nesse caso deve permitir a baixa para gerar mov. a pagar
						nRecPA := F080MovPA(.F.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
						If nRecPA > 0
							IF !lTodos
								Help(" ",1,"F090PAMOV",,STR0172,1,0) //"Não é possível realizar a baixa de pagamento antecipado sem movimentação bancária."
							Endif
							lBxTit := .F.
						Else
							lBxTit := .T.
						Endif
					EndIf
				Endif

				//------------------------------------------------------------------------------------------
				// PONTO DE ENTRADA F090TIT
				// Verifica se titulo pode ser marcado para baixa ou nÆo. Caso tenha
				// sido alterada a marcação do titulo.
				// Retornar .F. para não haver alteração dos acumuladores de valores e numero de titulos.
				// Importante:
				// Os valores passados como parãmetro para esse PE são apenas para manter a compatibilidade
				// com a chamada feita no FINA090.
				// Valores utilizados apenas na chamada da rotina automática do FINA090
				//------------------------------------------------------------------------------------------
				If __lF090TIT .and. !Empty(E2_OK)
					lBxTit := ExecBlock("F090TIT",.F.,.F.,{0,{}})
				Endif
				If lBxTit
					(cAliasSE2)->E2_OK := cMarca
					SE2->E2_OK := cMarca

					nAbat  := F091GETABAT()
					If __lFKD
						nVa    := SE2->(FValAcess(E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, E2_FORNECE, E2_LOJA, E2_NATUREZ, /*lBaixados*/, /*cCodVa*/, "P", dBaixa))
					EndIf
					nValor += SE2->(xMoeda(Round(E2_SALDO+nVa+fa080Juros(nMoedaBco)+E2_SDACRES-E2_SDDECRE-nAbat,2),E2_MOEDA,nMoedaBco,,_nTamMD2,If(cPaisLoc=="BRA",E2_TXMOEDA,0)))
					nQtdTit++
				Else
					(cAliasSE2)->E2_OK	:= "  "
					SE2->E2_OK	:= "  "
					lLibLock := .T.
				Endif
			Endif
		Endif

		IF lLibLock
			(cAliasSE2)->(MsUnlock())
			SE2->(MsUnlock())
		ENDIF

		If lTodos
			(cAliasSE2)->(dbSkip())
		Else
			Exit
		Endif
	Enddo
	(cAliasSE2)->(dbGoto(nReg))

	If !lAutomato
		oValor:Refresh()
		oQtda:Refresh()
		oMark:oBrowse:Refresh(.t.)
	EndIf
Return NIL

/*±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função	 ³Fa091Busca³ Autor ³ Adilson H. Yamaguchi  ³ Data ³06/06/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Pesquisa com indice temporario							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fa091Busca()
	AxPesqui()
	Eval(bFilBrw)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função	 ³ fa091Can ³ Autor ³ Adilson H. Yamaguchi  ³ Data ³ 04/05/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Rotina de Cancelamento de Baixa a pagar					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fa091Can(ExpC1,ExpN1,ExpN1)								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA091													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fa091Can(cAlias,nReg,nOpcx, lAutomato)
	Local oDlg
	Local lOk := .F.
	Local nHdlPrv := 0
	Local nTotal := 0
	Local lPadraoBx :=.F.
	Local nOrdem
	Local lPadraoVd :=.F.
	Local cArquivo
	Local nSalvRec := 0
	Local cParcela
	Local cNum
	Local cPrefixo
	Local dBaixa
	Local cAgencia	:= CriaVar("E1_AGEDEP")
	Local cCheque	:= CriaVar("EF_NUM")
	Local cFornece
	Local cMoeda
	Local cTitAnt
	Local cDescrMo	:= " "
	Local aBaixa 	:= {}
	Local nOpBaixa := 1
	Local cTipo
	Local nJuros 	:= 0
	Local nMulta 	:= 0
	Local nCorrec 	:= 0
	Local nDescont  := 0
	Local nVA       := 0  // Valores acessórios.
	Local dDataAnt
	Local lBaixaAbat	:= .F.
	Local cSequencia 	:= Space( TamSX3("E5_SEQ")[1] )
	Local nRegB
	Local lVend 		:= .F.
	Local nRegV
	Local lCheque 		:= .F.
	Local cBenef 		:= ""
	Local lContabilizou :=.F.
	Local cNumCheq		:= CRIAVAR("EF_NUM")
	Local lEstorna
	Local nTotAdto 	:= 0
	Local cSeqSe5 		:= Space( TamSX3("E5_SEQ")[1] )
	Local nTxMoeda := 0
	Local cTipoDoc := ""
	Local aAux := {}
	Local nI := 0
	Local nRecDelSef := 0
	Local nRecSe5    := 0
	Local lRet := .T.
	Local lFa080Own := ExistBlock("FA080OWN")
	Local aMotBx:= ReadMotBx()
	Local cTitOriV := CRIAVAR("E2_TITORIG")
	Local lBaixaOk	:= .T.
	Local nOrdSa6, nRecSa6
	Local nDifCambio := 0
	Local nImpSubst   := 0
	Local nOtrga     := 0
	Local nAtraso := 0
	Local cRef	:= ""
	Local cChave := ""
	Local lAtuSldNat := .T.
	Local lCalcIssBx :=	.F.
	Local lIRPFBaixa := .F.
	Local lPCCBaixa  := SuperGetMv("MV_BX10925",.T.,"2") == "1"
	Local lAtuForn   := SuperGetMv("MV_ATUFORN",.F.,.T.)
	Local lAtuSldBco := SuperGetMv("MV_ATUSLBC",.F.,.T.)

	//Reestruturacao SE5
	Local aAreaAnt	:= {}
	Local oModelBx  := FWLoadModel("FINM020")
	Local cLog		:= ""
	Local nOperFK2	:= 0
	Local oModelMov := FWLoadModel("FINM030")
	Local cHistCan091 := ""
	Local lExistFJU := FJU->(ColumnPos("FJU_RECPAI")) >0 .and. FindFunction("FinGrvEx")

	// Variáveis de integração EAI.
	Local llOpc := .F.
	Local aEaiRet := {}
	Local lTypeA6 := .T.

	PRIVATE aBaixaSE5 := {}

	Default lAutomato := .F.

	//Verifica se o Titulo nao sofreu nenhuma baixa
	IF Empty(SE2->E2_BAIXA)
		Help(" ",1,"TITNAOXADO")
		Return
	EndIF

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se data do movimento n„o ‚ menor que data limite de ³
	//³ movimentacao no financeiro    										  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !DtMovFin(SE2->E2_BAIXA,,"1")
		Return
	Endif

	//Verifica se ‚ um registro Principal												³
	IF SE2->E2_TIPO $ MVABATIM
		Help(" ",1,"NAOPRINCIP")
		Return
	Endif

	If !(FA080Integ(.T.))
		Return .F.
	Endif

	/*Posiciona no Fornecedor do título a pagar*/
	DbSelectArea("SA2")
	SA2->(DbSeek(XFILIAL("SA2")+SE2->(E2_FORNECE+E2_LOJA)))

	If _lTemMR
		F091VldImp(.T.)
	EndIf

	/*Verificação do tipo de retenção do imposto de renda*/
	If !_lIrfMR
		lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.) .And. ;
			IIf( cPaisLoc $ "ANG|ARG|AUS|BOL|BRA|CHI|COL|COS|DOM|EQU|EUA|HAI|MEX|PAD|PAN|PAR|PER|POR|PTG|SAL|URU|VEN", ;
			Posicione("SED",1,xFilial('SED',SE2->E2_FILORIG) + SE2->(E2_NATUREZ),"ED_CALCIRF") = "S", .F.)
	EndIf

	If !_lIssMR
		lCalcIssBx := IsIssBx("P")
	EndIf

	dbSelectArea("SE2")
	nOrdem:=IndexOrd()
	dbSetOrder(1)

	cMoeda		:= IIF(Empty(SE2->E2_MOEDA),"1",AllTrim(Str(SE2->E2_MOEDA,2)))
	nSalvRec	:= SE2->( RecNO() )
	cNum		:= SE2->E2_NUM
	cPrefixo	:= SE2->E2_PREFIXO
	cParcela	:= SE2->E2_PARCELA
	cFornece	:= SE2->E2_FORNECE
	cTipo		:= SE2->E2_TIPO
	cLoja		:= SE2->E2_LOJA
	nTotAbat	:= 0
	nValPgto	:= SE2->E2_VALLIQ
	dBaixa		:= SE2->E2_BAIXA
	nTotAbat	:= SumAbatPag( cPrefixo, cNum, cParcela, cFornece, SE2->E2_MOEDA,"V",dBaixa,cLoja )
	If cPaisLoc == "CHI"
		nOtrga		:= SE2->E2_OTRGA
		nDifCambio	:= SE2->E2_CAMBIO
		nImpSubst	:= SE2->E2_IMPSUBS
	EndIf
	SE2->( dbGoTo( nSalvRec ) )

	//Procura pelas baixas deste titulo
	aBaixa := Sel080Baixa( "VL /BA /CP /",cPrefixo, cNum, cParcela,cTipo,@nTotAdto,@lBaixaAbat,cFornece,cLoja)

	//Escolhe Baixa a ser cancelada
	If Len(aBaixa) > 1
		cListBox := aBaixa[1]
		nOpbaixa := 1

		If !lAutomato
			DEFINE MSDIALOG oDlg FROM 5, 5 TO 14, 50 TITLE  STR0041 //"Escolha A Baixa"

			@	.5, 2 LISTBOX nOpBaixa ITEMS aBaixa SIZE 150 , 40 Font oDlg:oFont
			DEFINE SBUTTON FROM 055,112	TYPE 1 ACTION (lOk := .T.,oDlg:End()) ENABLE OF oDlg
			DEFINE SBUTTON FROM 055,139.1 TYPE 2 ACTION (lOk := .F.,oDlg:End()) ENABLE OF oDlg

			ACTIVATE MSDIALOG oDlg CENTERED
		Else
			If FindFunction("GetParAuto")

				aRetAuto := GetParAuto("FINA091TESTCASE")

				For nI := 1 to Len (aBaixa)
					If aBaixa[nI]==aRetAuto[1] //Chave do cancelamento parcial que deverá ser:
						nOpBaixa := nI
						lOk := .T.
					Endif
				Next nI
			Endif
		EndIf
		If !lOk
			Return Nil
		Endif
	EndIF

	If Len(aBaixa) == 0
		// Procura pelas compensações
		If SE5->(dbSeek(xFilial("SE5")+"CP"+cPrefixo+cNum+cParcela+cTipo))
			Help(" ",1,"TITULOADT")
		ElseIf SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG .and. !lBaixaAbat
			Help(" ",1,"TITULOADT")
		Elseif Empty( SE2 -> E2_FATURA )
			Help(" ",1,"BAIXTITINC")
		Else
			Help(" ",1,"TITFATURAD")
		EndIF
		Return
	EndIF

	//Pega os Valores da Baixa Escolhida
	dBaixa		:= aBaixaSE5[nOpBaixa,07]
	cSequencia 	:= aBaixaSE5[nOpBaixa,09]
	cChave := SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+Dtos(dBaixa)+cFornece+cLoja+cSequencia

	//Verifica se data do cancelamento ‚ menor que a data da baixa
	If dBaixa > dDataBase
		Help(" ",1,"DTBAIXA")
		Return
	Endif

	dbSelectArea("SE5")
	SE5->(dbSetOrder(2))
	cTipoDoc := "CM/CX/DC/MT/JR/BA/VL/VA/"
	IIf(cPaisloc == "CHI", cTipoDoc += "IS/", .T.)
	lTypeA6 := Type("SA6->A6_MOEDAP")=="U"
	For nI := 1 to len( cTipoDoc) Step 3
		IF SE5->( dbSeek(xFilial("SE5")+substr(cTipoDoc,nI,2)+cChave) )
			nIrrf	+= If(!_lIrfMR, SE5->E5_VRETIRF, 0)
			nIss	+= If(!_lIssMR, SE5->E5_VRETISS, 0)

			If !_lPccMR
				nPis	+= SE5->E5_VRETPIS
				nCofins += SE5->E5_VRETCOF
				nCSLL	+= SE5->E5_VRETCSL
			EndIf

			If substr(cTipoDoc,nI,2 ) $ "CM/CX"
				If cPaisloc <> "CHI"
					nCorrec		:= SE5->E5_VALOR
				Else
					nDifcambio	:=SE5->E5_VALOR
				EndIf
			ElseIf substr(cTipoDoc,nI,2 ) $ "DC"
				nDescont:= SE5->E5_VALOR
			ElseIf substr(cTipoDoc,nI,2 ) $ "MT"
				nMulta	:= SE5->E5_VALOR
			ElseIf substr(cTipoDoc,nI,2 ) $ "JR"
				If cPaisloc <> "CHI"
					nJuros	:= SE5->E5_VALOR
				Else
					nOtrga	:= SE5->E5_VALOR
				EndIf
			ElseIf substr(cTipoDoc,nI,2 ) $ "BA/VL"
				If cPaisLoc <> "BRA" .And. !Empty(SE5->E5_BANCO)
					SA6->(DbSetOrder(1))
					SA6->(dbSeek(xFilial()+SE5->E5_BANCO+SE5->E5_AGENCIA+SE5->E5_CONTA))
					nValPgto := xMoeda(SE5->E5_VALOR,Max(IIf(lTypeA6,SA6->A6_MOEDA,SA6->A6_MOEDAP),1),1,SE5->E5_DATA)
				Else
					nValPgto := SE5->E5_VALOR
				Endif

				cHist070 := SE5->E5_HISTOR
				cMotBx   := SE5->E5_MOTBX
				cNumBor  := SubStr(SE5->E5_DOCUMEN,1,6)
				cLoteFin := SE5->E5_LOTE
				nRecSe5  := SE5->(RecNo())
				nValEstrang := SE5->E5_VLMOED2
			ElseIf substr(cTipoDoc,nI,2 ) $ "IS" 	//Localizacao Chile
				nImpsubst	:= SE5->E5_VALOR
			ElseIf lPodeTVA .and. lExistVA .and. substr(cTipoDoc,nI,2) == "VA"  // Valores acessórios.
				While SE5->(!EOF() .AND. xFilial("SE5")+substr(cTipoDoc,nI,2)+cChave == E5_FILIAL+E5_TIPODOC+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+DtoS(E5_DATA)+E5_CLIFOR+E5_LOJA+E5_SEQ)
					If ( cPaisLoc == "BRA" )
						nVA += SE5->E5_VALOR
					Else
						nVA += xMoeda( SE5->E5_VALOR, max(val(SE5->E5_MOEDA), 1), 1, SE5->E5_DATA,, SE5->E5_TXMOEDA )
					Endif
					SE5->(dbSkip())
				EndDo
			EndIF
		EndIF
	Next

	lEstorna := !Empty(cNumBor)

	//Verifica se foi utilizada taxa contratada para moeda > 1
	dbGoTo(nRecSe5)		//volta para o registro principal

	If _lTemMR
		_nTotImp := FinRetBxMR("P", SE5->E5_IDORIG, .T.)
	EndIf

	If SE2->E2_MOEDA > 1 .and. Round(NoRound(xMoeda(nValpgto,1,SE2->E2_MOEDA,dBaixa,3),3),2) != SE5->E5_VLMOED2
		nTxMoeda := Noround((SE5->E5_VALOR / SE5->E5_VLMOED2),5)
	Else
		nTxMoeda := RecMoeda(dBaixa,SE2->E2_MOEDA)
	Endif

	//Caso moeda ==1 a funcao RecMoeda iguala nTxMoeda = 0. Iguala-se
	//nTxMoeda = 1 p/ evitar problema c/ calculos de abatimento e outros.
	nTxMoeda := IIF(nTxMoeda == 0 , 1 , nTxMoeda)

	//Verifica se foi ja foi gerado cheque para esta baixa; se o cheque ja foi gerado nao permite o cancelamento
	dbSelectArea("SEF")
	dbSetOrder(3)

	If !(SE5->E5_TIPO $ MVPAGANT)
		If SEF->(dbSeek(SEF->EF_FILIAL+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO+SE5->E5_NUMCHEQ))
			cSeqSe5 := SE5->E5_SEQ

			While SEF->( !Eof()).and. ;
					EF_TITULO == SE5->E5_NUMERO	 .and. ;
					EF_PARCELA== SE5->E5_PARCELA .and. ;
					EF_PREFIXO== SE5->E5_PREFIXO .and. ;
					EF_TIPO   == SE5->E5_TIPO	 .and. ;
					EF_NUM    == SE5->E5_NUMCHEQ

				If SEF->EF_SEQUENC == cSeqSe5 .and. SE5->E5_CLIFOR == SEF->EF_FORNECE
					nRecDelSef := SEF->( RecNo() )
					lEstorna := .F.  //achou cheque para esta baixa
					// Permite a baixa se houver cheque cancelado.
					IF SEF->EF_IMPRESS # "C"
						lCheque := .T.
						cNumCheq:= SEF->EF_NUM
						cBenef  := SEF->EF_BENEF
						cRef	:= SEF->EF_TITULO
					Endif
					Exit
				Endif
				SEF->( dbSkip() )
			Enddo
		Endif
	EndIf
	dbSelectArea("SEF")
	dbSetOrder(1)

	lContabilizou:= Iif(SE5->E5_LA="S",.T.,.F.)

	nValPadrao	:= nValPgto-(nJuros+nMulta+Iif(SE2->E2_MOEDA>1,nCorrec,0)-nDescont+nVA)
	nSalDup		:= SE2->E2_SALDO-nValPadrao

	cBanco  := aBaixaSE5[nOpbaixa,11]+aBaixaSE5[nOpBaixa,12]+aBaixaSE5[nOpBaixa,13]

	dbSelectArea("SEF")
	dbSetOrder(1)
	If (lCheque .and. !Empty(cNumCheq)) .Or. (!Empty(SE2->E2_NUMBCO) .and. !Empty(SEF->EF_IMPRESS) .and. !SE2->E2_TIPO $ MVPAGANT )
		Help(" " , 1 , "FA080TEMCH")
		dbSelectArea("SE2")
		Return
	Endif

	If ( lCheque .And. !GetMv("MV_CTBAIXA") $ "BA" )
		lContabilizou := .F.
	EndIf

	dbSelectArea("SE5")
	dbGoTo(nRecSe5)		//volta para o registro principal

	nI :=  Ascan(aMotBx, {|x| Substr(x,1,3) == Upper(cMotBx) })
	cDescrMo := if( nI > 0,Substr(aMotBx[nI],07,10),"" )

	SA2->( dbseek( xFilial("SA2")+SE2->E2_FORNECE+SE2->E2_LOJA))
	dbSelectArea("SE2")
	RecLock("SE2")
	cNomeFor := SE2->E2_FORNECE + " " + SA2->A2_NOME
	cTitulo	:= SE2->E2_PREFIXO + " " + SE2->E2_NUM
	nPagtoParcial := SE2->E2_VALOR-SE2->E2_SALDO
	cTexto	 :=  STR0042 + SubStr(GetMV("MV_SIMB"+cMoeda),1,3)  //"Valor Original "

	*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	*³Recebe os dados do título a ser baixado 										³
	*ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nOpc1 := 0

	If !lAutomato
		DEFINE MSDIALOG oDlg FROM	31,15 TO 256,554 TITLE  STR0043 PIXEL OF oMainWnd //  "Cancelamento de Baixas a Pagar"
		@ 01, 002 TO 108, 268 LABEL  STR0044 OF oDlg  PIXEL // "Datos del Cheque"

		@ 010, 007 SAY  STR0045			SIZE 30,07 OF oDlg PIXEL //"Fornec."
		@ 008, 050 MSGET cNomeFor					SIZE 211,9 OF oDlg PIXEL When .F.
		@ 022, 007 SAY  STR0046			SIZE 40,07 OF oDlg PIXEL //"Banco"
		@ 020, 050 MSGET aBaixaSE5[nOpBaixa,11]	SIZE 22,10 OF oDlg PIXEL When .F.
		@ 034, 007 SAY  STR0047		  	SIZE 39,07 OF oDlg PIXEL //"Agˆncia"
		@ 032, 050 MSGET aBaixaSE5[nOpBaixa,12]	SIZE 35,10 OF oDlg PIXEL When .F.
		@ 046, 007 SAY  STR0048			SIZE 41,07 OF oDlg PIXEL //"Conta"
		@ 044, 050 MSGET aBaixaSE5[nOpBaixa,13]	SIZE 66,10 OF oDlg PIXEL When .F.
		@ 058, 007 SAY  STR0049	  		SIZE 40,07 OF oDlg PIXEL //"Referencia"
		@ 056, 050 MSGET cRef			 			SIZE 38,10 OF oDlg PIXEL When .F.
		@ 070, 007 SAY  STR0051  		SIZE 53,07 OF oDlg PIXEL //"Valor Original"
		@ 068, 050 MSGET SE2->E2_VALOR  			SIZE 66,10 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_VALOR")
		IF SE2->E2_MOEDA > 1
			@ 082, 007 SAY  STR0052  + SubStr(GetMV("MV_SIMB"+cMoeda),1,3)    SIZE 53,07 OF oDlg PIXEL //"Valor "
			@ 080, 050 MSGET nValEstrang			SIZE 66,10 OF oDlg PIXEL When .F. Picture PesqPict("SE5","E5_VLMOED2")
			If cPaisLoc <> "CHI"
				@ 094, 007 SAY  STR0053	SIZE 53,07 OF oDlg PIXEL //"+ Corr.Monet ria"
				@ 092, 050 MSGET nCorrec				SIZE 66,10 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_CORREC")
			Else
				@ 094, 007 SAY  STR0054 	SIZE 53,07 OF oDlg PIXEL //"+/- Dif. Cambio"
				@ 092, 050 MSGET nDifCambio		  	SIZE 66,10 OF oDlg PIXEL When .F. Picture PesqPict("SE2","E2_VALOR")
			EndIf
		ENDIF

		DEFINE SBUTTON FROM 54, 230 TYPE 1 ENABLE OF oDlg ACTION ( nOpc1 := 1,oDlg:End() )
		DEFINE SBUTTON FROM 68, 230 TYPE 2 ENABLE OF oDlg ACTION oDlg:End()

		ACTIVATE MSDIALOG oDlg CENTERED
	Else
		nOpc1 := 1
	Endif

	SE2->E2_BAIXA	:= dBaixa
	SE2->E2_NUMBOR	:= cNumBor
	SE2->(msUnlock("SE2"))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ PONTO DE ENTRADA P/ PERMISSAO DE CANCELAMENTO DE BAIXA DE TITULO		  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lFa080Own
		lRet :=	ExecBlock('FA080OWN',.F.,.F.)
	Endif
	If !lRet
		Return
	EndIf

	IF nOpc1 == 1
		*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		*³ Inicio da protecao via TTS										³
		*ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nOrdSa6 := SA6->(INDEXORD())
		nRecSa6 := SA6->(RECNO())
		Begin Transaction
			SED->( dbSeek(cFilial+SE2->E2_NATUREZ) )
			SA6->( DbSetOrder(1) )
			SA6->( DbSeek(xFilial("SA6")+SE5->(E5_BANCO+E5_AGENCIA+E5_CONTA) ) )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Apaga Titulo de Vendor Gerado					  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			lBaixaOk := .T.
			IF TrazCodMot(cMotBx) == "VEN"
				dbSelectArea("SE2")
				cTitOriV := SE2->E2_TITORIG
				If dbSeek(cFilial+SE2->E2_TITORIG)
					lVend := .T.
					nRegV := SE2->( Recno() )
					lPadraoVd := VerPadrao("519") //cancelamento de baixa vendor

					If SE2->E2_SALDO == SE2->E2_VALOR
						If lExistFJU
							FinGrvEx("P")
						Endif
						Reclock("SE2",.F.,.T.)
						dbDelete()
					Else
						Help(" ",1,"BXVENDOR",,Subs(cTitOriV,1,3)+" "+Subs(cTitOriV,4,6)+;
							" "+Subs(cTitOriV,10,1)+" "+Subs(cTitOriV,11,3),5,1)
						lBaixaOk := .F.
					Endif
				Endif
				If lBaixaOk
					dbGoto(nReg)
					RecLock("SE2",.F.)
					Replace SE2->E2_TITORIG With Space(19)
				Endif
			Endif
			If lBaixaOk
				// Valores acessórios.
				If lPodeTVA .and. lExistVA
					FAtuFKDBx(.T., "P")
				Endif

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Gravar valores no SE2                                             ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SE2->E2_OK <> 'TA'
					Reclock( "SE2" )
					SE2->E2_VALLIQ := nValPgto
					If cPaisloc <> "CHI"
						SE2->E2_JUROS	:= nJuros
						SE2->E2_CORREC := nCorrec
					Else
						SE2->E2_JUROS	:= nOtrga + nImpsubst
						SE2->E2_CORREC := nDifCambio
						SE2->E2_OTRGA  :=nOtrga
						SE2->E2_CAMBIO :=nDifCambio
						SE2->E2_IMPSUBS:=nImpSubst
					EndIf
					SE2->E2_MULTA	:= nMulta
					SE2->E2_DESCONT:= nDescont
				Else
					SE2->E2_OK := ''
					SE2->E2_BAIXA :=	IIF( Str(E2_SALDO,17,2) == Str(E2_VALOR,17,2) .AND. EMPTY(SE2->E2_NUMBOR),CtoD(""), E2_BAIXA )
				EndIf

				SE2->(MsUnlock())

				cPadrao := "531"    //cancelamento de baixa
				lPadraoBx := (VerPadrao(cPadrao) .and. lContabilizou)

				nRegB := SE2->( Recno() )

				ABATIMENTO := nTotAbat
				aFlagCTB	:= {}
				IF (lPadraoBx .or. lPadraoVd ) .and. lContabilizou
					nHdlPrv:=HeadProva(cLote,"FINA080",Substr(cUsuario,7,6),@cArquivo)
				Endif
				IF lPadraoBx .and. lContabilizou .and. !(nOpcx == 5 .and. SE5->E5_TIPODOC $ "VL")
					nTotal+=DetProva(nHdlPrv,cPadrao,"FINA080",cLote)
				Endif
				IF lPadraoVd .and. lContabilizou
					IF lVend
						dbSelectArea( "SE2" )
						SE2->( dbGoto(nRegV) )
						nTotal+=DetProva(nHdlPrv,"519","FINA080",cLote)
					Endif
				Endif
				SE2->( dbGoto(nRegB) )

				// Volta titulo para carteira.
				If SE2->E2_OK <> 'TA'
					Reclock( "SE2" )
					SE2->E2_PRETIRF := " "
					nTotAbat := IIF( SE2->E2_SALDO!=0,0,NoRound((nTotAbat*nTxMoeda),3) )
					dDataAnt := Iif(nOpBaixa==Len(aBaixa), Iif(Len(aBaixa)==1, CtoD(""), aBaixaSE5[Len(aBaixa)-1]),E2_BAIXA)
					IF SE2->E2_MOEDA == 1
						nValor := SE2->E2_SALDO + _nTotImp + (nValPgto-nJuros-nMulta+nDescont+nTotAbat-nVA)
					Else
						nValor := SE2->E2_SALDO + _nTotImp + ((nValPgto-nJuros-nCorrec-nMulta+nDescont+nTotAbat-nVA) / NoRound(nTxMoeda,5))
					Endif
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Volta valor original do titulo se cancelamento final das baixas ³
					//³ e n„o houverem compensa‡oes.                                   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					IF Len(aBaixa) == 1 .and. nTotAdto == 0 .and. !SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG
						nValor := SE2->E2_VALOR
					Endif
					/*
					* Atualização dos saldos do fluxo de caixa por natureza financeira
					*/
					If lAtuSldNat
						// Atualiza o saldo da natureza. O valor jah esth liquido dos abatimentos, desta forma nao precisa atualizar na baixa dos abatimentos
						AtuSldNat(SE2->E2_NATUREZ, SE2->E2_BAIXA, SE2->E2_MOEDA, "3", "P", nValor, xMoeda(nValor,SE2->E2_MOEDA,1,SE2->E2_BAIXA,,,If(cPaisLoc=="BRA",SE2->E2_TXMOEDA,0)), If(SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG,"+","-"),,FunName(),"SE2",SE2->(Recno()),0)
					EndIf

					SE2->E2_SALDO := 	IIf( nValor < 0 , 0 , IIF(EMPTY(SE2->E2_NUMBOR),nValor,nValPgto))
					SE2->E2_BAIXA :=	IIF( Str(E2_SALDO,17,2) == Str(E2_VALOR,17,2) .AND. EMPTY(SE2->E2_NUMBOR),CtoD(""), E2_BAIXA )
					SE2->E2_DESCONT:= 0
					SE2->E2_MULTA	:= 0
					SE2->E2_JUROS	:= 0
					SE2->E2_CORREC	:= 0
					SE2->E2_VALLIQ	:= 0
					SE2->E2_LOTE 	:= Space(Len(SE2->E2_LOTE))
					SE2->E2_IMPCHEQ:= " "

					If lIRPFBaixa .AND. EMPTY(SE2->E2_NUMBOR)
						If SA2->A2_TIPO == "F"
							SE2->E2_IRRF -= nIrrf
						EndIf
						SE2->E2_VRETIRF -= nIrrf
					EndIf

					If lCalcIssBx .AND. EMPTY(SE2->E2_NUMBOR)
						SE2->E2_VRETISS -= nIss
					EndIf

					If lPCCBaixa .AND. EMPTY(SE2->E2_NUMBOR)
						SE2->E2_VRETPIS -= nPis
						SE2->E2_VRETCOF -= nCofins
						SE2->E2_VRETCSL -= nCSLL

						If SE2->(E2_VRETPIS+E2_VRETCOF+E2_VRETCSL) == 0
							SE2->E2_PRETPIS := "1"
							SE2->E2_PRETCOF := "1"
							SE2->E2_PRETCSL := "1"
						EndIf
					EndIf

					If cPaisLoc=="BRA"
						SE2->E2_NUMBCO	:=	Space(Len(SE2->E2_NUMBCO))
					Else
						If Upper(Left(SE2->E2_NUMBCO,5))!="CJCC_"
							SE2->E2_NUMBCO	:=	Space(Len(SE2->E2_NUMBCO))
						Endif
					Endif
					If cPaisLoc == "CHI"
						SE2->E2_OTRGA    := 0
						SE2->E2_CAMBIO   := 0
						SE2->E2_IMPSUBS  := 0
						SE2->E2_TXMOEDA  := 0
					EndIf

					//Caso exista solicitacao de NCP eh necessario atualizar o campo CU_DTBAIXA...
					If cPaisLoc <> "BRA"
						A055AtuDtBx("2",SE2->E2_FORNECE,SE2->E2_LOJA,SE2->E2_NUM,SE2->E2_PREFIXO,SE2->E2_BAIXA)
						If Upper(Left(SE2->E2_NUMBCO,5))=="CJCC_"
							Fa550CJCC(Substr(SE2->E2_NUMBCO,6),"C")
						Endif
					EndIf

					//Inicializa a gravacao dos lancamentos do SIGAPCO
					PcoIniLan("000024")

					// Verifica se há  abatimentos para voltar a carteira
					If SE2->(dbSeek(cFilial+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA))
						cTitAnt := (SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA)
						While !SE2->(Eof()) .and. cTitAnt == (SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA)
							IF !SE2->E2_TIPO $ MVABATIM
								SE2->(dbSkip())
								Loop
							EndIF
							IF SE2->E2_FORNECE+SE2->E2_LOJA != cFornece+cLoja
								SE2->(dbSkip())
								Loop
							EndIF

							// Volta titulo para carteira
							Reclock("SE2")
							SE2->E2_BAIXA	:= dDataAnt
							SE2->E2_SALDO	:= E2_VALOR
							SE2->E2_DESCONT:= 0
							SE2->E2_JUROS	:= 0
							SE2->E2_MULTA	:= 0
							SE2->E2_CORREC	:= 0
							SE2->E2_VARURV	:= 0
							SE2->E2_LOTE	:= Space(Len(E2_LOTE))
							SE2->E2_VALLIQ	:= 0
							SE2->E2_NUMBCO	:= Space(Len(SE2->E2_NUMBCO))
							If !_lIrfMR .AND. lIRPFBaixa .AND. EMPTY(SE2->E2_NUMBOR)
								SE2->E2_VRETIRF -= nIrrf
							EndIf

							If !_lIssMR .AND. lCalcIssBx .AND. EMPTY(SE2->E2_NUMBOR)
								SE2->E2_VRETISS -= nIss
							EndIf

							If cPaisLoc == "CHI"
								SE2->E2_OTRGA    := 0
								SE2->E2_CAMBIO   := 0
								SE2->E2_IMPSUBS  := 0
								SE2->E2_TXMOEDA  := 0
							EndIf
							SE2->(dbSkip())
						Enddo
					Endif
				EndIf

				SE2->( dbGoTo( nSalvRec ) )

				//PONTOS DE ENTRADA
				If ExistTemplate("FA080CAN")
					ExecTemplate('FA080CAN',.F.,.F.)
				Endif

				If ExistBlock("FA080CAN")
					ExecBlock('FA080CAN',.F.,.F.)
				Endif

				If !_lPccMR .And. lPccBaixa .And. EMPTY(SE2->E2_NUMBOR)
					// Exclui os Tx's de PCC
					FDelTxBx(SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)
				EndIf

				//LOCALiza na movimentação banc ria, os registros referentes a baixa
				dbSelectArea("SE5")
				dbSetOrder(2)

				aAux := { "VL","BA","CM","CX","DC","MT","JR","VA"}
				IIf(cPaisloc == "CHI",AADD(aAux,"IS"),.T.)

				For nI := 1 to len(aAux)

					If SE5->( dbSeek(xFilial("SE5")+aAux[nI]+cChave))
						Do While SE5->(!eof() .and. xFilial("SE5")+aAux[nI]+cChave = E5_FILIAL+E5_TIPODOC+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+DtoS(E5_DATA)+E5_CLIFOR+E5_LOJA+E5_SEQ)

							cBanco	:= SE5->E5_BANCO
							cAgencia := SE5->E5_AGENCIA
							cConta   := SE5->E5_CONTA
							cTitulo	:= SE5->E5_NUMERO
							cCheque	:= SE5->E5_NUMCHEQ

							If !Empty( cLotefin ) // baixa por lote
								cHistCan091 :=  STR0055+" "+cLotefin // Canc. Baixa Lote
							Else
								cHistCan091 :=  STR0056 //"Cancelamento de baixa"
							EndIf

							If nOpcx == 5

								If SE5->E5_TIPODOC $ "VL|BA"

									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³Cancela as baixas gerando um lancamento de estorno no SE5         ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									If aAux[nI] $ "VL"
										//Reestruturacao SE5
										nOperFK2 := 2	//Altera E5_TIPODOC da SE5 para 'ES' e gera estorno na FK5
									Else
										//Reestruturacao SE5
										nOperFK2 := 1	//Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
									EndIf

									//Posiciona a FK5 para mandar a operação de alteração com base no registro posicionado da SE5
									aAreaAnt := GetArea()
									oModelBx  := FWLoadModel("FINM020")
									oModelBx:SetOperation( 4 ) //Alteração
									oModelBx:Activate()
									oModelBx:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
									oSubFKA := oModelBx:GetModel( "FKADETAIL" )
									oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )

									//E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
									//E5_OPERACAO 2 = Altera E5_TIPODOC da SE5 para 'ES' e gera estorno na FK5
									//E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5
									oModelBx:SetValue( "MASTER", "E5_OPERACAO", nOperFK2 )
									If cPaisloc <> "BRA"
										oModelBx:SetValue( "MASTER", "E5_LA", IIF(lContabilizou,"S","N") )
									EndIf
									oModelBx:SetValue( "MASTER", "HISTMOV"    , cHistCan091 )

									If oModelBx:VldData()
										oModelBx:CommitData()

										nRecSE5 := oModelMov:GetValue("MASTER","E5_RECNO")
										SE5->(dbGoTo(nRecSE5))

										oModelBx:DeActivate()
									Else
										lRet := .F.
										cLog := cValToChar(oModelBx:GetErrorMessage()[4]) + ' - '
										cLog += cValToChar(oModelBx:GetErrorMessage()[5]) + ' - '
										cLog += cValToChar(oModelBx:GetErrorMessage()[6])
										Help( ,,"M020VLDE1",,cLog, 1, 0 )
									Endif
									RestArea(aAreaAnt)

									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Prepara Lancamento Contabil                                      ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
										aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
									Endif

									If lPadraoBx .and. lContabilizou
										nTotal += DetProva( nHdlPrv,;
											cPadrao,;
											"FINA091" /*cPrograma*/,;
											cLote,;
											/*nLinha*/,;
											/*lExecuta*/,;
											/*cCriterio*/,;
											/*lRateio*/,;
											/*cChaveBusca*/,;
											/*aCT5*/,;
											/*lPosiciona*/,;
											@aFlagCTB,;
											/*aTabRecOri*/,;
											/*aDadosProva*/ )
									EndIf

									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ PONTO DE ENTRADA F080EST                            ³
									//³ PE para grava‡oes complementares do cancelamento    ³
									//³ da baixa                                            ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									IF nOperFK2 == 2 .and. EXISTBLOCK("F080EST")
										ExecBlock("F080EST",.F.,.F.)
									Endif

								Else
									//Cancelo os registros de valores acessoriso (Multas, Juros etc)
									RecLock("SE5")
									SE5->E5_SITUACA := "C"
									MsUnLock()
								Endif
							Else
								If SE5->E5_TIPODOC $ "VL|BA"

									aAreaAnt := GetArea()
									oModelBx  := FWLoadModel("FINM020")
									oModelBx:SetOperation( 4 ) //Alteração
									oModelBx:Activate()
									oModelBx:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
									oSubFKA := oModelBx:GetModel( "FKADETAIL" )
									oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )
									oModelBx:SetValue( "MASTER", "HISTMOV"    , cHistCan091 )

									//E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
									//E5_OPERACAO 2 = Altera E5_TIPODOC da SE5 para 'ES' e gera estorno na FK5
									//E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5
									oModelBx:SetValue( "MASTER", "E5_OPERACAO", 3 )

									If oModelBx:VldData()
										oModelBx:CommitData()
										oModelBx:DeActivate()
									Else
										lRet := .F.
										cLog := cValToChar(oModelBx:GetErrorMessage()[4]) + ' - '
										cLog += cValToChar(oModelBx:GetErrorMessage()[5]) + ' - '
										cLog += cValToChar(oModelBx:GetErrorMessage()[6])
										Help( ,,"M020VLDE3",,cLog, 1, 0 )

									Endif
									RestArea(aAreaAnt)
								Else
									//Cancelo os registros de valores acessoriso (Multas, Juros etc)
									RecLock("SE5")
									dbDelete()
									MsUnLock()
								Endif
							EndIf
							SE5->(dbSkip())
						EndDo
					Endif
				Next

				dbSetOrder(1)
				dbGoTo(nRecSe5)		//volta para o registro principal

				//Motor de Retenção Exclusão dos impostos
				If _lTemMR
					FMRDelImp(SE5->E5_TABORI, SE5->E5_IDORIG)
				Endif

				IF (lPadraoBx .Or. lPadraoVd) .and. lContabilizou
					cA100Incl( cArquivo,;
						nHdlPrv,;
						/*nOpcx*/,;
						cLote,;
						mv_par02 == 1 /*Mostra Lancamento*/,;
						mv_par03 == 1 /*Aglutnia Lancamento*/,;
						/*cOnLine*/,;
						/*dData*/,;
						/*dReproc*/,;
						@aFlagCTB,;
						/*aDadosProva*/,;
						)
					aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

				Endif

				//Apaga os lancamentos de desdobramento - SIGAPCO
				PcoDetLan("000024", "01", "FINA091", .T.)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Deleta Cheque gerado pela baixa						 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nRecNo := 0
				nValor := 0
				dbSelectArea("SEF")
				If nRecDelSef > 0
					dbGoto( nRecDelSef )
					If SEF->EF_IMPRESS != "C"
						Reclock("SEF",.F.,.T.)
						nValor := SEF->EF_VALOR
						dbDelete()
						MsUnlock()
					Endif
				Endif
				dbSetOrder(1)
				nRecNo := 0
				nValor := 0

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o totalizador										 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SubStr(cCheque,1,1) = "*" .And. nRecNo != 0
					dbGoTo( nRecNo )
					Reclock("SEF")
					SEF->EF_VALOR -= nValor
					IF SEF->EF_VALOR == 0
						Reclock("SEF",.F.,.T.)
						SEF->(dbDelete())
						MsUnlock()
					Endif
				Endif

				If lAtuForn
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o Cadastro de Fornecedores								  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					dbSelectArea("SA2")
					If !Eof()
						RecLock( "SA2" )
						SA2->A2_SALDUP		:= A2_SALDUP + nValPadrao
						SA2->A2_SALDUPM	+= xMoeda(nValPadrao,1,Val(GetMv("MV_MCUSTO")),SE2->E2_EMISSAO)

						nAtraso:=dBaixa-SE2->E2_VENCTO
						If nAtraso > 1
							IF Dow(SE2->E2_VENCTO) == 1 .Or. Dow(SE2->E2_VENCTO) == 7
								IF Dow(dBaixa) == 2 .and. nAtraso <= 2
									nAtraso := 0
								EndIF
							EndIF
							nAtraso:=IIF(nAtraso<0,0,nAtraso)
							If SA2->A2_MATR < nAtraso
								Replace A2_MATR With nAtraso
							EndIf
						Endif
					Endif
				Endif

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³	Atualiza saldos banc rios. 												  ³
				//³	No cancelamento de baixa de adiantamento, o saldo do caixa/banco ³
				//³	deve diminuir, pois o capital saiu do caixa e voltou a quem      ³
				//³	solicitou o PA. 																  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				dbSelectArea("SE2")
				SE2->( dbGoto(nReg) )

				If !_lIssMR .AND. lCalcIssBx .AND. nIss > 0.00 .AND. EMPTY(SE2->E2_NUMBOR)
					F241DelIS(SE2->(Recno()),nIss)
				EndIf

				If (!_lIrfMR .AND. lIRPFBaixa .AND. SA2->A2_TIPO == "J") .AND. nIrrf > 0.00 .AND. EMPTY(SE2->E2_NUMBOR)
					F241DelTxIR("FINA091", SE2->( Recno() ),nIrrf)
				EndIf

				If lAtuSldBco
					IF SE2->E2_TIPO $ MVPAGANT
						AtuSalBco(aBaixaSE5[nOpBaixa,11],aBaixaSE5[nOpBaixa,12],aBaixaSE5[nOpBaixa,13],dDataBase,nValPgto,"-")
					Endif

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³	Caixa ou Bordero sem Cheque ou Debto.CC								  ³
					//³	Quando for Debito em C.Corrente tem que estornar o saldo Bancario³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Verifica o modulo para definir o tratamento do Caixa			 	 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If (lEstorna .and. MovBcoBx(cMotBx, .T.) .and. SE5->E5_TIPODOC <>"BA") .or. ;
						TrazCodMot(cMotBx) $ "DEB" .or. ;
						(Left(aBaixaSE5[nOpBaixa,11],TamSX3("A6_COD")[1]) == Left(GetMv("MV_CXFIN"),TamSX3("A6_COD")[1]) .or. aBaixaSE5[nOpBaixa,11] $ cMV_CARTEIR)
						AtuSalBco(aBaixaSE5[nOpBaixa,11],aBaixaSE5[nOpBaixa,12],aBaixaSE5[nOpBaixa,13],dDataBase,nValPgto,"+")
					EndIf

					If cPaisLoc	<>	"BRA" .And. SE5->E5_TIPODOC=="VL"
						AtuSalBco(SE5->E5_BANCO,SE5->E5_AGENCIA,SE5->E5_CONTA,SE5->E5_DATA,SE5->E5_VALOR,"+")
					EndIf
				Endif

				If GetMv("MV_CANBORP") == "S"
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Apaga registro do titulo no SEA retirando-o do bordero		 	 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !Empty(SE2->E2_NUMBOR) .AND. !lIRPFBaixa .AND. !lCalcIssBx
						dbSelectArea("SEA")
						If dbseek(xFilial()+SE2->(E2_NUMBOR+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
							While !Eof() .and. SEA->(EA_NUMBOR+EA_PREFIXO+EA_NUM+EA_PARCELA+EA_TIPO+EA_FORNECE+EA_LOJA) == ;
									SE2->(E2_NUMBOR+E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
								If SEA->EA_CART == "P"
									Reclock("SEA",.F.,.T.)
									dbDelete()
									Exit
								Endif
								DbSkip()
							Enddo
						Endif
					Endif
					RecLock("SE2",.F.)
					If !lIRPFBaixa .AND. !lCalcIssBx
						SE2->E2_NUMBOR := Space(Len(SE2->E2_NUMBOR))
					EndIf
				Endif
			Endif

			If __lEAIF080
				llOpc  := ALTERA
				ALTERA := .F.  // Cancelamento de baixa.

				aEaiRet := FWIntegDef('FINA080',,,, 'FINA080')
				If !aEaiRet[1]
					Help(" ", 1, "HELP", STR0174, STR0175 + CRLF + aEaiRet[2], 3, 1)  // "Erro EAI" / "Problemas na integração EAI. Transação não executada."
					DisarmTransaction()
					Break
				Endif

				ALTERA := llOpc
			Endif
		End Transaction
		SA6->(DbSetOrder(nOrdSa6), DbGoto(nRecSa6))
	Endif

	//Finaliza a gravacao dos lancamentos do SIGAPCO
	PcoFinLan("000024")

	dbSelectArea(cAlias)
	If nSalvRec > 0
		dbGoTo(nSalvRec)
	EndIf
	dbSetOrder(nOrdem)
Return


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função    ³ F090Vldbx³ Autor ³ Mauricio Pequim Jr    ³ Data ³ 19/04/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Valida dados para baixa automática                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ F090VldBx()                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Gen‚rico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function F090VldBx(nTipoBx,lBxCnab,cBco090,cAge090,cCta090,cMotBx,oDlg,cCheq090,cBord090I,cBord090F,lAutomato,oRadio,lBcoExcl)
	Local nX
	Local lRet := .T.
	Local lWhen

	Default lAutomato := .F.
	Default lBcoExcl := .F.

	If !lAutomato
		For nX := 1 To Len(oDlg:aControls)
			If ValType(oDlg:aControls[nX]) == "O" .And.;
					!Empty(oDlg:aControls[nX]:bValid)
				lWhen := Eval(oDlg:aControls[nX]:bWhen)
				// So valida a condicao Valid, se passou pela condicao When
				If ValType(lWhen) != "L" .Or. lWhen
					lRet:=Eval(oDlg:aControls[nX]:bValid)
					If ValType(lRet) != "L"
						lRet := .T.
					Endif
					If !lRet
						Help(" ",1,"F090Erro",,STR0073,1,0) // "Campos obrigatórios não preenchidos"+chr(13)+"ou com valores inválidos"
						Exit // Sai no primeiro campo invalido
					Endif
				Endif
			Endif
		Next
	EndIf

	If ExistBlock("F090TOK")
		lRet := ExecBlock("F090TOK",.F.,.F.,{cBcoDe,cBcoAte,cBco090,cAge090,cCta090,cCheq090,cBord090I,cBord090F,dVencIni,dVencFim,nTipoBx,oRadio})
	Endif

	If lRet .and. nTipoBx == 2 .and. mv_par01 == 2 .and. lBxCnab
		If !Empty(cLoteFin)
			lRet := CheckLote("P", !lAutomato, cBco090)
		Else
			lRet := .F.
		Endif
	Endif

	//Verifica a conta corrente e se a mesma não está bloqueada
	NUMCHEQUE:=""
	If lRet .And. MovBcoBx(cMotBx,.T.)
		If !CarregaSa6(@cBco090,@cAge090,@cCta090,.T.,,.T.)
			lRet := .F.
		EndIf
	Endif

	If lRet
		if !Empty(cCheq090) .And. Substr(cCheq090,1,1)#"*"
			NUMCHEQUE := cCheq090
		Endif
	Endif

	If lRet .And. !IsBlind() .And. nTipoBx == 1 .And. lBcoExcl .And. !lAutomato .And. MovBcoBx(cMotBx,.T.)
		MsgAlert(STR0177, STR0180) //"Somente serão apresentados os títulos das filiais que tenham um cadastro de banco igual ao escolhido.", "Atenção"
	EndIf

Return lRet


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função    ³fa091Cheq ³ Autor ³ Mauricio Pequim Jr    ³ Data ³ 06/06/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³Valida cheque digitado, se digitado e diferente de '*'      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fa091Cheq()                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³FINA090                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fa091Cheq(cBanco090,cAgencia090,cConta090,cCheque090 )
	Local lRet    := .t.

	lRet := VldUser("EF_NUM") // Chama a validacao de usuario
	If lRet .And. !Empty(cCheque090) .And. Substr(cCheque090,1,1) # "*"
		SEF->(dbSetOrder(1))
		If SEF->( (dbSeek( cFilial + cBanco090 + cAgencia090 + cConta090 + cCheque090 ) ) )
			Help( " ",1,"F090Cheq" )
			lRet := .f.
		Endif
	Endif

Return lRet


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³Fa091bAval ³ Autor ³ Mauricio Pequim Jr.  ³ Data ³ 02/04/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Bloco de marcacoo       			          				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ Fa091bAval()		  										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA091													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Fa091bAval(cAliasSE2,cMarca,oValor,oQtda,oMark,nValor)

	Local lRet   := .T.
	Local lVld   := .F.
	Local lFA080 :=.T.
	Local nRecPA := 0

	SE2->(DBGOTO((cAliasSE2)->NUM_REG))

	// Verifica se o registro nao esta sendo utilizado em outro terminal
	If lFA080
		lRet:=FA080Integ(.F.)
	Endif
	If lRet
		If (cAliasSE2)->(MsRLock()) .AND. SE2->(MsRLock())
			If GetNewPar("MV_VLTITAD",.F.) .And. ( (cAliasSE2)->E2_OK <> cMarca )
				If F090VlMark(.F.,cAliasSE2,cMarca,oValor,oQtda,oMark,nValor,"FINA091")
					lVld := .T.
				Endif
			Else
				lVld := .T.
			Endif
			If lVld
				If SE2->E2_TIPO $ MVPAGANT
					//Verifica se PA possui movimentacao para permitir a baixa
					nRecPA := F080MovPA(.T.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
					If nRecPA < 1
						//Verifica se é PA de CNAB (Gera Ch para Adt = Não / Mov. Banc. sem Cheque = Não) - Nesse caso deve permitir a baixa para gerar mov. a pagar
						nRecPA := F080MovPA(.F.,SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_FORNECE,SE2->E2_LOJA)
						If nRecPA > 0
							lVld := .F.
							IW_MsgBox(STR0172,STR0072,"STOP")  //"Não é possível realizar a baixa de pagamento antecipado sem movimentação bancária."
						Else
							lVld := .T.
						Endif
					EndIf
				Endif
			Endif
			If lVld
				Fa091Inverte(cAliasSE2,cMarca,oValor,oQtda,.F.,oMark,,) // Marca o registro e trava
				lRet := .T.
			Else
				lRet := .F.
			Endif
		Else
			IW_MsgBox(STR0071,STR0072,"STOP")  //"Este titulo está sendo utilizado em outro terminal, não pode ser utilizado na fatura"###"Atenção"
			lRet := .F.
		Endif
	Endif
Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³F091VlMark ³ Autor ³ Cristiano Denardi    ³ Data ³ 18/04/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica na MarkBrowse se os titulos selecionados possuem   ³±±
±±³          ³Adiantamentos ou devolucoes   							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA090													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function F091VlMark(lGeral,cAliasA,cMarca,oValor,oQtda,oMark,nValor,cProg)

	Local aArea		:= GetArea()
	Local lMsg		:= .F.
	Local cMsg		:= ""
	Local lMarca 	:= .F.
	Local lRet	 	:= .T.
	Local lErro		:= .F.
	Local nPos		:= 1
	Local nBusca	:= 0
	Local nTamMark	:= 0
	Local aLog		:= {}

	Default lGeral := .T. // Define se verifica somente registro corrente ou todos registros
	Default cProg  := "FINA090"

	dbSelectArea(cAliasA)
	dbSetOrder(1)

	nTamMark	:= oMark:oBrowse:nLen

	If lGeral
		lMsg := .F.
		(cAliasA)->(DbGoTop())
	Else
		lMsg := .T.
	Endif

	If lGeral
		If MsgYesNo( STR0077 ) //"Gostaria que desmarque os titulos cujo Fornecedor possua Adiantamento ou Devolucao ?"
			lMarca := .T.
		Endif
	Endif

	While .T.

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Condicao para sair do While ³
		//³   Troca de todos Registros  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lGeral .And. ( nPos > nTamMark )
			Exit
		Endif

		If lGeral .And. (cAliasA)->E2_OK <> cMarca
			(cAliasA)->(DbSkip())
			nPos++
			Loop
		Endif

		nBusca := F091BuscAD( "__SE2", (cAliasA)->E2_FORNECE, (cAliasA)->E2_LOJA )

		If lMsg .And. nBusca <> 0
			cMsg := STR0078 //"O Fornecedor para este titulo possui "
		Endif

		Do Case
		Case nBusca == 1 // Adiantamento
			lRet := .F.
			If lMsg
				cMsg += STR0079 //"Adiantamento."
			Endif
		Case nBusca == 2 // Devolucao
			lRet := .F.
			If lMsg
				cMsg += STR0080 //"Devolucao."
			Endif
		Otherwise
			lRet  := .T.
		End Case

		If lGeral .And. nBusca <> 0
			lErro := .T.
			If lMarca .And. (cAliasA)->E2_OK == cMarca
				If cProg == "FINA090"
					Fa091Inverte(cAliasA,cMarca,oValor,oQtda,.F.,oMark,,)
				ElseIf cProg == "FINA240"
					FA240Inverte(cMarca,oValor,oQtda,.F.)
				Endif
			Endif
			/////////////////////////
			// Adiciona Array de LOG.
			Aadd( aLog, { 	(cAliasA)->E2_PREFIXO, (cAliasA)->E2_NUM    , (cAliasA)->E2_PARCELA, (cAliasA)->E2_TIPO,;
				(cAliasA)->E2_SALDO  , 	(cAliasA)->E2_FORNECE, (cAliasA)->E2_LOJA} )
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Usuario define se seleciona registro com ³
		//³ Adiantamento ou Devolucao.               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lRet .And. lMsg
			cMsg += chr(13)+chr(10)
			cMsg += STR0081 //"Deseja mesmo assim seleciona-lo ?"
			If MsgYesNo( cMsg )
				lRet := .T.
			Else
				lRet := .F.
			Endif
		Else
			lRet := .T.
		Endif

		(cAliasA)->(DbSkip())
		nPos++
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Condicao para sair do While ³
		//³   Troca do Registro atual   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lGeral
			Exit
		Endif
	Enddo

	RestArea( aArea )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza Tela ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	oValor:Refresh()
	oQtda:Refresh()
	oMark:oBrowse:Refresh(.T.)

	If lGeral
		lVldAD := .T.
		If !lErro
			MsgInfo(STR0082, STR0072) //"Nao existem titulos selecionados, cujos Fornecedores possuam Adiantamento ou Devolucao." / "Atenção"
		Else
			If MsgYesNo( STR0083 ) //"Gostaria de imprimir a lista de titulos cujos Fornecedores possuam Adiantamento ou Devolucao ?"
				F090PrtLog( aLog, cProg )
			Endif
		Endif
	Else
		lVldAD := .F.
	Endif

Return( lRet )


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³F091BuscAD ³ Autor ³ Cristiano Denardi    ³ Data ³ 18/04/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao que Busca para o titulo passado se existem Adianta-  ³±±
±±³          ³mentos ou devolucoes   							  		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA090													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function F091BuscAD( cAliasB, cFor, cLj )
	Local aArBusca	:= GetArea()
	Local nRet		:= 0
	Local lMFilial := (xFilial("SE2") == "  ")

	Default cAliasB	:= ""
	Default cFor	:= ""
	Default cLj 	:= ""

	If Select(cAliasB) <= 0
		SomaAbat("","","","P")
	Endif

	If !Empty(cAliasB) .And. !Empty(cFor) .And. !Empty(cLj)

		dbSelectArea(cAliasB)
		dbSetOrder(6)
		SE2->(DBGoTop())

		While !Eof() .And. ;
				( IIf(lMFilial,xFilial("SE2"),"")+cFor+cLj == IIf(lMFilial,(cAliasB)->E2_FILIAL,"")+(cAliasB)->E2_FORNECE+(cAliasB)->E2_LOJA )

			// So Processa titulos
			// com saldo
			If (cAliasB)->E2_SALDO <= 0
				dbSkip()
				Loop
			Endif

			// Adiantamento
			If (cAliasB)->E2_TIPO $ MVPAGANT
				nRet := 1
			Endif

			// Devolucao
			If (cAliasB)->E2_TIPO $ MV_CPNEG
				nRet := 2
			Endif

			If nRet <> 0
				Exit
			Endif

			DbSkip()

		EndDo

	Endif

	RestArea( aArBusca )
Return( nRet )


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³F090PrtLog ³ Autor ³ Cristiano Denardi    ³ Data ³ 18/04/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Imprime array com informacoes dos titulos cujos Fornecedores³±±
±±³          ³possuem Adiantamentos ou Devolucoes. 				  		 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA090													  				  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function F090PrtLog( aPrtLog, cProg )

	Local cDesc1		:= STR0084 //"Imprime relacao de titulos selecionados para baixa, "
	Local cDesc2		:= STR0085 //"cujos Fornecedores possuam Adiantamento ou Devolucao."
	Local cDesc3		:= ""
	Local titulo		:= STR0086 //"Tit. com Adiantamento ou Devolucao."
	Local nLin			:= 80
	Local Cabec1		:= "Pref Numero P Tipo             Valor - Fornec Lj"
	Local Cabec2		:= ""
	Local aOrd 			:= {}

	Private lEnd		:= .F.
	Private lAbortPrint	:= .F.
	Private limite		:= 80
	Private tamanho		:= "P"
	Private nomeprog	:= cProg
	Private nTipo		:= 18
	Private aReturn		:= { "Zebrado", 1, "Administracao", 2, 2, 1, "", 1}
	Private nLastKey	:= 0
	Private cbtxt		:= Space(10)
	Private cbcont		:= 00
	Private CONTFL		:= 01
	Private m_pag		:= 01
	Private wnrel		:= nomeprog
	Private cString 	:= ""

	wnrel := SetPrint(cString,NomeProg,"",@titulo,cDesc1,cDesc2,cDesc3,.T.,aOrd,.T.,Tamanho,,.T.)

	If nLastKey == 27
		Return
	Endif

	SetDefault(aReturn,cString)

	If nLastKey == 27
		Return
	Endif

	nTipo := If(aReturn[4]==1,15,18)

	RptStatus({|| RunReport(Cabec1,Cabec2,Titulo,nLin,aPrtLog) },Titulo)
Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³RUNREPORT  ³ Autor ³ Cristiano Denardi    ³ Data ³ 18/04/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA090													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function RunReport(Cabec1,Cabec2,Titulo,nLin,aPL)

	Local nP		:= 0
	Local nTamLog	:= Len(aPL)
	Local cPict		:= PesqPict("SE2","E2_SALDO")

	SetRegua( nTamLog )

	For nP := 1 To nTamLog

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica o cancelamento pelo usuario...                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If lAbortPrint
			@nLin,00 PSAY STR0087 //"*** CANCELADO PELO OPERADOR ***"
			Exit
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Impressao do cabecalho do relatorio. . .                            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If nLin > 55 // Salto de Página. Neste caso o formulario tem 55 linhas...
			Cabec(Titulo,Cabec1,Cabec2,NomeProg,Tamanho,nTipo)
			nLin := 8
		Endif

		@ nLin,01 PSAY aPL[nP][1] // Prefixo (3)
		@ nLin,05 PSAY aPL[nP][2] // Numero Tit (6)
		@ nLin,12 PSAY aPL[nP][3] // Parcela (1)
		@ nLin,14 PSAY aPL[nP][4] // Tipo (3)
		@ nLin,18 PSAY aPL[nP][5] Picture cPict // Saldo (17)
		@ nLin,36 PSAY " - "
		@ nLin,39 PSAY aPL[nP][6] // Fornecedor (6)
		@ nLin,46 PSAY aPL[nP][7] // Loja Fornecedor (2)

		nLin := nLin + 1 // Avanca a linha de impressao

	Next nP

	SET DEVICE TO SCREEN

	If aReturn[5]==1
		dbCommitAll()
		SET PRINTER TO
		OurSpool(wnrel)
	Endif

	MS_FLUSH()

Return


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função	 ³fa091CX   ³ Autor ³ Adilson H Yamaguchi   ³ Data ³ 05/05/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Funcao que abre ou n„o o get do n§ de cheque na baixa 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fa091CX()																  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA090																	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fa091CX(cBanco, lBord)
	Local lRet := .T.
	// Nao habilita o numero de cheque para :
	// Banco Caixa, Carteira ou Motivo igual a D‚bito em C/C
	If SubStr(cBanco,1,2) == "CX"       .or. ;
			cBanco $ GetMv("MV_CARTEIR")     .or. ;
			TrazCodMot(cMotBx) $ "DEB/DAC"   .or. ;
			! ChqMotBx(cMotBx)				   .or. ;
			(lBord .And. GetMv("MV_CHQBOR") == "N")
		lRet := .F.
	Endif
Return lRet


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³MenuDef   ³ Autor ³ Ana Paula N. Silva     ³ Data ³22/11/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Utilizacao de menu Funcional                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array com opcoes da rotina.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Parametros do array a Rotina:                               ³±±
±±³          ³1. Nome a aparecer no cabecalho                             ³±±
±±³          ³2. Nome da Rotina associada                                 ³±±
±±³          ³3. Reservado                                                ³±±
±±³          ³4. Tipo de Transação a ser efetuada:                        ³±±
±±³          ³		1 - Pesquisa e Posiciona em um Banco de Dados     ³±±
±±³          ³    2 - Simplesmente Mostra os Campos                       ³±±
±±³          ³    3 - Inclui registros no Bancos de Dados                 ³±±
±±³          ³    4 - Altera o registro corrente                          ³±±
±±³          ³    5 - Remove o registro corrente do Banco de Dados        ³±±
±±³          ³5. Nivel de acesso                                          ³±±
±±³          ³6. Habilita Menu Funcional                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MenuDef()
	Local aRotina := {}
	If cPaisLoc == "BRA"
		aRotina	:=	{	{ STR0057, "AxPesqui"    ,0,1},; // "Pesquisar"
						{ STR0001, "fA091Par"    ,0,1},; // "Parƒmetros"
						{ STR0002, "fA091Aut"    ,0,3},; // "Automática"
						{ STR0136, "FA091CAUT"   ,0,1},; // "Cancelamento Automático de Baixas"
						{ STR0061, "FA040Legenda",0,6} }
	Else
		aRotina	:=	{	{ STR0057, "fA091Busca"	 ,0,1},; // "Pesquisar"
						{ STR0001, "fA091Par"	 ,0,1},; // "Parƒmetros"
						{ STR0002, "fA091Aut"	 ,0,4},; // "Automática"
						{ STR0136, "FA091CAUT"   ,0,1},; // "Cancelamento Automático de Baixas"
						{ STR0058, "fA091Can"	 ,0,5},; // "Cancela Chq"
						{ STR0061, "FA040Legenda",0,6} } // "Legenda"
	EndIf

	//Rateio Multinatureza
	If FindFunction("F050CMNT") .and. MV_MULNATP
		aAdd( aRotina,	{ STR0162 ,"F050CMNT()", 0 , 2})	//"Consulta Rateio Multi Naturezas"
	Endif

	If FindFunction("FTemMotor") .And. FTemMotor()
		Aadd(aRotina, {STR0178, "FINCRET('SE2')", 0, 2}) //"Consulta retenções"
	EndIf

Return(aRotina)

//-------------------------------------------------------------------
/*{Protheus.doc} FA091CKUS
função ira verificar quais filais estão acessiveis pelo usuario logado

@param 	cFilIni - Filial Inicial
cFilFim - Filail Final


@author Caio Quiqueto
@since 21/07/2015
@version P11

@return Array{lAceCompl,aRet
lAceCompl - se o usuario tem acesso a todas as filais do Grupo de empresas
aRet - array com todas as filais que o usuario tem acesso no Grupo de empresas
*/
//-------------------------------------------------------------------
function FA091CKUS(aSelFil)
	Local aSM0	:= FWLoadSM0()	//Carrega as informações das filiais
	Local GrpCorr	:= FWGrpCompany ()	// Retorna o grupo de empresas utilizada pelo Sistema.
	Local nX	:= 1
	Local nGrpCont := 0
	Local aRet := {}
	Local lAceCompl := .F.

	DEFAULT aSelFil := {}

	//ordena o array de filial por grupo e código de filial
	aSM0 := asort(aSM0,,,{|X,Y| X[1]+X[2] < Y[1]+Y[2]})

	//posiciona no primeiro registro do grupo logado
	nX := aScan(aSM0,{|X| X[1] == GrpCorr})

	while aSM0[nX][1] = GrpCorr
		If aSM0[nX][11] .AND. IF(LEN(aSelFil)>0,ASCAN(aSelFil,{|e| e == aSM0[nX][2]}) > 0,.T.)
			aADD(aRet, xFilial( "SE2", aSM0[nX][2] ))
		EndIf
		If nX == Len(aSM0)
			Exit
		EndIf
		nGrpCont ++
		nX ++
	enddo

	if nGrpCont = len(aRet)
		lAceCompl := .T.
	EndIf

return {lAceCompl,aRet}

//-------------------------------------------------------------------
/*{Protheus.doc} Fa091MnFil
Função responsavel por criar filtro para Filiais a partir de um array

@param	aFiluser - array com todas as filais para criação o filtro

@author Caio Quiqueto
@since 21/07/2015
@version P11

@return cRet - string do filtro para todas as filiais
*/
//-------------------------------------------------------------------

FUNCTION Fa091MnFil(aFiluser)
	Local cRet		:= ''
	Local nX		:= 0
	Local cRetOld	:= ""
	Local nRecSM0	:= SM0->(Recno())

	For nX := 1 to len(aFiluser)  Step 1
		cRet += aFiluser[nX] + "|"
	next

	/*Esse tratamento só será executado em casos que o sigamat possua no mínimo
	de 400 filiais. Nesse caso monta o novo filtro com as filiais que o user não
	possui acesso a fim de usar o menor filtro na IndRegua*/
	If Len(cRet) > 1500
		cRetOld := cRet
		SM0->(dbGotop())

		While SM0->(!EOF())
			If !AllTrim(xFilial("SE2",SM0->M0_CODFIL)) $ cRetOld
				cRet += AllTrim(xFilial("SE2",SM0->M0_CODFIL)) + "|"
			EndIf
			SM0->(dbSkip())
		EndDo

		If Len(cRet) > Len(cRetOld)
			cRet := cRetOld
		EndIf

		SM0->(dbGoto(nRecSM0))
	EndIf

return cRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³F090RcSE5 ºAutor  ³Daniel Mendes      º Data ³  17/10/14    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna o RecNo do título principal conforme array populado º±±
±±º          ³caso contrário retorna  posição da SE5 se a mesma estiver   º±±
±±º          ³posicionada                                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³FinA090                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function F090RcSE5(aRecNosSE5)
	Local nRecSE5 := 0

	If !Empty( aRecNosSE5 )
		nRecSE5 := aRecNosSE5[ Len( aRecNosSE5 ) ]
	Else
		If !SE5->(Eof()) .And. !SE5->(Bof())
			nRecSE5 := SE5->(RecNo())
		EndIf
	EndIf

Return nRecSE5

/*
±±ºPrograma  ³FA091PcoLan ºAutor ³ ANDRE.LUIZ º Data ³  15/08/16         º±±
±±ºDescricao ³ Verifica e efetua o bloqueio na confirmacao da tela de    º±±
±±º          ³ baixa automatica, se utilizada a integracao e configuracaoº±±
±±º          ³ de lancamento de bloqueio do SIGAPCO.                     º±±
±±ºParametros³ EXPC1 - Indica que o titulo/bordero esta marcado          º±±
±±ºUso       ³ Integracao PCO x Baixa de titulos automatica              º±±
*/
Function FA091PcoLan(cMarca)
	Local lRet	:= .T.
	Local aArea := GetArea()

	(cAliasSE2)->(dbSetOrder(__nIdxE2OK))
	(cAliasSE2)->(dbSeek(cMarca))
	SE2->(DBGOTO((caliasSE2)->NUM_REG))
	Do While (cAliasSE2)->(!Eof() .AND. E2_OK == cMarca)
		SE2->(DBGOTO((caliasSE2)->NUM_REG))
		RegToMemory("SE2",.F.)
		lRet := PcoVldLan("000024", "01", "FINA091")
		If !lRet
			Exit
		EndIf
		(cAliasSE2)->(dbSkip())
	EndDo
	RestArea( aArea )
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} f091QryA

Faz a query de filtro dos titulos

@author Karen Honda
@since 22/09/2017
@version P12
/*/
//-------------------------------------------------------------------
Static Function F091QryA(aSelFil,aTMPFil,aCampos,aEstruct,nTipoBX,cBord090I,cBord090F,cBco090,cAge090,cCta090)
	Local cQuery := ""
	Local cFiltro := ''

	DEFAULT aEstruct := {}
	IF !EMPTY(aEstruct)
		// Constroi a clausula de filtro da seleção
		cFiltro := FA091ChecF(nTipoBx,cBord090I,cBord090F,aSelFil,aTMPFil,cBco090,cAge090,cCta090)
		cQuery  := "SELECT "
		aEval(aEstruct,{|x| cQuery += x[1] + ", "})
		If cPaisLoc = "ARG"
			cQuery += "SE2.R_E_C_N_O_ NUM_REG "
			cQuery += "FROM " + RetSqlName("SE2") + " SE2 "
			cQuery += "INNER JOIN " + RetSqlName("SEF") + " ON E2_PREFIXO+E2_NUM = EF_PREFIXO+EF_NUM AND E2_BCOCHQ+E2_AGECHQ+E2_CTACHQ = EF_BANCO+EF_AGENCIA+EF_CONTA "
			cQuery += "WHERE "
			cQuery += "SE2.D_E_L_E_T_ = ' ' AND "
		Else
			cQuery += "R_E_C_N_O_ NUM_REG "
			cQuery += "FROM " + RetSqlName("SE2") + " "
			cQuery += "WHERE "
			cQuery += "D_E_L_E_T_ = ' ' AND "
		EndIf
		cQuery += cFiltro + " "
		If cPaisLoc = "ARG"
			cQuery += "AND EF_STATUS = '03'"
		Endif
		cQuery += "ORDER BY " + SqlOrder(SE2->(indexkey()))
		cQuery := ChangeQuery(cQuery)

		cArqNew := F091MTTMP(cQuery,aCampos,aEstruct,cBord090I,cBord090F,@cBco090,@cAge090,@cCta090,nTipoBx)
	ENDIF

Return cArqNew
//-------------------------------------------------------------------
/*/{Protheus.doc} F090MTTMP

Monta a temporaria da query

@author Karen Honda
@since 22/09/2017
@version P12
/*/
//-------------------------------------------------------------------
Static Function F091MTTMP(cQuery,aCampos,aEstruct,cBord090I,cBord090F,cBco090,cAge090,cCta090,nTipoBx)

	Local nTcSql		:= 0
	Local aArea			:= GetArea()
	Local cQuery2		:= ''
	Local cCampos		:= ''
	Local cChave		:= ""
	Local nTamEFNUM		:= TamSX3('EF_NUM')[1]

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Montagem dos campos na Array  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If aScan(aEstruct, {|x| Alltrim(UPPER(x[1])) == Alltrim(UPPER("NUM_REG"))}) == 0
		AADD(aEstruct,{"NUM_REG","N",10,0})
	Endif

	AADD(aEstruct,{"VLSOMAABAT","N",14,2})
	AADD(aEstruct,{"HASCLCABAT","C",1,0})
	AADD(aEstruct,{"HASCLCTRIB","C",1,0})
	AADD(aEstruct,{"IMPCONF","C",250,0})

	//Deleta a tabela temporária no banco de dados, caso já exista
	If _oFINA0901 <> Nil
		_oFINA0901:Delete()
		_oFINA0901 := Nil
	Endif

	// Criação da Tabela Temporßria >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	_oFINA0901 := FWTemporaryTable():New( cAliasSE2 )
	_oFINA0901:SetFields(aEstruct)
	_oFINA0901:AddIndex("1", {"E2_FILIAL","E2_PREFIXO","E2_NUM","E2_PARCELA","E2_TIPO"})
	_oFINA0901:AddIndex(TRIM(STR(__nIdxE2OK)), {"E2_OK","E2_FILIAL","E2_PREFIXO","E2_NUM","E2_PARCELA","E2_TIPO"})
	_oFINA0901:AddIndex("3", {"NUM_REG"})
	_oFINA0901:AddIndex("4", TTFtIndex(StrToKarr(SE2->(indexkey()),"+"))) // Indice Ativo na Browse

	_oFINA0901:Create()

	cQuery2 := " INSERT "
	If ALLTRIM(tcGetdb()) == "ORACLE"
		cQuery2 += " /*+ APPEND */ "
	Endif

	aEval(aEstruct,{|x| cCampos += If( 'E2_' $ x[1] .OR. 'IMPOSTOS' == x[1], ALLTRIM(x[1]) + ',', '')})

	cCampos += ' NUM_REG'

	If AllTrim(TcGetDb()) == "DB2"
		cQuery := STRTRAN( cQuery, "FOR READ ONLY", "" )
	EndIf

	cQuery2 += " INTO "+_oFINA0901:GetRealName()+" ("+cCampos+") " + STRTRAN(cQuery,'IMPOSTOS','0 AS IMPOSTOS')

	Processa({|| nTcSql := TcSQLExec(cQuery2)})

	If nTcSql < 0
		Help(" ",1,"F090MTTMP",, STR0167,1,0) //"Não foi possivel montar a tabela temporaria, favor verificar o seu ambiente Protheus."
	EndIf

	(cAliasSE2)->(DBSETORDER(4))
	(cAliasSE2)->(DBGOTOP())
	// ---------------------------------------------------------------------------------------

	While !(cAliasSE2)->(EOF())

		SE2->(DBGoto((cAliasSE2)->NUM_REG))

		If cPaisLoc=="BRA"

			// Se for um titulo de adiantamento, verifica se existem cheques nao liberados, pois se existir, nao permitir a baixa
			// Isso ocorre quando o parametro MV_LIBCHEQ esta igual a N, foi gerado um cheque para o adiantamento e este
			// ainda nao foi liberado
			If Alltrim(SE2->E2_TIPO) $ MVPAGANT
				SEF->(DbSetOrder(3))
				SEF->(MsSeek(xFilial("SEF")+(cAliasSE2)->( E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+Pad(E2_NUMBCO,nTamEFNUM) )))
				If SEF->EF_LIBER == "N"
					(cAliasSE2)->(DbDelete())
					(cAliasSE2)->(DbSkip())
					Loop
				EndIf
			EndIf

			// Para o Brasil, apresenta somente os titulos cuja moeda e' a mesma do banco selecionado para baixa.
			// Caso a moeda do banco estiver vazia ou caso o motivo de baixa nao movimente banco, considero apenas a moeda forte
			If FXMultSld()
				If nMoedaBco > 1 .And. MovBcoBx(cMotBx,.T.)
					If !FXVldBxBco(cBco090,cAge090,cCta090,(cAliasSE2)->E2_NATUREZ, (cAliasSE2)->E2_MOEDA,.F.)
						(cAliasSE2)->(DbDelete())
						(cAliasSE2)->(DbSkip())
						Loop
					EndIf
				Endif
			EndIf

		EndIf

		If cPaisLoc $ "ARG|DOM|EQU" .and. FUNNAME()=="FINA095"
			If cPaisLoc=="ARG"
				cChave := xFilial('SEF') + "P" + cBco090 + cAge090 + cCta090 + SUBSTR((cAliasSE2)->E2_NUM,1,nTamEFNUM) + (cAliasSE2)->E2_PREFIXO
			Else
				cChave := xFilial('SEF') + "P" + cBco090 + cAge090 + cCta090 + SUBSTR((cAliasSE2)->E2_NUMBCO,1,nTamEFNUM) + (cAliasSE2)->E2_PREFIXO
			Endif

			If !FA090StChq(cChave)
				(cAliasSE2)->(DbDelete())
				(cAliasSE2)->(DbSkip())
				Loop
			EndIf

		Endif

		//Retenções geradas na emissão
		If _lTemMR
			(cAliasSE2)->IMPOSTOS := FMRGETRET("P", "SE2")
		Endif

		//Ponto de Entrada para tratamentos específicos de exclusão dos registros
		If (__F090VLEX)
			Execblock("F090VLEX", .F., .F., {cMotBx, nTipoBx, nMoedaBco})
		EndIf

		(cAliasSE2)->(DbSkip())
	EndDo

	RestArea(aArea)

Return cAliasSE2

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F091Clean

Limpa o objeto da temporarytable

@Author	Karen Yoshie Honda
@since	29/08/2017
/*/
//-----------------------------------------------------------------------------------------------------
Static Function F091Clean()

	If _oFINA0901 <> Nil
		_oFINA0901:Delete()
		_oFINA0901 := Nil
	Endif

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} function F91FORMATIN
Formata separadores de string para uso em cláusula IN de queries.
@author  Norberto M de Melo
@since   03/01/2017
@version P12
/*/
//-------------------------------------------------------------------
Static Function F91FORMATIN(cString as character) as character

	DEFAULT cString := ''

	cString	:=	StrTran(cString,',','/')
	cString	:=	StrTran(cString,';','/')
	cString	:=	StrTran(cString,'|','/')
	cString	:=	StrTran(cString,'\','/')

	cString := Formatin(cString,"/")

Return cString

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} Fa091Display

Atualiza a flag na tabela temporaria após atualização da SE2

@Author	Karen Yoshie Honda
@since	29/08/2017
/*/
//-----------------------------------------------------------------------------------------------------

Static Function Fa091Display(cAliasSE2,cMarca,lInverte,oValor,oQtda,cArquivo,lBaixa)
	FinaDisplay(cMarca,lInverte,oValor,oQtda,cArquivo,,lBaixa)

	If (cAliasSE2)->(MsRLock())
		(cAliasSE2)->E2_OK	:= SE2->E2_OK
		(cAliasSE2)->(MsUnlock())
	EndIf
Return
//-----------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F091GETABAT
Esta função Verifica se o calculo da função SumAbatPag() já foi efetuado para o registro atual de cAliasSE2
@type function
@author Karen Yoshie Honda
@since 04/08/2017
@version 1.0
@return $numerico, $Valor de Abatimento do título posicionado, caso houver.
@example
nTotAbat := F091GETABAT()
/*/
//-----------------------------------------------------------------------------------------------------------------------
STATIC FUNCTION F091GETABAT() as NUMERIC
	Local nRet		as NUMERIC

	//Inicialização
	nRet	:= 0

	IF (cAliasSE2)->HASCLCABAT == '1'
		nRet := (cAliasSE2)->VLSOMAABAT
	Else
		nRet := SumAbatPag(SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_FORNECE, SE2->E2_MOEDA, "V", SE2->E2_BAIXA, SE2->E2_LOJA)
		(cAliasSE2)->VLSOMAABAT := nRet
		(cAliasSE2)->HASCLCABAT := '1'
	ENDIF

RETURN nRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F091GetCampos
Preenche 2 arrays de campos, sendo: 1 para exibição em MarkBrowse e 1 para criação de tabela temporaria.
@author  Norberto Monteiro de Melo
@since   12/01/2018
@version P12
/*/
//-------------------------------------------------------------------
STATIC FUNCTION F091GetCampos(aCampos as ARRAY, aEstruct as ARRAY)
	Local cIndex As Character
	Local cCampoSX3 As Character
	Local aRestrict As Array
	Local nX As Numeric

	Default aCampos  := {}	// Campos para o MarkBrowse - Deve ser passado por referência
	Default aEstruct := {}	// Campos para a tabela temporária - Deve ser passado por referência

	//campos do indice do browse
	cIndex := SE2->(INDEXKEY())
	aRestrict := StrToKArr(cIndex,'+')
	cCampoSX3 := ""
	nX := 0

	For nX := 1 To Len(aRestrict)
		aRestrict[nX] := FinExtCpo("SE2",aRestrict[nX])
	Next

	/**Implementação */
	AADD(aCampos,{"E2_OK","","  ",""})
	AADD(aEstruct,{"E2_OK","C",2,0})

	//Busca a filial para adicionar ao lado da coluna OK
	//Dessa forma não teremos problemas caso a filial não seja a primeira coluna da SE2
	dbSelectArea("SX3")
	SX3->(dbSetOrder(2))
	SX3->(dbSeek("E2_FILIAL"))

	// Sempre adiciona o campo E2_FILIAL na estrutura
	AADD(aEstruct,{X3_CAMPO,X3_TIPO,X3_TAMANHO,X3_DECIMAL})

	// Apenas adiciona o campo E2_FILIAL se SE2 estiver exclusiva.
	If !Empty( _cFilFwSE2 ) .Or. X3USO(SX3->x3_usado) .And. cNivel >= SX3->x3_nivel
		AADD(aCampos,{SX3->X3_CAMPO,"",X3Titulo(),SX3->X3_PICTURE})
	EndIf
	
	//Posiciona no dicionário das colunas da SE2
	SX3->(dbSetOrder(1))
	SX3->(dbSeek("SE2"))

	// Processa o restante das colunas adicionando aquelas que passam pela regra.
	While !EOF() .And. (SX3->X3_ARQUIVO == "SE2")
		cCampoSX3 := AllTrim(upper(SX3->X3_CAMPO))

		If cCampoSX3 != "E2_FILIAL"	//não adiciono novamente a filial

			If ((ASCAN(aRestrict,{|x| AllTrim(upper(x)) == cCampoSX3 }) > 0) .Or. ;
				(SX3->X3_TIPO != "M" .And. X3USO(SX3->X3_USADO) .AND. cNivel >= SX3->X3_NIVEL .And. SX3->X3_CONTEXT != "V") .Or.;
				cCampoSX3 $ "E2_SALDO|E2_NUMBCO|E2_FATURA|E2_FATPREF" ) 
				
				IF !(TRIM(SX3->X3_CAMPO) $ __LstImp)
					AADD(aCampos,{SX3->X3_CAMPO,"",X3Titulo(),SX3->X3_PICTURE})
				ENDIF

				AADD(aEstruct,{SX3->X3_CAMPO,SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})

				IF cCampoSX3 == "E2_VALOR"
					AADD(aCampos,{'IMPOSTOS','','Retenções',SX3->X3_PICTURE})
					AADD(aEstruct,{'IMPOSTOS',SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})
				ENDIF
			Endif
		Endif
		SX3->(dbSkip())
	Enddo

RETURN NIL
//-------------------------------------------------------------------
/*/{Protheus.doc} F091VldImp()
Cálculo dos impostos a serem retidos
@author  Sivaldo Oliveira
@since 20/02/2018
@version 12
/*/
//-------------------------------------------------------------------
Static Function F091VldImp(lCancel As Logical)
	Local nZ As Numeric
	Local nImpos As Numeric
	Local nBasMR As Numeric
	Local aImpos As Array
	Local aBasMR As Array
	Local aImpConf As Array
	Local nCasDec as Numeric
	Local lBordero As Logical
	Local aBaseImp As Array
	Local nBaseDif As Numeric
	Local cIdFK0 As Character
	Local cChaveTit As Character

	Default lCancel := .F.

	//Inicilaiza variaveis
	nZ := 0
	nImpos := 0
	nBasMR := 0
	aImpos := {}
	aBasMR := {}
	aImpConf := {}
	nCasDec := (MsDecimais(1) + 1)
	lBordero := (SE2->E2_PRETPIS == '4' .OR. SE2->E2_PRETCOF == '4' .OR. SE2->E2_PRETCSL == '4' .Or. !Empty(SE2->E2_NUMBOR))
	aBaseImp := {}
	nBaseDif := 0
	cIdFK0 := ""
	_lPccMR := .F.
	_lIrfMR := .F.
	_lInsMR := .F.
	_lIssMR := .F.
	_lCidMR := .F.
	_lSesMR := .F.
	_lImpMR := .F.
	_lPccBxMR := .F.
	_nPisMR := 0
	_nCofMR := 0
	_nCslMR := 0
	_nIrfMR := 0
	_nInsMR := 0
	_nIssMR := 0
	_nCidMR := 0
	_nSesMR := 0
	_nImpMR := 0
	_aImpMR := {}

	//Valida quais os impostos configurados pelo motor de retenções
	If !SE2->E2_TIPO $ MVPAGANT+"|"+MVABATIM+"|"+MVPROVIS+"|"+MV_CPNEG+"|"+MVTAXA+"|"+MVTXA+"|INA"
		aImpConf := FinImpConf("1", SE2->E2_FILORIG, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_NATUREZ, SE2->E2_TIPO)
		nImpos := Len(aImpConf)

		For nZ := 1 To nImpos
			Do Case
			Case aImpConf[nZ,1] $ "PIS|COF|CSL"
				_lPccMR := .T.
				_lPccBxMR := aImpConf[nZ,2] == "2"
			Case aImpConf[nZ,1] == "IRF"
				_lIrfMR := .T.
			Case aImpConf[nZ,1] == "INSS"
				_lInsMR := .T.
			Case aImpConf[nZ,1] == "ISS"
				_lIssMR := .T.
			Case aImpConf[nZ,1] == "CIDE"
				_lCidMR := .T.
			Case aImpConf[nZ,1] == "SEST"
				_lSesMR := .T.
			OtherWise
				_lImpMR := .T.
			EndCase

			//Retenção na primeira baixa
			If aImpConf[nZ,7] == "1"
				nBaseDif := SE2->E2_VALOR

				If SE2->E2_MOEDA > 1
					nBaseDif := NoRound(xMoeda(nBaseDif, SE2->E2_MOEDA, 1, dBaixa, nCasDec, SE2->E2_TXMOEDA), nCasDec)
				EndIf

				Aadd(aBaseImp, {aImpConf[nZ,1], nBaseDif})
			EndIf
		Next nZ

		//busca chave p/ verificar se já houve retenção, se conf retenção na 1ª baixa
		cChaveTit := xFilial("SE2", SE2->E2_FILORIG)+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA

		//Impostos gerado pelo fiscal
		If nImpos == 0
			nImpos := Len(aImpConf := FinImpFis(cChaveTit, SE2->E2_FILORIG, "SE2", .F., 0, Nil, SE2->E2_FORNECE, SE2->E2_LOJA))
		EndIf
	EndIf

	If !lCancel .And. !lBordero .And. nImpos > 0
		/*-------------------------------------------
		Estrutura da aBasMR
		[1] = base de retenção
		[2] = Imp retidos na emissão motor de retenção
		[3] = Imp retidos Bx.MR e antigo que recompoem base
		-------------------------------------------*/
		nBasMR := SE2->E2_SALDO

		aBasMR := FinBaseMR(nBasMR, .F., SE2->E2_FILIAL, SE2->E2_PREFIXO, SE2->E2_NUM, SE2->E2_PARCELA, SE2->E2_TIPO, SE2->E2_FORNECE, SE2->E2_LOJA,;
			_lPccMR, _lIrfMR, _lInsMR, _lIssMR, _lCidMR, _lSesMR, SE2->E2_MOEDA, SE2->E2_TXMOEDA, dBaixa)

		For nZ := 1 To Len(aBasMR)
			If nZ == 1
				nBasMR := aBasMR[nZ]
				exit
			EndIf
		Next nZ

		If SE2->E2_MOEDA > 1
			nBasMR := NoRound(xMoeda(nBasMR, SE2->E2_MOEDA, 1, dBaixa, nCasDec, SE2->E2_TXMOEDA), nCasDec)
		EndIf

		If Len(aBaseImp) > 0
			cIdFK0 := FINGRVFK7("SE2", cChaveTit)
		EndIf

		//Cálculo motor de retenções.
		aImpos := FINCalImp("1", SE2->E2_NATUREZ, SE2->E2_FORNECE, SE2->E2_LOJA, SE2->E2_FILORIG, nBasMR, dBaixa, .T., aBaseImp, SE2->E2_TIPO, cChaveTit, cIdFK0, {})
		nImpos := Len(aImpos)

		For nZ := 1 To nImpos
			If (aImpos[nZ,9] != "2") .Or. (aImpos[nZ,13] != "1") .Or. (aImpos[nZ,14] != "1")
				Loop
			EndIf

			//Vlr de imps a ser abatido do valor a de pagto
			_nImpMR += aImpos[nZ,5]

			//Variáveis para gravar os Vrets.
			Do Case
			Case aImpos[nZ,8] == "PIS"
				_nPisMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "COF"
				_nCofMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "CSL"
				_nCslMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "IRF"
				_nIrfMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "INSS"
				_nInsMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "ISS"
				_nIssMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "CIDE"
				_nCidMR += aImpos[nZ,5]
			Case aImpos[nZ,8] == "SEST"
				_nSesMR += aImpos[nZ,5]
			EndCase
		Next nZ

		_aImpMR := Aclone(aImpos)
		_nBasLeg := nBasMR
	EndIf

Return Nil


//-------------------------------------------- CANCELAMENTO AUTOMATICO DE BAIXAS -----------------------------------------------------------------

//--------------------------------------------------------------------------------------
/*/{Protheus.doc}FA091CAUT
Filtros para montagem do grid de Títulos a Pagar, visando cancelamento das suas baixas
@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//--------------------------------------------------------------------------------------
Function FA091CAUT(cAlias,cCampo,nOpcE, lAutomato)

Local cBord1 := Space(6)
Local cBord2 := Space(6)
Local cDatB1 := CTOD("//")
Local cDatB2 := CTOD("//")
Local cFor1	:= Space(6)
Local cFor2 := Space(6)
Local nX := 0
Local nRadio := 1
Local nOpca := 0
Local aRadio := {}
Local aSelFil := {}
Local aTmpFil := {}
Local lSelFilial := .F.
Local oSize := NIL
Local oMasterPanel := NIL
Local oDlg1 := NIL
Local oSelFil := NIL
Local bProcessa
Local oPanel1 := NIL

Private oBord1
Private oBord2
Private oDatB1
Private oDatB2
Private oFor1
Private oFor2

DEFAULT lAutomato := .F.

If !lAutomato
	aAdd(aRadio, STR0066)	//"Títulos"
	aAdd(aRadio, STR0067)	//"Borderôs"

	DEFINE MSDIALOG oDlg1 TITLE STR0137 OF oMainWnd PIXEL FROM 050,010 TO 324,340 // "Cancelamento Automático de Baixas a Pagar"

	//Defino o tamanho dos componentes através do método FwDefSize(), amarrando ao objeto oDlg
	oSize := FwDefSize():New(.F.,,,oDlg1)

	oSize:lLateral := .F.
	oSize:lProp := .T.
	oSize:AddObject("MASTER",100,100,.T.,.T.)
	oSize:Process()

	//Instancio um painel "master" como container
	oMasterPanel := TPanel():New(oSize:GetDimension("MASTER","LININI"),oSize:GetDimension("MASTER","COLINI"),;
					,oDlg1,,,,,,oSize:GetDimension("MASTER","XSIZE"),oSize:GetDimension("MASTER","YSIZE"),.F.,.F.)

	oPanel1 := TPanel():New(0,0,'',oMasterPanel,, .T., .T.,, ,115,115,.f.,.f. )
	oPanel1:Align := CONTROL_ALIGN_ALLCLIENT

	@ 05,005 TO 117,158 PROMPT ""  PIXEL OF oPanel1

	@ 06,010 TO 33,150 PROMPT STR0138 PIXEL OF oPanel1		//  "Cancelar Baixas"
	@ 12,063 RADIO oRadio VAR nRadio ITEMS aRadio[1],aRadio[2]  SIZE 080,209 PIXEL OF oPanel1 ON CHANGE Fa091Radio(nRadio,@cBord1,@cBord2,@cDatB1,@cDatB2,@cFor1,@cFor2)

	@ 35,010 SAY STR0139	SIZE 555,10 PIXEL OF oPanel1  	// "Borderô De"
	@ 43,010 MSGET oBord1 	VAR cBord1	PICTURE  "@S6"  OF oPanel1  SIZE 060,10 PIXEL

	@ 35,085 SAY STR0140	SIZE 555,10 PIXEL OF oPanel1  // "Borderô Até"
	@ 43,085 MSGET oBord2	VAR cBord2	PICTURE  "@S6"  OF oPanel1  SIZE 060,10 PIXEL

	@ 55,010 SAY STR0141	SIZE 555,10 PIXEL OF oPanel1	//"Dt. Baixa De"
	@ 63,010 MSGET oDatB1	VAR cDatB1	   PICTURE "@!"	   OF oPanel1 SIZE 060,10 PIXEL HASBUTTON

	@ 55,085 SAY STR0142	SIZE 555,10 PIXEL 	OF oPanel1	//"Dt. Baixa Ate"
	@ 63,085 MSGET oDatB2	VAR cDatB2	PICTURE "@!"	   OF oPanel1 SIZE 060,10 PIXEL HASBUTTON

	@ 75,010 SAY STR0143	SIZE 555,10 PIXEL OF oPanel1	// "Fornecedor De"
	@ 83,010 MSGET oFor1	VAR cFor1   F3 "FOR" 	PICTURE "@!"  OF oPanel1  SIZE 060,10 PIXEL HASBUTTON

	@ 75,085 SAY STR0144	SIZE 555,10 PIXEL OF oPanel1	//"Fornecedor Ate"
	@ 83,093 MSGET oFor2	VAR cFor2	F3 "FOR"    PICTURE "@!"  OF oPanel1  SIZE 060,10 PIXEL HASBUTTON

	@ 100,010 CHECKBOX oSelFil VAR lSelFilial PROMPT "" SIZE 11,11 OF oPanel1 PIXEL
	@ 100,020 SAY STR0168 SIZE 50, 07 OF oPanel1 PIXEL	//"Seleciona Filiais"

	DEFINE SBUTTON FROM 120,093 TYPE 1 ACTION (nOpca := 1,If(Fa091ValOk(nRadio,cBord1,cBord2,cDatB1,cDatB2,cFor1,cFor2), oDlg1:End(), nOpca:=0))  ENABLE OF oPanel1
	DEFINE SBUTTON FROM 120,122 TYPE 2 ACTION oDlg1:End()  ENABLE OF oPanel1

	oDatB1:disable()
	oDatB2:disable()
	oFor1:disable()
	oFor2:disable()
	oBord1:disable()
	oBord2:disable()

	If Empty(cFor2)
		cFor2 := Replicate("Z",Len(SE2->E2_FORNECE))
		cBord2 := Replicate("Z",Len(SEA->EA_NUMBOR))
	Endif

	ACTIVATE MSDIALOG oDlg1 CENTERED ON INIT Fa091Radio(nRadio,@cBord1,@cBord2,@cDatB1,@cDatB2,@cFor1,@cFor2)

Else
	If FindFunction("GetParAuto")
		aRetAuto	:= GetParAuto("FINA091TESTCASE")
		nRadio		:= aRetAuto[1] //1 = Cancela Baixa de titulos titulos 	2 = cancela baixa somente titulos em bordero
		cBord1		:= aRetAuto[2] // Borderõ De
		cBord2 		:= aRetAuto[3] // Borderô Até
		cDatB1		:= aRetAuto[4] // Dt. Baixa Inicial
		cDatB2		:= aRetAuto[5] // Dt. Baixa Final
		cFor1		:= aRetAuto[6] // Fornecedor De
		cFor2		:= aRetAuto[7] // Fornecedor Até
		aSelFil		:= aRetAuto[8] // Array com as filiais a serem consideradas na seleção dos titulos
		nOpca 	:= 1
	Endif
Endif

If nOpca == 1
	pergunte("FIN091",.F.)

	bProcessa := {|| FA091STIT(nRadio, aSelFil, aTmpFil, lSelFilial, cBord1, cBord2, cDatB1, cDatB2, cFor1, cFor2, lAutomato)}
	IF !lAutomato
		If lSelFilial
			// Seleção de filiais
			aSelFil := AdmGetFil(, .F., "SE2")
			If Len( aSelFil ) <= 0
				nOpca := 0
			Endif
		Else
			aSelFil := {cFilAnt}
		EndIf
		If nOpca != 0
			Processa(bProcessa)
		Endif
	Else
		Eval(bProcessa)
	Endif
EndIF

For nX := 1 TO Len(aTmpFil)
	CtbTmpErase(aTmpFil[nX])
Next

Return


//---------------------------------------------------------------------
/*/{Protheus.doc}Fa091Radio
Validacao do RadioButtom - Tela de Filtros para selecao dos dados -
Cancelamento Automatico Baixas Titulo a Pagar

@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//---------------------------------------------------------------------
Static Function Fa091Radio(nRadio,cBord1,cBord2,cDatB1,cDatB2,cFor1,cFor2)

cBord1 := Space(TamSX3("EA_NUMBOR")[1])
cBord2 := Replicate("Z",TamSX3("EA_NUMBOR")[1] )

If nRadio == 1///Opção TITULO
   	oDatB1:enable()
	oDatB2:enable()
	oFor1:enable()
	oFor2:enable()
	oBord1:disable()
	oBord2:disable()

	cDatB1 := dDataBase
	cDatB2 := dDataBase
	cFor1 := Space(TamSX3("E2_FORNECE")[1])
	cFor2 := Replicate("Z",TamSX3("E2_FORNECE")[1] )
    oDatB1:SetFocus()

Else//Opção BORDERO
	oDatB1:disable()
	oDatB2:disable()
	oFor1:disable()
	oFor2:disable()
	oBord1:enable()
	oBord2:enable()

	cDatB1 := CtoD("01/01/1980","ddmmyy")
	cDatB2 := CtoD("31/12/2099","ddmmyy")
	cFor1 := Space(TamSX3("E2_FORNECE")[1])
	cFor2 := Replicate("Z",TamSX3("E2_FORNECE")[1])
	oBord1:SetFocus()
Endif

Return

//---------------------------------------------------------------------
/*/{Protheus.doc}Fa091ValOk
Validacao dos Gets - Tela de Filtros para selecao dos dados -
Cancelamento Automatico Baixas Titulos a Pagar

@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//---------------------------------------------------------------------
Static Function Fa091ValOk(nRadio,cBord1,cBord2,cDatB1,cDatB2,cFor1,cFor2)

Local lRet := .T.

// Valida todos os gets
If Empty(cDatB1) .or. Empty(cDatB2) .or. (cDatB2 < cDatB1)
   	MsgAlert( STR0169 , STR0146 )	//"Por favor, verifique o intervalo de datas informado."###"Validação"
    lRet := .F.
Endif

If lRet .and. Empty(cFor2)
    MsgAlert( STR0145 , STR0146 )	//"Fornecedor Até não está preenchido"###"Validação"
    lRet := .F.
Endif

If lRet .and. nRadio == 2 .and. Empty(cBord2)
    MsgAlert( STR0147 , STR0146 )   //"Borderô Até não está preenchido"###"Validação"
    lRet := .F.
Endif

If lRet .and. nRadio == 2 .and. cBord2 < cBord1
	MsgAlert( STR0170 , STR0146 )   //"Por favor, verifique o intervalo de borderôs informado."###"Validação"
	lRet := .F.
EndIf

Return lRet

//--------------------------------------------------------------------------------------
/*/{Protheus.doc}FA091STIT
FWMarkBrowse contendo os Títulos a Pagar, visando o cancelamento das suas baixas,
a partir dos Filtros escolhidos

@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//--------------------------------------------------------------------------------------
Static Function FA091STIT(nRadio, aSelFil, aTmpFil, lSelFilial, cBord1, cBord2, cDatB1, cDatB2, cFor1, cFor2, lAutomato)

Local cQuery 		:= ''
Local cArqTrab	    := GetNextAlias()
Local cCampos		:= ""
Local cTmpSE2Fil	:= ""
Local cMarca		:= ""
Local nX 			:= 1
Local nTcSql		:= 0
Local aStruct		:= {}
Local aDadosBx		:= {}
Local aColumns		:= {}
Local aSize			:= {}
Local aRotAtu		:= Aclone(aRotina)
Local bOk 			:= {}
Local oDlgy			:= Nil
Local oSize			:= NIL
Local oMasterPanel	:= NIL
Local oFnt2S		:= TFont():New("Arial      ",7,15,.F.,.F.,,,,,.F.) 	  //NEGRITO SUBLINHADO
Local lRet			:= .T.

Private oMrkBrowse := FWMarkBrowse():New()

DEFAULT nRadio := 0
DEFAULT aSelFil := {cFilAnt}
DEFAULT aTmpFil := {}
DEFAULT lSelFilial := .F.
DEFAULT cBord1 := ''
DEFAULT cBord2 := ''
DEFAULT cDatB1 := ''
DEFAULT cDatB2 := ''
DEFAULT cFor1 := ''
DEFAULT cFor2 := ''
DEFAULT lAutomato := .F.

aRotina := {}

//Cria estrutura e tabela tmp com os campos necessarios da SE2 e FK2
aAux := TamSx3("FK2_FILIAL")
cCampos += "FK2_FILIAL, "
Aadd(aStruct, {"FK2_FILIAL",aAux[3],aAux[1],0})

aAux := TamSx3("E2_PREFIXO")
cCampos += "E2_PREFIXO, "
Aadd(aStruct, {"E2_PREFIXO",aAux[3],aAux[1],0})

aAux := TamSx3("E2_NUM")
cCampos += "E2_NUM, "
Aadd(aStruct, {"E2_NUM"    ,aAux[3],aAux[1],0})

aAux := TamSx3("E2_PARCELA")
cCampos += "E2_PARCELA, "
Aadd(aStruct, {"E2_PARCELA",aAux[3],aAux[1],0})

aAux := TamSx3("E2_TIPO")
cCampos += "E2_TIPO, "
Aadd(aStruct, {"E2_TIPO"   ,aAux[3],aAux[1],0})

aAux := TamSx3("E2_FORNECE")
cCampos += "E2_FORNECE, "
Aadd(aStruct, {"E2_FORNECE",aAux[3],aAux[1],0})

aAux := TamSx3("E2_LOJA")
cCampos += "E2_LOJA, "
Aadd(aStruct, {"E2_LOJA"   ,aAux[3],aAux[1],0})

aAux := TamSx3("E2_NOMFOR")
cCampos += "E2_NOMFOR, "
Aadd(aStruct, {"E2_NOMFOR" ,aAux[3],aAux[1],0})

aAux := TamSx3("FK2_MOTBX")
cCampos += "FK2_MOTBX, "
Aadd(aStruct, {"FK2_MOTBX" ,aAux[3],aAux[1],0})

aAux := TamSx3("FK2_DATA")
cCampos += "FK2_DATA, "
Aadd(aStruct, {"FK2_DATA" ,aAux[3],aAux[1],0})

aAux := TamSx3("FK2_VALOR")
cCampos += "FK2_VALOR, "
Aadd(aStruct, {"FK2_VALOR" ,aAux[3],aAux[1],aAux[2]})

aAux := TamSx3("FK7_CHAVE")
cCampos += "FK7_CHAVE, "
Aadd(aStruct, {"FK7_CHAVE" ,aAux[3],aAux[1],0})

aAux := TamSx3("FK2_IDDOC")
cCampos += "FK2_IDDOC, "
Aadd(aStruct, {"FK2_IDDOC" ,aAux[3],aAux[1],0})

aAux := TamSx3("FK2_FILORI")
cCampos += "FK2_FILORI, "
Aadd(aStruct, {"FK2_FILORI",aAux[3],aAux[1],0})

aAux := TamSx3("FK2_IDFK2")
cCampos += "FK2_IDFK2, "
Aadd(aStruct, {"FK2_IDFK2" ,aAux[3],aAux[1],0})

aAux := TamSx3("FK2_TPDOC")
cCampos += "FK2_TPDOC, "
Aadd(aStruct, {"FK2_TPDOC" ,aAux[3],aAux[1],0})

aAux := TamSx3("FK2_SEQ")
cCampos += "FK2_SEQ, "
Aadd(aStruct, {"FK2_SEQ"   ,aAux[3],aAux[1],0})

Aadd(aStruct, {"FK2_OK","C",2,0})
Aadd(aStruct, {"NUM_REG","N",10,0})

//Filtra baixas realizadas nos Titulos a Pagar
cQuery := " SELECT DISTINCT "
cQuery += cCampos
cQuery += "SE2.E2_OK, SE2.R_E_C_N_O_ NUM_REG "
cQuery += "FROM " + RetSqlName("FK2") + " FK2 "

//Amarracao FK2 + FK7
cQuery += "Join " + RetSqlName("FK7") + " FK7 "
cQuery += "ON ( FK7.FK7_IDDOC = FK2.FK2_IDDOC ) "

//Amarracao FK2 + FKA
cQuery += "Join " + RetSqlName("FKA") + " FKA "
cQuery += "ON ( FKA.FKA_IDORIG = FK2.FK2_IDFK2 ) "

//Amarracao FK2 + SE2
cQuery += "Join " + RetSqlName("SE2") + " SE2 "
//Caso o banco seja Postgres ou MySQL dever  utilizar o Concat para tratamento do trecho de compara‡?o de chave
If ALLTRIM(tcGetdb()) == "POSTGRES" .or. ALLTRIM(tcGetdb()) == "MYSQL"
	cQuery += "ON RTRIM(CONCAT(SE2.E2_FILIAL,'|', SE2.E2_PREFIXO,'|',SE2.E2_NUM,'|',SE2.E2_PARCELA,'|',SE2.E2_TIPO,'|',SE2.E2_FORNECE,'|',SE2.E2_LOJA)) = RTRIM(FK7.FK7_CHAVE) "
Else
	cQuery += "ON ( SE2.E2_FILIAL || '|' || SE2.E2_PREFIXO || '|' || SE2.E2_NUM || '|' || SE2.E2_PARCELA || '|' ||  SE2.E2_TIPO || '|' ||  SE2.E2_FORNECE || '|' ||  SE2.E2_LOJA = FK7.FK7_CHAVE ) "
EndIf

cQuery += "WHERE "
cQuery += "SE2.E2_FILIAL " + GetRngFil( aSelFil, "SE2", .T., @cTmpSE2Fil )
aAdd(aTMPFil, cTmpSE2Fil)

If nRadio == 1///Opção Titulo
	cQuery += " AND FK2.FK2_DATA BETWEEN '"+ DTOS(cDatB1) +"' AND '"+ DTOS(cDatB2) +"' "
	cQuery += " AND SE2.E2_FORNECE BETWEEN '"+ cFor1 +"' AND '"+ cFor2 +"' "
Else
	cQuery += " AND SE2.E2_NUMBOR BETWEEN '"+ cBord1 +"' AND '"+ cBord2 +"' "
Endif
cQuery += " AND (SE2.E2_VALOR <> SE2.E2_SALDO)  " 	// houve baixa em algum momento
cQuery += " AND FK2.FK2_TPDOC NOT IN('ES', 'PA') "   			// apenas Baixas realizadas e não registros estornados
cQuery += " AND FK2.FK2_MOTBX NOT IN ('DSD','LIQ','CEC','PCC','IRF','ISS','FAT','CMP','STP','IMR','IPA') "
cQuery += " AND FK2.D_E_L_E_T_ = ' ' "
cQuery += " AND FK7.D_E_L_E_T_ = ' ' "
cQuery += " AND SE2.D_E_L_E_T_ = ' ' "

cQuery += " AND NOT EXISTS ("
cQuery += "SELECT A.FK2_IDDOC "
cQuery += "FROM "+RetSqlName("FK2")+" A "

cQuery += "WHERE "
cQuery += "A.FK2_FILIAL = FK2.FK2_FILIAL AND "
cQuery += "A.FK2_IDDOC = FK2.FK2_IDDOC AND "
cQuery += "A.FK2_SEQ = FK2.FK2_SEQ AND "
cQuery += "A.FK2_TPDOC = 'ES' AND "
cQuery += "A.D_E_L_E_T_ = ' ')"

cQuery := ChangeQuery(cQuery)

If _oFINA0902 <> Nil
	_oFINA0902:Delete()
	_oFINA0902 := Nil
Endif

// Criação da Tabela Temporária
_oFINA0902 := FWTemporaryTable():New( cArqTrab )
_oFINA0902:SetFields(aStruct)
_oFINA0902:AddIndex("1", {"FK2_FILIAL","FK2_DATA","E2_PREFIXO","E2_NUM","E2_PARCELA","E2_TIPO", "E2_FORNECE","E2_LOJA"})
_oFINA0902:AddIndex("2", {"FK2_OK","FK2_FILIAL","FK2_DATA","E2_PREFIXO","E2_NUM","E2_PARCELA","E2_TIPO", "E2_FORNECE","E2_LOJA"})
_oFINA0902:AddIndex("3", {"NUM_REG"})
_oFINA0902:AddIndex("4", {"FK2_FILIAL","FK2_IDFK2"})

_oFINA0902:Create()

cQuery2 := " INSERT "
If ALLTRIM(tcGetdb()) == "ORACLE"
	cQuery2 += " /*+ APPEND */ "
Endif

cCampos += 'FK2_OK, NUM_REG'

If AllTrim(TcGetDb()) == "DB2"
	cQuery := STRTRAN( cQuery, "FOR READ ONLY", "" )
EndIf

cQuery2 += " INTO " + _oFINA0902:GetRealName() + " (" + cCampos + " ) " + cQuery

If lAutomato
	nTcSql := TcSQLExec(cQuery2)
Else
	Processa({|| nTcSql := TcSQLExec(cQuery2)})
Endif

If nTcSql < 0
	If FindFunction("FinSqlLog")
		FinSqlLog("FN090" ,TCSqlError() , "TEMPORARIA_TITULOS")
		lRet := .F.
	Endif	
Endif

//Verifica se o banco esta bloqueado e deleta os registros
iF lRet .and. FindFunction("FxBcoBloq") .and. FxBcoBloq(_oFINA0902:GetRealName(),{"FK2_FILIAL","FK2_IDFK2"}) < 0
	FinSqlLog("FN090" ,TCSqlError() , "DELETE_TEMPORARIA")
	lRet := .F.
Endif

If lRet	
	cArqTrab := _oFINA0902:GetAlias()

	(cArqTrab)->(DBGOTOP())

	If (cArqTrab)->(Eof())
		If !lAutomato
			MsgAlert( STR0149 , STR0146 )	//"Não existem dados a partir dos filtros mencionados."###"Validação"
		Endif
	Else

		If !lAutomato

			//----------------MarkBrowse----------------------------------------------------
			For nX := 1 To Len(aStruct)
				If	aStruct[nX][1] $ "FK2_FILIAL|E2_PREFIXO|E2_NUM|E2_PARCELA|E2_TIPO|E2_FORNECE|E2_LOJA|E2_NOMFOR|FK2_DATA|FK2_MOTBX|FK2_VALOR"
					AAdd(aColumns,FWBrwColumn():New())
					aColumns[Len(aColumns)]:SetData( &("{||"+aStruct[nX][1]+"}") )
					aColumns[Len(aColumns)]:SetTitle(Alltrim(RetTitle(aStruct[nX][1]))  )
					aColumns[Len(aColumns)]:SetSize(6)
					aColumns[Len(aColumns)]:SetDecimal(aStruct[nX][4])

					IF aStruct[nX][1] == 'FK2_VALOR'
						aColumns[Len(aColumns)]:SetPicture(PesqPict("FK2",aStruct[nX][1]))
						aColumns[Len(aColumns)]:SetAlign('RIGHT')
					Endif
				EndIf

			Next nX

			aSize := MSADVSIZE(.F.)

			DEFINE MSDIALOG oDlgy TITLE STR0137 From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL  //'Cancelamento Automático de Baixas de Títulos a Pagar'

			//Defino o tamanho dos componentes através do método FwDefSize(), amarrando ao objeto oDlg
			oSize := FwDefSize():New(.T.,,,oDlgy)

			oSize:lLateral := .F.
			oSize:lProp := .T.

			oSize:AddObject("MASTER",100,100,.T.,.T.)

			oSize:Process()

			//Instancio um painel "master" como container
			oMasterPanel := TPanel():New(oSize:GetDimension("MASTER","LININI"),oSize:GetDimension("MASTER","COLINI"),;
									,oDlgy,,,,,,oSize:GetDimension("MASTER","XSIZE"),oSize:GetDimension("MASTER","YSIZE"),.F.,.F.)

			oPanel1 := TPanel():New(0,0,'',oMasterPanel,, .T., .T.,, ,115,115,.F.,.F. )
			oPanel1:Align := CONTROL_ALIGN_ALLCLIENT

			oMrkBrowse:SetFieldMark("FK2_OK")
			oMrkBrowse:SetOwner(oPanel1)
			oMrkBrowse:SetAlias(cArqTrab)
			oMrkBrowse:bMark     := {||FI091Mark(cArqTrab )}
			oMrkBrowse:bAllMark  := {||FA091AllMk(oMrkBrowse,cArqTrab)}
			oMrkBrowse:SetDescription("")
			oMrkBrowse:SetColumns(aColumns)
			oMrkBrowse:SetMenuDef("")
			oMrkBrowse:DisableReport("")

			oMrkBrowse:Activate()

			oMrkBrowse:SetFontBrowse(oFnt2S)
			oMrkBrowse:SetLineHeight(25)

			bOk := {||Processa({||If(F091Grava(cArqTrab,aDadosBx), IIf(Fa091ExcA(aDadosBx),(oMrkBrowse:Deactivate(), oDlgy:End()), Nil), Nil)}) }

			ACTIVATE MSDIALOG oDlgy ON INIT EnchoiceBar( oDlgy,	{|| ( Eval(bOk) ) },;
																{|| nOpca := 0,oDlgy:End()},, ) CENTER
		Else

			FA091AllMk( ,cArqTrab,lAutomato,@cMarca)
			If F091Grava(cArqTrab,aDadosBx,lAutomato,cMarca)
				Fa091ExcA(aDadosBx,.T.)
			Endif
		Endif
	EndIf

	If _oFINA0902 <> Nil
		_oFINA0902:Delete()
		_oFINA0902 := Nil
	Endif
Else
	IF !lAutomato
		HELP(" ",1,"SGDBInfo",,STR0181 ,2,0,,,,,, { STR0182 })  // Ocorreu erro no comando do banco de dados. ###  Avalie o log de incosistências gerado na pasta system arquivo FR110Log.
	Endif
Endif

aRotina := Aclone(aRotAtu)

Return aDadosBx


//---------------------------------------------------------------------
/*/{Protheus.doc}F091Grava
Faz gravação na Tabela Temporária a partir dos dados selecionados e
apresentados no FWMarkBorwse

@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//---------------------------------------------------------------------
Static Function F091Grava(cArqTrab, aDadosBx, lAutomato, cMarca)

Local lRet := .T.
Local nRecNo := 0

DEFAULT lAutomato := .F.
DEFAULT cMarca := If(lAutomato, cMarca, oMrkBrowse:cMark)

dbSelectArea(cArqTrab)
nRecno := (cArqTrab)->(RecNo())

(cArqTrab)->(dbSetOrder(2))
(cArqTrab)->(DbGoTop())

If (cArqTrab)->(DbSeek(cMarca))
	While !(cArqTrab)->(Eof())
		If (cMarca $ (cArqTrab)->FK2_OK)
			aAdd(aDadosBx,{ (cArqTrab)->FK7_CHAVE, (cArqTrab)->FK2_IDDOC, (cArqTrab)->FK2_FILORI, (cArqTrab)->FK2_IDFK2, (cArqTrab)->FK2_SEQ } )
		EndIf
		(cArqTrab)->(DbSkip())
	Enddo
EndIF

(cArqTrab)->(dbSetOrder(1))
(cArqTrab)->(DbGoTo(nRecno))

lRet := If (Len(aDadosBx) > 0, .T., .F.)

Return lRet


//---------------------------------------------------------------------
/*/{Protheus.doc}FA091AllMk
Faz gravação no cmapo FK2_OK com a marcação.
@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//---------------------------------------------------------------------
Static Function FA091AllMk(oMrkBrowse,cArqTrab,lAutomato,cMarca)

Local nReg 	 := (cArqTrab)->(Recno())

Default cMarca := oMrkBrowse:cMark

If lAutomato
	cMarca := GetMark()
EndIf

dbSelectArea(cArqTrab)
(cArqTrab)->(DbGoTop())

While !(cArqTrab)->(Eof())
	SE2->(dbGoto((cArqTrab)->NUM_REG))
	If SE2->(MsRLock()) .AND. (cArqTrab)->(MsRLock())
		IF	(cArqTrab)->FK2_OK == cMarca
			(cArqTrab)->FK2_OK := "  "
			(cArqTrab)->(MsUnlock())
			SE2->(MsUnlock())
		Else
			(cArqTrab)->FK2_OK := cMarca
		Endif
	Endif
	(cArqTrab)->(dbSkip())
Enddo

(cArqTrab)->(dbGoto(nReg))

If !lAutomato
	oMrkBrowse:oBrowse:Refresh(.t.)
Endif

Return .T.

//---------------------------------------------------------------------
/*/{Protheus.doc}
Faz gravação no cmapo FK2_OK com a marcação.
@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//---------------------------------------------------------------------
Function FI091Mark(cAliasTRB)

Local lRet		:= .T.

SE2->(dbGoto((cAliasTRB)->NUM_REG))

If SE2->(MsRLock()) .AND. (cAliasTRB)->(MsRLock())
	// destravamos o mesmo para uso de outro terminal
	If Empty( (cAliasTRB)->FK2_OK )
		(cAliasTRB)->(MsUnlock())
		SE2->(MsUnlock())
	Endif
Else
	lRet := .F.
Endif

Return lRet


//--------------------------------------------------------------------------
/*/{Protheus.doc} Fa091ExcA
Rotina Automática(ExecAuto) para Cancelamento de Baixas de Titulo a Pagar
@author Mauricio Pequim Jr
@since  02/03/2018
@version 12
/*/
//--------------------------------------------------------------------------
Function Fa091ExcA(aDadosBx, lAutomato)

Local lRet			:=  .T.
Local aVetor        := {}
Local aPerg			:= {}
Local nX            := 0
Local nRecSE2		:= 0
Local cFilOrig		:= ""
Local cIDOrig		:= ""
Local cSequencia	:= ""
Local aAreaSEA		:= SEA->(GetArea())
Local aArea			:= GetArea()
Local cFilAtu		:= cFilAnt

Private lMsErroAuto     := .F.
Private lMsHelpAuto     := .T.
Private lMostraErro     := .F.

DEFAULT lAutomato	:= .F.

//Realiza o repasse dos perguntes conforme a o rotina informada.
F91ResPerg(@aPerg)

ProcRegua(Len(aDadosBx))

BEGIN TRANSACTION

For nX:=1 to Len(aDadosBx)

    aVetor := {}
	lMsErroAuto := .F.

	cDadosTit := FinFK7Key(aDadosBx[nX,1],"")

	dbSelectArea('SE2')
	SE2->(dbSetOrder(1)) // Filial + Fornecedor + Loja + Prefixo + Número + Parcela + Tipo

	If SE2->(MsSeek( cDadosTit ) )

		nRecSE2 := SE2->(RECNO())

		IncProc("Cancelando Baixa: " + aDadosBx[nX,1]) //"Gerando parcela "

        AADD(aVetor,{"E2_FILIAL"     , SE2->E2_FILIAL        ,Nil})
        AADD(aVetor,{"E2_PREFIXO"    , SE2->E2_PREFIXO       ,Nil})
        AADD(aVetor,{"E2_NUM"        , SE2->E2_NUM           ,Nil})
        AADD(aVetor,{"E2_PARCELA"    , SE2->E2_PARCELA       ,Nil})
        AADD(aVetor,{"E2_TIPO"       , SE2->E2_TIPO          ,Nil})
        AADD(aVetor,{"E2_FORNECE"    , SE2->E2_FORNECE       ,Nil})
        AADD(aVetor,{"E2_LOJA"       , SE2->E2_LOJA          ,Nil})

		//posiciona SE5 a partir do FK2_IDFK2
		cFilOrig	:= aDadosBx[nX,3]
		cIDOrig		:= aDadosBx[nX,4]
		cSequencia	:= aDadosBx[nX,5]

    	//posiciona SE5 a partir do FK2_IDFK2
    	dbSelectArea('SE5')
		SE5->(dbSetOrder(21)) //  E5_FILORIG + E5_IDORIG + E5_TIPODOC
		SE5->(DbSeek((xFilial("SE5",cFilOrig)) + cIDOrig ) )

		cFilAnt := SE5->E5_FILORIG
		MSExecAuto({|a,b,c,d,e,f,g,h,i,j,k,l| Fina080(a,b,c,d,e,f,g,h,i,j,k,l)},aVetor,5,,,,,cSequencia,,,,,aPerg)
        cFilAnt := cFilAtu //  restaura cFilAnt para Filial logada

        //Em caso de erro na baixa desarma a transação
        If lMsErroAuto
			lRet:= .F.
			If !IsBlind()
				MOSTRAERRO()
			EndIf
			DisarmTransaction()
			Break
		Endif
	Endif

Next nX

END TRANSACTION

//Restaurando o grupo de perguntas
F91ResPerg()

If lRet .and. !lAutomato
	MsgInfo( STR0150 , STR0151  )  ///"Cancelamento de Baixas de Títulos a Pagar foi realizado com sucesso."###"Cancelamento de Baixas a Pagar"
Endif

SEA->(RestArea(aAreaSEA))
RestArea(aArea)

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} function F91VldBco
Verifica se o banco utilizado na baixa por títulos existe na filial do título a ser baixado.
@author  Simone Mie Sato Kakinoana
@since   06/09/2018
@version P12
/*/
//-------------------------------------------------------------------
Function F91VldBco(cBco,cAgencia,cCtaCorr,cCodFil)
SA6->(DbSetOrder(1))
Return SA6->( DbSeek( FXRetFil( "SA6",SE2->E2_FILIAL, .F. ) + cBco + cAgencia + cCtaCorr, .F.) )

/*/{Protheus.doc} FiltFilBco
Função para remover as filiais selecionadas que não possuam o banco selecionado para
baixas multi-filiais. Utilizada quando a tabela de bancos (SA6) está exclusiva.

@author pedro.alencar
@since 06/02/2020
@version 1.0
@type static function

@param aFilAux, array, Vetor com as filiais selecionadas (AdmGetFil) para a baixa
@param cChaveBco, char, Chave do banco informado (Código + Agência + Conta)
@return aRet, Vetor com a relação de filiais selecionadas que possuem o cadastro do banco informado
/*/
Static Function FiltFilBco( aFilAux As Array, cChaveBco As Char ) As Array
	Local aRet As Array
	Local aAreaSA6 As Array
	Local cFilSA6 As Char
	Local nI As Numeric
	Default aFilAux := {}
	Default cChaveBco := ""

	aRet := {}
	aAreaSA6 := SA6->( GetArea() )
	SA6->( dbSetOrder(1) ) //A6_FILIAL+A6_COD+A6_AGENCIA+A6_NUMCON

	For nI := 1 To Len(aFilAux)
		cFilSA6 := FWxFilial( "SA6", aFilAux[nI] )

		If SA6->( msSeek( cFilSA6 + cChaveBco ) )
			aAdd( aRet, aFilAux[nI] )
		EndIf
	Next nI

	RestArea(aAreaSA6)
	FwFreeArray(aAreaSA6)
Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} function F91ResPerg
Restaura os perguntes.
@Param	aPerg, Array, array para o grupo de perguntas.
@author  Vincius do Prado
@since   06/03/2020
@version P12
/*/
//-------------------------------------------------------------------
Static Function F91ResPerg(aPerg as Array)

	//Realiza o repasse dos perguntes conforme a o rotina informada.
	If FwIsInCallStack("FINA090")
		SetKey (VK_F12,{|a,b| AcessaPerg("FIN090",.T.)})
		Pergunte("FIN090",.F.)

		If(ValType(aPerg)=="A")
			AADD(aPerg,mv_par01) // Mostra Lançamento Contabil
			AADD(aPerg,mv_par02) // Aglutina Lançamento
			AADD(aPerg,mv_par03) // Contabiliza Online
		EndIf

	ElseIf FwIsInCallStack("FINA091")
		SetKey (VK_F12,{|a,b| AcessaPerg("FIN091",.T.)})
		Pergunte("FIN091",.F.)

		If(ValType(aPerg)=="A")
			AADD(aPerg,mv_par02) // Mostra Lançamento Contabil
			AADD(aPerg,mv_par03) // Aglutina Lançamento
			AADD(aPerg,mv_par04) // Contabiliza Online
		EndIf
	EndIf
Return Nil

//-------------------------------------------------------------------------
/*/{Protheus.doc} F091CRatIR
Função para criar o objeto __oRatIRF

@author pequim
@since  17/02/2022
@version 12.1.33
@param 
/*/
//-------------------------------------------------------------------------
Function F091CRatIR() As Object

Local cCdRetIRRt	As Character

cCdRetIRRt    := SuperGetMv("MV_RETIRRT",.T.,"3208")

F091LRatIR(.F.)

If Alltrim(SE2->E2_CODRET) $ cCdRetIRRt
	If FindFunction("FinXRatIR")
		If __oRatIRF == Nil
			__oRatIRF := FinBCRateioIR():New()
		EndIf
		__oRatIRF:SetFilOrig(cFilAnt)
		__oRatIRF:SetForLoja(SE2->E2_FORNECE,SE2->E2_LOJA)
		__oRatIRF:SetIRBaixa(.T.)
	EndIf
EndIf	

Return __oRatIRF

//-------------------------------------------------------------------------
/*/{Protheus.doc} F091LRatIR
Função para limpar o objeto __oRatIRF

@author pequim
@since  17/02/2022
@version 12.1.33
@param lExclui, Logical, Define se ira excluir o Objeto da memoria
/*/
//-------------------------------------------------------------------------
Function F091LRatIR(lExclui as Logical)

    Default lExclui := .T.

    If __oRatIRF <> Nil
        __oRatIRF:Clean()
        If lExclui
            FwFreeObj(__oRatIRF)
            __oRatIRF := Nil
        EndIf    
    EndIf

Return

//-------------------------------------------------------------------------
/*/{Protheus.doc} F091SRatIR
Função para setar o objeto __oRatIRF

@author pequim
@since  17/02/2022
@version 12.1.33
@param oObj, Object, Objeto que sera atribuido ao oRatIrf
/*/
//-------------------------------------------------------------------------
Function F091SRatIR(obj as Object)
    __oRatIRF := obj
Return 
