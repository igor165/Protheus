#Include 'TOTVS.CH'
#INCLUDE "FINA171.CH"
#INCLUDE "FWMVCDEF.CH"

#DEFINE DECIMALDECALCULO 12           

Static bLoadGrd  := {}
Static aCampos   := {}
Static cNumero   := ""
Static _oFINA171
Static cCodFor	 := ""
Static cForLj	 := ""
Static cBanco	 := ""
Static cAgencia	 := ""
Static cConta	 := ""
Static lMovEnt05
Static lMovEnt06
Static lMovEnt07
Static lMovEnt08
Static lMovEnt09
Static __nMaxParc := 0
Static __cMaxParc := ""
Static __nTamParc := 0
Static __nLastPar := 0
Static __nTamPraz := 0
Static __cGetrealname	:= ""

/*/


Ŀ
Funo     FINA171   Autor  Eduardo Riera          Data  28/03/98 
Ĵ
Descrio  Programa de atualizao de Aplicacoes/Emprestimos          
Ĵ
Sintaxe    FINA171()                                                  
Ĵ
 Uso       SIGAFIN                                                    
ٱ


/*/
Function FinA171(nPosArotina,aRotAuto,nOpcAuto,aParam)

//Declaracao de variaveis Multimoeda
Local nA := 0
Local nC	:=	MoedFin()
Local cMoedaTx
Local cRelease := GetRpoRelease()

Private aTxMoedas	:=	{} 
Private lF171Auto   := ( aRotAuto <> NIL )
Private aAutoCab    := {}

DEFAULT aRotAuto := {}
DEFAULT nOpcAuto := 3
DEFAULT aParam   := {}

If !lF171Auto .and. cRelease > "12.1.033" //FindFunction("FAplEmpNew") .and. FAplEmpNew("FINA171")
	FINA716()
	Return
Endif

aAutoCab := aClone(aRotAuto)

lF171Auto   := Len(aAutoCab) > 0

// Inicia as variaveis staticas do fonte.
FinIniVar()

//Ŀ
// Define Array contendo as Rotinas a executar do programa      
// ----------- Elementos contidos por dimensao ------------     
// 1. Nome a aparecer no cabecalho                              
// 2. Nome da Rotina associada                                  
// 3. Usado pela rotina                                         
// 4. Tipo de Transao a ser efetuada       
//    1 - Pesquisa e Posiciona em um Banco de Dados             
//    2 - Simplesmente Mostra os Campos                         
//    3 - Inclui registros no Bancos de Dados                   
//    4 - Altera o registro corrente                            
//    5 - Remove o registro corrente do Banco de Dados          
//
//Ŀ
// Parametros do Programa                                       
//                                                              
// MV_PAR01 : Mostra Lanc. Contabil                             
// MV_PAR02 : Contabiliza On-Line                               
//                                                              
//
Aadd(aTxMoedas,{"",1,PesqPict("SM2","M2_MOEDA1")})
For nA	:=	2	To nC
	cMoedaTx	:=	Str(nA,IIf(nA <= 9,1,2))
	If !Empty(GetMv("MV_MOEDA"+cMoedaTx))
		Aadd(aTxMoedas,{GetMv("MV_MOEDA"+cMoedaTx),RecMoeda(dDataBase,nA),PesqPict("SM2","M2_MOEDA"+cMoedaTx) })
	Else
		Exit
	Endif
Next

Private aRotina := MenuDef()

//Ŀ
// Define o cabecalho da tela de atualizacoes                   
//
PRIVATE cCadastro := OemToAnsi(STR0006)  //"Atual.Aplicaoes/Emprst."
//Ŀ
// Verifica o numero do Lote                                    
//
PRIVATE cLote
LoteCont("FIN")

//Ŀ
// Carrega funcao Pergunte                                      
//
If !lF171Auto
	SetKey(VK_F12,{||Fa171Perg()})
Endif	

Pergunte("AFI171",.F.)

If lF171Auto .and. Len(aParam) > 0
	F171PerAut(aParam)
Endif

//Ŀ
// Endereca a funcao de BROWSE                                  
//
DEFAULT nPosArotina := 0
If lF171Auto
	Default nOpcAuto := 3
	MBrowseAuto(nOpcAuto,aAutoCab,"SEH")
Else	
	If nPosArotina > 0 // Sera executada uma opcao diretamento de aRotina, sem passar pela mBrowse
		dbSelectArea("SEH")
		bBlock := &( "{ |a,b,c,d,e| " + aRotina[ nPosArotina,2 ] + "(a,b,c,d,e) }" )
		Eval( bBlock, Alias(), (Alias())->(Recno()),nPosArotina)
	Else
		mBrowse( 6, 1,22,75,"SEH",,,,,,Fa171Legenda())  	
	Endif
Endif	

If !lF171Auto
	SetKey( VK_F12 , Nil )
Endif	

Return(.T.)

/*/

Ŀ
Funo    A171Altera Autor  Eduardo Riera          Data  28.03.98 
Ĵ
Descrio  Programa de exclusao de Aplicacoes/Resgates                
Ĵ
Sintaxe    A171Altera(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       FINA171                                                    
ٱ


/*/
Function A171Altera(cAlias,nReg,nOpc)

Local lPanelFin := IsPanelFin()
//Ŀ
// Verifica se data do movimento no  menor que data limite de 
// movimentacao no financeiro e se nao houve resgate.           
//
If ( DtMovFin() .And. SEH->EH_SALDO != 0 )
	//Ŀ
	// Inicializa a geraao de lancamentos do SIGAPCO      
	//
	PcoIniLan("000008")		
	If !lF171Auto
		If lPanelFin
			dbSelectArea("SE5")		
			RegToMemory(cAlias,.T.,,,FunName())                                       		                                   
			oPanelDados := FinWindow:GetVisPanel()
			oPanelDados:FreeChildren()
			aDim := DLGinPANEL(oPanelDados)
			Altera := .T.			
			nOpca := AxAltera(cAlias,nReg,nOpc,,,,,"Fa171TudOk(nOpc)","Fa171Alt",,,,,,,,.T.,oPanelDados,aDim,FinWindow)		
		Else
			AxAltera(cAlias,nReg,nOpc,,,,,"Fa171TudOk(nOpc)","Fa171Alt")	 
		Endif	
	Else	  		
		RegToMemory("SEH",.F.,.F.)

		If EnchAuto(cAlias,aAutoCab,"Fa171TudOk(4)")
			nOpca := AxIncluiAuto(cAlias,,'Fa171Alt',4,nReg)
		Else	
			lMsErroAuto := .T.
		Endif	
	Endif
	//Ŀ
	// Inicializa a geraao de lancamentos do SIGAPCO      
	//
	PcoFinLan("000008")
	PcoFreeBlq("000008")
EndIf

Return(.T.)


/*/

Ŀ
Funo     Fa171Alt  Autor  Edson Maricate         Data  22.07.05 
Ĵ
Descrio  Funcao de complemento de gravao /Resgates                
Ĵ
Sintaxe    A171Altera(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       FINA171                                                    
ٱ


/*/
Function Fa171Alt()
Local aArea	:= GetArea()

//Ŀ
// Gera os lancamentos do SIGAPCO                      
//
PcoDetLan("000008","01","FINA171")

RestArea(aArea)
Return

/*/

Ŀ
Funo    A171Exclui Autor  Eduardo Riera          Data  28.03.98 
Ĵ
Descrio  Programa de exclusao de Aplicacoes/Resgates                
Ĵ
Sintaxe    A171Exclui(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       FINA171                                                    
ٱ


/*/
Function A171Exclui(cAlias,nReg,nOpc)
LOCAL nOpca      	:= 1
LOCAL cPadrao    	:= "581"
Local lDigita    	:= If(MV_PAR01==1,.T.,.F.)
Local nHdlPrv    	:= 0
LOCAL lPadrao    	:= VerPadrao(cPadrao)
LOCAL bCampo     	:= {|x| FieldName(x)}
LOCAL nTotal     	:= 0
LOCAL cArquivo   	:= ""
LOCAL lContabil  	:= .F.
LOCAL cHistorico 	:= ""
Local nCntFor 		:= 0   
Local lPanelFin 	:= IsPanelFin()
Local aFlagCTB		:= {}
Local lUsaFlag		:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/) 
Local lAtuSldNat := .T.

Local lFA171Bco		:= ExistBlock("FA171BCO")
Local lMovBco		:= .T.
Local lAplCota		:= (SEH->EH_TIPO $ GetMv("MV_APLCAL4"))
Local lTemResgate	:= .T.

Local oModelMov := Nil //Model de Movimento Bancrio
Local oSubFK5
Local oSubFKA
Local cLog := ""
Local lRet := .T.
Local cCamposE5 := ""
Local nValor := 0 
Local nE5Recno := 0
Local cTpDoc := ""
Local lSEHBase   := SEH->(ColumnPos("EH_BASEDES")) > 0

//Ŀ
// Monta a entrada de dados do arquivo                          
//
Private aTELA[0][0],aGETS[0] 

//Ŀ
// Verifica se houve resgate por cotas ou valor                 
//
If lAplCota
	lTemResgate := SEH->EH_SLDCOTA <> SEH->EH_QUOTAS
	If lTemResgate .And. Empty( SEH->EH_SLDCOTA ) .And. SEH->EH_SALDO > 0
		lTemResgate := SEH->EH_SALDO <> SEH->EH_QUOTAS
	EndIf	
Else
	lTemResgate := Round(SEH->EH_SALDO, TamSx3('EH_VALOR')[2]) <> SEH->EH_VALOR
EndIf

// Verifica se emprestimo teve algum valor de entrada
If SEH->EH_SALDO == SEH->EH_FINANC .And. !Empty(SEH->EH_ENTRADA)
	lTemResgate := .F.
EndIf

//Ŀ
// Verifica se data do movimento no  menor que data limite de 
// movimentacao no financeiro e se nao houve resgate.           
//
If	( !lTemResgate .And. Empty(SEH->EH_ULTAPR) ) .And. ;
	!CCBLOCKED(SEH->EH_BANCO,SEH->EH_AGENCIA,SEH->EH_CONTA) //Verifica bloqueio de conta corrente
	If !DtMovFin(,,IIF(SEH->EH_APLEMP=="APL","1","2"))
		Return
	EndIf 
	dbSelectArea(cAlias)
	If !SoftLock( "SEH" )
		Return
	EndIf
	dbSelectArea( cAlias )
	For nCntFor := 1 TO FCount()
		M->&(EVAL(bCampo,nCntFor)) := FieldGet(nCntFor)
	NEXT nCntFor

	iF !lF171Auto              
		If lPanelFin  //Chamado pelo Painel Financeiro								
			RegToMemory(cAlias,.T.,,,FunName())                                       
			oPanelDados := FinWindow:GetVisPanel()
			oPanelDados:FreeChildren()		
			aDim := DLGinPANEL(oPanelDados)		
			nOpca := AxVisual(cAlias,nReg,nOpc,,,,,,,,.T.,,.T.,.T.,aDim)			
		Else
			nOpca := AxVisual(cAlias,nReg,nOpc,,,,,,,,,,,)
		Endif
	Else	
		nOpcA := 1
	Endif	

	dbSelectArea(cAlias)

	If ( nOpca == 1 )
		SA6->(DBSetOrder(1))
		SA6->(MsSeek(xFilial("SA6")+SEH->EH_BANCO+SEH->EH_AGENCIA+SEH->EH_CONTA))
	
		If ( SubStr(SEH->EH_LA,1,1) == "S" )
			lContabil := .T.
		EndIf
		If ( SEH->EH_APLEMP == "APL" )
			cHistorico := STR0014+" "+SEH->EH_TIPO //"Estorno de Aplicacao"
		Else
			cHistorico := STR0015+" "+SEH->EH_TIPO //"Estorno de Emprestimo"
		EndIf
		//Ŀ
		// Inicializa a geraao de lancamentos do SIGAPCO      
		//
		PcoIniLan("000008")
		//Ŀ
		// Inicio do bloco protegido via TTS          
		//
		If lFA171Bco
			//Ŀ
			//Ponto de entrada que indica se deve movimentar ou nao banco
			//
			lMovBco := ExecBlock("FA171Bco", .F., .F.,{nOpc} )
			If Valtype(lMovBco) <> "L"
				lMovBco := .T.
			EndIf
		EndIf
		
		Begin Transaction
		
			FCExcluiE2(SEH->EH_NUMERO,nOpc)
			
			If lMovBco				
				
				//Pega o registro da SE5 correspondente ao movimento da aplicao ou emprestimo posicionado
				cTpDoc := Iif( SEH->EH_APLEMP=="EMP", "EP", "AP" )				
				nE5Recno := FN171SE5( cTpDoc )
				If nE5Recno > 0 
					SE5->( dbGoto( nE5Recno ) ) 
				Else
					lRet := .F.
				Endif

				/* 
				--- Formas de gravacao da movimentacao bancaria na exclusao de aplicacoes/emprestimos (a passar por revisao) ---
				FK5_MOEDA: Moeda definida no EH_MOEDA (na inclusao  gravada a moeda do cadastro do banco)
				FK5_VALOR: Grava o valor do EH_VLCRUZ, onde o mesmo possui 2 formas de gravacao (Gatilho - SX7) dependendo da operacao:
						- Aplicacao: Mesmo valor do EH_VALOR; 
						- Emprestimo: Converte para a moeda forte (taxa do SM2);
						Obs: Na inclusao, em pases diferente de Brasil h outro padrao de gravacao;
				FK5_VLMOE2: Faz a conversao do FK5_VALOR partindo da moeda forte para a moeda do EH_MOEDA (taxa do SM2);
						Obs: Na inclusao, em pases diferente de Brasil h outro padrao de gravacao;
				FK5_TXMOED: Nao  gravado;
				*/

				If lRet
				
					//Ŀ
					// Estorna Movimento Bancario                 
					//
					
					//Define os campos que no existem nas FKs e que sero gravados apenas na E5, para que a gravao da E5 continue igual
					cCamposE5	:= Fa171CpSE5(lMovEnt05, lMovEnt06, lMovEnt07,lMovEnt08,lMovEnt09)

					oModelMov := FWLoadModel("FINM030") //Recarrega o Model de movimentos para pegar o campo do relacionamento 
					oModelMov:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
					oModelMov:Activate()
					oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Informa se vai gravar SE5 ou no
					oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que sero gravados indepentes de FK5 
					oModelMov:SetValue( "MASTER", "NOVOPROC", .F. ) //Informa que a incluso no ser feita com um novo nmero de processo
					
					//Dados do Processo
					oSubFKA := oModelMov:GetModel("FKADETAIL")
					oSubFKA:SetValue( "FKA_IDORIG", FWUUIDV4() )
					oSubFKA:SetValue( "FKA_TABORI", "FK5" )
					
					//Informacoes do movimento
					oSubFK5 := oModelMov:GetModel( "FK5DETAIL" )
					nValor := SEH->EH_VLCRUZ
					oSubFK5:SetValue( "FK5_DATA", dDataBase )
					oSubFK5:SetValue( "FK5_BANCO", SEH->EH_BANCO )
					oSubFK5:SetValue( "FK5_AGENCI", SEH->EH_AGENCIA )
					oSubFK5:SetValue( "FK5_CONTA", SEH->EH_CONTA )				
					oSubFK5:SetValue( "FK5_VALOR", nValor )
					oSubFK5:SetValue( "FK5_VLMOE2", xMoeda( nValor, 1, SEH->EH_MOEDA ) )				
					oSubFK5:SetValue( "FK5_RECPAG", If(SEH->EH_APLEMP=="EMP","P","R") )
					oSubFK5:SetValue( "FK5_TPDOC", cTpDoc )
					oSubFK5:SetValue( "FK5_HISTOR", cHistorico )				
					oSubFK5:SetValue( "FK5_DTDISP", dDataBase )		
					oSubFK5:SetValue( "FK5_MOEDA", PADL(SEH->EH_MOEDA,TamSX3("CTO_MOEDA")[1],"0") )			
					oSubFK5:SetValue( "FK5_FILORI", SEH->EH_FILIAL )
					oSubFK5:SetValue( "FK5_DOC", SEH->EH_NUMERO+SEH->EH_REVISAO )
					oSubFK5:SetValue( "FK5_ORIGEM", FunName() )		
					oSubFK5:SetValue( "FK5_CCUSTO", SEH->EH_CCUSTO )		
					oSubFK5:SetValue( "FK5_NATURE", SEH->EH_NATUREZ )		
					If !lUsaFlag .and. ( MV_PAR02 == 1 )
						oSubFK5:SetValue( "FK5_LA", "S" )
					Endif					
					
					//Gravao da tabela FK8 - Dados Contbeis
					Fa171GrFK8(oModelMov,lMovEnt05, lMovEnt06, lMovEnt07,lMovEnt08,lMovEnt09)

					If oModelMov:VldData()		
						oModelMov:CommitData()
					    oModelMov:DeActivate()
					Else
						lRet := .F.
						cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
					    cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
					    cLog += cValToChar(oModelMov:GetErrorMessage()[6])        	
					    
					    Help( ,,"MF171EXC",,cLog, 1, 0 )	            
					Endif
					
					If lRet
						AtuSalBco( SE5->E5_BANCO, SE5->E5_AGENCIA, SE5->E5_CONTA, SE5->E5_DATA, SE5->E5_VALOR,;
							        IIf(SE5->E5_RECPAG == "R", "+", "-") )
						
						/*
						 * Atualiza os saldos do fluxo de caixa por natureza financeira - AtuSldNat()
						 */
						If lAtuSldNat
							AtuSldNat(SE5->E5_NATUREZ, SE5->E5_DATA, SE5->E5_MOEDA, "3", If(SEH->EH_APLEMP=="EMP","R","P"), SEH->EH_VLCRUZ, 0, "-",,FunName(),"SE5", SE5->(Recno()),0)
						EndIf
					Endif
					
				Endif
				
				If  !Empty(SEH->EH_DESPESA) .And. ( !lSEHBase .OR. (lSEHBase .And. SEH->EH_BASEDES <> "1" ) )
					cNumero := SEH->EH_NUMERO 
					If !lF171Auto
						MsgRun( STR0045,, { || FCGrvE5(cNumero,.T.) }  ) //"Aguarde, gravando as despesas do contrato..."
					Else	
						FCGrvE5(cNumero,.T.)
					Endif	
				EndIf
			EndIf
			
			If lRet
				//Ŀ
				//Lancamento Contabil                                            
				//
				IF ( lPadrao .And. MV_PAR02 == 1 .And. lContabil )
					//Ŀ
					// Inicializa Lancamento Contabil                                   
					//
					nHdlPrv := HeadProva( cLote, "FINA171" /*cPrograma*/, Substr( cUsuario, 7, 6 ), @cArquivo )
				
					//Ŀ
					// Prepara Lancamento Contabil                                      
					//
					If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil 
						aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
						aAdd( aFlagCTB, {"FK5_LA", "S", "FK5", FK5->( Recno() ), 0, 0, 0} )
					Endif
					nTotal += DetProva( nHdlPrv, cPadrao, "FINA171" /*cPrograma*/, cLote, /*nLinha*/, /*lExecuta*/,;
						                   /*cCriterio*/, /*lRateio*/, /*cChaveBusca*/, /*aCT5*/, /*lPosiciona*/,;
						                   @aFlagCTB, /*aTabRecOri*/, /*aDadosProva*/ )
	
					//Ŀ
					// Efetiva Lanamento Contabil                                      
					//
					RodaProva( nHdlPrv, nTotal )
					
					cA100Incl( cArquivo, nHdlPrv, 3 /*nOpcx*/, cLote, lDigita, .F. /*lAglut*/, /*cOnLine*/, /*dData*/,;
						         /*dReproc*/, @aFlagCTB, /*aDadosProva*/, /*aDiario*/ )
					aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento
				EndIf

				If ExistBlock("F171EXCL")
					Execblock("F171EXCL",.F.,.F.)
				Endif
			
				//Ŀ
				// Gera os lancamentos do SIGAPCO                      
				//
				dbSelectArea("SEH")            
				PcoDetLan('000008',"01","FINA171",.T.)
				RecLock("SEH",.F.)
				dbDelete()
				
			Endif
			
			//Ŀ
			// Final  do bloco protegido via TTS          
			//
		End Transaction
	
		//Ŀ
		// Finaliza os lancamentos do SIGAPCO  
		//
		PcoFinLan("000008")
	EndIf
	dbSelectArea( cAlias )
	MsUnLock()
Else
	Help(" ",,"A171DELETA")
EndIf
dbSelectArea( cAlias )
Return(.T.)

/*/

Ŀ
Funo    A171Inclui Autor  Eduardo Riera          Data  28.03.98 
Ĵ
Descrio  Programa de Incluisao de Aplicacoes e Emprestimo           
Ĵ
Sintaxe    A171Inclui(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       FINA171                                                    
ٱ


/*/
Function A171Inclui(cAlias,nReg,nOpc)

Local lPanelFin  := If (FindFunction("IsPanelFin"),IsPanelFin(),.F.)
Local nOpca	     :=	0
Local cTitulo    := ""
Local cPrograma  := 'FINA171'
Local nOperation := MODEL_OPERATION_UPDATE
Local lRet		 := .F.
Local nRet       := 0
Local lSEHBase   := SEH->(ColumnPos("EH_BASEDES")) > 0
Local nPosFor    := 0
Local nPosLoja   := 0
Local aEnableButtons := {{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.T.,Nil},{.T.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil},{.F.,Nil}} //"Confirmar"###"Fechar"
Local nPos := 0
Local lDelete := .F.
Local cBkpVlr := ""

//Ŀ
// Inicializa a geraao de lancamentos do SIGAPCO      
//
PcoIniLan("000008")
//Ŀ
// Inicio do bloco protegido via TTS                            
//
//Begin Transaction
dbSelectArea( cAlias )

BEGIN TRANSACTION

	If lF171Auto
		If DtMovFin()
			RegToMemory("SEH",.T.,.F.)

			If (nPos := aScan(aAutoCab,{|x| x[1] == "EH_TIPO"})) > 0
				IF Alltrim(aAutoCab[nPos][2]) == "TEM"
					If (nPos := aScan(aAutoCab,{|x| x[1] == "EH_GERPARC"})) > 0
						lDelete := .T.
						cBkpVlr := aAutoCab[nPos][2]
						aDel(aAutoCab, nPos)
						aSize(aAutoCab,Len(aAutoCab)-1)					
					Endif
				Endif
			EndIf

			If EnchAuto(cAlias,aAutoCab,"Fa171TudOk(3)")
				nOpca := AxIncluiAuto(cAlias,"Fa171TudOk(3)",'Fa171Grv("'+cAlias+'")', )
				If lDelete
					RecLock("SEH",.F.)
					SEH->EH_GERPARC := cBkpVlr
					SEH->( MsUnlock() )
				Endif
			Else
				lMsErroAuto := .T.
			EndIf
		else
			lMsErroAuto := .T.
		Endif		 
	Else
		If lPanelFin
			dbSelectArea("SE5")
			RegToMemory("SE5",.T.,,,FunName())                                       
			oPanelDados := FinWindow:GetVisPanel()
			oPanelDados:FreeChildren()
			aDim := DLGinPANEL(oPanelDados)
			Inclui := .T.	
			If DtMovFin()
				nOpca := AxInclui(cAlias,nReg,nOpc,,,,"Fa171TudOk(nOpc)",,'Fa171Grv("'+cAlias+'")',,,,,,,.T.,oPanelDados,aDim,FinWindow)
			EndIf	
		Else
			If DtMovFin()
				nOpca := AxInclui(cAlias,nReg,nOpc, , , ,"Fa171TudOk(nOpc)",,'Fa171Grv("'+cAlias+'")')
			EndIf
		Endif	
	ENDIF

	//Ŀ
	// Finaliza os lancamentos do SIGAPCO e libera os bloqueios        
	//

	PcoFinLan("000008")
	PcoFreeBlq("000008")

	//Apresenta uma tela demonstrando os valores do contrato bem como o valor que dever ser pago em cada parcela
	If SEH->EH_TIPO $ 'EMP|TEM' .And. !Empty(SEH->EH_AMORTIZ) .And. nOpca == 1
		
		If lF171Auto
			If ( nPosFor := aScan( aAutoCab, { |x| x[1] = 'AUTCODFOR' } ) ) > 0
				cCodFor := Padr(aAutoCab[nPosFor, 2],TamSx3("E2_FORNECE")[1])
			EndIf
			
			If ( nPosLoja := aScan( aAutoCab, { |x| x[1] = 'AUTFORLOJA' } ) ) > 0
				cForLj := Padr(aAutoCab[nPosLoja, 2],TamSx3("E2_LOJA")[1])
			EndIf

			If !SA2->( DbSeek( xFilial("SA2") + cCodFor + cForLj ) )
				AutoGRLog(STR0025+cCodFor+" - "+cForLj+STR0026)
				lMsErroAuto := .T.
				cCodFor	:= ""
				cForLj	:= ""
				DisarmTransaction()
				Break
			EndIf
		Endif	

		cNumero := SEH->EH_NUMERO
		
		//Carrega as parcelas no arquivo temporario
		If !lF171Auto
			MsgRun( STR0043,, { || lRet := FC171Par(cNumero,nOpc) }  ) //"Aguarde, realizando o calculo das parcelas...
		Else	
			lRet := FC171Par(cNumero,nOpc)
		Endif	
		
		If lRet
			If !lF171Auto
				// Chama a view da tabela SEH
				nRet := FWExecView(cTitulo , cPrograma, nOperation, /*oDlg*/, {|| .T. } ,{ || FCAtuOK()}, /*nPercReducao*/, aEnableButtons, /*bCancel*/ , /*cOperatId*/, /*cToolBar*/, /*oModel*/ )
				Inclui := .T.
				Altera := .F.	
				If (nRet == 0)
					// Chama funo para gravao do Contas a Pagar (SE2)
					Processa({||FCGrvE2('TRB',cNumero)},STR0044) //"Aguarde, gravando as parcelas no contas a pagar..."
					//Grava os valores das despesas
					If  !Empty(SEH->EH_DESPESA) .And. ( !lSEHBase .OR. (lSEHBase .And. SEH->EH_BASEDES <> "1" ) )
						MsgRun( STR0045,, { || FCGrvE5(cNumero,.F.) }  ) //"Aguarde, gravando as despesas do contrato..."
					EndIf
				ElseIf (nRet == 1) // Cancela incluso de emprstimo
					
					//apaga registros referentes as parcelas
					RecLock("SEH",.F.)
					SEH->EH_PRAZO   := 0
					SEH->EH_AMORTIZ := ""
					SEH->EH_GERPARC := ""
					SEH->( MsUnlock() )

					MsgInfo(STR0054,STR0017)// Emprestimo Financeiro //"Processo cancelado. O emprestimo ser gravado sem a gerao de parcelas."
				EndIf
			Else
				FCGrvE2('TRB',cNumero)
				If  !Empty(SEH->EH_DESPESA) .And. ( !lSEHBase .OR. (lSEHBase .And. SEH->EH_BASEDES <> "1" ) )
					FCGrvE5(cNumero,.F.) //"Aguarde, gravando as despesas do contrato..."
				EndIf
			Endif		
		EndIf
	EndIf

END TRANSACTION

Return
/*/

Ŀ
Funo    A171Grv    Autor  Bruno Sobieski         Data  28.03.98 
Ĵ
Descrio  Programa de gravacao da aplicacao                          
Ĵ
Sintaxe    A171Grv(cAlias)                                            
Ĵ
Parametros cAlias= Alias do arquivo                                   
Ĵ
 Uso       FINA171                                                    
ٱ


/*/
Function Fa171Grv(cAlias)
	Local cPadrao    :="580"
	Local lDigita    := If(MV_PAR01==1,.T.,.F.)
	Local nHdlPrv    := 0
	Local lPadrao    := VerPadrao(cPadrao)
	Local nTotal     := 0
	Local cArquivo   := ""
	Local cHistorico := ""
	Local lFin171    := ExistBlock("FIN171")
	Local nBcoMoeda  := 1   
	Local aFlagCTB   := {}
	Local lUsaFlag   := SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/) 
	Local lAtuSldNat := .T.
	Local lFA171Bco  := ExistBlock("FA171BCO")
	Local lMovBco    := .T.
	Local oModelMov  := FWLoadModel("FINM030") //Model de Movimento Bancrio
	Local oSubFK5
	Local oSubFKA
	Local cLog := ""
	Local lRet := .T.
	Local cCamposE5 := ""
	Local nValor := 0

	If ( SEH->EH_APLEMP=="APL" )
		cHistorico := STR0016+" "+SEH->EH_TIPO //"Aplicacao Financeira"
	Else
		cHistorico := STR0017+" "+SEH->EH_TIPO //"Emprestimo Financeiro"
	EndIf
	dbSelectArea('SA6')
	dbSetOrder(1)
	If dbSeek(xFilial()+SEH->EH_BANCO+SEH->EH_AGENCIA+SEH->EH_CONTA)
		nBcoMoeda := Max(SA6->A6_MOEDA,1)
	EndIf	

	dbSelectArea("SEH")
	RecLock("SEH",.F.)
	If !lUsaFlag .and. ( mv_par02 == 1 )
		SEH->EH_LA := "S"
	ElseIf ( lPadrao .and. MV_PAR02 == 1 )
		aAdd( aFlagCTB, {"EH_LA", "S", "SEH", SEH->( Recno() ), 0, 0, 0} )
	Endif
	SEH->EH_STATUS := If( SEH->EH_SALDO < 0.01, "B", "A" )
	If lFA171Bco
		//Ŀ
		//Ponto de entrada que indica se deve movimentar ou nao banco
		//
		lMovBco := ExecBlock("FA171Bco", .F., .F., )
		If Valtype(lMovBco) <> "L"
			lMovBco := .T.
		EndIf
	EndIf

	/* 
	--- Formas de gravacao da movimentacao bancaria na exclusao de aplicacoes/emprestimos (a passar por revisao) ---
	FK5_MOEDA: Moeda do cadastro do banco (A6_MOEDA)
	FK5_VALOR:
		- Localizao Brasil: Grava o valor do EH_VLCRUZ, onde o mesmo possui 2 formas de gravacao (Gatilho - SX7) dependendo da operacao:
			- Aplicacao: Mesmo valor do EH_VALOR; 
			- Emprestimo: Converte para a moeda forte (taxa do SM2);
		- Outras localizaes: Faz a converso partindo da moeda do EH_MOEDA para a moeda do banco (taxa do SM2);
	FK5_VLMOE2:
		- Localizao Brasil: Faz a conversao do FK5_VALOR partindo da moeda forte para a moeda do EH_MOEDA (taxa do SM2);
		- Outras localizaes: Faz a converso do EH_VALOR para a moeda do EH_MOEDA (taxa do SM2); 
	FK5_TXMOED: Nao  gravado;	
	*/

	If lMovBco
		//Ŀ
		//Gera movimentacao bancaria - Aplicacao                            
		//
		
		//Define os campos que no existem nas FKs e que sero gravados apenas na E5, para que a gravao da E5 continue igual
		cCamposE5	:= Fa171CpSE5(lMovEnt05, lMovEnt06, lMovEnt07,lMovEnt08,lMovEnt09)
		
		oModelMov:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
		oModelMov:Activate()
		oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Informa se vai gravar SE5 ou no
		oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que sero gravados indepentes de FK5 
		oModelMov:SetValue( "MASTER", "NOVOPROC", .T. ) //Informa que a incluso ser feita com um novo nmero de processo
		
		//Dados do Processo
		oSubFKA := oModelMov:GetModel("FKADETAIL")
		oSubFKA:SetValue( "FKA_IDORIG", FWUUIDV4() )
		oSubFKA:SetValue( "FKA_TABORI", "FK5" )
		
		//Informacoes do movimento
		oSubFK5 := oModelMov:GetModel( "FK5DETAIL" )
		nValor := If( cPaisLoc=="BRA", SEH->EH_VLCRUZ, xMoeda( SEH->EH_VALOR,SEH->EH_MOEDA,nBcoMoeda,,,aTxMoedas[SEH->EH_MOEDA][2],aTxMoedas[nBcoMoeda][2] ) )
		oSubFK5:SetValue( "FK5_DATA", SEH->EH_DATA )
		oSubFK5:SetValue( "FK5_BANCO", SEH->EH_BANCO )
		oSubFK5:SetValue( "FK5_AGENCI", SEH->EH_AGENCIA )
		oSubFK5:SetValue( "FK5_CONTA", SEH->EH_CONTA )
		oSubFK5:SetValue( "FK5_VALOR", nValor )
		oSubFK5:SetValue( "FK5_VLMOE2", If( cPaisLoc=="BRA", xMoeda( nValor,1,SEH->EH_MOEDA ), SEH->EH_VALOR * aTxMoedas[SEH->EH_MOEDA][2] ) )
		oSubFK5:SetValue( "FK5_RECPAG", Iif(SEH->EH_APLEMP=="EMP","R","P") )
		oSubFK5:SetValue( "FK5_TPDOC", Iif(SEH->EH_APLEMP=="EMP","EP","AP") )
		oSubFK5:SetValue( "FK5_HISTOR", cHistorico )
		oSubFK5:SetValue( "FK5_DTDISP", SEH->EH_DATA )		
		oSubFK5:SetValue( "FK5_MOEDA", PADL(nBcoMoeda,TamSX3("CTO_MOEDA")[1],"0") )			
		oSubFK5:SetValue( "FK5_FILORI", SEH->EH_FILIAL )
		oSubFK5:SetValue( "FK5_DOC", SEH->EH_NUMERO+SEH->EH_REVISAO )
		oSubFK5:SetValue( "FK5_NATURE", SEH->EH_NATUREZ )
		oSubFK5:SetValue( "FK5_ORIGEM", FunName() )
		oSubFK5:SetValue( "FK5_CCUSTO", SEH->EH_CCUSTO)
		If ! lUsaFlag .and. ( mv_par02 == 1 )
			oSubFK5:SetValue( "FK5_LA", "S" )
		Endif																			
		
		//Gravao da tabela FK8 - Dados Contbeis
		Fa171GrFK8(oModelMov,lMovEnt05, lMovEnt06, lMovEnt07,lMovEnt08,lMovEnt09)

		If oModelMov:VldData()		
			oModelMov:CommitData()
		    oModelMov:DeActivate()
		Else
			lRet := .F.
			cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
		    cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
		    cLog += cValToChar(oModelMov:GetErrorMessage()[6])        	
		    
		    Help( ,,"MF171GRV",,cLog, 1, 0 )	            
		Endif
		
		AtuSalBco( SE5->E5_BANCO, SE5->E5_AGENCIA, SE5->E5_CONTA, SE5->E5_DATA, SE5->E5_VALOR,;
			        Iif( SE5->E5_RECPAG=="R", "+", "-") )
		
		If lAtuSldNat
			/*
			 * Atualiza os saldos do fluxo de caixa por natureza financeira - AtuSldNat()
			 */
			AtuSldNat(SE5->E5_NATUREZ, SE5->E5_DATA, SE5->E5_MOEDA, "3", If(SEH->EH_APLEMP=="EMP","R","P"), SEH->EH_VLCRUZ, 0, "+",,FunName(),"SE5", SE5->(Recno()),0)
		EndIf
	EndIf
	//Ŀ
	//Verifica se a natureza esta cadastrada. Se nao, cria.             
	//
	Fa171AtuNat(SE5->E5_NATUREZ,SEH->EH_APLEMP,"FINA171")

	If UsaSeqCor()
		aDiario := {{"SEH",SEH->(Recno()), SEH->EH_DIACTB, "EH_NODIA","EH_DIACTB"}}
	Else
		aDiario := {} 
	EndIf
	
	//Ŀ
	//Lancamento Contabil                                               
	//
	If ( lPadrao .and. MV_PAR02 == 1 )
		//Ŀ
		// Inicializa Lancamento Contabil                                   
		//
			nHdlPrv := HeadProva( cLote,;
			                      "FINA171" /*cPrograma*/,;
			                      Substr( cUsuario, 7, 6 ),;
			                      @cArquivo )

		//Ŀ
		// Prepara Lancamento Contabil                                      
		//
			If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil 
				aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
				aAdd( aFlagCTB, {"FK5_LA", "S", "FK5", FK5->( Recno() ), 0, 0, 0} )
			Endif
			nTotal += DetProva( nHdlPrv,;
			                    cPadrao,;
			                    "FINA171" /*cPrograma*/,;
			                    cLote,;
			                    /*nLinha*/,;
			                    /*lExecuta*/,;
			                    /*cCriterio*/,;
			                    /*lRateio*/,;
			                    /*cChaveBusca*/,;
			                    /*aCT5*/,;
			                    /*lPosiciona*/,;
			                    @aFlagCTB,;
			                    /*aTabRecOri*/,;
			                    /*aDadosProva*/ )

		//Ŀ
		// Efetiva Lanamento Contabil                                      
		//
			RodaProva( nHdlPrv,;
			           nTotal)

			cA100Incl( cArquivo,;
			           nHdlPrv,;
			           3 /*nOpcx*/,;
			           cLote,;
			           lDigita,;
			           .F. /*lAglut*/,;
			           /*cOnLine*/,;
			           /*dData*/,;
			           /*dReproc*/,;
			           @aFlagCTB,;
			           /*aDadosProva*/,;
			           aDiario )
			aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

	EndIf                   

	//Ŀ
	// Gera os lancamentos do SIGAPCO                      
	//
	PcoDetLan("000008","01","FINA171")
	DbSelectArea( cAlias )

	If lFin171 
		Execblock("FIN171",.F.,.F.)
	Endif

Return(.T.)

/*/


Ŀ
Funo    Fa171Perg  Autor  Eduardo Riera          Data  28/03/98 
Ĵ
Descrio Ativa funcao pergunte                                       
Ĵ
Sintaxe   Fa171Perg()                                                 
Ĵ
Parametros                                                            
Ĵ
 Uso      Generico                                                    
ٱ


/*/
Static Function Fa171Perg()

pergunte("AFI171",.T.)

Return(.T.)

/*/


Ŀ
Funo    Fa171TudOk Autor  Eduardo Riera          Data  28/03/98 
Ĵ
Descrio  Validacao da Inclusao da Aplicacao ou Emprestimo           
Ĵ
Sintaxe   Fa171TudOk()                                                
Ĵ
Parametros                                                            
Ĵ
 Uso      FINA171                                                     
ٱ


/*/
Function Fa171TudOk(nOpc)
LOCAL aArea    := GetArea()
LOCAL lRetorna := .F. 
Local lF171OK := ExistBlock("F171OK")

DEFAULT nOpc := 3

If UsaSeqCor()
	Private cCodDiario := SEH->EH_DIACTB
Endif

If ( M->EH_APLEMP=="APL" )
	//Ŀ
	// Validacao das Aplicacoes baseadas em contratos               
	//
	If M->EH_TIPO $(GetMv("MV_APLCAL4"))
		If !Empty(M->EH_QUOTAS) .And. !Empty(M->EH_CONTRAT)
			lRetorna := .T.
		Endif	
	Else
		//Ŀ
		// Validacao das Aplicacoes baseadas em Taxa Pr-Fixada ou      
		// correcao monetaria.                                          
		//
		If ( !Empty(M->EH_VALOR) )
			lRetorna := .T.
		EndIf
	EndIf
Else
	If ( M->EH_TAXA >= 0 .And. M->EH_VALOR != 0 .And.;
		M->EH_SALDO != 0 .And. M->EH_VLCRUZ != 0 )
		lRetorna := .T.
	EndIf
EndIf
If ( lRetorna )
	lRetorna := ExistCpo("SA6",M->EH_BANCO+M->EH_AGENCIA+M->EH_CONTA)
EndIf
If ( lRetorna .And. M->EH_VLCRUZ==0 )
	lRetorna := .F.
EndIf
If ( !lRetorna )
	Help(" ",1,"FA171TUDOK")
ElseIf CCBLOCKED(M->EH_BANCO,M->EH_AGENCIA,M->EH_CONTA) //Verifica bloqueio de conta corrente
	lRetorna := .F.
EndIf                                          
If lRetorna
	lRetorna	:=	PcoVldLan('000008','01','FINA171')	
Endif 

If UsaSeqCor()
	If !CTBvldDiario( M->EH_DIACTB, dDataBase )
		lRetorna := .F.
	EndIf
Endif

If lRetorna .And. M->EH_APLEMP == "EMP"
	If (M->EH_GERPARC == "1" .And. Empty(M->EH_AMORTIZ))
		lRetorna := .F.
		Aviso(STR0017,STR0052) // Emprestimo Financeiro //Para o modelo Emprstimo optante por gerao de parcelas, deve-se utilizar uma tabela de Amortizao!"
	EndIf
EndIf

If lRetorna .And. M->EH_APLEMP == "EMP"
	If (!Empty(M->EH_AMORTIZ) .And. M->EH_GERPARC == "1" .And. M->EH_PRAZO == 0 .And. M->EH_VLAMORP == 0)
		lRetorna := .F.
		MsgInfo(STR0017,STR0053)// Emprestimo Financeiro //"Para o modelo Emprstimo optante por gerao de parcelas vinculadas a uma tabela de Amortizao, o Prazo ou Valor Amortizao/Parcela deve ser maior que zero !"
	EndIf
EndIf

If lRetorna .And. M->EH_APLEMP == "EMP"		//aqui kco
	If !Empty(M->EH_AMORTIZ) .And. M->EH_GERPARC == "1" .And. M->EH_PRAZO == 0 .And. M->EH_VLAMORP >= 0
		nParcelas := INT(M->EH_VALOR / M->EH_VLAMORP)	//nmero aproximado de parcelas a serem gerados
		If nParcelas > __nMaxParc
			lRetorna := .F.
			//###"O nmero de parcelas a serem geradas para o emprstimo no  suportado."###""Nmero mximo de parcelas permitido: ""###"Emprestimo Financeiro"
			HELP(' ',1,STR0017,,STR0081 + CRLF + STR0082 + __cMaxParc,2,0,,,,,,{STR0021})
		Endif
	EndIf
EndIf

RestArea(aArea)

If lF171OK .And. lRetorna
	lRetorna := Execblock("F171OK",.F.,.F.)
Endif 

If ( M->EH_APLEMP=="APL" )
	If !CtbValiDt(,M->EH_DATA,,,,{"FIN001"},)
		lRetorna := .F.
	Endif
Else
	If !CtbValiDt(,M->EH_DATA,,,,{"FIN002"},)
		lRetorna := .F.
	Endif
Endif

// No permite alterar as parcelas j gravadas no contas a pagar
If nOpc == 4
	dbSelectArea("SE2")
	If SE2->(dbseek(xFilial("SE2")+M->EH_TIPO+M->EH_NUMERO))
		iF !lF171Auto
			MsgInfo(STR0019,STR0017) //"No ser alterada as parcelas j gravadas no contas a pagar!" // "Emprestimo Financeiro"
		Endif	
	EndIf
EndIf

Return(lRetorna)

/*/


Ŀ
Funo    fa171Opera Autor  Eduardo Riera          Data  28/03/98 
Ĵ
Descrio Verifica a Operacao efetuada                                
Ĵ
Sintaxe   Fa171Oper()                                                 
Ĵ
Parametros                                                            
Ĵ
 Uso      FINA171                                                     
ٱ


/*/
Function Fa171OPera()
LOCAL aArea    := { Alias() , IndexOrd() , Recno() }
LOCAL lRetorna := .T.

dbSelectArea("SX5")
dbSetOrder(1)
dbSeek(xFilial()+"11"+M->EH_TIPO)
IF ( !Found() )
	Help(" ",1,"NOTIPOAPL")
	lRetorna := .F.
EndIf

dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])
Return( lRetorna )

/*/

Ŀ
Funo    FA171Nat   Autor  Eduardo Riera                30/03/98 
Ĵ
Descrio Inicializador Padrao da Natureza Finaceira                  
Ĵ
Sintaxe   Fa171Nat()                                                  
Ĵ
 Uso       FINA171                                                    
ٱ


/*/
Function Fa171Nat()

If ( M->EH_APLEMP == "APL" )
	M->EH_NATUREZ := PadR(&(GetMv("MV_NATAPLI")),TamSX3("EH_NATUREZ")[1])
Else
	M->EH_NATUREZ := PadR(&(GetMv("MV_NATEMP")),TamSX3("EH_NATUREZ")[1])
EndIf
Fa171AtuNat(M->EH_NATUREZ,M->EH_APLEMP,"FINA171")

Return .T.

/*/


Ŀ
Funo    Fa171AtuNa Autor  Eduardo Riera          Data  31/03/98 
Ĵ
Descrio  Verifica se a Natureza foi cadastrada, se nao, cria.       
Ĵ
Sintaxe    FINA171()                                                  
Ĵ
 Uso       SIGAFIN                                                    
ٱ


/*/
Function Fa171AtuNat(cNat,cTipo,cFonte)

Local cAlias:= Alias()

dbSelectArea("SED")
dbSetOrder(1)
If !dbSeek(xFilial("SED")+cNat) .And. !Empty(cNat)
	RecLock("SED",.T.)
	Replace ED_FILIAL    With xFilial("SED")
	Replace ED_CODIGO    With cNat
	If cTipo == "EMP"
		If cFonte=="FINA171"
			Replace ED_DESCRIC   With STR0010  //"NATUREZA EMPRESTIMOS"
		Else
			Replace ED_DESCRIC   With STR0012  //"NATUREZA PGT.EMPRESTIMOS"
		Endif
	Else
		If cFonte=="FINA171"
			Replace ED_DESCRIC   With STR0011  //"NATUREZA APLICACOES"
		Else
			Replace ED_DESCRIC   With STR0013  //"NATUREZA RESG.APLICACOES"
		Endif
	EndIF
	Replace ED_CALCIRF   With "N"
	Replace ED_CALCISS   With "N"
	Replace ED_PERCIRF   With 0
	Replace ED_TIPO		 With "2"
	MsUnlock()
EndIf
dbSelectArea(cAlias)
Return 

/*/


Ŀ
Funo    Fa171Cdi   Autor  Andr Luiz B. Silva  Data  14/02/2013 
Ĵ
Descrio "	Validao de campos quando EH_CLSIOF == 1                 
Ĵ
Sintaxe   Fa171Cdi ()                                                 
Ĵ
Parametros                                                            
Ĵ
 Uso      FINA171                                                     
ٱ


/*/

Function Fa171Cdi()

Local lRetorna := .T.  
Local lClsIof  := .T.

If lClsIof
	If (INCLUI .AND. ALLTRIM(M->EH_TIPO) == 'CDI' .And. ALLTRIM(M->EH_CLSIOF) == '1' )
		lRetorna := .F. 
	EndIf
Endif

Return( lRetorna )

/*/


Ŀ
Funo    fa171Apl   Autor  Eduardo Riera          Data  12/04/98 
Ĵ
Descrio Valicacao dos campos pertencentes a aplicacao               
Ĵ
Sintaxe   Fa171Apl ()                                                 
Ĵ
Parametros                                                            
Ĵ
 Uso      FINA171                                                     
ٱ


/*/
Function Fa171Apl()
LOCAL aArea    := { Alias() , IndexOrd() , Recno() }
LOCAL lRetorna := .F.

If ( INCLUI .And. M->EH_APLEMP=="APL" )
	lRetorna := .T.
EndIf

dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])
Return( lRetorna )

/*/


Ŀ
Funo    fa171Emp   Autor  Eduardo Riera          Data  12/04/98 
Ĵ
Descrio Valicacao dos campos pertencentes ao emprestimo             
Ĵ
Sintaxe   Fa171Emp ()                                                 
Ĵ
Parametros                                                            
Ĵ
 Uso      FINA171                                                     
ٱ


/*/
Function Fa171Emp()
LOCAL aArea    := { Alias() , IndexOrd() , Recno() }
LOCAL lRetorna := .F.

If ( INCLUI .And. M->EH_APLEMP=="EMP" )
	lRetorna := .T.
EndIf

dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])
Return( lRetorna )

/*/


Ŀ
Funo    Fa171AtuVl Autor  Alexandre Silva        Data  10/01/02 
Ĵ
Descrio Faz a conversao do valor para Multi-Moedas,baseado no array 
aTxMoeda, que contem o valor da moeda na contacao atual, ou digitada   
pelo usuario.                                                          
Ĵ
Sintaxe   Fa171Atuvl()                                                
Ĵ
Parametros                                                            
Ĵ
 Uso      FINA171                                                     
ٱ


/*/
Function Fa171AtuVl(lValid)
Local uRetorno  := 0

DEFAULT lValid := .F. // Sera utilizada para validar ou para obter o valor da operacao ?

	If M->EH_MOEDA >= 1 .And. M->EH_MOEDA <= MoedFin() 
		If lValid
			uRetorno := .T.
		Else	
			uRetorno := M->EH_VALOR * aTxMoedas[M->EH_MOEDA][2]
		Endif	
	Else
		Help( " ",1,"SEMMOEDA" )
		If lValid
			uRetorno := .F.
		Else	
			uRetorno := M->EH_VALOR
		Endif	
	EndIf	

Return uRetorno 


/*/

Ŀ
Funo    Fa181Legenda Autor  Mauricio Pequin Jr.  Data  05.05.08 
Ĵ
Descrio  Cria uma janela contendo a legenda da mBrowse ou retorna a 
           para o BROWSE                                              
Ĵ
 Uso       Fina181                                                    
ٱ


/*/
Function Fa171Legenda(nReg)

Local aLegenda := {{"BR_VERDE", 	STR0090 },;	//"Aplicao com Saldo"
						{"BR_VERMELHO",STR0091 }}	//"Aplicao Resgatada"   
Local uRetorno := .T.

If nReg = Nil	// Chamada direta da funcao onde nao passa, via menu Recno eh passado
	uRetorno := {}
	Aadd(uRetorno, { 'EH_SALDO <= 0'	, aLegenda[2][1] } )
	Aadd(uRetorno, { 'EH_SALDO > 0'	, aLegenda[1][1] } )
Else
	BrwLegenda(cCadastro, "Legenda", aLegenda)
Endif

Return uRetorno
/*/


Ŀ
Programa  MenuDef    Autor  Ana Paula N. Silva      Data 23/11/06 
Ĵ
Descrio  Utilizacao de menu Funcional                               
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          		1 - Pesquisa e Posiciona em um Banco de Dados     
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
Ĵ
   DATA    Programador   Manutencao efetuada                         
Ĵ
                                                                     
ٱ


/*/
Static Function MenuDef()
Local aRotina := {}
	
aAdd(aRotina,{STR0001	, "AxPesqui" 	, 0, 1,,.F.})	//Pesquisar
aAdd(aRotina,{STR0002	, "AxVisual"	, 0, 2})		//"Visualizar"
aAdd(aRotina,{STR0003	, "A171Inclui"	, 0, 3})		//"Incluir"
aAdd(aRotina,{STR0004	, "A171Altera"	, 0, 4})		//"Alterar"
aAdd(aRotina,{STR0005	, "A171Exclui"	, 0, 5})		//"Excluir"
aAdd(aRotina,{STR0041   , "FC171_V"		, 0, 8})		//"Visualizar Parcelas"
aAdd(aRotina,{STR0042   , "FC171Imp"	, 0, 2})		//"Imprimir Parcelas"
aAdd(aRotina,{STR0066	, "Fa171Idx"	, 0, 2,,.F.})	//"Taxas dos ndices"
aAdd(aRotina,{STR0018	, "Fa171Legenda", 0, 2,,.F.})	//"Legenda"
	
Return(aRotina)

/*/

Ŀ
Funo    FinA171T    Autor  Marcelo Celi Marques  Data  04.04.08 
Ĵ
Descrio  Chamada semi-automatica utilizado pelo gestor financeiro   
Ĵ
 Uso       FINA171                                                    
ٱ


/*/
Function FinA171T(aParam)
	cRotinaExec := "FINA171"
	ReCreateBrow("SEH",FinWindow)      		
	FinA171(aParam[1])
	ReCreateBrow("SEH",FinWindow)      	

	dbSelectArea("SEH")
	
	INCLUI := .F.
	ALTERA := .F.

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} FN171SE5
Funo para encontrar o registro de SE5 correspondente ao movimento
da aplicao ou emprstimo posicionado (SEH) 

@param cTpDoc, Tipo Doc que ser considerado na busca ("AP" ou "EP")
@return nRecno, identificao do registro na SE5
@author Pedro Alencar
@since 08/05/2014
@version P12
/*/
//-------------------------------------------------------------------
Static Function FN171SE5 (cTpDoc)
	Local nRecno := 0
	Local cQuery := ""
	Local cDocumen := ""
	Local cAliasTMP := ""
	Default cTpDoc := "AP"
	
	//Concatena o nmero e a reviso da aplicao (SEH) para buscar na SE5 (E5_DOCUMEN)
	cDocumen := SEH->EH_NUMERO + SEH->EH_REVISAO
	
	cQuery := "SELECT R_E_C_N_O_ "
	cQuery += "FROM " + RetSqlName("SE5") + " SE5 "
	cQuery += "WHERE SE5.E5_DOCUMEN = '" + cDocumen + "' "
	cQuery += "AND SE5.E5_TIPODOC = '" + cTpDoc  + "' " 
	cQuery += "AND SE5.E5_DATA = '" + DTOS(SEH->EH_DATA) + "'"  
	
	cQuery := ChangeQuery(cQuery)				
	cAliasTMP := GetNextAlias()
	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasTMP, .T., .F. )
	
	//Pega o recno da SE5 referente a aplicao
	( cAliasTMP )->( dbGoTop() )				
	nRecno := ( cAliasTMP )->R_E_C_N_O_
	
	(cAliasTMP)->( dbCloseArea() )
	FErase( cAliasTMP + GetDBExtension() )	
		
Return nRecno

//------------------------------------------------------------------------------------------
/* {Protheus.doc} ModelDef
Monta a tela demonstrando os valores do Contrato bem como o valor que dever ser pago
em cada parcela (ou amortizado a cada ms).
@author    Ronaldo Tapia
@version   11.80
@since     24/06/2016
@protected
*/
//------------------------------------------------------------------------------------------

Static Function ModelDef()

// Cria as estruturas a serem usadas no Modelo de Dados
Local oStruSEH  := FWFormStruct(1, 'SEH')
Local oStruFLY1 := MontaSCab()
Local oModel    

// Posiciona no arquivo correto
dbSelectArea("SEH")
SEH->(MsSeek(xFilial("SEH")+cNumero))

// Code block com as parcelas do financiamento/emprestimo
bLoad := {|oGridModel, lCopy| bLoadGrd}

// Cria o objeto do Modelo de Dados
oModel := MPFormModel():New('FINA171')
//oModel := MPFormModel():New( 'FINA171', ,{ |oModel| FCTeste( oModel ) } )

// Adiciona ao modelo um componente de formulrio
oModel:AddFields( 'SEHMASTER', /*cOwner*/, oStruSEH )
	
//Adiciona ao modelo um componente de grid
oModel:AddGrid( 'FLYDETAIL', 'SEHMASTER', oStruFLY1,,,,,bLoad)

//Criao de relao entre as entidades do modelo (SetRelation)
oModel:SetRelation( 'FLYDETAIL', { { 'EH_FILIAL', 'xFilial( "SEH" )' }, { 'EH_NUMERO' , 'EH_NUMERO'  } } , SEH->( IndexKey( 1 ) )  )
	
// Adiciona a descrio do Modelo de Dados
oModel:SetDescription(STR0038) //"Detalhe do valor do contrato e suas parcelas"

// Adiciona a descrio dos Componentes do Modelo de Dados
oModel:GetModel( 'SEHMASTER' ):SetDescription(STR0039) //"Detalhe do Emprestimo/Financiamento"
oModel:GetModel( 'FLYDETAIL' ):SetDescription(STR0040) //"Projeo de valor das parcelas do contrato"

oModel:GetModel( 'FLYDETAIL' ):SetNoInsertLine( .T. )

//Define uma chave primaria (obrigatorio mesmo que vazia)	
oModel:SetPrimaryKey( {} )

Return oModel


//------------------------------------------------------------------------------------------
/* {Protheus.doc} ViewDef
Visualiza a tela demonstrando os valores do Contrato

@author    Ronaldo Tapia
@version   11.80
@since     24/06/2016
@protected
*/
//------------------------------------------------------------------------------------------

Static Function ViewDef()

// Cria as estruturas a serem usadas na View
Local oStruSEH  := FWFormStruct(2, 'SEH')
Local oStruFLY1 := MontaSView()
Local cConsSEH  := "EH_VALOR;EH_ENTRADA;EH_FINANC;EH_PRAZO;EH_CARENCI;EH_AMORTIZ,EH_NUMERO;EH_NBANCO;EH_TAXA;EH_TXEFETI;EH_VLAMORP"
Local aStruSEH  := SEH->(DbStruct())
Local nAtual    := 0

// Interface de visualizao construda
Local oView  

//Percorre a estrutura da SEH para remover os campos que no iro aparecer na cabecalho
For nAtual := 1 To Len(aStruSEH)
	//Se o campo atual no estiver nos que forem considerados
	If ! Alltrim(aStruSEH[nAtual][01]) $ cConsSEH
		oStruSEH:RemoveField(aStruSEH[nAtual][01])
	EndIf
Next

// Cria o objeto de View
oView := FWFormView():New()

// Cria um objeto de Modelo de dados baseado no ModelDef do fonte informado
oModel := FWLoadModel( 'FINA171' )

// Adiciona botes
oView:AddUserButton(STR0037, 'FORNECE', {|oView| FC171Fornece() } )	//"Definir Fornecedor"

// Define qual Modelo de dados ser utilizado
oView:SetModel( oModel )
		
// Adiciona no nosso View um controle do tipo formulrio (antiga Enchoice)
oView:AddField( 'VIEW_SEH', oStruSEH, 'SEHMASTER' )
	
//Adiciona no nosso View um controle do tipo Grid (antiga Getdados)
oView:AddGrid( 'VIEW_FLY', oStruFLY1, 'FLYDETAIL' )
	
// Cria um "box" horizontal para receber cada elemento da view
oView:CreateHorizontalBox( 'SUPERIOR', 33 )
oView:CreateHorizontalBox( 'INFERIOR', 67 )
		
// Relaciona o identificador (ID) da View com o "box" para exibio
oView:SetOwnerView( 'VIEW_SEH', 'SUPERIOR' )
oView:SetOwnerView( 'VIEW_FLY', 'INFERIOR' )
	
// Liga a identificacao do componente
oView:EnableTitleView( 'VIEW_SEH' )
oView:EnableTitleView( 'VIEW_FLY' )

// Nao exibe a mensagem de atualizacao
oView:ShowUpdateMsg(.F.)		

Return oView


//------------------------------------------------------------------------------------------
/*/ {Protheus.doc} FC171Par
Realiza o calculo das parcelas para apresentacao em tela

@author    Ronaldo Tapia
@version   11.80
@since     24/06/2016
@protected
/*/
//------------------------------------------------------------------------------------------

Static Function FC171Par(cNumero,nOpc)

Local lRet		:= .T.
Local aCalculo 	:= {}
Local dDataVenc	:= STOD("")
Local dPrimVenc	:= STOD("")
Local lPriParc 	:= .T.
Local nParcela 	:= 1
Local nI	   	:= 1	
Local nValAmor 	:= 0
Local nValCorr 	:= 0
Local nValDeb  	:= 0
Local nValJuros	:= 0
Local nValPrest	:= 0
Local nTotJuros	:= 0
Local nTotPrest	:= 0
Local nTcSql	:= 0
Local i		   	:= 1
Local lCarencia	:= .F.
Local lRetCar  	:= .T.
Local cTPCaren 	:= SuperGetMV("MV_TPCAREN",.F.,"1")
Local nCont    	:= 0
Local lJurCar  	:= SEH->EH_JURCAR == "1"
Local lSEHBase 	:= SEH->(ColumnPos("EH_BASEDES")) > 0
Local nX       	:= 0

// Array com os campos utilizados na view
Local aCampos := {;
	{"PARCELA   ","N", __nTamPraz,0},;
	{"DATAX     ","D", 8,0},;
	{"VALOR     ","N",14,2},;
	{"JUROS     ","N",14,2},;
	{"VCORRIGIDO","N",14,2},;
	{"AMORTIZA  ","N",14,2},;
	{"PRESTACAO ","N",14,2} }
	
Default cNumero := SEH->EH_NUMERO

//Limpa o codeblock bLoadGrd
If len(bLoadGrd) > 0
	aSize(bLoadGrd,0)
EndIf

// Verifica se j teve movimentao para o emprstimo e aborta visualizao
If nOpc == 9
	dbSelectArea("SEI")
	SEI->(DbSetOrder(1))
	If SEI->(DbSeek(xFilial("SEI")+"EMP"+cNumero)) 
		IW_MsgBox(STR0035,STR0017, "INFO" ) // //"Emprestimo Financeiro"
		Return .F.
	EndIf
EndIf

// Se o emprestimo no tem parcelas geradas no mostro a projeo das parcelas em tela.
If nOpc == 9
	dbSelectArea("SE2")
	SE2->(dbSetOrder(1))	//Prefixo+Numero+Parcela
	If !(SE2->(DbSeek(xFilial("SE2")+SEH->EH_TIPO+cNumero)))
		IW_MsgBox(STR0046, "INFO" ) // //"Emprestimos no possui parcelas."
		Return .F.
	Endif
Endif
	
dbSelectArea("SEH")

//Ŀ
// Cria arquivo de Trabalho   
//
If(_oFINA171 <> NIL)

	//-- Limpa registros para nova execuo
	nTcSql := TcSQLExec("DELETE FROM " + __cGetrealname )
	If nTcSql < 0
		//-- Se ocorrer algum problema refaz a temporaria
		_oFINA171:Delete()
		_oFINA171 := Nil
	EndIf
EndIf

If _oFINA171 == Nil

	_oFINA171 := FwTemporaryTable():New("TRB")
	_oFINA171:SetFields(aCampos)
	_oFINA171:AddIndex("1",{"PARCELA"})
	_oFINA171:Create()

	__cGetrealname := _oFINA171:GetRealName()
EndIf

nPosParc :=  aScan( aAutoCab, { |x| x[1] = 'PARCELAS' } ) // A execauto ja calculou as parcelas
If lF171Auto .and. nPosParc > 0
	For nX := 1 to len(aAutoCab[nPosParc][2])	
		RecLock( "TRB", .T. )
			REPLACE &(aAutoCab[nPosParc][2][nX][1][1]) WITH	aAutoCab[nPosParc][2][nX][1][2]
			REPLACE &(aAutoCab[nPosParc][2][nX][2][1]) WITH	aAutoCab[nPosParc][2][nX][2][2]
			REPLACE &(aAutoCab[nPosParc][2][nX][3][1]) WITH	aAutoCab[nPosParc][2][nX][3][2]
			REPLACE &(aAutoCab[nPosParc][2][nX][4][1]) WITH	aAutoCab[nPosParc][2][nX][4][2]
			REPLACE &(aAutoCab[nPosParc][2][nX][5][1]) WITH	aAutoCab[nPosParc][2][nX][5][2]
			REPLACE &(aAutoCab[nPosParc][2][nX][6][1]) WITH	aAutoCab[nPosParc][2][nX][6][2]
			REPLACE &(aAutoCab[nPosParc][2][nX][7][1]) WITH aAutoCab[nPosParc][2][nX][7][2]
		msUnlock()
	Next nX
Else
	// Data de vencimento da primeira parcela (fixa 30 dias para teste)
	dPrimVenc := DaySum(SEH->EH_DATA,30)
	dDataVenc := DaySum(SEH->EH_DATA,30)

	// Valor do debito inicial
	If lSEHBase
		If SEH->EH_BASEDES == "1" //Compe taxas e despesas na base de calculo dos juros
			nValDeb := SEH->EH_SALDO+SEH->EH_VALIOF+SEH->EH_TARIFA+SEH->EH_DESPESA+SEH->EH_SPREAD
		Else
			nValDeb := SEH->EH_SALDO
		Endif
	Else 
		nValDeb := SEH->EH_SALDO
	Endif

	// Considera o valor informado no campo de amortizao
	If !Empty(SEH->EH_VLAMORP)
		nValAmor := SEH->EH_VLAMORP
		If nOpc == 3 .and. !lF171Auto
			IW_MsgBox(STR0034,STR0017, "INFO" ) //"Ser considerado para clculo o valor informado no campo Valor Amortizao/Parcela!" //"Emprestimo Financeiro"
		EndIf
	Else
		// Calcula valor da amortizao
		nValAmor := Round(nValDeb/SEH->EH_PRAZO,2)
	EndIf

	// Verifica se emprestimo tem carncia
	If !Empty(SEH->EH_CARENCI)
		lCarencia:= .T.
	EndIf

	// Preenche o temporario
	While SEH->EH_NUMERO == cNumero .And. xFilial("SEH") == SEH->EH_FILIAL
		
		/*******************************************************************************************/
		/*******************************************************************************************/
		/*Calcula os valores com base no valor da amortizao/parcela informada no campo EH_VLAMORP*/
		/*******************************************************************************************/
		If Empty(SEH->EH_PRAZO) .And. !Empty(SEH->EH_VLAMORP)
			/**************/
			/* Tabela SAC */
			/**************/
			If SEH->EH_AMORTIZ == "2"	
				While If(lPriParc, nValDeb >= nValAmor, nValDeb > nValAmor)
				
					/*********** Emprestimo com Carncia***********/
					If lCarencia
						For i:=1 to SEH->EH_CARENCI
							If !lPriParc
								// Data de vencimento da parcela subsequente
								dDataVenc := DaySum(TRB->DATAX,30)
							EndIf
							
							// Calcula o valor do debito
							nValDeb := nValDeb
							
							If SEH->EH_JURCAR == "1"	
								// Realiza o calculo das parcelas atraves da funo Fa171Calc presente no FINXFUN
								aCalculo := Fa171Calc(dPrimVenc, nValDeb, .F.)
								nValJuros := aCalculo[1][2]
							Else
								nValJuros := 0
							EndIf
							
							// Valor de amortizao  zero na carncia
							nValAmor := 0
							
							// Calcula o valor corrigido
							nValCorr := nValDeb + nValJuros
							
							// Calcula o valor da prestao
							nValPrest := nValJuros
							
							/**********************************************/
							/*Grava o temporario com os valores calculados*/
							/**********************************************/	
							RecLock( "TRB", .T. )
							REPLACE PARCELA		WITH	nParcela
							REPLACE DATAX      	WITH	dDataVenc
							REPLACE VALOR		WITH	nValDeb
							REPLACE JUROS		WITH	nValJuros
							REPLACE VCORRIGIDO	WITH	nValCorr
							REPLACE AMORTIZA	WITH	nValAmor
							REPLACE PRESTACAO	WITH	nValPrest
							msUnlock()
							
							lPriParc := .F.
						
							//Totaliza totais de juros e prestao
							nTotJuros += nValJuros
							nTotPrest += nValPrest
					
							// Soma uma parcela
							nParcela++							
						Next i	
						
						// Define carncia como falso para seguir o clculo das parcelas
						lCarencia := .F.				
					
					/***********Calculo sem Carncia***********/
					Else
						// Valor de amortizao
						nValAmor := SEH->EH_VLAMORP
						
						If !lPriParc
							// Data de vencimento da parcela sequente
							dDataVenc := DaySum(TRB->DATAX,30)
							
							// Calcula o valor do debito
							nValDeb := nValDeb - nValAmor		
						EndIf
						
						// Realiza o calculo das parcelas atraves da funo Fa171Calc presente no FINXFUN
						aCalculo := Fa171Calc(dPrimVenc, nValDeb, .F.)		
				
						// Calcula o valor dos juros
						nValJuros := aCalculo[1][2]
						
						// Calcula o valor corrigido
						nValCorr := nValDeb + nValJuros
						
						// Calcula o valor da prestao
						nValPrest := nValJuros + nValAmor
							
						/**********************************************/
						/*Grava o temporario com os valores calculados*/
						/**********************************************/	
						If nValDeb < nValAmor
							// Grava o valor da ltima parcela
							RecLock( "TRB", .T. )
							REPLACE PARCELA		WITH	nParcela
							REPLACE DATAX      	WITH	dDataVenc
							REPLACE VALOR			WITH	nValDeb
							REPLACE JUROS			WITH	nValJuros
							REPLACE VCORRIGIDO	WITH	nValCorr
							REPLACE AMORTIZA		WITH	nValDeb
							REPLACE PRESTACAO		WITH	nValCorr
							msUnlock()
							
							// Atualiza o total com o valor da ultima parcela
							nValPrest := nValCorr
							
						Else
							RecLock( "TRB", .T. )
							REPLACE PARCELA		WITH	nParcela
							REPLACE DATAX      	WITH	dDataVenc
							REPLACE VALOR			WITH	nValDeb
							REPLACE JUROS			WITH	nValJuros
							REPLACE VCORRIGIDO	WITH	nValCorr
							REPLACE AMORTIZA		WITH	nValAmor
							REPLACE PRESTACAO		WITH	nValPrest
							msUnlock()
						EndIf
						
						lPriParc := .F.
						
						//Totaliza totais de juros e prestao
						nTotJuros += nValJuros
						nTotPrest += nValPrest
				
						// Soma uma parcela
						nParcela++	
							
					EndIf
				Enddo
							
			/****************/
			/* Tabela PRICE */	
			/****************/	
			Else
				While nValDeb > nValPrest
					
					/*********** Emprestimo com Carncia***********/
					If lCarencia
						For i:=1 to SEH->EH_CARENCI
							If !lPriParc
								// Data de vencimento da parcela sequente
								dDataVenc := DaySum(TRB->DATAX,30)
							EndIf
							
							// Calcula o valor do debito
							nValDeb := nValDeb
							
							If SEH->EH_JURCAR == "1"	
								// Realiza o calculo das parcelas atraves da funo Fa171Calc presente no FINXFUN
								aCalculo := Fa171Calc(dPrimVenc, nValDeb, .F.)
								nValJuros := aCalculo[1][2]
							Else
								nValJuros := 0
							EndIf
							
							// Valor de amortizao  zero na carncia
							nValAmor := 0
							
							// Calcula o valor corrigido
							nValCorr := nValDeb + nValJuros
							
							// Calcula o valor da prestao
							nValPrest := nValJuros
							
							/**********************************************/
							/*Grava o temporario com os valores calculados*/
							/**********************************************/	
							RecLock( "TRB", .T. )
							REPLACE PARCELA		WITH	nParcela
							REPLACE DATAX      	WITH	dDataVenc
							REPLACE VALOR		WITH	nValDeb
							REPLACE JUROS		WITH	nValJuros
							REPLACE VCORRIGIDO	WITH	nValCorr
							REPLACE AMORTIZA	WITH	nValAmor
							REPLACE PRESTACAO	WITH	nValPrest
							msUnlock()
							
							lPriParc := .F.
						
							//Totaliza totais de juros e prestao
							nTotJuros += nValJuros
							nTotPrest += nValPrest
					
							// Soma uma parcela
							nParcela++							
						Next i	
						
						// Define carncia como falso para seguir o clculo das parcelas
						lCarencia := .F.
						
					/***********Calculo sem Carncia***********/	
					Else
					
						// Valor de amortizao
						nValPrest := SEH->EH_VLAMORP
						
						If !lPriParc
							// Data de vencimento da parcela sequente
							dDataVenc := DaySum(TRB->DATAX,30)
						EndIf
							
						// Recalcula o valor do debito quando no for a primeira parcela
						If !lPriParc			
							// Calcula o valor do debito
							nValDeb := nValDeb - nValAmor
						EndIf
							
						// Realiza o calculo das parcelas atraves da funo Fa171Calc presente no FINXFUN
						aCalculo := Fa171Calc(dPrimVenc, nValDeb, .F.)		
					
						// Calcula o valor dos juros
						nValJuros := aCalculo[1][2]
							
						// Calcula o valor da prestao para o sistema PRICE
						If lPriParc
							// Calcula a taxa de juros mensal
							nTaxaJur := nValJuros/nValDeb
								
							// Considera o valor da parcela informada no campo EH_VLAMORP
							nValPrest := SEH->EH_VLAMORP
		
							// Calcula o valor corrigido
							nValCorr := nValDeb + nValJuros
						EndIf
							
						// Calcula valor da amortizao
						nValAmor := nValPrest - nValJuros
							
						If !lPriParc
							// Calcula o valor corrigido
							nValCorr := nValDeb + nValJuros
						EndIf	
						
						/**********************************************/
						/*Grava o temporario com os valores calculados*/
						/**********************************************/
						If nValDeb < nValPrest
							// Grava o valor da ltima parcela
							RecLock( "TRB", .T. )
							REPLACE PARCELA		WITH	nParcela
							REPLACE DATAX      	WITH	dDataVenc
							REPLACE VALOR		WITH	nValDeb
							REPLACE JUROS		WITH	nValJuros
							REPLACE VCORRIGIDO	WITH	nValCorr
							REPLACE AMORTIZA	WITH	nValDeb
							REPLACE PRESTACAO	WITH	nValCorr
							msUnlock()	
							
							// Atualiza o total com o valor da ultima parcela
							nValPrest := nValCorr
										
						Else
							RecLock( "TRB", .T. )
							REPLACE PARCELA		WITH	nParcela
							REPLACE DATAX      	WITH	dDataVenc
							REPLACE VALOR			WITH	nValDeb
							REPLACE JUROS			WITH	nValJuros
							REPLACE VCORRIGIDO	WITH	nValCorr
							REPLACE AMORTIZA		WITH	nValAmor
							REPLACE PRESTACAO		WITH	nValPrest
							msUnlock()
						EndIf
								
						lPriParc := .F.
						
						//Totaliza totais de juros e prestao
						nTotJuros += nValJuros
						nTotPrest += nValPrest
				
						// Soma uma parcela
						nParcela++
					EndIf
				Enddo
			EndIf
				
				
		/*********************************************************************************/
		/*********************************************************************************/
		/*Calcula os valores com base no prazo informado no campo EH_PRAZO					*/
		/*********************************************************************************/
		Else
		
			nCont := IIF(cTPCaren=="1",SEH->EH_PRAZO - SEH->EH_CARENCI, SEH->EH_PRAZO) //Determina se a carncia  considera dentro ou fora do prazo informado

			For nI := 1 to nCont
				
				/**************/
				/* Tabela SAC */
				/**************/
				If SEH->EH_AMORTIZ == "2"	
				
					/*********** Emprestimo com Carncia***********/
					If lCarencia
						For i:=1 to SEH->EH_CARENCI
							If !lPriParc
								// Data de vencimento da parcela sequente
								dDataVenc := DaySum(TRB->DATAX,30)
							EndIf
							
							// Realiza o calculo das parcelas atraves da funo Fa171Calc presente no FINXFIN
							aCalculo  := Fa171Calc(dPrimVenc, nValDeb, .F.)
							nValJuros := aCalculo[1][2]
							
							// Valor de amortizao  zero na carncia
							nValAmor := 0
							
							//Calcula o valor corrigido, considerando ou no os juros na carencia conforme definido no campo EH_JURCAR
							nValCorr := IIF(lJurCar, nValDeb, nValDeb+nValJuros)
							
							//Calcula a prestao no periodo de carencia considerando os juros caso definido no campo EH_JURCAR
							nValPrest := IIF(lJurCar, nValJuros, 0)

							/**********************************************/
							/*Grava o temporario com os valores calculados*/
							/**********************************************/	
							RecLock( "TRB", .T. )
							REPLACE PARCELA		WITH	nParcela
							REPLACE DATAX      	WITH	dDataVenc
							REPLACE VALOR		WITH	nValDeb
							REPLACE JUROS		WITH	nValJuros
							REPLACE VCORRIGIDO	WITH	nValCorr
							REPLACE AMORTIZA	WITH	nValAmor
							REPLACE PRESTACAO	WITH	nValPrest
							msUnlock()
							
							lPriParc := .F.
							nValDeb  := nValCorr //Atualiza coluna valor debito com o valor corrigido, para assim exibir o valor debito correto na proxima parcela
						
							//Totaliza totais de juros e prestao
							nTotJuros += nValJuros
							nTotPrest += nValPrest
					
							// Soma uma parcela
							nParcela++							
						Next i					
						
						// Define carncia como falso para seguir o clculo das parcelas
						lCarencia := .F.
						lRetCar   := .F.
						lPriParc  := .T.
						nI := 0 // Volta uma posio do for para calcular a quantidade certa de parcelas
					
						Loop

					/***********Calculo sem Carncia***********/		
					Else
					
						If lPriParc
							// Calcula valor da amortizao
							If cTPCaren == "1"					
								nValAmor := nValDeb/(SEH->EH_PRAZO-SEH->EH_CARENCI)
							ElseIf cTPCaren == "2"
								// Carencia fora do prazo do emprestimo
								nValAmor := nValDeb/SEH->EH_PRAZO
							EndIf
						Endif				

						If nParcela > 1 .And. lPriParc
							// Data de vencimento da parcela sequente
							dDataVenc := DaySum(TRB->DATAX,30)
						EndIf

						If !lPriParc
							// Data de vencimento da parcela sequente
							dDataVenc := DaySum(TRB->DATAX,30)
							
							// Calcula o valor do debito
							nValDeb := nValDeb - nValAmor		
						EndIf
						
						// Realiza o calculo das parcelas atraves da funo Fa171Calc presente no FINXFUN
						aCalculo := Fa171Calc(dPrimVenc, nValDeb, .F.)		
				
						// Calcula o valor dos juros
						nValJuros := aCalculo[1][2]
						
						// Calcula o valor corrigido
						nValCorr := nValDeb + nValJuros
						
						// Calcula o valor da prestao
						nValPrest := nValJuros + nValAmor
						
						lRetCar   := .T. // Define variavel para impressao
					EndIf
				
				/****************/
				/* Tabela PRICE */	
				/****************/
				Else
				
					/*********** Emprestimo com Carncia***********/
					If lCarencia
						For i:=1 to SEH->EH_CARENCI
							If !lPriParc
								// Data de vencimento da parcela sequente
								dDataVenc := DaySum(TRB->DATAX,30)
							EndIf
							
							// Realiza o calculo das parcelas atraves da funo Fa171Calc presente no FINXFIN
							aCalculo  := Fa171Calc(dPrimVenc, nValDeb, .F.)
							nValJuros := aCalculo[1][2]

							// Valor de amortizao  zero na carncia
							nValAmor := 0
							
							//Calcula o valor corrigido, considerando ou no os juros na carencia conforme definido no campo EH_JURCAR
							nValCorr := IIF(lJurCar, nValDeb, nValDeb+nValJuros)
							
							//Calcula a prestao no periodo de carencia considerando os juros caso definido no campo EH_JURCAR
							nValPrest := IIF(lJurCar, nValJuros, 0)
							
							/**********************************************/
							/*Grava o temporario com os valores calculados*/
							/**********************************************/	
							RecLock( "TRB", .T. )
							REPLACE PARCELA		WITH	nParcela
							REPLACE DATAX      	WITH	dDataVenc
							REPLACE VALOR		WITH	nValDeb
							REPLACE JUROS		WITH	nValJuros
							REPLACE VCORRIGIDO	WITH	nValCorr
							REPLACE AMORTIZA	WITH	nValAmor
							REPLACE PRESTACAO	WITH	nValPrest
							msUnlock()
							
							lPriParc := .F.
							nValDeb  := nValCorr //Atualiza coluna valor debito com o valor corrigido, para assim exibir o valor debito correto na proxima parcela
						
							//Totaliza totais de juros e prestao
							nTotJuros += nValJuros
							nTotPrest += nValPrest		
							
							// Soma uma parcela
							nParcela++			
						Next i					
						
						// Define carncia como falso para seguir o clculo das parcelas
						lCarencia := .F.
						lRetCar   := .F.
						lPriParc  := .T.
						nI := 0 // Volta uma posio do for para calcular a quantidade certa de parcelas

						Loop
					
					/***********Calculo sem Carncia***********/
					Else
						
						If nParcela > 1 .And. lPriParc
							// Data de vencimento da parcela sequente
							dDataVenc := DaySum(TRB->DATAX,30)
						EndIf

						If !lPriParc
							// Data de vencimento da parcela sequente
							dDataVenc := DaySum(TRB->DATAX,30)
						EndIf
						
						// Recalcula o valor do debito quando no for a primeira parcela
						If !lPriParc			
							// Calcula o valor do debito
							nValDeb := nValDeb - nValAmor
						EndIf
						
						// Realiza o calculo das parcelas atraves da funo Fa171Calc presente no FINXFIN
						aCalculo := Fa171Calc(dPrimVenc, nValDeb, .F.)		
				
						// Calcula o valor dos juros
						nValJuros := aCalculo[1][2]
						
						// Calcula o valor da prestao para o sistema PRICE
						If lPriParc
							// Calcula a taxa de juros mensal
							nTaxaJur := nValJuros/nValDeb
		
							// Calcula o valor da prestao
							If cTPCaren = "1"
								If nTaxaJur > 0
									nValPrest := nValDeb*(((1+nTaxaJur)^(SEH->EH_PRAZO-SEH->EH_CARENCI))*nTaxaJur/(((1+nTaxaJur)^(SEH->EH_PRAZO-SEH->EH_CARENCI))-1))
								Else
									nValPrest := nValDeb/(SEH->EH_PRAZO-SEH->EH_CARENCI)
								EndIf
							ElseIf cTPCaren = "2"	
								If nTaxaJur > 0
									// Carencia fora do prazo do emprestimo
									nValPrest := nValDeb*(((1+nTaxaJur)^SEH->EH_PRAZO)*nTaxaJur/(((1+nTaxaJur)^SEH->EH_PRAZO)-1))
								Else						
									nValPrest := nValDeb/SEH->EH_PRAZO
								EndIf
							EndIf 
							
							// Calcula o valor corrigido
							nValCorr := nValDeb + nValJuros
						EndIf
						
						// Calcula valor da amortizao
						nValAmor := nValPrest - nValJuros
						
						If !lPriParc
							// Calcula o valor corrigido
							nValCorr := nValDeb + nValJuros
						EndIf
						
						lRetCar   := .T. // Define variavel para impressao
					EndIf
				EndIf			

				If lRetCar
					/**********************************************/
					/*Grava o temporario com os valores calculados*/
					/**********************************************/
					RecLock( "TRB", .T. )
					REPLACE PARCELA		WITH	nParcela
					REPLACE DATAX      	WITH	dDataVenc
					REPLACE VALOR		WITH	nValDeb
					REPLACE JUROS		WITH	nValJuros
					REPLACE VCORRIGIDO	WITH	nValCorr
					REPLACE AMORTIZA	WITH	nValAmor
					REPLACE PRESTACAO	WITH	nValPrest
					msUnlock()
					
					// Soma uma parcela
					nParcela++					
					lPriParc := .F.	
				EndIf
				
				//Totaliza totais de juros e prestao
				nTotJuros += nValJuros
				nTotPrest += nValPrest

			Next
		EndIf
		
		// Ajusta valor total das parcelas quando emprstimo com carncia 
		If SEH->EH_AMORTIZ == "2" .And. !Empty(SEH->EH_CARENCI) .And. !Empty(SEH->EH_VLAMORP)
			nTotPrest := nTotPrest + nValAmor
		EndIf
		
		// Grava o total do emprestimo/financiamento no temporario
		RecLock( "TRB", .T. )
		REPLACE PARCELA		WITH	__nLastPar
		REPLACE VALOR		WITH	0
		REPLACE JUROS		WITH	nTotJuros
		REPLACE VCORRIGIDO	WITH	0
		REPLACE AMORTIZA	WITH	SEH->EH_SALDO
		REPLACE PRESTACAO	WITH	nTotPrest
		msUnlock()	

		SEH->( dbSkip() )
	Enddo
Endif

/******************************************************/
/*Grava os valores do temporario no codeblock bLoadGrd*/
/******************************************************/
TRB->(dbGoTop())
While !TRB->(eof())
	aAdd(bLoadGrd,{0,{TRB->PARCELA, TRB->DATAX, TRB->VALOR, TRB->JUROS,TRB->VCORRIGIDO ,TRB->AMORTIZA ,TRB->PRESTACAO}})
	TRB->(dbSkip())
EndDo

Return lRet

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FC171_V
Visualiza o calculo das parcelas para apresentacao em tela

@author    Ronaldo Tapia
@version   11.80
@since     24/06/2016
@protected
*/
//------------------------------------------------------------------------------------------

Function FC171_V()

Local cTitulo    := ""
Local cPrograma  := 'FinA171'
Local nOperation := MODEL_OPERATION_VIEW
Local lRet		   := .T.
Local nOpc		   := 9

//Apresenta uma tela demonstrando os valores do Contrato bem como o valor que dever ser pago em cada parcela
If SEH->EH_TIPO == 'EMP' .And. !Empty(SEH->EH_AMORTIZ)

	cNumero := SEH->EH_NUMERO
	//Carrega as parcelas no arquivo temporario
	MsgRun(STR0033,, { || lRet := FC171Par(cNumero,nOpc) }  ) //"Aguarde, realizando o calculo das parcelas...
EndIf

If lRet
	// Chama a view da tabela SEH
	lRetorna := FWExecView(cTitulo , cPrograma, nOperation, /*oDlg*/, {|| .T. } ,/*bOk*/ , /*nPercReducao*/, /*aEnableButtons*/, /*bCancel*/ , /*cOperatId*/, /*cToolBar*/, /*oModel*/ )
EndIf

Return()


//-------------------------------------------------------------------
/*/{Protheus.doc} MontaSCab()
Retorna estrutura do tipo FWformModelStruct.

@author Ronaldo Tapia

@since 27/06/2016
@version 1.0
/*/
//-------------------------------------------------------------------

Static function MontaSCab()

Local aArea    := GetArea()
Local oStruct := FWFormModelStruct():New()

// Tabela
oStruct:AddTable('SEH',{'PARCELA','DATAX','VALOR','JUROS','VCORRIGIDO','AMORTIZA','PRESTACAO'},"Cabealho do TRB")// Campos do cabealho do TRB

// Campos
oStruct:AddField(	STR0068						,; 	// [01] C Titulo do campo // "Parcela"
					STR0068						,; 	// [02] C ToolTip do campo // "Parcela"
					"PARCELA"	 				,; 	// [03] C identificador (ID) do Field
					"N" 						,; 	// [04] C Tipo do campo
					3							,; 	// [05] N Tamanho do campo
					0 							,; 	// [06] N Decimal do campo
					Nil							,; 	// [07] B Code-block de validao do campo
					Nil							,; 	// [08] B Code-block de validao When do campo
					Nil 						,; 	// [09] A Lista de valores permitido do campo
			      	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatrio
					Nil							,; 	// [11] B Code-block de inicializacao do campo
					Nil 						,;	// [12] L Indica se trata de um campo chave
					.T.		 					,; 	// [13] L Indica se o campo no pode receber valor em uma operao de update.
					.F. )  	            		// [14] L Indica se o campo  virtual
					
oStruct:AddField(	STR0069						,; 	// [01] C Titulo do campo // "Vencimento"
					STR0069						,; 	// [02] C ToolTip do campo // "Vencimento"
					"DATA" 						,; 	// [03] C identificador (ID) do Field
					"D" 						,; 	// [04] C Tipo do campo
					8							,; 	// [05] N Tamanho do campo
					0 							,; 	// [06] N Decimal do campo
					Nil							,; 	// [07] B Code-block de validao do campo
					Nil							,; 	// [08] B Code-block de validao When do campo
					Nil 						,; 	// [09] A Lista de valores permitido do campo
			      	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatrio
					Nil							,; 	// [11] B Code-block de inicializacao do campo
					Nil 						,;	// [12] L Indica se trata de um campo chave
					.T.		 					,; 	// [13] L Indica se o campo no pode receber valor em uma operao de update.
					.F. )  	            		// [14] L Indica se o campo  virtual	
					
oStruct:AddField(	STR0070						,; 	// [01] C Titulo do campo // "Valor do Dbito"
					STR0070						,; 	// [02] C ToolTip do campo // "Valor do Dbito"
					"VALOR" 					,; 	// [03] C identificador (ID) do Field
					"N" 						,; 	// [04] C Tipo do campo
					14							,; 	// [05] N Tamanho do campo
					2							,; 	// [06] N Decimal do campo
					Nil							,; 	// [07] B Code-block de validao do campo
					Nil							,; 	// [08] B Code-block de validao When do campo
					Nil 						,; 	// [09] A Lista de valores permitido do campo
			      	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatrio
					Nil							,; 	// [11] B Code-block de inicializacao do campo
					Nil 						,;	// [12] L Indica se trata de um campo chave
					.T.		 					,; 	// [13] L Indica se o campo no pode receber valor em uma operao de update.
					.F. )  	            		// [14] L Indica se o campo  virtual	
					
oStruct:AddField(	STR0071						,; 	// [01] C Titulo do campo // "Juros"
					STR0071						,; 	// [02] C ToolTip do campo // "Juros"
					"JUROS" 					,; 	// [03] C identificador (ID) do Field
					"N" 						,; 	// [04] C Tipo do campo
					14							,; 	// [05] N Tamanho do campo
					2							,; 	// [06] N Decimal do campo
					Nil							,; 	// [07] B Code-block de validao do campo
					Nil							,;  // [08] B Code-block de validao When do campo
					Nil 						,; 	// [09] A Lista de valores permitido do campo
			      	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatrio
					Nil							,; 	// [11] B Code-block de inicializacao do campo
					Nil 						,;	// [12] L Indica se trata de um campo chave
					.T.		 					,; 	// [13] L Indica se o campo no pode receber valor em uma operao de update.
					.F. )  	            		// [14] L Indica se o campo  virtual	
	
oStruct:AddField(	STR0072						,; 	// [01] C Titulo do campo // "Valor Corrigido"
					STR0072						,; 	// [02] C ToolTip do campo // "Valor Corrigido"
					"VCORRIGIDO"				,; 	// [03] C identificador (ID) do Field
					"N" 						,; 	// [04] C Tipo do campo
					14							,; 	// [05] N Tamanho do campo
					2							,; 	// [06] N Decimal do campo
					Nil 						,; 	// [07] B Code-block de validao do campo
					Nil							,; 	// [08] B Code-block de validao When do campo
					Nil 						,; 	// [09] A Lista de valores permitido do campo
			      	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatrio
					Nil							,; 	// [11] B Code-block de inicializacao do campo
					Nil 						,;	// [12] L Indica se trata de um campo chave
					.F.		 					,; 	// [13] L Indica se o campo no pode receber valor em uma operao de update.
					.F. )  	            		// [14] L Indica se o campo  virtual	

oStruct:AddField(	STR0073						,; 	// [01] C Titulo do campo // "Amortizao"
					STR0073						,; 	// [02] C ToolTip do campo // "Amortizao"
					"AMORTIZA" 					,; 	// [03] C identificador (ID) do Field
					"N" 						,; 	// [04] C Tipo do campo
					14							,; 	// [05] N Tamanho do campo
					2 							,; 	// [06] N Decimal do campo
					Nil 						,; 	// [07] B Code-block de validao do campo
					Nil							,; 	// [08] B Code-block de validao When do campo
					Nil 						,; 	// [09] A Lista de valores permitido do campo
			      	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatrio
					Nil							,; 	// [11] B Code-block de inicializacao do campo
					Nil 						,;	// [12] L Indica se trata de um campo chave
					.T.		 					,; 	// [13] L Indica se o campo no pode receber valor em uma operao de update.
					.F. )  	            		// [14] L Indica se o campo  virtual	
	
oStruct:AddField(	STR0074						,; 	// [01] C Titulo do campo // "Prestao"
					STR0074						,; 	// [02] C ToolTip do campo // "Prestao"
					"PRESTACAO"					,; 	// [03] C identificador (ID) do Field
					"N" 						,; 	// [04] C Tipo do campo
					14							,; 	// [05] N Tamanho do campo
					2							,; 	// [06] N Decimal do campo
					Nil 						,; 	// [07] B Code-block de validao do campo
					Nil							,; 	// [08] B Code-block de validao When do campo
					Nil 						,; 	// [09] A Lista de valores permitido do campo
			      	Nil 						,;	// [10] L Indica se o campo tem preenchimento obrigatrio
					Nil							,; 	// [11] B Code-block de inicializacao do campo
					Nil 						,;	// [12] L Indica se trata de um campo chave
					.T.		 					,; 	// [13] L Indica se o campo no pode receber valor em uma operao de update.
					.F. )  	            		// [14] L Indica se o campo  virtual		
					
// Indices
oStruct:AddIndex( 	1	      						, ;     // [01] Ordem do indice
					"01"   							, ;     // [02] ID
					"PARCELA"				  		, ;		// [03] Chave do indice
					"Indice 1" + " + " + "Parcela"	, ;     // [04] Descrio do indice
					""       						, ;		// [05] Expresso de lookUp dos campos de indice (SIX_F3)
					"" 								, ;		// [06] Nickname do indice
					.T. )      								// [07] Indica se o indice pode ser utilizado pela interface
					
oStruct:AddIndex( 	2	      						, ;     // [01] Ordem do indice
					"02"   							, ;     // [02] ID
					"DATAX"				  		    , ; 	// [03] Chave do indice
					"Indice 2" + " + " + "Data"		, ;     // [04] Descrio do indice
					""       						, ;		// [05] Expresso de lookUp dos campos de indice (SIX_F3)
					"" 								, ;		// [06] Nickname do indice
					.T. )    

RestArea( aArea )

Return oStruct   

//-------------------------------------------------------------------
/*/{Protheus.doc} MontaSView()
Retorna estrutura do tipo FWFormViewStruct.

@author Ronaldo Tapia

@since 27/06/2016
@version 1.0
/*/
//-------------------------------------------------------------------

Static function MontaSView()
Local oStruct  := FWFormViewStruct():New()
Local cPicture := "@E " + CValToChar(__nLastPar)

		/* Estutura para a criao de campos na view	
		
			[01] C Nome do Campo
			[02] C Ordem
			[03] C Titulo do campo  
			[04] C Descrio do campo  
			[05] A Array com Help
			[06] C Tipo do campo
			[07] C Picture
			[08] B Bloco de Picture Var
			[09] C Consulta F3
			[10] L Indica se o campo  editvel
			[11] C Pasta do campo
			[12] C Agrupamento do campo
			[13] A Lista de valores permitido do campo (Combo)
			[14] N Tamanho Maximo da maior opo do combo
			[15] C Inicializador de Browse
			[16] L Indica se o campo  virtual
			[17] C Picture Varivel
	
		*/

// Campos
oStruct:AddField("PARCELA",    "01", STR0068, STR0068, {}, "N", cPicture		   , /*bPictVar*/, /*cLookUp*/, .T.) 
oStruct:AddField("DATA",       "02", STR0069, STR0069, {}, "D", "@!"			   , /*bPictVar*/, /*cLookUp*/, .T.) 
oStruct:AddField("VALOR",      "03", STR0070, STR0070, {}, "N", "@E 999,999,999.99", /*bPictVar*/, /*cLookUp*/, .T.) 
oStruct:AddField("JUROS",      "04", STR0071, STR0071, {}, "N", "@E 999,999,999.99", /*bPictVar*/, /*cLookUp*/, .T.) 
oStruct:AddField("VCORRIGIDO", "05", STR0072, STR0072, {}, "N", "@E 999,999,999.99", /*bPictVar*/, /*cLookUp*/, .T.) 
oStruct:AddField("AMORTIZA",   "06", STR0073, STR0073, {}, "N", "@E 999,999,999.99", /*bPictVar*/, /*cLookUp*/, .T.) 
oStruct:AddField("PRESTACAO",  "07", STR0074, STR0074, {}, "N", "@E 999,999,999.99", /*bPictVar*/, /*cLookUp*/, .T.) 

Return oStruct

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FCGrvE2
Funo para gravao das parcelas no contas a pagar (SE2)

@author    Ronaldo Tapia
@version   11.80
@since     04/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

Static Function FCGrvE2(cArqTmp,cNumero)

Local aArray	:= {}
Local cParcela	:= ""
Local dData		:= STOD("")
Local nValor	:= 0
Local nJuros	:= 0
Local aArea		:= GetArea()
Local nTamFor	:= TamSX3("E2_FORNECE")[1]
Local cForPar	:= PadR(SuperGetMV("MV_FOREMPR",.F.,"000001"),nTamFor)
Local nNumReg	:= Len(bLoadGrd)
Local nTotVal	:= 0

Private lMsErroAuto := .F.

If Empty(cCodFor)
	cCodFor := cForPar
	
	DbSelectArea("SA2")
	SA2->( DbSetOrder(1) )
	
	If SA2->( DbSeek( xFilial("SA2") + cCodFor ) )
		cForLj := SA2->A2_LOJA
	EndIf
EndIf

// Posiciona no arquivo correto
dbSelectArea("SEH")
SEH->(MsSeek(xFilial("SEH")+cNumero))

If !lF171Auto
	ProcRegua(nNumReg)
Endif	

(cArqTmp)->(dbGoTop())
While (cArqTmp)->(!EOF()) 

	BEGIN TRANSACTION
	
		If !lF171Auto
			// Alimenta barra de progresso
			IncProc(STR0032+cParcela) //"Gravando Parcela: "     
		Endif	            

		cParcela	:= cValtoChar((cArqTmp)->PARCELA)
		dData		:= (cArqTmp)->DATAX
		nValor		:= (cArqTmp)->PRESTACAO
		nJuros		:= (cArqTmp)->JUROS
		
		// Tratamento para parcelas com carncia, grava somente o valor dos juros
		If (cArqTmp)->AMORTIZA == 0 .And. (cArqTmp)->JUROS > 0
			nValor := 0.01
		EndIf
	
		// Ajusta valor da ltima parcela
		If cParcela == cValtoChar(nNumReg - 1)
			If nTotVal + (cArqTmp)->AMORTIZA < SEH->EH_FINANC
				nValor := Round(SEH->EH_FINANC - nTotVal,2) + (cArqTmp)->JUROS
			EndIf
		EndIf

		aArray := {	{ "E2_PREFIXO"		, SEH->EH_TIPO      , NIL },;
						{ "E2_NUM"      , SEH->EH_NUMERO    , NIL },;
						{ "E2_PARCELA"  , cParcela          , NIL },;
						{ "E2_TIPO"     , "PR"              , NIL },;
						{ "E2_NATUREZ"  , SEH->EH_NATUREZA  , NIL },;
						{ "E2_FORNECE"  , cCodFor           , NIL },;
						{ "E2_LOJA"		, cForLj            , NIL },;
						{ "E2_EMISSAO"  , SEH->EH_DATA		, NIL },;
						{ "E2_VENCTO"   , dData				, NIL },;            	
						{ "E2_JUROS"    , nJuros			, NIL },;
						{ "E2_MOEDA"    , SEH->EH_MOEDA		, NIL },;
						{ "E2_VALOR"    , nValor			, NIL },;										
						{ "E2_DEBITO"   , SEH->EH_DEBITO	, NIL },;
						{ "E2_CREDIT"   , SEH->EH_CREDIT	, NIL },;					
						{ "E2_CCUSTO"   , SEH->EH_CCUSTO	, NIL },;		
						{ "E2_CCD"   	, SEH->EH_CCD		, NIL },;													
						{ "E2_CCC"   	, SEH->EH_CCC		, NIL },;		
						{ "E2_ITEMD"   	, SEH->EH_ITEMD		, NIL },;
						{ "E2_ITEMC"   	, SEH->EH_ITEMC		, NIL },;
						{ "E2_CLVLDB"  	, SEH->EH_CLVLDB	, NIL },;
						{ "E2_CLVLCR"  	, SEH->EH_CLVLCR	, NIL },;
						{ "E2_ORIGEM"   , "FINA171"			, NIL } }				

		If lMovEnt05
			AADD(aArray,{ "E2_EC05DB"  	, SEH->EH_EC05DB	, NIL })
			AADD(aArray,{ "E2_EC05CR"  	, SEH->EH_EC05CR	, NIL })
		EndIf 

		If lMovEnt06
			AADD(aArray,{ "E2_EC06DB"  	, SEH->EH_EC06DB	, NIL })
			AADD(aArray,{ "E2_EC06CR"  	, SEH->EH_EC06CR	, NIL })
		EndIf 

		If lMovEnt07
			AADD(aArray,{ "E2_EC07DB"  	, SEH->EH_EC07DB	, NIL })
			AADD(aArray,{ "E2_EC07CR"  	, SEH->EH_EC07CR	, NIL })
		EndIf 

		If lMovEnt08
			AADD(aArray,{ "E2_EC08DB"  	, SEH->EH_EC08DB	, NIL })
			AADD(aArray,{ "E2_EC08CR"  	, SEH->EH_EC08CR	, NIL })
		EndIf 

		If lMovEnt09
			AADD(aArray,{ "E2_EC09DB"  	, SEH->EH_EC09DB	, NIL })
			AADD(aArray,{ "E2_EC09CR"  	, SEH->EH_EC09CR	, NIL })
		EndIf 

		nTotVal += (cArqTmp)->AMORTIZA
		
		// S grava a parcela se for diferente de 999 e maior que zero
		If cParcela <> CValToChar(__nLastPar) .And. nValor > 0    
			// Grava os valores no SE2
			MsExecAuto( { |x,y,z| FINA050(x,y,z)}, aArray,, 3)  // 3 - Inclusao, 4 - Alterao, 5 - Excluso
			If lMsErroAuto .and. !lF171Auto
				MostraErro()
				DisarmTransaction()
			Endif
		EndIf
			
	END TRANSACTION

	If lMsErroAuto
		Exit
	Endif

	(cArqTmp)->(dbSkip())
EndDo
 
// Mostra erro
If !lMsErroAuto
	If !lF171Auto
		IW_MsgBox(STR0031,STR0017, "INFO" ) //"Parcelas includas com sucesso!" //"Emprestimo Financeiro"
	Endif	
Endif

RestArea(aArea)

Return	

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FCGrvE5
Funo para gravao das despesas do contrato na SE5

@author    Ronaldo Tapia
@version   11.80
@since     04/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

Static Function FCGrvE5(cNumero,lEstorno)

Local nValor 	   := 0
Local cHistorico := ""
Local lUsaFlag   := SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/) 
Local lAtuSldNat := FindFunction("AtuSldNat") .AND. AliasInDic("FIV") .AND. AliasInDic("FIW")
Local nMoedaBco	 := 1	

Local oModelMov := FWLoadModel("FINM030") //Model de Movimento Bancrio
Local oSubFK5
Local oSubFKA
Local cLog := ""
Local lRet := .T.
Local cCamposE5 := ""
Local cSinal	:= ""

DEFAULT lEstorno	:= .F.

If lEstorno
	cHistorico := STR0075 //"Estorno Desp.Emprestimo/Financ."
Else
	cHistorico := STR0030 //"Despesas Emprestimos/Financiamentos"
EndIf

// Posiciona no arquivo correto
dbSelectArea("SEH")
SEH->(MsSeek(xFilial("SEH")+cNumero))

dbSelectArea('SA6')
dbSetOrder(1)
If dbSeek(xFilial()+SEH->EH_BANCO+SEH->EH_AGENCIA+SEH->EH_CONTA)
	nMoedaBco := Max(SA6->A6_MOEDA,1)
EndIf

/* 
--- Formas de gravacao da movimentacao bancaria das despesas do contrato (a passar por revisao) ---
FK5_MOEDA: Fixado na moeda forte;
FK5_VALOR: Converte as despesas partindo da moeda do EH_MOEDA para a moeda do banco (A6_MOEDA);
FK5_VLMOE2: Faz a conversao do FK5_VALOR partindo da moeda forte para a moeda do EH_MOEDA (taxa do SM2);
FK5_TXMOED: Nao  gravado;
*/

If !Empty(SEH->EH_SPREAD)
	If SEH->EH_MOEDA > 1	
		nValor := xMoeda(SEH->EH_DESPESA + SEH->EH_SPREAD,SEH->EH_MOEDA,nMoedaBco)
	Else
		nValor := SEH->EH_DESPESA + SEH->EH_SPREAD
	EndIf
Else
	If SEH->EH_MOEDA > 1
		nValor := 	xMoeda(((SEH->EH_FINANC*SEH->EH_PSPREAD)/100) + SEH->EH_DESPESA,SEH->EH_MOEDA,nMoedaBco)		
	Else
		nValor := ((SEH->EH_FINANC*SEH->EH_PSPREAD)/100) + SEH->EH_DESPESA
	EndIf
EndIf

If nValor > 0
	//Define os campos que no existem nas FKs e que sero gravados apenas na E5, para que a gravao da E5 continue igual
	cCamposE5	:= Fa171CpSE5(lMovEnt05, lMovEnt06, lMovEnt07,lMovEnt08,lMovEnt09)

				
	oModelMov := FWLoadModel("FINM030") //Recarrega o Model de movimentos para pegar o campo do relacionamento 
	oModelMov:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
	oModelMov:Activate()
	oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Informa se vai gravar SE5 ou no
	oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que sero gravados indepentes de FK5 
	oModelMov:SetValue( "MASTER", "NOVOPROC", .F. ) //Informa que a incluso no ser feita com um novo nmero de processo
					
	//Dados do Processo
	oSubFKA := oModelMov:GetModel("FKADETAIL")
	oSubFKA:SetValue( "FKA_IDORIG", FWUUIDV4() )
	oSubFKA:SetValue( "FKA_TABORI", "FK5" )
	
	//Informacoes do movimento
	oSubFK5 := oModelMov:GetModel( "FK5DETAIL" )
	If lEstorno
		oSubFK5:SetValue( "FK5_DATA", dDataBase )
		oSubFK5:SetValue( "FK5_RECPAG","R" )
		oSubFK5:SetValue( "FK5_DTDISP", dDataBase )
	Else
		oSubFK5:SetValue( "FK5_DATA", SEH->EH_DATA )
		oSubFK5:SetValue( "FK5_RECPAG","P" )
		oSubFK5:SetValue( "FK5_DTDISP", SEH->EH_DSPREAD )
	EndIf
	oSubFK5:SetValue( "FK5_BANCO", SEH->EH_BANCO )
	oSubFK5:SetValue( "FK5_AGENCI", SEH->EH_AGENCIA )
	oSubFK5:SetValue( "FK5_CONTA", SEH->EH_CONTA )				
	oSubFK5:SetValue( "FK5_VALOR", nValor )
	If SEH->EH_MOEDA <> 1
		oSubFK5:SetValue( "FK5_VLMOE2", xMoeda( nValor, 1, SEH->EH_MOEDA ) )
	EndIf
	oSubFK5:SetValue( "FK5_TPDOC", "DB" )
	oSubFK5:SetValue( "FK5_HISTOR", cHistorico )
	oSubFK5:SetValue( "FK5_MOEDA", "01" )			
	oSubFK5:SetValue( "FK5_FILORI", SEH->EH_FILIAL )
	oSubFK5:SetValue( "FK5_DOC", SEH->EH_NUMERO+SEH->EH_REVISAO )
	oSubFK5:SetValue( "FK5_ORIGEM", FunName() )				
	If !lUsaFlag .and. ( MV_PAR02 == 1 )
		oSubFK5:SetValue( "FK5_LA", "S" )
	Endif
	oSubFK5:SetValue( "FK5_NATURE", SEH->EH_NATUREZ )
	oSubFK5:SetValue( "FK5_CCUSTO", SEH->EH_CCUSTO)

	//Gravao da tabela FK8 - Dados Contbeis
	Fa171GrFK8(oModelMov,lMovEnt05, lMovEnt06, lMovEnt07,lMovEnt08,lMovEnt09)

	If oModelMov:VldData()		
		oModelMov:CommitData()
	    oModelMov:DeActivate()
	Else
		lRet := .F.
		cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
	    cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
	    cLog += cValToChar(oModelMov:GetErrorMessage()[6]) 
	    
	    Help( ,,"MF171EXC",,cLog, 1, 0 )	            
	Endif
					
	If lRet
		cSinal	:= IIf(SE5->E5_RECPAG == "R", "+", "-") 
		AtuSalBco( SE5->E5_BANCO, SE5->E5_AGENCIA, SE5->E5_CONTA, SE5->E5_DATA, SE5->E5_VALOR,cSinal)
						
		 // Atualiza os saldos do fluxo de caixa por natureza financeira - AtuSldNat()
		If lAtuSldNat			
			AtuSldNat(SE5->E5_NATUREZ, SE5->E5_DATA, SE5->E5_MOEDA, "3", "P", SEH->EH_DESPESA, 0, Iif(lEstorno,"-","+"),,FunName(),"SE5", SE5->(Recno()),0)
		EndIf
	Endif
EndIf

Return

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FC171VPAR
Faz verificacao do numero de parcelas do contrato de emprestimo/Financiamento

@author    Ronaldo Tapia
@version   11.80
@since     04/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

Function FC171VPAR(nParceEmp)

Local lRet		:= .T.

Default nParceEmp := M->EH_PRAZO

//Validaes do tamanho do campo E2_PARCELA
If nParceEmp > __nMaxParc
	If !lF171Auto
		//###"O nmero de parcelas a serem geradas para o emprstimo no  suportado."###""Nmero mximo de parcelas permitido: "###" Para aumentar altere o grupo de campos PARCELA."###"Emprestimo Financeiro"
		HELP(' ',1,STR0017,,STR0081 + CRLF + STR0082 + CValToChar(__nMaxParc),2,0,,,,,,{STR0021})
	Else
		AutoGRLog(STR0020+STR(nMaxParc)+STR0021)
		lMsErroAuto := .T.
	Endif

	lRet := .F.
Endif

If lRet .and. !Empty(M->EH_PRAZO) .And. !Empty(M->EH_VLAMORP)
	If !lF171Auto
		MsgInfo(STR0022,STR0017) //"Se o valor de parcela/amortizao estiver preenchido no  possvel definir o campo Prazo!" //"Emprestimo Financeiro"
	Else
		AutoGRLog(STR0022)
	Endif

	lRet := .F.
EndIf

Return lRet

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FC171VEnt
Validao no valor da entrada (EH_ENTRADA)

@author    Ronaldo Tapia
@version   11.80
@since     07/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

Function FC171VEnt()

//Validaes do tamanho do campo E2_ENTRADA
If M->EH_ENTRADA > M->EH_VALOR 
	MsgInfo(STR0023,STR0017) //"Valor da entrada no pode ser maior que o valor da operao!" //"Emprestimo Financeiro"
Endif

Return .T.

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FC171VAm
Validao no valor da parcela/amortizacao (EH_PRAZO)

@author    Ronaldo Tapia
@version   11.80
@since     07/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

Function FC171VAm(nValAmor)

Default nValAmor := M->EH_VLAMORP

//Validaes do tamanho do campo EH_VLAMORP
If !Empty(M->EH_VLAMORP) .And. !Empty(M->EH_PRAZO) 
	MsgInfo(STR0024,STR0017) //"Se o Prazo estiver preenchido no  possvel definir um valor de parcela/amortizao!"  //"Emprestimo Financeiro"
	Return .F.
EndIf

Return .T.

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FC171Imp
Imprime os dados do contrato com cabealho e parcelas provisrias

@author    Ronaldo Tapia
@version   11.80
@since     11/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

Function FC171Imp()

Local oReport := Nil	
Local cPerg:= "FC171Imp"

oReport := RptDef(cPerg)
oReport:PrintDialog()

Return

// Monta a estrutura das sees do relatrio
Static Function RptDef(cNome As Character) As Object

	Local oReport   As Object
	Local oSection1 As Object
	Local oSection2 As Object

	oReport   := Nil
	oSection1 := Nil
	oSection2 := Nil
		
	/*Sintaxe: TReport():New(cNome,cTitulo,cPerguntas,bBlocoCodigo,cDescricao)*/
	oReport := TReport():New(cNome, STR0028, cNome, {|oReport| ReportPrint(oReport)}, STR0029) //"Contrato de Emprstimo - Demonstrativo Mensal" //"Demonstrativo das parcelas do contrato de emprstimo" 
	oReport:SetPortrait()    
	oReport:lParamPage := .F.
		
	oSection1:= TRSection():New(oReport, upper(STR0087), {"SEH"}, , .F., .T.)
	TRCell():New(oSection1,"EH_NUMERO",	"SEH", NIL, /*Picture*/, /*Tamanho*/, /*lPixel*/, /*{|| code-block de impressao }*/)
	TRCell():New(oSection1,"EH_TAXA",	"SEH", NIL, /*Picture*/, /*Tamanho*/, /*lPixel*/, /*{|| code-block de impressao }*/)
	TRCell():New(oSection1,"EH_VALOR",	"SEH", NIL, /*Picture*/, /*Tamanho*/, /*lPixel*/, /*{|| code-block de impressao }*/)
	TRCell():New(oSection1,"EH_ENTRADA","SEH", NIL, /*Picture*/, /*Tamanho*/, /*lPixel*/, /*{|| code-block de impressao }*/)
	TRCell():New(oSection1,"EH_FINANC",	"SEH", NIL, /*Picture*/, /*Tamanho*/, /*lPixel*/, /*{|| code-block de impressao }*/)
	TRCell():New(oSection1,"EH_PRAZO",	"SEH", NIL, /*Picture*/, /*Tamanho*/, /*lPixel*/, /*{|| code-block de impressao }*/)
	TRCell():New(oSection1,"EH_CARENCI","SEH", NIL, /*Picture*/, /*Tamanho*/, /*lPixel*/, /*{|| code-block de impressao }*/)
	TRCell():New(oSection1,"EH_AMORTIZ","SEH", NIL, /*Picture*/, /*Tamanho*/, /*lPixel*/, /*{|| code-block de impressao }*/)
	TRCell():New(oSection1,"EH_VLAMORP","SEH", NIL, /*Picture*/, /*Tamanho*/, /*lPixel*/, /*{|| code-block de impressao }*/)
		
	oSection2:= TRSection():New(oReport, upper(STR0088), {"TRB"}, NIL, .F., .T.)
	TRCell():New(oSection2,"PARCELA",	"TRB", STR0068, /*Picture*/,/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
	TRCell():New(oSection2,"DEBITO",	"TRB", STR0070, "@E 999,999,999.99",/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
	TRCell():New(oSection2,"VENC",		"TRB", STR0069, /*Picture*/,/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
	TRCell():New(oSection2,"JUROS",		"TRB", STR0071, PesqPict("SE2","E2_JUROS" ),TamSX3("E2_JUROS" )[1],/*lPixel*/,/*{|| code-block de impressao }*/)
	TRCell():New(oSection2,"CORRIG",	"TRB", STR0072, "@E 999,999,999.99",/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
	TRCell():New(oSection2,"AMORTIZ",	"TRB", STR0073, "@E 999,999,999.99",/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)	
	TRCell():New(oSection2,"PRESTA",	"TRB", STR0074, "@E 999,999,999.99",/*Tamanho*/,/*lPixel*/,/*{|| code-block de impressao }*/)
	TRCell():New(oSection2,"SALDO",		"TRB", STR0089, PesqPict("SE2","E2_SALDO" ),TamSX3("E2_SALDO" )[1],/*lPixel*/,/*{|| code-block de impressao }*/)		

Return(oReport)


// Imprime os dados do contrato e o demonstrativo das parcelas provisrias
// geradas no contas a pagar (SE2)
Static Function ReportPrint(oReport)

Local oSection1 := oReport:Section(1)
Local oSection2 := oReport:Section(2)	 
Local cNumero   := ""
Local cAliasQry := GetNextAlias()
Local cQuery	  := " "
Local nValCorr  := 0
Local nValPres  := 0
Local nValDeb   := 0
Local nValor    := 0
Local nTotJur   := 0
Local nTotPres  := 0
Local dDtvenc   := STOD("")
Local dDataIni  := STOD("")
Local nSaldo    := 0

If oReport:Cancel()
	Return .T.
EndIf

//Apresenta relatrio demonstrando os valores do Contrato bem como o valor que dever ser pago em cada parcela
cNumero := SEH->EH_NUMERO

// Inicializo a primeira seo
oSection1:Init()
oReport:IncMeter()

// Posiciona no arquivo correto da SEH
dbSelectArea("SEH")
SEH->(MsSeek(xFilial("SEH")+cNumero))
				
IncProc(STR0027) //"Imprimindo parcelas do contrato de emprstimo"
		
// Imprimo a primeira seo				
oSection1:Cell("EH_NUMERO"):SetValue(SEH->EH_NUMERO)
oSection1:Cell("EH_TAXA"):SetValue(SEH->EH_TAXA)
oSection1:Cell("EH_VALOR"):SetValue(SEH->EH_VALOR)	
oSection1:Cell("EH_ENTRADA"):SetValue(SEH->EH_ENTRADA)	
oSection1:Cell("EH_FINANC"):SetValue(SEH->EH_FINANC)	
oSection1:Cell("EH_PRAZO"):SetValue(SEH->EH_PRAZO)	
oSection1:Cell("EH_CARENCI"):SetValue(SEH->EH_CARENCI)	
If SEH->EH_AMORTIZ == "1"
	oSection1:Cell("EH_AMORTIZ"):SetValue("Price")
Else
	oSection1:Cell("EH_AMORTIZ"):SetValue("SAC")
EndIf	
oSection1:Cell("EH_VLAMORP"):SetValue(SEH->EH_VLAMORP)	
				
oSection1:Printline()
		
// Inicializo e imprimo a segunda seo
oSection2:init()

// Query para buscar as parcelas no contas a pagar
cQuery:=''
cQuery:= " SELECT E2_FILIAL, E2_PREFIXO, E2_NUM, E2_PARCELA, E2_VALOR, E2_VENCREA, E2_JUROS, E2_SALDO "
cQuery+= " FROM "+RetSqlName("SE2")+" SE2 "
cQuery+= " WHERE SE2.D_E_L_E_T_ =' ' "
cQuery+= " AND E2_FILIAL = '"+xFilial("SEH")+"' "
cQuery+= " AND E2_PREFIXO = 'EMP' "
cQuery+= " AND E2_NUM = '"+cNumero+"' "
cQuery+= " ORDER BY E2_VENCREA "

cQuery := ChangeQuery(cQuery)

If (Select(cAliasQry) <> 0)
	dbSelectArea(cAliasQry)
	dbCloseArea()
Endif
dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )

Dbselectarea(cAliasQry)
dbgotop()

// Valor do Debito total do emprstimo
nValDeb := SEH->EH_FINANC

While (cAliasQry)->(!EOF())

	// Se prestao for de 0.01 apresenta valor de 0
	If (cAliasQry)->E2_VALOR <> 0.01
		nValor   := (cAliasQry)->E2_VALOR - (cAliasQry)->E2_JUROS
		nValPres := (cAliasQry)->E2_VALOR
	Else
		nValor   := 0
		nValPres := (cAliasQry)->E2_JUROS
	EndIf
	
	// Calcula o valor corrigido e da prestao
	nValCorr := nValDeb + (cAliasQry)->E2_JUROS
	dDtvenc  := STOD((cAliasQry)->E2_VENCREA)
	
	// Formato saldo para apresentao
	If (cAliasQry)->E2_SALDO == 0
		nSaldo := 0
	Else
		nSaldo   := (cAliasQry)->E2_SALDO// + (cAliasQry)->E2_JUROS 
	EndIf

	IncProc(STR0027) //"Imprimindo parcelas do contrato de emprstimo"
	oSection2:Cell("PARCELA"):SetValue((cAliasQry)->E2_PARCELA)
	oSection2:Cell("VENC"):SetValue(dDtvenc)	
	oSection2:Cell("DEBITO"):SetValue(nValDeb)
	oSection2:Cell("JUROS"):SetValue((cAliasQry)->E2_JUROS)				
	oSection2:Cell("CORRIG"):SetValue(nValCorr)
	oSection2:Cell("AMORTIZ"):SetValue(nValor)
	oSection2:Cell("PRESTA"):SetValue(nValPres)
	oSection2:Cell("PRESTA"):SetValue(nValPres)
	oSection2:Cell("SALDO"):SetValue(nSaldo)						
	oSection2:Printline()
	
	// atualiza valor do debito	
	//If nValor > 0
		//nValDeb := nValDeb - (nValor - (cAliasQry)->E2_JUROS)
	//Else
		nValDeb := nValDeb - nValor
	//EndIf
	nTotJur  += (cAliasQry)->E2_JUROS
	nTotPres += nValPres
	
	(cAliasQry)->( dbSkip() )
	
EndDo

nSaldo := SEH->EH_SALDO
// Imprime totais do emprestimo
oSection2:Cell("PARCELA"):SetValue("Total")
oSection2:Cell("VENC"):SetValue(dDataIni)	
oSection2:Cell("DEBITO"):SetValue(0)
oSection2:Cell("JUROS"):SetValue(nTotJur)			
oSection2:Cell("CORRIG"):SetValue(0)	
oSection2:Cell("AMORTIZ"):SetValue(SEH->EH_FINANC)
oSection2:Cell("PRESTA"):SetValue(nTotPres)
oSection2:Cell("SALDO"):SetValue(nSaldo)					
oSection2:Printline()

// Finalizo a segunda seo para que seja reiniciada para o proximo registro
oSection2:Finish()
	
// Imprimo uma linha para separar as informaes
oReport:ThinLine()
	
//Finalizo a primeira seo
oSection1:Finish()

Return

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FCExcluiE2
Funo para excluso das parcelas no contas a pagar (SE2)

@author    Ronaldo Tapia
@version   11.80
@since     12/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

Static Function FCExcluiE2(cNumero,nOpc)

Local cParcela	:= ""
Local aArea		:= GetArea()
Local cForPar	:= ""
Local nI		:= 0

Default cNumero := SEH->EH_NUMERO  
Default nOpc    := 5

If SEH->EH_GERPARC == "1" .AND. empty(cForPar) 
	cForPar := Fa171Forn(cNumero)
EndIf

//Carrega as parcelas no arquivo temporario
FC171Par(cNumero,nOpc)

// Posiciona no arquivo correto da SEH
dbSelectArea("SEH")
SEH->(MsSeek(xFilial("SEH")+cNumero))

For nI := 1 To Len(bLoadGrd)

	cParcela := bLoadGrd[nI][2][1]

	dbSelectArea("SE2")
	SE2->(dbSetOrder(1))	//Prefixo+Numero+Parcela
	If !(SE2->(DbSeek(xFilial("SE2")+SEH->EH_TIPO+cNumero))) 
		Exit
	Endif
	
	BEGIN TRANSACTION
		// Deleta registro
		If cParcela <> __nMaxParc .AND. SE2->E2_NATUREZ == SEH->EH_NATUREZ .AND. SE2->E2_FORNECE ==  cForPar .AND. Alltrim(SE2->E2_ORIGEM) $ "FINA171|FINA050"
			// Deleta registro atual
			RecLock("SE2",.F.)
			dbDelete()
			MsUnLock()
		EndIf
	END TRANSACTION	 
	       
Next nI

RestArea(aArea)

Return

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FC171Fornece
Funo para definir o fornecedor para gerao das parcelas provisrias

@author    Ronaldo Tapia
@version   11.80
@since     19/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

Static Function FC171Fornece()

Local aRet		:= {}
Local aParamBox	:= {}
Local nTamFor	:= TamSX3("A2_COD")[1]

SaveInter() // Salva as variaveis publicas

// Define fornecedor para gerao das parcelas
aAdd( aParamBox, { 1, STR0025, Space(nTamFor), "", "ExistCpo('SA2')", "SA2", "", 0, .T. } ) //Fornecedor

If ParamBox( aParamBox, STR0037, @aRet ) //Definir Fornecedor
	cCodFor	:= PadR( mv_par01, nTamFor )
	cForLj	:= SA2->A2_LOJA
EndIf

If !SA2->( DbSeek( xFilial("SA2") + cCodFor + cForLj ) )
	MsgInfo(STR0025+cCodFor+STR0026,STR0017) //"Fornecedor: " //" no encontrado." //"Emprestimo Financeiro"
	cCodFor	:= ""
	cForLj	:= ""
EndIf

RestInter() // Restaura as variavis publicas

Return

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FCl171Emp
Valicacao dos campos pertencentes a aplicacao

@author    Ronaldo Tapia
@version   11.80
@since     19/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

Function FCl171Emp()
Local aArea    := { Alias() , IndexOrd() , Recno() }
Local lRetorna := .F.

If ( INCLUI .And. M->EH_APLEMP=="EMP" .And. M->EH_GERPARC == "1")
	lRetorna := .T.
EndIf

dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])

Return( lRetorna )

//------------------------------------------------------------------------------------------
/* {Protheus.doc} Fa171ETx
Valicacao nos campos EH_NBANCO e EH_TAXA

@author    Ronaldo Tapia
@version   11.80
@since     19/07/2016
@protected
*/
//------------------------------------------------------------------------------------------

Function Fa171ETx()
Local aArea    := { Alias() , IndexOrd() , Recno() }
Local lRetorna := .F.

If ( ALTERA .And. M->EH_APLEMP=="EMP" .And. M->EH_GERPARC == "1")
	lRetorna := .F.
Else
	lRetorna := .T.
EndIf

dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])

Return( lRetorna )

//------------------------------------------------------------------------------------------
/* {Protheus.doc} FCAtuOK
Atualiza a tela para poder realizar a gravao das parcelas do grid

@author    Ronaldo Tapia
@version   11.80
@since     20/07/2016
@protected
@obs       Como  apenas visualizao da VIEW  necessrio forar uma
atualizao na tela para liberar a gravao (Boto Confirmar).
*/
//------------------------------------------------------------------------------------------

Function FCAtuOK()

Local lRet   := .T.
Local oModel := FWModelActive()
Local oGrid  := oModel:GetModel('FLYDETAIL')
Local oView  := FWViewActive()
Local nI     := 1
Local nTamFor	:= TamSX3("E2_FORNECE")[1]
Local cForPar	:= PadR(SuperGetMV("MV_FOREMPR",.F.,"000001"),nTamFor)

If Empty(cCodFor) .AND. Empty(cForLj)
	DbSelectArea("SA2")
	SA2->(DbSetOrder(1))
	
	If SA2->( DbSeek( xFilial("SA2") + cForPar ) )
		cCodFor	:= SA2->A2_COD
		cForLj	:= SA2->A2_LOJA
	Else
		Aviso( STR0049, STR0050 + STR0037 + STR0051/*cMensagem*/, {"Ok"} )// #Ateno! #"No foi definido fornecedor para esta operao. Utilize o Boto '" #"Definir Fornecedor" #"' no menu ou atravs do parmetro MV_FOREMPR."
		lRet	:= .F.
	EndIf
EndIf

For nI := 1 To oGrid:Length()
	oGrid:GoLine( nI )
	If !oGrid:IsDeleted()
		oGrid:DeleteLine()
		oGrid:UnDeleteLine()
		Exit
	EndIf
Next nI

// Atualiza a tela
oView:Refresh()

Return lRet

//--------------------------------------------------------------------------
/*/{Protheus.doc} Fa171Idx()
Funo para cadastro dos ndices que sero considerados para clculo do
rendimento da caderneta de poupana. (futuramente, para outras aplicaes)

@author Pedro Pereira Lima
@since 17/12/2018
@version 12.1.17
/*/
//--------------------------------------------------------------------------
Function Fa171Idx()
	Local oBrowse	As Object
	Local aRotBkp	As Array

	aRotBkp := aClone( aRotina )

	aRotina := {	{ STR0001	,"AxPesqui"	, 0 , 1, 0,.F.},;          
					{ STR0002	,"AxVisual"	, 0 , 2, 0,NIL},;          
					{ STR0003	,"AxInclui"	, 0 , 3, 0,NIL},;        
					{ STR0004	,"AxAltera"	, 0 , 4, 2,NIL},;     
					{ STR0005	,"AxDeleta"	, 0 , 5, 3,NIL}}

	oBrowse := FwMBrowse():New()

	oBrowse:SetAlias( 'FO3' )

	oBrowse:SetDescription( STR0066 )

	oBrowse:Activate()

	aRotina := aClone( aRotBkp )

	aRotBkp := {}

Return

//--------------------------------------------------------------------------
/*/{Protheus.doc} Fa171RetPc()
Funo de inicializao do campo FO3_PERC (Percentual da Meta Selic)

@author Pedro Pereira Lima
@since 21/12/2018
@version 12.1.17
/*/
//--------------------------------------------------------------------------
Function Fa171RetPc() As Numeric
	Local nPerc As Numeric

	nPerc := SuperGetMV( 'MV_PERCSLM', .F., 70 )

Return nPerc


//--------------------------------------------------------------------------
/*/{Protheus.doc} Fa171Forn()
Funo para busca do fornecedor usado para criar parcelas no emprstimo

@author Alberto Teixeira
@since 05/04/2019
@version 12.1.23
/*/
//--------------------------------------------------------------------------
Function Fa171Forn(cNumero)

Local cPrefixo	:= "EMP"
Local cFornece	:= ""
Local aAreaSE2	:= SE2->(GetArea())

	dbSelectArea("SE2")
	SE2->(DBSetOrder(1))
	If SE2->(MsSeek(xFilial("SE2")+cPrefixo+cNumero)) .OR. SE2->(MsSeek(xFilial("SE2")+"TEM"+cNumero))
		cFornece := E2_FORNECE
	Else
		If !lF171Auto
			AVISO(STR0049,STR0067,{"Ok"}) //"Ateno!" //"Fornecedor no encontrado, verifique se o mesmo esta cadastrado na SA2."  
		Else	
			AutoGrLog(STR0067)
		Endif	
	EndIf	

RestArea(aAreaSE2)
Return (cFornece)


//------------------------------------------------------------------------------------------
/* {Protheus.doc} FinIniVar
Inicia as varaveis estticas da rotina FINA171.
@author    Simone Mie Sato Kakinoana
@version   12.1.27
@since     02/09/2020
*/
//-------------------------------------------------------------------------------
Static Function FinIniVar()

If TYPE("lMovEnt05") == 'U' .or. lMovEnt05 == Nil
	lMovEnt05	:= CtbMovSaldo("CT0",,'05')
EndIf

If TYPE("lMovEnt06") == 'U' .or. lMovEnt06 == Nil
	lMovEnt06	:= CtbMovSaldo("CT0",,'06')
EndIf

If TYPE("lMovEnt07") == 'U' .or. lMovEnt07 == Nil
	lMovEnt07	:= CtbMovSaldo("CT0",,'07')
EndIf

If TYPE("lMovEnt08") == 'U' .or. lMovEnt08 == Nil
	lMovEnt08	:= CtbMovSaldo("CT0",,'08')
EndIf

If TYPE("lMovEnt09") == 'U' .or. lMovEnt09 == Nil
	lMovEnt09	:= CtbMovSaldo("CT0",,'09')
EndIf

If __nMaxParc == 0
	__nTamParc := TAMSX3("E2_PARCELA")[1]
	__cMaxParc := PADR("9",__nTamParc,"9")
	__nMaxParc := Val(__cMaxParc)	//Valor mximo de parcelas permitidos pelo tamanho do campo E2_PARCELA
	__nTamPraz := TamSx3("EH_PRAZO")[1]
	__nLastPar := Val(PADR("9",__nTamPraz,"9"))
Endif

Return

//------------------------------------------------------------------------------------------
/* {Protheus.doc} Fa171CpSE5
Atualiza cCamposE5 com os campos especficos da tabela SE5.
@author    Simone Mie Sato Kakinoana
@version   12.1.27
@since     03/09/2020
*/
//-------------------------------------------------------------------------------
Function Fa171CpSE5(lMovEnt05, lMovEnt06, lMovEnt07,lMovEnt08,lMovEnt09)

Local cCamposE5 := ""

DEFAULT lMovent05	:= .F.
DEFAULT lMovent06	:= .F.
DEFAULT lMovent07	:= .F.
DEFAULT lMovent08	:= .F.
DEFAULT lMovent09	:= .F.

cCamposE5 += "{"
cCamposE5 += "{'E5_DTDIGIT', dDataBase}"
cCamposE5 += ",{'E5_DEBITO' , SEH->EH_DEBITO  }"
cCamposE5 += ",{'E5_CREDITO', SEH->EH_CREDIT  }"
cCamposE5 += ",{'E5_CCD'    , SEH->EH_CCD     }"
cCamposE5 += ",{'E5_CCC'    , SEH->EH_CCC     }"
cCamposE5 += ",{'E5_ITEMD'  , SEH->EH_ITEMD   }"
cCamposE5 += ",{'E5_ITEMC'  , SEH->EH_ITEMC   }"
cCamposE5 += ",{'E5_CLVLDB' , SEH->EH_CLVLDB  }"
cCamposE5 += ",{'E5_CLVLCR' , SEH->EH_CLVLCR  }"
cCamposE5 += ",{'E5_CCUSTO' , SEH->EH_CCUSTO  }"

If lMovEnt05
	cCamposE5 += ",{'E5_EC05DB'  	, SEH->EH_EC05DB}"
	cCamposE5 += ",{'E5_EC05CR'  	, SEH->EH_EC05CR}"
EndIf 

If lMovEnt06
	cCamposE5 += ",{'E5_EC06DB'  	, SEH->EH_EC06DB}"
	cCamposE5 += ",{'E5_EC06CR'  	, SEH->EH_EC06CR}"
EndIf 

If lMovEnt07
	cCamposE5 += ",{'E5_EC07DB'  	, SEH->EH_EC07DB}"
	cCamposE5 += ",{'E5_EC07CR'  	, SEH->EH_EC07CR}"
EndIf 

If lMovEnt08
	cCamposE5 += ",{'E5_EC08DB'  	, SEH->EH_EC08DB}"
	cCamposE5 += ",{'E5_EC08CR'  	, SEH->EH_EC08CR}"
EndIf 

If lMovEnt09
	cCamposE5 += ",{'E5_EC09DB'  	, SEH->EH_EC09DB}"
	cCamposE5 += ",{'E5_EC09CR'  	, SEH->EH_EC09CR}"
EndIf 

cCamposE5 += "}"

Return(cCamposE5)

//------------------------------------------------------------------------------------------
/* {Protheus.doc} Fa171GrFK8
Gravar tabela FK8 (Dados Contbeis)
@author    Simone Mie Sato Kakinoana
@version   12.1.27
@since     03/09/2020
*/
//-------------------------------------------------------------------------------
Function Fa171GrFK8(oModelMov,lMovEnt05, lMovEnt06, lMovEnt07,lMovEnt08,lMovEnt09)

Local oSubFK8

DEFAULT lMovent05	:= .F.
DEFAULT lMovent06	:= .F.
DEFAULT lMovent07	:= .F.
DEFAULT lMovent08	:= .F.
DEFAULT lMovent09	:= .F.

oSubFK8 := oModelMov:GetModel("FK8DETAIL")				
oSubFK8:SetValue( "FK8_DEBITO", SEH->EH_DEBITO )
oSubFK8:SetValue( "FK8_CREDIT", SEH->EH_CREDIT )
oSubFK8:SetValue( "FK8_CCD", SEH->EH_CCD )
oSubFK8:SetValue( "FK8_CCC", SEH->EH_CCC )
oSubFK8:SetValue( "FK8_ITEMD", SEH->EH_ITEMD )
oSubFK8:SetValue( "FK8_ITEMC", SEH->EH_ITEMC )
oSubFK8:SetValue( "FK8_CLVLDB", SEH->EH_CLVLDB )
oSubFK8:SetValue( "FK8_CLVLCR", SEH->EH_CLVLCR )							

If lMovEnt05
	oSubFK8:SetValue( "FK8_EC05DB", SEH->EH_EC05DB)		
	oSubFK8:SetValue( "FK8_EC05CR", SEH->EH_EC05CR)	
EndIf 

If lMovEnt06
	oSubFK8:SetValue( "FK8_EC06DB", SEH->EH_EC06DB)		
	oSubFK8:SetValue( "FK8_EC06CR", SEH->EH_EC06CR)	
EndIf 

If lMovEnt07
	oSubFK8:SetValue( "FK8_EC07DB", SEH->EH_EC07DB)		
	oSubFK8:SetValue( "FK8_EC07CR", SEH->EH_EC07CR)	
EndIf 

If lMovEnt08
	oSubFK8:SetValue( "FK8_EC08DB", SEH->EH_EC08DB)		
	oSubFK8:SetValue( "FK8_EC08CR", SEH->EH_EC08CR)	
EndIf 

If lMovEnt09
	oSubFK8:SetValue( "FK8_EC09DB", SEH->EH_EC09DB)		
	oSubFK8:SetValue( "FK8_EC09CR", SEH->EH_EC09CR)	
EndIf 

Return 

//------------------------------------------------------------------------------------------
/* {Protheus.doc} A171Banco
Gatilha dados bancrios
@author    Jose Gavetti
@version   12.1.27
@since     12/05/2021
*/
//-------------------------------------------------------------------------------
Function A171Banco()

If  !FwIsInCallStack("CONPAD1") .And. SA6->((DbSeek(xfilial("SA6")+ M->EH_BANCO)))
	If cBanco <> M->EH_BANCO //Validao do cdigo bancrio.
		If !Empty(M->EH_AGENCIA) .and. !Empty(M->EH_CONTA) .and. SA6->((DbSeek(xfilial("SA6")+ M->EH_BANCO + M->EH_AGENCIA + M->EH_CONTA)))
			M->EH_NBANCO  := SA6->A6_NOME
		ElseiF SA6->((DbSeek(xfilial("SA6")+ M->EH_BANCO)))
			M->EH_AGENCIA := SA6->A6_AGENCIA
			M->EH_CONTA	  := SA6->A6_NUMCON
			M->EH_NBANCO  := SA6->A6_NOME	
		Endif	
	ElseIF cAgencia <> M->EH_AGENCIA .and. SA6->((DbSeek(xfilial("SA6")+ M->EH_BANCO + M->EH_AGENCIA)))//Validao da Agncia bancria.
		M->EH_AGENCIA := SA6->A6_AGENCIA
		M->EH_CONTA	  := SA6->A6_NUMCON
		M->EH_NBANCO  := SA6->A6_NOME
	ElseIF cConta <> M->EH_CONTA .and. SA6->((DbSeek(xfilial("SA6")+ M->EH_BANCO + M->EH_AGENCIA + M->EH_CONTA)))//Validao da Conta bancria.
		M->EH_CONTA	  := SA6->A6_NUMCON
		M->EH_NBANCO  := SA6->A6_NOME
	Endif	
EndIf

cBanco:=  	M->EH_BANCO
cAgencia:=  M->EH_AGENCIA
cConta:=  	M->EH_CONTA

Return .T.

/*/{Protheus.doc} F171PerAut
	Altera os perguntes da rotina, para execues automaticas
	@type  Static Function
	@author Vitor Duca
	@since 16/11/2021
	@version 1.0
	@param aParam, Array, Matriz contendo a ordem do SX1 e seu conteudo
/*/
Static Function F171PerAut(aParam As Array)
	Local nX As Numeric
	Local cVarParam As Character 

	nX := 0 
	cVarParam := ""

	For nX := 1 to Len(aParam)
		cVarParam := Alltrim(Upper(aParam[nX][1]))
		If "MV_PAR" $ cVarParam
			&(cVarParam) := aParam[nX][2]
		EndIf
	Next nX
Return 
