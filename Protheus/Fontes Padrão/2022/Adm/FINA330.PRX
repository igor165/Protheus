#INCLUDE "FINA330.CH"
#INCLUDE "PROTHEUS.CH"
#Include "FWMVCDEF.CH"
#INCLUDE "FWLIBVERSION.CH"

Static __PesqList
Static aRLocks
Static l330Auto  	:= .F.
Static __lDizPer	:= .F.
Static lFWCodFil 	:= .T.
Static __lCredNCC	:= .F.
Static __cRmProd	:= Nil
Static lRatFields
Static dLastPcc  	:= CTOD("22/06/2015")
Static nReg330 		:= 20
Static _oFina3301

Static __nTamPref	:= Nil
Static __nTamNum	:= Nil
Static __nTamParc	:= Nil
Static __nTamTipo	:= Nil
Static __nTamLoja	:= Nil
Static __nTamSeq	:= Nil
Static __nTamFil	:= Nil
Static __nTamPrf	:= Nil
Static __nTamSOri	:= Nil
Static __nTamE2Pr	:= Nil
Static __nTamValM	:= Nil	

Static __nTxMoedP 	:= 0 //Taxa de partida da compensação - Deve conter a taxa do título que partiu a compensação
Static __nTxMoedD	:= 0 //Taxa do título destino
Static __lTxConP	:= .F. // Indica se o título de partida possui taxa contratada
Static __nTxTiBrw 	:= 0
Static __nTxContr 	:= 0
Static __lCmTxCon 	:= .T.
Static __lCalcCM  	:= .T.
Static __nCasDec  	:= 2
Static __nPosTit  	:= 0
Static __lTxMoed  	:= .F.
Static __lNoTxMov 	:= .F.
Static __oMovRA   	:= Nil
Static __oMovCnb  	:= Nil
Static __aTxMoed0 	:= {}
Static __aTitCalc 	:= {}

Static __cFk1IdOri 	:= ""
Static __nProp		:= 0
Static __cPiE1Sld   := ""
Static __cToler		:= ""
//Motor de retenções
//=====================
Static __lMotRet 	:= .F.
Static __lImpMR 	:= .F.
Static __lImpBxMR
Static __lPccMR 	:= .F.
Static __lPccBxMR 	:= .F.
Static __lRaRtPcc 	:= .F.
Static __lIrfMR 	:= .F.
Static __lIrfBxMR 	:= .F.
Static __lRaRtIrf 	:= .F.
Static __lIssMR 	:= .F.
Static __lIssBxMR 	:= .F.
Static __lRaRtIss 	:= .F.
Static __aImpos 	:= {}
Static __aOutImp 	:= {}
Static __nPisCaMR 	:= 0
Static __nCofCaMR 	:= 0
Static __nCslCaMR 	:= 0
Static __nIrfCaMR 	:= 0
Static __nIssCaMR 	:= 0
Static __nImpMR		:= 0
Static __cOldMRCf 	:= ""
Static __cOldMRCl 	:= ""
Static __nBaseMR	:= 0
Static __lImpEmis	:= .F.
Static __nImpEst	:= 0
Static __aImpAnt	:= {}
//=====================	

Static __oHshTMrk
Static __aHshTMrk
Static __oHNatPCC	:= Nil
Static __aNatPCC	:= Nil
Static __lTCnfgMR	:= .F.
Static __l330Va		:= .F.
Static __lRaTxMov	:= .T.
Static __lPIXCanc   := NIL
Static __cIdFk4IR   := ""
Static __lMetric	:= .F.
Static __cFunBkp    := ""
Static __cFunMet	:= ""
Static __lBq10925	:= Nil
Static __nMarcs		:= 0
Static __nSldConv	:= 0
Static __nTotCtb	:= 0
Static __lCmpM460	:= .F.
Static __lGetParA 	:= .F.
Static __lRpoR33	:= NIL
Static __oPccBsRt	:= NIL
Static __lLoaded    := IniStatic()

Static __lExcImpo   := Nil
Static __lCNABImp   := Nil
Static __TpGerPix   := .T.
Static __lNExbMsg	:= .F.
Static __lMaTiPix   := .F.
Static __nValVa		:= 0
//-----------------------------------------------
/*/{Protheus.doc} IniStatic
	Inicialização das variaveis estáticas de dicionário de dados

	@author  Vinicius Nascimento
	@since   15/07/2022
	@version 12.1.33
/*/
//-----------------------------------------------

Static Function IniStatic()
	
	Local lRet as Logical

	lRet := .F.
	Default __lLoaded := .F.

	If Select("SX3") > 0 .and. !__lLoaded

		Default __nTamPref	:= TamSX3("E1_PREFIXO")[1]
		Default __nTamNum	:= TamSX3("E1_NUM")[1]
		Default __nTamParc	:= TamSX3("E1_PARCELA")[1]
		Default __nTamTipo	:= TamSX3("E1_TIPO")[1]
		Default __nTamLoja	:= TamSX3("E1_LOJA")[1]
		Default __nTamSeq	:= TamSX3("E5_SEQ")[1]
		Default __nTamFil	:= TamSX3("E2_FILIAL")[1]
		Default __nTamPrf	:= TamSX3("E5_PREFIXO")[1] //O campo E5_PREFIXO não está no mesmo grupo de campos do campo E1_PREFIXO, por isso mantive esse esse campo no TamSX3
		Default __nTamSOri	:= TamSX3("FQ_SEQORI")[1]
		Default __nTamE2Pr	:= TamSX3("E2_PREFIXO")[1] //O campo E2_PREFIXO não está no mesmo grupo de campos do campo E1_PREFIXO, por isso mantive esse esse campo no TamSX3
		Default __nTamValM	:= TamSX3("FK6_VALMOV")[2]
		
		__lLoaded := .T.
	EndIf 
	lRet := lRet .or. __lLoaded

Return lRet

//------------------------------------
/*/{Protheus.doc}Fina330
Compensação entre títulos e adiantamentos

@author Mauricio Pequim Jr
@since  22/09/97
@version 8
/*/
//------------------------------------
Function Fina330(nPosArotina,lExecAuto, aRetXAPI, lAutMrkPix)
	Local nSavRec	:= Recno()
	Local cBrwExp	:= NIL
	Local cMoedaTx  := ""
	Local nA        := 0
	Local nVlMoeda  := 0
	Local cDescMoed := "" 
	Local cFunName	:= Funname()
	Local aArea740	:= {}
	
	IniStatic()

	Private aRotina 	:= MenuDef()
	Private cCadastro 	:= STR0005  //Compensação de Titulos a Receber
	Private cLote		:= ""		//Utilizado para Contabilizacao
	Private VALOR 		:= 0 		//Utilizada para Contabilizacao - Valor em Real
	Private VALORMF		:= 0	 	//Utilizada para Contabilizacao - Valor na moeda do título
	Private VALOR7 		:= 0 		//Utilizada para Contabilizacao - Decréscimo
	Private VALOR8 		:= 0 		//Utilizada para Contabilizacao - Acréscimo
	Private VALOR9 		:= 0 		//Utilizada para Contabilizacao
	Private REGVALOR	:= 0	    //Utilizada para Contabilizacao
	Private lOracle		:= "ORACLE" $ Upper(TCGetDB())
	Private nTamTit		:= __nTamPref + __nTamNum + __nTamParc
	Private nTamTip		:= __nTamTipo
	Private nTamLoj		:= __nTamLoja
	Private aTxMoedas	:=	{}
	Private cCodDiario	:= ""
	
	Default nPosArotina := 0
	Default lExecAuto	:= .F.
	Default lRatFields 	:= cPaisLoc == "BRA"
	Default aRetXAPI	:= {}
	Default lAutMrkPix	:= .T.
	
	__cPiE1Sld := PesqPict("SE1","E1_SALDO")
	__lMetric  := FwLibVersion() >= "20210517"	
	
	If AllTrim(cFunName) == "FINA460"
		Help(" ",1, "FROTORIG",, STR0118 + ; // "Não foi possível identificar a Função de origem, "
			STR0119 + CRLF + CRLF + ; 		// "o que impossibilitará a Compensação."
			STR0120 + CRLF + ; 				// "Por favor, retorne ao menu principal e acesse"
			STR0121,1,0) 					// "a rotina de Compensação novamente."
			
		Return .F.
	EndIf

	FCadMotBx("CMP", Padr("COMPENSA", 10), "ANSN") //Inclusao motivo de baixa
	
	l330Auto := lExecAuto
	LoteCont( "FIN" )
	SetKey (VK_F12,{|a,b| AcessaPerg("FIN330",.T.)})
	
	If ExistBlock("FA330FLT")
		ExecBlock("FA330FLT",.F.,.F.)
	EndIf
	
	Pergunte("FIN330",.F.)
	
	//MV_PAR01 : Considera Loja  Sim/Nao          	 
	//MV_PAR02 : Considera Cliente     Original/Outros 
	//MV_PAR03 : Do Cliente                            
	//MV_PAR04 : Ate Cliente                           
	//MV_PAR05 : Compensa Titulos Transferidos S/[N]   
	//MV_PAR06 : Calcula Comissao sobre valores de NCC 
	//MV_PAR07 : Mostra Lancto Contabil                
	//MV_PAR08 : Considera abatimentos para compensar  
	//MV_PAR09 : Contabiliza On-Line                   
	//MV_PAR10 : Considera Filiais abaixo              
	//MV_PAR11 : Filial De                             
	//MV_PAR12 : Filial Ate                            
	//MV_PAR13 : Calcula Comissao sobre valores de RA  
	//MV_PAR14 : Reutiliza taxas informadas
	
	__lMotRet	:= ExistFunc("FTemMotor") .And. FTemMotor()
	__l330Va	:= ExistFunc("FA330VACAL") .And. TableInDic("FKD") .And. TableInDic("FKC") .And. cPaisLoc $ "BRA"
	//Estrutura aTxMoedas [1] = Nome Moeda, [2] = Taxa a Ser Utilizada, [3] = Picture, [4] = Taxa do dia atual
	Aadd(aTxMoedas, {"", 1, PesqPict("SM2","M2_MOEDA1"), 1})
	
	For nA := 2	To MoedFin()
		cMoedaTx  :=	Str(nA, IIf(nA <= 9, 1, 2))
		cDescMoed := GetMv("MV_MOEDA" + cMoedaTx) 
		
		If Empty(cDescMoed)
			Exit
		Else
			nVlMoeda := RecMoeda(dDataBase, nA)
			Aadd(aTxMoedas, {cDescMoed, nVlMoeda, PesqPict("SM2","M2_MOEDA" + cMoedaTx), nVlMoeda} )
		Endif
	Next nA
	
	__lTxMoed	:= Len(aTxMoedas) > 0
	__aTxMoed0	:= aClone(aTxMoedas)

	dbSelectArea('SFQ')
	dbSelectArea('SE1')
	
	If cFunName == "FINA740"
		aArea740 := GetArea()
	EndIf
	
	If nPosArotina > 0
		bBlock := &( "{ |a,b,c,d,e,f,g,h,i,j| " + aRotina[ nPosArotina,2 ] + "(a,b,c,d,e,f,g,h,i,j) }" )
		Eval( bBlock, Alias(), (Alias())->(Recno()),nPosArotina,/*oDlgPae*/,/*cLoteFat*/,/*cOrigem*/,/*aNumLay*/,l330Auto,aRetXAPI, lAutMrkPix)
	Else
		dbSetOrder(1)
		dbSeek(xFilial())
		
		//Ponto de entrada para incluir botoes na rotina
		If ExistBlock( "FA330MNU" )
			aRotina := ExecBlock( "FA330MNU", .F., .F., { aRotina } )
		EndIf
		
		//P.E retorna uma expressao SQL para filtro no mBrowse sem que a opcao de filtro do usuario seja desabilitado.
		cBrwExp	:= NIL
		
		If ExistBlock( "FA330FBRW" )
			cBrwExp := ExecBlock( "FA330FBRW", .F., .F. )
		EndIf
		
		mBrowse( 6, 1,22,75,"SE1",,,,,,Fa330Leg(),,,,,,,, cBrwExp)
	EndIf
	
	//Restaura o ambiente
	SetKey (VK_F12)
	dbSelectArea("SE1")
	If cFunName == "FINA740"
		RestArea(aArea740)
	Else
		dbSetOrder(1)
	EndIf
	dbGoTo( nSavRec )
	
	If __oHNatPCC <> Nil
		__oHNatPCC:Clean()
		__oHNatPCC 	:= NIL
	EndIf
	FwFreeArray(__aNatPCC)
	__aNatPCC	:= {}

	//Limpa as variáveis estáticas utilizadas para o motor de retenções
	LimpaVarMR()
Return(.T.)

//------------------------------------
/*/{Protheus.doc}fA330Comp
Marcação dos titulos para compensação

@author Mauricio Pequim Jr
@since  18/04/94
@version 8
/*/
//------------------------------------
Function fA330Comp(cAlias,cCampo,nOpcE,oDlgPae,cLoteFat,cOrigem,aNumLay, lAutomato,aRetXAPI, lAutMrkPix)

Local lPanelFin		:= IsPanelFin()
Local nTotal		:= 0
Local nHdlPrv		:= 0
Local nValorComp	:= 0
Local nVlrCmpAux	:= 0
Local nSeq			:= 0
Local nValBX		:= 0			// Valor da baixa na moeda 1
Local nValBX2		:= 0			// Valor da baixa na moeda do tit principal
Local nX
Local nI
Local cAdiantamento
Local cDadosTitulo
Local cArquivo
Local cPadrao		:= "596"
Local lContabil		:= .F.
Local lPadrao		:= .F.
Local lDigita		:= .F.
Local dEmissao		:= SE1->E1_EMISSAO
Local lMarcado		:= .F.
Local aBaixas		:= {}
Local nTotAbat		:= 0
Local nTotAbtIni	:= 0		//Abatimento do titulo de Partida
Local nTitIni		:= SE1->(Recno())
Local nDecs			:= 2
Local nSalTit		:= 0
Local nDecs1		:= MsDecimais(1)
Local oOk			:= LoadBitmap( GetResources(), "LBOK" )
Local oNo			:= LoadBitmap( GetResources(), "LBNO" )
Local cVarQ			:= "  "
Local oTitulo
Local oDlg
Local lFa330Cmp		:= ExistBlock( "FA330CMP" )
Local nSldReal		:= 0
Local oGet01
Local nLinha		:= 0
Local nTit			:= 0
Local cKeyAbt		:= ""
Local nSe1Rec		:= 0
Local nAcresc		:= 0
Local nDecres		:= 0
Local nAcrescNF		:= 0
Local nDecresNF		:= 0
Local nValVa		:= 0
Local nValVaTitP	:= 0
Local nIndexAtu		:= SE1->(IndexOrd())
Local nVlrCompe 	// Criada para exibir o conteudo do Help correto quando o usuario pressionar F1 sobre o campo
Local aSize			:= {}
Local lDeleted		:= .F.
Local lfa330Bx		:= Existblock("FA330BX")
Local oPanel
Local oChkBox
Local aArea			:= {}
Local lVldDtFin		:= .T.
Local aDiario		:= {}
//Controla o Pis Cofins e Csll na baixa  (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default) )
Local lPccBxCr		:= FPccBxCr()
//Controla IRPJ na baixa
Local lIrPjBxCr		:= FIrPjBxCr()
Local nPropIR		:= 1
Local nVlMinImp 	:= GetNewPar("MV_VL10925",5000)
Local nTotCsAbt		:= 0
Local nTotPisAbt	:= 0
Local nTotCofAbt	:= 0
Local aImpPcc		:= {0,0,0}
//Retencao do ISS pela emissao (1) ou baixa (2)
Local nTotIssAbt	:= 0
Local lCalcIssBx 	:= !Empty( SE5->( FieldPos( "E5_VRETISS" ) ) ) .and. !Empty( SE1->( FieldPos( "E1_SEQBX"   ) ) ) .and. ;
						!Empty( SE1->( FieldPos( "E1_TRETISS" ) ) ) .and. GetNewPar("MV_MRETISS","1") == "2"

Local nTotAdto		:= 0
Local lBaixaAbat	:= .F.
Local nVlrBaixa		:= 0
Local lBxCec		:= .F.
Local lBxLiq		:= .F.
Local nTamSeq		:= __nTamSeq
Local cSequencia	:= Replicate("0",nTamSeq)
Local nRecnoRA		:= 0
Local lF330BOTON 	:= ExistBlock("F330BOTON")
Local lF330ATLIS	:= ExistBlock("F330ATLIS")
Local lCompRa		:= .F.
Local nPropPcc		:= 0
Local nRegRa		:= 0
Local nPos			:= 0
Local lComisCR		:= SuperGetMv("MV_COMISCR",.F.,"S") == "S" // Verifica se permite o cálculo da comissão para vendedor na Compensação CR..
Local lComisOn		:= SuperGetMv("MV_TPCOMIS",.F.,"O") == "O" // Verifica se o cálculo da comissão é On Line ou Batch.
Local lTipBxCP  	:= .F.
Local lSigaLoja 	:= .F.
//Controle de abatimento
Local lTitpaiSE1 	:= .T.
Local nOrdTitPai	:= 0
Local cTipo	 		:= ""
Local bWhile 		:= {|| !EOF() .And. E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA==xFilSE1+cKeyAbt}
//Impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
Local nPisFin061	:= 0
Local nCofFin061	:= 0
Local nCslFin061	:= 0
Local nIrfFin061	:= 0  
Local nOrdSE5		:= 0
Local nRegSE5		:= 0
Local nPropImp		:= 0
Local nProp			:= 0
Local lPropBx  		:= SuperGetMv("MV_PROPBX",.F.,"2") == "1"
Local lSaldoNf		:= .T.
Local nIrrfParc		:= 0
Local nRecTit		:= 0
Local nOldVal		:= 0
Local nPosVa		:= 0
/* GESTAO - inicio */
Local oBtFilial		:= Nil
Local lSE1Comp 		:= If(Empty(FWxFilial("SE1")), .T., .F.)
/* GESTAO - fim */
Local aAlt     		:= {}
Local aPcc			:= Array(4)
Local nValIrf		:= 0
Local lJurMulDes    := SuperGetMv("MV_IMPBAIX", .T., "2") == "1" //Considera juros, multa e desconto 1= Sim/2=Não
Local nTotalTit		:= 0
Local nAltVal		:= 0
Local nVTit			:= 0
Local nBasePcc 		:= 0
Local lMata460		:= .F.
Local nRegFK1		:=	0
Local aBxInteg		:= {}
Local nInt			:= 0
Local lEnvMU070		:= FWHasEAI( "FINA070", .T.,, .T. )
Local lEnvMU330		:= FWHasEAI( "FINA330", .T.,, .T. )
Local aRetInteg		:= {}
Local lRet			:= .T.
Local lOpcAux		:= .F.
Local lJuros		:= .T.
Local lIntPFS       := SuperGetMV("MV_JURXFIN",,.F.) // Habilita a integracao entre os módulos SIGAFIN - Financeiro e SIGAPFS - Juridico
Local lRetImp		:= .T.
Local lRaRtImpMR 	:= .F.
Local nValImpAux 	:= 0
Local nValTitAux 	:= 0
Local nValorAux 	:= 0
Local cSeqAux 		:= ""
Local nIssAux 		:= 0
Local nInssAux 		:= 0
Local lNccAux 		:= .F.
Local lRetMinAux 	:= .F.
Local lIrfBxAux 	:= lIrPjBxCr
Local lPccBxAux 	:= lPccBxCr
Local lIssBxAux	 	:= lCalcIssBx
Local aAuxTitMR 	:= {}
Local dDtEmis		:= CTOD("  /  /  ")
Local lFinTp01		:= FindFunction("FINTP01")
Local lSelAuto		:= .F. 
Local lCheck		:= .T. // Check para pre-seleção dos títulos
Local cPicE5Val   	:= PesqPict("SE5","E5_VALOR")
Local nOdlgLen	 	as Numeric
Local nFrameLen 	as Numeric
Local oNumCont 		as Object
Local oChkFltCnt	as Object
Local nFilialPos 	as Numeric
Local nOkPos	 	as Numeric
Local nCancelPos 	as Numeric
Local nMoedaHght 	as Numeric
Local nN			as Numeric
Local oModelVA		as Object
Local cFilOld		As Character
Local nRegSe5Ori 	:= 0 
Local nInicio		:= 0
Local nFim			:= 0
Local nGravados		:= 0
Local nRegistros	:= 0
Local nTotImp		:= 0 
Local nVlTotConv	:= 0
Local nValImp		:= 0
Local nImpCalc		:= 0
Local nCntCent		:= 0
Local nMVToler		:= SuperGetMv("MV_TOLERPG",,0.01)
Local nToler		:= 0.01 
Local cChaveTit     := ""
Local lRetorno      := .T.

Default cOrigem 	:= ""
DEFAULT aNumLay 	:= {}
Default lAutomato 	:= .F.
Default aRetXAPI	:= {}
Default lAutMrkPix	:= .T.

PRIVATE nPosPis		:= 14		//Posicao Pis na Tela
PRIVATE nPosCof		:= 15		//Posicao Cofins na Tela
PRIVATE nPosCsl		:= 16		//Posicao Csll na Tela
PRIVATE nPosIrf		:= 17		//Posicao IRRF na Tela
PRIVATE cTipoOr		:= SE1->E1_TIPO
PRIVATE nPosBPCC 	:= 24
PRIVATE nPosBPCR 	:= 25
PRIVATE nPosBIRF 	:= 26
PRIVATE aTitulos	:= {}
PRIVATE aRecNo 		:= {}
PRIVATE aRegSE1 	:= {}
PRIVATE aBaixaSE5 	:= {}
PRIVATE	cPrefixo 	:= SE1->E1_PREFIXO
PRIVATE	cNum		:= SE1->E1_NUM
PRIVATE	cTipoTit 	:= SE1->E1_TIPO
PRIVATE	cCliente 	:= SE1->E1_CLIENTE
PRIVATE	cLoja 		:= SE1->E1_LOJA
PRIVATE	cSaldo		:= CriaVar("E1_SALDO")
PRIVATE	nValor		:= CriaVar("E1_SALDO")
PRIVATE	cParcela 	:= SE1->E1_PARCELA
PRIVATE	nMoeda		:= SE1->E1_MOEDA
PRIVATE	dBaixa		:= dDataBase
PRIVATE	nTxMoeda	:= SE1->E1_TXMOEDA
PRIVATE	nValTot		:= 0
PRIVATE	nSeqBx 		:= 0
PRIVATE	nPosSaldo	:= 0
PRIVATE	nPosValor	:= 0
PRIVATE	cBanco		:= Criavar("E1_PORTADO")
Private lCredito 	:= .F.
Private nPosATit 	:= 0
Private aFlagCTB 	:= {}
Private lUsaFlag 	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
Private aImpIR		:= {}     //array que armazena o IR na baixa
//PCC Baixa CR
PRIVATE nPis 		:= 0
PRIVATE nCofins   	:= 0
PRIVATE nCsll		:= 0
PRIVATE nIss		:= 0
PRIVATE nInss		:= 0
PRIVATE aDadosRef 	:= {0,0,0,0,0,0,0} //Array(7)
PRIVATE aDadosRet 	:= {0,0,0,0,0,0,0} //Array(7)
PRIVATE nVlRetPis	:= 0
PRIVATE nVlRetCof	:= 0
PRIVATE nVlRetCsl	:= 0
PRIVATE nDiferImp	:= 0
PRIVATE nValRec		:= 0
PRIVATE nOldValRec	:= 0
PRIVATE lRetParc  	:= .T.
PRIVATE nIrrf 	  	:= 0
PRIVATE ntotIrbx  	:= 0
PRIVATE nIndVld   	:= 0
PRIVATE nRecVld   	:= 0
PRIVATE nValCorCM 	:= 0
PRIVATE nTotImpbx  	:= 0 //Total de impostos calculados na baixa, quando posiciona !lCredito
Private aDadosRA1 	:= {{},{},{},{},{},{},{},{},{},{},{},{}}
Private lRaRtImp  	:= FRaRtImp()       //Define se ha retencao de impostos PCC/IRPJ no R.A
Private nValAbat	:= 0
PRIVATE lNcc		:= SE1->E1_TIPO $ MV_CRNEG
PRIVATE lF330SE5    := Existblock("F330SE5")
PRIVATE aRecSe5     := {}
PRIVATE nValPis		:= 0
PRIVATE nValCofins	:= 0
PRIVATE nValCsll	:= 0
PRIVATE nAbatRa		:= 0
Private nSldNF		:= 0
Private nAbatNf		:= 0
PRIVATE nValorNf	:= 0
PRIVATE lF330DESC	:= ExistBlock("F330DESC")
PRIVATE lDESC		:= .F.
PRIVATE nDesFin 	:= 0
PRIVATE nDescP		:= 0
PRIVATE nDescD		:= 0
Private nValorRa	:= 0
Private nSldRa		:= 0
Private nParciais	:= 0
Private nPisBaseR 	:= 0
Private nCofBaseR	:= 0
Private nCslBaseR 	:= 0
Private nPisBaseC 	:= 0
Private nCofBaseC 	:= 0
Private nCslBaseC 	:= 0
Private nIrfBase	:= 0
Private aSelFil		:= {}
Private lVldSEQ		:= .F.
PRIVATE lFilterMark	:= .F.	//Filter mark for function FINA330Filt
PRIVATE cTitFilt	as Character
PRIVATE cPayType  	as Character
PRIVATE cSortField	as Character
PRIVATE cSortType	as Character
PRIVATE nSel		as Numeric
PRIVATE nRadio		as Numeric
PRIVATE cNumCont	as Character

//***Reestruturacao SE5***
Private nPisCalc	:= 0
Private nCofCalc	:= 0
Private nCslCalc	:= 0
Private nIrfCalc	:= 0
Private nIssCalc	:= 0
Private nIrfBaseR 	:= 0
Private nIssBaseR 	:= 0
Private nIrfBaseC 	:= 0
Private nIssBaseC 	:= 0
//***Reestruturacao SE5***

If __lRpoR33 == NIL
	__lRpoR33 := GetRpoRelease() >= "12.1.033"
EndIF

//Metricas - Acessos a Compensação
__cFunBkp  := FunName()
__cFunMet  := Iif(AllTrim(__cFunBkp)=='RPC',"RPCFINA330",__cFunBkp)
__lCredNCC := lCredito
__lMaTiPix := lAutMrkPix

If __lMetric
	SetFunName(__cFunMet)
	// Metrica de controle de acessos 
	FwCustomMetrics():setSumMetric(Alltrim(ProcName()), "financeiro-protheus_qtd-por-acesso_total", 1)
	SetFunName(__cFunBkp)
EndIf

If __cRmProd == Nil
	__cRmProd		:= SuperGetMv('MV_RMORIG',, "E|U|S")
EndIf

If cPaisLoc == "RUS"
	cTitFilt  := ''
	cPayType  := ''
	cSortField:= ''
	nSel	  := 0
	nRadio 	  := 1	
	cNumCont  := Space(TamSX3("E1_F5QCODE")[1])
	nOdlgLen  :=0
	nFrameLen :=0
	nOkPos	  :=0
	nFilialPos:=0
	nCancelPos:=0
	oNumCont  := Nil
	oChkFltCnt:= Nil
	nMoedaHght:= Nil
EndIf

If __lBq10925 == Nil
	__lBq10925 := SuperGetMV("MV_BQ10925",,"2") == "1"
Endif

cFilOld	:= ""

If Empty(__cPiE1Sld) 
	__cPiE1Sld := PesqPict("SE1","E1_SALDO")
EndIf 

If SE1->E1_MOEDA <> 1 .And. dDataBase < CTOD("29/11/2018")
	Help(" ",1, "FA330MOED",, STR0111 + AllTrim(Str(SE1->E1_MOEDA,2)) +"," + STR0112 +CRLF+CRLF+STR0113 ,1,0)
	Return
EndIf

If cOrigem == "LOJA800"
   nValor   :=  nVlrComp
EndIf

nVlrCompe	:= nValor

If dDataBase > dLastPcc
	nVlMinImp	:= 0
EndIf
aPcc[1]	:= .F.

If SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG .or. cOrigem =="MATA465"
	lCredito 	:= .T.
	__lCredNCC	:= SE1->E1_TIPO $ MV_CRNEG
Endif

If !FA330Lock(,SE1->(Recno()))
	Return
EndIf

aArea := GetArea()

aPcc[1]	:= .F.

//Se vier do mata465 ou da LOCXNF, forca os valores dos parametros
If cOrigem == "MATA465"
	MV_PAR07 := mv_par03		// Mostra Lancto Contabil
	MV_PAR09 := mv_par05		// Contabiliza On-Line
	MV_PAR01 := 1 				// Considera Loja  Sim/Nao
	MV_PAR02 := 1 				// Considera Cliente Original/Outros
	MV_PAR03 :=	SE1->E1_CLIENTE // Do Cliente
	MV_PAR04 :=	SE1->E1_CLIENTE // Ate Cliente
	MV_PAR05 := 2				// Compensa Titulos Transferidos S/[N]
	MV_PAR06 := 2				// Calcula Comissao sobre valores de NCC
	MV_PAR08 := 2				//Considera abatimentos para compensar
	MV_PAR10 := 2				//Considera Filiais abaixo
	MV_PAR11 := Space( __nTamFil )	    //Filial De
	MV_PAR12 := Replicate("Z",__nTamFil)  //Filial Ate
	MV_PAR13 := 1				// Calcula Comissao sobre valores de RA
	MV_PAR14 := 2				// Reutiliza taxas informadas
    // obs.: nao eh necessario voltar aos valores originais no final, pois a
    // propria MATA465 recompoe os valores dos mv_parxx depois da chamada fa330comp()
ElseIf cOrigem == "COMPENSANCC"
	Pergunte("FIN330",.F.)
	MV_PAR03 := SE1->E1_CLIENTE  		// Do Cliente
	MV_PAR04 := SE1->E1_CLIENTE 		// Ate Cliente

	dbSelectArea("SE1")
EndIf

If Type("MV_PAR02")<>'N'
	MV_PAR02 := 1 				// Considera Cliente Original/Outros
EndIf

//Caso considere diferentes clientes
If MV_PAR02 == 2
	nPosPis		:= 17
	nPosCof		:= 18
	nPosCsl		:= 19
	nPosIrf		:= 20
	nPosBPCC	:= 27
	nPosBPCR	:= 28
	nPosBIRF	:= 29
	nPosVa		:= If(__lMotRet,31,30)
Else
	nPosVa		:= If(__lMotRet,28,27)
EndIf

RestArea(aArea)

If ExistBlock("F330DTFIN")
	lVldDtFin := ExecBlock("F330DTFIN",.F.,.F.)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se data do movimento no  menor que data limite de ³
//³ movimentacao no financeiro    										  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lVldDtFin .and. !DtMovFin(,,"2")
	Return
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ No permite que t¡tulos j  baixados possam ser acessados. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SE1->E1_SALDO <= 0
	Help(" ",1,"FA330JABAI")
	Return (.T.)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Caso titulos originados pelo SIGALOJA estejam nas carteiras :  ³
//³I = Carteira Caixa Loja                                        ³
//³J = Carteira Caixa Geral                                       ³
//³Nao permitir esta operacao, pois ele precisa ser transferido   ³
//³antes pelas rotinas do SIGALOJA.                               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Upper(AllTrim(SE1->E1_SITUACA)) $ "I|J" .AND. Upper(AllTrim(SE1->E1_ORIGEM)) $ "LOJA010|LOJA701|FATA701"
	Help(" ",1,"NOUSACLJ")
	Return
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Titulos provisorios nao sao compensaveis como titulo principal.        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cTipoTit $ MVPROVIS
	Help(" ",1,"NOCMPPROV",,STR0042+chr(13)+STR0043,1,0 )   //"Nao é permitida a compensacao a partir de"###"um titulo provisorio"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Recupera a Integridade dos dados     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SE1")
	dbSetOrder(nIndexAtu)
	DeleteObject(oOk)
	DeleteObject(oNo)
	FA330aUnlock()
	Return (.T.)
EndIf

//ANGOLA|BRASIL - Nao permitir compensar titulos de adiantamento relacionados a pedido
If cPaisLoc $ "ANG|BRA" .AND. !__lCmpM460
	If FinAdtSld( "R", SE1->( E1_CLIENTE + E1_LOJA + E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO ) )
		Help(" ",1,"ADTXPED",,STR0062,1,0)		//"Adiantamento relacionado a um pedido somente poderá ser utilizado no relacionamento com pedidos"
		Return (.T.)
	EndIf
EndIf

//-----------------------------------------------------------
// Nao permite compensar recebimentos antecipados originados
// de faturas de adiantamentos. Req. Manejo de Anticipo
//-----------------------------------------------------------
If cPaisLoc == "MEX" .And. X3Usado("ED_OPERADT")
	If SE1->E1_TIPO == Substr(MVRECANT,1,3) .And.;
		Upper(Alltrim(SE1->E1_ORIGEM)) == "FINA087A" .And.;
		GetAdvFVal("SED","ED_OPERADT",xFilial("SED")+SE1->E1_NATUREZ,1,"") == "1"

		Help(" ",1,"VLDTITRA",,STR0065,1,0) //"Processo não permitido para recebimento antecipado gerado de fatura de adiantamento."
		Return (.T.)

	EndIf
EndIf

//PCREQ-3782 - Bloqueio por situação de cobrança
If !(F023VerBlq("1","0007",SE1->E1_SITUACA,.T.))
	Return (.T.)
EndIf

// SIGAPFS - Valida se o RA que foi gerado a partir de um adiantamento do SIGAPFS pode ser compensado.
// Caso tenha sido gerado a partir de um adiantamento exclusivo não poderá ser compensado.
If lIntPFS .And. AllTrim(SE1->E1_ORIGEM) == 'JURA069'
	If FindFunction("JVldCompAd") .And. !JVldCompAd()
		Return (.T.)
	EndIf
EndIf

//Validação quando utiliza módulo do agro
If !l330Auto .And. SuperGetMv("MV_SIGAAGR",,.F.)
	If FindFunction("AGRTITFIN")
		If !AGRTITFIN()
			return .F.
		EndIf
	EndIf  
EndIf

//Validação de mensagem de titulo RM Classis
If(AllTrim(SE1->E1_ORIGEM) $ __cRMProd .And. !l330Auto)
	HELP(" ",1,STR0132 ,, STR0133,2,0,,,,,, {STR0134})//"Título gerado pela Integração Protheus X Classis não Pode ser compensado pelo Protheus" ## "Efetue o processo através do sistema RM Classis"
	Return .F.
EndIf

If Type("mv_par15") == 'N' .And. mv_par15 == 2
	lJuros := .F.
EndIf

//Motor de retenções
If __lMotRet
	//Verifica as configurações de impostos pelo motor de retenção
	__lTCnfgMR	:= F330VldImp()		
	
	lRaRtImpMR 	:= ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
	lPccBxCr 	:= ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
	lIrPjBxCr 	:= ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
	lCalcIssBx 	:= ( __lIssMR .And. __lIssBxMR ) .Or. ( !__lIssMR .And. lIssBxAux )
	
	//Calcula os impostos pelo motor de retenções
	If __lTCnfgMR
		F330CalImp( SE1->E1_NATUREZ, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG, SE1->E1_SALDO, dDataBase, SE1->E1_TIPO )
		__lTCnfgMR	:= .F.
	EndIf
EndIf

//Inicializa a gravacao dos lancamentos do SIGAPCO
PcoIniLan("000016")

//Inicializa as variáveis estáticas
F330Static()

If cPaisLoc == "BRA" .And. TipoGerPix(SE1->E1_TIPO)
	If __lExcImpo .And. !__lCNABImp
		lRetorno := ExcImpoPix(nTitIni)
		__TpGerPix	:= .F.
	EndIf
EndIf

While lRetorno

	If lFinTp01 .And. FINTP01(.T.)	// Restringe o uso do programa Financeiro Quando a origem do titulo for de origem Totvs Incorporação RM
		Exit
	EndIf

	//Metricas
	nInicio		:= 0
	nFim		:= 0
	nGravados	:= 0
	nRegistros	:= 0

	nOpca  :=0

	nSldTitIni := 0
	If !lCredito	
		nSldTitIni:= SE1->E1_SALDO
	Endif

	If cPaisLoc =="ARG"		
		__nTxMoedP := RecMoeda(dDatabase,SE1->E1_MOEDA)
	ElseIf SE1->E1_MOEDA != 1 .And. __nTxMoedP == 0
		__nTxMoedP := RecMoeda(If(SE1->E1_TIPO $ MVRECANT .And. __lRaTxMov, F330MovRA(Nil, "SE1", .T.)[2], dDatabase), SE1->E1_MOEDA)
	EndIf
	//a taxa não pode atualizar o array aTxMoedas senão perdemos a referencia de alteração pelo usuário
	__lNoTxMov := Empty(__nTxMoedP)

	If SE1->E1_MOEDA > 1 .And. lCredito .And. __lRaTxMov
		aTxMoedas[SE1->E1_MOEDA,2] := __nTxMoedP
	EndIf

	if !lCredito 
		nDescP := nDesFin := getDesc(nSldTitIni)
	endIf

	//VA: Calcula o valor acessório
	If __l330Va .And. !lCredito
		oModelVA	:= FWLoadModel("FINA070VA")
		nValVa		:= FA330VACAL(oModelVA)
		nValVaTitP	:= nValVa
		oModelVa:Destroy()
		oModelVa 	:= NIL
	EndIf
	__nValVa := nValVa

	If mv_par08 == 1 .Or. lRaRtImp .Or. lRaRtImpMR

		If !lCredito
			nTotAbtIni 	:= SumAbatRec( cPrefixo, cNum, cParcela, SE1->E1_MOEDA, "S", dBaixa,,, @nTotCsAbt, @nTotPisAbt, @nTotCofAbt,,,, @nTotIssAbt )
			If __lIrfMR
				If __lIrfBxMR .And. !__lRaRtIrf 
					nIrrf := __nIrfCaMR
				EndIF
			Else
				If lIrPjBxCr .And. !lRaRtImp
					nIrrf := FCaIrBxCR( nValRec )
				EndIf
			EndIf
	
			If !lCalcIssBx
				If lPropBx
					If SE1->(E1_SALDO != E1_VALOR)  // Sofreu baixa parcial 
						nTotIssAbt := (SE1->E1_SALDO/SE1->E1_VALOR) * nTotIssAbt
					Else
						nTotIssAbt := 0
					EndIf
				EndIf
			EndIf
		EndIf
				
		nSaldo := SE1->E1_SALDO + SE1->E1_SDACRES - SE1->E1_SDDECRE - nDesFin + nValVa - __nImpMR
		If ( !lRaRtImp .And. !lRaRtImpMR ) .Or. ( !lNcc .And. mv_par08 == 1 )
			nSaldo := nSaldo - nTotAbtIni
		EndIf
		If lPropBx
			nSaldo := nSaldo + nTotIssAbt
		EndIf
		
	Else
		nSaldo := SE1->E1_SALDO + SE1->E1_SDACRES - SE1->E1_SDDECRE - nDesFin + nValVa - __nImpMR
	EndIf

	If SE1->E1_MOEDA > 1
		__nSldConv := SE1->E1_VLCRUZ
	EndIf
	//Verifica se o titulo já possui impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
	nPisFin061	:= 0
	nCofFin061	:= 0
	nCslFin061	:= 0
	nIrfFin061	:= 0
	VALOR7 		:= 0
	VALOR8 		:= 0
	nRegSE5	:=	SE5->(Recno())
		
	If lPccBxCr .And. lIrPjBxCr
		dbSelectArea("SE5")
		SE5->( dbSetOrder( 2 ) ) //FILIAL + TIPODOC + PREFIXO + NUMERO + PARCELA + TIPO
		If SE5->( dbSeek( xFilial("SE5") + "BA" + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO ) )
			While !SE5->( Eof() ) .And. SE5->E5_FILIAL == xFilial("SE5") ;
			.And. SE5->E5_TIPODOC + SE5->E5_PREFIXO + SE5->E5_NUMERO + SE5->E5_PARCELA + SE5->E5_TIPO == "BA" + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO
			
				If  ("FINA061" $ Subst(SE5->E5_HISTOR,1,7) .Or. "FINA891" $ Subst(SE5->E5_HISTOR,1,7)) .And. SE5->E5_MOTBX $ "PCC_IRF"						
					If Alltrim(SE5->E5_MOTBX) == "PCC"
					   nPisFin061	+= SE5->E5_VRETPIS
					   nCofFin061	+= SE5->E5_VRETCOF
					   nCslFin061	+= SE5->E5_VRETCSL
					ElseIf Alltrim(SE5->E5_MOTBX) == "IRF"
					   nIrfFin061	+= SE5->E5_VRETIRF
					EndIf
				EndIf					
				SE5->( DbSkip() )
		   EndDo
		EndIf
	EndIf
	SE5->( dbGoTo( nRegSE5 ) )

	If ( nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061 ) > 0 .And. mv_par08 == 2
   		nSaldo	+= nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061
	EndIf
	
	If !lCredito
		nAcrescNF := SE1->E1_SDACRES
		nDecresNF := SE1->E1_SDDECRE
	EndIf

	nRecno := SE1->(Recno())

	cDadostitulo := SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO
	
	If (lPccBxCR .Or. lIRPJBxCr) .And. ( lRaRtImp .Or. lRaRtImpMR ) .And. !lNcc
   		If lCredito
   			aAdd(aDadosRA1[1],SE1->(recno()))
   		Else
   			aAdd(aDadosRA1[2],SE1->(recno()))
   		EndIf
   	EndIf
   	
   	If __lMotRet
		aAdd(aDadosRA1, {__nImpMR})
	EndIf
	//PCC Baixa CR
	//Se PCC Baixa CR e nao houver abatimento de impostos
	If cPaisLoc == "BRA" .And. (lPccBxCr .Or. lIrPjBxCr) .And. ( nTotCsAbt + nTotPisAbt + nTotCofAbt == 0 )
		If (SE1->E1_VALOR > SE1->E1_SALDO) .And. Empty(SE1->E1_TIPOLIQ)
			//Procura pelas baixas deste titulo
			lTipBxCP := lRaRtImp .Or. lRaRtImpMR
			aBaixa := Sel070Baixa( "VL /V2 /BA /RA /CP /LJ /" + MV_CRNEG, SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, ;
				                   @nTotAdto, @lBaixaAbat, SE1->E1_CLIENTE, SE1->E1_LOJA, @nVlrBaixa,, @lBxCec, @lBxLiq, @lSigaLoja, @lTipBxCP )

			For nX := 1 To Len(aBaixaSE5)
				nParciais += aBaixaSE5[nX][8]				
				If lPccBxCR .And. ( lRaRtImp .Or. lRaRtImpMR ) //somar impostos PCC
					nParciais += aBaixaSE5[nX][18] + aBaixaSE5[nX][19] + aBaixaSE5[nX][20] + aBaixaSE5[nX][30] + aBaixaSE5[nX][32] + aBaixaSE5[nX][33]
				Endif
				nIss += aBaixaSE5[nX][32]
				nInss += aBaixaSE5[nX][33]
			Next
			nParciais += nTotAdto
		Else
			nParciais := SE1->E1_VALOR - SE1->E1_SALDO
		EndIf

		If MVRECANT $ SE1->E1_TIPO
			nParciais := SE1->E1_VALOR - SE1->E1_SALDO
		EndIf
		
		If ( !lRartImp .And. !lRaRtImpMR .And. mv_par08 == 1 .And. SE1->E1_TIPO == MVNOTAFIS .And. !__lBq10925 ) .Or. ( lPropBx .And. ( ( ( !lRartImp .And. !lRaRtImpMR ) .And. mv_par08 == 2) .Or. ( lRartImp .Or. lRaRtImpMR ) ) .And. !lCredito)
			nParciais := SE1->E1_VALOR - SE1->E1_SALDO
		EndIf
		
		If SE1->E1_SDDECRE <> SE1->E1_DECRESC
			nParciais += ( SE1->E1_DECRESC - SE1->E1_SDDECRE )
		EndIf
		
		nValRec := SE1->E1_VALOR - nParciais
		nOldVal	:= nValrec
		
		If __lPccMR
			nPis 	:= __nPisCaMR
			nCofins := __nCofCaMR
			nCsll	:= __nCslCaMR
		Else
			If dDataBase <= dLastPcc				
				//chama a f070TotMes para preencher o array aDadosRet
				f070TotMes(dBaixa,.T.)
			Else
				If SE1->E1_TIPO <> MVRECANT 
					If ("MATA" $ SE1->E1_ORIGEM) .Or. (SE1->E1_VLCRUZ <> SE1->E1_BASEIRF)
				 		nBasePcc 	:= FBaseRPCC(nValRec)
				 		nBasePcc 	:= Iif(ValType(nBasePcc) != "N", nValRec, nBasePcc)
				 		lMata460	:= .T.
				 	EndIf

					If !Empty(SE1->E1_NUMBOR)
						lRetImp:= VLDBOR(SE1->E1_NUMBOR,"R")
					EndIf

					If lRetImp .And. FNatPCC(SE1->E1_FILORIG, SE1->E1_NATUREZ)
						aPcc		:= newMinPcc(dBaixa,Iif(lMata460, nBasePcc, nValRec),SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
						nPis		:= aPcc[2]
						nCofins		:= aPcc[3]
						nCsll		:= aPcc[4]
						If Len(aPcc) > 4 
							__aTitCalc := aPcc[5]
						EndIf
					EndIf			
				EndIf
				aPcc[1]		:= .T.
			EndIf			
		EndIf
		
		If lRartImp .Or. lRaRtImpMR
			//Se lRartImp, retoma o valor de nValRec, alterado pela TotMes
			nValRec := SE1->E1_VALOR - nParciais
		ElseIf !__lPccMR .And. aDadosRet[1] < nVlMinImp .And. ( aDadosRet[1] + nSaldo > nVlMinImp ) .And. lPccBxCr
			nValRec := nSaldo
		EndIf
		
		If !__lPccMR			
			If lRartImp .And. lPccBxCr .and. SE1->E1_TIPO <> MVRECANT
				nPropPCC	:= SE1->E1_SALDO/SE1->E1_BASEPIS
				If dDataBase <= dLastPcc
					nPis		:= SE1->E1_PIS * nPropPCC
					nCofins		:= SE1->E1_COFINS * nPropPCC
					nCsll		:= SE1->E1_CSLL * nPropPCC
				EndIf
				If MV_PAR08==1
		 			nIss		:= SE1->E1_ISS - nIss
					nInss		:= SE1->E1_INSS - nInss
				Else
					nIss		:= SE1->E1_ISS * nPropPCC
					nInss		:= SE1->E1_INSS * nPropPCC
				Endif
			EndIf
		Endif
		
		If !lCredito
			If __lIrfMR
				nIrrf := __nIrfCaMR
			Else
				If !Empty(SE1->E1_NUMBOR)
					lRetImp:= VLDBOR(SE1->E1_NUMBOR,"R")
				EndIf

				If lRetImp
					nIrrf := FCaIrBxCR( nValRec + Iif( lRaRtImp .And. SE1->E1_TIPO $ MVRECANT, nPis + nCofins + nCsll + nIrrf, 0 ),, lRaRtImp )
				EndIf
			EndIf
		EndIf
				
		If ( nPosIr := aScan( aImpIR, {|x| x[2] = SE1->(REcno())} ) ) = 0
			aAdd(aImpIR,{nIrrf,SE1->(Recno())})
			nPosIr := Len( aImpIR )
		Else
			aImpIR[nPosIr][1] := nIrrf
		EndIf
		
		If !__lIrfMR .And. ( lIrPjBxCr .And. lCredito )
			nIrrf := nIrrf * (nValRec / SE1->E1_BASEIRF)
		EndIf
		
		If !__lPccMR .And. !aPcc[1]
			If aDadosRet[1] <= nVlMinImp .and. ( aDadosRet[1] + nSaldo > nVlMinImp ) .and. !lRaRtImp .and. lPccBxCr .and. SE1->E1_TIPO <> MVRECANT
				nValPis		:= SE1->E1_PIS
				nValCofins 	:= SE1->E1_COFINS
				nValCsll	:= SE1->E1_CSLL
				nValorNf	:= SE1->E1_VALOR
			Elseif aDadosRet[1] <= nVlMinImp .and. ( aDadosRet[1] + nSaldo <= nVlMinImp ) .and. !lRaRtImp .and. lPccBxCr .and. SE1->E1_TIPO <> MVRECANT
				nProp	:= (aDadosRet[1] + SE1->E1_SALDO) / SE1->E1_VALOR
				nValPis	:= SE1->E1_PIS * nProp
				nValCofins := SE1->E1_COFINS * nProp
				nValCsll	:= SE1->E1_CSLL * nProp
				nValorNf	:= SE1->E1_VALOR
			ElseIf aDadosRet[1] > nVlMinImp .and. ( aDadosRet[1] + nSaldo > nVlMinImp ) .and. !lRaRtImp .and. lPccBxCr .and. SE1->E1_TIPO <> MVRECANT
				nValPis	:= SE1->E1_PIS
				nValCofins := SE1->E1_COFINS
				nValCsll	:= SE1->E1_CSLL
				nValorNf	:= SE1->E1_VALOR
				nSldNF		:= SE1->E1_SALDO
			EndIf
		EndIf
		
		If SE1->E1_TIPO == MVRECANT
			nValorRa	:= SE1->E1_VALOR
			nSldRa		:= SE1->E1_SALDO
		EndIf
				
		//Caso o titulo de partida possua PCC, diminuo do saldo a compensar
		If nPis + nCofins + nCsll + nIrrf > 0  .And. SE1->E1_TIPO <> MV_CRNEG .And. SE1->E1_TIPO <> MVRECANT
			aImpPcc [1] := nPis
			aImpPcc [2] := nCofins
			aImpPcc [3] := nCsll
						
			//Somente abate o imposto se teve retenção minima
			lRetMinAux := ( ( __nPisCaMR + __nCofCaMR + __nCslCaMR + __nIrfCaMR > 0 ) .Or. ( aDadosRet[1] + nSaldo > nVlMinImp ) )
			If MV_PAR08 == 1 .And. lRetMinAux
				If lRaRtImp .Or. lRaRtImpMR
					nSaldo -= ( nPis + nCofins + nCsll + nIrrf )
				Else
					If lPccBxCr
						nSaldo -= nPis + nCofins + nCsll
					EndIf
					If lIrPjBxCr
						nSaldo -= nIrrf
					EndIf
				EndIf
			ElseIf MV_PAR08 == 2 .And. ( ( lRaRtImp .And. ( !__lPccMR .And. aPcc[1] ) ) .Or. ( lRaRtImpMR .And. __lPccMR ) )
				nSaldo -= ( nPis + nCofins + nCsll + nIrrf )
			EndIf
						
			If !__lIrfMR .And. nIrrf > 0
			 	If ( nPosIr := aScan( aImpIR, {|x| x[2] = SE1->(Recno())} ) ) = 0
					aAdd( aImpIR, {nIrrf,SE1->(Recno())} )
					nPosIr := Len( aImpIR )
				Else
					aImpIR[nPosIr][1] := nIrrf
				EndIf
			EndIf
			
		EndIf	
	ElseIf lIrPjBxCr .And. ( !lRaRtImp .And. !lRaRtImpMR )
		nSaldo -= nIrrf
	EndIf

	If nPis + nCofins + nCsll + nIrrf > 0 .And. SE1->E1_TIPO <> MV_CRNEG .And. SE1->E1_TIPO <> MVRECANT
		lRetMinAux := ( ( lRaRtImpMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR + __nIrfCaMR > 0 ) .Or. ( lRaRtImp .And. aDadosRet[1] > nVlMinImp ) )
		If ( !lRartImp .And. !lRaRtImpMR ) .Or. lRetMinAux .AND. MV_PAR08 == 2
			nValRec -= ( nPis + nCofins + nCsll + nIrrf + nIss + nInss )  
		    nTotImpbx += ( nPis + nCofins + nCsll + nIrrf + nIss + nInss )
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se for chamada da mata465 , nao mostrar a janela de parametros   ³
	//³ e forçar o valor de nOpca con valor 1. (Loc. Arg.).              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cOrigem != "MATA465"
		If !lAutomato
			If lPanelFin  //Chamado pelo Painel Financeiro
				oPanelDados := FinWindow:GetVisPanel()
				oPanelDados:FreeChildren()
				aDim := DLGinPANEL(oPanelDados)
				DEFINE MSDIALOG oDlg OF oPanelDados:oWnd FROM 0,0 To 0,0 PIXEL STYLE nOR( WS_VISIBLE, WS_POPUP )
				oDlg:Move(aDim[1],aDim[2],aDim[4]-aDim[2], aDim[3]-aDim[1])
				nEspLarg := ((DlgWidthPanel(oPanelDados)/2) - 225) /2
				nEspLin  := 0
			Else
				nEspLarg := 0
				nEspLin  := 0
				If cPaisLoc == "RUS"
					nOdlgLen	:= 534
					nFrameLen 	:= 249
					nVlrCompe 	:= nSaldo
				Else
					nOdlgLen	:= 525
					nFrameLen 	:= 245
				EndIf

				DEFINE MSDIALOG oDlg FROM	88,	31 TO 275,nOdlgLen TITLE STR0036 PIXEL //"Compensação de Adiantamentos"
			EndIf
	   
			oDlg:lMaximized := .F.
			oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20)
			oPanel:Align := CONTROL_ALIGN_ALLCLIENT

			@ 000+nEspLin, 002+nEspLarg TO 030+nEspLin, 245+nEspLarg OF oPanel	PIXEL
			@ 031+nEspLin, 002+nEspLarg TO 062+nEspLin, 245+nEspLarg OF oPanel	PIXEL

			@ 015+nEspLin, 006+nEspLarg MSGET cPrefixo                SIZE 19, 10 OF oPanel PIXEL
			@ 015+nEspLin, 032+nEspLarg MSGET cNum VALID !EMPTY(cNum) SIZE 70, 10 OF oPanel PIXEL
			@ 015+nEspLin, 105+nEspLarg MSGET cParcela                SIZE 20, 10 OF oPanel PIXEL

			If !lCredito
				@ 015+nEspLin, 129+nEspLarg MSGET cTipoTit PICTURE "@!" VALID !Empty(cTipoTit) .AND.;
					!cTipoTit $ MVABATIM .AND. ;
					!(cTipoTit $ MVRECANT+"/"+MV_CRNEG) SIZE 12, 10 OF oPanel PIXEL
			Else
				@ 015+nEspLin, 129+nEspLarg MSGET cTipoTit PICTURE "@!" VALID !Empty(cTipoTit) .AND.;
					!cTipoTit $ MVABATIM .AND. ;
					(cTipoTit $ MVRECANT+"/"+MV_CRNEG) SIZE 12, 10 OF oPanel PIXEL
			EndIf
			
		   	@ 015+nEspLin, 155+nEspLarg MSGET cCliente F3 "SA1" Valid fa330Cli()	SIZE 70, 10 OF oPanel PIXEL HASBUTTON
		   	@ 015+nEspLin, 226+nEspLarg MSGET cLoja	 Valid Fa330Loja() SIZE 16, 10 OF oPanel PIXEL
	
		   	@ 047+nEspLin, 006+nEspLarg MSGET nSaldo When .F. 	Picture "@E 9999,999,999.99" SIZE 60, 10 OF oPanel PIXEL HASBUTTON
		   	@ 047+nEspLin, 070+nEspLarg MSGET nMoeda when .F.	SIZE 18, 10 OF oPanel PIXEL
		   	@ 047+nEspLin, 095+nEspLarg MSGET nVlrCompe			Picture "@E 9999,999,999.99";
				Valid nVlrCompe >= 0 .AND. STR(nVlrCompe,17,2) <= STR(nSaldo,17,2) ;
				SIZE 52, 10 OF oPanel PIXEL HASBUTTON
			@ 047+nEspLin, 152+nEspLarg MSGET dBaixa Valid dBaixa >= SE1->E1_EMISSAO  .And. (If( lVldDtFin, DtMovFin(dBaixa,,"2"), .T.)) ;
				SIZE 48, 10 OF oPanel PIXEL HASBUTTON
			@ 037+nEspLin, 194+nEspLarg CHECKBOX oChkBox VAR lCheck PROMPT STR0117 ; // "Tit. Marcados"
				SIZE 60,15 OF oPanel PIXEL
			If cPaisLoc == "RUS"
				@ 47+nEspLin, 190+nEspLarg MSGET oNumCont VAR cNumCont SIZE 50, 10 Picture "@!" OF oPanel PIXEL
				oNumCont:lVisible := .T.
				oNumCont:lActive  := .F. 
			EndIf
			@ 007+nEspLin, 006+nEspLarg SAY STR0006  SIZE 21, 7 OF oPanel PIXEL  //"Prefixo"
		   	@ 007+nEspLin, 032+nEspLarg SAY STR0007  SIZE 22, 7 OF oPanel PIXEL  //"N£mero"
		   	@ 006+nEspLin, 105+nEspLarg SAY STR0008  SIZE 23, 7 OF oPanel PIXEL  //"Parcela"
		   	@ 006+nEspLin, 129+nEspLarg SAY STR0009  SIZE 14, 7 OF oPanel PIXEL  //"Tipo"
		   	@ 006+nEspLin, 155+nEspLarg SAY STR0010  SIZE 34, 7 OF oPanel PIXEL  //"Cliente   "
		   	@ 006+nEspLin, 226+nEspLarg SAY STR0011  SIZE 14, 7 OF oPanel PIXEL  //"Loja"
		   	@ 038+nEspLin, 006+nEspLarg SAY STR0012  SIZE 34, 7 OF oPanel PIXEL  //"Saldo"
		   	@ 038+nEspLin, 070+nEspLarg SAY STR0013  SIZE 21, 7 OF oPanel PIXEL  //"Moeda"
		   	@ 038+nEspLin, 095+nEspLarg SAY STR0014  SIZE 55, 7 OF oPanel PIXEL  //"Valor a compensar"
		   	@ 038+nEspLin, 152+nEspLarg SAY STR0015  SIZE 45, 7 OF oPanel PIXEL  //"Data da Baixa"
			If cPaisLoc == "RUS"
			   @ 38+nEspLin, 190+nEspLarg CHECKBOX oChkFltCnt VAR lCheck PROMPT OemToAnsi(STR0102) SIZE 80,7 PIXEL OF oPanel ON CLICK(oNumCont:lActive := lCheck, IIf(!lCheck, cNumCont := Space(TamSX3("E1_F5QCODE")[1]), cNumCont := SE1->E1_F5QCODE) ,oNumCont:Refresh()) //Filter for Contracts
			EndIf			   
			If UsaSeqCor()
		   		SX3->(DbSetorder(2))
				SX3->(DbSeek("E5_DIACTB"))
				cCodDiario  := Criavar("E5_DIACTB",.T.)
				cTitDiar :=  AllTrim(X3TITULO())
				@ 038+nEspLin, 195+nEspLarg SAY cTitDiar SIZE 45, 7 OF oPanel PIXEL
				@ 047+nEspLin, 195+nEspLarg MSGET cCodDiario F3 "CVL" SIZE 20, 10 OF oPanel Valid VldCodSeq( cCodDiario ) When CtbWdia() PIXEL HASBUTTON
				SX3->(DbSetorder(1))
			EndIf
		
			If lPanelFin  //Chamado pelo Painel Financeiro
				aButtonTxt := {}
				AADD(aButtonTxt,{STR0037,STR0037, {||Fa330SetMo()}})

				ACTIVATE MSDIALOG oDlg ON INIT FaMyBar(oDlg,;
				{|| If(Fa330TudOk(nVlrCompe),(nOpca:=1,oDLg:End()),)},;
				{|| oDlg:End()},,aButtonTxt)

			Else
				If cPaisLoc == "RUS"
					nFilialPos		:= 158
					nOkPos			:= 186
					nCancelPos		:= 214
					nMoedaHght		:= 11
				Else
					nFilialPos		:= 162
					nOkPos			:= 190
					nCancelPos		:= 218
					nMoedaHght		:= 18
				EndIf
				@ 068+nEspLin, 005+nEspLarg BUTTON STR0037 SIZE 50,nMoedaHght ACTION (Fa330SetMo()) OF oPanel PIXEL //Taxas Moedas

				/* GESTAO - inicio */
				//Se o SE1 for Compartilhado entre todas as Empresas não exibe o Botao para Selecao das Filiais
				If !lSE1Comp
					DEFINE SBUTTON Var oBtFilial FROM 68,162 TYPE 05 ACTION { || aSelFil := Fa330Fil() } ENABLE OF oPanel
					oBtFilial:cCaption := STR0070		//"Filiais"
					oBtFilial:cToolTip := STR0071		//"Seleciona filiais"
				EndIf
				/* GESTAO - fim */
			
				DEFINE SBUTTON FROM 68, 190 TYPE 1 ENABLE ACTION (If(Fa330TudOk(nVlrCompe),(nOpca:=1,oDLg:End()),)) OF oPanel
				DEFINE SBUTTON FROM 68, 218 TYPE 2 ENABLE ACTION oDlg:End() OF oPanel
			
				ACTIVATE MSDIALOG oDlg CENTERED
			Endif 	
		Else

			If __lGetParA .or. __lCmpM460
				nLenAuto := Len(aRetXAPI)

				If __lCmpM460 .and. nLenAuto > 0
					aRetAuto := aClone(aRetXAPI)
				Else
					If __lGetParA .and. nLenAuto == 0
						aRetAuto := GetParAuto("FINA330TestCase")
						If ValType(aRetAuto) == "A"
							nLenAuto := Len(aRetAuto)
						EndIf
					EndIf

					If (ValType(aRetAuto) != "A" .Or. nLenAuto == 0) .and. !__lCmpM460
						aRetAuto := GetParAuto("JURBXRTestCase") // Casos de testes - Módulo SIGAPFS
					EndIf
				EndIf
				
				If aRetAuto[1,1,2]
					cPrefixo   := aRetAuto[1,1,1]
				EndIf
				
				If aRetAuto[1,2,2]
					cNum       := aRetAuto[1,2,1]
				EndIf
				
				If aRetAuto[1,3,2]
					cParcela   := aRetAuto[1,3,1]
				EndIf
				
				If aRetAuto[1,4,2]
					cTipoTit   := aRetAuto[1,4,1]
				EndIf
				
				If aRetAuto[1,5,2]
					cCliente   := aRetAuto[1,5,1]
				EndIf
				
				If aRetAuto[1,6,2]
					cLoja      := aRetAuto[1,6,1]
				EndIf
				
				If aRetAuto[1,7,2]
					nVlrCompe  := aRetAuto[1,7,1]
				EndIf
				
				If aRetAuto[1,8,2]
					dBaixa     := aRetAuto[1,8,1] 
				EndIf
				If Len(aRetAuto[1]) > 8 //array com as taxas das moedas {nMoeda, nTaxa} (Simulando a alteração pelo botão de taxas)
					For nN := 1 to Len(aRetAuto[1,9])
						aTxMoedas[aRetAuto[1,9,1,nN][1], 2] := aRetAuto[1,9,1,nN][2]
					Next
					Fa330SetMo(lAutomato)
				EndIf
				If Fa330TudOk(nVlrCompe)
					nOpca := 1
				EndIf	
			EndIf
		EndIf

	Else
		nOpca	:=	1
	EndIf
	
	If nOpca == 0
		dbSelectArea(cAlias)
		dbSetOrder(nIndexAtu)
		deleteObject(oOk)
		deleteObject(oNo)
		FA330aUnlock()
		Return
	EndIf
	
	//Metricas - Carregamento da tela de seleção
	If __lMetric
		nInicio := Seconds()
	Endif

	DbSelectArea("SE1")
	
	//Os valores exibidos em tela o serao na Moeda 1	
	If lPccBxCr
		If !__lPccMR
			nPropImp := nVlrCompe / SE1->E1_BASEPIS
			If dDataBase <= dLastPcc
				nPis		:= SE1->E1_PIS * nPropImp
				nCofins		:= SE1->E1_COFINS * nPropImp
				nCsll		:= SE1->E1_CSLL * nPropImp
				nIrrf		:= SE1->E1_IRRF * nPropImp
			Else
				If FNatPCC(SE1->E1_FILORIG, SE1->E1_NATUREZ)
					If nVlrCompe > 0
						aPcc	:= newMinPcc(dBaixa,nVlrCompe,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
					Else
						If dBaixa <> dDatabase .and. SE1->E1_TIPO <> MVRECANT //Alterou a data de baixa e nao alterou o valor
							aPcc := newMinPcc(dBaixa,Iif(lMata460, nBasePcc, nOldVal),SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
						EndIf
					EndIf
					
					If Len(aPcc) > 2	
						nPis		:= 	aPcc[2]
						nCofins		:=	aPcc[3]
						nCsll		:=  aPcc[4]
					EndIf
					If Len(aPcc) > 4 
						__aTitCalc := aPcc[5]
					EndIf
				EndIf
				If cPaisLoc == "BRA"
					If SE1->E1_BASEIRF < SE1->E1_VALOR
						nIrrf := Iif(nVlrCompe	> 0,nVlrCompe ,nOldVal)*(nIrrf/SE1->E1_VALOR)
					Else
						IF nIrrf == SE1->E1_IRRF 
							nIrrf := nIrrf * (Iif(nVlrCompe	> 0,nVlrCompe ,nOldVal) / SE1->E1_BASEIRF)
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
		
		If dBaixa <> dDatabase .And. SE1->E1_TIPO <> MVRECANT //Alterou a data de baixa e nao alterou o valor
			If nPis + nCofins + nCsll + nIrrf > 0  .And. SE1->E1_TIPO <> MV_CRNEG .And. SE1->E1_TIPO <> MVRECANT
				lRetMinAux := ( ( lRaRtImpMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR + __nIrfCaMR > 0 ) .Or. ( lRaRtImp .And. aDadosRet[1] > nVlMinImp ) )
				If ( !lRartImp .And. !lRaRtImpMR ) .Or. lRetMinAux .And. MV_PAR08 == 2
					nValRec	:= nOldVal
					nValRec -= ( nPis + nCofins + nCsll + nIrrf + nIss + nInss )
					nTotImpbx := ( nPis + nCofins + nCsll + nIrrf + nIss + nInss )
					nSaldo := SE1->E1_SALDO - nPis - nCofins - nCsll
					If nVlrCompe == 0 .and. !lIrPjBxCr
						nSaldo := nSaldo - SE1->E1_IRRF
					EndIf
				EndIf
			Endif
		EndIf
	EndIf

	nValor 		:= nVlrCompe
	nValComp 	:= nValor
	nValIrf		:= nIrrf
	Processa({ || Fa330Tit(dEmissao,cOrigem,lCredito,aNumLay,lAutomato)})  // Monta a Matriz com as compensacoes validas

	If Len(aTitulos) == 0
		Help(" ",1,"NOTITSEL",,"",1,0,,,,,,{STR0129})
		DeleteObject(oOk)
		DeleteObject(oNo)
		FA330aUnlock()
		Exit
	EndIf

	nQtdTit := 0
	nOpca := 0
	If cOrigem $ "MATA465#COMPENSANCC"
		cLote	:=	cLoteFat
	EndIf
	
	If !lAutomato
		aSize := MsAdvSize(,.F.,400)
		DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],0 to aSize[6],aSize[5] of oMainWnd PIXEL
		oDLg:lMaximized := .T.
		oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20,.T.,.T. )
		oPanel:Align := CONTROL_ALIGN_TOP
		
		If cPaisLoc != "RUS"
			@003,005 Say STR0073 + Pad(Getmv("MV_SIMB"+Alltrim(STR(nMoeda))),4)  PIXEL Of oPanel  // "Compensaçäo de Titulos - Valores expressos em "
		Else
			@003,005 Say STR0109 + SE1->E1_PREFIXO + " - " + SE1->E1_NUM + STR0110 + SE1->E1_NOMCLI PIXEL Of oPanel
		EndIf
		
		//Montando cabecalho do list box³
		If cPaisLoc == "BRA"
			If mv_par02 == 2 // Considera Cliente == Não
				nPosPis 	:= 17
				nPosCof 	:= 18
				nPosCsl 	:= 19
				nPosIrf 	:= 20
				nPosBPCC 	:= 27
				nPosBPCR 	:= 28
				nPosBIRF 	:= 29
				nPosxRet	:= 30
				nPosVa		:= If(__lMotRet,31,30)
				If __lMotRet
					@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
						HEADER "",;						//01
						STR0006,;						//02"Prefixo"
						STR0007,;						//03"Número"
						STR0008,;						//04"Parcela"
						STR0009,;						//05"Tipo"
						STR0011,;						//06"Loja"
						STR0016,;						//07"Saldo do t¡tulo"
						STR0017,;						//08"Valor compensado"
						STR0064,;						//09"Limite de compensação"
						STR0049,;						//10"Acréscimos"
						STR0050,;						//11"Decréscimos"
						STR0125,;						//12"Valores Acessórios"
						STR0046,;						//13"Cliente/Loja"
						STR0041,;						//14"Nome do Cliente"
						Rtrim(RetTitle("A1_CGC")),;		//15"CGC do Cliente"
						Rtrim(RetTitle("E1_HIST")),;	//16"Historico"
						RetTitle("E1_FILIAL"),; 		//17"FILIAL"
						RetTitle("E1_PIS"),;			//18
						RetTitle("E1_COFINS"),;			//19
						RetTitle("E1_CSLL"),; 			//20
						RetTitle("E1_IRRF"),;			//21
						STR0126;						//22"Retenções"
						COLSIZES 12,;															//01
						GetTextWidth(0,"BBBBB"),;												//02
						GetTextWidth(0,"BBBBBBB"),;												//03
						GetTextWidth(0,"BBBB"),;												//04
						GetTextWidth(0,"BBB"),;													//05
						GetTextWidth(0,"BBB"),;													//06
						GetTextWidth(0,"BBBBBBBBB"),;											//07
						GetTextWidth(0,"BBBBBBBBB"),;											//08
						GetTextWidth(0,"BBBBBBBBBB"),;											//09
						GetTextWidth(0,"BBBBBBBBB"),;											//10
						GetTextWidth(0,"BBBBBBBBB"),;											//11
						GetTextWidth(0,"BBBBBBBBB"),;											//12
						GetTextWidth(0,"BBBBBBBBB"),;											//13
						GetTextWidth(0,"BBBBBBBBBBB"),;											//14
						GetTextWidth(0,"BBBBBBBBBBBBBBBBBB"),;									//15
						GetTextWidth(0,"BBBBBB"),;												//16
						GetTextWidth(0,REPLICATE("B",IIf( lFWCodFil, FWGETTAMFILIAL, 2 ))),;	//17
						GetTextWidth(0,"BBBBBB"),;												//18
						GetTextWidth(0,"BBBBBB"),;												//19
						GetTextWidth(0,"BBBBBB"),;												//20
						GetTextWidth(0,"BBBBBB"),;												//21
						GetTextWidth(0,"BBBBBB");												//22
						SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
				Else
					@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
						HEADER "",;					//01
						STR0006,;					//02"Prefixo"
						STR0007,;					//03"N£mero"
						STR0008,;					//04"Parcela"
						STR0009,;					//05"Tipo"
						STR0011,;					//06"Loja"
						STR0016,;					//07"Saldo do t¡tulo"
						STR0017,;					//08"Valor compensado"
						STR0064,;					//09"Limite de compensação"
						STR0049,;					//10"Acréscimos"
						STR0050,;					//11"Decréscimos"
						STR0125,;					//12"Valores Acessórios"
						STR0046,;					//13"Cliente/Loja"
						STR0041,;					//14"Nome do Cliente"
						Rtrim(RetTitle("A1_CGC")),; //15"CGC do Cliente"
						Rtrim(RetTitle("E1_HIST")),;//16Historico
						RetTitle("E1_FILIAL"),;		//17FILIAL
						RetTitle("E1_PIS"),;		//18
						RetTitle("E1_COFINS"),;		//19
						RetTitle("E1_CSLL"),;		//20
						RetTitle("E1_IRRF");		//21
						COLSIZES 12,;															//01
						GetTextWidth(0,"BBBBB"),;												//02
						GetTextWidth(0,"BBBBBBB"),;												//03
						GetTextWidth(0,"BBBB"),;												//04
						GetTextWidth(0,"BBB"),;													//05
						GetTextWidth(0,"BBB"),;													//06
						GetTextWidth(0,"BBBBBBBBB"),;											//07
						GetTextWidth(0,"BBBBBBBBB"),;											//08
						GetTextWidth(0,"BBBBBBBBBB"),;											//09
						GetTextWidth(0,"BBBBBBBBB"),;											//10
						GetTextWidth(0,"BBBBBBBBB"),;											//11
						GetTextWidth(0,"BBBBBBBBB"),;											//12
						GetTextWidth(0,"BBBBBBBBB"),;											//13
						GetTextWidth(0,"BBBBBBBBBBB"),;											//14
						GetTextWidth(0,"BBBBBBBBBBBBBBBBBB"),;									//15
						GetTextWidth(0,"BBBBBB"),;												//16
						GetTextWidth(0,REPLICATE("B",IIf( lFWCodFil, FWGETTAMFILIAL, 2 ))),;	//17
						GetTextWidth(0,"BBBBBB"),;												//18
						GetTextWidth(0,"BBBBBB"),;												//19
						GetTextWidth(0,"BBBBBB"),;												//20
						GetTextWidth(0,"BBBBBB");												//21
						SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
				EndIf
				If GetFinLGPD()
					oTitulo:aObfuscatedCols := {	.F., ;
													.F., ;
													.F., ;
													.F., ;
													.F., ; // 5
													.F., ;
													.F., ;
													.F., ;
													.F., ;
													.F., ; // 10
													.F., ;
													.F., ;
													.F., ;
													RetGlbLGPD('E1_NOMCLI') , ;
													RetGlbLGPD('A1_CGC') , ; // 15
													RetGlbLGPD('E1_HIST'), ;
													.F., ;
													.F., ;
													.F., ;
													.F., ; // 20
													.F., ;
													.F., }
				EndIf													
				
				oTitulo:SetArray(aTitulos)
				oTitulo:bLine := { || {If(aTitulos[oTitulo:nAt,8],oOk,oNo),;
					aTitulos[oTitulo:nAt,1],;//Prefixo
					aTitulos[oTitulo:nAt,2],;//Numero
					aTitulos[oTitulo:nAt,3],;//Parcela
					aTitulos[oTitulo:nAt,4],;//Tipo
					aTitulos[oTitulo:nAt,5],;//Loja
					aTitulos[oTitulo:nAt,6],;//Saldo do Titulo
					If(aTitulos[oTitulo:nAt,8],aTitulos[oTitulo:nAt,7],Transform(0,__cPiE1Sld)),;//Saldo Compensar
					aTitulos[oTitulo:nAt,25],;//Limite de Compensacao
					aTitulos[oTitulo:nAt,13],;//Acréscimos
					aTitulos[oTitulo:nAt,14],;//Decréscimos
					aTitulos[oTitulo:nAt,nPosVa],;//Valores Acessórios
					aTitulos[oTitulo:nAt,10],;//CLiente+Loja
					aTitulos[oTitulo:nAt,11],;//Nome CLiente
					aTitulos[oTitulo:nAt,12],;//CGC
					aTitulos[oTitulo:nAt,15],;//Historico
					aTitulos[oTitulo:nAt,16],;//Filial
					aTitulos[oTitulo:nAt,17],;//Pis
					aTitulos[oTitulo:nAt,18],;//Cofins
					aTitulos[oTitulo:nAt,19],;//Csll
					aTitulos[oTitulo:nAt,20],;//Irrf
					If(__lMotRet,aTitulos[oTitulo:nAt,30],Nil)}}//Motor de Retenções
	
			Else // Considera Cliente == Sim
				nPosPis		:= 14
				nPosCof		:= 15
				nPosCsl		:= 16
				nPosIrf		:= 17
				nPosBPCC 	:= 24
				nPosBPCR 	:= 25
				nPosBIRF 	:= 26
				nPosxRet	:= 27
				nPosVa		:= If(__lMotRet,28,27)
				If __lMotRet
					@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
						HEADER "",;					//01
						STR0006,;					//02"Prefixo"
						STR0007,;					//03"N£mero"
						STR0008,;					//04"Parcela"
						STR0009,;					//05"Tipo"
						STR0011,;					//06"Loja"
						STR0016,;					//07"Saldo do t¡tulo"
						STR0017,;					//08"Valor compensado"
						STR0064,;					//09"Limite de compensação"
						STR0049,;					//10"Acréscimos"
						STR0050,;					//11"Decréscimos"
						STR0125,;					//12"Valores Acessórios"
						Rtrim(RetTitle("E1_HIST")),;//13Historico
						RetTitle("E1_FILIAL"),; 	//14FILIAL
						RetTitle("E1_PIS"),; 		//15
						RetTitle("E1_COFINS"),; 	//16
						RetTitle("E1_CSLL"),; 		//17
						RetTitle("E1_IRRF"),; 		//18
						STR0126;					//19"Retenções"
						COLSIZES 12,;															//01
						GetTextWidth(0,"BBBBB"),;												//02
						GetTextWidth(0,"BBBBBBB"),;												//03
						GetTextWidth(0,"BBBB"),;												//04
						GetTextWidth(0,"BBB"),;													//05
						GetTextWidth(0,"BBB"),;													//06
						GetTextWidth(0,"BBBBBBBBB"),;											//07
						GetTextWidth(0,"BBBBBBBBB"),;											//08
						GetTextWidth(0,"BBBBBBBBBB"),;											//09
						GetTextWidth(0,"BBBBBBBBB"),;											//10
						GetTextWidth(0,"BBBBBBBBB"),;											//11
						GetTextWidth(0,"BBBBBBBBB"),;											//12
						GetTextWidth(0,"BBBBBBBBBBBBBBBBBBBB"),;								//13
						GetTextWidth(0,REPLICATE("B",IIf( lFWCodFil, FWGETTAMFILIAL, 2 ))),;	//14
						GetTextWidth(0,"BBBBBB"),;												//15
						GetTextWidth(0,"BBBBBB"),;												//16
						GetTextWidth(0,"BBBBBB"),;												//17
						GetTextWidth(0,"BBBBBB"),;												//18
						GetTextWidth(0,"BBBBBB");												//19
						SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,@aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
				Else
					@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
						HEADER "",;					//01
						STR0006,;					//02"Prefixo"
						STR0007,;					//03"N£mero"
						STR0008,;					//04"Parcela"
						STR0009,;					//05"Tipo"
						STR0011,;					//06"Loja"
						STR0016,;					//07"Saldo do t¡tulo"
						STR0017,;					//08"Valor compensado"
						STR0064,;					//09"Limite de compensação"
						STR0049,;					//10"Acréscimos"
						STR0050,;					//11"Decréscimos"
						STR0125,;					//12"Valores Acessórios"
						Rtrim(RetTitle("E1_HIST")),;//13Historico
						RetTitle("E1_FILIAL"),; 	//14FILIAL
						RetTitle("E1_PIS"),; 		//15
						RetTitle("E1_COFINS"),; 	//16
						RetTitle("E1_CSLL"),; 		//17
						RetTitle("E1_IRRF"); 		//18
						COLSIZES 12,;															//01
						GetTextWidth(0,"BBBBB"),;												//02
						GetTextWidth(0,"BBBBBBB"),;												//03
						GetTextWidth(0,"BBBB"),;												//04
						GetTextWidth(0,"BBB"),;													//05
						GetTextWidth(0,"BBB"),;													//06
						GetTextWidth(0,"BBBBBBBBB"),;											//07
						GetTextWidth(0,"BBBBBBBBB"),;											//08
						GetTextWidth(0,"BBBBBBBBBB"),;											//09
						GetTextWidth(0,"BBBBBBBBB"),;											//10
						GetTextWidth(0,"BBBBBBBBB"),;											//11
						GetTextWidth(0,"BBBBBBBBB"),;											//12
						GetTextWidth(0,"BBBBBBBBBBBBBBBBBBBB"),;								//13
						GetTextWidth(0,REPLICATE("B",IIf( lFWCodFil, FWGETTAMFILIAL, 2 ))),;	//14
						GetTextWidth(0,"BBBBBB"),;												//15
						GetTextWidth(0,"BBBBBB"),;												//16
						GetTextWidth(0,"BBBBBB"),;												//17
						GetTextWidth(0,"BBBBBB");												//18
						SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,@aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
				EndIf
				
				oTitulo:SetArray(aTitulos)
				oTitulo:bLine := { || {If(aTitulos[oTitulo:nAt,8],oOk,oNo),;//Flag
					aTitulos[oTitulo:nAt,1],;//Prefixo
					aTitulos[oTitulo:nAt,2],;//Numero
					aTitulos[oTitulo:nAt,3],;//Parcela
					aTitulos[oTitulo:nAt,4],;//Tipo
					aTitulos[oTitulo:nAt,5],;//Loja
					aTitulos[oTitulo:nAt,6],;//Saldo do Titulo
					If(aTitulos[oTitulo:nAt,8],aTitulos[oTitulo:nAt,7],Transform(0,__cPiE1Sld)),;//Valor Compensado
					aTitulos[oTitulo:nAt,22],;//Limite de Compensacao
					aTitulos[oTitulo:nAt,10],;//Acrescimos
					aTitulos[oTitulo:nAt,11],;//Decréscimos
					aTitulos[oTitulo:nAt,nPosVa],;//Valores Acessórios
					aTitulos[oTitulo:nAt,12],;//Historico
					aTitulos[oTitulo:nAt,13],;//Filial
					aTitulos[oTitulo:nAt,14],;//Pis
					aTitulos[oTitulo:nAt,15],;//Cofins
					aTitulos[oTitulo:nAt,16],;//Csll
					aTitulos[oTitulo:nAt,17],;//Irrf
					If(__lMotRet,aTitulos[oTitulo:nAt,27],Nil)}}//Motor de Retenções
			EndIf
		ElseIf cPaisLoc == "EUA"

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se na listagem de titulos nao considerar o cliente original do titulo selecionado, mostra o cgc |
			//|e o nome dos clientes referentes a cada titulo (MV_PAR02==2)                                    |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If MV_PAR02 == 2
				//Adiciona Nome e CGC do cliente ao cabecalho
				nPosPis 	:= 17
				nPosCof 	:= 18
				nPosCsl 	:= 19
				nPosIrf 	:= 20
				nPosBPCC 	:= 27
				nPosBPCR 	:= 28
				nPosBIRF 	:= 29
				@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
					HEADER "",STR0006,;  //"Prefixo"
					STR0007,;  //"N£mero"
					STR0008,;  //"Parcela"
					STR0009,;  //"Tipo"
					STR0011,;  //"Loja"
					STR0016,;  //"Saldo do t¡tulo"
					STR0017,;  //"Valor compensado"
					STR0048,;  //"Acréscimos"
					STR0049,;  //"Decréscimos"
					STR0038,;  //"Moeda"
					STR0039,;  //"Emissao"
					STR0041,;  //"Nome do Cliente"
					Rtrim(RetTitle("A1_CGC")),;  //"CGC do Cliente"
					Rtrim(RetTitle("E1_HIST")),; //Historico
					RetTitle("E1_FILIAL"); //FILIAL
					COLSIZES 12,GetTextWidth(0,"BBBBB"),GetTextWidth(0,"BBBBBBB"),;
					GetTextWidth(0,"BBBB"),GetTextWidth(0,"BBB"),;
					GetTextWidth(0,"BBB"), GetTextWidth(0,"BBBBBBBBB"),;
					GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBB"),;
					GetTextWidth(0,"BBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),;
					GetTextWidth(0,"BBBBBBBBBBBBBBBBBBBB"),GetTextWidth(0,"BBBBBBBBBBBBBB"), GetTextWidth(0,"BBBBBBBBBBBBBBBBBBBB"),GetTextWidth(0,REPLICATE("B",IIf( lFWCodFil, FWGETTAMFILIAL, 2 )));
					SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,@aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
					oTitulo:SetArray(aTitulos)
					oTitulo:bLine := { || {If(	aTitulos[oTitulo:nAt,8],oOk,oNo),;
												aTitulos[oTitulo:nAt,1],;
												aTitulos[oTitulo:nAt,2],;
												aTitulos[oTitulo:nAt,3],;
												aTitulos[oTitulo:nAt,4],;
												aTitulos[oTitulo:nAt,5],;
												aTitulos[oTitulo:nAt,6],;
												If(aTitulos[oTitulo:nAt,8],aTitulos[oTitulo:nAt,7],Transform(0,__cPiE1Sld)),;
												aTitulos[oTitulo:nAt,13],;
												aTitulos[oTitulo:nAt,14],;
												aTitulos[oTitulo:nAt,9],;
												aTitulos[oTitulo:nAt,10],;
												aTitulos[oTitulo:nAt,11],;
												aTitulos[oTitulo:nAt,12],;
												aTitulos[oTitulo:nAt,15],;
												aTitulos[oTitulo:nAt,16]}}
				//---
			Else
				//Considera o cliente original do titulo seleionado, nao mostra o nome do cliente
				nPosPis		:= 14
				nPosCof		:= 15
				nPosCsl		:= 16
				nPosIrf		:= 17
				nPosBPCC 	:= 24
				nPosBPCR 	:= 25
				nPosBIRF 	:= 26
				@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
					HEADER "",STR0006,;  //"Prefixo"
					STR0007,;  //"N£mero"
					STR0008,;  //"Parcela"
					STR0009,;  //"Tipo"
					STR0011,;  //"Loja"
					STR0016,;  //"Saldo do t¡tulo"
					STR0017,;   //"Valor compensado"
					STR0048,; //"Acréscimos"
					STR0049,; //"Decréscimos"
					STR0038,;   //"Moeda"
					STR0039,;   //"Emissao"
					RetTitle("E1_FILIAL"); //FILIAL
					COLSIZES 12,GetTextWidth(0,"BBBBB"),GetTextWidth(0,"BBBBBBB"),;
					GetTextWidth(0,"BBBB"),GetTextWidth(0,"BBB"),GetTextWidth(0,"BBB"),;
					GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),;
					GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),;
					GetTextWidth(0,"BBBBB"),GetTextWidth(0,"BBBBBBBB"),GetTextWidth(0,REPLICATE("B",IIf( lFWCodFil, FWGETTAMFILIAL, 2 )));
					SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,@aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
					oTitulo:SetArray(aTitulos)
					oTitulo:bLine := { || {If(aTitulos[oTitulo:nAt,8],oOk,oNo),;
					aTitulos[oTitulo:nAt,1],;
					aTitulos[oTitulo:nAt,2],;
					aTitulos[oTitulo:nAt,3],;
					aTitulos[oTitulo:nAt,4],;
					aTitulos[oTitulo:nAt,5],;
					aTitulos[oTitulo:nAt,6],;
					If(aTitulos[oTitulo:nAt,8],aTitulos[oTitulo:nAt,7],Transform(0,__cPiE1Sld)),;
					aTitulos[oTitulo:nAt,11],;
					aTitulos[oTitulo:nAt,12],;
					aTitulos[oTitulo:nAt,9],;
					aTitulos[oTitulo:nAt,10],;
					aTitulos[oTitulo:nAt,13]}}

			EndIf
		ElseIf cPaisLoc == "RUS"
			If MV_PAR02 == 2
				@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
					HEADER "",RetTitle("E1_FILIAL"),; //FILIAL
					STR0006,;   //"Prefixo"
					STR0007,;   //"N?mero"
					STR0008,;   //"Parcela"
					STR0009,;   //"Tipo"
					STR0038,;   //"Moeda"
					STR0103,;	//Moeda code
					STR0016,;   //"Saldo do t?tulo"
					STR0017,;   //"Valor compensado"
					STR0104,;	//Cust. code
					STR0011,;   //"Loja"
					STR0041,;   //"Nome do Cliente"
					Rtrim(RetTitle("E1_HIST")),; //Historico
					STR0105,;	//Contr. code
					STR0039,;   //"Emissao"
					STR0106,;	// Bill Value
					STR0107,;	//Vl R$
					STR0108;	// Conv. unit
					COLSIZES 12,GetTextWidth(0,"BBBBBB"),GetTextWidth(0,"BBB"),;
					GetTextWidth(0,"BBBBBBBB"),GetTextWidth(0,"BB"),GetTextWidth(0,"BBB"),;
					GetTextWidth(0,"BB"),GetTextWidth(0,"BBB"),;
					GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),;
					GetTextWidth(0,"BBBBBB"),GetTextWidth(0,"BB"),GetTextWidth(0,"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"),;
					GetTextWidth(0,"BBBBBBBBBBBB"),GetTextWidth(0,"BBBBBBBBBBBBBBB"),;
					GetTextWidth(0,"BBBBBBBB"),GetTextWidth(0,"BBBBBBBBBBBBBBBB"),GetTextWidth(0,"BBBBBBBBBBBBBBBB"),;
					GetTextWidth(0,"B"),;
					SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,@aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
					oTitulo:SetArray(aTitulos)
					oTitulo:bLine := { || {If(aTitulos[oTitulo:nAt,8],oOk,oNo),;
					aTitulos[oTitulo:nAt,16],aTitulos[oTitulo:nAt,1],;
					aTitulos[oTitulo:nAt,2],aTitulos[oTitulo:nAt,3],;
					aTitulos[oTitulo:nAt,4],aTitulos[oTitulo:nAt,9],;
					aTitulos[oTitulo:nAt,23],aTitulos[oTitulo:nAt,6],;
					If(aTitulos[oTitulo:nAt,8],aTitulos[oTitulo:nAt,7],Transform(0,PesqPict("SE1","E1_SALDO"))),aTitulos[oTitulo:nAt,18],;
					aTitulos[oTitulo:nAt,5],aTitulos[oTitulo:nAt,11],;
					aTitulos[oTitulo:nAt,15],aTitulos[oTitulo:nAt,19],;
					aTitulos[oTitulo:nAt,10],aTitulos[oTitulo:nAt,20],;
					aTitulos[oTitulo:nAt,21],aTitulos[oTitulo:nAt,22]}}
			Else
				@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
					HEADER "",RetTitle("E1_FILIAL"),; //FILIAL
					STR0006,;   //"Prefixo"
					STR0007,;   //"N?mero"
					STR0008,;   //"Parcela"
					STR0009,;   //"Tipo"
					STR0038,;   //"Moeda"
					STR0103,;   //Moeda code
					STR0016,;   //"Saldo do t?tulo"
					STR0017,;   //"Valor compensado"
					STR0104,;	//Cust. code
					STR0011,;   //"Loja"
					STR0105,;	//Contr. code
					STR0039,;   //"Emissao"
					STR0106,;   // Bill Value
					STR0107,;   //Vl R$
					STR0108;    // Conv. unit
					COLSIZES 12,GetTextWidth(0,"BBBBBB"),GetTextWidth(0,"BBB"),;
					GetTextWidth(0,"BBBBBBBB"),GetTextWidth(0,"BB"),GetTextWidth(0,"BBB"),;
					GetTextWidth(0,"BB"),GetTextWidth(0,"BBB"),;
					GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),;
					GetTextWidth(0,"BBBBBB"),GetTextWidth(0,"BB"),GetTextWidth(0,"BBBBBBBBBBBBBBB"),;
					GetTextWidth(0,"BBBBBBBB"),GetTextWidth(0,"BBBBBBBBBBBBBBBB"),GetTextWidth(0,"BBBBBBBBBBBBBBBB"),;
					GetTextWidth(0,"B"),;
					SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,@aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
					oTitulo:SetArray(aTitulos)
					oTitulo:bLine := { || {If(aTitulos[oTitulo:nAt,8],oOk,oNo),;
					aTitulos[oTitulo:nAt,13],aTitulos[oTitulo:nAt,1],;
					aTitulos[oTitulo:nAt,2],aTitulos[oTitulo:nAt,3],;
					aTitulos[oTitulo:nAt,4],aTitulos[oTitulo:nAt,9],;
					aTitulos[oTitulo:nAt,20],aTitulos[oTitulo:nAt,6],;
					If(aTitulos[oTitulo:nAt,8],aTitulos[oTitulo:nAt,7],Transform(0,PesqPict("SE1","E1_SALDO"))),aTitulos[oTitulo:nAt,15],;
					aTitulos[oTitulo:nAt,5],aTitulos[oTitulo:nAt,16],;
					aTitulos[oTitulo:nAt,10],aTitulos[oTitulo:nAt,17],;
					aTitulos[oTitulo:nAt,18],aTitulos[oTitulo:nAt,19]}}
			EndIf
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se na listagem de titulos nao considerar o cliente original do titulo selecionado, mostra o cgc |
			//|e o nome dos clientes referentes a cada titulo (MV_PAR02==2)                                    |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If MV_PAR02 == 2
				//Adiciona Nome e CGC do cliente ao cabecalho
				nPosPis 	:= 17
				nPosCof 	:= 18
				nPosCsl 	:= 19
				nPosIrf 	:= 20
				nPosBPCC 	:= 27
				nPosBPCR 	:= 28
				nPosBIRF 	:= 29
				@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
					HEADER "",STR0006,;  //"Prefixo"
					STR0007,;  //"N£mero"
					STR0008,;  //"Parcela"
					STR0009,;  //"Tipo"
					STR0011,;  //"Loja"
					STR0016,;  //"Saldo do t¡tulo"
					STR0017,;   //"Valor compensado"
					STR0048,; //"Acréscimos"
					STR0049,; //"Decréscimos"
					STR0038,;   //"Moeda"
					STR0039,;   //"Emissao"
					STR0041,;  //"Nome do Cliente"
					Rtrim(RetTitle("A1_CGC")),; //"CGC do Cliente"
					Rtrim(RetTitle("E1_HIST")),; //Historico
					RetTitle("E1_FILIAL"); //FILIAL
					COLSIZES 12,GetTextWidth(0,"BBBBB"),GetTextWidth(0,"BBBBBBB"),;
					GetTextWidth(0,"BBBB"),GetTextWidth(0,"BBB"),;
					GetTextWidth(0,"BBB"), GetTextWidth(0,"BBBBBBBBB"),;
					GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBB"),;
					GetTextWidth(0,"BBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),;
					GetTextWidth(0,"BBBBBBBBBBBBBBBBBBBB"),GetTextWidth(0,"BBBBBBBBBBBBBB"), GetTextWidth(0,"BBBBBBBBBBBBBBBBBBBB"),GetTextWidth(0,REPLICATE("B",IIf( lFWCodFil, FWGETTAMFILIAL, 2 )));
					SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,@aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
					oTitulo:SetArray(aTitulos)
					oTitulo:bLine := { || {If(aTitulos[oTitulo:nAt,8],oOk,oNo),;
					aTitulos[oTitulo:nAt,1],aTitulos[oTitulo:nAt,2],;
					aTitulos[oTitulo:nAt,3],aTitulos[oTitulo:nAt,4],;
					aTitulos[oTitulo:nAt,5],aTitulos[oTitulo:nAt,6],;
					If(aTitulos[oTitulo:nAt,8],aTitulos[oTitulo:nAt,7],Transform(0,__cPiE1Sld)),aTitulos[oTitulo:nAt,13],;
					aTitulos[oTitulo:nAt,14],aTitulos[oTitulo:nAt,9],;
					aTitulos[oTitulo:nAt,10],aTitulos[oTitulo:nAt,11],;
					aTitulos[oTitulo:nAt,12], aTitulos[oTitulo:nAt,15],aTitulos[oTitulo:nAt,16]}}
				//---
			Else
				//Considera o cliente original do titulo seleionado, nao mostra o nome do cliente
				nPosPis		:= 14
				nPosCof		:= 15
				nPosCsl		:= 16
				nPosIrf		:= 17
				nPosBPCC 	:= 24
				nPosBPCR 	:= 25
				nPosBIRF 	:= 26
				@ 1.0,1.0 LISTBOX oTitulo	VAR cVarQ Fields;
					HEADER "",STR0006,;  //"Prefixo"
					STR0007,;  //"N£mero"
					STR0008,;  //"Parcela"
					STR0009,;  //"Tipo"
					STR0011,;  //"Loja"
					STR0016,;  //"Saldo do t¡tulo"
					STR0017,;   //"Valor compensado"
					STR0048,; //"Acréscimos"
					STR0049,; //"Decréscimos"
					STR0038,;   //"Moeda"
					STR0039,;   //"Emissao"
					RetTitle("E1_FILIAL"); //FILIAL
					COLSIZES 12,GetTextWidth(0,"BBBBB"),GetTextWidth(0,"BBBBBBB"),;
					GetTextWidth(0,"BBBB"),GetTextWidth(0,"BBB"),GetTextWidth(0,"BBB"),;
					GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),;
					GetTextWidth(0,"BBBBBBBBB"),GetTextWidth(0,"BBBBBBBBB"),;
					GetTextWidth(0,"BBBBB"),GetTextWidth(0,"BBBBBBBB"),GetTextWidth(0,REPLICATE("B",IIf( lFWCodFil, FWGETTAMFILIAL, 2 )));
					SIZE 293,54.5 ON DBLCLICK (aTitulos:=FA330Troca(oTitulo:nAt,@aTitulos,oGet01,,@oTitulo),oTitulo:Refresh()) NOSCROLL
					oTitulo:SetArray(aTitulos)
					oTitulo:bLine := { || {If(aTitulos[oTitulo:nAt,8],oOk,oNo),;
					aTitulos[oTitulo:nAt,1],aTitulos[oTitulo:nAt,2],;
					aTitulos[oTitulo:nAt,3],aTitulos[oTitulo:nAt,4],;
					aTitulos[oTitulo:nAt,5],aTitulos[oTitulo:nAt,6],;
					If(aTitulos[oTitulo:nAt,8],aTitulos[oTitulo:nAt,7],Transform(0,__cPiE1Sld)),aTitulos[oTitulo:nAt,11],;
					aTitulos[oTitulo:nAt,12],aTitulos[oTitulo:nAt,9],;
					aTitulos[oTitulo:nAt,10],aTitulos[oTitulo:nAt,13]}}
				//---
			EndIf
			//----
		EndIf
	EndIf
	
	If !lAutomato
		If !cPaisLoc $ "BRA|RUS"
			oTitulo:bHeaderClick := {|oObj,nCol| Iif( nCol == 1, fMarkAll( @aTitulos, @nValTot ), Nil ), oTitulo:Refresh(), oGet01:Refresh()}
		EndIf
		
		oTitulo:Align := CONTROL_ALIGN_ALLCLIENT
		//---
		If cPaisLoc == "RUS"
			@ 4, 353 SAY STR0092 PIXEL OF oPanel SIZE 70,7
			@ 4, 403 MSGET nVlrCompe PICTURE "@E 999,999,999.99" WHEN .F.	PIXEL OF oPanel SIZE 70,7
			@ 4, 503 SAY STR0045 PIXEL OF oPanel SIZE 70,7
			@ 4, 553 MSGET oGet01 VAR nValTot PICTURE "@E 999,999,999.99" WHEN .F. PIXEL OF oPanel SIZE 70,7
		Else			
			@  4, 353 SAY STR0045 PIXEL OF oPanel SIZE 70,7
			@  4, 403 MSGET oGet01 VAR nValTot PICTURE "@E 999,999,999.99" HASBUTTON WHEN .F. PIXEL OF oPanel SIZE 70,7
		EndIf

		If lF330ATLIS
			ExecBlock("F330ATLIS",.F.,.F., { @oPanel , 1, nValTot , nValor } )
		EndIf
	EndIf
	
	If !lPanelFin  //Chamado pelo Painel Financeiro
		If !lAutomato
			oPanel2 := TPanel():New(0,0,'',oDlg, oDlg:oFont, .T., .T.,, ,20,20,.T.,.T. )
			oPanel2:Align := CONTROL_ALIGN_BOTTOM

			@  4, 08   BUTTON STR0124 SIZE 50,11 ACTION (F330Button(lPccBxCr,oTitulo,oGet01,.T.)) OF oPanel2 PIXEL
			@  4, 65   BUTTON STR0044 SIZE 50,11 ACTION (F330Button(lPccBxCr,oTitulo,oGet01,.F.)) OF oPanel2 PIXEL
			@  4, 122  BUTTON STR0001 SIZE 50,11 ACTION PesqListBox(@oTitulo,aTitulos) OF oPanel2 PIXEL
			//VA: Adiciona a consulta do VA
			If __l330Va
				@  4, 179  BUTTON STR0125 SIZE 50,11 ACTION FA330VACON(aTitulos[oTitulo:nAt]) OF oPanel2 PIXEL
			EndIf
			
			If cPaisLoc == "RUS"
				If FindFunction("FA330Filt")
					@  4, 179 BUTTON STR0098 SIZE 50,11 ACTION FA330Filt(@oTitulo,@aTitulos,cNumCont,lAutomato,@oOk,@oNo,cVarQ,oPanel,dEmissao,cOrigem,lCredito,aNumLay,cNumCont) OF oPanel2 PIXEL
				EndIf	
				If FindFunction("FA330Unfil")
					@  4, 236 BUTTON STR0100 SIZE 50,11 ACTION FA330Unfil(@oTitulo,@aTitulos,lAutomato,@oOk,@oNo,dEmissao,cOrigem,lCredito,aNumLay,cNumCont) OF oPanel2 PIXEL
				EndIf
				If FindFunction("FA330AutMk")
					@  4, 293 BUTTON STR0091 SIZE 50,11 ACTION FA330AutMk(@oTitulo,@aTitulos,lAutomato,@oOk,@oNo,dEmissao,cOrigem,lCredito,aNumLay,cNumCont) OF oPanel2 PIXEL
				EndIf	
				If FindFunction("FA330Sort")
					@  4, 350 BUTTON STR0094 SIZE 50,11 ACTION FA330Sort(@oTitulo,@aTitulos,cNumCont,lAutomato,@oOk,@oNo,@oPanel,@nValTot) OF oPanel2 PIXEL	
				EndIf	
			EndIf

			If lF330BOTON
				ExecBlock("F330BOTON",.F.,.F.)
			EndIf

			DEFINE SBUTTON FROM 4,Iif(cPaisLoc != "RUS",325,425) TYPE 1 ACTION (nValor := nVlrCompe,nOpca := 1,IF(Fa330OK(@nValTot,.F.,lPccBxCR),oDlg:End(),nOpca:=0)) ENABLE OF oPanel2 PIXEL
			If cOrigem != "LOJA800"
			   DEFINE SBUTTON FROM 4,Iif(cPaisLoc != "RUS",360,460) TYPE 2 ACTION oDlg:End() ENABLE OF oPanel2 PIXEL
			EndIf
		EndIf

	Else
		If !lAutomato
			aButtonTxt := {}
			AADD(aButtonTxt,{STR0124,STR0124, {||F330Button(lPccBxCr,oTitulo,oGet01,.T.)}})
			AADD(aButtonTxt,{STR0061,STR0044, {||F330Button(lPccBxCr,oTitulo,oGet01,.F.)}})
			AADD(aButtonTxt,{STR0001,STR0001, {||PesqListBox(@oTitulo,aTitulos)}})
		EndIf
	EndIf

	//Metricas - Carregamento da tela de seleção
	If !lAutomato .and. __lMetric
		nRegistros := Len(aTitulos)

		If nRegistros > 0
			nFim := Seconds() - nInicio
			nFim := nFim / nRegistros

			SetFunName(__cFunMet)
			FwCustomMetrics():setAverageMetric(Alltrim(ProcName())+" - TempoEntrada", "financeiro-protheus_tempo-conclusão-processo_seconds", nFim)
			SetFunName(__cFunBkp)
		Endif
	Endif

	If lPanelFin  //Chamado pelo Painel Financeiro
		If cOrigem != "LOJA800"
		   ACTIVATE MSDIALOG oDlg ON INIT (oTitulo:Refresh(), FaMyBar(oDlg,;
		   	{||nValor := nVlrCompe,nOpca := 1,IF(Fa330OK(@nValTot,.F.,lPccBxCR),oDlg:End(),nOpca:=0)},;
				{||oDlg:End()},,aButtonTxt))
		Else
		   ACTIVATE MSDIALOG oDlg ON INIT (oTitulo:Refresh(), FaMyBar(oDlg,;
		   	{||nValor := nVlrCompe,nOpca := 1,IF(Fa330OK(@nValTot,.F.,lPccBxCR),oDlg:End(),nOpca:=0)},;
				,,aButtonTxt))
		EndIf
	Else
		If !lAutomato
			If !lCheck
				fDsMarkAll(@aTitulos, @nValTot)
			EndIf
			ACTIVATE MSDIALOG oDlg CENTERED ON INIT (oTitulo:Refresh())
		Else

			If __lGetParA .or. __lCmpM460
				nLenAuto := Len(aRetAuto)

				If __lCmpM460 .and. nLenAuto > 0
					aRetAuto := aClone(aRetAuto)
				Else
					If __lGetParA .and. nLenAuto == 0
						aRetAuto := GetParAuto("FINA330TestCase")
						If ValType(aRetAuto) == "A"
							nLenAuto := Len(aRetAuto)
						EndIf
					Endif

					If (ValType(aRetAuto) != "A" .Or. nLenAuto == 0) .and. !__lCmpM460
						aRetAuto := GetParAuto("JURBXRTestCase") // Casos de testes - Módulo SIGAPFS
					EndIf
				EndIf

				AEval(aTitulos,{|x| x[8] := .F.})

				For nX := 1 to Len(aTitulos)
					For nI := 1 to Len (aRetAuto[2])
						If aTitulos[nX,1] == Padr(aRetAuto[2,nI,1],Len(aTitulos[nX,1])) .AND. ;//Prefixo
							aTitulos[nX,2] == Padr(aRetAuto[2,nI,2],Len(aTitulos[nX,2])) .AND. ;//Titulo
							aTitulos[nX,3] == Padr(aRetAuto[2,nI,3],Len(aTitulos[nX,3])) .AND. ;//Parcela
							aTitulos[nX,4] == Padr(aRetAuto[2,nI,4],Len(aTitulos[nX,4]))        //Tipo
				
							aTitulos[nX,8] := .T.
							If !lSelAuto
								lSelAuto := aTitulos[nX,8]
							EndIf
						EndIf
					Next nI
				Next nX
			
				If lSelAuto
					If Fa330OK(@nValTot,lAutomato,lPccBxCR) 
						nOpcA 		:= 1
						lSelAuto	:= .F.
					EndIf
				EndIf
			EndIf
		EndIf    
	EndIf

	//Metricas - Carregamento da tela de seleção
	If lAutomato .and. __lMetric
		nRegistros := Len(aTitulos)
		If nRegistros > 0
			nFim := Seconds() - nInicio
			nFim := nFim / nRegistros

			SetFunName(__cFunMet)
			FwCustomMetrics():setAverageMetric(Alltrim(ProcName())+" - TempoEntrada", "financeiro-protheus_tempo-conclusão-processo_seconds", nFim)
			SetFunName(__cFunBkp)
		Endif
	Endif

	If nOpcA == 1

		//Metricas - Gravação da compensação
		If __lMetric
			nInicio := Seconds()
		Endif

		If __lMotRet .And. ( ( nValTot < nSaldo ) .Or. ( lCredito .And. MV_PAR08 == 1 ) )
			aSize( aAuxTitMR, 5 ) 
			aAuxTitMR[1] := SE1->E1_NATUREZ
			aAuxTitMR[2] := SE1->E1_CLIENTE
			aAuxTitMR[3] := SE1->E1_LOJA
			aAuxTitMR[4] := SE1->E1_FILORIG
			aAuxTitMR[5] := SE1->E1_TIPO
		EndIf
		
		If lFa330Cmp
			ExecBlock("FA330Cmp",.F.,.F.)
		EndIf
		
		dDtEmis	:= SE1->E1_EMISSAO
		
		DbSelectArea("SE1")
		nOrdSE1		:= IndexOrd()
		dbGotop()
		lPadrao		:=VerPadrao(cPadrao)
		VALOR 		:= 0
		ABATIMENTO 	:= 0		//Contabilização do Abatimento
		VARIACAO	:= 0 		//Contabilização da Variação Monetária
		aRegSE1 	:= {}
		aBaixaSE5 	:= {}
		__nMarcs	:= 0
		
		If cPaisLoc == "BRA"
			For nX := 1 To Len( aTitulos )
				If	aTitulos[nX,8] 
					nVTit += Fa330VTit( aTitulos[ nX , 7 ] )
					__nMarcs += If(aTitulos[nX,8],1,0)
				EndIf
			Next nX
		EndIf
		
		BEGIN TRANSACTION

		nGravados := 0

		For nTit := 1 to Len(aTitulos)
			__nTxMoedD	:= 0
			__nPosTit	:= nTit
			nPos		:= 22
	  			  			  		
			If MV_PAR02 == 2
				nPos := 25
			Endif
			If aTitulos[nTit,8]
				lMarcado := .T.
			EndIf

			//Caso o titulo esteja selecionado para compensação
			If lMarcado												
				lMarcado := .F.

				//Metricas
				nGravados += 1	

				If lPadrao .and. !lContabil .and. mv_par09 == 1
					nTotal 		:= 0
					lContabil 	:= .t.
					nHdlPrv   	:= HeadProva(cLote, "FINA330", Substr( cUsuario, 7, 6 ), @cArquivo )
				EndIf

				dbSelectArea("SE1")
				dbGoTo(aRecNo[nTit])
				
 				If __lMotRet .And. ( ( nValTot + Iif(lIrPjBxCr .And. __lIrfMR, Fa330VTit( aTitulos[nTit,nPosIrf] ), 0) + Iif( lPccBxCR , (nPis + nCofins + nCsll), 0) < nSaldo ) .Or. ( SE1->E1_SALDO < nSaldo ) ) .And. Len( aAuxTitMR ) >= 5
					//Calcula os impostos pelo motor de retenções
					__lTCnfgMR := F330VldImp()

					If __lTCnfgMR
						F330CalImp( aAuxTitMR[1], aAuxTitMR[2], aAuxTitMR[3], aAuxTitMR[4], Fa330VTit( aTitulos[nTit,7] ) + Iif( !__lImpEmis, __nImpMR, 0 )+ Iif( lPccBxCR , (nPis + nCofins + nCsll),0) + Iif(lIrPjBxCr .And. __lIrfMR, Fa330VTit( aTitulos[nTit,nPosIrf] ), 0), dDataBase, SE1->E1_TIPO )
						__lTCnfgMR := .F.
					EndIf 
				EndIf
				
				aAdd(aRegSE1, aRecNo[nTit])
				cAdiantamento := SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_LOJA)
				
				If (nTotCsAbt + nTotPisAbt + nTotCofAbt) # 0 .AND. MV_PAR08 == 2
					If (SE1->E1_TIPO == MV_CRNEG) .and. (SE1->E1_SALDO > aTitulos[nTit,9]) .AND. ((aTitulos[nTit,9]+nTotAbtIni) == F330SldPri(nRecNo))
						//Se o abatimento for composto por algo alem do PCC por ex. um AB-
						If Str(nTotAbtIni,17,2) # Str((nTotCsAbt + nTotPisAbt + nTotCofAbt),17,2)
							//Somar apenas o abatimento a ser desconsiderado (PCC) na compensacao
							aTitulos[nTit,9] := aTitulos[nTit,9] + (nTotCsAbt + nTotPisAbt + nTotCofAbt)
						Else
							//Somar todo o abatimento (formado pelo PCC)
							aTitulos[nTit,9] := aTitulos[nTit,9] + nTotAbtIni
						Endif
					EndIf
				Endif
				
				//--------------------------------------
				// Valor da baixa na moeda 1
				//--------------------------------------
				If cPaisLoc == "BRA"

					nValRec := aTitulos[nTit,9]

					If !__lBq10925 .and. __nMarcs == 1 
						//Baixa liquida - Recomponho a base para cálculo final do imposto
						nTotImp := xMoeda(nPis + nCofins + nCsll + IiF(lIrPjBxCr,nIrrf,0), 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
						lBxTotal := (nSldTitIni == nValRec + nTotImp)
						If lCredito .or. ( !lCredito .and. !lRarTimp .and. (l330Auto .or. lBxTotal .or. (Fa330VTit(aTitulos[nTit,9]) != nValor)) ) 
							aTitulos[nTit,9] := nValRec + nTotImp
						ElseIf !lCredito .and. lRarTimp 
							aTitulos[nTit,9] := nValRec + nTotImpbx
						Endif
					EndIf

					nValBx := aTitulos[nTit,9]
					
					If mv_par02 == 1
						nAcresc := Fa330VTit(aTitulos[nTit,10])
						nDecres := Fa330VTit(aTitulos[nTit,11])
					Else
						nAcresc := Fa330VTit(aTitulos[nTit,13])
						nDecres := Fa330VTit(aTitulos[nTit,14])
					EndIf

				Else
					nValBx := Fa330VTit(aTitulos[nTit,7])

					If cPaisLoc != "RUS"
						If mv_par02 == 1
							nAcresc := Fa330VTit(aTitulos[nTit,11])
							nDecres := Fa330VTit(aTitulos[nTit,12])
						Else
							nAcresc := Fa330VTit(aTitulos[nTit,13])
							nDecres := Fa330VTit(aTitulos[nTit,14])
						EndIf
					EndIf						
				EndIf
				
				If lPadrao
					nVlrCmpAux := nValorComp
					If cPaisLoc == "BRA"
						If __nSldConv > 0 .And. (Fa330VTit(aTitulos[nTit,6]) - aTitulos[nTit,9]) == 0.01
							If ( (nValorComp + Round(NoRound(xMoeda(Fa330VTit(aTitulos[nTit,6]),nMoeda,1,,3,Fa330Tx2(nMoeda,nTxMoeda)),3),2)) - NoRound(nCntCent,2) ) == __nSldConv
								nValBX := Fa330VTit(aTitulos[nTit,6])
							EndIf
							nValorComp 	+= Round(Round(NoRound(xMoeda(nValBX,nMoeda,1,,3,Fa330Tx2(nMoeda,nTxMoeda)),3),2) - nCntCent, 2 )
						Else
							nValorComp 	+= Round(NoRound(xMoeda(nValBX,nMoeda,1,,3,Fa330Tx2(nMoeda,nTxMoeda)),3),2)
							nCntCent	+= nValBX - NoRound(nValBX,2)
						EndIf
					Else
						nValorComp += xMoeda(nValBX,nMoeda,1,aTitulos[nTit,10],,Fa330Tx2(nMoeda,nTxMoeda))
					EndIf
				EndIf
				
				If lCredito
					nAbatNf := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE,,SE1->E1_FILIAL)
				EndIf

				nIrrfParc 	:= 0
				If cPaisLoc == "BRA"
					If dDatabase >= dLastPcc
						//Pega o Vlr recebido do tit correto.
						nValRec		:= Fa330VTit( aTitulos[ nTit , 9 ] )
						nValRec		:= If(__lDizPer .Or. Decimal(nValRec) > 0, FVlDiz(nValRec, nTit, @nValBx), nValRec )
						If ( !lRartImp .And. !lRaRtImpMR ) .And. MV_PAR08 == 1 .And. ( ( ( !__lPccMR .And. ( aPcc[2] == 0 .Or. aPcc[2] == Nil ) ) .Or. ( __lPccMR .And. __nPisCaMR == 0) ) .Or. ( SE1->E1_TIPO == MVRECANT .And. SE1->E1_SALDO < nValRec ) )
		  					nRecTit	:= recno()		  					
		  					If nRecTit == Iif(mv_par02 == 1,aTitulos[nTit][20],aTitulos[nTit][23]) .and.;
		  						Iif(mv_par02 == 1,Val(StrTran(aTitulos[nTit][14],",",".")),Val(StrTran(aTitulos[nTit][17],",","."))) <> 0
								If (nValRec + SE1->(E1_PIS+SE1->E1_COFINS+SE1->E1_CSLL) + IiF(lIrPjBxCr,nIrrf,0) + nAbatNf == SE1->E1_VALOR ) .or. ;
									(nValRec + nPis + nCofins + nCsll + IiF(lIrPjBxCr,nIrrf,0) + nAbatNf + __nImpMR == SE1->E1_SALDO) .or. ;
									(nValRec == Val(StrTran(StrTran(aTitulos[nTit][25],".", ""),",",".")))// Baixa Total - (Sem BX parciais)
			  						If ValType(aTitulos[nTit,nPosPis]) == "C"
									  	If FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)
											nBasePCC 	:= FBaseImp(nValRec)
											aPcc		:= newMinPcc(dBaixa,nBasePCC,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
											If Len(aPcc) > 4
												__aTitCalc := aPcc[5]
											EndIf
											If mv_par02 == 1
												nPis		:= Val(StrTran(StrTran(aTitulos[nTit][14],".", ""),",","."))		  				
												nCofins		:= Val(StrTran(StrTran(aTitulos[nTit][15],".", ""),",","."))
												nCsll		:= Val(StrTran(StrTran(aTitulos[nTit][16],".", ""),",","."))
											Else
												nPis		:= Val(StrTran(StrTran(aTitulos[nTit][17],".", ""),",","."))		  				
												nCofins		:= Val(StrTran(StrTran(aTitulos[nTit][18],".", ""),",","."))
												nCsll		:= Val(StrTran(StrTran(aTitulos[nTit][19],".", ""),",","."))
											EndIf
										EndIf							
									Else
										nPis		:= 	aTitulos[nTit][14]
										nCofins		:=	aTitulos[nTit][15]
										nCsll		:=  aTitulos[nTit][16]
									EndIf
								ElseIf !__lPccMR .And. FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)
									nValRec := xMoeda(nValRec, nMoeda, 1, dDataBase, __nCasDec, __nTxMoedP, 0)
									nBasePCC 	:= FBaseImp(nValRec)
									aPcc		:= newMinPcc(dBaixa,nBasePCC,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
									nPis		:= aPcc[2]
									nCofins		:= aPcc[3]
									nCsll		:= aPcc[4]
									If Len(aPcc) > 4 
										__aTitCalc := aPcc[5]
									EndIf
								EndIf
							Else
								nVTit := 0
								For nX:=1 to Len(aTitulos) // verifica todos os títulos ja marcados
									If aTitulos[nX,8] 
										nVTit += Fa330VTit(aTitulos[nX,7])
									EndIf
								Next
								aAreaParc	:= GetArea()
								dbGoto(nRecno)
								If !lCredito									
									nAltVal := FbaseImp(aTitulos[nTit,9])
									If !__lPccMR

										If !Empty(SE1->E1_NUMBOR)
											lRetImp:= VLDBOR(SE1->E1_NUMBOR,"R")
										EndIf
										
										nTotalTit 	+= nValBx

										If lRetImp .And. lPccBxCr
											aPcc		:= newMinPcc(dBaixa,nAltVal,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
											nPis		:= aPcc[2]
											nCofins		:= aPcc[3]
											nCsll		:= aPcc[4]
										EndIf
									EndIf
								ElseIf lPccBxCr .And. lCredito .And. ( ( !__lPccMR .and. !lRartimp ) .Or. ( __lPccMR .And. !__lRarTPcc) ) 
									If !__lPccMR
										aPcc		:= newMinPcc(dBaixa,nValRec,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
										nPis		:= 	aPcc[2]
										nCofins		:=	aPcc[3]
										nCsll		:=  aPcc[4]
									EndIf
									nValBx 		:= aTitulos[nTit,9] -= ( nPis + nCofins + nCsll )								
								EndIf
								If Len(aPcc) > 4
									__aTitCalc := aPcc[5]
								EndIf
								RestArea(aAreaParc)
							EndIf
							
							If !lIrPjBxCr
								nIrrf := SE1->E1_IRRF
							EndIf
						
							If !__lBq10925	//Baixa liquida
								nValRec := nValRec - nPis - nCofins - nCsll - IiF(lIrPjBxCr,nIrrf,0)
							Endif							
							
							If nMoeda > 1
								nValRec := xMoeda(nValRec, SE1->E1_MOEDA, nMoeda, dDataBase, __nCasDec, IIF(SE1->E1_MOEDA > 1,__nTxMoedD,0), __nTxMoedP)
							EndIf
						ElseIf ( !lRartImp .And. !lRaRtImpMR ) .And. MV_PAR08 == 1 .And. SE1->E1_TIPO $ MVRECANT							
							aAreaParc := GetArea()
							dbGoto( nRecno )
							If !SE1->E1_TIPO $  MVRECANT + "|" + MV_CRNEG 
								
								nValImpAux := 0
								nValImpAux += Iif( !lPccBxCr, 0, SE1->(E1_PIS + E1_COFINS + SE1->E1_CSLL) )
								nValImpAux += Iif( !lIrPjBxCr, 0, SE1->E1_IRRF )
								nValImpAux += Iif( !lCalcIssBx, 0, SE1->E1_ISS )
								nValImpAux += SE1->E1_INSS
								If __lMotRet .And. Len(aDadosRA1) > 12 //Recupera o valor do imposto do configurador de tributos
									nValImpAux += aDadosRA1[13][1]
								EndIf
								nValTitAux := SE1->E1_VALOR - nValImpAux - nTotAbtIni
								
								If nVtit == nValTitAux .And. ( nTotalTit + aTitulos[nTit,9] ) == nValTitAux
									nAltVal := SE1->E1_VALOR - nTotalTit //se os titulos ja marcados + o titulo do momento for igual o liquido, deve calcular pelo restante do saldo.
								ElseIf nPosIr > 0
									nAltVal	:= Iif(MV_PAR08==1,(nValTot+ Iif(!lIrPjBxCr,0,aImpIR[nPosIr][1])+aImpPcc[1]+aImpPcc[2]+aImpPcc[3]+nTotAbtIni) + SE1->E1_DECRESC ,aTitulos[nTit,9])
								Else
									nAltVal	:= Iif( MV_PAR08==1, ( nValTot + aImpPcc[1] + aImpPcc[2] + aImpPcc[3] + nTotAbtIni ), aTitulos[nTit,9] )
								EndIf
																
								nTotalTit += nValBx
								If ( SE1->E1_SALDO - ( nValRec + nPis + nCofins + nCsll + Iif( lIrPjBxCr, 0, SE1->E1_IRRF ) + If( lCalcIssBx, 0, SE1->E1_ISS ) + SE1->E1_INSS + ValorMR() )) <> 0 
									If lPccBxCr .And. nAltVal > nValBx .And. nValBx < nSaldo .And. ( nParciais == 0 .Or. NoRound( Abs( nSaldo - nValBx ) , 2 ) <> 0.01 )
										nAltVal := Iif( nValRec > nValBx , nValRec , nValBx )
									ElseIf lPccBxCr .And. nParciais > 0 .And. ( nValBx == nSaldo .Or. NoRound( Abs( nSaldo - nValBx ) , 2 ) == 0.01 )
										nAltVal := SE1->E1_VALOR - nParciais
									EndIf
									If !__lPccMR

										//nAltVal = valor cheio
										If !lJurMulDes // se não considera retira o acrescimo
											nAltVal -= SE1->E1_SDACRES	
										Else //se considera, retira o decrecimo
											nAltVal -= SE1->E1_SDDECRE
										EndIf

										If !Empty(SE1->E1_NUMBOR)
											lRetImp:= VLDBOR(SE1->E1_NUMBOR,"R")
										EndIf

										If lRetImp .And. FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)
										
											If SE1->E1_VLCRUZ > SE1->E1_BASEIRF
												aPcc     := newMinPcc( dBaixa, FBaseRPCC(nAltVal), SE1->E1_NATUREZ , "R" , SE1->E1_CLIENTE + SE1->E1_LOJA )
											Else
												aPcc     := newMinPcc( dBaixa, nAltVal, SE1->E1_NATUREZ , "R" , SE1->E1_CLIENTE + SE1->E1_LOJA )
											EndIf

											nPis     := aPcc[2]
											nCofins  := aPcc[3]
											nCsll    := aPcc[4]
											If Len(aPcc) > 4 
												__aTitCalc := aPcc[5]
											EndIf
										ElseIf nPis + nCofins + nCsll > 0
											nPis 	:= 0
											nCofins := 0
											nCsll 	:= 0
										EndIf
									EndIf
								EndIf
							EndIf
							RestArea(aAreaParc)
							If !lIrPjBxCr
								nIrrf := SE1->E1_IRRF
							EndIf
						ElseIf !__lPccMR .and. lPccBxCr .And. !lRartimp
							if lCredito
								If FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)
									if lAutomato
										nValRec 	:= FBaseImp(nValRec)
										aPcc		:= newMinPcc(dBaixa,nValRec,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
										nPis		:= 	aPcc[2]
										nCofins		:=	aPcc[3]
										nCsll		:=  aPcc[4]
										If Len(aPcc) > 4 
											__aTitCalc := aPcc[5]
										EndIf
									endif
								EndIf
								nValBx 		:= aTitulos[nTit,9]
							else
								aAreaParc	:= GetArea()
								dbGoto(nRecno)								
								nAltVal := FbaseImp(aTitulos[nTit,9])
									If !Empty(SE1->E1_NUMBOR)
										lRetImp:= VLDBOR(SE1->E1_NUMBOR,"R")
									EndIf										
									//nTotalTit 	+= nValBx
									If lRetImp .And. lPccBxCr
										aPcc		:= newMinPcc(dBaixa,nAltVal,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
										nPis		:= aPcc[2]
										nCofins		:= aPcc[3]
										nCsll		:= aPcc[4]
									EndIf
								If Len(aPcc) > 4
									__aTitCalc := aPcc[5]
								EndIf
								RestArea(aAreaParc)
							endIf
						EndIf
					Else
						If !__lPccMR
							//Se for RA
							If !lCredito .And. !lRartImp .And. nValRec <> nOldValRec .And. aDadosret[1] <= nVlMinImp .And. (nValRec + aDadosret[1]) <= nVlMinImp .And. nValPis > 0
								nPis		:= (nValPis * (nValrec/ SE1->E1_VALOR))
								nCofins		:= (nValCofins * (nValrec/ SE1->E1_VALOR))
								nCsll		:= (nValCsll * (nValrec/ SE1->E1_VALOR))
							ElseIf !lCredito .And. !lRartImp .And. nValRec <> nOldValRec .And. (nValRec + aDadosret[1]) > nVlMinImp .And. nValPis > 0
								nPis		:= aDadosRet[2] + (nValPis * (nValrec/nValorNf)) //SE1->E1_VALOR))
								nCofins		:= aDadosRet[3] + (nValCofins * (nValrec/nValorNf))// SE1->E1_VALOR))
								nCsll		:= aDadosRet[4] + (nValCsll * (nValrec/nValorNf))// SE1->E1_VALOR))
							EndIf
						
							//Se for NF				
							If lCredito .and. !lRartImp .AND. aDadosret[1] <= nVlMinImp .and. (nValRec + aDadosret[1]) <= nVlMinImp
								If nValRec + nAbatNf == nOldValRec
									nPis		:= (SE1->E1_PIS * ((nValrec + nAbatNf)/ SE1->E1_VALOR))
									nCofins		:= (SE1->E1_COFINS * ((nValrec + nAbatNf)/ SE1->E1_VALOR))
									nCsll		:= (SE1->E1_CSLL * ((nValrec + nAbatNf)/ SE1->E1_VALOR))
								Else
									nPis		:= (SE1->E1_PIS * (nValrec/ SE1->E1_VALOR))
									nCofins		:= (SE1->E1_COFINS * (nValrec/ SE1->E1_VALOR))
									nCsll		:= (SE1->E1_CSLL * (nValrec/ SE1->E1_VALOR))
								EndIf
							ElseIf 	lCredito .and. !lRartImp .and. lPccBxCr .and. mv_par08 == 1 .and. aDadosret[1] <= nVlMinImp .and. aDadosret[1] + nValRec > nVlMinImp .and. SE1->E1_SALDO <> nValRec +nAbatNf + nPis + nCofins + nCsll
								nPis		:= aDadosRet[2] + nPis
								nCofins		:= aDadosRet[3] + nCofins
								nCsll		:= aDadosRet[4] + nCsll
							ElseIf lCredito .and. !lRaRtImp .and. mv_par08 == 1 .and. lPccBxCr .and. nPis+nCofins+nCsll+nIrrf > 0 .AND. aDadosret[1] > nVlMinImp .and. SE1->E1_SALDO <> SE1->E1_VALOR .and. nValPis > 0
								If (mv_par02 == 2 .AND. AllTrim(atitulos[1][7]) == Alltrim(atitulos[1][25])) .or. (mv_par02 == 1 .AND. nPisFin061 == 0 .and. AllTrim(atitulos[1][7]) == Alltrim(atitulos[1][22])) 
									nPis		:= (nValPis * (SE1->E1_SALDO/ SE1->E1_VALOR))
									nCofins		:= (nValCofins * (SE1->E1_SALDO/ SE1->E1_VALOR))
									nCsll		:= (nValCsll * (SE1->E1_SALDO/ SE1->E1_VALOR))
								EndIf
							ElseIf lCredito .and. !lRartImp .and. lPccBxCr .and. mv_par08 == 2 .and. aDadosret[1] <= nVlMinImp .and. aDadosret[1] + nValRec > nVlMinImp .and. SE1->E1_SALDO <> nValRec +nAbatNf + nPis + nCofins + nCsll
								nPis		:= aDadosRet[2] + (SE1->E1_PIS * (nValrec/ SE1->E1_VALOR))
								nCofins		:= aDadosRet[3] + (SE1->E1_COFINS * (nValrec/ SE1->E1_VALOR))
								nCsll		:= aDadosRet[4] + (SE1->E1_CSLL * (nValrec/ SE1->E1_VALOR))
							ElseIf lCredito .and. !lRartImp .and. lPccBxCr .and. mv_par08 == 2 .and. aDadosret[1] > nVlMinImp .and. SE1->E1_SALDO <> nValRec +nAbatNf + nPis + nCofins + nCsll
								nPis		:= (SE1->E1_PIS * (nValrec/ SE1->E1_VALOR))
								nCofins		:= (SE1->E1_COFINS * (nValrec/ SE1->E1_VALOR))
								nCsll		:= (SE1->E1_CSLL * (nValrec/ SE1->E1_VALOR))
							EndIf
						EndIf
					EndIf
				EndIf
								
				//Definindo o conteudo que sera gravado no campo E1_TITPAI do abatimento, caso exista e a baixa seja integral
				If !lCredito
					cDadosTitulo := cPrefixo + cNum + cParcela + cTipoOr + cCliente + cLoja
				Else
					cDadosTitulo := SE1->(E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO + E1_CLIENTE + E1_LOJA)
				Endif
					
				dbSelectArea("SE1")
				SE1->(dbGoTo(nRecNo))
				
				//Guardo dados do titulo principal para utilizar no historico da contabilizaÆo
				STRLCTPAD := SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO

				//Valor da Baixa na moeda do titulo principal
				If cPaisLoc == "BRA"
					nValBX2 := aTitulos[nTit,9]					
					__nTxMoedD := iif(__lRaTxMov ,aTitulos[nTit][len(aTitulos[nTit])], atxmoedas[SE1->E1_MOEDA][2] )
					If lPccBxCr .And. nValor <> nSaldo .And. nPis > 0 .And. ( !lRaRtImp .And. !lRaRtImpMR ) .And. mv_par08 == 1  .And.;
						(nValBx2 + (nPis + nCofins + nCsll) + nIrrf <> Iif(MV_PAR02==1, aTitulos[nTit,21], aTitulos[nTit][24]) .Or.;
						(nValBx2 + nAbatNf == Iif(MV_PAR02==1, aTitulos[nTit][21], aTitulos[nTit][24])))

						nValBx	:= nValBx2
						
						If nSaldo - aTitulos[nTit,9] - nPis - nCofins - nCsll - Iif( lIrPjBxCr, nIrrf, nAbatNf ) == 0
							nValBx2 := aTitulos[nTit,9]
							nValBx	:= nValBx2
						ElseIf nValor - nIrrf == nValBx
							nValBx2 := aTitulos[nTit,9]
							nValBx	:= nValBx2
						EndIf
					Endif
					
					If mv_par02 == 1
						nAcresc := Fa330VTit(aTitulos[nTit,10])
						nDecres := Fa330VTit(aTitulos[nTit,11])
					Else
						nAcresc := Fa330VTit(aTitulos[nTit,13])
						nDecres := Fa330VTit(aTitulos[nTit,14])
					EndIf
					
					If lCredito
						VALOR7 :=  nDecres
						VALOR8 :=  nAcresc
					Endif

					If mv_par08 == 1 .And. ( !lRaRtImp .And. !lRaRtImpMR ) .and. !lCredito
						nTotAbat := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE,,SE1->E1_FILIAL)
					Else
						nTotAbat := 0
					Endif

					nPropPcc	:=	nRegRa	:=	0
										
					//PCC Baixa CR
				   	If lCredito .And. lPccBxCr .And. ( lRaRtImp .Or. lRaRtImpMR ) 
						nPis 	:= Fa330VTit(aTitulos[nTit,nPosPis])
						nCofins := Fa330VTit(aTitulos[nTit,nPosCof])
						nCsll 	:= Fa330VTit(aTitulos[nTit,nPosCsl])
					Endif
				Else
					nValBx2 := Fa330VTit(aTitulos[nTit,7])
					If lCredito .and. cPaisLoc != "RUS"
						If mv_par02 == 1
							nAcresc := Fa330VTit(aTitulos[nTit,11])
							nDecres := Fa330VTit(aTitulos[nTit,12])
						Else
							nAcresc := Fa330VTit(aTitulos[nTit,13])
							nDecres := Fa330VTit(aTitulos[nTit,14])
						EndIf
					EndIf
				EndIf

				nValIrf	:= nIrrf				
					
				//Efetiva gravacao da compensacao SE1/SE5
				If lCredito .And. ( !lRaRtImp .And. !lRaRtImpMR )
					
					If lIrPjBxCr .And. Len(aImpIr) >= 1
					  	nPosIr := aScan( aImpIR, {|x| x[2] = aTitulos[nTit,nReg330]} )    
					  	If nPosIr > 0 .And. aImpIR[nPosIr][1] > 0
					  		nIrrf := aImpIR[nPosIr][1]
							nVlTotConv := xMoeda(nValTot, SE1->E1_MOEDA, nMoeda, dDataBase, __nCasDec, IIF(SE1->E1_MOEDA > 1,__nTxMoedD,0), __nTxMoedP)
							FCaIrBxCR(Iif(MV_PAR08==1,(nVlTotConv+aImpIR[nPosIr][1]+aImpPcc[1]+aImpPcc[2]+aImpPcc[3]+nTotAbtIni),nVlTotConv), nRecTit)
						ElseIf Len(aImpIr) > 1 .And. nTit <= len(aImpIr) .And. nPosIr > 0 .And. !__lIrfMR
							nIrrf 	:= FReCalIRB( aImpIr, If(lAutomato,nValRec,nValBx2), nPosIr, lAutomato )
						EndIf
					Else
						nIrrf := 0
					EndIf
					
					If cPaisLoc == "BRA" .And. !__lIrfMR .And. MV_PAR08 == 1
						If MV_PAR02 <> 2
							nValComp := xMoeda(aTitulos[nTit,9], nMoeda, 1, dDataBase, __nCasDec, __nTxMoedP, 0)
							nValImp  := xMoeda(( nPis + nCofins + nCsll + nIrrf ), 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
							nImpCalc := xMoeda(( nPisCalc + nCofCalc + nCslCalc + nIrrf ), 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)

							If Val(StrTran(StrTran(aTitulos[nTit,22],".",""),",",".")) != aTitulos[nTit,9]  + nValImp .And. ;
								Val(StrTran(StrTran(aTitulos[nTit,22],".",""),",",".")) != aTitulos[nTit,9]  + nImpCalc
								
								nPropIr :=  nValComp/ aTitulos[nTit,(nPos-1)]
							Else
								nPropIr := 1
							EndIf
						Else
							nPropIr := nValComp / aTitulos[nTit,24]
						EndIf
						If !lCredito					
							nIrrf := nIrrf * nPropIr					
						EndIf
					EndIf					
					ntotIrbx := nIrrf
					
				ElseIf lIrPjBxCr .And. Len(aImpIr) >= 1 .And. ( !lRaRtImp .And. !lRaRtImpMR )
					
					If !__lIrfMR

						If !Empty(SE1->E1_NUMBOR)
							lRetImp:= VLDBOR(SE1->E1_NUMBOR,"R")
						EndIf

						nPosIr := aScan(aImpIR,{|x| x[2]=SE1->(REcno())})
						If nPosIr > 0  
							If lPccBxCr .And. nValTot == SE1->E1_SALDO
								If lRetImp
						   	 		nIrrf := FReCalIRB(aImpIr,Iif(MV_PAR08==1,(nValTot+aImpIR[nPosIr][1]+aImpPcc[1]+aImpPcc[2]+aImpPcc[3]+nTotAbtIni),nValTot),nPosIr, lAutomato)
								EndIf
						  	Elseif lPccBxCr .and. nSaldo == nValTot
						  		nIrrf := FReCalIRB(aImpIr,Iif(MV_PAR08==1,(nValTot+aImpIR[nPosIr][1]+aImpPcc[1]+aImpPcc[2]+aImpPcc[3]+nTotAbtIni),nValTot),nPosIr, lAutomato)
						  	Elseif nSaldo == nValTot
						  		nIrrf := FReCalIRB(aImpIr,Iif(MV_PAR08==1,(nValTot+aImpIR[nPosIr][1]+nTotAbtIni),nValTot),nPosIr, lAutomato)
						  	Else //indica que o valor foi digitado
						  		nIrrf := FReCalIRB(aImpIr,nValTot,nPosIr, lAutomato)
						  	EndIF
					  	EndIf				   	
				   	EndIf
				   	ntotIrbx := nIrrf
				   	
				Else
				   
					If lIrPjBxCr .And. !(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG )
						If !__lIrfMR
							If SE1->E1_IRRF > 0
								nIrrf := FCaIrBxCR(SE1->E1_SALDO)
							EndIf
						EndIf
						
						ntotIrbx := nIrrf
					Else
						nAbatNf := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE,,SE1->E1_FILIAL)
				  	 	nIrrf 	:= 0
						ntotIrbx := 0
					EndIf
				
			  	EndIf
			  				  	
				If ( !__lPccMR .And. aPcc[1] ) .And. ( !lIrPjBxCr .And. nValIrf <> nIrrf )
					nIrrf	:= nValIrf
				EndIf
				
				If cPaisLoc != "RUS" .And. ( lRartImp .Or. lRaRtImpMR ) .And. lPccBxCr .And. !lNcc
				   nPis		:= Fa330VTit(aTitulos[nTit,nPosPis])
				   nCofins	:= Fa330VTit(aTitulos[nTit,nPosCof])
				   nCsll	:= Fa330VTit(aTitulos[nTit,nPosCsl])
				   nIrrf	:= Fa330VTit(aTitulos[nTit,nPosIrf])
				   nIss	 	:= aDadosRA1[10,nTit]
				   nInss	:= aDadosRA1[11,nTit]
				   If __lMotRet .And. !Empty(aDadosRA1[12])
				   		aAdd(aDadosRA1[12,nTit], {__nImpMR})
				   EndIf
				EndIf

				If ( !lRartImp .And. !lRaRtImpMR ) .And. lPccBxCr .And. !lCredito .And. aImpPcc[1] <> nPis .And. MV_PAR08==2
					aImpPcc [1] := nPis
					aImpPcc [2] := nCofins
					aImpPcc [3] := nCsll
				EndIf
								
				If !(cPaisLoc $ "RUS|EUA|BRA") .And. lCredito .And. !lNCC
					nPisBaseR 	:= Fa330VTit(aTitulos[nTit,nPosBPCR])
					nPisBaseC 	:= Fa330VTit(aTitulos[nTit,nPosBPCC])
					nCofBaseR 	:= Fa330VTit(aTitulos[nTit,nPosBPCR])
					nCofBaseC 	:= Fa330VTit(aTitulos[nTit,nPosBPCC])
					nCslBaseR 	:= Fa330VTit(aTitulos[nTit,nPosBPCR])
					nCslBaseC 	:= Fa330VTit(aTitulos[nTit,nPosBPCC])
					nIrfBase	:= Fa330VTit(aTitulos[nTit,nPosBIRF])
					If nPis > 0 .And. nPisBaseR == 0
						nPisCalc	:= nPis
						nPisBaseC	:= nValBx+nPis+nCofins+nCsll
						nPisBaseR 	:= nPisBaseC
						nCofCalc	:= nCofins	
						nCofBaseC	:= nPisBaseC
						nCofBaseR 	:= nPisBaseC
						nCslCalc	:= nCsll	
						nCslBaseC	:= nPisBaseC
						nCslBaseR 	:= nPisBaseC
					EndIf
				EndIf

				nValorAux 	:= Iif( cPaisLoc == "BRA" .And. lCredito .And. aTitulos[nTit,9] < aTitulos[nTit,(nPos - 1)], nValBx, nValBx2 ) //Valor a compensar
				nVlAuxConv	:= Round(xMoeda(nValorAux,nMoeda,1,,nDecs1+1,__nTxMoedP),2) //Valor a compensar convertido para a moeda forte
				nSldPosCmp  := ABS( __nSldConv - ( nVlAuxConv + nVlrCmpAux ) ) //__nSldConv = Valor do titulo de partida - vlr a compensar acumulado (convertido na moeda forte)
				
				If nSldPosCmp <= If(nMoeda > 1 .And. nMVToler == 0, nToler, nMVToler) //Verifica se o saldo do titulo de partida ficará igual ou menor a margem de tolerancia (MV_TOLERPG)
					If ( nVlAuxConv + nToler ) <= Round(xMoeda(Fa330VTit(aTitulos[nTit,6]),nMoeda,1,,nDecs1+1,__nTxMoedP),2)  //Verifica se é compensacao parcial
						nValorAux := xMoeda((__nSldConv - nVlrCmpAux),1,nMoeda,,nDecs1+1,,__nTxMoedP) //Ajusta valor a compensar com o decimal correto
					EndIf
				EndIf
				cSeqAux := StrZero( nSeq, nTamSeq )				
					
				nIssAux  := 0
				nInssAux := 0
					
				If (lRaRtImp .Or. lRaRtImpMR)
					nIssAux := nIss
					nInssAux := nInss
				EndIf
				lNccAux	:= aTitulos[nTit,4] $ MV_CRNEG .Or. lNcc
				
				Fa330Grv( lPadrao, nValorAux, cAdiantamento, cSeqAux, aRecNo[nTit], @aBaixas, cOrigem, lCredito, mv_par09, @nAcresc, @nDecres, aBaixaSE5, ;
				          nTotAbtIni, aImpPcc, @cSequencia, cDadosTitulo, nIrrf, ntotIrbx, nIssAux, nInssAux, lNccAux, nDescP, nDescD, @nIrrfParc, nOldValRec, nValVa, @nRegSe5Ori)
	
				If lVldSEQ
					Help( ,,"FANXTSEQBX",,STR0122, 1, 0,,,,,, { STR0123 }  ) //"O sequencial para o campo E5_SEQ chegou ao seu limite de tamanho. Esta compensação será abortada." #  "Necessario aumentar o tamanho do campo E5_SEQ"
					DisarmTransaction()
					Return .F.
				EndIf
											
				//Acerta o saldo do título, somente para compensações parciais
				lRetMinAux := ( ( !__lPccMR .And. aDadosRet[1] + nValRec > nVlMinImp ) .Or. ( __lPccMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR > 0 ) )
				If !lCredito .And. ( !lRaRtImp .And. !lRaRtImpMR ) .And. MV_PAR08 == 1 .And. SE1->E1_TIPO <> MV_CRNEG .And. SE1->E1_TIPO <> MVRECANT
					If lPccBxCr .And. ( nPis + nCofins + nCsll > 0 ) .And. ( SE1->E1_SALDO - ( nPis + nCofins + nCsll ) > 0 )
						lRetMinAux := ( ( !__lPccMR .And. aDadosret[1] <= nVlMinImp .And. aDadosRet[1] + nValRec > nVlMinImp ) .Or. ( __lPccMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR > 0 ) )
						If lRetMinAux .And. nValRec == nOldValRec .And. nValrec == nValBx						     
							Reclock("SE1")
							SE1->E1_SALDO -= nPis + nCofins + nCsll
							MsUnlock()
						EndIf
					EndIf
				ElseIf lCredito .And. ( !lRaRtImp .And. !lRaRtImpMR ) .And. MV_PAR08 == 1 .And. SE1->E1_TIPO <> MV_CRNEG .And. lRetMinAux
					If lPccBxCr .And. ( nPis + nCofins + nCsll > 0 ) .And. nValRec + nPis + nCofins + nCsll + nAbatRa <> nSldNF .And. !lPropBx
						If SE1->E1_SALDO <> 0
							If nAbatNf > 0 .And. SE1->E1_SALDO - nAbatNf == 0
								Reclock("SE1")
								SE1->E1_SALDO -= SE1->E1_SALDO
								MsUnlock()
							EndIf							
						EndIf
					EndIf
				EndIf
				
				If SE1->E1_SALDO == 0
					nValorNf	:= 0
				EndIf
								
				If lCredito .And. ( lRartImp .And. lRaRtImpMR ) .And. nIrrf > 0 .And. lIrPjBxCr .And. SE1->E1_SALDO > 0 //lRartImp, indica que já houve a retenção no RA, não deve calcular novamente!
					SE1->E1_SALDO -= nIrrf
				EndIf
				
				If lPropBx .And. !lCredito  .And. ((SE1->E1_SALDO > 0 .And. mv_par08 == 1) .Or. mv_par08 == 2)					
					If lRartImp .Or. lRaRtImpMR
						nImp := SE1->E1_PIS + SE1->E1_COFINS + SE1->E1_CSLL + SE1->E1_IRRF + SE1->E1_INSS + SE1->E1_ISS
						nVal := (SE1->E1_VALOR * nValRec) / (SE1->E1_VALOR - nImp)
					Else
						nVal := nValRec
					EndIf
					
					aImp := FpropCR(SE1->E1_VALOR, SE1->E1_PIS, SE1->E1_COFINS, SE1->E1_CSLL, SE1->E1_IRRF, SE1->E1_INSS, SE1->E1_ISS, nVal)					
					If ( !lRartImp .And. !lRaRtImpMR )
						SE1->E1_VALLIQ -= ( aImp[1][1] + aImp[1][2] + aImp[1][3] + aImp[1][4] + aImp[1][5] + aImp[1][6] ) //NF
						If lPccBxCr
							SE1->E1_VALLIQ -= (nPis+nCofins+nCsll)
						EndIf
						If lIrPjBxCr
							SE1->E1_VALLIQ -= (nIrrf)
						EndIf
					EndIf
				ElseIf lPropBx .And. mv_par08 = 1 .And. !lCredito .And. SE1->E1_SALDO == 0
					lSaldoNf	:= .F.
				EndIf
				aAlt := {}				
				aadd( aAlt,{ STR0080,'','','',STR0081 + Alltrim(Transform(nValBx2,cPicE5Val)) })   
				///chamada da Função que cria o Histórico de Cobrança
				cFilOld := cFilAnt
				cFilAnt := SE1->E1_FILORIG
				FinaCONC(aAlt)
				cFilAnt	:= cFilOld

				//Atualiza o status do titulo no SERASA
				If cPaisLoc == "BRA"
					If !(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG)
						If SE1->E1_SALDO <= 0
							cChaveTit := SE1->E1_FILIAL + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
							cChaveFK7 := FINGRVFK7("SE1",cChaveTit,SE1->E1_FILORIG)
							F770BxRen("1","CMP1",cChaveFK7,,SE1->E1_FILORIG)
						Endif
					Endif
				Endif

				For nX:= 1 To len(aBaixas)
					If aBaixas[nX][1][4] $ MVRECANT + "/" + MV_CRNEG
						nRecnoRA := aBaixas[nX][1][3]
						lCompRa	:= .T.
					EndIf
					If lUsaFlag
						aAdd( aFlagCTB, {"E5_LA", "S", "SE5", aBaixas[nX][1][3], 0, 0, 0} )
					EndIf
				Next nX

				// Posiciona no adiantamento para contabilização
				dbSelectArea("SE1")
				dbGoTo(aRecNo[nTit])
				
				If mv_par08 == 1 .And. ( !lRaRtImp .And. !lRaRtImpMR ) .and. lCredito
					nTotAbat := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE,,SE1->E1_FILIAL)
				Else
					nTotAbat := 0
				Endif
				
				If lPropBx .And. lCredito .And. SE1->E1_SALDO > 0
					nImp	:= SE1->E1_PIS + SE1->E1_COFINS + SE1->E1_CSLL + SE1->E1_IRRF + SE1->E1_INSS + SE1->E1_ISS
					nVal	:= (SE1->E1_VALOR * nValor)/(SE1->E1_VALOR - nImp)					
					If nVal <> SE1->E1_SALDO .And. ( !lRartImp .And. !lRaRtImpMR )
						nVal := nValor
						lSaldoNf := .F.
					EndIf					
					aImp := FpropCR(SE1->E1_VALOR, SE1->E1_PIS, SE1->E1_COFINS, SE1->E1_CSLL, SE1->E1_IRRF, SE1->E1_INSS, SE1->E1_ISS, nVal)					
					If !lSaldoNf .And. ( ( !lRartImp .And. !lRaRtImpMR ) .And. mv_par08 == 1)
						SE5->E5_VALOR -= ( aImp[1][1] + aImp[1][2] + aImp[1][3] + aImp[1][4] + aImp[1][5] + aImp[1][6] )
						If lPccBxCr
							SE5->E5_VALOR -= (nPis+nCofins+nCsll)
						EndIf
						If lIrPjBxCr
							SE5->E5_VALOR -= (nIrrf)
						EndIf
					EndIf
				EndIf
				
				//---------------------------------------------
				//Acerta o saldo do titulo de destino
				//---------------------------------------------
				Reclock("SE1")
					
				If cPaisLoc == "BRA"
                    SE1->E1_DESCONT := nDescD
					If nValBx == Fa330VTit(aTitulos[nTit,6]) .Or. ABS(nValBx - Fa330VTit(aTitulos[nTit,6])) <= If(nMoeda > 1 .And. nMVToler == 0, nToler, nMVToler)
						SE1->E1_SALDO := 0
						SE1->E1_SDACRES := 0
						SE1->E1_SDDECRE := 0

						If !lCredito .And. ( !lRartImp .And. !lRaRtImpMR ) .and. !__lBq10925
							If lPccBxCr
								SE1->E1_SALDO += nPis + nCofins + nCsll
							Endif
							If lIrPjBxCr
								SE1->E1_SALDO += nTotIrbx
							Endif
							If !__lImpEmis
								SE1->E1_SALDO += __nImpMR
							Endif
						Endif
					Else
						//Na Compensacao de RA para NF posso ter impostos gerados e devem ser abatidos no valor do SALDO.
						If SE1->E1_TIPO = 'NF ' .AND. lCompRa .and. !lNcc
							nTotAbat += (nPis + nCofins + nCsll+ Iif(!lIrPjBxCr,0,nTotIrBx) + Iif( !__lImpEmis, __nImpMR, 0 ) )
						Endif
						//Valor do VA para ajuste do saldo
						nValVa := Fa330VTit(aTitulos[nTit,nPosVa])
						// Verifica se o titulo já possui impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
						nPisFin061	:=	0
						nCofFin061	:=	0
						nCslFin061	:=	0
						nIrfFin061	:=	0
						nRegSE5	:=	SE5->(Recno())
						nOrdSE5	:=	SE5->(IndexOrd())		
						If lPccBxCr .And. lIrPjBxCr 
							dbSelectArea("SE5")
							SE5->(dbSetOrder(2)) //FILIAL + TIPODOC + PREFIXO + NUMERO + PARCELA + TIPO
							If SE5->(DBSeek(xFilial("SE5")+"BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
								While !SE5->(Eof()) .and. SE5->E5_FILIAL==xFilial("SE5") .And. ;
									SE5->E5_TIPODOC+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO=="BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO		
								
									If  ("FINA061" $ Subst(SE5->E5_HISTOR,1,7) .Or. "FINA891" $ Subst(SE5->E5_HISTOR,1,7)) .And. SE5->E5_MOTBX $ "PCC_IRF"						
										If Alltrim(SE5->E5_MOTBX) == "PCC"
										   nPisFin061	+= SE5->E5_VRETPIS
										   nCofFin061	+=	SE5->E5_VRETCOF
										   nCslFin061	+= SE5->E5_VRETCSL
										ElseIf Alltrim(SE5->E5_MOTBX) == "IRF"
										   nIrfFin061	+= SE5->E5_VRETIRF
										EndIf
									EndIf				
									SE5->(DbSkip())		
							   Enddo
							EndIf
						Endif
						SE5->(Dbgoto(nRegSE5))
						SE5->(Dbsetorder(nOrdSE5))										
						
						If ( nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061 ) > 0 .And. mv_par08 = 2 .And. SE1->E1_TIPO <> MV_CRNEG .And. SE1->E1_TIPO <> MVRECANT 
						 	SE1->E1_SALDO	+=	( nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061 )
						Else
							nPisFin061	:=	0
							nCofFin061	:=	0
							nCslFin061	:=	0
							nIrfFin061	:=	0
						EndIf

						If SE1->E1_DECRESC >0 .OR. SE1->E1_ACRESC >0
							If SE1->E1_SDACRES >= nValBx
								SE1->E1_SDACRES -= nValBx
							Else
								SE1->E1_SALDO 	-= Round(Noround(xMoeda(nValBx-nAcresc+nDecres-nValVa+nDescD,nMoeda,SE1->E1_MOEDA,,3,Fa330Tx2(nMoeda,nTxMoeda),Fa330Tx2(SE1->E1_MOEDA,SE1->E1_TXMOEDA)),3),2)
								SE1->E1_SDACRES	-= Round(Noround(xMoeda(nAcresc               ,nMoeda,SE1->E1_MOEDA,,3,Fa330Tx2(nMoeda,nTxMoeda),Fa330Tx2(SE1->E1_MOEDA,SE1->E1_TXMOEDA)),3),2)
							EndIf
							SE1->E1_SDDECRE	-= Round(Noround(xMoeda(nDecres               ,nMoeda,SE1->E1_MOEDA,,3,Fa330Tx2(nMoeda,nTxMoeda),Fa330Tx2(SE1->E1_MOEDA,SE1->E1_TXMOEDA)),3),2)
						Else							
							lRetMinAux := ( ( !__lPccMR .And. aDadosret[1] < nVlMinImp .And. aDadosRet[1] + nValor > nVlMinImp ) .Or. ( __lPccMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR > 0 ) )
							If lPccBxCr .And. ( !lRaRtImp .And. !lRaRtImpMR ) .And. lRetMinAux .And. lCredito .And. !lPropBx
								If nTotAbat > 0
									SE1->E1_SALDO	-= Round(Noround(xMoeda(nValBx+nTotAbat-nValVa,nMoeda,SE1->E1_MOEDA,,3,Fa330Tx2(nMoeda,nTxMoeda),Fa330Tx2(SE1->E1_MOEDA,SE1->E1_TXMOEDA)),3),2)
								Else
									SE1->E1_SALDO	-= Round(Noround(xMoeda(nValBx+nPis+nCofins+nCsll+nIrrf+nIss+nTotAbat-nValVa,nMoeda,SE1->E1_MOEDA,,3,Fa330Tx2(nMoeda,nTxMoeda),Fa330Tx2(SE1->E1_MOEDA,SE1->E1_TXMOEDA)),3),2)
								EndIf
							Else
								SE1->E1_SALDO	-= SE5->E5_VALOR + nDescD - nValVa //E5_VALOR é gravado com a moeda do título na compensação
						    EndIf
						EndIf
					EndIf
					SE1->E1_VALLIQ := Iif(SE1->E1_MOEDA ==  VAL(SE5->E5_MOEDA), SE5->E5_VALOR, SE5->E5_VLMOED2)
					If STR(SE1->E1_SALDO,17,2) == STR(nTotAbat,17,2)
						SE1->E1_SALDO := 0
					EndIf
					SE1->E1_MOVIMEN:= dDatabase
										
					If lPropBx .And. ( !lRartImp .And. !lRaRtImpMR ) .And. !lCredito 
						If  lSaldoNf
							If mv_par08 == 1
								SE1->E1_SALDO += (aImp[1][1]+aImp[1][2]+aImp[1][3]+aImp[1][4]+aImp[1][5]+aImp[1][6])
							EndIf
							SE1->E1_VALLIQ -= (aImp[1][1]+aImp[1][2]+aImp[1][3]+aImp[1][4]+aImp[1][5]+aImp[1][6]) //RA
							If lPccBxCr
								SE1->E1_VALLIQ -= (nPis+nCofins+nCsll)
							EndIf
							If lIrPjBxCr
								SE1->E1_VALLIQ -= (nIrrf)
							EndIf
						EndIf
					EndIf
										
					If lPropBx .And. ((mv_par08 == 1 .And. ( !lRartImp .And. !lRaRtImpMR )) .Or. ( lRartImp .Or. lRaRtImpMR ) ) .And. lCredito
						If !(SE1->E1_VALLIQ == SE5->E5_VALOR)
							SE1->E1_VALLIQ -= (aImp[1][1]+aImp[1][2]+aImp[1][3]+aImp[1][4]+aImp[1][5]+aImp[1][6])
							If lPccBxCr
								SE1->E1_VALLIQ -= (nPis+nCofins+nCsll)
							EndIf
							If lIrPjBxCr
								SE1->E1_VALLIQ -= (nIrrf)
							EndIf
						EndIf						
						If lSaldoNf
							SE1->E1_SALDO -= (aImp[1][1]+aImp[1][2]+aImp[1][3]+aImp[1][4]+aImp[1][5]+aImp[1][6])
							If lPccBxCr
								SE1->E1_SALDO -= (nPis+nCofins+nCsll)
							EndIf
							If lIrPjBxCr
								SE1->E1_SALDO -= (nIrrf)
							EndIf
						EndIf
					EndIf
										
					//PCC Baixa CR
					If nMoeda == 1 .Or. SE1->E1_MOEDA == 1
						lRetMinAux := ( ( !__lPccMR .And. aDadosret[1] <= nVlMinImp .And. aDadosRet[1] + nValRec > nVlMinImp ) .Or. ( __lPccMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR > 0 ) ) 
						If lCredito .And. lPccBxCr .And. SE1->E1_SALDO > 0 .And. lRetMinAux
							If ( nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061 ) == 0 								
								lRetMinAux := ( ( !__lPccMR .And. aDadosret[1] <= nVlMinImp ) .Or. ( __lPccMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR > 0 ) ) 
								If lRetMinAux .And. ( ( ( !lRaRtImp .And. !lRaRtImpMR ) .And. mv_par08 == 1 .And. !__lBq10925 ) .Or. ( ( lRartimp .Or. lRaRtImpMR ) .And. mv_par08==1 ) )
									If nValRec + nPis + nCofins + nCsll + nIrrf >= nValBx + If (__lBq10925, nPis + nCofins + nCsll + nIrrf, 0 )
										SE1->E1_SALDO -= ( nPis + nCofins + nCsll + nIrrf )
									Else
										SE1->E1_SALDO += nPis + nCofins + nCsll
									EndIf
								ElseIf ( !lRaRtImp .And. !lRaRtImpMR ) .And. mv_par08 == 1 .And. __lBq10925 .And. !lNCC
									SE1->E1_SALDO -= ( nPis + nCofins + nCsll ) + Iif(!lIrPjBxCr,0,nTotIrBx) + Iif( !__lImpEmis, __nImpMR, 0 )
									If SE1->E1_SALDO < 0
										SE1->E1_SALDO := 0
									EndIf
									If !lIrPjBxCr .And. (SE1->E1_SALDO - nIrrf == 0 .Or. SE1->E1_SALDO - nIrrf == 0.01) //problemas de arredondamento 
										SE1->E1_SALDO -= nIrrf
										If nIrrf > 0
											SE1->E1_SALDO := Iif(SE1->E1_SALDO = 0.01,0,SE1->E1_SALDO)
										EndIf
									EndIf
									If	nAbatNf > 0 .And. (SE1->E1_SALDO - nAbatNf) == 0
										SE1->E1_SALDO -= nAbatNf
									EndIf
								ElseIf ( ( !__lPccMR .And. aDadosret[1] <= nVlMinImp ) .Or. ( __lPccMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR > 0 ) ) .And. ( lRartimp .Or. lRaRtImpMR )
									SE1->E1_SALDO -= nPis + nCofins + nCsll								
									SE1->E1_SALDO -= nIss + nInss										
									If lIrPjBxCr
										SE1->E1_SALDO -= nIrrf
									EndIf
								Endif
							Endif						
						ElseIf !lCredito .And. lPccBxCr .And. SE1->E1_SALDO > 0 .And. lRetMinAux	
							If ( nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061 ) == 0
								If nPis + nCofins + nCsll > 0 .And. nValorNf <> 0 .And. ( !lRaRtImp .And. !lRaRtImpMR ) .And. mv_par08 == 1
									SE1->E1_SALDO += ( nPis + nCofins + nCsll )
								Endif
								If nPis + nCofins + nCsll > 0 .And. ( !lRartImp .And. !lRaRtImpMR ) .And. mv_par08 == 1 .And. !SE1->E1_TIPO $ MV_CRNEG   
									If !lIrPjBxCr .And. nAbatNf > 0 .And. (SE1->E1_SALDO - nAbatNf) == 0
										SE1->E1_SALDO -= nAbatNf
									EndIf
								ElseIf nPis + nCofins + nCsll > 0 .And. ( !lRartImp .And. !lRaRtImpMR ) .And. mv_par08 == 2
									SE1->E1_SALDO += ( nPis + nCofins + nCsll )
									If lIrPjBxCr
										SE1->E1_SALDO += nIrrf
									ElseIf nAbatNf > 0 .And. nOldValRec == nValRec
										SE1->E1_SALDO += nAbatNf
									EndIf
								EndIf								
								If ( lRaRtImp .Or. lRaRtImpMR ) .And. !lPropBx 
									SE1->E1_SALDO -= ( nIss + nInss )
								EndIf	
							EndIf						
						ElseIf !lCredito .And. ( !lRaRtImp .And. !lRaRtImpMR ) .And. MV_PAR08 == 2 .And. ( nPis + nCofins + nCsll > 0 ) .And. !lPropBx .And. !SE1->E1_TIPO $ MV_CRNEG  
							If lIrPjBxCr
								SE1->E1_SALDO += nIrrf
							ElseIf SE1->E1_SALDO - nPis - nCofins - nCsll == 0
								SE1->E1_SALDO += nAbatNf
							EndIf
						EndIf
					EndIf
				Else
					If nValBx == Fa330VTit(aTitulos[nTit,6])
						SE1->E1_SALDO := 0
						SE1->E1_SDACRES := 0
						SE1->E1_SDDECRE := 0
					Else
						nDecs := MsDecimais(SE1->E1_MOEDA)
						nSalTit := SE1->E1_SALDO - Round(xMoeda(nValBx-nAcresc+nDecres,nMoeda,SE1->E1_MOEDA,dDatabase,nDecs+1,aTxMoedas[nMoeda][2],aTxMoedas[SE1->E1_MOEDA][2]),nDecs)
						SE1->E1_SALDO := Iif(nSalTit <= 0,0,nSalTit)
					EndIf
					SE1->E1_MOVIMEN := dDatabase
					SE1->E1_VALLIQ  += nValBx
				EndIf
								
				SE1->E1_BAIXA := dBaixa
				SE1->E1_STATUS:= IIF(SE1->E1_STATUS != "R",Iif(SE1->E1_SALDO > 0.01,"A","B"),"R")
				If cPaisLoc == "EUA" .And. SE1->(ColumnPos("E1_SLPLAID")) > 0
					SE1->E1_SLPLAID := SE1->E1_SALDO
				EndIf
				MsUnlock()
				nSE1Rec := SE1->(Recno())
				cKeyAbt := SE1->(E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA)
				cTipo:= SE1->E1_TIPO
				xFilSE1  := SE1->E1_FILIAL
				// Efetua a baixa dos titulos de abatimento
				If lCredito .AND. SE1->E1_SALDO - nTotAbat <= 0   //Se nao for titulo de adiantamento
					//atualiza status do adiantamento de viagem
					If (ALLTRIM(SE1->E1_ORIGEM) == "FINA677")
						FINATURES(SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA),.T.,SE1->E1_ORIGEM,"R")
					Endif
					If Select("__SE1") == 0
						SumAbatRec("","","",1,"")
					Endif
					dbSelectArea("__SE1")
					__SE1->(dbSetOrder(2))
					__SE1->(dbSeek(xFilSE1+cKeyAbt))
					If lTitpaiSE1
				 		If (nOrdTitPai:= OrdTitpai()) > 0
	   						DbSetOrder(nOrdTitPai)
							If	DbSeek(xFilSE1+Subs(cAdiantamento,1,nTamTit+nTamTip)+__SE1->E1_CLIENTE+__SE1->E1_LOJA)
								bWhile := {|| !Eof() .And. E1_FILIAL + ALLTRIM(E1_TITPAI) == xFilSE1 + Alltrim(Subs(cAdiantamento,1,nTamTit+nTamTip)+__SE1->E1_CLIENTE+__SE1->E1_LOJA)}
							Else
						   		__SE1->(dbSetOrder(2))
								__SE1->(dbSeek(xFilSE1+cKeyAbt))
							Endif
						Endif
					Endif

					While Eval(bWhile)
						If lTitpaiSE1
							If (  alltrim(E1_TITPAI)!=Alltrim(Subs(cAdiantamento,1,nTamTit+nTamTip)+__SE1->E1_CLIENTE+__SE1->E1_LOJA )) .and. !Empty(E1_TITPAI)
								DbSkip()
								Loop
							EndIf
						EndIf
							 IF E1_TIPO $ MVABATIM+"/"+MVIRABT+"/"+MVINABT+"/"+MVPIABT+"/"+ MVCFABT+"/"+MVCSABT

								RecLock("__SE1")
								If !lPropBx 
								Replace E1_SALDO	With 0
								Else
									Do Case
										Case E1_TIPO $ MVPIABT .and. !lPccBxCr
											Replace E1_SALDO	With (E1_SALDO - aImp[1][1])
										Case E1_TIPO $ MVCFABT .and. !lPccBxCr
											Replace E1_SALDO	With (E1_SALDO - aImp[1][2])
										Case E1_TIPO $ MVCSABT .and. !lPccBxCr
											Replace E1_SALDO	With (E1_SALDO - aImp[1][3])
										Case E1_TIPO $ MVIRABT .and. !lIrPjBxCr
											Replace E1_SALDO	With (E1_SALDO - aImp[1][4]) 
										Case E1_TIPO $ MVINABT 				
											Replace E1_SALDO	With (E1_SALDO - aImp[1][5])
										Case E1_TIPO $ MVISABT   				
											Replace E1_SALDO	With (E1_SALDO - aImp[1][6])	
									EndCase
								EndIf
								Replace E1_BAIXA	With If(E1_BAIXA <= dBaixa, dBaixa, E1_BAIXA)
								Replace E1_STATUS  With "B"
								Replace E1_MOVIMEN With dDataBase
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³Gravar o titulo que baixou o AB- para evitar estornos de ³
								//³abatimentos baixados por outras rotinas. Evita que um AB-³
								//³baixado pelo FINA070 / 110 seja estornado indevidamente  ³
								//³pelo FINA330, que gera erro na composicao do saldo do    ³
								//³titulo principal com abatimento.                         ³
								//³Gravar SEMPRE NCC/RA para identificar a baixa do AB-     ³
								//³pela rotina FINA330										³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If !Empty(cDadostitulo)
									If Empty(E1_TITPAI)
										Replace E1_TITPAI	With cDadosTitulo
									EndIf
								Else
									Replace E1_TITPAI	With ""
								EndIf

								MsUnlock()
							EndIf
						dbSkip()
					EndDo
					__SE1->(dbSetOrder(1))
				EndIf
				dbSelectArea("SE1")
				SE1->(dbGoto(nSE1Rec))

				// Integração SIGAPFS x SIGAFIN
				// Quando a compensação for posicionada no RA deve executar por aqui
				If lRet .And. FindFunction("JGrvBaixa")
					lRet := JGrvBaixa(SE1->(Recno()), SE5->(Recno()), nRecno)
				EndIf
				
				//Atualiza o status do titulo no SERASA
				If cPaisLoc == "BRA"
					If !(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG)
						If SE1->E1_SALDO <= 0
							cChaveTit := SE1->E1_FILIAL + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
							cChaveFK7 := FINGRVFK7("SE1",cChaveTit,SE1->E1_FILORIG)
							F770BxRen("1","CMP1",cChaveFK7,,SE1->E1_FILORIG)
						EndIf
					EndIf
				EndIf
								
				VALOR2 := 0
				VALOR3 := 0
				VALOR4 := 0
				VALOR5 := 0
				VALOR6 := 0
				ABATIMENTO  := 0

				If lPropBx .And. lCredito .And. cPaisLoc == "BRA"
					If !lPccBxCr
						SE5->E5_VRETPIS	:= aImp[1][1]
						SE5->E5_VRETCOF	:= aImp[1][2]
						SE5->E5_VRETCSL	:= aImp[1][3]
					EndIf
					If !lIrPjBxCr
						SE5->E5_VRETIRF	:= aImp[1][4]
					EndIf
					SE5->E5_VRETINS	:= aImp[1][5]
					SE5->E5_VRETISS	:= aImp[1][6]
				EndIf
				If lCredito .And. !lPropBx
					If cPaisLoc == "BRA" .And. lPccBxCr
						If EMPTY(SE5->E5_PRETPIS)
							VALOR3 := SE5->E5_VRETPIS
						EndIf
						If EMPTY(SE5->E5_PRETCOF)
							VALOR4 := SE5->E5_VRETCOF
						EndIf
						If EMPTY(SE5->E5_PRETCSL)
							VALOR5 := SE5->E5_VRETCSL
						EndIf
					EndIf

					If 	lIrPjBxCr
						VALOR2 := SE5->E5_VRETIRF
					EndIf  

					dbSelectArea("SE1")
					dbGoto(nSE1Rec)
				EndIf
				
				If SE5->E5_TIPODOC == "CM" .And. SE1->E1_MOEDA > 1 //Posicionar SE5 caso registro posicionado seja de correção monetária					
					Variacao := SE5->E5_VALOR
					dbSelectArea("SE5")
					DbSetOrder(2)
					//E5_FILIAL+E5_TIPODOC+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+DtoS(E5_DATA)+E5_CLIFOR+E5_LOJA+E5_SEQ
					dBSeek(xFilial("SE5")+IiF(lCredito,"CP","BA")+ SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO + DTOS(dBaixa)+ SE1->E1_CLIENTE + SE1->E1_LOJA )
				Else
					Variacao := Iif( SE5->E5_TIPODOC == 'BA' , SE5->E5_VLCORRE, nValCorCM)
				EndIf 

				If lCredito .and. SE1->E1_SALDO == 0
					ABATIMENTO := nTotAbat
				Endif

				If lPadrao .and. mv_par09 == 1

					If __l330VA .And. !lCredito .And. nValVaTitP <> 0 
						//Posiciono no registro
						SE1->(dbGoTo(nRecNo))
						nRecSE5Ant := SE5->(Recno())
						SE5->(dbGoto(nRegSE5Ori))						
						nTotal += DetProva( nHdlPrv, cPadrao, "FINA330", cLote,,,,,,,, @aFlagCTB, {"SE5",nRecnoRA} )
						SE1->(dbGoTo(nSE1Rec))
						SE5->(dbGoto(nRecSe5Ant))						
					Else
						nTotal += DetProva( nHdlPrv, cPadrao, "FINA330", cLote,,,,,,,, @aFlagCTB, {"SE5",nRecnoRA} )
					EndIf
				EndIf

				VALOR2 := 0
				VALOR3 := 0
				VALOR4 := 0
				VALOR5 := 0
				VALOR6 := 0
				VALOR7 := 0
				VALOR8 := 0
				Variacao := 0
				ABATIMENTO  := 0
				aPcc := {}
				aPcc := Array(4)
				nValVa	:= 0
				nValVaTitP := 0
				dbSelectArea ("SE1")
				dbSetOrder(1)

				If lfa330Bx
					Execblock("FA330BX",.f.,.f.)
				Endif
			Endif
		Next
		
		aBxInteg := aClone( aBaixas )
		
		If lF330SE5 
			ExecBlock("F330SE5",.F.,.F.,{aRecSe5})
		EndIf     						
		nRegSE5 := SE5->(Recno())
		nRegSE1 := SE1->(Recno())
		nRegFK1 := FK1->(Recno())
		
		If lComisCR .and. lComisOn
			dbSelectArea("SE1")
			dbSetOrder(2)
			dbGoto(nRecNo)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se calcula comissao sobre valores       ³
			//³ de NCC ou RA que compuseram a compencação Receb. ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If mv_par06 == 2 .Or. mv_par13 == 2
				For nLinha:= Len(aBaixas) to 1 Step -1
					lDeleted := .F.
					// Verifica se ha a 6 dimensao na matriz de valores baixados 
					If Len(aBaixas[nLinha][1]) >= 6
						If mv_par06 == 2
							If MV_CRNEG $ SubStr(aBaixas[nLinha][1][6],nTamTit+1,nTamTip)
								ADEL(aBaixas,nLinha)
								ASIZE(aBaixas,Len(aBaixas)-1)
								lDeleted := .T.
							Endif
						Endif
						If mv_par13 == 2 .And. !lDeleted
							If MVRECANT $ SubStr(aBaixas[nLinha][1][6],nTamTit+1,nTamTip)
								ADEL(aBaixas,nLinha)
								ASIZE(aBaixas,Len(aBaixas)-1)
							Endif
						Endif
					Endif
				Next
			Endif
						
			// Nunca calcular comissão sobre títulos de Crédito (NCC/RA)
			For nLinha:= Len(aBaixas) to 1 Step -1	
				If aBaixas[nLinha][1][4] $ MV_CRNEG +"\"+ MVRECANT
					ADEL(aBaixas,nLinha)
					ASIZE(aBaixas,Len(aBaixas)-1)
				EndIf
			Next
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Calcula comissao, se houver vendedor		  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Len(aBaixas) > 0
				SaveInter()
				AeVal( aBaixas, { |x| Fa440CalcB( x, lJuros, .T., "FINA330" ) } )
				RestInter()
			EndIf
		EndIf

		If cPaisLoc == "BRA"  .and. !lCredito
			//IRRF Baixa CR
			If lIrPjBxCr
				VALOR2 := nIrrf //SE5->E5_VRETIRF
			EndIf	
			//PCC Baixa CR
			If lPccBxCr
				If EMPTY(SE5->E5_PRETPIS)
					VALOR3 := nPis //SE5->E5_VRETPIS
				ENDIF
				If EMPTY(SE5->E5_PRETCOF)
					VALOR4 := nCofins//SE5->E5_VRETCOF
				EndIf	
				If EMPTY(SE5->E5_PRETCSL)				
					VALOR5 := nCsll //SE5->E5_VRETCSL
				EndIf
			EndIf	

			VALOR7  := nDecresNF
			VALOR8  := nAcrescNF

		EndIf

		If lPadrao .and. mv_par09 == 1

			SE5->(dbGoBottom())
			SE5->(dbSkip())
			SE1->(dbGoBottom())
			SE1->(dbSkip())
			FK1->(dbGoBottom())
			FK1->(dbSkip())
			VALOR := If( nValorComp <> __nTotCtb, __nTotCtb, nValorComp ) //"__nTotCtb" tem precisao de mais casas decimais que a "nValorComp"
			IF nMoeda>1
				VALORMF := xMoeda(nValorComp,1,nMoeda,,nDecs1+1,aTxMoedas[nMoeda][2],aTxMoedas[nMoeda][2])
			Endif
			Variacao := nValCorCM
			nSldReal := Round(NoRound(xMoeda(nSaldo,nMoeda,1,,3,Fa330TxMd(nMoeda,0)),3),2)

			ABATIMENTO := 0
			IF !lCredito .and. STR(nSldReal,17,2) == STR(nValorComp,17,2)
				ABATIMENTO := nAbatNf
			Endif

			REGVALOR := nRecno		// Variavel para reposicionar o registro de partida

			nTotal += DetProva( nHdlPrv, cPadrao, "FINA330",cLote,,,,,,,, @aFlagCTB,, )
			RodaProva(  nHdlPrv, nTotal )

			If UsaSeqCor()
				For nX := 1 To Len(aBaixaSE5)
					AAdd(aDiario,{"SE5",aBaixaSE5[nX],cCodDiario,"E5_NODIA","E5_DIACTB"})
				Next nX
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Envia para Lanamento Cont bil							  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			lDigita := IIF( mv_par07 == 1,.t., .f. )
			cA100Incl( cArquivo, nHdlPrv, 3, cLote, lDigita, .F.,,,, @aFlagCTB,, aDiario )
			aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

			VALORMF:= 0
			VALOR  := 0
			VALOR2 := 0
			VALOR3 := 0
			VALOR4 := 0
			VALOR5 := 0
			VALOR6 := 0
			VALOR7 := 0
			VALOR8 := 0
			REGVALOR := 0
			Variacao := 0
			ABATIMENTO := 0

		EndIf
		
		//Integração TIN x PROTHEUS
		If lEnvMU070 .And. Len( aBxInteg ) > 0 .And. !lEnvMU330 //Se o adapter de compensação estiver ativado para envio, então não manda a mensagem de baixa
			For nInt := 1 To Len( aBxInteg )
				If AllTrim( aBxInteg[nInt][1][7] ) == "FINI055"
					SE5->( dbGoTo( aBxInteg[nInt][1][3] ) )
					SE1->( dbGoTo( aBxInteg[nInt][1][8] ) )
					
					lOpcAux := ALTERA
					ALTERA := .T.					
					aRetInteg := FwIntegDef( "FINA070", , , , "FINA070" )
					ALTERA := lOpcAux
					
					//Se der erro no envio da integração, então faz rollback e apresenta mensagem em tela para o usuário
					If ValType( aRetInteg ) == "A" .And. Len( aRetInteg ) >= 2 .And. !aRetInteg[1]
						lRet := .F.
						Help( ,, "FINA330INTEGTIN",, STR0087 + AllTrim( aRetInteg[2] ), 1, 0,,,,,, {STR0088} ) //"A compensação não será concluída, pois ocorreu um erro na integração: ", "Verifique se a integração está configurada corretamente."
						DisarmTransaction()
						Exit
					Endif
					
				EndIf
			Next nInt
		EndIf
		
		If lRet
			SE5->(dbGoTo(nRegSE5))
			SE1->(dbGoTo(nRegSE1))
			FK1->(dbGoTo(nRegFK1))
	
			//integracao com modulo PCO
			Fa330IntPco(nRecno, aRegSE1, aBaixaSE5)
	
			If AllTrim(SE1->E1_TIPO) $ "RA"
				If !(Len(aAlt) > 0)
					aadd( aAlt,{ STR0080,'','','',STR0081 +  Alltrim(Transform(nValBx2,cPicE5Val)) })
				EndIf			   
				///chamada da Função que cria o Histórico de Cobrança
				cFilOld := cFilAnt
				cFilAnt := SE1->E1_FILORIG
				FinaCONC(aAlt)
				cFilAnt := cFilOld
			EndIf
		EndIf
	
		//Final  da protecao via TTS
		End Transaction
	Endif

	//Metricas - Gravação da compensação
	If __lMetric .and. nGravados > 0
		nFim := Seconds() - nInicio
		nFim := nFim / nGravados

		SetFunName(__cFunMet)
		FwCustomMetrics():setAverageMetric(Alltrim(ProcName())+" - TempoGravacao", "financeiro-protheus_tempo-conclusão-processo_seconds", nFim)
		SetFunName(__cFunBkp)
	Endif

	Exit
EndDo

If lRetorno
	cPrefixo := CriaVar("E1_PREFIXO")
	cNum	 := CriaVar("E1_NUM")
	cTipoTit := CriaVar("E1_TIPO")
	cCliente := CriaVar("E1_CLIENTE")
	cLoja 	 := CriaVar("E1_LOJA")
	cSaldo	 := CriaVar("E1_SALDO")
	nValor	 := CriaVar("E1_SALDO")
	cParcela := CriaVar("E1_PARCELA")
	nMoeda	 := 1
	nValor	 := 0
	nValTot	 := 0

	// Finaliza a gravacao dos lancamentos do SIGAPCO
	PcoFinLan("000016")

	// Recupera a Integridade dos dados
	dbSelectArea("SE1")
	dbSetOrder(nIndexAtu)
	dbGoTo(nTitIni)

	DeleteObject(oOk)
	DeleteObject(oNo)
	FA330aUnlock()
EndIf
Return lRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³ fa330Cli ³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 21/03/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Verifica validade do Cliente								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fa330Cli()												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA330													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fa330Cli( )
Local cAlias := Alias( )
dbSelectArea("SA1")
dbSeek(xFilial("SA1")+cCliente)
IF !Found()
	Help(" ",1,"A330CLI")
	Return .F.
Else
	cLoja:=Iif(Empty(cLoja),SA1->A1_LOJA,cLoja)
EndIF
dbSelectArea(cAlias)
Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³ fa330Loja³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 21/03/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Verifica validade da Loja do Cliente						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fa330Loja() 												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA330													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static FuncTion fa330Loja()
LOCAL cAlias:=Alias()
LOCAL nOrdSe1 := 0
LOCAL lRet := .T.

//PCREQ-3782 - Bloqueio por situação de cobrança
Local cLstCart := FN022LSTCB(1,'0007')	//Lista das situacoes de cobranca (Carteira)
Local cLstNoBlq := FN022LSTCB(6,'0007')	//Lista das situacoes de cobranca (Não bloqueadas para determinado processo)

If Funname() == "FINA740"
	SetKey (VK_F12)
EndIf

dbSelectArea("SA1")
dbSeek(xFilial()+cCliente+cLoja)
IF !Found()
	Help(" ",1,"A330LOJA")
	lRet := .F.
Endif
If lRet
	dbSelectArea("SE1")
	nOrdSe1 := IndexOrd()
	dbSetOrder(2)
	If dbSeek(xFilial()+cCliente+cLoja+cPrefixo+cNum+cParcela+cTipoTit)
		If mv_par05 == 2 .and. !(E1_SITUACA $ cLstCart)
			Help(" ",1,"F330CARTE")
			lRet := .F.

		//PCREQ-3782 - Bloqueio por situação de cobrança
		ElseIf !(E1_SITUACA $ cLstNoBlq)
			Help(" ",1,"F330BLOQD",,STR0079,1,0)	//"Não é possível realizar a operação pois o título se encontra em situação de cobrança que não permite manutenção ou movimento financeiro do titulo."
			lRet := .F.
		Endif
	Else
		Help(" ",1,"NOTIT")
		lRet := .F.
	Endif
	dbSetOrder(nOrdSe1)
Endif

dbSelectArea(cAlias)

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³Fa330Tit	³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 22/09/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Gera Tabela com os titulos 								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Fina330													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
STATIC Function Fa330Tit(dEmissao,cOrigem,lCredito,aNumLay,lAutomato)
//Salva a Integridade dos dados de Entrada
LOCAL cSavArea 	:= alias()
Local cAliasSE1	:= "SE1"
LOCAL lMarca	:= .T.
LOCAL lF330RIO  := ExistBlock("F330RIO")
LOCAL lF330CMP  := ExistBlock("F330CMP")
Local lFI330ALT	:= ExistBlock("FI330ALT")
LOCAL nSavOrd	:= IndexOrd()
LOCAL nRecNo	:= RecNo()
LOCAL nTotComp	:= 0
LOCAL nVlBasico := 0
Local nDecs     := MsDecimais(nMoeda)
Local bWhile    := {|| .T.}
LOCAL nRecEmp  	:= SM0->(RecNo())
LOCAL cFilDe
LOCAL cFilAte
Local cCgcClie
Local cNomClie
Local nX 		:= 0
Local nPosNumLay:= 0
Local lFa330Qry := Existblock("FA330QRY")
Local cOrdemSE1
Local lTitRAMex	:= cPaisLoc == "MEX" .And. X3Usado("ED_OPERADT") //Define se o titulo de RA esta disponivel - Manejo de Anticipo
Local lPccBxCr	:= FPccBxCr()								    	//Controla o Pis Cofins e Csll na baixa  (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default) )
Local lIrPjBxCr	:= FIrPjBxCr()									   //Controla IRPJ na baixa
Local aOldBaixaSE5
Local aBxSE5		:= {}
LOCAL nTotAdto		:= 0
Local lBaixaAbat	:= .F.
Local nVlrBaixa		:= 0
Local lBxCec		:= .F.
Local lBxLiq		:= .F.
Local x				:= 0
Local aImpPccIr		:= { SE5->E5_VRETPIS, SE5->E5_VRETCOF, SE5->E5_VRETCSL, SE5->E5_VRETIRF }
Local nSaldoNF		:= 0
Local nTotIrAbt		:= 0
Local nVlMinImp		:= GetNewPar("MV_VL10925",5000)
Local nTotCsAbt		:= 0
Local nTotPisAbt	:= 0
Local nTotCofAbt	:= 0
Local lAplVlMin		:= .T.
Local nValorPcc		:= 0
Local aCamposKey	:= {}
Local nValLim 		:= 0 //Limite de Compensacao
Local nImp          := 0 //Valor dos Imposto (proporcao)
Local nProp         := 0 //proporcao da baixa
Local nValVa		:= 0 //valor acessório

//--- Tratamento Gestao Corporativa
Local lGestao   	:= Iif( lFWCodFil, FWSizeFilial() > 2, .F. )	// Indica se usa Gestao Corporativa
//
Local cFilFwSE1 	:= IIF( lGestao, FwFilial("SE1") , xFilial("SE1") )
Local lSE1Exclusivo := .F.
Local nMoedaP		:= 1
Local nMoedaD		:= 1
Local nTaxaP		:= 0
Local nTaxaD		:= 0
Local cSep			:= IIf("|"$MV_CRNEG,"|",",")
Local lNcc			:= SE1->E1_TIPO $ MV_CRNEG 
Local lNcc2			:= .F.
//Impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
Local nPisFin061	:= 0
Local nCofFin061	:= 0
Local nCslFin061	:= 0
Local nIrfFin061	:= 0     
Local nOrdSE5		:= 0
Local nRegSE5		:= 0
Local nOrdSE1		:= 0
Local aDadRetAux	:= {}
/* GESTAO - inicio */

Local cTmpSE1Fil	:= ""
Local aTmpSE1Fil	:= {}
Local aAreaSIX		:= {}
Local aIndexPE		:= {}
Local lSE1Comp 		:= If(Empty(FWxFilial("SE1")), .T., .F.)
/* GESTAO - fim */
Local aPcc			:= Array(4)
Local aArea			:= {}
Local nValRec2		:= 0
Local nNumAT1		:= 0
Local nNumAT2		:= 0
Local nNumAT3		:= 0
Local nNumAT4		:= 0

//PCREQ-3782 - Bloqueio por situação de cobrança
Local cLstCart 		:= FN022LSTCB(1,'0007')	//Lista das situacoes de cobranca (Carteira)
Local cLstNoBlq 	:= FN022LSTCB(6,'0007')	//Lista das situacoes de cobranca (Não bloqueadas para determinado processo)

Local cQuery   		:= ""
Local cFils			:= ""
Local cAliasSA1		:= "SA1"
Local aStruQry 		:= {}
Local aAuxFil		:= {}
Local cUserKey		:= SE1->(IndexKey())
Local cSelect		:= " E1_FILIAL, E1_PREFIXO, E1_NUM, E1_PARCELA, E1_IRRF, E1_MOEDA, E1_TIPO, E1_SALDO, E1_EMISSAO, " 
Local cSelect		+= " E1_CLIENTE, E1_LOJA, E1_NOMCLI, E1_SDACRES, E1_SDDECRE, E1_HIST, E1_PIS, E1_COFINS, E1_CSLL, "
Local cSelect		+= " E1_TXMOEDA, E1_VLCRUZ, E1_BASEPIS, E1_BASECOF, E1_BASECSL, E1_VALOR, E1_FILORIG, E1_TXMDCOR, E1_NATUREZ  "
Local lExclus       := NWF->(ColumnPos("NWF_EXCLUS")) > 0 .And. SuperGetMV("MV_JURXFIN",,.F.) // Integração SIGAPFS x SIGAFIN
Local lRaRtImpMR 	:= .F.
Local aImpMRBrw 	:= PegaVarMR()
Local lIrfBxAux 	:= lIrPjBxCr
Local lPccBxAux 	:= lPccBxCr
Local lRetMinAux 	:= .F.
Local lFinLOTab		:= FindFunction("FinLOTab")
Local nPosxRet		:= 0
Local nTaxaMov      := 0
Local dDtMov		:= dDataBase
Local oModelVA		:= Nil
Local nTitSemTx		:= 0
Local aAdianta      := ProtCfgAdt()
Local bFilFIE       := Iif(aAdianta[1,4],{|| FIE_FILORI==cFilAnt .Or. Empty(FIE_FILORI)},{||.T.}) //FIE_FILOI vazio para o legado
Local lAdtPed       := .F.
Local cChaveFIE     := ''
Local cVlAux		:= ''
Local nlimite       := 0
Local nSldConv		:= 0
Local nTotAbtCon	:= 0
Local nI			:= 0
Local nPosPnt		:= 0
Local nTamFilA1		:= Len(RTrim(FwxFilial("SA1")))
Local nTamFilE1		:= Len(RTrim(FwxFilial("SE1")))
Local nTamFilED		:= Len(RTrim(FwxFilial("SED")))
Local cTamFilED		:= ""
Local nRecnoF71     := 0
Local nRecnoSE1     := 0
Local lTemImpPix    := .F.
Local lRetorno		:= .T.
Local lFirst        := .T.
Local cIdDocFK7     := ""

Default lAutomato   := .F.

cTamFilED	:= AllTrim(STR(nTamFilED))
If lFinLOTab
	cTamFilED	:= FinLOTab("SED")
EndIf

If lExclus
	lExclus := !IsInCallStack("MaIntBxCR")
EndIf

If __cRmProd == Nil
	__cRmProd		:= SuperGetMv('MV_RMORIG',, "E|U|S")
EndIf

If cPaisLoc == "RUS"
	cSelect += ",E1_F5QCODE,E1_CONUNI"
EndIf 
aCamposKey 	:= STRTOKARR(cUserKey,"+")

lRaRtImpMR 	:= ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
lPccBxCr 	:= ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxCr )
lIrPjBxCr 	:= ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrPjBxCr )

aPcc[1]	:= .F.

If ValType(nPis) <> "N"
	nPis	:= 0
EndIf

If ValType(nCofins) <> "N"
	nCofins	:= 0
EndIf

If ValType(nCsll) <> "N"
	nCsll	:= 0
EndIf

If ValType(nIrrf) <> "N"
	nIrrf	:= 0
EndIf
	
//Se o SE1 não for Compartilhado entre todas as Empresas
If !lSE1Comp
	If lGestao
		If !Empty(cFilFwSE1)
			lSE1Exclusivo := .T.
	    EndIf
	Else
		If !Empty(xFilial("SE1"))
			lSE1Exclusivo := .T.
		EndIf
	EndIf
EndIf

aPcc[1]	:= .F.
If dDataBase >= dLastPcc
	nVlMinImp	:= 0
EndIf

If MV_PAR08 == 1 .Or. ( lRaRtImp .Or. lRaRtImpMR )
	nTotAbat := If(Type("nTotAbat") != "N",SumAbatRec( SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_MOEDA, "S"  ,dBaixa,,@nTotIrAbt,@nTotCsAbt,@nTotPisAbt,@nTotCofAbt,),nTotAbat)
Else
	nTotAbat :=If(Type("nTotAbat") != "N",0,nTotAbat)
EndIf
nValComp := If(Type("nValComp") != "N",0,nValComp)

For nX := 1 to Len(aCamposKey)
	If AT("STR(",UPPER(aCamposKey[nX])) > 0
		aCamposKey[nX] := Substr(aCamposKey[nX], AT("(",aCamposKey[nX])+1, AT(",",aCamposKey[nX])-AT("(",aCamposKey[nX])-1)
	ElseIf AT("(",aCamposKey[nX]) > 0 .Or. AT(")",aCamposKey[nX]) > 0 //Removo da String potenciais chamadas de funcao
		aCamposKey[nX] := Substr(aCamposKey[nX], AT("(",aCamposKey[nX])+1, AT(")",aCamposKey[nX])-AT("(",aCamposKey[nX])-1)
	EndIf
	If !(aCamposKey[nX] $ cSelect)
		cSelect += ","+aCamposKey[nX]
	Endif
Next

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada permite alterar o indice que sera aplicado no Markbrowse ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("FA330ORD")
	nOrdSE1 := ExecBlock("FA330ORD",.F.,.F.)
	If ValType(nOrdSE1) == "N"
		aAreaSIX := SIX->(GetArea())
		If SIX->(DbSeek("SE1" + RetAsc(nOrdSE1,1,.T.))) 
			SE1->(DbSetOrder(nOrdSE1))
			aIndexPE := StrToKarr2(SE1->(IndexKey()),"+",.T.)
			If Len(aIndexPE) > 0
				For nX := 1 to Len(aIndexPE)
				
					nNumAT1	:= AT("STR(",UPPER(aIndexPE[nX]))
					nNumAT2	:= AT("(",aIndexPE[nX])
					nNumAT3 := AT(",",aIndexPE[nX])
					nNumAT4	:= AT(")",aIndexPE[nX])
				
					If nNumAT1 > 0
						aIndexPE[nX] := Substr(aIndexPE[nX], nNumAT2 + 1, nNumAT3 - nNumAT2 - 1)
					ElseIf nNumAT2 > 0 .Or. nNumAT3 > 0 
						aIndexPE[nX] := Substr(aIndexPE[nX], nNumAT2 + 1, nNumAT4 - nNumAT2 - 1)
					EndIf
					If !(aIndexPE[nX] $ cSelect)
						cSelect += "," + aIndexPE[nX]
					Endif
				Next nX
			Else
				If !l330Auto
					Help(" ",1, "FA330ORD",,STR0090,1,0) //"O retorno do Ponto de Entrada 'FA330ORD' esta incorreto. O indice do P.E. não será utilizado."
				Endif
			Endif
		Else
			If !l330Auto
				Help(" ",1, "FA330ORD",,STR0090,1,0) //"O retorno do Ponto de Entrada 'FA330ORD' esta incorreto. O indice do P.E. não será utilizado."
			Endif
		Endif
		RestArea(aAreaSIX)
	Else
		If !l330Auto
			Help(" ",1, "FA330ORD",,STR0090,1,0) //"O retorno do Ponto de Entrada 'FA330ORD' esta incorreto. O indice do P.E. não será utilizado."
		Endif
	Endif
Endif

dBaixa := If (Type("dBaixa") != "D",dDataBase,dBaixa)

//Verificar ou nao o limite de 5000 para Pis cofins Csll
// 1 = Verifica o valor minimo de retencao
// 2 = Nao verifica o valor minimo de retencao
If SE1->E1_APLVLMN == "2"
	lAplVlMin := .F.
Endif

cOrdemSE1 := SE1->(IndexKey())
SE1->(dbSetOrder(1))

If cOrigem == "COMPENSANCC"
	mv_par10 := 2
EndIf
If mv_par10 == 2
	cFilDe := cFilAnt
	cFilAte:= cFilAnt
Else
	cFilDe := mv_par11
	cFilAte:= mv_par12
Endif

dbSelectArea("SX3")
dbSetOrder(2)

MsSeek("E1_SALDO")
aadd(aStruQry,{"E1_SALDO",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})

MsSeek("E1_EMISSAO")
aadd(aStruQry,{"E1_EMISSAO",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})

MsSeek("E1_MOEDA")
aadd(aStruQry,{"E1_MOEDA",SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL})

dbSelectArea("SE1")
dbSetOrder(2)

cAliasSE1 := "QRYSE1"
cAliasSA1 := "QRYSE1"

cQuery := "SELECT DISTINCT " + cSelect + ","
cQuery += "SE1.R_E_C_N_O_ RECSE1, A1_CGC "

If lCredito
	cQuery += ", SEDBRW.ED_CALCIRF, SEDBRW.ED_CALCPIS, SEDBRW.ED_CALCCOF, SEDBRW.ED_CALCCSL FROM "
Else
	cQuery += "FROM "
EndIf

cQuery += RetSqlName("SE1") + " SE1 LEFT JOIN "
cQuery += RetSqlName("SA1") + " SA1 ON (SE1.E1_LOJA = SA1.A1_LOJA) AND (SE1.E1_CLIENTE = SA1.A1_COD) "

If nTamFilA1 == nTamFilE1
	cQuery	+= " AND SA1.A1_FILIAL = SE1.E1_FILIAL "
Else
	If nTamFilA1 == 0
		cQuery	+= " AND SA1.A1_FILIAL = ' ' "
	Else
		If lOracle
			cQuery	+= " AND RTRIM(SA1.A1_FILIAL) = SUBSTRING(SE1.E1_FILORIG,1, " + AllTrim(Str(nTamFilA1)) + ") "
		Else
			cQuery	+= " AND SA1.A1_FILIAL = SUBSTRING(SE1.E1_FILORIG,1, " + AllTrim(Str(nTamFilA1)) + ") "
		EndIf
	EndIf
EndIf

If lTitRAMex //Manejo de Anticipo - Mexico
	cQuery += " LEFT JOIN " + RetSqlName("SED") + " SED ON SE1.E1_NATUREZ = SED.ED_CODIGO "
EndIf

If lCredito
	cQuery += " LEFT JOIN " + RetSqlName("SED") + " SEDBRW ON SE1.E1_NATUREZ = SEDBRW.ED_CODIGO AND "
	If nTamFilED == 0
		cQuery += " SEDBRW.ED_FILIAL = '" + FwxFilial("SED") + "' "
	Else
		cQuery += " SEDBRW.ED_FILIAL = SUBSTRING(E1_FILORIG,1," + cTamFilED + ") "
	EndIf
	cQuery += " AND SEDBRW.D_E_L_E_T_ = ' ' "
EndIf

If lExclus // Integração SIGAPFS x SIGAFIN
	cQuery += " LEFT JOIN " + RetSqlName("NWF") + " NWF ON NWF.NWF_TITULO = SE1.E1_NUM AND SE1.E1_ORIGEM = 'JURA069' "
EndIf

cQuery += " WHERE "
If dDatabase >= dLastPcc .And. ( lRaRtImp  .Or. lRaRtImpMR ) .And. lRatFields .And. !(SE1->E1_TIPO $ MV_CRNEG) .And. lPccBxCr
	cQuery += "EXISTS "
	cQuery += "(select ED_CODIGO, ED_DESCRIC ,ED_CALCCSL , ED_CALCCOF, "
	cQuery += " ED_CALCPIS, ED_PERCCSL, ED_PERCCOF, ED_PERCPIS FROM "+RetSqlName("SED")+ " "
	cQuery += " WHERE ED_CALCCSL = 'S' AND ED_PERCCSL > 0 AND ED_CALCCOF = 'S' AND ED_PERCCOF > 0 "
	cQuery += " AND ED_CALCPIS = 'S' AND ED_PERCPIS > 0 AND D_E_L_E_T_ = ' ' ) AND "
EndIf
/* GESTAO - inicio */
//Se o SE1 for Compartilhado entre todas as Empresas
If lSE1Comp
	cQuery += "SE1.E1_FILIAL = '" + FWxFilial("SE1") + "' AND "
Else
	If Empty(aSelFil)
		If mv_par10 == 1
			aAuxFil := FWLoadSM0( , .T.)
			For nI := 1 To Len(aAuxFil)
				If aAuxFil[nI][SM0_GRPEMP] == cEmpAnt .And. aAuxFil[nI][SM0_CODFIL] >= cFilDe .And. aAuxFil[nI][SM0_CODFIL] <= cFilAte
					If aAuxFil[nI][SM0_USEROK]
						aAdd(aSelFil, aAuxFil[nI][SM0_CODFIL] )
					EndIf
				EndIf
			Next
			cFils	:= GetRngFil( aSelFil, "SE1", .T., @cTmpSE1Fil)
		EndIf
	Else
		cFils	:= GetRngFil( aSelFil, "SE1", .T., @cTmpSE1Fil)
	EndIf

	If lSE1Exclusivo
		If !Empty(aSelFil)
			cQuery += "SE1.E1_FILIAL " + cFils + " AND "
			Aadd(aTmpSE1Fil,cTmpSE1Fil)
		Else
			If mv_par10 == 2
				cQuery += "SE1.E1_FILIAL = '" + xFilial("SE1") + "' AND "  
			Else 
				cQuery += "SE1.E1_FILIAL " + cFils + " AND "  
			EndIf	
		EndIf
	Else
		If mv_par10 == 2
			cQuery += "SE1.E1_FILORIG = '" + cFilAnt + "' AND "  
		Else
			cQuery += "SE1.E1_FILIAL " + cFils  + " AND "  
		EndIf
	EndIf
EndIf
/* GESTAO - fim */

If mv_par02 == 1
	cQuery += "SE1.E1_CLIENTE = '"+cCliente+"' AND "
Else
	cQuery += "SE1.E1_CLIENTE >= '"+mv_par03+"' AND "
	cQuery += "SE1.E1_CLIENTE <= '"+mv_par04+"' AND "
EndIf
If mv_par01 == 1 .And. mv_par02 == 1
	cQuery += "SE1.E1_LOJA = '"+cLoja+"' AND "
EndIf

If ( lRaRtImp .Or. lRaRtImpMR ) .And. lRatFields .and. !(SE1->E1_TIPO $ MV_CRNEG)
	If !lCredito
		cQuery +="( ( "
	EndIf
	
	If lPccBxCr
		If !__lPccMR .Or. ( !__lPccMR .And. __lRaRtPcc )
			If lCredito
				cQuery += " SEDBRW.ED_CALCPIS = 'S' AND "
			Else
				If SE1->E1_PIS > 0
					cQuery += " E1_PIS > 0 AND "
				Else
					cQuery += " E1_PIS = 0 AND "
				EndIf
			EndIf
			If lCredito
				cQuery += " SEDBRW.ED_CALCCOF = 'S' AND "
			Else
				If SE1->E1_COFINS > 0
					cQuery += " E1_COFINS > 0 AND "
				Else
					cQuery += " E1_COFINS = 0 AND "
				EndIf
			EndIf
			If lCredito
				cQuery += " SEDBRW.ED_CALCCSL = 'S' AND "
			Else
				If SE1->E1_CSLL > 0
					cQuery += " E1_CSLL > 0 AND "
				Else
					cQuery += " E1_CSLL = 0 AND "
				EndIf
			EndIf
		EndIf
	EndIf
	
	If lIrPjBxCr
		If !__lIrfMR .Or. ( !__lIrfMR .And. __lRaRtIrf )
			If lCredito
				cQuery += " SEDBRW.ED_CALCIRF = 'S' AND "
			Else
				If SE1->E1_IRRF > 0
					cQuery += " ( E1_IRRF > 0 OR A1_RECIRRF = '1' ) AND "
				Else
					cQuery +=" E1_IRRF = 0 AND "
				EndIf
			EndIf
		EndIf
	EndIf
	
	If !lCredito .And. cPaisLoc == "BRA"
		If !__lIssMR .Or. ( !__lIssMR .And. __lRaRtIss )
			If SE1->E1_ISS>0
				cQuery += " E1_PRISS > 0 AND "
			Else
				cQuery += " E1_PRISS = 0 AND "
			EndIf
		EndIf
		If SE1->E1_INSS>0
			cQuery += " E1_PRINSS > 0 AND "
		Else
			cQuery += " E1_PRINSS = 0 AND "
		EndIf
	ElseIf cPaisLoc == "BRA"
		If !__lIssMR .Or. ( !__lIssMR .And. __lRaRtIss )
			If SE1->E1_PRISS>0
				cQuery += " E1_ISS > 0 AND "
			Else
				cQuery += " E1_ISS = 0 AND "
			EndIf
		EndIf
		If SE1->E1_PRINSS>0
			cQuery += " E1_INSS > 0 AND "
		Else
			cQuery += " E1_INSS = 0 AND "
		EndIf
	EndIf
	
	If !lCredito
		cQuery +=  " E1_TIPO IN "+ FormatIn(MVRECANT,",") + ") OR "
		cQuery +=  " E1_TIPO IN "+ FormatIn(MV_CRNEG,",") + ") AND "
	EndIf

EndIf

If mv_par05 == 2
	cQuery += " SE1.E1_SITUACA IN "+FormatIN(cLstCart,"|")+" AND "
Else
	//PCREQ-3782 - Bloqueio por situação de cobrança
	cQuery += " SE1.E1_SITUACA IN "+FormatIn(cLstNoBlq,'|')+" AND "
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Caso titulos originados pelo SIGALOJA estejam nas carteiras :  ³
//³I = Carteira Caixa Loja                                        ³
//³J = Carteira Caixa Geral                                       ³
//³Nao permitir a selecao destes titulos                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cQuery += "SE1.E1_SITUACA NOT IN ('I','J') AND "
cQuery += "SE1.E1_ORIGEM NOT IN " + FormatIN(__cRmProd, "|" ) + " AND "

If cPaisLoc <> "BRA"
	If lCredito
		cQuery += "SE1.E1_TIPO NOT IN " + FormatIn( MV_CRNEG+cSep+MVRECANT,cSep) + " AND "
	Else
		cQuery += "SE1.E1_TIPO IN " + FormatIn( MV_CRNEG+cSep+MVRECANT,cSep) + " AND "
	EndIf
Else
	If lCredito
		cQuery += "SE1.E1_TIPO NOT IN " + FormatIn( MV_CRNEG+cSep+MVRECANT+cSep+MVPROVIS,cSep) + " AND "
	Else
		If (cTipoTit $ MVRECANT .And. cTipoTit $ MV_CRNEG )
			cQuery += " (SE1.E1_TIPO NOT IN " + FormatIn(MVRECANT,",") + " OR  "
			cQuery += "SE1.E1_TIPO NOT IN " + FormatIn( MV_CRNEG,cSep) + ") AND "
		ElseIf !(cTipoTit $ MVRECANT) .And. !(cTipoTit $ MV_CRNEG )
			cQuery += " ( SE1.E1_TIPO IN " + FormatIn(MVRECANT,",") + " OR  "
			cQuery += "SE1.E1_TIPO IN " + FormatIn( MV_CRNEG,cSep) + ") AND "
		EndIf
	EndIf
EndIf
If cPaisLoc == "RUS"
	If lContrato
		cQuery += "SE1.E1_F5QCODE = '" + cNumCont + "' AND "
	ElseIf lFilterMark .Or. (!EMPTY(cTitFilt))
		cQuery += cTitFilt
	EndIf
EndIf

cQuery += "SE1.E1_TIPO NOT IN " + FormatIn(MVABATIM,"|") + " AND "
cQuery += "SE1.E1_SALDO > 0 AND "
cQuery += "SE1.E1_EMISSAO <= '"+DtoS(dDatabase)+ "' AND "
cQuery += "SE1.D_E_L_E_T_ = ' ' AND "

/* GESTAO - inicio */
If !Empty(aSelFil)
	cQuery += "SA1.A1_FILIAL " + GetRngFil( aSelFil, "SA1", .T., @cTmpSE1Fil) + " AND "
	Aadd(aTmpSE1Fil,cTmpSE1Fil)
Else
	cQuery += "SA1.A1_FILIAL = '"+ xFilial("SA1")+"' AND "
EndIf
/* GESTAO - fim */

cQuery += "SA1.D_E_L_E_T_ = ' ' "

If lTitRAMex //Manejo de Anticipo - Mexico. Tratamento para nao exibir titulo de RA provenientes de notas de adiantamento.

	/* GESTAO - inicio */
	If !Empty(aSelFil)
		cQuery += " AND SED.ED_FILIAL " + GetRngFil( aSelFil, "SED", .T., @cTmpSE1Fil)
		Aadd(aTmpSE1Fil,cTmpSE1Fil)
	Else
		cQuery += "	AND SED.ED_FILIAL = '" + XFilial("SED") + "'"
	EndIf
	/* GESTAO - fim */
	cQuery += " AND SED.D_E_L_E_T_	= '' "
	cQuery += "	AND SE1.E1_TIPO		<> '" + Substr(MVRECANT,1,3) + "'" //"RA" no Mexico
	cQuery += "	AND SE1.E1_ORIGEM	<> 'FINA087A' AND "
	cQuery += " SE1.D_E_L_E_T_ = ' ' "
	cQuery += "	AND SED.ED_OPERADT	<> '1' AND " //Operacao de adiantamento igual a SIM
	cQuery += " SE1.E1_SALDO > 0 AND "
	cQuery += " SE1.D_E_L_E_T_ = ' ' AND "
	If mv_par02 == 2
   		cQuery += "SE1.E1_CLIENTE = '"+cCliente+"'"
	Else
   		cQuery += "SE1.E1_CLIENTE >= '"+mv_par03+"' AND "
   		cQuery += "SE1.E1_CLIENTE <= '"+mv_par04+"'"
	EndIf
EndIf

If lExclus // Integração SIGAPFS x SIGAFIN
	cQuery += " AND ((NWF.NWF_EXCLUS = '2' AND NWF.D_E_L_E_T_ = ' ') OR NWF.NWF_EXCLUS IS NULL) "
EndIf

If FindFunction('FINTP02')
	cQuery += FINTP02() // retornar o filtro de bloqueio do titulo do TIN  AND E1_ORIGEM <> 'FINI055'
EndIf

cQuery += "ORDER BY " + SqlOrder(cOrdemSE1)

If lFa330Qry
	cQuery := Execblock("FA330QRY",.f.,.f.,{ cQuery }  )			// permite manipualção das query
EndIf

cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),cAliasSE1,.f.,.t.)

For nX := 1 To Len(aStruQry)
	If ( aStruQry[nX][2] <> "C" )
		TcSetField(cAliasSE1,aStruQry[nX][1],aStruQry[nX][2],aStruQry[nX][3],aStruQry[nX][4])
	EndIf
Next nX

bWhile := {|| (cAliasSE1)->(!Eof()) }

ProcRegua((cAliasSE1)->(Reccount()),STR0032 )

aTitulos 	:= {}
aRecNo 		:= {}

While .T.
	dbSelectArea(cAliasSE1)
	cFilAnt := IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL )

	nIndVld:=IndexOrd()
	nRecVld:=SE1->(Recno())
	If __l330Va
		oModelVA	:= FWLoadModel("FINA070VA")
	EndIf
	
	While Eval(bWhile)
	   	IncProc()

		If !Empty((cAliasSE1)->E1_FILORIG)
			cFilAnt := (cAliasSE1)->E1_FILORIG
		Else
			cFilAnt := (cAliasSE1)->E1_FILIAL
		EndIf

		//PONTO DE ENTRADA F330RIO Tratamento de "filtragem" de titulos de adiantamento a serem
		//considerados ou nÆo no array dos adiantamentos a serem compen sados. Retorno l¢gico
		IF lF330RIO
			If !(ExecBlock("F330RIO",.F.,.F.))
				dbSkip()
				Loop
			EndIf
		EndIf

		dbselectArea("SE1")

		SE1->( dbSetOrder( 1 ) ) //E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO
		SE1->( dbSeek( (cAliasSE1)->(E1_FILIAL) + (cAliasSE1)->(E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO) ) )
				
		dbselectArea(cAliasSE1)

		//Na finalizacao do Lay-Away, seleciona somente os titulos gerados pela emissao do mesmo - Loc. EUA|POR
		If cOrigem == "LOJA800"
		   nPosNumLay  := Ascan(aNumLay,AllTrim((cAliasSE1)->E1_NUM))
		   If nPosNumLay == 0 .And. Len(aNumLay) > 0
		       dbSkip()
			   Loop
		   EndIf
		EndIf

		nRecnoF71  := 0
		nRecnoSE1  := 0
		lTemImpPix := .F.
		
		If cPaisLoc == "BRA" .And. __lExcImpo .And. __TpGerPix .And. !__lCNABImp .And. SE1->E1_SITUACA != "0"
			nRecnoSE1 := SE1->(Recno())
			nRecnoF71 := F71Ativa(nRecnoSE1)
			
			If nRecnoF71 > 0 .And. TtBxImpPix(nRecnoSE1)
				lTemImpPix := !BorderoImp(SE1->E1_FILORIG, SE1->E1_NUMBOR, "R", SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA)
				
				If lTemImpPix
					If lFirst
						lFirst   := .F.
						lRetorno := IIf(lAutomato, __lMaTiPix, MsgTtBxPix(.T., .T., .F., .F.))
					EndIf
					
					If lAutomato .And. !lRetorno
						(cAliasSE1)->(DbSkip())
						Loop
					ElseIf lRetorno .And. ExcluiImpo(SE1->E1_FILIAL, SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA, nRecnoF71)
						lTemImpPix := .F.
						cIdDocFK7  := FINBuscaFK7(SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), "SE1", SE1->E1_FILORIG)					
						PIXCancel(SE1->E1_FILIAL, cIdDocFK7)
					EndIf
				EndIf
			EndIf
		EndIf
		
		//ANGOLA|BRASIL - Nao permitir compensar titulos de adiantamento relacionado a pedido
		If cPaisLoc $ "ANG|BRA" .And. !__lCmpM460
			FIE->(dbSetOrder(2))
			cChaveFIE := xFilial("FIE")+"R"+(cAliasSE1)->(E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)
			If FIE->(MsSeek(cChaveFIE))
				While FIE->(! Eof() .And. FIE_FILIAL+FIE_CART+FIE_FORNEC+FIE_LOJA+FIE_PREFIX+FIE_NUM+FIE_PARCEL+FIE_TIPO) == cChaveFIE
					lAdtPed := FIE->(Eval(bFilFIE))
					iF lAdtPed 
						Exit
					EndIf	
					FIE->(dbSkip())
				EndDo
				If lAdtPed
					(cAliasSE1)->(dbSkip())
					Loop
				EndIf	
			EndIf
		EndIf

		//Motor de retenções
		If __lMotRet
			ClrVarMRCl()
			//Verifica as configurações de impostos pelo motor de retenção
			__lTCnfgMR := F330VldImp()
	
			lRaRtImpMR 	:= ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
			lPccBxCr 	:= ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
			lIrPjBxCr 	:= ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
			
			//Calcula os impostos pelo motor de retenções
			If __lTCnfgMR .And. !lTemImpPix
				F330CalImp( SE1->E1_NATUREZ, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG, IIf(nSaldo > SE1->E1_SALDO, SE1->E1_SALDO, nSaldo) , dDataBase, SE1->E1_TIPO, .T. )
				__lTCnfgMR	:= .F.
			EndIf
		EndIf 
		
		nDesFin := 0
		if lCredito
			nDescD := nDesFin := getDesc(nSaldo)
		endIf

		nVlBasico 	:= IIf (nValor = 0 , nSaldo , nValor)
		nValRec		:= IIf (nValor = 0 , nSaldo , nValor)
		nOldValRec	:= nSaldo
		lMarca		:=	.F.
		
		//VA: Calcula o valor acessório
		If __l330Va
			nValVa		:= FA330VACAL(oModelVA)
		EndIf

		//Verifica RA se tem movimento no SE5 para obter a data do movimento
		If (cAliasSE1)->E1_TIPO $ MVRECANT .And. (cAliasSE1)->E1_MOEDA > 1 .And. __lRaTxMov
			aMovRA := F330MovRA(Nil, cAliasSE1, .T.)
					
			If aMovRA[1]
				dDtMov	:= aMovRA[2]
			EndIf
		Else
			dDtMov := dDatabase
		EndIf

		//Definição da taxa do movimento
		If cPaisLoc == "BRA"
			//Cenários com taxa contratada
			If (cAliasSE1)->E1_MOEDA != 1 
				If !Empty((cAliasSE1)->E1_TXMOEDA)	// Verifica se existe taxa contratada
					If __lTxConP .And. __lCmTxCon	//Verifica se o título da partida possui taxa contratada e se gera variação
						If !(cAliasSE1)->E1_TIPO $  MVRECANT + "|" + MV_CRNEG
							nTaxaMov := __nTxMoedP
						Else
							nTaxaMov := (cAliasSE1)->E1_TXMOEDA
						EndIf
					Else
						If !lFa330Qry .And. !Empty((cAliasSE1)->E1_TXMDCOR) .And. !__lCmTxCon 	//Se já sofreu variação(FINA350) e nao gera vairiação a taxa utilizada é a da variação
							nTaxaMov := (cAliasSE1)->E1_TXMDCOR
						Else
							nTaxaMov := Fa330Tx2((cAliasSE1)->E1_MOEDA,(cAliasSE1)->E1_TXMOEDA)
						Endif
					EndIf
				Else
					If __lTxMoed .And. ((!lCredito .And. !__lRaTxMov) .Or. lCredito) // Se o título de partida não é adiantamento (lCredito) e não utiliza a taxa do movimento, pego a taxa digitada
						nTaxaMov := aTxMoedas[(cAliasSE1)->E1_MOEDA][2]
					Else
						nTaxaMov := RecMoeda(dDtMov, (cAliasSE1)->E1_MOEDA)
					EndIf
				EndIf
					
			ElseIf __lTxConP 	//Verifica se o título da partida possui taxa contratada
				nTaxaMov := __nTxMoedP
			Else
				If __lRaTxMov
					nTaxaMov := RecMoeda(dDtMov, nMoeda) //obs pegando por padrão a taxa do dia do movimento
				Else
					nTaxaMov := __nTxMoedP 
				Endif
			EndIf

			If (cAliasSE1)->E1_MOEDA != 1 .And. Empty(nTaxaMov) //Não lista títulos sem conseguir defifinir sua taxa
				nTitSemTx ++
				(cAliasSE1)->(DbSkip())
				Loop
			EndIf

		EndIf

		If ( nVlBasico > nTotComp .or. nTotComp == 0 )  .And. Fa330Lock(Nil, (cAliasSE1)->RECSE1, .F.) .and.  !((cAliasSE1)->E1_TIPO $ MV_CRNEG) 
	    	lMarca  := !lTemImpPix		// marca para verso WIN
			nValPre := IIF (nTotComp == 0 , nVlBasico, nVlBasico - nTotComp)
			
			If cPaisLoc == "BRA"				
				If (mv_par08 == 1 .Or. ( ( lRaRtImp .Or. lRaRtImpMR ) .And. !lNcc)) .And. !((cAliasSE1)->E1_TIPO $ MVRECANT+"/"+MV_CRNEG )
					nTotCsAbt	:= 0
					nTotPisAbt	:= 0
					nTotCofAbt	:= 0
					nTotIrAbt	:= 0
					nTotAbat 	:= SumAbatRec((cAliasSE1)->E1_PREFIXO,(cAliasSE1)->E1_NUM,(cAliasSE1)->E1_PARCELA,(cAliasSE1)->E1_MOEDA,"S",dBaixa,,@nTotIrAbt,@nTotCsAbt,@nTotPisAbt,@nTotCofAbt)

					If lIrPjBxCr
                    	If lCredito .And. (cAliasSE1)->E1_IRRF > 0 .And. !lNcc
							If __lIrfMR
								nIrrf := __nIrfCaMR
							Else
								aArea := SE1->(GetArea())
								If !( SE1->E1_TIPO $ MVRECANT )
									SE1->(DbGoTo(nRecno))
								EndIf
								nIrrf := IIf(!lTemImpPix, FCaIrBxCR(SE1->E1_SALDO), nIrrf)
								RestArea(aArea)
			  				EndIf
			  				
			  				If (nPosIr := ascan( aImpIR, {|x| x[2] = SE1->(REcno())} ) ) = 0
				  		 		aAdd(aImpIR,{nIrrf,SE1->(Recno())})
				  		 		nPosIr := Len( aImpIR )
			   				Else
				  				aImpIR[nPosIr][1] := nIrrf
			   				EndIf
						EndIf
					EndIf
										
					//Se PCC Baixa CR e nao houver abatimento de impostos
					If cPaisLoc == "BRA" .And. !lAutomato .And. ( lPccBxCR .And. ( !lRartimp .And. !lRaRtImpMR ) .And. ( nTotCsAbt + nTotPisAbt + nTotCofAbt == 0 ) ) .Or. ;
					( ( lRartimp .Or. lRaRtImpMR ) .And. (cAliasSE1)->(E1_PIS + E1_CSLL + E1_COFINS) == 0 )
						//Se PCC Baixa CR e a compensação partiu de um adiantamento
						//Os titulos nao serao pre-selecionados.
						//Isto se da para que a cada titulo marcado, seja realizado o cálculo do PCC
						lMarca := .F.
					EndIf
				Else					
					If lIrPjBxCr .And. !((cAliasSE1)->E1_TIPO $ MVRECANT+"/"+MV_CRNEG )
                    	If lCredito .And. (cAliasSE1)->E1_IRRF > 0
							If __lIrfMR
								nIrrf := __nIrfCaMR
							Else
								nIrrf := IIf(!lTemImpPix, FCaIrBxCR(SE1->E1_SALDO), nIrrf)
							EndIf
							
							If ( nPosIr := ascan( aImpIR, {|x| x[2]=SE1->(REcno())} ) ) = 0
					  			aAdd(aImpIR,{nIrrf,SE1->(Recno())})
					  			nPosIr := Len( aImpIR )
				   			Else
					  			aImpIR[nPosIr][1] := nIrrf
			   				EndIf
						EndIf
	     			Else
	     		   		nTotAbat := 0
					EndIf
				EndIf
								
				//Se PCC Baixa CR e nao houver abatimento de impostos
				If cPaisLoc == "BRA" .And. lPccBxCR .And. ( nTotCsAbt + nTotPisAbt + nTotCofAbt == 0 ) .And. ( !lRartimp .And. !lRaRtImpMR ) .And. ( lCredito .And. !lAutomato )
					//Se PCC Baixa CR e a compensação partiu de um adiantamento
					//Os titulos nao serao pre-selecionados.
					//Isto se da para que a cada titulo marcado, seja realizado o cálculo do PCC
					lMarca := .F.
				ElseIf lAutomato
					If TitNMarca(cAliasSE1)
						lMarca	:= .F.
					EndIf
				EndIf
								
				If dDataBase < dLastPcc
					If nPis <> E1_PIS .and. nCofins <> E1_COFINS .and. nCsll <> E1_CSLL .and. nIrrf <> E1_IRRF  // Garantir a integridade do valor dos impostos 
						nPis    := aImpPccIr[1]
						nCofins := aImpPccIr[2]
						nCsll   := aImpPccIr[3]
						nIrrf   := aImpPccIr[4]
					EndIf
				EndIf
				
				nValComp := 0

				//Valores Acessórios
				If !FA330Msg(lAutomato,If(lCredito,nValVa,__nValVa),(cAliasSE1)->E1_SDACRES)
					lMarca := .F.
				Endif
				If lMarca
					nValComp := Iif (nValPre > Round(NoRound(xMoeda((cAliasSE1)->E1_SALDO - nDescD - nTotAbat +(cAliasSE1)->E1_SDACRES-(cAliasSE1)->E1_SDDECRE + nValVa - __nImpMR,(cAliasSE1)->E1_MOEDA,nMoeda,,3,nTaxaMov,Fa330Tx2(nMoeda,nTxMoeda)),3),2) , ;
									xMoeda((cAliasSE1)->E1_SALDO - nDescD - nTotAbat+(cAliasSE1)->E1_SDACRES-(cAliasSE1)->E1_SDDECRE + nValVa - __nImpMR,(cAliasSE1)->E1_MOEDA,nMoeda,,5,nTaxaMov,Fa330Tx2(nMoeda,nTxMoeda)), nVlBasico-nTotComp)
				EndIf
			Else
	 	       nValComp := Iif (nValPre > xMoeda((cAliasSE1)->E1_SALDO+(cAliasSE1)->E1_SDACRES-(cAliasSE1)->E1_SDDECRE,(cAliasSE1)->E1_MOEDA,nMoeda,dDatabase,,aTxMoedas[E1_MOEDA][2],aTxMoedas[nMoeda][2]),;
			                Round(xMoeda((cAliasSE1)->E1_SALDO+(cAliasSE1)->E1_SDACRES-(cAliasSE1)->E1_SDDECRE,(cAliasSE1)->E1_MOEDA,nMoeda,dDatabase,nDecs+1,aTxMoedas[E1_MOEDA][2],aTxMoedas[nMoeda][2]),nDecs), nVlBasico-nTotComp)
			EndIf
			
			//PONTO DE ENTRADA F330CMP
			//Tratamento de valor a ser compensado em determinado titulo permitindo que o usuario possa calcular o valor do titulo NDF ou PA a ser compensado
			IF lF330CMP
				nValComp:= ExecBlock("F330CMP",.F.,.F.)
			EndIf
			
			nTotComp += If( nMoeda > 1, Round(nValComp,2), nValComp)
		Else
			If lAutomato
				nValPre := IIF (nTotComp == 0 , nVlBasico, nVlBasico - nTotComp)
				nValComp := Iif (nValPre > Round(NoRound(xMoeda((cAliasSE1)->E1_SALDO - nTotAbat +(cAliasSE1)->E1_SDACRES-(cAliasSE1)->E1_SDDECRE+nValVa,(cAliasSE1)->E1_MOEDA,nMoeda,,3,Fa330Tx2((cAliasSE1)->E1_MOEDA,(cAliasSE1)->E1_TXMOEDA),Fa330Tx2(nMoeda,nTxMoeda)),3),2) , ;
							xMoeda((cAliasSE1)->E1_SALDO - nTotAbat+(cAliasSE1)->E1_SDACRES-(cAliasSE1)->E1_SDDECRE+nValVa,(cAliasSE1)->E1_MOEDA,nMoeda,,5,Fa330Tx2((cAliasSE1)->E1_MOEDA,(cAliasSE1)->E1_TXMOEDA),Fa330Tx2(nMoeda,nTxMoeda)),;
							nVlBasico-nTotComp)
			EndIf
			If cPaisLoc == "BRA"
				If (mv_par08 == 1 .Or. ( lRaRtImp .Or. lRaRtImpMR ) ) .And. !((cAliasSE1)->E1_TIPO $ MVRECANT+"/"+MV_CRNEG )
					nTotCsAbt	:= 0
					nTotPisAbt	:= 0
					nTotCofAbt	:= 0
					nTotIrAbt   := 0
					nTotAbat := SumAbatRec((cAliasSE1)->E1_PREFIXO,(cAliasSE1)->E1_NUM,(cAliasSE1)->E1_PARCELA,(cAliasSE1)->E1_MOEDA,"S",dBaixa,,@nTotIrAbt,@nTotCsAbt,@nTotPisAbt,@nTotCofAbt)
					If lNcc .And. ( lRaRtImp .Or. lRaRtImpMR ) .And. ((cAliasSE1)->E1_VALOR > (cAliasSE1)->E1_SALDO)
						aOldBaixaSE5 := aClone(aBaixaSE5)
						aBaixaSE5:= {}

						// Soma a proporcionalização de iss e inss ao nValrec 
						aBxSE5 := Sel070Baixa( "VL /V2 /BA /RA /CP /LJ /"+MV_CRNEG,(cAliasSE1)->E1_PREFIXO,(cAliasSE1)->E1_NUM,(cAliasSE1)->E1_PARCELA,;
					   							(cAliasSE1)->E1_TIPO,@nTotAdto,@lBaixaAbat,(cAliasSE1)->E1_CLIENTE,;
												(cAliasSE1)->E1_LOJA,@nVlrBaixa,,@lBxCEC,@lBxLiq,,.T.)
						For x := 1 To Len(aBaixaSE5)
					 		nTotAbat -= aBaixaSE5[x][32]+aBaixaSE5[x][33]
						Next
						aBaixaSE5 := aClone(aOldBaixaSE5)
					EndIf
				Else
					nTotAbat := 0
				EndIf
			EndIf
			If !lAutomato
				lMarca 		:= .F.		// desmarca para verso WIN
				nValComp 	:= 0
				nValPre 	:= nVlBasico
			EndIf
		EndIf
		
		If !__lDizPer .And. !lPccBxCR .And. lCredito
			cVlAux		:= AllTrim(Str(nValComp) )
			nPosPnt		:= AT(".", cVlAux)
			__lDizPer 	:= Iif(nPosPnt > 0, Len( SubStr(cVlAux, nPosPnt + 1, 5 ) ) >= 4, .F.)
		EndIf
		nValLim    := 0
		nSldConv   := xMoeda(SE1->E1_SALDO,  SE1->E1_MOEDA, nMoeda , dDtMov, __nCasDec, IIF(SE1->E1_MOEDA > 1,nTaxaMov,0), __nTxMoedP)
		nTotAbtCon := xMoeda(nTotAbat,  SE1->E1_MOEDA, nMoeda , dDtMov, __nCasDec, IIF(SE1->E1_MOEDA > 1,nTaxaMov,0), __nTxMoedP)
				
		If cPaisLoc == "BRA"
			
			// Moeda de Partida
			nMoedaP := (cAliasSE1)->E1_MOEDA
			If nMoedaP > 1
				If __lRaTxMov
					nTaxaP	:= (cAliasSE1)->E1_TXMOEDA
					If Empty(nTaxaP)
						nTaxaP := nTaxaMov
					EndIf
				Else
					nTaxaP  := aTxMoedas[nMoedaP][2] 
				Endif
			EndIf
			
			// Moeda de Destino
			nMoedaD := nMoeda		
			nTaxaD	:= __nTxMoedP
			
			nVAlSld:= (cAliasSE1)->(E1_SALDO+E1_SDACRES-E1_SDDECRE) - nDesFin + nValVa
			nValSld := FA330Valor(nValSld, (cAliasSE1)->E1_MOEDA, nMoeda, dDataBase, nTaxaMov, .F.)
			
			If (lPccBxCr .Or. lIRPJBxCr) .And. ( lRaRtImp .Or. lRaRtImpMR ) .And. !lNcc

				If lCredito
					aAdd(aDadosRA1[2],(cAliasSE1)->RecSe1)
				Else
					aAdd(aDadosRA1[1],(cAliasSE1)->RecSe1)
				EndIf
				
				aAdd(aDadosRA1[9],lMarca)
								
				If !lTemImpPix .And. dDatabase >= dLastPcc 
					If !__lPccMR
						If lRartImp .And. lCredito .And. FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)
							aPcc := newMinPcc(dBaixa,SE1->E1_SALDO,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
						EndIf
					EndIf
				EndIf
			
				If lAutomato .And. TitNMarca(cAliasSE1)
					lMarca := .F.
				EndIf
				
				If F330RaRtIm(@aDadosRA1)
					If !lAutomato .Or. ( lAutomato .And. lMarca )					
						nValLim 	:= If(aDadosRA1[7][len(aDadosRA1[7])]>nVlBasico,nVlBasico,aDadosRA1[7][len(aDadosRA1[7])])
						nTotComp	-= nValComp
						If !(nTotComp + If(aDadosRA1[8][len(aDadosRA1[8])]>nVlBasico,nVlBasico,aDadosRA1[8][len(aDadosRA1[8])]) > nVlBasico) 
							nValComp 	:= If(aDadosRA1[8][len(aDadosRA1[8])]>nVlBasico,nVlBasico,aDadosRA1[8][len(aDadosRA1[8])])
						EndIf
						
						If mv_par08 == 2 .And. !lCredito .And. lRartImp
							nValComp:= Iif( SE1->E1_SALDO > nValLim, nValComp, SE1->E1_SALDO)
						EndIf 
						
						nTotComp	+= nValComp
					ElseIf lAutomato
						nTotComp	:= 0
					EndIf
				EndIf
								
				If dDatabase >= dLastPcc .And. ( lRartImp .Or. lRaRtImpMR ) .And. lCredito
					If aDadosRA1[7][len(aDadosRA1[7])] < nVlBasico 
						If nValLim + nPis + nCofins + nCsll <> SE1->E1_SALDO //somente deve descontar os impostos quando o valor estiver bruto
							nValLim		:= nValLim - nPis - nCofins - nCsll
							nValComp	:= nValLim
						EndIf
					EndIf
				EndIf
													
				If nMoedaP <> nMoedaD
					nValLim	:= Iif(nSaldo>nVAlSld,nVAlSld,nSaldo) 					    
					nTotComp	-= nValComp
					nValComp 	:= nValLim
					nTotComp	+= nValComp
				EndIf

			Else
				
				If __lPccMR
					nPis 	:= __nPisCaMR
					nCofins := __nCofCaMR
					nCsll 	:= __nCslCaMR
					
					If !lCredito .Or. ( lCredito .And. MV_PAR08 == 1 )
						If nSaldo > ( nVAlSld - Iif( lPccBxCr, ( nPis + nCofins + nCsll), 0) - nTotAbat - __nImpMR - nIrrf)
							nValLim := nVAlSld - Iif( lPccBxCr, ( nPis + nCofins + nCsll), 0) - nTotAbat - __nImpMR - nIrrf
						Else
							nValLim := nSaldo - Iif( lPccBxCr, ( nPis + nCofins + nCsll), 0) - nTotAbat - __nImpMR - nIrrf
						EndIf
					Else
						nValLim := SE1->E1_SALDO - nTotAbat
					EndIf
					If !lRaRtImpMR .And. lPccBxCr .And. (cAliasSE1)->E1_TIPO <> MVRECANT .And. nPis + nCofins + nCsll + nIrrf > 0 .And. SE1->E1_SALDO <> SE1->E1_VALOR
						nAbatRa := nTotAbat
						nSldNF := SE1->E1_SALDO
					EndIf
				Else				
					If ( !lRaRtImp .And. mv_par08 == 1 .And. lPccBxCr .And. SE1->E1_TIPO <> MVRECANT )
						If dDataBase < dLastPcc
							f070TotMes( dBaixa , .T. )
						EndIf
					EndIf
								
					If dDataBase < dLastPcc
			  			If !lRaRtImp .and. lPccBxCr .and. (cAliasSE1)->E1_TIPO <> MVRECANT .and. nPis+nCofins+nCsll+nIrrf > 0 .And. aDadosret[1] <= nVlMinImp 
			  				If nSldRa > SE1->E1_SALDO 
			  					nProp		:= (SE1->E1_SALDO) / SE1->E1_VALOR
			  				Else
			  					nProp		:= nSldRa/SE1->E1_VALOR
			  				EndIf
			  				If nProp <> 0
								nValPis		:= SE1->E1_PIS * nProp
								nValCofins	:= SE1->E1_COFINS * nProp
								nValCsll	:= SE1->E1_CSLL * nProp
								If (nSldRa >= SE1->E1_SALDO .and. aDadosRet[1]+SE1->E1_SALDO > nVlMinImp) .or. (nSldRa <= SE1->E1_SALDO .and. aDadosRet[1]+nSldRa > nVlMinImp)  
									nPis		:= aDadosRet[2] + nValPis 
									nCofins		:= aDadosRet[3] + nValCofins
									nCsll		:= aDadosRet[4] + nValCsll
								Else
									nPis		:= nValPis 
									nCofins		:= nValCofins
									nCsll		:= nValCsll
								EndIf
							EndIf 	
							nValLim 	:= Iif( nSaldo > (nVAlSld - nPis - nCofins - nCsll - nTotAbat), (nVAlSld - nPis - nCofins - nCsll - nTotAbat) , Iif (aDadosRet[1]+nSaldo <= nVlMinImp, nSaldo, (nSaldo - nPis - nCofins - nCsll - nTotAbat)) )
						ElseIf !lRaRtImp .and. lPccBxCr .and. (cAliasSE1)->E1_TIPO <> MVRECANT .and. nPis+nCofins+nCsll+nIrrf > 0 .AND. aDadosret[1] > nVlMinImp .and. SE1->E1_SALDO <> SE1->E1_VALOR
							nValPis		:= nPis
							nValCofins	:= nCofins
							nValCsll	:= nCsll
							nPis		:= (nValPis * (SE1->E1_SALDO/ SE1->E1_VALOR))
							nCofins		:= (nValCofins * (SE1->E1_SALDO/ SE1->E1_VALOR))
							nCsll		:= (nValCsll * (SE1->E1_SALDO/ SE1->E1_VALOR))	
							nValLim 	:= Iif( nSaldo > (nVAlSld -nPis - nCofins - nCsll-nTotAbat) , (nVAlSld - nPis - nCofins - nCsll - nTotAbat) , (nSaldo - nPis - nCofins - nCsll - nTotAbat) )
							nAbatRa		:= nTotAbat
							nSldNF		:= SE1->E1_SALDO
						ElseIf !lRaRtImp .or. (lRaRtImp .and. (cAliasSE1)->(E1_PIS + E1_CSLL + E1_COFINS) == 0)
							If nValComp > 0 .and. (nSaldo <> nValComp)
								nPis	:= aDadosRet[2] + ((nValComp * nValPis)/nValorNf) 
								nCofins	:= aDadosRet[3] + ((nValComp * nValCofins)/nValorNf)
								nCsll	:= aDadosRet[4] + ((nValComp * nValCsll)/nValorNf)
			  					nValLim := Iif(!lRartImp,Max(nVAlSld , nValComp),Iif( nValComp > nVAlSld , nVAlSld , nValComp ))
			  				Else
			  					If nValPis > 0 .AND. aDadosret[1] <= nVlMinImp .and. aDadosRet[1]+nValComp <= nVlMinImp
			  						nPis	:= nValPis
			  						nCofins	:= nValCofins
			  						nCsll	:= nValCsll
			  					EndIf
			  					If lCredito
			  						nAbatNf	:= nTotAbat
			  					EndIf
			  					nValLim := Iif( nSaldo > nVAlSld , nVAlSld , nSaldo )
			  				EndIf
			  			EndIf
			  		Else
		  				If lCredito .and. mv_par08 == 2 .and. !lRartImp .and. nValSld+nPis+nCofins+nCsll <= SE1->E1_SALDO
		  					nValSld	+= nPis+nCofins+nCsll
		  				EndIf
		  				
						nValRec2 := Iif(nValRec < SE1->E1_SALDO,nValRec,SE1->E1_SALDO)
		  				
						If !(!lCredito .and. !lRartImp)
							If !lTemImpPix .And. FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)
								aPcc		:= newMinPcc(dBaixa,nValRec2,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
								nPis		:= aPcc[2]
								nCofins		:= aPcc[3]
								nCsll		:= aPcc[4]
							EndIf		
							
							If !lIrPjBxCr
								nIrrf	:= SE1->E1_IRRF
							ElseIf !__lIrfMR
								aArea := SE1->(GetArea())
								
								If !( SE1->E1_TIPO $ MVRECANT )
									SE1->(DbGoTo(nRecno))
								EndIf
								
								nIrrf := IIf(!lTemImpPix, FCaIrBxCR(nValRec2), nIrrf)
								RestArea(aArea)
							EndIf
		  				EndIf
		  				nValLim := Iif(nSaldo>nVAlSld,nVAlSld,nSaldo)
			  		EndIf
					If lMarca
		  				nValLim -= __nImpMR 	//Retira o valor calculado pelo configurador de tributos do valor limite para compensação	
					EndIf
		  			If SE1->E1_TIPO <> MVRECANT .And. nValLim > nSldConv - nTotAbtCon .And. MV_PAR08 == 1
					    // Só faz a subtração do nValLim se o mesmo não ficar negativo
						If nValLim - nTotAbtCon >= 0
							nValLim -= nTotAbtCon
							If ( nSldConv - nTotAbtCon - iif(lPccBxCr,nPis + nCofins + nCsll, 0 ) ) > nValLim
								nValLim := ( nSldConv - nTotAbtCon )
							EndIf
						// Se não subtrair o valor em nTotBat, verifica se o saldo atual do titulo esta inferior ao nValLim
						ElseIf ( nSldConv - nTotAbtCon ) < nValLim
							nValLim := ( nSldConv - nTotAbtCon )
						EndIf

						If nValComp > nValLim .And. SE1->E1_SDACRES > 0
							nValLim	+= SE1->E1_SDACRES
							If nValLim > nValComp
								nValLim := nValComp
							EndIf
						EndIf

						If !lRaRtImp
							If !aPcc[1]
								If ValType( aDadosRet ) == "A" 
									aDadRetAux := aClone( aDadosRet )
								EndIf
	
								If dDataBase < dLastPcc
									f070TotMes( dBaixa , .T. )
								EndIf
								//Retorna os valores originais
								aDadosRet  := aClone( aDadRetAux )
			
								nPis       := aImpPccIr[1]
								nCofins    := aImpPccIr[2]
								nCsll      := aImpPccIr[3]
								nIrrf      := aImpPccIr[4]
													
								aDadRetAux := {}
							EndIf
	
						EndIf
					
					EndIf
			
				EndIf

			EndIf

			//Verifica se o titulo já possui impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
			nPisFin061	:=	0
			nCofFin061	:=	0
			nCslFin061	:=	0
			nIrfFin061	:=	0
			nRegSE5		:=	SE5->(Recno())
			nOrdSE5		:=	SE5->(IndexOrd())		
			If lPccBxCr .Or. lIrPjBxCr                                                                                               			
				dbSelectArea("SE5")
				SE5->(dbSetOrder(2)) //FILIAL + TIPODOC + PREFIXO + NUMERO + PARCELA + TIPO
				If SE5->(DBSeek(xFilial("SE5")+"BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
					While !SE5->(Eof()) .and. SE5->E5_FILIAL==xFilial("SE5") .And. ;
						SE5->E5_TIPODOC+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO=="BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO		
				
						If  ("FINA061" $ Subst(SE5->E5_HISTOR,1,7) .Or. "FINA891" $ Subst(SE5->E5_HISTOR,1,7)) .And. SE5->E5_MOTBX $ "PCC_IRF"						
							If Alltrim(SE5->E5_MOTBX) == "PCC"
							   nPisFin061	+= SE5->E5_VRETPIS
							   nCofFin061	+= SE5->E5_VRETCOF
							   nCslFin061	+= SE5->E5_VRETCSL
							ElseIf Alltrim(SE5->E5_MOTBX) == "IRF"
							   nIrfFin061	+= SE5->E5_VRETIRF
							EndIf
						EndIf				
						SE5->(DbSkip())		
			   		EndDo
				EndIf
			EndIf
	   		SE5->(Dbgoto(nRegSE5))
			SE5->(Dbsetorder(nOrdSE5))													                  

			If ( nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061 ) > 0
				//Caso o titulo possua bordero de recebimento de imposto gerado na rotina FINA061 devo recompor base no caso de não abater os impostos
				//ou  abater os impostos e tiver compensando de RA para NF. Senão devo zerar as variaveis para não afetar o processamento. 
			  	If  mv_par08 == 1 
					nPisFin061	:=	0
					nCofFin061	:=	0
					nCslFin061	:=	0
					nIrfFin061	:=	0
				EndIf		
			EndIf					
			lNcc2 := (cAliasSE1)->E1_TIPO $ MV_CRNEG
      		
      		If ( lRaRtImp .Or. lRaRtImpMR ) .And. lPccBxCr .And. !lNcc .And. lCredito
               	nSaldoNF := (cAliasSE1)->E1_SALDO - aDadosRA1[3][Len(aDadosRA1[3])] - aDadosRA1[4][Len(aDadosRA1[4])] - aDadosRA1[5][Len(aDadosRA1[5])]
            Else
               	nSaldoNF := (cAliasSE1)->E1_SALDO
            EndIf

			If cPaisLoc != "EUA" .And. nValComp <> nValRec .And. !lRaRtImp
				nValRec	:= nValComp
			EndIf
	        
			If MV_PAR02 == 2 // Considera Cliente == Não
				DBSelectArea("SA1")
				nIndexSA1 := IndexOrd()
				nPosSA1   := Recno()
				DBSetOrder(1)
				DBSeek(xFilial()+(cAliasSE1)->E1_CLIENTE+(cAliasSE1)->E1_LOJA)
				dbSelectArea(cAliasSE1)				
				nDesFin := getDesc(nValComp)
				
				If __lMotRet
				    nlimite:= Iif (nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061 > nValorPcc, nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061, nValorPcc)

					AADD(aTitulos,{;
					(cAliasSE1)->E1_PREFIXO,;
					(cAliasSE1)->E1_NUM,;
					(cAliasSE1)->E1_PARCELA,;
					(cAliasSE1)->E1_TIPO,;
					(cAliasSE1)->E1_LOJA,;
					Transform(xMoeda((nSaldoNF+ nPisFin061+nCofFin061+nCslFin061+nIrfFin061)+(cAliasSE1)->E1_SDACRES-Iif(nProp>0,(nImp*nProp),0)-(cAliasSE1)->E1_SDDECRE- Iif(  Type("nTotAbat") <> "N" .OR. MV_PAR08== 2 ,0,nTotAbat) - nDesFin + nValVa,(cAliasSE1)->E1_MOEDA,nMoeda,,5,Fa330Tx2(nMoedaP,nTaxaP),Fa330Tx2(nMoedaD,nTaxaD)),"@E 9999,999,999.99"),; //06
					Transform(nlimite + nPisFin061+nCofFin061+nCslFin061+nIrfFin061, "@E 9999,999,999.99"),; //07
					lMarca,;
					nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061,; //09
					(cAliasSE1)->(E1_CLIENTE)+"-"+(cAliasSE1)->(E1_LOJA),;
					(cAliasSE1)->E1_NOMCLI,;
					Transform(SA1->A1_CGC,Substr(PicPes(SA1->A1_PESSOA),1,at("%",PicPes(SA1->A1_PESSOA))-1)),;
					Transform((cAliasSE1)->E1_SDACRES,"@E 9999,999,999.99"),;
					Transform((cAliasSE1)->E1_SDDECRE,"@E 9999,999,999.99"),;
					(cAliasSE1)->E1_HIST,;
					(cAliasSE1)->E1_FILIAL,;
					Transform(nValorPcc,"@E 9999,999,999.99"),;
					Transform(nValorPcc,"@E 9999,999,999.99"),;
					Transform(nValorPcc,"@E 9999,999,999.99"),;
					Transform(nValorPcc,"@E 9999,999,999.99"),;
					Transform(nValorPcc,"@E 9999,999,999.99"),;
					Transform(nValorPcc,"@E 9999,999,999.99"),;
					(cAliasSE1)->RECSE1,;
					(cAliasSE1)->E1_SALDO + nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061,; 
					Transform(nValLim,"@E 9999,999,999.99"),;
					(cAliasSE1)->E1_VALOR,; //26
					Transform(nValorPcc,"@E 9999,999,999.99"),;//27 base calculo PCC
					Transform(nValorPcc,"@E 9999,999,999.99"),;//28 Base Retenção PCC
					Transform(nValorPcc,"@E 9999,999,999.99"),;//29 Base de calculo e retenção do IRF
					Transform(nValorPcc,"@E 9999,999,999.99"),; //30 Motor
					Transform(nValVa,"@E 9999,999,999.99"),;	//31 Valor acessório	
					nTaxaMov}) //32 Taxa do título
					
					
				Else
					AADD(aTitulos,{;
						(cAliasSE1)->E1_PREFIXO,;
						(cAliasSE1)->E1_NUM,;
						(cAliasSE1)->E1_PARCELA,;
						(cAliasSE1)->E1_TIPO,;
						(cAliasSE1)->E1_LOJA,;
						Transform(xMoeda((nSaldoNF+ nPisFin061+nCofFin061+nCslFin061+nIrfFin061)+(cAliasSE1)->E1_SDACRES-Iif(nProp>0,(nImp*nProp),0)-(cAliasSE1)->E1_SDDECRE- Iif(  Type("nTotAbat") <> "N" .OR. MV_PAR08== 2 ,0,nTotAbat) - nDesFin + nValVa,(cAliasSE1)->E1_MOEDA,nMoeda,,5,Fa330Tx2(nMoedaP,nTaxaP),Fa330Tx2(nMoedaD,nTaxaD)),"@E 9999,999,999.99"),; //06
						Transform(nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061, "@E 9999,999,999.99"),; //07
						lMarca,;
						nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061,; //09
						(cAliasSE1)->(E1_CLIENTE)+"-"+(cAliasSE1)->(E1_LOJA),;
						(cAliasSE1)->E1_NOMCLI,;
						Transform(SA1->A1_CGC,Substr(PicPes(SA1->A1_PESSOA),1,at("%",PicPes(SA1->A1_PESSOA))-1)),;
						Transform((cAliasSE1)->E1_SDACRES,"@E 9999,999,999.99"),;
						Transform((cAliasSE1)->E1_SDDECRE,"@E 9999,999,999.99"),;
						(cAliasSE1)->E1_HIST,;
						(cAliasSE1)->E1_FILIAL,;
						Transform(nValorPcc,"@E 9999,999,999.99"),;
						Transform(nValorPcc,"@E 9999,999,999.99"),;
						Transform(nValorPcc,"@E 9999,999,999.99"),;
						Transform(nValorPcc,"@E 9999,999,999.99"),;
						Transform(nValorPcc,"@E 9999,999,999.99"),;
						Transform(nValorPcc,"@E 9999,999,999.99"),;
						(cAliasSE1)->RECSE1,;
						(cAliasSE1)->E1_SALDO + nPisFin061 + nCofFin061 + nCslFin061 + nIrfFin061,; 
						Transform(nValLim,"@E 9999,999,999.99"),;
						(cAliasSE1)->E1_VALOR,; //26
						Transform(nValorPcc,"@E 9999,999,999.99"),;//27 base calculo PCC
						Transform(nValorPcc,"@E 9999,999,999.99"),;//28 Base Retenção PCC
						Transform(nValorPcc,"@E 9999,999,999.99"),;//29 Base de calculo e retenção do IRF
						Transform(nValVa,"@E 9999,999,999.99"),;//30 Valor acessório	
						nTaxaMov}) //31 Taxa do título
					
				EndIf

				nLin := Len(aTitulos)
				nPosxRet := 30
				nReg330 := 23 // Posição 23 do aTitulos				 
				If ( lRaRtImp .Or. lRaRtImpMR ) .And. ( lPccBxCr .Or. lIRPJBxCr ) .And. !lNcc
					lRetMinAux := ( ( !__lPccMR .And. (aDadosRet[1] > nVlMinImp) .OR. ((cAliasSE1)->E1_PIS > 0 .OR. (cAliasSE1)->E1_COFINS  > 0 .OR. (cAliasSE1)->E1_CSLL > 0 .OR. (cAliasSE1)->E1_IRRF > 0) ) .Or. ( __lPccMR .And. __nPisCaMR + __nCofCaMR + __nCslCaMR > 0 ) )
					If lRetMinAux
   						aTitulos[nLin][nPosPis]:= Transform(aDadosRA1[3][nLin]   ,X3Picture("E1_PIS"))
						aTitulos[nLin][nPosCof]:= Transform(aDadosRA1[4][nLin]   ,X3Picture("E1_COFINS"))
						aTitulos[nLin][nPosCsl]:= Transform(aDadosRA1[5][nLin]   ,X3Picture("E1_CSLL"))
						aTitulos[nLin][nPosIrf]:= Transform(aDadosRA1[6][nLin]   ,X3Picture("E1_IRRF"))
						If __lMotRet .And. !Empty(aDadosRA1[12])
							aTitulos[nLin][nPosxRet]:= Transform(aDadosRA1[12][nLin]   ,X3Picture("E1_IRRF"))
						EndIf
					EndIf
					aTitulos[nLin][nPosBPCC]:= Transform(aDadosRA1[7][nLin]   ,X3Picture("E1_VALOR"))
					aTitulos[nLin][nPosBPCR]:= Transform(aDadosRA1[8][nLin]   ,X3Picture("E1_VALOR"))
					
					If Type("oTitulo") == "O"
						oTitulo:aArray:=aTitulos
  						oTitulo:Refresh()
					Endif
				Endif

				SA1->(DBSetOrder(nIndexSA1))
				SA1->(DBGoto(nPosSA1))
				
			Else	// MV_PAR02 <> 2 // Considera Cliente == Sim
				nPosxRet	:= 27

				If __lMotRet
					nlimite:= Iif (nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061 > nValLim  + nPisFin061+nCofFin061+nCslFin061+nIrfFin061, nValLim  + nPisFin061+nCofFin061+nCslFin061+nIrfFin061, nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061)

			    	aAdd(aTitulos,{(cAliasSE1)->E1_PREFIXO,;		//01
					(cAliasSE1)->E1_NUM,;						//02
					(cAliasSE1)->E1_PARCELA,;					//03
					(cAliasSE1)->E1_TIPO,;						//04
					(cAliasSE1)->E1_LOJA,;						//05
					Transform(xMoeda(nSaldoNF+(cAliasSE1)->E1_SDACRES-Iif(nProp>0,(nImp*nProp),0)-(cAliasSE1)->E1_SDDECRE- Iif(  Type("nTotAbat") <> "N" .OR. MV_PAR08== 2,0,nTotAbat) - nDesFin + nValVa,(cAliasSE1)->E1_MOEDA,nMoeda,,5,Fa330Tx2(nMoedaP,nTaxaP),Fa330Tx2(nMoedaD,nTaxaD)),"@E 9999,999,999.99"),; //06
					Transform(nlimite,"@E 9999,999,999.99"),;//07
					lMarca,;										//08
					nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061,;										//09
					Transform((cAliasSE1)->E1_SDACRES,"@E 9999,999,999.99"),;
					Transform((cAliasSE1)->E1_SDDECRE,"@E 9999,999,999.99"),;
					(cAliasSE1)->E1_HIST,;						//12
					(cAliasSE1)->E1_FILIAL,;						//13
					Transform(nValorPcc,"@E 9999,999,999.99"),;//PCC Baixa CR - Pis 		//14	
					Transform(nValorPcc,"@E 9999,999,999.99"),;//PCC Baixa CR - Cofins	 	//15
					Transform(nValorPcc,"@E 9999,999,999.99"),;//PCC Baixa CR - Csll		//16
					Transform(nValorPcc,"@E 9999,999,999.99"),;//PCC Baixa CR - Irrf		//17	
					Transform(nValorPcc,"@E 9999,999,999.99"),;								//18
					Transform(nValorPcc,"@E 9999,999,999.99"),;								//19
					(cAliasSE1)->RECSE1,;													//20
					(cAliasSE1)->E1_SALDO + nPisFin061+nCofFin061+nCslFin061+nIrfFin061,;														//21
					Transform(nValLim  + nPisFin061+nCofFin061+nCslFin061+nIrfFin061,"@E 9999,999,999.99"),;//Limite de Compensacao  //22
					(cAliasSE1)->E1_VALOR,;//23
					Transform(nValorPcc,"@E 9999,999,999.99"),;//24 base calculo PCC
					Transform(nValorPcc,"@E 9999,999,999.99"),;//25 Base Retenção PCC
					Transform(nValorPcc,"@E 9999,999,999.99"),;//26 Base de calculo e retenção do IRF
					Transform(nValorPcc,"@E 9999,999,999.99"),; //27 PCC Baixa CR - Irrf		//18
					Transform(nValVa,"@E 9999,999,999.99"),;//28 Valor acessório	
					nTaxaMov}) //29 Taxa do título
					
				Else
				aAdd(aTitulos,{(cAliasSE1)->E1_PREFIXO,;		//01
					(cAliasSE1)->E1_NUM,;						//02
					(cAliasSE1)->E1_PARCELA,;					//03
					(cAliasSE1)->E1_TIPO,;						//04
					(cAliasSE1)->E1_LOJA,;						//05
					Transform(xMoeda(nSaldoNF+(cAliasSE1)->E1_SDACRES-Iif(nProp>0,(nImp*nProp),0)-(cAliasSE1)->E1_SDDECRE- Iif(  Type("nTotAbat") <> "N" .OR. MV_PAR08== 2,0,nTotAbat) - nDesFin + nValVa,(cAliasSE1)->E1_MOEDA,nMoeda,,5,Fa330Tx2(nMoedaP,nTaxaP),Fa330Tx2(nMoedaD,nTaxaD)),"@E 9999,999,999.99"),; //06
					Transform(nValComp,"@E 9999,999,999.99"),;//07
					lMarca,;										//08
					nValComp + nPisFin061+nCofFin061+nCslFin061+nIrfFin061,;										//09		
					Transform((cAliasSE1)->E1_SDACRES,"@E 9999,999,999.99"),;
					Transform((cAliasSE1)->E1_SDDECRE,"@E 9999,999,999.99"),;
					(cAliasSE1)->E1_HIST,;						//12
					(cAliasSE1)->E1_FILIAL,;						//13
					Transform(nValorPcc,"@E 9999,999,999.99"),;//PCC Baixa CR - Pis 		//14	
					Transform(nValorPcc,"@E 9999,999,999.99"),;//PCC Baixa CR - Cofins	 	//15
					Transform(nValorPcc,"@E 9999,999,999.99"),;//PCC Baixa CR - Csll		//16
					Transform(nValorPcc,"@E 9999,999,999.99"),;//PCC Baixa CR - Irrf		//17	
					Transform(nValorPcc,"@E 9999,999,999.99"),;								//18
					Transform(nValorPcc,"@E 9999,999,999.99"),;								//19
					(cAliasSE1)->RECSE1,;													//20
					(cAliasSE1)->E1_SALDO + nPisFin061+nCofFin061+nCslFin061+nIrfFin061,;														//21
					Transform(nValLim  + nPisFin061+nCofFin061+nCslFin061+nIrfFin061,"@E 9999,999,999.99"),;//Limite de Compensacao  //22
					(cAliasSE1)->E1_VALOR,;//23
					Transform(nValorPcc,"@E 9999,999,999.99"),;//24 base calculo PCC
					Transform(nValorPcc,"@E 9999,999,999.99"),;//25 Base Retenção PCC
					Transform(nValorPcc,"@E 9999,999,999.99"),;//26 Base de calculo e retenção do IRF
					Transform(nValVa,"@E 9999,999,999.99"),; //27 Valor acessório
					nTaxaMov})//28 Taxa do título
				EndIf

				nlin := Len(aTitulos)
				nReg330 := 20 // Posição 20 do aTitulos				
				If ( lRaRtImp .Or. lRaRtImpMR ) .And. (lPccBxCr .Or. lIRPJBxCr) .And. !lNcc .And. ((cAliasSE1)->E1_PIS > 0 .OR. (cAliasSE1)->E1_COFINS  > 0 .OR. (cAliasSE1)->E1_CSLL > 0 .OR. (cAliasSE1)->E1_IRRF > 0)
					aTitulos[nLin][nPosPis]:= Transform(aDadosRA1[3][nLin]   ,X3Picture("E1_PIS"))
					aTitulos[nLin][nPosCof]:= Transform(aDadosRA1[4][nLin]   ,X3Picture("E1_COFINS"))
					aTitulos[nLin][nPosCsl]:= Transform(aDadosRA1[5][nLin]   ,X3Picture("E1_CSLL"))
					aTitulos[nLin][nPosIrf]:= Transform(aDadosRA1[6][nLin]   ,X3Picture("E1_IRRF"))
					If __lMotRet .And. !Empty(aDadosRA1[12])
						aTitulos[nLin][nPosxRet]:= Transform(aDadosRA1[12][nLin]   ,X3Picture("E1_IRRF"))
					EndIf
					aTitulos[nLin][6] := Transform(xMoeda(aDadosRA1[7][nLin],(cAliasSE1)->E1_MOEDA,nMoeda,,5,Fa330Tx2(nMoedaP,nTaxaP),Fa330Tx2(nMoedaD,nTaxaD)),"@E 9999,999,999.99")
				Endif
			
			Endif
			
			If __lMotRet .and. lMarca
				aTitulos[nLin][nPosxRet]:= Transform(__nImpMR   ,X3Picture("E1_IRRF"))
			EndIf
					
			If lFI330ALT
				aTitulos:=ExecBlock("FI330ALT",.F.,.F.,{aTitulos})
			EndIF

		Else
	      	//Quando considerar o cliente original do titulo selecionado, mostra o cgc e o nome dos clientes refrentes a cada titulo (MV_PAR02==2)
	      	If MV_PAR02 == 2
	      		DBSelectArea("SA1")
	      		nIndexSA1 := IndexOrd()
	      		nPosSA1   := Recno()
	      		DBSetOrder(1)
	      		DBSeek(xFilial()+(cAliasSE1)->E1_CLIENTE+(cAliasSE1)->E1_LOJA)
	      		cCgcClie := SA1->A1_CGC
	      		cNomClie := SA1->A1_NOME

	      		DBSetOrder(nIndexSA1)
	      		DBGoto(nPosSA1)
	     	   
	      		DBSelectArea(cAliasSE1)
	      		If nValLim==0
					If (cAliasSE1)->E1_SALDO>=nSaldo
						nValLim:= nSaldo
						If cPaisLoc != "RUS"
							nValComp:= If(lMarca,nSaldo,nValComp)
						Else
							nValComp:= If(lMarca,nValComp,nSaldo)
						EndIf
					Else
						nValLim:= (cAliasSE1)->E1_SALDO
						nValComp:= If(lMarca,nValComp,(cAliasSE1)->E1_SALDO)
					Endif
				Endif
				If cPaisLoc != "RUS"		
					aAdd(aTitulos,{(cAliasSE1)->E1_PREFIXO,;
										(cAliasSE1)->E1_NUM,;
										(cAliasSE1)->E1_PARCELA,;
										(cAliasSE1)->E1_TIPO,;
										(cAliasSE1)->E1_LOJA,;
										Transform(Round(xMoeda((cAliasSE1)->E1_SALDO+(cAliasSE1)->E1_SDACRES-(cAliasSE1)->E1_SDDECRE,(cAliasSE1)->E1_MOEDA,nMoeda,(cAliasSE1)->E1_EMISSAO,nDecs+1,aTxMoedas[(cAliasSE1)->E1_MOEDA][2],aTxMoedas[nMoeda][2]),nDecs),__cPiE1Sld),;
										Transform(nValComp,__cPiE1Sld),;
										lMarca,;
										(cAliasSE1)->E1_MOEDA,;
										(cAliasSE1)->E1_EMISSAO,;
										cNomClie,;
										Transform(cCgcClie,PesqPict("SA1","A1_CGC")),;
										Transform(xMoeda((cAliasSE1)->E1_SDACRES,(cAliasSE1)->E1_MOEDA,nMoeda,,5),"@E 9999,999,999.99"),;
										Transform(xMoeda((cAliasSE1)->E1_SDDECRE,(cAliasSE1)->E1_MOEDA,nMoeda,,5),"@E 9999,999,999.99"),;
										(cAliasSE1)->E1_HIST,;
										(cAliasSE1)->E1_FILIAL,;
										Transform(xMoeda(nValLim,nMoeda,nMoeda,,5,Fa330Tx2((cAliasSE1)->E1_MOEDA,(cAliasSE1)->E1_TXMOEDA),Fa330Tx2(nMoeda, nTxMoeda)),"@E 9999,999,999.99")})//Limite de Compensacao
				Else
						aAdd(aTitulos,{(cAliasSE1)->E1_PREFIXO,;
							(cAliasSE1)->E1_NUM,;
							(cAliasSE1)->E1_PARCELA,;
							(cAliasSE1)->E1_TIPO,;
							(cAliasSE1)->E1_LOJA,;
							Transform(Round(xMoeda((cAliasSE1)->E1_SALDO+(cAliasSE1)->E1_SDACRES-(cAliasSE1)->E1_SDDECRE,(cAliasSE1)->E1_MOEDA,nMoeda,(cAliasSE1)->E1_EMISSAO,nDecs+1,aTxMoedas[(cAliasSE1)->E1_MOEDA][2],aTxMoedas[nMoeda][2]),nDecs),PesqPict("SE1","E1_SALDO")),;
							Transform(nValComp,PesqPict("SE1","E1_SALDO")),;
							lMarca,;
							(cAliasSE1)->E1_MOEDA,;
							(cAliasSE1)->E1_EMISSAO,;
							cNomClie,;
							Transform(cCgcClie,PesqPict("SA1","A1_CGC")),;
							Transform(xMoeda((cAliasSE1)->E1_SDACRES,(cAliasSE1)->E1_MOEDA,nMoeda,,5),"@E 9999,999,999.99"),;
							Transform(xMoeda((cAliasSE1)->E1_SDDECRE,(cAliasSE1)->E1_MOEDA,nMoeda,,5),"@E 9999,999,999.99"),;
								(cAliasSE1)->E1_HIST,;
							(cAliasSE1)->E1_FILIAL,;
							Transform(xMoeda(nValLim,nMoeda,nMoeda,,5,Fa330Tx2((cAliasSE1)->E1_MOEDA,(cAliasSE1)->E1_TXMOEDA),Fa330Tx2(nMoeda, nTxMoeda)),"@E 9999,999,999.99"),;//Limite de Compensacao
							(cAliasSE1)->E1_CLIENTE,;
							(cAliasSE1)->E1_F5QCODE,;
							(cAliasSE1)->E1_VALOR,;
							(cAliasSE1)->E1_VLCRUZ,;
							(cAliasSE1)->E1_CONUNI,;
							AllTrim(Posicione("CTO",1,xFilial("CTO") + StrZero((cAliasSE1)->E1_MOEDA, GetSX3Cache("CTO_MOEDA", "X3_TAMANHO")), "CTO_SIMB"))})
				EndIf			
	       Else
	       
	       		// Moeda de Partida
				nMoedaP := (cAliasSE1)->E1_MOEDA
				// Moeda de Destino
				nMoedaD := nMoeda
				
   				If nValLim == 0
					If (cAliasSE1)->E1_SALDO>=nSaldo
						nValLim:= nSaldo
						nValComp:= If(lMarca,nValComp,nSaldo)

					Else
						nValLim:= (cAliasSE1)->E1_SALDO
						nValComp:= If(lMarca,nValComp,(cAliasSE1)->E1_SALDO)

					Endif
				Endif

				nVAlSld := (cAliasSE1)->(E1_SALDO+E1_SDACRES-E1_SDDECRE) - nDesFin  
				
				If cPaisLoc != "RUS"
					aAdd(aTitulos,{(cAliasSE1)->E1_PREFIXO,;
								(cAliasSE1)->E1_NUM,;
								(cAliasSE1)->E1_PARCELA,;
								(cAliasSE1)->E1_TIPO,;
								(cAliasSE1)->E1_LOJA,;
								Transform(Round(xMoeda((cAliasSE1)->E1_SALDO,(cAliasSE1)->E1_MOEDA,nMoeda,(cAliasSE1)->E1_EMISSAO,nDecs+1,aTxMoedas[(cAliasSE1)->E1_MOEDA][2],aTxMoedas[nMoeda][2]),nDecs),__cPiE1Sld),;
								Transform(nValComp,__cPiE1Sld),;
								lMarca,;
								(cAliasSE1)->E1_MOEDA,;
								(cAliasSE1)->E1_EMISSAO,;
								Transform(xMoeda((cAliasSE1)->E1_SDACRES,(cAliasSE1)->E1_MOEDA,nMoeda,,5),"@E 9999,999,999.99"),;
								Transform(xMoeda((cAliasSE1)->E1_SDDECRE,(cAliasSE1)->E1_MOEDA,nMoeda,,5),"@E 9999,999,999.99"),;
								(cAliasSE1)->E1_FILIAL,;
								Transform(xMoeda(nValLim,nMoeda,nMoeda,,5,Fa330Tx2((cAliasSE1)->E1_MOEDA,(cAliasSE1)->E1_TXMOEDA),Fa330Tx2(nMoeda, nTxMoeda)),"@E 9999,999,999.99")})//Limite de Compensacao
				Else
					aAdd(aTitulos,{(cAliasSE1)->E1_PREFIXO,;
									(cAliasSE1)->E1_NUM,;
									(cAliasSE1)->E1_PARCELA,;
									(cAliasSE1)->E1_TIPO,;
									(cAliasSE1)->E1_LOJA,;
									Transform(Round(xMoeda((cAliasSE1)->E1_SALDO,(cAliasSE1)->E1_MOEDA,nMoeda,(cAliasSE1)->E1_EMISSAO,nDecs+1,aTxMoedas[(cAliasSE1)->E1_MOEDA][2],aTxMoedas[nMoeda][2]),nDecs),__cPiE1Sld),;
									Transform(nValComp,__cPiE1Sld),;
									lMarca,;
									(cAliasSE1)->E1_MOEDA,;
									(cAliasSE1)->E1_EMISSAO,;
								Transform(xMoeda((cAliasSE1)->E1_SDACRES,(cAliasSE1)->E1_MOEDA,nMoeda,,5),"@E 9999,999,999.99"),;
								Transform(xMoeda((cAliasSE1)->E1_SDDECRE,(cAliasSE1)->E1_MOEDA,nMoeda,,5),"@E 9999,999,999.99"),;
										(cAliasSE1)->E1_FILIAL,;
									Transform(xMoeda(nValLim,nMoeda,nMoeda,,5,Fa330Tx2((cAliasSE1)->E1_MOEDA,(cAliasSE1)->E1_TXMOEDA),Fa330Tx2(nMoeda, nTxMoeda)),"@E 9999,999,999.99"),; //Limite de Compensacao
								(cAliasSE1)->E1_CLIENTE,;
								(cAliasSE1)->E1_F5QCODE,;
								(cAliasSE1)->E1_VALOR,;
								(cAliasSE1)->E1_VLCRUZ,;
								(cAliasSE1)->E1_CONUNI,;
								AllTrim(Posicione("CTO",1,xFilial("CTO") + StrZero((cAliasSE1)->E1_MOEDA, GetSX3Cache("CTO_MOEDA", "X3_TAMANHO")), "CTO_SIMB"))})
				EndIf

			EndIf

		EndIf

		aAdd( aRecNo, (cAliasSE1)->RECSE1 )
		
		If lFa330Qry
			aAreaSED	:= SED->(GetArea())
			DbSelectArea("SED")
			DbSetOrder(1)
			DbSeek(xFilial("SED", SE1->E1_FILORIG) + SE1->E1_NATUREZ)
			If !lNcc2 .And. ( ( lCredito .And. ( SED->ED_CALCPIS == 'S' .Or. SED->ED_CALCCOF == 'S' ;
				.Or. SED->ED_CALCCSL == 'S' ) ) .Or. ( !lCredito .And. FNatPCC((cAliasSE1)->E1_FILORIG, SE1->E1_NATUREZ) ) )
				If ( aScan(__aNatPCC, { |x| x[1] = (cAliasSE1)->E1_FILORIG + SE1->E1_NATUREZ } )) == 0
					aAdd(__aNatPCC, {(cAliasSE1)->E1_FILORIG + SE1->E1_NATUREZ})
				EndIf
			EndIf
			RestArea(aAreaSED)
		ElseIf !lNcc2 .And. ( ( lCredito .And. ( (cAliasSE1)->ED_CALCPIS == 'S' .Or. (cAliasSE1)->ED_CALCCOF == 'S' ;
			.Or. (cAliasSE1)->ED_CALCCSL == 'S' ) ) .Or. ( !lCredito .And. FNatPCC((cAliasSE1)->E1_FILORIG, (cAliasSE1)->E1_NATUREZ) ) )
			If ( aScan(__aNatPCC, { |x| x[1] = (cAliasSE1)->E1_FILORIG + (cAliasSE1)->E1_NATUREZ } )) == 0
				aAdd(__aNatPCC, {(cAliasSE1)->E1_FILORIG + (cAliasSE1)->E1_NATUREZ})
			EndIf
		EndIf
		
		(cAliasSE1)->(dbSkip())
	EndDo
	
	Exit
EndDo

__oHNatPCC := AtoHM(__aNatPCC, 1)

If __lMotRet
	FMRGetArr(,.T.) // Destrói o Model do MR
EndIf
If __l330Va
	oModelVa:Destroy()
	oModelVa := NIL
EndIf

If !Empty(nTitSemTx)
	Help(" ",1,"NOTXTITD",,STR(nTitSemTx,4) + STR0127,1,0)//  título(s) com problema de taxa cambial. Não serão listados títulos sem taxa!
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Recupera a Integridade dos dados	  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SM0")
dbGoto(nRecEmp)
cFilAnt := IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza valor total dos t¡tulos - Windows	 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nValTot := 0
For nX := 1 to Len(aTitulos)
	If aTitulos[nX,8]
		nValtot += Fa330VTit(aTitulos[nX,7])
	Endif
Next

/* GESTAO - inicio */
If !Empty(aTmpSE1Fil)
	For nX := 1 TO Len(aTmpSE1Fil)
		CtbTmpErase(aTmpSE1Fil[nX])
    Next
Endif
/* GESTAO - fim */
dbSelectArea(cAliasSE1)
dbCloseArea()
dbSelectArea("SE1")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Recupera a Integridade dos dados	  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea(cSavArea)
dbSetOrder(nSavOrd)
dbGoto(nRecNo)
RestVarMR( aImpMRBrw )

Return( aTitulos )
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³Fa330VTit ³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 22/09/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Retorna o saldo ou valor do titulo a ser compensado		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Fina330													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Fa330VTit(aTitulo,cTipoTit,cValor)
LOCAL nValor
cValor := IIF (cValor == NIL,aTitulo,cValor)
If ValType(cValor)=="N"
	nValor := cValor
Else
	nValor := DesTrans(cValor)
EndIf
Return nValor

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³ FA330Desc³ Autor ³ Wagner Xavier 		³ Data ³ 01/09/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Cancelar a Compensao de Adiantamentos.					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FA330Desc() 												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA330													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FA330Desc( cAlias, nReg, nOpc )
Local lPanelFin 	:= IsPanelFin()
Local nOpcA 		:= 0         		// Indica se a Compesaao sera efetuada
Local dBaixa		:= SE1->E1_BAIXA	// Data da Baixa
Local lCancelou 	:= .F.				// Indica se foi realmente cancelado
Local aRegistros 	:= {}             // Guarda os registros do SE5 a serem cancelados
Local cDocumento  	:= ""             // Guarda o RA/NCC que efetuou a Bx.
local cArquivo    	:= ""             // Utilizado na Contabilizacao
local nTotal		:= 0               // Utilizado na Contabilizacao
local nHdlPrv		:= 0               // Utilizado na Contabilizacao
local cPadrao		:= "588"           // Utilizado na Contabilizacao
local lPadrao		:= .F.					// Utilizado na Contabilizacao
Local lFirst		:= .F.					// Utilizado na Contabilizacao
Local cLojaCmp		:= ""             // Util. para Comp. de Lojas diferentes
local nOrdSE1		:= SE1->(IndexOrd())
Local nOrdFilter    := SE1->(IndexOrd())
local nRegSE1     	:= 0              // Guarda o Registro do SE1
local nRegSE5     	:= 0              // Guarda o Registro do SE5
Local lMarcado		:= .F.             // Indica se o item foi marcado
Local nMoeda      	:= 0              // Moeda do Titulo Principal (SE1)
Local cAdiantamento						// Guarda o RA/NCC que efetuou a Bx.
Local nVlrAbat    	:= 0
Local aBaixas     	:= {}             // Guarda as baixas do SE5 para cancelar comissao
Local oDlg
Local oOk		  	:= LoadBitmap( GetResources(), "LBOK" )
Local oNo		  	:= LoadBitmap( GetResources(), "LBNO" )
Local oTitulo
Local nDecs       	:= 2
Local nTxMoeda    	:= 0
Local nDecs1      	:= MsDecimais(1)
Local aDoctosSE5  	:= {}
Local nSaldoComp  	:= 0
Local aArea		  	:= {}
Local cChaveSE1
Local nValCtb     	:= 0		// Valor total a ser contabilizado (VALOR)
Local nI 		  	:= 0
Local nLaco 		:= 0
Local nTotAbat 		:= 0
Local nSE1Rec 		:= 0
Local cKeyAbt 		:= 0
Local nAcresc		:= 0		//Acrescimo do titulo de adiantamento
Local nDecres 		:= 0		//Decrescimo do titulo de adiantamento
Local nTitAcres 	:= 0		//Acrescimo do titulo principal
Local nTitDecre 	:= 0		//Decrescimo do titulo principal
Local nX 			:= 0
Local nY 			:= 0
Local nT 			:= 0
Local lAchou  		:= .F.
Local cCliAdt 		:= ""
Local cLojAdt 		:= ""
Local lF330FLTC 	:= ExistBlock("F330FLTC")
Local lF330AE5E		:= ExistBlock("F330AE5E")
Local lF330VEEX		:= ExistBlock("F330VEEX")
Local lFA330EAC		:= ExistBlock("FA330EAC")
Local nRecnoSE1 	:= SE1->(RECNO())
Local lImpComp 		:= SuperGetMv("MV_IMPCMP",,"2") == "1"
Local lIsNcc		:= .F.

//Compensacao de contas a receber, nao necessita verificar o parametro MV_BX10925
Local lPCCBaixa 	:= (cPaisLoc == "BRA")

Local lRaRtImp  	:= FRaRtImp()     //Define se ha retencao de impostos PCC/IRPJ no R.A
Local aSize			:= {}
Local oPanel
Local lDigita

Local aDiario		:=	{}
Local lVldDtFin		:= .T.
Local aFlagCTB		:= {}
Local lUsaFlag		:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
Local lAtusalImp	:= .F.
Local nRecE1Dest	:= 0		// Recno SE1 do título destino da exclusão.  (partida é o título que inicia o processo posicionado)
Local nRecE5Dest	:= 0		// Recno SE5 do título destino da exclusão.  (partida é o título que inicia o processo posicionado)

//Controla o Pis Cofins e Csll na baixa  (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default) )
Local lPccBxCr		:= FPccBxCr()
//Controla IRPJ na baixa
Local lIrPjBxCr		:= FIrPjBxCr()
Local nIrrf			:= 0
Local nPis			:= 0
Local nCofins		:= 0
Local nCsll			:= 0
Local nInss			:= 0
Local nCtbInss		:= 0
Local aTitulosTMP	:= {}
Local aTamChav		:= {}
Local cREGAnt 		:= ""
Local cREG 			:= ""
Local aLstDOC		:= {}
Local cChaveE1Adt 	:= ""
Local cChaveE5Adt 	:= ""
Local aAreaE5Adt
Local aAreaE1Adt
Local aAdtVen  		:= {}
Local lAdtVen  		:= .F.
Local aTipos   		:= {}
Local cTipos   		:= ""
Local cTipoAux 		:= ""
Local lVinculo 		:= .F.
Local lF330Exclui
Local lF330ESE5  	:= ExistBlock( "F330ESE5" )
Local lF330ExComp 	:= ExistBlock( "F330EXCOMP" )
Local lFi330Est   	:= ExistBlock( "FI330EST" )
Local l330DESC    	:= ExistBlock("F330DESC")
Local lDESC       	:= .F.
Local lRetAuto		:= .T.
Local cChavePai		:= ''
Local aDtMov		:=	{}
Local lPccComp 		:= .T.
Local aAreaSE5		:=	{}
Local cChaveSE5		:=	''
Local lBxCanc		:= .T.
Local nDescP		:= 0
Local nDescD		:= 0
Local nIrrfPac 		:= 0
Local nValPcc		:= 0  
Local nSaldoBx		:= 0
Local nVlNewPis 	:= nVlNewCof := nVlNewCsl := nPosTit := nVlNewIrf := 0
Local nValAux		:= 0

//--- Tratamento Gestao Corporativa
Local lGestao   	:= Iif( lFWCodFil, FWSizeFilial() > 2, .F. )	// Indica se usa Gestao Corporativa
Local cFilFwSE1 	:= lGestao .And. FwFilial("SE1")
Local cAliasCmp		:= GetNextAlias()
Local aDadosX		:=  {}
Local cFilCred		:=  ""
Local cFilSe1		:=	xFilial("SE1")
Local cTrabalho 	:=""
Local lLjOrigem 	:= Alltrim(Upper(FunName())) $ "LOJA140|LOJA701" .OR. Alltrim(SE1->E1_ORIGEM) $ "LOJA701|FRTA010|LOJA720" //indica se eh executada por alguma rotina do SIGALOJA/FRT

//Controle de abatimento
Local nOrdTitPai	:= 0
Local lTitpaiSE1 	:= (nOrdTitPai:= OrdTitpai()) > 0
Local cTipo 		:= ""
Local bWhile 		:= {|| !EOF() .And. E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA==cFilSE1+cKeyAbt}
Local bWhile2 		:= {|| (cFilSE1+cPrefixo+cNum+cParcela == SE1->E1_FILIAL+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA ) .OR. (Alltrim(SE1->E1_TITPAI) == Alltrim(cChavePai))}
Local lSE1Exclusivo := .F.
Local cFilOld 		:= cFilAnt
// Variaveis para o Novo Modelo de Gravacao do Movimento Bancario
Local aAreaAnt 		:= {}
Local cLog 			:= ""
Local lRet 			:= .T.
Local cCamposE5 	:= ""
//Impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
Local nPisFin061	:= 0
Local nCofFin061	:= 0
Local nCslFin061	:= 0
Local nIrfFin061	:= 0  
Local nOrdSE5		:= 0
Local nVlPis		:= 0
Local nVlCof		:= 0
Local nVlCsll		:= 0
Local nVlIrrf		:= 0
Local nVlNf			:= 0
Local lPropBx  		:= SuperGetMv("MV_PROPBX",.F.,"2") == "1"
Local nAbat			:= 0
Local lBQ10925		:= SuperGetMV("MV_BQ10925",,"2") == "1" .And. !lRaRtImp
Local aBaixa 		:= {}
LOCAL nTotAdto		:= 0
Local lBaixaAbat	:= .F.
Local nVlrBaixa		:= 0
Local lBxCec		:= .F.
Local lBxLiq		:= .F.
Local lbxPos		:= .F.
Local lExistFJU 	:= FindFunction("FinGrvEx")
Local lF070TRAVA	:= ExistBlock("F070TRAVA")
Local lGrvSa1		:= .T.
Local cCliLoja 		:= ""
Local nRegFK1		:= 0
Local aBxInteg 		:= {}
Local nRecNf 		:= 0
Local cSE1Orig 		:= ""
Local nInt 			:= 0
Local lOpcAux 		:= .F. 
Local lEnvMU070 	:= FWHasEAI( "FINA070", .T.,, .T. )
Local lEnvMU330 	:= FWHasEAI( "FINA330", .T.,, .T. )
Local aRetInteg 	:= {}
Local nCMEst		:= 0
Local lEstFdif		:= .F.
Local cFilPai		:= cFilAnt
Local cChvCrPai		:= ""		
Local cCliLjPai		:= ""

// Integração SIGAPFS x SIGAFIN
Local nSE5PFS    	:= 0
Local nSE5PFSTMP 	:= 0
Local nSE5PFSRA  	:= 0
Local nSE1PFS    	:= 0
Local nSE1PFSRA  	:= 0
Local nMovPFS    	:= 0
Local nValHist	 	:= 0
Local aMovPFS    	:= {}
Local aAlt			:= {}
Local lAcrDecr 		:= .F.

Local lIrfBxAux 	:= lIrPjBxCr
Local lPccBxAux 	:= lPccBxCr
Local lRaRtImpMR 	:= .F.
Local aAreaFK7		:= {}
Local cIdOrig 		:= ""
Local lSE5ModExc  	:= FWModeAccess("SE5",3)== "E" // Verifica se SE5 é exclusiva
Local lFinTp01		:= FindFunction("FINTP01")
Local cPrefCred 	:= ""
Local cNumCred		:= ""
Local cParcCred		:= ""
Local cTpCred		:= ""
Local nPosAcum		:= 0
Local cPicE5Val     := PesqPict("SE5","E5_VALOR")

Local nRecAntSe5	:= 0
Local nRecAntSe1	:= 0
Local nValVa 		:= 0

Local nInicio		:= 0
Local nFim			:= 0
Local nGravados		:= 0
Local nRegistros	:= 0

Local lPCO01605		:= PcoExistLc("000016","05","1")
Local lUsaAbat		:= .F.

PRIVATE aTitulos	:= {}
PRIVATE cPrefixo	:= SE1->E1_PREFIXO
PRIVATE cNum		:= SE1->E1_NUM
PRIVATE cTipoTit	:= SE1->E1_TIPO
PRIVATE cCliente	:= SE1->E1_CLIENTE
PRIVATE cLoja		:= SE1->E1_LOJA
PRIVATE cParcela	:= SE1->E1_PARCELA
PRIVATE cTipodoc	:= "  "
PRIVATE lCredito	:= .F.
PRIVATE cTipodc		:= " "
PRIVATE nValTit		:= 0
PRIVATE aBaixaSE5 	:= {}

If __cRmProd == Nil
	__cRmProd		:= SuperGetMv('MV_RMORIG',, "E|U|S")
EndIf

If lFinTp01 .And. FINTP01(.T.) // Restringe o uso do programa Financeiro quando a origem do titulo for de origem Totvs Incorporação RM
	Return
EndIf

//Não deixa efetuar o Cancelamento da Baixa de um titulo vindo de integração
If(Alltrim(SE1->E1_ORIGEM)  $ __cRmProd .And. !l330Auto)
	HELP(" ",1,STR0132 ,,STR0135,2,0,,,,,, {STR0134})//"Titulo gerado e compensado pela Integração RM Classis X Protheus, não pode ser cancelado" ## "Efetue o processo através do sistema RM Classis"
	Return
EndIf

// Metrica de controle de acessos - Cancelamento da Compensação
__cFunBkp   := FunName()
__cFunMet	:= Iif(AllTrim(__cFunBkp)=='RPC',"RPCFINA330",__cFunBkp)

If __lMetric
	SetFunName(__cFunMet)
	FwCustomMetrics():setSumMetric(Alltrim(ProcName()), "financeiro-protheus_qtd-por-acesso_total", 1)
	SetFunName(__cFunBkp)
EndIf

//Guardando a chave do titulo pai.
cChavePai	:= TRIM(SE1->(E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO + E1_CLIENTE + E1_LOJA))

If lGestao
	If !Empty(cFilFwSE1)
		lSE1Exclusivo := .T.
    EndIf
Else
	If !Empty(xFilial("SE1"))
		lSE1Exclusivo := .T.
	EndIf
EndIf

If !FA330Lock(,SE1->(Recno()))
	Return
EndIf

If (ALLTRIM(SE1->E1_ORIGEM) == "FINA677") .and. !(FINVERRES(SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA),SE1->E1_ORIGEM, "R"))
	Help(" " , 1 , "FAVIAGEM")
	Return
EndIf

//Validação quando utiliza módulo do agro
If !l330Auto .And. SuperGetMv("MV_SIGAAGR",,.F.)
	If FindFunction("AGRTITFIN")
		If !AGRTITFIN()
			return .F.
		EndIf
	EndIf  
EndIf

If ExistBlock("F330DTFIN")
	lVldDtFin := ExecBlock("F330DTFIN",.F.,.F.)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se data do movimento no  menor que data limite de ³
//³ movimentacao no financeiro    										  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lVldDtFin .and. !DtMovFin(,,"2")
	Return(.F.)
EndIf

If lF070TRAVA
   	lGrvSa1 := ExecBlock("F070TRAVA", .F., .F.)
EndIf

If SE1->E1_TIPO $MV_CRNEG+"/"+MVRECANT
	cTipodoc 	:= "BA"
	lCredito	:= .T.
	cTipodc		:="CP"
	lIsNcc 		:= SE1->E1_TIPO $ MV_CRNEG
Else
	cTipodoc 	:= "CP"
	cTipodc		:="BA"
EndIf
If Substr(SE1->E1_TIPO,3,1) == "-"
	If !l330Auto
		Help(" ",1,"FA030INVAL")
  	EndIf
  	lRetAuto := .F.
  	Return lRetAuto
EndIf

//-----------------------------------------------------------
// Nao permite compensar recebimentos antecipados originados
// de faturas de adiantamentos. Req. Manejo de Anticipo
//-----------------------------------------------------------
If cPaisLoc == "MEX" .And. X3Usado("ED_OPERADT")
	If SE1->E1_TIPO == Substr(MVRECANT,1,3) .And.;
		Upper(Alltrim(SE1->E1_ORIGEM)) == "FINA087A" .And.;
		GetAdvFVal("SED","ED_OPERADT",xFilial("SED")+SE1->E1_NATUREZ,1,"") == "1"

		Help(" ",1,"VLDTITRA",,STR0065,1,0) //"Processo não permitido para recebimento antecipado gerado de fatura de adiantamento."
		Return (.F.)

	EndIf
EndIf

If cPaisLoc == 'BRA' .And. lRarTimp .And. lCredito .And. !lIrpjBxCr
	dbSelectArea("SE5")
	dbSetOrder(2)
	dbSeek( SE5->E5_FILIAL + cTipoDoc + cPrefixo + cNum + cParcela + cTipoTit )
	cPrefCred 	:= Left(SE5->E5_DOCUMEN,Len(cPrefixo))
	cNumCred	:= SubStr(SE5->E5_DOCUMEN, ( nPosAcum := Len(cPrefixo) + 1 ), Len(cNum))
	cParcCred	:= SubStr(SE5->E5_DOCUMEN,( nPosAcum := ( nPosAcum + Len(cNum)) ), Len(cParcela))
	cTpCred		:= SubStr(SE5->E5_DOCUMEN, nPosAcum + Len(cParcela), Len(cTipoTit))
	Help(" ",1,"PARTEST",,STR0114 + CRLF + cTpCred + STR0115 + CRLF + cPrefCred + '/ ' + cNumCred + '/ ' + cParcCred + STR0116,1,0) //"Estornar esse processo a partir do título XXX para não comprometer saldo do abatimento do IR."
	Return ( .F. )
EndIf

If Select("__SE1") == 0
	SumAbatRec("","","",1,"")
EndIf

While ( .T. )
	aTitulos   := {}
	aRegistros := {}
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Titulo a ser cancelado a compensao		 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nOpca := 0

	If !l330Auto
		If lPanelfin
			oPanelDados := FinWindow:GetVisPanel()
			oPanelDados:FreeChildren()
			aDim := DLGinPANEL(oPanelDados)
			DEFINE MSDIALOG oDlg OF oPanelDados:oWnd FROM 0,0 To 0,0 PIXEL STYLE nOR( WS_VISIBLE, WS_POPUP )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Observacao Importante quanto as coordenadas calculadas abaixo: ³
			//³ -------------------------------------------------------------- ³
			//³ a funcao DlgWidthPanel() retorna o dobro do valor da area do	 ³
			//³ painel, sendo assim este deve ser dividido por 2 antes da sub- ³
			//³ tracao e redivisao por 2 para a centralizacao. 					 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nEspLarg := ((DlgWidthPanel(oPanelDados)/2) - 225) /2
			nEspLin  := 20
		Else
	   		nEspLarg := 0
	   		nEspLin  := 2
			DEFINE MSDIALOG oDlg FROM	88,31 TO 187,525 TITLE STR0019 PIXEL  //"Compensao CR"
		EndIf
		
		oDlg:lMaximized := .F.
		oPanel := TPanel():New(0,0,'',oDlg,, .T., .T.,, ,20,20)
		oPanel:Align := CONTROL_ALIGN_ALLCLIENT

		@ 000+nEspLin, 002+nEspLarg TO 030+nEspLin, 245+nEspLarg OF oPanel	PIXEL

		@ 014+nEspLin, 006+nEspLarg MSGET cPrefixo							SIZE 19, 10 OF oPanel PIXEL
		@ 014+nEspLin, 032+nEspLarg MSGET cNum 	 Valid !Empty(cNum)	SIZE 70, 10 OF oPanel PIXEL
		@ 014+nEspLin, 105+nEspLarg MSGET cParcela							SIZE 20, 10 OF oPanel PIXEL
		@ 014+nEspLin, 129+nEspLarg MSGET cTipoTit  Picture "@!" Valid  !Empty(cTipoTit) .And.;
			Subs(cTipoTit,3)!="-" SIZE 16, 10 OF oPanel PIXEL
		@ 014+nEspLin, 155+nEspLarg MSGET cCliente F3 "SA1" Valid fa330Cli() SIZE 70, 10 OF oPanel Hasbutton PIXEL
		@ 014+nEspLin, 226+nEspLarg MSGET cLoja	Valid Fa330Loja() 	SIZE 16, 10 OF oPanel PIXEL

		@ 006+nEspLin, 006+nEspLarg SAY STR0006  SIZE 21, 7 OF oPanel PIXEL  //"Prefixo"
		@ 006+nEspLin, 032+nEspLarg SAY STR0007  SIZE 22, 7 OF oPanel PIXEL  //"N£mero"
		@ 006+nEspLin, 105+nEspLarg SAY STR0008  SIZE 23, 7 OF oPanel PIXEL  //"Parcela"
		@ 006+nEspLin, 129+nEspLarg SAY STR0009  SIZE 14, 7 OF oPanel PIXEL  //"Tipo"
		@ 006+nEspLin, 155+nEspLarg SAY STR0025  SIZE 34, 7 OF oPanel PIXEL  //"Cliente   "
		@ 006+nEspLin, 226+nEspLarg SAY STR0011  SIZE 14, 7 OF oPanel PIXEL  //"Loja"

		If lPanelFin  //Chamado pelo Painel Financeiro
			oDlg:Move(aDim[1],aDim[2],aDim[4]-aDim[2], aDim[3]-aDim[1])
			ACTIVATE MSDIALOG oDlg ON INIT FaMyBar(oDlg,;
			{||nOpca:=1,oDLg:End()},;
			{||nOpca:=0,oDlg:End()})

		Else
			DEFINE SBUTTON FROM 34, 190 TYPE 1 ENABLE ACTION (nOpca:=1,oDLg:End()) OF oDlg
			DEFINE SBUTTON FROM 34, 218 TYPE 2 ENABLE ACTION oDlg:End() OF oDlg
			ACTIVATE MSDIALOG oDlg CENTERED

		EndIf

		If lFi330Est .And. nOpca == 1
			nOpca := ExecBlock("FI330EST",.F.,.F.,{ nOpc, { cPrefixo, cNum, cParcela, cTipoTit, cCliente, cLoja }})
			If ValType(nOpca) != "N"
				nOpca := 0
			EndIf
		EndIf

		If ( nOpca == 0 )
			DeleteObject(oOk)
			DeleteObject(oNo)
			Exit
		EndIf

	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o t¡tulo existe. 	³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SE1")
	dbSetOrder(2)
	dbSeek(xFilial("SE1")+cCliente+cLoja+cPrefixo+cNum+cParcela+cTipoTit)
	If !Found()
		If !l330Auto
			Help(" ",1,"NOTIT")
	  	Endif
		DeleteObject(oOk)
		DeleteObject(oNo)
		FA330aUnlock()
		lRetAuto := .F.
		Exit
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o t¡tulo nao foi compensado.  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( SE1->E1_SALDO == SE1->E1_VALOR ) .and. ;
		(SE1->E1_ACRESC == SE1->E1_SDACRES) .and. ;
		(SE1->E1_DECRESC == SE1->E1_SDDECRE)

		If ! l330Auto
		  Help(" ",1,"A330NAOCOMP")
		Endif

		DeleteObject(oOk)
		DeleteObject(oNo)
		lRetAuto := .F.
		Exit //Loop

	EndIf

	//ANGOLA - Nao permitir compensar titulos de adiantamento relacionado a pedido
	If cPaisLoc == "ANG"
		FIE->(dbSetOrder(2))
		If FIE->(MsSeek(xFilial("FIE")+"R"+SE1->(E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)))
			Help(" ",1,"NOCANCMP",,STR0063,1,0)
			DeleteObject(oOk)
			DeleteObject(oNo)
			Loop
		Endif
	Endif

	//Metricas - Tela do cancelamento da compensação - INICIO
	If __lMetric
		nInicio := Seconds()
	Endif

	nMoeda 		:= SE1->E1_MOEDA 				// Moeda do tit original
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Guardo dados do titulo principal para utilizar   ³
	//³ no historico da contabilizaÆo                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	STRLCTPAD := SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Procura a filial em que este titulo foi compensado ³
	//³ quando compensacao multifiliais                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	F330PsqFil(SE1->E1_FILORIG,cPrefixo,cNum,cParcela,SE1->E1_CLIENTE,SE1->E1_LOJA,cTipoTit,"R",cTipoDoc,cAliasCmp,@cTrabalho)

	__cFk1IdOri := ""
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Procura adiantamentos do titulo original para      ³
	//³ montar lista de titulos compensados para apresentar³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea(cAliasCmp)
	While (cAliasCmp)->( !EOF() )
		dbSelectArea("SE5")
		dbSetOrder(2)
		If lSE5ModExc
			VerSE5((cAliasCmp)->( E5_FILIAL ), cTipoDoc, cPrefixo, cNum, cParcela, cTipoTit, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG)
		Else
			dbSeek( (cAliasCmp)->( E5_FILIAL ) + cTipoDoc+cPrefixo+cNum+cParcela+cTipoTit)
		EndIf		

		nValVa		:= FxLoadFK6("FK1",SE5->E5_IDORIG,"VA")[1,2]	//Pego o valor Informado

		While (!Eof() .and. (cAliasCmp)->( E5_FILIAL ) == SE5->E5_FILIAL .And.	;
				SE5->E5_TIPODOC == cTipoDoc .And. 				;
				SE5->E5_PREFIXO == cPrefixo .And.				;
				SE5->E5_NUMERO == cNum .And.					;
				SE5->E5_PARCELA == cParcela )
			
			VerFk1(SE5->E5_IDORIG, @__cFk1IdOri)
			
			If (SE5->E5_MOTBX != "CMP" .Or. SE5->E5_RECPAG != "R" )
				dbSkip()
				Loop
			Endif

			//Verifica se tem baixa cancelada
			If TemBxCanc(SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ),.T.,SE5->E5_FILIAL)
				SE5->(dbskip())
				Loop
			EndIf

			aBaixaSE5 := {}
			lbxPos := .F.
			//verifica se houve baixa posteriores
			aBaixa := Sel070Baixa( "VL /V2 /BA /RA /CP /LJ /" + MV_CRNEG, SE5->E5_PREFIXO,SE5->E5_NUMERO, SE5->E5_PARCELA, SE5->E5_TIPO,;
			                       @nTotAdto, @lBaixaAbat, SE5->E5_CLIFOR, SE5->E5_LOJA, @nVlrBaixa, , @lBxCec, @lBxLiq , ,.T.)

			For nX := 1 to len(aBaixaSE5)
				If aBaixaSE5[nX][29] == "CMP"
					Loop
				ElseIf aBaixaSE5[nX][9] > SE5->E5_SEQ
					If aBaixaSE5[nX][18]+aBaixaSE5[nX][19]+aBaixaSE5[nX][20]+aBaixaSE5[nX][30] > 0
						HELP(" ",1, "FINIMPBX" )
						lbxPos := .T.
						Exit						
					EndIf 
				EndIf
			Next nXad
			
			If lbxPos
				SE5->(DbSkip())
				Loop
			EndIf	
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica Cliente se considerar Cliente Original 		³
			//³ na selecao de titulos 									³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If mv_par02 == 1 .and.  SE5->E5_CLIFOR != SE1->E1_CLIENTE
				dbSkip( )
				Loop
			EndIf
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica loja caso considere loja na selecao de titulos	  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If mv_par01 == 1 .and. mv_par02 == 1 .and.  SE5->E5_LOJA != SE1->E1_LOJA
				dbSkip( )
				Loop
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se a baixa e anterior a data do sistema    	  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SE5->E5_DATA > dDatabase
				dbSkip( )
				Loop
			EndIf

			//ANGOLA - Nao permitir compensar titulos de adiantamento relacionado a pedido
			If cPaisLoc == "ANG"
				FIE->(dbSetOrder(2))
				If FIE->(MsSeek(xFilial("FIE")+"R"+SE5->(E5_CLIFOR+E5_LOJA+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO)))
					dbSkip()
					Loop
				EndIf
			EndIf

			If cPaisLoc == "BRA"
				// se estorno da compensacao nao estah partindo do titulo de credito
				If !lCredito
					If AllTrim(SE1->E1_ORIGEM) == "MATA460"
						// checa se condicao de pagamento eh relacionado com adiantamento
						If FaNfsRAdt(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_CLIENTE,SE1->E1_LOJA,SE1->E1_EMISSAO)
							lAdtVen := .T.
							// checa se eh a primeira baixa para o titulo principal, pois a primeira baixa eh realizada no momento da geracao do documento de saida, quando hah adiantamento relacionado ao documento.
							If FaBxEmisDoc(SE5->E5_FILIAL,SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_TIPO,SE5->E5_DATA,SE5->E5_SEQ,"R",SE5->E5_DOCUMEN)
								dbSelectArea("SE5")
								aAdd(aAdtVen,{SE5->E5_DATA,SE5->E5_VALOR,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ}) // grava array com registros que foram compensados no momento da geracao do documento de saida e que nao podem ser excluidos na compensacao do Fina330. Grava campos que sao iguais entre o registro principal da baixa e o do adiantamento.
								dbSkip()
								Loop
							Endif
						Endif
					Endif
				// se estorno da compensacao estah partindo do titulo de credito
				Else
					// posiciona no titulo principal e na baixa principal para checar se eh adiantamento e se esta baixa foi gerada no momento da emissao do documento de saida.
					aAreaE5Adt := SE5->(GetArea())
					If lLjOrigem .Or. Empty(SE5->E5_FORNADT)	//executada por alguma rotina do SIGALOJA/FRT
						cChaveE5Adt := SE5->E5_FILIAL+cTipoDc+Subs(SE5->E5_DOCUMEN,1,nTamTit+nTamTip)+dTos(SE5->E5_DATA)+IIf(Empty(SE5->E5_FORNADT),SE5->(E5_CLIFOR+E5_LOJA+E5_SEQ),SE5->(E5_FORNADT+E5_LOJAADT+E5_SEQ))
					Else
						cChaveE5Adt := SE5->E5_FILIAL+cTipoDc+Subs(SE5->E5_DOCUMEN,1,nTamTit+nTamTip)+dTos(SE5->E5_DATA)+SE5->(E5_FORNADT+E5_LOJAADT+E5_SEQ)
					EndIf
					aAreaE1Adt := SE1->(GetArea())
					If lLjOrigem .Or. Empty(SE5->E5_FORNADT)	//executada por alguma rotina do SIGALOJA/FRT
						cChaveE1Adt := SE5->E5_FILIAL+IIf(Empty(SE5->E5_FORNADT),SE5->(E5_CLIFOR+E5_LOJA), SE5->(E5_FORNADT+E5_LOJAADT))+Subs(SE5->E5_DOCUMEN,1,nTamTit+nTamTip)
					Else
						cChaveE1Adt := SE5->E5_FILIAL+SE5->(E5_FORNADT+E5_LOJAADT)+Subs(SE5->E5_DOCUMEN,1,nTamTit+nTamTip)
					EndIf
					// posiciona no titulo principal
					SE1->(dbSetOrder(2)) // E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO                                                                                               
					If SE1->(dbSeek(cChaveE1Adt))

						If (ALLTRIM(SE1->E1_ORIGEM) == "FINA677") .and. !(FINVERRES(SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA),SE1->E1_ORIGEM, "R"))
							SE5->(dbskip())
							Loop
					 	Endif
						// posiciona na baixa principal
						SE5->(dbSetOrder(2)) // E5_FILIAL+E5_TIPODOC+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+DtoS(E5_DATA)+E5_CLIFOR+E5_LOJA+E5_SEQ                                                             
						If SE5->(dbSeek(cChaveE5Adt))
							If AllTrim(SE1->E1_ORIGEM) = "MATA460"
								// checa se condicao de pagamento eh relacionado com adiantamento
								If FaNfsRAdt(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_CLIENTE,SE1->E1_LOJA,SE1->E1_EMISSAO)
									lAdtVen := .T.
									// checa se eh a primeira baixa para o titulo principal, pois a primeira baixa eh realizada no momento da geracao do documento de saida, quando hah adiantamento relacionado ao documento.
									If FaBxEmisDoc(SE5->E5_FILIAL,SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_TIPO,SE5->E5_DATA,SE5->E5_SEQ,"R",SE5->E5_DOCUMEN)
										RestArea(aAreaE1Adt)
										RestArea(aAreaE5Adt)
										dbSelectArea("SE5")
										aAdd(aAdtVen,{SE5->E5_DATA,SE5->E5_VALOR,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ}) // grava array com registros que foram compensados no momento da geracao do documento de saida e que nao podem ser excluidos na compensacao do Fina330.
										dbSkip()
										Loop
									Endif
								Endif
							Endif
																				
							aBaixaSE5 := {}
							lbxPos := .F.
							//verifica se houve baixa posteriores
							aBaixa := Sel070Baixa( "VL /V2 /BA /RA /CP /LJ /" + MV_CRNEG, SE5->E5_PREFIXO,SE5->E5_NUMERO, SE5->E5_PARCELA, SE5->E5_TIPO,;
								@nTotAdto, @lBaixaAbat, SE5->E5_CLIFOR, SE5->E5_LOJA, @nVlrBaixa, , @lBxCec, @lBxLiq , ,.T.)
				
							For nX := 1 to len(aBaixaSE5)
								If aBaixaSE5[nX][29] == "CMP"
										Loop						
								ElseIf aBaixaSE5[nX][9] > SE5->E5_SEQ
									If aBaixaSE5[nX][18]+aBaixaSE5[nX][19]+aBaixaSE5[nX][20]+aBaixaSE5[nX][30] > 0
										HELP(" ",1, "FINIMPBX" )
										lbxPos := .T.
										
										Exit						
									EndIf 
								EndIf
							Next nX
							If lbxPos
								SE5->(DBskip())
								Loop
							EndIf
													
						Endif
					Endif
					RestArea(aAreaE1Adt)
					RestArea(aAreaE5Adt)
					dbSelectArea("SE5")
				Endif
			Endif

			//Ponto de entrada para dispensar do cancelamento
			If lF330FLTC .and. ExecBlock("F330FLTC",.F.,.F.)
				dbSkip( )
				Loop
			Endif

			If lLjOrigem 	//executada por alguma rotina do SIGALOJA/FRT
				If Empty(SE5->E5_FORNADT)
					aAdd(aLstDOC,{xFilial("SE5"),SE5->E5_DOCUMEN,DTOS(SE5->E5_DATA) })
				Else
					aAdd(aLstDOC,{SE5->E5_FILIAL,SE5->E5_DOCUMEN,DTOS(SE5->E5_DATA)+SE5->E5_FORNADT+SE5->E5_LOJAADT+SE5->E5_SEQ })
				EndIf
			ElseIf 	Empty(SE5->E5_FORNADT)
				aAdd(aLstDOC,{xFilial("SE5"),SE5->E5_DOCUMEN,DTOS(SE5->E5_DATA)+SE5->E5_CLIFOR+SE5->E5_LOJA+SE5->E5_SEQ })
			Else
				aAdd(aLstDOC,{SE5->E5_FILIAL,SE5->E5_DOCUMEN,DTOS(SE5->E5_DATA)+SE5->E5_FORNADT+SE5->E5_LOJAADT+SE5->E5_SEQ })
			EndIf

			dbSelectArea( "SE5" )
			dbSkip()
		Enddo

		dbSelectArea( cAliasCmp )
		(cAliasCmp)->( dbSkip() )

	EndDo
	
	If Len(aLstDOC) == 0
		If !l330Auto
			If Len(aAdtVen) > 0	//	Único movimento de compensação foi o do faturamento
				Help( ,,"COMPFAT",,STR0082, 1, 0 )	// "Compensação gerada na inclusão do documento de saída com adiantamento, não pode ser excluída na compensação Contas a Receber(FINA330)."
			Else
				Help(" ",1,"NOTITSEL",,"" ,1,0,,,,,,{STR0130})
			EndIf
		Endif
		DeleteObject(oOk)
		DeleteObject(oNo)
		FA330aUnlock()
		lRetAuto := .F.
		Exit
	EndIf

	If SE1->E1_TIPO $ MV_CRNEG+"/"+MVRECANT
		cTipodoc := "CP"
	Else
		cTipodoc := "BA"
	EndIf

	//Motor de retenções
	If __lMotRet
		//Verifica as configurações de impostos pelo motor de retenção
		F330VldImp()		
		
		lRaRtImpMR := ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
		lPccBxCr := ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
		lIrPjBxCr := ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Procura adiantamentos do titulo original para      ³
	//³ montar lista de apresentacao                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	
	dbSelectArea("SE5")
	SE5->(dbSetOrder(2))	//E5_FILIAL, E5_TIPODOC, E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_DATA, E5_CLIFOR, E5_LOJA, E5_SEQ
	For nI := 1 to Len(aLstDOC)
		SE5->(dbSeek(aLstDoc[nI][1] + cTipoDoc + Substr(aLstDoc[nI][2],1,nTamTit+nTamTip) + Iif(!lLjOrigem .or. Len(aLstDoc[nI][3]) > 10,aLstDoc[nI][3],"") ))
		If (lF330ESE5)
			//-- Ponto de entrada para que o registro na SE5 seja posicionado corretamente
			//-- quando existir diferenças no tamanho dos campos envolvidos no indice do SEEK.
			ExecBlock("F330ESE5",.F.,.F.,{aLstDOC,cTipoDoc,nTamTit,nTamTip,nI})
		EndIf
		While SE5->(! Eof() .AND. SE5->E5_FILIAL == aLstDoc[nI][1] .AND.	;
					E5_TIPODOC + E5_PREFIXO + E5_NUMERO + E5_PARCELA+E5_TIPO == cTipoDoc + Substr(aLstDoc[nI][2],1,nTamTit+nTamTip) .AND. ;
					SubStr(DTOS(SE5->E5_DATA)+SE5->(E5_CLIFOR+E5_LOJA+E5_SEQ), 1, Len(aLstDoc[nI][3]) ) == aLstDoc[nI][3] )

			// se for compensacao gerado no momento da geracao do documento de saida, nao pode ser excluido na compensacao do Fina330.

			If lAdtVen
				If aScan(aAdtVen,{|x| x[1] = SE5->E5_DATA .and. ;
				x[2] = SE5->E5_VALOR .and. ;
				x[3] = SE5->E5_CLIFOR .and. ;
				x[4] = SE5->E5_LOJA.and. ;
				x[5] = SE5->E5_SEQ}) > 0
					dbSkip()
					Loop
				EndIf
			EndIf

			If (SE5->E5_MOTBX != "CMP" .Or. SE5->E5_RECPAG != "R")
				dbSkip( )
				Loop
			EndIf

			If lSE5ModExc .And. !Empty(__cFk1IdOri) .And. !VerFK1(SE5->E5_IDORIG) 
				dbSkip( )
				Loop
			EndIf

			//Verifica se tem baixa cancelada-
			If TemBxCanc(SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ),.T.,SE5->E5_FILIAL)
				SE5->(dbskip())
				Loop
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica Cliente se considerar Cliente Original 			³
			//³ na selecao de titulos 												³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If mv_par02 == 1 .and.  SE5->E5_CLIFOR != SE1->E1_CLIENTE
				dbSkip( )
				Loop
			EndIf
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica loja caso considere loja na selecao de titulos	  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If mv_par01 == 1 .and. mv_par02 == 1 .and.  SE5->E5_LOJA != SE1->E1_LOJA
				dbSkip( )
				Loop
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se a baixa e posterior a data do sistema    	  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SE5->E5_DATA > dDatabase
				dbSkip( )
				Loop
			EndIf

			//ANGOLA - Nao permitir compensar titulos de adiantamento relacionado a pedido

			If cPaisLoc == "ANG"
				FIE->(dbSetOrder(2))
				If FIE->(MsSeek(xFilial("FIE")+"R"+SE5->(E5_CLIFOR+E5_LOJA+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO)))
					dbSkip()
					Loop
				EndIf
			EndIf

			//Ponto de entrada para dispensar do cancelamento
			If lF330FLTC .and. ExecBlock("F330FLTC",.F.,.F.)
				dbSkip( )
				Loop
			EndIf

			If cTipoTit $ MV_CRNEG + "/" + MVRECANT
				If (lIsNCC .AND. !Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MV_CRNEG) .OR. (!lIsNCC .AND. !Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MVRECANT)
			 		SE5->(dbSkip())
					Loop
				Else
					If Substr(SE5->E5_DOCUMEN,1,nTamTit) # SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA)
						SE5->(dbSkip())
						Loop
					EndIf
				EndIf
			EndIf

			If !(cTipoTit $ MV_CRNEG + "/" + MVRECANT)
				If Substr(SE5->E5_DOCUMEN,1,nTamTit+nTamTip+nTamLoj) != cPrefixo+cNum+cParcela+cTipoTit+cLoja
					SE5->(dbSkip())
					Loop
				EndIf
			EndIf

			nOrdSE1	:= SE1->(IndexOrd())
			nRegSE1	:= SE1->(Recno())
			nTAbat 	:= SumAbatRec(cPrefixo,cNum,cParcela,SE1->E1_MOEDA,"V",dBaixa)
			
			If lPccBxCr
				nTAbat += FA330RetPCC(cPrefixo,cNum,cParcela,SE1->E1_MOEDA,dBaixa)
			EndIf

			SE1->(dbSetOrder(nOrdSE1))
			SE1->(dbGoto(nRegSE1))
			
			If lIrPjBxCr .And. ( !lRartimp .And. !lRaRtImpMR )
				nTAbat += SE1->E1_IRRF
			EndIf

			nVlLiqTit:= SE1->E1_VALOR - nTAbat		// Valor do titulo - Abatimentos
			Aadd( aTitulos,{ SE5->E5_PREFIXO,;
				SE5->E5_NUMERO,;
				SE5->E5_PARCELA,;
				SE5->E5_TIPO,;
				SE5->E5_LOJA,;
				DtoC(SE5->E5_DATA),;
				Substr(SE5->E5_DOCUMEN,1,nTamTit),;
				SE5->E5_SEQ,;
				Transform(nVlLiqTit,"@E 9999,999,999.99"),;
				Transform(SE5->E5_VLMOED2,"@E 9999,999,999.99"),;
				.T.,;
		    	SE1->E1_FILIAL,;
		    	SE5->E5_FILIAL,;
				if(lCredito,SomaAbat(SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA, "R", SE1->E1_MOEDA, dDataBase, SE5->E5_CLIFOR, SE5->E5_LOJA, Nil, Nil, SE5->E5_TIPO),0)})
			dbSelectArea( "SE5" )
			dbSkip()
		Enddo
	Next nI
	
	If Len(aTitulos) == 0
		If !l330Auto
			If Len(aAdtVen) > 0	//	Único movimento de compensação foi o do faturamento
				Help( ,,"COMPFAT",,STR0082, 1, 0 )	// "Compensação gerada na inclusão do documento de saída com adiantamento, não pode ser excluída na compensação Contas a Receber(FINA330)."
			Else
				Help(" ",1,"NOTITSEL",,"" ,1,0,,,,,,{STR0130})
			EndIf		
		Endif
		DeleteObject(oOk)
		DeleteObject(oNo)
		FA330aUnlock()
		lRetAuto := .F.
		Exit
	Else
		//Remove titulos duplicados, caso existam
		// Primeiro ordena o array para que a lógica faça mais sentido
		aSort( aTitulos , , , { |a,b| a[1]+a[2]+a[3]+a[4]+a[6]+a[8] > b[1]+b[2]+b[3]+b[4]+b[6]+b[8] } )
		If Len(aTitulos) > 1
			For nI := Len(aTitulos) to 1 Step -1
				For nX := 1 to Len(aTitulos[nI])
					cREG += IIf(!cValtoChar(nX) $ "6,11",IIf(ValType(aTitulos[nI,nX]) # "C",cValtoChar(aTitulos[nI,nX]),aTitulos[nI,nX]),"")
				Next nX
				If cREGAnt == cREG
					aTitulos[nI,11] := .F.
				Endif
    			cREGAnt := cREG
       			cREG := ""
			Next nI
			For nI := 1 to Len(aTitulos)
				If aTitulos[nI,11]
					aAdd(aTitulosTMP,aTitulos[nI])
					If !DtMovFin(CtoD(aTitulosTMP[Len(aTitulosTMP)][06]),.F.,"2")
						aTitulosTMP[Len(aTitulosTMP)][11] := .F.
					Endif
				Endif
			Next nI
			aTitulos := aClone(aTitulosTMP)
			aTitulosTMP := Array(0)
		Else
			If !DtMovFin(CtoD(aTitulos[Len(aTitulos)][06]),.F.,"2")
				aTitulos[Len(aTitulos)][11] := .F.
			EndIf
		EndIf
	EndIf

	nOpcA := 0

	//Metricas - Tela do cancelamento da compensação - FIM
	If __lMetric
		nRegistros := Len(aTitulos)

		If nRegistros > 0
			nFim := Seconds() - nInicio
			nFim := nFim / nRegistros

			SetFunName(__cFunMet)
			FwCustomMetrics():setAverageMetric(Alltrim(ProcName())+" - TempoEntrada", "financeiro-protheus_tempo-conclusão-processo_seconds", nFim)
			SetFunName(__cFunBkp)
		Endif
	Endif

	If !l330Auto

		//------------------------------------------
		// Mostra Titulos Compensados
		//------------------------------------------
		aSize := MsAdvSize(,.F.,400)
		DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],0 to aSize[6],aSize[5] of oMainWnd PIXEL
		oDLg:lMaximized := .T.

		@ 01.0,.5 LISTBOX oTitulo VAR cVarQ Fields;
			HEADER "",	STR0006,;  //"Prefixo"
			STR0007,;  //"N£mero"
			STR0008,;  //"Parcela"
			STR0009,;  //"Tipo"
			STR0011,;  //"Loja"
			STR0020,;  //"Data"
			STR0021,;  //"Documento"
			STR0022,;  //"Seq"
			STR0023,;  //"Valor do t¡tulo"
			STR0017 ;  //"Valor compensado"
			COLSIZES 12,GetTextWidth(0,"BBBBB")	,;
			GetTextWidth(0,"BBBBBBBBB")		   ,;
			GetTextWidth(0,"BBBBB")					,;
			GetTextWidth(0,"BBB")					,;
			GetTextWidth(0,"BBB")					,;
			GetTextWidth(0,"BBBBBB")				,;
			GetTextWidth(0,"BBBBBBBBBB")  		,;
			GetTextWidth(0,"BBB")					,;
			GetTextWidth(0,"BBBBBBBBBB")			,;
			GetTextWidth(0,"BBBBBBBBBB")			;
			SIZE 293,54.5 ON DBLCLICK (aTitulos := FA330marca(oTitulo:nAt,aTitulos,nOpc),oTitulo:Refresh())NOSCROLL

		oTitulo:bHeaderClick := {|oObj,nCol| If( nCol==1, fMarkAll(@aTitulos,,.T.),Nil), oTitulo:Refresh()}

		oTitulo:SetArray(aTitulos)
		oTitulo:bLine := { || {If(aTitulos[oTitulo:nAt,11],oOk,oNo),;
			aTitulos[oTitulo:nAt,1],aTitulos[oTitulo:nAt,2],;
			aTitulos[oTitulo:nAt,3],aTitulos[oTitulo:nAt,4],;
			aTitulos[oTitulo:nAt,5],aTitulos[oTitulo:nAt,6],;
			aTitulos[oTitulo:nAt,7],aTitulos[oTitulo:nAt,8],;
			aTitulos[oTitulo:nAt,9],aTitulos[oTitulo:nAt,10]}}

		oTitulo:Align := CONTROL_ALIGN_ALLCLIENT
		//---
		oPanel := TPanel():New(0,0,'',oDlg, oDlg:oFont, .T., .T.,, ,20,20,.T.,.T. )
		oPanel:Align := CONTROL_ALIGN_BOTTOM

		If lPanelFin  //Chamado pelo Painel Financeiro
			ACTIVATE MSDIALOG oDlg ON INIT FaMyBar(oDlg,;
			{||nOpca := 1, oDlg:End() },;
			{||nOpca := 0, oDlg:End() })
	   Else
			DEFINE SBUTTON FROM 4,325 TYPE 1 ACTION (nOpca := 1, oDlg:End()) ENABLE OF oPanel PIXEL
			DEFINE SBUTTON FROM 4,360 TYPE 2 ACTION (nOpca := 0, oDlg:End())  ENABLE OF oPanel PIXEL
			ACTIVATE MSDIALOG oDlg CENTERED ON INIT (oTitulo:Refresh())
			If ( nOpca == 0 )
				DeleteObject(oOk)
				DeleteObject(oNo)
				Exit
			EndIf
		EndIf
	Else
		nOpca := 1
	EndIf

	if l330Auto .AND. nOpcA == 0
		lRetAuto := .F.
		Exit
	endif

	If ( nOpcA == 1 )

		//Metricas - Gravação do cancelamento - INICIO
		If __lMetric
			nInicio := Seconds()
		Endif

		//Desinvertendo a selecao NF-Antecipacao
		If SE1->E1_TIPO $ MV_CRNEG+"/"+MVRECANT
			cTipodoc := "BA"
		Else
			cTipodoc := "CP"
		EndIf
		aTitulosTMP := aClone(aTitulos)
		aTitulos := Array(0)
		aAdd(aTamChav,__nTamPrf)
		aAdd(aTamChav,__nTamNum)
		aAdd(aTamChav,__nTamParc)

		(cAliasCmp)->(DbGoTop())
		DbSelectArea(cAliasCmp)
		While (cAliasCmp)->( !EOF() )
			dbSelectArea("SE5")
			SE5->(dbSetOrder(2))
			SE5->(dbSeek((cAliasCmp)->( E5_FILIAL ) + cTipoDoc + cPrefixo + cNum + cParcela + cTipoTit))
	       	While !SE5->(Eof()) .AND. (cAliasCmp)->( E5_FILIAL ) == SE5->E5_FILIAL .AND.	;
				SE5->E5_TIPODOC == cTipoDoc .AND. ;
				SE5->E5_PREFIXO == cPrefixo .AND. ;
				SE5->E5_NUMERO == cNum .AND. ;
				SE5->E5_PARCELA == cParcela

				// se for compensacao gerado no momento da geracao do documento de saida, nao pode ser excluido na compensacao do Fina330.
				If lAdtVen
					If aScan(aAdtVen,{|x| x[1] = SE5->E5_DATA .and. ;
					x[2] = SE5->E5_VALOR .and. ;
					x[3] = SE5->E5_CLIFOR .and. ;
					x[4] = SE5->E5_LOJA.and. ;
					x[5] = SE5->E5_SEQ}) > 0
						dbSkip()
						Loop
					EndIf
				EndIf

				If (SE5->E5_MOTBX != "CMP" .Or. SE5->E5_RECPAG != "R")
					dbSkip( )
					Loop
				EndIf
				
				//Verifica se tem baixa cancelada
				If TemBxCanc(SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ),.T., SE5->E5_FILIAL)
					SE5->(dbskip())
					Loop
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica Cliente se considerar Cliente Original 			³
				//³ na selecao de titulos 												³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If mv_par02 == 1 .and.  SE5->E5_CLIFOR != SE1->E1_CLIENTE
					dbSkip()
					Loop
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica loja caso considere loja na selecao de titulos	  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If mv_par01 == 1 .and. mv_par02 == 1 .and.  SE5->E5_LOJA != SE1->E1_LOJA
					dbSkip( )
					Loop
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se a baixa e anterior a data do sistema    	  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SE5->E5_DATA >dDatabase
					dbSkip( )
					Loop
				EndIf

				//Lista de tipos de Adiantamento e Notas de Crédito
				cTipos 	:= MV_CRNEG + "," + MVRECANT
				nT 		:= 0 //Step do nX

				For nX := 1 To Len(cTipos)

					For nY := nX to Len(cTipos)
						If IsAlpha(SubStr(cTipos,nY,1))
							cTipoAux += SubStr(cTipos,nY,1)
							nT++
						Else
							Exit
						Endif
					Next nY

					If Len(aTipos) == 0 .Or. aScan(aTipos,{|x| x == cTipoAux}) == 0
						aAdd(aTipos, cTipoAux)
					Endif

					cTipoAux := ""
					nX += nT
					nT := 0

				Next nX

				If !cTipoTit $ cTipos	//Nota fiscal
					//Caso seja uma NF vinculada a uma NCC ou RA
					For nX := 1 to Len(aTipos)
						If aTipos[nX] $ SE5->E5_DOCUMEN
							lVinculo := .T.
							Exit
						Endif
					Next nX

					If lVinculo
						If aScan(aTitulosTMP,{|x|(AllTrim(x[4]) $ cTipos) .AND. ;		//Tipo
							x[1] == Substr(SE5->E5_DOCUMEN,1,aTamChav[1]) .AND. ;				//Prefixo
							x[2] == Substr(SE5->E5_DOCUMEN,aTamChav[1]+1,aTamChav[2]) .AND. ;	//Numero
							x[3] == Substr(SE5->E5_DOCUMEN,aTamChav[1]+aTamChav[2]+1,aTamChav[3]) .AND. ;	//Parcela
							x[8] == SE5->E5_SEQ .AND. x[11] == .T. .and. x[13]==SE5->E5_FILIAL}) == 0												//Selecionado
							SE5->(dbSkip())
							Loop
						Endif
					Endif
				Else        //Antecipacao
					//Caso o titulo original seja de atencipacao e o tipo do registro atual seja diferente, sair
					If SE5->E5_TIPO # cTipoTit
						SE5->(dbSkip())
						Loop
					Else
						If aScan(aTitulosTMP,{|x| 	x[1] == Substr(SE5->E5_DOCUMEN,1,aTamChav[1]) .AND.;
							 x[2] == Substr(SE5->E5_DOCUMEN,aTamChav[1]+1,aTamChav[2]) .AND.;
							 x[3] == Substr(SE5->E5_DOCUMEN,aTamChav[1]+aTamChav[2]+1,aTamChav[3]) .AND.;
	 						 x[8] == SE5->E5_SEQ .AND. x[11]==.T. .and. x[13]==SE5->E5_FILIAL}) == 0
							SE5->(dbSkip())
							Loop
						EndIf
					EndIf
				EndIf
				nOrdSE1	:= SE1->(IndexOrd())
				nRegSE1	:= SE1->(Recno())
				nTAbat 	:= SumAbatRec(cPrefixo,cNum,cParcela,SE1->E1_MOEDA,"V",dBaixa)
				nTAbat 	+= Iif(lIrPjBxCr, SE5->E5_VRETIRF,0)
				SE1->(dbSetOrder(nOrdSE1))
				SE1->(dbGoto(nRegSE1))
				nVlLiqTit := SE1->E1_VALOR - nTAbat		// Valor do titulo - Abatimentos
				aDtMov	:=	{}
				aDtMov	:= {'','','','','',Dtoc(SE5->E5_DATA)}

				aAdd(aTitulos,{SE5->E5_PREFIXO,;
					SE5->E5_NUMERO,;
					SE5->E5_PARCELA,;
					SE5->E5_TIPO,;
					SE5->E5_LOJA,;
					DtoC(SE5->E5_DATA),;
					Substr(SE5->E5_DOCUMEN,1,nTamTit),;
					SE5->E5_SEQ,;
					Transform(nVlLiqTit,"@E 9999,999,999.99"),;
					Transform(SE5->E5_VLMOED2,"@E 9999,999,999.99"),;
					Iif(Fa330VldDt(aDtMov,nOpc),.T.,.F.),;
	 				    SE1->E1_FILIAL,;
	 				    SE5->E5_FILIAL})
				aAdd(aRegistros, SE5->(Recno()))
				SE5->(dbSkip())
			Enddo
			(cAliasCmp)->(dbSkip())
		Enddo

  		(cAliasCmp)->(DbCloseArea())

  		IF lF330ExComp
			lF330Exclui := (ExecBlock( "F330EXCOMP", .F., .F.,{aTitulos,aRegistros,nOpc}))
			If lF330Exclui = .F.
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Recupera a Integridade dos dados           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				dbSelectArea( "SE1" )
				dbSetOrder( 1 )
				dbSelectArea( "SE5" )
				dbSetOrder( 1 )
				dbGoTo( nReg )
				DeleteObject(oOk)
				DeleteObject(oNo)
				FA330aUnlock()
				Return
			Endif
		Endif

		Begin Transaction

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Inicializa a gravacao dos lancamentos do SIGAPCO          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		PcoIniLan("000016")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Volta o valor aos RAs/NCCs	³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SE5")
		dbSetOrder( 2 )
		nRegSE1 := SE1->(Recno())
		nValorBaix := 0
		nValBaix2 := 0
		nValCtb	:= 0
		lPadrao := VerPadrao(cPadrao)
		If lPadrao
			lFirst := .T.
		EndIf
		
		For nLaco := 1 to Len(aRegistros)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Para saber se o titulo foi selecionado para estorno eh  |
			//³ necessario analisar o titulo no vetor aTitulosTMP pois a|
			//| flag do vetor aTitulos foi refeita e somente o vetor    |
			//| aTitulosTMP possui a flag informada pelo operador na    |
			//| interface grafica.(Projeto MPE)-Correcao Estorno Parcial|
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nPosTit := aScan(aTitulosTMP,{ |x| Alltrim(x[7]) + Alltrim(x[8]) ==  Alltrim(aTitulos[nLaco,1]+aTitulos[nLaco,2]+aTitulos[nLaco,3]) + Alltrim(aTitulos[nLaco,8]) .and. x[1]+x[2]+x[3] == aTitulos[nLaco,7] .AND. x[13] == aTitulos[nLaco,13]})
			If nPosTit > 0
				lMarcado :=  ( aTitulosTMP[nPosTit,11] .And. aTitulos[nLaco,11] )
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Caso o titulo esteja selecionado para compensao...    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( lMarcado )
				lMarcado := .F.

				//Metricas - Gravação do cancelamento - Registros
				nGravados += 1

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ So monta o cabecalho do LP se acha pelo menos um³
				//³ registro marcado 										 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lFirst
					nHdlPrv := HeadProva( cLote,;
					                      "FINA330",;
					                      Substr( cUsuario, 7, 6 ),;
					                      @cArquivo )

					VALOR := 0
					lFirst:= .F.
				EndIf
				dbSelectArea("SE5")
				dbGoTo(aRegistros[nLaco])
				cDocumento	:= SubStr(SE5->E5_DOCUMEN,1,nTamTit+nTamTip)
				cSeq		:= SE5->E5_SEQ
				
				//Array usado para integração TIN
				If !lCredito 
					If nRecNf == 0 //grava no array as informações da NF
						nRecNf := SE1->( Recno() )
						cSE1Orig := SE1->E1_ORIGEM
						aAdd( aBxInteg, { SE5->E5_SEQ, SE5->( Recno() ), nRecNf, cSE1Orig } )
					Else
						aAdd( aBxInteg, { SE5->E5_SEQ, SE5->( Recno() ), nRecNf, cSE1Orig } )
					EndIf
				EndIf
				
				If lLjOrigem .Or. Empty(SE5->E5_FORNADT)	//executada por alguma rotina do SIGALOJA/FRT
					cCliAdt		:= Iif(Empty(SE5->E5_FORNADT) ,SE5->E5_CLIFOR,SE5->E5_FORNADT)
					cLojAdt		:= Iif(Empty(SE5->E5_LOJAADT), SE5->E5_LOJA, SE5->E5_LOJAADT)
				Else
					cCliAdt		:= SE5->E5_FORNADT
					cLojAdt		:= SE5->E5_LOJAADT
				EndIf
				//Acrescimos e Decrescimos do titulo principal
				If SE5->E5_VLJUROS > 0 .And. SE1->E1_ACRESC > 0
					nTitAcres	+= Round(NoRound(xMoeda(SE5->E5_VLJUROS,1,nMoeda,SE5->E5_DATA,3,,Fa330TxMd(nMoeda,SE5->E5_TXMOEDA,.T.)),3),2)
				Endif
				If SE5->E5_VLDESCO > 0 .And. SE1->E1_DECRESC > 0
					nTitDecre	+= Round(NoRound(xMoeda(SE5->E5_VLDESCO,1,nMoeda,SE5->E5_DATA,3,,Fa330TxMd(nMoeda,SE5->E5_TXMOEDA,.T.)),3),2)
				Endif
				
				//Desconto Financeiro do titulo principal
				If l330DESC
					lDESC := ExecBlock("F330DESC",.F.,.F.)
					If SE5->E5_VLDESCO > 0 .And. lDESC
						nDescP := IIf(SE1->E1_DESCFIN > 0 .And. SE1->E1_VENCREA-SE5->E5_DATA >= SE1->E1_DIADESC .and. SE1->E1_DESCONT != 0,SE1->E1_VALOR * (SE1->E1_DESCFIN/100),0)
					EndIf
				EndIf
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Localiza o t¡tulo RA/NCC correspondente			 ³
				//³ Para cancelar a baixa									 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Inicializa a chave de pesquisa com  ³
				//³ a filial padrÆo. Caso seja utilizada³
				//³ compensaÆo em outras filiais, ir   ³
				//³ utilizar-se do campo E5_FILORIG.    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cChaveSe1 := xFilial("SE1")+SubStr( SE5->E5_DOCUMEN ,1,nTamTit+nTamTip )
				If !Empty(SE5->E5_FILORIG) .And. ( !Empty( cFilFwSE1 ) .OR. !Empty( xFilial("SE1") ) )
					aDadosX := GetInfSE5(SE5->E5_DOCUMEN)
	                If (cTipoTit != aDadosX[4] .And. aDadosX[4] $ MV_CRNEG+"/"+MVRECANT) .OR. (cTipoTit $ MV_CRNEG+"/"+MVRECANT)
	    				cFilCred := FaPesqBx2(SE5->E5_FILIAL,aDadosX[1],aDadosX[2],aDadosX[3],cCliAdt,cLojAdt,aDadosX[4],SE5->E5_DATA,SE5->E5_SEQ,"R",SE5->E5_DOCUMEN,cTipoDc)
	    			Else
		      			cFilCred := FaPesqBx2(SE5->E5_FILIAL,aDadosX[1],aDadosX[2],aDadosX[3],SE5->E5_CLIFOR,aDadosX[5],aDadosX[4],SE5->E5_DATA,SE5->E5_SEQ,"R",SE5->E5_DOCUMEN,cTipoDc)
	    			EndIf
	    			If !Empty( cFilFwSE1 )
						cChaveSe1 := cFilCred+SubStr( SE5->E5_DOCUMEN ,1,nTamTit+nTamTip )
					Else
						cFilOld := cFilAnt
						cFilAnt := cFilCred
						cFilCred := xFilial("SE1")
						cChaveSe1 := cFilCred+SubStr( SE5->E5_DOCUMEN ,1,nTamTit+nTamTip )
						cFilAnt := cFilOld
					EndIf
				EndIf

				aDoctosSE5 := {}
				dbSelectArea("SE1")
				dbSetOrder(1)
				SE1->(dbSeek(cChaveSe1))
				nRecE1Dest := SE1->(Recno())
				lAchou := .F.
				
				//Motor de retenções
				If __lMotRet
					//Verifica as configurações de impostos pelo motor de retenção
					F330VldImp()		
					
					lRaRtImpMR 	:= ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
					lPccBxCr 	:= ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
					lIrPjBxCr 	:= ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
				EndIf
				
				// Localiza titulo referente ao cliente correto
				While !Eof() .And. Left(&(IndexKey()), Len(cChaveSe1)) == cChaveSe1
					// Encontrou o titulo do cliente
					If !Empty(cCliAdt) .and. mv_par02 == 1
						If (cCliAdt == SE1->E1_CLIENTE .And. ;
								cLojAdt == SE1->E1_LOJA)
							lAchou := .T.
							Exit
						EndIf
					Else
						lAchou := .T.
						Exit
					Endif
					DbSkip()
				Enddo

				// Se encontrou o titulo referente ao cliente correto, desfaz a compensacao
				If lAchou
					lUsaAbat := usaAbat(nReg)
					nSaldoBx := SE1->E1_SALDO
					cAdiantamento := Substr(SE5->E5_DOCUMEN,1,nTamTit+nTamTip)
					cLojaCmp      := If( Empty(Substr(SE5->E5_DOCUMEN,nTamTit+nTamTip+1,nTamLoj)),;
												SE5->E5_LOJA,Substr(SE5->E5_DOCUMEN,nTamTit+nTamTip+1,nTamLoj))

					If ( !lRartImp .Or. ( __lIrfMR .And. !lRaRtImpMR) ) .And. !lCredito .And. ( lUsaAbat .Or. lBq10925 ) .And. lIrPjBxCr 
						nIrrfPac += SE5->E5_VRETIRF
					EndIf

					RecLock("SE1", .F.)
					//----------------------------------------------------------------
					// a Verificacao da moeda  feita para que caso o RA tenha moeda
					// diferente do titulo principal, volte o valor correto ao saldo.
					//----------------------------------------------------------------
					nSe5Rec := SE5->( RECNO() )

					If ( !lRartImp .Or. ( __lPccMR .And. !lRaRtImpMR) )  .And. !lCredito .And. ( lUsaAbat .Or. lBq10925 ) .And. lPccBaixa
						nValPcc := 0
						nValPcc := SE5->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)
					Endif
					
					cIdOrig := SE5->E5_IDORIG

					SE5->( dbSetOrder(7) ) //E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ
					SE5->( dbSeek(aTitulos[nLaco][13]+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO+SE1->E1_CLIENTE+SE1->E1_LOJA+cSeq) )
					
					If lCredito //Grava no array as informações da NF
						aAdd( aBxInteg, { SE5->E5_SEQ, SE5->( Recno() ), SE1->( Recno() ), SE1->E1_ORIGEM } )
					EndIf

					//Motor de retenções - Exclui os títulos de impostos para o título principal, selecionado na browse
					If __lMotRet
						__nImpEst	:= FinRetBxMR("R", SE5->E5_IDORIG)
						aAreaFK7	:= FK7->(GetArea())
						FMRDelImp( "FK1", SE5->E5_IDORIG, 3 )
						RestArea(aAreaFK7)
					EndIf
		
					//Desconto Financeiro do titulo principal
					nDescD := 0
					If l330DESC
						lDESC := ExecBlock("F330DESC",.F.,.F.)
						If SE5->E5_VLDESCO > 0 .And. lDESC
							nDescD := IIf(SE1->E1_DESCFIN > 0 .And. SE1->E1_VENCREA-SE5->E5_DATA >= SE1->E1_DIADESC .and. SE1->E1_DESCONT != 0,SE1->E1_VALOR * (SE1->E1_DESCFIN/100),0)
						EndIf
					EndIf

					VALOR2 := 0
					VALOR3 := 0
					VALOR4 := 0
					VALOR5 := 0
					VALOR6 := 0
					VALOR7 := 0
					VALOR8 := 0
					VARIACAO := 0
					
					If cPaisLoc == "BRA"
						//Se o cancelamento da compensacao NAO partiu do Titulo de Credito
						If !lCredito
							lIsNcc := SE5->E5_TIPO $ MV_CRNEG
						Else
							// Desfaz comissoes calculadas para adiantamentos ou notas de credito
							If (MV_PAR06 == 1 .And. Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MV_CRNEG) .Or.;
								(MV_PAR13 == 1 .And. Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MVRECANT)
								aadd(aBaixas,{SE5->E5_MOTBX,SE5->E5_SEQ,SE5->(Recno())})
							EndIf
						EndIf

						If lPropBx .and. lCredito .And. cPaisLoc == "BRA" 
							If !lPccBxCr .And. !__lPccMR
								nAbat		+= SE5->E5_VRETPIS + SE5->E5_VRETCOF + SE5->E5_VRETCSL 
								nVretPis	:= SE5->E5_VRETPIS
								nVretCof	:= SE5->E5_VRETCOF
								nVretCsl	:= SE5->E5_VRETCSL
							EndIf
							If	!lIrPjBxCr .and. !__lIrfMR
								nAbat	+= SE5->E5_VRETIRF
								nVretIrf	:= SE5->E5_VRETIRF 
							EndIf
							nAbat		+= SE5->E5_VRETINS + SE5->E5_VRETISS
							nVretIns	:= SE5->E5_VRETINS
							nVretiss	:= SE5->E5_VRETISS
						EndIf
						
						//Cancelamento partiu de um adiantamento
						If lImpComp .and. lIsNcc .and. lPccBaixa
							nRecnoSE1 := IIF(!lCredito, nRecnoSE1,SE1->(RECNO()))
							//Acerto valor dos impostos - Tecnofibras
							F330ActImp(nRecnoSE1,SE5->E5_VALOR,0,0,.F.,lCredito,0)
						EndIf

						//-------------------------------------------------------------
						//ATUALIZO O SALDO DO TITULO COMPENSADO (aTitulos)				
						//-------------------------------------------------------------		
						RecLock("SE1", .F.)

						// Caso o titulo esteja totalmente baixado recupera os impostos para o saldo.
						nTotAbat 	:= 0
						cFilOld 	:= cFilAnt
						If lCredito .and. SE1->E1_SALDO==0
						    If lSE1Exclusivo
						   		cFilAnt := SE1->E1_FILIAL
						    Else
						   		If lGestao
						   			nRecSM0 := SM0->(Recno())
									If "E" $ FWSM0Layout() .Or. "U" $ FWSM0Layout()  //se tem empresa ou unidade de negocio no layout
										If ! ( Alltrim( SE1->E1_FILIAL ) $ cFilAnt )
											SM0->( dbGoTop() )
											While SM0->(!Eof() .and. M0_CODIGO == cEmpAnt .and. IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL ) <= "ZZZZZZ")
												cFilAnt := IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL )
												If Alltrim(SE1->E1_FILIAL) $ cFilAnt
													Exit
												EndIf
												SM0->( dbSkip() )
											EndDo
										EndIf
									EndIf
									SM0->( dbGoto(nRecSM0) )
								EndIf
						    EndIf
							//Tratamento de retorno do Pis Cofins - Tecnofibras
							If ( !lRaRtImp .Or. ( __lPccMR .And. !lRaRtImpMR) ) .Or. lIsNCC
								nTotAbat := SumAbatRec(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_MOEDA,"V",dBaixa)
							Else
								nTotAbat := 0
							Endif
						EndIf
						cFilAnt := cFilOld
						If !__lIrfMR .And. (lIrPjBxCr .and. SE1->E1_SALDO == 0) .or. SE5->E5_VRETIRF > 0
							nTotAbat+= SE5->E5_VRETIRF
						EndIf
						
						If lPccBaixa .And. !__lPccMR
							If !(SE5->E5_TIPO $ MVRECANT +'|'+ MV_CRNEG) .AND. ( lRaRtImp .Or. lRaRtImpMR .Or. lBQ10925 .or. lCredito )
								nTotAbat += SE5->E5_VRETPIS + SE5->E5_VRETCOF + SE5->E5_VRETCSL
							Endif
				  		EndIf
					  	If ( lRaRtImp .Or. lRaRtImpMR ) .And. lCredito
					  		nTotAbat+= SE5->E5_PRISS + SE5->E5_PRINSS
					  	EndIf
						If ( lRartimp .Or. lRaRtImpMR ) .And. lPccBxCr .And. !__lPccMR
							nVlNewPis += (  SE5->E5_VRETPIS )
							nVlNewCof += (  SE5->E5_VRETCOF )
							nVlNewCsl += (  SE5->E5_VRETCSL )
							nVlNewIrf += (  SE5->E5_VRETIRF )
						EndIf
						
						nAcresc := Round(NoRound(xMoeda(SE5->E5_VLACRES,1,SE1->E1_MOEDA,SE5->E5_DATA,3,,Fa330TxMd(SE1->E1_MOEDA,SE5->E5_TXMOEDA,.T.)),3),2)
						nDecres := Round(NoRound(xMoeda(SE5->E5_VLDECRE,1,SE1->E1_MOEDA,SE5->E5_DATA,3,,Fa330TxMd(SE1->E1_MOEDA,SE5->E5_TXMOEDA,.T.)),3),2)
						
						If lPropBx .and. lCredito
							If !lUsaAbat .and. ( !lRartImp .Or. ( (__lIrfMR .Or. __lPccMR ) .And. !lRaRtImpMR) )
								SE1->E1_SALDO += SE5->E5_VALOR
							Else
								SE1->E1_SALDO += SE5->E5_VALOR + nAbat
							EndIf
						ElseIf (SE1->E1_MOEDA > 1 .AND. nMoeda == 1) .or. (SE1->E1_MOEDA == 1 .AND. nMoeda > 1) .or. (SE1->E1_MOEDA > 1 .AND. nMoeda > 1) // nMoeda > 1
							SE1->E1_SALDO += SE5->E5_VALOR + nTotAbat
						ElseIf ( ( !lRartImp .Or. ( (__lIrfMR .Or. __lPccMR ) .And. !lRaRtImpMR ) ) .and. !lUsaAbat)
							SE1->E1_SALDO += SE5->E5_VALOR
						ElseIf SE1->E1_VALOR <> SE1->E1_SALDO
							SE1->E1_SALDO += SE5->E5_VALOR + nTotAbat
						EndIf
						IF __lMotRet  .and. __nImpEst > 0
							SE1->E1_SALDO += __nImpEst
						EndIf
 
						If !lCredito .and. lUsaAbat
							SE1->E1_SALDO += nValPcc + nIrrfPac
						EndiF

						nTotAbat := 0
						//Verifica se o titulo já possui impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
						nPisFin061	:=	0
						nCofFin061	:=	0
						nCslFin061	:=	0
						nIrfFin061	:=	0
						nVAbat		:=  0
						nRegSE5	:=	SE5->(Recno())
						nOrdSE5	:=	SE5->(IndexOrd())		
					
						If SE1->E1_TIPO <> MVRECANT .AND. SE1->E1_TIPO <> MV_CRNEG .And. (lPccBxCr .Or. lIrPjBxCr)
							dbSelectArea("SE5")
							SE5->(dbSetOrder(2)) //FILIAL + TIPODOC + PREFIXO + NUMERO + PARCELA + TIPO
							If SE5->(DBSeek(xFilial("SE5")+"BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
								While !SE5->(Eof()) .and. SE5->E5_FILIAL==xFilial("SE5") .And. ;
									SE5->E5_TIPODOC+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO=="BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO		
								
									If  ("FINA061" $ Subst(SE5->E5_HISTOR,1,7) .Or. "FINA891" $ Subst(SE5->E5_HISTOR,1,7)) .And. SE5->E5_MOTBX $ "PCC_IRF"						
										If Alltrim(SE5->E5_MOTBX) == "PCC"
										   nPisFin061	+= SE5->E5_VRETPIS
										   nCofFin061	+=	SE5->E5_VRETCOF
										   nCslFin061	+= SE5->E5_VRETCSL
										ElseIf Alltrim(SE5->E5_MOTBX) == "IRF"
										   nIrfFin061	+= SE5->E5_VRETIRF
										EndIf
									EndIf
									SE5->(DbSkip())		
							   EndDo
							EndIf
						EndIf
						SE5->(Dbgoto(nRegSE5))
						SE5->(Dbsetorder(nOrdSE5))
						
						//Cancelamento partiu de um adiantamento
						If lCredito
							If cPaisLoc == "BRA"
								If lIrPjBxCr 
									If EMPTY(SE5->E5_PRETIRF)
										VALOR2 := SE5->E5_VRETIRF
									EndIf
								EndIf
								/////////////////////
								//PCC Baixa CR          
								//Retorna para o saldo do titulo o valor retido do PCC
								If lPccBxCr .and. !lIsNcc
									nVlNf	:= SE1->E1_VALOR
									If SE5->E5_PRETPIS $ ' |7'
										If !( !lUsaAbat .and. ( !lRartImp .And. !lRaRtImpMR ) ) .and. !lBQ10925
											SE1->E1_SALDO += SE5->E5_VRETPIS
										EndIf
										VALOR3 := SE5->E5_VRETPIS
										nVlPis	+= SE5->E5_VRETPIS
									EndIf
									If SE5->E5_PRETCOF $ ' |7'
										If !( !lUsaAbat .and. ( !lRartImp .And. !lRaRtImpMR )) .and. !lBQ10925
											SE1->E1_SALDO += SE5->E5_VRETCOF
										EndIf
										VALOR4 := SE5->E5_VRETCOF
										nVlCof	+= SE5->E5_VRETCOF
									EndIf
									If SE5->E5_PRETCSL $ ' |7'
										If !( !lUsaAbat .and. ( !lRartImp .And. !lRaRtImpMR ) )  .and. !lBQ10925
											SE1->E1_SALDO += SE5->E5_VRETCSL
										EndIf
										VALOR5 := SE5->E5_VRETCSL
										nVlCsll	+= SE5->E5_VRETCSL
									EndIf
									If EMPTY(SE5->E5_PRETIRF)
										nVlIrrf	+= SE5->E5_VRETIRF
									EndIf							
									VALOR6 := SE1->E1_INSS
									//cancelar SFQ
									//Escluir titulos PCC
									If !__lPccMR
										FaDelSFQCR()
									EndIf
								Endif
							
								//Atualiza o status do titulo no SERASA
								If nSaldoBx == 0
									cChaveTit := SE1->E1_FILIAL + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
									cChaveFK7 := FINGRVFK7("SE1",cChaveTit,SE1->E1_FILORIG)
									F770BxRen("3","",cChaveFK7)
								EndIf
							EndIf

						EndIf
						//QUESTAO DE ARREDONDAMENTO
						If ABS(SE1->E1_VALOR - xMoeda(SE5->E5_VLMOED2,nMoeda,SE1->E1_MOEDA,SE5->E5_DATA,3) - (nTotAbat + nDecres - nAcresc + nDescD)) > 0  ;
						 .and. ABS(SE1->E1_VALOR - xMoeda(SE5->E5_VLMOED2,nMoeda,SE1->E1_MOEDA,SE5->E5_DATA,3) - (nTotAbat + nDecres - nAcresc + nDescD)) <= 0.0099999
							SE1->E1_SALDO := SE1->E1_VALOR
						EndIf
						SE1->E1_VALLIQ:= 0
						If (nPisFin061+nCofFin061+nCslFin061+nIrfFin061)> 0 
							//O Pcc neste momento já foi subtraido do valor do saldo faltando somente o IR.
							If !lUsaAbat
								SE1->E1_SALDO	-= (nIrfFin061+nPisFin061+nCofFin061+nCslFin061)
							EndIf
							SE1->E1_VALLIQ	+= nPisFin061+nCofFin061+nCslFin061+nIrfFin061		
						EndIf																																		
					Else
						If (MV_PAR06 == 1 .And. Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MV_CRNEG) .Or.;
							(MV_PAR13 == 1 .And. Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MVRECANT)
							aadd(aBaixas,{{SE5->E5_MOTBX,SE5->E5_SEQ,SE5->(Recno())}})
						EndIf
						RecLock("SE1", .F.)
						nDecs := MsDecimais(nMoeda)
						nTxMoeda := Round(SE5->E5_VALOR/SE5->E5_VLMOED2,2)
						If  Empty(SE5->E5_MOEDA)
							SE1->E1_SALDO  += Round(xMoeda(SE5->E5_VLMOED2,nMoeda,SE1->E1_MOEDA,SE5->E5_DATA,nDecs+1,nTxMoeda),nDecs)
							SE1->E1_VALLIQ -= Round(xMoeda(SE5->E5_VLMOED2,nMoeda,1,SE5->E5_DATA,nDecs1+1,nTxMoeda),nDecs1)
						Else
							SE1->E1_VALLIQ:= 0
							If (SE1->E1_MOEDA > 1 .AND. nMoeda == 1) .or. (SE1->E1_MOEDA == 1 .AND. nMoeda > 1) .or. (SE1->E1_MOEDA > 1 .AND. nMoeda > 1) // nMoeda > 1
								SE1->E1_SALDO += SE5->E5_VLMOED2
							Else
								SE1->E1_SALDO += SE5->E5_VALOR
							EndIf
						EndIf
						If  nMoeda <> SE1->E1_MOEDA   .And.  Abs(SE1->E1_SALDO - SE1->E1_VALOR) <= 0.01
							SE1->E1_SALDO := SE1->E1_VALOR
						EndIf
					EndIf
					
					SE5->( dbGoto(nSE5Rec) )
					If SUBSTR(SE5->E5_LA,1,1) == "S"
						If SE5->E5_MOEDA == '01'
							nValCtb += SE5->E5_VALOR 
						Else
							nValCtb += SE5->E5_VLMOED2
						EndIf
					EndIf
					nValorBaix	+= SE5->E5_VALOR + nTitDecre - nTitAcres + nDescD
					lAcrDecr 	:= Iif(nTitAcres <> 0 .or. nTitDecre <> 0,.T.,.F.) 
					nValBaix2	+= Iif(SE1->E1_MOEDA ==  VAL(SE5->E5_MOEDA),  SE5->E5_VLMOED2, SE5->E5_VALOR) + Round(NoRound(xMoeda(SE5->E5_VLDESCO - SE5->E5_VLJUROS,1,nMoeda,SE5->E5_DATA,3,,Fa330TxMd(nMoeda,SE5->E5_VLMOED2/SE5->E5_VALOR,lAcrDecr)),3),2)
					nValHist	:= SE5->E5_VALOR

					If lImpComp .and. lPccBaixa .And. !__lPccMR
						If !lCredito .and. SE1->E1_SALDO == 0
							nValorBaix	+= SE5->E5_VRETPIS + SE5->E5_VRETCOF + SE5->E5_VRETCSL
							nValBaix2	+= SE5->E5_VRETPIS + SE5->E5_VRETCOF + SE5->E5_VRETCSL
						EndIf
					EndIf
					If lIrPjBxCr .or. SE5->E5_VRETIRF > 0
						If !(SE5->E5_TIPO $ MVRECANT +'|'+ MV_CRNEG).AND. (lUsaAbat .or. ( lRaRtImp .Or. lRaRtImpMR ) )
					   		nVlrAbat	+= Iif( __lIrfMR .And. __nIrfCaMR > 0, __nIrfCaMR, SE5->E5_VRETIRF )
					   		nVAbat :=  SE5->E5_VRETIRF
						EndIf
					EndIf
					If lPccBaixa
						If !(SE5->E5_TIPO $ MVRECANT +'|'+ MV_CRNEG) .AND. ( lRaRtImp .Or. lRaRtImpMR .Or. lBq10925 .or. !lCredito) .And. !__lPccMR
					   		nVlrAbat	+= SE5->E5_VRETPIS + SE5->E5_VRETCOF + SE5->E5_VRETCSL
					   		nVAbat 		+= SE5->E5_VRETPIS + SE5->E5_VRETCOF + SE5->E5_VRETCSL	
							SE1->E1_SALDO += nVAbat 		
							If ( !lRartImp .And. !lRaRtImpMR ) .and. lUsaAbat .and. SE1->E1_SALDO <> SE1->E1_VALOR //.and. lCredito
					   			If !lIrPjBxCr .and. nTabat > 0 .and. (SE1->E1_SALDO - SE5->E5_VALOR - nVlrAbat - nTabat == 0 .or. SE1->E1_SALDO + nTabat == SE1->E1_VALOR)
				   					SE1->E1_SALDO += nTabat
				   				EndIf
							EndIf
					   	ElseIf ( !lRartImp .And. !lRaRtImpMR ) .and. lUsaAbat .and. SE1->E1_SALDO <> SE1->E1_VALOR .and. !__lIrfMR
					   		SE1->E1_SALDO += nVAbat
					   		If !lIrPjBxCr .and. nTabat > 0 .and. (SE1->E1_SALDO - SE5->E5_VALOR - nVlrAbat - nTabat == 0 .or. SE1->E1_SALDO + nTabat == SE1->E1_VALOR)
				   				SE1->E1_SALDO += nTabat
				   			EndIf
						EndIf
					EndIf
					If lPropBx .and. !lCredito .And. cPaisLoc == "BRA"
						If !lPccBxCr .And. !__lPccMR
							nAbat		+= SE5->E5_VRETPIS + SE5->E5_VRETCOF + SE5->E5_VRETCSL 
							nVretPis	:= SE5->E5_VRETPIS
							nVretCof	:= SE5->E5_VRETCOF
							nVretCsl	:= SE5->E5_VRETCSL
						EndIf
						If	!lIrPjBxCr .And. !__lIrfMR
							nAbat		+= SE5->E5_VRETIRF
							nVretIrf	:= SE5->E5_VRETIRF 
						EndIf
						nAbat		+= SE5->E5_VRETINS + SE5->E5_VRETISS
						nVretIns	:= SE5->E5_VRETINS
						nVretiss	:= SE5->E5_VRETISS
					EndIf
					If ( lRaRtImp .Or. lRaRtImpMR )
						nVlrAbat	+= SE5->E5_PRISS + SE5->E5_PRINSS
					EndIf
					
					If cPaisLoc == "EUA" .And. SE1->(ColumnPos("E1_SLPLAID")) > 0
						SE1->E1_SLPLAID := SE1->E1_SALDO
					EndIf

					SE1->(MsUnlock())
					
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava lançamento no PCO ref titulo compensado apos canc. da compensacao   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					PCODetLan("000016","02","FINA330") //alteracao do titulo compensado

					nSe1Rec := SE1->(RECNO())
					//Se o cancelamento partiu do titulo de adiantamento, posiciono no titulo marcado na grid (titulos normais)
					If lCredito .AND. nRecE1Dest > 0
						SE1->(dbGoTo(nRecE1Dest))
					Endif
					cKeyAbt := SE1->(E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA)
					cFilSe1 := SE1->E1_FILIAL
					cTipo	:= SE1->E1_TIPO
					//Atualiza o status de viagem
					If (ALLTRIM(SE1->E1_ORIGEM) == "FINA677")
						FINATURES(SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA),.F.,SE1->E1_ORIGEM,"R")
					EndIf
					aAreaSE5 := SE5->(GetArea())
					aAreaSE1 := SE1->(GetArea())
					
					//Cancelamento da baixa dos abatimentos do titulo principal
					//quando cancelamento partiu do titulo de adiantamento
					If lCredito   //Se nao for titulo de adiantamento
						dbSelectArea("__SE1")
						__SE1->(dbSetOrder(2))
						__SE1->(dbSeek(cFilSE1+cKeyAbt))
						If lTitpaiSE1
  							__SE1->(DbSetOrder(nOrdTitPai))
							If	DbSeek(cChaveSe1+__SE1->E1_CLIENTE+__SE1->E1_LOJA)
								bWhile := {|| !Eof() .And. E1_FILIAL + Trim(E1_TITPAI) == Trim(cChaveSe1+__SE1->E1_CLIENTE+__SE1->E1_LOJA) }
							Else
					   			__SE1->(dbSetOrder(2))
					 			__SE1->(dbSeek(cFilSe1+cKeyAbt))
							Endif
						EndIf

						While Eval(bWhile)
							If lTitpaiSE1
								If !Empty(E1_TITPAI) .and.  (  trim(E1_TITPAI)!=trim(cAdiantamento+__SE1->E1_CLIENTE+__SE1->E1_LOJA) )
									DbSkip()
									Loop
								EndIf
							EndIf

							lPccComp := .T. //Verificando IR,INSS e ISS gerados na emissao ou PCC gerado na compensacao.
							If lPccBaixa
								aAreaSE5 	:= SE5->(GetArea())
								aAreaSE1	:=	SE1->(GetArea())

								cChaveSE5	:= xFilial("SE5") + If(SE1->E1_TIPO $ "COF/CSL/PIS","CP",Subst(SE1->E1_TITPAI,14,2)) + Subst(SE1->E1_TITPAI,1,3) + Subst(SE1->E1_TITPAI,4,9) +Subst(SE1->E1_TITPAI,13,1)
								If SE5->(dbSeek(cChaveSE5))
									If SE1->E1_TIPO $ "IR-/IN-/IS-" .AND. Alltrim(SE1->E1_SEQBX) <> Alltrim(SE5->E5_SEQ)
						  	  			lPccComp := .F.
									ElseIf SE1->E1_TIPO $ "COF/CSL/PIS" .AND. lPccBaixa //PCC gerado na compensacao.
										lBxCanc	:= TemBxCanc(SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ),.T.,SE5->E5_FILIAL)
										If (lBxCanc .AND. Alltrim(SE1->E1_SEQBX) == Alltrim(SE5->E5_SEQ)) //.OR. (!lBxCanc .AND. Alltrim(SE1->E1_SEQBX) <> Alltrim(SE5->E5_SEQ))
							 				lPccComp := .F.
							 			EndIf
									EndIf
								EndIf

								SE5->(RestArea(aAreaSE5))
								SE1->(RestArea(aAreaSE1))
							EndIf

							If (((__SE1->E1_TIPO $ "IR-|IN-|IS-|CF-|CS-|PI-" .AND. lPccBaixa .AND. lPccComp) .OR. __SE1->E1_TIPO $ MVABATIM ) .And. Alltrim(__SE1->E1_CLIENTE+__SE1->E1_LOJA) == Alltrim(SE1->E1_CLIENTE+SE1->E1_LOJA))
								//Tornar o abatimento aberto novamente somente caso o abatimento tenha sido baixado pela rotina

								nVlrAbat += E1_VALOR
								RecLock("__SE1")
								
								If !lPropBx
									Replace E1_SALDO	With E1_VALOR
								Else
									Do Case
										Case E1_TIPO $ MVPIABT .and. !lPCCBaixa
											Replace E1_SALDO	With (E1_SALDO + nVretPis)
										Case E1_TIPO $ MVCFABT .and. !lPCCBaixa 
											Replace E1_SALDO	With (E1_SALDO + nVretCof)
										Case E1_TIPO $ MVCSABT .and. !lPCCBaixa
											Replace E1_SALDO	With (E1_SALDO + nVretCsl)
										Case E1_TIPO $ MVIRABT .and. !lIrPjBxCr
											Replace E1_SALDO	With (E1_SALDO + nVretIrf)
										Case E1_TIPO $ MVINABT 				
											Replace E1_SALDO	With (E1_SALDO + nVretIns)
										Case E1_TIPO $ MVISABT   				
											Replace E1_SALDO	With (E1_SALDO + nVretIss)
									EndCase
								EndIf
								Replace E1_BAIXA	With CtoD("  /  /  ")
								Replace E1_STATUS	With "A"
								Replace E1_VALLIQ  With 0
								MsUnlock()
							EndIf
							dbSkip()
						EndDo
						__SE1->(dbSetOrder(1))
					EndIf
					dbSelectArea("SE1")
					dbGoto(nSE1Rec)
					
					If !__lIrfMR
						// Trecho irá deletar o titulo do IRF quando selecionada os titulos de adianamento para estorno					
						If lIrPjBxCr .And. !lRartImp
							FaDelSFQCR()
						Endif
					EndIf
					
					dbSelectArea("SE1")
					SE1->(dbSeek(cChaveSe1))

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Deleta a baixa do SE5	-  RA		³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					dbSelectArea("SE5")
					dbSetOrder(2)

					If (dbSeek(aTitulos[nLaco][13]+cTipodc+cDocumento))
						While ( 	!Eof() .And. SE5->E5_FILIAL == aTitulos[nLaco][13] .And. ;
								cDocumento ==	SE5->E5_PREFIXO+SE5->E5_NUMERO+;
								SE5->E5_PARCELA+SE5->E5_TIPO )
							If (  cSeq == SE5->E5_SEQ .And. cLojaCmp == SE1->E1_LOJA .And. ;
									SE1->E1_CLIENTE == SE5->E5_CLIFOR .and. ;
									Substr(SE5->E5_DOCUMEN,1,nTamTit+nTamTip)==cPrefixo+cNum+cParcela+cTipoTit ) .And. ;
									SE5->E5_TIPODOC <> "VA"

								AADD(aDoctosSE5,{SE5->E5_DOCUMEN,SE1->E1_CLIENTE,SE1->E1_LOJA,SE5->E5_SEQ})

								//Atualiza dados do Cliente - Adiantamento
								dbSelectArea("SA1")
								DbSetOrder(1)
								If dbSeek(xFilial("SA1")+SE5->E5_CLIFOR+SE5->E5_LOJA)
									If lGrvSa1	
										RecLock("SA1")
										nSaldoComp:=Round(xMoeda(SE5->E5_VLMOED2,nMoeda,SE1->E1_MOEDA,SE5->E5_DATA,nDecs+1,Fa330TxMd(nMoeda,nTxMoeda),Fa330TxMd(SE1->E1_MOEDA,nTxMoeda)),nDecs)
										If SE1->E1_TIPO $ MVRECANT +"/"+ MV_CRNEG
											AtuSalDup("-",nSaldoComp,nMoeda,SE1->E1_TIPO,,SE1->E1_EMISSAO)
										Else
						   		   			AtuSalDup("+",nSaldoComp,nMoeda,SE1->E1_TIPO,,SE1->E1_EMISSAO)
		   								EndIf
									EndIf
								EndIf

								nRecE1Dest := SE1->(Recno())
								nRecE5Dest := SE5->(Recno())

								RecLock("SE1")
								nAcresc := Round(NoRound(xMoeda(SE5->E5_VLACRES,1,SE1->E1_MOEDA,SE5->E5_DATA,3,,Fa330TxMd(SE1->E1_MOEDA,SE5->E5_TXMOEDA,.T.)),3),2)
								nDecres := Round(NoRound(xMoeda(SE5->E5_VLDECRE,1,SE1->E1_MOEDA,SE5->E5_DATA,3,,Fa330TxMd(SE1->E1_MOEDA,SE5->E5_TXMOEDA,.T.)),3),2)

								SE1->E1_STATUS:= IIF(SE1->E1_STATUS != "R",Iif(SE1->E1_SALDO > 0.01,"A","B"),"R")

								//E1_SALDO somou E5_VALOR no começo da rotina, desconsiderando acrescimo e decrescimo.
								If nAcresc > nSaldoComp //Caso o Acrescimo da NF seja maior que o valor compensado "RA", E1_SALDO do RA deve subtrair o valor compensado.
									SE1->E1_SALDO -= nSaldoComp
								Else
									SE1->E1_SALDO -= nAcresc
								Endif

								SE1->E1_SDDECRE += nDecres
								If SE1->E1_SDDECRE > SE1->E1_DECRESC
									SE1->E1_SDDECRE	:= SE1->E1_DECRESC
								EndIf

								If !(SE1->E1_TIPO $ MVRECANT)
									SE1->E1_SALDO += nDecres
								EndIf
								
								If nAcresc > nSaldoComp //Caso o Acrescimo da NF seja maior que o valor compensado "RA", E1_SDACRES do RA deve voltar ao seu valor original.
									SE1->E1_SDACRES += nSaldoComp
								Else 
									SE1->E1_SDACRES += nAcresc
								Endif
								
								// Desconto Financeiro
 								SE1->E1_SALDO += nDescD
								
								SE1->E1_DESCONT -= nDescD

								//Atualiza a variavel de acordo com o titulo posicionado
								lIrPjBxCr := FIrPjBxCr()

								If !__lIrfMR .And. lIrPjBxCr
									FaDelSFQCR()
								EndIf
								If cPaisLoc == "EUA" .And. SE1->(ColumnPos("E1_SLPLAID")) > 0
									SE1->E1_SLPLAID := SE1->E1_SALDO
								EndIf
								MsUnlock()

								// Desfaz comissoes calculadas para adiantamentos ou notas de credito
								If (MV_PAR06 == 1 .And. Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MV_CRNEG) .Or.;
									(MV_PAR13 == 1 .And. Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MVRECANT) 
									If cPaisLoc<>"BRA"
										aadd(aBaixas,{{SE5->E5_MOTBX,SE5->E5_SEQ,SE5->(Recno())}})
									Else
										aadd(aBaixas,{SE5->E5_MOTBX,SE5->E5_SEQ,SE5->(Recno())})
									EndIf
								EndIf
								
								VARIACAO := SE5->E5_VLCORRE
								
								If nOpc == 4  //Exclusao
									SE5->(DbSelectarea("SE5"))
									Fin330ExCM(SE5->E5_FILIAL, SE5->E5_SEQ)
								EndIf

								//Caso o registro posicionado do estorno seja de filial diferente da compensação, ajusto para correta gravação. 
								If cFilAnt # cFilCred .and. cFilAnt # SE5->E5_FILIAL
									lEstFdif := .T.
									If cPaisLoc == 'BRA' .And. cFilCred # SE5->E5_FILIAL
										cFilCred	:= SE5->E5_FILIAL
									EndIf
								EndIf
								
								//VA: Ajusta a SE5 e saldo do título para o movimento do VA
								If __l330Va
									FA330VACAN(SE5->E5_FILIAL, SE5->E5_IDORIG, SE1->(RECNO()), nOpc)
								EndIf

								//Ajusta o saldo do título caso fique maior que o valor.
								If (SE1->E1_VALOR+SE1->E1_ACRESC-SE1->E1_DECRESC) < (SE1->E1_SALDO+SE1->E1_SDACRES-SE1->E1_SDDECRE)
									RecLock("SE1", .F.)
									SE1->E1_SALDO := SE1->E1_VALOR
									SE1->(MsUnlock())
								EndIf

								//QUESTAO DE ARREDONDAMENTO
								nValAux :=  ABS(SE1->E1_VALOR - xMoeda(SE5->E5_VLMOED2,nMoeda,SE1->E1_MOEDA,SE5->E5_DATA,3) - (nTotAbat + nDecres - nAcresc + nDescD))
								If  ( nValAux <= 0.0099999 .And. nValAux > 0 ) .AND. !lLjOrigem
									If (nPisFin061+nCofFin061+nCslFin061+nIrfFin061) == 0
										SE1->E1_SALDO := SE1->E1_VALOR
									EndIf
								EndIf
								
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ So limpa a data da baixa se nao houver mais 	 ³
								//³ nenhum movimento para este titulo				 ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If NoRound( SE1->E1_VALOR, 2 ) == NoRound( SE1->E1_SALDO, 2 )
									RecLock("SE1", .F.)	
									SE1->E1_BAIXA := CtoD("  /  /  ")
									SE1->E1_CORREC := 0
									SE1->(MsUnlock())
								EndIf
								
								//Posiciona a FK1 para mandar a operação de alteração com base no registro posicionado da SE5
								If AllTrim( SE5->E5_TABORI ) == "FK1"
									If lEstFdif
										cFilOld := cFilAnt
										cFilAnt := cFilCred
									EndIf
									dbSelectArea( "FK1" )
									FK1->( DbSetOrder( 1 ) )
									If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
										oModelBA := FWLoadModel("FINM010")
										oModelBA:SetOperation( 4 ) //Alteração
										oModelBA:Activate()
										oSubFKA := oModelBA:GetModel( "FKADETAIL" )
										oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )
										oModelBA:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
										
										//E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK1
										//E5_OPERACAO 2 = Altera E5_TIPODOC da SE5 para 'ES' e gera estorno na FK1
										//E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK1
										
										//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
										cCamposE5 := '{'
										
										If !Empty( SE5->( FieldPos( "E5_MSEXP" ) ) ) 
											cCamposE5 += ",{'E5_MSEXP', ''}"
										EndIf
										
										If MV_PAR09 == 1 .and. !lUsaFlag
											oModelBA:SetValue( "MASTER", "E5_LA", "S " )
										EndIf

										If UsaSeqCor()
											cCamposE5 += ",{'E5_NODIA', ''}"
										EndIf
										cCamposE5 += "}"
											
										oModelBA:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1
										oModelBA:SetValue( "MASTER", "E5_OPERACAO",If(nOpc == 4, 3, 2) ) //E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK1
										oModelBA:SetValue( "MASTER", "HISTMOV" , STR0055 )
            
										//Integração PFS
										nSE5PFSTMP := SE5->(Recno())
										
										If oModelBA:VldData()
											oModelBA:CommitData()
											SE5->(dbGoto(oModelBA:GetValue( "MASTER", "E5_RECNO" )))
											
											If nOpc <> 4
	       										If MV_PAR09 == 1 .and. lUsaFlag
													aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->(RECNO()), 0, 0, 0} )
												EndIf

  								  				If UsaSeqCor()
					 								AAdd(aDiario,{"SE5",SE5->(RECNO()),SE5->E5_DIACTB,"E5_NODIA","E5_DIACTB"})
				  								EndIf
                                            Endif
										Else
											lRet := .F.
										    cLog := cValToChar(oModelBA:GetErrorMessage()[4]) + ' - '
									    	cLog += cValToChar(oModelBA:GetErrorMessage()[5]) + ' - '
	    							   		cLog += cValToChar(oModelBA:GetErrorMessage()[6])
							       			Help( ,,"M330VALID",,cLog, 1, 0 )
										EndIf	
										
										oModelBA:DeActivate()
										oModelBA:Destroy()
										oModelBA:= nil
									EndIf
									If lEstFdif
										cFilAnt := cFilOld
									EndIf
									
								EndIf
								
								// Grava lançamento no PCO ref canc. baixa do titulo compensado (Mov.Bancaria-SE5)
								PCODetLan("000016","06","FINA330")
							EndIf
							dbSelectArea("SE5")
							dbSkip()
						EndDo
					EndIf
					DbSelectArea("SE1")
					SE1->(DbSetOrder(1))
					
					If SE1->E1_TIPO $ MVRECANT
						aAlt :={}
						aadd( aAlt,{ STR0085,'','','',STR0086 +  Alltrim(Transform(nValHist,cPicE5Val)) })
				  		cFilOld := cFilAnt
						cFilAnt := SE1->E1_FILORIG
						FinaCONC(aAlt)
						cFilAnt	:= cFilOld
				  	EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Restaura o t¡tulo abatimento qdo houver    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cFilPai 	:= SE1->E1_FILIAL
					cChvCrPai 	:= TRIM(cFilPai + SE1->(E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO + E1_CLIENTE + E1_LOJA) )
					cCliLjPai 	:= SE1->E1_CLIENTE+SE1->E1_LOJA
					If SE1->(dbSeek(xFilial("SE1")+cPrefixo+cNum+cParcela,.F.))
						//Atualiza o status do titulo no SERASA
						If cPaisLoc == "BRA"
							If !lCredito
								If SE1->E1_SALDO == 0
									cChaveTit := SE1->E1_FILIAL + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
									cChaveFK7 := FINGRVFK7("SE1",cChaveTit,SE1->E1_FILORIG)
									F770BxRen("3","",cChaveFK7)
								EndIf
							EndIf
						EndIf
						
						cCliLoja 	:= Iif( lCredito, __SE1->E1_CLIENTE + __SE1->E1_LOJA, cCliente + cLoja )
						cChavePai 	:= Iif( lCredito, cChvCrPai, cChavePai )						
						aAlt 		:= {}
						aadd( aAlt,{ STR0085,'','','',STR0086 +  Alltrim(Transform(nValHist,cPicE5Val)) })
						///chamada da Função que cria o Histórico de Cobrança
						cFilOld := cFilAnt
						cFilAnt := SE1->E1_FILORIG
						FinaCONC(aAlt)
						cFilAnt	:= cFilOld
						If lTitpaiSE1
					 		If (nOrdTitPai:= OrdTitpai()) > 0
	   							SE1->(DbSetOrder(nOrdTitPai))
								If	SE1->( DbSeek( IIf(lCredito,cChavePai,FWxFilial("SE1") + cChavePai ) ))
									If lCredito 
										bWhile2 := {|| !Eof() .And. E1_FILIAL + Trim(E1_TITPAI) == cChavePai }
									Else 
										bWhile2 := {|| !Eof() .And. E1_FILIAL + Trim(E1_TITPAI) == FWxFilial("SE1") + cChavePai }
									EndIf
								Else
									SE1->(DbSetOrder(1))
								EndIf
							EndIf
						Else
							cFilSE1 := xFilial("SE1")
						EndIf
						
						DbSelectArea("SE1")
						While Eval(bWhile2)

							If lTitpaiSE1
								If !Empty(E1_TITPAI) .And. IF(lCredito, (cFilPai + E1_TITPAI != Trim(cChavePai)), (FWxFilial("SE1") + Trim(E1_TITPAI) != E1_FILIAL + Trim(cChavePai)))
									SE1->(DbSkip())
									Loop
								EndIf
							EndIf

							lPccComp := .T. //Verificando IR,INSS e ISS gerados na emissao ou PCC gerado na compensacao.
							If lPccBaixa
								aAreaSE5 	:= SE5->(GetArea())
								aAreaSE1	:=	SE1->(GetArea())

								cChaveSE5	:= xFilial("SE5") + If(SE1->E1_TIPO $ "COF/CSL/PIS","CP",Subst(SE1->E1_TITPAI,14,2)) + Subst(SE1->E1_TITPAI,1,3) + Subst(SE1->E1_TITPAI,4,9) +Subst(SE1->E1_TITPAI,13,1)
								If SE5->(dbSeek(cChaveSE5))
									If SE1->E1_TIPO $ "IR-/IN-/IS-" .AND. Alltrim(SE1->E1_SEQBX) <> Alltrim(SE5->E5_SEQ)
						  	  			lPccComp := .F.
									ElseIf SE1->E1_TIPO $ "COF/CSL/PIS" .AND. lPccBaixa //PCC gerado na compensacao.
										lBxCanc	:= TemBxCanc(SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ),.T.)
										If (lBxCanc .AND. Alltrim(SE1->E1_SEQBX) == Alltrim(SE5->E5_SEQ))
							 				lPccComp := .F.
							 			EndIf
									EndIf
								EndIf

								SE5->(RestArea(aAreaSE5))
								SE1->(RestArea(aAreaSE1))
							EndIf
							
							If (((SE1->E1_TIPO $ "COF/CSL/PIS/IR-/IN-/IS-/CF-/CS-/PI-/" .AND. lPccBaixa .AND. lPccComp) .OR. E1_TIPO $ MVABATIM ) .And.iIf(lCredito , Alltrim(cCliLjPai),AllTrim( cCliLoja )) == Alltrim(SE1->E1_CLIENTE+SE1->E1_LOJA))
								//Tornar o abatimento aberto novamente somente caso o abatimento tenha sido baixado pela rotina
								If cSeq <> SE1->E1_SEQBX .and. !Empty(SE1->E1_SEQBX)
									SE1->(dbSkip())
									Loop
								EndIf

								//Caso os impostos do PCC e IR sejam gerados na baixa devo exclui-los.
								If SE1->E1_TIPO $ ("COF/CSL/PIS") .AND. lPccBxCr
									If lExistFJU .AND. Alltrim(SE1->E1_ORIGEM) <> "FINA061"
										FingrvEx("R")
									EndIf	
									
									If !__lPccMR .AND. Alltrim(SE1->E1_ORIGEM) <> "FINA061"
										RecLock("SE1")
										dbDelete()
										MsUnlock()
									EndIf
								Else
									RecLock("SE1")
									If !lPropBx
										SE1->E1_SALDO := SE1->E1_VALOR
									Else
										Do Case
											Case SE1->E1_TIPO $ MVPIABT .and. !lPccBxCr
												SE1->E1_SALDO	+= nVretPis
											Case SE1->E1_TIPO $ MVCFABT .and. !lPccBxCr  
												SE1->E1_SALDO	+= nVretCof
											Case SE1->E1_TIPO $ MVCSABT .and. !lPccBxCr
												SE1->E1_SALDO	+= nVretCsl
											Case SE1->E1_TIPO $ MVIRABT .and. !lIrPjBxCr
												SE1->E1_SALDO	+= nVretIrf
											Case SE1->E1_TIPO $ MVINABT 				
												SE1->E1_SALDO	+= nVretIns
											Case SE1->E1_TIPO $ MVISABT   				
												SE1->E1_SALDO	+= nVretIss
										EndCase
									EndIf
									SE1->E1_VALLIQ:= 0
									If NoRound( SE1->E1_VALOR, 2 ) == NoRound( SE1->E1_SALDO, 2 )
										SE1->E1_BAIXA := CtoD("  /  /  ")
										SE1->E1_CORREC := 0
										nVlrAbat += SE1->E1_VALOR
									Else
										nVlrAbat += SE1->E1_VALOR-SE1->E1_SALDO
									EndIf
									SE1->E1_STATUS:= Iif(SE1->E1_SALDO>0.01,"A","B")
									MsUnlock()
								EndIf
							EndIf
							dbSelectArea("SE1")
							dbSkip()
						EndDo
					EndIf
				Else
					Exit
				EndIf

				If __l330VA .And. !lCredito .And. nValVA <> 0 

					nRecAntSe5:= SE5->(recno())
					nRecAntSe1:= SE1->(recno())

					SE5->(dbGoto(nSE5Rec))
					SE1->(dbGoto(nRegSE1))

				Else
					dbSelectArea("SE1")
					dbGoto(nRecE1Dest)

					dbSelectArea("SE5")
					dbGoTo(nRecE5Dest)
				EndIf

				If lPadrao .and. SUBSTR(SE5->E5_LA,1,1) == "S"  .and.  ( mv_par09 == 1 .Or. nOpc==4 ) // Contabilizar a exclusão mesmo que esteja para não contabilizar, pois não haverá registros para posicionar no modo off-line
					nTotal += DetProva( nHdlPrv,;
					                    cPadrao,;
					                    "FINA330",;
					                    cLote,;
					                    /*nLinha*/,;
					                    /*lExecuta*/,;
					                    /*cCriterio*/,;
					                    /*lRateio*/,;
					                    /*cChaveBusca*/,;
					                    /*aCT5*/,;
					                    /*lPosiciona*/,;
					                    @aFlagCTB,;
					                    /*aTabRecOri*/,;
					                    /*aDadosProva*/ )
				EndIf

				If __l330VA .And. !lCredito .And. nValVA <> 0 
					SE5->(dbGoto(nRecAntSe5))
					SE1->(dbGoto(nRecAntSe1))
				EndIf
				
				//Integração PFS
				If AllTrim(SE1->E1_TIPO) == "RA"
					nSE1PFSRA := SE1->(Recno())
					nSE1PFS   := nRegSE1
				Else
					nSE1PFSRA := nRegSE1
					nSE1PFS   := SE1->(Recno())
				EndIf

				dbSelectArea("SE1")
				dbGoto(nSE1Rec)

				dbSelectArea("SE5")
				dbGoTo(aRegistros[nLaco])
				
				nCMEst += SE5->E5_VLCORRE
				
				// Desfaz comissoes calculadas para adiantamentos ou notas de credito
				If (MV_PAR06 == 1 .And. Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MV_CRNEG) .Or.;
					(MV_PAR13 == 1 .And. Substr(SE5->E5_DOCUMEN,nTamTit+1,nTamTip) $ MVRECANT)
					If cPaisLoc<>"BRA"
						aadd(aBaixas,{{SE5->E5_MOTBX,SE5->E5_SEQ,SE5->(Recno())}})
					Else
						aadd(aBaixas,{SE5->E5_MOTBX,SE5->E5_SEQ,SE5->(Recno())})
					EndIf
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³  Apaga registro da movimentao  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				DbSelectArea("SE5")

				If E5_TIPO == "NF "
					AADD(aDoctosSE5,{SE5->E5_DOCUMEN,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ})
				EndIf

				If cPaisLoc == "BRA" .And. lIrPjBxCr .And. !lCredito
					If EMPTY(SE5->E5_PRETIRF) .And. !__lIrfMR
						nIrrf += SE5->E5_VRETIRF
					EndIf
				EndIf
				/////////////////////
				//PCC Baixa CR
				//Obtem valor dos impostos PCC retidos na compensacao
				If cPaisLoc == "BRA" .and. lPccBxCr .and. !lIsNcc .and. !lCredito .And. !__lPccMR
					If SE5->E5_PRETPIS $ ' |7'
						nPis += SE5->E5_VRETPIS
					EndIf
					If SE5->E5_PRETCOF $ ' |7'
						nCofins += SE5->E5_VRETCOF
					EndIf
					If SE5->E5_PRETCSL $ ' |7'
						nCsll += SE5->E5_VRETCSL
					EndIf
					nInss += SE1->E1_INSS
					nCtbInss += SE1->E1_INSS
					//Excluir relacionamentos SFP
					//Exclui titulos gerados
					If !__lPccMR
						FaDelSFQCR()
					EndIf
				EndIf

				If nOpc == 4  //Exclusao 
					Fin330ExCM(SE5->E5_FILIAL, SE5->E5_SEQ)
				EndIf								
						
				//Motor de retenções - Exclui os títulos de impostos gerados para os títulos compensados
				If __lMotRet
					__nImpEst := FinRetBxMR("R", SE5->E5_IDORIG)
					FMRDelImp( "FK1", SE5->E5_IDORIG, 3 )
				EndIf
				
				//VA: Ajusta a SE5 e saldo do título para o movimento do VA
				If __l330Va
					FA330VACAN(SE5->E5_FILIAL, SE5->E5_IDORIG, nReg, nOpc)
				EndIf
				//Ajusta o saldo do título caso fique maior que o valor.
				If (SE1->E1_VALOR+SE1->E1_ACRESC-SE1->E1_DECRESC) < (SE1->E1_SALDO+SE1->E1_SDACRES-SE1->E1_SDDECRE)
					RecLock("SE1", .F.)
					SE1->E1_SALDO := SE1->E1_VALOR
					SE1->(MsUnlock())
				EndIf
				//Posiciona a FK1 para mandar a operação de alteração com base no registro posicionado da SE5
				
				If AllTrim( SE5->E5_TABORI ) == "FK1"
					aAreaAnt := GetArea()
					If lEstFdif
						cFilOld := cFilAnt
						cFilAnt := cFilCred
					EndIf
					dbSelectArea( "FK1" )
					FK1->( DbSetOrder( 1 ) )
					If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
						oModelCP := FWLoadModel("FINM010")
						oModelCP:SetOperation( MODEL_OPERATION_UPDATE ) //Alteração
						oModelCP:Activate()
						//Posiciona a FKA com base no IDORIG da SE5 posicionada
            			oSubFKA := oModelCP:GetModel( "FKADETAIL" )
						oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } }) 

						oModelCP:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
						//E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK1
						//E5_OPERACAO 2 = Altera E5_TIPODOC da SE5 para 'ES' e gera estorno na FK1
						//E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK1
                        If nOpc <> 4
							//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
							cCamposE5 := '{'  
							
							If !Empty( SE5->( FieldPos( "E5_MSEXP" ) ) ) 
								cCamposE5 += ",{'E5_MSEXP', ''}"
							EndIf
														
							If MV_PAR09 == 1 .and. !lUsaFlag
								oModelCP:SetValue( "MASTER", "E5_LA", "S " )
							EndIf

							If UsaSeqCor()
								cCamposE5 += ",{'E5_NODIA', ''}"
							EndIf          
							cCamposE5 += '}'
							
						EndIf
						oModelCP:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1
						oModelCP:SetValue( "MASTER", "E5_OPERACAO",If(nOpc == 4, 3, 2) ) //E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK1
						oModelCP:SetValue( "MASTER", "HISTMOV" , STR0055 )

            			//Integração PFS
						If AllTrim(SE5->E5_TIPO) == "RA"
							nSE5PFSRA := SE5->(Recno())
							nSE5PFS   := nSE5PFSTMP
						Else
							nSE5PFSRA := nSE5PFSTMP
							nSE5PFS   := SE5->(Recno())
						EndIf
						
						If oModelCP:VldData()
							oModelCP:CommitData()
						
							// Integração PFS
							Aadd(aMovPFS, {nSE1PFS, nSE5PFS }) // SE1 e SE5 do título que está sendo estornado.
							Aadd(aMovPFS, {nSE1PFSRA, nSE5PFSRA })
							
							SE5->(dbGoto(oModelCP:GetValue( "MASTER", "E5_RECNO" )))

							If nOpc <> 4
	    						If MV_PAR09 == 1 .and. lUsaFlag                          
									aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->(RECNO()) , 0, 0, 0} )
								EndIf
    	
  		  						If UsaSeqCor()
									AAdd(aDiario,{"SE5",SE5->(RECNO()),SE5->E5_DIACTB,"E5_NODIA","E5_DIACTB"})
								EndIf

					   			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ PONTO DE ENTRADA NA ALTERACAO DO HISTORICO NA SE5 NO ESTORNO         ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
            					If lF330AE5E
            					   ExecBlock("F330AE5E",.F.,.F.)
               					EndIf

                            EndIf
						Else
							lRet := .F.
					    	cLog := cValToChar(oModelCP:GetErrorMessage()[4]) + ' - '
				    		cLog += cValToChar(oModelCP:GetErrorMessage()[5]) + ' - '
	    		  			cLog += cValToChar(oModelCP:GetErrorMessage()[6])
			   				Help( ,,"M330VALID",,cLog, 1, 0 )
						EndIf

						oModelCP:DeActivate()
						oModelCP:Destroy()
						oModelCP := nil
					
					EndIf
					If lEstFdif
						cFilAnt := cFilOld
					EndIf
					RestArea(aAreaAnt)
								
				EndIf
				
				// Grava lançamento no PCO ref canc. baixa do titulo compensado (Mov.Bancaria-SE5)
				If lPCO01605
					//Lançamento no PCO ref canc. baixa do titulo principal
					PCODetLan("000016", "05", "FINA330")
				Else
					//Lançamento no PCO ref canc. baixa do titulo compensado
					PCODetLan("000016", "06", "FINA330")											
				EndIf				

				// PONTO DE ENTRADA DE VALIDACAO DE EXCLUSAO/ESTORNO
          		If lF330VEEX
            	    ExecBlock("F330VEEX",.F.,.F.,{nOpc})
        	    EndIf
				lCancelou := .T.
          	EndIf

		Next nLaco				
				
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se foi gerado comisso e caso tenha sido, exclui     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cPaisLoc<>"BRA"
			AeVal(aBaixas,{|x|Fa440DeleB(x,.F.,.F.,"FINA330")})
		Else
			Fa440DeleB(aBaixas,.F.,.F.,"FINA330")
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ PONTO DE ENTRADA NA EXCLUSAO ANTES DA CONTABILIZACAO         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lFA330EAC
			ExecBlock("FA330EAC",.F.,.F.)
		EndIf
		
		nRegFK1	:=	FK1->(Recno())
		
		If lPadrao .and. lCancelou .and. !lFirst .and. nValCtb > 0
			VALOR  := nValCtb
			VALOR2 := nIrrf
			VALOR3 := nPis
			VALOR4 := nCofins
			VALOR5 := nCsll
			VALOR6 := nInss
			VALOR6 := nCtbInss
			VALOR7 := nTitDecre
			VALOR8 := nTitAcres
			VARIACAO := nCMEst 
			REGVALOR := nRegSE1

			dbSelectArea("SE1")
			SE1->(dbGoBottom())
			SE1->(dbSkip())
			SE5->(dbGoBottom())
			SE5->(dbSkip())
			dbSelectArea("FK1")
			FK1->(dbGoBottom())
			FK1->(dbSkip())
			
			nTotal += DetProva( nHdlPrv,;
			                    cPadrao,;
			                    "FINA330",;
			                    cLote,;
			                    /*nLinha*/,;
			                    /*lExecuta*/,;
			                    /*cCriterio*/,;
			                    /*lRateio*/,;
			                    /*cChaveBusca*/,;
			                    /*aCT5*/,;
			                    /*lPosiciona*/,;
			                    @aFlagCTB,;
			                    /*aTabRecOri*/,;
			                    /*aDadosProva*/ )

			RodaProva(  nHdlPrv,;
						nTotal)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Envia para Lanamento Cont bil                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			lDigita := IIF( mv_par07 == 1,.t., .f. )
			cA100Incl( cArquivo,;
			           nHdlPrv,;
			           3,;
			           cLote,;
			           lDigita,;
			           .F.,;
			           /*cOnLine*/,;
			           /*dData*/,;
			           /*dReproc*/,;
			           @aFlagCTB,;
			           /*aDadosProva*/,;
			           aDiario )
			aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

			VALOR  := 0
			VALOR2 := 0
			VALOR3 := 0
			VALOR4 := 0
			VALOR5 := 0
			VALOR6 := 0
			VALOR6 := 0
			VALOR7 := 0
			VALOR8 := 0
			VARIACAO := 0 
			REGVALOR := 0

			SE1->(dbSelectArea("SE1"))
			SE1->(dbGoTo(nRegSE1))
			SE5->(dbSelectArea("SE5"))
			SE5->(dbGoTo(nRegSE5))
			FK1->(dbSelectArea("FK1"))
			FK1->(dbGoTo(nRegFK1))
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Volta valor do titulo.		 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nValorBaix # 0 .or. nTitDecre # 0 .or. nTitAcres # 0 .or. nDescP # 0
			SE5->(dbGoTo(nRegSE5))
			SE1->(dbGoTo(nRegSE1))
			//Verifica se o titulo já possui impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
			nPisFin061	:=	0
			nCofFin061	:=	0
			nCslFin061	:=	0
			nIrfFin061	:=	0
			nRegSE5	:=	SE5->(Recno())
			nOrdSE5	:=	SE5->(IndexOrd())		
					
			If SE1->E1_TIPO <> MVRECANT .AND. SE1->E1_TIPO <> MV_CRNEG .And. (lPccBxCr .Or. lIrPjBxCr)
				dbSelectArea("SE5")
				SE5->(dbSetOrder(2)) //FILIAL + TIPODOC + PREFIXO + NUMERO + PARCELA + TIPO
				If SE5->(DBSeek(xFilial("SE5")+"BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
					While !SE5->(Eof()) .and. SE5->E5_FILIAL==xFilial("SE5") .And. ;
							SE5->E5_TIPODOC+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO=="BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO		
								
						If  ("FINA061" $ Subst(SE5->E5_HISTOR,1,7) .Or. "FINA891" $ Subst(SE5->E5_HISTOR,1,7)) .And. SE5->E5_MOTBX $ "PCC_IRF"						
							If Alltrim(SE5->E5_MOTBX) == "PCC"
							   nPisFin061	+= SE5->E5_VRETPIS
							   nCofFin061	+= SE5->E5_VRETCOF
							   nCslFin061	+= SE5->E5_VRETCSL
							ElseIf Alltrim(SE5->E5_MOTBX) == "IRF"
							   nIrfFin061	+= SE5->E5_VRETIRF
							EndIf
						EndIf
						SE5->(DbSkip())		
					EndDo
				EndIf
			EndIf						

			//--------------------------------------------------------
			//ATUALIZA SALDO DO TITULO DE PARTIDA DO CANCELAMENTO
			//--------------------------------------------------------
			Reclock("SE1")

			If !lCredito .And. SE1->E1_SALDO == 0 .and. !lPropBx
				SE1->E1_SALDO += Iif((lUsaAbat .Or. ( lRaRtImp .Or. lRaRtImpMR ) ),nVlrAbat,0) 
				If !( ( !lRartImp .And. !lRaRtImpMR ) .And. lUsaAbat .and. !lBq10925)
					lAtusalImp := .T.
				EndIf
			EndIf

			If !lCredito .and. SE1->E1_SALDO == 0
				nTotAbat := SumAbatRec(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_MOEDA,"V",dBaixa)
			Endif

			If SE1->E1_VALOR <> SE1->E1_SALDO
				SE1->E1_SALDO  += nValBaix2 + __nImpEst
			EndIf

			SE1->E1_VALLIQ := 0

			SE1->E1_SDDECRE := Iif (nTitDecre > 0, nTitDecre - nDescP, 0) 
			If nTitAcres > nSaldoComp //Caso o Acrescimo da NF seja maior que o valor compensado "RA", E1_SDACRES da NF deve voltar com o saldo que foi compensado ao invés de voltar com o valor do Acréscimo.
				SE1->E1_SDACRES += Iif (nTitAcres > 0, nSaldoComp - nDescP, 0)
			Else
				SE1->E1_SDACRES += Iif (nTitAcres > 0, nTitAcres - nDescP, 0)
			Endif 			
			SE1->E1_DESCONT -= nDescP
		
			If STR(SE1->(E1_VALOR - E1_SALDO),17,2) == STR(nTotAbat,17,2) .And. ( ( !lRaRtImp .And. !lRaRtImpMR ) .Or. (!lCredito .And. (lRaRtImp .And. !lRaRtImpMR ) ) )
				SE1->E1_SALDO += nTotAbat
			EndIf

			If nValBaix2 + nVlPis + nVlCof + nVlCsll == nVlNf .and. lCredito .and. ( !lRartImp .And. !lRaRtImpMR )
				SE1->E1_SALDO += (nVlPis + nVlCof + nVlCsll)
			ElseIf lUsaAbat .AND. ( !lRartImp .And. !lRaRtImpMR ) .and. SE1->E1_SALDO+nVlPis + nVlCof + nVlCsll + nVlIrrf == SE1->E1_VALOR
				SE1->E1_SALDO += (nVlPis + nVlCof + nVlCsll + nVlIrrf)
			ElseIf nValBaix2 + nVlPis + nVlCof + nVlCsll + nVlrAbat == nVlNf .and. lCredito .and. ( !lRartImp .And. !lRaRtImpMR )
				SE1->E1_SALDO += (nVlPis + nVlCof + nVlCsll + nVlrAbat)
			ElseIf lCredito .and. ( !lRartimp .And. !lRaRtImpMR )  .and. lUsaAbat .and. lBq10925
				SE1->E1_SALDO += (nVlPis + nVlCof + nVlCsll )
			EndIf
			
			If lPropBx .and. nAbat >0 .and. !lCredito .and. (( ( !lRartImp .And. !lRaRtImpMR ) .and. lUsaAbat) .or. ( lRartImp .Or. lRaRtImpMR ) )  
				SE1->E1_SALDO	+= nAbat
			EndIf
			
			If __lMotRet  .and. __nImpEst > 0
				SE1->E1_SALDO += __nImpEst
			EndIf 	

			/////////////////////
			//PCC Baixa CR
			//Retorna para o saldo do titulo o valor retido do PCC
			If lPccBaixa .and. !lIsNcc .and. !lCredito .AND. !lAtusalImp .and. lUsaAbat .And. !lRartImp .and. !lBq10925
				If nPis + nCofins + nCsll > 0
					SE1->E1_SALDO += nPis+nCofins+nCsll
				ElseIf nVlrAbat > 0
					SE1->E1_SALDO += nVlrAbat
				EndIf
			EndIf
		  	
			If (lIrPjBxCr .or. lPccBaixa) .AND. ( lRartImp .Or. lRaRtImpMR  .Or. lBQ10925 ) .and. !lCredito .AND. !lAtusalImp .and. !lPropBx 
				
				If lPccBaixa .And. nPis+nCofins+nCsll > 0
					SE1->E1_SALDO += nPis+nCofins+nCsll
				EndIf	

				If lIrPjBxCr .And. nIrrf > 0
					SE1->E1_SALDO += nIrrf
				EndIf
		
				If nPis+nCofins+nCsll+nIrrf > 0 .And. nPis+nCofins+nCsll+nIrrf <> nVlrAbat // gravo apenas a diferença
					SE1->E1_SALDO += (nVlrAbat  - (nPis+nCofins+nCsll+nIrrf)) 
				EndIF

			ElseIf !lIrPjBxCr .and. lPccBaixa .and. ( !lRartImp .And. !lRaRtImpMR ) .and. lBQ10925 .and. lCredito .and. !lAtusalImp .and. SE1->E1_SALDO < SE1->E1_VALOR
				If SE1->E1_TIPO == MVRECANT .And. SE1->E1_VALOR < SE1->E1_SALDO+nVlrAbat+RABxAnt()
				    SE1->E1_SALDO := SE1->E1_SALDO
				Else
					SE1->E1_SALDO += nVlrAbat
				EndIf
			EndIf

			If (nPisFin061+nCofFin061+nCslFin061+nIrfFin061)> 0 
				If !lUsaAbat
				  	SE1->E1_SALDO	-= nPisFin061+nCofFin061+nCslFin061+nIrfFin061		
				Endif  	
		  		SE1->E1_VALLIQ	+= nPisFin061+nCofFin061+nCslFin061+nIrfFin061		
			EndIf																				

			If !lAtusalImp
				SE1->E1_SALDO += nIrrfPac
			EndIf

			SE1->E1_STATUS:= IIF(SE1->E1_STATUS != "R",Iif(SE1->E1_SALDO > 0.01,"A","B"),"R")
			If SE1->E1_SALDO > SE1->E1_VALOR		// garantir que o saldo nao seja maior
				Replace E1_SALDO With E1_VALOR
			EndIf
			If NoRound( SE1->E1_VALOR, 2 ) == NoRound( SE1->E1_SALDO, 2 )
				SE1->E1_CORREC 	:= 0	
				SE1->E1_BAIXA 	:= CtoD("  /  /  ")
			EndIf

			If cPaisLoc == "EUA" .And. SE1->(ColumnPos("E1_SLPLAID")) > 0
				SE1->E1_SLPLAID := SE1->E1_SALDO
			EndIf

			MsUnlock()
			If (ALLTRIM(SE1->E1_ORIGEM) == "FINA677")
				FINATURES(SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA),.F.,SE1->E1_ORIGEM,"R")
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava lançamento no PCO ref titulo principal apos a cancelamento   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			PCODetLan("000016","01","FINA330")

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza Saldo do Cliente /  DP/NF  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aArea:=GetArea()
			dbSelectArea("SA1")
			DbSetOrder(1)
			If dbSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA)
				If lGrvSa1
					RecLock("SA1")
					nSaldoComp:=Round(xMoeda(nValBaix2,nMoeda,SE1->E1_MOEDA,SE5->E5_DATA,nDecs+1,Fa330TxMd(nMoeda,nTxMoeda),Fa330TxMd(SE1->E1_MOEDA,nTxMoeda)),nDecs)
					If lCredito
						AtuSalDup("-",nSaldoComp,nMoeda,SE1->E1_TIPO,,SE1->E1_EMISSAO)
					Else
						AtuSalDup("+",nSaldoComp,nMoeda,SE1->E1_TIPO,,SE1->E1_EMISSAO)
	  				EndIf
					MsUnlock()
				EndIf
			EndIf
			
			//Integração TIN x PROTHEUS
			If lEnvMU070 .And. Len( aBxInteg ) > 0 .And. !lEnvMU330 //Se o adapter de compensação estiver ativado para envio, então não manda a mensagem de baixa
				For nInt := 1 To Len( aBxInteg )
					If AllTrim( aBxInteg[nInt][4] ) == "FINI055"
						SE5->( dbGoTo( aBxInteg[nInt][2] ) )
						SE1->( dbGoTo( aBxInteg[nInt][3] ) )
			 		
						lOpcAux := ALTERA
						ALTERA := .F.
						cIntegSeq := SE5->E5_SEQ //Variável private que será utilizada no FINI070
						aRetInteg := FwIntegDef( "FINA070", , , , "FINA070" )
						ALTERA := lOpcAux
					
						//Se der erro no envio da integração, então faz rollback e apresenta mensagem em tela para o usuário
						If ValType( aRetInteg ) == "A" .And. Len( aRetInteg ) >= 2 .And. !aRetInteg[1]
							lRet := .F.
							Help( ,, "FINA330INTEGTIN",, STR0089 + AllTrim( aRetInteg[2] ), 1, 0,,,,,, {STR0088} ) //"O estorno da compensação não será concluído, pois ocorreu um erro na integração: ", "Verifique se a integração está configurada corretamente."
							DisarmTransaction()
							Exit
						Endif
						
					EndIf
				Next nInt
			EndIf
			
			RestArea( aArea )
			SE1->( dbGoTo( nRegSE1 ) )

		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ PONTO DE ENTRADA 															 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (ExistBlock( "FA330EXC" ) )
			ExecBlock("FA330EXC",.F.,.F.)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Finaliza a gravacao dos lancamentos do SIGAPCO            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		PcoFinLan("000016")

		End Transaction
		
		// Integração SIGAPFS x SIGAFIN
		If lRet .And. FindFunction("JCancBaixa") .And. FindFunction("JurDtBxCR")
			For nMovPFS := 1 To Len(aMovPFS)
				JCancBaixa( aMovPFS[nMovPFS][1]/*Recno SE1*/ , aMovPFS[nMovPFS][2]/*RECNO SE5*/,  JurDtBxCR(aMovPFS[nMovPFS][2])/*E5_DTDISPO*/ )
			Next nMovPFS
		EndIf
		
		//Metricas - Gravação do cancelamento - FIM
		If __lMetric .and. nGravados > 0
			nFim := Seconds() - nInicio
			nFim := nFim / nGravados

			SetFunName(__cFunMet)
			FwCustomMetrics():setAverageMetric(Alltrim(ProcName())+" - TempoGravacao", "financeiro-protheus_tempo-conclusão-processo_seconds", nFim)
			SetFunName(__cFunBkp)
		Endif

		Exit

	EndIf
EndDo

l330Auto := .F.

dbSelectArea( "SE1" )
SE1->(dbSetOrder(nOrdFilter)) // Devolvo para a ordem selecionada pelo cliente na Browser.
dbSelectArea( "SE5" ) 
dbSetOrder( 1 )
dbGoTo( nReg )
DeleteObject(oOk)
DeleteObject(oNo)
FA330aUnlock()

Return lRetAuto

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³Fa330Marca³ Autor ³ Alice Y Yamamoto 	    ³ Data ³ 08/04/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Marca os itens a serem excluidos 						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Fa330Marca												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fa330Marca(nIt,aArray,nOpc)

If (aArray[nIt,11] )
	aArray[nIt,11] := .F.
Else
	If Fa330VldDt(aArray[nIt],nOpc)
		aArray[nIt,11] := .T.
	EndIf
EndIf

Return aArray

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³Fa330OK	³ Autor ³ Marcos Patricio		³ Data ³ 19/12/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Confirma a marcacao dos titulos para compensacao.		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Fa330OK													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function FA330OK(nValTot As Numeric, lAutomato As Logical, lPccBxCR As Logical) As Logical
Local lMarcado 	As Logical 
Local nX	 	As Numeric
Local lRet		As Logical 
Local aAreaSE1 	As Array 

Default nValTot		 := 0 
Default lAutomato	 := .F.
Default lPccBxCR	 := FPccBxCr()

lMarcado	:= .T.
lRet		:=	.F.
aAreaSE1	:= {}

//Quando chamada da MATA465 se nao existe nada marcado da erro
If cPaisLoc <> "BRA"
	lMarcado	:=	.F.
	For nX	:=1 	To Len(aTitulos)
		If aTitulos[nX][8]
			//Forcar a saida do FOR
			lMarcado	:=	.T.
			nX	:=	Len(aTitulos)+1
		EndIf
	Next
EndIf

If !cPaisLoc $ "EUA|RUS"
	If !FA330SIT(aTitulos)
		Return(.F.)
	EndIf
EndIf

If !lAutomato
	If lMarcado
		lRet	:=	MsgYesNo(STR0024,STR0018)
	Else
		MsgAlert(STR0040,STR0018)
		lRet	:=	.F.
	EndIf
Else 
	lRet	:=	.T.
EndIf

If lRet  // Valida se o Saldo esta de acordo com o titulo. 
	nValTot := 0
	nValor  := IIf( nValor !=0 , 0 , nValor )

	For nX:=1 to Len(aTitulos)
		If aTitulos[nX,8]
			nValtot += Fa330VTit(aTitulos[nX,7])
			If lCredito .and. lRartImp .and. lPccBxCr 
				nValTot	-= Fa330VTit(aTitulos[nX,14])
				nValTot	-= Fa330VTit(aTitulos[nX,15])
				nValTot	-= Fa330VTit(aTitulos[nX,16])
			EndIf
		EndIf
	Next nX

	If nValTot == 0
		Help(" ",1,"NOTITSEL",,"" ,1,0,,,,,,{STR0131})
		lRet :=	.F.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o Vlr. Informado e'igual ao calculado.      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Str(nValtot,17,2) != Str(nValor,17,2) .and. nValor != 0 .And. nOpca == 1
		Help(" ",1,"FA330COMP")
		lRet	:=	.F.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o Vlr. Informado e'compativel com o Saldo.  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nValor := nValTot
	If Str(nValor,17,2) > Str(nSaldo,17,2)
		Help(" ",1,"FA330IVAL")
		lRet	:=	.F.
	EndIf

EndIf 

If ExistBlock("Fa330Vld") .and. lRet
	aAreaSE1 := SE1->(GetArea())
	SE1->(DbSetOrder(nIndVld))
	SE1->(DbGoTo(nRecVld))
	lRet := ExecBlock("Fa330Vld")
	RestArea(aAreaSE1)
EndIf

If UsaSeqCor()
	If !CTBvldDiario(cCodDiario,dDataBase)
		Return(.f.)
	EndIf
EndIf

Return lRet  //"Confirma marcao de T¡tulos ?"###"Ateno"
/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³Fa330Troca³ Autor ³ Marcos Patricio		³ Data ³ 19/12/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Troca o flag para marcado ou nao,aceitando valor.		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Fa330Troca												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function FA330Troca(nIt,aArray,oGet,lTodos,oTitulo,lMarkAll)
Local oDlg
Local nMinLim	:= 0
Local nOpca   	:= 0
Local nX       	:= 0
Local nAcresc  	:= 0
Local nY	   	:= 0
Local xy       	:= 0
Local nVezes   	:= 1
Local nOldIt   	:= nIt
Local lIrPjBxCr	:= FIrPjBxCr()
Local lPccBxCr	:= FPccBxCr()
Local nPosIr	:= 0
Local cLimite  	:= ''
Local cFilOld	:= ''
Local nValOld  	:= 0
Local nPos 	   	:= 0
LOCAL nTotAbat 	:= 0
Local aAreaSE1 	:= SE1->(GetArea())
Local nItemRA	:= 0
Local nItemOu	:= 0
Local lNcc		:= .F.
Local nVlMinImp := GetNewPar("MV_VL10925",5000)
Local nAltVal	:= 0
Local lBq10925	:= SuperGetMV("MV_BQ10925",,"2") == "1"
Local nVTit		:= 0
Local aArrAux	:= {}
Local nVlAbt	:= 0
Local lMSal		:= .F.
Local cOldVl	:= 0
Local nVlrSldPcc := 0
Local lRaRtImpMR := .F.
Local lIrfBxAux := lIrPjBxCr
Local lPccBxAux := lPccBxCr
Local aImpMRBrw := PegaVarMR()
Local nPosRec	:= 20
Local bEval		:= {|| ValType(aArray[nIt,26]) == 'C' }
Local cPicE1IRRF	:= PesqPict("SE1","E1_IRRF")
Local cPicE1PIS		:= PesqPict("SE1","E1_PIS")
Local cPicE1COF		:= PesqPict("SE1","E1_COFINS")
Local cPicE1CSL		:= PesqPict("SE1","E1_CSLL")
Local nValVa		:= 0
Local nBaseImp		:= 0
Local nVlRecAua		:= nValRec
Local nOldIr		:= 0
Local nOldBsIr		:= 0
Local nOldCalIr		:= 0
Local nVlConvPcc	:= 0
Local nParcNf		:= 0
Local nBasIRConv	:= 0
Local nVlIrConv		:= 0
Local nValImp		:= 0
Local nIrrfCon  	:= 0 
Local nTtPccCon 	:= 0 
Local nVlPccCon 	:= 0 
Local nSaldoCon 	:= 0 
Local nValorCon 	:= 0 
Local nSldConv		:= 0
Local nVlCruzCon 	:= 0 
Local nVlAltAnt  	:= 0 
Local nVlAltCmp		:= 0
Local nTotAbtCon	:= 0
Local oModelVA		:= Nil
Local lRetorno      := .F.
Local lMarca        := .T.
Local lTemImpPix    := .F.
Local nRecnoF71     := 0
Local cIdDocFK7     := ""

DEFAULT lMarkAll 	:= .F.
DEFAULT lTodos  	:= .F.

If cPaisLoc == "BRA" .And. !lTodos
	If MV_PAR02 == 2
		nPosRec	:= 23
	EndIf
	SE1->( dbGoTo( aArray[nIt, nPosRec] ) )
	lNcc	:= SE1->E1_TIPO $ MV_CRNEG .Or. __lCredNCC
EndIf

//Motor de retenções
If __lMotRet
	//Verifica as configurações de impostos pelo motor de retenção
	F330VldImp()
	
	lRaRtImpMR 	:= ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
	lPccBxCr 	:= ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
	lIrPjBxCr 	:= ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
EndIf

If dDataBase >= dLastPcc
	nVlMinImp	:= 0
EndIf

If MV_PAR02 == 2
	nPos := 25
    bEval := {|| ValType(aArray[nIt,29]) == 'C' }
Else
	nPos := 22
EndIf

If cPaisLoc == "BRA"
	cValor  := Fa330VTit(aTitulos[nIt,6 ])
	cSaldo  := Fa330VTit(aTitulos[nIt,nPos ])//Limite de Compensação
	cSalTit := Fa330VTit(aTitulos[nIt,6 ])
	cLimite := Fa330VTit(aTitulos[nIt,nPos]) //Limite de Compensação
	nVezes  := If(lTodos,Len(aArray),1)
	If mv_par02 == 1
		nAcresc := Fa330VTit(aTitulos[nIt,10])
		nValVa	:= Fa330VTit(aTitulos[nIt,If(__lMotRet,28,27)])
	Else
		nAcresc := Fa330VTit(aTitulos[nIt,13])
		nValVa	:= Fa330VTit(aTitulos[nIt,If(__lMotRet,31,30)])
	Endif
	If ( lPccBxCr .Or. lIRPJBxCr ) .And. ( lRaRtImp .Or. lRaRtImpMR )
		cValor  := Fa330VTit(aTitulos[nIt,Iif(MV_PAR02== 2, 25,22)])
	EndIf
Else
	cValor  := Fa330VTit(aTitulos[nIt,6 ])
	If mv_par02 == 1
		cSaldo  := Fa330VTit(aTitulos[nIt,14])
	Else
		cSaldo  := Fa330VTit(aTitulos[nIt,17])
	EndIf
	cSalTit := Fa330VTit(aTitulos[nIt,6 ])
	nVezes  := If(lTodos,Len(aArray),1)
EndIf

nValtot := 0
nVlComp := 0

For xy := 1 to Len(aTitulos)
	If aTitulos[xy,8] .And. xy <> nIt
		nVlComp += Fa330VTit(aTitulos[xy,7])
	EndIf
Next

nMinLim := Iif(nValor == 0, nSaldo, Min(nSaldo, nValor) )

cSaldo := Iif(cSaldo > (nMinLim - nVlComp), (nMinLim - nVlComp),cSaldo)
nValOld	:= cSaldo

For nY := 1 to nVezes
	nBaseImp   := 0
	lTemImpPix := .F.
	nRecnoF71  := 0		
	lMarca     := .T.
	nIt        := IIf(nVezes > 1, nY, nIt)
	
	If cPaisLoc == "BRA" .And. !aArray[nIt,8] .And. __lExcImpo .And. !__lCNABImp
		If lTodos
			nPosRec := IIf(MV_PAR02 == 2, 23, 20)
			SE1->(MsGoto(aArray[nIt,nPosRec]))
		EndIf
		
		If SE1->E1_SITUACA != "0"
			nRecnoF71 := F71Ativa(aArray[nIt,nPosRec])
			
			If nRecnoF71 > 0 .And. TtBxImpPix(aArray[nIt,nPosRec])
				lTemImpPix := !BorderoImp(SE1->E1_FILORIG, SE1->E1_NUMBOR, "R", SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA)
				
				If lTemImpPix
					If !__lNexbMsg
						lRetorno := IIf(l330Auto, __lMaTiPix, MsgTtBxPix(.F., lTodos, .T., @__lNexbMsg))
					EndIf
					
					If (lMarca := lRetorno)
						lTemImpPix := .F.
						cIdDocFK7  := FINBuscaFK7(SE1->(E1_FILIAL+"|"+E1_PREFIXO+"|"+E1_NUM+"|"+E1_PARCELA+"|"+E1_TIPO+"|"+E1_CLIENTE+"|"+E1_LOJA), "SE1", SE1->E1_FILORIG)						
						ExcluiImpo(SE1->E1_FILIAL, SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA, nRecnoF71)							
						PIXCancel(SE1->E1_FILIAL, cIdDocFK7)
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
	
	If nVezes > 1
		If !(cPaisLoc $ "RUS|EUA")
			cValor  := Fa330VTit(aTitulos[nIt,6])
			cSaldo  := Fa330VTit(aTitulos[nIt, If( cPaisLoc == "BRA", nPos, 14 ) ])
			cLimite := Fa330VTit(aTitulos[nIt,nPos])
			If ( lPccBxCr .Or. lIRPJBxCr ) .And. ( lRaRtImp .Or. lRaRtImpMR )
				cValor  := Fa330VTit(aTitulos[nIt,22])
			EndIf
		Else
			cValor  := Fa330VTit(aTitulos[nIt, 6])
			cSaldo  := Fa330VTit(aTitulos[nIt, 14])
			cLimite := Fa330VTit(aTitulos[nIt, 14])
		EndIf
	Endif

	If lMarkAll .And. lTodos
		aArray[nIt,8] := lMarca
	Else
		aArray[nIt,8] := IIf(!lTemImpPix, !aArray[nIt,8], .F.)
	EndIf

	If ( lPccBxCr .Or. lIRPJBxCr ) .And. ( lRaRtImp .Or. lRaRtImpMR ) .And. !lNcc
		aDadosRA1[9][nIt] := aArray[nIt,8]
	Endif

	If aArray[nIt,8]
		If FA330Lock(aArray[nIt,1]+aArray[nIt,2]+aArray[nIt,3]+aArray[nIt,4],,,aArray[nIt,Iif(MV_PAR02== 2, 16,13)])
			If !lTodos
				If cPaisLoc == "BRA"
					If aArray[nIt,4] $ MV_CRNEG .And. (mv_par08 == 1 .Or. ( lRaRtImp .Or. lRaRtImpMR ) )
						F330VALNCC(@aArray,nIt, cValor < cLimite, .T.)
						cSaldo  := nSaldo - nVlComp
					EndIf
					If cSaldo >= aArray[nIt,(nPos-1)]
						cLimite := Fa330VTit(aArray[nIt,nPos]) //Limite de Compensação
						cValor	:= Fa330VTit(aArray[nIt,nPos]) //Limite de Compensação
					Else
						If !lNcc .or. (lNCC .and. cValor > cSaldo)
							cLimite := cSaldo
							cValor	:= cSaldo
						EndIf
					EndIf
					If cLimite < cValor
						cValor	:= cLimite
					EndIf
					
					If __lMotRet
					
						If cPaisLoc == "BRA" .And. MV_PAR02 == 2
							nPosRec	:= 23
						EndIf
						SE1->( dbGoTo( aArray[nIt, nPosRec] ) )
						//Verifica as configurações de impostos pelo motor de retenção
						__lTCnfgMR := F330VldImp()
	
						lRaRtImpMR 	:= ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
						lPccBxCr 	:= ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
						lIrPjBxCr 	:= ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
	
						//Calcula os impostos pelo motor de retenções
						If __lTCnfgMR
							F330CalImp( SE1->E1_NATUREZ, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG, IIF(cSaldo == cLimite, cSalTit, cSaldo) , dDataBase, SE1->E1_TIPO )
							__lTCnfgMR	:= .F.
						EndIf
					EndIf

					If !lNcc
						cFilOld	:= ''
						If cFilAnt <> SE1->E1_FILORIG
							cFilOld	:= cFilAnt
							cFilAnt	:= SE1->E1_FILORIG
						EndIf
						If !__lPccMR
							If lPccBxCr
								If (!lRartimp .And. !SE1->E1_TIPO $ MVRECANT) 
								aArrAux 	:= aClone(aArray)
								nVlAbt 		:= SomaAbat(aArray[nIt][1],aArray[nIt][2],aArray[nIt][3],"R",,,SE1->E1_CLIENTE,,aArray[nIt][13])
								nVlrSldPcc  := DesTrans( aArrAux[nIt][nPos] ) 
								
								F330CalcPCC(nIt,aArrAux,@nVlrSldPcc,cValor < cLimite)
								
								If ( nVlAbt == 0 .Or. nVlAbt <> ( DesTrans(aArrAux[nIt][nPosPis]) + DesTrans(aArrAux[nIt][nPosCof]) + DesTrans(aArrAux[nIt][nPosCsl])) )
									If lBq10925 //Pcc Bruto
										nVlConvPcc := xMoeda((DesTrans(aArrAux[nIt][nPosPis]) + DesTrans(aArrAux[nIt][nPosCof]) + DesTrans(aArrAux[nIt][nPosCsl])),  1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
										If ( cValor + ( DesTrans(aArrAux[nIt][nPosPis]) + DesTrans(aArrAux[nIt][nPosCof]) + DesTrans(aArrAux[nIt][nPosCsl]) ) ) > Val(Replace(Replace(aArrAux[nIt][6],".", "" ), ",", ".")) //Verifica se é maior que Saldo do titulo							
											cValor     := ( nVlrSldPcc - nVlConvPcc )
											lMSal      := .T.
											nVlrSldPcc := DesTrans( aArray[nIt][nPos] )
										EndIf  
									Else //Pcc Liquido
										nVlConvPcc := xMoeda((DesTrans(aArrAux[nIt][nPosPis]) + DesTrans(aArrAux[nIt][nPosCof]) + DesTrans(aArrAux[nIt][nPosCsl])),  1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
										If cValor > ( nVlrSldPcc - nVlConvPcc )
											cValor     := ( nVlrSldPcc -  nVlConvPcc)
											lMSal      := .T.
											nVlrSldPcc := DesTrans( aArray[nIt][nPos] )
										EndIf
									EndIf
								EndIf
								ElseIf (lRartimp .And. SE1->E1_TIPO $ MVRECANT)
									nVlrSldPcc  := DesTrans( aArray[nIt][nPos] )
								EndIf
							EndIf	
							If lIrPjBxCr
								If !__lIrfMR
									nOldIr		:= nIrrf
									nOldBsIr	:= nIrfBase
									nOldCalIr	:= nIrfCalc
									If MV_PAR02 == 1
										If (!lRartimp .And. !SE1->E1_TIPO $ MVRECANT) 
											If lCredito .And. !lBq10925
												nParcNf := SE1->E1_VALOR - SE1->E1_SALDO
											Else
												nParcNf := nParciais
											EndIf

											nParcNf := xMoeda(nParcNf, IIF(!lBq10925, SE1->E1_MOEDA, nMoeda), 1, dDataBase, __nCasDec,  IIF(!lBq10925, __nTxMoedD, __nTxMoedP), 0)
											aArray[nIt,26] := Iif( Eval(bEval), Val(StrTran(Replace(aArray[nIt,26],".",""),",",".")), aArray[nIt,26])
											nBasIRConv := xMoeda(If(MV_PAR08 == 1 .And. aArray[nIt,26] > 0, aArray[nIt,26], nVlrSldPcc), nMoeda, 1, dDataBase, __nCasDec,  __nTxMoedP, 0)
											nIrrf := FCaIrBxCR(nBasIRConv,,(SE1->E1_VALOR <> SE1->E1_SALDO .And. lRaRtImp ),,,,nParcNf)
										EndIf
									Else
										aArray[nIt,29] := Iif( Eval(bEval), Val(StrTran(Replace(aArray[nIt,29],".",""),",",".")), aArray[nIt,29])
										nIrrf := FCaIrBxCR(If(MV_PAR08 == 1 .And. aArray[nIt,29] > 0, aArray[nIt,29], nVlrSldPcc),,(SE1->E1_VALOR <> SE1->E1_SALDO .And. lRaRtImp ) )
									EndIf
									If lCredito .And. !lNcc
										If !(SE1->E1_TIPO $ MVRECANT) .And. ( nIrrf != 0 .And. nOldIr > nIrrf )
											nIrrf		:= nOldIr
											nIrfBase	:= nOldBsIr 
											nIrfCalc	:= nOldCalIr
										EndIf
									EndIf
									aArray[nIt,nPosIrf] := Transf(nIrrf,cPicE1IRRF)
									aTitulos[nIt,nPosIrf]:= Transf(nIrrf,cPicE1IRRF)
									If (!lRartimp .And. !SE1->E1_TIPO $ MVRECANT) .And. (cValor + nPis + nCofins + nCsll + nIrrf >  Val(StrTran(Replace(aArray[nIt][6],".",""),",",".")) )
										nVlIrConv :=  xMoeda(Val(StrTran(Replace(aArray[nIt][nPosIrf],".",""),",",".")),  1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
										cValor := cValor - nVlIrConv
									EndIf
								EndIf
								aArray[nIt,nPosBIRF] := Transform(nVlrSldPcc,"@E 99,999,999.99")
							EndIf
						ElseIf MV_PAR08 == 1
							If lPccBxCr .And. ( !lRaRtImpMR ) // .And. SE1->E1_TIPO $ MVRECANT
								aArrAux 	:= aClone(aArray)
								nVlAbt 		:= SomaAbat(aArray[nIt][1],aArray[nIt][2],aArray[nIt][3],"R",,,SE1->E1_CLIENTE,,aArray[nIt][13])
								nVlrSldPcc  := DesTrans( aArrAux[nIt][nPos] ) 
								
								F330CalcPCC(nIt,aArrAux,@nVlrSldPcc,cValor < cLimite)
									
								If lBq10925 //Pcc Bruto
									If ( cValor + ( DesTrans(aArrAux[nIt][nPosPis]) + DesTrans(aArrAux[nIt][nPosCof]) + DesTrans(aArrAux[nIt][nPosCsl]) ) ) > Val(Replace(Replace(aArrAux[nIt][6],".", "" ), ",", ".")) //Verifica se é maior que Saldo do titulo							
										cValor     := ( nVlrSldPcc - ( DesTrans(aArrAux[nIt][nPosPis]) + DesTrans(aArrAux[nIt][nPosCof]) + DesTrans(aArrAux[nIt][nPosCsl]) ) )
										lMSal      := .T.
										nVlrSldPcc := DesTrans( aArray[nIt][nPos] )
									EndIf  
								Else //Pcc Liquido
									If cValor > ( nVlrSldPcc - ( DesTrans(aArrAux[nIt][nPosPis]) + DesTrans(aArrAux[nIt][nPosCof]) + DesTrans(aArrAux[nIt][nPosCsl]) ) )
										cValor     := ( nVlrSldPcc - ( DesTrans(aArrAux[nIt][nPosPis]) + DesTrans(aArrAux[nIt][nPosCof]) + DesTrans(aArrAux[nIt][nPosCsl]) ) )
										lMSal      := .T.
										nVlrSldPcc := DesTrans( aArray[nIt][nPos] )
									EndIf
								EndIf
							EndIf
						EndIf
						
						If !Empty(cFilOld)
							cFilAnt	:= cFilOld
						EndIf
						If __lMotRet
							aArray	[nIt,nPosxRet] := Transf(__nImpMR,cPicE1IRRF)
							aTitulos[nIt,nPosxRet] := Transf(__nImpMR,cPicE1IRRF)
							If __lIrfMR .And. lIrPjBxCr .And. MV_PAR08 == 1
								nIrrf := __nIrfCaMR
								aArray[nIt,nPosIrf] := Transf(nIrrf,cPicE1IRRF)
								aTitulos[nIt,nPosIrf]:= Transf(nIrrf,cPicE1IRRF)
							EndIf
							nValImp := xMoeda(nPis+nCofins+nCsll+nIrrf+__nImpMR,  1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
							If (!lRartimp .And. !SE1->E1_TIPO $ MVRECANT) .And. (cValor + nValImp >  Val(StrTran(Replace(aArray[nIt][6],".",""),",",".")) )
								cValor := cValor - ( Val(StrTran(Replace(aArray[nIt][nPosIrf],".",""),",",".")) + __nImpMR )
							EndIf
						EndIf
					EndIf
				EndIf
				
				If !cPaisLoc $ "EUA|RUS"
					If !FA330SIT(aTitulos,Iif(MV_PAR02 == 2, aTitulos[nIt,23],aTitulos[nIt,20]))
						aTitulos[nIt][8] := .F.
						Return(aTitulos)
					EndIf
				EndIf
				
				DEFINE MSDIALOG oDlg FROM  80,100 TO 183,393 TITLE STR0048 PIXEL Style DS_MODALFRAME //"Compensação CR"

				@ -3, 2 TO 22, 148 OF oDlg	PIXEL
				@ 6, 68 MSGET cValor Picture "@E 9999,999,999.99" VALID cValor <= cSaldo  .And. cValor > 0 SIZE 80, 10 OF oDlg PIXEL hasbutton
				@ 7, 9 SAY STR0014  SIZE 54, 7 OF oDlg PIXEL  //"Valor a compensar"

				If aArray[nIt,4] $ MV_CRNEG .Or. lNcc

					@ 22, 2 SAY STR0072  SIZE 140, 60 OF oDlg PIXEL //"Ao selecionar esse titulo os impostos calculados na baixa serão desconsiderados"

				EndIf

				DEFINE SBUTTON FROM 38, 094 TYPE 1 ENABLE ACTION (nOpca:=1,If((cValor <= cSaldo  .AND. cValor > 0 .AND. ;
																 If(cPaisLoc== "BRA", cValor<=cLimite, cValor <= cSalTit) .AND. ;
																 FA330Msg(.T.,If(lCredito,nValVa,__nValVa),nAcresc)),oDLg:End(),nOpca:=0)) OF oDlg // Quando a NF tenha Valor Acessório, apenas será possivel compensar caso o valor compesado seja maior ou igual a soma do Acréscimo e Valor Acessório.
				DEFINE SBUTTON FROM 38, 121 TYPE 2 ENABLE ACTION oDlg:End() OF oDlg

				ACTIVATE MSDIALOG oDlg
			Else
				nOpca := 1
			EndIf
			
			//retorna decimais do cValor caso ntxmoeda maior que tamanho padrao 
			If cValor == Fa330VTit(aTitulos[nIt,6]) .and. SE1->E1_MOEDA <> nMoeda
				
				nValVa		:= 0
				//VA: Calcula o valor acessório
				If __l330Va
					oModelVA	:= FWLoadModel("FINA070VA")
					nValVa		:= FA330VACAL(oModelVA)
				EndIf
			
				nDesFin := 0
				nAcresTit 	:= SE1->E1_SDACRES
				nDecresTit 	:= SE1->E1_SDDECRES
				nTitAbt		:= SumAbatRec(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA, SE1->E1_MOEDA, "V" )
				nVlTit		:= Iif(mv_par02 == 1,aTitulos[nIt,21], aTitulos[nIt,24])

				cValor  := xMoeda( nVlTit - nTitAbt + nAcresTit - nDecresTit - nDesFin + nValVa, SE1->E1_MOEDA,nMoeda,,5,SE1->E1_TXMOEDA,Fa330Tx2(nMoeda,nTxMoeda))
				cLimite := cValor

				If __l330Va
					oModelVa:Destroy()
					oModelVa := NIL
				EndIf

			EndIf

			If lMSal
				cOldVl := cValor
				cValor := nVlrSldPcc
			EndIf
			
			If 	nOpca == 0
				aArray[nIt,8] := .F.
				If ( lRaRtImp .Or. lRaRtImpMR ) .And. !lNcc .And. Type("aDadosRA1[9][nIt]") == "A"
					aDadosRA1[9][nIt] := .F.
				EndIf
				If aArray[nIt,4] $ MV_CRNEG .And. (mv_par08 == 1 .Or. ( lRaRtImp .Or. lRaRtImpMR ) ) .And. !Empty( cLimite )
					F330VALNCC(@aArray,nIt, cValor < cLimite, .F.)
					cSaldo  := nSaldo - nVlComp
					cLimite := Fa330VTit(aTitulos[nIt,Iif(cPaisLoc != "RUS",nPos,14)]) //Limite de Compensação
				EndIf
			EndIf
			
			If nOpca == 1
			
				If lCredito .And. SE1->E1_TIPO == MV_CRNEG
					If !cPaisLoc $ "EUA|RUS"
						dbSelectArea("SE1")
						If MV_PAR02 == 2
							dbGoTo(aArray[nIt,23])
						Else
							dbGoTo(aArray[nIt,20])
					    EndIf
				    EndIf
					nValAbat := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE,,SE1->E1_FILIAL)
					RestArea(aAreaSE1)
				EndIf
							
				//Pcc Baixa CR
				//Caso a compensacao tenha partido de um Adiantamento
				If lCredito .And. (SE1->E1_TIPO <> MV_CRNEG) .And. ( !lRaRtImp .And. !lRaRtImpMRt ) .And. cPaisLoc == "BRA"
					dbSelectArea("SE1")					 				
					If MV_PAR02 == 2
						dbGoTo(aArray[nIt,23])
					Else
				   		dbGoTo(aArray[nIt,20])
				    Endif
				    
					If mv_par08 == 1 .Or. ( lRaRtImp .Or. lRaRtImpMR )
						nTotAbat := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE,,SE1->E1_FILIAL)
						nValAbat := nTotAbat
					Else
						nTotAbat := 0
					Endif
					
					nOldValRec	:= nValOld
					If cValor > cLimite
						cValor := cLimite
					EndIf

					nBaseImp := FBaseImp(cValor)

					//Motor de retenções
					If __lMotRet
						//Verifica as configurações de impostos pelo motor de retenção

						lRaRtImpMR	:= ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
						lPccBxCr 	:= ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
						lIrPjBxCr 	:= ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
						
						//Calcula os impostos pelo motor de retenções

						F330CalImp( SE1->E1_NATUREZ, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG, nBaseImp, dDataBase, SE1->E1_TIPO, .T. )
						
						If nY == nVezes // Destrói o Model do MR
							FMRGetArr(,.T.)
						EndIf
						
						aArray	[nIt,nPosxRet] := Transf(__nImpMR,cPicE1IRRF)
						aTitulos[nIt,nPosxRet] := Transf(__nImpMR,cPicE1IRRF)
						If __lIrfMR .And. lIrPjBxCr
							nIrrf := __nIrfCaMR
							aArray[nIt,nPosIrf] := Transf(nIrrf,cPicE1IRRF)
							aTitulos[nIt,nPosIrf]:= Transf(nIrrf,cPicE1IRRF)
						EndIf								
					EndIf
					
					If ( lRartimp .Or. lRaRtImpMR ) .And. ( !( cValor + nPis + nCofins + nCsll == SE1->E1_SALDO ) )
						F330CalcPCC( nIt, aArray, @cValor + Iif( cValor == cSalTit, nTotAbat, 0 ), cValor < cLimite )
					EndIf

					If !__lPccMR .And. dDatabase <= dLastPcc
						If !lRaRtImp .and. mv_par08 == 1 .and. lPccBxCr .and. SE1->E1_TIPO <> MVRECANT .and. nPis+nCofins+nCsll+nIrrf > 0 .AND. aDadosret[1] < nVlMinImp .and. aDadosRet[1]+nValRec > nVlMinImp
		  					nProp	:= (aDadosret[1]+ nValRec) / nSaldo
							nPis	:= SE1->E1_PIS * nProp
							nCofins := SE1->E1_COFINS * nProp
							nCsll	:= SE1->E1_CSLL * nProp
						EndIf
					EndIf
				EndIf
								
				If cPaisLoc == "BRA"
					If !__lDizPer .Or. ( (cValor < cLimite) .Or. aArray[nIt,9] == 0 )
						If nMoeda <> SE1->E1_MOEDA .And. cValor == NoRound(xMoeda(SE1->E1_SALDO,SE1->E1_MOEDA,nMoeda,SE1->E1_EMISSAO,5,Fa330Tx2(nMoeda,nTxMoeda)),2) 
							aArray[nIt,9] := xMoeda(SE1->E1_SALDO,SE1->E1_MOEDA,nMoeda,SE1->E1_EMISSAO,5,Fa330Tx2(nMoeda,nTxMoeda))
						Else
							aArray[nIt,9] := Iif(lMSal .And. cValor > cOldVl,cOldVl,cValor)
						EndIf
					EndIf
					
					If lIrPjBxCr .And. lCredito .And. (SE1->E1_TIPO <> MV_CRNEG) 
						
						If MV_PAR02 == 2
							If !__lIrfMR
								nIrrf := Val(StrTran(Replace(aArray[nIt][nPosIrf],".",""),",",".")) //FCaIrBxCR(aArray[nIt,9],aArray[nIt,23])
							EndIf
							
							If ( nPosIr := aScan(aImpIR,{|x| x[2] == aArray[nIt,23]}) ) == 0
								aAdd( aImpIR, {nIrrf,aArray[nIt,23]} )
								nPosIr := Len( aImpIR )
							Else
								aImpIR[nPosIr][1] := nIrrf
							EndIf
						Else
							If !__lIrfMR
								nIrrf := Val(StrTran(Replace(aArray[nIt][nPosIrf],".",""),",","."))//FCaIrBxCR(aArray[nIt,9],aArray[nIt,20])
							EndIf
							
							If ( nPosIr := aScan(aImpIR,{|x| x[2] == aArray[nIt,20]}) ) == 0
								aAdd( aImpIR, {nIrrf,aArray[nIt,20]} )
								nPosIr := Len( aImpIR )
							Else
								aImpIR[nPosIr][1] := nIrrf
							EndIf
						EndIf
							
					EndIf

					If (lPccBxCr .Or. lIRPJBxCr) .And. ( lRaRtImp .Or. lRaRtImpMR ) .And. !lNcc
						dbSelectArea("SE1")
						If MV_PAR02 == 2
							dbGoTo(aArray[nIt,23])
						Else
				   			dbGoTo(aArray[nIt,20])
				    	Endif
				    	
						If lCredito
							nItemOU := aScan(aDadosRA1[2],{|x| x==SE1->(Recno())})
						Else
							nItemRA := aScan(aDadosRA1[1],{|x| x==SE1->(Recno())})
						EndIf
												
				        If !__lPccMR .And. !(aArray[nIt,4] $ MV_CRNEG)
							If F330RaRtIm(@aDadosRA1,cValor,nItemRA,nItemOu, cValor < cLimite )
								If lCredito
									nAltVal	:= cValor
									If nAltVal+nPis+nCofins+nCsll == SE1->E1_SALDO 
										nAltVal	:= nAltVal+nPis+nCofins+nCsll
									ElseIf nAltVal+aDadosRA1[3][nItemOU]+aDadosRA1[4][nItemOU]+aDadosRA1[5][nItemOU] == SE1->E1_SALDO
										nAltVal	:= nAltVal+aDadosRA1[3][nItemOU]+aDadosRA1[4][nItemOU]+aDadosRA1[5][nItemOU]
									EndIf
									If dDataBase >= dLastPcc .And. (cValor <> cLimite )
										If FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)
											aPcc	:= newMinPcc(dbaixa,nAltVal,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
											nPis	:= 	aPcc[2]
											nCofins	:=	aPcc[3]
											nCsll	:=  aPcc[4]
											If Len(aPcc) > 4 
												__aTitCalc := aPcc[5]
											EndIf
										EndIf
										If !__lIrfMR .And. lIrPjBxCr .And. cPaisLoc == "BRA"
											nIrrf := FCaIrBxCR( nAltVal )
										EndIf
										
										aDadosRA1[3][nItemOu]	:= nPis
										aDadosRA1[4][nItemOu]	:= nCofins
										aDadosRA1[5][nItemOu]	:= nCsll
											
									EndIf
									aArray[nIt,nPosPis]:=Transf(aDadosRA1[3][nItemOu],cPicE1PIS)
									aArray[nIt,nPosCof]:=Transf(aDadosRA1[4][nItemOu],cPicE1COF)
									aArray[nIt,nPosCsl]:=Transf(aDadosRA1[5][nItemOu],cPicE1CSL)
									If !__lIrfMR
										aArray[nIt,nPosIrf] := Transf(aDadosRA1[6][nItemOu],cPicE1IRRF)
									Else
										aArray[nIt,nPosIrf] := Transf( nIrrf, cPicE1IRRF)
									EndIf
									If dDataBase < dLastPcc
										If cValor < cLimite
											cValor := cValor - (aDadosRA1[3][nItemOu]+aDadosRA1[4][nItemOu]+aDadosRA1[5][nItemOu]+aDadosRA1[6][nItemOu];
													  +aDadosRA1[10][nItemOu]+aDadosRA1[11][nItemOu])
										EndIf
									Else
										If cValor < cLimite
											cValor := cValor - (nPis+nCofins+nCsll)
											If !__lIrfMR .And. lIrPjBxCr
												cValor	:= cValor - nIrrf
											EndIf
										EndIf
									EndIf
								Else
									nAltVal	:= cValor
									If nAltVal+nPis+nCofins+nCsll == SE1->E1_SALDO 
										nAltVal	:= nAltVal+nPis+nCofins+nCsll
									ElseIf nAltVal+aDadosRA1[3][nItemRA]+aDadosRA1[4][nItemRA]+aDadosRA1[5][nItemRA] == SE1->E1_SALDO
										nAltVal	:= nAltVal+aDadosRA1[3][nItemRA]+aDadosRA1[4][nItemRA]+aDadosRA1[5][nItemRA]
									EndIf
									If dDataBase >= dLastPcc .And. (cValor <> cLimite)
										If FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)
											aPcc	:= newMinPcc(dbaixa,nAltVal,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
											nPis	:= 	aPcc[2]
											nCofins	:=	aPcc[3]
											nCsll	:=  aPcc[4]
											If Len(aPcc) > 4 
												__aTitCalc := aPcc[5]
											EndIf
										EndIf
										If !__lIrfMR .And. lIrPjBxCr .And. cPaisLoc == "BRA"
											nIrrf	:= aDadosRA1[6][nItemRA]
										EndIf
											
										aDadosRA1[3][nItemRA]	:= nPis
										aDadosRA1[4][nItemRA]	:= nCofins
										aDadosRA1[5][nItemRA]	:= nCsll
												
									EndIf
									aArray[nIt,nPosPis]:=Transf(aDadosRA1[3][nItemRA],cPicE1PIS)
									aArray[nIt,nPosCof]:=Transf(aDadosRA1[4][nItemRA],cPicE1COF)
									aArray[nIt,nPosCsl]:=Transf(aDadosRA1[5][nItemRA],cPicE1CSL)
									If !__lIrfMR
										aArray[nIt,nPosIrf] := Transf(aDadosRA1[6][nItemRA],cPicE1IRRF)
										nIrrf := aDadosRA1[6][nItemRA]										
									Else
										aArray[nIt,nPosIrf] := Transf( nIrrf, cPicE1IRRF)
									EndIf
									If dDataBase < dLastPcc
										If cValor < cLimite
									   		cValor := cValor - (aDadosRA1[3][nItemRA]+aDadosRA1[4][nItemRA]+aDadosRA1[5][nItemRA]+aDadosRA1[6][nItemRA];
																+aDadosRA1[10][nItemRA]+aDadosRA1[11][nItemRA])
										Endif
									Else
										If cValor < cLimite
											cValor := cValor - (nPis+nCofins+nCsll)
											If !__lIrfMR .And. lIrPjBxCr
												cValor	:= cValor - nIrrf
											EndIf
										EndIf
									EndIf
								EndIf
								If !( nMoeda <> SE1->E1_MOEDA .And. cValor == NoRound(aArray[nIt,9], 2) )
									If !__lDizPer .Or. ( (cValor < cLimite) .Or. aArray[nIt,9] == 0 )
										aArray[nIt,9]	 := cValor
									EndIf
								EndIf
							EndIf
						ElseIf !(aArray[nIt,4] $ MV_CRNEG) // Pcc pelo Motor
							aArray[nIt,nPosPis] := Transf(nPis,		cPicE1PIS)
							aArray[nIt,nPosCof] := Transf(nCofins,	cPicE1COF)
							aArray[nIt,nPosCsl] := Transf(nCsll,	cPicE1CSL)
							If __lIrfMR
								aArray[nIt,nPosIrf] := Transf( nIrrf, cPicE1IRRF)
							EndIf
						EndIf
					EndIf
				EndIf
								
				If cPaisLoc != "RUS" .And. lPccBxCr .And. (( !lRartimp .And. !SE1->E1_TIPO $ MVRECANT) .Or. (lRartimp .And. SE1->E1_TIPO $ MVRECANT))
					nTotAbat := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE,,SE1->E1_FILIAL)
					If ((cValor <= cLimite .and. IIf(lRartimp .And. SE1->E1_TIPO $ MVRECANT,SE1->E1_SALDO,SE1->E1_SALDO - nPis -nCofins - nCsll - nTotAbat - __nImpMR ) <> cValor) .Or.;
					(SE1->(E1_PIS+E1_CSLL+E1_COFINS) > 0 .And. (nPis+nCofins+nCsll) == 0 .And. cValor <= cLimite .And. mv_par08 == 1)) //essa cond ocorre quando os tít são marca indiv, removido a seleç e depois selec todos.
						For nX:=1 to Len(aArray) // verifica todos os títulos ja marcados
							If	aArray[nX,8] 
								nVTit += Fa330VTit(aArray[nX,7])
							EndIf
						Next
						If lMSal
							cValor	:= cOldVl
						EndIf

						//Conversao dos valores para moeda do processo
						nIrrfCon  := xMoeda(Iif(lIrPjBxCr, nIrrf, 0), 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
						nTtPccCon := xMoeda(SE1->(E1_PIS + E1_COFINS + E1_CSLL), 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
						nVlPccCon := xMoeda(nPis + nCofins + nCsll, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
						nSaldoCon := Round(NoRound(xMoeda(SE1->E1_SALDO, SE1->E1_MOEDA, nMoeda, dDataBase, __nCasDec, __nTxMoedD, __nTxMoedP), __nCasDec), 2)
						nValorCon := Round(NoRound(xMoeda(SE1->E1_VALOR, SE1->E1_MOEDA, nMoeda, dDataBase, __nCasDec, __nTxMoedD, __nTxMoedP), __nCasDec), 2)

						__nProp := Round((cValor + nIrrfCon + nTtPccCon + SE1->E1_DECRESC + nTotAbat) / nSaldoCon, 2)
						If ( nVtit + cValor ==  nValorCon - nTtPccCon - nTotAbat ) .Or. ( nVtit + cValor == nValorCon - nVlPccCon - nTotAbat - __nImpMR )
							nAltVal := nSaldoCon - nVtit // se os titulos ja marcados + o titulo do momento for igual o liquido, deve calcular pelo restante do saldo.
						Else
							nAltVal := Iif(MV_PAR08==1 .Or. ( cPaisLoc == 'BRA' .And. __nProp == 1 ), (cValor + nIrrfCon + If(cPaisLoc == 'BRA' .And. __nProp == 1, nTtPccCon, 0 ) + SE1->E1_DECRESC + nTotAbat), cValor)
						EndIf
						
						If (aArray[nIt,4] $ MV_CRNEG .and.  nSaldoCon - nTotAbat == cValor) .or. (lNCC .and.  nSaldoCon - nValAbat == cValor ) .Or. ( nAltVal > nSaldoCon ) 
							//baixa total
							nAltVal := nSaldoCon
						EndIf
					
						nBaseImp := cValor + Iif(lRartimp, nVlPccCon+nIrrfCon,0)
					
						If cPaisLoc == 'BRA'  
							nAltVal := nBaseImp
						EndIf

						If dDataBase >= dLastPcc
							If !__lPccMR .And. FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)
								If SE1->E1_VLCRUZ > SE1->E1_BASEIRF
									nAltVal := xMoeda(nAltVal, nMoeda, 1, dDataBase, __nCasDec, __nTxMoedP, 0)
									aPcc	:= newMinPcc(dBaixa,FBaseRPCC(nAltVal),SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
							    Else
									nVlCruzCon := Round(NoRound(xMoeda(SE1->E1_VLCRUZ, SE1->E1_MOEDA, nMoeda, dDataBase, __nCasDec, __nTxMoedD, __nTxMoedP), __nCasDec), 2)
									nVlAltAnt  := nAltVal
									nAltVal    := Round(NoRound(xMoeda(nAltVal, nMoeda, 1, dDataBase, __nCasDec, __nTxMoedP, 0), __nCasDec), 2)
									nSldConv   := Round(NoRound(xMoeda(SE1->E1_SALDO, SE1->E1_MOEDA, nMoeda, dDataBase, __nCasDec, __nTxMoedD, __nTxMoedP), __nCasDec), 2)
									nTotAbtCon := Round(NoRound(xMoeda(nTotAbat, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP), __nCasDec), 2)
									
									If ( nVlCruzCon == ( nVlAltAnt + nVlPccCon+nIrrfCon )) .Or. ((nSldConv - nTotAbtCon) ==  ( nVlAltAnt + nVlPccCon+nIrrfCon ))
										nAltVal := FBaseRPCC(nAltVal)
									EndIf
								   	aPcc	:= newMinPcc(dBaixa,nAltVal,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
								EndIf
								nPis	:= 	aPcc[2]
								nCofins	:=	aPcc[3]
								nCsll	:=  aPcc[4]
								If Len(aPcc) > 4 
									__aTitCalc := aPcc[5]
								EndIf
							EndIf
														
							If !__lIrfMR .And. lIrPjBxCr .And. cPaisLoc == "BRA"
								nVlAltCmp	:= cValor
								If !lBq10925
									nVlAltCmp := cValor + xMoeda(nPis + nCofins + nCsll + IIf( lIrPjBxCr, nIrrf, 0 ), 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
								EndIf
								nIrrf	:= Iif(nVlAltCmp <> cLimite .And. !lRartimp , FCaIrBxCR( nAltVal ),nIrrf)
								aArray[nIt,nPosIrf]	:= Transf(nIrrf,cPicE1IRRF)
							EndIf
						EndIf
						
						If !lBq10925
							If !__lPccMR .Or. !__lIrfMR
								cValor := nAltVal
							
								If !__lPccMR
									cValor := cValor - nPis - nCofins - nCsll
								EndIf
								If !__lIrfMR
									cValor := cValor - Iif ( lIrPjBxCr, nIrrf, 0 )
								EndIf

								cValor := cValor - nTotAbat

								cValor := Round(NoRound(xMoeda(cValor, SE1->E1_MOEDA, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP),3),2)
							EndIf
						EndIf

						If cValor > cLimite
							cValor := cLimite
						EndIf						
						
						aArray[nIt,nPosPis]	:= Transf(nPis,cPicE1PIS)
						aArray[nIt,nPosCof]	:= Transf(nCofins,cPicE1COF)
						aArray[nIt,nPosCsl]	:= Transf(nCsll,cPicE1CSL)
					EndIf
				EndIf
				
				If lTodos .And. lPccBxCr .And. ( !lRaRtImp .And. !lRaRtImpMR ) .And. mv_par08 == 1
					aArray[nIt,7] := Transf((cValor-nPis-nCofins-nCsll),__cPiE1Sld)
					//Vld para ñ gerar mov.diferentes
					cValor := If(lBq10925, Val(StrTran(StrTran(aArray[nIt][7],".", ""),",",".")), cValor)
					If !( nMoeda <> SE1->E1_MOEDA .And. cValor == NoRound(aArray[nIt,9], 2) )
						If !__lDizPer .Or. ( (cValor < cLimite) .Or. aArray[nIt,9] == 0 )
							aArray[nIt,9]	 := cValor
						EndIf
					EndIf
				Else				
					If cPaisLoc == "EUA"
						If cValor >= nVlRecAua
							aArray[nIt,7] := Transf(nVlRecAua,__cPiE1Sld)
							nVlRecAua := 0
						Else
							aArray[nIt,7] := Transf(cValor,__cPiE1Sld)
							nVlRecAua := nVlRecAua - cValor
						EndIf
					Else
						aArray[nIt,7] := Transf(cValor,__cPiE1Sld)
					EndIf
				EndIf
				
				If cPaisLoc != "RUS" .And. ( !lRaRtImp .Or. ( (__lIrfMR .Or. __lPccMR) .And. !lRaRtImpMR ) )
					If cPaisLoc != "EUA" .And. !( nMoeda <> SE1->E1_MOEDA .And. cValor == NoRound(aArray[nIt,9], 2) )
						If !__lDizPer .Or. ( (cValor < cLimite) .Or. aArray[nIt,9] == 0 )
							aArray[nIt,9]	 := cValor
						EndIf
					EndIf
				EndIf
				
				If cPaisLoc != "EUA" .And. cValor <> nValRec // cvalor é uma variavel numerica
					nValRec	:= cValor
				EndIf
			EndIf
	    Else
			aArray[nIt,8] := !aArray[nIt,8]
			If aArray[nIt,4] $ MV_CRNEG
				F330VALNCC(@aArray,nIt, cValor < cLimite, .F.)
			EndIf
		EndIf
	Else
		If !aArray[nIt,8]
			aArray[nIt,7] := Transf(0,__cPiE1Sld)
			
			If cPaisLoc == "BRA"
				aArray[nIt,9] := 0
				
				If lCredito
					dbSelectArea("SE1")
					If MV_PAR02 == 2
						dbGoTo(aArray[nIt,23])
					Else
				   		dbGoTo(aArray[nIt,20])
				    EndIf
				    
				    //Motor de retenções
					If __lMotRet
						//Verifica as configurações de impostos pelo motor de retenção
						F330VldImp()
											
						lRaRtImpMR 	:= ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
						lPccBxCr 	:= ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
						lIrPjBxCr 	:= ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
					EndIf
				    
					If mv_par08 == 1 .Or. ( lRaRtImp .Or. lRaRtImpMR )
						nTotAbat := SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE)
					Else
						nTotAbat := 0
					EndIf
					
					If !lTemImpPix
						F330CalcPCC(nIt,aArray,@cValor+If(cValor==cSalTit,nTotAbat,0),cValor < cLimite)
					EndIf
					
					If lIrPjBxCr
						nIrrf := 0
						
						If !__lIrfMR .And. !lTemImpPix
							nIrrf := FCaIrBxCR(aArray[nIt,9])
						EndIf
						
						If ( nPosIr := ascan(aImpIR,{|x| x[2]=SE1->(REcno())}) ) = 0
							aAdd(aImpIR,{nIrrf,SE1->(Recno())})
							nPosIr := Len( aImpIR )
						Else
							aImpIR[nPosIr][1] := nIrrf
						EndIf
					EndIf				
				Endif
			EndIf
		EndIf
		
		FA330UnLock(aArray[nIt,1]+aArray[nIt,2]+aArray[nIt,3]+aArray[nIt,4],,aArray[nIt,Iif(MV_PAR02== 2, 16,13)])
	EndIf	
Next nVezes

For nX:=1 to Len(aArray)
	If	aArray[nX,8]
		nValtot += Fa330VTit(aArray[nX,7])
	Endif
Next

nIt := nOldIt

If oGet != Nil
	oGet:Refresh()
EndIf

If ExistBlock("F330ATLIS")
	ExecBlock("F330ATLIS",.F.,.F., {  , 2 , nValTot, nValor } )
EndIf  

RestArea(aAreaSE1)
RestVarMR( aImpMRBrw )

Return aArray

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³Fa330SetMo³ Autor ³ Fernando Machima      ³ Data ³ 19/02/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Tela de taxas de moedas                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Fa330SetMo												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Fa330SetMo(lAutomato)
Local oDlg
Local nLenMoedas	:= Len(aTxMoedas)
Local nI            := 1
Local nLinTelaF
Local nLinTelaD
Local nLinButton
Local aSay := {}
Local aGet := {}
Local cBlKMoeda
Local lExistM := Type("nMoeda") == "N" .And. nMoeda > 1
Default lAutomato := .F.

nLinTelaD	:=  05 + ((nLenMoedas-1) * 16)
nLinTelaF  	:= 200 + ((nLenMoedas-1) * 30.5) + 50
nLinButton  :=  03 + nLinTelaD

If nLenMoedas > 1
	If !lAutomato
		DEFINE MSDIALOG oDlg From 200,0 TO nLinTelaF,230 TITLE STR0037 PIXEL
			@ 005,005  To nLinTelaD,110 OF oDlg PIXEL

			For nI := 1 To nLenMoedas-1
				cBlKMoeda := "{|| aTxMoedas["+AllTrim(Str(ni+1))+",1]}"
				aAdd(aSay, TSay():New(1+(ni*12),010,&cBlKMoeda,oDlg,,, .F., .F., .T.,.T.,,,,, .F., .F., .F., .F.))
				aAdd(aGet, TGet():New((ni*12)-2,060,&("{|x| If(x <> NIL,aTxMoedas["+AllTRim(Str(ni+1))+",2] := x,aTxMoedas["+Str(ni+1)+",2])}"),oDlg,45,,aTxMoedas[nI+1,3],,,,,,,.T.,,,,.F.,.T.,,.F.,.F.,,,,.F.,,.T.))
			Next nI

		DEFINE  SButton FROM (nLinTelaD + 5),80 TYPE 1 Action (oDlg:End() ) ENABLE OF oDlg  PIXEL
		ACTIVATE MSDIALOG oDlg CENTERED
	EndIf
	If lExistM .And. (nI >= nMoeda .Or. lAutomato)
		If __lTxConP // validação para taxa contratada no título de partida
			If __lCmTxCon //se possui taxa contratada e não gera variação, a taxa de partida não se altera.
				__nTxMoedP := aTxMoedas[nMoeda, 2]
				__nTxContr := __nTxMoedP 
				nTxMoeda   := __nTxMoedP
			EndIf
		Else // validação para taxa do adiantamento na partida
			If (lCredito .And. !__lRaTxMov) .Or. !lCredito //se é crédito e utiliza a taxa do movimento, a taxa de partida não se altera
				__nTxMoedP := aTxMoedas[nMoeda, 2]
				__nTxContr := __nTxMoedP 
				nTxMoeda   := __nTxMoedP
			EndIf
		EndIf
	EndIf
Else
	Help("",1,"NoMoneda")
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºRotina    ³Fa330TudOkºAutor  ³Claudio D. de Souza º Data ³  29/11/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Validar os campos informados na compensacao                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Fina330                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fa330TudOk(nVlrCompe)

Local lRet := .T.
Default nVlrCompe := 0

Do Case
Case EMPTY(cNum)
	lRet := .F.
Case !fa330Cli()
	lRet := .F.
Case !Fa330Loja()
	lRet := .F.
Case !(nValor >= 0 .AND. STR(nValor,17,2) <= STR(nSaldo,17,2))
	lRet := .F.
Case !(dBaixa >= SE1->E1_EMISSAO)
	lRet := .F.
Case !lCredito
	If Empty(cTipoTit) .Or.	!(!cTipoTit $ MVABATIM .AND. 	!(cTipoTit $ MVRECANT+"/"+MV_CRNEG))
		lRet := .F.
	EndIf
Case lCredito
	If Empty(cTipoTit) .Or. !(!cTipoTit $ MVABATIM .AND. (cTipoTit $ MVRECANT+"/"+MV_CRNEG))
		lRet := .F.
	EndIf

EndCase

If SE1->E1_MOEDA > 1 .And. Empty(__nTxMoedP)
	Help( ,,"NOTXTITP",,STR0128, 1, 0 ) //"Não existe taxa cambial para o título!"
	lRet := .F.
EndIf

//Possibilita novas validacoes
If ExistBlock("F300VALID")
	lRet := ExecBlock	("F300VALID",.F.,.F.,nVlrCompe)
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}fMarkAll

Marcar todos os títulos da tela

@author Totvs
@since  11/06/2019
@version 12
/*/
//-------------------------------------------------------------------

Static Function fMarkAll(aTit As Array, nValor As Numeric, lEstorno As Logical) As Logical

	Local nI 		As Numeric
	Local nPosMarca As Numeric
	Local lRet 		As Logical
	
	nI 			:= 0
	nPosMarca 	:= 8
	lRet 		:= .T.
	
	Default lEstorno := .F.

	nPosMarca := Iif( lEstorno, 11, nPosMarca )

	If Len(aTit) > 0
		For nI := 1 to Len(aTit)
			If !aTit[nI,nPosMarca]
				lRet := .F.
				If !lEstorno
					If cPaisLoc == "EUA"
						aTit[nI][7] := aTit[nI][14]
					Else
						aTit[nI][7] := aTit[nI][22]
					EndIf
				EndIf
			EndIf
		Next
	EndIf
	
	If lEstorno
		aEval(@aTit, {|e| e[nPosMarca] := !lRet } )
	Else
		nValTot := 0
		aEval( @aTit, {|e| e[nPosMarca] := !lRet, ;
						   Iif( e[nPosMarca], ( Iif( Fa330VTit(e[7]) = 0, e[7] := e[6], Nil ), nValTot += Fa330VTit(e[7]),;
						   Iif( cPaisLoc=="BRA", e[9] := DesTrans(e[7]), IIf( MV_PAR02 == 02, e[12] := DesTrans(e[7]), .T. ) ) ),;
						   ( e[7] := Transf(0,"@E 9999,999,999.99"), Iif( cPaisloc=="BRA", e[9] := DesTrans(e[7]), IIf( MV_PAR02 == 02, e[12] := e[7], e[11] := e[7] ) ) ) ) } )
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc}fDsMarkAll

Desmarcar todos os títulos da tela

@author Rodrigo Oliveira
@since  26/06/2019
@version 12
/*/
//-------------------------------------------------------------------

Static Function fDsMarkAll(aTit As Array, nValor As Numeric) As Logical

	Local nI 		As Numeric
	Local nPosMarca As Numeric
	Local lRet 		As Logical
	
	nI 			:= 0
	nPosMarca 	:= 8
	lRet 		:= .T.
	
	nValTot := 0
	aEval( @aTit, {|e| e[nPosMarca] := .F., ;
					   Iif( e[nPosMarca], ( Iif( Fa330VTit(e[7]) = 0, e[7] := e[6], Nil ), nValTot += Fa330VTit(e[7]),;
					   Iif( cPaisLoc=="BRA", e[9] := DesTrans(e[7]), IIf( MV_PAR02 == 02, e[12] := DesTrans(e[7]), .T. ) ) ),;
					   ( e[7] := Transf(0,"@E 9999,999,999.99"), Iif( cPaisloc=="BRA" .And. !__lDizPer, e[9] := DesTrans(e[7]), IIf( MV_PAR02 == 02, e[12] := e[7], e[11] := e[7] ) ) ) ) } )

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³Fa330Leg   ³ Autor ³ Mauricio Pequim Jr   ³ Data ³ 20.07.04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Cria uma janela contendo a legenda da mBrowse              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Fa330Leg(nReg)
Local uRetorno := .T.
Local aLegenda := {	{"ENABLE"		, 	STR0051	},; //"Titulo nao Compensado"
				   	{"DISABLE"		, 	STR0052	},; //"Titulo Compensado Totalmente"
					{"BR_AZUL"		,  STR0053	}} //"Titulo Compensado Parcialmente"

If nReg = Nil	// Chamada direta da funcao onde nao passa, via menu Recno eh passado
	uRetorno := {}
	Aadd(uRetorno, {'E1_SALDO =  0', aLegenda[2][1]})			// Titulo Compensado Totalmente
	Aadd(uRetorno, {'E1_SALDO =  E1_VALOR', aLegenda[1][1]}) // Titulo nao Compensado
	Aadd(uRetorno, {'E1_SALDO <> 0', aLegenda[3][1]})			// Titulo Compensado Parcialmente
Else
	BrwLegenda(cCadastro,STR0047,aLegenda)  //"Legenda"
EndIf

Return uRetorno

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³PesqListBox³ Autor ³ Edson Maricate       ³ Data ³ 09.02.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Monta uma pesquisa de texto em um listBox.                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Geral                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function PesqListBox(oListBox,aListBox)

Local nFound
Local aParam	:= {}

PRIVATE mv_par01 // Declara as variaveis private para não conflitar com as variaveis da pergunte
PRIVATE mv_par02
PRIVATE mv_par03

If ParamBox( { { 1,STR0001 ,Padr(__PesqList,200),"@" 	 ,""  ,""    ,"" ,120 ,.T. },;
				{5,STR0056,.F.,90,,.F.},;
				{5,STR0057,.F.,90,,.F.} }, STR0001 , aParam, , , , , , , , .F. )

	__PesqList := aParam[1]
	If aParam[2]
		If aParam[3]
			nFound := aScan(aListBox,{|x| aScan(x,{|x| AllTrim(aParam[1])$AllTrim(x) } )>0 },oListBox:nAt+1)
		Else
			nFound := aScan(aListBox,{|x| aScan(x,{|x| AllTrim(aParam[1])$AllTrim(x) } )>0 })
		EndIf
	Else
		If aParam[3]
			nFound := aScan(aListBox,{|x| aScan(x,{|x| UPPER(AllTrim(aParam[1]))$UPPER(AllTrim(x)) } )>0 },oListBox:nAt+1)
		Else
			nFound := aScan(aListBox,{|x| aScan(x,{|x| UPPER(AllTrim(aParam[1]))$UPPER(AllTrim(x)) } )>0 })
		EndIf
	EndIf
	If nFound <= 0
		Aviso(STR0058, STR0059,{"Ok"},2)
	Else
		oListBox:nAt := nFound
		oListBox:Refresh()
	EndIf

EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Fa330IntPco ºAutor ³Paulo Carnelossi    º Data ³  22/11/06  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³funcao que gera os lancamentos no sigapco (PcoDetLan())     º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function Fa330IntPco(nRecSE1, aRecnoSE1, aBaixasSE5)
Local aArea := GetArea()
Local aAreaSE1 := SE1->(GetArea())
Local aAreaSE5 := SE5->(GetArea())
Local nX

If SuperGetMV("MV_PCOINTE",.F.,"2")=="1"

	dbSelectArea("SE1")
	dbGoto(nRecSE1) //titulo principal apos a compensacao

	// Grava lançamento no PCO ref titulo principal apos a compensacao
	PCODetLan("000016","01","FINA330")

	For nX := 1 TO Len(aRecnoSE1) // ARRAY COM REGISTROS TITULOS COMPENSADOS

		//grava lcto ref. titulo compensado
		dbSelectArea("SE1")
		dbGoto(aRecnoSE1[nX])

		//Grava lançamento no PCO ref titulo compensado apos a compensacao 
		PCODetLan("000016","02","FINA330")

		//grava lctos das baixas referente titulo principal e titulo compensado
		dbSelectArea("SE5")
		If Len(aBaixasSE5) > 0
			If valtype(aBaixasSE5[(nX*2)-1]) == "N" .and. Valtype(aBaixasSE5[(nX*2)]) == "N"
				
				dbGoto(aBaixasSE5[(nX*2)-1])
				// Grava lançamento no PCO ref baixa (Mov.Bancaria-SE5) do titulo principal apos a compensacao
				PCODetLan("000016","03","FINA330")

				dbGoto(aBaixasSE5[(nX*2)])
				// Grava lançamento no PCO ref baixa do titulo compensado (Mov.Bancaria-SE5)
				PCODetLan("000016","04","FINA330")
			Else
				Loop
			EndiF
		EndIf

	Next

EndIf

RestArea(aAreaSE5)
RestArea(aAreaSE1)
RestArea(aArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³MenuDef   ³ Autor ³ Ana Paula N. Silva     ³ Data ³23/11/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Utilizacao de menu Funcional                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array com opcoes da rotina.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Parametros do array a Rotina:                               ³±±
±±³          ³1. Nome a aparecer no cabecalho                             ³±±
±±³          ³2. Nome da Rotina associada                                 ³±±
±±³          ³3. Reservado                                                ³±±
±±³          ³4. Tipo de Transao a ser efetuada:                        ³±±
±±³          ³		1 - Pesquisa e Posiciona em um Banco de Dados     ³±±
±±³          ³    2 - Simplesmente Mostra os Campos                       ³±±
±±³          ³    3 - Inclui registros no Bancos de Dados                 ³±±
±±³          ³    4 - Altera o registro corrente                          ³±±
±±³          ³    5 - Remove o registro corrente do Banco de Dados        ³±±
±±³          ³5. Nivel de acesso                                          ³±±
±±³          ³6. Habilita Menu Funcional                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MenuDef()
Local lFA330LIB := Existblock("FA330LIB")
Local aRetorno  := {}
Local aRotina   := {  {STR0001, "AxPesqui"  , 0, 1,, .F. },;  //"Pesquisar"
	                  {STR0002, "AxVisual"  , 0, 2 },;        //"Visualizar"
	                  {STR0003, "Fa330Comp" , 0, 4 },;        //"Compensar"
 	                  {STR0004, "Fa330Desc" , 0, 4 },;        //"Excluir"
 	                  {STR0054, "Fa330Desc" , 0, 4 },;        //"Estornar"
 	                  {STR0047, "Fa330Leg"  , 0, 2,, .F.} }   //"Legenda"

If lFA330LIB
	aRetorno := ExecBlock("FA330LIB",.F.,.F.,{aRotina})
	aRotina := AClone(aRetorno)
Endif

Return(aRotina)

//------------------------------------------------------------------------------------------------------------------------------------------------

Static Function FA330aUnlock()
Local aArea := GetArea()
If aRLocks == Nil
	aRLocks:={}
Endif
//**********************************************
// Retirado para permitir utilizacao de rotina *
// automatica dentro de transacao no banco     *
//**********************************************
//AEval(aRLocks,{|x,y| SE1->(MsRUnlock(x))})
AEval(aRLocks,{|x,y| SE1->(DbGoTo(x)),MsUnLock() })
aRLocks:={}
RestArea(aArea)
Return

//------------------------------------------------------------------------------------------------------------------------------------------------

Static Function FA330Unlock(cChave,nRecno,cfilorig)
Local aArea
Local nPosRec

If aRLocks == Nil
	aRLocks:={}
EndIf
If nRecno <> Nil
	SE1->(MsGoto(nRecno))
Else
	aArea	:=	getArea()
	SE1->(DbSetOrder(1))
	SE1->(MsSeek(cfilorig+cChave))
EndIf

//**********************************************
// Retirado para permitir utilizacao de rotina *
// automatica dentro de transacao no banco     *
// **********************************************
//SE1->(MsRUnlock(SE1->(Recno())))
SE1->(MsUnlock())

If (nPosRec:=Ascan(aRLocks,SE1->(REcno()))) > 0
	Adel(aRlocks,nPosRec)
	aSize(aRlocks,Len(aRlocks)-1)
EndIf

If aArea <> Nil
	RestArea(aArea)
EndIf

Return

//------------------------------------------------------------------------------------------------------------------------------------------------

Static Function FA330Lock(cChave,nRecno,lHelp,cfilOrig)
Local aArea
Local lRet	:=	.F.
DEFAULT lHelp	:=	.T.

If aRLocks == Nil
	aRLocks:={}
Endif

If nRecno <> Nil
	SE1->(MsGoto(nRecno))
Else
	aArea	:=	SE1->(getArea())
	SE1->(DbSetOrder(1))
	SE1->(MsSeek(cfilorig+cChave))
Endif

If  SE1->(RecLock("SE1",.F.))
	AAdd(aRLocks, SE1->(Recno()))
	lRet	:=	.T.
ElseIf lHelp
	MsgAlert(STR0060)
Endif

If aArea <> Nil
	RestArea(aArea)
Endif

Return lRet


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³FinA330T   ³ Autor ³ Marcelo Celi Marques ³ Data ³ 27.03.08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Chamada semi-automatica utilizado pelo gestor financeiro   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FinA330T(aParam)

	cRotinaExec := "FINA330"
	ReCreateBrow("SE1",FinWindow)
	FinA330(aParam[1])
	FinVisual(FinWindow:cAliasFile,FinWindow,(FinWindow:cAliasFile)->(Recno()),.T.)
	ReCreateBrow("SE1",FinWindow)
	dbSelectArea("SE1")

	INCLUI := .F.
	ALTERA := .F.

Return .T.

//------------------------------------------------------------------------------------------------------------------------------------------------

Function F330SldPri(nRecNo)
Local aArea := SE1->(GetArea())
Local nSaldo := 0

SE1->(DbGoTo(nRecNo))
nSaldo := SE1->E1_SALDO

RestArea(aArea)

Return nSaldo

//------------------------------------------------------------------------------------------------------------------------------------------------

Function F330CalcPCC( nIt, aArray, cValor, lAltValor )

Local nPosPis 	:= 14		//Posicao Pis na Tela
Local nPosCof 	:= 15		//Posicao Cofins na Tela
Local nPosCsl 	:= 16		//Posicao Csll na Tela
Local nPVRPis 	:= 17		//Posicao Valor Retido Pis na Tela
Local nPVRCof 	:= 18		//Posicao Valor Retido Cofins na Tela
Local nPVRCsl 	:= 19		//Posicao Valor Retido Csll na Tela
Local nPosRec 	:= 20		//Posicao Recno na Tela
Local nPisJaRet := 0
Local nPisARet 	:= 0
Local nCofJaRet := 0
Local nCofARet 	:= 0
Local nCslJaRet := 0
Local nCslARet 	:= 0
Local nX		:= 0
Local cRetCli 	:= "1"
Local lPccBxCr	:= FPccBxCr()
Local nPropPcc	:= 0
Local nVlrTitSel	:= 0  
Local nValPcc	:= 0  
Local ni		:= 0    
Local nRecTit	:= 0
Local nTotAdto	:= 0
Local lBaixaAbat	:= .F.
Local nVlrBaixa	:= 0
Local lBxCec	:= .F.
Local lBxLiq	:= .F.
Local lSigaloja	:= .F.
Local lTipBxCP  := .F.
Local nTAbt		:= 0

Default lAltValor := .F.

lPccBxCr := ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxCr )

If cPaisLoc == "BRA" .And. lPccBxCr
	//Caso considere diferentes clientes
	If MV_PAR02 == 2
		nPosPis := 17
		nPosCof := 18
		nPosCsl := 19
		nPVRPis := 20		//Posicao Valor Retido Pis na Tela
		nPVRCof := 21		//Posicao Valor Retido Cofins na Tela
		nPVRCsl := 22		//Posicao Valor Retido Csll na Tela
		nPosRec := 23
		nPosBPCC := 27
		nPosBPCR := 28
	Endif

	SE1->( dbGoTo( aArray[nIt, nPosRec] ) )
	nValrec 	:= cValor 	//Esta variavel esta numerica apesar da notacao.
	nOldValRec 	:= nValRec

	If !__lPccMR
	
		cRetCli := Iif(Empty(SA1->A1_ABATIMP),"1",SA1->A1_ABATIMP)
	
		If aArray[nIt,8]
			If cRetCli == "1"  //Calculo do sistema
				nValRecAtu := nValRec
				For nX := nIt To Len(aArray)
					If	aArray[nX,8]
						nValRec   += Fa330VTit(aArray[nX,7])
						If mv_par08 == 2
							nValRec   += Fa330VTit(aArray[nX,nPosPis])
							nValRec   += Fa330VTit(aArray[nX,nPosCof])
							nValRec   += Fa330VTit(aArray[nX,nPosCsl])
							nPisJaRet += Fa330VTit(aArray[nX,nPosPis])
							nPisARet  += Fa330VTit(aArray[nX,nPVRPis])
							nCofJaRet += Fa330VTit(aArray[nX,nPosCof])
							nCofARet  += Fa330VTit(aArray[nX,nPVRCof])
							nCslJaRet += Fa330VTit(aArray[nX,nPosCsl])
							nCslARet  += Fa330VTit(aArray[nX,nPVRCsl])
						EndIf
					EndIf
				
					If (Len(aArray) > nX)
						If aArray[(nX+1),8]
							Exit
						EndIf
					EndIf			
				Next
	
				nVlrTitSel := nValRec
				If ( nPisJaRet + nCofJaRet + nCslJaRet ) > 0
					nValRec    := nOldValRec
				EndIf
				
				aBaixa := Sel070Baixa( "VL /V2 /BA /RA /CP /LJ /" + MV_CRNEG, SE1->E1_PREFIXO,SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO,;
					                   @nTotAdto, @lBaixaAbat, SE1->E1_CLIENTE, SE1->E1_LOJA, @nVlrBaixa, , @lBxCec, @lBxLiq ,@lSigaloja ,@lTipBxCP)
				
				nTAbt	:= SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",SE1->E1_MOEDA,,SE1->E1_CLIENTE,,SE1->E1_FILIAL)
				
				If dDataBase < dLastPcc
					f070TotMes(dBaixa,.T.)
				Else
					If lAltValor
						nValPcc	:= nValRec
					Else
						If !__lBq10925 .And. lCredito
							nValPcc	:= SE1->E1_SALDO
						Else
							nValPcc	:= SE1->E1_VALOR - nTotAdto
						EndIf
					EndIf

					If 	FHCliPCC(SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_NATUREZ)
						If SE1->E1_VLCRUZ > SE1->E1_BASEIRF
					   		aPcc := newMinPcc(dBaixa,FBaseRPCC(nValPcc),SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
						Else
					   		aPcc := newMinPcc(dBaixa,nValPcc,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
				    	EndIf	

						nPis	:= aPcc[2]
						nCofins	:= aPcc[3]
						nCsll	:= aPcc[4]
						If !lAltValor .and. !lRartimp .and. mv_par08 == 1 .and. !lCredito /*SE1->E1_TIPO == MVNOTAFIS*/ .and. (SE1->E1_SALDO - Iif(!lPccBxCr,0,nPis + nCofins + nCsll) - nTAbt <> nValRec )//.and. SE1->E1_SALDO - nPis - nCofins - nCsll - nTAbt == SE1->E1_SALDO) // compensado pelo valor liquido 
							nValPcc	:= nValRec
							aPcc	:= newMinPcc(dBaixa,nValPcc,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE+SE1->E1_LOJA)
							nPis	:= aPcc[2]
							nCofins	:= aPcc[3]
							nCsll	:= aPcc[4]
						EndIf
						If Len(aPcc) > 4 
							__aTitCalc := aPcc[5]
						EndIf
					EndIf
				EndIf
				nValRec    	:= nVlrTitSel
				nOldvalRec	:= nVlrTitSel
	
				If dDataBase < dLastPcc
					If ( MV_PAR08 == 1 .Or. lRaRtImp ) .And. ( lAltValor .Or. nValRecAtu < SE1->E1_SALDO );
					.And. (!lRaRtImp .And. (nValRecAtu+(nCofins+nCsll+nPis+nIrrf+nTAbt))< SE1->E1_SALDO)
						
						nPropPcc 	:= (nValRecAtu*(nCofins+nCsll+nPis))/SE1->E1_VLCRUZ
						nPropPcc 	:= (nPropPcc/ (nCofins+nCsll+nPis) )
						nPis		:= Round(NoRound(SE1->E1_PIS * nPropPCC,3),2)
						nCofins		:= Round(NoRound(SE1->E1_COFINS * nPropPCC,3),2)
						nCsll		:= Round(NoRound(SE1->E1_CSLL * nPropPCC,3),2)
						nPisBaseR 	:= Round(NoRound(SE1->E1_BASEPIS * nPropPCC,3),2)
						nPisBaseC 	:= Round(NoRound(SE1->E1_BASEPIS * nPropPCC,3),2)
		
						nValRec := nValRecAtu
					Else
						nValRec := nValRecAtu
						nPis 	:= nPis + nPisARet - nPisJaRet
						nCofins := nCofins + nCofARet - nCofJaRet
						nCsll 	:= nCsll + nCslARet - nCslJaRet
					EndIf
				EndIf
	
			ElseIf cRetCli == "2"	//Sempre calcula
				nPropPcc 	:= nValrec/SE1->E1_VLCRUZ
				nPis		:= Round(NoRound(SE1->E1_PIS * nPropPCC,3),2)
				nCofins		:= Round(NoRound(SE1->E1_COFINS * nPropPCC,3),2)
				nCsll		:= Round(NoRound(SE1->E1_CSLL * nPropPCC,3),2)
				nPisBaseR 	:= Round(NoRound(SE1->E1_BASEPIS * nPropPCC,3),2)
				nPisBaseC 	:= Round(NoRound(SE1->E1_BASEPIS * nPropPCC,3),2)
				nVlRetPis	:= nPis
				nVlRetCof	:= nCofins
				nVlRetCsl	:= nCsll
				nValRec		-= (nPis+nCofins+nCsll)
			Else
				nPis		:= 0
				nCofins		:= 0
				nCsll		:= 0
				nVlRetPis	:= 0
				nVlRetCof	:= 0
				nVlRetCsl	:= 0
			Endif
		Else
			nPis		:= 0
			nCofins		:= 0
			nCsll		:= 0
			nVlRetPis	:= 0
			nVlRetCof	:= 0
			nVlRetCsl	:= 0
		EndIf

		cValor	:= nValRec
	Else
		
		If !aArray[nIt,8]
			nPis 	:= 0
			nCofins	:= 0
			nCsll 	:= 0
		EndIf
		
	EndIf
	
	If mv_par08 == 1
		aArray[nIt,nPosPis] := Transform(nPis,"@E 99,999,999.99")
		aArray[nIt,nPosCof] := Transform(nCofins,"@E 99,999,999.99")
		aArray[nIt,nPosCsl] := Transform(nCsll,"@E 99,999,999.99")
	EndIf
	
	If !__lPccMR
		aArray[nIt,nPosBPCC] := Transform(nPisBaseC,"@E 99,999,999.99")
		aArray[nIt,nPosBPCR] := Transform(nPisBaseR,"@E 99,999,999.99")
	Endif
	
	If MV_PAR02 == 2
		If !__lPccMR
			aArray[nIt,nPVRPis] := Transform(nVlRetPis,"@E 99,999,999.99")
			aArray[nIt,nPVRCof] := Transform(nVlRetCof,"@E 99,999,999.99")
			aArray[nIt,nPVRCsl] := Transform(nVlRetCsl,"@E 99,999,999.99")
		Else
			aArray[nIt,nPVRPis] := Transform(nPis,"@E 99,999,999.99")
			aArray[nIt,nPVRCof] := Transform(nCofins,"@E 99,999,999.99")
			aArray[nIt,nPVRCsl] := Transform(nCsll,"@E 99,999,999.99")
		EndIf
	Endif
	
	For ni := 1 To Len(aTitulos)
		nRecTit	:= SE1->(Recno())
		If ValType(aTitulos[ni,20]) <> "C"
			If nRecTit == aTitulos[ni][20]
				aTitulos[ni][14]	:= aArray[nIt,nPosPis]
				aTitulos[ni][15]	:= aArray[nIt,nPosCof]
				aTitulos[ni][16]	:= aArray[nIt,nPosCsl]
			EndIf
		EndIf
	Next		
EndIf

Return

//------------------------------------------------------------------------------------------------------------------------------------------------

Function F330GrvSFQ(cSequencia,nRecnoSE1)
Local aAreaSFQ	 	:= Getarea() 
Local nLoop		 	:= 0
Local nVlMinImp	 	:= GetNewPar("MV_VL10925",5000)
Local aRecnos	 	:= {}
Local cModRetPIS 	:= SA1->A1_ABATIMP
Local nBaseRet	 	:= 0
Local lAplVlMin	 	:= .T.
Local nTamSeq	 	:= TamSX3("FQ_SEQORI")[1]
Local lPccBxCr	 	:= FPccBxCr()
Local nTit		 	:= 0
Local lIrPjBxCr	 	:= FIrPjBxCr()
Local lRaRtImp   	:= FRaRtImp()
// Variaveis para o Model de Alteração do SE5
Local aAreaFKs 	 	:= {}
Local oSubFK3
Local oSubFK4
Local cCamposE5  	:= ""
Local lRet 		 	:= .T.
Local lGrvFK3		:= .T.
Local aImpostos  	:= {}
Local nX
Local nSalvRec 	 	:= SE1->(Recno())
Local oModelMov  	:= Nil
Local cIDFK1 	 	:= ""
Local cFilOld	 	:= ""

DEFAULT cSequencia 	:= Replicate("0",nTamSeq)
DEFAULT nRecnoSE1	:= 0

nIss     := If(Type("nIss") != "N",0,nIss)
nIrrf    := If(Type("nIrrf") != "N",0,nIrrf)
nValComp := If(Type("nValComp") != "N",0,nValComp)
nValLiq  := If(Type("nValLiq") != "N",0,nValLiq)
dBaixa	 := If(Type("dBaixa") != "D",dDataBase,dBaixa)
nTotAbat := If(Type("nTotAbat") != "N",SumAbatRec( SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_MOEDA, "S"  ,dBaixa,,@nTotIrAbt,@nTotCsAbt,@nTotPisAbt,@nTotCofAbt,),nTotAbat)
nDescont := If(Type("nDescont") != "N",0,nDescont)
nMulta   := If(Type("nMulta") != "N",0,nMulta)
nJuros   := If(Type("nJuros") != "N",0,nJuros)
nAcresc  := If(Type("nAcresc") != "N",0,nAcresc)
nDecresc := If(Type("nDecresc") != "N",0,nDecresc)
lRetParc := If(Type("lRetParc") != "L",.T.,lRetParc)

nBaseRet		:= nValRec+nDescont+nTotAbat-nJuros-nMulta

If dDatabase >= dLastPcc
	nVlMinImp	:= 0
EndIf

If __lRpoR33 == NIL
	__lRpoR33 := GetRpoRelease() >= "12.1.033"
EndIF

//Verificar ou nao o limite de 5000 para Pis cofins Csll
// 1 = Verifica o valor minimo de retencao
// 2 = Nao verifica o valor minimo de retencao
If SE1->E1_APLVLMN == "2"
	lAplVlMin := .F.
EndIf

If nRecnoSE1 > 0 .AND. AllTrim(cSequencia) != Replicate("0",nTamSeq)

	//Posiciona a FK1 para mandar a operação de alteração com base no registro posicionado da SE5
	If AllTrim( SE5->E5_TABORI ) == "FK1"
		aAreaFKs := GetArea()
		dbSelectArea( "FK1" )
		FK1->( DbSetOrder( 1 ) )
		If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
			//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
			SE1->(dbGoto(nRecnoSE1))
	   		cCamposE5:= "{"
   			cCamposE5+= "{'E5_VRETPIS', "+cValtoChar(nPis)+"}"
   			cCamposE5+= ",{'E5_VRETCOF', "+cValtoChar(nCofins)+"}"
    		cCamposE5+= ",{'E5_VRETCSL', "+cValtoChar(nCsll)+"}"
    		cCamposE5+= ",{'E5_VRETIRF', "+cValtoChar(nIrrf)+"}"
	   		cCamposE5+= "}"

			oModelMov := FWLoadModel("FINM010")
			oModelMov:SetOperation( 4 ) //Alteração
			oModelMov:Activate()
			oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
			oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1

			//Dados Contábeis
   			oSubFK3 := oModelMov:GetModel("FK3DETAIL")
   			oSubFK4 := oModelMov:GetModel("FK4DETAIL")
   			      
   			cIDFK1 := FWUUIDV4()
			//------------------------------------------------------
			// Grava os valores agregados ao titulo no totalizador 
			//------------------------------------------------------
			//Reestruturacao SE5
			//aImpostos[1] = codigo imposto
			//aImpostos[2] = imposto calculado
			//aImpostos[3] = natureza
			//aImpostos[4] = cIdFK4															
			//aImpostos[5] = imposto retido
			//aImpostos[6] = base calculado
			//aImpostos[7] = base retencao
			aadd(aImpostos,{"PIS" ,nPisCalc ,		SuperGetMV("MV_PISNAT")		,"", nPis    , nPisBaseC, nPisBaseR, ""	})
			aadd(aImpostos,{"COF" ,nCofCalc ,		SuperGetMV("MV_COFINS")		,"", nCofins , nCofBaseC, nCofBaseR, ""	})
			aadd(aImpostos,{"CSL" ,nCslCalc ,		SuperGetMV("MV_CSLL")  		,"", nCsll   , nCslBaseC, nCslBaseR, ""	})
			aadd(aImpostos,{"IRF" ,nIrfCalc ,		&(SuperGetMV("MV_IRF"))		,"", nIrrf   , nIrfBase , nIrfBaseR, ""	})
			
			//Grava FK3 E/OU FK4
			For nX := 1 to Len(aImpostos)
				lGrvFk3	:= .T.
				//Gravar FK4 se os valores de PCC forem maiores que zero IMPOSTOS
				If aImpostos[nX][2] > 0 .And. aImpostos[nX][6] > 0
                       
					cIdFK4 := ""
					If aImpostos[nX][5] > 0 .And. aImpostos[nX][7] > 0   //Houve retencao
						If aImpostos[nX,1] == "IRF"
							cIdFK4 := __cIdFk4IR
						Else
							cIdFK4:= FINFKSID('FK4', 'FK4_IDFK4')
						EndIf

						aImpostos[nX,4] := cIdFK4

						//Guardo o IDFK4 do IRF para usar posteriormente
						
					EndIf
	                        
					If !oSubFK3:IsEmpty()
						If aImpostos[nX,1] == "IRF"
							If nIrrf > 0 .Or. FXBuscaIRF(oModelMov) // No caso de IR retido, a gravação é feita pela FGSFQIRCR (FINXIMP)
								lGrvFK3	:= .F.
							EndIf
						EndIf
						If lGrvFK3
							//Inclui a quantidade de linhas necessárias
							oSubFK3:AddLine()		
						
							//Vai para linha criada
							oSubFK3:GoLine( oSubFK3:Length() )
						EndIf
					EndIf	
		
					//---------------------------------------------
					// Grava Imposto calculado
					//---------------------------------------------
					If lGrvFK3
						oSubFK3:SetValue( "FK3_IDFK3" , FINFKSID('FK3', 'FK3_IDFK3'))
						oSubFK3:SetValue( "FK3_DATA"  , dDataBase )
						oSubFK3:SetValue( "FK3_ORIGEM", FunName() )
						oSubFK3:SetValue( "FK3_IMPOS" , aImpostos[nX][1] )
						oSubFK3:SetValue( "FK3_RECPAG", "R" )
						oSubFK3:SetValue( "FK3_MOEDA" , "01" )
						oSubFK3:SetValue( "FK3_VALOR" , aImpostos[nX][2] )
						oSubFK3:LoadValue( "FK3_NATURE", aImpostos[nX][3])
						oSubFK3:SetValue( "FK3_FILORI", SE1->E1_FILORIG  )
						oSubFK3:SetValue( "FK3_BASIMP", aImpostos[nX][6] )
						oSubFK3:SetValue( "FK3_IDORIG", cIdFK1 )
						oSubFK3:SetValue( "FK3_TABORI", "FK1") 
						oSubFK3:SetValue( "FK3_IDRET" , aImpostos[nx,4] )
						If __lMotRet
							oSubFK3:SetValue( "FK3_CODFKM", aImpostos[nX,8] )
							oSubFK3:SetValue( "FK3_CLIFOR", SA1->A1_COD )
							oSubFK3:SetValue( "FK3_LOJA"  , SA1->A1_LOJA )
							oSubFK3:SetValue( "FK3_CGC"   , SA1->A1_CGC )
							oSubFK3:SetValue( "FK3_RAICGC", Substr(SA1->A1_CGC, 1, 8) )
						EndIf
					EndIf
		
					//---------------------------------------------
					// Grava Imposto Retido
					//---------------------------------------------
					If aImpostos[nX][5] > 0 .And. aImpostos[nX][1] != "IRF"  //Houve retencao
						If !oSubFK4:IsEmpty()
							//Inclui a quantidade de linhas necessárias
							oSubFK4:AddLine()		
						
							//Vai para linha criada
							oSubFK4:GoLine( oSubFK4:Length() )	
						EndIf		
	
						oSubFK4:SetValue( "FK4_IDFK4" , aImpostos[nx,4])
						oSubFK4:SetValue( "FK4_DATA"  , dDataBase )
						oSubFK4:SetValue( "FK4_ORIGEM", FunName() )
						oSubFK4:LoadValue( "FK4_IMPOS" , aImpostos[nx,1] )
						oSubFK4:SetValue( "FK4_RECPAG", "R" )
						oSubFK4:SetValue( "FK4_MOEDA" , "01" )
						oSubFK4:SetValue( "FK4_VALOR" , aImpostos[nX,5] )
						oSubFK4:LoadValue( "FK4_NATURE", aImpostos[nX,3])
						oSubFK4:SetValue( "FK4_FILORI", SE1->E1_FILORIG )
						oSubFK4:SetValue( "FK4_BASIMP", aImpostos[nX,7])
						If __lMotRet
							oSubFK4:SetValue( "FK4_CODFKM", aImpostos[nX,8] )
							oSubFK4:SetValue( "FK4_CLIFOR", SA1->A1_COD )
							oSubFK4:SetValue( "FK4_LOJA"  , SA1->A1_LOJA )
							oSubFK4:SetValue( "FK4_CGC"   , SA1->A1_CGC )
							oSubFK4:SetValue( "FK4_RAICGC", Substr(SA1->A1_CGC, 1, 8) )
						EndIf

					EndIf
				EndIf
			Next nX

			If oModelMov:VldData()
				oModelMov:CommitData()
				SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
			Else
				lRet := .F.
				cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[6])
				Help( ,,"M010VALID",,cLog, 1, 0 )
 			EndIf
			oModelMov:DeActivate()
			oModelMov:Destroy()
			oModelMov:= nil

			If lRet
				//Gravo o relacionamento de retenção dos títulos que tiveram impostos retidos na baixa atual
				FinFk3BCR(__aTitCalc, aImpostos)
				AjustBsPCC(aImpostos)
			EndIf

		Else //Se não achou o registro na FK1
			lRet := .F.
		EndIf
		RestArea(aAreaFKs)
	Else //Se a origem do registro posicionado não for FK1
		lRet := .F.
	EndIf

	Do Case
	Case cModRetPIS == "1"
		If (aDadosRet[ 1 ] + nValRec > nVlMinImp) .or. !lAplVlMin
			If (!lRaRtImp .and. !(SE5->E5_TIPO == MVRECANT) .and. aDadosRet[ 1 ] + nValRec > nVlMinImp)
				nSalvRec := SE5->( Recno() )
				lRetParc := .T.
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Exclui a Marca de "pendente recolhimento" dos demais registros   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If aDadosRet[1] > 0
					aRecnos := aClone( aDadosRet[ 6 ] )
	
					cPrefOri  := SE5->E5_PREFIXO
					cNumOri   := SE5->E5_NUMERO
					cParcOri  := SE5->E5_PARCELA
					cTipoOri  := SE5->E5_TIPO
					cCfOri    := SE5->E5_CLIFOR
					cLojaOri  := SE5->E5_LOJA
	
					For nLoop := 1 to Len( aRecnos )
	
						SE5->( dbGoto( aRecnos[ nLoop ] ) )
	
						RecLock( "SE5", .F. )
	
						If !Empty(SE5->E5_PRETPIS) .And. !Empty(SE5->E5_PRETCOF) .And. !Empty(SE5->E5_PRETCSL)
							SE5->E5_PRETPIS := "2"
							SE5->E5_PRETCOF := "2"
							SE5->E5_PRETCSL := "2"
						EndIf
	
						SE5->( MsUnlock() )
	
						If nSalvRec <> aRecnos[ nLoop ]
							dbSelectArea("SFQ")
							RecLock("SFQ",.T.)
							SFQ->FQ_FILIAL  := xFilial("SFQ")
							SFQ->FQ_ENTORI  := "E1B"
							SFQ->FQ_PREFORI := cPrefOri
							SFQ->FQ_NUMORI  := cNumOri
							SFQ->FQ_PARCORI := cParcOri
							SFQ->FQ_TIPOORI := cTipoOri
							SFQ->FQ_CFORI   := cCfOri
							SFQ->FQ_LOJAORI := cLojaOri
							SFQ->FQ_SEQORI  := cSequencia
	
							SFQ->FQ_ENTDES  := "E1B"
							SFQ->FQ_PREFDES := SE5->E5_PREFIXO
							SFQ->FQ_NUMDES  := SE5->E5_NUMERO
							SFQ->FQ_PARCDES := SE5->E5_PARCELA
							SFQ->FQ_TIPODES := SE5->E5_TIPO
							SFQ->FQ_CFDES   := SE5->E5_CLIFOR
							SFQ->FQ_LOJADES := SE5->E5_LOJA
							SFQ->FQ_SEQDES  := SE5->E5_SEQ
	
							//Grava a filial de destino
							SFQ->FQ_FILDES := SE5->E5_FILIAL
	
							MsUnlock()
						Endif
	 				Next nLoop
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Retorna do ponteiro do SE1 para a parcela         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SE5->( MsGoto( nSalvRec ) )
		Else
			If nVlRetPis + nVlRetCof + nVlRetCsl > 0
				//Posiciona a FK1 para mandar a operação de alteração com base no registro posicionado da SE5
				If AllTrim( SE5->E5_TABORI ) == "FK1"
					aAreaFKs := GetArea()
					dbSelectArea( "FK1" )
					FK1->( DbSetOrder( 1 ) )
					If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
						//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
						cCamposE5:= "{"
						cCamposE5+= "{'E5_VRETPIS',"+Str(nVlRetPis)+"}"
						cCamposE5+= ",{'E5_VRETCOF',"+Str(nVlRetCof)+"}"
						cCamposE5+= ",{'E5_VRETCSL',"+Str(nVlRetCsl)+"}"
						cCamposE5+= ",{'E5_PRETPIS', '1'}"
						cCamposE5+= ",{'E5_PRETCOF', '1'}"
						cCamposE5+= ",{'E5_PRETCSL', '1'}"
						cCamposE5+= "}"
						oModelMov:SetOperation( 4 ) //Alteração
						oModelMov:Activate()
						oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
						oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1
						
						
  						If oModelMov:VldData()
      	   					oModelMov:CommitData()
							SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
						Else
       						lRet := .F.
	   				 		cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
	   	 					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
	   	 					cLog += cValToChar(oModelMov:GetErrorMessage()[6])
   							Help( ,,"M030VALID",,cLog, 1, 0 )
						Endif
						
						oModelMov:DeActivate()
						oModelMov:Destroy()
						oModelMov:= nil
					Else //Se não achou o registro na FK1
						lRet := .F.
					Endif
					RestArea(aAreaFKs)
				Else //Se a origem do registro posicionado não for FK1
					lRet := .F.
				Endif
	
			EndIf
			lRetParc := .F.

		EndIf

	Case cModRetPIS == "2"
		lRetParc := .T.

	Case cModRetPIS == "3"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava a Marca de "pendente recolhimento" dos demais registros    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nVlRetPis + nVlRetCof + nVlRetCsl > 0
			//Posiciona a FK1 para mandar a operação de alteração com base no registro posicionado da SE5
			If AllTrim( SE5->E5_TABORI ) == "FK1"
				aAreaFKs := GetArea()
				dbSelectArea( "FK1" )
				FK1->( DbSetOrder( 1 ) )
				If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
					//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
					cCamposE5:= "{"
					cCamposE5+= "{'E5_VRETPIS',"+Str(nVlRetPis)+"}"
					cCamposE5+= ",{'E5_VRETCOF',"+Str(nVlRetCof)+"}"
					cCamposE5+= ",{'E5_VRETCSL',"+Str(nVlRetCsl)+"}"
					cCamposE5+= ",{'E5_PRETPIS', '1'}"
					cCamposE5+= ",{'E5_PRETCOF', '1'}"
					cCamposE5+= ",{'E5_PRETCSL', '1'}"
					cCamposE5+= "}"
					oModelMov:SetOperation( 4 ) //Alteração
					oModelMov:Activate()
					oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
					oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1
					
					
					If oModelMov:VldData()
   	   					oModelMov:CommitData()
						SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))

					Else
   						lRet := .F.
   				 		cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
   	 					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
   	 					cLog += cValToChar(oModelMov:GetErrorMessage()[6])
						Help( ,,"M030VALID",,cLog, 1, 0 )
					Endif
					oModelMov:DeActivate()
					oModelMov:Destroy()
					oModelMov:= nil
				Else //Se não achou o registro na FK1
					lRet := .F.
				Endif
				RestArea(aAreaFKs)
			Else //Se a origem do registro posicionado não for FK1
				lRet := .F.
			Endif

		EndIf
		lRetParc := .F.
	EndCase

	//Grava os titulos de PCC Baixa CR
	//Gravo os titulos de impostos Pis Cofins Csll quando controlados pela baixa
	If lRetParc .And. !lRaRtImp
		If lCredito
			cFilOld	:= cFilAnt
			cFilAnt := SE1->E1_FILORIG
			FGrvPccRec(@nPis,@nCofins,@nCsll,nRecnoSE1,.F.,lRetParc,@cSequencia,"FINA070",SE1->E1_MOEDA)
			cFilAnt	:= cFilOld
		Else
			FGrvPccRec(@nPis,@nCofins,@nCsll,nRecnoSE1,.F.,lRetParc,@cSequencia,"FINA070",SE1->E1_MOEDA)
		EndIf
	EndIf

    If lRaRtImp .And. !SE5->E5_TIPO $ MVRECANT .And. (lPccBxCr  .or. lIRPJBxCr)
		If Len(aDadosRA1[2]) ==1
			nTit := 0
		Else
			nTit := aScan(aDadosRA1[2],{|x| x=nRecnoSE1})
		EndIf
		If nTit == 0
			For nTit := 1 to Len(aDadosRA1[1])
				If aDadosRA1[9][nTit]
					//Posiciona a FK1 para mandar a operação de alteração com base no registro posicionado da SE5
					If AllTrim( SE5->E5_TABORI ) == "FK1"
						aAreaFKs := GetArea()
						dbSelectArea( "FK1" )
						FK1->( DbSetOrder( 1 ) )
						If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
							//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
							cCamposE5:= "{"
   							cCamposE5+= "{'E5_VRETPIS', "+Str(aDadosRA1[3][nTit])+"}"
   							cCamposE5+= ",{'E5_VRETCOF', "+Str(aDadosRA1[4][nTit])+"}"
    						cCamposE5+= ",{'E5_VRETCSL', "+Str(aDadosRA1[5][nTit])+"}"
    						cCamposE5+= ",{'E5_VRETIRF', "+Str(aDadosRA1[6][nTit])+"}"

    						If aDadosRA1[3][nTit]+aDadosRA1[4][nTit]+aDadosRA1[5][nTit]>0
					  			cCamposE5+= ",{'E5_PRETPIS', '7'}"
    							cCamposE5+= ",{'E5_PRETCOF', '7'}" //Retido no RA
					  			cCamposE5+= ",{'E5_PRETCSL', '7'}" //Retido no RA
							Endif
							If aDadosRA1[6][nTit]>0
						   		cCamposE5+= ",{'E5_PRETIRF', '7'}"//Retido no RA
				 			Endif
				 			If lRaRtImp .And. cPaisLoc == "BRA"
				 				cCamposE5+= ",{'E5_PRISS', "+Str(aDadosRA1[10][nTit])+"}"
				 				cCamposE5+= ",{'E5_PRINSS', "+Str(aDadosRA1[11][nTit])+"}"
				 			Endif          
				 			cCamposE5+= "}"
				 			
							oModelMov := FWLoadModel("FINM010")
							oModelMov:SetOperation( 4 ) //Alteração
							oModelMov:Activate()
							oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
							oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1

							If oModelMov:VldData()
       	   					oModelMov:CommitData()
							   	SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
	       					oModelMov:DeActivate()
							Else
	       					lRet := .F.
		   				 		cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
		   	 					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
		   	 					cLog += cValToChar(oModelMov:GetErrorMessage()[6])

	       					If !lF330Auto  //Se não for rotina automatica
	       						Help( ,,"M030VALID",,cLog, 1, 0 )
       						Endif
							Endif
							oModelMov:DeActivate()
							oModelMov:Destroy()
							oModelMov:= nil
						Else //Se não achou o registro na FK1
							lRet := .F.
						Endif
						RestArea(aAreaFKs)
					Else //Se a origem do registro posicionado não for FK1
						lRet := .F.
					Endif
					aDadosRA1[9][nTit]:= .F.
					Exit
				Endif
			Next nTit
		Else
			If aDadosRA1[9][nTit]

				If AllTrim( SE5->E5_TABORI ) == "FK1"
					aAreaFKs := GetArea()
					dbSelectArea( "FK1" )
					FK1->( DbSetOrder( 1 ) )
					If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
						//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
						cCamposE5:= "{"
						cCamposE5+= "{'E5_VRETPIS', "+Str(aDadosRA1[3][nTit])+"}"
						cCamposE5+= ",{'E5_VRETCOF', "+Str(aDadosRA1[4][nTit])+"}"
   						cCamposE5+= ",{'E5_VRETCSL', "+Str(aDadosRA1[5][nTit])+"}"
   						cCamposE5+= ",{'E5_VRETIRF', "+Str(aDadosRA1[6][nTit])+"}"
   						If aDadosRA1[3][nTit]+aDadosRA1[4][nTit]+aDadosRA1[5][nTit]>0
				  			cCamposE5+= ",{'E5_PRETPIS', '7'}"
   							cCamposE5+= ",{'E5_PRETCOF', '7'}" //Retido no RA
				  			cCamposE5+= ",{'E5_PRETCSL, '7'}" //Retido no RA
						Endif
						If aDadosRA1[6][nTit]>0
					   		cCamposE5+= ",{'E5_PRETIRF', '7'}"//Retido no RA
			 			Endif
			 			If lRaRtImp .And. cPaisLoc == "BRA"
			 				cCamposE5+= ",{'E5_PRISS', "+Str(aDadosRA1[10][nTit])+"}"
			 				cCamposE5+= ",{'E5_PRINSS', "+Str(aDadosRA1[11][nTit])+"}"
			 			Endif
						cCamposE5+= "}"

						oModelMov := FWLoadModel("FINM010")
						oModelMov:SetOperation( 4 ) //Alteração
						oModelMov:Activate()
						oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
						oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1

						If oModelMov:VldData()
   	   						oModelMov:CommitData()
						   	SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
						Else
       					lRet := .F.
	   				 		cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
	   	 					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
	   	 					cLog += cValToChar(oModelMov:GetErrorMessage()[6])

       					If !lF330Auto  //Se não for rotina automatica
       						Help( ,,"M030VALID",,cLog, 1, 0 )
      						Endif
						Endif
						oModelMov:DeActivate()
						oModelMov:Destroy()
						oModelMov:= nil
					Else //Se não achou o registro na FK1
						lRet := .F.
					EndIf
					RestArea(aAreaFKs)
				Else //Se a origem do registro posicionado não for FK1
					lRet := .F.
				EndIf

			EndIf
		EndIf
	EndIf

EndIf

RestArea(aAreaSFQ)

Return

//--------------------------------------------------------------------------

Function FaDelSFQCR()

Local nI := 0
Local aRecSE5 := {}
Local lPccBxCr	:= FPccBxCr()
//Controla IRPJ na baixa
Local lIrPjBxCr		:= FIrPjBxCr()
Local aArea := GetArea()
Local nRecSE5 := 0
Local aSE1Area := SE1->(GetArea())
//  Variaveis de Uso do Model
Local aAreaFKs := {}
Local oModelMov := nil
Local cCamposE5 := ""
Local lRet := .T.

Private lRaRtImp  	:= FRaRtImp()       //Define se ha retencao de impostos PCC/IRPJ no R.A

If cPaisLoc == "BRA" .and. lPccBxCR
	nRecSe5  := SE5->(RecNo())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclui os registros de relacionamentos do SFQ                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aRecSE5 := FImpDelTit("E1B",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)
	For nI := 1 to Len(aRecSE5)
		SE5->(MSGoto(aRecSE5[nI]))

		If AllTrim( SE5->E5_TABORI ) == "FK1"
			aAreaFKs := GetArea()
			dbSelectArea( "FK1" )
			FK1->( DbSetOrder( 1 ) )
			If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
				//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
				cCamposE5 := "{"
				cCamposE5 += "{'E5_PRETPIS', '1'}"
				cCamposE5 += ",{'E5_PRETCOF', '1'}"
				cCamposE5 := ",{'E5_PRETCSL', '1'} }"
				oModelMov := FWLoadModel("FINM010")
				oModelMov:SetOperation( 4 ) //Alteração
				oModelMov:Activate()
				oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
				oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1

				If oModelMov:VldData()
					oModelMov:CommitData()
				Else
					lRet := .F.
					cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[6])       			
       			
					Help( ,,"M100VALID",,cLog, 1, 0 )
				Endif
				oModelMov:DeActivate()
				oModelMov:Destroy()
				oModelMov:= Nil
			Else //Se não achou o registro na FK1
				lRet := .F.
			EndIf
			RestArea(aAreaFKs)
		Else //Se a origem do registro posicionado não for FK1
			lRet := .F.
		EndIf

	Next
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclui os registros de relacionamentos do SFQ                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SE5->(dbGoto(nRecSe5))
	FImpDelSFQ("E1B",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Apaga os registros de impostos gerados na Baixa                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lIrPjBxCr .And. !lRartimp
		F070DelTxBx(SE1->E1_FILIAL)
	EndIf

EndIf
If cPaisLoc == "BRA" .and. lIrPjBxCr
	nRecSe5  := SE5->(RecNo())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclui os registros de relacionamentos do SFQ                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aRecSE5 := FImpDelTit("E5B",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)
	For nI := 1 to Len(aRecSE5)
		SE5->(MSGoto(aRecSE5[nI]))

		If AllTrim( SE5->E5_TABORI ) == "FK1"
			aAreaFKs := GetArea()
			dbSelectArea( "FK1" )
			FK1->( DbSetOrder( 1 ) )
			If MsSeek( xFilial("FK1") + SE5->E5_IDORIG )
				//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
				cCamposE5 := "{{'E5_PRETIRF', '1'}}"
				oModelMov := FWLoadModel("FINM010")
				oModelMov:SetOperation( 4 ) //Alteração
				oModelMov:Activate()
				oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
				oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1

				If oModelMov:VldData()
					oModelMov:CommitData()
				Else
					lRet := .F.
					cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[6])
					Help( ,,"M100VALID",,cLog, 1, 0 )
				Endif
				oModelMov:DeActivate()
				oModelMov:Destroy()
				oModelMov:= Nil
			Else //Se não achou o registro na FK1
				lRet := .F.
			Endif
			RestArea(aAreaFKs)
		Else //Se a origem do registro posicionado não for FK1
			lRet := .F.
		Endif

	Next
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclui os registros de relacionamentos do SFQ                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SE5->(dbGoto(nRecSe5))
	FImpDelSFQ("E5B",SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_TIPO,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_SEQ)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Apaga os registros de impostos gerados na Baixa                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SE1->E1_TIPO == MVRECANT .OR. SE1->E1_TIPO == MV_CRNEG .And. !lRartImp
			dbSelectArea("SE1")
			dbSetorder(1)
			Seek(xfilial("SE1")+SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO))
			F070DelTxBx(SE1->E1_FILIAL)
	Else
			If !lRartimp
			 F070DelTxBx(SE1->E1_FILIAL)
			Endif
	EndIf
EndIf
RestArea(aArea)
RestArea(aSE1Area)

Return

//--------------------------------------------------------------------------------

Function F330Button(lPccBxCr,oTitulo,oGet01,lMarkAll)

Default lMarkAll := .F. 
nValTot := 0

If (cPaisLoc == "BRA" .and. lPccBxCr .and. lCredito) .Or. cPaisLoc <> "BRA"
	aTitulos := FA330Troca(oTitulo:nAt,aTitulos,oGet01,.T.,,lMarkAll)
Else
	If lMarkAll  // Marca Todos 
		aEval(aTitulos, {|e| IIf(Fa330Lock(e[1]+e[2]+e[3]+e[4],,,Iif(MV_PAR02== 2, e[16],e[13]),.F.), (e[8] := .T.) , Nil ), If(e[8],(If(Fa330VTit(e[7])=0,e[7]:=e[6],Nil),nValTot += Fa330VTit(e[7]),e[9]:=DesTrans(e[7])),(e[7]:=Transf(0,"@E 9999,999,999.99"), e[9]:=DesTrans(e[7]) ))})
	Else
		aEval(aTitulos, {|e| IIf(!e[8].And.Fa330Lock(e[1]+e[2]+e[3]+e[4],,,Iif(MV_PAR02== 2, e[16],e[13]),.F.), (e[8] := .T.) , If(e[8], (Fa330UnLock(e[1]+e[2]+e[3]+e[4],,Iif(MV_PAR02== 2, e[16],e[13]),.F.),e[8] := .F. ),Nil)       ), If(e[8],(If(Fa330VTit(e[7])=0,e[7]:=e[6],Nil),nValTot += Fa330VTit(e[7]),e[9]:=DesTrans(e[7])),(e[7]:=Transf(0,"@E 9999,999,999.99"), e[9]:=DesTrans(e[7]) ))})
	Endif
EndIf

oTitulo:Refresh()
oGet01:Refresh()

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³FaNfsRAdt   ³ Autor ³Totvs                ³ Data ³10.05.2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Checa se condicao de pagamento do documento de saida usa    ³±±
±±³          ³adiantamento.                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se Condicao de Pagamento gera Adiantamento    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Prefixo do titulo                                    ³±±
±±³          ³ExpC2: Numero do titulo                                     ³±±
±±³          ³ExpC3: Codigo do cliente                                    ³±±
±±³          ³ExpC4: Loja do cliente                                      ³±±
±±³          ³ExpD5: Data de Emissao do Documento                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function FaNfsRAdt(cPrefixo,cNum,cCliente,cLoja,dDataEmis)

Local aArea := GetArea()
Local cQ := ""
Local lRet := .F.

cQ	:= "SELECT F2_COND "
cQ += "FROM "+RetSqlName("SF2")+" "
cQ += "WHERE F2_FILIAL = '"+xFilial("SF2")+"' "
cQ += "AND F2_PREFIXO = '"+cPrefixo+"' "
cQ += "AND F2_DUPL = '"+cNum+"' "
cQ += "AND F2_CLIENTE = '"+cCliente+"' "
cQ += "AND F2_LOJA = '"+cLoja+"' "
cQ += "AND F2_EMISSAO = '"+dTos(dDataEmis)+"' "
cQ += "AND D_E_L_E_T_= ' ' "

cQ := ChangeQuery(cQ)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQ),"TRBSF2",.T.,.T.)

If !Eof()
	If A410UsaAdi(TRBSF2->F2_COND)
		lRet := .T.
	Endif
Endif

TRBSF2->(dbCloseArea())

RestArea(aArea)

Return(lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³FaBxEmisDoc ³ Autor ³Totvs                ³ Data ³10.05.2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Checa se a compensacao do titulo foi gerada no momento da   ³±±
±±³          ³emissao do documento.Parametros devem ser o do titulo       ³±±
±±³          ³principal (Tipo de titulo = MVNOTAFIS).                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se a Compensacao foi realizada na geracao do  ³±±
±±³          ³Documento                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Filial do SE5                                        ³±±
±±³          ³ExpC2: Prefixo do titulo                                    ³±±
±±³          ³ExpC3: Numero do titulo                                     ³±±
±±³          ³ExpC4: Parcela do titulo                                    ³±±
±±³          ³ExpC5: Cliente/Fornecedor do titulo                         ³±±
±±³          ³ExpC6: Loja do titulo                                       ³±±
±±³          ³ExpC7: Tipo da baixa                                        ³±±
±±³          ³ExpD8: Data de emissao do titulo                            ³±±
±±³          ³ExpC9: Sequencia da baixa                                   ³±±
±±³          ³ExpC10: Carteira da baixa "R"/"P"                           ³±±
±±³          ³ExpC11: Numero do documento                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Esta rotina eh usada no contas a receber a pagar.           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FaBxEmisDoc(cFilSE5,cPrefixo,cNum,cParcela,cCliFor,cLoja,cTipo,dDataE,cSeq,cCarteira,cDocumen)

Local aArea 	:= GetArea()
Local cQ 		:= ""
Local lRet 		:= .F.
Local nCountFR3 := 0
Local nTamPref 	:= IIf(cCarteira = "R",__nTamPref,IIf(cCarteira = "P",__nTamE2Pr,0))
Local nTamNum 	:= __nTamNum
Local nTamParc 	:= __nTamParc
Local aAdianta	:= ProtCfgAdt()
Local lAdComPart:= aAdianta[1,5] .And. 'C' $ aAdianta[1,1]+aAdianta[1,2]+aAdianta[1,3]

// localiza quantas vezes o adiantamento foi utilizado neste documento de saida
cQ	:= "SELECT COUNT(*) AS NREG "
cQ += "FROM "+RetSqlName("FR3")+" "
cQ += "WHERE FR3_FILIAL = '"+xFilial("FR3")+"' "
cQ += "AND FR3_CART = '"+cCarteira+"' "
If cCarteira = "R"
	cQ += "AND FR3_CLIENT = '"+cCliFor+"' "
Elseif cCarteira = "P"
	cQ += "AND FR3_FORNEC = '"+cCliFor+"' "
Endif
cQ += "AND FR3_LOJA = '"+cLoja+"' "
cQ += "AND FR3_PREFIX = '"+Subs(cDocumen,1,nTamPref)+"' "
cQ += "AND FR3_NUM = '"+Subs(cDocumen,nTamPref+1,nTamNum)+"' "
cQ += "AND FR3_PARCEL = '"+Subs(cDocumen,nTamPref+nTamNum+1,nTamParc)+"' "
If cCarteira = "R"
	cQ += "AND FR3_TIPO IN "+FormatIn(MVRECANT,"/")+" "
Elseif cCarteira = "P"
	cQ += "AND FR3_TIPO IN "+FormatIn(MVPAGANT,"/")+" "
Endif
cQ += "AND FR3_DOC = '"+cNum+"' "

If lAdComPart
	cQ += " AND ( FR3_FILORI = '"+cFilAnt+"' OR FR3_FILORI = ' ') "
EndIf

cQ += "AND FR3_DATAE = '"+dTos(dDataE)+"' "
cQ += "AND EXISTS( SELECT 1 " // busca somente os registros que tenham o mesmo documento que estah sendo comparado, para evitar problema de titulos com mais de uma parcela, gerando divergencia na comparacao entre as parcelas.
cQ += "	FROM "+RetSqlName("FR3")+" "
cQ += "	WHERE FR3_FILIAL = '"+xFilial("FR3")+"' "
cQ += "	AND FR3_CART = '"+cCarteira+"' "
If cCarteira = "R"
	cQ += "	AND FR3_CLIENT = '"+cCliFor+"' "
Elseif cCarteira = "P"
	cQ += "	AND FR3_FORNEC = '"+cCliFor+"' "
Endif
cQ += "	AND FR3_LOJA = '"+cLoja+"' "

cQ += "	AND FR3_PREFIX = '"+cPrefixo+"' "
cQ += "	AND FR3_NUM = '"+cNum+"' "
cQ += "	AND FR3_PARCEL = '"+cParcela+"' "

cQ += "	AND FR3_TIPO = '"+MVNOTAFIS+"' "
cQ += "	AND FR3_DOC = '"+cNum+"' "

If lAdComPart
	cQ += " AND ( FR3_FILORI = '"+cFilAnt+"' OR FR3_FILORI = ' ') "
EndIf

cQ += "	AND FR3_DATAE = '"+dTos(dDataE)+"' "

cQ += "	AND D_E_L_E_T_= ' ') "
cQ += "AND D_E_L_E_T_= ' ' "

cQ := ChangeQuery(cQ)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQ),"TRBFR3",.T.,.T.)

nCountFR3 := TRBFR3->NREG

TRBFR3->(dbCloseArea())

If !Empty(nCountFR3)
	// localiza as baixa para o titulo principal por ordem de sequencia, para comparar com a quantidade de baixas ocorridas no momento da geracao do documento
	cQ	:= "SELECT R_E_C_N_O_ AS SE5RECNO,E5_PREFIXO,E5_NUMERO,E5_PARCELA,E5_TIPO,E5_CLIFOR,E5_LOJA,E5_SEQ "
	cQ += "FROM "+RetSqlName("SE5")+" "
	cQ += "WHERE E5_FILIAL = '"+cFilSE5+"' "
	cQ += "AND E5_RECPAG = '"+cCarteira+"' "
	cQ += "AND E5_SITUACA <> 'C' "
	cQ += "AND E5_DATA = '"+dTos(dDataE)+"' "
	cQ += "AND E5_NUMERO = '"+cNum+"' "
	cQ += "AND E5_PREFIXO = '"+cPrefixo+"' "
	cQ += "AND E5_PARCELA = '"+cParcela+"' "
	cQ += "AND E5_CLIFOR = '"+cCliFor+"' "
	cQ += "AND E5_LOJA = '"+cLoja+"' "
	cQ += "AND E5_TIPO = '"+cTipo+"' "
	cQ += "AND E5_MOTBX = 'CMP' "
	cQ += "AND E5_TIPODOC = 'CP' "
	cQ += "AND D_E_L_E_T_= ' ' "
	cQ += "AND E5_DOCUMEN = '"+cDocumen+"' " // considera somente as baixas que usaram este mesmo documento, ou seja, as baixas deste adiantamento
	cQ += "ORDER BY E5_FILIAL,E5_SEQ "

	cQ := ChangeQuery(cQ)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQ),"TRBSE5",.T.,.T.)

	While !Eof()
		If Empty(nCountFR3)
			Exit
		Endif
		If TemBxCanc(TRBSE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ),.T.)
			dbSkip()
			Loop
		Endif
		nCountFR3--
		// se sequencia da baixa for igual a do parametro, esta baixa foi efetuado junto com a emissao do documento
		If TRBSE5->E5_SEQ = cSeq
			lRet := .T.
		Endif
		dbSkip()
	Enddo

	TRBSE5->(dbCloseArea())
EndIf

RestArea(aArea)

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Fa330VldDtºAutor  ³ Clovis Magenta     º Data ³  13/01/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Consiste MV_DATAFIN antes de cancelar baixa/compensação    º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Fa330VldDt(aArray, nOpc)
Local lRet := .T.
DEFAULT nOpc := 5

If lRet .and. SuperGetMv("MV_BXDTFIN",,"1") == "2"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ A data da baixa deve ser passada como parametro, pois tanto ³
	//³ o cancelamento como a exclusao devem ser validados pela     ³
	//³ data de baixa e nao pela data base do sistema.              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF nOpc == 4  //Exclusao
		lRet := DtMovFin(CtoD(aArray[06]),!l330Auto,"2")
	Else
		lRet := DtMovFin( ,!l330Auto,"2")
	EndIf

EndIf

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³Fa330TxMd  ³ Autor ³ Cristiano Denardi    ³ Data ³ 05.04.05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Busca Taxa em aTxMoedas e verifica se foi trocada          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Fa330TxMd( nMoeda2, nTx ,lAcrDes)

Local lExistTxMd	:= Type("aTxMoedas")#"U" .And. Len(aTxMoedas) > 0

Default nTx			:= 0
Default nMoeda2 	:= 0
Default lAcrDes		:= .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Estrutura aTxMoedas         ³
//³ [1] -> Nome Moeda          	³
//³ [2] -> Taxa a Ser Utilizada	³
//³ [3] -> Picture          	³
//³ [4] -> Taxa do dia atual    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If nMoeda2 > 0 .And. lExistTxMd .AND. (nMoeda2<>SE1->E1_MOEDA)
	If aTxMoedas[nMoeda2][2] <> aTxMoedas[nMoeda2][4] .and. (aTxMoedas[nMoeda2][2]<>0)
		nTx := aTxMoedas[nMoeda2][2]
	Elseif (nTx <> aTxMoedas[nMoeda2][4]) .and. (aTxMoedas[nMoeda2][4]<>0)
		nTx := aTxMoedas[nMoeda2][4]
	Endif
ELSEIF (nMoeda2==SE1->E1_MOEDA)
	// se a moeda do titulo principal é 2 e a do titulo posicionado tb, nao convertemos pois os valores serao expressos em U$
	If !lAcrDes
		nTx := 1
	Endif
Endif

Return( nTx )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³Fa330Tx2  ³ Autor ³ Clovis Magenta       ³ Data ³ 31.08.11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Busca Taxa em aTxMoedas e verifica se foi trocada          ³±±
±±³Descrio ³ Funcao copiada da Fa340TxMd pois a Fa330TxMd() nao obtem   ³±±
±±³Descrio ³ resultado satisfatorio para alguns casos de conversao      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINXATU                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Fa330Tx2( nMoeda2, nTx )

Local lExistTxMd	:= Type("aTxMoedas")#"U" .And. Len(aTxMoedas) > 0
Default nTx			:= 0
Default nMoeda2 	:= 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Estrutura aTxMoedas         ³
//³ [1] -> Nome Moeda          	³
//³ [2] -> Taxa a Ser Utilizada	³
//³ [3] -> Picture          	³
//³ [4] -> Taxa do dia atual    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/

// Esta função só deve ser chamada pela rotina de compensação a RECEBER
If nMoeda2 > 0 .And. lExistTxMd .And. (__lCmTxCon .And. SE1->E1_TXMOEDA > 0) 
	If aTxMoedas[nMoeda2][2] <> aTxMoedas[nMoeda2][4] .and. (aTxMoedas[nMoeda2][2]<>0)
		nTx := aTxMoedas[nMoeda2][2]
	ElseIf (nTx == 0)
		nTx := aTxMoedas[nMoeda2][4]
	EndIf
EndIf

If SE1->E1_TXMOEDA == 0 .And. nMoeda2 > 1
	If nTx <> __nTxMoedP .And. __nTxMoedP > 0
		nTx := __nTxMoedP
	EndIf
EndIf 

Return( nTx )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Fin330ExCMºAutor  ³Clovis Magenta      º Data ³  07/02/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função que excluirá o registro de correção monetaria na SE5 º±±
±±º          ³ ao excluir uma compensacao                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fin330ExCM(cFilCmp, cSequen)
Local aArea 	:= GetArea()
Local aAreaSE5 	:= SE5->( GetArea() )
Local cChave	:= ""

DEFAULT cFilCmp := xFilial("SE5")
DEFAULT cSequen := SE5->E5_SEQ

SE5->(DbSetorder(7))
If SE5->( DbSeek(cFilCmp+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO) )
	cChave := cFilCmp+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO

	While cChave == SE5->(E5_FILIAL + E5_PREFIXO + E5_NUMERO + E5_PARCELA + E5_TIPO )
		If SE5->E5_TIPODOC $ "VM|CM" .AND. cSequen == SE5->E5_SEQ
			RecLock("SE5")
			DbDelete()
			MsUnLock()
		EndIf
		SE5->(DbSkip())
	EndDo
Endif

RestArea(aAreaSE5)
RestArea(aArea)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FINA330   ºAutor  ³Pâmela Bernardo     º Data ³  03/20/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função para recalcular o IR antes da geração do titulo de IRFº±±
±±º          ³na compensaçãdo de contas a receber                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Fina330                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FReCalIRB (aImpIr,nValTot,nTit, lAutomato)

//Controla IRPJ na baixa
Local lIrPjBxCr		:= FIrPjBxCr()
Local nPropIR		:= 0
Local aAreaSE1 		:= SE1->(GetArea())
Local lAplMinIR		:= SA1->A1_MINIRF == "2"
Local lIrfRetAnt	:= .F.

If cPaisLoc == "BRA" .and. lIrPjBxCr .and. (!lCredito .or. (lCredito .and. lAutomato ))
	nIrrf:=FCaIrBxCR(nValTot)
	If (nPosIr:=ascan(aImpIR,{|x| x[2]=SE1->(REcno())}))=0
		aAdd(aImpIR,{nIrrf,SE1->(Recno())})
		nPosIr := Len( aImpIR )
	Else
		aImpIR[nPosIr][1]:= nIrrf
	EndIf

Endif

If cPaisLoc == "BRA" .and. lIrPjBxCr .and. lCredito .and. Valtype(aImpIr) == "A" .and. !(lCredito .and. lAutomato .and. !__lBq10925) //porporciona o calculo do IR quando não alcança o valor minimo de retenção 
	SE1->(MSGoto(aImpIr[nTit][2]))
	nPropIR 	:= nValTot/SE1->E1_VLCRUZ
	nIrrf		:= Round(NoRound(SE1->E1_IRRF * nPropIR,3),2)
	nIRFBase 	:= Round(NoRound(SE1->E1_BASEIRF * nPropIR,3),2)
	nIrfBaseC	:= nIRFBase
	nIrfCalc	:= nIrrf
EndIf

//Controle de retencao anterior no mesmo periodo
lIrfRetAnt := Iif(nIrrf > GetMv("MV_VLRETIR"), .T., .F.)

If lAplMinIR .and. !lIrfRetAnt .and. lIrPjBxCr
	nIrrf := 0
Endif

RestArea(aAreaSE1)

Return nIrrf

//-------------------------------------------------------------------
/*/{Protheus.doc}F330PsqFil

@author Totvs
@since  11/06/2019
@version 12
/*/
//-------------------------------------------------------------------

Function F330PsqFil(cFilSE1 As Character,cPrefixo As Character,cNum As Character,cParcela As Character,cCliFor As Character,cLoja As Character,cTipo As Character,cCarteira As Character,cTipoDoc As Character, cAliasCmp As Character,cTrabalho As Character)

	Local aArea 	As Array
	Local cQryAux 	As Character

	aArea 	:= GetArea()

	if Select(cAliasCmp) > 0
		(cAliasCmp)->(dbCloseArea())
	endif
	cQryAux := ""
	
	cQryAux	:= "SELECT DISTINCT E5_FILIAL "
	cQryAux += "FROM "+RetSqlName("SE5")+" "
	cQryAux += "WHERE E5_RECPAG = '"+cCarteira+"' "
	cQryAux += "AND E5_SITUACA <> 'C' "
	cQryAux += "AND E5_NUMERO   = '"+cNum+"' "
	cQryAux += "AND E5_PREFIXO  = '"+cPrefixo+"' "
	cQryAux += "AND E5_PARCELA  = '"+cParcela+"' "
	cQryAux += "AND E5_CLIFOR   = '"+cCliFor+"' "
	cQryAux += "AND E5_LOJA     = '"+cLoja+"' "
	If !Empty(cFilSE1) .And. cPaisLoc == "BRA"
		cQryAux += "AND E5_FILORIG  = '"+cFilSE1+"' "
	EndIf
	cQryAux += "AND E5_MOTBX    = 'CMP' "
	cQryAux += "AND E5_TIPODOC  = '"+cTipoDoc+"' "
	cQryAux += "AND D_E_L_E_T_  = ' ' "
	cQryAux += "ORDER BY E5_FILIAL "
	
	cQryAux := ChangeQuery(cQryAux)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQryAux),cAliasCmp,.T.,.T.)
	
	(cAliasCmp)->( dbGoTop() )
	
	RestArea(aArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³GetInfSE5 ³ Autor ³Clovis Magenta         ³ Data ³26.10.2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Pega as informações da SE5->E5_DOCUMEN e divide em partes   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³aSE5: Array com as informações do SE5->E5_DOCUMEN           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cDoc: SE5->E5_DOCUMEN                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Static Function GetInfSE5(cDoc)
Local nPrefixo 	:= __nTamPref
Local nNum		:= __nTamNum
Local nParcel	:= __nTamParc
Local nTipo		:= __nTamTipo
Local nLoja		:= __nTamLoja
Local nCont		:= 1
Local aSE5		:= {}
Local nx		:= 0

Default cDoc := ""

For nX:=1 to 6
    Do Case
    	Case nX == 1
			Aadd(aSE5,substr(cDoc,1,nPrefixo ) )
			nCont += nPrefixo
    	Case nX == 2
			Aadd(aSE5,substr(cDoc,nCont,nNum ) )
			nCont += nNum
    	Case nX == 3
			Aadd(aSE5,substr(cDoc,nCont,nParcel ) )
			nCont += nParcel
    	Case nX == 4
			Aadd(aSE5,substr(cDoc,nCont,nTipo ) )
			nCont += nTipo
     	Case nX == 5
			Aadd(aSE5,substr(cDoc,nCont,nLoja ) )
	EndCase

Next nX

Return aSE5

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³FaPesqBx2 ³ Autor ³Felipe Cunha            ³ Data ³19.10.2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Checa se a compensacao do titulo foi gerada no momento da   ³±±
±±³          ³emissao do documento.Parametros devem ser o do titulo       ³±±
±±³          ³principal (Tipo de titulo = MVNOTAFIS).                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se a Compensacao foi realizada na geracao do  ³±±
±±³          ³Documento                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Filial do SE5                                        ³±±
±±³          ³ExpC2: Prefixo do titulo                                    ³±±
±±³          ³ExpC3: Numero do titulo                                     ³±±
±±³          ³ExpC4: Parcela do titulo                                    ³±±
±±³          ³ExpC5: Cliente/Fornecedor do titulo                         ³±±
±±³          ³ExpC6: Loja do titulo                                       ³±±
±±³          ³ExpC7: Tipo da baixa                                        ³±±
±±³          ³ExpD8: Data de emissao do titulo                            ³±±
±±³          ³ExpC9: Sequencia da baixa                                   ³±±
±±³          ³ExpC10: Carteira da baixa "R"/"P"                           ³±±
±±³          ³ExpC11: Numero do documento                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Esta rotina eh usada no contas a receber a pagar.           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
STATIC Function FaPesqBx2(cFilSE5,cPrefixo,cNum,cParcela,cCliFor,cLoja,cTipo,dDataE,cSeq,cCarteira,cDocumen,cTipoDoc)

Local aArea 	:= GetArea()
Local cQryAux 	:= ""
Local cFilorig 	:= ''
Local cTrabalho	:= ""

// localiza as baixa para o titulo principal por ordem de sequencia, para comparar com a quantidade de baixas ocorridas no momento da geracao do documento
cQryAux	:= "SELECT E5_FILORIG, E5_FILIAL "
cQryAux += "FROM "+RetSqlName("SE5")+" "
cQryAux += "WHERE E5_SEQ = '"+cSeq+"' "
cQryAux += "AND E5_RECPAG   = '"+cCarteira+"' "
cQryAux += "AND E5_SITUACA <> 'C' "
cQryAux += "AND E5_DATA 	= '"+dTos(dDataE)+"' "
cQryAux += "AND E5_NUMERO   = '"+cNum+"' "
cQryAux += "AND E5_PREFIXO  = '"+cPrefixo+"' "
cQryAux += "AND E5_PARCELA  = '"+cParcela+"' "
cQryAux += "AND E5_CLIFOR   = '"+cCliFor+"' "
cQryAux += "AND E5_LOJA     = '"+cLoja+"' "
cQryAux += "AND E5_MOTBX    = 'CMP' "
cQryAux += "AND E5_TIPODOC  = '"+cTipoDoc+"' "
cQryAux += "AND D_E_L_E_T_  = ' ' "
cQryAux += "ORDER BY E5_FILIAL,E5_SEQ "
cQryAux := ChangeQuery(cQryAux)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQryAux),"__TRBSE5",.T.,.T.)

If __TRBSE5->(!EOF())
	If Empty( __TRBSE5->E5_FILORIG ) .And. cPaisLoc == "MEX"
		cFilorig := __TRBSE5->E5_FILIAL
	Else
		cFilorig := __TRBSE5->E5_FILORIG
	EndIF
EndIf

__TRBSE5->(DbCloseArea())
RestArea(aArea)
If cTrabalho <> Nil .and. !Empty(cTrabalho)
	Ferase(cTrabalho+GetDBExtension())
	Ferase(cTrabalho+OrdBagExt())
EndIf

Return(cFilorig)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FINA330   ºAutor  ³TOTVS          º Data ³  05/15/13  	 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³  Acumula os impostos para compor o aTitulos                º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA330                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function F330RaRtIm(aDadosRA1,cValDig,nItemRA,nItemOU, lAltValor)

Local aArea	  		:= GetArea()
Local lRet			:= .T.
Local nBaseRA  		:= 0
Local nSaldoRA 		:= 0
Local nPisRA		:= 0
Local nCofRA		:= 0
Local nCslRA		:= 0
Local nIrfRA		:= 0
Local nBasOUIr		:= 0
Local nBasOUPis 	:= 0
Local nBasOUCof 	:= 0
Local nBasOUCsl 	:= 0
Local nBasOUIns 	:= 0
Local nBasOUIss 	:= 0
Local nSaldoOU 		:= 0
Local nPisOU		:= 0
Local nCofOU		:= 0
Local nCslOU		:= 0
Local nIrfOU		:= 0
Local nPrIsRA		:= 0     // Provisionamento de ISS e INSS
Local nPrIsOU		:= 0     // Provisionamento de ISS e INSS
Local nPrInRA		:= 0     // Provisionamento de ISS e INSS
Local nPrInOU		:= 0     // Provisionamento de ISS e INSS
Local nTxIr 		:= 1
Local nTxPis 		:= 1
Local nTxCof		:= 1
Local nTxCsl		:= 1
Local nTxIns		:= 1
Local nTxIss		:= 1
Local nTxSaldo		:= 1
Local ni 			:= 0
Local nItLcRA		:= 0
Local nItLcOU		:= 0
Local nSaldoCMP		:= 0
Local nProp			:= 1
Local nPropPis		:= 1
Local nPropCof		:= 1
Local nPropCsl		:= 1
Local nPropIr		:= 1
Local nPropIss		:= 1
Local nPropIns		:= 1

Default cValDig	:= 0
Default nItemRA	:= 0
Default nItemOU	:= 0
Default lAltValor := .F.

If nItemRA <> 0
	nItLcRA := nItemRA
Else
	nItLcRA := Len(aDadosRA1[1])
EndIf

If aDadosRA1[1][nItLcRA] <> 0
	SE1->(dbGoto(aDadosRA1[1][nItLcRA]))
	If SE1->E1_SALDO <> SE1->E1_VALOR //indica que houve baixa parcial
		nProp := SE1->E1_SALDO/SE1->E1_VALOR
	EndIf
	nBaseRA 	:= SE1->E1_BASEIRF * nProp
	nSaldoRA 	:= SE1->E1_SALDO
	If lRaRtImp .And. cPaisLoc == "BRA"
		nSaldoRA += (SE1->E1_PRISS * nProp)+ (SE1->E1_PRINSS* nProp)
		nPrIsRA  := SE1->E1_PRISS * nProp
		nPrInRA	 := SE1->E1_PRINSS * nProp
	EndIf

	If lCredito
		nSaldoCMP := SE1->E1_SALDO
	EndIf

	If cValDig <> 0 .and. cValDig <> nSaldoRA .and. lAltValor
		nSaldoRA := cValdig
	EndIf

	SE5->(dbSetOrder(2))
	SE5->(dbSeek( xFilial("SE5")+"RA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
	While (SE5->(!Eof()) .and. xFilial("SE5") == SE5->E5_FILIAL .And.	;
			SE5->E5_TIPODOC == "RA" .And. 				;
			SE5->E5_PREFIXO == SE1->E1_PREFIXO .And.				;
			SE5->E5_NUMERO == SE1->E1_NUM .And.					;
			SE5->E5_PARCELA == SE1->E1_PARCELA )

		If SE5->E5_RECPAG != "R"
			SE5->(dbSkip())
			Loop
		EndIf

		//Verifica se tem baixa cancelada
		If TemBxCanc(SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ),.T.,SE5->E5_FILIAL)
			SE5->(dbskip())
			Loop
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica Cliente 	³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SE5->E5_CLIFOR != SE1->E1_CLIENTE
			SE5->(dbSkip( ))
			Loop
		EndIf

		If SE5->E5_PRETPIS <> " "
			nPisRA		:= 0
		Else
			nPisRA		:= SE5->E5_VRETPIS * nProp
		EndIf
		If SE5->E5_PRETCSL <> " "
			nCslRA		:= 0
		Else
			nCslRA		:= SE5->E5_VRETCSL* nProp
		EndIf
		If SE5->E5_PRETCOF <> " "
			nCofRA		:= 0
		Else
			nCofRA		:= SE5->E5_VRETCOF* nProp
		EndIf
		If SE5->E5_PRETIRF <> " "
			nIrfRA		:= 0
		Else
			nIrfRA		:= SE5->E5_VRETIRF	* nProp
		EndIf

		Exit

	Enddo

	If Len(aDadosRA1[8]) > 0 .and. lCredito
		For ni := 1 to Len(aDadosRA1[8])
			nSaldoCMP -= aDadosRA1[8][ni]
		Next ni
	EndIf

	If Round(nSaldoRa+nPisRA+nCofRA+nCslRA+nIrfRA,2) <> Round(nBaseRA,2) .and. nBaseRA <> 0
		nTxSaldo	:= nSaldoRA/nBaseRA//-(nPisRA+nCofRA+nCslRA+nIrfRA)))
		nPisRA		:= Round(nPisRA*nTxSaldo,2)
		nCofRA		:= Round(nCofRA*nTxSaldo,2)
		nCslRA		:= Round(nCslRA*nTxSaldo,2)
		nIrfRA		:= Round(nIrfRA*nTxSaldo,2)
		nPrIsRA		:= Round(nPrIsRA*nTxSaldo,2)
		nPrInRA		:= Round(nPrInRA*nTxSaldo,2)
		nBaseRA		:= nSaldoRa//+nPisRA+nCofRA+nCslRA+nIrfRA+nPrIsRA+nPrInRA)
	EndIf

	If nItemOU <> 0
		nItLcOU := nItemOU
	Else
		nItLcOU := Len(aDadosRA1[2])
	EndIf

	If lRaRtImp .and. !lAltValor .And. cPaisLoc == "BRA"
		nSaldoRA -= (SE1->E1_PRISS*nProp)+ (SE1->E1_PRINSS *nProp)
	EndIf
	nProp:=1
	If aDadosRA1[2][nItLcOU] <> 0 
		SE1->(dbGoto(aDadosRA1[2][nItLcOU]))
		If SE1->E1_SALDO <> SE1->E1_VALOR //indica que houve baixa parcial			
			nPropPis	:= SE1->E1_SALDO/SE1->E1_BASEPIS
			nPropCof	:= SE1->E1_SALDO/SE1->E1_BASECOF
			nPropCsl	:= SE1->E1_SALDO/SE1->E1_BASECSL
			nPropIr		:= SE1->E1_SALDO/SE1->E1_BASEIRF
			nPropIss	:= SE1->E1_SALDO/SE1->E1_BASEISS
			nPropIns	:= SE1->E1_SALDO/SE1->E1_BASEINS
		EndIf

		nBasOUPis 	:= SE1->E1_BASEPIS * nPropPis
		nBasOUCof 	:= SE1->E1_BASECOF * nPropCof
		nBasOUCsl 	:= SE1->E1_BASECSL * nPropCsl
		nBasOUIr 	:= SE1->E1_BASEIRF * nPropIr		
		nBasOUIss 	:= SE1->E1_BASEISS * nPropIss
		nBasOUIns 	:= SE1->E1_BASEINS * nPropIns

		If MV_PAR08 == 1 .AND. !lRaRtImp
			nSaldoOU	:= SE1->E1_SALDO-(SE1->(E1_PIS+E1_COFINS+E1_CSLL+E1_IRRF)*nProp)
		Else
			nSaldoOU	:= SE1->E1_SALDO
		EndIf
		nPisOU		:= SE1->E1_PIS * nProp
		nCofOU		:= SE1->E1_COFINS* nProp
		nCslOU		:= SE1->E1_CSLL* nProp
		nIrfOU		:= SE1->E1_IRRF* nProp
		
		If lRaRtImp
			If !lCredito
				nSaldoOU -= ((SE1->E1_ISS* nProp)+ (SE1->E1_INSS* nProp))
			EndIf
			nPrIsOU	 := SE1->E1_ISS * nProp
			nPrInOU	 := SE1->E1_INSS* nProp
		EndIf

		If !lCredito .And. !lRaRtImp .And. !IsInCallStack("FA330Troca")
			nSaldoCMP := SE1->E1_SALDO-SE1->(E1_PIS+E1_COFINS+E1_CSLL+E1_IRRF)
		ElseIf !lCredito
		 	nSaldoCMP := SE1->E1_SALDO
		EndIf


		If cValDig <> 0 .and. cValDig <> nSaldoOU
			nSaldoOU := cValdig
		EndIf

		If Len(aDadosRA1[8]) > 0 .and. !lCredito
			For ni := 1 to Len(aDadosRA1[8])
				If aDadosRA1[1][nItLcRA] <> aDadosRA1[1][ni] .And. aDadosRA1[9][ni]
					If aTitulos[ni][9] == aDadosRA1[8][ni]
						nSaldoCMP -= aDadosRA1[8][ni] + aDadosRA1[3][ni] + aDadosRA1[4][ni] + aDadosRA1[5][ni] + aDadosRA1[6][ni] + aDadosRA1[10][ni] + aDadosRA1[11][ni]
					Else
						nSaldoCMP -= aDadosRA1[8][ni]
					EndIf 	
				EndIf 		 
			Next ni
		EndIf
		
		If cValDig <> 0 .and. cValDig <> nSaldoRA .And. lRaRtImp .And. IsInCallStack("FA330Troca") .and. !lCredito
			nBaseRA:= nSaldoCMP 
		EndIf 	


		If lCredito
			nTxPis 		:= IIF( (nBasOUPis/nBaseRA) > 1 , 1 , (nBasOUPis/nBaseRA) )
			nTxCof		:= IIF( (nBasOUCof/nBaseRA) > 1 , 1 , (nBasOUCof/nBaseRA) )
			nTxCsl		:= IIF( (nBasOUCsl/nBaseRA) > 1 , 1 , (nBasOUCsl/nBaseRA) )
			nTxIr 		:= IIF( (nBasOUIr/nBaseRA)  > 1 , 1 , (nBasOUIr/nBaseRA)  )
			nTxIss		:= IIF( (nBasOUIss/nBaseRA) > 1 , 1 , (nBasOUIss/nBaseRA) )
			nTxIns		:= IIF( (nBasOUIns/nBaseRA) > 1 , 1 , (nBasOUIns/nBaseRA) )				
		Else
			nTxPis 		:= IIF( (nBaseRA/nBasOUPis) > 1 , 1 , (nBaseRA/nBasOUPis) )
			nTxCof		:= IIF( (nBaseRA/nBasOUCof) > 1 , 1 , (nBaseRA/nBasOUCof) )
			nTxCsl		:= IIF( (nBaseRA/nBasOUCsl) > 1 , 1 , (nBaseRA/nBasOUCsl) )
			nTxIr 		:= IIF( (nBaseRA/nBasOUIr)  > 1 , 1 , (nBaseRA/nBasOUIr)  )
			nTxIss		:= IIF( (nBaseRA/nBasOUIss) > 1 , 1 , (nBaseRA/nBasOUIss) )
			nTxIns		:= IIF( (nBaseRA/nBasOUIns) > 1 , 1 , (nBaseRA/nBasOUIns) )			
		EndIf

		If lCredito
			nPisOU		:= If(nPisRA<>0,Round(nPisRA*nTxPis,2),Round(nPisOU*nTxPis,2))
			nCofOU		:= If(nCofRA<>0,Round(nCofRA*nTxCof,2),Round(nCofOU*nTxCof,2))
			nCslOU		:= If(nCslRA<>0,Round(nCslRA*nTxCsl,2),Round(nCslOU*nTxCsl,2))
			nIrfOU		:= If(nIrfRa<>0 .Or. ( lCredito .And. nBaseRA <= SE1->E1_SALDO ),Round(nIrfRA*nTxIr,2),Round(nIrfOU*nTxIr,2))
			nPrIsOU		:= If(nPrIsRA<>0,Round(nPrIsRA*nTxIss,2),Round(nPrIsOU*nTxIss,2))
			nPrInOU		:= If(nPrInRA<>0,Round(nPrInRA*nTxIns,2),Round(nPrInOU*nTxIns,2))
			If (SA1->A1_MINIRF == "2" .And. (nIrfOU <= SuperGetMv("MV_VLRETIR",.T.,10)) ) .OR. nIrfOU < 0
				nIrfOU	:= 0
			EndIf
		Else
			nPisRA		:= If(nPisOU<>0,Round(nPisOU*nTxPis,2),Round(nPisRA*nTxPis,2)) 
			nCofRA		:= If(nCofOU<>0,Round(nCofOU*nTxCof,2),Round(nCofRA*nTxCof,2))
			nCslRA		:= If(nCslOU<>0,Round(nCslOU*nTxCsl,2),Round(nCslRA*nTxCsl,2))
			nIrfRA		:= If(nIrfOU<>0,Round(nIrfOU*nTxIr,2),Round(nIrfRA*nTxIr,2))
			nPrIsRA		:= If(nPrIsOU<>0,Round(nPrIsOU*nTxIss,2),Round(nPrIsRA*nTxIss,2))
			nPrInRA		:= If(nPrInOU<>0,Round(nPrInOU*nTxIns,2),Round(nPrInRA*nTxIns,2))
			If (SA1->A1_MINIRF == "2" .And. (nIrfRA <= SuperGetMv("MV_VLRETIR",.T.,10)) ) .OR. nIrfRA < 0
				nIrfRA	:= 0
			EndIf
		EndIf
	Else
		lRet := .F.
	EndIf
Else
	lRet := .F.
EndIf

If lCredito
	nSaldoOU -= (nPisOU+nCofOU+nCslOU+nIrfOU+nPrIsOU+nPrInOU) 
Else
	// nIrfRA:= FCaIrBxCR(nBaseRA)
	nSaldoOU -= (nPisRA+nCofRA+nCslRA+nIrfRA+nPrIsRA+nPrInRA) 
EndIf

If lRet

	If lCredito
		If nItemOU <> 0
			aDadosRA1[3][nItLcOU] := nPisOU
			aDadosRA1[4][nItLcOU] := nCofOU
			aDadosRA1[5][nItLcOU] := nCslOU
			aDadosRA1[6][nItLcOU] := nIrfOU
			aDadosRA1[7][nItLcOU] := nSaldoOU
			aDadosRA1[8][nItLcOU] := If(aDadosRA1[7][nItLcOU]>nSaldoRA,nSaldoRA,aDadosRA1[7][nItLcOU])
			aDadosRA1[10][nItLcOU]:= nPrIsRA
			aDadosRA1[11][nItLcOU]:= nPrInRA

		Else
			aAdd(aDadosRA1[3],nPisOU)
			aAdd(aDadosRA1[4],nCofOU)
			aAdd(aDadosRA1[5],nCslOU)
			aAdd(aDadosRA1[6],nIrfOU)
			aAdd(aDadosRA1[7],nSaldoOU)
			aAdd(aDadosRA1[8],If(aDadosRA1[7][Len(aDadosRA1[7])]>nSaldoRA,nSaldoRA,aDadosRA1[7][Len(aDadosRA1[7])]))
			aAdd(aDadosRA1[10],nPrIsRA)
			aAdd(aDadosRA1[11],nPrInRA)
		EndIf
	Else
		If nItemRA <> 0
			aDadosRA1[3][nItLcRA] := nPisRA
			aDadosRA1[4][nItLcRA] := nCofRA
			aDadosRA1[5][nItLcRA] := nCslRA
			aDadosRA1[6][nItLcRA] := nIrfRA
			aDadosRA1[7][nItLcRA] := nSaldoRA
			aDadosRA1[8][nItLcRA] := If(aDadosRA1[7][nItLcRA]>nSaldoOU,nSaldoOU,aDadosRA1[7][nItLcRA])
			aDadosRA1[10][nItLcRA]:= nPrIsRA
			aDadosRA1[11][nItLcRA]:= nPrInRA

		Else
			aAdd(aDadosRA1[3],nPisRA)
			aAdd(aDadosRA1[4],nCofRA)
			aAdd(aDadosRA1[5],nCslRA)
			aAdd(aDadosRA1[6],nIrfRA)
			aAdd(aDadosRA1[7],nSaldoRA)
			aAdd(aDadosRA1[8],If(aDadosRA1[7][Len(aDadosRA1[7])]>nSaldoOU,nSaldoOU,aDadosRA1[7][Len(aDadosRA1[7])]))
			aAdd(aDadosRA1[10],nPrIsRA)
			aAdd(aDadosRA1[11],nPrInRA)

		EndIf
	EndIf

EndIf

RestArea(aArea)

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FA330Fil  ºAutor  ³Microsiga           ºFecha ³ 08/07/2013  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Permite determinar as filias para selecao dos titulos       º±±
±±º          ³para liquidacao.                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Fa330Fil() As Array
	Local aRet	As Array
	
	aRet	:= {}

	If MsgYesNo(STR0066 + " " + STR0067 + CRLF + CRLF + STR0068 + CRLF + CRLF + STR0069,STR0018)
		//"Serão selecionados somente os títulos das filiais escolhidas." + " " + "Se nenhuma for escolhida serão considerados somente os da filial corrente." + CRLF + CRLF + "Importante: Algumas entidades, como clientes, bancos etc, podem possuir um código na filial A, porém na filial B, esse mesmo código não necessariamente representa a mesma entidade." + CRLF + CRLF + "Deseja continuar com a seleção de filiais?"
		aRet := AdmGetFil(.F.,.T., "SE1")
	Else
		aRet := {}
	EndIf

Return(Aclone(aRet))

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FINA330   ºAutor  TOTVS		         º Data ³  07/23/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Recompor Valor de compensação, nSaldo, limite de compensaçãoº±±
±±º          ³ quando marcado uma NCC para compensação                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FINA330                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function F330VALNCC(aArray As Array, nX As Numeric, lAltValor As Logical, lSoma As Logical)

	Local nProp		As Numeric
	Local nLim 		As Numeric
	Local nPos 		As Numeric
	Local nImpBx 	As Numeric
	
	nProp	:= 0
	nLim 	:= 0
	nPos 	:= 0
	nImpBx 	:= 0
	
	nPis	:= 0
	nCofins	:= 0
	nCsll	:= 0
	nIrrf	:= 0

	DEFAULT nX 			:= 1
	DEFAULT lAltValor 	:= .F.
	DEFAULT aArray		:= {}
	DEFAULT lSoma		:= .F.
	
	If MV_PAR02 == 2
		nPos := 25
	Else
		nPos := 22
	EndIf
	If MV_PAR08 == 1
		nImpBx := nTotImpbx-nIss-nInss
	Else
		nImpBx := nTotImpbx
	EndIf
	
	If lAltValor
		nProp:=  aTitulos[nX,9]/SE1->E1_VALOR
	Else
	    If aArray[nX,(nPos+1)]< SE1->E1_VALOR
			nProp:= aTitulos[nX,(nPos+1)]/SE1->E1_VALOR
		Else
			nProp:=  1
		EndIf
	EndIf
	If lSoma
		nLim := Fa330VTit(aArray[nX,Iif(cPaisLoc != "RUS",nPos,6)])
		nSaldo+= nImpBx*nProp
		nLim += nImpBx *nProp
		If nLim <= aArray[nX,(nPos-1)]
			aArray[nX,nPos]:= Transf(nLim,__cPiE1Sld)
		Endif
	
	Else
		nLim := Fa330VTit(aArray[nX,Iif(cPaisLoc != "RUS",nPos,6)])
		nSaldo-= nImpBx *nProp
		nLim -= nImpBx *nProp
		If nLim <= aArray[nX,(nPos-1)]
			aArray[nX,nPos]:= Transf(nLim,__cPiE1Sld)
		EndIf
	EndIf

Return

//------------------------------------------------------------------------------------------------------------------------
//	Função	| FA330RetPCC()
//	Autor	| Pedro Pereira Lima
//	Data	| 21/01/2014
//	Uso		| Utilizada para retornar o valor total dos títulos de impostos PIS, COFINS e CSLL gerados na baixa
//	-		| e que estão com o campo E1_TIPO preenchido como "COF", "CSL" e "PIS", ao invés de "CF-", "CS-" e "PI-"
//------------------------------------------------------------------------------------------------------------------------
Function FA330RetPCC(cPrefixo,cNum,cParcela,nMoeda,dData)

Local cFilAbat		:= xFilial("SE1")
Local bWhile		:= {|| !Eof() .And. E1_FILIAL == cFilAbat .And. E1_PREFIXO == cPrefixo .And. E1_NUM == cNum .And. E1_PARCELA == cParcela}
Local nTotImp		:= 0
Local cCliLj		:= SE1->(E1_CLIENTE+E1_LOJA)
Local cTipo			:= SE1->E1_TIPO
Local aArea			:= GetArea()
Local lRaRtImp  	:= FRaRtImp()

Default cPrefixo	:= ""
Default cNum		:= ""
Default cParcela	:= ""
Default nMoeda		:= 0
Default dData		:= dDataBase
Default cSeq		:= ""

If Empty(cPrefixo) .And. Empty(cNum) .And. Empty(cParcela)
	RestArea(aArea)
	Return nTotImp
EndIf

DbSelectArea("SE1")

If  (nOrdTitPai:= OrdTitpai()) > 0
	DbSetOrder(nOrdTitPai)
	If	DbSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+cTipo+cCliLj)   
		bWhile := {|| !Eof() .And. E1_FILIAL + AllTrim(E1_TITPAI) ==  cFilAbat+Alltrim(cPrefixo+cNum+cParcela+cTipo+cCliLj)}
	Else
		DbSetOrder(1)
		DbSeek(cFilAbat+cPrefixo+cNum+cParcela)
	Endif
Endif

While Eval(bWhile)
	If !Empty(E1_TITPAI) .And. (Alltrim(E1_TITPAI) != Alltrim(cPrefixo+cNum+cParcela+cTipo+cCliLj))
		DbSkip()
		Loop
	EndIf
	
	If E1_CLIENTE+E1_LOJA == cCliLj .And. !(lRartimp .And. cTipo $ MVRECANT)
		If E1_TIPO $ "COF|CSL|PIS"
			nTotImp += xMoeda(E1_VALOR,E1_MOEDA,nMoeda,dData,,,0)
		EndIf
	EndIf
	
	DbSkip()
	
EndDo

RestArea(aArea)
Return nTotImp  

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±                                                                         ±±
±±            Funcoes retiradas do arquivo FINXATU.PRX                     ±±
±±                                                                         ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³ fA330Grv ³ Autor ³ Valter G. Nogueira Jr.³ Data ³ 21/03/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Funo utilizada para atualizar a baixa efetuada			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fA330Grv(lPadrao) 										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FinA330													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fA330Grv(lPadrao,nValor,cAdiantamento,cSeq,nRegCmp,aBaixas,cOrigem,lCredito,nContab,;
					nAcresc,nDecres,aBaixaSE5,nTotAbto,aImpPcc,cSequencia,cDadosTitulo,nIrrf,ntotIrbx,;
					nPrIss, nPrInss, lNcc, nDescP, nDescD, nIrrfParc, nValLim, nValVa, nRegSe5Ori)

Local nSaldo		:= 0
Local nSalvRec		:= 0
Local nAtraso		:= 0
Local nTitAcres		:= SE1->E1_SDACRES		//Acrescimo do titulo principal
Local nTitDecre		:= SE1->E1_SDDECRE		//Decrescimo do titulo principal
Local nVlMinImp 	:= GetNewPar("MV_VL10925",5000)
Local lRaRtImp		:= FRaRtImp()
//Controla o Pis Cofins e Csll na baixa (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default))
Local lPccBxCr		:= FPccBxCr()
//Controla IRPJ na baixa
Local lIrPjBxCr		:= FIrPjBxCr()
Local cCliente		:= ""
Local cLoja			:= ""
Local nTamSeq		:= __nTamSeq
Local nDecs1 		:= MsDecimais(1)
Local nVrAbat		:= 0
Local lFina330  	:= IsInCallStack("FINA330")
Local lCompRa		:=	.F.
//Controle de abatimento
Local lTitpaiSE1	:= .T.
Local cTipo 		:= ""
Local nOrdTitPai	:= 0
Local bWhile		:= {|| !EOF() .And. E1_FILIAL==xFilial("SE1") .And. E1_PREFIXO=cPrefixo	.And.	E1_NUM==cNum .And. E1_PARCELA==cParcela .And. E1_CLIENTE==cCliente .And. E1_LOJA==cLoja}
Local cTipoAux		:= ""
Local xFilSE1		:= SE1->E1_FILIAL
//Impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
Local nPisFin061	:=	0
Local nCofFin061	:=	0
Local nCslFin061	:=	0
Local nIrfFin061	:=	0
Local nRegSE5		:=	0
Local nOrdSE5		:=	0
Local nX			:=	0
Local nPosRec     	:= 0
Local aPcc			:= Array(4)
Local ntitulo1		:= 0
Local nI			:= 0
Local aAreaSE		:= {}
Local cChave
Local nPropPCC		:= 0
Local lPropBx  		:= SuperGetMv("MV_PROPBX",.F.,"2") == "1"
Local aImp			:= {}
Local lCalcIssBx 	:=  GetNewPar("MV_MRETISS","1") == "2"
Local lRaRtImpMR 	:= .F.
Local lIrfBxAux 	:= lIrPjBxCr
Local lPccBxAux 	:= lPccBxCr
Local cSaldoAux 	:= ""
Local nBaseImp		:= 0
Local nSaldoVa		:= 0
Local nMVToler		:= SuperGetMv("MV_TOLERPG",,0.01)
Local nToler		:= IF(nMVToler==0,0.01,nMVToler)
Local lAjstSld		:= .F.

DEFAULT cOrigem		:= "  "
DEFAULT lCredito	:= .F.
DEFAULT nContab		:= 1			//1=Sim, 2=Nao
DEFAULT nAcresc		:= 0
DEFAULT nDecres		:= 0
DEFAULT aBaixaSE5	:= {}
DEFAULT nTotAbto	:= SumAbatRec(cPrefixo,cNum,cParcela,SE1->E1_MOEDA,"S",dBaixa)
DEFAULT aImpPcc		:= {0,0,0}
DEFAULT cSequencia	:= Replicate("0",nTamSeq)
DEFAULT nIrrf		:= 0     
DEFAULT ntotIrbx	:= 0    
DEFAULT nPrIss		:= 0 // Provisionamento do INSS e ISS no RA
DEFAULT nPrInss		:= 0 // Provisionamento do INSS e ISS no RA
DEFAULT lNcc		:= .F.
DEFAULT nDescP  	:= 0
DEFAULT nDescD  	:= 0
DEFAULT nIrrfParc 	:= 0
Default nValLim 	:= 0
Default nValVa	  := 0
Default nRegSe5Ori	:= 0 
	
//Motor de retenções
If __lMotRet
	//Verifica as configurações de impostos pelo motor de retenção
	__cOldMRCf  := "" 
	__lTCnfgMR := F330VldImp()
	
	lRaRtImpMR := ( __lPccMR .And. __lRaRtPcc ) .Or. ( __lIrfMR .And. __lRaRtIrf ) .Or. ( __lIssMR .And. __lRaRtIss )
	lPccBxCr := ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
	lIrPjBxCr := ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
	
	//Calcula os impostos pelo motor de retenções
	If __lTCnfgMR
		nBaseImp := FBaseImp(nValor)
		F330CalImp( SE1->E1_NATUREZ, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG, nBaseImp, dDataBase, SE1->E1_TIPO )
		__lTCnfgMR	:= .F.
	EndIf
EndIf

__cToler	:= ""
aPcc[1]		:= .F.

If dDataBase >= dLastPcc
	nVlMinImp	:= 0
EndIf
nDescP := If(Type("nDescP") != "N",0,nDescP)
nDescD := If(Type("nDescD") != "N",0,nDescD)

// Conversão de valores para garantir que o saldo será abatido conforme moeda do titulo
// Podemos compensar titulos de moedas diferentes, o que causa atenção nas atualizações de saldos
nValor 	:= xMoeda(nValor,nMoeda,SE1->E1_MOEDA,,nDecs1+1,__nTxMoedP)
nVrAbat	:=	nTotAbto
If !lNcc
	nTotAbto += iif( lPccBxCr, nPis + nCofins + nCsll, 0 )
	nTotAbto -= iif( ( lRartImp  .Or. lRaRtImpMR ) .And. lCredito, nPis + nCofins + nCsll, 0 )
	nTotAbto += iif( lIrPjBxCr .And. !lCredito, nIrrf, 0 )
Endif

nRegSE5	:=	SE5->(Recno())
nOrdSE5	:=	SE5->(IndexOrd())		
If SE1->E1_TIPO <> MVRECANT .And. SE1->E1_TIPO <> MV_CRNEG .And. (lPccBxCr .Or. lIrPjBxCr)
	dbSelectArea("SE5")
	SE5->(dbSetOrder(2)) //FILIAL + TIPODOC + PREFIXO + NUMERO + PARCELA + TIPO
	If SE5->(dbSeek(xFilial("SE5")+"BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
		While !SE5->(Eof()) .and. SE5->E5_FILIAL==xFilial("SE5") .And. ;
			SE5->E5_TIPODOC+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO=="BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO		
		
			If  ("FINA061" $ Subst(SE5->E5_HISTOR,1,7) .Or. "FINA891" $ Subst(SE5->E5_HISTOR,1,7)) .And. SE5->E5_MOTBX $ "PCC_IRF"						
				If Alltrim(SE5->E5_MOTBX) == "PCC"
				   nPisFin061	+= SE5->E5_VRETPIS
				   nCofFin061	+= SE5->E5_VRETCOF
				   nCslFin061	+= SE5->E5_VRETCSL
				ElseIf Alltrim(SE5->E5_MOTBX) == "IRF"
				   nIrfFin061	+= SE5->E5_VRETIRF
				EndIf
			Endif					
			SE5->(DbSkip())		
	   EndDo
	EndIf
EndIf
SE5->(Dbgoto(nRegSE5))
SE5->(Dbsetorder(nOrdSE5))

If ((SE1->E1_SALDO + nTitAcres - nTitDecre - If((mv_par08 == 1 .Or. ( lRaRtImp .Or. lRaRtImpMR ) ) .And. !lCredito,nTotAbto,0)) - nValor) <= nToler
	nSaldo := (SE1->E1_SALDO + nTitAcres - nTitDecre - nDescP - If(((mv_par08 == 1 .AND. !lPccBxCr) .Or. ( lRaRtImp .Or. lRaRtImpMR ) ),nTotAbto,0) ) - nValor	// moeda do tit principal
	If nTotAbto <> 0
		nSaldo 		:= 0
		lAjstSld	:= .T.
	EndIf
Else
	If (nPisFin061+nCofFin061+nCslFin061+nIrfFin061) > 0 .And. mv_par08 == 2 .And. Alltrim(Upper(FunName())) == "FINA330"
		nSaldo := SE1->E1_SALDO - (nValor - nTitAcres + nTitDecre) - nDescP   	// moeda do tit principal  
		If nSaldo > 0.009999
			nSaldo += (nPisFin061+nCofFin061+nCslFin061+nIrfFin061)
		EndIf
	Else
		nSaldo:= SE1->E1_SALDO - (nValor - nTitAcres + nTitDecre) - nDescP	// moeda do tit principal
  	EndIf
EndIf

If !lCredito
	nSaldo += nValVa 
EndIf

If !lCredito .And. ( ( !lRartimp .And. !lRaRtImpMR ) ) .And. !lNcc .And. !(ABS(nSaldo) <= nMVToler)
	nSaldo := SE1->E1_SALDO - (nValor - nTitAcres + nTitDecre + nPrIss + nPrInss) - nDescP + nValVa

	If __lBq10925 
		If (nSaldo > 0 .And. lIrPjBxCr) .Or. lPropBx 
			nSaldo -= nIrrf
		EndIf
		If (nSaldo > 0 .And. lPccBxCr) .Or. lPropBx
			nSaldo -= ( nPis + nCofins + nCsll )
		EndIf
		If lPropBx .And. nIss > 0 .And. nPrIss == 0
			nSaldo -= nIss
		ElseIf nSaldo > 0 .And. lCalcIssBx .And. !lPropBx
			nSaldo -= nIss
		EndIf
		// Não será usado o nTotAbto, pois o valor do ISS e INSS deverá ser considerado em todas as compensações devido ao provisionamento
		nSaldo -= __nImpMR
	EndIf
ElseIf lCredito .And. ( ( !lRartimp .And. !lRaRtImpMR ) ) .And. !lNcc

	nSaldo := SE1->E1_SALDO - (nValor - nTitAcres + nTitDecre + nPrIss + nPrInss) - nDescP + nValVa

	If !__lBq10925 
		If lIrPjBxCr
			nSaldo += xMoeda(nIrrf, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
		EndIf
		If lPccBxCr
			nSaldo += xMoeda(( nPis + nCofins + nCsll ), 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
		EndIf
		If lPropBx .And. nIss == 0 .And. nPrIss == 0
			nSaldo += xMoeda(nIss, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
		ElseIf lCalcIssBx
			nSaldo += xMoeda(nIss, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP)
		EndIf
		// Não será usado o nTotAbto, pois o valor do ISS e INSS deverá ser considerado em todas as compensações devido ao provisionamento
		nSaldo -= __nImpMR
	EndIf
EndIf

If nMoeda > 1 .And. nSaldo < nToler
	nSaldo := 0
EndIf

//Tolerância de Recebimento
If nSaldo <> 0

	//Valor recebido a menor
	If nMVToler > 0
		If nSaldo > 0
			If nSaldo <= nMVToler
				nTitDecre	+= nSaldo	
				nSaldo		:= 0
				__cToler	:= "D"
			EndIf
		EndIf
	ElseIf lAjstSld
		nTitDecre	+= nSaldo
		__cToler	:= "D"
	ElseIf nSaldo < 0
		nSaldo := 0
	EndIf
EndIf

cSeq := IIf( cSeq == Nil, PadL("1",nTamSeq,"0"), cSeq )

If SE1->E1_SDACRES >= nValor
	nSaldo 	  := SE1->E1_SALDO
	nTitAcres := nValor
Endif

//--------------------------------------------------------
//ATUALIZA SALDO DO TITULO DE PARTIDA DA COMPENSAÇÃO
//--------------------------------------------------------
RecLock("SE1")
Replace E1_SALDO   With nSaldo
Replace E1_BAIXA   With Iif(E1_BAIXA <= dBaixa, dBaixa, E1_BAIXA)
Replace E1_LOTE    With cLote
Replace E1_MOVIMEN With dBaixa
Replace E1_DESCONT With nDescP
Replace E1_MULTA   With 0
Replace E1_JUROS   With nTitAcres
Replace E1_CORREC  With 0
If cPaisLoc == "BRA"
	Replace E1_VALLIQ With xMoeda(nValor, nMoeda, SE1->E1_MOEDA, , nDecs1+1, __nTxMoedP) // Valliq na moeda do título
Else
	E1_VALLIQ   += nValor 
EndIf
Replace E1_STATUS   With IIF(E1_STATUS != "R",Iif(E1_SALDO >= 0.01,"A","B"),"R")
Replace E1_SDDECRE  With E1_SDDECRE - nTitDecre
Replace E1_SDACRES  With IIF(SE1->E1_SDACRES >= nValor , E1_SDACRES - nValor , E1_SDACRES - nTitAcres)
SE1->(MsUnlock())

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ PONTO DE ENTRADA NA ALTERACAO DO HISTORICO NA SE1                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock( "F330AHE1" )
   ExecBlock("F330AHE1",.F.,.F.)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se h  ponto de entrada 	³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("FA330SE1")
	Execblock("FA330SE1",.F.,.F.)
EndIf

cNumero	:= E1_NUM
cPrefixo := E1_PREFIXO
cParcela := E1_PARCELA
cCliente := E1_CLIENTE
cLoja	 := E1_LOJA
cTipoTit := ""
nSalvRec := SE1->(RecNo())

If ! ( SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG ) .and. nSaldo > 0
	nTotAbat := SumAbatRec(cPrefixo,cNumero,cParcela,1,"S")
Else
	nTotAbat := 0
EndIf

RecLock("SE1")
If cPaisLoc == "BRA" .And. lPccBxCr .And. !lCredito	
	
	If !__lPccMR
		
		If dDataBase < dLastPcc
			If (if(nSaldo==0 .and. nTotAbto > nVrAbat,Str(nTotAbto-nVrAbat,16,2),Str(nSaldo,16,2))=Str(aImpPcc[1]+aImpPcc[2]+aImpPcc[3],16,2));
				.or. (nSaldo==0 .and. (Str(nTotAbto-nVrAbat,16,2))>(Str(aImpPcc[1]+aImpPcc[2]+aImpPcc[3],16,2))) ;
				.or. (nSaldo == nTotAbat)
				
				nPis 	:= aImpPcc[1] //entra aki para gravar na baixa total não proporcionaliza
				nCofins := aImpPcc[2]
				nCsll	:= aImpPcc[3]
				nPisBaseR 	:= Round(NoRound(nCsll * 100,3),2) //trecho retirado do FA070TOTMES
				nPisBaseC 	:= Round(NoRound(nCsll * 100,3),2) // no calculo do PCC na função F330CalcPCC não considera cumulatividade, portanto a mesma base de calculo é a de retenção
				nCofBaseR 	:= Round(NoRound(nCsll * 100,3),2)
				nCofBaseC 	:= Round(NoRound(nCsll * 100,3),2)
				nCslBaseR 	:= Round(NoRound(nCsll * 100,3),2)
				nCslBaseC 	:= Round(NoRound(nCsll * 100,3),2)			
			Else	
				If (MV_PAR08==1 .Or. lRaRtImp) .And. !lNcc
					If lRaRtImp .And. !lNcc
						If Len(aTitulos) > 0
							ntitulo1 += nValor+nPis+nCofins+nCsll+nIrrf+nIss+nInss
							nPropPcc := (ntitulo1 / SE1->E1_VALOR)
						Else
							nPropPcc := nPis/SE1->E1_PIS
						EndIf
					ElseIf !lRaRtImp .And. !lNcc
						If aDadosret[1] <= nVlMinImp .And. aDadosret[1] + nValor > nVlMinImp .And. lPccBxCr .And. (!lIrPjBxCr .Or. SE1->E1_ISS > 0)
							If nValPis > 0 
								nPropPcc := nPis/SE1->E1_PIS
							Else
								nPropPcc	:= (aDadosRet[1] + nValor + nPis + nCofins + nCsll)/(nValor + nPis + nCofins + nCsll)
							EndIf
						ElseIf aDadosret[1] < nVlMinImp .and. aDadosret[1] + nValor > nVlMinImp .and. lPccBxCr 
							nPropPcc	:=  (aDadosret[1] + nValor + nTotAbto)/(nValor + nTotAbto)	
						ElseIf nValor > nVlMinImp
							nPropPcc := nValor/SE1->E1_VLCRUZ
						ElseIf aDadosret[1] <= nVlMinImp .and. aDadosret[1] + nValor <= nVlMinImp .and. lPccBxCr .and. (!lIrPjBxCr .or. SE1->E1_ISS > 0)
							nPropPcc	:= nPis/SE1->E1_PIS
						ElseIf (aDadosret[1] > nVlMinImp .and. aDadosret[1] + nValor > nVlMinImp) .and. lPccBxCr .and. (!lIrPjBxCr .or. SE1->E1_ISS > 0)
							nPropPcc := nValor/SE1->E1_VLCRUZ
						Else
							nPropPcc := 0
						EndIf
					Else
						nPropPcc := (nValor*nTotAbto)/SE1->E1_VLCRUZ //é aqui o ntotabto está 0 pq é NCC
						nPropPcc := (nPropPcc/nTotAbto)
					EndIf
				Else
					If !lRARtImp .and. mv_par08 == 2 .and. aDadosret[1] <= nVlMinImp .and. aDadosret[1] + nValor > nVlMinImp .and. lPccBxCr .and. (!lIrPjBxCr .or. SE1->E1_ISS > 0)
						nPropPcc := (aDadosret[1] + nValor )/(SE1->E1_VLCRUZ)
					ElseIf nValor > nVlMinImp .or. aDadosret[1] + nValor > nVlMinImp 
						nPropPcc := nValor/SE1->E1_VLCRUZ
					Else 
						nPropPcc := 0
					Endif
				Endif
				
				If Str(nSaldo,16,2)<>Str(nPis+nCofins+nCsll+nTotAbat,16,2)
					nPis		:= Round(NoRound(SE1->E1_PIS * nPropPCC,3),2)
					nCofins		:= Round(NoRound(SE1->E1_COFINS * nPropPCC,3),2)
					nCsll		:= Round(NoRound(SE1->E1_CSLL * nPropPCC,3),2)
					nPisBaseR	:= Round(NoRound(SE1->E1_BASEPIS * nPropPCC,3),2)
					nPisBaseC	:= Round(NoRound(SE1->E1_BASEPIS * nPropPCC,3),2)
					nCofBaseR	:= Round(NoRound(SE1->E1_BASECOF * nPropPCC,3),2)
					nCofBaseC	:= Round(NoRound(SE1->E1_BASECOF * nPropPCC,3),2)
					nCslBaseR	:= Round(NoRound(SE1->E1_BASECSL * nPropPCC,3),2)
					nCslBaseC	:= Round(NoRound(SE1->E1_BASECSL * nPropPCC,3),2)
					
					aImpPcc[1]	-= nPis
					aImpPcc[2]	-= nCofins
					aImpPcc[3]	-= nCsll							
				Endif
				
				If lIrPjBxCr
					If MV_PAR08 == 1 .And. !lRaRtImp .And. nIrrf == nSaldo //Ultima baixa considera o restante de IRRF
						nIRFBase  	:= Round(NoRound(SE1->E1_BASEIRF * nPropPCC,3),2)
					Else 
						nIrrf		:= Round(NoRound(SE1->E1_IRRF * nPropPCC,3),2)
						nIRFBase  	:= Round(NoRound(SE1->E1_BASEIRF * nPropPCC,3),2)
					EndIf
				Endif
				
				aAreaSE := GetArea()
				DbSelectArea("SFQ")
				SFQ->(dbSetOrder(1))
				For ni := 1 to Len(aTitulos)
					cChave := aTitulos[ni,1]+aTitulos[ni,2]+aTitulos[ni,3]+aTitulos[ni,4] // prefixo+numero+parcela+tipo
					If SFQ->(DbSeek(xFilial("SFQ")+'E1B'+cChave))
						While !SFQ->(Eof()) .and. FQ_PREFORI+FQ_NUMORI+FQ_PARCORI+FQ_TIPOORI == cChave
							nPis	:= nPis + SFQ->FQ_SABTPIS
							nCofins	:= nCofins + SFQ->FQ_SABTCOF
							nCsll	:= nCsll + SFQ->FQ_SABTCSL
							SFQ->(DbSkip())
						EndDo
					EndIf
				Next ni
				
				RestArea(aAreaSE)
				aImpPcc[1] -= nPis
				aImpPcc[2] -= nCofins
				aImpPcc[3] -= nCsll			
			Endif
	    
		EndIf
   	
   	EndIf
   	   	
   	E1_STATUS := IIF(E1_STATUS != "R",Iif(E1_SALDO >= 0.01,"A","B"),"R")
	
EndIf

cSaldoAux := Str( nSaldo, 16, 2 ) 
If ( cSaldoAux = Str(nTotAbat,16,2) .Or. cSaldoAux = Str(nPis+nCofins+nCsll+nTotAbat,16,2) .And. mv_par08 == 1 .And. ( ( (!lRaRtImp .And. !lRaRtImpMR) .And. !lCredito ) .Or. (lRaRtImp .Or. lRaRtImpMR) ) ) .Or.;
( cSaldoAux = Str(SE1->(E1_PIS+E1_COFINS+E1_CSLL),16,2) .And. mv_par08 == 2 .And. (lRaRtImp .Or. lRaRtImpMR) )
	Replace E1_SALDO  With 0 
	Replace E1_STATUS With Iif( E1_STATUS != "R", "B", "R" )
EndIf
SE1->(MsUnlock())

//atualiza status do adiantamento de viagem
If SE1->E1_SALDO==0 .AND. (ALLTRIM(SE1->E1_ORIGEM) == "FINA677")
	FINATURES(SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA),.T.,SE1->E1_ORIGEM,"R")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava um registro para cada Movimentao Banc ria 			  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

SE1->(dbGoTo(nSalvRec))
If !lCredito
	nSaldoVa:= FValAcess(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_CLIENTE,SE1->E1_LOJA, SE1->E1_NATUREZ,!Empty(SE1->E1_BAIXA),,"R",SE1->E1_BAIXA,,SE1->E1_MOEDA)	
EndIf
FA330Mov(lPadrao,nValor,cAdiantamento,cSeq,nRegCmp,@abaixas,cOrigem,lCredito,nContab,@nAcresc,@nDecres,nTitAcres,nTitDecre,aBaixaSE5,nTotAbto,@cSequencia, lNcc, nValLim,@nRegSe5Ori,nSaldoVa)
SE1->(dbGoTo(nSalvRec))

If SE1->E1_TIPO $ MVRECANT .AND. lFina330
	lCompRa	:=	.T.
EndIf

If ! ( SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG ) .OR. (lCompRa .AND. SE1->E1_TIPO $ MVRECANT)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Baixar titulos de abatimento se for baixa total					³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SE1")
	If E1_SALDO = 0 .or. lPropBx
		If lPropBx .and. !lCredito
			If (E1_SALDO == 0 .AND. MV_PAR08 == 1) .Or. ( lRartImp .Or. lRaRtImpMR )
				nImp	:= SE1->E1_PIS + SE1->E1_COFINS + SE1->E1_CSLL + SE1->E1_IRRF + SE1->E1_INSS + SE1->E1_ISS
				nVal	:= (SE1->E1_VALOR * nValor)/(SE1->E1_VALOR - nImp)
			Else
				nVal	:= nValor
			EndIf
			aImp	:= FpropCR(SE1->E1_VALOR, SE1->E1_PIS, SE1->E1_COFINS, SE1->E1_CSLL, SE1->E1_IRRF, SE1->E1_INSS, SE1->E1_ISS, nVal)
		EndIf
		cTipo := If( lCompRA .And. lCredito, cTipoAux, SE1->E1_TIPO )
		SE1->(dbSetOrder(2))
		SE1->(dbSeek(xFilSE1+cCliente+cLoja+cPrefixo+cNum+cParcela))
		If lTitpaiSE1
	 		If (nOrdTitPai:= OrdTitpai()) > 0
				SE1->(DbSetOrder(nOrdTitPai))
				If	DbSeek(xFilSE1+cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja)
					bWhile := {|| !Eof() .And. E1_FILIAL + Trim(E1_TITPAI) == xFilSE1+Trim(cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja) }
				Else
					SE1->(dbSetOrder(2))
					SE1->(dbSeek(xFilial("SE1")+cCliente+cLoja+cPrefixo+cNum+cParcela))
				Endif
			Endif
		Endif
				
		While Eval(bWhile)
			If lTitpaiSE1
				If !Empty(SE1->E1_TITPAI) .and. (Alltrim(SE1->E1_TITPAI) != Alltrim(cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja) )
					SE1->(DbSkip())
					Loop
				EndIf
			EndIf

			IF If(lCompRa,E1_TIPO,SE1->E1_TIPO) $ If(lPccBxCr,"CSL/FB-/"+MVCOFINS+"/"+MVPIS+"/"+MVABATIM+"/"+MVIRABT+"/"+MVINABT,;
				(MVABATIM+"/"+MVIRABT+"/"+MVINABT+"/"+MVPIABT+"/"+MVCFABT+"/"+MVCSABT))

				RecLock("SE1")
				If !lPropBx
					Replace E1_SALDO 	With 0
				Else
					Do Case
						Case E1_TIPO $ MVPIABT .and. !lPccBxCr
							Replace E1_SALDO	With (E1_SALDO - aImp[1][1])
						Case E1_TIPO $ MVCFABT .and. !lPccBxCr
							Replace E1_SALDO	With (E1_SALDO - aImp[1][2])
						Case E1_TIPO $ MVCSABT .and. !lPccBxCr
							Replace E1_SALDO	With (E1_SALDO - aImp[1][3])
						Case E1_TIPO $ MVIRABT .and. !lIrPjBxCr
							Replace E1_SALDO	With (E1_SALDO - aImp[1][4]) 
						Case E1_TIPO $ MVINABT 				
							Replace E1_SALDO	With (E1_SALDO - aImp[1][5])
						Case E1_TIPO $ MVISABT   				
							Replace E1_SALDO	With (E1_SALDO - aImp[1][6])	
					EndCase
				EndIf
				
				Replace E1_BAIXA 	With If(E1_BAIXA <= dBaixa, dBaixa, E1_BAIXA)
				Replace E1_LOTE		With cLote
				Replace E1_MOVIMEN	With dBaixa
				Replace E1_PORTADO	With cBanco
				Replace E1_STATUS   With IIF(E1_STATUS != "R",Iif(E1_SALDO >= 0.01,"A","B"),"R")

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Gravar o titulo que baixou o AB- para evitar estornos de ³
				//³abatimentos baixados por outras rotinas. Evita que um AB-³
				//³baixado pelo FINA070 / 110 seja estornado indevidamente  ³
				//³pelo FINA330, que gera erro na composicao do saldo do    ³
				//³titulo principal com abatimento.                         ³
				//³Gravar SEMPRE NCC/RA para identificar a baixa do AB-     ³
				//³pela rotina FINA330										³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !Empty(cDadostitulo)
					If Empty(E1_TITPAI)
						Replace E1_TITPAI	With cDadosTitulo
					EndIf
				Else
					Replace E1_TITPAI	With ""
				Endif
				SE1->(MsUnlock())
			EndIf
			SE1->(dbSkip())
		EndDo
		SE1->(DbSetOrder(1))
	EndIf
	SE1->(dbGoto( nSalvRec ))
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona no registro de natureza 	 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SED")
	SED->(dbSeek(xFilial("SED")+SE1->E1_NATUREZ))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza campo de maior atrazo no Cadastro de Clientes     		  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SA1")
	SA1->(DbSetOrder(1))
	SA1->(dbSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA))
	RecLock("SA1")
	nAtraso := dBaixa-SE1->E1_VENCTO
	If nAtraso > 1
		IF Dow(SE1->E1_VENCTO) == 1 .Or. Dow(SE1->E1_VENCTO) == 7
			IF Dow(dBaixa) == 2 .and. nAtraso <= 2
				nAtraso := 0
			EndIF
		EndIF
		nAtraso:=IIF(nAtraso<0,0,nAtraso)
		If SA1->A1_MATR < nAtraso
			Replace A1_MATR With nAtraso
		EndIf
	EndIf
	SA1->(MsUnlock())
ElseIf cPaisLoc == "BRA"
	//Baixar titulos de abatimento se for baixa total do(s) título(s) selecionado(s) no array aTitulos
	dbSelectArea("SE1")
	If Funname() == "FINA330" .Or. Funname() == "FINA740"
		If MV_PAR02 == 1
			nPosRec := 20
		Else
			nPosRec := 23
		EndIf	 
	EndIf	
	For nX := 1 To Len(aTitulos)
		DbSelectArea("SE1")
		SE1->(DbGoTo(aTitulos[nX][nPosRec]))		
		xFilSE1		:= SE1->E1_FILIAL
		cNumero		:= SE1->E1_NUM
		cPrefixo 	:= SE1->E1_PREFIXO
		cParcela 	:= SE1->E1_PARCELA
		cCliente 	:= SE1->E1_CLIENTE
		cLoja	 	:= SE1->E1_LOJA
				
		If (SE1->E1_SALDO - aTitulos[nX][09]) == 0 //Baixa total	
			cTipo:= If( lCompRA .And. lCredito, cTipoAux, SE1->E1_TIPO )
			dbSetOrder(2)
			dbSeek(xFilSE1+cCliente+cLoja+cPrefixo+cNumero+cParcela) 
			If lTitpaiSE1 
		 		If FindFunction("OrdTitpai") .and. (nOrdTitPai:= OrdTitpai()) > 0
					DbSetOrder(nOrdTitPai)
					If	DbSeek(xFilSE1+cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja)
						bWhile := {|| !Eof() .And. E1_FILIAL + Trim(E1_TITPAI) == xFilSE1+Trim(cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja) }
					Else
						dbSetOrder(2)		
						dbSeek(xFilial("SE1")+cCliente+cLoja+cPrefixo+cNumero+cParcela)
					Endif
				Endif
			Endif
			
			While Eval(bWhile)                         
				If lTitpaiSE1
					If !Empty(E1_TITPAI) .and. (Alltrim(E1_TITPAI)!=Alltrim(cPrefixo+cNumero+cParcela+cTipo+cCliente+cLoja) )
						DbSkip()
						Loop
					EndIf
				EndIf        
				
				IF If(lCompRa,E1_TIPO,SE1->E1_TIPO) $ If(lPccBxCr,"CSL/FB-/"+MVCOFINS+"/"+MVPIS+"/"+MVABATIM+"/"+MVIRABT+"/"+MVINABT,;
					(MVABATIM+"/"+MVIRABT+"/"+MVINABT+"/"+MVPIABT+"/"+MVCFABT+"/"+MVCSABT))								
	
					RecLock("SE1")
					Replace E1_SALDO 	With 0
					Replace E1_BAIXA 	With If(E1_BAIXA <= dBaixa, dBaixa, E1_BAIXA)
					Replace E1_LOTE		With cLote
					Replace E1_MOVIMEN	With dBaixa
					Replace E1_PORTADO	With cBanco
					Replace E1_STATUS   With IIF(E1_STATUS != "R",Iif(E1_SALDO >= 0.01,"A","B"),"R")
				
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Gravar o titulo que baixou o AB- para evitar estornos de ³
					//³abatimentos baixados por outras rotinas. Evita que um AB-³
					//³baixado pelo FINA070 / 110 seja estornado indevidamente  ³
					//³pelo FINA330, que gera erro na composicao do saldo do    ³
					//³titulo principal com abatimento.                         ³
					//³Gravar SEMPRE NCC/RA para identificar a baixa do AB-     ³
					//³pela rotina FINA330										³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If SE1->(FieldPos("E1_TITPAI")) # 0
						If !Empty(cDadostitulo)
							If Empty(E1_TITPAI)
								Replace E1_TITPAI	With cDadosTitulo 
							EndIf
						Else
							Replace E1_TITPAI	With ""
						Endif
					Endif
					MsUnlock()
	
				EndIf
				dbSelectArea( "SE1" )
				dbSkip( )
			EndDo
			DbSetOrder(1)
		Else
			Loop
		EndIf
		dbGoto( nSalvRec )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona no registro de natureza 	 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SED")
		dbSeek(xFilial("SED")+SE1->E1_NATUREZ)
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza campo de maior atrazo no Cadastro de Clientes     		  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SA1")
		DbSetOrder(1)
		dbSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA)
		RecLock("SA1")
		nAtraso:=dBaixa-SE1->E1_VENCTO
		If nAtraso > 1
			If Dow(SE1->E1_VENCTO) == 1 .Or. Dow(SE1->E1_VENCTO) == 7
				If Dow(dBaixa) == 2 .and. nAtraso <= 2
					nAtraso := 0
				EndIf
			EndIf
			nAtraso:=IIF(nAtraso<0,0,nAtraso)
			If SA1->A1_MATR < nAtraso
				Replace A1_MATR With nAtraso
			EndIf
		EndIf
		MsUnlock()
	Next nX
	SE1->(dbGoto(nSalvRec))	
EndIf
dbSelectArea("SE1")
SE1->(dbSetOrder(1))

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³ FA330Mov ³ Autor ³ Valter G. Nogueira Jr.³ Data ³ 21/03/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Grava registros referentes a compensacao de titulos		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FA330Mov(ExpC1,ExpN2)                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function FA330Mov(lPadrao,nValor,cAdiantamento,cSeq,nRegCmp,aBaixas,cOrigem,lCredito,nContab,nAcresc,nDecres,;
							nTitAcres,nTitDecre,aBaixaSE5,nTotAbto,cSequencia, lNcc, nValLim, nRegSe5Ori,nSaldoVa)

	Local nTamSeq		As Numeric
	Local cAlias		As Character
	LOCAL cDocOriginal	As Character
	LOCAL nRecSe1		As Numeric
	LOCAL nValorReal	As Numeric
	Local cSeqPrc 		As Character
	Local cSeqAdt 		As Character
	LOCAL nDecs1		As Numeric
	LOCAL aArea			As Array
	LOCAL cFilOrig		As Character
	LOCAL cCliOri		As Character
	LOCAL cLojaOri		As Character
	LOCAL cCliAdt		As Character
	LOCAL cLojaAdt		As Character
	Local lImpComp		As Logical
	Local lIsNcc		As Logical
	Local nValPis		As Numeric
	Local nValCof		As Numeric
	Local nValCSL		As Numeric
	local nRecImp		As Numeric
	//Compensacao de contas a receber, nao necessita verificar o parametro MV_BX10925
	Local lPCCBaixa		As Logical
	//Controla o Pis Cofins e Csll na baixa (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default))
	Local lPccBxCr		As Logical
	Local lRaRtImp		As Logical
	//Controla IRPJ na baixa
	Local lIrPjBxCr		As Logical
	Local lMultFil  	As Logical // CRIADO PARA MANIPULAR A FILIAL NO MOVIMENTO BANCARIO
	Local aAreaSE5		As Array
	Local nVlReal		As Numeric

	//Impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
	Local nPisFin061	As Numeric
	Local nCofFin061	As Numeric
	Local nCslFin061	As Numeric
	Local nIrfFin061	As Numeric
	Local nRegSE5		As Numeric
	Local nOrdSE5		As Numeric
	Local oModelBxR		As Object
	Local oSubFK1		As Object
	Local oSubFK6		As Object
	Local cLog 			As Character
	Local cChaveFK7		As Character
	Local cChvFK7out	As Character
	Local cCamposE5		As Character
	Local lRet 			As Logical
	Local oSubFKA		As Object
	Local cChaveTit		As Character
	Local cFilSE5		As Character
	Local cIdFK1		As Character
	Local cTpDoc		As Character
	Local nDecValFK6 	As Numeric //Quantidade de decimais do campo FK6_VALMOV
	Local lIrfBxAux 	As Logical
	Local lPccBxAux 	As Logical
	Local aImpMRBrw 	As Array //Guarda os dados de imposto do motor para o título posicionado na browse
	Local aImpMRSel 	As Array //Vetor que irá guardar os impostos calculado para o título selecionado na markbrowse  
	Local aAuxImpGrv 	As Array
	Local nJ 			As Numeric
	Local nBaseImpMR 	As Numeric
	Local nImpMR		As Numeric
	Local nVlrEstr      As Numeric
	Local nVlrNF        As Numeric
	Local nCM           As Numeric
	Local lTxC          As Logical
	Local nMoedTiBrw    As Numeric
	Local aAreaFK1		As Array
	Local nRecFK1		As Numeric
	Local cFilOld		As Character
	Local cIdDoc		As Character
	Local nCntFK6		As Numeric
	Local lIdFkd		As Logical
	Local nTxCompP		As Numeric
	Local nValImp		As Numeric
	Local lFina330  	As Logical
	Local nMVToler		As Numeric
	Local nDiff			As Numeric
	Local lDescToler	As Logical
	//////

	nTamSeq		:= __nTamSeq
	cAlias		:= Alias()
	cDocOriginal	:= SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO+SE1->E1_LOJA
	nRecSe1		:= SE1->(RecNo())
	nValorReal	:= 0
	cSeqPrc 	:= Replicate("0",nTamSeq)
	cSeqAdt 	:= Replicate("0",nTamSeq)
	nDecs1		:= MsDecimais(1)
	aArea		:= {}
	cFilOrig	:= ''
	cCliOri		:= ''
	cLojaOri	:= ''
	cCliAdt		:= ''
	cLojaAdt	:= ''
	lImpComp	:= SuperGetMv("MV_IMPCMP",,"2") == "1"
	lIsNcc		:= .F.
	nValPis		:= 0
	nValCof		:= 0
	nValCSL		:= 0
	nRecImp		:= 0
	//Compensacao de contas a receber, nao necessita verificar o parametro MV_BX10925
	lPCCBaixa	:= (cPaisLoc == "BRA")
	//Controla o Pis Cofins e Csll na baixa (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default))
	lPccBxCr	:= FPccBxCr()
	lRaRtImp	:= FRaRtImp()
	//Controla IRPJ na baixa
	lIrPjBxCr		:= FIrPjBxCr() 
	lMultFil  	:= ExistBlock("SE5MTFIL") // CRIADO PARA MANIPULAR A FILIAL NO MOVIMENTO BANCARIO
	aAreaSE5	:= {}
	nVlReal		:= 0

	//Impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
	nPisFin061	:=	0
	nCofFin061	:=	0
	nCslFin061	:=	0
	nIrfFin061	:=	0
	nRegSE5		:=	0
	nOrdSE5		:=	0
	oModelBxR	:= Nil
	oSubFK1		:= Nil
	oSubFK6		:= Nil
	cLog 		:= ""
	cChaveFK7	:= ""
	cChvFK7out	:= ""
	cCamposE5	:= ""
	lRet 		:= .T.
	oSubFKA		:= Nil
	cChaveTit	:= SE1->E1_FILIAL + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
	cFilSE5		:= FWxFilial('SE5')
	cIdFK1		:= ''
	cTpDoc		:= ''
	nDecValFK6 	:= __nTamValM //Quantidade de decimais do campo FK6_VALMOV
	lIrfBxAux 	:= lIrPjBxCr
	lPccBxAux 	:= lPccBxCr
	aImpMRBrw 	:= PegaVarMR() //Guarda os dados de imposto do motor para o título posicionado na browse
	aImpMRSel 	:= {} //Vetor que irá guardar os impostos calculado para o título selecionado na markbrowse  
	aAuxImpGrv 	:= {}
	nJ 			:= 0
	nBaseImpMR 	:= 0
	nImpMR		:= 0
	nVlrEstr 	:= 0
	nVlrNF      := 0
	nCM         := 0
	lTxC        := If(cPaisLoc == "BRA", !Empty(SE1->E1_TXMOEDA), .F.)
	nMoedTiBrw  := 0
	aAreaFK1	:= {}
	nRecFK1		:= 0
	cFilOld		:= ""
	cIdDoc		:= ""
	nCntFK6		:= 0
	lIdFkd		:= .F.
	nTxCompP	:= 0
	nValImp		:= 0
	lFina330  	:= IsInCallStack("FINA330") .OR. IsInCallStack("FINA740")
	nMVToler	:= SuperGetMv("MV_TOLERPG",,0.01)
	nDiff		:= 0
	lDescToler	:= .F.

	DEFAULT lCredito	:= .F.
	DEFAULT nContab		:= 1
	DEFAULT nAcresc		:= 0
	DEFAULT nDecres		:= 0
	DEFAULT aBaixaSE5	:= {}
	DEFAULT nTotAbto	:= 0
	DEFAULT cSequencia	:= Replicate("0",nTamSeq)
	DEFAULT lNcc		:= .F.
	Default nValLim 	:= 0
	Default __nPosTit   := 0
	Default nRegSe5Ori	:= 0 
	Default nSaldoVA	:= 0

	PRIVATE cMotBx		:= "CMP"
	PRIVATE l330Mov1	:= ExistBlock("SE5FI330")
	PRIVATE l330Mov2	:= ExistBlock("SE5FI331")

	If __lBq10925 == Nil
		__lBq10925 := SuperGetMV("MV_BQ10925",,"2") == "1"
	Endif

	//Posiciono no titulo de adiantamento
	dbSelectArea("SE1")
	SE1->(dbSetOrder(1))
	SE1->(dbGoTo(nRegCmp))
	cFilOrig	 	:= SE1->E1_FILORIG
	cCliAdt			:= SE1->E1_CLIENTE
	cLojaAdt		:= SE1->E1_LOJA
	nMoedTiBrw 		:= SE1->E1_MOEDA

	//Vld se ambos os títulos possuem taxa contratada 
	If __nPosTit > 0 .And. cPaisLoc == "BRA" .And. Len(aTitulos) > 0
		__nTxTiBrw := aTitulos[__nPosTit, Len(aTitulos[__nPosTit])]
		lTxC       := (lTxC .And. !Empty(SE1->E1_TXMOEDA))
	Else
		__nTxTiBrw := Fa330Tx2(nMoeda,nTxMoeda)
	EndIf
	// Taxa a ser considerada para o título de partida
	If nMoeda > 1
		If !Empty(SE1->E1_TXMOEDA) .And. __lCmTxCon 
			nTxCompP := __nTxMoedD
		Else
			nTxCompP := __nTxMoedP
		EndIf
	Else // Se o título de partida for moeda 1, a taxa é a do movimento
		nTxCompP := __nTxMoedD
	EndIf

	if lCredito	
		nDescD := getDesc(nValor)
	endIf

	If !lCredito
		lIsNcc := SE1->E1_TIPO $ MV_CRNEG   //Verifico se o titulo de adiantamento é um NCC
	EndIf

	If cPaisLoc <> "BRA" .And. Type("aTxMoedas")#"U" .And. FunName() <> "FINA330"
		If __lDizPer
			nValorReal := Round(xMoeda(nValor,nMoeda,1,dDatabase,nDecs1+1,aTxMoedas[nMoeda][2],nDecs1), nDecs1 )
		Else
			nValorReal := xMoeda(nValor,nMoeda,1,dDatabase,nDecs1+1,aTxMoedas[nMoeda][2],nDecs1)
		EndIf
	ElseIf nMoeda <> 1
		If __lDizPer
			nValorReal := Round(xMoeda(nValor,nMoeda,1,dDatabase,nDecs1+1,nTxCompP), nDecs1 )
		Else
			nValorReal := xMoeda(nValor,nMoeda,1,dDatabase,nDecs1+1,nTxCompP)
		EndIf
	Else
		nValorReal := nValor
	EndIf

	If lCredito
		cFilOld	:= cFilAnt
		cFilAnt	:= cFilOrig
	EndIf

	cSeqAdt := FaNxtSeqBx("SE1",.T.)

	If lVldSEQ
		Return .F.
	EndIf

	If lCredito
		cFilAnt	:= cFilOld
	EndIf

	SE1->(dbGoTo(nRecSe1))
	cSeqPrc	:= FaNxtSeqBx("SE1",.T.)

	If lVldSEQ
		Return .F.
	EndIf

	cCliOri	:= SE1->E1_CLIENTE
	cLojaOri := SE1->E1_LOJA

	//Motor de retenções
	If __lMotRet .And. lCredito
		//Verifica as configurações de impostos pelo motor de retenção
		__lTCnfgMR := F330VldImp()
		
		lPccBxCr := ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
		lIrPjBxCr := ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )
		
		//Se for a baixa total do saldo do título e houver imposto, então passa o valor do saldo como base de cálculo para o motor
		If nValorReal + SE1->E1_SALDO == SE1->E1_VALOR
			nBaseImpMR := SE1->E1_VALOR
		ElseIf !lIrPjBxCr //Se for baixa parcial, então passa o valor da baixa
			nBaseImpMR := nValorReal + nTotAbto
		Else
			nBaseImpMR := Iif( SE1->E1_VALOR <> ( nValorReal + nTotAbto ), nValorReal, SE1->E1_VALOR )
		EndIf
		
		If !__lImpEmis
			nImpMR	:= __nImpMR
		EndIf
		
		//Calcula os impostos pelo motor de retenções
		If __lTCnfgMR
			F330CalImp( SE1->E1_NATUREZ, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG, nBaseImpMR, dDataBase, SE1->E1_TIPO )
			__lTCnfgMR	:= .F.
		EndIf
	EndIf

	If lCredito
		lIsNcc := SE1->E1_TIPO $ MV_CRNEG   //Verifico se o titulo de adiantamento é um NCC
	Endif

	cSequencia := IIf(cSeqAdt > cSeqPrc,cSeqAdt,cSeqPrc)

	dbSelectArea("SE5")
	SE5->(dbSetOrder(1))

	If nValor != 0
		If nMoeda == 1
			nValorReal := nValor
			If !__lBq10925  .AND. (!lRaRtImp .or. (lRaRtImp .and. __nMarcs == 1))
				nValorReal := nValor - nPis - nCofins - nCsll - IiF(lIrPjBxCr,nIrrf,0)
			Endif
			nVlrEstr   := xMoeda(nValorReal, nMoeda, nMoedTiBrw, dDataBase, __nCasDec, 0, IIf(cPaisLoc == "BRA", __nTxTiBrw, __nTxMoedP))
		Else
			nVlrEstr   := nValor
			If !__lBq10925  .AND. (!lRaRtImp .or. (lRaRtImp .and. __nMarcs == 1))
				nValImp := xMoeda((nPis+nCofins+nCsll+IiF(lIrPjBxCr,nIrrf,0)), 1, nMoeda, Ddatabase, __nCasDec, 0, __nTxMoedP)
				nVlrEstr := nValor - nValImp
			Endif
			nValorReal := xMoeda(nVlrEstr, nMoeda, 1, dDataBase, __nCasDec, nTxCompP)
		EndIf
		
		If cPaisLoc == "BRA" .And. __lCmTxCon .And. lTxC
			If !SE1->E1_TIPO $ MVRECANT+"|"+MV_CRNEG
				nVlrNF := Round(nValorReal,__nCasDec)
			Else
				SE1->(dbGoTo(nRegCmp))
				nVlrNF := Round(xMoeda(nValor, If(nMoedTiBrw != 1, nMoedTiBrw, nMoeda), 1, SE1->E1_EMISSAO, __nCasDec, __nTxTiBrw),__nCasDec)
				SE1->(dbGoTo(nRecSe1))
			EndIf
		EndIf
		
		oModelBxR := FWLoadModel("FINM010") 
		oModelBxR:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
		oModelBxR:Activate()		
		lIdFkd := oModelBxR:GetModel("FK6DETAIL"):HasField("FK6_IDFKD")
		oModelBxR:SetValue("MASTER", "E5_GRV", .T. )
		oModelBxR:SetValue("MASTER", "NOVOPROC", .T. ) 
		
		cCamposE5:="{"
		cCamposE5 += "{'E5_FILIAL'		,'" + cFilSE5 			+ "'}"
		cCamposE5 += ",{'E5_PREFIXO'	,'" +  SE1->E1_PREFIXO	+ "'}"
		cCamposE5 += ",{'E5_NUMERO'		,'" +  SE1->E1_NUM		+ "'}"
		cCamposE5 += ",{'E5_PARCELA'	,'" +  SE1->E1_PARCELA	+ "'}"
		cCamposE5 += ",{'E5_CLIENTE'	,'" +  SE1->E1_CLIENTE	+ "'}"
		cCamposE5 += ",{'E5_CLIFOR'		,'" +  SE1->E1_CLIENTE	+ "'}"
		cCamposE5 += ",{'E5_LOJA'		,'" +  SE1->E1_LOJA		+ "'}"
		cCamposE5 += ",{'E5_BENEF'		,'" + StrTran(SE1->E1_NOMCLI,"'","")+ "'}"
		cCamposE5 += ",{'E5_TIPO'		,'" +  SE1->E1_TIPO		+ "'}"
		cCamposE5 += ",{'E5_DTDIGIT'	, STOD('" + DTOS(dDataBase) + "')}"
		cCamposE5 += ",{'E5_DTDISPO'	, STOD('" + DTOS(dBaixa) + "')}"
		cCamposE5 += ",{'E5_SITCOB'		,'" + SE1->E1_SITUACA + "' }"
		cCamposE5 += ",{'E5_LA'			,'" +  IIF(lPadrao .and. nContab == 1,"S","N") + "'}"

		If ! lMultFil
			cCamposE5 += ",{'E5_FILIAL'		,'" + xFilial("SE5") + "' } "
		Else
			cCamposE5 += ",{'E5_FILIAL'		,'" + ExecBlock("SE5MTFIL",.F.,.F.,cFilAnt) + "' } "
		EndIf

		cChaveFK7	:= FINGRVFK7("SE1", cChaveTit, SE1->E1_FILORIG)
		cChvFK7out	:= cChaveFK7
		cIdFK1		:= FWUUIDV4()
		oSubFK1 := oModelBxR:GetModel( "FK1DETAIL" )
		oSubFKA := oModelBxR:GetModel( "FKADETAIL" )
		oSubFK6 := oModelBxR:GetModel( "FK6DETAIL" )

		If !oSubFKA:IsEmpty()
			oSubFKA:AddLine()
		EndIf
		
		oSubFKA:SetValue( "FKA_IDORIG"	, cIdFK1 )
		oSubFKA:SetValue( "FKA_TABORI"	, 'FK1')
		
		If !oSubFK1:IsEmpty()
			oSubFK1:AddLine()
		EndIf

		oSubFK1:SetValue( "FK1_DATA"	, dBaixa )		
		oSubFK1:SetValue( "FK1_NATURE"	, SE1->E1_NATUREZ )
		oSubFK1:SetValue( "FK1_RECPAG"	, "R" )
		oSubFK1:SetValue( "FK1_MOTBX"	, "CMP")
		oSubFK1:SetValue( "FK1_ORIGEM"	, FunName() )
		oSubFK1:SetValue( "FK1_SEQ"		, cSequencia )
		oSubFK1:SetValue( "FK1_DOC"		, SE1->E1_NUMBOR )
		oSubFK1:SetValue( "FK1_IDDOC"	, cChaveFK7 )
		oSubFK1:SetValue( "FK1_TPDOC"	, cTpDoc )	
		oSubFK1:SetValue( "FK1_CCUSTO"	, SE1->E1_CCUSTO )	
		oSubFK1:SetValue( "FK1_FILORI"	, SE1->E1_FILORIG )
		oSubFK1:SetValue( "FK1_VALOR"	, If(SE1->E1_MOEDA == 1, Round(nValorReal, 2), Round(nVlrEstr, 2)))
		oSubFK1:SetValue( "FK1_VLMOE2"	, If(SE1->E1_MOEDA == 1, Round(nVlrEstr, 2), Round(nValorReal, 2)))
		oSubFK1:SetValue( "FK1_SITCOB"	, SE1->E1_SITUACA )
		oSubFK1:SetValue( "FK1_MOEDA"	,  StrZero(SE1->E1_MOEDA, 2))
		oSubFK1:SetValue( "FK1_LOTE"	, cLote )
		oSubFK1:SetValue( "FK1_DOC"		, cAdiantamento )
		oSubFK1:SetValue( "FK1_LA"		, IIF(lPadrao .and. nContab == 1,"S","N") )
		
		If nTitAcres <> 0
			If !oSubFK6:IsEmpty()
				oSubFK6:AddLine()
			EndIf
			
			nTitAcres 	:= Round(xMoeda(nTitAcres, nMoeda, 1, Nil, __nCasDec, nTxCompP), 2)

			oSubFK6:SetValue( 'FK6_GRVSE5'  , .F. )		
			oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
			oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
			oSubFK6:SetValue( 'FK6_TPDOC'	, 'JR' )
			oSubFK6:SetValue( 'FK6_VALCAL'	, nTitAcres )	
			oSubFK6:SetValue( 'FK6_VALMOV'	, nTitAcres )
			oSubFK6:SetValue( 'FK6_RECPAG'	, "R" )
			oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
			oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0049) ) //ACRESCIMO
			
			cCamposE5 += ",{'E5_VLACRES'," + Str(nTitAcres) + " }"
			cCamposE5 += ",{'E5_VLJUROS'," + Str(nTitAcres) + " }"
		EndIf
		
		If nTitDecre+nDescP <> 0
			If !oSubFK6:IsEmpty()
				oSubFK6:AddLine()
			EndIf
			
			nTitDecre		:= Round(xMoeda(nTitDecre+nDescP, nMoeda, 1, Nil, __nCasDec, nTxCompP), 2)

			oSubFK6:SetValue( 'FK6_GRVSE5'  , __cToler == "D" )		
			oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
			oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
			oSubFK6:SetValue( 'FK6_TPDOC'	, 'DC' )
			oSubFK6:SetValue( 'FK6_VALCAL'	, nTitDecre )	
			oSubFK6:SetValue( 'FK6_VALMOV'	, nTitDecre )
			oSubFK6:SetValue( 'FK6_RECPAG'	, "R" )
			oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
			oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0050) ) //DECRESCIMO
			oSubFK6:SetValue( 'FK6_TPDESC'	, Iif(SE1->E1_TPDESC == 'C', '1', '2') )
			
			cCamposE5 += ",{'E5_VLDESCO'," + Str(nTitDecre) + " }"
			cCamposE5 += ",{'E5_VLDECRE'," + Str(nTitDecre) + " }"
		EndIf
		//VA: Adiciona os valores da FKD ao model
		If __l330Va .And. (lCredito .Or. (!lCredito .And. nSaldoVA <> 0 ))
			cIdDoc := oSubFK1:GetValue("FK1_IDDOC")
			FSetFK6FKD( oSubFK6, cIdDoc, cIdFK1, "R" )
		EndIf

		If nMoeda > 1 .Or. cPaisLoc != "BRA"
			nCM := FA330Corr(nVlrEstr, nVlrNF, "SE1", nTxCompP)		
		EndIf
		
		nTxMoed1 := nTxMoed2 := nValEmis := nValBax := nValCm := 0
		nValCorCM += nCM

		// Grava o valor de correção monetária no SE5 para ser visualizado na consulta
		If cPaisLoc == "MEX" .And. SE5->E5_MOEDA <> "1" .And. FunName() == "FINA330"
			nTxCor		:= Iif(SE1->E1_TXMOEDA > 0, SE1->E1_TXMOEDA, RecMoeda(SE1->E1_EMISSAO, SE1->E1_MOEDA))
			nValOrig	:= Round(xMoeda(nValorReal,nMoeda,1,,,nTxCor),2)
			nValAtu	:= Round(xMoeda(nValorReal,nMoeda,1,,,aTxMoedas[nMoeda][2]),2)
			
			If nValAtu - nValOrig <> 0
				If !oSubFK6:IsEmpty()
					oSubFK6:AddLine()
				EndIf	
				oSubFK6:SetValue( 'FK6_GRVSE5'  , .F.)			
				oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
				oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
				oSubFK6:SetValue( 'FK6_TPDOC'	, 'CM' )
				oSubFK6:SetValue( 'FK6_VALCAL'	, nValAtu - nValOrig )	
				oSubFK6:SetValue( 'FK6_VALMOV'	, nValAtu - nValOrig )
				oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
				oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
				
				If SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG
					oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0075) ) //CORREC.DE ADIANTAMENTO
				Else
					oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0076) ) //"Correcao Monet s/Receb.Titulo" 
				EndIf
				cCamposE5 += ",{'E5_VLCORRE'," + Str(nValAtu - nValOrig )+ " }"
			EndIf
		Else
			If cPaisLoc == "BRA" .And. SE1->E1_MOEDA > 1 .And. nValCm != 0 .And. (lFina330 .OR. __lCmpM460)
				If !oSubFK6:IsEmpty()
					oSubFK6:AddLine()
				EndIf
				
				oSubFK6:SetValue( 'FK6_GRVSE5'  , .F.)		
				oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
				oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
				oSubFK6:SetValue( 'FK6_TPDOC'	, 'CM' )
				oSubFK6:SetValue( 'FK6_VALCAL'	, Round(nValCm, 2))	
				oSubFK6:SetValue( 'FK6_VALMOV'	, Round(nValCm, 2))
				oSubFK6:SetValue( 'FK6_RECPAG'	, "R" )
				oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
				
				If SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG
					oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0075) ) //CORREC.DE ADIANTAMENTO
				Else
					oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0076) ) //CORREC. MONET S/ RECEBTO
				EndIf
				cCamposE5 += ",{'E5_VLCORRE'," + Str(Round(nValCm, 2)) + " }"

			ElseIf Round( nCm, nDecValFK6 ) <> 0
				If !oSubFK6:IsEmpty()
					oSubFK6:AddLine()
				EndIf
				
				oSubFK6:SetValue( 'FK6_GRVSE5'  , .T.)		
				oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
				oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
				oSubFK6:SetValue( 'FK6_TPDOC'	, 'CM' )
				oSubFK6:SetValue( 'FK6_VALCAL'	, nCm)	
				oSubFK6:SetValue( 'FK6_VALMOV'	, nCm)
				oSubFK6:SetValue( 'FK6_RECPAG'	, "R" )
				oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
				
				If SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG
					oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0075) ) //CORREC.DE ADIANTAMENTO
				Else
					oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0076) ) //CORREC. MONET S/ RECEBTO
				EndIf
				
				cCamposE5 += ",{'E5_VLCORRE'," + Str(nCm) + " }"
			Endif
		EndIf

		If lCredito
			oSubFK1:SetValue( "FK1_HISTOR"	, OemToAnsi(STR0077)) //"Baixa por Compensação"
			oSubFK1:SetValue( "FK1_TPDOC"	, "BA" )
		Else
			oSubFK1:SetValue( "FK1_HISTOR"	, OemToAnsi(If(lIsNcc,STR0078,STR0036)) ) //"Compensação Nota de Crédito" //"Compensaçäo de Adiantamentos"
			oSubFK1:SetValue( "FK1_TPDOC"	, "CP" )
		EndIf

		If !lPccBxCr
			//Acerto valor dos impostos - Tecnofibras
			If lImpComp .and. lIsNcc .and. lPccBaixa
				nRecImp := IIF(lCredito,nRegCmp,nRecSE1)
				F330ActImp(nRecImp,nValorReal,@nValPis,@nValCof,.T.,lCredito,@nValCSL,nTotAbto)
				//Gravo Valores dos impostos no SE5 (ja locado)
				cCamposE5 += ",{'E5_VRETPIS' ,  "+cValToChar(nValPis)+"}"																		
				cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nValCof)+"}"
				cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nValCSL)+" }"
			EndIf			
		EndIf

		// alimenta o VRET do pcc na compensacao NCC mas nao gera o titulo, para
		//que este valor nao seja calculado na baixa do restante.
		If !lCredito 
			If lPccBaixa
				cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nPis)+"}"																		
				cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nCofins)+"}"
				cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nCsll)+"}"		
				If lIsNcc
					cCamposE5 += ",{'E5_PRETPIS' , '7' }"
					cCamposE5 += ",{'E5_PRETCOF' , '7' }"
					cCamposE5 += ",{'E5_PRETCSL' , '7' }"
				EndIf  
			EndIf

			If lIrPjBxCr
				cCamposE5 += ",{'E5_VRETIRF' , "+cValToChar(nIrrf)+"}"		
				If lIsNcc			
					cCamposE5 += ",{'E5_PRETIRF' , '7' }"
				EndIf	
			EndIf	

		EndIf	
		
		cCamposE5 += ",{'E5_FORNADT' , '" + cCliAdt + "' } "
		cCamposE5 += ",{'E5_LOJAADT' , '" + cLojaAdt + "' } "

		If l330Mov1
			ExecBlock("SE5FI330",.f.,.f.)
		EndIf

		If nMoeda > 1 
			If cPaisLoc == "BRA"
				oSubFK1:SetValue("FK1_TXMOED", nTxCompP)
			ElseIf cPaisLoc == "MEX" .And.  Type("aTxMoedas") # "U"
				oSubFK1:SetValue( "FK1_TXMOED" , aTxMoedas[nMoeda][2] )
			EndIf
		EndIf

		cCamposE5 += " } "
		oModelBxR:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )

		If oModelBxR:VldData()
			oModelBxR:CommitData()
			
			//VA: Atualiza a FKD com as informações da baixa
			If __l330Va .And. !oSubFK6:IsEmpty()
				For nCntFK6 := 1 to oSubFK6:Length()
					oSubFK6:GoLine(nCntFK6)
					If oSubFK6:GetValue("FK6_TPDOC",nCntFK6) $ "VA"
						FA330VAFKD(cIdDoc, oSubFK6:GetValue("FK6_CODVAL"), If(lIdFkd, oSubFK6:GetValue("FK6_IDFKD"),""), dBaixa, oSubFK6:GetValue("FK6_VALMOV")) 
					EndIf
				Next
			EndIf
			
			nRecFk1	:= FK1->(Recno())
			SE5->(DbGoto(oModelBxR:GetValue("MASTER","E5_RECNO")))	//posicionando o movimento de compensação recém-gravado
			aAdd( aBaixas, { { "CMP", cSequencia, SE5->(Recno()), SE1->E1_TIPO, cAdiantamento, SE5->E5_DOCUMEN, SE1->E1_ORIGEM, SE1->(Recno()) } } )
			
			// Integração SIGAPFS x SIGAFIN
			// Quando a compensação for posicionada no Tìtulo deve executar por aqui
			If lRet .And. FindFunction("JGrvBaixa")
				lRet := JGrvBaixa(SE1->(Recno()), SE5->(Recno()), nRegCmp)
			EndIf		
			
			aAdd(aRecSE5, FIM010RSE5()[Len(FIM010RSE5())])
		Else
			lRet := .F.
			cLog := cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_IDFIELDERR]) + ' - '
			cLog += cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_ID]) + ' - '
			cLog += cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_MESSAGE])         	
			Help( ,,"FA330MOV01",,cLog, 1, 0 )   
		EndIf

		If !Empty(nCm)
			F330MoedCm()
		EndIf
		
		oSubFK1 := Nil
		oSubFKA := Nil
		oSubFK6 := Nil
		
		oModelBxR:DeActivate()
		oModelBxR:Destroy()
		oModelBxR := Nil

		// Verifica se titulo esta no PIX e retira
		If cPaisLoc == "BRA" .and. !(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG) .and. lRet
			If __lExcImpo .And. !PIXCancel(xFilial("SE1", SE1->E1_FILORIG), cChaveFK7)
				lRet := .F.
				DisarmTransaction()
			EndIf
		EndIf

		//Carregando dados bancarios caso seja necessario gravar o registro da diferenca cambial.
		cBcoSE5  := SE5->E5_BANCO
		cAgSE5   := SE5->E5_AGENCIA
		cCtSE5   := SE5->E5_CONTA
		cLoteSE5 := SE5->E5_LOTE
		
		//Verifica se o titulo já possui impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
		nPisFin061	:=	0
		nCofFin061	:=	0
		nCslFin061	:=	0
		nIrfFin061	:=	0
		nRegSE5	:=	SE5->(Recno())
		nOrdSE5	:=	SE5->(IndexOrd())		

		If !lCredito
			nRegSe5Ori := SE5->(Recno())
		EndIf	
		
		If SE1->E1_TIPO <> MVRECANT .AND. SE1->E1_TIPO <> MV_CRNEG .And. (lPccBxCr .Or. lIrPjBxCr) 
			dbSelectArea("SE5")
			SE5->(dbSetOrder(2)) //FILIAL + TIPODOC + PREFIXO + NUMERO + PARCELA + TIPO
			If SE5->(DBSeek(xFilial("SE5")+"BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
				While !SE5->(Eof()) .and. SE5->E5_FILIAL==xFilial("SE5") .And. ;
					SE5->E5_TIPODOC+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO=="BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO		
				
					If  ("FINA061" $ Subst(SE5->E5_HISTOR,1,7) .Or. "FINA891" $ Subst(SE5->E5_HISTOR,1,7)) .And. SE5->E5_MOTBX $ "PCC_IRF"						
						If Alltrim(SE5->E5_MOTBX) == "PCC"
						nPisFin061	+= SE5->E5_VRETPIS
						nCofFin061	+= SE5->E5_VRETCOF
						nCslFin061	+= SE5->E5_VRETCSL
						ElseIf Alltrim(SE5->E5_MOTBX) == "IRF"
						nIrfFin061	+= SE5->E5_VRETIRF
						EndIf
					EndIf					
					SE5->(DbSkip())		
			EndDo
			EndIf
		EndIf
		
		SE5->(Dbgoto(nRegSE5))
		SE5->(Dbsetorder(nOrdSE5))
		
		If lCredito .and. !(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG)
			nIrfBaseC := nIrfBaseR := FBaseImp(nValorReal)
		EndIf
		If !__lIrfMR
			If cPaisLoc == "BRA" .and. lIrPjBxCr .and. !lCredito .And. !lNcc .And. nIrfFin061 == 0	 .And. !lRaRtImp
				FGrvIrRec(@nIrrf,nRecSe1,.F.,cSequencia,"FINA070",SE1->E1_MOEDA)
				SE1->(dbGoTo(nRecSe1))
				FGSFQIRCR(nIrrf,nIRFBase,cSequencia)
				__cIdFk4IR := FK4->FK4_IDFK4
			EndIf
		EndIf
		
		SE5->(Dbgoto(nRegSE5))
		
		If !__lPccMR
			If cPaisLoc == "BRA" .And. lPccBxCr .And. !lCredito .And. !lNcc .And. !lRartImp
				F330GrvSFQ(cSequencia,nRecSe1)
			EndIf
		EndIf
		
		//Se houver impostos calculados pelo motor, então chama a função de gravação dos títulos de impostos pelo motor de retenções 
		If Len( __aImpos ) > 0
			aImpMRSel := aClone ( __aImpos )
		EndIf
		
		RestVarMR( aImpMRBrw ) //Volta as variáveis do motor com os dados do título posicionado na browse 
		
		If Len( aImpMRSel ) > 0
			If lCredito //Se estiver posicionado no RA, só manda gerar os título de impostos da NF caso o mesmo tipo de imposto já não tenha sido gerado na emissão do RA
				For nJ := 1 To Len( aImpMRSel )
					If aImpMRSel[nJ][8] $ "PIS|COF|CSL" .And. !__lRaRtPcc
						aAdd( aAuxImpGrv, aClone(  aImpMRSel[nJ] ) )
					ElseIf aImpMRSel[nJ][8] == "IRF" .And. !__lRaRtIrf
						aAdd( aAuxImpGrv, aClone(  aImpMRSel[nJ] ) )
					ElseIf aImpMRSel[nJ][8] == "ISS" .And. !__lRaRtIss
						aAdd( aAuxImpGrv, aClone(  aImpMRSel[nJ] ) )
					Else
						aAdd( aAuxImpGrv, aClone(  aImpMRSel[nJ] ) )
					EndIf
				Next nJ
			Else
				aAuxImpGrv := aClone( aImpMRSel )
			Endif
		EndIf
		
		//Chama a função de gravação do motor de retenções
		IF Len( aAuxImpGrv ) > 0
			F330GrvFKs( nRecSe1, aAuxImpGrv ) //Grava as tabelas FK3 e FK4
			FinGrvImp( "2", SE1->(Recno()), aAuxImpGrv, "FINA330", .F., {}, {}, .F., .F., .T., dBaixa, "FK1", cSequencia, .T. )
		EndIf

		//PONTO DE ENTRADA NA ALTERACAO DO HISTORICO NA SE5 NA INCLUSAO
		If ExistBlock( "F330AE5I" )
		ExecBlock("F330AE5I",.F.,.F.)
		EndIf

		//Ajusto o E1_VALLIQ de acordo com o movimento do SE5
		RecLock("SE1")
			SE1->E1_VALLIQ := If(SE1->E1_MOEDA == 1, Round(nValorReal, 2), Round(nVlrEstr, 2))
			// Grava valor da correcao no titulo, para contabilizacao
			If (nValCm + nCm) != 0  
				If cPaisLoc == "BRA" .And. SE1->E1_MOEDA > 1 .And. nValCm != 0 .And. (lFina330 .OR. __lCmpM460)
					SE1->E1_CORREC := Round(nValCm, 2)
				Else
					SE1->E1_CORREC := nCm
				EndIf
			EndIf
		SE1->(MsUnlock())	

		// Atualizar saldo do cliente
		aArea	:= GetArea()
		nVlReal	:= nValorReal - nTitAcres + nTitDecre
		dbSelectArea("SA1")
		SA1->(DbSetOrder(1))
		
		If dbSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA)
			RecLock("SA1")
			If lCredito
				AtuSalDup("+",nVlReal,1,SE1->E1_TIPO,,SE1->E1_EMISSAO)
			Else
				AtuSalDup("-",nVlReal,1,SE1->E1_TIPO,,SE1->E1_EMISSAO)
			EndIf
			SA1->(MsUnlock())
		EndIf
		
		RestArea(aArea)

		If lRet .And. !Empty(cAdiantamento)
			nCM := 0
			dbSelectArea("SE1")
			SE1->(dbSetOrder(1))
			SE1->(dbGoto(nRegCmp))
			
			//Motor de retenções - base
			If __lMotRet
				//Verifica as configurações de impostos pelo motor de retenção
				__lTCnfgMR	:= F330VldImp()
				
				lPccBxCr := ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. lPccBxAux )
				lIrPjBxCr := ( __lIrfMR .And. __lIrfBxMR ) .Or. ( !__lIrfMR .And. lIrfBxAux )

				nBaseImpMR := FBaseImp(nValorReal)
			EndIf

			If nMoeda == 1
				nValorReal := nValor
				If !__lBq10925 .AND. (!lRaRtImp .or. (lRaRtImp .and. __nMarcs == 1))
					nValorReal := nValor - nPis - nCofins - nCsll - IiF(lIrPjBxCr,nIrrf,0)
				Endif							
				nVlrEstr   := xMoeda(nValorReal, nMoeda, SE1->E1_MOEDA, dDataBase, __nCasDec, 0, Iif( lCredito .Or. !__lRaTxMov, __nTxTiBrw, __nTxMoedD) )
			ElseIf SE1->E1_MOEDA > 1 .And.  SE1->E1_MOEDA <> nMoeda // Compensação sem envolver moeda real
				nVlrEstr	:= xMoeda(nValor, nMoeda, SE1->E1_MOEDA, dDataBase, __nCasDec, __nTxmoedp, __nTxMoedD) //Transforma na moeda do título
				nValorReal	:= xMoeda(nVlrEstr, SE1->E1_MOEDA, 1, dDataBase, __nCasDec, __nTxMoedD)
			Else
				nVlrEstr   := nValor
				If !__lBq10925 .AND. (!lRaRtImp .or. (lRaRtImp .and. __nMarcs == 1))
					nValImp := xMoeda((nPis+nCofins+nCsll+IiF(lIrPjBxCr,nIrrf,0)), 1, nMoeda, Ddatabase, __nCasDec, 0, __nTxMoedP)
					nVlrEstr := nValor - nValImp
				Endif	
				nValorReal := xMoeda(nVlrEstr, nMoeda, 1, dDataBase, __nCasDec, __nTxTiBrw)
			EndIf		
			
			__nTotCtb	+= Round(nValorReal, 2) //Auxilia na contabilizacao posteriormente (deve estar na moeda forte)

			oModelBxR 	:= FWLoadModel("FINM010") 
			oModelBxR:SetOperation( MODEL_OPERATION_INSERT )
			oModelBxR:Activate()
			oModelBxR:SetValue( "MASTER", "E5_GRV", .T. )
			oModelBxR:SetValue( "MASTER", "NOVOPROC", .T. )
			oSubFK1 := oModelBxR:GetModel( "FK1DETAIL" )
			oSubFKA := oModelBxR:GetModel( "FKADETAIL" )
			oSubFK6 := oModelBxR:GetModel( "FK6DETAIL" )
			
			cCamposE5 := " { "
			cCamposE5 += "{'E5_FILIAL'		,'" +  cFilSE5 + "'}"
			cCamposE5 += ",{'E5_PREFIXO'	,'" +  SE1->E1_PREFIXO+ "'}"
			cCamposE5 += ",{'E5_NUMERO'		,'" +  SE1->E1_NUM + "'}"
			cCamposE5 += ",{'E5_PARCELA'	,'" +  SE1->E1_PARCELA + "'}"
			cCamposE5 += ",{'E5_CLIENTE'	,'" +  SE1->E1_CLIENTE + "'}"
			cCamposE5 += ",{'E5_CLIFOR'		,'" +  SE1->E1_CLIENTE + "'}"
			cCamposE5 += ",{'E5_LOJA'		,'" +  SE1->E1_LOJA + "'}"
			cCamposE5 += ",{'E5_BENEF'		,'" +  StrTran(SE1->E1_NOMCLI,"'","")+ "'}"
			cCamposE5 += ",{'E5_TIPO'		,'" +  SE1->E1_TIPO + "'}"
			cCamposE5 += ",{'E5_DTDIGIT'	, STOD('" + DTOS(dDataBase) + "')}"
			cCamposE5 += ",{'E5_DTDISPO'	, STOD('" + DTOS(dBaixa) + "')}"
			
			cChaveTit 	:= xFilial("SE1", SE1->E1_FILORIG)+"|"+SE1->E1_PREFIXO+"|"+SE1->E1_NUM+"|"+SE1->E1_PARCELA+"|"+SE1->E1_TIPO+"|"+SE1->E1_CLIENTE+"|"+SE1->E1_LOJA
			cChaveFK7	:= FINGRVFK7("SE1", cChaveTit, SE1->E1_FILORIG)
			cIdFK1		:= FWUUIDV4()
			
			If !oSubFKA:IsEmpty()
				oSubFKA:AddLine()
			EndIf
		
			oSubFKA:SetValue( "FKA_IDORIG"	, cIdFK1 )
			oSubFKA:SetValue( "FKA_TABORI"	, 'FK1')

			If !oSubFK1:IsEmpty()
				oSubFK1:AddLine()
			EndIf
		
			oSubFK1:SetValue( "FK1_DATA"	, dBaixa )
			oSubFK1:SetValue( "FK1_NATURE"	, SE1->E1_NATUREZ )
			oSubFK1:SetValue( "FK1_RECPAG"	, "R" )
			oSubFK1:SetValue( "FK1_MOTBX"	, "CMP")
			oSubFK1:SetValue( "FK1_ORIGEM"	, FunName() )
			oSubFK1:SetValue( "FK1_SEQ"		, cSequencia )
			oSubFK1:SetValue( "FK1_DOC"		, cDocOriginal )
			oSubFK1:SetValue( "FK1_IDDOC"	, cChaveFK7 )
			oSubFK1:SetValue( "FK1_TPDOC"	, cTpDoc )
			oSubFK1:SetValue( "FK1_CCUSTO"	, SE1->E1_CCUSTO )	
			oSubFK1:SetValue( "FK1_FILORI"	, SE1->E1_FILORIG )
			oSubFK1:SetValue( "FK1_VALOR",  If(SE1->E1_MOEDA == 1, Round(nValorReal, 2), Round(nVlrEstr, 2)))
			oSubFK1:SetValue( "FK1_VLMOE2", If(SE1->E1_MOEDA == 1, Round(nVlrEstr, 2), Round(nValorReal, 2)))
			oSubFK1:SetValue( "FK1_SITCOB"	, SE1->E1_SITUACA )
			oSubFK1:SetValue( "FK1_MOEDA",  StrZero(SE1->E1_MOEDA, 2))
			oSubFK1:SetValue( "FK1_LA"		, IIF(lPadrao .and. nContab == 1,"S","N") )
			oSubFK1:SetValue( "FK1_IDCOMP"	, cChvFK7out )
					
			If lCredito
				oSubFK1:SetValue( "FK1_HISTOR"	, OemToAnsi(If(lIsNcc,STR0078,STR0036)) ) //"Compensação Nota de Crédito" //"Compensaçäo de Adiantamentos"
				oSubFK1:SetValue( "FK1_TPDOC"	, "CP" )
			Else
				oSubFK1:SetValue( "FK1_HISTOR"	, OemToAnsi(STR0077) ) //"Baixa por Compensação"
				oSubFK1:SetValue( "FK1_TPDOC"	, "BA" )
			EndIf
			
			oSubFK1:SetValue( "FK1_LOTE"  , cLote )
			
			//Ponto de Entrada para permitir a manipulação da filial no movimento bancario
			If ! lMultFil
				cCamposE5 += ",{'E5_FILIAL'		,'" + xFilial("SE5") + "' } "
			Else
				cCamposE5 += ",{'E5_FILIAL'		,'" + ExecBlock("SE5MTFIL",.F.,.F.,cFilAnt)+"' } "
			EndIf
		
			cCamposE5 += ",{'E5_LA'		,'" +  IIF(lPadrao .and. nContab == 1,"S","N") + "'}"

			If !lPccBxCr
				//Acerto valor dos impostos - Tecnofibras
				If lImpComp .and. lIsNcc .and. lPccBaixa
					//Gravo Valores dos impostos no SE5 (ja locado)
					cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nValPis)+"}"																		
					cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nValCof)+"}"
					cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nValCsl)+"}"  
				EndIf
			EndIf

			// alimenta o VRET do pcc na compensacao NCC mas nao gera o titulo, para
			//que este valor nao seja calculado na baixa do restante.
			If lCredito .And. ( lIsNcc .Or. !(SE1->E1_TIPO $ MVRECANT) ) 
				If lPccBaixa
					cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nPis)+"}"
					cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nCofins)+"}"
					cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nCsll)+"}"
					cCamposE5 += ",{'E5_PRETPIS' , '7' }"
					cCamposE5 += ",{'E5_PRETCOF' , '7' }"
					cCamposE5 += ",{'E5_PRETCSL' , '7' }"
				ElseIf !(SE1->E1_TIPO $ MVRECANT)
					cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nPisCalc)+"}"
					cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nCofCalc)+"}"
					cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nCslCalc)+"}"
					cCamposE5 += ",{'E5_PRETPIS' , '1' }"
					cCamposE5 += ",{'E5_PRETCOF' , '1' }"
					cCamposE5 += ",{'E5_PRETCSL' , '1' }"
				EndIf

				If lIrPjBxCr
					cCamposE5 += ",{'E5_VRETIRF' , "+cValToChar(nIrrf)+"}"
					cCamposE5 += ",{'E5_PRETIRF' , '7' }"			
				EndIf

			EndIf
			
			If nAcresc <> 0
				If !oSubFK6:IsEmpty()
					oSubFK6:AddLine()
				EndIf
				
				nAcresc		:=	Round(xMoeda(nAcresc, SE1->E1_MOEDA, 1, Nil, __nCasDec, __nTxTiBrw), 2)

				oSubFK6:SetValue( 'FK6_GRVSE5'  , .F.)		
				oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
				oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
				oSubFK6:SetValue( 'FK6_TPDOC'	, 'JR' )
				oSubFK6:SetValue( 'FK6_VALCAL'	, nAcresc )	
				oSubFK6:SetValue( 'FK6_VALMOV'	, nAcresc )
				oSubFK6:SetValue( 'FK6_RECPAG'	, "R" )
				oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
				oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0049) ) //ACRESCIMO
				
				cCamposE5 += ",{'E5_VLJUROS'," + Str(nAcresc) + " }"
				cCamposE5 += ",{'E5_VLACRES'," + Str(nAcresc) + " }"
			EndIf
			
			nDiff := (SE1->E1_SALDO - FK1->FK1_VALOR)
			lDescToler := ( nDiff > 0 .And. nDiff <= nMVToler )
			If nDecres+nDescD <> 0 .Or. lDescToler
				If !oSubFK6:IsEmpty()
					oSubFK6:AddLine()
				EndIf
				
				nDecres := Round(xMoeda(nDecres + nDescD + if(lDescToler, nDiff ,0), SE1->E1_MOEDA, 1, Nil, __nCasDec, __nTxTiBrw), 2)
				
				oSubFK6:SetValue( 'FK6_GRVSE5'  , .F.)		
				oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
				oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
				oSubFK6:SetValue( 'FK6_TPDOC'	, 'DC' )
				oSubFK6:SetValue( 'FK6_VALCAL'	, nDecres )
				oSubFK6:SetValue( 'FK6_VALMOV'	, nDecres )
				oSubFK6:SetValue( 'FK6_RECPAG'	, "R" )
				oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
				oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0050) ) //DECRESCIMO
				oSubFK6:SetValue( 'FK6_TPDESC'	, Iif(SE1->E1_TPDESC == 'C', '1', '2') )
			
				cCamposE5 += ",{'E5_VLDESCO'," + Str(nDecres) + " }"
				cCamposE5 += ",{'E5_VLDECRE'," + Str(nDecres) + " }"
			EndIf

			If lDescToler
				RecLock("SE1", .F.)
					Replace E1_SDDECRE With E1_SDDECRE -= Round(xMoeda(nDiff, nMoeda, 1, Nil, __nCasDec, __nTxTiBrw), 2)
				SE1->(MsUnLock())
			EndIf

			If !lCredito
				nAcresc := nTitAcres
				nDecres := nTitDecre
			EndIf

			//VA: Adiciona os valores da FKD ao model
			If __l330Va .And. (lCredito .Or. (!lCredito .And. nSaldoVA <> 0 ))
				cIdDoc := oSubFK1:GetValue("FK1_IDDOC")
				FSetFK6FKD( oSubFK6, cIdDoc, cIdFK1, "R" )
			EndIf
			
			If SE1->E1_MOEDA > 1 .Or. cPaisLoc != "BRA"
				nCM := FA330Corr(nVlrEstr, nVlrNF, "SE1", __nTxTiBrw)
			EndIf

			// Grava o valor de correção monetária no SE5 para ser visualizado na consulta
			If SE1->E1_MOEDA <> 1 .And. nCm != 0 .and. (lFina330 .OR. __lCmpM460)
				If !oSubFK6:IsEmpty()
					oSubFK6:AddLine()
				EndIf
				
				oSubFK6:SetValue( 'FK6_GRVSE5'  , .T.)		
				oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )
				oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
				oSubFK6:SetValue( 'FK6_TPDOC'	, 'CM' )
				oSubFK6:SetValue( 'FK6_VALCAL'	, nCm)	
				oSubFK6:SetValue( 'FK6_VALMOV'	, nCm)
				oSubFK6:SetValue( 'FK6_RECPAG'	, "R" )
				oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
				
				If SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG
					oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0075) ) //CORREC.DE ADIANTAMENTO
				Else
					oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0076) ) //CORREC. MONET S/ RECEBTO
				EndIf
				
				cCamposE5 += ",{'E5_VLCORRE'," + Str(nCm) + " }"	
			EndIf
			
			// Grava fornecedor do titulo no movimento do PA, para ser utilizado no
			//cancelamento da compensacao, quando se utiliza PA de outros fornecedores para compensar.
			cCamposE5 += ",{'E5_FORNADT' , '" + cCliOri + "' } "
			cCamposE5 += ",{'E5_LOJAADT' , '" + cLojaOri + "' } "

			If l330Mov2
				ExecBlock("SE5FI331",.f.,.f.)
			EndIf
			
			If SE1->E1_MOEDA > 1
				If cPaisLoc == "BRA"
					oSubFK1:SetValue("FK1_TXMOED", Iif( !lCredito .And. nMoeda == 1 .And. __lRaTxMov, __nTxMoedD, __nTxTiBrw) )
				ElseIf cPaisLoc == "MEX" .And.  Type("aTxMoedas") # "U"
					oSubFK1:SetValue( "FK1_TXMOED" , aTxMoedas[nMoeda][2] )
				EndIf
			EndIf
			
			cCamposE5 += " } "
			oModelBxR:SetValue("MASTER", "E5_CAMPOS", cCamposE5 )
		
			If oModelBxR:VldData()
				oModelBxR:CommitData()
				
				//VA: Atualiza a FKD com as informações da baixa
				If __l330Va .And. !oSubFK6:IsEmpty()
					For nCntFK6 := 1 to oSubFK6:Length()
						oSubFK6:GoLine(nCntFK6)
						If oSubFK6:GetValue("FK6_TPDOC",nCntFK6) $ "VA"
							FA330VAFKD(cIdDoc, oSubFK6:GetValue("FK6_CODVAL"), If(lIdFkd, oSubFK6:GetValue("FK6_IDFKD"),""), dBaixa, oSubFK6:GetValue("FK6_VALMOV")) 
						EndIf
					Next
				EndIf
			
				SE5->(DbGoto(oModelBxR:GetValue("MASTER","E5_RECNO")))	//posicionando o movimento de compensação recém-gravado
				aAdd( aBaixas, { { "CMP", cSequencia, SE5->(Recno()), SE1->E1_TIPO, cAdiantamento, SE5->E5_DOCUMEN, SE1->E1_ORIGEM, SE1->(Recno()) } } )
		
				aAdd(aRecSE5, FIM010RSE5()[Len(FIM010RSE5())])
				
				aArea		:= GetArea()
				aAreaFK1 	:= FK1->(GetArea())
				
				DbSelectArea("FK1")
				DbGoTo(nRecFk1)
				
				RecLock("FK1", .F.)
					FK1->FK1_IDCOMP := cChaveFK7
				MsUnLock()
				
				RestArea(aAreaFK1)
				RestArea(aArea)
			Else
				lRet := .F.
				cLog := cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_IDFIELDERR]) + ' - '
				cLog += cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_ID]) + ' - '
				cLog += cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_MESSAGE])
				Help( ,,"FA330MOV02",,cLog, 1, 0 )   
			EndIf
			
			If !Empty(nCm)
				F330MoedCm()
			EndIf		
			
			oSubFK1 := Nil
			oSubFKA := Nil
			oSubFK6 := Nil

			oModelBxR:DeActivate()
			oModelBxR:Destroy()
			oModelBxR:= Nil

			// Verifica se titulo esta no PIX e retira
			If cPaisLoc == "BRA" .and. !(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG) .and. lRet
				If __lExcImpo .And. !PIXCancel(xFilial("SE1", SE1->E1_FILORIG), cChaveFK7)
					lRet := .F.
					DisarmTransaction()
				EndIf
			EndIf
		
			nTxMoed1	:=	nTxMoed2	:=	nValEmis	:=	nValBax	:=	nValCm:=	0

			//Carregando dados bancarios caso seja necessario gravar o registro da diferenca cambial.
			cBcoSE5		:=	SE5->E5_BANCO
			cAgSE5		:=	SE5->E5_AGENCIA
			cCtSE5		:=	SE5->E5_CONTA
			cLoteSE5	:=	SE5->E5_LOTE

			//Verifica se o titulo já possui impostos gerados pela rotina de Borderô de Recebimento de Imposto (FINA061).
			nPisFin061	:=	0
			nCofFin061	:=	0
			nCslFin061	:=	0
			nIrfFin061	:=	0
			nRegSE5	:=	SE5->(Recno())
			nOrdSE5	:=	SE5->(IndexOrd())
			If SE1->E1_TIPO <> MVRECANT .AND. SE1->E1_TIPO <> MV_CRNEG .And. lPccBxCr .And. lIrPjBxCr                                                                                               			
				dbSelectArea("SE5")
				SE5->(dbSetOrder(2)) //FILIAL + TIPODOC + PREFIXO + NUMERO + PARCELA + TIPO
				If SE5->(DBSeek(xFilial("SE5")+"BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO))
					While !SE5->(Eof()) .and. SE5->E5_FILIAL==xFilial("SE5") .And. ;
						SE5->E5_TIPODOC+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO=="BA"+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO		
					
						If  ("FINA061" $ Subst(SE5->E5_HISTOR,1,7) .Or. "FINA891" $ Subst(SE5->E5_HISTOR,1,7)) .And. SE5->E5_MOTBX $ "PCC_IRF"						
							If Alltrim(SE5->E5_MOTBX) == "PCC"
							nPisFin061	+= SE5->E5_VRETPIS
							nCofFin061	+= SE5->E5_VRETCOF
							nCslFin061	+= SE5->E5_VRETCSL
							ElseIf Alltrim(SE5->E5_MOTBX) == "IRF"
							nIrfFin061	+= SE5->E5_VRETIRF
							EndIf
						EndIf
						SE5->(DbSkip())
						
				EndDo
				EndIf
			EndIf
			SE5->(Dbgoto(nRegSE5))
			SE5->(Dbsetorder(nOrdSE5))				
			
			If !__lIrfMR .And. lIrPjBxCr .And. lCredito .And. !lRaRtImp .and. !lNcc .And. nIrfFin061 == 0 	
				FGrvIrRec(@nIrrf,nRegCmp,.F.,cSequencia,"FINA070",SE1->E1_MOEDA)
				FGSFQIRCR(nIrrf,nIRFBase,cSequencia)
				__cIdFk4IR := FK4->FK4_IDFK4
			EndIf

			aAreaSE5 := SE5->(GetArea()) //para efeito de acerto no posicio. da SE5 na contabil.		
			//Gravando diferenca cambial		
			aBaixaSE5 := FIM010RSE5()		
			RestArea(aAreaSE5)
			
			//Motor de retenções - Calcula os impostos pelo motor de retenções
			If __lMotRet .And. __lTCnfgMR
				F330CalImp( SE1->E1_NATUREZ, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG, nBaseImpMR, dDataBase, SE1->E1_TIPO )
				__lTCnfgMR	:= .F.
			EndIf
			
			//Se houver impostos calculados pelo motor, então chama a função de gravação dos títulos de impostos pelo motor de retenções 
			aSize( aImpMRSel, 0 )
			aImpMRSel := {}
			aSize( aAuxImpGrv, 0 )
			aAuxImpGrv := {}
			If Len( __aImpos ) > 0
				aImpMRSel := aClone ( __aImpos )
			EndIf		 
			If Len( aImpMRSel ) > 0
				If lCredito //Se estiver posicionado no RA, só manda gerar os título de impostos da NF caso o mesmo tipo de imposto já não tenha sido gerado na emissão do RA
					For nJ := 1 To Len( aImpMRSel )
						If aImpMRSel[nJ][8] $ "PIS|COF|CSL" .And. !__lRaRtPcc
							aAdd( aAuxImpGrv, aClone(  aImpMRSel[nJ] ) )
						ElseIf aImpMRSel[nJ][8] == "IRF" .And. !__lRaRtIrf
							aAdd( aAuxImpGrv, aClone(  aImpMRSel[nJ] ) )
						ElseIf aImpMRSel[nJ][8] == "ISS" .And. !__lRaRtIss
							aAdd( aAuxImpGrv, aClone(  aImpMRSel[nJ] ) )
						Else
							aAdd( aAuxImpGrv, aClone(  aImpMRSel[nJ] ) )
						EndIf
					Next nJ
				Else
					aAuxImpGrv := aClone( aImpMRSel )
				EndIf
			EndIf
			//Chama a função de gravação do motor de retenções
			If Len( aAuxImpGrv ) > 0
				F330GrvFKs( nRegCmp, aAuxImpGrv ) //Grava as tabelas FK3 e FK4
				FinGrvImp( "2", SE1->(Recno()), aAuxImpGrv, "FINA330", .F., {}, {}, .F., .F., .T., dBaixa, "FK1", cSequencia, .T. )
			EndIf
					
			/////////////////////
			// PCC Baixa CR
			// Grava relacionamento no SFQ
			// Grava titulos PIS/COF/CSL no SE1
			If !__lPccMR .And. cPaisLoc == "BRA" .and. (lPccBxCr .or. lIrPjBxCr) .and. lCredito .and. !lNcc .And. !lRartImp
				F330GrvSFQ(cSequencia,nRegCmp)
			EndIf
			
			RestVarMR( aImpMRBrw ) //Volta as variáveis do motor com os dados do título posicionado na browse
			
			// Grava valor da correcao no titulo, para contabilizacao
			If (nValCm+nCm) != 0
				SE1->(RecLock("SE1"))
				If cPaisLoc == "BRA" .And. SE1->E1_MOEDA > 1 .And. nValCm <>0 .And. FUNNAME() $ "FINA330#FINA740"
					SE1->E1_CORREC := Round(nValCm, nDecs1)
				Else
					SE1->E1_CORREC := nCm
				Endif
				SE1->(MsUnlock())
			EndIf
			
			// Atualizar saldo do cliente
			nVlReal	:= nValorReal - nAcresc + nDecres
			aArea		:= GetArea()
			dbSelectArea("SA1")
			SA1->(DbSetOrder(1))
			If SA1->(dbSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA))
				SA1->(RecLock("SA1"))
				If lCredito
					AtuSalDup("-",nVlReal,1,SE1->E1_TIPO,,SE1->E1_EMISSAO)
				Else
					AtuSalDup("+",nVlReal,1,SE1->E1_TIPO,,SE1->E1_EMISSAO)
				EndIf
				SA1->(MsUnlock())
			EndIf
			RestArea(aArea)
		EndIf
	EndIf
	FZerSFQIr()

	dbSelectArea(cAlias)

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³F330ActImp  ³ Autor ³Mauricio Pequim Jr.. ³ Data ³ 11.11.05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Acerta valores dos impostos na compensacao CR com NCC.     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ FINA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function F330ActImp(nRecSE1,nValorReal,nValPis,nValCof,lBaixa,lCredito,nValCsl,nTotAbto)

Local nProporcao := 0
Local cKeySe1 := ""
Local aArea  := GetArea()
Local nTotAbt := 0
Local nTotAbImp := 0
Local nSe5Rec := 0   

//Controle de abatimento
Local lTitpaiSE1 := .T.
Local nOrdTitPai:=0
Local cTitPai	:=""
Local bWhile:= {||!EOF() .And.MsSeek(xFilial("SE1")+cKeySe1)}  

Default nValPis := 0
Default nValCof := 0
Default nValCsl := 0
Default lBaixa  := .T.

If Select("__SE1") == 0
	SumAbatRec("","","",1,"")
Endif

DbSelectArea("__SE1")
dbSetOrder(2)
dbGoto(nRecSe1)  //posiciono no titulo pai no SE1

//Verifico valor dos abatimentos antes de proporcionalizar
nTotAbImp := 0
nTotAbt  := SumAbatRec(__SE1->E1_PREFIXO,__SE1->E1_NUM,__SE1->E1_PARCELA,__SE1->E1_MOEDA,"V",dDataBase,@nTotAbImp) 
nTotAbt	 -= nTotAbImp 	

DbSelectArea("__SE1")
dbSetOrder(2)
dbGoto(nRecSe1)  //posiciono no titulo pai no SE1

nSe5Rec := SE5->( RECNO() )

aValor:=Baixas(__SE1->E1_NATUREZ,__SE1->E1_PREFIXO,__SE1->E1_NUM,__SE1->E1_PARCELA,__SE1->E1_TIPO,__SE1->E1_MOEDA,"R",__SE1->E1_CLIENTE,dDataBase,__SE1->E1_LOJA)

SE5->( dbGoto(nSE5Rec) )

nProporcao := nValorReal / (__SE1->E1_SALDO-nTotAbt+aValor[5] )

cKeySe1 := __SE1->(E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA)	  
cTitPai	:= __SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA)	 

If lBaixa
	//Se for a baixa que zera o saldo, a proporcao do imposto deverá ser igual a 1 para que seja
	//feita a compensacao correta
	If __SE1->E1_SALDO == 0
		nProporcao := 1
		nValPis := __SE1->E1_PIS
		nValCof := __SE1->E1_COFINS
		nValCsl := __SE1->E1_CSLL
	Else
		nValPis := ((__SE1->E1_PIS+aValor[14]) * nProporcao)
		nValCof := ((__SE1->E1_COFINS+aValor[15]) * nProporcao)
		nValCsl := ((__SE1->E1_CSLL+aValor[18]) * nProporcao)
	EndIf
Else
	nValPis := se5->e5_vretpis
	nValCof := se5->e5_vretcof
	nValCsl := se5->e5_vretcsl
EndIf

If nValPis+nValCof+nValCsl > 0
	//Acerto o valor dos impostos no titulo principal
	RecLock("__SE1")
	If lBaixa
		__SE1->E1_PIS -= nValPis
		__SE1->E1_COFINS -= nValCof
		__SE1->E1_CSLL -= nValCsl
	Else
		__SE1->E1_PIS += nValPis
		__SE1->E1_COFINS += nValCof
		__SE1->E1_CSLL += nValCsl
	Endif
	MsUnLock()
	
	//Acerto os valores dos titulos de impostos
	If lTitpaiSE1
 		 If (nOrdTitPai:= OrdTitpai()) > 0
			DbSetOrder(nOrdTitPai)
			If	DbSeek(xFilial("SE1")+cTitPai)    
			  	bWhile  := {|| !Eof() .And. Alltrim(__SE1->E1_TITPAI) == Alltrim(cTitPai)}   
			Else
				 	__SE1->(dbSetOrder(2))    
			Endif
		Endif
	Endif
	
	While Eval(bWhile)
	
		//Pis
		If __SE1->E1_TIPO $ MVPIABT
			If lBaixa
				RecLock("__SE1")
				__SE1->E1_VALOR -= nValPis
				__SE1->E1_SALDO := __SE1->E1_VALOR
				__SE1->E1_VLCRUZ := __SE1->E1_VALOR
				MsUnlock()
			Else
				RecLock("__SE1")
				__SE1->E1_VALOR += nValPis
				__SE1->E1_SALDO := __SE1->E1_VALOR
				__SE1->E1_VLCRUZ := __SE1->E1_VALOR
				MsUnlock()
			Endif
		Endif
	
		//Cofins
		If __SE1->E1_TIPO $ MVCFABT
			If lBaixa
				RecLock("__SE1")
				__SE1->E1_VALOR -= nValCof
				__SE1->E1_SALDO := __SE1->E1_VALOR
				__SE1->E1_VLCRUZ := __SE1->E1_VALOR
				MsUnlock()
			Else
				RecLock("__SE1")
				__SE1->E1_VALOR += nValCof
				__SE1->E1_SALDO := __SE1->E1_VALOR
				__SE1->E1_VLCRUZ := __SE1->E1_VALOR
				MsUnlock()
			Endif
		Endif
		
		//CSLL
		If __SE1->E1_TIPO $ MVCSABT
			If lBaixa
				RecLock("__SE1")
				__SE1->E1_VALOR -= nValCsl
				__SE1->E1_SALDO := __SE1->E1_VALOR
				__SE1->E1_VLCRUZ := __SE1->E1_VALOR
				MsUnlock()
			Else
				RecLock("__SE1")
				__SE1->E1_VALOR += nValCsl
				__SE1->E1_SALDO := __SE1->E1_VALOR
				__SE1->E1_VLCRUZ := __SE1->E1_VALOR
				MsUnlock()
			Endif
		Endif  
		__SE1->( DbSkip() )
	Enddo
EndIf

RestArea(aArea)

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} IntegDef

Funcao de integracao com o adapter EAI para o recebimento de compensacao
de titulos a receber.

@param   Caracter, cXML, Variavel com conteudo xml para envio/recebimento.
@param   Caracter, cTypeTrans, Tipo de transacao. (Envio/Recebimento)
@param   Caracter, cTypeMsg, Tipo de mensagem. (Business Type, WhoIs, etc)
@param   Caracter, cVersion, Versão da mensagem.

@author  TOTVS
@version P12
@since   03/02/2017
@return  Array, Array contendo o resultado da execucao e a mensagem Xml de retorno.
         aRet[1] - (boolean) Indica o resultado da execução da função
         aRet[2] - (caracter) Mensagem Xml para envio

@obs
O método irá retornar um objeto do tipo TOTVSBusinessEvent caso
o tipo da mensagem seja EAI_BUSINESS_EVENT ou um tipo
TOTVSBusinessRequest caso a mensagem seja do tipo TOTVSBusinessRequest.
O tipo da classe pode ser definido com a função EAI_BUSINESS_REQUEST.
/*/
//-------------------------------------------------------------------
Static Function IntegDef( cXML, nTypeTrans, cTypeMessage, cVersion )
	Local aRet := {}

	aRet := FINI330( cXML, nTypeTrans, cTypeMessage, cVersion )

Return aRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RABxAnt

Função para verificação do valor já compensado do RA

@author    Rodrigo Oliveira
@version   12
@since     18/08/2017

@return nTotCmp - retorna o total já compensado desse RA 
/*/
//-----------------------------------------------------------------------------------------------------

Static Function RABxAnt() As Numeric

	Local aArea 	As Array
	Local aAreaSE5 	As Array
	Local cQuery	As Character
	Local nSld		As Numeric
	Local nI		As Numeric
	
	aArea 		:= GetArea()
	aAreaSE5 	:= GetArea()
	cQuery		:= ""
	nSld		:= 0
	nI			:= 0

	cQuery := " SELECT SUM(SE5.E5_VALOR) TOTAL, 'COMP' AS SITUA "
	cQuery += " FROM " + RetSqlName("SE5") + " SE5 "
	cQuery += " WHERE SE5.E5_FILIAL = '" + xFilial("SE5") + "' " 
	cQuery += " AND SE5.E5_NUMERO = '" + SE1->E1_NUM + "' " 
	cQuery += " AND SE5.E5_TIPO = '" + SE1->E1_TIPO + "' " 
	cQuery += " AND SE5.E5_MOTBX = 'CMP' " 
	cQuery += " AND SE5.E5_TIPODOC != 'ES' "
	cQuery += " AND SE5.D_E_L_E_T_ = '' "
	
	cQuery += " UNION "
	
	cQuery += " SELECT SUM(E5EST.E5_VALOR) TOTAL, 'ESTORNO' AS SITUA 
	cQuery += " FROM " + RetSqlName("SE5") + " E5EST "
	cQuery += " WHERE E5EST.E5_FILIAL = '" + xFilial("SE5") + "' " 
	cQuery += " AND E5EST.E5_NUMERO = '" + SE1->E1_NUM + "' " 
	cQuery += " AND E5EST.E5_TIPO = '" + SE1->E1_TIPO + "' " 
	cQuery += " AND E5EST.E5_MOTBX = 'CMP' " 
	cQuery += " AND E5EST.E5_TIPODOC = 'ES' "
	cQuery += " AND E5EST.D_E_L_E_T_ = '' "
	
	cQuery := ChangeQuery(cQuery)
	
	dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TRBEST",.f.,.t.)
	
	("TRBEST")->(DbGoTop())
	
	For nI := 1 to 2
		If AllTrim(("TRBEST")->SITUA) == 'COMP'
			nSld	+= ("TRBEST")->TOTAL
		Else
			nSld	-= ("TRBEST")->TOTAL
		EndIf
		("TRBEST")->(DbSkip())
	Next 
	
	("TRBEST")->(DbCloseArea())
	
	RestArea(aAreaSE5)
	RestArea(aArea)

Return nSld

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F330VldImp()
Função para retornar as configurações de impostos através do motor de retenções

@author Pedro Alencar
@since 08/01/2018
@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Static Function F330VldImp()
	Local nZ As Numeric
	Local lPisMR As Logical
	Local lCofMR As Logical
	Local lCslMR As Logical
	Local lPisBxMR As Logical
	Local lCofBxMR As Logical
	Local lCslBxMR As Logical
	Local lRaRtPis As Logical
	Local lRaRtCof As Logical
	Local lRaRtCsl As Logical
	Local aImpConf As Array
	Local cTitPosic As Char
	//Local lCfgAdto	As Logical
	
	lPisMR := .F.
	lCofMR := .F.
	lCslMR := .F.
	lPisBxMR := .F.
	lCofBxMR := .F.
	lCslBxMR := .F.
	lRaRtPis := .F.
	lRaRtCof := .F.
	lRaRtCsl := .F.
	//lCfgAdto := .F.
	aImpConf := {}
	cTitPosic := SE1->E1_FILORIG + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO + SE1->E1_CLIENTE + SE1->E1_LOJA
	
	/*---------------------------------------------------------------------------
	Estrutura do aImpConf
	[1] = Codigo do tipo de imposto (cCodFOO)
	[2] = Fato gerador ( 1=Competência; 2=Caixa ) 
	[3] = Código FOI
	[4] = Tipo de Movimento (FKM_TPMVEM)
	[5] = Valor da nota (FKM_VLNOTE)
	[6] = Ação para antecipações (FKM_ANTEBX: 1= Retém; 2=Provisiona; 3=Sem ação)
	----------------------------------------------------------------------------*/
	If __cOldMRCf <> cTitPosic //Chama a função para ver os impostos configurados pelo motor de retenções, caso já não tenha sido chamada para o título posicionado 
		ClrVarMRCf()
		__cOldMRCf := cTitPosic
		
		aImpConf 	:= FinImpConf( "2", SE1->E1_FILORIG, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_NATUREZ, SE1->E1_TIPO )
		__lTCnfgMR	:= Len(aImpConf) > 0 
		For nZ := 1 To Len( aImpConf )
			Do Case
				
				Case aImpConf[nZ,1] == "PIS" //.And. ( !lCfgAdto .Or. ( lCfgAdto .And. aImpConf[nZ,6] == '1'))
					lPisMR 		:= .T.
					lPisBxMR 	:= ( aImpConf[nZ,2] == "2" )
					lRaRtPis 	:= ( aImpConf[nZ,6] == "1" )
				
				Case aImpConf[nZ,1] == "COF" //.And. ( !lCfgAdto .Or. ( lCfgAdto .And. aImpConf[nZ,6] == '1'))
					lCofMR 		:= .T.
					lCofBxMR 	:= ( aImpConf[nZ,2] == "2" )
					lRaRtCof 	:= ( aImpConf[nZ,6] == "1" )
				
				Case aImpConf[nZ,1] == "CSL" //.And. ( !lCfgAdto .Or. ( lCfgAdto .And. aImpConf[nZ,6] == '1'))
					lCslMR 		:= .T.
					lCslBxMR 	:= ( aImpConf[nZ,2] == "2" )
					lRaRtCsl 	:= ( aImpConf[nZ,6] == "1" )
				
				Case aImpConf[nZ,1] == "IRF" //.And. ( !lCfgAdto .Or. ( lCfgAdto .And. aImpConf[nZ,6] == '1'))
					__lIrfMR 	:= .T.
					__lIrfBxMR 	:= ( aImpConf[nZ,2] == "2" )
					__lRaRtIrf 	:= ( aImpConf[nZ,6] == "1" )
				
				Case aImpConf[nZ,1] == "ISS" //.And. ( !lCfgAdto .Or. ( lCfgAdto .And. aImpConf[nZ,6] == '1'))
					__lIssMR 	:= .T.
					__lIssBxMR 	:= ( aImpConf[nZ,2] == "2" )
					__lRaRtIss 	:= ( aImpConf[nZ,6] == "1" )
				OtherWise
					__lImpMR 	:= .T.
					__lImpBxMR	:= ( aImpConf[nZ,2] == "2" )
			EndCase
		Next nZ
		
		__lPccMR := lPisMR .Or. lCofMR .Or. lCslMR
		__lPccBxMR := lPisBxMR .Or. lCofBxMR .Or. lCslBxMR
		__lRaRtPcc := lRaRtPis .Or. lRaRtCof .Or. lRaRtCsl

		__aImpAnt := aClone(aImpConf)

		FWFreeArray(aImpConf)
		aImpConf := {}

	Else
		__lTCnfgMR	:= Len(__aImpAnt) > 0 
		For nZ := 1 To Len(__aImpAnt)
			Do Case
				
				Case __aImpAnt[nZ,1] == "IRF"
					__lIrfMR 	:= .T.
					__lIrfBxMR 	:= ( __aImpAnt[nZ,2] == "2" )
					__lRaRtIrf 	:= ( __aImpAnt[nZ,6] == "1" )
				
				Case __aImpAnt[nZ,1] == "ISS"
					__lIssMR 	:= .T.
					__lIssBxMR 	:= ( __aImpAnt[nZ,2] == "2" )
					__lRaRtIss 	:= ( __aImpAnt[nZ,6] == "1" )
				OtherWise
					__lImpMR 	:= .T.
					__lImpBxMR	:= ( __aImpAnt[nZ,2] == "2" )
			EndCase
		Next nZ
		
	EndIf
	
Return __lTCnfgMR

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F330CalImp()
Função para realizar o cálculo de imposto através do motor de retenções

@param cNatMR, Natureza para cálculo do imposto pelo motor de retenções
@param cCliMR, Cliente para cálculo do imposto pelo motor de retenções
@param cLojaMR, Loja para cálculo do imposto pelo motor de retenções
@param cFilMR, Filial de origem para cálculo do imposto pelo motor de retenções
@param nBaseMR, Valor base para cálculo do imposto pelo motor de retenções
@param dDataMR, Data para cálculo do imposto pelo motor de retenções
@param cTipoTitMR, Tipo do tíutlo para cálculo do imposto pelo motor de retenções 
@author Pedro Alencar
@since 12/01/2018
@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Static Function F330CalImp( cNatMR As Char, cCliMR As Char, cLojaMR As Char, cFilMR As Char, nBaseMR As Numeric, dDataMR As Date, cTipoTitMR As Char, lTroca As Logical )
	Local nZ 		As Numeric
	Local cTitPosic As Char
	Local nI 		As Numeric
	Local nX 		As Numeric
	Local cChaveAux As Char
	Local aImposE 	As Array
	Local nTotAdto	As Numeric
	Local lPccBxCr 	As Logical
	Local lMRVrTimp As Logical
	Local nVlParcl	As Numeric
	Local aArea     As Array
	
	Default cNatMR 		:= ""
	Default cCliMR 		:= ""
	Default cLojaMR 	:= ""
	Default cFilMR 		:= ""
	Default nBaseMR 	:= 0
	Default dDataMR		:= CtoD("//")
	Default cTipoTitMR 	:= ""
	Default lTroca		:= .F.
	
	lMRVrTimp	:= Type('lRarTimpMR') != "U"
	
	lPccBxCr := ( __lPccMR .And. __lPccBxMR ) .Or. ( !__lPccMR .And. FPccBxCr() )
	
	aImposE		:= {}
	nVlParcl	:= 0
	aArea 		:= GetArea()
	
	cTitPosic := SE1->E1_FILORIG + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO + SE1->E1_CLIENTE + SE1->E1_LOJA
	cChaveAux := FWxFilial( "SE1", SE1->E1_FILIAL ) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA	
	
	If __lPccMR 
		nPis 	:= 0
		nCofins := 0
		nCsll 	:= 0
	EndIf
	If __lIrfMR																						
		nIrrf 	:= 0
	EndIf
	
	ClrVarMRCl()
	__cOldMRCl := cTitPosic

	/*-------------------------------------------
	Estrutura da aImpos
	[1] = Codigo do tipo de imposto (FKM_CODIGO)
	[2] = Base do imposto
	[3] = Valor calculado do imposto
	[4] = Base de retenção do imposto
	[5] = Valor a reter do imposto
	[6] = IDRET FK4
	[7] = Array contendo os Recnos FK3 das pendências de retenção	
	[8] = Tipo do Imposto (SX5 - 0C )
	[9] = Fato gerador ( 1=Competência; 2=Caixa )
	[10] = Natureza do imposto
	[11] = Tabela onde foi gerado o imposto
	[12] = Recno do titulo de imposto gerado
	[13] = Ação aplicada no valor da nota na emissão(1 = subtrai, 2 = soma, 3 = sem ação) 
	[14] = Carteira de movimento na emissão (1 = Pagar, 2 = Receber)
	[15] = Tipo de movimento na emissão (1 = Abtimento, 2 = Provisão, 3 = Retenção, 4 = Não Gerar)
	[16] = Ação aplicada no valor da nota na baixa(1 = subtrai, 2 = soma, 3 = sem ação)
	[17] = Carteira de movimento na baixa (1 = Pagar, 2 = Receber)
	[18] = Tipo de movimento na baixa (1 = Abtimento, 2 = Provisão, 3 = Retenção, 4 = Não Gerar) 
	[19] = Ação sobre títulos de antecipação pagamento/recebimento: 1 = Retém, 2 = Provisiona, 3 = sem ação
	--------------------------------------------*/
	
	If lTroca
		aImposE := FMRGetArr('2', .F.)
		For nI := 1 To Len( aImposE )
			Do Case
				Case aImposE[nI,8] == "PIS" .And. aImposE[nI,9] == '1'
					__nPisCaMR += aImposE[nI,5]
				Case aImposE[nI,8] == "COF" .And. aImposE[nI,9] == '1'
					__nCofCaMR += aImposE[nI,5]
				Case aImposE[nI,8] == "CSL" .And. aImposE[nI,9] == '1'
					__nCslCaMR += aImposE[nI,5]
				Case aImposE[nI,8] == "IRF" .And. aImposE[nI,9] == '1'
					__nIrfCaMR += aImposE[nI,5]
				Case aImposE[nI,8] == "ISS" .And. aImposE[nI,9] == '1'
					__nIssCaMR += aImposE[nI,5]
				OtherWise
					If aImposE[nI,9] == '1'
						// aAdd(__aOutImp, nI)
						__nImpMR	+= aImposE[nI,5]
						__lImpMR	:= .T.
						__lImpEmis	:= .T.
					EndIf			
			EndCase
		Next nI
	EndIf

	If SE1->E1_SALDO <> SE1->E1_VALOR
		If Len(aBaixaSE5) == 0
			If Empty(SE1->E1_TIPOLIQ)
				//Procura pelas baixas deste titulo
				Sel070Baixa( "VL /V2 /BA /RA /CP /LJ /" + MV_CRNEG, SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, ;
					@nTotAdto, /*@lBaixaAbat*/, SE1->E1_CLIENTE, SE1->E1_LOJA) //, /*@nVlrBaixa*/,, @lBxCec, @lBxLiq, @lSigaLoja, @lTipBxCP )

				For nX := 1 To Len(aBaixaSE5)
					nVlParcl += aBaixaSE5[nX][8]				
					If lPccBxCR .And. ( lRaRtImp .Or. ( lMRVrTimp  .And. lRaRtImpMR ) ) //somar impostos PCC
						nVlParcl += aBaixaSE5[nX][18] + aBaixaSE5[nX][19] + aBaixaSE5[nX][20] + aBaixaSE5[nX][30] + aBaixaSE5[nX][32] + aBaixaSE5[nX][33]
					EndIf
					nIss += aBaixaSE5[nX][32]
					nInss += aBaixaSE5[nX][33]
				Next
				nVlParcl := nTotAdto
			Else
				nVlParcl := SE1->E1_VALOR - SE1->E1_SALDO
			EndIf
		EndIf
			
		__nBaseMR	:= SE1->E1_VALOR - nVlParcl
		nBaseMR 	:= Iif( nVlParcl > 0, __nBaseMR, nBaseMR )
	EndIf

	__aImpos := FINCalImp( "2", cNatMR, cCliMR, cLojaMR, cFilMR, nBaseMR, dDataMR, .T., {}, cTipoTitMR, cChaveAux)
	For nZ := 1 To Len( __aImpos )
		Do Case
			Case __aImpos[nZ,8] == "PIS"
				__nPisCaMR += __aImpos[nZ,5]
			Case __aImpos[nZ,8] == "COF"
				__nCofCaMR += __aImpos[nZ,5]
			Case __aImpos[nZ,8] == "CSL"
				__nCslCaMR += __aImpos[nZ,5]
			Case __aImpos[nZ,8] == "IRF"
				__nIrfCaMR += __aImpos[nZ,5]
			Case __aImpos[nZ,8] == "ISS"
				__nIssCaMR += __aImpos[nZ,5]
			OtherWise
				aAdd(__aOutImp, nZ)
				__nImpMR	+= __aImpos[nZ,5]
				__lImpMR	:= .T.
		EndCase
	Next nZ
	
	If __lPccMR
		nPis 	:= __nPisCaMR 
		nCofins := __nCofCaMR
		nCsll 	:= __nCslCaMR
	EndIf
	
	If __lIrfMR
		nIrrf := __nIrfCaMR
	EndIf
	RestArea(aArea)
Return Nil

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} LimpaVarMR()
Função para limpar as variáveis estáticas utilizadas para o motor de retenções

@author Pedro Alencar
@since 08/01/2018
@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Static Function LimpaVarMR()
	
	ClrVarMRCf() //Limpa as variáveis de configuração
	ClrVarMRCl() //Limpa as variáveis de cálculo	
	__cOldMRCf := ""
	__cOldMRCl := ""
	__lMotRet := .F.
	FwFreeArray(__aImpAnt)
	__aImpAnt	:= {}
	
Return Nil

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ClrVarMRCf()
Função para limpar as variáveis estáticas utilizadas para AS CONFIGURAÇÔES do motor de retenções

@author Pedro Alencar
@since 08/01/2018
@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Static Function ClrVarMRCf()

	__lPccMR 	:= .F.
	__lPccBxMR 	:= .F.
	__lRaRtPcc 	:= .F.
	__lIrfMR 	:= .F.
	__lIrfBxMR 	:= .F.
	__lRaRtIrf 	:= .F.
	__lIssMR 	:= .F.
	__lIssBxMR 	:= .F.
	__lRaRtIss 	:= .F.
	__lImpEmis	:= .F.
	__nImpEst	:= 0
	
Return Nil

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ClrVarMRCl()
Função para limpar as variáveis estáticas utilizadas para OS CÁLCULOS do motor de retenções

@author Pedro Alencar
@since 08/01/2018
@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Static Function ClrVarMRCl()
	
	__nPisCaMR 	:= 0
	__nCofCaMR 	:= 0
	__nCslCaMR 	:= 0
	__nIrfCaMR 	:= 0
	__nIssCaMR 	:= 0
	__nImpMR	:= 0
	__nBaseMR	:= 0
	
	aSize ( __aImpos, 0 )
	__aImpos := {}
	
Return Nil

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PegaVarMR()
Função para guardar os valores das variáveis estáticas utilizadas para o motor de retenções, 
para poder restaurá-los sem precisar realizar o cáluclo do motor novamente.

@return aRet, vetor com os dados das variáveis estáticas usadas para o motor de retenções.

@author Pedro Alencar
@since 26/01/2018
@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Static Function PegaVarMR() As Array
	Local aRet As Array
	
	aRet := {}
	If __lMotRet
		aAdd( aRet, __lPccMR )
		aAdd( aRet, __lPccBxMR )
		aAdd( aRet, __lRaRtPcc )
		aAdd( aRet, __lIrfMR )
		aAdd( aRet, __lIrfBxMR )
		aAdd( aRet, __lRaRtIrf )
		aAdd( aRet, __lIssMR )
		aAdd( aRet, __lIssBxMR )
		aAdd( aRet, __lRaRtIss )
		aAdd( aRet, __nPisCaMR )
		aAdd( aRet, __nCofCaMR )
		aAdd( aRet, __nCslCaMR )
		aAdd( aRet, __nIrfCaMR )
		aAdd( aRet, __nIssCaMR )
		aAdd( aRet, aClone( __aImpos ) )
		aAdd( aRet, __cOldMRCf )
		aAdd( aRet, __cOldMRCl )
	EndIf
Return aRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} RestVarMR()
Função para restaurar os valores das variáveis estáticas utilizadas para o motor de retenções.

@param aVarMR, vetor com a estrutura retornada pela função PegaVarMR.

@author Pedro Alencar
@since 26/01/2018
@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Static Function RestVarMR( aVarMR As Array )
	Default aVarMR := {}
	
	If __lMotRet .And. Len( aVarMR ) >= 17
		__lPccMR 	:= aVarMR[1]
		__lPccBxMR 	:= aVarMR[2]
		__lRaRtPcc 	:= aVarMR[3]
		__lIrfMR 	:= aVarMR[4]
		__lIrfBxMR 	:= aVarMR[5]
		__lRaRtIrf 	:= aVarMR[6]
		__lIssMR 	:= aVarMR[7]
		__lIssBxMR 	:= aVarMR[8]
		__lRaRtIss 	:= aVarMR[9]
		__nPisCaMR 	:= aVarMR[10]
		__nCofCaMR 	:= aVarMR[11]
		__nCslCaMR 	:= aVarMR[12]
		__nIrfCaMR 	:= aVarMR[13]
		__nIssCaMR 	:= aVarMR[14]
		__aImpos 	:= aClone( aVarMR[15] )
		__cOldMRCf 	:= aVarMR[16]
		__cOldMRCl 	:= aVarMR[17]
		
		If __lPccMR .And. ( __nCofCaMR > 0 .Or. !lCredito )
			nPis 	:= __nPisCaMR 
			nCofins := __nCofCaMR
			nCsll 	:= __nCslCaMR
		EndIf
		
		If __lIrfMR
			nIrrf := __nIrfCaMR
		EndIf
	EndIf
	
Return Nil

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F330GrvFKs()
Função para gravar a FK3 e FK4 pelo motor de retenções.

@param nRecnoSE1, Registro posicionado para a geração dos impostos
@param aImposMR, Contem as informações de impostos do motor a serem gerados
@return lRet, Indica se a gravação ocorreu sem erros

@author Rodrigo Oliveira
@since 24/04/2018
@version 12
/*/
//-----------------------------------------------------------------------------------------------------
Function F330GrvFKs( nRecnoSE1 As Numeric, aImposMR As Array ) As Logical
	Local aAreaFKs 	As Array
	Local oSubFK3 	As Object
	Local oSubFK4 	As Object
	Local cCamposE5 As Char
	Local lRet 		As Logical
	Local nX 		As Numeric
	Local oModelMov As Object
	Local cIDFK1 	As Char
	
	Default nRecnoSE1 	:= 0
	Default aImposMR 	:= {}

	aAreaFKs 	:= {}
	oSubFK3 	:= Nil
	oSubFK4 	:= Nil
	cCamposE5 	:= ""
	lRet 		:= .T.
	nX 			:= 0
	oModelMov 	:= Nil
	cIDFK1 		:= ""
	
	If nRecnoSE1 > 0	
		//Posiciona a FK1 para mandar a operação de alteração com base no registro posicionado da SE5
		If AllTrim( SE5->E5_TABORI ) == "FK1"
			aAreaFKs := GetArea()
			FK1->( dbSetOrder( 1 ) ) //FK1_FILIAL+FK1_IDFK1
			If FK1->( MsSeek( FWxFilial("FK1") + SE5->E5_IDORIG ) )
				SE1->( dbGoto( nRecnoSE1 ) )
				
				oModelMov := FWLoadModel("FINM010")
				oModelMov:SetOperation( 4 ) //Alteração
				oModelMov:Activate()
				oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5				

	   			oSubFK3 := oModelMov:GetModel("FK3DETAIL")
	   			oSubFK4 := oModelMov:GetModel("FK4DETAIL")
	   			      
	   			cIDFK1 := FWUUIDV4()
	   			
	   			//Estrutura do aImposMR
				//aImposMR[1] = codigo FKM - motor de retenção
				//aImposMR[2] = base calculado
				//aImposMR[3] = imposto calculado
				//aImposMR[4] = base retencao
				//aImposMR[5] = imposto retido
				//aImposMR[6] = cIdFK4															
				//aImposMR[8] = codigo imposto
				//aImposMR[10] = natureza
				
				cCamposE5 := "{"
				//Grava FK3 e/ou FK4
				For nX := 1 to Len( aImposMR )
					
					//Verifica se houve imposto calculado
					If aImposMR[nX][3] > 0
						
						//Se já houver uma linha de FK3 preenchida, adiciona uma nova
						If !oSubFK3:IsEmpty()
							oSubFK3:AddLine()
							//Garante que a grid estará posicionada na linha adicionada 
							oSubFK3:GoLine( oSubFK3:Length() )	
						EndIf
			
						//Grava o imposto calculado
						oSubFK3:SetValue( "FK3_IDFK3" , GetSx8Num( "FK3", "FK3_IDFK3" ) )
						oSubFK3:SetValue( "FK3_DATA"  , dDataBase )
						oSubFK3:SetValue( "FK3_ORIGEM", FunName() )
						oSubFK3:SetValue( "FK3_IMPOS" , aImposMR[nX][8] )
						oSubFK3:SetValue( "FK3_RECPAG", "R" )
						oSubFK3:SetValue( "FK3_MOEDA" , "01" )
						oSubFK3:SetValue( "FK3_VALOR" , aImposMR[nX][3] )
						oSubFK3:LoadValue( "FK3_NATURE",  aImposMR[nX][10] )
						oSubFK3:SetValue( "FK3_FILORI", SE1->E1_FILORIG  )
						oSubFK3:SetValue( "FK3_BASIMP", aImposMR[nX][2] )
						oSubFK3:SetValue( "FK3_IDORIG", cIdFK1 )
						oSubFK3:SetValue( "FK3_TABORI", "FK1" ) 						   
						oSubFK3:SetValue( "FK3_CODFKM", aImposMR[nX,1] )
						oSubFK3:SetValue( "FK3_CLIFOR", SA1->A1_COD )
						oSubFK3:SetValue( "FK3_LOJA"  , SA1->A1_LOJA )
						oSubFK3:SetValue( "FK3_CGC"   , SA1->A1_CGC )
						oSubFK3:SetValue( "FK3_RAICGC", Substr( SA1->A1_CGC, 1, 8 ) )
						
						//Grava imposto retido
						cIdFK4 := ""
						If aImposMR[nX][5] > 0 //Verifica se houve retenção
							cIdFK4 			:= GetSx8Num( "FK4", "FK4_IDFK4" )
							aImposMR[nX,6] 	:= cIdFK4
							oSubFK3:SetValue( "FK3_IDRET" , cIdFK4 )
							
							//Se já houver uma linha de FK4 preenchida, adiciona uma nova
							If !oSubFK4:IsEmpty()
								oSubFK4:AddLine()
								//Garante que a grid estará posicionada na linha adicionada
								oSubFK4:GoLine( oSubFK4:Length() )
							EndIf
		
							oSubFK4:SetValue( "FK4_IDFK4" , aImposMR[nx,6] )
							oSubFK4:SetValue( "FK4_DATA"  , dDataBase )
							oSubFK4:SetValue( "FK4_ORIGEM", FunName() )
							oSubFK4:SetValue( "FK4_IMPOS" , aImposMR[nx,8] )
							oSubFK4:SetValue( "FK4_RECPAG", "R" )
							oSubFK4:SetValue( "FK4_MOEDA" , "01" )
							oSubFK4:SetValue( "FK4_VALOR" , aImposMR[nX,5] )
							oSubFK4:LoadValue( "FK4_NATURE", aImposMR[nX][10] )
							oSubFK4:SetValue( "FK4_FILORI", SE1->E1_FILORIG )
							oSubFK4:SetValue( "FK4_BASIMP", aImposMR[nX][4] )
							oSubFK4:SetValue( "FK4_CODFKM", aImposMR[nX,1] )
							oSubFK4:SetValue( "FK4_CLIFOR", SA1->A1_COD )
							oSubFK4:SetValue( "FK4_LOJA"  , SA1->A1_LOJA )
							oSubFK4:SetValue( "FK4_CGC"   , SA1->A1_CGC )
							oSubFK4:SetValue( "FK4_RAICGC", Substr( SA1->A1_CGC, 1, 8 ) )
						
							If aImposMR[nx,8] == "PIS"
								cCamposE5 += "{'E5_VRETPIS', " + cValtoChar(nPis) + "}"
							ElseIf aImposMR[nx,8] == "COF"
								cCamposE5 += ",{'E5_VRETCOF', " + cValtoChar(nCofins) + "}"
							ElseIf aImposMR[nx,8] == "CSL"
								cCamposE5 += ",{'E5_VRETCSL', " + cValtoChar(nCsll) + "}"
							ElseIf aImposMR[nx,8] == "IRF"
								cCamposE5 += ",{'E5_VRETIRF', " + cValtoChar(nIrrf) + "}"
							EndIf
						EndIf
					EndIf
					
				Next nX
				
				//Se houver alguma informação informada no cCamposE5, então passa os dados para o model
				If cCamposE5 <> "{"
					cCamposE5 += "}"
					oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK1
				EndIf
				
				If oModelMov:VldData()
					oModelMov:CommitData()
				Else
					lRet := .F.
					cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
					cLog += cValToChar(oModelMov:GetErrorMessage()[6])
					Help( ,, "M010VALID",, cLog, 1, 0 )
	 			Endif
				oModelMov:DeActivate()
				oModelMov:Destroy()
				oModelMov := Nil
			Else //Se não achou o registro na FK1
				lRet := .F.
			Endif
			
			RestArea(aAreaFKs)
		Else //Se a origem do registro posicionado não for FK1
			lRet := .F.
		Endif
	EndIf

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA330SIT

Função para verificação do campo E1_SITUACA do titulo

@author    Francisco Oliveira
@version   12
@since     02/02/2018

@return cSituac - retorna a situação do titulo 
/*/
//-----------------------------------------------------------------------------------------------------

Static Function FA330SIT(aTitulos,nRecE1)
	Local nX
	Local aAreaE1		:= SE1->(GetArea())
	Local cLstCart		:= FN022LSTCB(1,'0007')	//Lista das situacoes de cobranca (Carteira)
	Local lRet			:= .T.
	
	Default nRecE1	:= 0
	
	If nRecE1 == 0
		For nX := 1  To Len(aTitulos)
			If MV_PAR02 == 2
				SE1->(DbGoTo(aTitulos[nX][23]))
			Else
				SE1->(DbGoTo(aTitulos[nX][20]))
			Endif
			
			If MV_PAR05 == 2 .And. !(SE1->E1_SITUACA $ cLstCart) .And. aTitulos[nX][8]
				Help(" ",1,"F330CARTE")
				lRet := .F.
				Exit
			Endif
		Next nX
	Else
		SE1->(DbGoTo(nRecE1))
		If MV_PAR05 == 2 .And. !(SE1->E1_SITUACA $ cLstCart)
			Help(" ",1,"F330CARTE")
			lRet := .F.
		Endif
	Endif
	
	RestArea(aAreaE1)
Return lRet

//--------------------------------------------------------------------------
/*/{Protheus.doc}FA330Corr
Calcula a correção monetária

@author Sivaldo Oliveira
@since  22/11/2018
@version 12
/*/
//--------------------------------------------------------------------------
Static Function FA330Corr(nBasCorr As Numeric, nVlrNF As Numeric, cTbl As Character, nTaxaMov As Numeric)
	Local nVlrCm    As Numeric 
	Local nVlrAtual As Numeric
	Local nVlrEmiss As Numeric
	Local dDtVaria  As Date
	Local dDtMov	As Date
	Local lGerCm    As Logical
	
	Default nBasCorr := 0
	Default nVlrNF   := 0
	Default cTbl     := "SE1"
	Default nTaxaMov := 0
	
	//Inicializa variáveis
	nVlrCm := 0
	dDtMov := dDataBase
	lGerCm := .T.
	
	If cPaisLoc == "BRA"
		If (cTbl)->E1_TXMOEDA > 0 .And. __lTxConP .And. nVlrNF > 0	// Se for Tx contratada x Tx contratada 
			If __lCmTxCon 							//verifica se está parametrizado para gerar VM.
				nVlrAtual := Round(xMoeda(nBasCorr, (cTbl)->E1_MOEDA, 1, dDtMov, __nCasDec, IIF((cTbl)->E1_TXMDCOR > 0, (cTbl)->E1_TXMDCOR , (cTbl)->E1_TXMOEDA)),__nCasDec)
				nVlrCm    := Round((nVlrNF - nVlrAtual), 2)
				lGerCm := .F.
			Else
				lGerCm := .F.
			EndIf
		ElseIf __lCmTxCon .And. (cTbl)->E1_TXMOEDA > 0
			lGerCm := .T.
		Else 
			lGerCm := ((cTbl)->E1_TXMOEDA == 0 .Or. (__nTxContr != 0 .And. __nTxContr != (cTbl)->E1_TXMOEDA))  
		EndIf  
	EndIf
	
	If __lCalcCM .And. lGerCm .And. (cTbl)->E1_MOEDA > 1 .And. !Empty(nBasCorr) 
		nVlrAtual := 0
		nVlrEmiss := 0
		dDtVaria  := If(Empty((cTbl)->E1_DTVARIA), (cTbl)->E1_EMISSAO, (cTbl)->E1_DTVARIA)
		
		//A variação da NF ocorre em relação a RA
		If __lCmTxCon .And. nVlrNF != 0
			nVlrAtual := xMoeda(nBasCorr, (cTbl)->E1_MOEDA, 1, dDtMov, __nCasDec, nTaxaMov)
			nVlrCm    := Round((nVlrAtual - nVlrNF), 2)
		Else //Variação ocorre em realçao a moeda do dia(SM2)
			If (cTbl)->E1_TIPO $ MVRECANT
				dDtMov := F330MovRA(Nil, cTbl, .T.)[2]
			EndIf
			
			If Empty((cTbl)->E1_DTVARIA) .And. STR(nBasCorr, 17, 2) == STR((cTbl)->E1_VALOR, 17, 2)
				nVlrEmiss := (cTbl)->E1_VLCRUZ
			Else
				If !Empty((cTbl)->E1_TXMDCOR)
					nVlrEmiss := xMoeda(nBasCorr, (cTbl)->E1_MOEDA, 1, dDtVaria, __nCasDec, (cTbl)->E1_TXMDCOR)
				Else
					If (cTbl)->E1_TIPO $ MVRECANT
						dDtVaria := dDtMov
					EndIf
					nVlrEmiss := xMoeda(nBasCorr, (cTbl)->E1_MOEDA, 1, dDtVaria, __nCasDec, (cTbl)->E1_TXMOEDA)
				EndIf
			EndIf
			
			nVlrAtual := xMoeda(nBasCorr, (cTbl)->E1_MOEDA, 1, dDtMov, __nCasDec, nTaxaMov)
			nVlrCm    := Round((nVlrAtual - nVlrEmiss), 2)
		EndIf
	EndIf
Return nVlrCm

//------------------------------
/*/{Protheus.doc} F330MoedCm
Atualiza a moeda do registro de correção monetária
@author Sivaldo Oliveira
@since 22/11/2018
@version P12
/*/
//------------------------------
Static Function F330MoedCm()
	Local aArea As Array
	
	//Inicializa variáveis.
	aArea := SE5->(GetArea())
	SE5->(DbSetOrder(2))		
	
	If SE5->(MsSeek(xFilial("SE5") + "CM" + SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)+DTOS(dDataBase)+SE1->(E1_CLIENTE+E1_LOJA)+FK1->FK1_SEQ))
		If SE5->E5_MOEDA  != "01"
			RecLock("SE5", .F.)
			SE5->E5_MOEDA   :=  "01"
			If cPaisLoc != "BRA"  //Mantenho a taxa utilizada na VM
				SE5->E5_TXMOEDA := 0
			EndIf
			SE5->(MsUnlock())
		EndIf
	EndIf
	
	RestArea(aArea)
Return Nil

//------------------------------
/*/{Protheus.doc}FA330Valor
Define os valores a serem enviado para conversão da moeda

@author Sivaldo Oliveira
@since  23/11/2018
@version 12
/*/
//------------------------------
Static Function FA330Valor(nVlr, nMoedP, nMoedD, dDtMov, nTaxaMov, lRound)
	Default nVlr     := 0
	Default nMoedP   := 0
	Default nMoedD   := 0
	Default dDtMov   := dDataBase
	Default nTaxaMov := 0
	Default lRound   := .F.
	
	If nMoedP != nMoedD .And. nVlr != 0 .And. nMoedP != 0 .And. nMoedD != 0
		If (nMoedD > 1 .And. nMoedP > 1) .And. (nMoedD <> nMoedP)
			nVlr := xMoeda(nVlr, nMoedP, nMoedD, dDtMov, __nCasDec,  nTaxaMov, __nTxMoedP)
		ElseIf (nMoedD == 1 .Or. nMoedP != 1)
			nVlr := xMoeda(nVlr, nMoedP, nMoedD, dDtMov, __nCasDec, nTaxaMov)
		Else
			nVlr := xMoeda(nVlr, nMoedP, nMoedD, dDtMov, __nCasDec, Nil, nTaxaMov)
		EndIf
	EndIf
	
	If lRound
		nVlr := Round(NoRound(nVlr, __nCasDec), 2)	
	EndIf
Return nVlr

//------------------------------
/*/{Protheus.doc}F330Static
Inicializa as variáveis estáticas.

@author Sivaldo Oliveira
@since  23/11/2018
@version 12
/*/
//------------------------------
Static Function F330Static() 
	
	__nTxMoedP 	:= 0 //Necessário limpar, pois a ultima taxa pode ser de um título de outra moeda
	__lTxConP 	:= .F.
	__lDizPer	:= .F.
	If SE1->E1_MOEDA != 1  //Tratamento para taxa contratada do título de partida
		If SE1->E1_TXMOEDA > 0  
			If SE1->E1_TXMDCOR > 0
				__nTxMoedP := SE1->E1_TXMDCOR
				__lTxConP	:= .T.
			Else
				__nTxMoedP := SE1->E1_TXMOEDA
				__lTxConP	:= .T.
			EndIf
		EndIf
	EndIf 
	
		IF mv_par14 == 2
			aTxMoedas := aClone(__aTxMoed0)
		Else
			If SE1->E1_MOEDA != 1 .And. Empty(__nTxMoedP) .And. ((lCredito .And. !__lRaTxMov) .Or. !lCredito)
				__nTxMoedP := aTxMoedas[nMoeda, 2]
			EndIf
		EndIf
	
	__nTxMoedD 	:= 0
	__nTxContr 	:= 0
	__lCmTxCon 	:= .T.
	__lCalcCM  	:= .T.
	__nPosTit  	:= 0
	__lNoTxMov 	:= .F.
	__oMovRA    := Nil
	__oMovCnb	:= Nil
	If __oHshTMrk <> Nil
		__oHshTMrk:Clean()
		__oHshTMrk	:= Nil
	EndIf
	If __aHshTMrk <> Nil
		aSize(__aHshTMrk, 0)
		__aHshTMrk	:= Nil
	EndIf
	
	If __oHNatPCC <> Nil
		__oHNatPCC:Clean()
		__oHNatPCC := Nil
	EndIf
	__oHNatPCC := tHashMap():New()
	FwFreeArray(__aNatPCC)
	__aNatPCC	:= {}

	If cPaisLoc == "BRA"
		__lCmTxCon	:= SuperGetMv("MV_CMTXCON", .F., .F.) //Gera VM para TXCANTRATADA
		__lCalcCM	:= SuperGetMv("MV_CALCCM", .F., "N") == "S"
		__lRaTxMov	:= SuperGetMv("MV_RATXMOV", .F., .T.)
	EndIf

	__nCasDec  	:= TamSx3("E1_TXMOEDA")[2]
	__aTitCalc	:= {}
	__cIdFk4IR	:= ""
	__lCmpM460  := IsInCallStack('MaIntBxCR') 
	__lGetParA  := FindFunction("GetParAuto")
	__nSldConv	:= 0
	__nTotCtb	:= 0
	If lCredito .And. ( !lRaRtImp .And. !__lRaRtIrf .And. !__lRaRtPcc )
		__nImpMR	:= 0
	EndIf
	__cToler   := ""
	__lExcImpo := IIf(__lExcImpo == Nil, FindFunction("ExcluiImpo"), __lExcImpo)	
	__lCNABImp := IIf(__lCNABImp == Nil, SuperGetMV("MV_CNABIMP", .F., .F.), __lCNABImp)
	__TpGerPix := .T.
	__lNExbMsg := .F.
	__nValVa   := 0
Return Nil

//--------------------------------------------------------------------------
/*/{Protheus.doc}F330MovRA
Verifica se o RA possui movimento bancário

@author Rodrigo Oliveira
@since  17/01/2019
@version 12
/*/
//--------------------------------------------------------------------------
Function F330MovRA(aMovRA As Array, cTbl As Character, lVerMov As Logical) As Array
Local cQry      As Character
Local cTblTmp   As Character
Local aArea     As Array
Local cCampoChq As Character
Local dDtMov	As Date 

Default aMovRA  := {.F., dDataBase, ""}
Default cTbl    := "SE2"
Default lVerMov := .T.

//Inicializa variáveis
cQry 	  := ""
cTblTmp   := ""
cCampoChq := Padr("", TamSX3("E5_NUMCHEQ")[1])
aArea     := GetArea()

If lVerMov
	If __oMovRA == Nil
		cQry := "SELECT E5_DATA, E5_TIPODOC FROM " + RetSqlName("SE5") + " "
		cQry += "WHERE E5_FILIAL = ? AND E5_PREFIXO = ? AND "
		cQry += "E5_NUMERO = ? AND E5_PARCELA = ? AND "
		cQry += "E5_TIPO = ? AND E5_CLIFOR = ? AND E5_LOJA = ? AND "
		cQry += "((E5_TIPODOC = 'RA' ) OR (E5_TIPODOC = 'BA' AND E5_NUMCHEQ <> '" + cCampoChq + "' ) OR "
		cQry += "(E5_TIPODOC = 'CH' AND E5_NUMCHEQ <> '" + cCampoChq + "')) AND "
		cQry += "E5_RECPAG = 'R' AND E5_SITUACA = ' ' AND D_E_L_E_T_ = ' ' "
		cQry := ChangeQuery(cQry)
		__oMovRA := FWPreparedStatement():New(cQry)
	EndIf

	__oMovRA:SetString(1, xFilial("SE5", (cTbl)->E1_FILORIG))
	__oMovRA:SetString(2, (cTbl)->E1_PREFIXO)
	__oMovRA:SetString(3, (cTbl)->E1_NUM)
	__oMovRA:SetString(4, (cTbl)->E1_PARCELA)
	__oMovRA:SetString(5, (cTbl)->E1_TIPO)
	__oMovRA:SetString(6, (cTbl)->E1_CLIENTE)
	__oMovRA:SetString(7, (cTbl)->E1_LOJA)

	cQry := __oMovRA:GetFixQuery()
	cTblTmp := MpSysOpenQuery(cQry)
Else
	If __oMovCnb == Nil
		cQry := "SELECT E5_DATA, E5_TIPODOC FROM " + RetSqlName("SE5") + " "
		cQry += "WHERE E5_FILIAL = ? AND E5_PREFIXO = ? AND "
		cQry += "E5_NUMERO = ? AND E5_PARCELA = ? AND "
		cQry += "E5_TIPO = ? AND E5_CLIFOR = ? AND E5_LOJA = ? AND "
		cQry += "E5_RECPAG = 'R' AND E5_SITUACA = ' ' AND D_E_L_E_T_ = ' ' "
		cQry := ChangeQuery(cQry)
		__oMovCnb := FWPreparedStatement():New(cQry)
	EndIf

	__oMovCnb:SetString(1, xFilial("SE5", (cTbl)->E1_FILORIG))
	__oMovCnb:SetString(2, (cTbl)->E1_PREFIXO)
	__oMovCnb:SetString(3, (cTbl)->E1_NUM)
	__oMovCnb:SetString(4, (cTbl)->E1_PARCELA)
	__oMovCnb:SetString(5, (cTbl)->E1_TIPO)
	__oMovCnb:SetString(6, (cTbl)->E1_CLIENTE)
	__oMovCnb:SetString(7, (cTbl)->E1_LOJA)

	cQry := __oMovCnb:GetFixQuery()
	cTblTmp := MpSysOpenQuery(cQry)
EndIf

(cTblTmp)->(DbGotop())

If (cTblTmp)->(!Eof())
	dDtMov := If(Empty((cTblTmp)->E5_DATA), dDataBase, STOD((cTblTmp)->E5_DATA))
	aMovRA := {.T., dDtMov, (cTblTmp)->E5_TIPODOC}
EndIf

(cTblTmp)->(DbCloseArea())
RestArea(aArea)

Return aMovRA

//--------------------------------------------------------------------------
/*/{Protheus.doc}VerSE5
Posiciona na baixa relativa ao título selecionado

@author Rodrigo Oliveira
@since  25/03/2019
@version 12
/*/
//--------------------------------------------------------------------------

Static Function VerSE5(cFil As Character, cTipoDoc As Character, cPrefixo As Character, cNum As Character, cParcela As Character, cTipoTit As Character, cCliente As Character, cLoja As Character, cFilOrig As Character)

Local cAliasQry	:= GetNextAlias()

BeginSql Alias cAliasQry

	Select R_E_C_N_O_ RECNO
	From %Table:SE5%	
	Where E5_FILIAL = %Exp:cFil%
	And E5_TIPODOC 	= %Exp:cTipoDoc%
	And E5_PREFIXO 	= %Exp:cPrefixo% 
	And E5_NUMERO  	= %Exp:cNum%
	And E5_PARCELA 	= %Exp:cParcela%
	And E5_TIPO 	= %Exp:cTipoTit%
	And E5_FILORIG	= %Exp:cFilOrig%
	And E5_CLIFOR	= %Exp:cCliente%
	And E5_LOJA 	= %Exp:cLoja%
	And %NotDel%

EndSql

SE5->(DbGoTo((cAliasQry)->(RECNO)))

(cAliasQry)->(DbCloseArea())

dbSelectArea("SE5")

Return Nil

//--------------------------------------------------------------------------
/*/{Protheus.doc}VerFK1
Verifica se o IDCOMP é referente ao mesmo processo de compensação

@author Rodrigo Oliveira
@since  25/03/2019
@version 12
/*/
//--------------------------------------------------------------------------

Static Function VerFK1(cSE5IdOri As Character, cIdDoc As Character) As Logical

Local lRet 		:= .T.
Local aAreaSE5	:= SE5->(GetArea())
Local cAliasQry	:= GetNextAlias()
Local aAliasFK1 := FK1->(GetArea())

BeginSql Alias cAliasQry
 
	Select FK1_IDDOC, FK1_IDCOMP
	From %Table:FK1%	
	  Where FK1_IDFK1 = %Exp:cSE5IdOri%
		And %NotDel%
EndSql

If !Empty((cAliasQry)->FK1_IDCOMP) .And. (cAliasQry)->FK1_IDCOMP != __cFk1IdOri
	lRet := .F.
EndIf

cIdDoc := (cAliasQry)->FK1_IDDOC

RestArea(aAliasFK1)
(cAliasQry)->(DbCloseArea())
RestArea(aAreaSE5)

Return lRet

//--------------------------------------------------------------------------
/*/{Protheus.doc}TitNMarc
Verificar se determinado título da rotina automática deve ser marcado ou
não.

@author Rodrigo Oliveira
@since  23/05/2019
@version 12
/*/
//--------------------------------------------------------------------------
Static Function TitNMarca(cAliasSE1 As Character) As Logical

	Local lTitNMarc As Logical
	Local nI		As Numeric
	Local nPos		As Numeric
	// Local lFlag		As Logical
	
	lTitNMarc	:= .F.
	nI			:= 0
	nPos		:= 0
	
	If ValType(aRetAuto) == 'A'
		If __aHshTMrk == Nil // __oHshTMrk == Nil
			__aHshTMrk := {}
			For nI := 1 To Len(aRetAuto[2])
				aAdd(__aHshTMrk, aRetAuto[2][nI][1] + aRetAuto[2][nI][2] + aRetAuto[2][nI][3] + aRetAuto[2][nI][4])
			Next nI
			If ( nPos	:= aScan(__aHshTMrk, (cAliasSE1)->E1_PREFIXO + (cAliasSE1)->E1_NUM + (cAliasSE1)->E1_PARCELA + (cAliasSE1)->E1_TIPO) ) == 0
				lTitNMarc := .T.
			EndIf
		Else
			If ( nPos	:= aScan(__aHshTMrk, (cAliasSE1)->E1_PREFIXO + (cAliasSE1)->E1_NUM + (cAliasSE1)->E1_PARCELA + (cAliasSE1)->E1_TIPO) ) == 0
				lTitNMarc := .T.
			EndIf
		EndIf
	EndIf

Return lTitNMarc

//-------------------------------------------------------------------
/*/{Protheus.doc}FBaseRPCC
Consiste valor base de calculo do PCC.
@author Rodrigo Oliveira
@since  28/05/2019
@version 12
/*/
//-------------------------------------------------------------------
Static Function FBaseRPCC(nValorRec As Numeric, lCalcPCC As Logical) As Numeric
	Local nValBase	As Numeric
	Local nBaseRet	As Numeric
	Local aBase 	As Array
	Local nX 		As Numeric
	Local cChaveAux As Character
	Local nBase	 	As Numeric
	Local nParc		As Numeric
	
	nValBase	:= 0
	nBaseRet	:= 0
	aBase 		:= {}
	nX 			:= 0
	cChaveAux 	:= ""
	nBase	 	:= If(SE1->E1_BASEPIS > 0, SE1->E1_BASEPIS, If(SE1->E1_BASECOF > 0, SE1->E1_BASECOF, If(SE1->E1_BASECSL > 0, SE1->E1_BASECSL, 0)))
	nParc		:= 0
	
	DEFAULT nValorRec	:= nBase
	DEFAULT lCalcPcc	:= .T.
	
	If __lMotRet .And. __lPccMR .And. nBase == 0
		cChaveAux := FWxFilial( "SE1", SE1->E1_FILORIG ) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
	
		aBase := FinImpFis(cChaveAux,SE1->E1_FILORIG,"SE1")
		For nX := 1 to Len(aBase)
			nBase := aBase[nX][2]
		Next
	Endif
	
	nParc 		:= IF(Type("nParciais") != "N", 0, nParciais)// real
	nValorRec 	:= IIF(ReadVar() == "NVALREC" .or. ReadVar() == "NVALESTRANG", nValorRec, nBase)
	nValBase 	:= nBase

	If !__lBq10925 .And. lCredito
		nParc := SE1->E1_VALOR - SE1->E1_SALDO
	EndIf

	If SE1->E1_MOEDA > 1
		nParc	:= xMoeda(nParc,nMoeda,SE1->E1_MOEDA,dDatabase,3,,nTxMoeda)
	EndIf
	
	If nParc < nValBase // Se o valor das baixas parciais nao atingiram o valor da base.
		nValBase := nValBase - nParc
		If nValorRec < nValBase
			nValBase := nValorRec
		EndIf
	Else // Se ja alcançou a base de calculo.
		nBaseRet	:= 0
		lCalcPcc	:= .F.
	EndIf
	
	nBaseRet := nValBase

Return nBaseRet

//-------------------------------------------------------------------
/*/{Protheus.doc}ValorMR
Recupera o valor de retenção do configurador de tributos do título origem
@author Renato Ito
@since  24/01/2020
@version 12
/*/
//-------------------------------------------------------------------

Static Function ValorMR()

	Local nZ		As Numeric
	Local nTotal	As Numeric
	nTotal := 0
	For nZ := 1 To Len( __aImpos )
		If !(AllTrim(__aImpos[nZ,8]) $ "PIS|COF|CSL|IRF|ISS")
			nTotal	+= __aImpos[nZ,5]
		EndIf
	Next nZ

Return nTotal

//-------------------------------------------------------------------
/*/{Protheus.doc}FBaseImp
Consiste o valor base para os impostos
@author Renato Ito
@since  24/01/2020
@version 12
/*/
//-------------------------------------------------------------------
Static Function FBaseImp(nVlBase As Numeric) As Numeric

	Local nParcVl	As Numeric
	Local nVlBaixa	As Numeric
	Local nBase		As Numeric
	Local nX		As Numeric
	Local cChaveAux	As Character
	Local aBase		As Array
	Local nValMR	As Numeric
	Local nSaldoCon As Numeric
	Local nVlBseCon As Numeric
	Local lBxTot	As Logical
	
	nValMR		:= 0
	nParcVl		:= 0 //baixas por adiantamento
	nVlBaixa    := 0 //baixas parciais
	nBase		:= 0
	nX			:= 0
	nSaldoCon   := SE1->E1_SALDO
	nVlBseCon   := nVlBase
	lBxTot		:= .T.

	If __lMotRet
		cChaveAux := FWxFilial( "SE1", SE1->E1_FILORIG ) + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
		aBase := FINCalImp( "2", SE1->E1_NATUREZ, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILORIG, SE1->E1_VALOR, dDataBase, .T., {}, SE1->E1_TIPO, cChaveAux)

		For nX := 1 to Len(aBase)
			nValMR += aBase[nX][3]
		Next
	EndIf
	
	If SE1->E1_VALOR <> SE1->E1_SALDO
		Sel070Baixa( "VL /V2 /BA /RA /CP /LJ /" + MV_CRNEG, SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, @nParcVl, /*@lBaixaAbat*/, SE1->E1_CLIENTE, SE1->E1_LOJA, @nVlBaixa)
	EndIf

	If nMoeda > 1
		nSaldoCon :=  Round(NoRound(xMoeda(SE1->E1_SALDO, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP),3),2)
		nVlBseCon :=  Round(NoRound(xMoeda(nVlBase, 1, nMoeda, dDataBase, __nCasDec, 0, __nTxMoedP),3),2)
	EndIf

	lBxTot := nSaldoCon <> nVlBseCon

	If FxIsBxTotal(nVlBase + Iif( MV_PAR08 == 1, SE1->E1_SDDECRE, 0), nParcVl + nVlBaixa , nValMR) .And. lBxTot
		nBase := SE1->E1_VALOR - ( nParcVl + nVlBaixa )
	Else
		nBase := nVlBase
	EndIf

Return nBase
//------------------------------
/*/{Protheus.doc}ProtCfgAdt
Retorna a configuração de compartilhamento das tabelas de adiantamento

@param 
@return aRet, Array
			[1,1]=Empresa - Modo de compartilhamento FIE
 			[1,2]=Unidade de Negócio - Modo de compartilhamento FIE 
			[1,3]=Filial - Modo de compartilhamento FIE
			[1,4]Existe Indice 4-Cliente na tabela FIE
			[1,5]Existe Indice 5-fornecedor na tabela FIE
			[2,1]=Empresa - Modo de compartilhamento FR3
			[2,2]=Unidade de Negócio - Modo de compartilhamento FR3
			[2,3]=Filial - Modo de compartilhamento FR3
			[2,4]Existe Indice 8-Cliente na tabela FR3
			[2,5]Existe Indice 9-Fornecedor na tabela FR3
@author Vitor Pires
@since  29/08/2019
@version 12
@type static function
/*/
//------------------------------
Static Function ProtCfgAdt() As Array 
Local aRet As Array 
aRet := {;
		{FwModeAccess('FIE',1),;
		 FwModeAccess('FIE',2),;
		 FwModeAccess('FIE',3),;
		 FWSIXUtil():ExistIndex( 'FIE', '4' ),;
		 FWSIXUtil():ExistIndex( 'FIE', '5' )},;
		{FwModeAccess('FR3',1),;
		 FwModeAccess('FR3',2),;
		 FwModeAccess('FR3',3),;
		 FWSIXUtil():ExistIndex( 'FR3' , '8' ),;
		 FWSIXUtil():ExistIndex( 'FR3' , '9' )},;
		{FwModeAccess('SE1',3),;
		 FwModeAccess('SE2',3)} }
Return (aRet)

//--------------------------------------------------------------------------
/*/{Protheus.doc}FHCliPCC
Verificar se determinado cliente do título da browse tem PCC ou não.

@author Rodrigo Oliveira
@since  11/01/2021
@version 12
/*/
//--------------------------------------------------------------------------
Static Function FHCliPCC(cFil As Character, cCli As Character, ;
	cNat As Character) As Logical

	Local lCliPCC	As Logical
	Local aAreaSA1	As Array
	Local aVal		As Array

	aVal := {}
	
	If SE1->E1_TIPO $ MV_CRNEG
		lCliPCC := .F.
	Else
		lCliPCC	:= HMGet(__oHNatPCC, cFil + cNat,aVal)

		If lCliPCC
			aAreaSA1	:= SA1->(GetArea())
			
			DbSelectArea("SA1")
			DbSetOrder(1)
			If SA1->(DbSeek(FwxFilial("SA1", cFil) + cCli) )
				lCliPCC := (SA1->A1_PESSOA == 'J' .And. ( SA1->A1_RECCOFI == 'S' .Or. SA1->A1_RECCSLL == 'S' .Or. SA1->A1_RECPIS == 'S' ) )
			EndIf
			RestArea(aAreaSA1)
		EndIf
	EndIf

	If !lCliPCC
		__aTitCalc	:= {}
		nPis := nCofins := nCsll := 0
		nPisBaseC := nCofBaseC 	:= nCslBaseC :=	0 
		nPisBaseR := nCofBaseR	:= nCslBaseR := 0
		nPisCalc  := nCofCalc	:= nCslCalc	:= 0
	EndIf

Return lCliPCC

//--------------------------------------------------------------------------
/*/{Protheus.doc}FNatPCC
Verificar se determinada natureza do título da browse tem PCC ou não.

@author Rodrigo Oliveira
@since  11/01/2021
@version 12
/*/
//--------------------------------------------------------------------------
Static Function FNatPCC(cFil As Character, cNat As Character) As Logical

	Local lNatPCC	As Logical
	Local aAreaSED	As Array
	
	lNatPCC	:= .F.
	
	aAreaSED	:= SED->(GetArea())
	
	DbSelectArea("SED")
	DbSetOrder(1)
	If SED->(DbSeek(FwxFilial("SED", cFil) + cNat) )
		lNatPCC := (SED->ED_CALCPIS == 'S' .Or. SED->ED_CALCCOF == 'S' .Or. SED->ED_CALCCSL == 'S' )
	EndIf
	If lNatPCC .And. !(SE1->E1_TIPO $ MV_CRNEG) .And. !lCredito
		If ( aScan(__aNatPCC, { |x| x[1] = SE1->E1_FILORIG + SE1->E1_NATUREZ } )) == 0
			aAdd(__aNatPCC, {SE1->E1_FILORIG + SE1->E1_NATUREZ})
		EndIf
	EndIf

	RestArea(aAreaSED)

Return lNatPCC

//--------------------------------------------------------------------------
/*/{Protheus.doc}AjustBsIRF
Função que ajusta a base real do IR retido

@author Rodrigo Oliveira
@since  16/03/2021
@version 12
/*/
//--------------------------------------------------------------------------
Function AjustBsIRF(cIdFK4)

Local cAlias 	As Character
Local aArea 	As Array
Local aAreaFK4 	As Array
Local nBaseIr	As Numeric

aArea		:= GetArea()
aAreaFK4	:= FK4->(GetArea())
cAlias 		:= GetNextAlias()

BeginSql Alias cAlias
	Select Sum(FK3_BASIMP) As BASEIR
	From %Table:FK3% FK3
	Where FK3_IDRET = %Exp:cIdFK4%
		And FK3_IMPOS = 'IRF'
		And FK3.%NotDel%
EndSql

If !(cAlias)->(Eof())
	nBaseIr := (cAlias)->BASEIR
EndIf

FK4->(DbSetOrder(1))
If FK4->(DbSeek(xFilial("FK4") + cIdFK4) ) .And. nBaseIr > 0
	RecLock("FK4")
	FK4->FK4_BASIMP := nBaseIr
	MsUnlock()
EndIf

(cAlias)->(DbCloseArea())
RestArea(aAreaFK4)
RestArea(aArea)

Return

//--------------------------------------------------------------------------
/*/{Protheus.doc}AjustBsPCC
Função que ajusta a base real do IR retido

@author Pequim
@since  22/09/2021
@version 12
/*/
//--------------------------------------------------------------------------
Function AjustBsPCC(aImpostos)

Local cAliasQry	As Character
Local aArea 	As Array
Local aAreaFK4 	As Array
Local nBaseRet	As Numeric
Local nX		As Numeric

aArea		:= GetArea()
aAreaFK4	:= FK4->(GetArea())
cAliasQry	:= ""
nBaseRet	:= 0
nX			:= 0

For nX := 1 to Len(aImpostos)

	If !Empty(aImpostos[nX,4])

		If __oPccBsRt == Nil
			cQuery := "SELECT Sum(FK3_BASIMP) As BASEIMP "
			cQuery += "FROM " + RetSqlName( "FK3" ) + " FK3 "
			cQuery += "WHERE "
			cQuery += "FK3.FK3_IDRET = ? "
			cQuery += "AND FK3.FK3_IMPOS = ? "
			cQuery += "AND FK3.D_E_L_E_T_ = ' ' "
			cQuery := ChangeQuery( cQuery )
			__oPccBsRt := FWPreparedStatement():New(cQuery)
		EndIf
		
		__oPccBsRt:SetString(1, aImpostos[nX,4] )	//FK4_IDRET
		__oPccBsRt:SetString(2, aImpostos[nX,1] )	//FK4_IMPOS

		cQuery := __oPccBsRt:GetFixQuery()
		cAliasQry := mpsysopenquery(cQuery)

		If !(cAliasQry)->(Eof())
			nBaseImp := (cAliasQry)->BASEIMP 
		EndIf

		FK4->(DbSetOrder(1))
		If FK4->(DbSeek(xFilial("FK4") + aImpostos[nX,4]) ) .And. nBaseImp > 0
			RecLock("FK4")
			FK4->FK4_BASIMP := nBaseImp
			MsUnlock()
		EndIf

		(cAliasQry)->(DbCloseArea())
	Endif
Next

RestArea(aAreaFK4)
RestArea(aArea)

Return

//--------------------------------------------------------------------------
/*/{Protheus.doc} FVlDiz
Função que ajusta o valor da baixa quanto a dizima periódica

@author totvs
@since  16/03/2021
@version 12
/*/
//--------------------------------------------------------------------------
Static Function FVlDiz(nValSel, nIt, nValBx)
	Local nVlRet	:= 0
	Local nTAbatim	:= 0
	Local nValVA	:= 0

	If mv_par02 == 1
		nValVa	:= Fa330VTit(aTitulos[nIt,If(__lMotRet,28,27)])
	Else
		nValVa	:= Fa330VTit(aTitulos[nIt,If(__lMotRet,31,30)])
	EndIf

	nTAbatim 	:= SumAbatRec(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_MOEDA,"S",dBaixa ) // ,,@nTotIrAbt,@nTotCsAbt,@nTotPisAbt,@nTotCofAbt)

	nVlRet 		:= xMoeda(SE1->E1_SALDO - nDescD + SE1->E1_SDACRES - SE1->E1_SDDECRE + nValVa - __nImpMR - nTAbatim,SE1->E1_MOEDA,nMoeda,,5, __nTxMoedP,Fa330Tx2(nMoeda,nTxMoeda))
	
	If nValSel == NoRound(nVlRet, 2)
		nValBx				:= nVlRet
		aTitulos[nIt, 9] 	:= nVlRet
	Else
		nVlRet	:= nValSel
	EndIf

Return nVlRet

/*/{Protheus.doc} Fa330TitEx
Funcao responsavel por retornar a funcao Fa330Tit externamente devido a filtros utlizados por localizacao 
Function responsible for returning the Fa330Tit function externally due to filters used by location
@type function
@version  P12
@author eduardo.Flima
@since 6/16/2021
@param dExEmiss, date, Emission Date
@param cExOrig, character, origin function of the compensation
@param lExCredi, logical, If it is a credit
@param aExNum, array, Layout Number
@param lExAutoma, logical, If it is automation
@param cNCnt, character, Numeber of the contract
@return aTitulos_array, list with bills avaliable for compensation
/*/
Function Fa330TitEx(dExEmiss,cExOrig,lExCredi,aExNum,lExAutoma,cNCnt)
	Local aTitulos as Array

	Default cNCnt := ""

	If !empty(cNCnt)
		cNumCont:=cNCnt
	Endif 

	aTitulos := {}
	aTitulos := Fa330Tit(dExEmiss,cExOrig,lExCredi,aExNum,lExAutoma)	

Return aTitulos


/*/{Protheus.doc} getDesc
@description Verifica se será aplicado desconto financeiro na baixa por compensação
@type function
@version 12.1.33
@author guilherme.sordi
@since 06/05/2022
@param nValor, numeric, valor da baixa
@return nDesc, numeric, valor do desconto
/*/
static function getDesc(nValor as numeric) as numeric
	local nDesc as Numeric
	local dDtBaixa as date
	local nMoeda as Numeric

	nDesc := 0
	dDtBaixa := dDataBase
	nMoeda := SE1->E1_MOEDA

	If lF330DESC 
		if ExecBlock("F330DESC",.F.,.F.)			
			nDesc := FaDescFin("SE1",dDtBaixa,nValor,nMoeda,/*lVerBxado*/,/*lTemGEM*/)
		endIf
	EndIf

	//nDesc:= IIf(SE1->E1_DESCFIN > 0 .And. SE1->E1_VENCREA-dBaixa >= SE1->E1_DIADESC .and. SE1->E1_DESCONT == 0,SE1->E1_VALOR * (SE1->E1_DESCFIN/100),0)
return nDesc

/*/{Protheus.doc} usaAbat
	@description Verifica se a compensação foi realizada considerando abatimento.
	@type  Static Function
	@author guilhermed.santos
	@since 04/08/2022
	@version 12.1.33
	@param nReg, numeric, RECNO do título de partida no estorno
	@return lRet, logical, Retorna .T. se a compensação foi realizada com abatimento
/*/
Static Function usaAbat(nReg as Numeric) as Logical
	Local aAreaSE1 as Array
	Local aAreaFK6 as Array
	Local aAreaFK1 as Array
	Local cChave as Character
	Local cFK1RA as Character
	Local cIdDocNF as Character
	Local nVlrCmp as Numeric
	Local lRet	as Logical
	
	aAreaSE1	:= SE1->(GetArea())
	aAreaFK6	:= FK6->(GetArea())
	aAreaFK1	:= FK1->(GetArea())
	cChave 		:= ''
	cFK1RA		:= ''
	cIdDocNF	:= ''
	nVlrCmp		:= 0
	lRet		:= .F.

	If lCredito		
		cChave := SE1->E1_FILIAL + "|" +  SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" +SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
		cIdDocNF := FinBuscaFK7(cChave,"SE1")
	Else
		SE1->(DbGoTo(nReg))
		cChave := SE1->E1_FILIAL + "|" +  SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" +SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
		cIdDocNF := FinBuscaFK7(cChave,"SE1")
	EndIf

	If SE1->E1_SALDO == 0
		DbSelectArea("FK1")
		FK1->(DbSetOrder(5)) //FK1_IDDOC+FK1_SEQ
		FK6->(DbSetOrder(2)) //FK6_FILIAL+FK6_IDORIG+FK6_TABORI+FK6_IDFK6
		FK1->(DbSeek(cIdDocNF))
		While !EOF() .and. FK1->FK1_IDDOC == cIdDocNF
			If FK1->FK1_RECPAG = 'R'
				nVlrCmp += FK1->FK1_VALOR
			Else
				nVlrCmp -= FK1->FK1_VALOR
			EndIf
			If FK6->(DbSeek(FK1->FK1_FILIAL+FK1->FK1_IDFK1+"FK1"))
				While !FK6->(EOF()) .and. FK6->FK6_FILIAL+FK6->FK6_IDORIG+FK6->FK6_TABORI == FK1->FK1_FILIAL+FK1->FK1_IDFK1+"FK1"
					If FK6->FK6_RECPAG = 'R'
						If FK6->FK6_TPDOC $ 'DC/VA'
							nVlrCmp += FK6->FK6_VALMOV
						ElseIf FK6->FK6_TPDOC == 'JR'
							nVlrCmp -= FK6->FK6_VALMOV
						EndIf
					EndIf
					FK6->(dbSkip())
				EndDo
			EndIf
			FK1->(dbSkip())
		EndDo

		lRet := SE1->E1_VALOR > nVlrCmp
	EndIf

	RestArea(aAreaSE1)
	RestArea(aAreaFK6)
	RestArea(aAreaFK1)
Return lRet

/*/{Protheus.doc} TipoGerPix
    Valida se um determinado tipo de título
    pode gerar registro no monitor pix

    @author Sivaldo Oliveira
    @since 30/06/2022
    @return lRet, Logical, retorna verdadeiro (.T.) ou falso (.F.),
    (.T.) = Pode gerar registro no monitor pix
    (.F.) = Não pode gerar no monitor pix
/*/
Static Function TipoGerPix(cTipoTit As Char) As Logical
    Local lRet   As Logical
    Local cLista As Char
    
    Default cTipoTit := ""
    
    If (lRet   := !Empty(cTipoTit))
        cLista := MVABATIM+"|"+MV_CRNEG+"|"+MVTXA+"|"+MV_CPNEG+"|"+MVPROVIS+"|"+MVINSS+"|"+MVPAGANT
        cLista += "|"+MVISS+"|"+MVIRF+"|"+MVRECANT+"|TX |SES|CID|INA|PIS|CSL|COF"
        
        lRet := !cTipoTit $ cLista 
    EndIf	

Return lRet	

/*/{Protheus.doc} ExcImpoPix
	Valida se o título está em situação de cobrança
	pix, para que seja excluído os impostos destacados
	na geração da remessa de cobrança/integração PIX
	
	@author Sivaldo Oliveira
	@since 21/06/2022
	@version P12
	
	@Param nRecnoSE1, Numeric, Recno do cadastro do título
	@Return lRetorno, Logical, Retorna um Verdadeiro ou Falso que indica se o 
	usuário confirmou ou não a marcação/seleção do título
/*/
Static Function ExcImpoPix(nRecnoSE1 As Numeric) As Logical
	Local lRetorno   As Logical
	Local lTemImpPix As Logical
	Local aAreaAtual As Array
	Local aAreaSE1   As Array
	
	Default nRecnoSE1 := 0
	
	//Inicializa variáveis
	lRetorno   := .T.
	lTemImpPix := .F.	
	
	If nRecnoSE1 > 0 .And. cPaisLoc == "BRA" .And. __lExcImpo .And. !__lCNABImp .And. __TpGerPix
		aAreaAtual := GetArea()
		aAreaSE1   := SE1->(GetArea())
		SE1->(DbGoto(nRecnoSE1))
		
		If SE1->E1_SITUACA != "0" .And. TtBxImpPix(nRecnoSE1)
			lTemImpPix := !BorderoImp(SE1->E1_FILORIG, SE1->E1_NUMBOR, "R", SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA)
			
			If lTemImpPix
				nRecnoF71 := F71Ativa(nRecnoSE1)
				
				If nRecnoF71 > 0
					lRetorno := IIf(l330Auto, __lMaTiPix, MsgTtBxPix(.F., .F., .F., .F.))						
					
					If lRetorno
						ExcluiImpo(SE1->E1_FILIAL, SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA, nRecnoF71)
						cIdDocFK7 := FINBuscaFK7(xFilial("SE1", SE1->E1_FILORIG)+"|"+SE1->E1_PREFIXO+"|"+SE1->E1_NUM+"|"+SE1->E1_PARCELA+"|"+SE1->E1_TIPO+"|"+SE1->E1_CLIENTE+"|"+SE1->E1_LOJA, "SE1", SE1->E1_FILORIG)					
						PIXCancel(SE1->E1_FILIAL, cIdDocFK7) 								
					EndIf
				EndIf
			EndIf
		EndIf
		
		RestArea(aAreaSE1)		
		RestArea(aAreaAtual)
		FwFreeArray(aAreaSE1)
		FwFreeArray(aAreaAtual)		
	EndIf
Return lRetorno

/*/{Protheus.doc} F71Ativa
	Verifica se há registro monitor pix
	ativo, e retorna o recno do registro
	
	@author Sivaldo Oliveira
	@since 01/07/2022
	@Param nRecnoSE1, Numeric, Recno do cadastro do título
	@return nRecnoF71, numeric, Renco do registro ativo no 
	monitor pix (F71)
/*/
Static Function F71Ativa(nRecnoSE1 As Numeric) As Numeric
	Local cChaveF71  As Char	
	Local nRecnoF71  As Numeric
	Local aAreaAtual As Array
	Local aAreaSE1   As Array
	
	Default nRecnoSE1 := 0
	
	//Inicializa variáveis
	cChaveF71 := ""
	nRecnoF71 := 0
	
	If nRecnoSE1 > 0
		aAreaAtual := GetArea()
		aAreaSE1   := SE1->(GetArea())
		DbSelectArea("F71")
		SE1->(DbGoto(nRecnoSE1))
		
		F71->(DbSetOrder(2))
		If F71->(DbSeek(SE1->(E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA)))
			cChaveF71 := F71->(F71_FILIAL+F71_IDDOC) 
			
			While F71->(F71_FILIAL+F71_IDDOC) == cChaveF71
				If F71->F71_STATUS $ "1|5|6|7|8"
					F71->(DbSkip())
					Loop
				EndIf
				
				nRecnoF71 := F71->(Recno())
				Exit
			EndDo			
		EndIf
		
		RestArea(aAreaSE1)
		RestArea(aAreaAtual)
		FwFreeArray(aAreaSE1)
		FwFreeArray(aAreaAtual)
	EndIf	
Return nRecnoF71

//-------------------------------------------------------------------
/*/{Protheus.doc}FA330Msg

Valida se o valor a ser compensado é superior ao valor do Valor Acessório. 
lHelp quando passada como .T. irá mostrar o Help na tela.

@author Vinicius Nascimento
@since  23/09/2022
@version 12
/*/
//-------------------------------------------------------------------

Static Function FA330Msg(lHelp as Logical, nValVa as Numeric, nAcresc as Numeric) as Logical
	Local lRet as Logical
	Local nValor as Numeric

	Default nAcresc 	:= 0
	Default nValVa 		:= 0

	nValor := If(FwIsInCallStack("FA330TROCA"),cValor,If(!lCredito,SE1->E1_SALDO,nSaldo)) 
	lRet := .T.

	If nValVa > 0 
	   	If (nAcresc + nValVa) > nValor 
	   	  	If lHelp
			   Help(" ",1,"CMPMENORQVA",,STR0139,1,0,,,,,,{STR0140}) //O valor efetivamente compensado é menor que os Valores Acessórios, "Por favor, ajuste o valor Compensado.
			Endif
			lRet := .F.
		Endif
	Endif

Return lRet
