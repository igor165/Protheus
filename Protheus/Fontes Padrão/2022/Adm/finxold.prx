#INCLUDE "PROTHEUS.CH"
#INCLUDE "finxold.ch"

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINXOLD

Funções sem chamadas em fontes ou SX3. Serão mantidas por legado ou configurações CNAB.

NÃO UTILIZAR PARA NOVOS PROCESSOS

@version 12
@since   11/12/2014

/*/
//-----------------------------------------------------------------------------------------------------

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±                                                                         ±±
±±            Funcoes retiradas do arquivo FINXATU.PRX                     ±±
±±                                                                         ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

//-------------------------------------------------------------------
/*/{Protheus.doc} FA070MOSTR

Carrega pergunte do FINA070.

Arquivo original: FINXATU.PRX

@author Wagner Xavier
@since 06/05/1992
/*/
//-------------------------------------------------------------------
Function Fa070Mostr()
pergunte("FIN070",.T.)
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} CPERG070

Carrega pergunte do FINA070.
Arquivo original: FINXATU.PRX

@author Wagner Xavier
@since 26/05/1992
/*/
//-------------------------------------------------------------------
Function cPerg070()
Pergunte("FIN070",.t.)
Return .t.

//-------------------------------------------------------------------
/*/{Protheus.doc} FA170NAT

Verifica se a natureza foi cadastrada, se nao, cria. (Empréstimos) 
(não encontrada chamada em fontes ou SX3)

Arquivo original: FINXATU.PRX

@author Pilar S. Albaladejo
@since 11/01/1996
/*/
//-------------------------------------------------------------------
Function Fa170Nat(cNat,cTipo,cFonte)

Local cAlias:= Alias()

dbSelectArea("SED")

If !dbSeek(xFilial("SED")+cNat) .And. !Empty(cNat)
	RecLock("SED",.T.)
	Replace ED_FILIAL 	With xFilial("SED")
	Replace ED_CODIGO		With cNat
	If cTipo == "EMP"
		If cFonte=="FINA170"
			Replace ED_DESCRIC	With STR0001 //"NATUREZA EMPRESTIMOS"
		Else
			Replace ED_DESCRIC	With STR0002 //"NATUREZA PAGTO. EMPRESTIMOS"
		Endif
	Else
		If cFonte=="FINA170"
			Replace ED_DESCRIC	With STR0003 //"NATUREZA APLICACOES"
		Else
			Replace ED_DESCRIC	With STR0004 //"NATUREZA RESGATE APLICACOES"
		Endif
	EndIF	
	Replace ED_CALCIRF	With "N"
	Replace ED_CALCISS	With "N"
	Replace ED_PERCIRF	With 0
	Replace ED_CALCINS	With "N"
	Replace ED_CALCCOF	With "N"
	Replace ED_CALCCSL	With "N"
	Replace ED_CALCPIS	With "N"
	Replace ED_TIPO		With "2"
	MsUnlock()
EndIf
dbSelectArea(cAlias)
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A040MANSE1

Gera titulo de contas a receber, a partir de parametros Usando Rotina 
automatica (FINA040).
Arquivo original: FINXATU.PRX

 
@deprecated Não recomendamos o uso desta função e nem damos manutenção.


@param nOpcao - Opcao que sera executada
@param cNumero - Numero do titulo a ser gerado
@param cPrefixo - Prefixo do titulo
@param cTipotit - Tipo do titulo
@param cParcela - Parcela do titulo (usado em alteracao/exclusao)
@param nValTitulo - valor do titulo a ser gerado
@param cCodCli - codigo do cliente
@param cLoja - loja do cliente
@param cNatureza - Natureza do titulo
@param nMoedTit - numero da moeda do titulo
@param cCodPraz - condicao de pagamento
@param cOrigem - nome do programa origem
@param dEmissao - Data de emissao do titulo (base calculo dias)
@param dVenc Data de vencimento, usada caso condicao de pagamento nao for passada (assumira um vencimento)
@param cHistorico
@param aCompleG - Matriz com bloco de codigo p/ complentar gravacao

@author Wagner Mobile Costa
@since 20/09/2001
/*/
//-------------------------------------------------------------------
Function A040ManSe1(nOpcao, cNumero, cPrefixo, cTipoTit, cParcela, nValTitulo,;
cCodCli, cLoja, cNatureza, nMoedTit, cCodPraz,;
cOrigem,dEmissao, cHistorico, dVenc, aCompleG)

Local nParcela, nIndice, nParcelas, aVenc := {}, aGrvSe1 := {}, nCompleG
Local aGravar := Array(0)
Private lMsErroAuto := .F., lInclusao

DEFAULT nOpcao := 3

If (lInclusao := (nOpcao = 3))
	cNumero    	:= If(cNumero = Nil, GetSxENum("SE1", "E1_NUM"), cNumero)
	cPrefixo   	:= If(cPrefixo = Nil, Space(3), cPrefixo)
	cTipoTit	:= If(cTipoTit = Nil, "DP", cTipoTit)
Else
	cNumero    	:= If(cNumero = Nil, SE1->E1_NUM, cNumero)
	cPrefixo   	:= If(cPrefixo = Nil, SE1->E1_PREFIXO, cPrefixo)
	cTipoTit	:= If(cTipoTit = Nil, SE1->E1_TIPO, cTipoTit)
Endif

cParcela	:= If(cParcela = Nil, SE1->E1_PARCELA, cParcela)
cCodCli 	:= If(cCodCli = Nil, SE1->E1_CLIENTE, cCodCli)
cLoja   	:= If(cLoja = Nil, SE1->E1_LOJA, cLoja)
cNatureza	:= If(cNatureza = Nil, SE1->E1_NATUREZ, cNatureza)
cOrigem		:= IF(cOrigem = Nil, Space(0), cOrigem)
dEmissao	:= If(dEmissao = Nil, dDataBase, dEmissao)
cHistorico 	:= If(cHistorico = Nil, Space(0), cHistorico)
nParcela	:= If(lInclusao, 1, Val(cParcela))

If lInclusao
	If cCodPraz # Nil
		aVenc := Condicao(nValTitulo,cCodPraz,,dEmissao)
	ElseIf ValType(dVenc) = "D"
		aVenc := { { dVenc, nValTitulo } }
	Endif
Endif	

SA1 -> ( MsSeek( xFilial("SA1") + cCodCli + cLoja ) )

nIndice 	:= nParcela
nParcelas	:= If(lInclusao, Len(aVenc), nIndice)

For nParcela := nIndice To nParcelas
	
	If ! lInclusao				
		SE1->(DbSetOrder(1))
		SE1->(MsSeek(xFilial("SE1") + cPrefixo + cNumero + Str(nParcela, 1)))
	Endif
	
	aGravar := Array(0)
	Aadd(aGravar, If(lInclusao, SA1->A1_BCO1         			, SE1->E1_PORTADO))
	Aadd(aGravar, If(lInclusao, aVenc[nParcela][1]			, SE1->E1_VENCTO))
	Aadd(aGravar, If(lInclusao, DataValida(aVenc[nParcela][1]), SE1->E1_VENCREA))
	Aadd(aGravar, If(lInclusao, aVenc[nParcela][2]            , SE1->E1_VALOR))
	Aadd(aGravar, If(lInclusao, aVenc[nParcela][2]           	, SE1->E1_SALDO))
	Aadd(aGravar, If(lInclusao, Iif(ValType(nMoedTit)=="N",nMoedTit,Val(nMoedTit)),;
	SE1->E1_MOEDA))
	Aadd(aGravar, If(lInclusao, xMoeda((aVenc[nParcela][2]),nMoedTit,1,;
	dEmissao), SE1->E1_VLCRUZ) )
	
	aGrvSe1 := { 	{ "E1_FILIAL"	, xFilial("SE1") 	, Nil },;
	{ "E1_PREFIXO"	, cPrefixo 			, Nil },;
	{ "E1_NUM"		, cNumero			, Nil },;
	{ "E1_PARCELA"	, Str(nParcela, 1) , Nil },;
	{ "E1_TIPO"		, cTipoTit			, Nil },;
	{ "E1_NATUREZ"	, cNatureza 		, Nil },;
	{ "E1_PORTADO"	, aGravar[1]   		, Nil },;
	{ "E1_CLIENTE"	, cCodCli  			, Nil },;
	{ "E1_LOJA"   	, cLoja   			, Nil },;
	{ "E1_NOMCLI"	, SA1->A1_NREDUZ 	, Nil },;
	{ "E1_EMISSAO"	, dEmissao			, Nil },;
	{ "E1_VENCTO"	, aGravar[2]		, Nil },;
	{ "E1_VENCREA"	, aGravar[3]		, Nil },;
	{ "E1_VALOR"  	, aGravar[4]		, Nil },;
	{ "E1_SALDO"  	, aGravar[5]		, Nil },;
	{ "E1_MOEDA"	, aGravar[6]		, Nil },;
	{ "E1_VLCRUZ" 	, aGravar[7] 		, Nil },;
	{ "E1_HIST"   	, cHistorico		, Nil },;
	{ "E1_ORIGEM" 	, cOrigem   		, Nil } }
	If cCodPraz # Nil
		Aadd(aGrvSe1, { "E1_PORCJUR", SE4->E4_ACRSFIN, Nil  })
	Endif
	If aCompleG # Nil
		For nCompleG := 1 To Len(aCompleG)
			Aadd(aGrvSe1, { aCompleG[nCompleG][1], Eval(aCompleG[nCompleG][2]),Nil })
		Next
	Endif
	MsExecAuto({ | x,y | Fina040(x,y) }, aGrvSe1, nOpcao)
	If lMsErroAuto
		Help(" ", 1, "ERROGERACR")
		Exit
	Endif
Next		

cNumero := StrZero(Val(cNumero)+1,6)

Return ! lMsErroAuto




/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±                                                                         ±±
±±            Funcoes retiradas do arquivo FINXFUN.PRX                     ±±
±±                                                                         ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

//-------------------------------------------------------------------
/*/{Protheus.doc} FA390F3

Ativa e direciona a tecla F3 de acordo com o campo editado.

Arquivo original: FINXFUN.PRX

@author Vinicius Barreira
@since 16/03/1995
/*/
//-------------------------------------------------------------------
Function fa390F3( cArq )
If cArq == Nil
	Set Key K_F3 To
Else
	SetKey( K_F3, {|a,b,c| ConPad1(a,b,c,cArq)} )
End
Return (.T.)


//-------------------------------------------------------------------
/*/{Protheus.doc} CALCABAT

Calcula Abatimentos de Titulo.

Arquivo original: FINXFUN.PRX

@author Antonio Maniero Jr.
@since 28/06/1994
/*/
//-------------------------------------------------------------------
Function CalcAbat(cPrefixo,cNumero,cParcela,nMoeda,cModo,cFornCli)
LOCAL nRegistro    := 0
LOCAL nAbatimentos := 0
LOCAL cArea        := Alias ()
LOCAL nOrdem
Private cArquivo   := ""
If cModo == "P"
	cFornCli := Iif(cFornCli == NIL,SE2->E2_FORNECE,cFornCli )
Else
	cFornCli := Iif(cFornCli == NIL,SE1->E1_CLIENTE,cFornCli )
End

// Quando eh chamada do Excel, estas variaveis estao em branco
IF Empty(MVABATIM)
	CriaTipos()
Endif
nMoeda:=IIF(nMoeda==NIL,1,nMoeda)
If cModo=="R"
	dbSelectArea("SE1")
	cArquivo  := "E1"
	nRegistro := SE1->(Recno())
Else
	dbSelectArea("SE2")
	cArquivo  := "E2"
	nRegistro := SE2->(Recno())
End
nOrdem:=IndexOrd()
dbSetOrder(1)
dbSeek(cFilial+cPrefixo+cNumero+cParcela)

While &cArquivo._FILIAL  == cFilial  .and. ;
		&cArquivo._PREFIXO == cPrefixo   .and. ;
		&cArquivo._NUM     == cNumero    .and. ;
		&cArquivo._PARCELA == cParcela

	If !(&cArquivo._TIPO $ MVABATIM) .or.  ;
			&cArquivo._EMISSAO > dDataBase   .or.  ;
			Empty(&cArquivo._BAIXA)          .and. ;
			&cArquivo._BAIXA <= dDataBase    .and. ;
			&cArquivo._SALDO == 0
	Else
		If cModo == "P"
			If SE2->E2_FORNECE == cFornCli
				nAbatimentos+=Moeda(&cArquivo._VALOR,nMoeda,cModo)
			Endif
		Else
			If SE1->E1_CLIENTE == cFornCli
				nAbatimentos+=Moeda(&cArquivo._VALOR,nMoeda,cModo)
			Endif
		Endif
	End
	dbSkip()
End
dbGoto(nRegistro)
dbSetOrder(nOrdem)
dbSelectArea(cArea)
Return(nAbatimentos)


//-------------------------------------------------------------------
/*/{Protheus.doc} FA050FUNSK

Funcao chamada do fa050Skip para fazer pulo do Tbrowse.

Arquivo original: FINXFUN.PRX

@param nPula - número de pulos para cima ou para baixo.

@author Wagner Xavier
@since 21/101/1992
/*/
//-------------------------------------------------------------------
Function fa050FunSk(nPula)
LOCAL nCnt := 0

If nPula > 0
	While nCnt < nPula
		nPosBco++
		dbSkip()
		If Eof() .Or. E2_FILIAL != xFilial("SE2") .Or. E2_SALDO != E2_VALOR
			nPosBco--
			dbSkip(-1)
			Exit
		EndIf
		nCnt++
	EndDo
Else
	While nCnt > nPula
		nPosBco--
		dbSkip(-1)
		If Bof()
			nPosBco++
			Exit
		ElseIf E2_FILIAL != xFilial("SE2") .Or. E2_SALDO != E2_VALOR
			nPosBco++
			dbSkip()
			Exit
		Endif
		nCnt--
	EndDo
EndIf
Return nCnt


//-------------------------------------------------------------------
/*/{Protheus.doc} BUSCATXS

Funcao que retorna uma matriz com os titulos TXs de IRRF gerados  a 
partir do titulo principal.

Arquivo original: FINXFUN.PRX

@param cPrefixo - Prefixo do título principal
@param cNum - Número do título principal
@param cParcela - Parcela do título principal
@param cParcIRF - Parcela referente ao título de IRRF

@author João Gonçalves de Oliveira
@since 01/10/2008
/*/
//-------------------------------------------------------------------
Function BuscaTxs(cPrefixo,cNum,cParcela,cParcIRF)

LOCAL aArea     := GetArea()
LOCAL aTituTxs  := {}
Default cParcIRF := ""

// Seleciono SE2 com outro alias para efetuar a varredura dos impostos
If Select("__SE2") == 0
	ChkFile("SE2",.F.,"__SE2")
Else
	DbSelectArea("__SE2")
	DbGoTop()
EndIf

dbSetOrder(1)

// Caso a parcela do IRRF nao esteja em branco, busco pelo TX para carregar o array.
If !Empty(cParcIRF)
	If (dbSeek(xFilial("SE2") + cPrefixo + cNum + cParcIRF + MVTAXA))
		Aadd(aTituTXs,{E2_PREFIXO,E2_NUM,E2_PARCELA,E2_TIPO,E2_NATUREZ,E2_VALOR,E2_SALDO,E2_CODRET})
	Endif
Endif

RestArea(aArea)

Return aTituTXS


//-------------------------------------------------------------------
/*/{Protheus.doc} BUSCATXS

Imprime abatimentos de t¡tulos vencidos ou a vencer, seguido pelo 
total ( valor do t¡tulo - abatimentos ).

Arquivo original: FINXFUN.PRX

@author Luis C. Cunha
@since 17/08/1993
/*/
//-------------------------------------------------------------------
Function Abatimentos(cPrefixo,cNumero,cParcela,cFornecedor,nValor,nMoeda,nColuna,cModo)
LOCAL nRegistro    := 0
LOCAL nAbatimentos := 0
LOCAL cArea        := Alias ()
LOCAL nOrdem
LOCAL nDesconto := 0
Private cArquivo:= ""
nMoeda:=IIF(nMoeda==NIL,1,nMoeda)

If cModo=="R"
	dbSelectArea("SE1")
	cArquivo  := "E1"
	nRegistro := SE1->(Recno())
Else
	dbSelectArea("SE2")
	cArquivo  := "E2"
	nRegistro := SE2->(Recno())
End
nOrdem:=IndexOrd()
dbSetOrder(1)
dbSeek(cFilial+cPrefixo+cNumero+cParcela)
While &cArquivo._FILIAL  == cFilial  .and. ;
		&cArquivo._PREFIXO == cPrefixo .and. ;
		&cArquivo._NUM     == cNumero  .and. ;
		&cArquivo._PARCELA == cParcela

	If cModo == "P"
		If SE2->E2_FORNECE != cFornecedor
			dbSkip()
			Loop
		End
	End

	If !(&cArquivo._TIPO $ MVABATIM) .or.  ;
			&cArquivo._EMISSAO > dDataBase   .or.  ;
			Empty(&cArquivo._BAIXA)          .and. ;
			&cArquivo._BAIXA <= dDataBase    .and. ;
			&cArquivo._SALDO == 0
	Else
		If li>58
			cabec(Titulo,cabec1,cabec2,nomeprog,tamanho,15)
		End
		nDesconto := Moeda(&cArquivo._VALOR,nMoeda,cModo)
		@ ++li,41    PSAY OemToAnsi( STR0005 )  + Substr ( &cArquivo._HIST, 1, 25 ) //"Abatimento - "
		@ li,nColuna PSAY nDesconto Picture Tm(nDesconto,16)
		nAbatimentos+=nDesconto
	End
	dbSkip()
End
If nAbatimento > 0
	If li > 58
		Cabec(titulo,cabec1,cabec2,nomeprog,tamanho,15)
	End
	@ ++li,41    PSAY OemToAnsi( STR0006) //"Total com abatimentos :"
	@ li,nColuna PSAY (nValor-nAbatimentos) Picture Tm(nValor-nAbatimentos,16)
End
dbGoto(nRegistro)
dbSetOrder(nOrdem)
dbSelectArea(cArea)
Return(nAbatimentos)


//-------------------------------------------------------------------
/*/{Protheus.doc} FINNATDESC

Retorna a Descricao da Natureza.
Arquivo original: FINXFUN.PRX

@author Eduardo Riera
@since 13/03/1998
/*/
//-------------------------------------------------------------------
Function FinNatDesc(cNatureza)
cNatureza := AllTrim(cNatureza)
cNatureza := StrTran(cNatureza,".","")
cNatureza := PadR(cNatureza,TamSX3("E1_NATUREZ")[1])
dbSelectArea("SED")
dbSetOrder(1)
dbSeek(xFilial()+cNatureza)
Return(SED->ED_DESCRIC)


//-------------------------------------------------------------------
/*/{Protheus.doc} TIME2NUM

Retorna a Descricao da Natureza.
Arquivo original: FINXFUN.PRX

@author Fabio Jadao Caire 
@since 22/10/2007
/*/
//-------------------------------------------------------------------
Function Time2Num(nTime,nTam)

LOCAL nTimeNum := 0

DEFAULT nTam := 7

nTimeNum    := Int(nTime) + ( ( nTime - Int(nTime) ) / 0.6 )

Return(nTimeNum)


//-------------------------------------------------------------------
/*/{Protheus.doc} NEXTNUMBOR

Retorna a Descricao da Natureza.
Arquivo original: FINXFUN.PRX

@author Alessandro Freire
@since 15/12/1997
/*/
//-------------------------------------------------------------------
Function NextNumBor( cPgRec )

LOCAL cOldAlias   := Alias()
LOCAL nOldOrd     := IndexOrd()
LOCAL cNumBor     := Space( 6 )

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Posiciona no SX6.                                    ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea( "SX6" )
cNumBor  := Soma1(IIF(Upper(cPgRec) == "R",GetMv("MV_NUMBORR"),GetMv("MV_NUMBORP")),6)

While .t.

	// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	// ³ Procura um n£mero livre para o bordero.              ³
	// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ! NumFree( cNumBor, cPgRec )
		cNumBor  := Soma1(cNumBor,6)
		Loop
	EndIf

	// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	// ³ Trava o registro no SX6 para gravar o novo n£mero    ³
	// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SX6")
	If SimpleLock()
		PutMv("MV_NUMBORR", cNumBor)
		Exit
	EndIf
	Inkey(.5)
EndDo

dbSelectArea(cOldAlias)
dbSetOrder(nOldOrd)
Return( cNumBor )


//-------------------------------------------------------------------
/*/{Protheus.doc} SLDFORNECE

Retorna o Saldo a Pagar do Fornecedor em uma data.
Arquivo original: FINXFUN.PRX

@author Eduardo Riera
@since 15/03/1998
/*/
//-------------------------------------------------------------------
Function SldFornece(cForLoja,dData,nMoeda,lMovSE5)

LOCAL aArea     := { Alias() , IndexOrd() , Recno() }
LOCAL aAreaSE2  := { SE2->(IndexOrd()), SE2->(Recno()) }
LOCAL bCondSE2
LOCAL nSaldo    := 0
LOCAL nTamFor   := len(Criavar("A2_COD"))
LOCAL nTamLoja  := len(Criavar("A2_LOJA"))
LOCAL cFornece  := SubStr(cForLoja,1,nTamFor)
LOCAL cLoja     := SubStr(cForLoja,nTamFor+1,nTamLoja)
LOCAL nSaldoTit := 0

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Testa os parametros vindos do Excel                  ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nMoeda      := If(Empty(nMoeda),1,nMoeda)
dData       := If(Empty(dData),dDataBase,dData)
dData       := DataWindow(dData)
lMovSE5     := BoolWindow(lMovSe5)
If ( ValType(nMoeda) == "C" )
	nMoeda      := Val(nMoeda)
EndIf

// Quando eh chamada do Excel, estas variaveis estao em branco
IF Empty(MVABATIM) .Or.;
	Empty(MV_CPNEG) .Or.;
	Empty(MVPAGANT) .Or.;
	Empty(MVPROVIS)
	CriaTipos()
Endif

dbSelectArea("SE2")
dbSetOrder(6)
dbSeek(xFilial()+cFornece+cLoja)
If ( !Empty(cLoja) )
	bCondSE2  := {|| !Eof() .And. xFilial() == SE2->E2_FILIAL .And.;
		cFornece == SE2->E2_FORNECE .And.;
		cLoja    == SE2->E2_LOJA }
Else
	bCondSE2  := {|| !Eof() .And. xFilial() == SE2->E2_FILIAL .And.;
		cFornece == SE2->E2_FORNECE }
EndIf
While ( Eval(bCondSE2) )
	If ( SE2->E2_EMIS1 <= dData .And. ;
			!SE2->E2_TIPO $ MVPROVIS+"/"+MVABATIM .And.;
			((!Empty(SE2->E2_FATURA).And.;
			Substr(SE2->E2_FATURA,1,6)=="NOTFAT" ) .Or.;
			(!Empty(SE2->E2_FATURA) .And.;
			Substr(SE2->E2_FATURA,1,6)!="NOTFAT" .And.;
			SE2->E2_DTFATUR > dData ) .Or.;
			Empty(SE2->E2_FATURA)) )
		If ( !SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG )
			If ( !lMovSE5 )
				If SE2->E2_SALDO > 0
					nSaldo += xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,1,dData)
					nSaldo -= SomaAbat(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,"P",1,dData,SE2->E2_FORNECE)
				EndIf
			Else
				nSaldoTit := SaldoTit(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_NATUREZ,"P",SE2->E2_FORNECE,nMoeda,,dData,SE2->E2_LOJA)
				If nSaldoTit > 0
					nSaldoTit -= SomaAbat(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,"P",1,dData,SE2->E2_FORNECE)
				Endif
				nSaldo += nSaldoTit
			EndIf
		Else
			If ( !lMovSE5 )
				nSaldo -= SaldoTit(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_NATUREZ,"P",SE2->E2_FORNECE,nMoeda,,dData,SE2->E2_LOJA)
			Else
				nSaldo -= xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,1,dData)
			EndIf
		EndIf
	EndIf
	dbSelectArea("SE2")
	dbSkip()
EndDo
dbSelectArea("SE2")
dbSetOrder(aAreaSE2[1])
dbGoto(aAreaSE2[2])
dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])
Return(nSaldo)


//-------------------------------------------------------------------
/*/{Protheus.doc} SLDRECEBER

Retorna o Saldo a Receber em uma determinada data. 
Arquivo original: FINXFUN.PRX

@param dData - Data do Movimento a Receber - Default dDataBase
@param nMoeda - Moeda do Saldo Bancario - Defa 1
@param lDtAnterior -  Se .T. Ate a Data,.F. Somente Data - Defa .T.
@param lMovSE5 - Se .T. considera o saldo do SE5 - Defa .T.

@author Eduardo Riera
@since 12/03/1998
/*/
//-------------------------------------------------------------------
Function SldReceber(dData,nMoeda,lDtAnterior,lMovSE5)

LOCAL aArea     := { Alias() , IndexOrd() , Recno() }
LOCAL aAreaSE1  := { SE1->(IndexOrd()), SE1->(Recno()) }
LOCAL bCondSE1
LOCAL nSaldo    := 0

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Testa os parametros vindos do Excel                  ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nMoeda      := If(Empty(nMoeda),1,nMoeda)
dData       := If(Empty(dData),dDataBase,dData)
lDtAnterior := BoolWindow(lDtAnterior)
lMovSe5     := BoolWindow(lMovSe5)
If ( ValType(nMoeda) == "C" )
	nMoeda      := Val(nMoeda)
EndIf
dData       := DataWindow(dData)

// Quando eh chamada do Excel, estas variaveis estao em branco
IF Empty(MVABATIM) .Or.;
	Empty(MV_CRNEG) .Or.;
	Empty(MVRECANT) .Or.;
	Empty(MVPROVIS)
	CriaTipos()
Endif

dbSelectArea("SE1")
dbSetOrder(7)
bCondSE1  := {|| !Eof() .And. xFilial() == SE1->E1_FILIAL .And.;
	SE1->E1_VENCREA <= dData }
If ( lDtAnterior )
	dbSeek(xFilial(),.T.)
Else
	dbSeek(xFilial()+Dtos(dData))
EndIf
While ( Eval(bCondSe1) )
	If ( SE1->E1_EMISSAO <= dData .And. ;
			!SE1->E1_TIPO $ MVPROVIS+"/"+MVABATIM .AND. ;
			((!Empty(SE1->E1_FATURA).And.;
			Substr(SE1->E1_FATURA,1,6)=="NOTFAT" ) .Or.;
			(!Empty(SE1->E1_FATURA) .And.;
			Substr(SE1->E1_FATURA,1,6)!="NOTFAT" .And.;
			SE1->E1_DTFATUR > dData ) .Or.;
			Empty(SE1->E1_FATURA)) ) .And. SE1->E1_FLUXO != "N"
		If ( !SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG )
			If ( !lMovSE5 )
				nSaldo += xMoeda(SE1->E1_SALDO,SE1->E1_MOEDA,1,dData )
				nSaldo -= SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",1,dData,SE1->E1_CLIENTE)
			Else
				nSaldo += SaldoTit(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE,nMoeda,,dData,SE1->E1_LOJA)
				nSaldo -= SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",1,dData,SE1->E1_CLIENTE)
			EndIf
		Else
			If ( !lMovSE5 )
				nSaldo -= SaldoTit(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE,nMoeda,,dData,SE1->E1_LOJA)
			Else
				nSaldo -= xMoeda(SE1->E1_SALDO,SE1->E1_MOEDA,1,dData)
			EndIf
		EndIf
	Endif
	dbSelectArea("SE1")
	dbSkip()
EndDo

dbSelectArea("SE1")
RetIndex("SE1")
dbClearFilter()
dbSetOrder(aAreaSE1[1])
dbGoto(aAreaSE1[2])

dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])

Return(nSaldo)


//-------------------------------------------------------------------
/*/{Protheus.doc} SLDPAGAR

Retorna o Saldo a Pagar em uma determinada data.  
Arquivo original: FINXFUN.PRX

@param dData - Data do Movimento a Receber - Default dDataBase
@param nMoeda - Moeda do Saldo Bancario - Defa 1
@param lDtAnterior -  Se .T. Ate a Data,.F. Somente Data - Defa .T.
@param lMovSE5 - Se .T. considera o saldo do SE5 - Defa .T.

@author Eduardo Riera
@since 12/03/1998
/*/
//-------------------------------------------------------------------
Function SldPagar(dData,nMoeda,lDtAnterior,lMovSe5)

LOCAL aArea     := { Alias() , IndexOrd() , Recno() }
LOCAL aAreaSE2  := { SE2->(IndexOrd()), SE2->(Recno()) }
LOCAL bCondSE2
LOCAL nSaldo    := 0

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Testa os parametros vindos do Excel                  ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nMoeda      := If(Empty(nMoeda),1,nMoeda)
dData       := If(Empty(dData),dDataBase,dData)
lDtAnterior := BoolWindow(lDtAnterior)
lMovSe5     := BoolWindow(lMovSe5)
If ( ValType(nMoeda) == "C" )
	nMoeda      := Val(nMoeda)
EndIf
dData       := DataWindow(dData)
// Quando eh chamada do Excel, estas variaveis estao em branco
IF Empty(MVABATIM) .Or.;
	Empty(MV_CPNEG) .Or.;
	Empty(MVPAGANT) .Or.;
	Empty(MVPROVIS)
	CriaTipos()
Endif
dbSelectArea("SE2")
dbSetOrder(3)
bCondSE2  := {|| !Eof() .And. xFilial() == SE2->E2_FILIAL .And.;
	SE2->E2_VENCREA <= dData }
If ( lDtAnterior )
	dbSeek(xFilial(),.T.)
Else
	dbSeek(xFilial()+Dtos(dData))
EndIf
While ( Eval(bCondSe2) )
	If ( SE2->E2_EMIS1 <= dData .And. ;
			!SE2->E2_TIPO $MVPROVIS+"/"+MVABATIM .AND. ;
			((!Empty(SE2->E2_FATURA).And.;
			Substr(SE2->E2_FATURA,1,6)=="NOTFAT" ) .Or.;
			(!Empty(SE2->E2_FATURA) .And.;
			Substr(SE2->E2_FATURA,1,6)!="NOTFAT" .And.;
			SE2->E2_DTFATUR > dData ) .Or.;
			Empty(SE2->E2_FATURA)) ) .And. SE2->E2_FLUXO != "N"
		If ( !SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG )
			If ( !lMovSE5 )
				nSaldo += xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,1,dData)
				nSaldo -= SomaAbat(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,"P",1,dData,SE2->E2_FORNECE)
			Else
				nSaldo += SaldoTit(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_NATUREZ,"P",SE2->E2_FORNECE,nMoeda,,dData,SE2->E2_LOJA)
				nSaldo -= SomaAbat(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,"P",1,dData,SE2->E2_FORNECE)
			EndIf
		Else
			If ( !lMovSE5 .And. !SE2->E2_TIPO $ MVABATIM )
				nSaldo -= SaldoTit(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_NATUREZ,"P",SE2->E2_FORNECE,nMoeda,,dData,SE2->E2_LOJA)
			Else
				nSaldo -= xMoeda(SE2->E2_SALDO,SE2->E2_MOEDA,1,dData)
			EndIf
		EndIf
	EndIf
	dbSelectArea("SE2")
	dbSkip()
EndDo
dbSelectArea("SE2")
RetIndex("SE2")
dbClearFilter()
dbSetOrder(aAreaSE2[1])
dbGoto(aAreaSE2[2])
dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])
Return(nSaldo)


//-------------------------------------------------------------------
/*/{Protheus.doc} VLRFORNECE

Retorna o Valor dos titulo do fornecedor em um periodo.  
Arquivo original: FINXFUN.PRX

@param cForLoja - Fornecedor + Loja
@param dDtIni - Data inicial do Movimento a Receber				  
@param dDtFin - Data final   do Movimento a Receber
@param nMoeda - Moeda do Valor dos movimentos - Defa 1
@param lConsAbat -  Se .T. considera abatimentos - Defa .T.
@param lConsAcresc - Se .T. considera Acrescimos - Defa .T.
@param lConsDecresc - Se .T. considera Decrescimos - Defa .T.

@author Claudio D. de Souza
@since 06/05/2002
/*/
//-------------------------------------------------------------------
Function VlrFornece(cForLoja,dDtIni,dDtFin,nMoeda,lConsAbat,lConsAcresc,lConsDecresc)

LOCAL aArea     := { Alias() , IndexOrd() , Recno() }
LOCAL aAreaSE2  := { SE2->(IndexOrd()), SE2->(Recno()) }
LOCAL bCondSE2
LOCAL nVlrFornece := 0
LOCAL nTamFor   := len(Criavar("A2_COD"))
LOCAL nTamLoja  := len(Criavar("A2_LOJA"))
LOCAL cFornece  := SubStr(cForLoja,1,nTamFor)
LOCAL cLoja     := SubStr(cForLoja,nTamFor+1,nTamLoja)

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Testa os parametros vindos do Excel                  ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT nMoeda  := 1
DEFAULT dDtIni  := Ctod("01/01/1900")
DEFAULT dDtFin  := dDataBase
DEFAULT lConsAcresc := .F.
DEFAULT lConsDecresc:= .F.

dDtIni      := DataWindow(dDtIni)
dDtFin      := DataWindow(dDtFin)
lConsAcresc := BoolWindow(lConsAcresc)
lConsDecresc:= BoolWindow(lConsDecresc)

If ( ValType(nMoeda) == "C" )
	nMoeda      := Val(nMoeda)
EndIf

// Quando eh chamada do Excel, estas variaveis estao em branco
IF Empty(MVABATIM) .Or.;
	Empty(MV_CPNEG) .Or.;
	Empty(MVPAGANT) .Or.;
	Empty(MVPROVIS)
	CriaTipos()
Endif

dbSelectArea("SE2")
dbSetOrder(7)
MsSeek(xFilial("SE2")+Dtos(dDtIni),.T.)
If ( !Empty(cLoja) )
	bCondSE2  := {||	cFornece == SE2->E2_FORNECE .And.;
							cLoja    == SE2->E2_LOJA }
Else
	bCondSE2  := {|| 	cFornece == SE2->E2_FORNECE }
EndIf
While SE2->(!Eof())  						.And.;
		xFilial("SE2")==SE2->E2_FILIAL	.And.;
		SE2->E2_EMIS1 <= dDtFin
	If	Eval(bCondSE2) .And. ;
		!SE2->E2_TIPO $ MVPROVIS+"/"+MVABATIM .And.;
		((!Empty(SE2->E2_FATURA) .And.;
		  Substr(SE2->E2_FATURA,1,6)!="NOTFAT") .Or.;
		  Empty(SE2->E2_FATURA))
		If (!SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG )
			nVlrFornece += xMoeda(SE2->E2_VALOR+If(lConsAcresc,SE2->E2_ACRESC,0)-If(lConsDecresc,SE2->E2_DECRESC,0),SE2->E2_MOEDA,nMoeda)
			If lConsAbat
				nVlrFornece -= SomaAbat(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,"P",1,,SE2->E2_FORNECE)
			Endif
		Else
			nVlrfornece -= xMoeda(SE2->E2_VALOR+If(lConsAcresc,SE2->E2_ACRESC,0)-If(lConsDecresc,SE2->E2_DECRESC,0),SE2->E2_MOEDA,nMoeda)
		EndIf
	EndIf
	dbSelectArea("SE2")
	dbSkip()
EndDo
dbSelectArea("SE2")
dbSetOrder(aAreaSE2[1])
dbGoto(aAreaSE2[2])
dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])
Return(nVlrFornece)


//-------------------------------------------------------------------
/*/{Protheus.doc} VLRCLIENTE

Retorna o Valor dos titulo do cliente em um periodo     
Arquivo original: FINXFUN.PRX

@param cCliLoja - Cliente  + Loja
@param dDtIni - Data inicial do Movimento a Receber				  
@param dDtFin - Data final   do Movimento a Receber
@param nMoeda - Moeda do Valor dos movimentos - Defa 1
@param lConsAbat -  Se .T. considera abatimentos - Defa .T.
@param lConsAcresc - Se .T. considera Acrescimos - Defa .T.
@param lConsDecresc - Se .T. considera Decrescimos - Defa .T.

@author Claudio D. de Souza
@since 07/05/2002
/*/
//-------------------------------------------------------------------
Function VlrCliente(cCliLoja,dDtIni,dDtFin,nMoeda,lConsAbat,lConsAcresc,lConsDecresc)

LOCAL aArea     := { Alias() , IndexOrd() , Recno() }
LOCAL aAreaSE1  := { SE1->(IndexOrd()), SE1->(Recno()) }
LOCAL bCondSE1
LOCAL nVlrCliente := 0
LOCAL nTamCli   := len(Criavar("A1_COD"))
LOCAL nTamLoja  := len(Criavar("A1_LOJA"))
LOCAL cCliente  := SubStr(cCliLoja,1,nTamCli)
LOCAL cLoja     := SubStr(cCliLoja,nTamCli+1,nTamLoja)

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Testa os parametros vindos do Excel                  ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT nMoeda  := 1
DEFAULT dDtIni  := Ctod("01/01/1900")
DEFAULT dDtFin  := dDataBase
DEFAULT lConsAcresc := .F.
DEFAULT lConsDecresc:= .F.

dDtIni      := DataWindow(dDtIni)
dDtFin      := DataWindow(dDtFin)
lConsAcresc := BoolWindow(lConsAcresc)
lConsDecresc:= BoolWindow(lConsDecresc)

If ( ValType(nMoeda) == "C" )
	nMoeda      := Val(nMoeda)
EndIf

// Quando eh chamada do Excel, estas variaveis estao em branco
IF Empty(MVABATIM) .Or.;
	Empty(MV_CPNEG) .Or.;
	Empty(MVPAGANT) .Or.;
	Empty(MVPROVIS)
	CriaTipos()
Endif

dbSelectArea("SE1")
dbSetOrder(6)
MsSeek(xFilial("SE1")+Dtos(dDtIni),.T.)
If ( !Empty(cLoja) )
	bCondSE1  := {||	cCliente == SE1->E1_CLIENTE .And.;
							cLoja    == SE1->E1_LOJA }
Else
	bCondSE1  := {|| 	cCliente == SE1->E1_CLIENTE }
EndIf
While SE1->(!Eof())  						.And.;
		xFilial("SE1")==SE1->E1_FILIAL	.And.;
		SE1->E1_EMISSAO <= dDtFin
	If	Eval(bCondSE1) .And. ;
		!SE1->E1_TIPO $ MVPROVIS+"/"+MVABATIM .And.;
		((!Empty(SE1->E1_FATURA) .And.;
		  Substr(SE1->E1_FATURA,1,6)!="NOTFAT") .Or.;
		  Empty(SE1->E1_FATURA))
		If (!SE1->E1_TIPO $ MVPAGANT+"/"+MV_CPNEG )
			nVlrCliente += xMoeda(SE1->E1_VALOR+If(lConsAcresc,SE1->E1_ACRESC,0)-If(lConsDecresc,SE1->E1_DECRESC,0),SE1->E1_MOEDA,nMoeda)
			If lConsAbat
				nVlrCliente -= SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"P",1,,SE1->E1_CLIENTE)
			Endif
		Else
			nVlrCliente -= xMoeda(SE1->E1_VALOR+If(lConsAcresc,SE1->E1_ACRESC,0)-If(lConsDecresc,SE1->E1_DECRESC,0),SE1->E1_MOEDA,nMoeda)
		EndIf
	EndIf
	dbSelectArea("SE1")
	dbSkip()
EndDo
dbSelectArea("SE1")
dbSetOrder(aAreaSE1[1])
dbGoto(aAreaSE1[2])
dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])
Return(nVlrCliente)


//-------------------------------------------------------------------
/*/{Protheus.doc} FINANATORC

Retorna o Valor dos titulo do cliente em um periodo     
Arquivo original: FINXFUN.PRX

@param cNatureza - Natureza a ser Pesquisada
@param cMes - Mês para cálculo
@param nMoeda - Moeda de Saida
@param nAno - Ano

@author Eduardo Riera
@since 13/03/1998
/*/
//-------------------------------------------------------------------
Function FinNatOrc(cNatureza,cMes,nMoeda,nAno)

LOCAL aArea    := { Alias() , IndexOrd() , Recno() }
LOCAL aAreaSE7 := { SE7->(IndexOrd()) , SE7->(Recno()) }
LOCAL nRetorno := 0
LOCAL nPosicao := 0

nAno := Iif(nAno==Nil,Year(dDataBase),nAno)

cNatureza := AllTrim(cNatureza)
cNatureza := StrTran(cNatureza,".","")
cNatureza := PadR(cNatureza,TamSX3("E1_NATUREZ")[1])
If ( ValType(cMes) == "N" )
	cMes := StrZero(cMes,2)
EndIf
cMes := Upper(cMes)
Do Case
Case cMes $ "01#JAN#JANEIRO"
	cMes := "JAN1"
Case cMes $ "02#FEV#FEVEREIRO"
	cMes := "FEV1"
Case cMes $ "03#MAR#MARCO"
	cMes := "MAR1"
Case cMes $ "04#ABR#ABRIL"
	cMes := "ABR1"
Case cMes $ "05#MAI#MAIO"
	cMes := "MAI1"
Case cMes $ "06#JUN#JUNHO"
	cMes := "JUN1"
Case cMes $ "07#JUL#JULHO"
	cMes := "JUL1"
Case cMes $ "08#AGO#AGOSTO"
	cMes := "AGO1"
Case cMes $ "09#SET#SETEMBRO"
	cMes := "SET1"
Case cMes $ "10#OUT#OUTUBRO"
	cMes := "OUT1"
Case cMes $ "11#NOV#NOVEMBRO"
	cMes := "NOV1"
Case cMes $ "12#DEZ#DEZEMBRO"
	cMes := "DEZ1"
EndCase
If ( ValType(nMoeda) == "C" )
	nMoeda := Val(nMoeda)
EndIf
dbSelectArea("SE7")
dbSetOrder(1)
dbSeek(xFilial()+cNatureza)
While ( !Eof() .And. SE7->E7_FILIAL  == xFilial("SE7") .And.;
		SE7->E7_NATUREZ >= cNatureza .And.;
		SE7->E7_NATUREZ <= cNatureza )
	nPosicao := FieldPos("E7_VAL"+cMes)
	If ( nPosicao != 0 ) .and. SE7->E7_ANO == Alltrim(STR(nAno))
		nRetorno += xMoeda(FieldGet(nPosicao),1,nMoeda)
	EndIf
	dbSelectArea("SE7")
	dbSkip()
EndDo
dbSelectArea("SE7")
dbSetOrder(aAreaSE7[1])
dbGoto(aAreaSE7[2])
dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])
Return(nRetorno)


//-------------------------------------------------------------------
/*/{Protheus.doc} FINANATPRV

Retorna o Valor previsto de cada Natureza      
Arquivo original: FINXFUN.PRX

@author Eduardo Riera
@since 13/03/1998
/*/
//-------------------------------------------------------------------
Function FinNatPrv(cNatureza,dDataIni,dDataFim,nMoeda,nTipoData,lConsDtBas,lConsProvis)

LOCAL aArea 	:= GetArea()
LOCAL aAreaSE1 	:= SE1->( GetArea() )
LOCAL aAreaSE2 	:= SE2->( GetArea() )
LOCAL nRetorno 	:= 0
LOCAL cCampoData
LOCAL lTop		:= .F.
LOCAL nY 		:= 0
LOCAL aStruSE1 	:= SE1->(dbStruct())
LOCAL aStruSE2 	:= SE2->(dbStruct())
LOCAL cCond 	:= ""
LOCAL cOrder 	:= ""
LOCAL cQuery 	:= ""
LOCAL cAliasSE1 := ""
LOCAL cAliasSE2	:= ""

DEFAULT nTipoData   := 1
DEFAULT lConsDtBas  := .F.
DEFAULT lConsProvis := .F.

#IFDEF TOP
	If TcSrvType() <> "AS/400"
		lTop := .T.
	Endif
#ENDIF

If lTop
	cAliasSE1 := "TmpSE1"
	cAliasSE2 := "TmpSE2"
Else
	cAliasSE1 := "SE1"
	cAliasSE2 := "SE2"
Endif

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Testa os parametros vindos do Excel			      ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cNatureza := AllTrim(cNatureza)
cNatureza := StrTran(cNatureza,".","")
cNatureza := PadR(cNatureza,TamSX3("E1_NATUREZ")[1])
dDataIni  := DataWindow(dDataIni)
dDataFim  := DataWindow(dDataFim)
dDataIni  := If(Empty(dDataIni),FirstDay(dDataBase),dDataIni)
dDataFim  := If(Empty(dDataFim),LastDay(dDataBase) ,dDataFim)
If ( ValType(nMoeda) == "C" )
	nMoeda := Val(nMoeda)
EndIf

cCampoData := If( nTipoData == 1, "E1_EMISSAO", If(nTipoData==2,"E1_VENCREA","E1_EMISSAO") )

// Quando eh chamada do Excel, estas variaveis estao em branco
IF	Empty(MVABATIM) .Or.;
   	Empty(MV_CRNEG) .Or.;
	Empty(MVRECANT) .Or.;
	Empty(MV_CPNEG) .Or.;
	Empty(MVPAGANT) .Or.;
	Empty(MVPROVIS)
		CriaTipos()
Endif

dbSelectArea("SE1")
dbSetOrder( If(nTipoData==1,11,7) )
If lTop
	cCond  := ".T."
	cQuery := ""
	For nY := 1 To Len(aStruSE1)
		cQuery += IIf(!EMPTY(cQuery),",","") + aStruSE1[nY][1]
	Next nY
	cOrder := SqlOrder(IndexKey())
	cQuery := " SELECT " + cQuery
	cQuery += " FROM "   + RetSqlName("SE1") + " SE1 "
	cQuery += " WHERE SE1.E1_FILIAL = '" + xFilial("SE1") + "' AND "
	cQuery += cCampoData + ">= '" + DToS(dDataIni) + "' AND " + cCampoData + "<= '" + DToS(dDataFim) + "' AND "
	cQuery += " SE1.D_E_L_E_T_ = ' ' "
	cQuery += " ORDER BY  " + cOrder

	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE1,.T.,.T.)
	DBSelectArea(cAliasSE1)
	For nY := 1 To Len(aStruSE1)
		If aStruSE1[nY][2] <> "C"
			TcSetField(cAliasSE1,aStruSE1[nY][1],aStruSE1[nY][2],aStruSE1[nY][3],aStruSE1[nY][4])
		EndIf
	Next nY
Else
	cAliasSE1 := "SE1"
	cCond     := '( SE1->E1_FILIAL == xFilial("SE1") .And. 	SE1->'+cCampoData+' <= dDataFim )'
	dbSeek(xFilial("SE1")+Dtos(dDataIni),.T.)
Endif

While !((cAliasSE1)->(EOF())) .And. &cCond
	If (cAliasSE1)->E1_NATUREZ == cNatureza 	.And.;
		!(cAliasSE1)->E1_TIPO$MVRECANT+"/"+MV_CRNEG+"/"+MVABATIM

		If !lConsProvis .and. (cAliasSE1)->E1_TIPO $ MVPROVIS
			dbSkip()
			Loop
		Endif

		If !lConsDtBas
			nRetorno += xMoeda((cAliasSE1)->E1_SALDO,(cAliasSE1)->E1_MOEDA,nMoeda)
		Else
			nRetorno += SaldoTit((cAliasSE1)->E1_PREFIXO,(cAliasSE1)->E1_NUM,(cAliasSE1)->E1_PARCELA,(cAliasSE1)->E1_TIPO,(cAliasSE1)->E1_NATUREZ,"R",(cAliasSE1)->E1_CLIENTE,nMoeda,,dDataBase,(cAliasSE1)->E1_LOJA)
		Endif
		nRetorno -= SomaAbat((cAliasSE1)->E1_PREFIXO,(cAliasSE1)->E1_NUM,(cAliasSE1)->E1_PARCELA,"R",1,dDataBase,(cAliasSE1)->E1_CLIENTE)
	EndIf
 	dbSelectArea(cAliasSE1)
	dbSkip()
EndDo
If lTop
	dbSelectArea(cAliasSE1)
	dbCloseArea()
Else
	dbSelectArea("SE1")
	RetIndex("SE1")
	dbClearFilter()
	dbSetOrder(1)
Endif

dbSelectArea("SE2")
cCampoData :=	If( nTipoData == 1, "E2_EMIS1",;
				If( nTipoData == 2, "E2_VENCREA",;
				If( nTipoData == 3, "E2_EMISSAO","E2_EMIS1")))

dbSetOrder(	If(nTipoData==1,7,;
			If(nTipoData==2,3,;
			If(nTipoData==3,5,7))))
If lTop
	cCond := ".T."
	cQuery := ""
	For nY := 1 To Len(aStruSE2)
		cQuery += IIf(!EMPTY(cQuery),",","") + aStruSE2[nY][1]
	Next nY
	cOrder := SqlOrder(IndexKey())
	cQuery := "SELECT " + cQuery
	cQuery += " FROM "  + RetSqlName("SE2") + " SE2 "
	cQuery += " WHERE SE2.E2_FILIAL = '" + xFilial("SE2") + "' AND "
	cQuery += cCampoData + ">= '" + DToS(dDataIni) + "' AND " + cCampoData + "<= '" + DToS(dDataFim) + "' AND "
	cQuery += " SE2.D_E_L_E_T_ = ' ' "
	cQuery += " ORDER BY  " + cOrder

	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE2,.T.,.T.)
	DBSelectArea(cAliasSE2)
	For nY := 1 To Len(aStruSE2)
		If aStruSE2[nY][2] <> "C"
			TcSetField(cAliasSE2,aStruSE2[nY][1],aStruSE2[nY][2],aStruSE2[nY][3],aStruSE2[nY][4])
		EndIf
	Next nY
Else
	cAliasSE2 := "SE2"
	cCond     := '(cAliasSE2)->E2_FILIAL == xFilial("SE2") .And. (cAliasSE2)->&(cCampoData) <= dDataFim'
	dbSeek(xFilial()+Dtos(dDataIni)+If(nTipoData==1,cNatureza,""),.T.)
Endif

While !((cAliasSE2)->(EOF())) .And. &cCond

	If (cAliasSE2)->E2_NATUREZ == cNatureza .And. ;
	   !(cAliasSE2)->E2_TIPO$MVPAGANT+"/"+MV_CPNEG+"/"+MVABATIM

		If !lConsProvis .and. (cAliasSE2)->E2_TIPO $ MVPROVIS
			dbSkip()
			Loop
		Endif
		If !lConsDtBas
			nRetorno += xMoeda((cAliasSE2)->E2_SALDO,(cAliasSE2)->E2_MOEDA,nMoeda)
		Else
			nRetorno += SaldoTit((cAliasSE2)->E2_PREFIXO,(cAliasSE2)->E2_NUM,(cAliasSE2)->E2_PARCELA,(cAliasSE2)->E2_TIPO,(cAliasSE2)->E2_NATUREZ,"P",(cAliasSE2)->E2_FORNECE,nMoeda,,dDataBase,(cAliasSE2)->E2_LOJA)
		Endif
		nRetorno -= SomaAbat((cAliasSE2)->E2_PREFIXO,(cAliasSE2)->E2_NUM,(cAliasSE2)->E2_PARCELA,"P",1,,(cAliasSE2)->E2_FORNECE)
	EndIf
	dbSelectArea(cAliasSE2)
	dbSkip()
EndDo
If lTop
	dbSelectArea(cAliasSE2)
	dbCloseArea()
Else
	dbSelectArea("SE2")
	RetIndex("SE2")
	dbClearFilter()
	dbSetOrder(1)
Endif

RestArea( aAreaSE2 )
RestArea( aAreaSE1 )
RestArea( aArea    )
Return(nRetorno)


//-------------------------------------------------------------------
/*/{Protheus.doc} FINANATVEN

Retorna o Valor Previsto de cada Natureza, considerando a data de 
vencimento real.        
Arquivo original: FINXFUN.PRX

@param cNatureza - Natureza a ser Pesquisada
@param dDataIni - Data Inicial para calculo
@param dDataFim - Data Final de calculo
@param nMoeda - Moeda de Saida
@param cCarteira - Carteira a considerar (R/P/A) Default=[A]mbas
@param cPosTit - (B)Baixados (A)Aberto (T)Todos Default=[T]odos
@param nTipoData
@param lConsDtBas
@param lConsProvis

@author Julio Wittwer
@since 01/09/1999
/*/
//-------------------------------------------------------------------
Function FinNatVen(cNatureza,dDataIni,dDataFim,nMoeda,cCarteira,cPosTit,;
 						 nTipoData,lConsDtBas,lConsProvis)

LOCAL aArea 	:= { Alias() , IndexOrd() , Recno() }
LOCAL aAreaSE1 := { SE1->(IndexOrd()) , SE1->(Recno()) }
LOCAL aAreaSE2 := { SE2->(IndexOrd()) , SE2->(Recno()) }
LOCAL nRetorno := 0
LOCAL lFinNVR  := ExistBlock("FINNVR")
LOCAL lFinNVP  := ExistBlock("FINNVP")

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Testa os parametros vindos do Excel						 ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cNatureza := AllTrim(cNatureza)
cNatureza := StrTran(cNatureza,".","")
cNatureza := PadR(cNatureza,TamSX3("E1_NATUREZ")[1])
dDataIni  := DataWindow(dDataIni)
dDataFim  := DataWindow(dDataFim)
lConsDtBas:= BoolWindow(lConsDtBas)
lConsProvis:=BoolWindow(lConsProvis)
dDataIni  := If(Empty(dDataIni),FirstDay(dDataBase),dDataIni)
dDataFim  := If(Empty(dDataFim),LastDay(dDataBase),dDataFim)
If ( ValType(nMoeda) == "C" )
	nMoeda		:= Val(nMoeda)
EndIf
cCarteira := If(cCarteira=NIL,"A",upper(alltrim(cCarteira)))
cPosTit   := If(cPostit == NIL,"T",upper(alltrim(cPosTit)))

DEFAULT nTipoData := 1
DEFAULT lConsDtBas := .F.
DEFAULT lConsProvis := .F.

cCampoData :=	If( nTipoData == 1,	"E1_EMISSAO",;
					If( nTipoData == 2,	"E1_VENCREA",;
												"E1_EMISSAO"))

// Quando eh chamada do Excel, estas variaveis estao em branco
IF Empty(MVABATIM) .Or.;
	Empty(MV_CRNEG) .Or.;
	Empty(MVRECANT) .Or.;
	Empty(MV_CPNEG) .Or.;
	Empty(MVPAGANT) .Or.;
	Empty(MVPROVIS)
	CriaTipos()
Endif

If cCarteira $ "RA"
	dbSelectArea("SE1")
	dbSetOrder(If(nTipoData==1,11,7))
	dbSeek(xFilial()+Dtos(dDataIni),.T.)
	While ( !Eof() .And.  SE1->E1_FILIAL == xFilial() .And.;
			SE1->&(cCampoData) <= dDataFim )

		If (cPosTit == "T") .or. (cPostit == "A" .and. SE1->E1_SALDO > 0) .or. ;
				(cPostit == "B" .and. SE1->E1_SALDO <= 0)
			If SE1->E1_NATUREZ == cNatureza .And.;
					!SE1->E1_TIPO $ MV_CRNEG+"/"+MVRECANT+"/"+MVABATIM
				If !lConsProvis .and. SE1->E1_TIPO $ MVPROVIS
					dbSkip()
					Loop
				Endif
				If !lConsDtBas
					nRetorno += xMoeda(SE1->E1_VALOR,SE1->E1_MOEDA,nMoeda)
				Else
					nRetorno += SaldoTit(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE,nMoeda,,dDatabase,SE1->E1_LOJA)
				Endif
				nRetorno -= SomaAbat(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,"R",1,dDataBase,SE1->E1_CLIENTE)
				If lFinNVR
					nRetorno := ExecBlock("FINNVR",.F.,.F.,nRetorno)
				Endif
			EndIf
		Endif
		dbSelectArea("SE1")
		dbSkip()
	EndDo
	dbSelectArea("SE1")
	RetIndex("SE1")
	dbClearFilter()
	dbSetOrder(aAreaSE1[1])
	dbGoto(aAreaSE1[2])
Endif

If cCarteira$"PA"
	dbSelectArea("SE2")
	cCampoData :=	If( nTipoData == 1, "E2_EMIS1",;
						If( nTipoData == 2, "E2_VENCREA"	,;
						If( nTipoData == 3, "E2_EMISSAO","E2_EMIS1")))

	dbSetOrder(	If(nTipoData==1,7,;
					If(nTipoData==2,3,;
					If(nTipoData==3,5,7))))
	dbSeek(xFilial()+Dtos(dDataIni)+If(nTipoData==1,cNatureza,""),.T.)
	While !Eof() .And. SE2->E2_FILIAL == xFilial()	.And. ;
			SE2->&(cCampoData)	 <= dDataFim

		If (cPosTit == "T") .or. (cPostit == "A" .and. SE2->E2_SALDO > 0) .or. ;
				(cPostit == "B" .and. SE2->E2_SALDO <= 0)
			If SE2->E2_NATUREZ == cNatureza	.And. ;
					!SE1->E1_TIPO$MV_CPNEG+"/"+MVPAGANT+"/"+MVABATIM
				If !lConsProvis .and. SE2->E2_TIPO $ MVPROVIS
					dbSkip()
					Loop
				Endif
				If !lConsDtBas
					nRetorno += xMoeda(SE2->E2_VALOR,SE2->E2_MOEDA,nMoeda)
				Else
					nRetorno += SaldoTit(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,SE2->E2_NATUREZ,"P",SE2->E2_FORNECE,nMoeda,,dDataBase,SE2->E2_LOJA)
				Endif
				nRetorno -= SomaAbat(SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,"P",1,,SE2->E2_FORNECE)
				If lFinNVP
					nRetorno := ExecBlock("FINNVP",.F.,.F.,nRetorno)
				Endif
			EndIf
		Endif
		dbSelectArea("SE2")
		dbSkip()
	EndDo
	dbSelectArea("SE2")
	RetIndex("SE2")
	dbClearFilter()
	dbSetOrder(aAreaSE2[1])
	dbGoto(aAreaSE2[2])
Endif

dbSelectArea(aArea[1])
dbSetOrder(aArea[2])
dbGoto(aArea[3])
Return(nRetorno)


//-------------------------------------------------------------------
/*/{Protheus.doc} FINNATREA

Retorna o Valor realizado de cada Natureza.        
Arquivo original: FINXFUN.PRX

@param cNatureza - Natureza a ser Pesquisada
@param dDataIni - Data Inicial para calculo
@param dDataFim - Data Final de calculo
@param nMoeda - Moeda de Saida

@author Eduardo Riera
@since 13/03/1998
/*/
//-------------------------------------------------------------------
Function FinNatRea(cNatureza,dDataIni,dDataFim,nMoeda,lMovBco,cTipoDat)

LOCAL aArea 	:= GetArea()
LOCAL aAreaSE5	:= SE5->( GetArea() )
LOCAL nRetorno 	:= 0
LOCAL lTop		:= .F.
LOCAL nY 		:= 0
LOCAL aStruSE5	:= SE5->(dbStruct())
LOCAL cCond 	:= ""
LOCAL cOrder 	:= ""
LOCAL cQuery	:= ""
LOCAL cAliasTMP

#IFDEF TOP
	If TcSrvType() <> "AS/400"
		lTop := .T.
	Endif
#ENDIF

If lTop
	cAliasTMP := "TMPSE5"
Else
	cAliasTMP := "SE5"
Endif

cTipoDat := Iif(cTipoDat==NIl,"DG","DT"   ) // DG=Digitacao, DT=Data Movto
lMovBco  := Iif(lMovBco==Nil ,1   ,lMovBco)

PRIVATE dDtFim
PRIVATE dDtIni
// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Testa os parametros vindos do Excel                  ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cNatureza	:= AllTrim(cNatureza)
cNatureza	:= PadR(cNatureza,TamSX3("E1_NATUREZ")[1])
dDtIni		:= DataWindow(dDataIni)
dDtFim		:= DataWindow(dDataFim)
dDataIni	:= If(Empty(dDataIni),dDataBase,dDataIni)
dDataFim	:= If(Empty(dDataFim),dDataBase,dDataFim)
If ( ValType(nMoeda) == "C" )
	nMoeda := Val(nMoeda)
EndIf

dbselectArea("SE5")
If cTipoDat == "DG"
	dbSetOrder(6)
Else
	dbSetOrder(1)
Endif

If lTop
	cCond  := ".T."
	cQuery := ""
	For nY := 1 To Len(aStruSE5)
		cQuery += IIf(!EMPTY(cQuery),",","") + aStruSE5[nY][1]
	Next nY
	cOrder := SqlOrder(IndexKey())
	cQuery := " SELECT " + cQuery
	cQuery += " FROM " + RetSqlName("SE5") + " SE5 "
	cQuery += " WHERE SE5.E5_FILIAL = '"+xFilial("SE5")+"' AND "
	If cTipoDat == "DG"
		cQuery += " SE5.E5_DTDIGIT >= '" + DToS(dDtIni) + "' AND SE5.E5_DTDIGIT <= '" + DToS(dDtFim) + "' AND"
	Else
		cQuery += " SE5.E5_DATA    >= '" + DToS(dDtIni) + "' AND SE5.E5_DATA    <= '" + DToS(dDtFim) + "' AND"
	EndIf
	cQuery += " SE5.E5_NATUREZ = '" + cNatureza + "' AND"
	cQuery += " SE5.D_E_L_E_T_ = ' ' "
	cQuery += " ORDER BY  " + cOrder

	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTMP,.T.,.T.)
	DbSelectArea(cAliasTMP)
	For nY := 1 To Len(aStruSE5)
		If aStruSE5[nY][2] <> "C"
			TcSetField(cAliasTMP,aStruSE5[nY][1],aStruSE5[nY][2],aStruSE5[nY][3],aStruSE5[nY][4])
		EndIf
	Next nY
Else
	cAliasTMP := "SE5"
	dbSelectArea(cAliasTMP)
	cCond := "xFilial() == SE5->E5_FILIAL"
	If cTipoDat == "DG"
		cCond += " .And. E5_DTDIGIT <= dDtFim"
		dbSeek(xFilial("SE5")+Dtos(dDtIni)+cNatureza,.T.)
	Else
		cCond += " .And. E5_DATA <= dDtFim"
		dbSeek(xFilial("SE5")+Dtos(dDtIni),.T.)
	Endif
Endif

While !((cAliasTMP)->(Eof())) .And. &cCond

	If (cAliasTMP)->E5_NATUREZ != cNatureza
		dbSkip()
		Loop
	Endif

	If !Empty((cAliasTMP)->E5_MOTBX)
		If !MovBcoBx( (cAliasTMP)->E5_MOTBX ) .and. lMovBco == 0
			dbSkip()
			Loop
		EndIf
	EndIf

	If !Empty( (cAliasTMP)->E5_TIPODOC ) .and. TemBxCanc((cAliasTMP)->E5_PREFIXO+(cAliasTMP)->E5_NUMERO+(cAliasTMP)->E5_PARCELA+(cAliasTMP)->E5_TIPO+(cAliasTMP)->E5_CLIFOR+(cAliasTMP)->E5_LOJA+(cAliasTMP)->E5_SEQ)
  		dbSkip()
  		Loop
   Endif

  	// Desconsidera baixas de titulos geradas por aglutinacao de impostos
	If !Empty((cAliasTMP)->E5_AGLIMP) .And. (cAliasTMP)->E5_TIPO $ MVTAXA+"/"+MVTXA
		dbSkip()
  		Loop
	Endif

	If ( !(cAliasTMP)->E5_TIPODOC$"DC#JR#MT#CM#D2#J2#M2#C2#TL#CP#CH#EC#BL#V2#VM" ) .And.;
			!((cAliasTMP)->E5_SITUACA $ "C/E/X")
		If ( (cAliasTMP)->E5_RECPAG == "R" )
			nRetorno += (cAliasTMP)->E5_VALOR
		Else
			nRetorno -= (cAliasTMP)->E5_VALOR
		EndIf
	EndIf
	dbSelectArea((cAliasTMP))
	dbSkip()
EndDo
If lTop
	dbSelectArea(cAliasTMP)
	dbCloseArea()
Else
	dbSelectArea("SE5")
	RetIndex("SE5")
	dbClearFilter()
	dbSetOrder(1)
Endif

RestArea( aAreaSE5 )
RestArea( aArea    )
Return(xMoeda(nRetorno,1,nMoeda))


//-------------------------------------------------------------------
/*/{Protheus.doc} LIQORDEN

Tela de Edição para Liquidaçao da Orden de Pago e Cobranzas funçãao 
exclusiva para o MercoSul.
Arquivo original: FINXFUN.PRX

@param cLiq - "0" Ordem de Pagamento, "1" Ordem de Cobranas.

@author Jose Lucas
@since 28/09/1998
/*/
//-------------------------------------------------------------------
Function LiqOrden(cLiq)

LOCAL oDlg := NIL
LOCAL oFnt := NIL

cCliFor := If( cLiq=="0",cFornece,cCliente )
cLjCliFor := cLoja

nOpca := 0
DEFINE MSDIALOG oDlg TITLE cCadastro PIXEL FROM 97,0.5 TO 398,630 OF oMainWnd

@ 1.0 , 00.3   To 3.0, 39 OF oDlg
@ 3.1 , 00.3   To 5.5, 39 OF oDlg

@ 1.6 , 00.8 SAY OemToAnsi(STR0007) FONT oDlg:oFont //"Nro. Liquidaçäo "
@ 1.6 , 10   Say cLiquid Picture "@!" FONT oFnt COLOR CLR_HBLUE
@ 1.6 , 15   SAY OemToAnsi(STR0008) + Dtoc(dDataI) FONT oDlg:oFont //"Emissäo de  "
@ 1.6 , 25   SAY OemToAnsi(STR0009) + Dtoc(dDataF) FONT oDlg:oFont //"até  "
@ 2.2 , 00.8 SAY OemToAnsi(STR0010) + cCliFor      FONT oDlg:oFont //"Cliente  "
@ 2.2 , 10   SAY OemToAnsi(STR0011) + cLjCliFor    FONT oDlg:oFont //"Loja  "
@ 2.2 , 20   Say nValor      Picture "@E 999,999,999.99" FONT oDlg:oFont
@ 2.2 , 30   Say nValRet     Picture "@E 999,999,999.99" FONT oDlg:oFont

@ 2.2 , 15   SAY OemToAnsi(STR0012) FONT oDlg:oFont //"Valor "
@ 2.2 , 25   SAY OemToAnsi(STR0013) FONT oDlg:oFont //"Retenções "
@ 3.6 , 00.8 SAY OemToAnsi(STR0014) FONT oDlg:oFont //"Condição  "
@ 3.6 , 20   SAY OemToAnsi(STR0015) FONT oDlg:oFont //"Natureza  "
@ 4.5 , 00.8 SAY OemToAnsi(STR0016) FONT oDlg:oFont //"Valor Liquido "
@ 4.5 , 20   SAY OemToAnsi(STR0017) FONT oDlg:oFont //"Qtde Parcelas  "

@ 3.6,  10 MSGET cCondicao    F3 "SE4" Picture "!!!";
	Valid If( cLiq == "0",ExecBlock("PAGO0124",.F.,.F.),;
	ExecBlock("COBA0124",.F.,.F.) )

@ 3.6,  28 MSGET cNatureza    F3 "SED" Picture "@!";
	Valid ExistCpo("SED",cNatureza)

@ 4.5 , 10  Say oValorLiq  VAR nValorLiq  Picture "@E 999,999,999.99" FONT oDlg:oFont
@ 4.5 , 30  Say oNroParc   VAR nNroParc   Picture "999"               FONT oDlg:oFont

oGet := MsGetDados():New(75,1,150,312,nOpcx,"ExecBlock('PAGOLOK',.F.,.F.)","ExecBlock('PAGOTOK',.F.,.F.)","",.T.)

ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,if(oGet:TudoOk(),oDlg:End(),nOpca:=0)},{||oDlg:End()})
Return( nOpca )


//-------------------------------------------------------------------
/*/{Protheus.doc} NUMFREE

Valida o número do borderô (Chamado pela função NextnumBor).
Arquivo original: FINXFUN.PRX

@author Alessandro Freire
@since 15/12/1997
/*/
//-------------------------------------------------------------------
Function NumFree( cNumBor, cPgRec )

LOCAL cOldAlias   := Alias()
LOCAL nOldOrd     := IndexOrd()
LOCAL nSavRec     := 0
LOCAL lReturn     := .T.

If Upper(cPgRec) == "P"
	dbSelectArea( "SEA" )
	nSavRec     := RecNo()
	dbSetOrder(1)
	dbSeek( xFilial("SEA")+cNumBor )
	While SEA->EA_FILIAL == xFilial("SEA") .and. SEA->EA_NUMBOR == cNumBor
		If SEA->EA_CART == "P"
			lReturn  := .F.
		EndIf
	EndDo
Else
	dbSelectArea("SE1")
	nSavRec     := RecNo()
	dbSetOrder(5)
	If dbSeek(xFilial("SE1")+cNumBor)
		lReturn  := .F.
	EndIf
EndIf

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³ Retorna ao registro e alias original                 ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbGoTo( nSavRec )
dbSelectArea( cOldAlias )
dbSetOrder( nOldOrd )
Return( lReturn )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±                                                                         ±±
±±            Funcoes retiradas do arquivo MATXATU.PRX                     ±±
±±                                                                         ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

//-------------------------------------------------------------------
/*/{Protheus.doc} RECSALCXA

Funcão para recalcular o saldo do caixinha com base na tabela SEU.

Arquivo original: MATXATU.PRX

@author TOTVS
@since 13/11/2009
/*/
//-------------------------------------------------------------------
Function RecSalCxa( cCaixa )
Local aAreaSET	:= SET->( GetArea() )

If Empty( cCaixa )
	Return
EndIf

DbSelectArea( "SET" )
SET->( DbSetOrder( 1 ) )
If SET->( DbSeek( xFilial( "SET" ) + cCaixa ) )
	If FIJ->( !DbSeek( xFilial( "FIJ" ) + SET->ET_ULTREP + cCaixa ) )
		RecLock( "FIJ", .T. )
		FIJ->FIJ_FILIAL := xFilial( "FIJ" )
		FIJ->FIJ_CODCX	:= cCaixa
		FIJ->FIJ_DATA	:= SET->ET_ULTREP
		FIJ->FIJ_SALDO	:= SET->ET_SALDO
		MsUnlock()
	EndIf
EndIf

RestArea( aAreaSET )
Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±                                                                         ±±
±±           INICIO - Funcoes retiradas do arquivo FINA050.PRX             ±±
±±                                                                         ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/

//-------------------------------------------------------------------
/*/{Protheus.doc} fa050Rate

Rateia o valor do titulo em v rios Centro de Custos.

@author Wagner Xavier
@since  18/05/93
@version 12
/*/
//-------------------------------------------------------------------
Function fa050Rate( cPadrao,cProg,cOperacao,nHdlPrv,cArquivo )

    Local lPanelFin := IsPanelFin()
    LOCAL nOpcA 	 :=0
    LOCAL cArq 		 := Space(8)
    LOCAL lEstornou := .F.
    LOCAL nColunas
    LOCAL oDlg
    LOCAL oGet
    LOCAL j
    LOCAL cRateio
    LOCAL nMostra
    Local nInss := 0
    Local lF050ACOL := ExistBlock("F050ACOL")

    //Controla o Pis Cofins e Csll na baixa
    Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
    Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)
    Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
    Local lInssBX :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"
    PRIVATE aGETS[0]
    PRIVATE cPrograma := cProg
    PRIVATE nValRat	:=0
    PRIVATE aCols		:= {}
    PRIVATE aHeader	:= {}
    PRIVATE nUsado 	:= 0
    PRIVATE oValRat

    If !lInssBX
        If cPrograma == "FINA050"
            nInss := SE2->E2_INSS
            IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
                nInss := 0
            Endif
        Endif
    Endif

    //³ Definicao de variaveis para posicionamento relativo na tela  ³
    nColunas  := IIF( cPrograma == "FINA050" , IIF(mv_par03==1,7,5) , IIF(mv_par03==1,7,5) )

    cOperacao := Iif(cOperacao == NIL,"I",cOperacao)

    aCampos := { { "I2_CCD"    , "ExistCpo('SI3').or.vazio()",OemToAnsi(STR0020)},;
    { "I2_ITEMD"  , "ExistCpo('SID').or.vazio()",OemToAnsi(STR0028)},;
    { "I2_ITEMC"  , "ExistCpo('SID').or.vazio()",OemToAnsi(STR0029)},;
    { "E2_PORCJUR", "fa050CalcP('"+cProg+"')",OemToAnsi(STR0021)},;
    { "I2_VALOR"  , "fa050CalcV('"+cProg+"')",OemToAnsi(STR0022)},;
    { "I2_DEBITO" , "ExistCpo('SI1').or.vazio()",OemToAnsi(STR0023)},;
    { "I2_CREDITO", "ExistCpo('SI1').or.vazio()",OemToAnsi(STR0024)} }

    If cOperacao == "E"
        If cPrograma == "FINA050"
            cArqRat := Alltrim(SE2->E2_ARQRAT)
            cRateio := SE2->E2_RATEIO
        Endif
        If cPrograma == "FINA100"
            cArqRat := Alltrim(SE5->E5_ARQRAT)
            cRateio := SE5->E5_RATEIO
        Endif
        IF cRateio == "S"
            lEstornou := fa050Carr(nUsado,cArqRat,@cArquivo,@nHdlPrv)
        Endif
    Endif

    If !lEstornou
        //³ Montagem da matriz aHeader											  ³
        nUsado := 0
        For j:=1 To nColunas
            nUsado++
            IF j == 1
                AADD(aHeader,{OemToAnsi(STR0020),"I2_CCD","@!",; // "Centro Custo"
                9,0,"ExistCpo('SI3').or.vazio()","û","C","SI2" } )
            ElseIf j == 2
                AADD(aHeader,{OemToAnsi(STR0028),"I2_ITEMD","@!",; // "Item Debito"
                9,0,"ExistCpo('SID').or.vazio()","û","C","SI2" } )
            ElseIf j == 3
                AADD(aHeader,{OemToAnsi(STR0029),"I2_ITEMC","@!",; // "Item Credito"
                9,0,"ExistCpo('SID').or.vazio()","û","C","SI2" } )
            Elseif j == 4
                AADD(aHeader,{OemToAnsi(STR0021),"E2_PORCJUR","999.99",; //  "Porcent"
                3,0,"fa050CalcP('"+cProg+"')","û","N","SE2" } )
            Elseif j == 5
                AADD(aHeader,{OemToAnsi(STR0022),"I2_VALOR","@E 9999,999,999.99",; // "Valor"
                14,2,"fa050CalcV('"+cProg+"')","û","N","SI2" } )
            Elseif j == 6
                AADD(aHeader,{OemToAnsi(STR0023),"I2_DEBITO","@!",;  //  "Conta Debito"
                20,0,"Vazio().Or.ca050cta(,6)","û","C","SI2" } )
            Else
                AADD(aHeader,{OemToAnsi(STR0024),"I2_CREDITO","@!",; // "Conta Credito"
                20,0,"Vazio().Or.ca050cta(,7)","û","C","SI2" } )
            Endif
        Next j

        //³ Cria aCOLS de acordo com Tamanho do Arquivo enviado  ³
        AADD(aCols,Array(nUsado+1))
        nUsado := 0

        For j:=1 To nColunas
            nUsado++
            IF aHeader[j][8] == "C"
                aCols[1][nUsado] := Space(aHeader[j][4])
            Else
                aCols[1][nUsado] := 0
            EndIf
        Next j
        aCols[1][nUsado+1] := .F.

        //³ Ponto de entrada para pr-inicializar aCOLS de Rateio³
        If lF050ACOL
            nMostra := ExecBlock("F050ACOL",.F.,.F.)
        Endif

        //³ Mostra o corpo da rateio 									 ³
        nOpca := 0
        If	Valtype(nMostra) != "N"
            If cPrograma == "FINA050"
                While nOpca == 0
                    DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0025) From 9,0 To 28,80 OF oMainWnd	//	"Rateios"
                    oDLg:lMaximized := .F.
                    @ 1.6 , 1.4	Say OemToAnsi(STR0018) + SE2->E2_FORNECE	FONT oDlg:oFont		// "Fornecedor: "
                    @ 1.6 , 7.6	Say OemToAnsi(STR0019) + SE2->E2_LOJA		FONT oDlg:oFont		// "Loja: "
                    @ 1.6 , 19   	Say OemToAnsi(STR0026) + SE2->E2_PREFIXO	FONT oDlg:oFont		// "Prefixo: "
                    @ 1.6 , 24   	Say OemToAnsi(STR0027) + SE2->E2_NUM		FONT oDlg:oFont		// "N£mero T¡tulo: "
                    @ 1.6 , 41   	Say OemToAnsi(STR0030) + SE2->E2_PARCELA	FONT oDlg:oFont		// "Parcela: "
                    @ 10.0 , 1.4 	Say OemToAnsi(STR0031)							FONT oDlg:oFont 		// "Valor T¡tulo: "
                    @ 10.0 , 7.6 	Say Iif(mv_par06==1,;
                    SE2->(E2_VALOR + If(lIRPFBaixa .And. ! (SE2->E2_TIPO $ MVPAGANT),0,E2_IRRF) +;
                    If(!lCalcIssBx,E2_ISS,0)+E2_RETENC+E2_SEST+IIF(lPccBaixa,0,E2_PIS+E2_COFINS+E2_CSLL))+nInss,;
                    SE2->E2_VALOR) Picture PesqPict("SE2","E2_VALOR",14) 					FONT oDlg:oFont ;
                    COLOR CLR_HBLUE
                    @ 10.0 , 24 	Say OemToAnsi(STR0032)  						FONT oDlg:oFont		// "Valor Rateio: "
                    @ 10.0 , 32  	Say oValRat VAR nValRat Picture PesqPict("SE2","E2_VALOR",14);
                    FONT oDlg:oFont COLOR CLR_HBLUE
                    @ 1.0, 0.5 To 2.35,18 OF oDlg
                    @ 1.0 ,18.6 To 2.35,39 OF oDlg
                    oGet := MSGetDados():New(34,5,128,315,3,"Fa050LinOk", "Fa050TudOk('"+cProg+"')","",.T., , ,.f.)

                    If lPanelFin //Chamado pelo Painel Financeiro
                        ACTIVATE MSDIALOG oDlg CENTERED ON INIT FaMyBar(oDlg,{||nOpca:=1,if(fa050TudOk(cProg),oDlg:End(),nOpca := 0)},{||oDlg:End()})
                    Else
                        ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,if(fa050TudOk(cProg),oDlg:End(),nOpca := 0)},{||oDlg:End()})
                    Endif

                EndDo
            Else
                While nOpca == 0
                    DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0025) From 9,0 To 28,80 OF oMainWnd  // "Rateios"
                    oDLg:lMaximized := .F.
                    @ 1.6,1.4 	SAY OemToAnsi(STR0033) + DtoC(SE5->E5_DATA)  FONT oDlg:oFont 	// "Data: "
                    @ 1.6,19	   SAY OemToAnsi(STR0034) + SE5->E5_DOCUMEN FONT oDlg:oFont  			//"Doc.: "
                    @ 10.0 , 1.4 	Say OemToAnsi(STR0031)							FONT oDlg:oFont 		// "Valor T¡tulo: "
                    @ 10.0 , 7.6 	Say SE5->E5_VALOR			Picture PesqPict("SE5","E5_VALOR",14) 					FONT oDlg:oFont ;
                    COLOR CLR_HBLUE
                    @ 10.0 , 24 	Say OemToAnsi(STR0032)  						FONT oDlg:oFont		// "Valor Rateio: "
                    @ 10.0 , 32  	Say oValRat VAR nValRat Picture PesqPict("SE2","E2_VALOR",14);
                    FONT oDlg:oFont COLOR CLR_HBLUE
                    @ 1.0, 0.5 To 2.35,39 OF oDlg

                    oGet := MSGetDados():New(34,5,128,315,3,"Fa050LinOk","Fa050TudOk('"+cProg+"')","",.T., , ,.f.)

                    If lPanelFin //Chamado pelo Painel Financeiro
                        ACTIVATE MSDIALOG oDlg CENTERED ON INIT FaMyBar(oDlg,{||nOpca:=1,if(fa050TudOk(cProg),oDlg:End(),nOpca := 0)},{||oDlg:End()})
                    Else
                        ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,if(fa050TudOk(cProg),oDlg:End(),nOpca := 0)},{||oDlg:End()})
                    Endif

                EndDo
            Endif
        Else
            nOpca := 1
            fa050TudOk(cProg)
        Endif
        If nOpca == 1
            Fa050OnLine( @cArq, cOperacao, cPrograma, cPadrao )
        Endif
    Endif

Return cArq

//-------------------------------------------------------------------
/*/{Protheus.doc} FA050CalcP

Calcula o porcentual digitado para rateio no Centro Custo

@author Wagner Xavier
@since  18/05/93
@version 12
/*/
//-------------------------------------------------------------------
Function FA050CalcP(cPrograma)

    LOCAL nCont
    Local nInss := 0
    //Controla o Pis Cofins e Csll na baixa
    Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
    Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)
    Local lCalcIssBx :=	IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
    Local lInssBX :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"

    nPorcent := &(ReadVar())

    If nPorcent > 100
        Return .F.
    EndIf

    If !lInssBX
        If cPrograma == "FINA050"
            nInss := SE2->E2_INSS
            IF SED->ED_DEDINSS == "2"  //Nao desconta o INSS do principal
                nInss := 0
            Endif
        Endif
    Endif
    nValRat	:= 0

    IF nPorcent == 0
        aCOLS[n][5] := 0
    Else
        aCOLS[n][5] := NoRound( Iif( cPrograma == "FINA050" 	,;
        Iif(mv_par06==1,;
        SE2->(E2_VALOR + If(lIRPFBaixa .And. ! M->E2_TIPO $ MVPAGANT,0,E2_IRRF) +;
        If(!lCalcIssBx,E2_ISS,0)+E2_RETENC+E2_SEST+IIF(lPccBaixa,0,E2_PIS+E2_COFINS+E2_CSLL))+nInss,;
        SE2->E2_VALOR),;
        SE5->E5_VALOR ) * nPorcent / 100 ,2 )
    Endif

    For nCont := 1 To Len(aCols)
        If ! aCols[nCont][nUsado+1]
            nValRat += aCols[nCont][5]
        EndIF
    Next

    If Type("oValRat")=="O"
        oValRat:Refresh()
    Endif

Return .t.

//-------------------------------------------------------------------
/*/{Protheus.doc} FA050CalcV

Calcula o valor digitado para rateio no Centro Custo

@author Wagner Xavier
@since  18/05/93
@version 12
/*/
//-------------------------------------------------------------------
Function FA050CalcV(cPrograma)

    LOCAL nCont

    nValRat := 0

    aCols[n][5] := &(ReadVar())

    For nCont := 1 To Len(aCols)
        If !aCols[nCont][nUsado+1]
            nValRat += aCols[nCont][5]
        EndIf
    Next

    If Type("oValRat")=="O"
        oValRat:Refresh()
    Endif

Return .t.

//-------------------------------------------------------------------
/*/{Protheus.doc} fa050Carr

Monta exclusão do rateio.

@author Pilar S. Albaladejo
@since  28/08/95
@version 12
/*/
//-------------------------------------------------------------------
Static Function fa050Carr(nUsado,cArqRat,cArquivo,nHdlPrv)

    LOCAL cProva
    LOCAL nHdlRat
    LOCAL nTamArq
    LOCAL xBuffer
    LOCAL cRotina
    LOCAL nBytes
    LOCAL nTotal := 0
    LOCAL cTipo
    LOCAL cDebito
    LOCAL cCredito
    LOCAL cCCD
    LOCAL cCCC
    Local nLin := 0
    Local cHistRat
    Local cOrigem
    Local lF050HST := ExistBlock("F050HST")
    Local lF050ORI := ExistBlock("F050ORI")

    cProva		:= GetMv("MV_PROVA")
    cArqRat 		:=	cProva+cArqRat+".#LA"
    IF (nHdlRat := Fopen(cArqRat)) < 0
        Return .f.
    End

    //³ L o cabealho do arquivo 									³
    nTamArq:=FSEEK(nHdlRat,0,2)
    xBuffer:=Space( 312 )
    FSEEK(nHdlRat,0,0)
    FREAD(nHdlRat,@xBuffer,312)

    cArquivo := Space(10)
    //³ Nome do programa gerador dos lanamentos             ³
    cRotina := SubStr(xBuffer,17,8)
    nBytes  := 0
    nTotal  := 0

    //³ Inicializa Lancamento Contabil                                   ³
    nHdlPrv := HeadProva( cLote,;
    "FINA050" /*cPrograma*/,;
    Substr(cUsuario,7,6),;
    @cArquivo,;
    .T. /*lCria*/ )

    While nBytes < nTamArq

        xBuffer	:=Space(312)
        fRead(nHdlRat,@xBuffer,312)

        If Substr(xBuffer,309,2) == "FF"
            Exit
        EndIf

        nLin++
        cTipo	 	:= SubStr(xBuffer,1,1	)
        cDebito  := SubStr(xBuffer, 2,20)
        cCredito := SubStr(xBuffer,22,20)
        cCCD 	 	:= SubStr(xBuffer,167,9)
        cCCC 	 	:= SubStr(xBuffer,176,9)
        cItemD	:= Substr(xBuffer,251,9)
        cItemC	:= Substr(xBuffer,260,9)

        If cTipo $ "DXC"        // Inverte quando leu uma linha de detalhe
            cDebito  := SubStr(xBuffer,22,20)
            cCredito := SubStr(xBuffer, 2,20)
            cCCD	  	:= SubStr(xBuffer,176,9)
            cCCC	  	:= SubStr(xBuffer,167,9)
            cItemD	:= Substr(xBuffer,260,9)
            cItemC	:= Substr(xBuffer,251,9)
        Endif
        If cTipo == "D"
            cTipo := "C"
        Elseif cTipo == "C"
            cTipo := "D"
        Endif

        cHistRat 	:= Substr(xbuffer,063,040)
        cOrigem		:= Substr(xbuffer,200,040)

        If lF050HST
            cHistRat :=	ExecBlock("F050HST",.f.,.f.,{cHistRat})
            cHistRat := PAD(cHistRat,40)
        EndIF
        If lF050ORI
            cOrigem := 	ExecBlock("F050ORI",.f.,.f.,{cOrigem})
            cOrigem := PAD(cOrigem,40)
        EndIf

        xBuffer := 	cTipo+cDebito+cCredito+SubStr(xBuffer,42,21)+;
        Substr(cHistRat,1,40)+SubStr(xBuffer,103,64)+Cccd+Cccc+;
        Substr(xBuffer,185,15)+Substr(cOrigem,1,40)+Substr(xBuffer,240,1)+;
        cRotina+SubStr(xBuffer,249,2)+;
        cItemD+cItemC+Substr(xBuffer,269,42)+;
        CHR(13)+CHR(10)

        fWrite(nHdlPrv,xBuffer,312)
        nBytes+=312
    Enddo

    If nLin > 0
        Fwrite(nHdlPrv,xBuffer,312)
    EndIf

Return .t.

//-------------------------------------------------------------------
/*/{Protheus.doc} FA050TudOK

Analisa a tela digitada

@author Wagner Xavier
@since  18/05/93
@version 12
/*/
//-------------------------------------------------------------------
Function FA050TudOK(cPrograma)

    LOCAL n,lRet := .T.
    LOCAL nValorRat := 0
    Local nInss := 0
    //Controla o Pis Cofins e Csll na baixa
    Local lPCCBaixa := SuperGetMv("MV_BX10925",.T.,"2") == "1"
    Local lIRPFBaixa := IIf( cPaisLoc == "BRA", SA2->A2_CALCIRF == "2", .F.)
    Local lCalcIssBx := IIF(lIsIssBx, IsIssBx("P"), SuperGetMv("MV_MRETISS",.F.,"1") == "2" )
    Local lInssBx :=	SuperGetMv("MV_INSBXCP",.F.,"2") == "1"

    If !lInssBx
        If cPrograma == "FINA050"
            nInss := M->E2_INSS
            IF SED->ED_DEDINSS == "2"  //desconta o INSS do principal
                nInss := 0
            Endif
        EndIf
    Endif

    FOR n:=1 TO LEN(aCOLS)
        If !aCOLS[n][nUsado+1]		// SE no  deletado
            nValorRat += aCols[n][5]
        Endif
    NEXT n

    If lF050RAT
        lRet := ExecBlock("F050RAT",.F.,.F.)
        Return lRet
    EndIf

    IF Str( nValorRat,17,2 ) != IIF(cPrograma == "FINA050",;
    Str(IIF(mv_par06==1,;
    SE2->(E2_VALOR+If(lIRPFBaixa,0,E2_IRRF)+If(!lCalcIssBx,E2_ISS,0)+E2_RETENC+E2_SEST+IIF(lPccBaixa,0,E2_PIS+E2_COFINS+E2_CSLL))+nInss,;
    SE2->E2_VALOR),17,2 ),Str( SE5->E5_VALOR,17,2 ))
        Help( " ", 1, "FA050RATEI")
        lRet := .F.
    Endif

    If UsaSeqCor()
        If !CTBvldDiario(M->E1_DIACTB,dDataBase)
            Return(.F.)
        EndIf
    EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa050OnLine

Verifica se a contabilizacao deve ser on-line e a executa

@author Alessandro Freire
@since  13/02/96
@version 12
/*/
//-------------------------------------------------------------------
Function Fa050OnLine( cArq, cOperacao, cPrograma, cPadrao )

    Local nHandle
    Local lResult := .T.

    If mv_par04 == 1			// Contabiliza On-Line
        If cOperacao == "I" .And. cPrograma $ "FINA050/FINA100"
            //³ É preciso gerar um arquivo texto nesta contabilizacao, pois ³
            //³ podera existir a sua exclusao e deve-se trazer na tela o que³
            //³ ja foi contabilizado													 ³
            cArq	:= "RT"+cEmpAnt+GetSX8Num("CPR")
            ConfirmSx8()
            Fa050Off(aCols,cPadrao,cLote,cArq,mv_par04,cPrograma,nHandle)
        EndIF
        fa050MontC( cPadrao,nHandle )
    ElseIf mv_par04 != 1 	// Para evitar o K_ESC
        If cOperacao == "I"
            cArq	:= "RT"+cEmpAnt+GetSX8Num("CPR")
            ConfirmSx8()
            Fa050Off(aCols,cPadrao,cLote,cArq,mv_par04,cPrograma,nHandle)
        Endif
    EndIf

Return ( lResult )

//-------------------------------------------------------------------
/*/{Protheus.doc} FA050LinOK

Analisa a linha digitada

@author Wagner Xavier
@since  18/05/93
@version 12
/*/
//-------------------------------------------------------------------
Function FA050LinOK()
    
    Local lRet := .T.
    Local lF050LRat := ExistBlock("F050LRAT") // Validar a inclusao da linha do rateio on-line

    // Se existir o PE F050LRAT, utiliza o retorno do PE para validar a linha
    If lF050LRat
        lRet := ExecBlock("F050LRAT", .F., .F. )
    Endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FA050MontC

Monta lançamento contabil em funcao do rateio digitado 

@author Wagner Xavier
@since  18/05/93
@version 12
/*/
//-------------------------------------------------------------------
Function FA050MontC( cPadrao, nHandle )

    Local lResult		:= .T.
    LOCAL cArquivo
    LOCAL nTotal		:=0
    LOCAL nHdlPrv		:=0
    LOCAL lDigita
    LOCAL nLinha
    LOCAL nCont			:=0
    LOCAL nSomaAcols	:=0
    Local lAglutina
    Local aFlagCTB := {}
    Local lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)

    //Nova estrutura SE5
    Local oModel
    Local oSubFK5
    Local oSubFKA
    Local cLog := ""
    Local aAreaAnt

    For nCont := 1 TO Len(aCols)
        If !(aCols[nCont][nUsado+1])
            nSomaAcols++
        Endif
    Next nCont

    If nSomaAcols != 0
        //³ Inicializa Lancamento Contabil                                   ³
        nHdlPrv := HeadProva( cLote,;
        cPrograma,;
        Substr(cUsuario,7,6),;
        @cArquivo )
        nLinha := 0
        While nLinha < Len(aCols)
            nLinha++
            If !aCols[nLinha][nUsado+1]
                Custo  := aCols[nLinha][1]
                ItemD	 := aCols[nLinha][2]
                ItemC  := aCols[nLinha][3]
                Valor  := xMoeda(aCols[nLinha][5],SE2->E2_MOEDA,1)
                If SE2->E2_MOEDA > 1
                    //³ Carrega em VALOR o valor referente ao campo E2_VLCRUZ³
                    //³ que  o valor em REAIS.                              ³
                    //³ Isto se a moeda do t¡tulo for maior que 1.           ³
                    If ( cPaisLoc == "CHI" )
                        Valor := Round( SE2->E2_VLCRUZ, MsDecimais(1) ) * aCols[nLinha][4] / 100
                    Else
                        Valor := SE2->E2_VLCRUZ * aCols[nLinha][4] / 100
                    Endif
                Endif
                Debito := Iif(mv_par03==1,aCols[nLinha][6],"")
                Credito:= Iif(mv_par03==1,aCols[nLinha][7],"")
                VlrInStr := Valor

                //³ Prepara Lancamento Contabil                                      ³
                //Contabiliza pela variavel VALOR. Nao necessita de controle de flag.
                nTotal += DetProva( nHdlPrv,;
                cPadrao,;
                cPrograma,;
                cLote,;
                0 /*nLinha*/,;
                .F. /*lExecuta*/,;
                cPrograma /*cCriterio*/,;
                /*lRateio*/,;
                /*cChaveBusca*/,;
                /*aCT5*/,;
                /*lPosiciona*/,;
                /*@aFlagCTB*/,;
                /*aTabRecOri*/,;
                /*aDadosProva*/ )
            Endif
        Enddo // While nLinha < Len(aCols)

        Valor := 0
        VlrInStr := 0
        //³ Prepara Lancamento Contabil                                      ³
        If lUsaFlag  // Armazena em aFlagCTB para atualizar no modulo Contabil
            If cPrograma == "FINA050"
                aAdd( aFlagCTB, {"E2_LA", "S", "SE2", SE2->( Recno() ), 0, 0, 0} )
            Else
                aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
            Endif
        Endif
        nTotal += DetProva( nHdlPrv,;
        cPadrao,;
        cPrograma,;
        cLote,;
        0 /*nLinha*/,;
        .T. /*lExecuta*/,;
        cPrograma /*cCriterio*/,;
        /*lRateio*/,;
        /*cChaveBusca*/,;
        /*aCT5*/,;
        /*lPosiciona*/,;
        @aFlagCTB,;
        /*aTabRecOri*/,;
        /*aDadosProva*/ )

        lDigita := IIF( cPrograma == "FINA050" , IIF(mv_par01==1,.T.,.F.) , Iif(mv_par02==1,.t.,.f.) )
        If cPrograma == "FINA050"
            lAglutina	:= Iif(mv_par07 == 1,.T.,.F.)
        Else
            lAglutina	:= .F.
        EndiF
        If  UsaSeqCor()
            aDiario := {}
            aDiario := {{"SE2",SE2->(recno()),SE2->E2_DIACTB,"E2_NODIA","E2_DIACTB"}}
        Else
            aDiario := {}
        EndIf
        //³ Envia para Lanamento Contabil                      ³
        RodaProva( nHdlPrv,;
        nTotal )
        cA100Incl( cArquivo,;
        nHdlPrv,;
        3 /*nOpcx*/,;
        cLote,;
        lDigita,;
        lAglutina,;
        /*cOnLine*/,;
        /*dData*/,;
        /*dReproc*/,;
        @aFlagCTB,;
        /*aDadosProva*/,;
        aDiario )
        aFlagCTB := {}  // Limpa o coteudo apos a efetivacao do lancamento

        If !lUsaFlag
            If cPrograma == "FINA050"
                dbSelectArea("SE2")
                //³ Atualiza flag de Lanamento Cont bil       ³
                Reclock("SE2")
                Replace E2_LA With "S"
            Else
                dbSelectArea("SE5")
                //³ Atualiza flag de Lanamento Cont bil       ³
                aAreaAnt := GetArea()

                oModel :=  FWLoadModel('FINM030')//Mov. Bancarios Manual
                oModel:SetOperation( 4 ) //Alteração
                oModel:Activate()
                oSubFKA := oModel:GetModel( "FKADETAIL" )
                oSubFKA:SeekLine( 	{ {"FKA_IDORIG", SE5->E5_IDORIG } } )

                //Dados do movimento
                oSubFK5 := oModel:GetModel( "FK5DETAIL" )
                oSubFK5:SetValue( "FK5_LA", "S" )

                If oModel:VldData()
                    oModel:CommitData()
                    oModel:DeActivate()
                Else
                    cLog := cValToChar(oModel:GetErrorMessage()[4]) + ' - '
                    cLog += cValToChar(oModel:GetErrorMessage()[5]) + ' - '
                    cLog += cValToChar(oModel:GetErrorMessage()[6])
                    Help( ,,"M050VALID",,cLog, 1, 0 )
                Endif
                RestArea(aAreaAnt)
            Endif
        Endif
    Endif

Return ( lResult ) // FA050MontC

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa050Off

Gera o arquivo de "Contra-Prova" p/ os rateios Financeiro

@author Pilar S. Albaladejo
@since  24/08/95
@version 12
/*/
//-------------------------------------------------------------------
Function Fa050Off(aCols,cPadrao,cLote,cArq,nContab,cPrograma,nHandle)

    LOCAL nCont
    LOCAL nTotal		:=0
    LOCAL nHdlPrv		:=0
    LOCAL nSomaAcols	:=0
    LOCAL nLinha		:=0

    FOR nCont := 1 TO Len(aCols)
        If !(aCols[nCont][nUsado+1])
            nSomaAcols++
        Endif
    NEXT nCont

    If nSomaAcols != 0
        nHdlPrv :=  Fa050Head(cLote,cArq,nContab,cPrograma)
        nLinha := 0
        While nLinha < Len(aCols)
            nLinha++
            If !aCols[nLinha][nUsado+1]
                Custo 	:= aCols[nLinha][1]
                ItemD		:= aCols[nLinha][2]
                ItemC		:= aCols[nLinha][3]
                Valor 	:= xMoeda(aCols[nLinha][5],SE2->E2_MOEDA,1)
                VlrInStr := Valor
                Debito	:= Iif(mv_par03==1,aCols[nLinha][6],"")
                Credito	:= Iif(mv_par03==1,aCols[nLinha][7],"")
                nTotal+=fa050det(nHdlPrv,cPadrao,.f.)
            Endif
        Enddo
        Valor	  := 0
        VlrInStr := 0
        nTotal+=fa050det(nHdlPrv,cPadrao,.t.)
        fa050Roda(nHdlPrv,nTotal)
        fClose( nHdlPrv )
    Endif

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fa050Head

Grava a linha de cabecalho dos rateios off-line -financeiro

@author Pilar S. Albaladejo
@since  24/08/95
@version 12
/*/
//-------------------------------------------------------------------
Function fa050Head(cLote,cArq,nContab,cPrograma)

    LOCAL cData
    LOCAL nHdlPrv
    LOCAL cOperador
    LOCAL cProva
    LOCAL cArquivo
    Local cSet
    Local nSaveSx8 := GetSx8Len()

    cSet := Set(_SET_DATEFORMAT)
    Set(_SET_DATEFORMAT,"dd/mm/yyyy")

    cData 	:= Iif(cPrograma=="FINA050",DtoC(SE2->E2_EMISSAO),DtoC(SE5->E5_DATA))
    cProva	:= GetMv("MV_PROVA")
    cOperador:= SubStr(cUsuario,7,6)

    If nContab == 1
        cArquivo := cProva+cArq+".#LA"
    Else
        cArquivo := cProva+cArq+".LAN"
    EndIf

    cPrograma := SubStr(cPrograma+Space(8-Len(cPrograma)),1,8)
    //³ Cria o arquivo de LOG para LA							  ³
    nHdlPrv	:= MSFCREATE(cArquivo,0)
    IF nHdlPrv > 0
        FWRITE(nHdlPrv,"00"+cData+cLote+cPrograma+cOperador+xFilial("SI2")+Space(278)+CHR(13)+CHR(10),312)
        While (GetSx8Len() > nSaveSx8 )
            ConfirmSX8()
        Enddo
        Commit
    Else
        While (GetSx8Len() > nSaveSx8 )
            RollBackSX8()
        Enddo
        HELP(" ",1,"HDLNAOGERA")
    EndIF

    Set(_SET_DATEFORMAT,cSet)

Return nHdlPrv

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa050Det

Grava as linhas de detalhe dos rateios off-line -financeiro

@author Pilar S. Albaladejo
@since  24/08/95
@version 12
/*/
//-------------------------------------------------------------------
Function Fa050Det(nHdlPrv,cPadrao,lExecuta)

    LOCAL aContas[18]
    LOCAL nTotal := 0
    Local cSet, cHist, cHistorico, n

    cSet := Set(_SET_DATEFORMAT)
    Set(_SET_DATEFORMAT,"dd/mm/yyyy")

    //³ Gravar o DETALHE do Arquivo gerado 					  ³
    dbSelectArea("SI5")
    dbSeek(cFilial+cPadrao)
    While !Eof() .And. I5_FILIAL == cFilial .And. cPadrao==I5_CODIGO
        //³ Tipo do Lancamento 				 	³
        aContas[1]:=I5_DC

        aContas[2] :=TranslCta(I5_DEBITO, 20)
        aContas[3] :=TranslCta(I5_CREDITO,20)
        aContas[4] := 0

        //³ Vlr Moeda1 ³
        cValor1	:= Trim(I5_CPOVAL1)

        If lExecuta
            If Alltrim(Upper(cValor1)) == "VALOR" .or. "VLRINSTR" $ Upper(cValor1)
                dbSkip()
                Loop
            Endif
        Endif

        If !lExecuta
            If ! (Alltrim(Upper(cValor1)) == "VALOR" .or. "VLRINSTR" $ Upper(cValor1))
                dbSkip()
                Loop
            Endif
        Endif

        If !Empty(cValor1)
            aContas[4]:=&(cValor1)
        Endif

        //³ Moedas 	   ³
        aContas[5]	:= I5_MOEDAS

        //³ Historico 	   ³
        aContas[6]	:= TranslCta(I5_HISTORI,240)

        //³ Outras Moedas ³
        aContas[7] := 0
        aContas[8] := 0
        aContas[9] := 0
        aContas[10]:= 0
        aContas[17]:=TranslCta(I5_ITEMD,9)
        aContas[18]:=TranslCta(I5_ITEMC,9)

        //³ C.Custo Debito e Credito  ³
        aContas[11] := TranslCta(I5_CCD, 9)
        aContas[12] := TranslCta(I5_CCC, 9)

        //³ Cod/Seq Lanc Padrao		 	³
        aContas[13] :=	I5_CODIGO+I5_SEQUENC

        //³ Data de Vencimento 		 	³
        aContas[14] :=	TranslDta(I5_DTVENC)

        //³ Origem Lancamento			³
        aContas[15] := TranslCta(I5_ORIGEM,40)

        aContas[16] := I5_INTERCP

        If aContas[4] > 0
            //³ Escreve no Arquivo		   ³

            nTotal+=aContas[4]
            If Len(Alltrim(aContas[6])) > 40
                cHistorico := Alltrim(aContas[6])
                For n := 1 to Len(cHistorico) Step 40
                    cHist := Substr(cHistorico,n,40)
                    cHist := cHist + Space(40 - Len(cHist))
                    If n = 1
                        FWRITE( nHdlPrv,aContas[1]+aContas[2]+aContas[3]+;
                        Str(aContas[4],16,2)+aContas[5]+cHist+;
                        Str(aContas[7],16,2)+Str(aContas[8],16,2)+;
                        Str(aContas[9],16,2)+Str(aContas[10],16,2)+;
                        aContas[11]+aContas[12]+aContas[13]+aContas[14]+;
                        aContas[15]+aContas[16]+Space(10)+aContas[17]+;
                        aContas[18]+Space(42)+CHR(13)+CHR(10),312)
                    Else
                        aContas[1]  := "-"
                        aContas[2]  := Space(20)
                        aContas[3]  := Space(20)
                        aContas[4]  := 0
                        aContas[7]  := 0
                        aContas[8]  := 0
                        aContas[9]  := 0
                        aContas[10] := 0
                        aContas[11] := Space(9)
                        aContas[12] := Space(9)
                        aContas[13] := I5_CODIGO+I5_SEQUENC
                        aContas[14] := TranslDta(I5_DTVENC)       //Interpreta data de vencimento
                        aContas[15] := TranslCta(I5_ORIGEM,40)    //Interpreta a origem
                        aContas[16] := Substr(I5_INTERCP,1,1)     //Inter Company
                        aContas[17] := Space(9)
                        aContas[18] := Space(9)

                        FWRITE( nHdlPrv,aContas[1]+aContas[2]+aContas[3]+;
                        Str(aContas[4],16,2)+aContas[5]+cHist+;
                        Str(aContas[7],16,2)+Str(aContas[8],16,2)+;
                        Str(aContas[9],16,2)+Str(aContas[10],16,2)+;
                        aContas[11]+aContas[12]+aContas[13]+aContas[14]+;
                        aContas[15]+aContas[16]+Space(10)+aContas[17]+;
                        aContas[18]+Space(42)+CHR(13)+CHR(10),312)
                    Endif
                Next
            Else
                FWRITE( nHdlPrv,aContas[1]+aContas[2]+aContas[3]+;
                Str(aContas[4],16,2)+aContas[5]+Substr(aContas[6],1,40)+;
                Str(aContas[7],16,2)+Str(aContas[8],16,2)+;
                Str(aContas[9],16,2)+Str(aContas[10],16,2)+;
                aContas[11]+aContas[12]+aContas[13]+aContas[14]+;
                aContas[15]+aContas[16]+Space(10)+aContas[17]+;
                aContas[18]+Space(42)+CHR(13)+CHR(10),312)
            Endif
            dbCommit()
        Endif
        dbSelectArea("SI5")
        dbSkip()
    Enddo
    Set(_SET_DATEFORMAT,cSet)

Return nTotal

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa050Roda

Gera o rodape dos rateios off-line -financeiro

@author Pilar S. Albaladejo
@since  28/08/95
@version 12
/*/
//-------------------------------------------------------------------
Function Fa050Roda(nHdlPrv,nTotal)
    //³ Gravar o TOTAL do Arquivo gerado						  ³
    FWRITE(nHdlPrv,Str(nTotal,16,2)+Space(292)+"FF"+CHR(13)+CHR(10),312)
    dbCommit()
Return

/*/{Protheus.doc} F050VERDES
Validação do campo E2_DESDOBR
@author TOTVS S/A
@since 24/02/2015
@version P12.1.4
@return Retorno Booleano da validação dos dados
/*/
FUNCTION F050VERDES()

    Local lRet := .T.
    //E2_DESDOBR

    If GetMv("MV_RATDESD",,"2") != "1" // Se nao rateia desdobramento
        lRet := (M->E2_RATEIO == "N")
    Endif

RETURN lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F050BlkSA6

Validation for closed banks

@author Flavio Lopes

@since 29/03/2017
@version 12/MA3
/*/
//-------------------------------------------------------------------
Function F050BlkSA6()

    Local lRet := .T.

    If !Empty(M->E2_PORTADO)
        SA6->(DbSetOrder(1))
        If SA6->(DbSeek(xFilial("SE2") + M->E2_PORTADO))
            If SA6->A6_BLOCKED == "1"
                Help("",1,"FA050BANKBLOCK") //This account is blocked and cannot be used.
                lRet := .F.
            Endif
        Endif
    Endif

Return lRet

//-------------------------------------------------------
/*/{Protheus.doc} Fa050CodRat
Analisa a tela digitada

@author Pilar S. Albaladejo.
@since 21/05/01
@version P12
*/
//-------------------------------------------------------
Function Fa050CodRat(cCodRateio,nRadio)

    Local lRet		:= .T.
    Local lF050VLC := ExistBlock("F050VLCOD")

    If nRadio == 2 .And. Empty(cCodRateio)
        lRet := .F.
    EndIf

    If lF050VLC
        lRet := ExecBlock("F050VLCOD",.F.,.F.,{cCodRateio,nRadio})
    EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} Fa050Drop
Funcao que dropara as tabelas temporarias quando utilizado 
banco de dados postgres  

@author Clovis Magenta
@since  09/11/10
/*/
//-------------------------------------------------------------------
Function Fa050Drop()

    Local cAglImPJ	 := SuperGetMv("MV_AGLIMPJ",.T.,"1")

    If Type('cArqTmp') != 'C' 
        cArqTmp := ""
    Endif

    //Fecha arquivo temporario
    If cAglImPJ != "1" .and. !Empty(cArqTmp)
        DELTRBIR(SM0->M0_CODIGO, IIf( lFWCodFil, FWGETCODFILIAL, SM0->M0_CODFIL ),.F.,0,cArqTmp,TCGetDb())
    Endif

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} F050DelPCC
Exclui Impostos PCC

@author Totvs SA
@since  05/11/09
/*/
//-------------------------------------------------------------------
Function F050DelPCC()
    
    Local lRet 		:= .F.
    Local aAreaSE2 := SE2->(GetArea())
    Local aArea 	:= GetArea()
    Local cSE2Fil  := SE2->E2_FILIAL
    Local cPrefixo	:= SE2->E2_PREFIXO
    Local cNum		:= SE2->E2_NUM

    dbSelectArea("SE2")
    dbSetOrder(1)
    If dbSeek(xFilial("SE2")+cPrefixo+cNum)
        While !Eof() .and. SE2->(E2_FILIAL+E2_PREFIXO+E2_NUM) == cSE2Fil+cPrefixo+cNum
            If AllTrim(xFilial("SE2")+cPrefixo+cNum) == AllTrim(E2_FILIAL+E2_PREFIXO+E2_NUM)
                If (SE2->E2_TIPO $ MVTAXA+"/"+MVTXA)
                    If AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_PISNAT"	))  	.Or. ;
                    AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_COFINS"	))  	.Or. ;
                    AllTrim(E2_NATUREZ) = AllTrim(GetMv("MV_CSLL"	))

                        FINDELFKs(xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA,"SE2")
                        SE2->(RecLock("SE2"))
                        SE2->(dbDelete())
                        SE2->(MsUnlock())
                    EndIf
                EndIf
            EndIf
            DbSkip()
        Enddo
    EndIf

    RestArea(aAreaSE2)
    RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F050TXPCC
Grava Impostos Pcc

@author Totvs SA
@since  05/11/09
/*/
//-------------------------------------------------------------------
Function F050TXPCC()

    Local lRet 	  	    := .F.
    Local aAreaSE2	    := SE2->(GetArea())
    Local aArea   	    := GetArea()
    Local nRegSe2       := SE2->(RECNO())
    Local cPrefixo      := SE2->E2_PREFIXO
    Local cNum          := SE2->E2_NUM
    Local cTipoSE2      := SE2->E2_TIPO
    Local dVencrea      := SE2->E2_VENCREA
    Local dVctoReal     := SE2->E2_VENCREA
    Local dEmissao      := SE2->E2_VENCREA
    Local dEmis1        := SE2->E2_VENCREA
    Local cParcPis      := SE2->E2_PARCELA
    Local cParcCsll     := SE2->E2_PARCELA
    Local cParcCof      := SE2->E2_PARCELA
    Local cModSpb       := "1"
    Local lSpbInUse     := SpbInUse()
    Local nValPis       := SE2->E2_VRETPIS
    Local nValCofins    := SE2->E2_VRETCOF
    Local nValCsll      := SE2->E2_VRETCSL
    Local cCodRetPis 	:= ""
    Local cCodRetCof 	:= ""
    Local cCodRetCsl 	:= ""
    Local cGeraDirf 	:= Iif(cPaisLoc == "BRA",SE2->E2_DIRF," ")
    Local cTitPai_Rtr   := Rtrim(SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA))
    Local lCodRtPCC 	:= cPaisLoc == "BRA"
    //Controla o Pis Cofins e Csll na baixa
    Local lPCCBaixa     := SuperGetMv("MV_BX10925",.T.,"2") == "1"
    Local cLojaImp      := PadR( "00", TamSX3("A2_LOJA")[1], "0" )
    Local cCodAprov     := SE2->E2_CODAPRO

    If	(SE2->E2_PIS <= 0 .Or. SE2->E2_COFINS <= 0 .Or. SE2->E2_CSLL <= 0 )
        cCodRetPis := If (lCodRtPCC .and. !Empty(SE2->E2_CODRPIS),SE2->E2_CODRPIS,"5979")
        cCodRetCof := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCOF),SE2->E2_CODRCOF,"5960")
        cCodRetCsl := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCSL),SE2->E2_CODRCSL,"5987")
    Else
        // Se os 3 impostos juntos for maior que a media de retencao, o codigo sera o mesmo
        // para os tres.
        If SE2->(E2_PIS+E2_COFINS+E2_CSLL) > ((GetMv("MV_VRETPIS")+GetMv("MV_VRETCOF")+GetMv("MV_VRETCSL")) / 3)
            cCodRetPis := If (lCodRtPCC .and. !Empty(SE2->E2_CODRPIS),SE2->E2_CODRPIS,"5952")
            cCodRetCof := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCOF),SE2->E2_CODRCOF,"5952")
            cCodRetCsl := If (lCodRtPCC .and. !Empty(SE2->E2_CODRCSL),SE2->E2_CODRCSL,"5952")
        EndIf
    EndIf

    //Verifica se aglutina os impostos em apenas um titulo
    If SuperGetMv("MV_AG10925",.F.,"2") == "1" .and. cCodRetPis == "5952"
        nRefCof := nValCofins //Armazena o valor do Cofins, para recompor os valores apos a geracao dos titulos
        nRefCsl := nValCsll   //Armazena o valor do Csll, para recompor os valores apos a geracao dos titulos

        nValPis += nValCofins + nValCsll
        nValCofins := 0
        nValCsll := 0
    Endif
    // Gera titulo de PIS
    // Cria o fornecedor, caso nao exista
    If nValPis > 0
        dbSelectArea("SA2")
        If !(dbSeek(xFilial("SA2")+GetMv("MV_UNIAO")))
            Reclock("SA2",.T.)
            Replace A2_FILIAL With xFilial("SA2")
            Replace A2_COD    With GetmV("MV_UNIAO")
            Replace A2_NOME	With "UNIAO"
            Replace A2_NREDUZ With "UNIAO"
            Replace A2_LOJA	With cLojaImp
            Replace A2_MUN 	With "."
            Replace A2_EST 	With SuperGetMv("MV_ESTADO")
            Replace A2_BAIRRO With "."
            Replace A2_END 	With "."
            Replace A2_TIPO	With "J"
        EndIF
        dVencRea := F050VImp("PIS",dEmissao,dEmis1,dVctoReal) // Calcula o vencimento do imposto

        // Verifica parcela do PIS caso exista titulo
        // de PIS com o mesmo numero.                
        cParcPis := ParcImposto(cPrefixo,cNum,cTipoSE2)
        // Grava a parcela do PIS no titulo pai fazendo
        // a amarracao titulo x titulo PIS 				
        dbGoto(nRegSe2)
        RecLock("SE2")
        SE2->E2_PARCPIS := cParcPis
        SE2->E2_DIRF    := "2"	// Desmarca titulo principal, pois apenas o titulo de
                                    // imposto var para DIRF
        // Cria a natureza PIS caso nao exista 		
        dbSelectArea("SED")
        cVar := Alltrim(GetMv("MV_PISNAT"))
        cVar := cVar + Space(10-Len(cVar))
        If !(dbSeek(cFilial+cVar))
            RecLock("SED",.T.)
            Replace 	ED_FILIAL  With cFilial,;
            ED_CODIGO  With cVar	,	;
            ED_CALCIRF With "N" 	,	;
            ED_CALCISS With "N"	, 	;
            ED_CALCINS With "N"	,	;
            ED_CALCCSL With "N"  ,	;
            ED_CALCCOF With "N"  ,  ;
            ED_CALCPIS With "N"  ,	;
            ED_DESCRIC With "PIS",  ;
            ED_TIPO	   With "2"
        EndIf
        // Grava titulo de PIS caso no exista anterior.
        RecLock("SE2",.T.)
        SE2->E2_FILIAL		:= cFilial
        SE2->E2_PREFIXO 	:= cPrefixo
        SE2->E2_NUM			:= cNum
        SE2->E2_PARCELA 	:= cParcPis
        SE2->E2_NATUREZ 	:= GetMv("MV_PISNAT")
        SE2->E2_TIPO		:= Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG  .And. !lPCCBaixa,MVTXA,MVTAXA)
        SE2->E2_EMISSAO 	:= dDataBase
        SE2->E2_VALOR		:= nValPis
        SE2->E2_VENCREA 	:= dVencrea
        SE2->E2_SALDO		:= nValPis
        SE2->E2_VENCTO		:= dVencRea
        SE2->E2_VENCORI 	:= dVencRea
        SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U",IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
        SE2->E2_FORNECE		:= GetMv("MV_UNIAO")
        SE2->E2_LOJA 		:= cLojaImp
        SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
        SE2->E2_MOEDA		:= 1
        SE2->E2_VLCRUZ		:= Round( nValPis, MsDecimais(1) )
        SE2->E2_TITPAI      := cTitPai_Rtr
        SE2->E2_CODAPRO		:= cCodAprov
        SE2->E2_ORIGEM		:= "FINA050"
        If lSpbInUse
            Replace	SE2->E2_MODSPB with cModSpb
        EndIf

        SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
        SE2->E2_DIRF    := cGeraDirf
        SE2->E2_CODRET  := cCodRetPis
        MsUnlock()
		FKCOMMIT()		

        // Grava o lancamento de PIS no PCO
        PCODetLan("000002","10","FINA050")
    Endif

    // Gera titulo de COFINS							 
    // Cria o fornecedor, caso nao exista			 
    If nValCofins > 0
        dbSelectArea("SA2")
        If !(dbSeek(xFilial("SA2")+GetMv("MV_UNIAO")))
            Reclock("SA2",.T.)
            Replace A2_FILIAL With xFilial("SA2")
            Replace A2_COD    With GetmV("MV_UNIAO")
            Replace A2_NOME	With "UNIAO"
            Replace A2_NREDUZ With "UNIAO"
            Replace A2_LOJA	With cLojaImp
            Replace A2_MUN 	With "."
            Replace A2_EST 	With SuperGetMv("MV_ESTADO")
            Replace A2_BAIRRO With "."
            Replace A2_END 	With "."
            Replace A2_TIPO	With "J"
        Endif
        dVencRea := F050VImp("COFINS",dEmissao,dEmis1,dVctoReal) // Calcula o vencimento do imposto
        // Verifica parcela do COFINS caso exista titulo
        // de COFINS com o mesmo numero.                
        cParcCof := ParcImposto(cPrefixo,cNum,cTipoSE2)
        // Grava a parcela do COFINS no titulo pai fazendo
        // a amarracao titulo x titulo COFINS	   			
        dbGoto(nRegSe2)
        RecLock("SE2")
        SE2->E2_PARCCOF 	:= cParcCof
        SE2->E2_DIRF    	:= "2"	 // Desmarca titulo principal, pois apenas o titulo de
        // imposto var para DIRF
        // Cria a natureza COFINS caso nao exista 	
        dbSelectArea("SED")
        cVar := Alltrim(GetMv("MV_COFINS"))
        cVar := cVar + Space(10-Len(cVar))
        If !(dbSeek(cFilial+cVar))
            RecLock("SED",.T.)
            Replace 	ED_FILIAL  With cFilial,;
            ED_CODIGO  With cVar	,	;
            ED_CALCIRF With "N" 	,	;
            ED_CALCISS With "N"	, 	;
            ED_CALCINS With "N"	,	;
            ED_CALCCSL With "N"  ,	;
            ED_CALCCOF With "N"  ,  ;
            ED_CALCPIS With "N"  ,	;
            ED_DESCRIC With "COFINS",;
            ED_TIPO	   With "2"
        Endif
        // Grava titulo de COFINS caso no exista anterior.
        RecLock("SE2",.T.)
        SE2->E2_FILIAL		:= cFilial
        SE2->E2_PREFIXO 	:= cPrefixo
        SE2->E2_NUM			:= cNum
        SE2->E2_PARCELA 	:= cParcCof
        SE2->E2_NATUREZ 	:= GetMv("MV_COFINS")
        SE2->E2_TIPO        := Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG  .And. !lPCCBaixa,MVTXA,MVTAXA)
        SE2->E2_EMISSAO 	:= dDataBase
        SE2->E2_VALOR		:= nValCofins
        SE2->E2_VENCREA 	:= dVencrea
        SE2->E2_SALDO		:= nValCofins
        SE2->E2_VENCTO		:= dVencRea
        SE2->E2_VENCORI 	:= dVencRea
        SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U", IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
        SE2->E2_FORNECE		:= GetMv("MV_UNIAO")
        SE2->E2_LOJA 		:= cLojaImp
        SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
        SE2->E2_MOEDA		:= 1
        SE2->E2_VLCRUZ		:= Round( nValCofins, MsDecimais(1) )
        SE2->E2_TITPAI    	:= cTitPai_Rtr
        SE2->E2_CODAPRO		:= cCodAprov
        SE2->E2_ORIGEM		:= "FINA050"
        If lSpbInUse
            Replace	SE2->E2_MODSPB with cModSpb
        EndIf
        SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
        SE2->E2_DIRF    := cGeraDirf
        SE2->E2_CODRET  := cCodRetCof
        MsUnlock()
		FKCOMMIT()		

        // Gera o lancamento de COFINS no PCO
        PCODetLan("000002","11","FINA050")
    EndIf
    // Gera titulo de CSLL							 
    // Cria o fornecedor, caso nao exista			 
    If nValCsll > 0
        dbSelectArea("SA2")
        If !(dbSeek(xFilial("SA2")+GetMv("MV_UNIAO")))
            Reclock("SA2",.T.)
            Replace A2_FILIAL With xFilial("SA2")
            Replace A2_COD    With GetmV("MV_UNIAO")
            Replace A2_NOME	With "UNIAO"
            Replace A2_NREDUZ With "UNIAO"
            Replace A2_LOJA	With cLojaImp
            Replace A2_MUN 	With "."
            Replace A2_EST 	With SuperGetMv("MV_ESTADO")
            Replace A2_BAIRRO With "."
            Replace A2_END 	With "."
            Replace A2_TIPO	With "J"
        EndIf
        dVencRea := F050VImp("CSLL",dEmissao,dEmis1,dVctoReal) // Calcula o vencimento do imposto

        // Verifica parcela do CSLL caso exista titulo
        // de CSLL com o mesmo numero.                
        cParcCsll := ParcImposto(cPrefixo,cNum,cTipoSE2)
        // Grava a parcela do CSLL no titulo pai fazendo
        // a amarracao titulo x titulo CSLL   			 
        dbGoto(nRegSe2)
        RecLock("SE2")
        SE2->E2_PARCSLL 	:= cParcCsll
        SE2->E2_DIRF    	:= "2"	 // Desmarca titulo principal, pois apenas o titulo de
        // imposto vai para DIRF
        // Cria a natureza CSLL caso nao exista 	
        dbSelectArea("SED")
        cVar := Alltrim(GetMv("MV_CSLL"))
        cVar := cVar + Space(10-Len(cVar))
        If !(dbSeek(cFilial+cVar))
            RecLock("SED",.T.)
            Replace 	ED_FILIAL  With cFilial,;
            ED_CODIGO  With cVar	,	;
            ED_CALCIRF With "N" 	,	;
            ED_CALCISS With "N"	, 	;
            ED_CALCINS With "N"	,	;
            ED_CALCCSL With "N"  ,	;
            ED_CALCCOF With "N"  ,  ;
            ED_CALCPIS With "N"  ,	;
            ED_DESCRIC With "CSLL", ;
            ED_TIPO	   With "2"
        EndIf

        // Grava titulo de CSLL caso no exista anterior.
        RecLock("SE2",.T.)
        SE2->E2_FILIAL		:= cFilial
        SE2->E2_PREFIXO 	:= cPrefixo
        SE2->E2_NUM			:= cNum
        SE2->E2_PARCELA 	:= cParcCsll
        SE2->E2_NATUREZ 	:= GetMv("MV_CSLL")
        SE2->E2_TIPO		:= Iif(cTipoSE2 $ MVPAGANT+"/"+MV_CPNEG  .And. !lPCCBaixa,MVTXA,MVTAXA)
        SE2->E2_EMISSAO 	:= dDataBase
        SE2->E2_VALOR		:= nValCsll
        SE2->E2_VENCREA 	:= dVencrea
        SE2->E2_SALDO		:= nValCsll
        SE2->E2_VENCTO		:= dVencRea
        SE2->E2_VENCORI 	:= dVencRea
        SE2->E2_EMIS1		:= IIf(Type("dDataEmis1") # "U", IIf(!Empty(dDataEmis1),dDataEmis1,dDataBase),dDataBase)
        SE2->E2_FORNECE 	:= GetMv("MV_UNIAO")
        SE2->E2_LOJA 		:= cLojaImp
        SE2->E2_NOMFOR		:= SA2->A2_NREDUZ
        SE2->E2_MOEDA		:= 1
        SE2->E2_VLCRUZ		:= Round( nValCsll, MsDecimais(1) )
        SE2->E2_TITPAI      := cTitPai_Rtr
        SE2->E2_CODAPRO		:= cCodAprov
        SE2->E2_ORIGEM		:= "FINA050"
        If lSpbInUse
            Replace	SE2->E2_MODSPB with cModSpb
        EndIf
        SE2->E2_FILORIG  := If(Empty(SE2->E2_FILORIG),cFilAnt,SE2->E2_FILORIG)
        SE2->E2_DIRF    := cGeraDirf
        SE2->E2_CODRET  := cCodRetCsl

        MsUnlock()
		FKCOMMIT()		
        // Gera o lancamento de CSLL no PCO
        PCODetLan("000002","12","FINA050")
    EndIf

    //Refaz os valores de PIS/COFINS/CSLL, quando aglutinados em um unico TX.
    If SuperGetMv("MV_AG10925",.F.,"2") == "1" .And. cCodRetPis == "5952"
        nValPis -= nRefCof + nRefCsl
        nValCsll := nRefCsl
        nValCofins := nRefCof
    EndIf
    RestArea(aAreaSE2)
    RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} F050AltPCC
Pesquisar titulos retidos para Fornecedor no periodo antigo
(anterior a alteração), sem SFQ gravado(ex.E2_PRETPIS =" ")
atualizar a situação para pendente de retenção e excluir
os impostos PCC respectivos a ele

@author Totvs SA
@since  05/11/09
/*/
//-------------------------------------------------------------------
Function F050AltPCC()

    Local lRet 	  		:= .F.
    Local aAreaSE2 	:= SE2->(GetArea())
    Local aArea   		:= GetArea()
    Local nRegSe2     := SE2->(RECNO())
    Local cNomeFor    := SE2->E2_NOMFOR
    Local cFornece    := SE2->E2_FORNECE
    Local cLojaOri   	:= SE2->E2_LOJA
    Local	dDtSeek		:=	dOldVencRe
    Local dDataAcm		:=	dOldVencRe
    Local dFirstDay 	:= FirstDay(dDataAcm)
    Local dLastDay   	:= LastDay(dDataAcm)
    Local nLastDay   	:=	0
    Local nX          := 0
    Local nTamData    := 0

    dbGoTop()
    dbSetOrder(3)  //Filial+Dt.VENCREA+NomeForn
    nLastDay := Day(LastDay(dOldVencRe))
    nTamData := Iif(Len(Dtoc(dOldVencRe)) == 10, 7, 5)

    For nX := 1 to nLastDay
        dDtSeek := DTOS(CTOD(STRZERO(nX)+"/"+Subs(DTOC(dDataAcm),4,nTamData)))
        ///Pesquisa todos titulos pendentes de retenção(ex.E2_PRETPIS='1') para o novo periodo deste titulo e seu fornecedor
        If dbSeek(xFilial("SE2")+dDtSeek+cNomeFor,.T.)
            //Encontrou a primeira ocorrencia de titulo para o fornecedor
            //A partir deste titulo ele vai acumulando todos os que tiverem dentro do range de datas
            While !Eof() .and. xFilial("SE2") == E2_FILIAL .and.	E2_NOMFOR == cNomeFor .and. ;
            (E2_VENCREA >= dFirstDay .and. E2_VENCREA <= dLastDay)

                If E2_FORNECE+E2_LOJA == cFornece+cLojaOri  	.And. ;
                SE2->E2_PRETPIS   	== 	' ' 				.And. ;
                nRegSe2		  			<>		SE2->(RECNO())
                    //Atualiza Situação de Retenção do titulo Retido
                    RecLock("SE2")
                    Replace E2_VALOR     With  SE2->(E2_VALOR + E2_VRETPIS + E2_VRETCOF + E2_VRETCSL )
                    Replace E2_SALDO     With  SE2->(E2_SALDO + E2_VRETPIS + E2_VRETCOF + E2_VRETCSL )
                    Replace E2_VRETPIS 	With 	0
                    Replace E2_VRETCOF 	With 	0
                    Replace E2_VRETCSL 	With 	0
                    Replace E2_PRETPIS 	With 	'1'
                    Replace E2_PRETCOF 	With 	'1'
                    Replace E2_PRETCSL 	With 	'1'
                    MsUnlock()
                    FKCOMMIT()
                    //Exclui Impostos PCC
                    F050DelPCC()
                EndIf
                dbSkip()
            Enddo
        EndIf
    Next

    RestArea(aAreaSE2)
    RestArea(aArea)

Return lRet


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³fa040Inss ³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 28/01/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Zera valor do INSS caso cliente no recolha e Natureza sim  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³fa040Inss()  												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA040													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Fa040Inss()

	//639.04 Base Impostos diferenciada
	Local lBaseImp	 := F040BSIMP()
	Local nBaseImp := m->e1_valor

	//639.04 Base Impostos diferenciada
	If lBaseImp .and. M->E1_BASEIRF > 0
		nBaseImp   := M->E1_BASEIRF
	Endif

	If SA1->A1_RECINSS <> "S" .and. m->e1_inss > 0
		m->e1_inss := 0
	Endif

	If SED->ED_CALCINS == "S" .and. SA1->A1_RECINSS == "S" .And. m->e1_multnat != "1"
		m->e1_inss := (nBaseImp * (SED->ED_PERCINS / 100))
	Endif

	If ( M->E1_INSS <= GetNewPar("MV_VLRETIN",0) )
		M->E1_INSS := 0
	EndIf

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³fa040CSSL ³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 07/02/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Zera valor do CSLL caso cliente no recolha e Natureza sim  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³fa040CSLL()  												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA040													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Fa040CSLL()

	//639.04 Base Impostos diferenciada
	Local lBaseImp	 := F040BSIMP()
	Local nBaseImp := m->e1_valor

	//639.04 Base Impostos diferenciada
	If lBaseImp .and. M->E1_BASEIRF > 0
		nBaseImp   := M->E1_BASEIRF
	Endif

	If !(SA1->A1_RECCSLL $ "S#P") .and. m->e1_csll > 0
		m->e1_csll := 0
	Endif

	If SED->ED_CALCCSL == "S" .and. SA1->A1_RECCSLL $ "S#P" .And. m->e1_multnat != "1"
		m->e1_csll := (nBaseImp * (SED->ED_PERCCSL / 100))
	Endif

	If M->E1_CSLL <= GetNewPar("MV_VRETCSL",0)
		M->E1_CSLL := 0
	EndIf

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³fa040COFI ³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 07/02/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Zera valor do COFINS caso cliente no recolha e Natureza sim³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³fa040Cofins()  											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA040													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Fa040Cofi()

	//639.04 Base Impostos diferenciada
	Local lBaseImp	 := F040BSIMP()
	Local nBaseImp := m->e1_valor

	//639.04 Base Impostos diferenciada
	If lBaseImp .and. M->E1_BASEIRF > 0
		nBaseImp   := M->E1_BASEIRF
	Endif

	If !(SA1->A1_RECCOFI $ "S#P") .and. m->e1_cofins > 0
		m->e1_cofins := 0
	Endif

	If SED->ED_CALCCOF == "S" .and. SA1->A1_RECCOFI $ "S#P" .And. m->e1_multnat != "1"
		m->e1_cofins := (nBaseImp * (Iif(SED->ED_PERCCOF>0,SED->ED_PERCCOF,GetMv("MV_TXCOFIN")) / 100))
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Titulos Provisorios ou Antecipados no geram COFINS       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If m->e1_tipo $ MVPROVIS+"/"+MVRECANT+"/"+MV_CRNEG+"/"+MVABATIM
		m->e1_cofins := 0
	EndIf

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³fa040PIS  ³ Autor ³ Mauricio Pequim Jr.   ³ Data ³ 07/02/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Zera valor do PIS caso cliente no recolha e Natureza sim   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³fa040Pis()   												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA040													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Fa040Pis()

	//639.04 Base Impostos diferenciada
	Local lBaseImp	 := F040BSIMP()
	Local nBaseImp := m->e1_valor

	//639.04 Base Impostos diferenciada
	If lBaseImp .and. M->E1_BASEIRF > 0
		nBaseImp   := M->E1_BASEIRF
	Endif

	If !(SA1->A1_RECPIS $ "S#P") .and. m->e1_pis > 0
		m->e1_pis := 0
	Endif

	If SED->ED_CALCPIS == "S" .and. SA1->A1_RECPIS $ "S#P" .And. m->e1_multnat != "1"
		m->e1_pis := (nBaseImp * (Iif(SED->ED_PERCPIS>0,SED->ED_PERCPIS,GetMv("MV_TXPIS")) / 100))
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Titulos Provisorios ou Antecipados no geram PIS          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If m->e1_tipo $ MVPROVIS+"/"+MVRECANT+"/"+MV_CRNEG+"/"+MVABATIM
		m->e1_pis := 0
	EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo    ³FA040Pes  ³ Autor ³ Rafael Rodrigues      ³ Data ³ 04/09/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³Cria uma pesquisa personalizada para usar campos virtuais.  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Gestao Educacional                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FA040Pes(cAlias, nReg, nOpc)
	Local nOpcA
	Local oDlg, oOrdem, oChave, oBtOk, oBtCan, oBtPar
	Local cOrdem
	Local cExpChave := ""
	Local cChave	:= Space(255)
	Local aOrdens	:= {}
	Local aBlocks	:= {}
	Local nOrder	:= 1

	SIX->( dbSetOrder(1) )
	SIX->( dbSeek(cAlias) )

	while SIX->( !eof() .and. INDICE == cAlias )

		aAdd( aOrdens, Capital( SIXDescricao() ) )
		aAdd( aBlocks, &("{ || "+cAlias+"->(dbSetOrder("+Str(nOrder,2,0)+")), "+cAlias+"->(dbSeek(xFilial('"+cAlias+"')+Rtrim(cChave))) }") )

		nOrder++

		SIX->( dbSkip() )
	end

	aAdd( aOrdens, Capital( STR0036 ) )	// "Nome do Aluno"
	aAdd( aBlocks, &("{ || "+cAlias+"->(dbSetOrder(2)), "+cAlias+"->(dbSeek(xFilial('"+cAlias+"')+Posicione('JA2',3,xFilial('JA2')+Rtrim(cChave),'JA2_CLIENT')))}") )

	define msDialog oDlg title STR0035 from 00,00 TO 100,500 pixel

	@ 005, 005 combobox oOrdem var cOrdem items aOrdens size 210,08 of oDlg pixel
	@ 020, 005 msget oChave var cChave size 210,08 of oDlg pixel

	define sButton oBtOk  from 05,218 type 1 action (nOpcA := 1, oDlg:End()) enable of oDlg pixel
	define sButton oBtCan from 20,218 type 2 action (nOpcA := 0, oDlg:End()) enable of oDlg pixel
	define sButton oBtPar from 35,218 type 5 when .F. of oDlg pixel

	activate msdialog oDlg center

	if nOpcA == 1
		Set SoftSeek On
		for nOrder := 1 to len(aOrdens)
			if aOrdens[ nOrder ] == cOrdem
				cExpChave := (cAlias)->(IndexKey(nOrder))
				if "DTOS" $ cExpChave .Or. "DTOC" $ cExpChave
					cChave := ConvData( cExpChave, cChave )
				endif
				Eval( aBlocks[ nOrder ] )
			endif
		next i
		Set SoftSeek Off
	endif

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funo	 ³GetDadoFI2  ³Autor  ³ Bruno Sobieski      ³ Data ³ 03/02/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrio ³ Le os conteudos  anterior e atual de uma linha do FI2, con-³±±
±±³          ³ vertendo-os para o tipo original.                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ FINA040						            							  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function GetDadoFI2()
	Local xRet	:=	{Nil,Nil}

	Do Case
	Case  FI_TIPCPO	==	"C"
		xRet	:=	{FI2->FI2_VALANT,FI2->FI2_VALNOV}
	Case  cTipo == "D"
		xRet	:=	{Ctod(Alltrim(FI2->FI2_VALANT)),Ctod(Alltrim(FI2->FI2_VALNOV))}
	Case  cTipo == "N"
		xRet	:=	{Val(Alltrim(FI2->FI2_VALANT)),Val(Alltrim(FI2->FI2_VALNOV))}
	EndCase

Return xRet


/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³F040GetNTiºAutor  ³Alberto Deviciente  º Data ³ 13/Jun/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Esta funcao tem por objetivo buscar o codigo sequencial p/ oº±±
±±º          ³No. Titulo utilizando a tabela de controle do RM Classis Netº±±
±±º          ³para que nao seja gerado codigo duplicado entre os sistemas.º±±
±±º          ³Neste caso nao sera considerado o controle de numeracao     º±±
±±º          ³para o titulo utilizando o SXE e SXF e sim a tabela do      º±±
±±º          ³CLASSIS.NET                                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Integracao - Protheus x RM Classis Net (RM Sistemas)       º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function F040GetNTi()
	Local nIdLan 		:= 0

Return cIdLan

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³F040WhnNumºAutor  ³Alberto Deviciente  º Data ³ 27/Jan/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ X3_WHEN do campo E1_NUM                                    º±±
±±º          ³ Se a integracao do Protheus x RM Classis Net estiver ativa,º±±
±±º          ³nao permite editar o campo E1_NUM.                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Integracao - Protheus x RM Classis Net (RM Sistemas)       º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function F040WhnNum()
	Local lRet := .T.
	Local nPos := 0

	//MV_RMCLASS: Parametro de ativacao da integracao do Protheus x RM Classis Net (RM Sistemas)
	If GetNewPar("MV_RMCLASS", .F.)
		if IsInCallStack("FINA040")//Bloqueia a edicao do campo E1_NUM pela rotina FINA040
			if !empty(M->E1_PARCELA)
				for nPos:=1 to TamSX3("E1_PARCELA")[1]
					if !empty(SubStr(alltrim(M->E1_PARCELA),nPos,1)) .and. SubStr(alltrim(M->E1_PARCELA),nPos,1) <> "0"
						lRet := .F.
						exit
					endif
				next nPos
			else
				lRet := .F.
			endif
		endif
	EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³F040RelNumºAutor  ³Alberto Deviciente  º Data ³ 27/Jan/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ X3_RELACAO do campo E1_NUM                                 º±±
±±º          ³ Se a integracao do Protheus x RM Classis Net estiver ativa º±±
±±º          ³e for inclusao de titulo pela rotina FINA040, tras o numero º±±
±±º          ³como "0" (zero) e somente busca o proximo numero do titulo  º±±
±±º          ³qdo. confirmar a tela.                                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Integracao - Protheus x RM Classis Net (RM Sistemas)       º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function F040RelNum()
	Local cRet 	:= ""
	Local aArea	:= getArea()

	dbSelectArea('SE1')

	//MV_RMCLASS: Parametro de ativacao da integracao do Protheus x RM Classis Net (RM Sistemas)
	If GetNewPar("MV_RMCLASS", .F.)
		if (FunName() == "FINA040" .or. FunName() == "FINA740") .and. Inclui
			//Caso a chamada seja realizada pela rotina "Contas a Receber" ou "Funcoes Contas a Receber"
			//o numero do titulo deve ser automatico conforme a GAUTOINC
			cRet := Replicate("0",TamSX3("E1_NUM")[1])
		Else
			cRet := SE1->E1_NUM
		EndIf
	else
		cRet := SE1->E1_NUM
	endif

	RestArea(aArea)
Return cRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³F040RelIdBºAutor  ³Cesar A. Bianchi    º Data ³ 06/Mar/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º          ³Se a integracao do Protheus x RM Classis Net estiver ativa  º±±
±±º          ³e for inclusao de titulo pela rotina FINA040, ja traz o     º±±
±±º          ³proximo numero do IDBOLET.                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Integracao - Protheus x RM Classis Net (RM Sistemas)       º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function F040RelIdB()
	Local nRet := 0
	Local aArea 		:= getArea()

	dbSelectArea('SE1')

	If cPaisLoc == "BRA"
		nRet := SE1->E1_IDBOLET
	EndIf

	RestArea(aArea)
Return nRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FA330RetIRF
Utilizada para retornar o valor total dos títulos de impostos IRF gerados na baixa
e que estão com o campo E1_TIPO preenchido como IRF, ao invés de "IRF-"

@author Caique Bispo Ferreira

@since 29/07/2014
@version 1.0
/*/
//-------------------------------------------------------------------

Function FA330RetIRF(cPrefixo,cNum,cParcela,nMoeda,dData)
Local nTotImp		:= 0
Local aArea			:= GetArea()
Local cQuery		:= ""
Local cCliLj		:= SE1->(E1_CLIENTE+E1_LOJA)
Local cTipo			:= SE1->E1_TIPO

Default cPrefixo	:= ""
Default cNum		:= ""
Default cParcela	:= ""
Default nMoeda		:= 0
Default dData		:= dDataBase

If Empty(cPrefixo) .And. Empty(cNum) .And. Empty(cParcela)
	RestArea(aArea)
	Return nTotImp
EndIf

cQuery := " SELECT E1_MOEDA, E1_VALOR  "
cQuery += " FROM  " + RetSqlName("SE1") + " SE1 "
cQuery += " WHERE E1_TITPAI = '" + (cPrefixo+cNum+cParcela+cTipo+cCliLj)+ "'  AND E1_TIPO = 'IRF' AND D_E_L_E_T_ = ' ' " 

//* Verifica se a Query Existe, se existir fecha
If Select("TSE1") > 0
	dbSelectArea("TSE1")
	DbCloseArea()
EndIf

//* Cria a Query e da Um Apelido
dbUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"TSE1",.F.,.T.)

dbSelectArea("TSE1")
dbGotop()
Do While TSE1->(!Eof())
	
	TCSetField("TSE1", "E1_VALOR" ,"N", 16, 2)
	TCSetField("TSE1", "E1_MOEDA" ,"N", 2, 0)
	
	nTotImp += xMoeda(TSE1->E1_VALOR,TSE1->E1_MOEDA,nMoeda,dData,,,0)
	dbSkip()
Enddo

If Select("TSE1") > 0
	dbSelectArea("TSE1")
	DbCloseArea()
EndIf

RestArea(aArea)
Return nTotImp

//-----------------------------------------------------------------------------------------
/*/{Protheus.doc} OldF070Confirma
Funcao para a validar o código capturado pelo leitor de CMC7.

Funções migrada do FINA070 para o FINXOLD para aumentar cobertura

@since 08/12/2020
@version 1.0
/*/
//-----------------------------------------------------------------------------------------
Function OldF070Confirma( cCmc7 )
Local lRet := .F.		// Retorno da validacao da string

If Empty( cCmc7 ) // Caso nao leia nada
	MsgAlert( STR0039 )		// "Passe o cheque novamente no leitor."
Elseif ( "?" $ cCmc7 ) .OR. Len( AllTrim( cCmc7 ) ) <> 34 // Se encontrar o caracter de erro (?) ou tamnaho menor que o correto (34)
	MsgAlert( STR0040 + " " + STR0039 )		// "Erro na leitura." ### "Passe o cheque novamente no leitor."
Else
	lRet := .T.
Endif

Return ( lRet )


//-----------------------------------------------------------------------------------------
/*/{Protheus.doc} Oldfa070Blank
Limpa as marcacoes do arquivo (E1_OK) teclado. 

Funções migrada do FINA070 para o FINXOLD para aumentar cobertura

@since 08/12/2020
@version 1.0
/*/
//-----------------------------------------------------------------------------------------
Function OldF070Cmc7Tc()
Local cCmc7 	:= Space(35)	// Recebera o conteudo lido do cheque
Local oCmc7						// Objeto do get do CMC7
Local oDlg						// Monta a tela de captura do codigo
Local aCmc7Tc	:= {}			// Armazena os dados do cheque; retorno da funcao
Local nOpcx 	:= 0


DEFINE MSDIALOG oDlg TITLE STR0041 FROM 200 , 001 TO 300 , 300 OF oMainWnd PIXEL	// "Leitura do código do cheque"
@ 010 , 018 Say STR0042 SIZE 050 , 050 OF oDlg PIXEL								// "Passe o cheque:"
@ 018 , 018 MSGET oCmc7 VAR cCmc7 PICTURE "@!" SIZE 120,009 OF oDlg PIXEL

DEFINE SBUTTON FROM 35 , 080 TYPE 1 ACTION (Iif (F070Confirma(cCmc7), (oDlg:End(), nOpcx := 1), oCmc7:SetFocus()) )  ENABLE OF oDlg
DEFINE SBUTTON FROM 35 , 110 TYPE 2 ACTION oDlg:End()  ENABLE OF oDlg

ACTIVATE MSDIALOG oDlg CENTERED

If nOpcx == 1  //Confirmou cheque

	If ExistBlock("F460CMTC")
		aCmc7Tc := ExecBlock("F460CMTC",.F.,.F.,cCmc7)
	Else
		Aadd( aCmc7Tc, SubStr(cCmc7, 2, 3) )	//Banco
		Aadd( aCmc7Tc, SubStr(cCmc7, 14, 6) )	//Cheque
		Aadd( aCmc7Tc, SubStr(cCmc7, 5, 4) )	//Agencia
		Aadd( aCmc7Tc, SubStr(cCmc7, 25, 8) )	//Conta
	Endif

Endif

Return( aCmc7Tc )


//-----------------------------------------------------------------------------------------
/*/{Protheus.doc} Oldfa070Blank
Soma titulos de abatimento relacionado a um determinado titulo a receber - Pis, Cofins e Csll	 

Funções migrada do FINA070 para o FINXOLD para aumentar cobertura

@since 08/12/2020
@version 1.0
/*/
//-----------------------------------------------------------------------------------------
Function OldSumAbatPCC( cImposto)
Local aAreaPcc:=GetArea()
Local nTotAbtPCC := 0
Local cPrefixo := SE1->E1_PREFIXO
Local cNumero	:= SE1->E1_NUM
Local cParcela := SE1->E1_PARCELA
Local cTipoAtu := SE1->E1_TIPO
Local cCliente := SE1->E1_CLIENTE
Local cLoja 	:= SE1->E1_LOJA
Local cTipo		:= "PCC"
Local cSeq		:= SE5->E5_SEQ

DEFAULT cImposto := "PCC"

//Se a sequencia de baixa posicionada nao for vazia
//Faz a busca dos valores de Pis e Cofins do titulo
If SE1->E1_SALDO == 0 .AND. !Empty(cSeq)

	//Verifico se eh a ultima sequencia das baixas do titulo
	//Caso nao seja, retorno zero ja que os impostos somente serao abatidos na ultima baixa do titulo
	If Select("__SE5") == 0
		ChkFile("SE5",.F.,"__SE5")
	Else
		dbSelectArea("__SE5")
	Endif
	dbSetOrder(7)
	MsSeek(xFilial("SE5")+cPrefixo+cNumero+cParcela+cTipoAtu+cCliente+cLoja+"zz",.T.)
	dbSkip(-1)
	If (xFilial("SE5")+cPrefixo+cNumero+cParcela+cTipoAtu+cCliente+cLoja+cSeq == ;
		__SE5->(E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ))

		If Select("__SE1") == 0
			ChkFile("SE1",.F.,"__SE1")
		Else
			dbSelectArea("__SE1")
		Endif

		DO CASE
			CASE UPPER(cImposto) == "PIS"
				cTipo := MVPIABT
			CASE UPPER(cImposto) == "COFINS"
				cTipo := MVCFABT
			CASE UPPER(cImposto) == "CSLL"
				cTipo := MVCSABT
			OtherWise
				cTipo := "PCC"
		END CASE

		dbSetOrder( 1 )
		dbSeek( xFilial("SE1")+cPrefixo+cNumero+cParcela+IIF(cTipo == "PCC","",cTipo))

		While !Eof() .And. E1_FILIAL == xFilial("SE1") .And. E1_PREFIXO == cPrefixo .And.;
				E1_NUM == cNumero .And. E1_PARCELA == cParcela .and. IIF(cTipo == "PCC",.T.,cTipo == E1_TIPO)

		  	If E1_TIPO $ MVCSABT+"/"+MVCFABT+"/"+MVPIABT
				nTotAbtPCC += E1_VLCRUZ
			Endif

			dbSkip()
		Enddo
	Endif
Endif

RestArea(aAreaPcc)

Return (NoRound(nTotAbtPCC))

//-----------------------------------------------------------------------------------------
/*/{Protheus.doc} OldFa070Acha
Funcao que realiza a pesquisa - WINDOWS

Funções migrada do FINA070 para o FINXOLD para aumentar cobertura

@since 08/12/2020
@version 1.0
/*/
//-----------------------------------------------------------------------------------------
Function OldFa070Acha(cCampo,oMark)

dbSelectArea("SE1")
MsSeek(xFilial("SE1")+cCampo,.T.)
oMark:oBrowse:Refresh(.T.)
Return

//-----------------------------------------------------------------------------------------
/*/{Protheus.doc} Oldfa070Blank
Limpa as marcacoes do arquivo (E1_OK)

Funções migrada do FINA070 para o FINXOLD para aumentar cobertura

@since 08/12/2020
@version 1.0
/*/
//-----------------------------------------------------------------------------------------
Function Oldfa070Blank()
If !Empty(SE1->E1_NUM)
	Reclock("SE1")
	SE1->E1_OK := "  "
	SE1->(MsUnlock())
Endif
Return

//-----------------------------------------------------------------------------------------
/*/{Protheus.doc} FxDelSFQCR
Funções migrada do FINA070 para o FINXOLD para aumentar cobertura

@since 08/12/2020
@version 1.0
/*/
//-----------------------------------------------------------------------------------------
Function FxDelSFQCR(nOper,cAlias,cPrefixo,cNumero,cParcela,cTipo,cCliFor,cLoja,cSeq)
Local lImpGer061	:= .F. //Registros gerados na rotina FINA061 nao devem ser excluidos.
Local cAliasQry 	:= ""
Local cQuery		:= ""
Local aTitSe5		:= {}
Local nI			:= 0
Local cSequencia 	:= ""
//***Reestruturação da SE5***
Local oModelMov		:= FWLoadModel("FINM030") //Model de Movimento bancario
Local oSubFKAMV
Local oSubFK5MV
Local cCamposE5		:= ""
Local cLog			:= ""
//***Reestruturação da SE5***

If nOper == 1
	SE1->(DbSetOrder(1))
	If SE1->(MsSeek(xFilial("SE1")+SFQ->FQ_PREFDES+SFQ->FQ_NUMDES+SFQ->FQ_PARCDES+SFQ->FQ_TIPODES))
		While SE1->(!EOF()) .And. SE1->E1_FILIAL+SE1->E1_PREFIXO+SE1->E1_NUM+SE1->E1_PARCELA+SE1->E1_TIPO == ;
			(xFilial("SE1")+ SFQ->FQ_PREFDES + SFQ->FQ_NUMDES + SFQ->FQ_PARCDES + SFQ->FQ_TIPODES)
			If SE1->E1_TIPO $ "PIS/COF/CSL"  .And. SE1->E1_ORIGEM = "FINA061"
				lImpGer061	:=	.T.
           	Endif
           	SE1->(Dbskip())
		Enddo
	Endif

	If SE1->(MsSeek(xFilial("SE1")+SFQ->FQ_PREFDES+SFQ->FQ_NUMDES+SFQ->FQ_PARCDES+SFQ->FQ_TIPODES))
		If  !Empty(SE1->E1_NUMBOR) .And. !lImpGer061
			Reclock("SE1",.F.)
			SE1->E1_SABTPIS	:= 0
			SE1->E1_SABTCOF	:= 0
			SE1->E1_SABTCSL	:= 0
			MsUnlock()
		Endif

	  	cAliasQry := GetNextAlias()

		cQuery := "SELECT E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_CLIFOR, E5_LOJA, E5_HISTOR,  "
		cQuery += "R_E_C_N_O_ RECNOSE5 FROM "
		cQuery += RetSqlName( "SE5" ) + " SE5 "
		cQuery += "WHERE "
		cQuery += "E5_FILIAL='"    + xFilial("SE5")  +  "' AND "
		cQuery += "E5_PREFIXO='"	+ SE1->E1_PREFIXO + "' AND "
		cQuery += "E5_NUMERO='"		+ SE1->E1_NUM + "' AND "
		cQuery += "E5_PARCELA='"	+ SE1->E1_PARCELA + "' AND "
		cQuery += "E5_TIPO='"		+ SE1->E1_TIPO + "' AND "
		cQuery += "E5_CLIFOR='"		+ SE1->E1_CLIENTE	+ "' AND "
		cQuery += "E5_LOJA='"		+ SE1->E1_LOJA		+ "' AND "
		cQuery += "E5_HISTOR = '" +  'Bx. Bord. Ac.'  + "' AND  "
		cQuery += "E5_PRETPIS = '2' AND E5_PRETCOF = '2' AND E5_PRETCSL = '2' AND "
		cQuery += "D_E_L_E_T_=' '"

		cQuery 		:= ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry)

		If !( cAliasQRY )->( Eof())
			While !( cAliasQRY )->( Eof())
				SE5->( dbGoto(  ( cAliasQRY )->RECNOSE5 ) )
			  	Reclock("SE5",.F.)
				dbDelete()
				MsUnlock()
	     		( cAliasQRY )->(Dbskip())
			Enddo
		Endif
		( cAliasQRY )->(DbCloseArea())

	  	cAliasQry := GetNextAlias()
		cQuery := "SELECT E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_CLIFOR, E5_LOJA, E5_HISTOR,  "
		cQuery += "R_E_C_N_O_ RECNOSE5 FROM "
		cQuery += RetSqlName( "SE5" ) + " SE5 "
		cQuery += "WHERE "
		cQuery += "E5_FILIAL='"    + xFilial("SE5")  +  "' AND "
		cQuery += "E5_PREFIXO='"	+ SE1->E1_PREFIXO + "' AND "
		cQuery += "E5_NUMERO='"		+ SE1->E1_NUM + "' AND "
		cQuery += "E5_PARCELA='"	+ SE1->E1_PARCELA + "' AND "
		cQuery += "E5_TIPO='"		+ SE1->E1_TIPO + "' AND "
		cQuery += "E5_CLIFOR='"		+ SE1->E1_CLIENTE	+ "' AND "
		cQuery += "E5_LOJA='"		+ SE1->E1_LOJA		+ "' AND "
		cQuery += "E5_PRETPIS = '9' AND E5_PRETCOF = '9' AND E5_PRETCSL = '9' AND "
		cQuery += "D_E_L_E_T_=' '"

		cQuery 		:= ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry)

		If !( cAliasQRY )->( Eof())
			While !( cAliasQRY )->( Eof())
				SE5->( dbGoto(  ( cAliasQRY )->RECNOSE5 ) )

				Reclock("SE5",.F.)
  				SE5->E5_PRETPIS 	:= "8"
				SE5->E5_PRETCOF 	:= "8"
				SE5->E5_PRETCSL 	:= "8"
				MsUnlock()

				( cAliasQRY )->(Dbskip())
			Enddo
		Endif
		( cAliasQRY )->(DbCloseArea())

	Endif
Else

	SFQ->(dbSetOrder(2))
	If SFQ->(MsSeek(xFilial("SFQ")+cAlias+cPrefixo+cNumero+cParcela+cTipo+cClifor+cLoja))
		If SE1->(MsSeek(xFilial("SE1")+SFQ->FQ_PREFDES+SFQ->FQ_NUMDES+SFQ->FQ_PARCDES+SFQ->FQ_TIPODES)) .And. !Empty(SE1->E1_NUMBOR)

		  	cAliasQry := GetNextAlias()

			cQuery := "SELECT E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_CLIFOR, E5_LOJA, E5_HISTOR,  "
			cQuery += "R_E_C_N_O_ RECNOSE5 FROM "
			cQuery += RetSqlName( "SE5" ) + " SE5 "
			cQuery += "WHERE "
			cQuery += "E5_FILIAL='"    + xFilial("SE5")  +  "' AND "
			cQuery += "E5_PREFIXO='"	+ SE1->E1_PREFIXO + "' AND "
			cQuery += "E5_NUMERO='"		+ SE1->E1_NUM + "' AND "
			cQuery += "E5_PARCELA='"	+ SE1->E1_PARCELA + "' AND "
			cQuery += "E5_TIPO='"		+ SE1->E1_TIPO + "' AND "
			cQuery += "E5_CLIFOR='"		+ SE1->E1_CLIENTE	+ "' AND "
			cQuery += "E5_LOJA='"		+ SE1->E1_LOJA		+ "' AND "
			cQuery += "E5_HISTOR = '" +  'FINA061-Ref. Baixa'  + "' AND  "
			cQuery += "E5_PRETPIS = '2' AND E5_PRETCOF = '2' AND E5_PRETCSL = '2' AND "
			cQuery += "E5_VALOR = 0  AND  "

			cQuery += "D_E_L_E_T_=' '"

			cQuery 		:= ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry)

			If !( cAliasQRY )->( Eof())
				While !( cAliasQRY )->( Eof())
						SE5->( dbGoto(  ( cAliasQRY )->RECNOSE5 ) )

					  	Aadd(aTitSe5,{SE5->E5_BANCO,;
				  							SE5->E5_AGENCIA,;
			  								SE5->E5_CONTA,;
									  		SE5->E5_DATA,;
											SE5->E5_DTDISPO,;
											SE5->E5_MOEDA,;
											SE5->E5_TXMOEDA,;
											SE5->E5_VALOR,;
											SE5->E5_VRETPIS,;
											SE5->E5_VRETCOF,;
											SE5->E5_VRETCSL,;
											SE5->E5_NATUREZ,;
											SE5->E5_RECPAG,;
											SE5->E5_TIPO,;
											SE5->E5_LA,;
											SE5->E5_TIPODOC,;
											SE5->E5_HISTOR,;
											SE5->E5_TIPODOC,;
											SE5->E5_LOTE,;
											SE5->E5_BENEF,;
											SE5->E5_DTDIGIT,;
											SE5->E5_MOTBX,;
											SE5->E5_SERREC,;
											SE5->E5_ORDREC,;
											SE5->E5_FILORIG})

					  	Reclock("SE5",.F.)
						dbDelete()
						MsUnlock()
		     			( cAliasQRY )->(Dbskip())
				Enddo
			Endif
			( cAliasQRY )->(DbCloseArea())

		Endif

		oModelMov:SetOperation( 3 ) //Inclusao
		oModelMov:Activate()
		oSubFKAMV  := oModelMov:GetModel( "FKADETAIL" )
		oSubFK5MV  := oModelMov:GetModel( "FK5DETAIL" )

		If SE1->(MsSeek(xFilial("SE1")+SFQ->FQ_PREFORI+SFQ->FQ_NUMORI+SFQ->FQ_PARCORI+SFQ->FQ_TIPOORI))
			//Seto um novo processo para o model antes da chamada do laço
			oModelMov:SetValue( "MASTER", "NOVOPROC", .T. )

			For nI := 1 To Len(aTitSe5)
				If !Empty(cCamposE5)
					cCamposE5 += "|"
				EndIf

				If !oSubFKAMV:IsEmpty()
					//Inclui a quantidade de linhas necessárias
					oSubFKAMV:AddLine()
					//Vai para linha criada
					oSubFKAMV:GoLine( oSubFKAMV:Length() )
				Endif

				cSequencia 	:= FaNxtSeqBx("SE1",.T.)  // Sequencia da baixa do adiantamento + 1

				cCamposE5 += "{"

				cCamposE5 += " ,{'E5_TIPO'		,'" + aTitSe5[nI,14] + "'}"
				cCamposE5 += " ,{'E5_LOTE'		,'" + aTitSe5[nI,19] + "'}"
				cCamposE5 += " ,{'E5_BENEF'		,'" + aTitSe5[nI,20] +"' }"
				cCamposE5 += " ,{'E5_DTDIGIT'	, StoD('" + DtoS(aTitSe5[nI,21]) + "')}"
				cCamposE5 += " ,{'E5_MOTBX'		,'" + aTitSe5[nI,22] + "'}"
				cCamposE5 += " ,{'E5_SERREC'	,'" + aTitSe5[nI,23] + "'}"
				cCamposE5 += " ,{'E5_ORDREC'	,'" + aTitSe5[nI,24] + "'}"
				cCamposE5 += " ,{'E5_PREFIXO'	, SE1->E1_PREFIXO}"
				cCamposE5 += " ,{'E5_NUMERO'	, SE1->E1_NUM}"
				cCamposE5 += " ,{'E5_PARCELA'	, SE1->E1_PARCELA}"
				cCamposE5 += " ,{'E5_CLIFOR'	, SE1->E1_CLIENTE}"
				cCamposE5 += " ,{'E5_CLIENTE'	, SE1->E1_CLIENTE}"
				cCamposE5 += " ,{'E5_LOJA'		, SE1->E1_LOJA}"
				cCamposE5 += " ,{'E5_VRETPIS'	, '" + aTitSe5[nI,09] + "'}"
				cCamposE5 += " ,{'E5_VRETCOF'	, '" + aTitSe5[nI,10] + "'}"
				cCamposE5 += " ,{'E5_VRETCSL'	, '" + aTitSe5[nI,11] + "'}"
				cCamposE5 += " ,{'E5_PRETPIS'	, '8'}"
				cCamposE5 += " ,{'E5_PRETCOF'	, '8'}"
				cCamposE5 += " ,{'E5_PRETCSL'	, '8'}"

				cCamposE5 += "}"

				oSubFK5MV:SetValue( "FK5_BANCO"  , aTitSe5[nI,01] )
				oSubFK5MV:SetValue( "FK5_AGENCI" , aTitSe5[nI,02] )
				oSubFK5MV:SetValue( "FK5_CONTA"  , aTitSe5[nI,03] )
				oSubFK5MV:SetValue( "FK5_DATA"   , aTitSe5[nI,04] )
				oSubFK5MV:SetValue( "FK5_DTDISP" , aTitSe5[nI,05] )
				oSubFK5MV:SetValue( "FK5_MOEDA"  , aTitSe5[nI,06] )
				oSubFK5MV:SetValue( "FK5_TXMOED" , aTitSe5[nI,07] )
				oSubFK5MV:SetValue( "FK5_VALOR"	 , aTitSe5[nI,08] )
				oSubFK5MV:SetValue( "FK5_NATURE" , aTitSe5[nI,12] )
				oSubFK5MV:SetValue( "FK5_RECPAG" , aTitSe5[nI,13] )
				oSubFK5MV:SetValue( "FK5_LA"     , aTitSe5[nI,15] )
				oSubFK5MV:SetValue( "FK5_TPDOC"  , aTitSe5[nI,16] )
				oSubFK5MV:SetValue( "FK5_HISTOR" , aTitSe5[nI,17] )
				oSubFK5MV:SetValue( "FK5_FILORI" , aTitSe5[nI,25] )
				oSubFK5MV:SetValue( "FK5_SEQ"    , cSequencia )

			Next nI
			//Grava os dados
			If oModelMov:VldData()
			    oModelMov:CommitData()
			Else
			    cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
			    cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
			    cLog += cValToChar(oModelMov:GetErrorMessage()[6])

			    Help( ,,"M010DELSFQ",,cLog, 1, 0 )
			Endif
		Endif
		oModelMov:DeActivate()
		oModelMov:Destroy()
		oModelMov:= Nil

		RecLock("SFQ",.F.)
		SFQ->(dbDelete())
		MsUnlock()
	Endif
Endif

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} FaGrvActBd()
Gera bordero no momento da baixa e atualiza os
registros relacionados

@param cNumBor   
@param cPort240 
@param cAgen240
@param cConta240
@param dDataBord
@param cModPgto
@param cTipoPag

@author Totvs
@since 09/10/2017
@version 1.0
/*/
//-----------------------------------------------------------------------
Function BxGrvActBd(cNumBor,cPort240,cAgen240,cConta240,dDataBord,cModPgto,cTipoPag)

	Local lSE2DtBor := cPaisLoc == "BRA"

	//REESTRUTURACAO SE5
	Local oModelBxP := FWLoadModel("FINM020") //Model de baixas a pagar
	Local oSubFK5	//MOVTO BANCARIO
	Local cLog 		:= ""

	//Grava registro no bordero SEA
	dbSelectArea("SEA")
	RecLock("SEA",.T. )
	Replace EA_FILIAL  With xFilial("SEA"),;
	EA_PORTADO With cPort240,;
	EA_AGEDEP  With cAgen240,;
	EA_NUMCON  With cConta240,;
	EA_NUMBOR  With cNumBor,;
	EA_PREFIXO With SE2->E2_PREFIXO,;
	EA_NUM     With SE2->E2_NUM,;
	EA_PARCELA With SE2->E2_PARCELA,;
	EA_TIPO    With SE2->E2_TIPO,;
	EA_FORNECE With SE2->E2_FORNECE,;
	EA_LOJA	   With SE2->E2_LOJA,;
	EA_CART    With "P",;
	EA_MODELO  With cModPgto,;
	EA_TIPOPAG With cTipoPag ,;
	EA_FILORIG With SE2->E2_FILIAL
	If lSE2DtBor
		Replace EA_DATABOR With dDataBord
	Endif
	MsUnlock()
	FKCOMMIT()

	//Grava dados no SE2 ref bordero
	dbSelectArea("SE2")
	RecLock("SE2")
	Replace E2_NUMBOR  With cNumBor
	Replace E2_PORTADO With cPort240
	If lSE2DtBor
		Replace E2_DTBORDE  With dDataBord
	Endif
	MsUnlock( )
	FKCOMMIT()

	//Gravadados no SE5 - este ja esta posicionado na volta da FA080GRV
	dbSelectArea("SE5")
	RecLock("SE5")
	Replace E5_DOCUMEN  With cNumBor
	MsUnlock( )
	FKCOMMIT()

	//Atualiza a informação de retencao de impostos em outro titulo
	//Carrego o Model        TO DO
	oModelBxP:SetOperation( 4 ) //Atualizacao
	oModelBxP:Activate()
	oModelBxP:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
	oSubFKA := oModelBxP:GetModel( "FKADETAIL" )
	oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )
	oSubFK5:SetValue( "FK5_DOC"    , cNumBor )

	//Grava os dados
	If oModelBxP:VldData()
		oModelBxP:CommitData()

	Else
		lRet := .F.
		cLog := cValToChar(oModelBxP:GetErrorMessage()[4]) + ' - '
		cLog += cValToChar(oModelBxP:GetErrorMessage()[5]) + ' - '
		cLog += cValToChar(oModelBxP:GetErrorMessage()[6])

		Help( ,,"M020VLDI8",,cLog, 1, 0 )
	Endif

	oModelBxP:DeActivate()
	oModelBxP:Destroy()
	oModelBxP:= Nil
Return

/*/{Protheus.doc} FaActBord()
Gera bordero no momento da Baixa

@param cNumBor   
@param cPort240 
@param cAgen240
@param cConta240
@param dDataBord
@param cModPgto
@param cTipoPag

@author Totvs
@since 09/10/2017
@version 1.0
/*/
//-----------------------------------------------------------------------
Function BxActBord(cNumBor,cPort240,cAgen240,cConta240,dDataBord,cModPgto,cTipoPag)

	LOCAL aMoedas := { "01-"+GetMv("MV_MOEDA1"),"02-"+GetMv("MV_MOEDA2"),"03-"+GetMv("MV_MOEDA3"),"04-"+GetMv("MV_MOEDA4"),"05-"+GetMv("MV_MOEDA5") }
	Local cTit := ""
	Local cForne := ""
	Local cLoja := ""
	Local cContrato := ""
	Local lRet := .T.
	LOCAL cMoeda240,cVar
	Local nOpcK := 0
	Local oDlg := NIL
	Local lDadosDig := .F.

	If lRet .And. SE2->E2_TIPO $ MVPROVIS
		Help(" ",1,"FA590PROV")
		lRet := .F.
	Endif

	If lRet .And. SE2->E2_TIPO $ MVENVBCOR
		Help(" ",1,"F590ENVBCO")
		lRet := .F.
	Endif

	If lRet .and. !Empty(SE2->E2_NUMBOR)
		lRet := .F.
	Endif


	If lRet
		While .T.
			cTit  := SE2->E2_PREFIXO+"-"+SE2->E2_NUM+"-"+SE2->E2_PARCELA+"-"+SE2->E2_TIPO
			cForne:= SE2->E2_FORNECE
			cLoja := SE2->E2_LOJA
			cContrato:=  ""

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Tela e Gets do bordero - Windows                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cMoeda240 := aMoedas[SE2->E2_MOEDA]
			cVar := aMoedas[SE2->E2_MOEDA]
			nOpcK := 0
			DEFINE MSDIALOG oDlg FROM  15,6 TO 249,404 TITLE "Bordero" PIXEL  //"Borders de Pagamentos"
			@ 00, 01 TO 29, 197 OF oDlg  PIXEL
			@ 33, 01 TO 63, 197 OF oDlg  PIXEL
			@ 67, 01 TO 97, 197 OF oDlg  PIXEL

			@ 06, 009 SAY "Bordero" 	SIZE 23, 7 OF oDlg PIXEL  //"N£mero"
			@ 40, 009 SAY "Banco"		SIZE 23, 7 OF oDlg PIXEL  //"Banco"
			@ 40, 045 SAY "Agencia"		SIZE 32, 7 OF oDlg PIXEL  //"Agncia"
			@ 40, 085 SAY "Conta"		SIZE 32, 7 OF oDlg PIXEL  //"Conta"
			@ 73, 009 SAY "Moeda"		SIZE 23, 7 OF oDlg PIXEL  //"Moeda"
			@ 73, 063 SAY "Modelo"		SIZE 22, 7 OF oDlg PIXEL  //"Modelo"
			@ 73, 097 SAY "Tipo Pagto"	SIZE 32, 7 OF oDlg PIXEL  //"Tipo Pagto"
			@ 73, 135 SAY "Data do Bordero"	SIZE 50, 7 OF oDlg PIXEL  //Data do Bordero

			//Linha 1
			@ 15, 009 MSGET cNumBor         		SIZE 32, 10 OF oDlg PIXEL ;
			Picture "@!" Valid !Empty(cNumBor) .and. ;
			FaDadosBrd(cNumBor,@cPort240,@cAgen240,@cConta240,@dDataBord,@cModPgto,@cTipoPag,@lDadosDig)

			@ 49, 009 MSGET cPort240        		SIZE 30, 10 OF oDlg PIXEL Picture "@!"  ;
			F3 "SA6";
			Valid CarregaSA6(@cPort240,,,.t.) HASBUTTON
			@ 49, 045 MSGET cAgen240        		SIZE 26, 10 OF oDlg PIXEL Picture "@!"  ;
			Valid CarregaSA6(@cPort240,@cAgen240,,.T.)
			@ 49, 085 MSGET cConta240       		SIZE 62, 10 OF oDlg PIXEL Picture "@!"  ;
			Valid CarregaSA6(@cPort240,@cAgen240,@cConta240,.T.,,.T.)

			//Linha 3
			@ 82, 009 MSCOMBOBOX oCbx VAR cMoeda240 ITEMS aMoedas SIZE 46, 50 OF oDlg PIXEL
			@ 82, 063 MSGET cModPgto        		SIZE 25, 10 OF oDlg PIXEL Picture "@!"  Valid ExistCpo("SX5", + "58" + cModPgto) F3 "58" HASBUTTON
			@ 82, 097 MSGET cTipoPag        		SIZE 25, 10 OF oDlg PIXEL Picture "@!"  Valid ExistCpo("SX5", + "59" + cTipoPag) F3 "59" HASBUTTON
			@ 82, 135 MSGET dDataBord        	SIZE 60, 10 OF oDlg PIXEL HASBUTTON VALID dDataBord >= dDataBase

			DEFINE SBUTTON FROM 105, 135 TYPE 1 ENABLE OF oDlg ACTION (cVar:=cMoeda240,nOpcK:=1,;
			Iif(F240TudoOk(oDlg),oDlg:End(),nOpcK:=0))
			DEFINE SBUTTON FROM 105, 170 TYPE 2 ENABLE OF oDlg ACTION (nOpcK := 2, oDlg:End())

			ACTIVATE MSDIALOG oDlg CENTERED

			If nOpcK == 0
				Loop
			Endif
			Exit
		Enddo

		If nOpcK != 1
			lRet := .F.
		Endif

	Endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} FaDadosBrd()
Verifica existencia de bordero e carrega os dados
basicos do mesmo

@param cNumBor   
@param cPort240 
@param cAgen240
@param cConta240
@param dDataBord
@param cModPgto
@param cTipoPag
@param lDadosDig

@author Totvs
@since 09/10/2017
@version 1.0
/*/
//-------------------------------------------------------------------
Function BxDadosBrd(cNumBor,cPort240,cAgen240,cConta240,dDataBord,cModPgto,cTipoPag,lDadosDig)

	Local aAreaSEA := SEA->(GetArea())
	Local lSE2DtBor := cPaisLoc == "BRA"

	SEA->(dbSetOrder(2))
	If SEA->(MsSeek(xFilial("SEA")+cNumBor+"P"))
		cPort240		:= SEA->EA_PORTADO
		cAgen240		:= SEA->EA_AGEDEP
		cConta240		:= SEA->EA_NUMCON
		cModPgto		:= SEA->EA_MODELO
		cTipoPag		:= SEA->EA_TIPOPAG
		If lSE2DtBor
			dDataBord := SEA->EA_DATABOR
		Endif
	Endif
	lDadosDig := .T.

	RestArea(aAreaSEA)

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} F080BxSPB
Valida e executa emissao de dadodos para SPB

@param Utiliza SPB ou nao  
@param Clearing 
@param Tipo de Pagamento (Tabela 59)    
@param Stored a ser disparada     
@param Hora do agendamento da operacao
@param Codigo de Barras
@param Numero Evento SPB

@author Mauricio Pequim Jr 
@since 22/09/2001
/*/
//-------------------------------------------------------------------
Function Bx80BxSPB(cClearing,cTipoPgto,cStored,cHora,cCodbar,nEventoSpb)
	Local lRet := .T.
	Local nValBaixa := nValPgto-(nJuros+nMulta-nDescont)
	Local aSPB := {}
	Local aDadosSpb := {}

	IF STR(nValBaixa,17,2) != STR(Round(NoRound(xMoeda(SE2->E2_VALOR-nTotAbat,SE2->E2_MOEDA,nMoedaBco,dBaixa,3),3),2),17,2)
		Help(" ",1,"FA070INV")
		lRet := .F.
	Endif

	aDadosSpb := {}

	If lRet
		cCodBar	:= SE2->E2_CODBAR+Space(44-Len(SE2->E2_CODBAR))
		AADD(aSPB,{cClearing,cTipoPgto,cStored,cHora,cCodBar})
		// Execblock para iniciar Stored Procedure
		IF ExistBlock("FA080SPB")
			aDadosSPB := ExecBlock("FA080SPB",.f.,.f.,aSPB)
			cCodBar := aDadosSpb[1]
			nEventoSPB := aDadosSpb[2]
			If nEventoSPB == 0	//Erro no SPB. Não permite a baixa
				lRet := .F.
			Endif
		Endif
	Endif

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} FCmpCPOLD 
Rotina de Compensasao do Contas a Pagar 

Função movida do FINXAPI por estar sem uso no sistema

@param aTitulo		Array com os dados do titulo principal
       					[1] Abatimento (-)
	   					[2] Descrescimo (-)
						[3] Acrescimo   (+)
						[4] Variacao Monetaria (=)
@param aCompensar	Array com os dados do titulos a compensar
						{}[1] RecNo do Titulo a compensar	
						  [2] Valor do Titulo a compensar na moeda do Titulos principal
						  [3] Valor do Abatimento da NDF
						  [4] Data da Baixa  (OPC)		
						  [5] Numero de Lote para contabilizacao (OPC)
						  [6] Data a ser considerar para converte o valor do titulo principal para a moeda corrente  (OPC)
						  [7] Taxa da moeda a ser considerada para converte o valor do titulo principal para a moeda corrente (OPC)
						  [8] Numero de decimais utilizado nas conversoes. (OPC)
						  [9] Numero de decimais utilizado nas conversoes. (OPC)
						  [10] Valor da Variacao Monetaria	(OPC)
@param lLctPad		Indica se a compensacao sera contabilizada (OPC)
@param cOrigem		Indica o programa de origem da compensacao (OPC)
@param bContabil	Bloco de codigo para contabilizacao (OPC)
@param bBlock		Bloco de codigo apos cada compensacao. Recebe o E5_DOCUMEN como parametro (OPC)
@param aEstorno		Codigo da amarracao entre o titulo compensado e o adiantamento ( E5_DOCUMEN ). Quando informado indica uma operacao de estorno. (OPC)
@param lHeadProva	Informa se o HeadProva já foi criado na rotina chamadora

@author Eduardo Riera 
@since 11/08/2003
/*/
//-------------------------------------------------------------------
#DEFINE CR_VLRABAT 01
#DEFINE CR_VLDESCR 02
#DEFINE CR_VLACRES 03
#DEFINE CR_VLVARMN 04

#DEFINE CMP_RECNO  1
#DEFINE CMP_VLRCMP 2
#DEFINE CMP_VLABAT 3
#DEFINE CMP_DTREC  4
#DEFINE CMP_LOTE   5
#DEFINE CMP_DATAP  6
#DEFINE CMP_TAXAP  7
#DEFINE CMP_NUMDEC 8
#DEFINE CMP_GRCONT 9
#DEFINE CMP_VLRCM 10
#DEFINE CMP_LCALCM 11

Function FCmpCPOLD(aTitulo, aCompensar, lLctPad, cOrigem, bContabil, bBlock, aEstorno, lHeadProva)
Local aArea     := GetArea()
Local aAreaSE2  := SE2->(GetArea())
Local aAreaCMP  := {}
Local aDelCMP   := {}
Local aDelCorre := {}
Local nW        := 0
Local nX        := 0
Local nY        := 0
Local nZ        := 0
Local nVlCpMdCp := 0
Local nVlCpMd1  := 0
Local nSldMdCR  := 0
Local nSldMdCp  := 0
Local nVlBxMd1  := 0
Local nMoedaCP  := SE2->E2_MOEDA
Local cMoed		:= StrZero(nMoedaCP,2)
Local nAtraso   := 0
Local cAliasSE2 := "SE2"
Local cAliasSE5 := "SE5"
Local cPrefixo  := SE2->E2_PREFIXO
Local cNumero   := SE2->E2_NUM
Local cParcela  := SE2->E2_PARCELA
Local cFornece  := SE2->E2_FORNECE
Local cLoja     := SE2->E2_LOJA
Local cPrincipal:= SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO
Local cNDF_RA   := ""
Local cSeqBx    := ""
Local cSeqBxCp  := ""
Local cPrimary  := ""
Local cFilterSE2:= SE2->(dbFilter())
Local lQuery    := .F.
Local lEstorno  := IIf(Empty(aEstorno),.F.,.T.)
Local l340Mov1 	:= ExistBlock("SE5FI340")
Local l340Mov2 	:= ExistBlock("SE5FI341")
Local lMaIntDel := ExistBlock("MaIntDel")
Local aSE5		:= {}
Local lUsaFlag	:= SuperGetMV( "MV_CTBFLAG" , .T. /*lHelp*/, .F. /*cPadrao*/)
Local aDiario	:= {}
Local aFlagCTB	:= {}
Local nRecSE2 	:= 0
Local nRecSE5 	:= 0
Local cQuery    := ""
Local cKeySE2   := SE2->(IndexKey())
Local oModelBxP := Nil
Local oSubFK2	:= NIL
Local oSubFK5	:= NIL
Local cLog		:= ""
Local cChaveTit := ""
Local cChaveFK7 := ""
Local cCamposE5 := ""
Local lRet		:= .T.
Local cIdFK2 	:= ""
Local lFA330SE2 := ExistBlock("FA330SE2")
Local lSigaEIC 	:= Type("cModulo")=="C" .and. cModulo=="EIC"
Local lCmTxCon  := SuperGetMv("MV_CMTXCON", .F., .F.)
Local cFornAdt	:= ''
Local cLojaAdt	:= ''
Local lPCCBaixa	:= SuperGetMv("MV_BX10925",.T.,"2") == "1"
Local cFilCred	:= ""
Local oModelMov := Nil

DEFAULT lLctPad		:= .F.
DEFAULT lHeadProva	:= .F.
DEFAULT cOrigem		:= "FINA340"
DEFAULT bContabil	:= {|| .T.}
DEFAULT bBlock		:= {|| .T.}

For nX := 1 To Len(aCompensar)
    For nY := 4 To 9
        If Len(aCompensar[nX])<nY
            aadd(aCompensar[nX],Nil)
        EndIf
        Do Case
        Case nY == 4
            DEFAULT aCompensar[nX][4] := dDataBase
        Case nY == 5
            DEFAULT aCompensar[nX][5] := ""
        Case nY == 8
            DEFAULT aCompensar[nX][8] := 2
        Case nY == 9
            DEFAULT aCompensar[nX][9] := .F.
        EndCase
    Next nX
Next nY

dbSelectArea("SA2")
dbSetOrder(1)
DbSeek(xFilial("SA2")+SE2->E2_FORNECE+SE2->E2_LOJA)

//Trava o registro principal
If RecLock("SE2") .And. RecLock("SA2")
    If !lEstorno
        For nX := 1 To Len(aCompensar)
            If aCompensar[nX][CMP_VLRCMP]<>0
                //Calcula os valores a compensar do Titulo principal
                cPrincipal:= SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA
                nVlBxMdCP := aCompensar[nX][CMP_VLRCMP]+aTitulo[2]-aTitulo[3]
                nVlBxMd1  := xMoeda(aCompensar[nX][CMP_VLRCMP],SE2->E2_MOEDA,1,aCompensar[nX][CMP_DATAP],aCompensar[nX][CMP_NUMDEC],aCompensar[nX][CMP_TAXAP])
                nSldMdCr  := SE2->E2_SALDO-nVlBxMdCP

                If ( (nSldMdCr - aTitulo[CR_VLRABAT]) <= 0.009 ) .OR. ( SE2->E2_SALDO - nSldMdCp <= aCompensar[nX][CMP_VLABAT] )
                    nSldMdCr := 0
                    nVlBxMdCP:= SE2->E2_SALDO
                EndIf

                //Verifica a proxima sequencia de baixa do titulo principal
                cSeqBx := FaNxtSeqBx("SE2")

                //Posiciona no titulo de adiantamento
                dbSelectArea("SE2")
                MsGoTo(aCompensar[nX][CMP_RECNO])
                cNDF_RA	:= SE2->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)
                cFornAdt := SE2->E2_FORNECE
                cLojaAdt := SE2->E2_LOJA

                If RecLock("SE2")
                    //Verifica a proxima sequencia de baixa
                    cSeqBxCp := FaNxtSeqBx("SE2")

                    //Verifica a maior sequencia entre os dois titulos
                    cSeqBx := IIf(cSeqBxCp>cSeqBx,cSeqBxCp,cSeqBx)

                    //Calcula os valores a compensar do Titulo de adiantamento
                    nVlCpMdCp := xMoeda(aCompensar[nX][CMP_VLRCMP],nMoedaCP,SE2->E2_MOEDA,aCompensar[nX][CMP_DATAP],aCompensar[nX][CMP_NUMDEC],aCompensar[nX][CMP_TAXAP])
                    nVlCpMd1  := xMoeda(aCompensar[nX][CMP_VLRCMP],nMoedaCP,1,aCompensar[nX][CMP_DATAP],aCompensar[nX][CMP_NUMDEC],aCompensar[nX][CMP_TAXAP])
                    nSldMdCp  := SE2->E2_SALDO-nVlCpMdCp

                    If ( SE2->E2_SALDO - (nSldMdCp + aCompensar[nX][CMP_VLABAT]) <= 0.009 )
                        nSldMdCp  := 0
                        nVlBxMdCp := SE2->E2_SALDO
                    EndIf

                    //Efetua a baixa do titulo principal
                    RestArea(aAreaSE2)
                    If lPccBaixa
                        SE2->E2_VRETPIS	:= SE2->E2_PIS
                        SE2->E2_VRETCOF	:= SE2->E2_COFINS
                        SE2->E2_VRETCSL	:= SE2->E2_CSLL
                        SE2->E2_PRETPIS	:= "7"
                        SE2->E2_PRETCOF	:= "7"
                        SE2->E2_PRETCSL	:= "7"
                        nSldMdCr	-= (SE2->E2_PIS+SE2->E2_COFINS+SE2->E2_CSLL)
                    EndIf
                    SE2->E2_SALDO   := nSldMdCr
                    SE2->E2_BAIXA   := aCompensar[nX][CMP_DTREC]
                    SE2->E2_LOTE    := aCompensar[nX][CMP_LOTE]
                    SE2->E2_MOVIMEN := aCompensar[nX][CMP_DTREC]
                    SE2->E2_DESCONT := 0
                    SE2->E2_MULTA   := 0
                    SE2->E2_JUROS   := 0
                    SE2->E2_SDACRES:= 0
                    SE2->E2_SDDECRE	:= 0

                    If aCompensar[nX][CMP_LCALCM] .And. (!lCmTxCon .Or. (lCmTxCon .And. !SE2->E2_TIPO $ MVPAGANT))
                        SE2->E2_CORREC  := aTitulo[CR_VLVARMN]
                    Endif

                    SE2->E2_VALLIQ  := nVlCpMd1

                    If lFA330SE2
                        ExecBlock("FA330SE2",.F.,.F.)
                    EndIf

                    //Calcula os dias de Atraso
                    nAtraso:=aCompensar[nX][CMP_DTREC]-SE2->E2_VENCTO
                    If nAtraso > 1
                        If Dow(SE2->E2_VENCTO) == 1 .Or. Dow(SE2->E2_VENCTO) == 7
                            If Dow(aCompensar[nX][CMP_DTREC]) == 2 .And. nAtraso <= 2
                                nAtraso := 0
                            EndIf
                        EndIf
                        nAtraso:=Max(0,nAtraso)
                    EndIf

                    //Atualiza os acumulados do cliente atualiza maior atraso
                    SA2->A2_MATR := nAtraso

                    //Efetua a movimentacao de baixa do titulo principal
                    If nVlBxMd1 != 0
                        oModelBxP := FWLoadModel("FINM020")

                        If !Empty(cCamposE5)
                            cCamposE5 += "|"
                        Endif

                        cCamposE5 += "{"
                        cCamposE5 += "{'E5_DTDIGIT', dDataBase}"
                        cCamposE5 += ",{'E5_PREFIXO', SE2->E2_PREFIXO}"
                        cCamposE5 += ",{'E5_NUMERO', SE2->E2_NUM}"
                        cCamposE5 += ",{'E5_PARCELA', SE2->E2_PARCELA}"
                        cCamposE5 += ",{'E5_CLIFOR', SE2->E2_FORNECE}"
                        cCamposE5 += ",{'E5_LOJA', SE2->E2_LOJA}"
                        cCamposE5 += ",{'E5_BENEF', SE2->E2_NOMFOR}"
                        cCamposE5 += ",{'E5_TIPO', SE2->E2_TIPO}"
                        cCamposE5 += ",{'E5_LA', '"+ IIf(lLctPad,"S","N")+"'}"
                        cCamposE5 += ",{'E5_FORNADT', '" + cFornAdt + "' }"
                        cCamposE5 += ",{'E5_LOJAADT', '" + cLojaAdt + "' }"
                        cCamposE5 += ",{'E5_FORNECE', SE2->E2_FORNECE }"
                        cCamposE5 += ",{'E5_DTDIGIT', dDataBase }"
                        cCamposE5 += ",{'E5_DTDISPO', SE2->E2_BAIXA }"
                        cCamposE5 += ",{'E5_VLDESCO',"+ Str(aTitulo[CR_VLDESCR])+" }"
                        cCamposE5 += ",{'E5_VLJUROS',"+ Str(aTitulo[CR_VLACRES])+" }"
                        cCamposE5 += ",{'E5_MOEDA', '"+ cMoed +"'}"
                        cCamposE5 += ",{'E5_VRETPIS', SE2->E2_VRETPIS }"
                        cCamposE5 += ",{'E5_VRETCOF', SE2->E2_VRETCOF }"
                        cCamposE5 += ",{'E5_VRETCSL', SE2->E2_VRETCSL }"
                        cCamposE5 += ",{'E5_PRETPIS', SE2->E2_PRETPIS }"
                        cCamposE5 += ",{'E5_PRETCOF', SE2->E2_PRETCOF }"
                        cCamposE5 += ",{'E5_PRETCSL', SE2->E2_PRETCSL }"

                        If aCompensar[nX][CMP_LCALCM] .And. (!lCmTxCon .Or. (lCmTxCon .And. !SE2->E2_TIPO $ MVPAGANT))
                            cCamposE5 += ",{'E5_VLCORRE',"+ Str(aTitulo[CR_VLVARMN])+" }"
                        Endif

                        cCamposE5 += "}"

                        oModelBxP:SetOperation( 3 ) //Inclusao
                        oModelBxP:Activate()

                        //Retorna o identifcador do processo.
                        cChaveTit := xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
                        cChaveFK7 := FINGRVFK7("SE2", cChaveTit)
                        cIdFK2 := FWUUIDV4()
                        oModelBxP:SetValue("FKADETAIL","FKA_IDORIG",cIdFK2)
                        oModelBxP:SetValue("FKADETAIL","FKA_TABORI","FK2")
                        oModelBxP:SetValue( "MASTER", "E5_GRV", .T. )
                        oModelBxP:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )
                        oModelBxP:SetValue( "MASTER", "NOVOPROC", .T. )
                        oSubFK2 := oModelBxP:GetModel("FK2DETAIL")
                        oSubFK5 := oModelBxP:GetModel("FK5DETAIL")

                        //Dados da baixa a pagar
                        oSubFK2:SetValue( "FK2_DATA", SE2->E2_BAIXA )
                        oSubFK2:SetValue( "FK2_VALOR", If(SE2->E2_MOEDA == 1, nVlBxMd1, nVlCpMdCp) )
                        oSubFK2:SetValue( "FK2_MOEDA", StrZero(SE2->E2_MOEDA,2) )
                        oSubFK2:SetValue( "FK2_NATURE", SE2->E2_NATUREZ )
                        oSubFK2:SetValue( "FK2_RECPAG", "P" )
                        oSubFK2:SetValue( "FK2_TPDOC", If(cOrigem=="MATA465","BA","CP") )

                        //Grava historico diferenciado gestao de contratos
                        If lSigaEIC
                            oSubFK2:SetValue( "FK2_HISTOR", STR0043)//"Compens. Autom. Adiantamento"
                        ElseIf aCompensar[nX,CMP_GRCONT]
                            oSubFK2:SetValue( "FK2_HISTOR", STR0044)//"//CMP--CTR..COMP.AUTOMATICA CAUCAO CONTRATOS"
                        Else
                            oSubFK2:SetValue( "FK2_HISTOR", STR0045)//"Comp.Autom.p/Devol.Compras"
                        EndIf

                        oSubFK2:SetValue( "FK2_VLMOE2", If(SE2->E2_MOEDA == 1, nVlCpMdCp, nVlBxMd1))
                        oSubFK2:SetValue( "FK2_MOTBX", "CMP" )
                        oSubFK2:SetValue( "FK2_TXMOED", aCompensar[nX][CMP_TAXAP] )
                        oSubFK2:SetValue( "FK2_ORIGEM", FunName() )
                        oSubFK2:SetValue( "FK2_SEQ", cSeqBx )
                        oSubFK2:SetValue( "FK2_IDDOC", cChaveFK7 )
                        oSubFK2:SetValue( "FK2_FILORI",	SE2->E2_FILORIG)
                        oSubFK2:SetValue( "FK2_LOTE", Substr(aCompensar[nX][CMP_LOTE],1, TAMSX3("FK2_LOTE")[1] ))
                        oSubFK2:SetValue( "FK2_DOC", cNDF_RA)

                        //Geracao de Correcao monetaria
                        If aCompensar[nX][CMP_LCALCM] .And. aTitulo[CR_VLVARMN] != 0
                            FinGerCM(1, 'P', aTitulo[CR_VLVARMN], oModelBxP, cIdFK2)
                        Endif

                        // Efetiva a Inclusão de Dados >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                        If oModelBxP:VldData()
                            oModelBxP:CommitData()
                            SE5->(dbGoto(oModelBxP:GetValue( "MASTER", "E5_RECNO" )))
                        Else
                            lRet := .F.
                            cLog := cValToChar(oModelBxP:GetErrorMessage()[4]) + ' - '
                            cLog += cValToChar(oModelBxP:GetErrorMessage()[5]) + ' - '
                            cLog += cValToChar(oModelBxP:GetErrorMessage()[6])
                            Help( ,,"M020VALID",,cLog, 1, 0 )
                        Endif

                        //Zerar Variáveis
                        cCamposE5 := ''
                        // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

                        If l340Mov1
                            ExecBlock("SE5FI340",.F.,.F.)
                        EndIf

                        //Guarda a chave primary da baixa para busca futura
                        cPrimary := SE5->E5_DOCUMEN
                        oModelBxP:DeActivate()
                        oModelBxP:Destroy()
                        oModelBxP := Nil
                        oSubFK5 := Nil
                        oSubFK2 := Nil
                    EndIf

                    //Encerra os titulos de abatimento caso a baixa seja total
                    If (SE2->E2_SALDO == 0 .And. aTitulo[CR_VLRABAT]<>0) .OR. ( (SE2->E2_SALDO-aTitulo[CR_VLRABAT]) == 0)
                        cPrefixo  := SE2->E2_PREFIXO
                        cNumero   := SE2->E2_NUM
                        cParcela  := SE2->E2_PARCELA
                        cFornece  := SE2->E2_FORNECE
                        cLoja     := SE2->E2_LOJA

                        dbSelectArea("SE2")
                        dbSetOrder(2)
                        SE2->(dbCommit())
                        aStruSE2  := SE2->(dbStruct())
                        cAliasSE2 := "FaCmpCR"
                        lQuery    := .T.
                        cQuery := "SELECT SE2.*, SE2.R_E_C_N_O_ SE2RECNO "
                        cQuery += "FROM "+RetSqlName("SE2")+" SE2 "
                        cQuery += "WHERE SE2.E2_FILIAL='"+xFilial("SE2")+"' AND "
                        cQuery += "SE2.E2_PREFIXO='"+cPrefixo+"' AND "
                        cQuery += "SE2.E2_NUM='"+cNumero+"' AND "
                        cQuery += "SE2.E2_PARCELA='"+cParcela+"' AND "
                        cQuery += "SE2.E2_FORNECE='"+cFornece+"' AND "
                        cQuery += "SE2.E2_LOJA='"+cLoja+"' AND "
                        cQuery += "SE2.D_E_L_E_T_=' ' "

                        cQuery := ChangeQuery(cQuery)

                        dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE2,.T.,.T.)

                        For nZ := 1 To Len(aStruSE2)
                            If aStruSE2[nZ][2]<>"C"
                                TcSetField(cAliasSE2,aStruSE2[nZ][1],aStruSE2[nZ][2],aStruSE2[nZ][3],aStruSE2[nZ][4])
                            EndIf
                        Next nZ

                        SE2->(dbClearFilter())
                        dbSelectArea("SE2")
                        dbSetOrder(6)	// E2_FILIAL, E2_FORNECE, E2_LOJA, E2_PREFIXO, E2_NUM, E2_PARCELA, E2_TIPO, R_E_C_N_O_, D_E_L_E_T_
                        DbSeek(xFilial("SE2")+cFornece+cLoja+cPrefixo+cNumero+cParcela)

                        While !Eof() .And. (cAliasSE2)->E2_FILIAL == xFilial("SE2") .And.;
                                (cAliasSE2)->E2_FORNECE == cFornece	.And.;
                                (cAliasSE2)->E2_LOJA == cLoja .And.;
                                (cAliasSE2)->E2_PREFIXO == cPrefixo .And.;
                                (cAliasSE2)->E2_NUM == cNumero .And.;
                                (cAliasSE2)->E2_PARCELA == cParcela

                            If (cAliasSE2)->E2_TIPO $ MVABATIM+"/"+MVIRABT+"/"+MVINABT+"/"+MVPIABT+"/"+	MVCFABT+"/"+MVCSABT
                                If lQuery
                                    dbSelectArea("SE2")
                                    MsGoto((cAliasSE2)->SE2RECNO)
                                EndIf
                                RecLock("SE2")
                                SE2->E2_SALDO   := 0
                                SE2->E2_BAIXA   := aCompensar[nX][CMP_DTREC]
                                SE2->E2_LOTE    := aCompensar[nX][CMP_LOTE]
                                SE2->E2_MOVIMEN := aCompensar[nX][CMP_DTREC]
                                MsUnLock()
                            EndIf
                            dbSelectArea(cAliasSE2)
                            dbSkip()
                        EndDo
                        If lQuery
                            dbSelectArea(cAliasSE2)
                            dbCloseArea()
                            dbSelectArea("SE2")
                        Else
                            dbSelectArea("SE2")
                            If !Empty(cFilterSE2)
                                If nOrdSE2 == 0 .And. !Empty(cKeySE2)
                                    cFilterSE2 += ".AND. ORDERBY("+StrTran(ClearKey(cKeySE2),"+",",")+")"
                                EndIf
                            EndIf

                            If ( !Empty(cFilterSE2) )
                                Set Filter to &cFilterSE2
                            EndIf
                        EndIf
                    EndIf

                    If nVlBxMd1 <> 0
                        cFornAdt := SE2->E2_FORNECE
                        cLojaAdt := SE2->E2_LOJA

                        //Posiciona no titulo de adiantamento
                        dbSelectArea("SE2")
                        MsGoTo(aCompensar[nX][CMP_RECNO])

                        //Efetua a baixa do titulo de adiantamento
                        RecLock("SE2")
                        SE2->E2_SALDO   := nSldMdCp
                        SE2->E2_BAIXA   := aCompensar[nX][CMP_DTREC]
                        SE2->E2_LOTE    := aCompensar[nX][CMP_LOTE]
                        SE2->E2_MOVIMEN := aCompensar[nX][CMP_DTREC]
                        SE2->E2_DESCONT := 0
                        SE2->E2_MULTA   := 0
                        SE2->E2_JUROS   := 0

                        If aCompensar[nX][CMP_LCALCM] .And. (!lCmTxCon .Or. (lCmTxCon .And. !SE2->E2_TIPO $ MVPAGANT))
                            SE2->E2_CORREC  := aCompensar[nX][10]
                        Endif

                        SE2->E2_VALLIQ  := nVlCpMd1
                        SE2->E2_SDACRES := 0
                        SE2->E2_SDDECRE := 0

                        If !Empty(SE5->E5_DOCUMEN)
                            oModelBxP := FWLoadModel("FINM020")

                            If !Empty(cCamposE5)
                                cCamposE5 += "|"
                                If lCmTxCon
                                    cCamposE5 := ""
                                EndIf
                            Endif

                            cCamposE5 += "{"
                            cCamposE5 += "{'E5_DTDIGIT', dDataBase}"
                            cCamposE5 += ",{'E5_PREFIXO', SE2->E2_PREFIXO}"
                            cCamposE5 += ",{'E5_NUMERO', SE2->E2_NUM}"
                            cCamposE5 += ",{'E5_PARCELA', SE2->E2_PARCELA}"
                            cCamposE5 += ",{'E5_CLIFOR', SE2->E2_FORNECE}"
                            cCamposE5 += ",{'E5_LOJA', SE2->E2_LOJA}"
                            cCamposE5 += ",{'E5_BENEF', SE2->E2_NOMFOR}"
                            cCamposE5 += ",{'E5_TIPO', SE2->E2_TIPO}"
                            cCamposE5 += ",{'E5_LA', '"+ IIf(lLctPad,"S","N")+"'}"
                            cCamposE5 += ",{'E5_FORNADT', '" + cFornAdt + "' }"
                            cCamposE5 += ",{'E5_LOJAADT', '" + cLojaAdt + "' }"
                            cCamposE5 += ",{'E5_FORNECE', SE2->E2_FORNECE }"
                            cCamposE5 += ",{'E5_DTDIGIT', dDataBase }"
                            cCamposE5 += ",{'E5_DTDISPO', SE2->E2_BAIXA }"
                            cCamposE5 += ",{'SE5->E5_MOEDA', '"+ cMoed +"'}"

                            If aCompensar[nX][CMP_LCALCM] .And. (!lCmTxCon .Or. (lCmTxCon .And. !SE2->E2_TIPO $ MVPAGANT))
                                cCamposE5 += ",{'E5_VLCORRE',"+Str( aCompensar[nX][10])+" }"
                            Endif

                            cCamposE5 += "}"

                            oModelBxP:SetOperation( 3 ) //Inclusao
                            oModelBxP:Activate()
                            oModelBxP:SetValue( "MASTER", "E5_GRV", .T. ) //Informa se vai gravar SE5 ou não
                            oModelBxP:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5

                            //Dados da tabela auxiliar com o código do título a pagar
                            cChaveTit := xFilial("SE2")+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
                            cChaveFK7 := FINGRVFK7("SE2", cChaveTit)
                            cIdFK2 := FWUUIDV4()
                            oModelBxP:SetValue("FKADETAIL", "FKA_IDORIG"	, cIdFK2 )
                            oModelBxP:SetValue("FKADETAIL", "FKA_TABORI"	, 'FK2')
                            //
                            oSubFK2 := oModelBxP:GetModel("FK2DETAIL")
                            oSubFK5 := oModelBxP:GetModel("FK5DETAIL")

                            //Dados da baixa a pagar
                            oSubFK2:SetValue( "FK2_IDFK2", cIdFK2 )
                            oSubFK2:SetValue( "FK2_DATA", SE2->E2_BAIXA )
                            oSubFK2:SetValue( "FK2_VALOR", If(SE2->E2_MOEDA == 1, nVlCpMd1, nVlCpMdCp))
                            oSubFK2:SetValue( "FK2_MOEDA", StrZero(SE2->E2_MOEDA,2) )
                            oSubFK2:SetValue( "FK2_NATURE", SE2->E2_NATUREZ )
                            oSubFK2:SetValue( "FK2_RECPAG", "P" )
                            oSubFK2:SetValue( "FK2_TPDOC",  If(cOrigem<>"MATA465","BA","CP") )

                            //Grava historico diferenciado gestao de contratos
                            If lSigaEIC
                                oSubFK2:SetValue( "FK2_HISTOR", STR0043)//"Compens. Autom. Adiantamento"
                            ElseIf aCompensar[nX,CMP_GRCONT]
                                oSubFK2:SetValue( "FK2_HISTOR", STR0044)//"//CMP--CTR..COMP.AUTOMATICA CAUCAO CONTRATOS"
                            Else
                                oSubFK2:SetValue( "FK2_HISTOR", STR0045)//"Comp.Autom.p/Devol.Compras"
                            EndIf

                            oSubFK2:SetValue( "FK2_VLMOE2", If(SE2->E2_MOEDA == 1, nVlCpMdCp, nVlCpMd1))
                            oSubFK2:SetValue( "FK2_MOTBX", "CMP" )
                            oSubFK2:SetValue( "FK2_TXMOED", aCompensar[nX][CMP_TAXAP] )
                            oSubFK2:SetValue( "FK2_ORIGEM", FunName() )
                            oSubFK2:SetValue( "FK2_SEQ", cSeqBx )
                            oSubFK2:SetValue( "FK2_IDDOC", cChaveFK7 )
                            oSubFK2:SetValue( "FK2_FILORI",	SE2->E2_FILORIG)
                            oSubFK2:SetValue( "FK2_LOTE", Substr(aCompensar[nX][CMP_LOTE],1, TAMSX3("FK2_LOTE")[1] ))
                            oSubFK2:SetValue( "FK2_DOC", cPrincipal)

                            If aCompensar[nX][CMP_LCALCM] .and. aCompensar[nX][CMP_VLRCM] != 0    // Geracao de Correcao monetaria
                                FinGerCM(2, 'P', aCompensar[nX][CMP_VLRCM], oModelBxP, cIdFK2)
                            EndIf

                            oModelBxP:SetValue( "MASTER", "E5_GRV", .T. ) //Informa se vai gravar SE5 ou não
                            oModelBxP:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5
                            oModelBxP:SetValue( "MASTER", "NOVOPROC", .T. ) //Informa que a inclusao sera feita com um novo numero de processo

                            // Efetiva a Inclusão de Dados >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                            If oModelBxP:VldData()
                                oModelBxP:CommitData()
                                SE5->(dbGoto(oModelBxP:GetValue( "MASTER", "E5_RECNO" )))
                            Else
                                lRet := .F.
                                cLog := cValToChar(oModelBxP:GetErrorMessage()[4]) + ' - '
                                cLog += cValToChar(oModelBxP:GetErrorMessage()[5]) + ' - '
                                cLog += cValToChar(oModelBxP:GetErrorMessage()[6])

                                Help( ,,"M020VALID",,cLog, 1, 0 )
                            Endif

                            //Zerar Variáveis
                            cCamposE5 := ''
                            // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

                            If l340Mov2
                                ExecBlock("SE5FI341",.F.,.F.)
                            EndIf

                            oModelBxP:DeActivate()
                            oModelBxP:Destroy()
                            oModelBxP := Nil
                            oSubFK5 := Nil
                            oSubFK2 := Nil
                        EndIf

                        //Encerra os titulos de abatimento caso a baixa seja total
                        If SE2->E2_SALDO == 0 .And. aCompensar[nX][CMP_VLABAT] <> 0
                            cPrefixo  := SE2->E2_PREFIXO
                            cNumero   := SE2->E2_NUM
                            cParcela  := SE2->E2_PARCELA
                            cFornece  := SE2->E2_FORNECE
                            cLoja     := SE2->E2_LOJA

                            dbSelectArea("SE2")
                            dbSetOrder(2)
                            SE2->(dbCommit())
                            aStruSE2  := SE2->(dbStruct())
                            cAliasSE2 := "FaCmpCP"
                            lQuery    := .T.
                            cQuery := "SELECT SE2.*, SE2.R_E_C_N_O_ SE2RECNO "
                            cQuery += "FROM "+RetSqlName("SE2")+" SE2 "
                            cQuery += "WHERE SE2.E2_FILIAL='"+xFilial("SE2")+"' AND "
                            cQuery += "SE2.E2_PREFIXO='"+cPrefixo+"' AND "
                            cQuery += "SE2.E2_NUM='"+cNumero+"' AND "
                            cQuery += "SE2.E2_PARCELA='"+cParcela+"' AND "
                            cQuery += "SE2.E2_FORNECE='"+cFornece+"' AND "
                            cQuery += "SE2.E2_LOJA='"+cLoja+"' AND "
                            cQuery += "SE2.D_E_L_E_T_=' ' "

                            cQuery := ChangeQuery(cQuery)

                            dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE2,.T.,.T.)

                            For nX := 1 To Len(aStruSE2)
                                If aStruSE2[nX][2]<>"C"
                                    TcSetField(cAliasSE2,aStruSE2[nX][1],aStruSE2[nX][2],aStruSE2[nX][3],aStruSE2[nX][4])
                                EndIf
                            Next nX

                            SE2->(dbClearFilter())
                            DbSeek(xFilial("SE2")+cFornece+cLoja+cPrefixo+cNumero+cParcela)
                            While !Eof() .And. (cAliasSE2)->E2_FILIAL == xFilial("SE2") .And.;
                                    (cAliasSE2)->E2_FORNECE == cFornece	.And.;
                                    (cAliasSE2)->E2_LOJA == cLoja .And.;
                                    (cAliasSE2)->E2_PREFIXO == cPrefixo .And.;
                                    (cAliasSE2)->E2_NUM == cNumero .And.;
                                    (cAliasSE2)->E2_PARCELA == cParcela

                                If (cAliasSE2)->E2_TIPO $ MVABATIM+"/"+MVIRABT+"/"+MVINABT+"/"+MVPIABT+"/"+	MVCFABT+"/"+MVCSABT
                                    If lQuery
                                        dbSelectArea("SE2")
                                        MsGoto((cAliasSE2)->SE2RECNO)
                                    EndIf
                                    RecLock("SE2")
                                    SE2->E2_SALDO   := 0
                                    SE2->E2_BAIXA   := aCompensar[nX][CMP_DTREC]
                                    SE2->E2_LOTE    := aCompensar[nX][CMP_LOTE]
                                    SE2->E2_MOVIMEN := aCompensar[nX][CMP_DTREC]
                                    MsUnLock()
                                EndIf
                                dbSelectArea(cAliasSE2)
                                dbSkip()
                            EndDo
                            If lQuery
                                dbSelectArea(cAliasSE2)
                                dbCloseArea()
                                dbSelectArea("SE2")
                            Else
                                dbSelectArea("SE2")
                                If !Empty(cFilterSE2)
                                    If nOrdSE2 == 0 .And. !Empty(cKeySE2)
                                        cFilterSE2 += ".AND. ORDERBY("+StrTran(ClearKey(cKeySE2),"+",",")+")"
                                    EndIf
                                EndIf

                                If ( !Empty(cFilterSE2) )
                                    Set Filter to &cFilterSE2
                                EndIf
                            EndIf
                        EndIf
                    EndIf
                EndIf
            EndIf

            If lLctPad
                //Posiciona no titulo de adiantamento
                dbSelectArea("SE2")
                MsGoTo(aCompensar[nX][CMP_RECNO])
                Eval(bContabil)
            EndIf

            //Executa o codeblock
            Eval(bBlock,aAreaSE2[3],cPrimary)
            //Repociona o titulo principal
            RestArea(aAreaSE2)
        Next nX
    Else
        //Inicia o estorno da compensacao
        aTitulo    := Array(3)
        aTitulo    := Afill(aTitulo,0)
        aCompensar := Array(8)
        aCompensar := Afill(aCompensar,0)

        If RecLock("SE2")
            // Restaura os titulos de abatimento caso a baixa seja total
            If SE2->E2_SALDO == 0
                dbSelectArea("SE2")
                dbSetOrder(2)
                SE2->(dbCommit())
                aStruSE2  := SE2->(dbStruct())
                cAliasSE2 := "FaCmpCR"
                lQuery    := .T.
                cQuery := "SELECT SE2.*,SE2.R_E_C_N_O_ SE2RECNO "
                cQuery += "FROM "+RetSqlName("SE2")+" SE2 "
                cQuery += "WHERE SE2.E2_FILIAL='"+xFilial("SE2")+"' AND "
                cQuery += "SE2.E2_PREFIXO='"+cPrefixo+"' AND "
                cQuery += "SE2.E2_NUM='"+cNumero+"' AND "
                cQuery += "SE2.E2_PARCELA='"+cParcela+"' AND "
                cQuery += "SE2.E2_FORNECE='"+cFornece+"' AND "
                cQuery += "SE2.E2_LOJA='"+cLoja+"' AND "
                cQuery += "SE2.D_E_L_E_T_=' ' "

                cQuery := ChangeQuery(cQuery)

                dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE2,.T.,.T.)

                For nX := 1 To Len(aStruSE2)
                    If aStruSE2[nX][2]<>"C"
                        TcSetField(cAliasSE2,aStruSE2[nX][1],aStruSE2[nX][2],aStruSE2[nX][3],aStruSE2[nX][4])
                    EndIf
                Next nX

                While !Eof() .And. (cAliasSE2)->E2_FILIAL == xFilial("SE2") .And.;
                        (cAliasSE2)->E2_FORNECE == cFornece	.And.;
                        (cAliasSE2)->E2_LOJA == cLoja .And.;
                        (cAliasSE2)->E2_PREFIXO == cPrefixo .And.;
                        (cAliasSE2)->E2_NUM == cNumero .And.;
                        (cAliasSE2)->E2_PARCELA == cParcela

                    If (cAliasSE2)->E2_TIPO $ MVABATIM+"/"+MVIRABT+"/"+MVINABT+"/"+MVPIABT+"/"+	MVCFABT+"/"+MVCSABT
                        If lQuery
                            dbSelectArea("SE2")
                            MsGoto((cAliasSE2)->SE2RECNO)
                        EndIf
                        RecLock("SE2")
                        SE2->E2_SALDO   := SE2->E2_VALOR
                        SE2->E2_BAIXA   := Ctod("")
                        SE2->E2_LOTE    := ""
                        SE2->E2_MOVIMEN := Ctod("")
                        MsUnLock()
                        aTitulo[CR_VLRABAT] := SE2->E2_VALOR
                    EndIf
                    dbSelectArea(cAliasSE2)
                    dbSkip()
                EndDo
                If lQuery
                    dbSelectArea(cAliasSE2)
                    dbCloseArea()
                    dbSelectArea("SE2")
                Else
                    dbSelectArea("SE2")
                    If !Empty(cFilterSE2)
                        If nOrdSE2 == 0 .And. !Empty(cKeySE2)
                            cFilterSE2 += ".AND. ORDERBY("+StrTran(ClearKey(cKeySE2),"+",",")+")"
                        EndIf
                    EndIf

                    If ( !Empty(cFilterSE2) )
                        Set Filter to &cFilterSE2
                    EndIf
                EndIf
            EndIf
            // Efetua o estorno de um baixa
            RestArea(aAreaSE2)

            // Atualiza o saldo do titulo com base no abatimento
            SE2->E2_SALDO += aTitulo[CR_VLRABAT]
            SE2->E2_CORREC := 0

            // Pesquisa pelos registros de baixa da compensacao
            dbSelectArea("SE5")
            dbSetOrder(7)

            DbSeek(xFilial("SE5")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA)

            While !Eof() .And. (cAliasSE5)->E5_FILIAL == xFilial("SE5") .And.;
                    (cAliasSE5)->E5_PREFIXO == SE2->E2_PREFIXO .And.;
                    (cAliasSE5)->E5_NUMERO == SE2->E2_NUM      .And.;
                    (cAliasSE5)->E5_PARCELA == SE2->E2_PARCELA .And.;
                    (cAliasSE5)->E5_TIPO == SE2->E2_TIPO       .And.;
                    (cAliasSE5)->E5_CLIFOR == SE2->E2_FORNECE .And.;
                    (cAliasSE5)->E5_LOJA == SE2->E2_LOJA

                If TemBxCanc( (cAliasSE5)->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ) , .T. )
                    (cAliasSE5)->( dbskip())
                    Loop
                EndIf

                If ((cAliasSE5)->E5_TIPODOC == "CP" .And. (cAliasSE5)->E5_MOTBX == "CMP" .And. (cAliasSE5)->E5_RECPAG == "P") .OR. (cAliasSE5)->E5_TIPODOC == "CM"

                    If (cAliasSE5)->E5_TIPODOC == "CM"
                        aadd(aDelCorre,{ SE5->(Recno()) })
                    ElseIf aScan(aEstorno,(cAliasSE5)->E5_DOCUMEN) <> 0
                        aadd(aDelCmp,{(cAliasSE5)->E5_DOCUMEN,(cAliasSE5)->(RecNo()),(cAliasSE5)->E5_SEQ })
                    EndIf

                EndIf
                dbSelectArea(cAliasSE5)
                dbSkip()
            EndDo
            If lQuery
                dbSelectArea(cAliasSE5)
                dbCloseArea()
                dbSelectArea("SE5")
            EndIf
            If Len(aDelCmp)>0
                For nX := 1 To Len(aDelCmp)

                    // Posiciona no registro de baixa do titulo compensado
                    dbSelectArea("SE5")
                    SE5->(DbGoTo(aDelCmp[nx][2])) //Posiciono no titulo marcado na tela
                    lPrimeiro := .T.
                    cSeqBx := aDelCmp[nX][3]
                    //Busca através do E5_DOCUMEN , o título a ser estornada a compensação, retornando a filial de compensação do título
                    cFilCred := FaFilSE5Or(SE5->E5_FILIAL,SE5->E5_PREFIXO,SE5->E5_NUMERO,SE5->E5_PARCELA,SE5->E5_CLIFOR,SE5->E5_LOJA,SE5->E5_TIPO,SE5->E5_DATA,SE5->E5_SEQ,"P",SE5->E5_DOCUMEN,SE5->E5_TIPODOC)

                    // Pesquisa o titulo de adiantamento
                    dbSelectArea("SE2")
                    dbSetOrder(1)
                    If DbSeek(xFilial("SE2",cFilCred)+RTrim(aDelCmp[nX][1])) .And. RecLock("SE2")
                        // Restaura os titulos de abatimento caso a baixa seja total
                        aAreaCMP := SE2->(GetArea())
                        If SE2->E2_SALDO == 0
                            cPrefixo  := SE2->E2_PREFIXO
                            cNumero   := SE2->E2_NUM
                            cParcela  := SE2->E2_PARCELA
                            cFornece  := SE2->E2_FORNECE
                            cLoja     := SE2->E2_LOJA

                            dbSelectArea("SE2")
                            dbSetOrder(2)
                            SE2->(dbCommit())
                            aStruSE2  := SE2->(dbStruct())
                            cAliasSE2 := "FaCmpCP"
                            lQuery    := .T.
                            cQuery := "SELECT SE2.*,SE2.R_E_C_N_O_ SE2RECNO "
                            cQuery += "FROM "+RetSqlName("SE2")+" SE2 "
                            cQuery += "WHERE SE2.E2_FILIAL='"+xFilial("SE2")+"' AND "
                            cQuery += "SE2.E2_PREFIXO='"+cPrefixo+"' AND "
                            cQuery += "SE2.E2_NUM='"+cNumero+"' AND "
                            cQuery += "SE2.E2_PARCELA='"+cParcela+"' AND "
                            cQuery += "SE2.E2_FORNECE='"+cFornece+"' AND "
                            cQuery += "SE2.E2_LOJA='"+cLoja+"' AND "
                            cQuery += "SE2.D_E_L_E_T_=' ' "

                            cQuery := ChangeQuery(cQuery)

                            dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE2,.T.,.T.)

                            For nY := 1 To Len(aStruSE2)
                                If aStruSE2[nY][2]<>"C"
                                    TcSetField(cAliasSE2,aStruSE2[nY][1],aStruSE2[nY][2],aStruSE2[nY][3],aStruSE2[nY][4])
                                EndIf
                            Next nY

                            While !Eof() .And. (cAliasSE2)->E2_FILIAL == xFilial("SE2") .And.;
                                    (cAliasSE2)->E2_FORNECE == cFornece	.And.;
                                    (cAliasSE2)->E2_LOJA == cLoja .And.;
                                    (cAliasSE2)->E2_PREFIXO == cPrefixo .And.;
                                    (cAliasSE2)->E2_NUM == cNumero .And.;
                                    (cAliasSE2)->E2_PARCELA == cParcela

                                If (cAliasSE2)->E2_TIPO $ MVABATIM+"/"+MVIRABT+"/"+MVINABT+"/"+MVPIABT+"/"+	MVCFABT+"/"+MVCSABT
                                    If lQuery
                                        dbSelectArea("SE2")
                                        MsGoto((cAliasSE2)->SE2RECNO)
                                    EndIf
                                    RecLock("SE2")
                                    SE2->E2_SALDO   := SE2->E2_VALOR
                                    SE2->E2_BAIXA   := Ctod("")
                                    SE2->E2_LOTE    := ""
                                    SE2->E2_MOVIMEN := CtoD("")
                                    MsUnLock()
                                    aCompensar[CMP_VLABAT] := SE2->E2_VALOR
                                EndIf
                                dbSelectArea(cAliasSE2)
                                dbSkip()
                            EndDo
                            If lQuery
                                dbSelectArea(cAliasSE2)
                                dbCloseArea()
                                dbSelectArea("SE2")
                            Else
                                dbSelectArea("SE2")
                                If !Empty(cFilterSE2)
                                    If nOrdSE2 == 0 .And. !Empty(cKeySE2)
                                        cFilterSE2 += ".AND. ORDERBY("+StrTran(ClearKey(cKeySE2),"+",",")+")"
                                    EndIf
                                EndIf

                                If ( !Empty(cFilterSE2) )
                                    Set Filter to &cFilterSE2
                                EndIf
                            EndIf
                        EndIf

                        // Reposiciona nos titulos de adiantamento
                        RestArea(aAreaCMP)

                        // Atualiza o saldo do titulo com base no abatimento
                        SE2->E2_SALDO += aCompensar[CMP_VLABAT]

                        // Localiza o registro de baixa do adiantamento
                        dbSelectArea("SE5")
                        dbSetOrder(7)
                        If DbSeek(xFilial("SE5")+SE2->E2_PREFIXO+SE2->E2_NUM+SE2->E2_PARCELA+SE2->E2_TIPO+SE2->E2_FORNECE+SE2->E2_LOJA+cSeqBx)
                            While ( !Eof() .And. SE5->E5_FILIAL == xFilial("SE5") .And.;
                                    SE5->E5_PREFIXO == SE2->E2_PREFIXO .And.;
                                    SE5->E5_NUMERO == SE2->E2_NUM .And.;
                                    SE5->E5_PARCELA == SE2->E2_PARCELA .And.;
                                    SE5->E5_TIPO == SE2->E2_TIPO .And.;
                                    SE5->E5_CLIFOR == SE2->E2_FORNECE .And.;
                                    SE5->E5_LOJA == SE2->E2_LOJA .And.;
                                    SE5->E5_SEQ == cSeqBx )

								If TemBxCanc(   SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ) , .T.)
									SE5->( dbskip())
									Loop
								EndIf

								If SE5->E5_TIPODOC <> "CM"
									// Atualiza o saldo do titulo com base no SE5
									SE2->E2_SALDO += SE5->E5_VALOR
								Endif

								// Bloco de codigo para contabilizacao
								If lMaIntDel .and. ExecBlock("MaIntDel",.F.,.F.)
									If AllTrim( SE5->E5_TABORI ) == "FK2"
										aAreaAnt := GetArea()
										dbSelectArea( "FK2" )
										FK2->( DbSetOrder( 1 ) )
										If MsSeek( xFilial("FK2") + SE5->E5_IDORIG )
											oModelMov := FWLoadModel("FINM020") //Model de baixas a pagar
											oModelMov:SetOperation( 4 ) //Alteração
											oModelMov:Activate()
											oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
											//E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
											//E5_OPERACAO 2 = Grava E5 com E5_TIPODOC = 'ES' e gera estorno na FK5
											//E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5
											oModelMov:SetValue( "MASTER", "E5_OPERACAO", 2 ) //E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5

											cCamposE5 := "{"

											If lUsaFlag
												aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
											Elseif !lUsaFlag .and. lLctPad
												cCamposE5 += "{'E5_LA', 'S'}
											EndIf

											If UsaSeqCor()
												if Len(cCamposE5)>1
													cCamposE5 += ","
												endif
												cCamposE5 += "{'E5_NODIA', ''}"
											EndIf
											cCamposE5 += "}"

											If oModelMov:VldData()
												oModelMov:CommitData()
												SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
											Else
												lRet := .F.
												cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
												cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
												cLog += cValToChar(oModelMov:GetErrorMessage()[6])

												Help( ,,"M030VALID",,cLog, 1, 0 )

											Endif

											oModelMov:DeActivate()
											oModelMov:Destroy()
											oModelMov := Nil
										Endif
										RestArea(aAreaAnt)
									EndIf

									If UsaSeqCor()
										AAdd(aDiario,{"SE5",SE5->(Recno()),SE5->E5_DIACTB,"E5_NODIA","E5_DIACTB"})
									EndIf

									If lLctPad
										If lHeadProva
											REGVALOR := SE2->(RecNo())
											nTotalCtb += DetProva(nHdlPrv,cPadrao,"FINA330",cLoteCtb)
										EndIf
									EndIf

									Else

									If lLctPad
										Eval(bContabil)
									EndIf

									// Deleta o registro de baixa
									If AllTrim( SE5->E5_TABORI ) == "FK2"
										aAreaAnt := GetArea()
										dbSelectArea( "FK2" )
										FK2->( DbSetOrder( 1 ) )
										If MsSeek( xFilial("FK2") + SE5->E5_IDORIG )
											oModelMov := FWLoadModel("FINM020") //Model de baixas a pagar
											oModelMov:SetOperation( 4 ) //Alteração
											oModelMov:Activate()
											oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
											//E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
											//E5_OPERACAO 2 = Grava E5 com E5_TIPODOC = 'ES' e gera estorno na FK5
											//E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5
											oModelMov:SetValue( "MASTER", "E5_OPERACAO", 3 ) //E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5

											If oModelMov:VldData()
												oModelMov:CommitData()
												SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
											Else
												lRet := .F.
												cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
												cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
												cLog += cValToChar(oModelMov:GetErrorMessage()[6])

												Help( ,,"M030VALID",,cLog, 1, 0 )
											Endif

											oModelMov:DeActivate()
											oModelMov:Destroy()
											oModelMov := Nil
										Endif
										RestArea(aAreaAnt)
									Endif

								Endif

                                dbSelectArea("SE5")
                                dbSkip()
                            EndDo

                            For nY := 1 to Len( aDelCorre )
                                dbGoTo(aDelCorre[nY][1])
                                // Bloco de codigo para contabilizacao
                                If lLctPad
                                    Eval(bContabil)
                                EndIf
                                If AllTrim( SE5->E5_TABORI ) == "FK2"
                                    aAreaAnt := GetArea()
                                    dbSelectArea( "FK2" )
                                    FK2->( DbSetOrder( 1 ) )
                                    If MsSeek( xFilial("FK2") + SE5->E5_IDORIG )
                                        oModelMov := FWLoadModel("FINM020") //Model de baixas a pagar
                                        oModelMov:SetOperation( 4 ) //Alteração
                                        oModelMov:Activate()
                                        oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
                                        //E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
                                        //E5_OPERACAO 2 = Grava E5 com E5_TIPODOC = 'ES' e gera estorno na FK5
                                        //E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5
                                        oModelMov:SetValue( "MASTER", "E5_OPERACAO", 3 ) //E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5

                                        If oModelMov:VldData()
                                            oModelMov:CommitData()
                                            SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
                                        Else
                                            lRet := .F.
                                            cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
                                            cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
                                            cLog += cValToChar(oModelMov:GetErrorMessage()[6])
                                            Help( ,,"M030VALID",,cLog, 1, 0)
                                        Endif

                                        oModelMov:DeActivate()
                                        oModelMov:Destroy()
                                        oModelMov := Nil
                                    Endif
                                    RestArea(aAreaAnt)
                                EndIf

                            Next nY

                            // Encerra a atualizacao do adiantamento
                            SE2->E2_VALLIQ := 0
                            SE2->E2_BAIXA  := IIf(SE2->E2_SALDO==SE2->E2_VALOR,Ctod(""),SE2->E2_BAIXA)
                        EndIf
                    EndIf

                    // Reposiciona o titulo principal
                    SE2->E2_CORREC := 0
                    RestArea(aAreaSE2)

                    // Reposiciona no registro de baixa do titulo compensado
                    dbSelectArea("SE5")
                    MsGoto(aDelCmp[nX][2])

                    // Guarda a chave primary da baixa para busca futura
                    cPrimary := SE5->E5_DOCUMEN

                    If lMaIntDel .and. ExecBlock("MaIntDel",.F.,.F.)

                        // Obtem os dados do registro tipo RA para gerar um	registro de estorno
                        aSE5 := {}
                        dbSetOrder( 1 )
                        For nW := 1 to SE5->( Fcount() )
                            AAdd( aSE5, SE5->( FieldGet(nW) ) )
                        Next

                        // Grava o registro de estorno
                        If AllTrim( SE5->E5_TABORI ) == "FK2"
                            aAreaAnt := GetArea()
                            dbSelectArea( "FK2" )
                            FK2->( DbSetOrder( 1 ) )
                            If MsSeek( xFilial("FK2") + SE5->E5_IDORIG )
                                oModelMov := FWLoadModel("FINM020") //Model de baixas a pagar
                                oModelMov:SetOperation( 4 ) //Alteração
                                oModelMov:Activate()
                                oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
                                //E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
                                //E5_OPERACAO 2 = Grava E5 com E5_TIPODOC = 'ES' e gera estorno na FK5
                                //E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5
                                oModelMov:SetValue( "MASTER", "E5_OPERACAO", 2 ) //E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5

                                cCamposE5 := "{"

                                If lUsaFlag
                                    aAdd( aFlagCTB, {"E5_LA", "S", "SE5", SE5->( Recno() ), 0, 0, 0} )
                                Elseif !lUsaFlag .and. lLctPad
                                    cCamposE5 += "{'E5_LA', 'S'}
                                EndIf

                                If UsaSeqCor()
                                    if Len(cCamposE5)>1
                                       cCamposE5 += ","
                                    endif
                                    cCamposE5 += "{'E5_NODIA', ''}"
                                EndIf
                                cCamposE5 += "}"

                                If oModelMov:VldData()
                                       oModelMov:CommitData()
                                       SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
                                Else
                                    lRet := .F.
                                    cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
                                    cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
                                    cLog += cValToChar(oModelMov:GetErrorMessage()[6])
                                    Help( ,,"M030VALID",,cLog, 1, 0 )
                                Endif

                                oModelMov:DeActivate()
                                oModelMov:Destroy()
                                oModelMov := Nil
                            Endif
                            RestArea(aAreaAnt)
                        EndIf

                        If UsaSeqCor()
                            AAdd(aDiario,{"SE5",SE5->(Recno()),SE5->E5_DIACTB,"E5_NODIA","E5_DIACTB"})
                        EndIf

                        If lHeadProva
                            VALOR    := SE5->E5_VALOR
                            VALOR2	:= SE5->E5_VLCORRE  //Variacao monetaria do titulo Principal
                            nRecSE2 := SE2->(Recno())
                            nRecSE5 := SE5->(Recno())
                            SE5->(MsGoto(0))
                            SE2->(MsGoto(0))
                            REGVALOR := SE2->(RecNo())
                            nTotalCtb += DetProva(nHdlPrv,cPadrao,"FINA330",cLoteCtb)
                            VALOR		:= 0
                            VALOR2	:= 0
                            SE5->(DbGoTo(nRecSE5))
                            SE2->(DbGoTo(nRecSE2))
                        EndIf

                    Else

                        If lHeadProva
                            VALOR    := SE5->E5_VALOR
                            VALOR2	:= SE5->E5_VLCORRE  //Variacao monetaria do titulo Principal
                            nRecSE2 := SE2->(Recno())
                            nRecSE5 := SE5->(Recno())
                            REGVALOR := SE2->(RecNo())
                            SE5->(MsGoto(0))
                            SE2->(MsGoto(0))
                            nTotalCtb += DetProva(nHdlPrv,cPadrao,"FINA330",cLoteCtb)
                            VALOR	:= 0
                            VALOR2	:= 0
                            SE5->(DbGoTo(nRecSE5))
                            SE2->(DbGoTo(nRecSE2))
                        EndIf

                        // Deleta o registro de baixa
                        If AllTrim( SE5->E5_TABORI ) == "FK2"
                            aAreaAnt := GetArea()
                            dbSelectArea( "FK2" )
                            FK2->( DbSetOrder( 1 ) )
                            If MsSeek( xFilial("FK2") + SE5->E5_IDORIG )
                                oModelMov := FWLoadModel("FINM020") //Model de baixas a pagar
                                oModelMov:SetOperation( 4 ) //Alteração
                                oModelMov:Activate()
                                oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação SE5
                                //E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
                                //E5_OPERACAO 2 = Grava E5 com E5_TIPODOC = 'ES' e gera estorno na FK5
                                //E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5
                                oModelMov:SetValue( "MASTER", "E5_OPERACAO", 3 ) //E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5

                                If oModelMov:VldData()
                                    oModelMov:CommitData()
                                    SE5->(dbGoto(oModelMov:GetValue( "MASTER", "E5_RECNO" )))
                                Else
                                    lRet := .F.
                                    cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
                                    cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
                                    cLog += cValToChar(oModelMov:GetErrorMessage()[6])
                                    Help( ,,"M030VALID",,cLog, 1, 0 )
                                Endif

                                oModelMov:DeActivate()
                                oModelMov:Destroy()
                                oModelMov := Nil
                            Endif
                            RestArea(aAreaAnt)
                        Endif

                    Endif

                    // Encerra a atualizacao do adiantamento
                    SE2->E2_SALDO  += SE5->E5_VALOR
                    SE2->E2_VALLIQ := 0
                    SE2->E2_BAIXA  := IIf(SE2->E2_SALDO==SE2->E2_VALOR,Ctod(""),SE2->E2_BAIXA)

                    // Executa o codeblock
                    Eval(bBlock,aAreaSE2[3],cPrimary)

                Next nX
            EndIf
        EndIf
    EndIf
EndIf
RestArea(aArea)

Return(lRet)


//-------------------------------------------------------------------

/*/{Protheus.doc} FaFilSE5Or

Retorna a Filial de origem caso seja diferente da filial corrente.

@Author
@since	16/11/2018
/*/
//-----------------------------------------------------------------------------------------------------
STATIC Function FaFilSE5Or(cFilSE5,cPrefixo,cNum,cParcela,cCliFor,cLoja,cTipo,dDataE,cSeq,cCarteira,cDocumen,cTipoDoc)

Local aArea 	:= GetArea()
Local cQryAux 	:= ""
Local cFilorig 	:= ""
Local cTrabalho	:= GetNextAlias()
Local cTypeDB   := Upper( TcGetDb() )
Local cConcat	:= IIf(cTypeDB $ "ORACLE,POSTGRES,DB2,INFORMIX","||","+")

cQryAux := " SELECT E5_FILORIG, E5_FILIAL "
cQryAux += " FROM " + RetSqlName("SE5")
cQryAux += " WHERE E5_FILIAL = '" + cFilSE5   + "'"
cQryAux += " AND E5_RECPAG   = '" + cCarteira + "'"
cQryAux += " AND E5_TIPODOC  = 'BA' "
cQryAux += " AND E5_SITUACA <> 'C' "
cQryAux += " AND E5_CLIFOR   = '" + cCliFor + "'"
cQryAux += " AND E5_PREFIXO" + cConcat + "E5_NUMERO" + cConcat + "E5_PARCELA" + cConcat + "E5_TIPO" + cConcat + "E5_CLIFOR" + cConcat +"E5_LOJA =  '" + cDocumen + "'"
cQryAux += " AND D_E_L_E_T_ = ' ' "
cQryAux += " ORDER BY E5_FILIAL,E5_SEQ "
cQryAux := ChangeQuery(cQryAux)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQryAux),cTrabalho,.T.,.T.)

dbSelectArea(cTrabalho)
(cTrabalho)->(dbGoTop())
If (cTrabalho)->(!Eof())
    If Empty( (cTrabalho)->E5_FILORIG )
        cFilorig := (cTrabalho)->E5_FILIAL
    Else
        cFilorig := (cTrabalho)->E5_FILORIG
    EndIf
    (cTrabalho)->(dbCloseArea())
EndIf

RestArea(aArea)

Return(cFilorig)

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc}FBcoPAOLD 

Verifica banco utilizado na inclusao do adiantamento.

@param cAlias Alias aberto para busca utilizando campos da SE2
@return aBancos - [1][1] - CODIGO BANCO
                  [1][2] - AGENCIA
                  [1][3] - CONTA
                  [2]    - MOEDA DO BANCO

@author Clovis Magenta
@since  11/09/2012
*/
//-----------------------------------------------------------------------------------------------------
Function FBcoPAOLD(cAlias)

Local aArea		:= GetArea()
Local aAreaSE5	:= GetArea('SE5')
Local aAreaSA6	:= GetArea('SA6')
Local cChavePA	:= ""
Local lMoedaBco	:= .T.
Local aBanco	:= {}

cChavePA := xFilial("SE5")+(cAlias)->(E2_PREFIXO+E2_NUM+E2_PARCELA+E2_TIPO+E2_FORNECE+E2_LOJA)

dbSelectARea("SE5")
dbSetOrder( 7 )
If dbSeek( cChavePA )
    If SE5->E5_TIPODOC = "PA"
        Aadd(aBanco, { SE5->E5_BANCO, SE5->E5_AGENCIA, SE5->E5_CONTA } )

        dbSelectARea("SA6")
        dbSetOrder(1)
        If DbSeek( xFilial("SA6")+SE5->(E5_BANCO+E5_AGENCIA+E5_CONTA) )
            If lMoedaBco
                Aadd(aBanco, SA6->A6_MOEDA )
            Else
                Aadd(aBanco, 0 )
            Endif
        Endif
    Else
        Aadd(aBanco, {} )
        Aadd(aBanco, 0 )
    EndIf
Else
    Aadd(aBanco, {} )
    Aadd(aBanco, 0 )
Endif

RestArea(aAreaSA6)
RestArea(aAreaSE5)
RestArea(aArea)
FwFreeArray(aAreaSA6)
FwFreeArray(aAreaSE5)
FwFreeArray(aArea)

Return aBanco

//-------------------------------------------------------------------
/*/{Protheus.doc} FCaInsBxCP

Cálculo de INSS Contas a Pagar - Baixa

@param nBaseTit 	- Base de calculo
@param lIRPFBaixa	- Informa se o IRF é na Baixa
@param lCalcIssBx	- Informa se o ISS é na Baixa
@param lPCCBaixa	- Informa se o PCC é na Baixa
@return aValImp
@author Jose.Gavetti
@since  18/09/2015
/*/
//-------------------------------------------------------------------
Function FCaInsBxCP(nBaseTit,lIRPFBaixa,lCalcIssBx,lPCCBaixa)

	Local lTCpsINSS	:=  .T.
	Local lPJAcum 	:= SuperGetMv("MV_INSACPJ",.F.,"2") == "1"   // PJ acumula INSS
	Local nLimInss 	:= SuperGetMv("MV_LIMINSS",.F.,0)
	Local nVlRetin	:= SuperGetMv("MV_VLRETIN",.F.,0)
	Local lZeraInss	:= .T.
	Local nCalcInss	:= 0
	Local nINSSTot	:= 0
	Local nParciais	:= 0
	Local nVrImp	:= 0
	Local nImpRet	:= 0
	Local nValor	:= 0
	Local cTipo		:=""
	Local nMinINS1	:= SuperGetMv("MV_MININSS",.F.,0)
	Local nMinINS2	:= SuperGetMv("MV_VLRETIN",.F.,0)
	Local lInsPub	:= SuperGetMv("MV_INSPUB",,.F.) .And. nMinINS1 == 0 .And.;
						nLimInss == 0 .And. nMinINS2 == 0 //Inss Baixa com empresa publica. Neste caso os valores do inss não tem valor minimo ou maximo de retencao.
	Private nTotRIns := 0

	nInsBaseR := 0

	If !lTCpsINSS // verifica se os campos da cumulatividade de INSS existem na base
		Return nInss
	Endif

	If IsInCallStack("FINA050")
		cTipo		:=	M->E2_TIPO
		nValor	:=	M->E2_VALOR
	Else
		cTipo		:=	SE2->E2_TIPO
		If Subst(SE2->E2_ORIGEM,1,4) == "MATA" .And. lInsPub  //Origem do documento de entrada.
			nValor	:=	SE2->E2_BASEINS
		Else
			nValor	:=	SE2->E2_VALOR
		Endif
	Endif

	If IsInCallStack("FINA340") .Or. IsInCallStack("FINA241") .Or. IsInCallStack("FINA090")
		If Subst(SE2->E2_ORIGEM,1,4) == "MATA" .And. lInsPub //Origem do documento de entrada.
			nBaseTit	:= SE2->E2_BASEINS
		ElseIf Alltrim(SE2->E2_FATURA) == "NOTFAT"	 .And. !lPCCBaixa//Fatura	e emissao.
		    nBaseTit	:=	SE2->E2_BASEINS
		Else// NF
			If nBaseTit < SE2->E2_BASEINS //Somar somente se a base não vier o valor total do titulo.
				If !lPCCBaixa
					nBaseTit	:=	nBaseTit	+ SE2->E2_VRETPIS + SE2->E2_VRETCSL + SE2->E2_VRETCOF
				Endif

				If !lIRPFBaixa
					nBaseTit	:=	nBaseTit	+ SE2->E2_IRRF
				Endif

				If !lCalcIssBx
					nBaseTit	:=	nBaseTit	+ SE2->E2_VRETISS
				Endif
			Endif
		Endif
	ElseIf !IsInCallStack("FINA241") .And. !IsInCallStack("FINA050")

		nParciais	:= SE2->E2_VALOR-SE2->E2_SALDO

		IF nParciais == 0  //Titulo sem baixa

			If Subst(SE2->E2_ORIGEM,1,4) == "MATA"  .And. lInsPub //Origem do documento de entrada.

				If nBaseTit == SE2->E2_VALOR //Somente quando baixo total o titulo.
					nBaseTit	:= SE2->E2_BASEINS
				Endif

			ElseIf nBaseTit == SE2->E2_VALOR  //Baixa Total devo somar os impostos.
				If Alltrim(SE2->E2_FATURA) == "NOTFAT"	 .And. !lPCCBaixa//Fatura	e emissao.
			    	nBaseTit	:=	SE2->E2_BASEINS
				Else// NF
					If !lPCCBaixa
						nBaseTit	:=	nBaseTit	+ SE2->E2_VRETPIS + SE2->E2_VRETCSL + SE2->E2_VRETCOF
					Endif

					If !lIRPFBaixa
						nBaseTit	:=	nBaseTit	+ SE2->E2_IRRF
					Endif

					If !lCalcIssBx
						nBaseTit	:=	nBaseTit	+ SE2->E2_VRETISS
					Endif
				Endif
			Endif

			nVrImp	:=	0
			If lPCCBaixa
				nVrImp	:=	nVrImp	+ nPis + nCsll + nCofins
			Endif

			If lIRPFBaixa
				nVrImp	:=	nVrImp	+ nIrrf
			Endif

			If lCalcIssBx
				nVrImp	:=	nVrImp	+ nIss
			Endif

			If lPCCBaixa
				If nParciais + nBaseTit + nVrImp == SE2->E2_VALOR //Baixa Total somar os titulos.
				    nBaseTit	:=	nBaseTit +	nVrImp
				Endif
			Else
				If nBaseTit + nVrImp == SE2->E2_VALOR //Baixa Total somar os titulos.
				    nBaseTit	:=	nBaseTit +	nVrImp
				Endif
			Endif

		Else//Caso titulo tenha baixa    	                                                               .

			nImpRet	:=	0 //somar os valores dos impostos retidos na baixa gerados em baixas anteriores.
			nVrImp	:=	0 //somar os valores dos impostos gerados na baixa.
			If lPCCBaixa
				nVrImp	:=	nVrImp	+ nPis + nCsll + nCofins
				nImpRet	:=	nImpRet	+ SE2->E2_VRETPIS + SE2->E2_VRETCOF + SE2->E2_VRETCSL
			Endif

			If lIRPFBaixa
				nVrImp	:=	nVrImp	+ nIrrf
				nImpRet	:=	nImpRet	+ SE2->E2_VRETIRF
			Endif

			If lCalcIssBx
				nVrImp	:=	nVrImp	+ nIss
				nImpRet	:= nImpRet	+ SE2->E2_VRETISS
			Endif

			If nBaseTit + nParciais + nVrImp == SE2->E2_VALOR  //Ultima baixa do titulos
				nBaseTit	:= nBaseTit + nVrImp
			Endif

			If ((nBaseTit + nParciais) == SE2->E2_VALOR .Or. (nBaseTit == SE2->E2_VALOR)) //Caso seja a ultima baixa somar os valores dos impostos.
				nVrImp	:=	0 //somar os valores dos impostos gerados na emissao.

				If !lPCCBaixa
					nVrImp	:=	 SE2->E2_VRETPIS + SE2->E2_VRETCSL + SE2->E2_VRETCOF
				Endif

				If !lIRPFBaixa
					nVrImp	:=	nVrImp	+ SE2->E2_IRRF
				Endif

				If !lCalcIssBx
					nVrImp	:=	nVrImp	+ SE2->E2_VRETISS
				Endif

				If nVrImp > 0
				    nBaseTit := nBaseTit + nVrImp
				Endif

				//Fatura	e emissao Origem do documento de entrada.
				If (Alltrim(SE2->E2_FATURA) == "NOTFAT" .And. !lPCCBaixa) .Or. Subst(SE2->E2_ORIGEM,1,4) == "MATA" .And. lInsPub
					nBaseTit	:=	SE2->E2_BASEINS - nParciais
				ElseIf (nBaseTit + nParciais) <= SE2->E2_VALOR
					If nImpRet > 0 //impostos de baixas anteriores
						nBaseTit	:= nBaseTit	+ nImpRet //+ SE2->E2_VRETINS
					Endif

					If (nParciais - nImpret) + nBaseTit < SE2->E2_VALOR
						nBaseTit 	:= nBaseTit + SE2->E2_VRETINS
					Endif
				Endif
			Endif
		Endif
	Endif

	//³ Verifica se Natureza pede calculo do INSS (RECOLHE INSS P/ FORNEC) e se no  titulo Provisorio ou Adiantamento ou Abatimento 		  ³
	If cTipo $ MVPAGANT+"/"+MVPROVIS+"/"+MVTAXA+"/"+MVINSS+"/"+MVTAXA+"/"+MV_CPNEG+"/"+MVABATIM+"/"+"SES"+"/"+"INA" .or. ;
			(cTipo $ MVPAGANT .and. GetMv("MV_IMPADT") == "S")

		If cTipo $ MVPAGANT  //Tipo PA
			If SED->ED_CALCINS == "S" .And. SA2->A2_RECINSS == "S"
				If !Empty(SED->ED_BASEINS)
					If nBaseTit == 0
						nBaseIns := NoRound((nValor * (SED->ED_BASEINS/100)),2)
					Else
						nBaseIns := NoRound((nBaseTit * (SED->ED_BASEINS/100)),2)
					Endif
				ElseIf nBaseIns == 0
					If nBaseTit == 0
						nBaseIns := nValor
					Else
						nBaseIns := nBaseTit
					Endif
				EndIf

				If SA2->A2_TIPO  == "F"
					nInss := FCaInsPFBx(nBaseIns,@lZeraInss,@nCalcInss,@nINSSTot) //Inss baixa
				Else
					nInss := FCaInsPJBx(nBaseIns,@nCalcInss,@nINSSTot) //Inss baixa
				Endif

				nInsBaseC := nBaseIns
				nInsCalc := nCalcInss
				If nInsBaseC > 0 .And. nInsBaseR == 0
					nInsBaseR := nInsBaseC
				ElseIf nInsBaseR > 0 .And. nInsBaseC > 0
					nInsBaseR += nInsBaseC
				EndIF

				nInss	:= Max(nINSSTot,nInss)

				If lTCpsINSS // se os campos da cumulatividade de INSS tiverem sido criados
					nVretInss	:= nCalcInss
				EndIf

				If nValor < nInss //-- Valor do titulo nao pode ser menor que o valor do INSS
					nInss  := nValor - 0.01
				EndIf
			EndIf
		EndIf
	Else
		If !Empty(SED->ED_BASEINS)
			nBaseIns := NoRound((nBaseTit * (SED->ED_BASEINS/100)),2)
		Else
			nBaseIns := nBaseTit
		EndIf

		If SA2->A2_TIPO == "F"
			nInss := FCaInsPFBx(nBaseIns,@lZeraInss,@nCalcInss,@nINSSTot) //Inss baixa
		Else
			nInss := FCaInsPJBx(nBaseIns,@nCalcInss,@nINSSTot) //Inss baixa
		Endif

		nInsBaseC := nBaseIns
		nInsCalc := nCalcInss
		If nInsBaseC > 0 .And. nInsBaseR == 0
			nInsBaseR := nInsBaseC
		ElseIf nInsBaseR > 0 .And. nInsBaseC > 0
			nInsBaseR += nInsBaseC
		EndIF

		nInss		:= Max(nINSSTot,nInss)

		If lTCpsINSS // se os campos da cumulatividade de INSS tiverem sido criados
			nVretInss	:= nCalcInss
		EndIf

		If SE2->E2_VALOR < nInss //-- Valor do titulo nao pode ser menor que o valor do INSS
			nInss  := SE2->E2_VALOR - 0.01
		EndIf

		SE2->(MsUnlock())
	Endif

	If SA2->A2_TIPO == "F" .And. nLimInss > 0 .And. nInss > nLimInss //³Verifica se o valor do INSS ultrapassou o valor limite.³
		nInss := Max(0,(nLimInss - nVretInss))
	Endif

	If ( nInss+nTotRIns < nVlRetin ) .And. lZeraInss .And. !(FunName() $ "FINA340")
		nInss		:= 0
		nOldInss  	:= 0
		nVretInss	:= Iif(!lPJAcum .And. SA2->A2_TIPO == "J",0,nVretInss)
	EndIf

	If SA2->A2_TIPO == "J"
		If !lPJAcum // Não acumula
			cPretIns	:=	" "
			If nInss > nVlRetin //Inss maior que valor minimo gera titulo do imposto INSS.
				nVretInss	:= nInss
			Endif
		Else// Acumula
			If nInss+nTotRIns > nVlRetin
				cPretIns	:= " "
			Else
				cPretIns	:= "1"
			Endif
		Endif
	Endif

	If SA2->A2_TIPO == "F"
		If nVlRetin > 0  //Caso o parâmetro MV_VLRETIN esteja preenchido.
			If nInss > nVlRetin //Valor Inss maior que valor minimo de retencao.
				cPretIns	:= " "
			ElseIf nInss < nVlRetin //Valor Inss menor que valor minimo de retencao.
				cPretIns	:= "1"
				If (nInss == 0 .And. nVretInss == 0) .Or. !lZeraInss
					cPretIns	:= " "
				Endif
			Endif
		Else
			cPretIns	:= " "
		Endif
	Endif

Return nInss



//-------------------------------------------------------------------
/*/{Protheus.doc} FCaInPJBx

Cálculo de INSS Contas a Pagar - Baixa - PJ

@param nBaseIns 	- Base de calculo
@param nCalcInss	- Valor calculado do INSS
@param nINSSTot		- INSS acumulado no periodo

@return nValInss	- Valor do INSS

@author  Andrea Verissimo Santiago
@since  04/04/2004
/*/
//-------------------------------------------------------------------
Function FCaInPJBx(nBaseIns,nCalcInss,nINSSTot)
	Local nInssAcum 	:= 0
	Local lRoundIns		:= GetNewPar("MV_RNDINS",.F.)
	Local nVlMinINSS 	:= SuperGetMv("MV_VLRETIN",.F.,0)
	Local lAcmPJ 	 	:= SuperGetMv("MV_INSACPJ",.T.,"2") == "1"  //1 = Acumula    2= Não acumula
	Local nValInss		:= 0	//valor inss calculado com base do parametro.

	// verifica se os campos da cumulatividade de INSS existem na base
	Local lTCpsINSS 	:= .T.
	Local nInsRest 		:= 0
	Local lFinVldIns 	:= Existblock("FinVldIns")
	Local nVretTit		:= 0
	Local dDtIni 		:= FirstDay(dDatabase)
	Local dDtFim		:= LastDay(dDatabase)
	Local nX			:= 0
	Local aBaixa		:= {}
	Local lValida		:= nVlMinINSS = 0 .And. SuperGetMv("MV_INSPUB",,.F.) // Empresas publicas que não controlam os valores de INSS retidos.
	Private aBaixaSE5	:= {}

	If lRoundIns
		nValInss := Round((nBaseIns * (SED->ED_PERCINS/100)),2)
	Else
		nValInss := NoRound((nBaseIns * (SED->ED_PERCINS/100)),2)
	EndIf

	//-------------------------------------------------------------------------------------------
	// Orientação do artigo 120 da IN 971/2009
	// 
	// Fica dispensada a retenção quando o valor correspondente a 11% do valor dos serviços
	// prestados for inferior ao limite mínimo estabelecido para recolhimento.
	// 
	// Este tratamento deve considerar individualmente cada documento.
	//-------------------------------------------------------------------------------------------
	If !(IsInCallStack("FINA340")) .And. !lValida
		nCalcInss := nValInss //valor do INSS para ESSE título.
		nVretTit	:=	0
		nTotRIns  := 0

		If nVlMinINSS > 0 .And. lTCpsINSS //.And. lOk
			If lAcmPJ //PJ com cumulatividade
				If IsInCallStack("FINA050")
					nINSSAcum := InssCaPJBx(SA2->A2_COD,SA2->A2_LOJA,SA2->A2_NREDUZ,M->E2_EMISSAO,M->E2_VENCREA,@nInsRest)
				Else
					nINSSAcum := InssCaPJBx(SA2->A2_COD,SA2->A2_LOJA,SA2->A2_NREDUZ,SE2->E2_EMISSAO,SE2->E2_VENCREA,@nInsRest)
				Endif
			Else// PJ sem cumulatividade
				aBaixaSE5:= {} //Procura pelas baixas deste titulo.

				If IsInCallStack("FINA050")
					aBaixa	:= Sel080Baixa("VL /BA /CP /",M->E2_PREFIXO,M->E2_NUM,M->E2_PARCELA,M->E2_TIPO,0,0,M->E2_FORNECE,M->E2_LOJA,.F.,.F.,.F.,0,.F.,.T.)
				Else
					aBaixa	:= Sel080Baixa("VL /BA /CP /",SE2->E2_PREFIXO,SE2->E2_NUM,SE2->E2_PARCELA,SE2->E2_TIPO,0,0,SE2->E2_FORNECE,SE2->E2_LOJA,.F.,.F.,.F.,0,.F.,.T.)
				Endif

				If Len(aBaixaSE5) >= 1 .And.  Len(aBaixaSE5[1]) > 23
					For nX:=1 To Len(aBaixaSE5)
						If Dtos(aBaixaSE5[nX][7]) >= Dtos(dDtIni) .And. Dtos(aBaixaSE5[nX][7]) <= Dtos(dDtFim) //E5_DATA
							If Empty(aBaixaSE5[nX][28]) .And. aBaixaSE5[nX][27] <= nVlMinINSS //Pretins
								If lRoundIns
									nVretTit := Round((aBaixaSE5[nX][8] * (SED->ED_PERCINS/100)),2)
								Else
									nVretTit := NoRound((aBaixaSE5[nX][8] * (SED->ED_PERCINS/100)),2)
								EndIf
							Endif
						Endif
					Next
				Endif
				nValInss :=	nValInss + nVretTit
			EndIf

			nINSSTot := nINSSAcum+nValInss+Iif(nInsRest > 0 .And. nInsRest <= nVlMinINSS,nInsRest,0)
			
			If nINSSTot+IIF(lAcmPJ,nTotRIns,0) < nVlMinINSS .AND. (IIF(lFinVldIns, Execblock("FinVldIns",.F.,.F., {} ), .T. ))
				nValInss := 0
				nINSSTot := 0
				If !lAcmPJ
					nCalcInss := 0
				EndIf
			EndIf
		EndIf
	Endif

Return nValInss


//-------------------------------------------------------------------
/*/{Protheus.doc} FCaInPFBx

Cálculo de INSS na Baixa - PF

@param nBaseIns 	- Base de calculo
@param lZeraInss	- Apos gerar o INSS pela primeira mesmo com 
						valor minimo calculado deve ser gerado.
@param nCalcInss	- Valor calculado do INSS
@param nINSSTot		- INSS acumulado no periodo

@return nValInss	- Valor do INSS

@author  Andrea Verissimo Santiago
@since  04/04/2004
/*/
//-------------------------------------------------------------------
Function FCaInPFBx(nBaseIns,lZeraInss,nCalcInss,nINSSTot)

	Local nLimInss 		:= GetMv("MV_LIMINSS",.F.,0)
	Local nInssAcum 	:= 0
	Local nInssCalc 	:= 0
	Local nValMaxIns 	:= 0
	Local lRoundIns		:= GetNewPar("MV_RNDINS",.F.)
	// Esse parametro deve estar preenchido com o valor mínimo para recolhimento de INSS
	// o conteúdo padrão "0" (zero) foi utilizado para manter o legado.
	Local nVlMinINSS 	:= SuperGetMv("MV_MININSS",.F.,0)
	// Verifica se os campos da cumulatividade de INSS existem na base
	Local lTCpsINSS 	:= .T.
	Local nValInss		:=	0
	Local nInsRest 		:= 0
	Local lOk			:= .F.
	Local nMinINSS2 	:= SuperGetMv("MV_VLRETIN",.F.,0)
	// Empresas publicas que não controlam os valores de INSS retidos.
	Local lValida		:=	( nLimInss = 0 .And. nVlMinINSS = 0 .And. nMinINSS2 = 0 ) .And. SuperGetMv("MV_INSPUB",,.F.)

	If lRoundIns
		nValInss := Round((nBaseIns * (SED->ED_PERCINS/100)),2)
	Else
		nValInss := NoRound((nBaseIns * (SED->ED_PERCINS/100)),2)
	EndIf
	nCalcInss := nValInss //valor do INSS para ESSE título.

	If !lValida //Controle de valores de INSS com parametros MV_LIMINSS e MV_MININSS preenchidos.
		If IsInCallStack("FINA340")
			If nValInss > nLimInss
				nValInss	:=	nLimInss
			Endif
		Else
			//Retornar o saldo de INSS acumulado do fornecedor, do mes de emissao ou vencimento do titulo originador
			If IsInCallStack("FINA050")
				nInssAcum := InssAcmBx(SA2->A2_COD,SA2->A2_LOJA,SA2->A2_NREDUZ,M->E2_EMISSAO,M->E2_VENCREA)
			Else
				nInssAcum := InssAcmBx(SA2->A2_COD,SA2->A2_LOJA,SA2->A2_NREDUZ,SE2->E2_EMISSAO,SE2->E2_VENCREA)
			Endif

			nValMaxIns := (nLimInss - nInssAcum)	//Saldo do que pode ser retido no mes

			If IsInCallStack("FINA050") //Retornar todo o saldo retido de INSS do fornecedor
				nINSSCalc := InssCaPFBx(SA2->A2_COD,SA2->A2_LOJA,SA2->A2_NREDUZ,M->E2_EMISSAO,M->E2_VENCREA,@nInsRest)
			Else
				nINSSCalc := InssCaPFBx(SA2->A2_COD,SA2->A2_LOJA,SA2->A2_NREDUZ,SE2->E2_EMISSAO,SE2->E2_VENCREA,@nInsRest)
			Endif

			nINSSTot := (nInssCalc + nValINSS) + Iif(nInsRest > 0,nInsRest,0)
			lOk :=	!(SE2->E2_TIPO == MVPAGANT)

			//Se o valor devido de INSS do título for menor que o valor mínimo. Ele será zerado.
			If nVlMinINSS > 0 .And. lTCpsINSS .And. lOk
				If nINSSTot+nInssAcum < nVlMinINSS
					nValINSS := 0
					nINSSTot := 0
					If GetMv("MV_LIMINSS",.F.,0)<>0 .and. nValMaxIns == 0
						nCalcInss := 0
					EndIf
				EndIf
			EndIf

			If nLimInss > 0 .and. nValINSS <> 0 .and. nINSSTot <> 0
				//Retornar o saldo de INSS acumulado do fornecedor, do mes de emissao ou vencimento do titulo originador
				If nValMaxIns <= 0
					nValInss := 0
					nINSSTot := 0
					nCalcInss := 0
				ElseIf nValMaxIns < nVlMinINSS
					//Se o valor retido (retencao por nao atingir o minimo de retencao e/ou por haver ultrapassado o maximo) for um saldo,
					//verificar se o seu valor nao eh igual ou maior ao do saldo calculado, para evitar duplicidade de retencao de INSS
					If nINSSCalc < nVlMinINSS
						If nINSSCalc >= nValMaxIns
							nCalcInss := 0
						Else
							nCalcInss := nValMaxIns - nINSSCalc
						Endif
					Else
						nCalcInss := nValMaxIns
					Endif
					nValInss := 0
					nINSSTot := 0
				Else
					//Atribuir ao INSS calculado do titulo, as retencoes pendentes
					nValInss += nINSSCalc
					If nValMaxIns < nValInss
						nValInss  := nCalcInss :=  nValMaxIns
					EndIf
					If nValMaxIns < nINSSTot
						nINSSTot :=  IIf(nValMaxIns > nValInss, nValInss, nValMaxIns)
					EndIf
				Endif
			Endif

			If nValMaxIns <= nLimInss .And. nInssAcum > nVlMinINSS //Apos gerar o INSS pela primeira mesmo com valor minimo calculado deve ser gerado.
				lZeraInss	:=	.F.
			Endif
		Endif
	Endif

Return nValInss


//----------------------------------------------------------------------------
/*/{Protheus.doc} InsCaPFBx

Verifica o valor CALCULADO de inss de um fornecedor num determinado periodo.

@param cFornece 	- Código do Fornecedor
@param cLoja    	- Loja do Fornecedor
@param cNomeFor		- Nome do Fornecedor
@param dEmissao		- Data de Emissão
@param dVencRea		- Data de Vencimento Real
@param nInsRest		- Valor restante pare retenção de INSS

@return nValor  	- Valor do INSS

@author  Andrea Verissimo Santiago
@since  23/04/2014
/*/
//---------------------------------------------------------------------------
Function InsCaPFBx(cFornece,cLoja,cNomeFor,dEmissao,dVencRea,nInsRest)

	Local nValor 		:= 0
	Local aArea 		:= GetArea()
	Local aAreaSA2  	:= {}
	Local lVencto 	    := SuperGetMv("MV_ACMINSS",.T.,"1") == "2"  //1 = Emissao    2= Vencimento Real
	Local lTodasFil 	:= ExistBlock("F50TFINS")
	Local aFilINSS 	    := {}
	Local nX			:= 0
	Local nVrBord		:= 0
	Local cQuery		:= ""
	Local dDataIni      := CTOD("//")
	Local dDataFim      := CTOD("//")
	Local cTpAcm        := SuperGetMv("MV_INSTPAC", .F., "1" ) //Default 1
	
    Default aRecnoINSS 	:= {}
	Default aBordINSS 	:= {}
	Default nInsRest 	:= 0

	//Verifico todas as filiais apenas quando SA2 compartilhado
	If lTodasFil
		aFilINSS := ExecBlock( "F50TFINS", .F., .F. )
	Else
		aFilINSS := { xFilial("SE5") }
	Endif

	If Empty(cFornece) .or. Empty(cLoja) .or. Empty(dEmissao) .or. Empty(cNomeFor)
		Return 0
	Endif

	//Valida se o fornecedor calcula acumulado - PF
	dbSelectArea("SA2")
	aAreaSA2 := SA2->(GetArea())
	SA2->(dbSetOrder(1))
	If SA2->(dbSeek(xFilial("SA2")+cFornece+cLoja))
		cTpForn := SA2->A2_TIPO
	Endif
	SA2->(RestArea(aAreaSA2))

	cQuery := "SELECT SUM(E5_VRETINS) NVALINSS, SUM(E5_VALOR) NBASINSS FROM " + RetSQLname("SE5") + " SE5 "
	cQuery += " WHERE "
	cQuery += "( "

	For nX:= 1 to Len(aFilINSS)
		cQuery += "SE5.E5_FILIAL = '"+ aFilINSS[nX] + "' OR "
	Next nX

	cQuery := Left( cQuery, Len( cQuery ) - 4 )
	cQuery += ") AND "

	cQuery += "SE5.E5_CLIFOR = '"+ cFornece +"' AND "
	cQuery += "SE5.E5_LOJA = '"+ cLoja +"' AND "
	cQuery += "SE5.E5_VRETINS > 0 AND "
	cQuery += "SE5.E5_PRETINS = '1' AND "	//E5_PRETINS = '1' -> Pendente de retenção.
	cQuery += "SE5.E5_SITUACA <> 'C' AND "

	If cTpAcm == "2"
		dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
		dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))
		cQuery += "SE5.E5_DATA  BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
	Else
		If lVencto
			cQuery += "SE5.E5_VENCTO  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
		Else
			cQuery += "SE5.E5_DATA  BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
		Endif
	EndIf

	cQuery += "D_E_L_E_T_ = ' ' "
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBCALC", .F., .T.)
	TcSetField("TRBCALC","NVALINSS"  ,"N", 17,2)
	TcSetField("TRBCALC","NBASINSS"  ,"N", 17,2)
	nValor := nValInss
	nInsBaseR := TRBCALC->NBASINSS
	dbCloseArea()

	If nValor > 0

		cQuery := "SELECT R_E_C_N_O_ RECNO FROM " + RetSQLname("SE5") + " SE5 "
		cQuery += " WHERE "
		cQuery += "( "

		For nX:= 1 to Len(aFilINSS)
			cQuery += "SE5.E5_FILIAL = '"+ aFilINSS[nX] + "' OR "
		Next nX

		cQuery := Left( cQuery, Len( cQuery ) - 4 )
		cQuery += ") AND "
		cQuery += "SE5.E5_CLIFOR = '"+ cFornece +"' AND "
		cQuery += "SE5.E5_LOJA = '"+ cLoja +"' AND "
		cQuery += "SE5.E5_VRETINS > 0 AND "
		cQuery += "SE5.E5_PRETINS = '1' AND "	//E5_PRETINS = '1' -> Pendente de retenção.
		cQuery 	+= "SE5.E5_SITUACA <> 'C' AND "
		If cTpAcm == "2"
			dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
			dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))
			cQuery += "SE5.E5_DATA  BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
		Else
			If lVencto
				cQuery += "SE5.E5_VENCTO  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
			Else
				cQuery += "SE5.E5_DATA  BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
			Endif
		EndIf

		cQuery += "D_E_L_E_T_ = ' ' "
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBCALC", .F., .T.)
		While !TRBCALC->(EOF())
			Aadd(aRecnoINSS,TRBCALC->RECNO)
			TRBCALC->(DbSkip())
		EndDo
		dbCloseArea()
	EndIf

	//Verifico os valores retidos e que não foram calculados
	cQuery := "SELECT SUM(E2_INSS) NVLINSCAL, SUM(E5_VRETINS) NVLINSRET "

	cQuery	+= "FROM "
	cQuery += RetSqlName("SE5") + " SE5 , "
	cQuery += RetSqlName("SE2") + " SE2 "

	cQuery += " WHERE "
	cQuery += "SE5.E5_FILIAL = '"	+ xFilial("SE5") +	"' AND "
	cQuery += "SE5.E5_CLIFOR = '"	+	cFornece		+	"' AND "
	cQuery += "SE5.E5_LOJA='"		+	cLoja			+	"' AND "

	cQuery	+= "SE5.E5_SITUACA <> 'C' AND "
	cQuery += "SE5.E5_PREFIXO = SE2.E2_PREFIXO AND "
	cQuery += "SE5.E5_NUMERO = SE2.E2_NUM AND "
	cQuery += "SE5.E5_PARCELA = SE2.E2_PARCELA AND "
	cQuery += "SE5.E5_TIPO = SE2.E2_TIPO AND "
	cQuery	+= "SE5.E5_CLIFOR = SE2.E2_FORNECE AND "
	cQuery	+= "SE5.E5_LOJA = SE2.E2_LOJA AND "

	cQuery += "SE5.E5_VRETINS > 0 AND "
	cQuery += "(SE5.E5_PRETINS = '2' OR SE5.E5_PRETINS ='' OR SE5.E5_PRETINS ='4') AND "

	cTipoTit	:=	""
	cTipoTit	:=	MVABATIM + "|" + MV_CRNEG + "|" + MVPROVIS
	cQuery 	+= "SE5.E5_TIPO NOT IN " + FormatIn(cTipoTit,If("|"$cTipoTit,"|",","))  + " AND "
	cQuery 	+= "SE5.E5_RECPAG = 'P' AND "
	cQuery 	+= "SE5.E5_MOTBX NOT IN ('FAT','LIQ','EEC','STP') AND "
	cQuery 	+= "SE5.E5_SITUACA <> 'C' AND "

	If cTpAcm == "2"
		dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
		dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))
		cQuery += "SE5.E5_DATA  BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
	Else
		If lVencto
			cQuery += "SE5.E5_VENCTO  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
		Else
			cQuery += "SE5.E5_DATA  BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
		Endif
	EndIf

	cQuery += "SE5.D_E_L_E_T_ = ' ' "

	cQuery += "AND NOT EXISTS ( "
	cQuery += "SELECT A.E5_NUMERO "
	cQuery += "FROM "+RetSqlName("SE5")+" A "
	cQuery += "WHERE A.E5_FILIAL='"+xFilial("SE5")+"' AND "
	cQuery +=		"A.E5_PREFIXO= SE5.E5_PREFIXO AND "
	cQuery +=		"A.E5_NUMERO= SE5.E5_NUMERO AND "
	cQuery +=		"A.E5_PARCELA= SE5.E5_PARCELA AND "
	cQuery +=		"A.E5_TIPO= SE5.E5_TIPO AND "
	cQuery +=		"A.E5_CLIFOR= SE5.E5_CLIFOR AND "
	cQuery +=		"A.E5_LOJA= SE5.E5_LOJA AND "
	cQuery +=		"A.E5_SEQ= SE5.E5_SEQ AND "
	cQuery +=		"A.E5_TIPODOC='ES' AND "
	cQuery +=		"A.E5_RECPAG<>'P' AND "
	cQuery +=		"A.D_E_L_E_T_ = ' ')"

	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBCALC2", .F., .T.)
	nInsRest  := TRBCALC2->NVLINSCAL - TRBCALC2->NVLINSRET
	dbCloseArea()

	//Titulos que possuem borderos.
	cQuery := "SELECT SUM(E2_VRETINS) NINSBORD FROM " + RetSQLname("SE2") + " A "
	cQuery += " WHERE "
	cQuery += "( "

	For nX:= 1 to Len(aFilINSS)
		cQuery += "A.E2_FILIAL = '"+ aFilINSS[nX] + "' OR "
	Next nX

	cQuery := Left( cQuery, Len( cQuery ) - 4 )
	cQuery += ") AND "

	cQuery += "A.E2_FORNECE = '"	+	cFornece	+	"' AND "
	cQuery += "A.E2_LOJA='"		+	cLoja		+ 	"' AND "

	cTipoTit	:=	""
	cTipoTit	:=	MVABATIM + "|" + MV_CRNEG + "|" + MVPROVIS
	cQuery 	+= "A.E2_TIPO NOT IN " + FormatIn(cTipoTit,If("|"$cTipoTit,"|",","))  + " AND "

	cQuery += "A.E2_NUMBOR <> ' ' AND " 	//Titulos que possuam bordero.

	cQuery += "A.E2_FATURA = ' ' AND " 	//Titulos que nao possuam fatura.

	cQuery += "A.E2_PRETINS = '1' AND "		//Titulo pendente de retencao.
	cQuery += "A.E2_VRETINS > 0 AND "

	If cTpAcm == "2"
		dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
		dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))
		cQuery += "A.E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
	Else
		If lVencto
			cQuery += "A.E2_VENCTO  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
		Else
			cQuery += "A.E2_EMISSAO BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
		Endif
	EndIf

	cQuery += "D_E_L_E_T_=' '"
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBCALCB", .F., .T.)
	TcSetField("TRBCALCB","NINSBORD"  ,"N", 17,2)
	nVrBord	:=	NINSBORD
	nValor		:= nValor + NINSBORD
	dbCloseArea()

	If nVrBord > 0
		cQuery := "SELECT R_E_C_N_O_ RECNO FROM " + RetSQLname("SE2")  + " SE2 "
		cQuery += " WHERE "
		cQuery += "( "

		For nX:= 1 to Len(aFilINSS)
			cQuery += "SE2.E2_FILIAL = '"+ aFilINSS[nX] + "' OR "
		Next nX

		cQuery := Left( cQuery, Len( cQuery ) - 4 )
		cQuery += ") AND "

		cQuery += "SE2.E2_FORNECE = '"+ cFornece +"' AND "
		cQuery += "SE2.E2_LOJA = '"+ cLoja +"' AND "

		cQuery += "SE2.E2_PRETINS = '1' AND "	// Pendentes de retencao com bordero.
		cQuery += "SE2.E2_NUMBOR <> ' ' AND " 	//Titulos que possuam bordero.
		cQuery += "SE2.E2_VRETINS > 0 AND "
		cQuery += "SE2.E2_FATURA = ' ' AND " 	//Titulos que nao possuam fatura.

		If cTpAcm == "2"
			dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
			dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))
			cQuery += "SE2.E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
		Else
			If lVencto
				cQuery += "SE2.E2_VENCTO  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
			Else
				cQuery += "SE2.E2_EMISSAO BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
			Endif
		EndIf

		cQuery += "D_E_L_E_T_=' '"

		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBBORD", .F., .T.)

		While !TRBBORD->(EOF())
			aaDD(aBordINSS,TRBBORD->RECNO)
			TRBBORD->(DbSkip())
		EndDo

		dbCloseArea()
	EndIf

	//Query para selecionar titulos da tabela SE2 que estao retidos em outros titulos.
	//Nesse caso somente para a conta Valor do Inss e Valor retido bater.*/
	cQuery := "SELECT SUM(E2_VRETINS) NBORDRET FROM " + RetSQLname("SE2") + " A "
	cQuery += " WHERE "
	cQuery += "( "

	For nX:= 1 to Len(aFilINSS)
		cQuery += "A.E2_FILIAL = '"+ aFilINSS[nX] + "' OR "
	Next nX

	cQuery := Left( cQuery, Len( cQuery ) - 4 )
	cQuery += ") AND "

	cQuery += "A.E2_FORNECE = '"	+	cFornece	+	"' AND "
	cQuery += "A.E2_LOJA='"		+	cLoja		+ 	"' AND "

	cTipoTit	:=	""
	cTipoTit	:=	MVABATIM + "|" + MV_CRNEG + "|" + MVPROVIS
	cQuery 	+= "A.E2_TIPO NOT IN " + FormatIn(cTipoTit,If("|"$cTipoTit,"|",","))  + " AND "

	cQuery += "A.E2_NUMBOR <> ' ' AND " 	//Titulos que possuam bordero.
	cQuery += "A.E2_PRETINS = '2' AND "		//Titulo pendente de retencao.
	cQuery += "A.E2_FATURA = ' ' AND " 	//Titulos que nao possuam fatura.

	If cTpAcm == "2"
		dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
		dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))
		cQuery += "A.E2_EMISSAO  BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
	Else
		If lVencto
			cQuery += "A.E2_VENCTO  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
		Else
			cQuery += "A.E2_EMISSAO BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
		Endif
	EndIf

	cQuery += "D_E_L_E_T_=' '"
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBCALCD", .F., .T.)
	TcSetField("TRBCALCD","NBORDRET"  ,"N", 17,2) //Borderos retidos em outro.
	nInsRest	:=	nInsRest - NBORDRET
	dbCloseArea()

	RestArea(aArea)

Return (nValor)


//---------------------------------------------------------------------------------
/*/{Protheus.doc} InsCaPJBx

Verifica o valor CALCULADO de inss de um fornecedor num determinado periodo 
que retenha o imposto na baixa.

@param cFornece - Código do Fornecedor
@param cLoja	- Loja do Fornecedor
@param cNomeFor	- Nome do Fornecedor
@param dEmissao	- Data de emissão
@param dVencRea	- Data de vencimento real
@param nInsRest	- Valor restante de inss

@return nValor	- Valor do INSS

@author  Andrea Verissimo Santiago
@since  04/04/2004
/*/
//---------------------------------------------------------------------------------
Function InsCaPJBx(cFornece,cLoja,cNomeFor,dEmissao,dVencRea,nInsRest)

	Local nValor 		:= 0
	Local aArea 		:= GetArea()
	Local aAreaSA2		:= {}
	Local lVencto 		:= SuperGetMv("MV_ACMINSS",.T.,"1") == "2"  //1 = Emissao    2= Vencimento Real
	Local lTodasFil		:= ExistBlock("F50TFINS")
	Local aFilINSS 		:= {}
	Local nX			:=	0
	Local nVrBord		:=	0
	Local cTipoTit		:= ""
	Local cTpAcm  		:= SuperGetMv("MV_INSTPAC", .F., "1" )  //Default 1
	Local dDataIni 		:= CTOD("//")
	Local dDataFim 		:= CTOD("//")

	Default aRecnoINSS 	:= {}
	Default aBordINSS	:= {}
	Default nInsRest	:= 0

	//Verifico todas as filiais apenas quando SA2 compartilhado
	If lTodasFil
		aFilINSS := ExecBlock( "F50TFINS", .F., .F. )
	Else
		aFilINSS := { xFilial("SE5") }
	Endif

	If Empty(cFornece) .or. Empty(cLoja) .or. Empty(dEmissao) .or. Empty(cNomeFor)
		Return 0
	Endif

	//Valida se o fornecedor calcula acumulado - PF
	dbSelectArea("SA2")
	aAreaSA2 := SA2->(GetArea())
	SA2->(dbSetOrder(1))
	If SA2->(dbSeek(xFilial("SA2")+cFornece+cLoja))
		cTpForn := SA2->A2_TIPO
	Endif
	SA2->(RestArea(aAreaSA2))

	//Retidos e não atingiu o mínimo
	cQuery := "SELECT SUM(E5_VRETINS) NVALINSS, SUM(E5_VALOR) NBASINSS FROM " + RetSQLname("SE5") + " B "
	cQuery += " WHERE "
	cQuery += "( "

	// Filiais
	For nX:= 1 to Len(aFilINSS)
		cQuery += "E5_FILIAL = '"+ aFilINSS[nX] + "' OR "
	Next nX

	cQuery := Left( cQuery, Len( cQuery ) - 4 )
	cQuery += ") AND "

	//Fornecedor
	cQuery += "E5_CLIFOR = '"	+	cFornece	+"' AND "
	cQuery += "E5_LOJA='"		+	cLoja		+ "' AND "

	cTipoTit	:=	""
	cTipoTit	:=	MVABATIM + "|" + MV_CRNEG + "|" + MVPROVIS
	cQuery 	+= "E5_TIPO NOT IN " + FormatIn(cTipoTit,If("|"$cTipoTit,"|",","))  + " AND "
	cQuery 	+= "E5_RECPAG = 'P' AND "
	cQuery 	+= "E5_MOTBX NOT IN ('FAT','LIQ','EEC','STP') AND "
	cQuery 	+= "E5_SITUACA <> 'C' AND "

	cQuery += "E5_VRETINS > 0 AND "
	cQuery += "E5_PRETINS = '1' AND "	//Pendente de retenção.

	If cTpAcm == "2"
		dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
		dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))
		cQuery += "E5_DATA BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
	Else
		If lVencto
			cQuery += "E5_VENCTO  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
		Else
			cQuery += "E5_DATA BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
		Endif
	EndIf

	cQuery += "D_E_L_E_T_=' '"
	cQuery += "AND NOT EXISTS ( "
	cQuery += "SELECT A.E5_NUMERO "
	cQuery += "FROM "+RetSqlName("SE5")+" A "
	cQuery += "WHERE A.E5_FILIAL='"+xFilial("SE5")+ "' AND "
	cQuery +=		"A.E5_PREFIXO=B.E5_PREFIXO AND "
	cQuery +=		"A.E5_NUMERO=B.E5_NUMERO AND "
	cQuery +=		"A.E5_PARCELA=B.E5_PARCELA AND "
	cQuery +=		"A.E5_TIPO=B.E5_TIPO AND "
	cQuery +=		"A.E5_CLIFOR=B.E5_CLIFOR AND "
	cQuery +=		"A.E5_LOJA=B.E5_LOJA AND "
	cQuery +=		"A.E5_SEQ=B.E5_SEQ AND "
	cQuery +=		"A.E5_TIPODOC='ES' AND "
	cQuery +=		"A.E5_RECPAG<>'P' AND "
	cQuery +=		"A.D_E_L_E_T_ = ' ')"

	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBCALC", .F., .T.)
	TcSetField("TRBCALC","NVALINSS"  ,"N", 17,2)
	TcSetField("TRBCALC","NBASINSS"  ,"N", 17,2)
	nValor := nValInss
	nInsBaseR := TRBCALC->NBASINSS
	dbCloseArea()

	If nValor > 0
		cQuery := "SELECT R_E_C_N_O_ RECNO FROM " + RetSQLname("SE5")  + " SE5 "
		cQuery += " WHERE "
		cQuery += "( "

		For nX:= 1 to Len(aFilINSS)
			cQuery += "E5_FILIAL = '"+ aFilINSS[nX] + "' OR "
		Next nX

		cQuery := Left( cQuery, Len( cQuery ) - 4 )
		cQuery += ") AND "

		cQuery += "E5_CLIFOR = '"+ cFornece +"' AND "
		cQuery += "E5_LOJA = '"+ cLoja +"' AND "

		cQuery += "E5_VRETINS > 0 AND "
		cQuery += "E5_PRETINS = '1' AND "	//Pendente de retenção.

		If cTpAcm == "2"
			dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
			dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))
			cQuery += "E5_DATA BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
		Else
			If lVencto
				cQuery += "E5_VENCTO  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
			Else
				cQuery += "E5_DATA BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
			Endif
		EndIf

		cQuery	+= "SE5.E5_SITUACA <> 'C' AND "
		cQuery += "D_E_L_E_T_ = ' ' "
		cQuery += "AND NOT EXISTS ( "
		cQuery += "SELECT A.E5_NUMERO "
		cQuery += "FROM "+RetSqlName("SE5")+" A "
		cQuery += "WHERE A.E5_FILIAL='"+xFilial("SE5")+"' AND "
		cQuery +=		"A.E5_PREFIXO= SE5.E5_PREFIXO AND "
		cQuery +=		"A.E5_NUMERO= SE5.E5_NUMERO AND "
		cQuery +=		"A.E5_PARCELA= SE5.E5_PARCELA AND "
		cQuery +=		"A.E5_TIPO= SE5.E5_TIPO AND "
		cQuery +=		"A.E5_CLIFOR= SE5.E5_CLIFOR AND "
		cQuery +=		"A.E5_LOJA= SE5.E5_LOJA AND "
		cQuery +=		"A.E5_SEQ= SE5.E5_SEQ AND "
		cQuery +=		"A.E5_TIPODOC='ES' AND "
		cQuery +=		"A.E5_RECPAG<>'P' AND "
		cQuery +=		"A.D_E_L_E_T_ = ' ')"

		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBCALC1", .F., .T.)

		While !TRBCALC1->(EOF())
			aaDD(aRecnoINSS,TRBCALC1->RECNO)
			TRBCALC1->(DbSkip())
		EndDo

		dbCloseArea()
	EndIf
	//Calculado - Retido
	cQuery := "SELECT SUM(E2_INSS) NVLINSCAL, SUM(E5_VRETINS) NVLINSRET  "

	cQuery	+= "FROM "
	cQuery += RetSqlName("SE5") + " SE5 , "
	cQuery += RetSqlName("SE2") + " SE2 "

	cQuery += " WHERE "
	cQuery += "SE5.E5_FILIAL = '"	+ xFilial("SE5") +	"' AND "
	cQuery += "SE5.E5_CLIFOR = '"	+	cFornece		+	"' AND "
	cQuery += "SE5.E5_LOJA='"		+	cLoja			+	"' AND "

	cQuery += "SE5.E5_PREFIXO = SE2.E2_PREFIXO AND "
	cQuery += "SE5.E5_NUMERO = SE2.E2_NUM AND "
	cQuery += "SE5.E5_PARCELA = SE2.E2_PARCELA AND "
	cQuery += "SE5.E5_TIPO = SE2.E2_TIPO AND "
	cQuery += "SE5.E5_CLIFOR = SE2.E2_FORNECE AND "
	cQuery += "SE5.E5_LOJA = SE2.E2_LOJA AND "

	cQuery += "SE5.E5_VRETINS > 0 AND "
	cQuery += "(SE5.E5_PRETINS = '2' OR SE5.E5_PRETINS ='' OR SE5.E5_PRETINS ='4') AND "

	cTipoTit	:=	""
	cTipoTit	:=	MVABATIM + "|" + MV_CRNEG + "|" + MVPROVIS
	cQuery 	+= "SE5.E5_TIPO NOT IN " + FormatIn(cTipoTit,If("|"$cTipoTit,"|",","))  + " AND "
	cQuery 	+= "SE5.E5_RECPAG = 'P' AND "
	cQuery 	+= "SE5.E5_MOTBX NOT IN ('FAT','LIQ','EEC','STP') AND "
	cQuery 	+= "SE5.E5_SITUACA <> 'C' AND "

	If cTpAcm == "2"
		dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
		dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))
		cQuery += "SE5.E5_DATA BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
	Else
		If lVencto
			cQuery += "SE5.E5_VENCTO  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
		Else
			cQuery += "SE5.E5_DATA BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
		Endif
	EndIf

	cQuery += "SE5.D_E_L_E_T_ = ' ' "
	cQuery += "AND NOT EXISTS ( "
	cQuery += "SELECT A.E5_NUMERO "
	cQuery += "FROM "+RetSqlName("SE5")+" A "
	cQuery += "WHERE A.E5_FILIAL='"+xFilial("SE5")+"' AND "
	cQuery +=		"A.E5_PREFIXO= SE5.E5_PREFIXO AND "
	cQuery +=		"A.E5_NUMERO= SE5.E5_NUMERO AND "
	cQuery +=		"A.E5_PARCELA= SE5.E5_PARCELA AND "
	cQuery +=		"A.E5_TIPO= SE5.E5_TIPO AND "
	cQuery +=		"A.E5_CLIFOR= SE5.E5_CLIFOR AND "
	cQuery +=		"A.E5_LOJA= SE5.E5_LOJA AND "
	cQuery +=		"A.E5_SEQ= SE5.E5_SEQ AND "
	cQuery +=		"A.E5_TIPODOC='ES' AND "
	cQuery +=		"A.E5_RECPAG<>'P' AND "
	cQuery +=		"A.D_E_L_E_T_ = ' ')"

	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBCALC2", .F., .T.)
	nInsRest := TRBCALC2->NVLINSCAL - TRBCALC2->NVLINSRET
	nTotRIns := TRBCALC2->NVLINSRET
	dbCloseArea()

	//Titulos que possuem borderos.
	cQuery := "SELECT SUM(E2_VRETINS) NINSBORD FROM " + RetSQLname("SE2") + " A "
	cQuery += " WHERE "
	cQuery += "( "

	For nX:= 1 to Len(aFilINSS)
		cQuery += "A.E2_FILIAL = '"+ aFilINSS[nX] + "' OR "
	Next nX

	cQuery := Left( cQuery, Len( cQuery ) - 4 )
	cQuery += ") AND "

	cQuery += "A.E2_FORNECE = '"	+	cFornece	+	"' AND "
	cQuery += "A.E2_LOJA='"		+	cLoja		+ 	"' AND "

	cTipoTit	:=	""
	cTipoTit	:=	MVABATIM + "|" + MV_CRNEG + "|" + MVPROVIS
	cQuery 	+= "A.E2_TIPO NOT IN " + FormatIn(cTipoTit,If("|"$cTipoTit,"|",","))  + " AND "

	cQuery += "A.E2_NUMBOR <> ' ' AND " 	//Titulos que possuam bordero.
	cQuery += "A.E2_PRETINS = '1' AND "		//Titulo pendente de retencao.
	cQuery += "A.E2_VRETINS > 0 AND "

	cQuery += "A.E2_FATURA = ' ' AND " 	//Titulos que nao possuam fatura.

	If cTpAcm == "2"
		dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
		dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))
		cQuery += "A.E2_EMISSAO BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
	Else
		If lVencto
			cQuery += "A.E2_VENCTO  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
		Else
			cQuery += "A.E2_EMISSAO BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
		Endif
	EndIf

	cQuery += "D_E_L_E_T_=' '"
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBCALCB", .F., .T.)
	TcSetField("TRBCALCB","NINSBORD"  ,"N", 17,2)
	nVrBord	:=	TRBCALCB->NINSBORD
	nValor	:= nValor + TRBCALCB->NINSBORD
	dbCloseArea()

	If nVrBord > 0
		cQuery := "SELECT R_E_C_N_O_ RECNO FROM " + RetSQLname("SE2")  + " SE2 "
		cQuery += " WHERE "
		cQuery += "( "

		For nX:= 1 to Len(aFilINSS)
			cQuery += "SE2.E2_FILIAL = '"+ aFilINSS[nX] + "' OR "
		Next nX

		cQuery := Left( cQuery, Len( cQuery ) - 4 )
		cQuery += ") AND "

		cQuery += "SE2.E2_FORNECE = '"+ cFornece +"' AND "
		cQuery += "SE2.E2_LOJA = '"+ cLoja +"' AND "

		cQuery += "SE2.E2_PRETINS = '1' AND "	// Pendentes de retencao com bordero.
		cQuery += "SE2.E2_NUMBOR <> ' ' AND " 	//Titulos que possuam bordero.
		cQuery += "SE2.E2_VRETINS > 0 AND "

		cQuery += "SE2.E2_FATURA = ' ' AND " 	//Titulos que nao possuam fatura.

		If cTpAcm == "2"
			dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
			dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))
			cQuery += "SE2.E2_EMISSAO BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
		Else
			If lVencto
				cQuery += "SE2.E2_VENCTO  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
			Else
				cQuery += "SE2.E2_EMISSAO BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
			Endif
		EndIf

		cQuery += "D_E_L_E_T_=' '"

		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBBORD", .F., .T.)

		While !TRBBORD->(EOF())
			aaDD(aBordINSS,TRBBORD->RECNO)
			TRBBORD->(DbSkip())
		EndDo

		dbCloseArea()
	EndIf

	//Query para selecionar titulos da tabela SE2 que estao retidos em outros titulos.
	//Nesse caso somente para a conta Valor do Inss e Valor retido bater.*/
	cQuery := "SELECT SUM(E2_VRETINS) NBORDRET FROM " + RetSQLname("SE2") + " A "
	cQuery += " WHERE "
	cQuery += "( "

	For nX:= 1 to Len(aFilINSS)
		cQuery += "A.E2_FILIAL = '"+ aFilINSS[nX] + "' OR "
	Next nX

	cQuery := Left( cQuery, Len( cQuery ) - 4 )
	cQuery += ") AND "

	cQuery += "A.E2_FORNECE = '"	+	cFornece	+	"' AND "
	cQuery += "A.E2_LOJA='"		+	cLoja		+ 	"' AND "

	cTipoTit	:=	""
	cTipoTit	:=	MVABATIM + "|" + MV_CRNEG + "|" + MVPROVIS
	cQuery 	+= "A.E2_TIPO NOT IN " + FormatIn(cTipoTit,If("|"$cTipoTit,"|",","))  + " AND "

	cQuery += "A.E2_NUMBOR <> ' ' AND " 	//Titulos que possuam bordero.
	cQuery += "A.E2_PRETINS = '2' AND "		//Titulo pendente de retencao.
	cQuery += "A.E2_FATURA = ' ' AND " 	//Titulos que nao possuam fatura.

	If cTpAcm == "2"
		dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
		dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))
		cQuery += "A.E2_EMISSAO BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
	Else
		If lVencto
			cQuery += "A.E2_VENCTO  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
		Else
			cQuery += "A.E2_EMISSAO BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
		Endif
	EndIf

	cQuery += "D_E_L_E_T_=' '"
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBCALCD", .F., .T.)
	TcSetField("TRBCALCD","NBORDRET"  ,"N", 17,2) //Borderos retidos em outro.
	nInsRest	:=	nInsRest - TRBCALCD->NBORDRET
	dbCloseArea()

	RestArea(aArea)

Return (nValor)


//---------------------------------------------------------------------------------
/*/{Protheus.doc} FGrvInSe5

Grava o relacionamento dos impostos da tabela SE5 na SFQ 

@author  Andrea Verissimo Santiago
@since  04/04/2004
/*/
//---------------------------------------------------------------------------------
Function FGrvInSe5(aListTit,nRegOri,nInss,cTipo)
	Local aTitSe2		:=	{}
	Local nOrdSe2		:= SE2->(IndexOrd())
	Local nRegSe2		:=	SE2->(Recno())
	Local nOrdSe5		:= SE5->(IndexOrd())
	Local nRegSe5		:=	SE5->(Recno())
	Local nX			:= 0
	Local nLimInss 	:= 	SuperGetMv("MV_LIMINSS",.F.,0)
	Local cFiltro		:=	SE2->(DbFilter())
	SE2->(DbClearFilter())

	SE2->(DbGoTo( nRegOri ))
	cPrefOri  := SE2->E2_PREFIXO
	cNumOri   := SE2->E2_NUM
	cParcOri  := SE2->E2_PARCELA
	cTipoOri  := SE2->E2_TIPO
	cCfOri    := SE2->E2_FORNECE
	cLojaOri  := SE2->E2_LOJA

	SE5->(Dbsetorder(1))
	For nX := 1 to Len(aListTit)

		SE5->(DbGoTo( aListTit[nX] ))

		//Caso seja acumulado no mesmo titulo nao devo alterar o PRETINS e nem criar registro na SFQ.
		If Alltrim(SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO+SE5->E5_CLIFOR+SE5->E5_LOJA) <>;
			Alltrim(cPrefOri+cNumOri+cParcOri+cTipoOri+cCfOri+cLojaOri)
			Reclock( "SE5" , .F. )
			SE5->E5_PRETINS := "2" // PRET = "2" - Retido na emissão em outro título.
			SE5->(MsUnlock())

			//Procurar o titulo referente da SE2 para guardar no array.
			dbSelectArea("SE2")
			SE2->(DbSetOrder(1))
			If SE2->(DbSeek(xFilial("SE2")+SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO+SE5->E5_CLIFOR+SE5->E5_LOJA))
				Aadd( aTitSe2, SE2->(Recno()) )
			Endif
		Else
			Reclock( "SE5" , .F. )
			SE5->E5_PRETINS := " " // PRET = " " - Retido nele mesmo.

			//Caso seja PF e o valor da baixa que está sendo realizada seja igual ao valor máximo para retenção os valores retidos do imposto nas
			//baixas anteriores devem ser zerados.
			If Upper(cTipo) == "F" .And. nInss == nLimInss
				SE5->E5_VRETINS	:=	0
			Endif
			SE5->(MsUnlock())
		Endif

	Next nX

	DbSelectArea("SE2")
	Set Filter to &cFiltro

	SE2->(Dbsetorder(nOrdSe2))
	SE2->(Dbgoto(nRegSe2))
	SE5->(Dbsetorder(nOrdSe5))
	SE5->(Dbgoto(nRegSe5))

Return aTitSe2


//---------------------------------------------------------------------------------
/*/{Protheus.doc} InsAcmBx

Verifica o valor RETIDO de inss de um fornecedor num determinado periodo quando 
imposto retido na baixa.

@param cFornece - Código do Fornecedor
@param cLoja	- Loja do Fornecedor
@param cNomeFor	- Nome do Fornecedor
@param dEmissao	- Data de emissão
@param dVencRea	- Data de vencimento real

@return nValor	- Valor do INSS acumulado no periodo

@author  Andrea Verissimo Santiago
@since  04/04/2004
/*/
//---------------------------------------------------------------------------------

Function InsAcmBx(cFornece,cLoja,cNomeFor,dEmissao,dVencRea)
	Local nValor 	:= 0
	Local aArea 	:= GetArea()
	Local lVencto 	:= SuperGetMv("MV_ACMINSS",.T.,"1") == "2"  //1 = Emissao    2= Vencimento Real
	Local lTodasFil := ExistBlock("F50TFINS")
	Local aFilINSS 	:= {}
	Local nX		:= 0
	Local cTipoTit	:= ""
	Local cQuery	:= ""
	Local cTpAcm    := SuperGetMv("MV_INSTPAC", .F., "1" )  //Default 1
	Local dDataIni  := CTOD("//")
	Local dDataFim  := CTOD("//")

	//Verifico todas as filiais apenas quando SA2 compartilhado
	If lTodasFil
		aFilINSS := ExecBlock( "F50TFINS", .F., .F. )
	Else
		aFilINSS := { xFilial("SE5") }
	Endif

	If Empty(cFornece) .or. Empty(cLoja) .or. Empty(dEmissao) .or. Empty(cNomeFor) .or. If(lVencto, Empty(dVencRea),Empty(dEmissao))
		Return 0
	Endif

	cQuery := "SELECT SUM(E5_VRETINS) NVALINSS "
	cQuery	+= "FROM "
	cQuery += RetSqlName("SE5") + " SE5 "

	cQuery += " WHERE "
	cQuery += "( "

	// Filiais
	For nX:= 1 to Len(aFilINSS)
		cQuery += "SE5.E5_FILIAL = '"+ aFilINSS[nX] + "' OR "
	Next nX

	cQuery := Left( cQuery, Len( cQuery ) - 4 )
	cQuery += ") AND "

	cQuery += "SE5.E5_CLIFOR = '"	+	cFornece	+"' AND "
	cQuery += "SE5.E5_LOJA='"		+	cLoja		+ "' AND "

	cTipoTit	:=	""
	cTipoTit	:=	MVABATIM + "|" + MV_CRNEG + "|" + MVPROVIS
	cQuery 	+= "SE5.E5_TIPO NOT IN " + FormatIn(cTipoTit,If("|"$cTipoTit,"|",","))  + " AND "
	cQuery 	+= "SE5.E5_RECPAG = 'P' AND "
	cQuery 	+= "SE5.E5_MOTBX NOT IN ('FAT','LIQ','EEC','STP') AND "
	cQuery 	+= "SE5.E5_SITUACA <> 'C' AND "

	cQuery += "SE5.E5_VRETINS > 0 AND "
	cQuery += "SE5.E5_PRETINS IN (' ','2','4') AND "	//Retidos nele mesmo, retido em outro titulo e retido em bordero.

	If cTpAcm == "2"
		dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
		dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))
		cQuery += "SE5.E5_DATA BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
	Else
		If lVencto
			cQuery += "SE5.E5_VENCTO  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
		Else
			cQuery += "SE5.E5_DATA BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
		Endif
	EndIf

	cQuery += "SE5.D_E_L_E_T_=' '"
	cQuery += "AND NOT EXISTS ( "
	cQuery += "SELECT A.E5_NUMERO "
	cQuery += "FROM "+RetSqlName("SE5")+" A "
	cQuery += "WHERE A.E5_FILIAL='"+xFilial("SE5")+"' AND "
	cQuery +=		"A.E5_PREFIXO=SE5.E5_PREFIXO AND "
	cQuery +=		"A.E5_NUMERO=SE5.E5_NUMERO AND "
	cQuery +=		"A.E5_PARCELA=SE5.E5_PARCELA AND "
	cQuery +=		"A.E5_TIPO=SE5.E5_TIPO AND "
	cQuery +=		"A.E5_CLIFOR=SE5.E5_CLIFOR AND "
	cQuery +=		"A.E5_LOJA=SE5.E5_LOJA AND "
	cQuery +=		"A.E5_SEQ=SE5.E5_SEQ AND "
	cQuery +=		"A.E5_TIPODOC='ES' AND "
	cQuery +=		"A.E5_RECPAG<>'P' AND "
	cQuery +=		"A.D_E_L_E_T_ = ' ')"

	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRB", .F., .T.)
	TcSetField("TRB","NVALINSS"  ,"N", 17,2)
	nValor := nValInss
	dbCloseArea()

	cQuery := "SELECT SUM(E2_VRETINS) NVRINSS FROM " + RetSQLname("SE2") + " SE2 "
	cQuery += " WHERE "
	cQuery += "( "

	For nX:= 1 to Len(aFilINSS)
		cQuery += "SE2.E2_FILIAL = '"+ aFilINSS[nX] + "' OR "
	Next nX

	cQuery := Left( cQuery, Len( cQuery ) - 4 )
	cQuery += ") AND "

	cQuery += "SE2.E2_FORNECE = '"	+	cFornece	+	"' AND "
	cQuery += "SE2.E2_LOJA='"		+	cLoja		+ 	"' AND "

	cQuery += "SE2.E2_NUMBOR <> ' ' AND "

	cQuery += "SE2.E2_FATURA = ' ' AND " 	//Titulos que nao possuam fatura.

	cTipoTit	:=	""
	cTipoTit	:=	MVABATIM + "|" + MV_CRNEG + "|" + MVPROVIS
	cQuery 	+= "SE2.E2_TIPO NOT IN " + FormatIn(cTipoTit,If("|"$cTipoTit,"|",","))  + " AND "

	cQuery += "SE2.E2_VRETINS > 0 AND "
	cQuery += "SE2.E2_PRETINS = '2' AND "	//Retidos retidos em outro titulo que contenham bordero.

	If cTpAcm == "2"
		dDataIni :=  CTOD("01/01/"+STR(YEAR(dEmissao)))
		dDataFim :=  CTOD("31/12/"+STR(YEAR(dEmissao)))
		cQuery += "SE2.E2_EMISSAO BETWEEN '" + Dtos(FirstDay(dDataIni-1825)) + "' AND '" + Dtos(dDataFim)+ "' AND "
	Else
		If lVencto
			cQuery += "SE2.E2_VENCTO  BETWEEN '" + Dtos(FirstDay(dVencRea)) + "' AND '" + Dtos(LastDay(dVencRea))+ "' AND "
		Else
			cQuery += "SE2.E2_EMISSAO BETWEEN '" + Dtos(FirstDay(dEmissao)) + "' AND '" + Dtos(LastDay(dEmissao))+ "' AND "
		Endif
	EndIf

	cQuery += "D_E_L_E_T_=' '"

	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), "TRBBORD", .F., .T.)
	TcSetField("TRBBORD","NVRINSS"  ,"N", 17,2)
	nValor := nValor + nVrInss
	dbCloseArea()

	RestArea(aArea)

Return (nValor)

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} VLDBCOLD função original VldBanco

Validar a existencia dos codigos de Banco, Agencia e Conta e ainda se existe Bloqueio do registro.
Arquivo anterior: FINXFUN.PRX

@Author	Norberto M. Melo
@since	03/09/2007
/*/
//-----------------------------------------------------------------------------------------------------
Function VldBcold()
LOCAL lRet := .T.

If !Empty(M->E5_BANCO) .and. !Empty(M->E5_AGENCIA) .and. !Empty(M->E5_CONTA)
	lRet := ExistCpo("SA6", M->(E5_BANCO+E5_AGENCIA+E5_CONTA))
ElseIf !Empty(M->E5_BANCO) .and. !Empty(M->E5_AGENCIA)
	lRet := Existcpo("SA6",M->(E5_BANCO+E5_AGENCIA),,,,.F.)
Else
	lRet := Existcpo("SA6",M->E5_BANCO,,,,.F.)
Endif

Return lRet
