#INCLUDE "atfa050.ch"
#INCLUDE "Protheus.ch"
#INCLUDE "FWLIBVERSION.CH"

#DEFINE CONFIRMA					1
#DEFINE REDIGITA					2
#DEFINE ABANDONA					3
#DEFINE NOMEDOCAMPO					1
#DEFINE CONTEUDODOCAMPO				2
#DEFINE DEPRECIACAO_ACUMULADA		1
#DEFINE CORRECAO_DA_DEPRECIACAO		2
#DEFINE VALOR_ORIGINAL				3
#DEFINE CORRECAO_ACUMULADA			4
#DEFINE VALOR_DA_AMPLIACAO			5
#DEFINE TAXA_DE_DEPRECIACAO			6
#DEFINE P_ANUAL						"A"
#DEFINE P_MENSAL					"M"
// MV_CALCDEP - Forma de Calculo da Depreciacao
#DEFINE cd_MENSAL					"0"	// Zero
#DEFINE cd_ANUAL					"1"	// UM
// TRADUCAO DE CH'S PARA PORTUGAL
Static lFWCodFil	:= .T.
// Definicao de ambiente
Static __lStruPrj
// Verifica se existem as funções e se o ATFA051 está configurado no Adapter do Scheduler no Configurador
Static __lEAI051 	:= NIL
// *******************************
// Controle de multiplas moedas  *
// *******************************
Static lMultMoed := .T.
STATIC lIsRussia	:= NIL

//Metricas
Static __lMetric	:= NIL

Static __lAf050CT  := NIL

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Carrega as perguntas selecionadas:               ³
//³ mv_par01 - 1 Mostra lan‡amentos cont beis        ³
//³            2 NAO Mostra lan‡amentos cont beis    ³
//³            3 NAO Contabiliza                     ³
//³ mv_par02 - 1 Aglutina                            ³
//³            2 Nao Aglutina                        ³
//³ mv_par03 - 1 Trazer Centro de Custo              ³
//³          - 2 Nao trazer Centro de Custo          ³
//³ mv_par04 - 1 Abrir Exclusivo                     ³
//³            2 Abrir Compartilhado                 ³
//³ mv_par05 - Taxa de referencia                    ³
//³ mv_par06 - Cons. Filiais                         ³
//³ mv_par07 - Filial de                             ³
//³ mv_par08 - Filial ate                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ ATFA050  ³ Autor ³ Wagner Xavier               ³ Data ³ 17/08/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calculo de deprecia‡„o e corre‡„o monet ria do Ativo Imob.       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Gen‚rico                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³                            ATUAIZACOES SOFRIDAS                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador  ³ Data   ³   BOPS   ³           Motivo da Alteracao             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Marco A. Glz ³18/04/17³  MMI-365 ³Se replica llamado TVTXMA, el cual consiste³±±
±±³             ³        ³          ³en realizar el calculo de depreciacion,    ³±±
±±³             ³        ³          ³cuando el calendario sea diferente al 01 de³±±
±±³             ³        ³          ³Enero - 31 Diciembre. (ARG)                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function ATFA050( cAlias, lDireto )

	Local lResult		:= AmIIn( 1 )				//Restringe acesso ao Sigaatf
	Local oDlg			:= nil
	Local nOpca			:= Iif(cPaisLoc=="CHI",1,0 )	// Chile entra como ok, os outros entram como Cancelar
	Local nDecimais 	:= Set( _SET_DECIMALS )
	Local cPictTxDep	:= ""
	Local dDataBx 		:= SuperGetMV("MV_ATFULBX",.F.,"")
	Local dDataVir 		:= SuperGetMV("MV_VIRAATF",.F.,"")
	Local cMoedaAtf 	:= SuperGetMV("MV_ATFMOED")
	Local cMoedaMax		:= SuperGetMV("MV_ATFMDMX",.F.,cMoedaAtf)
	Local aSays			:= {}
	Local aButtons		:= {}
	Local cFunction		:= "ATFA050"
	Local cPerg			:= "AFA050"
	Local cTitle		:= STR0005
	Local dUltDepr		:= SuperGetMV("MV_ULTDEPR",.F., STOD("19800101"))
	Local bProcess		:= {|oSelf,cAlias| A050CALC(cAlias,cMoedaAtf,dUltDepr,.F.,oSelf) }
	//Data de Bloqueio da Movimentação - MV_ATFBLQM
	Local dDataBloq		:= SuperGetMV("MV_ATFBLQM",.F.,CTOD(""))
	Local cATFCRAT		:= SuperGetMV("MV_ATFCRAT",.F.,"1") //Criterio de atualizacao: 0-Mensal | 1-Anual (Default)
	Private cDescription:= " "

	Private aRotina		:= MenuDef()
	Private cCadastro	:= STR0005 // "C lculo de Deprecia‡Æo e Corre‡Æo Monet ria"
	Private Inclui		:= .t. /*Esta variavel Inclui foi inserida para contornar um bug na funcao AXINCLUIF3()*/
	Private nTaxaDepr	:= IIf( cPaisloc == "BRA", 0.8287, 1.0000 )
	Private cUltDiaMes := "1231"
	Private cPriDiaMes	:= "0101"
	Private lPerDepr	:= .F.

	Default lDireto := .F.
	Set( _SET_DECIMALS ,4 )

	cMoedaMax := IIF(!Empty(cMoedaMax),cMoedaMax,cMoedaAtf)

	ATFXKERNEL()
	LoadVar050()
	
	dbSelectArea("SN4")
	dbSetOrder(1) //Garantir que indice 1 da SN4 esteja aberto 

	If !Empty(dDatabase) .AND. (dDataBase <= dDataBloq)
		HELP(" ",1,"AF050BLQM",,STR0032 + DTOC(dDataBloq) ,1,0)    //"A data de aquisição do bem é igual ou menor que a data de bloqueio de movimentação : "
		lResult := .F.
	EndIf

	//Validacao para o bloquei do proceco
	If lResult .And. !CtbValiDt(,dDataBase  ,,,,{"ATF001"},)
		lResult := .F.
	EndIf

	// Executa o ponto de entrada AF050CHK
	If AF050CHK()

		If lResult .and. cPaisLoc == "CHI"

			If cATFCRAT == "1" //Criterio de atualização anual
				If Month(dDatabase) ==	1
					If Year( dDataBx ) + 1 <> Year( dDataBase )
						If MsgYesNo(OemToAnsi(STR0034) + OemToAnsi(STR0017) +  Dtoc(dDataBx) + ", " + OemToAnsi(STR0001) + "?","ULTBAIXA") //"Atencao"###" Nao foi feita a baixa anual para o exercicio anterior. Ultima baixa executada em: "###"Confirma"
							lResult := .T.
						Else
							lResult := .F.
						EndIf
					EndIf
					If lResult .and. (dDataBx <> dDataVir .Or. Year(dDataBase) <> Year(dDataVir)+ 1 )
						Help(" ",1,"VIRADAANUAL",,OemToAnsi(STR0019) + Dtoc(GetMV("MV_VIRAATF")) + OemToAnsi(STR0020),1,0)//"Nao foi feita a virada anual para o exercicio anterior. Ultima Virada executada em "###"Virada Anual"
						lResult := .F.
					EndIf
				EndIf

			ElseIf cATFCRAT == "0" //Criterio de atualização mensal

				//-----------------------------------------------
				// Valida se o mes de execucao ja sofreu calculo
				//-----------------------------------------------
				If lResult .And. (Month(dDatabase) == Month(dDataBx) .And. Year(dDatabase) == Year(dDataBx))
					lResult := .F.
					Help(" ",1,"ATFA050",,STR0044,1,0) //"O crédito do Ativo Fixo já ocorreu para este mês. Verifique o parâmetro MV_ATFULBX"
				EndIf

				//----------------------------------------------------
				// Se mes de execucao for janeiro, valida se o ultimo
				// calculo foi realizado em dezembro do ano anterior
				//----------------------------------------------------
				If lResult .And. (Month(dDatabase) == 1 .And. (Month(dDataBx) != 12 .Or. Year(dDataBx)+1 != Year(dDatabase)))
					lResult := .F.
					Help(" ",1,"ATFA050",,STR0045,1,0) //"O mês de execução não é posterior ao último cálculo de crédito do Ativo Fixo. Verifique os parâmetros MV_ATFULBX e MV_ATFCRAT."
				EndIf

				//---------------------------------------------------
				// Caso não seja janeiro, valida o ano e se o mes do
				// último calculo eh anterior a data de execucao
				//---------------------------------------------------
				If lResult .And. (Month(dDatabase) != 1 .And. (Month(dDatabase)-1 != Month(dDataBx) .Or. Year(dDataBx) != Year(dDatabase)))
					lResult := .F.
					Help(" ",1,"ATFA050",,STR0045,1,0) //"O mês de execução não é posterior ao último cálculo de crédito do Ativo Fixo. Verifique os parâmetros MV_ATFULBX e MV_ATFCRAT."
				EndIf

			Else
				lResult := .F.
				Help(" ",1,"ATFA050",,STR0043,1,0) //"Parametro MV_ATFCRAT configurado incorretamente"
			EndIf

		EndIf

		// Valida o conteudo do parametro MV_ATFMOED
		If lResult
			If !AtfVldMoed(cMoedaAtf)
				lResult := .F.
				Help(" ",1,"ATFVLDMOED",,"Parametro MV_ATFMOED configurado incorretamente",1,0)//"Parametro MV_ATFMOED configurado incorretamente"
			Else
				cDescription:=	STR0006 + " " +;
				STR0007 + CHR(10) +;
				STR0008 + Dtoc(dUltDepr) + CHR(10) +;
				STR0010 + GETMV("MV_SIMB" + cMoedaAtf) + " ( "+ cMoedaAtf + ")"
			Endif

		Endif

		// Valida o conteudo do parametro MV_ATFMDMX
		If lResult
			If !AtfVldMoed(cMoedaMax)
				lResult := .F.
				Help(" ",1,"ATFVLDMOED",,"Parametro MV_ATFMDMX configurado incorretamente",1,0)//"Parametro MV_ATFMDMX configurado incorretamente"
			Endif
		Endif

		If lResult

			If ( IsBlind() .Or. lDireto )
				BatchProcess(	cCadastro, 	STR0005 + Chr(13) + Chr(10) +;
				STR0006 + Chr(13) + Chr(10) +;
				STR0008 + Chr(13) + Chr(10) +;
				STR0010 + Chr(13) + Chr(10) +;
				STR0009, "ATFA050",;
				{ || A050CALC(cAlias,cMoedaAtf,dUltDepr,.T.) }, { || .F. })
				lResult := .F.
			Endif
		Endif

		If lResult
			SetKey( VK_F12, { |a,b| AcessaPerg("AFA050",.T.) } )
			cPictTxDep:= PesqPict("SM2","M2_MOEDA"+cMoedaAtf,12)
			Pergunte("AFA050",.F.)

			tNewProcess():New(cFunction,cTitle,bProcess,cDescription,cPerg)
			If ExistBlock("AF050FIM")
				Execblock("AF050FIM",.T.,.T., { dUltDepr })
			EndIf
		EndIf

	EndIf	//	AF050CHK()

	SET KEY VK_F12 TO
	SET( _SET_DECIMALS , nDECIMAIS )

Return (nil)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ A050Calc   ³ Autor ³ Wagner Xavier         ³ Data ³ 17/08/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calculo de deprecia‡„o e corre‡„o monet ria do Ativo Imob.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A050Calc( cAlias, cMoedaAtf, dUltDepr, lDireto, oSelf, lCheck070 )

	Static aHeader
	Static lN3Deprec
	Static aTaxas // Devera conter os indices do cadastro de moedas ref a databse mais o ultimo dia da database anterior.

	Local dUltProc		:= dUltDepr
	Local nTxPerdida	:= 0
	Local nDias			:= 0
	Local cFiltro		:= nil

	Local aTotDeprec	:= {}	// Auxiliar Para controle de tipos de Ativo = '01'
	Local nDepr1 		:= 0

	Local nDiferenca   	:= 0
	Local cTipoCorr 	:= ""
	Local nCalcRes		:= 0	// Calculo do Residuo (nDiferenca)
	Local nVarIPC		:= 0	// Calculo variacao do IPC
	Local lRet			:=	.F.

	// Contabilizacao
	Local cArquivo, cConta, cDebito, cCredito

	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local cLoteAtf		:= LoteCont("ATF")
	Local nHdlPrv 		:= 0
	Local lHdlProva  	:= .F.
	Local nTotal		:= 0
	Local lPadrao 		:= VerPadrao("820")
	Local lLP_Rat		:= VerPadrao("823")//acrescentado por Fernando Radu Muscalu em 09/05/2011
	Local lMostra 		:= IIf( mv_par01 == 1, .T., .F. )

	// Pontos de Entrada
	Local lAtfa050 		:= ExistBlock("AF050CAL")	// Deve ser hamado logo apos o tratamento de correcao do bem.
	Local lA30Embra	 	:= ExistBlock("A30EMBRA")	// Fixa o valor da Ufir. E chamado para mudança/inclusao de linhas do ativo.
	Local lAf050Ctb 	:= ExistBlock("AF050CTB")	// O ponto de entrada AF050CTB sera utilizado, entre outros fins, para
													// contabilizacao de rateio de depreciacao entre centro de custos.
													// Seu uso e abrangente, permitindo a substituicao/ complementacao do LP820.
	Local lChmLpd		:= .T.	// Indica se chamara o lancamento definido no PE AF050CTB
	Local lAtf050l   	:= ExistBlock("ATF050LOG")
	Local lAtf0502		:= ExistBlock("AF050SPS")
	// Estabalecendo ambiente
	
	Local cCodCusto  	:= CriaVar("N3_CCUSTO")
	Local lHeadExist	:= .F.
	Local aRet			:= {}
	Local cFilDe  		:= cFilAnt
	Local cFilAte 		:= cFilAnt
	Local cFilOld 		:= cFilAnt

	Local ni
	Local aDepre
	Local aBases
	Local aRegSn301		:= {}	// Auxiliar no tratamento de Depreciacao Incentivada
	Local aRegSn308		:= {}	// Auxiliar no tratamento de Depreciacao Incentivada
	Local aEntidade 	:= {}	// Auxiliar na selecao de Grupos de Bens
	Local aPFimDepr 	:= {}	// Auxiliar na atualizacao do N3_FIMDEPR (Tipos 01 e 07)
	Local aRusModer		:= {}	// Set of russian modernization operations for this month
	Local nSldAcelM1	:= 0	// O saldo depreciado em moeda 1, dos tipos 01 e 07.
	Local nSldAcelMP	:= 0	// O saldo depreciado na Moeda do parametro MV_ATFMOEDA, dos tipos 01 e 07.

	// Customizacao da Correcao Monetaria para a Argentina Boletim 00004935-08
	Local nMesCalc 		:= 0
	Local nN3VDPCOMM	:= 0			// Valor da Correcao Monetaria sobre a Depreciacao no Mes
	Local nN3VDPCOMA	:= 0			// Valor da Correcao Monetaria sobre a Depreciacao Acumulada
	// 0- BLOQUEIO INTEGRAL
	// 1- BLOQUEIO PROPORCIONAL NO MES DE TERMINO DO BLOQUEIO
	Local cTipoImob		:= ""
	Local nInc			:= 0
	Local aSM0 			:= AdmAbreSM0()
	
	// Habilita/Desabilita o recurso de depreciação no uso de campos N1_TPDEPR, N3_TPDEPR, N3_VLACTXP
	Local lCalcTxPer	:= .F.

	// Uso do calculo da Taxa Perdida para PORTUGAL (PTG)
	Local aTxMoedas		:= AtfMultMoe(,,{|x| 0})
	Local __nQuantas	:= AtfMoedas()
	Local i				:= 0
	Local aValTxPerd	:= Array(__nQuantas)
	Local aValTxAcuP	:= Array(__nQuantas)
	Local nMFiscal		:= Val(cMoedaAtf)
	Local cIDMOV		:= ""
	Local nMoedaVMax  	:= Iif(Val(SuperGetMV("MV_ATFMDMX",.F.," "))>0, Val(SuperGetMV("MV_ATFMDMX")), Val(cMoedaAtf))
	Local cFilProc		:= ""

	Local lAtfctap	:= IIF(SuperGetMV("MV_ATFCTAP",.F.,"0")=="0",.F.,.T.)
	Local dDataVir
	Local lSldAtf

	Local lSN3Saldo:= .T.
	Local cTpSaldo := ""
	//Tratamento para bens bloqueados, baseado no parametro MV_ATFCLBL
	Local lDeprBlq	:= .F.		//determina se bens bloqueados serao depreciados
	Local lCorrBlq	:= .F.		//determina se bens bloqueados terao correcao monetaria
	Local lBemBloq	:= .F.

	// Verificação da classificação de Ativo se sofre depreciação
	Local lAtClDepr := .F.

	Local cAvisoTit	:= ""
	Local cAvisoMsg	:= ""

	//Verifica implementacao da Margem Gerencial - MRG
	Local lMargem 	:= AFMrgAtf()
	Local lFirst    := .T.
	Local cTipoGerenc := ATFXTpBem(2)
	Local lOnOff := .T.
	Local cTmpCtrl  := ""
	Local cTypes10		:= IIF(lIsRussia,"*" + AtfNValMod({1}, "*"),"") // CAZARINI - 24/03/2017 - If is Russia, add new valuations models - main models
	Local oATF050TMP	:= Nil
	Local lCheckObj 	:= ValType(oSelf) == "O"
	Local lSN4Mult		:= SuperGetMv("MV_SN4MULT", .F., .T.)

	Local nQtdReg		:= 0
	Local nStart		:= 0

	Default lCheck070 := .F.

	// Calculo de Depreciacao
	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Private aValDepr	:= AtfMultMoe(,,{|x| 0})			// Valor da Cota de Depreciacao

	Private lAcelMes 	:= .F.	  		// Sinaliza se tem aceleracao no Mes

	Private nValCorr	:= 0
	Private nValCorDep 	:= 0			// Valor de Correcao sobre Depreciacao Acumulada
	Private nValCorDAC 	:= 0			// Valor de Correcao sobre Depreciacao Acumulada (Chile)
	Private nTaxaCorr 	:= 0			// Taxa para as Correcoes do Bem e da Depreciacao
	Private nTxVar		:= 0
	Private nTaxaMesSeg := 0
	Private aTxMedia	:= AtfMultMoe(,,{|x| 0})
	Private aTxMediaCM	:= AtfMultMoe(,,{|x| 0})
	Private aTaxaMes	:= AtfMultMoe(,,{|x| 0})
	Private cAliasSn1	:= "SN1"
	Private cAliasSn3	:= "SN3"
	Private dBloqueio	:= CToD( "" )
	Private dInDepr		:= CToD( "" )
	Private nUsado		:= 0			// Esta variavel e usada no ATFXFUN:Function atfx3
	Private lCtb       	:= CtbInUse()
	Private cMesAno		:= ""			// Auxiliar p/Contabilizacao
	// Parametrizacao do Configurador
	Private lMesCheio	:= SuperGetMv("MV_TIPDEPR",.F.,"0")$"14"				// Mes Cheio
	Private lAtfCont	:= ( SuperGetMv("MV_ATFCONT") == "O" )					// Baixa On Line = 'O' ou Off Line = 'N'
	Private lAjustInf	:= SuperGetMV("MV_ATFINFL",.F.,.F.)
	// Capital Social
	Private cContaCap	:= SuperGetMv("MV_CONTACO",/**/,""/*Default*/)		// Conta de Correcao do Capital Social
	Private lConta     	:= Empty( SuperGetMv("MV_CONTACO",/**/,""/*Default*/) )
	Private nCorrec		:= SuperGetMV("MV_CORCAPI")							// Valor da Correcao sobre Capital Social
	// Calculo da Correcao Monetaria
	Private lCalcula	:= SuperGetMV("MV_CORREC",.F.,"N")=="S"				// Define se deve calcular a Correcao
	Private nMVVALCORR	:= SuperGetMV("MV_VALCORR",.F.,0)						// Fator de correcao. Obs.: Nao eh porcentagem
	Private cMVATFMCCM	:= SuperGetMV("MV_ATFMCCM",.F.,"M")						// Metodo de Calculo da Correcao Monetaria

	Private cPerRegres	:= SuperGetMV("MV_PCALCAF",.F.,"")						// Periodo de Calculo
	Private nMesRegres	:= SuperGetMV("MV_MCALCAF",.F.,0)						// Mes para Calculo Anual
	Private cModoBlq	:= SuperGetMV("MV_ATFMBLQ",.F.,"0")
	Private cTCalcAF	:= SuperGetMV("MV_TCALCAF",.F.,"0")
	Private cCalcDep	:= SuperGetMV("MV_CALCDEP",.F.,'0')						//-> '0'-Mensal
	//-> '1'-Anual
	Private cTipDepr	:= AllTrim(SuperGetMV("MV_TIPDEPR"))					//-> '0'-Proporcional
	//-> '1'-Mes Cheio
	//-> '2'-Mes Posterior (NAO calc deprec de bens baixados(RIPASA) no mes de calc)
	//-> '3'-Ano proporcional com mes de aquisicao proporcional
	//-> '4'-Ano proporcional com mes de aquisicao cheio
	//-> '5'-Ano posterior
	Private bContador
	
	If __lMetric
		nStart := Seconds()
	End

	If cPaisLoc == "ARG"
		lPerDepr := ATFXPerDepr(@cPriDiaMes, @cUltDiaMes)
	EndIf // Bloco de referencia para uso de escala de processamento

	// verifica parametro que controla transacoes
	Private lAtivaControle := SuperGetMV("MV_ATFCTRL",.F.,.F.)	

	// se a rotina esta com o controle de transacao ativo,
	// os parametros sao forcados manualmente
	If lAtivaControle
		MV_PAR01 := 3                            // nao contabiliza
		MV_PAR02 := 2                            // nao aglutina
		MV_PAR03 := 2                            // nao contabiliza cc
		MV_PAR04 := 1                            // exclusivo
		MV_PAR06 := 1                            // considera filiais
		MV_PAR07 := Replicate(" ", Len(cFilAnt)) // branco
		MV_PAR08 := Replicate("Z", Len(cFilAnt)) // ZZZ
	EndIf

	//Contabilização dos mov. gerados pelo Cálc Mensal do Ativo Fixo ser OffLine "N"
	//o parametro sera forcado manualmente 
	If !lAtfCont
		MV_PAR01 := 3                            // nao contabiliza
		MV_PAR02 := 2                            // nao aglutina
		MV_PAR03 := 2                            // nao contabiliza cc
	EndIF

	IF lAtf050l
		If !ExecBlock("ATF050LOG")
			Return
		EndIf
	EndIf

	lOnOff := MV_PAR01 < 3 

	// Tabelas - Descricao
	DbSelectArea( "SIE" )		// Indices de Ajuste de Inflacao (usada para ARG)
	SIE->( DbSetOrder( 1 ) )	// IE_FILIAL+IE_EXERCIC+IE_MES

	//Registrando no log de processos
	If lDireto
		LogRecord("Inicio - CALCULO DE DEPRECIAÇÃO")
	Else
		oSelf:SaveLog("MENSAGEM: Iniciando processo de cálculo de depreciação")
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o campo N3_DEPREC esta' ou nao em uso.                                                                              ³
	//³ Se estiver em uso para Brasil significa que deve-se usar o calculo da depreciacao do tipo "Safra Fundada", da Usina Cerradinho. ³
	//³ Para outros paises indica o uso do campo N3_DEPREC para definir o método de depreciação                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If aHeader == Nil
		aHeader := {}
		Atfx3( "SN3", @aHeader )
		lN3Deprec := Ascan( aHeader, {|e| Trim(e[2]) == "N3_DEPREC" } ) > 0
	Endif

	// Habilita/Desabilita o recurso de depreciação no uso de campos N1_TPDEPR, N3_TPDEPR, N3_VLACTXP
	lCalcTxPer := .T.

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ lAtfCont-Atualizar arquivos Off Line                                      ³
	//³ lHeadExist - Verifica se o Header foi criado Rotina de Atualizacao do SN3 ³
	//³ Pesquisa taxa da UFIR no 1.dia do pr¢ximo mˆs.                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lAtfCont
		A050AtuOFF(@nHdlPrv,@nTotal,@lHeadExist,@cArquivo)
	EndIf

	If mv_par04 == 1	// Abrir Exclusivo
		If !( MA280FLock( IIf( lCtb, "CT1", "SI1" ) ) .And.;
			MA280FLock("SN1") .And.;
			MA280FLock("SN2") .And.;
			MA280FLock("SN3") .And.;
			MA280FLock("SN4") .And.;
			MA280FLock("SN5") .And.;
			MA280FLock("SN6"))
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Fecha todos os arquivos e reabre-os de forma compartilhada   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbCloseAll()
			OpenFile(SubStr( cNumEmp, 1, 2))
			Return .T.
		Endif
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pesquisa taxa da UFIR no 1.dia do pr¢ximo mˆs. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nTaxaMesSeg := af050MesSeg(cMoedaATF)

	If (dDataBase <= Ctod("01/06/96","ddmmyy"))
		If nTaxaMesSeg == 0
			If lDireto
				LogRecord( 'ID:AF050TXSEG' )
			Else
				Help( " ",1,"AF050TXSEG" )
			EndIf
			Return
		Endif
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cria array com os nomes dos campos do SNG (Cadastro de grupos)³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SX3->(MsSeek("SNG"))
	SX3->(DbEval( { || Aadd(aEntidade, SX3->X3_CAMPO ) }, , { || SX3->X3_ARQUIVO == "SNG" } ) )

	// ----------------------------------------------------------
	// Carrega todos os indices de moedas no contexto do periodo
	// ----------------------------------------------------------
	If !lDireto
		oSelf:SetRegua1( Day( dDataBase ) )
		bContador := {|nInc| If(oSelf:lEnd, .F., ( oSelf:IncRegua1(LTrim(Str(nInc))), .T. )) }
	Else
		bContador := {|nInc| .T.}
	EndIf

	aTaxas	:= GetTaxas( bContador, .T.)
	nDias	:= Len( aTaxas )
	If nDias == 0

		//---------------------------------------
		// Exclusao da tabela temporaria cArqTmp
		//---------------------------------------
		If oATF050TMP <> Nil
			oATF050TMP:Delete()
			oATF050TMP := Nil
		EndIf

		Return
	Endif

	If mv_par06 == 1 // considera filiais
		cFilDe  := mv_par07
		cFilAte := mv_par08
	Endif
	dbSelectArea("SN3")

	// backup para reprocessamento
	cTmpCtrl := af050CtrlI()
	If Empty(cTmpCtrl)
		Return .F.
	EndIf

	If ValidSP()
		If mv_par06 == 1 // considera filiais
			dUltProc := SuperGetMV( "MV_ULTDEPR",.F., STOD( "19800101" ) )
		Endif

		If lAtf0502
			lRet := ExecBlock("AF050SPS",.F.,.F.)
			If lRet
				ExecuteSP(cMoedaAtf, cFilDe, cFilAte)
			EndIf
		Else
			ExecuteSP(cMoedaAtf, cFilDe, cFilAte)
		EndIf
	Else
		//somente quando nao tem procedure instalada verifica var __lAf050CT para ver se chama funcao A050CONTPROC
		//Para chamar esta funcao deve ser conteudo (.F.) no parametro MV_AF050CT - LOGICO por padrao .T. - proc normal atual
		__lAf050CT := If(__lAf050CT != NIL, __lAf050CT, .T.) 
		lOnOff := MV_PAR01 < 3 .And. __lAf050CT
		If cPaisLoc == "BRA"
			ChkFile("SN3",.F.,"NEWSN3")
		Endif

		// Processa todo o arquivo de filiais ou apenas a filial atual
		For nInc := 1 To Len( aSM0 )

			If aSM0[nInc][1] == cEmpAnt .AND. aSM0[nInc][2] >= cFildE .AND. aSM0[nInc][2] <= cFilAte
				cFilAnt := aSM0[nInc][2]

				//Tratamento para validar se o usuário possui permissão na Filial a ser calculada
				If !VldFilial(cFilAnt)
					Loop
				EndIf
				//Tratamento Gestao Corporativa
				If Len( xFilial("SN3") ) > 2
					If !Empty(xFilial("SN3"))
						If Alltrim(cFilProc) != Alltrim(xFilial("SN3"))
							cFilProc:= xFilial("SN3")
						Else
							Loop
						EndIf
					Else  //se for tudo compartilhado
						If !lFirst
							Exit
						EndIf
					EndIf
				EndIf

				lDeprBlq	:= (SuperGetMV("MV_ATFCLBL",.F.,"0") $ "1|3")	//determina se bens bloqueados serao depreciados
				lCorrBlq	:= (SuperGetMV("MV_ATFCLBL",.F.,"0") $ "2|3")	//determina se bens bloqueados terao correcao monetaria

				If mv_par06 == 1 // considera filiais
					dUltProc:= SuperGetMV("MV_ULTDEPR",.F., STOD("19800101"))
				Endif
				lSldAtf 	:= SuperGetMV("MV_ATFRSLD",.F.,.F.)

				//se tem o parametro MV_ATFRSLD (REFAZ SALDO) CONFIGURADO COM .T. e controla data de virada
				If lSldAtf
					dDataVir :=  AtfGetSN0("13","VIRADAATIVO")

					If !Empty(dDataVir)

						dDataVir := STOD(dDataVir)

						//data da virada deve ser sempre no primeiro dia do ano
						If lPerDepr
							If ( DTOS(dDataVir) != "19800101" .And. Year(dDataBase) != Year(dDataVir)+1 ) .Or. dDataBase < dDataVir
								cAvisoTit	:=	STR0034	 							//"Atencao"
								cAvisoMsg	:=	STR0035 + CRLF + ;					//"O calculo de depreciacao somente pode ser efetuado após a  virada anual no exercicio vigente. "
												STR0036 + cFilAnt + " " + CRLF + ;	//"Filial : "
												STR0037 + DtoC(dDataVir) + " " + ;	//"Ultima Virada : xx/xx/xx"
												STR0038 + DtoC(dUltDepr)				//"Ultimo Calculo Depreciacao : xx/xx/xx"
							EndIf
						Else
							If ( DTOS(dDataVir) != "19800101" .And. Year(dDataBase) != Year(dDataVir) ) .Or. dDataBase < dDataVir
								cAvisoTit	:=	STR0034	 							//"Atencao"
								cAvisoMsg	:=	STR0035 + CRLF + ;					//"O calculo de depreciacao somente pode ser efetuado após a  virada anual no exercicio vigente. "
												STR0036 + cFilAnt + " " + CRLF + ;	//"Filial : "
												STR0037 + DtoC(dDataVir) + " " + ;	//"Ultima Virada : xx/xx/xx"
												STR0038 + DtoC(dUltDepr)				//"Ultimo Calculo Depreciacao : xx/xx/xx"
							EndIf
						EndIf
					Else
						cAvisoTit	:= STR0034						//"Atencao"
						cAvisoMsg	:= 	STR0039+;					//"A data da virada anual não encontrada e o parametro MV_ATFRSLD esta ativo. Verifique! "
						STR0040+Space(50)+CRLF+;	//"No Ativo, a virada ocorre após o cálculo de 31 de Dezembro. "
						STR0036+ cFilAnt+" "		//"Filial : "
					EndIf

					If !Empty(cAvisoTit + cAvisoMsg)
						If IsBlind()
							LogRecord( cAvisoMsg )
						Else
							Aviso(cAvisoTit, cAvisoMsg, {"Ok"})
						EndIf
						cAvisoTit := ""
						cAvisoMsg := ""
						Loop
					EndIf
				EndIf

				nTxVar 	:= Round( RecMoeda(dDataBase,Val(cMoedaAtf)) / RecMoeda(dUltProc,Val(cMoedaAtf)),3) - 1

				If !AFA050Valid( cMoedaAtf, lAjustInf, dUltProc, cFilDe, cFilAte, lCheck070)
					Loop
				Else
					Begin Transaction
					lFirst 		:= .F. //CONTROLE SOMENTE PARA SN? COMPARTILHADO

						cAliasSn3	:= "SN3SQL"
						cAliasSn1	:= "SN3SQL"
						aStru		:= SN3->(DbStruct())

						cFiltro := "SELECT N1_DTBLOQ, N1_AQUISIC, N1_PATRIM, N1_FILIAL, N1_CBASE, N1_ITEM"

						If cPaisLoc == "ARG"
							cFiltro += ", N1_CONSAB"
						EndIf

						If  Val(cMoedaAtf) <= 9
							cFiltro += ", N3_FILIAL, N3_CBASE, N3_ITEM, N3_BAIXA, N3_CCONTAB, N3_AQUISIC,N3_TPSALDO, N3_TXDEPR" + cMoedaAtf
						Else
							cFiltro += ", N3_FILIAL, N3_CBASE, N3_ITEM, N3_BAIXA, N3_CCONTAB, N3_AQUISIC,N3_TPSALDO, N3_TXDEP" + cMoedaAtf
						EndIf
						cFiltro += ", N3_VMXDEPR "

						If Val(cMoedaAtf) <= 9
							cFiltro += ", N3_VRDACM" + cMoedaAtf
							cFiltro += ", N3_VRDMES" + cMoedaAtf   													//para calculdo de depreciacao maxima.

						Else
							cFiltro += ", N3_VRDAC" + cMoedaAtf
							cFiltro += ", N3_VRDME" + cMoedaAtf   													//para calculdo de depreciacao maxima.

						EndIf
						cFiltro += ", N3_VORIG" + cMoedaAtf
						cFiltro += ", N3_TXDEPR" + Str(nMoedaVMax,1,0)
						cFiltro += ", N3_VORIG" + Str(nMoedaVMax,1,0)
						cFiltro += ", N3_VRDACM" + Str(nMoedaVMax,1,0)
						cFiltro += ", N3_VRDMES" + Str(nMoedaVMax,1,0)
						cFiltro += ", SN3.R_E_C_N_O_ RECNO "
						cFiltro += ", SN1.R_E_C_N_O_ N1_RECNO "
						cFiltro += "FROM " + RetSqlName("SN3") + " SN3,"
						cFiltro += 			RetSqlName("SN1") + " SN1 "
						cFiltro += "WHERE "
						cFiltro += "N3_FILIAL = '" + xFilial("SN3") + "' AND "
						cFiltro += "( N3_DTBAIXA = ' ' OR (N3_DTBAIXA BETWEEN '" + Substr(Dtos(dDatabase),1,6) + "01" + "' AND '"+Dtos(dDataBase)+"' )) AND "
						cFiltro += "( N3_BAIXA < '1' OR (N3_BAIXA >= '1' AND N3_NOVO = '1')) AND "
						cFiltro += "N3_CCONTAB <> '" + Space(Len(SN3->N3_CCONTAB)) + "' AND "
						cFiltro += "N3_CDEPREC <> '" + Space(Len(SN3->N3_CDEPREC)) + "' AND "
						cFiltro += "N3_CCDEPR  <> '" + Space(Len(SN3->N3_CCDEPR )) + "' AND "
						cFiltro += "N3_AQUISIC <= '" + DTOS(dDataBase) + "' AND "
						cFiltro += "SN3.N3_TIPO NOT IN ('03','13') AND "
						If lIsRussia
							cFiltro += "SN3.N3_OPER = '1' AND " // CAZARINI - 21.01.2017 - Asset Into Operation?
							cFiltro += "SN3.N3_TPDEPR <> 'N' AND "
						EndIf
						//Alterado por Fernando Radu Muscalu em 23/11/2011 - Compatibilizacao para o Brasil
						If lAtfctap
							If cPaisLoc == "BOL"
								cFiltro += "SN3.N3_TPDEPR NOT IN ('4','8','9') AND "
							Else
								cFiltro += "SN3.N3_TPDEPR NOT IN ('4','5','8','9') AND "
							EndIf
						EndIf

						cFiltro += "SN3.D_E_L_E_T_=' ' AND "
						cFiltro += "N1_FILIAL='" + xFilial("SN1") + "' AND "
						cFiltro += "N1_CBASE = N3_CBASE AND "
						cFiltro += "N1_ITEM  = N3_ITEM  AND "
						/*
						Verifica as acoes para itens bloqueados */
						If (cPaisLoc == "BRA") .Or. (!lDeprBlq .And. !lCorrBlq)
							cFiltro += "(N1_DTBLOQ = ' ' OR "
							cFiltro += "N1_DTBLOQ < '"+ Dtos(dDataBase) + "') AND "
							cFiltro += "N1_STATUS <> '2' AND N1_STATUS <> '3' AND "
							If SN1->(Fieldpos("N1_BLQDEPR")) > 0 .AND. cPaisLoc == "BRA"
								cFiltro += "N1_BLQDEPR <> 'S' AND " //Validação CPC31 Bens com motivo para venda
							Endif
						Endif
						/*-*/
						cFiltro += "SN1.D_E_L_E_T_=' '"

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Este ponto foi criado para quem utiliza outros tipos de bens,           ³
						//³(Depreciacao Negativa, Depreciacao Acelerada, etc) e deseja mudar a     ³
						//³ordem para ordenar por conta.                                           ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If existblock("ATF50ORD")
							cFiltro += "ORDER BY " + SqlOrder(ExecBlock("ATF50ORD"))
						else
							cFiltro += "ORDER BY " + SqlOrder("N3_CBASE+N3_ITEM+N3_TIPO")
						endif

						cFiltro := ChangeQuery( cFiltro )

						dbUseArea(.T.,"TOPCONN",TcGenQry(,,cFiltro),cAliasSn3,.T.,.T.)
						aEval(aStru, {|e|	IIf(	FieldPos(e[1]) > 0 .And. e[2]!= "C",;
						TCSetField(cAliasSn3, e[1], e[2],e[3],e[4]),;
						Nil)})
						TCSetField( cAliasSn3, "N1_AQUISIC", "D" )

					If !IsBlind() .And. lCheckObj
						oSelf:SetRegua2(2)
						oSelf:IncRegua2(LTrim(Str(1)))
					EndIf

					aRusModer	:= {}
					If lIsRussia
						aRusModer	:= RU01T06_R1MonthModernization()
					EndIf

					Do While (cAliasSn3)->(!Eof()) .And. (cAliasSn3)->N3_FILIAL == xFilial("SN3")
						
						//Quantidade de registros para metricas
						If __lMetric
							nQtdReg ++
						EndIf

						lBemBloq := .F.
						cChave := (cAliasSn3)->(N3_CBASE+N3_ITEM)
						If !IsBlind() .And. lCheckObj
							If oSelf:lEnd
								Exit
							EndIf
						EndIf

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Ponto de entrada que permite a selecao de determinados produtos para ³
						//³ nao depreciar no calculo de depreciacao mensal                       ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If ExistBlock("AF050FPR")
							If ExecBlock("AF050FPR",.F.,.F.,{cChave})
								DbSelectarea(cAliasSn3)
								(cAliasSn3)->( DbSkip() )
								Loop
							EndIf
						EndIf

						// Posiciona no arquivo original para gravacao dos dados da depreciacao
						dbSelectArea("SN1")
						MsGoto((cAliasSn1)->N1_RECNO)
						dbSelectArea("SN3")
						MsGoto((cAliasSn3)->RECNO)
						dbSelectArea("SN4")
						SN4->(dbSetOrder(4)) //N4_CBASE+N4_ITEM+N4_TIPO+N4_OCORR
						
						//validação para ver se o ativo foi  transferido, se sim só deprecia a filial destino 
						// 3 Transferência de
						If !Empty(SN3->N3_DTBAIXA) .And. SN4->(DbSeek(xFilial("SN4")+SN3->(N3_CBASE+N3_ITEM+N3_TIPO)+"03"))
							(cAliasSn3)->( DbSkip() )
							Loop
						EndIf
						If lIsRussia
							/*
							 * Russian criteria for depreciation
							 * 1 - In operation (FI-FA-26-4)
							 * 2 - Not in conservation (FI-FA-26-24)
							*/
							If 	SN3->N3_OPER <> "1" .Or. ;
								! RU01XFN004() // Old A050Conservation
									DbSelectarea(cAliasSn3)
									(cAliasSn3)->( DbSkip() )
									Loop
							EndIf
						EndIf

						If lCalcTxPer .And. cPaisLOC == "PTG" // Novo calculo pelo conteudo dos campos no cadastro
							cTpCalc :=  Iif(!Empty(SN3->N3_TPDEPR), SN3->N3_TPDEPR, Iif(Empty(SN1->N1_TPDEPR),"1", SN1->N1_TPDEPR) )
							If cTpCalc == '1'
								cTCalcAF:= "0"
							Else
								cTCalcAF:= "1"
							EndIf
						Endif

						DbSelectArea(cAliasSn3)	// Area da Query

						If	( !Empty(SN3->N3_DTBAIXA) ) .and.;
						( Month(SN3->N3_DTBAIXA) < Month(dDatabase) ) .and.;
						( Year(SN3->N3_DTBAIXA) <= Year(dDatabase) ) 
							RecLock("SN3")
							// *******************************
							// Controle de multiplas moedas  *
							// *******************************
							AtfMultMoe("SN3","N3_VRDMES",{|x| 0 })
							
							SN3-> N3_VRCMES1 	:= 0
							SN3-> N3_VRCDM1		:= 0
							MsUnlock()

							(cAliasSn3)->( dbSkip() )
							Loop
						EndIf

						//Para tipo 15, somente haverá depreciacao se estiver relacionado a um tipo 10
						If lMargem .and. SN3->N3_TIPO == "15"
							If !(AF050T10( SN3->N3_CBASE,SN3->N3_ITEM,SN3->N3_TPSALDO ))
								DbSelectarea(cAliasSn3)
								(cAliasSN3)->( DbSkip() )
								Loop
							EndIf
						Endif

						// Inicializacao de Variaveis
						cChave		:= SN3->(N3_CBASE+N3_ITEM)
						cMesAno		:= StrZero(Month(dDataBase),2)+'/'+ Subs(StrZero(Year(dDataBase),4),3,2)
						dInDepr		:= SN3->N3_DINDEPR
						nDiferenca	:= 0
						nDepr1		:= 0
						nTxVar		:= 0

						If Val( SN3->N3_BAIXA ) != 0
							// Calcula a depreciacao para itens baixados, apenas uma vez.
							If SN3->N3_NOVO == "1" .AND. !(cPaisLoc $ "BOL|PTG")  // Item gerado pela baixa do ATFA035 com cálculo proporcional na aquisição
								// Obs. Para Portugal nao se deve gerar depreciacao no mes da baixa do bem
								// Monta as bases de calculo para a depreciacao de itens baixados
								aBases := Af050MonBas(SN3->N3_CBASE, SN3->N3_ITEM, SN3->N3_TIPO, SN3->N3_BAIXA, SN3->N3_SEQ)

								// Encontra a baixa no SN4, para encontrar a proporcao baixada e efetuar o calculo
								// da depreciacao da baixa.
								SN4->(dbSetOrder(1))

								SN4->( MsSeek(	xFilial("SN4") +;
								SN3->(	N3_CBASE +;
								N3_ITEM +;
								N3_TIPO +;
								DTOS(N3_DTBAIXA) +;
								"01" +;
								N3_SEQ ) ) )

								aDepre := CalcDepre(	SN3->N3_DTBAIXA ,;
								SN3->N3_DTBAIXA ,;
								SN3->N3_DINDEPR ,;
								SN3->N3_TIPO    ,;
								aBases			,;
								cMoedaAtf		,;
								SN4->N4_QUANTD	,; // Qtde. Baixada
								SN3->N3_QUANTD	,; // Qtde. Original na data da baixa
								lCalcula		,;
								nMVVALCORR 		,;
								(cAliasSn1)->N1_PATRIM,;
								aRusModer)

								// *******************************
								// Controle de multiplas moedas  *
								// *******************************
							    aValDepr := AtfMultMoe(,,{|x| aDepre[1][x] })

								nValCorr  := aDepre[2]
								nValCorDep := aDepre[3]
							Else
								dbSelectArea(cAliasSn3)
								RecLock("SN3")
								// Se for um item gerado pelo ATFA035, marca que ja foi calculada depreciacao
								// para nao ser calculada no proximo calculo (no item baixado
								/*If  SN3->N3_NOVO == "1"
									SN3->N3_NOVO := "2"
								EndIf*/
								MsUnlock()
								(cAliasSn3)->(dbSkip())
								Loop
							Endif
						Else
							// Verifica a Data de Bloqueio e o
							/*If cPaisLoc == "BOL"
								// Para Bolivia, se o item ja foi totalmente depreciado, não pode sofrer baixas.
								If !Empty(SN3->N3_FIMDEPR)
									dbSelectArea(cAliasSn3)
									(cAliasSn3)->( dbSkip() )
									Loop
								Endif
							EndIf*/

							// Verifica a Data de Bloqueio e o indice de Correcao Monetaria
							AtfBloqueio((cAliasSn3)->(N3_CBASE + N3_ITEM), @(dBloqueio := Ctod("")))
							lBemBloq := (!Empty( dBloqueio ) .And. Left(Dtos(dBloqueio), 6) > Left(Dtos(dDataBase), 6))
							If	!Empty( dBloqueio ) .and.;
							Left(Dtos(dBloqueio), 6) > Left(Dtos(dDataBase), 6) .and.;
							!ValIndCM( @dInDepr, @nTxVar )
								dbSelectArea(cAliasSn3)
								(cAliasSn3)->( dbSkip() )
								Loop
							Endif

							// Posiciona o arquivo do Ativo Imobilizado
							SN1->(	MsSeek(xFilial("SN1") + SN3->N3_CBASE + SN3->N3_ITEM))

							If SN1->N1_STATUS $ "2|3"
								lBemBloq := .T.
								If (!lDeprBlq .And. !lCorrBlq)
									SN3->( dbSetOrder(1) )
									SN3->( dbSkip() )
									Loop
								Endif
							EndIf

							dbSelectarea("SN3")
							If cPaisLoc == "BRA"
								// Define a Taxa para o Calculo da Correcao Monetaria
								aTxMedia := GetTxCM( nDias, cMoedaAtf, la30Embra )
							Else
								If  !lBemBloq .Or. lCorrBlq
									// Define a Taxa para o Calculo da Correcao Monetaria
									aTxMedia := GetTxCM( nDias, cMoedaAtf, la30Embra )
								Else
									Afill(aTxMedia,0)
								Endif
							Endif
							/*-*/
							If (cPaisLoc == "BRA") .Or. (!lBemBloq .Or. lDeprBlq)
								If SN3->N3_TIPO == "51"
									SomaDigitos(dDataBase, dINDEPR,SN3->N3_PERDEPR , SN3->N3_CALCDEP )
								ElseIf  SN3->N3_TIPO == "52"
									ReduzSaldos( SN3->N3_VLSALV1 , SN3->N3_VORIG1, SN3->N3_PERDEPR , SN3->N3_VRDACM1 )
								ElseIf SN3->N3_TIPO == "53"
									SomaDosAnos( SN3->N3_PERDEPR )
								ElseIf SN3->N3_TIPO == "54"
									TaxPUnidad( SN3->N3_PRODMES,SN3->N3_PRODANO )
								Else
									// Define a Taxa para o Calculo da Cota de Depreciacao
									GetTxDepr( @nTxPerdida, aRusModer )
								endif
								// Calcula a Cota de Depreciacao
								CotaDepr(aTaxaMes,aValDepr , SN3->N3_TIPO == "52",  nMoedaVMax, aRusModer)
							Else
								aValDepr := AtfMultMoe(,,{|x| 0 })
								aTaxaMes := AtfMultMoe(,,{|x| 0})
							Endif
							/*-*/
							If !Empty( SN3->N3_CCORREC )
								If (cPaisLoc == "BRA") .Or. (!lBemBloq .Or. lCorrBlq)
									// Calcula a Correcao Monetaria
									CalculoCM( cMoedaAtf, la30Embra )
								Else
									nValCorr := 0
									nValCorDep := 0
								Endif
							EndIf
						EndIf

						// Verificação da classificação de Ativo se sofre depreciação
						lAtClDepr := AtClssVer((cAliasSn1)->N1_PATRIM )

						//Verificacoes
						If !( lAtClDepr .OR. EMPTY((cAliasSn1)->N1_PATRIM) ) .or. ( dInDepr > dDataBase )
							// *******************************
							// Controle de multiplas moedas  *
							// *******************************
							aValDepr := AtfMultMoe(,,{|x| 0 })
							nValCorr := 0
							nValCorDep := 0
						EndIf

						If Empty(SN3->N3_CCORREC)
							nValCorr := 0
						EndIf

						If Empty(SN3->N3_CDESP)
							nValCorDep := 0
						EndIf

						// Verifica se a depreciação acelerada foi calculada dentro do mes.
						lAcelMes := (Left(DTOS(SN3->N3_DTACELE),6) == Left(DTOS(dDataBase),6))

						//Area de Inclusao de Movimentacoes
						If lConta .And. (cAliasSn1)->N1_PATRIM == "C" .And. nValCorr != 0
							// *******************************
							// Controle de multiplas moedas  *
							// *******************************
							aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,nValCorr,0) })

							// Atualiza arquivo Movimenta‡”es (Tipo da Conta: Correcao da Conta de Capital Social)
							IncMovSN4( "07" /*cOcorr*/, aValorMoed , "6" /*cTipoCNT*/, cCodCusto, cContaCap,@cIdMov )
							A050Contab( lPadrao , lChmLpd , lOnOff , lLP_Rat , lHeadExist , cLoteAtf , @lHdlProva , @nHdlPrv , @cArquivo , @nTotal )
						EndIf

						If !Empty( SN3->N3_CCORREC ) .and. nValCorr # 0
							//Codigo do Centro de Custo
							GetCodCusto("CORRECAO", @cCodCusto, "820" /*cPadrao*/, {nValCorr,0,0,0,0} )
							// *******************************
							// Controle de multiplas moedas  *
							// *******************************
							aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,nValCorr,0) })

							// Atualiza arquivo movimenta‡„o (Tipo da Conta: Correcao do Bem)
							IncMovSN4( "07" /*cOcorr*/, aValorMoed , "2" /*cTipoCNT*/, cCodCusto, cContaCap,@cIdMov )
							A050Contab( lPadrao , lChmLpd , lOnOff , lLP_Rat , lHeadExist , cLoteAtf , @lHdlProva , @nHdlPrv , @cArquivo , @nTotal )
							// Atualiza arquivo movimenta‡„o (Tipo da Conta: Conta do Bem)

							// *******************************
							// Controle de multiplas moedas  *
							// *******************************
							aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,nValCorr,0) })

							IncMovSN4( "07" /*cOcorr*/, aValorMoed , "1" /*cTipoCNT*/, cCodCusto, cContaCap,@cIdMov )
							A050Contab( lPadrao , lChmLpd , lOnOff , lLP_Rat , lHeadExist , cLoteAtf , @lHdlProva , @nHdlPrv , @cArquivo , @nTotal )
						EndIf

						// *******************************
						// Controle de multiplas moedas  *
						// *******************************
						nTotVal := 0
						AtfMultMoe(,,{|x| nTotVal += aValDepr[x] })

						If	nTotVal # 0 .and.;
						dInDepr <= dDataBase
							// Atualiza Movimenta‡”es (Tipo da Conta: Deprecia‡„o Acumulada)
							If !lIsRussia .Or. lSN4Mult
								IncMovSN4(	"" /*cOcorr*/,;
								aValDepr,;
								"4" /*cTipoCNT*/,;
								cCodCusto,;
								cContaCap ,@cIdMov)
								A050Contab( lPadrao , lChmLpd , lOnOff , lLP_Rat , lHeadExist , cLoteAtf , @lHdlProva , @nHdlPrv , @cArquivo , @nTotal )
							EndIf
							
							If nValCorDep != 0 .And. !Empty( SN3->N3_CDESP )
								// *******************************
								// Controle de multiplas moedas  *
								// *******************************
								aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,nValCorDep,0) })
								
								// Atualiza Movimentacoes (Tipo da Conta: Depreciacao Acumulada)
								If !lIsRussia .Or. lSN4Mult
									IncMovSN4("08" /*cOcorr*/, aValorMoed , "4" /*cTipoCNT*/, cCodCusto, cContaCap,@cIdMov)
									A050Contab( lPadrao , lChmLpd , lOnOff , lLP_Rat , lHeadExist , cLoteAtf , @lHdlProva , @nHdlPrv , @cArquivo , @nTotal )
								EndIf

								If cPaisLoc == "CHI" .and. nValCorDAC != 0 .And. !Empty(SN3->N3_CDESP)
									// *******************************
									// Controle de multiplas moedas  *
									// *******************************
									aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,nValCorr,0) })

									// Atualiza Movimentacoes (Tipo da Conta: depr acum do exercicio anterior)
									IncMovSN4("08" /*cOcorr*/, aValorMoed , "8" /*cTipoCNT*/, cCodCusto, cContaCap,@cIdMov)
									A050Contab( lPadrao , lChmLpd , lOnOff , lLP_Rat , lHeadExist , cLoteAtf , @lHdlProva , @nHdlPrv , @cArquivo , @nTotal )
								EndIf
							EndIf

							// Codigo do Centro de Custo
							GetCodCusto(	"DEPRECIACAO", @cCodCusto, "820" /*cPadrao*/, aValDepr )
							// Atualiza arquivo Movimenta‡”es (Tipo da conta: Despesa Deprecia‡„o)
							IncMovSN4(	"" /*cOcorr*/,;
							aValDepr,;
							"3" /*cTipoCNT*/,;
							cCodCusto,;
							cContaCap,@cIdMov )
							A050Contab( lPadrao , lChmLpd , lOnOff , lLP_Rat , lHeadExist , cLoteAtf , @lHdlProva , @nHdlPrv , @cArquivo , @nTotal )

							//Atualiza as informações do projeto de imobilizado
							AF050AtProj(SN3->N3_CBASE,SN3->N3_ITEM,SN3->N3_TIPO,SN3->N3_TPSALDO,aValDepr)

						EndIf

						If nValCorDep # 0 .and. dInDepr <= dDataBase
							// *******************************
							// Controle de multiplas moedas  *
							// *******************************
							aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,nValCorDep,0) })
							
							If !lIsRussia .Or. lSN4Mult
								// Atualiza arquivo Movimenta‡”es (Tipo da Conta: Correcao da Deprecia‡„o Acumulada)
								IncMovSN4("08" /*cOcorr*/, aValorMoed , "5" /*cTipoCNT*/, cCodCusto, cContaCap,@cIdMov)
								A050Contab( lPadrao , lChmLpd , lOnOff , lLP_Rat , lHeadExist , cLoteAtf , @lHdlProva , @nHdlPrv , @cArquivo , @nTotal )
							EndIf
						EndIf

						If cPaisLoc == "CHI" .and. nValCorDAC # 0 .and. dInDepr <= dDataBase
							// Atualiza arquivo Movimenta‡”es (Tipo da Conta: Correcao da Deprecia‡„o)
							// *******************************
							// Controle de multiplas moedas  *
							// *******************************
							aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,nValCorDAC,0) })

							IncMovSN4("08" /*cOcorr*/, aValorMoed , "9" /*cTipoCNT*/, cCodCusto, cContaCap,@cIdMov)
							A050Contab( lPadrao , lChmLpd , lOnOff , lLP_Rat , lHeadExist , cLoteAtf , @lHdlProva , @nHdlPrv , @cArquivo , @nTotal )
						EndIf
						// Area de Inclusao de Movimentacoes

						// Grava valores de Deprecia‡„o da Corre‡„o ( ARG )
						If cPaisLoc == 'ARG' .AND. SN3->N3_VDPCOMM > 0
							nN3VDPCOMM  := 0
							If nValCorr > 0
								nN3VDPCOMM = Round(Abs(SN3->N3_VDPCOMM + nValCorr/nMesCalc), X3Decimal("N3_VDPCOMM"))
							Else
								nN3VDPCOMM = Round(Abs(SN3->N3_VDPCOMM), X3Decimal("N3_VDPCOMM"))
							EndIf
							If !Empty(SN3->N3_CDPCOMM)
								// *******************************
								// Controle de multiplas moedas  *
								// *******************************
								aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,nN3VDPCOMM,0) })

								IncMovSN4("17" /*cOcorr*/, aValorMoed , "7" /*cTipoCNT*/, cCodCusto, cContaCap,@cIdMov)
								A050Contab( lPadrao , lChmLpd , lOnOff , lLP_Rat , lHeadExist , cLoteAtf , @lHdlProva , @nHdlPrv , @cArquivo , @nTotal )
							EndIf
							nN3VDPCOMA := 0
							nN3VDPCOMA := Round(Abs(SN3->N3_VDPCOMA + nN3VDPCOMM), X3Decimal("N3_VDPCOMM"))

							If !Empty(SN3->N3_CDPCOMA)
								// *******************************
								// Controle de multiplas moedas  *
								// *******************************
								aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,nN3VDPCOMA,0) })

								IncMovSN4("18" /*cOcorr*/, aValorMoed , "8" /*cTipoCNT*/, cCodCusto, cContaCap,@cIdMov)
								A050Contab( lPadrao , lChmLpd , lOnOff , lLP_Rat , lHeadExist , cLoteAtf , @lHdlProva , @nHdlPrv , @cArquivo , @nTotal )
							EndIf
						EndIf
						//Grava valores de Deprecia‡„o da Corre‡„o ( ARG )

						// Atualiza os valores de Deprecia‡„o e Corre‡„o Monetaria no SN3
						// Pesquisa Depreciacoes de aceleracao antes do travamento do SN3
						nSldAcelM1 := GetSldAcel( '1' )
						nSldAcelMP := GetSldAcel( cMoedaAtf ) // Moeda do Ativo
						AtzSldSN3(	aValDepr,;
						nVarIPC,;
						nN3VDPCOMM,;
						nValCorr,;
						nSldAcelM1,;
						nSldAcelMP,;
						nCalcRes,;
						@aPFimDepr,;
						nMesCalc,;
						nMoedaVMax,;
						lCheck070 )
						// Atualiza os valores de Deprecia‡„o e Corre‡„o Monetaria no SN3

						// Acumula a depreciacao do item normal
						If cPaisLoc == "BRA" .And. SN3->N3_TIPO $ "01*10*16*17"
							Aadd(	aTotDeprec, {	SN3->N3_TIPO,;
							SN3->N3_CBASE,;
							SN3->N3_ITEM,;
							SN3->N3_VRDACM1 + SN3->N3_VRCDA1,;
							SN3->N3_VORIG1 + SN3->N3_AMPLIA1 } )
							aRegSn301	:= aRegToMemory("SN3")
						EndIf

						If cPaisLoc == "BRA" .And. SN3->N3_TIPO == "08"
							aRegSn308	:= aRegToMemory("SN3")
						EndIf

						If lCalcTxPer .And. cPaisLoc == "PTG"	// Taxa Perdida para PORTUGAL
							//--------------------------------------------------------------------------------
							//A lei portuguesa permite a utilização de taxas mínimas e máximas de amortização.
							//As empresas poderão optar por amortizar os seus bens recorrendo a taxas mínimas
							//sendo estas metade das taxas máximas apresentadas na tabela de grupos homogêneos.
							//Se em determinados exercícios, forem utilizadas taxas de amortização inferiores
							//às taxas mínimas, a diferença entre estas e as taxas praticadas não pode constituir
							//custo de exercícios seguintes peloo que se consideram assim taxas perdidas no exercício.

							Afill( aTxMoedas,  0)   // Definicao da Taxa de Depreciação/SN3
							Afill( aValTxPerd, 0)	// Definicao da Taxa perdida acumulada/SN3
							Afill( aValTxAcuP, 0)	// Definicao do Valor da taxa perdida acumulada/SN3

							// Refaz sem a opção do uso da tabela SNT/Taxas de Depreciação
							for i := 1 to __nQuantas
								aTxMoedas[ i ] := SN3->&(IIf(i>9,'N3_TXDEP','N3_TXDEPR') + Alltrim(Str(i)) )   // Taxa Perdida
							next i

							cNomTxFisc	:= IIf(Val( cMoedaATF )>9,"NG_TXDEP","NG_TXDEPR") + cMoedaATF

							If aTxMoedas[ Val( cMoedaATF ) ] < (SNG->&(cNomTxFisc )) / 2
								// A taxa perdida calculada eh armazena em um unico elemento do array
								aValTxperd[nMFiscal] := (( SNG->&( IIf(Val( cMoedaATF )>9,"NG_TXDEP","NG_TXDEPR") + cMoedaATF ) / 2 ) - aTxMoedas[ nMFiscal ] )/12
								aValTxAcuP[nMFiscal] := Round( SN3->&("N3_VORIG"+cMoedaATF) * (aValTxperd[nMFiscal]/100), X3Decimal("N3_VLACTXP") )

								If AtFimDeprF()
									SN3->( RecLock('SN3') )
									SN3->N3_TXPERDA += aValTxperd[nMFiscal]
									SN3->N3_VLACTXP += aValTxAcuP[nMFiscal]
									MsUnlock( )

									IncMovSN4(	"21" /*cOcorr*/,;
									aValTxPerd,;
									"3" /*cTipoCNT*/,;
									"",;
									"" ,@cIdMov)
									A050Contab( lPadrao , lChmLpd , lOnOff , lLP_Rat , lHeadExist , cLoteAtf , @lHdlProva , @nHdlPrv , @cArquivo , @nTotal )
									IncMovSN4(	"21" /*cOcorr*/,;
									aValTxAcuP,;
									"4" /*cTipoCNT*/,;
									"",;
									"" ,@cIdMov)
									A050Contab( lPadrao , lChmLpd , lOnOff , lLP_Rat , lHeadExist , cLoteAtf , @lHdlProva , @nHdlPrv , @cArquivo , @nTotal )
								Endif
							EndIf
						Endif

						If	cPaisLoc == "BRA" .and.;
						SN3->N3_TIPO == "08" .and.;
						Len(aTotDeprec) > 0 .and.;
						Len(aRegSn301) > 0 // Depreciacao incentivada positiva

							// Se estiver em um item de depreciacao incentivada, verifica se deve gerar o calculo reverso (negativo)
							// A condicao para gerar o calculo reverso, eh quando o Valor da Depreciacao acumulada do item de depreciacao
							// incentivada com o total da depreciacao do item normal (01) for maior ou igual ao valor original do item 01
							// para comecar a zerar o incentivo. O calculo reverso sera efetuado ate que o valor da depreciacao acumulada
							// do item 09 9 (incentivada negativa) seja igual o valor da depreciacao acumulada do item 08 (incentivada positiva)
							If (SN3->N3_VRDACM1 + SN3->N3_VRCDA1 + aTotDeprec[1][4]) >= aTotDeprec[1][5] .And.;
							NEWSN3->(!MsSeek(xFilial("SN3") + SN3->(N3_CBASE+N3_ITEM+"09"))) // Gera o calculo reverso apenas uma vez
								// Gravo os dados do item (copiando os dados do item 01)
								RecLock("NEWSN3", .T. )
								For nI := 1 To Len(aRegSn301)
									NEWSN3->&(aRegSn301[nI][NOMEDOCAMPO]) := aRegSn301[nI][CONTEUDODOCAMPO]
								Next
								// Altera os campos que nao sao comuns
								NEWSN3->N3_TIPO		:= "09"
								For ni := 1 To 5
									NEWSN3->&("N3_VRDBAL"+Str(ni,1)) 	:= 0
									NEWSN3->&("N3_VRDMES"+Str(ni,1)) 	:= 0
									NEWSN3->&("N3_VRDACM"+Str(ni,1)) 	:= 0
									// Copia o valor original do item 08
									NEWSN3->&("N3_VORIG"+Str(ni,1))		:= aRegSn308[aScan(aRegSn308, {|e| Alltrim(e[NOMEDOCAMPO]) == Alltrim("N3_VORIG"+Str(ni,1))})][CONTEUDODOCAMPO]
								Next
								// Se o grupo estiver preenchido,usar a taxa e demais dados contabeis do grupo, senao os dados
								// contabeis ja foram utilizados a partir do tipo 01
								If !Empty(SN1->N1_GRUPO) .And.;
								SNG->(DbSeek(xFilial("SNG") + SN1->N1_GRUPO))
									For nI := 1 To Len(aEntidade)
										// Procura o campo do no SN3, se o campo do SNG estiver preenchido e nao
										// for o campo de filial
										If NEWSN3->(FieldPos("N3_" + Subs(aEntidade[ni], 4))) <> 0 .And.;
										!Empty(&("SNG->NG_" + Subs(aEntidade[ni], 4))) .And.;
										! "_FILIAL" $ Subs(aEntidade[ni], 4)
											NEWSN3->&("N3_" + Subs(aEntidade[ni], 4)) := &("SNG->NG_" + Subs(aEntidade[ni], 4))
										EndIf
									Next
								EndIf
								NEWSN3->N3_VRCMES1 	:= 0
								NEWSN3->N3_VRCACM1 	:= 0
								NEWSN3->N3_VRCDA1	:= 0
								NEWSN3->N3_VRCBAL1 	:= 0
								NEWSN3->N3_HISTOR 	:= "DEPRECIACAO ACEL. INCENTIVADA REVERSA"
								NEWSN3->( msUnlock() )
								NEWSN3->(FkCommit())
							EndIf
						EndIf

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Atualiza Saldos                                                        ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						dbSelectarea( "SN3" )
						If Year(dDataBase) != 1996
							nTaxaDepr := aTxMedia[ Val( cMoedaAtf ) ]
						EndIf

						// Verificação da classificação de Ativo se sofre depreciação
						lAtClDepr := AtClssVer((cAliasSn1)->N1_PATRIM)

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Tratamento de correcao do bem. Criado N5_TIPO = "P" para tratar as  ³
						//³ correcoes de bens com N1_PATRIM $ "SCA". Nao ha necessidade de tipo ³
						//³ novo p/ a corr da depr., porque bens com N1_PATRIM $ "SCA" nÆo so-  ³
						//³ frem depreciacao.                                                   ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If lAtClDepr .OR. (cAliasSn1)->N1_PATRIM $ " P"
							cTipoCorr := "6"		// N5_TIPO - Correcao Monetaria para bens com N1_PATRIM = " P"
						Else
							cTipoCorr := "O"		// N5_TIPO - Correcao de bens com N1_PATRIM $ "SCA"
						EndIf

						//Atualiza‡„o de saldos
						// *******************************
						// Controle de multiplas moedas  *
						// *******************************
						aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,nValCorr,0) })

						If lSN3Saldo
							cTpSaldo := SN3->N3_TPSALDO
						EndIf

						ATFSaldo( SN3->N3_CCORREC, dDataBase, cTipoCorr, nValCorr  , 0        , 0        , 0        , 0        , "+", nTaxaCorr, SN3->N3_SUBCCOR,, SN3->N3_CLVLCOR, SN3->N3_CCCORR , "2", aValorMoed,cTpSaldo )
						ATFSaldo( SN3->N3_CCONTAB, dDataBase, cTipoCorr, nValCorr  , 0        , 0        , 0        , 0        , "+", nTaxaCorr, SN3->N3_SUBCCON,, SN3->N3_CLVLCON, SN3->N3_CUSTBEM, "1", aValorMoed,cTpSaldo )

						If SN3->N3_TIPO $ cTipoGerenc
							cTipoImob := "Y" // Depreciacao Gerencial
						ElseIf SN3->N3_TIPO =="09"
							cTipoImob := "L" // Depreciacao Incentivada Negativa
						ElseIf SN3->N3_TIPO =="08"
							cTipoImob := "K" // Depreciacao Incentivada Positiva
						Else
							cTipoImob := "4"
						EndIf

						ATFSaldo( SN3->N3_CDEPREC, dDataBase, cTipoImob  , aValDepr[1] , aValDepr[2], aValDepr[3], aValDepr[4], aValDepr[5], "+", nTaxaDepr, SN3->N3_SUBCDEP,, SN3->N3_CLVLDEP, SN3->N3_CCDESP , "3", aValDepr, cTpSaldo )
						ATFSaldo( SN3->N3_CCDEPR , dDataBase, cTipoImob  , aValDepr[1] , aValDepr[2], aValDepr[3], aValDepr[4], aValDepr[5], "+", nTaxaDepr, SN3->N3_SUBCCDE,, SN3->N3_CLVLCDE, SN3->N3_CCCDEP , "4", aValDepr, cTpSaldo )

						// *******************************
						// Controle de multiplas moedas  *
						// *******************************
						aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,nValCorDep,0) })

						ATFSaldo( SN3->N3_CDESP  , dDataBase, "7"                                                              , nValCorDep, 0        , 0        , 0        , 0        , "+", nTaxaCorr, SN3->N3_SUBCDES,, SN3->N3_CLVLDES, SN3->N3_CCCDES , "5", aValorMoed, cTpSaldo)
						ATFSaldo( SN3->N3_CCDEPR , dDataBase, "7"                                                              , nValCorDep, 0        , 0        , 0        , 0        , "+", nTaxaCorr, SN3->N3_SUBCCDE,, SN3->N3_CLVLCDE, SN3->N3_CCCDEP , "4", aValorMoed, cTpSaldo)

						// Atualiza Conta de Correcao do capital social
						If lConta .And. (cAliasSn1)->N1_PATRIM=="C" .And. nValcorr # 0
							// *******************************
							// Controle de multiplas moedas  *
							// *******************************
							aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,nValCorr,0) })

							ATFSaldo( 	cContaCap,;
							dDataBase,;
							cTipoCorr,;
							nValCorr,0,0,0,0,;
							"+",;
							nTaxaCorr,;
							/*cSubConta*/,;
							/*cFil*/,;
							/*cClvl*/,;
							/*cCusto*/,;
							"6" /*cTipoCnt*/, aValorMoed,cTpSaldo)
							PutMv( "MV_CORCAPI", (nCorrec + nValCorr) )
						EndIf
						// Atualiza‡„o de saldos

						// TDN - O ponto de entrada AF050CAL sera chamado logo apos o tratamento de correcao do bem.
						dbSelectArea( "SN3" )
						If lAtfa050
							Execblock("AF050CAL",.F.,.F.)
						EndIf

						// >>> Grava valores de Deprecia‡„o da Corre‡„o ( ARG )
						If nN3VDPCOMM > 0
							If !Empty(SN3->N3_CDPCOMM)
								// *******************************
								// Controle de multiplas moedas  *
								// *******************************
								aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,Round(nN3VDPCOMM, X3Decimal("N3_VDPCOMM")),0) })
								ATFSaldo( SN3->N3_CDPCOMM ,dDataBase,"W",Round(nN3VDPCOMM, X3Decimal("N3_VDPCOMM")),0,0,0,0,"+",nTaxaCorr,,,,, aValorMoed,cTpSaldo )
							EndIf
						EndIf
						If nN3VDPCOMA > 0
							If !Empty(SN3->N3_CDPCOMA)
								// *******************************
								// Controle de multiplas moedas  *
								// *******************************
								aValorMoed := AtfMultMoe(,,{|x| IIf(x=1,Round(nN3VDPCOMA, X3Decimal("N3_VDPCOMA")),0) })
								ATFSaldo( SN3->N3_CDPCOMA ,dDataBase,"W",Round(nN3VDPCOMA, X3Decimal("N3_VDPCOMA")),0,0,0,0,"+",nTaxaCorr,,,,, aValorMoed, cTpSaldo )
							EndIf
						EndIf
						// Grava valores de Deprecia‡„o da Corre‡„o ( ARG )

						// TDN - O ponto de entrada AF050CAL sera chamado logo apos o tratamento de correcao do bem.
						dbSelectArea( "SN3" )
						If lAtfa050
							Execblock("AF050CAL",.F.,.F.)
						EndIf

						If lAf050Ctb
							aRet := Execblock("AF050CTB",.T.,.T., { nHdlPrv, cLoteAtf, cArquivo, nTotal, .T. })	// Retorno do ponto de entrada
							If nHdlPrv = 0					// Handle do arquivo de contabilizacao
								nHdlPrv   := aRet[1]
								cLoteAtf  := aRet[2]		// Permito a mudanca do lote de contabilizacao
								cArquivo  := aRet[3]
								lHdlProva := nHdlPrv > 0
							EndIf
							nTotal   := aRet[4]				// Total do valor contabilizado
							lChmLpd  := aRet[5]				// Indica se deve chama o LP definido
						Else
							lChmLpd	:= .T.
						EndIf

						//Incluido por Fernando Radu Muscalu em 02/05/2011
						//Movimentacao do rateio de despesas de depreciacao da ficha do ativo
						//chamada da funcao que efetua a gravacao da movimentacao
						//ATFRTMOV(cCodigo,cItem,cTipo,cSeq,dDtMov,cIdMov,aValores,lContabil,cOper)
						ATFRTMOV(	SN3->N3_FILIAL,;
						SN3->N3_CBASE,;
						SN3->N3_ITEM,;
						SN3->N3_TIPO,;
						SN3->N3_SEQ,;
						SN4->N4_DATA,;
						SN4->N4_IDMOV,;
						aValDepr,;
						lCtb,;
						"1",;
						nHdlPrv,;
						cLoteATF,;
						@nTotal,;
						SN3->N3_BAIXA,;
						FunName(),;
						"823",;
						lOnOff )
						dbSelectArea(cAliasSn3)
						(cAliasSn3)->( dbSkip() )
						// Mudou de Chave, Zera totalizador da depreciacao
						If N3_CBASE+N3_ITEM != cChave
							aTotDeprec := {}
						EndIf

					EndDo

					If !IsBlind() .And. lCheckObj
						oSelf:IncRegua2(LTrim(Str(2)))
					EndIf

					//Atualiza as contas do Tipo 01
					SetFimDepr( aPFimDepr, dDataBase )

					// Fecha a query
						dbSelectArea(cAliasSn3)
						(cAliasSn3)->( DbCloseArea() )

					// Contabiliza se constar lancamentos pendentes.
					If lPadrao .and. lCTB .And. lOnOff
						If lHdlProva .and. (nTotal > 0) .and. (MV_PAR01 < 3)
							RodaProva( nHdlPrv, nTotal )
							SAVEINTER()
							CA100Incl( cArquivo, nHdlPrv, 1, cLoteATF, lMostra, iif(MV_PAR02 ==1, .T., .F.) )
							RESTINTER()
						EndIf
					EndIf

					// Atualiza o parametro por filial
					AF050AtPar(cFilAnt,dDataBase)

					If __lEAI051
						ATFA051()
					Else
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Integracao Protheus x PimsGraos  ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If SuperGetMV("MV_PIMSINT",.F.,.F.)
							PIMSGerATF(aClone(aSM0),cFildE,cFilAte)
						EndIf
					EndIf

					End Transaction

					If !lOnOff .And. !__lAf050CT    //sempre ver as 2 variaveis as 2 tem q estar .F. para chamar funcao
						A050CONTPROC(SN4->N4_IDMOV) //Função para contabilizar tem q estar apos End Transaction
					EndIf

					// Se o arquivo for compartilhado, processa apenas uma vez
					If Empty(xFilial("SN3"))
						Exit
					EndIf
				EndIf
			EndIf
		Next
	
		// Restaura a filial
		cFilAnt := cFilOld

		dbSelectArea( "SN3" )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Envia para Lancamento Contabil  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If lHdlProva .and. nTotal > 0 .And. mv_par01 < 3 .And. lOnOff
			RodaProva(nHdlPrv,nTotal)
			SAVEINTER()
			cA100Incl(cArquivo,nHdlPrv,1,cLoteAtf,lMostra,Iif(mv_par02==1,.T.,.F.))
			RESTINTER()
		EndIf
	EndIf

	// Limpa o backup do processamento
	af050CtrlF(cTmpCtrl)

	//Registrando no log de processos
	If IsBlind()
		ProcLogAtu( "FIM" )
		LogRecord( 'Process executed normally.' )
	ElseIf lCheckObj
		oSelf:SaveLog("MENSAGEM: Finalizando processo de cálculo de depreciação")
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao PIMS GRAOS ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !__lEAI051
		If SuperGetMV("MV_PIMSINT",.F.,.F.)
			PIMSGerATF(aClone(aSM0),cFildE,cFilAte)
			//Restaura a filial
			cFilAnt := cFilOld
		EndIf
	Endif

	//---------------------------------------
	// Exclusao da tabela temporaria cArqTmp
	//---------------------------------------
	If oATF050TMP <> Nil
		oATF050TMP:Delete()
		oATF050TMP := Nil
	EndIf

	If mv_par04 == 1
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Fecha todos os arquivos e reabre-os de forma compartilhada   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbCloseAll()
		OpenFile(SubStr(cNumEmp,1,2))
	EndIf

	If cPaisLoc == "BRA" .and. Select("NEWSN3") > 0
		NEWSN3->(DbCloseArea())
	EndIf

	dbSelectArea( "SN1" )   // Posiciona no cadastro de bens

	//Grava metricas apenas se nQtdReg e nStart forem maiores que 0
	If __lMetric .And. nQtdReg > 0 .And. nStart > 0

		ATF050Metrics("01" /*cEvent*/, nStart, "001" /*cSubEvent*/, Alltrim(ProcName()) /*cSubRoutine*/)

		ATF050Metrics("02" /*cEvent*/, /* nStart */, "001" /*cSubEvent*/, Alltrim(ProcName()) /*cSubRoutine*/, nQtdReg /* nQtdReg */)

	EndIf

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ SetFimDepr ³ Autor ³ Norberto M Melo       ³ Data ³ 08/05/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Atualiza o registro do tipo 01 ou 07, conforme chave enviada.³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SetFimDepr( aPFimDepr, dDTBase )

	//Salva o ambiente atual
	Local aResult := ACLONE( aPFimDepr )
	Local nRecNoSN3 := SN3->(RecNo())
	Local nOrderSN3 := SN3->( IndexOrd() )
	Local i := 0 // Contador

	DEFAULT dDTBase := CTOD('')

	//Configura o ambiente
	AFILL( aResult, .F. )
	SN3->(DBSetOrder( 1 )) //N3_FILIAL + N3_CBASE + N3_ITEM + N3_TIPO

	if len( aPFimDepr ) > 0
		for i := 1 to Len( aPFimDepr )
			if SN3->(DBSeek( aPFimDepr[i] ))
				SN3->( RecLock('SN3') )
				SN3->N3_FIMDEPR := dDTBase
				aResult[ i ] := .T.
				MsUnlock( )
			endif
		next
	endif

	//Restaura o ambiente obtido na entrada da funcao
	SN3->( DBGoTo( nRecNoSN3 ) )
	SN3->( DBSetOrder( nOrderSN3 ) )

return (aResult)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ GetSldAcel ³ Autor ³ Norberto M Melo       ³ Data ³ 28/04/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna o valor de depreciacao acumulada acelerada da moeda  ³±±
±±³          ³ informada.                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetSldAcel( cMoedaATF )
//Salva o ambiente atual
Local nResult 	:= 0.00
Local aArea		:= GetArea()
Local aAreaSN3	:= SN3->(GetArea())
Local cKey 		:= ''
Local cTipo 	:= SN3->N3_TIPO //Usado para desconsiderar o Tipo Atual, pois sera usado na chamada.

Local cTypes10		:= IIF(lIsRussia,AtfNValMod({1}, "*"),"") // CAZARINI - 24/03/2017 - If is Russia, add new valuations models - main models
Local cTypesNM		:= IIF(lIsRussia,AtfNValMod({3,4}, "*"),"") // CAZARINI - 24/03/2017 - If is Russia, add new valuations models - 17 and 16 models
Local aTypes10		:= {}
Local nTypes10		:= 0
Local lFindAquis	:= .F.
aTypes10 := Separa(cTypes10, '*', .f.)

DBSelectArea("SN3")
DBSetOrder( 1 ) //N3_FILIAL + N3_CBASE + N3_ITEM + N3_TIPO

//Chave ja esta posicionada pelo chamador
cKey := SN3->(N3_FILIAL + N3_CBASE + N3_ITEM)

//-- JRJ 20171110.A Inicio
If lIsRussia
	If cTipo == '07'
		If !( SN3->(DBSeek( cKey + '01' )) .or. SN3->(DBSeek( cKey + '10' ))) //Pesquisa pelo Tipo 01 - Aquisicao
			For nTypes10 := 1 to len(aTypes10)
				If SN3->(DBSeek( cKey + aTypes10[nTypes10] ))
					lFindAquis := .T.
					Exit
				Endif
			Next nTypes10
		EndIf
	Endif
	IF lFindAquisR
		// *******************************
		// Controle de multiplas moedas  *
		// *******************************
		nResult += SN3->&(IIf(Val(cMoedaATF)>9,"N3_VRDAC","N3_VRDACM") + cMoedaATF)
	EndIf

	If cTipo $ ('01*10*16*17' + '*' + cTypes10 + '*' + cTypesNM) .AND. SN3->(DBSeek( cKey + '07' )) //Pesquisa pelo Tipo 07 - Depreciacao Acelerada
		nResult += SN3->&(IIf(Val(cMoedaATF)>9,"N3_VRDAC","N3_VRDACM") + cMoedaATF)
	EndIf
Else
	If cTipo == '07' .AND. ( SN3->(DBSeek( cKey + '01' )) .or. SN3->(DBSeek( cKey + '10' ))) //Pesquisa pelo Tipo 01 - Aquisicao
		// *******************************
		// Controle de multiplas moedas  *
		// *******************************
		nResult += SN3->&(IIf(Val(cMoedaATF)>9,"N3_VRDAC","N3_VRDACM") + cMoedaATF)
	EndIf
	If cTipo $ '01*10*16*17' .AND. SN3->(DBSeek( cKey + '07' )) //Pesquisa pelo Tipo 07 - Depreciacao Acelerada
		nResult += SN3->&(IIf(Val(cMoedaATF)>9,"N3_VRDAC","N3_VRDACM") + cMoedaATF)
	EndIf
EndIf
//-- JRJ 20171110.A Fim

//Restaura o ambiente obtido na entrada da funcao
RestArea(aAreaSN3)
RestArea(aArea)

Return nResult

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ A050AtuOff ³ Autor ³ Alice                 ³ Data ³ 20/08/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula depreciacao quando parametrizacao de saldos off line ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A050AtuOFF(nHdlPrv,nTotal,lHeadExist,cArquivo)

	Local aArea := GetArea()
	Local dDataUltD := GetMv("MV_ULTDEPR")

	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local aValorMoed
	Local aValDepr		:= AtfMultMoe(,,{|x| 0})
	Local aBxOrig		:= AtfMultMoe(,,{|x| 0}) 
	Local aBxAcum		:= AtfMultMoe(,,{|x| 0})
	Local nValCorr		:= 0, nValCorDep := 0
	Local cIndex
	Local nIndex
	Local cChaveBusca	:= " "   //Chave de Busca no SN3 ( arquivos com N.._TIPO )
	Local cChave1		:= "  "      //Chave de Busca para o SN1
	Local lUltBaixa		:= .F.    //Verifica se  a Ultima Baixa Parcial / Baixa Total
	Local cSeqReav		:= "  "    //Sequencia de Reavaliacao do Ativo. Para Ativos sem
	//Reavaliacoes o Conteudo e "  ".

	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local aUltOrig 	:= AtfMultMoe(,,{|x| 0}) 
	Local aUltBxAcm	:= AtfMultMoe(,,{|x| 0}) 
	Local aUltValDe	:= AtfMultMoe(,,{|x| 0})
	Local nUltCorr  :=0      //As vars q se iniciam com 'nUlt' sao usadas para armazenar os
	Local nUltCorDep:=0    //valores da ultima depreciacao.
	lOCAL dUltData  := Ctod("  /  /  ")
	Local lAchouSN3 := .F. //Verifca se ja pegou os dados do SN3. Executa apenas uma vez
	Local cChaveSN1 := ""  //CHAVE DE BUSCA NO SN1
	Local cFilOrigN4 := CriaVar("N3_FILORIG")
	Local nTxMediaN4 := 0, cSeqN4 := CriaVar("N3_SEQ"), cSeqReavN4 := CriaVar("N3_SEQREAV")
	Local nQuantdN4:= CriaVar("N4_QUANTD"), dDataN4:=CriaVar("N4_DATA")

	Local cTipoImob := " ", cTipoCorr := " "
	Local lPadrao  := .F.
	Local cLoteAtf := LoteCont("ATF")
	Local nPercBx  := 0
	Local lBxTotal := .F.      // Se for ultima bx aprc atualizo o reg orig no SN3
	Local nPosSN3 := 0

	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local aTotBxAcm	:= AtfMultMoe(,,{|x| 0})
	Local aTotBxBal	:= AtfMultMoe(,,{|x| 0})
	Local aTotBxOr	:= AtfMultMoe(,,{|x| 0})
	Local aTotBxAmp	:= AtfMultMoe(,,{|x| 0})
	Local nTotBxCOri:=0, nTotBxCDep:=0, nTotBxIcms:=0, nTotBxCBal:=0, nTotBxCDB:= 0

	Local	cBase    := CriaVar("N3_CBASE")
	Local cItem    := CriaVar("N4_ITEM")
	Local	cTipo    := CriaVar("N3_TIPO")
	Local	dAquisic := CriaVar("N3_AQUISIC")
	Local	dFimDepr := CriaVar("N3_FIMDEPR")
	Local	cHistor  := CriaVar("N3_HISTOR")
	Local	dDinDepr := CriaVar("N3_DINDEPR")
	Local	cSeq     := CriaVar("N3_SEQ")
	Local	cCodaix  := CriaVar("N3_CODBAIX")
	Local	cCContab:= CriaVar("N3_CCONTAB"),	cCDeprec := CriaVar("N3_CDEPREC")
	Local	cCCDepr  := CriaVar("N3_CCDEPR") ,	cCDesp   := CriaVar("N3_CDESP")
	Local	cCCorrec := CriaVar("N3_CCORREC")
	Local cCCusto  := CriaVar("N3_CCUSTO") ,	cCustBem := CriaVar("N3_CUSTBEM")
	Local cSubccon := CriaVar("N3_SUBCCON"), cSubccor := CriaVar("N3_SUBCCOR")
	Local cSubcdep := CriaVar("N3_SUBCDEP"),	cSubcdes := CriaVar("N3_SUBCDES")
	Local cSubccde := CriaVar("N3_SUBCCDE")
	Local	cClvlcon := CriaVar("N3_CLVLCON"), cClvlcor := CriaVar("N3_CLVLCOR")
	Local	cClvldep := CriaVar("N3_CLVLDEP"),	cClvldes := CriaVar("N3_CLVLDES")
	Local	cClvlcde := CriaVar("N3_CLVLCDE")
	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local aTxdepr	:=  AtfMultMoe(,,{|x| CriaVar(IIf(x>9,"N3_TXDEP","N3_TXDEPR")+Alltrim(Str(x)))}) 

	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local aIndice :=  AtfMultMoe(,,{|x| CriaVar(IIf(x>9,"N3_INDIC","N3_INDICE")+Alltrim(Str(x)))})
	Local cDeprec  := CriaVar("N3_DEPREC")

	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local aVorig  := AtfMultMoe(,,{|x| CriaVar("N3_VORIG"+Alltrim(Str(x)))}) 
	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local aVrdAcm	:= AtfMultMoe(,,{|x| CriaVar(IIf(x>9,"N3_VRDAC","N3_VRDACM")+Alltrim(Str(x)))})

	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local aVrdBal	:=  AtfMultMoe(,,{|x| CriaVar(IIf(x>9,"N3_VRDBA","N3_VRDBAL")+Alltrim(Str(x)))}) 

	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local aAmplia	:=  AtfMultMoe(,,{|x| CriaVar(IIf(x>9,"N3_AMPLI","N3_AMPLIA")+Alltrim(Str(x)))}) 

	Local	nVrcAcm1 := CriaVar("N3_VRCACM1")
	Local	nVrcMes1 := CriaVar("N3_VRCMES1")
	Local	nVrcBal1 := CriaVar("N3_VRCBAL1")
	Local	nVrcDa1  := CriaVar("N3_VRCDA1")
	Local	nVrcDb1  := CriaVar("N3_VRCDB1"), nBxIcms := CriaVar("N3_BXICMS")
	Local	cPadrao  := ""
	Local lSN3Saldo:= .T.
	Local cTpSaldo := ""

	// Verificação da classificação de Ativo se sofre depreciação
	Local lAtClDepr := .F.
	Local cTipoGerenc := ATFXTpBem(2)
	Local cTypes10		:= IIF(lIsRussia,"*" + AtfNValMod({1}, "*"),"") // CAZARINI - 24/03/2017 - If is Russia, add new valuations models - main models
	Local cTypesNM		:= IIF(lIsRussia,"*" + AtfNValMod({3,4}, "*"),"") // CAZARINI - 24/03/2017 - If is Russia, add new valuations models - 17 and 16 models

	dbSelectArea("SN4")
	dbSetOrder(1)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Seleciona os registro de baixa num arquivo                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cIndex := CriaTrab(nil,.f.)
	cChave  := "N4_FILIAL+N4_CBASE+N4_ITEM+N4_TIPO+N4_SEQREAV+N4_SEQ"
	IndRegua("SN4",cIndex,cChave,,Af050OFF(dDataUltD),STR0011) // "Selecionando Registros..."
	nIndex := RetIndex("SN4")
	dbSelectArea("SN4")
	#IFNDEF TOP
		dbSetIndex( cIndex +OrdBagExt())
	#ENDIF
	dbSelectArea("SN4")
	dbSetOrder(nIndex+1)
	dbGoTop()

	If BOF() .and. EOF()
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Restaura os indices      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		RetIndex("SN4")
		Set Filter To
		fErase(cIndex+OrdBagExt())
		RestArea(aArea)
		Return
	Endif

	While !Eof()

		aBxOrig	:= AtfMultMoe(,,{|x| 0}) 
		aBxAcum	:= AtfMultMoe(,,{|x| 0})
		aValDepr 	:= AtfMultMoe(,,{|x| 0}) 
		nValCorr:= 0;nValCorDep:=0
		lAchouSN3 := .F.
		lUltBaixa := .F.
		cChaveBusca := N4_CBASE+N4_ITEM+N4_TIPO+N4_SEQREAV+N4_SEQ
		While !Eof() .And.	cChaveBusca==N4_CBASE+N4_ITEM+N4_TIPO+N4_SEQREAV+N4_SEQ .And.;
		xFilial("SN4")=N4_FILIAL
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Compatibilizacao da baixa Off Line com a baixa On Line. Na baixa tradicional, ³
			//³ On Line, a ultima baixa parcial tem os seus valores atualizados no proprio re-³
			//³ gistro existente, ao inves de criar uma sequencia (N3_SEQ) nova. Por isto se  ³
			//³ encontrar uma bx parcial com a mesma sequencia do bem no SN4, significa que o ³
			//³ bem foi totalmente depreciado e esta atualizacao deve ser feita sobre o regis-³
			//³ tro existente no SN3 ( nao cria nova sequencia).                              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cChaveSN1 := N4_CBASE+N4_ITEM
			cChave1 := N4_CBASE+N4_ITEM+N4_TIPO
			dbSelectArea("SN3")
			dbSetOrder(1)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Localizo o Ativo a ser Baixado no SN3. Os N4_CBASE+N4_ITEM+N4_TIPO+N4_SEQREAV  ³
			//³ devem ser iguais a N3_CBASE+N3_ITEM+N3_TIPO+N3_SEQREAV no SN3.                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lAchouSN3
				If dbSeek(xFilial("SN3")+cChave1)
					While !Eof() .And. N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO==xFilial("SN3")+cChave1
						If SN3->N3_SEQREAV == SN4->N4_SEQREAV
							If N3_SEQ==SN4->N4_SEQ
								lUltBaixa := .T.
								lBxTotal  := .T.
							EndIf
							nPosSN3 := Recno()
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Carrego as vars para utilizar na gravacao do reg novo         ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							cBase      := SN3->N3_CBASE
							cItem      := SN4->N4_ITEM
							cTipo      := SN3->N3_TIPO
							dAquisic   := SN3->N3_AQUISIC
							dFimDepr   := SN3->N3_FIMDEPR
							cHistor    := SN3->N3_HISTOR
							dDinDepr   := SN3->N3_DINDEPR
							cSeq       := SN3->N3_SEQ
							cSeqReav   := SN3->N3_SEQREAV
							cCodaix    := SN3->N3_CODBAIX

							cCContab  := SN3->N3_CCONTAB
							cCDeprec   := SN3->N3_CDEPREC
							cCCDepr    := SN3->N3_CCDEPR
							cCDesp     := SN3->N3_CDESP
							cCCorrec   := SN3->N3_CCORREC

							cCCusto    := SN3->N3_CCUSTO
							cCustBem   := SN3->N3_CUSTBEM

							cSubccon  := SN3->N3_SUBCCON
							cSubccor  := SN3->N3_SUBCCOR
							cSubcdep  := SN3->N3_SUBCDEP
							cSubcdes  := SN3->N3_SUBCDES
							cSubccde  := SN3->N3_SUBCCDE

							cClvlcon  := SN3->N3_CLVLCON
							cClvlcor  := SN3->N3_CLVLCOR
							cClvldep  := SN3->N3_CLVLDEP
							cClvldes  := SN3->N3_CLVLDES
							cClvlcde  := SN3->N3_CLVLCDE

							// *******************************
							// Controle de multiplas moedas  *
							// *******************************
							aTxdepr	:= AtfMultMoe("SN3","N3_TXDEPR")

							// *******************************
							// Controle de multiplas moedas  *
							// *******************************
							aIndice	:= AtfMultMoe("SN3","N3_INDICE")

							cDeprec   := SN3->N3_DEPREC

							// *******************************
							// Controle de multiplas moedas  *
							// *******************************
							aVorig	:= AtfMultMoe("SN3","N3_VORIG")

							// *******************************
							// Controle de multiplas moedas  *
							// *******************************
							aVrdAcm	:= AtfMultMoe("SN3","N3_VRDACM")

							// *******************************
							// Controle de multiplas moedas  *
							// *******************************
							aVrdBal	:= AtfMultMoe("SN3","N3_VRDBAL")

							// *******************************
							// Controle de multiplas moedas  *
							// *******************************
							aAmplia	:= AtfMultMoe("SN3","N3_AMPLIA")

							nVrcAcm1  := SN3->N3_VRCACM1
							nVrcMes1  := SN3->N3_VRCMES1
							nVrcBal1  := SN3->N3_VRCBAL1
							nVrcDa1   := SN3->N3_VRCDA1
							nVrcDa1   := SN3->N3_VRCDM1
							nVrcDb1   := SN3->N3_VRCDB1
							nBxIcms   := SN3->N3_BXICMS
							lAchouSN3 := .T.
							Exit
						EndIf
						dbSkip()
					EndDo
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Baixa do Valor Original                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SN4->N4_OCORR=="01" .And. SN4->N4_TIPOCNT="1"
				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				aBxOrig	:= AtfMultMoe("SN4","N4_VLROC")

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Baixa dde despesa de depreciacao                    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ElseIf SN4->N4_OCORR=="06" .And. SN4->N4_TIPOCNT="3"
				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				aValDepr	:= AtfMultMoe("SN4","N4_VLROC")

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Baixa do Valor Depreciao Acumulada                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ElseIf SN4->N4_OCORR=="01" .And. SN4->N4_TIPOCNT="4"
				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				aBxAcum	:= AtfMultMoe("SN4","N4_VLROC")

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Baixa do Valor Correcao do Bem                      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ElseIf SN4->N4_OCORR=="07" .And. SN4->N4_TIPOCNT="2"
				nValCorr := SN4->N4_VLROC1
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Baixa do Valor Correcao da Depreciacao Acumulada    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ElseIf SN4->N4_OCORR=="08" .And. SN4->N4_TIPOCNT="5"
				nValCorDep := SN4->N4_VLROC1
			EndIf
			dDataN4   := SN4->N4_DATA
			cFilOrigN4 := SN4->N4_FILORIG
			nTxMediaN4 := SN4->N4_TXMEDIA
			cSeqN4     := SN4->N4_SEQ
			cSeqReavN4 := SN4->N4_SEQREAV
			cCodBaixN4 := SN4->N4_CODBAIX
			nQuantdN4  := SN4->N4_QUANTD
			nPercBx    := aBxOrig[1]/(aVorig[1]+aAmplia[1])
			dbSelectArea("SN4")
			dbSkip()
		EndDo

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Subtraio os valores de correcoes do nVOrig1 e nBxAcum1, pois na baixa, se exis-³
		//³ tir correcoes estas sao somadas nestas variaveis. Portanto, antes de atualizar ³
		//³ os Cpos N3_VORIG1 e N3_VRDACM1 subtraio estes valores, ja que existem Cpos es- ³
		//³ pecificos para as correcoes ( N3_VRCDA1 e N3_VRCACM1 ).                        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aBxOrig[1] := aBxOrig[1] - nValCorr
		aBxAcum[1] := aBxAcum[1] - nValCorDep
		If lUltBaixa
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Guardo os valores referentes a ultima baixa pois a ultima baixa deve ser atu³
			//³ alizada sobre o ultima registro.                                            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			aUltOrig	:= AtfMultMoe(,, {|x| aBxOrig[x] })

			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			aUltBxAcm	:= AtfMultMoe(,, {|x| aBxAcum[x] })

			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			aUltValDe	:= AtfMultMoe(,, {|x| aValDepr[x] })

			nUltCorr:=nValCorr;  nUltCorDep:=nValCorDep;dUltData:=dDataN4
			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			aBxOrig	:=  AtfMultMoe(,,{|x| 0}) 

			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			aBxAcum	:=  AtfMultMoe(,,{|x| 0})

			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			aValDepr :=  AtfMultMoe(,,{|x| 0}) 
			//nValDepr1:=0;nValDepr2:=0;nValDepr3:=0;nValDepr4:=0;nValDepr5:=0
			nValCorr :=0;nValCorDep:=0
		Endif

		dbSelectArea("SN1")
		dbSetOrder(1)
		If dbSeek(xFilial()+cChaveSN1)
			Reclock("SN1",.f.)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ A data de baixa existente no SN1 deve ser gravada somente qdo o Ativo for To-³
			//³ talmente baixado.                                                            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SN1->N1_BAIXA  := Iif(lBxTotal,dDataN4,CTOD("  /  /  "))
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ A Qtd de Ativo deve ser subtraida somente uma vez, pois a quantidade e unica ³
			//³ para todos os tipos de bem ( N3_TIPO = 01, 02, 04 ) e esta gravada no SN1.   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nQuantdN4 !=SN1->N1_QUANTD
				SN1->N1_QUANTD -= nQuantdN4
			EndIf
			MsUnlock()
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica as Pergutnas da Baixa                      ³
		//³ mv_par01 - 1 Mostra lancto Contabil                 ³
		//³          - 2 NAO Contabiliza                        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If mv_par01 = 1
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Contabilizacao ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cTipo $ "01*10*16*17"       // Aquisi‡„o
				cPadrao := "810"
			ElseIf cTipo $ "02/41/42"    // Reavalia‡„o
				cPadrao := "811"
			ElseIf cTipo == "04"    // Lei 8200 (Dif. BTN/IPC)
				cPadrao := "813"
			Else
				cPadrao := "81A"
			EndIf
		EndIf

		If !lUltBaixa

			RecLock("SN3",.T.)
			SN3->N3_FILIAL   := xFilial("SN3")
			SN3->N3_CBASE    := cBase
			SN3->N3_ITEM     := cItem
			SN3->N3_TIPO     := cTipo
			SN3->N3_AQUISIC  := dAquisic
			SN3->N3_HISTOR   := cHistor
			SN3->N3_BAIXA    := "1"
			SN3->N3_DINDEPR  := dDinDepr
			SN3->N3_SEQ      := cSeqN4
			SN3->N3_SEQREAV  := cSeqReavN4
			SN3->N3_CODBAIX  := cCodBaixN4

			SN3->N3_CCONTAB  := cCContab
			SN3->N3_CDEPREC  := cCDeprec
			SN3->N3_CCDEPR   := cCCDepr
			SN3->N3_CDESP    := cCDesp
			SN3->N3_CCORREC  := cCCorrec

			SN3->N3_CCUSTO   := cCCusto
			SN3->N3_CUSTBEM  := cCustBem

			SN3->N3_DTBAIXA  := dDataN4
			SN3->N3_FIMDEPR  := dFimDepr

			SN3->N3_SUBCCON  := cSubccon
			SN3->N3_SUBCCOR  := cSubccor
			SN3->N3_SUBCDEP  := cSubcdep
			SN3->N3_SUBCDES  := cSubcdes
			SN3->N3_SUBCCDE  := cSubccde

			SN3->N3_CLVLCON  := cClvlcon
			SN3->N3_CLVLCOR  := cClvlcor
			SN3->N3_CLVLDEP  := cClvldep
			SN3->N3_CLVLDES  := cClvldes
			SN3->N3_CLVLCDE  := cClvlcde

			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			AtfMultMoe("SN3","N3_TXDEPR", {|x| aTxdepr[x] })

			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			AtfMultMoe("SN3","N3_INDICE", {|x| aIndice[x] })

			SN3->N3_DEPREC   := cDeprec

			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			AtfMultMoe("SN3","N3_VRDMES", {|x| aValDepr[x] })

			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			AtfMultMoe("SN3","N3_VORIG", {|x| aBxOrig[x] })

			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			AtfMultMoe("SN3","N3_VRDACM", {|x| aBxAcum[x] })

			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			AtfMultMoe("SN3","N3_VRDBAL", {|x| Round(aVrdBal[x] * nPercBx,X3Decimal(IIf(x>9,"N3_VRDBA","N3_VRDBAL")))+aValDepr[x] })

			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			AtfMultMoe("SN3","N3_AMPLIA", {|x| Round(aAmplia[x] * nPercBx,X3Decimal(IIf(x>9,"N3_AMPLI","N3_AMPLIA")+Alltrim(Str(x)))) })

			SN3->N3_VRCACM1  := Round(nVrcAcm1 * nPercBx,X3Decimal("N3_VRCACM1")) + nValCorr
			SN3->N3_VRCMES1  := nValCorr
			SN3->N3_VRCBAL1  := Round(nVrcBal1 * nPercBx,X3Decimal("N3_VRCBAL1")) + nValCorr
			SN3->N3_VRCDA1   := Round(nVrcDa1 * nPercBx,X3Decimal("N3_VRCDA1")) + nValCorDep
			SN3->N3_VRCDM1   := nValCorDep
			SN3->N3_VRCDB1   := Round(nVrcDb1 * nPercBx,X3Decimal("N3_VRCDB1")) + nValCorDep
			SN3->N3_BXICMS   := Round(nBxIcms * nPercBx,X3Decimal("N3_BXICMS"))
			MsUnlock()

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualizar os Arquivos SN5, SN5, SN6 SNA             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			aValorMoed	:= AtfMultMoe("SN3","N3_VORIG")

			If lSN3Saldo
				cTpSaldo := SN3->N3_TPSALDO
			EndIf

			// Verificação da classificação de Ativo se sofre depreciação
			lAtClDepr := AtClssVer(SN1->N1_PATRIM)
			cTipoImob := IIF(SN1->N1_PATRIM $ "CAS","C",IIF(lAtClDepr .OR. EMPTY(SN1->N1_PATRIM),"5","D"))
			cTipoCorr := IIF(SN1->N1_PATRIM $ "CAS","O",IIF(lAtClDepr .OR. EMPTY(SN1->N1_PATRIM),"6","6"))
			AtfSaldo(	SN3->N3_CCONTAB,dDataN4,cTipoImob,SN3->N3_VORIG1,SN3->N3_VORIG2,;
			SN3->N3_VORIG3,SN3->N3_VORIG4,SN3->N3_VORIG5,"+",nTxMediaN4,;
			SN3->N3_SUBCCON,,SN3->N3_CLVLCON,SN3->N3_CUSTBEM,"1", aValorMoed,cTpSaldo)
			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			aValorMoed	:= AtfMultMoe(,,{|x| IIf(x=1,nValCorr,0) })

			cTipoImob := IIF(SN1->N1_PATRIM $ "CAS","C",IIF(lAtClDepr .OR. EMPTY(SN1->N1_PATRIM),"5","D"))
			cTipoCorr := IIF(SN1->N1_PATRIM $ "CAS","O",IIF(lAtClDepr .OR. EMPTY(SN1->N1_PATRIM),"6","6"))
			AtfSaldo(	SN3->N3_CCONTAB,dDataN4,cTipoCorr,nValCorr,0,0,0,0,"+",nTxMediaN4,;
			SN3->N3_SUBCCON,,SN3->N3_CLVLCON,SN3->N3_CUSTBEM,"1", aValorMoed, cTpSaldo)

			If lAtClDepr .OR. EMPTY(SN1->N1_PATRIM)
				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				aValorMoed	:= AtfMultMoe(,,{|x| IIf(x=1,nValCorr,0) })

				cTipoImob := IIF(SN1->N1_PATRIM $ "CAS","C",IIF(lAtClDepr .OR. EMPTY(SN1->N1_PATRIM),"5","D"))
				cTipoCorr := IIF(SN1->N1_PATRIM $ "CAS","O",IIF(lAtClDepr .OR. EMPTY(SN1->N1_PATRIM),"6","6"))
				ATFSaldo(	SN3->N3_CCORREC,dDataN4,cTipoCorr,nValCorr,0,0,0,0,"+",;
				nTxMediaN4,SN3->N3_SUBCCOR,,SN3->N3_CLVLCOR,SN3->N3_CCCORR,"2", aValorMoed,cTpSaldo)
				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				// Deprecia‡„o e deprecia‡„o acumulada
				cTipoImob := IIf( !SN3->N3_TIPO $ "08,09"+cTipoGerenc, "4", IIf(SN3->N3_TIPO $ cTipoGerenc ,"Y",IIf(SN3->N3_TIPO=="09","L","K")))
				ATFSaldo(	SN3->N3_CDEPREC,dDataN4,cTipoImob,aValDepr[1],aValDepr[2],aValDepr[3],;
				aValDepr[4],aValDepr[5],"+",nTxMediaN4,SN3->N3_SUBCDEP,,;
				SN3->N3_CLVLDEP,SN3->N3_CCDESP,"3", aValDepr,cTpSaldo)
				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				aValorMoed	:= AtfMultMoe(,,{|x| IIf(x=1,nValCorDep ,0) })

				ATFSaldo(	SN3->N3_CDESP  ,dDataN4,"7",nValCorDep ,0,0,0,0,"+",;
				nTxMediaN4,SN3->N3_SUBCDES,,SN3->N3_CLVLDES,SN3->N3_CCCDES,"5", aValorMoed, cTpSaldo)
				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				ATFSaldo(	SN3->N3_CCDEPR ,dDataN4,"4",aValDepr[1],aValDepr[2],;
				aValDepr[3],aValDepr[4],aValDepr[5],"+",nTxMediaN4,SN3->N3_SUBCCDE,,;
				SN3->N3_CLVLCDE,SN3->N3_CCCDEP,"4", aValDepr,cTpSaldo)
				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				ATFSaldo(	SN3->N3_CCDEPR ,dDataN4,"5",aBxAcum[1],aBxAcum[2],aBxAcum[3],;
				aBxAcum[4],aBxAcum[5],"+",nTxMediaN4,SN3->N3_SUBCCDE,,;
				SN3->N3_CLVLCDE,SN3->N3_CCCDEP,"4", aBxAcum,cTpSaldo)
				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				aValorMoed	:= AtfMultMoe(,,{|x| IIf(x=1,nValCorDep ,0) })

				ATFSaldo(	SN3->N3_CCDEPR ,dDataN4,"7",nValCorDep ,0,0,0,0,"+",;
				nTxMediaN4,SN3->N3_SUBCCDE,,SN3->N3_CLVLCDE,SN3->N3_CCCDEP,"4", aValorMoed,cTpSaldo)
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se existe lancto padrao da baixa ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If mv_par01 == 1
				lPadrao := VerPadrao(cPadrao)
				IF lPadrao
					If !lHeadExist
						nHdlPrv := HeadProva(cLoteAtf,"ATFA050",Substr(cUsername,1,6),@cArquivo)
						lHeadExist := .T.
					Endif
					nTotal += DetProva(nHdlPrv,cPadrao,"ATFA050",cLoteAtf)
				Endif
			EndIf

			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			AtfMultMoe(,, {|x| aTotBxOr[x] += aBxOrig[x] })

			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			AtfMultMoe(,, {|x| aTotBxAcm[x] += aBxAcum[x] })

			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			AtfMultMoe(,, {|x| aTotBxBal[1]+= SN3->&(IIf(x>9,"N3_VRDBA","N3_VRDBAL")+Alltrim(Str(x))) })

			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			AtfMultMoe(,, {|x| aTotBxAmp[1]+= SN3->&(IIf(x>9,"N3_AMPLI","N3_AMPLIA")+Alltrim(Str(x))) })

			nTotBxCOri+=SN3->N3_VRCACM1; nTotBxCDep+=SN3->N3_VRCDA1;  nTotBxIcms+=SN3->N3_BXICMS
			nTotBxCBal+=SN3->N3_VRCBAL1; nTotBxCDB +=SN3->N3_VRCDB1
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se Nao for a ultima bx parc ou bx total, mas for a  ³
		//³ ultima lida atualizo o regs atual do SN3            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (SN4->N4_CBASE+SN4->N4_ITEM+SN4->N4_TIPO+SN4->N4_SEQREAV!=SN3->N3_CBASE+SN3->N3_ITEM+SN3->N3_TIPO+SN3->N3_SEQREAV)
			If lBxTotal
				SN3->(dbGoto(nPosSN3))
				Reclock("SN3",.F.)
				SN3->N3_BAIXA    := "1"
				SN3->N3_DTBAIXA  := dUltData
				SN3->N3_FIMDEPR  := dFimDepr

				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				AtfMultMoe("SN3","N3_VORIG", {|x| aUltOrig[x] })

				nPercBx    := SN3->N3_VORIG1/(aVorig[1]+aAmplia[1])

				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				AtfMultMoe("SN3","N3_VRDACM", {|x| aUltBxAcm[x] })

				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				AtfMultMoe("SN3","N3_VRDMES", {|x| aUltValDe[x] })

				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				AtfMultMoe("SN3","N3_VRDBAL", {|x| Round(aVrdBal[x] * nPercBx,X3Decimal(IIf(x>9,"N3_VRDBA","N3_VRDBAL")+Alltrim(Str(x))))+aUltValDe[x] })

				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				AtfMultMoe("SN3","N3_AMPLIA", {|x| Round(aAmplia[x] * nPercBx,X3Decimal(IIf(x>9,"N3_AMPLI","N3_AMPLIA")+Alltrim(Str(x)))) })

				SN3->N3_VRCACM1  := Round(nVrcAcm1 * nPercBx,X3Decimal("N3_VRCACM1"))+nUltCorr
				SN3->N3_VRCBAL1  := Round(nVrcBal1 * nPercBx,X3Decimal("N3_VRCBAL1"))+nUltCorr
				SN3->N3_VRCDA1   := Round(nVrcDa1  * nPercBx,X3Decimal("N3_VRCDA1")) +nUltCorDep
				SN3->N3_VRCDB1   := Round(nVrcDa1  * nPercBx,X3Decimal("N3_VRCDB1")) +nUltCorDep
				SN3->N3_BXICMS   := Round(nBxIcms  * nPercBx,X3Decimal("N3_BXICMS"))
				MsUnlock()

				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				aUltOrig 	:=  AtfMultMoe(,, {|x| 0 })
				aUltBxAcm	:=  AtfMultMoe(,, {|x| 0 }) 
				aUltValDe	:=  AtfMultMoe(,, {|x| 0 })

				nUltCorr:=0  ; nUltCorDep:=0; dUltData:=Ctod("  /  /  ")
				lBxTotal := .F.
			Else
				SN3->(dbGoto(nPosSN3))
				Reclock("SN3",.F.)

				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				AtfMultMoe("SN3","N3_VORIG", {|x| SN3->&("N3_VORIG"+Alltrim(Str(x))) - aTotBxOr[x] })

				nPercBx    := SN3->N3_VORIG1/(aVorig[1]+aAmplia[1])

				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				AtfMultMoe("SN3","N3_VRDMES", {|x| Round(aValDepr[x] * nPercBx,X3Decimal( IIf(x>9,"N3_VRDME","N3_VRDMES")+Alltrim(Str(x)) )) })

				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				AtfMultMoe("SN3","N3_VRDACM", {|x| Round(aVrdAcm[x] * nPercBx,X3Decimal(IIf(x>9,"N3_VRDAC","N3_VRDACM")+Alltrim(Str(x)))) })

				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				AtfMultMoe("SN3","N3_VRDBAL", {|x| Round(aVrdBal[x] * nPercBx,X3Decimal( IIf(x>9,"N3_VRDBA","N3_VRDBAL")+Alltrim(Str(x)) )) })

				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				AtfMultMoe("SN3","N3_AMPLIA", {|x| Round(aAmplia[x] * nPercBx,X3Decimal( IIf(x>9,"N3_AMPLI","N3_AMPLIA")+Alltrim(Str(x)) )) })

				SN3->N3_VRCACM1  := Round(nVrcAcm1 * nPercBx,X3Decimal("N3_VRCACM1"))
				SN3->N3_VRCBAL1  := Round(nVrcBal1 * nPercBx,X3Decimal("N3_VRCBAL1"))
				SN3->N3_VRCDA1   := Round(nVrcDa1  * nPercBx,X3Decimal("N3_VRCDA1"))
				SN3->N3_VRCDB1   := Round(nVrcDa1  * nPercBx,X3Decimal("N3_VRCDB1"))
				SN3->N3_BXICMS   := Round(nBxIcms  * nPercBx,X3Decimal("N3_BXICMS"))
				MsUnlock()

				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				aTotBxOr :=  AtfMultMoe(,, {|x| 0 }) 
				aTotBxAcm:=  AtfMultMoe(,, {|x| 0 }) 
				aTotBxBal:=  AtfMultMoe(,, {|x| 0 }) 
				aTotBxAmp:=  AtfMultMoe(,, {|x| 0 })
				nTotBxIcms:=0; nTotBxCOri:=0; nTotBxCDep:=0; nTotBxCBal:=0; nTotBxCDB:= 0
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualizar os Arquivos SN5, SN5, SN6 SNA             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			
			aValorMoed	:= AtfMultMoe("SN3","N3_VORIG")
			

			// Verificação da classificação de Ativo se sofre depreciação
			lAtClDepr := AtClssVer(SN1->N1_PATRIM)

			cTipoImob := IIF(SN1->N1_PATRIM $ "CAS","C",IIF(lAtClDepr .OR. EMPTY(SN1->N1_PATRIM),"5","D"))
			cTipoCorr := IIF(SN1->N1_PATRIM $ "CAS","O",IIF(lAtClDepr .OR. EMPTY(SN1->N1_PATRIM),"6","6"))
			AtfSaldo(	SN3->N3_CCONTAB,dDataN4,cTipoImob,SN3->N3_VORIG1,SN3->N3_VORIG2,;
			SN3->N3_VORIG3,SN3->N3_VORIG4,SN3->N3_VORIG5,"+",nTxMediaN4,;
			SN3->N3_SUBCCON,,SN3->N3_CLVLCON,SN3->N3_CUSTBEM,"1", aValorMoed,cTpSaldo)
			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			
			aValorMoed	:= AtfMultMoe(,,{|x| IIf(x=1,nValCorr,0) })
			

			cTipoImob := IIF(SN1->N1_PATRIM $ "CAS","C",IIF(lAtClDepr .OR. EMPTY(SN1->N1_PATRIM),"5","D"))
			cTipoCorr := IIF(SN1->N1_PATRIM $ "CAS","O",IIF(lAtClDepr .OR. EMPTY(SN1->N1_PATRIM),"6","6"))
			AtfSaldo(	SN3->N3_CCONTAB,dDataN4,cTipoCorr,nValCorr,0,0,0,0,"+",;
			nTxMediaN4,SN3->N3_SUBCCON,,SN3->N3_CLVLCON,SN3->N3_CUSTBEM,"1", aValorMoed,cTpSaldo)

			// Verificação da classificação de Ativo se sofre depreciação
			lAtClDepr := AtClssVer(SN1->N1_PATRIM)
			If lAtClDepr .OR. EMPTY(SN1->N1_PATRIM)
				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				
				aValorMoed	:= AtfMultMoe(,,{|x| IIf(x=1,nValCorr,0) })

				cTipoImob := IIF(SN1->N1_PATRIM $ "CAS","C",IIF(lAtClDepr .OR. EMPTY(SN1->N1_PATRIM),"5","D"))
				cTipoCorr := IIF(SN1->N1_PATRIM $ "CAS","O",IIF(lAtClDepr .OR. EMPTY(SN1->N1_PATRIM),"6","6"))
				ATFSaldo(	SN3->N3_CCORREC,dDataN4,cTipoCorr,nValCorr,0,0,0,0,"+",;
				nTxMediaN4,SN3->N3_SUBCCOR,,SN3->N3_CLVLCOR,SN3->N3_CCCORR,"2", aValorMoed,cTpSaldo)
				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				// Deprecia‡„o e deprecia‡„o acumulada
				ATFSaldo(	SN3->N3_CDEPREC,dDataN4,"4",aValDepr[1],aValDepr[2],aValDepr[3],;
				aValDepr[4],aValDepr[5],"+",nTxMediaN4,SN3->N3_SUBCDEP,,;
				SN3->N3_CLVLDEP,SN3->N3_CCDESP,"3", aValorMoed,cTpSaldo)
				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				aValorMoed	:= AtfMultMoe(,,{|x| IIf(x=1,nValCorDep ,0) })
				
				ATFSaldo(	SN3->N3_CDESP  ,dDataN4,"7",nValCorDep ,0,0,0,0,"+",;
				nTxMediaN4,SN3->N3_SUBCDES,,SN3->N3_CLVLDES,SN3->N3_CCCDES,"5", aValorMoed,cTpSaldo)
				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				ATFSaldo(	SN3->N3_CCDEPR ,dDataN4,"4",aValDepr[1],aValDepr[2],aValDepr[3],;
				aValDepr[4],aValDepr[5],"+",nTxMediaN4,SN3->N3_SUBCCDE,,;
				SN3->N3_CLVLCDE,SN3->N3_CCCDEP, aValDepr,cTpSaldo)
				ATFSaldo(	SN3->N3_CCDEPR ,dDataN4,"5",aBxAcum[1],aBxAcum[2],aBxAcum[3],aBxAcum[4],;
				aBxAcum[5],"+",nTxMediaN4,SN3->N3_SUBCCDE,,SN3->N3_CLVLCDE,;
				SN3->N3_CCCDEP,"4", aBxAcum,cTpSaldo)
				// *******************************
				// Controle de multiplas moedas  *
				// *******************************
				aValorMoed	:= AtfMultMoe(,,{|x| IIf(x=1,nValCorDep ,0) })
				ATFSaldo(	SN3->N3_CCDEPR ,dDataN4,"7",nValCorDep ,0,0,0,0,"+",nTxMediaN4,;
				SN3->N3_SUBCCDE,,SN3->N3_CLVLCDE,SN3->N3_CCCDEP,"4", aValorMoed,cTpSaldo)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se existe lancto padrao da baixa ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If mv_par01 == 1
				lPadrao := VerPadrao(cPadrao)
				IF lPadrao
					If !lHeadExist
						nHdlPrv := HeadProva(cLoteAtf,"ATFA050",Substr(cUsername,1,6),@cArquivo)
						lHeadExist := .T.
					Endif
					nTotal += DetProva(nHdlPrv,cPadrao,"ATFA050",cLoteAtf)
				Endif
			EndIf
		EndIf
		dbSelectArea("SN4")
	EndDo

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Restaura os indices      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RetIndex("SN4")
	Set Filter To
	fErase (cIndex+OrdBagExt())
	RestArea(aArea)

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³Af050Off  ³ Autor ³ Alice Yaeko Yamamoto  ³ Data ³ 08.08.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna Condi‡„o para Indice Condicional					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³af050Off()   											      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ATFA050													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Af050Off(dDataUltD)

	Local cFiltro := ""

	cFiltro := 'N4_FILIAL == "'+xFilial("SN4")+'" .AND. DTOS(N4_DATA) > "'+Dtos(dDataUltD)
	cFiltro += '" .AND. DTOS(N4_DATA) <= "'+Dtos(LastDay(dDataUltD+1))+'" .And. (!Empty(N4_MOTIVO))'
	cFiltro += ' .AND. N4_OCORR $ "01 06 07 08" '

Return cFiltro

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A050TxDeprºAutor  ³ Jose Novaes Romeu  º Data ³  07/23/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Definicao de outras formulas de calculo da depreciacao.     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ATFA050                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A050TxDepr(nPeriodos)

	Local nTaxa := 0, nAno, nLaco, nTxAcum

	Default nPeriodos := SN3->N3_PERDEPR

	If SN3->N3_TPDEPR == "2" // Declinio de Saldos - Localizacoes POR|EUA
		nTaxa	:= (SN3->N3_TXDEPR1 / 2) * IIf(nPeriodos > 10, 1.5,2) //Taxa do primeiro ano
		nAno	:= Year(dDatabase) - Year(SN3->N3_DINDEPR)
		If Month(dDatabase) >= Month(SN3->N3_DINDEPR)
			nAno ++
		EndIf
		If nAno > 1  // Variacao da taxa a partir do segundo ano.
			nTxAcum := nTaxa
			For nLaco := 2 to nAno
				nTaxa := (100-nTxAcum) / 10 * IIf(nPeriodos > 10, 1.5,2)
				nTxAcum += nTaxa
			Next
		EndIf
	ElseIf SN3->N3_TPDEPR == "3" // Soma dos Anos - Localizacoes POR|EUA
		nAno := Year(dDatabase) - Year(SN3->N3_DINDEPR)
		If Month(dDatabase) < Month(SN3->N3_DINDEPR)
			nAno --
		EndIf
		nTaxa := (nPeriodos - nAno) / (( nPeriodos * ( nPeriodos + 1)) / 2)
	EndIf

Return (nTaxa)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ CalcDepre  ³ Autor ³ Claudio D. de Souza   ³ Data ³ 13/02/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula a depreciacao de  itens baixados, conforme a base    ³±±
±±³          ³ de calculo do item                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ ATFA050                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CalcDepre(dData,dBaixa,dINDEPR,cTipo,aBases,cMoedaAtf,nQuant,nQtdOrig,lCalcula,nMVVALCORR,cPatrim,aRusModer)

	Local nMoeda, nTaxa, nValTaxa,cMoeda,nPos
	Local aDias     := AtfMultMoe(,,{|x| 0}) 
	Local aTxMedia  := AtfMultMoe(,,{|x| IIf(x=1,1,0) }) 
	Local nDias     := Day(LastDay(dData))	//nro de dias no mes da baixa
	Local nDiasDepr := Day(dData)			// Nro de dias a depreciar
	Local nResidual := 0
	Local nTaxaCorr := 0					//Taxa para corre‡Æo
	Local nValCorr  := 0
	Local nValCorDep:= 0
	Local nDiferenca:= 0

	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local __nQuantas := AtfMoedas()

	Local aValDepr[__nQuantas]
	Local aDepr[__nQuantas]
	Local aVlResid[__nQuantas]
	Local aVRDACM[__nQuantas]
	Local aRet		  := {{},{},{},{},{}}
	Local nVRCDA1
	Local i
	Local dDataI
	Local cN1TipoNeg := Alltrim(SuperGetMv("MV_N1TPNEG",.F.,"")) // Tipos de N1_PATRIM que aceitam Valor originais negativos
	Local cN3TipoNeg := Alltrim(SuperGetMv("MV_N3TPNEG",.F.,"")) // Tipos de N3_TIPO que aceitam Valor originais negativos

	Local aTaxaMes	:= {aBases[1][TAXA_DE_DEPRECIACAO],aBases[2][TAXA_DE_DEPRECIACAO],aBases[3][TAXA_DE_DEPRECIACAO],aBases[4][TAXA_DE_DEPRECIACAO],aBases[5][TAXA_DE_DEPRECIACAO]}
	Local cCalcDep	:= GetNewPar("MV_CALCDEP",'0')	//->	'0'-Mensal
	//->	'1'-Anual
	Local cTipDepr	:= AllTrim(GetMv("MV_TIPDEPR"))	//->	'0'-Proporcional
	//->	'1'-Mes Cheio
	//->	'2'-Mes Posterior (NAO calc deprec de bens baixados(RIPASA) no mes de calc)
	//->	'3'-Ano proporcional com mes de aquisicao proporcional
	//->	'4'-Ano proporcional com mes de aquisicao cheio
	//->	'5'-Ano posterior
	Local nTaxaMes
	Local nTaxaBx

	Local nPropBase		:= 0
	Local lVlrMxDp		:= .F.
	Local nMoedaVMax	:= Iif(Val(GetMv("MV_ATFMDMX",.F.," "))>0, Val(GetMv("MV_ATFMDMX")), Val(cMoedaAtf))
	Local lVlrSalv		:= SN3->N3_TPDEPR=='2'
	Local nCusto
	Local nDecTax
	Local nMFiscal		:= Val(cMoedaAtf) // O vlr zero exclui a condicao da moeda fiscal
	Local nVlrOriSal	:= 0
	Local nDecimal		:= 0
	Local aRusFatPar	:= {}	// Set of russian fields for calculation of depreciation
	Local nRusModI		:= 0	// Index of russian modernization reference
	Local nX			:= 0

	// Verificação da classificação de Ativo se sofre depreciação
	Local lAtClDepr := .F.

	// Verifica se o método de depreciaco é por indice calculado
	Local lCalcInd   := AF050IND()
	Local nCustOrig := 0

	Local nVlrCota  := SuperGetMV("MV_ATFCOTA",.F., 0.99)

	Default cPatrim := SN1->N1_PATRIM
	Default aRusModer	:= {}

	lVlrMxDp := nMoedaVMax > 0 .AND. SN3->N3_VMXDEPR > 0

	If lVlrMxDp
		lVlrMxDp := Alltrim(SN3->N3_TPDEPR) == '7'
	EndIf

	If lVlrMxDp .And. nMoedaVMax > 9
		nPropBase 	:= SN3->N3_VMXDEPR / (&("SN3->N3_VORIG"  + Alltrim(Str(nMoedaVMax))) + &("SN3->N3_AMPLI" + Alltrim(Str(nMoedaVMax))))
	ElseIf lVlrMxDp .And. nMoedaVMax <= 9
		nPropBase 	:= SN3->N3_VMXDEPR / (&("SN3->N3_VORIG"  + Alltrim(Str(nMoedaVMax))) + &("SN3->N3_AMPLIA" + Alltrim(Str(nMoedaVMax))))
	ElseIf lVlrSalv
		nPropBase 	:= SN3->N3_VLSALV1 / SN3->(N3_VORIG1+N3_AMPLIA1)
	Endif


	/*
	aBases[1] = Informacao na moeda 1
	aBases[2][n] = Informacao Conforme abaixo
	--------------------------------------------------------------------------
	aBases[1][1] - Depreciacao acumulada na moeda 1 (N3_VRDACM1)
	aBases[1][2] - Correcao da depreciacao acumulada na moeda 1 - (N3_VRCDA1)
	aBases[1][3] - Valor original na moeda 1 (N3_VORIG1)
	aBases[1][4] - Correcao acumulada do bem (N3_VRCACM1)
	aBases[1][5] - Valor da ampliacao na moeda 1 - (N3_AMPLIA1)
	aBases[1][6] - Taxa de depreciacao na moeda 1 - (N3_TXDEPR1)

	aBases[2][1] - Depreciacao acumulada na moeda 1 (N3_VRDACM2)
	aBases[2][2] - Correcao da depreciacao acumulada na moeda 1 - (N3_VRCDA2)
	aBases[2][3] - Valor original na moeda 1 (N3_VORIG2)
	aBases[2][4] - Correcao acumulada do bem (N3_VRCACM2)
	aBases[2][5] - Valor da ampliacao na moeda 1 - (N3_AMPLIA2)
	aBases[2][6] - Taxa de depreciacao na moeda 1 - (N3_TXDEPR2)
	*/

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³                                                                        ³
	//³                     V A L O R   R E S I D U A L                        ³
	//³                                                                        ³
	//ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
	//³                                                                        ³
	//³ Valor residual e' a quantia a ser depreciada de um bem.                ³
	//³                                                                        ³
	//³ Se o valor da baixa for superior ao valor residual, a diferenca entre  ³
	//³ esses valores representa LUCRO a ser devidamente contabilizado.        ³
	//³                                                                        ³
	//³ Custo da Baixa = Valor Original em Moeda Forte                         ³
	//³                                                                        ³
	//ÃÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ´
	//³ Valor	 ³ Depr.   ³ Depr.ate ³ Depr.   ³ Valor    ³ Valor   ³ Lucro(+)³
	//³ Original ³ Acum.   ³ Dt Baixa ³ Acum.   ³ Residual ³ Baixa   ³         ³
	//ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
	//³ 1.000,00 ³  300,00 ³  20,00   ³  320,00 ³	680,00 ³  680,00 ³  0,00   ³
	//ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
	//³ 1.000,00 ³  300,00 ³  20,00   ³  320,00 ³	680,00 ³  780,00 ³  100,00 ³
	//ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
	//³ 2.000,00 ³2.000,00 ³  0,00    ³   0,00  ³	  0,00 ³  200,00 ³  200,00 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÙ

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcula a taxa media para cada moeda                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	nDiasDepr := IIf( cTipDepr == "0", Day(dData), nDias)		// Nro de dias a depreciar

	dDataI := FirstDay(dData)
	dDataI := IIF(dINDEPR > dDataI, dINDEPR, dDataI)
	dbSelectArea("SM2")
	dbSeek(dDataI,.T.)
	aTxMedia[1] := 1
	aDias := AtfMultMoe(,,{|x| 0 }) 
	While !Eof() .And. SM2->M2_DATA <= dData
		For i := 2 To __nQuantas
			cMoeda := Alltrim(Str(i))
			IF &('SM2->M2_MOEDA'+cMoeda) > 0
				aDias[i] += 1
				aTxMedia[i] += &('SM2->M2_MOEDA'+cMoeda)
			EndIf
		Next
		dbSkip()
	EndDo
	For i := 2 To __nQuantas
		cMoeda:=Alltrim(Str(i))
		IF aTxMedia[i] = 0 .Or. aDias[i] = 0
			aDias[i]	 := 1
			aTxMedia[i] := 1
		Else
			aTxMedia[i]:=aTxMedia[i] / aDias[i]
		End
	Next

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Efetua a deprecia‡„o por moedas apenas se a data de in¡cio de depre-   ³
	//³ cia‡„o j  tenha chegado.                                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aFill(aValDepr, 0 )
	aFill(aDepr, 0 )
	aFill(aVlResid, 0 )
	aFill(aVRDACM, 0 )
	nDiferenca := 0

	// Verificação da classificação de Ativo se sofre depreciação
	lAtClDepr := AtClssVer(cPatrim)

	If lAtClDepr .OR. EMPTY(cPatrim)
		aRusFatPar	:= Nil
		If lIsRussia
			// Russian modernization performed on this month can't impact on depreciation
			nRusModI	:= AScan(aRusModer, {|x| ;
				x[1] + x[2] + x[3] + x[4] + x[5] == ;
				SN3->(N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_TPSALDO) })
			If nRusModI > 0
				For nX := 1 To Len(aTaxaMes)
					aTaxaMes[nX]	:= NoRound(aTaxaMes[nX] - aRusModer[nRusModI,6], TAMSX3('N3_TXDEPR1')[2])
				Next nX

				// Same logic performed on AFatorCalc for Nil aParam but replace N3_PERDEPR for old value
				aRusFatPar 		:= Array(9)
				aRusFatPar[1]	:= SN3->N3_VORIG1
				aRusFatPar[2]	:= SN3->N3_VRDACM1
				aRusFatPar[3]	:= SN3->N3_TPDEPR
				aRusFatPar[4]	:= SN3->N3_VMXDEPR
				aRusFatPar[5]	:= RU01T03_S3ReturnPerDep(&("SN3->N3_TXDEPR" + cMoedaAtf) - aRusModer[nRusModI,6], cCalcDep == "1")
				aRusFatPar[6]	:= SN3->N3_VLSALV1
				aRusFatPar[7]	:= SN3->N3_PRODMES
				aRusFatPar[8]	:= SN3->N3_PRODANO
				aRusFatPar[9]	:= SN3->N3_FIMDEPR
			EndIf
		EndIf
		aTaxaMes 	:= AFatorCalc(aTaxaMes, dINDEPR, dDataBase, cTipDepr, cCalcDep, .T., aRusFatPar)

		For nMoeda := 1 To 5
			If cPaisLoc == "CHI" .and. ( nMoeda == 1 )
				nDecimal := 0
			Else
				nDecimal := X3Decimal( "N3_VORIG" + AllTrim(Str(nMoeda)) )
			Endif

			If dINDEPR <= dBaixa
				cMoeda := Str(nMoeda,1)
				aValDepr[nMoeda] := 0
				If(!(lVlrMxDp .And. nMoedaVMax == nMoeda .and.SN3->N3_VMXDEPR == Abs(aBases[nMoeda][DEPRECIACAO_ACUMULADA]+ aBases[nMoeda][CORRECAO_DA_DEPRECIACAO]))) .AND. (Abs(aBases[nMoeda][DEPRECIACAO_ACUMULADA]+ aBases[nMoeda][CORRECAO_DA_DEPRECIACAO]) < ;
				Abs(aBases[nMoeda][VALOR_ORIGINAL]+aBases[nMoeda][CORRECAO_ACUMULADA]+aBases[nMoeda][VALOR_DA_AMPLIACAO]))
					IF aTaxaMes[nMoeda] > 0
						nDecTax	:= TamSX3("N3_VORIG1")[2]
						nCusto	:= aBases[nMoeda][VALOR_ORIGINAL]+aBases[nMoeda][CORRECAO_ACUMULADA]+aBases[nMoeda][VALOR_DA_AMPLIACAO]

						If nMoedaVMax==nMoeda .And. lVlrMxDp
							//habilita o "Valor maximo de depreciação" no calculo de depreciação na moeda definida
							nCusto := IIf(Empty(SN3->N3_VMXDEPR), nCusto, SN3->N3_VMXDEPR)
						ElseIf nMoedaVMax!=nMoeda .And. lVlrMxDp
							// Proporcionaliza a base para as outras moedas
							If cPaisloc <> "PTG"
								nCusto := Round(NoRound(nCusto * Round(NoRound(nPropBase,nDecTax+1),nDecTax), nDecTax+1), nDecTax)
							Endif
						EndIf

						If lVlrSalv .And. nMoeda == 1
							nVlrOriSal := nCusto - SN3->N3_VLSALV1
							nCusto := Abs(nCusto - aBases[nMoeda][DEPRECIACAO_ACUMULADA])
						ElseIf lVlrSalv .And. nMoeda >= 2
							nVlrOriSal := nCusto - ROUND(NOROUND(nCusto * Round(NoRound(nPropBase,nDecTax+1),nDecTax),nDecTax+1),nDecTax)
							nCusto := Abs(nCusto - aBases[nMoeda][DEPRECIACAO_ACUMULADA])
						EndIf

						// No calculo de curva de trafego a depreciacao é sobre o valor contabil ( Aquisicao - Depreciacao Acumulada)
						If lCalcInd
							nCustOrig := nCusto
							nCusto := Abs(nCusto - aBases[nMoeda][DEPRECIACAO_ACUMULADA] )
						EndIf

						nTaxa				:= aTaxaMes[nMoeda]
						aValDepr[nMoeda]	:= Round(Abs(nCusto) * nTaxa, X3Decimal("N3_VORIG"+cMoeda))
						// Verifica se o valor da cota eh maior do que o valor residual.
						If lVlrSalv
							nDiferenca := Abs(nVlrOriSal) - (Abs(aValDepr[nMoeda]) + Abs(aBases[nMoeda][DEPRECIACAO_ACUMULADA]+ aBases[nMoeda][CORRECAO_DA_DEPRECIACAO]))
						ElseIf lCalcInd
							nDiferenca := Abs(nCustOrig) - (Abs(aValDepr[nMoeda]) + Abs(aBases[nMoeda][DEPRECIACAO_ACUMULADA]+ aBases[nMoeda][CORRECAO_DA_DEPRECIACAO]))
						Else
							nDiferenca := Abs(nCusto) - (Abs(aValDepr[nMoeda]) + Abs(aBases[nMoeda][DEPRECIACAO_ACUMULADA]+ aBases[nMoeda][CORRECAO_DA_DEPRECIACAO]))
						EndIf

						// Residuo inferior a 1 (uma) unidade monetaria sera adicionado a cota atual.
						If lCalcInd .And. Round( nDiferenca, nDecimal ) <= nVlrCota
							aDepr[ nMoeda ] := nCustOrig - aBases[nMoeda][DEPRECIACAO_ACUMULADA] + aBases[1][CORRECAO_DA_DEPRECIACAO]
						ElseIf !lVlrSalv .And. Round( nDiferenca, nDecimal ) <= nVlrCota
							aDepr[ nMoeda ] := nCusto - aBases[nMoeda][DEPRECIACAO_ACUMULADA] + aBases[1][CORRECAO_DA_DEPRECIACAO]
						ElseIf lVlrSalv .And. Round( nDiferenca, nDecimal ) <= nVlrCota
							aDepr[ nMoeda ] := nVlrOriSal - aBases[nMoeda][DEPRECIACAO_ACUMULADA] + aBases[1][CORRECAO_DA_DEPRECIACAO]
						Endif
					Endif
				Endif
			Endif
		Next
	EndIf

	nMoeda := Val(cMoedaAtf)

	If lCalcula
		nTaxaCorr  := nMVVALCORR
		nValCorr   := Round(	Abs((aBases[1][VALOR_ORIGINAL]+aBases[1][VALOR_DA_AMPLIACAO])*nTaxaCorr),X3Decimal("N3_VORIG1")) - ;
		Abs(aBases[1][CORRECAO_ACUMULADA]+aBases[1][VALOR_ORIGINAL]+aBases[1][VALOR_DA_AMPLIACAO])
		nValCorDep := Round(	Abs(aBases[1][DEPRECIACAO_ACUMULADA]+aValDepr[nMoeda])*nTaxaCorr,X3Decimal("N3_VORIG1")) - ;
		Abs(aBases[1][DEPRECIACAO_ACUMULADA]+aBases[1][CORRECAO_DA_DEPRECIACAO]+aValDepr[1])
	Else
		If DtoS(dData) < "19941001"
			nTaxaCorr := RecMoeda(dData,cMoedaAtf)
		Else
			nTaxaCorr := 0
		Endif

		If nTaxaCorr != 0
			nValCorr   := Round(	Abs((aBases[nMoeda][VALOR_ORIGINAL]+aBases[nMoeda][VALOR_DA_AMPLIACAO])*nTaxaCorr),X3Decimal("N3_VORIG1")) - ;
			Abs(aBases[1][CORRECAO_ACUMULADA]+aBases[1][VALOR_ORIGINAL]+aBases[1][VALOR_DA_AMPLIACAO])
			nValCorDep := Round(	Abs(aBases[nMoeda][DEPRECIACAO_ACUMULADA]+aValDepr[nMoeda])*nTaxaCorr,X3Decimal("N3_VORIG1")) - ;
			Abs(aBases[1][DEPRECIACAO_ACUMULADA]+aBases[1][CORRECAO_DA_DEPRECIACAO]+aValDepr[1])

			nValCorr   := IIF(nQuant < nQtdOrig, nValCorr / nQtdOrig * nQuant, nValCorr)
			nValCorr   := Round(nValCorr, X3Decimal("N3_VRCACM1"))
			nValCorDep := IIF(nQuant< nQtdOrig, nValCorDep / nQtdOrig* nQuant, nValCorDep)
			nValCorDep := Round(nValCorDep, X3Decimal("N3_VRCDA1" ))
		EndIf
	EndIf
	nVlrAtual1 := aBases[1][VALOR_ORIGINAL]+aBases[1][CORRECAO_ACUMULADA]+aBases[1][VALOR_DA_AMPLIACAO]+nValCorr

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ CALC. DE DEPRECIA€ÇO NA MOEDA1.                                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lCalcula  // BOBS
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se NAO tiver residuo na moeda 3                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If aDepr[nMoeda] = 0
			aValDepr[1] := Round(aValDepr[nMoeda] * nMVVALCORR,X3Decimal("N3_VORIG1"))
		Endif
		nDiferenca := (aBases[1][VALOR_ORIGINAL]+aBases[1][CORRECAO_ACUMULADA]+aBases[1][VALOR_DA_AMPLIACAO]+nValCorr) - (aValDepr[1]+aBases[1][DEPRECIACAO_ACUMULADA]+aBases[1][CORRECAO_DA_DEPRECIACAO])
		If Round(nDiferenca,X3Decimal("N3_VORIG1")) < 0
			aDepr[1] := (aBases[1][VALOR_ORIGINAL]+aBases[1][CORRECAO_ACUMULADA]+aBases[1][VALOR_DA_AMPLIACAO])-(aBases[1][DEPRECIACAO_ACUMULADA] + aBases[1][CORRECAO_DA_DEPRECIACAO])
		Endif
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Regra Geral a Depr na Moeda1 ‚ calculada pela taxa media do mˆs,   ³
		//³enquanto existe uma taxa de referencia (UFIR). A partir de 01/01/96³
		//³a referncia ‚ o pr¢prio real. Dessa forma nÆo ha necessidade de    ³
		//³converter a deprecia‡Æo pela Ufir de referencia.                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Dtos(dData) < "19960101"
			aValDepr[1]  := Round(aValDepr[nMoeda] * aTxMedia[nMoeda],X3Decimal("N3_VORIG1"))
			nDiferenca := (aBases[1][VALOR_ORIGINAL]+aBases[1][CORRECAO_ACUMULADA]+aBases[1][VALOR_DA_AMPLIACAO]+nValCorr) - (Abs(aValDepr[1])+aBases[1][DEPRECIACAO_ACUMULADA]+aBases[1][CORRECAO_DA_DEPRECIACAO])
			If Round(nDiferenca,X3Decimal("N3_VORIG1")) <= 0
				aDepr[1] := (aBases[1][VALOR_ORIGINAL]+aBases[1][CORRECAO_ACUMULADA]+aBases[1][VALOR_DA_AMPLIACAO])-(aBases[1][DEPRECIACAO_ACUMULADA] + aBases[1][CORRECAO_DA_DEPRECIACAO])
			Endif
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Trata os res¡duos de deprecia‡ao.                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If dINDEPR <= dBaixa
		If aDepr[1] != 0
			aValDepr[1] := aDepr[1]
		Endif
	Endif
	For nMoeda := 1 To __nQuantas
		cMoeda := Alltrim(Str(nMoeda))
		If cMoeda =="1"
			nResidual := aBases[nMoeda][DEPRECIACAO_ACUMULADA]+aBases[nMoeda][CORRECAO_DA_DEPRECIACAO]
			If cTIPO = "05" .Or. (cPatrim $ cN1TipoNeg) .Or. (cTipo $ cN3TipoNeg)
				nResidual := aBases[nMoeda][VALOR_ORIGINAL]+aBases[nMoeda][VALOR_DA_AMPLIACAO]+aBases[nMoeda][CORRECAO_ACUMULADA]+Abs(nResidual)
			Else
				nResidual := Abs(aBases[nMoeda][VALOR_ORIGINAL]+aBases[nMoeda][VALOR_DA_AMPLIACAO]+aBases[nMoeda][CORRECAO_ACUMULADA]-nResidual)
			Endif
		Else
			nResidual := aBases[nMoeda][DEPRECIACAO_ACUMULADA]
			If cTIPO = "05" .Or. (cPatrim $ cN1TipoNeg) .Or. (cTipo $ cN3TipoNeg)
				nResidual := aBases[nMoeda][VALOR_ORIGINAL]+aBases[nMoeda][VALOR_DA_AMPLIACAO]+Abs(nResidual)
			Else
				nResidual := Abs(aBases[nMoeda][VALOR_ORIGINAL]+aBases[nMoeda][VALOR_DA_AMPLIACAO]-nResidual)
			Endif
		End
		aVlResid[nMoeda] := nResidual

		If cCalcDep == cd_MENSAL .Or. !cPaisLoc $ "BRA|ANG"
			If cPaisLoc == "ARG"
				If SN1->N1_CONSAB == "1"
					nDiasDepr := 0
				Else
					nDiasDepr := (LastDay(dData)-FirstDay(dData))+1
				EndIf
			Else
				If Month(dINDEPR) == Month(dData) .And. Year(dINDEPR) == Year(dData)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Nro de dias a depreciar qdo a baixa ‚ feita no mesmo mˆs e ano da³
					//³ data de in¡cio de deprecia‡ao.                                   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					nDiasDepr := IIf(cTipDepr == "0", (dData-dINDEPR)+1, nDias)
				ElseIf Month(dINDEPR) > Month(dData) .And.;
				Year(dINDEPR) == Year(dData)
					nDiasDepr := 0
				Endif
			EndIf

			If Round(nDiferenca,X3Decimal("N3_VORIG"+cMoeda)) > 0
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ nDias - n£mero de dias no mˆs em que se est  efetuando o c lc.   ³
				//³ nDiasDepr - n£mero efetivo de dias a depreciar no mˆs.           ³
				//³   Somente deprecio proporcional ao n£mero de dias do mˆs quando  ³
				//³ o valor da deprecia‡„o NAO ‚ um res¡duo de deprecia‡„o. Caso se- ³
				//³ ja um res¡duo, este ser  o valor da deprecia‡„o do mˆs, na oca - ³
				//³ si„o da baixa.                                                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aValDepr[nMoeda] := aValDepr[nMoeda] / nDias * nDiasDepr   //Day(dData)
			EndIf
		Else

			If Year(dINDEPR)==Year(dData)
				If Month(dINDEPR)==Month(dData)
					nTaxaMes         := ( aValDepr[nMoeda] / 12 ) * IIf( cTipDepr $ "4|5", 1, ( (dINDEPR-dData) + 1 ) / Day(LastDay(dData)) )
					aValDepr[nMoeda] := aValDepr[nMoeda] * ( ( Month(dData) - Month(dINDEPR) ) / 12 ) + nTaxaMes
				Else
					nTaxaMes         := ( aValDepr[nMoeda] / 12 ) * IIf( cTipDepr $ "4|5", 1, ( (LastDay(dINDEPR)-dINDEPR) + 1 ) / Day(LastDay(dINDEPR)) )
					nTaxaBx          := ( aValDepr[nMoeda] / 12 ) * IIf( cTipDepr $ "4|5", 0, Day(dData) / Day(LastDay(dData)) )
					aValDepr[nMoeda] := aValDepr[nMoeda] * ( ( Month(dData) - Month(dINDEPR) - 1 ) / 12 ) + nTaxaMes + nTaxaBx
				EndIf
			EndIf

		EndIf

		If cTIPO = "05" .Or. (cPatrim $ cN1TipoNeg) .Or. (cTipo $ cN3TipoNeg)
			aVlResid[nMoeda] += aValDepr[nMoeda]
		Else
			aVlResid[nMoeda] -= aValDepr[nMoeda]
		Endif

		aVRDACM[nMoeda]  := aBases[nMoeda][DEPRECIACAO_ACUMULADA]

		If nQuant < nQtdOrig
			aValDepr[nMoeda]  := Round(aValDepr[nMoeda] / nQtdOrig * nQuant, X3Decimal(IIf(nMoeda>9,"N3_VRDME","N3_VRDMES")+cMoeda))
			aVlResid[nMoeda]  := Round(aVlResid[nMoeda] / nQtdOrig * nQuant, X3Decimal("N3_VORIG"+cMoeda))
			aVRDACM[nMoeda]   := Round(aVRDACM[nMoeda]  / nQtdOrig * nQuant, X3Decimal(IIf(nMoeda>9,"N3_VRDAC","N3_VRDACM")+cMoeda))
		EndIf

		If aDepr[nMoeda] != 0
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Baixa de bem com residuo de depreciacao em uma ou outra moeda    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aValDepr[nMoeda]  := Round(aDepr[nMoeda], X3Decimal(IIf(nMoeda>9,"N3_VRDME","N3_VRDMES")+cMoeda))
		Endif
		aVlResid[nMoeda]  := Round(aVlResid[nMoeda], X3Decimal("N3_VORIG"+cMoeda))
		aVRDACM[nMoeda]   := Round(aVRDACM[nMoeda] , X3Decimal(IIf(nMoeda>9,"N3_VRDAC","N3_VRDACM")+cMoeda))
		If nMoeda == 1
			nVRCDA1  := aBases[CORRECAO_DA_DEPRECIACAO]
		EndIf
	Next

	nMoeda := Val(cMoedaAtf)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calculo de Correcao da correcao do bem e da depreciacao.              ³
	//³ A taxa de correcao e a mesma para o custo e p/ depr acumulada.        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lCalcula
		nTaxaCorr  := nMVVALCORR
		nValCorr   := Round(	(aBases[nMoeda][VALOR_ORIGINAL]+aBases[nMoeda][VALOR_DA_AMPLIACAO]*nTaxaCorr),X3Decimal("N3_VORIG1")) - ;
		Abs(aBases[1][CORRECAO_ACUMULADA]+aBases[1][VALOR_ORIGINAL]+aBases[1][VALOR_DA_AMPLIACAO])
		nValCorr   := IIF(nQuant < nQtdOrig, nValCorr / nQtdOrig * nQuant, nValCorr)
		nValCorDep := Round(	(aBases[nMoeda][DEPRECIACAO_ACUMULADA]+ aValDepr[nMoeda])*nTaxaCorr,X3Decimal("N3_VORIG1")) - ;
		(aBases[1][DEPRECIACAO_ACUMULADA] + aBases[1][CORRECAO_DA_DEPRECIACAO] + aValDepr[1])
		nValCorDep := IIF(nQuant< nQtdOrig, nValCorDep / nQtdOrig* nQuant, nValCorDep)
		nValCorDep := Round(nValCorDep, X3Decimal("N3_VRCDA1" ))
	Else
		If DtoS(dData) < "19941001"
			nTaxaCorr := RecMoeda(dData,cMoedaAtf)
		Else
			nTaxaCorr := 0
		Endif
		If nTaxaCorr != 0
			nValCorr   := Round((aBases[nMoeda][VALOR_ORIGINAL]+aBases[nMoeda][VALOR_DA_AMPLIACAO]*nTaxaCorr),X3Decimal("N3_VORIG1")) - ;
			Abs(aBases[1][CORRECAO_ACUMULADA]+aBases[1][VALOR_ORIGINAL]+aBases[1][VALOR_DA_AMPLIACAO])
			nValCorr   := IIF(nQuant < nQtdOrig, nValCorr / nQtdOrig * nQuant, nValCorr)
			nValCorDep := Round(	(aBases[nMoeda][DEPRECIACAO_ACUMULADA] + aValDepr[nMoeda])*nTaxaCorr,X3Decimal("N3_VORIG1")) - ;
			(aBases[1][DEPRECIACAO_ACUMULADA] + aBases[1][CORRECAO_DA_DEPRECIACAO] + aValDepr[1])
			nValCorDep := IIF(nQuant< nQtdOrig, nValCorDep / nQtdOrig* nQuant, nValCorDep)
			nValCorDep := Round(nValCorDep, X3Decimal("N3_VRCDA1" ))
		End
	EndIf
	// Retorno os valores calculados, uma dimensao para as moedas, onde sao retornados o valor da
	// depreciacao em cada moeda. Os valores de correcao e correcao da depreciacao independe da moeda
	// por isso sao retornados na linha 2 e 3 da matriz.
	aRet := {aValDepr,nValCorr,nValCorDep}

Return aRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Af050MonBas ³ Autor ³ Claudio D. de Souza   ³ Data ³ 16/02/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Monta as bases para calculo de depreciacao de itens baixados ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ ATFA050                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Af050MonBas(cBase, cItem, cTipo, cBaixa, cSeq)

	Local aAreaSn3 := SN3->(GetArea())
	Local aBases 	:= {}
	Local nX
	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local __nQuantas := AtfMoedas()

	/*
	aBases[1][1] - Depreciacao acumulada na moeda 1 (N3_VRDACM1)
	aBases[1][2] - Correcao da depreciacao acumulada na moeda 1 - (N3_VRCDA1)
	aBases[1][3] - Valor original na moeda 1 (N3_VORIG1)
	aBases[1][4] - Correcao acumulada do bem (N3_VRCACM1)
	aBases[1][5] - Valor da ampliacao na moeda 1 - (N3_AMPLIA1)
	aBases[1][6] - Taxa de depreciacao na moeda 1 - (N3_TXDEPR1)
	*/

	SN3->(DbSetOrder(1))
	SN3->(MsSeek(xFilial("SN3")+cBase+cItem+cTipo+cBaixa+cSeq))
	FOR nX := 1 to __nQuantas
		cMoed := Alltrim(Str(nX))

		IF nX == 1
			Aadd(aBases, {	SN3->(&("N3_VRDACM"+cMoed)/N3_PERCBAI),;
			SN3->(&("N3_VRCDA"+cMoed)/N3_PERCBAI),;
			SN3->(&("N3_VORIG"+cMoed)/N3_PERCBAI),;
			SN3->(&("N3_VRCACM"+cMoed)/N3_PERCBAI),;
			SN3->(&("N3_AMPLIA"+cMoed)/N3_PERCBAI),;
			SN3->&("N3_TXDEPR"+cMoed)} )
		ELSEIF nX>9
			Aadd(aBases, {	SN3->(&("N3_VRDAC"+cMoed)/N3_PERCBAI),;
			0,;
			SN3->(&("N3_VORIG"+cMoed)/N3_PERCBAI),;
			0,;
			SN3->(&("N3_AMPLI"+cMoed)/N3_PERCBAI),;
			SN3->&("N3_TXDEPR"+cMoed)} )
		ELSE
			Aadd(aBases, {	SN3->(&("N3_VRDACM"+cMoed)/N3_PERCBAI),;
			0,;
			SN3->(&("N3_VORIG"+cMoed)/N3_PERCBAI),;
			0,;
			SN3->(&("N3_AMPLIA"+cMoed)/N3_PERCBAI),;
			SN3->&("N3_TXDEPR"+cMoed)} )
		ENDIF
	NEXT

	SN3->(RestArea(aAreaSn3))

Return aBases

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³aRegToMemoryºAutor  ³Claudio Donizete  º Data ³  05/07/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ ATIVO                                                      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function aRegToMemory(cAlias)

	Local aRet := {}
	Local aStru := (cAlias)->(DbStruct())
	Local nX
	Local nLen

	nLen := Len(aStru)

	For nX := 1 To nLen
		Aadd(aRet, { AllTrim(aStru[nX][1]), (cAlias)->(FieldGet(nX)) } )
	Next

	// Estrutura da matriz de Retorno
	// aRet[1] := Nome do campo
	// aRet[2] := Conteudo do campo

Return aRet


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³MenuDef   ³ Autor ³ Ana Paula N. Silva     ³ Data ³08/12/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Utilizacao de menu Funcional                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array com opcoes da rotina.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Parametros do array a Rotina:                               ³±±
±±³          ³1. Nome a aparecer no cabecalho                             ³±±
±±³          ³2. Nome da Rotina associada                                 ³±±
±±³          ³3. Reservado                                                ³±±
±±³          ³4. Tipo de Transa‡„o a ser efetuada:                        ³±±
±±³          ³		1 - Pesquisa e Posiciona em um Banco de Dados         ³±±
±±³          ³    2 - Simplesmente Mostra os Campos                       ³±±
±±³          ³    3 - Inclui registros no Bancos de Dados                 ³±±
±±³          ³    4 - Altera o registro corrente                          ³±±
±±³          ³    5 - Remove o registro corrente do Banco de Dados        ³±±
±±³          ³5. Nivel de acesso                                          ³±±
±±³          ³6. Habilita Menu Funcional                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MenuDef()
	Local aRotina := { { STR0004,"AllwaysTrue", 0 , 3} } // "Parametros"
Return(aRotina)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³VerIDProc ³ Autor ³ Marcelo Pimentel      ³ Data ³24.07.2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Identifica a sequencia de controle do fonte ADVPL com a     ³±±
±±³          ³stored procedure, qualquer alteracao que envolva diretamente³±±
±±³          ³a stored procedure a variavel sera incrementada.            ³±±
±±³          ³Procedure ATF001                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function VerIDProc()
Return '012'

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Funcao   ³AFA050Valid³ Autor ³ --------------------- ³ Data ³ -------- ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descrição³Efetua as validacoes basicas para o processamento do calculo ³±±
±±³          ³com filial de/ate                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ATFA050                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function AFA050Valid( cMoedaAtf, lAjustInf, dUltProc, cFilDe, cFilAte, lCheck070 )

	Local lResult	:= .T.
	Local cCalcDep	:= GetNewPar("MV_CALCDEP",'0')	//->	'0'-Mensal //->	'1'-Anual
	Local cAliasQry := ""
	Local lOrigem   := SN4->(FieldPos("N4_ORIGEM"))>0
	Local dUltData  := CToD('//')

	Default dUltProc := GetNewPar("MV_ULTDEPR", STOD("19800101"))
	Default lCheck070 := .F.

	If lIsRussia .and. lCheck070
		lResult := AFA070Valid(dUltProc, .F.)
	Else
		dUltProc := GetNewPar("MV_ULTDEPR", STOD("19800101"))

		If lResult .And. lOrigem
			cAliasQry := GetNextAlias()
			cQuery := " SELECT "
			cQuery += " 	ISNULL( MAX(N4_DATA), ' ' ) SN4DTPROC  "
			cQuery += " FROM "  + RetSQLTab("SN4")
			cQuery += " WHERE SN4.N4_FILIAL  = '" + xFilial("SN4") + "' AND "
			cQuery += " N4_OCORR IN ('06','20') AND "
			cQuery += " N4_ORIGEM = 'ATFA050' AND "
			
			If lIsRussia
				cQuery += " (N4_STORNO != '1' AND N4_STORNO != '2') AND "
			EndIf

			cQuery += " N4_DATA > '" + Dtos(dUltProc) + "' AND "
			cQuery += " SN4.D_E_L_E_T_ = '' "
			cQuery := ChangeQuery(cQuery)

			DbUseArea( .T., "TOPCONN", TcGenQry( ,, cQuery ), cAliasQry )

			dUltData := STOD((cAliasQry)->SN4DTPROC)

			If (cAliasQry)->(!Eof()) .And. dUltData > dUltProc
				Help(" ",1,"050UTDEPR",,STR0046,1,0)
				lResult := .F.
			Endif

			dbSelectArea(cAliasQry)
			dbCloseArea()
		Endif

		If	lResult .and. cCalcDep == cd_MENSAL .And.;
			(dDataBase # LastDay(dDataBase) .Or.;
		dDataBase > LastDay(dUltProc + 1) )
			If IsBlind()
				LogRecord( 'ID:050DTDEPR' )
			Else
				HELP(" ",1,"050DTDEPR",,DTOC(dUltProc),5,1)
			EndIf

			SET KEY VK_F12 TO
			lResult := .F.
		ElseIf	lResult .and. cCalcDep <> cd_MENSAL .And.;
		(dDataBase # STOD(StrZero(Year(dDataBase),4)+cUltDiaMes) .Or.;
		dDataBase > STOD(StrZero(Year(dUltProc)+1,4)+cUltDiaMes))
			If IsBlind()
				LogRecord( 'ID:050DTDEPRA' )
			Else
				HELP(" ",1,"050DTDEPRA",,DTOC(dUltProc),5,1)
			EndIf
			SET KEY VK_F12 TO
			lResult := .F.
		ENDIF

		If lresult .and.;
			( cPaisLoc == "CHI" ) .and.;
			( RecMoeda(dDataBase,Val(cMoedaAtf)) == 0 )
			// "Nao existe taxa para a Moeda "  ###" cadastrada neste dia"  ### "Tasa referencia "
			If IsBlind()
				LogRecord( STR0009 + ' ' + STR0015 + cMoedaAtf + STR0016 )
			Else
				MsgStop( STR0015 + cMoedaAtf + STR0016, STR0009 )
			EndIf
			SET KEY VK_F12 TO
			lResult := .F.
		Endif

		If lResult .and. cPaisLoc == "ARG" .and. lAjustInf
			If dUltProc <> GetMV("MV_ATFINDT")
				//"No se puede hacer el calculo del activo sin hacer el ajuste de inflacion del mes anterior"###"Ajuste"
				If IsBlind()
					LogRecord( STR0021 + ': ' + STR0022 )
				Else
					MSGAlert(STR0021,STR0022)
				EndIf
				lResult := .F.
			Endif
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Valida a ultima Data de Depreciacao.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF lResult .and. ( dUltProc >= dDataBase )
			If IsBlind()
				LogRecord( 'ID:050JACALC' )
			Else
				HELP( " ", 1, "050JACALC" )
			EndIf
			lResult := .F.
		End

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se pode efetuar o calculo  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lPerDepr
			If lResult .and. !ATFCanCalc(dUltProc, SubStr(cUltDiaMes,1,2), SubStr(cUltDiaMes,3,2))
				lResult := .F.
			Endif
		Else
			If lResult .and. !ATFCanCalc(dUltProc)
				lResult := .F.
			Endif
		EndIf

		//Executa apenas com o ponto de entrada AF050VTP
		If ExistBlock("AF050VTP")
			If lResult .and. !AFA050VlTp(cFilDe, cFilAte)
				If IsBlind()
					LogRecord( 'ID:AF050VLTP' )
				Else
					HELP(" ",1,"AF050VLTP",,STR0033,1,0)    //"Existem ativo(s) com tipo nao tratado"
				EndIf
				lResult := .F.
			EndIf
		EndIf
	EndIf

Return lResult

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função    ³ TxRegres ³ Autor ³ Norberto M Melo       ³ Data ³01/06/08  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Ajusta a taxa de depreciação de acordo com a regra de cotas³±±
±±³          ³ decrescentes.                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Taxa Perdida. Passada por referência.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Array de 5 Elementos, representando as taxas de depreciação³±±
±±³          ³ nas respectivas moedas de 1 a 5                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function TxRegres( nTxPerdida, cMoedaATF, cPeriodo, nMes)

	Local aAreaNT		:= SNT->( GetArea( ) )			//Tabela de Taxas de Depreciação
	Local aAreaN1		:= SN1->( GetArea( ) )			//Tabela de Ativos Imobilizados - Cabeçalho
	Local aAreaN3		:= SN3->( GetArea( ) )			//Tabela de Contas e Saldos
	Local aTxMoedas		:= AtfMultMoe(,,{|x| 0}) 					//Retorno da Função
	Local cAnoMesBase	:= SubStr( DToS( dDataBase ), 1, 6)
	Local aTaxaMax		:= AtfMultMoe(,,{|x| 0})
	Local nCoefici		:= 0
	Local i				:= 0							//Contador - Auxiliar

	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local __nQuantas := AtfMoedas()

	Default nTxPerdida 	:= 0

	nCoefici := IIF( SN3->N3_COEFICI <= 0, 1, SN3->N3_COEFICI )

	if cPeriodo == P_MENSAL .or. (cPeriodo == P_ANUAL .and. nMes == Month( dDataBase ))
		// Verifica se existe um conjunto específico de taxas para esta data //
		SNT->( dbSetOrder( 1 ) )
		SNT->( dbSeek( xFilial( "SN3" ) + SN3->N3_CBASE + SN3->N3_ITEM + cAnoMesBase ) )
		for i := 1 to __nQuantas
			if !SNT->( Eof() )
				aTxMoedas[ i ] := SNT->&('NT_MOEDA' + Alltrim(Str(i)) )
			else
				aTxMoedas[ i ] := SN3->&(IIf(i>9,'N3_TXDEP','N3_TXDEPR') + Alltrim(Str(i)) )
			endif
		next i

		//Verifica Taxa Perdida ------------------------------------------------------------------
		//A lei portuguesa permite a utilização de taxas mínimas e máximas de amortização.
		//As empresas poderão optar por amortizar os seus bens recorrendo a taxas mínimas
		//sendo estas metade das taxas máximas apresentadas na tabela de grupos homogêneos.
		//Se em determinados exercícios, forem utilizadas taxas de amortização inferiores
		//às taxas mínimas, a diferença entre estas e as taxas praticadas não pode constituir
		//custo de exercícios seguintes peloo que se consideram assim taxas perdidas no exercício.
		aTaxaMax := MaxTxDegr()
		if aTxMoedas[ Val( cMoedaATF ) ] < ( aTaxaMax[Val(cMoedaATF)] ) / 2
			nTxPerdida := ( SNG->&( IIf(Val( cMoedaATF )>9,"NG_TXDEP","NG_TXDEPR") + cMoedaATF ) / 2 ) - aTxMoedas[ Val( cMoedaATF ) ]
		endif

		//Aplicar Coeficiente --------------------------------------------------------------------
		//Neste método as taxas resultantes da multiplicação pelos coeficientes são
		//aplicadas ao valor liquido contabilístico, ou seja, ao custo de aquisição
		//deduzido das reintegrações acumuladas.
		//Exemplos:
		//		1,5 se o período de vida útil do elemento é inferior a 5 anos;
		//		2,0 se o período mínimo de vida útil do elemento é de 5 ou 6 anos;
		//		2,5 se o período mínimo de vida útil do elemento é superior a 6 anos.
		//Por definição, O coeficiente será informado pelo usuário.
		for i := 1 to __nQuantas
			aTxMoedas[ i ] := aTxMoedas[ i ] * nCoefici
		next i

		//Ajusta a Taxa conforme o intervalo de periodos estipulado: Anual ou Mensal -------------
		for i := 1 to __nQuantas
			aTxMoedas[ i ] := aTxMoedas[ i ] / IIf( cPeriodo == P_MENSAL, 1200, 100)
		next i
	endif

	SNT->( RestArea( aAreaNT ) )
	SN1->( RestArea( aAreaN1 ) )
	SN3->( RestArea( aAreaN3 ) )

Return ( aTxMoedas )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função    ³ CotaDegres ³ Autor ³ Norberto M Melo       ³ Data ³01/06/08  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cota de depreciação de acordo com a regra de cotas           ³±±
±±³          ³ decrescentes.                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function CotaDegres(cMoedaATF,cPeriodo,nMes)

	Local aResult		:= AtfMultMoe(,,{|x| 0}) 					//Valor de Retorno
	Local aLiquido		:= AtfMultMoe(,,{|x| 0}) 					//Valor Liquido - Auxiliar
	Local nAnosDecor	:= 0							//Tempo Decorrido em anos desde o início dos cálculos.
	Local nAnosRest		:= 0		  					//Tempo restante em anos para o término dos cálculos.
	Local aTaxaMax		:= AtfMultMoe(,,{|x| 0}) 
	Local i, j			:= 0							//Contador - Auxiliar
	Local lUsaCoefic	:= .T.							//Coeficiente aplicado sobre a Taxa de Depreciação

	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local __nQuantas := AtfMoedas()

	aTaxaMax   := MaxTxDegr( lUsaCoefic )
	nAnosDecor := 1 + ( Year( dDataBase ) - Year( SN3->( N3_DINDEPR ) ) )
	nAnosRest  := PrzTotPrev(cMoedaATF) - nAnosDecor

	for i := 1 to __nQuantas
		aLiquido[ i ] := SN3->&('N3_VORIG' + Alltrim(Str(i)) )
		for j := 1 to nAnosDecor
			//Regra: Quando a Cota Anual (VlLiquido * Taxa) FOR MENOR QUE (VlLiquido/Anos Restantes)
			//de vida util, considerar (VlLiquido/Anos Restantes).
			if (aLiquido[ i ] * ( aTaxaMax[ i ] / 100 )) < ( aLiquido[ i ] / nAnosRest )
				aResult[ i ] := aLiquido[ i ] / nAnosRest
				aLiquido[ i ] -= aResult[ i ]
			else
				aResult[ i ] := ( aLiquido[ i ] * ( aTaxaMax[ i ] / 100 ) )
				aLiquido[ i ] -= aResult[ i ]
			endif
		next j
		if cPeriodo == 'M'
			aResult[ i ] /= 12
		endif
	next i

Return aResult

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função    ³ PrzTotPrev  ³ Autor ³ Norberto M Melo       ³ Data ³01/06/08  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Tempo total para a depreciação em anos                        ³±±
±±³          ³ Se não informada através de N1_PRZDEPR efetua um cálculo utili³±±
±±³          ³ zando a taxa anual cadastrada no N3                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Valor numérico representado a quantidade em anos.             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Static Function PrzTotPrev( cMoedaATF )

	Local 	nPrzTotPrev	:= 1	//Valor de Retorno

	If (cPaisLoc == "PTG")
		if Empty( SN1->N1_PRZDEPR )
			nPrzTotPrev := 100 / SN3->&(IIf(Val(cMoedaATF)>9,"N3_TXDEP","N3_TXDEPR") + cMoedaATF)
		endif
	endif

Return nPrzTotPrev

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função    ³ MaxTxDegr   ³ Autor ³ Norberto M Melo       ³ Data ³01/06/08  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Taxa Máxima de Depreciação que via de regra deverá ser in
³±±
±±³          ³ mada no cadastro de grupos, porém na falta deste cadastro     ³±±
±±³          ³ será considerado o valor informado no N3                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExprL1 - Aplicar o coeficiente sobre a taxa                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Array com cinco elementos contendo a taxa respectiva de cada  ³±±
±±³          ³ moeda.                                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MaxTxDegr( lUsaCoefic )

	Local aMaxTxDegr:= AtfMultMoe(,,{|x| 0}) 
	Local aAreaNG	:= SNG->( GetArea( ) )		//Tabela de Grupos
	Local i 		:= 0								//Contador - Auxiliar
	Local nCoefici	:= 0

	SNG->( dbSetOrder( 1 ) )
	SNG->( DBSeek( xFilial( "SN1" ) + SN1->N1_GRUPO ) )
	for i := 1 to Len( aMaxTxDegr )
		if !SNG->( EOF() )
			aMaxTxDegr[ i ] := SNG->&( IIf(i>9,"NG_TXDEP","NG_TXDEPR") + Alltrim(Str(i)) )
		else
			aMaxTxDegr[ i ] := SN3->&( IIf(i>9,"N3_TXDEP","N3_TXDEPR") + Alltrim(Str(i)) )
		endif

		if lUsaCoefic
			aMaxTxDegr[ i ] *= IIf( SN3->N3_COEFICI > 0,SN3->N3_COEFICI, IIf( SNG->NG_COEFICI > 0, SNG->NG_COEFICI,1 ) )
		endif
	Next i

	SNG->( RestArea( aAreaNG ) )

Return aMaxTxDegr

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função    ³ Degressiva  ³ Autor ³ Norberto M Melo       ³ Data ³ 01/06/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Efetua o calculo da taxa Degressiva                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ ATFA050                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Degressiva(cMoedaATF, cPeriodo, nMes, aCotaM)

	Local i				:= 0						//Contador - Auxiliar
	Local cPos			:= 0						//Posição de Campo - Auxiliar
	Local nVlAtivo		:= 0
	Local nDeprAcum		:= 0
	Local nDif			:= 0
	Local aVlDepr		:= AtfMultMoe(,,{|x| 0})
	Local aCotas		:= CotaDegres(cMoedaATF, cPeriodo, nMes)

	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local __nQuantas := AtfMoedas()

	for i := 1 to __nQuantas

		cPos := Alltrim(Str(i))

		//Saldo de depreciação acumulada na moeda i
		nDeprAcum := SN3->( FieldGet( FieldPos(IIf(i>9,'N3_VRDAC','N3_VRDACM') + cPos ) ) )
		nDeprAcum += GetSldAcel( cPos )
		if i == 1
			//Este campo é tratado apenas na moeda 1
			nDeprAcum += SN3->( FieldGet( FieldPos('N3_VRCDA' + cPos ) ) )
		endif

		//Valor Total do Ativo na moeda i
		nVlAtivo := SN3->( FieldGet( FieldPos('N3_VORIG' + cPos ) ) )
		nVlAtivo += SN3->( FieldGet( FieldPos(IIf(i>9,'N3_AMPLI','N3_AMPLIA') + cPos ) ) )
		if i == 1
			//Este campo é tratado apenas na moeda 1
			nVlAtivo += SN3->( FieldGet( FieldPos(IIf(i>9,'N3_VRCAC','N3_VRCACM') + cPos ) ) )
		endif

		if Abs( nDeprAcum ) < Abs( nVlAtivo )
			aVlDepr[ i ] := Round( aCotas[ i ], X3Decimal("N3_VORIG" + cPos) )
			nDif := Abs( nVlAtivo ) - ( Abs( aValDepr[2] ) + Abs( nDeprAcum ) )
			if Round( nDif, X3Decimal( "N3_VORIG" + cPos ) ) <= 0
				aVlDepr[ i ] := nVlAtivo - nDeprAcum
			endif
		endif
	next i

	AtfMultMoe(,, {|x| aCotaM[x] := aCotaDepr[x] })

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CotaDepr  ºAutor  ³Microsiga           º Data ³  09/29/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function CotaDepr( aTaxaRef, aCotaM , lResid, nMoedaVMax, aRusModer )

	Local cMoedaAtf 	:= SuperGetMV("MV_ATFMOED")
	Local aGetArea		:= GetArea()
	Local nDiferenca	:= 0				// Auxiliar na verificacao de saldo residual.
	Local nCusto		:= 0				// Auxiliar Custo de Aquisição
	Local nDecimal		:= 0				// Auxiliar número de decimais
	Local i				:= 0				// Auxiliar Contador
	Local nMFiscal		:= Val(cMoedaAtf)	// O vlr zero exclui a condicao da moeda fiscal
	Local nDecTax		:= 0
	Local nPropBase		:= 0
	Local nValAmplia	:= 0
	Local lVlrMxDp		:= .F.
	Local lVlrSalv		:= SN3->N3_TPDEPR=='2'
	Local nVlrOriSal	:= 0 // Valor original - Valor de salvamento
	Local aRusMGTM		:= {}
	Local lCalcInd   := AF050IND()  // Verifica se o método de depreciaco é por indice calculado
	Local nCustOrig := 0
	Local cValRes   := Iif(cPaisLoc == "BOL" .And. SuperGetMv("MV_ZVALRES",.F.,"") == "1","1", "0")
	Local nVlDepre	:= 0
	Local aDepBefMod := {}
	Local cManTypes	  := IIF(lIsRussia,AtfNValMod({1,2,3},"|"),"") 
	Local nRound 		:= 0

	Local nVlrCota  := SuperGetMV("MV_ATFCOTA",.F., 0.99)

	Private aCotaDepr	:= AtfMultMoe(,,{|x| 0})  // Array com as posicoes relativas as cotas de depreciacao nas moedas.

	Default aCotaM := AtfMultMoe(,,{|x| 0})
	Default nMoedaVMax  := Iif(Val(SuperGetMV("MV_ATFMDMX",.F.," "))>0, Val(SuperGetMV("MV_ATFMDMX")), Val(cMoedaAtf))

	/*Verificacao do tratamento de valor maximo de depreciacao*/
	lVlrMxDp := nMoedaVMax > 0 .AND. SN3->N3_VMXDEPR > 0

	// Set accumulated depreciation for difference of cost for modernizated with managerial type	
	If lIsRussia		
		aDepBefMod := AtfMultMoe(,,{|x| 0})
		
		If !(SN3->N3_TIPO $ "01")
			aDepBefMod := RU01XFUN01_AccumDeprBeforeModer(SN3->N3_CBASE/*cBase*/, SN3->N3_ITEM/*cItem */, SN3->N3_TIPO/*cType*/, SN3->N3_SEQ/*cSeq*/, dDatabase/*dDtDepr*/)
		EndIf
		If (SN3->N3_TIPO $ cManTypes) .And. &("SN3->N3_AMPLIA"+cMoedaAtf) > 0
			aRusMGTM	:= RU01T06_R3LastModernization()
		EndIf
	EndIf

	/*Define regra de proporcionalizacao para outras moedas*/
	If lVlrMxDp .AND. nMoedaVMax > 9
		nValAmplia	:= &("N3_AMPLI" + Str(nMoedaVMax,1))
		If lIsRussia
			nValAmplia	-= RusMonthModer(aRusModer, nMoedaVMax)
		EndIf
		nPropBase 	:= SN3->N3_VMXDEPR /(&("N3_VORIG"  + Str(nMoedaVMax,1)) + nValAmplia)
	ElseIf lVlrMxDp .AND. nMoedaVMax <= 9
		nValAmplia	:= &("N3_AMPLIA" + Str(nMoedaVMax,1))
		If lIsRussia
			nValAmplia	-= RusMonthModer(aRusModer, nMoedaVMax)
		EndIf
		nPropBase 	:= SN3->N3_VMXDEPR /(&("N3_VORIG"  + Str(nMoedaVMax,1)) + nValAmplia)
	ElseIf lVlrSalv
		nValAmplia	:= SN3->N3_AMPLIA1
		If lIsRussia
			nValAmplia	-= RusMonthModer(aRusModer, 1)
		EndIf
		nPropBase 	:= SN3->N3_VLSALV1 / SN3->(N3_VORIG1+nValAmplia)
	Endif

	If dInDepr <= dDataBase
		For i := 1 to Len( aCotaDepr )

			If cPaisLoc == "CHI" .and. ( i == 1 )
				nDecimal := 0
			Else
				nDecimal := X3Decimal( "N3_VORIG" + AllTrim(Str(i)) )
			Endif

 			If aTaxaRef[ i ] # 0

				nDecTax		:= TAMSX3("N3_VORIG"  + AllTrim(Str(i)))[2]
				If i<=9
					If cPaisloc == "BOL" .And. cValres == "1"
						nDeprAcum	:=  &("N3_VRDACM" + Str(i,1)) + GetSldAcel( Str(i,1) ) + 1
					Else
						nDeprAcum	:=  &("N3_VRDACM" + Str(i,1)) + GetSldAcel( Str(i,1) )
					EndIf
					nCusto		:=	&("N3_VORIG"  + Str(i,1)) + &("N3_AMPLIA" + Str(i,1))
				Else
					nDeprAcum	:=  &("N3_VRDAC" + Str(i,2)) + GetSldAcel( Str(i,2) )
					nCusto		:=	&("N3_VORIG" + Str(i,2)) + &("N3_AMPLI" + Str(i,2))
				EndIf

				If lIsRussia
					// Russian modernization performed on this month can't impact on depreciation
					nCusto	-= RusMonthModer(aRusModer, i) + IIf(Len(aRusMGTM) >= i, aRusMGTM[i], 0)
				EndIf

				// Tratamento da correção Monetária
				If i == 1
					nDeprAcum	+= N3_VRCDA1	// Round( N3_VRCDA1 / RecMoeda( dDataBase, i ), nDecimal )
					nCusto		+= N3_VRCACM1	// Round( N3_VRCACM1 / RecMoeda( dDataBase, i ), nDecimal )
				Endif

				If  i == nMoedaVMax .And. lVlrMxDp
					//habilita o "Valor maximo de depreciação" no calculo de depreciação na moeda definida
					nCusto	:=	iif(Empty(SN3->N3_VMXDEPR),nCusto, SN3->N3_VMXDEPR)
				ElseIf i != nMoedaVMax .And. lVlrMxDp
					// Proporcionaliza a base para as outras moedas
					If cPaisLoc <> "PTG"
						nCusto := ROUND(NOROUND(nCusto * Round(NoRound(nPropBase,nDecTax+1),nDecTax),nDecTax+1),nDecTax)
					Endif
				Endif

				If lVlrSalv .And. i == 1
					nVlrOriSal := nCusto - SN3->N3_VLSALV1
					nCusto := Abs(nCusto - nDeprAcum)
				ElseIf lVlrSalv .And. i >= 2
					nVlrOriSal := nCusto - ROUND(NOROUND(nCusto * Round(NoRound(nPropBase,nDecTax+1),nDecTax),nDecTax+1),nDecTax)
					nCusto := Abs(nCusto - nDeprAcum)
				EndIF

				// No calculo de curva de trafego a depreciacao é sobre o valor contabil ( Aquisicao - Depreciacao Acumulada)
				If lCalcInd
					nCustOrig := nCusto
					nCusto := Abs(nCusto - nDeprAcum )
				EndIf

				// Se possuir valor residual, efetua o calculo da cota.
				If ( !lVlrSalv .And. Abs( nDeprAcum ) <= Abs( nCusto ) ) .Or.;
					( lVlrSalv .And. Abs( nDeprAcum ) <= Abs( nVlrOriSal ) ) .Or.;
					( lCalcInd .And. Abs( nDeprAcum ) <= Abs( nCustOrig ) )
					If i == nMFiscal .AND. cPaisLoc == "PTG"     // Moeda FiscaL
						// Limites para o calculo de depreciacao da Moeda Fiscal de Portugal
						nVlDepre := nCusto * NOROUND(aTaxaRef[ i ],11)
						aCotaDepr[ i ] := If ( AtFimDeprF() .AND. Empty( SN3->N3_FIMDEPR ),Round( nVlDepre, nDecimal ), 0 )
					Else
						//aCotaDepr[ i ] := If ( Empty( SN3->N3_FIMDEPR )	,Round( nCusto * aTaxaRef[ i ], nDecimal ), 0 )
						If	!Empty( SN3->N3_FIMDEPR ) .and. ( Val( cMoedaAtf ) == i )
							aCotaDepr[ i ] := 0
						Else
							If lIsRussia
								aCotaDepr[ i ] := Round( (nCusto - aDepBefMod[i])  * aTaxaRef[ i ], nDecimal )
							Else							
								nVlDepre :=  nCusto * NOROUND(aTaxaRef[ i ],11)

								If ("N3_VORIG"  + AllTrim(Str(i))) == "N3_VORIG1"
									/* Lógica para arredondamento correto de depreciação */
									IF Left(Right(AllTrim(Str(nVlDepre)),4),1) == "5"
										IF Left(Right(AllTrim(Str(nVlDepre)),3),1) == "5"
											IF Left(Right(AllTrim(Str(nVlDepre)),2),1) == "5"
												IF Right(Str(nVlDepre),1) == "5"
													nRound	:= NoRound(nVlDepre,5)
													nRound	:= NoRound(nRound, 4)
													nRound	:= NoRound(nRound, 3)
													nRound	:= NoRound(nRound, nDecimal)
													aCotaDepr[ i ] := nRound
												Else
													nRound	:= NoRound(nVlDepre, 4)
													nRound	:= NoRound(nRound, 3)
													nRound	:= NoRound(nRound, nDecimal)
													aCotaDepr[ i ] := nRound
												EndIf
											Else
												nRound	:= NoRound(nVlDepre, 3)
												nRound	:= NoRound(nRound, nDecimal)
												aCotaDepr[ i ] := nRound
											EndIf
										Else
											nRound	:= NoRound(nVlDepre, 3)
											nRound	:= NoRound(nRound, nDecimal)
											aCotaDepr[ i ] := nRound
										EndIf	
									Else
										//Conforme regra da procedure
										nRound	:= Round(nVlDepre, nDecimal)
										aCotaDepr[ i ] := nRound
									EndIf	
									/* fim arredondamento de depreciação */															
								Else //antigo processo para moedas != 1
									aCotaDepr[ i ] := Round( nVlDepre , nDecimal )
								EndIf	
							EndIf		
						EndIf
					Endif
					// Verifica se o valor da cota eh maior do que o valor residual.
					If lVlrSalv
						nDiferenca := Abs(nVlrOriSal) - ( Abs(aCotaDepr [ i ]) + Abs(nDeprAcum) )
					ElseIf lCalcInd
						nDiferenca := Abs(nCustOrig) - ( Abs(aCotaDepr [ i ]) + Abs(nDeprAcum) )
					Else
						nDiferenca := Abs(nCusto) - ( Abs(aCotaDepr [ i ]) + Abs(nDeprAcum) )
					EndIf

					// Residuo inferior a 1 (uma) unidade monetaria sera adicionado a cota atual.
					If  lCalcInd .And. Round( nDiferenca, nDecimal ) <= nVlrCota
						aCotaDepr[ i ] := nCustOrig - nDeprAcum
					ElseIf !lVlrSalv .And. Round( nDiferenca, nDecimal ) <= nVlrCota
						aCotaDepr[ i ] := nCusto - nDeprAcum
					ElseIf lVlrSalv .And. Round( nDiferenca, nDecimal ) <= nVlrCota
						aCotaDepr[ i ] := nVlrOriSal - nDeprAcum
					Endif
				Endif
			EndIf	
		Next i
	Endif

	If cTCalcAF == "1"	// Saldos Decrescentes
		Degressiva( cMoedaATF, cPerRegres, nMesRegres, ACotaM )
	EndIf

	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	AtfMultMoe(,,{|x| aCotaM[x] := aCotaDepr[x] })

	RestArea( aGetArea )

Return ( aCotaDepr )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GetTxDepr ºAutor  ³Microsiga           º Data ³  09/29/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function GetTxDepr( nTxPerdida, aRusModer )

	Local aArea			:= GetArea()	// Guarda a area atual
	Local nDiasParcial	:= 0
	Local i				:= 0
	Local cMoedaAtf 	:= GetMV( "MV_ATFMOED" )
	Local nDecimal		:= 8			// X3Decimal( "N3_VORIG" + cMoedaAtf )
	Local lCalcProp		:= .F.
	Local nRusModI		:= 0
	Local aRusFatPar	:= {}
	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local __nQuantas := AtfMoedas()
	Local nX := 0
	Local cManTypes	  := IIF(lIsRussia,AtfNValMod({1,2,3},"|"),"") 
	Local nTxRtFact := 0

	DBSelectArea( "SN3" )
	dInDepr		:= SN3->N3_DINDEPR
	AtfBloqueio( SN3->(N3_CBASE + N3_ITEM), @dBloqueio)	// Verifica o bloqueio do bem ou do grupo

	If !lN3Deprec .And. ! ( cPaisLoc $ "POR|EUA|PTG" ) //cPaisLoc $ "BRA|ANG"

		lCalcProp := .F.
		// *******************************
		// Controle de multiplas moedas  *
		// *******************************
		aTaxaMes := AtfMultMoe("SN3","N3_TXDEPR")

		aRusFatPar	:= Nil
		If lIsRussia

			// Russian modernization performed on this month can't impact on depreciation
			nRusModI	:= AScan(aRusModer, {|x| ;
				x[1] + x[2] + x[3] + x[4] + x[5] == ;
				SN3->(N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_TPSALDO) })
			If nRusModI > 0
				For nX := 1 To Len(aTaxaMes)
					aTaxaMes[nX]	:= NoRound(aTaxaMes[nX] - aRusModer[nRusModI,6], TAMSX3('N3_TXDEPR1')[2])
				Next nX

				// Same logic performed on AFatorCalc for Nil aParam but replace N3_PERDEPR for old value
				aRusFatPar 		:= Array(9)
				aRusFatPar[1]	:= SN3->N3_VORIG1
				aRusFatPar[2]	:= SN3->N3_VRDACM1
				aRusFatPar[3]	:= SN3->N3_TPDEPR
				aRusFatPar[4]	:= SN3->N3_VMXDEPR
				aRusFatPar[5]	:= RU01T03_S3ReturnPerDep(&("SN3->N3_TXDEPR" + cMoedaAtf) - aRusModer[nRusModI,6], cCalcDep == "1")
				aRusFatPar[6]	:= SN3->N3_VLSALV1
				aRusFatPar[7]	:= SN3->N3_PRODMES
				aRusFatPar[8]	:= SN3->N3_PRODANO
				aRusFatPar[9]	:= SN3->N3_FIMDEPR
			ElseIf (SN3->N3_TIPO $ cManTypes)
				nTxRtFact := SN3->N3_PERDEPR/(SN3->N3_PERDEPR - RU01XFUN02_MonthBeforeModer(SN3->N3_CBASE, SN3->N3_ITEM, SN3->N3_TIPO, SN3->N3_SEQ))
				For nX := 1 to Len(aTaxaMes)
					aTaxaMes[nX] := Round(aTaxaMes[nX]*nTxRtFact, TAMSX3('N3_TXDEPR1')[2])
				Next nX
			EndIf
		EndIf

		If	MesAnoAtf( dInDepr ) <> MesAnoAtf( dDataBase ) .And.;
			cModoBlq == "1" .And.;
			!Empty( dBloqueio ) .And.;
			MesAnoAtf( dBloqueio ) == MesAnoAtf( dDataBase )
			aTaxaMes := AFatorCalc(aTaxaMes, dBloqueio, dDataBase, cTipDepr, cCalcDep, Nil, aRusFatPar)
		Else
			aTaxaMes := AFatorCalc(aTaxaMes, dInDepr  , dDataBase, cTipDepr, cCalcDep, Nil, aRusFatPar)
		EndIf

		If lIsRussia .and. SN3->N3_TPDEPR == "F" // full depreciation
			For nX := 1 to len(aTaxaMes)
				aTaxaMes[nX] := 1
			Next nX
		Endif

	ElseIf cPaisLoc == "BRA" .And. lN3Deprec .And. !Empty( SN3->N3_DEPREC ) // Verifica se sera' usada a forma de calculo "Safra Fundada - Usina Cerradinho"

		lCalcProp := .F.
		// *******************************
		// Controle de multiplas moedas  *
		// *******************************
		aTaxaMes[1] := ( CalcTaxa( SN3->N3_DEPREC ) / 12) / 100
		aTaxaMes := AtfMultMoe(,,{|x| IIf(x=1,aTaxaMes[1] := aTaxaMes[1], aTaxaMes[x] := aTaxaMes[1]) })

	ElseIf !(cPaisLoc $ "BRA|PTG") .And. lN3Deprec .And. !Empty( SN3->N3_DEPREC ) .and. SN3->N3_TPDEPR $ " 1" // Verifica se sera' usada a forma de calculo baseada na string do N3_DEPREC
		lCalcProp := .T.
		// *******************************
		// Controle de multiplas moedas  *
		// *******************************
		aTaxaMes[1] := ( CalcTaxa( SN3->N3_DEPREC ) / 12) / 100
		aTaxaMes := AtfMultMoe(,,{|x| aTaxaMes[x] := Round( (SN3->(&( "N3_TXDEPR"+Alltrim(Str(x)) )/12)/100), nDecimal ) })

	ElseIf cPaisLoc == "POR"
		lCalcProp := .T.
		// *******************************
		// Controle de multiplas moedas  *
		// *******************************
		aTaxaMes[1] := (A050TxDepr()/12)/100
		aTaxaMes := AtfMultMoe(,,{|x| IIf(x=1,aTaxaMes[1] := aTaxaMes[1], aTaxaMes[x] := aTaxaMes[1] ) })
	ElseIf cPaisLoc $ "PTG|EUA"
		lCalcProp := .T.

		If cPaisLoc == "EUA" .And. SN3->N3_TPDEPR $ "2|3"
			aTaxaMes[1] := (A050TxDepr()/12)/100

		ElseIf cTCalcAF == "0"	// Linear
			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			aTaxaMes[1] := ( CalcTaxa( SN3->N3_DEPREC ) / 12) / 100
			aTaxaMes := AtfMultMoe(,,{|x| aTaxaMes[x] := Round( (SN3->(&( "N3_TXDEPR"+Alltrim(Str(x)) )/12)/100), nDecimal ) })
		Else										//	Regressiva
			aTaxaMes := TxRegres( @nTxPerdida, cMoedaATF, cPerRegres, nMesRegres )
		EndIf
	Endif

	// Regra de proporcionalização de calculo de depreciação utilizada por alguns métodos / paises.
	If lCalcProp
		If cPaisLoc <> "ARG"
			If		MESANOAtf(dInDepr) == MesAnoAtf(dDataBase) .and.;
			Day(dInDepr) > 1 .And.;
			!lMesCheio
				nDiasParcial := Day( LastDay(dDataBase) ) - Day( dInDepr ) + 1
				For i := 1 to __nQuantas
					aTaxaMes[ i ] := aTaxaMes[ i ] * ( nDiasParcial / Day(LastDay(dDataBase)) )
				Next i
				//Calculo da taxa no caso de bloqueio proporcional
			ElseIf	cModoBlq == "1" .AND.;
			!Empty(dBloqueio) .AND.;
			MESANOAtf(dBloqueio) == MesAnoAtf(dDataBase)
				nDiasParcial := Day(LastDay(dDataBase))- Day(dBloqueio) + 1
				For i := 1 to 5
					aTaxaMes[ i ] := aTaxaMes[ i ] * ( nDiasParcial / Day(LastDay(dDataBase)) )
				Next
			EndIf
		Else
			If	MESANOAtf(SN3->N3_DINDEPR) == MesAnoAtf(dDataBase) .and.;
			Day(SN3->N3_DINDEPR) > 1 .And. !lMesCheio
				If (cAliasSn1)->N1_CONSAB == "1"
					nDiasParcial := (LastDay(dDataBase) - FirstDay(dDataBase)) + 1
				Else
					nDiasParcial := Day(LastDay(dDataBase)) - Day(SN3->N3_DINDEPR) + 1
				EndIf
				For i := 1 to __nQuantas
					aTaxaMes[ i ] := aTaxaMes[ i ] * ( nDiasParcial /  Day(LastDay(dDataBase)) )
				Next
			EndIf
		EndIf
	Endif

	RestArea( aArea )

Return nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³IncMovSN4 ºAutor  ³Microsiga           º Data ³  09/29/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function IncMovSN4(cOcorr, aVLROC, cTipoCNT, cCodCusto, cContaCap,cIDMOV)

	Local lResult	:= .T.
	Local cMoedaAtf	:= GetMV( "MV_ATFMOED" )
	Local aDadosComp :={}
	Local nTaxaMedia := 0
	Local nTxDepre	 := 0
	Local aEntidades := {'','','',''}
	Local cTpSaldo	:= ""
	Local lSN3Saldo := .T.
	Local cPadrao		:= "820"
	Local cTypesNM		:= IIF(lIsRussia,"/" + AtfNValMod({1,2,3,4}, "/"),"") // CAZARINI - 10/04/2017 - If is Russia, add new valuations models - main and recoverable models
	Default cCodCusto	:= CriaVar("N3_CCUSTO")
	Default cContaCap	:= GetMv("MV_CONTACO")
	Default cIDMOV	:= ""

	/*
	N3_VORIG1	// Custo de Aquisicao
	N3_VRDMES1	// Depreciacao acumulada no Mes
	N3_VRDBAL1	// Depreciacao acumulada no Exercicio
	N3_VRDACM1	// Depreciacao acumulada Geral
	N3_VRCMES1	// Correcao s/Custo de Aquisicao no Mes
	N3_VRCBAL1	// Correcao s/Custo de Aquisicao Acumulada no Exercicio
	N3_VRCACM1	// Correcao s/Custo de Aquisicao Acumulada Geral
	N3_VRCDB1	// Correcao s/Depreciacao Acumulada no Mes
	N3_VRCDB1	// Correcao s/Depreciacao Acumulada no Exercicio
	N3_VRCDA1	// Correcao s/Depreciacao Acumulada no Geral
	*/

	While Len( aVLROC ) < 5
		AADD(aVLROC, 0)
	End

	//22/07/2010
	PcoIniLan("000363")

	If lResult
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³N4_TIPOCNT - Tipo da Conta Envolvida no Movimento³
		//³ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
		//³1 - Conta do Bem                                 ³
		//³2 - Conta de Correcao do Bem                     ³
		//³3 - Conta de Despesa de Depreciacao              ³
		//³4 - Conta de Depreciacao Acumulada               ³
		//³5 - Conta de Correcao da Depreciacao Acumulada   ³
		//³6 - Conta de Correcao da Conta de Capital Social ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cTipoCNT $ "3|4" .and. Empty( cOcorr )
			Do Case
				Case SN3->N3_TIPO == "07"	// Depreciacao acelerada
				cOcorr	:= "10"			// Aceleracao Positiva
				Case SN3->N3_TIPO == "08"	// Depreciacao incentivada positiva
				cOcorr	:= "12"			//
				Case SN3->N3_TIPO == "09"	// Depreciacao incentivada negativa
				cOcorr	:= "11"			// Aceleracao Negativa
				Case SN3->N3_TIPO $  ("10|12|14|15|16|17|50|51|52|53|54" + cTypesNM) 			//AVP
				If lIsRussia
					cOcorr	:= "06"			// Depreciacao Gerencial
				Else
					cOcorr	:= "20"			// Depreciacao Gerencial
				EndIf
				OtherWise
				cOcorr	:= "06"			// Depreciacao
			EndCase
		Endif

		If cOcorr $ "06/10/20"
			nTxDepre := aTaxaMes[ Val( cMoedaAtf ) ]		// Taxa de Depreciacao 
		Else
			nTaxaMedia	:= aTxMedia[ Val( cMoedaAtf ) ]		// Indice de Correcao Monetaria
		Endif

		If	cTipoCNT == "1"	// Conta do Bem
			aEntidades[1]		:= SN3->N3_CCONTAB
			aEntidades[2]		:= cCodCusto
			aEntidades[3]		:= SN3->N3_SUBCCON
			aEntidades[4]       := SN3->N3_CLVLCON
		ElseIf	cTipoCNT == "2"	// Conta de Correcao do Bem
			aEntidades[1]		:= SN3->N3_CCORREC
			aEntidades[2]		:= SN3->N3_CCCORR
			aEntidades[3]		:= SN3->N3_SUBCCOR
			aEntidades[4]       := SN3->N3_CLVLCOR
		ElseIf	cTipoCNT == "3"	// Conta de Despesa da Depreciacao
			aEntidades[1]		:= SN3->N3_CDEPREC
			aEntidades[2]		:= SN3->N3_CCDESP
			aEntidades[3]		:= SN3->N3_SUBCDEP
			aEntidades[4]       := SN3->N3_CLVLDEP
		ElseIf	cTipoCNT == "4"	// Conta de Depreciacao Acumulada
			aEntidades[1]		:= SN3->N3_CCDEPR
			aEntidades[2]		:= SN3->N3_CCCDEP
			aEntidades[3]		:= SN3->N3_SUBCCDE
			aEntidades[4]       := SN3->N3_CLVLCDE
		ElseIf	cTipoCNT == "5"	// Conta de Correcao da Depreciacao Acumulada
			aEntidades[1]		:= SN3->N3_CDESP
			aEntidades[2]		:= SN3->N3_CCCDES
			aEntidades[3]		:= SN3->N3_SUBCDES
			aEntidades[4]       := SN3->N3_CLVLDES
		ElseIf	cTipoCNT == "6"	// Conta de correcao da conta de Capital Social
			aEntidades[1]		:= cContaCap
		ElseIf	cTipoCNT == '7'	// CONTA DE DEPREICACAO CORRECAO ( ARG )
			aEntidades[1]		:= SN3->N3_CDPCOMM
		ElseIf	cTipoCNT == "8"
			If cPaisLoc == "ARG"	//CONTA DE DEPREcIACAO ACUMULADA CORRECAO ( ARG )
				aEntidades[1]		:= SN3->N3_CDPCOMA
			Else
				aEntidades[1]		:= SN3->N3_CDEPREC
				aEntidades[2]		:= SN3->N3_CCCDEP
				aEntidades[3]		:= SN3->N3_SUBCCDE
				aEntidades[4]       := SN3->N3_CLVLCDE
			EndIf
		ElseIf	cTipoCNT == "9"	//
			aEntidades[1]		:= SN3->N3_CDEPREC
			aEntidades[2]		:= SN3->N3_CCCDES
			aEntidades[3]		:= SN3->N3_SUBCDES
			aEntidades[4]       := SN3->N3_CLVLDES
		Endif

		aDadosComp := ATFXCompl(nTaxaMedia, nTxDepre,/*cMotivo*/,/*cCodBaix*/,/*cFilOrig*/,/*cSerie*/,/*cNota*/,/*nVenda*/,/*cLocal*/, SN3->N3_PRODMES )
		aVLROC[1] := Round( aVLROC[1], IIf(cPaisLOc=="CHI", 0, X3Decimal("N4_VLROC1")) )
		If lSN3Saldo
			cTpSaldo := SN3->N3_TPSALDO
		EndIf
		ATFXMOV(cFilAnt,@cIDMOV,dDataBase,cOcorr,SN3->N3_CBASE,SN3->N3_ITEM,SN3->N3_TIPO,SN3->N3_BAIXA,SN3->N3_SEQ,SN3->N3_SEQREAV,cTipoCNT,0,cTpSaldo,aEntidades,aVLROC,aDadosComp,,,,,.F.,cPadrao)
		PcoDetLan("000363","01","ATFA050")
	EndIf

	PcoFinLan("000363")

Return lResult

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³AtzSldSN3 ºAutor  ³Microsiga           º Data ³  09/29/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function AtzSldSN3(aValDepr, nVarIPC, nN3VDPCOMM, nValCorr, nSldAcelM1, nSldAcelMP,;
							nCalcRes, aPFimDepr, nMesCalc, nMoedaVMax, lCheck070 )

	Local lResult	:= .T.
	Local cMoedaAtf	:= GetMV( "MV_ATFMOED" )
	Local lVlrMxDp	:= .F.
	Local nDiasDep	:= 0
	Local nDiasMes	:= 0
	Local nFator	:= 0
	Local lVlrSalv	:= SN3->N3_TPDEPR=='2'
	Local cValRes   := Iif(cPaisLoc == "BOL" .And. SuperGetMv("MV_ZVALRES",.F.,"") == "1","1", "0")

	Default nMoedaVMax    := Iif(Val(GetMv("MV_ATFMDMX",.F.," "))>0, Val(GetMv("MV_ATFMDMX")), Val(cMoedaAtf))
	Default lCheck070     := .F.


	/*Verificacao do tratamento de valor maximo de depreciacao*/
	lVlrMxDp := nMoedaVMax > 0 .AND. SN3->N3_VMXDEPR > 0

	SN3->(RecLock("SN3", .F.))
	// Se for um item gerado pelo ATFA035, marca que ja foi calculada depreciacao para nao ser calculada no proximo calculo
	/*If  SN3->N3_NOVO == "1"
		SN3->N3_NOVO := "2"
	EndIf*/

	If lAcelMes
		//Caso já haja aceleracao, soma o valor da depreciacao mensal.
		// *******************************
		// Controle de multiplas moedas  *
		// *******************************
		AtfMultMoe("SN3","N3_VRDMES",{|x| SN3-> &(IIf(x>9,"N3_VRDME","N3_VRDMES")+Alltrim(Str(x))) + Round( aValDepr[x], IIf(cPaisLoc=="CHI" .and. x==1, 0, X3Decimal(IIf(x>9,"N3_VRDME","N3_VRDMES")+Alltrim(Str(x))))) })
	Else
		// *******************************
		// Controle de multiplas moedas  *
		// *******************************
		AtfMultMoe("SN3","N3_VRDMES",{|x| Round( aValDepr[x], IIf(cPaisLoc=="CHI" .and. x==1, 0, X3Decimal( IIf(x>9,"N3_VRDME","N3_VRDMES")+Alltrim(Str(x)) ))) })
	EndIf

	If  cPaisLoc != "CHI"
		If lIsRussia .And. lCheck070
			AtfMultMoe("SN3","N3_VRDACM",{|x| SN3->&(IIF(x>9,"N3_VRDAC","N3_VRDACM")+ALLTRIM(STR(x))) - ROUND( aValDepr[x] , X3Decimal(IIF(x>9,"N3_VRDAC","N3_VRDACM")+Alltrim(STR(x)))) })
		Else
			AtfMultMoe("SN3","N3_VRDACM",{|x| SN3->&(IIf(x>9,"N3_VRDAC","N3_VRDACM")+Alltrim(Str(x))) + IIf( x==1 .AND. cPaisLoc == "CHI", Round( aValDepr[1], 0), Round( aValDepr[x] , X3Decimal(IIf(x>9,"N3_VRDAC","N3_VRDACM")+Alltrim(Str(x))))) })
		EndIf
	Else
		SN3-> N3_VRDACM1 += Round( aValDepr[1], IIf( cPaisLoc == "CHI", 0, X3Decimal("N3_VRDACM1") ) )
		SN3-> N3_VRDACM2 += Round( aValDepr[2], X3Decimal("N3_VRDACM2") )
		SN3-> N3_VRDACM3 += Round( aValDepr[3], X3Decimal("N3_VRDACM3") )
		SN3-> N3_VRDACM4 += Round( aValDepr[4], X3Decimal("N3_VRDACM4") )
		SN3-> N3_VRDACM5 += Round( aValDepr[5], X3Decimal("N3_VRDACM5") )
	EndIf

	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	If  cPaisLoc != "CHI"
		AtfMultMoe("SN3","N3_VRDBAL",{|x| SN3->&(IIf(x>9,"N3_VRDBA","N3_VRDBAL")+Alltrim(Str(x))) + IIf( x==1 .AND. cPaisLoc == "CHI", Round( aValDepr[1], 0), Round( aValDepr[x] , X3Decimal(IIf(x>9,"N3_VRDBA","N3_VRDBAL")+Alltrim(Str(x))))) })
	Else
		SN3-> N3_VRDBAL1 += Round( aValDepr[1],  IIf( cPaisLoc == "CHI", 0, X3Decimal("N3_VRDBAL1") ) )
		SN3-> N3_VRDBAL2 += Round( aValDepr[2], X3Decimal("N3_VRDBAL2") )
		SN3-> N3_VRDBAL3 += Round( aValDepr[3], X3Decimal("N3_VRDBAL3") )
		SN3-> N3_VRDBAL4 += Round( aValDepr[4], X3Decimal("N3_VRDBAL4") )
		SN3-> N3_VRDBAL5 += Round( aValDepr[5], X3Decimal("N3_VRDBAL5") )
	EndIf

	If !Empty( SN3->N3_CCORREC )
		// Customizacao da Correcao Monetaria para a Argentina Boletim 00004935-08
		If cPaisLoc == 'ARG';
			.AND. SN3->N3_VDPCOMM > 0;
			.AND. SN3->N3_VDPCOMA > 0;
			.AND. SN3->N3_CDPCOMM > 0;
			.AND. SN3->N3_CDPCOMA > 0

			If !Empty(SN3->N3_CDPCOMM)
				SN3->N3_VDPCOMM   := nN3VDPCOMM
			EndIf
			If !Empty(SN3->N3_CDPCOMA)
				SN3->N3_VDPCOMA   += Round((SN3->N3_VDPCOMM) ,X3Decimal("N3_VDPCOMA"))
			EndIf
		EndIf

		If cPaisloc == "BOL" .And. cValRes == "1"
			nValCorr:=Round( nValCorr  , Iif(cPaisLoc == "CHI",2,X3Decimal("N3_VRCMES1")) )
			nValCorD:=Round( nValCorDep , Iif(cPaisLoc == "CHI",2,X3Decimal("N3_VRCDM1")) )

			NdifCalO:= Round((N3_VORIG1 + N3_VRCACM1 + N3_AMPLIA1+nValCorr),2) - Round((N3_VRDACM1 + N3_VRCDA1+nValCorD+1),2)
			NdifCalD:= Round((N3_VRDACM1 + N3_VRCDA1+nValCorD+1),2) - Round((N3_VORIG1 + N3_VRCACM1 + N3_AMPLIA1+nValCorr),2)

			ldif := IIF((N3_VORIG2 + N3_AMPLIA2) - N3_VRDACM2<= 1,.T.,.F.)

			If NdifCalO <0 .AND. nValCorD > 0 .and. ldif
				nValCorD:= ABS(nValCorD) - ABS(NdifCalO)
			Endif

			If NdifCalD <0 .AND. nValCorr > 0  .and. (ldif .and. aValDepr[1] > 0)
				nValCorr:=  ABS(NdifCalD) - ABS(nValCorr)
			EndIf

			If aValDepr[1] == 0 .and. ldif
				nValCorD := nValCorr
			Endif

			SN3-> N3_VRCMES1 := nValCorr //Correc do Bem no Mes
			SN3-> N3_VRCACM1 += nValCorr //Correc Acu do Bem
			SN3-> N3_VRCBAL1 += nValCorr //Correc Acu Exercicio

			SN3-> N3_VRCDM1  :=	nValCorD //Correc Depr no Mes
			SN3-> N3_VRCDB1  += nValCorD //Correc Depr Acu Exercicio
			SN3-> N3_VRCDA1  += nValCorD //Correc Depr Acumulada
		Else
			SN3-> N3_VRCMES1 := Round( nValCorr  , Iif(cPaisLoc == "CHI",0,X3Decimal("N3_VRCMES1")) ) //Correc do Bem no Mes
			SN3-> N3_VRCACM1 += Round( nValCorr  , Iif(cPaisLoc == "CHI",0,X3Decimal("N3_VRCACM1")) ) //Correc Acu do Bem
			SN3-> N3_VRCBAL1 += Round( nValCorr  , Iif(cPaisLoc == "CHI",0,X3Decimal("N3_VRCBAL1")) ) //Correc Acu Exercicio

			SN3-> N3_VRCDM1  := Round( nValCorDep , Iif(cPaisLoc == "CHI",0,X3Decimal("N3_VRCDM1")) ) //Correc Depr no Mes
			SN3-> N3_VRCDB1  += Round( nValCorDep , Iif(cPaisLoc == "CHI",0,X3Decimal("N3_VRCDB1")) ) //Correc Depr Acu Exercicio
			SN3-> N3_VRCDA1  += Round( nValCorDep , Iif(cPaisLoc == "CHI",0,X3Decimal("N3_VRCDA1")) ) //Correc Depr Acumulada
		EndIf
	EndIf

	// Verifica o saldo a depreciar. Se zerou atualiza o campo N3_FIMDEPR.
	If	round(ABS(SN3->N3_VRDACM1) + ABS(nSldAcelM1) +ABS(SN3->N3_VRCDA1),2) >= ABS(SN3->N3_VORIG1) + ABS(SN3->N3_AMPLIA1) .And.;
	(ABS(&('SN3->N3_VRDACM'+cMoedaAtf)) + ABS(nSldAcelMP)) >= (ABS(&('SN3->N3_VORIG'+cMoedaAtf)) + IIf(	cMoedaAtf == '1',ABS(SN3->N3_VRCACM1),0) + ABS(&('SN3->N3_AMPLIA'+cMoedaAtf))) .And.;
	Empty( SN3->N3_FIMDEPR )
		If 	((SN3->N3_VORIG1 + SN3->N3_VRCACM1 + SN3->N3_AMPLIA1)-(SN3->N3_VRDACM1 + SN3->N3_AMPLIA1 + SN3->N3_VRCDA1)) < 0
			SN3->N3_VRDACM1 += 	(SN3->N3_VORIG1 + SN3->N3_AMPLIA1 + SN3->N3_VRCACM1)-(SN3->N3_VRDACM1 + SN3->N3_VRCDA1)
			SN3->N3_VRDBAL1 += 	(SN3->N3_VORIG1 + SN3->N3_AMPLIA1 + SN3->N3_VRCACM1)-(SN3->N3_VRDACM1 + SN3->N3_VRCDA1)
		EndIf

		// Se o saldo zerou atraves do tipo 07, deve-se atualizar o tipo 01
		If SN3->N3_TIPO == '07'
			//Guarda o ID do bem para atualizacao posterior do tipo 01
			AADD( aPFimDepr, SN3->N3_FILIAL + SN3->N3_CBASE + SN3->N3_ITEM + '01' )
		EndIf
		SN3->N3_FIMDEPR := dDataBase
	ElseIf	cPaisLoc == "CHI" .AND.;
	Round( (N3_VORIG1 + N3_CLVRCOA + N3_VRCBAL1) - (N3_VRDACM1 + N3_VRCDA1), 0 ) <= 0
		SN3->N3_FIMDEPR 	:= dDataBase
	ElseIf cPaisLoc $ "ARG"
		If nMesCalc = 1 .and. Empty( SN3->N3_FIMDEPR )
			SN3->N3_FIMDEPR := dDataBase
		EndIf

	ElseIf lVlrMxDp .AND. EMPTY(SN3->N3_FIMDEPR) .AND. IIF(nMoedaVMax<=9,&('SN3->N3_VRDACM'+STR(nMoedaVMax,1)), &('SN3->N3_VRDAC'+STR(nMoedaVMax,1)))  >= SN3->N3_VMXDEPR
		SN3->N3_FIMDEPR := dDataBase
	ElseIf lVlrSalv .AND. EMPTY(SN3->N3_FIMDEPR) .AND. SN3->N3_VRDACM1  >= SN3->N3_VORIG1 - SN3->N3_VLSALV1
		SN3->N3_FIMDEPR := dDataBase
	ElseIf cPaisLoc=="BOL"	.AND. EMPTY(SN3->N3_FIMDEPR) .And. round(ABS(SN3->N3_VRDACM1+1) + ABS(nSldAcelM1) +ABS(SN3->N3_VRCDA1),0) >=;
		ABS(SN3->N3_VORIG1) + ABS(SN3->N3_AMPLIA1)
		SN3->N3_FIMDEPR := dDataBase
	EndIf

	SN3->( msUnlock() )

Return lResult

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GetCodCustoºAutor  ³Microsiga          º Data ³  09/30/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function GetCodCusto( cTPConta, cCodCusto, cPadrao, aValMov )

	Local lResult	:= .T.
	Local lPadrao	:= VerPadrao( "820" )

	Default cCodCusto	:= CriaVar( "N3_CCUSTO" )

	If lResult
		If mv_par01 < 3   // 1-Mostra, 2-Nao Mostra, 3-Nao Contabiliza
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Se o usuario desejar utilizar centro de custo (MV_PAR03 ==1 ), a cada  ³
			//³ despesa ser  considerado, caso contr rio, dever  ser analisado a obriga³
			//³ toriedade do centro de custo na CONTA, se for obrigado o mesmo dever   ³
			//³ ser considerado.                                                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If mv_par03 == 1		// considerar centro de custo
				If cTPConta == "DEPRECIACAO"
					cCodCusto := SN3->N3_CCUSTO		// Depreciacao no Mes
				ElseIf	cTPConta == "CORRECAO"
					cCodCusto := SN3->N3_CUSTBEM	// Correcao no Mes
				EndIf
			Else					// nao considerar
				If lCtb
					If cTPConta == "DEPRECIACAO"
						cCodCusto := SN3->N3_CCUSTO				// Depreciacao no Mes
					ElseIf	cTPConta == "CORRECAO"
						dbSelectArea("CT1")
						CT1->( dbSetOrder( 1 ) )
						If CT1->( dbSeek(xFilial("CT1") + SN3->N3_CCONTAB) )
							If CT1->CT1_ACCUST <> "2"			// se nao aceita CC eh preenchido 2
								cCodCusto := SN3->N3_CUSTBEM	// Correcao no Mes
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf

			dbSelectArea("SN3")
		EndIf
	EndIf

Return ( lResult )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ GetTaxas ºAutor  ³Microsiga           º Data ³  09/30/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Transfere as taxas das moedas para um array e pega a ultima º±±
±±º          ³taxa do mes Anterior                                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetTaxas( bContador, lHelp )

	Local lResult	:= .T.
	Local aGetTaxas	:= {}
	Local aArea		:= GetArea()

	Default bContador	:= {|nInc| .T. }
	Default lHelp		:= .F.

	DbSelectArea( "SM2" )

	// ---------------------------------------------------------------------------------------------------
	// Preenche array com o ultimo indice do mes anterior
	// Se nao encontrar inclui um registro igual ao do primeiro dia da data base,
	// porem com data do dia anterior
	// ---------------------------------------------------------------------------------------------------
	If SM2->( DbSeek( (FirstDay(dDataBase) - 1) ) )
		// *******************************
		// Controle de multiplas moedas  *
		// *******************************
		AAdd(aGetTaxas, {} )
		aGetTaxas[Len(aGetTaxas)] := AtfMultMoe(,,{|x| IIf(x=1, SM2->M2_Data, SM2->&("M2_Moeda"+Alltrim(Str(x))) ) })
	elseIf	SM2->( DbSeek( (FirstDay(dDataBase) ) ) )
		// *******************************
		// Controle de multiplas moedas  *
		// *******************************
		AAdd(aGetTaxas, {} )
		aGetTaxas[Len(aGetTaxas)] := AtfMultMoe(,,{|x| IIf(x=1, (FirstDay(dDataBase) - 1), 1 ) })
	Endif

	// ---------------------------------------------------------------------------------------------------
	// Preenche array com os indices do cadastro de moedas
	// ---------------------------------------------------------------------------------------------------
	SM2->( DbSeek( FirstDay(dDataBase), .T.) )
	While !SM2->( Eof() ) .And. SM2->M2_DATA <= LastDay(dDataBase)
		If Eval( bContador, 1 )	// Incrementa escala de processamento se houver.
			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			AAdd(aGetTaxas, {} )
			aGetTaxas[Len(aGetTaxas)] := AtfMultMoe(,,{|x| IIf(x=1, SM2->M2_Data, SM2->&("M2_Moeda"+Alltrim(Str(x))) ) })

			SM2->( dbSkip() )
		Else
			Exit
		Endif
	EndDo

	// ----------------------------------------------------------------
	// Exige que todas as moedas do mes a depreciar estejam cadastradas
	// ----------------------------------------------------------------
	If lHelp .and. Len( aGetTaxas ) != ( Day( LastDay(dDataBase) ) + 1 )
		Help( " ",1,"AF050MOEDA" )
		aGetTaxas := {}
	Endif

	RestArea( aArea )

Return ( aGetTaxas )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ValIndCM  ºAutor  ³Microsiga           º Data ³  10/02/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function ValIndCM( dInDepr, nTxVar )

	Local lResult := .T.

	Default dInDepr := SN3->N3_DINDEPR
	Default nTxVar	:= 0

	If lResult
		If	cPaisLoc == "ARG"
			lResult := ValIndARG( @dInDepr, @nTxVar )
		ElseIf	cPaisLoc == "CHI"
			lResult := ValIndCHI( @dInDepr, @nTxVar )
		Endif
	EndIf

Return ( lResult )




/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GetDtCalc ºAutor  ³Microsiga           º Data ³  10/05/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function GetDtCalc( dDataI, dDataF )

	Local lResult	:= .T.
	Local lMesCheio	:= SuperGetMv("MV_TIPDEPR",,"0") $ "14"	//Codigos para Mes Cheio

	If lResult
		dDataF := IIf( lMesCheio, LastDay( dDataBase ), dDataBase )

		If	cPaisLoc == "ARG"
			If SN1->N1_CONSAB == "1"
				lMesCheio := .T.
				If !Empty(SN3->N3_DTBAIXA)
					dDataF  := FirstDay( SN3->N3_DTBAIXA ) - 1
				Else
					dDataF  := LastDay( dDataBase )
				EndIf
			Else
				dDataF  := LastDay( dDataBase )
			EndIf
		EndIf

		dDataI  := IIf(	MesAnoAtf( SN3->N3_DINDEPR ) == MesAnoAtf( dDataBase ),;
		SN3->N3_DINDEPR,;	//IIf(	lMesCheio, FirstDay(SN3->N3_DINDEPR), SN3->N3_DINDEPR ),;
		FirstDay( dDataBase ) )

		If dDataBase < CtoD( "01/09/94","ddmmyy" )
			dDataF := IIf(	MesAnoAtf(SN3->N3_DtBaixa) = MesAnoAtf( dDataBase ), ;
			SN3->N3_DtBaixa,;
			LastDay( dDataBase ) )
		End

	EndIf

Return ( lResult )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GetTxCM   ºAutor  ³Microsiga           º Data ³  10/28/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetTxCM( nDias, cMoedaAtf, la30Embra, aIndMesAtu )

	Local lResult		:= .T.
	Local aResult		:= AtfMultMoe(,,{|x| 0}) 
	Local lCalcula		:= GetNewPar( "MV_CORREC", "N" ) == "S"	// Define se deve calcular a Correcao
	Local dDataI		:= CToD( "" )
	Local dDataF		:= CToD( "" )

	If !Empty( aIndMesAtu )
		aTaxas := aIndMesAtu
	Endif

	// Define as datas Inicial e Final
	GetDtCalc( @dDataI, @dDataF )

	If lResult .and. lCalcula	/*MV_CORREC*/
		If		cPaisLoc == "CHI"
			ValIndCHI( dDataI, @aResult[ Val( cMoedaATF ) ] )
		ElseIf	cMVATFMCCM == "M"	/*Media Simples*/
			aResult := GetTxMedia( dDataI, dDataF, cMoedaAtf, la30Embra )
		ElseIf	cMVATFMCCM == "V"	/*Variacao Mensal*/
			aResult := GetTxVariacao( dDataI, dDataF, cMoedaAtf, la30Embra )
		ElseIf	cMVATFMCCM == "F"	/*Informada p/Usuario no Parametro*/
			aResult[ Val( cMoedaATF ) ] := ( (nMVVALCORR /100) + 1 )
		ElseIf	cMVATFMCCM == "A"	/*Ajuste por inflação*/
			if (LastDay(SN1->n1_aquisic))==ddatabase
				SM2->( DbSeek( SN1->n1_aquisic ))
			Else
				SM2->( DbSeek( GetMv("MV_ULTDEPR") ))
			Endif
			aResult[ Val( cMoedaATF ) ] := ( aTaxas[Ascan( aTaxas, {|e| e[ 1 ] == dDataF } )][ Val( cMoedaATF )] / &('SM2->M2_MOEDA'+cMoedaATF ) )
		EndIf
	Endif

Return (aResult)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GetTxMediaºAutor  ³Microsiga           º Data ³  10/05/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function GetTxMedia( dDataI, dDataF, cMoedaAtf, la30Embra )

	Local lResult		:= .T.
	Local nMoeda		:= 0
	Local i				:= 0
	Local nDtLimite		:= 0
	Local nDtInicial	:= 0
	Local nInc			:= 0
	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local __nQuantas	:= AtfMoedas()
	Local aGetTx		:= Array( __nQuantas )

	If lResult
		aGetTx[ 1 ]	:= 1
		nDtInicial	:= Ascan( aTaxas, {|e| e[ 1 ] == dDataI } )
		nDtLimite	:= Ascan( aTaxas, {|e| e[ 1 ] == dDataF } )

		For nMoeda := 2 To __nQuantas
			aGetTx[ nMoeda ] := 0
			nInc := 0
			For i := nDtInicial To nDtLimite
				// Acumula a variacao diaria
				aGetTx[ nMoeda ] += ( aTaxas[ i ][ nMoeda ] / aTaxas[ i - 1 ][ nMoeda ] )
				nInc++
			Next i
			// Calcula a media da variacao diaria
			aGetTx[ nMoeda ] := ( aGetTx[ nMoeda ] / nInc )
		Next

		If la30Embra
			aGetTx[ Val( cMoedaAtf ) ] := ExecBlock("A30EMBRA",.F.,.F.)
		EndIf
	EndIf

Return (aGetTx)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GetTxVariacaoºAutor  ³Microsiga        º Data ³  10/05/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function GetTxVariacao( dDataI, dDataF, cMoedaAtf, la30Embra )

	Local lResult		:= .T.
	Local nMoeda		:= 0
	Local nDtLimite		:= 0
	Local nDtInicial	:= 0
	// *******************************
	// Controle de multiplas moedas  *
	// *******************************
	Local __nQuantas	:= AtfMoedas()
	Local aGetTx		:= Array( __nQuantas )

	If lResult
		aGetTX[ 1 ]	:= 1
		If dDataI ==  FirstDay( dDataI )
			dDataI := dDataI - 1
		Endif
		nDtInicial	:= Ascan( aTaxas, {|e| e[ 1 ] == dDataI } )
		nDtLimite	:= Ascan( aTaxas, {|e| e[ 1 ] == dDataF } )

		For nMoeda := 2 To __nQuantas
			If ( nDtLimite > 0 ) .and. ( nDtInicial > 0 )
				aGetTX[ nMoeda ] := ( aTaxas[ nDtLimite ][ nMoeda ] / aTaxas[ nDtInicial ][ nMoeda ] )
			Else
				aGetTX[ nMoeda ] := 0
			Endif
		Next

		If la30Embra
			aGetTX[ Val(cMoedaAtf) ] := ExecBlock("A30EMBRA",.F.,.F.)
		EndIf
	EndIf

Return ( aGetTX )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CalculoCM ºAutor  ³Microsiga           º Data ³  10/06/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function CalculoCM( cMoedaAtf, PE_lA30Embra )

	Local lResult	:= .T.

	Private lA30EMBRA	:= PE_lA30Embra


	If cPaisLoc == "CHI"
		lResult := CalcCMCHI( cMoedaAtf )
	ElseIf	cPaisLoc == "ARG"
		lResult := CalcCMARG( cMoedaAtf )
	Else	// Calculo Padrao
		lResult := CalcCMPADRAO( cMoedaAtf )
	Endif

Return ( lResult )






/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CalcCMPADRAOºAutor  ³Microsiga         º Data ³  10/06/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ 														      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function CalcCMPADRAO( cMoedaATF )

	Local lResult		:= .T.
	Local nDecimals		:= X3Decimal('N3_VORIG' + cMoedaAtf)
	Local nDepr1		:= 0
	Local nDiferenca	:= 0

	// Verificação da classificação de Ativo se sofre depreciação
	Local lAtClDepr 	:= .F.

	If lResult
		nTaxaCorr	:= 0	// Taxa para as Correcoes do Bem e da Depreciacao
		nValCorr	:= 0	// N4_OCORR $ ('07')	N4_TIPOCNT $ ('1','2')		Correcao do Bem no mes
		nValCorDep	:= 0	// N4_OCORR $ ('08')	N4_TIPOCNT $ ('4','5')		Correcao da Depreciacao Acumulada
		nValCorDAC	:= 0	// N4_OCORR $ ('08')	N4_TIPOCNT $ ('8')		Depr Acum do Exercicio Anterior

		// Valida se o bem ja iniciou o tempo de depreciacao
		// Nao permitindo o calculo de Correcao no mes de aquisicao
		If	lCalcula .and.;
		( MesAnoATF(SN3->N3_DINDEPR) <= MesAnoATF(dDataBase) )

			nTaxaCorr := nMVVALCORR := aTxMedia[ Val(cMoedaAtf) ]

			// Correcao Monetaria sobre o Custo de Aquisicao
			If nMVVALCORR < 0
				nValCorr  := 	Abs(( N3_VRCACM1 + N3_VORIG1 + N3_AMPLIA1 )) -;
				Round(	Abs(( N3_VORIG1 + N3_VRCACM1 + N3_AMPLIA1) * nMVVALCORR ), nDecimals )
			Else
				nValCorr  := Round(	Abs(( N3_VORIG1 + N3_VRCACM1 + N3_AMPLIA1) * nMVVALCORR ), nDecimals ) -;
				Abs(( N3_VRCACM1 + N3_VORIG1 + N3_AMPLIA1 ))
			Endif

			// Extrai a Cota de Depreciacao relativa a Correcao Calculada enquanto no periodo de depreciacao
			// ********************************
			// Controle de multiplas moedas  *
			// ********************************

			If Empty( SN3->N3_FIMDEPR )
				If cPaisLoc=="BOL"
					aValDepr := AtfMultMoe(,,{|x|	aValDepr[ x ] += If( x==1, Round( nValCorr * aTaxaMes[ x ], nDecimals ), 0 ) })
				else
					aValDepr := AtfMultMoe(,,{|x|	aValDepr[ x ] += If( x==1, Round( nValCorr * aTaxaMes[ x ], nDecimals ), Round( (nValCorr / RecMoeda( dDataBase, x /*Moeda*/)) * aTaxaMes[ x ], nDecimals ) ) })
				Endif
				// Ajusta o valor da cota ao limite do residuo apurado.

				nDiferenca :=	Round( Abs( N3_VORIG1 + N3_VRCACM1 + N3_AMPLIA1 ), X3Decimal('N3_VORIG1') ) -;
				Round( Abs( aValDepr[1] + N3_VRDACM1 ), X3Decimal('N3_VORIG1') )
			Endif

			If cPaisLoc = "BOL"
				nValCorDep := Round( (N3_VRDACM1 + N3_VRCDA1) * ( aTxMedia[Val(cMoedaATF)] - 1 ), nDecimals)
			Else
				If !Empty( N3_VRCACM1 )
					nValCorDep := Round( (N3_VRDACM1 + N3_VRCDA1) * ( aTxMedia[Val(cMoedaATF)] - 1 ), nDecimals)
				EndIf
			Endif

			nTaxaDepr := nMVVALCORR
			nTaxaDepr := IIf( la30Embra, ExecBlock("A30EMBRA",.F.,.F.), nTaxaDepr )
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Trata os res¡duos de deprecia‡ao.                                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Round( nDiferenca, nDecimals ) < 0
			nDepr1 :=	Abs( N3_VORIG1 + N3_VRCACM1 + N3_AMPLIA1 ) -;
			Abs( N3_VRDACM1 + N3_VRCDA1 )
		EndIf

		// Verificação da classificação de Ativo se sofre depreciação
		lAtClDepr := AtClssVer((cAliasSn1)->N1_PATRIM)
		If ! ( lAtClDepr .OR. EMPTY((cAliasSn1)->N1_PATRIM) )
			// *******************************
			// Controle de multiplas moedas  *
			// *******************************
			aValDepr 	:=  AtfMultMoe(,,{|x| 0}) 
			//nValDepr1 := 0; nValDepr2 := 0; nValDepr3 := 0; nValDepr4 := 0; nValDepr5 := 0
			nValCorDep := 0
		EndIf

		If Empty(SN3->N3_CCORREC)
			nValCorr := 0
		EndIf
		If Empty(SN3->N3_CDESP)
			nValCorDep := 0
		EndIf

	Endif

Return ( lResult )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ValidSP   ºAutor  ³Microsiga           º Data ³  10/09/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³A procedure sera executa se:                                º±±
±±º          ³1 - Nao for AS400;                                          º±±
±±º          ³2 - Se a procedure existir;                                 º±±
±±º          ³3 - O parametro NAO CONTABILIZA (mv_par01 = 3 )             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function ValidSP()
	Local cATF001 := GetSPName("ATF001","11")
Return ( (cPaisLoc = "BRA") .and. ExistProc(cATF001, VerIDProc()) ) 

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ExecuteSP ºAutor  ³Microsiga           º Data ³  10/09/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function ExecuteSP(cMoedaAtf, cFilDe, cFilAte)

	Local lResult		:= .T.
	Local cFilOld 		:= cFilAnt
	Local lCusto		:= CtbMovSaldo("CTT")
	Local lItem			:= CtbMovSaldo("CTD")
	Local lCLVL			:= CtbMovSaldo("CTH")
	Local cMoedaForte	:= "0"+cMoedaAtf
	Local lLeyDl824		:= GetNewPar("MV_CCDL824",.F.)
	Local aResult		:= {}
	Local aSM0			:= AdmAbreSM0()
	Local cFilProc		:= ""
	Local cMesCheio		:= AllTrim(GetMv("MV_TIPDEPR"))	// '0' - PROPORCIONAL,
	// '1' - MES CHEIO,
	// '2' - NAO calc deprec de bens baixados(RIPASA) no mes de calc
	Local cATF001       := GetSPName("ATF001","11")
	Local nInc          := 0
	Local dUltProcAnt   := cTod("  /  /  ")
	Local dUltProc      := cTod("  /  /  ")
	Local lFilbyFil     := .F.
	Local lPrim         := .T.
	Local cFilAux       := ""
	Local cCalcDep	    := GetNewPar("MV_CALCDEP",'0')	//->	'0'-Mensal //->	'1'-Anual
	Local cATFMdmx      := GetNewPar("MV_ATFMDMX",'1')  //Define a Moeda para o vlr maximo de depreciacao.
	Local cCasas1       := Str( (TamSx3("N3_VRDMES1")[2]), 2 )
	Local cCasas2       := Str( (TamSx3("N3_VRDMES2")[2]), 2 )
	Local cCasas3       := Str( (TamSx3("N3_VRDMES3")[2]), 2 )
	Local cCasas4       := Str( (TamSx3("N3_VRDMES4")[2]), 2 )
	Local cCasas5       := Str( (TamSx3("N3_VRDMES5")[2]), 2 )
	Local cCasasN       := " "
	Local nQtdMoedas    := AtfMoedas()
	Local iX            := 0
	Local lAtfctap	    := IIF(GetNewPar("MV_ATFCTAP","0")=="0",.F.,.T.)
	
	If nQtdmoedas > 5
		cCasasN := ""
		For iX := 6 to nQtdMoedas
			If iX >= 10
				If SN3->(FieldPos('N3_VRDME'+Alltrim(Str(iX)) )) > 0
					cCasasN += StrZero( (TamSx3("N3_VRDME"+Alltrim(Str(iX)))[2]), 2 )
				EndIf
			Else
				If SN3->(FieldPos('N3_VRDMES'+Alltrim(Str(iX)) )) > 0
					cCasasN += StrZero( (TamSx3("N3_VRDMES"+Alltrim(Str(iX)))[2]), 2 )
				EndIf
			EndIf
		Next iX
	EndIf
	If Len(cATFMdmx) == 1
		cATFMdmx = '0'+cATFMDmx
	EndIf

	If lResult
		If mv_par06 == 1 // considera filiais
			cFilProc := ""
			For nInc := 1 to Len(aSM0)
				If aSM0[nInc][1] == cEmpAnt .AND. aSM0[nInc][2] >= cFilDe .AND. aSM0[nInc][2] <= cFilAte
					cFilAnt := aSM0[nInc][2]

					If Alltrim(cFilProc) != Alltrim(xFilial("SN3"))
						cFilProc:= xFilial("SN3")
					Else
						Loop
					EndIf

					//Tratamento para validar se o usuário possui permissão na Filial a ser calculada
					If !VldFilial(cFilAnt)
						Loop
					EndIf

					dUltProc:= GetNewPar("MV_ULTDEPR", STOD("19800101"))
					If !AFA050Valid( cMoedaAtf, lAjustInf, dUltProc)
						lResult := .F.
					EndIf
					If dUltProcAnt != dUltProc .and. !lPrim
						lFilbyFil := .t. 
						Exit
					EndIf
					lPrim := .F.
				Endif
				dUltProcAnt := dUltProc
			Next
		Else
			cFilDe  := cFilAnt
			cFilAte := cFilAnt
			dUltProc:= GetNewPar("MV_ULTDEPR", STOD("19800101"))
			If !AFA050Valid( cMoedaAtf, lAjustInf, dUltProc)
				lResult := .F.
			EndIf
		Endif

		If lFilbyFil .and. lResult
			cFilProc := ""
			For nInc := 1 To Len( aSM0 )
				If aSM0[nInc][1] == cEmpAnt .AND. aSM0[nInc][2] >= cFilDe .AND. aSM0[nInc][2] <= cFilAte
					cFilAnt := aSM0[nInc][2]
					cFilAux := cFilAnt
					cFilAux := cFilAnt

					If Alltrim(cFilProc) != Alltrim(xFilial("SN3"))
						cFilProc:= xFilial("SN3")
					Else
						Loop
					EndIf

					//Tratamento para validar se o usuário possui permissão na Filial a ser calculada
					If !VldFilial(cFilAnt)
						Loop
					EndIf
					If mv_par06 == 1 // considera filiais
						dUltProc:= GetNewPar("MV_ULTDEPR", STOD("19800101"))
					Endif

					If !AFA050Valid( cMoedaAtf, lAjustInf, dUltProc)
						Loop
					Else
						// Gerar e confirmar o IDMOV
						cIdMov := Af050IdMov()
						MsgRun(	STR0023,;
						STR0024,;
						{|| aResult := TCSPEXEC(xProcedures(cATF001),;
						cFilAux,;
						cFilAux,;
						IIf(lCusto,'1','0'),;
						IIf(lItem,'1','0'),;
						IIf(lClVl,'1','0'),;
						Dtos(dDataBase),;
						cMesCheio,;
						cPaisLoc,;
						IIf(lN3Deprec,'1','0'),;
						cMoedaForte,;
						IIf(lcalcula,'1','0'),;
						nMVVALCORR,;
						IIf(lLeyDl824,'1','0'),;
						mv_par05,;
						cModoBlq,;
						cCalcDep,;
						cATFMdmx,;
						cIdMov,;
						Alltrim(cCasas1),;
						Alltrim(cCasas2),;
						Alltrim(cCasas3),;
						Alltrim(cCasas4),;
						Alltrim(cCasas5),;
						Alltrim(cCasasN),;
						nQtdMoedas,;
						IIf(lAtfctap,'1','0') ) } )
						If Empty(aResult) .or. aResult[1] = "0"
							MsgAlert(STR0025)
						ElseIf aResult[1] = "1"
							AF050AtPar(cFilAnt,dDataBase)
							A050CONTPROC(cIdMov) //Função para contabilizar 
							A050PCOPROC(cFilAnt,cIdMov) //Função para integrar com PCO
						EndIf
					EndIf
				Endif
			Next
		ElseIf lResult
			// Gerar e confirmar o IDMOV
			cIdMov := Af050IdMov()
			MsgRun(	STR0023,;
			STR0024,;
			{|| aResult := TCSPEXEC(	xProcedures(cATF001),;
			cFilDe,;
			cFilAte,;
			IIf(lCusto,'1','0'),;
			IIf(lItem,'1','0'),;
			IIf(lClVl,'1','0'),;
			Dtos(dDataBase),;
			cMesCheio,;
			cPaisLoc,;
			IIf(lN3Deprec,'1','0'),;
			cMoedaForte,;
			IIf(lcalcula,'1','0'),;
			nMVVALCORR,;
			IIf(lLeyDl824,'1','0'),;
			mv_par05,;
			cModoBlq,;
			cCalcDep,;
			cATFMdmx,;
			cIdMov,;
			Alltrim(cCasas1),;
			Alltrim(cCasas2),;
			Alltrim(cCasas3),;
			Alltrim(cCasas4),;
			Alltrim(cCasas5),;
			Alltrim(cCasasN),;
			nQtdMoedas,;
			IIf(lAtfctap,'1','0') ) } )
			If Empty(aResult) .or. aResult[1] = "0"
				MsgAlert(STR0025)
			ElseIf aResult[1] = "1"
				If Alltrim(xFilial("SN3"))=""
					AF050AtPar(cFilAnt,dDataBase)
					AF050ProcPrj(cFilAnt,dDataBase)
					A050CONTPROC(cIdMov) //Função para contabilizar 
					A050PCOPROC(cFilAnt,cIdMov) //Função para integrar com PCO
				Else
					cFilProc := ""
					For nInc := 1 To Len( aSM0 )
						If aSM0[nInc][1] == cEmpAnt .AND. aSM0[nInc][2] >= cFilDe .AND. aSM0[nInc][2] <= cFilAte
							cFilAnt := aSM0[nInc][2]
							If Alltrim(cFilProc) != Alltrim(xFilial("SN3"))
								cFilProc:= xFilial("SN3")
							Else
								Loop
							EndIf

							//Tratamento para validar se o usuário possui permissão na Filial a ser calculada
							If !VldFilial(cFilAnt)
								Loop
							EndIf

							AF050AtPar(cFilAnt,dDataBase)
							AF050ProcPrj(cFilAnt,dDataBase)
							ATFrat()
							A050CONTPROC(cIdMov) //Função para contabilizar 
							A050PCOPROC(cFilAnt,cIdMov) //Função para integrar com PCO
						Endif
					Next
				EndIf
			EndIf
		EndIf
		// Restaura a filial
		cFilAnt := cFilOld
		dbSelectArea("SN3")
	Endif

Return lResult

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³SomaDigitosºAutor  ³Microsiga           º Data ³  23/11/09  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Metodo de depreciacao diferenciado: Soma de Digitos         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function SomaDigitos(dDataBase, dINDEPR, nPeriodos, cPeriodo)
Return ATFCalcSD(dDataBase, dINDEPR, nPeriodos ,cPeriodo, @aTaxaMes)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ReduzSaldosºAutor  ³Microsiga           º Data ³  25/11/09  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Metodo de depreciacao diferenciado: Reducao de Saldos      º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function ReduzSaldos(nVlSalv, nVorig, nPeriodos, nDepAcm)
Return ATFCalcRS(nVlSalv, nVorig, nPeriodos, nDepAcm, @aTaxaMes)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³TaxPUnidadºAutor  ³Alvaro Camillo Neto º Data ³  11/29/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Calcula a taxa de depreciacao pela razao entre as unidades º±±
±±º          ³ produzidas no mes pelas produzidas no ano                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function TaxPUnidad(nProdMes, nProdAno )
Return ATFCalcVR(nProdMes, nProdAno, @aTaxaMes)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³SomaDosAnosºAutor  ³Alvaro Camillo Neto º Data ³  29/11/09  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Calcula a taxa de depreciacao pelo mentodo de soma dos anosº±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function SomaDosAnos( nPeriodos )
Return ATFCalcSA(nPeriodos, @aTaxaMes)



/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³AdmAbreSM0³ Autor ³ Orizio                ³ Data ³ 22/01/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna um array com as informacoes das filias das empresas ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function AdmAbreSM0()

	Local aArea			:= SM0->( GetArea() )
	Local aRetSM0		:= {}
	
	aRetSM0	:= FWLoadSM0()
	
	RestArea( aArea )

Return aRetSM0



/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AF050DET    ³ Autor ³ TOTVS SA              ³ Data ³ 10/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Grava as linhas de detalhe do arquivo de Contra Prova         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³af050Detal(ExpN1,ExpC1,ExpC2,ExpA1)                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Arquivo,Programa,Lote,Array com conteudos                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AF050DET( nHdlPrv,cPrograma,cLote,aCampos )

	Local nTotal:=0
	cPrograma := ALLTRIM(UPPER(cPrograma))+SPACE(10-Len(Alltrim(cPrograma)))

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³                       ARQUIVO DE LOG-LANC AUT                         ³
	³                         Mem¢ria de Calculos                           ³
	ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
	³                          HEADER DO ARQUIVO                            ³
	³	Descricao				Tamanho			Pos Ini			Pos Fim     ³
	ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
	³  Marca de In¡cio              002             001             002     ³
	³  Data Base                    010             003             013     ³
	³  Lote                         004             014             018     ³
	³  Programa                     008             019             027     ³
	³  Operador                     006             028             034     ³
	³  Filial                       002             035             037     ³
	³  Filler                       278             038             260     ³
	ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
	³                          DETALHE DO ARQUIVO                           ³
	³	Descricao				Tamanho			Pos Ini			Pos Fim     ³
	ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
	³  Tipo Lancamento              001             001             001     ³
	³  Codigo da Conta              020 			002				021     ³
	³  Contra Partida	  			020 			022				041     ³
	³  Valor Moeda 1 	 			016 			042				057     ³
	³  Moedas						005 			058				062     ³
	³ 	Historico			  		040 			063				102     ³
	³  Valor Moeda 2 	  			016 			103				118     ³
	³  Valor Moeda 3 	  			016 			119				134     ³
	³  Valor Moeda 4 	  			016 			135				150     ³
	³  Valor Moeda 5 	  			016 			151				166     ³
	³  C Custo Debito				009 			167				175     ³
	³  C Custo Credito              009             176             184     ³
	³  Cod/Seq Lanc Pad 			005 			185				189     ³
	³  Data de Vencimento           010 			190				199     ³
	³  Origem do lanc.              040             200             239     ³
	³  Ident Inter CP				001 			240				240     ³
	³  Nome do Programa             010             241             250     ³
	³  Item Debito   				009 			251				259     ³
	³  Item Credito  				009             260             268     ³
	³  Filler				  		042 			269				310     ³
	ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
	³                          TOTALIZADOR DO ARQUIVO                       ³
	³   Descricao               Tamanho         Pos Ini         Pos Fim     ³
	ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
	³  Valor Total		  			016 			001				016     ³
	³  Filler				 		294 			017				310     ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	/*/
	IF aCampos[ 4 ] > 0 .or. aCampos[ 7 ] > 0 .or. aCampos[ 8 ] > 0 .or. ;
		aCampos[ 9 ] > 0 .or. aCampos[ 10] > 0
		FWRITE(nHdlPrv,aCampos[1]+;   // tipo lancto - 1
		aCampos[2]+;                  // cod conta   -20
		aCampos[3]+;                  // contra part -20
		Str(aCampos[4],16,2)+;        // valor 1     -16
		aCampos[5]+;                  // moedas      - 5
		aCampos[6]+;                  // historico   -40
		Str(aCampos[ 7],16,2)+;       // valor 2     -16
		Str(aCampos[ 8],16,2)+;       // valor 3     -16
		Str(aCampos[ 9],16,2)+;       // valor 4     -16
		Str(aCampos[10],16,2)+;       // valor 5     -16
		aCampos[11]+;                 // cc debito   - 9
		aCampos[12]+;                 // cc credito  - 9
		aCampos[13]+;                 // cod seq     - 5
		aCampos[14]+;                 // data vencto - 10
		aCampos[15]+;                 // origem lcto -40
		aCampos[16]+;                 // Inter CP    - 1
		aCampos[17]+;                 // Nome Progr  -10
		aCampos[18]+;                 // item debito   9
		aCampos[19]+;                 // item credito  9
		Space(42)+;
		CHR(13)+;
		CHR(10),312)         // filler
		dbCommit()
		nTotal += aCampos[4]
	End

Return nTotal

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AF050NXMTH  ³ Autor ³ TOTVS SA              ³ Data ³ 10/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Devolve a taxa de uma determ. moeda no 1. dia do proximo mes. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³af050MesSeg()                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³AtfA050                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AF050NXMTH(cMoedaATF)

	Local dDataProx

	dDataProx := LastDay( dDataBase ) + 1
	SM2 -> ( dbSeek( dDataProx , .T. ) )

	If MesAnoAtf( SM2 -> M2_DATA ) != MesAnoAtf( dDataProx )
		Return 0			// Nao achou nenhuma taxa
	End

Return &("SM2->M2_MOEDA"+cMoedaAtf)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³AF050CHK  ºAutor  ³Microsiga           º Data ³  11/09/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica e chama o ponto de entrada AF050CHK.              º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP - Ativo Fixo                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AF050CHK()
	Local lResult := .T.

	If ExistBlock("AF050CHK")
		lResult := ExecBlock( "AF050CHK", .F., .F. )
	Endif

Return lResult

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³AFA050VlTpºAutor  ³Marcelo Akama       º Data ³  26/01/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica se existem ativos com tipo nao tratados           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP - Ativo Fixo                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AFA050VlTp(cFilDe, cFilAte)

	Local aArea		:= GetArea()
	Local aAreaSN3	:= SN3->(GetArea())
	Local aSM0 		:= AdmAbreSM0()
	Local cFilOld 	:= cFilAnt
	Local cAliasSn3 := "SN3"
	Local lOk		:= .T.
	Local aTipos	:= {'01','02','03','04','05','06','07','08','09','10','11','12','13','14','15','16','17','33','41','42','50','51','52','53','54'}
	Local aAux		:= {}
	Local cTipos	:= ""
	Local nX
	Local cTypesNM	:= IIF(lIsRussia,AtfNValMod({1,2,3,4}, "|"),"") // CAZARINI - 24/03/2017 - If is Russia, add new valuations models - main, recoverable, 17 and 16 models
	Local aTypesNM 	:= {}
	Local nTypesNM 	:= 0

	DEFAULT cFilDe	:= cFilAnt
	DEFAULT cFilAte	:= cFilAnt
	// CAZARINI - 24/03/2017 - If is Russia, add new valuations models - main models and 17 and 16 similar models
	aTypesNM := Separa(cTypesNM, '|', .f.)

	For nTypesNM := 1 to len(aTypesNM)
		aadd( aTipos, aTypesNM[nTypesNM] )
	Next nTypesNM

	If ExistBlock("AF050VTP")
		aAux := ExecBlock( "AF050VTP", .F., .F. )
		If ValType(aAux)=="A"
			For nX := 1 to Len(aAux)
				If ValType(aAux[nX])=="C"
					AADD(aTipos, aAux[nX])
				EndIf
			Next
		EndIf
	Endif

	For nX := 1 to Len( aTipos )
		cTipos := cTipos + IIf(nX>1, ",", "") + aTipos[nX]
	Next

	// Processa todo o arquivo de filiais ou apenas a filial atual
	For nX := 1 To Len( aSM0 )
		If aSM0[nX][1] == cEmpAnt .AND. aSM0[nX][2] >= cFilDe .AND. aSM0[nX][2] <= cFilAte
			cFilAnt := aSM0[nX][2]
			dbSelectArea( "SN3" )
			dbSeek( xFilial("SN3") )
			Do While lOk .And. (cAliasSn3)->(!Eof()) .And. (cAliasSn3)->N3_FILIAL == xFilial("SN3")
				If !(cAliasSn3)->N3_TIPO $ cTipos
					lOk := .F.
				EndIf
				SN3->( dbSkip() )
			EndDo
		EndIf
	Next

	cFilAnt := cFilOld

	RestArea(aAreaSN3)
	RestArea(aArea)

Return lOk

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³AF050AtParºAutor  ³Alvaro Camillo Neto º Data ³  09/09/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Atualiza o parametro MV_ULTDEPR dos parametros da filial    º±±
±±º          ³corrente dependendo do compartilhamento da tabela SN1       º±±
±±º          ³tratamento para gestao corporativa                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function AF050AtPar(cFilMov,dDataMov)

	Local cFilX 	:= cFilAnt
	Local aSM0  	:= AdmAbreSM0()
	Local nX		:= 0
	Local lExclusivo := ADMTabExc("SN1")

	If lExclusivo
		For nX := 1 to Len(aSM0)
			cFilAnt := aSM0[nX][2]
			If Alltrim(aSM0[nX][1]) == Alltrim(cEmpAnt) .And. Alltrim(xFilial("SN3")) == Alltrim(xFilial("SN3",cFilMov))
				PutMv("MV_ULTDEPR",DTOS(dDataMov))
			EndIf
		Next nX
	Else
		PutMv("MV_ULTDEPR",DTOS(dDataMov))
	EndIf

	cFilAnt := cFilX

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³AF050AtProjºAutor  ³Alvaro Camillo Neto º Data ³  14/11/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Atualiza as informações do projeto de imobilizado           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function AF050AtProj(cBase,cItem,cTipo,cTipoSld,aValDepr)

	Local aArea		:= GetArea()
	Local aAreaSN1	:= SN1->(GetArea())
	Local nMoeda	:= 0

	If __lStruPrj == Nil
		__lStruPrj := .T.
	EndIf

	If __lStruPrj
		SN1->(DBSetOrder(1)) //N1_FILIAL+N1_CBASE+N1_ITEM
		FNE->(DBSetOrder(2)) //FNE_FILIAL+FNE_CODPRJ+FNE_REVIS+FNE_ETAPA+FNE_ITEM+FNE_TPATF+FNE_TPSALD
		If SN1->(MsSeek( xFilial("SN1") + cBase + cItem))
			// Acumula também o tipo 14 que complementa o tipo 10
			cTipo := IIF( cTipo == '14','10', cTipo )

			If FNE->(MsSeek( xFilial("FND") + SN1->(N1_PROJETO + N1_PROJREV + N1_PROJETP + N1_PROJITE) + cTipo + cTipoSld ))
				nMoeda := Val(FNE->FNE_MOEDRF)
				RecLock("FNE",.F.)
				FNE->FNE_VRDACM += aValDepr[nMoeda]
				MsUnLock()
			EndIf

		EndIf
	EndIf
	RestArea(aAreaSN1)
	RestArea(aArea)

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ AF050T10    ³ Autor ³ Mauricio Pequim Jr. ³ Data ³ 14/09/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Verifica a existencia de um tipo 10 relacionado a um tipo 15³±±
±±³          ³ de mesmo tipo de saldo                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ ATFA050                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cBase     = Codigo base do bem					           ³±±
±±³          ³ cItem     = Item do bem			                           ³±±
±±³          ³ cTipoSld  = Tipo de saldo do bem tipo 15      		       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function AF050T10( cBase,cItem,cTpSaldo )

	Local lRet 		:= .F.
	Local cQuery 	:= ""
	Local aArea		:= GetArea()
	Local cAliasQry := "CHKT15W10"
	Local cTypes10	:= IIF(lIsRussia,AtfNValMod({1}, "|"),"") // CAZARINI - 24/03/2017 - If is Russia, add new valuations models - main models
	Local aTypes10	:= {}
	Local nTypes10	:= 0

	cQuery := " SELECT COUNT(*) SN3MARGEM "
	cQuery += " FROM " + RetSqlName("SN3") + " SN3 "
	cQuery += " WHERE SN3.N3_FILIAL  = '" + xFilial("SN3") + "' AND "
	cQuery += "       SN3.N3_CBASE   = '" + cBase          + "' AND "
	cQuery += "       SN3.N3_ITEM    = '" + cItem          + "' AND "
	If empty(cTypes10)
		cQuery += "       SN3.N3_TIPO    = '10' AND "
	Else
		aTypes10 := Separa(cTypes10, '|', .f.)

		If len(aTypes10) = 0
			cQuery += "       SN3.N3_TIPO    = '10' AND "
		Else
			cQuery += "       SN3.N3_TIPO    IN ('10' "
			For nTypes10 := 1 to len(aTypes10)
				cQuery += ", '" + aTypes10[nTypes10] + "' "
			Next nTypes10
			cQuery += ") AND "
		Endif
	Endif
	cQuery += "       SN3.N3_TPSALDO = '" + cTpSaldo       + "' AND "
	cQuery += "       SN3.D_E_L_E_T_ = ' ' "

	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

	If (cAliasQry)->SN3MARGEM > 0
		lRet := .T.
	EndIf

	(cAliasQry)->(dbCloseArea())

	RestArea(aArea)

Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ AF050IND    ³ Autor ³Alvaro Camillo Neto  ³ Data ³ 16/11/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Verifica se o ativo esta realizando a depreciacao pelo metodo±±
±±³          ³ por indice com o tipo calculado (Curva de Demanda)          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ ATFA050                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cBase     = Codigo base do bem					           ³±±
±±³          ³ cItem     = Item do bem			                           ³±±
±±³          ³ cTipoSld  = Tipo de saldo do bem tipo 15      		       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function AF050IND()

	Local aArea := GetArea()
	Local lRet  := .F.

	If SN3->N3_TPDEPR == 'A'
		dbSelectArea("FNI")
		FNI->(dbSetOrder(1))
		lRet := FNI->(MsSeek(xFilial("FNI") + SN3->N3_CODIND)) .And. FNI->FNI_TIPO == '2'
	EndIf

	RestArea(aArea)

Return lRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Af050IdMovºAutor  ³                    º Data ³  09/11/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Reserva o XXX_IDMOV e passa para a procedure                º±±
±±º          ³Somente para procedure                                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Procedure ATF001                                           º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Af050IdMov()

	Local nSaveSx8Len := GetSx8Len()
	Local cIDMOV      := " " //NAO tirar esse espaço em branco. Necessário para procedure
	Local lRet        := .T.

	cIdMov := GetSXENum("SN4","N4_IDMOV",,6)

	While (GetSx8Len() > nSaveSx8Len)
		If lRet
			ConfirmSX8()
		Else
			RollBackSX8()
		Endif
	EndDo

Return(cIdMov)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³AF050ProcPrjºAlvaro ³Camillo Neto        º Data ³  20/05/13 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Atualiza o projeto dos ativos do calculo de depreciacao     º±±
±±º          ³utilizado no processamento da procedure                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function AF050ProcPrj(cFilX,dData)

	Local cQuery		:= ""
	Local aArea		:= GetArea()
	Local cAliasQry 	:= "CHKTPROJATF"
	Local __nQuantas	:= AtfMoedas()
	Local aVlrMoed    := {}
	Local nX			:= 0

	If Select(cAliasQry) > 0
		(cAliasQry)->(dbCloseArea())
	EndIf

	cQuery := " SELECT " +CRLF
	cQuery += "     N4_CBASE, " +CRLF
	cQuery += "     N4_ITEM, " +CRLF
	cQuery += "     N4_TIPO, " +CRLF
	For nX := 1 to __nQuantas
		cQuery += "     N4_VLROC"+cValToChar(nX)+",      " +CRLF
	Next nX
	cQuery += "     N4_TPSALDO " +CRLF

	cQuery += " FROM " + RetSqlName("SN4") + " SN4 " +CRLF
	cQuery += " INNER JOIN " + RetSqlName("FNB") + " FNB ON " +CRLF
	cQuery += "     N4_FILIAL = FNB_FILIAL " +CRLF
	cQuery += "     AND N4_CBASE = FNB_CBASE " +CRLF
	cQuery += " WHERE " +CRLF
	cQuery += "         N4_OCORR   IN ('06','20') " +CRLF
	cQuery += "     AND N4_TIPOCNT = '3' " +CRLF
	cQuery += "     AND N4_DATA = '"+DTOS(dData)+"' " +CRLF
	cQuery += "     AND N4_FILIAL = '"+xFilial("SN4",cFilX)+"' " +CRLF
	cQuery += "     AND SN4.D_E_L_E_T_ = '' " +CRLF
	cQuery += "     AND FNB.D_E_L_E_T_ = '' " +CRLF
	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

	Do While(cAliasQry)->(!EOF())
		aVlrMoed := {}
		For nX := 1 to __nQuantas
			aAdd(aVlrMoed,(cAliasQry)->&("N4_VLROC"+cValToChar(nX) ) )
		Next nX
		AF050AtProj((cAliasQry)->N4_CBASE,(cAliasQry)->N4_ITEM,(cAliasQry)->N4_TIPO,(cAliasQry)->N4_TPSALDO,aVlrMoed)
		(cAliasQry)->(dbSkip())
	EndDo

	(cAliasQry)->(dbCloseArea())

	RestArea(aArea)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LogRecord ºAutor  ³                    º Data ³  07/08/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Executa a Função MatXFunA::ConOutR()                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ATF                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function LogRecord( cTexto )
Return ConOutR( cTexto , .F. , 'ATFA050' )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³VldFilial ºAutor  ³ Caio C. F.         º Data ³  10/12/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida se o usuário possui acesso na filial                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ATF                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function VldFilial(_cFil)

	Local lAdmin  	:= FWIsAdmin( __cUserID ) //Se usuário é administrador ou está no grupo Administradores
	Local aEmp		:= {}
	Local aGrp		:= {}
	local nI,nX,nY	:= 0
	Local cUsrRul	:= FWUsrGrpRule(__cUserID) //0-Não encontrou o usuário informado; 1-Prioriza; 2-Desconsidera; 3-Soma
	Local aUser		:= {}
	Local lRet		:= .F.
	Local _cEmpFil 	:= cEmpAnt + _cFil

	If lAdmin
		Return (.T.)
	Endif

	//--Obtem os acessos dos grupos do usuario
	aGrp := FWSFUsrGrps(__cUserID)  //000001

	// Soma ou Prioriza acessos do grupo
	If cUsrRul $ "3|1"
		For nI:=1 to len(aGrp)
			// Retorna Empresa e Filial que o grupo tem acesso. Ex: 9901
			aAdd(aEmp, FWGrpEmp(aGrp[nI]) )
		Next nI
	EndIf

	// Soma ou desconsidera - Soma com os acessos do usuário ou desconsidera grupo
	If cUsrRul $ "3|2" .Or. len(aGrp) == 0
		//--Obtem os acessos do usuario
		aUser :=FWUsrEmp(__cUserID)
		//Se aUser for igual a @@@@, o usuário tem acesso a todas as empresas
		If ValType(aUser) == "A" .AND. LEN(aUser) >=1 .And. aUser[1] == "@@@@"
			Return (.T.)
		EndIf
		//Soma aos acessos do grupo
		aAdd(aEmp, aUser)
	EndIf

	//Desconsidera Grupo, considera acessos do usuário
	If cUsrRul == "2" .Or. len(aGrp) == 0
		For nY:=1 to len(aUser)
			If AllTrim(aUser[nY]) == AllTrim(_cEmpFil)
				Return (.T.)
			EndIf
		Next
	Else
		For nX:=1 to len(aEmp)
			For nY:=1 to len(aEmp[nX])
				If ( AllTrim(aEmp[nX][nY]) == "@@@@" ) .OR. ( AllTrim(aEmp[nX][nY]) == AllTrim(_cEmpFil) )
					Return (.T.)
				EndIf
			Next
		Next
	EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ A050Contab º Autor ³Daniel Mendes       º Data ³  27/11/14 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Faz as validações e o lançamento contábil                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ ATFA050                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A050Contab( lPadrao , lChmLpd , lOnOff , lLP_Rat , lHeadExist , cLoteAtf , lHdlProva/*@*/ , nHdlPrv/*@*/ , cArquivo/*@*/ , nTotal/*@*/ )

	If (lPadrao .AND. lChmLpd .AND. lOnOff) .OR. (lLP_Rat .AND. lOnOff) //modificado por Fernando Radu Muscalu em 09/05/2011
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ lHeadExist=.T. - Header já criado na rotina de Atualizacao de baixas      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lHeadExist
			If !lHdlProva
				nHdlPrv := HeadProva(cLoteAtf,"ATFA050",Substr(cUsername,1,6),@cArquivo)
				lHdlProva := .T.
			EndIf
		Else
			lHdlProva := .T.
		EndIf

		nTotal += DetProva( nHdlPrv, "820", "ATFA050", cLoteAtf )

		If MV_PAR01 < 3 .And. SN4->N4_LA <> "S"
			If RecLock( "SN4" , .F. )
				//SN4->N4_DCONTAB := dDataBase --Campo histórico
				SN4->N4_LA := "S"
				MSUnlock()
			EndIf
		EndIf

	EndIf

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³af050Detal  ³ Autor ³ Wagner Xavier         ³ Data ³ 06/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Grava as linhas de detalhe do arquivo de Contra Prova         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³af050Detal(ExpN1,ExpC1,ExpC2,ExpA1)                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Arquivo,Programa,Lote,Array com conteudos                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Af050Detal( nHdlPrv,cPrograma,cLote,aCampos )
Return AF050DET( nHdlPrv,cPrograma,cLote,aCampos )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³af050MesSeg ³ Autor ³ Wagner Xavier         ³ Data ³ 06/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Devolve a taxa de uma determ. moeda no 1. dia do proximo mes. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³af050MesSeg()                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³AtfA050                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function af050MesSeg(cMoedaATF)
Return AF050NXMTH(cMoedaATF)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³af050CtrlI  ³ Autor ³ Daniel Fonseca Lira   ³ Data ³ 10/04/17 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Inicia o backup ou reparacao da rotina apos termino com       ³±±
±±³          ³inconsistencias                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   |cTblCtrl := af050CtrlI()                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function af050CtrlI()

	// adicionado o controle de processamento da rotina
	// - apenas sera feito controle se parametro for ativado
	// - se parametro for ativado a contabilizacao deve ser off
	//
	// caso a rotina inicie e verifique que ja existe uma tabela
	// de backup significa que terminou com um status inconsistente
	// nesse momento o descalculo ‚ feito automaticamente, porem
	// o descalculo gera inconsistencias na SN3 por isso sao
	// recuperados os dados da SN3 manualmente
	//
	// a rotina passa a criar um backup da SN3 no inicio do
	// processamento. Ao termino do processamento a rotina remove
	// a tabela com o backup

	Local cTblCtrl := "SN3CTRL"
	Local cDrive   := "TOPCONN"
	Local aSN3     := SN3->(GetArea())
	Local aSN3S    := SN3->(DbStruct())
	Local nI       := 0
	Local cBusca   := ""
	Local cFilAux  := ""
	Local aSM0     := AdmAbreSM0()
	Local lRet     := .F.

	// verifica parametro de controle (privada definida no A050Calc)
	If lAtivaControle

		// se existe tabela e solicitou para restaurar
		If MsFile(cTblCtrl,,cDrive)

			// abre a tabela de backup
			DbUseArea(.T., cDrive, cTblCtrl, cTblCtrl, .F., .F.)
			(cTblCtrl)->(DbGoTop())

			// verifica se backup tem conteudo
			If ! (cTblCtrl)->(Eof())

				// exibe mensagem de restaucao e grava no console
				Help(" ", 1, "AF050CTRL", ,STR0047, 1, 0) // Inconsistencia no calculo de depreciacao detectado, restaurando...
				ConOut("!!! " + DtoC(Date()) + " - " + Time() + CRLF + "!!! " + STR0047)

				// ajusta o parametro para todas as filiais
				For nI := 1 To Len( aSM0 )
					If aSM0[nI][1] == cEmpAnt .AND. aSM0[nI][2] >= MV_PAR07 .AND. aSM0[nI][2] <= MV_PAR08

						// backup e ajuste da filial corrente
						cFilAux := cFilAnt
						cFilAnt := aSM0[nI][2]

						// altera o parametro
						PutMv("MV_ULTDEPR", dDataBase)

						// recupera a filial
						cFilAnt := cFilAux
					End
				Next nI

				// reseta os buffers de parametros (funcao definida na matxfuna)
				RstMvBuff()

				// descalculo automatico
				If ! ATFA070AUT( ;
						3, ;        //nao contabiliza
						2, ;        //nao aglutina
						MV_PAR06, ; //considera filiais
						MV_PAR07, ; //filial de
						MV_PAR08  ) //filial ate
					(cTblCtrl)->(DbCloseArea())
					Return ""
				EndIf

				RstMvBuff()

				// posiciona indice da SN3
				SN3->(DbSetOrder(1))

				// percorre registros de backup
				Begin Transaction
				While ! (cTblCtrl)->(Eof())
					cBusca := (cTblCtrl)->(&(SN3->(IndexKey(1))))

					// faz trava e restaura todos os campos da SN3
					If SN3->(MsSeek(cBusca))
						SN3->(RecLock("SN3", .F.))
						For nI := 1 To Len(aSN3S)
							// aSN3S[nI][1] eh o nome do campo
							SN3->(&(aSN3S[nI][1])) := (cTblCtrl)->(&(aSN3S[nI][1]))
						Next nI
						SN3->(MsUnlock())
					EndIf

					(cTblCtrl)->(DbSkip())
				EndDo
				End Transaction

			EndIf
			// fim - verifica se backup tem conteudo

		EndIf
		// fim - existe tabela e solicitou para restaurar

		// remove a tabela
		af050CtrlF(cTblCtrl)

		// tenta criar a tabela
		If MsCreate(cTblCtrl, aSN3S, cDrive)
			DbUseArea(.T., cDrive, cTblCtrl, cTblCtrl, .F., .F.)

			Begin Transaction
			SN3->(DbGoTop())
			While ! SN3->(Eof())

				// faz trava e inclui todos os campos
				If (cTblCtrl)->(RecLock(cTblCtrl, .T.))
					For nI := 1 To Len(aSN3S)
						// aSN3S[nI][1] eh o nome do campo
						(cTblCtrl)->(&(aSN3S[nI][1])) := SN3->(&(aSN3S[nI][1]))
					Next nI
					(cTblCtrl)->(MsUnlock())
				EndIf

				SN3->(DbSkip())
			EndDo
			End Transaction

			(cTblCtrl)->(DbCloseArea())
		EndIf
		// fim - tenta criar a tabela

		// restura areas
		SN3->(RestArea(aSN3))
	EndIf
	// fim - verifica parametro de controle

Return cTblCtrl

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³af050CtrlF  ³ Autor ³ Daniel Fonseca Lira   ³ Data ³ 10/04/17 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Finaliza o arquivo de backup                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   |af050CtrlF(cTblCtrl)                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function af050CtrlF(cTblCtrl)

	Local cDrive := "TOPCONN"
	Local lRet   := .F.

	// tabela existe? se sim deleta
	If MsFile(cTblCtrl,,cDrive)

		// area esta aberta? se sim fecha
		If Select(cTblCtrl) > 0
			(cTblCtrl)->(DbCloseArea())
		EndIf

		lRet := MsErase(cTblCtrl,,cDrive)
	EndIf

Return lRet
//-----------------------------------------------------------------------
/*/{Protheus.doc} RusMonthModer

Russian Project

Return the value for current month modernization

@param		ARRAY aRusModer
@param		NUMERIC nCurrency
@return		NUMERIC
@author 	victor.rezende
@since 		15/11/2017
@version 	1.0
@project	MA3
@see        None
/*/
//-----------------------------------------------------------------------
Static Function RusMonthModer(aRusModer, nCurrency)
Local nRet		AS NUMERIC
Local nRusModI	AS NUMERIC

nRet	:= 0

If lIsRussia
	nRusModI	:= AScan(aRusModer, {|x| ;
		x[1] + x[2] + x[3] + x[4] + x[5] == ;
		SN3->(N3_FILIAL+N3_CBASE+N3_ITEM+N3_TIPO+N3_TPSALDO) })
	If nRusModI > 0
		nRet	:= aRusModer[nRusModI, 07, nCurrency]
	EndIf
EndIf

Return nRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ATFrat 						           º Data ³  10/05/17   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Grava SNX, SNW e SNY apos a procedure                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ATF                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function ATFrat()

Local cFiltro		:= nil
Local cMoedaAtf 	:= GetMV("MV_ATFMOED")
Local nMFiscal		:= Val(cMoedaAtf)
Local nMoedaVMax  	:= IIf(Val(GetMv("MV_ATFMDMX",.F.," "))>0, Val(GetMv("MV_ATFMDMX")), Val(cMoedaAtf))

Local lAtfctap	:= IIf(GetNewPar("MV_ATFCTAP","0")=="0",.F.,.T.)

Local lDeprBlq	:= .F.		//determina se bens bloqueados serao depreciados
Local lCorrBlq	:= .F.		//determina se bens bloqueados terao correcao monetaria
Local aStru 		:= {} 
Local lOnOff	:= .F.

Private cAliasrat	:= "Crat"

lOnOff := iIF( MV_PAR01 < 3 .and. !lAtivaControle .and. lAtfCont .and. !ValidSP() , .T. , .F. )

aStru		:= SN3->(DbStruct())
					
cFiltro := "SELECT N1_DTBLOQ, N1_AQUISIC, N1_PATRIM, N1_FILIAL, N1_CBASE, N1_ITEM"
					
If cPaisLoc == "ARG" .And. SN1->( FieldPos("N1_CONSAB")) > 0
	cFiltro += ", N1_CONSAB"
EndIf
					
If  Val(cMoedaAtf) <= 9
	cFiltro += ", N3_FILIAL, N3_CBASE, N3_TIPO, N3_ITEM, N3_SEQ, N3_BAIXA, N3_CCONTAB, N3_AQUISIC,N3_TPSALDO, N3_VRDMES1, N3_VRDMES2 , N3_VRDMES3, N3_VRDMES4, N3_VRDMES5, N3_TXDEPR" + cMoedaAtf
Else
	cFiltro += ", N3_FILIAL, N3_CBASE, N3_TIPO, N3_ITEM, N3_SEQ, N3_BAIXA, N3_CCONTAB, N3_AQUISIC,N3_TPSALDO, N3_VRDMES1, N3_VRDMES2 , N3_VRDMES3, N3_VRDMES4, N3_VRDMES5, N3_TXDEPR" + cMoedaAtf
EndIf
				    
If SN3->(FieldPos("N3_VMXDEPR")) > 0
	cFiltro += ", N3_VMXDEPR "
EndIf
					
If Val(cMoedaAtf) <= 9
	cFiltro += ", N3_VRDACM" + cMoedaAtf
	cFiltro += ", N3_VRDMES" + cMoedaAtf  // para calculdo de depreciacao maxima.
Else
	cFiltro += ", N3_VRDAC" + cMoedaAtf
	cFiltro += ", N3_VRDME" + cMoedaAtf  // para calculdo de depreciacao maxima.
EndIf
					
cFiltro += ", N3_VORIG" + cMoedaAtf
cFiltro += ", N3_TXDEPR" + Str(nMoedaVMax,1,0)
cFiltro += ", N3_VORIG" + Str(nMoedaVMax,1,0)
cFiltro += ", N3_VRDACM" + Str(nMoedaVMax,1,0)
cFiltro += ", N3_VRDMES" + Str(nMoedaVMax,1,0)
cFiltro += ", N3_RATEIO "
cFiltro += ", SN3.R_E_C_N_O_ RECNO "
cFiltro += ", SN1.R_E_C_N_O_ N1_RECNO "
cFiltro += " FROM " + RetSqlName("SN3") + " SN3," + RetSqlName("SN1") + " SN1 "
cFiltro += " WHERE N3_FILIAL = '" + xFilial("SN3") + "' AND "
/* Retirado do temporário os itens de outras filiais uma vez que a função chamadora 
	já esta iterando as filiais no range selecionado e manipulando a variavel cFilant */

cFiltro += "( N3_DTBAIXA = ' ' OR (N3_DTBAIXA BETWEEN '" + Substr(Dtos(dDatabase),1,6) + "01" + "' AND '"+Dtos(dDataBase)+"' )) AND "
cFiltro += "( N3_BAIXA < '1' OR (N3_BAIXA >= '1' AND N3_NOVO = '1')) AND "
cFiltro += "N3_CCONTAB <> '" + Space(Len(SN3->N3_CCONTAB)) + "' AND "
cFiltro += "N3_AQUISIC <= '" + DTOS(dDataBase) + "' AND "
cFiltro += "SN3.N3_TIPO NOT IN ('03','13') AND "
					
// Alterado por Fernando Radu Muscalu em 23/11/2011 - Compatibilizacao para o Brasil
If lAtfctap
	cFiltro += "SN3.N3_TPDEPR NOT IN ('4','5','8','9') AND "
EndIf

cFiltro += "SN3.D_E_L_E_T_=' ' AND "
cFiltro += "SN1.N1_FILIAL = SN3.N3_FILIAL AND "
cFiltro += "SN1.N1_CBASE  = SN3.N3_CBASE AND "
cFiltro += "SN1.N1_ITEM   = SN3.N3_ITEM  AND "

/* VerIfica as acoes para itens bloqueados */
If (cPaisLoc == "BRA") .Or. (!lDeprBlq .And. !lCorrBlq)
	cFiltro += "(N1_DTBLOQ = ' ' OR "
	cFiltro += "N1_DTBLOQ < '"+ Dtos(dDataBase) + "') AND "

	If SN1->(FieldPos("N1_STATUS")) > 0
		cFiltro += "N1_STATUS <> '2' AND N1_STATUS <> '3' AND "
	EndIf
EndIf

cFiltro += "N3_RATEIO='1'  AND "
cFiltro += "SN1.D_E_L_E_T_=' '

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Este ponto foi criado para quem utiliza outros tipos de bens,           ³
//³(Depreciacao Negativa, Depreciacao Acelerada, etc) e deseja mudar a     ³
//³ordem para ordenar por conta.                                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If ExistBlock("ATF50ORD")
	cFiltro += "ORDER BY " + SqlOrder(ExecBlock("ATF50ORD"))
Else
	cFiltro += "ORDER BY " + SqlOrder("N3_CBASE+N3_ITEM+N3_TIPO")
EndIf
					
cFiltro := ChangeQuery( cFiltro )

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cFiltro),cAliasrat,.T.,.T.)
aEval(aStru, {|e|	IIf(FieldPos(e[1]) > 0 .And. e[2]!= "C",TCSetField(cAliasrat, e[1], e[2],e[3],e[4]),Nil)})

TCSetField( cAliasrat, "N1_AQUISIC", "D" )
		
dbSelectArea("Crat")
Do While (cAliasrat)->(!Eof())
	
	// Calcula a Cota de Depreciacao
	aValDepr :={(cAliasrat)->N3_VRDMES1,(cAliasrat)->N3_VRDMES2,(cAliasrat)->N3_VRDMES3,(cAliasrat)->N3_VRDMES4,(cAliasrat)->N3_VRDMES5}
			
	If FindFunction("ATFRTMOV")
		ATFRTMOV(	(cAliasrat)->N3_FILIAL,;
			(cAliasrat)->N3_CBASE,;
			(cAliasrat)->N3_ITEM,;
			(cAliasrat)->N3_TIPO,;
			(cAliasrat)->N3_SEQ,;
			dDataBase,;
			cIdMov,;
			aValDepr,;
			lCtb,;
			"1",;
			0,;
			"0",;
			0,;
			(cAliasrat)->N3_BAIXA ; 
			, , , lOnOff )
	EndIf

	dbSelectArea(cAliasrat)
	(cAliasrat)->( dbSkip() )
EndDo

(cAliasrat)->( dbCloseArea())

Return


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A050CONTPROC						     º Data ³  15/09/20   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função para realizar a contabilização apos a execução 	  º±±
±±           ³da procedure                       						  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ATF                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A050CONTPROC(cIdMov)
Local cRotAtF     := "02"
Local cAlsTabReg  := FunName()+"_"+AllTrim(SM0->M0_CODIGO)+"_"+StrTran(AllTrim(xFilial("SN4"))," ", "_")
Local dDtInicial  := STOD(Substr(Dtos(dDatabase),1,6)+"01")
Local dDtFinal    := dDataBase
Local nConsidFil  := mv_par06
Local aSelFil     := {}
Local aTmpFil     := {}
Local nAtvJaClas  := 2

Local aSM0			:= AdmAbreSM0()
Local nX			:= 0

Local nIniLote    := 0
Local nFinLote    := 0
Local nQuebraPrc  := 2 // Não quebra por Processo
Local nAglutLanc  := mv_par02
Local nMostraLanc := mv_par01
Local lUsaFlag    := GETMV("MV_CTBFLAG",.F.,.F.)

If mv_par01 < 3

	If mv_par06==1
		For nX:= 1 to Len(aSM0)//aSelFil := LoadSelFil(mv_par07,mv_par08) //cria array com as filias
			If ( aSM0[nX][1] == cEmpAnt ) .And. aSM0[nX][2] >= MV_PAR07 .and. aSM0[nX][2] <= MV_PAR08
				aAdd(aSelFil, aSM0[nX][2]) 
			EndIf
		Next 
	EndIf
			
	//Definição de Quais Processos do Ativo Fixo serão contabilizados na Execução desta Rotina
	CTATFDADOS(cRotATF,@cAlsTabReg,dDtInicial,dDtFinal,nConsidFil,aSelFil,aTmpFil,nAtvJaClas, cIdMov)
		
	
	//Função de contabilização dos registros pendentes de contabilização do ambiente Ativo Fixo.
	CTATFCTB(cRotATF, cAlsTabReg ,nIniLote, nFinLote, nQuebraPrc,nAglutLanc,nMostraLanc,lUsaFlag,nConsidFil,,cIdMov)

	/*
	* Verifica se a tabela existe no banco de dados e exclui
	*/
	If TcCanOpen(cAlsTabReg)
		(cAlsTabReg)->(dbCloseArea())
		TcDelFile(cAlsTabReg)
	EndIf

EndIf

ASize(aSelFil,0)
ASize(aSM0,0)

Return

/*/{Protheus.doc} ATF050Metrics
	
	ATF050Metrics - Função utilizada para metricas no CTBR400

	@type  Static Function
	@author user
	@since date
	@version version
	@param param, param_type, param_descr
	@return return, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function ATF050Metrics(cEvent, nStart, cSubEvent, cSubRoutine, nQtdReg)

Local cFunBkp	:= ""
Local cFunMet	:= ""

Local nFim := 0

Local cIdMetric  := ""
Local dDateSend := CtoD("") 
Local nLapTime := 0
Local cTotal := ""

Default cEvent := ""
Default nStart := Seconds()
Default cSubEvent := ""
Default cSubRoutine := Alltrim(ProcName(1))
Default nQtdReg := 0

//Só capturar metricas se a versão da lib for superior a 20210517
If __lMetric .And. !Empty(cEvent)
	
	//grava funname atual na variavel cFunBkp
	cFunBkp := FunName()

	If cEvent == "01" //Evento 01 - Metrica de tempo médio

		
		If cSubEvent == '001' .Or. cSubEvent == '002' // 001 = R4 - 002 = R3
			
			cFunMet := Iif(AllTrim(cFunBkp)=='RPC',"RPCATFA050",cFunBkp)
			SetFunName(cFunMet)

			nFim := Seconds() - nStart // Capturar tempo final | Diferença com o tempo inicial
			
			//atribuicao das variaveis que serao utilizadas pelo FwCustomMetrics
			
			cSubRoutine := Alltrim(cSubRoutine)
			cIdMetric  := "ativo-fixo-protheus_ativofixoprotheus_depreciacaodeativotempo_seconds_seconds"
			cTotal := "1"
			dDateSend := LastDay( Date() )
			nLapTime := nFim

			// Metrica
			FWCustomMetrics():SetMetric(cSubRoutine, cIdMetric, cTotal, dDateSend, nLapTime)

		EndIf

	//Evento 02 - Metrica de quantidade total
	ElseIf cEvent == "02" .And. nQtdReg > 0 

		If cSubEvent == '001'

			cFunMet := cFunMet := Iif(AllTrim(cFunBkp)=='RPC',"RPCATFA050",cFunBkp)			
			//atribuicao das variaveis que serao utilizadas pelo FwCustomMetrics
			SetFunName(cFunMet)
			cSubRoutine := Alltrim(cSubRoutine)			
			cIdMetric  := "ativo-fixo-protheus_ativofixoprotheus_depreciacaodeativoqtd_total_total"
			cTotal := cValToChar(nQtdReg) //cTotal na função SetMetric espera parametro do tipo caractere						
			dDateSend := LastDay( Date() )
			FWCustomMetrics():SetMetric(cSubRoutine, cIdMetric, cTotal, dDateSend)
		EndIf
	EndIf

	//Restaura setfunname a partir da variavel salva cFunBkp
	SetFunName(cFunBkp)
EndIf

Return 

//-------------------------------------------------------------------
/*/{Protheus.doc} SchedDef
Retorna os parametros no schedule.

@return aReturn			Array com os parametros

@author  TOTVS
@since   07/04/2014
@version 12
/*/
//-------------------------------------------------------------------
Static Function SchedDef()

Local aParam  := {}

aParam := { "P",;			//Tipo R para relatorio P para processo
            "AFA050",;		//Pergunte do relatorio, caso nao use passar ParamDef
            ,;				//Alias
            ,;				//Array de ordens
            STR0005}				//Titulo - "Calculo de Depreciacao e Correcao Monetaria"

Return aParam


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A050PCOPROC 						     º Data ³  17/11/21   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função para realizar a integração com PCO apos a execução   º±±
±±           ³da procedure                       						  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ATF                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A050PCOPROC(cFilMov, cIdMov)

	Local cFilX	:= cFilAnt

	DbSelectArea("SN4")
	SN4->( DbSetOrder(6) )
	SN4->( DbSeek( xFilial("SN4", cFilMov) + cIdMov ) )

	PcoIniLan("000363")

	Do While SN4->(!Eof()) .And. SN4->(N4_FILIAL+N4_IDMOV) == xFilial("SN4", cFilMov) + cIdMov

		PcoDetLan("000363","01","ATFA050")

		SN4->( dbSkip() )
	EndDo

	PcoFinLan("000363")

	cFilAnt := cFilX

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} EngSPS11Signature
Processo 11 - CÁLCULO DE DEPRECIAÇÃO DE ATIVOS
Funções executadas durante a exibição de informações detalhadas 
do processo na interface de gestão de procedures.
Faz a execução de funções STATIC proprietárias das rotinas donas 
dos processos.

@return cAssinatura
@author  TOTVS
@since   13/12/2021
@version 12
/*/
//-------------------------------------------------------------------
Function EngSPS11Signature(cProcess as character)
Local cAssinatura as character

cAssinatura := STATICCALL(ATFA050,VERIDPROC)

Return cAssinatura

//Carrega variaveis estaticas da rotina
Function LoadVar050()


If __lEAI051 == NIL
	__lEAI051 	:= FWHasEAI("ATFA051",.T.,,.T.)
EndIF

If lIsRussia == NIL
	lIsRussia	:= If(cPaisLoc$"RUS",.T.,.F.) // CAZARINI - Flag to indicate if is Russia location
Endif

//Metricas
If __lMetric == NIL
	__lMetric	:= FwLibVersion() >= "20210517" .And. GetSrvVersion() >= "19.3.0.6"
Endif

If __lAf050CT == NIL
	__lAf050CT := SuperGetMv("MV_AF050CT", .F., .T.)
EndIf

Return
