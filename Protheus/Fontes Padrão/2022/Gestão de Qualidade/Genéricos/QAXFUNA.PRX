#include "PROTHEUS.CH"
#include "QAXFUNA.CH"
#include "AP5MAIL.CH"

#define Confirma 1
#define Redigita 2
#define Abandona 3

Static oMeter,oNome
Static __cEmpAnt
Static __cFilAnt

/*


Ŀ
Funo     QAXFUNA   Autor  Equipe Quality         Data 20/01/00  
Ĵ
Descrio  Rotinas comuns aos modulos do Siga Quality e tambem aos    
           modulos integrados.                                        
Ĵ
 Obs       Ultimo STR utilizado: 0033                                 
Ĵ
			ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.			  
Ĵ
Programador  Data	 BOPS   Motivo da Alteracao 					  
Ĵ
Vera        20/01/00------Inclusao da QA_GRVENT                     
Paulo Emidio01/07/00------Definicao da VAR lPrimDoc na QA_GRVENT    
                          Alteracao da VAR cRevi para Private na    
                          QA_GRVENT                                 
Paulo Emidio28/07/00------Alteracao da descricao do Lote no vetor   
                          aDados para 16 posicoes.                  
Aldo        28/07/00Meta  Inclusao da Funcao QAEnvMail()            
Paulo Emidio16/08/00MelhorRevisao e compatibilizacao da CTOD()      
Paulo Emidio06/09/00Meta  Alteracao na A200AtPA() para tratar o pla-
                          no de amostragem por Ensaio               
Paulo Emidio15/09/00META   Implementacao do Plano de Amostragem por 
                           Ensaios.                                 
Paulo Emidio20/09/00Melhor Gravacao do campo QEK_ORIGEM, que armaze-
                           na a origem do registro.                 
Paulo Emidio25/09/00------ Inicializacao da variavel nBMP := 1 utili
                           zada na ProcQdo().                       
Paulo Emidio05/10/00------ Acerto na gravacao do campo QEK_ORIGEM   
Paulo Emidio21/02/01------ Correcao na pesquisa no QF5, para grava- 
			   		 	    cao das especificacoes da Entrada no QF5.
Paulo Emidio08/06/01META   Foram eliminadas as funcoes QA_GRVENT() e
			   			    QAImpEnt(), devido a Implementacao da fun
			   			    cao qAtuMatQie() que realiza a Integracao
			   			    com Materiais e a Importacao de Dados    
Eduardo S.  30/11/01------ Acertado para enviar email com a conta do
                           usuario logado.                          
Eduardo S.  28/06/02 META  Inclusao da funcao QA_OPENARQ()          
Eduardo S.  01/11/02 ----  Alterado para autenticar conta de e-mail.
Eduardo S.  08/01/03------ Incluido a funcao QA_CONPAD() permitindo 
                           pesquisar usuarios de outras filiais.    
ٱ


*/

/*


Ŀ
Funo	  ProcQDO   Autor  Aldo / Marcelo         Data  13/07/98 
Ĵ
Descrio  Monta Tela de Processamento para Multiplas mensagems.      
Ĵ
Sintaxe	  ProcQDO(ExpB1,ExpC1,ExpC2,ExpL1)							  
Ĵ
Parametros ExpB1 = Funcao a ser executada      						  
           ExpC1 = Titulo (Caption) da janela  						  
           ExpC2 = Mensagem do processamento a ser realizado          
           ExpL1 = Indica se ter opcao de cancelar o processamento   
Ĵ
Uso		  Generico                               					  
      	  Obs.: Serao utilizadas as funcoes definidas abaixo:        
      	        QDChgBmp, QDProcRegua e QDIncProc                    
ٱ


*/
Function ProcQDO( bAction, cTitle ,cMsg,lAbort)
Local oDlg
Local lEnd := .f.
Local nVal := 0
Local nBmp := 0

DEFAULT lAbort  := .f.
DEFAULT bAction := { || nil }
DEFAULT cMsg := STR0011
DEFAULT cTitle := STR0012 //"Processando..."###"Aguarde"

DEFINE MSDIALOG oDlg FROM 12,35 TO 19.5, 75 TITLE OemToAnsi(cTitle) STYLE DS_MODALFRAME STATUS
@ 0.5, 3.0  SAY oNome VAR OemToAnsi(cMsg) SIZE 140, 10 OF oDlg FONT oDlg:oFont
@ 1.2,   0.5  METER oMeter VAR nVal TOTAL 10 SIZE 150, 10 OF oDlg
IF lAbort
	DEFINE SBUTTON FROM 31.5,127.5 TYPE 2 ACTION (lAbortPrint := .t.,lEnd := .t.) ENABLE OF oDlg
Else
	DEFINE SBUTTON FROM 31.5,127.5 TYPE 2 OF oDlg
Endif
oDlg:bStart = { || Eval( bAction, @lEnd ),lEnd := .t., oDlg:End() }
nBmp := 1

ACTIVATE DIALOG oDlg VALID lEnd

Return nil

Function QDChgBmp(nBmp,oBmp)
Local cBmp := "CLOCK01"
oBmp:cResName := cBmp
oBmp:SetBmp()
oBmp:Display()
Return

Function QDProcRegua(nTotal)
oMeter:nTotal := nTotal
nAtual := 0
Return

Function QDIncProc(cMsg)
Local nAtual	:= 0
oMeter:Set(++nAtual)
oNome :SetText(OemToAnsi(cMsg))
SysRefresh()
Return

/*/


Ŀ
Funo     A100DPla  Autor  Vera Lucia S. Simoes   Data  28.01.98 
Ĵ
Descrio  Gatilho para preencher a descricao do Plano de Amostragem  
Ĵ
Sintaxe    A100DPla(ExpC1,ExpL1)                                      
Ĵ
Parametros ExpC1 = Codigo do Plano de Amostragem                      
           ExpL1 = Indica se e' gatilho                               
Ĵ
 Uso       SigaQIE -Cham. no X3_RELACAO,X3_INIBRW 			          
ٱ


/*/
Function A100DPla(cCodPl,lGatilho)
lGatilho := Iif(lGatilho == NIL,.t.,lGatilho)

IF !Inclui .or. lGatilho   // Se Inic. Padrao ou gatilho a partir do cod. equipe
   If ! Empty(cCodPl)
      Return(Tabela("Q5",cCodPl))
   EndIf
EndIf
Return(Space(Len(X5Descri())))

/*/


Ŀ
Funo     A110DSit  Autor  Vera Lucia S. Simoes   Data  21.11.97 
Ĵ
Descrio  Gatilho para preencher a descricao Situacao                
Ĵ
Sintaxe    A110DSit(ExpC1,ExpL1)                                      
Ĵ
Parametros ExpC1 = Codigo da Situacao                                 
           ExpL1 = Indica se e' gatilho                               
Ĵ
 Uso       SigaQIE -Cham. no X3_RELACAO,X3_INIBRW e gat. (A5_SITU)    
ٱ


/*/
Function A110DSit(cSitu,lGatilho)
Local cRet := ""

lGatilho := Iif(lGatilho == NIL,.t.,lGatilho)

QEG->(dbSetOrder(1))
QEG->(dbSeek(xFilial("QEG") + cSitu))
cRet := QEG->QEG_NIVEL

Return(cRet)

/*/


Ŀ
Funo     A120DSLt  Autor  Vera Lucia S. Simoes   Data  12.01.98 
Ĵ
Descrio  Gatilho para preencher a descricao do Skip-Lote            
Ĵ
Sintaxe    A060DSLt(ExpC1,ExpL1)                                      
Ĵ
Parametros ExpC1 = Codigo do Skip-Lote                                
           ExpL1 = Indica se e' gatilho                               
Ĵ
 Uso       SigaQIE -Cham. no X3_RELACAO,X3_INIBRW e gat. (A5_SKPLOT)  
ٱ


/*/
Function A120DSLt(cSkLt,lGatilho)
Local cRet := ""
lGatilho := Iif(lGatilho == NIL,.t.,lGatilho)

// Verifica se o arquivo QEF est aberto
If Select("QEF") <> 0
	IF !Inclui .or. lGatilho   // Se Inic. Padrao ou gatilho a partir do cod. Skip-Lote
		QEF->(dbSetOrder(1))
		QEF->(dbSeek(xFilial("QEF") + cSkLt))
		cRet := QEF->QEF_DESCRI
	Else
		cRet := Space(Len(QEF->QEF_DESCRI))
	EndIf
EndIf
Return(cRet)

/*


Ŀ
Funo     QA_NUSR   Autor  Aldo Marini Junior     Data  24.04.98 
Ĵ
Descrio  Gatilho para preencher o nome do usuario                   
Ĵ
Sintaxe    QA_NUSR(ExpC1,ExpC2,ExpL1,ExpC3)                           
Ĵ
Parametros ExpC1 = Codigo da Filial                                   
           ExpC2 = Codigo do Funcionario                              
           ExpL1 = Indica se e' gatilho                               
           ExpC3 = "N" - Nome do Funcionario                          
                   "A" - Apelido do Funcionario                       
                   "C" - Codigo do Funcionario						  
Ĵ
 Uso       Quality -Cham. no X3_RELACAO,X3_INIBRW e gatilhos (Manual) 
ٱ


*/
Function QA_NUSR(cCodFI,cCodDe,lGatilho,cTipo)
Local aArea    := GetArea()
Local aAReaQAA := {}
Local cNome    := ""

DEFAULT cCodDe := Space(GetSX3Cache("QAA_MAT","X3_TAMANHO"))
DEFAULT cCodFi := IIF(!EMPTY(POSICIONE("QAA",6,TRIM(UPPER(cUserName)),"QAA_FILIAL")),POSICIONE("QAA",6,TRIM(UPPER(cUserName)),"QAA_FILIAL"),xFilial("QAA"))

dbSelectArea("QAA")
aAReaQAA := GetArea()
lGatilho := If(lGatilho==NIL,.T.,lGatilho)

If Type("INCLUI") == "U"
	Private Inclui := .F.
Endif

If nModulo == 21 .Or. nModulo == 25 .or. nModulo == 22 .or. nModulo == 47 // SigaQIE ou SigaQIP ou SigaQMT ou SigaPPAP
	If Empty(cCodDe)
		lGatilho := If(!lGatilho,.T.,lGatilho) //Forca o Retorno do Nome do Usuario
		dbSetOrder(6)
		If QAA->(MsSeek(TRIM(UPPER(cUserName))))
			cCodDe := QAA->QAA_MAT
		EndIf
	EndIf
EndIf

lGatilho := If(lGatilho==NIL,.T.,lGatilho)
cTipo    := If(cTipo==NIL,"N",cTipo)
cNome    := If(cTipo=="N",Space(Len(QAA->QAA_NOME)),Space(Len(QAA->QAA_APELID)))

If !Inclui .or. lGatilho   // Se Inic. Padrao ou gatilho
	dbSelectArea("QAA")
	dbSetOrder(1)
	If !Empty(cCodDe)
		dbSetOrder(1)
		If MsSeek(cCodFI + cCodDe)
			If cTipo == "N"
				cNome := PadR(QAA->QAA_NOME,40)
			Else
				cNome := QAA->QAA_APELID
			EndIf
		EndIf
	EndIf
EndIf

RestArea(aAReaQAA)
RestArea(aArea)

Return(If(cTipo=="C",cCodDe,cNome))

/*


Ŀ
Funo	  QA_Choice Autor  Alessandro B. Freire   Data  09/03/98 
Ĵ
Descrio  Browse de um array										  
Ĵ
Sintaxe	  QA_Choice( ExpA1, ExpA2, ExpN1, ExpC1 )					  
Ĵ
Parametros ExpA1 = Array de 2 elementos contendo o Conteudo no Browse 
			  		  (Titulo das opcoes) e o conteudo get (opcoes) 	  
			  ExpA2 = Array contendo as linhas de mensagem.			  
			  ExpN1 = Linha que deve ficar posicionado. 				  
			  ExpC1 = Titulo da janela.								  
Ĵ
Retorno	  Retorna a opcao escolhida no aChoice						  
Ĵ
 Uso		  QIEA200													  
ٱ


*/
Function QA_Choice( aOpc,aMsg,nOpc,cTit )
Local nPasso 	:= 1
Local nRet	 	:= 1
Local aShow	:= {}
Local oDlg
Local oListBox
Local nP		:= 3
Local cVar
Local lRet		:= .F.
Local oSayMsg
Local oSize

// Desmembra o array de Opcoes
For nPasso := 1 to Len( aOpc )
	AAdd( aShow, aOpc[nPasso][1] )
Next

DEFINE MSDIALOG oDlg TITLE cTit FROM  170,1 TO 400,558 PIXEL OF oMainWnd

oSize := FwDefSize():New(.T.,,,oDlg)

oSize:AddObject( "LISTBOX"	,  60, 100, .T., .T.) // No dimensionavel
oSize:AddObject( "MSG"   	,  40, 100, .T., .T.) // No dimensionavel

oSize:lLateral := .T. //Calculo em Lateral
oSize:lProp := .T. 	// Proporcional
oSize:aMargins := { 3, 3, 3, 3 } // Espaco ao lado dos objetos 0, entre eles 3

oSize:Process() // Dispara os calculos

@ oSize:GetDimension("LISTBOX","LININI") , oSize:GetDimension("LISTBOX","COLINI") TO ;
		oSize:GetDimension("LISTBOX","LINEND"),oSize:GetDimension("LISTBOX","COLEND") LABEL "" OF oDlg  PIXEL

@ oSize:GetDimension("LISTBOX","LININI")+3 , oSize:GetDimension("LISTBOX","COLINI")+3 LISTBOX oListBox VAR cVar ;
				 FIELDS HEADER ""  SIZE oSize:GetDimension("LISTBOX","XSIZE")-4,oSize:GetDimension("LISTBOX","YSIZE")-5 OF oDlg PIXEL ON CHANGE (nRet:=oListBox:nAt) ON DBLCLICK (lRet := .T.,oDlg:End())

oListBox:SetArray(aShow)
oListBox:bLine := { ||{aShow[oListBox:nAt]}}
oListBox:nAt := nOpc

@ oSize:GetDimension("MSG","LININI") , oSize:GetDimension("MSG","COLINI") TO ;
		oSize:GetDimension("MSG","LINEND") , oSize:GetDimension("MSG","COLEND") LABEL "" OF oDlg  PIXEL

For nPasso := 1 to Len( aMsg )
	@ oSize:GetDimension("MSG","LININI")+nP,oSize:GetDimension("MSG","COLINI")+3 Say oSayMsg VAR "" SIZE 153,7 OF oDlg PIXEL
   oSayMsg:SetText(aMsg[nPasso])
	nP:=nP+10
Next nPasso
oListBox:Refresh()

ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, {|| lRet:= .T., oDlg:End() },{|| lRet:=.F.,oDlg:End()})

Return( nRet )

/*


Ŀ
Funo	 QA_VerNum  Autor  Vera Lucia S. Simoes   Data  23.12.97 
Ĵ
Descrio  Verifica se o valor digitado e' um numero valido           
Ĵ
Sintaxe	  QA_VerNum(@ExpC1) 										  
Ĵ
Parametros ExpC1 = Valor digitado									  
Ĵ
 Uso		  Generico 												  
			  Obs.: Aceita numeros, sinal negativo e ',' ou '.' como se- 
			  		parador de casa decimal.							  
			  		Devolve o numero sempre com a picture com ',' como    
			  		separador de casa decimal. 							  
ٱ


*/
Function QA_VerNum(cValor)
Local nTamTot := len(cValor)
Local nTam    := len(alltrim(cValor))
Local cSubs
Local lRetu   := .t.
Local nI      := 1
Local nChr    := 0

//Ŀ
// chr(44) = ( Virgula )										 
// chr(45) = ( Negativo )										 
// chr(46) = ( Ponto Decimal )	 								 
//

While nI <= nTam .and. lRetu
	cSubs := Subs(alltrim(cValor),nI,1)

	//Ŀ
	// Consiste se e' numero, ponto, virgula ou sinal negativo      
	//
	If asc(cSubs) <> 44 .and. asc(cSubs) <> 45 .and. asc(cSubs) <> 46 .and. ;
			(asc(cSubs) < 48 .or. asc(cSubs) > 57)
		lRetu := .f.
	Else
		//Ŀ
		// Verifica a ocorrencia do ponto e virgula:						
		// Nao aceita mais de 1 ponto, mais de 1 virgula, ou ponto e virgu-
		// la ao mesmo tempo.												
		//
		If asc(cSubs) == 46 .or. asc(cSubs) == 44
			If empty(nChr)
				nChr := nI
			Else
				lRetu := .f.
			Endif
		Endif
		//Ŀ
		// Verifica se o sinal negativo esta' fora da 1a. posicao          
		//
		If asc(cSubs) == 45 .and. nI <> 1
			lRetu := .f.
		Endif
	Endif
	nI++
Enddo
If lRetu
	//Ŀ
	// Se digitou '.' como decimal, muda para ','                  
	//
	If cPaisLoc = "MEX"
		cValor := StrTran(cValor,',','.')
	Else
		cValor := StrTran(cValor,'.',',')
	EndIf

	//Ŀ
	// Se comecar com virgula, coloca zero antes						
	//
	If (left(alltrim(cValor),1) == ',') .OR.(left(alltrim(cValor),1) == '.')
		cValor := '0'+alltrim(cValor)
	ElseIf (left(alltrim(cValor),2) == '-,') .OR.(left(alltrim(cValor),2) == '-.')
		cValor := '-0'+right(alltrim(cValor),nTam-1)
	EndIf
	cValor := padr(cValor,nTamTot)

EndIf

return(lRetu)

/*


Ŀ
Funo	 QA_NumDec  Autor  Vera Lucia S. Simoes   Data  24.12.97 
Ĵ
Descrio  Retorna o numero de casas decimais de um valor			  
Ĵ
Sintaxe	  QA_NumDec(ExpC1)											  
Ĵ
Parametros ExpC1 = Valor digitado									  
Ĵ
 Uso		  Generico 												  
Ĵ
Antonio   09/09/99 Verificacao do Tipo de cValor para tratar valor   
                     numerico                                        
Antonio   14/12/99 Inclusao do If ValType(cValor) == "C"             
ٱ


*/
Function QA_NumDec(cValor)

Local nTam  := 0
Local nRetu := 0
Local nPos  := 0
Local nI 	:= 1
Local cVar  := ""
Local cByte := ""

If ValType(cValor) == "N"
	//Ŀ
	// Considera '.' como separador de casa decimal                    
	// Como e numerico necessariamente tem que ser '.'				    
	//
	cValor := AllTrim(Str(cValor) )
	cValor := StrTran(cValor,".",",")
	nTam := len(cValor)
ElseIf ValType(cValor) == "C"
	nTam := Len(AllTrim(cValor))
Else
	Return(nRetu)  // Ignora outros tipos
EndIf

If cPaisLoc == "MEX"
	For nI:= 1 to Len(cValor)
		cByte := Subs(cValor,ni,1)
		If cByte == ","
			cByte := "."
		Endif
		If cByte $"1234567890.-"
			cVar+= cByte
		EndIf
	Next
	nPos  := At('.',Alltrim(cVar)) // Considera '.' como separador de casa decimal
Else
	nPos  := At(',',Alltrim(cValor)) // Considera ',' como separador de casa decimal
Endif

nRetu := Iif(nPos<>0,nTam-nPos,nRetu)

Return(nRetu)

/*


Ŀ
Funo	  QA_SEQU	 Autor  Vera Lucia S. Simoes   Data  11/02/98 
Ĵ
Descrio  Gera o proximo codigo de uma sequencia, gravada no QA4	  
Ĵ
Sintaxe	  QA_SEQU(ExpC1,ExpN1,ExpC2,ExpC3) 						  
Ĵ
Parametros ExpC1 = Codigo Identificador da Sequencia ( Q??_???? )	  
			  ExpN1 = Tamanho do codigo								  
			  ExpC2 = Tipo do Codigo ( "N" - Numerico                    
			  							"A" - Alfanumerico                
			  							"S" - Sequencial no ano: 999/9999)
			  ExpC3 = Mensagem qdo nao consegue gerar o codigo			  
Ĵ
Retorno	  Retorna o codigo gerado ou "    " se nao conseguir gerar   
Ĵ
 Uso		  Generico 												  
ٱ


*/
Function QA_SEQU(cCodTab,nTamCod,cTipoCod,cMens,lLegSX6,cNewCod)
Local lSai   := .f.
Local cAlias := Alias()
Local cCodi  := Space(nTamCod)
Local cChvCer:= ""
Local cQuery
Local aArea
Local cIndex1  := ""
Local cKey     := ""
Local cFiltro  := ""
Local nIndex   := ""
Local aAreaAnt := ""

DEFAULT lLegSX6 := .F.
DEFAULT cNewCod := ""

If cTipoCod = "S"	// Controla o sequencial por ano
	dbSelectArea("QA4")
	If 	! dbSeek(xFilial("QA4")+cCodTab) // Nao achou o controle por ano
		DbSelectArea("QA4")
		If 	dbSeek(xFilial("QA4")+Left(cCodTab, Len(cCodTab) - 4)) .And.;
			Right(Trim(QA4_CHAVE),4) == Left(cCodTab, Len(cCodTab) - 4)
			RecLock("QA4",.F.)
			dbDelete()
			MsUnLock()
		Endif
		If lLegSX6
			cChvCer	:= cNewCod
		ElseIf cCodTab = "QIE_NNCO"
			If cCodTab == "QIE_NNCO"	// Garanto que o parametro esteja com o ano
				cCodTab += Alltrim(Str(Year(dDataBase)))
			Endif
			DbSelectArea("QEK")
			aArea := GetArea()
			DbSetOrder(5)
			DbSeek(xFilial() + Str(Val(Right(cCodTab, 4)) + 1, 4), .T.)
			If Left(QEK_NNCINV, 4) <> Str(Val(Right(cCodTab, 4)), 4)
				If Eof()
					DbGoBottom()
				Else
					DbSkip(-1)
				Endif
			Endif
			cChvCer := Subs(QEK_NNCINV, 5) + Left(QEK_NNCINV, 4)
			RestArea(aArea)
		ElseIf cCodTab = "QIE_CEQU"
			If cCodTab == "QIE_CEQU"	// Garanto que o parametro esteja com o ano
				cCodTab += Alltrim(Str(Year(dDataBase)))
			Endif
			DbSelectArea("QEK")
			aArea := GetArea()
			cQuery := SelDados(	"QEK", "QEK_FILIAL = '" + xFilial("QEK") + "' ",;
								,, { "MAX(QEK_CERQUA) QEK_CERQUA" },;
								"QEK_CERQUA LIKE '%" + Right(cCodTab, 4) + "'",;
								" .And. Right(QEK_CERQUA, 4) = '" + Right(cCodTab, 4) + "'", "QEK_CERQUA")
			(cQuery)->(DbGoBottom())
			cChvCer := (cQuery)->QEK_CERQUA
			RemoveSel("QEK")
			RestArea(aArea)
		ElseIf cCodTab = "QIP_CEQU" .And. cAlias = "SH6"
			If cCodTab == "QIP_CEQU"	// Garanto que o parametro esteja com o ano
				cCodTab += Alltrim(Str(Year(dDataBase)))
			Endif
			DbSelectArea("SH6")
			aArea := GetArea()
			cQuery := SelDados(	"SH6", "H6_FILIAL = '" + xFilial("SH6") + "' ",;
								,, { "MAX(H6_CERQUA) H6_CERQUA" },;
								"H6_CERQUA LIKE '%" + Right(cCodTab, 4) + "'",;
								" .And. Right(H6_CERQUA, 4) = '" + Right(cCodTab, 4) + "'", "H6_CERQUA")
			(cQuery)->(DbGoBottom())
			cChvCer := (cQuery)->H6_CERQUA
			RemoveSel("SH6")
			RestArea(aArea)
		ElseIf cCodTab = "QIP_CEQU" .Or. cCodTab = "QIP_NNCO"
			If cCodTab == "QIP_CEQU" .Or. cCodTab == "QIP_NNCO"	// Garanto que o parametro esteja com o ano
				cCodTab += Alltrim(Str(Year(dDataBase)))
			Endif
			DbSelectArea("SC2")
			aArea := GetArea()
			cQuery := SelDados(	"SC2", "C2_FILIAL = '" + xFilial("SC2") + "' ",;
								,, { "MAX(C2_CERQUA) C2_CERQUA" },;
								"C2_CERQUA LIKE '%" + Right(cCodTab, 4) + "'",;
								" .And. Right(C2_CERQUA, 4) = '" + Right(cCodTab, 4) + "'", "C2_CERQUA")
			(cQuery)->(DbGoBottom())
			cChvCer := (cQuery)->C2_CERQUA
			RemoveSel("SC2")
			RestArea(aArea)
		ElseIf cCodTab = "QMT_CERT"
			If cCodTab == "QMT_CERT"	// Garanto que o parametro esteja com o ano
				cCodTab += Alltrim(Str(Year(dDataBase)))
			Endif
			DbSelectArea("QM7")
			aArea := GetArea()
			cQuery := SelDados(	"QM7", "QM7_FILIAL = '" + xFilial("QM7") + "' ",;
								,, { "MAX(QM7_NRCERT) QM7_NRCERT" },;
								"QM7_NRCERT LIKE '%" + Right(cCodTab, 4) + "'",;
								" .And. Right(QM7_NRCERT, 4) = '" + Right(cCodTab, 4) + "'", "QM7_NRCERT")
			(cQuery)->(DbGoBottom())
			cChvCer := (cQuery)->QM7_NRCERT
			RemoveSel("QM7")
			RestArea(aArea)
		Else
			cChvCer := ""
		Endif

        If ! Empty(cChvCer)
			RecLock("QA4",.T.)
			QA4->QA4_FILIAL := xFilial("QA4")
			QA4->QA4_CODTAB := cCodTab
			QA4->QA4_CHAVE	:= cChvCer
			QA4->QA4_LIGDES := "0"
			MsUnLock()
		Endif
	Endif
Endif

//Ŀ
// Gera registro para a tabela, se nao existir     			
//
dbSelectArea("QA4")
dbSetOrder(1)
If !dbSeek(xFilial()+cCodTab)
	If RecLock("QA4",.t.)
		QA4->QA4_FILIAL := xFilial()
		QA4->QA4_CODTAB := cCodTab
		QA4->QA4_LIGDES := "1"
		dbCommit()
	Else
		lSai := .t.
	EndIf
Else
	//Ŀ
	// Se semaforo estiver ligado, da' mensagem e retorna s/ gerar codigo   
	//
	If QA4_LIGDES == '1'
		If ! Empty(cMens)
			HELP(" ",1,"QA_NAOSEQU",,cMens,2,1) // Nao foi possivel gerar a sequencia:
		EndIf
		lSai := .t.
	Else
		//Ŀ
		// Liga semaforo, para nao gerar o mesmo codigo para 2 usuarios	
		//
		If RecLock("QA4",.f.)
			QA4->QA4_LIGDES := "1"
			dbCommit()
		Else
			lSai := .t.
		EndIf
	EndIf
EndIf
If !lSai
	//Ŀ
	// Gera proximo codigo e atualiza o arquivo QA4				  	
	//
	If lLegSX6
		cCodi := cNewCod
	ElseIf cCodTab == "QIE_IDEN" .AND. Empty(QA4->QA4_CHAVE)
		aAreaAnt := GetArea()
		dbSelectArea("QEK")
 	    dbSetOrder(1)
		cIndex1 := CriaTrab( Nil, .F. )
		cKey:=IndexKey()
		cFiltro := 'QEK_FILIAL == "'+xFilial("QEK")+'"'
		IndRegua("QEK",cIndex1,cKey,,cFiltro,STR0021)//"Selecionando Registros.."
		nIndex := RetIndex("QEK")
	 	dbSetOrder(nIndex+1)
 		QEK->(dbGoTop())
 		dbGoTop()
		ProcRegua(LastRec())

	 	cCodi := QA_GRCOD(QEK->QEK_IDENTE,nTamCod,cTipoCod)

		//Ŀ
		// Restaura a Integridade dos dados   
		//
		RetIndex("QEK")
		Set Filter To
		fErase(cIndex1+OrdBagExt())

		RestArea(aAreaAnt)
	Else
		cCodi := QA_GRCOD(QA4_CHAVE,nTamCod,cTipoCod)
	Endif
	QA4->QA4_CHAVE  := cCodi
	QA4->QA4_LIGDES := "0"
	dbCommit()
	MsUnLock()
EndIf

dbSelectArea(cAlias)
Return( cCodi )

/*


Ŀ
Funo	  QA_GRCOD  Autor  Vera Lucia S. Simoes   Data  11/02/98 
Ĵ
Descrio  Gera a proxima sequencia de um numero					  
Ĵ
Sintaxe	  QA_GRCOD(ExpC1,ExpN1,ExpC2,ExpL1)						  
Ĵ
Parametros ExpC1 = Codigo Atual (Ultimo codigo utilizado)			  
			  ExpN1 = Tamanho do codigo								  
			  ExpC2 = Tipo do Codigo ( "N" - Numerico                    
			  						    "A" - Alfanumerico                
			  							"S" - Sequencial no ano:9999/9999)
			  ExpL1 = Indica se preenche o campo com zeros `a esquerda   
Ĵ
Retorno	  Retorna o codigo gerado 									  
Ĵ
 Uso		  Generico 												  
ٱ


*/
Function QA_GRCOD(cCodi,nTamCod,cTipoCod,lZeros)
Local cNovoCod
Local lSoma := .t.
Local nI
Local cDig
Local cRet

lZeros := If(lZeros==Nil,.F.,lZeros)

cCodi    := AllTrim(cCodi)
cNovoCod := ''

//Ŀ
// Gera proximo codigo para tipo alfanumerico						
//
If cTipoCod == 'A' .or. cTipoCod == 'C'
	For nI := Len(cCodi) to 1 Step -1
		lSoma := .f.
		cDig := Subs(cCodi,nI,1)
		If Asc(cDig) == 57	// No. 9
			cRet := 'A'
		ElseIf Asc(cDig) == 90	// Letra Z
			cRet := '0'
			lSoma := .t.
		Else
			cRet := Chr(Asc(cDig)+1)
		EndIf
		cNovoCod := cRet + cNovoCod

		If !lSoma
			cNovoCod := Subs(cCodi,1,nI-1) + cNovoCod
			Exit
		EndIf
	Next

	If lSoma
		cNovoCod := '1' + cNovoCod
	EndIf
	cNovoCod := Iif(lZeros,Right(Replicate("0",nTamCod)+AllTrim(cNovoCod),nTamCod),;
									Padl(AllTrim(cNovoCod),nTamCod))

ElseIf cTipoCod == 'S'
	//Ŀ
	// Gera proximo codigo para tipo sequencial no ano: 999999999/9999	  
	//
	// Verifica se o ano e' o mesmo
	If Right(cCodi,4) <> StrZero(Year(dDataBase),4)
		cNovoCod := StrZero(1,nTamCod-5) + '/' + StrZero(Year(dDataBase),4)
	Else
		cNovoCod := StrZero(Val(Subs(cCodi,1,nTamCod-5))+1,nTamCod-5) + ;
						'/' + StrZero(Year(dDataBase),4)
	EndIf

Else
	//Ŀ
	// Gera proximo codigo para tipo numerico							  
	//
	cNovoCod := Iif(lZeros,StrZero(Val(cCodi) + 1,nTamCod),;
								Padl(AllTrim(Str(Val(cCodi) + 1)),nTamCod))
EndIf
Return(cNovoCod)

/*


Ŀ
Funao	 QA_NivAces Autor  Vera Lucia S. Simoes   Data 04/05/1999
Ĵ
Descriao  Verifica se o usuario logado tem o nivel acesso requerido  
Ĵ
Sintaxe    ExpL1 := QA_NivAces(ExpN1,ExpC1)                           
Ĵ
Parametros ExpN1: Nivel de acesso requirido                           
           ExpC1: Mensagem a ser exibida se usuario nao tiver acesso  
           ExpL1: .T. se usuario tiver acesso e .F. se nao tiver      
Ĵ
 Uso		  Generico       											  
ٱ


*/
Function QA_NivAces(nNivel,cMens)
Local lRet := .T.

If !VerSenha(nNivel)
	MessageDlg(cMens,,3)
	lRet := .F.
EndIf
Return(lRet)

/*


Ŀ
Funao	 QA_CartEns Autor  Vera Lucia S. Simoes   Data  19/02/98 
Ĵ
Descriao  Retorna a Carta do Ensaio								  
Ĵ
Sintaxe	 QA_CARTENS(ExpC1)											  
Ĵ
Parametros ExpC1 = Codigo do Ensaio									  
Ĵ
 Uso		  QIEA210, QIEA181 (Rdmake Importacao Entradas)              
           QIE210LL (Rdmake calculo do Laudo do Laboratorio)          
           Esta funcao deve estar aqui porque eh acessada indireta-   
           mente pelo Estoque.                                        
ٱ


*/
Function QA_CARTENS(cEnsaio)
Local cAliOld := Alias()
Local nQE1Ord := QE1->(IndexOrd())

dbSelectArea("QE1")
QE1->(dbSetOrder(1))
dbSeek(xFilial("QE1")+cEnsaio)

QE1->(dbSetOrder(nQE1Ord))
If !Empty(cAliOld)
	dbSelectArea(cAliOld)
EndIf
Return(QE1->QE1_CARTA)

/*


Ŀ
Funao	 QA_DelMed  Autor  Vera Lucia S. Simoes   Data  04/03/98 
Ĵ
Descriao  Delecao da medicao com todas as suas amarracoes 			  
Ĵ
Sintaxe	  QA_DelMed(ExpC1)											  
Ĵ
Parametros ExpC1 = Carta do Ensaio 									  
Ĵ
 Uso		  Generico													  
ٱ


*/
Function QA_DelMed(cCarta)
Local cChvMed
Local cChvQER
Local cChvQEL
Local cLabQER
Local nRecQER
Local cAliOld := Alias()
Local aStrQEU
Local aCpoQNC
Local nOrdQEL  := 0
Local nOrdQER  := 0

//Ŀ
// Cancela a medicao que est posicionada 
//
dbSelectArea("QER")
RecLock("QER",.f.)
dbDelete()
MsUnLock()

nRecQER	:= QER->(Recno())

cChvQER := xFilial("QER")+QER->QER_PRODUT+QER->QER_REVI+QER->QER_FORNEC+;
			QER->QER_LOJFOR+QER->QER_NTFISC+QER->QER_SERINF+QER->QER_ITEMNF+QER->QER_TIPONF+QER->QER_LOTE

cChvQEL := xFilial("QEL")+QER->QER_FORNEC+QER->QER_LOJFOR+QER->QER_PRODUT+QEK->QEK_NTFISC+QEK->QEK_SERINF+QEK->QEK_ITEMNF+QEK->QEK_TIPONF+;
		   QER->QER_LOTE
nOrdQEL := 3
nOrdQER := 5

cLabQER := QER->QER_LABOR

//Ŀ
// Cria chave de ligacao da medicao com os outros arquivos 
//
cChvMed := QER->QER_CHAVE

If cCarta <> "TXT"
	dbSelectArea("QES")
	dbSetOrder(1)
	If dbSeek(xFilial("QES")+cChvMed)
		//Ŀ
		// Cancela os valores das medicoes (ensaios mensuraveis)
		//
		While QES->QES_FILIAL+QES->QES_CODMED == xFilial("QES")+cChvMed .And. !Eof()
			RecLock("QES",.f.)
			dbDelete()
			MsUnLock()
			dbSkip()
		EndDo
	EndIf
Else
	dbSelectArea("QEQ")
	dbSetOrder(1)
	If dbSeek(xFilial("QEQ")+cChvMed)
		//Ŀ
		// Cancela os valores das medicoes (ensaios texto) 
		//
		While QEQ->QEQ_FILIAL+QEQ->QEQ_CODMED == xFilial("QEQ")+cChvMed .And. !Eof()
			RecLock("QEQ",.F.)
			dbDelete()
			MsUnLock()
			dbSkip()
		EndDo
	EndIf
EndIf

//Ŀ
// Cancela os Instrumentos das medicoes 
//
dbSelectArea("QET")
dbSetOrder(1)
If dbSeek(xFilial("QET")+cChvMed)
	While QET->QET_FILIAL+QET->QET_CODMED == xFilial("QET")+cChvMed .And. !Eof()
		RecLock("QET",.F.)
		dbDelete()
		MsUnLock()
		dbSkip()
	EndDo
EndIf

//Ŀ
// Cancela as NCs das medicoes 
//
cEspecie := "QIEA210C"   // Cronicas das NCs
dbSelectArea("QEU")
dbSetOrder(1)
If dbSeek(xFilial("QEU")+cChvMed)
	While QEU->QEU_FILIAL+QEU->QEU_CODMED == xFilial("QEU")+cChvMed .And. !Eof()

		//Ŀ
		// 			Integracao  QIE x QNC					     
		//

		//Se existirem os novos campos realiza a integracao
		aStrQEU := QEU->(dbStruct())
 	    If Ascan(aStrQEU,{|x| AllTrim(x[1]) == "QEU_CODNC"}) > 0 .And.;
 	    	Ascan(aStrQEU,{|x| AllTrim(x[1]) == "QEU_REVNC"}) > 0

			//Ŀ
			// Caso haja alteracao no Resultado, apaga a NC corrente    
			//
			If !Empty(QEU->QEU_CODNC) .And. !Empty(QEU->QEU_REVNC)

				aCpoQNC := {}
			    Aadd(aCpoQNC,xFilial("QI2"))
				Aadd(aCpoQNC,QEU->QEU_CODNC)
				Aadd(aCpoQNC,QEU->QEU_REVNC)
				QNCGERA(2,aCpoQNC)

			EndIf
		EndIf
		//Final
		RecLock("QEU",.F.)
		dbDelete()
		MsUnLock()

		//Ŀ
		// Cancela a Cronica da NC 
		//
		QA_DelTxt(QEU->QEU_CHAVE,cEspecie)	// QAXFUN

		dbSelectArea("QEU")
		dbSkip()
	EndDo
EndIf

//Ŀ
// Se nao houver mais med. p/ o labor., cancela o Laudo Labor.  
//
dbSelectArea("QER")
dbSetOrder(nOrdQER)
If !dbSeek(cChvQER+cLabQER)
	dbSelectArea("QEL")
	dbSetOrder(nOrdQEL)
	If dbSeek(cChvQEL+cLabQER)
		RecLock("QEL",.F.)
		dbDelete()
		MsUnLock()
	EndIf
EndIf

//Ŀ
// Se nao houver mais med. p/ a Entrada, cancela o Laudo Entrada 
//
dbSelectArea("QER")
dbSetOrder(nOrdQER)
If !dbSeek(cChvQER)
	dbSelectArea("QEL")
	dbSetOrder(nOrdQEL)
	If dbSeek(cChvQEL+Space(GetSX3Cache("QEL_LABOR","X3_TAMANHO")))
		RecLock("QEL",.F.)
		dbDelete()
		MsUnLock()
	EndIf
EndIf

dbSelectArea("QER")
dbGoto(nRecQER)

//Ŀ
// Realiza a exclusao das NNCs vinculadas					   
//
QieAtuNNC(2)

dbSelectArea(cAliOld)
Return .T.

/*


Ŀ
Funo	 QA_DelTxt  Autor  Vera / Wanderley 	     Data  04.12.97 
Ĵ
Descrio  Deleta o texto editado com QA_TEXTO, a partir do axTextos. 
Ĵ
Sintaxe	  QA_DelTxt(ExpC1,ExpC2,ExpN1,ExpC3)						  
Ĵ
Parametros ExpC1 = Chave do Texto (j convertida) 					  
			  ExpC2 = Especie do Texto									  
			  ExpC3 = Alias do arquivo para leitura (QA2 ou tempor.)	  
			   Obs.:  Se for arq. temp., deve ter a mesma estrut. do QA2.
Ĵ
 Uso		  Generico 												  
ٱ


*/
Function QA_DelTxt(cChave,cEspecie,cAliasQA2)

Local cOldAlias := Select()
Local cAlias
cAlias := Iif(cAliasQA2 == NIL,"QA2",cAliasQA2)

//Ŀ
// Deleta o texto no QA2 ou arq. temporario 				    
//
dbSelectArea(cAlias)
dbseek(xFilial(cAlias) + cEspecie + cChave)
While !Eof() .and. QA2_FILIAL+QA2_ESPEC+QA2_CHAVE == xFilial(cAlias)+cEspecie+cChave
	RecLock(cAlias, .f.)
	dbDelete()
	dbSkip()
Enddo

dbSelectArea(cOldAlias)
Return

/*


Ŀ
Funo	 MessageDlg Autor  Fernando Godoy		 Data  8/10/1998
Ĵ
Descrio Mostra uma mensagem na tela 								  
Ĵ
Parametros[<ExpC1>] - Mensagem a ser exibida						  
			 [<ExpC2>] - Titulo da Janela ->Default "Atencao"            
			 [<ExpN1>] - Tipo de mensagem - Default "Stop"               
Ĵ
Retorno	 Nenhum 													  
Ĵ
Uso		 Generico													  
ٱ


*/
Function MessageDlg(cMensagem, cTitulo, nTipo )
Default cMensagem := ""
Default cTitulo	:= OemToAnsi(STR0001) //"Ateno"
Default nTipo		:= 1

Do case
	//Ŀ
	// Stop Erro 
	//
	Case nTipo == 1	// MsgStop
		MsgStop(cMensagem, cTitulo)
	//Ŀ
	// Informacao 
	//
	Case nTipo == 2
		MsgInfo(cMensagem, cTitulo)
	//Ŀ
	// Alert 
	//
	Case nTipo == 3
		MsgAlert(cMensagem, cTitulo)
	OtherWise
		MsgStop(cMensagem, cTitulo)
EndCase

Return Nil

/*


Ŀ
Funo    QAEnvMail  Autor  Aldo Marini Junior     Data  26/07/00 
Ĵ
Descrio  Rotina que envia e-mail de acordo com array                
Ĵ
Sintaxe    QAEnvMail(ExpA1)                                           
Ĵ
Parametros ExpA1 = Array com os dados de envio (To,Subject,Body,      
                   Attachment)                                        
           ExpC1 = Caracter contendo conta de acesso ao servidor      
           ExpC2 = Caracter contendo o endereco do servidor           
           ExpC3 = Caracter contendo senha de acesso ao servidor      
           ExpC4 = Caracter contendo a conta do Usuario logado        
Ĵ
 Retorno   lResult = Logico retornando se houve algum erro no envio   
Ĵ
 Uso       GENERICO                                                   
ٱ


*/
Function QAEnvMail(aUsuarios,cMailConta,cMailServer,cMailSenha,cSendConta,cTipoemail)
Local lResult	:= .F.
Local aRetUser := {}
Local nAtConta
Default cMailConta  := AllTrim(GETMV("MV_RELACNT"))
Default cMailServer := AllTrim(GETMV("MV_RELSERV"))
Default cMailSenha  := AllTrim(GETMV("MV_RELPSW"))
Default cSendConta  := "SIGA"+cModulo
Default cTipoemail	:= "1" //1=Sistemas 2=Usuario

//Ŀ
// Verifica se a conta de email do usuario esta com mais de uma e considera apenas 
// a primeira para conectar e enviar email                                         
//
If ";" $ cSendConta
	nAtConta := AT(";",cSendConta)
	cSendConta := SubStr(cSendConta,1,nAtConta-1)
Endif

If Len(aUsuarios) == 0
	Return(.F.)
Endif

IF cTipoemail=="2"  //Tipo 2=Usuario
	If cSendConta == ("SIGA"+cModulo) .Or. Empty(AllTrim(cSendConta))
		PswOrder(1)
		PswSeek(__CUSERID)
		aRetUser := PswRet(1)
		If !Empty(aRetUser[1][14])
			cSendConta := AllTrim(aRetUser[1][14])
	    Else
	        cSendConta := GetMV("MV_EMCONTA")
	        IF Empty(AllTrim(cSendConta))
				cSendConta := "SIGA"+cModulo+"@PROTHEUS"
			Endif
		EndIf
	Endif
Else				//Tipo 1=Sistemas
	cSendConta := GetMV("MV_EMCONTA")
	IF Empty(AllTrim(cSendConta))
		cSendConta := "SIGA"+cModulo+"@PROTHEUS"
	Endif
Endif

If Empty(AllTrim(cMailConta))
   cMailConta :=AllTrim(GETMV("MV_RELACNT"))
Endif

If Empty(AllTrim(cMailServer))
   cMailServer:=AllTrim(GETMV("MV_RELSERV"))
Endif

If Empty(AllTrim(cMailSenha))
   cMailSenha :=AllTrim(GETMV("MV_RELPSW"))
Endif

LjMsgRun(OemToAnsi(STR0002),OemtoAnsi(STR0003),{||QARunMail(aUsuarios,cMailConta,cMailServer,cMailSenha,@lResult,cSendConta)})  //"Enviando e-Mail para os Usuarios..." ### "Aguarde"

Return(lResult)

/*


Ŀ
Funo    QARunMail  Autor  Aldo Marini Junior     Data  26/07/00 
Ĵ
Descrio  Rotina que envia e-mail Mostrando Msg de Processamento     
Ĵ
Sintaxe    QARunMail(ExpA1)                                           
Ĵ
Parametros ExpA1 = Array com os dados de envio (To,Subject,Body,      
                   Attachment)                                        
           ExpC1 = Caracter contendo conta de acesso ao servidor      
           ExpC2 = Caracter contendo o endereco do servidor           
           ExpC3 = Caracter contendo senha de acesso ao servidor      
           ExpL1 = Logical  indicando Erro na Conexao ao Servidor     
           ExpC4 = Caracter contendo a conta do Usuario logado        
Ĵ
 Retorno   lResult = Logico retornando se houve algum erro no envio   
Ĵ
 Uso       GENERICO                                                   
ٱ


*/
Function QARunMail(aUsuarios,cMailConta,cMailServer,cMailSenha,lResult,cSendConta)
Local nA := 1
Local nI := 1
Local cError	:= ""
Local lAuth 	:= GetMv("MV_RELAUTH",,.F.)
Local lMsgError	:= GetMv("MV_QMSGERM", .T., .T.)
Default cMailConta := ""
Default cMailSenha := ""

cSendConta := If(Empty(GetMV("MV_RELFROM",.F.,"")),cSendConta,AllTrim(GetMV("MV_RELFROM")))

lResult	:= .F.

If !Empty(cMailServer) .And. If(lAuth,!Empty(cMailConta) .And. !Empty(cMailSenha),.T.)

	For nI :=1 to Len(aUsuarios)
        If !Empty(aUsuarios[nI,2])
        	If ! lResult
				// Envia e-mail com os dados necessarios
				CONNECT SMTP SERVER cMailServer ACCOUNT cMailConta PASSWORD cMailSenha RESULT lResult

				// Autenticacao da conta de e-mail
				If lResult .And. lAuth
					lResult := MailAuth(cMailConta,cMailSenha)
		 			If !lResult
						lResult := QAGetMail() // Funcao que abre uma janela perguntando o usuario e senha para fazer autenticacao
					EndIf
					If !lResult
						//Erro na conexao com o SMTP Server
						If lMsgError
							GET MAIL ERROR cError
							MsgInfo(cError,OemToAnsi(STR0009)) // "Erro de Autenticacao"
						Endif
						Return Nil
					Endif
				Else
					If !lResult
						//Erro na conexao com o SMTP Server
						If lMsgError
							GET MAIL ERROR cError
							MsgInfo(cError,OemToAnsi(STR0010)) // "Erro de Conexao"
						Endif
						Return Nil
					Endif
				EndIf
			Endif

			If lResult
				For nA := 1 to Len(aUsuarios[nI,3])
					If !lResult
						Exit
					Endif

					SEND        MAIL  ;
					FROM        cSendConta ;
					TO          aUsuarios[nI,2] ;
					SUBJECT     "Protheus SIGA"+cModulo+" "+aUsuarios[nI,3,nA,1] ;
					BODY        aUsuarios[nI,3,nA,2] ;
					ATTACHMENT  aUsuarios[nI,3,nA,3];
					RESULT      lResult
		    	Next

				If !lResult
					//Erro no envio do email
					If lMsgError
						GET MAIL ERROR cError
						MsgInfo(cError,OemToAnsi(STR0004)) // "Erro no envio de e-Mail"
					Endif
				EndIf
		    EndIf
		    If ! lResult
				DISCONNECT SMTP SERVER
			Endif
		Endif
	Next
	If lResult
		DISCONNECT SMTP SERVER
	Endif
EndIf

Return Nil

/*

Ŀ
Funo    QA_OPENARQ  Autor  Eduardo de Souza      Data  25/06/02 
Ĵ
Descrio  Programa para abrir arquivo com qualquer extensao.         
Ĵ
Sintaxe    QA_OPENARQ(ExpC1)                                          
Ĵ
Parametros ExpC1 - Arquivo                                            
Ĵ
 Uso       QUALITY                                                    
ٱ

*/
Function QA_OPENARQ(cArquivo)

Local cDrive := ""
Local cDir   := ""
Local nRet   := 0
Local lReturn:= .T.
Local lRemotp:= GetRemoteType() == 2   //Checa se o Remote e Linux
Local lMacOS := .F.
Local cLibCli:= ""

Default cArquivo:= ""

GetRemoteType( @cLibCli )
lMacOS := Iif('MAC' $ cLibCli,.T.,.F.)

SplitPath(cArquivo,@cDrive,@cDir)
cDir:= Alltrim(cDrive)+Alltrim(cDir)

//Ŀ
// Faz a chamada do aplicativo associado  
//
If lMacOS
	Waitrun("open "+STUFF(cArquivo,AT(cDrive,cArquivo),Len(cDrive),""))
ElseIf lRemotp
	If !IsSrvUnix()  // verifica se o server no  linux
		Waitrun("gnome-open "+STUFF(cArquivo,AT(cDrive,cArquivo),Len(cDrive),""))
	else
	    WinExec("linexec "+STUFF(cArquivo,AT(cDrive,cArquivo),Len(cDrive),""))
    EndIF
Else
	nRet:= ShellExecute("Open", AllTrim(cArquivo),"",cDir,1)
 	If nRet = 0//<= 32 -- Mudana de retorno da funo ShellExecute
		Help(" ",1,"QANABRIR") // "Nao foi possivel abrir o arquivo, o arquivo nao esta associado a um programa ou o arquivo nao existe."
		lReturn:= .F.
	EndIf
Endif

Return lReturn

/*


Ŀ
Funo    QA_FatIQP   Autor Paulo Emidio de Barros Data 03/08/2002
Ĵ
Descrio  Verifica se existem todos os fatores de IQP cadastrados	  
Ĵ
Sintaxe    QA_FatIQP()												  
Ĵ
Parametros Nenhum								   					  
Ĵ
 Uso       QUALITY                                                    
ٱ


*/
Function QA_FatIQP()
Local lRetorno := .T.
Local aFatores := {}
Local nFatIQP

Aadd(aFatores,{"A","1",.F.}) //Aprovado sem Restricoes
Aadd(aFatores,{"B","2",.F.}) //Aceito com Desvio Simples
Aadd(aFatores,{"C","2",.F.}) //Aceito com Desvio Grave
Aadd(aFatores,{"D","2",.F.}) //Aceito com Selecao do Fornecedor
Aadd(aFatores,{"E","3",.F.}) //Rejeitado Totalmente
Aadd(aFatores,{"U","4",.F.}) //Liberado Urgente

QED->(dbSetOrder(1))
QED->(dbSeek(xFilial('QED')))
While QED->(!Eof()) .And. xFilial('QED') == QED->QED_FILIAL
	nFatIQP := Ascan(aFatores,{|x|x[1]==QED->QED_CODFAT})
	If nFatIQP > 0
		If (aFatores[nFatIQP,2]==QED->QED_CATEG)
			aFatores[nFatIQP,3] := .T.
		EndIf
	EndIf
	QED->(dbSkip())
EndDo

nFatIQP := Ascan(aFatores,{|x|!x[3]})

If nFatIQP > 0
     Help(" ",1,"QNAOFATIQP",,)
     lRetorno := .F.
EndIf

Return(lRetorno)

/*

Ŀ
Funo     QA_NORMA  Autor  Eduardo de Souza       Data  26/08/02 
Ĵ
Descrio  Gatilho para preencher a descricao da Norma                
Ĵ
Sintaxe    QA_NORMA(ExpC1,ExpL1)                                      
Ĵ
Parametros ExpC1 = Codigo da Filial                                   
           ExpL1 = Indica se e' gatilho                               
Ĵ
 Uso       QUALITY                                                    
ٱ

*/
Function QA_NORMA(cNorma,lGatilho)

Local aArea:= GetArea()
Local cDesc:= ""

Default cNorma  := Space(GetSX3Cache("QAK_NORMA","X3_TAMANHO"))
Default lGatilho:= .T.

DbSelectArea("QAK")
DbSetOrder(1)
If QAK->(DbSeek(xFilial("QAK")+cNorma))
	cDesc:= QAK->QAK_DESC
EndIf

RestArea(aArea)

Return(cDesc)

/*


Ŀ
Funo	 QA_SEQUSX6 Autor  Aldo Marini		     Data  01/10/02 
Ĵ
Descrio  Gera o proximo codigo de uma sequencia, gravada no QA4	  
Ĵ
Sintaxe	  QA_SEQU(ExpC1,ExpN1,ExpC2,ExpC3) 						  
Ĵ
Parametros ExpC1 = Codigo Identificador da Sequencia ( Q??_???? )	  
			  ExpN1 = Tamanho do codigo								  
			  ExpC2 = Tipo do Codigo ( "N" - Numerico                    
			  							"A" - Alfanumerico                
			  							"S" - Sequencial no ano: 999/9999)
			  ExpC3 = Mensagem qdo nao consegue gerar o codigo			  
Ĵ
Retorno	  Retorna o codigo gerado ou "    " se nao conseguir gerar   
Ĵ
 Uso		  Generico 												  
ٱ


*/
Function QA_SEQUSX6(cCodTab,nTamCod,cTipoCod,cMens)
Local cCodi  		:= Space(nTamCod)
Local cCodBsc 		:= ""
Local cCtdCodBsc	:= ""
Local cSX6Fil 		:= ""
Local nHandQA4 		:= 0
LOCAL __cName 		:= "QA4LOCK.LCK"
LOCAL nTrys   		:= 0

While ( nHandQA4 := MSFCREATE(__cName) ) < 0
	nTrys++
	SysRefresh()
	IF nTrys > 60
		IF Ca100Msg()
			Return " "			// Desistencia
		Else
			nTrys := 0
		Endif
	Endif
	Inkey( ((nTrys%10)+1) / 20 )	// Tempo Varivel de 0.05 a 0.5 segundos
Enddo

// Grava no Semaforo quem est realizando a operao.
FWrite(nHandQA4,"Operador: "+cUserName+chr(13)+chr(10)+;
"Funcao..: "+FunName()+chr(13)+chr(10))

If UPPER(ALLTRIM(cCodTab)) == "QIE_IDEN"
	cCodBsc := "MV_QID"+StrZero(Year(dDataBase),4)
ElseIf UPPER(ALLTRIM(cCodTab)) == "QIE_CEQU"
	cCodBsc := "MV_QCQ"+StrZero(Year(dDataBase),4)
ElseIf UPPER(ALLTRIM(cCodTab)) == "QIE_NNCO"
	cCodBsc := "MV_QNN"+StrZero(Year(dDataBase),4)
ElseIf UPPER(ALLTRIM(cCodTab)) == "QIP_CEQU"
	cCodBsc := "MV_QCP"+StrZero(Year(dDataBase),4)
Endif

//Ŀ
// Gera registro para a tabela, se nao existir     			
//
dbSelectArea("QA4")
dbSetOrder(1)

cCtdCodBsc := GetMv(cCodBsc,.T.,"*")
If cCtdCodBsc == "*"
	If QA4->(dbSeek(xFilial("QA4")+cCodTab))
		cSX6Fil := QA4->QA4_FILIAL
		cCodi   := QA_GRCOD(QA4->QA4_CHAVE,nTamCod,cTipoCod)
	Else
		cSX6Fil := xFilial("SX6")
		If cTipoCod == "S"
			cCodi := QA_GRCOD(Replicate("0",nTamcod-5)+"/"+StrZero(Year(dDataBase),4),nTamCod,cTipoCod)
		Else
			cCodi := QA_GRCOD(" ",nTamCod,cTipoCod)
		Endif
	Endif
	cCodi := QA_SEQU(cCodTab,nTamCod,cTipoCod,cMens,.T.,cCodi)
Else
	cCodi := QA_GRCOD(cCtdCodBsc,nTamCod,cTipoCod)
	PutMv( cCodBsc, cCodi )
Endif

FClose(nHandQA4)	// Libera o semaforo
Ferase(__cName)

Return(cCodi)

/*

Ŀ
Funo    QAGetMail  Autor  Eduardo de Souza       Data  30/10/02 
Ĵ
Descrio  Tela solicitando usuario e senha para autenticacao da conta
Ĵ
Sintaxe    QAGetMail()                                                
Ĵ
 Uso       GENERICO                                                   
ٱ

*/
Function QAGetMail()

Local oDlg
Local oMailUsr
Local oMailPsw
Local oBtn1
Local oBtn2
Local cMailUsr:= Space(50)
Local cMailPsw:= Space(50)
Local lReturn := .F.

DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0005) FROM 000,000 TO 105,425 OF oDlg PIXEL // "Autenticacao de e-Mail"

@ 006,003 SAY OemToAnsi(STR0006) SIZE 040,010 OF oDlg PIXEL // "e-Mail"
@ 005,033 MSGET oMailUsr VAR cMailUsr SIZE 160,005 OF oDlg PIXEL

@ 019,003 SAY OemToAnsi(STR0007) SIZE 040,010 OF oDlg PIXEL // "Senha"
@ 018,033 MSGET oMailPsw VAR cMailPsw PASSWORD SIZE 160,005 OF oDlg PIXEL

DEFINE SBUTTON oBtn1 FROM 038,151 TYPE 1 ENABLE OF oDlg;
       ACTION If(MailAuth(AllTrim(cMailUsr),AllTrim(cMailPsw)),;
       			(lReturn:= .T.,oDlg:End()),MsgStop(OemToAnsi(STR0008))) // "Usuario e/ou Senha nao estao corretos, tente novamente."

DEFINE SBUTTON oBtn2 FROM 038,181 TYPE 2 ENABLE OF oDlg;
       ACTION  oDlg:End()

ACTIVATE MSDIALOG oDlg CENTERED

Return lReturn

/*

Ŀ
Funo    QA_QPLINHA Autor  Eduardo de Souza       Data  25/11/02 
Ĵ
Descrio  Quebra linha verificando se a palavra final cabe na impres.
Ĵ
Sintaxe    QA_QPLINHA(ExpC1,ExpN1)                                    
Ĵ
Parametros ExpC1 - String                                             
           ExpN1 - Tamanho para verificacao da quebra                 
Ĵ
 Uso       GENERICO                                                   
ٱ

*/
Function QA_QPLINHA(cPalavra,nTam)

Local aArray:= {}
Local cTexto:= ""

cPalavra:= AllTrim(cPalavra)

While !Empty(cPalavra)
	cTexto:= SubsTr(cPalavra,1,nTam)
	If Len(cPalavra) > nTam
		If !Empty(SubStr(cPalavra,nTam,1)) .And. !Empty(SubStr(cPalavra,nTam+1,1))
			If At(" ",cTexto) > 0
				While At(" ",cTexto) > 0
					cTexto:= SubStr(cTexto,At(" ",cTexto)+1)
				EndDo
				Aadd(aArray, SubStr(cPalavra,1,nTam-Len(cTexto)))
				cPalavra:= SubStr(cPalavra,nTam-Len(cTexto))
			Else
				Aadd(aArray, SubStr(cPalavra,1,nTam))
				cPalavra:= SubStr(cPalavra,nTam+1)
			EndIf
		Else
			Aadd(aArray, SubStr(cPalavra,1,nTam))
			cPalavra:= SubStr(cPalavra,nTam+1)
		EndIf
		If Empty(SubStr(cPalavra,1,1))
			cPalavra:= SubStr(cPalavra,2)
		EndIf
	Else
		Aadd(aArray,cPalavra)
		cPalavra:= " "
	EndIf
EndDo

Return aArray

/*

Ŀ
Funo    QA_ConPad  Autor  Eduardo de Souza       Data  08/01/03 
Ĵ
Descrio  Executa Conpad padrao permitindo a pesquisa entre filiais. 
Ĵ
Sintaxe    QA_Conpad()                                                
Ĵ
 Uso       GENERICO                                                   
ٱ

*/
Function QA_Conpad(cAlias,lMen)

Local lRet  := .F.
Local cCpo  := Upper(AllTrim(ReadVar()))
Local nPos  := At("->",Upper(cCpo))
Local cCampo:= SubStr(cCpo,If(nPos>0,nPos+2,0))
Local cProg := Upper(FunName())
Default lMen:= .F.

If Type("cFilMat") == "U"
	cFilMat := cFilAnt
Endif

__cFilAnt:= cFilAnt

If cProg == "QAXA010"
	cFilAnt:= cCcFilial
ElseIf cProg == "QAXA030"
	cFilAnt:= M->QAD_FILMAT
ElseIf cProg == "QDOM020"
	cFilAnt:= cFil020
ElseIf cProg == "QDOC040"
	cFilAnt:= cFil040
ElseIf nModulo == 24 // SIGAQDO
	If Type("nQaConPad") <> "U"
		If nQaConpad == 1 // Cadastro de Responsaveis
			nPosFil:= Ascan( aHeader, { |X| Upper( Alltrim( X[2] ) ) = "QD0_FILMAT"} )
			cFilAnt:= Acols[n,nPosFil]

		ElseIf nQaConpad == 2 // Cadastro de Departamentos
			cFilAnt:= M->QAD_FILMAT

		ElseIf nQaConpad == 3 // Cadastro de Treinamentos
			If cCampo == "QDA_MAT1"
				cFilAnt:= M->QDA_FILF1
			ElseIf cCampo == "QDA_MAT2"
				cFilAnt:= M->QDA_FILF2
			ElseIf cCampo == "QDA_MAT3"
				cFilAnt:= M->QDA_FILF3
			EndIf

		ElseIf nQaConpad == 4 // Importacao de Documentos ### Distribuicao de Documentos
			If cCampo == "CCODDEP"
				cFilAnt:= cFilDep
			Else
				cFilAnt:= cFilMat
			EndIf

		ElseIf nQaConpad == 5 // Aviso E-Mail
			If cCampo == "CDEQAAMAT"
				cFilAnt:= cDeQAAFil
			ElseIf cCampo == "CATEQAAMAT"
				cFilAnt:= cAteQAAFil
			EndIf

		ElseIf nQaConpad == 6 // Cadastro de Treinamentos
			If cCampo == "QAE_MAT"
				cFilAnt:= M->QAE_FILMAT
			ElseIf cCampo == "QAF_MAT"
				cFilAnt:= Acols[n,nPosFUs]
			EndIf

		ElseIf nQaConpad == 7 // Tipo de Documentos
			If cCampo == "QD2_DEPTO"
				cFilAnt:= M->QD2_FILDEP
			ElseIf cCampo == "QDD_DEPTOA"
				cFilAnt:= Acols[n,nPosFil]
			EndIf

		ElseIf nQaConpad == 8 // Cadastro de Pastas
			If cCampo == "QDT_DEPTO"
				cFilAnt:= Acols[n,nPosFil]
			EndIf

		ElseIF nQaConpad == 9 // Escolha de Distribuidores QDZ
		    IF cCampo == "QDZ_DEPTO"
				cFilAnt:= Acols[n,nPosFil]
			Endif
		EndIf
	ElseIf Type("cFilMat") <> "U"
		cFilAnt := cFilMat
	Endif
ElseIf nModulo == 36 // SIGAQNC
	If Type("nQaConPad") <> "U"

		If nQaConPad == 1 // Ficha de Nao-Conformidade
			If cCampo == "QI2_MATRES"
				cFilAnt:= M->QI2_FILRES
			ElseIf cCampo == "QI2_ORIDEP"
				cFilAnt:= M->QI2_FILORI
			ElseIf cCampo == "QI2_DESDEP"
				cFilAnt:= M->QI2_FILDEP
			EndIf

		ElseIf nQaConPad == 2 // Plano de Acao
			If cCampo == "QI3_MAT"
				cFilAnt:= M->QI3_FILMAT
			ElseIf cCampo == "QI4_MAT"
				cFilAnt:= Acols[n,nPosFilQi4]
			ElseIf cCampo == "QI5_MAT"
				cFilAnt:= Acols[n,nPosFilQi5]
			EndIf
		EndIf
	ElseIf Type("cFilMat") <> "U"
		cFilAnt := cFilMat
	EndIf


ElseIf nModulo == 37 // SIGAQAD
	If Type("nQaConPad") <> "U"
		If nQaConPad == 1 // Auditoria
			If cCampo == "QUA_MAT"
				cFilAnt:= M->QUA_FILMAT
			ElseIf cCampo == "QUB_AUDLID"
				cFilAnt:= M->QUB_FILMAT
			ElseIf cCampo == "QUC_CODAUD"
				cFilAnt:= oGetAudit:Acols[n,nPosFilAud]
			ElseIf cCampo == "QUH_CODAUD"
				cFilAnt:= oGetArea:Acols[n,nPosFilRes]
			ElseIf cCampo == "QUM_CODAUD"
				cFilAnt:= oGet:Acols[n,nPosFilRes]
			EndIf

		ElseIf nQaConPad == 2 // Encerramento de Auditoria
			cFilAnt:= M->QUB_FILMAT
        Endif
	ElseIf Type("cFilMat") <> "U"
		cFilAnt := cFilMat
	EndIf

ElseIf nModulo == 22 // SIGAQMT
	If Type("nQaConPad") <> "U"
		If nQaConpad == 1 // Calibracoes
			cFilAnt:= M->QM6_FILRES
		ElseIf nQaConpad == 2 // Cadastro de Instrumentos
			cFilAnt:= M->QM2_FILRES
		ElseIf nQaConpad == 3 // Cadastro de Instrumentos
			cFilAnt:= M->QML_FILREL
		Endif
    Else
    	cFilAnt := cFilMat
	Endif
EndIf

If lMen .And. nQaConpad == 4 .And. cCampo == "CCODPST"
	cFilAnt:= cFilPst
ElseIf cCampo == "CCODPST"
	cFilAnt:= __cFilAnt
Endif

lRet   := ConPad1(,,,cAlias,,,.F.)
cFilAnt:= __cFilAnt

Return lRet

/*


Ŀ
Funo    QA_SaveSX1 Autor  Paulo Emidio de Barros Data  16/01/03 
Ĵ
Descrio  Salva o conteudo das perguntas atuais					  
Ĵ
Sintaxe    QA_SaveSX1()												  
Ĵ
 Uso       GENERICO                                                   
ٱ


*/
Function QA_SaveSX1()
Local aSX1 := {}
Local nIni := 0
Local nMax := 99
Local xConteudo

For nIni := 1 to nMax
	xConteudo := "MV_PAR"+StrZero(nIni,2)
	If Type(xConteudo) <> "U"
		Aadd(aSX1,&xConteudo)
	Else 
		Exit
	EndIf
Next nMx

Return(aSX1)

/*


Ŀ
Funo    QA_RestSX1 Autor  Paulo Emidio de Barros Data  16/01/03 
Ĵ
Descrio  Recupera o conteudo das perguntas 						  
Ĵ
Sintaxe    QA_SaveSX1()												  
Ĵ
 Uso       GENERICO                                                   
ٱ


*/
Function QA_RestSX1(aSX1)
Local xConteudo

Aeval(aSX1,{|x,y|xConteudo:="MV_PAR"+StrZero(y,2),&xConteudo:=x})

Return(NIL)

/*/


Ŀ
Funcao     QA_Plano  Autor  Marcos Cesar           Data 01.08.2003
Ĵ
Descrio Retorna o codigo da norma.                                  
Ĵ
Sintaxe   ExpC1 := QA_Plano(ExpC2,ExpL1)                              
Ĵ
Retorno   ExpC1 = O codigo da Norma.                                  
Ĵ
ParametrosExpC2 == Tipo da Amostra.                                   
			 ExpL1 == Indica se retorna a descricao					  
ٱ


/*/
Function QA_Plano(cTipoAmo,lDescricao)
Local cNorma := ""

lDescricao := If(lDescricao==NIL,.F.,lDescricao)

//Ŀ
// Verifica qual a norma escolhida pelo usuario.                      
//
If cTipoAmo == "1" .Or. cTipoAmo == "N" //NBR-5426
	If lDescricao
	    cNorma := STR0013 //"NBR-5426"
	Else
		cNorma := "NB5426"
	EndIf
ElseIf cTipoAmo == "2" .Or. cTipoAmo == "Z" //Zero Defeito
	If lDescricao
		cNorma := STR0014 //"Zero defeito"
	Else
		cNorma := "QS9000"
	EndIf
ElseIf cTipoAmo == "3" .Or. cTipoAmo == "I" //Plano Interno
	If lDescricao
		cNorma := STR0015 //"Plano Interno"
	Else
		cNorma := "INTERN"
	EndIf
ElseIf cTipoAmo == "4" .Or. cTipoAmo == "T" //Plano Texto
	If lDescricao
		cNorma := STR0016 //"Plano Texto"
	Else
		cNorma := "PTEXTO"
	EndIf
ElseIf cTipoAmo == "5" .Or. cTipoAmo == "B" //NBR-5429
	If lDescricao
		cNorma := STR0017 //"NBR-5429"
	Else
		cNorma := "NB5429"
	EndIf
Else
	cNorma := Space(GetSX3Cache("QA6_PLANO","X3_TAMANHO"))
EndIf

Return(cNorma)

/*/


Ŀ
Funcao    QA_CalcDV  Autor  Marcos Cesar           Data 04.08.2003
Ĵ
Descrio Realiza o calculo do Desvio Padrao, retornando o resultado. 
Ĵ
Sintaxe   ExpA1 := QA_CalcDv(ExpA2)                                    
Ĵ
Retorno   ExpA1 = Array com a Media e o Desvio Padrao.                
                  ExpA1[1] : Media                                    
                  ExpA1[2] : Desvio Padrao                            
Ĵ
ParametrosExpA2 == Array com as medicoes.                             
ٱ


/*/
Function QA_CalcDV(aMedicao)

Local nA       := 0
Local nMedia   := 0
Local nDesvPad := 0

//Ŀ
// Calcula a Media.                                                   
//
For nA := 1 To Len(aMedicao)
	nMedia += SuperVal(aMedicao[nA])
Next nA

nMedia := nMedia / Len(aMedicao)

//Ŀ
// Calcula o Desvio Padrao.                                           
//
For nA := 1 To Len(aMedicao)
	nDesvPad += (SuperVal(aMedicao[nA]) - nMedia) ** 2
Next nA

nDesvPad := Sqrt( nDesvPad / ( Len(aMedicao) - 1 ) )

Return({nMedia,nDesvPad})

/*


Ŀ
Funo	 QA_UltRvDc   Autor Cleber Souza 	     Data  19/02/04 
Ĵ
Descrio  Retorna a ultima revisao vigente de um documento			  
Ĵ
Parametros ExpC1 = Documento										  
			  ExpD1 = Data de Referencia 								  
			  ExpL1 = Indica se mostra mensagem de revisao nao disponivel
			  ExpL2 = Traz ultima revisao independente da Data           
Ĵ
 Uso		  Generico 												  
ٱ


*/
Function QA_UltRvDc(cDocto,dData,lMsg,lUltRv)

Local cRevisao  := "  "
Local dVigencia := Ctod("")
Local aAreaAnt  := GetArea()
Local aAreaQDH  := QDH->(GetArea())

dData  := If(dData==NIL,dDataBase,dData)
lMsg   := If(lMsg==NIL,.T.,lMsg)
lUltRv := If(lUltRv==NIL,.F.,lUltRv)

//Ŀ
// Pesquisa a revisao vigente na data de referencia			    
//
QDH->(dbSetOrder(6))
QDH->(dbSeek(xFilial("QDH")+cDocto))

While QDH->(!Eof()) .And. QDH->QDH_FILIAL==xFilial("QDH") .And. QDH->QDH_DOCTO==cDocto
	If QDH->QDH_CANCEL<>"S" .AND. QDH->QDH_STATUS == "L  "
		cRevisao  := QDH->QDH_RV
		dVigencia := QDH->QDH_DTVIG
	EndIF

	If !Empty(QDH->QDH_DTVIG) .And. QDH->QDH_DTVIG <= dData .or. lUltRv
		Exit
	EndIf

	QDH->(dbSkip())
EndDo

//Ŀ
// Digita a Justificativa e gera Historico do Plano Amostragem     
//
If dVigencia > dData  .and. !lUltRv
	cRevisao :=  "  "
EndIf

If Empty(cRevisao)
	If lMsg
		HELP(" ",1,"QA_NREVDOC",,cDocto,2,1) //Docto nao tem revisao disponivel
	EndIf
EndIf

RestArea(aAreaQDH)
RestArea(aAreaAnt)

Return(cRevisao)

/*


Ŀ
Funo	 QA_UltRevEsp Autor Paulo Emidio de Barros Data 25/05/2004
Ĵ
Descrio  Retorna a Revisao Vigente da Especificacao do Produto	   
Ĵ
Sintaxe    QA_UltRevEsp(EXPC1,EXPD1,EXPL1,EXPL2,EXPC2)				   
Ĵ
Parametros EXPC1 = Codigo do Produto								   
			  EXPD1 = Data de Referencia para Vigencia					   
			  EXPL1 = Indica se o Help sera exibido em caso de erro	   
			  EXPL2 = Retorna a maior data vigente						   
			  EXPC2 = Ambiente para retorno da Revisao					   
Ĵ
Retorno    EXPL1 = Indica se mostra mensagem de revisao nao disponivel 
Ĵ
 Uso		  Generico 												   
ٱ


*/
Function QA_UltRevEsp(cProduto,dVigencia,lMsg,lUltima,cOrigem)
Local cRevisao     := " "
Local aAreaAnt     := GetArea()
Local cAlias       := " "
Local dIniVigencia := Ctod("")
Local lVerifica
Local lProduto
Local lQipMat  := .T.

dbSelectArea("SB1")
SB1->(dbSetOrder(1))
lProduto := SB1->(MsSeek(xFilial("SB1")+cProduto))

If cOrigem == "QIE" //Inspecao de Entradas
	cAlias := "QE6"
ElseIf cOrigem == "QIP" //Inspecao de Processsos
	cAlias := "QP6"
EndIf

dVigencia 	 := If(dVigencia==NIL,dDataBase,dVigencia)
lMsg      	 := If(lMsg==NIL,.T.,lMsg)
lUltima   	 := If(lUltima==NIL,.F.,lUltima)
lMt650RevDis := If(Type("lMt650RevDis") == "U",.F.,lMt650RevDis)

//Caso venha das OPs previstas no apresenta mensagem
If IsInCallStack("MATA651")
	lMt650RevDis := .T.
EndIf

dbSelectArea(cAlias)
dbSetOrder(1)
dbSeek(xFilial(cAlias)+alltrim(cProduto))
While !Eof() .And. &(cAlias+"_FILIAL") == xFilial(cAlias) .And. alltrim(&(cAlias+"_PRODUT")) == alltrim(cProduto)
	lVerifica := .T.

	If !(&(cAlias+"_SITREV") == "0")
		lVerifica := .F.
	EndIf

	If lVerifica
		cRevisao     := &(cAlias+"_REVI")
		dIniVigencia := &(cAlias+"_DTINI")
		If ( &(cAlias+"_DTINI") <= dVigencia .or. lUltima )
			Exit
		EndIf
	EndIf
	dbSkip()
EndDo

//Verifica a inexistencia de revisao disponivel
If dIniVigencia > dVigencia  .And. !lUltima
	cRevisao :=  "  "
EndIf

lQipMat :=  IIF(((lProduto .and. SB1->B1_TIPOCQ <> 'Q');                                    //No Exibe Help QA_NREVDIS quando B1_TIPOCQ<>'Q' e existe na SB1
			.or. IsInCallStack('MATA121');													//No Exibe Help QA_NREVDIS quando Pedido de Compras
			.or. (GetMV("MV_QIPMAT") == "N" .AND. IsInCallStack('MATA681'))   ), .F. , .T.) //No Exibe Help QA_NREVDIS quando MV_QIPMAT=N e Apontamento de produo

If(Empty(cRevisao) .Or. &(cAlias+"->(Eof())") .Or. !(( &(cAlias+"_FILIAL")+&(cAlias+"_PRODUT")+&(cAlias+"_REVI") ) == (xFilial(cAlias)+cProduto+cRevisao))) .and. lQipMat
	If lMsg .And. !lMt650RevDis
		lMt650RevDis := .T.
		Help(" ",1,"QA_NREVDIS",,cProduto,2,1) //O produto nao possui Revisao Disponivel
	EndIf
ElseIf IsInCallStack("QIEA090") .AND. (Empty(cRevisao) .Or. &(cAlias+"->(Eof())") .Or. !(( &(cAlias+"_FILIAL")+&(cAlias+"_PRODUT")+&(cAlias+"_REVI") ) == (xFilial(cAlias)+cProduto+cRevisao)))
//Tratamento para impedir incluso de skip-teste de produto sem especificao e sem integrao com o Quality
	Help(" ",1,"QA_NREVDIS",,cProduto,2,1) //O produto nao possui Revisao Disponivel
EndIf

RestArea(aAreaAnt)
Return(cRevisao)

Function QA_UltRvQ(cProd,dData,lmen,lUltRv); Return(QA_UltRevEsp(cProd,dData,lMen,lUltRv,"QIP"))
Function QA_UltRv(cProd,dData,lMsg,lUltRv);  Return(QA_UltRevEsp(cProd,dData,lMsg,lUltRv,"QIE"))

/*


Ŀ
Funo	 QA_NxtRevEsp  Autor Paulo Emidio de BarrosData27/05/2004 
Ĵ
Descrio  Sugere o Proximo Numero da Revisao da Especificacao do Pro- 
			  duto.													   
Ĵ
Sintaxe    QA_NxtRevEsp(cProduto,cOrigem) 							   
Ĵ
Parametros EXPC1 = Codigo do Produto								   
			  EXPC2 = Ambiente para retorno da Revisao					   
Ĵ
Retorno    EXPC3 = Sugestao para a proxima Revisao					   
Ĵ
 Uso		  Generico 												   
ٱ


*/
Function QA_NxtRevEsp(cProduto,cOrigem)
Local aAreaAnt := GetArea()
Local cRevisao := " "
Local cAlias   := " "

If cOrigem=="QIE"
	cAlias := "QE6"
ElseIf cOrigem=="QIP"
	cAlias := "QP6"
EndIf

dbSelectArea(cAlias)
dbSetorder(1)
MsSeek(xFilial(cAlias)+cProduto)
While !Eof() .And. &(cAlias+"_FILIAL") == xFilial(cAlias) .And. &(cAlias+"_PRODUT")==cProduto
	cRevisao := Soma1(&(cAlias+"_REVI"))
	MsSeek(xFilial(cAlias)+cProduto+Inverte(cRevisao))
EndDo
RestArea(aAreaAnt)
Return(cRevisao)

/*


Ŀ
Funo	 QA_NxtRevGrp  Autor Paulo Emidio de BarrosData27/05/2004 
Ĵ
Descrio  Sugere o Proximo Numero da Revisao do Grupo de Produtos     
Ĵ
Sintaxe    QA_NxtRevGrp(cGrupo)		 							       
Ĵ
Parametros EXPC1 = Grupo de Produtos								   
Ĵ
Retorno    EXPC2 = Sugestao para a proxima Revisao					   
Ĵ
 Uso		  Generico 												   
ٱ


*/
Function QA_NxtRevGrp(cGrupo)
Local aAreaAnt := GetArea()
Local cRevisao := " "

dbSelectArea("QQC")
dbSetorder(1)
MsSeek(xFilial("QQC")+cGrupo)
While !Eof() .And. QQC_FILIAL==xFilial("QQC") .And. QQC_GRUPO==cGrupo
	cRevisao := Soma1(QQC_REVI)
	MsSeek(xFilial("QQC")+cGrupo+Inverte(cRevisao))
EndDo

RestArea(aAreaAnt)
Return(IIF(Empty(cRevisao),"00",cRevisao))

/*


ͻ
Programa  QA_CHDOCTOAutor  Telso Carneiro       Data   13/05/2005 
͹
Desc.      Valida o Documento VIGENTE                                 
                                                                      
ͼ


*/

Function QA_CHDOCTO(cFilDoc,cDocto,cRev)
Local lRet	:=.F.
Local aARea	:=GetArea()

Default cFilDoc := xFilial("QDH")
Default cDocto	:= ""
Default cRev	:= ""

IF Empty(cDocto)
	Help(" ",1,"QDO50DND") // "Documento nao foi criado."
	RestArea(aArea)
	Return(lRet)
Endif

IF Empty(cRev)
	cRev := QDUltRvDoc(cDocto)	//Traz a ultima revisao
Endif

QDH->(DbSetOrder(1))
IF QDH->(DBSEEK(cFilDoc+cDocto+cRev))
	lRet:= QDH->QDH_CANCEL<>"S" .AND. QDH->QDH_OBSOL<>"S" .AND. QDH->QDH_STATUS=="L  "
Else
	Help(" ",1,"QDO50DND") // "Documento nao foi criado."
Endif

IF !lRet
	Help(" ",1,"QDNEDOCTO") // "No existe nenhum documento disponivel."
Endif

RestArea(aArea)
Return(lRet)


/*


Ŀ
Funo	 QA_EXTQLX  Autor  Telso Carneiro		 Data  13/09/05 
Ĵ
Descrio Gravar o conteudo da tabela QL do SX5 Extensoes do Linux	  
 		 indicando qual o programa para a sua abertura	  			  
ٱ


*/
Function QA_EXTQLX(cArquivo)
Local aAlias	:= GetArea()
Local cLxProg	:= ""
Local cExT		:= Subs(cArquivo,QDOCLExt(cArquivo)+1)

cLxProg := QAXDescSX5("QL",cExT,"")

RestArea(aAlias)
Return (cLxProg)

/*


ͻ
Programa  QA_TRABAR Autor  Telso Carneiro       Data   21/09/05   
͹
Desc.      Tratamento das barras para Windos X Linux  				  
          	e Linux X Windows 										  
͹
Uso        SIGAQDO,SIGAQAD,SIGAQNC                                    
ͼ


*/

Function QA_TRABAR(cParpatch)

IF ISSRVUNIX()
	IF AT("\",cParpatch) > 0  //Linux Unix
		While AT("\",cParpatch) > 0
			cParpatch := Stuff(cParpatch,AT("\",cParpatch),1,"/")
		Enddo
	Endif
Else
	IF AT("/",cParpatch) > 0  //Windows
		While AT("/",cParpatch) > 0
			cParpatch := Stuff(cParpatch,AT("/",cParpatch),1,"\")
		Enddo
	Endif
Endif

Return(cParpatch)

/*


ͻ
Programa  QA_CursTRMAutor  Telso Carneiro       Data   01/12/05   
͹
Desc.     Verificacao/Escolha dos Cursos quando integrado com SIGATRM 
                                                                      
ͼ


*/

Function QA_CURSTRM(cDocto,cRv,aCursos)
Local lRet	 	:=.F.
Local aARea		:=GetArea()
Local oDlgCur
Local oCursos
Local aMsSize	:= MsAdvSize()
Local aObjects 	:= {{ 800, 600, .T., .T., .T. }}
Local aInfo		:= { aMsSize[ 1 ], aMsSize[ 2 ], aMsSize[ 3 ], aMsSize[ 4 ], 4, 4 }
Local aPosObj	:= MsObjSize( aInfo, aObjects, .T. , .T. )

Default cDocto  := CriaVar("QDH_DOCTO")
Default cRv     := CriaVar("QDH_RV")

IF nModulo== 24 //QDO
	DbSelectArea("RAN")
	DbSetOrder(1)
	RAN->(DbGoTop())
	IF Len(aCursos)==0
		While RAN->(!EOF())
			IF RAN->RAN_DOCTO==cDocto
				AADD(aCursos,{.F.,RAN->RAN_FILIAL,RAN->RAN_CURSO,Posicione("RA1",1,RAN->RAN_FILIAL+RAN->RAN_CURSO,"RA1_DESC")})
			Endif
			RAN->(DbSkip())
		Enddo
	Endif
	IF Len(aCursos) == 0
		Help(" ",1,"QA_NCURSO",,OemtoAnsi(STR0018)+cDocto,3,0) //"No momento, no h Curso disponvel para esta empresa/filial !"  //"Associado ao Documento - "
    Endif
Else
	DbSelectArea("RA1")
	DbSetOrder(1)
	RA1->(DbGoTop())
	IF Len(aCursos)==0
		While RA1->(!EOF())
			AADD(aCursos,{.F.,RA1->RA1_FILIAL,RA1->RA1_CURSO,RA1->RA1_DESC})
			RA1->(DbSkip())
		Enddo
	Endif
	IF Len(aCursos) == 0
		Help(" ",1,"QA_NCURSO") //"No momento, no h Curso disponvel para esta empresa/filial !"
    Endif
Endif

IF Len(aCursos) > 0
	DEFINE MSDIALOG oDlgCur FROM aMsSize[7],000 To aMsSize[6],600 OF GetWndDefault() TITLE OemToAnsi(STR0019) PIXEL  //"Cursos - Integrao com SIGATRM"

	oCursos := TCBrowse():New(000,000,600,aMsSize[6],,,,oDlgCur,,,,,,,,,,,,.F.,"RA1",.T.,,.F.)
	oCursos:AddColumn(TCColumn():New(" "         		      , {|| IF(aCursos[oCursos:nAt ,1],hOK,hNo) },,,,"LEFT",10, .T., .F.,,,, .F., ))
	oCursos:AddColumn(TCColumn():New(TITSX3("RA1_FILIAL")[1], {|| aCursos[oCursos:nAt ,2]},,,,"LEFT",20,.F., .F.,,,, .F., ) )
	oCursos:AddColumn(TCColumn():New(TITSX3("RA1_CURSO") [1], {|| aCursos[oCursos:nAt ,3]},,,,"LEFT",35,.F., .F.,,,, .F., ) )
	oCursos:AddColumn(TCColumn():New(TITSX3("RA1_DESC") [1] , {|| aCursos[oCursos:nAt ,4]},,,,"LEFT",,.F., .F.,,,, .F., ) )
	oCursos:SetArray(aCursos)
	oCursos:bLDbLClick:= {|| aCursos[oCursos:nAt ,1]:=IF(aCursos[oCursos:nAt ,1],.F.,.T.),oCursos:Refresh()  }
	oCursos:Align:=CONTROL_ALIGN_ALLCLIENT
	oCursos:Refresh()

	ACTIVATE MSDIALOG oDlgCur CENTERED ON INIT EnchoiceBar(oDlgCur, ;
	{ || Aeval(aCursos,{|x| lRet:=IF(x[1],.T.,lRet)}), IF(lRet,oDlgCur:End(),Help(" ",1,"QA_NCURSO")) },;
	{ || lRet:=.F., oDlgCur:End()} )
Endif

RestArea(aARea)
Return(lRet)

/*


ͻ
Programa  QA_GNecTRMAutor  Telso Carneiro       Data   09/12/05   
͹
Desc.      Gera a Solicitacao de Treinamento no Modulo SIGATRM  	  
           										  					  
͹
Uso        SIGAQDO                                   				  
ͼ


*/

Function QA_GNECTRM(cCodUSr,cNomUsr,cModoRA3,cCodCur,cDesCur,aUsrMail,cModoRA1)
Local aArea	  := GetArea()
Local cEmpUsr := ""
Local cFilUsr := ""
Local cRA3    := "RA3"
Local lOpenRA3:= .F.
Local lRet	  := .T.
Local cRA1    := "RA1"
Local lOpenRA1:= .F.

__cFilAnt := cFilAnt
__cEmpAnt := cEmpAnt

cEmpUsr := SUBS(cCodUSr,1,2)
cFilUsr := SUBS(cCodUSr,3,2)

If cEmpAnt <> cEmpUsr
	IF !fAbrEmpresa("RA3",1,cEmpUsr,cFilUsr,@cModoRA3,"QUA")
		lRet:= .F.
	Else
		cRA3    := "QUARA3"
		lOpenRA3:= .T.
	Endif
	IF !fAbrEmpresa("RA1",1,cEmpUsr,cFilUsr,@cModoRA1,"QUA")
		lRet:= .F.
	Else
		cRA1    := "QUARA1"
		lOpenRA1:= .T.
	Endif
Endif

IF lRet
	//Ŀ
	// Gravar as Necessides de Treinamento na Solicitacao           
	//
	dbSelectArea(cRA1)
	If dbSeek(If(cModoRA1=="C",xFilial("RA1"),SUBS(cCodUSr,3,2))+cCodCur)
		//Ŀ
		// Gravar as Necessides de Treinamento na Solicitacao           
		//
		dbSelectArea(cRA3)
		If ! dbSeek(SUBS(cCodUSr,3))
			RecLock(cRA3,.T.)
			(cRA3)->RA3_FILIAL := SUBS(cCodUSr,3,2)
			(cRA3)->RA3_MAT    := SUBS(cCodUSr,5)
			(cRA3)->RA3_CURSO  := cCodCur
			(cRA3)->RA3_RESERV := "S"
			(cRA3)->RA3_DATA   := dDataBase
			MsUnlock()
			FkCommit()

			//Ŀ
			// Carrega array para envio de e-mail              
			//
			Aadd(aUsrMail, {SUBS(cCodUSr,5) +" - "+ cNomUsr, cCodCur +" - "+ cDesCur})
		Endif
	Else
		Help(" ",1,"QA_NCURSO",,cEmpUsr+" - "+cFilUsr,3) //"No momento, no h Curso disponvel para esta empresa/filial !"
		lRet:=.F.
    Endif
Endif
//Ŀ
//Finaliza Arquivos e Indices temporarios da Empresa Destino. 
//
If lOpenRA3
	fFecEmpresa( cRA3 )
EndIf
If lOpenRA1
	fFecEmpresa( cRA1 )
EndIf

cFilAnt := __cFilAnt
cEmpAnt := __cEmpAnt

RestArea(aArea)

Return( lRet )

/*


ͻ
Programa  QA_VisTRM Autor  Telso Carneiro       Data   12/12/05   
͹
Desc.     Visualizar funcionario do ambiente Treinamento SIGATRM      
                                                                      
͹
Uso        AP                                                         
ͼ


*/
Function QA_VISTRM(cCodUSr)
Local cEmpUsr := ""
Local cFilUsr := ""
Local cSRA    := "SRA"
Local lOpenSRA:= .F.
Local cModoSRA:= ""
Local cFilSx2 := SX2->(DbFilter())
Local cAlias  := "RA3"
Local nUsado  := 0
Local lRet	  := .F.
Local aArea	  := GetArea()
Local aStruCad := FWFormStruct(3,cAlias)[3]

//Ŀ
//Verifica o Usado da tabela do Treinamento, so estara liberado a partir do Release 3
//
nUsado := Len(aStruCad)

//Ŀ
//numero minimo de campos disponiveis, so estara liberado a partir do Release 3
//
IF nUsado < 10
	HELP(" ",1,"QA_NCPTRM") //"No momento, no h campos disponiveis para Consulta ! "
	Return( lRet )
Endif

dbSelectArea("SX2")
DbClearFilter()
DbSetOrder(1)

dbSeek("SRA")
cModoSRA:= FWModeAccess("SRA",1)

dbSelectArea("SX2")
Set Filter To &(cFilSx2)


__cFilAnt := cFilAnt
__cEmpAnt := cEmpAnt

cEmpUsr := SUBS(cCodUSr,1,2)
cFilUsr := SUBS(cCodUSr,3,2)

If cEmpAnt <> cEmpUsr
	//Ŀ
	//Finaliza Arquivos e Indices temporarios da Empresa Destino. 
	//
	If lOpenSRA
		fFecEmpresa( cSRA )
		lOpenSRA:=.F.
	Else
		DbSelectArea(cSRA)
		DbCloseArea()
	EndIf

	IF !fAbrEmpresa("SRA",1,cEmpUsr,cFilUsr,@cModoSRA)
		Return( lRet )
	Else
		cSRA    := "SRA"
		lOpenSRA:= .T.
	Endif
Endif

dbSelectArea(cSRA)
dbSetOrder(1)
If dbSeek(SUBS(cCodUSr,3))
	lRet:= .T.
	TRM100Rot(cSRA,(cSRA)->(Recno()),2) //Visualizar
Endif

//Ŀ
//Finaliza Arquivos e Indices temporarios da Empresa Destino. 
//
If lOpenSRA
	fFecEmpresa( cSRA )
EndIf

cFilAnt := __cFilAnt
cEmpAnt := __cEmpAnt

RestArea(aArea)

Return( lRet )


/*
Ŀ
Funo    fAbrEmpresa	   Autor Wilson de Godoy         Data 03/01/2001
Ĵ
Descrio Abre o Arquivo da Outra Empresa                        			
Ĵ
Parametros cAlias - Alias do Arquivo a Ser Aberto							
           nOrdem - Ordem do Indice              							
*/
Static Function fAbrEmpresa(cAlias,nOrdem,cEmpAte,cFilAte,cModo,cDif)
Local lRet

Default cDif := ""

IF ( lRet := MyEmpOpenFile(cDif+cAlias,cAlias,nOrdem,.t.,cEmpAte,@cModo) )
	dbSelectArea( cDif+cAlias )
Else
	MsgAlert( OemToAnsi( +STR0020+ cAlias )  )	  //"Nao foi possivel encontrar o arquivo"
EndIF

Return( lRet )

/*
Ŀ
Funo    fFecEmpresa	   Autor Wilson de Godoy         Data 03/01/2001
Ĵ
Descrio Fecha o Arquivo da Outra Empresa                        		
Ĵ
Parametros cAlias - Alias do Arquivo a Ser Fechado						
*/
Static Function fFecEmpresa( cAlias )

IF Select(cAlias) > 0
	(cAlias)->(dbCloseArea())
EndIF

Return( .T. )

/*
Ŀ
Funo    MyEmpOpenFile  Autor Wilson de Godoy         Data 03/01/2001
Ĵ
Descrio Abre Arquivo de Outra Empresa                         			
Ĵ
Parametrosx1 - Alias com o Qual o Arquivo Sera Aberto                  	
          x2 - Alias do Arquivo Para Pesquisa e Comparacao                
          x3 - Ordem do Arquivo a Ser Aberto                              
          x4 - .T. Abre e .F. Fecha                                       
          x5 - Empresa                                                    
          x6 - Modo de Acesso (Passar por Referencia)                     
*/
Static Function MyEmpOpenFile(x1,x2,x3,x4,x5,x6)
Local cSavE := cEmpAnt, cSavF := cFilAnt, xRet
cEmpAnt := __cEmpAnt
cFilAnt := __cFilAnt
xRet	:= EmpOpenFile(@x1,@x2,@x3,@x4,@x5,@x6)
cEmpAnt := cSavE
cFilAnt := cSavF

Return( xRet )



/*


ͻ
Programa  QA_VALDTRMAutor  Telso Carneiro       Data   20/12/05   
͹
Desc.      Valida a Necessidade de Treinamento no Modulo SIGATRM  	  
           										  					  
͹
Uso        MODULOS QUALITY                             				  
ͼ


*/

Function QA_VALDTRM(cFilMat,cCodUSr)
Local aArea    := GetArea()
Local aCursos  := {}
Local aNecess  := {}
Local cCargo   := ""
Local cCC      := ""
Local cChave   := ""
Local cEmpUsr  := ""
Local cFil     := ""
Local cFilSx2  := SX2->(DbFilter())
Local cFilUsr  := ""
Local cFuncao  := ""
Local chvRA5   := ""
Local cModoRA3 := ""
Local cModoRA4 := ""
Local cModoRA5 := ""
Local cModoRAL := ""
Local cModoSQ3 := ""
Local cModoSRA := ""
Local cModoSRJ := ""
Local cRA3     := "RA3"
Local cRA4     := "RA4"
Local cRA5     := "RA5"
Local cRAL     := "RAL"
Local cSQ3     := "SQ3"
Local cSRA     := "SRA"
Local cSRJ     := "SRJ"
Local lNecess  := .F.
Local lOpenRA3 := .F.
Local lOpenRA4 := .F.
Local lOpenRA5 := .F.
Local lOpenRAL := .F.
Local lOpenSQ3 := .F.
Local lOpenSRA := .F.
Local lOpenSRJ := .F.
Local lQGTRM   := GetMV("MV_QGTRM",.F.,"2")=="1" .AND. GetMv("MV_QGINT")=="S" // "Define se os modulos Quality esto integrados com Modulo SIGATRM trabalha em conjunto com MV_QGINT 1=SIM;2=NAO"
Local lRet     := .T.
Local nC       := 0
Local nTamCC   := 0

IF lQGTRM .AND. POSICIONE("QAA",1,cFilMat+cCodUSr,"QAA_TPUSR")=="1" //Funcionario

	dbSelectArea("SX2")
	DbClearFilter()
	DbSetOrder(1)

	dbSeek("SRA")
	cModoSRA:= FWModeAccess("SRA",3)

	dbSeek("SRJ")
	cModoSRJ:= FWModeAccess("SRJ",3)

	dbSeek("RA3")
	cModoRA3:= FWModeAccess("RA3",3)

	dbSeek("RA4")
	cModoRA4:= FWModeAccess("RA4",3)

	dbSeek("RA5")
	cModoRA5:= FWModeAccess("RA5",3)

	dbSeek("RAL")
	cModoRAL:= FWModeAccess("RA6",3)

	dbSeek("SQ3")
	cModoSQ3:= FWModeAccess("SQ3",3)

	dbSelectArea("SX2")
	Set Filter To &(cFilSx2)

	__cFilAnt := cFilAnt
	__cEmpAnt := cEmpAnt

	cEmpUsr := SUBS(cCodUSr,1,2)
	cFilUsr := SUBS(cCodUSr,3,2)

	If cEmpAnt <> cEmpUsr
		IF !fAbrEmpresa("SRA",1,cEmpUsr,cFilUsr,@cModoSRA,"QUA")
			lRet:= .F.
		Else
			cSRA    := "QUASRA"
			lOpenSRA:= .T.
		Endif
		IF !fAbrEmpresa("SRJ",1,cEmpUsr,cFilUsr,@cModoSRJ,"QUA")
			lRet:= .F.
		Else
			cSRJ    := "QUASRJ"
			lOpenSRJ:= .T.
		Endif

		IF !fAbrEmpresa("RA3",1,cEmpUsr,cFilUsr,@cModoRA3,"QUA")
			lRet:= .F.
		Else
			cRA3    := "QUARA3"
			lOpenRA3:= .T.
		Endif
		IF !fAbrEmpresa("RA4",1,cEmpUsr,cFilUsr,@cModoRA4,"QUA")
			lRet:= .F.
		Else
			cRA4    := "QUARA4"
			lOpenRA4:= .T.
		Endif
		IF !fAbrEmpresa("RA5",1,cEmpUsr,cFilUsr,@cModoRA5,"QUA")
			lRet:= .F.
		Else
			cRA5    := "QUARA5"
			lOpenRA5:= .T.
		Endif
		IF !fAbrEmpresa("RAL",1,cEmpUsr,cFilUsr,@cModoRAL,"QUA")
			lRet:= .F.
		Else
			cRAL    := "QUARAL"
			lOpenRAL:= .T.
		Endif

		IF !fAbrEmpresa("SQ3",1,cEmpUsr,cFilUsr,@cModoSQ3,"QUA")
			lRet:= .F.
		Else
			cSQ3    := "QUASQ3"
			lOpenSQ3:= .T.
		Endif

	Endif

	IF lRet
		dbSelectArea(cSRA)
		dbSetOrder(1)
		If dbSeek(SUBS(cCodUSr,3))
			cCC		:= (cSRA)->RA_CC
			chvRA5	:= (cRA5)+"->RA5_FILIAL+"+(cRA5)+"->RA5_CARGO+"+(cRA5)+"->RA5_CC"
			nTamCC	:= GetSX3Cache("RA_CC","X3_TAMANHO")
			If !Empty((cSRA)->RA_CARGO)
				cCargo := (cSRA)->RA_CARGO
			Else
				cCargo := FDesc(cSRJ, (cSRA)->RA_CODFUNC, "RJ_CARGO",,(cSRA)->RA_FILIAL)
			EndIf

			//Ŀ
			// Carregar os Cursos do Cargo em Array para Comparacao         
			//
			aCursos := {}
			dbSelectArea(cSQ3)
			dbSetOrder(1)
			cFil := If ( cModoSQ3 == "C", Space(FWSizeFilial()), (cSRA)->RA_FILIAL) //Space(2)
			If dbSeek(cFil+cCargo+cCC)
				cChave 	:= cCargo+cCC
			Else
				cChave	:= cCargo+Space(nTamCC)
			EndIf

			dbSelectArea(cRA5)
			dbSetOrder(2)
			cFil := If ( cModoRA5 == "C", Space(FWSizeFilial()), (cSRA)->RA_FILIAL)
			cChave 	:= cFil+cChave

			dbSeek(cChave)
			While !Eof() .And. cChave == &chvRA5

				Aadd(aCursos,{(cRA5)->RA5_CURSO,(cRA5)->RA5_HORAS,(cRA5)->RA5_VALIDA,(cRA5)->RA5_NOTA,(cRA5)->RA5_FREQUE,(cRA5)->RA5_EFICAC})
				dbSkip()
			Enddo

			cFuncao := (cSRA)->RA_CODFUNC

			//Ŀ
			// Carregar os Cursos da Funcao em Array para Comparacao        
			//
			dbSelectArea(cRAL)
			dbSetOrder(1)
			cFil := If ( cModoRAL == "C", Space(FWSizeFilial()), (cSRA)->RA_FILIAL)
			dbSeek(cFil+cFuncao)

			While ! Eof() .And. cFil+cFuncao == (cRAL)->RAL_FILIAL+(cRAL)->RAL_FUNCAO

				Aadd(aCursos,{(cRAL)->RAL_CURSO,(cRAL)->RAL_HORAS,(cRAL)->RAL_VALIDA,(cRAL)->RAL_NOTA,(cRAL)->RAL_FREQUE,(cRAL)->RAL_EFICAC})
				dbSkip()
			Enddo

			//Ŀ
			// Verificar Cursos do Cargo com Cursos do Fucnionario          
			//
			aNecess := {}
			For nC := 1 To Len(aCursos)

				lNecess	:= .T.

				dbSelectArea(cRA4)
				dbSetOrder(1)
				dbSeek((cSRA)->RA_FILIAL+(cSRA)->RA_MAT+aCursos[nC,1] )
				If ! Eof()
					While ! Eof() .And. (cSRA)->RA_FILIAL+(cSRA)->RA_MAT+aCursos[nC,1] == (cRA4)->RA4_FILIAL+(cRA4)->RA4_MAT+(cRA4)->RA4_CURSO
						If !lNecess
							dbSkip()
							Loop
						EndIf

						IF	(cRA4)->RA4_HORAS 	< aCursos[nC,2] .Or.;
							(cRA4)->RA4_NOTA 	< aCursos[nC,4] .Or.;
							(cRA4)->RA4_PRESEN	< aCursos[nC,5] .Or.;
							(cRA4)->RA4_EFICAC	< aCursos[nC,6] .Or.;
							(!Empty((cRA4)->RA4_VALIDA) .And. (cRA4)->RA4_VALIDA < dDataBase)

							lNecess := .T.
						Else
							lNecess := .F.
						Endif

						dbSelectArea(cRA4)
						dbSkip()
					Enddo
				Else
					lNecess := .T.
				Endif

				If lNecess
					Aadd(aNecess,aCursos[nC,1])
				EndIf
			Next nC
		Endif

		//Ŀ
		// Verifica se ja ha Necessides de Treinamento na Solicitacao           
		//
		For Nc := 1 To Len(aNecess)
			dbSelectArea(cRA3)
			dbSetOrder(1)
			IF !dbSeek((cSRA)->RA_FILIAL+(cSRA)->RA_MAT+aNecess[Nc])
				lRet:= .F.
			Endif
		Next nC

	Endif
	//Ŀ
	//Finaliza Arquivos e Indices temporarios da Empresa Destino. 
	//
	If lOpenSRA
		fFecEmpresa( cSRA )
	EndIf
	If lOpenSRJ
		fFecEmpresa( cSRJ )
	EndIf
	If lOpenRA3
		fFecEmpresa( cRA3 )
	EndIf
	If lOpenRA4
		fFecEmpresa( cRA4 )
	EndIf
	If lOpenRA5
		fFecEmpresa( cRA5 )
	EndIf
	If lOpenRAL
		fFecEmpresa( cRAL )
	EndIf
	If lOpenSQ3
		fFecEmpresa( cSQ3 )
	EndIf

	cFilAnt := __cFilAnt
	cEmpAnt := __cEmpAnt

	IF !lRet
		Help(" ",1,"QA_NECCUR")
	Endif
Endif

RestArea(aArea)

Return( lRet )

/*


ͻ
Programa  QA_HTOM   Autor  Cleber Souza         Data   04/08/06   
͹
Desc.      Programa de conversao de horas para minutos.	              
Ĵ
Parametros EXPC1 = Hora informados para conversao.		  		      
Ĵ
Retorno    EXPC1 = Minutos convertidos.								  
͹
Uso        MODULOS QUALITY                                            
ͼ


*/
Function QA_HTOM(cHora)

Local nMin
Local nPos

nPos := At(":",cHora)
nMin := (Val(Subs(cHora,nPos-2,2)) * 60) + Val(Subs(cHora,nPos+1,2))

Return(Alltrim(Str(nMin)))

/*


ͻ
Programa  QA_MTOH   Autor  Cleber Souza		  Data   04/08/06   
͹
Desc.      Programa de conversao de minos para horas.                 
Ĵ
Parametros EXPN1 = Minutos informados para conversao.			      
Ĵ
Retorno    EXPC1 = Hora convertida.									  
͹
Uso        MODULOS QUALITY                                            
ͼ


*/
Function QA_MTOH(nMin)

Local nInt
Local nDec

nInt := Int(nMin / 60)
nDec := Mod(nMin , 60)

Return(Str(nInt,6)+":"+StrZero(nDec,2))

/*


ͻ
Programa  QXMSLOGIX Autor  Denis Martins        Data   07/14/09   
͹
Desc.     Apresenta as inconsistencias dos Webservices da integracao  
          Quality - Logix                                             
͹
Uso        AP                                                         
ͼ


*/
Function QXMSLOGIX()
Local oListx
Local cQuery
Local aArea := GetArea()
Local cIndex
Local cChave	:= ""
Local cStaQ1	:= "0"
Local cStaQ2	:= "1"
Local oDlg

Private aIncons := {}

//Monta a query para registros inconsistentes do Logix...

cQuery := "SELECT QNB_DATA, QNB_PROCED, QNB_DESCRI FROM "+RetSqlName("QNB")
cQuery += " WHERE QNB_FILIAL = '"+xFilial("QNB")+"' AND "
cQuery += " QNB_STATUS BETWEEN '"+ cStaQ1 +"' AND '"+ cStaQ2 +"' AND "
cQuery += " D_E_L_E_T_ = ' '"
cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"QNBLGX")

While QNBLGX->(!EOF())
	If dDatabase <= (STOD(QNBLGX->QNB_DATA) + 10)
		AADD(aIncons,{QNBLGX->QNB_PROCED,STOD(QNBLGX->QNB_DATA),QNBLGX->QNB_DESCRI})
	Endif
	dbSkip()
Enddo

QNBLGX->(DbCloseArea())

If Len(aIncons) > 0 //Existe inconsistencias...
	DEFINE MSDIALOG oDlg TITLE STR0022 FROM 000,000 TO 385,625 OF oMainWnd PIXEL //"Aviso de Inconsistencias"
	@ 030,003 LISTBOX oListx FIELDS HEADER Alltrim(STR0023),; //"Procedimento"
	                                  		Alltrim(STR0024),;//Data
	                                   		Alltrim(STR0025) SIZE 308,140 PIXEL //"Descricao"

	oListx:SetArray(aIncons)
	oListx:bLine := { || { aIncons[oListx:nAt,1],aIncons[oListx:nAt,2],aIncons[oListx:nAt,3]}}
	oListx:GoTop()
	oListx:Refresh()

	DEFINE SBUTTON FROM 177,250 TYPE 2 ENABLE OF oDlg ACTION oDlg:end()

	ACTIVATE MSDIALOG oDlg CENTERED
Endif
Return Nil


/*/{Protheus.doc} QAXDescSX5
//TODO Carrega Descrio da SX5
@author brunno.costa
@since 06/04/2018
@version 6
@return cReturn, characters, correspondente o X5_DESCRI
@param 	cTabela, characters, correspondente o X5_TABELA
		cChave, characters, correspondente o X5_CHAVE
		cMsgPadrao, characters, descrio padro
@type function
/*/
Function QAXDescSX5(cTabela,cChave,cMsgPadrao)
Local aSX5QHx := FWGetSX5(cTabela,cChave)
Local nPX5Descr	:= 4
DEFAULT cMsgPadrao := ""
Return Iif(Len(aSX5QHx)>0,aSX5QHx[1][nPX5Descr],cMsgPadrao)

//----------------------------------------------------------------------
/*/{Protheus.doc} QAGetX3Tit 
Busca ttulo SX3 com GetSx3Cache por idioma
@author Brunno de Medeiros da Costa
@since 13/04/2018
@version 1.0
@return cTitulo
/*/
//---------------------------------------------------------------------- 
Function QAGetX3Tit(cCampo)
	Local cTitulo	 := ""
	Static oTitulos  := Nil
	oTitulos := Iif(oTitulos == Nil, JsonObject():New(), oTitulos) 
	If oTitulos[cCampo] == NIL
		oTitulos[cCampo] := FWX3Titulo( cCampo )
	EndIf
	cTitulo := oTitulos[cCampo]
Return cTitulo

//----------------------------------------------------------------------
/*/{Protheus.doc} QAGetX3Cmb 
Busca combo SX3 com GetSx3Cache por idioma
@author Brunno de Medeiros da Costa
@since 13/04/2018
@version 1.0
@return cCombo
/*/
//---------------------------------------------------------------------- 
Function QAGetX3Cmb(cCampo)
Local cCombo	 := ""
Local nX         := 0
Local aCombo     := {}
Local cComboTemp := ""
Local cOpc       := ""

IF !EMPTY(GetSx3Cache(cCampo, "X3_CBOX"))
	cCombo := GetSx3Cache(cCampo, "X3_CBOX")

	aCombo := STRTOKARR2( cCombo, ";",  )

	FOR nX := 1 TO LEN(aCombo)
		IF !EMPTY(aCombo[nX])
			IF nX > 1
				cComboTemp += ";"
			ENDIF

			cOpc := SUBSTR(aCombo[nX], 1, At(  "=", aCombo[nX], 1 ) - 1)
			
			cComboTemp += cOpc + "=" + X3CboxDesc(cCampo, cOpc)
		ENDIF
	NEXT nX

	cCombo := cComboTemp
ENDIF

Return cCombo

/*/


Ŀ
Funcao	 QAXFilSXB Autor  Sergio S. Fuzinaka     Data  03.03.09 
Ĵ
Descricao Filtra Instrumento com Calibracao nas Consultas INS e INE   
Ĵ
Uso		 QIEA215() 												  
ٱ


Movida do fonte QIEA215
/*/
Function Q215FilSXB()
Local lRet := .F.
Local cQuery := ""
local aArea := GetArea()
Local cAlias := GetNextAlias()

cQuery := "SELECT Count(1) COUNT" 
cQuery += "FROM " + RetSqlName("QM6")
cQuery += "WHERE QM6_FILIAL = '" + xFilial("QM6") + "' "
cQuery += "AND QM6_INSTR = '" + QM2->QM2_INSTR + "' "
cQuery += "AND QM6_REVINS = '" + QM2->QM2_REVINS + "'"
cQuery += "AND D_E_L_E_T_ = ' ' "
    
cQuery := ChangeQuery(cQuery)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)

iF (cAlias)->COUNT > 0
	lRet := .T.
EndIf

(cAlias)->(DBCloseArea())
RestArea(aArea)

Return( lRet )      


/*/


Ŀ
Funcao	 QAXFilSX2 Autor  Sergio S. Fuzinaka     Data  03.03.09  
Ĵ
Descricao Filtra Instrumento com Calibracao na Consulta ICAL          
Ĵ
Uso		 QIEA215() 												  
ٱ


Movida do fonte QIEA215
/*/
Function Q215FilSX2()
Local nOrd := QM2->(IndexOrd())
Local lRet := .F.

QM2->(dbSetOrder(1))
lRet := ( QM2->(dbSeek(xFilial("QM2")+QM6->QM6_INSTR+QM6->QM6_REVINV))) .And. QM2->QM2_STATUS <> "0"
QM2->(dbSetOrder(nOrd))

Return( lRet ) 
