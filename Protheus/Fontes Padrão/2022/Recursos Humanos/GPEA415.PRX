#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEA415.CH"
#INCLUDE "PONCALEN.CH"
#INCLUDE "HEADERGD.CH"

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³gpea415   ³Autor³Guadalupe Santacruz                  ³ Data ³08/07/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Amortizaciones   									     	            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                                ³
ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³            ACTUALIZACIONES DESDE LA CONTRUCCION INICIAL                           ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Programador ³Data      ³   BOPS/FNC     ³Motivo da Alteracao                       ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Mauricio T. ³11/09/2006³----------------³Permitir Nro de Parcelas pagas seja       ³
³            ³          ³                ³maior que Nro de Parcelas a Pagar         ³
³Luiz Gustavo|05/01/2007³Melhoria        ³Inclusao da funcao MenuDef() para         ³
³      	     ³----------³----------------³versao 9.12.                              ³
³Valdeci Lira³30/01/2008³140682          ³Alteracao na forma de chamada da funcao   ³
³            ³          ³                ³ffiltro e filtragem apenas da SRA e SRK   ³
³            ³          ³                ³e SRV ja que a somente estes campos sao   ³
³            ³          ³                ³exibidos em tela                          ³
³Abel        ³12/03/2009³06352           |Testar Paisloc, para inibir campo desati  |
³            ³          ³                ³localização Colombia                      ³
³Rogerio R.  ³21/05/2009³00000012812/2009³Removido da tela os campos "RCK_PDJURO",  ³
³            ³          ³                ³"RK_PDJUROS" e "RK_VLJUROS" para Argentina³
|Valdeci Lira|24/08/2009|00000021149/2009|Criado 3 pontos de entrada que poderao    |
³            ³          ³                ³ser executados no LinOk do RCK, linOk do  ³
³            ³          ³                ³SRK e no tudoOk, no fechamaento da tela   ³
|Marcelo     |28/09/2009|00000022944/2009|Validacao no campo RCK_PD p/aceitar verbas|
³            ³          ³                ³de acordo com o lancamento da tabela SRK. ³
³            ³          ³                ³Correcao na avaliacao dos campos para     ³
³            ³          ³                ³montagem do aHeader RCK.                  ³
³            ³          ³                ³Criacao da funcao AjustaSX3 para realizar ³
³            ³          ³                ³ajustes nos campos: RCK_PD, RCK_DESCPD e  ³
³            ³          ³                ³RCK_REFERE.                               ³
³            ³          ³                ³Ajuste na gpea415Mnt() para exibir a      ³
³            ³          ³                ³descricao das verbas na GetDados da RCK.  ³
³Marcelo     ³26/10/2009³00000026155/2009³Ajuste para nao adicionar zeros a esquerda³
³            ³          ³                ³no campo matricula.                       ³
³Allyson M.  ³18/11/2009³00000028024/2009³Criado PE GP415GRV para executar processos³
³            ³          ³                ³apos gravar dados da amortizacao.         ³
³Christiane  ³15/01/2010³00000000333/2010³Inclusao tratamento de Item Contábil e    ³
³            ³          ³                ³Classe de Valor                           ³
³Alceu P.    ³15/10/2010³00000023767/2010³Inclusao aviso ao usuario referente ao 	³
³            ³          ³                ³valor pago do saldo devedor. Ajuste do    ³
³			 ³			³				 ³saldo devedor de acordo com o valor pago. ³
³Raquel Hager³04/06/2012³00000011093/2012³Ajuste nas funcoes Gp415RCKLinOk e devido ³
³            ³          ³          TEXMZY³Gpea415Grava devido a nao utilizacao do   ³
³            ³          ³                ³campo RK_DTVENC para para Cos/Dom.        ³
³Raquel Hager³02/07/2012³00000011093/2012³Correcao na funcao Gpea415Grava para corre³
³            ³          ³          TEXMZY³ta gravacao na RCK quando SRK for alterada³
³            ³          ³                ³DOM/COS Tratamento para remocao dos campos³
³            ³          ³                ³RCK_PXVCTO e RCK_PDJURO do aHeader.       ³
³GSantacruz  ³26/11/2016³pcreq-7944      ³Para Chile no debe visualizar el campo    ³
³            ³          ³                ³RCK_CALCUL.                               ³
³Allyson M.  ³14/01/2016³          TUFKWX³-Ajuste p/ permitir a alteracao do campo  ³
³            ³          ³                ³RCK_PARCPG devido ao processo de estorno  ³
³            ³          ³                ³de lancamento.                            ³
³            ³          ³                ³-Ajuste na atualizacao da SRK p/ quando o ³
³            ³          ³                ³lancamento ser de estorno p/ subtrair o   ³
³            ³          ³                ³valor pago  								³
³Cícero Alves³19/07/2016³          TVJTAS³Ajuste na função Gpea415Grava para alterar³
³            ³          ³                ³corretamente o registro na SRK			³
³Marcos Cout.³22/12/2016³         MRH-237³Ajustes para possibilitar a exclusão de   ³
³            ³          ³                ³valores futuros lançados incorretamente   ³
³Jaqueline L.³05/01/2017³ DRHPAG-11185   ³Ajuste para quando não estiver preenchido ³
³            ³          ³                ³a coluna valor pago, preencha com 0 para  ³
³            ³          ³                ³não gerar errorlog.                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GPEA415( cAlias , nReg , nOpc )

Local aIndexSRA		:= {}

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Si Empleados   No esta vacio            								 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	/*/
   	IF  !ChkVazio("SRA")   //en GPEXFUN1.PRX
		Break
	EndIF

	Private aRotina := MenuDef() // ajuste para versao 9.12 - chamada da funcao MenuDef() que contem aRotina

	Private bFiltraBrw	:= { || NIL }
	Private cCadastro   := OemToAnsi( STR0005 )
	Private aArray		:= {}

	Private lItemClVl   := SuperGetMv( "MV_ITMCLVL", .F., "2" ) $ "13" // Define se trabalha com item e classe contabil

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Inicializa o filtro utilizando a funcao FilBrowse                      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	*/
	aArray := {"SRA", "RCK" , "SRK" }
	ffiltro("GPEA415",aArray, 2) //Cria todas as variaveis para filtro
	//Executa Apenas o Primeiro Filtro
	ffiltro("GPEA415",aArray, 1 /* Exec Filtro*/, 1 /*Inicio*/, 1/*Fim*/)

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Chama a Funcao de Montagem do Browse                                   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	*/
	mBrowse( 6 , 1 , 22 , 75 , "SRA"  , NIL , NIL , NIL , NIL , NIL , fCriaCor() )

   	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Deleta o filtro utilizando a funcao FilBrowse                     	 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	fFiltro("GPEA415", aArray, 0)//-> Deleta todos os filtros

End Sequence

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gpea415Mnt³ Autor ³Gpe Santacruz          ³ Data ³08/07/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³gpea415Mnt( cAlias , nReg , nOpc )							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cAlias = Alias do arquivo                                   ³
³          ³nReg   = Numero do registro                                 ³
³          ³nOpc   = Numero da opcao selecionada                        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³gpea415()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
/*/
Function gpea415Mnt( cAlias , nReg , nOpc )

Local aArea			:= GetArea()
Local aSvKeys		:= GetKeys()
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aSRKVirtGd	:= {}
Local aSRKVisuGd	:= {}
Local aSRKNotFields	:= {}
Local aSRKRecnos	:= {}
Local aSRKQuery		:= {}
Local aRCKNotFields	:= {}
Local aRCKQuery		:= {}
Local aSRKCols		:= {}
Local aVirtualRC	:= {}
Local aVisualRC		:= {}
Local aRecnosRC		:= {}
Local aLstRCaColsAll:= {}
Local aNaoAltRC     := {}

Local aAlteraRC		:= {}
Local aSRKGdNaoAlt	:= {}
Local aSRKGdAltera  := {}
Local aOfusca		:= If(FindFunction('ChkOfusca'), ChkOfusca(), {.T. , .F.}) //[1] Acesso; [2]Ofusca
Local aFldRot 		:= {'RA_NOME'}
Local aFldOfusca 	:= {}

Local bSet15		:= { || NIL }
Local bSet24		:= { || NIL }
Local bSRKTudOk		:= {}
Local bSRKLinOk		:= {}
Local bRCKTudOk		:= {}
Local bSRKLinDelOk	:= {}
Local bRCKLinOk		:= {}
Local cSRAKeySeek	:= ""
Local lSRKLock		:= .F.
Local lOfuscaNom	:= .F.
Local oDlg			:= NIL
Local oFont
Local oGroup
Local nSRKUsado		:= 0
Local nUsadoRC		:= 0
Local nLoop			:= 0
Local nPosPd		:= 0
Local nPosDesc		:= 0
Local nOpcAlt		:= 0
Local nOpcSRK		:= IF( ( ( nOpc == 2 ) .or. ( nOpc ==5 ) ) , 0 , GD_UPDATE + GD_DELETE )  //ESTA OPCION DEJAMODIFICAR Y DEBE ESTAR EN 2 O EN 3 SEGUN ORDEN
Local nOpcRCK		:= IF( ( ( nOpc == 2 )) , 0 , GD_INSERT + GD_UPDATE + GD_DELETE )  //ESTA OPCION DEJAMODIFICAR Y DEBE ESTAR EN 2 O EN 3 SEGUN ORDEN
Local bSkip         := {|| SRK->RK_VLRPAGO == 0 .And. SRK->RK_PARCPAG == 0 }

Private aColsRCAll		:= {}
Private aHeaderRCAll	:= {}
Private aRCKHeader		:= {}
Private aSvRCKCols		:= {}
Private aSRKHeader		:= {}
Private aSvSRKCols		:= {}
Private aColsAtivos		:= {}
Private __nSRKAtAnt		:= 0
Private cFilSRA			:= ""
Private cMatSRA			:= ""
Private oGetSuper		:= NIL
Private oGetInfer		:= NIL

Private nOpcX			:= nOpc
Private lPeRckLinOk		:= ExistBlock("G415RCKLOK")
Private lPeSrkLinOk		:= ExistBlock("G415SRKLOK")
Private lPeGp415TudOk	:= ExistBlock("G415TUDOK")

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta los Datos para el Enchoice							   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cFilSRA		:= xfilial("SRA")
	cMatSRA		:= SRA->RA_MAT
	cSRAKeySeek	:= ( cFilSRA + 	cMatSRA )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Bloqueia Chaves Logicas de Prestamos                          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( lSRKLock := gpea415Locks( nOpc , "SRK", NIL, { cFilSRA + cMatSRA } ) )
		Break
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define los Campos que no seran cargados en el grid		   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aAdd( aSRKNotFields , "RK_FILIAL")
	aAdd( aSRKNotFields , "RK_MAT"	 )

	If (cPaisLoc $ "ARG")
		aAdd( aSRKNotFields , "RK_PDJUROS")
		aAdd( aSRKNotFields , "RK_VLJUROS")
	EndIf

	If !lItemClVl
		AAdd(aSRKNotFields, "RK_ITEM")
		AAdd(aSRKNotFields, "RK_CLVL")
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta os Dados para a GetDados							   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aSRKQuery		:= Array( 05 )
	aSRKQuery[01]	:= "RK_FILIAL='"+cFilSRA+"'"
	aSRKQuery[02]	:= " AND "
	aSRKQuery[03]	:= "RK_MAT='"+cMatSRA+"'"
	aSRKQuery[04]	:= " AND "
	aSRKQuery[05]	:= "D_E_L_E_T_=' ' "

	SRK->( dbSetOrder( RetOrdem( "SRK" , "RK_FILIAL+RK_MAT" ) ) )
	ffiltro("GPEA415",aArray, 1 /* Exec Filtro*/, 2 /*Inicio*/, 3/*Fim*/, .T.)
	aSRKCols	:= SRK->(GdMontaCols(	@aSRKHeader		,;
										@nSRKUsado		,;
										@aSRKVirtGd		,;
										@aSRKVisuGd		,;
										"SRK"			,;
										aSRKNotFields	,;
										@aSRKRecnos		,;
										"SRA"			,;
										cSRAKeySeek		,;
										NIL				,;
										bSkip			,;
										NIL				,;
										NIL				,;
										NIL				,;
										NIL				,;
										NIL				,;
										NIL				,;
										aSRKQuery		,;
										.F.				,;
										.F.				,;
										.T.				))

    If Len(aSRKRecnos) = 0
		MsgInfo(  OemToAnsi( STR0009 ) , cCadastro ) // Nao existem lancamento para esse funcionario
		Break
    EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega a Descricao das Verbas         					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	nPosPd		:= GdFieldPos( "RK_PD"		, aSRKHeader )
	nPosDesc	:= GdFieldPos( "RK_DESCPD"	, aSRKHeader )
	For nLoop := 1 to len(aSRKCols)
		aSRKCols[nLoop,nPosDesc] := fDesc( "SRV" , aSRKCols[ nLoop , nPosPd ] , "RV_DESC" )
	Next nLoop

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Efetuo Copia para Comparacao na Saida						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aSvSRKCols	:= aClone( aSRKCols )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define los Campos que no se alteraran solo se visualizaran   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
/*  aAdd( aSRKGdNaoAlt , "RK_NUMID"		)
	aAdd( aSRKGdNaoAlt , "RK_PD"		)
	aAdd( aSRKGdNaoAlt , "RK_DESCPD"	)
	aAdd( aSRKGdNaoAlt , "RK_VALORTO"	)
	aAdd( aSRKGdNaoAlt , "RK_PARCELA"	)
	aAdd( aSRKGdNaoAlt , "RK_JUROANO"	)
	aAdd( aSRKGdNaoAlt , "RK_JUROMES"	)
	aAdd( aSRKGdNaoAlt , "RK_VALORPA"	)
	aAdd( aSRKGdNaoAlt , "RK_PARCPAG"	)
	aAdd( aSRKGdNaoAlt , "RK_VLRPAGO"	)
	aAdd( aSRKGdNaoAlt , "RK_VALORAR"	)
	aAdd( aSRKGdNaoAlt , "RK_DTVENC" 	)
	aAdd( aSRKGdNaoAlt , "RK_DTMOVI"	)
	aAdd( aSRKGdNaoAlt , "RK_DOCUMEN"	)
	aAdd( aSRKGdNaoAlt , "RK_CC"		)
	aAdd( aSRKGdNaoAlt , "RK_PERINI"	)
	aAdd( aSRKGdNaoAlt , "RK_NUMPAGO"	)
    aAdd( aSRKGdNaoAlt , "RK_VLSALDO"	)
	aAdd( aSRKGdNaoAlt , "RK_QTDE"		)
	aAdd( aSRKGdNaoAlt , "RK_QTDEDES"	)
	aAdd( aSRKGdNaoAlt , "RK_QTDESDO"	)
*/
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carga los Campos Editables para a GetDados				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	/*For nLoop := 1	To nSRKUsado
		IF (;
			 ( aScan( aSRKVirtGd,		PADR(aSRKHeader[nLoop, 2], 10) ) == 0 ) .and.	;
		   	 ( aScan( aSRKVisuGd,		PADR(aSRKHeader[nLoop, 2], 10) ) == 0 ) .and.	;
		   	 ( aScan( aSRKNotFields,	PADR(aSRKHeader[nLoop, 2], 10) ) == 0 ) .and.	;
		   	 ( aScan( aSRKGdNaoAlt,		PADR(aSRKHeader[nLoop, 2], 10) ) == 0 )		;
		   	)
			aAdd( aSRKGdAltera , aSRKHeader[ nLoop , 02 ] )
		EndIF
	Next nLoop */

	aAdd( aSRKGdAltera , "RK_STATUS" )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define os Campos que nao serao carregados					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aAdd( aRCKNotFields , "RCK_FILIAL"	)
	aAdd( aRCKNotFields , "RCK_MAT"	 	)
	aAdd( aRCKNotFields , "RCK_POSTO"	)
	aAdd( aRCKNotFields , "RCK_NUMID"	)

	If (cPaisLoc $ "ARG*COS*DOM")
		aAdd( aRCKNotFields , "RCK_PDJURO")
	EndIf

	If (cPaisLoc $ "MEX")
		aAdd( aRCKNotFields , "RCK_REFERE"	)
	EndIf

	If cPaisLoc $ "COS*DOM"
		aAdd( aRCKNotFields , "RCK_PXVCTO"	)
	EndIf
	If cPaisLoc $ "CHI"
		aAdd( aRCKNotFields , "RCK_CALCUL"	)
	EndIf
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta Query para a Selecao das Informacoes em GdMontaCols    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aRCKQuery	:= Array( 05 )
	aRCKQuery[01] := "RCK_FILIAL='"+cFilSRA+"'"
	aRCKQuery[02] := " AND "
	aRCKQuery[03] := "RCK_MAT='"+cMatSRA+"'"
	aRCKQuery[04] := " AND "
	aRCKQuery[05] := "D_E_L_E_T_=' ' "

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Seleciona a Ordem para a Obtencao dos Dados                  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	RCK->( dbSetOrder( RetOrdem( "RCK" , "RCK_FILIAL+RCK_MAT+RCK_NUMID+STR(RCK_SEQUEN)" ) ) )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega todas as Informacoes do RCK para o funcaionario	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	ffiltro("GPEA415",aArray, 1 /* Exec Filtro*/, 2 /*Inicio*/, 3/*Fim*/, .T.)
	aColsRCAll := RCK->(GdMontaCols(@aHeaderRCAll	,;	//01 -> Array com os Campos do Cabecalho da GetDados
				  				     @nUsadoRC  	,;	//02 -> Numero de Campos em Uso
				  					 @aVirtualRC	,;	//03 -> [@]Array com os Campos Virtuais
				  					 @aVisualRC		,;	//04 -> [@]Array com os Campos Visuais
				  					 "RCK"		    ,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
			  						 Nil  			,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
			  						 @aRecnosRC		,;	//07 -> [@]Array unidimensional contendo os Recnos
			  						 "SRA"			,;	//08 -> Alias do Arquivo Pai
			  						 cSRAKeySeek	,;	//09 -> Chave para o Posicionamento no Alias Filho
				  					 NIL			,;	//10 -> Bloco para condicao de Loop While
				  					 NIL			,;	//11 -> Bloco para Skip no Loop While
				  					 NIL			,;	//12 -> Se Havera o Elemento de Delecao no aCols
				  					 NIL			,;	//13 -> Se cria variaveis Publicas
				  					 NIL			,;	//14 -> Se Sera considerado o Inicializador Padrao
				  					 NIL			,;	//15 -> Lado para o inicializador padrao
			  						 .T.			,;	//16 -> Opcional, Carregar Todos os Campos
				  					 NIL 			,;	//17 -> Opcional, Nao Carregar os Campos Virtuais
									 aRCKQuery		,;	//18 -> Opcional, Utilizacao de Query para Selecao de Dados
									 .F.			,;	//19 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP )
									 .F.			,;	//20 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP )
									 .T.		 	,;	//21 -> Carregar Coluna Fantasma
									 NIL			,;	//22 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
	 								 NIL			,;	//23 -> Verifica se Deve Checar se o campo eh usado
									 NIL			,;	//24 -> Verifica se Deve Checar o nivel do usuario
									 NIL			,;	//25 -> Verifica se Deve Carregar o Elemento Vazio no aCols
									 NIL			,;	//26 -> [@]Array que contera as chaves conforme recnos
									 NIL			,;	//27 -> [@]Se devera efetuar o Lock dos Registros
									 NIL			,;	//28 -> [@]Se devera obter a Exclusividade nas chaves dos registros
									 NIL			,;	//29 -> Numero maximo de Locks a ser efetuado
									 .T.			 ;	//30 -> Utiliza Numeracao na GhostCol
							)  )

	// O inicializador padrao da GHOSTCOL e retirado para verificar quais linhas
	// foram incluidas e quais ja foram gravadas. Registros ja gravados nao poderam
	// ser alterados.
	aHeaderRCAll[ GdFieldPos( "GHOSTCOL" , aHeaderRCAll ) , __AHEADER_INITPAD__ ] := ""
	//Altera o campo RCK_PARCPG para alteravel
	aHeaderRCAll[ GdFieldPos( "RCK_PARCPG", aHeaderRCAll ) , __AHEADER_VISUAL__ ] := "A"

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega a Descricao das Verbas na GetDados RCK               ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	nPosPdRC	:= GdFieldPos( "RCK_PD"		, aHeaderRCAll )
	nPosDescRC	:= GdFieldPos( "RCK_DESCPD"	, aHeaderRCAll )

	For nLoop := 1 to Len(aColsRCAll)
		aColsRCAll[nLoop,nPosDescRC] := fDesc( "SRV" , aColsRCAll[ nLoop , nPosPdRC ] , "RV_DESC" )
	Next nLoop

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define los Campos que no se alteraran solo se visualizaran   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aAdd( aNaoAltRC , "RCK_FILIAL"	)
	aAdd( aNaoAltRC , "RCK_MAT"		)
	aAdd( aNaoAltRC , "RCK_NUMID"	)
	aAdd( aNaoAltRC , "RCK_DESROT"	)
	aAdd( aNaoAltRC , "RCK_PER"		)
	aAdd( aNaoAltRC , "RCK_NUMPAGO"	)
	aAdd( aNaoAltRC , "RCK_CALCULO"	)
	aAdd( aNaoAltRC , "RCK_SEQUEN"	)


	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Montar o aHeader para Uso e Definir os Campos Editaveis 	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	For nLoop := 1 To nUsadoRC
		IF (;
				( aScan( aVirtualRC, 	{|x| PADR(x, 10) == PADR( aHeaderRCAll[nLoop, 2], 10)} ) ) == 0 .and. ;
		   		( aScan( aVisualRC, 	{|x| PADR(x, 10) == PADR( aHeaderRCAll[nLoop, 2], 10)} ) ) == 0 .and. ;
				( aScan( aNaoAltRC, 	{|x| PADR(x, 10) == PADR( aHeaderRCAll[nLoop, 2], 10)} ) )	 == 0 ;
		  	)
			aAdd( aAlteraRC , aHeaderRCAll[ nLoop , 02 ] )
		EndIF

		IF ( aScan(aRCKNotFields , {|x| PADR(x, 10) == PADR(aHeaderRCAll[nLoop, 2], 10)} ) ) == 0
	       	aAdd( aRCKHeader ,	 aClone(aHeaderRCAll[nLoop] ) )
		EndIF
	Next nLoop

	If aScan( aAlteraRC, { |x| x == "RCK_PARCPG" } ) == 0
		aAdd( aAlteraRC , "RCK_PARCPG" )
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Salva Conteudo Inicial dos aColsAll para comparacao antes  da³
	³ Gravacao													   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aLstRCaColsAll := aClone( aColsRCAll )

	aAdvSize		:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
	aAdd( aObjCoords , { 015 , 020 , .T. , .F. } )
	aAdd( aObjCoords , { 000 , 100 , .T. , .F. } )
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para validacao da GetDados SRK (oGetSuper)   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bSRKTudOk := {|| oGetSuper:TudoOk() }

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para validacao da GetDados RCK (oGetInfer)   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bRCKTudOk := { || oGetInfer:TudoOk() }

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para a Tecla <CTRL-O>						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bSet15		:= { || IF(;
								Eval( bSRKTudOk );					//Valida as Informacoes da GetDados
								.and.;
								Eval( bRCKTudOk );					//Valida as Informacoes da GetDados
								.and.;
								iIf(lPeGp415TudOk, ExecBlock( "G415TUDOK",.F.,.F.), .T.),; //Se tiver o ponto de entrada TudoOk, executa
								(;
									Eval( oGetSuper:bChange , .T. ),;	//Transere as informacoes Atuais para o aRCKCols
									aSRKCols := oGetSuper:aCols,;		//Redireciona o Ponteiro do aSRKCols
									nOpcAlt := 1 ,;
									RestKeys( aSvKeys , .T. ),;
									oDlg:End();
							 	),;
							 	(;
							 		nOpcAlt := 0 ,;
							 		.F.;
							 	);
						   );
					 }

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para a Tecla <CTRL-X>     	   				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bSet24		:= { || ( nOpcAlt := 0 , RestKeys( aSvKeys , .T. ) , oDlg:End() ) }

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta o Dialogo Principal para a Manutencao das Marcacoes    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi( STR0005 ) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL

	//Protecao de Dados Sensiveis
	If aOfusca[2]
		aFldOfusca := FwProtectedDataUtil():UsrNoAccessFieldsInList( aFldRot) // CAMPOS SEM ACESSO
		IF aScan( aFldOfusca , { |x| x:CFIELD == "RA_NOME" } ) > 0 
			lOfuscaNom	:= FwProtectedDataUtil():IsFieldInList( "RA_NOME" )
		ENDIF
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Sustituye al Enchoice para o SRA                      	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	@ aObjSize[1,1] , aObjSize[1,2] GROUP oGroup TO ( aObjSize[1,3] ),( ( aObjSize[1,4]*0.18 ) ) LABEL OemToAnsi(STR0007) OF oDlg PIXEL				// "Matricula:"
	oGroup:oFont:= oFont
	@ aObjSize[1,1] , ( ( aObjSize[1,4]*0.185 ) ) GROUP oGroup TO ( aObjSize[1,3] ),( aObjSize[1,4] * 0.87 ) LABEL OemToAnsi(STR0008) OF oDlg PIXEL	// "Nome:"
	oGroup:oFont:= oFont
	@ aObjSize[1,1]+10 , aObjSize[1,2]* 2.5				SAY OemToAnsi(SRA->RA_MAT)		SIZE 050,10 OF oDlg PIXEL FONT oFont
	@ aObjSize[1,1]+10 , aObjSize[1,4]* 0.2	SAY If(lOfuscaNom,Replicate('*',15),OemToAnsi(SRA->RA_NOME)) 	SIZE 146,10 OF oDlg PIXEL FONT oFont

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para validacao da GetDados SRK (oGetSuper)   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bSRKTudOk := {|| Gp415SRKTudOk()}

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para validacao de linha da GetDados SRK (oGetSuper)   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bSRKLinOk := {|| Gp415SRKLinOk()}

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para validacao de linha da excluida GetDados SRK (oGetSuper)   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bSRKLinDelOk := {|| Gp415SRKDelOk()}

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para validacao da GetDados RCK (oGetInfer)   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bRCKTudOk := { || Gp415RCKTudOk( ) }

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para validacao de linha da GetDados RCK (oGetInfer)   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bRCKLinOk := { || Gp415RCKLinOk( ) }

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta o Objeto GetDados para o SRK						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	oGetSuper	:= MsNewGetDados():New(	aObjSize[2,1]	,; // Linha Inicial
										aObjSize[2,2]	,; // Coluna Inicial
										aObjSize[2,3]	,; // Linha Final
										aObjSize[2,4]	,; // Coluna Final
										nOpcSRK			,;
									 	bSRKLinOk		,;	// funcao para validar a edicao da linha - ulinhaOK
								 		bSRKTudOk		,;	// funcao para validar todas os registros da GetDados - uTudoOK
										""				,;
										aSRKGdAltera	,;
										0				,;
										NIL				,;
										NIL				,;
										NIL				,;
										bSRKLinDelOk	,; // funcao para validar a deleção da linha - ulinhaDelOk
										oDlg			,;
										aSRKHeader		,;
										aSRKCols 		 )

	oGetSuper:oBrowse:bGotFocus := { || SRKGotFocus() }
	oGetSuper:bChange := { |lColsToAll| Gpea415AllTrf( nOpc, oGetSuper , @oGetInfer , lColsToAll) }

	oGetInfer   := MsNewGetDados():New(	aObjSize[3,1]			,;
										aObjSize[3,2]			,;
										aObjSize[3,3]			,;
										aObjSize[3,4]			,;
										nOpcRCK					,;
									 	bRCKLinOk				,;	// funcao para validar a edicao da linha - ulinhaOK
										bRCKTudOk				,;
										"+RCK_PARCPG"			,;
										aAlteraRC				,;
										0						,;
										99999					,;
										NIL						,;
										NIL						,;
										NIL						,;
										oDlg					,;
										aRCKHeader				,;
										GdRmkaCols( aRCKHeader ) ;
										)

	oGetInfer:bDelOk:= {|| gp415ChkDel()}

	ACTIVATE MSDIALOG oDlg ON INIT	EnchoiceBar( oDlg , bSet15 , bSet24 , NIL , NIL )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Quando Confirmada a Opcao e Nao for Visualizacao Grava ou   Ex³
	³clui as Informacoes do CTT e RCL							   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF( nOpcAlt == 1 )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Apenas se nao For Visualizacao              				   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
 		IF ( nOpc != 2 )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Gravando/Incluido ou Excluindo Informacoes do SRY/RCL        ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			MsAguarde({ ||;
						Gpea415Grava(nOpc			,;	//Opcao de Acordo com aRotina
									 aRecnosRC  	,;
									 aLstRCaColsAll ,;
									 aVirtualRC		 ;
									);
						},cCadastro)
	   EndIF
	EndIF

End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Libera Locks						                           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If lSRKLock
	FreeLocks( "SRK" , NIL , .T. )
	FreeLocks( "SRA" , NIL , .T. )
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Restaura as Teclas de Atalho								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
RestKeys( aSvKeys )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Restaura os Dados de Entrada								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
RestArea( aArea )

Return( nOpcAlt )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³gpea415Locks    ³Autor³Mauricio MR         ³ Data ³14/04/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Bloqueia Lancamentos de Marcacoes /Apont/Abonos		         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL		                                               	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³gpea415                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function gpea415Locks( nOpc , cAlias , aRecnos, aKeys )

Local lLocks	:= .T.

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se nao For Visualizacao				 					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( nOpc == 2 )
		Break
	EndIF

	IF !( lLocks := WhileNoLock( cAlias , aRecnos , aKeys , 1 , 1 , .T. , NIL ) )
		Break
	EndIF

End Sequence

Return( lLocks )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³SRKGotFocus	 	 ³Autor³Tatiane Matias    ³ Data ³21/10/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³GotFocus para os Objetos GetDados do SRK (oGetSuper)		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA415()													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function SRKGotFocus()

IF Empty( __nSRKAtAnt )
	__nSRKAtAnt := oGetSuper:oBrowse:nAt
EndIF

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gp415SRKLinOk³Autor³Tatiane Matias        ³ Data ³21/10/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Linha Ok do SRK(oGetSuper)                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gp415SRKLinOk( aSvCols ) 			    					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA415()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gp415SRKLinOk()

Local lLinOk		:= .T.
Local nPosStatus	:= 0
Local nPosSaldo	:= 0
Local nPosVlTot	:= 0
Local nSaldo		:= 0
Local nValTot		:= 0


/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Altera o Estado do Cursor  								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
CursorWait()

Begin Sequence

	If !fCompArray(aCols[n] , aSvSRKCols[n])
		//Declarando variaveis de auxilio quanto a posicao dos campos
		nPosStatus	:= GdFieldPos( "RK_STATUS" , aHeader )
		nPosSaldo	:= GdFieldPos( "RK_VLSALDO" , aHeader )
		nPosVlTot	:= GdFieldPos( "RK_VALORTO" , aHeader )

		//Declarando variaveis de valores
		nSaldo		:= aCols[n,nPosSaldo]
		nValTot	:= aCols[n,nPosVlTot]
		nPosDel	:= LEN(aHeader)+1

		// Verifica se houve alguma alteracao no SRK - situacao (RK_STATUS)
		// 1)Solicitado 	-> 2)Ativo
		// 2)Ativo			-> 4)Suspenso
		// 3)Pago			-> Nao pode alterar
		// 4)Suspenso 	-> 2)Ativo
		If ((aSvSRKCols[n,nPosStatus] = "1")  .AND. (aCols[n,nPosStatus] <> "2")) .OR. ;
		   ((aSvSRKCols[n,nPosStatus] = "2")  .AND. (aCols[n,nPosStatus] <> "4")) .OR. ;
		   ((aSvSRKCols[n,nPosStatus] = "3")  .AND. (aCols[n,nPosStatus] <> "3")) .OR. ;
		   ((aSvSRKCols[n,nPosStatus] = "4")  .AND. (aCols[n,nPosStatus] <> "2"))
		   lLinOk := .F.
			//Verifica se STATUS é diferente de PAGO + Saldo é igual a valor total + Registro esta apagado
			//STATUS: Pode ser apagado se for ativo, suspenso ou solicitado sem lançamentos
			//SALDO : Se o Saldo == Valor Total, significa que nao houve lancamentos para aquele registro de Val. Futuro
			//APAGA : Faz a validação na Gp415SRKDelOk.
			If((aCols[n,nPosStatus] <> "3") .AND. (nValTot == nSaldo) .AND. (aCols[n,nPosDel] == .T.))
				lLinOk := .T.
			Else
				Help(" ",1,"GPA415SIT")
			Endif
		EndIf

	EndIf

	If(lLinOk .and. lPeSrkLinOk)
		lLinOk := lLinOk .And. ExecBlock("G415SRKLOK", .F., .F.)
	EndIf

End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura o Estado do Cursor								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
CursorArrow()

Return( lLinOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gp415SRKDelOk³Autor³Marcos Coutinho    ³ Data ³21/12/2016³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Linha Deletada Ok do SRK(oGetSuper)                       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gp415SRKLinDelOk( aSvCols ) 			    					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA415()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gp415SRKDelOk()

Local lLinOk		:= .T.
Local nPosStatus	:= 0

Local nPosValTo  := GdFieldPos( "RK_VALORTO"	, aHeader	)
Local nPosValPg  := GdFieldPos( "RK_VLRPAGO"	, aHeader	)
Local nPosStatus := GdFieldPos( "RK_STATUS"	, aHeader	)
Local nPosSaldo  := GdFieldPos( "RK_VLSALDO"	, aHeader	)

Local lStatus    := aCols[n,nPosStatus]
Local nSaldo     := aCols[n,nPosSaldo]
Local nValorTotal:= aCols[n,nPosValTo]
Local nValorPago := aCols[n,nPosValPg]

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Altera o Estado do Cursor  								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
CursorWait()

Begin Sequence
		// (1)Solicitado / (2)Ativo / (3)Pago / (4)Suspenso
	If ((lStatus == "2") .AND. (nSaldo <> nValorTotal)) .OR. ;		//Se Status == Ativo e Saldo for diferente do ValorTotal
	   ((lStatus == "3")) .OR. ;										//Se Status == Pago
	   ((lStatus == "2") .AND. (nSaldo <> nValorTotal))				//Se Status == Suspenso e Saldo for diferente do ValorTotal

		Help(" ",1,STR0016)
		lLinOk := .F.
	EndIf

End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura o Estado do Cursor								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
CursorArrow()

Return( lLinOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gp415SRKTudOk³Autor³Tatiane Matias        ³ Data ³21/10/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Tudo Ok do SRK(oGetSuper)                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gp415SRKTudOk( aSvCols )									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA415()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gp415SRKTudOk()

Local lTudoOk := .T.

Local nLoop

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Altera o Estado do Cursor  								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
CursorWait()

Begin Sequence

	aCols 	:= oGetSuper:aCols
	aHeader := oGetSuper:aHeader

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Percorre Todas as Linhas para verificar se Esta Tudo OK      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	For nLoop := 1 To Len( aCols )
		n := nLoop
		IF !( lTudoOk := Gp415SRKLinOk() )
			oGetSuper:oBrowse:Refresh()
			Break
		EndIF
	Next nLoop

End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura o Estado do Cursor								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
CursorArrow()

Return( lTudoOk  )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gp415RCKLinOk³Autor³Tatiane Matias        ³ Data ³21/10/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Linha Ok do RCK(oGetInfer)                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gp415RCKLinOk( )		    								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA415()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gp415RCKLinOk( )

Local lLinOk		:= .T.
Local lNParc		:= .F.
Local lValidar		:= .F.
Local cNParc		:= ""
Local cStatus		:= ""
Local nLinha		:= 0
Local nX			:= 0
Local nValPar		:= 0
Local nPosSRKStatus	:= GdFieldPos( "RK_STATUS" 	, aSRKHeader)
Local nPosSRKDtVenc	:= GdFieldPos( "RK_DTVENC" 	, aSRKHeader)
Local nPosRCKStatus	:= GdFieldPos( "RCK_STATUS"	, aHeader)
Local nPosNParc		:= GdFieldPos( "RCK_PARCPG"	, aHeader)
Local nPosDtPagto	:= GdFieldPos( "RCK_DTPAGO"	, aHeader)
Local nPosDtVenc	:= GdFieldPos( "RCK_PXVCTO"	, aHeader)
Local nPosRCKVlPago	:= GdFieldPos( "RCK_VLPAGO"	, aHeader)
Local nPosQtdPg     := GdFieldPos( "RCK_QTDEPG"	, aHeader)
Local nPosSRKSaldo  := GdFieldPos( "RK_VLSALDO"	, aSRKHeader)
Local nPosGhostCol	:= GdFieldPos( "GHOSTCOL" 	, oGetInfer:aHeader )
Local nPosDelRCK    := GdFieldPos( "GDDELETED"	, aHeader)
Local cMsgNoYes		:= ""

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Altera o Estado do Cursor  								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
CursorWait()

Begin Sequence

	// Se for inclusao de linha ...
	If Len(aSvRCKCols) < n
		lValidar := !GdDeleted()

	// Se houve alguma alteracao no registro ....
	ElseIf !fCompArray( aCols[n], aSvRCKCols[n] )
		lValidar := !GdDeleted()
	Else
		lValidar := .T.
	EndIf

	If lValidar .And. ( (aSvSRKCols[__nSRKAtAnt][nPosSRKStatus] == '2' .And. oGetSuper:aCols[ oGetSuper:nAt , nPosSRKStatus ] == '4') .Or. (aSvSRKCols[__nSRKAtAnt][nPosSRKStatus] == '4' .And. oGetSuper:aCols[ oGetSuper:nAt , nPosSRKStatus ] == '2'))
		lValidar := .F.
	EndIf

	If ( lValidar )
		cNParc  := aCols[ n , nPosNParc ]
		cStatus	:= aCols[ n , nPosRCKStatus ]

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica Se o Campos Estao Devidamente Preenchidos		   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If Len(aSvRCKCols) < n .Or.  !(aSvRCKCols[n][nPosNParc] == cNParc .And. aSvRCKCols[n][nPosRCKVlPago] == aCols[ n ,nPosRCKVlPago])
			aCposKey := {"RCK_PD", "RCK_PARCPG", "RCK_VLPAGO"}
			IF !( lLinOk := GdNoEmpty( aCposKey ) )
				Break
			EndIF
		EndIf

		If  !(cStatus # "3/5" )
			If ( iif(!empty(aCols[ n , nPosQtdPg ]), aCols[ n , nPosQtdPg ],0) * iif(!empty(aCols[ n, nPosRCKVlPago ]),aCols[ n, nPosRCKVlPago ],0)  )  > aSvSRKCols[__nSRKAtAnt][nPosSRKSaldo]
				cMsgNoYes := STR0011
				cMsgNoYes += CRLF
				cMsgNoYes += STR0012
				cMsgNoYes += STR0014
				IF !( MsgNoYes( OemToAnsi( cMsgNoYes )  , STR0013 ) )
					lLinOk := .F.
					Break
				EndIF
			Endif
		Endif
		// Se nao for exclusao de uma determinada parcela ...
		If (!(cStatus # "3/5" )) .AND. ( lLinOk )

			// A situacao do RCK devera ser igual a situacao do SRK.
			If ( oGetSuper:aCols[ oGetSuper:nAt , nPosSRKStatus ] <> cStatus )
				Help( " " , 1 , "GPA415SITR" )
				lLinOk := .F.
			EndIf

			// Data de pagamento obrigatorio.
			If Empty( aCols[ n , nPosDtPagto ] ) .AND. ( lLinOk )
				Help( " " , 1 , "GPA415DTPG" )
				lLinOk := .F.
			EndIf

			// Verificar se a data do proximo vencimento da 1a parcela informada eh menor
			// que a data do proximo vencimento informado no emprestimo.
			If(!cPaisLoc $ "COS*DOM")
				If ( lLinOk ) .AND. !Empty(aCols[ n , nPosDtVenc]) .AND. ( oGetSuper:aCols[ oGetSuper:nAt , nPosSRKDtVenc ] > aCols[ n , nPosDtVenc] )
					Help( " " , 1 , "GPA415VENC" )
					lLinOk := .F.
				EndIf
			EndIf
		EndIf

		// Se existir mais de um registro em RCK ...
		If ( n > 1 ) .AND. ( lLinOk )
			// Percorre as linhas anteriores para verificar se a parcela informada
			// ja existe.
			// Quando for exclusao, devera informar uma parcela ja existente.
			lNParc := .F.
			For nLinha := ( n - 1 ) to 1 step -1
				If ( aCols[ nLinha , nPosNParc ] == cNParc ) .AND. !GdDeleted(nLinha)
					If ( aCols[ nLinha , nPosRCKStatus ] == cStatus )
						Help( " " , 1 , "GPA415DUPL" )
						lLinOk := .F.
					EndIf
					lNParc	:= .T.
					Exit
				EndIf
			Next nLinha

			If !( lNParc ) .AND. ( cStatus = "5" )
				Help( , , OemToAnsi( STR0013 ), , OemToAnsi(STR0015), 1, 0 )//"Atenção"##"Número da parcela informada para exclusão não existente."
				lLinOk := .F.
			EndIf
		EndIf

		If lLinOk

			nValPar := 0
			// Precisa do FOR caso seja a primeira modificacao - unico momento em que ele pode adicionar 2 registros
			For nX := 1 to Len(aCols)
				If Empty(aCols[ nX , nPosGhostCol ]) .And. !(aCols[ nX , nPosRCKStatus ] $ "3*4*5") .AND. ValType(aCols[ nX, nPosRCKVlPago ]) == "N"
					nValPar += Round( (aCols[ nX , nPosQtdPg ] * aCols[ nX, nPosRCKVlPago ] ),2)
				Endif
			Next nX

			If  nValPar  > aSvSRKCols[__nSRKAtAnt][nPosSRKSaldo]
				cMsgNoYes := STR0011
				cMsgNoYes += CRLF
				cMsgNoYes += STR0012
				cMsgNoYes += CRLF
				cMsgNoYes += STR0014
				IF !( MsgNoYes( OemToAnsi( cMsgNoYes ) , STR0013 ))
					lLinOk := .F.
					Break
				ENDIF
			Endif
		Endif
		If ( lLinOk )
			gp415CarregaAtivos(aHeader, aCols, n, nPosRCKStatus, nPosNParc, nPosDtPagto, Len(aCols))
		EndIf

		If(lLinOk .and. lPeRckLinOk)
			lLinOk := lLinOk .AND. ExecBlock("G415RCKLOK", .F.,.F.)
		EndIf

	EndIf


End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura o Estado do Cursor								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
CursorArrow()

Return( lLinOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gp415RCKTudOk³Autor³Tatiane Matias        ³ Data ³21/10/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Tudo Ok do RCK(oGetInfer)                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gp415RCKTudOk( )		    								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA415()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gp415RCKTudOk()

Local lTudoOk := .T.

Local nLoop
Local nNrAtivos 	:= 0
Local nPosSituacao 	:= 0
Local nPosQtdParc	:= 0

aCols 			:= oGetInfer:aCols
aHeader 		:= oGetInfer:aHeader
nPosSituacao	:= GdFieldPos( "RCK_STATUS"	, aHeader)
nPosQtdParc		:= GdFieldPos( "RCK_QTDEPG"	, aHeader)
nPosPDJuros		:= GdFieldPos( "RCK_PDJURO"	, aHeader)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Altera o Estado do Cursor  								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
CursorWait()

Begin Sequence

    /*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Percorre Todas as Linhas para verificar se Esta Tudo OK      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	For nLoop := 1 To Len( aCols )
		n := nLoop

		If !( GdDeleted() )
			// Contador de registros "Ativos"
			If (nPosPDJuros == 0) .OR. Empty(aCols[n, nPosPDJuros])
				If aCols[n, nPosSituacao] == "2"
					nNrAtivos := nNrAtivos + aCols[n, nPosQtdParc]
				Else
					nNrAtivos := nNrAtivos - aCols[n, nPosQtdParc]
				EndIf
			EndIf
		EndIf

		IF !( lTudoOk := Gp415RCKLinOk( ) )
			oGetInfer:oBrowse:Refresh()
			Break
		EndIF
	Next nLoop

End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura o Estado do Cursor								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
CursorArrow()

Return( lTudoOk  )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Gpea415AllTrf	³Autor³Tatiane Matias     ³ Data ³21/10/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Transfere Informacoes do aCols para o aColsAll              ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>     								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA415                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea415AllTrf( nOpc , oGetSRK , oGetRCK , lColsToAll )

Local nSRKSvAt
Local nLinha
Local aRCKCposPes
Local aRCKCposSrt
Local bColsToAll
Local bAllToCols
Local cChave
Local nPosStatus	:= GdFieldPos( "RCK_STATUS"	, oGetRCK:aHeader )
Local nPosNParc		:= GdFieldPos( "RCK_PARCPG"	, oGetRCK:aHeader )
Local nPosDtPagto	:= GdFieldPos( "RCK_DTPAGO"	, oGetRCK:aHeader )

DEFAULT lColsToAll	:= .F.

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Garanto que o Ponteiro Estara no Final do Arquivo para que nao³
	³Carregue Conteudo Invalido nos Inicializadores Padroes        ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	PutFileInEof( "RCK" )

	nSRKSvAt	:= oGetSRK:nAt

	If ( !Empty( __nSRKAtAnt ) .and. ( __nSRKAtAnt <> nSRKSvAt ) )

		If ValType(oGetSRK:oBrowse) == "O"
			oGetSRK:Goto( __nSRKAtAnt )

			If !( oGetRCK:TudoOk() )
				oGetRCK:oBrowse:SetFocus()
				oGetSRK:Refresh()
				Break
			EndIF
		EndIf

		lColsToAll	:= .T.
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Altera o Estado do Cursor  								   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	CursorWait()

	If ( lColsToAll ) .AND. (!fCompArray( aSvRCKCols , oGetRCK:aCols ))

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Obtem as Informacoes para o GdColsExChange para o RCK         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		RCKInfTrf(	oGetSRK			,;
					oGetRCK			,;
					@cChave			,;
					@aRCKCposPes	,;
					@aRCKCposSrt	,;
					@bColsToAll		,;
					@bAllToCols		 ;
			  )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Transfere os Dados Entre aCols        					  	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		GdColsExChange(	@aColsRCAll   	,;	//01 -> Array com a Estrutura do aCols Contendo todos os Dados
						@oGetRCK:aCols	,;	//02 -> Array com a Estrutura do aCols Contendo Dados Especificos
						oGetRCK:aHeader	,;	//03 -> Array com a Estrutura do aHeader Contendo Informacoes dos Campos
						NIL				,;	//04 -> Array com as Posicoes dos Campos para Pesquisa
						cChave			,;	//05 -> Chave para Busca
						aRCKCposSrt		,;	//06 -> Array com as Posicoes dos Campos para Ordenacao
						aRCKCposPes		,;	//07 -> Array com as Posicoes dos Campos e Chaves para Pesquisa
						aHeaderRCAll	,;	//08 -> Array com a Estrutura do aHeaderAll Contendo Informacoes dos Campos
						.F.				,;	//09 -> Se Carrega o Elemento como Deletado na Remontagem do aCols
						.T.				,;	//10 -> Se deve Transferir do aCols para o aColsAll
						.F.   			,;	//11 -> Se deve Transferir do aColsAll para o aCols
						.T.				,;	//12 -> Se Existe o Elemento de Delecao no aCols
						.T.				 ;	//13 -> Se deve Carregar os Inicializadores padroes
					   )
	EndIF

	If ( __nSRKAtAnt <> nSRKSvAt )

		If ValType(oGetSRK:oBrowse) == "O"
			oGetSRK:Goto( nSRKSvAt )
		EndIf

		__nSRKAtAnt := nSRKSvAt

	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Obtem as Informacoes para o GdColsExChange para o Rdj         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	RCKInfTrf(	oGetSRK			,;
				oGetRCK			,;
				@cChave			,;
				@aRCKCposPes	,;
				@aRCKCposSrt	,;
				@bColsToAll		,;
				@bAllToCols		 ;
	 	 )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Transfiro os Dados do aColsAll para o aCols				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

	GdColsExChange(	@aColsRCAll		,;	//01 -> Array com a Estrutura do aCols Contendo todos os Dados
					@oGetRCK:aCols 	,;	//02 -> Array com a Estrutura do aCols Contendo Dados Especificos
					oGetRCK:aHeader	,;	//03 -> Array com a Estrutura do aHeader Contendo Informacoes dos Campos
					NIL				,;	//04 -> Array com as Posicoes dos Campos para Pesquisa
					cChave			,;	//05 -> Chave para Busca no aColsAll para Carga do aCols
					aRCKCposSrt		,;	//06 -> Array com as Posicoes dos Campos para Ordenacao
					aRCKCposPes		,;	//07 -> Array com as Posicoes dos Campos e Chaves para Pesquisa
					aHeaderRCAll	,;	//08 -> Array com a Estrutura do aHeaderAll Contendo Informacoes dos Campos
					.F.				,;	//09 -> Conteudo do Elemento "Deleted" a ser Carregado na Remontagem dos aCols
					.F.				,;	//10 -> Se deve Transferir do aCols para o aColsAll
					.T.				,;	//11 -> Se deve Transferir do aColsAll para o aCols
					.T.				,;	//12 -> Se Existe o Elemento de Delecao no aCols
					.T.				 ;	//13 -> Se deve Carregar os Inicializadores padroes
				 )

	If ( nOpc == 3 ) // alteracao
		nPosSit	:= GdFieldPos( "RK_STATUS", oGetSRK:aHeader )
		// So ira permitir a inclusao e alteracao quando a situacao estiver Ativo.
		If aSvSRKCols[oGetSRK:nAt, nPosSit] == "2"
			oGetRCK:lInsert 	:= .T.
			oGetRCK:lUpdate 	:= .T.
		Else
			oGetRCK:lInsert 	:= .F.
			oGetRCK:lUpdate 	:= .F.
		EndIf
	EndIf

	If ValType(oGetRCK:oBrowse) == "O"
		oGetRCK:Goto( 1 )
		oGetRCK:Refresh()
	EndIf

	aSvRCKCols 	:= aClone(oGetRCK:aCols)
	aColsAtivos := {}
	For nLinha := 1 to Len(aSvRCKCols)
		gp415CarregaAtivos(oGetRCK:aHeader, aSvRCKCols, nLinha, nPosStatus, nPosNParc, nPosDtPagto, nLinha)
	Next nLinha


End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura o Estado do Cursor								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
CursorArrow()

Return ( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RCKInfTrf		 ³Autor³Marinaldo de Jesus³ Data ³05/08/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Monta as informacoes que serao utilizadas para a  transferen³
³          ³cia de informacoes no GdColsExChange do RCK                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA415()													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function RCKInfTrf(	oGetSRK		,;
							oGetRCK		,;
							cChave		,;
							aRCKCposPes	,;
							aRCKCposSrt	,;
							bColsToAll	,;
							bAllToCols	 ;
				  		)

Local nPosFilial	:= GdFieldPos( "RCK_FILIAL"	, aHeaderRCAll )
Local nPosMatric  	:= GdFieldPos( "RCK_MAT"	, aHeaderRCAll )
Local nPosNumid   	:= GdFieldPos( "RCK_NUMID"	, aHeaderRCAll )
Local nPosSeq		:= GdFieldPos( "RCK_SEQUEN"	, aHeaderRCAll )
Local cNumid 		:= GdFieldGet( "RK_NUMID"  	, oGetSRK:nAt , .F. , oGetSRK:aHeader , oGetSRK:aCols )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carrega Array a Posicao dos Campos para o "Sort"			  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aRCKCposSrt := {}
aAdd( aRCKCposSrt , nPosFilial )
aAdd( aRCKCposSrt , nPosMatric )
aAdd( aRCKCposSrt , nPosNumid  )
aAdd( aRCKCposSrt , nPosSeq    )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carrega Array com a Posicao dos Campos e as Chaves  Correspon³
³dentes														  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aRCKCposPes := {}
aAdd( aRCKCposPes , { nPosFilial , cFilSRA } )
aAdd( aRCKCposPes , { nPosMatric , cMatSRA } )
aAdd( aRCKCposPes , { nPosNumid  , cNumid  } )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Monta a chave para busca no aColsAll e Transferencia para   o³
³Respectivo aCols											  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cChave := ( cFilSRA + cMatSRA + cNumid)

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gp415Inic	     ³Autor³Tatiane Matias    ³ Data ³22/10/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Inicializador Padrao 										³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO dos campos RCK_STATUS e RCK_VLPAGO				³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function gp415Inic( cColuna )

Local cConteudo 	:= ""

Local nPosColuna	:= GdFieldPos( cColuna		, aSRKHeader )
Local nPosPdRk		:= GdFieldPos( "RK_PD"		, aSRKHeader )
Local nPosVlRes		:= GdFieldPos( "RK_VALORAR"	, aSRKHeader )
Local nPosNParc		:= GdFieldPos( "RK_PARCELA"	, aSRKHeader )
Local nPosParcPg	:= GdFieldPos( "RCK_PARCPG"	, aRCKHeader)
Local nPosPdRck		:= GdFieldPos( "RCK_PD"		, aRCKHeader)

	If Len( aColsRCAll ) > 0 .And. nPosPdRck > 0 //.And. aScan( aColsRCAll, { |x| !Empty( x[ nPosPdRck ] ) } ) > 0
		Do Case
			Case ( cColuna == "RK_VALORPA" )
				If Len(oGetInfer:aCols) > 0
					If ( oGetSuper:aCols[oGetSuper:nAt, nPosNParc] == oGetInfer:aCols[ Len(oGetInfer:aCols) , nPosParcPg ] )
						cConteudo := oGetSuper:aCols[oGetSuper:nAt, nPosColuna] + oGetSuper:aCols[oGetSuper:nAt, nPosVlRes]
					Else
						cConteudo := oGetSuper:aCols[oGetSuper:nAt, nPosColuna]
					EndIf
				Else
					cConteudo := oGetSuper:aCols[oGetSuper:nAt, nPosColuna]
				EndIf

			Case ( cColuna == "RK_DTVENC" )
				cConteudo := Gp010RetCont("RCH_DTINI",,SRA->RA_PROCES)

				If Empty( cConteudo )
					cConteudo := oGetSuper:aCols[oGetSuper:nAt, nPosColuna]
				EndIf

			Case ( cColuna == "RK_STATUS" )
				cConteudo := aSvSRKCols[oGetSuper:nAt, nPosColuna]

			Case ( cColuna == "RK_PD" )
				cConteudo := oGetSuper:aCols[oGetSuper:nAt, nPosColuna]

			Case ( cColuna == "RK_DESCPD" )
				cConteudo := fDesc("SRV", oGetSuper:aCols[oGetSuper:nAt, nPosPdRk] , "RV_DESC" )

			OtherWise
				cConteudo := oGetSuper:aCols[oGetSuper:nAt, nPosColuna]
		EndCase
	EndIf
Return ( cConteudo )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gp415NParcInic   ³Autor³Tatiane Matias    ³ Data ³22/10/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Inicializador Padrao 										³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RCK_PARCPG								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function gp415NParcInic(cColuna)

Local cConteudo := ""
Local nNParc	:= 0
Local nLinha	:= 0
Local nPosNum	:= GdFieldPos( cColuna		, oGetInfer:aHeader )
Local nPosStatus:= GdFieldPos( "RCK_STATUS"	, oGetInfer:aHeader )
Local aColsRCK	:= oGetInfer:aCols

	If Len(aColsRCK) > 0
		nNParc := aColsRCK[1, nPosNum]
		For nLinha := 2 to (Len(aColsRCK) - 1)
			If !GdDeleted(nLinha)
				If aColsRCK[nLinha, nPosStatus] = "2"
					If nNParc < aColsRCK[nLinha, nPosNum]
						nNParc := aColsRCK[nLinha, nPosNum]
					EndIf
				ElseIf aColsRCK[nLinha, nPosStatus] = "5"
					If nNParc = aColsRCK[nLinha, nPosNum]
						nNParc := nNParc - 1
					EndIf
				EndIf
			EndIf
		Next nLinha

		cConteudo := nNParc + 1
	Else
		cConteudo := 1
	EndIF

Return ( cConteudo )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gp415SeqInic     ³Autor³Tatiane Matias    ³ Data ³22/10/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Inicializador Padrao 										³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO do campo RCK_SEQUEN								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function gp415SeqInic()
Local nTotal	:= 0
Local nLinha	:= 0

	If Len(oGetInfer:aCols) = 0
		cConteudo := 1
	Else
		For nLinha := 1 To Len(oGetInfer:aCols) - 1
			If !GdDeleted(nLinha, oGetInfer:aHeader, oGetInfer:aCols)
				nTotal := nTotal + 1
			EndIf
		Next nLinha
		cConteudo := nTotal + 1
	EndIf

Return ( cConteudo )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea415Grava ³Autor³Tatiane Matias        ³ Data ³26/10/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GEPA415()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpea415Grava(nOpc			,; // Opcao de Acordo com aRotina
							 aRecnosRC  	,; // Recnos do Arquivo Filho (RCK)
							 aLstRCaColsAll ,; // Itens Anteriores do Arquivo Filho ( RCK )
							 aVirtualRC		 ; // Campos Virtuais do Arquivo Filho ( RCK )
							  )
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis de Inicializacao Obrigatoria					  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aSubItens		:= {}
Local aItens		:= {}
Local aMestre		:= GdPutIStrMestre( 01 )
Local aArea
Local cOpcao		:= IF( (nOpc == 3) , "PUT" , NIL )
Local lGp415Grv		:= ExistBlock("GP415GRV")
Local lModItens		:= .F.
Local lGravouRCK    := .F.
Local lAltPago      := .F.
Local lAltSRK       := .F.
Local cSRKStatus    := ""
Local nLinha		:= 0
Local nIndex		:= 1
Local nSubItens		:= 0
Local nItens		:= 0
Local nValorJuros   := 0
Local nPosGhostCol	:= GdFieldPos( "GHOSTCOL" 	, oGetInfer:aHeader )
Local nPosFecVen    := GdFieldPos( "RCK_PXVCTO"	, oGetInfer:aHeader )
Local nPosVlPago    := GdFieldPos( "RCK_VLPAGO"	, oGetInfer:aHeader	)
Local nPosSitua 	:= GdFieldPos( "RCK_STATUS"	, oGetInfer:aHeader	)
Local nPosRCKPdJur	:= GdFieldPos( "RCK_PDJURO"	, oGetInfer:aHeader	)
Local nPosQtdPg		:= GdFieldPos( "RCK_QTDEPG"	, oGetInfer:aHeader	)
Local nPosRCFil		:= GdFieldPos( "RCK_FILIAL"	, aHeaderRCAll 	)
Local nPosRCMat		:= GdFieldPos( "RCK_MAT"	, aHeaderRCAll 	)
Local nPosRCNmi		:= GdFieldPos( "RCK_NUMID"	, aHeaderRCAll	)
Local nPosDtPag		:= GdFieldPos( "RCK_DTPAGO"	, aHeaderRCAll	)
Local nPosNumid     := GdFieldPos( "RK_NUMID"	, aSRKHeader	)
Local nPosSRKSit 	:= GdFieldPos( "RK_STATUS"	, aSRKHeader	)
Local nPosSRKPd  	:= GdFieldPos( "RK_PD"		, aSRKHeader	)
Local sChave 		:= ""
Local nValorPago	:= 0
Local nApaga		:= LEN(aSRKHeader)+1
Local lApaga		:= .F.
Local bValorPago 	:= {|x, y| If( x[nPosSitua] <> "5" .and. (nPosRCKPdJur == 0 .OR. Empty(x[nPosRCKPdJur]) ), ;
									If(x[nPosQtdPg] ==0, nValorPago += x[nPosVlPago], nValorPago += ( x[nPosVlPago] * x[nPosQtdPg] )), ;
									If( (nPosRCKPdJur == 0 .OR. Empty(x[nPosRCKPdJur])),;
										If(x[nPosQtdPg] ==0, nValorPago -= x[nPosVlPago], nValorPago -= ( x[nPosVlPago] * x[nPosQtdPg] )),;
										0 );
									) }
Local bValorJuros 	:= {|x, y| If( x[nPosSitua] <> "5" .and. (nPosRCKPdJur != 0 .AND. !Empty(x[nPosRCKPdJur])), ;
									If(x[nPosQtdPg] ==0, nValorJuros += x[nPosVlPago], nValorJuros += ( x[nPosVlPago] * x[nPosQtdPg] )), ;
									If( (nPosRCKPdJur != 0 .AND. !Empty(x[nPosRCKPdJur])),;
										If(x[nPosQtdPg] ==0, nValorJuros -= x[nPosVlPago], nValorJuros -= ( x[nPosVlPago] * x[nPosQtdPg] )),;
										0 );
									) }
Local nParcPago		:= 0
Local bParcPago 	:= {|x, y| If( (nPosRCKPdJur == 0 .OR. Empty(x[nPosRCKPdJur])), nParcPago += x[nPosQtdPg], 0 ) }
Local dDtVenc		:= CTOD("//")
Local aSvAtivos		:= {}
Local cUsrRCK 		:= UsrRetName(RetCodUsr())

#IFNDEF TOP
	Local lTopDelItens	:= .F.
	Local lExecSort		:= .T.
#ELSE
	Local lTopDelItens	:= .T.
	Local lExecSort		:= .F.
#ENDIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Altera o Estado do Cursor  								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
CursorWait()

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Transfere os Dados do aCols para o aColsAll     			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	Gpea415AllTrf( nOpc, oGetSuper , @oGetInfer, .T.)

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Preparando Gravacao										   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	Gpea415PreGrv()

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se Houve alteracoes nos Itens					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	lModItens := (( nOpc == 5 ).or.!fCompArray( aColsRCAll , aLstRCaColsAll ))

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega os Itens Apenas se Houveram Alteracoes ou na Exclusao³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lModItens )

		aAdd( aSubItens , GdPutIStrSItens() )
		nSubItens := Len( aSubItens )
		aSubItens[ nSubItens , 01 ] := "RCK"
		aSubItens[ nSubItens , 02 ] := aClone( aRecnosRC )
		aSubItens[ nSubItens , 03 ] := NIL
		aSubItens[ nSubItens , 04 ] := { |nElem|	( RCK_FILIAL	== aColsRCAll[ nElem , nPosRCFil ]	) .and. ;
													( RCK_MAT		== aColsRCAll[ nElem , nPosRCMat ]	) .and. ;
													( RCK_NUMID		== aColsRCAll[ nElem , nPosRCNmi ] 	)       ;
					 		 			}
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega os Itens Apenas se Houveram Alteracoes ou na Exclusao³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

		aAdd( aItens , GdPutIStrItens() )
		nItens := Len( aItens )

		aItens[ nItens , 01 ] := "RCK"
		aItens[ nItens , 02 ] := {}
		aItens[ nItens , 03 ] := aClone( aHeaderRCAll )
		aItens[ nItens , 04 ] := aClone( aColsRCAll	  )
		aItens[ nItens , 05 ] := aClone( aVirtualRC   )
		aItens[ nItens , 06 ] := aClone( aRecnosRC	  )

	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Seta a Gravacao ou Exclusao Apenas se Houveram Alteracoes  ou³
	³ se foi Selecionada a Exclusao								   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aMestre[ 01 , 01 ]	:= "SRA"
	aMestre[ 01 , 02 ]	:= SRA->( Recno() )
	aMestre[ 01 , 03 ]	:= .F.
	aMestre[ 01 , 04 ]	:= NIL
	aMestre[ 01 , 05 ]	:= NIL
	aMestre[ 01 , 06 ]	:= NIL
	aMestre[ 01 , 07 ]	:= aClone( aItens )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Grava as Informacoes                        				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	GdPutInfoData( aMestre , cOpcao , lTopDelItens , lExecSort )

	// 1)Solicitado -> 2)Ativo
	// 2)Ativo	 	-> 4)Suspenso
	// 4)Suspenso 	-> 2)Ativo
	// Gravar um registro em RCK contendo o usuario, a data de alteracao da situacao
	// e para qual situacao o registro SRK foi alterado.
	// Atualizar o SRK com a nova situacao

		dbSelectArea( "SRK" )
		nIndex	:= IndexOrd()
		SRK->( dbSetOrder( RetOrdem( "SRK" , "RK_FILIAL+RK_MAT+RK_NUMID" ) ) )
		ffiltro("GPEA415",aArray, 1 /* Exec Filtro*/, 2 /*Inicio*/, 3/*Fim*/)

		For nLinha := 1 to Len(oGetSuper:aCols)
			sChave := cFilSRA + cMatSRA + oGetSuper:aCols[nLinha, nPosNumid ]
			lApaga := oGetSuper:aCols[nLinha, nApaga]
			//Faz a pesquisa no pai
			If( SRK->( dbSeek( sChave  )))
				//Verifica se o registro pai esta apagado
				If(lApaga)
					//Verifica se o pai possui filhos na RCK
					DBSELECTAREA("RCK")
					RCK->(DBSETORDER( 2 )) //RCK_FILIAL+RCK_MAT+RCK_NUMID+STR(RCK_SEQUEN, 5, 0)

					cChaveRCK := sChave + STR(nLinha,5,0)
					//Se encontrar os filhos, começa a apagar 1 por 1 e após isso
					If(RCK->(dbSeek(cChaveRCK)))
						While(RCK->RCK_NUMID == oGetSuper:aCols[nLinha, nPosNumid ])
							RCK->( RecLock( "RCK" , .F.) )
								RCK->(DBDELETE())
							MSUnlock()
							dbSkip()
						endDo
					Endif
					//Apaga o pai
					SRK->( RecLock( "SRK" , .F.) )
						SRK->(DBDELETE())
					MSUnlock()
				Else
				//Pai não esta apagado, então é só alteração
						SRK->( RecLock( "SRK" , .F. , .T.) )
						oGetSuper:nAt := nLinha
                     Gpea415AllTrf( nOpc, oGetSuper , @oGetInfer, .F. )
						cSRKStatus := oGetSuper:aCols[nLinha, nPosSRKSit ]
						cSequen:= Len(oGetInfer:aCols)

			            // Verifica se houve alteracao na SRK
						lAltSRK := !fCompArray(oGetSuper:aCols[nLinha] , aSvSRKCols[nLinha])

						// Verifica se houve alteracao na RCK
						aArea := GetArea()
						dbSelectArea("RCK")
					    dbSetOrder(2)
					    If dbSeek(cFilSRA + cMatSRA + oGetSuper:aCols[nLinha, nPosNumid ])
					       If dbSeek(cFilSRA + cMatSRA + RCK->RCK_NUMID + STR(cSequen, 5, 0))
							   	lGravouRCK := .T.
				    	   Else
			         	   	lGravouRCK := .F.
			         	   Endif
			         	Else
			         		lGravouRCK := .F.
			         	EndIf

						RestArea(aArea)

			            If ( lGravouRCK .And. cSRKStatus == "2" )
							nValorPago := 0
							aEval(aColsAtivos, bValorPago)
							SRK->RK_VLRPAGO := nValorPago
							SRK->RK_VLSALDO	:= If( ( SRK->RK_VALORTO - nValorPago ) > 0, ( SRK->RK_VALORTO - nValorPago ), 0)

							nValorJuros := 0
							aEval( aColsAtivos, bValorJuros )
							SRK->RK_PGJUROS	:= nValorJuros

							nParcPago := 0
							aEval(aColsAtivos, bParcPago)
							SRK->RK_PARCPAG := nParcPago

							dDtVenc	:= CTOD("//")
							If Len( aColsAtivos ) > 0  .and. nPosFecVen > 0
								aSvAtivos := aClone(aColsAtivos)
								aSort( aSvAtivos, NIL, NIL, {|x,y| x[nPosFecVen] > y[nPosFecVen]})
								dDtVenc	:= aSvAtivos[1, nPosFecVen]
								If !Empty(dDtVenc)
									SRK->RK_DTVENC	= dDtVenc
								EndIf
							EndIf
			            EndIf

						If cPaisLoc <> "COL"

							If  SRK->RK_VLSALDO <= 0 .OR. (SRK->RK_VLJUROS > 0 .AND. SRK->RK_PGJUROS >= SRK->RK_VLJUROS)
								SRK->RK_STATUS := "3"
								lAltPago := .T.
							EndIf

					    ElseIf SRK->RK_VLSALDO <= 0
							   SRK->RK_STATUS := "3"
							   lAltPago := .T.
					    EndIf


					   	If lAltSRK // SRK Alterada

							// Atualizar SRK
							SRK->RK_STATUS := cSRKStatus

						    If !lGravouRCK // Se RCK nao foi gravada, criar novo registro na RCK
								RCK->( RecLock("RCK",.T.) )
								RCK->RCK_FILIAL	:= cFilSRA
								RCK->RCK_MAT	:= cMatSRA
								RCK->RCK_PD		:= oGetSuper:aCols[nLinha, nPosSRKPd  ]
								RCK->RCK_STATUS	:= cSRKStatus
								RCK->RCK_USUARI	:= cUsrRCK
								RCK->RCK_DTALTE	:= MsDate()
								RCK->RCK_NUMID	:= oGetSuper:aCols[nLinha, nPosNumid ]
								RCK->RCK_SEQUEN	:= If(Len(oGetInfer:aCols) == 1 .And. Empty(oGetInfer:aCols[1,nPosGhostCol]),cSequen,cSequen+1)
								RCK->( MsUnLock() )
							EndIf
						ElseIf lAltPago // Se quitou o emprestimo
								aArea := GetArea()
								dbSelectArea("RCK")
							    dbSetOrder(2)
							    If dbSeek(cFilSRA+cMatSRA+oGetSuper:aCols[nLinha, nPosNumid ])
								    While !RCK->(Eof()) .And. RCK->(RCK_FILIAL+RCK_MAT+RCK_NUMID) == cFilSRA+cMatSRA+oGetSuper:aCols[nLinha, nPosNumid ]
									    RCK->( RecLock("RCK",.F.) )
										RCK->RCK_STATUS := "3"
										RCK->( MsUnLock() )

										RCK->(dbSkip())
									EndDo
					         	EndIf
								RestArea(aArea)
						EndIf

			    	  	SRK->( MsUnlock() )

			    	  	lAltPago := .F.
				Endif
			Endif
		Next nLinha

		//PE apos a gravacao dos dados da amortizacao
		If lGp415Grv
			ExecBlock("GP415GRV", .F., .F.)
		EndIf

		SRK->( dbSetOrder(nIndex) )
		ffiltro("GPEA415",aArray, 1 /* Exec Filtro*/, 2 /*Inicio*/, 3/*Fim*/)
End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura o Estado do Cursor								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
CursorArrow()

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea415PreGrv ³Autor³Marinaldo de Jesus   ³ Data ³13/06/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Prepara os Arrays  RCK para la gravacion                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA415                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpea415PreGrv()

Local aAux			:= {}
Local bAscan		:= { || NIL }
Local nPosFil 		:= 0
Local nPosMat 		:= 0
Local nPosIni		:= 0
Local nLenArray		:= 0

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Define o Bloco para Procura de Informacoes invalidas		   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
bAscan := { |x| ( x[nPosFil] <> cFilSRA ) .and. ( x[nPosMat] <> cMatSRA ) }

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Remonta Array do RCK eliminando Informacoes Invalidas		   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
nPosFil := GdFieldPos( "RCK_FILIAL"	, aHeaderRCAll )
nPosMat := GdFieldPos( "RCK_MAT"	, aHeaderRCAll )
IF ( aScan( aColsRCAll , bAscan ) > 0 )
	nLenArray := Len( aColsRCAll )
	For nPosIni := 1 To nLenArray
		IF ( ( aColsRCAll[nPosIni,nPosFil] == cFilSRA ) .and. ( aColsRCAll[nPosIni,nPosMat] == cMatSRA ) )
			aAdd( aAux , aClone( aColsRCAll[ nPosIni ] ) )
		EndIF
	Next nPosIni
	aColsRCAll	:= aClone( aAux )
	aAux		:= {}
EndIF

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gp415ChkAlt   ³Autor³Tatiane Matias       ³ Data ³27/10/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica se o registro pode ser alterado.                   ³
³          ³O registro so podera ser alterado se for uma inclusao.      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Todos os campos do SX3 da tabela RCK.                       ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function gp415ChkAlt()

Local lRet 			:= .F.
Local nPosGhostCol	:= GdFieldPos( "GHOSTCOL" 	, aHeader )
Local nPosSituacao	:= GdFieldPos( "RCK_STATUS" , aHeader )

	If Val(aCols[n, nPosGhostCol]) == 0
		If ((aCols[n, nPosSituacao] == "5") .AND. ((ReadVar() == "M->RCK_STATUS") .OR. (ReadVar() == "M->RCK_PARCPG")));
			.OR.;
			(aCols[n, nPosSituacao] <> "5")
			   	lRet := .T.
		EndIf
	EndIf
Return ( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gp415QtdePg   ³Autor³Tatiane Matias       ³ Data ³27/10/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna a quantidade de parcelas pagas do numero de         ³
³          ³pagamento informado. Utilizado para o Mexico.               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gatilho no campo RCK_NUMPAG, para preencher o campo         ³
³          ³RCK_QTDEPG.                                                 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function gp415QtdePg()

Local nQtdeParc		:= 1
Local nLinha		:= 0
Local nPosSit 		:= GdFieldPos( "RCK_STATUS" , aHeader)
Local nPosNParc		:= GdFieldPos( "RCK_PARCPG"	, aHeader)
Local nPosQtde		:= GdFieldPos( "RCK_QTDEPG"	, aHeader)
Local nPosValor		:= GdFieldPos( "RCK_VLPAGO"	, aHeader)
Local nPosDtPago	:= GdFieldPos( "RCK_DTPAGO"	, aHeader)

	If aCols[ n , nPosSit ] == "5"
		For nLinha := ( n - 1 ) to 1 step -1
			If ( aCols[ nLinha , nPosNParc ] == aCols[ n , nPosNParc ] )
		 		nQtdeParc 				:= aCols[ nLinha , nPosQtde ]
		 		aCols[ n , nPosValor ] 	:= aCols[ nLinha , nPosValor ]
		 		aCols[ n , nPosDtPago ]	:= aCols[ nLinha , nPosDtPago ]
				Exit
			EndIf
		Next nLinha
	EndIf

Return ( nQtdeParc )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gp415ChkDel   ³Autor³Tatiane Matias       ³ Data ³27/10/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica se o registro pode ser excluido.                   ³
³          ³O registro so podera ser excluido se for uma inclusao.      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³No bDelOk da oGetInfer.				                        ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function gp415ChkDel()
Local lRet		:= .T.
Local nPosPxVcto	:= GdFieldPos( "RCK_PXVCTO"	, aHeader	)
Local nPosStatus	:= GdFieldPos( "RCK_STATUS"	, aHeader	)
Local nPosGhostCol	:= GdFieldPos( "GHOSTCOL" 	, aHeader )
Local cPxVcto 		:= CtoD("//")
Local cStatus    	:= 0
Local aPerAtual		:={}
Local cFolMes 		:= ""

fGetPerAtual( @aPerAtual, xFilial("RCH"), SRA->RA_PROCES, fGetRotOrdinar() )
If Empty(aPerAtual)
	fGetPerAtual( @aPerAtual, xFilial("RCH"), SRA->RA_PROCES, fGetCalcRot('9') )
EndIf					

If !(Empty(aPerAtual))
	cFolMes := AnoMes(aPerAtual[1,6])
Else
	cFolMes := AnoMes(Date())
EndIf

If nPosPxVcto > 0 .And. nPosStatus > 0
	cPxVcto := AnoMes(aCols[n,nPosPxVcto])
	cStatus := aCols[n,nPosStatus]
EndIf

// (1)Solicitado / (2)Ativo / (3)Pago / (4)Suspenso
If (cFolMes == cPxVcto) .And. (cStatus <> "2")   // Não permite excluir se for status diferente de ativo e não for dentro do período ativo
	Help(,,OemToAnsi(STR0013),,OemToAnsi(STR0017),1,0) // Exclusão é permitida somente para lançamentos com Status ativo e Data de Vencimento dentro do periodo ativo."  
	lRet := .F.
EndIf

Return ( lRet )


Static Function gp415CarregaAtivos(aRCKHeader, aRCKCols, nLinha, nPosStatus, nPosNParc, nPosDtPagto, nTamanho)
Local nParcela	:= 0
Local nPosNIL	:= 0

	If !GdDeleted(nLinha, aRCKHeader, aRCKCols)	.AND. ;
	   !Empty(aRCKCols[nLinha, nPosNParc]) 		.AND. ;
	   !Empty(aRCKCols[nLinha, nPosDtPagto])

		nParcela := aScan( aColsAtivos , { |x| x[nPosStatus] == "2" .AND. x[nPosNParc] == aRCKCols[ nLinha , nPosNParc]})

		// Adicionar no array as parcelas ativas.
		If aRCKCols[nLinha, nPosStatus] == "2" .AND. nParcela == 0
			aAdd( aColsAtivos , aRCKCols[nLinha] )

		// Atualizar os dados da parcela no array
		ElseIf aRCKCols[nLinha, nPosStatus] == "2" .AND. nParcela > 0 .AND. nLinha >= nTamanho
			aColsAtivos[nParcela] := aClone(aRCKCols[nLinha])

		// Deletar do array as parcelas excluidas.
		ElseIf aRCKCols[nLinha, nPosStatus] == "5" .AND. nParcela > 0 .AND. nLinha >= nTamanho
			aDel( aColsAtivos, nParcela )
		EndIf

		// Redimensiona o array caso algum elemento foi deletado.
		nPosNIL := aScan(aColsAtivos, NIL)
		If nPosNIL > 0
			aSize( aColsAtivos, nPosNIL - 1)
		EndIf
	EndIf

	// Ordena por parcela
	aSort( aColsAtivos, NIL, NIL, {|x,y| x[2] < y[2]})

Return ( NIL )

// --
// --

Function GPEA415Mult (cReadVar,xConteudo,lHelp)

Local nPosRCNmi		:= GdFieldPos( "RCK_NUMID"	, aRCKHeader)
Local nPosRCVpa		:= GdFieldPos( "RCK_VLPAGO"	, aRCKHeader)
Local nPosRCPcp		:= GdFieldPos( "RCK_PARCPG"	, aRCKHeader)
Local nValorPar     := 0
Local sChave := ""
Local nPosRen := 0

DEFAULT cReadVar := ReadVar()
DEFAULT xConteudo:= &(cReadVar)
DEFAULT lHelp    := .T.

IF cReadVar = "M->RCK_PARCPG"

	sChave = cFilSRA + cMatSRA+aCols[n,nPosRCNmi]
	dbSelectArea( "SRK" )
	SRK->( dbSetOrder( RetOrdem( "SRK" , "RK_FILIAL+RK_MAT+RK_NUMID" ) ) )
	ffiltro("GPEA415",aArray, 1 /* Exec Filtro*/, 2 /*Inicio*/, 3/*Fim*/)
	IF  SRK->( dbSeek( sChave  ) )
	    nValorPar = SRK->RK_VALORPA
	ENDIF
	aCols[n,nPosRCVpa] =  nValorPar * xConteudo

ENDIF

Return .t.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gpa415ValPD   ³Autor³Mauricio T. Takakura ³ Data ³29/09/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica se a verba informada esta vinculada com o SRK      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SX3                    				                        ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function gpa415ValPD()

Local cCampoAtu		:= ReadVar()
Local cPDJuros 		:= &( ReadVar() )

Local lRet := .T.

Local nPosVlPago
Local nPosPcJuros
Local nPosSRKPd  	:= GdFieldPos( "RK_PDJUROS"		, aSRKHeader	)
Local nPosRCKPd  	:= GdFieldPos( "RCK_PD"			, aRCKHeader	)
Local nLinhaSRK     := oGetSuper:oBrowse:nAt
Local nLinhaRCK		:= oGetInfer:oBrowse:nAt

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Validar a verba informada pelo usuario.                	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If "RCK_PDJURO" $ cCampoAtu
	If oGetSuper:aCols[ nLinhaSRK, nPosSRKPd  ] != cPDJuros
		MsgInfo( OemToAnsi( STR0010 )  )  //"A Verba informada nao eh a mesma informada no Cadastro de Valores Futuros!"
		lRet := .F.
	EndIf
/*ElseIf "RCK_PD" $ cCampoAtu .and. !empty(cPDJuros)
	If ( oGetSuper:aCols[ nLinhaSRK, nPosRCKPd  ] != cPDJuros ) .And. ( oGetSuper:aCols[ nLinhaSRK, nPosSRKPd  ] != cPDJuros )
		MsgInfo( OemToAnsi( STR0010 )  )  //"A Verba informada nao eh a mesma informada no Cadastro de Valores Futuros!"
		lRet := .F.
	EndIf
	*/
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Trocar o valor da Parcela - Trazer do campo Juros   		   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If lRet .And. "RCK_PDJURO" $ cCampoAtu
   IF cPaisLoc <> "COL"
      nPosVlPago  := GdFieldPos( "RCK_VLPAGO"	, aRCKHeader )
	  nPosPcJuros := GdFieldPos( "RK_PCJUROS"	, aSRKHeader )
	  oGetInfer:aCols[ nLinhaRCK, nPosVlPago ] := oGetSuper:aCols[ nLinhaSRK, nPosPcJuros ]
   ENDIF
EndIf

Return( lRet )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ MenuDef		³Autor³  Luiz Gustavo     ³ Data ³05/01/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Isola opcoes de menu para que as opcoes da rotina possam    ³
³          ³ser lidas pelas bibliotecas Framework da Versao 9.12 .      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA390                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³aRotina														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

Static Function MenuDef()

/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define Array q contiene las Rutinas a ejecutar del programa  ³
	³ ----------- Elementos contidos por dimensao ------------     ³
	³ 1. Nome a aparecer no cabecalho                              ³
	³ 2. Nome da Rotina associada                                  ³
	³ 3. Usado pela rotina                                         ³
	³ 4. Tipo de Transa‡„o a ser efetuada                          ³
	³    1 - Pesquisa e Posiciona em um Banco de Dados             ³
	³    2 - Simplesmente Mostra os Campos                         ³
	³    3 - Inclui registros no Bancos de Dados                   ³
	³    4 - Altera o registro corrente                            ³
	³    5 - Remove o registro corrente do Banco de Dados          ³
	³    6 - Legenda                                               ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	Local aRotina :=   {	{ STR0001 , "PesqBrw"	 , 0 , 01,,.F. } ,; //"Pesquisar"
							{ STR0002 , "gpea415Mnt" , 0 , 02 } ,;		 //"Visualizar"
							{ STR0003 , "gpea415Mnt" , 0 , 04 } ,; 		 //"Alterar"
							{ STR0004 , "GpLegend"   , 0 , 05,,.F. } ;  //"Legenda"
						}


Return aRotina
