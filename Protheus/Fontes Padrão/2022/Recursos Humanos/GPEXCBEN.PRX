#INCLUDE "GPEXCALC.CH"
#INCLUDE "PROTHEUS.CH"

Static aCriterio 	:= {}
Static aFaltas		:= {}
Static cTipoCri		:= ""
Static cNroPed		:= ""
Static cFilPed      := ""
Static lUsaCPer		:= GetMvRH("MV_USACPER",, .F.) //.T.=Usa periodo folha/.F.= usa calendario ponto
Static lUsaGS       := GetMvRH("MV_TECXRH", NIL, .F. )
Static lGp210Sal
Static lGPM5001
Static lGPVTRDias
Static nFaltasAut	:= 0 // Dias de falta para o cálculo automático
Static nDiasRef		:= 0 // Dias de referência para VA e VR
Static nTamPed 		:= GetSx3Cache( "R0_NROPED", "X3_TAMANHO" )
Static __lMemCalc
Static lGPM19RGB 
Static lTemCCT
Static lOtbCCT

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³			ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.			  			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data	³ FNC			 ³  Motivo da Alteracao 					³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Flavio Corre³25/02/15³PCREQ-2898      ³Inclusao fonte							³±±
±±³Allyson M.  ³04/03/15³TRIA28    		 ³Ajuste em fMedia13() p/ verificar se e'   ³±±
±±³            ³        ³          		 ³complemento de 13o.    					³±±
±±³Mariana M.  ³04/09/15³TSZLXV    		 ³Ajuste em fVTRCalc() p/ quando percentual ³±±
±±³            ³        ³          		 ³for diferente de 6%. Sistema irá respeitar³±±
±±³            ³        ³          		 ³o que foi informado no cadastro da verba. ³±±
±±³            ³        ³          		 ³Também foi ajustado o sistema para quando ³±±
±±³            ³        ³          		 ³possuir sábados como não trabalhados, mas ³±±
±±³            ³        ³          		 ³a empresa para o VT para os funcionários, ³±±
±±³            ³        ³          		 ³o sistema terá que calcular a quantidade  ³±±
±±³            ³        ³          		 ³de Dias Uteis de VT e Não Uteis de VT cor-³±±
±±³            ³        ³          		 ³retamente.								³±±
±±³Allyson M.  ³19/10/15³TTQ964    		 ³Ajuste em fVRFCalc() p/ considerar os dias³±±
±±³            ³        ³          		 ³de VR que sao no sabado/domingo			³±±
±±³Renan Borges³14/12/15³TTUHKO    		 ³Ajuste no cálculo de VT quando há dias fi-³±±
±±³            ³        ³          		 ³xos cadastrados no meio de VT.            ³±±
±±³Christiane V.³06/11/15³TTSM85         ³Ajuste na FCalcDSR para considerar a data ³±±
±±³             ³        ³               ³de admissao ao pesquisar os dias de DSR   ³±±
±±³             ³        ³               ³somente no mes de admissao do funcionario.³±±
±±³Allyson M.   ³11/12/15³TU9321         ³Ajuste na validacao dos dias afastados    ³±±
±±³             ³        ³               ³quando for calculo do dissidio            ³±±
±±³Allyson M.   ³11/12/15³TU9321         ³Ajuste em fVTRCalc() p/ nao descontar     ³±±
±±³             ³        ³               ³o VT de funcionario estagiario.           ³±±
±±³Renan Borges ³18/12/15³TUBRN8		 ³Ajuste para fechar alias temporario aberto³±±
±±³Allyson M.   ³24/12/15³TTZEZ2         ³Ajuste em fVlsAus() e em fVTRCalc() p/ nao³±±
±±³             ³        ³               ³calcular VT p/ funcionario afastado no    ³±±
±±³             ³        ³               ³periodo inteiro    						³±±
±±³Ricardo D.  ³19/12/15³TUCIXY		     ³Arredondamento no calculo de Vale Alimen- ³±±
±±³            ³        ³          		 ³tacao e Refeicao nas funcoes FVRFCALC e   ³±±
±±³            ³        ³          		 ³FVALCALC								    ³±±
±±³Eduardo F.  ³05/05/16³TUVDWU		     ³Ajuste para que na integração da rotina   ³±±
±±³            ³        ³          		 ³BEN não duplicar o valor.                 ³±±
±±³Raquel Hager³17/05/16³TUYLIQ		     ³Ajuste na função fValCalc p/ contabilizar ³±±
±±³            ³        ³          		 ³qualquer dia desde que seja trabalhado.   ³±±
±±³Allyson M.  ³23/06/16³TVJ289          ³Ajuste em fVlsAus() p/ guardar os dias de ³±±
±±³            ³        ³                ³ferias p/ gravacao correta no cabecalho   ³±±
±±³Gabriel A.  ³24/06/16³TVGZA5          ³Ajuste para zerar o valor da empresa      ³±±
±±³            ³        ³                ³quando o valor do benefício for zero.     ³±±
±±³Esther V.   ³27/06/16³	   TVIAMO    ³Ajuste na gravacao do campo R0_DIASPRO no ³±±
±±³            ³        ³          		 ³calculo de VR/VA quando há calculo propor-³±±
±±³            ³        ³          		 ³cional.									³±±
±±³Allyson M.  ³12/07/16³TURHSE          ³Ajuste p/ desconto do VT p/ verificar as  ³±±
±±³            ³        ³                ³verbas que serão somadas ao salário       ³±±
±±³Allyson M.  ³12/08/16³TURHSE          ³Ajuste p/ desconto do VT p/ verificar a   ³±±
±±³            ³        ³                ³garantia de comissão       				³±±
±±³Raquel Hager³12/08/16³TURHSE          ³Ajuste nas funções fCrgAutom e fCrgBenAut ³±±
±±³            ³        ³                ³para cálculo automático de Benefícios em  ³±±
±±³            ³        ³                ³ambiente com Gestão de Serviços para consi³±±
±±³            ³        ³                ³derar os dias de cálculo conforme cadastro³±±
±±³Allyson M.  ³20/09/16³TVYDXQ          ³Ajuste p/ verificar corretamente os bene- ³±±
±±³            ³        ³                ³fícios quando há integração com gestão de ³±±
±±³            ³        ³                ³serviços 									³±±
±±³Raquel Hager³27/09/16³TWCLU0          ³Realizado ajuste para pagamento devido da ³±±
±±³            ³        ³                ³parte empresa conforme configurações da   ³±±
±±³            ³        ³                ³definição de benefício.                   ³±±
±±³Claudinei S.³05/10/16³TVQFFA          ³Ajuste na função fAuxCre() para calcular o³±±
±±³            ³        ³                ³auxílio-creche com retenção de IR no novo ³±±
±±³            ³        ³                ³ID de cálculo 1414, conforme a tabela S015³±±
±±³Cícero Alves³19/10/16³TWGETX          ³Ajuste na função fVlsRGB para procurar as ³±±
±±³            ³        ³                ³faltas na RGB com o período do roteiro que³±±
±±³            ³        ³                ³está sendo executado						³±±
±±³Leandro Dr. ³01/12/16³98909           ³Ajuste para pagar todos os dias de VR e VA³±±
±±³            ³        ³                ³que estejam definidos no cadastro de perio³±±
±±³            ³        ³                ³do para ser pago, mesmo feriados.			³±±
±±³Renan Borges³05/12/16³MRH-2368        ³Ajuste para descontar faltas de acordo com³±±
±±³            ³        ³                ³Mnemonico P_BENBUSFA.                     ³±±
±±³Allyson M.  ³28/12/16³MRH-2534        ³Ajuste em fCargaRI1() p/ validar as datas ³±±
±±³            ³        ³                ³de inícios e fim corretamente.			³±±
±±³Allyson M.  ³28/12/16³MRH-3331        ³Ajuste em fVTRCalc() p/ sempre gravar o   ³±±
±±³            ³        ³                ³cálculo de VT.							³±±
±±³Raquel Hager³04/01/16³MRH-4035        ³Ajuste em fOtbCalc p/ validar Demissão do ³±±
±±³            ³        ³                ³funcionário no cálculo de Oturos Benef.	³±±
±±³Raquel Hager³19/01/16³MRH-5140        ³Ajuste em fVTRCalc p/ considerar qtde de  ³±±
±±³            ³        ³                ³vales por dia util no cálc. de Dif. VTR. e³±±
±±³            ³        ³                ³o valor já custeado pelo funcionário.   	³±±
±±³Renan Borges³19/01/16³MRH-5185		 ³Ajuste para não gerar error.log quando ca-³±±
±±³            ³        ³          		 ³lendário for sintético (MV_TPCALEN).      ³±±
±±³Allyson M.  ³20/01/17³MRH-825         ³Ajuste p/ considerar o ID 0242 p/ desconto³±±
±±³            ³        ³                ³das faltas e p/ não considerar os dias de	³±±
±±³            ³        ³                ³férias programadas se já considerou os das³±±
±±³            ³        ³                ³férias calculadas							³±±
±±³Cícero Alves³08/06/17³DRHPAG-2445	 ³Alteração na fVTRSal para considerar a	³±±
±±³            ³        ³                ³verba de salário horista quando lançada na³±±
±±³            ³        ³                ³RGB em vez dasa horas no cadastro de		³±±
±±³            ³        ³                ³funcionários								³±±
±±³Cecília C.  ³22/06/17³DRHPAG-3454     ³Alteração na fAuxCre para acessar o regis-³±±
±±³            ³        ³                ³tro da tabela S015 correta.               ³±±
±±³Cecília C.  ³04/07/17³DRHPAG-3753     ³Ajuste em fAuxCre para não ocorrer error.³±±
±±³            ³        ³                ³log em fPosTab e acessar a tabela S015 cor³±±
±±³            ³        ³                ³retamente.                                ³±±
±±³Cecília C.  ³28/07/17³DRHPAG-4463     ³Ajuste em para calcular VA/VR/VT não pro- ³±±
±±³            ³        ³                ³porcional quando utiliza calendário sinté-³±±
±±³            ³        ³                ³tico.                                     ³±±
±±³Esther V.   ³03/10/17³DRHPAG-6110     ³Verifica se funcionario está demitido no  ³±±
±±³            ³        ³                ³período de cálculo.                       ³±±
±±³Isabel N.   ³17/10/17³DRHPAG-6790     ³Ajuste no PE GPVTRDIAS.                   ³±±
±±³Jaqueline L ³15/12/17³DRHPAG-7346     ³Inclusão do PE GPM5001                    ³±±
±±³Jaqueline L ³15/12/17³DRHPAG-7670     ³Quando preenchido o R0_DPROPIN deverá ser ³±±
±±³            ³        ³  				 ³considerado ao invés do RFO_DIAFIX NO vr	³±±
±±³Jaqueline L ³20/12/17³DRHPAG-7941     ³Verifico se o funcionário é comissionado  ³±±
±±³            ³        ³  				 ³se for, atualizo o custo com base no 		³±±
±±³            ³        ³  				 ³RCE_GCOMIS do sindicato do funcionáio 	³±±
±±³Jaqueline L ³07/02/18³DRHPAG-12323    ³Quando preenchido o R0_DPROPIN deverá ser ³±±
±±³            ³        ³  				 ³considerado ao invés do RFO_DIAFIX no VA  ³±±
±±³Jaqueline L ³08/02/18³DRHPAG-12906    ³Correção para quando o R0_DPROPIN não est ³±±
±±³            ³        ³  				 ³iver preenchido e o dias fixo sim, manter ³±±
±±³            ³        ³  				 ³os dias fixo     							³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ fAssMed2 ºAutor  ³ Adilson Silva      º Data ³ 01/11/2009  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Novo Calculo da Assistencia Medica.                        º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ P11                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fAssmed2(aCodFol)

 // Valores de Desconto
 Local nMedTit  := 0
 Local nMedDep  := 0
 Local nMedAgr  := 0

 // Valores da Parte Empresa
 Local nEmprTit := 0
 Local nEmprDep := 0
 Local nEmprAgr := 0

 // Bases p/ Calculo
 Local nBaseTit := 0
 Local nBaseDep := 0
 Local nBaseAgr := 0

 // Percentuais de Calculo do Desconto
 Local nPercTit := 0
 Local nPercDep := 0
 Local nPercAgr := 0

 // Quantidades Processadas - Funcionario / Dependentes / Agregados
 Local nQdeTit  := 0
 Local nQdeDep  := 0
 Local nQdeAgr  := 0

 // Variaveis Totalizadoras
 Local nDesc    := 0
 Local nRef     := 0
 Local nEmpr    := 0

 // Verbas Utilizadas no Calculo
 Local cPdDescTit
 Local cPdDescDep
 Local cPdDescAgr
 Local cPdEmprTit
 Local cPdEmprDep
 Local cPdEmprAgr
 Local nBusca, cTab, nLinha

 Local aPdDescDep := {}
 Local nX := 0
 Local dDataCalc
 Local nUltDia
 Local cIdadeDesc    := SuperGetMv( "MV_PLSBASI",, "1" )

If !FP_CODFOL(@aCodFol,SRA->RA_FILIAL)
	Return
EndIf

cPdDescTit := aCodFol[049,1]		//-- Assistencia Medica
cPdDescDep := aCodFol[723,1]		//-- Desc.Ass.Medica Dependentes
cPdDescAgr := aCodFol[724,1]		//-- Desc.Ass.Medica Agregados
cPdEmprTit := aCodFol[213,1]		//-- Base parte Empresa Assist.Medica
cPdEmprDep := aCodFol[725,1]		//-- Base parte Empresa Ass.Medica Dependentes
cPdEmprAgr := aCodFol[726,1]		//-- Base parte Empresa Ass.Medica Agregados


 If aCodFol[49,1] # Space( 03 ) .And. SRA->RA_ASMEDIC # Space( 02 )
    If ( c__Roteiro == "RES" .And. ( cCompl # "S" .Or. ( cCompl == "S" .And. MesAno(GetMemVar("RG_DATADEM")) == MesAno(GetMemVar("RG_DTGERAR")) ) .And. aIncRes[11] == "S")) .Or. ;
       ( c__Roteiro == "FOL" .And. ( SRA->RA_TIPOPGT # "S" .Or. ( SRA->RA_TIPOPGT == "S" .And. lUltSemana)) )

	   // Busca salário mês correspondente
	   If (SRA->RA_CATFUNC = "H")
       		nBusca := SRA->RA_HRSMES * SRA->RA_SALARIO
       Else
	   		nBusca := SALMES
	   EndIf

       // Busca Tabela Relacionada
       cTab   := "S008"
       If SRA->RA_TIPAMED == "2"
          nBusca := Val( Left(cFolMes,4) ) - Year( SRA->RA_NASC )
          cTab   := "S009"
          If Month( SRA->RA_NASC ) >  Val( Right(cFolMes,2) ) .OR. ( cIdadeDesc == "2" .AND. ( Month( SRA->RA_NASC ) ==  Val( Right(cFolMes,2) )))
             nBusca--
          EndIf
       EndIf

       // Calculo da Assistencia Medica
       If ( nLinha := fPosTab(cTab,SRA->RA_ASMEDIC,"=",4,nBusca,"<=",6) ) > 0
          nBaseTit := fTabela(cTab,nLinha,7)
          nPercTit := fTabela(cTab,nLinha,10) / 100

          nMedTit  := nBaseTit * nPercTit

          nEmprTit := nBaseTit - nMedTit
          nQdeTit ++


          If lDissidio
           	 dDataCalc := dDatabase
          Else
             nUltDia:= f_UltDia(CToD("01"+"/"+Substr(cFolMes,5,2)+"/"+Substr(cFolMes,1,4)))   //Ultimo dia do Mes
		 	 dDataCalc:= CToD(StrZero(nUltDia,2)+"/"+Substr(cFolMes,5,2)+"/"+Substr(cFolMes,1,4))
          EndIf
          SRB->(dbSetOrder( 1 ))
          SRB->(dbSeek( SRA->(RA_FILIAL + RA_MAT) ))
          Do While !(SRB->(Eof())) .And. SRB->(RB_FILIAL + RB_MAT) == SRA->(RA_FILIAL + RA_MAT)
				If 	(!Empty(SRB->RB_DTINIAM) .or. !Empty(SRB->RB_DTFIMAM))

						If (!Empty(SRB->RB_DTINIAM) .and. dDataCalc < SRB->RB_DTINIAM) .or.;
						   (!Empty(SRB->RB_DTFIMAM) .and. dDataCalc > SRB->RB_DTFIMAM)
							SRB->(dbSkip())
							Loop
						EndIf
				EndIf

		   	If (cPaisLoc == "BRA")
		   		aAdd(aPdDescDep,{SRB->RB_VBDESAM,0,,1})
		   	EndIf


             // Busca Tabela Relacionada
             nBusca := SALMES
             cTab   := "S008"
             If SRB->RB_TIPAMED == "2"
                nBusca := Val( Left(cFolMes,4) ) - Year( SRB->RB_DTNASC )
                cTab   := "S009"
                If Month( SRB->RB_DTNASC ) >  Val( Right(cFolMes,2) ) .OR. ( cIdadeDesc == "2" .AND. ( Month( SRB->RB_DTNASC ) ==  Val( Right(cFolMes,2) )))
                   nBusca--
                EndIf
             EndIf

             // Calculo da Assistencia Medica
             If ( nLinha := fPosTab(cTab,SRB->RB_CODAMED,"=",4,nBusca,"<=",6) ) > 0
                nBaseDep := fTabela(cTab,nLinha,8)
                nBaseAgr := fTabela(cTab,nLinha,9)
                nPercDep := fTabela(cTab,nLinha,11) / 100
                nPercAgr := fTabela(cTab,nLinha,12) / 100

                If SRB->RB_TPDEPAM == "1"
	               If (cPaisLoc == "BRA")
	                   aPdDescDep[Len(aPdDescDep),2] := nBaseDep * nPercDep
	                   aPdDescDep[Len(aPdDescDep),3] := "1"	//significa que é Dependente
	               EndIf
                   nMedDep  += nBaseDep * nPercDep
                   nEmprDep += nBaseDep - ( nBaseDep * nPercDep )
                   nQdeDep ++
                ElseIf SRB->RB_TPDEPAM == "2"
                   If (cPaisLoc == "BRA")
	                   aPdDescDep[Len(aPdDescDep),2] := nBaseAgr * nPercAgr
	                   aPdDescDep[Len(aPdDescDep),3] := "2"	//significa que é Agregado
                   EndIf
                   nMedAgr  += nBaseAgr * nPercAgr
                   nEmprAgr += nBaseAgr - ( nBaseAgr * nPercAgr )
                   nQdeAgr ++
                EndIf
             EndIf

             SRB->(dbSkip())
          EndDo
       EndIf
    EndIf
 EndIf

 If nMedTit + nMedDep + nMedAgr + nEmprTit + nEmprDep + nEmprAgr > 0
	//Verificar se o valor calculado é superior ao limite para desconto.
	//Caso o valor seja superior, os valores de descontos serão alterados para atingir o Limite de Desconto.
	//A alteração será na seguinte ordem: 1- Agregado / 2- Dependente / 3- Titular

    nDesc += nMedTit
    nRef  += nQdeTit
    nEmpr += nEmprTit

    // Soma Desconto dos Dependentes Caso Nao Tenha Identificador Especifico Cadastrado
//    If Empty( cPdDescDep )
//       nDesc += nMedDep
//       nRef  += nQdeDep
//    EndIf

    // Soma Desconto dos Agregados Caso Nao Tenha Identificador Especifico Cadastrado
//    If Empty( cPdDescAgr )
//       nDesc += nMedAgr
//       nRef  += nQdeAgr
//    EndIf

    // Soma Parte Empresa dos Dependentes Caso Nao Tenha Identificador Especifico Cadastrado
    If Empty( cPdEmprDep )
       nEmpr += nEmprDep
    EndIf

    // Soma Parte Empresa dos Agregados Caso Nao Tenha Identificador Especifico Cadastrado
    If Empty( cPdEmprAgr )
       nEmpr += nEmprAgr
    EndIf

    // Grava Desconto
    If nDesc > 0
       If cPaisLoc == "BRA"
          If ! (( Ascan(aPd,{|X| X[1] == cPdDescTit .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
          		fGeraVerba(cPdDescTit,nDesc,nRef)
          EndIf
       Else
       		fGeraVerba(cPdDescTit,nDesc,nRef,,,,,,,,.T.)
       EndIf
    EndIf
    // Grava Parte Empresa
    If nEmpr > 0
	   If cPaisLoc == "BRA"
          If ! (( Ascan(aPd,{|X| X[1] == cPdEmprTit .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
          		fGeraVerba(cPdEmprTit,nEmpr)
          EndIf
       Else
	       fGeraVerba(cPdEmprTit,nEmpr,,,,,,,,,.T.)
	   EndIf
    EndIf
    If (cPaisLoc == "BRA")
	    // Grava Desconto dos Dependentes
	    If nMedDep > 0
			For nX := 1 to Len(aPdDescDep)
				If aPdDescDep[nX,3] == "1"	//significa que é Dependente
					If cPaisLoc == "BRA"
				          If ! (( Ascan(aPd,{|X| X[1] == aPdDescDep[nX,1] .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
				          		fGeraVerba(aPdDescDep[nX,1],aPdDescDep[nX,2],aPdDescDep[nX,4])
				          EndIf
			       	Else
					fGeraVerba(aPdDescDep[nX,1],aPdDescDep[nX,2],aPdDescDep[nX,4],,,,,,,,.T.)
					EndIf
		  		EndIf
	  		Next nX
	    EndIf
    EndIf
    // Grava Parte Empresa dos Dependentes
    If !Empty( cPdEmprDep ) .And. nEmprDep > 0
    	If cPaisLoc == "BRA"
			If ! (( Ascan(aPd,{|X| X[1] == cPdEmprDep .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
				fGeraVerba(cPdEmprDep,nEmprDep)
			EndIf
		Else
       		fGeraVerba(cPdEmprDep,nEmprDep,,,,,,,,,.T.)
       	EndIf
    EndIf
    If (cPaisLoc = "BRA")
	    // Grava Desconto dos Agregados
	    If nMedAgr > 0
			For nX := 1 to Len(aPdDescDep)
				If aPdDescDep[nX,3] == "2"	//significa que é Agregado
					If cPaisLoc == "BRA"
						If ! (( Ascan(aPd,{|X| X[1] == aPdDescDep[nX,1] .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
							fGeraVerba(aPdDescDep[nX,1],aPdDescDep[nX,2],aPdDescDep[nX,4])
						EndIf
					Else
					fGeraVerba(aPdDescDep[nX,1],aPdDescDep[nX,2],aPdDescDep[nX,4],,,,,,,,.T.)
					EndIf
		  		EndIf
	  		Next nX
	    EndIf
    EndIf
    // Grava Parte Empresa dos Agregados

    If !Empty( cPdEmprAgr ) .And. nEmprAgr > 0
    	If cPaisLoc == "BRA"
			If ! (( Ascan(aPd,{|X| X[1] == cPdEmprAgr .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
				fGeraVerba(cPdEmprAgr,nEmprAgr)
			EndIf
		Else
       		fGeraVerba(cPdEmprAgr,nEmprAgr,,,,,,,,,.T.)
       	EndIf
    EndIf
 EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ fAssOdon ºAutor  ³ Renata Bueno       º Data ³ 18/11/2009  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Calculo da Assistencia Odontologica.                       º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ P11                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fAssOdon(aCodfol)

 // Valores de Desconto
 Local nOdonTit := 0
 Local nOdonDep := 0
 Local nOdonAgr := 0

 // Valores da Parte Empresa
 Local nEmprTit := 0
 Local nEmprDep := 0
 Local nEmprAgr := 0

 // Bases p/ Calculo
 Local nBaseTit := 0
 Local nBaseDep := 0
 Local nBaseAgr := 0

 // Percentuais de Calculo do Desconto
 Local nPercTit := 0
 Local nPercDep := 0
 Local nPercAgr := 0

 // Quantidades Processadas - Funcionario / Dependentes / Agregados
 Local nQdeTit  := 0
 Local nQdeDep  := 0
 Local nQdeAgr  := 0

 // Variaveis Totalizadoras
 Local nDesc    := 0
 Local nRef     := 0
 Local nEmpr    := 0

 // Verbas Utilizadas no Calculo
 Local cPdDescTit := aCodFol[714,1]		//-- Desconto Assist.Odontologica Titular
 Local cPdEmprTit := aCodFol[717,1]		//-- Parte Empresa Assist.Odontologica Titular
 Local cPdEmprDep := aCodFol[718,1]		//-- Parte Empresa Assist.Odontologica Dependente
 Local cPdEmprAgr := aCodFol[719,1]		//-- Parte Empresa Assist.Odontologica Agregado

 Local dDataCalc
 Local nUltDia

 Local aPdDescDep := {}
 Local nX := 0
 Local nBusca, cTab, nLinha

 If aCodFol[49,1] # Space( 03 ) .And. SRA->RA_ASODONT # Space( 02 )
    If ( c__Roteiro == "RES" .And. ( cCompl # "S" .Or. ( cCompl == "S" .And. MesAno(GetMemVar("RG_DATADEM")) == MesAno(GetMemVar("RG_DTGERAR")) ) .And. aIncRes[11] == "S")) .Or. ;
       ( c__Roteiro == "FOL" .And. ( SRA->RA_TIPOPGT # "S" .Or. ( SRA->RA_TIPOPGT == "S" .And. lUltSemana)) )

       // Busca Tabela Relacionada
       nBusca := SALMES
       cTab   := "S013"
       If SRA->RA_TPASODO == "2"
          nBusca := Val( Left(cFolMes,4) ) - Year( SRA->RA_NASC )
          cTab   := "S014"
          If Month( SRA->RA_NASC ) > Val( Right(cFolMes,2) )
             nBusca--
          EndIf
       EndIf

       // Calculo da Assistencia Odontologica
       If ( nLinha := fPosTab(cTab,SRA->RA_ASODONT,"=",4,nBusca,"<=",6) ) > 0
          nBaseTit := fTabela(cTab,nLinha,7)
          nPercTit := fTabela(cTab,nLinha,10) / 100

          nOdonTit := nBaseTit * nPercTit
          nEmprTit := nBaseTit - nOdonTit
          nQdeTit ++


          If lDissidio
           	 dDataCalc := dDatabase
          Else
             nUltDia:= f_UltDia(CToD("01"+"/"+Substr(cFolMes,5,2)+"/"+Substr(cFolMes,1,4)))   //Ultimo dia do Mes
		 	 dDataCalc:= CToD(StrZero(nUltDia,2)+"/"+Substr(cFolMes,5,2)+"/"+Substr(cFolMes,1,4))
          EndIf
          SRB->(dbSetOrder( 1 ))
          SRB->(dbSeek( SRA->(RA_FILIAL + RA_MAT) ))
          Do While !(SRB->(Eof())) .And. SRB->(RB_FILIAL + RB_MAT) == SRA->(RA_FILIAL + RA_MAT)
				If 	(!Empty(SRB->RB_DTINIAO) .or. !Empty(SRB->RB_DTFIMAO))

					If (!Empty(SRB->RB_DTINIAO) .and. dDataCalc < SRB->RB_DTINIAO) .or.;
						(!Empty(SRB->RB_DTFIMAO) .and. dDataCalc > SRB->RB_DTFIMAO)
		            SRB->(dbSkip())
						Loop
					EndIf
				EndIf

			    If(cPaisLoc == "BRA")
					aAdd(aPdDescDep,{SRB->RB_VBDESAO,0,,1})
                EndIf

             // Busca Tabela Relacionada
             nBusca := SALMES
             cTab   := "S013"
             If SRB->RB_TPASODO == "2"
                nBusca := Val( Left(cFolMes,4) ) - Year( SRB->RB_DTNASC )
                cTab   := "S014"
                If Month( SRB->RB_DTNASC ) > Val( Right(cFolMes,2) )
                   nBusca--
                EndIf
             EndIf

             // Calculo da Assistencia Odontologica
             If ( nLinha := fPosTab(cTab,SRB->RB_ASODONT,"=",4,nBusca,"<=",6) ) > 0
                nBaseDep := fTabela(cTab,nLinha,8)
                nBaseAgr := fTabela(cTab,nLinha,9)
                nPercDep := fTabela(cTab,nLinha,11) / 100
                nPercAgr := fTabela(cTab,nLinha,12) / 100

                If SRB->RB_TPDPODO == "1"
                	If(cPaisLoc == "BRA")
	                   aPdDescDep[Len(aPdDescDep),2] := nBaseDep * nPercDep
	                   aPdDescDep[Len(aPdDescDep),3] := "1"	//significa que é Dependente
	                EndIf
                   nOdonDep += nBaseDep * nPercDep
                   nEmprDep += nBaseDep - ( nBaseDep * nPercDep )
                   nQdeDep ++
                ElseIf SRB->RB_TPDPODO == "2"
                	If(cPaisLoc == "BRA")
	                   aPdDescDep[Len(aPdDescDep),2] := nBaseAgr * nPercAgr
	                   aPdDescDep[Len(aPdDescDep),3] := "2"	//significa que é Agregado
                    EndIf
                   nOdonAgr += nBaseAgr * nPercAgr
                   nEmprAgr += nBaseAgr - ( nBaseAgr * nPercAgr )
                   nQdeAgr ++
                EndIf
             EndIf

             SRB->(dbSkip())
          EndDo
       EndIf
    EndIf
 EndIf

 If nOdonTit + nOdonDep + nOdonAgr + nEmprTit + nEmprDep + nEmprAgr > 0
	/*Verificar se o valor calculado é superior ao limite para desconto.
	 Caso o valor seja superior, os valores de descontos serão alterados para atingir o Limite de Desconto.
	 A alteração será na seguinte ordem: 1- Agregado / 2- Dependente / 3- Titular	*/

    nDesc += nOdonTit
    nRef  += nQdeTit
    nEmpr += nEmprTit

    // Soma Parte Empresa dos Dependentes Caso Nao Tenha Identificador Especifico Cadastrado
    If Empty( cPdEmprDep )
       nEmpr += nEmprDep
    EndIf

    // Soma Parte Empresa dos Agregados Caso Nao Tenha Identificador Especifico Cadastrado
    If Empty( cPdEmprAgr )
       nEmpr += nEmprAgr
    EndIf

    // Grava Desconto
    If nDesc > 0
    	If cPaisLoc == "BRA"
			If ! (( Ascan(aPd,{|X| X[1] == cPdDescTit .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
				fGeraVerba(cPdDescTit,nDesc,nRef)
			EndIf
		Else
	       fGeraVerba(cPdDescTit,nDesc,nRef,,,,,,,,.T.)
	    EndIf
    EndIf
    // Grava Parte Empresa
    If nEmpr > 0
    	If cPaisLoc == "BRA"
			If ! (( Ascan(aPd,{|X| X[1] == cPdEmprTit .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
				fGeraVerba(cPdEmprTit,nEmpr)
			EndIf
		Else
	       fGeraVerba(cPdEmprTit,nEmpr,,,,,,,,,.T.)
	    EndIf
    EndIf
    If(cPaisLoc = "BRA")
	    // Grava Desconto dos Dependentes
	    If nOdonDep > 0
			For nX := 1 to Len(aPdDescDep)
				If aPdDescDep[nX,3] == "1"	//significa que é Dependente
					If cPaisLoc == "BRA"
						If ! (( Ascan(aPd,{|X| X[1] == aPdDescDep[nX,1] .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
								fGeraVerba(aPdDescDep[nX,1],aPdDescDep[nX,2],aPdDescDep[nX,4])
						EndIf
					Else
					fGeraVerba(aPdDescDep[nX,1],aPdDescDep[nX,2],aPdDescDep[nX,4],,,,,,,,.T.)
					EndIf
		  		EndIf
	  		Next nX
	    EndIf
    EndIf
    // Grava Parte Empresa dos Dependentes
    If !Empty( cPdEmprDep ) .And. nEmprDep > 0
    	If cPaisLoc == "BRA"
			If ! (( Ascan(aPd,{|X| X[1] == cPdEmprDep .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
					fGeraVerba(cPdEmprDep,nEmprDep)
			EndIf
		Else
	       fGeraVerba(cPdEmprDep,nEmprDep,,,,,,,,,.T.)
	    EndIf
    EndIf
    If (cPaisLoc == "BRA")
	    // Grava Desconto dos Agregados
	    If nOdonAgr > 0
			For nX := 1 to Len(aPdDescDep)
				If aPdDescDep[nX,3] == "2"	//significa que é Agregado
					If cPaisLoc == "BRA"
						If ! (( Ascan(aPd,{|X| X[1] == aPdDescDep[nX,1] .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
								fGeraVerba(aPdDescDep[nX,1],aPdDescDep[nX,2],aPdDescDep[nX,4])
						EndIf
					Else
					fGeraVerba(aPdDescDep[nX,1],aPdDescDep[nX,2],aPdDescDep[nX,4],,,,,,,,.T.)
					EndIf
		  		EndIf
	  		Next nX
	    EndIf
    EndIf
    // Grava Parte Empresa dos Agregados
    If !Empty( cPdEmprAgr ) .And. nEmprAgr > 0
    	If cPaisLoc == "BRA"
			If ! (( Ascan(aPd,{|X| X[1] == cPdEmprAgr .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
					fGeraVerba(cPdEmprAgr,nEmprAgr)
			EndIf
		Else
	       fGeraVerba(cPdEmprAgr,nEmprAgr,,,,,,,,,.T.)
	    EndIf
    EndIf
 EndIf

Return


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fAuxCre   ºAutor  ³ Renata Elena       º Data ³ 30/11/2009  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Calculo do Auxilio Creche                                  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ P11                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function fAuxCre(aCodfol,cPdMes)

Local cPdMeIsIr	:= If(Len(aCodFol) > 1413, aCodFol[1414,1], "")
Local dDtRef   	:= StoD( cAnoMes + "01" )
Local nValBase	:= 0
Local nValCre   := 0
Local nValCrIsIR:= 0 	//Valor do Auxilio com a isenção de IR
Local nQdeDep  	:= 0
Local nQdeDeIsIR:= 0 	//Quantidade de Dependentes com isenção de IR
Local nPerc		:= 100
Local nPercIsIr	:= 100	// Percentual da verba com isenção de IR
Local lValorDep	:= .F. // Se o valor do Auxílio-Creche a ser considerado será o valor informado no cad. de dependentes.
Local lIsIR		:= .F.
Local nBusca, cTab, nLinha
Local nSizeSin := TamSX3("RA_SINDICA")[1]

nPerc		:= RetValSRV(cPdMes,SRA->RA_FILIAL,"RV_PERC") /100
nPercIsIr	:= RetValSRV(cPdMeIsIr,SRA->RA_FILIAL,"RV_PERC") /100

SRB->(dbSetOrder( 1 ))
SRB->(dbSeek( SRA->(RA_FILIAL + RA_MAT) ))

Do While !(SRB->(Eof())) .And. SRB->(RB_FILIAL + RB_MAT) == SRA->(RA_FILIAL + RA_MAT)

	If !(SRB->RB_AUXCRE == "1") .or. ( !Empty(SRB->RB_DTBAIXA) .and. AnoMes(SRB->RB_DTBAIXA) <= cAnoMes)
		SRB->(dbSkip())
		Loop
	Else

		If Empty(cPdMes)
			CMSGLOG := FMSGFORM({19}) + " -> 0721 - " + aCodFol[721,2] //"Nao existe verba cadastrada para identificador de calculo "
			S_MSGLOG()
			FINALCALC()
			Return()
		EndIf

		If SRB->RB_VLRCRE > 0
			lValorDep := .T.
    	Else
    		lValorDep := .F.
    	Endif
    	// Busca Tabela Relacionada
		nBusca :=  DateDiffMonth( dDtRef , SRB->RB_DTNASC )
		cTab   := "S015"
		dDataRef	:= dDataBase

		If !lValorDep
			//verifica se dados para o sindicato mes / ano / filial
			nLinha := fPosTab(cTab,SRA->RA_SINDICA,"==",4 ,,,,,,,,SRA->RA_FILIAL,,,,dDtRef) //filial+mes/ano+sindicato (preenchidos)
			If nLinha == 0
			     nLinha := fPosTab(cTab,SRA->RA_SINDICA,"==",4 ,,,,,,,,SRA->RA_FILIAL,,,,Ctod("  /  /    ")) //filial+sindicato (preenchidos)
			EndIf
			If nLinha == 0
			    nLinha := fPosTab(cTab,SRA->RA_SINDICA,"==",4 ,,,,,,,,Space(FWGetTamFilial),,,,dDtRef) //mes/ano+sindicato (preenchidos)
			EndIf
			If nLinha == 0
			    nLinha := fPosTab(cTab,SRA->RA_SINDICA,"==",4 ,,,,,,,,Space(FWGetTamFilial),,,,Ctod("  /  /    ")) //sindicato (preenchido)
			EndIf
			If nLinha == 0
			    nLinha := fPosTab(cTab,Space(nSizeSin),"==",4 ,,,,,,,,Space(FWGetTamFilial),,,,Ctod("  /  /    ")) //filial+mes/ano+sindicato (em branco)
			EndIf

			If nLinha > 0
				//so depois verifica os meses que tem direito para não mostrar msg indevidamente, pq se o dependente não tem mais direito não preciso mostrar msg
				nLinha := fPosTab(cTab,SRA->RA_SINDICA,"==",4 ,nBusca,"<=",5,,,,,SRA->RA_FILIAL,nBusca,">=",7,dDtRef) //filial+mes/ano+sindicato (preenchidos)
				If nLinha == 0
				     nLinha := fPosTab(cTab,SRA->RA_SINDICA,"==",4 ,nBusca,"<=",5,,,,,SRA->RA_FILIAL,nBusca,">=",7,Ctod("  /  /    ")) //filial+sindicato (preenchidos)
				EndIf
				If nLinha == 0
				    nLinha := fPosTab(cTab,SRA->RA_SINDICA,"==",4 ,nBusca,"<=",5,,,,,Space(FWGetTamFilial),nBusca,">=",7,dDtRef) //mes/ano+sindicato (preenchidos)
				EndIf
				If nLinha == 0
				    nLinha := fPosTab(cTab,SRA->RA_SINDICA,"==",4 ,nBusca,"<=",5,,,,,Space(FWGetTamFilial),nBusca,">=",7,Ctod("  /  /    ")) //sindicato (preenchido)
				EndIf
				If nLinha == 0
				    nLinha := fPosTab(cTab,Space(nSizeSin),"==",4 ,nBusca,"<=",5,,,,,Space(FWGetTamFilial),nBusca,">=",7,Ctod("  /  /    ")) //filial+mes/ano+sindicato (em branco)
				EndIf

				If nLinha > 0
					nValBase := fTabela(cTab,nLinha,6)
					lIsIR	 := fTabela(cTab,nLinha,8) == "N"
				EndIf
			Else
				CMSGLOG := FMSGFORM({40}) + " S015 para o Sindicato: " + SRA->RA_SINDICA  //"Não existem dados cadastrados na Tabela  "
				S_MSGLOG()
			EndIf
		Else
			nValBase := SRB->RB_VLRCRE
		EndIf

		If nValBase > 0
			If !lIsIR
	  			nValCre  += (nValBase * If(nPerc == 0, 1, nPerc) )
	  			nQdeDep ++
	  		Else
	  			nValCrIsIR += (nValBase * If(nPercIsIr == 0, 1, nPercIsIr) )
	  			nQdeDeIsIR ++
	  		EndIf
	  	EndIf
	EndIf

	SRB->(dbSkip())
EndDo

If nValCre > 0 .Or. nValCrIsIR > 0
	If cPaisLoc == "BRA"
 		If ! (( Ascan(aPd,{|X| X[1] == cPdMes .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
      		fGeraVerba(cPdMes,nValCre,nQdeDep)
       EndIf
		IF ! (( Ascan(aPd,{|X| X[1] == cPdMeIsIr .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
      		fGeraVerba(cPdMeIsIr,nValCrIsIR,nQdeDeIsIR)
       Endif
   	Else
   		fGeraVerba(cPdMes,nValCre,nQdeDep,,,,,,,,.T.)
   	EndIf
EndIf

Return
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ FornVld  ºAutor  ³ Adrianne Furtado   º Data ³ 11/11/2010  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Validacao de Fornedores na Configuração de Ass Medica/Odontº±±
±±º          ³ modelo 2                                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ P10                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FornVld(cCodTab)
Local lRet := .F.
Local nPosIni := 1
Local nLenCod
Local nOrdem
Local nX := 1

Local cVar		:= Alltrim(ReadVar())
Local cFOrigem := ""

Local oModel
Local oStructRHX
Local cTpForn

If cVar == "M->RB_CODAMED" .or. cVar == "SRB->RB_CODAMED" // DEPENDENTES ASSISTENCIA MEDICA
	cFOrigem := xFilial("SRB")
ElseIf cVar == "M->RB_ASODONT" .or. cVar == "SRB->RB_ASODONT" // DEPENDENTES ASSISTENCIA ODONTOLOGICA
	cFOrigem := xFilial("SRB")
ElseIf __READVAR == "M->CODFOR"           //CONSULTA F3 A PARTIR DE UMA TABELA SNNN
	cFOrigem := aCols[n][1]
	If cCodTab == "S074"
		cTpForn := aCols[n][5]
		If cTpForn == "1"
			cCodTab := "S016"
		Else
			cCodTab := "S017"
		EndIf
	Endif
ElseIf cVar $ "M->RHK_CODFOR/M->RHL_CODFOR/M->RHM_CODFOR/M->RHN_CODFOR/M->RHO_CODFOR/M->JX_CODFORN"
	oModel 		:= FWModelActive()

	If cVar == "M->RHK_CODFOR"
		oStructRHX	:= oModel:GetModel( "GPEA001_MRHK" )
		cTpForn		:= oStructRHX:GetValue("RHK_TPFORN")
	ElseIf cVar == "M->RHL_CODFOR"
		oStructRHX	:= oModel:GetModel( "GPEA001_MRHL" )
		cTpForn		:= oStructRHX:GetValue("RHL_TPFORN")
	ElseIf cVar == "M->RHM_CODFOR"
		oStructRHX	:= oModel:GetModel( "GPEA001_MRHM" )
		cTpForn		:= oStructRHX:GetValue("RHM_TPFORN")
	ElseIf cVar == "M->RHN_CODFOR"
		oStructRHX	:= oModel:GetModel( "GPEA002_MRHN" )
	  	cTpForn		:= oStructRHX:GetValue("RHN_TPFORN")
	ElseIf cVar == "M->RHO_CODFOR"
		oStructRHX	:= oModel:GetModel( "GPEA003_MRHO" )
	  	cTpForn		:= oStructRHX:GetValue("RHO_TPFORN")
	ElseIf cVar == "M->JX_CODFORN"
		oStructSJX	:= oModel:GetModel( "GPEA063_MSJX" )
		cTpForn := oStructSJX:GetValue("JX_TPFORN")
	EndIf

	If FunName() = "GPEA063"
		cFOrigem := xFilial("SJX")
	Else
		cFOrigem := xFilial("SRA")
	EndIf

	If cTpForn == "1"
		cCodTab := "S016"
	ElseIf cTpForn == "2"
		cCodTab := "S017"
	EndIf

	M->CODFOR := &(cVar)
EndIf

RCB->(dbSetOrder(3))
RCB->(dbSeek(xFilial("RCB")+"CODIGO    "+cCodTab))

nLenCod := RCB->RCB_TAMAN
nOrdem := Val(RCB->RCB_ORDEM)

RCB->(dbSetOrder(1))
RCB->(dbSeek(xFilial("RCB")+cCodTab))

While nX < nOrdem .and. RCB->RCB_CODIGO == cCodTab

	If Val(RCB->RCB_ORDEM) < nOrdem
		nPosIni += RCB->RCB_TAMAN
		nX ++
	EndIf
	RCB->(DbSkip())
EndDo

RCC->(dbSetOrder(1))

If RCC->(dbSeek(xFilial("RCC")+cCodTab))
	While RCC->RCC_CODIGO == cCodTab .and. !lRet
		If M->CODFOR == SubStr(RCC->RCC_CONTEU,nPosIni,nLenCod) .and.;
			(Empty(RCC->RCC_FIL) .or. RCC->RCC_FIL == cFOrigem)
			lRet := .T.
		EndIf
		RCC->(DbSkip())
	EndDo
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fCarDiasMes    ºAutor  ³Leandro Drumond  º Data ³  24/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Carrega dados dos beneficios                                  º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCarDiasMes(aDias, lPropAdm, aPeriod)

	Local nX 			:= 0
	Local lCalc			:= .F.
	Local cTipo			:= "3"
	Local cVale			:= ""
	Local cMotivo		:= ""
	Local dBkpFim		:= cToD("//")
	Local dIni			:= ctod("")
	Local dFim			:= ctod("")
	Local lAdd			:= .T.
	Local aTabCalend	:= {}
	Local lPropFerias	:= .F. //APERGUNTE[4, 3] == 1
	Local lFeriado		:= .F.

	DEFAULT aPeriod := aPeriodo
	DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

	If Len(aPeriod) < 1
		If __lMemCalc
			fAddMemLog("Período não carregado" ,1,1)
		EndIf
		Return(Nil)
	EndIf

	If cTipoRot == "8"
		cTipo 		:= "0"
		lPropFerias	:= APERGUNTE[4,3] == 1	// Se calcula proporcional a férias programadas
	ElseIf cTipoRot $ "D*E"
		cTipo		:= If(cTipoRot == "D", "1", "2" )
		lPropFerias	:= APERGUNTE[3,3] == 1	// Se calcula proporcional a férias programadas
	EndIf

	If SRA->RA_TPCONTR == "2" .And. !Empty(SRA->RA_DTFIMCT)
		dBkpFim				:= aPeriod[nPosSem, 4]
		aPeriod[nPosSem, 4] := Min( SRA->RA_DTFIMCT, aPeriod[nPosSem, 4] )
	EndIf

	If LNOVOCALCB
		dIni		:=  aPeriod[nPosSem, 3]
		dFim		:=  aPeriod[nPosSem, 4]
	EndIf

	If __lMemCalc
		fAddMemLog("Proporcional a férias : " + If(lPropFerias,"Sim","Não") ,1,1)
		fAddMemLog("Proporcional a admissão : " + If(LPROPADM,"Sim","Não") ,1,1)
		fAddMemLog("Data Admissão : " + dtoc(SRA->RA_ADMISSA)  ,1,1)
		fAddMemLog("Periodo de Calculo : " + dtoc(dIni) + " a " + dtoc(dFim) ,1,1)
		fAddMemLog("Calendario utilizado(MV_USACPER) : " +If(lUsaCPer,"FOLHA","PONTO") ,1,1)
	EndIf

	aDias := {}

	// Se utilizar o calendário do ponto carrega o aDias com base nesse calendário
	If !lUsaCPer
		aTabCalend := fCarPonto(aPeriod,lPropAdm)
		If Len(aTabCalend) > 1
			SPA->( dbSeek( xFilial("SPA", SRA->RA_FILIAL ) + SRA->RA_REGRA ) )
			lFeriado := ( SPA->PA_FERIADO == "S" .Or. ( SPA->( Type("PA_RECBENF") ) != "U" .And. SPA->PA_RECBENF == "1" ) )
			aEval( aTabCalend, { |x| If( If( lPropFerias, (Empty(dDataDem) .Or. x[1] < dDataDem) .And. ((( x[6] == "S" .And. ( x[19] == .F. .or. x[10] == "E" ) ) .Or. ( lFeriado .And. (( x[6] == "F" .And. x[24] == .F. .And. x[36] == "S") .Or. ( x[6] == "S" .And. x[24] == .F. .And. x[36] == "S" .And. x[19] == .T.))))), (Empty(dDataDem) .OR. x[1] < dDataDem) .AND.((( ( x[6] == "S" .And. x[19] == .F. ) .Or. ( lFeriado .And. ( (x[6] == "F" .And. x[24] == .F. .And. x[36] == "S" ) .Or. (x[6] == "S" .And. x[24] == .F. .And. x[36] == "S" .And. x[19] == .T.)))) ) .Or. ( x[6] == "N" .And. x[19] == .F. .And. x[24] == .T. .And. x[36] == "S" ) )), aAdd( aDias, { x[1], If(x[6] == "S","1",""), "1", .T., "" }), aAdd( aDias, { x[1], If(x[6] == "S","1",""), "1", .F., "" })) } )
		EndIf
		If __lMemCalc
			If !Empty(dDataDem)
				fAddMemLog("Data de demissão : " + dtoc(dDataDem) ,1,1)
				fAddMemLog("Considera feriado cadastro de Regra(SPA) : " + If(lFeriado,"Sim","Não") ,1,1)
			EndIf
		EndIf
		// Proporcionaliza a admissão
		If lPropAdm .Or. SRA->RA_ADMISSA > aPeriod[nPosSem, 4]
			For nX := 1 To Len(aDias)
				If (SRA->RA_ADMISSA > aDias[nX][1])
					aDias[nX][4] := .F.
					aDias[nX][5] := "ADM"
				EndIf
			Next
		EndIf

		// Dias de referência
		If(Empty(nDiasRef), aEval( aDias, {|x| If( x[4], nDiasRef++, Nil ) }), Nil)

		Return (aDias)
	EndIf

	For nX := 1 to Len(aPeriod[1][5])
		lAdd := .T.
		If LNOVOCALCB .And. ! (aPeriod[1][5][nX][1] >= dIni .And. aPeriod[1][5][nX][1] <= dFim )
			lAdd := .F.
		EndIf

		If lAdd
			lCalc	:= .T.
			cMotivo	:= ""

			If cTipo = "0"  //Vale Transporte
				cVale := aPeriod[1][5][nX][3]
			ElseIf cTipo = "1" //Vale Refeição
				cVale := aPeriod[1][5][nX][5]
			ElseIf cTipo = "2" //Vale Alimentação
				cVale := aPeriod[1][5][nX][8]
			Else //Outros beneficios
				cVale := "1"
			Endif
			lCalc := cVale == "1"

			If lPropAdm .And. (SRA->RA_ADMISSA > aPeriod[1][5][nX][1])
				lCalc := .F.
				cMotivo  := "ADM"
			EndIf

			aAdd( aDias, { aPeriod[nPosSem][5][nX][1], aPeriod[nPosSem][5][nX][2], cVale, lCalc, cMotivo })
		EndIf
	Next nX

	// Dias de Referência
	If(Empty(nDiasRef), aEval( aDias, {|x| If( x[4], nDiasRef++, Nil ) }), Nil)

	If SRA->RA_TPCONTR == "2" .And. !Empty(SRA->RA_DTFIMCT)
		aPeriod[nPosSem, 4] := dBkpFim
	EndIf

Return (aDias)


//-------------------------------------------------------------------
/*/{Protheus.doc} function RHOTPATEN
Retorna os tipos de Atendimentos disponíveis na rotina de Co-participação e Reembolso. Usado no ComboBox de Cadastro.
@author  Hugo de Oliveira
@since   04/04/2019


@version 12.1.23
/*/
//-------------------------------------------------------------------
Function RHOTPATEN()
	Local cOpcBox := "1=Eletivo;2=PS;3=Exame;4=PAC;5=Material/Medicamento;6=Internação;7=Terapia;8=Taxa/Diária;9=Case;10=Reembolso;11=Remoção;12=Não Informado;13=Ambulatorio"
Return(cOpcBox)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fCarPonto    ºAutor  ³Leandro Drumond  º Data ³  24/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Carrega dados dos beneficios                                  º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCarPonto(aPeriod,lPropAdm)
Local dIni		:= CtoD("")
Local dFim		:= CtoD("")
Local aTabPadrao:= {}
Local aTurnos	:= {}
Local aTabCalend:= {}
Local lPropAfast:= .T.
Local lPropFER	:= .T.

Static _aTabAux	:= {}
Static __cFunTab:= ""

DEFAULT aPeriod  := aPeriodo
DEFAULT lPropAdm := If(CTIPOROT == "8",APERGUNTE[2,3] == 1, If(cTipoRot $ "D*E",APERGUNTE[1,3] == 1,.F.))

If cTipoRot == "8"
	lPropAfast 	:= (APERGUNTE[3, 3] == 1 .Or. APERGUNTE[3, 3] == 4)
	lPropFER 	:= (APERGUNTE[3, 3] == 1 .Or. APERGUNTE[3, 3] == 3)
ElseIf cTipoRot $ "D*E"
	lPropAfast 	:= (APERGUNTE[2, 3] == 1 .Or. APERGUNTE[2, 3] == 4)
	lPropFER 	:= (APERGUNTE[2, 3] == 1 .Or. APERGUNTE[2, 3] == 3)
EndIf

dIni		:=  aPeriod[nPosSem,3]
dFim		:=  aPeriod[nPosSem,4]

If LNOVOCALCB
	If cTipoRot == "8" .And. aPergunte[1,3] == 3
		dIni :=  aPergunte[12, 3]
		dFim :=  aPergunte[13, 3]
	ElseIf cTipoRot $ "D*E" .And. aPergunte[6,3] == 1
		dIni :=  aPergunte[8, 3]
		dFim :=  aPergunte[9, 3]
	EndIf
EndIf

//Tratamento para performance
If __cFunTab <> SRA->RA_FILIAL + SRA->RA_MAT
	_aTabAux := {}
EndIf

//Carrega apenas se já não tiver sido carregado
If Empty(_aTabAux) .or. _aTabAux[1,1] > dFim .or. _aTabAux[Len(_aTabAux)][1] < dFim

	CriaCalend(		dIni 			,;	//01 -> Data Inicial do Periodo
					dFim			,;	//02 -> Data Final do Periodo
					SRA->RA_TNOTRAB	,;	//03 -> Turno Para a Montagem do Calendario
					SRA->RA_SEQTURN	,;	//04 -> Sequencia Inicial para a Montagem Calendario
					@aTabPadrao		,;	//05 -> Array Tabela de Horario Padrao
					@_aTabAux		,;	//06 -> Array com o Calendario de Marcacoes
					SRA->RA_FILIAL  ,;	//07 -> Filial para a Montagem da Tabela de Horario
					SRA->RA_MAT   	,;	//08 -> Matricula para a Montagem da Tabela de Horario
					SRA->RA_CC   	,;	//09 -> Centro de Custo para a Montagem da Tabela
					@aTurnos		,;	//10 -> Array com as Trocas de Turno
					NIL				,;	//11 -> Array com Todas as Excecoes do Periodo
					NIL				,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
					.T.				,;	//13 -> Se executa a funcao se sincronismo do calendario (Default .T.)
					.T.			 	;	//14 -> Se Forca a Criacao de Novo Calendario
					)

	__cFunTab := SRA->RA_FILIAL + SRA->RA_MAT
	
EndIf

aEval( _aTabAux, { |x| If( x[4] == "1E" .and. x[1] >= dIni .and. x[1] <= dFim, aAdd( aTabCalend, aClone(x) ), Nil)  } )

If lPropAdm
	aEval(aTabCalend,{ |x| if(x[1] < SRA->RA_ADMISSA, x[6]:= "N",nil)})
EndIf

If !lPropAfast
	aEval(aTabCalend, { |x| if(x[24] .and. x[25] == "A", ( x[6] := x[36], x[24] := .F.), nil)})
EndIf

If !lPropFER
	aEval(aTabCalend, { |x| if(x[24] .and. x[25] == "F", ( x[6] := x[36], x[24] := .F.), nil)})
EndIf

Return (aTabCalend)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fVlsAus		   ºAutor  ³Leandro Drumond  º Data ³  24/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Verifica ausencias para pagamento de beneficios               º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVlsAus(dDtPesq1, dDtPesq2, aAfast, aDiasMes)
Local aArea		:= GetArea()
Local cTipoAfas	:= ""
Local dDataAux	:= CtoD("")
Local dDataAux2	:= CtoD("")
Local nAfas		:= 0
Local nLenAfa 	:= 0
Local nX		:= 0
Local nY		:= 0
Local nAfaFer	:= If(cTipoRot == "I", 0, If(cTipoRot == '8', aPergunte[3,3], aPergunte[2,3]))

DEFAULT dDtPesq1 	:= aPeriodo[nPosSem,3] //Data inicial do periodo de calculo
DEFAULT dDtPesq2 	:= aPeriodo[nPosSem,4] //Data final do periodo de calculo
DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

aAfast 		:= {}
nDiasAfas 	:= 0
nFerVen		:= 0
DIASTRAB	:= 0

// -- Apura Dias Trabalhados
fDiasTrab(@DIASTRAB)

If nAfaFer <> 1
	cTipoAfas := If(nAfaFer == 3, '4','123')
EndIf
// -- Apura Dias Trabalhados e Dias de Afastamento
fDiasAfast(@nAfas,@DIASTRAB,dDataBase,,,cTipoAfas)

DIASTRAB	:= Max( ( DIASTRAB  + nDiasMat + nDPrgSalMa ) , 0 )

fRetAfas(dDtPesq1, dDtPesq2 , , , ,cTipoAfas, @aAfast,,,,,,,,,.F.)

If __lMemCalc
	fAddMemLog("Periodo de Calculo : " + dtoc(dDtPesq1) + " a " + dtoc(dDtPesq2) ,1,1)
	fAddMemLog("Dias trabalhados: " + cvaltochar(DIASTRAB) ,1,1)
	fAddMemLog("Dias afastados: " + cvaltochar(nAfas) ,1,1)
	fAddMemLog("Dias maternidade: " + cvaltochar(nDiasMat + nDPrgSalMa) ,1,1)
EndIf

If !Empty(aAfast)
	nLenAfa := Len(aAfast)
	If Len(aDiasMes) > 0
		For nX := 1 to nLenAfa
			dDataAux  := aAfast[nX,3]
			dDataAux2 := aAfast[nX,4]
			If ( !Empty(dDataAux2) .And. aDiasMes[1,1] > dDataAux2 ) .Or. aDiasMes[Len(aDiasMes),1] < dDataAux
				Loop
			EndIf
			For nY := 1 to Len(aDiasMes)
				If aDiasMes[nY,1] >= dDataAux .and. ( aDiasMes[nY,1] <= dDataAux2 .OR. Empty(dDataAux2))
					aDiasMes[nY,4] := .F.
					If aAfast[nX,5] == "A"
						aDiasMes[nY,5] := "AFA"
						nDiasAfas++
					ElseIf aAfast[nX,5] == "F"
						aDiasMes[nY,5] := "FER"
						nFerVen++
					EndIf
				EndIf
			Next nY
		Next nX
	EndIf
EndIf
RestArea(aArea)

Return Nil

/*/{Protheus.doc} fVlsFerPrg
Verifica ferias programadas para pagamento de beneficios
@author Leandro Drumond
@since 24/07/2013
@param dDtPesq1, date, Data para o início da pesquisa
@param dDtPesq2, date, Data para o Fim da Pesquisa
@param aDiasMes, array, Array com os dias do mes
@example
	fVlsFerPrg(cTod("01/09/2017"), cTod("30/09/2017"), @aDiasMes)
/*/
Function fVlsFerPrg(dDtPesq1, dDtPesq2, aDiasMes, lBusca)

	Local aArea		:= GetArea()
	Local cMesAno	:= ""
	Local dDataAux	:= CtoD("")
	Local dDataAux2	:= CtoD("")
	Local nDiasFer	:= 0
	Local nPos		:= 0
	Local nY		:= 0

	Default dDtPesq1	:= aPeriodo[nPosSem,3]	// Data inicial do periodo de calculo
	Default dDtPesq2	:= aPeriodo[nPosSem,4]	// Data final do periodo de calculo
	Default lBusca		:= .F.					// Apenas realiza a busca, não atualiza o mnemônico nFerVen
	DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

	DbSelectArea("SRF")
	DbSetOrder(1)

	If DbSeek( xFilial("SRF") + SRA->RA_MAT )
		cMesAno := MesAno(dDtPesq1)
		While SRF->( ! Eof() .and. RF_FILIAL + RF_MAT == xFilial("SRF") + SRA->RA_MAT )
			If SRF->RF_STATUS = "1"		//Ativo
				If __lMemCalc
					fAddMemLog("Periodo de férias ativo : " + dtoc(SRF->RF_DATABAS) + " a " + dtoc(SRF->RF_DATAFIM) ,1,1)
				EndIf
				dDataAux := CtoD("")
				If MesAno(SRF->RF_DATAINI) == cMesAno .And. SRF->RF_DATAINI <= dDtPesq2
					dDataAux := SRF->RF_DATAINI
					nDiasFer := SRF->RF_DFEPRO1
				ElseIf MesAno(SRF->RF_DATINI2) == cMesAno .And. SRF->RF_DATINI2 <= dDtPesq2
					dDataAux := SRF->RF_DATINI2
					nDiasFer := SRF->RF_DFEPRO2
				ElseIf MesAno(SRF->RF_DATINI3) == cMesAno .And. SRF->RF_DATINI3 <= dDtPesq2
					dDataAux := SRF->RF_DATINI3
					nDiasFer := SRF->RF_DFEPRO3
				EndIf
				If ! Empty(dDataAux)
					dDataAux2 := dDataAux + nDiasFer - 1 //Subtrai um porque o dia de inicio deve ser contado.
					dDataAux2 := Min(dDataAux2, dDtPesq2) //Limite eh a menor data entre final do periodo e fim das ferias
					If !Empty(aDiasMes)
						nPos := Ascan( aDiasMes, { |X| X[1] == dDataAux } )
						If nPos == 0
							nPos := Ascan( aDiasMes, { |X| X[1] == dDataAux2 } )
						EndIf
						If nPos > 0
							For nY := nPos to Len(aDiasMes)
								If aDiasMes[nY, 1] >= dDataAux .and. aDiasMes[nY,1] <= dDataAux2
									If !lBusca .And. aDiasMes[nY, 5] != "FER"
										nFerVen++
									EndIf
									aDiasMes[nY, 4] := .F.
									aDiasMes[nY, 5] := "PRG"
								Else
									Exit //Sai do laco interno
								EndIf
							Next nY
						EndIf
					EndIf
				EndIf
				Exit //So deve existir uma programacao ativa
			EndIf
			SRF->(DbSkip())
		EndDo
	EndIf

	If __lMemCalc
		fAddMemLog("Dias ferias programadas : " + cvaltochar(nFerVen) ,1,1)
	EndIf
	RestArea(aArea)

Return Nil


/*/{Protheus.doc} fVlsRGB
Verifica existência de faltas na RGB, SRC ou SRD e alimenta mnemônico
@author Leandro Drumond
@since 25/07/2013
@version 12.1.17
@history 01/11/2017, Cícero Alves, Incluído tratamento para busca das faltas no ponto
/*/
Function fVlsRGB()

	Local aArea			:= GetArea()
	Local aPerAtual		:= {}
	Local cAliasQry		:= ""
	Local cWhere		:= ""
	Local cWhere1		:= ""
	Local cPdAux		:= ""
	Local nFDias		:= 0
	Local nFHoras		:= 0
	Local nDesconto		:= 0  //faltas ja descontadas para o periodo
	Local dDt1			:= ctod("")
	Local dDt2			:= ctod("")
	Local nMesAnt		:= If( Type("P_BENBUSFA") == "U", 0, P_BENBUSFA)
	Local cEventosPon	:= If( Type("P_BENPONEV") == "U", "", StrTran( P_BENPONEV, ",", "','" ))	// Eventos do ponto que serão considerados para desconto
	Local cPerBusFal	:= ""
	Local aPerAberto	:= {}
	Local aPerFechado	:= {}
	Local cRotFun		:= If(SRA->RA_CATFUNC $ 'A|P', fGetCalcRot('9'), fGetCalcRot('1'))
	Local dDataIni		:= cTod("//")
	Local dDataFim		:= cTod("//")
	Local dPonIni		:= cTod("//")
	Local dPonFim		:= cTod("//")
	Local cAliasPON		:= ""
	Local nFalArray		:= 0

	DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

	nFaltas := 0 //Mnemonico
	aFaltas := {}

	If LNOVOCALCB //mnemonico
		If cTipoRot == "8" .AND. APERGUNTE[1, 3] == 3
			dDt1 := APERGUNTE[12, 3]
			dDt2 := APERGUNTE[13, 3]
		EndIF

		If cTipoRot <> "8" .AND. APERGUNTE[6,3] == 1
			dDt1 := APERGUNTE[8, 3]
			dDt2 := APERGUNTE[9, 3]
		EndIF

		nDesconto := FaltasDes(cPeriodo, dDt1, dDt2)
		If __lMemCalc
			fAddMemLog("Calendario utilizado(MV_USACPER) : " +If(lUsaCPer,"FOLHA","PONTO") ,1,1)
			fAddMemLog("Faltas já descontadas de pedidos anteriores: " + cvaltochar(nDesconto) ,1,1)
			fAddMemLog("Meses para busca de faltas (P_BENBUSFA): " + cvaltochar(nMesAnt) ,1,1)
			fAddMemLog("Eventos do ponto para desconto (P_BENPONEV): " + cEventosPon ,1,1)
		EndIf
	EndIf

	fGetPerAtual( @aPerAtual, , SRA->RA_PROCES, cRot )

	// Se usa calendário do ponto e se o mnemônico P_BENPONEV está preenchido com os eventos do ponto verifica as faltas no ponto
	If !lUsaCPer .And. !Empty(cEventosPon) .And. !Empty(aPerAtual)

		cAliasPON := GetNextAlias()

		// Bustca o período atual do ponto
		GetPerAtu(@dPonIni, @dPonFim )

		// Carrega o período de apontamento considerando o conteúdo do mnemônico P_BenBusFa
		PerAponta(@dDataIni, @dDataFim, MonthSub(aPerAtual[1][6], nMesAnt),,,,,,,.T.)

		If __lMemCalc
			fAddMemLog("Periodo atual do ponto : " + dtoc(dPonIni) + " a " + dtoc(dPonFim) ,1,1)
			fAddMemLog("Periodo de busca de desconto : " + dtoc(dDataIni) + " a " + dtoc(dDataFim) ,1,1)
		EndIf

		// Se for o período atual ou superior busca na SPC
		If dDataIni >= dPonIni

			BeginSQL Alias cAliasPON

				SELECT COUNT(*) FALTAS
				FROM %Table:SPC% SPC
				WHERE ( PC_PD IN (%Exp: cEventosPon%)
				AND PC_PDI = ''
				OR PC_PDI IN (%Exp: cEventosPon% ))
				AND PC_DATA BETWEEN %Exp: dTos(dDataIni)% AND %Exp: dTos(dDataFim)%
				AND PC_MAT = %Exp: SRA->RA_MAT%
				AND PC_FILIAL = %Exp: SRA->RA_FILIAL%
				AND SPC.%NotDel%

			EndSQL

		Else
			//Caso seja um período anterior busca na SPH

			BeginSQL Alias cAliasPON

				SELECT COUNT(*) FALTAS
				FROM %Table:SPH% SPH
				WHERE ( PH_PD IN (%Exp: cEventosPon%)
				AND PH_PDI = ''
				OR PH_PDI IN (%Exp: cEventosPon% ))
				AND PH_DATA BETWEEN %Exp: dTos(dDataIni)% AND %Exp: dTos(dDataFim)%
				AND PH_MAT = %Exp: SRA->RA_MAT%
				AND PH_FILIAL = %Exp: SRA->RA_FILIAL%
				AND SPH.%NotDel%

			EndSQL

		EndIf

		nFaltas := (cAliasPON)->(FALTAS)

		(cAliasPON)->(dbCloseArea())

		If nFaltas > 0
			//Posições no array: 1=domingo,2=segunda,3=terça,4=quarta,5=quinta,6=sexta,7=sabado
			aFaltas := {0,0,0,0,0,0,0}
			//Busca as faltas por dia da semana
			cAliasPON := GetNextAlias()
			If dDataIni >= dPonIni
				BeginSQL Alias cAliasPON

					SELECT DISTINCT PC_DATA AS DATAFAL
					FROM %Table:SPC% SPC
					WHERE ( PC_PD IN (%Exp: cEventosPon%)
					AND PC_PDI = ''
					OR PC_PDI IN (%Exp: cEventosPon% ))
					AND PC_DATA BETWEEN %Exp: dTos(dDataIni)% AND %Exp: dTos(dDataFim)%
					AND PC_MAT = %Exp: SRA->RA_MAT%
					AND PC_FILIAL = %Exp: SRA->RA_FILIAL%
					AND SPC.%NotDel%

				EndSQL

			Else
				//Caso seja um período anterior busca na SPH

				BeginSQL Alias cAliasPON

					SELECT DISTINCT PH_DATA AS DATAFAL
					FROM %Table:SPH% SPH
					WHERE ( PH_PD IN (%Exp: cEventosPon%)
					AND PH_PDI = ''
					OR PH_PDI IN (%Exp: cEventosPon% ))
					AND PH_DATA BETWEEN %Exp: dTos(dDataIni)% AND %Exp: dTos(dDataFim)%
					AND PH_MAT = %Exp: SRA->RA_MAT%
					AND PH_FILIAL = %Exp: SRA->RA_FILIAL%
					AND SPH.%NotDel%

				EndSQL
			EndIf

			While (cAliasPON)->(!Eof())
				aFaltas[Dow(StoD((cAliasPON)->DATAFAL))] += 1 //Acrescenta uma falta no dia da semana referente a data
				(cAliasPON)->(DbSkip())
			EndDo

			(cAliasPON)->(dbCloseArea())
		EndIf

	ElseIf ! Empty(aPerAtual) .and. (!Empty(aCodFol[54, 1]) .or. !Empty(aCodFol[242, 1]))

		If ! Empty(aCodFol[54, 1])
			cPdAux := "'" + aCodFol[54, 1] + "'"
		EndIf
		If ! Empty(aCodFol[242, 1])
			cPdAux += If(Empty(cPdAux), "'" + aCodFol[242, 1] + "'", ",'" + aCodFol[242, 1] + "'")
		EndIf
		If ! Empty(aCodFol[0244, 1])
			cPdAux += If(Empty(cPdAux), "'" + aCodFol[0244, 1] + "'", ",'" + aCodFol[0244, 1] + "'")
		EndIf

		If nMesAnt == 0
			//Posições no array: 1=domingo,2=segunda,3=terça,4=quarta,5=quinta,6=sexta,7=sabado
			aFaltas := {0,0,0,0,0,0,0}

			cWhere1 += " RGB.RGB_FILIAL = '" + SRA->RA_FILIAL + "' "
			cWhere1 += " AND RGB.RGB_MAT = '" + SRA->RA_MAT + "' "
			cWhere1 += " AND RGB.RGB_PROCES = '" + aPerAtual[1, 8] + "' "
			cWhere1 += " AND RGB.RGB_PERIOD = '" + aPerAtual[1, 1] + "' "
			cWhere1 += " AND RGB.RGB_ROTEIR = '" + cRotFun + "' "
			cWhere1 += " AND RGB.RGB_PD IN (" + cPdAux + ") "

			cWhere := "%" + cWhere1 + " AND RGB.RGB_TIPO1 = 'D'"
			cWhere += "%"

			cAliasQry:= "QRGB"
			BeginSql alias cAliasQry
				SELECT RGB_PD, RGB_HORAS, RGB_DTREF
				FROM %table:RGB% RGB
				WHERE %exp:cWhere% AND
				RGB.%notDel%
			EndSql

			While !(cAliasQry)->( EOF() )
				If (cAliasQry)->RGB_PD == aCodFol[0244,1]
					nFDias -= (cAliasQry)->RGB_HORAS
				Else
					nFDias += (cAliasQry)->RGB_HORAS
				EndIf
				If !Empty((cAliasQry)->RGB_DTREF)
					aFaltas[Dow(StoD((cAliasQry)->RGB_DTREF))] += 1 //Acrescenta uma falta no dia da semana referente a data
				EndIf
				(cAliasQry)->( DbSkip() )
			EndDo

			(cAliasQry)->(DbCloseArea())

			cWhere := "%" + cWhere1 + " AND RGB.RGB_TIPO1 = 'H'"
			cWhere += "%"

			cAliasQry:= "QRGB"
			BeginSql alias cAliasQry
				SELECT RGB_PD, RGB_HORAS, RGB_DTREF
				FROM %table:RGB% RGB
				WHERE %exp:cWhere% AND
				RGB.%notDel%
			EndSql

			While !(cAliasQry)->( EOF() )
				If (cAliasQry)->RGB_PD == aCodFol[0244,1]
					nFHoras -= Round((cAliasQry)->RGB_HORAS / SRA->RA_HRSDIA, 0)
				Else
					nFHoras += Round((cAliasQry)->RGB_HORAS / SRA->RA_HRSDIA, 0)
				EndIf
				If !Empty((cAliasQry)->RGB_DTREF)
					aFaltas[Dow(StoD((cAliasQry)->RGB_DTREF))] += 1 //Acrescenta uma falta no dia da semana referente a data
				EndIf
				(cAliasQry)->( DbSkip() )
			EndDo

			(cAliasQry)->(DbCloseArea())

		Else
			cPerBusFal := MesAno(MonthSub(aPerAtual[1][6], nMesAnt))
			If __lMemCalc
				fAddMemLog("Periodo de busca de desconto : " + cPerBusFal ,1,1)
				fAddMemLog("Verbas  : " + cPdAux ,1,1)
			EndIf

			RetPerAbertFech(SRA->RA_PROCES,; // Processo selecionado na Pergunte.
						cRotFun		,; // Roteiro selecionado na Pergunte.
						cPerBusFal	,; // Periodo selecionado na Pergunte.
						"99"		,; // Numero de Pagamento selecionado na Pergunte.
						NIL			,; // Periodo Ate - Passar "NIL", pois neste relatorio eh escolhido apenas um periodo.
						NIL			,; // Numero de Pagamento Ate - Passar "NIL", pois neste relatorio eh escolhido apenas um numero de pagamento.
						@aPerAberto	,; // Retorna array com os Periodos e NrPagtos Abertos
						@aPerFechado ) // Retorna array com os Periodos e NrPagtos Fechados

			If nMesAnt == 1 .and. ! Empty(aPerAberto)
				cWhere1 += " SRC.RC_FILIAL = '" + SRA->RA_FILIAL + "' "
				cWhere1 += " AND SRC.RC_MAT = '" + SRA->RA_MAT    + "' "
				cWhere1 += " AND SRC.RC_PROCES = '" + SRA->RA_PROCES + "' "
				cWhere1 += " AND SRC.RC_PERIODO = '" + aPerAberto[1,1] + "' "
				cWhere1 += " AND SRC.RC_ROTEIR = '" + cRotFun + "' "
				cWhere1 += " AND SRC.RC_PD IN (" + cPdAux   + ") "

				cWhere := "%" + cWhere1 + " AND SRC.RC_TIPO1 = 'D'"
				cWhere += "%"

				cAliasQry:= "QSRC"
				BeginSql alias cAliasQry
					SELECT RC_PD, RC_HORAS
					FROM %table:SRC% SRC
					WHERE %exp:cWhere% AND
					SRC.%notDel%
				EndSql

				While !(cAliasQry)->( EOF() )
					If (cAliasQry)->RC_PD == aCodFol[0244,1]
						nFDias -= (cAliasQry)->RC_HORAS
					Else
						nFDias += (cAliasQry)->RC_HORAS
					EndIf

					(cAliasQry)->( DbSkip() )
				EndDo

				(cAliasQry)->(DbCloseArea())

				cWhere := "%" + cWhere1 + " AND SRC.RC_TIPO1 = 'H'"
				cWhere += "%"
				cAliasQry:= "QSRC"
				BeginSql alias cAliasQry
					SELECT RC_PD,RC_HORAS
					FROM %table:SRC% SRC
					WHERE %exp:cWhere% AND
					SRC.%notDel%
				EndSql

				While !(cAliasQry)->( EOF() )
					If (cAliasQry)->RC_PD == aCodFol[0244,1]
						nFHoras -= Round((cAliasQry)->RC_HORAS / SRA->RA_HRSDIA, 0)
					Else
						nFHoras += Round((cAliasQry)->RC_HORAS / SRA->RA_HRSDIA, 0)
					EndIf

					(cAliasQry)->( DbSkip() )
				EndDo

				(cAliasQry)->(DbCloseArea())
			ElseIf !Empty(aPerFechado)
				cWhere1 += " SRD.RD_FILIAL = '" + SRA->RA_FILIAL + "' "
				cWhere1 += " AND SRD.RD_MAT = '" + SRA->RA_MAT + "' "
				cWhere1 += " AND SRD.RD_PROCES = '" + SRA->RA_PROCES + "' "
				cWhere1 += " AND SRD.RD_PERIODO = '" + aPerFechado[1, 1] + "' "
				cWhere1 += " AND SRD.RD_ROTEIR = '" + cRotFun + "' "
				cWhere1 += " AND SRD.RD_PD IN (" + cPdAux + ") "

				cWhere := "%" + cWhere1 + " AND SRD.RD_TIPO1 = 'D'"
				cWhere += "%"

				cAliasQry:= "QSRD"
				BeginSql alias cAliasQry
					SELECT RD_PD,RD_HORAS
					FROM %table:SRD% SRD
					WHERE %exp:cWhere% AND
					SRD.%notDel%
				EndSql

				While !(cAliasQry)->( EOF() )
					If (cAliasQry)->RD_PD == aCodFol[0244,1]
						nFDias -= (cAliasQry)->RD_HORAS
					Else
						nFDias += (cAliasQry)->RD_HORAS
					EndIf

					(cAliasQry)->( DbSkip() )
				EndDo

				(cAliasQry)->(DbCloseArea())

				cWhere := "%" + cWhere1 + " AND SRD.RD_TIPO1 = 'H'"
				cWhere += "%"
				cAliasQry:= "QSRD"
				BeginSql alias cAliasQry
					SELECT RD_PD,RD_HORAS
					FROM %table:SRD% SRD
					WHERE %exp:cWhere% AND
					SRD.%notDel%
				EndSql

				While !(cAliasQry)->( EOF() )
					If (cAliasQry)->RD_PD == aCodFol[0244,1]
						nFHoras -= Round((cAliasQry)->RD_HORAS / SRA->RA_HRSDIA, 0)
					Else
						nFHoras += Round((cAliasQry)->RD_HORAS / SRA->RA_HRSDIA, 0)
					EndIf

					(cAliasQry)->( DbSkip() )
				EndDo

				(cAliasQry)->(DbCloseArea())
			EndIf
		EndIf
		nFaltas := nFDias + nFHoras
	EndIf
	If __lMemCalc
		fAddMemLog("Faltas no periodo : " + cvaltochar(nFaltas) ,1,1)
	EndIf

	aEval(aFaltas, {|x| nFalArray += x})
	If nFalArray == 0
		aFaltas := {}
	EndIf

	nFaltas := nFaltas - nDesconto

	If __lMemCalc
		fAddMemLog("Faltas no periodo - faltas ja descontadas em outros pedidos: " + cvaltochar(nFaltas) ,1,1)
	EndIf
	If LNOVOCALCB .And. nFaltas < 0 .And. nDesconto > 0
		nFaltas := 0
		aFaltas := {}
	EndIf

	RestArea(aArea)
Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fVTRSal		   ºAutor  ³Leandro Drumond  º Data ³  25/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Monta salario base para calculo do vale transporte		      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVTRSal()

	Local aArea		:= GetArea()
	Local lCVTUso	:= GetMvRH( "MV_CVTUSO", .F., "2" ) == "1"
	Local cVTProp	:= GetMvRH( "MV_CVTPROP", .F., "P" )
	Local cCodigos	:= ""
	Local nDiaTra	:= 0
	Local nTVerbas	:= 0
	Local nQtdPerg	:= 8
	Local nCont		:= 0
	Local nInfNorm	:= 0
	Local nInfDesc	:= 0
	Local nValRed	:= 0
	Local lSALHBEN	:= .F.
	Local lLDSRHRSP := Type("P_LDSRHRSP") # "U" .And. P_LDSRHRSP

	DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

	If LNOVOCALCB
		nQtdPerg	:= 7
	EndIf

	fSalario(@nSalario, @SalHora, @SalDia, @nSalMes, "A")

	If SRA->RA_CATFUNC == "H" .And. lLDSRHRSP
		nSalMes := (SRA->RA_SALARIO * nHrsCal)
	EndIf

	If DIASTRAB == 0 .and. Len(aAfast) == 0
		fDiasTrab(@DIASTRAB)
	EndIf

	If lCVTUso
		nDiatra := If(cVTProp == "T", If(GetMvRH("MV_DIASPER",,"1") == "1",nDiasP,(If(SRA->RA_TIPOPGT =="M", P_QTDIAMES, P_NTOTDIAS))), DIASTRAB)
	EndIf

	nSalBsVT := 0 //Salario Base VTR - Mnemonico

	aPd := FCARMVTO(SRA->RA_FILIAL, SRA->RA_MAT, CSEMANA, CPROCESSO, CPERIODO, "FOL", CNUMPAG, ,.F.)

	lSALHBEN := If( Type("P_SALHBEN") == "U", .F., P_SALHBEN)

	If __lMemCalc
		fAddMemLog("MV_CVTUSO : " + If(lCVTUso,"Sim","Não") ,1,1)
		fAddMemLog("MV_CVTPROP : " + cVTProp ,1,1)
		fAddMemLog("P_LDSRHRSP : " + If(P_LDSRHRSP,"Sim","Não")  ,1,1)
		fAddMemLog("P_SALHBEN : " + If(lSALHBEN,"Sim","Não")  ,1,1)
		fAddMemLog("Dias Periodo : " + cvaltochar(nDiatra) ,1,1)
		fAddMemLog("Dias trabalhados : " + cvaltochar(DIASTRAB) ,1,1)
		fAddMemLog("Dias afastamento : " + cvaltochar(nDiasAfas) ,1,1)
		fAddMemLog("Salario : " + Transform(nSalario,"@E 999,999,999.99")  ,1,1)
		fAddMemLog("Salario hora : " + Transform(SalHora,"@E 999,999,999.99")  ,1,1)
		fAddMemLog("Salario dia : " + Transform(SalDia,"@E 999,999,999.99")  ,1,1)
		fAddMemLog("Salario incorporado : " + Transform(nSalMes,"@E 999,999,999.99")  ,1,1)
		fAddMemLog("Horas NORMAL : " + cvaltochar(Normal) ,1,1)
		fAddMemLog("Horas DESCANSO : " + cvaltochar(Descanso) ,1,1)
	EndIf

	If SRA->RA_CATFUNC == "H" .AND. lSALHBEN
		//Percorre o aPd em busca das verbas de salário horista (Id 0032) e DSR horista (Id 0033)
		For nCont := 1 To Len(aPd)
			If aPd[nCont, 1] == aCodFol[032, 1] .And. aPd[nCont, 9] != "D" .And. AllTrim( aPd[nCont, 3] ) == AllTrim( cSemana ) .And. aPd[nCont, 7] == "I"
				nInfNorm += aPd[nCont, 4]
			EndIf
			If aPd[nCont, 1] == aCodFol[033, 1] .And. aPd[nCont, 9] != "D" .And. AllTrim( aPd[nCont, 3] ) == AllTrim( cSemana ) .And. aPd[nCont, 7] == "I"
				nInfDesc += aPd[nCont, 4]
			EndIf
		Next nCont

		//Caso tenha informado a verba de salário horista, utiliza as horas informadas
		If nInfNorm > 0
			Normal := nInfNorm
			//Caso possua afastamento, divide as horas pelas dias trabalhados e multiplica pelos dias de cálculo para considerar as horas previstas no mês
			If nDiasAfas > 0
				Normal := (Normal / DiasTrab * nDiasC)
			EndIf
			//Verifica a quantidade de horas trabalhadas por dia, de acordo com as horas informadas
			//Conta será as horas trabalhadas, dividido pelos dias úteis, multiplicado pelos dias de cálculo e dividido por 30
			nHrsDia := (Normal / aPeriodo[nPosSem, 24] * aPeriodo[nPosSem, 20] / 30)
			//Caso tenha informado a verba de DSR horista, utiliza as horas informadas
			If nInfDesc > 0
				Descanso := nInfDesc
			//Caso contrário, multiplica as horas trabalhadas por dia pelos dias de DSR
			Else
				Descanso := nHrsDia * aPeriodo[nPosSem, 7]
			EndIf

			//Retira a incorporação das variáveis de salário, pois foram consideradas as horas cadastrais
			nSalMes -= (SRA->RA_SALARIO * nHrsCal)
			SalDia -= (SRA->RA_SALARIO * SRA->RA_HRSDIA)

			//Efetua a incorporação das variáveis de salário, com base nas horas trabalhadas
			nHrsCal := nHrsDia * nDiasC
			nSalMes += (SRA->RA_SALARIO * nHrsCal)
			SalDia += (SRA->RA_SALARIO * nHrsDia)

			If __lMemCalc
				fAddMemLog("Horas informadas NORMAL : " + cvaltochar(nInfNorm) ,1,1)
				fAddMemLog("Horas informadas DESCANSO : " + cvaltochar(nInfDesc) ,1,1)
				fAddMemLog("Horas calculo : " + cvaltochar(nHrsCal) ,1,1)
				fAddMemLog("novo Salario dia : " + Transform(SalDia,"@E 999,999,999.99")  ,1,1)
				fAddMemLog("novo Salario incorporado : " + Transform(nSalMes,"@E 999,999,999.99")  ,1,1)
			EndIf
		EndIf
	EndIf

	If Len(aPergunte) > nQtdPerg
		If LNOVOCALCB
			cCodigos := AllTrim(aPergunte[7, 3]) + AllTrim(aPergunte[8, 3]) + AllTrim(aPergunte[9, 3]) + AllTrim(aPergunte[10, 3])
		Else
			cCodigos := AllTrim(aPergunte[8, 3]) + AllTrim(aPergunte[9, 3]) + AllTrim(aPergunte[10, 3]) + AllTrim(aPergunte[11, 3])
		EndIf
		If !Empty(cCodigos) // Incorpora verbas do Movimento Mensal ao Salario
			nTVerbas := 0
			fSVerbas(cCodigos, @nTVerbas, aPd)
			nSalMes += nTVerbas
			If __lMemCalc
				fAddMemLog("Verbas a serem incorporadas : " + cCodigos ,1,1)
				fAddMemLog("valor das verbas : " + Transform(nTVerbas,"@E 999,999,999.99") ,1,1)
				fAddMemLog("novo Salario incorporado : " + Transform(nSalMes,"@E 999,999,999.99")  ,1,1)
			EndIf
		EndIf
	EndIf

	If P_lPPEAtiv .And. P_RedSalB
		fInssResEx()
		fSalRed(@nValRed, Nil, Nil, nSalMes)
		nSalMes -= nValRed
	EndIf

	If lCVTUso //Usa parametro MV_CVTPROP
		If !BaseVTProp(@nSalBsVT, nDiaTra, cVTProp)
			Return(.F.)
		EndIf
	Else
		nSalBsVT  := nSalMes //Considera salario integral
		If __lMemCalc
			fAddMemLog("SALARIO BASE para calculo do beneficio(nSalMes) : " + Transform(nSalMes,"@E 999,999,999.99") ,1,1)
		EndIf
	EndIf

	// Verifico se o Funcionário é Comissionado
	If SRA->RA_CATFUNC == "C" .And. (nSalBsVT == 0 .OR. empty(nSalBsVT))
		nSalBsVT := fDesc("RCE", SRA->RA_SINDICA, "RCE_GCOMISS", Nil, SRA->RA_FILIAL)
		If __lMemCalc
			fAddMemLog("Garantia comissao(salario) : " + Transform(nSalBsVT,"@E 999,999,999.99") ,1,1)
		EndIf
	Endif

RestArea(aArea)

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³BaseVTProp	   ºAutor  ³Leandro Drumond  º Data ³  25/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Monta base de salario para VT baseado no parametro		      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function BaseVTProp(nSalBsVT,nDiaTra,cVTProp)
Local lRet		:= .T.
Local nX		:= 0
Local nDiasFunc	:= 0
Local nDPropInf	:= 0
Local nDiasPer	:= 0
Local nDiasTb	:= 0

DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

If __lMemCalc
	fAddMemLog("Calendário  : " + if( Empty(aDiasMes),"Sintético","Analítico") ,1,1)
EndIf

If cVTProp == "I" 	//Integral
	nSalBsVT := nSalMes
ElseIf cVTProp == "T"	//Trabalhado
	If Empty(aDiasMes) //Periodo sintetico, nao tem informacao de dia. Utilizar salario do mes
		nSalBsVT := nSalMes		//Considera salario integral
		If __lMemCalc
			fAddMemLog("SALARIO BASE para calculo do beneficio(nSalMes) : " + Transform(nSalMes,"@E 999,999,999.99") ,1,1)
		EndIf
	Else
		For nX := 1 to Len(aDiasMes)
			If ( aDiasMes[nX,2] $ "1*3" .and. Empty(aDiasMes[nX,5]) ) //Dias úteis e DSR sem afastamento
				nDiasFunc++
			EndIf
		Next nX
		nSalBsVT := nSalMes * (nDiasFunc/nDiaTra)
		If __lMemCalc
			fAddMemLog("Dias trabalhados(calendario)  : " + cvaltochar(nDiasFunc) ,1,1)
			fAddMemLog("SALARIO BASE para calculo do beneficio(nSalMes * (nDiasFunc/nDiaTra)) : " + Transform(nSalBsVT,"@E 999,999,999.99") ,1,1)
		EndIf
	EndIf
ElseIf cVTProp == "P"
	If LNOVOCALCB
		DbSelectArea("SM7")
		DbSetOrder(RetOrdem("SM7","M7_FILIAL+M7_MAT+M7_TPVALE+M7_CODIGO"))
		If DbSeek(SRA->RA_FILIAL+SRA->RA_MAT+"0")
			While ( !Eof() .and. M7_FILIAL+M7_MAT+M7_TPVALE == SRA->RA_FILIAL+SRA->RA_MAT+"0" )
				//Se existir algum meio de transporte sem dias proporcionais informados ou com dias proporcionais diferentes entre si, campo será desconsiderado
				If SM7->M7_DPROPIN == 0 .or. ( nDPropInf <> 0 .and. nDPropInf <> SM7->M7_DPROPIN .and. SM7->M7_DPROPIN <> 99 )
					nDPropInf := 0
					Exit
				EndIf
				If SM7->M7_DPROPIN <> 99
					nDPropInf := SM7->M7_DPROPIN
				EndIf
				DbSkip()
			EndDo
		EndIf
	Else
		DbSelectArea("SR0")
		DbSetOrder(RetOrdem("SR0","R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO"))
		If DbSeek(SRA->RA_FILIAL+SRA->RA_MAT+"0")
			While ( !Eof() .and. R0_FILIAL+R0_MAT+R0_TPVALE == SRA->RA_FILIAL+SRA->RA_MAT+"0" )
				//Se existir algum meio de transporte sem dias proporcionais informados ou com dias proporcionais diferentes entre si, campo será desconsiderado
				If SR0->R0_DPROPIN == 0 .or. ( nDPropInf <> 0 .and. nDPropInf <> SR0->R0_DPROPIN .and. SR0->R0_DPROPIN <> 99 )
					nDPropInf := 0
					Exit
				EndIf
				If SR0->R0_DPROPIN <> 99
					nDPropInf := SR0->R0_DPROPIN
				EndIf
				DbSkip()
			EndDo
		EndIf
	EndIf
	If __lMemCalc
		fAddMemLog("Dias proporcionais informados  : " + cvaltochar(nDPropInf) ,1,1)
	EndIf
	If nDPropInf == 0
		If Empty(aDiasMes)
			nSalBsVT  := nSalMes	//Considera salario integral pois nao eh possivel calcular dias proporcionais informados
			nDPropInf := 0
			If __lMemCalc
				fAddMemLog("SALARIO BASE para calculo do beneficio(nSalMes) : " + Transform(nSalMes,"@E 999,999,999.99") ,1,1)
			EndIf
		Else
			For nX := 1 to Len(aDiasMes)
				If aDiasMes[nX,3] == "1" .and. aDiasMes[nX,4]  //RCG_VTRANS = "S"
					nDPropInf++
				EndIf
			Next nX
		EndIf
	EndIf
	If nDPropInf > 0
		nDiasPer  := If(SRA->RA_TIPOPGT =="S", P_NTOTDIAS, nDiasC)
		nSalBsVT  := nSalMes/nDiasPer*nDPropInf
		If __lMemCalc
			fAddMemLog("Dias proporcionais calendario  : " + cvaltochar(nDPropInf) ,1,1)
			fAddMemLog("SALARIO BASE para calculo do beneficio(nSalMes/nDiasPer*nDPropInf ) : " + Transform(nSalBsVT,"@E 999,999,999.99") ,1,1)
		EndIf
	EndIf
ElseIf cVTProp == "S" //Base Saldo de Salario
	nDiasTb     := Max(DiasTrab - ( nDiasMat + nDPrgSalMa ), 0)
	nDiasPer	:= If(GetMvRH("MV_DIASPER",,"1") == "1",nDiasP,(If(SRA->RA_TIPOPGT =="M", P_QTDIAMES, P_NTOTDIAS)))
	If !Empty(aDiasMes)
		For nX := 1 to Len(aDiasMes)
			If !aDiasMes[nX,4] .and. aDiasMes[nX,5] == "PRG" .and. Day(aDiasMes[nX,1]) <= nDiasPer //Se tiver férias programadas, subtrai dos dias trabalhados
				nDiasTb--
			EndIf
		Next nX
	EndIf
	nSalBsVT 	:= (( nSalMes / nDiasPer ) * nDiasTb )
	If __lMemCalc
		fAddMemLog("Dias trabalhados - dias de ferias programadas  : " + cvaltochar(DiasTrab-nDiasTb) ,1,1)
		fAddMemLog("Dias trabalhados  : " + cvaltochar(nDiasTb) ,1,1)
		fAddMemLog("SALARIO BASE para calculo do beneficio((( nSalMes / nDiasPer ) * nDiasTb )	 ) : " + Transform(nSalBsVT,"@E 999,999,999.99") ,1,1)
	EndIf
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fChkSR0  	   ºAutor  ³Leandro Drumond  º Data ³  26/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Checa se existem dados na SR0							      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fChkSR0(cFilFunc,cMatFunc,cTipoVale,lAgrup)
Local aArea		:= GetArea()
Local lRet		:= .T.

DEFAULT cFilFunc  := xFilial("SR0")
DEFAULT cMatFunc  := SRA->RA_MAT
DEFAULT cTipoVale := If(cTipoRot == "8","0",(If(cTipoRot == "D","1","2"))) //0-Vale Transporte / 1-Vale Refeição / 2-Vale Alimentação
DEFAULT lAgrup	  := .F.


DbSelectArea("SR0")
DbSetOrder(RetOrder("SR0", "R0_FILIAL+R0_MAT+R0_TPVALE"))

If lAgrup
	If DbSeek(cFilFunc + cMatFunc + cTipoVale)
		While !SR0->(Eof()) .And. SR0->(R0_FILIAL+R0_MAT+R0_TPVALE) == cFilFunc + cMatFunc + cTipoVale
			If SR0->R0_TPCALC <> "2"
				lRet := .F.
			Else
				RecLock("SR0",.F.)
				DbDelete()
				MsUnLock()
			EndIf
			SR0->(dbSkip())
		EndDo
	EndIf
Else
	If !DbSeek(cFilFunc + cMatFunc + cTipoVale)
		lRet := .F.
	EndIf
EndIf
RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fChkSM7  	   ºAutor  ³Leandro Drumond  º Data ³  26/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Checa se existem dados na SR0							      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fChkSM7(cFilFunc,cMatFunc,cTipoVale,lAgrup)
Local aArea		:= GetArea()
Local lRet		:= .T.

DEFAULT cFilFunc  := xFilial("SM7")
DEFAULT cMatFunc  := SRA->RA_MAT
DEFAULT cTipoVale := If(cTipoRot == "8","0",(If(cTipoRot == "D","1","2"))) //0-Vale Transporte / 1-Vale Refeição / 2-Vale Alimentação
DEFAULT lAgrup	  := .F.


DbSelectArea("SM7")
SM7->(DbSetOrder(RetOrder("SM7", "M7_FILIAL+M7_MAT+M7_TPVALE")))

If lAgrup
	If SM7->(DbSeek(cFilFunc + cMatFunc + cTipoVale))
		While !SM7->(Eof()) .And. SM7->(M7_FILIAL+M7_MAT+M7_TPVALE) == cFilFunc + cMatFunc + cTipoVale
			If SM7->M7_TPCALC <> "2"
				lRet := .F.
			Else
				RecLock("SM7",.F.)
				DbDelete()
				MsUnLock()
			EndIf
			SM7->(dbSkip())
		EndDo
	EndIf
Else
	If !SM7->(DbSeek(cFilFunc + cMatFunc + cTipoVale))
		lRet := .F.
	EndIf
EndIf
RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fChkRG2  	   ºAutor  ³Leandro Drumond  º Data ³  29/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Checa se existe pedido completo na RG2					      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fChkRG2(cFilFunc, cMatFunc, cTipoVale)

Local aArea		:= GetArea()
Local lRet		:= .T.
Local cTpRG2Ped	:= GetSx3Cache("RG2_PEDIDO", "X3_TIPO")

DEFAULT cFilFunc  := xFilial("RG2")
DEFAULT cMatFunc  := SRA->RA_MAT
DEFAULT cTipoVale := If(cTipoRot == "8","0",(If(cTipoRot == "D","1","2"))) //0-Vale Transporte / 1-Vale Refeição / 2-Vale Alimentação

DbSelectArea("RG2")
DbSetOrder(RetOrder("RG2", "RG2_FILIAL+RG2_PERIOD+RG2_NROPGT+RG2_ROTEIR+RG2_MAT+RG2_TPVALE+RG2_CODIGO"))

If DbSeek(cFilFunc + cPeriodo + cSemana + cRot + cMatFunc + cTipoVale)
	If RG2->RG2_PEDIDO == If( cTpRG2Ped == "C", "2", 2 )			//Se pedido foi concluido, nao recalcula
		If GetRemoteType() == -1
			MsgLogGrid( STR0036, .F. ) // "Pedido de compra do beneficio já foi concluído. Não será recalculado."
		Else
			If IsInCallStack( "EXECROT" ) //Se estiver executando roteiro de calculo
				AddLogExecRot( STR0036 )	// "Pedido de compra do beneficio já foi concluído. Não será recalculado."
			Else
				Help(" ", 1, "Help",, OemToAnsi(STR0036), 1, 0)  // "Pedido de compra do beneficio já foi concluído. Não será recalculado."
			EndIf
		EndIf
		lRet := .F.
	EndIf
EndIf

RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fVTRCalc	   ºAutor  ³Leandro Drumond  º Data ³  25/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Calculo do Vale Transporte								      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVTRCalc(aVTCalc)
Local aArea		:= GetArea()
Local cFilFunc  := SRA->RA_FILIAL
Local cMatFunc  := SRA->RA_MAT
Local cKeyAux	:= ""
Local nCustAux  := 0
Local nCustFunc := 0
Local nDiaNUtil	:= 0
Local nDiaUtil	:= 0
Local nDiasFix	:= 0
Local nValUni	:= 0
Local nValUniAnt:= 0
Local nValUniDif:= 0
Local nDiaTran	:= 0
Local nDiaNTran	:= 0
Local nDiaUCal	:= 0
Local nDiaNUCal	:= 0
Local nValVTR	:= 0
Local nTotVTR	:= 0
Local nDiasVTR	:= 0
Local nDiasProp	:= 0
Local nX		:= 0
Local nH		:= 0
Local nValAux	:= 0
Local nDiasPer	:= If(SuperGetMv("MV_DIASPER",,"1") == "1",nDiasP,(If(SRA->RA_TIPOPGT =="M", P_QTDIAMES, P_NTOTDIAS)))

Private nPercentual := RetValSRV(aCodFol[051,1],SRA->RA_FILIAL,"RV_PERC")
Private aVTRDias    := {}

DEFAULT lGp210Sal	:= ExistBlock("GP210SAL")
DEFAULT lGPVTRDias  := ExistBlock("GPVTRDias")

If lGp210Sal
	EXECBLOCK("GP210SAL", .F. , .F. ) //Retorna nPercentual
	If ValType(nPercentual) <> "N"
		nPercentual := 6
	EndIf
EndIf

If SRA->RA_CATFUNC $ "E*G"
	nCustFunc := nPercentual := 0
Else
	nCustFunc := Round(NSALBSVT * ( nPercentual / 100 ),2) //Custo Mensal do Funcionario
EndIf

aVTCalc	  := {}

DbSelectArea("SR0")
DbSetOrder(RetOrder("SR0", "R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO"))

DbSeek(cFilFunc + cMatFunc + "0")

While SR0->(!Eof() .and. R0_FILIAL + R0_MAT + R0_TPVALE == cFilFunc + cMatFunc + "0")

	nDiaNUtil := SR0->R0_QDNUTIL	//Qtde vales por dia não util de VT
	nDiaUtil  := SR0->R0_QDIAINF	//Qtde vales por dia util de VT
	nDiasProp := SR0->R0_DPROPIN
	nValUni	  := PosAlias( "SRN" , SR0->R0_CODIGO , xFilial("SRN") , "RN_VUNIATU" , 1 )
	nDiasFix  := PosAlias( "SRN" , SR0->R0_CODIGO , xFilial("SRN") , "RN_DIASFIX" , 1 )

	If SR0->R0_DPROPIN == 99 //Se diasprop for 99 não calcula meio de transporte
		aAdd(aVTCalc , {SR0->(R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO), 0, nValUni, 0,  0,0, 0, 0, 0 } )
		SR0->(DbSkip())
		Loop
	EndIf

	If aPergunte[1,3] == 2 //Se for calculo da diferenca
		//Controle pelo Histórico de alterações
		SQY->(dbSeek(xFilial("SQY")+SRN->RN_COD+dtos(aPeriodo[nPosSem,3]),.T.))
		if SQY->QY_COD == SRN->RN_COD .AND. (SQY->QY_DATVIGE >= aPeriodo[nPosSem,3] .and. SQY->QY_DATVIGE <= aPeriodo[nPosSem,4])
		    nValUniAnt := SQY->QY_VUNIANT
		    nValUniDif := nValUni - nValUniAnt
		    nDiasVtr := 0
		    for nh := 1 to len(aPeriodo[nPosSem][5])
		    	if aPeriodo[nPosSem][5][nh][1] >= SQY->QY_DATVIGE.and. aPeriodo[nPosSem][5][nh][3] == '1'
			    	nDiasVTR ++
			    endif
		    next
		else
		    nValUniAnt := PosAlias( "SRN" , SR0->R0_CODIGO , xFilial("SRN") , "RN_VUNIANT" , 1 )
		    nValUniDif := nValUni - nValUniAnt
		    nDiasVTR   := aPeriodo[nPosSem,11] //RCF_DDIFVT
		endif
		nValVTR    := (nDiasVTR * nDiaUtil)  * nValUniDif
		nDiasProp  := 0	//Zera pois nao sera utilizado
	Else
		nDiaTran  := 0
		nDiaNTran := 0
		If Empty(nDiasFix) .And. Empty(nDiasProp)	//Caso informe dias proporcionais ou fixos, considera os dias informados ao invés de calcular
			If !Empty(aDiasMes)	//Se existir dados no array aDiasMes, utiliza estes dados para montar dias uteis e nao uteis de vale transporte (analitico)
				For nX := 1 to Len(aDiasMes)
					If aDiasMes[nX,2] == "1" .and. aDiasMes[nX,3] == "1" .and. aDiasMes[nX,4]
						nDiaTran += 1
					ElseIf aDiasMes[nX,2] <> "1" .and. aDiasMes[nX,3] == "1" .and. aDiasMes[nX,4]
						nDiaNTran += 1
					EndIf
				Next nX
			Else				//do contrario utiliza cadastro de periodo - RCF_DUTILT e RCF_DNUTIL (sintetico)
				If aPergunte[3,3] == 1 .And. ( DiasTrab - ( nDiasMat + nDPrgSalMa ) ) < nDiasPer
					nDiaTran  := Int( Round( aPeriodo[nPosSem,10] * ( ( DiasTrab - ( nDiasMat + nDPrgSalMa ) ) / nDiasPer ), 2 ) )
					nDiaNTran := Int( Round( aPeriodo[nPosSem,09] * ( ( DiasTrab - ( nDiasMat + nDPrgSalMa ) ) / nDiasPer ), 2 ) )
				Else
					nDiaTran  := aPeriodo[nPosSem,10]
					nDiaNTran := aPeriodo[nPosSem,9]
				EndIf
			EndIf
		EndIf

		// Ponto de entrada para alteracao dos dias de VTR e dias trabalhados no mes.
		If lGPVTRDias
			aVTRDias := {}
			aAdd(aVTRDias , {nDiaNTran, nDiaTran, nDiasProp, nDiasFix } )
			aVTRDias := ExecBlock("GPVTRDias",.F.,.F.)

			If ValType(aVTRDias) == "A" .And. Len(aVTRDias) > 0 .And. Len(aVTRDias[1]) >= 4
				nDiaNTran := aVTRDias[1,1]
				nDiaTran  := aVTRDias[1,2]
				nDiasProp := aVTRDias[1,3]
				nDiasFix  := aVTRDias[1,4]
			EndIf
		EndIf

		//Caso informe dias proporcionais, considera o valor como dias úteis de VT
		If( !Empty(SR0->R0_DPROPIN), nDiaTran := nDiasProp, )
		If( nDiasFix > 0 .And. ( Empty(SR0->R0_DPROPIN) .Or. fIntRHGS() ), nDiaTran := nDiasFix, )
		//Considera dias fixos caso use integração com Serviços; para os demais, apenas considera fixos caso não informe dias proporcionais
		nDiasProp := nDiaTran + nDiaNTran
		nDiaUcal  := ( nDiaTran * nDiaUtil ) - aPergunte[6,3]
		nDiaNUCal := nDiaNTran * nDiaNUtil

		nDiasVTR  := Max( If( nDiasFix > 0 .And. ( Empty(SR0->R0_DPROPIN) .Or. fIntRHGS() ), nDiasFix * nDiaUtil, nDiaUCal + nDiaNUCal - ( nFaltas * nDiaUtil ) ), 0 )
		nValVTR  := nDiasVTR * nValUni
	EndIf

	If aPergunte[1,3] == 2
		nTotVTR += nValVTR + SR0->R0_VALCAL
	Else
		nTotVTR += nValVTR
	EndIf

	cKeyAux := SR0->(R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO)

		aAdd(aVTCalc , {cKeyAux, nDiasVTR, nValUni, nValVTR,  nCustFunc,(nValVTR-nCustFunc), nValUniDif, nDiasProp, 0 } )

	SR0->(dbSkip())

EndDo

For nX := 1 to Len(aVTCalc)
	aVTCalc[nX,9] := nTotVTR //Atualiza valor total de vale transporte
	If nCustFunc > nTotVTR
		aVTCalc[nX,5] := aVtCalc[nX,4] //Se Custo funcionario for maior que soma do total de VT, custo do funcinario passa a ser o valor total do VT
		aVTCalc[nX,6] := 0
	Else
		If aPergunte[1,3] == 2
			aVTCalc[nX,5] := 0 // Custo Funcionario
			aVTCalc[nX,6] := aVTCalc[nX,4] //Custo Empresa
		Else
			aVTCalc[nX,5] := Round(nCustFunc / nTotVTR * aVTCalc[nX,4],2) //Rateia custo do VT
			If nX == Len(aVTCalc)
				aVTCalc[nX,5] := nCustFunc - nValAux //Força com que, mesmo com arredondamento, a somatória dos valores seja idência aos 6% definidos originalmente.
			Else
				nValAux += aVTCalc[nX,5]
			EndIf
			aVTCalc[nX,6] := aVTCalc[nX,4] - aVTCalc[nX,5] //Custo Empresa
			nCustAux += aVTCalc[nX,5]
		EndIf
	EndIf
Next nX

RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fVTRCalcN	   ºAutor  ³Leandro Drumond  º Data ³  25/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Calculo do Vale Transporte								      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVTRCalcN(aVTCalc)
Local aArea		:= GetArea()
Local cFilFunc  := SRA->RA_FILIAL
Local cMatFunc  := SRA->RA_MAT
Local cKeyAux	:= ""
Local nCustFunc := 0
Local nDiaNUtil	:= 0
Local nDiaUtil	:= 0
Local nDiasFix	:= 0
Local nValUni	:= 0
Local nValUniAnt:= 0
Local nValUniDif:= 0
Local nDiaTran	:= 0
Local nDiaNTran	:= 0
Local nDiaUCal	:= 0
Local nDiaNUCal	:= 0
Local nValVTR	:= 0
Local nTotVTR	:= 0
Local nDiasVTR	:= 0
Local nDiasProp	:= 0
Local nX		:= 0
Local nPos		:= 0
Local lPeriodico	:= aPergunte[1,3] == 3//Avulso/Complemnto/Semanal/diario
Local nDiasSeg 		:= 0									//-- Qtde Segundas trabalhadas
Local nDiasTer 		:= 0									//-- Qtde Tercas trabalhadas
Local nDiasQua		:= 0									//-- Qtde Quartas trabalhadas
Local nDiasQui 		:= 0									//-- Qtde Quintas trabalhadas
Local nDiasSex 		:= 0									//-- Qtde Sextas trabalhadas
Local nDiasSab 		:= 0									//-- Qtde Sabados trabalhadas
Local nDiasDom 		:= 0									//-- Qtde Domingos trabalhadas
Local nDiasPonto 	:= 0
Local nFalAux		:= 0
Local lDias			:= .F.
Local lFeriado 		:= .F.
Local lPropFerias	:= APERGUNTE[4,3] == 1 .Or. APERGUNTE[3,3] == 1 .Or. APERGUNTE[3,3] == 3
Local aTabCalend	:= If (!lUsaCPer,fCarPonto(),{})
Local lSP7			:= .F.
Local dDt1			:= ctod("")
Local dDt2			:= ctod("")
Local nH			:= 0
Local nDiaNTraPE	:= 0
Local nDiaTraPE		:= 0
Local nCustAux		:= 0
Local nDias			:= 0
Local nDNUtil		:= 0
Local nDUtil		:= 0

Private nPercentual := RetValSRV(aCodFol[051,1],SRA->RA_FILIAL,"RV_PERC")
Private aVTRDias    := {}

DEFAULT lGp210Sal	:= ExistBlock("GP210SAL")
DEFAULT lGPVTRDias  := ExistBlock("GPVTRDias")
DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

If lGp210Sal
	EXECBLOCK("GP210SAL", .F. , .F. ) //Retorna nPercentual
	If ValType(nPercentual) <> "N"
		nPercentual := 6
	EndIf
EndIf

If SRA->RA_CATFUNC $ "E*G"
	nCustFunc := nPercentual := 0
Else
	nCustFunc := Round(NSALBSVT * ( nPercentual / 100 ),2) //Custo Mensal do Funcionario
EndIf

If lPeriodico .and. nCustFunc > 0//Verifica se já houve pagamento de VT no mês para abater o custo do funcionário
	SR0->(DbSetOrder(3)) //R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO+R0_PEDIDO
	If SR0->(DbSeek(SRA->RA_FILIAL +  SRA->RA_MAT + "0"))
		While(SR0->(!Eof() .and. R0_FILIAL + R0_MAT + R0_TPVALE == SRA->RA_FILIAL +  SRA->RA_MAT + "0"))
			If SR0->R0_PERIOD == cPeriodo .and. SR0->R0_PEDIDO == "2" //Apenas pedidos concluídos
				nCustFunc -= SR0->R0_VLRFUNC
			EndIf
			SR0->(DbSkip())
		EndDo
		nCustFunc := Max(nCustFunc,0)
	EndIf
EndIf

If !lUsaCPer .And. Len(aTabCalend) > 1
	SPA->( dbSeek( xFilial("SPA", SRA->RA_FILIAL ) + SRA->RA_REGRA ) )
	lFeriado := ( SPA->PA_FERIADO == "S" .Or. ( SPA->( Type("PA_RECBENF") ) != "U" .And. SPA->PA_RECBENF == "1" ) )
EndIf

If __lMemCalc
	fAddMemLog("Calendario utilizado(MV_USACPER) : " +If(lUsaCPer,"FOLHA","PONTO") ,1,1)
	fAddMemLog("Considera feriado cadastro de Regra(SPA) : " + If(lFeriado,"Sim","Não") ,1,1)
	If !lUsaCPer
		fAddMemLog("Tabela padrão do ponto carregada : " + If(Len(aTabCalend) > 1 ,"Sim","Não") ,1,1)
	EndIf
	fAddMemLog("Proporcional a férias : " + If(lPropFerias,"Sim","Não") ,1,1)
	fAddMemLog("Calculo periódico : " + If(lPeriodico,"Sim","Não") ,1,1)
EndIf

aVTCalc	  := {}

DbSelectArea("SM7")
SM7->(DbSetOrder(RetOrder("SM7", "M7_FILIAL+M7_MAT+M7_TPVALE+M7_CODIGO")))

If SM7->(DbSeek(cFilFunc + cMatFunc + "0"))
	While SM7->(!Eof() .and. M7_FILIAL + M7_MAT + M7_TPVALE == cFilFunc + cMatFunc + "0")

		nFalAux := 0

		If lPeriodico .And. aPergunte[14,3] == 1 .And. SM7->M7_COMPL <> '1'
			SM7->(dbSkip())
			Loop
		EndIf

		lDias :=  SM7->M7_VALSEG > 0 .Or. SM7->M7_VALTER  > 0 .Or. SM7->M7_VALQUA  > 0 .Or.  SM7->M7_VALQUI  > 0 .Or.  SM7->M7_VALSEX  > 0 .Or.  SM7->M7_VALSAB  > 0 .Or.  SM7->M7_VALDOM >0
		aDiaVales := {SM7->M7_VALSEG , SM7->M7_VALTER , SM7->M7_VALQUA , SM7->M7_VALQUI , SM7->M7_VALSEX , SM7->M7_VALSAB , SM7->M7_VALDOM}
		nDiasSeg := 0									//-- Qtde Segundas trabalhadas
		nDiasTer := 0									//-- Qtde Tercas trabalhadas
		nDiasQua := 0									//-- Qtde Quartas trabalhadas
		nDiasQui := 0									//-- Qtde Quintas trabalhadas
		nDiasSex := 0									//-- Qtde Sextas trabalhadas
		nDiasSab := 0									//-- Qtde Sabados trabalhadas
		nDiasDom := 0
		nDias    := 0
		nDNUtil	 := 0
		nDUtil	 := 0

		nDiaNUtil := SM7->M7_QDNUTIL //Qtde vale em dias não úteis de VT
		nDiaUtil  := SM7->M7_QDIAINF //Qtde vale em dias úteis de VT
		nDiasProp := SM7->M7_DPROPIN
		nValUni	  := PosAlias( "SRN" , SM7->M7_CODIGO , xFilial("SRN") , "RN_VUNIATU" , 1 )
		nDiasFix  := PosAlias( "SRN" , SM7->M7_CODIGO , xFilial("SRN") , "RN_DIASFIX" , 1 )

		If !lUsaCPer .And. SM7->M7_VALFIX > 0
			nDiasFix := SM7->M7_VALFIX
		EndIf

		If SM7->M7_DPROPIN == 99 //Se diasprop for 99 não calcula meio de transporte
			SM7->(DbSkip())
			Loop
		EndIf

		If lPeriodico //complemento
			nDiasFix	:= 0
			nDiaNUtil 	:= 0
			If aPergunte[11,3] > 0
				nDiaUtil	:= aPergunte[11,3]
			EndIf
			aPergunte[6,3] 	:= 0 //vales a deduzir
		EndIf

		If __lMemCalc
			fAddMemLog("Benefício : " + SM7->M7_CODIGO ,1,1)
			fAddMemLog("Benefício avulso : " +If(SM7->M7_COMPL=="1","SIM","NÃO") ,1,1)
			fAddMemLog("Dias da semana preenchidos : " +If(lDias,"SIM","NÃO") ,1,1)
			fAddMemLog("Dias fixos : " + cvaltochar(nDiasFix) ,1,1)
			fAddMemLog("Quantidade de vales dias úteis : " + cvaltochar(nDiaUtil) ,1,1)
			fAddMemLog("Quantidade de vales dias não úteis : " + cvaltochar(nDiaNUtil) ,1,1)
			fAddMemLog("Quantidade de vales proporcionais : " + cvaltochar(nDiasProp) ,1,1)
			If lPeriodico
				fAddMemLog("Vales por dia informados : " + cvaltochar(nDiaUtil) ,1,1)
			EndIf
			fAddMemLog("vales a deduzir informado : " + cvaltochar(aPergunte[6,3]) ,1,1)
			fAddMemLog("Faltas  : " + cvaltochar(nFaltas) ,1,1)
			fAddMemLog("Valor Unitário  : " + Transform(nValUni,"@E 999,999,999.99") ,1,1)
		EndIf

		If aPergunte[1,3] == 2 //Se for calculo da diferenca
			SQY->(dbSeek(xFilial("SQY")+SM7->M7_CODIGO+dtos(aPeriodo[nPosSem,3]),.T.))
			if SQY->QY_COD == SM7->M7_CODIGO .AND. (SQY->QY_DATVIGE >= aPeriodo[nPosSem,3] .and. SQY->QY_DATVIGE <= aPeriodo[nPosSem,4])
				nValUniAnt := SQY->QY_VUNIANT
				nValUniDif := nValUni - nValUniAnt
				nDiasVtr := 0
				for nh := 1 to len(aPeriodo[nPosSem][5])
					if aPeriodo[nPosSem][5][nh][1] >= SQY->QY_DATVIGE.and. aPeriodo[nPosSem][5][nh][3] == '1'
						nDiasVTR ++
					EndIf
				Next
			Else
				nValUniAnt := PosAlias( "SRN" , SM7->M7_CODIGO , xFilial("SRN") , "RN_VUNIANT" , 1 )
				nValUniDif := nValUni - nValUniAnt
				nDiasVTR   := aPeriodo[nPosSem,11] //RCF_DDIFVT
			EndIf
			nValVTR    := (nDiasVTR  * nDiaUtil) * nValUniDif
			nDiasProp  := 0	//Zera pois nao sera utilizado
		Else
			nDiaTran  := 0
			nDiaNTran := 0
			If Empty(nDiasFix) .And. Empty(nDiasProp)	//Caso informe dias proporcionais ou fixos, considera os dias informados ao invés de calcular
				If !lUsaCPer .And. Len(aTabCalend) > 1 .And. lDias
					
					GetDiasTab(aTabCalend,aDiaVales,lPropFerias,lFeriado,.T.,nDUtil,nDiaNUtil,@nDiasSeg,@nDiasTer,@nDiasQua,@nDiasQui,@nDiasSex,@nDiasSab,@nDiasDom,@nDias,@nDiaNTran)

					//-- Calculo dos Dias Uteis     ( Qtde de cada dia semana * No vales de cada dia da semana ) - deducao
					nDiaTran := nDiasSeg + nDiasTer + nDiasQua + nDiasQui + nDiasSex  + nDiasSab + nDiasDom
					
					nDiasPonto	:= ( ( nDiasSeg * SM7->M7_VALSEG) + ( nDiasTer * SM7->M7_VALTER ) + ( nDiasQua *  SM7->M7_VALQUA ) + ( nDiasQui * SM7->M7_VALQUI ) + ( nDiasSex * SM7->M7_VALSEX ) + ( nDiasSab * SM7->M7_VALSAB ) + ( nDiasDom * SM7->M7_VALDOM ) )

					nDiaUCal  := nDiasPonto - aPergunte[6,3]
					nDiaNUCal := 0

					If nFaltas > 0 .and. Len(aFaltas) > 0
						If SM7->M7_VALDOM > 0
							nFalAux += aFaltas[1] * SM7->M7_VALDOM
						EndIf
						If SM7->M7_VALSEG > 0
							nFalAux += aFaltas[2] * SM7->M7_VALSEG
						EndIf
						If SM7->M7_VALTER > 0
							nFalAux += aFaltas[3] * SM7->M7_VALTER
						EndIf
						If SM7->M7_VALQUA > 0
							nFalAux += aFaltas[4] * SM7->M7_VALQUA
						EndIf
						If SM7->M7_VALQUI > 0
							nFalAux += aFaltas[5] * SM7->M7_VALQUI
						EndIf
						If SM7->M7_VALSEX > 0
							nFalAux += aFaltas[6] * SM7->M7_VALSEX
						EndIf
						If SM7->M7_VALSAB > 0
							nFalAux += aFaltas[7] * SM7->M7_VALSAB
						EndIf
						nDiaUCal -= nFalAux
					EndIf
				Else
					If !Empty(aDiasMes) //Se existir dados no array aDiasMes, utiliza estes dados para montar dias uteis e nao uteis de vale transporte
						If __lMemCalc
							fAddMemLog("Calendario ANALÍTICO " ,1,1)
						EndIf

						If lPeriodico
							nPos := aScan(aDiasMes,{|x| x[1] == aPergunte[12,3]})
						EndIf
						If nPos == 0
							nPos := 1
						EndIf
						aEval(aDiasMes, {|x| If(x[2] == "1" .And. x[3] == "1", nDUtil ++, If(x[2] != "1" .And. x[3] == "1", nDNUtil ++,  ))})
						For nX := nPos to Len(aDiasMes)
							If (!lUsaCPer .And. aDiasMes[nX,4]) .Or. (aDiasMes[nX,2] == "1" .and. (Empty(dDataDem) .OR. aDiasMes[nX,1] < dDataDem) .and. aDiasMes[nX,4])
								nDiaTran += 1
							ElseIf (!lUsaCPer .And. aDiasMes[nX,4]) .Or. (aDiasMes[nX,2] <> "1" .and. (Empty(dDataDem) .OR. aDiasMes[nX,1] < dDataDem) .and. aDiasMes[nX,4])
								nDiaNTran += 1
							EndIf
							If lPeriodico .And. aDiasMes[nX][1]==aPergunte[13,3]
								exit
							EndIf
						Next nX
					Else //do contrario utiliza cadastro de periodo - RCF_DUTILT e RCF_DNUTIL
						If __lMemCalc
							fAddMemLog("Calendario SINTÉTICO " ,1,1)
						EndIf

						If lPeriodico
							nDiaTran  := DateDiffDay( aPergunte[12,3],aPergunte[13,3] ) + 1
							nDiaNTran := 0
						Else
							nDiaTran  := aPeriodo[nPosSem,10]
							nDiaNTran := aPeriodo[nPosSem,9]
						EndIf
					EndIf
					If __lMemCalc
						fAddMemLog("Dias úteis : " +  cvaltochar(nDiaTran) ,1,1)
						fAddMemLog("Dias não úteis : " +  cvaltochar(nDiaNTran) ,1,1)
					EndIf
					nDiaUCal  := ( nDiaTran * nDiaUtil ) - aPergunte[6,3]
					nDiaNUCal := nDiaNTran * nDiaNUtil
				EndIf
			EndIf

			// Ponto de entrada para alteracao dos dias de vales e dias trabalhados no mes.
			If lGPVTRDias
				aVTRDias := {}
				aAdd(aVTRDias , {nDiaNTran, nDiaTran, nDiasProp, nDiasFix } )
				aVTRDias := ExecBlock("GPVTRDias",.F.,.F.)

				If ValType(aVTRDias) == "A" .And. Len(aVTRDias) > 0 .And. Len(aVTRDias[1]) >= 4
					nDiaNTraPE	:= aVTRDias[1,1]
					nDiaTraPE	:= aVTRDias[1,2]
					nDiasProp	:= aVTRDias[1,3]
					nDiasFix	:= aVTRDias[1,4]
				EndIf

				If ( nDiaNTraPE != nDiaNTran ) .Or. ( nDiaTraPE != nDiaTran )	//Se qtde. de dias úteis ou não úteis for alterada,
					nDiaNUCal += ( (nDiaNTraPE - nDiaNTran) * nDiaNUtil )
					nDiaUcal += ( (nDiaTraPE - nDiaTran) * nDiaUtil )			//soma com a quantidade de vales já calculada
					nDiaNTran := nDiaNTraPE
					nDiaTran  := nDiaTraPE										//e dias prop passa a ser informado
				EndIf
			EndIf

			//Considera dias fixos caso use integração com Serviços; para os demais, apenas considera fixos caso não informe dias proporcionais
			If nDiasFix > 0 .And. ( Empty(SM7->M7_DPROPIN) .Or. fIntRHGS() )
				nDiaTran  := nDiasFix
				nDiaNTran := 0
				nDiasProp := nDiasFix
			ElseIf !Empty(SM7->M7_DPROPIN) .And. nDiasProp > 0	//Caso informe dias proporcionais, considera o valor como dias úteis de VT e zera dias não úteis
				nDiaTran  := nDiasProp
				nDiaNTran := 0
				nDiaNUCal := 0
				nDiaUcal  := ( nDiaTran * nDiaUtil ) - aPergunte[6,3]
			EndIf

			If !lSP7 .And. nFaltas > 0 .And. nFaltas >= nDiaTran
				If lPeriodico
					dDt1	:= aPergunte[12,3]
					dDt2	:= aPergunte[13,3]
				Else
					dDt1	:= aPeriodo[nPosSem,3]
					dDt2	:= aPeriodo[nPosSem,4]
				EndIf
				GravaSP7(nDiaTran,dDt1,dDt2)
				lSP7 := .T.
			EndIf

			nDiasVTR  := Max( If( nDiasFix > 0 .And. ( Empty(SM7->M7_DPROPIN) .Or. fIntRHGS() ), nDiasFix * nDiaUtil, If (!lUsaCPer .And. Len(aTabCalend) > 1 .And. lDias, nDiaUCal ,nDiaUCal + nDiaNUCal - ( nFaltas * nDiaUtil ) ) ), 0 )
			nValVTR  := nDiasVTR * nValUni
			If __lMemCalc
				fAddMemLog("Dias de calculo : " +  cvaltochar(nDiasVTR) ,1,1)
				fAddMemLog("Valor calculo : " +  Transform(nValVTR,"@E 999,999,999.99") ,1,1)
			EndIf
		EndIf

		nTotVTR += nValVTR
		cKeyAux := SM7->(M7_FILIAL+M7_MAT+M7_TPVALE+M7_CODIGO)

		aAdd(aVTCalc , {cKeyAux, nDiasVTR, nValUni, nValVTR,  nCustFunc,(nValVTR-nCustFunc), nValUniDif, nDiasProp, 0 ,SM7->M7_CODIGO,Iif(ndias > 0,nDias,nDiaTran),nDiaUtil,nDiaNUtil,SM7->M7_TPCALC,aDiaVales,SM7->M7_VALFIX,If(!Empty(nDNUtil),nDNUtil,nDiaNTran),nDUtil,""} )

		If SM7->M7_COMPL == "1"
			RecLock("SM7",.F.)
			SM7->(dbDelete())
			SM7->(msUnlock())
		EndIf

		SM7->(dbSkip())

	EndDo
EndIf

If __lMemCalc
	fAddMemLog("Total VTR : " +  Transform(nTotVTR,"@E 999,999,999.99") ,1,1)
	fAddMemLog("Percentual funcionário  : " +  Transform(nPercentual,"@E 999,999,999.99") + " %" ,1,1)
	fAddMemLog("Teto do custo VT  = Salario Base * Percentual  : " +  Transform(nCustFunc,"@E 999,999,999.99")  ,1,1)
EndIf

For nX := 1 to Len(aVTCalc)
	aVTCalc[nX,9] := nTotVTR //Atualiza valor total de vale transporte
	If nCustFunc > nTotVTR
		aVTCalc[nX,5] := aVtCalc[nX,4] //Se Custo funcionario for maior que soma do total de VT, custo do funcinario passa a ser o valor total do VT
		aVTCalc[nX,6] := 0
	Else
		If nX == Len(aVTCalc)
			aVTCalc[nX,5] := nCustFunc - nCustAux //Rateia custo do VT
			aVTCalc[nX,6] := aVTCalc[nX,4] - aVTCalc[nX,5] //Custo Empresa
		Else
			aVTCalc[nX,5] := Round(aVTCalc[nX,5] / nTotVTR * aVTCalc[nX,4],2) //Rateia custo do VT
			aVTCalc[nX,6] := aVTCalc[nX,4] - aVTCalc[nX,5] //Custo Empresa
			nCustAux += aVTCalc[nX,5]
		EndIf
	EndIf
Next nX

RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fVTRGrv 	   ºAutor  ³Leandro Drumond  º Data ³  29/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Gravacao do calculo do vale transporte					      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVTRGrv(aVTCalc)
Local aArea		:= GetArea()
Local cKeyAux	:= ""
Local nX		:= 0

DEFAULT lGPM5001	:= ExistBlock("GPM5001")

DbSelectArea("SR0")
DbSetOrder(RetOrder("SR0", "R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO"))

For nX := 1 to Len(aVTCalc)
	cKeyAux := aVTCalc[nX,1]
	DbSeek(cKeyAux)
	If Reclock( "SR0" , .F. )
		If aVTCalc[nX,8] > 0
			SR0->R0_DIASPRO := aVTCalc[nX,8]  //Grava apenas se utilizou o campo R0_DPROPIN
		Else
			SR0->R0_DIASPRO := 0
		EndIf

		SR0->R0_DUTILM	:= aPeriodo[nPosSem,10] 	//Dias Uteis no Mês - campo RCF_DUTILT
		SR0->R0_DNUTIM	:= aPeriodo[nPosSem,9]		//Dias Não Uteis no Mês - campo RCF_DNUTIL
		SR0->R0_SALBASE	:= nSalmes					//Salário Base
		SR0->R0_CC		:= SRA->RA_CC				//Centro de Custo do Funcionário
		SR0->R0_FALTAS 	:= nFaltas					//Dias correspondentes à faltas (mnemônico NFALTAS)
		SR0->R0_FERIAS 	:= nFerVen					//Dias correspondentes a férias (mnemônico NFERVEN)
		SR0->R0_AFAST 	:= nDiasAfas				//Dias correspondentes a afastamentos (mnemônico NDIASAFAS)

		If aPergunte[1,3] == 2
			SR0->R0_QDIADIF	:= aVTCalc[nX,2]	//Dias de Difer. calculados
			SR0->R0_VALDIF 	:= aVTCalc[nX,4]	//Valor de Dif. VTR calculado
			SR0->R0_CUNIDF 	:= aVTCalc[nX,7]	//Custo Unitário de Difer. (RN_VUNIATU - RN_VUNIANT)
			SR0->R0_CFUNDF	:= aVTCalc[nX,5]	//Custo Funcionário Difer.
			SR0->R0_CEMPDF	:= aVTCalc[nX,6]	//Custo Empresa Difer.
		Else
			SR0->R0_QDIACAL	:= aVTCalc[nX,2]	//Dias calculados
			SR0->R0_VALCAL 	:= aVTCalc[nX,4] 	//Valor VTR calculado
			SR0->R0_VLRVALE	:= aVTCalc[nX,3]	//Custo Unitário
			SR0->R0_VLRFUNC	:= aVTCalc[nX,5] 	//Custo Funcionário
			SR0->R0_VLREMP 	:= aVTCalc[nX,6]	//Custo Empresa
		EndIf

		SR0->( MsUnLock() )
		//PE para gravar campos personalizados
		If lGPM5001
			ExecBlock("GPM5001",.F.,.F.)
		EndIf
	EndIf

Next nX

RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fVTRGrvN 	   ºAutor  ³Leandro Drumond  º Data ³  29/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Gravacao do calculo do vale transporte					      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVTRGrvN(aVTCalc)
Local aArea		:= GetArea()
Local cNumPed   := ""
Local cKey		:= ""
Local cCodCCT 	:= ""
Local nX		:= 0
Local nPos      := 0
Local lNovo		:= .T.
Local lPeriodico:= aPergunte[1,3] == 3//Avulso/Complemnto/Semanal/diario
Local lGpem040  := FunName() == "GPEM040" .or. FunName() == "GPEM040B"

DEFAULT lGPM5001  := ExistBlock("GPM5001")
DEFAULT lTemCCT	  := SR0->(ColumnPos("R0_CODCCT")) > 0

If lGpem040 //Se for rescisão, inclui valores calculados no array para desconto na rescisão

	aBenefRes[1] := aClone(aVTCalc)

Else

	If lTemCCT .and. !Empty(SRA->RA_SINDICA)
		cCodCCT := fBuscaCCT(SRA->RA_SINDICA)
	EndIf

	DbSelectArea("SR0")
	SR0->(DbSetOrder(RetOrder("SR0", "R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO+R0_PEDIDO")))

	// Exclui cálculo anterior para o mesmo período, caso exista
	cKey := SRA->RA_FILIAL + SRA->RA_MAT + "0"
	If SR0->(dbSeek(cKey))
		While SR0->(R0_FILIAL + R0_MAT + R0_TPVALE) == cKey
			//Somente deleta o cálculo se for recálculo. Caso o pedido já tenha sido emitido, não deleta.
			If SR0->R0_DTREFI == aPeriodo[nPosSem, 3] .And. SR0->R0_DTREFF == aPeriodo[nPosSem, 4] .And. SR0->R0_PEDIDO == "1" .AND. aPergunte[1,3] != 2 ;
				.Or. (Empty(SR0->R0_DTREFI) .And. Empty(SR0->R0_DTREFF) .And. SR0->R0_PEDIDO != "2")
				//Se já existir um cálculo em aberto, quer dizer que é recálculo, então armazena o numero do pedido já utilizado.
				If ( nPos := aScan(aVTCalc, {|x| x[1] == SR0->R0_FILIAL+SR0->R0_MAT+SR0->R0_TPVALE+SR0->R0_CODIGO}) ) > 0
					aVTCalc[nPos,19] := SR0->R0_NROPED
				EndIf
				Reclock("SR0", .F.)
				SR0->(dbDelete())
				SR0->(MsUnlock())
			EndIf
			SR0->(dbSkip())
		EndDo
		SR0->(dbGoTop())
	EndIf

	For nX := 1 to Len(aVTCalc)
		lNovo 	  := .T.
		cNumPed   := ""
		If SR0->(DbSeek(aVTCalc[nX, 1] + "1"))
			While SR0->( !EoF() ) .And. SR0->R0_FILIAL+SR0->R0_MAT+SR0->R0_TPVALE+SR0->R0_CODIGO+SR0->R0_PEDIDO == aVTCalc[nX, 1] + "1"
				If SR0->R0_NROPGT == aPeriodo[nPosSem, 2] 
					lNovo := .F.
					Exit
				EndIf
				SR0->( dbSkip() )
			EndDo
		EndIf
		If !lNovo .And. !Empty(SR0->R0_NROPED)
			cNroPed := SR0->R0_NROPED
		ElseIf lNovo
			cNumPed := aVTCalc[nX,19]
		EndIf
		If Reclock( "SR0" , lNovo)
			If aVTCalc[nX,8] > 0  .OR. (lUsaCPer .And. (aVTCalc[nX,11] != aPeriodo[nPosSem,10]))
				SR0->R0_DPROPIN := aVTCalc[nX,8]	// Grava apenas se utilizou o campo R0_DPROPIN
			Else
				SR0->R0_DPROPIN := 0
			EndIf
			SR0->R0_FILIAL	:= SRA->RA_FILIAL
			SR0->R0_MAT		:= SRA->RA_MAT
			SR0->R0_TPVALE	:= "0"
			SR0->R0_CODIGO	:= aVTCalc[nX,10]
			SR0->R0_DIASPRO	:= aVTCalc[nX,11]
			SR0->R0_QDIAINF	:= aVTCalc[nX,12]
			SR0->R0_QDNUTIL	:= aVTCalc[nX,13]
			SR0->R0_TPCALC	:= aVTCalc[nX,14]
			SR0->R0_ROTEIR	:= cRot
			SR0->R0_PERIOD 	:= cPeriodo
			SR0->R0_NROPGT	:= cNumPag
			SR0->R0_ANOMES	:= SubSTr(cPeriodo,5,2) + SubSTr(cPeriodo,1,4)
			SR0->R0_PEDIDO	:= "1"
			SR0->R0_QVALSEG  := aVTCalc[nX,15,1]
			SR0->R0_QVALTER  := aVTCalc[nX,15,2]
			SR0->R0_QVALQUA  := aVTCalc[nX,15,3]
			SR0->R0_QVALQUI  := aVTCalc[nX,15,4]
			SR0->R0_QVALSEX  := aVTCalc[nX,15,5]
			SR0->R0_QVALSAB  := aVTCalc[nX,15,6]
			SR0->R0_QVALDOM  := aVTCalc[nX,15,7]
			SR0->R0_QVALFIX  := aVTCalc[nX,16]

			If lPeriodico
				SR0->R0_DTREFI	:= aPergunte[12,3]
				SR0->R0_DTREFF	:= aPergunte[13,3]
			Else
				SR0->R0_DTREFI	:= aPeriodo[nPosSem,3]
				SR0->R0_DTREFF	:= aPeriodo[nPosSem,4]
			EndIf

			If lNovo
				//Caso não exista pedido, pode ser novo mês ou mais de 1 pedido no mês, então assume o novo número do pedido.
				If cNumPed <> ""
					cNroPed := cNumPed
				EndIf
				SR0->R0_NROPED	:= GetNroPed()
			EndIf
			SR0->R0_TPBEN	:= BuscaTBen(SR0->R0_TPVALE,SR0->R0_CODIGO,SR0->R0_FILIAL)

			SR0->R0_DUTILM	:= If(!Empty(aVTCalc[nX,18]), aVTCalc[nX,18], aVTCalc[nX,11])	//Dias Uteis no Mês - campo RCF_DUTILT
			SR0->R0_DNUTIM	:= aVTCalc[nX,17]			//Dias Não Uteis no Mês - campo RCF_DNUTIL
			SR0->R0_SALBASE	:= nSalmes					//Salário Base
			SR0->R0_CC		:= SRA->RA_CC				//Centro de Custo do Funcionário
			SR0->R0_FALTAS 	:= nFaltas					//Dias correspondentes à faltas (mnemônico NFALTAS)
			SR0->R0_FERIAS 	:= nFerVen					//Dias correspondentes a férias (mnemônico NFERVEN)
			SR0->R0_AFAST 	:= nDiasAfas				//Dias correspondentes a afastamentos (mnemônico NDIASAFAS)

			If aPergunte[1,3] == 2
				SR0->R0_QDIADIF	:= aVTCalc[nX,2]	//Dias de Difer. calculados
				SR0->R0_VALDIF 	:= aVTCalc[nX,4]	//Valor de Dif. VTR calculado
				SR0->R0_CUNIDF 	:= aVTCalc[nX,7]	//Custo Unitário de Difer. (RN_VUNIATU - RN_VUNIANT)
				SR0->R0_CFUNDF	:= aVTCalc[nX,5]	//Custo Funcionário Difer.
				SR0->R0_CEMPDF	:= aVTCalc[nX,6]	//Custo Empresa Difer.
			Else
				SR0->R0_QDIACAL	:= aVTCalc[nX,2]	//Dias calculados
				SR0->R0_VALCAL 	:= aVTCalc[nX,4] 	//Valor VTR calculado
				SR0->R0_VLRVALE	:= aVTCalc[nX,3]	//Custo Unitário
				SR0->R0_VLRFUNC	:= aVTCalc[nX,5] 	//Custo Funcionário
				SR0->R0_VLREMP 	:= aVTCalc[nX,6]	//Custo Empresa
			EndIf

			If lTemCCT
				SR0->R0_CODCCT 	:= cCodCCT	//Convenção Coletiva de Trabalho
			EndIf

			SR0->( MsUnLock() )

			//PE para gravar campos personalizados
			If lGPM5001
				ExecBlock("GPM5001",.F.,.F.)
			EndIf
		EndIf

		If cNumPed <> ""
			cNroPed := "" //Zera static para não usar o mesmo número para outro funcionário causando chave duplicada.
		EndIf

	Next nX

	CustoVales("0")

	RestArea(aArea)

EndIf

Return Nil


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fVRFCalc 	   ºAutor  ³Leandro Drumond  º Data ³  03/08/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Efetua o calculo do vale refeicao   					      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVRFCalc(aVRCalc)
Local aArea		:= GetArea()
Local aPerAux	:= {}
Local cFilFunc  := SRA->RA_FILIAL
Local cMatFunc  := SRA->RA_MAT
Local cKeyAux	:= ""
Local lPropin	:= .F.
Local lPriVez	:= .T.
Local nCustFunc := 0
Local nCustEmp	:= 0
Local nValVRF	:= 0
Local nDiaInf	:= 0
Local nValUni	:= 0
Local nPerc		:= 0
Local nTeto		:= 0
Local nDiasFix	:= 0
Local nDiaRef	:= 0
Local nDiaCal	:= 0
Local nX		:= 0
Local nTotDif	:= 0
Local nDiaUtil	:= 0
Local nDiaNUtil	:= 0
Local nDUtil	:= 0
Local nDNUtil	:= 0
Local nValOri	:= 0
Local nDiasPer	:= If(SuperGetMv("MV_DIASPER",,"1") == "1",nDiasP,(If(SRA->RA_TIPOPGT =="M", P_QTDIAMES, P_NTOTDIAS)))
Local nFaltVRF  := nFaltas

aVRCalc	  := {}

DbSelectArea("RFO")
DbSetOrder(RetOrder("RFO","RFO_FILIAL+RFO_TPVALE+RFO_CODIGO"))

DbSelectArea("SR0")
DbSetOrder(RetOrder("SR0", "R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO"))

If( DbSeek(cFilFunc + cMatFunc + "1") )

	While SR0->(!Eof() .and. R0_FILIAL + R0_MAT + R0_TPVALE == cFilFunc + cMatFunc + "1")

	    If SR0->R0_DPROPIN == 99 //Se diasprop for 99 não calcula meio de transporte
	    	SR0->(DbSkip())
	    	Loop
	    EndIf

	    nDUtil	  := SR0->R0_QDIAINF
	    nDNUtil	  := SR0->R0_QDNUTIL
    	nValUni   := 0
    	nPerc	  := 0
    	nTeto	  := 0
    	nDiasFix  := 0
    	nDiaRef	  := 0
		nDiaUtil  := 0
		nDiaNUtil := 0
    	lPropin	  := .F.

	    If RFO->(DbSeek(xFilial("RFO")+SR0->(R0_TPVALE + R0_CODIGO)))
	    	nValUni  := RFO->RFO_VALOR
	    	nPerc	 := RFO->RFO_PERC
	    	nTeto	 := RFO->RFO_TETO
	    	nDiasFix := RFO->RFO_DIAFIX
	    EndIf

	    If SR0->R0_DPROPIN > 0
	    	nDiaRef := SR0->R0_DPROPIN
	    	lPropin	:= .T.
    	ElseIf !Empty(aDiasMes)	//Se existir dados no array aDiasMes, utiliza estes dados para montar dias uteis e nao uteis de vale transporte (analitico)
			For nX := 1 to Len(aDiasMes)
				If aDiasMes[nX,2] == "1" .and. aDiasMes[nX,3] == "1" .and. aDiasMes[nX,4]
					nDiaUtil += 1
				ElseIf aDiasMes[nX,2] <> "1" .and. aDiasMes[nX,3] == "1" .and. aDiasMes[nX,4]
					nDiaNUtil += 1
				EndIf
			Next nX
		Else				//do contrario utiliza cadastro de periodo - RCF_DUTILT e RCF_DNUTIL (sintetico)
			If aPergunte[2,3] <> 2 .And. DiasTrab < nDiasPer
				nDiaUtil  := Int( Round( aPeriodo[nPosSem,12] * ( ( DiasTrab - ( nDiasMat + nDPrgSalMa ) ) / nDiasPer ), 2 ) )
				nDiaNUtil := 0
			Else
				nDiaUtil  := aPeriodo[nPosSem,12]
				nDiaNUtil := 0
			EndIf
		EndIf

    	If nDiasFix > 0
    		nDiaCal := iif(!Empty(nDiaRef) .and. lPropin ,nDiaRef,nDiasFix) // Quando o nDiaRef estiver preenchido é mandatório, pois deve ser considerado primeiro que o nDiasFix
    	Else
    		If nDiaRef > 0
    			nDiaInf := nDUtil
    			nDiaCal := Max( ( nDiaRef - nFaltVRF ) * nDiaInf - aPergunte[5,3], 0 ) //Parametro MV_PAR05 - Deducoes
    		Else
    			nDiaRef   := nDiaUtil + nDiaNUtil
	    		nDiaCal   := ( (( nDiaUtil * nDUtil ) - aPergunte[5,3]) + (nDiaNUtil * nDNUtil) ) - (nFaltVRF * nDUtil)
	    	EndIf

			If nDUtil > 0
				nFaltVRF := 0
			EndIf
    	EndIf

    	nValVRF 	:= nDiaCal * nValUni

    	//Inicio do trecho para recalculo dos beneficios gerados pela integração com serviços
    	cKeyAux := SR0->(R0_FILIAL + R0_MAT + R0_TPVALE + R0_CODIGO)

		//Inicio do trecho para recalculo dos beneficios gerados pela integração com serviços

		//Recalcula último VR pago por critérios definidos na intergração com serviços para verificar se deve ser feito algum desconto ou acréscimo
		If lPriVez .And. ( fIntRHGS() .AND. SuperGetMv("MV_BENEXGS",,.T.) )
			fRetBenAnt(SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_PROCES, "1", @aPerAux)
			If Len(aPerAux) > 0
				nTotDif := fApurPAnt(aPerAux[1], "1")[1]
			EndIf
			lPriVez := .F.
		EndIf

		nValOri := nValVRF // Guarda o valor calculado originalmente

		If nTotDif != 0

			If nTotDif > 0 //Se houver diferença positiva para pagar em relação ao mês anterior, soma no valor total do VR
				nValVRF += nTotDif
				nTotDif := 0
			ElseIf ( nValVRF + nTotDif ) >= 0
				nValVRF += nTotDif
				nTotDif := 0
			Else
				nTotDif += nValVRF
				nValVRF := 0
			EndIf

		EndIf

		//Fim do trecho para recalculo dos beneficios gerados pela integração com serviços

		nCustFunc   := Round(( nValVRF * nPerc ) / 100,2)
		If nTeto > 0
			nCustFunc   := Min(nCustFunc, nTeto)
		EndIf
		nCustEmp	:= nValVRF - nCustFunc

		Aadd(aVRCalc , {cKeyAux, nDiaCal, nValUni, nValVRF,  nCustFunc, nCustEmp, nDiaRef, lPropin, 0, nValOri,,,,,,,,,nDiaUtil,nDiaNUtil} )

		SR0->(DbSkip())

	EndDo

	If nTotDif < 0 //Grava o saldo negativo no último vale calculado
		aVRCalc[Len(aVRCalc),9] := nTotDif
	EndIf

EndIf

RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fVRFCalcN 	   ºAutor  ³Leandro Drumond  º Data ³  03/08/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Efetua o calculo do vale refeicao   					      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVRFCalcN(aVRCalc)
Local aArea			:= GetArea()
Local aPerAux		:= {}
Local aDias			:= {}
Local cFilFunc  	:= SRA->RA_FILIAL
Local cMatFunc  	:= SRA->RA_MAT
Local cKeyAux		:= ""
Local lPropin		:= .F.
Local lPriVez		:= .T.
Local nCustFunc 	:= 0
Local nCustEmp		:= 0
Local nValVRF		:= 0
Local nDiaInf		:= 0
Local nValUni		:= 0
Local nPerc			:= 0
Local nTeto			:= 0
Local nDiasFix		:= 0
Local nDiaRef		:= 0
Local nDiaCal		:= 0
Local nX			:= 0
Local nTotDif		:= 0
Local nValOri		:= 0
Local nDiasProp 	:= 0
Local lPeriodico	:= aPergunte[6,3] == 1//Avulso/Complemnto/Semanal/diario
Local nPos			:= 0
Local nDiasSeg 		:= 0									//-- Qtde Segundas trabalhadas
Local nDiasTer 		:= 0									//-- Qtde Tercas trabalhadas
Local nDiasQua 		:= 0									//-- Qtde Quartas trabalhadas
Local nDiasQui 		:= 0									//-- Qtde Quintas trabalhadas
Local nDiasSex 		:= 0									//-- Qtde Sextas trabalhadas
Local nDiasSab 		:= 0									//-- Qtde Sabados trabalhadas
Local nDiasDom 		:= 0									//-- Qtde Domingos trabalhadas
Local nDiasPonto 	:= 0
Local nDiaUtil		:= 0
Local nDiaNUtil		:= 0
Local nDUtil		:= 0
Local nDNUtil		:= 0
Local nAuxUtil		:= 0
Local nAuxNUtil		:= 0
Local nFalAux		:= 0
Local lDias			:= .F.
Local lFeriado 		:= .F.
Local lPropFerias	:= APERGUNTE[3,3] == 1
Local aTabCalend	:= If (!lUsaCPer,fCarPonto(),{})
Local aDiaVales		:= {}
Local lSP7			:= .F.
Local dDt1			:= ctod("")
Local dDt2			:= ctod("")
Local nDiasPer		:= If(GetMvRH("MV_DIASPER",,"1") == "1",nDiasP,(If(SRA->RA_TIPOPGT =="M", P_QTDIAMES, P_NTOTDIAS)))

DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo


If !lUsaCPer .And. Len(aTabCalend) > 1
	SPA->( dbSeek( xFilial("SPA", SRA->RA_FILIAL ) + SRA->RA_REGRA ) )
	lFeriado := ( SPA->PA_FERIADO == "S" .Or. ( SPA->( Type("PA_RECBENF") ) != "U" .And. SPA->PA_RECBENF == "1" ) )
EndIf

If __lMemCalc
	fAddMemLog("Calendario utilizado(MV_USACPER) : " +If(lUsaCPer,"FOLHA","PONTO") ,1,1)
	fAddMemLog("Considera feriado cadastro de Regra(SPA) : " + If(lFeriado,"Sim","Não") ,1,1)
	If !lUsaCPer
		fAddMemLog("Tabela padrão do ponto carregada : " + If(Len(aTabCalend) > 1 ,"Sim","Não") ,1,1)
	EndIf
	fAddMemLog("Proporcional a férias : " + If(lPropFerias,"Sim","Não") ,1,1)
	fAddMemLog("Calculo periódico : " + If(lPeriodico,"Sim","Não") ,1,1)
	fAddMemLog("Dias período : " + cvaltochar(nDiasPer) ,1,1)
EndIf

aVRCalc	  := {}

DbSelectArea("RFO")
RFO->(DbSetOrder(RetOrder("RFO","RFO_FILIAL+RFO_TPVALE+RFO_CODIGO")))

DbSelectArea("SM7")
SM7->(DbSetOrder(RetOrder("SM7", "M7_FILIAL+M7_MAT+M7_TPVALE+M7_CODIGO")))

If SM7->(DbSeek(cFilFunc + cMatFunc + "1") )

	While SM7->(!Eof() .and. M7_FILIAL + M7_MAT + M7_TPVALE == cFilFunc + cMatFunc + "1")

		nFalAux := 0

		If lPeriodico .And. aPergunte[10,3] == 1 .And. SM7->M7_COMPL <> '1'
			SM7->(dbSkip())
			Loop
		EndIf

		If SM7->M7_DPROPIN == 99 //Se diasprop for 99 não calcula meio de transporte
			SM7->(DbSkip())
			Loop
		EndIf

		lDias :=  SM7->M7_VALSEG > 0 .Or. SM7->M7_VALTER  > 0 .Or. SM7->M7_VALQUA  > 0 .Or.  SM7->M7_VALQUI  > 0 .Or.  SM7->M7_VALSEX  > 0 .Or.  SM7->M7_VALSAB  > 0 .Or.  SM7->M7_VALDOM >0
		aDiaVales := {SM7->M7_VALSEG , SM7->M7_VALTER , SM7->M7_VALQUA , SM7->M7_VALQUI , SM7->M7_VALSEX , SM7->M7_VALSAB , SM7->M7_VALDOM}

		nDiasSeg := 0									//-- Qtde Segundas trabalhadas
		nDiasTer := 0									//-- Qtde Tercas trabalhadas
		nDiasQua := 0									//-- Qtde Quartas trabalhadas
		nDiasQui := 0									//-- Qtde Quintas trabalhadas
		nDiasSex := 0									//-- Qtde Sextas trabalhadas
		nDiasSab := 0									//-- Qtde Sabados trabalhadas
		nDiasDom := 0

		nDUtil	 := SM7->M7_QDIAINF
	    nDNUtil	 := SM7->M7_QDNUTIL
		nDiasProp := SM7->M7_DPROPIN
		nValUni  := 0
		nPerc	 := 0
		nTeto	 := 0
		nDiasFix := 0
		nDiaRef	 := 0
		lPropin	 := .F.
		nDiaUtil := 0
		nDiaNUtil:= 0

		If RFO->(DbSeek(xFilial("RFO")+SM7->(M7_TPVALE + M7_CODIGO)))
			nValUni  := RFO->RFO_VALOR
			nPerc	 := RFO->RFO_PERC
			nTeto	 := RFO->RFO_TETO
			nDiasFix := RFO->RFO_DIAFIX
		EndIf

		If !lUsaCPer .And. SM7->M7_VALFIX > 0
			nDiasFix := SM7->M7_VALFIX
		EndIf

		If lPeriodico //complemento
			nDiasFix	:= 0
			nDiaInf	  := SM7->M7_QDIAINF
			If aPergunte[7,3] > 0
				nDiaInf	:= aPergunte[7,3]
			EndIf
			aPergunte[5,3] 	:= 0 //vales a deduzir
		EndIf
		If __lMemCalc
			fAddMemLog("Benefício : " + SM7->M7_CODIGO ,1,1)
			fAddMemLog("Benefício avulso : " +If(SM7->M7_COMPL=="1","SIM","NÃO") ,1,1)
			fAddMemLog("Dias da semana preenchidos : " +If(lDias,"SIM","NÃO") ,1,1)
			fAddMemLog("Dias fixos : " + cvaltochar(nDiasFix) ,1,1)
			fAddMemLog("Quantidade de vales dias úteis : " + cvaltochar(nDUtil) ,1,1)
			fAddMemLog("Quantidade de vales dias não úteis : " + cvaltochar(nDNUtil) ,1,1)
			fAddMemLog("Quantidade de vales proporcionais : " + cvaltochar(nDiasProp) ,1,1)
			If lPeriodico
				fAddMemLog("Vales por dia informados : " + cvaltochar(nDiaInf) ,1,1)
			EndIf
			fAddMemLog("vales a deduzir informado : " + cvaltochar(aPergunte[5,3]) ,1,1)
			fAddMemLog("Faltas  : " + cvaltochar(nFaltas) ,1,1)
			fAddMemLog("Valor Unitário  : " + Transform(nValUni,"@E 999,999,999.99") ,1,1)
		EndIf
		If nDiasProp > 0
			nDiaRef := nDiasProp
			lPropin	:= .T.
			nDiaCal := Max( ( nDiaRef - If(nDUtil > 0,nFaltas,0) ) * If (lPeriodico, nDiaInf - aPergunte[5,3], nDUtil), 0 ) //Parametro MV_PAR05 - Deducoes
		Else
			If nDiasFix > 0
				nDiaRef  := nDiasFix
				nDiasProp := nDiasFix
				nDiaCal :=  nDiaRef - aPergunte[5,3] //Parametro MV_PAR05 - Deducoes
			Else

				If !lUsaCPer .And. Len(aTabCalend) > 1 .And. lDias

					GetDiasTab(aTabCalend,aDiaVales,lPropFerias,lFeriado,.F.,nDUtil,nDNUtil,@nDiasSeg,@nDiasTer,@nDiasQua,@nDiasQui,@nDiasSex,@nDiasSab,@nDiasDom,@nDiaUtil,@nDiaNUtil)

					//-- Calculo dos Dias Uteis     ( Qtde de cada dia semana * No vales de cada dia da semana ) - deducao
					nDiaRef := nDiasSeg + nDiasTer + nDiasQua + nDiasQui + nDiasSex  + nDiasSab + nDiasDom
					
					nDiasPonto	:= ( ( nDiasSeg * SM7->M7_VALSEG) + ( nDiasTer * SM7->M7_VALTER ) + ( nDiasQua *  SM7->M7_VALQUA ) + ( nDiasQui * SM7->M7_VALQUI ) + ( nDiasSex * SM7->M7_VALSEX ) + ( nDiasSab * SM7->M7_VALSAB ) + ( nDiasDom * SM7->M7_VALDOM ) )
					nDiaCal := nDiasPonto - aPergunte[5,3] //Parametro MV_PAR05 - Deducoes
					
					If nFaltas > 0 .and. Len(aFaltas) > 0
						If SM7->M7_VALDOM > 0
							nFalAux += aFaltas[1]
						EndIf
						If SM7->M7_VALSEG > 0
							nFalAux += aFaltas[2]
						EndIf
						If SM7->M7_VALTER > 0
							nFalAux += aFaltas[3]
						EndIf
						If SM7->M7_VALQUA > 0
							nFalAux += aFaltas[4]
						EndIf
						If SM7->M7_VALQUI > 0
							nFalAux += aFaltas[5]
						EndIf
						If SM7->M7_VALSEX > 0
							nFalAux += aFaltas[6]
						EndIf
						If SM7->M7_VALSAB > 0
							nFalAux += aFaltas[7]
						EndIf
						nDiaCal -= nFalAux
					EndIf
				Else
					If !Empty(aDiasMes)	//Se existir dados no array aDiasMes, utiliza estes dados para montar dias uteis e nao uteis de vale transporte (analitico)
						If __lMemCalc
							fAddMemLog("Calendario ANALÍTICO " ,1,1)
						EndIf
						nDiaRef  := 0
						If lPeriodico
							nPos := aScan(aDiasMes,{|x| x[1] == aPergunte[8,3]})
						EndIf
						If nPos == 0
							nPos := 1
						EndIf
						For nX := nPos to Len(aDiasMes)
							If aDiasMes[nX,2] == "1" .and. (Empty(dDataDem) .OR. aDiasMes[nX,1] < dDataDem) .and. aDiasMes[nX,3] == "1" .and. aDiasMes[nX,4]
								nDiaUtil += 1
							ElseIf aDiasMes[nX,2] <> "1" .and. (Empty(dDataDem) .OR. aDiasMes[nX,1] < dDataDem) .and. aDiasMes[nX,3] == "1" .and. aDiasMes[nX,4]
								nDiaNUtil += 1
							EndIf
							If lPeriodico .And. aDiasMes[nX][1]==aPergunte[9,3]
								exit
							EndIf
						Next nX
					Else				//do contrario utiliza cadastro de periodo - RCF_DUTILT e RCF_DNUTIL (sintetico)
						If __lMemCalc
							fAddMemLog("Calendario SINTÉTICO " ,1,1)
						EndIf
						If lPeriodico
							nDiaRef  := DateDiffDay( aPergunte[8,3],aPergunte[9,3] ) + 1
						ElseIf aPergunte[2,3] <> 2 .And. DiasTrab < nDiasPer
							nDiaUtil  := Int( Round( aPeriodo[nPosSem,12] * ( ( DiasTrab - ( nDiasMat + nDPrgSalMa ) ) / nDiasPer ), 2 ) )
							nDiaNUtil := 0
						Else
							nDiaUtil  := aPeriodo[nPosSem,12]
							nDiaNUtil := 0
						EndIf
					EndIf
					If __lMemCalc
						fAddMemLog("Dias úteis : " +  cvaltochar(nDiaUtil) ,1,1)
						fAddMemLog("Dias não úteis : " +  cvaltochar(nDiaNUtil) ,1,1)
					EndIf

					// O array aFaltas só é utilizado quando o lUsaCPer = .F. (Usa informações do Ponto)
					If Len(aFaltas) > 0
						aFaltas := {}
						nFalAux := nFaltas
					EndIf

					If nDiaRef > 0
						nDiaInf := If(lPeriodico .and. nDiaInf > 0, nDiaInf, nDUtil)
		    			nDiaCal := Max( ( nDiaRef -  If(nDUtil > 0,nFaltas,0) ) * nDiaInf - aPergunte[5,3], 0 ) //Parametro MV_PAR05 - Deducoes
					Else
			    		nAuxUtil  := ( nDiaUtil * If(lPeriodico .and. nDiaInf > 0, nDiaInf, nDUtil) ) - aPergunte[5,3]
			    		nAuxNUtil := nDiaNUtil * If(lPeriodico .and. nDiaInf > 0, nDiaInf, nDNUtil)
			    		nDiaCal   := ( nAuxUtil + nAuxNUtil ) - ( If(nDUtil > 0,nFaltas,0) * nDUtil)
					EndIf
				EndIf
			EndIf
		EndIf

		If !lSP7 .And. If(nDUtil > 0,nFaltas,0) > 0 .And. If(nDUtil > 0,nFaltas,0) >= nDiaRef
			If lPeriodico
				dDt1	:= aPergunte[8,3]
				dDt2	:= aPergunte[9,3]
			Else
				dDt1	:= aPeriodo[nPosSem,3]
				dDt2	:= aPeriodo[nPosSem,4]
			EndIf
			GravaSP7(nDiaRef,dDt1,dDt2)
			lSP7 := .T.
		EndIf

		nValVRF := nDiaCal * nValUni
		If __lMemCalc
			fAddMemLog("Dias de calculo : " +  cvaltochar(nDiaCal) ,1,1)
			fAddMemLog("Valor calculo : " +  Transform(nValVRF,"@E 999,999,999.99") ,1,1)
		EndIf

		//Inicio do trecho para recalculo dos beneficios gerados pela integração com serviços

		//Recalcula último VR pago por critérios definidos na intergração com serviços para verificar se deve ser feito algum desconto ou acréscimo
		If lPriVez .And. ( fIntRHGS() .AND. SuperGetMv("MV_BENEXGS",,.T.) )
			fRetBenAnt(SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_PROCES, "1", @aPerAux)
			If Len(aPerAux) > 0
				nTotDif := fApurPAnt(aPerAux[1], "1")[1]
			EndIf
			If __lMemCalc
				fAddMemLog("Integração com serviços ATIVADA "  ,1,1)
				fAddMemLog("Valor diferença mês anterior : " +  Transform(nTotDif,"@E 999,999,999.99") ,1,1)
			EndIf

			lPriVez := .F.
		EndIf

		nValOri := nValVRF	// Guarda o valor calculado originalmente

		If nTotDif != 0

			If nTotDif > 0 //Se houver diferença positiva para pagar em relação ao mês anterior, soma no valor total do VR
				nValVRF += nTotDif
				nTotDif := 0
			ElseIf ( nValVRF + nTotDif ) >= 0
				nValVRF += nTotDif
				nTotDif := 0
			Else
				nTotDif += nValVRF
				nValVRF := 0
			EndIf

		EndIf

		//Fim do trecho para recalculo dos beneficios gerados pela integração com serviços

		nCustFunc   := Round(( nValVRF * nPerc ) / 100,2)

		If nTeto > 0
			nCustFunc   := Min(nCustFunc, nTeto)
		EndIf
		nCustEmp	:= nValVRF - nCustFunc

		If __lMemCalc
			fAddMemLog("Percentual desconto funcionário : " +  cvaltochar(nPerc) + " %" ,1,1)
			fAddMemLog("Teto  : " +  Transform(nTeto,"@E 999,999,999.99") ,1,1)
			fAddMemLog("Custo funcionário : " +  Transform(nCustFunc,"@E 999,999,999.99") ,1,1)
			fAddMemLog("Custo empresa : " +  Transform(nCustEmp,"@E 999,999,999.99") ,1,1)
		EndIf

		cKeyAux := SM7->(M7_FILIAL+M7_MAT+M7_TPVALE+M7_CODIGO)

		aAdd(aVRCalc, {cKeyAux, nDiaCal, nValUni, nValVRF, nCustFunc, nCustEmp, nDiasRef, lPropin, SM7->M7_CODIGO, nDiasProp, nDUtil, nDNUtil, SM7->M7_TPCALC, SM7->M7_TPVALE, aDiaVales, SM7->M7_VALFIX, 0, nValOri,nDiaUtil,nDiaNUtil, If( nDUtil > 0, If(Len(aFaltas) > 0 , nFalAux, nFaltas ), 0),""} )

		If SM7->M7_COMPL == "1"
			RecLock("SM7",.F.)
			SM7->(dbDelete())
			SM7->(msUnlock())
		EndIf

		SM7->(DbSkip())

	EndDo

	If nTotDif < 0 //Grava o saldo negativo no último vale calculado
		aVRCalc[Len(aVRCalc), 17] := nTotDif
	EndIf

Else // Não Encontrou Registros na SM7, mas deve recalcular o mês anterior

	If fIntRHGS() .AND. SuperGetMv("MV_BENEXGS",,.T.) // Apenas integração com serviços
		fRetBenAnt(SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_PROCES, "1", @aPerAux)
		If Len(aPerAux) > 0
			aDias := fApurPAnt(aPerAux[1], "1")
			nTotDif := aDias[1]
			cCodBen := aDias[2]
		EndIf
	EndIf

	nValOri := nValVRF	// Guarda o valor calculado originalmente

	If nTotDif != 0

		//Grava na SM7
		AtuSM7Aut("1", cCodBen)

		If nTotDif > 0	// Se houver diferença positiva para pagar em relação ao mês anterior, soma no valor total do VA
			nValVRF += nTotDif
			nTotDif := 0
		ElseIf ( nValVRF + nTotDif ) >= 0	// Se houver diferença negativa, debita do total até o minimo de zero
			nValVRF += nTotDif
			nTotDif := 0
		Else
			nTotDif += nValVRF
			nValVRF := 0
		EndIf

		cKeyAux := SRA->(RA_FILIAL + RA_MAT + "1" + cCodBen)
		aAdd(aVRCalc, {cKeyAux, 0, nValUni, nValVRF, nCustFunc, nCustEmp, nDiaRef, lPropin, cCodBen, nDiasProp, nDUtil, nDNUtil, "2", "1", {0, 0, 0, 0, 0, 0, 0}, 0, nTotDif, nValOri,0,0,nFaltas,"" })

	EndIf

EndIf

RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fVALCalc 	   ºAutor  ³Leandro Drumond  º Data ³  04/08/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Efetua o calculo do vale alimentacao   					      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVALCalc(aVACalc)
Local aArea		:= GetArea()
Local aPerAux 	:= {}
Local cFilMat   := SRA->RA_FILIAL + SRA->RA_MAT
Local cKeyAux	:= ""
Local lPropin	:= .F.
Local lPriVez 	:= .T.
Local nCustFunc := 0
Local nCustEmp	:= 0
Local nValAli	:= 0
Local nDiaInf	:= 0
Local nValUni	:= 0
Local nPerc		:= 0
Local nTeto		:= 0
Local nDiasFix	:= 0
Local nDiaAlim	:= 0
Local nDiaCal	:= 0
Local nTotDif 	:= 0
Local nValOri	:= 0
Local nX		:= 0
Local nDiaUtil	:= 0
Local nDiaNUtil	:= 0
Local nDUtil	:= 0
Local nDNUtil	:= 0
Local nDiasPer	:= If(SuperGetMv("MV_DIASPER",,"1") == "1",nDiasP,(If(SRA->RA_TIPOPGT =="M", P_QTDIAMES, P_NTOTDIAS)))

aVACalc	  := {}

DbSelectArea("RFO")
DbSetOrder(RetOrder("RFO","RFO_FILIAL+RFO_TPVALE+RFO_CODIGO"))

DbSelectArea("SR0")
DbSetOrder(RetOrder("SR0", "R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO"))

If( DbSeek(cFilMat + "2") )

	While SR0->(!Eof() .and. R0_FILIAL + R0_MAT + R0_TPVALE == cFilMat + "2")

	    If SR0->R0_DPROPIN == 99 //Se diasprop for 99 não calcula meio de transporte
	    	SR0->(DbSkip())
	    	Loop
	    EndIf

	    nDUtil	 := SR0->R0_QDIAINF
	    nDNUtil	 := SR0->R0_QDNUTIL
    	nValUni  := 0
    	nPerc	 := 0
    	nTeto	 := 0
    	nDiasFix := 0
    	nDiaAlim := 0
    	lPropin	 := .F.
	    nDiaUtil := 0
	    nDiaNUtil:= 0

	    If RFO->(DbSeek(xFilial("RFO")+SR0->(R0_TPVALE + R0_CODIGO)))
	    	nValUni  := RFO->RFO_VALOR
	    	nPerc	 := RFO->RFO_PERC
	    	nTeto	 := RFO->RFO_TETO
	    	nDiasFix := RFO->RFO_DIAFIX
	    EndIf

	    If SR0->R0_DPROPIN > 0
	    	nDiaAlim := SR0->R0_DPROPIN
	    	lPropin	 := .T.
    	ElseIf !Empty(aDiasMes)	//Se existir dados no array aDiasMes, utiliza estes dados para montar dias uteis e nao uteis de vale transporte (analitico)
			For nX := 1 to Len(aDiasMes)
				If aDiasMes[nX,2] == "1" .and. aDiasMes[nX,3] == "1" .and. aDiasMes[nX,4]
					nDiaUtil += 1
				ElseIf aDiasMes[nX,2] <> "1" .and. aDiasMes[nX,3] == "1" .and. aDiasMes[nX,4]
					nDiaNUtil += 1
				EndIf
			Next nX
		Else				//do contrario utiliza cadastro de periodo - RCF_DUTILT e RCF_DNUTIL (sintetico)
			If aPergunte[2,3] <> 2 .And. DiasTrab < nDiasPer
				nDiaUtil  := Int( Round( aPeriodo[nPosSem,21] * ( ( DiasTrab - ( nDiasMat + nDPrgSalMa ) ) / nDiasPer ), 2 ) )
				nDiaNUtil := 0
			Else
				nDiaUtil  := aPeriodo[nPosSem,21]
				nDiaNUtil := 0
			EndIf
		EndIf

    	If nDiasFix > 0
    		nDiaCal := iif(!empty(nDiaAlim) .and. lPropin, nDiaAlim,nDiasFix) // Quando o nDiaAlim estiver preenchido é mandatório, pois deve ser considerado primeiro que o nDiasFix
    	Else
    		If nDiaAlim > 0
    			nDiaInf := nDUtil
    			nDiaCal := Max( ( nDiaAlim - nFaltas ) * nDiaInf - aPergunte[5,3], 0 ) //Parametro MV_PAR05 - Deducoes
    		Else
    			nDiaAlim  := nDiaUtil + nDiaNUtil
	    		nDiaCal   := ( (( nDiaUtil * nDUtil ) - aPergunte[5,3]) + (nDiaNUtil * nDNUtil) ) - (nFaltas * nDUtil)
	    	EndIf
    	EndIf

    	nValAli 	:= nDiaCal * nValUni

	    //Inicio do trecho para recalculo dos beneficios gerados pela integração com serviços
	    cKeyAux := SR0->(R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO)

		//Recalcula último VA pago por critérios definidos na intergração com serviços para verificar se deve ser feito algum desconto ou acréscimo
		If lPriVez .and. ( fIntRHGS() .AND. SuperGetMv("MV_BENEXGS",,.T.) )
			fRetBenAnt(SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_PROCES, "2", @aPerAux)
			If Len(aPerAux) > 0
				nTotDif := fApurPAnt(aPerAux[1], "2")[1]
			EndIf
			lPriVez := .F.
		EndIf

		nValOri := nValAli	// Guarda o valor calculado originalmente

		If nTotDif != 0
			If nTotDif > 0 //Se houver diferença positiva para pagar em relação ao mês anterior, soma no valor total do VA
				nValALI += nTotDif
				nTotDif := 0
			ElseIf ( nValALI + nTotDif ) >= 0 //Se houver diferença negativa, debita do total até o minimo de zero
				nValALI += nTotDif
				nTotDif := 0
			Else
				nTotDif += nValALI
				nValALI := 0
			EndIf
		EndIf

		//Fim do trecho para recalculo dos beneficios gerados pela integração com serviços

		nCustFunc := Round(( nValAli * nPerc ) / 100, 2)
		If nTeto > 0
			nCustFunc   := Min(nCustFunc, nTeto)
		EndIf
		nCustEmp := nValAli - nCustFunc

		aAdd(aVACalc, {cKeyAux, nDiaCal, nValUni, nValAli,  nCustFunc, nCustEmp, nDiaAlim, lPropin, 0, nValOri,,,,,,,,,nDiaUtil,nDiaNUtil} )

		SR0->(DbSkip())

	EndDo

	If nTotDif < 0 //Grava o saldo negativo no último vale calculado
		aVACalc[Len(aVACalc), 9] := nTotDif
	EndIf

EndIf

RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fVALCalcN 	   ºAutor  ³Leandro Drumond  º Data ³  04/08/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Efetua o calculo do vale alimentacao   					      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVALCalcN(aVACalc)
Local aArea			:= GetArea()
Local aDias 		:= {}
Local aPerAux 		:= {}
Local cFilMat   	:= SRA->RA_FILIAL + SRA->RA_MAT
Local cKeyAux		:= ""
Local lPropin		:= .F.
Local nCustFunc 	:= 0
Local nCustEmp		:= 0
Local nValAli		:= 0
Local nDiaInf		:= 0
Local nValUni		:= 0
Local nPerc			:= 0
Local nTeto			:= 0
Local nDiasFix		:= 0
Local nDiaAlim		:= 0
Local nDiaCal		:= 0
Local nTotDif 		:= 0
Local nValOri		:= 0
Local nX			:= 0
Local lPeriodico	:= aPergunte[6,3] == 1//Avulso/Complemnto/Semanal/diario
Local nPos			:= 0
Local nDiasProp 	:= 0
Local nDiasSeg 		:= 0									//-- Qtde Segundas trabalhadas
Local nDiasTer 		:= 0									//-- Qtde Tercas trabalhadas
Local nDiasQua 		:= 0									//-- Qtde Quartas trabalhadas
Local nDiasQui 		:= 0									//-- Qtde Quintas trabalhadas
Local nDiasSex 		:= 0									//-- Qtde Sextas trabalhadas
Local nDiasSab 		:= 0									//-- Qtde Sabados trabalhadas
Local nDiasDom 		:= 0									//-- Qtde Domingos trabalhadas
Local nDiasPonto 	:= 0
Local nDiaUtil		:= 0
Local nDiaNUtil		:= 0
Local nDUtil		:= 0
Local nDNUtil		:= 0
Local nAuxUtil		:= 0
Local nAuxNUtil		:= 0
Local nFalAux		:= 0
Local lDias			:= .F.
Local lFeriado 		:= .F.
Local lPropFerias	:= APERGUNTE[3,3] == 1
Local aTabCalend	:= If (!lUsaCPer,fCarPonto(),{})
Local lSP7			:= .F.
Local dDt1			:= ctod("")
Local dDt2			:= ctod("")
Local cCodBen		:= ""
Local nDiasPer		:= If(GetMvRH("MV_DIASPER",,"1") == "1",nDiasP,(If(SRA->RA_TIPOPGT =="M", P_QTDIAMES, P_NTOTDIAS)))

DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

If !lUsaCPer .And. Len(aTabCalend) > 1
	SPA->( dbSeek( xFilial("SPA", SRA->RA_FILIAL ) + SRA->RA_REGRA ) )
	lFeriado := ( SPA->PA_FERIADO == "S" .Or. ( SPA->( Type("PA_RECBENF") ) != "U" .And. SPA->PA_RECBENF == "1" ) )
EndIf

If __lMemCalc
	fAddMemLog("Calendario utilizado(MV_USACPER) : " +If(lUsaCPer,"FOLHA","PONTO") ,1,1)
	fAddMemLog("Considera feriado cadastro de Regra(SPA) : " + If(lFeriado,"Sim","Não") ,1,1)
	If !lUsaCPer
		fAddMemLog("Tabela padrão do ponto carregada : " + If(Len(aTabCalend) > 1 ,"Sim","Não") ,1,1)
	EndIf
	fAddMemLog("Proporcional a férias : " + If(lPropFerias,"Sim","Não") ,1,1)
	fAddMemLog("Calculo periódico : " + If(lPeriodico,"Sim","Não") ,1,1)
	fAddMemLog("Dias período : " + cvaltochar(nDiasPer) ,1,1)
EndIf

aVACalc	  := {}

DbSelectArea("RFO")
DbSetOrder(RetOrder("RFO","RFO_FILIAL+RFO_TPVALE+RFO_CODIGO"))

DbSelectArea("SM7")
SM7->(DbSetOrder(RetOrder("SM7", "M7_FILIAL+M7_MAT+M7_TPVALE+M7_CODIGO")))

If SM7->( DbSeek(cFilMat + "2") )

	While SM7->(!Eof() .and. M7_FILIAL + M7_MAT + M7_TPVALE == cFilMat + "2")

		nFalAux := 0

		If lPeriodico .And. aPergunte[10,3] == 1 .And. SM7->M7_COMPL <> '1'
			SM7->(dbSkip())
			Loop
		EndIf

		If SM7->M7_DPROPIN == 99 //Se diasprop for 99 não calcula meio de transporte
			SM7->(DbSkip())
			Loop
		EndIf

		lDias :=  SM7->M7_VALSEG > 0 .Or. SM7->M7_VALTER  > 0 .Or. SM7->M7_VALQUA  > 0 .Or.  SM7->M7_VALQUI  > 0 .Or.  SM7->M7_VALSEX  > 0 .Or.  SM7->M7_VALSAB  > 0 .Or.  SM7->M7_VALDOM >0
		aDiaVales := {SM7->M7_VALSEG , SM7->M7_VALTER , SM7->M7_VALQUA , SM7->M7_VALQUI , SM7->M7_VALSEX , SM7->M7_VALSAB , SM7->M7_VALDOM}
		nDiasSeg := 0									//-- Qtde Segundas trabalhadas
		nDiasTer := 0									//-- Qtde Tercas trabalhadas
		nDiasQua := 0									//-- Qtde Quartas trabalhadas
		nDiasQui := 0									//-- Qtde Quintas trabalhadas
		nDiasSex := 0									//-- Qtde Sextas trabalhadas
		nDiasSab := 0									//-- Qtde Sabados trabalhadas
		nDiasDom := 0
		nDiaUtil := 0
		nDiaNUtil := 0

		nDUtil	 := SM7->M7_QDIAINF
		nDNUtil	 := SM7->M7_QDNUTIL
		nDiasProp:= SM7->M7_DPROPIN
		nValUni  := 0
		nPerc	 := 0
		nTeto	 := 0
		nDiasFix := 0
		nDiaAlim := 0
		lPropin	 := .F.

		If RFO->(DbSeek(xFilial("RFO")+SM7->(M7_TPVALE + M7_CODIGO)))
			nValUni  := RFO->RFO_VALOR
			nPerc	 := RFO->RFO_PERC
			nTeto	 := RFO->RFO_TETO
			nDiasFix := RFO->RFO_DIAFIX
		EndIf

		If !lUsaCPer .And. SM7->M7_VALFIX > 0
			nDiasFix := SM7->M7_VALFIX
		EndIf

		If lPeriodico //complemento
			nDiasFix	:= 0
			nDiaInf	  := SM7->M7_QDIAINF
			If aPergunte[7,3] > 0
				nDiaInf	:= aPergunte[7,3]
			EndIf
			aPergunte[5,3] 	:= 0 //vales a deduzir
		EndIf
		If __lMemCalc
			fAddMemLog("Benefício : " + SM7->M7_CODIGO ,1,1)
			fAddMemLog("Benefício avulso : " +If(SM7->M7_COMPL=="1","SIM","NÃO") ,1,1)

			fAddMemLog("Dias da semana preenchidos : " +If(lDias,"SIM","NÃO") ,1,1)
			fAddMemLog("Dias fixos : " + cvaltochar(nDiasFix) ,1,1)
			fAddMemLog("Quantidade de vales dias úteis : " + cvaltochar(nDUtil) ,1,1)
			fAddMemLog("Quantidade de vales dias não úteis : " + cvaltochar(nDNUtil) ,1,1)
			fAddMemLog("Quantidade de vales proporcionais : " + cvaltochar(nDiasProp) ,1,1)
			If lPeriodico
				fAddMemLog("Vales por dia informados : " + cvaltochar(nDiaInf) ,1,1)
			EndIf
			fAddMemLog("vales a deduzir informado : " + cvaltochar(aPergunte[5,3]) ,1,1)
			fAddMemLog("Faltas  : " + cvaltochar(nFaltas) ,1,1)
			fAddMemLog("Valor Unitário  : " + Transform(nValUni,"@E 999,999,999.99") ,1,1)
		EndIf

		If nDiasProp > 0
			nDiaAlim := nDiasProp
			lPropin	 := .T.
			nDiaCal := Max( ( nDiaAlim - nFaltas ) * If(lPeriodico, nDiaInf - aPergunte[5,3], nDUtil), 0 ) //Parametro MV_PAR05 - Deducoes
		Else
			If nDiasFix > 0
				nDiaAlim  := nDiasFix
				nDiasProp := nDiasFix
				nDiaCal   := nDiaAlim - aPergunte[5,3] //Parametro MV_PAR05 - Deducoes
			Else
				If !lUsaCPer .And. Len(aTabCalend) > 1 .And. lDias

					GetDiasTab(aTabCalend,aDiaVales,lPropFerias,lFeriado,.F.,nDUtil,nDNUtil,@nDiasSeg,@nDiasTer,@nDiasQua,@nDiasQui,@nDiasSex,@nDiasSab,@nDiasDom,@nDiaUtil,@nDiaNUtil)
					
					//-- Calculo dos Dias Uteis     ( Qtde de cada dia semana * No vales de cada dia da semana ) - deducao
					nDiaAlim := nDiasSeg + nDiasTer + nDiasQua + nDiasQui + nDiasSex  + nDiasSab + nDiasDom
									
					nDiasPonto	:= ( ( nDiasSeg * SM7->M7_VALSEG) + ( nDiasTer * SM7->M7_VALTER ) + ( nDiasQua *  SM7->M7_VALQUA ) + ( nDiasQui * SM7->M7_VALQUI ) + ( nDiasSex * SM7->M7_VALSEX ) + ( nDiasSab * SM7->M7_VALSAB ) + ( nDiasDom * SM7->M7_VALDOM ) )
					nDiaCal := nDiasPonto - aPergunte[5,3] //Parametro MV_PAR05 - Deducoes

					If nFaltas > 0 .and. Len(aFaltas) > 0
						If SM7->M7_VALDOM > 0
							nFalAux += aFaltas[1]
						EndIf
						If SM7->M7_VALSEG > 0
							nFalAux += aFaltas[2]
						EndIf
						If SM7->M7_VALTER > 0
							nFalAux += aFaltas[3]
						EndIf
						If SM7->M7_VALQUA > 0
							nFalAux += aFaltas[4]
						EndIf
						If SM7->M7_VALQUI > 0
							nFalAux += aFaltas[5]
						EndIf
						If SM7->M7_VALSEX > 0
							nFalAux += aFaltas[6]
						EndIf
						If SM7->M7_VALSAB > 0
							nFalAux += aFaltas[7]
						EndIf
						nDiaCal -= nFalAux
					EndIf
				Else
					If !Empty(aDiasMes) //Se existir dados no array aDiasMes, utiliza estes dados para montar dias uteis e nao uteis de vale transporte
						If __lMemCalc
							fAddMemLog("Calendario ANALÍTICO " ,1,1)
						EndIf
						nDiaAlim  := 0
						If lPeriodico
							nPos := aScan(aDiasMes,{|x| x[1] == aPergunte[8,3]})
						EndIf
						If nPos == 0
							nPos := 1
						EndIf
						For nX := nPos to Len(aDiasMes)
							If aDiasMes[nX,2] == "1" .and. (Empty(dDataDem) .OR. aDiasMes[nX,1] < dDataDem) .and. aDiasMes[nX,3] == "1" .and. aDiasMes[nX,4]
								nDiaUtil += 1
							ElseIf aDiasMes[nX,2] <> "1" .and. (Empty(dDataDem) .OR. aDiasMes[nX,1] < dDataDem) .and. aDiasMes[nX,3] == "1" .and. aDiasMes[nX,4]
								nDiaNUtil += 1
							EndIf
							If lPeriodico .And. aDiasMes[nX][1]==aPergunte[9,3]
								exit
							EndIf
						Next nX
					Else //do contrario utiliza cadastro de periodo - RCF_DALIM
						If __lMemCalc
							fAddMemLog("Calendario SINTÉTICO " ,1,1)
						EndIf
						If lPeriodico
							nDiaAlim  := DateDiffDay( aPergunte[8,3],aPergunte[9,3] ) + 1
						ElseIf aPergunte[2,3] <> 2 .And. DiasTrab < nDiasPer
							nDiaUtil  := Int( Round( aPeriodo[nPosSem,21] * ( ( DiasTrab - ( nDiasMat + nDPrgSalMa ) ) / nDiasPer ), 2 ) )
							nDiaNUtil := 0
						Else
							nDiaUtil  := aPeriodo[nPosSem,21]
							nDiaNUtil := 0
						EndIf
						nDiasRef := nDiaUtil
					EndIf
					If __lMemCalc
						fAddMemLog("Dias úteis : " +  cvaltochar(nDiaUtil) ,1,1)
						fAddMemLog("Dias não úteis : " +  cvaltochar(nDiaNUtil) ,1,1)
					EndIf
					If nDiaAlim > 0
		    			nDiaInf := If(lPeriodico .and. nDiaInf > 0, nDiaInf, nDUtil)
		    			nDiaCal := Max( ( nDiaAlim - nFaltas ) * nDiaInf - aPergunte[5,3], 0 ) //Parametro MV_PAR05 - Deducoes
		    		Else
			    		nAuxUtil  := ( nDiaUtil * If(lPeriodico .and. nDiaInf > 0, nDiaInf, nDUtil) ) - aPergunte[5,3]
			    		nAuxNUtil := nDiaNUtil * If(lPeriodico .and. nDiaInf > 0, nDiaInf, nDNUtil)
			    		nDiaCal   := ( nAuxUtil + nAuxNUtil ) - (nFaltas * nDUtil)
			    	EndIf
				EndIf
			EndIf
		EndIf

		If !lSP7 .And. nFaltas > 0 .And. nFaltas >= nDiaAlim
			If lPeriodico
				dDt1	:= aPergunte[8,3]
				dDt2	:= aPergunte[9,3]
			Else
				dDt1	:= aPeriodo[nPosSem,3]
				dDt2	:= aPeriodo[nPosSem,4]
			EndIf
			GravaSP7(nDiaAlim,dDt1,dDt2)
			lSP7 := .T.
		EndIf

		nValAli 	:= nDiaCal * nValUni
		If __lMemCalc
			fAddMemLog("Dias de calculo : " +  cvaltochar(nDiaCal) ,1,1)
			fAddMemLog("Valor calculo : " +  Transform(nValAli,"@E 999,999,999.99") ,1,1)
		EndIf
		//Inicio do trecho para recalculo dos beneficios gerados pela integração com serviços

		//Recalcula último VA pago por critérios definidos na intergração com serviços para verificar se deve ser feito algum desconto ou acréscimo
		If fIntRHGS() .AND. SuperGetMv("MV_BENEXGS",,.T.)
			fRetBenAnt(SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_PROCES, "2", @aPerAux)
			If Len(aPerAux) > 0
				nTotDif := fApurPAnt(aPerAux[1], "2", Nil, SM7->M7_CODIGO)[1]
			EndIf
			If __lMemCalc
				fAddMemLog("Integração com serviços ATIVADA "  ,1,1)
				fAddMemLog("Valor diferença mês anterior : " +  Transform(nTotDif,"@E 999,999,999.99") ,1,1)
			EndIf
		EndIf

		nValOri := nValAli	// Guarda o valor calculado originalmente

		If nTotDif != 0
			If nTotDif > 0 //Se houver diferença positiva para pagar em relação ao mês anterior, soma no valor total do VA
				nValALI += nTotDif
				nTotDif := 0
			ElseIf ( nValALI + nTotDif ) >= 0 //Se houver diferença negativa, debita do total até o minimo de zero
				nValALI += nTotDif
				nTotDif := 0
			Else
				nTotDif += nValALI
				nValALI := 0
			EndIf
		EndIf
		//Fim do trecho para recalculo dos beneficios gerados pela integração com serviços

		nCustFunc   := Round(( nValAli * nPerc ) / 100, 2)
		If nTeto > 0
			nCustFunc   := Min(nCustFunc, nTeto)
		EndIf
		nCustEmp	:= nValAli - nCustFunc
		If __lMemCalc
			fAddMemLog("Percentual desconto funcionário : " +  cvaltochar(nPerc) + " %" ,1,1)
			fAddMemLog("Teto  : " +  Transform(nTeto,"@E 999,999,999.99") ,1,1)
			fAddMemLog("Custo funcionário : " +  Transform(nCustFunc,"@E 999,999,999.99") ,1,1)
			fAddMemLog("Custo empresa : " +  Transform(nCustEmp,"@E 999,999,999.99") ,1,1)
		EndIf
		cKeyAux := SM7->(M7_FILIAL + M7_MAT + M7_TPVALE + M7_CODIGO)

		aAdd(aVACalc , {cKeyAux, nDiaCal, nValUni, nValAli, nCustFunc, nCustEmp, nDiasRef, lPropin, SM7->M7_CODIGO, nDiasProp, nDUtil, nDNUtil, SM7->M7_TPCALC, SM7->M7_TPVALE, aDiaVales, SM7->M7_VALFIX, 0, nValOri,nDiaUtil,nDiaNUtil,If(Len(aFaltas)>0,nFalAux,nFaltas),""} )

		If SM7->M7_COMPL == "1"
			RecLock("SM7",.F.)
			SM7->(dbDelete())
			SM7->(msUnlock())
		EndIf

		SM7->(DbSkip())

	EndDo

	If nTotDif < 0 //Grava o saldo negativo no último vale calculado
		aVACalc[Len(aVACalc),17] := nTotDif
	EndIf

Else // Não Encontrou Registros na SM7, mas deve recalcular o mês anterior

	If fIntRHGS() .AND. SuperGetMv("MV_BENEXGS",,.T.) // Apenas integração com serviços
		fRetBenAnt(SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_PROCES, "2", @aPerAux)
		If Len(aPerAux) > 0
			aDias := fApurPAnt(aPerAux[1], "2")
			nTotDif := aDias[1]
			cCodBen := aDias[2]
		EndIf
	EndIf

	nValOri := nValAli	// Guarda o valor calculado originalmente

	If nTotDif != 0

		//Grava na SM7
		AtuSM7Aut("2", cCodBen)

		If nTotDif > 0 //Se houver diferença positiva para pagar em relação ao mês anterior, soma no valor total do VA
			nValALI += nTotDif
			nTotDif := 0
		ElseIf ( nValALI + nTotDif ) >= 0 //Se houver diferença negativa, debita do total até o minimo de zero
			nValALI += nTotDif
			nTotDif := 0
		Else
			nTotDif += nValALI
			nValALI := 0
		EndIf

		cKeyAux := SRA->(RA_FILIAL + RA_MAT + "2" + cCodBen)

		aAdd(aVACalc, {cKeyAux, 0, nValUni, nValAli, nCustFunc, nCustEmp, nDiaAlim, lPropin, cCodBen, nDiasProp, nDUtil, nDNUtil, "2", "2", {0, 0, 0, 0, 0, 0, 0}, 0, nTotDif, nValOri,0,0,nFaltas,"" })
	EndIf

EndIf

RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fValGrv 	   ºAutor  ³Leandro Drumond  º Data ³  03/08/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Gravacao do calculo do vale refeicao/alimentacao		      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fValGrv(aVLCalc)
Local aArea		:= GetArea()
Local cKeyAux	:= ""
Local nX		:= 0
Local nFalVal   := nFaltas

DEFAULT aVLCalc := {}

DbSelectArea("SR0")
DbSetOrder(RetOrder("SR0", "R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO"))

For nX := 1 to Len(aVLCalc)
	cKeyAux := aVLCalc[nX,1]
	DbSeek(cKeyAux)
	If Reclock( "SR0" , .F. )
		If aVLCalc[nX,8] .OR. ( aVLCalc[nX,7] <> IIf( SR0->R0_TPVALE == "1", aPeriodo[nPosSem,12] , aPeriodo[nPosSem,21] ) )
			SR0->R0_DIASPRO := aVLCalc[nX,7]							//Grava apenas se utilizou o campo R0_DPROPIN -OU-
																		//Se dias calculados diferente da quantidade de dias do mes.
		Else
			SR0->R0_DIASPRO := 0
		EndIf

		If aVLCalc[nX,19] > 0 .or. aVLCalc[nX,20] > 0
			SR0->R0_DUTILM	:= aVLCalc[nX,19]
			SR0->R0_DNUTIM	:= aVLCalc[nX,20]
		Else
			SR0->R0_DUTILM	:= aPeriodo[nPosSem,10]							//Dias Uteis no Mês - campo RCF_DUTILT
			SR0->R0_DNUTIM	:= aPeriodo[nPosSem,9]							//Dias Não Uteis no Mês - campo RCF_DNUTIL
		EndIf
		SR0->R0_SALBASE	:= SRA->RA_SALARIO								//Salário Base
		SR0->R0_CC		:= SRA->RA_CC									//Centro de Custo do Funcionário
		SR0->R0_FALTAS	:= If(Empty(nFaltasAut), nFalVal, nFaltasAut)	//Dias correspondentes à faltas (mnemônico NFALTAS)
		SR0->R0_FERIAS 	:= nFerVen										//Dias correspondentes a férias (mnemônico NFERVEN)
		SR0->R0_AFAST 	:= nDiasAfas									//Dias correspondentes a afastamentos (mnemônico NDIASAFAS)

		SR0->R0_QDIACAL	:= aVLCalc[nX,2]								//Dias calculados
		SR0->R0_VALCAL 	:= aVLCalc[nX,4]								//Valor Vale calculado
		SR0->R0_VLRVALE	:= aVLCalc[nX,3]								//Custo Unitário
		SR0->R0_VLRFUNC	:= aVLCalc[nX,5]								//Custo Funcionário
		SR0->R0_VLREMP 	:= aVLCalc[nX,6]								//Custo Empresa
		If SR0->(ColumnPos("R0_SLDANT")) > 0
			SR0->R0_SLDANT  := aVLCalc[nX,9]							//Saldo negativo
			SR0->R0_VALORI	:= aVLCalc[nX,10]							//Valor Caculado originalmente
		EndIf

		SR0->( MsUnLock() )

		nFalVal := 0
	EndIf

Next nX

RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fValGrvN 	   ºAutor  ³Leandro Drumond  º Data ³  03/08/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Gravacao do calculo do vale refeicao/alimentacao		      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fValGrvN(aVLCalc)

	Local aArea		:= GetArea()
	Local lNovo		:= .T.
	Local nX		:= 0
	Local nPos 		:= 0
	Local lPeriodico:= aPergunte[6,3] == 1//Avulso/Complemnto/Semanal/diario
	Local cNumPed   := ""
	Local cCodCCT   := ""
	Local lGpem040  := FunName() == "GPEM040" .or. FunName() == "GPEM040B"

	DEFAULT aVLCalc := {}
	DEFAULT lTemCCT	  := SR0->(ColumnPos("R0_CODCCT")) > 0

If lGpem040 //Se for rescisão, inclui valores calculados no array para desconto na rescisão

	aBenefRes[If(cRot == "VRF",2,3)] := aClone(aVLCalc)

Else

	If lTemCCT .and. !Empty(SRA->RA_SINDICA)
		cCodCCT := fBuscaCCT(SRA->RA_SINDICA)
	EndIf

	DbSelectArea("SM7")
	SM7->(DbSetOrder(RetOrder("SM7","M7_FILIAL+M7_MAT+M7_TPVALE+M7_CODIGO")))

	DbSelectArea("SR0")
	SR0->(DbSetOrder(RetOrder("SR0", "R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO+R0_PEDIDO")))

	// Exclui cálculo anterior para o mesmo período, caso exista
	cKey := SRA->RA_FILIAL + SRA->RA_MAT + If(cRot == "VAL", "2", If(cRot == "VRF", "1", "0"))
	If SR0->(dbSeek(cKey))
		While SR0->(R0_FILIAL + R0_MAT + R0_TPVALE) == cKey
			//Somente deleta o cálculo se for recálculo. Caso o pedido já tenha sido emitido, não deleta.
			If (SR0->R0_DTREFI == aPeriodo[nPosSem, 3] .And. SR0->R0_DTREFF == aPeriodo[nPosSem, 4] .And. SR0->R0_PEDIDO != "2") ;
				.Or. (Empty(SR0->R0_DTREFI) .And. Empty(SR0->R0_DTREFF) .And. SR0->R0_PEDIDO != "2")
				//Se já existir um cálculo em aberto, quer dizer que é recálculo, então armazena o numero do pedido já utilizado.
				If ( nPos := aScan(aVLCalc, {|x| x[1] == SR0->R0_FILIAL+SR0->R0_MAT+SR0->R0_TPVALE+SR0->R0_CODIGO}) ) > 0
					aVLCalc[nPos,22] := SR0->R0_NROPED
				EndIf
				Reclock("SR0", .F.)
				SR0->(dbDelete())
				SR0->(MsUnlock())
			EndIf
			SR0->(dbSkip())
		EndDo
		SR0->(dbGoTop())
	EndIf
	For nX := 1 to Len(aVLCalc)
		SM7->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + aVLCalc[nX, 14] + aVLCalc[nX, 9]))
		lNovo 	  := .T.
		cNumPed   := ""
		If SR0->(DbSeek(aVLCalc[nX, 1] + "1"))
			While SR0->( !EoF() ) .And. SR0->R0_FILIAL+SR0->R0_MAT+SR0->R0_TPVALE+SR0->R0_CODIGO+SR0->R0_PEDIDO == aVLCalc[nX, 1] + "1"
				If SR0->R0_NROPGT == aPeriodo[nPosSem, 2] 
					lNovo := .F.
					Exit
				EndIf
				SR0->( dbSkip() )
			EndDo
		EndIf		
		If ! lNovo .And. ! Empty(SR0->R0_NROPED)
			cNroPed := SR0->R0_NROPED
		ElseIf lNovo
			cNumPed := aVLCalc[nX,22]
		EndIf
		If Reclock( "SR0", lNovo)
			If !Empty(aVLCalc[nX, 10]) .And. (aVLCalc[nX,8] .OR. ( aVLCalc[nX,10] <> IIf( aVLCalc[nX, 14] == "1", aPeriodo[nPosSem,12] , aPeriodo[nPosSem,21] ) ))
				//Grava apenas se utilizou o campo R0_DPROPIN -OU-
				//Se dias calculados diferente da quantidade de dias do mes.
				SR0->R0_DPROPIN	:= aVLCalc[nX, 10]
				SR0->R0_DIASPRO := aVLCalc[nX, 10]
			Else
				SR0->R0_DPROPIN := 0
				If aVLCalc[nX, 21] >= 0
					SR0->R0_DIASPRO := If(aVLCalc[nX, 2] < aVLCalc[nX, 7], aVLCalc[nX, 2], aVLCalc[nX, 7])
				Else
					// Se houver devolução de Faltas soma a devolução aos dias proporcionais
					SR0->R0_DIASPRO := If(aVLCalc[nX, 2] < aVLCalc[nX, 7], aVLCalc[nX, 2] - aVLCalc[nX, 21], aVLCalc[nX, 7] - aVLCalc[nX, 21])
				EndIf
			EndIf
			SR0->R0_FILIAL	:= SRA->RA_FILIAL
			SR0->R0_MAT		:= SRA->RA_MAT
			SR0->R0_TPVALE	:= aVLCalc[nX, 14]
			SR0->R0_CODIGO	:= aVLCalc[nX, 9]
			SR0->R0_QDIAINF	:= aVLCalc[nX, 11]
			SR0->R0_QDNUTIL	:= aVLCalc[nX, 12]
			SR0->R0_TPCALC	:= aVLCalc[nX, 13]
			SR0->R0_ROTEIR	:= cRot
			SR0->R0_PERIOD 	:= cPeriodo
			SR0->R0_NROPGT	:= cNumPag
			SR0->R0_ANOMES	:= SubSTr(cPeriodo,5,2) + SubSTr(cPeriodo,1,4)
			SR0->R0_PEDIDO	:= "1"
			SR0->R0_QVALSEG  := aVLCalc[nX, 15, 1]
			SR0->R0_QVALTER  := aVLCalc[nX, 15, 2]
			SR0->R0_QVALQUA  := aVLCalc[nX, 15, 3]
			SR0->R0_QVALQUI  := aVLCalc[nX, 15, 4]
			SR0->R0_QVALSEX  := aVLCalc[nX, 15, 5]
			SR0->R0_QVALSAB  := aVLCalc[nX, 15, 6]
			SR0->R0_QVALDOM  := aVLCalc[nX, 15, 7]
			SR0->R0_QVALFIX  := aVLCalc[nX, 16]
			If lPeriodico
				SR0->R0_DTREFI	:= aPergunte[8, 3]
				SR0->R0_DTREFF	:= aPergunte[9, 3]
			Else
				SR0->R0_DTREFI	:= aPeriodo[nPosSem, 3]
				SR0->R0_DTREFF	:= aPeriodo[nPosSem, 4]
			EndIf

			If lNovo
				//Caso não exista pedido, pode ser novo mês ou mais de 1 pedido no mês, então assume o novo número do pedido.
				If cNumPed <> ""
					cNroPed := cNumPed
				EndIf
				SR0->R0_NROPED	:= GetNroPed()
			EndIf
			SR0->R0_TPBEN	:= BuscaTBen(SR0->R0_TPVALE, SR0->R0_CODIGO, SR0->R0_FILIAL)

			If aVLCalc[nX,19] > 0 .or. aVLCalc[nX,20] > 0
				SR0->R0_DUTILM	:= aVLCalc[nX,19]
				SR0->R0_DNUTIM	:= aVLCalc[nX,20]
			Else
				SR0->R0_DUTILM	:= aPeriodo[nPosSem,10]							//Dias Uteis no Mês - campo RCF_DUTILT
				SR0->R0_DNUTIM	:= aPeriodo[nPosSem,9]							//Dias Não Uteis no Mês - campo RCF_DNUTIL
			EndIf

			SR0->R0_SALBASE	:= SRA->RA_SALARIO								//Salário Base
			SR0->R0_CC		:= SRA->RA_CC									//Centro de Custo do Funcionário
			SR0->R0_FALTAS	:= If(Len(aVlCalc[nX]) >= 21, aVlCalc[nX,21], (If(Empty(nFaltasAut), If(SM7->M7_QDIAINF > 0, nFaltas, 0), nFaltasAut)))	//Dias correspondentes à faltas (mnemônico NFALTAS) - Só desconta faltas se houvere pagamento de dias úteis.
			SR0->R0_FERIAS	:= nFerVen										//Dias correspondentes a férias (mnemônico NFERVEN)
			SR0->R0_AFAST	:= nDiasAfas									//Dias correspondentes a afastamentos (mnemônico NDIASAFAS)

			SR0->R0_QDIACAL	:= aVLCalc[nX, 2]								//Dias calculados
			SR0->R0_VALCAL 	:= aVLCalc[nX, 4]								//Valor Vale calculado
			SR0->R0_VLRVALE	:= aVLCalc[nX, 3]								//Custo Unitário
			SR0->R0_VLRFUNC	:= aVLCalc[nX, 5]								//Custo Funcionário
			SR0->R0_VLREMP 	:= aVLCalc[nX, 6]								//Custo Empresa

			If SR0->(ColumnPos("R0_SLDANT")) > 0
				SR0->R0_SLDANT  := aVLCalc[nX, 17]							//Saldo negativo
				SR0->R0_VALORI	:= aVLCalc[nX, 18]							//Valor Caculado originalmente
			EndIf

			If lTemCCT
				SR0->R0_CODCCT 	:= cCodCCT	//Convenção Coletiva de Trabalho
			EndIf

			SR0->( MsUnLock() )
		EndIf

		If cNumPed <> ""
			cNroPed := "" //Zera static para não usar o mesmo número para outro funcionário causando chave duplicada.
		EndIf

	Next nX

	If Len(aVLCalc) > 0
		CustoVales( aVLCalc[1, 14])
	EndIf

EndIf

// Zera Variáveis Static
RestXCBEN()

RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fCargaRI1      ºAutor  ³Leandro Drumond  º Data ³ 21/02/2014  º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Carrega dados dos beneficios do funcionario.                  º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³Roteiros de Calculo			                                  º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCargaRI1(aBenRI1)
Local aArea		:= GetArea()
Local lRet		:= .F.
Local lRetAut	:= .F.

lRetAut := fCrgBenAut(.F.) //Verifica se existem critérios automáticos para o funcionário

DbSelectArea("RI1")
DbSetOrder(1)

lRI1Afast := .F.


If DbSeek(SRA->RA_FILIAL + SRA->RA_MAT)
	If Empty(SRA->RA_DEMISSA) .or. SRA->RA_DEMISSA > dDataDe
		
		While RI1->(!Eof() .and. RI1_FILIAL + RI1_MAT == SRA->RA_FILIAL + SRA->RA_MAT )
			If RI1->( RI1_TPCALC != "2" .And. (( Empty(RI1_DINIPG) .or. RI1_DINIPG <= dDataAte ) .And. (Empty(RI1_DFIMPG) .Or. RI1_DFIMPG >= dDataDe)))
				lRet := .T.
				RI1->(aAdd(aBenRI1, {RI1_MAT, RI1_BENEF, RI1_TABELA, RI1_PD, RI1_PD1, RI1_PD2, RI1_PROPOR}))
				If RI1->RI1_PROPOR == "1"
					lRI1Afast := .T.
				EndIf
			EndIf
			RI1->(DbSkip())
		EndDo
		
	EndIf
EndIf

lRet := lRet .Or. lRetAut

If lRI1Afast .Or. lRetAut //Se existir cálculo proporcional, carrega dias trabalhados
	fDiasTrab(@DiasTrab)
EndIf

If lRetAut .And. RIS->RIS_PROPOR == "1"
	lRI1Afast := .T.
EndIf

RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fOtbCalc       ºAutor  ³Leandro Drumond  º Data ³ 21/02/2014  º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Calcula outros beneficios.                                    º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³Roteiros de Calculo			                                  º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fOtbCalc()
Local cCodBenef	:= ""
Local cCodTab	:= ""
Local cTpRef	:= ""
Local cTpDesc	:= ""
Local cPdBen	:= ""
Local cPdFunc	:= ""
Local cPdEmp	:= ""
Local nValBen	:= 0
Local nValEmp	:= 0
Local nValFunc	:= 0
Local nRef		:= 0
Local nRefCalc	:= 0
Local nPercFunc	:= 0
Local nPercBen	:= 0
Local nPercEmp	:= 0
Local nValMin	:= 0
Local nValMax	:= 0
Local nX 		:= 0
Local nDiasProp	:= 0
Local nValAux	:= 0
Local nValRed	:= 0
Local nBkpSalMes:= SalMes
Local nDiasPer	:= If(GetMvRH("MV_DIASPER",,"1") == "1",nDiasP,(If(SRA->RA_TIPOPGT =="M", P_QTDIAMES, P_NTOTDIAS)))
Local lProp		:= .F.
Local lSalOuBen := If( Type("P_SALOUBEN") <> "U", P_SALOUBEN, .F.)

// Valida Demissão do Funcionário
If ( !Empty(SRA->RA_DEMISSA) .And. MesAno(SRA->RA_DEMISSA) <= cAnoMes .And. cSitFolh == "D")
    Return()
EndIf

DbSelectArea("RIS")
DbSetOrder(1)

For nX := 1 to Len(aBenRI1)
	cCodBenef 	:= aBenRI1[nX,2]
	cCodTab		:= aBenRI1[nX,3]
	cPdBen		:= aBenRI1[nX,4]
	cPdFunc		:= aBenRI1[nX,5]
	cPdEmp		:= aBenRI1[nX,6]
	lProp		:= aBenRI1[nX,7] == "1"
	aRISCalc	:= {}
	SalMes		:= nBkpSalMes

	If Empty(cPdBen) .and. Empty(cPdFunc) .and. Empty(cPdEmp)
		Loop
	EndIf

	If RIS->(DbSeek(xFilial("RIS")+cCodBenef+cCodTab))
		While RIS->(!Eof() .and. RIS_FILIAL + RIS_TPBENE + RIS_COD == xFilial("RIS")+cCodBenef + cCodTab )
			If Empty(RIS->RIS_SALATE)
				nValAux := RIS->RIS_SALMIN * Val_SalMin
			Else
				nValAux := RIS->RIS_SALATE
			EndIf
			If SalMes <= nValAux
				cTpRef 		:= RIS_TPREF
				cTpDesc		:= RIS_TPDESC
				nRef		:= RIS_REF
				nPercFunc	:= RIS_FUNCD
				nPercBen	:= RIS_FUNCP
				nPercEmp	:= RIS_EMP
				nValMin		:= RIS_MINIMO
				nValMax		:= RIS_MAXIMO
				nValBen		:= 0
				nValEmp		:= 0
				nValFunc	:= 0
				nRefCalc	:= 0
				nDiasProp	:= 0

				If cTpRef == "1" //Valor Fixo
					nRefCalc := nRef
				ElseIf cTpRef == "2" //Percentual do Salario Base
					If !lSalOuBen
						nRefCalc := SalMes * ( nRef / 100 )
					Else
						fSalInc(@nSalario,@SalMes,@SalHora,@SalDia)
						//Se for comissionado, utiliza a mesma estrutura utilizada na fórmula S_NVLGOMIS()
						If SRA->RA_CATFUNC == "C"
							nTotComis := FBUSCAPD(ACODFOL[165,1] + "," + ACODFOL[166,1],,CSEMANA)
                    		nGComisPro := 0
                    		FPROPGCOMIS('2',@nGComisPro)
    	                    SalMes += MAX(SalMes,nTotComis)
    	                    SalMes := MAX(SalMes,nGComisPro)
						EndIf
						//Se for tarefeiro, utiliza a mesma estrutura utilizada na fórmula S_NVLGTARE()
						If SRA->RA_CATFUNC == "T"
							nGTarPro := 0
                   			FPROPGTAR('2',@nGTarPro)
                   			SalMes += MAX(SalMes,nTotTarefa)
                    		SalMes := MAX(SalMes,nGTarPro)
						EndIf
						nRefCalc := SalMes * ( nRef / 100 )
					EndIf
				ElseIf cTpRef == "3" //Percentual sobre salario minimo
					nRefCalc := Val_SalMin * ( nRef / 100 )
				EndIf

				If !Empty(nPercBen)
					nValBen := nRefCalc * ( nPercBen / 100 )
				EndIf

				If lProp
					nValBen := Round( ( nValBen / nDiasPer ) * DiasTrab, 2)
					nDiasProp := DiasTrab
				EndIf

				If !Empty(cPdFunc) .and. !Empty(nPercFunc) .And. nValBen > 0
					If cTpDesc == "1" //Percentual do Beneficio
						nValFunc := nValBen * ( nPercFunc / 100 )
					ElseIf cTpDesc == "2"
						If !lSalOuBen
							If P_lPPEAtiv .And. P_RedSalB
								If Empty(aPPE)
									fInssResEx()
									fSalRed(@nValRed, Nil, Nil, nSalMes)
								EndIf
								SalMes -= nValRed
							EndIf
							nValFunc := SalMes * ( nPercFunc / 100 )
						Else
							fSalInc(@nSalario,@SalMes,@SalHora,@SalDia)
							If P_lPPEAtiv .And. P_RedSalB
								If Empty(aPPE)
									fInssResEx()
									fSalRed(@nValRed, Nil, Nil, nSalMes)
									EndIf
								SalMes -= nValRed
							EndIf
							If SRA->RA_CATFUNC == "C"
								nTotComis := FBUSCAPD(ACODFOL[165,1] + "," + ACODFOL[166,1],,CSEMANA)
								nGComisPro := 0
								FPROPGCOMIS('2',@nGComisPro)
								SalMes += MAX(SalMes,nTotComis)
								SalMes := MAX(SalMes,nGComisPro)
							EndIf
							If SRA->RA_CATFUNC == "T"
								nGTarPro := 0
								FPROPGTAR('2',@nGTarPro)
								SalMes += MAX(SalMes,nTotTarefa)
								SalMes := MAX(SalMes,nGTarPro)
							EndIf
							nValFunc := SalMes  * ( nPercFunc / 100 )
						EndIf
					ElseIf cTpDesc == "3" //Percentual Salario Minimo
						nValFunc := Val_SalMin * ( nPercFunc / 100 )
					EndIf
					nValFunc := Round(nValFunc,2)
					If nValMin > 0
						nValFunc := Max(nValFunc,nValMin)
					EndIf
					If nValMax > 0
						nValFunc := Min(nValFunc,nValMax)
					EndIf
				EndIf

				// Quando informado 100% no campo RIS_FUNCP(%Pagto.Func) quer dizer que o pagamento
				// daquele benefício realizado por aquela empresa. Por exemplo, ao informar que aquela empresa
				// pagará 50% sobre um benefício no valor de R$ 60,00, então R$ 30,00
				// é que serão utilizados para construir o desconto do funcionário e o desconto da empresa.
				nValEmp := If(nValBen == 0, nValBen, nValBen - nValFunc )

				aAdd(aCalcRI1,{cCodBenef, nValBen, nValFunc, nValEmp, cPdBen, cPdFunc, cPdEmp, cCodTab, nDiasProp, nRefCalc})

				Exit
			EndIf
			RIS->(DbSkip())
		EndDo
	EndIf
Next nX

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fOtbCalc       ºAutor  ³Leandro Drumond  º Data ³ 21/02/2014  º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Calcula outros beneficios.                                    º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³Roteiros de Calculo			                                  º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fGrvOtB()
Local cCodCCT 	:= ""
Local nX 		:= 0

DEFAULT lOtbCCT	  	:= RIQ->(ColumnPos("RIQ_CODCCT")) > 0

If lOtbCCT .and. !Empty(SRA->RA_SINDICA)
	cCodCCT := fBuscaCCT(SRA->RA_SINDICA)
EndIf

fDelRIQ()

DbSelectArea("RIQ")

For nX := 1 to Len(aCalcRI1)
	RecLock("RIQ",.T.)

	RIQ_FILIAL 	:= SRA->RA_FILIAL
	RIQ_MAT	   	:= SRA->RA_MAT
	RIQ_TPBENE	:= aCalcRI1[nX,1]
	RIQ_VALBEN	:= aCalcRI1[nX,2]
	RIQ_VLRFUN	:= aCalcRI1[nX,3]
	RIQ_VLREMP	:= aCalcRI1[nX,4]
	RIQ_PD		:= aCalcRI1[nX,5]
	RIQ_PD1		:= aCalcRI1[nX,6]
	RIQ_PD2		:= aCalcRI1[nX,7]
	RIQ_COD		:= aCalcRI1[nX,8]
	RIQ_DIAPRO	:= aCalcRI1[nX,9]
	RIQ_VALCAL	:= aCalcRI1[nX,10]
	RIQ_SALBAS	:= SalMes
	RIQ_SALMIN	:= Val_SalMin
	RIQ_PROCES	:= cProcesso
	RIQ_ROTEIR	:= cRot
	RIQ_PERIOD	:= cPeriodo
	RIQ_NUMPAG	:= cSemana
	RIQ_TIPO	:= "1"

	If lOtbCCT
		RIQ_CODCCT := cCodCCT 
	EndIf

	MsUnLock()
Next nX

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fDelRIQ        ºAutor  ³Leandro Drumond  º Data ³ 21/02/2014  º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Deleta calculo anterior.	                                  º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³Roteiros de Calculo			                                  º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fDelRIQ()

Local aArea := GetArea()
Local cQuery
Local cNameDB
Local cDelet
Local cSqlName := InitSqlName( "RIQ" )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³O banco DB2 nao aceita o nome da tabela apos o comando DELETE			 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
cNameDB	:= Upper(TcGetDb())

cQuery	:= "DELETE "

cDelet	:= "RIQ.D_E_L_E_T_ = ' ' "

If ( cNameDB $ "INFORMIX" )
	cDelet := cSqlName + ".D_E_L_E_T_ = ' ' "
EndIf

If !( cNameDB $ "DB2_ORACLE_INFORMIX_POSTGRES" )
	cQuery += cSqlName
EndIf

 		/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³O Informix precisa do nome da tabela ao inves do Alias no comando DELETE³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If ( cNameDB $ "INFORMIX" )
	cQuery += " FROM " + cSqlName
Else
	cQuery += " FROM " + cSqlName + " RIQ"
	cSqlName := "RIQ"
EndIf

cQuery += " WHERE " + cSqlName + ".RIQ_FILIAL = '" + SRA->RA_FILIAL + "'"
cQuery += " AND " + cSqlName + ".RIQ_MAT = '" + SRA->RA_MAT + "'"
cQuery += " AND " + cSqlName + ".RIQ_PROCES = '" + cProcesso + "'"
cQuery += " AND " + cSqlName + ".RIQ_ROTEIR = '" + cRot + "'"
cQuery += " AND " + cSqlName + ".RIQ_PERIOD = '" + cPeriodo + "'"
cQuery += " AND " + cSqlName + ".RIQ_NUMPAG = '" + cSemana + "'"
cQuery += " AND " + cDelet

TcSqlExec( cQuery )

RestArea( aArea )

Return( .T. )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fIntegraOUT    ºAutor  ³Leandro Drumond  º Data ³ 22/02/2014  º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Integra outros beneficios com a folha.                        º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³Roteiros de Calculo			                                  º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fIntegraOUT(cFil, cMat, cProcBen, cProcFol, cRotFol, cPerFol, cSemFol, cRotBen, cPerBen, cSemBen)
Local aArea			:= GetArea()
Local aVerbas		:= {"RIQ->RIQ_PD","RIQ->RIQ_PD1","RIQ->RIQ_PD2"}
Local aValAux		:= {"RIQ->RIQ_VALBEN","RIQ->RIQ_VLRFUN","RIQ->RIQ_VLREMP"}
Local cKeyRIQ		:= cFil + cMat + cProcBen + cRotBen + cPerBen
Local cPdAux		:= ""
Local cPdGerado     := ""
Local cTpBenAux		:= ""
Local cCodAux		:= ""
Local cSeq			:= ""
Local lGrava		:= .T.
Local lAtualiza		:= .F.
Local nValAux		:= 0
Local nX			:= 0
Local dDataBen

DEFAULT lGPM19RGB 	:= ExistBlock("GPM19RGB")

Pergunte("GPEM015OUT",.F.) //Carrega o grupo de perguntas, a definição da sobreposição vira do conteúdo gravado, mesmo quando a integração ocorrer pelo GPEM019
nSobrepor := mv_par04

DbSelectArea("SRA")
DbSetOrder(1)
DbSeek(cFil + cMat)

DbSelectArea("RGB")
DbSetOrder(RetORder("RGB","RGB_FILIAL+RGB_PROCES+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_MAT+RGB_PD+RGB_SEQ"))

DbSelectArea("RIQ")
DbSetOrder(1)

If(DbSeek(cKeyRIQ))
	While RIQ->(!Eof() .and. RIQ_FILIAL+RIQ_MAT+RIQ_PROCES+RIQ_ROTEIR+RIQ_PERIOD == cKeyRIQ )
		If !Empty(cSemBen) .and. RIQ->RIQ_NUMPAG <> cSemBen
			RIQ->(DbSkip())
			Loop
		EndIf

		For nX := 1 to Len(aVerbas)
			cPdAux 		:= &(aVerbas[nX])
			lGrava 		:= .T.
			lAtualiza 	:= .F.
			cSeq 		:= ""
			
			If Empty(cPdAux) .or. &(aValAux[nX]) == 0
				Loop
			Else
				nValAux := &(aValAux[nX])
			EndIf

			If RGB->(DbSeek(cFil + cProcFol + cPerFol + cSemFol + cRotFol + cMat + cPdAux))
				If cTpBenAux == RIQ->RIQ_TPBENE .and. cCodAux <> RIQ->RIQ_COD
				  	If Val(RetValSRV(  cPdAux , cFil , "RV_QTDLANC" )) > 1
				  		If nSobrepor <> 1
					  		If Empty(cSeq)
					  			cSeq := "1"
					  		Else
								cSeq := Soma1(cSeq)
							EndIf
						Else
							cSeq := RGB->RGB_SEQ
						EndIf
						If RGB->(DbSeek(cFil + cProcFol + cPerFol + cSemFol + cRotFol + cMat + cPdAux+cSeq))
							RGB->( RecLock( "RGB" , .F. ) )
						Else
							RGB->( RecLock( "RGB" , .T. ) )
						Endif
					Else
						if nSobrepor == 1
				  			nValAux := RGB->RGB_VALOR
				  		Else
				  			nValAux += RGB->RGB_VALOR
				  		Endif
				  		RGB->( RecLock( "RGB" , .F. ) )
					EndIf
				ElseIf RGB->RGB_ROTORI == cRotBen .and. RGB->RGB_TIPO2 == "G" .and. cPdAux $ cPdGerado //Dois beneficios diferentes, para o mesmo funcionário, calculado na mesma verba
					RGB->( RecLock( "RGB" , .F. ) )
					lAtualiza := .T.
				ElseIf nSobrepor == 1
					RGB->( RecLock( "RGB" , .F. ) )
				Else
					aAdd( aLog[Len(aLog)], SRA->RA_FILIAL + "  " + SRA->RA_MAT + "-" + If(lOfusca, Replicate('*',15), SRA->RA_NOME) + "   " + cPdAux + "   " + fDesc( "SRV" , cPdAux  , "RV_DESC" ) )
					lGrava := .F.
				EndIf
			Else
				RGB->( RecLock( "RGB" , .T. ) )
			EndIf

			cTpBenAux := RIQ->RIQ_TPBENE
			dDataBen  := StoD(cPerFol+"01")

			If lGrava
				RGB->RGB_FILIAL	:= RIQ->RIQ_FILIAL
				RGB->RGB_MAT 	:= RIQ->RIQ_MAT
				RGB->RGB_CC		:= SRA->RA_CC
				RGB->RGB_PD		:= cPdAux
				RGB->RGB_TIPO1	:= RetValSRV(  cPdAux , cFil , "RV_TIPO" )
				RGB->RGB_TIPO2	:= "G"
				RGB->RGB_VALOR	:= If(lAtualiza,RGB->RGB_VALOR + nValAux, nValAux)
				RGB->RGB_PARCEL	:= 0
				RGB->RGB_ITEM 	:= SRA->RA_ITEM
				RGB->RGB_CLVL 	:= SRA->RA_CLVL
				RGB->RGB_PROCES	:= cProcFol
				RGB->RGB_PERIOD	:= cPerFol
				RGB->RGB_ROTEIR	:= cRotFol
				RGB->RGB_SEMANA	:= cSemFol
				RGB->RGB_ROTORI	:= cRotBen
				RGB->RGB_SEQ	:= cSeq
				RGB->RGB_DTREF	:= dDataBen

				If lGPM19RGB
					ExecBlock("GPM19RGB", .F. , .F., { cRotBen, RIQ->RIQ_FILIAL, RIQ->RIQ_MAT, cPerFol, cSemFol } )
				EndIf

				RGB->(MsUnLock())

				cPdGerado += cPdAux + "/"
			EndIf
		Next nX

		cCodAux	  := RIQ->RIQ_COD

		RIQ->(DbSkip())
	EndDo
EndIf

RestArea(aArea)

Return .T.

/*/{Protheus.doc} fCrgAutom
Carrega benefícios por critério
@author Flavio S Correa
@since 22/02/2014
@param cTipo, characters, "VR" - Vale refeição ou "VA" - Vale alimentação
@param cTipoVale, characters, "1" - Vale Refeição ou "2" - Vale Alimentação
/*/
Function fCrgAutom(cTipo, cTipoVale, lGrava)
	
	Local aArea			:= GetArea()
	Local aAreaRFO		:= RFO->(GetArea())
	Local aAloc			:= {}
	Local nI, nJ		:= 1
	Local lOk			:= .F.
	Local nCrit			:= 0
	Local nX			:= 0
	Local aDias			:= {}
	Local nDias			:= 0
	Local nPosAdias		:= 0
	Local lDesprezar	:= .F.
	Local lNovo			:= .T.
	Local lFrist		:= .T.
	Local lRepete		:= .F.
	Local cChave		:= ""
	Local cCCChave		:= ""
	Local cFilChave		:= ""
	local cDeptoChave	:= ""
	Local cPostoChave	:= ""
	Local cSindChave	:= ""
	Local cCargoChave	:= ""
	Local cCodBen		:= ""
	Local cTurnoChave	:= ""
	Local cFuncaoChave	:= ""
	Local cChaveBEN		:= ""
	Local cCCTChave		:= ""
	Local cTipoBen		:= ""
	Local cCodSLY		:= ""
	Local cEntidade		:= ""
	Local aCCTChave		:= ""
	Local aTransf		:= {}
		
	DEFAULT cTipo		:= If(cTipoRot == "D", "VR", "VA") //1-Vale Refeição / 2-Vale Alimentação
	DEFAULT cTipoVale	:= If(cTipoRot == "D", "1", "2") //0-Vale Transporte / 1-Vale Refeição / 2-Vale Alimentação
	DEFAULT lGrava		:= .T.
	DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo
	
	If __lMemCalc
		fAddMemLog("Periodo de Calculo : " + dtoc(dDataDe) + " a " + dtoc(dDataAte) ,1,1)
	EndIf
	
	fCarrAdias(dDataDe, dDataAte) // Carrega o array _aDias com os dias do mês
	
	If Empty(aCriterio) .Or. cTipo <> cTipoCri
		CargaCrit(cTipo, @aCriterio, dDataDe, dDataAte)
		cTipoCri := cTipo
	EndIf
	
	// Carrega transferências do funcionário
	If fTransf(@aTransf, MesAno(dDataDe), , , , , , , , , , , SRA->RA_FILIAL, SRA->RA_MAT)
		For nI := 1 To Len(aTransf)
			If aTransf[nI][2] != SRA->RA_FILIAL		// Transferência de Filial
				cFilChave += SubStr(aTransf[nI][2], 1, FWGetTamFilial) + "|"
			EndIf
			If aTransf[nI][3] != SRA->RA_CC			// Transferência de Centro de Custo
				cCCChave += aTransf[nI][3] + "|"
			EndIf
			If aTransf[nI][16] != SRA->RA_DEPTO		// Transferência de Departamento
				cDeptoChave += aTransf[nI][16] + "|"
			EndIf
			If aTransf[nI][18] != SRA->RA_POSTO		// Transferência de Posto
				cPostoChave += aTransf[nI][18] + "|"
			EndIf
		Next
	EndIf
	
	If __lMemCalc .And. !Empty(cFilChave)
		fAddMemLog("Transferências Filial : " + cFilChave ,1,1)
	EndIf
	If __lMemCalc .And. !Empty(cCCChave)
		fAddMemLog("Transferências CC : " + cCCChave ,1,1)
	EndIf
	If __lMemCalc .And. !Empty(cDeptoChave)
		fAddMemLog("Transferências Depto : " + cDeptoChave ,1,1)
	EndIf
	If __lMemCalc .And. !Empty(cPostoChave)
		fAddMemLog("Transferências Posto : " + cPostoChave ,1,1)
	EndIf
	
	//Carrega alterações no cadastro do Funcionário
	//Alteração de Sindicato
	aTransf := HistSRA("RCE")
	For nI := 1 To Len(aTransf)
		cSindChave += aTransf[nI][2] + "|"
	Next
	
	//Alteração de Cargo
	aTransf := HistSRA("SQ3")
	For nI := 1 To Len(aTransf)
		cCargoChave += aTransf[nI][2] + "|"
	Next
	
	//Alteração de Turno
	aTransf := HistSPF( dDataDe, dDataAte)
	For nI := 1 To Len(aTransf)
		cTurnoChave += aTransf[nI][2] + "|"
	Next
	
	//Alteração de Função
	aTransf := HistSR7()
	For nI := 1 To Len(aTransf)
		cFuncaoChave += aTransf[nI][2] + "|"
	Next
	
	cCCChave		+= SRA->RA_CC		// Adiciona Centro de Custo atual na Chave
	cFilChave		+= SRA->RA_FILIAL	// Adiciona Filial atual na Chave
	cDeptoChave		+= SRA->RA_DEPTO	// Adiciona Departamento atual na Chave
	cPostoChave		+= SRA->RA_POSTO	// Adiciona Posto atual na Chave
	cSindChave		+= SRA->RA_SINDICA	// Adiciona Sindicato atual na Chave
	cCargoChave		+= SRA->RA_CARGO	// Adiciona Cargo atual na Chave
	cTurnoChave		+= SRA->RA_TNOTRAB	// Adiciona Turno atual na Chave
	cFuncaoChave	+= SRA->RA_CODFUNC	// Adiciona Função atual na Chave
	aCCTChave		:= {} 				//Zera pois deve carregar apenas se houver critério de CCT definido
	
	For nI := 1 To Len(aCriterio)
		
		If cTipoVale == "OUT" .And. aCriterio[nI][12] $ "VR*VA*PS"
			Loop
		EndIf
		
		// Verifica se possui mesmo Tipo de Beneficio em mais de 1 linha do critério na mesma Entidade
		// ou o mesmo tipo de benefício em hiearquias diferentes
		lDesprezar 	:= .F.
		lRepete 	:= .F.
		If nI > 1 
			For nX := 1 To (nI-1)
				If cTipoVale <> "OUT" .And. cEntidade == aCriterio[nI, 1] .And. aCriterio[nI, 1] == aCriterio[nX, 1] .And. aCriterio[nI, 4] == aCriterio[nX, 4]
					lRepete 	:= .T.
				ElseIf cTipoVale == "OUT" .And. aCriterio[nI, 1] != aCriterio[nX, 1] .And. aCriterio[nI, 12] == aCriterio[nX, 12]
					lDesprezar 	:= .T.		
				EndIf
				If lRepete .Or. lDesprezar
					Exit
				EndIf
			Next nX
		EndIf

		If lDesprezar
			Loop
		EndIf

		cChave	:= Alltrim(aCriterio[nI][2])
		If __lMemCalc
			fAddMemLog("Tabela Critério : " + aCriterio[nI][1] ,1,1)
			fAddMemLog("Chave Critério : " + cChave ,1,1)
		EndIf
		
		nDias	:= 0
		lOk		:= .F.
		lNovo 	:= .T.
		
		If ! lOk .And. (aCriterio[nI][1] == "SQB") // Departamento
			lOk := cChave $ cDeptoChave
			nDias := If(lOk, NroDias("SQB", cChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If ! lOk .And. (aCriterio[nI][1] == "RCE") // Sindicato
			lOk := cChave $ cSindChave
			nDias := If(lOk, NroDias("RCE", cChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If ! lOk .And. (aCriterio[nI][1] == "CTT") // Centro de Custo
			lOk := cChave $ cCCChave
			nDias := If(lOk, NroDias("CTT", cChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If ! lOk .And. (aCriterio[nI][1] == "SQ3") // Cargo
			lOk := cChave $ cCargoChave
			nDias := If(lOk, NroDias("SQ3", cChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If ! lOk .And. (aCriterio[nI][1] == "RCL") // Posto
			lOk := cChave $ cPostoChave
			nDias := If(lOk, NroDias("RCL", cChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If ! lOk .And. (aCriterio[nI][1] == "SRJ") // Função
			lOk := cChave $ cFuncaoChave
			nDias := If(lOk, NroDias("SRJ", cChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If ! lOk .And. (aCriterio[nI][1] == "SR6") // Turno
			lOk := cChave $ cTurnoChave
			nDias := If(lOk, NroDias("SR6", cChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If ! lOk .And. (aCriterio[nI][1] == "SWY") // Convenção Coletiva de Trabalho
			If Empty(aCCTChave)
				aCCTChave := fLoadCCT(cChave, cFilChave)
			EndIf
			cCCTChave := ""
			aEval(aCCTChave, {|x| If(x $ cSindChave, cCCTChave += x + "/", Nil)})
			lOk := !Empty(cCCTChave)
			nDias := If(lOk, NroDias("SWY", cCCTChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If ! lOk .And. (aCriterio[nI][1] == "SM0") // Filial
			lOk := cChave $ cFilChave
			nDias := If(lOk, NroDias("SM0", cChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If !lOk .And. lUsaGS .and. (aCriterio[nI][1] $ "ABS*SA1*TDX") // Local de Atendimento ou Cliente ou Turno do Posto
			If lFrist
				AA1->(DbSetOrder(7)) // AA1_FILIAL, AA1_CDFUNC, AA1_FUNFIL
				If AA1->(DbSeek(xFilial("AA1") + SRA->RA_MAT + SRA->RA_FILIAL))
					aAloc := TXRetAloc(SRA->RA_FILIAL, SRA->RA_MAT, dDataDe, dDataAte)
					For nX := 1 To Len(aAloc)
						Aadd(aAloc[nX], 0)
					Next
				EndIf
				lFrist := .F.
			EndIf
			For nX := 1 to Len(aAloc)
				If ( aCriterio[nI][1] == "ABS" .And. AllTrim(aAloc[nX][07]) == cChave ) .or. ( aCriterio[nI][1] == "SA1" .And. AllTrim(aAloc[nX][10] + aAloc[nX][11]) == cChave ) .or. ( aCriterio[nI][1] == "TDX" .And. AllTrim(aAloc[nX][15] + aAloc[nX][08]) == cChave )
					lPaga := fVldCrit(aAloc[nX],aCriterio[nI],aDiasMes)
					
					If lPaga .And. aAloc[nX][Len(aAloc[nX])] == 0	// Se o dia deve ser pago e não foi pago em um critério anterior
						nDias++
						If cTipoVale != "OUT" 
							aAloc[nX][Len(aAloc[nX])] := 1
							
							If (nPosAdias := Ascan( _aDias, { |X| X[1] == aAloc[nX][02] } )) > 0
								_aDias[nPosAdias][4] := .F.
								If FindFunction("TecBAtuDia")
									TecBAtuDia( SRA->RA_FILIAL, SRA->RA_MAT, _aDias[nPosAdias][1], .F. )
								EndIf
							EndIf
						EndIf
					ElseIf ! lPaga	// Se o dia não deve ser pago
						aAloc[nX][Len(aAloc[nX])] := 1
						If (nPosAdias := Ascan( _aDias, { |X| X[1] == aAloc[nX][02] } )) > 0
							_aDias[nPosAdias][4] := .F.
							If FindFunction("TecBAtuDia")
								TecBAtuDia( SRA->RA_FILIAL, SRA->RA_MAT, _aDias[nPosAdias][1], .F. )
							EndIf
						EndIf
					EndIf
				EndIf
			Next nX
			If __lMemCalc
				fAddMemLog("Mínimo informado no critério : " + cValtochar(aCriterio[nI][13]) ,1,1)
				fAddMemLog("Dias  : " + cvaltochar(nDias) ,1,1)
			EndIf
			If cTipoVale != "OUT" .And. nDias > 0 .And. nDias >= aCriterio[nI, 13]	//Se quantidade de dias maior que 0 e maior que o número minimo de dias informado no crit
				aAdd(aDias, {nI, nDias, .T., 0})
			ElseIf cTipoVale == "OUT" 
				lOk := .T.
				If nDias < aCriterio[nI, 13]
					nDias := 0
				EndIf
			Endif
		EndIf
		If lOk .And. nDias > 0
			nCrit 		:= nI
			cCodBen 	:= Alltrim(aCriterio[nCrit][3])
			cTipoBen 	:= Alltrim(aCriterio[nCrit][12])
			cCodSLY 	:= Alltrim(aCriterio[nCrit][3])
			For nJ := 1 To Len(aDias)
				If cTipoVale == "OUT" .And. aCriterio[aDias[nJ, 1]][12] == cTipoBen .And. aCriterio[aDias[nJ, 1]][3] == cCodSLY
					lNovo := .F.
					EXIT
				Else
					If (cTipoVale != "OUT" .And. Alltrim(aCriterio[aDias[nJ, 1]][3]) == cCodBen) .Or. (cTipoVale == "OUT" .And. aCriterio[aDias[nJ, 1]][12] == cTipoBen .And. Alltrim(aCriterio[aDias[nJ, 1]][3]) == cCodBen)
						aDias[nJ][2] += nDias
						lNovo := .F.
					EndIf
				EndIf
			Next
			If lNovo
				Aadd(aDias, {nI, nDias, .T., 0})
				lNovo := .T.
				If Empty(cEntidade)
					cEntidade := aCriterio[nCrit][1]
				EndIf
			EndIf
		EndIf
	Next nI
	
	If Len(aDias) > 0
		
		RFO->(DbSetOrder(1)) //RFO_FILIAL+RFO_TPVALE+RFO_CODIGO
		
		If cTipoVale <> "OUT"
			If LNOVOCALCB
				//Grava SM7
				DbSelectArea("SM7")
				SM7->(DbSetOrder(3))
				
				For nX := 1 to Len(aDias)
					nCrit := aDias[nX,1]
					
					RFO->(DbSeek(xFilial("RFO")+cTipoVale + Alltrim(aCriterio[nCrit][3])))
					
					If SM7->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cTipoVale + Alltrim(aCriterio[nCrit][3])))
						lNovo := .F.
					Else
						lNovo := .T.
					EndIf
					
					RecLock("SM7",lNovo)
						
						SM7->M7_FILIAL 	:= SRA->RA_FILIAL
						SM7->M7_MAT		:= SRA->RA_MAT
						SM7->M7_CODIGO	:= Alltrim(aCriterio[nCrit][3])
						SM7->M7_TPCALC	:= "2"
						SM7->M7_QDIAINF	:= 1
						SM7->M7_TPVALE	:= cTipoVale
						SM7->M7_COMPL	:= "2"
						If aDias[nX,3] //Se for criterio de serviços, grava os dias calculados no campo R0_DPROPIN para que elessejam considerados no calculo.
							If RFO->RFO_DIAFIX > 0
								SM7->M7_DPROPIN := RFO->RFO_DIAFIX
							Else
								SM7->M7_DPROPIN := aDias[nX, 2]
							EndIf
						EndIf
						
					SM7->(MsUnlock())
				Next nX
			Else
				//Grava SR0
				DbSelectArea("SR0")
				SR0->(DbSetOrder(3))
				
				For nX := 1 to Len(aDias)
					nCrit := aDias[nX, 1]
					
					RFO->(DbSeek(xFilial("RFO")+cTipoVale + Alltrim(aCriterio[nCrit][3])))
					
					If SR0->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cTipoVale + Alltrim(aCriterio[nCrit][3])))
						lNovo := .F.
					Else
						lNovo := .T.
					EndIf
					
					RecLock("SR0",lNovo)
						
						SR0->R0_FILIAL 	:= SRA->RA_FILIAL
						SR0->R0_MAT		:= SRA->RA_MAT
						SR0->R0_CODIGO	:= Alltrim(aCriterio[nCrit][3])
						SR0->R0_TPCALC	:= "2"
						SR0->R0_QDIAINF	:= 1
						SR0->R0_TPVALE	:= cTipoVale
						If aDias[nX,3] //Se for criterio de serviços, grava os dias calculados no campo R0_DPROPIN para que elessejam considerados no calculo.
							If RFO->RFO_DIAFIX > 0
								SR0->R0_DPROPIN := RFO->RFO_DIAFIX
							Else
								SR0->R0_DPROPIN := aDias[nX, 2]
							EndIf
							SR0->R0_QDIADIF := aDias[nX, 4]//Grava a diferença de dias com relação ao periodo anterior
						EndIf
						
					SR0->(MsUnlock())
				Next nX
			EndIf
		Else
			DbSelectArea("RIS")
			DbSetOrder(1) //RIS_FILIAL + RIS_TPBENE + RIS_COD + STR(RIS_SALATE)
			
			DbSelectArea("RI1")
			RI1->(DbSetOrder(1)) // RI1_FILIAL + RI1_MAT + RI1_BENEF + RI1_TABELA
			
			For nX := 1 to Len(aDias)
				nCrit := aDias[nX,1]
				
				If aCriterio[nCrit][12] $ "VR*VA*PS"
					Loop
				EndIf
				
				// Preserva os benefícios informados
				cChaveBEN := Alltrim(aCriterio[nCrit][3]) + Alltrim(aCriterio[nCrit][12])
				If aScan(aBenRI1, {|x| AllTrim(x[3]) + AllTrim(x[2]) == cChaveBEN }) > 0
					LOOP
				EndIf
				
				RIS->(DbSeek(xFilial("RIS", SRA->RA_FILIAL) + aCriterio[nCrit][12] + Alltrim(aCriterio[nCrit][3] )))
				cProp := RIS->RIS_PROPOR
				
				If Empty(cProp)
					cProp := "2"
				EndIf
				
				If lGrava
					If RI1->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + aCriterio[nCrit][12] + Alltrim(aCriterio[nCrit][3])))
						lNovo := .F.
					Else
						lNovo := .T.
					EndIf
					
					RecLock("RI1", lNovo)
						
						RI1->RI1_FILIAL 	:= SRA->RA_FILIAL
						RI1->RI1_MAT		:= SRA->RA_MAT
						RI1->RI1_COD		:= "001"
						RI1->RI1_BENEF		:= aCriterio[nCrit][12]
						RI1->RI1_TABELA		:= Alltrim(aCriterio[nCrit][3])
						RI1->RI1_PROPOR		:= cProp
						RI1->RI1_TPCALC		:= "2"
						RI1->RI1_PD			:= RIS->RIS_PD
						RI1->RI1_PD1		:= RIS->RIS_PD1
						RI1->RI1_PD2		:= RIS->RIS_PD2
						RI1->RI1_DINIPG		:= StoD(aCriterio[nCrit][14])
						RI1->RI1_DFIMPG		:= StoD(aCriterio[nCrit][15])
						
					RI1->(MsUnlock())
				EndIf
				//Adiciona no array para calculo
				aAdd(aBenRI1, {RI1->RI1_MAT, RI1->RI1_BENEF, RI1->RI1_TABELA, RI1->RI1_PD, RI1->RI1_PD1, RI1->RI1_PD2, RI1->RI1_PROPOR})
			Next nX
		EndIf
	EndIf
	
	_aDias				:= {} // Zera array com os dias do funcionário
	RestArea(aAreaRFO)
	RestArea(aArea)

Return Nil

/*/{Protheus.doc} fApurPAnt
Apura pagamento de beneficios no periodo anterior.
@author Leandro Drumond
@since 28/04/2015
@param aPerAux, array, Período que será recalculado
@param cTipoVale, characters, "1" - Vale Refeição ou "2" - Vale Alimentação
@param aCritRet, array, Array com o critério de benefícios
@return nDiferenca, Numérico, Diferença entre o que foi pago e o que era devido para o funcionário no mês anterior
/*/
Function fApurPAnt(aPerAux, cTipoVale, aCritRet, cCodSM7)

	Local aAloc			:= {}
	Local aDiasAux		:= {}
	Local aDiasMesAnt	:= {}
	Local aTransf		:= {}
	Local aRet			:= {0, ""}
	Local cChave		:= ""
	Local cTnoAux		:= SRA->RA_TNOTRAB
	Local nI			:= 0
	Local nX			:= 0
	Local nDias			:= 0
	Local nDiasAux1		:= 0
	Local nDiasAux2		:= 0
	Local nCrit			:= 0
	Local nPosAdias		:= 0
	Local nValPago		:= 0
	Local nValDevido	:= 0
	Local nDiasFixos	:= 0
	Local nValUni		:= 0
	Local nDiferenca	:= 0
	Local lAchou		:= .F.
	Local lAchouRG2		:= .F.
	Local lOk			:= .F.
	Local lPaga			:= .F.
	Local lFrist		:= .T.
	Local cCodBen		:= ""
	Local cCCChave		:= ""
	Local cDeptoChave	:= ""
	Local cPostoChave	:= ""
	Local cFilChave		:= ""
	Local cSindChave	:= ""
	Local cCargoChave	:= ""
	Local cTurnoChave	:= ""
	Local cFuncaoChave	:= ""
	Local cCampos		:= ""
	Local cAliasRG2		:= ""
	Local cCCTChave		:= ""
	Local aCCTChave		:= {}
	Local cWhereCod		:= "%%"
	Local cTipo			:= If(cTipoVale == "2", "VA", If(cTipoVale == "1", "VR", ""))
	Local lSLDANT		:= .F.

	Static nTamRg2Cd	:= TamSX3("RG2_CODIGO")[1]

	DEFAULT aCritRet 	:= {}
	DEFAULT cCodSM7 	:= ""

	CargaCrit(cTipo, @aCriterio, aPerAux[5], aPerAux[6])

	If ! Empty(aCritRet)
		aCriterio := aCritRet
	EndIf

	fCarrAdias(aPerAux[5], aPerAux[6], aPerAux[1]) // Carrega o array _aDias com os dias do mês

	// Carrega transferências do funcionário
	If fTransf(@aTransf, aPerAux[1], , , , , , , , , , , SRA->RA_FILIAL, SRA->RA_MAT)
		For nI := 1 To Len(aTransf)
			If aTransf[nI][2] != SRA->RA_FILIAL		// Transferência de Filial
				cFilChave += SubStr(aTransf[nI][2], 1, FWGetTamFilial) + "|"
			EndIf
			If aTransf[nI][3] != SRA->RA_CC			// Transferência de Centro de Custo
				cCCChave += aTransf[nI][3] + "|"
			EndIf
			If aTransf[nI][16] != SRA->RA_DEPTO		// Transferência de Departamento
				cDeptoChave += aTransf[nI][16] + "|"
			EndIf
			If aTransf[nI][18] != SRA->RA_POSTO		// Transferência de posto
				cPostoChave += aTransf[nI][18] + "|"
			EndIf
		Next
	EndIf

	// Verifica alterações no cadastro de Funcionários
	// Alterações de Sindicato
	aTransf := HistSRA("RCE")
	For nI := 1 To Len(aTransf)
		cSindChave += aTransf[nI][2] + "|"
	Next

	// Alterações de Cargo
	aTransf := HistSRA("SQ3")
	For nI := 1 To Len(aTransf)
		cCargoChave += aTransf[nI][2] + "|"
	Next

	// Alterações de Turno
	aTransf := HistSPF( aPerAux[5], aPerAux[6])
	For nI := 1 To Len(aTransf)
		cTurnoChave += aTransf[nI][2] + "|"
	Next

	// Alterações de Função
	aTransf := HistSR7()
	For nI := 1 To Len(aTransf)
		cFuncaoChave += aTransf[nI][2] + "|"
	Next

	cCCChave		+= SRA->RA_CC		// Adiciona Centro de Custo atual na Chave
	cFilChave		+= SRA->RA_FILIAL	// Adiciona Filial atual na Chave
	cDeptoChave		+= SRA->RA_DEPTO	// Adiciona Departamento atual na Chave
	cPostoChave		+= SRA->RA_POSTO	// Adiciona Posto atual na Chave
	cSindChave		+= SRA->RA_SINDICA	// Adiciona Sindicato atual na Chave
	cCargoChave		+= SRA->RA_CARGO	// Adiciona Cargo atual na Chave
	cTurnoChave		+= SRA->RA_TNOTRAB	// Adiciona Turno atual na Chave
	cFuncaoChave	+= SRA->RA_CODFUNC	// Adiciona Função atual na Chave
	aCCTChave		:= {} 				//Zera pois deve carregar apenas se houver critério de CCT definido

	For nI := 1 To Len(aCriterio)
		cChave := Alltrim(aCriterio[nI][2])
		nDias  := 0
		If !Empty(cCodSM7) .And. AllTrim(cCodSM7) != Alltrim(aCriterio[nI][3])
			Loop
		EndIf
		Do Case
			Case (aCriterio[nI][1] $ "ABS*SA1*TDX") // Local de Atendimento * Cliente * Turno do Posto (Entidades do Gestão de Serviços)

				If lFrist
					If lUsaGS
						AA1->(DbSetOrder(7)) // AA1_FILIAL, AA1_CDFUNC, AA1_FUNFIL
						If AA1->(DbSeek(xFilial("AA1") + SRA->RA_MAT + SRA->RA_FILIAL))
							aAloc := TXRetAloc(SRA->RA_FILIAL, SRA->RA_MAT, aPerAux[5], aPerAux[6])

							For nX := 1 To Len(aAloc)
								Aadd(aAloc[nX], 0)
							Next
						EndIf
					EndIf
					lFrist := .F.
				EndIf

				For nX := 1 to Len(aAloc)
					If ( aCriterio[nI][1] == "ABS" .And. aAloc[nX][07] == cChave ) .or. ( aCriterio[nI][1] == "SA1" .And. aAloc[nX][10] + aAloc[nX][11] == cChave ) .or. ( aCriterio[nI][1] == "TDX" .And. aAloc[nX][15] + aAloc[nX][08] == cChave )
						If ( aCriterio[nI][10] <> "1" .or. aCriterio[nI][11] <> "1" ) .And. Empty(aDiasMesAnt) //Se não paga ferias ou afastamentos, monta DiasMes do periodo anterior.
							RCG->(DbSetOrder(RetOrder("RCG","RCG_FILIAL+RCG_PROCES+RCG_PER+RCG_SEMANA+RCG_ROTEIR+RCG_TNOTRA+DTOS(RCG_DIAMES)")))
							lAchou := RCG->( dbSeek(xFilial("RCG") + SRA->RA_PROCES + aPerAux[1] + aPerAux[2] + Space(3) + cTnoAux ) )
							If !lAchou
								cTnoAux := "@@@"
								lAchou := RCG->( dbSeek(xFilial("RCG") + SRA->RA_PROCES + aPerAux[1] + aPerAux[2] + Space(3) + cTnoAux ) )
							EndIf
							If lAchou
								While !RCG->( Eof() )  .And. RCG->(RCG_FILIAL + RCG_PROCES + RCG_PER + RCG_SEMANA + RCG_ROTEIR + RCG_TNOTRA ) == xFilial("RCG") + SRA->RA_PROCES + aPerAux[1] + aPerAux[2] + Space(3) + cTnoAux
									aAdd( aDiasMesAnt, {RCG->RCG_DIAMES, RCG->RCG_TIPDIA, "", .T.,  "" } )
									RCG->( DbSkip() )
								Enddo
								nDiasAux1 := DiasTrab
								nDiasAux2 := nDiasAfas
								fVlsAus(aPerAux[5], aPerAux[6], , @aDiasMesAnt)
								nDiasAfas := nDiasAux2
								DiasTrab  := nDiasAux1
								nDiasAux1 := nFerVen
								fVlsFerPrg(aPerAux[5], aPerAux[6],@aDiasMesAnt)
								nFerVen   := nDiasAux1
							EndIf
						EndIf
						lPaga := fVldCrit(aAloc[nX], aCriterio[nI], aDiasMesAnt)
						If lPaga .And. aAloc[nX][Len(aAloc[nX])] == 0 // Se o dia deve ser paga e se ainda não foi pago em outro critério
							nDias++
							aAloc[nX][Len(aAloc[nX])] := 1
							If (nPosAdias := Ascan( _aDias, { |X| X[1] == aAloc[nX][02] } )) > 0
								_aDias[nPosAdias][4] := .F.
							EndIf
						ElseIf ! lPaga // Se o dia não deve ser pago
							aAloc[nX][Len(aAloc[nX])] := 1
							If (nPosAdias := Ascan( _aDias, { |X| X[1] == aAloc[nX][02] } )) > 0
								_aDias[nPosAdias][4] := .F.
							EndIf
						EndIf
					EndIf
				Next nX

				lOk := nDias > 0

			Case (aCriterio[nI][1] == "CTT") // Centro de Custo
				lOk := cChave $ cCCChave
				nDias := If(lOk, NroDias("CTT", cChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)

			Case (aCriterio[nI][1] == "SQB") // Departamento
				lOk := cChave $ cDeptoChave
				nDias := If(lOk, NroDias("SQB", cChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)

			Case (aCriterio[nI][1] == "RCL") // Posto
				lOk := cChave $ cPostoChave
				nDias := If(lOk, NroDias("RCL", cChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)

			Case (aCriterio[nI][1] == "SM0") // Filial
				lOk := cChave $ cFilChave
				nDias := If(lOk, NroDias("SM0", cChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)

			Case (aCriterio[nI][1] == "RCE") // Sindicato
				lOk := cChave $ cSindChave
				nDias := If(lOk, NroDias("RCE", cChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)

			Case (aCriterio[nI][1] == "SQ3") // Cargo
				lOk := cChave $ cCargoChave
				nDias := If(lOk, NroDias("SQ3", cChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)

			Case (aCriterio[nI][1] == "SR6") // Turno
				lOk := cChave $ cTurnoChave
				nDias := If(lOk, NroDias("SR6", cChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)

			Case (aCriterio[nI][1] == "SRJ") // Função
				lOk := cChave $ cFuncaoChave
				nDias := If(lOk, NroDias("SRJ", cChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)

			Case (aCriterio[nI][1] == "SWY") // Convenção Coletiva de Trabalho
				If Empty(aCCTChave)
					aCCTChave := fLoadCCT(cChave, cFilChave)
				EndIf
				cCCTChave := ""
				aEval(aCCTChave, {|x| If(x $ cSindChave, cCCTChave += x + "/", Nil)})
				lOk := !Empty(cCCTChave)
				nDias := If(lOk, NroDias("SWY", cCCTChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)
			Otherwise
				lOk := .F.
		EndCase

		If nDias > 0 .And. nDias >= aCriterio[nI, 13]	//Se quantidade de dias maior que 0 e maior que o número minimo de dias informado no crit
			Aadd(aDiasAux, {nI, nDias, 0, 0, 0, 0, .F.})
		EndIf

	Next nI

	If Len(aDiasAux) > 0

		DbSelectArea("RG2")
		DbSetOrder(1)	// RG2_FILIAL + RG2_MAT + RG2_TPVALE + RG2_CODIGO + RG2_PERIOD + RG2_NROPGT + RG2_ROTEIR

		lSLDANT := RG2->(ColumnPos("RG2_SLDANT")) > 0

		cAliasRG2 := GetNextAlias()

		// Busca valor pago no mês anterior
		If lSLDANT
			cCampos := "%RG2_VALCAL, RG2_SLDANT, RG2_CODIGO%"
		Else
			cCampos := "%RG2_VALCAL, RG2_CODIGO%"
		EndIf

		If !Empty(cCodSM7)
			cWhereCod	:= "%AND RG2_CODIGO = '" + cCodSM7 + "'%"
		EndIf

		BeginSQL ALIAS cAliasRG2

			SELECT %Exp: cCampos%

			FROM %Table:RG2% RG2

			WHERE RG2_FILIAL = %Exp:SRA->RA_FILIAL%
			AND RG2_MAT = %Exp:SRA->RA_MAT%
			AND RG2_TPVALE = %Exp:cTipoVale%
			AND RG2_PERIOD = %Exp:aPerAux[1]%
			AND RG2_NROPGT = %Exp:aPerAux[2]%
			AND RG2_ROTEIR = %Exp:aPerAux[8]%
			AND RG2.%notDel%
			%Exp:cWhereCod%

		ENdSQL

		While ! (cAliasRG2)->(Eof())
			If(lSLDANT, nValPago += (cAliasRG2)->(RG2_VALCAL + RG2_SLDANT), nValPago += (cAliasRG2)->RG2_VALCAL)
			cCodBen 	:= (cAliasRG2)->RG2_CODIGO
			lAchouRG2 	:= .T.
			(cAliasRG2)->(dbSkip())
		EndDo

		(cAliasRG2)->(dbCloseArea())

		// Calcula valor devido para o funcionário
		If lAchouRG2
			For nX := 1 To Len(aDiasAux)

				nCrit := aDiasAux[nX, 1]
				cCodBen := Padr(aCriterio[nCrit, 3], nTamRg2Cd )

				nDiasFixos := Posicione("RFO", 1, xFilial("RFO", SRA->RA_FILIAL) + cTipoVale + cCodBen, "RFO_DIAFIX")
				nValUni := RFO->RFO_VALOR

				nValDevido += If( ! Empty(nDiasFixos), nDiasFixos * nValUni, aDiasAux[nX, 2] * nValUni)

			Next
		
			// calcula a diferença entre o que foi pago e o que é devido
			nDiferenca := nValDevido - nValpago

			aRet := {nDiferenca, cCodBen}
		EndIf
	EndIf

	_aDias := {} // Zera array com os dias do funcionário

Return aRet

/*/{Protheus.doc} fVldCrit
Valida criterios de servicos.
@author Leandro Drumond
@since 28/04/2015
/*/
Static Function fVldCrit(aAloc,aCriterio,aDiasMes)

Local lPaga := .F.

	lPaga := aAloc[Len(aAloc)] == 0 // Se não foi pago em um critério anterior (Estará sempre na última posição)
	If lPaga
		If (lPaga := ! aAloc[13] .or. aCriterio[08] == "1") // Se não for falta ou se estiver definido para pagar falta
			If (lPaga := ! aAloc[12] .or. aCriterio[07] == "1") // Se nao for feriado ou se estiver definido para pagar feriado
				If (lPaga := Dow(aAloc[02]) <> 1 .or. aCriterio[06] == "1") //Se não for domingo ou se estiver definido para pagar o domingo
					If (lPaga := Dow(aAloc[02]) <> 7 .or. aCriterio[05] == "1") //Se não for sabado ou se estiver definido para pagar o sabado
						If (lPaga := ! aAloc[14] .or. aCriterio[09] == "1") //Se não for substituto ou se estiver definido para pagar substituição
							If aCriterio[10] <> "1" //Não paga afastamento e férias
								If (nPos := Ascan( aDiasMes , { |X| X[1] == aAloc[02] } )) > 0
									If aDiasMes[nPos, 5] == "AFA" .or. aDiasMes[nPos, 5] == "FER"
										lPaga := .F.
									EndIf
								EndIf
							EndIf
						EndIf
						If lPaga
							If aCriterio[11] <> "1" //Não paga férias programadas
								If (nPos := Ascan( aDiasMes, { |X| X[1] == aAloc[02] } )) > 0
									If aDiasMes[nPos,5] == "PRG"
										lPaga := .F.
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
			If lPaga
				If DateWorkDay( aAloc[02] , aAloc[02], .F., .F., .F. ) > 0 .And. aCriterio[04] <> "1" //É dia útil e esta definido para não pagar dias úteis
					lPaga := .F.
				EndIf
			EndIf
		EndIf
	EndIf

Return lPaga

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³CargaCrit    ºAutor  ³Flavio S Correa  º Data ³ 22/02/2014  º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Carrega beneficios por criterio			                      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³Roteiros de Calculo			                                  º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function CargaCrit(cTipo, aCriterio, dDt1, dDt2)

Local aArea			:= GetArea()
Local cQry			:= GetNextAlias()
Local cSGBD			:= AllTrim( Upper( TcGetDb() ) )
Local cWhere		:= ""
Local cLimite		:= ""
Local cWhereFil		:= "%%"
Local cSelect		:= ""

Default dDt1		:= aPeriodo[nPosSem,3] //Data inicial do periodo de calculo
Default dDt2		:= aPeriodo[nPosSem,4] //Data final do periodo de calculo

Do Case
	Case cSGBD $ "ORACLE/MYSQL/POSTGRES/DB2"
		cLimite += If(cSGBD $ "ORACLE", " WHERE ROWNUM <= 1 ", If(cSGBD $ "MYSQL/POSTGRES", " TSTALIAS LIMIT 1 ", " FETCH FIRST 1 ROW ONLY "))
	Case cSGBD $ "INFORMIX"
	Otherwise
		cSelect := " TOP 1 "
EndCase

cWhere  := "% " + cWhere + " %"

If !Empty( xFilial("SJQ") )
	cWhereFil	:= "% LY_FILIAL = '"+ xFilial("SLY") + "' AND %"
EndIf

If !Empty(cSelect) //MSSQLServer
	cSelect := "% " + cSelect + " %"

	BEGINSQL ALIAS cQry
		SELECT * FROM %table:SLY% SLY
		INNER JOIN %table:SJS% SJS on JS_FILIAL = %xfilial:SJS% AND JS_CDAGRUP = LY_AGRUP and JS_TABELA = LY_ALIAS and SJS.%notDel%
		WHERE %exp:cWhereFil%
		LY_TIPO IN (%exp:cTipo%)
		AND LY_AGRUP=(SELECT %exp:cSelect% JQ_CODIGO
						FROM %table:SJQ%  SJQ
						WHERE SJQ.%notDel%
						AND JQ_FILIAL = %xfilial:SJQ%
						AND JQ_STATUS = %exp:'1'%
						AND JQ_FILREF IN (%exp:SRA->RA_FILIAL%,'')
						AND ( %exp:AnoMes(dDt1)% >= JQ_PERINI AND (%exp:AnoMes(dDt2)% <= JQ_PERFIM OR JQ_PERFIM = %exp:''%) )
						%exp:cWhere% 
						ORDER BY JQ_FILREF DESC)
		AND ( %exp:dtos(dDt1)% >= LY_DTINI AND (%exp:dtos(dDt2)% <= LY_DTFIM or LY_DTFIM = %exp:''%))	and SLY.%notDel%
		ORDER BY JS_SEQ
	ENDSQL
Else
	cLimite := "% " + cLimite + " %"

	BEGINSQL ALIAS cQry
		SELECT * FROM %table:SLY% SLY
		INNER JOIN %table:SJS% SJS on JS_FILIAL = %xfilial:SJS% AND JS_CDAGRUP = LY_AGRUP and JS_TABELA = LY_ALIAS and SJS.%notDel%
		WHERE %exp:cWhereFil%
		LY_TIPO IN (%exp:cTipo%)
		AND LY_AGRUP=(SELECT CODIGO FROM 
			(SELECT JQ_CODIGO CODIGO
						FROM %table:SJQ%  SJQ
						WHERE SJQ.%notDel%
						AND JQ_FILIAL = %xfilial:SJQ%
						AND JQ_STATUS = %exp:'1'%
						AND JQ_FILREF IN (%exp:SRA->RA_FILIAL%,'')
						AND ( %exp:AnoMes(dDt1)% >= JQ_PERINI AND (%exp:AnoMes(dDt2)% <= JQ_PERFIM OR JQ_PERFIM = %exp:''%) )
						%exp:cWhere% 
						ORDER BY JQ_FILREF DESC) %exp:cLimite% )
		AND ( %exp:dtos(dDt1)% >= LY_DTINI AND (%exp:dtos(dDt2)% <= LY_DTFIM or LY_DTFIM = %exp:''%))	and SLY.%notDel%
		ORDER BY JS_SEQ
	ENDSQL
EndIf

aCriterio := {}
While !(cQry)->(Eof())
	(cQry)->(aAdd(aCriterio, { LY_ALIAS,LY_CHVENT,LY_CODIGO,LY_PGDUT,LY_PGSAB,LY_PGDOM,LY_PGFER,LY_PGFALT,LY_PGSUBS,LY_PGAFAS,LY_PGVAC,LY_TIPO,LY_DIAS,LY_DTINI,LY_DTFIM   } ))
	(cQry)->(dbSkip())
EndDo

(cQry)->(DbCloseArea())

RestArea(aArea)
Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fCrgBenAut     ºAutor  ³Leandro Drumond  º Data ³ 05/05/2015  º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Valida criterios de servicos.  			                      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³Roteiros de Calculo			                                  º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCrgBenAut(lGrava)
Local aArea		:= GetArea()
Local aTabBenef := {}
Local cTipo		:= ""
Local nX		:= 0
Local lCarga	:= .F.
Local lDiasMes	:= .F.

If Empty(aCriterio)
	fCarrTab( @aTabBenef,"S011", Nil,.T.)
	If !Empty(aTabBenef)
		For nX := 1 to Len(aTabBenef)
			cTipo += aTabBenef[nX,5]
			If nX < Len(aTabBenef)
				cTipo += "','"
			EndIf
		Next nX
	EndIf
	If Empty(aCriterio) .Or. cTipo <> cTipoCri
		CargaCrit(cTipo, @aCriterio)
		cTipoCri := cTipo
	EndIf
EndIf

If Len(aCriterio) > 0
	DbSelectArea("RI1")
	DbSetOrder(1)//RI1_FILIAL+RI1_MAT+RI1_BENEF+RI1_TABELA
	
	For nX := 1 to Len(aCriterio)
		If DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + aCriterio[nX,12])
			If RI1->RI1_TPCALC == "2"
				RecLock("RI1",.F.)
				DbDelete()
				MsUnLock()
				lCarga := .T.
			EndIf
		Else
			lCarga := .T.
		EndIf
		If (aCriterio[nX][1] $ "ABS*SA1*TDX")
			lDiasMes := .T.
		EndIf
	Next nX
	
	If lCarga
		If lGrava
			//Carrega aDiasMes
			If lDiasMes
				fVlsAus(,,, @aDiasMes)
				fVlsFerPrg(,,@aDiasMes)
			EndIf
		EndIf
		fCrgAutom(cTipoCri,"OUT",lGrava)
		If !lGrava
			lCarga := !Empty(aBenRI1) //Se não houver critérios lançados para o funcionário, retorna .F. para carregar a definição padrão.
			aBenRI1 := {}
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return lCarga

/*/{Protheus.doc} fSVerbas
Funcao de soma as verbas definidas no cálculo da folha
@author Allyson Mesashi
@since 12/07/2016
@version P12.1.07
@Param cCodigos, Caracter, Código de verbas que serão verificados
@Param nValor, Numérico, Variável contendo o valor das verbas selecionadas
/*/
Static Function fSVerbas(cCodigos, nValor, aVerbas)

Local aPd		:= aClone( If(Type("aBkpPd") != "U" .and. !Empty(aBkpPd), aBkpPd, aVerbas) )
Local cVerbas 	:= ""
Local nFor		:= 0
Local nGarantia	:= 0

// Separa os Codigos das verbas solicitadas a listar
For nFor := 1 To Len(ALLTRIM(cCodigos)) Step 3
	cVerbas += Subs(cCodigos,nFor,3)
	If Len(ALLTRIM(cCodigos)) > ( nFor+3 )
		cVerbas += "/"
	Endif
Next nFor

For nFor := 1 To Len(aPd)
	If aPd[nFor, 3] != cSemana
		Loop
	EndIf
	If aPd[nFor, 1] $ cVerbas
		If RetValSRV( aPd[nFor, 1], SRA->RA_FILIAL, "RV_TIPOCOD" ) == "1"//Proventos
			nValor += aPd[nFor, 5]
		ElseIf RetValSRV( aPd[nFor, 1], SRA->RA_FILIAL, "RV_TIPOCOD" ) == "2"//Descontos
			nValor -= aPd[nFor, 5]
		EndIf
	EndIf
Next nFor

fPosReg("RCE", 1, xFilial("RCE", SRA->RA_FILIAL)+SRA->RA_SINDICA)
nGarantia := RCE->RCE_GCOMIS

If nValor < nGarantia .AND. SRA->RA_CATFUNC $ "C"
	nValor := nGarantia
EndIf

Return Nil


Static Function GetNroPed()

Local aAreaSR0 	:= {}
Local cAliasTab	:= ""

If Empty(cNroPed) .or. cFilPed <> SRA->RA_FILIAL
	aAreaSR0 	:= SR0->( GetArea() )
	cAliasTab	:= GetNextAlias()

	BeginSql Alias cAliasTab
		SELECT MAX(R0_NROPED) NROPED FROM %table:SR0% SR0
		WHERE SR0.R0_FILIAL = %Exp:(xFilial("SR0", SRA->RA_FILIAL))%
			AND %NotDel%
	EndSql

	cNroPed := StrZero( Val((cAliasTab)->NROPED)+1, nTamPed )

	(cAliasTab)->( dbCloseArea() )

	cFilPed := SRA->RA_FILIAL

	RestArea( aAreaSR0 )
	
EndIf

Return cNroPed

/*/{Protheus.doc} CustoVales
Como podemos ter mais de um pedido por periodo é preciso recalcular os custos
@author Flavio Correa
@since 12/08/2016
@version P12.1.07
/*/
Static Function CustoVales(cTipo)
Local aArea			:= GetArea()
Local nCustFunc		:= 0
Local nCalc			:= 0
Local nFechF		:= 0
Local nCustAux		:= 0
Local nI			:= 1
Local aCalc			:= {}
Local cCod			:= ""
Local nTeto			:= 0
Local cAliasQry		:= ""

Private nPercentual	:= RetValSRV(aCodFol[051, 1], SRA->RA_FILIAL, "RV_PERC")

DEFAULT lGp210Sal	:= ExistBlock("GP210SAL")

If cTipo == "0"
	If lGp210Sal
		EXECBLOCK("GP210SAL", .F. , .F. ) //Retorna nPercentual
		If ValType(nPercentual) <> "N"
			nPercentual := 6
		EndIf
	EndIf

	If SRA->RA_CATFUNC $ "E*G"
		nCustFunc := nPercentual := 0
	Else
		nCustFunc := Round(NSALBSVT * ( nPercentual / 100 ),2) //Custo Mensal do Funcionario
	EndIf

	DbSelectArea("SR0")
	SR0->(DbSetOrder(RetOrder("SR0", "R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO+R0_PEDIDO")))
	SR0->(DbSeek(SRA->RA_FILIAL+SRA->RA_MAT+cTipo+cPeriodo))
	While !SR0->(Eof()) .And. SR0->(R0_FILIAL+R0_MAT+R0_TPVALE+R0_PERIOD) == SRA->RA_FILIAL+SRA->RA_MAT+cTipo+cPeriodo
		If SR0->R0_PEDIDO == "1"
			nCalc += SR0->R0_VALCAL
			Aadd(aCalc,SR0->(Recno()))
		Else
			nCustFunc := Max(nCustFunc - SR0->R0_VLRFUNC,0)
		EndIf
		SR0->(dbSkip())
	EndDo

	For nI := 1 To Len(aCalc)
		SR0->(dbGoto(aCalc[nI]))
		RecLock("SR0",.F.)
		If nCustFunc > nCalc
			SR0->R0_VLRFUNC := SR0->R0_VALCAL
			SR0->R0_VLREMP := 0
		Else
			If nI == Len(aCalc)
				SR0->R0_VLRFUNC := nCustFunc - nCustAux
			Else
				SR0->R0_VLRFUNC := Round(nCustFunc / nCalc * SR0->R0_VALCAL, 2) //Rateia custo do VT
				nCustAux += SR0->R0_VLRFUNC
			EndIf
			SR0->R0_VLREMP := SR0->R0_VALCAL - SR0->R0_VLRFUNC  //Custo Empresa
		EndIf

		SR0->(msUnlock())

	Next nI
Else
	cAliasQry := GetNextAlias()
	BeginSql alias cAliasQry
		SELECT SR0.R_E_C_N_O_ AS RECSR0,SR0.*
		FROM %table:SR0% SR0
		WHERE R0_FILIAL = %exp:SRA->RA_FILIAL%
		AND R0_MAT = %exp:SRA->RA_MAT%
		AND R0_TPVALE = %exp:cTipo%
 	    AND SR0.%notDel%
 	    ORDER BY R0_PEDIDO DESC
	EndSql
	cCod := ""
	While !(cAliasQry)->(Eof()) .And. (cAliasQry)->(R0_FILIAL+R0_MAT+R0_TPVALE) == SRA->RA_FILIAL+SRA->RA_MAT+cTipo
		SR0->(dbGoto( (cAliasQry)->RECSR0))
		If cCod <> (cAliasQry)->R0_CODIGO
			nTeto := 0
			nFechF := 0
			If RFO->(DbSeek(xFilial("RFO")+(cAliasQry)->(R0_TPVALE + R0_CODIGO)))
		    	nTeto	 := RFO->RFO_TETO
		    EndIf
	    EndIf

	    If nTeto <= 0
	    	cCod := (cAliasQry)->R0_CODIGO
	    	(cAliasQry)->(dbSkip())
	    	Loop
	    EndIf


	    If (nFechF + (cAliasQry)->R0_VLRFUNC) >= nTeto
	    	nVal :=  nTeto  - nFechF
	    	If nVal > 0
		    	RecLock("SR0",.F.)
		    		SR0->R0_VLRFUNC := nVal
		    		SR0->R0_VLREMP  := (cAliasQry)->R0_VALCAL - nVal
		    	SR0->(msUnlock())
		    Else
		    	RecLock("SR0",.F.)
		    		SR0->R0_VLRFUNC := 0
		    		SR0->R0_VLREMP  := (cAliasQry)->R0_VALCAL
		    	SR0->(msUnlock())
		    EndIf
	    Endif
	    nFechF += (cAliasQry)->R0_VLRFUNC

		cCod := (cAliasQry)->R0_CODIGO
		(cAliasQry)->(dbSkip())
	EndDo
	(cAliasQry)->(dbCloseArea())
EndIf
RestArea(aArea)
Return

/*/{Protheus.doc} FaltasDes
faltas ja descontadas da tabela SP7 = faltas da tabela SR0 com pedido = 2
@author Flavio Correa
@since 12/08/2016
@version P12.1.07
/*/
Static Function FaltasDes(cPeriodo,dDt1,dDt2)
Local aArea		:= GetArea()
Local nDescont 	:= 0
Local cAliasQry	:= GetNextAlias()
Local cTipoVale := If(cTipoRot == "8","0",(If(cTipoRot == "D","1","2"))) //0-Vale Transporte / 1-Vale Refeição / 2-Vale Alimentação

DEFAULT dDt1 	:= aPeriodo[nPosSem,3] //Data inicial do periodo de calculo
DEFAULT dDt2 	:= aPeriodo[nPosSem,4] //Data final do periodo de calculo

dbSelectArea("SP7")

//nao pegar faltas que sao do mesmo periodo(inicio/Fim), pois se for considerar recalculo e sobreescrever as faltas
BeginSql alias cAliasQry
	SELECT SUM(P7_DFALT) TOTALFAL
	FROM %table:SP7% SP7
	WHERE SP7.%notDel%
    AND SP7.P7_FILIAL = %exp:SRA->RA_FILIAL%
    AND SP7.P7_MAT = %exp:SRA->RA_MAT%
    AND SP7.P7_PERIOD = %exp:cPeriodo%
    AND SP7.P7_DATAINI <> %exp:dDt1%
    AND SP7.P7_DATAFIM <> %exp:dDt2%
EndSql
nDescont := (cAliasQry)->TOTALFAL
(cAliasQry)->(DbCloseArea())

BeginSql alias cAliasQry
	SELECT DISTINCT R0_NROPED, R0_FALTAS
	FROM %table:SR0% SR0
	WHERE SR0.%notDel%
    AND SR0.R0_FILIAL = %exp:SRA->RA_FILIAL%
    AND SR0.R0_MAT = %exp:SRA->RA_MAT%
    AND SR0.R0_PERIOD = %exp:cPeriodo%
    AND SR0.R0_TPVALE = %exp:cTipoVale%
    AND SR0.R0_PEDIDO ='2'
EndSql
While !(cAliasQry)->(Eof())
	nDescont += (cAliasQry)->R0_FALTAS
	(cAliasQry)->(dbskip())
EndDo
(cAliasQry)->(DbCloseArea())


RestArea(aArea)
Return nDescont

/*/{Protheus.doc} GravaSP7
Grava faltas descontadas
@author Flavio Correa
@since 12/08/2016
@version P12.1.07
/*/
Static Function GravaSP7(nValor,dDt1,dDt2)
Local aArea	:= GetArea()
Local lNovo	:= .T.

DEFAULT dDt1 	:= aPeriodo[nPosSem,3] //Data inicial do periodo de calculo
DEFAULT dDt2 	:= aPeriodo[nPosSem,4] //Data final do periodo de calculo


dbSelectArea("SP7")

lNovo := !(SP7->(dbSeek(SRA->RA_FILIAL+ SRA->RA_MAT+cPeriodo+dtos(dDt1)+dtos(dDt2))))
RecLock("SP7",lNovo)
	SP7->P7_FILIAL 	:= SRA->RA_FILIAL
	SP7->P7_MAT		:= SRA->RA_MAT
	SP7->P7_PERIOD	:= cPeriodo
	SP7->P7_DFALT	:= nValor
	SP7->P7_DATAINI	:= dDt1
	SP7->P7_DATAFIM	:= dDt2
SP7->(msUnlock())

RestArea(aArea)
Return

/*/{Protheus.doc} NovoCalcBEN
Usa o calculo novo ou nao do beneficios
@author Flavio Correa
@since 12/08/2016
@version P12.1.07
@see http://tdn.totvs.com/x/ikyZDg
/*/
Function NovoCalcBEN()

	Local lNovo := .F.

	If GetRPORelease() >= "12.1.027"
		lNovo := .T.
	Else
		lNovo := GetMvRH("MV_CALCBEN",,.F.)
	EndIf

Return lNovo

/*/{Protheus.doc} fRetBenAnt
Verifica o último mês de pagamento de beneficio para o funcionário
@author Leandro Drumond
@since 19/08/2017
@version P12.1.17
/*/
Function fRetBenAnt(cFilFunc, cMatFunc, cProcFunc, cTipoVale, aPerAux)

	Local aArea		:= GetArea()
	Local cAnoAux	:= ""
	Local cMesAux	:= ""
	Local dDtIni	:= Ctod("//")
	Local cAliasQuey	:= GetNextAlias()
	Local cTipo		:= If(cTipoVale == "2", "VA", If(cTipoVale == "1", "VR", ""))

	BeginSQL Alias cAliasQuey

		COLUMN RCH_DTINI AS DATE
		COLUMN RCH_DTFIM AS DATE

		SELECT RCH_PER, RCH_NUMPAG, RCH_MES, RCH_ANO, RCH_DTINI, RCH_DTFIM, RCH_DTFECH

		FROM %Table:RCH% RCH

		WHERE RCH.RCH_FILIAL = %Exp:xFilial("RCH", cFilFunc)%
		AND RCH.RCH_PROCES = %Exp:cProcFunc%
		AND RCH.RCH_ROTEIR = %Exp:fGetCalcRot(cTipoRot)%
		AND RCH.%notDel%

		ORDER BY RCH_DTINI DESC

	EndSQL

	// Último período fechado
	While ! (cAliasQuey)->(Eof())
		If ! Empty((cAliasQuey)->RCH_DTFECH)
			cAnoAux := (cAliasQuey)->RCH_ANO
			cMesAux := (cAliasQuey)->RCH_MES
			dDtIni	:= (cAliasQuey)->RCH_DTINI
			Exit
		EndIf
		(cAliasQuey)->(dbSkip())
	EndDo

	(cAliasQuey)->(dbCloseArea())

	BeginSQL Alias cAliasQuey

		SELECT LY_AGRUP

		FROM %Table:SLY% SLY

		WHERE SLY.LY_FILIAL = %Exp:xFilial("SLY", cFilFunc)%
		AND SLY.LY_TIPO = %Exp:cTipo%
		AND SLY.LY_DTINI <= %Exp:dTos(dDtIni)%
		AND SLY.%notDel%

	EndSQL

	// Só faz o recalculo se no perído havia calculo automático configurado
	If ! (cAliasQuey)->(Eof())
		fRetPerComp(cMesAux, cAnoAux, , cProcFunc, fGetCalcRot(cTipoRot), , , @aPerAux)
	EndIf

	(cAliasQuey)->(dbCloseArea())

	RestArea(aArea)

Return Nil

/*/{Protheus.doc} NroDias
Calcula o número de dias que deve ser pago para o benefício em determinada entidade
@author cicero.pereira
@since 30/09/2017
@param cEntidade, characters, Entidade do critério que está sendo calculada
@param cChave, characters, Código referente a entidade informada
@param dDataDe, date, Início do período
@return nDias, numerico
@param dDataAte, date, Fim do período
@sample
	NroDias("CTT", "000000001", cTod("01/09/2017"), cTod("30/09/2017"))
	Verifica quantos dias o funcionário ficou no Centro de custo 000000001, verificando transferências
	e retorna a quantidades de dias válidos para o pagamento do benefício
/*/
Static Function NroDias(cEntidade, cChave, dDataDe, dDataAte, cPeriod, lRepete)

	Local nDias		:= 0
	Local nI		:= 0
	Local nPosDe	:= 0
	Local nPosPara	:= 0
	Local nPosData	:= 7
	Local aTransf	:= {}
	Local dAuxPara	:= Ctod("//")

	Default cPeriod := ""
	Default lRepete := .F.

	If Empty(_aDias)
		fCarrAdias(dDataDe, dDataAte, cPeriod)
	EndIf

	If cEntidade == "CTT" // Centro de Custo
		fTransf(@aTransf, MesAno(dDataDe), , , .T., , , , , , , , SRA->RA_FILIAL, SRA->RA_MAT)
		nPosDe		:= 3
		nPosPara	:= 6
	ElseIf cEntidade == "SQB" // Departamento
		fTransf(@aTransf, MesAno(dDataDe), , , , , , , , .T., , , SRA->RA_FILIAL, SRA->RA_MAT)
		nPosDe		:= 16
		nPosPara	:= 17
	ElseIf cEntidade == "RCL" // Posto
		fTransf(@aTransf, MesAno(dDataDe), , , , , , , , , .T., , SRA->RA_FILIAL, SRA->RA_MAT)
		nPosDe		:= 18
		nPosPara	:= 19
	ElseIf cEntidade == "SM0" // Filial
		fTransf(@aTransf, MesAno(dDataDe), , .T., , , , , , , , , SRA->RA_FILIAL, SRA->RA_MAT)
		nPosDe		:= 2
		nPosPara	:= 5
		cChave += SRA->RA_MAT
	ElseIf cEntidade == "RCE" .or.  cEntidade == "SWY"// Sindicato
		aTransf		:= HistSRA("RCE")
		nPosData	:= 1
		nPosDe		:= 2
		nPosPara	:= 3
	ElseIf cEntidade == "SQ3" // Cargo
		aTransf		:= HistSRA("SQ3")
		nPosData	:= 1
		nPosDe		:= 2
		nPosPara	:= 3
	ElseIf cEntidade == "SR6" // Turno
		aTransf		:= HistSPF(dDataDe, dDataAte)
		nPosData	:= 1
		nPosDe		:= 2
		nPosPara	:= 3
	ElseIf cEntidade == "SRJ" // Função
		aTransf		:= HistSR7()
		nPosData	:= 1
		nPosDe		:= 2
		nPosPara	:= 3
	EndIf

	If ! Empty(aTransf)
		For nI := 1 To Len(aTransf)
			If ( cEntidade == "SWY" .and. aTransf[nI][nPosDe] $ cChave ) .or. ( cEntidade <> "SWY" .and. aTransf[nI][nPosDe] == cChave ) // Saindo
				If ! Empty(dAuxPara)
					nDias += VldDiasRH(dAuxPara, aTransf[nI][nPosData], lRepete)
					dAuxPara := Ctod("//")
				Else
					nDias += VldDiasRH(dDataDe, aTransf[nI][nPosData], lRepete)
				EndIf
			ElseIf ( cEntidade == "SWY" .and. aTransf[nI][nPosPara] $ cChave ) .or. ( cEntidade <> "SWY" .and. aTransf[nI][nPosPara] == cChave ) // Entrando
				dAuxPara := aTransf[nI][nPosData]
			EndIf
		Next
		If ! Empty(dAuxPara)
			nDias += VldDiasRH(dAuxPara, dDataAte + 1, lRepete)
		EndIf
	Else
		nDias += VldDiasRH(dDataDe, dDataAte + 1, lRepete)
	EndIf

Return nDias

/*/{Protheus.doc} HistSPF
Busca histórico de alterações do turno de trabalho
@author cicero.pereira
@since 02/10/2017
@param dInicio, date, Data inicial da pesquisa
@param dFim, date, Data final da pesquisa
/*/
Function HistSPF(dInicio, dFim)

	Local cAliasSPF := GetNextAlias()
	Local aAlt		:= {}

	BeginSQL Alias cAliasSPF
		Column  PF_DATA As Date
		SELECT PF_DATA, PF_TURNODE, PF_TURNOPA
		FROM %Table:SPF% SPF
		WHERE PF_FILIAL = %Exp:xFilial("SPF", SRA->RA_FILIAL)%
		AND SPF.PF_MAT = %Exp:SRA->RA_MAT%
		AND SPF.PF_DATA >= %Exp: dTos(dInicio)%
		AND SPF.PF_DATA <= %Exp: dTos(dFim)%
		AND SPF.%notDel%
	EndSQL

	While ! (cAliasSPF)->(Eof())
		Aadd(aAlt, {(cAliasSPF)->PF_DATA, Alltrim((cAliasSPF)->PF_TURNODE), Alltrim((cAliasSPF)->PF_TURNOPA)})
		(cAliasSPF)->(dbSkip())
	EndDo

	(cAliasSPF)->(dbCloseArea())

Return aAlt

/*/{Protheus.doc} VldDiasRH
Retorna quanto dias válidos para o pagamento do benefício, atualiza o _aDias
@author cicero.pereira
@since 30/09/2017
@param dInicio, date, Início do período
@param dFim, date, Fim do período
/*/
Static Function VldDiasRH(dInicio, dFim, lRepete)

	Local nDias	:= 0
	Local nI	:= 0
	Local lGS   := SuperGetMV("MV_TECXRH", NIL, .F. ) .AND. SuperGetMV("MV_GSBENAG", NIL, .F. ) .AND. FindFunction("TecBVldBnf")

	Default lRepete := .F.

	For nI := 1 To Len(_aDias)
		If _aDias[nI][1] >= dInicio .And. _aDias[nI][1] < dFim .And. (_aDias[nI][Len(_aDias[nI])] == 0 .Or. lRepete)
			If lGS
				IF TecBVldBnf(_aDias[nI],SRA->RA_FILIAL, SRA->RA_MAT)
					nDias++
					If cTipoRot != "I"
						_aDias[nI][Len(_aDias[nI])] := 1
					EndIf
				EndIf
			ElseIf _aDias[nI][4]
				nDias++
				If cTipoRot != "I"
					_aDias[nI][Len(_aDias[nI])] := 1
				EndIf
			EndIf
		EndIf
	Next

Return nDias

/*/{Protheus.doc} HistSRA
Busca o Histórico de alterações de um campo da SRA em determinado período
@author cicero.pereira
@since 29/09/2017
@param cEntidade, characters, Define qual campo será buscado. Ex.: Entidade RCE retorna o hitórico do campo RA_SINDICA
@param dInicio, date, Data para inicio da busca
@return aAlt, array
@example
	HistSRA("RCE", cTod("01/09/2017"))

	Retorna o array aAlt com as alterações do campo RA_SINDICA sendo:
	aAlt[nI][1] = Data da alteração
	aAlt[nI][1] = Conteúdo De
	aAlt[nI][1] = Conteúdo Para
/*/
Static Function HistSRA(cEntidade)

	Local cAliasSR9 := GetNextAlias()
	Local aAlt		:= {}
	Local cCampo	:= ""
	Local cCodAux	:= ""
	Local lFrist	:= .T.

	If cEntidade == "RCE"
		cCampo := "RA_SINDICA"
	ElseIf cEntidade == "SQ3"
		cCampo := "RA_CARGO"
	EndIf

	BeginSQL Alias cAliasSR9
		Column  R9_DATA As Date
		SELECT R9_DATA, R9_DESC
		FROM %Table:SR9% SR9
		WHERE SR9.R9_FILIAL = %Exp:SRA->RA_FILIAL%
		AND SR9.R9_MAT = %Exp:SRA->RA_MAT%
		AND SR9.R9_CAMPO = %Exp:cCampo%
		AND SR9.%notDel%
	EndSQL

	While ! (cAliasSR9)->(Eof())
		If lFrist
			cCodAux := Alltrim((cAliasSR9)->R9_DESC)
			lFrist := .F.
		Else
			Aadd(aAlt, {(cAliasSR9)->R9_DATA, cCodAux, Alltrim((cAliasSR9)->R9_DESC)})
			cCodAux := Alltrim((cAliasSR9)->R9_DESC)
		EndIf
		(cAliasSR9)->(dbSkip())
	EndDo
	(cAliasSR9)->(dbCloseArea())

Return aAlt

/*/{Protheus.doc} HistSR7
Busca o histórico das alterações de função do funcionário posicionado
@author cicero.pereira
@since 29/09/2017
@return aAlt, Array, Array contendo todas as alterações de função do funcionário
@sample
	HistSR7()

	Retorna aAlt sendo:
	aAlt[nI][1] = Data da alteração
	aAlt[nI][2] = Função De
	aAlt[nI][2] = Função Para
/*/
Static Function HistSR7()

	Local cAliasSR7 := GetNextAlias()
	Local aAlt		:= {}
	Local lFrist	:= .T.
	Local cFuncAux	:= ""

	BeginSQL Alias cAliasSR7
		Column  R7_DATA As Date
		SELECT R7_DATA, R7_FUNCAO
		FROM %Table:SR7% SR7
		WHERE SR7.R7_FILIAL = %Exp:SRA->RA_FILIAL%
		AND SR7.R7_MAT = %Exp:SRA->RA_MAT%
		AND SR7.%notDel%
	EndSQL

	While ! (cAliasSR7)->(Eof())
		If lFrist
			cFuncAux := Alltrim((cAliasSR7)->R7_FUNCAO)
			lFrist := .F.
		ElseIf cFuncAux != Alltrim((cAliasSR7)->R7_FUNCAO)
			Aadd(aAlt, {(cAliasSR7)->R7_DATA, cFuncAux, Alltrim((cAliasSR7)->R7_FUNCAO)})
			cFuncAux := Alltrim((cAliasSR7)->R7_FUNCAO)
		EndIf
		(cAliasSR7)->(dbSkip())
	EndDo
	(cAliasSR7)->(dbCloseArea())

Return aAlt

/*/{Protheus.doc} fCarrAdias
Carrega os dias do mês validando em quais dias devem ser pagos os benefícios
@author cicero.pereira
@since 30/09/2017
@param dInicio, date, Inicio do período
@param dFim, date, Fim do período
@param cPeriod, caracter, Código do período que será carregado
/*/
Static Function fCarrAdias(dInicio, dFim, cPeriod)

	Local nI, nJ		:= 0
	Local lPropAdm		:= .F. //APERGUNTE[1,3] == 1	// Se calcula proporcional a admissão
	Local lDesAfast		:= .F. //APERGUNTE[2,3] <> 2	// Se desconta férias/astamentos
	Local lDesFerProg	:= .F. //APERGUNTE[3,3] == 1	// Se calcula proporcional a férias programadas
	Local lDesFaltas	:= .F. //APERGUNTE[4,3] == 1	// Se desconta faltas
	Local cTipoAfas		:= ""
	Local aAfast		:= {}
	Local aPerAnt		:= {}
	//Local nAfaFer	:= If(cTipoRot == "I", 0, If(cTipoRot == '8', aPergunte[3,3], aPergunte[2,3]))
	Static _aDias		:= {}

	Default cPeriod := ""
	DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

	If cTipoRot == "8"
		lPropAdm	:= APERGUNTE[2,3] == 1	// Se calcula proporcional a admissão
		lDesAfast	:= APERGUNTE[3,3] <> 2	// Se desconta férias/astamentos
		lDesFerProg	:= APERGUNTE[4,3] == 1	// Se calcula proporcional a férias programadas
		lDesFaltas	:= APERGUNTE[5,3] == 1	// Se desconta faltas
	ElseIf cTipoRot $ "D*E"
		lPropAdm	:= APERGUNTE[1,3] == 1	// Se calcula proporcional a admissão
		lDesAfast	:= APERGUNTE[2,3] <> 2	// Se desconta férias/astamentos
		lDesFerProg	:= APERGUNTE[3,3] == 1	// Se calcula proporcional a férias programadas
		lDesFaltas	:= APERGUNTE[4,3] == 1	// Se desconta faltas
	EndIf

	If __lMemCalc
		fAddMemLog("Proporcional a férias : " + If(lDesFerProg,"Sim","Não") ,1,1)
		fAddMemLog("Proporcional a admissão : " + If(lPropAdm,"Sim","Não") ,1,1)
		fAddMemLog("Desconta faltas  : " + If(lDesFaltas,"Sim","Não") ,1,1)
		fAddMemLog("Desconta afastamentos  : " + If(lDesAfast,"Sim","Não") ,1,1)
	EndIf

	If !Empty(cPeriod) // Se estiver preenchido está recalculando o mês anterior
		fCarPeriodo( cPeriod , cRot, @aPerAnt, , , ! IsBlind(), )
		fCarDiasMes(@_aDias, lPropAdm, aPerAnt)
	Else
		fCarDiasMes(@_aDias, lPropAdm)
	EndIf

	If lDesAfast
		If cTipoRot == "8"
			If aPergunte[2,3] > 1
				cTipoAfas := If(aPergunte[2,3] == 3, '4','123')
			EndIf
		Else
			If aPergunte[2,3] > 1
				cTipoAfas := If(aPergunte[3,3] == 3, '4','123')
			EndIf
		EndIf

		fRetAfas(dInicio, dFim, , , ,cTipoAfas , @aAfast)
		For nI := 1 To Len(aAfast)
			For nJ := 1 To Len(_aDias)
				If _aDias[nJ][1] >= aAfast[nI][3] .And. (_aDias[nJ][1] <= aAfast[nI][4] .Or. Empty(aAfast[nI][4]))
					_aDias[nJ][4] := .F.
				EndIf
			Next
		Next
	EndIf

	If lDesFerProg
		fVlsFerPrg(dInicio, dFim, @_aDias, .T.)
	EndIf

	For nI := 1 To Len(_aDias)
		Aadd(_aDias[nI], 0)
	Next

Return

/*/{Protheus.doc} AtuSM7Aut
Grava Registro na SM7
@author cicero.pereira
@since 09/10/2017
@version 12.1.17
@param cTpVale, characters, Tipo do vale: 1 Vale Refeição; 2 Vale Alimentação
@param cCodBen, characters, Código do benefício
/*/
Static Function AtuSM7Aut(cTpVale, cCodBen)

	Local aArea	:= GetArea()

	dbSelectArea("SM7")

	RecLock("SM7", .T.)
		SM7->M7_FILIAL := xFilial("SM7", SRA->RA_FILIAL)
		SM7->M7_MAT := SRA->RA_MAT
		SM7->M7_TPCALC := "2"	// Cálculo automático
		SM7->M7_TPVALE := cTpVale
		SM7->M7_CODIGO := cCodBen
		SM7->M7_COMPL := "2"
	SM7->(MSUnlock())

	RestArea(aArea)

Return

/*/{Protheus.doc} fVlDemMs
Verifica demissao mes seguinte para pagamento de beneficios
@author Esther de Viveiro
@since 03/10/2017
@version P12.1.14
/*/
Function fVlDemMs()
	Local aArea		:= GetArea()
	Local lGpem040 	:= FunName() == "GPEM040" .or. FunName() == "GPEM040B"

	If !lGpem040 //Se esta sendo calculado pela rescisão, a data de demissão já esta preenchida, mas a SRG ainda não foi gravada.
		dDataDem	:= StoD("//")

		//verifica se ha calculo de rescisao para o periodo de processamento do beneficio
		SRG->( DbSetOrder(1) )	// Ordem 1 - RetOrdem( "SRG", "RG_FILIAL+RG_MAT+DTOS(RG_DTGERAR)")
		If SRG->(DbSeek( SRA->RA_FILIAL + SRA->RA_MAT))
			While SRG->(!Eof()) .and. SRG->(RG_FILIAL+RG_MAT) == SRA->(RA_FILIAL + RA_MAT)
				If SRG->RG_EFETIVA == 'S' .AND. AnoMes(SRG->RG_DATADEM) <= cPeriodo
					dDataDem := (SRG->RG_DATADEM)
				EndIf
				SRG->(dbSkip())
			EndDo
		EndIf

		RestArea(aArea)
	EndIf
Return Nil

/*/{Protheus.doc} RestXCBEN
Reinicia variáveis Static do fonte GPEXCBEN
@author cicero.pereira
@since 14/11/2017
/*/
Function RestXCBEN()

	nFaltasAut	:= 0
	nDiasRef	:= 0
	aCriterio 	:= {}
	lUsaCPer	:= GetMvRH("MV_USACPER",, .F.) //.T.=Usa periodo folha/.F.= usa calendario ponto
	cTipoCri	:= ""

Return

/*/{Protheus.doc} RestXCBEN
Reinicia cNroPed
@author Allyson Mesashi
@since 30/07/2021
/*/
Function RstNroPed()

cNroPed := ""

Return

/*/{Protheus.doc} fLoadCCT
Carrega sindicatos associados a CCT
@author Leandro Drumond
@since 23/05/2022
/*/
Static Function fLoadCCT(cCodCCT, cFilSRA)
Local aRet  		:= {"##"}
Local cAliasQry 	:= GetNextAlias()
Local cFilRCE       := xFilial("RCE", cFilSRA)

BeginSql alias cAliasQry
	SELECT RCE_CODIGO
	FROM %table:RCE% RCE
	WHERE RCE_CCT = %exp:cCodCCT% AND
	RCE_FILIAL = %exp:cFilRCE% AND
	RCE.%notDel%
EndSql

If !(cAliasQry)->( EOF() )
	aRet := {}
	While !(cAliasQry)->( EOF() )
		aAdd(aRet, (cAliasQry)->RCE_CODIGO)
		(cAliasQry)->( DbSkip() )
	EndDo
EndIf

(cAliasQry)->(DbCloseArea())

Return aRet

/*/{Protheus.doc} fBuscaCCT
Busca o código da CCT associado ao sindicato
@author Leandro Drumond
@since 02/06/2022
/*/
Static Function fBuscaCCT(cSindicato)
Local aArea		:= GetArea()
Local cRet		:= ""

DbSelectArea("RCE")
RCE->(DbSetOrder(1))

If RCE->(DbSeek(xFilial("RCE") + cSindicato))
	cRet := RCE->RCE_CCT
EndIf

RestArea(aArea)

Return cRet

/*{Protheus.doc} GetDiasTab
Carrega os dias de beneficio de acordo com a tabela de horário padrão
@author Leandro Drumond
@since 23/08/2022
*/
Static Function GetDiasTab(aTabCalend,aDiaVales,lPropFerias,lFeriado,lVT,nDUtil,nDiaNUtil,nDiasSeg,nDiasTer,nDiasQua,nDiasQui,nDiasSex,nDiasSab,nDiasDom,nDias,nDiaNTran)
Local dDtAux	:= CtoD("")
Local nX 		:= 0
Local nDiaSem 	:= 0
Local nPos 		:= 0
Local lSoma 	:= .F.
Local cDiaSem	:= ""

For nX := 1 to Len(aTabcalend)
	lSoma	:= .F.
	cDiaSem := Alltrim( Upper(cDow( aTabCalend[nX][1] ) ))

	Do Case
		Case cDiaSem == "MONDAY"
			nDiaSem := 1
		Case cDiaSem == "TUESDAY"
			nDiaSem := 2
		Case cDiaSem == "WEDNESDAY"
			nDiaSem := 3
		Case cDiaSem == "THURSDAY"
			nDiaSem := 4
		Case cDiaSem == "FRIDAY"
			nDiaSem := 5
		Case cDiaSem == "SATURDAY"
			nDiaSem := 6
		Otherwise
			nDiaSem := 7
	EndCase

	If aDiaVales[nDiaSem] > 0
		If aTabCalend[nX][6] == "S" .and. nDUtil > 0
			nDias++
		ElseIf aTabCalend[nX][6] <> "S" .and. nDiaNUtil > 0
			nDiaNTran++
		EndIf
	EndIf

	dDtAux := aTabCalend[nX][1]

	If lVT .or. ( aDiasMes[Ascan( aDiasMes, { |y| y[1] == dDtAux })][4] .or.(  aTabCalend[nX][19] == .F. .And. nDiaNUtil > 0 .And. aDiaVales[nDiaSem] > 0 ) )
		If lPropFerias			
			nPos := aScan(aDiasMes,{|y| y[1] == dDtAux})
			If !lVT .or. ( nPos == 0 .or. aDiasMes[nPos,5] <> 'PRG' ) //Se for vale transporte ou o dia estiver configurado para pagamento de beneficio
				If (Empty(dDataDem) .OR. aTabCalend[nX][1] < dDataDem)
					If ( aTabCalend[nX][6] == "S" .And. !aTabCalend[nX][19] ) ; //Se tipo de dia é trabalhado e não é feriado
						.or. ;
					   ( !aTabCalend[nX][19] .And. nDiaNUtil > 0 .And. aDiaVales[nDiaSem] > 0) ; //Se dia não for trabalhado, não for feriado, pagar dias não úteis e pagar vale no dia especifico da semana
						.or. ;
						( lFeriado .and. ( aTabCalend[nX][6] == "F" .And. !aTabCalend[nX][24] .And. aTabCalend[nX][36] == "S") ) ; //Se for feriado, pagar feriado  e funcionário não estiver afastado
						.or. ;
						( lFeriado .and.  ( aTabCalend[nX][6] == "S" .And. !aTabCalend[nX][24] .And. aTabCalend[nX][36] == "S" .And. aTabCalend[nX][19]) )
							lSoma := .T.
					EndIf 
				EndIf 
			EndIf
		Else
			If (Empty(dDataDem) .OR. aTabCalend[nX][1] < dDataDem)
				If ( aTabCalend[nX][6] == "S" .And. !aTabCalend[nX][19] ) ;
					.or. ;
				( !aTabCalend[nX][19] .And. nDiaNUtil > 0 .And. aDiaVales[nDiaSem] > 0) ;
					.or. ;
				( lFeriado .and. (aTabCalend[nX][6] == "F" .And. !aTabCalend[nX][24] .And. aTabCalend[nX][36] == "S" ) ) ;
					.or. ;
				( lFeriado .and. (aTabCalend[nX][6] == "S" .And. !aTabCalend[nX][24] .And. aTabCalend[nX][36] == "S" .And. aTabCalend[nX][19]) ) ;
					.or. ;
				( aTabCalend[nX][6] == "N" .And. !aTabCalend[nX][19] .And. aTabCalend[nX][24] .And. aTabCalend[nX][36] == "S" ) 
					lSoma := .T.
				EndIf 
			EndIf 
		EndIf

		If lSoma
			Do Case
				Case cDiaSem == "MONDAY"
					nDiasSeg++
				Case cDiaSem == "TUESDAY"
					nDiasTer++
				Case cDiaSem == "WEDNESDAY"
					nDiasQua++
				Case cDiaSem == "THURSDAY"
					nDiasQui++
				Case cDiaSem == "FRIDAY"
					nDiasSex++
				Case cDiaSem == "SATURDAY"
					nDiasSab++
				Otherwise
					nDiasDom++
			EndCase	
		EndIf
	EndIf
Next nX

If __lMemCalc
	fAddMemLog("Qtd dias de Segunda : " +  cValtoChar(nDiasSeg) ,1,1)
	fAddMemLog("Qtd dias de Terça   : " +  cValtoChar(nDiasTer) ,1,1)
	fAddMemLog("Qtd dias de Quarta  : " +  cValtoChar(nDiasQua) ,1,1)
	fAddMemLog("Qtd dias de Quinta  : " +  cValtoChar(nDiasQui) ,1,1)
	fAddMemLog("Qtd dias de Sexta   : " +  cValtoChar(nDiasSex) ,1,1)
	fAddMemLog("Qtd dias de Sabado  : " +  cValtoChar(nDiasSab) ,1,1)
	fAddMemLog("Qtd dias de Domingo : " +  cValtoChar(nDiasDom) ,1,1)
EndIf

Return Nil
