#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "GPEM040A.CH"
#INCLUDE "vkey.ch"

Static aFerPag		:= {}
Static _aCodFol		:= {}
Static aPd_SRK		:= {}
Static aStructSRG
Static aSPBRec
Static aPdRAW
Static cRfyTpAv
Static cTpAvBkp
Static cOpcCompl	:= "1"
Static cIdHistMed 	:= ""
Static _BkpFilial	:= ""
Static lTemRFY
Static lDtDemRFY
Static lAvMsg
Static lGestPubl
Static lIntTaf
Static lMiddleware
Static __lMemCalc
Static lCancelCalc	:= .T.
Static lAtuBrowse	:= .F.
Static lVlEsocDif	:= .F.
Static lCtrlTit
Static lConsig
Static lCpoFlagIC
Static lVerMultv
Static lTemSeqMV
Static lMvRHNG

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ GPEM040  ³ Autor ³ Leandro Drumond                ³ Data ³ 11/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Calculo de Rescisao                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GPEM040()                                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Esecifico                                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³            ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data     ³ FNC         ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Raquel Hager³17/07/2014³TPZUCK       ³Inclusao de replicas versao 11  com itens ³±±
±±³            ³          ³             ³do eSocial.					           ³±±
±±³Christiane V³24/07/2014³TQCNUA       ³Correção de erros no cálculo da rescisão. ³±±
±±³Emerson Camp³19/08/2014³TQGBQ6       ³Inclusao da funcao fVldAccess na funcao   ³±±
±±³            ³          ³             ³CalResc para validar de per. bloqueado.   ³±±
±±³Gustavo M.  ³24/09/2014³TQQNS7       ³Ajuste na verificacao do tipo de aviso.   ³±±
±±³Allyson M.  ³27/01/2015³TRGSDH       ³Ajuste p/ calculo quando ha rateio p/     ³±±
±±³            ³          ³             ³respeitar o item/classe cadastrado.   	   ³±±
±±³Flavio Corr ³19/03/15  ³PCREQ-4163   ³Integração Mensagem Unica                 ³±±
±±³Renan Borges³22/06/2015³TSQYRQ       ³Ajuste p/ não gerar error.log ao preencher³±±
±±³            ³          ³             ³o tipo de rescisão.                 	   ³±±
±±³L.Ttrombini ³16/07/2015³TSSFG7       ³Ajuste p/ Não calcular os dias de Aviso   ³±±
±±³            ³          ³             ³Previo quando tipo de Rescisão estiver com³±±
±±³            ³          ³             ³Aviso Previo = "N" 					   ³±±
±±³Christiane V³29/07/2015³PCDEF-52364  ³Inclusão de validações para o eSocial     ³±±
±±³Mariana M.  ³08/09/2015³TSYCQ6       ³Ajuste na função GP40DiasAv (calculo de   ³±±
±±³            ³          ³             ³data e Aviso Previo)p/ quando não utilizar³±±
±±³            ³          ³             ³o cadastro de aviso prévio, o sistema cal-³±±
±±³            ³          ³             ³cule a data de aviso prévio corretamente  ³±±
±±³            ³          ³             ³(30 dias antes da demissao)			   ³±±
±±³Flavio Corr.³22/09/2015³TTKNAO       ³Integração com ponto                      ³±±
±±³            ³          ³	            ³				                           ³±±
±±³Matheus M.  ³23/09/2015³TTJLK4       ³Ajuste para trazer o tipo de rescisão     ³±±
±±³            ³          ³	            ³quando a solicitacao é efetuada pelo	   ³±±
±±³            ³          ³	            ³portal.		                           ³±±
±±³Renan Borges³19/10/2015³TTOW08       ³Ajuste para que ao preencher a data de de-³±±
±±³            ³          ³             ³missão de um autonomo, quando seu processo³±±
±±³            ³          ³             ³ não possui periodo de rescisão, não seja ³±±
±±³            ³          ³             ³gerado error.log.                         ³±±
±±³Mariana M.  ³05/11/2015³TTRRQX       ³Ajuste na função GP40VldTpRes e fSRGWhen  ³±±
±±³            ³          ³             ³para que o sistema possa deixar o campo de³±±
±±³            ³          ³             ³Data de Aviso Previo habilitado e carregar³±±
±±³            ³          ³             ³data quando o aviso for Indenizado	       ³±±
±±³Cecilia Carv³02/12/2015³PCDEF-86584  ³Ajuste para nao deixar gravar a rescisao  ³±±
±±³            ³          ³             ³sem ter efetuado o calculo antes.         ³±±
±±³Cecilia Carv³03/12/2015³PCDEF-86584  ³Inclusao de linhas que foram retiradas in-³±±
±±³            ³          ³             ³devidamente.                              ³±±
±±³M. Silveira ³10/12/2015³TTXUZU       ³Ajuste na mensagem de exibida ao calcular ³±±
±±³            ³          ³             ³estagiario sem recesso cadastrado.        ³±±
±±³Cícero Alves³28/12/2015³TUBXVA       ³Correção nas chamadas da função fGetCodFol³±±
±±³            ³          ³             ³      									   ³±±
±±³Cícero Alves³28/12/2015³TUBURI       ³Ajuste p/ deducao das faltas lancadas na  ³±±
±±³            ³          ³             ³tabela RGB		                           ³±±
±±³Cícero Alves³06/01/2016³PCREQ-9091  	³Ajuste para criar opcao de bloqueio para  ³±±
±±³            ³          ³             ³readmissão.                               ³±±
±±³Raquel Hager³07/01/2016³TTTON9    	³Valida bloqueio de periodos para exclusao.³±±
±±³Raquel Hager³08/01/2016³TTTON9    	³Inclusao da validao no if de EXCLUSAO.	   ³±±
±±³Allyson M.  ³12/01/2015³TUEKJH       ³Ajuste p/ desabilitar a edicao dos campos ³±±
±±³            ³          ³             ³de salario do cabecalho da rescisao       ³±±
±±³            ³          ³             ³Ajuste p/ validar preenchimento da data de³±±
±±³            ³          ³             ³homologacao antes do calculo              ³±±
±±³Raquel Hager³12/01/2016³TTTON9    	³Inclusao var. aPerAtual na func.FTUDOOKM40³±±
±±³Renan Borges³13/01/2016³TUAGO9       ³Ajuste para utilizar a rotina GPEM040 como³±±
±±³            ³          ³             ³adapter do tipo MVC pelo Mile corretamente³±±
±±³Allyson M.  ³19/01/2016³TUGCTV       ³Ajuste p/ deducao das faltas lancadas na  ³±±
±±³            ³          ³             ³tabela RGB	quando possui data preenchida  ³±±
±±³Allyson M.  ³26/01/2016³TUEQZ2    	³Ajuste para guardar o valor do salario    ³±±
±±³			   ³          ³          	³incorporado para o relatorio de medias    ³±±
±±³Allyson M.  ³04/02/2016³TUJCCK    	³Ajuste p/ sempre desfazer a delecao das   ³±±
±±³			   ³          ³          	³linhas do calculo antes de atualizar a    ³±±
±±³			   ³          ³          	³grid com o novo calculo p/ evitar situacao³±±
±±³			   ³          ³          	³em que verba que deveria ser gravada era  ³±±
±±³			   ³          ³          	³exibida como deletada.					   ³±±
±±³Allyson M.  ³05/02/2016³TUBP63    	³Ajuste p/ nao carregar o campo RG_SABDOM  ³±±
±±³			   ³          ³          	³desabilitado quando tem cadastro do aviso ³±±
±±³			   ³          ³          	³previo									   ³±±
±±³Allyson M.  ³05/02/2016³TUJENA    	³Ajuste p/ validar o cadastro do periodo   ³±±
±±³			   ³          ³          	³corretamente antes de iniciar o calculo   ³±±
±±³Claudinei S.³18/02/2016³TUCD45       ³Incluido novo controle para o Aviso Previo³±±
±±³            ³          ³             ³Trabalhado e Indenizado.                  ³±±
±±ºRenan Borges³26/02/2016³TUNQG2       ³Ajuste para no calculo da rescisão comple-º±±
±±º            ³          ³             ³mentar seja possível informar o código de º±±
±±º            ³          ³             ³RRA e para não gerar os valores de RRA ca-º±±
±±º            ³          ³             ³so não seja informado o código.           º±±
±±ºRenan Borges³26/02/2016³TUOPJD       ³Ajuste para no calculo da rescisão comple-º±±
±±º            ³          ³             ³mentar seja possível informar o código de º±±
±±º            ³          ³             ³RRA e para não gerar os valores de RRA ca-º±±
±±º            ³          ³             ³so não seja informado o código.           º±±
±±³Claudinei S.³29/02/2016³TUCD45       ³Incluido tratamento para gravacao do novo ³±±
±±³            ³          ³             ³campo RG_DTPROAV.                         ³±±
±±³Claudinei S.³03/03/2016³TUCD45       ³Incluido tratamento para gravacao do tipo ³±±
±±³            ³          ³             ³de rescisao quando possui cad.aviso previo³±±
±±³Claudinei S.³07/03/2016³TUCD45       ³Ajuste para nao projetar a data quando o  ³±±
±±³            ³          ³             ³tipo do aviso for N ou D, e para que ao   ³±±
±±³            ³          ³             ³excluir o aviso do Cad.Aviso Prévio,o tipo³±±
±±³            ³          ³             ³do aviso nao apareca na rescisao          ³±±
±±³Claudinei S.³16/03/2016³TURBCB       ³Ajuste considerar o campo do sindicato    ³±±
±±³            ³          ³             ³RCE_PRJAVT somente se aviso for trabalhado³±±
±±ºClaudinei S.³18/03/2016³TUSEC0       ³Ajustada a rotina para não permitir o     ³±±
±±º            ³          ³             ³cálculo da rescisão sem o preenchimento da³±±
±±º            ³          ³             ³data do aviso prévio.                     ³±±
±±ºClaudinei S.³21/03/2016³TUUEUC       ³fInitModel,carregar a descricao correta do³±±
±±º            ³          ³             ³tipo do aviso em rescisões já calculadas  ³±±
±±º            ³          ³             ³após ter sido incluída uma nova rescisão. ³±±
±±ºGustavo M.  ³04/04/2016³TUSJMS       ³Ajuste para validar se o periodo está ati ³±±
±±º            ³          ³             ³vo.									   ³±±
±±ºRenan Borges³05/04/2016³TUP601       ³Ajuste para abater o valor de % de salário³±±
±±º            ³          ³             ³educação corretamente do valor de tercei- ³±±
±±º            ³          ³             ³ros. Ajuste para validar o cadastro de ti-³±±
±±º            ³          ³             ³po de aviso previo corretamente de acordo ³±±
±±º            ³          ³             ³com os periodos ativos. Ajuste para utili-³±±
±±º            ³          ³             ³zar o mnemonico P_CHKDTHOM  ao realizar o ³±±
±±º            ³          ³             ³calculo de rescisão.                      ³±±
±±ºRaquel Hager³06/04/2016³TUUOE5       ³Ajuste para permissao de edicao do campo  ³±±
±±º            ³          ³             ³de Data de Aviso quando Complementar.     ³±±
±±³Renan Borges³12/04/2016³TURTIA       ³Ajuste para mostrar codigo de classe valor³±±
±±³            ³          ³             ³corretamente quando MV_ITMCLVL igual a 3 e³±±
±±³            ³          ³             ³não possuir o Item no registro de "Progra-³±±
±±³            ³          ³             ³mação de Rateio".                         ³±±
±±³Eduardo F.  ³09/05/2016³TUXUTK       ³Validação da quantidade maxima de lançamen³±±
±±³            ³          ³             ³tos por verbas, onde no final do procedi- ³±±
±±³            ³          ³             ³mento caso alguma verba esteja incorreta  ³±±
±±³            ³          ³             ³com o a listagem do calculo o usuário é   ³±±
±±³            ³          ³             ³informado de quais verbas estão incorretas³±±
±±ºRaquel Hager³30/05/2016³TVFXON       ³Ajuste para usar LoadValue quando comple- ³±±
±±º            ³          ³             ³mentar pois o campo já estará gravado na  ³±±
±±º            ³          ³             ³tabela./Ajuste para carregar variavel     ³±±
±±º            ³          ³             ³nDferave quando complementar para geração ³±±
±±º            ³          ³             ³da ref de Médias de Férias Proporcionais./³±±
±±º            ³          ³             ³Ajuste para não recalcular Dias de Férias ³±±
±±º            ³          ³             ³Proporcionais/Aviso/Vencidas quando comple³±±
±±º            ³          ³             ³mentar.							       ³±±
±±ºAllyson M.  ³13/06/2016³TVBL05       ³Ajuste na verificacao das ferias sobre    ³±±
±±º            ³          ³             ³aviso quando possuir aviso misto.		   ³±±
±±º            ³          ³TVJSRJ       ³Ajuste quando carregar os lançamentos das ³±±
±±º            ³          ³             ³rescisoes anteriores p/ nao verificar data³±±
±±º            ³          ³TVH709       ³Ajuste para gravar na SRR o mesmo período ³±±
±±³            ³          ³             ³da SRG, ou seja, o período que está sendo ³±±
±±³            ³          ³             ³calculada a rescisão complementar.        ³±±
±±³Gabriel A.  ³14/06/2016³TVFIKA       ³Ajuste para não exibir a mensagem de      ³±±
±±³            ³          ³             ³salário mínimo indevidamente.             ³±±
±±ºAllyson M.  ³14/06/2016³TVJDFD       ³Ajuste na importação dos resultados do    ³±±
±±º            ³          ³             ³ponto p/ não validar a data informada com ³±±
±±º            ³          ³             ³o período do ponto pois os dados da SPB só³±±
±±º            ³          ³             ³irão conter os dados do período em aberto ³±±
±±º            ³          ³             ³e troca do help() por msgalert() pois não ³±±
±±º            ³          ³             ³exibia a mensagem corretamente			   ³±±
±±³Gabriel A.  ³23/06/2016³TUXPCK       ³Ajuste na validação do campo RA_DEMISSA   ³±±
±±³            ³          ³             ³quando for importação via MILE.           ³±±
±±³Gabriel A.  ³24/06/2016³TVJSOG       ³Ajuste para guardar o valor do salario    ³±±
±±³            ³          ³             ³incorporado para o relatorio de medias    ³±±
±±ºAllyson M.  ³18/07/2016³TVNTNE       ³Ajuste p/ efetuar validação do campo de   ³±±
±±º            ³          ³             ³data de demissão somente quando alterar o ³±±
±±º            ³          ³             ³campo de data de demissão (antes validava ³±±
±±º            ³          ³             ³quando alterava a data de aviso) e quando ³±±
±±º            ³          ³             ³executar o cálculo de rescisão. 		   ³±±
±±ºAllyson M.  ³27/07/2016³TVKWJ7       ³Ajuste p/ carregar os campos de usuario   ³±±
±±º            ³          ³             ³de forma editável no fSRGWhen() 		   ³±±
±±ºVictor A.   ³28/07/2016³TVKHL4       ³Ajuste p/ nao consultar roteiro rescisão  ³±±
±±º            ³          ³             ³caso o funcionário não possua vinculos    ³±±
±±º            ³          ³             ³empregatícios em fChkDtDem().             ³±±
±±ºAllyson M.  ³04/08/2016³TVGXM3       ³Ajuste p/ validar tipo de roteiro somente ³±±
±±º            ³          ³             ³após a validação das datas 		   	   ³±±
±±ºCícero Alves³14/09/2016³TVQMN6       ³Ajuste na função fChkDtDem para verificar ³±±
±±º            ³          ³             ³se o GPE está sendo utilizado			   ³±±
±±ºAllyson M.  ³19/09/2016³TVVTPR       ³Ajuste p/ garantir a reinicialização das  ³±±
±±º            ³          ³             ³variáveis de aviso prévio 		   	   	   ³±±
±±ºAllyson M.  ³22/09/2016³TVY808       ³Ajuste na verificação do controle de dias ³±±
±±º            ³          ³             ³de direito		   	   	   				   ³±±
±±ºAllyson M.  ³18/10/2016³TVUZFF       ³Ajuste p/ não considerar o salário família³±±
±±º            ³          ³             ³p/ o desconto do empréstimo consignado.   ³±±
±±ºMatheus M.  ³18/10/2016³TWAAH8       ³Ajuste na carga do código da rescisão     ³±±
±±º            ³          ³             ³quando vier do Portal GCH.				   ³±±
±±ºAllyson M.  ³26/10/2016³TWHDNC       ³-Ajuste p/ reinicializar variáveis static ³±±
±±º            ³          ³             ³do GPEXCIMP/GPEXCINI ao iniciar o calculo ³±±
±±º            ³          ³             ³-Ajuste p/ permitir excluir rescisão simu-³±±
±±º            ³          ³             ³lada de períodos anteriores			   ³±±
±±º            ³          ³             ³-Ajuste p/ preparar rotina p/ teste auto- ³±±
±±º            ³          ³             ³matizado do robô de complementar 		   ³±±
±±ºRaquel Hager³10/10/2016³TWKEU2       ³Realizados ajustes para execução de robô  ³±±
±±º            ³          ³             ³de testes para cálculo de rescisão compl. ³±±
±±º            ³          ³             ³com período aberto.					   ³±±
±±³M.Camargo   ³25/10/2016³MRH-1134     ³ Se modifica fVAC_RESM2 por loc Chile     ³±±
±±ºCícero Alves³11/11/2016³TWEP47       ³Ajuste na validação dos campos para buscar³±±
±±º            ³          ³             ³a informação do modelo criado na rotina   ³±±
±±º            ³          ³             ³gpem042								   ³±±
±±ºRaquel Hager³29/12/2016³MRH-3935     ³Ajuste em fChkDtDem para buscar Afastamen-³±±
±±º            ³          ³             ³to em períodos futuros(1 ano para frente) ³±±
±±³Gabriel A.  ³10/01/2017³MRH-4551     ³Ajuste no cálculo de férias proporcionais ³±±
±±³            ³          ³             ³quando a data do aviso é trocada.         ³±±
±±ºAllyson M.  ³06/02/2017³MRH-5565     ³Ajuste no cálculo de complementar p/ não  ³±±
±±º            ³          ³             ³permitir o cálculo de complementar por    ³±±
±±º            ³          ³             ³dissídio se selecionado o 'Recálculo'	   ³±±
±±³Oswaldo L.  ³01/02/17  ³MRH-5770     ³Tratativa para que o sistema apenas utilize ³±±
±±³            ³          ³             ³os campos de acordo com o pais conectado  ³±±
±±³Gabriel A.  ³07/03/2017³MRH-7844     ³Ajuste no cálculo de rescisão quando há   ³±±
±±³            ³          ³             ³empréstimo consignado.                    ³±±
±±³Gabriel A.  ³05/04/2017³DRHPAG-42    ³Ajuste para zerar o mnemônico nFalAtuD em ³±±
±±³            ³          ³             ³todos os cálculos.                        ³±±
±±³Eduardo K.  ³20/04/2017³MPRIMESP-9798³Ajuste p/ não carregar verba de PLR no    ³±±
±±³            ³          ³             ³calculo da rescisão.                      ³±±
±±³Claudinei S.|09/05/2017|MRH-1646     |Implementado o cálculo para funcionários  ³±±
±±³            |          |             |com regime parcial.                       ³±±
±±³Marcos Cout.|26/05/2017|DRHESOCP-282 |Realizar a geração do evento S-2299       ³±±
±±³            |          |             |Desligamento. Foi realizado o merge 12.16 ³±±
±±³Marcos Cout.|01/06/2017|DRHESOCP-320 |Realizar a geração do evento S-2299       ³±±
±±³            |          |             |Desligamento Coletivo. Realizar ajustes   ³±±
±±³            |          |             |necessários para melhor funcionamento.    ³±±
±±³Marcos Cout.³02/06/2017³DRHESOCP-331 ³Ajustes para geração de LOG. Evento       ³±±
±±³            ³          ³             ³S-2299 - Desligamento Coletivo            ³±±
±±³Cecilia Car.|24/05/2017|DRHPAG-1474  |Ajuste para permitir lançar verba de PLR  ³±±
±±³            |          |             |no cálculo da rescisão.                   ³±±
±±³Cícero Alves|02/06/2017|DRHPAG-2125  |Inclusão do PE VLDTPRESP				   ³±±
±±³Marcos Cout.³14/06/2017³DRHESOCP-419 ³Ajustes para exibição de alerta (help) e  ³±±
±±³            ³          ³             ³chamada da função persistência do STATUS  ³±±
±±³Marcos Cout.³16/06/2017³DRHESOCP-437 ³Adicionada variavel aErros responsavel por³±±
±±³            ³          ³             ³armazenar o erros do XML na funcao. S2299 ³±±
±±³Marcos Cout.³24/08/2017³DRHESOCP-868 ³Ponteirando o registro para a sua filial  ³±±
±±³            ³          ³             ³correta. O registro não estava sendo encon³±±
±±³            ³          ³             ³_trado na base do TAF                     ³±±
±±³Cecília C.  ³21/08/2017³DRHESOCP-736 ³Implementação do campo RG_INDAV e geração ³±±
±±³            ³          ³             ³no XML S-2299.                            ³±±
±±³L. Samaniego|04/09/2017|DMICNS-163   |Se realiza declaracion de Variables para  ³±±
±±³            |          |             |el pais Argentina cuando ejecuta GPEM042  ³±±
±±Flavio C.    |12/09/2017|DRHPAG-4711  |Compatibilizado fonte com versoes .14 .16 ³±±
±±³            |          |             | e .17 								   ³±±
±±³Isabel N.   |15/09/2017|DRHPAG-4561  |Inicializa variáveis p/ ModFol modelo 2.  ³±±
±±ºRenan Borges³19/09/2017³DRHESOCP-1045³Ajuste para ao tentar fazer um desligamen-³±±
±±º            ³          ³             ³to S-2299 o sistema não retornar o erro de³±±
±±º            ³          ³             ³ Help FWMODELPOS.                         ³±±
±±ºCecília C.  ³05/10/2017³DRHESOCP-1324³Ajuste na geração dos valores do plano de ³±±
±±º            ³          ³             ³saúde do dependente para o evento S-2299. ³±±
±±ºEduardo K.  ³16/10/2017³MPRIMESP11285³Ajuste para ordenar verbas no grid pelo   ³±±
±±º            ³          ³             ³código das mesmas.						   ³±±
±±ºJoão Balbino³17/10/2017³MPRIMESP11750³Ajuste para posicionar corretamente a SRF ³±±
±±º            ³          ³             ³caso haja mais de um periodo aberto.      ³±±
±±ºJaqueline L.³22/12/2017³DRHPAG-10265 ³Declarando o Array aLogErros na função    ³±±
±±º            ³          ³             ³FCHKINTEG para evitar erroLog.            ³±±
±±ºCecília Carv³08/01/2018³DRHESOCP-2682³Ajuste para geração de contrato intermiten³±±
±±º            ³          ³             ³te - evento S-2200.                       ³±±
±±ºJaqueline L.³13/03/2018³DRHGCH-62    ³Retirado a chamada da tela de Filial      ³±±
±±³Marcos Cout.³15/03/2018³DRHESOCP-3473³Realizar criação do botão de "Integração  ³±±
±±³            ³          ³             ³com o TAF".                               ³±±
±±³Eduardo Vic.³22/03/2018³DRHESOCP-3704³Tratamento quando rescisão complementar   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GPEM040(nOpcAuto,lRotAuto)

Local aArea         := GetArea()
Local aCoors  		:= FWGetDialogSize( oMainWnd )
Local cIdBrowse
Local cIdGrid
Local oPanelUp
Local oTela
Local oPanelDown
Local oRelacSRG
Local cFiltraRH		:= ""
Local cVerEnv		:= ""
Local cVerGPE		:= ""

Private oDlgPrinc

Private oBrowseUp
Private oBrowseDwn
Private cResComp
Private aLogErros	:= {}				// Array com os logs de erros de processamento
Private lRescRRA	:= .F.
Private lAtuSimul	:= .F.
Private lSabDom		:= GetMvRH("MV_SABDOM") == "S" //Se pagara o sab e domingo qdo demissao na sexta
Private lModDataDem := GetMvRH("MV_MDDTDEM",NIL,"N") == "S"
Private lProjav		:= .F. //Projeção do aviso prévio por tipo de rescisão
Private lProj		:= .T. //Projeção do aviso prévio por sindicato
Private lColetiva	:= .F.
Private lTCFA040	:= IsInCallStack("TCFA040")
Private aSrgRecnos	:= {}
Private nRegSrg		:= 0
Private cAtualSit   := GetMvRH( "MV_SITRES", .F., "2" )
Private cModFol 	:= GetMvRH( "MV_MODFOL", .F., "1" )
Private cFilOld		:= ""
Private dDataAvi	:= CtoD ("//")
Private nSalaMed	:= 0
Private nSMesMed	:= 0
Private nSDiaMed	:= 0
Private nSHorMed	:= 0
Private lIndAv		:= Iif(cPaisLoc == 'BRA' .And. SRG->(ColumnPos( "RG_INDAV")) > 0, .T., .F.)
Private lContrInt	:= If(SRC->(ColumnPos( 'RC_CONVOC' )) > 0,.T.,.F.)

Private aPublicacao := Array(5) // [1]-Data da Rescisão / [2]-Nr.Documento / [3]-Data Publicacao / [4]-Chave RI6 / [5]-Índice da RI6

DEFAULT __lMemCalc  := cPaisLoc == "BRA" .And. FindFunction("fMemCalc") .And. fMemCalc() //Memória de Cálculo
DEFAULT lRotAuto    := .F.
DEFAULT lIntTaf 	:= ((SuperGetMv("MV_RHTAF",, .F.) == .T.) .AND. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 1 )
DEFAULT lMiddleware	:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )

lAvMsg				:= .F.
lAtuBrowse			:= .T. //Se for robo não passara por aqui

If lMiddleware .And. !ChkFile("RJE")
	Help( " ", 1, OemToAnsi(STR0020),, OemToAnsi(STR0248), 1, 0 )//"Tabela RJE não encontrada. Execute o UPDDISTR - atualizador de dicionário e base de dados."
	Return
EndIf

//Verifica se os leiaute do eSocial GPE vs TAF estão divergentes.
If lIntTaf .And. FindFunction("fVersEsoc") .And. FindFunction("ESocMsgVer")
	fVersEsoc( "S2299", .F.,,, @cVerEnv, @cVerGPE)
	If !lMiddleware .And. cVerGPE <> cVerEnv .And. (cVerGPE >= "9.0" .Or. cVerEnv >= "9.0")
		//"Atenção! A versão do leiaute GPE é xxx e a do TAF é xxx, sendo assim, estão divergentes. O Evento xxx não será integrado com o TAF, e consequentemente, não será enviado ao RET.
		//Caso prossiga a informação será atualizada somente na base do GPE. Deseja continuar?"
		If ESocMsgVer(.F.,/*cEvento*/, cVerGPE, cVerEnv)
			lVlEsocDif  := .T.
			lIntTAF		:= .F.
		Else
			Return
		EndIf
	EndIf
EndIf

//Inicializa variaveis que no modelo 1 sao mnemonicos
If cModFol == "2"
	aIncRes				:= {}
	lUltSemana 			:= .F.
	lRescDis			:= .F.
	lRescPLR			:= .F.
	lRecRes				:= .F.
	nPosSem				:= 0
	Salario				:= 0
	SalHora				:= 0
	SalDia				:= 0
	SalMes				:= 0
	NORMAL				:= 0
	DESCANSO			:= 0
	nDferven 			:= 0
	nFaltasv			:= 0
	nDferave			:= 0
	nFaltasp			:= 0
	nDferInd			:= 0
	cProcesso			:= ""
	cPeriodo			:= ""
	cNumPag				:= ""
	cRot				:= ""
	cCompl				:= ""
	dDataDem			:= CtoD("")
	dDataAvis			:= CtoD("")
	dDtEst936			:= CtoD("")
	nPerEst936			:= 0
EndIf

If lRotAuto

	lAtuBrowse	:= .F.

	FWExecView(If(nOpcAuto == MODEL_OPERATION_INSERT,STR0037,If(nOpcAuto == MODEL_OPERATION_VIEW,STR0005,STR0007)), "GPEM040", nOpcAuto ,,{||.T.})

Else

	Define MsDialog oDlgPrinc Title OemToAnsi(STR0001) From aCoors[1], aCoors[2] To aCoors[3], aCoors[4] OF oMainWnd Pixel  //"Calculo de Rescisao"

	// Cria o conteiner onde serão colocados os paineis
	oTela     := FWFormContainer():New( oDlgPrinc )
	cIdBrowse := oTela:CreateHorizontalBox( 60 )
	cIdGrid   := oTela:CreateHorizontalBox( 35 )

	oTela:Activate( oDlgPrinc, .F. )

	//Cria os paineis onde serao colocados os browses
	oPanelUp  	:= oTela:GeTPanel( cIdBrowse )
	oPanelDown  := oTela:GeTPanel( cIdGrid )

	// FWmBrowse Superior: Funcionarios
	oBrowseUp:= FWmBrowse():New()
	oBrowseUp:SetOwner( oPanelUp )                  // Aqui se associa o browse ao componente de tela
	oBrowseUp:SetDescription( OemToAnsi(STR0002) )	//"Funcionarios"
	oBrowseUp:SetAlias( 'SRA' )
	oBrowseUp:SetMenuDef( 'GPEM630' )              // Define de onde virao os botoes deste browse
	oBrowseUp:DisableDetails()
	oBrowseUp:SetProfileID( '1' )
	oBrowseUp:SetCacheView (.F.)
	oBrowseUp:ExecuteFilter(.T.)

	GpLegMVC(@oBrowseUp)

	cFiltraRh := ChkRh("GPEM040","SRA","1")
	// Aplicar filtro quando chamado pelo TCFA040 (Aprovacao workflow portal)
	If lTCFA040
		cFiltraRh += IF(!Empty(cFiltraRh),'.and. RA_FILIAL == "' + RTrim(cFilFun) + '"','RA_MAT == "' + RTrim(cMatFun) + '"')
	EndIf

	oBrowseUp:SetFilterDefault(cFiltraRh)
	oBrowseUp:SetMainProc("GPEM630")
	oBrowseUp:Activate()

	// FWmBrowse Inferior: Cabecalhos de rescisao
	oBrowseDwn:= FWMBrowse():New()
	oBrowseDwn:SetOwner( oPanelDown )
	oBrowseDwn:SetDescription( OemToAnsi(STR0003) )	//"Cabeçalho de rescisão"
	oBrowseDwn:SetMenuDef( 'GPEM040' )
	oBrowseDwn:DisableDetails()
	oBrowseDwn:SetAlias( 'SRG' )
	oBrowseDwn:SetProfileID( '2' )
	oBrowseDwn:ForceQuitButton()					//sempre que existem dois menudefs na tela, deve-se indicar em qual browse vai ficar o botao 'Sair'
	oBrowseDwn:SetCacheView (.F.)
	oBrowseDwn:ExecuteFilter(.T.)

	If cModFol == "2"
		oBrowseDwn:AddLegend( "SRG->RG_EFETIVA=='1'"		, 'YELLOW'	, OemToAnsi(STR0030) ) //Nao Calculado
		oBrowseDwn:AddLegend( "SRG->RG_EFETIVA=='2'"		, 'GREEN'	, OemToAnsi(STR0031) ) //Calculado
		oBrowseDwn:AddLegend( "SRG->RG_EFETIVA=='3'"		, 'RED'		, OemToAnsi(STR0032) ) //Fechado
		oBrowseDwn:AddLegend( "SRG->RG_EFETIVA=='4'"		, 'PINK'	, OemToAnsi(STR0033) ) //Impresso
		oBrowseDwn:AddLegend( "SRG->RG_EFETIVA=='5'"		, 'BLUE'	, OemToAnsi(STR0034) ) //Pago
	Else
		oBrowseDwn:AddLegend( "SRG->RG_EFETIVA=='S'"		, 'RED'		, OemToAnsi(STR0035) ) //Efetivada
		oBrowseDwn:AddLegend( "SRG->RG_EFETIVA=='N'"		, 'BLUE'	, OemToAnsi(STR0036) ) //Simulação
	EndIf

	// Relacionamento entre os Paineis
	oRelacSRG:= FWBrwRelation():New()
	oRelacSRG:AddRelation( oBrowseUp  , oBrowseDwn , { { 'RG_FILIAL', 'RA_FILIAL' }, { 'RG_MAT' , 'RA_MAT'  } } )
	oRelacSRG:Activate()

	oBrowseDwn:SetMainProc("GPEM040")
	oBrowseDwn:Activate()

	oBrowseUp:Refresh()
	oBrowseDwn:Refresh()

	Activate MsDialog oDlgPrinc Center

EndIf

RestArea(aArea)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MenuDef     ³ Autor ³ Leandro Drumond       ³ Data ³ 11/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Menu Funcional                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MenuDef()                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function MenuDef()

	Local aRotina := {}

	DEFAULT lGestPubl 	:= IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP
	DEFAULT lIntTaf 	:= ((SuperGetMv("MV_RHTAF",, .F.) == .T.) .AND. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 1 )
	DEFAULT lMiddleware	:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )

	ADD OPTION aRotina Title OemToAnsi(STR0004)	Action 'PesqBrw'         OPERATION 1  ACCESS 0 DISABLE MENU //"Pesquisar"
	ADD OPTION aRotina Title OemToAnsi(STR0005)	Action 'VIEWDEF.GPEM040' OPERATION 2  ACCESS 0 DISABLE MENU //"Visualizar"
	ADD OPTION aRotina Title OemToAnsi(STR0037) Action 'VIEWDEF.GPEM040' OPERATION 3  ACCESS 0 DISABLE MENU //"Incluir"

	If SuperGetMv( "MV_MODFOL", .F., "1" ) == "2"
		ADD OPTION aRotina Title OemToAnsi(STR0006) Action 'VIEWDEF.GPEM040' OPERATION 4  ACCESS 0 DISABLE MENU //"Manutenção"
	EndIf

	ADD OPTION aRotina Title OemToAnsi(STR0007) Action 'VIEWDEF.GPEM040' OPERATION 5  ACCESS 0 DISABLE MENU	//"Excluir"

	If cPaisLoc == "BRA"
		ADD OPTION aRotina Title OemToAnsi(STR0103) Action 'GPEA925(Nil,Nil,4)' OPERATION 3  ACCESS 0 DISABLE MENU	//"Cadastro de Aviso Prévio"
	EndIf

	If lGestPubl .AND. cModulo $ 'GFP*VDF'
		ADD OPTION aRotina Title OemToAnsi(STR0226) Action 'Gp40GItePu()' OPERATION 3  ACCESS 0 DISABLE MENU //"Gerar Item Publicação"
	EndIf

	If cPaisLoc == "BRA" .And. (lIntTaf .Or. lMiddleware) .And. FindFunction("fIntResLot") .And. !lVlEsocDif
		ADD OPTION aRotina Title OemToAnsi(STR0283) Action 'fIntResLot()' OPERATION 3  ACCESS 0 DISABLE MENU//"Integ. eSocial em lote"
	EndIf

Return aRotina

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ModelDef    ³ Autor ³ Leandro Drumond       ³ Data ³ 11/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Modelo de Dados da Rotina                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ModelDef()                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function ModelDef()
Local oModel
Local oStruSRG
Local oStruGET
Local cWhenSRG		:= ""
Local nX			:= 0
Local oEvent  		:= GPM040VLD():New()
Local bCommiM040	:= { | oModel | fCommit040(oModel) }
Local lBloqAdm		:= SRA->(ColumnPos("RA_BLOQADM")) > 0

cModFol		:=  If( Type("CMODFOL")== "U", SuperGetMv( "MV_MODFOL", .F., "1" ), cModFol)

oModel := MPFormModel():New( 'GPEM040', /*bPreValid*/, /*Utilizar FWModelEvent*/, bCommiM040, /*Utilizar FWModelEvent*/ )

oStruSRG := FWFormStruct(1,"SRG")
oStruSRG:AddField ( PosAlias( "SX3" , "RA_ADMISSA"  , "" , "X3Titulo()" , 2 , .F. ) 	,; //Titulo
					""																	,; //Descricao
					"RG_ADMISSA"														,; //Campo
					"D"																	,; //Tipo
					8																	,; //Tamanho
					0																	,; //Decimal
					Nil																	,; //Valid
					Nil																	,; //When
					Nil																	,; //Combo
					Nil																	,; //Obrigatorio
					FwBuildFeature( STRUCT_FEATURE_INIPAD, "SRA->RA_ADMISSA" )			,; //Inicializador padrao
					Nil																	,; //Campo chave
					Nil																	,; //Alteravel
					.T.																	)  //Virtual
if cPaisLoc == "BRA"
	oStruSRG:AddField ( OemToAnsi(STR0261)												 	,; //Titulo
					""																	,; //Descricao
					"RG_DSCRESC"														,; //Campo
					"C"																	,; //Tipo
					25																	,; //Tamanho
					0																	,; //Decimal
					Nil																	,; //Valid
					Nil																	,; //When
					Nil																	,; //Combo
					Nil																	,; //Obrigatorio
					FwBuildFeature(STRUCT_FEATURE_INIPAD, "fSRetDes()")					,; //Inicializador padrao
					Nil																	,; //Campo chave
					.F.																	,; //Alteravel
					.T.																	)  //Virtual
EndIf
//		 		   cTitulo, cTooltip, cIdField	 , cTipo	, nTamanho, nDecimal, bValid, bWhen, aValues, lObrigat, bInit									      												 					 , lKey, lNoUpd, lVirtual, cValid)
If lBloqAdm
	oStruSRG:AddField( OemToAnsi(STR0150), ""	    , "RA_BLOQADM", "L"		, 1	  	  ,	0		, Nil	, Nil  , Nil	,	   Nil,	FwBuildFeature( STRUCT_FEATURE_INIPAD, "If(SRA->RA_BLOQADM == '1', .T., .F.)" ), Nil , .F.   , .T.     , ""    )
ElseIf cPaisLoc $ "BRA|DOM|MEX"
	oStruSRG:AddField( OemToAnsi(STR0150), ""	    , "RA_FECREI", "L"		, 1	  	  ,	0		, Nil	, Nil  , Nil	,	   Nil,	FwBuildFeature( STRUCT_FEATURE_INIPAD, "If(SRA->RA_FECREI != cTOd('') .AND. SRA-> RA_SITFOLH == 'D', .T., .F.)" ), Nil , .F.   , .T.     , ""    )
EndIf

oModel:AddFields("GPEM040_MSRG", /*cOwner*/, oStruSRG , /*Pre-Validacao*/,/*Pos-Validacao*/,/*Carga*/)

If aStructSRG == Nil .Or. Empty(aStructSRG)
	aStructSRG := oStruSRG:GetFields()
EndIf

For nX := 1 to Len(aStructSRG)
	cWhenSRG := "{ || fSRGWhen( '" + aStructSRG[nX,3] + "' ) } "
	oStruSRG:SetProperty( aStructSRG[nX,3], MODEL_FIELD_WHEN, &(cWhenSRG) )
	If cPaisLoc == "BRA" .and. aStructSRG[nX,3] == "RG_SABDOM"
		oStruSRG:SetProperty( aStructSRG[nX,3], MODEL_FIELD_VALID, {|| fVldSabDom() } )
	ElseIf cPaisLoc == "BOL" .and. aStructSRG[nX,3] == "RG_DATAHOM"
		oStruSRG:SetProperty( aStructSRG[nX,3], MODEL_FIELD_VALID, {|a,b,c,d| FWInitCpo(a,b,c),lRet:=((fChkDtHom(M->RG_DATADEM, M->RG_DATAHOM))),FWCloseCpo(a,b,c,lRet),lRet} )
	EndIf
Next nX

If cModFol == "2"
	oStruGET := FWFormStruct( 1, 'SRC', /*bAvalCampo*/, /*lViewUsado*/ )
	//seta inicializador padrao para o campo de descricao do SRC
	oStruGET:SetProperty( 'RC_DESCPD' , MODEL_FIELD_INIT, FWBuildFeature( /*STRUCT_FEATURE_INIPAD*/ 3 , "FillDescPd()" ))
Else
	oStruGET := FWFormStruct(1, "SRR")

	oStruGET:SetProperty( 'RR_DESCPD' , MODEL_FIELD_INIT,{|oGrid|FDESC("SRV",If(oGrid:Length()>0,oGrid:GetValue("RR_PD"),SRR->RR_PD),"RV_DESC")})
EndIf

IncidCpos(oStruGET,IIF(cModFol == "2","SRC","SRR"))

oModel:AddGrid("GPEM040_MGET", "GPEM040_MSRG", oStruGET,/*bLinePre*/, /* bLinePost*/, /*bPre*/,  /*bPost*/,/*{|oGrid| CargaSRR(oGrid) }*//*bLoad*/)

//Regras do Model GPEM040_MGET
oModel:GetModel( "GPEM040_MGET" ):SetNoInsertLine(.T.)
oModel:GetModel( "GPEM040_MGET" ):SetNoDeleteLine(.T.)
oModel:GetModel( "GPEM040_MGET" ):SetOptional(.T.)

//Definindo relacionamento entre SRG e SRC
If cModFol == "2"
	If cPaisLoc $ "ARG*CHI*COL*COS*DOM*MEX"
	   oModel:SetRelation( 'GPEM040_MGET', { { 'RC_FILIAL', 'xFilial( "SRC" )' } , { 'RC_MAT', 'RG_MAT' },  {'RC_DTREF', 'RG_DTPAGO'}	} , SRC->(IndexKey(1)) )
	Else
	    oModel:SetRelation( 'GPEM040_MGET', { { 'RC_FILIAL', 'xFilial( "SRC" )' } , { 'RC_MAT', 'RG_MAT' }	} , SRC->(IndexKey(1)) )
	EndIf
Else
	SRR->(DbSetOrder( RetOrdem( "SRR", "RR_FILIAL+RR_PD" ) ))
	oModel:SetRelation( 'GPEM040_MGET', { { 'RR_FILIAL', 'xFilial( "SRG" )' }, { 'RR_MAT', 'RG_MAT' }, { 'RR_DATA', 'RG_DTGERAR' }}, SRR->( IndexKey( 5 ) ) )
EndIf


oModel:SetPrimaryKey( {"RG_FILIAL", "RG_MAT", "RG_PERIODO", "RG_ROTEIR", "RG_SEMANA", "RG_DTGERAR", "R_E_C_D_E_L_"} )

//--Valida se o model deve ser ativado
oModel:SetVldActivate( { |oModel| fVldModel(oModel,oModel:GetOperation()) } )

//--Apos a ativacao, faz a carga inicial da enchoice
oModel:SetActivate( { |oModel| fInitModel(oModel,oModel:GetOperation()) } )

oModel:InstallEvent("GPM040VLD", /*cOwner*/, oEvent)

Return oModel

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ViewDef     ³ Autor ³ Leandro Drumond       ³ Data ³ 11/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³View                                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ViewDef()                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function ViewDef()

Local lResComp	:= .F.
Local lRetif	:= .F.
Local lConfCompl:= SRR->(ColumnPos("RR_VALORI")) > 0
Local oStruSRG 	:= FWFormStruct( 2, 'SRG' )
Local oStruGET 	:= If( cModFol == "2" , FWFormStruct( 2, 'SRC' ) , FWFormStruct( 2, 'SRR' ) ) //Modelo 1 utiliza SRR, modelo 2 utilizada SRC
Local oModel   	:= FWLoadModel( 'GPEM040' )
Local oView
Local bAplicacao:= {|| fAplicaRes(1) }
Local bUndoAplic:= {|| fAplicaRes(2) }
Local bCalcM42	:= {|| MsAguarde( { || Iif( lTCFA040, If(VldTpRes(), CalResc(), Help( , , OemToAnsi(STR0020), , OemToAnsi(STR0188), 1, 0 )), CalResc() )} , STR0101 )}
Local bCalcAnt	:= {|| RescAntView() }
Local bLancFixos:= {|| AbreCadastro(1)}
Local bIncidenci:= {|| AbreCadastro(2) }
Local bAusencias:= {|| AbreCadastro(3) }
Local bValFuturo:= {|| AbreCadastro(4) }
Local bTmpExtra	:= {|| AbreCadastro(5) }
Local bIntegra	:= {|| AbreCadastro(6) }
Local bMedias	:= {|| AbreCadastro(7) }
Local bFerias	:= {|| AbreCadastro(8) }
Local bPonto	:= {|| AbreCadastro(9) }
Local bAviso	:= {|| AbreCadastro(10) }
Local bIntTAF
Local lBloqAdm	:= SRA->(ColumnPos("RA_BLOQADM")) > 0
Local lHistMed	:= AliasInDic("RJK") .And. AliasInDic("SRP")

DEFAULT lIntTaf 	:= ((SuperGetMv("MV_RHTAF",, .F.) == .T.) .AND. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 1 )
DEFAULT lMiddleware	:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )

bIntTAF	:= {|| iif ((lIntTaf .Or. lMiddleware) .And. fResCompl(Nil ,.T., Nil, @lResComp, @lRetif),fIntegraTAF( (lIntTaf .Or. lMiddleware), oModel:GetModel('GPEM040_MSRG'), oModel:GetModel('GPEM040_MGET'), oModel, lResComp, lRetif, aPd_SRK ),.T.) }

oView := FWFormView():New()
oView:SetModel( oModel )

oStruSRG:RemoveField( 'RG_PROCES' )
oStruSRG:RemoveField( 'RG_ROTEIR' )
oStruSRG:RemoveField( 'RG_RRA' )

oStruSRG:AddField ( "RG_ADMISSA"														,; //Campo
					"04"																,; //Ordem
					PosAlias( "SX3" , "RA_ADMISSA"  , "" , "X3Titulo()" , 2 , .F. )		,; //Titulo
					""																	,; //Descricao
					{""}																,; //Help
					"D"																	,; //Tipo
					""																	,; //Picture
					Nil																	,; //Bloco picture var
					''																	,; //F3
					.F.																	,; //Alteravel?
					"1"																	,; //Pasta
					Nil																	,; //Agrupamento
					Nil																	,; //Combo
					Nil																	,; //Tamanho maximo combo
					Nil																	,; //Inicializador de browse
					.T.																	)  //Virtual
If cPaisLoc=='BRA'
	oStruSRG:AddField ( "RG_DSCRESC"														,; //[01] - Campo
					"30"																,; //[02] - Ordem
					OemToAnsi(STR0261)													,; //[03] - Titulo
					""																	,; //[04] - Descricao
					{""}																,; //[05] - Help
					"C"																	,; //[06] - Tipo
					""																	,; //[07] - Picture
					Nil																	,; //[08] - Bloco picture var
					''																	,; //[09] - F3
					.F.																	,; //[10] - Alteravel?
					"1"																	,; //[11] - Pasta
					Nil																	,; //[12] - Agrupamento
					Nil																	,; //[13] - Combo
					25																	,; //[14] - Tamanho maximo combo
					Nil																	,; //[15] - Inicializador de browse
					.T.																	)  //[16] - Virtual
EndIf
//		 AddField( cIdField   , cOrdem, cTitulo, cDescric, aHelp, cType, cPicture, bPictVar, cLookUp, lCanChange, cFolder, cGroup, aComboValues, nMaxLenCombo, cIniBrow, lVirtual, cPictVar, lInsertLine )
If lBloqAdm
	oStruSRG:AddField( "RA_BLOQADM", "26"  , OemToAnsi(STR0150), ""		 , {""} , "L"  , ""	     , Nil	   , ''	    , .T.	    , "1"	 , Nil	 , Nil		   , Nil  		 , ".T."   , .F.	 , ""	   , .F. 		 )
ElseIf cPaisLoc $ "BRA|DOM|MEX"
	oStruSRG:AddField( "RA_FECREI", "26"  , OemToAnsi(STR0150), ""		 , {""} , "L"  , ""	     , Nil	   , ''	    , .T.	    , "1"	 , Nil	 , Nil		   , Nil  		 , ".T."   , .F.	 , ""	   , .F. 		 )
EndIf

If cPaisLoc $ "BRA|EQU"
	oStruSRG:SetProperty( 'RG_SABDOM' , MVC_VIEW_CANCHANGE, .T. )
EndIf

//Altera as propriedades dos campos abaixo, para permitir edição.
If cPaisLoc == "BRA"
	oStruSRG:SetProperty( 'RG_DAVISO' , MVC_VIEW_CANCHANGE, .T. )
	oStruSRG:SetProperty( 'RG_DAVCUM' , MVC_VIEW_CANCHANGE, .T. )
	oStruSRG:SetProperty( 'RG_DAVIND' , MVC_VIEW_CANCHANGE, .T. )
EndIf

If cPaisLoc <> "BRA
	oStruSRG:SetNoFolder() //Se nao for Brasil, nao divide em pasta, pois nao possui referencia ao EFD Social
EndIf

If SRG->(ColumnPos("RG_PDRESC")) > 0
	oStruSRG:SetProperty( 'RG_PDRESC' , MVC_VIEW_FOLDER_NUMBER, "1")
EndIf

If SRG->(ColumnPos("RG_NPROCS")) > 0 .And. cPaisLoc == "BRA
    oStruSRG:SetProperty( 'RG_NPROCS' , MVC_VIEW_FOLDER_NUMBER, "2")
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Nao apresenta os seguintes campos no Grid                  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If cModFol == "2"
	oStruGET:RemoveField( 'RC_FILIAL' )
	oStruGET:RemoveField( 'RC_MAT' )
	oStruGET:RemoveField( 'RC_NOME' )
	oStruGET:RemoveField( 'RC_QTDSEM' )
	oStruGET:RemoveField( 'RC_HORINFO' )
	oStruGET:RemoveField( 'RC_VALINFO' )
	oStruGET:RemoveField( 'RC_VALORBA' )
	oStruGET:RemoveField( 'RC_PROCES' )
	oStruGET:RemoveField( 'RC_PERIODO' )
	oStruGET:RemoveField( 'RC_ROTEIR' )
	oStruGET:RemoveField( 'RC_SEMANA' )
Else
	oStruGET:RemoveField( 'RR_FILIAL' )
	oStruGET:RemoveField( 'RR_MAT' )
	oStruGET:RemoveField( 'RR_AUXIL' )
	oStruGET:RemoveField( 'RR_TIPO3' )
	If lConfCompl
		If Empty(SRA->RA_DEMISSA)
			oStruGET:RemoveField( 'RR_VALORI' ) //Não exibe o campo na primeira rescisão ou na complementar no mesmo mês
		Else
			oStruGET:SetProperty( 'RR_VALORI' , MVC_VIEW_ORDEM, "08" )
		EndIf
	EndIf
EndIf

IncidCpos(oStruGET,IIF(cModFol == "2",'SRC','SRR'),.T.)

oView:AddField( 'VIEW_SRG', oStruSRG, 'GPEM040_MSRG' )
oView:AddGrid(  'VIEW_GET', oStruGET, 'GPEM040_MGET' )

oView:CreateHorizontalBox( 'SUPERIOR', 50 )
oView:CreateHorizontalBox( 'INFERIOR', 50 )

oView:SetOnlyView('VIEW_GET') //nao permite alteracoes no Grid

oView:SetOwnerView( 'VIEW_SRG', 'SUPERIOR' )
oView:SetOwnerView( 'VIEW_GET', 'INFERIOR' )

oView:addUserButton(OemToAnsi(STR0011) + " (F6)","MAGIC_BMP", bCalcM42,   OemToAnsi(STR0011),VK_F6, {MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE} ) //"Calcular Rescisão"

If cPaisLoc == "BRA" .And. !Empty(SRA->RA_DEMISSA)
	//Se for complementar, inclui botão para visualizar rescisões anteriores
	oView:addUserButton("Rescisões Anteriores" ,"MAGIC_BMP", bCalcAnt,   OemToAnsi(STR0253),, {MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE} ) //"Rescisões Anteriores"
EndIf

If cModFol == "2"
	oView:addUserButton(OemToAnsi(STR0013),"MAGIC_BMP", bAplicacao, OemToAnsi(STR0013),, {MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE} )	 //"Aplicar rescisão"
	oView:addUserButton(OemToAnsi(STR0014),"MAGIC_BMP", bUndoAplic, OemToAnsi(STR0014),, {MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE} )	 //"Desfazer aplicação de rescisão"
EndIf

oView:addUserButton(OemToAnsi(STR0015),"MAGIC_BMP", bLancFixos, OemToAnsi(STR0015),,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE } )	//"Lançamentos Fixos"
oView:addUserButton(OemToAnsi(STR0016) + " (F7)","MAGIC_BMP", bIncidenci, OemToAnsi(STR0016),VK_F7,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE } )	//"Lançamentos por funcionário"
oView:addUserButton(OemToAnsi(STR0017),"MAGIC_BMP", bAusencias, OemToAnsi(STR0017),,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE } )	//"Afastamentos"
oView:addUserButton(OemToAnsi(STR0018),"MAGIC_BMP", bValFuturo, OemToAnsi(STR0018),,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE } )	//"Valores Futuros"
oView:addUserButton(OemToAnsi(STR0038) + " (F8)","MAGIC_BMP", bIntegra, 	 OemToAnsi(STR0038),VK_F8,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE } )	//"Integrações"
oView:addUserButton(OemToAnsi(STR0120),"MAGIC_BMP", bMedias, 	 OemToAnsi(STR0120),,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE,iif(lHistMed,MODEL_OPERATION_VIEW,) } )						//"Visualizar Medias"
oView:addUserButton(OemToAnsi(STR0121),"MAGIC_BMP", bFerias, 	 OemToAnsi(STR0121),,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE } )	//"Contr. Dias de Direito"
oView:addUserButton(OemToAnsi(STR0075),"CLOCK01",bPonto , 	 OemToAnsi(STR0075),,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE } )	//"Contr. Dias de Direito"
oView:addUserButton(OemToAnsi(STR0166),"MAGIC_BMP", bAviso, 	 "Aviso Prévio"/*OemToAnsi(STR0121)*/,,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE } )	//"Aviso Prévio"

If cModFol == "2"
	oView:addUserButton(OemToAnsi(STR0019),"MAGIC_BMP", bTmpExtra , OemToAnsi(STR0019),,{MODEL_OPERATION_INSERT,MODEL_OPERATION_UPDATE,MODEL_OPERATION_VIEW } )	//"Tempo Extra"
EndIf

//Botão auxiliar para integração no TAF
If cPaisLoc == "BRA" .And. FunName() == "GPEM040" .And. SRG->RG_EFETIVA == "S" .And. !lVlEsocDif
	oView:addUserButton( OemToAnsi(STR0211), "MAGIC_BMP", bIntTAF, OemToAnsi(STR0211), , {MODEL_OPERATION_VIEW} )	//"Integração com o TAF"
EndIf

oView:SetCloseOnOk({ || If(SRG->RG_EFETIVA == "S", fCtrTitLg(), .T. )}) //Fecha tela apos commit

oView:SetViewCanActivate({ |oView| Gp40VldView(oView)})

oView:SetAfterViewActivate({ |oView| Gp40VldView(oView)})

oView:SetViewAction( 'BUTTONCANCEL', { |oView| fDelHist( .F.,oView ) } )

Return oView

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gp40VldView ºAutor  ³Leandro Drumond   º Data ³  20/08/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida view			                                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Gp40VldView(oView)
dbSelectArea("SRG")
Return lCancelCalc //Se cancelou a seleção de complementar/recalculo..retorna sem exibir erro.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fVldModel    ³ Autor ³ Leandro Drumond       ³ Data ³ 11/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida model e inicializa cabecalho SRG.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fVldModel(oModel,nOperation)                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fVldModel(oModel,nOperation)
Local aPerAtual		:= {}
Local aRetAuto		:= {}
Local cMesAnoRef	:= ""
Local cMesAnoDem	:= ""
Local cCodFer		:= ""
Local lRet			:= .T.
Local lRetPer		:= .T.
Local lEstag		:= .F.
Local nMaxCompl		:= 0
Local lRobo			:= IsBlind()
Local aInfoTpRes	:= {}

DEFAULT lGestPubl   := IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP
DEFAULT lCtrlTit	:= ChkFile("RJ1") .And. !Empty(GetNewPar("MV_BTITRES", "" )) .And. RJ1->(ColumnPos( "RJ1_ROTEIR")) > 0 .And. RJ1->(ColumnPos( "RJ1_PROCES")) > 0 .And. RJ1->(ColumnPos( "RJ1_TIPO")) > 0

lModDataDem := GetMvRH("MV_MDDTDEM",NIL,"N") == "S"

RstlDefaut()
SetMnemonicos(NIL,NIL,.T.,,,"GPEM040")

Begin Sequence

	If IsInCallStack("FwAlertExitPage")
		lCancelCalc := .F.
		Break
	EndIf
	//Zera aSPBRec
	aPd			:= {}
	aSrgRecnos  := {}
	aSPBRec 	:= {}
	aPerFerias	:= {}
	aPeriodo	:= {}
	aCodFol		:= {}
	aFerPag		:= {}
	dDataDem	:= dDataDem1 := dDtEst936 := CtoD("")
	dDataAvis	:= CtoD("")
	lColetiva	:= .F.
	lProxMes	:= .F.
	nRegSrg 	:= 0
	nDFerVen 	:= 0
	nDFerAux 	:= 0
	nDFerAve 	:= 0
	nDFerInd	:= 0
	nDFerAnt	:= 0
	nDiasAv		:= 0
	nDiascum	:= 0
	nDiaInde	:= 0
	cTipoRot	:= "4"
	cRfyTpAv	:= ""
	lTemRFY		:= .F.
	lRecRes		:= .F.
	lDtDemRFY	:= .F.
	cFilOld		:= cFilAnt
	cFilAnt		:= SRA->RA_FILIAL
	nPerEst936	:= 0

	lAtuSimul 	:= .F. //Indica se trata-se de efetivacao de uma simulacao
	cCompl	  	:= "N"
	lRescDis  	:= .F.
	lDissidio 	:= .F.
	lCancelCalc	:= .T.
	lIntTaf		:= ((SuperGetMv("MV_RHTAF",, .F.) == .T.) .And. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 1 ) .And. !(SRA->RA_CATEFD $ SuperGetMv( "MV_NTSV", .F., "701|711|712|741|" )) .And. !lVlEsocDif
	lMiddleware	:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )
	cOpcCompl 	:= "1"

	If _BkpFilial <> SRA->RA_FILIAL .or. Empty(_aCodFol)
		If !FP_CODFOL(@aCodFol,SRA->RA_FILIAL)
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0100), 1, 0 ) //"Atenção" ## "Falha na carga de verbas"
			Return( .F. )
		EndIf
		_aCodFol:= aClone(aCodFol)
		_BkpFilial:= SRA->RA_FILIAL
	Endif

	aCodFol:= aClone(_aCodFol)
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cria Arquivo Temporario para Calculo de Medias               ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	Cria_Trp()

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Nao deixa incluir rescisao se houver outra em aberto. 	          ³
	³ Se jah houver rescisao fechada, lanca como rescisao complementar.   ³
	³ (Se for complemetar fora do mes, sera modificada no TudoOK)  	      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If nOperation == MODEL_OPERATION_INSERT

		If (TamSX3("RR_HORAS")[1] > TamSX3("RC_HORAS")[1]) .Or. (TamSX3("RR_HORAS")[1] > TamSX3("RD_HORAS")[1]) .Or. (TamSX3("RR_HORAS")[1] > TamSX3("RGB_HORAS")[1])
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0189 + CRLF + STR0190 ), 1, 0)  // "Atenção"##"O tamanho dos campos RR_HORAS, RC_HORAS, RD_HORAS e RGB_HORAS está divergente e deveriam estar iguais."##"Solicite a correção ao administrador do sistema."
			lRet := .F.
			Break
		EndIf

		If cPaisLoc == "BRA" .and. !Empty(SRA->RA_DEMISSA) .and. SRA->RA_SITFOLH == "D" .and. SRA->RA_RESCRAI == '31'
			lRet := .F.
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0229) , 1, 0 ) //"Atenção" ## Funcionário foi transferido e não encontra-se ativo nesta empresa/filial."
			Break
		EndIf
		If ! SRA->RA_CATFUNC $ "A*P" // Se não for autônomo ou pró-labore verifica o controle de dias de direito
			If SRA->RA_CATFUNC $ "E*G"   // Estagiario Mensalista/Horista
				cCodFer	:= FGETCODFOL( "0891" )
				lEstag	:= .T.
			Else
				cCodFer	:= FGETCODFOL( "0072" )
			EndIf
			SRF->(DbSetOrder(2))
			lRet := SRF->( dbSeek( SRA->( RA_FILIAL + RA_MAT + cCodFer  ) ) )

			SRF->(DbSetOrder(1))

			If !lRet .AND. lGestPubl .AND. SRA->RA_CATFUNC $ '4*7*8*9' //GFP nao exige SRF das categorias Adido/Aponsentados/Pensionista
				lRet := .T.
			EndIf

			If !lRet .and. Empty(SRA->RA_DEMISSA)
				If !lEstag
		   			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0039) , 1, 0 ) //"Atenção" ## Funcionário não tem registro cadastrado para o ID 0072 no cadastro de Controle de Dias de Direito.
			   Else
					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0148) , 1, 0 ) //"Atenção"	## Funcionário não tem registro cadastrado para o ID 0891 no cadastro de Controle de Dias de Direito.
			   EndIf
			   Break
			EndIf
		EndIf

		lRet := .T.

		If fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, fGetCalcRot('4') )
			cMesAnoRef  := aPerAtual[1,5] + aPerAtual[1,4]
			dDataDe  := aPerAtual[1,6]
			dDataAte := aPerAtual[1,7]
			cPeriodo := aPerAtual[1,1]
			cRot	 := aPerAtual[1,3]
			cNumPag	 := aPerAtual[1,2]
			cSemana	 := aPerAtual[1,2]
			cProcesso:= aPerAtual[1,8]

			lRetPer := fCarPeriodo( cPeriodo , cRot , @aPeriodo , @lUltSemana , @nPosSem)

			If !lRetPer
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0153), 1, 0)  // "Atenção"###"A configuração dos períodos está incorreta ou não existe período válido para o roteiro de rescisão. Verifique o cadastro de períodos."
				lRet := .F.
				Break
			EndIf

			NORMAL := aPeriodo[nPosSem,24] * SRA->RA_HRSDIA
            DESCANSO := aPeriodo[nPosSem,07] * SRA->RA_HRSDIA
		Else
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0021) + SRA->RA_PROCES + OemToAnsi(STR0022) + fGetCalcRot('4'), 1, 0)  // "Atenção"###"Não existe periodo aberto para o processo: ### roteiro:###"
		    lRet := .F.
		    Break
		EndIf

		dbSelectArea("SRG")

		If cModFol == "2"
			cResComp := "1"
			SRG->(DbSetOrder( RetOrdem( "SRG", "RG_FILIAL+RG_MAT+DTOS(RG_DTPAGO)" ) ))
			If SRG->(dbSeek(xFilial("SRG",SRA->RA_FILIAL)+SRA->RA_MAT))
				While SRG->(!Eof() .and. RG_FILIAL + RG_MAT == xFilial("SRG",SRA->RA_FILIAL) + SRA->RA_MAT )
					If SRG->RG_EFETIVA $ "1*2"
						Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0040), 1, 0 ) //"Nao é possivel incluir nova rescisao" ## "pois existe rescisao em aberto para este funcionario"
						lRet:= .F.
						Break
					EndIf
					SRG->(DbSkip())
				EndDo
				cResComp := "2"
		  	EndIf
		Else
			SRG->(DbSetOrder( RetOrdem( "SRG", "RG_FILIAL+RG_MAT+DTOS(RG_DTGERAR)" ) ))

			If SRG->(dbSeek(xFilial("SRG",SRA->RA_FILIAL)+SRA->RA_MAT))
				While SRG->(!Eof() .and. RG_FILIAL + RG_MAT == xFilial("SRG",SRA->RA_FILIAL) + SRA->RA_MAT )
					nRegSrg := SRG->( Recno() )
					If MesAno( SRG->RG_DTGERAR ) == cMesAnoRef
						nMaxCompl++
					EndIf
					nPos	:= aScan( aSrgRecnos , { |x| MesAno( x[2] ) == MesAno( SRG->RG_DTGERAR ) } )
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Se Teve Rescisao Complementar no Mesmo Mes da Demissao consi³
					³sidera apenas a Ultima										 ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					If MesAno( SRG->RG_DTGERAR ) == MesAno( SRG->RG_DATADEM ) .And. nPos > 0.00 .And. !fCompPLR()
						aSrgRecnos[ nPos , 01 ] := nRegSrg
						aSrgRecnos[ nPos , 02 ] := SRG->RG_DTGERAR
						aSrgRecnos[ nPos , 03 ] := SRG->RG_DATADEM
					Else
						SRG->( aAdd( aSrgRecnos , { nRegSrg , RG_DTGERAR , RG_DATADEM } ) )
					EndIf

					SRG->(DbSkip())
				EndDo
				SRG->(DbGoTo(nRegSrg))

				cMesAnoDem	:= AnoMes(SRG->RG_DATADEM)
				lProxMes	:= !(cMesAnoRef == cMesAnoDem)

				If SRG->RG_EFETIVA == "N"
					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0023),1,0 )//"Existe rescisão simulada gravada. Será aberta para efetivação."
					oModel:SetOperation(MODEL_OPERATION_UPDATE)
					lAtuSimul := .T.
					Break
			  	Else

					//Se ano da rescisao complementar (MV_FOLMES) for maior que ano da demissao, deve calcular RRA
					lRescRRA := If(SubStr(cMesAnoRef,1,4) > SubStr(cMesAnoDem,1,4),.T.,.F.)

					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Calculo de Rescisoes Complementares no Mesmo Mes/Ano e Limi³
					³ tado a 9 em funcao do campo RC_SEQ ser de Tamanho 1        ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					If lProxMes
						If ( nMaxCompl < 9 )
							cCompl	:= "S"
							If !IsBlind()
								If cPaisLoc != "BRA" .Or. (!lIntTaf .And. !lMiddleware)
									lRescDis  := MsgYesNo( OemToAnsi( STR0124 ) , OemToAnsi( STR0123) ) //Rescisão Complementar. Deseja calcular a complementar por dissídio?
									cOpcCompl := If( lRescDis, "2", "1" )
								Else
									fAlertJob()
									If (cOpcCompl := OpcRecCom()) == "0"
										lCancelCalc := .F.
										lRet := .T.
										Break
									EndIf
									lRescDis  := (cOpcCompl == "2")
								EndIf
							Else
								If GetGlbVars("aRetAuto", @aRetAuto)
									lRescDis := aRetAuto[2]
									If Len(aRetAuto) < 3
										cOpcCompl := If( lRescDis, "2", "1" )
									Else
										cOpcCompl := aRetAuto[3]
									EndIf
								Else
									lRescDis := .F.
									cOpcCompl := If( lRescDis, "2", "1" )
								EndIf
							EndIf
							aPdResc		:= {}
							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³ Matriz Verbas da Rescisao ja Paga para Calculo de Compl.   ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							fCarCompl( SRA->( RA_FILIAL + RA_MAT ) , @aPdResc, aSrgRecnos )
						Else
							Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0024),1,0 ) //"Excedeu o Número Máximo de Rescisões Complementares para Cálculo na Data Base"
							lRet := .F.
							Break
						EndIf
					Else
						fTemIdResc( SRA->( RA_FILIAL + RA_MAT ), aSrgRecnos )
						DbSelectArea("RCH")
						DbSetOrder(1)
						If DbSeek(xFilial("RCH",SRA->RA_FILIAL)+SRG->RG_PROCES+SRG->RG_PERIODO+SRG->RG_SEMANA+SRG->RG_ROTEIR)
							If !Empty(RCH->RCH_DTINTE)
								Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0122), 1, 0 ) //"Periodo referente a data de demissão já foi integrado."
								lRet := .F.
								Break
							EndIf
						EndIf

						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Apresenta Tela para Escolha da Opcoes de Recalculo ou   com³
						³ plementar quando Calculo no Mesmo Mes/Ano da Demissa		 ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						If IsBlind() .And. GetGlbVars("aRetAuto", @aRetAuto)
							nRecRes	:= aRetAuto[1]
							If nRecRes == 2
								lRescDis := aRetAuto[2]
							EndIf
						Else
							nRecRes 	:= OpcRecRes()
						EndIf

						If ( lRecRes := (  nRecRes == 1 ) )			//Recalculo de Rescisao
							cCompl := "N"
						ElseIf ( lRecRes := (  nRecRes == 2 ) )						//Rescisao Complementar
							cCompl := "S"
						ElseIf ( nRecRes == 3 )											//Rescisao com Reingresso - MEX
							If cPaisLoc $ "BRA|DOM|MEX" .And. Empty(SRA->RA_FECREI)
								Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0025),1,0 )//"Não há data de reingresso informada."
					        	lRet := .F.
								Break
							Else
								cCompl  := "N"
								lReingr := .T.
								/*
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³ Se for uma nova rescisão, e tem a data de reingresso		 ³
								³ retorna processo que o funcionário está no SRA, atual		 ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
								cProcesso := SRA->RA_PROCES
								cPeriodo  := ""
								cNumPag	  := ""
							EndIf
				        Else
				        	lCancelCalc := .F.
							lRet := .T.
							Break
						EndIf
					EndIf
			  	EndIf
			EndIf
		EndIf

		If (lIntTaf .Or. lMiddleware) .And. cPaisLoc == "BRA" .And. cCompl == 'S' .And. !lRobo
			fIncRes(SRA->RA_FILIAL, SRG->RG_TIPORES, @aInfoTpRes)
			If Len(aInfoTpRes) > 0 .And. Empty(aInfoTpRes[16])
				Help(,, OemToAnsi(STR0020),, + CRLF + OemToAnsi(STR0143) + " " + SRA->RA_CATEFD + ", " + OemToAnsi(STR0294), 1, 0,,,,,, { + CRLF + OemToAnsi(STR0295)})//"Atencao" ## "Para func. Cat.eSocial contido em:" ### " a coluna Mot. eSocial. (tabela S043) deverá estar preenchida." ### "Altere a tabela S043 e preencha o campo Mot. eSocial para o tipo de rescisão."
				lRet := .F.
			EndIf
		EndIf

		If lRecRes
			If cPaisLoc $ "BRA*EQU"
				If  SRG->RG_SABDOM == "1"
					lSabDom := .T.
				Else
					lSabDom := .F.
				EndIf
			EndIf
		Else
			lSabDom := SuperGetMv("MV_SABDOM",NIl,"N")=="S"
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Avisa ao usuario, porem permite continuar no calculo         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !IsBlind() .And. lRescDis .And. !fBuscaRHH(SRA->RA_FILIAL, SRA->RA_MAT,  cMesAnoRef)
			If !GetNewPar("MV_RHTAF")
				If !fBusSRKDis()
					MsgInfo(+ CRLF + OemToAnsi(STR0262) + CRLF + CRLF + OemToAnsi(STR0302)) // "Foi selecionada Rescisão Complementar por Dissídio, mas não foi encontrado cálculo de dissídio, caso seja realizada a geração do evento S-1200 posteriormente, esta rescisão não será considerada." ### "Caso já tenha efetuado calculo do Dissidio, verifique o compartilhamento de Empresa / Filial da tabela RHH através do Configurador."
				EndIf					
			EndIf

			If lRet .And. GetNewPar("MV_RHTAF") .And. GetNewPar("MV_FASESOC") == '2'
				If MsgYesNo("Não foi encontrado cálculo de dissídio no período aberto! Deseja verificar se há valores de dissídio não quitados (SRK) em períodos anteriores?", "Rescisão Complementar por Dissídio.")
					If !fBusSRKDis()
						Help( ,, OemToAnsi(STR0020),, + CRLF + OemToAnsi(STR0263) + CRLF + CRLF + OemToAnsi(STR0302), 1, 0) // "Atenção" ## "Foi selecionada Rescisão Complementar por Dissídio, mas não foi encontrado cálculo de dissídio, a rescisão não será gerada." ### "Caso já tenha efetuado calculo do Dissidio, verifique o compartilhamento de Empresa / Filial da tabela RHH através do Configurador."
						lRet := .F.					
					EndIf
				Else
					Help( ,, OemToAnsi(STR0020),, + CRLF + OemToAnsi(STR0263) + CRLF + CRLF + OemToAnsi(STR0302), 1, 0) // "Atenção" ## "Foi selecionada Rescisão Complementar por Dissídio, mas não foi encontrado cálculo de dissídio, a rescisão não será gerada." ### "Caso já tenha efetuado calculo do Dissidio, verifique o compartilhamento de Empresa / Filial da tabela RHH através do Configurador."
					lRet := .F.
				EndIf
			EndIf
		Endif

		If SRA->RA_SITFOLH == "A"
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0028),1,0 ) //Funcionário está com situação de afastado no cadastro.
		EndIf

		If SRA->RA_SITFOLH == "F"
		  	Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0029),1,0 )  //Funcionário está com situação de férias no cadastro.
		EndIf

		If lRecRes .AND. nRecRes == 1 .AND. SRG->RG_EFETIVA == "S" .And. fExisTitRe()
			If !lCtrlTit
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0218), 1, 0 ) //"Atençãoo, Cáculo de Rescisão cancelado pelo usuário."
			ElseIf lCtrlTit .And. Len( aLogErros ) > 0
					// "Atenção"###"Ação cancelada - título(s) encontrado(s) sobre essa rescisão."###"Consulte os títulos listados no log."
					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0286), 1, 0, NIL, NIL, NIL, NIL, NIL, {OemToAnsi(STR0288)})
					// Imprime Log
					fCtrTitLg()
			EndIf
			lRet := .F.
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega informacoes do salario do funcionario              ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		fSalario(@Salario,@SalHora,@SalDia,@SalMes,"A",AnoMes(dDataDe),cNumPag)
	ElseIf nOperation == MODEL_OPERATION_DELETE
		If Empty(cPeriodo)
			If fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, fGetCalcRot('4') )
				cMesAnoRef  := aPerAtual[1,5] + aPerAtual[1,4]
				dDataDe  := aPerAtual[1,6]
				dDataAte := aPerAtual[1,7]
				cPeriodo := aPerAtual[1,1]
				cRot	 := aPerAtual[1,3]
				cNumPag	 := aPerAtual[1,2]
				cSemana	 := aPerAtual[1,2]
				cProcesso:= aPerAtual[1,8]

				lRetPer := fCarPeriodo( cPeriodo , cRot , @aPeriodo , @lUltSemana , @nPosSem)

				If !lRetPer
					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0153), 1, 0)  // "Atenção"###"A configuração dos períodos está incorreta ou não existe período válido para o roteiro de rescisão. Verifique o cadastro de períodos."
					lRet := .F.
					Break
				EndIf

				NORMAL := aPeriodo[nPosSem,24] * SRA->RA_HRSDIA
				DESCANSO := aPeriodo[nPosSem,07] * SRA->RA_HRSDIA
			Else
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0021) + SRA->RA_PROCES + OemToAnsi(STR0022) + fGetCalcRot('4'), 1, 0)  // "Atenção"###"Não existe periodo aberto para o processo: ### roteiro:###"
				lRet := .F.
				Break
			EndIf
		EndIf
		//Verifica se rescisão foi calculada em período anterior
		If SRA->RA_SITFOLH == "D" .And. AnoMes(SRG->RG_DTGERAR) < cPeriodo .And. AnoMes(SRG->RG_DATADEM) < cPeriodo .AND. SRG->RG_EFETIVA <> 'N'
			Help(" ",1,"GPM040MANT")
			lRet := .F.
			Break
		EndIf

		nRegSrg := SRG->( Recno() )
		While SRG->(!Eof() .and. RG_FILIAL + RG_MAT == xFilial("SRG",SRA->RA_FILIAL) + SRA->RA_MAT )

			If MesAno( SRG->RG_DTGERAR ) == cMesAnoRef
				nMaxCompl++
			EndIf
			nPos	:= aScan( aSrgRecnos , { |x| MesAno( x[2] ) == MesAno( SRG->RG_DTGERAR ) } )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Se Teve Rescisao Complementar no Mesmo Mes da Demissao consi³
			³sidera apenas a Ultima										 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If MesAno( SRG->RG_DTGERAR ) == MesAno( SRG->RG_DATADEM ) .and. nPos > 0.00
				aSrgRecnos[ nPos , 01 ] := nRegSrg
				aSrgRecnos[ nPos , 02 ] := SRG->RG_DTGERAR
				aSrgRecnos[ nPos , 03 ] := SRG->RG_DATADEM
			Else
				SRG->( aAdd( aSrgRecnos , { nRegSrg , RG_DTGERAR , RG_DATADEM } ) )
			EndIf

			SRG->(DbSkip())
		EndDo
		SRG->(DbGoTo(nRegSrg))

		//Verifica se rescisão é a última calculada
		If aScan( aSrgRecnos, { |x| x[2] > SRG->RG_DTGERAR } ) > 0
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0209), 1, 0 ) //"A exclusão de Rescisões deverá ser feita do fim (última calculada) para o início (primeira calculada)"
			lRet := .F.
		EndIf

		If lRet .AND. SRG->RG_EFETIVA == "S" .And. fExisTitRe()
			If !lCtrlTit
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0218), 1, 0 ) //"Atençãoo, Cáculo de Rescisão cancelado pelo usuário."
			ElseIf lCtrlTit .And. Len( aLogErros ) > 0
					// "Atenção"###"Ação cancelada - título(s) encontrado(s) sobre essa rescisão."###"Consulte os títulos listados no log."
					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0286), 1, 0, NIL, NIL, NIL, NIL, NIL, {OemToAnsi(STR0288)})
					// Imprime Log
					fCtrTitLg()
			EndIf
			lRet := .F.
		EndIf

	EndIf

End Sequence

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fInitModel   ³ Autor ³ Leandro Drumond       ³ Data ³ 13/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Carrega enchoice apos ativacao do modelo.                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fInitModel(oModel,nOperation)                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fInitModel(oModel,nOperation)
Local cTipoSind	:= ""
Local lConfCompl:= SRR->(ColumnPos("RR_VALORI")) > 0
Local oViewAux
Local oViewStruct
Local oViewSRG
Local oStruSRG

DEFAULT lGestPubl := IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP

cIdHistMed := ""

If lAtuBrowse .And. nOperation <> MODEL_OPERATION_VIEW
	oViewSRG := FWViewActive()
	oStruSRG := oViewSRG:GetViewStruct("GPEM040_MSRG")
	If cPaisLoc == "BRA"
		oStruSRG:RemoveField('RG_RESCDIS')
		oStruSRG:RemoveField('RG_DSCRESC')
	EndIf
EndIf

If lAtuBrowse .and. lConfCompl .and. !Empty(SRA->RA_DEMISSA)
	If ( nOperation <> MODEL_OPERATION_INSERT .and. ( iif(cPaisloc=="BRA" .And. SRG->RG_RESCDIS == "0",.T.,.F.)  .or. AnoMes(SRG->RG_DATADEM) == AnoMes(SRG->RG_DTGERAR) ) ) .or. ( nOperation == MODEL_OPERATION_INSERT .and. (cCompl <> "S" .or. !lProxMes) )
		oViewAux := FWViewActive()
		oViewStruct := oViewAux:GetViewStruct("GPEM040_MGET")
		oViewStruct:RemoveField("RR_VALORI")
	EndIf
EndIf

If nOperation == MODEL_OPERATION_INSERT

	oModel:LoadValue("GPEM040_MSRG","RG_SALMES",SalMes)
	oModel:LoadValue("GPEM040_MSRG","RG_SALDIA",SalDia)
	oModel:LoadValue("GPEM040_MSRG","RG_SALHORA",SalHora)
	If lTCFA040
		oModel:LoadValue("GPEM040_MSRG","RG_TIPORES",cTipResPortal)
		GP40VldTpRes("S043",cTipResPortal)
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega informacoes do periodo				             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	oModel:LoadValue("GPEM040_MSRG","RG_PROCES",cProcesso)
	oModel:LoadValue("GPEM040_MSRG","RG_PERIODO",cPeriodo)
	oModel:LoadValue("GPEM040_MSRG","RG_SEMANA",cNumPag)
	oModel:LoadValue("GPEM040_MSRG","RG_ROTEIR",cRot)
	oModel:LoadValue("GPEM040_MSRG","RG_NORMAL",NORMAL)
	oModel:LoadValue("GPEM040_MSRG","RG_DESCANS",DESCANSO)
	If cPaisLoc == "BRA"
		oModel:LoadValue("GPEM040_MSRG","RG_JTCUMPR","1")
		oModel:LoadValue("GPEM040_MSRG","RG_RESCDIS", If( cCompl != "S", "0", cOpcCompl) )
	EndIf

	If cPaisLoc $ "BRA*EQU"
		oModel:LoadValue("GPEM040_MSRG","RG_SABDOM",If(lSabDom,"1","2"))
	EndIf

	If cModFol == "2"
		If(cPaisLoc $ "ARG*CHI*COL*COS*DOM*MEX")
			oModel:LoadValue("GPEM040_MSRG","RG_RESCOMP",cResComp)
		EndIf
	EndIf

	If SRG->( ColumnPos( "RG_PDRESC")) > 0 .And. RCE->(ColumnPos( "RCE_PDRESC")) > 0
		If lRescDis
			cTipoSind := Posicione("RCE",1,xFilial("RCE",SRA->RA_FILIAL)+SRA->RA_SINDICA,"RCE_PDRESC")
		EndIf
		oModel:LoadValue("GPEM040_MSRG","RG_PDRESC",IIf(Empty(cTipoSind),"1",cTipoSind))
	EndIf

	If cCompl == "S" .or. lRecRes
		SRG->(DbGoTo(nRegSrg))

		If cPaisLoc $ "BRA*EQU"
			oModel:LoadValue("GPEM040_MSRG","RG_SABDOM",SRG->RG_SABDOM)
		EndIf

		oModel:LoadValue("GPEM040_MSRG","RG_TIPORES",SRG->RG_TIPORES)
		oModel:LoadValue("GPEM040_MSRG","RG_MEDATU",SRG->RG_MEDATU)
		oModel:LoadValue("GPEM040_MSRG","RG_DATADEM",SRG->RG_DATADEM)
		If cCompl == "S"
			dDataDem1 := SRG->RG_DATADEM
			dDtProje  := SRG->RG_DTPROAV
			nDiasAV	  := SRG->RG_DAVISO
			nDiasCum  := SRG->RG_DAVCUM
			nDiaInde  := SRG->RG_DAVIND
		EndIf

		GP40VldTpRes('S043',SRG->RG_TIPORES)

		If cCompl == "S"
			oModel:LoadValue("GPEM040_MSRG","RG_DTAVISO",SRG->RG_DTAVISO)
		Else
			oModel:SetValue("GPEM040_MSRG","RG_DTAVISO",SRG->RG_DTAVISO)
		EndIf

		oModel:LoadValue("GPEM040_MSRG","RG_PERIODO",SRG->RG_PERIODO)
		oModel:LoadValue("GPEM040_MSRG","RG_SEMANA",SRG->RG_SEMANA)
		oModel:LoadValue("GPEM040_MSRG","RG_NORMAL",SRG->RG_NORMAL)
		oModel:LoadValue("GPEM040_MSRG","RG_DESCANS",SRG->RG_DESCANS)
		If cCompl == "S"
			oModel:LoadValue("GPEM040_MSRG","RG_SALMES",SRG->RG_SALMES)
			oModel:LoadValue("GPEM040_MSRG","RG_SALDIA",SRG->RG_SALDIA)
			oModel:LoadValue("GPEM040_MSRG","RG_SALHORA",SRG->RG_SALHORA)
			oModel:LoadValue("GPEM040_MSRG","RG_DFERVEN",SRG->RG_DFERVEN)
			oModel:LoadValue("GPEM040_MSRG","RG_DFERPRO",SRG->RG_DFERPRO)
			If(cPaisLoc == 'BRA')
				oModel:LoadValue("GPEM040_MSRG","RG_DFERAVI",SRG->RG_DFERAVI)
				oModel:LoadValue("GPEM040_MSRG","RG_OBITO",SRG->RG_OBITO)
			EndIf
		EndIf
		nDiasAv	:= SRG->RG_DAVISO
		oModel:LoadValue("GPEM040_MSRG","RG_DAVISO",nDiasAv)

		If ( cPaisLoc == 'BRA' )
			If SRG->(ColumnPos( "RG_DAVCUM")) > 0 .And. SRG->(ColumnPos( "RG_DAVIND")) > 0
				nDiasCum	:= SRG->RG_DAVCUM
				nDiaInde 	:= SRG->RG_DAVIND
				oModel:LoadValue("GPEM040_MSRG","RG_DAVCUM",SRG->RG_DAVCUM)
				oModel:LoadValue("GPEM040_MSRG","RG_DAVIND",SRG->RG_DAVIND)
			Endif
		EndIf

		If lIndAv
		  oModel:LoadValue("GPEM040_MSRG","RG_INDAV",SRG->RG_INDAV)
		EndIf
	ElseIf cPaisLoc == "BRA"
		dbSelectArea("RFY")
		RFY->( dbSetOrder(1) )
		If RFY->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT ) )
			While RFY->( !EOF() ) .and. SRA->RA_FILIAL+SRA->RA_MAT == RFY->RFY_FILIAL+RFY->RFY_MAT
				If Empty(RFY->RFY_DTCAP) .and. Empty(RFY->RFY_TPCAP)
			    	cRfyTpAv	:= RFY->RFY_TPAVIS
			    	oModel:SetValue("GPEM040_MSRG","RG_DATADEM",RFY->RFY_DTPJAV)
			    	If !Empty(RFY->RFY_DTASVP)
				   		If !Empty(RFY->RFY_TPRESC)
				   			fIncRes(SRA->RA_FILIAL,RFY->RFY_TPRESC,@aIncRes,@nPercFgts,@cRescrais,@cAfasfgts,@Cod_Am)
				   			If RFY->(ColumnPos( "RFY_DAVCUM")) > 0
				   				nDiasCum 	:= RFY->RFY_DAVCUM
								nDiaInde 	:= (RFY->RFY_DIASAV-RFY->RFY_DAVCUM)
							Endif
							nDiasAv 	:= RFY->RFY_DIASAV
				   			lTemRFY := .T.
				   			GP40VldTpRes('S043',RFY->RFY_TPRESC)

					   		If !Empty(aIncRes) .And. !(aIncRes[2] $ "I/A")
					   			If ( cPaisLoc == 'BRA' )
						   			If SRG->(ColumnPos( "RG_DAVCUM")) > 0 .And. SRG->(ColumnPos( "RG_DAVIND")) > 0
						   				oModel:LoadValue("GPEM040_MSRG","RG_DAVIND",RFY->RFY_DTASVP-RFY->RFY_DAVCUM)
						   				oModel:LoadValue("GPEM040_MSRG","RG_DAVCUM",RFY->RFY_DAVCUM)
						   			Endif
					   			EndIf
					   			oModel:LoadValue("GPEM040_MSRG","RG_DTAVISO",RFY->RFY_DTASVP)
					   		EndIf
					   	EndIf
				   		lTemRFY := .T.
			   		EndIf
			    	If !Empty(RFY->RFY_TPRESC)
			    		oModel:SetValue("GPEM040_MSRG","RG_TIPORES",RFY->RFY_TPRESC)
			    	Else
			    		oModel:LoadValue("GPEM040_MSRG","RG_DESCTPR","")
			    	EndIf
		    		oModel:LoadValue("GPEM040_MSRG","RG_DAVISO"	,RFY->RFY_DIASAV)

		    		If ( cPaisLoc == 'BRA' )
			    		If SRG->(ColumnPos( "RG_DAVCUM")) > 0 .ANd. SRG->(ColumnPos( "RG_DAVIND")) > 0
			    			oModel:LoadValue("GPEM040_MSRG","RG_DAVCUM"	,RFY->RFY_DAVCUM)
							oModel:LoadValue("GPEM040_MSRG","RG_DAVIND"	,RFY->RFY_DIASAV-RFY->RFY_DAVCUM)
						Endif
					EndIf

					oModel:LoadValue("GPEM040_MSRG","RG_DTAVISO"	,RFY->RFY_DTASVP)
					oModel:LoadValue("GPEM040_MSRG","RG_DATADEM"	,RFY->RFY_DTPJAV)
		    		nDiasAv 	:= RFY->RFY_DIASAV
					If RFY->(ColumnPos( "RFY_DAVCUM")) > 0
						//Atribui às variáveis Private os valores digitados no cadastro do Aviso Prévio.
						nDiasCum 	:= RFY->RFY_DAVCUM
						nDiaInde 	:= (RFY->RFY_DIASAV-RFY->RFY_DAVCUM)
						dDataDem1	:= RFY->RFY_DTPJAV
						dDtProje	:= CtoD("")
						If !Empty(RFY->RFY_DTASVP)
							dDtProje    := RFY->RFY_DTASVP + nDiasAv
						EndIf
					Endif

					//Chama novamente o cálculo das férias.
					//Nesse ponto, o cadastro de Aviso Prévio existe, portanto, recalcula as férias, de acordo com os valores digitados pelo usuário.
					If !Empty(dDataDem1)
						//Calcula dias de ferias
						If lGestPubl .AND. cPaisLoc == "BRA" .AND. SRA->RA_REGIME == "2" .AND. FindFunction("fdFerResFP")
							fdFerResFP(.T.,dDataDem1)
						Else
							aPerFerias := {}
							fdFerRes(.T.,dDataDem1)
						EndIf

						oModel:LoadValue("GPEM040_MSRG","RG_DFERVEN", If(!lMetFalv, If(!lTempoParc, nDferven - nFaltasv, 0), nDferven / 2))
						oModel:LoadValue("GPEM040_MSRG","RG_DFERPRO", If(!lMetFalp, If(!lTempoPArc, nDferave - nFaltasp, 0), nDferave / 2))
						If (SRA->RA_TPCONTR == "3" .Or. SRA->RA_CATEFD $ '107/108') .and. nDferInd > 0
							nDferInd := 2.5	// Intermitente sempre será 1 avo
						EndIf
						oModel:LoadValue("GPEM040_MSRG","RG_DFERAVI",nDferInd)
					EndIf

					oModel:LoadValue("GPEM040_MSRG","RG_DTPROAV" , dDtProje)
		    		lTemRFY := .T.
			    	Exit
				EndIf
				RFY->( dbSkip() )
			EndDo
		ElseIf Empty(M->RG_TIPORES)
			If lTCFA040
				oModel:LoadValue("GPEM040_MSRG","RG_DESCTPR",fDescRCC("S043",cTipResPortal,1,2,3,30))
			Else
				oModel:LoadValue("GPEM040_MSRG","RG_DESCTPR","")
		EndIf
	EndIf
	EndIf
ElseIf nOperation <> MODEL_OPERATION_DELETE
	cDesc:= fDescRCC("S043",SRG->RG_TIPORES,1,2,3,30)
	oModel:LoadValue("GPEM040_MSRG","RG_DESCTPR",cDesc)
EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fChkDtDem    ³ Autor ³ Leandro Drumond       ³ Data ³ 13/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Checar a Data de Demissao do Funcionario.                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno  ³Logico   -> .T. para Data Valida e .F. para Data Nao Valida    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fChkDtDem( dDtDemAux 	,;	// Data de Demissao
					lMsg 		,;	// Se mostra mensagem de erro ou nao
					dRch_DtIni	,;	// Data de Inicio do Periodo
					dRch_DtFim	,;	// Data Final do Periodo
					lModDataDem ,;	// Nao Usado
					aLogErros	,;	// Array com o Log de Erros
					lResPos		;	// Nao Usado
				  )

Local aBuscaAf	:= {}
Local aTransf	:= {}
Local aPerAberto:= {}
Local aPerAtual	:= {}
Local aVerbas	:= {}

Local cMsgData	:= ""
Local cMsgVerba	:= ""

Local dDtPesq1	:= CtoD("//")
Local dDtPesq2	:= CtoD("//")
Local dDtInteg	:= CtoD("//")

Local lRet		:= .T.
Local lOrigem	:= .T.
Local lRetPer	:= .T.

Local nX		:= 0
Local IsMILEFunc := .F.

Local lUsaGpe 	:= .T.

If FunName() == "GPEA010"
	IsMILEFunc := IsInCallStack("FWMILEIMPORT")
EndIf

If Type("lUltSemana") == "U"
	Private lUltSemana := .F.
EndIf

If Type("nPosSem") == "U"
	Private nPosSem := 0
EndIf

If Type("Salario") == "U"
	Private Salario := 0
EndIf

If Type("SalHora") == "U"
	Private SalHora := 0
EndIf

If Type("SalDia") == "U"
	Private SalDia := 0
EndIf

If Type("SalMes") == "U"
	Private SalMes := 0
EndIf

DEFAULT dDtDemAux 	:= &(ReadVar())
DEFAULT aLogErros	:= {}

/*Quando essa função for chamada a partir da Importação Logix
deve sempre retornar verdadeiro(.T.)*/
If (IsInCallStack("RHIMP01") .Or. IsInCallStack("GPEA265") .Or. IsInCallStack("RHIMPGEN") .Or. IsInCallStack("U_RHIMP08JOB") .Or. IsMILEFunc .Or. (FunName() == "GPEM040" .And. ProcName(3) == "SETRULES") )
	Return(.T.)
EndIf

dDataDem := dDataDem1 := dDtDemAux

lColetiva	:= If ( Type("LCOLETIVA")== "U" ,.F., lColetiva)
cCompl		:= If ( Type("CCOMPL")= "U" .Or. cCompl = Nil, "N", cCompl)
lMsg		:= If( lMsg == NIL .or. ValType( lMsg ) != "L"  , .T. , lMsg )

If !lColetiva .and. cPaisLoc $ "BRA*EQU"
	If FunName() $ "GPEA010|GPEA011"
		lSabDom := SuperGetMv("MV_SABDOM",NIl,"N")=="S"
	Else
		lSabDom := M->RG_SABDOM == "1"
	EndIf
EndIf

Begin Sequence


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Data de demissao nao foi preenchida ou invalida³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Empty( dDtDemAux )
		lRet := .F.
		If lMsg
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0043), 1, 0 ) //"Data em branco ou Invalida"
		Else
		  	aAdd( aLogErros, STR0043 )
		EndIf
		Break
	EndIf

/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Demissao nao Pode ser Inferior a Admissao                  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If dDtDemAux < SRA->RA_ADMISSA
		lRet := .F.
		If lMsg
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0044), 1, 0 ) //Data de Demissao nao Pode Ser Inferior a Admissao
		Else
		  	aAdd( aLogErros, STR0044 )
		EndIf
		Break
	EndIf

	//-- Quando o cadastro de funcionário for alterado por outro módulo verificar se o GPE está sendo utilizado
	If (FunName() $ "GPEA010/TRMA100"  .AND. cModulo != "GPE") .Or. (nModulo == 7 .and. IsincallStack("GPEI010"))
		dbSelectArea("SRD")
		If(! dbSeek(xFilial("SRD"))) .AND. EOF()
			dbSelectArea("SRC")
			If( ! dbSeek(xFilial("SRC"))) .AND. EOF()
				lUsaGpe := .F.
			EndIf
		EndIf
	EndIf

	If lUsaGpe
		If fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, fGetCalcRot('4') )
			dRch_DtIni 	:= dDataDe  := aPerAtual[1,6]
			dRch_DtFim 	:= dDataAte := aPerAtual[1,7]
			cPeriodo 	:= aPerAtual[1,1]
			cRot	 	:= aPerAtual[1,3]
			cNumPag	 	:= aPerAtual[1,2]
			cProcesso	:= aPerAtual[1,8]
			dDtInteg	:= aPerAtual[1,10]
		ElseIf !(SRA->RA_CATFUNC $ "A|E|P") // Funcionários sem vínculo empregatício não necessita verificar o roteiro de rescisão.
			lRet := .F.

			If lMsg
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0046), 1, 0 )
			EndIf

			If !lRet
				Break
			EndIf
		EndIf
	EndIf

    //Nao permite rescisao com data anterior ao periodo atual
    If lUsaGpe .AND. !Empty(dRch_DtIni) .And. !Empty(dRch_DtFim)  .and. cCompl <> "S"
		If ( dDtDemAux < dRch_DtIni )
			cMsgData := STR0045 // "Data de Demissao menor que a Data Inicial do Periodo Atual"
			lRet := .F.
		ElseIf ( dDtDemAux > dRch_DtFim )
			fRetPerComp(SubStr(Dtos(dDataDem),5,2), SubStr(Dtos(dDataDem),1,4),, SRA->RA_PROCES,fGetCalcRot("4"),@aPerAberto )

			If Empty(aPerAberto)
				cMsgData := STR0046 //"Não existe período de cálculo aberto para a competência"
				lRet := .F.
			Else
				dDataDe 	:= aPerAberto[1,5]
				dDataAte 	:= aPerAberto[1,6]
				cPeriodo	:= aPerAberto[1,1]
				cNumPag		:= aPerAberto[1,2]
				dDtInteg	:= aPerAberto[1,11]
			EndIf
		EndIf

		If !(FunName() $ "GPEA010|GPEA011")
			aPeriodo 	:= {}

			If !(lRetPer := fCarPeriodo( cPeriodo , cRot , @aPeriodo , @lUltSemana , @nPosSem))
				If cSemana <> "01"
					cSemana := "01"
					lRetPer := fCarPeriodo( cPeriodo , cRot , @aPeriodo , @lUltSemana , @nPosSem)
				EndIf
			EndIf

			If !lRetPer
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0153), 1, 0)  // "Atenção"###"A configuração dos períodos está incorreta ou não existe período válido para o roteiro de rescisão. Verifique o cadastro de períodos."
				lRet := .F.
				Break
			EndIf

			//Altera periodo e semana na tela
			M->RG_PERIODO := cPeriodo
			M->RG_SEMANA  := cNumPag
			M->RG_NORMAL  := NORMAL := aPeriodo[nPosSem,24] * SRA->RA_HRSDIA
			M->RG_DESCANS := DESCANSO := aPeriodo[nPosSem,07] * SRA->RA_HRSDIA

			fSalario(@Salario,@SalHora,@SalDia,@SalMes,"A",AnoMes(dDataDe),cNumPag)

			M->RG_SALMES  := SalMes
			M->RG_SALDIA  := SalDia
			M->RG_SALHORA := SalHora

			//Ponto de Entrada para alteração do cabeçalho da rescisão - Tv Tribuna
			If ExistBlock( "GPESALAR" )
				ExecBlock("GPESALAR",.F.,.F.)
		EndIf

		EndIf

		If lMsg .and. !Empty( cMsgData )
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(cMsgData), 1, 0 )
		EndIf

		If !lRet
			Break
		EndIf
	EndIf

	If !Empty(dDtInteg)
		lRet := .F.
		If lMsg
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0122), 1, 0 ) //"Periodo referente a data de demissão já foi integrado."
		Else
		  	aAdd( aLogErros, STR0122 )
		EndIf
		Break
	EndIf

	If lUsaGpe .And. !( SRA->RA_CATFUNC $ "A|E|P" ) .And. !fChkInteg( lMsg )
		lRet := .F.
		Break
	EndIf

	//Validação deve ser excluída após 16/05/2018, devido entrada em vigor do eSocial, quando as verbas passarão a ser obrigatórias//
	If cPaisLoc == "BRA" .And. !IsBlind() .And. Date() < cToD("16/05/2018") .And. FunName() == "GPEM040" .And. lUsaGpe .And. FindFunction("fVldId") .And. !fVldId( aCodFol, @aVerbas )
		cMsgVerba := "Disponibilizados os ID's de Cálculo listados abaixo, que serão obrigatórios a partir de 16/05/2018. Para mais informações consulte http://tdn.totvs.com/pages/viewpage.action?pageId=353275183" + CRLF
		For nX := 1 To Len(aVerbas)
			cMsgVerba += aVerbas[nX] + CRLF
		Next nX
		Aviso( OemToAnsi(STR0020), OemToAnsi(cMsgVerba) )
	EndIf
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se o Funcionario esta Afastado                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	dDtPesq1	:= SRA->RA_ADMISSA
	dDtPesq2	:= dDtDemAux
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega os Afastamentos do Funcionario                     ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If cCompl <> "S" .and. fChkAfas(SRA->RA_FILIAL,SRA->RA_MAT, dDtPesq2, @dDtPesq2,,,dDtPesq2,YearSum(dDtPesq2, 1))
		fRetAfas(dDtPesq1, YearSum(dDtPesq2, 1),,,,, @aBuscaAf)
	EndIf

	If !Empty( aBuscaAf )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ordena o Array pelo Inicio do Afastamento                  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aSort( aBuscaAf,,,{ |x,y| x[3] < y[3] } )

		For nX := 1 To Len( aBuscaAf )

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Data de Demissao nao Pode ser Inferior ao Inicio do Afast. ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If dDtDemAux <= aBuscaAf[ nx , 3 ]
				lRet := .F.
				If lMsg
					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0047), 1, 0 ) //"Existe Afastamento Posterior à Data Informada"
				Else
					aAdd( aLogErros, STR0047 )
				EndIf
				Break
			EndIf

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Demissao nao pode ser Calculada com Funcionario Afastado   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If (cPaisLoc != "BRA" .Or. !(aIncRes[16] $ "9/A")) .And. (Empty( aBuscaAf[ nX , 4 ] ) .Or. aBuscaAf[ nX , 4 ] >= iif( cPaisLoc != "BOL" ,dDtDemAux,dDtDemAux+1))
				lRet := .F.
				If lMsg
					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0048), 1, 0 )	//"Demissao nao Pode ser Calculada com Funcionario Afastado"
				Else
					aAdd( aLogErros, STR0048 )
				EndIf
				Break
			EndIf
		Next nX
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se o Funcionario tem Transferencia                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If cCompl <> "S" .and. fTransf(@aTransf,,,,,,,lOrigem)
		For nX := 1 To Len( aTransf )
			If dDtDemAux < aTransf[ nX , 7 ]
				lRet := .F.
				If lMsg
					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0049), 1, 0 )	//"Existe Transferência Posterior à Data Informada"
				Else
					aAdd( aLogErros, STR0049 )
				EndIf
				Break
			EndIf
		Next nX
	EndIf

	dDataDem := dDataDem1 := dDtDemAux

	fDtSabDom()

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Tempo de Casa do Funcionario                               ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	nAnosCasa := fAnosCasa( dDataDem , SRA->RA_ADMISSA )

	If !(cCompl == "S")
		M->RG_DTGERAR := dDtDemAux
	EndIf

End Sequence

Return( lRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fFiltrApd    ³ Autor ³ Microsiga             ³ Data ³ 06/07/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Filtra aPd deixando somente as tarefas variaveis, Dsr e Hrs    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso	     ³Generico													     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fFiltrApd(	dDtTarDe	,;	// Data da Tarefa De
					dDtTarAte	 ;	// Data da Tarefa Ate
				  )

Local aSvCols := aCols

Local cCodVerba

Local nCnt
Local nPos1
Local nPosVerba
Local nPosValor

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Limpar o conteudo do aCols	                               ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aCols := {}

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ As variaveis aTarefas, aSalProf estao sendo carregadas no    ³
³ roteiro de Salario Incorporado 							   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If !Empty(dDtTarDe) .And. SRA->RA_CATFUNC $ "I*J*T" .And. Type("aTarefas") == "A"

	nPosVerba := GdFieldPos( "RR_PD", aSrrHeader )
	nPosValor := GdFieldPos( "RR_VALOR", aSrrHeader )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Adiciona em aCols as tarefas variaveis - RO_TIPO == "2" 	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	For nCnt := 1 To Len(aSvCols)

		nPos1 :=  Ascan( aTarefas, { |X| X[1] == aSvCols[nCnt, nPosVerba] .And. X[9] # "1" } )
		If nPos1 > 0
			AAdd( aCols, aSvCols[nCnt] )
		EndIf

	Next nCnt

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Se existir tarefa variavel, busca DSR e Hrs Atividade 	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If Len( aCols ) > 0

		If SRA->RA_CATFUNC $ "I*J" .And. Type( "aSalProf" ) == "A"
			cCodVerba := FGetCodFol( "0033", .F. )		// 033 - DSR Horista
			nPos1 := Ascan( aSvCols, { |x| x[nPosVerba] == cCodVerba } )
			If nPos1 > 0 .And. aSalProf[2,2] > 0  			// DSR sobre tarefa variavel
				aSvCols[nPos1, nPosValor] := aSalProf[2,2]
				aAdd( aCols, aSvCols[nPos1] )
			EndIf
			cCodVerba := FGetCodFol( "0317", .F. )		// 317 - Hora Atividade (Calculo de Professores)
			nPos1 := Ascan( aSvCols, { |x| x[nPosVerba] == cCodVerba } )
			If nPos1 > 0 .And. aSalProf[2,3] > 0  			// Hrs Atividade sobre tarefa variavel
				aSvCols[nPos1, nPosValor] := aSalProf[2,3]
				aAdd( aCols, aSvCols[nPos1] )
			EndIf

		ElseIf SRA->RA_CATFUNC == "T"
			cCodVerba := FGetCodFol( "0033", .F. )		// 033 - DSR Horista
			nPos1 := Ascan( aSvCols, { |x| x[nPosVerba] == cCodVerba } )
			If nPos1 > 0  						   			// DSR dos Tarefeiros
				aAdd( aCols, aSvCols[nPos1] )
			EndIf

		EndIf
	EndIf
EndIf

Return( Nil )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fdFerRes  ³ Autor ³ Equipe RH             ³ Data ³25/07/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Busca Dias de Ferias Vencidas e Proporcionais               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fdFerRes()                                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function fdFerRes( lGpexmed, dtAviso )

Local aAreaSRH		:= {}
Local aFer			:= {}
Local aPerAux		:= {}
Local aPerAtual		:= {}
Local aPerFerAux	:= {}
Local cPd
Local dDtBaseFer
Local dDtIniPen
Local dDataDAux		:= CtoD("")
Local dDtSRFAux		:= CtoD("")
Local dDtIniPre		:= CtoD("")
Local dDtFimPre		:= CtoD("")
Local cMesAnoRef	:= ""
Local cSeekSRF		:= ""
Local lNoRescMes	:= .F.
Local lConvFProp	:= .F.
Local lDVenPen		:= .F.
Local nDFerPag		:= 0.00
Local nDFerGoz 		:= 0
Local nVal_SalMin 	:= 0
Local nFaltasPer	:= 0
Local nTipFal		:= 0
Local nTotDDobra	:= 0
Local nFerA			:= 0
Local nFerAAux		:= 0
Local nFerV			:= 0
Local nFerVAux		:= 0
Local nRecAux		:= 0
Local nQtdAtiv		:= 0
Local nDFerVPgAnt	:= 0 //Dias de férias vencidos pagos no mes anterior
Local nDFerAPgAnt	:= 0 //Dias de férias antecipadas pagas no mes anterior
Local nx,nPos
Local nPosTbFer		:= 0
Local nTempoParc	:= 0
Local nDFerTot      := 0
Local nVencAux		:= 0
Local nPosFal		:= 0
Local aBkpFer		:= {}
Local cCodFer		:= ""

P_REGPARCI			:= If( Type("P_REGPARCI") == "U", .F. , P_REGPARCI)
P_PRJESTAB			:= If( Type("P_PRJESTAB") == "U", .F. , P_PRJESTAB)
dDtEst936			:= If( Type("dDtEst936") == "U", cToD("") , dDtEst936)

DEFAULT lGpexmed	:= .T.
DEFAULT dDataDem	:= M->RG_DATADEM
DEFAULT lGestPubl   := IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP

If cPaisLoc == "BRA" .AND. lGestPubl .AND. SRA->RA_REGIME == "2" .AND. FindFunction("fdFerResFP")
	fdFerResFP( lGpexmed, dtAviso )
	Return
EndIf

If cPaisLoc == "BRA" .And. !( Empty(dtAviso) )
	dDataDem := dtAviso
Endif

//Busca periodo atual da folha
fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, fGetRotOrdinar() ) // Busca o periodo aberto da folha

If !Empty(aPerAtual)
	cMesAnoRef := aPerAtual[1,5] + aPerAtual[1,4]
Else
	cMesAnoRef := AnoMes(dDataBase)
EndIf

Sal_Min(@nVal_SalMin, IIf(!Empty(dDataDem),AnoMes( dDataDem ),cMesAnoRef))

lNoRescMes			:= !( cMesAnoRef  == AnoMes( dDataDem ) )

If SRA->RA_CATFUNC $ "E*G"   // Estagiario Mensalista/Horista
	cCodFer	:= FGETCODFOL( "0891" )
Else
	cCodFer	:= FGETCODFOL( "0072" )
EndIf

Begin Sequence

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Funcao Para Calcular Dias Ferias Vencidas e Proporcionais  ³
	³ Achar os dias de Ferias sem a parte indenizada de Aviso 	 ³
	³ Previo													 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	nDFerV 	 := 0
	nDFerA 	 := 0
	nDFerInd := 0
	nDFerAnt := 0

	If !(cPaisLoc $ "MEX|BOL|HAI")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Verifica a existecia do array aTabFer p/ o calculo de ferias |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Type("aTabFer") # "A" .Or. Len(aTabFer) == 0
			aTabFer	:= {}
			aTabFer2:= {}
			If cPaisLoc == "PER"
				fRetTab(@aTabFer,"S017",,,fCalcFimAq(Iif(dDataRef==Nil,dDataBase,dDataRef)),)
			Else
				If !(cPaisLoc $ 'ANG')
					fTab_Fer(@aTabFer,,@aTabFer2)
				EndIf
			EndIf
		EndIf

		//Se as horas semanais forem inferiores a 26, e o Mnemonico P_REGPARCI estiver ativo,
		//utiliza os dias de férias da tabela S065 - Tabela de férias tempo parcial (Artigo 130A da CLT)
		If cPaisLoc == "BRA"
			aAreaSRH   := SRH->( GetArea() )
			aPerDesc   := {}
			nTempoParc := SRA->RA_HRSEMAN
			If ( SRA->RA_HOPARC == "1" .And. nTempoParc <= 25 .And. nTempoParc  > 0 .And. Len(aTabFer2) > 0	.And. P_REGPARCI )
				nPosTbFer := Ascan(aTabFer2, { |X|  nTempoParc <= X[6] .And. nTempoParc > X[5] })
				If nPosTbFer > 0
					aTabFer := aClone(aTabFer2[nPosTbFer])
				Endif
			Endif
		EndIf

		If cPaisLoc == "PER"
			If SRA->RA_MEIOPER == "1" //# Part Time
				nDiasFer := aTabFer[6]
			Else
				nDiasFer := aTabFer[5]
			EndIf
			nDiasAux := nDiasFer
		ElseIf cPaisLoc <> "ANG"
			nDiasFer := aTabFer[4]
			nDiasAux := aTabFer[3]
		EndIf

		DbSelectArea("SRF")
		DbSetOrder(2)

		cSeekSRF := SRA->RA_FILIAL + SRA->RA_MAT + cCodFer
		dDtSRFAux := CtoD("")

		If DbSeek(cSeekSRF)
			If SRF->RF_STATUS $ " 1"
				RecAux := SRF->(Recno()) //Grava o primeiro registro aberto da SRF
			EndIf
			While SRF->(!Eof() .and. RF_FILIAL + RF_MAT + RF_PD == cSeekSRF )
				aFer := {}
				If (SRF->RF_STATUS $ " 1" .and. ( SRF->RF_DFERVAT > 0 .or. SRF->RF_DFERAAT > 0  .or. SRF->RF_DVENPEN > 0 ) ) .or.; //Carrega o primeiro periodo aquisitivo com dias vencidos ou a vencer
				 	( cCompl == "S" .And. lProxMes .and. Ascan(aFerPag,{ |X| X[1] == SRF->RF_DATABAS .and. X[2] == SRF->RF_DATAFIM }) > 0 )  //Se for complementar, carrega a SRF dos períodos de férias pagos na rescisão.
					aAdd(aPerFerAux,{	SRF->RF_DATABAS	,;										  		 			// 01 - Inicio Database de Ferias
										If(Empty(SRF->RF_DATAFIM),fCalcFimAq(SRF->RF_DATABAS),SRF->RF_DATAFIM),;    // 02 - Final Database de Ferias
										SRF->RF_DFERVAT	,;															// 03 - Dias de ferias vencidas
										SRF->RF_DFERAAT	,;															// 04 - Dias de ferias a vencer
										0.00			,;															// 05 - Dias totais de afastamento por periodo
										SRF->RF_OBSERVA	,;															// 06 - Descricao do tipo de afastamento do periodo
										CtoD("")		,;															// 07 - Data de original de termino do p.aquisitivo quando houver prorrogacao do mesmo RWX
										If(Empty(SRF->RF_STATUS),"1",SRF->RF_STATUS),;								// 08 - Status do periodo de ferias:  1-Ativo (Vencidos/A vencer)/2-Prescrito (Perdido)/3-Pago
										CtoD("")		,;															// 09 - Data de Inicio do Proximo periodo caso seja um periodo perdido.
										0				,;															// 10 - Quantidade dias de deducao para o direito apurado no periodo
										SRF->RF_DVENPEN ,;     														// 11 - Dias Vencidos Pendentes
										SRF->RF_IVENPEN ,;     														// 12 - Data Inicia Vencido Pendente
										SRF->RF_FVENPEN ,;															// 13 - Data Inicia Vencido Pendente
										SRF->RF_DFERANT ,;     														// 14 - Dias de Ferias Antecipadas
										SRF->RF_DFALVAT ,;     														// 15 - Dias de Faltas Vencidas
										SRF->RF_DFALAAT ,; 				    										// 16 - Dias de Faltas a Vencer
										If(cPaisLoc$"VEN|EQU",SRF->RF_DBONVAT,NIL),;				 				// 17 - Dias de bono vencido
										If(cPaisLoc$"VEN|EQU",SRF->RF_DBONAAT,NIL),; 								// 18 - Dias de bono a Vencer
										0				,;															// 19 - Total de dias de ferias
										0				,;															// 20 - Total de dias de bonificacao
										0				,;															// 21 - Dias de Faltas vencidas bonificacao
										0				,;															// 22 - Dias de ¦Faltas a Vencer bonificacao
										0				,;															// 23 - Dias de ausencia convertidos em ferias
										0				,;      													// 24 - Total de Dias de Ferias do Periodo
										SRF->RF_DIASANT ,;					      									// 25 - Dias Gozados Vencidos
										SRF->RF_DIASANT	,;	    													// 26 - Dias Gozados a Vencer
										0               ,;      													// 27 - Dias Subsid. Vencidos
										0               ,;   														// 28 - Dias Subsid. a Vencer
										0				,; 															// 29 - Dias de Pagto. Minimo na Adm/Dem (cpo. RF_PAGOFER desabilitado 08/2012)
										SRF->( RECNO() ),;															// 30 - Recno do aquivo
										Iif(Type("SRF->RF_FERPAGA")<>"U",  SRF->RF_FERPAGA, 0) ,;					// 31 - Dias pagos em R$ na folha
										SRF->RF_DATAATU	,;															// 32 - Data de atualizacao
										0                ;                                                          // 33 - Dias de suspensão do período
										})
										If Empty(nRecAux)
											nRecAux := SRF->(Recno()) //Grava o primeiro registro aberto da SRF
										EndIf
				ElseIf SRF->RF_STATUS == "2" //Prescrito
					dDtIniPre := SRF->RF_DATABAS
					dDtFimPre := SRF->RF_DATAFIM
				EndIf
				If cCompl == "S" .And. lProxMes //Rescisao complementar
					dDtSRFAux := SRF->RF_DATAFIM + 1
				EndIf
				If cPaisLoc == "BRA" .And. cAfasfgts == "J " .And. (!Empty(aCodFol[1858, 1]) .Or. !Empty(aCodFol[1859, 1])) .And. (SRF->RF_DFERVAT == 0 .And. (SRF->RF_STATUS == "3" .Or. SRF->RF_DFERANT > SRF->RF_DFERAAT))
					SRH->( dbSetOrder(1) )//RH_FILIAL+RH_MAT+DTOS(RH_DATABAS)+DTOS(RH_DATAINI)
					If SRH->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT+dToS(SRF->RF_DATABAS) ) )
						While SRH->( !EoF() ) .And. SRH->RH_FILIAL+SRH->RH_MAT+dToS(SRH->RH_DATABAS) == SRA->RA_FILIAL+SRA->RA_MAT+dToS(SRF->RF_DATABAS)
							If SRH->RH_DATAINI >= cToD("28/04/2021") .And. SRH->RH_DATAINI <= cToD("25/08/2021")
								aAdd( aFer, SRH->RH_DATAINI )
							EndIf
							SRH->( dbSkip() )
						EndDo
					EndIf
					If !Empty(aFer)
						aPerAux		:= {}
						nFerAAux	:= 0
						nFerVAux	:= 0
						aAdd(aPerAux,	{	SRF->RF_DATABAS	,;										  		 			// 01 - Inicio Database de Ferias
											If(Empty(SRF->RF_DATAFIM),fCalcFimAq(SRF->RF_DATABAS),SRF->RF_DATAFIM),;    // 02 - Final Database de Ferias
											SRF->RF_DFERVAT	,;															// 03 - Dias de ferias vencidas
											SRF->RF_DFERAAT	,;															// 04 - Dias de ferias a vencer
											0.00			,;															// 05 - Dias totais de afastamento por periodo
											SRF->RF_OBSERVA	,;															// 06 - Descricao do tipo de afastamento do periodo
											CtoD("")		,;															// 07 - Data de original de termino do p.aquisitivo quando houver prorrogacao do mesmo RWX
											"1",;																		// 08 - Status do periodo de ferias:  1-Ativo (Vencidos/A vencer)/2-Prescrito (Perdido)/3-Pago
											CtoD("")		,;															// 09 - Data de Inicio do Proximo periodo caso seja um periodo perdido.
											0				,;															// 10 - Quantidade dias de deducao para o direito apurado no periodo
											SRF->RF_DVENPEN ,;     														// 11 - Dias Vencidos Pendentes
											SRF->RF_IVENPEN ,;     														// 12 - Data Inicia Vencido Pendente
											SRF->RF_FVENPEN ,;															// 13 - Data Inicia Vencido Pendente
											SRF->RF_DFERANT ,;     														// 14 - Dias de Ferias Antecipadas
											SRF->RF_DFALVAT ,;     														// 15 - Dias de Faltas Vencidas
											SRF->RF_DFALAAT ,; 				    										// 16 - Dias de Faltas a Vencer
											NIL,;				 														// 17 - Dias de bono vencido
											NIL,; 																		// 18 - Dias de bono a Vencer
											0				,;															// 19 - Total de dias de ferias
											0				,;															// 20 - Total de dias de bonificacao
											0				,;															// 21 - Dias de Faltas vencidas bonificacao
											0				,;															// 22 - Dias de ¦Faltas a Vencer bonificacao
											0				,;															// 23 - Dias de ausencia convertidos em ferias
											0				,;      													// 24 - Total de Dias de Ferias do Periodo
											SRF->RF_DIASANT ,;					      									// 25 - Dias Gozados Vencidos
											SRF->RF_DIASANT	,;	    													// 26 - Dias Gozados a Vencer
											0               ,;      													// 27 - Dias Subsid. Vencidos
											0               ,;   														// 28 - Dias Subsid. a Vencer
											0				,; 															// 29 - Dias de Pagto. Minimo na Adm/Dem (cpo. RF_PAGOFER desabilitado 08/2012)
											SRF->( RECNO() ),;															// 30 - Recno do aquivo
											Iif(Type("SRF->RF_FERPAGA")<>"U",  SRF->RF_FERPAGA, 0) ,;					// 31 - Dias pagos em R$ na folha
											SRF->RF_DATAATU	,;															// 32 - Data de atualizacao
											0                ;                                                          // 33 - Dias de suspensão do período
											})
						Calc_Fer(@aPerAux, dDataDem, @nFerVAux, @nFerAAux,,,,.F.,aPerAux[1])
						If nFerVAux == 0 .And. SRF->RF_DFERANT > nFerAAux
							aAdd( aPerDesc, { SRF->RF_DATABAS, SRF->RF_DATAFIM, nFerAAux, SRF->RF_DFERANT, aFer } )
						EndIf
					EndIf
				EndIf
				SRF->(DbSkip())
			EndDo
			If nRecAux > 0
				SRF->(DbGoTo(nRecAux))
			ElseIf !(SRF->RF_FILIAL + SRF->RF_MAT + SRF->RF_PD == cSeekSRF) //Posiciona no último registro da SRF
				SRF->(DbSkip(-1))
				If (SRF->RF_FILIAL + SRF->RF_MAT + SRF->RF_PD == cSeekSRF) .And. SRF->RF_STATUS == "3"
					aAdd(aPerFerAux,{	SRF->RF_DATABAS	,;										  		 			// 01 - Inicio Database de Ferias
										If(Empty(SRF->RF_DATAFIM),fCalcFimAq(SRF->RF_DATABAS),SRF->RF_DATAFIM),;  // 02 - Final Database de Ferias
										SRF->RF_DFERVAT	,;															// 03 - Dias de ferias vencidas
										SRF->RF_DFERAAT	,;															// 04 - Dias de ferias a vencer
										0.00			,;															// 05 - Dias totais de afastamento por periodo
										SRF->RF_OBSERVA	,;															// 06 - Descricao do tipo de afastamento do periodo
										CtoD("")		,;															// 07 - Data de original de termino do p.aquisitivo quando houver prorrogacao do mesmo RWX
										If(Empty(SRF->RF_STATUS),"1",SRF->RF_STATUS),;								// 08 - Status do periodo de ferias:  1-Ativo (Vencidos/A vencer)/2-Prescrito (Perdido)/3-Pago
										CtoD("")		,;															// 09 - Data de Inicio do Proximo periodo caso seja um periodo perdido.
										0				,;															// 10 - Quantidade dias de deducao para o direito apurado no periodo
										SRF->RF_DVENPEN ,;     														// 11 - Dias Vencidos Pendentes
										SRF->RF_IVENPEN ,;     														// 12 - Data Inicia Vencido Pendente
										SRF->RF_FVENPEN ,;															// 13 - Data Inicia Vencido Pendente
										SRF->RF_DFERANT ,;     														// 14 - Dias de Ferias Antecipadas
										SRF->RF_DFALVAT ,;     														// 15 - Dias de Faltas Vencidas
										SRF->RF_DFALAAT ,; 				    										// 16 - Dias de Faltas a Vencer
										If(cPaisLoc$"VEN|EQU",SRF->RF_DBONVAT,NIL),;				 				// 17 - Dias de bono vencido
										If(cPaisLoc$"VEN|EQU",SRF->RF_DBONAAT,NIL),; 								// 18 - Dias de bono a Vencer
										0				,;															// 19 - Total de dias de ferias
										0				,;															// 20 - Total de dias de bonificacao
										0				,;															// 21 - Dias de Faltas vencidas bonificacao
										0				,;															// 22 - Dias de ¦Faltas a Vencer bonificacao
										0				,;															// 23 - Dias de ausencia convertidos em ferias
										0				,;      													// 24 - Total de Dias de Ferias do Periodo
										SRF->RF_DIASANT ,;					      									// 25 - Dias Gozados Vencidos
										SRF->RF_DIASANT	,;	    													// 26 - Dias Gozados a Vencer
										0               ,;      													// 27 - Dias Subsid. Vencidos
										0               ,;   														// 28 - Dias Subsid. a Vencer
										0				,; 															// 29 - Dias de Pagto. Minimo na Adm/Dem (cpo. RF_PAGOFER desabilitado 08/2012)
										SRF->( RECNO() ),;															// 30 - Recno do aquivo
										Iif(Type("SRF->RF_FERPAGA")<>"U",  SRF->RF_FERPAGA, 0) ,;					// 31 - Dias pagos em R$ na folha
										SRF->RF_DATAATU ,;                                                          // 32 - Data de atualizacao
										0                ;                                                          // 33 - Dias de suspensão do período
										})
				EndIf
			EndIf
		EndIf

		If cPaisLoc == "BRA"
			RestArea( aAreaSRH )
		EndIf

		//	aPerFerias - Mnemonico tipo Publico com os Periodos de Ferias
		If !(cCompl == "S" .And. lProxMes) //Apenas executa se não for complementar
			If Len(aPerFerAux) > 0
				If !Empty(dDtIniPre) .and. Empty(aPerFerAux[Len(aPerFerAux),3]) .And. Day(dDtIniPre) == Day(aPerFerAux[Len(aPerFerAux),1]) .And. Month(dDtIniPre) == Month(aPerFerAux[Len(aPerFerAux),1])
					nQtdAtiv := 0
					Aeval(aPerFerAux, { |X| nQtdAtiv += If ( X[8] == "1" .And. X[1] > dDtIniPre ,1,0) } )
					If nQtdAtiv < 2 .and. dDtFimPre + 1 >= aPerFerAux[Len(aPerFerAux),1]//Se o período anterior ao ultimo estava prescrito, efetua calc_fer considerando o período anterior para avaliação correta dos afastamentos sequenciais
						If Len(aPerFerAux) == 1 .or. aPerFerAux[Len(aPerFerAux),1] - 1 > aPerFerAux[Len(aPerFerAux)-1,2]
							aPerFerAux[Len(aPerFerAux),1] := dDtIniPre
						EndIf
					ElseIf nQtdAtiv == 0 //Ainda não existe período ativo gravado na SRF após o último preescrito. Cria período com inicio no último período preescrito e fim do período que seria o atual
						aAdd(aPerFerAux,{	dDtIniPre					,;
											fCalcFimAq(dDtFimPre + 1)	,;
											0.00			,;
											0.00			,;
											0.00			,;
											""				,;
											CtoD("")		,;
											"1"				,;
											CtoD("")		,;
											0.00			,;
											0.00			,;
											CtoD("")		,;
											CtoD("")		,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00		    ,;
											0.00			,;
											0.00		    ,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											0.00			,;
											CtoD("")		,;
											0.00             ;
											})
					EndIf
				EndIf

				For nPos := 1 to Len(aPerFerAux) - 1
					nFerV += aPerFerAux[nPos,3]
					nFerA += aPerFerAux[nPos,4]
				Next nPos

				aAdd(aPerFerias,aPerFerAux[Len(aPerFerAux)])
			EndIf

			dDataDAux := dDataDem

			fDtSabDom() //Verifica se deve pagar o sabado e domingo para utilizar na apuração dos avos.

			Calc_Fer(@aPerFerias,dDataDem, @nDferv, @nDfera,,,,.F.,If(Len(aPerFerias)>0,aPerFerias[Len(aPerFerias),1],dDtSRFAux))

			dDataDem := dDataDAux //Retorna datadem original

			If Len(aPerFerAux) > 0
				For nPos := 1 to Len(aPerFerias)
					If nPos == 1
						aPerFerAux[Len(aPerFerAux)] := aClone(aPerFerias[nPos])
					Else
						aAdd(aPerFerAux, aPerFerias[nPos])
					EndIf
				Next nPos
				aPerFerias := aPerFerAux
			EndIf
		Else
			aPerFerias := aClone(aPerFerAux)
			nDFerV := SRG->RG_DFERVEN
			nDFerA := SRG->RG_DFERPRO
		EndIf

		nDFerV += nFerV
		nDFerA += nFerA

		// Verifica e Aplica a Tabela de Faltas
		If !(cPaisLoc $ "ANG/ARG/EQU")
			aFaltasPer := {}
			nFalAtuD   := 0
			Calmed( @nfaltasv, @nFaltasp, lGpexmed, dDtBaseFer, nVal_SalMin, @aFaltasPer )
		EndIf

		nPos		:= Ascan(aPerFerias,{ |X| X[8] == "1" })
		nPos		:= If(nPos == 0,Len(aPerFerias),nPos)
		If nPos > 0
			dDtBaseFer	:= aPerFerias[nPos,1]
			dDtIniPen	:= aPerFerias[nPos,12]
			lDVenPen	:= (aPerFerias[nPos,11] > 0 .and. !Empty(aPerFerias[nPos,12]))
		    dDT1        := dDtBaseFer // dDt1 - Mnemonico Tipo Publico utilizado no GPEXMED
			Aeval(aPerFerias, { |X| nDFerAnt += If ( X[8] = "1" .OR. ( cCompl == "S" .and. x[3] > 0 ),X[14],0) } ) // Apura dias de Ferias Antecipadas
			If cCompl == "S" .And. Len(aFerPag) > 0 .And. aPerFerias[nPos,8] <> "1" //Quando complementar, subtrai os dias pagos na rescisão
				nVencAux := nDFerV
				For nX := Len(aFerPag) to 1 step -1 //Trata do mais recente para o mais antigo
					If aFerPag[nX,3] - Int(aFerPag[nX,3]) == 0.12
						//Pode ocorrer casos em que o valor gerado na SRR não condiz com a referência dos avos.
						// Por isso, busca a quantidade de dias vencidos e subtrai a referência da SRR.
						If Int(aFerPag[nX,3]) < 12
							nDFerTot := nVencAux - Int(aFerPag[nX,3]) * nDiasFer
						Else
							nDFerTot := 0
							nVencAux -= ( Int(aFerPag[nX,3]) * nDiasFer )
						EndIf
						//Caso o valor seja < 0, quer dizer que tem menos dias vencidos do que referência.
						//Exemplo: 24 Dias Vencidos e 12/12 gerados na SRR.
						// 24 - (12 * 2,5) = -6
						If nDFerTot < 0
							nDFerTot := nDFerTot * (- 1)
						EndIf
						nDFerAnt -= (Int(aFerPag[nX,3]) * nDiasFer) + nDFerTot
					Else
						nDFerAnt -=  aFerPag[nX,3]
					EndIf
				Next nX

				//Subtrai os dias de faltas que foram descontados
				If (nPosFal := aScan(aFaltasPer, {|X| X[1] = CVALTOCHAR(nPos + If(nPos > 1, 3, 0))})) > 0
					nDFerAnt -= aFaltasPer[nPosFal, 2]
				EndIf

			EndIf
		EndIf

		If !(cCompl == "S" .and. Len(aFerPag) > 0)
			dbSelectArea("SRH")
			DbSetOrder(1)
			For nx := 1 to Len(aPerFerias)
				SRH->( MsSeek( SRA->RA_FILIAL + SRA->RA_MAT + Dtos(aPerFerias[nx,1]) ) )
				While !Eof() .And. SRH->RH_FILIAL + SRH->RH_MAT + Dtoc(SRH->RH_DATABAS) == SRA->RA_FILIAL + SRA->RA_MAT + Dtoc(aPerFerias[nx,1])
					If cPaisLoc == "EQU"
						If SRH->RH_PERIODO == cPeriodo .And. SRH->RH_NPAGTO == cNumPag
							nDFerGoz+= SRH->RH_DFERIAS  //ferias gozadas
							nDFerGoz+= SRH->RH_DBONIFI  //ferias vendidas (Abono pec)
						EndIf
					Else
						If MesAno(SRH->RH_DATAINI) == MesAno(dDataDem) .Or. ( lNoRescMes .And. MesAno(SRH->RH_DATAFIM) == MesAno(dDataDem) )
							If SRH->RH_DFERIAS + SRH->RH_DABONPE + SRH->RH_DFALTAS + nDFerAnt >= nDiasAux  .and. !(MesAno(SRH->RH_DATAINI) == MesAno(dDataDem))
								dDtBaseFer 	:= SRH->RH_DBASEAT + 1
								If cCompl <> "S" .and. lNoRescMes .and. MesAno(SRH->RH_DATAINI) == cMesAnoRef
									If aPerFerias[nX,3] > 0
										nDFerVPgAnt += SRH->RH_DFERIAS + SRH->RH_DABONPE
									Else
										nDFerAPgAnt += SRH->RH_DFERIAS + SRH->RH_DABONPE
									EndIf
								EndIf
							Else
								If cPaisloc <> "VEN"
									nDFerAnt  += SRH->RH_DABONPE + SRH->RH_DFERIAS
								EndIf
							EndIf
						//Se férias foi paga durante o período aberto da folha e rescisão esta sendo calculada para o futuro, subtrai os dias de férias pagos no mês anterior da rescisão
						ElseIf cCompl <> "S" .and. lNoRescMes .and. MesAno(SRH->RH_DATAINI) == cMesAnoRef
							If aPerFerias[nX,3] > 0
								nDFerVPgAnt += SRH->RH_DFERIAS + SRH->RH_DABONPE
								If nDFerVPgAnt + SRF->RF_DFERANT >= aTabFer[3] //Se o período foi quitado (30 dias pago), altera o registro na SRF
									SRF->(DbSkip())
									If !(SRF->RF_FILIAL + SRF->RF_MAT == SRA->RA_FILIAL + SRA->RA_MAT ) .and. nRecAux > 0
										SRF->(DbGoTo(nRecAux))
									Else
										nRecAux := SRF->(Recno())
									EndIf
								EndIf
							Else
								nDFerAPgAnt += SRH->RH_DFERIAS + SRH->RH_DABONPE
							EndIf
						EndIf
					EndIf
					dbSkip()
				Enddo
			Next nx
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Calcular Dias de Ferias						 			 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		nDFerVen := 0
		nDFerAve := 0
		If cCompl <> "S"
			dDataDAux := dDataDem

			fDtSabDom() //Verifica se deve pagar o sabado e domingo para utilizar na apuração dos avos.

			aBkpFer := aClone(aPerFerias)
			If cPaisLoc $ "PTG|ARG|VEN|COL|ANG|PER|EQU"
				Calc_Fer(@aPerFerias , dDataDem , @nDferven, @nDferave,,,,.f.)
			ElseIf !Empty(aIncRes) .And. aIncRes[2] $ "T*B" .And. cPaisLoc == "BRA"
				Calc_Fer(@aPerFerias, Iif( P_PRJESTAB .And. dDtEst936 > dDataDem, (dDtEst936+nDiaInde), (dDataDem+nDiaInde) ),@nDferven,@nDferave,,,,.F.,dDtSRFAux)
			Else
				Calc_Fer(@aPerFerias, Iif( cPaisLoc == "BRA" .And. P_PRJESTAB .And. dDtEst936 > dDataDem, dDtEst936 + If(!Empty(aIncRes) .And. aIncRes[2]$ "S*I*A", nDiasAv, 0), dDataDem + If( !Empty(aIncRes) .And. aIncRes[2]$ "S*I*A".And. !(cPaisLoc $"ARG|CHI"), nDiasAv, 0)), @nDferven, @nDferave,,,,.F.,dDtSRFAux)
			EndIf
			aPerFerias := aBkpFer

			//Subtrai os dias de férias pagos no mês da folha que ainda esta aberto
			If nDFerVPgAnt > 0 .and. nDFerV > 0
				nDFerV -= nDFerVPgAnt
				nDferven -= nDFerVPgAnt
				If nDFerV == 0 //Se período foi quitado, altera aPerFerias para calcular médias corretamente
					If ( nPos := aScan(aPerFerias, {|x| x[8] == "1" .and. x[3] > 0}) ) > 0
						aPerFerias[nPos,8] := "3"
					EndIf
				EndIf
			ElseIf nDFerAPgAnt > 0 .and. nDFerA > 0
				nDFerA := Max(0,nDFerA - nDFerAPgAnt)
				nDferave := Max(0, nDFerAve - nDFerAPgAnt)
			EndIf

			//Calcular dias ferias sobre aviso, vencido e proporcionais
			nDferInd := ( (nDferven +  nDferave) - ( nDferv + nDfera ) )     // Dias Ferias sobre aviso previo
			nDferven := nDferv               								 // Dias Ferias Indenizados sem aviso
			nDferave := nDfera		         								 // Dias Ferias Proporcionais sem aviso

			dDataDem := dDataDAux //Retorna datadem original
		Else
			If(cPaisLoc == 'BRA')
				nDferInd := SRG->RG_DFERAVI
			EndIf
			nDferave := SRG->RG_DFERPRO
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		|Se apurada ferias vencidas em consequencia do aviso,subtrair|
		|da vencidas, a ferias a vencer calculada sem o aviso.       |
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If ( nDferInd == nDiasAux )
			nDferInd -= nDfera   // 1/12 avos de ferias sobre aviso indenizado
		EndIf

		// Verifica e Aplica a Tabela de Faltas
		If !(cPaisLoc $ "ANG/ARG/EQU")
			aFaltasPer := {}
			nFalAtuD   := 0
			Calmed( @nfaltasv, @nFaltasp, lGpexmed, dDtBaseFer, nVal_SalMin, @aFaltasPer )
		EndIf

		If(cPaisLoc == 'BRA')
			lDFerAvi := !(SRG->RG_DFERAVI == 0 .and. nDiasAv > 0 .and. cCompl == "S")
		Else
			lDFerAvi := !(nDiasAv > 0 .and. cCompl == "S")
		EndIf
		//FALTAS
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ A rotina de media gera as faltas por periodos com a data demissao sem    ³
		//³ o aviso previo. As faltas ficam gravadas no periodo correspondente,      ³
		//³ podendo ser, proporcional ou vencidas. 									 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se for complementar antes da separacao dos dias ferias sobre aviso, pode  ³
		//³ocorrer com o aviso previo indenizado ou quando completa os 12 meses com a³
		//³data da demissao, as ferias proporcionais podem passar a ser vencidas, e  ³
		//³as faltas ficarem gravadas no periodo proporcional. Nessas situacoes      ³
		//³utilizar faltas do periodo proporcional par abater das ferias vencidas.   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If (nDFerA > 0 .And. nDFerVen >= nDFerV) .or. (nDFerA == 0 .And. nDFerVen > 29 )
			nfaltasv := nFaltasp := 0
			nFaltasPer	:= aScan(aFaltasPer, { |x| x[ 1 ] == "2" } )

		  	If ( nFaltasPer > 0 )  .and. !lDFerAvi // 	//-- Se encontrou algum periodo com faltas proporcionais e calculo sem a separacao das ferias sobre aviso.
				//-- Na existencia de periodos de ferias, as ferias proporcionais somente serão convertidas em vencidas
				//-- caso o periodo das mesmas compreenda a da data de demissao
				lConvFProp:= ( 	;
								( Type("aPerFerias") != "U" .and. ;
								  Dtos( aPerFerias[ Len( aPerFerias ) ,2 ] )  >= Dtos(dDataDem) .and. ;
								  aPerFerias[ Len(aPerFerias),3 ] > 0;
								) .or.;
							 	Type("aPerFerias") == "U" ;
							 )
		        If  lConvFProp
					If( ( nTipFal := Val( aFaltasPer[ Len( aFaltasPer ), 1 ] ) ) >= 5, nTipFal := nTipFal + 1, If( aFaltasPer[ 1, 1 ] == "1", nTipFal := 5, nTipFal := 1 ) )
					aFaltasPer[ nFaltasPer, 1 ] := Alltrim( Str( nTipFal ) )
					aSort( @aFaltasPer, , , { | x, y | x[ 1 ] < y[ 1 ] } )
				EndIf
			EndIf
		EndIf

		//Calculo das faltas vencidas proporcionais aos dias de ferias vencidas por periodo
		If Len( aFaltasPer ) > 0

			nFaltasv := 0
			aEval( aFaltasPer, {|x| nFaltasv +=If( x[ 1 ] <> "2" , x[2],0) })

			nFaltasp:=0
			aEval( aFaltasPer, {|x| nFaltasp +=If( x[ 1 ] == "2" , x[2],0) })

		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ A rotina de media gera as faltas por periodos com a data demissao sem     ³
		³ o aviso previo e o periodo para faltas pode ser proporcional e com o aviso³
		³ as ferias mudou de proporcional para vencidas e as faltas ficaram gravada ³
		³ no periodo proporcional, nessa situacao utilizar faltas do periodo        ³
		³ proporcional par abater das ferias vencidas.                              ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If nDFerV == 0 .And. nDFerA > 0 .And. nFaltasv = 0 .And. nDFerVen > 0
			nfaltasv := nFaltasp
			nFaltasp  := 0
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		| Calcula as Faltas Proporcionais							 |
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !P_REGPARCI .And. !lTempoParc
			nFaltasp := ((nFaltasp / 30) * nDferAve)
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		| Calculo de Ferias Dobrada									 |
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !SRA->RA_CATFUNC $ "E*G" //Se for estagiario não calcula férias em dobro
			If cPaisLoc == "BRA"
				fDiasDobra( ndDobro, 0, .F., Iif(cCompl <> "S", nDferven, nDFerV), If( lDVenPen, dDtIniPen, dDtBaseFer ),(dDataDem + nDiaInde)-1, (dDataDem + nDiaInde)-1, @nTotDDobra, aFaltasPer, nDFerAnt + nDFerVPgAnt + nDFerAPgAnt, dDataDem, nDiaInde)
				ndDobro	:= nTotDDobra
			Else
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				| Calculo de Ferias Dobrada									 |
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If (nDFerVen / nDiasAux) > 1
					ndDobro := ( (Int(nDFerVen / nDiasAux)-1 ) * nDiasAux )
					ndDobro -= nDFerAnt
				EndIf
			EndIf
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Deducao de dias de ferias antecipadas                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !(cCompl == "S" .and. Len(aFerPag) > 0) .And. nDFerAnt > 0 .AND. cPaisLoc <> "ANG"
			If nDferave > 0 .And. nDferven = 0
				nDferave -= nDFerAnt
			ElseIf nDferven > 0
				nDferven -= nDFerAnt
			EndIf
			If nDFerInd > 0 .and. ( nDferave < 0 .or. nDferven < 0 )
				nDFerInd += If(nDferave < 0, nDferave, nDferven)
				nDFerInd := Max(nDFerInd, 0)
			EndIf
			nDferave := If(nDferave < 0, 0, nDferave)
			nDferven := If(nDferven < 0, 0, nDferven)
		EndIf

		If nDFerVPgAnt > 0 .and. nDFerV > 0
			nDFerAnt += nDFerVPgAnt
		EndIf
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Zera dias de Ferias para Funcionarios com Menos de um ano de³
		³Casa e quando o Tipo de Rescisao estiver com "N" para o  Cal³
		³culo de Ferias Prop. Enunc. 261 do TST e art. 147 da CLT.   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !(cPaisLoc$"PTG|ARG|VEN|COL|ANG|PER|EQU") .And. !Empty(aIncRes) .And. aIncRes[4] = "N" .And. nAnosCasa < 1
			nDferave := 0 ; nDferven := 0
		EndIf

		//Desconta dias de ferias ja pagos ou gozados no periodo da rescisao
		If cPaisLoc == "EQU" .And. nDFerGoz > 0
			If nDferven > nDFerGoz
				nDFerVen-= nDFerGoz
			Else
				nDFerGoz-= nDFerVen
				nDFerVen:= 0
				nDFerAVe:= Max(	nDFerAVe - nDFerGoz, 0 )
			EndIf
		EndIf

	Else

		If cPaisLoc == "BOL"
			aTabFer := {}
			aTabFer2 := {}
			fTab_Fer(@aTabFer, , @aTabFer2)
		EndIf

		nDferven := 0
		nDferave := 0
		nDFerPag := 0

		DbSelectArea( "SRF" )
		DbSetOrder( RetOrdem( "SRF", "RF_FILIAL+RF_MAT+RF_PD+DTOS(RF_DATABAS)" ))
		cPd := fGetCodFol("0072")	// ID de Vacaciones
		Dbseek( SRA->RA_FILIAL + SRA->RA_MAT + cPd, .F. )
		While !Eof() .and. SRF->(RF_FILIAL+RF_MAT+RF_PD) == (SRA->RA_FILIAL + SRA->RA_MAT + cPd)
			If cPaisLoc != "BOL" .Or. SRF->RF_STATUS $ " 1"
				nDferven += SRF->RF_DFERVAT
				nDferave += SRF->RF_DFERAAT
				nDFerPag += SRF->RF_DFERANT
			EndIf
			DbSkip()
		EndDo
		If cPaisLoc == "BOL" .And. nDferave > 0
			SRF->( DbSetOrder(1) )
			SRF->( Dbseek( SRA->RA_FILIAL + SRA->RA_MAT, .F. ) )
			While SRF->( !Eof() ) .And. SRF->RF_FILIAL+SRF->RF_MAT == SRA->RA_FILIAL+SRA->RA_MAT
				If SRF->RF_PD == cPd .AND. SRF->RF_STATUS $ " 1"
					dDataDe :=CtoD( StrZero(Day(SRA->RA_ADMISSA),2)+ "/"+RCH->RCH_MES+"/"+RCH->RCH_ANO) //DIA ADM + MES/ANO PERIODO.
					dDataIniP :=CtoD( StrZero( DAY( SRA->RA_ADMISSA ), 2 ) + "/" + StrZero( Month( SRA->RA_ADMISSA ),2 ) + "/" + StrZero(YEAR(dDataDe),4 ) )  //DIA/MES ADM + ANO PERIODO
					If dDataIniP <= dDataDe
						dDtFimP := CtoD( StrZero( DAY( SRA->RA_ADMISSA ),2 ) + "/" + StrZero( Month( SRA->RA_ADMISSA ) ,2 ) + "/" + StrZero( YEAR(dDataDe) + 1, 4) ) -1
					Else
						dDataIniP:= CtoD( StrZero( DAY( SRA->RA_ADMISSA) , 2 )  + "/" + StrZero( Month( SRA->RA_ADMISSA ) ,  2 ) + "/" + StrZero( YEAR(DDATADE ) - 1,  4 ) )
						dDtFimP := CtoD( StrZero( DAY( SRA->RA_ADMISSA ), 2 ) + "/" + StrZero( Month( SRA->RA_ADMISSA ),2  ) + "/" + StrZero(YEAR(DDATADE) , 4) ) -1
					EndIf

					If SRA->RA_ADMISSA < dtAviso
						DDATAF := dtAviso
						NANOSTRAB := (( DDATAF - SRA->RA_ADMISSA) + 1) / 365
						NX := FPOSTAB("S010", SRA->RA_PROCES, "=", 4 , NANOSTRAB , "<=" , 6 )
						NDIASVAC := If(NX > 0,  FTABELA("S010" , NX , 7 ) ,  0 )
						If NDIASVAC > 0
							nDferven := 0
							nDferave := (NANOSTRAB - Int(NANOSTRAB)) * NDIASVAC

							If SRF->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT ) )
								While SRF->( !EoF() ) .And. SRF->RF_FILIAL + SRF->RF_MAT == SRA->RA_FILIAL + SRA->RA_MAT
									If SRF->RF_DFERVAT > 0 .And. SRF->RF_STATUS == "1"
										nDferven += SRF->RF_DFERVAT
									ElseIf SRF->RF_DFERVAT == 0
										nDferave -= SRF->RF_DFERANT
									EndIf
									SRF->( dbSkip() )
								End
							EndIf
						EndIf
					EndIf
					Exit
				EndIf
				SRF->( DbSkip())
			EndDo
		EndIf
		
		SR8->( dbSetOrder(1) )
		If SR8->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT+cPeriodo ) )
			While SR8->( !EoF() ) .And. SR8->R8_FILIAL+SR8->R8_MAT+SubStr( DToS(SR8->R8_DATAINI), 1, 6 ) == SRA->RA_FILIAL+SRA->RA_MAT+cPeriodo
				If SR8->R8_TIPOAFA == "VAC"
					nDFerAux += SR8->R8_DURACAO
					nDFerPag += SR8->R8_DURACAO
				EndIf
				SR8->( dbSkip() )
			EndDo
		EndIf

		If nDFerPag > 0
		   If nDferven >= nDFerPag
		   		nDferven := nDferven - nDFerPag
		   Else
		   		If nDferave >= (nDFerPag - nDferven)
		   			nDferave := nDferave - (nDFerPag - nDferven)
		   		Else
		   			nDferave := 0
		   		EndIf
		   		nDferven := 0
		   EndIf
		EndIf
	EndIf

End Sequence

Return( Nil )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CalMed       ³ Autor ³ Leandro Drumond       ³ Data ³ 08/01/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo das Medias do Funcionario							     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso	     ³GPEM040													     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function CalMed( nFaltasv, nFaltasp, lGpexmed, dDtBaseFer, nVal_SalMin, aFaltasPer )

Local aPerAtual		:= {}
Local APdAux		:= aPd
Local cTipMed		:= ""
Local cMesAnoRef	:= ""

Local nX			:= 0.00
Local nFalAtu		:= 0.00
Local nLenaPd		:= 0.00
Local nQtdPer		:= 0.00
Local lResMSeg		:= .F.
Local nNroFaltas	:= 0.00
Local nFaltasU		:= 0
Local nTotFal		:= 0       //Total faltas sem o desconto
Local nAux			:= 0

lMetadeFal			:= If( Type("lMetadeFal") == "U", .F. , lMetadeFal)
lMetFalP			:= If( Type("lMetFalP") == "U", .F. , lMetFalP)
lMetFalV			:= If( Type("lMetFalV") == "U", .F. , lMetFalV)

DEFAULT lGpexmed	:= .T.
DEFAULT dDtBaseFer	:= SRF->RF_DATABAS

fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, fGetCalcRot('4')  ) // Busca o periodo aberto da rescisao

If !Empty(aPerAtual)
	cMesAnoRef := aPerAtual[1,5] + aPerAtual[1,4]
Else
	cMesAnoRef := AnoMes(dDataBase)
EndIf

lResMSeg := ( MesAno( dDataDem ) > cMesAnoRef )

aPd := {}

fCarRGB()

nLenaPd := Len(aPd)

Begin Sequence

	DbSelectArea( cTBLXMED )

	nFaltasv := nFaltasp := 0

	If lGpexmed

		If (cTBLXMED)->( RECCOUNT() ) > 0
			zap
		EndIf

		If cCompl == "S"
			M->RG_DFERVEN := SRG->RG_DFERVEN
			M->RG_DFERPRO := SRG->RG_DFERPRO
		EndIf

		GPEXMED(dDtBaseFer, ,dDataDem,dDataDem,dDataDem,SalHora,nVal_SalMin,aCodfol,,If( lResMSeg, .T., .F. ),.T.)
		For nX := 1 To 6
			cTipMed	   := Str( IF(nX ==1, 1,nX+3),1 )
			nNroFaltas := 0
			IF dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cTipMed + "998" + "9698" )
				nNroFaltas := (cTBLXMED)->RP_HORAS
				nTotFal	   := nNroFaltas
				TabFaltas(@nNroFaltas)
				aAdd( aFaltasPer, { cTipMed, nNroFaltas, nTotFal })
			EndIF
			lMetFalV := lMetadeFal
			nFaltasv += nNroFaltas
		Next nX
		If !Empty(aFaltasPer)
			nFaltasU := aFaltasPer[Len(aFaltasPer),2]
		EndIf
	EndIf

	nNroFaltas := 0

	For nX := 1 To nLenaPd
		If aPd[nX,9] <> "D"
			//--Verifica se ‚ falta/Atraso para descontar Ferias e 13o.
			If aPd[nX,1] $ ( aCodFol[054,1]+'*'+aCodFol[203,1]+'*'+aCodFol[055,1]+'*'+aCodFol[242,1]+'*'+ aCodFol[243,1]+'*'+aCodFol[244,1]+'*'+aCodFol[245,1] )
				nFalAtu := 0
				If aPd[nX,6] = "D"
					nFalAtu := aPd[nX,4]
				ElseIf aPd[nX,6] == "H"
					nFalAtu := aPd[nX,4]/Round(SRA->RA_HRSMES/30,2)
				EndIf
				If Upper(AllTrim(PosSrv(aPd[nX,1],SRA->RA_FILIAL,"RV_MEDFER"))) $ "S *SP"
					If !( aPd[nX,1]  $ aCodFol[244,1] + '_' + aCodFol[245,1] )
						If ( Empty(aPd[nX,10]) .Or. nDferv == 0 .Or. (nDferv > 0 .And. aPd[nX,10] >= aPerFerias[Len(aPerFerias),1]) )
							nFaltasP += nFalAtu
						Else
							nNroFaltas += nFalAtu
						EndIf
					Else
						If ( Empty(aPd[nX,10]) .Or. nDferv == 0 .Or. (nDferv > 0 .And. aPd[nX,10] >= aPerFerias[Len(aPerFerias),1]) )
							nFaltasP -= nFalAtu
						Else
							nNroFaltas -= nFalAtu
						EndIf
					EndIf
				EndIf
				If Upper(AllTrim(PosSrv(aPd[nX,1],SRA->RA_FILIAL,"RV_MED13"))) == "S"
					If !( aPd[nX,1]  $ aCodFol[244,1] + '_' + aCodFol[245,1] )
						nFalAtuD += nFalAtu
					Else
						nFalAtuD -= nFalAtu
					EndIf
				EndIf
			EndIf
		EndIf
	Next nX

	If nNroFaltas > 0
		If Len(aFaltasPer) > 0
			nNroFaltas += aFaltasPer[Len(aFaltasPer),3]
			nAux := nNroFaltas
			TabFaltas(@nNroFaltas)
			aFaltasPer[Len(aFaltasPer),2] := nNroFaltas
			aFaltasPer[Len(aFaltasPer),3] := nAux
			lMetFalV := lMetadeFal
			nFaltasv += (nNroFaltas - nFaltasU)
		Else
			nAux := nNroFaltas
			TabFaltas(@nNroFaltas)
			aAdd( aFaltasPer, { "1", nNroFaltas, nAux })
			nFaltasv += (nNroFaltas - nFaltasU)
		EndIf
	EndIf

	//-- Busca as faltas lancadas na rescisao original para o calculo do 13o salario
	If cCompl == "S" .And. lProxMes
		For nX := 1 To Len(aPdResc)
			//--Somente considera as verbas que nao estao excluidas
			If aPdResc[nX,9] <> "D"
				//--Verifica se ‚ falta/Atraso para descontar Ferias e 13o.
				If aPdResc[nX,1] $ ( aCodFol[054,1]+'*'+aCodFol[203,1]+'*'+aCodFol[055,1]+'*'+aCodFol[242,1]+'*'+ ;
						aCodFol[243,1]+'*'+aCodFol[244,1]+'*'+aCodFol[245,1] )
					nFalAtu := 0
					If aPdResc[nX,6] = "D"
						nFalAtu := aPdResc[nX,4]
					ElseIf aPdResc[nX,6] == "H"
						nFalAtu :=  Int(aPdResc[nX,4]/Round(SRA->RA_HRSMES/30,2))
					EndIf
					If Upper(AllTrim(PosSrv(aPdResc[nX,1],Sra->Ra_Filial,"RV_MED13"))) == "S"
						If !( aPdResc[nX,1]  $ aCodFol[244,1] + '_' + aCodFol[245,1] )
							nFalAtuD += nFalAtu
						Else
							nFalAtuD -= nFalAtu
						EndIf
					EndIf
				EndIf
			EndIf
		Next nX
	EndIf

	dbSelectArea(cTBLXMED)
	IF dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + "2" + "998" + "9698" )
		nFaltasP += (cTBLXMED)->RP_HORAS
	EndIF

	If nFaltasP > 0
		If nDferave > 0 .or. ( cCompl == "S" .And. lProxMes .and. SRG->RG_DFERPRO > 0 )
			TabFaltas(@nFaltasp, nDferave)
			aAdd( aFaltasPer, { "2", nFaltasp })
			lMetFalP := lMetadeFal
		ElseIf Len(aPerFerias) <= 1 .or. !( Empty(aPerFerias[Len(aPerFerias)][3]) .and. aPerFerias[Len(aPerFerias)-1][8] == "2") //Se o último período não tem dias e o anterior estiver prescrito, ignora as faltas

			nQtdPer 	:= Len(aFaltasPer) //Qtd de periodos de faltas
			nFaltasV	:= If(nQtdPer>0,aFaltasPer[nQtdPer,3],0) + nFaltasP
			nFaltasP	:= 0

			TabFaltas(@nFaltasV)
			lMetFalV := lMetadeFal

			If nQtdPer > 0
				aSort( @aFaltasPer, , , { |x,y| X[1] < y[1] } )
				aFaltasPer[nQtdPer,2] := nFaltasV
			Else
				aAdd( aFaltasPer, { "1", nFaltasV })
			EndIf
		EndIf
	EndIf

End Sequence

If( Len( aFaltasPer ) > 0, aSort( @aFaltasPer, , , { | x, y | x[ 1 ] < y[ 1 ] } ), )

aPd := APdAux

Return( Nil )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCarCompl    ³ Autor ³ Leandro Drumond       ³ Data ³ 08/01/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Carregar os Valores Pagos Anteriormente que serao utilizados	 ³±±
±±³          ³para o Calculo da Rescisao complementar Feita Fora da   Data	 ³±±
±±³          ³de Demissao													 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso	     ³GPEM040													     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fCarCompl( cFilMat , aPdResc , aSrgRecnos )

Local aArea		:= GetArea()
Local cSeq		:= " "
Local dDataGer	:= Ctod("//")
Local dDataPag	:= Ctod("//")
Local nPerc		:= 0.00
Local nPosPd	:= 0.00
Local nV		:= 0.00
Local nX		:= 0.00
Local nPos		:= 0.00
Local nPosIns	:= 0.00
Local nVezes	:= Len( aSrgRecnos )
Local nValTerP	:= 0
Local nValTerV	:= 0
Local nCount	:= 0
Local lRatProv	:= GetMvRH("MV_RATPROV", Nil, "N") == "S"
//Novos adicionais rescisão.
Local cIdsADI   := aCodFol[1680,1] + "/" + aCodFol[1681,1] + "/" + aCodFol[1682,1] + "/" + aCodFol[1683,1] + "/" + aCodFol[1684,1] + "/" +;
					   aCodFol[1685,1] + "/" + aCodFol[1686,1] + "/" + aCodFol[1687,1] + "/" + aCodFol[1688,1] + "/" + aCodFol[1689,1] + "/" +;
					   aCodFol[1690,1] + "/" + aCodFol[1691,1] + "/" + aCodFol[1692,1] + "/" + aCodFol[1693,1] + "/" + aCodFol[1694,1] + "/" +;
					   aCodFol[1695,1] + "/" + aCodFol[1696,1] + "/" + aCodFol[1697,1] + "/" + aCodFol[1698,1] + "/" + aCodFol[1699,1] + "/" +;
					   aCodFol[1700,1] + "/" + aCodFol[1701,1] + "/" + aCodFol[1702,1] + "/" + aCodFol[1703,1] + "/" + aCodFol[1704,1] + "/" +;
					   aCodFol[1705,1] + "/" + aCodFol[1706,1] + "/" + aCodFol[1707,1] + "/" + aCodFol[1708,1] + "/" + aCodFol[1709,1] + "/" +;
					   aCodFol[1710,1] + "/" + aCodFol[1711,1] + "/" + aCodFol[1712,1] + "/" + aCodFol[1713,1] + "/" + aCodFol[1714,1] + "/" +;
					   aCodFol[1715,1] + "/" + aCodFol[1716,1] + "/" + aCodFol[1717,1] + "/" + aCodFol[1718,1] + "/" + aCodFol[1719,1] + "/" +;
					   aCodFol[1720,1] + "/" + aCodFol[1721,1]

aPdResc	    := {}
aPd			:= {}
aFerPag		:= {}
aPerDobra   := {}
LTEMIDRESC 	:= .F.

SRR->(DbSetOrder(3))

For nV := 1 To nVezes
	dDataGer	:= aSrgRecnos[ nV , 02 ]
	lMesDem     := ( MesAno( aSrgRecnos[ nV , 02 ] ) == MesAno( aSrgRecnos[ nV , 03 ] ) )
	If SRR->( dbSeek( cFilMat + "R" + Dtos( dDataGer ) ) )
		While SRR->( !Eof() .and. RR_FILIAL + RR_MAT + RR_TIPO3 + Dtos( RR_DATA ) == cFilMat + "R" + Dtos( dDataGer ) )
			dDataPag := SRR->( If( Empty( RR_DATAPAG ) , RR_DATA , RR_DATAPAG ) )

			If SRR->RR_PD $ cIdsADI
				LTEMIDRESC := .T.
			EndIf

			If SRR->RR_PD == aCodFol[86,1] //Se for verba referente a férias indenizadas, grava período para posterior carga no aPerFerias
				If ( nPos := aScan( aFerPag, { |x| dToS(x[1])+dToS(x[2])+dToS(x[4]) == SubStr(SRR->RR_NUMID,1,8)+SubStr(SRR->RR_NUMID,12,8)+dToS(SRR->RR_DATA) } ) ) == 0
					aAdd(aFerPag, { StoD(SubStr(SRR->RR_NUMID,1,8)), StoD(SubStr(SRR->RR_NUMID,12,8)), SRR->RR_HORAS, SRR->RR_DATA})
				Else
					aFerPag[nPos, 3] += SRR->RR_HORAS
				EndIf
			ElseIf SRR->RR_PD $ aCodFol[224,1] + "/" + aCodFol[925,1]//Férias em Dobro
			 	aAdd(aPerDobra, {StoD(SubStr(SRR->RR_NUMID,1,8)),StoD(SubStr(SRR->RR_NUMID,12,8)), SRR->RR_HORAS})
			 	ndDobro += SRR->RR_HORAS
			EndIf

			cSeq := SRR->RR_SEQ

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se nao Existir a Verba em aPd acrescenta					 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If lRatProv
				If (AnoMes(SRR->RR_DATA) == cPeriodo .And. SRR->RR_TIPO2 $ "I/E") .Or. ;
				   ( ;
				   		nPosPd := aScan( aPD , { |x|  x[1] == SRR->RR_PD .And. x[11] == SRR->RR_SEQ .And. x[2] == SRR->RR_CC  .And. AnoMes(x[18]) == AnoMes(dDataGer) .Or. ;
													( x[1] == SRR->RR_PD .And. x[11] == SRR->RR_SEQ .And. x[2] == SRR->RR_CC .And. AnoMes(x[18]) <> AnoMes(dDataGer) .And. ;
														( ( SRR->RR_TIPO2 $ "I/E" .And. x[7] $ "I/E" ) .Or. ( SRR->RR_TIPO2 == "G" .And. x[7] == "G" .And. SRR->RR_TIPO1 == "H" .And. x[6] == "H"  ) ) ; 
													) ;
												};
										 ;
										)  ) == 0.00
					aScan(aPd, {|X| If( x[1] == SRR->RR_PD .And. x[11] >= SRR->RR_SEQ .And. x[2] == SRR->RR_CC, cSeq := Soma1(cSeq), cSeq := cSeq) })
					SRR->( fMatriz(RR_PD,RR_VALOR,  If(SRR->RR_TIPO1=="H",fConvHoras(SRR->RR_HORAS,"1"),SRR->RR_HORAS)  ,RR_SEMANA,RR_CC,RR_TIPO1,RR_TIPO2,0,"",dDataPag,NIL,cSeq,,,,If(RR_TIPO2 <> "G",RR_NUMID,Nil),,,dDataGer ) )
				Else
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ A Quantidade Devera ser Sempre a Ultima 					 ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					If !((SRR->RR_TIPO2 == "I" .And. SRR->RR_VALORI > 0 .And. SRR->RR_VALOR == 0) .Or. ; //Complementar da Complementar
					     (SRR->RR_TIPO2 == "G" .And. SRR->RR_TIPO1 == "H" .And. aPd[ nPosPd, 04] == SRR->RR_HORAS .And. SRR->RR_VALORI > 0 .And. SRR->RR_VALOR > 0 )) 
						aPd[ nPosPd, 04 ] := Iif(SRR->RR_TIPO1 == "H", fConvHoras(SRR->RR_HORAS + Iif(lRescDis .And. !lMesDem, aPd[ nPosPd, 04 ], 0), "1"), SRR->RR_HORAS)  
					EndIf

					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Ja os Valores, quando o Mes/Ano da Data de Geracao for igual³
					³ao Mes/Ano da Data de Demissao considera sempre o ultimo  va³
					³lor, C/C o Valores deverao sem Somados pois referem-se a Com³
					³pelentar de Complementar									 ³
					³Obs.: Base IR 13o. sempre deve considerar o valor da ultima ³
					³rescisao porque ela sempre sera composta pelas anteriores.  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF lMesDem .Or. SRR->RR_PD == aCodFol[27,1]
						aPd[ nPosPd , 05 ] := SRR->RR_VALOR
					Else
						aPd[ nPosPd , 05 ] += SRR->RR_VALOR
					EndIf
				EndIf
			Else
				If (AnoMes(SRR->RR_DATA) == cPeriodo .And. SRR->RR_TIPO2 $ "I/E") .Or. ;
				   ( ;
				   		nPosPd := aScan( aPD , { |x|  x[1] == SRR->RR_PD .And. x[11] == SRR->RR_SEQ .And. AnoMes(x[18]) == AnoMes(dDataGer) .Or. ;
													( x[1] == SRR->RR_PD .And. x[11] == SRR->RR_SEQ .And. AnoMes(x[18]) <> AnoMes(dDataGer) .And. ;
														( ( SRR->RR_TIPO2 $ "I/E" .And. x[7] $ "I/E" ) .Or. ( SRR->RR_TIPO2 == "G" .And. x[7] == "G" .And. SRR->RR_TIPO1 == "H" .And. x[6] == "H"  ) ) ; 
													) ;
												};
										 ;
										)  ) == 0.00
					For nCount := (Val(cSeq) + 1) to 9
						If aScan(aPd, {|X| x[1] == SRR->RR_PD .And. x[11] == cSeq  }) > 0
							cSeq := Soma1(cSeq)
						Else
							Exit
						EndIf
					Next nCount

					SRR->( fMatriz(RR_PD,RR_VALOR,  If(SRR->RR_TIPO1=="H",fConvHoras(SRR->RR_HORAS,"1"),SRR->RR_HORAS)  ,RR_SEMANA,RR_CC,RR_TIPO1,RR_TIPO2,0,"",dDataPag,NIL,cSeq,,,,If(RR_TIPO2 <> "G",RR_NUMID,Nil),,,dDataGer ) )
				Else
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ A Quantidade Devera ser Sempre a Ultima 					 ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					If !((SRR->RR_TIPO2 == "I" .And. SRR->RR_VALORI > 0 .And. SRR->RR_VALOR == 0) .Or. ; //Complementar da Complementar
					     (SRR->RR_TIPO2 == "G" .And. SRR->RR_TIPO1 == "H" .And. aPd[ nPosPd, 04] == SRR->RR_HORAS .And. SRR->RR_VALORI > 0 .And. SRR->RR_VALOR > 0 )) 
						aPd[ nPosPd, 04 ] := Iif(SRR->RR_TIPO1 == "H", fConvHoras(SRR->RR_HORAS + Iif(lRescDis .And. !lMesDem, aPd[ nPosPd, 04 ], 0), "1"), SRR->RR_HORAS)  
					EndIf

					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Ja os Valores, quando o Mes/Ano da Data de Geracao for igual³
					³ao Mes/Ano da Data de Demissao considera sempre o ultimo  va³
					³lor, C/C o Valores deverao sem Somados pois referem-se a Com³
					³pelentar de Complementar									 ³
					³Obs.: Base IR 13o. sempre deve considerar o valor da ultima ³
					³rescisao porque ela sempre sera composta pelas anteriores.  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF lMesDem .Or. SRR->RR_PD == aCodFol[27,1]
						aPd[ nPosPd , 05 ] := SRR->RR_VALOR
					Else
						aPd[ nPosPd , 05 ] += SRR->RR_VALOR
					EndIf
				EndIf
			EndIf


			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Obtem os valores de INSS e IR de rescisoes complementares   ³
			³calculadas em meses diferentes da demissao para tratamento  ³
			³especifico quando houver diversas Rescisoes Complementares. ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If !lMesDem	.And. ( nPosPd := aScan( aPD , { |x| x[1] == SRR->RR_PD } ) ) > 0
				If ( aPd[nPosPd,1] $ aCodFol[64,1]+"*"+aCodFol[13,1]+"*"+aCodFol[14,1]+"*"+aCodFol[15,1]+"*"+aCodFol[66,1])
					aAdd( aPdResVals, aClone(aPd[nPosPd]) )
					nPosIns := Len( aPdResVals )
					aPdResVals[nPosIns][05] := SRR->RR_VALOR
					aPdResVals[nPosIns][10] := dDataPag
					aAdd( aPdResVals[nPosIns], SRR->RR_DATA )
				EndIf
			EndIf

			SRR->( dbSkip() )
		EndDo
	EndIf
Next nV

//Caso a verba do ID 0625 esteja cadastrada e não exista no calculo original
//refaz o calculo do 1/3 de ferias vencidas e 1/3 de ferias proporcionais
If !Empty(aCodFol[625,1]) .And. aScan( aPd, { |x| x[1] == aCodFol[625,1] } ) == 0 .And. aScan( aPd, { |x| x[1] == aCodFol[87,1] } ) > 0
	dDataPag := CtoD("")
	lZeraApd := .T.
	For nX := 1 to Len(aPd)
		If !Empty(dDataPag) .and. AnoMes(dDataPag) <> AnoMes(aPd[nX,18])
			aEval( aPd, { |x| If(x[1] == aCodFol[125,1] , x[9] := "D", Nil) } )
			lZeraApd := .F.
			nPerc := fDesc("SRV", aCodFol[125,1], "RV_PERC", Nil, SRA->RA_FILIAL)
			fGeraVerba(aCodfol[125,1], Round( nValTerV * If( nPerc == 0 .Or. nPerc == 100, 1/3, nPerc/100 ), 2 ), 0, Nil, Nil, "V", "R",,,,,,,,,,,,dDataPag)
			nPerc := fDesc("SRV", aCodFol[625,1], "RV_PERC", Nil, SRA->RA_FILIAL)
			fGeraVerba(aCodfol[625,1], Round( nValTerP * If( nPerc == 0 .Or. nPerc == 100, 1/3, nPerc/100 ), 2 ), 0, Nil, Nil, "V", "R",,,,,,,,,,,,dDataPag)
			nValTerV := 0
			nValTerP := 0
			dDataPag  := CtoD("")
		EndIf
		If aPd[nX, 1] $ aCodFol[86,1]+"/"+aCodFol[248,1]
			nValTerV += aPd[nX, 5]
			dDataPag := aPd[nX,18]
		ElseIf aPd[nX, 1] $ aCodFol[87,1]+"/"+aCodFol[249,1]
			nValTerP += aPd[nX, 5]
			dDataPag := aPd[nX,18]
		EndIf
	Next nX
	If lZeraApd
		aEval( aPd, { |x| If(x[1] == aCodFol[125,1] , x[9] := "D", Nil) } )
	EndIf
	nPerc := fDesc("SRV", aCodFol[125,1], "RV_PERC", Nil, SRA->RA_FILIAL)
	fGeraVerba(aCodfol[125,1], Round( nValTerV * If( nPerc == 0 .Or. nPerc == 100, 1/3, nPerc/100 ), 2 ), 0, Nil, Nil, "V", "R",,,,,,,,,,,,dDataPag)
	nPerc := fDesc("SRV", aCodFol[625,1], "RV_PERC", Nil, SRA->RA_FILIAL)
	fGeraVerba(aCodfol[625,1], Round( nValTerP * If( nPerc == 0 .Or. nPerc == 100, 1/3, nPerc/100 ), 2 ), 0, Nil, Nil, "V", "R",,,,,,,,,,,,dDataPag)
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega aPdResc com os Valores Correspondentes			 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
For nX := 1 to Len(aPd)
	aAdd(aPdResc, aPd[nX])
Next nX

aPd		:= {}

RestArea(aArea)

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fChkDtHom    ³ Autor ³ Luciana Silveira      ³ Data ³ 12/01/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Checar a Data de Homologacao do Funcionario 				     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso	     ³GPEM040													     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fChkDtHom( dDataDem , dDataHom  )
Local lRet		:= .T.

lChkDtHom := If( Type("P_CHKDTHOM")=="U",.T.,P_CHKDTHOM)

If lChkDtHom
	If dDataHom < dDataDem
		lRet := .F.
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0106), 1, 0 ) //"Data de Homologação não pode ser inferior a Demissão"
	EndIf
EndIf

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RrFuncInitºAutor  ³Silvia Taguti       º Data ³  07/19/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Inicializador Padrao para o campo RR_CODFUNC                º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RRFuncInit()

Return( SRA->RA_CODFUNC )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gpm040Fin ºAutor  ³Mauricio Takakura   º Data ³  28/03/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Aplicacao do Finiquitos para um calculo - Somente Mexico    º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Gpm040Fin( nTipo, cRoteir, cPer, cNPgto, cProc, aParam )	// 1-Aplicacao Rescisao; 2-Reversao Rescisao

Local aPerAtual	:= {}
Local aSRGHeader:= {}
Local aSRGCols	:= {}
Local aSRRHeader:= {}
Local aSRRCols	:= {}

Local bSet15	  := { || lRet := .T., oDlg:End() }
Local bSet24	  := { || lRet := .F., oDlg:End() }
Local bDialogInit := {}

Local cTitle
Local cTipoRot 	:= fGetTipoRot( cRoteir )
Local cRotDesc
Local cSvRoteir := cRoteir
Local cSvPer	:= cPer
Local cSvNPgto	:= cNPgto

Local cFil		:= ""
Local cMat		:= ""

Local lRet 		:= .t.

Local nNextRecno 	:= 0
Local nRecno 		:= 0
Local nOrder 		:= 0

Local oDlg

Local lGpm040ReApl
Local lGpm040AplRes
Local lRetGpm040Apl := .F.
Local oGetRef		:= Nil
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

Local aAdv1Size		:= {}
Local aInfo1AdvSize	:= {}
Local aObj1Size		:= {}
Local aObj1Coords 	:= {}

Local aAdv2Size		:= {}
Local aInfo2AdvSize	:= {}
Local aObj2Size		:= {}
Local aObj2Coords 	:= {}

DEFAULT nTipo 	  := 0
DEFAULT cProcesso := ""
DEFAULT cProc	  := ""
DEFAULT cRoteir	  := ""
DEFAULT cPer 	  := ""
DEFAULT cNPgto	  := ""

lGpm040ReApl := ExistBlock( "GPM040RA" )
lGpm040AplRes:= ExistBlock( "GPM040AR" )

If ( nTipo == 2 )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Ponto de Entrada para nao verificacao da Situacao da Folha   ³
	³ em caso de Reversao da Aplicacao de Rescisao				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If ( lGpm040ReApl )
		oGetRef := oGet
		lRetGpm040Apl := ExecBlock("GPM040RA")
		If !( ValType(lRetGpm040Apl) == "L" )
			lRetGpm040Apl := .F.
		EndIf
		oGet := oGetRef
	EndIf

EndIf

If ( MV_MODFOL == "2" )

	If (nTipo == 1 .and. cTipoRot <> "4") .Or. (nTipo == 2 .and. cTipoRot <> "A")
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0107),1,0 ) //"Tipo de Roteiro Diferente do Solicitado!"###"Atencao"
		Return( .F. )
	Else

		If nTipo == 1
			cRoteir := fGetCalcRot('A')	// Aplicacao de Finiquito
		ElseIf nTipo == 2
			If (AllTrim(SRA->RA_SITFOLH) == "D") .or. lRetGpm040Apl
				cRoteir := fGetCalcRot('4')	// Reversao de Aplicacao de Rescisao
			Else
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0108),1,0 ) //"A reversao só pode ser feita para funcionários demitidos"
				Return( .F. )
			EndIf
		EndIf

		lRet := fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, cRoteir ) // Busca o periodo aberto para trabalho
		If lRet
			cPer		:= aPerAtual[1,1]
			cNPgto 		:= aPerAtual[1,2]
		Else
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0082),1,0 ) //"Periodo nao cadastrado para o Roteiro selecionado!"###"Atencai"
			Return( lRet )
		EndIf
		If nTipo == 1 .and. cTipoRot == "4"
			cTitle := OemToAnsi(STR0110) // "Aplicacao de Rescisao"
		Else
			cTitle := OemToAnsi(STR0111) // "Reversao da Aplicacao de Rescisao"
		EndIf
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para a Inicializacao do Dialog            	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bDialogInit		:= { ||;
								CursorWait()													,;
								EnchoiceBar( oDlg , bSet15 , bSet24, NIL  )						,;
								CursorArrow()												 	 ;
					   }

	aAdvSize        := MsAdvSize( ,.T.,370)

	aInfoAdvSize    := { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
	aAdd( aObjCoords , { 040 , 000 , .T. , .T. } )
	aAdd( aObjCoords , { 060 , 000 , .T. , .T. } )
	aObjSize    := MsObjSize( aInfoAdvSize , aObjCoords, .T., .T. )

	aAdv1Size    := aClone(aObjSize[1])

	aInfo1AdvSize    := { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 5 , 5 }
	aAdd( aObj1Coords , { 000 , 020 , .T. , .F. } )
	aAdd( aObj1Coords , { 000 , 020 , .T. , .F. } )
	aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
	aObj1Size := MsObjSize( aInfo1AdvSize , aObj1Coords )

	aAdv2Size    := aClone(aObjSize[2])

	aInfo2AdvSize    := { aAdv2Size[2] , aAdv2Size[1] , aAdv2Size[4] , aAdv2Size[3] , 5 , 5 }
	aAdd( aObj2Coords , { 000 , 020 , .T. , .F. } )
	aAdd( aObj2Coords , { 000 , 020 , .T. , .F. } )
	aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )
	aObj2Size := MsObjSize( aInfo2AdvSize , aObj2Coords )

	DEFINE MSDIALOG oDlg TITLE cTitle FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() STYLE DS_MODALFRAME PIXEL
		oDlg:lEscClose := .F. // Nao permite sair ao se pressionar a tecla ESC.

		If ExistCpo("SRY", cRoteir)
			cRotDesc := Posicione("SRY",1,xFilial("SRY")+cRoteir, "RY_DESC")
		EndIf


		@ aObj1Size[1,1]	, aObj1Size[1,2] 		SAY   OemToAnsi(STR0085) SIZE 033,007 OF oDlg PIXEL	//"Periodo: "
		@ aObj1Size[1,1]	, aObj1Size[1,2]+55 	MSGET cPer SIZE 040,007	OF oDlg PIXEL WHEN .F.

		@ aObj1Size[2,1]	, aObj1Size[2,2] 		SAY   OemToAnsi(STR0086) SIZE 038,007 OF oDlg PIXEL	//"Nro Pagto: "
		@ aObj1Size[2,1]	, aObj1Size[2,2]+55 	MSGET cNPgto SIZE 040,007	OF oDlg PIXEL WHEN .F.

		@ aObj1Size[3,1]	, aObj1Size[3,2] 		SAY OemToAnsi(STR0112) SIZE 033,007 OF oDlg PIXEL	//"Tipo Folha: "
		@ aObj2Size[3,1]	, aObj2Size[3,2] 		SAY OemToAnsi(STR0088) SIZE 033,007 OF oDlg PIXEL	//"Descricao: "
		@ aObj1Size[3,1]	, aObj1Size[3,2]+55 	MSGET cRoteir  SIZE 040,007	OF oDlg PIXEL WHEN .F. PICTURE PesqPict("SRY","RY_CALCULO")
		@ aObj2Size[3,1]	, aObj2Size[3,2]+55 	MSGET cRotDesc SIZE 110,007	OF oDlg PIXEL WHEN .F.

	ACTIVATE DIALOG oDlg ON INIT Eval( bDialogInit ) CENTERED

	If !lRet
		cRoteir := cSvRoteir
		cPer 	:= cSvPer
		cNPgto 	:= cSvNPgto
	Else
		// Alterar o periodo do Calculo de Finiquitos para Aplicacao de Finiquitos
	    DbSelectArea( "SRC" )
	    nOrder := RetOrdem("SRC","RC_FILIAL+RC_MAT+RC_PROCES+RC_ROTEIR+RC_PERIODO+RC_SEMANA")
	    DbSetOrder( nOrder )
	    DbSeek(SRA->(RA_FILIAL+RA_MAT+RA_PROCES)+cSvRoteir+cSvPer+cSvNPgto, .F.)

		Begin Transaction
		    While SRC->( !Eof() ) .and. SRC->( RC_FILIAL+RC_MAT+RC_PROCES+RC_ROTEIR+RC_PERIODO+RC_SEMANA) == SRA->(RA_FILIAL+RA_MAT+RA_PROCES)+cSvRoteir+cSvPer+cSvNPgto

		   		/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Obtem o Proximo Registro                    				   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If !GetNextRecno( "SRC", @nNextRecno , @nRecno , nOrder )
					Exit
				EndIf

				RecLock( "SRC", .F.)
				SRC->RC_PERIODO := cPer
				SRC->RC_ROTEIR	:= cRoteir
				SRC->RC_SEMANA 	:= cNPgto
				MsUnlock()

				If !GotoNextRecno( "SRC" , nNextRecno , nOrder )
					Exit
				EndIf

		    EndDo
		End Transaction

		If lRet
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0089),1,0 ) //"Processo Concluido com Sucesso!"###"Atencao"
			oGet:Refresh()

			If ( lGpm040AplRes )
				oGetRef := oGet
				ExecBlock( "GPM040AR",.F.,.F.,{cRoteir, cPer, cNPgto, cProcesso, SRA->RA_MAT})
				oGet := oGetRef
			EndIf

		EndIf
	EndIf

ElseIf ( MV_MODFOL == "1" )

	cFil		:= aParam[01]
	cMat		:= aParam[02]
	aSRGHeader	:= aParam[03]
	aSRGCols	:= aParam[04]
	aSRRHeader	:= aParam[05]
	aSRRCols	:= aParam[06]

	bSet15		:= { || lRet := .T.,;
					aParam := { cProc, cPer, cRoteir, cNPgto },;
					If ( lRet := fPerClose( cProc, cPer, cNPgto, cRoteir, 2 ),;
					fRecAplFin( cFilial, cMat, SRG->RG_DTGERAR, {}, aParam, aSRGHeader, aSRGCols, aSRRHeader, aSRRCols, .T. ),;
					.F. ) ,;
					If ( lRet, oDlg:End(), Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0109),,1,0 ) ); //"Periodo nao Cadastrado!" - "Atenção"
				}
	bSet24		:= { || lRet := .F., oDlg:End() }
	bDialogInit := {}

	lRet 		:= .T.

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para a Inicializacao do Dialog            	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bDialogInit		:= { ||;
								CursorWait()													,;
								EnchoiceBar( oDlg , bSet15 , bSet24, NIL  )						,;
								CursorArrow()												 	 ;
					   }

	aAdvSize        := MsAdvSize( ,.T.,370)

	aInfoAdvSize    := { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
	aAdd( aObjCoords , { 040 , 000 , .T. , .T. } )
	aAdd( aObjCoords , { 060 , 000 , .T. , .T. } )
	aObjSize    := MsObjSize( aInfoAdvSize , aObjCoords, .T., .T. )

	aAdv1Size    := aClone(aObjSize[1])

	aInfo1AdvSize    := { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 5 , 5 }
	aAdd( aObj1Coords , { 000 , 020 , .T. , .F. } )
	aAdd( aObj1Coords , { 000 , 020 , .T. , .F. } )
	aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
	aObj1Size := MsObjSize( aInfo1AdvSize , aObj1Coords )

	aAdv2Size    := aClone(aObjSize[2])

	aInfo2AdvSize    := { aAdv2Size[2] , aAdv2Size[1] , aAdv2Size[4] , aAdv2Size[3] , 5 , 5 }
	aAdd( aObj2Coords , { 000 , 020 , .T. , .F. } )
	aAdd( aObj2Coords , { 000 , 020 , .T. , .F. } )
	aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )
	aObj2Size := MsObjSize( aInfo2AdvSize , aObj2Coords )

	DEFINE MSDIALOG oDlg TITLE cTitle FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() STYLE DS_MODALFRAME PIXEL
		oDlg:lEscClose := .F. // Nao permite sair ao se pressionar a tecla ESC.

		If ExistCpo("SRY", cRoteir)
			cRotDesc := Posicione("SRY",1,xFilial("SRY")+cRot, "RY_DESC")
		EndIf

		@ aObj1Size[1,1]	,aObj1Size[1,2] SAY OemToAnsi(STR0087) SIZE 033,007 OF oDlg PIXEL	//"Roteiro: "
		@ aObj2Size[1,1]	,aObj2Size[1,2] SAY OemToAnsi(STR0088) SIZE 033,007 OF oDlg PIXEL	//"Descricao: "

		@ aObj1Size[1,1]	,aObj1Size[1,2]+55 MSGET oRoteiro VAR cRoteir  SIZE 040,007	OF oDlg PIXEL PICTURE "@!" F3 'SRYRES' VALID NaoVazio() .And. ExistCpo("SRY")
		oRoteiro:bValid		:= { || cRot := cRoteir,;
									cRotDesc := Posicione("SRY",1,xFilial("SRY")+cRoteir, "RY_DESC") }
		@ aObj2Size[1,1]	, aObj2Size[1,2]+55 MSGET oRotDescr VAR cRotDesc SIZE 110,007	OF oDlg PIXEL WHEN .F.

		@ aObj1Size[2,1]	, aObj1Size[2,2] SAY   OemToAnsi(STR0085) SIZE 033,007 OF oDlg PIXEL	//"Periodo: "
		@ aObj1Size[2,1]	, aObj1Size[2,2]+55 MSGET oPeriodo VAR cPer SIZE 040,007	OF oDlg PIXEL F3 'RCH' VALID NaoVazio()
		oPeriodo:bValid		:= { || cPeriodo := cPer }

		@ aObj1Size[3,1]	, aObj1Size[3,2] SAY   OemToAnsi(STR0086) SIZE 038,007 OF oDlg PIXEL	//"Nro Pagto: "
		@ aObj1Size[3,1]	, aObj1Size[3,2]+55 MSGET oNumPag VAR cNPgto SIZE 040,007	OF oDlg PIXEL WHEN ( .F. ) F3 'RCH01'
		oNumPag:bValid := { || cNumPag := cNPgto }

		@ aObj2Size[3,1]    , aObj2Size[3,2] SAY   OemToAnsi(STR0090) SIZE 033,007 OF oDlg PIXEL	//"Processo: "
		@ aObj2Size[3,1]    , aObj2Size[3,2]+55 MSGET oProcesso VAR cProc SIZE 040,007	OF oDlg PIXEL WHEN .F.
		oProcesso:bValid := { || cProcesso := cProc }

	ACTIVATE DIALOG oDlg ON INIT Eval( bDialogInit ) CENTERED

EndIf

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fPerClose ºAutor  ³Igor Franzoi        º Data ³  01/12/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Verifica se o periodo esta fechado						  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fPerClose( cProcesso, cPeriodo, cNumPag, cRoteiro, nOption )

Local aArea		:= GetArea()

Local cFilRCH	:= ""

Local lRet 		:= .F.

Local bCondRCH	:= {}
DEFAULT nOption := 1
If ( Type("cProcesso") == "U" .or. Empty(cProcesso) )
	cProcesso := Space( GetSx3Cache("RCH_PROCES", "X3_TAMANHO") )
EndIf
If ( Type("cPeriodo") == "U" .or. Empty(cPeriodo) )
	cPeriodo := Space( GetSx3Cache("RCH_PER", "X3_TAMANHO") )
EndIf
If ( Type("cNumPag") == "U" .or. Empty(cNumPag) )
	cNumPag := Space( GetSx3Cache("RCH_PER", "X3_TAMANHO") )
EndIf
If ( Type("cRoteiro") == "U" .or. Empty(cRoteiro) )
	cRoteiro := Space( GetSx3Cache("RCH_ROTEIR", "X3_TAMANHO") )
EndIf

Begin Sequence

 	If Empty( cProcesso )
 		lRet := .F.
		Break
	EndIf

	cFilRCH	:= xFilial("RCH",SRA->RA_FILIAL)
	DbSelectArea("RCH")
	If ( nOption == 1 .or. nOption == 2 )
		RCH->( dbsetOrder( Retorder( "RCH" , "RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR" ) ) )
		RCH->( dbSeek( cFilRCH + cProcesso + cPeriodo + cNumPag + cRoteiro, .F. ) )
		bCondRCH := { || (RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR) == (cFilRCH + cProcesso + cPeriodo + cNumPag + cRoteiro ) }
	ElseIf ( nOption == 3 )
		RCH->( dbsetOrder( Retorder( "RCH" , "RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG" ) ) )
		RCH->( dbSeek( cFilRCH + cProcesso + cRoteiro, .F. ) )
		bCondRCH := { || (RCH_FILIAL+RCH_PROCES+RCH_ROTEIR) == (cFilRCH + cProcesso + cRoteiro ) }
	Else
		RCH->( dbsetOrder( Retorder( "RCH" , "RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR" ) ) )
		RCH->( dbSeek( cFilRCH + cProcesso + cPeriodo + cNumPag + cRoteiro, .F. ) )
		bCondRCH := { || (RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR) == (cFilRCH + cProcesso + cPeriodo + cNumPag + cRoteiro ) }
	EndIf
	While RCH->( !Eof() .and. Eval(bCondRCH) )
		//Verifica se o período esta fechado - Padrao
		If ( nOption == 1 )
			If !Empty( RCH_DTFECH )
				lRet := .T.
				Exit
			EndIf
		//Localiza o período, se não existe retorna .F.
		ElseIf ( nOption == 2 )
			lRet := .T.
		//Retorna no conteúdo das variaveis, o último período de rescisão em aberto
		ElseIf ( nOption == 3 )

			//Se o roteiro for igual ao de rescisao e periodo aberto
			If ( fGetTipoRot( RCH->RCH_ROTEIR ) == '4' .and. Empty(RCH->RCH_DTFECH) )

				cNumPag		:= RCH->RCH_NUMPAG
				cRoteiro	:= RCH->RCH_ROTEIR
				cPeriodo	:= RCH->RCH_PER
				cProcesso	:= RCH->RCH_PROCES

				lRet := .T.

			EndIf

		EndIf
		RCH->( dbSkip() )
	EndDo

End Sequence

RestArea( aArea )

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fRecAplFinºAutor  ³Igor Franzoi        º Data ³  02/12/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Grava a aplicação na tabela SRC     						  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fRecAplFin( cFil, cMat, dDataGer, aDataFrom, aDataTo, aHeaderSRG, aColsSRG, aHeaderSRR, aColsSRR, lWindow, lMsg )

Local lRet		:= .F.
Local lDupl		:= .F.

Local cAliasSRC	:= "SRC"

//Periodo PARA
Local cRot		:= Space( GetSx3Cache("RCH_ROTEIR", "X3_TAMANHO") )
Local cNumPag	:= Space( GetSx3Cache("RCH_NUMPAG", "X3_TAMANHO") )
Local cPeriodo	:= Space( GetSx3Cache("RCH_PER"	  , "X3_TAMANHO") )
Local cProcesso	:= Space( GetSx3Cache("RCH_PROCES", "X3_TAMANHO") )

//Periodo DE
Local cRotFrom	  := Space( GetSx3Cache("RCH_ROTEIR", "X3_TAMANHO") )
Local cNumPagFrom := Space( GetSx3Cache("RCH_NUMPAG", "X3_TAMANHO") )
Local cPeriodFrom := Space( GetSx3Cache("RCH_PER"	  , "X3_TAMANHO") )
Local cProcesFrom := Space( GetSx3Cache("RCH_PROCES", "X3_TAMANHO") )

Local cJoin		:= ""
Local cWhere	:= ""
Local cQuery	:= ""
Local cKeySRC	:= ""
Local cMsgAlert := ""

Local nRecnoSRG := ""
Local nOrderSRC := RetOrdem("SRC","RC_FILIAL+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ+Dtos(RC_DTREF)")

Local nPosPD	:= ""
Local nPosTipo1	:= ""
Local nPosHorInf:= ""
Local nPosHoras	:= ""
Local nPosValInf:= ""
Local nPosValor	:= ""
Local nPosTipo2	:= ""
Local nPosData	:= ""
Local nPosDataPg:= ""
Local nPosSeq	:= ""
Local nPosCC	:= ""
Local nPosNumID	:= ""

Local nContCols	  := 0

DEFAULT lMsg	:= .T.
DEFAULT lWindow := .F.

cRot		:= aDataTo[03]
cNumPag		:= aDataTo[04]
cPeriodo	:= aDataTo[02]
cProcesso	:= aDataTo[01]

dbSelectArea("SRG")
dbSetOrder(RetOrder("SRG","RG_FILIAL+RG_MAT+DTOS(RG_DTGERAR)"))
SRG->(dbSeek(cFil+cMat+Dtos(dDataGer)))
nRecnoSRG := SRG->(Recno())

//Efetua gravação conforme os parametros utilizados na aplicação através da tela
If lWindow

	nPosPD		:= GdFieldPos( "RR_PD", aHeaderSRR )
	nPosTipo1	:= GdFieldPos( "RR_TIPO1", aHeaderSRR )
	nPosHorInf	:= GdFieldPos( "RR_HORINFO", aHeaderSRR )
	nPosHoras	:= GdFieldPos( "RR_HORAS", aHeaderSRR )
	nPosValInf	:= GdFieldPos( "RR_VALINFO", aHeaderSRR )
	nPosValor	:= GdFieldPos( "RR_VALOR", aHeaderSRR )
	nPosTipo2	:= GdFieldPos( "RR_TIPO2", aHeaderSRR )
	nPosData	:= GdFieldPos( "RR_DATA", aHeaderSRR )
	nPosDataPg	:= GdFieldPos( "RR_DATAPAG", aHeaderSRR )
	nPosSeq		:= GdFieldPos( "RR_SEQ", aHeaderSRR )
	nPosCC		:= GdFieldPos( "RR_CC", aHeaderSRR )
	nPosNumID	:= GdFieldPos( "RR_NUMID", aHeaderSRR )

    Begin Transaction

	    DbSelectArea( cAliasSRC )
	    (cAliasSRC)->(DbSetOrder( nOrderSRC ))

		For nContCols := 1	To Len(aColsSRR)

			cKeySRC := cFil+cMat+cPeriodo+cNumPag+cRot+aColsSRR[ nContCols, nPosPD ]+aColsSRR[ nContCols, nPosCC ]+aColsSRR[ nContCols, nPosSeq ]+Dtos(aColsSRR[ nContCols, nPosData ])

			If !(cAliasSRC)->(DbSeek(cKeySRC))
				RecLock(cAliasSRC,.T.)

					(cAliasSRC)->RC_FILIAL	:= cFil
					(cAliasSRC)->RC_MAT		:= cMat
					(cAliasSRC)->RC_PD		:= aColsSRR[ nContCols, nPosPD ]
					(cAliasSRC)->RC_TIPO1	:= aColsSRR[ nContCols, nPosTipo1 ]
					(cAliasSRC)->RC_HORINFO	:= aColsSRR[ nContCols, nPosHorInf ]
					(cAliasSRC)->RC_HORAS	:= aColsSRR[ nContCols, nPosHoras ]
					(cAliasSRC)->RC_VALINFO	:= aColsSRR[ nContCols, nPosValInf ]
					(cAliasSRC)->RC_VALOR	:= aColsSRR[ nContCols, nPosValor ]
					(cAliasSRC)->RC_DATA	:= aColsSRR[ nContCols, nPosDataPg ]
					(cAliasSRC)->RC_DTREF	:= aColsSRR[ nContCols, nPosData ]
					(cAliasSRC)->RC_SEMANA	:= cNumPag
					(cAliasSRC)->RC_CC		:= aColsSRR[ nContCols, nPosCC ]
					(cAliasSRC)->RC_TIPO2	:= aColsSRR[ nContCols, nPosTipo2 ]
					(cAliasSRC)->RC_SEQ		:= aColsSRR[ nContCols, nPosSeq ]
					(cAliasSRC)->RC_PROCES	:= cProcesso
					(cAliasSRC)->RC_PERIODO	:= cPeriodo
					(cAliasSRC)->RC_POSTO	:= SRA->RA_POSTO
					(cAliasSRC)->RC_NUMID	:= aColsSRR[ nContCols, nPosNumID ]
					(cAliasSRC)->RC_ROTEIR	:= cRot
					(cAliasSRC)->RC_CODFUNC	:= SRA->RA_CODFUNC

				(cAliasSRC)->(MsUnlock())
				lRet := .T.
			Else
				lDupl := .T.
			EndIf
		Next

	End Transaction

Else

	cRotFrom	:= aDataFrom[03]
	cNumPagFrom	:= aDataFrom[04]
	cPeriodFrom := aDataFrom[02]
	cProcesFrom := aDataFrom[01]

	#IFDEF TOP

		cJoin := "%"
		cJoin += " SRR.RR_FILIAL  = SRG.RG_FILIAL  AND "
		cJoin += " SRR.RR_MAT 	  = SRG.RG_MAT 	   AND "
		cJoin += " SRR.RR_PROCES  = SRG.RG_PROCES  AND "
		cJoin += " SRR.RR_PERIODO = SRG.RG_PERIODO AND "
		cJoin += " SRR.RR_SEMANA  = SRG.RG_SEMANA  AND "
		cJoin += " SRR.RR_ROTEIR = SRG.RG_ROTEIR	   "
		cJoin += "%"

		cWhere := "%"
		cWhere += " SRG.RG_FILIAL 	= '" + cFil + "' AND "
		cWhere += " SRG.RG_MAT 		= '" + cMat + "' AND "
		cWhere += " SRG.RG_PROCES 	= '" + cProcesFrom + "' AND "
		cWhere += " SRG.RG_PERIODO 	= '" + cPeriodFrom + "' AND "
		cWhere += " SRG.RG_SEMANA 	= '" + cNumPagFrom + "' AND "
		cWhere += " SRG.RG_ROTEIR 	= '" + cRotFrom	+ "' "
		cWhere += "%"

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Seleciona os dados na tabela SRR - aDataFrom				  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cQuery := GetNextAlias()
		BeginSql alias cQuery
			column RR_DATA AS Date, RR_DATAPAG AS Date
			SELECT
				SRR.RR_PD, SRR.RR_TIPO1, SRR.RR_HORINFO, SRR.RR_HORAS, SRR.RR_VALINFO, SRR.RR_VALOR,
				SRR.RR_TIPO2, SRR.RR_DATA, SRR.RR_DATAPAG, SRR.RR_SEQ, SRR.RR_CC, SRR.RR_NUMID
			FROM 		%table:SRG% SRG
			INNER JOIN  %table:SRR% SRR
			ON 			%exp:cJoin%
			WHERE
						%exp:cWhere% AND
						SRG.%NotDel% AND
						SRR.%NotDel%
		EndSql

	    DbSelectArea( cAliasSRC )
	    (cAliasSRC)->(DbSetOrder( nOrderSRC ))

		While (cQuery)->( !Eof() )

			cKeySRC := cFil+cMat+cPeriodo+cNumPag+cRot+(cQuery)->RR_PD+(cQuery)->RR_CC+(cQuery)->RR_SEQ+Dtos((cQuery)->RR_DATA)

			If !(cAliasSRC)->(DbSeek(cKeySRC))
				RecLock(cAliasSRC,.T.)

					(cAliasSRC)->RC_FILIAL	:= cFil
					(cAliasSRC)->RC_MAT		:= cMat
					(cAliasSRC)->RC_PD		:= (cQuery)->RR_PD
					(cAliasSRC)->RC_TIPO1	:= (cQuery)->RR_TIPO1
					(cAliasSRC)->RC_HORINFO	:= (cQuery)->RR_HORINFO
					(cAliasSRC)->RC_HORAS	:= (cQuery)->RR_HORAS
					(cAliasSRC)->RC_VALINFO	:= (cQuery)->RR_VALINFO
					(cAliasSRC)->RC_VALOR	:= (cQuery)->RR_VALOR
					(cAliasSRC)->RC_DATA	:= (cQuery)->RR_DATAPAG
					(cAliasSRC)->RC_DTREF	:= (cQuery)->RR_DATA
					(cAliasSRC)->RC_SEMANA	:= cNumPag
					(cAliasSRC)->RC_CC		:= (cQuery)->RR_CC
					(cAliasSRC)->RC_TIPO2	:= (cQuery)->RR_TIPO2
					(cAliasSRC)->RC_SEQ		:= (cQuery)->RR_SEQ
					(cAliasSRC)->RC_PROCES	:= cProcesso
					(cAliasSRC)->RC_PERIODO	:= cPeriodo
					(cAliasSRC)->RC_POSTO	:= SRA->RA_POSTO
					(cAliasSRC)->RC_NUMID	:= (cQuery)->RR_NUMID
					(cAliasSRC)->RC_ROTEIR	:= cRot
					(cAliasSRC)->RC_CODFUNC	:= SRA->RA_CODFUNC

				(cAliasSRC)->(MsUnlock())
				lRet := .T.
			Else
				lDupl := .T.
			EndIf

			(cQuery)->(dbSkip())

		EndDo

	#Else

		cJoin	:= ""
		cWhere	:= ""
		dbSelectArea("SRR")
		dbSetOrder(RetOrder("SRR","RR_FILIAL+RR_MAT+RR_PERIODO+RR_ROTEIR+RR_SEMANA+RR_PD+RR_CC+RR_SEQ+Dtos(RR_DATA)"))

	    DbSelectArea( cAliasSRC )
	    (cAliasSRC)->(DbSetOrder( nOrderSRC ))

		While( !Eof() .and. RR_FILIAL + RR_MAT + RR_PERIODO == cFil + cMat + cPeriodFrom + cRotFrom + cNumPagFrom .and. SRG->RG_DTGERAR == RR_DATA )

			cKeySRC := cFil+cMat+cPeriodo+cNumPag+cRot+RR_PD+RR_CC+RR_SEQ+Dtos(RR_DATA)

			If !(cAliasSRC)->(DbSeek(cKeySRC))
				RecLock(cAliasSRC,.T.)

					(cAliasSRC)->RC_FILIAL	:= cFil
					(cAliasSRC)->RC_MAT		:= cMat
					(cAliasSRC)->RC_PD		:= (cQuery)->RR_PD
					(cAliasSRC)->RC_TIPO1	:= (cQuery)->RR_TIPO1
					(cAliasSRC)->RC_HORINFO	:= (cQuery)->RR_HORINFO
					(cAliasSRC)->RC_HORAS	:= (cQuery)->RR_HORAS
					(cAliasSRC)->RC_VALINFO	:= (cQuery)->RR_VALINFO
					(cAliasSRC)->RC_VALOR	:= (cQuery)->RR_VALOR
					(cAliasSRC)->RC_DATA	:= (cQuery)->RR_DATAPAG
					(cAliasSRC)->RC_DTREF	:= (cQuery)->RR_DATA
					(cAliasSRC)->RC_SEMANA	:= cNumPag
					(cAliasSRC)->RC_CC		:= (cQuery)->RR_CC
					(cAliasSRC)->RC_TIPO2	:= (cQuery)->RR_TIPO2
					(cAliasSRC)->RC_SEQ		:= (cQuery)->RR_SEQ
					(cAliasSRC)->RC_PROCES	:= cProcesso
					(cAliasSRC)->RC_PERIODO	:= cPeriodo
					(cAliasSRC)->RC_POSTO	:= SRA->RA_POSTO
					(cAliasSRC)->RC_NUMID	:= (cQuery)->RR_NUMID
					(cAliasSRC)->RC_ROTEIR	:= cRot
					(cAliasSRC)->RC_CODFUNC	:= SRA->RA_CODFUNC

				(cAliasSRC)->(MsUnlock())
				lRet := .T.
			Else
				lDupl := .T.
			EndIf

			SRR->(dbSkip())

		EndDo

	#EndIf

EndIf

If lDupl
	If lMsg
		cMsgAlert := OemToAnsi(STR0098) + CRLF			//"Registros duplicado!"
		cMsgAlert += OemToAnsi(STR0099) + "SRC" + CRLF  //"Tabela: "
		Help( ,, OemToAnsi(STR0020),, cMsgAlert,,1,0 ) //"Atenção"
EndIf
EndIf

//Grava flag de Aplicação de rescisão
If lRet
	If(cPaisLoc == 'MEX')
		dbSelectArea("SRG")
		SRG->(dbGoTo(nRecnoSRG))
		If ( SRG->RG_STSAPL != "1" )
			RecLock("SRG",.F.)
				SRG->RG_STSAPL := "1"
			SRG->(MsUnlock())
		EndIf
	EndIf
EndIf

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RRProces  ºAutor  ³Igor Franzoi        º Data ³  03/12/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Inicializador padrao do campo processo					  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RRProces()

Local cProc	:= Space( GetSx3Cache("RCH_PROCES", "X3_TAMANHO") )

If ( ValType("cProcesso") != "U" )
	cProc := cProcesso
Else
	cProc := SRA->RA_PROCES
EndIf

Return (cProc)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fImpPonto  ºAutor  ³RH                  º Data ³  02/07/07     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Importa resultado do Ponto Eletronico para a rescisao(utili-  º±±
±±º          ³ zado para importacao de resultados do periodo de apontamento  º±±
±±º          ³ do mes da rescisao, em rescisao calculada para o mes seguinte º±±
±±º          ³ ao mes em aberto na folha).                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ dDataDe    = Data inicial do periodo p/ importar os resultadosº±±
±±º          ³ dDataAte   = Data final do periodo p/ importar os resultados  º±±
±±º          ³ nSubsLct   = Opcao para lctos. ja existentes na rescisao      º±±
±±º          ³ lIsGPEM040 = .T.-Calculo GPEM040; .F.-Calculo GPEM630         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fImpPonto( dDataDe, dDataAte, nSubsLct, lIsGPEM040, aLogFile )

Local aDetSPB 			:= {}
Local aDetSPBAux		:= {}
Local aCabSPB			:= {}
Local aCabSPBAux		:= {}
Local aSpbRecnos		:= {}
Local aSpbRecAux		:= {}
Local aPerAtual			:= {}
Local aNotFields		:= {"PB_FILIAL", "PB_MAT"}
Local aRetSRV
Local aSvKeys			:= GetKeys()
Local cFil				:= SRA->RA_FILIAL
Local cMat				:= SRA->RA_MAT
Local cKey				:= ( ( cFil + cMat ) )
Local cPonMes			:= GetPonMes()
Local cProcFol			:= 	""
Local cRotFol			:=	""
Local cPerFol			:=	""
Local cNPagFol			:= 	""
Local bKey 				:= { || SPB->(PB_FILIAL + PB_MAT) }
Local bSkip				:= { || (SPB->PB_DATA > dDataAte .Or. SPB->PB_DATA < dDataDe) }
Local bSkip1			:= { || .T. }
Local lComisPuro		:= .F.
Local nPosPBPd			:= 0
Local nPosPBVlr			:= 0
Local nPosPBHrs 		:= 0
Local nPosPBTp1			:= 0
Local nPosPBTp2			:= 0
Local nPosPBSem			:= 0
Local nPosPBDtPg		:= 0
Local nPosPBCc			:= 0
Local nPosPBDel			:= 0
Local nPosPBAWT			:= 0
Local nPosPBRWT			:= 0
Local nPosPBRot			:= 0
Local nx				:= 0
Local ny				:= 0
Local nPos				:= 0.00
Local nOpcA 			:= 0.00
Local oFont
Local oRadio
Local oGroup
Local dPerIni			:= CtoD("")
Local dPerFim			:= CtoD("")
Local dPonMes			:= CtoD( Substr(cPonMes, 7, 2) + "/" + Substr(cPonMes, 5, 2) + "/" + Substr(cPonMes, 1, 4) )
Local lItemClVl   		:= SuperGetMv( "MV_ITMCLVL", .F., "2" ) $ "1*3"
Local lContinua			:= .T.
Local aAdvSize			:= {}
Local aInfoAdvSize		:= {}
Local aObjCoords   		:= {}
Local aObjSize			:= {}
Local dBkpAvis 			:= CtoD("")

DEFAULT	aLogFile		:= {}
DEFAULT nSubsLct		:= 2 //Opcao para lancamentos ja existentes: 1-Substitui;2-Despreza;3-Soma
DEFAULT dDataDe			:= CtoD("") //Data inicial do periodo para importacao do Ponto
DEFAULT dDataAte		:= CtoD("") //Data final do periodo para importacao do Ponto
DEFAULT lIsGPEM040		:= .T. //Calculo de rescisao via GPEM040

If cPaisLoc == "BRA"
	dBkpAvis 	:= dDataAvis
EndIf

aAdvSize		:= MsAdvSize()
aAdvSize[5]		:=	500 //horizontal
aAdvSize[3]		:=	252 // LARGURA
aAdvSize[4]		:=	87  // ALTURA
aAdvSize[6]		:=  200 //Vertical
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 2 , 2 }
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
aObjSize			:= MsObjSize( aInfoAdvSize , aObjCoords )

If lIsGPEM040
	If Empty(dPonMes)
		MsgAlert(STR0064)   //Parametro MV_PONMES deve estar preenchido para que a importação seja executada
		Return NIl
	EndIf

	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg1 FROM  aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] TITLE OemToAnsi( STR0065 ) OF oMainWnd PIXEL //Integração de dados do Ponto Eletronico

		@ aObjSize[1][1]-30,aObjSize[1][2]	GROUP oGroup TO aObjSize[1][3]-10,aObjSize[1][4] LABEL OemToAnsi(STR0066) OF oDlg1 PIXEL	//"Informações para busca dos resultados:"
		oGroup:oFont:=oFont

		@ aObjSize[1][1]-10,aObjSize[1][2]+10 SAY OemToAnsi(STR0067) SIZE 146,10 OF oDlg1 PIXEL FONT oFont //"Data inicial:"
		@ aObjSize[1][1]-10,aObjSize[1][2]+50 MSGET odDataDe VAR dDataDe 	  				    	SIZE 050,10 OF oDlg1 PIXEL PICTURE "@D"
		@ aObjSize[1][1]-10,aObjSize[1][2]+140 SAY OemToAnsi(STR0068)			 					SIZE 146,10 OF oDlg1 PIXEL FONT oFont //"Data final:"
		@ aObjSize[1][1]-10,aObjSize[1][2]+180 MSGET odDataAte VAR dDataAte		   		   		SIZE 050,10 OF oDlg1 PIXEL PICTURE "@D"

		@ aObjSize[1][1]+10,aObjSize[1][2]+10 SAY OemToAnsi(STR0069)								SIZE 146,15 OF oDlg1 PIXEL FONT oFont //"Lançamentos ja existentes:"
		@ aObjSize[1][1]+10,aObjSize[1][2]+100 RADIO oRadio VAR nSubsLct ITEMS	OemToAnsi(STR0070)	,;			//"Substituir"
													OemToAnsi(STR0071)	,;			//"Desprezar"
													OemToAnsi(STR0072)	 ;			//"Somar"
					SIZE 050,010 OF oDlg1 PIXEL

		lContinua := PerAponta( @dPerIni , @dPerFim , dPonMes , NIL , cFil )

		DEFINE SBUTTON oSButton1 FROM 80, 80 TYPE 01 OF oDlg1 ENABLE ACTION { || If( !lContinua .Or. Empty( dDataDe ) .Or. Empty( dDataAte ) .Or. ( dDataAte < dDataDe ),;
		 				MsgAlert(STR0073,"") , If( MsgYesNo( OemToAnsi( STR0074 ) , OemToAnsi( STR0075 ) ), ( nOpcA := 1 , oDlg1:End() ),))}

		DEFINE SBUTTON oSButton2 FROM 80, 120 TYPE 02 OF oDlg1 ENABLE ACTION {|| nOpcA := 2,oDlg1:End() }

	ACTIVATE MSDIALOG oDlg1 CENTERED
	RestKeys( aSvKeys , .T. )
EndIf

// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// ³Identifica comissionista puro			 ³
// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lComisPuro :=  ( cPaisLoc == "BRA" )  .and.  (SRA->RA_CATFUNC == "C" ) .and.  Empty(SRA->RA_SALARIO )

If ( nOpcA == 1 ) .Or. ( !lIsGPEM040 ) //Calculo de Rescisao

	//Utiliza o processo da rescisão
	cProcFol 	:= cProcesso
	cRotFOL		:= cRot
	cPerFOL		:= cPeriodo
	cNPagFOL	:= cSemana

	If Empty(cPerFol)

		fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, fGetRotOrdinar() ) // Busca o periodo aberto da folha

		If !Empty(aPerAtual)
			cProcFOL	:= 	aPerAtual[1,8]
			cRotFOL		:=	aPerAtual[1,3]
			cPerFOL		:=	aPerAtual[1,1]
			cNPagFOL	:= 	aPerAtual[1,2]
		Else
			If lIsGPEM040
				MsgAlert(STR0076)   //"Não existe periodo da folha ativo."
			Else
				SRA->(;
							aAdd( aLogFile ,	STR0077 + 		RA_NOME 	+  " "	+;		//"Funcionario: "
												STR0078 + 		RA_FILIAL 	+ "   " +	;	//"Filial: "
												STR0079 + 		RA_MAT 		+ ".  "	+	;	//"Matricula: "
												STR0076;									//"Nao existe período da folha ativo."
								);
						 )
			EndIf
			Return(Nil)
		EndIf
	EndIf

	aDetSPBAux		:= GdMontaCols(@aCabSPBAux,,,,"SPB",aNotFields,@aSpbRecAux,"SRG",cKey,bKey,bSkip) //aDetSPBAux contem lctos. do SPB, filtrando apenas a filial+matricula dentro do periodo selecionado
	aDetSPB			:= GdMontaCols(@aCabSPB,,,,"SPB",aNotFields,@aSpbRecnos,"SRG",cKey,bKey,bSkip1) //criacao de aDetSPB vazio com mesma estrutura de aDetSPBAux
	nPosPBPd		:= GdFieldPos("PB_PD",aCabSPBAux)
	nPosPBVlr		:= GdFieldPos("PB_VALOR",aCabSPBAux)
	nPosPBHrs	 	:= GdFieldPos("PB_HORAS",aCabSPBAux)
	nPosPBTp1		:= GdFieldPos("PB_TIPO1",aCabSPBAux)
	nPosPBTp2		:= GdFieldPos("PB_TIPO2",aCabSPBAux)
	nPosPBSem		:= GdFieldPos("PB_SEMANA",aCabSPBAux)
	nPosPBDtPg		:= GdFieldPos("PB_DATA",aCabSPBAux)
	nPosPBCc		:= GdFieldPos("PB_CC",aCabSPBAux)
	nPosPBDel		:= GdFieldPos("GDDELETED",aCabSPBAux)
	nPosPBAWT		:= GdFieldPos("PB_ALI_WT",aCabSPBAux)
	nPosPBRWT		:= GdFieldPos("PB_REC_WT",aCabSPBAux)
	nPosPBRot		:= GdFieldPos("PB_ROTEIR",aCabSPBAux)

	If ( Len( aSpbRecAux ) > 0.00 )
		For ny := 1 to Len(aDetSPBAux) //For para alimentar aDetSPB com os totais de aDetSPBAux


			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³*** Tratamento para comissionista puro (BRA)							³
			³    Converte a verba de hora extra para verba de hora extra s/comissoes³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If lComisPuro
				aRetSRV:= PosSrv(aDetSPBAux[ ny, nPosPBPd ],cFil,{"RV_CODCORR","RV_HE"})
				//-- Se a verba for de hora extra
				If aRetSRV[2] == "S"
					//-- Substitui o codigo da verba pelo correspondente
					If !Empty(aRetSRV[1])
						aDetSPBAux[ ny, nPosPBPd ]:= aRetSRV[1]
					EndIf
				EndIf
			EndIf

			If ( aScan(aDetSPB,{ |x| ( x[nPosPBPd] + x[nPosPBCc] + x[nPosPBSem] == aDetSPBAux[ny,nPosPBPd] + aDetSPBAux[ny,nPosPBCc] + aDetSPBAux[ny,nPosPBSem] ) } )  == 0)
				nPos := Len(aDetSPB)

				If( !Empty( aDetSPB[nPos,nPosPBPd] ), aAdd( aDetSPB , Array( Len(aDetSPB[1]) ) ), )

				nPos							:= Len(aDetSPB)
				aDetSPB[nPos,nPosPBPd]			:= aDetSPBAux[ny,nPosPBPd]
				aDetSPB[nPos,nPosPBVlr]			:= aDetSPBAux[ny,nPosPBVlr]
				aDetSPB[nPos,nPosPBHrs]			:= aDetSPBAux[ny,nPosPBHrs]
				aDetSPB[nPos,nPosPBTp1]			:= aDetSPBAux[ny,nPosPBTp1]
				aDetSPB[nPos,nPosPBSem]			:= aDetSPBAux[ny,nPosPBSem]
				aDetSPB[nPos,nPosPBCc]			:= aDetSPBAux[ny,nPosPBCc]
				aDetSPB[nPos,nPosPBDel]			:= .F.
				aDetSPB[nPos,nPosPBAWT]			:= aDetSPBAux[ny,nPosPBAWT]
				aDetSPB[nPos,nPosPBRWT]			:= aDetSPBAux[ny,nPosPBRWT]
		    Else
		    	nLin := aScan(aDetSPB,{ |x| ( x[nPosPBPd] + x[nPosPBCc] + x[nPosPBSem] == aDetSPBAux[ny,nPosPBPd] + aDetSPBAux[ny,nPosPBCc] + aDetSPBAux[ny,nPosPBSem] ) } )

		       	aDetSPB[nLin,nPosPBHrs]			+= aDetSPBAux[ny,nPosPBHrs]
		    	aDetSPB[nLin,nPosPBVlr]			+= aDetSPBAux[ny,nPosPBVlr]
				aDetSPB[nLin,nPosPBAWT]			:= NIL
				aDetSPB[nLin,nPosPBRWT]			:= NIL
			EndIf
		Next ny

		DbSelectArea("RGB")
		DbSetOrder(RetOrder("RGB","RGB_FILIAL+RGB_PROCES+RGB_MAT+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_PD+RGB_CC+RGB_SEQ+DTOS(RGB_DTREF)"))

		For nx := 1 to Len(aDetSPB)
			If lIsGPEM040
				//Alimentar aColsAnt com registros de aDetSPB checando duplicidade (caso haja, serao somados os lctos.)
				If !RGB->(DbSeek(SRA->RA_FILIAL+cProcFOL+SRA->RA_MAT+cPerFOL+cNPagFOL+cRotFOL+aDetSPB[nx,nPosPBPd]+aDetSPB[nx,nPosPBCc]))
					RecLock("RGB",.T.)

					RGB->RGB_FILIAL	:= SRA->RA_FILIAL
					RGB->RGB_MAT	:= SRA->RA_MAT
					RGB->RGB_CC		:= aDetSPB[nx,nPosPBCc]
					RGB->RGB_PD		:= aDetSPB[nx,nPosPBPd]
					RGB->RGB_HORAS	:= aDetSPB[nx,nPosPBHrs]
					RGB->RGB_DTREF	:= Ctod("//")
					RGB->RGB_TIPO1	:= aDetSPB[nx,nPosPBTp1]
					RGB->RGB_TIPO2	:= "E"
					RGB->RGB_VALOR	:= aDetSPB[nx,nPosPBVlr]
					RGB->RGB_PARCEL	:= 0
					RGB->RGB_SEQ	:= SRR->RR_SEQ
					RGB->RGB_PROCES	:= cProcFOL
			      	RGB->RGB_PERIOD	:= cPerFOL
					RGB->RGB_ROTEIR	:= cRotFOL
					RGB->RGB_SEMANA	:= cNPagFOL
			      	RGB->RGB_ROTORI	:= "PON"

					If lItemClVl
						RGB->RGB_ITEM 	:= SRR->RR_ITEM
						RGB->RGB_CLVL 	:= SRR->RR_CLVL
					EndIf
					RGB->(msUnlock())
				ElseIf nSubsLct == 1 //Lcto. ja existente, substitui
					RecLock("RGB",.F.)

					If RGB->RGB_TIPO1 <> aDetSPB[nx,nPosPBTp1]
						If RGB->RGB_TIPO1 == "H" .And. aDetSPB[nx,nPosPBTp1] == "D"
							RGB->RGB_HORAS	:= NoRound( ( ( SRA->RA_HRSMES / 30 ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
		     			ElseIf RGB->RGB_TIPO1 == "D" .And. aDetSPB[nx,nPosPBTp1] == "H"
		      				RGB->RGB_HORAS	:= NoRound( ( ( 30 / SRA->RA_HRSMES ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
		      			Else
		      				RGB->RGB_HORAS	:= aDetSPB[nx,nPosPBHrs]
						EndIf
					Else
						RGB->RGB_HORAS	:= aDetSPB[nx,nPosPBHrs]
					EndIf

					RGB->RGB_TIPO2 	:= "E" //Utilizando o mesmo tratamento da rescisao, atribui a origem do ultimo lcto.
					RGB->RGB_VALOR	:= aDetSPB[nx,nPosPBVlr]
					RGB->(msUnlock())
				ElseIf nSubsLct == 3//Lcto. ja existente, soma
					RecLock("RGB",.F.)

					If RGB->RGB_TIPO1 <> aDetSPB[nx,nPosPBTp1]
						If RGB->RGB_TIPO1 == "H" .And. aDetSPB[nx,nPosPBTp1] == "D"
							RGB->RGB_HORAS	+= NoRound( ( ( SRA->RA_HRSMES / 30 ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
	      				ElseIf RGB->RGB_TIPO1 == "D" .And. aDetSPB[nx,nPosPBTp1] == "H"
	      					RGB->RGB_HORAS	+= NoRound( ( ( 30 / SRA->RA_HRSMES ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
	      				Else
							RGB->RGB_HORAS	+= aDetSPB[nx,nPosPBHrs]
						EndIf
					Else
						RGB->RGB_HORAS += aDetSPB[nx,nPosPBHrs]
					EndIf

					RGB->RGB_TIPO2 	:= "E" //Utilizando o mesmo tratamento da rescisao, atribui a origem do ultimo lcto.
					RGB->RGB_VALOR	+= aDetSPB[nx,nPosPBVlr]
					RGB->(msUnlock())
				EndIf
			Else //Importacao no calculo de Rescisao Coletiva

				//Verifica se existe a chave VERBA + C.CUSTO + SEMANA para incluir ou somar no aPd
				nPos := ( aScan( aPd,{ |x| ( x[1] + x[2] + x[3] == aDetSPB[nx,nPosPBPd] + aDetSPB[nx,nPosPBCc] + aDetSPB[nx,nPosPBSem] ) .And. ( x[9] <> "D" ) } ) )

				If nPos == 0
					fMatriz( aDetSPB[ nx,nPosPBPd ]		,;	//Verba
						aDetSPB[nx,nPosPBVlr]			,;	//Valor
						aDetSPB[nx,nPosPBHrs]			,;	//Horas
						aDetSPB[nx,nPosPBSem]			,;	//Semana
						aDetSPB[nx,nPosPBCC]			,;	//Centro de Custo
						aDetSPB[nx,nPosPBTp1]			,;	//Tipo 1 "V"alor,"H"oras,"D"ias
						"E"								,;	//Tipo 2 "G"erado,"I"nformado,"E"letronico,etc.
						0								,;	//Parcela
						" "								,;	//Deletada
						CTOD("//")						 ;	//Data de Pagamento
					)

				ElseIf nSubsLct == 1 //Lcto. ja existente, substitui

					If aPd[nPos,06] <> aDetSPB[nx,nPosPBTp1]
						If aPd[nPos,06] == "H" .And. aDetSPB[nx,nPosPBTp1] == "D"
							aPd[nPos,04]	:= NoRound( ( ( SRA->RA_HRSMES / 30 ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
	      				ElseIf aPd[nPos,06] == "D" .And. aDetSPB[nx,nPosPBTp1] == "H"
	      					aPd[nPos,04]	:= NoRound( ( ( 30 / SRA->RA_HRSMES ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
	      				Else
							aPd[nPos,04]	:= aDetSPB[nx,nPosPBHrs]
						EndIf
					Else

						aPd[nPos,04]	:= aDetSPB[nx,nPosPBHrs]
					EndIf

					aPd[nPos,05] := aDetSPB[nx,nPosPBVlr]	//Valor
					aPd[nPos,07] := "E"						//Origem do Calculo

				ElseIf nSubsLct == 3//Lcto. ja existente, soma

					If aPd[nPos,06] <> aDetSPB[nx,nPosPBTp1]
						If aPd[nPos,06] == "H" .And. aDetSPB[nx,nPosPBTp1] == "D"
							aPd[nPos,04]	+= NoRound( ( ( SRA->RA_HRSMES / 30 ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
	      				ElseIf aPd[nPos,06] == "D" .And. aDetSPB[nx,nPosPBTp1] == "H"
	      					aPd[nPos,04]	+= NoRound( ( ( 30 / SRA->RA_HRSMES ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
	      				Else
							aPd[nPos,04]	+= aDetSPB[nx,nPosPBHrs]
						EndIf
					Else

						aPd[nPos,04]	+= aDetSPB[nx,nPosPBHrs]
					EndIf

					aPd[nPos,05] += aDetSPB[nx,nPosPBVlr]	//Valor
					aPd[nPos,07] := "E"						//Origem do Calculo
				EndIf
			EndIf
		Next nx

		If !Empty(aSpbRecAux)
			aSPBRec := aClone(aSpbRecAux)
		EndIf
		If lIsGPEM040
			If cPaisLoc == "BRA"
				dDataAvis := M->RG_DTAVISO
				fAtAvProj(.T.,.F.)
				dDataAvis := dBkpAvis
			EndIf
			MsgAlert(STR0089)   //"Processo Concluido com Sucesso!"
		EndIf

	Else

		If lIsGPEM040

			MsgAlert(STR0080)   //"Nao ha lancamentos nos resultados do Ponto Eletronico para importacao."
		Else

			SRA->(;
						aAdd( aLogFile ,	STR0077 + 		RA_NOME 	+  " "	+;		//"Funcionario:"
											STR0078 + 	    RA_FILIAL 	+ "   " +	;	//"Filial:"
											STR0079 + 		RA_MAT 		+ ".  "	+	;	//"Matricula:"
											STR0076;									//"Nao ha lancamentos nos resultados do Ponto Eletronico para importacao."
							);
					 )
		EndIf
	EndIf
	SPB->( dbCloseArea() )
EndIf

Return( Nil )

/*VERIFICAR NECESSIDADE DESTA FUNCAO, E OU UNIFICAO COM A OUTRA, NA SEGUNDA FASE DA UNIFICAO POIS UNIFICAO DO PONTO ELETRONICO ESTA PENDENTE
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fImpPonto  ºAutor  ³Leandro Drumond     º Data ³  14/09/11     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Importa resultado do Ponto Eletronico para a rescisao(utili-  º±±
±±º          ³ zado para importacao de resultados do periodo de apontamento  º±±
±±º          ³ do mes da rescisao, em rescisao calculada para o mes seguinte º±±
±±º          ³ ao mes em aberto na folha).                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ nSubsLct   = Opcao para lctos. ja existentes na rescisao      º±±
±±º          ³ lIsGPEM040 = .T.-Calculo GPEM040; .F.-Calculo GPEM630         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fImpPontoM2( cProcFOL, cPerFOL, cRotFOL, cNPagFOL, nSubsLct, lIsGPEM040, aLogFile )

Local aAreaRCH			:= RCH->( GetArea() )
Local aDetSPB 			:= {}
Local aDetSPBAux		:= {}
Local aCabSPB			:= {}
Local aCabSPBAux		:= {}
Local aSpbRecnos		:= {}
Local aSpbRecAux		:= {}
Local aNotFields		:= {"PB_FILIAL", "PB_MAT"}
Local aSvKeys			:= GetKeys()
Local aColsAnt			:= {}
Local cFil				:= SRA->RA_FILIAL
Local cMat				:= SRA->RA_MAT
Local cKey				:= ( ( cFil + cMat ) )
Local cKeyRG8			:= ''
Local bKey 				:= { || SPB->(PB_FILIAL + PB_MAT ) }
Local bSkip				:= { || NIL }
Local bSkip1			:= { || .T. }
Local nPosRRProc		:= 0
Local nPosRRPer			:= 0
Local nPosRRRot			:= 0
Local nPosRRPd			:= 0
Local nPosRRVlr			:= 0
Local nPosRRHrs 		:= 0
Local nPosRRDesc		:= 0
Local nPosRRTp1			:= 0
Local nPosRRTp2			:= 0
Local nPosRRDt			:= 0
Local nPosRRSem			:= 0
Local nPosRRDtPg		:= 0
Local nPosRRCc			:= 0
Local nPosRRItem		:= 0
Local nPosRRCLVL		:= 0
Local nPosRRDel			:= 0
Local nPosRRAWT			:= 0
Local nPosRRRWT			:= 0
Local nPosPBProc		:= 0
Local nPosPBPer			:= 0
Local nPosPBRot			:= 0
Local nPosPBPd			:= 0
Local nPosPBVlr			:= 0
Local nPosPBHrs 		:= 0
Local nPosPBTp1			:= 0
Local nPosPBTp2			:= 0
Local nPosPBSem			:= 0
Local nPosPBDtPg		:= 0
Local nPosPBCc			:= 0
Local nPosPBCFun		:= 0
Local nPosPBDel			:= 0
Local nPosPBAWT			:= 0
Local nPosPBRWT			:= 0
Local nPosValInfo		:= 0
Local nPosHorInfo 		:= 0
Local nx				:= 0
Local ny				:= 0
Local nz				:= 0
Local nPos				:= 0.00
Local nOpcA 			:= 0.00
Local oFont
Local oDlg
Local oRadio
Local oGroup
Local lItemCLVL			:= SuperGetMv( "MV_ITMCLVL", .F., "2" ) $ "1*3" // Define se utiliza Item Contabil e Classe de Valor

Private oPeriodo	 	:= RHPERIODO():New()

DEFAULT	aLogFile		:= {}
DEFAULT nSubsLct		:= 2 //Opcao para lancamentos ja existentes: 1-Substitui;2-Despreza;3-Soma
DEFAULT dDataDe			:= CTOD("") //Data inicial do periodo para importacao do Ponto
DEFAULT dDataAte		:= CTOD("") //Data final do periodo para importacao do Ponto
DEFAULT lIsGPEM040		:= .T. //Calculo de rescisao via GPEM040

cKeyRG8 := "GPE" + cPerFOL + cNPagFOL + cProcFOL + cRotFOL

RG8->( dbSetOrder( Retorder( "RG8" , "RG8_FILIAL+RG8_MODCOR+RG8_PERCOR+RG8_NPGCOR+RG8_PROCOR+RG8_ROTCOR" ) ) )

//PROCURA CHAVE CORRESPONDENTE DA FOLHA
If RG8->( dbSeek( xFilial("RCH",SRA->RA_FILIAL) + cKeyRG8 ) )
	oPeriodo:cProcesso	:= 	RG8->RG8_PRCORI
	oPeriodo:cRoteiro	:=	RG8->RG8_ROTORI
	oPeriodo:cPeriodo	:=	RG8->RG8_PERORI
	oPeriodo:cNumPagto	:= 	RG8->RG8_NPGORI

	If !(fGetPeriodo( oPeriodo ))
		If lIsGPEM040
			Help( ,, OemToAnsi(STR0020),, OemToAnsi( oPeriodo:cMsgNotFoundPer ),,1,0 )   //"Período de Apontamento Não Encontrado."
		Else
			SRA->(;
						aAdd( aLogFile ,	OemToAnsi( oPeriodo:cMsgNotFoundPer ) + 	" "	+;		//"Período de Apontamento Não Encontrado."
											STR0090 + " " + SRA->RA_PROCES ;						//"Processo: "
							);
					 )
		EndIf
		Return Nil
	EndIf
Else
	If lIsGPEM040
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0091),1,0 )  //"Período do ponto (RG8) não encontrado"
	Else
		SRA->(;
					aAdd( aLogFile ,	OemToAnsi( oPeriodo:cMsgNotFoundPer ) + 	" "	+;		//"Período de Apontamento Não Encontrado."
										STR0090 + " " + SRA->RA_PROCES ;						//"Processo: "
						);
				 )
	EndIf
	Return Nil
EndIf

bSkip	:= { || (SPB->PB_PROCES <> oPeriodo:cProcesso .Or. SPB->PB_PERIODO <> oPeriodo:cPeriodo .Or. SPB->PB_ROTEIR <> oPeriodo:cRoteiro) }

If lIsGPEM040

	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg FROM  094,001 TO 250,400 TITLE OemToAnsi( STR0075 ) PIXEL  //--"Importação dos eventos de resultados do Ponto Eletrõnico"

		@ 015,005	GROUP oGroup TO 075,196 LABEL OemToAnsi(STR0066)  OF oDlg PIXEL	//"Informações para busca dos resultados:"
		oGroup:oFont:=oFont

		@ 030 , 014 SAY OemToAnsi(STR0069)			SIZE 146,15 OF oDlg PIXEL FONT oFont //"Lançamentos ja existentes:"
		@ 030 ,	095	RADIO oRadio VAR nSubsLct ITEMS	OemToAnsi(STR0070)	,;			//"Substituir"
													OemToAnsi(STR0071)	,;			//"Desprezar"
													OemToAnsi(STR0072)	 ;			//"Somar"
					SIZE 050,010 OF oDlg PIXEL

		oDlg:bSet15		:= { || If( MsgYesNo( OemToAnsi( STR0075 ) , OemToAnsi( STR0074 ) ), ( nOpcA := 1 , oDlg:End() ),)}  //--"Deseja importar os resultados de acordo com os parametros informados?" //--"Importação de eventos de resultados do Ponto Eletrônico"

		oDlg:bSet24		:= { || nOpcA := 2 , oDlg:End() }

		bSvSet24 := SetKey( 24 , oDlg:bSet24 )

		oDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.

	ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar( oDlg , oDlg:bSet15 , oDlg:bSet24 )
	RestKeys( aSvKeys , .T. )
EndIf

If ( nOpcA == 1 ) .Or. ( !lIsGPEM040 ) //Calculo de Rescisao

	aColsAnt		:= aClone(aCols)
	nPosRRProc		:= GdFieldPos("RR_PROCES",aSrrHeader)
	nPosRRPer		:= GdFieldPos("RR_PERIODO",aSrrHeader)
	nPosRRRot		:= GdFieldPos("RR_ROTEIR",aSrrHeader)
	nPosRRPd		:= GdFieldPos("RR_PD",aSrrHeader)
	nPosRRVlr		:= GdFieldPos("RR_VALOR",aSrrHeader)
	nPosRRHrs 		:= GdFieldPos("RR_HORAS",aSrrHeader)
	nPosRRDesc		:= GdFieldPos("RR_DESCPD",aSrrHeader)
	nPosRRTp1		:= GdFieldPos("RR_TIPO1",aSrrHeader)
	nPosRRTp2		:= GdFieldPos("RR_TIPO2",aSrrHeader)
	nPosRRDt		:= GdFieldPos("RR_DATA",aSrrHeader)
	nPosRRSem		:= GdFieldPos("RR_SEMANA",aSrrHeader)
	nPosRRDtPg		:= GdFieldPos("RR_DATAPAG",aSrrHeader)
	nPosRRCc		:= GdFieldPos("RR_CC",aSrrHeader)
	nPosRRItem		:= GdFieldPos("RR_ITEM",aSrrHeader)
	nPosRRCLVL		:= GdFieldPos("RR_CLVL",aSrrHeader)
	nPosRRDel		:= GdFieldPos("GDDELETED",aSrrHeader)
	nPosRRAWT		:= GdFieldPos("RR_ALI_WT",aSrrHeader)
	nPosRRRWT		:= GdFieldPos("RR_REC_WT",aSrrHeader)
	nPosValInfo		:= GdFieldPos("RR_VALINFO"	, aSrrHeader )
	nPosHorInfo 	:= GdFieldPos("RR_HORINFO"	, aSrrHeader )

	If Len(aColsAnt) > 1
		For nz := 1 to (Len(aColsAnt)-1)   //Alterar aColsAnt para ter apenas 1 elemento
			aDel(aColsAnt,Len(aColsAnt))
			aSize(aColsAnt,Len(aColsAnt)-1)
		Next nz
	EndIf

	If !Empty(aColsAnt)
		aColsAnt[1,nPosRRPd] := ""     //Excluido o codigo da verba para nao duplicar lcto. no aScan
	EndIf

	For nz := 1 to Len(aCols) //For no aCols para totalizar os lctos. no array aColsAnt
		//Incluir em aColsAnta apenas elementos de aCols que nao existem em aColsAnt(despreza os deletados de aColsAnt na comparacao) ou que estejam deletados no aCols.
		If (( aScan(aColsAnt,{ |x| ( x[nPosRRPd] + x[nPosRRCc] + x[nPosRRSem] == aCols[nz,nPosRRPd] + aCols[nz,nPosRRCc] + aCols[nz,nPosRRSem] ) .And. !x[nPosRRDel]} )  == 0) .Or. aCols[nz,nPosRRDel]) .And. !Empty(aCols[nz,nPosRRPd]) //Garante nao inclusao de elemento vazio

			If( nz > 1, aAdd( aColsAnt , Array( Len(aColsAnt[1]) ) ), )

			nPos	:= Len(aColsAnt)
			aColsAnt[nPos,nPosRRProc]		:= aCols[nz,nPosRRProc]
			aColsAnt[nPos,nPosRRPer]		:= aCols[nz,nPosRRPer]
			aColsAnt[nPos,nPosRRRot]		:= aCols[nz,nPosRRRot]
			aColsAnt[nPos,nPosRRPd]			:= aCols[nz,nPosRRPd]
			aColsAnt[nPos,nPosRRVlr]		:= aCols[nz,nPosRRVlr]
			aColsAnt[nPos,nPosRRHrs] 		:= If( aCols[nz,nPosRRTp1] == "H", ( fConvHoras( aCols[nz,nPosRRHrs], "2" ) ), aCols[nz,nPosRRHrs] )
			aColsAnt[nPos,nPosRRDesc]		:= DescPd(aCols[nz,nPosRRPd])
			aColsAnt[nPos,nPosRRTp1]		:= aCols[nz,nPosRRTp1]
			aColsAnt[nPos,nPosRRTp2]		:= aCols[nz,nPosRRTp2]
			aColsAnt[nPos,nPosRRDt]			:= aCols[nz,nPosRRDt]
			aColsAnt[nPos,nPosRRSem]		:= aCols[nz,nPosRRSem]
			aColsAnt[nPos,nPosRRDtPg]		:= aCols[nz,nPosRRDtPg]
			aColsAnt[nPos,nPosRRCc]			:= aCols[nz,nPosRRCc]
			aColsAnt[nPos,nPosRRDel]		:= aCols[nz,nPosRRDel]
			aColsAnt[nPos,nPosRRAWT]		:= aCols[nz,nPosRRAWT]
			aColsAnt[nPos,nPosRRRWT]		:= aCols[nz,nPosRRRWT]
			aColsAnt[nPos,nPosValInfo]		:= aCols[nz,nPosValInfo]
			aColsAnt[nPos,nPosHorInfo]		:= aCols[nz,nPosValInfo]

			If lItemCLVL
				aColsAnt[nPos,nPosRRItem]		:= aCols[nz,nPosRRItem]
				aColsAnt[nPos,nPosRRCLVL]		:= aCols[nz,nPosRRCLVL]
			EndIf
		ElseIf !Empty(aCols[nZ,nPosRRPd])
			nLin := aScan(aColsAnt,{ |x| ( x[nPosRRPd] + x[nPosRRCc] + x[nPosRRSem] == aCols[nz,nPosRRPd] + aCols[nz,nPosRRCc] + aCols[nz,nPosRRSem] ) .And. !x[nPosRRDel]} )

			If aColsAnt[nLin,nPosRRTp1] <> aCols[nz,nPosRRTp1] //Tratamento de tipos de lcto. diferentes (Horas->Dias ou Dias->Horas)
				If aColsAnt[nLin,nPosRRTp1] == "H" .And. aCols[nz,nPosRRTp1] == "D"
					aColsAnt[nLin,nPosRRHrs] += NoRound( ( ( SRA->RA_HRSMES / 30 ) * (aCols[nz,nPosRRHrs]) ) , 2 )
     			ElseIf aColsAnt[nLin,nPosRRTp1]	== "D" .And. aCols[nz,nPosRRTp1] == "H"
      				aColsAnt[nLin,nPosRRHrs] += NoRound( ( ( 30 / SRA->RA_HRSMES ) * ( If( aCols[nz,nPosRRTp1] == "H", ( fConvHoras( aCols[nz,nPosRRHrs], "2" ) ), aCols[nz,nPosRRHrs] ) ) ) , 2 )
      			Else
					aColsAnt[nLin,nPosRRHrs]	+= aCols[nz,nPosRRHrs]
				EndIf
			Else
				aColsAnt[nLin,nPosRRHrs] += If( aCols[nz,nPosRRTp1] == "H", ( fConvHoras( aCols[nz,nPosRRHrs], "2" ) ), aCols[nz,nPosRRHrs] )
			EndIf

			aColsAnt[nLin,nPosRRTp2] 	:= aCols[nz,nPosRRTp2] //Utilizando o mesmo tratamento da rescisao, atribui a origem do ultimo lcto.
			aColsAnt[nLin,nPosRRVlr] 	+= aCols[nz,nPosRRVlr]
			aColsAnt[nLin,nPosRRAWT] 	:= NIL
			aColsAnt[nLin,nPosRRRWT] 	:= NIL
			aColsAnt[nLin,nPosValInfo]	:= aCols[nz,nPosValInfo]
			aColsAnt[nLin,nPosHorInfo]	:= aCols[nz,nPosValInfo]
		EndIf
	Next nz

	aDetSPBAux		:= GdMontaCols(@aCabSPBAux,,,,"SPB",aNotFields,@aSpbRecAux,"SRG",cKey,bKey,bSkip) //aDetSPBAux contem lctos. do SPB, filtrando apenas a filial+matricula dentro do periodo selecionado
	aDetSPB			:= GdMontaCols(@aCabSPB,,,,"SPB",aNotFields,@aSpbRecnos,"SRG",cKey,bKey,bSkip1) //criacao de aDetSPB vazio com mesma estrutura de aDetSPBAux
	nPosPBProc		:= GdFieldPos("PB_PROCES",aCabSPBAux)
	nPosPBPer		:= GdFieldPos("PB_PERIODO",aCabSPBAux)
	nPosPBRot		:= GdFieldPos("PB_ROTEIR",aCabSPBAux)
	nPosPBPd		:= GdFieldPos("PB_PD",aCabSPBAux)
	nPosPBVlr		:= GdFieldPos("PB_VALOR",aCabSPBAux)
	nPosPBHrs	 	:= GdFieldPos("PB_HORAS",aCabSPBAux)
	nPosPBTp1		:= GdFieldPos("PB_TIPO1",aCabSPBAux)
	nPosPBTp2		:= GdFieldPos("PB_TIPO2",aCabSPBAux)
	nPosPBSem		:= GdFieldPos("PB_SEMANA",aCabSPBAux)
	nPosPBDtPg		:= GdFieldPos("PB_DATA",aCabSPBAux)
	nPosPBCc		:= GdFieldPos("PB_CC",aCabSPBAux)
	nPosPBCFun		:= GdFieldPos("PB_CODFUNC",aCabSPBAux)
	nPosPBDel		:= GdFieldPos("GDDELETED",aCabSPBAux)
	nPosPBAWT		:= GdFieldPos("PB_ALI_WT",aCabSPBAux)
	nPosPBRWT		:= GdFieldPos("PB_REC_WT",aCabSPBAux)

	If ( Len( aSpbRecAux ) > 0.00 )
		For ny := 1 to Len(aDetSPBAux) //For para alimentar aDetSPB com os totais de aDetSPBAux

			If ( aScan(aDetSPB,{ |x| ( x[nPosPBProc] + x[nPosPBPer] + x[nPosPBRot] + x[nPosPBPd] + x[nPosPBCc] + x[nPosPBSem] == aDetSPBAux[ny,nPosPBProc] + aDetSPBAux[ny,nPosPBPer] + aDetSPBAux[ny,nPosPBRot] + aDetSPBAux[ny,nPosPBPd] + aDetSPBAux[ny,nPosPBCc] + aDetSPBAux[ny,nPosPBSem] ) } )  == 0)
				nPos		:= Len(aDetSPB)

				If( !Empty( aDetSPB[nPos,nPosPBPd] ), aAdd( aDetSPB , Array( Len(aDetSPB[1]) ) ), )

				nPos		:= Len(aDetSPB)
				aDetSPB[nPos,nPosPBProc]		:= aDetSPBAux[ny,nPosPBProc]
				aDetSPB[nPos,nPosPBPer]			:= aDetSPBAux[ny,nPosPBPer]
				aDetSPB[nPos,nPosPBRot]			:= aDetSPBAux[ny,nPosPBRot]
				aDetSPB[nPos,nPosPBPd]			:= aDetSPBAux[ny,nPosPBPd]
				aDetSPB[nPos,nPosPBVlr]			:= aDetSPBAux[ny,nPosPBVlr]
				aDetSPB[nPos,nPosPBHrs]			:= aDetSPBAux[ny,nPosPBHrs]
				aDetSPB[nPos,nPosPBTp1]			:= aDetSPBAux[ny,nPosPBTp1]
				aDetSPB[nPos,nPosPBSem]			:= aDetSPBAux[ny,nPosPBSem]
				aDetSPB[nPos,nPosPBCc]			:= aDetSPBAux[ny,nPosPBCc]
				aDetSPB[nPos,nPosPBCFun]		:= aDetSPBAux[ny,nPosPBCFun]
				aDetSPB[nPos,nPosPBDel]			:= .F.
				aDetSPB[nPos,nPosPBAWT]			:= aDetSPBAux[ny,nPosPBAWT]
				aDetSPB[nPos,nPosPBRWT]			:= aDetSPBAux[ny,nPosPBRWT]
		    Else
		    	nLin := aScan(aDetSPB,{ |x| ( x[nPosPBProc] + x[nPosPBPer] + x[nPosPBRot] + x[nPosPBPd] + x[nPosPBCc] + x[nPosPBSem] == aDetSPBAux[ny,nPosPBProc] + aDetSPBAux[ny,nPosPBPer] + aDetSPBAux[ny,nPosPBRot] + aDetSPBAux[ny,nPosPBPd] + aDetSPBAux[ny,nPosPBCc] + aDetSPBAux[ny,nPosPBSem] ) } )

		       	aDetSPB[nLin,nPosPBHrs]			+= aDetSPBAux[ny,nPosPBHrs]
		    	aDetSPB[nLin,nPosPBVlr]			+= aDetSPBAux[ny,nPosPBVlr]
				aDetSPB[nLin,nPosPBAWT]			:= NIL
				aDetSPB[nLin,nPosPBRWT]			:= NIL
			EndIf
		Next ny

		For nx := 1 to Len(aDetSPB)
			If lIsGPEM040
				//Alimentar aColsAnt com registros de aDetSPB checando duplicidade (caso haja, serao somados os lctos.)
				If ( aScan(aColsAnt,{ |x| ( x[nPosRRPd] + x[nPosRRCc] + x[nPosRRSem] == aDetSPB[nx,nPosPBPd] + aDetSPB[nx,nPosPBCc] + aDetSPB[nx,nPosPBSem] ) .And. !x[nPosRRDel] } )  == 0) //Verbas + C.Custo + Semana
					nPos	:= Len(aColsAnt)
					If( !Empty( aColsAnt[nPos,nPosRRPd] ), aAdd( aColsAnt , Array( Len(aColsAnt[1]) ) ), )
					nPos	:= Len(aColsAnt)
					aColsAnt[nPos,nPosRRProc]		:= aDetSPB[nx,nPosPBProc]
					aColsAnt[nPos,nPosRRPer]		:= aDetSPB[nx,nPosPBPer]
					aColsAnt[nPos,nPosRRRot]		:= aDetSPB[nx,nPosPBRot]
					aColsAnt[nPos,nPosRRPd]			:= aDetSPB[nx,nPosPBPd]
					aColsAnt[nPos,nPosRRVlr]		:= aDetSPB[nx,nPosPBVlr]
					aColsAnt[nPos,nPosRRHrs]		:= aDetSPB[nx,nPosPBHrs]
					aColsAnt[nPos,nPosRRDesc]		:= DescPd(aDetSPB[nx,nPosPBPd])
					aColsAnt[nPos,nPosRRTp1]		:= aDetSPB[nx,nPosPBTp1]
					aColsAnt[nPos,nPosRRTp2]		:= "E"
					aColsAnt[nPos,nPosRRDt]			:= Ctod("//")
					aColsAnt[nPos,nPosRRSem]		:= aDetSPB[nx,nPosPBSem]
					aColsAnt[nPos,nPosRRDtPg]		:= Ctod("//")
					aColsAnt[nPos,nPosRRCc]			:= aDetSPB[nx,nPosPBCc]
					aColsAnt[nPos,nPosRRDel]		:= .F.
					aColsAnt[nPos,nPosRRAWT]		:= aDetSPB[nx,nPosPBAWT]
					aColsAnt[nPos,nPosRRRWT]		:= aDetSPB[nx,nPosPBRWT]
					aColsAnt[nPos,nPosValInfo]		:= 0
					aColsAnt[nPos,nPosHorInfo]		:= 0


					If lItemCLVL
						aColsAnt[nPos,nPosRRItem]	:= SRA->RA_ITEM
						aColsAnt[nPos,nPosRRCLVL]	:= SRA->RA_CLVL
					EndIf

				ElseIf nSubsLct == 1 //Lcto. ja existente, substitui

			   		nLin := aScan(aColsAnt,{ |x| ( x[nPosRRPd] + x[nPosRRCc] + x[nPosRRSem] == aDetSPB[nx,nPosPBPd] + aDetSPB[nx,nPosPBCc] + aDetSPB[nx,nPosPBSem] ) .And. !x[nPosRRDel] } )

					If nLin # 0
						If aColsAnt[nLin,nPosRRTp1] <> aDetSPB[nx,nPosPBTp1]
							If aColsAnt[nLin,nPosRRTp1] == "H" .And. aDetSPB[nx,nPosPBTp1] == "D"
								aColsAnt[nLin,nPosRRHrs]	:= NoRound( ( ( SRA->RA_HRSMES / 30 ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
			     			ElseIf aColsAnt[nLin,nPosRRTp1] == "D" .And. aDetSPB[nx,nPosPBTp1] == "H"
			      				aColsAnt[nLin,nPosRRHrs]	:= NoRound( ( ( 30 / SRA->RA_HRSMES ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
			      			Else
			      				aColsAnt[nLin,nPosRRHrs]	:= aDetSPB[nx,nPosPBHrs]
							EndIf
						Else
							aColsAnt[nLin,nPosRRHrs]	:= aDetSPB[nx,nPosPBHrs]
						EndIf

						aColsAnt[nLin,nPosRRTp2] 	:= "E" //Utilizando o mesmo tratamento da rescisao, atribui a origem do ultimo lcto.
						aColsAnt[nLin,nPosRRVlr]	:= aDetSPB[nx,nPosPBVlr]
						aColsAnt[nLin,nPosRRAWT]	:= aDetSPB[nx,nPosPBAWT]
						aColsAnt[nLin,nPosRRRWT]	:= aDetSPB[nx,nPosPBRWT]
						aColsAnt[nLin,nPosRRProc]	:= aDetSPB[nx,nPosPBProc]
						aColsAnt[nLin,nPosRRPer]	:= aDetSPB[nx,nPosPBPer]
						aColsAnt[nLin,nPosRRRot]	:= aDetSPB[nx,nPosPBRot]
					EndIf
				ElseIf nSubsLct == 3//Lcto. ja existente, soma

					nLin := aScan(aColsAnt,{ |x| ( x[nPosRRPd] + x[nPosRRCc] + x[nPosRRSem] == aDetSPB[nx,nPosPBPd] + aDetSPB[nx,nPosPBCc] + aDetSPB[nx,nPosPBSem] ) .And. !x[nPosRRDel] } )

					If nLin # 0
						If aColsAnt[nLin,nPosRRTp1] <> aDetSPB[nx,nPosPBTp1]
							If aColsAnt[nLin,nPosRRTp1] == "H" .And. aDetSPB[nx,nPosPBTp1] == "D"
								aColsAnt[nLin,nPosRRHrs]	+= NoRound( ( ( SRA->RA_HRSMES / 30 ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
		      				ElseIf aColsAnt[nLin,nPosRRTp1] == "D" .And. aDetSPB[nx,nPosPBTp1] == "H"
		      					aColsAnt[nLin,nPosRRHrs]	+= NoRound( ( ( 30 / SRA->RA_HRSMES ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
		      				Else
								aColsAnt[nLin,nPosRRHrs]	+= aDetSPB[nx,nPosPBHrs]
							EndIf
						Else
							aColsAnt[nLin,nPosRRHrs]	+= aDetSPB[nx,nPosPBHrs]
						EndIf

						aColsAnt[nLin,nPosRRTp2] 	:= "E" //Utilizando o mesmo tratamento da rescisao, atribui a origem do ultimo lcto.
						aColsAnt[nLin,nPosRRVlr]	+= aDetSPB[nx,nPosPBVlr]
						aColsAnt[nLin,nPosRRAWT]	:= NIL
						aColsAnt[nLin,nPosRRRWT]	:= NIL
						aColsAnt[nLin,nPosRRProc]	:= aDetSPB[nx,nPosPBProc]
						aColsAnt[nLin,nPosRRPer]	:= aDetSPB[nx,nPosPBPer]
						aColsAnt[nLin,nPosRRRot]	:= aDetSPB[nx,nPosPBRot]
					EndIf
				EndIf
			Else //Importacao no calculo de Rescisao Coletiva

				//Verifica se existe a chave PROC + PERIODO + ROTEIRO + VERBA + C.CUSTO + SEMANA para incluir ou somar no aPd
				nPos := ( aScan( aColsAnt,{ |x| ( x[nPosRRPd] + x[nPosRRCc] + x[nPosRRSem] == aDetSPB[nx,nPosPBPd] + aDetSPB[nx,nPosPBCc] + aDetSPB[nx,nPosPBSem] ) .And. ( x[9] <> "D" ) } ) )

				If nPos == 0
					fInsertCols( 	@aColsAnt 					,;
									aSrrHeader 					,;
									aDetSPB[nx,nPosPBPd ]		,;
									aDetSPB[nx,nPosPBVlr]		,;
									aDetSPB[nx,nPosPBHrs]		,;
									aDetSPB[nx,nPosPBSem]		,;
									aDetSPB[nx,nPosPBCC]		,;
									aDetSPB[nx,nPosPBTp1]		,;
									"E"							,;
									NIL							,;
									cPeriodo					,;
									cRoteiro					,;
									NIL							,;
									NIL							,;
									NIL							,;
									NIL							,;
									NIL							,;
									NIL						    ,;
			 					  	aDetSPB[nx,nPosPBCFun]		 ;
							   )
				ElseIf nSubsLct == 1 //Lcto. ja existente, substitui

					If aColsAnt[nPos,nPosRRTp1] <> aDetSPB[nx,nPosPBTp1]
						If aColsAnt[nPos,nPosRRTp1] == "H" .And. aDetSPB[nx,nPosPBTp1] == "D"
							aColsAnt[nPos,nPosRRHrs]	:= NoRound( ( ( SRA->RA_HRSMES / 30 ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
	      				ElseIf aColsAnt[nPos,nPosRRTp1] == "D" .And. aDetSPB[nx,nPosPBTp1] == "H"
	      					aColsAnt[nPos,nPosRRHrs]	:= NoRound( ( ( 30 / SRA->RA_HRSMES ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
	      				Else
							aColsAnt[nPos,nPosRRHrs]	:= aDetSPB[nx,nPosPBHrs]
						EndIf
					Else

						aColsAnt[nPos,nPosRRHrs]	:= aDetSPB[nx,nPosPBHrs]
					EndIf

					aColsAnt[nPos,nPosPBVlr] := aDetSPB[nx,nPosPBVlr]	//Valor
					aColsAnt[nPos,nPosPBTp2] := "E"					//Origem do Calculo

				ElseIf nSubsLct == 3//Lcto. ja existente, soma

					If aColsAnt[nPos,nPosRRTp1] <> aDetSPB[nx,nPosPBTp1]
						If aColsAnt[nPos,nPosRRTp1] == "H" .And. aDetSPB[nx,nPosPBTp1] == "D"
							aColsAnt[nPos,nPosRRHrs]	+= NoRound( ( ( SRA->RA_HRSMES / 30 ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
	      				ElseIf aColsAnt[nPos,nPosRRTp1] == "D" .And. aDetSPB[nx,nPosPBTp1] == "H"
	      					aColsAnt[nPos,nPosRRHrs]	+= NoRound( ( ( 30 / SRA->RA_HRSMES ) * (aDetSPB[nx,nPosPBHrs]) ) , 2 )
	      				Else
							aColsAnt[nPos,nPosRRHrs]	+= aDetSPB[nx,nPosPBHrs]
						EndIf
					Else

						aColsAnt[nPos,nPosRRHrs]	+= aDetSPB[nx,nPosPBHrs]
					EndIf

					aColsAnt[nPos,nPosPBVlr] += aDetSPB[nx,nPosPBVlr]	//Valor
					aColsAnt[nPos,nPosPBTp2] := "E"					//Origem do Calculo
				EndIf
			EndIf
		Next nx

		For nz := 1 To Len(aColsAnt) //Efetua conversao dos lctos. em horas do formato centesimal para o formato sexagenal

			aColsAnt[nz,nPosRRHrs] := If( aColsAnt[nz,nPosRRTp1] == "H", ( fConvHoras(aColsAnt[nz,nPosRRHrs], "1" ) ), aColsAnt[nz,nPosRRHrs] )
		Next nz

		aSort( @aColsAnt , , , { |x,y| x[nPosRRPd] < y[nPosRRPd] } ) //Ordena aColsAnt

		aCols := aClone(aColsAnt) //Atualiza aCols com itens de aColsAnt

		If lIsGPEM040
			oGet:oBrowse:nAT := Len(aCols) //Atualiza no. de elementos do aCols
			oGet:aCols := aClone(aCols)
			oGet:ForceRefresh() //Forca Refresh para demonstracao em tela de todos os elementos
		EndIf

		If !Empty(aSpbRecAux)
			aSPBRec := aClone(aSpbRecAux)
		EndIf
	Else

		If lIsGPEM040

			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0080), 1, 0 ) //"Nao ha lancamentos nos resultados do Ponto Eletronico para importacao."
		Else

			SRA->(;
						aAdd( aLogFile ,	STR0077 + 		RA_NOME 	+  " "	+		;		//"Funcionario:"
											STR0079 + 		RA_MAT 		+ ".  "	+		;		//"Matricula:"
											STR0080;											//"Nao ha lancamentos nos resultados do Ponto Eletronico para importacao."
							);
					 )
		EndIf
	EndIf
EndIf

RestArea(aAreaRCH)

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGetPeriodoºAutor  ³Leandro Drumond    º Data ³  14/09/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Obtem o periodo de apontamento							  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fGetPeriodo( oPeriodo )

Local aArea 		:= GetArea()
Local lRet 			:= .T.

oPeriodo:PerSel()

    /*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Mostra Advertencia para Periodo Nao Encontrado				  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
lRet := oPeriodo:lFound

RestArea( aArea )

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GrvIntSPB  ºAutor  ³Leandro Drumond    º Data ³  19/09/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Grava conteudo no campo PB_INTEGRAm para que, ao efetuar 	  º±±
±±º          ³fechamento do periodo, campo PL_INTEGRA fique com conteudo  º±±
±±º          ³igual a um e valores nao sejam transferidos na integracao.  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GrvIntSPB(aSPBRec)
Local aArea := GetArea()
Local nX	:= 0

For nX := 1 to Len(aSPBRec)
	SPB->(dbGoTo(aSPBRec[nX]))
	RecLock("SPB",.F.)

		SPB->PB_INTEGRA := "1"

	SPB->(MsUnlock())
Next nX

RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ExcIntSPB  ºAutor  ³Leandro Drumond    º Data ³  19/09/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Exclui conteudo do campo PB_INTEGRA						  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ExcIntSPB(cKeySPB)
Local aArea 	:= GetArea()
Local cKeyRG8 	:= ''

Private oPeriodo	:= RHPERIODO():New()

cKeyRG8 := "GPE" + cPeriodo + cNumPag + cProcesso + fGetRotOrdinar()

RG8->( dbSetOrder( Retorder( "RG8" , "RG8_FILIAL+RG8_MODCOR+RG8_PERCOR+RG8_NPGCOR+RG8_PROCOR+RG8_ROTCOR" ) ) )

//PROCURA CHAVE CORRESPONDENTE DA FOLHA
If RG8->( dbSeek( xFilial("RCH",SRA->RA_FILIAL) + cKeyRG8 ) )
	oPeriodo:cProcesso	:= 	RG8->RG8_PRCORI
	oPeriodo:cRoteiro	:=	RG8->RG8_ROTORI
	oPeriodo:cPeriodo	:=	RG8->RG8_PERORI
	oPeriodo:cNumPagto	:= 	RG8->RG8_NPGORI

	If !(fGetPeriodo( oPeriodo ))
		Return Nil
	EndIf
EndIf

If MsFile("SPB")
	SPB->(DbSetOrder(1))

	If SPB->(dbSeek(cKeySPB))
		While SPB->(!Eof() .and. PB_FILIAL + PB_MAT + PB_PROCES + PB_PERIODO + PB_ROTEIR + PB_SEMANA == cKeySPB + oPeriodo:cProcesso + oPeriodo:cPeriodo + oPeriodo:cRoteiro + oPeriodo:cNumPagto )
			If SPB->PB_INTEGRA == "1"
				RecLock("SPB",.F.)
				SPB->PB_INTEGRA := " "
				SPB->(MsUnlock())
			EndIf
			SPB->(dbSkip())
		EndDo
	EndIf
Endif

RestArea(aArea)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCommit040  ³ Autor ³ Leandro Drumond       ³ Data ³ 11/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao que comita as informacoes, SEM abrir outra inclusao au-³±±
±±³          ³tomaticamente.                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fCommit040(oModel)                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fCommit040(oModel)
Local aArea      	:= GetArea()
Local aAreaSRD     	:= GetArea()
Local nOperacao  	:= oModel:GetOperation()
Local lRet			:= .T.
Local oGrid 		:= oModel:GetModel('GPEM040_MGET')
Local aSolucao		:= {}
Local nI
Local aPerAtuADI	:= {}
Local lBloqAdm		:= SRA->(ColumnPos("RA_BLOQADM")) > 0
Local cQuery		:= ""

DEFAULT lGestPubl   := IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP
DEFAULT lConsig		:= GetMvRH("MV_CONSIG",, .F.)
DEFAULT lCpoFlagIC	:= ChkFile("SRG") .And. SRG->(ColumnPos("RG_CONFIC")) > 0
DEFAULT lMvRHNG		:= SuperGetMv('MV_RHNG', .F., .F.)

Begin Transaction

	If nOperacao == MODEL_OPERATION_DELETE

		//Informa ao usuario sobre os lancamentos importados do Ponto Eletronico
		If !lColetiva
			cMsgAlert := OemToAnsi(STR0194) //"Se houve importação de dados do Ponto Eletrônico eles não serão excluídos ao executar o cancelamento da rescisão."
			aAdd( aSolucao, { OemToAnsi(STR0195) } ) //"Os dados importados do Ponto Eletrônico deverão ser cancelados por meio da rotina Cancelamento de Cálculo (GPEM160), selecionando o roteiro 'PON'."
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(cMsgAlert) , 1,,,,,,, aSolucao )
		EndIf

		FWFormCommit( oModel ) 						//--Grava model
		ExcIntSPB(SRA->RA_FILIAL+SRA->RA_MAT) 		//--Retorna o campo PB_INTEGRA para Nil, de forma que este possa ser integrado com a folha apos o fechamento
		fRetSitRes()  								//--Retorna a situacao do funcionario

		fDelHist(.T.) //deleta historico de medias

		If lGestPubl .AND. cModulo $ 'GFP*VDF'
			fIncRes(SRA->RA_FILIAL, oModel:GetValue("GPEM040_MSRG","RG_TIPORES"), @aIncRes, @nPercFgts, @cRescrais, @cAfasfgts, @Cod_Am)
			fRetSitGFP(cAfasfgts)//--Retorna a situacao do funcionario aposentado
		EndIf

		If cPaisLoc== "BRA" .And. SRG->RG_RESCDIS == '0' .AND. FindFunction("OrgXDelRescisao") //Só retorna status do posto se for a rescisão principal, na exclusão de complementares nada é alterado.
			OrgXDelRescisao(SRA->RA_FILIAL, SRA->RA_MAT)
		EndIf
		PcoDetLan("000090","01","GPEM040", .T.)

		If lBloqAdm
			If oModel:GetValue("GPEM040_MSRG","RA_BLOQADM")
				RecLock("SRA", .F.)
				SRA->RA_BLOQADM :=  "2"
				MsUnLock()
			EndIf
		ElseIf cPaisLoc $ "BRA|DOM|MEX" .And. oModel:GetValue("GPEM040_MSRG","RA_FECREI")
			RecLock("SRA", .F.)
			SRA->RA_FECREI :=  CtoD("")
			MsUnLock()
		EndIf

		// Gravar as verbas com origem A que estão no grid na RGB caso o roteiro de adiantamento esteja fechado.
		If ! cCompl == "S" .And. fGetPerAtual( @aPerAtuADI, xFilial("RCH", SRA->RA_FILIAL), SRA->RA_PROCES, fGetCalcRot('2'))
			If aPerAtuADI[1][1] > cPeriodo // Período de ADI já foi fechado
				For nI := 1 To oGrid:Length()
					oGrid:GoLine(nI)
					If oGrid:GetValue("RR_TIPO2") == "A" .And. (oGrid:GetValue("RR_PD") != aCodFol[010,1])
						GravaRGB(oGrid, oGrid:nLine)
					EndIf
				Next
			EndIf
		EndIf

		If SRA->RA_SITFOLH == "D" //Se a rescisão excluída era complementar, funcionário continua demitido.
			DbSelectArea("SRC")
			DbSetOrder(RetOrder("SRC","RC_FILIAL+RC_MAT+RC_PROCES+RC_ROTEIR+RC_PERIODO+RC_SEMANA"))
			If DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + SRA->RA_PROCES + fGetCalcRot('1'))
				MsgAlert(STR0228) //"A rescisão foi integrada e calculada na folha. Os registros gravados no roteiro da folha não serão excluídos. Para exclui-los utilize a rotina de 'Cancelamento de Cálculo'."
			EndIf
		EndIf

		If cPaisLoc == "BRA" .And. !Empty(P_ADIPGFE)
			For nI := 1 To oGrid:Length()
				oGrid:GoLine(nI)
				If oGrid:GetValue("RR_PD") $ P_ADIPGFE+"/"+P_ADIPGAB .And. oGrid:GetValue("RR_TIPO2") == "F"
					//--Exclui registros existentes na SRC
					cQuery := "UPDATE " + RetSqlName("SRD") + " "
					cQuery += "SET RD_NUMID='' "
					cQuery += "WHERE RD_FILIAL='" + SRA->RA_FILIAL + "' AND "
					cQuery += "RD_MAT='" + SRA->RA_MAT + "' AND "
					cQuery += "RD_NUMID='" + oModel:GetValue("GPEM040_MSRG", "RG_PERIODO") + oModel:GetValue("GPEM040_MSRG", "RG_SEMANA") + oModel:GetValue("GPEM040_MSRG", "RG_ROTEIR") + oGrid:GetValue("RR_PD") + "'"

					TcSqlExec( cQuery )

					TcRefresh( InitSqlName("SRD") )
				EndIf
			Next
		EndIf

	Else

		//Apaga rescisao anterior
		If lRecRes .and. !(cCompl == "S") .and. lRet
			Gpem040Exc( nRegSrg )
		EndIf

		If cPaisLoc == "BRA" .And. oModel:GetValue("GPEM040_MSRG", "RG_EFETIVA") == "S" .And. lConsig .And. lCpoFlagIC
			If IsBlind() .Or. MsgYesNo( OemToAnsi( STR0296 ), OemToAnsi( STR0020 ) )//"Deseja enviar a rescisão para a instituição de crédito?"##"Atenção"
				oModel:GetModel('GPEM040_MSRG'):LoadValue('RG_CONFIC', "1")
			EndIf
		EndIf

		FWFormCommit( oModel ) //Grava model

		If SRG->RG_EFETIVA $ "S*2"

			If cPaisLoc != "MEX"

				RetSituacao()

				If  lGestPubl .AND. cModulo $ 'GFP*VDF'
					If cAfasfgts $ 'U1*U3'//Aposentadoria
						RegToMemory("SRA")
						fGravaSr3(dDataDem,"APO", SRG->RG_NOVSUBS,, 4) //Grava SR3/SR7

						RecLock("SRA",.F.,.T.)
						SRA->RA_SITFOLH	:= ""
						SRA->RA_DEMISSA	:= Ctod("  /  /  ")
						SRA->RA_APOSENT	:= dDataDem
						If SRA->RA_CATFUNC == "2" //Servidor Efetivo
							SRA->RA_CATFUNC	:= "8"
						ELseIf	SRA->RA_CATFUNC == "0" //Membro Efetivo.
							SRA->RA_CATFUNC	:= "7"
						EndIf
						SRA->RA_TABELA	:= ""
						SRA->RA_TABNIVE	:= ""
						SRA->RA_TABFAIX	:= ""
						SRA->RA_SALARIO	:= SRG->RG_NOVSUBS
						SRA->RA_MSBLQL	:= '2'
						SRA->( MsUnLock() )


					EndIf

					If SRA->RA_CATFUNC $ '4,5'//4Servidor Adido/Cedido
						If 	RID->(dbSeek(SRA->RA_FILIAL+SRA->RA_MAT))
							While RID->(!eof()) .and. RID->(RID_FILIAL+RID_MAT) == SRA->(RA_FILIAL+RA_MAT)
								If empty(RID->RID_DATFIM)
									RecLock("RID",.F.,.T.)
									RID->RID_DATFIM	:= 	dDataDem
									RID->( MsUnLock() )
								Endif
								RID->(dbskip())
							EndDo
						EndIF
					EndIf
				EndIf
			EndIf

			If FindFunction("OrgXRescisao")
				OrgXRescisao(SRA->RA_FILIAL, SRA->RA_MAT, dDataDem)
			EndIf

			fMontaMail("017")

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Integracao Protheus X RM Classis Net (RM Sistemas)³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If GetNewPar("MV_CLASSIS", .F.)
				//Efetua atualizacao de registros na tabela INT_FUNC (Tabela de integracao de professores)
				//referente a Integracao do Protheus x RM Classis Net (RM Sistemas)
				ClsIncPrf("U", "GPEM040")
			Endif

			GrvIntSPB(aSPBRec)

			If cPaisLoc == "BRA" .And. !Empty( aRecResUt )
				aAreaSRD := SRD->( GetArea() )
				For nI := 1 To Len(aRecResUt)
					SRD->( dbGoTo( aRecResUt[nI, 1] ) )
					If RecLock("SRD", .F.)
						SRD->RD_NUMID := aRecResUt[nI, 2]
						SRD->(MsUnlock())
					EndIf
				Next nI
				RestArea( aAreaSRD )
			EndIf

			PcoDetLan("000090","01","GPEM040")
		EndIf

		If lBloqAdm
			If oModel:GetValue("GPEM040_MSRG","RA_BLOQADM")
				RecLock("SRA", .F.)
				SRA->RA_BLOQADM :=  "1"
				MsUnLock()
			EndIf
		ElseIf cPaisLoc $ "BRA|DOM|MEX" .And. oModel:GetValue("GPEM040_MSRG","RA_FECREI")
			RecLock("SRA", .F.)
			SRA->RA_FECREI :=  oModel:GetValue("GPEM040_MSRG","RG_DATADEM")
			MsUnLock()
		EndIf

		//Grava na tabela RJP - NG Quirons
		If lMvRHNG .And. SRG->RG_EFETIVA == "S" .And. cCompl <> "S"
			fRescToRJP("D")
		EndIf

	EndIf

End Transaction

If CCOMPL <> "S"
	//Desvincula ou vincula o funcionário ao currículo de acordo com a operação realizada
	fVincSQG(nOperacao,SRA->RA_FILIAL,SRA->RA_MAT)
EndIf


/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Atualiza Publicação RI6 - SIGAGFP								³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If lGestPubl .And. cModulo $ 'GFP*VDF' .And. cCompl <> "S" .And. !Empty(aPublicacao[4]) .And. nOperacao == MODEL_OPERATION_INSERT
	DbSelectArea("RI6")
	DbSetOrder(aPublicacao[5])
	RI6->(DbSeek(aPublicacao[4]))
	Reclock("RI6",.F.)
	RI6->RI6_TABORI	:= "SRG"
	RI6->RI6_DTEFEI	:= SRG->RG_DATADEM
	MsUnlock()
	DbSelectArea("SRG")
EndIf


cFilAnt := cFilOld

RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fRetSitResºAutor  ³Microsiga           º Data ³  01/30/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna a Situacao do funcionario                          º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function fRetSitRes(cFil,cMat)

Local aSituacao := {}

DEFAULT cFil 	:= SRA->RA_FILIAL
DEFAULT cMat 	:= SRA->RA_MAT

aSituacao := RetSituacao( cFil , cMat , .F. , NIL , .T. )

If !( aSituacao[1] == "D" )
		SRA->( RecLock( "SRA" , .F. , .T. ) )
		SRA->RA_DEMISSA  := Ctod("//")
		SRA->RA_RESCRAI  := "  "
		SRA->( MsUnLock() )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Retorna a Atual Situacao do Funcionario                       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		RetSituacao(cFil , cMat , .T. , NIL , .T. )
EndIf

Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fTudoOKM40  ³ Autor ³ Leandro Drumond       ³ Data ³ 11/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Validacoes acionadas ao clicar no botao confirma.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fTudoOKM40()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fTudoOKM40(oModel)
Local aArea			:= GetArea()
Local lRet			:= .T.
Local lContinua		:= .T.
Local nAux2			:= 0
Local nX			:= 0
Local nOperation	:= oModel:GetOperation()
Local oModelSRG		:= oModel:GetModel('GPEM040_MSRG')
Local oGrid 		:= oModel:GetModel('GPEM040_MGET')
Local aPerAtual		:= {}
Local cProcesso		:= ""
Local cRoteiro		:= ""
Local cPeriodo		:= ""
Local cNumPago		:= ""
Local cMesAnt		:= ""
Local cMesAtu		:= ""
Local cAnoAnt		:= ""
Local cAnoAtu		:= ""
Local cSem			:= ""
Local dDtPerAt		:= CtoD("//")
Local lAlteracao	:= .F.
Local lBloqAb		:= .F.
Local lBloqDtDem	:= .F.
//Controle de registros duplicados comparando com a quantidade de lançamentos permitidos
Local nCVerba		:= 1 //Inicializado com 1 devido a valor que obrigatoriamente deve conter de verba, caso haja diferença deve checar qtde de lanc limite
Local cVerbaAnt		:= "" //Controle de Verba Anterior
Local cVerbaAtu		:= "" //Controle de Verbas Atual
Local cMsgLog		:= ""
Local lItemClVl   	:= SuperGetMv( "MV_ITMCLVL", .F., "2" ) $ "1*3" // Define se trabalha com item e classe contabil
Local aErros		:= {}
Local lGera			:= .T.
Local cMsgAlert 	:= ""
Local cMsg			:= ""
Local lTpSuces		:= SRG->(ColumnPos("RG_TPSU")) > 0
Local cTpSuc		:= "3"
Local lResComp		:= .F.
Local lRetif		:= .F.

Private aPd_Aux		:= aPd_SRK

DEFAULT lVerMultv	:= If ( Type("P_MULTV") == "U",.F.,P_MULTV)
DEFAULT lTemSeqMV	:= If(SRC->(ColumnPos( 'RC_SEQMV' )) > 0,.T.,.F.)
DEFAULT lIntTaf 	:= ((SuperGetMv("MV_RHTAF",, .F.) == .T.) .AND. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 1 )
DEFAULT lMiddleware	:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )

FWModelActive( oModel )

 /*	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Nao deixa alterar informacoes caso a rescisao esteja aplicada. 					  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 	*/
If cModFol == "2" .and. (nOperation == MODEL_OPERATION_UPDATE .Or. nOperation == MODEL_OPERATION_DELETE) .And. !(RG_EFETIVA $ "1*2")
	Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0092), 1, 0 ) //"Esta rescisao ja foi aplicada. Portanto, não pode ser modificada."
	lRet:= .F.
EndIf

DbSelectArea("RCH")
DbSetOrder(1)
If DbSeek(xFilial("RCH",SRA->RA_FILIAL)+M->RG_PROCES+M->RG_PERIODO+M->RG_SEMANA+M->RG_ROTEIR)
	If M->RG_EFETIVA == 'S' .And. RCH->RCH_PERSEL <> "1"
		cMsgAlert := OemToAnsi(STR0219)
		Help(, , OemToAnsi(STR0020), , OemToAnsi(cMsgAlert), 1, 0, , , , , , { OemToAnsi(STR0220) })
		lRet := .F.
	EndIf
EndIf

/*	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Reclassifica o tipo de rescisao (caso for rescisao complementar ou complementar fora do mes). ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 	*/
If lRet .And. (nOperation == MODEL_OPERATION_UPDATE .Or. nOperation == MODEL_OPERATION_INSERT)
	If cModFol == "2"
		//Necessario igualar os campos de roteiro, pois o setRelation e feito atraves
		//de RG_APLROT em virtude do processo de aplicacao e reversao de aplicacao
		oModelSRG:LoadValue('RG_APLROT', oModelSRG:GetValue('RG_ROTEIR'))

		dbSelectArea("SRG")
		SRG->(DbSetOrder( RetOrdem( "SRG", "RG_FILIAL+RG_MAT+DTOS(RG_DTPAGO)" ) ))

		If SRG->(dbSeek(xFilial("SRG",SRA->RA_FILIAL)+SRA->RA_MAT)) .And. SRG->RG_DTPAGO <> M->RG_DTPAGO


		    If cPaisLoc $ "ARG*CHI*COL*COS*DOM*MEX"

				While SRG->(RG_FILIAL+RG_MAT) == xFilial("SRG",SRA->RA_FILIAL) + SRA->RA_MAT .And. lContinua
					If SRG->RG_RESCOMP == "1"
						cProcesso	:= SRG->RG_PROCES
						cRoteiro	:= SRG->RG_ROTEIR
						cPeriodo	:= SRG->RG_PERIODO
						cNumPago	:= SRG->RG_SEMANA
						lContinua:= .F.
					EndIf
					SRG->(dbSkip())
				End

			EndIf

			//procura o mes do periodo da rescisao
			cAnoAnt:= Posicione("RCH", 4, xFilial("RCH",SRA->RA_FILIAL)+cProcesso+cRoteiro+cPeriodo+cNumPago, "RCH_ANO")
			cMesAnt:= Posicione("RCH", 4, xFilial("RCH",SRA->RA_FILIAL)+cProcesso+cRoteiro+cPeriodo+cNumPago, "RCH_MES")
			cAnoAnt+= cMesAnt
			//procura o mes do periodo da nova rescisao. Se for no mesmo mes, mantem status 'rescisao complementar', caso contrario muda para 'rescisao compl. fora do mes'
			cAnoAtu:= Posicione("RCH", 4, xFilial("RCH",SRA->RA_FILIAL)+M->RG_PROCES+M->RG_ROTEIR+M->RG_PERIODO+M->RG_SEMANA, "RCH_ANO")
			cMesAtu:= Posicione("RCH", 4, xFilial("RCH",SRA->RA_FILIAL)+M->RG_PROCES+M->RG_ROTEIR+M->RG_PERIODO+M->RG_SEMANA, "RCH_MES")
			cAnoAtu+= cMesAtu

			If cAnoAnt < cAnoAtu
				If cPaisLoc $ "ARG*CHI*COL*COS*DOM*MEX"
					M->RG_RESCOMP:= "3"
				EndIf
			ElseIf cAnoAnt > cAnoAtu
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0093), 1, 0 ) //"O periodo selecionado eh anterior ao periodo em que foi calculada a rescisao"
				lRet:= .F.
			EndIf

		EndIf
	EndIf
EndIf

If lRet
/*	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Se eh inclusao, soh permite a confirmacao se a rescisao foi calculada.              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 	*/
	If nOperation == MODEL_OPERATION_INSERT
		If oGrid:Length() == 1 .And. (cPaisLoc != "BRA" .Or. (cPaisLoc == "BRA" .And. SRA->RA_CATEFD <> '111'))
			If Empty(oGrid:GetValue("RR_PD"))
				Help( ,, 'HELP',, OemToAnsi(STR0094), 1, 0 ) //"Para incluir uma rescisao ela deve ser calculada."##"Calcule a rescisao."
				lRet:= .F.
			Else
				If !IsBlind() .and. !( MsgNoYes(	OemToAnsi( STR0197 + CRLF + CRLF + STR0097),;//"Só houve a geração de uma verba no cálculo da rescisão."##"Deseja gravar mesmo assim?"
					OemToAnsi(STR0020) )) // "Atencao"
					cMsgLog := STR0198//"Rescisão não foi gravada."
					lRet	:= .F.
				EndIf
			EndIf
		Else
			cTpSuc := If(lTpSuces, oModelSRG:GetValue('RG_TPSU'), "3")
			If lTCFA040
				If VldTpRes() .And. fValEfdM040(M->RG_OBS, oModelSRG:GetValue('RG_OBITO'), oModelSRG:GetValue('RG_TIPORES'), oModelSRG:GetValue('RG_NPROC'), oModelSRG:GetValue('RG_SUCES'),cTpSuc)
					lRet := .T.
				Else
					Help( ,, OemToAnsi('Atenção'),, OemToAnsi('Utilize o Tipo de Rescisão informado na solicitação vinda do Portal.'), 1, 0 )
					lRet := .F.
				EndIf
			Else
				lRet := cPaisLoc != "BRA" .Or. fValEfdM040(M->RG_OBS, oModelSRG:GetValue('RG_OBITO'), oModelSRG:GetValue('RG_TIPORES'), oModelSRG:GetValue('RG_NPROC'), oModelSRG:GetValue('RG_SUCES'), cTpSuc, @cMsg)
				If Empty(cMsgLog)
					cMsgLog :=  cMsg
				Else
					cMsgLog += CRLF + cMsg
				Endif
			EndIf
		EndIf
	ElseIf nOperation == MODEL_OPERATION_UPDATE
	/*	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se eh alteracao, verifica se os dados foram alterados e se houve recalculo da rescisao ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 	*/
		If Len(oModelSRG:aDataModel) > 0
			For nAux2 := 1 To Len(oModelSRG:aDataModel[1])
				If oModel:IsFieldUpdated('GPEM040_MSRG', oModelSRG:aDataModel[1][nAux2][1])
					lAlteracao:= .T.
					Exit
				EndIf
			Next
		EndIf

		If lAlteracao
			If!( MsgNoYes(	OemToAnsi( STR0096 + CRLF + CRLF + STR0097),;//"Houve alteracao de campos no formulario e nao houve recalculo da rescisao."##"Deseja gravar mesmo assim?"
				 OemToAnsi(STR0020) )) // "Atencao"
				lRet:= .F.
			EndIf
		EndIf
	EndIf
EndIf

If lRet .and. nOperation == MODEL_OPERATION_DELETE
	DbSelectArea("RCH")
	DbSetOrder(1)
	If DbSeek(xFilial("RCH",SRA->RA_FILIAL)+M->RG_PROCES+M->RG_PERIODO+M->RG_SEMANA+M->RG_ROTEIR)
		If SRG->RG_EFETIVA == 'S' .And. !Empty(RCH->RCH_DTINTE)
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0102), 1, 0 ) //"Periodo já foi integrado com a folha de pagamento. Rescisão não poderá ser excluída."
			lRet := .F.
		EndIf
	EndIf

	// Valida bloqueio na exclusao
	If lRet
		If fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, fGetCalcRot('4') )
			dDtPerAt	:= aPerAtual[1,7]
			cSem		:= aPerAtual[1,2]
			lBloqAb 	:= !fVldAccess( cFilAnt, dDtPerAt, cSem, .F., fGetCalcRot("4") )
		EndIf
		lBloqDtDem	:= !fVldAccess( cFilAnt, M->RG_DATADEM, M->RG_SEMANA, .F., fGetCalcRot("4") )
		If lBloqAb .Or. lBloqDtDem // Periodo aberto esta bloqueado ou o periodo em que a rescisao foi calculada
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0149), 1, 0 ) //"Exclusão bloqueada para o período. Contate o Administrador."
			lRet := .F.
		EndIf
	EndIf
EndIf

If lRet .and. nOperation == MODEL_OPERATION_INSERT
	For nX := 1 to oGrid:Length()
		oGrid:GoLine(nX)
		If cModFol == "1" .and. oGrid:GetValue("RR_VALOR") < 0
			If MsgYesNo( OemToAnsi( STR0104 ) , OemToAnsi( STR0020) ) //Atenção. Existem valores negativos na rescisão. Continua?
				lRet := .T.
			Else
				lRet := .F.
			EndIf
			Exit
		EndIf
		If cModFol == "2" .and. oGrid:GetValue("RC_VALOR") < 0
			If MsgYesNo( OemToAnsi( STR0104 ) , OemToAnsi( STR0020) ) //Atenção. Existem valores negativos na rescisão. Continua?
				lRet := .T.
			Else
				lRet := .F.
			EndIf
			Exit
		EndIf
		If lItemClVl
			cVerbaAtu	:=  oGrid:GetValue("RR_PD")+oGrid:GetValue("RR_CC")+oGrid:GetValue("RR_ITEM")+oGrid:GetValue("RR_CLVL")
		Else
			cVerbaAtu	:=  oGrid:GetValue("RR_PD")+oGrid:GetValue("RR_CC")
		EndIf
		if  cVerbaAnt == cVerbaAtu
			nCVerba	+= 1
		EndIf
		If cVerbaAnt <> cVerbaAtu .Or. (cVerbaAnt == cVerbaAtu .And. nX == oGrid:Length())
			if (nCVerba > 1 .And. nCVerba > Val(Posicione("SRV",1,xFilial("SRV")+cVerbaAnt ,"RV_QTDLANC")))
				if Empty(cMsgLog)
					cMsgLog += STR0169 + CRLF
				EndIf
				cMsgLog += cVerbaAnt +' - ' + Posicione("SRV",1,xFilial("SRV")+cVerbaAnt ,"RV_DESC") + CRLF
			EndIf
			cVerbaAnt := cVerbaAtu
			nCVerba	:= 1
		EndIf
	Next nX
EndIf

if !Empty(cMsgLog)
	Help( ,, STR0170 , ,OemToAnsi( cMsgLog) , 1 , 0 )
	lRet := .F.
EndIf

If lRet .And. cPaisLoc == "BRA"
	If lVerMultv .and. lTemSeqMV
		If nOperation <> MODEL_OPERATION_DELETE
			cSeqMV := "9" //Força a gravação da RAZ/RAW
			aPd := aClone(aPdRAW)
			fGrvRAZRAW(.T.)
			aPd := {}
		Else
			fDelRAZRAW()
		EndIf
	EndIf

	// Valida se o conteúdo do parâmetro MV_FASESOC é válido
	If SuperGetMv("MV_RHTAF",, .F.) .And. !Empty(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) .And. !SuperGetMv("MV_FASESOC",/*lHelp*/,' ') $ "1|2"
		// "Conteúdo do parâmetro MV_FASESOC inválido." # "Verifique o conteúdo do parâmetro MV_FASESOC." # "Os valores permitidos são: " # " (Vazio) - Primeira fase" # "1 - Primeira e segunda fase" # "2 - Primeira, segunda e treiceira fase"
		Help(NIL, NIL, "MV_FASESOC", NIL, STR0230, 1, 0, NIL, NIL, NIL, NIL, NIL, { STR0231 + CRLF + STR0232 + CRLF + STR0233 + CRLF + STR0234 + CRLF + STR0235 })
		lRet := .F.
	EndIf
	//Integracao com o TAF
	If (lIntTaf .Or. lMiddleware) .And. fResCompl(@lGera, Nil, nOperation, @lResComp, @lRetif, Nil, cOpcCompl) .And. M->RG_EFETIVA == 'S' .And. lRet
		lRet := fGeraIntegracao( oModelSRG, oGrid, lRet, @aErros, oModel, lResComp, lRetif)
	EndIf
EndIf
//Retornado pela função fResCompl, se rescisão complementar com pagto de PLR e outras verbas, perguntar se quer
//enviar ao TAF ou cancelar o cálculo e fazer os pagamentos em 2 complementares, uma com o PLR e a outras com os outros pagamentos.
If !lGera .And. lRet
	lRet := lGera
	Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0218), 1, 0 ) //"Atenção, Cálculo de Rescisão cancelado pelo usuário."
Endif

If lRet
	fDelTMPMED()
EndIf

If lRet .And. FindFunction( 'ngIntegra' ) .And. oModel:GetOperation() != 5 // Finaliza o programa e a tarefa do funcionário
	ngIntegra( { SRA->RA_MAT, M->RG_DATADEM } )
EndIf

RestArea(aArea)
Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GP40VldTpResºAutor  ³Leandro Drumond   º Data ³  12/12/2013 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica o tipo de rescisao para o funcionario             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³GPEM040													  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GP40VldTpRes(cTab,cTpRes)

Local lRet 	    := .F.
Local cDesc		:= ""
Local cTpAviso  := ""
Local cCodAfa	:= ""
Local cDesTpRes	:= ""
Local cDesAvPre	:= ""
Local cCateg	:= "721,722"
Local dDataAv	:= CtoD("")
Local oModel	:= FWModelActive()
Local lExbAlert := .T.
Local aRet      := array(2)
Local cVersEnvio:= ""
Local cVersGPE  := ""
Local cTrabVinc := fCatTrabEFD("TCV") //Retorna todos os Trab. Com Vínculo
Local cTrabSVinc:= fCatTrabEFD("TSV") //Retorna todos os Trab. Sem Vínculo
Local lTrabVinc := .F.
Local lTrabSVinc:= .F.
Local lTabS043	:= .F.
Local cMotEsoc	:=  ""
Local lRobo		:= IsBlind()

If cPaisLoc == "BRA"
	lTrabVinc := SRA->RA_CATEFD $ cTrabVinc
	lTrabSVinc:= SRA->RA_CATEFD $ cTrabSVinc
	If lTrabSVinc
	    lRet := fVersEsoc( 'S2399', lExbAlert, , @aRet, @cVersEnvio,@cVersGPE )
	Else
	    lRet := fVersEsoc( 'S2299', lExbAlert, , @aRet, @cVersEnvio,@cVersGPE )
	EndIf

	DEFAULT nDferven  := 0
	DEFAULT nDferave  := 0
	DEFAULT nFaltasv  := 0
	DEFAULT nFaltasp  := 0
EndIf

DEFAULT cTpRes 		:= &(ReadVar())
DEFAULT lIntTaf 	:= ((SuperGetMv("MV_RHTAF",, .F.) == .T.) .AND. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 1 )
DEFAULT lMiddleware	:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )

Private lMetFalV	:= If( Type("lMetFalV") == "U", .F., lMetFalV)
Private LTEMPOPARC	:= If( Type("LTEMPOPARC") == "U", .F., LTEMPOPARC)
Private LMETFALP	:= If( Type("LMETFALP") == "U", .F., LMETFALP)

Private lTpRes    := .T.
Private nDFerPag  := 0.00

If cTab <> Nil
	dbSelectArea( "RCC" )
	dbSetOrder(1)
	If dbSeek(xFilial("RCC",SRA->RA_FILIAL) + cTab + xFilial("SRA") )
		While !Eof() .and. RCC->RCC_FILIAL+RCC_CODIGO+RCC_FIL == xFilial("RCC",SRA->RA_FILIAL)+cTab+ xFilial("SRA")
			If RCC->RCC_FILIAL+RCC_CODIGO == xFilial("RCC",SRA->RA_FILIAL)+cTab .and. Alltrim(Substr(RCC->RCC_CONTEU,1,2)) == AllTrim(cTpRes)
				cDesc := Alltrim(Substr(RCC->RCC_CONTEU,3,30))
				cTpAviso := Alltrim(Substr(RCC->RCC_CONTEU,34,1))
				cTpRsDir := Alltrim(Substr(RCC->RCC_CONTEU,63,2))
				cCodAfa  := Alltrim(Substr(RCC->RCC_CONTEU,50,1))
				cMotEsoc := Alltrim(Substr(RCC->RCC_CONTEU, 62, 1))
				lRet := .T.
				lTabS043 = .T.
				Exit
			EndIf
			dBSkip()
		EndDo
	EndIf

	If !lTabS043
		dbSeek(xFilial("RCC",SRA->RA_FILIAL) + cTab  )
		While !Eof() .and. RCC->RCC_FILIAL+RCC_CODIGO == xFilial("RCC",SRA->RA_FILIAL)+cTab
			If RCC->RCC_FILIAL+RCC_CODIGO == xFilial("RCC",SRA->RA_FILIAL)+cTab .and. Alltrim(Substr(RCC->RCC_CONTEU,1,2)) == AllTrim(cTpRes)
				cDesc := Alltrim(Substr(RCC->RCC_CONTEU,3,30))
				cTpAviso := Alltrim(Substr(RCC->RCC_CONTEU,34,1))
				cTpRsDir := Alltrim(Substr(RCC->RCC_CONTEU,63,2))
				cCodAfa  := Alltrim(Substr(RCC->RCC_CONTEU,50,1))
				cMotEsoc := Alltrim(Substr(RCC->RCC_CONTEU, 62, 1))
				lRet := .T.
				lTabS043 := .T.
				Exit
			EndIf
			dBSkip()
		EndDo
	EndIf

	If !lTabS043
		Help(" ",1, "NOTAB")
	Else
	    If cPaisLoc == "MEX"
	    	oModel:LoadValue("GPEM040_MSRG","RG_DESCTPR",cDesc)
		EndIf
	EndIf
EndIf

If (lIntTaf .Or. lMiddleware) .And. cPaisLoc == "BRA" .And. lTrabVinc .And. lTabS043 .And. Empty(cMotEsoc)
	Help(,, OemToAnsi(STR0020),, + CRLF + OemToAnsi(STR0143) + " " + SRA->RA_CATEFD + ", " + OemToAnsi(STR0294), 1, 0,,,,,, { + CRLF + OemToAnsi(STR0295)})//"Atencao" ## "Para func. Cat.eSocial contido em:" ### " a coluna Mot. eSocial. (tabela S043) deverá estar preenchida." ### "Altere a tabela S043 e preencha o campo Mot. eSocial para o tipo de rescisão."
	lRet := Iif(lRobo, .T., .F.)
EndIf

If cPaisLoc <> "MEX"
	If lRet .And. cPaisLoc == "BRA" .and. !Empty(cRfyTpAv)
		If cTpAviso $ "I*T*N*D*B"
			If ((cRfyTpAv $ "1*2*5" .Or. ( cRfyTpAv == "6" .And. cVersEnvio >= "2.4.02") ) .AND. cTpAviso $ "T*B")
				If cCodAfa == "I"
					lRet := .T.
				Else
					Help( ,, OemToAnsi(STR0020),, STR0208  , 1, 0 ) //STR0208 # "Código de Afastamento de FGTS informado no Tipo de Recisão é incompativél com o tipo de Aviso Prévio."
					lRet := .F.
				Endif
			Elseif (cRfyTpAv $ "4" .AND. cTpAviso $ "T")
				If cCodAfa == "J"
					lRet := .T.
				Else
					Help( ,, OemToAnsi(STR0020),, STR0208  , 1, 0 ) //STR0208 # "Código de Afastamento de FGTS informado no Tipo de Recisão é incompativél com o tipo de Aviso Prévio."
					lRet := .F.
				Endif
			Elseif (cRfyTpAv $ "3" .AND. cTpAviso $ "N" )
				lRet := .T.
			Else

				//Montagem da descricao do tipo da rescisao para exibicao na mensagem
				If cTpAviso $ "T*B"
					cDesTpRes := STR0154  //"está como T - Trabalhado " 154
				Elseif cTpAviso == "I"
					cDesTpRes := STR0155  //"está como  I - Indenizado " 155
				Elseif cTpAviso == "N"
					cDesTpRes := STR0156  //"esta como N - Não Previsto" 156
				Else
					cDesTpRes := STR0157  //"está como D - Descontado " 157
				Endif

				//Montagem da descricao do tipo do aviso para exibicao na mensagem
				If cRfyTpAv == "1"
					cDesAvPre := STR0158 //" 1- Aviso Previo Trabalhado dado pelo empregador ao empregado" 158
				Elseif cRfyTpAv == "2"
					cDesAvPre := STR0159 //" 2- Aviso Previo Trabalhado dado pelo empregador ao empregado" 159
				Elseif cRfyTpAv == "3"
					cDesAvPre := STR0160 //" 3 – Aviso Previo por Pedido de Demissão, Dispensado do seu cumprimento" 160
					ElseIf (cRfyTpAv =="6" .And. cVersEnvio >= "2.4.02")
				     cDesAvPre := STR0215
				Else
					cDesAvPre := STR0161 //"4 - Aviso Previo Trabalhado dado pelo empregado ao empregador (pedido de demissão)." 161
				Endif

				//"Atencao" ## STR0020 "
				//Aviso Previo informado no Tipo de Rescisao (<Cod.TpRes> - <Desc.Aviso>) esta divergente com o tipo de aviso cadastrado para esse funcionario
				//(<Cod.TpAvPrv> - <Desc.TpAvPrv>). Ajuste o tipo de rescisao ou o cadastro do aviso previo.
				//Lembrando que o cadastro do aviso previo nao deve ser realizado quando este for indenizado/descontado(pedido demissao).

				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0162) + ":  "+ cTpRes + " - " + cDesc + " "+cDesTpRes+" , " + OemToAnsi(STR0163) + ": " +  cDesAvPre +". " + chr(13)+ chr(13)+ OemToAnsi(STR0164)  , 1, 0 )

				lRet:= .F.
			Endif
		Endif
	Endif

	If lRet .And. cPaisLoc == "BRA"
		If SRA->RA_CATEFD $ "721|722"
			If Empty(cTpRsDir)
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0143) + " " + cCateg +"." + OemToAnsi(STR0144), 1, 0 ) //"Atencao" ## "Para func. Cat.eSocial contido em:"###" a coluna Tp.Res.Dir. (tabela S043) devera estar preenchida."
				lRet := .F.
			Else
				oModel:LoadValue("GPEM040_MSRG","RG_TPDIR",cTpRsDir)
			EndIf
		EndIf
	EndIf

	If lRet

		If cPaisLoc == "BRA"

			fIncRes(SRA->RA_FILIAL,cTpRes,@aIncRes,@nPercFgts,@cRescrais,@cAfasfgts,@Cod_Am)
			If !Empty(aIncRes) .And. Len(aIncRes)>=17
				lProJav	  := aIncRes[17] == "S"
			Else
				Help( ,, OemToAnsi(STR0020),, OemToAnsi("Tipo de Rescisão não encontrado."), 1, 0 )//Tipo de Rescisão não encontrado.
				lRet:= .F.
			EndIf
			If RCE->(ColumnPos( "RCE_PRJAVT")) > 0
				If (fDesc( "RCE", SRA->RA_SINDICA, "RCE_PRJAVT" )) == "2"
					lProj := .F.
				Endif
			Else
				lProj := .T.
			Endif

			If !lTemRFY
				If !cCompl == "S"
					nDiasAv := GP40DiasAv(@dDataAv,,cTpAviso,@nDiasCum, @nDiaInde)
				EndIf
				If (!Empty(aIncRes) .And.  !(aIncRes[2] $ "I/A")) .Or. cPaisLoc == "BRA"
					oModel:LoadValue("GPEM040_MSRG","RG_DTAVISO",dDataAv)
				EndIf

				If ( cPaisLoc == 'BRA' )
					If SRG->(ColumnPos( "RG_DAVCUM")) > 0 .And. SRG->(ColumnPos( "RG_DAVIND")) > 0
						oModel:LoadValue("GPEM040_MSRG","RG_DAVCUM",nDiasCum)
						oModel:LoadValue("GPEM040_MSRG","RG_DTPROAV",dDtProje)
						oModel:LoadValue("GPEM040_MSRG","RG_DAVIND",nDiaInde)
					Endif
				ENdIf

				oModel:LoadValue("GPEM040_MSRG","RG_DAVISO",nDiasAV)
				oModel:LoadValue("GPEM040_MSRG","RG_DATADEM",dDataDem1)
			Else
				If !Empty(M->RG_DTAVISO)
					nDiasAv := ( dDataDem - M->RG_DTAVISO ) + 1
				EndIf
				If !Empty(aIncRes) .And. aIncRes[2] $ "N|D"
					dDtProje := CTOD("//")
				ElseIf !Empty(dDataAv)
					dDtProje := dDataAv + nDiasAv
				Endif
				oModel:LoadValue("GPEM040_MSRG","RG_DAVISO",nDiasAV)
				If ( cPaisLoc == 'BRA' )
					If SRG->(ColumnPos( "RG_DAVCUM")) > 0 .and. SRG->(ColumnPos( "RG_DAVIND")) > 0
						oModel:LoadValue("GPEM040_MSRG","RG_DTPROAV",dDtProje)
					Endif
				EndIf
				lDtDemRFY := .T.
			EndIf

		ElseIf cPaisLoc == "BOL"
			fIncRes(SRA->RA_FILIAL, cTpRes, @aIncRes, @nPercFgts, @cRescrais, @cAfasfgts, @Cod_Am)
		EndIf

		oModel:LoadValue("GPEM040_MSRG","RG_DESCTPR",cDesc)
		If cPaisLoc == "BRA"
			oModel:LoadValue("GPEM040_MSRG","RG_TPAVISO",cTpAviso)
			If SRA->RA_CATEFD == "721"
				oModel:LoadValue("GPEM040_MSRG","RG_TPDIR",aIncRes[18])
			EndIf
		EndIf
		nFalAtuD := 0


		If cPaisLoc <> "BRA" .OR. !Empty(dDataDem1)
			//Calcula dias de ferias
			aPerFerias := {}
			fdFerRes(.T.,dDataDem1)

			oModel:LoadValue("GPEM040_MSRG","RG_DFERVEN", If(!lMetFalv, If(!lTempoParc, nDferven - nFaltasv, 0), nDferven / 2))
			oModel:LoadValue("GPEM040_MSRG","RG_DFERPRO", If(!lMetFalp, If(!lTempoPArc, nDferave - nFaltasp, 0), nDferave / 2))

			If(cPaisLoc == 'BRA')
				If (SRA->RA_TPCONTR == "3" .Or. SRA->RA_CATEFD $ '107/108') .and. nDferInd > 0
					nDferInd := 2.5	// Intermitente sempre será 1 avo
				EndIf
				oModel:LoadValue("GPEM040_MSRG","RG_DFERAVI",nDferInd)
			EndIf
		Endif
	EndIf
EndIf

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gp40VldAvP  ºAutor  ³Leandro Drumond   º Data ³  14/12/2013 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Atualiza a data de aviso de acordo com os dias de aviso    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³GPEM040													  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Gp40VldAvP()

Local oModel
Local dDataAv 	 := CtoD("")
Local nDAvInf    := 0 // Variável para buscar os dias digitados no campo RG_DAVISO
Local nDAvIndInf := 0 // Variável para buscar os dias digitados no campo RG_DAVIND
Local nDAvCumInf := 0 // Variável para buscar os dias digitados no campo RG_DAVCUM

DEFAULT lGestPubl := IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP

oModel := FWModelActive()
lTemRFY := If(ValType(lTemRFY) == "L", lTemRFY, .F.)

If !lTemRFY
	nDiasAv := &(ReadVar())

	If cPaisLoc <> "ARG" .AND. !(nDiasAv == 0 .And. !Empty(aIncRes) .And. aIncRes[02] == "T") .And. !Empty(dDatadem)
		dDataAv := M->RG_DTAVISO
	EndIf

	If cPaisLoc <> "ARG" .AND. !Empty(aIncRes) .And. !(aIncRes[02] $ "I/A")
		If cPaisLoc == "BRA" .and. (lProjav .or. lProj)
			If SRG->(ColumnPos( "RG_DAVCUM")) > 0 .and.  SRG->(ColumnPos( "RG_DAVIND")) > 0

				//Tratativa para o caso do usuário digitar os dias de aviso previo manualmente na rescisão, para casos em que o trabalhador comprovou ter outro emprego.
				nDAvInf    := oModel:GetValue("GPEM040_MSRG","RG_DAVISO") // Carrega os valores digitados pelo usuário
				nDAvIndInf := oModel:GetValue("GPEM040_MSRG","RG_DAVIND") // Carrega os valores digitados pelo usuário
				nDAvCumInf := oModel:GetValue("GPEM040_MSRG","RG_DAVCUM") // Carrega os valores digitados pelo usuário
				//Fim

				nDiascum := If (nDiasAv < 30, nDiasAv, nDiascum)
				nDiaInde := nDiasAv - nDiascum
				nDiasCum := nDiasAv - nDiaInde

				//Tratativa para o caso do usuário digitar os dias de aviso previo manualmente na rescisão, para casos em que o trabalhador comprovou ter outro emprego.
				nDiasAv  := nDAvInf
				nDiascum := If(nDAvCumInf > nDAvInf, nDAvInf, nDAvCumInf)
				nDiaInde := nDAvInf - nDiascum


				M->RG_DAVIND := nDiaInde
				M->RG_DAVCUM := nDiasCum

				If !Empty(dDataAvis)
					dDatadem1:= dDataAvis + nDiasCum + nDiaInde
				EndIf

				//Calcula dias de ferias
				//Nesse caso, não existe a RFY, portanto, caso o usuário troque os dias de aviso prévio, será necessário recalcular as férias de acordo os os valores digitados pelo usuário.
				If lGestPubl .AND. cPaisLoc == "BRA" .AND. SRA->RA_REGIME == "2" .AND. FindFunction("fdFerResFP")
					fdFerResFP(.T.,dDataDem1)
				Else
					aPerFerias := {}
					fdFerRes(.T.,dDataDem1)
				EndIf
				oModel:LoadValue("GPEM040_MSRG","RG_DFERVEN", If(!lMetFalv, If(!lTempoParc, nDferven - nFaltasv, 0), nDferven / 2))
				oModel:LoadValue("GPEM040_MSRG","RG_DFERPRO", If(!lMetFalp, If(!lTempoParc, nDferave - nFaltasp, 0), nDferave / 2))
				If (SRA->RA_TPCONTR == "3" .Or. SRA->RA_CATEFD $ '107/108') .and. nDferInd > 0
					nDferInd := 2.5	// Intermitente sempre será 1 avo
				EndIf
				oModel:LoadValue("GPEM040_MSRG","RG_DFERAVI",nDferInd)
				//Fim Tratativa

			ElseIf !Empty(dDataAvis)
				dDatadem1:= dDataAvis + nDiasAv
			EndIf

			M->RG_DATADEM := dDataDem1
			oModel:LoadValue("GPEM040_MSRG","RG_DAVISO",nDiasAV)
			If SRG->(ColumnPos( "RG_DAVCUM")) > 0 .and.  SRG->(ColumnPos( "RG_DAVIND")) > 0
				oModel:LoadValue("GPEM040_MSRG","RG_DAVCUM",nDiasCum)
				oModel:LoadValue("GPEM040_MSRG","RG_DAVIND",nDiaInde)
			Endif
			oModel:LoadValue("GPEM040_MSRG","RG_DATADEM",dDataDem1)
			oModel:LoadValue("GPEM040_MSRG","RG_DTGERAR",dDataDem1)
			oModel:LoadValue("GPEM040_MSRG","RG_DTPROAV",dDatadem1) // Atualiza a data projetada.
		Endif
	Else
		If !Empty(aIncRes) .And. aIncRes[02] == "A"
			nDiaInde := nDiasAv / 2
		Else
			nDiaInde := nDiasAv
		EndIf
		If ( cPaisLoc == 'BRA' )
			If SRG->(ColumnPos( "RG_DAVIND")) > 0
				M->RG_DAVIND := nDiaInde
			Endif
		ENdIf
	EndIf
EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fValDtResc   ³ Autor ³ EquipeRH		       ³ Data ³ 07/02/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se data está correta, ou seja tem que ser maior que a ³±±
±±³          ³data de admissão. E nao pode haver qualquer tipo de transfe-   ³±±
±±³          ³cia apos a data de demissão.									 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fValDtResc()                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fValDtResc(dData)
Local lRet		:= .T.
Local nX		:=0
Local aTransf	:={}

DEFAULT dData:= M->RG_DATADEM

If !Empty(dData)

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se o Funcionario tem Transferencia                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If fTransf(@aTransf,,,,,,,.T.)
		For nX := 1 To Len( aTransf )
			If dData < aTransf[ nX , 7 ]
				lRet:= .F.
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0049), 1, 0 )	//"Existe Transferência Posterior à Data Informada"
				Return lRet
			EndIf
		Next nX
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Demissao nao Pode ser Inferior a Admissao                  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If lRet .And. dData < SRA->RA_ADMISSA
		lRet:= .F.
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0044), 1, 0 )	//"Data de Demissao nao Pode Ser Inferior a Admissao"
		Return lRet
	EndIf
EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCargaDFerias³ Autor ³ Erika Kanamori        ³ Data ³ 11/08/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Carrega dias vencidos e proporcionais de ferias do cabecalho da³±±
±±³          ³rescisao                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fCargaDFerias()                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fCargaDFerias()

fVAC_RESM2()

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fVAC_RESM2   ³ Autor ³ EquipeRH		       ³ Data ³ 11/08/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rotina copia funão fCargaDFerias 30/11/11 (ver historico TFS)  ³±±
±±³          ³Realiza carga dias vencidos e proporcionais de ferias no       ³±±
±±³          ³cabecalho rescisao, para paises Modelo 2 e diferente Argentina.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fCargaDFerias()                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fVAC_RESM2(nDiasVacV, nOpc)
Local oModel	:= FWModelActive()
Local oModelSRG	:= Nil
Local nOperation:= oModel:GetOperation()
Local oViewSRG	:= FWViewActive()
Local aPerFerias:= {}
Local nDFerVen	:= 0
Local nDFerAVe	:= 0
Local nDFerPag	:= 0
Local nDFerDir	:= 0
Local nDFerPagV	:= 0
Local x			:= 0
Local nAno		:= 0
Local nDiasFer	:= 0
Local nDiasProp	:= 0
Local lRet		:= 	.T.

Default nDiasVacV 	:= 0
Default nOpc		:= 0

If Type("cModel") == "C" .AND. ! Empty(cModel)
	oModelSRG	:= oModel:GetModel(cModel)
Else
	oModelSRG	:= oModel:GetModel('GPEM040_MSRG')
EndIf


If (nOperation == MODEL_OPERATION_INSERT .Or. (nOperation == MODEL_OPERATION_UPDATE) )

	If lRet
		If cPaisLoc =='CHI' // carga Vacaciones progresivas
			nVacProgre:= Gp042VacProg()
			If nVacProgre > 0
				oModelSRG:LoadValue('RG_DFERPRG', nVacProgre )
			Else
				oModelSRG:LoadValue('RG_DFERPRG', 0 )
			EndIf
		Endif
		CargaFerias(@aPerFerias, Iif(nOpc==1,SRA->RA_DEMISSA,M->RG_DATADEM))

		If Len(aPerFerias)> 0

			If cPaisLoc # 'ARG'
		        //A seguir trecho recuperado da data 30/11/11, para tratamento de modelo 2
		        //Tomar cuidado neste chamado, pois a mesma só está preparada para os paises COS|DOM
		        //Na rotina CargaFerias esta detalhado o que é avaliado para cada pais
				Aeval(aPerFerias,{|x| (nDFerVen += x[5], nDFerAVe += x[4], nDFerPag += x[7])})

					//desconta dias pagos
				If cPaisLoc <> "CHI"
					If nDFerVen > nDFerPag
						nDFerVen:= nDFerVen - nDFerPag
					Else
						nDFerVen:= 0
						nDFerPag:= nDFerPag - nDFerVen
						nDFerAVe:= Max(nDFerAVe - nDFerPag, 0)
					Endif
				Else
					nDFerVen := Gp042VacProg(.T.)
				EndIF

				If cPaisLoc =='CHI'
					// carga Vacaciones Proporcionales CHILE
					oModelSRG:LoadValue('RG_DFERVEN', nDFerVen )
					nVacProp:= Gp042VaPc()
					oModelSRG:LoadValue('RG_DFERPRO', nVacProp )
				Else
					oModelSRG:LoadValue('RG_DFERVEN', nDFerVen )
					If  nOpc != 1
						oModelSRG:LoadValue('RG_DFERPRO', nDFerAVe )
					Endif
				EndIf
			Else
				//Tratamento especifico para Argentina

				nAno := year(M->RG_DATADEM)
				//Aqui preninimos qdo ano de admissao e demissao iguais, e admissao maior que 01/01/ANO
				dDataIni:= Iif(nAno == year(SRA->RA_ADMISSA),SRA->RA_ADMISSA,CTOD("01/01/"+STR(nAno)))
				fDiasFerArg(.T.,dDataIni,M->RG_DATADEM,@nDiasFer,@nDiasProp, .T.)

				For x:=1 To Len(aPerferias)
					//Tratamento para anoCivil colocar o If do parame
					If nAno == Year(aPerFerias[x,1]) .And. nAno == Year(aPerFerias[x,2])
						//Ferias proporcionais
						//com o mesmo periodo de RG_PERIODO - periodo SRF_VIGENTE
						nDFerPagV	+= aPerferias[x,7]	//RF_DFERANT = Ferias Pagas
					ElseIf (Year(aPerFerias[x,1]) < nAno  .And. Year(aPerFerias[x,2]) < nAno)
						nDFerDir	+= aPerferias[x,3]	//RF_DIASDIR = Dias de Direito
						nDFerPag	+= aPerferias[x,7]	//RF_DFERANT = Ferias Pagas
					EndIf
				Next x

				//Ferias Proporcionais do periodo vigente
				nDFerAve	:= nDiasProp - nDFerPagV

				//Ferias Nao gozadas
				//Se nDFerAve for negativo, entrará na conta a seguir, caso contrario não
				nDFerVen    := ((Iif (nDFerAve>0, 0, nDFerAve) )  + nDFerDir ) - nDFerPag

				oModelSRG:LoadValue('RG_DFERVEN', Iif (nDFerVen > 0 ,nDFerVen, 0) )
				oModelSRG:LoadValue('RG_DFERPRO', Iif (nDFerAVe > 0, nDFerAVe, 0) )
			EndIf
		Else
			oModelSRG:LoadValue('RG_DFERVEN', 0)
			If  nOpc != 1
				oModelSRG:LoadValue('RG_DFERPRO', 0)
			Endif
		EndIf

		//Roteiro e Periodo irei limpar, para que os mesmos sejam preenchidos adequadamente
		If cPaisLoc == "BRA"
			oModelSRG:LoadValue('RG_ROTEIR', '')
			oModelSRG:LoadValue('RG_PERIODO', '')
		EndIf

		If oViewSRG != Nil .And. oViewSRG:lActivate .And. cPaisLoc !='CHI'
			oViewSRG:Refresh()
	EndIf
EndIf
EndIf

If  nOpc == 1
	nDiasVacV := nDFerVen
Endif

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fSRGWhen     ³ Autor ³ Leandro Drumond       ³ Data ³ 12/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³When dos campos da SRG										 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fSRGWhen()                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fSRGWhen(cCampo)
Local lRet := .F.

DEFAULT lGestPubl := IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP

If cCampo == "RG_EFETIVA"
	lRet := .T.
ElseIf lAtuSimul //Se for efetivacao da simulacao, nao permite o preechimento de nenhum outro campo
	lRet := .F.
ElseIf cCampo $ "RG_DATAHOM*RG_MEDATU*RA_FECREI*RA_BLOQADM"
	lRet := .T.
ElseIf cCampo == "RG_SABDOM" .And. !Empty(dDataDem) .And. !lTemRFY
	lRet := .F.
ElseIf lGestPubl .AND. cModulo $ 'GFP*VDF' .AND. cCampo == "RG_NOVSUBS"
	lRet := .T.
ElseIf cCompl == "S"
	If lRescRRA .and. cCampo == "RG_IDCMPL"
		lRet := .T.
	ElseIf cCampo == "RG_DTGERAR" .or. ( cCampo == "RG_DATADEM" .and. lModDataDem ) .or. ( cCampo == "RG_DATADEM" .and. Empty(SRG->RG_DATADEM) )
		lRet := .T.
	ElseIf lIndAv .And. cCampo $ "RG_INDAV"
        lRet := .T.
	EndIf
ElseIf cCampo == "RG_DTGERAR" .And. cCompl <> "S" .And. !lRecRes //se não for complementar e nem recálculo
    lRet := .T.
Elseif cCampo == "RG_OBITO"
	lRet := fObitoWhen()
Elseif cCampo == "RG_CONFIC"
	lRet := .F.
Else

	If lRescRRA .and. cCampo == "RG_IDCMPL"
		lRet := .T.
	ElseIf 	(  (( cPaisLoc != 'BRA' ) .And. cCampo $ "RG_TIPORES*RG_DATADEM*RG_DTAVISO*RG_DAVISO*RG_SABDOM*RG_JTCUMPR*RG_COMPRAV*RG_DESCTPR*RG_NPROC*RG_OBITO*RG_SUCES*RG_OBS*RG_TPSU")     ;
	           .or. ;
	           (( cPaisLoc == 'BRA' ) .And. cCampo $ "RG_TIPORES*RG_DATADEM*RG_DTAVISO*RG_DAVISO*RG_SABDOM*RG_JTCUMPR*RG_COMPRAV*RG_DESCTPR*RG_NPROC*RG_OBITO*RG_SUCES*RG_OBS*RG_DAVCUM*RG_DAVIND*RG_NPROCS*RG_TPSU")  ;
	        )


		If lTemRFY .and. cCampo $ "RG_DTAVISO*RG_DAVISO"
			If lDtDemRFY
				lRet := .T.
				If cCampo == "RG_DTAVISO"
					lDtDemRFY := .T.
				EndIf
			Else
				lRet := .F.
			EndIf
		ElseIf cCampo $ "RG_DAVCUM*RG_DAVIND" .and. Empty(dDataDem)
			lRet := .F.
		Else
			lRet := .T.
		EndIf
	ElseIf cCampo $ "RG_NORMAL*RG_DESCANS"
		lRet := .T.
   ElseIf lIndAv .And. cCampo $ "RG_INDAV"
    	lRet := .T.
	EndIf
EndIf

If GetSx3Cache(cCampo, "X3_PROPRI") == "U"
	lRet := .T.
EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³AbreCadastro³ Autor ³Erika Kanamori		  ³ Data ³ 14/09/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Faz chamada de telas de cadastro e tratamento para calculo    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³nOpcaoTela: opcao a ser chamada                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function AbreCadastro(nOpcaoTela)
Local aArea			:= GetArea()
Local oModel      	:= FWModelActive()
Local oGrid			:= oModel:GetModel("GPEM040_MGET")

Private lResM2	:= .T. 	//flag que indica se deve ou nao mostrar o browse inicial
Private lM2Modif:= .F. //variavel para saber se houve alteracoes no cadastro
Private lAvPrevRfy	:= .F.

DEFAULT lGestPubl := IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP

lTempoParc	:= If( Type("LTEMPOPARC") == "U", .F., lTempoParc)
lMetFalp	:= If( Type("LMETFALP") == "U", .F., lMetFalp)
lMetFalv	:= If( Type("LMETFALV") == "U", .F., lMetFalv)

Do Case
	Case nOpcaoTela== 1 //"Lançamentos Fixos"
		GpeA550()
	Case nOpcaoTela== 2 //"Incidências por funcionário"
		 GPEA580()
	Case nOpcaoTela== 3 //"Ausências"
		GpeA240()
	Case nOpcaoTela== 4 //"Valores Futuros"
		GPEA110()
	Case nOpcaoTela== 5 //"Tempo Extra"
		Gpea640()
	Case nOpcaoTela== 6 //"Integrações"
		Gpem019()
	Case nOpcaoTela== 7 //Medias
		fVerMedia("R")
	Case nOpcaoTela== 8 //Controle dias de direito
		Gpea050(1)
	Case nOpcaoTela == 9
		fImpPonto()
	Case nOpcaoTela== 10 //Cadastro de aviso previo
		Gpea925(,,4)
EndCase

If lAvPrevRfy
	fInitModel(oModel,oModel:GetOperation())
Endif


If lM2Modif .and. !Empty(dDataDem) .And. cCompl <> "S"
	//Calcula dias de ferias
	If lGestPubl .AND. cPaisLoc == "BRA" .AND. SRA->RA_REGIME == "2" .AND. FindFunction("fdFerResFP")
		fdFerResFP(.T.)
	Else
		aPerFerias := {}
		fdFerRes(.T.)
	EndIf

	oModel:LoadValue("GPEM040_MSRG","RG_DFERVEN", If(!lMetFalv, If(!lTempoParc, nDferven - nFaltasv, 0), nDferven / 2))
	oModel:LoadValue("GPEM040_MSRG","RG_DFERPRO", If(!lMetFalp, If(!lTempoParc, nDferave - nFaltasp, 0), nDferave / 2))

	If(cPaisLoc == 'BRA')
		If (SRA->RA_TPCONTR == "3" .Or. SRA->RA_CATEFD $ '107/108') .and. nDferInd > 0
			nDferInd := 2.5	// Intermitente sempre será 1 avo
		EndIf
		oModel:LoadValue("GPEM040_MSRG","RG_DFERAVI",nDferInd)
	EndIf

	//ATUALIZA VARIAVEIS DA TELA
	M->RG_DFERVEN := If(!lMetFalv, If(!lTempoParc, nDferven - nFaltasv, 0), nDferven / 2)
	M->RG_DFERPRO := If(!lMetFalp, If(!lTempoParc, nDferave - nFaltasp, 0), nDferave / 2)

	If(cPaisLoc == 'BRA')
		M->RG_DFERAVI := nDferInd
	EndIf

	If oGrid:Length() > 1
		If( MsgNoYes(	OemToAnsi( STR0051 + CRLF + CRLF + STR0052),;//"Estas modificações só terão efeito se a rescisão for recalculada."##"Deseja recalcular agora?"
			OemToAnsi(STR0020) )) // "Atencao"
			CalResc() //Nao eh necessario validar, pois a funcao de calculo realiza a validacao do model (se houver alteracoes)
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CalResc     ³ Autor ³ Leandro Drumond       ³ Data ³ 07/01/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava as informacoes do model (para que seja possivel acessa- ³±±
±±³          ³las nas formulas), e executa o calculo de rescisao de acordo  ³±±
±±³          ³com os campos de roteiro, processo, periodo e data de pagto.  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³CalResc()                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function CalResc()

Local aArea         := GetArea()
Local aPerAux		:= {}
Local aTitleLog		:= {}
Local aLog			:= {}
Local aVarAux		:= {}
Local aPdAux 		:= {}
Local aBenefAnt 	:= {{},{},{}}
Local aCposSRV		:= {'RV_INSS','RV_FGTS','RV_IR','RV_INCORP','RV_REF13','RV_REFFER'}
Local lItemClVl   	:= SuperGetMv( "MV_ITMCLVL", .F., "2" ) $ "1*3" // Define se trabalha com item e classe contabil
Local lAtuGrid		:= .F.
Local nPosLog		:= 0
Local nPos			:= 0
Local nX			:= 0
Local nElem			:= 0
Local nElem1		:= 0
Local nElem2 		:= 0
Local nP3			:= 0
Local nCount		:= 0
Local nRet			:= 0
Local nSdoEmp		:= 0
Local nTotEmp 		:= 0
Local nTotLiq 		:= 0
Local nTetoDesc		:= 0
Local nDescAux 		:= 0
Local nPosaPd 		:= 0
Local nPosaPdV 		:= 0
Local nPosLiq		:= 0
Local nPosInsuf		:= 0
Local nPosLiqAnt	:= 0
Local nPosEmp		:= 0
Local nValAux		:= 0
Local nLiqAux 		:= 0
Local nHorAux		:= 0
Local nAnoCasaAux	:= 0
Local nValBenAnt 	:= 0
Local nValBenAtu 	:= 0
Local nCustEmp 		:= 0
Local oModel      	:= FWModelActive()
Local oGrid			:= oModel:GetModel("GPEM040_MGET")
Local lBaseRRA      := .F.
Local lLocked		:= .T.
Local lConfCompl	:= SRR->(ColumnPos("RR_VALORI")) > 0
Local lSeqMv        := SRR->(ColumnPos("RR_SEQMV")) > 0
Local lVNaoApl      := cPaisLoc == "BOL" .And. SRR->( ColumnPos("RR_VNAOAPL") ) > 0
Local dBkp			:= M->RG_DATADEM
Local lLancFut 		:= .F.
Local lRet          := .T.
Local lRvCpoPlr		:= SRV->(Columnpos("RV_REFPLR") > 0)
Local cVerbasPLR	:= ""
Local cChave 		:= ""
Local cDescBen 		:= ""

Private lRescRet	:=  (cOpcCompl == "3")
Private aBenefRes	:= Array(3)

Static lPergBenef

P_lPPEAtiv			:= If( Type("P_lPPEAtiv") == "U", .F. , P_lPPEAtiv)
dDtEst936			:= If( Type("dDtEst936") == "U", cToD("") , dDtEst936)
lPergBenef			:= .T.

DEFAULT lGestPubl := IIf(ExistFunc("fUsaGFP"),fUsaGFP(),.F.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP

SRV->(DbSetOrder(1))

//?- Verifica se o calculo esta Liberado
If !fVldAccess( cFilAnt, M->RG_DATADEM, M->RG_SEMANA, .T., fGetCalcRot("4") )
   Return( .F. )
EndIf

If lAtuSimul //Se for efetivacao da simulacao, nao permite recalculo
	Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0126), 1, 0 ) //"Atenção"##"Rescisão simulada não pode ser recalculada. Exclua e efetue um novo cálculo."
	Return(.F.)
EndIf

If Len(aSpbRec) > 0 .and. !( lLocked := ChkFile( "SPB",.F.))
	Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0172), 1, 0 ) //O Fechamento do SIGAPON está sendo executado. Tente mais tarde.
	Return( .F. )
EndIf

/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Funcao verifica se existe alguma restrição de acesso para o³
//³usuário que impeça a execução da rotina.                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If !(fValidFun({"SQB","SRJ","RCO",;
				"CTT","RGC","RCE","SR6","SR3",;
				"SR7","SRC","RGB","SRV","SRK",;
				"RCP","RG7"}))
	RestArea(aArea)
	Return(.F.)
EndIf

If lRescRRA
	If Empty(oModel:GetModel('GPEM040_MSRG'):GetValue("RG_IDCMPL"))
		If Isblind() .Or. MsgYesNo( OemToAnsi( STR0113 ) , OemToAnsi( STR0020) ) //Atenção. Identificador de complemento do RRA não foi preenchido. Não será calculado RRA. Continua?
			lRescRRA := .F.
		Else
			Return(.F.)
		EndIf
	Else
		DbSelectArea('RF1')
		If !(DbSeek(xFilial('RF1')+oModel:GetModel('GPEM040_MSRG'):GetValue("RG_IDCMPL")))
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0165), 1, 0 ) //"Atencao"##'Complemento Trabalhista informado não encontrado'  {OK}
			Return(.F.)
		EndIf
	EndIf
EndIf

If lGestPubl .AND. cModulo $ 'GFP*VDF' .AND. oModel:GetOperation() == MODEL_OPERATION_INSERT
	dDataDem1 		:= fDtRescAnt(SRA->RA_FILIAL,SRA->RA_MAT)

	If Empty(dDataDem1)
		lRet := MsgNoYes( OemToAnsi(STR0227), OemToAnsi(STR0020) ) //Não existe publicação para esta Rescisão. Deseja continuar?
		If !(cCompl == "S")
			dDataDem1	:= Iif(lRet, dDataBase, dDataDem1)
		Else
			dDataDem1	:= Iif(lRet, dDataDem, dDataDem1)
		EndIf
		If !lRet
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0218), 1, 0 ) //"Atenção, Cálculo de Rescisão cancelado pelo usuário."
		EndIf
	ElseIf Empty(aPublicacao[2])
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0223), 1, 0 ) //	"Existe Item com pendência de Publicação. Não será possível prosseguir."  ###	Atenção
		lRet		:= .F.
	ElseIf Empty(aPublicacal[3])
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0224), 1, 0 )//	"Existe Documento gerado sem data de publicação. Não será possível prosseguir." ###	Atenção
		lRet		:= .F.
	EndIf

	If lRet .AND. cAfasfgts $ 'U1*U3' .AND. Empty(oModelSRG:GetValue('RG_NOVSUBS'))
		lRet := .F.
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0225), 1, 0 )//Para Aposentadoria o Valor do Novo Subsidio deve ser Informado.
	EndIf

	If !lRet
		Return .F.
	EndIf
EndIf

Begin Sequence

    aPD  := {}
    aPDV := {}
    aPd_SRK := {}

	If !fChkDtDem(oModel:GetValue("GPEM040_MSRG","RG_DATADEM"), .T., dDataDe, dDataAte, lModDataDem, @aLogErros)
		Break
	EndIf

	cRot			:= M->RG_ROTEIR
	cPeriodo		:= M->RG_PERIODO
	cNumPag			:= M->RG_SEMANA
	lMesAtu			:= ( M->RG_MEDATU == "S" )
	cTipoRot		:= fGetTipoRot(cRot)
	oModel:LoadValue("GPEM040_MSRG","RG_PERIODO",cPeriodo)

		/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Aviso de Demissao durante a Estabilidade do Funcionario    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !(cPaisLoc $ "DOM*EQU")
		If (! Empty(SRA->RA_DTVTEST)) .And. SRA->RA_DTVTEST >= dDataDem1
			If !IsBlind() .And. !( MsgYesNo( OemToAnsi( STR0041 ) + Dtoc(SRA->RA_DTVTEST) + ". " + OemTOAnsi(STR0042), OemToAnsi( STR0020 ) ) ) //"Atencao"###"Funcionario esta com data de Estabilidade ate: "###"Continua?"
				Break
			EndIf
		EndIf
		If !IsBlind() .And. cPaisLoc == "BRA" .And. P_lPPEAtiv .And. Date() >= cToD("09/10/2020") .And. !Empty(dDtEst936) .And. dDtEst936 >= dDataDem1
			If !( MsgYesNo( OemToAnsi( STR0290 ) + dToC(dDtEst936) + ". " + OemTOAnsi(STR0042), OemToAnsi( STR0020 ) ) ) //"Atencao"###"Funcionário está com data de estabilidade da MP 936/2020 até: "###"Continua?"
				Break
			Else
				If SRG->(ColumnPos( "RG_DTESTAB")) == 0 .Or. Len(aCodFol) < 1853 .Or. Empty(aCodFol[1853,1])
					fAlert936(1)
					Break
				Else
					fAlert936(2)
				EndIf
			EndIf
		EndIf
	EndIf

	//Integração com o GS
	If FindFunction("TecConfAlo") .AND. SuperGetMV("MV_TECXRH", NIL, .F. ) .AND. !IsBlind()
		TecConfAlo( /*oModel*/, dDataDem1 )
	EndIf

	If Empty(M->RG_DATAHOM)
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0151), 1, 0 ) //"Atenção"##"Data de Homologação não foi preenchida"
		Break
	EndIf

	If Empty(M->RG_DTAVISO)
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0167), 1, 0 ) //"Atenção"##"Data do Aviso não foi preenchida"
		Break
	EndIf

	If Empty(M->RG_TIPORES)
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0152), 1, 0 ) //"Atenção"##"Tipo de Rescisão não foi preenchido"
		Break
	EndIf

	If Empty(M->RG_DTGERAR)
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0171), 1, 0 ) //"Atenção"##"Data de Geração não foi preenchida"
		Break
	EndIf

	If cTipoRot <> "4"
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0053), 1, 0 ) //"Atenção"##"Roteiro de Cálculo diferente de Rescisão!"
		Break
	EndIf

	DbSelectArea(cTBLXMED)
	Zap

	cSvSetRot 		:= SetRotExec( cRot )
	cSvSetPer 		:= SetPeriodCalc( cPeriodo )
	cSvSetNumPago 	:= SetNumPgCalc( cNumPag )

	If cModFol == "1" .and. !(cPaisLoc $ "BRA*CHI*PAR") .and. oSrr == Nil
		oSrr := Nil
		GetSRR( @oSrr, "1 = 0" )	// Expressao de filtro para criar um objeto em branco
	EndIf

	aPerAux	:= aClone(aPerFerias)

	nAnoCasaAux := nAnosCasa
	NINCSEMID := 0
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Executa as formulas roteiro                                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

	//Memória de Cálculo
	If __lMemCalc
		fSetMemCalc()
	EndIf

	nRet := ExecRot( SRA->RA_FILIAL , cRot )

	//Memória de Cálculo
	If __lMemCalc
		fAddMemLog("",2) //grava parametros na memoria de calculo
		fGrvLogFun(cRot, cPeriodo, cNumPag,"GPEM040", aMenLog)
		aMenLog := {}
	EndIf

	nAnosCasa := nAnoCasaAux //Restaura valor do mnemonico

	aPerFerias	:= aClone(aPerAux)

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Fecha o Repositorio Auxiliar                                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	RpoFormInit( NIL , .T. )

	If nRet < 0 .or. nRet == 2 //Retorna 2 quando calculo eh abortado
		cFilCalc 	:= ""
		lErrExecRot	:= .T.
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Carregando Informacoes para o Log                                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aLogInit := LogExecRot()
		For nX := 1 To Len( aLogInit )
			If !Empty(aLogInit[ nX, 2 ])
				If nX == 1
					aAdd( aTitleLog, STR0054 ) //"Erro de Carga de Mnemonicos"
				ElseIf nX == 2
					aAdd( aTitleLog, STR0055 ) //"Erro de Carga de Formulas"
				ElseIf nX == 3
				aAdd( aTitleLog, STR0056 ) //"Ocorreu erro na compilacao ou Execucao do Roteiro"
				ElseIf nX == 4
					aAdd( aTitleLog, STR0057 ) //"Erros ocasionados durante o Calculo da Rescisao"
				EndIf
				aAdd( aLog, aLogInit[nX, 2] )
			EndIf
		Next nX

		If Len( aLogErros ) > 0
			If Empty( aLog )
				aAdd( aTitleLog, STR0058 )	//"Log de Ocorrencias do Calculo de Rescisao"
				aAdd( aLog, {} )
			EndIf

			nPosLog := Len( aLog )
			For nX := 1 To Len( aLogErros )
				aAdd( aLog[ nPosLog ], aLogErros[ nX ] )
			Next nX
		EndIf

		If !Empty( aLog )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Mostrar o Log                                                          ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			MsAguarde( { || fMakeLog( aLog , aTitleLog , "GPEM040" , NIL , FunName() , STR0058 ) } ,  STR0058 ) //"Log de Ocorrencias do Calculo de Rescisao"
		EndIf
		RstExecCalc()
		Return( .F. )
	EndIf

	SetRotExec( cSvSetRot )
	SetPeriodCalc( cSvSetPer )
	SetNumPgCalc( cSvSetNumPago )

	If cPaisLoc == "BRA" .and. !Empty(aIncRes[21])

		aPdAux 		:= aClone(aPd)

		cDescBen	:= P_DESCBEN
		
		SR0->(DbSetOrder(RetOrder( "SR0", "R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO+R0_PEDIDO" )))

		cChave := SRA->RA_FILIAL + SRA->RA_MAT

		If "T" $ aIncRes[21] .and. !Empty(aCodFol[1896,1])//Vale Transporte
			If SR0->(DbSeek(cChave + "0"))

				nCustEmp := 0

				While SR0->(!Eof() .and. R0_FILIAL + R0_MAT + R0_TPVALE == cChave + "0")
					aAdd(aBenefAnt[1], {SR0->R0_CODIGO, SR0->R0_VLRFUNC, SR0->R0_VLREMP})
					nCustEmp += SR0->R0_VLREMP
					SR0->(DbSkip())
				EndDo

				If !("VT" $ cDescBen) .and. nCustEmp > 0 //Calcula para proporcionalizar apenas se houve pagamento de beneficio por parte da empresa

					cRot := fGetCalcRot('8')
				
					cSvSetRot 		:= SetRotExec( cRot )
					cSvSetPer 		:= SetPeriodCalc( cPeriodo )
					cSvSetNumPago 	:= SetNumPgCalc( cNumPag )

					aPergunte		:= {}

					fGetPergunte(@aPergunte, "GP021VTR")

					nRet := ExecRot( SRA->RA_FILIAL , cRot )

					If nRet < 0 .or. nRet == 2 //Retorna 2 quando calculo eh abortado
						fLogBenef()
						Return( .F. )
					EndIf

					//Fecha o Repositorio Auxiliar
					RpoFormInit( NIL , .T. )

					SetRotExec( cSvSetRot )
					SetPeriodCalc( cSvSetPer )
					SetNumPgCalc( cSvSetNumPago )
				EndIf
			EndIf
		EndIf

		If "R" $ aIncRes[21]  .and. !Empty(aCodFol[1897,1])//Vale Refeição
			If SR0->(DbSeek(cChave + "1"))

				nCustEmp := 0

				While SR0->(!Eof() .and. R0_FILIAL + R0_MAT + R0_TPVALE == cChave + "1")
					aAdd(aBenefAnt[2], {SR0->R0_CODIGO, SR0->R0_VLRFUNC, SR0->R0_VLREMP})
					nCustEmp += SR0->R0_VLREMP
					SR0->(DbSkip())
				EndDo

				If !("VR" $ cDescBen) .and. nCustEmp > 0 //Calcula para proporcionalizar apenas se houve pagamento de beneficio por parte da empresa
			
					cRot := fGetCalcRot('D') //Vale Refeição
				
					cSvSetRot 		:= SetRotExec( cRot )
					cSvSetPer 		:= SetPeriodCalc( cPeriodo )
					cSvSetNumPago 	:= SetNumPgCalc( cNumPag )

					aPergunte		:= {}

					fGetPergunte(@aPergunte, "GP021VRF")

					nRet := ExecRot( SRA->RA_FILIAL , cRot )

					If nRet < 0 .or. nRet == 2 //Retorna 2 quando calculo eh abortado
						fLogBenef()
						Return( .F. )
					EndIf

					//Fecha o Repositorio Auxiliar
					RpoFormInit( NIL , .T. )

					SetRotExec( cSvSetRot )
					SetPeriodCalc( cSvSetPer )
					SetNumPgCalc( cSvSetNumPago )
				EndIf
			EndIf
		EndIf

		If "A" $ aIncRes[21]  .and. !Empty(aCodFol[1898,1])//Vale Alimentação
			If SR0->(DbSeek(cChave + "2"))

				nCustEmp := 0

				While SR0->(!Eof() .and. R0_FILIAL + R0_MAT + R0_TPVALE == cChave + "2")
					aAdd(aBenefAnt[3], {SR0->R0_CODIGO, SR0->R0_VLRFUNC, SR0->R0_VLREMP})
					nCustEmp += SR0->R0_VLREMP
					SR0->(DbSkip())
				EndDo

				If !("VA" $ cDescBen) .and. nCustEmp > 0 //Calcula para proporcionalizar apenas se houve pagamento de beneficio por parte da empresa

					cRot := fGetCalcRot('E') //Vale Alimentação
				
					cSvSetRot 		:= SetRotExec( cRot )
					cSvSetPer 		:= SetPeriodCalc( cPeriodo )
					cSvSetNumPago 	:= SetNumPgCalc( cNumPag )

					aPergunte		:= {}

					fGetPergunte(@aPergunte, "GP021VAL")

					nRet := ExecRot( SRA->RA_FILIAL , cRot )

					If nRet < 0 .or. nRet == 2 //Retorna 2 quando calculo eh abortado
						fLogBenef()
						Return( .F. )
					EndIf

					//Fecha o Repositorio Auxiliar
					RpoFormInit( NIL , .T. )

					SetRotExec( cSvSetRot )
					SetPeriodCalc( cSvSetPer )
					SetNumPgCalc( cSvSetNumPago )
				EndIf
			EndIf
		EndIf

		cRot		:= M->RG_ROTEIR

		aPd := aClone(aPdAux)

		nPosLiq := aScan( aPD,{|x| x[1] == aCodfol[126,1] .And. x[9] != "D" } )

		If ( aBenefRes[1] <> Nil .and. Len(aBenefRes[1]) > 0 ) .or. ("VT" $ cDescBen)
			nValBenAnt 	:= 0
			nValBenAtu 	:= 0
			aEval(aBenefAnt[1], {|x| nValBenAnt += x[3]})
			If aBenefRes[1] <> Nil
				aEval(aBenefRes[1], {|x| nValBenAtu += x[6]})
			EndIf
			If nValBenAnt - nValBenAtu > 0
				fGeraVerba(aCodFol[1896,1], nValBenAnt - nValBenAtu,,,,,"R")
				aPd[nPosLiq,5] := Max(0, aPd[nPosLiq,5] - ( nValBenAnt - nValBenAtu)) //Atualiza valor do liquido
			EndIf
		EndIf
		If ( aBenefRes[2] <> Nil .and. Len(aBenefRes[2]) > 0 )  .or. ("VR" $ cDescBen)
			nValBenAnt 	:= 0
			nValBenAtu 	:= 0
			aEval(aBenefAnt[2], {|x| nValBenAnt += x[3]})
			If aBenefRes[2] <> Nil
				aEval(aBenefRes[2], {|x| nValBenAtu += x[6]})
			EndIf 
			If nValBenAnt - nValBenAtu > 0
				fGeraVerba(aCodFol[1897,1], nValBenAnt - nValBenAtu,,,,,"R")
				aPd[nPosLiq,5] := Max(0, aPd[nPosLiq,5] - ( nValBenAnt - nValBenAtu))
			EndIf
		EndIf
		If ( aBenefRes[3] <> Nil .and. Len(aBenefRes[3]) > 0 )  .or. ("VA" $ cDescBen)
			nValBenAnt 	:= 0
			nValBenAtu 	:= 0
			aEval(aBenefAnt[3], {|x| nValBenAnt += x[3]})
			If aBenefRes[3] <> Nil
				aEval(aBenefRes[3], {|x| nValBenAtu += x[6]})
			EndIf
			If nValBenAnt - nValBenAtu > 0
				fGeraVerba(aCodFol[1898,1], nValBenAnt - nValBenAtu,,,,,"R")
				aPd[nPosLiq,5] := Max(0, aPd[nPosLiq,5] - ( nValBenAnt - nValBenAtu))
			EndIf
		EndIf
	EndIf

	aEval( aPd, { |x, y| If( x[16] == .T. , aAdd( aPd_SRK, {aPd[y,1], APD[y,7]} ), Nil )  }  )

	//--Transfere verbas para identificador de RRA no caso de rescisão complementar ser feita em ano diferente da rescisão original
	If lRescRRA

		//Verifica se as verbas geradas pelo roteiro existe incidência de RRA
		//para realizar a transferência de base do IR
		For nX := 1 To Len(aPd)
			If AllTrim(PosSrv(aPd[nX,1],SRA->RA_FILIAL,"RV_RRA")) == "1"
				lBaseRRA := .T.
				Exit
			EndIf
		Next nX

		If lBaseRRA

			//Trasnfere Base de IR para Base IR RRA
			If ( nPos := aScan(aPd,{ |x| x[1] == aCodFol[974,1] .and. x[9] # "D" }) ) > 0
				If (nP := aScan(aPd,{ |x| x[1] == aCodFol[015,1] .and. x[9] # "D" }) ) > 0
					aPd[nPos,5] := aPd[nP,05]
					aPd[nP,9] := "D"
					//Transfere IR para codigo de IR RRA
					If (nP := aScan(aPd,{ |x| x[1] == aCodFol[066,1] .and. x[9] # "D" }) ) > 0
						If ( nPos := aScan(aPd,{ |x| x[1] == aCodFol[978,1] .and. x[9] # "D" }) ) > 0
							aPd[nPos,5] := aPd[nP,5]
							aPd[nP,9] := "D"
						Else
							aPd[nP,1] := aCodFol[978,1]
						EndIf
					EndIf
					//Apaga base IRRF de Ferias, pois valor foi incorporado a Base IR RRA
					If ( nPos := aScan(aPd,{ |x| x[1] == aCodFol[016,1] .and. x[9] # "D" }) ) > 0
						aPd[nPos,9] := "D"
					EndIf
					//Apaga IRRF de Ferias, pois valor foi incorporado ao IR RRA
					If ( nPos := aScan(aPd,{ |x| x[1] == aCodFol[067,1] .and. x[9] # "D" }) ) > 0
						aPd[nPos,9] := "D"
				EndIf
				EndIf
			ElseIf ( nPos := aScan(aPd,{ |x| ( x[1] == aCodFol[015,1] .or. x[1] == aCodFol[016,1] ) .and. x[9] # "D" }) ) > 0
				aPd[nPos,1] := aCodFol[974,1]
				If ( nPos := aScan(aPd,{ |x| ( x[1] == aCodFol[066,1] .or. x[1] == aCodFol[067,1] ) .and. x[9] # "D" }) ) > 0
					aPd[nPos,1] := aCodFol[978,1]
				EndIf
			EndIf
			//Trasnfere base de IR 13o para Base IR 13o RRA
			If ( nPos := aScan(aPd,{ |x| x[1] == aCodFol[979,1] .and. x[9] # "D" }) ) > 0
				If (nP := aScan(aPd,{ |x| x[1] == aCodFol[027,1] .and. x[9] # "D" }) ) > 0
					aPd[nPos,5] := aPd[nP,05]
					aPd[nP,9] := "D"
					//Transfere IR 13o para codigo de IR 13o RRA
					If (nP := aScan(aPd,{ |x| x[1] == aCodFol[071,1] .and. x[9] # "D" }) ) > 0
						If ( nPos := aScan(aPd,{ |x| x[1] == aCodFol[983,1] .and. x[9] # "D" }) ) > 0
							aPd[nPos,5] := aPd[nP,5]
							aPd[nP,9] := "D"
						Else
							aPd[nP,1] := aCodFol[983,1]
						EndIf
				EndIf
				EndIf
			ElseIf ( nPos := aScan(aPd,{ |x| x[1] == aCodFol[027,1] .and. x[9] # "D" }) ) > 0
				aPd[nPos,1] := aCodFol[979,1]
				If ( nPos := aScan(aPd,{ |x| x[1] == aCodFol[071,1] .and. x[9] # "D" }) ) > 0
					aPd[nPos,1] := aCodFol[983,1]
				EndIf
			EndIf
		EndIf
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Tratamento de Emprestimos                     	         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If (cCompl != "S" .Or. !lProxMes) .And. ( nPosLiq := aScan( aPD,{|x| x[1] == aCodfol[126,1] .And. x[9] != "D" } ) ) > 0//Saldo liquido
		nTotEmp := 0
		nTotLiq := aPd[nPosLiq,05]
		//Retira o valor do salário familia pois o pagamento dessa verba é obrigatória
		aEval( aPd ,{ |X| If(x[1] == aCodFol[034,1] .And. x[9] != "D", nTotLiq -= x[5], Nil) } )
		aEval( aPd ,{ |X| If(X[16] == .T. .And. x[9] != "D",nTotEmp+=x[5],Nil) } )
		If cCompl == "S" .And. ( nPosLiqAnt := aScan( aPD, { |x| x[1] == aCodfol[303,1] .And. x[9] != "D" } ) ) > 0//Liquido da Rescisao Anterior
			nTotLiq += aPd[nPosLiqAnt, 05]
		EndIf

		nTetoDesc 	:= Round(P_PERCONS/100 * nTotLiq,2)
		nSdoEmp 	:= round(P_PERCONS/100 * nTotLiq,2)

		If nTotEmp > 0 .and. nTotEmp > nTetoDesc // o Total de Emprestimo é maior que 30% do liquido
			Help( ,, OemToAnsi(STR0020),, STR0221 + "(" + cValToChar(P_PERCONS) + STR0222 , 1, 0 )
			//"Atenção o funcionario possui emprestimo(s) que serao liquidados parcialmente ou NÃO serão liquidados
			// pois o saldo devedor dos mesmos ultrapassa o valor o testo estabelecido pelo mnemônico P_PERCONS
			//(XX% sobre o liquido da Rescisão). Verifique os Lancamentos Futuros"
		EndIf
		
		If nTotEmp > 0 // Calcula emprestimos
			nElem2 := Len(aPd)
			For nP3 := 1 To nElem2
			  If (nPosEmp := aScan( aPD, {|x| x[16] == .T. .And. x[9] != "D" }, nP3 )) >0
		           If nSdoEmp > 0 //Tem saldo a descontar
						If  aPd[nPosEmp,05] >=  nSdoEmp // valor do emprestimo maior ou igual ao saldo
							aPd[nPosEmp,05]:= nSdoEmp
							nSdoEmp := 0
						Else      //Valdor menor
							nSdoEmp -= aPd[nPosEmp,05]
						EndIf
				   Else // verba nao pode ser processada
						aPd[nPosEmp,05] := 0
				   EndIf

				   aPd[nPosLiq,05] -= aPd[nPosEmp,05]//Subtrai o valor do emprestimo no liquido
				   aPd[nPosEmp,16] := .F.
		   	  EndIf
	   		Next nP3
		EndIf
	ElseIf aScan( aPD,{|x| x[1] == aCodfol[0048,1] } ) > 0
		nElem2 := Len(aPd)
		aEval( aPd ,{ |X| If(X[16] == .T.,nTotEmp+=x[5],Nil) } )
		If nTotEmp > 0
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0105) , 1, 0 )
			//"Atenção o funcionario possui emprestimo(s) que serao liquidados parcialmente ou NÃO serão liquidados
			// pois o saldo devedor dos mesmos ultrapassa o valor de 30% sobre o liquido da Rescisão"
			// Verifique os Lancamentos Futuros
			aEval( aPd ,{ |x| If( x[16] == .T., x[5] := 0,Nil) } )
		EndIf
	EndIf

	If cPaisLoc == "BRA" .and. !Empty(aCodFol[1899.1]) .and. !Empty(P_LIMRESPD) .and. P_LIMRESPD <> "N"
		
		nDescAux := 0

		If P_LIMRESPD == "S"
			aEval(aPd, {|x| If(x[1] <> aCodFol[126,1] .and. x[9] <> "D" .and. RetValSRV(x[1], SRA->RA_FILIAL, 'RV_TIPOCOD') == "2", nDescAux += x[5], Nil )} )
		Else
			aEval(aPd, {|x| If(x[1] $ P_LIMRESPD .and. x[9] <> "D", nDescAux += x[5], Nil )} )
		EndIf

		If nDescAux > SALMES
			nValAux := nDescAux - SALMES

			fMatriz(aCodFol[1899,1], nValAux ) //Gera valor de valor não descontado devido ultrapassar o teto

			Help( ,, OemToAnsi(STR0020),, STR0309 + CRLF + STR0310 + cValToChar(SALMES) , 1, 0 )
			//"O funcionário possui descontos que não serão efetuados integralmente, de acordo com a definição do mnemônico P_LIMRESPD."
			//"O teto para desconto do funcionário é de R$"

			aSort( aPD ,,, { |x,y| Val(x[21]) > Val(y[21]) } ) //Coloca na ordem de cálculo inversa

			nPosLiq 	:= aScan( aPD,{|x| x[1] == aCodfol[126,1] .And. x[9] != "D" } )
			nPosInsuf	:= aScan( aPD,{|x| x[1] == aCodfol[45,1] .And. x[9] != "D" } )
			
			For nX := 1 to Len(aPd)
				If aPd[nX,1] <> aCodFol[126,1] .and. aPd[nX,9] <> "D" .and. !aPd[nX,16] .and. ( RetValSRV(aPd[nX,1], SRA->RA_FILIAL, 'RV_TIPOCOD') == "2" )  .and.( P_LIMRESPD == "S" .or. aPd[nX,1] $ P_LIMRESPD )
					If aPd[nX,5] <= nValAux 
						nValAux -= aPd[nX,5]
						If nPosLiq + nPosInsuf > 0
							nLiqAux := If(nPosLiq > 0, aPd[nPosLiq,5] + aPd[nX,5], aPd[nPosInsuf,5] - aPd[nX,5])
							If(nPosLiq > 0, aPd[nPosLiq,5] := nLiqAux, aPd[nPosInsuf,5] := Max(nLiqAux,0)) //Soma o valor abatido do desconto no liquido
							If(nLiqAux < 0 .and. nPosLiq == 0, fMatriz(aCodFol[126,1], ( nLiqAux * (-1) ) ), Nil) //Gera liquido
							If(nLiqAux < 0 .and. nPosLiq == 0, nPosLiq 	:= aScan( aPD,{|x| x[1] == aCodfol[126,1] .And. x[9] != "D" } ), Nil )
						EndIf
						aPd[nX,5] := 0
					Else 
						aPd[nX,5] -= nValAux 
						If nPosLiq + nPosInsuf > 0
							nLiqAux := If(nPosLiq > 0, aPd[nPosLiq,5] + nValAux, aPd[nPosInsuf,5] - nValAux)
							If(nPosLiq > 0, aPd[nPosLiq,5] := nLiqAux, aPd[nPosInsuf,5] := Max(nLiqAux,0))//Soma o valor abatido do desconto no liquido
							If(nLiqAux < 0 .and. nPosLiq == 0, fMatriz(aCodFol[126,1], ( nLiqAux * (-1) ) ), Nil ) //Gera liquido
							If(nLiqAux < 0 .and. nPosLiq == 0, nPosLiq 	:= aScan( aPD,{|x| x[1] == aCodfol[126,1] .And. x[9] != "D" } ), Nil )
						EndIf
						nValAux := 0
					EndIf 
					If nValAux == 0
						Exit 
					EndIf
				EndIf
			Next nX

			nDescAux := SALMES
		EndIf
	EndIf

	If cModFol == "1"
		If cPaisLoc $ "BRA*CHI*PAR"
			nElem := Len(aPd)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ CONTA OS ELEMENTOS VALIDOS PARA MONTAR O NOVO aCols        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nElem1 := 0
			aEval(aPd,{ |X| nElem1 += If( Round(x[5],2) = 0.00 .Or. X[9]=="D" ,0 ,1) })

			If nElem1 > 0

				cVerbasPLR := aCodFol[151,1]+'*'+aCodFol[152,1]+'*'+aCodFol[300,1]+'*'+aCodFol[835,1]+'*'+aCodFol[836,1]

				aSort( aPD ,,, { |x,y| x[1] + x[11] < y[1] + y[11] } )

				If lRescPLR
					for nCount = 1 to nElem
						If !(aPd[nCount,1] $ cVerbasPLR) .And. (!lRvCpoPlr .Or. (lRvCpoPlr .And. !(RetValSRV(aPd[nCount,1], SRA->RA_FILIAL, 'RV_REFPLR') == "S")))
							aDel(aPd,nCount)
							aSize(aPd,Len(aPd)-1)
							nCount--
						EndIf
						If nCount == Len(aPd)
							Exit
						EndIf
					Next nCount
					fLiquido(aCodFol,aCodFol[126,1],0,"",.T.,aCodFol[45,1],.T.,.T.,.T.)
				EndiF

				nElem := Len(aPd)
				nElem1 := 0

				aPdRAW := aClone(aPd) //Copia valores gerados na rescisão

				For nCount = 1 To nElem

					lLancFut := aPd[nCount,7] == "G" .And. "SRK" $ aPd[nCount,15]

					If ( Round(aPd[nCount,5],2) = 0.00 .And. ( !(aPd[nCount,7] $ "I*E*G") .or. lRescPLR)) .Or. aPd[nCount,9] == "D"
						Loop
					EndIf

					If !(cPaisLoc == "BRA") .And. ( nPos := aScan( aVarAux, {|x| x[1] == aPd[nCount,1] .And. x[2] == aPd[nCount,2] .And. x[3] == aPd[nCount,3] .And. x[4] == aPd[nCount,11] .and. aPd[nCount,7] == "I"} )) > 0
						nElem1	:= nPos
						lAtuGrid:= .T.
					ElseIf cPaisLoc == "BRA" .And. ( nPos := aScan( aVarAux, {|x| x[1] == aPd[nCount,1] .And. x[2] == aPd[nCount,2] .And. x[3] == aPd[nCount,3]  .And. x[5] == aPd[nCount,7] .and. (aPd[nCount,7] $ "I*E*G") } )) > 0
						nElem1	:= nPos
						lAtuGrid:= .T.
					Else
						nElem1++
						aAdd(aVarAux,{aPd[nCount,1],aPd[nCount,2],aPd[nCount,3],aPd[nCount,11],aPd[nCount,7]})
						lAtuGrid:= .F.
					Endif

					If nElem1 > oGrid:Length()
						oGrid:AddLine(.T.)
					EndIf

					oGrid:GoLine(nElem1)

					If lAtuGrid
						nValAux := oGrid:GetValue("RR_VALOR") + aPd[nCount,05]
						nHorAux := oGrid:GetValue("RR_HORAS") + aPd[nCount,04]
					Else
						nValAux := aPd[nCount,05]
						nHorAux := aPd[nCount,04]
					EndIf

					oGrid:LoadValue("RR_FILIAL"	,SRA->RA_FILIAL)
					oGrid:LoadValue("RR_MAT"	,SRA->RA_MAT)
					oGrid:LoadValue("RR_PD"		,aPd[nCount,01])
					oGrid:LoadValue("RR_DESCPD"	,DescPd( aPd[nCount,01] ))
					oGrid:LoadValue("RR_VALOR"	,Round(nValAux,2))
					oGrid:LoadValue("RR_HORAS"	,nHorAux)
					oGrid:LoadValue("RR_TIPO1"	,aPd[nCount,06])
					oGrid:LoadValue("RR_TIPO2"	,If(aPd[nCount,07]=="C","R",aPd[nCount,07]))
					oGrid:LoadValue("RR_DATA"	,oModel:GetModel('GPEM040_MSRG'):GetValue("RG_DTGERAR"))
					oGrid:LoadValue("RR_DATAPAG",Iif(Empty(aPd[nCount,10]) .Or. aPd[nCount,07] $ "C/E/G/I" .Or. ( ( nPosaPdV := aScan( aPdv, { |x| x[3] == aPd[nCount, 1] } ) ) > 0 .And. ( nPosaPd := aScan( aPd, { |x| x[1] == aPdv[nPosaPdv, 1] .And. x[9] != "D" } ) ) > 0 .And. aPd[nPosaPd, 7] $ "C/E/G/I" ), oModel:GetModel('GPEM040_MSRG'):GetValue("RG_DATAHOM"), aPd[nCount,10]))
					oGrid:LoadValue("RR_CC"		,aPD[nCount,02])
					oGrid:LoadValue("RR_PROCES"	,SRA->RA_PROCES)
					oGrid:LoadValue("RR_PERIODO",oModel:GetModel('GPEM040_MSRG'):GetValue("RG_PERIODO"))
					oGrid:LoadValue("RR_ROTEIR"	,cRot)
					oGrid:LoadValue("RR_SEMANA"	,cNumPag)
					oGrid:LoadValue("RR_TIPO3"	,"R")
					oGrid:LoadValue("RR_SEQ"	,aPd[nCount,11])
					oGrid:LoadValue("RR_VALORBA",aPd[nCount,20])
					oGrid:LoadValue("RR_CODB1T"	,aPd[nCount,21])
					If !lLancFut
						oGrid:LoadValue("RR_NUMID"	,aPd[nCount,15])
					EndIf
					If(SRV->(DbSeek(xFilial('SRV') + oGrid:GetValue('RR_PD'))))
						aEval(aCposSRV,{|x|oGrid:LoadValue("RR" + SubStr( x, At('_',x)),SRV->(&(x)))})
					EndIf
					If lItemClVl
						oGrid:LoadValue("RR_ITEM"	,If(!Empty(aPd[nCount,13]), aPd[nCount,13], SRA->RA_ITEM))
						oGrid:LoadValue("RR_CLVL"	,If(!Empty(aPd[nCount,14]), aPd[nCount,14], SRA->RA_CLVL))
					EndIf
					oGrid:LoadValue("RR_DTREF",If( aPd[nCount,07] $ "I*E*G", CtoD("//"), aPd[nCount,18])) //Se for a verba de base salarial, não grava a soma das anteriores
					If cCompl == "S" .and. lConfCompl .and. lProxMes .and. aPd[nCount,1] <> aCodFol[318,1] //Não grava quando a complementar é no mesmo mês
						nValAux := 0
						aEval(aPdResc,{ |X| nValAux += If( x[1] == aPd[nCount,1] .and. x[9]<>'D' .and. AllTrim(x[15]) == AllTrim(aPd[nCount,15]) ,x[5] ,0) })
						If nValAux > 0
							oGrid:LoadValue("RR_VALORI"	,Round(nValAux,2))
						EndIf
					EndIf
					If lSeqMv
						oGrid:LoadValue("RR_SEQMV"	,cSeqMV)
					EndIf

				Next
			EndIf
		Else
			fo_GoTop( @oSrr )

			nElem1 := 0

			For nX := 1 To Len( oSrr:aCols )
				If !fo_Deleted( @oSrr, nX )

					nElem1++

					If nElem1 > oGrid:Length()
						oGrid:AddLine(.T.)
					EndIf

					oGrid:GoLine(nElem1)

					oGrid:LoadValue("RR_FILIAL"	,SRA->RA_FILIAL)
					oGrid:LoadValue("RR_MAT"	,SRA->RA_MAT)
					oGrid:LoadValue("RR_PD"		,fo_GetVal( @oSrr, "RR_PD", nX ))
					oGrid:LoadValue("RR_DESCPD"	,DescPd( fo_GetVal( @oSrr, "RR_PD", nX ) ))
					oGrid:LoadValue("RR_VALOR"	,fo_GetVal( @oSrr, "RR_VALOR", nX ))
					If lVNaoApl
						oGrid:LoadValue("RR_VNAOAPL"	,fo_GetVal( @oSrr, "RR_VNAOAPL", nX ))
					EndIf
					oGrid:LoadValue("RR_HORAS"	,If( fo_GetVal( @oSrr, "RR_TIPO1", nX )=="H", fConvHoras( fo_GetVal( @oSrr, "RR_HORAS", nX ),"1"), fo_GetVal( @oSrr, "RR_HORAS", nX )))
					oGrid:LoadValue("RR_TIPO1"	,fo_GetVal( @oSrr, "RR_TIPO1", nX ))
					oGrid:LoadValue("RR_TIPO2"	,fo_GetVal( @oSrr, "RR_TIPO2", nX ))
					oGrid:LoadValue("RR_DATA"	,oModel:GetModel('GPEM040_MSRG'):GetValue("RG_DTGERAR"))
					oGrid:LoadValue("RR_DATAPAG",oModel:GetModel('GPEM040_MSRG'):GetValue("RG_DATAHOM"))
					oGrid:LoadValue("RR_CC"		,fo_GetVal( @oSrr, "RR_CC", nX ))
					oGrid:LoadValue("RR_PROCES"	,SRA->RA_PROCES)
					oGrid:LoadValue("RR_PERIODO",oModel:GetModel('GPEM040_MSRG'):GetValue("RG_PERIODO"))
					oGrid:LoadValue("RR_ROTEIR"	,cRot)
					oGrid:LoadValue("RR_SEMANA"	,cNumPag)
					oGrid:LoadValue("RR_TIPO3"	,"R")
					oGrid:LoadValue("RR_SEQ"	,fo_GetVal( @oSrr, "RR_SEQ", nX ))
					oGrid:LoadValue("RR_VALORBA",fo_GetVal( @oSrr, "RR_VALORBA", nX ))
					oGrid:LoadValue("RR_CODB1T"	,fo_GetVal( @oSrr, "RR_CODB1T", nX ))
					oGrid:LoadValue("RR_NUMID"	,fo_GetVal( @oSrr, "RR_NUMID", nX ))
					If(SRV->(DbSeek(xFilial('SRV') + oGrid:GetValue('RR_PD'))))
						aEval(aCposSRV,{|x|oGrid:LoadValue("RR" + SubStr( x, At('_',x)),SRV->(&(x)))})
					EndIf
					If lItemClVl
						oGrid:LoadValue("RR_ITEM"	,SRA->RA_ITEM)
						oGrid:LoadValue("RR_CLVL"	,SRA->RA_CLVL)
					EndIf
				EndIf
			Next nX
		EndIf
	Else
		nElem := Len(aPd)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ CONTA OS ELEMENTOS VALIDOS PARA MONTAR O NOVO aCols        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nElem1 := 0
		aEval(aPd,{ |X| nElem1 += If( Round(x[5],2) = 0.00 .Or. X[9]=="D" ,0 ,1) })

		If nElem1 > 0

			aSort( aPD ,,, { |x,y| x[1] + x[11] < y[1] + y[11] } )

			nElem1 := 0

			For nCount = 1 To nElem
				If Round(aPd[nCount,5],2) = 0.00 .Or. aPd[nCount,9] == "D"
					Loop
				EndIf

				nElem1++

				If nElem1 > oGrid:Length()
					oGrid:AddLine(.T.)
				EndIf

				oGrid:GoLine(nElem1)

				oGrid:LoadValue("RC_FILIAL"	,SRA->RA_FILIAL)
				oGrid:LoadValue("RC_MAT"	,SRA->RA_MAT)
				oGrid:LoadValue("RC_PD"		,aPd[nCount,01])
				oGrid:LoadValue("RC_DESCPD"	,DescPd( aPd[nCount,01] ))
				oGrid:LoadValue("RC_VALOR"	,Round(aPd[nCount,05],2))
				oGrid:LoadValue("RC_HORAS"	,aPd[nCount,04])
				oGrid:LoadValue("RC_TIPO1"	,aPd[nCount,06])
				oGrid:LoadValue("RC_TIPO2"	,If(aPd[nCount,07]=="C","R",aPd[nCount,07]))

				If (cPaisLoc $ "ARG*CHI*COL*COS*DOM*MEX")
					oGrid:LoadValue("RC_DATA"	,oModel:GetModel('GPEM040_MSRG'):GetValue("RG_DTPAGO"))
					oGrid:LoadValue("RC_DTREF"  ,oModel:GetModel('GPEM040_MSRG'):GetValue("RG_DTPAGO"))
				EndIf

				oGrid:LoadValue("RC_CC"		,aPd[nCount,02])
				oGrid:LoadValue("RC_PROCES"	,SRA->RA_PROCES)
				oGrid:LoadValue("RC_PERIODO",oModel:GetModel('GPEM040_MSRG'):GetValue("RG_PERIODO"))
				oGrid:LoadValue("RC_ROTEIR"	,cRot)
				oGrid:LoadValue("RC_SEMANA"	,cNumPag)
				oGrid:LoadValue("RC_SEQ"	,aPd[nCount,11])
				oGrid:LoadValue("RC_VALORBA",aPd[nCount,20])
				oGrid:LoadValue("RC_CODB1T"	,aPd[nCount,21])
				oGrid:LoadValue("RC_NUMID"	,aPd[nCount,15])
				If(SRV->(DbSeek(xFilial('SRV') + oGrid:GetValue('RR_PD'))))
					aEval(aCposSRV,{|x|oGrid:LoadValue("RR" + SubStr( x, At('_',x)),SRV->(&(x)))})
				EndIf
				If lItemClVl
					oGrid:LoadValue("RC_ITEM"	,If(!Empty(aPd[nCount,13]), aPd[nCount,13], SRA->RA_ITEM))
					oGrid:LoadValue("RC_CLVL"	,If(!Empty(aPd[nCount,14]), aPd[nCount,14], SRA->RA_CLVL))
				EndIf
			Next nCount
		EndIf
	EndIf

	//Zera grid
	If nElem1 > 1 .and. oGrid:Length() > nElem1
		oModel:GetModel( "GPEM040_MGET" ):SetNoDeleteLine(.F.) //--Altera model para permitir excluir as linhas do calculo anterior
		For nX := nElem1+1 to oGrid:Length()
			oGrid:GoLine(nX)
			oGrid:DeleteLine()
		Next nX
		oModel:GetModel( "GPEM040_MGET" ):SetNoDeleteLine(.T.) //--Retorna bloqueio de exclusão de linha
	ElseIf nElem1 > 1
		For nX := 1 to nElem1
			oGrid:GoLine(nX)
			oGrid:UnDeleteLine()
		Next nX
	EndIf

	oGrid:GoLine(1) //Posiciona na primeira linha

	//grava historico de médias
	cIdHistMed := fHistMed(M->RG_DTGERAR)

End Sequence

RestArea(aArea)

nSalaMed	:= Salario
nSMesMed	:= SalMes
nSDiaMed	:= SalDia
nSHorMed	:= SalHora
dDataDem	:= dBkp

RstExecCalc() //Restaurar as Static apos o calculo
RstGpexIni()
RestXCIMP()

Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fAplicaRes  ³ Autor ³ Erika Kanamori        ³ Data ³ 18/08/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao de validacao de aplicacao e reversao de aplicacao de   ³±±
±±³          ³rescisao.                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³nTipoApl: 1 para aplicacao; 2 para reversao de aplicacao.     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fAplicaRes(nTipoApl)
Local oModel        := FWModelActive()
Local oModelSRG    	:= oModel:GetModel("GPEM040_MSRG")
Local nOperation	:= oModel:GetOperation()
Local cRoteiro		:= ""
Local cPeriodo		:= ""
Local cNumPago		:= ""
Local lRet			:= .T.
Local nAux2			:= 0
Local dDtFech  		:= CTOD("//")

/*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Soh faz aplicacao se tiver rescisao calculada e sem        ³
//³alteracoes a confirmar 								      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If nOperation == MODEL_OPERATION_INSERT
	lRet:= .F.
Else
   	If nOperation != MODEL_OPERATION_VIEW
		If Len(oModelSRG:aDataModel) > 0
			For nAux2 := 1 To Len(oModelSRG:aDataModel[1])
				If oModel:IsFieldUpdated("GPEM040_MSRG", oModelSRG:aDataModel[1][nAux2][1])
					lRet:= .F.
					Exit
				EndIf
			Next
		EndIf
	Else
		lRet:= .F.
	EndIf
EndIf

If lRet
	If nTipoApl == 1
		cRoteiro:= M->RG_ROTEIR
		cPeriodo:= M->RG_PERIODO
		cNumPago:= M->RG_SEMANA
	Else
		cRoteiro:= M->RG_APLROT
		cPeriodo:= M->RG_APLPER
		cNumPago:= M->RG_APLNPG
		If Empty(cRoteiro) .Or. Empty(cPeriodo)
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0059) , 1, 0 )//"Atenção"##"Nao é possivel reverter a aplicaçao de rescisao pois a aplicação ainda não foi executada."
			Return(.F.)
		EndIf

		//Verifica se o periodo do roteiro de aplicacao esta fechado
		dDtFech := Posicione("RCH", 4, xFilial("RCH",SRA->RA_FILIAL)+SRA->RA_PROCES+cRoteiro+cPeriodo+cNumPago, "RCH_DTFECH")
		If !Empty(dDtFech)
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0060) , 1, 0 )//"Atenção"##"Nao é possivel reverter a aplicaçao de rescisao pois o periodo ja esta fechado."
			Return(.F.)
		EndIf
	EndIf

	If !Gpm042Apl( nTipoApl, cRoteiro, cPeriodo , cNumPago )
		lRet:= .F.
	EndIf
Else
	If nOperation == MODEL_OPERATION_VIEW
   		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0061) , 1, 0 )//"Atenção"##"Execute esse processo em modo de alteracao."
	Else
		If nTipoApl == 1
	   		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0062) , 1, 0 )//"Atenção"##"É necessario confirmar as informacoes do formulario antes de realizar a operação de aplicação de rescisão."
	   	Else
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0063) , 1, 0 )//"Atenção"##"É necessario confirmar as informacoes do formulario antes de realizar a operação de reversão de aplicação de rescisão."
EndIf
	EndIf
EndIf

Return(lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpm042Apl   ³ Autor ³ Erika Kanamori        ³ Data ³ 19/08/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao de aplicacao e reversao de aplicacao de rescisao.      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³nTipo		: 1- Aplicacao, 2- Reversao de aplicacao            ³±±
±±³          ³cRoteir	: Roteiro de calculo                                ³±±
±±³          ³cPer 		: Periodo de calculo                                ³±±
±±³          ³cNPgto	: Numero de pagamento                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function Gpm042Apl( nTipo, cRoteir, cPer, cNPgto)

Local aPerAtual	  := {}

Local bSet15	  := { || lRet := .T., oDlg:End() }
Local bSet24	  := { || lRet := .F., oDlg:End() }
Local bDialogInit := {}

Local cTitle
Local cTipoRot 	  := fGetTipoRot( cRoteir )
Local cRotDesc
Local cSvRoteir   := cRoteir
Local cSvPer	  := cPer
Local cSvNPgto	  := cNPgto

Local lRet 		  := .t.

Local nNextRecno  := 0
Local nRecno 	  := 0
Local nOrder 	  := 0

Local oDlg

Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

Local aAdv1Size		:= {}
Local aInfo1AdvSize	:= {}
Local aObj1Size		:= {}
Local aObj1Coords 	:= {}

Local aAdv2Size		:= {}
Local aInfo2AdvSize	:= {}
Local aObj2Size		:= {}
Local aObj2Coords 	:= {}

Local oModel      	:= FWModelActive()
Local oModelSRG		:= oModel:GetModel('GPEM040_MSRG')

Local cFil			:= SRA->RA_FILIAL
Local cMat			:= SRA->RA_MAT

DEFAULT nTipo 	  := 0
DEFAULT cRoteir	  := ""
DEFAULT cPer 	  := ""
DEFAULT cNPgto	  := ""

If (nTipo == 1 .and. cTipoRot <> "4") .Or. (nTipo == 2 .and. cTipoRot <> "A")
	Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0081) , 1, 0 )//"Atenção"##Tipo de Roteiro Diferente do Solicitado!
	Return( .F. )
Else

	If nTipo == 1
		cRoteir := fGetCalcRot('A')	// Aplicacao de Finiquito
	ElseIf nTipo == 2
		cRoteir := fGetCalcRot('4')	// Reversao de Aplicacao de Rescisao
	EndIf

	lRet := fGetPerAtual( @aPerAtual, xFilial("RCH",SRA->RA_FILIAL), SRA->RA_PROCES, cRoteir ) // Busca o periodo aberto para trabalho
	If lRet
		cPer		:= aPerAtual[1,1]
		cNPgto 		:= aPerAtual[1,2]
	Else
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0082) , 1, 0 )//"Atenção"##"Periodo nao cadastrado para o Roteiro selecionado!"
		Return( lRet )
	EndIf
	If nTipo == 1 .and. cTipoRot == "4"
		cTitle := OemToAnsi(STR0083) // "Aplicacao de Rescisao"
	Else
		cTitle := OemToAnsi(STR0084) // "Reversao da Aplicacao de Rescisao"
	EndIf
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Define o Bloco para a Inicializacao do Dialog            	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
bDialogInit		:= { ||;
							CursorWait()													,;
							EnchoiceBar( oDlg , bSet15 , bSet24, NIL  )						,;
							CursorArrow()												 	 ;
				   }

aAdvSize        := MsAdvSize( ,.T.,370)

aInfoAdvSize    := { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
aAdd( aObjCoords , { 040 , 000 , .T. , .T. } )
aAdd( aObjCoords , { 060 , 000 , .T. , .T. } )
aObjSize    := MsObjSize( aInfoAdvSize , aObjCoords, .T., .T. )

aAdv1Size    := aClone(aObjSize[1])

aInfo1AdvSize    := { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 5 , 5 }
aAdd( aObj1Coords , { 000 , 020 , .T. , .F. } )
aAdd( aObj1Coords , { 000 , 020 , .T. , .F. } )
aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
aObj1Size := MsObjSize( aInfo1AdvSize , aObj1Coords )

aAdv2Size    := aClone(aObjSize[2])

aInfo2AdvSize    := { aAdv2Size[2] , aAdv2Size[1] , aAdv2Size[4] , aAdv2Size[3] , 5 , 5 }
aAdd( aObj2Coords , { 000 , 020 , .T. , .F. } )
aAdd( aObj2Coords , { 000 , 020 , .T. , .F. } )
aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )
aObj2Size := MsObjSize( aInfo2AdvSize , aObj2Coords )

DEFINE MSDIALOG oDlg TITLE cTitle FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() STYLE DS_MODALFRAME PIXEL
	oDlg:lEscClose := .F. // Nao permite sair ao se pressionar a tecla ESC.

	If ExistCpo("SRY", cRoteir)
		cRotDesc := Posicione("SRY",1,xFilial("SRY")+cRoteir, "RY_DESC")
	EndIf


	@ aObj1Size[1,1]	, aObj1Size[1,2] 		SAY   OemToAnsi(STR0085) SIZE 033,007 OF oDlg PIXEL	//"Periodo: "
	@ aObj1Size[1,1]	, aObj1Size[1,2]+55 	MSGET cPer SIZE 040,007	OF oDlg PIXEL WHEN .F.

	@ aObj1Size[2,1]	, aObj1Size[2,2] 		SAY   OemToAnsi(STR0086) SIZE 038,007 OF oDlg PIXEL	//"Nro Pagto: "
	@ aObj1Size[2,1]	, aObj1Size[2,2]+55 	MSGET cNPgto SIZE 040,007	OF oDlg PIXEL WHEN .F.

	@ aObj1Size[3,1]	, aObj1Size[3,2] 		SAY OemToAnsi(STR0087) SIZE 033,007 OF oDlg PIXEL	//"Roteiro: "
	@ aObj2Size[3,1]	, aObj2Size[3,2] 		SAY OemToAnsi(STR0088) SIZE 033,007 OF oDlg PIXEL	//"Descricao: "
	@ aObj1Size[3,1]	, aObj1Size[3,2]+55 	MSGET cRoteir  SIZE 040,007	OF oDlg PIXEL WHEN .F. PICTURE PesqPict("SRY","RY_CALCULO")
	@ aObj2Size[3,1]	, aObj2Size[3,2]+55 	MSGET cRotDesc SIZE 110,007	OF oDlg PIXEL WHEN .F.

ACTIVATE DIALOG oDlg ON INIT Eval( bDialogInit ) CENTERED

If lRet
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Alterando o periodo do Calculo de Finiquitos para Aplicacao de Finiquitos ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

	DbSelectArea( "SRC" )
    nOrder := RetOrdem("SRC","RC_FILIAL+RC_MAT+RC_PROCES+RC_ROTEIR+RC_PERIODO+RC_SEMANA")
    DbSetOrder( nOrder )
    DbSeek(SRA->(RA_FILIAL+RA_MAT+RA_PROCES)+cSvRoteir+cSvPer+cSvNPgto, .F.)

	Begin Transaction

	    /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Altera informacoes no formulario             				   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
   		If nTipo == 1
			oModelSRG:LoadValue('RG_APLROT' , cRoteir 	)
			oModelSRG:LoadValue('RG_APLPER' , cPer    	)
			oModelSRG:LoadValue('RG_APLNPG' , cNPgto  	)
			oModelSRG:LoadValue('RG_EFETIVA', "3"		)
		Else
			oModelSRG:LoadValue('RG_ROTEIR' , cRoteir 	)
			oModelSRG:LoadValue('RG_PERIODO', cPer    	)
			oModelSRG:LoadValue('RG_SEMANA' , cNPgto  	)
			oModelSRG:LoadValue('RG_EFETIVA', "2"		)
			oModelSRG:ClearField('RG_APLPER')
			oModelSRG:ClearField('RG_APLNPG')
			oModelSRG:ClearField('RG_APLROT' )
		EndIf

		If cAtualSit == "1"
			If nTipo == 1
				RetSituacao(cFil ,cMat , .T.,M->RG_DATADEM)
	        Else
		        fRetSitRes(cFil,cMat)
    		EndIf
		EndIf

		FwFormCommit(oModel) //nao precisa fazer validacoes novamente pois o formulario jah foi validado antes da aplicacao de rescisao

		DbSelectArea("SRG") //voltar para a tabela SRG
	End Transaction

	While SRC->( !Eof() ) .and. SRC->( RC_FILIAL+RC_MAT+RC_PROCES+RC_ROTEIR+RC_PERIODO+RC_SEMANA) == SRA->(RA_FILIAL+RA_MAT+RA_PROCES)+cSvRoteir+cSvPer+cSvNPgto

   		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Obtem o Proximo Registro                    				   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !GetNextRecno( "SRC", @nNextRecno , @nRecno , nOrder )
			Exit
		EndIf

		RecLock( "SRC", .F.)
		SRC->RC_PERIODO := cPer
		SRC->RC_ROTEIR	:= cRoteir
		SRC->RC_SEMANA 	:= cNPgto
		MsUnlock()

		If !GotoNextRecno( "SRC" , nNextRecno , nOrder )
			Exit
		EndIf
    EndDo

	If lRet
		Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0089) , 1, 0 )//"Atenção"##"Processo Concluido com Sucesso!"
	EndIf
EndIf

Return(lRet)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³OpcRecRes ³ Autor ³ Marinaldo de Jesus 	  ³ Data ³04/03/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Dialogo com as Opcoes para Recalculo da Resciasao			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³OpcRecRes( nOpc )											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Numero da Opcao de Recalculo da Rescisao: 0 -> Sair			³
³          ³                                          1 -> Recalculo	³
³          ³                                          2 -> Complementar ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³GPEM040   												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function OpcRecRes()

Local aSvKeys	:= GetKeys()

Local bSet15	:= { || lOpcOk := .T.	, RestKeys( aSvKeys , .T. ) , oDlg:End() }
Local bSet24	:= { || nOpcRec := 0	, RestKeys( aSvKeys , .T. ) , oDlg:End() }

Local lOpcOk	:= .F.

Local nOpcRec	:= 1.00

Local oRadio
Local oDlg
Local oGroup
Local oFont
Local oCheckRes
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

aAdvSize	:= MsAdvSize( ,.T.,370)
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 15 }
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
aObjSize	:= MsObjSize( aInfoAdvSize , aObjCoords )

DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
DEFINE MSDIALOG oDlg FROM  aAdvSize[7],0 TO aAdvSize[6]*0.60,aAdvSize[5] TITLE OemToAnsi( STR0001 ) PIXEL

	@ aObjSize[1,1],aObjSize[1,2]	GROUP oGroup TO aObjSize[1,1] + 45,aObjSize[1,4] LABEL OemToAnsi(STR0114) OF oDlg PIXEL	//"Rescis„o ja foi Calculada. Escolha a Op‡„o:"
	oGroup:oFont:=oFont

	If ( cPaisLoc == "MEX" ) .AND. ( TYPE("SRG->RG_FECREI") <> "U" )
		@ aObjSize[1,1]+10,aObjSize[1,2]+10	RADIO oRadio VAR nOpcRec ITEMS 	OemToAnsi(STR0115)	,;			//"Recalcular"
																				OemToAnsi(STR0116)	,;	   		//"Complementar"
																				OemToAnsi(STR0117)	 ;			//"Nova"
					SIZE 115,010 OF oDlg PIXEL

		@ aObjSize[1][1]+40,aObjSize[1][2]+10 CHECKBOX oCheckRes VAR lRescDis PROMPT OemToAnsi( STR0118 ) SIZE 95,10 OF oDlg PIXEL FONT oFont  	//"Complementar por Dissidio"
	Else
		@ aObjSize[1,1]+10,aObjSize[1,2]+10	RADIO oRadio VAR nOpcRec ITEMS 	OemToAnsi(STR0115)	,;			//"Recalcular"
																				OemToAnsi(STR0116)	 ;	   		//"Complementar"
					SIZE 115,010 OF oDlg PIXEL
		oRadio:bChange := { || fRadioChange(nOpcRec, oCheckRes) }

		@ aObjSize[1][1]+30,aObjSize[1][2]+10 CHECKBOX oCheckRes VAR lRescDis PROMPT OemToAnsi( STR0118 ) SIZE 95,10 OF oDlg PIXEL //"Complementar por Dissidio"
		oCheckRes:lVisible := .F.
	EndIf

	oDlg:bSet24 := { || nOpcRec := 0 , oDlg:End() }
	bSvSet24 := SetKey( 24 , oDlg:bSet24 )

	oDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.

ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 )
RestKeys( aSvKeys , .T. )

If !( lOpcOk )
	nOpcRec := 0
EndIf

Return( nOpcRec )

/*/{Protheus.doc} OpcRecCom
Dialogo com as Opcoes para Complementar
@author Allyson
@since 26/12/2018
@version 1.0
@return cOpcRec  -  1 -> Complementar
					2 -> Complementar por Dissídio
					3 -> Retificação
/*/
Static Function OpcRecCom()

Local aSvKeys	:= GetKeys()

Local bSet15	:= { || lOpcOk := .T.	, RestKeys( aSvKeys , .T. ) , oDlg:End() }
Local bSet24	:= { || nOpcRec := 0	, RestKeys( aSvKeys , .T. ) , oDlg:End() }

Local lOpcOk	:= .F.

Local cOpcRec	:= "0"
Local nOpcRec	:= 1.00

Local oRadio
Local oDlg
Local oGroup
Local oFont
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

aAdvSize	:= MsAdvSize( ,.T.,370)
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 15 }
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
aObjSize	:= MsObjSize( aInfoAdvSize , aObjCoords )

DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
DEFINE MSDIALOG oDlg FROM  aAdvSize[7],0 TO aAdvSize[6]*0.60,aAdvSize[5] TITLE OemToAnsi( STR0001 ) PIXEL

	@ aObjSize[1,1],aObjSize[1,2]	GROUP oGroup TO aObjSize[1,1] + 45,aObjSize[1,4] LABEL OemToAnsi(STR0114) OF oDlg PIXEL	//"Rescis„o ja foi Calculada. Escolha a Op‡„o:"
	oGroup:oFont:=oFont

	@ aObjSize[1,1]+10,aObjSize[1,2]+10	RADIO oRadio VAR nOpcRec ITEMS 	OemToAnsi(STR0116)	,;			//"Complementar"
																		OemToAnsi(STR0118)	,;	   		//"Complementar por Dissidio"
																		OemToAnsi(STR0240)	 ;	   		//"Retificação"
				SIZE 115,010 OF oDlg PIXEL

	oDlg:bSet24 := { || nOpcRec := 0 , oDlg:End() }
	bSvSet24 := SetKey( 24 , oDlg:bSet24 )

	oDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.

ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 )
RestKeys( aSvKeys , .T. )

If !lOpcOk
	nOpcRec := 0
EndIf

cOpcRec := Str(nOpcRec, 1)

Return( cOpcRec )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Gpem040Exc 	³ Autor ³Marinaldo de Jesus   ³ Data ³16/05/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Excluir os Itens de Rescisoes Calculados					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpem040Exc( nRegSrg , aSrgRecnos , aSrgExclui )				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL 														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³GPEM040   												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function Gpem040Exc( nRegSrg , aSrgRecnos , aSrgExclui, lResPosFol,cAfasfgts)

Local aSituacao		:= {}

Local cFil			:= SRA->RA_FILIAL
Local cMat			:= SRA->RA_MAT
Local cKey			:= ( ( cFil + cMat ) + "R" )
Local cKeySPB		:= cFil + cMat

Local lExcluiu		:= .F.

Local nRecno		:= 0.00
Local nRecnos		:= 0.00
Local nIndSRR		:= RetOrder( "SRR", "RR_FILIAL+RR_MAT+RR_TIPO3+DTOS(RR_DATA)+RR_PD+RR_CC" )
Local cMyChave		:= ""

DEFAULT aSrgRecnos	:= { { nRegSrg, ,  } }
DEFAULT aSrgExclui  := { { .T. } }
DEFAULT lResPosFol  := .F.
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Controle nOpcEx para exclusão.       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nOpcEx := 9
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa a gravacao dos lancamentos do SIGAPCO        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PcoIniLan("000090")

Begin Transaction

	nRecnos := Len( aSrgRecnos )
	For nRecno := 1 To nRecnos
		If ( aSrgExclui[ nRecno , 01 ] )
			lExcluiu := .T.
			SRG->( dbGoto( aSrgRecnos[ nRecno, 1 ] ) )
			SRR->( dbSetOrder(nIndSRR) )
			If SRR->( dbSeek( cKey ) )
				While SRR->( !Eof() .and. cKey == RR_FILIAL+RR_MAT+RR_TIPO3 )
					If ( SRG->RG_DTGERAR == SRR->RR_DATA )
						SRR->( RecLock("SRR",.F.,.T.) )
						SRR->( dbDelete() )
						SRR->( MsUnLock() )
						//integracao com modulo SIGAPCO
						PcoDetLan("000090","01","GPEM040", .T.)
					EndIf
					SRR->( dbSkip() )
				EndDo
			EndIf
			//# Salva chave pra pesquisa futura
			cMyChave := SRG->(RG_MAT+RG_PROCES+RG_ROTEIR+RG_PERIODO+RG_SEMANA)

			SRG->( RecLock( "SRG" , .F. , .T. ) )
			SRG->( dbDelete() )
			SRG->( MsUnLock() )
		EndIf
	Next nRecno

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se ocorreu exclusao                                           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If ( lExcluiu )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Verifica a Situacao do Funcionario                            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If cPaisLoc <> "MEX"	// Para o México nao devera alterar os campos de demissao na exclusao, pois
								// o status e os demais campos sao informados no cadastro de funcionario
			aSituacao := RetSituacao( cFil , cMat , .F. , NIL , .T. )
			If !( aSituacao[1] == "D" )
				SRA->( RecLock( "SRA" , .F. , .T. ) )
				SRA->RA_DEMISSA  := Ctod("//")
				SRA->RA_RESCRAI  := "  "
				If ( ( cPaisLoc == "DOM" ) .and. !Empty(SRA->RA_DTENTRA) )
					SRA->RA_DTENTRA := Max(SRA->RA_ADMISSA,(SRA->RA_DTENTRA - 365))
				EndIf
				SRA->( MsUnLock() )

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Atualiza Bloqueio do SRA e Apaga SRC com dados da Rescisao ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If lResPosFol .And. cPaisLoc == "ARG"

					ResBloqSRA("E")	//# Excluir
					ResExclSRC( cMyChave )	//# SRG->(RG_MAT+RG_PROCES+RG_ROTEIR+RG_PERIODO+RG_SEMANA)

					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0119), 1, 0 )//#"Rescisão depois da folha excluida com sucesso !!!"###"Atencao"

				EndIf

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Retorna a Atual Situacao do Funcionario                       ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				RetSituacao(cFil , cMat , .T. , NIL , .T. )
			EndIf

		EndIf

		If FindFunction("OrgXDelRescisao")
			OrgXDelRescisao(SRA->RA_FILIAL, SRA->RA_MAT)
		EndIf

		//--Retorna o campo PB_INTEGRA para Nil, de forma que este possa ser integrado com a folha apos o fechamento
		ExcIntSPB(cKeySPB)

	EndIf

End Transaction

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Finaliza a gravacao dos lancamentos do SIGAPCO          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PcoFinLan("000090")

Return( Nil )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GP40DiasAv  ³ Autor ³ Leandro Drumond       ³ Data ³ 14/01/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula dias e data de aviso previo.                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³GP40DiasAv(@dDataAv,nDiasAv)									³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function GP40DiasAv(dDataAv,nDiasAv,cTpAviso,nDiasCum,nDiaInde)

	DEFAULT nDiasAv		:= 0
	DEFAULT nDiasCum	:= 0
	DEFAULT nDiaInde	:= 0

	If cPaisLoc == "BRA"
		nDiasAv:= (fDesc( "RCE", SRA->RA_SINDICA, "RCE_DIASAV" ))
	EndIf

	lProJav := If(Type("lProJav") <> "L", .F., lProJav)

	If cPaisLoc == "BRA" .And. RCE->(ColumnPos( "RCE_PRJAVT")) > 0
		If (fDesc( "RCE", SRA->RA_SINDICA, "RCE_PRJAVT" )) == "2"
			lProj := .F.
		Endif
	Else
		lProj := .T.
	Endif

	If nDiasAv == 0 .And. lProjav .And. ( (lProj .And. cTpAviso $ "T*B") .Or. ! cTpAviso $ "T*B")
		nDiasAv := fComplAvP(dDatadem1,nAnosCasa,cTpAviso)
	EndIf
	If cPaisLoc == "BRA"
		If	nDiasAv == 0 .And. lProjav .And. ( (lProj .And. cTpAviso $ "T*B") .Or. ! cTpAviso $ "T*B")
			nDiasAv := fAvProj(dDatadem1,nAnosCasa,,cTpAviso,,@nDiasCum,nDiaInde)
		EndIf
	Else
		If	nDiasAv == 0 .And. lProjav
			nDiasAv := fAvProj(dDatadem1,nAnosCasa,,cTpAviso)
		EndIf
	Endif

	If nDiasAv == 0 .and. !lProjav
		nDiasAv:= 30
	EndIf

	If cPaisLoc <> "BRA"
		If nDiasAv > 0 .and. lProJav
			dDataAv := If( ! Empty(aIncRes) .And. ! aIncRes[02] $ "T*B", If(lSabDom .and. dDatadem <> dDatadem1, dDatadem1, dDatadem), dDatadem - nDiasAv + 1)
		EndIf
	Endif
	if nDiasAv > 0 .and. !Empty(aIncRes) .And. aIncRes[02] == "N"
		nDiasAv := 0
	Endif

Return nDiasAv

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fChkDtGer   ³ Autor ³ Leandro Drumond       ³ Data ³ 23/01/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valid do campo RG_DTGERAR.			                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fChkDtGer()													³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fChkDtGer()
Local aArea			:= GetArea()
Local lRet 			:= .T.
Local aPerAberto	:= {}
Local dDataGer  	:= &(ReadVar())
Local oModel		:= FWModelActive()
Local cFil			:= ""
Local cMat			:= ""
Local nRecAux		:= SRG->(Recno())
Local nX			:= 0
Local lUsaDiss		:= lRescDis
If cModFol == "2"
	If Type("cCompl") == "U" .Or. cCompl == Nil
		Private cCompl := "N"
	EndIf
	If Type("dDataDem1") == "U" .Or. dDataDem1 == Nil
		Private dDataDem1 := ddatabase
	EndIf
	If Type("dDataDem") == "U" .Or. dDataDem == Nil
		Private dDataDem := fDtSabDom()
	EndIf
	If Type("nSabDom") == "U" .Or. nSabDom == Nil
		Private nSabDom := 0
	EndIf
EndIf

If Type("cModel") == "C" .AND. ! Empty(cModel)
	cFil := oModel:GetModel(cModel):GetValue("RG_FILIAL")
	cMat := oModel:GetModel(cModel):GetValue("RG_MAT")
Else
	cFil := oModel:GetModel('GPEM040_MSRG'):GetValue("RG_FILIAL")
	cMat := oModel:GetModel('GPEM040_MSRG'):GetValue("RG_MAT")
EndIf

Begin Sequence
	If cCompl == "S"
		SRG->(DbSetOrder(1))
		If SRG->(DbSeek(cFil+cMat+DtoS(dDataGer)))
			Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0134), 1, 0 ) //"Atenção"###"A data de geração da complementar deve ser diferente das demais rescisões"
			lRet := .F.
			SRG->(DbGoTo(nRecAux))
			Break
		Else
			SRG->(DbGoTo(nRecAux))
		EndIf

		If cPaisLoc == "BRA"
			For nX := 1 To Len(aSrgRecnos)
				SRG->( dbGoTo( aSrgRecnos[nX, 1] ) )
				//Se existiu uma complementar por dissídio no mês atual, força a nova rescisão como dissídio para que calcule a anterior corretamente (apenas a última será integrada)
				If AnoMes( SRG->RG_DTGERAR ) == AnoMes(dDataGer) .and. SRG->RG_RESCDIS == "2"
					lUsaDiss := .T.
				EndIf
			Next nX
		EndIf
		SRG->(DbGoTo(nRecAux))

		If !(AnoMes(dDataGer) == AnoMes(dDataDem)) .or. lRescDis
			fRetPerComp(SubStr(Dtos(dDataGer),5,2), SubStr(Dtos(dDataGer),1,4),, SRA->RA_PROCES,fGetCalcRot("4"),@aPerAberto )

			If Empty(aPerAberto)
				Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0135), 1, 0 ) //"Data de Geração Inválida. A Data de geração deve pertencer ao periodo em aberto"
				lRet := .F.
			Else
				dDataDe 	:= aPerAberto[1,5]
				dDataAte 	:= aPerAberto[1,6]
				cPeriodo	:= aPerAberto[1,1]
				cNumPag		:= aPerAberto[1,2]

				aPeriodo 	:= {}

				fCarPeriodo( cPeriodo , cRot , @aPeriodo , @lUltSemana , @nPosSem)

				//Altera periodo e semana na tela
				M->RG_PERIODO := cPeriodo
				M->RG_SEMANA  := cNumPag

				fSalario(@Salario,@SalHora,@SalDia,@SalMes,"A",AnoMes(dDataDe),cNumPag)

				M->RG_SALMES  := SalMes
				M->RG_SALDIA  := SalDia
				M->RG_SALHORA := SalHora

				If IsBlind()
					oModel:LoadValue("GPEM040_MSRG","RG_PERIODO",cPeriodo)
					oModel:LoadValue("GPEM040_MSRG","RG_SEMANA",cNumPag)
					oModel:LoadValue("GPEM040_MSRG","RG_SALMES",SalMes)
					oModel:LoadValue("GPEM040_MSRG","RG_SALDIA",SalDia)
					oModel:LoadValue("GPEM040_MSRG","RG_SALHORA",SalHora)
				EndIf

				//Ponto de Entrada para alteração do cabeçalho da rescisão - Tv Tribuna
				If ExistBlock( "GPESALAR" )
					ExecBlock("GPESALAR",.F.,.F.)
				EndIf

			EndIf
		EndIf

	Else
	    If Empty(dDataGer)
			 Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0171), 1, 0 ) //"Data de Geração não foi preenchida"
			 lRet := .F.
	    Else
			If !(AnoMes(dDataGer) == AnoMes(dDataDem))
				fRetPerComp(SubStr(Dtos(dDataGer),5,2), SubStr(Dtos(dDataGer),1,4),, SRA->RA_PROCES,fGetCalcRot("4"),@aPerAberto )
				If Empty(aPerAberto)
					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0135), 1, 0 ) //"Data de Geração Inválida. A Data de geração deve pertencer ao periodo em aberto"
					lRet := .F.
		       EndIf
		   Else
				SRG->(DbSetOrder(1))
				If SRG->(DbSeek(cFil+cMat+DtoS(dDataGer)))
					Help( ,, OemToAnsi(STR0020),, OemToAnsi(STR0193), 1, 0 ) //"Atenção"###"Data de Geração Inválida. Já existe Rescisão calculada para esta data."
					lRet := .F.
					SRG->(DbGoTo(nRecAux))
					Break
				Else
					SRG->(DbGoTo(nRecAux))
				EndIf
			EndIf
       EndIf

	EndIf
End Sequence

RestArea(aArea)

If lRet
	lRescDis := lUsaDiss
EndIf
Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCarRGB     ³ Autor ³ Leandro Drumond       ³ Data ³ 17/01/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Carrega lançamentos da RGB para analise na calmed             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fCarRGB()														³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fCarRGB(cProcAux,cPerAux,cSemAux)
Local aArea		 := GetArea()
Local cQuery	 := GetNextAlias()
Local cWhere	 := ""
Local cRotRGB	 := fGetRotOrdinar() + "*" + fGetCalcRot("4") //FOL*RES
Local cSeq := ""

DEFAULT cProcAux := M->RG_PROCES
DEFAULT cPerAux	 := M->RG_PERIODO
DEFAULT cSemAux	 := M->RG_SEMANA

cWhere := "%"
cWhere += " RGB_FILIAL 	= '" + SRA->RA_FILIAL + "' AND "
cWhere += " RGB_MAT 	= '" + SRA->RA_MAT + "' AND "
cWhere += " RGB_PROCES 	= '" + cProcAux + "' AND "
cWhere += " RGB_PERIOD  = '" + cPerAux + "' AND "
cWhere += " RGB_SEMANA 	= '" + cSemAux + "' "
cWhere += "%"

BeginSql alias cQuery
	SELECT
		column RGB_DTREF AS Date
		RGB_PD, RGB_VALOR, RGB_CC, RGB_CC, RGB_TIPO1, RGB_TIPO2, RGB_HORAS, RGB_DTREF, RGB_ROTEIR
	FROM 		%table:RGB% RGB
	WHERE
				%exp:cWhere% AND
				RGB.%NotDel%
EndSql

While (cQuery)->( !Eof() )
	If (cQuery)->RGB_ROTEIR $ cRotRGB
		If (cQuery)->( nPos := Ascan(aPd, { |X| X[1] == RGB_PD .And. X[3] = cSemana .And. X[2] = RGB_CC .AND. X[10] == RGB_DTREF } ) ) == 0
			If (cQuery)->( nPos := Ascan(aPd, { |X| X[1] == RGB_PD .And. X[3] = cSemana .And. X[2] = RGB_CC  } ) ) > 0
				If Empty(cSeq)
					cSeq := "0"
				EndIf
				cSeq := Soma1(cSeq)
			Else
				cSeq := ""
			EndIf
			(cQuery)->( FMatriz(RGB_PD,RGB_VALOR,RGB_HORAS,,RGB_CC,RGB_TIPO1,RGB_TIPO2,,,RGB_DTREF,,cSeq ) )
		Else
			aPd[nPos,4] += (cQuery)->RGB_HORAS
			aPd[nPos,5] := Round((cQuery)->RGB_VALOR + aPd[nPos,5],2)
		EndIf
	EndIf
	(cQuery)->(dbSkip())
EndDo

dbSelectArea(cQuery)
dbCloseArea()

RestArea(aArea)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³Gpm40LoadRRA  ³ Autor ³ Leandro Drumond   ³ Data ³ 03.08.12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carrega valores de RRA                                	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM040                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±/*/
Function Gpm40LoadRRA(nIr_B,nVal_Peal,aTabIr,nMeses,dDataHom,cPdIr,cPdInss)
Local aArea		:= GetArea()
Local cChave	:= ""
Local nBaseAux 	:= 0
Local nPosTab	:= 0
Local nX		:= 0

//Carrega tabela de IR para RRA somente se o periodo nao tiver sido carregado
nPosTab := fPosTab( "S034",AnoMes(dDataHom),">=",4,AnoMes(dDataHom),"<=",5 )

If nPosTab > 0
	aAdd(aTabIr,"S034")
	For nX := 1 to 21
		aAdd(aTabIr,fTabela("S034",nPosTab,nX))
	Next nX
Else
	If IsInCallStack( "EXECROT" ) //Se estiver executando roteiro de calculo
		AddLogExecRot( STR0125 )	// "Tabela de IR RRA (Tabela S034) não cadastrada."
		FinalCalc()
	Else
		Help( , , OemToAnsi(STR0020), , OemToAnsi( STR0125 ), 1, 0 )// "Tabela de IR RRA (Tabela S034) não cadastrada."
	EndIf
    SET DECIMALS TO 2
    Return ( .F. )
EndIf

//Se for verba de RRA, soma verbas de RRA Ferias
If cPdIR == aCodFol[974,1]
	Aeval( aPd ,{ |X| SomaInc(X,5,@nBaseAux,11,"S",12,"N",Month(dDataBase), ,aCodFol) })
EndIf

//Se nao existe base de IR, nao precisa somar IR RRA
If nIr_B <= 0 .and. nBaseAux <= 0
	Return Nil
EndIf

aEval( aPD , { |x| nBaseAux += IF( X[1] = cPdIr .And. X[3] = cSemana .And. X[9] # "D" .And. ( X[10] == NIL .Or. Empty(X[10]) .Or. MesAno(dDataHom) = MesAno(X[10]) ), x[5] , 0.00 ) } )

If nBaseAux > 0
	If ( nPos := Ascan(aPD,{ |X| !Empty(X[17]) }) ) > 0

		cChave := xFilial("RFC")+SRA->RA_MAT+aPd[nPos,17]+cPdIr

		DbSelectArea("RFC")
		DbSetOrder(RetOrder("RFC","RFC_FILIAL+RFC_MAT+RFC_IDCMPL+RFC_PD+RFC_CC+RFC_DATARQ+RFC_SEQ"))

		If(DbSeek(cChave))
			While(RFC->(!Eof() .and. RFC_FILIAL + RFC_MAT + RFC_IDCMPL + RFC_PD == cChave))
				nMeses += RFC->RFC_MESES
				RFC->(DbSkip())
			EndDo

			nIr_B += nBaseAux

			//Soma deducoes de INSS RRA
			aEval( aPD , { |x| nVal_Peal += IF( X[1] = cPdInss .And. X[3] = cSemana .And. X[9] # "D" .And. ( X[10] == NIL .Or. Empty(X[10]) .Or. MesAno(dDataHom) = MesAno(X[10]) ), x[5] , 0.00 ) } )

		EndIf
		EndIf
EndIf

//Zera IR RRA e IR RRA 13o para nao duplicar calculo do liquido
If ( nPos := Ascan(aPD,{ |X| X[1] == aCodFol[978,1] } ) ) > 0
	aPd[nPos,5] := 0
EndIf
If ( nPos := Ascan(aPD,{ |X| X[1] == aCodFol[983,1] } ) ) > 0
	aPd[nPos,5] := 0
EndIf

RestArea(aArea)
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³fTpRescDir³ Autor ³ Alessandro Santos	    ³ Data ³ 29/03/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Selecionar tipo de rescisao de diretor                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fTpRescDir()											 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ Cadastro tabela SRG - Campo RG_TPDIR  					  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fTpRescDir()
Local cTitulo 	:= OemtoAnsi(STR0127) //##"Informacoes de Diretor"
Local MvPar   	:= ""
Local MvParDef	:= ""
Local MvStrRet := ""
Local nGrupo  	:= 0
Local lRet    	:= .T.
Local l1Elem  	:= .T.
Local aArea   	:= GetArea()
Local aTipo := { "01-" + OemtoAnsi(STR0128),; //##"Exoneracao do Diretor Nao Empregado sem justa causa, por deliberacao da assembleia, dos socios cotistas ou da autoridade competente"
				  "02-" + OemtoAnsi(STR0129),; //##"Termino de Mandato do Diretor Nao Empregado que nao tenha sido reconduzido ao cargo"
				  "03-" + OemtoAnsi(STR0130),; //##"Exoneracao a pedido de Diretor Nao Empregado"
				  "04-" + OemtoAnsi(STR0131),; //##"Exoneracao do Diretor Não Empregado por culpa receproca ou forca maior"
				  "05-" + OemtoAnsi(STR0132),;	//##"Morte do Diretor Nao Empregado"
				  "06-" + OemtoAnsi(STR0133),;  //##"Exoneracao do Diretor Nao Empregado por falencia, encerramento ou supressao de parte da empresa"
				  "99-" + OemtoAnsi(STR0260)}  //##"Outros"

cAlias 	:= Alias() 					// Salva Alias Anterior
MvPar	:= &(Alltrim(ReadVar()))	// Carrega Nome da Variavel do Get em Questao
MvRet	:= Alltrim(ReadVar())		// Iguala Nome da Variavel ao Nome variavel de Retorno
VAR_IXB := MvPar



MvParDef := "01020304050699"

If f_Opcoes(@MvPar, cTitulo, aTipo, MvParDef,,, l1Elem, 2)
	For nGrupo := 1 To Len(MvPar)
 		If (SubStr(MvPar, nGrupo, 2) # "*")
   			MvStrRet += SubStr(mvpar, nGrupo, 1)
      	Else
       		MvStrRet += Space(1)
		Endif
	Next nGrupo

	&(MvRet) := AllTrim(MvStrRet)
EndIf

If MvStrRet $ MvParDef
	lRet := .T.
Else
	lRet := .F.
EndIf

RestArea(aArea)

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³ fValEfd 	ºAutor  ³ Emerson Campos     º Data ³  20/09/2013 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao para validar todos os campos do eSocial			  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cObs Campo observação da aba eSocial			  			  º±±
±±º          ³ cAtOb Campo Atestado de obito da aba eSocial			      º±±
±±º          ³ cTpRes Campo Tipo de rescisao da aba eSocial			      º±±
±±º          ³ cNrProc Campo nro do processo trabalhista da aba eSocial	  º±±
±±º          ³ cCnpj Campo CNPJ da sucessora da aba eSocial			  	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEM040 			                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fValEfd(cObs, cAtOb, cTpRes, cNrProc, cNroCnpj, cTpSuc, cMsg)
Return fValEfdM040(cObs, cAtOb, cTpRes, cNrProc, cNroCnpj, cTpSuc, cMsg)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fObitoVld	ºAutor  ³ Emerson Campos     º Data ³  20/09/2013 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao para validar o ca				  					  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEM040 			                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fObitoVld(cAtObito, cTipR)
Return fObtVldM040(cAtObito, cTipR)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³ fValCNPJ  ºAutor  ³ Emerson Campos    º Data ³  26/09/2013 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao para limitar em 255 caractreres no campo memo		  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEM040 			                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fValCNPJ(cCnpj, cTipR, cTpSuc, cMsg)
Return fVldInsM040(cCnpj, cTipR, cTpSuc, cMsg)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³INTEGDEF  ºAutor  ³                     º Data ³ 06/01/2015 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função para a interação com EAI                             º±±
±±º          ³envio e recebimento                                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function IntegDef( cXml, nType, cTypeMsg, cVersaoMsg )

Local aRet  := {}

aRet:= GPEI041( cXml, nType, cTypeMsg, cVersaoMsg )

Return aRet

/*/{Protheus.doc} VldTpRes
Valida o Tipo de rescisão vindo do portal.
@author cicero.pereira
@since 23/09/2015
@version 2.0
@see http://tdn.totvs.com/x/PrthE
/*/
Static Function VldTpRes()

	Local aAreaSRG	:= SRG->( GetArea() )
	Local lRet		:= .F.

	If M->RG_TIPORES == cTipResPortal
		lRet := .T.
	EndIF

	//Ponto de entrada para definir se o tipo de rescisão pode ser alterado quando a solicitação vier do portal
	If ExistBlock( "VLDTPRESP" )
		lRet := ExecBlock("VLDTPRESP",.F.,.F.)
	EndIf

	RestArea(aAreaSRG)

Return ( lRet )

/*/{Protheus.doc} fRadioChange
@author Allyson Mesashi
@Since 06/02/2017
@version 1.0
@param nOpcao Opção selecionada (1-Recálculo, 2-Complementar)
@param oCheck Objeto oCheckRes da opção "Complementar por dissídio"
/*/
Static Function fRadioChange(nOpcao, oCheck)

If nOpcao == 1
	lRescDis		:= .F.
	oCheck:lVisible := .F.
Else
	oCheck:lVisible := .T.
EndIf

oCheck:Refresh()

Return .T.

Static Function IncidCpos(oStruct,cTabela,lIsView)
	Local aArea	:= SX3->(GetArea())
	Local aCampos := {'RV_INSS','RV_FGTS','RV_IR','RV_INCORP','RV_REF13','RV_REFFER'}
	Local nI := 0
	Local cCpNome := ''
	Local cPrefixo := ''
	Local cOrdem := ''
	Local cCpoPD := ''
	Local bIniPad := {||}
	Local cIniPad := ''
	Default lIsView := .F.

	cPrefixo := PrefixoCpo(cTabela)
	cCpoPD := cPrefixo + '_PD'

	SX3->(dbSetOrder(2))
	dbSelectArea('SX3')
	for nI:= 1 to Len(aCampos)
		cCpNome := cPrefixo + SubStr( aCampos[nI], At('_',aCampos[nI]))
		if(dbSeek(aCampos[nI]))
			if(lIsView)
				cOrdem := aTail(oStruct:aFields)[2]
				cOrdem := Val(cOrdem) + 1
				cOrdem := StrZero(cOrdem,2)

				oStruct:AddField(	cCpNome, cOrdem, AllTrim(X3_TITULO), AllTrim(X3_TITULO), {}, X3_TIPO, AllTrim(X3_PICTURE),;
				/*bPictVar*/, /*cLookUp*/, /*lCanChange*/, /*cFolder*/, /*cGroup*/, /*aComboValues*/,;
				/*nMaxLenCombo*/, /*cIniBrow*/, .T.)
			else
				cIniPad := 'POSICIONE( "SRV", 1, xFilial("SRV")+'+ cTabela + '->'+ cCpoPD + ',"'+ aCampos[nI] +'")'
				bIniPad := FwBuildFeature( STRUCT_FEATURE_INIPAD, cIniPad )
				oStruct:AddField(AllTrim(X3_TITULO), AllTrim(X3_TITULO), cCpNome, X3_TIPO, X3_TAMANHO, X3_DECIMAL,;
			  	/*bValid*/, /*bWhen*/, /*aValues*/, /*lObrigat*/, bIniPad, /*lKey*/, /*lNoUpd*/,.T.)

		endIf
		endIf
	next nI

	RestArea(aArea)

Return nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGP40TPRES  ºAutor  ³Rh Manutenção      º Data ³  31/05/17  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Baseado no tipo de rescisao informado, realiza um de/para naº±±
±±º          ³ tabela do eSocial e retorna a opcao selecionada            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Rescisao Simples e Rescisao Coletiva                       º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fGP40TPRES( cCodTpRes, cTpAvs )
Return fM40TPRES( cCodTpRes, cTpAvs )

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGP40VLRES  ºAutor  ³Rh Manutenção      º Data ³  31/05/17  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Realiza a validacoes dos dados enviados para rescisao do    º±±
±±º          ³ funcionario corrente                                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Realiza a validacao dos registros setados em memoria       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParam     ³ cTpAviso   : Tipo de Aviso do funcionário                  º±±
±±º          ³ cCdEFD     : Tipo Rescisao do eSocial                      º±±
±±º          ³ dDtDemissa : Data de demissao do desligamento              º±±
±±º          ³ cCodObito  : Numero de certidao de obito do funcionario    º±±
±±º          ³ cTpRes     : 1 = Rescisao Simples / 2 = Rescisao Coletiva  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fGP40VLRES( cTpAviso, cCdEFD, dDtDemissa, cCodObito, cTpRes, cIndAv, aErroRes, lAviso, cVersEnvio, nOper, lNT15)
Return fM40VLRES( cTpAviso, cCdEFD, dDtDemissa, cCodObito, cTpRes, cIndAv, aErroRes, lAviso, cVersEnvio, nOper, lNT15)

/*/{Protheus.doc} fVincSQG
Disponibiliza o currículo do funcionário ou troca o status para FUN
@author Gabriel A.
@Since 21/09/2017
@version 1.0
@param nOperacao Operação da rescisão - Inclusão ou Exclusão
@param cFil Filial do funcionário
@param cMat Matrícula do funcionário
/*/
Static Function fVincSQG(nOperacao,cFil,cMat)
	Local cCurriculo := ""
	Local aArea      := GetArea()
	Local cAliasQry  := GetNextAlias()
	Local cFilSQG    := xFilial("SQG",cFil)

	BeginSql Alias cAliasQry
		SELECT QG_FILIAL,QG_CURRIC
		FROM %Table:SQG% SQG
		WHERE
			QG_FILMAT = %Exp:cFil% AND
			QG_MAT = %Exp:cMat% AND
			SQG.%NotDel%
	EndSql

	If !( (cAliasQry)->(EOF()) )
		cCurriculo := (cAliasQry)->QG_CURRIC

		DbSelectArea("SQG")
		SQG->( DbSetOrder(1) )

		If SQG->( DbSeek(cFilSQG + cCurriculo) )
			RecLock("SQG",.F.)
			If nOperacao == MODEL_OPERATION_DELETE
				If SRA->RA_ADMISSA <= SQG->QG_DTCAD
					SQG->QG_SITUAC := "FUN"
				Else
					SQG->QG_SITUAC := "002"
				EndIf
			Else
				SQG->QG_SITUAC := "001"
			EndIf
			SQG->( MsUnlock() )
		EndIf

		SQG->( DbCloseArea() )
	EndIf

	RestArea(aArea)
Return

/*/{Protheus.doc}fChkInteg()
- Verifica se existem dados que nao foram integrados.
@Type Static Function
@author:	Jônatas Alves
@since:		26/09/2017
@param:	lMsg - Indica se deve exibir mensagem ao usuario.
@version 1.0
@return lRet - Retorno lógico, indica se prossegue com a rescisão.
/*/
Static Function fChkInteg( lMsg )

Local aArea		:= GetArea()
Local aRCH		:= RCH->(GetArea())
Local aLogAux	:= {}
Local cQuery	:= ""
Local cAliasQRY	:= GetNextAlias()
Local cKeyRCH	:= xFilial("RCH") + cProcesso + GetRotExec() + cPeriodo
Local cUltSemana:= cNumPag
Local lRet 		:= .T.
Local lFirst	:= .T.

Private aLogErros	:= {}				// Array com os logs de erros de processamento


DbSelectArea("RCH")
DbSetOrder(4) //RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG
DbSeek( cKeyRCH  + cNumPag )

While !Eof() .and. RCH_FILIAL + RCH_PROCES + RCH_ROTEIR + RCH_PER == cKeyRCH
	If RCH_NUMPAG <>  cNumPag
		cUltSemana  := RCH_NUMPAG
	EndIf
	RCH->(DbSkip())
EndDo

cQuery := "SELECT * FROM " + RetSqlName("RCH") + " RCH "
cQuery += "INNER JOIN " + RetSqlName("SRY") + " SRY "
cQuery += "ON RCH.RCH_ROTEIR = SRY.RY_CALCULO AND "
cQuery += FWJoinFilial( "RCH", "SRY" )
cQuery += " INNER JOIN " + RetSqlName("RCJ") + " RCJ "
cQuery += "ON RCH.RCH_PROCES = RCJ.RCJ_CODIGO AND "
cQuery += FWJoinFilial( "RCH", "RCJ" )
cQuery += " INNER JOIN " + RetSqlName("SRA") + " SRA "
cQuery += "ON " + FWJoinFilial( "RCH", "SRA" )
cQuery += " WHERE RCH_PROCES = '" + cProcesso + "' AND RCH_PER = '" + cPeriodo + "' AND RCH_DTINTE = ''"
cQuery += " AND RY_INTEGRA = '1'" //Nao valida folha, adiantamento, 13o., Autonomo e PLR pois nao sao integraveis
cQuery += " AND RY_TIPO <> '4'" //Nao valida o proprio roteiro de rescisao
cQuery += " AND RA_FILIAL = '" + SRA->RA_FILIAL + "'"
cQuery += " AND RA_MAT = '" + SRA->RA_MAT + "'"

If cUltSemana <> cNumPag //Se for a ultima semana, todos as demais semanas devem estar fechadas
	cQuery += " AND RCH_NUMPAG = '" + cNumPag + "'"
EndIf

cQuery += "  AND RCJ.D_E_L_E_T_ = ' ' AND RCH.D_E_L_E_T_ = ' ' AND SRY.D_E_L_E_T_ = ' ' AND SRA.D_E_L_E_T_ = ' '"
cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQRY)

dbSelectArea(cAliasQRY)

cMsgLog := ""

While !((cAliasQRY)->(EOF()))
	If lFirst
		cMsgLog += STR0199 + CRLF // "Os seguintes roteiros de cálculo ainda não foram integrados:"
		aAdd(aLogErros, { OemToAnsi( STR0199 ) }) // "Os seguintes roteiros de cálculo ainda não foram integrados:"
		lFirst := .F.
	EndIf
	If (aScan(aLogAux, {|x| x[01]+x[02] == (cAliasQRY)->RY_CALCULO + (cAliasQRY)->RY_DESC })) == 0
		aAdd(aLogAux, {(cAliasQRY)->RY_CALCULO , (cAliasQRY)->RY_DESC})
		cMsgLog += (cAliasQRY)->RY_CALCULO + " - " + (cAliasQRY)->RY_DESC + CRLF
		aAdd(aLogErros, {(cAliasQRY)->RY_CALCULO , (cAliasQRY)->RY_DESC})
	EndIf
	(cAliasQRY)->(DbSkip())
EndDo

(cAliasQRY)->(dbCloseArea())

If !Empty( cMsgLog )
	cMsgLog += STR0200 + CRLF // "Antes de prosseguir, é recomendada a verificação dos cálculos e"
	cMsgLog += STR0201 + CRLF // "solicitações dos benefícios já realizados para a competência de"
	cMsgLog += STR0202 + CRLF // "cálculo da rescisão."
	cMsgLog += STR0203 + CRLF // "Se necessário, efetue a manutenção dessas informações para não"
	cMsgLog += STR0204 + CRLF // "ocasionar pedidos de benefícios indevidos para este funcionário."
	cMsgLog += STR0205 // "Deseja continuar ?"
	aAdd(aLogErros, { OemToAnsi( STR0206 ) }) // "É recomendada a verificação dos cálculos e solicitações dos benefícios já realizados para a competência de cálculo da rescisão."
	aAdd(aLogErros, { OemToAnsi( STR0207 ) }) // "Se necessário, efetue a manutenção dessas informações para não ocasionar pedidos de benefícios indevidos para este funcionário."
EndIf

If lMsg .And. !Empty( cMsgLog ) .And. !IsBlind()
	lRet := MsgNoYes( OemToAnsi( cMsgLog ) , OemToAnsi( STR0020 ) ) // Atenção
EndIf

RestArea(aRCH)
RestArea(aArea)

Return lRet

/*/{Protheus.doc} GravaRGB
Grava verba na RGB de acordo com as informações da SRR
@author cicero.pereira
@since 09/04/2018
@param oGrid, object, Grid com as verbas da SRR
@param nLine, numeric, Número da linha no grid
/*/
Static Function GravaRGB(oGrid, nLine)

	Local cChave := ""

	oGrid:GoLine(nLine)

	// RGB_FILIAL + RGB_PROCES + RGB_MAT + RGB_PERIOD + RGB_SEMANA + RGB_PD + RGB_SEQ

	cChave := SRA->(RA_FILIAL + RA_PROCES + RA_MAT) + cPeriodo + oGrid:GetValue("RR_SEMANA") + oGrid:GetValue("RR_PD")
	DbSelectArea("RGB")
	DbSetOrder(3)

	// Só grava se não encontrar a verba na RGB
	If ! DbSeek(cChave)
		RecLock("RGB", .T.)
			RGB -> RGB_FILIAL := SRA->RA_FILIAL
			RGB -> RGB_MAT 	  := SRA->RA_MAT
			RGB -> RGB_PD 	  := oGrid:GetValue("RR_PD")
			RGB -> RGB_TIPO1  := oGrid:GetValue("RR_TIPO1")
			RGB -> RGB_HORAS  := oGrid:GetValue("RR_HORAS")
			RGB -> RGB_VALOR  := oGrid:GetValue("RR_VALOR")
			RGB -> RGB_TIPO2  := oGrid:GetValue("RR_TIPO2")
			RGB -> RGB_DTREF  := oGrid:GetValue("RR_DATAPAG")
			RGB -> RGB_PROCES := SRA->RA_PROCES
			RGB -> RGB_PERIOD := cPeriodo
			RGB -> RGB_ROTEIR := "FOL" // lançamento sempre na folha
			RGB -> RGB_SEMANA := oGrid:GetValue("RR_SEMANA")
			RGB -> RGB_CC  	  := SRA->RA_CC
			RGB -> RGB_ITEM   := oGrid:GetValue("RR_ITEM")
			RGB -> RGB_CLVL   := oGrid:GetValue("RR_CLVL")
		MsUnlock()
	EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fObitoWhen
Função usada no X3_WHEN do campo RG_OBITO para que fique abilitado
apenas quando motivo de desligamento for igual a 10 - RESCISÃO POR
FALECIMENTO DO EMPREGADO
@author  Rafael Reis
@since   26/09/18
@version 1
/*/
//-------------------------------------------------------------------
Function fObitoWhen()
Local lRet	:= .F.
Local nPos	:= 0
Local cTipo	:= ""

If !Empty(M->RG_TIPORES)
	If ( nPos := fPosTab("S043", M->RG_TIPORES , "=", 4 )) > 0
		cTipo := fTabela("S043", nPos, 26)
		If ValType(cTipo) == "C"
			lRet := Alltrim(cTipo) $ 'A'
		EndIf
	EndIf
Endif
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fObtVld
Função responsável por validar preenchimento do campo RG_OBITO de acordo
com padrão de certidões estabelecido para Registro Civil das Pessoas
Naturais
@author  Rafael Reis
@since   26/09/18
@version 1
/*/
//-------------------------------------------------------------------
Function fObtVld()
Local lRet := .T.
If !Empty(M->RG_OBITO)
	If !Len(M->RG_OBITO) == 32 .OR. !SubStr( M->RG_OBITO ,15, 1) $ '4/7'
		lRet := .F.
		Help(NIL, NIL, OemToAnsi(STR0020) , NIL, "Formato de Certidão de Óbito inválido.", 1, 0, NIL, NIL, NIL, NIL, NIL, {"Informe a Certidão de acordo com o Padrão estabelecido para Registro Civil das Pessoas Naturais."})
	Endif
Endif
Return lRet
/*/{Protheus.doc} fPVarSuces
Função responsável por alterar a picture do campo RG_SUCES
Este campo pode ser preenchido com um CNPJ ou um CPF.
@author  Claudinei Soares
@since   10/12/2018
@version 1
/*/

Function fPVarSuces()

Local cPict := ""

If SRG->(ColumnPos( 'RG_TPSU' ) ) > 0
	If M->RG_TPSU == "2"
		cPict := "@R 999.999.999-99"
	Else
		cPict := "@R 99.999.999/9999-99"
	Endif
Else
	cPict := "@R 99.999.999/9999-99"
Endif

cPict := cPict + "%C"

Return cPict

//-------------------------------------------------------------------
/*/{Protheus.doc} fAlertJob
Função para exibição de alerta e link para o TDN com orientação sobre
envio de afastamentos
@author  Rafael Reis
@since   26/10/2018
@version 1
/*/
//-------------------------------------------------------------------
Static Function fAlertJob()
Local oButton1
Local oButton2
Local oCheckBo1
Local lCheckBo1 := .F.
Local oGroup1
Local oPanel1
Local oSay1
Local cSession	:= "AlertaComplementar"
Local lChkMsg := fwGetProfString(cSession,"MSG_JOBCOMPL_" + cUserName,'',.T.) == ""
Static oDlg

If lChkMsg

	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0241) FROM 000, 000  TO 200, 500 COLORS 0, 16777215 PIXEL //#STR0241 = "Rescisão Complementar"

		@ 000, 000 MSPANEL oPanel1 SIZE 300, 150 OF oDlg COLORS 0, 16777215 RAISED
		@ 005, 012 GROUP oGroup1 TO 055, 237 PROMPT OemToAnsi(STR0020) OF oPanel1 COLOR 0, 16777215 PIXEL //#STR0020 = "Atenção"
		@ 022, 017 SAY oSay1 PROMPT OemToAnsi(STR0242) SIZE 215, 025 OF oPanel1 COLORS 0, 16777215 PIXEL //#STR0242 = 'Foi criada a opção Retificação, que irá retificar os eventos S-2299/S-2399 do eSocial. Clique em "Abrir Link" para consultar a documentação no TDN'
		@ 080, 012 CHECKBOX oCheckBo1 VAR lCheckBo1 PROMPT OEMToAnsi(STR0243) SIZE 067, 008 OF oPanel1 COLORS 0, 16777215 PIXEL //#STR0243 = "Não exibir novamente"
		@ 070, 160 BUTTON oButton1 PROMPT "Abrir Link" SIZE 037, 012 OF oPanel1 PIXEL
		@ 070, 200 BUTTON oButton2 PROMPT "OK" SIZE 037, 012 OF oPanel1 PIXEL

		oButton1:bLClicked := {|| ShellExecute("open","http://tdn.totvs.com/x/ewCmGg","","",1) }
		oButton2:bLClicked := {|| oDlg:End() }

	ACTIVATE MSDIALOG oDlg CENTERED

	If lCheckBo1
		fwWriteProfString(cSession,"MSG_JOBCOMPL_" + cUserName, 'CHECKED', .T.)
	Endif

Endif

Return

/*/{Protheus.doc} fExisTitRe
//Verifica se existe titulo para a rescisão
@author paulo.inzonha
@since 22/01/2019
@version 1.0
@return Logico, Retorna .T. se encontrou o titulo e .F. se não encontrou
@type function
/*/
Function fExisTitRe()
Local lRet 		:= .F.
Local cCtrlTit	:= ""
Local nIndex	:= 0

DEFAULT lCtrlTit		:= ChkFile("RJ1") .And. !Empty(GetNewPar("MV_BTITRES", "" )) .And. RJ1->(ColumnPos( "RJ1_ROTEIR")) > 0 .And. RJ1->(ColumnPos( "RJ1_PROCES")) > 0 .And. RJ1->(ColumnPos( "RJ1_TIPO")) > 0

// Possui dados atualizados para Integ. Títulos por Roteiros de Cálculo completo (RES/FER/ADI/FOL)
If lCtrlTit
	// Utiliza conteúdo do parâmetro MV_BTITRES (variavel cCtrlTit)
	// 0 - Não realiza tratamento
	// 1 - Exibe mensagem para o usuário mas não bloqueia, usuário escolhe prosseguir ou não - gera log com Títulos
	// 2 - Exibe mensagem para o usuário e bloqueia - gera log com Títulos
	cCtrlTit 	:= SuperGetMv("MV_BTITRES",,"0")
	If cCtrlTit == "0"
		lRet := .F.
	ElseIf cCtrlTit == "1"
		If TCCanOpen(RetSqlname("RJ1")) .and. Retorder("RJ1","RJ1_FILIAL+RJ1_PROCES+RJ1_ROTEIR+RJ1_PERIOD+RJ1_SEMANA+DTOS(RJ1_DTGERA)+RJ1_FILFUN+RJ1_MAT") > 0

			nIndex	:= Retorder("RJ1","RJ1_FILIAL+RJ1_PROCES+RJ1_ROTEIR+RJ1_PERIOD+RJ1_SEMANA+DTOS(RJ1_DTGERA)+RJ1_FILFUN+RJ1_MAT")

			dbSelectArea("RJ1")
			RJ1->(dbSetOrder(nIndex)) // RJ1_FILIAL+ RJ1_PROCES+RJ1_ROTEIR+RJ1_PERIOD+RJ1_SEMANA+DTOS(RJ1_DTGERA)+RJ1_FILFUN+RJ1_MAT
			If RJ1->(dbSeek(SRG->RG_FILIAL+SRG->RG_PROCES+SRG->RG_ROTEIR+SRG->RG_PERIODO+SRG->RG_SEMANA+DTOS(SRG->RG_DTGERAR)+SRG->RG_FILIAL+SRG->RG_MAT))
				aAdd( aLogErros, OemToAnsi(STR0289) + OemToAnsi(STR0285) ) // "Existe Título(s) gerado(s) sobre essa rescisão"###"Consulte o(s) Título(s) abaixo em Manutenção de Títulos:"
				While RJ1->(!Eof()) .And. (	RJ1->RJ1_FILIAL+RJ1->RJ1_PROCES+RJ1->RJ1_ROTEIR+RJ1->RJ1_PERIOD+RJ1->RJ1_SEMANA+DTOS(RJ1->RJ1_DTGERA)+RJ1->RJ1_FILFUN+RJ1->RJ1_MAT == SRG->RG_FILIAL+SRG->RG_PROCES+SRG->RG_ROTEIR+SRG->RG_PERIODO+SRG->RG_SEMANA+DTOS(SRG->RG_DTGERAR)+SRG->RG_FILIAL+SRG->RG_MAT )
					aAdd( aLogErros, OemToAnsi(STR0078) + RJ1->RJ1_FILIAL + " " + OemToAnsi(STR0287) + RJ1->RJ1_NUMTIT ) // Filial:###Número do Título:
					("RJ1")->(DbSkip())
				EndDo

				lRet := !MsgNoYes(OemToAnsi(STR0289) + OemToAnsi(STR0245),OemToAnsi(STR0020)) //"Existe Título(s) gerado(s) sobre essa rescisão. A Exclusão ou Recálculo da Rescisão sem a exclusão do título anterior pode gerar duplicidade de titulos. Deseja Continuar?"                                                                                                                                                                                                                                                                                                                                                                                      "

			EndIf
			RJ1->(dbCloseArea())
		EndIf
	ElseIf cCtrlTit == "2"
		If TCCanOpen(RetSqlname("RJ1")) .and. !Empty(RJ1->(INDEXKEY(3)))
			dbSelectArea("RJ1")
			RJ1->(dbSetOrder(3)) // RJ1_FILIAL+ RJ1_PROCES+RJ1_ROTEIR+RJ1_PERIOD+RJ1_SEMANA+DTOS(RJ1_DTGERA)+RJ1_FILFUN+RJ1_MAT
			If RJ1->(dbSeek(SRG->RG_FILIAL+SRG->RG_PROCES+SRG->RG_ROTEIR+SRG->RG_PERIODO+SRG->RG_SEMANA+DTOS(SRG->RG_DTGERAR)+SRG->RG_FILIAL+SRG->RG_MAT))
				aAdd( aLogErros, OemToAnsi(STR0289) + OemToAnsi(STR0285) ) // "Existe Título(s) gerado(s) sobre essa rescisão"###"Consulte o(s) Título(s) abaixo em Manutenção de Títulos:"
				While RJ1->(!Eof()) .And. (	RJ1->RJ1_FILIAL+RJ1->RJ1_PROCES+RJ1->RJ1_ROTEIR+RJ1->RJ1_PERIOD+RJ1->RJ1_SEMANA+DTOS(RJ1->RJ1_DTGERA)+RJ1->RJ1_FILFUN+RJ1->RJ1_MAT == SRG->RG_FILIAL+SRG->RG_PROCES+SRG->RG_ROTEIR+SRG->RG_PERIODO+SRG->RG_SEMANA+DTOS(SRG->RG_DTGERAR)+SRG->RG_FILIAL+SRG->RG_MAT )
					aAdd( aLogErros, OemToAnsi(STR0078) + RJ1->RJ1_FILIAL + " " + OemToAnsi(STR0287) + RJ1->RJ1_NUMTIT ) // Filial:###Número do Título:
					("RJ1")->(DbSkip())
				EndDo

				lRet := .T.
			EndIf
			RJ1->(dbCloseArea())
		EndIf

	EndIf
Else
	If TCCanOpen(RetSqlname("RJ1"))
		dbSelectArea("RJ1")
		RJ1->(dbSetOrder(2))
		If RJ1->(dbSeek(SRG->RG_FILIAL+SRG->RG_MAT+SRG->RG_PERIODO+SRG->RG_SEMANA+DTOS(SRG->RG_DTGERAR)))
			lRet := !MsgNoYes(OemToAnsi(STR0244) + RJ1->RJ1_NUMTIT  +  OemToAnsi(STR0245),OemToAnsi(STR0020)) //"Existe um Titulo gerado para essa rescisão: XXXX. ". A Exclusão ou Recálculo da rescisão sem a exclusão do titulo anterior pode gerar duplicidade de titulos. Deseja Continuar?"                                                                                                                                                                                                                                                                                                                                                                                      "
		EndIf
		RJ1->(dbCloseArea())
	EndIf
EndIf

Return lRet

/*/{Protheus.doc} GPM040VLD
Classe de evento do MVC - Validação do Cálculo de Rescisão.

@author  Leandro Drumond
@since   05/04/2019
@type    Class
@version 12.1.17
/*/
//-------------------------------------------------------------------------------------------------------------
Class GPM040VLD FROM FWModelEvent

	Data lRet
	Method new()
	Method ModelPosVld()
	Method DeActivate()

End Class

Method new() Class GPM040VLD

Return

Method DeActivate() Class GPM040VLD
	If Type("cFilOld") != "U" //qdo vem da carga inicial do eai
		cFilAnt := cFilOld

		If !lTCFA040 .and. lAtuBrowse
			oBrowseUp:Refresh()
			oBrowseDwn:Refresh()
		EndIf
	EndIf
	fDelTMPMED()
Return

Method ModelPosVld(oModel, cModelId) Class GPM040VLD
	lRet:= fTudoOKM40(oModel)
Return lRet


/*/{Protheus.doc} fBuscaRHH()
Função responsável por verificar se o funcionário possui dissídio retroativo calculado
@type function
@author Claudinei Soares
@since 06/05/2019
@version 1.0
@param cFilRHH 		= Filial a ser pesquisada na tabela RHH
@param cMatRHH 		= Matrícula a ser pesquisada na tabela RHH
@param cPerRHH 		= Período do cálculo da rescisão
@return lRet, Lógico, Retorno da função, se verdadeiro o funcionário possui dissídio calulado
/*/

Function fBuscaRHH(cFilRHH, cMatRHH, cPerRHH)

Local lRet	:= .F.
Local aArea	:= GetArea()

dbSelectArea("RHH")
RHH->( dbSetOrder(1) )

If RHH->( dbSeek( xFilial("RHH", cFilRHH) + cMatRHH + cPerRHH ) )
	lRet := .T.
Endif

RestArea(aArea)

Return lRet

/*/{Protheus.doc} RescAntView
Monta browse para visualização das rescisões complementares anteriores

@author  Leandro Drumond
@since   09/09/2019
@type    function
@version 1.0
/*/
Function RescAntView()

Local aRescAnt := {}
Local aArea	   := GetArea()
Local aAreaSRG := SRG->(GetArea())
Local aAreaSRR := SRR->(GetArea())
Local aAreaSRA := SRA->(GetArea())
Local cTpResc  := ""
Local dDataGer := CtoD("")

DbSelectArea("SRR")
DbSetOrder(1) //RR_FILIAL+RR_MAT+RR_TIPO3+DTOS(RR_DATA)+RR_PD+RR_CC

dbSelectArea( "SRG" )
DbSetOrder(1) //RG_FILIAL+RG_MAT+DTOS(RG_DTGERAR)

dbSeek(SRA->RA_FILIAL+SRA->RA_MAT)
While SRG->( !Eof() .And. RG_FILIAL+RG_MAT == SRA->RA_FILIAL+SRA->RA_MAT )
	cTpResc := STR0254 //"Normal"
	If SRG->RG_RESCDIS == "3"
		cTpResc := STR0255 //"Retificadora"
	ElseIf SRG->RG_RESCDIS == "2"
		cTpResc := STR0256 //"Dissídio"
	ElseIf SRG->RG_RESCDIS == "1"
		If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[151,1])) //Verifica se foi pago PLR
			cTpResc := STR0257 //"PLR"
		Else
			cTpResc := STR0116 //"Complementar"
		EndIf
	EndIf
	aAdd(aRescAnt, { SRG->RG_DATADEM, SRG->RG_DTGERAR, SRG->RG_DATAHOM, cTpResc })
	SRG->(dbSkip())
EndDo

Begin Sequence

	If Len(aRescAnt) > 1
		If !fSeleResc(aRescAnt,@dDataGer)
			Break
		EndIf
	ElseIf Len(aRescAnt) == 1
		dDataGer := aRescAnt[1,2]
	EndIf

	If !Empty(dDataGer)
		SRG->(dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+DTOS(dDataGer)))
		FWExecView("", "GPEM040", MODEL_OPERATION_VIEW,,{||.T.},,50)
	EndIf

End Sequence

RestArea(aAreaSRG)
RestArea(aAreaSRR)
RestArea(aAreaSRA)
RestArea(aArea)

Return Nil

/*/{Protheus.doc} fSeleResc
Monta browse para seleção das rescisões complementares anteriores

@author  Leandro Drumond
@since   09/09/2019
@type    function
@version 1.0
/*/
Static Function fSeleResc(aLbxF,dDataGera)
Local aObjCoords	:= {}
Local aAdvSize		:= {}
Local aObjSize		:= {}
Local aInfoAdvSize	:= {}
Local lOK      		:= .F.
Local nPosLbxF		:= 0
Local oDlg
Local oLbxF

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Monta as Dimensoes dos Objetos         					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aAdvSize	:= MsAdvSize(,.T.,180)
aInfoAdvSize:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
aAdd( aObjCoords , { 000 , 000 , .T. , .T. , .T. } )
aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

oDlg := MSDialog():New(aAdvSize[7],0,aAdvSize[6]*0.9,aAdvSize[5],STR0258,,,,,,,,,.T.) //"Selecione a Rescisão"

	@ aObjSize[1,1]-20 , aObjSize[1,2] LISTBOX oLbxF FIELDS HEADER 	OemToAnsi(GetSx3Cache("RG_DATADEM","X3_TITULO")),; 	//"Data de Demissão"
																	OemToAnsi(GetSx3Cache("RG_DTGERAR","X3_TITULO")),;  //"Data de Geração"
																	OemToAnsi(GetSx3Cache("RG_DATAHOM","X3_TITULO")),;  //"Data de Homologação"
																	OemToAnsi(GetSx3Cache("RG_RESCDIS","X3_TITULO"));   //"Tipo de Rescisão"
													 FIELDSIZES 45,45,45,45;
													 SIZE aObjSize[1,3] , aObjSize[1,4]*0.7;
										OF oDlg PIXEL ON DBLCLICK ( lOk := .T., nPosLbxF:=oLbxF:nAt,oDlg:End() )

	oLbxF:SetArray(aLbxF)
	oLbxF:bLine := { || {aLbxF[oLbxF:nAt,1],aLbxF[oLbxF:nAt,2],aLbxF[oLbxF:nAt,3],aLbxF[oLbxF:nAt,4]}}

	TButton():New( aObjSize[1,4]*0.9, aObjSize[1,3]*0.87, STR0259, oDlg, {|| lOk := .T.,nPosLbxF:=oLbxF:nAt, oDlg:End()},aObjSize[1,3] - (aObjSize[1,3]*0.87),20,,,,.T.) //"Abrir"

oDlg:Activate()

If lOk
	dDataGera := aLbxF[nPosLbxF,2]
EndIf

Return( lOk )

/*/{Protheus.doc} fDelHist
/Delete historico de medias
@author flavio.scorrea
@since 23/10/2019
/*/
Static Function fDelHist(lDel, oView)
Local lHistMed		:= AliasInDic("RJK") .And. AliasInDic("SRP")

If (lDel .Or. (oView:GetModel():nOperation != 1 .And. oView:GetModel():nOperation != 5) )
	If lHistMed .And. Empty(cIdHistMed)
		If fTemHMed(M->RG_DTGERAR,,M->RG_PERIODO,M->RG_SEMANA,M->RG_ROTEIR)
			cIdHistMed := RJK->RJK_ID
		Endif
	EndIf
	If lHistMed .And. !Empty(cIdHistMed)
		fDelHMedId(cIdHistMed)
	EndIf
EndIf

Return

/*/{Protheus.doc} fVldSabDom
/Atualiza variável lSabDom
@author Leandro Drumond
@since 12/11/2019
/*/
Function fVldSabDom()

Local oModel := FWModelActive()
Local cVar 	 := oModel:GetValue("GPEM040_MSRG","RG_SABDOM")

lSabDom := cVar == "1"

Return .T.

/*/
 {Protheus.doc} fSRetDes
Função responsavel por retornar a descrição do tipo de rescisão.

@type		Function
@author		Silvio César Stecca
@since		19/02/2020
@version	12
@param
@return 	cDescResc, Caracter, Retorno da função, retorna a descrição do tipo de rescisão.
/*/
Function fSRetDes()

	Local cDescResc := ""
	Local oModel	:= FWModelActive()
	Local cTpResc	:= Iif(Empty(oModel:GetValue("GPEM040_MSRG", "RG_RESCDIS")), "0", oModel:GetValue("GPEM040_MSRG", "RG_RESCDIS"))

	Do Case
		Case cTpResc == '0'
			cDescResc := OemToAnsi(STR0254) // "Normal"

		Case cTpResc == '1'
			cDescResc := OemToAnsi(STR0116) // "Complementar"

		Case cTpResc == '2'
			cDescResc := OemToAnsi(STR0118) // "Complementar por Dissidio"

		OtherWise
			cDescResc := OemToAnsi(STR0240) // "Retificação"
	EndCase

Return cDescResc

/*/{Protheus.doc} fTemIdResc
Verifica se na rescisao original tem novos id's de adicionais
@since 09/04/2020
/*/
Static Function fTemIdResc( cFilMat  , aSrgRecnos )

Local aArea		:= GetArea()
Local dDataGer	:= Ctod("//")
Local nVezes	:= Len( aSrgRecnos )
Local nV		:= 1
//Novos adicionais rescisão.
Local cIdsADI   := aCodFol[1680,1] + "/" + aCodFol[1681,1] + "/" + aCodFol[1682,1] + "/" + aCodFol[1683,1] + "/" + aCodFol[1684,1] + "/" +;
					   aCodFol[1685,1] + "/" + aCodFol[1686,1] + "/" + aCodFol[1687,1] + "/" + aCodFol[1688,1] + "/" + aCodFol[1689,1] + "/" +;
					   aCodFol[1690,1] + "/" + aCodFol[1691,1] + "/" + aCodFol[1692,1] + "/" + aCodFol[1693,1] + "/" + aCodFol[1694,1] + "/" +;
					   aCodFol[1695,1] + "/" + aCodFol[1696,1] + "/" + aCodFol[1697,1] + "/" + aCodFol[1698,1] + "/" + aCodFol[1699,1] + "/" +;
					   aCodFol[1700,1] + "/" + aCodFol[1701,1] + "/" + aCodFol[1702,1] + "/" + aCodFol[1703,1] + "/" + aCodFol[1704,1] + "/" +;
					   aCodFol[1705,1] + "/" + aCodFol[1706,1] + "/" + aCodFol[1707,1] + "/" + aCodFol[1708,1] + "/" + aCodFol[1709,1] + "/" +;
					   aCodFol[1710,1] + "/" + aCodFol[1711,1] + "/" + aCodFol[1712,1] + "/" + aCodFol[1713,1] + "/" + aCodFol[1714,1] + "/" +;
					   aCodFol[1715,1] + "/" + aCodFol[1716,1] + "/" + aCodFol[1717,1] + "/" + aCodFol[1718,1] + "/" + aCodFol[1719,1] + "/" +;
					   aCodFol[1720,1] + "/" + aCodFol[1721,1]

LTEMIDRESC 	:= .F.

SRR->(DbSetOrder(3))

For nV := 1 To nVezes
	dDataGer	:= aSrgRecnos[ nV , 02 ]
	If SRR->( dbSeek( cFilMat + "R" + Dtos( dDataGer ) ) )
		While SRR->( !Eof() .and. RR_FILIAL + RR_MAT + RR_TIPO3 + Dtos( RR_DATA ) == cFilMat + "R" + Dtos( dDataGer ) )
			If SRR->RR_PD $ cIdsADI
				LTEMIDRESC := .T.
				exit
			EndIf
			SRR->( dbSkip() )
		EndDo
	EndIf
Next nV

RestaRea(aArea)
Return

/*/{Protheus.doc} fUpdAtBrw
Atualiza o conteúdo da variável static lAtuBrowse
@since 14/05/2020
/*/
Function fUpdAtBrw( lCont )

lAtuBrowse := lCont

Return

/*/{Protheus.doc} fCtrTitLg
Imprime log com títulos existentes do funcionário (quando existe controle de títulos na base MV_BTITRES igual a 1 ou 2)
@author		raquel.anrade
@since		04/08/2020
@version 1.0
/*/
Static Function fCtrTitLg()
Local aLog			:= {}
Local aTitleLog		:= {}
Local nX			:= 0
Local nPosLog		:= 0
Local lRet			:= .T.

lCtrlTit		:= ChkFile("RJ1") .And. !Empty(GetNewPar("MV_BTITRES", "" )) .And. RJ1->(ColumnPos( "RJ1_ROTEIR")) > 0 .And. RJ1->(ColumnPos( "RJ1_PROCES")) > 0 .And. RJ1->(ColumnPos( "RJ1_TIPO")) > 0

If lCtrlTit .And. Len( aLogErros ) > 0
	If Empty( aLog )
		aAdd( aTitleLog, STR0058 )	//"Log de Ocorrencias do Calculo de Rescisao"
		aAdd( aLog, {} )
	EndIf

	nPosLog := Len( aLog )
	For nX := 1 To Len( aLogErros )
		aAdd( aLog[ nPosLog ], aLogErros[ nX ] )
	Next nX

	If !IsBlind()
		MsAguarde( { || fMakeLog( aLog , aTitleLog , "GPEM040" , NIL , FunName() , STR0058 ) } ,  STR0058 ) //"Log de Ocorrencias do Cálculo de Rescisao"
		aLog		:= {}
		aLogErros	:= {}
	EndIf
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fAlert936
Função para exibição de alerta e link para o TDN com orientação sobre multa da MP 936/2020
@author  allyson.mesashi
@since   24/09/2020
@version 1
/*/
//-------------------------------------------------------------------
Static Function fAlert936( nOpc )
Local oButton1
Local oButton2
Local oCheckBo1
Local lCheckBo1 := .F.
Local oGroup1
Local oPanel1
Local oSay1
Local cSession	:= "Alerta936"
Local cVar		:= ""
Local lChkMsg 	:= fwGetProfString(cSession, "MSG_MULT936_" + cUserName,'',.T.) == ""
Local oDlg

Default nOpc	:= 2

If nOpc == 1
	cVar := "MSG_MULT936A_"
Else
	cVar := "MSG_MULT936B_"
EndIf
lChkMsg 	:= fwGetProfString(cSession, cVar + cUserName,'',.T.) == ""

If lChkMsg

	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0291) FROM 000, 000  TO 200, 500 COLORS 0, 16777215 PIXEL //#STR0291 = "Rescisão com estabilidade da MP 936/2020"

		@ 000, 000 MSPANEL oPanel1 SIZE 300, 150 OF oDlg COLORS 0, 16777215 RAISED
		@ 005, 012 GROUP oGroup1 TO 055, 237 PROMPT OemToAnsi(STR0020) OF oPanel1 COLOR 0, 16777215 PIXEL //#STR0020 = "Atenção"
		If nOpc == 1
			@ 022, 017 SAY oSay1 PROMPT OemToAnsi(STR0292) SIZE 215, 025 OF oPanel1 COLORS 0, 16777215 PIXEL //#STR0292 = 'É necessário possuir o campo RG_DTESTAB no dicionário de dados e cadastro de verba para o Id de cálculo 1853. Clique em "Abrir Link" para consultar a documentação no TDN'
		Else
			@ 022, 017 SAY oSay1 PROMPT OemToAnsi(STR0293) SIZE 215, 025 OF oPanel1 COLORS 0, 16777215 PIXEL //#STR0293 = 'Clique em "Abrir Link" para consultar a documentação no TDN com a explicação dos cálculos realizados pelo sistema'
		EndIf
		@ 080, 012 CHECKBOX oCheckBo1 VAR lCheckBo1 PROMPT OEMToAnsi(STR0243) SIZE 067, 008 OF oPanel1 COLORS 0, 16777215 PIXEL //#STR0243 = "Não exibir novamente"
		@ 070, 160 BUTTON oButton1 PROMPT "Abrir Link" SIZE 037, 012 OF oPanel1 PIXEL
		@ 070, 200 BUTTON oButton2 PROMPT "OK" SIZE 037, 012 OF oPanel1 PIXEL

		oButton1:bLClicked := {|| ShellExecute("open","https://tdn.totvs.com/x/uVmVIQ","","",1) }
		oButton2:bLClicked := {|| oDlg:End() }

	ACTIVATE MSDIALOG oDlg CENTERED

	If lCheckBo1
		fwWriteProfString(cSession, cVar + cUserName, 'CHECKED', .T.)
	Endif

Endif

Return

/*/{Protheus.doc} fDelRAZRAW
Função para excluir os registros gerados na RAZ/RAW quando funcionário possui multiplos vínculos
@author  Leandro Drumond
@since   21/09/2021
@version 1
/*/
Static Function fDelRAZRAW()

dbSelectArea("RAW")
RAW->(dbSetOrder(1))//RAW_FILIAL, RAW_MAT, RAW_FOLMES, RAW_TPFOL, RAW_PROCES, RAW_ROTEIR, RAW_SEMANA

If DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + "1" + SRA->RA_PROCES + fGetCalcRot("4"))
	RecLock("RAW",.F.)
	DbDelete()
	MsUnLock()
	
	dbSelectArea("RAZ")
	RAZ->(DbSetOrder(1))//RAZ_FILIAL+RAZ_MAT+RAZ_FOLMES+RAZ_TPFOL+RAZ_INSCR

	If DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + "1")
		RecLock("RAZ",.F.)
		DbDelete()
		MsUnLock()
	EndIf
EndIf

Return Nil

/*/{Protheus.doc} fBusSRKDis
Função para verificar se o funcionário possui lançamentos não quitados de dissídio retroativo calculado em período anterior
@author  Julio Silva
@since   04/11/2021
@version 1
/*/

Static Function fBusSRKDis()

	Local aArea := getArea()
	Local lRet := .F.

	DbSelectArea("SRK")
	SRK->( dbSetOrder(1) )
	If SRK->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT ) )
		While SRK->( !EoF() .And. SRK->RK_FILIAL+SRK->RK_MAT == SRA->RA_FILIAL+SRA->RA_MAT  )	
			If !Empty(SRK->RK_NUMID) .And. !Empty(SRK->RK_MESDISS) .And. SRK->RK_STATUS == "2"
				If fBuscaRHH(SRA->RA_FILIAL, SRA->RA_MAT,  SRK->RK_PERINI+SubStr(SRK->RK_MESDISS,3)+SubStr(SRK->RK_MESDISS,1,2))
					lRet := .T.
					Exit
				EndIf
			EndIf	
			SRK->( dbSkip() )
		EndDo
	EndIf

	RestaRea(aArea)
	
Return lRet

/*/{Protheus.doc} fRescToRJP
Processo para enviar os dados para integração (NG - Quirons) Tabela RJP.
@since	02/12/2021
@autor	martins.marcio
@version 1.0
/*/
Function fRescToRJP(cOperacao)

Local aArea		:= GetArea()
Local dDtBase   := dDataBase
Local cHoraAt   := Time()
Local cTmpEmp   := cEmpAnt
Local cProces   := "SRA"
Local cUserId   := SubStr(cUsuario,7,15)
Local cTmpMat   := SRA->RA_MAT
Local cTmpFil   := xFilial ("SRA")
Local cChave    := cTmpEmp + "|" + cTmpFil + "|" + cTmpMat

fSetInforRJP(cTmpFil, cTmpMat, cProces, cChave, cOperacao, dDtBase, cHoraAt, cUserId )

RestArea(aArea)

Return (.T.)

/*/{Protheus.doc} fGetPergunte
Preenche o mnemonico aPergunte com os dados da consulta de beneficios
@since	22/08/2022
@autor	Leandro Drumond
@version 1.0
/*/
Static Function fGetPergunte(aPergunte,cPerg)

Local oSX1  := FWSX1Util():New()

If lPergBenef
	MsgInfo(STR0308) //"Serão recalculados os beneficios para desconto conforme parametrização do tipo de rescisão e do mnemônico P_DESCBEN."
	lPergBenef := .F.
EndIf

Pergunte(cPerg, .T.)

oSX1:AddGroup(cPerg)
oSX1:SearchGroup()

aEval(oSX1:aGrupo[1,2],{|x| aAdd(aPergunte, {x:cX1_VAR01, AllTrim(x:cX1_PERGUNT), &(x:cX1_VAR01), x:cX1_TIPO, 10})})

FreeObj(oSX1)

Return Nil

/*/{Protheus.doc} fLogBenef
Log de erro no cálculo de beneficios
@since	22/08/2022
@autor	Leandro Drumond
@version 1.0
/*/
Static Function fLogBenef()
Local aLogInit 		:= {}
Local aTitleLog		:= {}
Local aLog			:= {}
Local nX 			:= 0

cFilCalc 	:= ""
lErrExecRot	:= .T.

//Carregando Informacoes para o Log                                      
aLogInit := LogExecRot()
For nX := 1 To Len( aLogInit )
	If !Empty(aLogInit[ nX, 2 ])
		If nX == 1
			aAdd( aTitleLog, STR0054 ) //"Erro de Carga de Mnemonicos"
		ElseIf nX == 2
			aAdd( aTitleLog, STR0055 ) //"Erro de Carga de Formulas"
		ElseIf nX == 3
		aAdd( aTitleLog, STR0056 ) //"Ocorreu erro na compilacao ou Execucao do Roteiro"
		ElseIf nX == 4
			aAdd( aTitleLog, STR0306 ) //"Erros ocasionados durante o Calculo dos Benefícios"
		EndIf
		aAdd( aLog, aLogInit[nX, 2] )
	EndIf
Next nX

If !Empty( aLog )
	//Mostrar o Log
	MsAguarde( { || fMakeLog( aLog , aTitleLog , "GPEM040" , NIL , FunName() , STR0307 ) } ,  STR0307 ) //"Log de Ocorrencias do Calculo de Benefícios"
EndIf

RstExecCalc()

Return Nil

/*/{Protheus.doc} fCompPLR
Log de erro no cálculo de beneficios
@since	29/08/2022
@autor	Leandro Drumond
/*/
Static Function fCompPLR()

Local aAreaSRR	:= SRR->( GetArea() )
Local lCompPLR	:= .F.

SRR->( dbSetOrder(1) )//RR_FILIAL+RR_MAT+RR_TIPO3+DTOS(RR_DATA)+RR_PD+RR_CC
If SRR->( dbSeek( SRG->RG_FILIAL + SRG->RG_MAT + "R" + dToS(SRG->RG_DTGERAR) + aCodFol[151, 1] ) ) //Verifica se foi pago PLR
	lCompPLR := .T.
EndIf

RestArea( aAreaSRR )

Return lCompPLR


/*/{Protheus.doc} fObtDVacV()
Obtener vacaciones vencidas cuando el empleado está inactivo
@since	26/09/2022
@autor	Laura Medina
@param
@return nDiasVacV, Numerico, Retorna los días de vacaciones vencidas
/*/
Function fObtDVacV()
Local nDiasVacV := 0

//Empleado inactivo (opción INCLUIR)
If  !Empty(SRA->RA_DEMISSA) .And. SRA->RA_SITFOLH == 'D' 
	fVAC_RESM2(@nDiasVacV,1)
ENDIF

Return nDiasVacV
