#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEXREL.CH"

Static lCorpManage	:= fIsCorpManage( FWGrpCompany() )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GPEXREL   ³ Autor ³ *EQUIPE RH ADVANCED*        ³ Data ³28/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ Conjunto de fun‡”es para Impressao de Relatorios                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ Void                                                             ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Gen‚rico                                                         ³
ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³               ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Programador ³ Data     ³ BOPS/FNC ³  Motivo da Alteracao                     ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Carlos E. O.³06/12/2013³M12RH01   ³Inclusao de funcao que retorna JOINs para ³
³            ³          ³184702    ³uma query com base no layout de gestao de ³
³            ³          ³          ³empresas para o grupo de empresas logado. ³
³Luis Artuso ³01/10/2014³TQMKEE    ³Ajuste para nao alterar a variavel 'nTama-³
³            ³          ³	       ³nho' ao executar o 'SetPrint'.   	      ³
³Renan Borges³09/10/2014³TQNUVG    ³Ajuste na impressão de log de ocorrências ³
³            ³          ³	       ³quando a impressão não for em disco.      ³
³Matheus M.  ³04/12/2015³TTTNEJ    ³Ajuste para não gerar erro na query quando³
³            ³          ³	       ³utilizado Gestão Corporativa.		      ³
³Cícero Alves³22/12/2015³TTZE19    ³Ajuste no espaçamento do relatorio, para  ³
³            ³          ³	       ³que nao fique um grande espaço em branco, ³
³            ³          ³	       ³criando uma condição quando for o GPER080,³
³            ³          ³	       ³deixar o relatorio c/ tamanho de 80 linhas³
³Raquel Hager³19/01/2016³TTURXX    ³Ajuste na funcao fGetJOINGestEmp para nao ³
³            ³          ³	       ³gerar conteudo quando encontrar posicoes  ³
³            ³          ³	       ³zeradas.								  ³
³Gabriel A.  ³23/09/2016³TVEQT2    ³Ajuste para não imprimir o cabeçalho e o  ³
³            ³          ³          ³rodapé quando não houver tela, em virtude ³
³            ³          ³          ³da automação de testes.                   ³
³Jônatas A.T.³25/11/2016³191591    ³Retirada condição que verificava uso de   ³
³            ³          ³	       ³gestão corporativa ao montar filtro de qry³
³Flavio C.   ³22/12/2016³          ³Retirada linhas de separação no calculo   ³
³Cícero Alves³10/05/2017³DRHPAG-   ³Ajuste na função RetPergLog para carregar³
³			 ³			³1515	   ³o grupo de perguntas					  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o	   ³fGetJOINGestEmp³ Autor ³ Carlos E. Olivieri   ³ Data ³ 06/12/13 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ Funcao para retornar os Joins entre as tabelas pelo campo      ³
³          ³ _FILIAL, conforme o conceito de gestao de empresas, tomando    ³
³          ³ como base os modos de compartilhamento da 1a tabela.           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>								        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ aPosicoes - Array com quantos caracteres tem cada nivel (empre-³
³          ³             sa, unidade/negocio e filial.                      ³
³          ³ cTabela1 - Tabela onde serao checados os compartilhamentos.    ³
³          ³ cCampo1  - Campo da tabela 1 para o JOIN                       ³      
³          ³ cTabela2 - Tabela relacionada (JOIN)                           ³
³          ³ cCampo2  - Campo da tabela 2 para o JOIN                       ³      
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³Generico													    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/
Function fGetJOINGestEmp (aPosicoes, cTabela1, cCampo1, cTabela2, cCampo2)

	Local nCont
	Local aComps 		:= Array(3)
	Local cGestaoEmp 	:= ""
	Local cNameDB 		:= Upper(TcGetDb())
	Local cSQLCommand 	:= ""
	Local cTab1Access  	:= ""

	Do Case
		Case "MSSQL" $ cNameDB 
			cSQLCommand := "SUBSTRING"
		Otherwise		
			cSQLCommand := "SUBSTR"	
	Endcase	
	
	If lCorpManage
		For nCont := 1 to 3
			aComps[nCont] := FWModeAccess(cTabela1, nCont) //Checa compartilhamentos usados para empresa, unid. negocio, filial
		Next
	
		cGestaoEmp += " AND " + cSQLCommand + "(" + cTabela1 + "." + cCampo1 + ", 1, " + Strzero(aPosicoes[1], 1) + ")" 

		If aComps[1] == "E" //Empresa
			cGestaoEmp += "=" + cSQLCommand + "(" + cTabela2 + "." + cCampo2 + ", 1, " + Strzero(aPosicoes[1], 1) + ")"
		Else
			cGestaoEmp += "='" + Space(aPosicoes[1]) + "'"  				
		Endif
	
		cGestaoEmp += " AND " + cSQLCommand + "(" + cTabela1 + "." + cCampo1 + ", " + Strzero(aPosicoes[1] + 1, 1) + ", " 
		cGestaoEmp += Strzero(aPosicoes[2], 1) + ")"
	
		If aComps[2] == "E" //Unidade Negocio
			cGestaoEmp += "=" + cSQLCommand + "(" + cTabela2 + "." + cCampo2 + ", "
			cGestaoEmp += Strzero(aPosicoes[1] + 1, 1) + ", " + Strzero(aPosicoes[2], 1) + ")"
		Else
			cGestaoEmp += "='" + Space(aPosicoes[2]) + "'"  							
		Endif

		cGestaoEmp += " AND " + cSQLCommand + "(" + cTabela1 + "." + cCampo1 + ", " + Strzero(aPosicoes[1] + aPosicoes[2] + 1, 1) + ", " 
		cGestaoEmp += Strzero(aPosicoes[3], 1) + ")"
	
		If aComps[3] == "E" //Filial
			cGestaoEmp += "=" + cSQLCommand + "(" + cTabela2 + "." + cCampo2 + ", "
			cGestaoEmp += Strzero(aPosicoes[1] + aPosicoes[2] + 1, 1) + ", " + Strzero(aPosicoes[3], 1) + ")"
		Else
			cGestaoEmp += "='" + Space(aPosicoes[3]) + "'"  												
		Endif
	Else
		cTab1Access := FWModeAccess(cTabela1) //Checa compartilhamentos usados para empresa, unid. negocio, filial
		
		If cTab1Access == "E"
			cGestaoEmp += " AND " + cSQLCommand + "(" + cTabela1 + "." + cCampo1 + ", 1, 2 )" 			
			cGestaoEmp += "=" + cSQLCommand + "(" + cTabela2 + "." + cCampo2 + ", 1, 2 )"
		Else
			cGestaoEmp += " AND " + cSQLCommand + "(" + cTabela1 + "." + cCampo1 + ", 1, 2 )" 						
			cGestaoEmp += "='" + Space(2) + "'"
		EndIF
	EndIF

Return cGestaoEmp

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o	   ³Impr	  ³ Autor ³ Equipe de RH		  ³ Data ³16/02/1995³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Controle de Linhas de Impressao, Cabecalho e Rodape	        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function Impr(	cDetalhe	,;	//01 -> Linha Detalhe a ser impressa.
				cFimFolha	,;	//02 -> "F" ou "P" Imprime Rodape e Salta de Pagina. Qualquer outro Ex.: "C" Imprime Detalhe e  Incrementa Li.
				nReg		,;	//03 -> Numero de Registros a Serem Impressos no Rodape.
				cRoda		,;	//04 -> Descritivo a Ser Impresso no Rodape apos nReg.
				nColuna		,;	//05 -> Coluna onde Iniciar Impressao do Detalhe.
				lSalta		,;	//06 -> Se deve ou nao Incrementar o salto de Linha.
				lMvImpSX1	,;	//07 -> Se Deve Considerar o Parametro MV_IMPSX1 ao inves do MV_PERGRH
				bCabec		,;	//08 -> Bloco com a Chamada de Funcao para Cabecalho Especifico
				bRoda		,;	//09 -> Bloco com a Chamada de Funcao para Rodape Especifico
				lQbLinDet	 ;	//10 -> Quebrar a Linha Detalhe caso o texto seja maior que o limite - Padrao .F.
			  )

Local aCabec		:= {}
Local cDetCab		:= ""
Local cWCabec		:= ""
Local lbCabec		:= ( ValType( bCabec ) == "B" )
Local lbRoda        := ( ValType( bRoda  ) == "B" )
Local nCb			:= 0
Local nSpace		:= 0
Local nIniStr		:= 0
Local nTamStr		:= 0
Local nQuebra       := 0

Static cPerg			
Static lPerg
Static nNormal
Static nComp

DEFAULT lMvImpSX1	:= .F.

DEFAULT lPerg  		:= ( GetMvRH( IF( lMvImpSX1 , "MV_IMPSX1" , "MV_PERGRH" ) ) == "S" )
DEFAULT	nNormal		:= GetMvRH("MV_NORM")
DEFAULT nComp		:= GetMvRH("MV_COMP")
DEFAULT cFimFolha	:= ""
DEFAULT cDetalhe	:= ""
DEFAULT nReg		:= 0
DEFAULT nColuna 	:= 0
DEFAULT lSalta		:= .T.
DEFAULT lQbLinDet	:= .F.


wnRel		:= IF( Type("wnRel")	== "U" , IF( Type("NomeProg") != "U" ,  NomeProg , "" ) , wnRel )
wCabec0		:= IF( Type("wCabec0")	== "U" , 0	, wCabec0	)
wCabec1 	:= IF( Type("wCabec1")	== "U" , "" , wCabec1	)
wCabec2 	:= IF( Type("wCabec2")	== "U" , "" , wCabec2	)
nChar		:= IF( Type("nChar")	== "U" , NIL , IF( nChar == 15 , nComp , nNormal ) ) // Quando nao for compactado nChar deve ser Nil para tratamento da Cabec.
ContFl		:= IF( Type("ContFl")   == "U" , 1   , ContFl   )
nTamanho	:= IF( Type("nTamanho") == "U" , "P" , nTamanho )
Li			:= IF( Type("Li")		== "U" , 0   , Li		)
Titulo		:= IF( Type("Titulo")   == "U" , ""  , Titulo   )
aReturn		:= IF( Type("aReturn")  == "U" , {"",1,"",2,1,"","",1} , aReturn )


If cPaisLoc == "BRA" .and. FunName() == "GPER080" 
	nQuebra := 80
Else 
	nQuebra := If (cPaisLoc == "BRA" .and. FunName() == "GPER040", GetMvRH("MV_QBIMPFO",,58), 58 )
EndIf

//O minimo para saltar de pagina e 58 linhas
nQuebra := If( nQuebra > 58, nQuebra, 58 ) 
m_pag		:= ContFl
nSpace		:= IF( nTamanho == "P" , 80 , IF( nTamanho == "G" , 220 , 132 ) )
cFimFolha	:= Upper( AllTrim( cFimFolha ) )

Begin Sequence

	IF (;
			( cFimFolha $ "FP" );
			.or.;
			( Li >= nQuebra );
		)
		IF ( Li != 0 )
			IF (;
					( cFimFolha $ "F" );
					.or.;
					( cRoda != NIL );
				)
				IF !( lbRoda )
					IF (;
							( nReg == 0 );
							.or.;
							( cRoda == NIL );
						)
						If !( IsBlind() )
							Roda( 0 , ""    , nTamanho )
						EndIf
					Else
						Roda( nReg , cRoda , nTamanho )
					EndIF
				Else
					Eval( bRoda )
				EndIF	
			EndIF
			Li := 0
		EndIF
		IF (;
				( cFimFolha == "F" );
				.or.;
				(;
					( cFimFolha == "P" );
					.and.;
					Empty( cDetalhe );
				);
			)
			Break
		EndIF
	EndIF
	
	IF ( Li == 0 )
		IF !( lbCabec )
			IF ( wCabec0 <= 2 )
				If !( IsBlind() )
					Cabec( Titulo , wcabec1 , wcabec2 , wnrel , nTamanho , nChar , NIL , lPerg )
				EndIf
			Else
			    aCabec := SendCab(nSpace)
			    For nCb := 1 To wCabec0
			    	IF ( Type((cWCabec := "wCabec"+Alltrim(Str(nCb)))) != "U" )
				    	cDetCab := &(cWCabec)
				    	nTamStr := Len( &(cWCabec) )
				    	If nTamStr > nSpace .And. lQbLinDet
					    	nIniStr := 0
				    		While nTamStr > 0
						    	cDetCab := SubStr( &(cWCabec), nIniStr , nSpace-1 )
					    		aAdd(aCabec,"__NOTRANSFORM__"+cDetCab)
						    	nIniStr += Len(cDetCab)+1
						    	nTamStr -= nIniStr
						    Enddo				    	
				    	Else
					    	cDetCab += Space(nSpace - Len(cDetCab) -1)
				    		aAdd(aCabec,"__NOTRANSFORM__"+cDetCab)
				    	EndIf
			    	EndIF
			    Next nCb
			  	Cabec( Titulo , "" , "" , wnrel , nTamanho , nChar , aCabec , lPerg )
			EndIF
		Else
			Eval( bCabec )
		EndIF
		ContFl++
	EndIF
	
	IF ( Len( cDetalhe ) == nSpace )
		IF ( Empty(StrTran(cDetalhe,"-","")) .or. Empty(StrTran(cDetalhe,".","")) )
			cDetalhe := __PrtThinLine()
		ElseIF ( Empty(StrTran(cDetalhe,"=","")) .or. Empty(StrTran(cDetalhe,"*","")) )
			cDetalhe := __PrtFatLine()
		EndIF
	EndIF
	
	@ Li , nColuna PSAY cDetalhe
	
	IF(lSalta,Li++,NIL)

End Sequence
	
Return( NIL )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³SendCab   ³ Autor ³ Marinaldo de Jesus    ³ Data ³18/04/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Impressao de Cabecalho                                      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Impr()														³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function SendCab( nLargura )

Local aDetCab := {}
Local cDetCab := ""
Local nEspaco := 0

// Nome da Empresa / Pagina
cDetCab := "__LOGOEMP__"
nEspaco := ( ( nLargura - 2 ) - (Len(cDetCab + STR0011+" "+TransForm(m_pag,'999999'))) )
cDetCab += Space(nEspaco)+STR0011+" "+TransForm(m_pag,'999999')
aAdd(aDetCab,cDetCab)

// Versão / Titulo / Data
cDetCab := ( "SIGA /"+wnrel+"/v."+cVersao+"  " )
nEspaco := Len(cDetCab+STR0013+" "+DTOC(dDataBase))
cDetCab += PADC(Trim(Titulo),(nLargura - 2)-nEspaco)
nEspaco := ( (nLargura - 2) - (Len(cDetCab + STR0013+" "+DTOC(dDataBase))) )
cDetCab += ( STR0013+" "+DTOC(dDataBase) )
aAdd(aDetCab,cDetCab)

// Hora da emissão / Data Emissao
cDetCab := ( STR0012+" "+time() )
nEspaco := ( (nLargura - 2) - Len(cDetCab+STR0014+" "+DToC(MsDate())) )
cDetCab += Space(nEspaco)+STR0014+" "+DToC(MsDate())
aAdd(aDetCab,cDetCab)

aAdd(aDetCab,"__FATLINE__")

Return(aDetCab)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o	   ³LEDriver  ³ Autor ³ Tecnologia 		      ³ Data ³16/02/1995³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Controlar o Tipo de Impressora e Impressao				    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³LEDriver(Void)												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³Acionada pela Funcao Impr									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function LEDriver()

Local aSettings := {}
Local cStr
Local cLine
Local i

if !File( __DRIVER )
	aSettings := { "CHR(15)" , "CHR(18)" , "CHR(15)" , "CHR(18)" , "CHR(15)" , "CHR(15)" }
Else
	cStr := MemoRead(__DRIVER)
	For i := 2 To 7
		cLine := AllTrim( MemoLine( cStr , 254 , i ) )
		aAdd( aSettings , SubStr( cLine , 7 ) )
	Next
Endif

Return( aSettings )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fMakeLog  ³ Autor ³ Marinaldo de Jesus    ³ Data ³18/04/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gerar o Arquivo em Disco com os Logs das Ocorrencias        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function fMakeLog(	aLogFile 	,;	//Array que contem os Detalhes de Ocorrencia de Log
					aLogTitle	,;	//Array que contem os Titulos de Acordo com as Ocorrencias
					cPerg		,;	//Pergunte a Ser Listado
					lShowLog	,;	//Se Havera "Display" de Tela
					cLogName	,;	//Nome Alternativo do Log
					cTitulo		,;	//Titulo Alternativo do Log
					cTamanho	,;	//Tamanho Vertical do Relatorio de Log ("P","M","G")
					cLandPort	,;	//Orientacao do Relatorio ("P" Retrato ou "L" Paisagem )
					aRet		,;	//Array com a Mesma Estrutura do aReturn
					lAddOldLog	,;	//Se deve Manter ( Adicionar ) no Novo Log o Log Anterior
					aPerg		;	//Array com as perguntas selecionadas
				  )

Local aArea			:= GetArea()
Local aNewLog		:= {}
Local aNewTitle		:= {}
Local aNull			:= {}
Local aAllString	:= {}
Local aModName		:= RetModName()
Local cFile	   		:= ""
Local cPathFile		:= "" 
Local cFatLine		:= ""
Local cThinLine		:= ""
Local cPathOldLog	:= ""
Local cTipoImp		:= ""
Local cExtRel		:= ".##R"
Local nX	   		:= 0
Local nY	   		:= 0
Local nLenLogFile	:= 0
Local nFornX   		:= 0
Local nFornY		:= 0
Local nLenTitle		:= 0
Local nSpace   		:= 0
Local nHandleOld	:= 0
Local nOrienta		:= 0
Local nSvLastKey	:= 0
Local nModName		:= IF( !Empty( aModName ) , aScan( aModName , { |x| x[ 1 ] == nModulo } ) , 0 )
Local nTamOld		:= 0
Local lIncLog		:= SuperGetMV("MV_LOGPROC",,.F.) .and. FunName() $ "GPEM020*GPEM030*GPEM040*GPEM060*GPEA070*GPEM110*GPEM120*GPEM630".and. Type("__aMVLog") <> "U"

Private Titulo 		:= ( STR0001 + " - " + IF( nModName > 0 , aModName[ nModName , 3 ] , "" ) + " - " + STR0002 + cVersao ) //"LOG DE OCORRENCIAS"###
Private wnRel		:= ""
Private nTamanho	:= ""
Private Tamanho		:= ""
Private LI			:= 0
Private ContFl		:= 1
Private aReturn		:= IF( !Empty( aRet ) .and. ValType( aRet ) == "A" , aRet , {"",1,"",2,1,"","",1} )

DEFAULT aLogFile	:= {{}}
DEFAULT aLogTitle	:= {}
DEFAULT cPerg		:= ""
DEFAULT lShowLog 	:= .T.
DEFAULT cLogName	:= ""
DEFAULT cTamanho	:= "G"
DEFAULT cTitulo		:= ""
DEFAULT cLandPort	:= "L"
DEFAULT aRet		:= {}
DEFAULT lAddOldLog	:= .T.
DEFAULT aPerg	   	:= {}

IF ( ( Type("__cInternet") <> "U" ) .and. ( __cInternet == "AUTOMATICO" ) )
	lShowLog := .F.
EndIF

IF ( lShowLog )
	CursorWait()
EndIF

cTamanho	:= Upper( AllTrim( cTamanho ) )
Titulo		:= IF( !Empty( cTitulo ) , cTitulo , Titulo )
nTamanho	:= ( Tamanho := cTamanho )
nSpace		:= ( Limite := IF( nTamanho == "P" , 80 , IF( nTamanho == "G" , 220 , 132 ) ) )
cLandPort	:= Upper( AllTrim( cLandPort ) )
cTipoImp	:= ( StrZero( nSpace , 03 ) + IF( cLandPort == "P" , IF( cTamanho == "G" , "L" , cLandPort ) , cLandPort ) )
cFatLine	:= Replicate("*",nSpace)
cThinLine	:= Replicate("-",nSpace)

nLenLogFile := Len( aLogFile )
aEval( aLogFile , { |x,y| IF( !Empty( aLogFile[ y ] ) , aAdd(  aNewLog , aClone( aLogFile[ y ] ) ) , aAdd( aNull ,  y ) ) } )

If lIncLog 
 	RetLogCalc(@aNewLog)
EndIf

aLogFile	:= aClone( aNewLog )
aNewLog		:= {}
nLenTitle	:= Len( aLogTitle )
For nX := 1 To nLenTitle
	IF ( aScan( aNull , { |x| x == nX } ) == 0 )
		aAdd( aNewTitle , aLogTitle[ nX ] )
	EndIF
Next nX

If lIncLog 
	If Len(__aMVLog) > 0
		aAdd( aNewTitle , STR0015) //"Parâmetros utilizados durante o cálculo"
	EndIf
	aAdd( aNewTitle , "Fontes utilizados durante o cálculo") //"Fontes utilizados durante o cálculo"
	aAdd( aNewTitle , "Perguntes utilizados durante o cálculo") //"Perguntes utilizados durante o cálculo"
	aAdd( aNewTitle , "Mnemonicos utilizados durante o cálculo") //"Mnemonicos utilizados durante o cálculo"
	aAdd( aNewTitle , "Tabelas auxiliares utilizados durante o cálculo") //"Tabelas auxiliares utilizados durante o cálculo"
EndIf


aLogTitle	:= aClone( aNewTitle )
nLenTitle	:= Len( aLogTitle )
aNewTitle	:= {}

IF (;
		( nLenLogFile > 0 );
		.and.;
		( Len( aNull ) != nLenLogFile );
	)	

	aNull		:= {}	
	cFile		:= RetLogName( cLogName , @cPathFile , cExtRel )
	wNrel		:= cFile
	nLenLogFile := Len( aLogFile )
    
	aReturn[ 4 ]	:= IF( cTamanho == "G" , 2 , aReturn[4] )
	aReturn[ 6 ]	:= cFile

	IF ( Type( "nLastKey" ) == "U" )
		Public nLastKey := 0
	Else
		nSvLastKey	:= nLastKey
		nLastKey	:= 0
	EndIF

	nTamOld		:= nTamanho
	SetPrint(NIL,aReturn[6],NIL,@Titulo,"","","",.F.,{},.F.,cTamanho,NIL,.F.,NIL,NIL,!( lShowLog ),.T.)
	nTamanho	:= nTamOld

	cLogName	:= aReturn[ 6 ]
	cFile		:= RetLogName( cLogName , @cPathFile , cExtRel ) 
	wNrel		:= cFile

	IF (aReturn[5] == 1) .AND. File( cPathFile ) // Validação feita apenas para impressões em disco.
		IF ( lAddOldLog )
			cPathOldLog := StrTran( cPathFile , cExtRel , ".OLD"  )
			IF ( RenLastLog( cPathFile , cPathOldLog , lShowLog ) == -1 )
				cPathOldLog := cPathFile
				cFile		:= CriaTrab( NIL , .F. )
				wNrel		:= cFile
				cPathFile	:= ( __RelDir + cFile + cExtRel )
			EndIF
		ElseIF ( fErase( cPathFile ) == -1 )
			cFile		:= CriaTrab( NIL , .F. )
			wNrel		:= cFile
			cPathFile	:= ( __RelDir + cFile + cExtRel )
		EndIF
	EndIF

	Begin Sequence
	
		//Apenas se usuario nao Cancelou a Geracao ( nLastKey eh PUBLIC em SetPrint )
		IF ( nLastKey == 27 )
			nLastKey := nSvLastKey
			IF ( lShowLog )
				//"Deseja cancelar a gera‡„o do LOG?"
				IF MsgNoYes( OemToAnsi( STR0009 ) , OemToAnsi( STR0010 )  ) //"Aten‡„o"
					IF ( lAddOldLog )
						//Verifica se foi criado arquivo Temporario e Retorna nome valido
						IF ( "SC" $ Upper( cPathFile ) )
							cPathOldLog := cPathFile
							RetLogName( cLogName , @cPathFile , cExtRel )
						EndIF
						IF File( cPathOldLog )
							//Retorna o Nome Original do Arquivo
							RenLastLog( cPathOldLog , cPathFile , lShowLog )
						EndIF
					EndIF
					Break
				EndIF
			EndIF	
		EndIF
		
		If lShowLog
			nOrienta := IF( SubStr( cLandPort , -1 ) == "L" , 2 , 1 )
			SetDefault( aReturn , "", NIL, .F., cTamanho, nOrienta )
		EndIf 
	
		//-- Perguntas
		IF !Empty( cPerg )
			IF (;
					( ( nFornX := Len( aPerg ) ) > 0 ) .Or.;
					(RetPergLog( @aPerg , cPerg );
					.and.;
					( ( nFornX := Len( aPerg ) ) > 0 ));
				)
				cString := STR0003	// 'PARAMETROS SELECIONADOS PELO USUARIO'
				Impr( cString )
				cString := cFatLine
				Impr( cString )
				Impr( "" )
				For nX := 1 To nFornX
					cString := aPerg[ nX ]
					Impr( cString )
				Next nX
				cString := cFatLine
				Impr( cString )
			EndIF
			Impr( "" )
			cString := cFatLine
			Impr( cString )
			Impr( "" )
		EndIF
		
		For nX := 1 To nLenLogFile
			
			IF ( ( nFornY := Len( aLogFile[ nX ] ) ) > 0 )
				
				// Titulo
				IF (;
						( nLenTitle > 0 );
						.and.;
						( nX <= nLenTitle );
						.and.;
						( nFornY > 0 );
					)
					cString := cThinLine 
					Impr( cString )
					cString := aLogTitle[ nX ]
					Impr( cString )
					cString := cThinLine 
					Impr( cString )
				EndIF
					
				// Detalhes			
				For nY := 1 To nFornY
					IF ( Li >= 57 )
						// Titulo (Continuacao em outra pagina...)
						IF (;
								( nLenTitle > 0 );
								.and.;
								( nX <= nLenTitle );
								.and.;
								( nFornY > 0 );
							)
							cString := cThinLine 
							Impr( cString , "P" )
							cString := aLogTitle[ nX ]
							Impr( cString )
							cString := cThinLine 
							Impr( cString )
							Impr( "" )
						EndIF
					EndIF
					cString := aLogFile[ nX , nY ]
					Impr( cString )
				Next nY
					
				// Separador de Logs
				IF ( nFornY > 0 )
					Impr( "" )
				EndIF
					
			EndIF
				
		Next nX
		    
		Impr( "" , "F" )
			
		IF ( ( lAddOldLog ) .and. File( cPathOldLog ) )
			IF !( ( nHandleOld := OpenFileLog( cPathOldLog , "READ" , lShowLog ) ) == -1 )
				RetBytes( cPathOldLog , nHandleOld )
				aAllString := GetAllTxtFile( nHandleOld )
				nX := 0
				nFornX := Len( aAllString )
				While ( ++nX <= nFornX )
					@ Li , 0 PSAY aAllString[ nX ]
				End While
				aAllString := {}
				fClose( nHandleOld )
				Ms_Flush()
				fErase( cPathOldLog )
				IF ( "SC" $ Upper( cPathFile ) )
					cPathOldLog := cPathFile
					RetLogName( cLogName , @cPathFile , cExtRel )
					IF !( RenLastLog( cPathOldLog , cPathFile , lShowLog ) == -1 )
						cFile := RetLogName( cLogName )
					EndIF
				EndIF
			EndIF	
		EndIF
		
		If lShowLog
			If __cUserId == Nil .Or. Empty(__cUserId)
				__cUserId := "000000"
			EndIf
			If aReturn[5] == 1
				Set Printer To
				//Commit
				ourspool( cfile )
			EndIf
		EndIF
		
		Ms_Flush()
		
	End Sequence
	
EndIF

IF ( lShowLog )
	CursorArrow()
EndIF

RestArea( aArea )

Return( cPathFile )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RetLogName³ Autor ³ Equipe Advanced RH    ³ Data ³18/04/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Retorna um Nome de Arquivo com base na Data Atual          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³fMakeLog                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function RetLogName( cLogName , cPathFile , cExtRel )

Local aModName

Local cLogFile
Local cBakName
Local cSpace01

Local nModName
Local nFornX
Local nX

DEFAULT cExtRel		:= ".##R" 

IF Empty( cLogName )
	aModName	:= RetModName()
	nModName	:= IF( !Empty( aModName ) , aScan( aModName , { |x| x[ 1 ] == nModulo } ) , 0 )
	cBakName	:= IF( nModName > 0 , SubStr( aModName[ nModName , 2 ] , 5 , 2 ) , "" ) 
	cBakName	+= StrZero( Day( MsDate() ) , 2 )
	cBakName	+= StrZero( Month( MsDate() ) , 2 )
	cBakName	+= Right( StrZero( Year( MsDate() ) , 4 ) , 2 )
	cSpace01	:= Space( 01 )
	cLogFile	:= ""
	nFornX := Len( cBakName )
	For nX:= 1 To nFornX
		IF ( ( SubStr( cBakName , nX , 1 ) # "." ) .and. ( SubStr( cBakName , nX , 1 ) # cSpace01 ) )
			cLogFile += SubStr( cBakName , nX , 1 )
		EndIF
	Next nX
	cLogFile := AllTrim( SubStr( cLogFile , 1 , 8 ) )
	DEFAULT cLogName := cLogFile
Else
	cLogFile := cLogName
EndIF

cPathFile := ( __RelDir + cLogFile + cExtRel )
	
Return( cLogFile )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RetPergLog³ Autor ³ Equipe Advanced RH    ³ Data ³18/04/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ Alimenta um Array com as perguntas selecionadas            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³fMakeLog                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function RetPergLog( aPerg , cPerg )

Local aAreaSX1	:= SX1->( GetArea() )
Local aPergSX1	:= {}
Local cVar      := ""
Local lRet      := .T.

DEFAULT aPerg := {}

SX1->( dbSetOrder( 1 ) )

IF ( lRet := SX1->( dbSeek( cPerg , .F. ) ) )
	
	aPergSX1	:= SX1->( GetArea() )
	Pergunte(cPerg, .F.)
	RestArea(aPergSX1)

	While SX1->( !Eof() .and. ( AllTrim(X1_GRUPO) == cPerg ) )

		cVar := ""

		IF ( SX1->X1_TIPO $ "CD" )
			IF ( SX1->X1_TIPO == "C" )
				cVar := &( SX1->X1_VAR01 )
			Else
				cVar := DtoC( &( SX1->X1_VAR01 ) )
			EndIF
		Else
			IF ( SX1->X1_GSC == "C" )
				cVar := SX1->( &( "X1_DEF" + StrZero( &( X1_VAR01 ) , 2 ) ) )
			Else
				cVar := SX1->( StrZero( &(X1_VAR01 ) , X1_TAMANHO,X1_DECIMAL) )
			EndIf
		EndIf

		IF (;
				( ValType( cVar ) # "C" );
				.or.;
				( Len( cVar ) == 0 );
			)	
			lRet := .F.
			Exit
		Else
			cVar := AllTrim( cVar )
		EndIF

		aAdd( aPerg , fTAcento( SX1->X1_PERGUNT + Space( 1 ) + cVar ) )

		SX1->( dbSkip() )

	End While

EndIF

RestArea( aAreaSX1 )

Return( lRet )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³OpenFileLog³Autor ³ Marinaldo de Jesus    ³ Data ³18/04/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna Handle de Arquivo de Log Anterior                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³fMakeLog                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function OpenFileLog( cPathFile , cModo , lShowLog )

Local nHandle	:= 0
Local nTenta	:= 0
Local nModo		:= 0
Local lOld		:= ( ".OLD" $ cPathFile )

DEFAULT cPathFile	:= ""
DEFAULT lShowLog	:= .T.
DEFAULT cModo		:= "READWRITE"

cModo := Upper( AllTrim( cModo ) )

nModo := IF( cModo == "READ" , 0 , IF( cModo == "WRITE" , 1 , 2 ) )

While (;
			( ( nHandle := fOpen( cPathFile , nModo ) ) == -1 );
			.and.;
			( ++nTenta <= 1000 );
		)
	IF ( nTenta == 1000 )
		//"Nao Foi Possivel Abrir o Arquivo de Log Anterior:" ou //"Nao Foi Possivel Abrir o Arquivo de Log:"
		//"Deseja Tentar Novamente?"
		IF lShowLog .and. GpConfOk( IF( lOld , STR0004 , STR0005 ) + Space( 01 ) +  cPathFile + Space( 01 ) + STR0006 )
			nTenta := 0
		Else
			Exit
		EndIF
	EndIF
End While

IF !( nHandle == -1 )
	fSeek( nHandle , 0 , 2 )
EndIF

Return( nHandle )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RenLastLog ³Autor ³ Marinaldo de Jesus    ³ Data ³18/04/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Salva o Arquivo de Log Anterior                             ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³fMakeLog                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function RenLastLog( cPathFile , cNewPathFile ,lShowLog )

Local nError	:= 0
Local nTenta	:= 0

DEFAULT cPathFile		:= ""
DEFAULT cNewPathFile	:= ""
DEFAULT lShowLog		:= .T.

IF File( cNewPathFile )
	fErase( cNewPathFile )
EndIF

While (;
			( ( nError := fRename( cPathFile , cNewPathFile ) ) == -1 );
			.and.;
			( ++nTenta <= 1000 );
	  )
	IF ( nTenta == 1000 )
		IF lShowLog .and. GpConfOk( STR0007 + Space( 01 ) +  cNewPathFile + Space( 01 ) + STR0006 ) //"Nao Foi Possivel Salvar o Arquivo de Log Anterior:""###"Deseja Tentar Novamente?"
			nTenta := 0
		Else
			Exit
		EndIF
	EndIF
End While

Return( nError )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fImp_Tot  ³Autor  ³Marinaldo de Jesus     ³ Data ³12/07/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Imprime os Totais                                          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fImp_Tot( @aExp1 , @aExp2 , @aExp3 , cExp4 , lExp5 , nExp6 )³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ aExp1       - Array  com os Proventos                      ³
³          ³ aExp2       - Array  com os Descontos                      ³
³          ³ aExp3       - Array  com as Bases                          ³
³          ³ cExp4       - String com a Descricao do Tipo de Totalizacao³
³          ³ lExp5       - Logico Quebra de Pagina                      ³
³          ³ nExp6       - Numero de Colunas do Relatorio               ³
³          ³ aExp7       - Array com os Codigos da Folha de Pagamento   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Gper550.Prx e Gper630.prx                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function fImp_Tot( aExp1 , aExp2 , aExp3 , cExp4 , lExp5 , nExp6 , aExp7 , cFilialAnt )

Local cDetalhe	:= ""
Local nMaximo	:= 0
Local nConta	:= 0
Local nTotProv	:= 0
Local nTotDesc  := 0
Local nLiquido	:= 0

Default cFilialAnt := SRA->RA_FILIAL

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Testa os Parametros Passados                                 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aExp1 := IF( aExp1 == NIL .or. ValType( aExp1 ) != "A"	, {}	, aExp1 )
aExp2 := IF( aExp2 == NIL .or. ValType( aExp2 ) != "A"	, {}	, aExp2 )
aExp3 := IF( aExp3 == NIL .or. ValType( aExp3 ) != "A"	, {}	, aExp3 )
cExp4 := IF( cExp4 == NIL .or. ValType( cExp4 ) != "C"	, ""	, cExp4 )
lExp5 := IF( lExp5 == NIL .or. ValType( lExp5 ) != "L"	, .F.	, lExp5 )
nExp6 := IF( nExp6 == NIL .or. ValType( nExp6 ) != "N"	, 0		, nExp6 )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Retorna se nao tiver valores a Serem Impressos               ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF ( Empty( aExp1 ) .and. Empty( aExp2 ) .and. Empty(aExp3) )
	Return( NIL )
EndIF	

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Quebra de Pagina                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF lExp5 ; 	Impr( "" , "P" ) ; 	Li := 0 ; EndIF

/*                                                   
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Impressao das Verbas                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
nMaximo		:= Max( Max( Len( aExp1 ) , Len( aExp2 ) ) , Len( aExp3 ) )
For nConta	:= 1 To nMaximo
			
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cancela ImpressÆo ao se pressionar <ALT> + <A>.              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF lEnd
		Exit  
	EndIF
															                                                                                                                                        
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Mascara do Relatorio (132 Colunas)                           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	        10        20        30        40        50        60        70        80        90       100       110       120       130  
	123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
	Cod Descricao           Qtde      Proventos Cod Descricao           Qtde      Descontos Cod Descricao           Qtde           Bases
	XXX XXXXXXXXXXXXXXXX 9999,99 999.999.999,99 XXX XXXXXXXXXXXXXXXX 9999,99 999.999.999,99 XXX XXXXXXXXXXXXXXXX 9999,99  999.999.999,99
	Totais:                      999.999.999,99                              999.999.999,99                     Liquido:  999.999.999,99*/
                                                                                            
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Proventos                                                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF nConta > Len( aExp1 )
		cDetalhe := cDetalhe + Space( 44 )
	Else
		
		cDetalhe := cDetalhe + aExp1[ nConta, 1 ]													+ Space( 01 ) 	//Codigo
		cDetalhe := cDetalhe + Subst( PosSrv(aExp1[nConta,1],cFilialAnt ,"RV_DESC") , 1 , 16 )	+ Space( 01 ) 	//Descricao
		cDetalhe := cDetalhe + Transform( aExp1[nConta,2],'@E 9999.99'        )						+ Space( 01 ) 	//Quantidade
		cDetalhe := cDetalhe + Transform( aExp1[nConta,3],'@E 999,999,999.99' )						+ Space( 01 )	//Valor
	EndIF
				
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Descontos                                                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF nConta > Len( aExp2 )
		cDetalhe := cDetalhe + Space( 44 )
	Else
		cDetalhe := cDetalhe + aExp2[ nConta, 1 ]													+ Space( 01 ) 	//Codigo
		cDetalhe := cDetalhe + Subst( PosSrv(aExp2[nConta,1],cFilialAnt ,"RV_DESC") , 1 , 16 )	+ Space( 01 ) 	//Descricao
		cDetalhe := cDetalhe + Transform( aExp2[nConta,2],'@E 9999.99'        )						+ Space( 01 ) 	//Quantidade
		cDetalhe := cDetalhe + Transform( aExp2[nConta,3],'@E 999,999,999.99' )						+ Space( 01 ) 	//Valor
	EndIF	
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Bases                                                        ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF nConta > Len( aExp3 )
		cDetalhe := cDetalhe + Space( 44 )
	Else
		cDetalhe := cDetalhe + aExp3[ nConta, 1 ]													+ Space( 01 ) 	//Codigo
		cDetalhe := cDetalhe + Subst( PosSrv(aExp3[nConta,1],cFilialAnt,"RV_DESC") ,1 , 16 ) 	+ Space( 01 ) 	//Descricao
		cDetalhe := cDetalhe + Transform( aExp3[nConta,2],'@E 9999.99'     )						+ Space( 02 ) 	//Quantidade
		cDetalhe := cDetalhe + Transform( aExp3[nConta,3],'@E 999,999,999.99' )	              						//Valor
	EndIF	

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Imprime os Detalhes das Verbas                               ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	Impr(cDetalhe,"C") ; cDetalhe := ""

Next nConta
					
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Totalizacao dos Valores                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aEval( aExp1 ,{ |x| nTotProv := nTotProv + x[3]  } )
aEval( aExp2 ,{ |x| nTotDesc := nTotDesc + x[3]  } )

nLiquido := nTotProv - nTotDesc

Impr( cDetalhe := "" ,"C") 
cDetalhe := cDetalhe + cExp4 										+ Space( 08 )  	//Tipo de Totalizacao
cDetalhe := cDetalhe + Transform( nTotProv ,"@E 999,999,999.99")	+ Space( 30 )	//Total de Proventos
cDetalhe := cDetalhe + Transform( nTotDesc ,"@E 999,999,999.99")	+ Space( 21 )	//Total de Descontos
cDetalhe := cDetalhe + STR0008										+ Space( 02 ) 	//Liquido
cDetalhe := cDetalhe + Transform( nLiquido ,"@E 999,999,999.99")					//Total de Liquido

Impr(cDetalhe,"C") ; Impr( Replicate( "-" , nExp6 ) , "C")

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Reinicializa Variaveis                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aExp1 := {}
aExp2 := {}
aExp3 := {}

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Quebra de Pagina                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF lExp5 ; 	Impr( "" , "P" ) ; 	Li := 0 ; EndIF

Return( NIL )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fCarApdImp³ Autor ³ Marinaldo de Jesus    ³ Data ³01/03/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Carrega os Valores em Apd                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ fCarApdImp( aExp1 , lExp2 , aExp3 )						³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ aExp1       - Array a Ser Carregada                        ³
³          ³ lExp2       - Totatiza ou nao os Valores                   ³
³          ³ aExp3       - Array com os Codigos da Folha (aCodFol)      ³
³          ³ cExp4       - Tipo para Exclusao de Liquido                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³ Array com os Valores a Serem Impressos                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Gper630.PRX e Gper550.prx                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function fCarApdImp( aExp1 , lExp2 , aExp3 , cExp4 )

Local cNaoLista	:= ""

aExp1	:= IF( aExp1 == NIL .or. ValType( aExp1 ) != "A" , {}  , aExp1   )
lExp2	:= IF( lExp2 == NIL .or. ValType( lExp2 ) != "L" , .F. , lExp2   )
aExp3	:= IF( aExp3 == NIL .or. ValType( aExp3 ) != "A" , {}  , aExp3   )
cExp4	:= IF( cExp4 == NIL .or. ValType( cExp4 ) != "C" , "F" , Upper( AllTrim( cExp4 ) ) )

cNaoLista := IF( ( cExp4 == "F" ) , aExp3[ 102 , 1 ] , IF( ( cExp4 == "R" ) , aExp3[ 126 , 1 ] , "" ) )

IF !( SRR->RR_PD $ cNaoLista )
	IF !( lExp2 )
		SRR->( aAdd( aExp1 , { RR_PD, RR_HORAS , RR_VALOR, RR_TIPO1 } ) )
	Else
		SRR->( IF(;
						( ( nPos := aScan( aExp1, { |x| x[1] == RR_PD } ) ) == 0 ),;
						aAdd( aExp1,;
										{;
											RR_PD,;
											RR_HORAS,;
											RR_VALOR,;
											RR_TIPO1;
										};
							),;
						(;
								aExp1[nPos,2] += RR_HORAS,;
								aExp1[nPos,3]+=RR_VALOR;
						 );
				 );
			  )	 
	EndIF
EndIF

aSort( aExp1 , NIL , NIL , { |x , y | x[1] < y[1] } )

Return( aExp1 )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³InGpexRelExec ³Autor ³Marinaldo de Jesus   ³ Data ³24/08/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Executar Funcoes Dentro de GPEXREL                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³InGpexRelExec( cExecIn , aFormParam )						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³uRet                                                 	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function InGpexRelExec( cExecIn , aFormParam )
         
Local uRet

DEFAULT cExecIn		:= ""
DEFAULT aFormParam	:= {}

IF !Empty( cExecIn )
	cExecIn	:= BldcExecInFun( cExecIn , aFormParam )
	uRet	:= &( cExecIn )
EndIF

Return( uRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Rst040Imp  ºAutor  ³Jonatas A. T. Alves º Data ³  22/10/08  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³  Restaura variavel estatica do GPER040.	                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEM110                            						  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Rst040Imp()
Return( ( lPrimeira := .T. ) )


/*/{Protheus.doc} GetLogFnt
//Retorna fontes utilizados pela rotina para ser mostrada no LOG
@author Flavio
@since 22/03/2017
/*/
Function GetLogFnt(cProcesso,lTela)
Local aFntGeral := {}
Local aRPO		:= {}
Local aRet		:= {}
Local nX 		:= 1

DEFAULT lTela 		:= .F.
DEFAULT cProcesso 	:= ""

cProcesso := RetProc(cProcesso)

Aadd(aFntGeral,'GPROTBRA.PRX')
Aadd(aFntGeral,'GPFORBRA.PRX')
Aadd(aFntGeral,'GPFO1BRA.PRX')
Aadd(aFntGeral,'GPFO2BRA.PRX')
Aadd(aFntGeral,'GPTABBRA.PRX')
Aadd(aFntGeral,'GPMNEBRA.PRX')
Aadd(aFntGeral,'GPEXCADI.PRX')
Aadd(aFntGeral,'GPEXCAL1.PRX')
Aadd(aFntGeral,'GPEXCAL2.PRX')
Aadd(aFntGeral,'GPEXCAL3.PRX')
Aadd(aFntGeral,'GPEXCALC.PRX')
Aadd(aFntGeral,'GPEXCBEN.PRX')
Aadd(aFntGeral,'GPEXCDES.PRX')
Aadd(aFntGeral,'GPEXCIMP.PRX')
Aadd(aFntGeral,'GPEXCPLR.PRX')
Aadd(aFntGeral,'GPEXFUN.PRX')
Aadd(aFntGeral,'GPEXFUN1.PRX')
Aadd(aFntGeral,'GPEXFERE.PRX')
Aadd(aFntGeral,'GPEXC131.PRX')
Aadd(aFntGeral,'GPEM020.PRX')
	
If cProcesso == "1" //FOL
ElseIf cProcesso == "2" //ADI
ElseIf cProcesso == "3"//FER
	Aadd(aFntGeral,'GPEM030.PRX')
ElseIf cProcesso == "4" //RES
	Aadd(aFntGeral,'GPEM040.PRX')
ElseIf cProcesso == "5" //131
ElseIf cProcesso == "6" //132
ElseIf cProcesso == "8" //VTR
ElseIf cProcesso == "9" //AUT
ElseIf cProcesso == "C" //PLA
	Aadd(aFntGeral,'GPEM016.PRW')
ElseIf cProcesso == "D" //VRF
ElseIf cProcesso == "E" //VAL
ElseIf cProcesso == "F" //PLR
ElseIf cProcesso == "G" //INC
ElseIf cProcesso == "I" //BEN
ElseIf cProcesso == "J" //MUV
ElseIf cProcesso == "K" //VEX
ElseIf cProcesso == "M" //Medias
	Aadd(aFntGeral,'GPEXMED.PRX')
ElseIf cProcesso == "W" //Fechamento
	Aadd(aFntGeral,'GPEM120.PRX')
ElseIf cProcesso == "X" //Contabilização
	Aadd(aFntGeral,'GPEM110.PRX')
ElseIf cProcesso == "Y" //Provisão de Férias
	Aadd(aFntGeral,'GPEM070.PRX')
	Aadd(aFntGeral,'GPEA070.PRX')
ElseIf cProcesso == "Z" //Provisão 13
	Aadd(aFntGeral,'GPEM070.PRX')
	Aadd(aFntGeral,'GPEA070.PRX')
EndIf

For nX := 1 To Len(aFntGeral)
	aRPO := {}
	aRPO := GetApoInfo( aFntGeral[nX] )
	If lTela
		Aadd(aRet,aRpo)
	Else
		aadd(aRet,aRpo[1] + " | " + Dtoc(aRpo[4]) + " | " + aRpo[5])
	EndIf
Next nX

Return aRet

/*/{Protheus.doc} GetLogSX1
//Retorna perguntas utilizadas pela rotina para ser mostrada no LOG
@author Flavio
@since 22/03/2017
/*/
Function GetLogSX1(cProcesso,lTela)
Local aRet		:= {}
Local aPerg		:= {}
Local nX		:= 1

DEFAULT lTela := .F.
DEFAULT cProcesso := ""

cProcesso := RetProc(cProcesso)

If cProcesso $ "Y*Z" //provisao
	aadd(aPerg,"GPM070") 
ElseIf cProcesso = "W" // fechamento
	aadd(aPerg,"GPEM120")
ElseIf cProcesso = "M" // Media
	aadd(aPerg,"GPR080")
ElseIf cProcesso = "X" //contabilização
	aadd(aPerg,"GPE110A")
	aadd(aPerg,"GPE110D")
	aadd(aPerg,"GPE110B")
	aadd(aPerg,"GPE110C")
	aadd(aPerg,"GPE110F")
	aadd(aPerg,"GP110F")
	aadd(aPerg,"GP110P")
	aadd(aPerg,"GPE110M")
	aadd(aPerg,"GPE110A")
ElseIf cProcesso = "3"  //ferias coletivas
	aadd(aPerg,"GPM060")
	aadd(aPerg,"GPM062")
Else // roteiros
	aadd(aPerg,"GPEM020")
	//perguntas especificas
	Pergunte(aPerg[1],.F.)
	dbSelectArea("SRY")
	SRY->(dbSetOrder(1))
	If SRY->(DbSeek( xFilial("SRY") + MV_PAR02))
		If !Empty(SRY->RY_PERGUNT)
	      	aadd(aPerg,SRY->RY_PERGUNT)
	    EndIf
	EndIf
EndIf


dbSelectArea("SX1")
SX1->(dbSetOrder(1))
For nX := 1 To Len(aPerg)
	Pergunte(aPerg[nX],.F.)
	If !lTela
		aadd(aRet,"Pergunta - " + aPerg[nX])
	EndIf
	If SX1->(dbSeek(aPerg[nX]))
		While !Eof() .And. AllTrim(SX1->X1_GRUPO) == AllTrim(aPerg[nX])
			If lTela
				aAdd(aRet, {aPerg[nX] ,SX1->X1_VAR01 ,  AllTrim(X1PERGUNT()) ,  AllToChar(&(SX1->X1_VAR01)) } )
			Else
				aAdd(aRet, SX1->X1_VAR01 + " | " +  AllTrim(X1PERGUNT()) + " | " +  AllToChar(&(SX1->X1_VAR01)) )
			EndIf
			SX1->(dbSkip())
		EndDo
	EndIf
Next nX


Return aRet

/*/{Protheus.doc} GetLogMNE
//Retorna mnemonicos utilizados pela rotina para ser mostrada no LOG
@author Flavio
@since 22/03/2017
/*/
Function GetLogMNE(cProcesso,lTela)
Local aRet	:= {}
Local aArea	:= GetArea()
Local cQry	:= GetNextAlias()

DEFAULT lTela := .F.
DEFAULT cProcesso := ""

cProcesso := RetProc(cProcesso)
cProcesso := "% RCA.RCA_PROCES LIKE ('%" + cProcesso + "%') %"
BeginSql alias cQry
	SELECT RCA_MNEMON,RCA_DESC,RCA_CONTEU
	FROM %table:RCA%  RCA
	WHERE 
	RCA.RCA_FILIAL = %xfilial:RCA%
	AND %exp:cProcesso%  
	AND SUBSTRING(RCA.RCA_MNEMON,1,2) = 'P_' 
	AND RCA.%notDel%   
	
EndSql

While !(cQry)->(eof())
	If lTela
		aadd(aRet,{(cQry)->RCA_MNEMON, (cQry)->RCA_DESC , (cQry)->RCA_CONTEU})
	Else
		aadd(aRet,(cQry)->RCA_MNEMON + " | " + (cQry)->RCA_DESC + " | " + iif(Type((cQry)->RCA_MNEMON)== "U",(cQry)->RCA_CONTEU,cvaltochar(&((cQry)->RCA_MNEMON))))
	EndIf
	(cQry)->(dbSkip())
EndDo
(cQry)->(dbcloseArea())

RestArea(aArea)
Return aRet

/*/{Protheus.doc} GetLogTAB
//Retorna Tabelas auxiliares utilizados pela rotina para ser mostrada no LOG
@author Flavio
@since 22/03/2017
/*/
Function GetLogTAB(cProcesso,lTela,cPeriodo)
Local aRet	:= {}
Local aTab	:= {}
Local aAux	:= {}
Local aRetAux := {}
Local nAux	:= 0
Local nAux2	:= 0
Local nX	:= 1
Local nZ	:= 1
Local nY	:= 1
Local cTmp	:= ""
Local aArea	:= GetArea()
Local cQry	:= GetNextAlias()
Local cWhere 	:= ""
Local aPict		:= {}

DEFAULT lTela := .F.
DEFAULT cPeriodo := ""
DEFAULT cProcesso := ""

cProcesso := RetProc(cProcesso,@cPeriodo)
cWhere := "% RCB.RCB_PROCES LIKE '%" + cProcesso + "%' %"

BeginSql alias cQry
	SELECT DISTINCT RCB_CODIGO,RCB_DESC,RCB_SHOWMA
	FROM %table:RCB%  RCB
	WHERE 
	%exp:cWhere%
	AND RCB.RCB_FILIAL = %xfilial:RCB%
	AND RCB.%notDel%   
		
EndSql

While !(cQry)->(eof())
	fCarrTab( @aTab,(cQry)->RCB_CODIGO,, .T., cPeriodo, .F. )
	aadd(aAux,{(cQry)->RCB_CODIGO,aClone(aTab),(cQry)->RCB_DESC})
	(cQry)->(dbSkip())
EndDo
(cQry)->(dbcloseArea())

For nX := 1 To Len(aAux)
	cQry	:= GetNextAlias()
	BeginSql alias cQry
		SELECT RCB_DESCPO,RCB_DESC,RCB.RCB_TAMAN,RCB.RCB_PICTUR
		FROM %table:RCB%  RCB
		WHERE 
		RCB.RCB_CODIGO = %exp:aAux[nX][1]%
		AND RCB.RCB_FILIAL = %xfilial:RCB%
		AND RCB.%notDel%   
			
	EndSql
	
	If Len(aAux[nX,2]) > 0
	
		aadd(aRet,aAux[nX][1] + " - " + aAux[nX][3])
		cTmp := ""
		aPict := {}
		
		
		If (Len(aAux[nX,2,1])-5) > 10
			aRetAux := {}
			nAux	:= 0
			While !(cQry)->(eof())
				aadd(aPict,(cQry)->RCB_PICTUR)
				cTmp += Padr((cQry)->RCB_DESCPO,15) + " | "
				nAux++
				If nAux > 10
					nAux := 0
					aAdd(aRetAux, {})
					aAdd(aRetAux[Len(aRetAux)],cTmp)
					cTmp := ""
				EndIf
				(cQry)->(dbSkip())
			EndDo
			If nAux > 0
				aAdd(aRetAux, {})
				aAdd(aRetAux[Len(aRetAux)],cTmp)
			EndIf
			(cQry)->(dbcloseArea())
	//		aadd(aRet,cTmp)
			For nY := 1 To Len(aAux[nX][2])
				cTmp := ""
				nAux := 0
				nAux2 := 1
				For nZ := 5 To Len(aAux[nX][2][nY])
					cTmp += Padr(alltochar(aAux[nX][2][nY][nZ],aPict[nZ-4]),15) + " | "
					nAux++
					If nAux > 10
						nAux := 0
						aAdd(aRetAux[nAux2],cTmp)
						cTmp := ""
						nAux2++
					EndIf
				Next nZ
				If nAux > 0
					aAdd(aRetAux[nAux2],cTmp)
	//			aadd(aRet,cTmp)
				EndIf
			Next nY
			For nY := 1 to Len(aRetAux)
				For nAux := 1 to Len(aRetAux[nY])
					aAdd(aRet,aRetAux[nY,nAux])
				Next nAux
			Next nY
		Else
			While !(cQry)->(eof())
				aadd(aPict,(cQry)->RCB_PICTUR)
				cTmp += Padr((cQry)->RCB_DESCPO,15) + " | "
				(cQry)->(dbSkip())
			EndDo
			(cQry)->(dbcloseArea())
			aadd(aRet,cTmp)
			For nY := 1 To Len(aAux[nX][2])
				cTmp := ""
				For nZ := 5 To Len(aAux[nX][2][nY])
					cTmp += Padr(alltochar(aAux[nX][2][nY][nZ],aPict[nZ-4]),15) + " | "
				Next nZ
				aadd(aRet,cTmp)
			Next nY
		EndIf
		aadd(aRet,"")
	EndIf
Next nX

RestArea(aArea)

Return aRet

Static Function RetProc(cProcesso,cPeriodo)

If Empty(cProcesso)
	If FunName() =="GPEA070" //provisao
		cProcesso := "Y"
	ElseIf FunName() =="GPEM120"// fechamento
		cProcesso := "W"
	ElseIf FunName() =="GPEM110"//contabilização
		cProcesso := "X"
	ElseIf FunName() == "GPEM060" //ferias coletivas
		cProcesso := "3"
	ElseIf FunName() == "GPEM020"
		//perguntas especificas
		Pergunte("GPEM020",.F.)
		cProcesso := fGetTipoRot( MV_PAR02 )
		cPeriodo := MV_PAR03
	Else
		cProcesso := "1"
	EndIf
EndIf
Return cProcesso

/*/{Protheus.doc} GetLogMV
//Retorna Parametros utilizados no processo
//SE ALTERAR A ESTRUTURA DA TABELAA TEMPORÁRIA, DEVE SER REVISTO A MANUTENÇÃO NO GPEA932 
@author Leandro Drumond
@since 27/03/2017
/*/
Static Function GetLogMV()
Local aRet		:= {}
Local nX		:= 0

/* Solicitado remoção de chamadas de CTREE */
/*Foi criada tabela temporária quando planejado criar uma tela para consultar os registros, a qual não foi implementada.
Removida criação de tabela temporária, caso retorne necessidade de criar tela de consulta dos parâmetros, basta olhar as alterações removidas nesse commit. */

For nX := 1 to Len(__aMVLog)
	aAdd(aRet, Padr(__aMVLog[nX,1],10) + " = " + __aMvLog[nX,2])
Next nX


Return aRet

/*/{Protheus.doc} RetLogCalc
//Retorna Parametros utilizados no processo
@author Flavio Correa
@since 23/20/2019
/*/
Function RetLogCalc(aRet,cTipos,cProc)
DEFAULT cTipos 	:= "12345"
DEFAULT cProc	:= ""

If "1" $ cTipos
	If Len(__aMVLog) > 0
		aadd(aRet,aClone(GetLogMV())) //parametros
	EndIf
EndIf

If "2" $ cTipos
	aadd(aRet,aClone(GetLogFnt(cProc))) //fontes
EndIf

If "3" $ cTipos
	aadd(aRet,aClone(GetLogSX1(cProc))) //sx1
EndIf

If "4" $ cTipos
	aadd(aRet,aClone(GetLogMNE(cProc))) //Mnemonicos
EndIf

If "5" $ cTipos
	aadd(aRet,aClone(GetLogTAB(cProc))) //tabelas auxiliares
EndIf

Return aRet
