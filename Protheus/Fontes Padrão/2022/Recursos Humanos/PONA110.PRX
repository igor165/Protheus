#INCLUDE "PONA110.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "PONCALEN.CH"
/*


Ŀ
Funo     Pona110   Autor  Wiliam R. Bertoncini   Data  22/07/96 
Ĵ
Descrio  Cadastro de Arredondamentos                                
Ĵ
Sintaxe    pona110                                                    
Ĵ
Parametros                                                            
Ĵ
 Uso       Generico                                                   
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
Cecilia C.  20/05/14TPQAN3Incluido o fonte da 11 para a 12 e efetu- 
                          ada a limpeza.                            
ٱ

*/
Function Pona110()

Local aArea			:= GetArea()
Local cFiltraRh		:= ""

Private cCadastro := OemToAnsi(STR0004 ) // "Arredondamentos"

/*
Ŀ
 So Executa se os Modos de Acesso dos Arquivos Relacionados es
 tiverm OK 												   
*/
IF ValidArqPon()

	Private aIndexSPD	    := {}
	Private bFiltraBrw		:= {|| NIL }
	private bFilterOk		:= { || .F. }
	
	//Ŀ
	// Define Array contendo as Rotinas a executar do programa      
	// ----------- Elementos contidos por dimensao ------------     
	// 1. Nome a aparecer no cabecalho                              
	// 2. Nome da Rotina associada                                  
	// 3. Usado pela rotina                                         
	// 4. Tipo de Transao a ser efetuada                          
	//    1 - Pesquisa e Posiciona em um Banco de Dados             
	//    2 - Simplesmente Mostra os Campos                         
	//    3 - Inclui registros no Bancos de Dados                   
	//    4 - Altera o registro corrente                            
	//    5 - Remove o registro corrente do Banco de Dados          
	//
	Private aRotina := MenuDef()
	
	Private aHeader := {}
	
	// Inicializa o filtro utilizando a funcao FilBrowse
	cFiltraRh	:= ChkRh("PONA110", "SPD", "1")
	bFiltraBrw 	:= { || FilBrowse( "SPD", @aIndexSPD, @cFiltraRH ) }
	Eval( bFiltraBrw )
	
	mBrowse( 6, 1, 22, 75, "SPD",,,,,,,,,,,,,, Pona110Unique() )
	
	// Deleta o filtro utilizando a funcao FilBrowse
	EndFilBrw( "SPD", aIndexSPD )
	
EndIF

//Restaura Integridade de Entrada
RestArea( aArea )

Return( NIL )

/*


Ŀ
Funo    Pona110Vis   AutorWiliam R. Bertoncini   Data  22.07.96 
Ĵ
Descrio  Programa de visualizacao arredondamento                    
Ĵ
Sintaxe   Pona110Vis(ExpC1,ExpN1,ExpN2)                               
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       pona110                                                    
ٱ

*/
Static Function Pona110Vis(cAlias,nReg,nOpcx)

Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aRecnos		:= {}
Local bSet15		:= { || .T. }
Local bSet24		:= { || .T. }
Local bDialogInit	:= { || EnchoiceBar( oDlg , bSet15 , bSet24 ) }
Local cDesc			:= Space(20)
Local cTipoArred	:= SPD->PD_TIPO
Local cTurno     	:= SPD->PD_TURNO
Local cFilSPD		:= xFilial( "SPD" )
Local cKey			:= ""
Local nOpcA			:= 0
Local oDlg
Local oGet
Local oFont
Local oGroup

Private aTela
Private aGets
Private aHeader
Private nUsado
Private aCols

Begin Sequence

	/*
	Ŀ
	 Nao Permite Visualizacao em Arquivo Vazio				   	   
	*/
	IF !( ChkVazio("SPD") )
	   Break
	EndIF
	
	/*
	Ŀ
	 Reserva o Codigo e Carrega Descricao					   	   
	*/
	IF !Chk_Tipo( nOpcX , cTipoArred , cTurno , @cDesc , .F. )
		Break
	EndIF

	/*
	Ŀ
	 Carrega os Dados no aCols  							   	   
	*/
	cKey := ( cFilSPD+cTipoArred+cTurno )
	aCols := GdMontaCols(	@aHeader		,;	//01 -> Array com os Campos do Cabecalho da GetDados
							@nUsado			,;	//02 -> Numero de Campos em Uso
							NIL     		,;	//03 -> [@]Array com os Campos Virtuais
							NIL    			,;	//04 -> [@]Array com os Campos Visuais
							cAlias			,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
							NIL       		,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
							@aRecnos		,;	//07 -> [@]Array unidimensional contendo os Recnos
							cAlias		   	,;	//08 -> Alias do Arquivo Pai
							cKey			,;	//09 -> Chave para o Posicionamento no Alias Filho
							NIL 			,;	//10 -> Bloco para condicao de Loop While
							NIL  			,;	//11 -> Bloco para Skip no Loop While
							.T.     		,;	//12 -> Se Havera o Elemento de Delecao no aCols 
							.T.     		,;	//13 -> Se cria variaveis Publicas
							.T.     		,;	//14 -> Se Sera considerado o Inicializador Padrao
							NIL  			,;	//15 -> Lado para o inicializador padrao
							NIL       		,;	//16 -> Opcional, Carregar Todos os Campos
							NIL         	,;	//17 -> Opcional, Nao Carregar os Campos Virtuais
							NIL       		,;	//18 -> Opcional, Utilizacao de Query para Selecao de Dados
							NIL        		,;	//19 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP )
							NIL         	,;	//20 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP )
							.F.      		,;	//21 -> Carregar Coluna Fantasma
							NIL           	,;	//22 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
							NIL      		,;	//23 -> Verifica se Deve Checar se o campo eh usado
							NIL      		,;	//24 -> Verifica se Deve Checar o nivel do usuario
							NIL          	,;	//25 -> Verifica se Deve Carregar o Elemento Vazio no aCols
							NIL       		,;	//26 -> [@]Array que contera as chaves conforme recnos
							.F.        		,;	//27 -> [@]Se devera efetuar o Lock dos Registros
							.F.     		,;	//28 -> [@]Se devera obter a Exclusividade nas chaves dos registros
							NIL      		 ;	//29 -> Numero maximo de Locks a ser efetuado
						)

	If ( Len( aRecnos ) == 0 )
	   Help(" ",1,"A040SLANC")
	   Break
	Endif

	/*
	Ŀ
	 Monta as Dimensoes dos Objetos         					   
	*/
	aAdvSize		:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
	aAdd( aObjCoords , { 000 , 025 , .T. , .F. } )
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )
 	//aObj1Coords := {}
	//aAdd( aObj1Coords , { 000 , 000 , .T. , .T., .T. } )
	//aObj1Size		:= MsObjSize( aInfoAdvSize , aObjCoords )
	/*
	Ŀ
	 Mostra o corpo dos Arredondamentos  ( Visualizacao ) 
	*/
	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0023 ) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL // "Visualizar - Arredondamentos"
			
	@ aObjSize[1,1], aObjSize[1,2] 		GROUP oGroup TO aObjSize[1,3],aObjSize[1,4]*0.10 	LABEL OemToAnsi(STR0024) OF oDlg PIXEL	// "Turno:"
	oGroup:oFont:= oFont
	@ aObjSize[1,1], aObjSize[1,4]*0.105 	GROUP oGroup TO aObjSize[1,3],aObjSize[1,4]*0.20	LABEL OemToAnsi(STR0015) OF oDlg PIXEL	// 'Tipo:'
	oGroup:oFont:= oFont
	@ aObjSize[1,1], aObjSize[1,4]*0.205	GROUP oGroup TO aObjSize[1,3],aObjSize[1,4]			LABEL OemToAnsi(STR0033) OF oDlg PIXEL	// "Descrio:"
	oGroup:oFont:= oFont
		
	@ aObjSize[1,1]+10, aObjSize[1,2]*2.5	SAY cTurno		PICTURE PesqPict("SPD","PD_TURNO")	SIZE 050,10 OF oDlg PIXEL FONT oFont
	@ aObjSize[1,1]+10, aObjSize[1,4]*0.12	SAY cTipoArred	PICTURE PesqPict("SPD","PD_TIPO")	SIZE 146,10 OF oDlg PIXEL FONT oFont
	@ aObjSize[1,1]+10, aObjSize[1,4]*0.22	SAY cDesc		PICTURE "@!"						SIZE 150,10 OF oDlg PIXEL FONT oFont
	
	oGet := MSGetDados():New(aObjSize[2,1],aObjSize[2,2],aObjSize[2,3],aObjSize[2,4],nOpcx,,,"",.F.,,,,,,,,,oDlg)
		
	bSet15		:= { || nOpcA:=1 , oDlg:End() }
	bSet24		:= { || nOpcA:=0 , oDlg:End() }
		
	ACTIVATE MSDIALOG oDlg ON INIT Eval( bDialogInit ) CENTERED

End Sequence

Return( NIL )

/*


Ŀ
Funo    Pona110Inc Autor  Wiliam R. Bertoncini   Data  22.07.96 
Ĵ
Descrio  Programa de Inclusao dos tipos de hora extra               
Ĵ
Sintaxe   Pona110Inc(ExpC1,ExpN1,ExpN2)                               
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       pona110                                                    
ٱ

*/
Static Function Pona110Inc(cAlias,nReg,nOpcX)

Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aCombo		:= Sx3Box2Arr( "PD_TIPO" )
Local cKey			:= "__NewReg__"
Local bSet15		:= { || .T. }
Local bSet24		:= { || .T. }
Local bDialogInit	:= { || EnchoiceBar( oDlg , bSet15 , bSet24 ) }
Local nOpcA			:= 0
Local nCnt
Local nCnts
Local oDlg
Local oGet
Local oFont
Local oGroup

Private cTipoArred	:= Space( TamSx3( "PD_TIPO" )[1] )
Private cTurno		:= Space( TamSx3( "PD_TURNO" )[1] )

Private aTela
Private aGets
Private aHeader
Private nUsado
Private aCols
Private aColsAnt

/*
Ŀ
 Carrega a Estrutura do aCols							   	   
*/
aCols := GdMontaCols(	@aHeader		,;	//01 -> Array com os Campos do Cabecalho da GetDados
						@nUsado			,;	//02 -> Numero de Campos em Uso
						NIL     		,;	//03 -> [@]Array com os Campos Virtuais
						NIL    			,;	//04 -> [@]Array com os Campos Visuais
						cAlias			,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
						NIL       		,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
						NIL    			,;	//07 -> [@]Array unidimensional contendo os Recnos
						cAlias		   	,;	//08 -> Alias do Arquivo Pai
						cKey			,;	//09 -> Chave para o Posicionamento no Alias Filho
						NIL 			,;	//10 -> Bloco para condicao de Loop While
						NIL  			,;	//11 -> Bloco para Skip no Loop While
						.T.     		,;	//12 -> Se Havera o Elemento de Delecao no aCols 
						.T.     		,;	//13 -> Se cria variaveis Publicas
						.T.     		,;	//14 -> Se Sera considerado o Inicializador Padrao
						NIL  			,;	//15 -> Lado para o inicializador padrao
						NIL       		,;	//16 -> Opcional, Carregar Todos os Campos
						NIL         	,;	//17 -> Opcional, Nao Carregar os Campos Virtuais
						NIL       		,;	//18 -> Opcional, Utilizacao de Query para Selecao de Dados
						NIL        		,;	//19 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP )
						NIL         	,;	//20 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP )
						.F.      		,;	//21 -> Carregar Coluna Fantasma
						NIL           	,;	//22 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
						NIL      		,;	//23 -> Verifica se Deve Checar se o campo eh usado
						NIL      		,;	//24 -> Verifica se Deve Checar o nivel do usuario
						NIL          	,;	//25 -> Verifica se Deve Carregar o Elemento Vazio no aCols
						NIL       		,;	//26 -> [@]Array que contera as chaves conforme recnos
						.F.        		,;	//27 -> [@]Se devera efetuar o Lock dos Registros
						.F.     		,;	//28 -> [@]Se devera obter a Exclusividade nas chaves dos registros
						NIL      		 ;	//29 -> Numero maximo de Locks a ser efetuado
					)

/*
Ŀ
 Salva o Conteudo Inicial do aCols para comparacao na Gravacao
*/
aColsAnt := aClone( aCols )

/*
Ŀ
 Monta as Dimensoes dos Objetos         					   
*/
aAdvSize		:= MsAdvSize()
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
aAdd( aObjCoords , { 000 , 025 , .T. , .F. } )
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

/*
Ŀ
 Define o Bloco para o <Ctrl-O>					   
*/
bSet15 := { || IF(;
					oGet:TudoOk();
					.and.;
					Chk_Tipo( nOpcX , Subst( cTipoArred , 1 , 1 ) , cTurno ),;
					(;
						nOpcA := 1,;
						oDlg:End();
					),;
					(;
						nOpcA := 0,;
						.F.;
					);
				 );
			}
/*
Ŀ
 Define o Bloco para o <Ctrl-X>					   
*/
bSet24 := { || nOpcA := 0 , oDlg:End() }

/*
Ŀ
 Mostra o corpo dos Arredondamentos  ( Inclusao )     
*/
DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0027) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL // "Incluir - Arredondamentos"
	
	@ aObjSize[1,1], aObjSize[1,2] 		GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]*0.25	LABEL OemToAnsi(STR0024) OF oDlg PIXEL	// "Turno:"
	oGroup:oFont:= oFont
	@ aObjSize[1,1], aObjSize[1,4]*0.255 	GROUP oGroup TO aObjSize[1,3],aObjSize[1,4]			LABEL OemToAnsi(STR0015) OF oDlg PIXEL	// 'Tipo:'
	oGroup:oFont:= oFont

	@ aObjSize[1,1]+10, aObjSize[1,2]*2.5	MSGET		cTurno PICTURE PesqPict("SPD","PD_TURNO") F3 "SR6" Valid If(!Empty(cTurno),ExistCpo('SR6'),.T.) SIZE 050,10 OF oDlg PIXEL FONT oFont HASBUTTON
	@ aObjSize[1,1]+10, aObjSize[1,4]*0.27	COMBOBOX	cTipoArred ITEMS aCombo Valid Chk_Tipo( nOpcx , Subst( cTipoArred , 1 , 1 ), cTurno ) SIZE 146,10 OF oDlg PIXEL FONT oFont
	
	oGet := MSGetDados():New(aObjSize[2,1],aObjSize[2,2],aObjSize[2,3],aObjSize[2,4],nOpcx,"Pona110LinOk" ,"Pona110TudOk" ,"",.T.,,,,,,,,,oDlg)
	
ACTIVATE MSDIALOG oDlg ON INIT Eval( bDialogInit ) CENTERED

IF ( nOpcA == 1 )
	Begin Transaction
		Pona110Grava(cAlias)
		//Processa Gatilhos
		EvalTrigger()
	End Transaction
EndIF

/*
Ŀ
 Libera a Reserva de Codigo                           
*/
FreeLocks( "SPD" , NIL , .T. )

Return( NIL )

/*/


Ŀ
Funo    Pona110Alt Autor  Wiliam R. Bertoncini   Data  22.07.96 
Ĵ
Descrio  Programa de Alteracao dos tipos de hora extra              
Ĵ
Sintaxe   Pona110Alt(ExpC1,ExpN1,ExpN2)                               
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       pona110                                                    
ٱ

*/
Static Function Pona110Alt(cAlias,nReg,nOpcX)

Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aRecnos		:= {}
Local bSet15		:= { || .T. }
Local bSet24		:= { || .T. }
Local bDialogInit	:= { || EnchoiceBar( oDlg , bSet15 , bSet24 ) }
Local cDesc			:= Space(20)
Local cFilSPD		:= xFilial( "SPD" )
Local cKeys			:= ""
Local nCnt			:= 0
Local nOpcA			:= 0
Local oDlg
Local oGet
Local oFont
Local oGroup

Private cTipoArred  := SPD->PD_TIPO
Private cTurno		:= SPD->PD_TURNO

Private aTela
Private aGets
Private aHeader
Private nUsado
Private aCols
Private aColsAnt

Begin Sequence

	/*
	Ŀ
	 Nao Permite Alteracao em Arquivo Vazio				   	   
	*/
	IF !( ChkVazio("SPD") )
   		Break
	EndIF

	/*
	Ŀ
	 Reserva o Codigo e Carrega Descricao					   	   
	*/
	IF !Chk_Tipo( nOpcX , cTipoArred, cTurno , @cDesc , .F.  )
		Break
	EndIF

	/*
	Ŀ
	 Carrega os Dados no aCols  							   	   
	*/
	cKey := ( cFilSPD+cTipoArred+cTurno )
	aCols := GdMontaCols(	@aHeader		,;	//01 -> Array com os Campos do Cabecalho da GetDados
							@nUsado			,;	//02 -> Numero de Campos em Uso
							NIL     		,;	//03 -> [@]Array com os Campos Virtuais
							NIL    			,;	//04 -> [@]Array com os Campos Visuais
							cAlias			,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
							NIL       		,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
							@aRecnos		,;	//07 -> [@]Array unidimensional contendo os Recnos
							cAlias		   	,;	//08 -> Alias do Arquivo Pai
							cKey			,;	//09 -> Chave para o Posicionamento no Alias Filho
							NIL 			,;	//10 -> Bloco para condicao de Loop While
							NIL  			,;	//11 -> Bloco para Skip no Loop While
							.T.     		,;	//12 -> Se Havera o Elemento de Delecao no aCols 
							.T.     		,;	//13 -> Se cria variaveis Publicas
							.T.     		,;	//14 -> Se Sera considerado o Inicializador Padrao
							NIL  			,;	//15 -> Lado para o inicializador padrao
							NIL       		,;	//16 -> Opcional, Carregar Todos os Campos
							NIL         	,;	//17 -> Opcional, Nao Carregar os Campos Virtuais
							NIL       		,;	//18 -> Opcional, Utilizacao de Query para Selecao de Dados
							NIL        		,;	//19 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP )
							NIL         	,;	//20 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP )
							.F.      		,;	//21 -> Carregar Coluna Fantasma
							NIL           	,;	//22 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
							NIL      		,;	//23 -> Verifica se Deve Checar se o campo eh usado
							NIL      		,;	//24 -> Verifica se Deve Checar o nivel do usuario
							NIL          	,;	//25 -> Verifica se Deve Carregar o Elemento Vazio no aCols
							NIL       		,;	//26 -> [@]Array que contera as chaves conforme recnos
							.F.        		,;	//27 -> [@]Se devera efetuar o Lock dos Registros
							.F.     		,;	//28 -> [@]Se devera obter a Exclusividade nas chaves dos registros
							NIL      		 ;	//29 -> Numero maximo de Locks a ser efetuado
						)

	/*
	Ŀ
	 Se nao Existirem Registros								   
	*/
	IF ( Len( aRecnos ) == 0 )
	   Help(" ",1,"A040SLANC")
	   Break
	EndIF

	/*
	Ŀ
	 Salva o Conteudo Inicial do aCols para comparacao na Gravacao
	*/
	aColsAnt := aClone( aCols )

	/*
	Ŀ
	 Monta as Dimensoes dos Objetos         					   
	*/
	aAdvSize		:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
	aAdd( aObjCoords , { 000 , 025 , .T. , .F. } )
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )
	/*
	Ŀ
	 Mostra o corpo dos Arredondamentos  ( Alteracao )    
	*/
	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0028) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL // "Alteracao - Arredondamentos"
		
		@ aObjSize[1,1], aObjSize[1,2] 		GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]*0.10	LABEL OemToAnsi(STR0024) OF oDlg PIXEL	// "Turno:"
		oGroup:oFont:= oFont
		@ aObjSize[1,1], aObjSize[1,4]*0.105 	GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]*0.20	LABEL OemToAnsi(STR0015) OF oDlg PIXEL	// 'Tipo:'
		oGroup:oFont:= oFont
		@ aObjSize[1,1], aObjSize[1,4]*0.205 	GROUP oGroup TO aObjSize[1,3],aObjSize[1,4]			LABEL OemToAnsi(STR0033) OF oDlg PIXEL	// "Descrio:"
		oGroup:oFont:= oFont
		
		@ aObjSize[1,1]+10, aObjSize[1,2]*2.5	SAY cTurno		PICTURE PesqPict("SPD","PD_TURNO")	SIZE 050,10 OF oDlg PIXEL FONT oFont
		@ aObjSize[1,1]+10, aObjSize[1,4]*0.12	SAY cTipoArred	PICTURE PesqPict("SPD","PD_TIPO")	SIZE 146,10 OF oDlg PIXEL FONT oFont
		@ aObjSize[1,1]+10, aObjSize[1,4]*0.22	SAY cDesc		PICTURE "@!"						SIZE 150,10 OF oDlg PIXEL FONT oFont
		
		oGet := MSGetDados():New(aObjSize[2,1],aObjSize[2,2],aObjSize[2,3],aObjSize[2,4],nOpcx,"Pona110LinOk" ,"Pona110TudOk" ,"",.T.,,,,,,,,,oDlg)
        
		bSet15 := { || IF( oGet:TudoOk() , ( nOpcA := 1 , oDlg:End() ) , ( nOpcA := 0 , .T. ) ) }
		bSet24 := { || nOpcA := 0 , oDlg:End() }
		
	ACTIVATE MSDIALOG oDlg ON INIT Eval( bDialogInit ) CENTERED
	
	IF ( nOpcA == 1 )
	   Begin Transaction
	      Pona110Grava( cAlias , aRecnos )
	      //Processa Gatilhos
	      EvalTrigger()
	   End Transaction
	EndIF

End Sequence

/*
Ŀ
 Libera a Reserva de Codigo                           
*/
FreeLocks( "SPD" , NIL , .T. )

Return( NIL )

/*/


Ŀ
Funo    Pona110Del Autor  Wiliam R. Bertoncini   Data  22.07.96 
Ĵ
Descrio  Programa de Delecao   dos tipos de hora extra              
Ĵ
Sintaxe   Pona110Del(ExpC1,ExpN1,ExpN2)                               
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       pona110                                                    
ٱ

*/
Static Function Pona110Del(cAlias,nReg,nOpcX)

Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aRecnos		:= {}
Local bSet15		:= { || .T. }
Local bSet24		:= { || .T. }
Local bDialogInit	:= { || EnchoiceBar( oDlg , bSet15 , bSet24 ) }
Local cTipoArred	:= SPD->PD_TIPO
Local cTurno		:= SPD->PD_TURNO
Local cDesc			:= Space( 20 )
Local cFilSPD		:= xFilial( "SPD" )
Local cMsgErr		:= ""
Local nCnt			:= 0
Local nOpcA			:= 0
Local oDlg
Local oGet
Local oFont
Local oGroup

Private aTela
Private aGets
Private aHeader
Private nUsado
Private aCols

Begin Sequence

	/*
	Ŀ
	 Nao Permite Alteracao em Arquivo Vazio				   	   
	*/
	IF !( ChkVazio("SPD") )
	   Break
	EndIF

	/*
	Ŀ
	 Reserva o Codigo e Carrega Descricao					   	   
	*/
	IF !Chk_Tipo( nOpcX , cTipoArred , cTurno , @cDesc , .F. )
		Break
	EndIF

	/*
	Ŀ
	 Carrega os Dados no aCols  							   	   
	*/
	cKey := ( cFilSPD+cTipoArred+cTurno )
	aCols := GdMontaCols(	@aHeader		,;	//01 -> Array com os Campos do Cabecalho da GetDados
							@nUsado			,;	//02 -> Numero de Campos em Uso
							NIL     		,;	//03 -> [@]Array com os Campos Virtuais
							NIL    			,;	//04 -> [@]Array com os Campos Visuais
							cAlias			,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
							NIL       		,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
							@aRecnos		,;	//07 -> [@]Array unidimensional contendo os Recnos
							cAlias		   	,;	//08 -> Alias do Arquivo Pai
							cKey			,;	//09 -> Chave para o Posicionamento no Alias Filho
							NIL 			,;	//10 -> Bloco para condicao de Loop While
							NIL  			,;	//11 -> Bloco para Skip no Loop While
							.T.     		,;	//12 -> Se Havera o Elemento de Delecao no aCols 
							.T.     		,;	//13 -> Se cria variaveis Publicas
							.T.     		,;	//14 -> Se Sera considerado o Inicializador Padrao
							NIL  			,;	//15 -> Lado para o inicializador padrao
							NIL       		,;	//16 -> Opcional, Carregar Todos os Campos
							NIL         	,;	//17 -> Opcional, Nao Carregar os Campos Virtuais
							NIL       		,;	//18 -> Opcional, Utilizacao de Query para Selecao de Dados
							NIL        		,;	//19 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP )
							NIL         	,;	//20 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP )
							.F.      		,;	//21 -> Carregar Coluna Fantasma
							NIL           	,;	//22 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
							NIL      		,;	//23 -> Verifica se Deve Checar se o campo eh usado
							NIL      		,;	//24 -> Verifica se Deve Checar o nivel do usuario
							NIL          	,;	//25 -> Verifica se Deve Carregar o Elemento Vazio no aCols
							NIL       		,;	//26 -> [@]Array que contera as chaves conforme recnos
							.F.        		,;	//27 -> [@]Se devera efetuar o Lock dos Registros
							.F.     		,;	//28 -> [@]Se devera obter a Exclusividade nas chaves dos registros
							NIL      		 ;	//29 -> Numero maximo de Locks a ser efetuado
						)

	/*
	Ŀ
	 Se nao Existirem Registros								   
	*/
	IF ( Len( aRecnos ) == 0 )
	   Help(" ",1,"A040SLANC")
	   Break
	EndIF

	/*
	Ŀ
	 Monta as Dimensoes dos Objetos         					   
	*/
	aAdvSize		:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
	aAdd( aObjCoords , { 000 , 025 , .T. , .F. } )
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )
	
	/*
	Ŀ
	 Mostra o corpo dos Arredondamentos  ( Exclusao )     
	*/
	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0031) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL // "Exclusao - Arredondamentos"
				
		@ aObjSize[1,1], aObjSize[1,2] 		GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]*0.10	LABEL OemToAnsi(STR0024) OF oDlg PIXEL	// "Turno:"
		oGroup:oFont:= oFont
		@ aObjSize[1,1], aObjSize[1,4]*0.105 	GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]*0.20	LABEL OemToAnsi(STR0015) OF oDlg PIXEL	// 'Tipo:'
		oGroup:oFont:= oFont
		@ aObjSize[1,1], aObjSize[1,4]*0.205 	GROUP oGroup TO aObjSize[1,3], aObjSize[1,4]		LABEL OemToAnsi(STR0033) OF oDlg PIXEL	// "Descrio:"
		oGroup:oFont:= oFont
		
		@ aObjSize[1,1]+10, aObjSize[1,2]*2.5	SAY cTurno		PICTURE PesqPict("SPD","PD_TURNO")	SIZE 050,10 OF oDlg PIXEL FONT oFont
		@ aObjSize[1,1]+10, aObjSize[1,4]*0.12	SAY cTipoArred	PICTURE PesqPict("SPD","PD_TIPO")	SIZE 146,10 OF oDlg PIXEL FONT oFont
		@ aObjSize[1,1]+10, aObjSize[1,4]*0.22	SAY cDesc		PICTURE "@!"						SIZE 150,10 OF oDlg PIXEL FONT oFont
		
		oGet := MSGetDados():New(aObjSize[2,1],aObjSize[2,2],aObjSize[2,3],aObjSize[2,4], nOpcx,,,"",.F.,,,,,,,,,oDlg)
		
		bSet15 := { || nOpcA := 2 , oDlg:End() }
		bSet24 := { || nOpcA := 0 , oDlg:End() }
		
	ACTIVATE MSDIALOG oDlg ON INIT Eval( bDialogInit ) CENTERED

	If ( nOpcA == 2 )
		Begin Transaction
			PonDelRecnos( cAlias , @aRecnos )
		End Transaction
	Endif

End Sequence

/*
Ŀ
 Libera a Reserva de Codigo                           
*/
FreeLocks( "SPD" , NIL , .T. )

Return( NIL )

/*/


Ŀ
Funo    Pona110LinOkAutor Wiliam R. Bertoncini   Data  22.07.96 
Ĵ
Descrio Critica linha digitada                                      
Ĵ
 Uso       Generico                                                   
ٱ

*/
Function Pona110LinOk(o)

Local lRet	:= .T.

Begin Sequence

	If !aCols[n,nUsado+1]
	
	   	//-- Nao permite campos em branco
	   	If  fVazio(n)
			lRet := .F.
			Break
		Endif
			
	    If ( aCols[n,1] > aCols[n,2] )
			Help(" ",1,"GR200FAIXA")
			lRet := .F.
			Break
		Endif
		
		If ( n > 1 )
			If aCols[n,1] <= aCols[n-1,2]
				Help(" ",1,"GR200FAIXA")
				lRet := .F.
				Break
			Endif
		Endif
	Endif

End Sequence

Return( lRet )

/*/


Ŀ
Funo    Pona110TudOkAutor Wiliam R. Bertoncini   Data  22.07.96 
Ĵ
Descrio                                                             
Ĵ
 Uso       Generico                                                   
ٱ

*/
Function Pona110TudOk(o)

Local lRet  := .T.

Local nDelete
Local nx
Local nw

Continua 	:= .F.

nw 		:= Len(aCols)
nDelete	:= ( nUsado + 1 )
For nx := 1 To nw

    If !aCols[ nx , nDelete ]
       
       	//-- Nao permite campos em branco
	   	If  fVazio(nx)
			lRet := .F.
			Break
		Endif
        

        If ( aCols[nx,1] > aCols[nx,2] )
            Help(" ",1,"GR200FAIXA")
            lRet := .F.
            Exit
        Endif

        If ( nx > 1 )
            If aCols[nx,1] <= aCols[nx-1,2]
                Help(" ",1,"GR200FAIXA")
                lRet := .F.
                Exit
            Endif
        Endif
    
    Endif

Next nx

Return( lRet )   

/*


Ŀ
Funo    fVazio     Autor  Mauricio MR            Data  18/06/04 
Ĵ
Descrio  Valida Colunas em Branco                                   
Ĵ
 Uso       Generico                                                   
ٱ

*/
Static Function fVazio(nline)      
Local lRet	:= .F.
If  !GDNOEMPTY({'PD_DE','PD_ATE'},nline)
    lRet:= .T.
Endif     

Return lRet 

/*/

Ŀ
Funo    Pona110GravaAutor Wiliam R. Bertoncini   Data  22.07.96 
Ĵ
Descrio  Grava no arquivo de Valores Variaveis                      
Ĵ
 Uso      Pona110Grava                                                
ٱ

*/
Static Function Pona110Grava(cAlias,aRegAltera)

Local cFilSPD	:= xFilial( "SPD" )

Local cMsgErr
Local nX
Local nY
Local nW
Local nZ
Local nDeleted
Local lTudoIgual

Begin Sequence

	IF ( lTudoIgual := fCompArray( aCols , aColsAnt ) )
		Break
	EndIF

	nDeleted := ( nUsado + 1 )

	Begin Transaction
		
		dbSelectArea(cAlias)
		
		IF !Empty( aRegAltera )

			nW := Len(aRegAltera)
			nZ := Len(aHeader)
				
			For nX := 1 To nW
	
				lTudoIgual := fCompArray( aCols[ nX ] , aColsAnt[ nX ] )
				IF ( ( lTudoIgual ) .and. !( aCols[ nX , nDeleted ] ) )
					Loop
				EndIF
				
				( cAlias )->( dbGoto( aRegAltera[ nX ] ) )
				
				IF !( RecLock(cAlias,.F.,.T.) )
					Loop
				EndIF
					
				IF ( aCols[ nX , nDeleted ] )
					IF !SPD->( FkDelete( @cMsgErr ) )
						SPD->( RollBackDelTran( cMsgErr ) )
					EndIF
				Else
		           	SPD->PD_FILIAL	:= cFilSPD
		           	SPD->PD_TIPO	:= Subst( cTipoArred , 1 , 1 )
		           	SPD->PD_TURNO	:= cTurno
		           	For nY := 1 To Len(aHeader)
						cCampo		:= Trim(aHeader[nY,2])
						xConteudo	:= aCols[nX,nY]
						&cCampo		:= xConteudo
					Next nY
				EndIF
			Next nX
		
			IF ( Len(aCols) >= nX )	// Se Trata de Inclusao de Itens
				Pona110GrInc( cAlias , nX )
			EndIF
		
		Else
		
			Pona110GrInc( cAlias , 1 )
		
		EndIF
		
	End Transaction

End Sequence
	
Return( .T. )

/*/


Ŀ
Funo    Pona110GrIncAutor Wiliam R. Bertoncini   Data  22.07.96 
Ĵ
Descrio  Grava os registros Incluidos na GetDados                   
Ĵ
 Uso       Pona110Grava                                               
ٱ

*/
Static Function Pona110GrInc( cAlias , nIniciar )

Local cFilSPD	:= xFilial( "SPD" )
Local nDeleted	:= ( nUsado + 1	 )

Local cCampo
Local xConteudo
Local nX
Local nY
Local nW
Local nZ


nW := Len(aCols)
nZ := Len(aHeader)
For nX := nIniciar To nW

	IF !( aCols[ nX , nDeleted ] )
	   
		IF !RecLock( cAlias , .T. )
			Loop
		EndIF
        
        SPD->PD_FILIAL	:= cFilSPD
        SPD->PD_TIPO	:= Subst( cTipoArred , 1 , 1 )
        SPD->PD_TURNO	:= cTurno
		
		For nY := 1 To nZ
			cCampo		:= aHeader[ nY , 2 ]
			xConteudo	:= aCols[ nX , nY ]
			&( cCampo )	:= xConteudo
		Next nY
	
	EndIF

Next nX

Return( NIL )

/*
Ŀ
Funo    Chk_Tipo	 Autor Marinaldo de Jesus     Data 07/03/2002
Ĵ
Descrio Chk_Tipo( nOpc , cTipoArred , cTurno , cDesc , lValid )		 
Ĵ
Sintaxe                               								 
Ĵ
Parametros															 
Ĵ
Retorno                                                          	     
Ĵ
Observao                                                      	     
Ĵ
 Uso      PONA110                                                      
*/
Static Function Chk_Tipo( nOpc , cTipoArred , cTurno , cDesc , lValid )

Local cFilSPD	:= xFilial( "SPD" )
Local cKey		:= ( cFilSPD + cTipoArred + cTurno )
Local lRet		:= .T.

Local nRegSPD

DEFAULT lValid := .T.

cDesc	:= Space( 20 )

IF ( lValid )

	nRegSPD := SPD->( Recno() )

	Begin Sequence

		If !( cTipoArred $ 'HDSANF9' )
		   Help(' ',1,'PN110TIPIN')
		  	lRet := .F.
			Break
		EndIF
		
		IF SPD->( MsSeek( cKey , .F. ) )
			Help(' ',1,'PN110CLANC')
			lRet := .F.
			Break
		EndIF

	End Sequence

	SPD->( MsGoto( nRegSPD ) )

EndIF	

IF ( lRet )
	
	IF ( nOpc <> 2 )
		IF !( lRet := WhileNoLock( "SPD" , NIL , { cKey } , 1 , 1 , .T. , 1 , 10 ) )
			Break
		EndIF	
	EndIF	
	
	IF ( cTipoArred == "A" )
		cDesc := Stuff( cDesc , 01 , Len(STR0016) , STR0016 )	//"Atrasos           "
	ElseIF ( cTipoArred == "S" )
		cDesc := Stuff( cDesc , 01 , Len(STR0017) , STR0017 )	//"Saidas Antecipadas"
	ElseIF ( cTipoArred == "H" )
		cDesc := Stuff( cDesc , 01 , Len(STR0018) , STR0018 )	//"Horas Extras      "
	ElseIF ( cTipoArred == "D" )
		cDesc := Stuff( cDesc , 01 , Len(STR0019) , STR0019 )	//"D.S.R.            "
	ElseIF ( cTipoArred == "F" )
		cDesc := Stuff( cDesc , 01 , Len(STR0032) , STR0032 )	//"Faltas"
	ElseIF ( cTipoArred == "N" )
		cDesc := Stuff( cDesc , 01 , Len(STR0020) , STR0020 )	//"Adic. Noturno     "
	ElseIF ( cTipoArred == "9" )
		cDesc := Stuff( cDesc , 01 , Len(STR0021) , STR0021 )	//"Nona Hora         "
	EndIF
	cDesc := OemToAnsi( cDesc )

EndIF

Return( lRet )

/*
Ŀ
Funo    Pona110Opc	 Autor Marinaldo de Jesus     Data 02/10/2002
Ĵ
Descrio Limpa o Filtro de Browse e Chama a Funcao Correspondente	 
Ĵ
Sintaxe                               								 
Ĵ
Parametros															 
Ĵ
Retorno                                                          	     
Ĵ
Observao                                                      	     
Ĵ
 Uso      PONA110                                                      
*/
Function Pona110Opc( cAlias , nReg , nOpcX )

Local nOpc 	 := 0

(cAlias)->( MsGoto( nReg ) )

IF ( nOpcX == 2 )
	nOpc := Pona110Vis( cAlias , nReg , nOpcX )
ElseIF ( nOpcX == 3 )
	nOpc := Pona110Inc( cAlias , nReg , nOpcX )
ElseIF ( nOpcX == 4 )
	nOpc := Pona110Alt( cAlias , nReg , nOpcX )
ElseIF ( nOpcX == 5 )
	nOpc := Pona110Del( cAlias , nReg , nOpcX )
EndIF

UpdFilter()

IF ( nOpcX <> 3 )
	( cAlias )->( MsGoto( nReg ) )
EndIF	

Return( nOpc )

/*
Ŀ
Funo    Pona110UniqueAutor Marinaldo de Jesus     Data 18/08/2004
Ĵ
Descrio Retorna String Contendo Chave unica para o Filtro do Browse  
Ĵ
Sintaxe   <vide parametros formais>   								 
Ĵ
Parametros<vide parametros formais>   								 
Ĵ
Retorno   Retorna String Contendo Chave unica para o Filtro do Browse  
Ĵ
Observao                                                      	     
Ĵ
Uso       PONA110                                                      
*/
Static Function Pona110Unique()

Local cSpdUnique	:= ""

Local nFields

Static aSpdHeader
Static cUnSvEmpAnt

DEFAULT cUnSvEmpAnt := cEmpAnt
IF ( cUnSvEmpAnt <> cEmpAnt )
	cUnSvEmpAnt := cEmpAnt
	aSpdHeader	:= NIL
EndIF

DEFAULT aSpdHeader	:= GdMontaHeader(@nFields,NIL,NIL,"SPD",{"PD_FILIAL","PD_TURNO","PD_TIPO","PD_DE"},.F.,.T.,.F.,.T.,.F.,.F.,.F.)
DEFAULT nFields		:= Len( aSpdHeader )

IF !Empty( nFields )
	SPD->( UniqueKey( NIL , "SPD" , .T. ) )
	SPD->( dbGotop() )
	While SPD->( !Eof() )
		IF SPD->( UniqueKey( { "PD_FILIAL", "PD_TURNO", "PD_TIPO" }, "SPD" ) )
			cSpdUnique += CValToChar(Recno()) + ", "
		EndIF
		SPD->( dbSkip() )
	End While
	If !Empty(cSpdUnique)
		cSpdUnique := left(cSpdUnique, Len(cSpdUnique) -2)
		cSpdUnique := "R_E_C_N_O_ IN (" + cSpdUnique + ")"
	EndIf
	
EndIF

Return( cSpdUnique )

/*
Ŀ
Funo     MenuDef		Autor  Luiz Almeida      Data 21/11/2006
Ĵ
Descrio Isola opcoes de menu para que as opcoes da rotina possam    
          ser lidas pelas blibliotecas Framework da Versao 9.12 .     
Ĵ
Sintaxe   < Vide Parametros Formais >									
Ĵ
 Uso      PONA110                                                     
Ĵ
 Retorno  aRotina														
Ĵ
Parametros< Vide Parametros Formais >									
*/


Static Function MenuDef()

	Local aRotina :=   { { STR0005 , "PesqBrw"		, 0 ,1, ,.F. },;	// "Pesquisar"
	                     { STR0006 , "Pona110Opc"	, 0 ,2 },;	// "Visualizar"
	                     { STR0008 , "Pona110Opc"	, 0 ,3 },;	// "Incluir"
	                     { STR0010 , "Pona110Opc"	, 0 ,4 },;	// "Alterar"
	                     { STR0012 , "Pona110Opc"	, 0 ,5 } ;	// "Excluir"
	                    } 

Return aRotina


/*/{Protheus.doc} UpdFilter
Atualiza o filtro utilizado no Browse
@type  Static Function
@author Ccero Alves
@since 03/08/2021
@see https://tdn.totvs.com/x/XP1n
/*/
Static Function UpdFilter()
	
	_oObj := GetObjBrow()
	
	Eval( bFiltraBrw )
	SetMBTopFilter("SPD", Pona110Unique(), .T.)
	_oObj:ResetLen()
	_oObj:Gotop()
	_oObj:Refresh()
	
Return
