#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEXFORM.CH"
#INCLUDE "APDTREEN.CH"
#INCLUDE "COMPILE.CH"          

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Statics utilizadas no Processo de Calculo e Na Montagem    de³
³ Formulas e Roteiros ( Sao Reinicializadas atraves da  chamada³
³ aa Funcao RstExecCalc()									   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __aMnemonicos	:= {}  					//Array das variaveis usadas no calculo
Static __aLocal			:= {}					//Armazena as Locais para a Montagem das Formulas
Static _aGetTreeErr		:= {}					//Array com os Erros na Montagem das Formulas
Static _aLogExecRot		:= {}					//Array com os Logs na Execucao do Roteiro
Static __aRotErr		:= {}					//Array com os Erros de Roteiro de Calculo
Static __aMnemError		:= {}					//Array com os Mnemonicos que possuem inicializadores com erro

Static __bFunRotExec	:= NIL					//Funcao de Roteiro Compilada

Static __cFunRotExec	:= "__cFunRotExec"		//Funcao de Roteiro a ser Executada
Static __cRotInExec		:= "__cRotInExec"		//Roteiro que esta sendo executado
Static __cGetRotExec	:= "__cGetRotExec"		//Roteiro a Ser Executado
Static __cRotFilial		:= "__cRotFilial"		//Filial Selecao do Roteiro Roteiro
Static __cRpoForm		:= "RpoForm_No_Init"	//Armazena o Nome do Ultimo Rpo de Formulas Utilizado
Static __cLastRotExec	:= "__cLastRotExec"		//Ultimo Roteiro Executado

Static __lEndCalc		:= .F.					//Variavel de Controle de encerramento do calculo tratado na formula
Static __lNoPrcReg		:= .F.					//Variavel de Controle para desprezar o funcionario no calculo
Static __lCriaLocal		:= .T.					//Variavel para Controle de Inclusao de Variaveis Locais
Static __IsInDebbug		:= .F.					//Verifica se Esta em Processo de Debbug
Static __lInitFrm		:= .T.					//Verifica se Deve Inicializar e Compilar as Formulas
Static __lFilRPO								//Indica se deve compilar roteiros por filial. Padrão é falso, compilação é por grupo de empresas. Desenvolvido para TMF.

Static __oRpoForm		:= NIL					//Objeto Repositorio para a Compilacao das Formulas
Static lRefTrab			:= FindFunction("fRefTrab") .And. fRefTrab("R")
Static cBuildVer		:= GetSrvVersion()
/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GPEXFORM  ³ Autor ³ Marinaldo de Jesus    ³ Data ³10/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Biblioteca de Funcoes Genericas para uso em Formulas        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Generico                                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Programador ³ Data     ³ BOPS  ³Motivo da Alteracao                    ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Leandro Dr. ³27/09/2012|M12RH01|Requisito RHU210- Unificação das folhas³
³Allyson M   ³01/09/2015| TSZEC3|Ajuste em GetFunRot() p/ forcar o      ³
³            ³          |       |posicionamento em SRY.      			³
³Gustavo M   ³24/02/2016| TUKUJ3|Ajuste na performance da rotina.       ³
³Raquel Hager³26/01/2016|MRH-5214|Realizado ajuste para simular a       ³
³            ³          |        |compilação de fórmula e validar se    ³
³            ³          |        |ela está em uso por roteiro de cálculo³
³Renan Borges³21/02/2017³MRH-6779³Ajuste para gerar o repositório de for³
³            ³        	³        ³mulas corretamente, quando for gerado ³
³            ³        	³        ³a partir de uma rotina de cálculo.    ³
³            ³        	³        ³Além disso foi disponibilizado a opção³
³            ³        	³        ³de recompilar tudo na rotina de Rotei-³
³            ³        	³        ³ros de cálculos, que só será possível ³
³            ³        	³        ³a recompilação quando estiver exclusi-³
³            ³        	³        ³vo o rpo de fórmulas.                 ³
³Gabriel A.  ³16/03/2017³MRH-8494³Ajuste para que ao executar o cálculo ³
³            ³          ³        ³unificado, não seja validada a        ³
³            ³          ³        ³exclusividade das fórmulas, pois ele é³
³            ³          ³        ³executado em múltiplas threads.       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/
/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RstExecCalc	  ³Autor ³Marinaldo de Jesus   ³ Data ³07/15/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Reinicializar as Static utilizadas no GPEXFORM toda vez   que³
³          ³Retornar ao Menu											 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                    	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/
Function RstExecCalc( lReset )

Default lReset := .T.

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Statics utilizadas no Processo de Calculo e Na Montagem     de³
³Formulas e/ou Roteiros									       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/
__cRotFilial	:= "__cRotFilial"
__cGetRotExec	:= "__cGetRotExec"
__cFunRotExec	:= "__cFunRotExec"
__cLastRotExec	:= "__cLastRotExec"
__bFunRotExec	:= NIL
__lEndCalc		:= .F.
__lNoPrcReg		:= .F.
__lInitFrm		:= .T.
__lCriaLocal	:= .T.
__cKeyAux		:= ""

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Restaura a variavel __acodfol para carregar novamente em outro³
³situacao.                 					       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If lReset
	RstaCodFol()
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Funcao Reinicializadora de Statics utilizadas no Calculo  e na³
³Montagem de Formulas e/ou Roteiros							   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
SetDebbug()
SetLocal()
GetTreeErr()
LogExecRot()
If lReset
	RstMnemonicos()
EndIf
SetRotExec( "__cRotInExec" )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carrega as Funcoes em Assembler Nao Localizadas pela  FindFunc³
³tion()														   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
GetAsmFunc()

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carrega as Palavras Reservadas								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
GetReservedWords()

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Inicializa a Static __IniFormPad__ no Gpea290()			   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Gpea290FrmInit()

If Select("SX3") > 0
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Inicializa a Static __cPeriodCalc no Gpem020()			   	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	SetPeriodCalc( Space( GetSx3Cache( "RCH_PER" , "X3_TAMANHO" ) ) )
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Inicializa a Static __cProcesCalc no Gpem020()			   	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	SetProcesCalc( Space( GetSx3Cache( "RCH_PROCES" , "X3_TAMANHO" ) ) )
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Inicializa a Static __cNumPgCalc no Gpem020()			   	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	SetNumPgCalc( Space( GetSx3Cache( "RCH_NUMPAG" , "X3_TAMANHO" ) ) )
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Restaura as variaveis do Novo Modelo de Calculo		 	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If MV_MODFOL == '2'
	RstNewCalc()
EndIf

IF ( FindFunction( "RstHashSRV" ) ) //Limpa hash com dados da SRV
	RstHashSRV()
EndIf

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³InitLogExecRot³Autor ³Marinaldo de Jesus   ³ Data ³02/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializa o Array com Informacoes do Roteiro				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                    	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function InitLogExecRot()

_aLogExecRot := Array( 4 , 2 )
_aLogExecRot[ 1 , 1 ] := STR0034	//"Erro de Carga de Mnemonicos"
_aLogExecRot[ 1 , 2 ] := {}
_aLogExecRot[ 2 , 1 ] := STR0035	//"Erro de Carga de Formulas"
_aLogExecRot[ 2 , 2 ] := {}
_aLogExecRot[ 3 , 1 ] := STR0036	//"Ocorreu erro na compilacao ou Execucao do Roteiro"
_aLogExecRot[ 3 , 2 ] := {}
_aLogExecRot[ 4 , 1 ] := STR0046	//"Log de Calculo" ( Gerado pela funcao AddLogExecRot() )
_aLogExecRot[ 4 , 2 ] := {}

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³SetDebbug	  ³Autor ³Marinaldo de Jesus   ³ Data ³10/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Seta Variavel __IsInDebbug que sera utilizada pela IsDebbug()³
³          ³para Identificar se o Processo de Formula Esta em Modo Debbug³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³__IsInDebbug                                           	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function SetDebbug( lSet )

Local lLastSet

DEFAULT lSet 			:= .F.
DEFAULT __IsInDebbug	:= .F.

lLastSet		:= __IsInDebbug
__IsInDebbug	:= lSet

Return( lLastSet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³IsDebbug	  ³Autor ³Marinaldo de Jesus   ³ Data ³10/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica se Esta em Modo Debbug			                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³__IsInDebbug                                           	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function IsDebbug()
DEFAULT __IsInDebbug := .F.
Return( __IsInDebbug )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³AbortProc	  ³Autor ³Marinaldo de Jesus   ³ Data ³11/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica se Houve Cancelamento do Processo de Calculo		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³__IsInDebbug                                           	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function AbortProc()

Local lAbortProc

Begin Sequence

	IF (;
			lAbortProc := (;
								( Type( "lAbortPrint" ) == "L" );
								.and.;
								( lAbortPrint );
						  );
		)
		EndCalc()
		Break
	EndIF

	IF ( lAbortProc := __lEndCalc )
		Break
	EndIF

	IF ( lAbortProc := __lNoPrcReg )
		Break
	EndIF

End Sequence

Return( lAbortProc )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³FimEnquanto	  ³Autor ³Marinaldo de Jesus   ³ Data ³14/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inclui um Exit em um Laco Enquanto ( While ) na Formula		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³.T.			                                           	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³Forcar a Saida em um Laco Enquanto ( While ) na Formula		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function FimEnquanto()
Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³FimFormula	  ³Autor ³Marinaldo de Jesus   ³ Data ³14/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inclui um Break na Formula		 							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³.T.			                                           	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³Forcar a Finalizacao da Formula		 						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function FimFormula()
Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RetorneEnq	  ³Autor ³Marinaldo de Jesus   ³ Data ³14/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inclui um Loop em um Laco Enquanto ( While ) na Formula		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³.T.			                                           	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                               		 						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RetorneEnq()
Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³EndCalc	  	  ³Autor ³Marinaldo de Jesus   ³ Data ³10/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Seta a Finalizacao do processo de Calculo		             ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³__IsInDebbug                                           	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function EndCalc()
fFunExec()
Return( __lEndCalc := .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³IfDefTop	  ³Autor ³Mauricio T. Takakura ³ Data ³13/01/2006³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Incluir condicao para TOP 		 							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³.T.			                                           	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³Permitir incluir a definicao IFDEF TOP						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function IfDefTop()

Local lTop

#IFDEF TOP
	lTop := .T.
#ELSE
	lTop := .F.
#ENDIF

Return( lTop )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³IsEndCalc	  ³Autor ³Marinaldo de Jesus   ³ Data ³10/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica se Setou a Finalizacao do processo de Calculo		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³__IsInDebbug                                           	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function IsEndCalc()

Local IsEndCalc := __lEndCalc
IF ( IsEndCalc )
	__lEndCalc := .F.
EndIF
Return( IsEndCalc )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³NoPrcReg	  ³Autor ³Marinaldo de Jesus   ³ Data ³10/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Seta o Nao Processamento do Registro Corrente				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³__IsInDebbug                                           	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function NoPrcReg()
fFunExec()
Return( __lNoPrcReg := .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³IsNoPrcReg	  ³Autor ³Marinaldo de Jesus   ³ Data ³10/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica se Setou para Desprezar o Registro no Processo    de³
³          ³Calculo														 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³__IsInDebbug                                           	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function IsNoPrcReg()
Local lIsNoPrcReg := __lNoPrcReg
IF ( lIsNoPrcReg )
	__lNoPrcReg := .F.
EndIF
Return( lIsNoPrcReg )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetTreeErr	  ³Autor ³Marinaldo de Jesus   ³ Data ³10/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Array Unidimensional com as Strings dos Erros  Ocorri³
³          ³dos Durante a Compilacao das Formulas						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³aTreeErr													 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³Reinicializa _aGetTreeErr a Cada Chamada					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetTreeErr()

Local aTreeErr := aClone( _aGetTreeErr )

DEFAULT _aGetTreeErr := {}

aTreeErr		:= aClone( _aGetTreeErr )
_aGetTreeErr	:= {}

Return( aTreeErr )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³AddTreeErr	  ³Autor ³Marinaldo de Jesus   ³ Data ³10/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Adiciona String de Erro aa _aGetTreeErr						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL     													 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                         					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function AddTreeErr( cErr )

Local aErr

Local nErr		:= Len( cErr )

DEFAULT _aGetTreeErr := {}

IF ( nErr > 220 )
	aErr := {}
	While ( nErr > 220 )
		aAdd( aErr , SubStr( cErr , 1 , 220 ) )
		cErr := SubStr( cErr , 221 )
		IF ( ( nErr := Len( cErr ) ) < 220 )
			aAdd( aErr , cErr )
			Exit
		EndIF
	End While
	aEval( aErr , { |cErr| AddTreeErr( cErr ) } )
ElseIF ( aScan( _aGetTreeErr , { |x| x == cErr } ) == 0 )
	aAdd( _aGetTreeErr , cErr )
EndIF	

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³DelFunRot	  ³Autor ³Marinaldo de Jesus   ³ Data ³23/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem Roteiro a Ser Executado           					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL     													 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                         					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function DelFunRot( cSryFilial , cRoteiro )
Return( GetFunRot( cSryFilial , cRoteiro , .F. , NIL , .F. , NIL ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetFunRot	  ³Autor ³Marinaldo de Jesus   ³ Data ³23/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem Funcao do Roteiro a Ser Executado           			 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL     													 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                         					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetFunRot(	cSryFilial	,;	//01 -> Filial do SRY ( Cabecalho de Roteiro de Calculo )
					cRoteiro	,;	//02 -> Codigo do Roteiro de Calculo
					lCompile	,;	//03 -> .T. para Compilar, .F. para Remover o Codigo
					cSrc		,;	//04 -> Codigo do Programa ( Por Referencia )
					lInitPadrao	,;	//05 -> Se devera inicializar os Roteiros Padroes
					oRpoForm	,;	//06 -> Objeto Repositorio
					lInclui		,;	//07 -> Se Esta Efetuando a Inclusao de Novo Roteiro
					lEmptyRpo	,;  //08 -> Se o RPO esta vazio, acumula os roteiros para compilar de uma única vez
					aRotComp	,;  //09 -> Lista os roteiros que serão compilados
					lSimula		,;  //10 -> Simula se o roteiro está em uso
					lGP290REPL	,;  //11 -> Indica se está na função de réplica de fórmulas
					aRotBkp		,;  //12 -> Array com os roteiros da SRY
					aSRYHBKP	,;  //13 -> Array com o Header da SRY
					aSRMHBkp	,;  //14 -> Array com o Header da SRM
					aSYPHBkp	 ;  //15 -> Array com o Header da SYP
				  )
         
Local aFunRot
Local aMsgErr
Local aRotPadrao
Local aPrgsCompile

Local cIdent
Local cPrgFile
Local cFunction    := ""
Local cSourcePath
Local cFormula

Local nLoop
Local nLoops
Local nHandle
Local nSryOrder
Local nSrmOrder

DEFAULT lEmptyRpo 	:= .F.
DEFAULT lSimula   	:= .F.
DEFAULT lGP290REPL  := .F.
DEFAULT aRotBkp		:= {}
DEFAULT aSRYHBKP	:= {}
DEFAULT aSRMHBkp	:= {}
DEFAULT aSYPHBkp	:= {}

Begin Sequence

	IF Empty( cRoteiro )
		RotAddErr( STR0037 )	//"Nao Foi Informado Roteiro para Calculo."
		RotAddErr( STR0038 )	//"Sera necessario informar um Roteiro Valido."	
		Break
	EndIF

	nSryOrder	:= RetOrder( "SRY" , "RY_FILIAL+RY_CALCULO" )
	SRY->( dbSetOrder( nSryOrder ) )
	cRoteiro	:= Padr( Upper( AllTrim( cRoteiro ) ) , GetCache( "SX3" , "RY_CALCULO" , NIL , "X3_TAMANHO" , 2 , .F. ) )
	DEFAULT lInitPadrao := .T.
	IF ( lInitPadrao )
		lInitPadrao := .F.
		If !lGP290REPL
			fGeraRoteiro( NIL , @aRotPadrao , .T. )
		EndIf
		IF lGP290REPL .Or. ( aScan( aRotPadrao , { |aRotPadrao| ( aRotPadrao[1] == cRoteiro ) } ) > 0 )
			Gpea160RotGer( .F., Nil, lGP290REPL, aRotBkp, aSRYHBKP, aSRMHBkp, aSYPHBkp, cRoteiro )
		EndIF
	EndIF
	
	DEFAULT lInclui := .F.
	IF !( lInclui )
		IF SRY->( !MsSeek( cSryFilial + cRoteiro , .F. ) )
			RotAddErr( STR0039 )	//"O Roteiro Informado para Calculo nao e valido."
			RotAddErr( STR0038 )	//"Sera necessario informar um Roteiro Valido."	
			Break
		EndIF
	EndIF	

	cFunction	:= RotGetFunc( @cSryFilial , cRoteiro , IF( lInclui , GetMemVar( "RY_ORIGEM" ) , SRY->RY_ORIGEM ) )
	IF ( lInclui )
		Break
	Else
		SRY->( dbSeek( cSryFilial + cRoteiro ) )
	EndIF

	DEFAULT lCompile := .T.
	IF ( lCompile )

		IF (;
				( SRY->RY_RECOMP == "2" );		//Compilado
				.and.;
				IsFunction( cFunction );		//Ja Existe a Funcao no Repositorio
				.and.;
				( cSryFilial == __cRotFilial );	//Nao Trocou de Filial
				.and.;
				( cRoteiro == __cGetRotExec );	//Nao Trocou de Roteiro
				.and.;
				!ErrorInRot();					//Nao Existe Erro Pendente
			)
			Break
		EndIF

		__cRotFilial	:= cSryFilial
		__cGetRotExec	:= cRoteiro

		IF !( RpoFormInit() )
			RotAddErr( STR0041 )	//"Nao Foi Possivel Inicializar o Repositorio para Carga dos Roteiros."
			Break
		EndIF

		IF (;
				!( SRY->RY_RECOMP <> "2" );	//Nao Forca Recompilar
				.and.;
				IsFunction( cFunction );	//Ja Existe a Funcao no Repositorio
			)
			Break
		EndIF

		nSrmOrder		:= RetOrder( "SRM" , "RM_FILIAL+RM_CALCULO+RM_SEQ" )

		SRM->( dbSetOrder( nSrmOrder ) )
		IF SRM->( !MsSeek( cSryFilial + cRoteiro , .F. ) )
			RotAddErr( STR0039 )	//"O Roteiro Informado para Calculo nao e valido."
			RotAddErr( STR0040 )	//"Nao possui o sequenciamento de Calculo."
			RotAddErr( STR0038 )	//"Sera necessario informar um Roteiro Valido."	
			Break
		EndIF

		IF Empty( cSourcePath := GetRpoForm( .F. , .T., cSryFilial ) )
			RotAddErr( STR0042 )	//"Nao Foi Possivel Obter acesso ao Diretorio:"
			RotAddErr( STR0043 )	//"Para a Criacao do Programa para Compilacao do Roteiro."
			Break
		EndIF
		cPrgFile	:= Lower( ( cSourcePath + cFunction + ".PRG" ) )

		IF !( FileCreate( cPrgFile , @nHandle,,1 ) )
			RotAddErr( STR0044 + " " + cPrgFile )	//"Nao Foi Possivel Criar o arquivo."
			Break
		EndIF

		cIdent := Space( 4 )
	
		aFunRot := {}
		aAdd( aFunRot , "Function " + cFunction + "()" )
		aAdd( aFunRot , "" )
		aAdd( aFunRot , "Begin Sequence" )
		aAdd( aFunRot , "" )

			While SRM->(;
							!Eof();
							.and.;
							( RM_FILIAL == cSryFilial );
							.and.;
							( RM_CALCULO == cRoteiro );
						)
					IF ( SRM->RM_HABILIT == "1" ) //Apenas os Roteiros Habilitados
						cFormula := AllTrim( SRM->RM_FORMULA )
						If !Empty(SRM->RM_VERBA)
							cFormula := SubStr(cFormula,1,Len(cFormula)-1) + "'" + SRM->RM_VERBA + "')"
						EndIf
						If !FindFunction( cFormula )
							RotAddErr( STR0047 + " " + cPrgFile )										//"Nao Foi Possivel compor o Roteiro."
							RotAddErr( STR0048 + " " + cFormula + " " + STR0049 )						//"A Formula"###"nao Esta Compilada."
							RotAddErr( STR0050 + " " + cRoteiro + " " + STR0051 + " " + SRM->RM_SEQ )	//"Roteiro:"###"Sequencia:"
							fClose( nHandle )
							Break
						EndIf
						aAdd( aFunRot , cIdent + "IF ( AbortProc() ) " )
						aAdd( aFunRot , cIdent + cIdent + "Break" )
						aAdd( aFunRot , cIdent + "EndIF" )
						aAdd( aFunRot , "" )
						aAdd( aFunRot , cIdent + cFormula )
					EndIF
				SRM->( dbSkip() )
			End While					

		aAdd( aFunRot , "" )
		aAdd( aFunRot , "End Sequence" )
		aAdd( aFunRot , "" )
		aAdd( aFunRot , "Return( NIL )" )

		cSrc 	:= ""
		nLoops := Len( aFunRot )
		For nLoop := 1 To nLoops
			cSrc += ( aFunRot[ nLoop ] + CRLF )
		Next nLoop

		fWrite( nHandle , cSrc )
		fClose( nHandle )

	EndIF

	If !lEmptyRpo
		AddPrgCompile( @aPrgsCompile , cFunction , cPrgFile , cSrc )
		IF !Compile( @oRpoForm , @aPrgsCompile , lCompile , @aMsgErr, lSimula )
			RotAddErr( STR0059 + " " + cPrgFile )	//"Nao Foi Possivel Compilar o Roteiro:"
			aEval( aMsgErr , { |cError| RotAddErr( cError ) } )
			RotAddErr( STR0045 + " " 	+ cPrgFile )	//"Ocorreu erro na compilacao do Roteiro."
			If Type("oRpoForm") <> "U"
				RotAddErr( "Error Col:"		+ Str( oRpoForm:ErrCol  ) )
				RotAddErr( "Error Line:"	+ Str( oRpoForm:ErrLine ) )
			Else
				RotAddErr( "Error Col: 0"	 )
				RotAddErr( "Error Line: 0"	 )
			EndIf
		ElseIF SRY->( RecLock( "SRY" , .F. ) )
			SRY->RY_RECOMP := "2"		//Compilado
			SRY->( MsUnLock() )
		EndIF
	Else
		AddPrgCompile( @aRotComp , cFunction , cPrgFile , cSrc )
	EndIf
	
End Sequence

Return( cFunction )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RotGetFunc	  ³Autor ³Marinaldo de Jesus   ³ Data ³23/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem a Funcao para Executar o Roteiro             			 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL     													 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                         					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RotGetFunc( cSryFilial , cRoteiro , cOrigem )
Local aArea		:= GetArea()
Local cMyRet	:= ""
Local cSeqFil	:= ""

//?? cSryFilial			:= xFilial( "SRY" , cSryFilial )
DEFAULT cRoteiro	:= ""
DEFAULT cOrigem		:= "1"

If Empty( cSryFilial )
	cSeqFil := "__"
Else
	cSeqFil := GetSrySeqFil(cSryFilial,.F.)
EndIf
          
cMyRet := Iif( cOrigem == "1" , "S_" , "U_" ) + "ROT" + Iif( Empty( cSeqFil ) , "__" , cSeqFil ) + cRoteiro

RestArea(aArea)

Return( cMyRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ErrorInRot	  ³Autor ³Marinaldo de Jesus   ³ Data ³23/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica se Existe Erros no Roteiro a Ser Executado			 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL     													 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                         					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ErrorInRot()
Return( !Empty( __aRotErr ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RotAddErr	  ³Autor ³Marinaldo de Jesus   ³ Data ³23/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Adiciona String de Erro aa __aRotErr						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL     													 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                         					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function RotAddErr( cErr )

Local aErr

Local nErr		:= Len( cErr )

DEFAULT __aRotErr := {}

IF ( nErr > 220 )
	aErr := {}
	While ( nErr > 220 )
		aAdd( aErr , SubStr( cErr , 1 , 220 ) )
		cErr := SubStr( cErr , 221 )
		IF ( ( nErr := Len( cErr ) ) < 220 )
			aAdd( aErr , cErr )
			Exit
		EndIF
	End While
	aEval( aErr , { |cErr| RotAddErr( cErr ) } )
ElseIF ( aScan( __aRotErr , { |x| x == cErr } ) == 0 )
	aAdd( __aRotErr , cErr )
EndIF	

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RotGetErr	  ³Autor ³Marinaldo de Jesus   ³ Data ³23/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem os Erros de Roteiro               					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL     													 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                         					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RotGetErr()

Local aRotErr

DEFAULT __aRotErr	:= {}

aRotErr		:= aClone( __aRotErr )
__aRotErr	:= {}

Return( aClone( aRotErr ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetFunForm	  ³Autor ³Mauricio T. Takakura ³ Data ³10/02/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem Funcao da Formula a Ser Executado           			 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL     													 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                         					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetFunForm(	cFilForm	,;	//01 -> Filial do SRY ( Cabecalho da Formula de Calculo )
						cFormula	 ;	//02 -> Codigo da Formula
				   )

Local cFunction

Local nRc2Order

Begin Sequence

	IF Empty( cFormula )
		AddTreeErr( STR0063 ) //"Nao Foi Informado Formula para Execucao."
		AddTreeErr( STR0064 )	//"Sera necessario informar uma Formula Valida."
		Break
	EndIF

	nRc2Order	:= RetOrder( "RC2" , "RC2_FILIAL+RC2_CODIGO+RC2_ORIGEM" )
	RC2->( dbSetOrder( nRc2Order ) )
	RC2->( DbSeek( cFilForm + cFormula ) )
	IF RC2->( Eof() )
		cFunction := ""
		AddTreeErr( STR0065 ) //"Formula nao cadastrada! Informe uma Formula Valida !"
		Break
	EndIF

	cFunction := ( RC2->( RC2_ORIGEM + AllTrim( RC2_CODIGO ) ) )

End Sequence

Return( cFunction )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetTreeFrm		³ Autor ³Marinaldo de Jesus³ Data ³03/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem a estrutura das Formulas                 				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetTreeFrm(	aGetTreeFrm	,;	//01 -> Array Com Informacoes para a Compilacao da Formula ( Por Referencia )
						cRc2Filial	,;	//02 -> Filial do Rc2 para a Compilacao da Formula
						cRc2Origem	,;	//03 -> Codigo da Origem da Formula no RC2
						cRc2Codigo	,;	//04 -> Codigo da Formula no RC2
						lIniFormPad	,;	//05 -> Se Devera Inicializar as Formulas Padroes
						oRpoForm	,;	//06 -> Objeto Repositorio ( Por Referencia )
						lCompile	,;	//07 -> Se devera Compilar ou Excluir a(s) Formula(s)
						lSimula		,;	//08 -> Simula se Fórmula está em uso
						lForca		;   //09 -> Simula se Formula está em uso. // Memória de Cálculo.
					)

Local aArea
Local aAreaRC2
Local aAreaRC3
Local aMsgErr
Local aPrgsCompile

Local lGetTreeFrm	:= .T.
Local lSetDebbug	:= SetDebbug( .T. )
Local lSetCentury	:= __SetCentury( "on" )

Local adbTreeForm
Local aRc3Header

Local bRc2While
Local bRc3ItemField
Local bRc3TreeField
Local bRc3DescField

Local cCodForm
Local cRetForm
Local cKeyForm
Local cNodeMaster

Local lReCompile

Local nPrgErr
Local nNoPrgErr
Local nRc2Order
Local nRc2Recno
Local nRc2NextRecno
Local nRc3Select
Local nRc3TreeOrder
Local nRc3ItemOrder
Local lRpoUso	:= .F.
Static __IniFormPad__

DEFAULT lIniFormPad		:= .F.
DEFAULT lCompile		:= .T.
DEFAULT __IniFormPad__	:= lIniFormPad
DEFAULT lSimula		:= .F.
DEFAULT lForca		:= .F.

SetLocal()

Begin Sequence

	IF ( __IniFormPad__ )
		GpIniForm()
		__IniFormPad__	:= .F.
	EndIF

	IF !( lGetTreeFrm := RpoFormInit() )
		Break
	EndIF

	aArea			:= GetArea()
	aAreaRC2		:= RC2->( GetArea() )
	aAreaRC3		:= RC3->( GetArea() )

	nRc2Order := RetOrder( "RC2" , "RC2_FILIAL+RC2_ORIGEM+RC2_CODIGO" )
	RC2->( dbSetOrder( nRc2Order ) )

	cRc2Filial := xFilial( "RC2" , cRc2Filial )
	IF (;
			( cRc2Origem == NIL );
			.and.;
			( cRc2Codigo == NIL );
		)
		IF !( lGetTreeFrm := RC2->( dbSeek( cRc2Filial , .T. ) ) )
			AddTreeErr( STR0023 ) //"Nao Foi Possivel Carregar as Formulas. Verifique se as Tabelas de Formulas RC2 e RC3 estao com Conteudo"
			Break
		EndIF
		bRc2While		:= { || cRc2Filial == RC2_FILIAL }
	ElseIF (;
				( cRc2Origem <> NIL );
				.and.;
				( cRc2Codigo == NIL );
			)
		IF !( lGetTreeFrm := RC2->( dbSeek( cRc2Filial + cRc2Origem , .T. ) ) )
			AddTreeErr( STR0023 ) //"Nao Foi Possivel Carregar as Formulas. Verifique se as Tabelas de Formulas RC2 e RC3 estao com Conteudo"
			Break
		EndIF
		bRc2While		:= { || ( ( RC2_FILIAL == cRc2Filial ) .and. ( RC2_ORIGEM == cRc2Origem ) ) }
	ElseIF (;
				( cRc2Origem <> NIL );
				.and.;
				( cRc2Codigo <> NIL );
			)
		IF !( lGetTreeFrm := RC2->( dbSeek( cRc2Filial + cRc2Origem + cRc2Codigo , .T. ) ) )
			AddTreeErr( STR0023 ) //"Nao Foi Possivel Carregar as Formulas. Verifique se as Tabelas de Formulas RC2 e RC3 estao com Conteudo"
			Break
		EndIF
		bRc2While		:= { || ( ( RC2_FILIAL == cRc2Filial ) .and. ( RC2_ORIGEM == cRc2Origem ) .and. ( RC2_CODIGO == cRc2Codigo ) ) }
	EndIF
	IF !( lGetTreeFrm := ( bRc2While <> NIL ) )
		AddTreeErr( STR0023 ) //"Nao Foi Possivel Carregar as Formulas. Verifique se as Tabelas de Formulas RC2 e RC3 estao com Conteudo"
		Break
	EndIF

	nRc3Select		:= Select( "RC3" )
	bRc3ItemField	:= FieldWBlock( "RC3_SEQFOR" , nRc3Select )
	bRc3DescField	:= FieldWBlock( "RC3_DESCR"	 , nRc3Select )
	bRc3TreeField	:= FieldWBlock( "RC3_SEQPAI" , nRc3Select )

	nRc3TreeOrder	:= RetOrder( "RC3" , "RC3_FILIAL+RC3_ORIGEM+RC3_CODIGO+RC3_SEQPAI+RC3_SEQFOR" )
	nRc3ItemOrder	:= RetOrder( "RC3" , "RC3_FILIAL+RC3_ORIGEM+RC3_CODIGO+RC3_SEQFOR+RC3_SEQPAI" )

	aRc3Header		:= GdMontaHeader( NIL , NIL , NIL , "RC3" , NIL , .T. , .T. , .F. , .F. , .F. , .F. , .F. , .T. )
	cNodeMaster		:= Replicate( "0" , GetSx3Cache( "RC3_SEQFOR" , "X3_TAMANHO" ) )
	oRpoForm		:= GetRpoObj()

	aGetTreeFrm		:= {}

	While RC2->(;
					!Eof();
					.and.;
					Eval( bRc2While );
				 )

		IF !GetNextRecno( "RC2" , @nRc2NextRecno , @nRc2Recno , nRc2Order )
			Exit
		EndIF

		Begin Transaction
			RC2->( Rc2Rc3NewCod( cRc2Filial , RC2_ORIGEM , RC2_CODIGO ) )
		End Transaction	

		cRc2Origem	:= RC2->RC2_ORIGEM
		cRc2Codigo	:= RC2->RC2_CODIGO
		cCodForm	:= ( cRc2Origem + cRc2Codigo )
		lReCompile	:= (;
							( RC2->RC2_RECOMP <> "2" );
							.or.;
							!IsFunction( cCodForm );
						)
		
		IF (;
				( lReCompile );
				.or.;
				!( lCompile ) .Or. lForca;
			)

			cRetForm	:= AllTrim( RC2->RC2_RETURN )
			cKeyForm	:= cCodForm
			cCodForm	:= AllTrim( cCodForm )
			ApdTreeCacheClear()
			adbTreeForm := ApdGetNodes(	"RC2"			,;
										cRc2Filial		,;
										cKeyForm		,;
										"RC2_DESC"		,;
										nRc2Recno		,;
										NIL             ,;
										NIL           	,;
										"RC3"       	,;
										bRc3ItemField	,;
										bRc3DescField	,;
										nRc3TreeOrder	,;
										bRc3TreeField	,;
										nRc3ItemOrder 	,;
										{ || .T. }		,;
										NIL       		,;
										NIL       		,;
										NIL				 ;
				 			)

			aAdd( aGetTreeFrm , {;
									cCodForm				,;	//01 -> Codigo da Formula
									cRetForm				,;	//02 -> Codigo do Mnemonico de Retorno
									aClone( adbTreeForm )	,;	//03 -> Estrutura Tree da Formula
									{ {} , {} }				,;	//04 -> Array Bidimensional [1]Formula Convertida em Funcao;[2]Sequencia da Formula
									lReCompile .Or. lForca	,;	//05 -> Se Forca a Recompilacao da Formula
									nRc2Recno				,;	//06 -> Recno do RC2 para Futuro Posicionamento
									{}						,;	//07 -> Informacoes de Erro na Formula
									lCompile				 ;	//08 -> .T. Se Devera Compilar, .F. Remove
								 };
				 )

	    EndIF

		IF !GotoNextRecno( "RC2" , nRc2NextRecno , nRc2Order )
			Exit
		EndIF

	End While

	If Len(aGetTreeFrm) > 0
		
		lMayIUseCode	:= .T.
		If IsInCallStack("GPEM020PROCESSA") .And. !lGrid .And. !( lGpeGerFrm := WhileExecRot() )
			Break
		EndIf
	
		RC3->( dbSetOrder( nRc3ItemOrder ) )
		ColsTreeFrm( @aGetTreeFrm , aRc3Header , cNodeMaster )

		MkeTreeFrm( @aPrgsCompile , aGetTreeFrm , aRc3Header , cNodeMaster, cCodForm )

		IF !( lGetTreeFrm := Compile( oRpoForm , @aPrgsCompile , lCompile , @aMsgErr,lSimula ,@lRpoUso) )
			aEval( aMsgErr , { |cError| AddTreeErr( cError ) } )
		EndIF
		
		If lSimula .Or. lRpoUso
			aGetTreeFrm := {}
			Return( lGetTreeFrm )
		EndIf

		If IsInCallStack("GPEM020PROCESSA") .And. !lGrid .And. ( lMayIUseCode )
			LeaveExecRot()
		EndIf

		IF !( lGetTreeFrm := ( ( nPrgErr := aScan( aPrgsCompile , { |x| !( x[ COMPILE_OK ] ) } ) ) == 0 ) )
			// Se simulação de tentativa de compilação da fórmula falhar
			// Retornar e impedir edição - fórmula em  uso por roteiro de cálculo
			
			--nPrgErr
			While ( ( nPrgErr := aScan( aPrgsCompile , { |x| !( x[ COMPILE_OK ] ) } , ++nPrgErr ) ) > 0 )
				AddTreeErr( "________________________________________"	)
				AddTreeErr( aPrgsCompile[ nPrgErr , COMPILE_PRG ]  		)
				AddTreeErr( AllTrim( aPrgsCompile[ nPrgErr , COMPILE_ERROR_STR  ] ) )
				AddTreeErr( AllTrim( Str( aPrgsCompile[ nPrgErr , COMPILE_ERROR_COL  ] ) ) )
				AddTreeErr( AllTrim( Str( aPrgsCompile[ nPrgErr , COMPILE_ERROR_LINE ] ) ) )
				AddTreeErr( "________________________________________"  )
				nRc2Recno := aPrgsCompile[ nPrgErr , COMPILE_RECNO ]
				IF !Empty( nRc2Recno )
					RC2->( MsGoto( nRc2Recno ) )
					IF RC2->( !Eof() )
						IF RC2->( RecLock( "RC2" , .F. ) )
							RC2->RC2_RECOMP := "1"	//Recompilar
							RC2->( MsUnLock() )
							Rc2RecSry()
						EndIF
					EndIF
				EndIF
				nForm							:= aPrgsCompile[ nPrgErr , COMPILE_INDICE ]
				aGetTreeFrm[ nForm , 7 ]		:= Array( 5 )
				aGetTreeFrm[ nForm , 7 ][ 1 ]	:= aPrgsCompile[ nPrgErr , COMPILE_ERROR_STR 	]
				aGetTreeFrm[ nForm , 7 ][ 2 ]	:= aPrgsCompile[ nPrgErr , COMPILE_ERROR_COL 	]
				aGetTreeFrm[ nForm , 7 ][ 3 ]	:= aPrgsCompile[ nPrgErr , COMPILE_ERROR_LINE	]
				aGetTreeFrm[ nForm , 7 ][ 4 ]	:= aPrgsCompile[ nPrgErr , COMPILE_PRG			]
				aGetTreeFrm[ nForm , 7 ][ 5 ]	:= aPrgsCompile[ nPrgErr , COMPILE_SOURCE		]
			End While
		EndIF

		IF ( ( nNoPrgErr := aScan( aPrgsCompile , { |x| ( x[ COMPILE_OK ] ) } ) ) > 0 )
			--nNoPrgErr
			While ( ( nNoPrgErr := aScan( aPrgsCompile , { |x| ( x[ COMPILE_OK ] ) } , ++nNoPrgErr ) ) > 0 )
				nRc2Recno := aPrgsCompile[ nNoPrgErr , COMPILE_RECNO ]
				IF !Empty( nRc2Recno )
					RC2->( MsGoto( nRc2Recno ) )
					IF RC2->( !Eof() )
						IF RC2->( RecLock( "RC2" , .F. ) )
							RC2->RC2_RECOMP := "2"	//Compilado
							RC2->( MsUnLock() )
						EndIF
					EndIF
				EndIF
			End While
		EndIF
	EndIf
End Sequence

IF !Empty( aAreaRC2 )
	RestArea( aAreaRC2 )
	RestArea( aAreaRC3 )
	RestArea( aArea )
EndIF	

IF !( lSetCentury )
	__SetCentury( "off" )
EndIF

SetLocal()
SetDebbug( lSetDebbug  )

Return( lGetTreeFrm )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ColsTreeFrm		³ Autor ³Marinaldo de Jesus³ Data ³03/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Percorre as Formulas e Carrega as Informacoes do aCols		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function ColsTreeFrm( aGetTreeFrm , aRc3Header , cNodeMaster )

Local nForm
Local nForms

nForms := Len( aGetTreeFrm )
For nForm := 1 To nForms
	TreeFrmCols( @aGetTreeFrm[ nForm , 3 ] , aRc3Header , cNodeMaster )
Next nForm

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³TreeFrmCols		³ Autor ³Marinaldo de Jesus³ Data ³03/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega aCols conforme aHeader                         	 	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function TreeFrmCols( adbTreeForm , aRc3Header , cNodeMaster )

Local aCols

Local nRecno
Local nLoop
Local nLoops

nLoops := Len( adbTreeForm )
For nLoop := 1 To nLoops
	
	IF ( adbTreeForm[ nLoop , NODE_INFERIOR ] == cNodeMaster )
	
		TreeFrmCols( adbTreeForm[ nLoop , NODE_TREE ] , aRc3Header , cNodeMaster )
	
	Else
		
		nRecno := adbTreeForm[ nLoop , NODE_RECNO ]
		
		RC3->( dbGoto( nRecno ) )
		
		aCols := RC3->(;
							GdBuildCols(	aRc3Header	,;	//01 -> Array com os Campos do Cabecalho da GetDados
											NIL			,;	//02 -> Numero de Campos em Uso
											NIL			,;	//03 -> [@]Array com os Campos Virtuais
											NIL			,;	//04 -> [@]Array com os Campos Visuais
											"RC3"		,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
											NIL			,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
											NIL			,;	//07 -> [@]Array unidimensional contendo os Recnos
											"RC3"   	,;	//08 -> Alias do Arquivo Pai
											NIL			,;	//09 -> Chave para o Posicionamento no Alias Filho
											NIL			,;	//10 -> Bloco para condicao de Loop While
											NIL			,;	//11 -> Bloco para Skip no Loop While
											.T.			,;	//12 -> Se Havera o Elemento de Delecao no aCols 
											.F.			,;	//13 -> Se Sera considerado o Inicializador Padrao
											.F.			,;	//14 -> Opcional, Carregar Todos os Campos
											.T.		 	,;	//15 -> Opcional, Nao Carregar os Campos Virtuais
											NIL			,;	//16 -> Opcional, Utilizacao de Query para Selecao de Dados
											NIL			,;	//17 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP )
											NIL			,;	//18 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP )
											.F.			,;	//19 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
											.F.			,;	//20 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
											.F.			,;	//21 -> Verifica se Deve Checar se o campo eh usado
											.F.			,;	//22 -> Verifica se Deve Checar o nivel do usuario
											.F.			,;	//23 -> Verifica se Deve Carregar o Elemento Vazio no aCols
											NIL			,;	//24 -> [@]Array que contera as chaves conforme recnos
											NIL			,;	//25 -> [@]Se devera efetuar o Lock dos Registros
											NIL			,;	//26 -> [@]Se devera obter a Exclusividade nas chaves dos registros
											NIL			,;	//27 -> Numero maximo de Locks a ser efetuado
											NIL			,;	//28 -> Utiliza Numeracao na GhostCol
											NIL			 ;	//29 -> Carrega os Campos de Usuario
										);
						)										
		
		adbTreeForm[ nLoop , NODE_ACOLS ] := aClone( aCols )
		
		TreeFrmCols( adbTreeForm[ nLoop , NODE_TREE ] , aRc3Header , cNodeMaster )
	
	EndIF

Next nLoop

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³MkeTreeFrm		³ Autor ³Marinaldo de Jesus³ Data ³03/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Percorre todas as Formulas para Montagem       				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function MkeTreeFrm( aPrgsCompile , aGetTreeFrm , aRc3Header , cNodeMaster, cCodForm )

Local lMkeTreeFrm	:= .T.

Local cPrgFile
Local cPrgSrc

Local nForm
Local nForms

Begin Sequence

	nForms := Len( aGetTreeFrm )
	IF ( nForms == 0 )
		Break
	EndIF

	IF !( lMkeTreeFrm := SetMnemonicos( xFilial( "RCA" ) , @__aMnemonicos , .T. , NIL , .T. ) )	//Aqui __aMnemonicos he Static
		AddTreeErr( STR0062 ) //"Nao Foi Possivel Carregar os Mnemonicos para a Montagem e Compilacao das Formulas"
		Break
	EndIF

	For nForm := 1 To nForms
		lMkeTreeFrm := TreeFrmMke(;
										@aPrgsCompile			,;
										@aGetTreeFrm			,;
										nForm					,;
										@cPrgFile				,;
										@cPrgSrc				,;
										aRc3Header				,;
										cNodeMaster				 ;
								 )
		IF !( lMkeTreeFrm )
			RC2->( MsGoto( aGetTreeFrm[ nForm , 6 ] ) )
			IF RC2->( !Eof() )
				AddTreeErr( STR0024 + " " + cCodForm + " - " + AllTrim( RC2->RC2_DESC ) ) //"Nao Foi Possivel Montar e/ou Compilar a Formula:"
			EndIF	
		EndIF	
	Next nForm

End Sequence

Return( lMkeTreeFrm )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³TreeFrmMke		³ Autor ³Marinaldo de Jesus³ Data ³03/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Monta as Formulas                              				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function TreeFrmMke(	aPrgsCompile	,;	//Array com as Informacoes para Compilacao ( Por Referencia )
							aGetTreeFrm 	,;	//Array com as Informacoes da Fomula a Ser Compilada
							nForm			,;	//Indice em aGetTreeFrm
							cPrgFile		,;	//Programa a ser Compilado ( Por Referencia )
							cSrc			,;	//Codigo a ser Compilado ( Por Referencia )
							aRc3Header		,;	//Array com a Estrutura Header do RC3
							cNodeMaster		 ;	//Node Mastre da Estrutura de Formula
						  )

Local aLocal
Local aBodyFrm
Local aTreeFrmMke
Local aSeqFrmMke

Local cFunction
Local cReturn
Local cSrcAux
Local cSourcePath
Local cSvRc2Codigo
Local cIdent	:= Space(4)
Local cFilAux   := Replicate("!", Len(cFilAnt))
Local cFilSRY   := ""

Local lTreeFrmMke
Local lReturn
Local lReCompile
Local lCompile

Local nLoop
Local nLoops
Local nHandle
Local nRc2Recno

Static __lMemCalc
DEFAULT __lMemCalc := cPaisLoc == "BRA" .And. FindFunction("fMemCalc") .And. fMemCalc()
DEFAULT __lFilRPO  := SuperGetMv("MV_RPOFIL",, .F.) //Gera repositórios auxiliares por filial? -- TMF

If __lFilRPO 
	cFilSRY   := If(Type("cFilCalc") <> "U" .and. !Empty(cFilCalc) .and. cFilCalc <> cFilAux, xFilial("SRY",cFilCalc), xFilial("SRY") )
EndIf

Begin Sequence

	cFunction		:= AllTrim( aGetTreeFrm[ nForm , 1 ] )
	cSvRc2Codigo	:= SetMemVar( "RC2_CODIGO" , cFunction , .T. , .T. , .T. , .F. , NIL )

	lCompile		:= aGetTreeFrm[ nForm , 8 ]

	IF ( lCompile )	
		aTreeFrmMke	:= {}
		aAdd( aTreeFrmMke , "Function " + cFunction + "(cPdRot)" )
	
		aLocal	 	:= {}
		cReturn		:= aGetTreeFrm[ nForm , 2 ]
		lReturn		:= !Empty( cReturn )
		IF ( lReturn )
			AddLocal( cReturn , @aLocal )
		EndIF
		//Memória de Cálculo
		If __lMemCalc
			AddLocal( "nTimeINI" , @aLocal )
		EndIf

		aBodyFrm	:= {}
		MkeBodyFrm( @aBodyFrm , aGetTreeFrm[ nForm , 3 ] , aRc3Header , cReturn , cNodeMaster , @aLocal )
		
		nLoops := Len( aLocal )
		IF ( nLoops > 0 )
			//ASort(aLocal, NIL, NIL, { |aItem1, aItem2| aItem1 < aItem2 })
			
			For nLoop := 1 To nLoops
				aAdd( aTreeFrmMke , aLocal[ nLoop , 2 ] )
			Next nLoop

			aAdd( aTreeFrmMke , "" )
		EndIF

		//Memória de Cálculo
		If __lMemCalc
			aAdd( aTreeFrmMke , "fAddMemLog('Fórmula : ' + '" + cFunction + "' ,1)" )
			aAdd( aTreeFrmMke , "nTimeINI := Time()" )
		EndIf

		aAdd( aTreeFrmMke , "cVerbaRot := cPdRot" )
		aAdd( aTreeFrmMke , "" )
		
		aAdd( aTreeFrmMke , "Begin Sequence" )		
		aAdd( aTreeFrmMke , cIdent+ "If ( AbortProc() )" )
		aAdd( aTreeFrmMke , cIdent+cIdent+ "Break" )
		aAdd( aTreeFrmMke , cIdent+ "EndIf" )
		aAdd( aTreeFrmMke , "" )			
		
		aSeqFrmMke := {}
		nLoops := Len( aBodyFrm )
		IF ( nLoops > 0 )
			For nLoop := 1 To nLoops
				aAdd( aTreeFrmMke	, aBodyFrm[ nLoop , 1 ] )
				aAdd( aSeqFrmMke	, aClone( aBodyFrm[ nLoop , 2 ] ) )
			Next nLoop
		EndIF

		//Memória de Cálculo
		If __lMemCalc
			aAdd( aTreeFrmMke , "fAddMemLog('Tempo de execução : ' + ElapTime(NTIMEINI,TIME()),1)" )
			aAdd( aTreeFrmMke , "fGrvLogFun(GetRotExec(), cPeriodo, cSemana,'" + cFunction +"', aMenLog)" )
			aAdd( aTreeFrmMke , "aMenLog := {}" )
		EndIf

		aAdd( aTreeFrmMke , "End Sequence" )
		
		IF ( lReturn )
			aAdd( aTreeFrmMke , "Return (" + cReturn + ")" )
		Else
			aAdd( aTreeFrmMke , "Return" )
		EndIF
		
		aGetTreeFrm[ nForm , 4 , 1 ] := aClone( aTreeFrmMke )
		aGetTreeFrm[ nForm , 4 , 2 ] := aClone( aSeqFrmMke	)

	EndIF

	lTreeFrmMke	:= !Empty( cSourcePath	:= GetRpoForm( .F. , .T., cFilSRY ) )

	IF !( lTreeFrmMke )
		Break
	EndIF

	IF ( lCompile )

		cPrgFile	:= Lower( ( cSourcePath + ( cFunction + ".PRG" ) ) )
		lReCompile	:= ( aGetTreeFrm[ nForm , 5 ] .or. !File( cPrgFile ) )
		IF !( lReCompile )
			Break
		EndIF
		
		lTreeFrmMke := FileCreate( cPrgFile , @nHandle,, 1 )

		cSrc 	:= ""
		cSrcAux	:= ""
		nLoops := Len( aTreeFrmMke )
		For nLoop := 1 To nLoops
			cSrcAux := RTrim( aTreeFrmMke[ nLoop ] )

			IF nLoop > 1 .AND. nLoop < nLoops
				cSrcAux := cIdent + cSrcAux
			EndIF
		
			IF ( SubStr( cSrcAux , -1 ) == ";" )
				cSrcAux := cSrcAux
				cSrc	+= SubStr( cSrcAux , 1 , ( Len( cSrcAux ) - 1 ) )
				For nLoop := nLoop + 1 To nLoops
					cSrcAux := RTrim( aTreeFrmMke[ nLoop ] )
					IF ( SubStr( cSrcAux , -1 ) <> ";" )
						cSrcAux := AllTrim( cSrcAux )
						cSrc	+= ( cSrcAux + CRLF )
						Exit
					EndIF
					cSrcAux := AllTrim( cSrcAux )
					cSrc	+= SubStr( cSrcAux , 1 , ( Len( cSrcAux ) - 1 ) )
				Next nLoop
			Else
				cSrc += ( cSrcAux + CRLF )
			EndIF
		Next nLoop

		fWrite( nHandle , cSrc )
		fClose( nHandle )

	EndIF

	nRc2Recno := aGetTreeFrm[ nForm , 6 ]
	AddPrgCompile( @aPrgsCompile , cFunction , cPrgFile , cSrc , "RC2" , nRc2Recno , nForm )

End Sequence

IF !Empty( cSvRc2Codigo )
	SetMemVar( "RC2_CODIGO" , cSvRc2Codigo , .F. , .F. , .F. , .F. , NIL )
EndIF

Return( lTreeFrmMke )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³AddPrgCompile	³ Autor ³Marinaldo de Jesus³ Data ³16/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Adicionar Informacoes para Compilacao no Array aPrgsCompile  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function AddPrgCompile( aPrgsCompile , cFunction , cPrgFile , cSrc , cAlias , nRecno , nIndice )

Local nPrgsCompile

DEFAULT aPrgsCompile := {}

aAdd( aPrgsCompile , Array( COMPILE_ELEMENTS ) )
nPrgsCompile := Len( aPrgsCompile )

aPrgsCompile[ nPrgsCompile , COMPILE_FUNCTION	]	:= cFunction
aPrgsCompile[ nPrgsCompile , COMPILE_PRG		]	:= cPrgFile
aPrgsCompile[ nPrgsCompile , COMPILE_SOURCE		]	:= cSrc
aPrgsCompile[ nPrgsCompile , COMPILE_OK			]	:= .F.
aPrgsCompile[ nPrgsCompile , COMPILE_ALIAS		]	:= cAlias
aPrgsCompile[ nPrgsCompile , COMPILE_RECNO		]	:= nRecno
aPrgsCompile[ nPrgsCompile , COMPILE_ERROR_STR	]	:= ""
aPrgsCompile[ nPrgsCompile , COMPILE_ERROR_COL	]	:= 0
aPrgsCompile[ nPrgsCompile , COMPILE_ERROR_LINE	]	:= 0
aPrgsCompile[ nPrgsCompile , COMPILE_INDICE		]	:= nIndice

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Compile			³ Autor ³Marinaldo de Jesus³ Data ³16/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Compilar as Formulas Adicionando-as no Repositorio Auxiliar  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Compile( oRpoForm , aPrgsCompile , lCompile , aMsgErr, lSimula, lRpoUso )

Local cSrc
Local cPrgFile
Local cFunction
Local cSourcePath
Local lCompileOk
Local nPrg
Local nPrgs
Local nSrcChkSum

DEFAULT lSimula := .F.
DEFAULT lRpoUso	:= .F.

Begin Sequence

	aMsgErr := {}

	IF !( lCompileOk := !Empty( aPrgsCompile ) )
    	Break
	EndIF

	IF !( lCompileOk := RpoFormInit() )
		aAdd( aMsgErr , STR0061 )
		Break
	EndIF

	DEFAULT oRpoForm	:= GetRpoObj()

	IF !( oRpoForm:StartBuild( .T. ) )
		aAdd( aMsgErr , STR0062 )			//"Nao Foi Possivel Compilar a Formula:"
		aAdd( aMsgErr , STR0060 )			//"Rpo em uso por Outro Processo."
		aAdd( aMsgErr , oRpoForm:ErrStr )
		lCompileOk := .F.
		lRpoUso := .T.
		oRpoForm:EndBuild()
		oRpoForm:Close()
		RpoFormInit()
		Break
	EndIF

	If lSimula
		Break
	EndIf
	
	DEFAULT lCompile	:= .T.

	nPrgs := Len( aPrgsCompile )
	For nPrg := 1 To nPrgs

		cFunction	:= aPrgsCompile[ nPrg , 1 ]
		cPrgFile	:= aPrgsCompile[ nPrg , 2 ]

		IF ( lCompile )

			cSrc		:= aPrgsCompile[ nPrg , 3 ]
			nSrcChkSum	:= oRpoForm:ChkSum( cSrc )

			IF !( lCompileOk := oRpoForm:Compile( cPrgFile , cSrc , 0, nSrcChkSum ) )
		   		ConOut( "Error Prg:" 	+ cPrgFile		 		  )
		   		ConOut( "Error Str:" 	+ oRpoForm:ErrStr 		  )
		   		ConOut( "Error Col:" 	+ Str( oRpoForm:ErrCol  ) )
		   		ConOut( "Error Line:" 	+ Str( oRpoForm:ErrLine ) )
				aPrgsCompile[ nPrg , COMPILE_ERROR_STR 	] := oRpoForm:ErrStr
				aPrgsCompile[ nPrg , COMPILE_ERROR_COL 	] := oRpoForm:ErrCol
				aPrgsCompile[ nPrg , COMPILE_ERROR_LINE	] := oRpoForm:ErrLine
			EndIF

		ElseIF IsFunction( cFunction )

			cPrgFile := ( cFunction + ".PRG" )

			IF ( lCompileOk := (;
									oRpoForm:RemProg( cPrgFile );
									.and.;
									!IsFunction( cFunction );
								);
				)				 

				IF !Empty( cSourcePath := GetRpoForm( .F. , .T. ) )
					cPrgFile := ( cSourcePath + ( cFunction + ".PRG" ) )
					FileErase( cPrgFile )
				EndIF	

				//"O Progama"###"Foi Removido Com Sucesso..."
				ConOut( STR0015 + " " + cPrgFile + " " + STR0016 )

			EndIF
		
		EndIF

		aPrgsCompile[ nPrg , COMPILE_OK ] := lCompileOk

	Next nPrg

	oRpoForm:EndBuild()
	oRpoForm:Close()
	RpoFormInit()

End Sequence

Return( lCompileOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CriaLocal		³ Autor ³Marinaldo de Jesus³ Data ³10/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Cria variaveis Locais para uso em Formulas     				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function CriaLocal( cVar , cType , uInit , nSize , cForm , lShowInfo )

Local cMsgInfo
Local nForm
Local nVar

Local lCriaLocal := .T.

Begin Sequence

	IF !( IsDebbug() )
		Break
	EndIF

	DEFAULT cForm := GetMemVar( "RC2_CODIGO" )

	IF (;
			Empty( cForm );
			.or.;
			Empty( cVar );
		)	
		lCriaLocal := .F.
		Break
	EndIF

	cForm	:= Upper( AllTrim( cForm ) )
	cVar	:= Upper( AllTrim( cVar  ) )

	DEFAULT	cType		:= "U"
	DEFAULT uInit		:= NIL
	DEFAULT nSize		:= 0
	DEFAULT lShowInfo   := .T.

	SetLocal( .T. )

	IF (;
			( ( nForm := aScan( __aLocal , { |x| ( x[1] == cForm ) } ) ) == 0 );
			.and.;
			( ( nForm := aScan( __aLocal , { |x| ( SubStr( x[1] , 3 ) == cForm ) } ) ) == 0 );
		)
		aAdd( __aLocal , { cForm , {} } )
		nForm := Len( __aLocal )
	EndIF

	IF !( lCriaLocal := CheckExecForm( @uInit , lShowInfo ) )
		Break
	EndIF

	cType	:= Upper( AllTrim( cType ) )

	IF (;
			( cType <> "U" );
			.and.;
			( ValType( uInit ) <> cType );
		)
		lCriaLocal := .F.
		cMsgInfo := STR0020 //"Tipo do Valor Inicial da Variável não é compatível com o Tipo Definido para a Variável."
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0021	//"Tipo Definido para a Variável:"
		cMsgInfo += " "
		cMsgInfo += "'" + cType + "'"
		cMsgInfo += CRLF
		cMsgInfo += STR0022	//"Tipo Definido para o Valor Inicial:"
		cMsgInfo += " "
		cMsgInfo += "'" + ValType( uInit ) + "'"
		cMsgInfo += CRLF
		cMsgInfo += CRLF
		cMsgInfo += STR0032	//"A Variável passada no 1o. parâmetro da CriaLocal() não será adicionada ao Codigo Fonte."
		cMsgInfo += CRLF
		cMsgInfo += STR0033	//"Favor Corrigir o Tipo ou o Valor Inicial da Variavel ( parâmetros 2 e 3 , respectivamente )."
		Break
	EndIF

	nVar := aScan( __aLocal[ nForm , 2 ] , { |x| ( x[1] == cVar ) } )
	IF ( nVar == 0 )
		aAdd( __aLocal[ nForm , 2 ] , Array( 4  ) )
		nVar := Len( __aLocal[ nForm , 2 ] )
	EndIF
	uInit := IF( ( cVar == "C" ) , "'" + uInit + "'" , uInit )
	__aLocal[ nForm , 2 , nVar , 01 ] := cVar	//01 -> Nome da Variavel
	__aLocal[ nForm , 2 , nVar , 02 ] := cType	//02 -> Tipo da Variavel
	__aLocal[ nForm , 2 , nVar , 03 ] := nSize	//03 -> Tamanho da Variavel ( Quando cType == "C" )
	__aLocal[ nForm , 2 , nVar , 04 ] := uInit	//04 -> Inicializador Padrao para a Variavel

End Sequence

IF (;
		!( lCriaLocal );
		.and.;
		( lShowInfo );
		.and.;
		!Empty( cMsgInfo );
	)
	MsgInfo( OemToAnsi( cMsgInfo ) , OemToAnsi( STR0017 ) ) //"Atençäo!"
EndIF		

__lCriaLocal := lCriaLocal

Return( lCriaLocal )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CriaLocalOk		³ Autor ³Marinaldo de Jesus³ Data ³10/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna o Estado de chamada da ultima CriaLocal				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function CriaLocalOk()

Local lCriaLocalOk		:= .F. 

DEFAULT __lCriaLocal	:= .T.

lCriaLocalOk	:= __lCriaLocal
__lCriaLocal	:= .T.

Return( lCriaLocalOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetLocal		³ Autor ³Marinaldo de Jesus³ Data ³10/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem as Variaveis Locais para a Formula       				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetLocal( cForm )

Local aLocal := {}

Local nForm

Begin Sequence

	IF !( IsDebbug() )
		Break
	EndIF

	DEFAULT cForm := GetMemVar( "RC2_CODIGO" )
	IF ( Empty( cForm ) )
		Break
	EndIF

	SetLocal( .T. )

	cForm	:= Upper( AllTrim( cForm ) )
	nForm	:= aScan( __aLocal , { |x| ( x[1] == cForm ) } )
	IF ( nForm == 0 )
		nForm := aScan( __aLocal , { |x| ( SubStr( x[1] , 3 ) == cForm ) } )
		IF ( nForm == 0 )
			Break
		EndIF
	EndIF

	aLocal := aClone( __aLocal[ nForm ] )

End Sequence

Return( aLocal )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³SetLocal		³ Autor ³Marinaldo de Jesus³ Data ³10/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializa a variavel __aLocal                 				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function SetLocal( lNoReSet )

DEFAULT lNoReSet := .F.

IF ( lNoReSet )
	DEFAULT __aLocal := {}
Else
	__aLocal := {}
EndIF

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RpoFormInit		³ Autor ³Marinaldo de Jesus³ Data ³09/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializa o Rpo de Formula e Retorna o Nome Por Referencia  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RpoFormInit( cGetRpoForm , lClose )
Local lRpoFormInit	:= .T.
Local lDel			:= .F.
Local lIsObject
Local lGetNew
Local cFilAux       := Replicate("!", Len(cFilAnt))
Local cFilSRY       := ""

DEFAULT __cRpoForm 	:= "RpoForm_No_Init"
DEFAULT lClose 		:= .F.
DEFAULT __lFilRPO  	:= SuperGetMv("MV_RPOFIL",, .F.) //Gera repositórios auxiliares por filial? -- TMF

If __lFilRPO 
	cFilSRY   := If(Type("cFilCalc") <> "U" .and. !Empty(cFilCalc) .and. cFilCalc <> cFilAux, xFilial("SRY",cFilCalc), xFilial("SRY") )
EndIf

Begin Sequence

	cGetRpoForm := GetRpoForm( .T.,,cFilSRY )
	IF !( lRpoFormInit := !Empty( cGetRpoForm ) )
		Break
	EndIF
	
	IF (;
			( lIsObject := ( ValType( __oRpoForm ) == "O" ) );
			.and.;
			!( lGetNew := (;
								( __cRpoForm <> cGetRpoForm );
						   		.or.;
						   		!__oRpoForm:Open( cGetRpoForm );
						   );
			 );
		)
		If !( lClose )
			Break
		EndIf
	EndIF
	
	IF (;
			( lIsObject );
			.and.;
			(;
				( lGetNew );
				.or.;
				( lClose );
			);	
		)
		__oRpoForm:Close()
		__oRpoForm := NIL
		IF ( lClose )
			Break
		EndIF
	EndIF

	__cRpoForm		:= cGetRpoForm
	__oRpoForm		:= Rpo():New(iif(!isBlind() .And. cBuildVer != Nil .And. cBuildVer > '17.3.0.13',.T.,nil))
	lRpoFormInit	:= __oRpoForm:Open( cGetRpoForm )
	IF !( lRpoFormInit )
		lIsObject := ( ValType( __oRpoForm ) == "O" )
		lDel := 'INVALID RPO SIGNATURE' $ Upper(__oRpoForm:ERRSTR) .Or. 'GENERAL ERROR' $ Upper(__oRpoForm:ERRSTR)  //"Invalid RPO signature (APNSRM0418). Please update your RPO file."##"GENERAL ERROR opening rpoaux"
		IF ( lIsObject )
			__oRpoForm:Close()
		EndIF
		__oRpoForm := NIL
		__cRpoForm := "RpoForm_No_Init"
		If lDel
			If FileErase( cGetRpoForm )
				lRpoFormInit := RpoFormInit( cGetRpoForm , lClose )
			EndIf
		EndIf
	EndIF

End Sequence

Return( lRpoFormInit )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetRpoObj		³ Autor ³Marinaldo de Jesus³ Data ³23/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Objeto Rpo em uso									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetRpoObj()

RpoFormInit()

Return( __oRpoForm )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetRpoForm		³ Autor ³Marinaldo de Jesus³ Data ³04/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna um Nome Valido para o Rpo Auxiliar usado no GPE	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetRpoForm( lGetRpoName , lGetPathSource, cFilSRY )

Local cRpoName			:= ""
Local cSourcePath		:= ""
Local cSeqSry			:= ""
Local cFilAux   		:= Replicate("!", Len(cFilAnt))
Local cGetRpoForm		:= GetPvProfString( GetEnvServer() , "SourcePath" , "" , GetAdv97() )
Local cGetRpoPath		:= GetPvProfString( GetEnvServer() , "FormPath" , "" , GetAdv97() )
Local lMakeOk			:= .F.

DEFAULT __lFilRPO		:= SuperGetMv("MV_RPOFIL",, .F.) //Gera repositórios auxiliares por filial? -- TMF
DEFAULT lGetRpoName 	:= .F.
DEFAULT lGetPathSource  := .F.

If !Empty(cGetRpoPath)
	cGetRpoForm := cGetRpoPath
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Trocar as barras para evitar inconsistencia no Linux 				    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
cGetRpoForm := StrTran(cGetRpoForm, "/", "\" )
IF ( SubStr( cGetRpoForm , -1 ) <> "\" )
	cGetRpoForm += "\"
EndIF
If __lFilRPO
	DEFAULT cFilSRY := If(Type("cFilCalc") <> "U" .and. !Empty(cFilCalc) .and. cFilCalc <> cFilAux, xFilial("SRY",cFilCalc), xFilial("SRY") )
	If Empty(cFilSRY)
		cFilSRY := xFilial("SRY")
	EndIf
	cSeqSry := GetSrySeqFil(cFilSRY,.T.)
	cRpoName	:= ( "rpofrm" + cSeqSry )
Else 
	cRpoName	:= ( "rpofrm" + cEmpAnt )
EndIf
cGetRpoForm += cRpoName

cGetRpoForm := Lower( cGetRpoForm )
IF !( lMakeOk := lIsSRVDir( cGetRpoForm ) )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Foi utilizado o parametro 1 no MakeDir para criar diretorio "fora" do  ³
	³servidor, pois esta se passando todo o caminho do path e nao a partir  ³
	³dele. Com esta funcionalidade sempre sera criado no server mesmo que   ³
	³C:\                                                                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	lMakeOk := ( MakeDir( cGetRpoForm ,1) == 0 )

EndIF

cSourcePath := "\source
IF !( lMakeOk := lIsSRVDir( cGetRpoForm + cSourcePath ) )

	lMakeOk := ( MakeDir( cGetRpoForm + cSourcePath, 1 ) == 0 )

EndIF

IF !( lMakeOk )
	//"Nao Foi Possivel Criar o Diretorio:"###"Para a Compilacao das Formulas
	AddTreeErr( STR0029 + " " + cGetRpoForm + " " + STR0030 )
	cGetRpoForm := ""
ElseIF ( lGetRpoName )
	cGetRpoForm += ( "\" + cRpoName + ".rpo" )
ElseIF ( lGetPathSource )
	cSourcePath += "\"
	cGetRpoForm += cSourcePath
EndIF

Return( cGetRpoForm )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³MkeBodyFrm		³ Autor ³Marinaldo de Jesus³ Data ³03/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Monta o corpo da Formula                       				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³TreeFrmMke                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function MkeBodyFrm(	aBodyFrm	,;	//Array com o Corpo da Formula ( por Referencia )
							adbTreeForm ,;	//Array Multidimensional e Recursivo com a Estrutura da Formula
							aRc3Header	,;	//Array com a Estrutura de Cabecalho do RC3
							cReturn		,;	//Variavel de Retorno da Formula
							cNodeMaster ,;	//Node Superior
							aLocal		,;	//Array com a Inicializacao dos Mnemonicos Locais ( Por Referencia ) 
							nIdent		 ;	//Indice para Identacao da Formula
						   )

Local aCols

Local cIdent
Local cExprAdd

Local cRc3Tipo

Local cRc3SeqFor
Local cRc3SeqPai

Local cRc3TpResu
Local cRc3TpFm01
Local cRc3TpFm02

Local cRc3Result
Local cRc3Form01
Local cRc3Form02

Local cRc3Opera1
Local cRc3Opera2
Local cRc3Opera3

Local nLoop
Local nLoops

DEFAULT nIdent := 4
cIdent	:= Space( nIdent )

nLoops := Len( adbTreeForm )
For nLoop := 1 To nLoops

	IF ( adbTreeForm[ nLoop , NODE_INFERIOR ] == cNodeMaster )

		MkeBodyFrm( @aBodyFrm , adbTreeForm[ nLoop , NODE_TREE ] , aRc3Header , cReturn , cNodeMaster , @aLocal )

	Else

		aCols		:= adbTreeForm[ nLoop , NODE_ACOLS ]
		IF Empty( aCols )
			Loop
		EndIF

		cRc3SeqFor	:= GdFieldGet( "RC3_SEQFOR"	 , 1 , .F. , aRc3Header , aCols )
		cRc3SeqPai  := GdFieldGet( "RC3_SEQPAI"	 , 1 , .F. , aRc3Header , aCols )

		cRc3Tipo	:= AllTrim( GdFieldGet( "RC3_TIPO"	 , 1 , .F. , aRc3Header , aCols ) )
		
		cRc3TpResu	:= AllTrim( GdFieldGet( "RC3_TPRESU" , 1 , .F. , aRc3Header , aCols ) )
		cRc3TpFm01	:= AllTrim( GdFieldGet( "RC3_TPFM01" , 1 , .F. , aRc3Header , aCols ) )
		cRc3TpFm02	:= AllTrim( GdFieldGet( "RC3_TPFM02" , 1 , .F. , aRc3Header , aCols ) )

		cRc3Opera1	:= AllTrim( GdFieldGet( "RC3_OPERA1" , 1 , .F. , aRc3Header , aCols ) )
		cRc3Opera2	:= AllTrim( GdFieldGet( "RC3_OPERA2" , 1 , .F. , aRc3Header , aCols ) )
		cRc3Opera3	:= AllTrim( GdFieldGet( "RC3_OPERA3" , 1 , .F. , aRc3Header , aCols ) )

		cRc3Result	:= SetGpeBlock( AllTrim( GdFieldGet( "RC3_RESULT" , 1 , .F. , aRc3Header , aCols ) ) )
		cRc3Form01	:= SetGpeBlock( AllTrim( GdFieldGet( "RC3_FORM01" , 1 , .F. , aRc3Header , aCols ) ) )
		cRc3Form02  := SetGpeBlock( AllTrim( GdFieldGet( "RC3_FORM02" , 1 , .F. , aRc3Header , aCols ) ) )

		//Memória de Cálculo
		If __lMemCalc .And. ( cRc3Tipo == ".MSG." ) .and. ( cRc3Opera3 $ ".CNT." ) .And. "FADDMEMLOG" $ cRc3Result
			cRc3Tipo := ".EXE."
		Endif

		//AddLocal( cRc3Result , @aLocal )
		//AddLocal( cRc3Form01 , @aLocal )
		//AddLocal( cRc3Form02 , @aLocal )
		AddLocal( cRc3Result + cRc3Opera1 + cRc3Form01 + cRc3Opera2 + cRc3Form02, @aLocal )

		IF (;
				( cRc3Tipo == ".CON." );
				.and.;
				( cRc3Opera3 == ".END." );
			)
			
			cExprAdd := ( cIdent + "IF ( " + cRc3Form01 + cRc3Opera2 + cRc3Form02 + " )" )
			AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
			AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )

			MkeBodyFrm( @aBodyFrm , adbTreeForm[ nLoop , NODE_TREE ] , aRc3Header , cReturn , cNodeMaster , @aLocal , nIdent + 4 )
			//AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )

			cExprAdd := ( cIdent + "EndIF" )
			AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
			AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )
			AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )
			
		ElseIF (;
				( cRc3Tipo == ".CON." );
				.and.;
				( cRc3Opera3 $ ".AND./.OR." );
			)

			cExprAdd := ( cIdent + "IF (;" )
			AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )

				cExprAdd := ( cIdent + cIdent + "( " + cRc3Form01 + cRc3Opera2 + cRc3Form02 + " );" )
				AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
	
				cExprAdd := ( cIdent + cIdent + cRc3Opera3 + ";" )
				AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
	
				For nLoop := nLoop + 1 To nLoops
					
					aCols	:= adbTreeForm[ nLoop , NODE_ACOLS ]
					IF Empty( aCols )
						Loop
					EndIF
			
					cRc3Tipo	:= AllTrim( GdFieldGet( "RC3_TIPO"	 , 1 , .F. , aRc3Header , aCols ) )
	
					cRc3SeqFor	:= GdFieldGet( "RC3_SEQFOR"	 , 1 , .F. , aRc3Header , aCols )
					cRc3SeqPai  := GdFieldGet( "RC3_SEQPAI"	 , 1 , .F. , aRc3Header , aCols )
			
					cRc3TpResu	:= AllTrim( GdFieldGet( "RC3_TPRESU" , 1 , .F. , aRc3Header , aCols ) )
					cRc3TpFm01	:= AllTrim( GdFieldGet( "RC3_TPFM01" , 1 , .F. , aRc3Header , aCols ) )
					cRc3TpFm02	:= AllTrim( GdFieldGet( "RC3_TPFM02" , 1 , .F. , aRc3Header , aCols ) )
	        	
					cRc3Opera1	:= AllTrim( GdFieldGet( "RC3_OPERA1" , 1 , .F. , aRc3Header , aCols ) )
					cRc3Opera2	:= AllTrim( GdFieldGet( "RC3_OPERA2" , 1 , .F. , aRc3Header , aCols ) )
					cRc3Opera3	:= AllTrim( GdFieldGet( "RC3_OPERA3" , 1 , .F. , aRc3Header , aCols ) )
	
					cRc3Result	:= SetGpeBlock( AllTrim( GdFieldGet( "RC3_RESULT" , 1 , .F. , aRc3Header , aCols ) ) )
					cRc3Form01	:= SetGpeBlock( AllTrim( GdFieldGet( "RC3_FORM01" , 1 , .F. , aRc3Header , aCols ) ) )
					cRc3Form02  := SetGpeBlock( AllTrim( GdFieldGet( "RC3_FORM02" , 1 , .F. , aRc3Header , aCols ) ) )
	
					//AddLocal( cRc3Result , @aLocal )
					//AddLocal( cRc3Form01 , @aLocal )
					//AddLocal( cRc3Form02 , @aLocal )				
					AddLocal( cRc3Result + cRc3Opera1 + cRc3Form01 + cRc3Opera2 + cRc3Form02, @aLocal )
	
					cExprAdd := ( cIdent + cIdent + "( " + cRc3Form01 + cRc3Opera2 + cRc3Form02 + " );" )
					AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
	
					IF ( cRc3Opera3 $ ".AND./.OR." )
	
						cExprAdd := ( cIdent + cIdent + cRc3Opera3 + ";" )
						AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
	
					ElseIF ( cRc3Opera3 == ".END." )
	
						cExprAdd := ( cIdent + ")" )
						AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
						AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )
	
						Exit
	
					EndIF
				
				Next nLoop
	
				MkeBodyFrm( @aBodyFrm , adbTreeForm[ nLoop , NODE_TREE ] , aRc3Header , cReturn , cNodeMaster , @aLocal , nIdent + 4 )
	
			cExprAdd := ( cIdent + "EndIF" )
			AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
			AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )
			AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )

		ElseIF (;
					( cRc3Tipo == ".ENQ." );
					.and.;
					( cRc3Opera3 == ".END." );
				)	

			cExprAdd := ( cIdent + "While ( " + cRc3Form01 + cRc3Opera2 + cRc3Form02 + " ) " )
			AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
				
				//AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )
				cExprAdd := ( cIdent + cIdent + "IF ( AbortProc() ) " )
				AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )

				//AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )
				cExprAdd := ( cIdent + cIdent + cIdent + "Break" )
				AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
            	
				//AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )
				cExprAdd := ( cIdent + cIdent + "EndIF" )
				AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
				AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )
				AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )
				
				MkeBodyFrm( @aBodyFrm , adbTreeForm[ nLoop , NODE_TREE ] , aRc3Header , cReturn , cNodeMaster , @aLocal , nIdent + 4 )

				AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )

			cExprAdd := ( cIdent + "End" )
			AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
			AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )

		ElseIF (;
				( cRc3Tipo == ".ENQ." );
				.and.;
				( cRc3Opera3 $ ".AND./.OR." );
			)

			cExprAdd := ( cIdent + "While (;" )
			AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )

				cExprAdd := ( cIdent + cIdent + "( " + cRc3Form01 + cRc3Opera2 + cRc3Form02 + " );" )
				AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
	
				cExprAdd := ( cIdent + cIdent + cRc3Opera3 + ";" )
				AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
	
				For nLoop := nLoop + 1 To nLoops
					
					aCols		:= adbTreeForm[ nLoop , NODE_ACOLS ]
					IF Empty( aCols )
						Loop
					EndIF

					cRc3Tipo	:= AllTrim( GdFieldGet( "RC3_TIPO"	 , 1 , .F. , aRc3Header , aCols ) )
	
					cRc3SeqFor	:= GdFieldGet( "RC3_SEQFOR"	 , 1 , .F. , aRc3Header , aCols )
					cRc3SeqPai  := GdFieldGet( "RC3_SEQPAI"	 , 1 , .F. , aRc3Header , aCols )
			
					cRc3TpResu	:= AllTrim( GdFieldGet( "RC3_TPRESU" , 1 , .F. , aRc3Header , aCols ) )
					cRc3TpFm01	:= AllTrim( GdFieldGet( "RC3_TPFM01" , 1 , .F. , aRc3Header , aCols ) )
					cRc3TpFm02	:= AllTrim( GdFieldGet( "RC3_TPFM02" , 1 , .F. , aRc3Header , aCols ) )
	        	
					cRc3Opera1	:= AllTrim( GdFieldGet( "RC3_OPERA1" , 1 , .F. , aRc3Header , aCols ) )
					cRc3Opera2	:= AllTrim( GdFieldGet( "RC3_OPERA2" , 1 , .F. , aRc3Header , aCols ) )
					cRc3Opera3	:= AllTrim( GdFieldGet( "RC3_OPERA3" , 1 , .F. , aRc3Header , aCols ) )
	
					cRc3Result	:= SetGpeBlock( AllTrim( GdFieldGet( "RC3_RESULT" , 1 , .F. , aRc3Header , aCols ) ) )
					cRc3Form01	:= SetGpeBlock( AllTrim( GdFieldGet( "RC3_FORM01" , 1 , .F. , aRc3Header , aCols ) ) )
					cRc3Form02  := SetGpeBlock( AllTrim( GdFieldGet( "RC3_FORM02" , 1 , .F. , aRc3Header , aCols ) ) )
	
					//AddLocal( cRc3Result , @aLocal )
					//AddLocal( cRc3Form01 , @aLocal )
					//AddLocal( cRc3Form02 , @aLocal )
					AddLocal( cRc3Result + cRc3Opera1 + cRc3Form01 + cRc3Opera2 + cRc3Form02, @aLocal )

					cExprAdd := ( cIdent + cIdent + "( " + cRc3Form01 + cRc3Opera2 + cRc3Form02 + " );" )
					AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )

					IF ( cRc3Opera3 $ ".AND./.OR." )

						cExprAdd := ( cIdent + cIdent + cRc3Opera3 + ";" )
						AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )

					ElseIF ( cRc3Opera3 == ".END." )

						cExprAdd := ( cIdent + ")" )
						AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
						AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )                

						Exit

					EndIF
				
				Next nLoop

				AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )
				cExprAdd := ( cIdent + cIdent + "IF ( AbortProc() ) " )
				AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )

				//AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )
				cExprAdd := ( cIdent + cIdent + cIdent + "Break" )
				AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
            	
				//AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )
				cExprAdd := ( cIdent + cIdent + "EndIF" )
				AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
				AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )
				AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )
				
				MkeBodyFrm( @aBodyFrm , adbTreeForm[ nLoop , NODE_TREE ] , aRc3Header , cReturn , cNodeMaster , @aLocal , nIdent + 4 )

			//AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )
			cExprAdd := ( cIdent + "End" )
			AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )

		ElseIF ( cRc3Tipo == ".EXE." )

			IF (;
					( cRc3Opera3 == ".END." );
					.and.;
					!Empty( cReturn );
					.and.;
					!( cReturn == cRc3Result );
				)

				cExprAdd := ( cIdent + cReturn + " := " + cRc3Result + cRc3Opera1 + cRc3Form01 + cRc3Opera2 + cRc3Form02 )
				AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
				AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )

			Else

				cExprAdd := ( cIdent + cRc3Result + cRc3Opera1 + cRc3Form01 + cRc3Opera2 + cRc3Form02 )
				AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
				AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )

			EndIF
			
			IF !Empty( adbTreeForm[ nLoop , NODE_TREE ] )
			
				MkeBodyFrm( @aBodyFrm , adbTreeForm[ nLoop , NODE_TREE ] , aRc3Header , cReturn , cNodeMaster , @aLocal , nIdent + 4 )
			
			EndIF

		//# Tratamento de Mensagens
		ElseIF (;
				( cRc3Tipo == ".MSG." );
				.and.;
				( cRc3Opera3 $ ".CNT." );
				)
					cExprAdd := ( cIdent + "//# " + cRc3Result )
					AddBodyFrm( @aBodyFrm , cExprAdd , cRc3SeqFor , cRc3SeqPai )
					AddBodyFrm( @aBodyFrm , "" , cRc3SeqFor , cRc3SeqPai )

		EndIF

	EndIF

Next nLoop

Return( aBodyFrm )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³AddBodyFrm		³ Autor ³Marinaldo de Jesus³ Data ³05/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Adiciona o Corpo da Formula no aBodyFrm        				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³TreeFrmMke                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function AddBodyFrm( aBodyFrm , cExprAdd , cSeqFrm , cSeqPai )

Local cUpper		:= Upper( cExprAdd )

Local lChkCriaLocal
Local nAt

Begin Sequence

	cExprAdd := ExecFunRmv( cExprAdd )

	cUpper	:= Upper( cExprAdd )
	While ( ( nAt := At( "FIMENQUANTO()" , cUpper ) ) > 0 )
		cUpper 		:= Stuff( cUpper 	, nAt , 13 , "" )
		cExprAdd	:= Stuff( cExprAdd	, nAt , 13 , "Exit" )
	End While

	cUpper	:= Upper( cExprAdd )
	While ( ( nAt := At( "RETORNEENQ()"	, cUpper ) ) > 0 )
		cUpper 		:= Stuff( cUpper 	, nAt , 12 , "" )
		cExprAdd	:= Stuff( cExprAdd	, nAt , 12 , "Loop" )
	End While

	cUpper	:= Upper( cExprAdd )
	While ( ( nAt := At( "FIMFORMULA()"	, cUpper ) ) > 0 )
		cUpper 		:= Stuff( cUpper 	, nAt , 12 , "" )
		cExprAdd	:= Stuff( cExprAdd	, nAt , 12 , "Break" )
	End While

	lChkCriaLocal := !Empty( ChkCriaLocal( @cExprAdd , .F. , .T. ) )
	IF (;
			( lChkCriaLocal );
			.and.;
			Empty( cExprAdd );
		)
		Break
	EndIF

	aAdd( aBodyFrm , { cExprAdd , { cSeqFrm , cSeqPai } } )

End Sequence

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³AddLocal		³ Autor ³Marinaldo de Jesus³ Data ³03/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Adiciona as Variaveis Locais                   				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³TreeFrmMke                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function AddLocal( cVar , aLocal )

Local aParse
Local aCriaLocal

Local cUpper
Local cInitLocal
Local cPict
Local cType

Local nLoop
Local nLoops
Local nPosMnemo

Begin Sequence

	IF Empty( cVar )
		Break
	EndIF

	cUpper	:= Upper( AllTrim( cVar ) )
	aParse	:= ParseMnemo( cUpper )
	nLoops	:= Len( aParse )
	For nLoop := 1 To nLoops
		cVar := aParse[ nLoop ]
		IF Empty( cVar )
			Loop
		EndIF
		nPosMnemo	:= aScan( __aMnemonicos , { |x| x[1] == cVar } )
		IF (;
				( nPosMnemo > 0 );
				.and.;
				( __aMnemonicos[ nPosMnemo , 6 ] == "3" );
				.and.;
				( aScan( aLocal , { |x| x[1] == cVar } ) == 0 );
			)
			cInitLocal	:= "Local "
			cInitLocal	+= cVar
			cInitLocal	+= " := "
			IF Empty( __aMnemonicos[ nPosMnemo , 3 ] )
				cInitLocal += "GetValType( '" + __aMnemonicos[ nPosMnemo , 4 ] + "' )"
			Else
				cInitLocal += StrTran( __aMnemonicos[ nPosMnemo , 3 ] , '"' , "'" )
			EndIF
			aAdd( aLocal , { cVar , cInitLocal } )
		EndIF
	Next nLoop
	
	IF ( At( "CRIALOCAL" , cUpper ) > 0 )
	
		ChkCriaLocal( cUpper )
		aCriaLocal	:= GetLocal()
		IF !Empty( aCriaLocal )
			aCriaLocal	:= aClone( aCriaLocal[2] )
			nLoops		:= Len( aCriaLocal )
			For nLoop := 1 To nLoops
				cVar	:= aCriaLocal[ nLoop , 1 ]
				IF (;
						!ChkAddVar( cVar );
						.or.;
						( aScan( aLocal , { |x| x[1] == cVar } ) > 0 );
					)
					Loop
				EndIF	
				cInitLocal	:= "Local "
				cInitLocal	+= cVar
				cInitLocal	+= " := "
				IF (;
						( aCriaLocal[ nLoop , 4 ] == NIL );
						.or.;
						( aCriaLocal[ nLoop , 2 ] == "U" );
					)	
					cInitLocal += "GetValType( '" + aCriaLocal[ nLoop , 2 ] + "'," + AllTrim( Str( aCriaLocal[ nLoop , 3 ] ) )  + " )"
				Else
					IF ( aCriaLocal[ nLoop , 2 ] == "C" )
						cInitLocal += "'" + aCriaLocal[ nLoop , 4 ] + "'" 
					Else
						cPict := NIL
						IF ( aCriaLocal[ 1 , 2 ] == "N" )
							cPict	  	:= RetPictVal( aCriaLocal[ nLoop , 4 ] )
						EndIF
					    cInitLocal		+= AllToChar( aCriaLocal[ nLoop , 4 ] , cPict )
					EndIF
				EndIF
				aAdd( aLocal , { cVar , cInitLocal } )
			Next nLoop
		EndIF

	Else

		aParse	:= ParseVar( cUpper )
		nLoops	:= Len( aParse )
		For nLoop := 1 To nLoops
			cVar := aParse[ nLoop ]
			IF Empty( cVar )
				Loop
			EndIF
			IF (;
					ChkAddVar( cVar );
					.and.;
					( aScan( aLocal , { |x| x[1] == cVar } ) == 0 );
				)
				cType := Upper( SubStr( cVar , 1 , 1 ) )
				IF ( cType $ "ABCDLMNO" )
					cInitLocal	:= "Local "
					cInitLocal	+= cVar
					cInitLocal	+= " := "
					cInitLocal	+= "GetValType('" + cType + "')"
					aAdd( aLocal , { cVar , cInitLocal } )
				EndIF
			EndIF
		Next nLoop

	EndIF

End Sequence
	
Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ExecFunRmv		³ Autor ³Marinaldo de Jesus³ Data ³26/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Remove EXECUTE_FUN_ da Expressao							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ExecFunRmv( cExpr )

Local cNewExpr	:= cExpr
Local cUpper	:= Upper( cExpr )

Local nAt

While ( ( nAt := At( "EXECUTE_FUN_" , cUpper ) ) > 0 )
	cUpper 		:= Stuff( cUpper 	, nAt , 12 , "" )
	cNewExpr	:= Stuff( cNewExpr	, nAt , 12 , "" )
End While

Return( cNewExpr )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ChkCriaLocal	³ Autor ³Marinaldo de Jesus³ Data ³10/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Array com os Dados da CriaLocal a Serem Criados  Remo³
³          ³vendo CriaLocal da String								     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ChkCriaLocal( cString , lExecute , lRemove )

Local aParse		:= {}
Local aCriaLocal	:= {}
Local cStringUpper	:= Upper( cString )

Local cStringAux

Local nY
Local nAtLocal0
Local nAtLocal1
Local nTamVar 	:= Len( "CRIALOCAL" )

DEFAULT lExecute	:= .T.
DEFAULT lRemove		:= .F.

cStringAux := cStringUpper
While ( ( nAtLocal0 := At( "CRIALOCAL" , cStringAux ) ) > 0 )
	nAtLocal1 	:= nAtLocal0 + nTamVar
	cCriaLocal	:= SubStr( cStringAux , nAtLocal1, (Len(cStringAux)-nTamVar) )

	IF ( lExecute )
		CheckExecForm( cCriaLocal , .F. )
	Else
		aParse := ParseVar( cCriaLocal )
		IF Len( aParse ) > 0
			For nY := 1 To Len( aParse )
				aAdd( aCriaLocal, aParse[nY] )
			Next nY
		Else
			aAdd( aCriaLocal, cCriaLocal )
		EndIF
	EndIF
	cStringAux	:= Stuff( cStringAux , nAtLocal0 , nTamVar , "" )
	IF ( lRemove )
		cString	:= Stuff( cString	 , nAtLocal0 , nTamVar , "" )
	EndIF
End While

Return( aCriaLocal )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³SetGpeBlock		³ Autor ³Marinaldo de Jesus³ Data ³03/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Transforma ExecBlock em GpecBlock              				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function SetGpeBlock( cForm )
Return( StrTran( Upper( cForm ) , "EXECBLOCK" , "GPECBLOCK" ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GpeCBlock  ³ Autor ³ Wilson               ³ Data ³27/09/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Forca a passagem dos parametros na chamada do ExecBlock.    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GpeCBlock( p1 , p2 , p3 , p4 )                              ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GpeCBlock( P1 , P2 , P3 , P4 )
Return( ExecBlock( P1 , .F. , .F. , P4 ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Rc2Rc3NewCod	³ Autor ³Marinaldo de Jesus³ Data ³03/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Compatibiliza o Codigo do RC2 e RC3            				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Rc2Rc3NewCod( cRc2Filial , cRc2Origem , cRc2Codigo )

Local cNewCodForm
Local cRc3KeySeek

Local nRc3Order
Local nRc3Recno
Local nRc3NextRecno

Begin Sequence

	cNewCodForm	:= Rc2CodChkStr( cRc2Codigo )

	IF ( cNewCodForm == cRc2Codigo )
		Break
	EndIF

	IF RC2->( !RecLock( "RC2" , .F. ) )
		Break
	EndIF

	RC2->RC2_CODIGO := cNewCodForm
	RC2->RC2_RECOMP := "1"

	nRc3Order :=  RetOrder( "RC3" , "RC3_FILIAL+RC3_ORIGEM+RC3_CODIGO+RC3_SEQFOR" )
	RC3->( dbSetOrder( nRc3Order ) )

	cRc3KeySeek := ( cRc2Filial + cRc2Origem + cRc2Codigo )
	IF !RC3->( dbSeek( cRc3KeySeek , .F. ) )
		Break
	EndIF

	While RC3->(;
					!Eof();
					.and.;
					(;
						( RC3_FILIAL + RC3_ORIGEM + RC3_CODIGO );
						==;
						cRc3KeySeek;
					);
				)

		IF !GetNextRecno( "RC3" , @nRc3NextRecno , @nRc3Recno , nRc3Order )
			Exit
		EndIF
	
		IF RC3->( RecLock( "RC3" , .F. ) )
			RC3->RC3_CODIGO := cNewCodForm
		EndIF

		IF !GotoNextRecno( "RC3" , nRc3NextRecno , nRc3Order )
			Exit
		EndIF
	
	End While

	RC2->( MsUnLock() )
	RC3->( MsUnLock() )

End Sequence

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Rc2CodChkStr	³ Autor ³Marinaldo de Jesus³ Data ³04/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Novo Codigo para o RC2 Retirando os Caracteres Invali³
³          ³dos															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Rc2CodChkStr( cLastCod )

Local cSubStr
Local cNewCod

Local nChar
Local nChars

cNewCod := Upper( AllTrim( cLastCod ) )
IF ( !ChkAsc( cNewCod , .F. ) )
	nChar	:= 0
	nChars	:= Len( cNewCod )
	While ( ( ++nChar ) <= nChars )
		cSubStr := SubStr( cNewCod , nChar , 1 )
		IF !ChkAsc( cSubStr , .F. )
			cNewCod := StrTran( cNewCod , cSubStr , "" )
			--nChar
			nChars := Len( cNewCod )
		EndIF
	End While
EndIF

cNewCod := Padr( SubStr( cNewCod , 1 , 8 ) , GetSx3Cache( "RC2_CODIGO" , "X3_TAMANHO" ) )

Return( cNewCod )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³SetMnemonicos	³ Autor ³Marinaldo de Jesus³ Data ³10/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializa os Mnemonicos para uso em Formulas				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function SetMnemonicos(	cFil		,;	//01 -> Filial para a Carga dos Mnemonicos
						aMnemonicos	,;	//02 -> Array com os Mnemonicos ( Por Referencia )
						lDefaults	,;	//03 -> Se Inicializa os Valores Defaults
						cMnemonico	,;	//04 -> Mnemonico a ser Setado
						lInitLocal	, ;	//05 -> De deverar Setar os Mnemonicos Locais
						cFuncao)

Local aArea
Local aAreaRCA

Local cFilRCA
Local cType

Local lSet
Local lOne

Local nMnemo
Local nMnemos
Local nPosMnem
Local nRcaOrder

Local uVar

Static lDefautsMnemos

DEFAULT lDefaults		:= .F.
DEFAULT cMnemonico		:= ""
DEFAULT lDefautsMnemos	:= .T.
DEFAULT lInitLocal		:= .F.
DEFAULT cFuncao			:= ""

If IsBlind() .Or. IsInCallStack("FwMyTestRunner") .Or. IsInCallStack("EXECSUITE") .Or. IsInCallStack("EXECSUITEBLIND") .Or. IsInCallStack("AUTJOBRUNCT")
	cFuncao := ""
	If Upper(Alltrim(Procname(1))) == "FVLDMODEL" 
		lDefautsMnemos := .F.
		return .T.
	EndIf
EndIf

cMnemonico	:= Upper( AllTrim( cMnemonico ) )
lOne 		:= !Empty( cMnemonico )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verifica se Deve Carregar os Mnemonicos Padroes do Sistema   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lDefautsMnemos )
	fCarMnemo()
	lDefautsMnemos := .F.
EndIF

DEFAULT __aMnemonicos := {}
IF (;
		(;
			!( lDefaults );
			.and.;
			Empty( __aMnemonicos );
		);	
		.or.;
		Empty( __aMnemonicos );
	)

	RstMnemonicos()

	aArea		:= GetArea()
	aAreaRCA	:= RCA->( GetArea() )
	cFilRCA		:= xFilial( "RCA" , cFil )
	nRcaOrder	:= RetOrder( "RCA" , "RCA_FILIAL+RCA_MNEMON" )

	RCA->( dbSetOrder( nRcaOrder ) )
	IF ( lSet := RCA->( dbSeek( cFilRCA , .F. ) ) )
		
		While RCA->( !Eof() .and. ( RCA_FILIAL == cFilRCA ) )
			RcaAddMnemo( @__aMnemonicos )
			RCA->( dbSkip() )
		End While
			
	EndIF

	RestArea( aAreaRCA )
	RestArea( aArea )

EndIF

IF ( lDefaults )
	IF ( lSet := ( nMnemos := Len( __aMnemonicos ) ) > 0 )
		IF ( lOne )
			nPosMnem := aScan( __aMnemonicos , { |x| Upper( AllTrim( x[1] ) ) == cMnemonico } )
			IF ( nPosMnem == 0 )
				aArea		:= GetArea()
				aAreaRCA	:= RCA->( GetArea() )
				IF ( lSet := GetCache( "RCA" , cMnemonico , cFilRCA , NIL , nRcaOrder , .T. ) )
					RcaAddMnemo( @__aMnemonicos )
					nPosMnem := aScan( __aMnemonicos , { |x| Upper( AllTrim( x[1] ) ) == cMnemonico } )
				EndIF
				RestArea( aAreaRCA )
				RestArea( aArea )
			EndIF
		EndIF
		DEFAULT nPosMnem := 1
		IF (;
				!( lOne );
				.or.;
				(;
					( lOne );
					.and.;
					( lSet := ( nPosMnem > 0 ) );
				);	
			)
			For nMnemo := nPosMnem To nMnemos
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Inicializa Apenas Os Mnemonicos Publicos e Privados           ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF !( lInitLocal )
					IF !( __aMnemonicos[ nMnemo , 06 ] $ "1/2" )
						Loop
					EndIF
				EndIF	
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Carrega os valores Defaults do arquivo de mnemonicos		   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF !Empty( uVar := AllTrim( __aMnemonicos[ nMnemo , 03 ] ) )
					IF (;
							( __aMnemonicos[ nMnemo , 04 ] == "D" );
							.and.;
							( "/" $ uVar );
						)
						IF (;
								CheckExecForm( { || uVar := Ctod( uVar ) } , .F. );
								.and.;
								( ( cType := ValType( uVar ) ) == __aMnemonicos[ nMnemo , 04 ] );
							)	
							If Empty(cFuncao)
								_SetOwnerPrvt( __aMnemonicos[ nMnemo , 01 ] , uVar )
							Else
								_setNamedPrvt( __aMnemonicos[ nMnemo , 01 ] , uVar ,cFuncao)
							EndIf
						Else
							If Empty(cFuncao)
								_SetOwnerPrvt( __aMnemonicos[ nMnemo , 01 ] , GetValType( __aMnemonicos[ nMnemo , 04 ] ) )
							Else
								_setNamedPrvt( __aMnemonicos[ nMnemo , 01 ] , GetValType( __aMnemonicos[ nMnemo , 04 ] ),cFuncao )
							EndIf
						EndIF
					Else
						IF CheckExecForm( @uVar , .F. )
							If Empty(cFuncao)
								_SetOwnerPrvt( __aMnemonicos[ nMnemo , 01 ] , uVar )
							Else
								_setNamedPrvt( __aMnemonicos[ nMnemo , 01 ] , uVar ,cFuncao)
							EndIf
						Else
							If Empty(cFuncao)
								_SetOwnerPrvt( __aMnemonicos[ nMnemo , 01 ] , GetValType( __aMnemonicos[ nMnemo , 04 ] ) )
							Else
								_setNamedPrvt( __aMnemonicos[ nMnemo , 01 ] , GetValType( __aMnemonicos[ nMnemo , 04 ] ),cFuncao )
							EndIf
						EndIF
					EndIF
				Else
					If Empty(cFuncao)
						_SetOwnerPrvt( __aMnemonicos[ nMnemo , 01 ] , GetValType( __aMnemonicos[ nMnemo , 04 ] ) )
					Else
						_setNamedPrvt( __aMnemonicos[ nMnemo , 01 ] , GetValType( __aMnemonicos[ nMnemo , 04 ] ) ,cFuncao)
					EndIf
				EndIF
				IF ( lOne )
					Exit
				EndIF
			Next nMnemo
		EndIF
	EndIF
EndIF

aMnemonicos		:= aClone( __aMnemonicos )

DEFAULT lSet	:= .F.

Return( lSet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetContMnemon   ³ Autor ³Mauricio Takakura ³ Data ³03/02/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Pegar o conteudo Inicial do Mnemonico.       				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetContMnemon(	cFil		,;	//01 -> Filial para a Carga dos Mnemonicos
						cMnemo		 ;	//02 -> Nome do Mnemonico
					  )
Local cType

Local nPos

Local uRetConteud
Local uValor
          
cMnemo := UPPER( cMnemo )
nPos := aScan( __aMnemonicos, { |x| x[1] == cMnemo } )

If nPos > 0
	uRetConteud := AllTrim( __aMnemonicos[ nPos, 3 ] )
	If ( ( __aMnemonicos[ nPos , 04 ] == "D" ) .and. ( "/" $ uRetConteud ) )
		If ( CheckExecForm( { || uValor := Ctod( uRetConteud ) } , .F. ) .and. ;
		   ( ( cType := ValType( uValor ) ) == __aMnemonicos[ nPos , 04 ] )	)	
			uRetConteud := uValor
		Else
			uRetConteud := GetValType( __aMnemonicos[ nPos , 04 ] )
		EndIf
	Else
		uValor := uRetConteud
		If CheckExecForm( @uValor , .F. )
			uRetConteud := uValor
		Else
			uRetConteud := GetValType( __aMnemonicos[ nPos , 04 ] )
		EndIf
	EndIf
EndIf

Return( uRetConteud )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RstMnemonicos	³ Autor ³Marinaldo de Jesus³ Data ³11/09/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Reinicializa a Static __aMnemonicos							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstMnemonicos()
__aMnemonicos := {}
Return( NIL )

Function RstlDefaut()
	lDefautsMnemos	:= .T.
Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³SaveMnemonicos  ³ Autor ³Marinaldo de Jesus³ Data ³02/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Salva o conteudo dos Mnemonicos								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function SaveMnemonicos()

Local aSvMnemonicos := {}

Local nMnemo
Local nMnemos

nMnemos := Len( __aMnemonicos )
For nMnemo := 1 To nMnemos
	aAdd( aSvMnemonicos , { __aMnemonicos[ nMnemo , 1 ] , GetMemVar( __aMnemonicos[ nMnemo , 1 ] ) } ) 
Next nMnemo

Return( aSvMnemonicos )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RestoreMnemonicos³Autor ³Marinaldo de Jesus³ Data ³02/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Restaura o conteudo dos Mnemonicos							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RestoreMnemonicos( aSvMnemonicos )

Local nMnemo
Local nMnemos

nMnemos := Len( aSvMnemonicos )
For nMnemo := 1 To nMnemos
	SetMemVar( aSvMnemonicos[ nMnemo , 1 ] , aSvMnemonicos[ nMnemo , 2 ] )
Next nMnemo

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RcaAddMnemo		³Autor³Marinaldo de Jesus  ³ Data ³09/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Adiciona Mnemonicos no Array aMnemonicos baseado no RCA 	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function RcaAddMnemo( aMnemonicos )

Local cRcaMnemon	:= AllTrim( RCA->RCA_MNEMON )

DEFAULT aMneMonicos := {}

IF ( aScan( aMneMonicos , { |x| x[1] == cRcaMnemon } ) == 0 )
	RCA->( aAdd( aMneMonicos , {;
									cRcaMnemon		,;	//01 - Codigo do Mnemonico
									RCA_DESC		,;	//02 - Descricao do Mnemonico
									If(Empty(RCA_CONTEU), GetValType(RCA_TIPO), If( Upper(AllTrim( RCA->RCA_MNEMON )) == "P_REGPARCI" .And. lRefTrab , .F., RCA_CONTEU)),;//03 - Conteudo DEFAULT do Mnemonico
									RCA_TIPO		,;	//04 - Tipo do Mnemonico
									Recno()			,;	//05 - Recno do Mnemonico
									RCA_ACUMUL		 ;	//06 - Instancia do Mnemonico
								};
				);
		)
EndIF
	
Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CheckExecForm	³Autor³Marinaldo de Jesus  ³ Data ³07/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Executa as Formulas para Verificacao de Erros         	 	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function CheckExecForm( uExec , lShowHelp , cHelp , cMsgHelp , lAddLogExecRot )

Local bErro			:= ErrorBlock( { |oErr| ErroForm( oErr , @lExecOk , lShowHelp , cHelp , @cMsgHelp , lAddLogExecRot ) } )
Local lExecOk		:= .T.
Local cTipoExec		:= ""
Local l270 			:= FunName() == "GPEA270"
Local lFuncao 		:= If(l270,FindFunction(AllTrim(uExec)),.F.)

DEFAULT uExec		:= ""
DEFAULT lShowHelp	:= .T.

cTipoExec			:= ValType( uExec )

Begin Sequence
	If ( cTipoExec == "C" )
		uExec := __ExecMacro( uExec )
		If l270
			If lFuncao .And. ValType(uExec) == "L"
				lExecOk := .F.
				cHelp := "ERR_FORM"
				cMsgHelp := STR0067
				Help( "" , 1 , cHelp , NIL , cMsgHelp , 3 , 1 )
			EndIf
		EndIf
	ElseIf ( cTipoExec == "B" )
		uExec := Eval( uExec )
	EndIf
End Sequence

ErrorBlock( bErro )

Return( lExecOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ErroForm 		³Autor³Marinaldo de Jesus  ³ Data ³07/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica os Erros na Execucao da Formula                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function ErroForm(	oErr			,;	//01 -> Objeto oErr
							lNotErro		,;	//02 -> Se Ocorreu Erro ( Retorno Por Referencia )
							lShowHelp		,;	//03 -> Se Devera Mostrar o Help
							cHelp			,;	//04 -> Nome do Help a Ser Mostrado
							cMsgHelp		,;	//05 -> Mensagem Complementar para o Helo ( Podera ser Retornada Por Referencia )
							lAddLogExecRot	 ;	//06 -> Se Esta Executando aa Partir da ExecRot, verifica se Deve Adicionar Log
						)

Local aErrorStack

DEFAULT lNotErro	:= .T.
DEFAULT lShowHelp	:= .T.

IF !( lNotErro := !( oErr:GenCode > 0 ) )
	IF ( lShowHelp )
		DEFAULT cMsgHelp		:= ""
		DEFAULT lAddLogExecRot	:= IsInCallStack( "EXECROT" )
		IF !Empty( cMsgHelp )
			IF ( lAddLogExecRot )
				AddLogExecRot( cMsgHelp )
				cMsgHelp	:= ""
			Else
				cMsgHelp	+= CRLF
			EndIF
		EndIF
		cMsgHelp += "Error Description: "
		cMsgHelp += oErr:Description
		IF ( lAddLogExecRot )
			AddLogExecRot( cMsgHelp )
			aErrorStack	:= Str2Arr( oErr:ErrorStack , Chr( 10 ) )
			aEval( aErrorStack , { |cStackError| RotAddErr( cStackError ) } )
		Else
			DEFAULT cHelp	:= "ERR_FORM"
			Help( "" , 1 , cHelp , NIL , cMsgHelp , 3 , 1 )
		EndIF	
	EndIF
EndIF

Break

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ValidRot		³Autor³Marinaldo de Jesus ³ Data ³27/02/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Valida o Tamanho da Expressao digitada no Roteiro           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ValidRot( cTitulo , cMemo , nSizeCpo )						³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³lValid 														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cTitulo		-> Titulo do Campo a ser Validado				³
³          ³cMemo		-> Expressao para Validacao						³
³          ³nSizeCpo	-> Tamanho do Campo para Validacao				³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ValidRot( cTitulo , cMemo , nSizeCpo )

Local lValid	:= .F. 
Local cMsg		:= ""
Local nSizeMemo	:= 0

DEFAULT cTitulo 	:= ""
DEFAULT cMemo		:= ""
DEFAULT nSizeCpo	:= 0.01

cMemo := ClearChar( cMemo )

IF  !( lValid := ( ( nSizeMemo := Len( cMemo ) ) <= nSizeCpo ) )
	cMsg := ( STR0001 + '"' + cTitulo + '"' + STR0002 + CRLF )	//"A Express„o da"###"Ultrapassou o tamanho m ximo permitido para o campo."
	cMsg += ( STR0003 + CRLF )									//"Favor refazer a Express„o ou criar Sub-Sequencias."
	cMsg += CRLF
	cMsg += CRLF
	cMsg += ( STR0004 + StrZero( nSizeCpo  , 10 ) + CRLF )		//"Tamanho do Campo: "
	cMsg += ( STR0005 + StrZero( nSizeMemo , 10 ) )				//"Tamanho da Express„o: "
	MsgAlert( OemToAnsi( cMsg ) , OemToAnsi(STR0006) )			//"Aten‡„o"
EndIF

Return( lValid )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ClearChar		³Autor³Marinaldo de Jesus ³ Data ³27/02/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Valida o Tamanho da Expressao digitada no Roteiro           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ClearChar( cMemo )											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ValidRot() em GPEA160                                       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³cMemo  														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cMemo  		-> Expressao a ser limpa         				³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function ClearChar( cMemo )

cMemo := IF( Empty( cMemo ) .or. ValType( cMemo ) != "C" , "" , cMemo )

cMemo := AllTrim( cMemo )
cMemo := NoAcento( ftAcento( cMemo ) )
cMemo := StrTran( cMemo , Chr(13) , "" )
cMemo := StrTran( cMemo , Chr(10) , "" )
cMemo := AllTrim( cMemo )

Return( cMemo )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetMemVar		³ Autor ³Marinaldo de Jesus³ Data ³30/01/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem e Retorna o Conteudo de uma Variavel de Memoria		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³uRetValue                                           	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetMemVar( cVar , lInitPad , cLado )

Local cVarAux
Local uRetValue

DEFAULT cVar 		:= "__Undefined__"
DEFAULT lInitPad	:= .F.

cVar := Upper( AllTrim( cVar ) )
IF !( "M->" == SubStr( cVar , 1 , 3 ) )
	cVar := ( "M->" + cVar )
EndIF

IF ( IsMemVar( cVar ) )
	uRetValue := __ExecMacro( cVar )
Else
	IF !( cVar == Upper( "__Undefined__" ) )
		cVarAux := SubStr( cVar , 4 )
		IF !( GetSx3Cache( cVarAux , "X3_CAMPO" ) == NIL )
			uRetValue := CriaVar( cVarAux , lInitPad , cLado , .F. )
		EndIF
	EndIF
EndIF

Return( uRetValue )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³SetMemVar		³ Autor ³Marinaldo de Jesus³ Data ³30/01/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Atualiza conteudo da Variavel de Memoria     				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³uLastVal                                               	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function SetMemVar(		cVar			,;	//Variavel de Memoria a ser Setada.
						uSetValue		,;	//Conteudo a ser Setado.
						lSetOwnerPrvt	,;	//Se cria em uma instancia superior caso nao exista.
						lForceSetOwner	,;	//Se forca a criacao em uma instancia acima
						lRetLastValue	,;	//Se retorna o valor anterior.
						lInitPad		,;	//Se utiliza o Inicializador padrao em GetMemVar().
						cLado			 ;	//Lado para o Inicializador padrao para FieldType <=>"C".
				  )

Local uRetValue

DEFAULT cVar 			:= "__Undefined__"
DEFAULT lSetOwnerPrvt	:= .F.
DEFAULT lRetLastValue	:= .F.
DEFAULT lForceSetOwner	:= .F.

cVar := Upper( AllTrim( cVar ) )
IF !( "M->" == SubStr( cVar , 1 , 3 ) )
	cVar := ( "M->" + cVar )
EndIF

IF ( lRetLastValue )
	uRetValue	:= GetMemVar( SubStr( cVar , 4 ) , lInitPad , cLado )
Else
	uRetValue	:= uSetValue
EndIF
IF (;
		!IsMemVar( cVar );
		.or.;
		( lForceSetOwner );
	)
	IF ( lSetOwnerPrvt )
		_SetOwnerPrvt( SubStr( cVar , 4 ) , uSetValue )
	EndIF
Else
	&( cVar )	:= uSetValue
EndIF

Return( uRetValue )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³IsMemVar		³ Autor ³Marinaldo de Jesus³ Data ³20/03/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica a Existencia de Variavel de Memoria 				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lIsMemVar                                           	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function IsMemVar( cVar )

Local cType
Local cTypeVar
Local lIsMemVar

DEFAULT cVar := "__Undefined__"

cVar := Upper( AllTrim( cVar ) )
IF !( "M->" == SubStr( cVar , 1 , 3 ) )
	cVar := ( "M->" + cVar )
EndIF

cType		:= Type( cVar )	
cTypeVar	:= GetSx3Cache( SubStr( cVar , 4 ) , "X3_TIPO" )
IF (;
		( cTypeVar == "M" );
		.and.;
		( cType == "C" );
	)
	cTypeVar := "C"
EndIF
lIsMemVar	:= IF( cTypeVar <> NIL , ( cType == cTypeVar ) , ( cType <> "U" ) )

Return( lIsMemVar )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³InGpexFormExec³Autor ³Marinaldo de Jesus   ³ Data ³24/08/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Executar Funcoes Dentro de GPEXFORM                          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³InGpexFormExec( cExecIn , aFormParam )						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³uRet                                                 	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function InGpexFormExec( cExecIn , aFormParam )
         
Local uRet

DEFAULT cExecIn		:= ""
DEFAULT aFormParam	:= {}

IF !Empty( cExecIn )
	cExecIn	:= BldcExecInFun( cExecIn , aFormParam )
	uRet	:= __ExecMacro( cExecIn )
EndIF

Return( uRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³MayIExecRot   ³Autor ³Marinaldo de Jesus   ³ Data ³01/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Garante a Exclusividade na Execucao do Roteiro				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³.T., se Tem Exclusividade, Caso Contratio .F.          	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function MayIExecRot()
Return( MayIUseCode( cEmpAnt + "MayIExecRot" ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³LeaveExecRot  ³Autor ³Marinaldo de Jesus   ³ Data ³01/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Libera a Exclusividade na Execucao do Roteiro				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³.T.                                                    	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function LeaveExecRot()
Return( Leave1Code( cEmpAnt + "MayIExecRot" ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³WhileExecRot  ³Autor ³Marinaldo de Jesus   ³ Data ³01/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Tentativa de Exclusividade para a Execucao do Roteiro		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³.T., se Tem Exclusividade, Caso Contratio .F.          	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function WhileExecRot( nWait , lStop )

Local cMsgInfo	:= STR0052	//"As Formulas ou Roteiros estão em uso por outro Processo."
Local cTitInfo	:= STR0053	//"Formulas e/ou Roteiros em uso."
Local cMsgYesNo	:= STR0054	//"Deseja Tentar Novamente?"
Local cTitYesNo	:= IF( Type( "cCadastro" ) == "C" , STR0055 + " " + cCadastro , STR0056 )//"Tendando Acessar"###"Aviso"
Local cMsgWait	:= STR0057	//"Aguarde..."
Local cTitWait	:= STR0058	//"Tentando"

DEFAULT nWait	:= 1000
DEFAULT lStop	:= .T.

Return( WhileYesNoWait( { || MayIExecRot() } , nWait , lStop , cMsgInfo , cTitInfo , cMsgYesNo , cTitYesNo , cMsgWait , cTitWait ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ExecRot		  ³Autor ³Marinaldo de Jesus   ³ Data ³10/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Executa o Roteito de Calculo								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³nRet                                                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ExecRot( cFilExec , cRotExec, lRot, cNomeForm )

Local nRet

Local aGetTreeFrm
Local aTreeErr
Local aRotErr
Local aMnemonErr

Local cType
Local cSvRoteiro
Local cSryFilial	:= ""
Local cFilAux 		:= ""

Local lInExecRot
Local lInitPadrao
Local lInitFrmAux	:= .T.

Local nMnemo
Local nMnemos

Local oRpoForm

Local uVar
Local uCont

Private cBkpFilial	:= ""
Private cBkpRoteiro	:= ""
Private cFunRotExec	:= ""
Private cFunForExec	:= ""

Static __cKeyAux	:= ""

DEFAULT lRot		:= .T.		// se a execucao eh um roteiro ==> .F. == Formula
DEFAULT cNomeForm	:= ""
DEFAULT __lFilRPO   := SuperGetMv("MV_RPOFIL",, .F.) //Gera repositórios auxiliares por filial? -- TMF

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Carregar os Mnemonicos no Array __aMnemonicos				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF Empty( __aMnemonicos )
		IF (;
				!SetMnemonicos( cFilExec , @__aMnemonicos , .F. );	//Aqui __aMnemonicos he Static
				.or.;
				( ( nMnemos := Len( __aMnemonicos ) ) == 0 );
			)	
			DEFAULT aMnemonErr := {}
			aAdd( aMnemonErr , STR0031 )	//"Nao Foi Possivel Carregar os Mnemonicos para a Execucao do Calculo. Verifique a Tabela de Mnemonicos RCA"
			nRet := -1						//Nao Consegui Carregar os Mnemonicos
			Break
		EndIF
	EndIF

	If __lInitFrm .and. !__IniFormPad__ .and. __lFilRPO //Verifica se as fórmulas padrões foram gravadas, caso não existam, força a criação
		cFilAux		:= xFilial( "RC2" , cFilExec )
		If RC2->(DbSeek(cFilAux))
			While RC2->(!Eof() .and. RC2_FILIAL == cFilAux)
				If RC2->RC2_ORIGEM == "S_"
					lInitFrmAux := .F.
					Exit 
				EndIf
				RC2->(DbSkip())
			EndDo
		EndIf 

		If lInitFrmAux
			//Se não existem fórmulas padrões criadas, força compilação de todos os roteiros e fórmulas
			Gpea290FrmInit( .T. )
			GpeGerFrm(.T.)
			Gpea160RotGer( .F., , , , , , , , .T. )
			__lInitFrm := .F.
		EndIf
		GPCallCmpAll("SRY",.T.,.F.,,.T.)
	EndIf	

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Seta o Roteiro a Ser Executado								   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If lRot
		cSvRoteiro 		:= SetRotExec( cRotExec )
	Else
		cSvRoteiro 		:= cRotExec
	EndIf	
	
	// Verifica as Formulas que Precisam ser Compiladas
	If( __lInitFrm )
		If !GetTreeFrm( @aGetTreeFrm , cFilExec , NIL , NIL , .T. , @oRpoForm , .T. )
			nRet		:= -2	//Nao Consegui Inicializar ou Compilar Todas as Formulas
			Break
		EndIf
		__lInitFrm := .F.

	EndIf
	
	If __cLastRotExec # cRotExec

		cSryFilial		:= xFilial( "SRY" , cFilExec )
	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se Deve Adicionar as Formulas Padroes                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If !IsBlind()//Se for JOB, não efetua a verificação
			IF !GpeGerFrm()
				Break 
			EndIF
		EndIf
		
		If lRot
			lInitPadrao := .T.
			If cSryFilial + cRotExec $ __cKeyAux
				lInitPadrao := .F.
			Else
				__cKeyAux += cSryFilial + cRotExec + "*"
			EndIf			

			cFunRotExec := ( GetFunRot( cSryFilial , @cRotExec, , , lInitPadrao ) + "()" )
			
			// Se for JOB, não efetua a verificação
			// Executa nos testes automatizados
			If !IsBlind() .Or. IsInCallStack("FwMyTestRunner") .Or. IsInCallStack("EXECSUITE") .Or. IsInCallStack("EXECSUITEBLIND") .Or. IsInCallStack("AUTJOBRUNCT")
				GPCallCmpAll("SRY",.T.,.F.,,, {cFilExec}) //"Validando a Compilação de Roteiros e Formulas..."
			EndIf
		Else
			cFunRotExec := ( GetFunForm( cSryFilial , @cRotExec ) + "()" )
		EndIf
		
		cBkpFilial	:= cSryFilial
		cBkpRoteiro	:= cRotExec
		
		If __bFunRotExec # NIL
			If GetCbSource( __bFunRotExec ) <> GetCbSource( __CompStr( cFunRotExec ) )
				__bFunRotExec := NIL
			EndIf
		EndIf
	Else
		cFunRotExec := __cFunRotExec
	EndIf
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Verifica se a ExecRot ja Esta Empilhada					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	lInExecRot := ( ( cSvRoteiro <> cRotExec ) .and. IsInCallStack( "EXECROT" ) )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Inicializa os Mnemonicos 									   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	DEFAULT nMnemos := Len( __aMnemonicos )
	For nMnemo := 1 To nMnemos
		IF (;
				( __aMnemonicos[ nMnemo , 06 ] == "3" );		//"3" -> Mnemonicos Local sao inicializados apenas na Formula
				.or.;
				(;
					( __aMnemonicos[ nMnemo , 06 ] == "1" );	//"1" -> Mnemonicos Public sao inicializados apenas uma unica vez
					.and.;
					type(__aMnemonicos[ nMnemo , 01]) <> "U";   //IsMemVar( __aMnemonicos[ nMnemo , 01 ] );
					.and.;
					!( lInExecRot );	//Se ExecRot ja Estiver Empilhada ( chamada via Formula ), Re-Seta os Mnemonicos Public para uso em Novo Roteiro
				);
			)
			Loop
		EndIF

		// "2" -> Mnemonicos Private sao reinicializados a Cada Processo
		IF ( !Empty( uVar := AllTrim( __aMnemonicos[ nMnemo , 03 ] ) ) )
			IF (;
					( __aMnemonicos[ nMnemo , 04 ] == "D" );
					.and.;
					( "/" $ uVar );
				)
				IF (;
						CheckExecForm( { || uVar := Ctod( uVar ) } , .F. );
						.and.;
						( ( cType := ValType( uVar ) ) == __aMnemonicos[ nMnemo , 04 ] );
					)	
					If Empty( __bFunRotExec )
						_SetOwnerPrvt( __aMnemonicos[ nMnemo , 01 ] , uVar )
					Else
						&(__aMnemonicos[ nMnemo , 01 ]) := uVar
					EndIf
				Else
					If Empty( __bFunRotExec )
						_SetOwnerPrvt( __aMnemonicos[ nMnemo , 01 ] , GetValType( __aMnemonicos[ nMnemo , 04 ] ) )
					Else
						&(__aMnemonicos[ nMnemo , 01 ]) := GetValType( __aMnemonicos[ nMnemo , 04 ] )
					EndIf
				EndIF
			Else
				If Empty( __bFunRotExec )
					IF CheckExecForm( @uVar , .F. )
						If Empty( __bFunRotExec )
							_SetOwnerPrvt( __aMnemonicos[ nMnemo , 01 ] , uVar )
						Else
							&(__aMnemonicos[ nMnemo , 01 ]) := uVar
						EndIf
					Else
						aAdd( __aMnemError, { __aMnemonicos[ nMnemo , 01 ] , GetValType( __aMnemonicos[ nMnemo , 04 ] ), __aMnemonicos[ nMnemo , 03 ], uVar } )
						If Empty( __bFunRotExec )
							_SetOwnerPrvt( __aMnemonicos[ nMnemo , 01 ] , GetValType( __aMnemonicos[ nMnemo , 04 ] ) )
						Else
							&(__aMnemonicos[ nMnemo , 01 ]) := GetValType( __aMnemonicos[ nMnemo , 04 ] )
						EndIf
					EndIf
				Else
					If Empty(__aMnemError)
						If Empty(__aMnemonicos[ nMnemo , 03 ])
							uCont := GetValType( __aMnemonicos[ nMnemo , 04 ] )
						Else
							uCont := &(__aMnemonicos[ nMnemo , 03 ])
						EndIf
					Else
						nPosItem := aScan( __aMnemError, { |x| x[1] == __aMnemonicos[ nMnemo , 01 ] } )
						If nPosItem > 0
							uCont := __aMnemError[ nPosItem , 02 ]
						Else
							If Empty(__aMnemonicos[ nMnemo , 03 ])
								uCont := GetValType( __aMnemonicos[ nMnemo , 04 ] )
							Else
								uCont := &(__aMnemonicos[ nMnemo , 03 ])
							EndIf
						EndIf
					EndIf
					&(__aMnemonicos[ nMnemo , 01 ]) := uCont
				EndIF
			EndIF
		Else
			If Empty( __bFunRotExec )
				_SetOwnerPrvt( __aMnemonicos[ nMnemo , 01 ] , GetValType( __aMnemonicos[ nMnemo , 04 ] ) )
			Else
				&(__aMnemonicos[ nMnemo , 01 ]) := GetValType( __aMnemonicos[ nMnemo , 04 ] )
			EndIf
		EndIF
	Next nMnemo

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Compilando Bloco para a Execucao do Roteiro      		   	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF Empty( __bFunRotExec )
		If 	lRot
			IF (;
					( __cFunRotExec <> cFunRotExec );
					.or.;
					( __bFunRotExec == NIL );
				)	

				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Carregando o Roteiro para Calculo                		   	   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				If cBkpFilial <> cSryFilial .Or. cBkpRoteiro <> cRotExec
					cFunRotExec := ( GetFunRot( cSryFilial , @cRotExec ) + "()" )
				Endif
				
				IF ErrorInRot()
					nRet	:= -3	//Nao Consegui Inicializar ou Compilar o Roteiro
					Break
				EndIF
				
				__cFunRotExec	:= cFunRotExec
		
				IF !CheckExecForm( { || __bFunRotExec := __CompStr( cFunRotExec ) } , .T. , NIL , NIL , .T. )
					nRet	:= -4	//Ocorreu Erro ao Compilar a Funcao para Executar o Roteiro
					Break
				EndIF

			EndIF
    
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Execucao de uma determinada formula diretamente  		   	   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		Else
			If cBkpFilial <> cSryFilial .Or. cBkpRoteiro <> cRotExec
				cFunRotExec := GetFunForm( cSryFilial , @cRotExec )
			Endif
			IF !Empty( _aGetTreeErr )
				nRet := -2		//Nao Consegui Inicializar ou Compilar Todas as Formulas
				Break
			EndIF
			 cFunRotExec += "()"
	
			__cFunRotExec	:= cFunRotExec
			IF !CheckExecForm( { || __bFunRotExec := __CompStr( cFunRotExec ) } , .T. , NIL , NIL , .T. )
				nRet	:= -2	//Nao Consegui Inicializar ou Compilar Todas as Formulas
				Break
			EndIF
		EndIF
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Executando Roteiro de Calculo                    		   	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !CheckExecForm( { ||&cFunRotExec } , .T. , NIL , NIL , .T. )
		nRet	:= -5	//Ocorreu Erro ao Executar o Roteiro
		Break
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Funcao que Verifica a Finalizacao do Calculo				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF IsEndCalc()
		nRet := 2	//Nao Ocorreu Erro, Finalizacao de Calculo
		cNomeForm := cFunForExec
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Funcao que Verifica Se Deve Desprezar o Registro			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF lRot
		IF IsNoPrcReg()
			nRet := 1	//Nao Ocorreu Erro, Nao Processar o Registro
			cNomeForm := cFunForExec
		EndIF
	EndIF

End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Se nao Ocorreu nenhuma Inconsistencia, Carrega o valor DEFAULT³
³para nRet													   ³
³         													   ³
³Valores Positivos ( Nao ocorrencia de Erros )				   ³
³         													   ³
³nRet == 0 	-> ExecRot() TudoOk								   ³
³nRet == 1 	-> Desprezar o Registro duranto o Processamento	   ³
³nRet == 2 	-> Forcar a Finalizacao do Calculo	   			   ³
³         													   ³
³Valores Negativos ( Ocorrencia de Erros )				   	   ³
³         													   ³
³nRet == -1	-> Erro ao Carregar os Mnemonicos              	   ³
³nRet == -2	-> Erro ao Carregar as Formulas					   ³
³nRet == -3	-> Erro ao Carregar o Roteiro					   ³
³nRet == -4	-> Erro ao Compilar a Funcao de Roteiro			   ³
³nRet == -5	-> Erro ao Executar o Roteiro					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
DEFAULT nRet	:= 0

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carrega Erros de Mnemonicos                      			   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( nRet == -1 )
	IF !Empty( aMnemonErr )
		aEval( aMnemonErr , { |cErr| aAdd( _aLogExecRot[ 1 , 2 ] , cErr ) } )
	EndIF
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carrega Erros de Formula                         			   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( nRet == -2 )
	aTreeErr	:= GetTreeErr()
	IF !Empty( aTreeErr )
		aEval( aTreeErr , { |cErr| aAdd( _aLogExecRot[ 2 , 2 ] , cErr ) } )
	EndIF
EndIF	

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carrega os Erros de Roteiro                      			   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF (;
		( nRet >= -5 );
		.or.;
		( nRet <= -3 );
	)
	aRotErr := RotGetErr()
	IF !Empty( aRotErr )
		aEval( aRotErr , { |cErr| aAdd( _aLogExecRot[ 3 , 2 ] , cErr ) } )
	EndIF
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Restaura o Roteiro de Entrada                    			   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If lRot
	SetRotExec( cSvRoteiro )
EndIf

__cLastRotExec := cRotExec
__cFunRotExec := cFunRotExec

Return( nRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ExecForm	  ³Autor ³Mauricio T. Takakura ³ Data ³10/02/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Executa uma determinada formula								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³ nRet                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ExecForm( cFilExec , cFormula, cRotForm )

Local cSvRoteiro 

Local nRet

cSvRoteiro := SetRotExec( If( Empty(cRotForm), cFormula, cRotForm ) )

nRet := ExecRot( cFilExec , cFormula, .F. )

SetRotExec( cSvRoteiro )

Return( nRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³LogExecRot	  ³Autor ³Marinaldo de Jesus   ³ Data ³10/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Array com os Logs na ExecRot            			 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³aLogExecRot                                            	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function LogExecRot()

Local aLogExecRot

DEFAULT _aLogExecRot	:= {}

aLogExecRot				:= aClone( _aLogExecRot )
InitLogExecRot()

Return( aLogExecRot )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³AddLogExecRot ³Autor ³Marinaldo de Jesus   ³ Data ³27/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Utilizar na Montagem das Formulas de Roteiro para Adicao   de³
³          ³Informacoes no Log											 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL		                                            	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function AddLogExecRot( cMsg )

Local aMsg

Local nMsg		:= Len( cMsg )

IF ( nMsg > 220 )
	aMsg := {}
	While ( nMsg > 220 )
		aAdd( aMsg , SubStr( cMsg , 1 , 220 ) )
		cMsg := SubStr( cMsg , 221 )
		IF ( ( nMsg := Len( cMsg ) ) < 220 )
			aAdd( aMsg , cMsg )
			Exit
		EndIF
	End While
	aEval( aMsg , { |cMsg| AddLogExecRot( cMsg ) } )
ElseIF Len( _aLogExecRot) == 0   
	InitLogExecRot()  
ElseIF ( aScan( _aLogExecRot[ 4 , 2 ] , { |x| x == cMsg } ) == 0 )
	aAdd( _aLogExecRot[ 4 , 2 ] , cMsg )
EndIF	

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetRotExec	  ³Autor ³Marinaldo de Jesus   ³ Data ³11/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna o Roteiro em Execucao no Momento       				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³__cRotInExec ( Roteiro em Execucao )						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetRotExec()
DEFAULT __cRotInExec := "__cRotInExec"
Return( __cRotInExec )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³SetRotExec	  ³Autor ³Marinaldo de Jesus   ³ Data ³11/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Seta o Roteiro para Execucao                   				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³cLastRot ( Roteiro Anterior em Execucao )					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function SetRotExec( cNewRot )

Local cLastRot

DEFAULT __cRotInExec	:= "__cRotInExec"
cLastRot				:= __cRotInExec
__cRotInExec			:= cNewRot

Return( cLastRot )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³FinalFun		 ³Autor³Mauro Sergio       ³Data ³12/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Finaliza calculo do Funcionario								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³FinalFun()													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Calculo Gpexcal1 Gpexcalc                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NoPrcReg()													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aTabelas -> Array com a carga da tabela       				³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function FinalFun()
Return( NoPrcReg() )	//Variavel que define se deve continuar calculo do funcionario ou pular para o proximo.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³FinalCalc		 ³Autor³Mauro Sergio       ³Data ³12/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Finaliza calculo											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³FinalCalc()													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas para uso no Roteiro de Calculo                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³EndCalc()													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³NIL															³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function FinalCalc()
Return( EndCalc() )		//Variavel que define se calculo deve continuar ou ser abortado.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetStackFormula  ³Autor³Marinaldo de Jesus³ Data ³21/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica se Esta Executando a Partir de Uma Formula			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                     								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetStackFormula()

Local cCallStack	:= ""
Local nCallStack	:= 0

While ( !Empty( cCallStack := ProcName( ++nCallStack ) ) )
	If (;
			( SubStr( cCallStack , 1 , 2 ) $ "S_/U_" );
			.and.;
			GetCache( "RC2" , cCallStack , NIL , NIL , RetOrder( "RC2" , "RC2_FILIAL+RC2_ORIGEM+RC2_CODIGO" , .F. ) );
		)
		Exit
	EndIf
End While

Return( cCallStack )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetLastRot		 ³Autor³Leandro Drumond   ³ Data ³26/02/2014³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna o ultimo roteiro executado (pilha de roteiros)		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                     								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetLastRot()

Return cSvSetRot

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RstLastRot   	 ³Autor³Leandro Drumond   ³ Data ³13/01/2015³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Altera o valor da variavel __cLastRotExec					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                     								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstLastRot(cRotAux)

DEFAULT cRotAux := "__cLastRotExec"

__cLastRotExec	:= cRotAux

Return Nil 

/*/{Protheus.doc} fFunExec
Função que verifica qual fórmula solicitou a parada na execução do roteiro via FinalCalc()/FinalFun()
@author Allyson Mesashi
@since 22/03/2018
@version 1.0
/*/
Static Function fFunExec()

Local aCalls	:= {}
Local nCont		:= 1

If IsInCallStack("Execrot")
	While ProcName(nCont) != SubStr(cFunRotExec, 1, Len(cFunRotExec)-2)
		aAdd(aCalls, {nCont, ProcName(nCont)})
		nCont ++
	End While
	
	aSort( aCalls , NIL , NIL , { |x,y| ( x[1] > y[1] ) } )
	For nCont := 1 To Len(aCalls)
		If At("S_", aCalls[nCont,2]) > 0 
			cFunForExec := aCalls[nCont,2]
			Exit
		EndIf
	Next nCont
EndIf

Return

/*/{Protheus.doc} RstStMem
Merge Memória de Cálculo - Função para restaurar o conteúdo do mnemônico.
@author Henrique Ferreira
@since 28/08/2018
@version 1.0
/*/
Function RstStMem()

__lMemCalc := cPaisLoc == "BRA" .And. FindFunction("fGrvLogFun") .And. Type("P_LMEMCALC") <> "U" .And. P_LMEMCALC

Return


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ GrvReliq ³ Autor ³ Jonatas A. T. Alves   ³ Data ³ 03.02.10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava as Verbas da Matriz de Impostos Reliqudiados na RGV. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GrvReliq(X)												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ X =	Matriz Multi contendo						    	  ³±±
±±³	 		 ³ Codigo da Verba , Referencia, Valor, Competencia.          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso 	 ³ Gravacao da reliquidacao para o Chile.                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GrvReliq( aPdRlq )

Local cCodRlq	:= aPdRlq[1] // Codigo da verba
Local nPdRef	:= aPdRlq[2] // Quantidade de horas/dias
Local nValRlq	:= aPdRlq[3] // Valor
Local cDatArq	:= aPdRlq[4] // Competencia de referencia (meses retroativos)
Local cCompRlq	:= aPdRlq[5] // Competencia de calculo (mes de geracao da reliquidacao)
Local cRescEft	:= ""
Local lTemItem	:= RGV->( FieldPos("RGV_ITEM") # 0 )
Local lTemClVl	:= RGV->( FieldPos("RGV_CLVL") # 0 )
Local dDtPgRlq	:= Ctod("//") // Data de pagamento
Local dDtGera	:= Ctod("//") // Data de geracao da rescisao

If Type("dDt_Pgto") # "U" // Data de pagto. da Folha
	dDtPgRlq	:= dDt_Pgto
ElseIf Type("M->RG_DATAHOM") # "U" // Data de pagto. da Rescisao
	dDtPgRlq	:= M->RG_DATAHOM
	dDtGera		:= M->RG_DTGERAR
	cRescEft	:= If( Type("cEfetiva") # "U", If( cEfetiva == "C" , "S" , cEfetiva ), "" )
EndIf

dbSelectArea("RGV")
dbSetOrder(1)

If dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cCompRlq + cDatArq + cCodRlq )
	RecLock( "RGV", .F., .T. )
	
	RGV->RGV_VALOR	+= nValRlq
Else
	RecLock( "RGV", .T., .T. )
	
	RGV->RGV_FILIAL	:= SRA->RA_FILIAL
	RGV->RGV_MAT 	:= SRA->RA_MAT
	RGV->RGV_ANOMES	:= cCompRlq
	RGV->RGV_DATARQ	:= cDatArq
	RGV->RGV_PD		:= cCodRlq
	RGV->RGV_HORAS	:= nPdRef
	RGV->RGV_VALOR	:= nValRlq
	RGV->RGV_DATPGT	:= dDtPgRlq
	RGV->RGV_TIPO2	:= "C"
	RGV->RGV_CC		:= SRA->RA_CC
	RGV->RGV_DTGERA	:= dDtGera
	RGV->RGV_EFETIV	:= cRescEft
	
	If lTemItem .And. lTemClVl
		RGV->RC_ITEM	:= SRA->RA_ITEM
		RGV->RC_CLVL	:= SRA->RA_CLVL
	EndIf
EndIf
	
MsUnlock()

Return( NIL )
