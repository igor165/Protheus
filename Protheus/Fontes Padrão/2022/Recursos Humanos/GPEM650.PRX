#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEM650.CH"
#INCLUDE "Report.ch"

Static aInssEmp		:= If( Type("aInssEmp") == "A", aInssEmp, {} ) // Array com os dados do parametro 14
Static lGp650Chk 	:= ExistBlock("GP650CHK")
Static lGp650Cpo 	:= ExistBlock("GP650CPO")
Static lGp650Acm	:= ExistBlock("GP650ACM")
Static lRc1Arelin 	:= RC1->( FieldPos('RC1_ARELIN') ) > 0
Static lGP650CFO    := ExistBlock("GP650CFO")
Static lCtrlTit		:= !Empty(GetNewPar("MV_BTITRES", "" )) .And. !Empty(GetNewPar("MV_BTITFOL", "" )) .And. !Empty(GetNewPar("MV_BTITADT", "" )) .And. !Empty(GetNewPar("MV_BTITFER", "" ))
Static lTamTitDif   := ChkFile("RJ1") .And. TamSX3( "RC1_NUMTIT" )[1] <> TamSX3( "RJ1_NUMTIT" )[1]
Static lMsgRJ1      := .T.

Static cFilLastNum	:= ""
Static lTitLog1 := .F.
Static lTitLog2 := .F.
Static lTitLog3 := .F.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GPEM650  ³ Autor ³ Emerson Rosa de Souza ³ Data ³ 09/08/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Gera Movimentacao de Titulos no arquivo RC1                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Altera‡„o                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Cecilia H Y ³15/05/13³M12RH01³Unificacao da Folha de Pagamento         ³±±
±±³Flavio Correa³07/05/14³TPKHR3³Replica V11 Desoneração   				. ³±±
±±³Gustavo M.  ³02/07/14³TPYCXG³Ajuste para nao fixar o valor com a inte- ³±±
±±³            ³        ³      ³gracao com o logix ativada.				  ³±±
±±³Alberto M   ³19/08/14³TPXWQ2³Inclusao do campo de Cod. Retencao para   ³±±
±±             ³        ³      ³geracao de titulo e integracao com Finan  ³±±
±±             ³        ³      ³ceiro.                                    ³±±
±±³Alberto M   ³19/09/14³TPXWQ2³Tratamento de parametros dDataDeT e       ³±±
±±             ³        ³      ³(dDataAteT) tem que sempre estar no mesmo ³±±
±±             ³        ³      ³mes                                       ³±±
±±³Alberto M   ³09/10/14³TPXWQ2³Tratamento para geracao de titulos apenas ³±±
±±             ³        ³      ³usando definicoes(RC0) da filial corrente ³±±
±±³Flavio Corre³22/06/15³TSRHGG³Ajuste na busca da SR para ferias,        ³±±
±±³            ³        ³      ³RR_DATA = RH_DATAINI                      ³±±
±±³Gabriel A.  ³14/10/15³TSXBDD³Alteração para consistir a duplicidade de ³±±
±±³            ³        ³      ³títulos (Réplica)                         ³±±
±±³Gabriel A.  ³07/12/15³TTWPVL³Alterações para: não gerar error log ao   ³±±
±±³            ³        ³      ³gerar título definido por usuário sem     ³±±
±±³            ³        ³      ³informar verba e não gerar títulos em     ³±±
±±³            ³        ³      ³looping quando houver data de vencimento  ³±±
±±³            ³        ³      ³baseada em um registro de uma tabela      ³±±
±±³Gabriel A.  ³10/12/15³TTRWND³Alterações para considerar a data de      ³±±
±±³            ³        ³      ³pagamento no momento da geração do título ³±±
±±³Raquel Hager³07/01/15³TUDZYG³Ajuste na variável cNovoTit (GPEM650) como³±±
±±³            ³        ³      ³private para que, ao possuir os pontos de ³±±
±±³            ³        ³      ³entrada GP650CHK e GP650ACM, sistema pro- ³±±
±±³            ³        ³      ³cesse corretamente, conforme link do tdn. ³±±
±±³Joao Balbino³02/02/16³TUEUB7³Feito ajuste para considerar o filtro 	  ³±±
±±³            ³        ³      ³informado na geração do título 			  ³±±
±±³Esther V.   ³30/05/16³TVFY37³Ajuste na validacao de acesso de filiais  ³±±
±±³            ³        ³      ³do usuario.					 			  ³±±
±±³Raquel Hager³21/09/16³TVUPNJ ³Remoção de validação quanto ao preenchi- ³±±
±±³            ³        ³       ³mento da data de pagamento.			  ³±±
±±³Cícero Alves³26/10/16³TW5891 ³Ajuste para incluir os campos contidos no³±±
±±³            ³        ³       ³cCamposRC0 na query executada na RC0	  ³±±
±±³Oswaldo L.  ³01/02/17³MRH5505³Trativa para que o sistema apenas utiliz³±±
±±³            ³        ³       ³os campos de acordo com o pais conectado³±±
±±³Gabriel A.  ³01/03/17³MRH-  ³Alterações no cadastro automático de      ³±±
±±³            ³        ³5585  ³fornecedores.                             ³±±
±±³Raquel Hager³12/01/17³MRH-4110³Agrupamento por beneficiario na geração ³±±
±±³            ³        ³        ³Tit. Pensão Alimentícia.                ³±±
±±³Cecilia Carv³02/06/17³DRHPAG³Ajuste para nao ocorre error.log para ou- ³±±
±±³            ³        ³-2426 ³tras localizações.                        ³±±
±±³Gabriel A.  ³14/08/17³DRHPAG³Tratamento para gravação de valor do      ³±±
±±³            ³        ³-4948 ³título rateado por Item Contábil.         ³±±
±±³João Balbino³07/12/17³      ³MPRIMESP-12652 -Definição da variavel     ³±±
±±³            ³        ³      ³cAcessaSRD para não gerar error log       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GPEM650()
Local nOpca 	   := 0
Local aSays 	   :={ }
Local aButtons	:= { } // arrays locais de preferencia
Local aRegs		:= {}
Local aFilterExp :=  {} //Expressao de filtro
Local nI := 0

Private aRetFiltro
Private cRC0Filter

Private cCadastro := OemToAnsi(STR0001) //"Geracao de Titulos"
Private cTitulo   := OemToAnsi(STR0001) //"Geracao de Titulos"
Private cTipoCont := 3                  // Tipo de Contabilizacao: 1-Folha Pagamento;2-Provisao;3-Ambas
Private lDrop	 := .F.
Private cAnoMes	 := ""

Private nTpImpre := 2

Private aLogFile	:= {}
Private aLogTitle	:= {}

Private cGeraBen	:= ""

Private cChvsRJ1	:= ""
Private lCpoInteg	:= ChkFile("RJ1") .And. RJ1->(ColumnPos( "RJ1_ROTEIR")) > 0 .And. RJ1->(ColumnPos( "RJ1_PROCES")) > 0 .And. RJ1->(ColumnPos( "RJ1_TIPO")) > 0

Pergunte("GPM650",.F.)

lTitLog1 := .F.
lTitLog2 := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Funcao verifica se existe alguma restrição de acesso para o³
//³usuário que impeça a execução da rotina.                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !(fValidFun({"RC1","RC0","CTT","SRZ","SRT","SRG","SRH"}))
	Return( nil )
Endif

// Verifica se registros RJ1 estão com dados atualizados
If lCtrlTit
	If !fVldRJ1()
		If !fAlertRJ1()
        	Return()
		EndIf
	EndIf
EndIf

/* Retorne os Filtros que contenham os Alias Abaixo */
aAdd( aFilterExp , { "FILTRO_ALS" , "RC0"     	, NIL , NIL } )
/* Que Estejam Definidos para a Função */
aAdd( aFilterExp , { "FILTRO_PRG" , FunName() 	, NIL , NIL    } )

AADD(aSays,OemToAnsi( STR0002 )) //"Este programa gera titulos no  arquivo  de  movimentos (RC1) a partir do cadastro de"
AADD(aSays,OemToAnsi( STR0003))  //"definicoes (RC0). Apos gerados, estarao disponiveis para consultas e integracao com "
AADD(aSays,OemToAnsi( STR0004))  //"o financeiro.                           											 "

AADD(aButtons, { 17,.T.,{|| aRetFiltro := FilterBuildExpr( aFilterExp ) } } )
AADD(aButtons, { 5,.T.,{|o| Pergunte("GPM650",.T. ) } } )
AADD(aButtons, { 1,.T.,{|o| nOpca := 1, If(GPM650OK(),FechaBatch(), nOpca:=0 ) }} )
AADD(aButtons, { 2,.T.,{|o| FechaBatch() }} )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa a gravacao dos lancamentos do SIGAPCO        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PcoIniLan("000092")

If !(IsBlind())
	FormBatch( cCadastro, aSays, aButtons )
Else
	nOpca	:= 1
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis utilizadas para parametros                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nOpca == 1
	ProcGpe({|lEnd| GPM650Proc()})  // Chamada do Processamento
Endif

If !Empty(aLogFile)
	AAdd(aLogTitle ,{OemToAnsi(STR0022)})
	ASort(aLogFile,,,{|x,y| x[1] < y[1]}) // Ordena o Log de duplicidade de títulos e do cadastro de fornecedores

	For nI := 1 To Len(aLogFile)
		ADel(aLogFile[nI],1)
	Next nI

	fMakeLog( aLogFile, aLogTitle, "GPEM650", NIL, FunName())
	aLogFile := {}
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Finaliza a gravacao dos lancamentos do SIGAPCO          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PcoFinLan("000092")

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GPM650Proc³ Autor ³ Emerson Rosa de Souza ³ Data ³ 04.08.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de geracao de Titulos				                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GPM650Proc()  			                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 							                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function GPM650Proc()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Define Variaveis LOCAIS DO PROGRAMA                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Local cAlias    := ALIAS()
	Local cTitProc  := ""
	Local nCnt      := 0
	Local nCnt1     := 0
	Local nFol13Sal := 0
	Local nNroSem   := 0
	Local lCabec    := .F.
	Local lVenc    := .F.
	Local cCpoPadRC1 := ""
	Local cCposRC0  := ""
	Local cRC1Cpo   := ""
	Local cRC1Conf  := ""
	Local nRecnoRC1 := 0

	Local aArea			:= GetArea()
	Local aAreaSM0		:= SM0->( GetArea() )
	Local cCodEmp		:= SM0->M0_CODIGO
	Local cModoRC0		:= ""
	Local aFilProc		:= {}
	Local nCont			:= 0
	Local nFatDes 		:= 0
	Local nFatFol 		:= 0
	Local nFatTot 		:= 0
	Local nFilial		:= 0
	Local nProp			:= 0
	Local cRecFatEmp	:= ""
	Local aTabS033		:= {}
	Local lRecDesTot	:= .F.
	Local lRec2DesTot	:= .F.
	Local lChkRHH 		:= Sx2ChkTable( "RHH" )
	Local cWhereRC0 	:= ""
	Local cCamposRC0 	:= ""
	Local cChave		:= ""
	Local cChaveAnt     := ""
	Local nTamFilRC0	:= 0
	Local nTamFilDe		:= 0
	Local nTamFilATe	:= 0

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Define Variaveis PRIVATE DO PROGRAMA                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Private aCposUsu    := {}
	Private dDataVenc   := CTOD("")
	Private cAliasCC    := "CTT"
	Private lSrz		   :=	.F.
	Private aPerAberto  := {}
	Private aPerFechado := {}
	Private cProcesso   := ""
	Private cRoteiro    := ""
	Private lConsiste   := SuperGetMv("MV_CONDUPL",,.F.) //.T. - Consiste / .F. - Não consiste
	Private cChaveDup   := SuperGetMv("MV_CHAVDUP",,"1") //"1" - Chave sem data de vencimento / "2" - Chave com data de vencimento
	Private aRatTit     := {}
	Private cAliasRC0 	:= ""
	Private aTipContra	:= {1, 2, 3}

	_SetOwnerPrvt(	"aAliasFields"	, {} )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Variaveis utilizadas para parametros                          ³
	//³ mv_par01        //  Filial De                                 ³
	//³ mv_par02        //  Filial Ate                                ³
	//³ mv_par03        //  Centro de Custo De                        ³
	//³ mv_par04        //  Centro de Custo Ate                       ³
	//³ mv_par05        //  Matricula De                              ³
	//³ mv_par06        //  Matricula Ate                             ³
	//³ mv_par07        //  Dt. Busca Pagto De                        ³
	//³ mv_par08        //  Dt. Busca Pagto Ate                       ³
	//³ mv_par09        //  Codigo Titulo De                          ³
	//³ mv_par10        //  Codigo Titulo Ate                         ³
	//³ mv_par11        //  Data de Emissao                           ³
	//³ mv_par12        //  Competencia                               ³
	//³ mv_par13        //  Data de vencimento                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFilDeT     := mv_par01
	cFilAteT    := mv_par02
	cCCDeT      := mv_par03
	cCCAteT     := mv_par04
	cMatDeT     := mv_par05
	cMatAteT    := mv_par06
	dDataDeT    := mv_par07
	dDataAteT   := mv_par08
	cCodTitDe   := mv_par09
	cCodTitAte  := mv_par10
	dDtEmisTit  := mv_par11
	cCompetTit  := mv_par12
	dVctoInf	 := mv_par13
	cAnoMes    :=substr(cCompetTit,3,4)+substr(cCompetTit,1,2)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Campos do RC1 (padrao do sistema)				                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cpaisloc == "BRA"

		cCpoPadRC1 := "RC1_FILIAL/RC1_INTEGR/RC1_FILTIT/RC1_CODTIT/RC1_DESCRI/RC1_PREFIX/"+;
					"RC1_NUMTIT/RC1_TIPO/RC1_NATURE/RC1_FORNEC/RC1_EMISSA/RC1_VENCTO/"  +;
					"RC1_VENREA/RC1_VALOR/RC1_DTBUSI/RC1_DTBUSF/RC1_CODRET/RC1_LOJA"
	Else

		cCpoPadRC1 := "RC1_FILIAL/RC1_INTEGR/RC1_FILTIT/RC1_CODTIT/RC1_DESCRI/RC1_PREFIX/"+;
					"RC1_NUMTIT/RC1_TIPO/RC1_NATURE/RC1_FORNEC/RC1_EMISSA/RC1_VENCTO/"  +;
					"RC1_VENREA/RC1_VALOR/RC1_DTBUSI/RC1_DTBUSF"
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega os Filtros                                 	 	      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cRC0Filter	:= GpFltAlsGet( aRetFiltro , "RC0" )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Variaveis utilizadas para geracao do SRZ via procedure     	³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lFolPgto    := .F.
	lFol13Sl    := .F.

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava no array os campos do usuario criados no arquivo RC0 e ³
	//³ RC1, assegurando que os dois tem o mesmo tipo e tamanho.     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SX3")
	dbSetOrder(1)
	dbSeek("RC1")
	While !Eof() .And. X3_ARQUIVO == "RC1"
		If !(AllTrim(X3_CAMPO) $ cCpoPadRC1)
			cRC1Cpo   := X3_CAMPO
			cRC1Conf  := X3_TIPO+StrZero(X3_TAMANHO, 3)+StrZero(X3_DECIMAL, 1)
			nRecnoRC1 := RECNO()
			dbSetOrder(2)
			If dbSeek("RC0" + Right(cRC1Cpo, 7))
				If X3_TIPO+StrZero(X3_TAMANHO, 3)+StrZero(X3_DECIMAL, 1) == cRC1Conf
					Aadd(aCposUsu, { "(cAliasRC0)->"+X3_CAMPO, "RC1->" + cRC1Cpo, Nil })
				EndIf
			EndIf
			dbSetOrder(1)
			dbGoTo(nRecnoRC1)
		EndIf
		dbSkip()
	EndDo

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se existem os campos RC1_CC e RC1_MAT		         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea( "RC1" )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica existencia dos cpos RC0_ALIADV/RC0_CPOBDV/RC0_FILTDV³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFilAte := xFilial( "RC0", cFilAteT )

	xRetModo( "RC0" , NIL , .F. , @cModoRC0 , NIL )

		cAliasRC0	:= GetNextAlias()
		cCamposRC0	:= "%RC0_FILIAL, RC0_CODTIT, RC0_TIPTIT, RC0_VERBAS, RC0_DESCRI, RC0_AGRUPA,  "
		cCamposRC0	+= "RC0_DMVENC, RC0_MESPGT, RC0_DSVENC, RC0_FORNEC, RC0_LOJA, RC0_NATURE, RC0_ANTPGT, "
		cCamposRC0	+= "RC0_PREFIX, RC0_TIPO, RC0_FILTRV, RC0_FILTRF, RC0_FILTRD, RC0_ALIAS, RC0_SEQUEN,  "

		If cpaisloc == "BRA"
			cCamposRC0 += "RC0_CODRET, RC0_TPRET, "
			If RC0->(ColumnPos( "RC0_GERBEN")) > 0
				cCamposRC0 += " RC0_GERBEN,"
			EndIf
			cCamposRC0 += " RC0_DIAUTI, RC0_ALIADV, RC0_CPODTV, RC0_FILTDV, RC0_CPODTR"
		Else
			cCamposRC0 += " RC0_DIAUTI, RC0_ALIADV, RC0_CPODTV, RC0_FILTDV, RC0_CPODTR"
		EndIf

		For nCnt1 := 1 To Len(aCposUsu)
			cCamposRC0 += ", " + SubStr(aCposUsu[nCnt1,1], 14)
		Next nCnt1

		cCamposRC0 += "%"

		cWhereRC0 := "%RC0.RC0_FILIAL >= " + "'" + xFilial("RC0",cFilDeT)  + "'" + " AND "
		cWhereRC0 += "RC0.RC0_FILIAL <= " + "'" + xFilial("RC0",cFilATet) + "'" + " AND "
		cWhereRC0 += "RC0.RC0_CODTIT >= " + "'" + cCodTitDe  + "'" + " AND "
		cWhereRC0 += "RC0.RC0_CODTIT <= " + "'" + cCodTitAte + "'" + "%"

		BeginSql alias cAliasRC0
			SELECT %exp:cCamposRC0%
			FROM  %table:RC0% RC0
			WHERE %exp:cWhereRC0% AND RC0.%notDel%
		EndSql

		nTamFilRC0	:= Len(RTrim((cAliasRC0)->RC0_FILIAL))
		nTamFilDe	:= Len(RTrim(cFilDeT))
		nTamFilATe	:= Len(RTrim(cFilAteT))

	GPProcRegua((cAliasRC0)->(RecCount()))

	While (cAliasRC0)->(!EoF())
		cNovoTit 	:= ""

		GPIncProc(STR0010) // "Processando..."

		If (cAliasRC0)->RC0_CODTIT < cCodTitDe .Or. (cAliasRC0)->RC0_CODTIT > cCodTitAte
			dbSelectArea((cAliasRC0))
			(cAliasRC0)->(dbSkip())
			Loop
		EndIf

		If !Empty( cRC0Filter )
			If !( &( cRC0Filter ) )
				(cAliasRC0)->( dbSkip())
				Loop
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica existencia da nova tabela de Dissidio Acumulado (RHH) SE a		 ³
		//³ geracao de Titulo for de Dissidio. Se NAO existir a tabela sera			 ³
		//³ apresentada a mensagem informando a necessidade da execucao do update 	 ³
		//³ 150 para a criacao e impede a execucao da geracao somente para o tipo de³
		//³ titulo 006 - INSS - DISSIDIO ate que o update seja executado.		   	    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (cAliasRC0)->RC0_TIPTIT == '1' .and. '006' $ AllTrim( (cAliasRC0)->RC0_VERBAS ) .and. !lChkRHH

			Aviso( STR0008, STR0015 + CRLF + STR0016, { STR0017 } )	//"Atencao" ## "Execute a opção do compatibilizador referente à criação da nova tabela de Dissídio Acumulado. Para maiores informações verifique respectivo Boletim Técnico."
																			//"Somente os títulos de tipo 006 - INSS - Dissidio NÃO serão gerados até que o compatibilizador seja executado." ## "OK"

			(cAliasRC0)->( dbSkip())
			Loop
		EndIf

		cFilAtu		:= (cAliasRC0)->RC0_FILIAL
		cCodTit		:= (cAliasRC0)->RC0_CODTIT
		cDescri		:= (cAliasRC0)->RC0_DESCRI
		cAgrupa		:= (cAliasRC0)->RC0_AGRUPA
		cDmVenc		:= (cAliasRC0)->RC0_DMVENC
		cMesPgt		:= (cAliasRC0)->RC0_MESPGT
		cDsVenc		:= (cAliasRC0)->RC0_DSVENC
		cFornec		:= (cAliasRC0)->RC0_FORNEC
		cLoja		:= (cAliasRC0)->RC0_LOJA
		cNature		:= (cAliasRC0)->RC0_NATURE
		cPrefix		:= (cAliasRC0)->RC0_PREFIX
		cTipTit		:= (cAliasRC0)->RC0_TIPTIT
		cIdentTit	:= AllTrim((cAliasRC0)->RC0_TIPO)
		cFiltrLan	:= AllTrim((cAliasRC0)->RC0_FILTRV)
		cFiltrSRA	:= (cAliasRC0)->RC0_FILTRF
		cCpoDtLan	:= Alltrim((cAliasRC0)->RC0_FILTRD)
		cAliasLan	:= If (!Empty( (cAliasRC0)->RC0_ALIAS ),(cAliasRC0)->RC0_ALIAS, "RC0")

		If cpaisloc == "BRA"
			cCodRetTit := (cAliasRC0)->RC0_CODRET
			cTipoRet  := (cAliasRC0)->RC0_TPRET
			If RC0->(ColumnPos( "RC0_GERBEN")) > 0
				cGeraBen  := (cAliasRC0)->RC0_GERBEN
			EndIf
		Else
			cCodRetTit := ""
			cTipoRet  := ""
			cGeraBen  := ""
		EndIf

		cSRACodRet := ""

		lSrz	   := If( cAliasLan == "SRZ" , .T. , .F. )
		cDiaUtil  := (cAliasRC0)->RC0_DIAUTI
		cVerbas   := ""
		lCabec    := .F.
		lVenc    := .F.

		cAliasCab := (cAliasRC0)->RC0_ALIADV
		cCpoDtCab := AllTrim((cAliasRC0)->RC0_CPODTV)
		cFiltrCab := (cAliasRC0)->RC0_FILTDV
		cCpoDtRel := (cAliasRC0)->RC0_CPODTR
		lCabec    := (!Empty((cAliasRC0)->RC0_ALIADV) .And. !Empty((cAliasRC0)->RC0_CPODTV)) .And. ((cAliasRC0)->RC0_ALIAS <> (cAliasRC0)->RC0_ALIADV) .And. Empty(dVctoInf)
		lVenc     := !lCabec .And. (!Empty((cAliasRC0)->RC0_ALIADV) .And. !Empty((cAliasRC0)->RC0_CPODTV) .And. (cAliasRC0)->RC0_ALIAS == (cAliasRC0)->RC0_ALIADV )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava o conteudo dos campos de usuario do RC0 em aCposUsu	   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nCnt1 := 1 To Len(aCposUsu)
			cCposRC0          := aCposUsu[nCnt1,1]
			aCposUsu[nCnt1,3] := &cCposRC0
		Next nCnt1

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calcula data de vencimento do titulo			                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dDataVenc := CTOD("")
		If !Empty(cDmVenc) .And. !Empty(cMesPgt)  // Dia do mes para o vencimento
			If cMesPgt == "3" // Mes Seguinte ao Pagamento
				cNovMes :=  Strzero(Month(dDataDeT),2)
				cNovAno := Str(Year(dDataDeT),4)
				//-- Calcula o mes seguinte a data de apuracao.
				cNovMes := If(cNovMes == "12", "01", StrZero(Val(cNovMes)+1,2))
				cNovAno := If(cNovMes == "01", StrZero(Val(cNovAno)+1,4), cNovAno)
			Else
				cNovMes :=  Left(cCompetTit,2)
				cNovAno := Right(cCompetTit,4)
				If cMesPgt == "2" // Mes Seguinte
					cNovMes := If(cNovMes == "12", "01", StrZero(Val(cNovMes)+1,2))
					cNovAno := If(cNovMes == "01", StrZero(Val(cNovAno)+1,4), cNovAno)
				EndIf
			EndIf

			dDataVenc := CTOD(cDmVenc + "/" + cNovMes + "/" + cNovAno)
			//-- Se gerou um data invalida pois o dia nao existe para o mes gerado
			IF Empty(dDataVenc)
				//-- Assume o maior dia do mes gerado
				dDataVenc:= CTOD(Strzero(F_ULTDIA(Ctod("01/"+cNovMes+"/"+cNovAno)),2) + "/" + cNovMes + "/" + cNovAno)
			Endif

		ElseIf !Empty(cDsVenc)   // Dia da Semana para o vencimento
			nNroSem := If(DOW(dDataAteT) > Len(cDsVenc), 7, 0)
			dDataVenc := (dDataAteT - DOW(dDataAteT) + Val(cDsVenc) + nNroSem)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se existem outros registro e os carregas em cVerbas ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cChave	:= (cAliasRC0)->(RC0_FILIAL+RC0_CODTIT+RC0_SEQUEN)
		If RC0->(dbSeek(cChave))
			While RC0->(!Eof()) .And. RC0->(RC0_FILIAL+RC0_CODTIT+RC0_SEQUEN) == cChave
				cVerbas += AllTrim(RC0->RC0_VERBAS)
				RC0->( dbSkip())
			EndDo
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Geracao dos titulos padroes do sistema                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cTipTit == "1"

			cTitProc := Left(cVerbas,3)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Chamada para o programa de geracao do INSS - FOLHA/13o	      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cTitProc $ "001*002"
				If cAgrupa = "4"
					Aviso(STR0008, STR0018 + STR0019, {"OK"})
					//"Atencao!"###"Para titulos de INSS nao e permitido o agrupamento por funcionario". Acerte o agrupamento e processe a geracao novamente."
					Return
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se deve gerar o arquivo SRZ com os valores de INSS	³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nFol13Sal := If(cTitProc == "001", 1, 2)   // 1-Folha, 2-13o Salario

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Variaveis utilizadas para geracao do SRZ via procedure       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				lFolPgto    := ( nFol13Sal == 1 ) // Geracao dos registros 'FL' no SRZ
				lFol13Sl    := ( nFol13Sal == 2 ) // Geracao dos registros '13' no SRZ
				Rst040Imp() // Reinicializa static para execucao da procedure

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Carregar os periodos abertos (aPerAberto) e/ou os periodos   ³
				//³ fechados (aPerFechado), de acordo com uma determinada compe- ³
				//³ tencia.                 				                         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

				fRetPerComp(substr(cCompetTit,1,2),substr(cCompetTit,3,4), Nil, Nil, Nil, @aPerAberto, @aPerFechado)
				cAnoMes:=substr(cCompetTit,3,4)+substr(cCompetTit,1,2)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Tipo de Geracao na GPS:     1 - CC, 2 - Nivel CC, 3 - Filial ³
				//³ Tipo de Geracao no Titulo:  2 - CC, 3 - Nivel CC, 1 - Filial ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nPorCc        := If(cAgrupa == "2", 1, If(cAgrupa == "3", 2, 3))
				cNivCCusto    := If( nPorCc == 2, "1", "")
				cTipo         := nFol13Sal

				If !fGeraFolSRZ(nFol13Sal, aTipContra, cCompetTit, aPerAberto, aPerFechado) // 1-Indeterminado, 2-Determinado, 3-Intermitente
					Loop
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Carregando variaveis mv_par?? para Variaveis do Sistema      ³
				//³ Estas variaveis serao utilizadas em GPM240Proc()		         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nValAutonomo  := 0.00
				nValProLabore := 0.00
				nValReceita   := 0.00
				nValDedSer    := 0.00
				nValJuros     := 0.00
				cCentra       := Space(FwGetTamFilial)
				cCompetencia  := cCompetTit

				// Processa os contratos.
				// 1-Contrato Indeterminado
				// 2-Determinado
				// 3-Intermitente
				For nCnt := 1 To Len(aTipContra)
					cTpc    := Str(nCnt, 1) //Define o tipo de contrato

					If cModoRC0 == "E"
						cFilIni := cFilAtu
						cFilFim := cFilAtu
					Else
						cFilIni := cFilDeT
						cFilFim := cFilAteT
					EndIf

					aRatTit := {}

					Processa({|lEnd|GPM240Proc(3,@lEnd,,,cFilIni,cFilFim,cCCDeT,cCCAteT,cTpc),STR0009})  //"Gerando arquivo aguarde..."
				Next nCnt

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Chamada para o programa de geracao dos valores de I.R.	      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ElseIf cTitProc == "003"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Carregando variaveis mv_par?? para Variaveis do Sistema      ³
				//³ Estas variaveis serao utilizadas em GR050Imp()		         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Empty(xFilial("RC0"))
					cFilDe  := cFilDeT
					cFilAte := cFilAteT
				Else
					If nTamFilRC0 >= nTamFilDe
						cFilDe  := cFilAtu
					else
						cFilDe  := If( RTrim(cFilAtu) == Left(cFilDeT,nTamFilRC0), cFilDeT, cFilAtu)
					EndIf

					If nTamFilRC0 >= nTamFilAte
						cFilAte := cFilAtu
					else
						cFilAte := If( RTrim(cFilAtu) == Left(cFilAteT,nTamFilRC0), cFilAteT, cFilAtu )
					EndIf
				Endif
				cFilAte := PadR(RTrim(cFilAte), FWGETTAMFILIAL, "Z")

				cCCDe 	  := cCCDeT
				cCCAte 	  := cCCAteT
				cMatDe    := cMatDeT
				cMatAte   := cMatAteT
				dDataDe   := dDataDeT
				dDataAte  := dDataAteT
				cNomDe    := Space(30)
				cNomAte   := Replicate("z", 30)
				cSinAna   := "A" // Analitica
				lSalta    := .F.
				nTipImp   := If( cTipoRet == "2", 3, 1) // Tipo Relatorio no programa GPER050
				dVencto   := CTOD("")
				cNumRef   := ""
				cCentra   := ""

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Ordem na Impressao do I.R.: 1 - Mat, 2 - CC,    3 - Nome	   ³
				//³ Ordem na Geracao de titulo: 2 - CC,  3 - Nivel, 1 - Filial   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nOrdem	:= If(cAgrupa $ "2*3", 2, 1)
				aRatTit := {}
				GR050Imp(2, .F.,,, cAgrupa,, "GPEM650",, cTipoRet)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Chamada para o programa de geracao dos valores de PENSAO     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ElseIf cTitProc == "004"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se existem outros registro com mesmo cod/seq em outras filiais ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If (FwModeAccess('RC0',3) == 'E' .and. FwModeAccess('RC1',3) == 'E') .and. !Empty(cChaveAnt)
					If cChaveAnt == (cAliasRC0)->(RC0_CODTIT+RC0_TIPTIT+RC0_AGRUPA+RC0_SEQUEN)
						(cAliasRC0)->( dbSkip())
						Loop
					EndIf
				EndIf
				cChaveAnt := (cAliasRC0)->(RC0_CODTIT+RC0_TIPTIT+RC0_AGRUPA+RC0_SEQUEN)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica var referente ao RC0_ALIAS e seta tabela RC0 se vazio.	³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Empty(cAliasLan)
					cAliasLan := "RC0"
				EndIf

				aRatTit := {}
				Processa({|lEnd| fGerPens(@lEnd),STR0009})  //"Gerando arquivo aguarde..."

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Chamada para o programa de geracao dos valores de DISSIDIO   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ElseIf cTitProc $ "006"

				Rst040Imp() // Reinicializa static para execucao da procedure
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Carregando variaveis mv_par?? para Variaveis do Sistema      ³
				//³ Estas variaveis serao utilizadas em GPM240PrcD()			      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nValAutonomo  := 0.00
				nValProLabore := 0.00
				nValReceita   := 0.00
				nValDedSer    := 0.00
				nValJuros     := 0.00
				cCentra       := ""
				cCompetencia  := cCompetTit
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Tipo de Geracao na GPS:     1 - CC, 2 - Nivel CC, 3 - Filial ³
				//³ Tipo de Geracao no Titulo:  2 - CC, 3 - Nivel CC, 1 - Filial ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nPorCc        := If( cAgrupa == "2", 1, If(cAgrupa == "3", 2, 3))
				cNivCCusto    := If( nPorCc == 2, "1", "")
				cTipo         := nFol13Sal
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Processa duas vezes. 1-Contrato Indeterminado, 2-Determinado ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				For nCnt := 1 To 2
					cTpc := Str(nCnt,1) //Define o tipo de contrato
					If cModoRC0 == "E"
						cFilIni := cFilAtu
						cFilFim := cFilAtu
					Else
						cFilIni := cFilDeT
						cFilFim := cFilAteT
					EndIf
					aRatTit := {}
					Processa( { |lEnd| GPM240PrcD(3,@lEnd,,,cFilIni,cFilFim,cCCDeT,cCCAteT,cTpc,cAnoMes),STR0009})  //"Gerando arquivo aguarde..."
				//               Gpm240PrcD( nTipGer, lEnd, WnRel, cFilArq, cFilIni, cFilFim, cCcIni, cCcFim, cTipCont, cAnoMes )
				Next nCnt
			//INSS RRA
			ElseIf cTitProc $ "007"

				Rst040Imp() // Reinicializa static para execucao da procedure
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Carregando variaveis mv_par?? para Variaveis do Sistema      ³
				//³ Estas variaveis serao utilizadas em GPM240PrcD()			      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nValAutonomo  := 0.00
				nValProLabore := 0.00
				nValReceita   := 0.00
				nValDedSer    := 0.00
				nValJuros     := 0.00
				cCentra       := ""
				cCompetencia  := cCompetTit
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Tipo de Geracao na GPS:     1 - CC, 2 - Nivel CC, 3 - Filial ³
				//³ Tipo de Geracao no Titulo:  2 - CC, 3 - Nivel CC, 1 - Filial ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nPorCc        := If( cAgrupa == "2", 1, If(cAgrupa == "3", 2, 3))
				cNivCCusto    := If( nPorCc == 2, "1", "")
				cTipo         := nFol13Sal := 1

				// Processa os contratos.
				// 1-Contrato Indeterminado
				// 2-Determinado
				// 3-Intermitente
				lFolPgto    := .T. // Geracao dos registros 'FL' no SRZ
				lFol13Sl    := .T. // Geracao dos registros '13' no SRZ
				Rst040Imp() // Reinicializa static para execucao da procedure

				If !fGeraFolSRZ(nFol13Sal, aTipContra, cCompetTit)// 1-Indeterminado, 2-Determinado, 3-Intermitente
					Loop
				EndIf

				For nCnt := 1 To Len(aTipContra)
					cTpc := Str(nCnt,1) //Define o tipo de contrato

					If Empty( xFilial( "RC0" ) )
						cFilIni := cFilDeT
						cFilFim := cFilAteT
					Else
						cFilIni := cFilAtu
						cFilFim := cFilAtu
					EndIf

					aRatTit := {}

					Processa({|lEnd|GPM240PrcR(@lEnd,    ,,cFilIni,cFilFim,cCCDeT,cCCAteT,cTpc),STR0009})  //"Gerando arquivo aguarde..."
				//            Gpm240PrcR(lEnd,WnRel,cFilSRZ,cFilIni,cFilFim,cCcIni,cCcFim,cTipCont)
				Next nCnt
			//IMPOSTO DE RENDA - RRA
			ElseIf cTitProc == "008"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Carregando variaveis mv_par?? para Variaveis do Sistema      ³
				//³ Estas variaveis serao utilizadas em GR050Imp()				   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Empty( xFilial( "RC0" ) )
					cFilDe	:= cFilDeT
					cFilAte	:= cFilAteT
				Else
					cFilDe	:= cFilAtu
					cFilAte := cFilAtu
				EndIf

				cCCDe 	  := cCCDeT
				cCCAte 	  := cCCAteT
				cMatDe    := cMatDeT
				cMatAte   := cMatAteT
				dDataDe   := dDataDeT
				dDataAte  := dDataAteT
				cNomDe    := Space(30)
				cNomAte   := Replicate("z", 30)
				cSinAna   := "A" // Analitica
				lSalta    := .F.
				nTipImp   :=  If( cTipoRet == "2", 3, 1) // Tipo Relatorio no programa GPER050
				dVencto   := CTOD("")
				cNumRef   := ""
				cCentra   := ""
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Ordem na Impressao do I.R.: 1 - Mat, 2 - CC,    3 - Nome	   ³
				//³ Ordem na Geracao de titulo: 2 - CC,  3 - Nivel, 1 - Filial   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nOrdem	:= If(cAgrupa $ "2*3", 2, 1)
				aRatTit	:= {}
				Processa({|lEnd| GR050Imp(2,@lEnd,,,cAgrupa,,"GPEM650",.T., cTipoRet),STR0009})  //"Gerando arquivo aguarde..."
			//             GR050Imp(nTipGer,lEnd,WnRel,cString,cAgrupa,oReport,cFonte)
			ElseIf cTitProc == "009"	// DARF - DESONERACAO
				aRatTit := {}
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Carregando variaveis mv_par?? para Variaveis do Sistema      ³
				//³ Estas variaveis serao utilizadas em GR050Imp()				   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Empty(FWFilial("RC0"))
						cFilDe	:= cFilDeT
						cFilAte	:= cFilAteT
					Else
						cFilDe	:= cFilAtu
						cFilAte	:= cFilAtu
				EndIf

				// Monta o array das filiais a processar
				dbSelectArea( "SM0" )
				dbSeek( cCodEmp, .T. )
				While SM0->( ! EoF() ) .And. cCodEmp == SM0->M0_CODIGO
					If FWGETCODFILIAL >= cFilDe .And. FWGETCODFILIAL <= cFilAte
						aAdd( aFilProc, {FWGETCODFILIAL, " ", 0.00, " ", 0.00} )
					Endif
					SM0->( DbSkip() )
				EndDo

				//Retorna a area do arquivo de empresas. SIGAMAT.EMP
				RestArea( aAreaSM0 )

				//Chama fCarrTab para carregar tabela auxiliar S033
				fCarrTab( @aTabS033, "S033", CtoD( "01/" + SubStr( cAnoMes, 5, 2 ) + "/" + SubStr( cAnoMes, 1, 4 ) ), .T. )

				//Apura a receita bruta total da empresa
				aEval(aTabS033, {|aTabS033| nFatTot += aTabS033[7] } )
				//Apura a receita bruta que nao e' sobre as atividades desoneradas
				aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "2", nFatFol += aTabS033[7], ) } )
				//Apura a receita bruta que e' sobre as atividades desoneradas
				aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "1", nFatDes += aTabS033[7], ) } )
				//Verifica se a receita desonerada da empresa e' superior a 95% do total
				lRecDesTot := ( nFatDes / nFatTot >= 0.95 )

				lRec2DesTot := ( nFatFol / nFatTot >= 0.95 )

				For nFilial := 1 to Len( aFilProc )
					aArea	:= GetArea()
					nFatFol := 0
					fInssEmp( aFilProc[nFilial,1], @aInssEmp, Nil, cAnoMes )

					For nCnt := 1 To Len( aInssEmp[27] )
						cRecFatEmp	:= aInssEmp[ 27, nCnt ]	// X14_RECFAT
						If cRecFatEmp $ "S*M*C"
							Exit
						EndIf
					Next

					//Se a empresa recolhe contribuicao previdenciaria sobre a receita bruta
					If cRecFatEmp $ "S*M*C"
						//Caso seja S, ou M/C sem a atividade desonerada ou não desonerada representar 95% do faturamento.
						If cRecFatEmp == "S" .Or. ((cRecFatEmp =="M" .Or. cRecFatEmp =="C") .And. !lRecDesTot .And. !lRec2DesTot)
							//Verifica os registros da filial em processamento e guarda o valor da contribuicao calculada
							aEval(aTabS033, {|aTabS033| If( aTabS033[2]  ==  aFilProc[nFilial, 1] .And.  aTabS033[6] == "1", aFilProc[nFilial, 5] += aTabS033[9], ) } )
						Else
							If (cRecFatEmp == "C" .And. lRec2DesTot) .Or. (lRecDesTot) .Or. (!lRecDesTot .And. !lRec2DesTot)
								//Apura a receita bruta que nao e' sobre as atividades beneficiadas da Lei no. 12.546/2011
								aEval(aTabS033, {|aTabS033| If( aTabS033[2] == aFilProc[nFilial, 1] .And. aTabS033[6] == "2", nFatFol += aTabS033[7], ) } )
								//Se a receita bruta da atividade desonerada for maior do que 95% do total devera ser
								//considerado a receita bruta da atividade nao desonerada.Sera aplicado a proporcionalidade
								//das aliquotas das atividades desoneradas conforme correspondencia do percentual da receita
								//desonerada em relacao ao total desonerado
								//Ex: Cod de atividade X possui receita bruta de 45.000 com aliquota de 1%. A receita bruta
								//    total de atividade desonerada e' igual a 98.000 e ha 2.000 de atividade nao desonerada.
								//	  Sera feito a regra de 3 para saber quanto da receita bruta da atividade corresponde
								//    ao total desonerado. Percentual = 45.000 * 100 / 98.000 = 45,91%. O percentual sera
								//    aplicado sobre os 2.000 da receita nao desonerada. Sobre o valorencontrado sera
								//	  aplicado a aliquota correspondente ao codigo da atividade. Esse valor sera somado ao
								//    que a empresa ja recolhe de contribuicao sobre a atividade desonerada.
								For nCont := 1 To Len(aTabS033)
									If aTabS033[nCont, 6] == "1"
										nProp := ( aTabS033[nCont, 7] * 100 / nFatDes ) / 100
										aFilProc[nFilial, 5] += ( nProp * nFatFol ) * ( aTabS033[nCont, 8] / 100 )
									EndIf
								Next nCont
							EndIf
						EndIf

					EndIf

					fGravTit( aFilProc[nFilial,1], cAgrupa, , aFilProc[nFilial, 5] )

					RestArea( aArea )
				Next nFilial
			EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Geracao dos titulos definidos pelo usuario			            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ElseIf cTipTit == "2"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica Alias e Campo para filtrar o periodo   		         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Empty(cAliasLan)
				dbSelectArea( (cAliasRC0) )
				Loop
			EndIf
			aRatTit := {}
			Processa({|lEnd| fTitUsu(@lEnd,lCabec,lVenc),STR0009})  //"Gerando arquivo aguarde..."
		EndIf
		(cAliasRC0)->( dbSkip())
		cFilAte := xFilial( "RC0", cFilAteT )
		dbSelectArea( (cAliasRC0) )
	EndDo

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GPM650OOk ³ Autor ³ Emerson Rosa de Souza ³ Data ³ 13.08.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Confirma parametros             				               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GPM650Ok()    			                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 							                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function GPM650Ok()

Return (MsgYesNo(OemToAnsi(STR0007),OemToAnsi(STR0008))) //"Confirma configura‡„o dos parƒmetros?"###"Aten‡„o"

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fGerPens ³ Autor ³ Emerson Rosa de Souza ³ Data ³ 13.08.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta valores de pensao e grava no arquivo de titulos	      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fGerPens	    			                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 							                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fGerPens(lEnd)
	Local cAlias		:= ALIAS()
	Local aArea
	Local aCodFol		:= {}
	Local aValBenef		:= {}
	Local aOrdBagRC		:= {}
	Local aRotAux		:= {}
	Local nValor		:= 0
	Local nValTotal		:= 0
	Local cAliasRC		:= ""
	Local cFilRotAux	:= "#########"
	Local cRCName
	Local cFilialAnt
	Local cCCAnt
	Local nCntB			:= 0
	Local cAgrupAnt
	Local dDataRef
	Local cQuery		:= ""
	Local cAliasSRA		:= "SRA"
	Local cAliasCount	:= ""
	Local cQry			:= ""
	Local cCount		:= ""
	Local lQuery		:= .F.
	Local cOrder
	Local cPensVer		:= ""
	Local cValidFil		:= fValidFil()
	Local nRoteir		:= 0
	Local cAliasPENS    := GetNextAlias()
	Local cOrderBy      := ""

	//-- Tratamento para competencia dos benecifiarios
	Local cMesAno		:= ''
	Local dDtIniComp	:= Ctod('')
	Local dDtFimComp	:= Ctod('')
	Local nUltDia		:= 0
	Local nX			:= 0
	Local aSRQStru
	//-- Tratamento para geração de Título de Pensão Alimentícia por Beneficiário
	Local lGeraTit		:= .T.
	Local cFornAnt		:= cFornec
	Local cLojaAnt		:= cLoja
	Local nOrdRot		:= 1

	//Variaveis Privates utilizadas em fBuscaLiq()
	Private lImprFunci  := .F. // Indica se deve buscar valores dos funcionarios
	Private lImprBenef  := .T. // Indica se deve buscar valores dos beneficiarios

	Private cArqMovRC   := ""

	Private cAcessaSRA	:= &( " { || " + ChkRH( "GPEM650" , "SRA" , "2" ) + " } " )
	Private cAcessaSRC	:= &( " { || " + ChkRH( "GPEM650" , "SRC" , "2" ) + " } " )
	Private cAcessaSRG	:= &( " { || " + ChkRH( "GPEM650" , "SRG" , "2" ) + " } " )
	Private cAcessaSRH	:= &( " { || " + ChkRH( "GPEM650" , "SRH" , "2" ) + " } " )
	Private cAcessaSRR	:= &( " { || " + ChkRH( "GPEM650" , "SRR" , "2" ) + " } " )
	Private cAcessaSRD	:= &( " { || " + ChkRH( "GPEM650" , "SRD" , "2" ) + " } " )
	Private cCpoDel		:= "D_E_L_E_T_"

	Private dDataDe     := dDataDeT
	Private dDataAte    := dDataAteT
	Private Semana      := "  "
	Private aRoteiros	:= {}

	//-- Tratamento para competencia dos beneficios
	cMesAno  := Substr(cCompetTit,1,2)+"/"+Substr(cCompetTit,3,4)

	dDtIniComp	:= CToD( "01" + "/" + cMesAno )    //Primeiro dia do Mes
	nUltDia	:= f_UltDia( dDtIniComp )      	 //Ultimo dia do Mes
	dDtFimComp	:= CToD(StrZero(nUltDia,2)+"/"+ cMesAno)

	cPensVer := "   "

	If cAgrupa $ "1*4" // Filial*Funcionario
		cOrderBy := "%1,2%"
	ElseIf cAgrupa $ "2*3" //Centro de Custo/Nivel de Centro de Custo
		cOrderBy := "%1,3%"
	EndIf

	BeginSql Alias cAliasPENS
		SELECT DISTINCT
			RA_FILIAL, RA_MAT, RA_CC
		FROM
			%Table:SRA% SRA
			JOIN %Table:SRQ% SRQ ON RQ_FILIAL = RA_FILIAL AND RQ_MAT = RA_MAT
			JOIN %Table:SRC% SRC ON RC_FILIAL = RA_FILIAL AND RC_MAT = RA_MAT
		WHERE
			SRA.%NotDel%
			AND SRQ.%NotDel%
			AND SRC.%NotDel%
			AND RC_PERIODO = %Exp:cAnoMes%
			AND RA_FILIAL >= %Exp:cFilDeT%
			AND RA_FILIAL <= %Exp:cFilAteT%
			AND RA_CC >= %Exp:cCCDeT%
			AND RA_CC <= %Exp:cCCAteT%
			AND RA_MAT >= %Exp:cMatDeT%
			AND RA_MAT <= %Exp:cMatAteT%

		UNION

		SELECT DISTINCT
			RA_FILIAL, RA_MAT, RA_CC
		FROM
			%Table:SRA% SRA
			JOIN %Table:SRQ% SRQ ON RQ_FILIAL = RA_FILIAL AND RQ_MAT = RA_MAT
			JOIN %Table:SRD% SRD ON RD_FILIAL = RA_FILIAL AND RD_MAT = RA_MAT
		WHERE
			SRA.%NotDel%
			AND SRQ.%NotDel%
			AND SRD.%NotDel%
			AND RD_PERIODO = %Exp:cAnoMes%
			AND RA_FILIAL >= %Exp:cFilDeT%
			AND RA_FILIAL <= %Exp:cFilAteT%
			AND RA_CC >= %Exp:cCCDeT%
			AND RA_CC <= %Exp:cCCAteT%
			AND RA_MAT >= %Exp:cMatDeT%
			AND RA_MAT <= %Exp:cMatAteT%

		UNION

		SELECT DISTINCT
			RA_FILIAL, RA_MAT, RA_CC
		FROM
			%Table:SRA% SRA
			JOIN %Table:SRQ% SRQ ON RQ_FILIAL = RA_FILIAL AND RQ_MAT = RA_MAT
			JOIN %Table:SRR% SRR ON RR_FILIAL = RA_FILIAL AND RR_MAT = RA_MAT
		WHERE
			SRA.%NotDel%
			AND SRQ.%NotDel%
			AND SRR.%NotDel%
			AND RR_PERIODO = %Exp:cAnoMes%
			AND RA_FILIAL >= %Exp:cFilDeT%
			AND RA_FILIAL <= %Exp:cFilAteT%
			AND RA_CC >= %Exp:cCCDeT%
			AND RA_CC <= %Exp:cCCAteT%
			AND RA_MAT >= %Exp:cMatDeT%
			AND RA_MAT <= %Exp:cMatAteT%

		ORDER BY
			%Exp:cOrderBy%
	EndSql

	DbSelectArea("SRY")
	("SRY")->( DbGoTop() )
	While !("SRY")->(Eof())
		If SRY->RY_TIPO $ "1*2*3*4*5*6*F"
			If SRY->RY_TIPO == "4"
				Aadd(aRotAux, {SRY->RY_CALCULO, SRY->RY_TIPO, cPensVer,SRY->RY_FILIAL,0 })
			Else
				Aadd(aRotAux, {SRY->RY_CALCULO, SRY->RY_TIPO, cPensVer,SRY->RY_FILIAL,nOrdRot} )
			EndIf
			nOrdRot++
		EndIf
		("SRY")->(DbSkip())
	EndDo

	aSort(aRotAux,,,{|x,y| x[5] < y[5]})
	DbSelectArea("SRA")

	ProcRegua( (cAliasPENS)->(RecCount()) )

	nValTotal  := 0
	cFilialAnt := Replicate("!",FWGETTAMFILIAL)
	cCCAnt     := Replicate("!",GetSx3Cache("RA_CC","X3_TAMANHO"))
	cCpoAgrup  := If(cAgrupa=="1","(cAliasPENS)->RA_FILIAL",If(cAgrupa$"2*3","(cAliasPENS)->RA_CC","(cAliasPENS)->RA_MAT"))

	While (cAliasPENS)->( !Eof() )
		If cAgrupa $ "1*4" // Filial*Funcionario
			SRA->( DbSetOrder(1) )
			SRA->( DbSeek( (cAliasPENS)->(RA_FILIAL+RA_MAT) ) )
		ElseIf cAgrupa $ "2*3" //Centro de Custo/Nivel de Centro de Custo
			SRA->( DbSetOrder(2) )
			SRA->( DbSeek( (cAliasPENS)->(RA_FILIAL+RA_CC+RA_MAT) ) )
		EndIf

		//Verifica quebra de filial e busca novos codigos da folha
		If SRA->RA_FILIAL # cFilialAnt
			//Consiste acesso do usuario a filiais
			If ! ( SRA->RA_FILIAL $ cValidFil )
				SRA->(dbSkip())
				Loop
			EndIf
		IF !FP_CODFOL(@aCodFol,SRA->RA_FILIAL)
			Exit
		Endif
		cFilialAnt := SRA->RA_FILIAL
		Endif

		If cFilRotAux <> xFilial("SRY",SRA->RA_FILIAL)
			cFilRotAux := xFilial("SRY",SRA->RA_FILIAL)
			aRoteiros := {}
			For nX := 1 to Len(aRotAux)
				If cFilRotAux == aRotAux[nX,4]
					Aadd(aRoteiros, {aRotAux[nX,1], aRotAux[nX,2], aRotAux[nX,3]} )
				EndIf
			Next nX
		EndIf

		//Centro de custo para gravacao quando agrupar por funcionario
		If SRA->RA_CC # cCCAnt
			cCCAnt := SRA->RA_CC
		EndIf

		cAgrupAnt := &cCpoAgrup
		While (cAliasPENS)->( !Eof() ) .And. cFilialAnt + cAgrupAnt == (cAliasPENS)->RA_FILIAL + &cCpoAgrup
			IncProc(STR0005 + cDescri) //"Gerando Titulos - "

			//Busca os valores do beneficiario
			nValor    := 0
			aValBenef 	:= {}
			dDataRef	:= CTOD("01"+"/"+Substr(cCompetTit,1,2)+"/"+Substr(cCompetTit,3,4) )

			Gp020BuscaLiq(@nValor, @aValBenef, cPensVer,, (cAliasPENS)->RA_FILIAL, (cAliasPENS)->RA_MAT)
			lGeraTit := .F.
			For nCntB := 1 To Len( aValBenef )
				If cGeraBen == "1" .And. cAgrupa == "4"
					lGeraTit := .T.

					If !Empty(aValBenef[nCntB,10]) .And. !Empty(aValBenef[nCntB,11])
						cFornec := aValBenef[nCntB,10]
						cLoja := aValBenef[nCntB,11]
					EndIf

					//Grava o titulo de acordo com seu agrupamento
					aArea :=  (cAliasSRA)->(GetArea())
					If !(fGravTit(cFilialAnt,If(cAgrupa$"2*3",cAgrupAnt,If(cAgrupa=="4",cCCAnt,Nil)),If(cAgrupa=="4",cAgrupAnt, Nil),aValBenef[nCntB,5]))
						Exit
					EndIf
					RestArea(aArea)

					cFornec := cFornAnt
					cLoja := cLojaAnt

				Else
					nValTotal += aValBenef[nCntB,5]
				EndIf
			Next nCntB

			(cAliasPENS)->( DbSkip() )
		EndDo

		//Grava o titulo de acordo com seu agrupamento
		If !lGeraTit
			//Grava o titulo de acordo com seu agrupamento
			aArea :=  (cAliasSRA)->(GetArea())
			If !(fGravTit(cFilialAnt,If(cAgrupa$"2*3",cAgrupAnt,If(cAgrupa=="4",cCCAnt,Nil)),If(cAgrupa=="4",cAgrupAnt, Nil),nValTotal))
				Exit
			EndIf
			RestArea(aArea)
		EndIf
		nValTotal := 0
	EndDo

	(cAliasPENS)->( DbCloseArea() )

	DbSelectArea( "SRA" )
	DbSetOrder(1)
	DbSelectArea( cAlias)
Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fTitUsu  ³ Autor ³ Emerson Rosa de Souza ³ Data ³ 13.08.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Busca valores no arquivo definido pelo usuario		         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fTitUsu	    			                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 							                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fTitUsu(lEnd,lCabec,lVenc)
Local cAlias		:= ALIAS()
Local cFilLimI		:= If(Len(Alltrim(cFilAtu)) < FWGETTAMFILIAL, cFilDeT, cFilAtu)
Local cFilLimF		:= If(Len(Alltrim(cFilAtu)) < FWGETTAMFILIAL, cFilAteT, cFilAtu)
Local cIniCpo
Local cPriCpo
Local cDtFiltro
Local cIndCond
Local cFor
Local cChaveCab
Local cChaveLan
Local cChaveBas
Local aChaveAgrup	:= {}
Local nRecAgrup		:= 0
Local nPosAgrup
Local cChaveAgrup
Local cModeAccess
Local cOrder		:= ""
Local cSelect		:= ""
Local cPdAux		:= ""
Local cAliasAux		:= cAliasLan
Local aAliasStru	:= {}
Local nX 			:= 0
Local cValidFil		:= fValidFil()
Local cChaveCabL    := ""
Local cCpoData		:= "" 

DEFAULT lVenc		:= .F.
Private cArqNtx
Private cCcLan
Private cMatLan
Private cFilLan
Private cPDLan
Private cValLan
Private lMatLan
Private lCcLan
Private lMatCab
Private cCcCab
Private cItem

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variavel obritatorias do arquivo LANCAMENTOS  		         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea( cAliasLan )
cPriCpo := FieldName(1) // Nome do primeiro campo do arquivo
cIniCpo := Substr(cPriCpo, 1, AT("_", cPriCpo))
cFilLan := cIniCpo + "FILIAL"
cCcLan  := cIniCpo + "CC"
cMatLan := cIniCpo + "MAT"
cValLan := cIniCpo + If(cAliasLan == "SRZ", "VAL",If (cAliasLan == "SRK","VALORTO","VALOR"))
cPDLan  := cIniCpo + If(cAliasLan == "SRT", "VERBA", "PD")
lMatLan := ( FieldPos( cMatLan ) > 0 )
lCcLan	 := ( FieldPos( cCcLan ) > 0 )
cItem   := cIniCpo + "ITEM"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Prepara filtro do cadastro de funcionarios       		      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea( "SRA" )
dbSetOrder(1)
cFiltrSRA := AllTrim(cFiltrSRA)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Chave para comparacao entre arquivo CABECALHO E LANCAMENTOS  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cChaveCab := &( "{ || .T.}" )
cChaveLan := &( "{ || .T.}" )

cModeAccess := FWModeAccess( "RC0", 1) + FWModeAccess( "RC0", 2) + FWModeAccess( "RC0", 3)
If Empty(cFilAtu) .Or. ( !Empty(cFilAtu) .and. cModeAccess <> "EEE")
	cFilLimI := cFilDeT
	cFilLimF := cFilAteT
Else
	cFilLimI := cFilAtu
	cFilLimF := cFilAtu
EndIf

If lCabec

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Variaveis obritatorias do arquivo CABECALHO    		         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea( cAliasCab )
	cPriCpo := FieldName(1) // Nome do primeiro campo do arquivo
	cIniCpo := Substr(cPriCpo, 1, AT("_", cPriCpo))
	cFilCab := cIniCpo + "FILIAL"
	cMatCab := cIniCpo + "MAT"
	lMatCab := ( FieldPos( cMatCab ) > 0 )

	// Tratamento para CC, pois na rescisao (SRG) este campo somente fara parte da tabela de itens (SRR)
	cCcCab	:= If( FieldPos( cIniCpo + "CC" ) > 0, cIniCpo + "CC", "" )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta indice condicional do arquivo CABECALHO                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cAgrupa == "2" .and. !( cAliasCab $ "SRG*SRH" )   // Centro de Custo/Nivel de Centro de Custo - Cabecalho de Rescisao nao tem CC
		cIndCond := cFilCab + "+" + cCcCab + If(lMatCab, "+" + cMatCab, "")

		cFor := '(' + cFilCab + "+" + cCcCab + If(lMatCab, "+" + cMatCab, "")+;
				' >= "' + cFilLimI+cCCDeT+ If(lMatCab, cMatDeT,'') + '")'

		cFor += ' .And. (' + cFilCab+ "+" + cCcCab + If(lMatCab, "+" + cMatCab, "")+;
				' <= "' + cFilLimF+cCCAteT + If(lMatCab, cMatAteT ,'') + '")'

	Else
		cIndCond := cFilCab + If(lMatCab, "+" + cMatCab, "")

		cFor := '(' + cFilCab + If(lMatCab, "+" + cMatCab, "")+;
				' >= "' + cFilLimI + If(lMatCab, cMatDeT,'') + '")'

		cFor += ' .And. (' + cFilCab + If(lMatCab, "+" + cMatCab, "")+;
				' <= "' + cFilLimF + If(lMatCab, cMatAteT ,'') + '")'

	EndIf

	If !Empty(cFiltrCab)
		cFor += ' .And. ' + AllTrim(cFiltrCab)
	EndIf

	If !Empty(cCpoDtCab)
		cDtFiltro := 'DTOS(' + cCpoDtCab + ')'
		cFor += ' .And. (' +cDtFiltro+' >= "'+DTOS(dDataDeT)+'")'+' .And. ('+cDtFiltro+' <= "'+DTOS(dDataAteT)+'")'
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cria indice temporario do arquivo CABECALHO			         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cArqNtx := CriaTrab(NIL,.f.)
	IndRegua(cAliasCab,cArqNtx,cIndCond,,cFor,STR0006)  //"Selecionando Registros..."
	dbGoTop()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta chave para busca das verbas no arquivo de LANCAMENTOS  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cTipoItens  := If(cAliasCab == "SRG", "R", If(cAliasCab == "SRH", "F", ""))
	cChaveBas   := "" //Chave basica para busca - somente Filial + Matricula

	If cAliasCab == "SRG"
		cChaveCab := &( "{ || " + cAliasCab + "->" + cFilCab + " + " + cAliasCab + "->" + cMatCab + " + cTipoItens + Dtos(SRG->RG_DTGERAR) }" )
	ElseIf cAliasCab == "SRH"
		cChaveCab := &( "{ || " + cAliasCab + "->" + cFilCab + " + " + cAliasCab + "->" + cMatCab + " + cTipoItens + Dtos(SRH->RH_DATAINI) }" )
	Else
		If cAgrupa == "2"   //Centro de Custo
			cChaveCab := &( "{ || " + cAliasCab + "->" + cFilCab + " + " + cAliasCab + "->" + cCcCab + If(lMatCab, " + " + cAliasCab + "->" + cMatCab,"") + " + Dtos(" + cAliasCab + "->" + cCpoDtRel + ") }" )
			cChaveBas := &( "{ || " + cAliasCab + "->" + cFilCab + " + " + cAliasCab + "->" + cCcCab + If(lMatCab, " + " + cAliasCab + "->" + cMatCab,"") + " }" )
		else
			cChaveCab := &( "{ || " + cAliasCab + "->" + cFilCab + If(lMatCab, " + " + cAliasCab + "->" + cMatCab,"") + " + Dtos(" + cAliasCab + "->" + cCpoDtRel + ") }" )
			cChaveBas := &( "{ || " + cAliasCab + "->" + cFilCab + If(lMatCab, " + " + cAliasCab + "->" + cMatCab,"") + " }" )
		EndIf
	EndIf

	If cAgrupa == "2" .And. cAliasCab != "SRH"   //Centro de Custo
		If 	!Empty(cCpoDtLan)
			cChaveLan := &( "{ || " + cAliasLan + "->" + cFilLan + " + " + cAliasLan + "->" + cCcLan + " + " + cAliasLan + "->" + cMatLan + " + cTipoItens + DTOS(" + cAliasLan + "->" + cCpoDtLan + ") }" )
		Else
			cChaveLan := &( "{ || " + cAliasLan + "->" + cFilLan + " + " + cAliasLan + "->" + cCcLan + " + " + cAliasLan + "->" + cMatLan + " + cTipoItens }" )
    	Endif
    else
		If 	!Empty(cCpoDtLan)
			cChaveLan := &( "{ || " + cAliasLan + "->" + cFilLan + " + " + cAliasLan + "->" + cMatLan + " + cTipoItens + DTOS(" + cAliasLan + "->" + cCpoDtLan + ") }" )
		Else
			cChaveLan := &( "{ || " + cAliasLan + "->" + cFilLan + " + " + cAliasLan + "->" + cMatLan + " + cTipoItens }" )
	    Endif
    EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Processa o arquivo CABECALHO definido pelo usuario		      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	While !Eof()

		//Consiste acesso do usuario a filiais
		If ! ( (cAliasCab)->&cFilCab $ cValidFil )
			(cAliasCab)->(dbSkip())
			Loop
		EndIf

		dbSelectArea( cAliasLan )
		If dbSeek( If(Empty(cChaveBas), Eval(cChaveCab), Eval(cChaveBas)) )
			dDataVenc := &(cAliasCab + "->" + cCpoDtCab)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Efetua tratamento especifico para agrupamento Filial/C.Custo,³
			//³ preserva a chave de agrupamento para somar a cada registro.  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cAgrupa # "4"           //Agrupamento Funcionario
				cChaveAgrup := ""
				nRecAgrup   := 0
				If cAgrupa == "1"      //Agrupamento Filial
					cChaveAgrup := &cFilLan + Dtos(dDataVenc)
				ElseIf cAgrupa $ "2*3" //Agrupamento Centro de Custo
					cChaveAgrup := &cFilLan + &cCcLan + Dtos(dDataVenc)
				EndIf
				nPosAgrup := Ascan( aChaveAgrup, { |X| X[1] == cChaveAgrup })
				If nPosAgrup > 0
					nRecAgrup := aChaveAgrup[nPosAgrup, 2]
				Else
					Aadd( aChaveAgrup, { cChaveAgrup, 0 } )
				EndIf
			EndIf

			If cAliasCab $ "SRG*SRH"
				cChaveCabL := &( "{ || " + cAliasCab + "->" + cFilCab + If(lMatCab, " + " + cAliasCab + "->" + cMatCab,"") + " + cTipoItens + Dtos(" + cAliasCab + "->" + cCpoDtRel + ") }" )
				While !Eof() .And. !(Eval(cChaveCabL) == Eval(cChaveLan))
					DbSkip()
				EndDo
			EndIf

			fProcLctos(IIf( !Empty(cChaveCabL),cChaveCabL,cChaveCab ), cChaveLan, aChaveAgrup, nRecAgrup)
		EndIf
		dbSelectArea( cAliasCab )
		dbSkip()
	EndDo
Else
	If cAliasLan <> "RC0"
		aAliasStru 	:= (cAliasLan)->(dbStruct())

		For nX := 1 to Len(cVerbas) Step 4
			If !Empty(cPdAux)
				cPdAux += ","
			EndIf
			cPdAux += "'" + SubStr(cVerbas,nX,3) + "'"
		Next nX

		cSelect := "SELECT * " + CRLF

		If cIdentTit == "RES"
			cCpoData := cIniCpo + IIf(cIniCpo $ "RD_|RGB_", "DTREF", "DATA")
			cQuery := "FROM " + RetSqlName(cAliasLan) + " SRR " + CRLF
			cQuery += "INNER JOIN " + RetSqlName("SRG") + " SRG ON "
			cQuery += "SRR." + cIniCpo + "FILIAL  = SRG.RG_FILIAL "
			cQuery += "AND SRR." + cIniCpo + "MAT = SRG.RG_MAT "
			cQuery += "AND SRR." + cCpoData + " = SRG.RG_DTGERAR "
		Else
			cQuery := "FROM " + RetSqlName(cAliasLan) + CRLF
		EndIf

		cQuery += "WHERE " + cFilLan +	" BETWEEN '" + cFilLimI + "' AND '" + cFilLimF	+ "' AND "

		If lMatLan
       		cQuery += cMatLan + " BETWEEN '" + cMatDeT + "' AND '" + cMatAteT	+ "' AND "
       	EndIf

       	If lCcLan
        	cQuery += cCcLan + " BETWEEN '" + cCcDeT  + "' AND '" + cCcAteT	+ "' AND "
        EndIf

		If cAliasLan == "SRD" .and. !Empty(cAnoMes)
			cQuery += "RD_DATARQ = '" + cAnoMes + "' AND "
		EndIf

		If !Empty(cCpoDtLan)
			cQuery += " " + cCpoDtLan + " BETWEEN '" + Dtos(dDataDeT) + "' AND '" + Dtos(dDataAteT) + "' AND "
		EndIf

		If !( Empty(cPdAux) )
			cQuery += cPDLan + " IN ( " + cPdAux + " ) AND "
		Else
			cQuery += cPDLan + " IN ('') AND "
		EndIf

		If cIdentTit == "RES"
			cQuery += "SRR.D_E_L_E_T_ = ' ' AND SRG.D_E_L_E_T_ = ' ' "
		Else
			cQuery += "D_E_L_E_T_ = ' ' "
		EndIf

		cOrder := " ORDER BY "

		If cAgrupa $ "1*4"       // Filial*Funcionario
			cOrder += cFilLan + If(lMatLan, "," + cMatLan, "") + If(lCcLan,"," + cCcLan, "") + CRLF
		ElseIf cAgrupa $ "2*3"   //Centro de Custo/Nivel de Centro de Custo
			cOrder += cFilLan + "," + cCcLan + If(lMatLan, "," + cMatLan, "") + CRLF
		EndIf

		cQuery := ChangeQuery(cSelect+cQuery+cOrder)
		cAliasLan 	:= GetNextAlias()

		//ABRE A EXECUCAO DA QUERY ATRIBUIDA AO SRA
		If MsOpenDbf(.T.,"TOPCONN",TcGenQry(, ,cQuery),cAliasLan,.F.,.T., .F. , .F.)
			For nX := 1 To Len(aAliasStru)
				If !( aAliasStru[ nX , 02 ] == "C" )
					TcSetField(cAliasLan,aAliasStru[nX][1],aAliasStru[nX][2],aAliasStru[nX][3],aAliasStru[nX][4])
				EndIf
			Next nX
		EndIf
	EndIf

	If cAliasLan <> "RC0"
		fProcLctos(cChaveCab, cChaveLan,,, cAliasAux, cFiltrLan, lVenc)
	EndIf
EndIf

(cAliasLan)->(DbCloseArea())
dbSelectArea(cAlias)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fProcLctos³ Autor ³ Emerson Rosa de Souza ³ Data ³ 13.08.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Busca valores no arquivo de Intes definido pelo usuario	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fProcLctos    			                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 							                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fProcLctos(cChaveCab,cChaveLan,aChaveAgrup,nRecAgrup,cAliasAux,cFiltrLan,lVenc)
Local cAlias    := ALIAS()
Local cTipVerba
Local nValTitulo 	:= 0
Local cFilialAnt
Local cCCAnt
Local cAgrupAnt
Local cCpoAgrup  	:= If(cAgrupa == "1", cFilLan, If(cAgrupa $ "2*3", cCcLan, cMatLan))
Local lIRRF			:= .F.
Local lRatItm		:= SuperGetMV("MV_RATITM",,.F.)
Local aDetTitulo	:= {}
Local cDetTitulo    := ""
Local nTamMat		:= TamSX3("RA_MAT")[1]

DEFAULT cAliasAux	:= cAliasLan
DEFAULT cFiltrLan	:= ""
DEFAULT lVenc		:= .F.

cFilialAnt := Replicate("!",FWGETTAMFILIAL)
cCCAnt     := Replicate("!", GetSx3Cache("RA_CC", "X3_TAMANHO"))

If lVenc .And. Empty(dVctoInf)
	dDataVenc := ctod("  /  /  ")
EndIf

While (cAliasLan)->(!Eof()) .And. Eval(cChaveCab) == Eval(cChaveLan)
	DbSelectArea(cAliasLan)
	cFilialAnt    	:= &cFilLan
	cAgrupAnt     	:= &cCpoAgrup
	aAliasFields	:= {}
	aDetTitulo		:= {}
	cDetTitulo      := ""

	If lVenc .And. Empty(dDataVenc)
		dDataVenc := &(cAliasLan + "->" + cCpoDtCab)
	EndIf

	While (cAliasLan)->(!Eof()) .And. cFilialAnt + cAgrupAnt == &cFilLan + &cCpoAgrup

		// VALIDA A FILIAL DA TABELA RC0 E FILIAL DO ALIAS DE LANÇAMENTOS POIS
		// AS TABELAS PODEM TER COMPARTILHAMENTOS DIFERENTES.
		If SubStr(cFilialAnt, 1, Len(Alltrim((cAliasRC0)->RC0_FILIAL))) <> Alltrim((cAliasRC0)->RC0_FILIAL)
			DbSelectArea(cAliasLan)
			(cAliasLan)->(dbSkip())
			Loop
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se satisfaz a condicao do arquivo de Cabecalho    	³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Eval(cChaveCab) # Eval(cChaveLan)
			DbSelectArea( cAliasLan )
			(cAliasLan)->(dbSkip())
			Loop
		EndIf

		//Filtra centro de custo
		If &cCcLan < cCCDeT .Or. &cCcLan > cCCAteT
			DbSelectArea( cAliasLan )
			(cAliasLan)->(dbSkip())
			Loop
		EndIf

		If !Empty(cFiltrLan)
			(cAliasAux)->( dbGoTo( (cAliasLan)->R_E_C_N_O_ ) )
			If !&cFiltrLan
				dbSelectArea( cAliasLan )
				(cAliasLan)->(dbSkip())
				Loop
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Centro de custo para gravacao quando agrupar por funcionario ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If &cCcLan # cCCAnt
			cCCAnt := &cCcLan
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Testa o filtro do cadastro de funcionarios                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cFiltrSRA # Nil .And. !Empty(cFiltrSRA)
			cChaveBusca := &cFilLan + &cMatLan
			dbSelectArea( "SRA" )
			If dbSeek( cChaveBusca )
				If !&cFiltrSRA
					dbSelectArea( cAliasLan )
					(cAliasLan)->(dbSkip())
					Loop
				EndIf
			EndIf
			dbSelectArea( cAliasLan )
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se for titulo de RES se a rescisão é efetiva        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cIdentTit == "RES"
			If aChaveAgrup == Nil
				If (cAliasLan)->RG_EFETIVA = 'N'
					dbSelectArea( cAliasLan )
					(cAliasLan)->(dbSkip())
					Loop
				EndIf
			Else
				If SRG->RG_EFETIVA = 'N'
					dbSelectArea( cAliasLan )
					(cAliasLan)->(dbSkip())
					Loop
				EndIf
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se as verbas existem no arquivo em processamento    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If &cPDLan $ cVerbas
			cTipVerba := Substr( cVerbas, AT(&cPDLan, cVerbas)+3, 1)
			PosSrv(&cPDLan,&cFilLan)
			lIRRF	:=	.F.
			If ( SRV->RV_CODFOL == '0152' )
				lIRRF	:=	.T.
			EndIf
			dbSelectArea( cAliasLan )
			If !(cTipVerba $ "P*D")
				cTipVerba := If(SRV->RV_TIPOCOD == "2", "D", "P")
			EndIf
			If cTipVerba == "P"     // Verbas definidas (No Titulo) pelo usuario como provento
				nValTitulo += &cValLan
				If lRatItm
					fSomaRat( &cValLan, &cItem )
				EndIf
			ElseIf cTipVerba == "D" //Verbas definidas (No Titulo) pelo usuario como desconto
   				nValTitulo -= &cValLan
   				If lRatItm
					fSomaRat( (&cValLan)*(-1), &cItem )
				EndIf
			EndIf

			If cAliasAux == "SRR" .And. If(Empty(RR_ROTEIR), .F. ,fGetTipoRot(RR_ROTEIR) $ "3*4") .And. !( ( RR_FILIAL + RR_PROCES + RR_ROTEIR + RR_PERIODO + RR_SEMANA + DtoS(RR_DATA) + RR_MAT ) $ cDetTitulo )

				aAdd(aDetTitulo,{RR_FILIAL,RR_PROCES, RR_ROTEIR, RR_PERIODO,RR_SEMANA, RR_DATA , RR_MAT })

				cDetTitulo += RR_FILIAL + RR_PROCES + RR_ROTEIR + RR_PERIODO + RR_SEMANA + DtoS(RR_DATA) + RR_MAT + "|"

			ElseIf cAliasAux $ "SRC" .And. If(Empty(RC_ROTEIR), .F. ,fGetTipoRot(RC_ROTEIR) $ "1*2")
				If cAgrupa == "4" // Agrupamento por Funcionário
					// Considera matrícula
					If !( ( RC_FILIAL + RC_PROCES + RC_ROTEIR, RC_PERIODO + RC_SEMANA + DtoS(RC_DATA) + RC_MAT ) $ cDetTitulo ) // Verifica se chave já foi lida
						aAdd(aDetTitulo,{RC_FILIAL,RC_PROCES, RC_ROTEIR , RC_PERIODO, RC_SEMANA, RC_DATA , RC_MAT })

						cDetTitulo += RC_FILIAL + RC_PROCES + RC_ROTEIR + RC_PERIODO + RC_SEMANA + DtoS(RC_DATA) + RC_MAT + "|"
					EndIf
				Else
					If !( ( RC_FILIAL + RC_PROCES + RC_ROTEIR + RC_PERIODO + RC_SEMANA + DtoS(RC_DATA) + Space(nTamMat) )  $ cDetTitulo )
						aAdd(aDetTitulo,{RC_FILIAL,RC_PROCES, RC_ROTEIR, RC_PERIODO, RC_SEMANA, RC_DATA, Space(nTamMat)})

						cDetTitulo += RC_FILIAL + RC_PROCES + RC_ROTEIR + RC_PERIODO + RC_SEMANA + DtoS(RC_DATA) + Space(nTamMat) + "|"
					EndIf
				EndIf
			EndIf



			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³O ponto de entrada GP650ACM e utilizado no momento do agrupamento dos titulos      ³
			//³Nele e possivel armazenar no array "aAliasFields" os dados que formam o título.    ³
			//³Exemplo: filial, matricula, verba, centro de custo, valor.                         ³
			//³Variaveis disponíveis:                                                             ³
			//³                                                                                   ³
			//³"	cFilLan                                                                         ³
			//³"	cCpoAgrup                                                                       ³
			//³"	cCcLan                                                                          ³
			//³"	cMatLan                                                                         ³
			//³"	cPDLan                                                                          ³
			//³"	cValLan                                                                         ³
			//³Todas estas variáveis deverão ser utilizadas com o símbolo de macro("&") na frente.³
			//³Ex.: cFil := &cFilLan                                                              ³
			//³Utiliar o ponto de entrada GP650CHK para utilizar o numero do titulo e guardar as  ³
			//³informacoes em  uma tabela.                                                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lGp650Acm
	            ExecBlock("GP650ACM",.F.,.F.)
		    EndIf

		EndIf
		dbSelectArea(cAliasLan)
		(cAliasLan)->(dbSkip())
	EndDo
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava o titulo de acordo com seu agrupamento                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !(fGravTit(cFilialAnt,If(cAgrupa$"2*3",cAgrupAnt,If(cAgrupa=="4",cCCAnt,Nil)),If(cAgrupa=="4",cAgrupAnt, Nil),nValTitulo,aChaveAgrup,nRecAgrup,cAliasAux,aDetTitulo))
		Exit
	EndIf
	nValTitulo := 0
EndDo
dbSelectArea(cAlias)

Return Nil

/*/{Protheus.doc} fGravTit
Grava os valores gerados no arquivo de titulos
@author  Emerson Rosa de Souza
@since   13/08/2001
@version 1.0
/*/
Function fGravTit(cFilGrav, cCCGrav, cMatGrav, nValTit, aChaveAgrup, nRecAgrup, cAliasAux, aChaveDet)
Local cAlias     := Alias()
Local cFilAux    := cFilAnt
Local cCposRC1
Local nCnt1
Local dDataAux
Local aAreaSRA   := SRA->( GetArea() )
Local aAreaSRZ   := SRZ->( GetArea() )
Local aAreaAux	 := {}

Local aDadosAuto := {} // Array para o cadastro de fornecedores via ExecAuto
Local aDadosPE   := {} // Array de retorno para o PE GP650CFO
Local nOpc 		 := 0
Local aErro 	 := {}
Local cLog 	  	 := ""
Local aLogCampo  := {}
Local nI 		 := 0
Local cPeriodo   := ""
Local lGeraRJ1   := .F.
Local lExist	 := .F.
Local nPosFor	 := 0
Local nPosLoj 	 := 0
Local cCodSA2    := ""

Private nVlTotTit  := nValTit
Private cCpoFornec := cFornec
Private cNovoTit

//Variáveis declaradas para a execução da MSExecAuto
Private lMsErroAuto    := .F.
Private lMsHelpAuto    := .T.
Private lAutoErrNoFile := .T.

Static cValidFil	:= fValidFil()
Static lCadForA 	:= SuperGetMv( 'MV_CADFORA', .F., .F., cFilAnt )

DEFAULT cAliasAux := cAliasLan
DEFAULT aChaveDet := {}

If cAliasAux $ "SRR*SRC" .And. lTamTitDif .And. lMsgRJ1
	lMsgRJ1 := .F.
	If !MSGYESNO(STR0049) //Deseja continuar a geração de títulos sem gravar os dados na RJ1?
		Return .F.
	EndIf
ElseIf cAliasAux $ "SRR*SRC"
	lGeraRJ1 := !lTamTitDif
EndIf

//Variaveis utilizadas para agrupamento Filial/C.Custo quando o usuario definir Data de Vencimento pelo arquivo de CABECALHO
aChaveAgrup := If( aChaveAgrup == Nil, {}, aChaveAgrup )
nRecAgrup   := If( nRecAgrup   == Nil, 0,  nRecAgrup   )

If !( cFilGrav $ cValidFil )
	If !lTitLog3
		aAdd(aLogFile,{5,OemToAnsi(STR0046) + CRLF}) // Os títulos que seguem não foram gerados pois o usuário não tem acesso as filiais dos mesmos:
		lTitLog3 := .T.
	EndIf

	aAdd(aLogFile,{6,""})

	If !Empty(cFilGrav)
		aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0024) + cFilGrav )
	Endif
	If !Empty(cCCGrav)
		aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0025) + cCCGrav )
	Endif
	If !Empty(cMatGrav)
		aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0026) + cMatGrav )
	Endif
	aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0027) + cPrefix )
	aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0028) + cIdentTit )

	Return .T.
EndIf

If cAliasAux # Nil .And. !Empty(cAliasAux)
	aAreaAux	:= (cAliasAux)->(GetArea())
EndIf

If cAgrupa == "4"
	DbSelectArea( cAliasAux )

	If cAliasAux == "SRR" .And. !Empty(cCpoDtCab)
		SRR->( DbSetOrder(4) )
		cPeriodo := SubStr(cCompetTit,3,4) + SubStr(cCompetTit,1,2)
	EndIf

	If !Empty(cPeriodo)
		If DbSeek( cFilGrav + cMatGrav + cPeriodo )
			If ( !Empty(cAliasCab) .and. !Empty(cCpoDtCab) )
				dDataVenc := &(cAliasCab + "->" + cCpoDtCab)
			EndIf
		EndIf
	EndIf
EndIf

dDataVenc := If( !Empty(dVctoInf),dVctoInf,dDataVenc)
dDataAux  := DataValida(dDataVenc,If(cdiaUtil =="1",.F.,.T.)) // Vencimento real
dDataVenc := If(dDataAux < dDataVenc,dDataAux,dDataVenc)      // Vencimento

If lConsiste
	lExist	:= fExistTit(xFilial("RC1", cFilGrav ),cPrefix,cIdentTit,cFilGrav,cCCGrav,cMatGrav,cAgrupa,cCompetTit,nVlTotTit,dDataVenc)
	If lExist
		If Len(aAreaAux) > 0
			RestArea( aAreaAux )
		EndIf
		If nVlTotTit > 0
			Return .T.
		Else
			Return .F.
		EndIf
	EndIf
EndIf

If !Empty(cFilGrav) .And. nVlTotTit > 0
	//Verifica se Fornecedor foi preenchido com campo de arquivo
	If "_" $ cFornec
		cCpoFornec := ""
		If cAgrupa $ "2*3" .And. cCCGrav # Nil
			dbSelectArea( cAliasCC )
			dbSeek( xFilial(cAliasCC) + cCCGrav )
			cCpoFornec := &( cAliasCC + "->" + AllTrim(cFornec) )
		ElseIf cAgrupa == "4" .And. cMatGrav # Nil
			dbSelectArea( "SRA" )
			dbSeek( cFilGrav + cMatGrav )
			cCpoFornec := &( "SRA->" + AllTrim(cFornec) )
			If lCadForA
				DbSelectArea( "RDZ" )
				RDZ->(DbSetOrder(1)) //RDZ_FILIAL+RDZ_EMPENT+RDZ_FILENT+RDZ_ENTIDA+RDZ_CODENT+RDZ_CODRD0
				If (RDZ->(MsSeek(xFilial("RDZ") + cEmpAnt + xFilial("SRA",SRA->RA_FILIAL) + "SRA" + cFilGrav + cMatGrav)))
					DbSelectArea( "RD0" )
					RD0->(DbSetOrder(1)) //RD0_FILIAL+RD0_CODIGO
					If (RD0->(MsSeek(xFilial("RD0") + RDZ->RDZ_CODRD0)))
						//Incluir os dados na aDadosAuto para gravação na SA2 via ExecAuto
						DbSelectArea( "SA2" )
						SA2->(DbSetOrder(1)) //A2_FILIAL+A2_COD+A2_LOJA

						If (Empty(RD0->RD0_FORNEC + RD0->RD0_LOJA))
							//Verifica se o fornecedor existe na SA2
							If SA2->(MsSeek(xFilial("SA2") + &( "SRA->" + AllTrim(cFornec) )))
								If Empty( cCodSA2 := CriaVar("A2_COD") )
									cCpoFornec := GetSx8Num("SA2","A2_COD",,)
								Else
									cCpoFornec := cCodSA2
									If __lSx8
										RollBackSX8()
									EndIf
								EndIf
							EndIf

							//Tratamento de campos que serão enviados da SRA para SA2
							Aadd( aDadosAuto, {'A2_COD'		, cCpoFornec , NIL} )
							Aadd( aDadosAuto, {'A2_LOJA' 	, cLoja , Nil} )
							Aadd( aDadosAuto, {'A2_NOME'	, If(TamSX3( 'RA_NOME' )[1] > TamSX3( 'A2_NOME' )[1], Substr(SRA->RA_NOME , 1 , TamSX3( 'A2_NOME' )[1] ) , SRA->RA_NOME ) , Nil} )
							Aadd( aDadosAuto, {'A2_NREDUZ'	, If(TamSX3( 'RA_NOME' )[1] > TamSX3( 'A2_NREDUZ' )[1], Substr(SRA->RA_NOME , 1 , TamSX3( 'A2_NREDUZ' )[1] ) , SRA->RA_NOME ) , Nil} )

							If !Empty(SRA->RA_ENDEREC)
								Aadd( aDadosAuto, {'A2_END' , If(TamSX3( 'RA_ENDEREC' )[1] > TamSX3( 'A2_END' )[1], Substr(SRA->RA_ENDEREC , 1 , TamSX3( 'A2_END' )[1] ) , SRA->RA_ENDEREC ) , Nil} )
							Else
								Aadd( aLogCampo, "SRA->RA_ENDEREC")
							Endif

							If !Empty(SRA->RA_ESTADO)
								Aadd( aDadosAuto, {'A2_EST' , If(TamSX3( 'RA_ESTADO' )[1] > TamSX3( 'A2_EST' )[1], Substr(SRA->RA_ESTADO , 1 , TamSX3( 'A2_EST' ) )[1] , SRA->RA_ESTADO ) , Nil} )
							Else
								Aadd( aLogCampo, "SRA->RA_ESTADO")
							Endif

							If !Empty(SRA->RA_MUNICIP)
								Aadd ( aDadosAuto, {'A2_MUN' , If(TamSX3( 'RA_MUNICIP' )[1] > TamSX3( 'A2_MUN' )[1], Substr(SRA->RA_MUNICIP , 1 , TamSX3( 'A2_MUN'  )[1] ) , SRA->RA_MUNICIP ) , Nil} )
							Else
								Aadd( aLogCampo, "SRA->RA_MUNICIP")
							Endif

							Aadd( aDadosAuto, {'A2_TIPO' , 'F' , Nil} )
							Aadd( aDadosAuto, {'A2_CGC' , SRA->RA_CIC , Nil} )
							Aadd( aDadosAuto, {'A2_BAIRRO' , If(TamSX3( 'RA_BAIRRO' )[1] > TamSX3( 'A2_BAIRRO' )[1], Substr(SRA->RA_BAIRRO , 1 , TamSX3( 'A2_BAIRRO'  )[1] ) , SRA->RA_BAIRRO ) , Nil} )

							If Len(aLogCampo) > 0
								If !lTitLog2
									aAdd(aLogFile,{3,OemToAnsi(STR0035)}) // Os funcionários abaixo não foram cadastrados como fornecedores
									lTitLog2 := .T.
								EndIf
								aAdd(aLogFile,{4,"",""})
								aLogFile[Len(aLogFile),2] += STR0033 + SRA->RA_FILIAL + SRA->RA_MAT + STR0037
								aLogFile[Len(aLogFile),3] += "É necessário que os campos do funcionário estejam preenchidos:" + CRLF
								For nCnt1 := 1 to Len(aLogCampo)
									aLogFile[Len(aLogFile),3] += aLogCampo[nCnt1] + " / "
								Next nCnt1
								Return .T.
							Endif

							If lGP650CFO
								aDadosPE := ExecBlock("GP650CFO",.F.,.F.,aDadosAuto)

								If ValType(aDadosPE) == "A" .And. Len(aDadosPE) >= 10
									aDadosAuto := aDadosPE
								EndIf
							EndIf

							//Cadastra um novo Fornecedor
							MSExecAuto({|x, y| MATA020(x, y)},aDadosAuto, 3)

							If !lMsErroAuto
								nPosFor := Ascan(aDadosAuto, { |x|  Upper(x[1]) == "A2_COD" })
								nPosLoj := Ascan(aDadosAuto, { |x|  Upper(x[1]) == "A2_LOJA"})

								If nPosFor > 0 .AND. nPosLoj > 0
									RecLock("RD0",.F.)
									RD0->RD0_FORNEC := aDadosAuto[nPosFor,2]	//SA2->A2_COD
									RD0->RD0_LOJA 	:= aDadosAuto[nPosLoj,2]	//SA2->A2_LOJA
									RD0->(MsUnlock())
								Endif

								ConfirmSX8()
							Else
								If Empty(cCodSA2)
									RollBackSX8()
								EndIf

								aErro := GetAutoGRLog()

								VarInfo(STR0036, aErro)

								For nI := 1 To Len(aErro)
									cLog += StrTran( StrTran( StrTran( StrTran( StrTran( aErro[nI], CHR(10), " " ), CHR(13), " " ), "/", "" ), "<", "" ), ">", "" ) + "|"
								Next nI

								aAdd(aLogFile,{4,"",""})
								aLogFile[Len(aLogFile),2] += Alltrim(StrTran(cLog, "-", ""))

								SA2->(DbCloseArea())
								RD0->(DbCloseArea())
								SRA->(DbCloseArea())

								Return .T.
							EndIf
						EndIf

						SA2->(DbCloseArea())
						cCpoFornec := RD0->RD0_FORNEC
						cLoja      := RD0->RD0_LOJA
					EndIf

					RD0->(DbCloseArea())
				Else
					If !lTitLog2
						aAdd(aLogFile,{3,OemToAnsi(STR0035) + CRLF}) // Os funcionários abaixo não foram cadastrados como fornecedores
						lTitLog2 := .T.
					EndIf

					aAdd(aLogFile,{4,""})
					aLogFile[Len(aLogFile),2]+= STR0033 + cFilGrav + cMatGrav + STR0034 //O funcionário não pode ser cadastrado pois não possui vínculo na RDZ + CRLF

					RDZ->(DbCloseArea())
					Return .T.
				EndIf
				RDZ->(DbCloseArea())
			EndIf
		EndIf
	EndIf

	//Posiciona cFilAnt na filial corrente p/ garantir Integridade
	cFilAnt := cFilGrav

	cNovoTit := GetSx8Num("RC1","RC1_NUMTIT",,RetOrdem( "RC1" , "RC1_FILIAL+RC1_NUMTIT" ))

	DbSelectArea( "RC1" )

	//Ponto de entrada para checar o valor do titulo
	If lGp650Chk
	    aRet1 := {}
		aRet1 := ExecBlock("GP650CHK",.F.,.F.,{nRecAgrup,.T.})
		If ValType(aRet1) == "A" .and. len(aRet1) == 2
			If aRet1 [2] = .F.
				dbSelectArea( cAlias )
				RollbackSX8()
				Return( .T. )
			EndIf
			nRecAgrup := aRet1 [1]
		Else
			RollbackSX8()
			MsgAlert(OemToAnsi(STR0039)) // "O retorno do ponto de entrada GP650CHK deve ser um array e possuir duas posições, sendo a primeira um valor e a segunda uma variável lógica"
			Return ( .F. )
		EndIf
	EndIf

	Begin Transaction
		If nRecAgrup > 0
			dbGoTo( nRecAgrup )
			RecLock("RC1",.F.,.F.)
			RC1->RC1_VALOR += nVlTotTit
			MsUnLock()
		Else
			//Novo numero do titulo deve ser antes do Reclock devido a integridade
			RecLock("RC1",.T.,.T.)
			RC1->RC1_FILIAL   := xFilial("RC1", cFilGrav )
			RC1->RC1_INTEGR   := "0"
			RC1->RC1_FILTIT   := cFilGrav
			If cCCGrav # Nil .and. cAgrupa # "1"
				RC1->RC1_CC := cCCGrav
			EndIf
			If cMatGrav # Nil
				RC1->RC1_MAT := cMatGrav
			EndIf

			//Tratamento de Integração Logix x Rh Protheus
			If cpaisloc == "BRA"
				If lRc1Arelin
					fGravArelin( cMatGrav )
				EndIf
			EndIf

			RC1->RC1_CODTIT   := cCodTit
			RC1->RC1_DESCRI   := cDescri
			RC1->RC1_PREFIX   := cPrefix
			RC1->RC1_NUMTIT   := cNovoTit
			RC1->RC1_TIPO     := cIdentTit
			RC1->RC1_NATURE   := cNature
			RC1->RC1_FORNEC   := cCpoFornec
			RC1->RC1_LOJA	  := cLoja
			RC1->RC1_EMISSA   := dDtEmisTit
			RC1->RC1_VENCTO   := dDataVenc
			RC1->RC1_VENREA   := dDataAux
			RC1->RC1_VALOR    := nVlTotTit
			RC1->RC1_DTBUSI   := dDataDeT
			RC1->RC1_DTBUSF   := dDataAteT
			RC1->RC1_COMPET   := cCompetTit

			If cpaisloc == "BRA"
			 	If cTipoRet <> "2"
			 		RC1->RC1_CODRET := cCodRetTit
			 	Else
			 		RC1->RC1_CODRET := cSRACodRet
			 	EndIf
			EndIf

			//Grava os campos criados pelo usuario - do RC0 para o RC1
		   	For nCnt1 := 1 To Len(aCposUsu)
		   		cCposRC1  := aCposUsu[nCnt1,2]
				&cCposRC1 := aCposUsu[nCnt1,3]
		   	Next nCnt1

			//Grava no array o numero do recno para agrupar posteriormente
			If Len(aChaveAgrup ) > 0
				aChaveAgrup[Len(aChaveAgrup),2] := Recno()
			EndIf

			RC1->( MsUnLock() )

			ConfirmSX8()
		EndIf

		If lGeraRJ1
			fGrvTitCal(aChaveDet)
		EndIf

		SX3->(DbSetOrder(2))

		//Gravacao dos valores do Titulo agrupados por Item Contabil.
		//ColumnPos() - Retirar essa validação do campo QF_FILTIT a partir do release 12.1.18
		If SX3->( DbSeek("QF_FILTIT") ) //se campo existe realiza gravacao
			For nI := 1 to Len(aRatTit)
				RecLock("SQF",.T.)
					SQF->QF_FILIAL := xFilial("SQF",cFilGrav)
					SQF->QF_FILTIT := cFilGrav
					SQF->QF_NUMTIT := cNovoTit
					SQF->QF_ITEM   := aRatTit[nI][1]
					SQF->QF_VALOR  := aRatTit[nI][2]
				MsUnLock()
			Next nI

			aRatTit := {}
		EndIf

		//Ponto de entrada para alterar campos do RC1
		If lGp650Cpo
			ExecBlock("GP650CPO",.F.,.F.)
		EndIf

		//Integracao com modulo SIGAPCO
		PcoDetLan("000092","01","GPEM650")
	End Transaction

	//Retorna filial original para o cFilAnt
	cFilAnt := cFilAux
EndIf

RestArea( aAreaSRA )
RestArea( aAreaSRZ )

If Len(aAreaAux) > 0
	RestArea( aAreaAux )
EndIf

DbSelectArea( cAlias )

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGravArelin  ºAutor  ³Tiago Malta      º Data ³  10/09/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Integração Logix X Rh Protheus.                  		  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fGravArelin( cMat )

Local cDepto  := space(10)
Local cArelin := space(10)

	IF cMat <> nil .AND. !EMPTY(cMat) .AND. Getmv("MV_ERPLOGI") == '1'

		SRA->( dbSetOrder(1) )
		SRA->( dbSeek( xFilial('SRA') + cMat ) )
		cDepto := SRA->RA_DEPTO

		SQB->( dbSetOrder(1) )
		SQB->( dbSeek( xFilial('SQB') + cDepto ) )
		cArelin := SQB->QB_ARELIN

		IF !EMPTY(cArelin)
			RC1->RC1_ARELIN := cArelin
		ENDIF

	ENDIF

Return()

/*/{Protheus.doc} fExistTit
Verifica se o título já foi gerado
@author  gabriel.almeida
@since   17/07/2015
@param   cFil = Filial vinda da RC0
@param   cPrex = Prefixo vindo da RC0
@param   cTipoT = Tipo do título vindo da RC0
@param   cFilt = Filial do título vindo da RC0
@param   cCC = Centro de custo vindo da RC0
@param   cMat = Matrícula vinda da RC0
@param   cAgrup = Agrupamento
@param   cCompet = Competência do título
@param   nValor = Valor do título
@param   dDtVenc = Data de vencimento do título
/*/
Static Function fExistTit(cFil,cPrex,cTipoT,cFilT,cCC,cMat,cAgrup,cCompet,nValor,dDtVenc)
	Local lRet      := .F.
	Local aArea     := GetArea()
	Local cArqRC1   := CriaTrab( "", .F. )
	Local cArqRJ1   := CriaTrab( "", .F. )
	Local nIndex    := 0
	Local cIndex    := ""
	Local cTitRes 		:= ""
	Local cTitFer 		:= ""
	Local cTitFol 		:= ""
	Local cTitAdi 		:= ""
	Local nTam1     := TamSX3("RC1_VALOR")[1]
	Local nTam2     := TamSX3("RC1_VALOR")[2]
	Local nTam3		:= TamSX3("RJ1_PREFIX")[1]
	Local lCfgTit	:= .F.
	Local cDataVen  := ""
	Local cFilGra	:= cFilT
	Local cCompetOr	:= ""

	If lCtrlTit
		cTitRes 	:= SuperGetMv("MV_BTITRES",,"0")
		cTitFer 	:= SuperGetMv("MV_BTITFER",,"0")
		cTitFol 	:= SuperGetMv("MV_BTITFOL",,"0")
		cTitAdi 	:= SuperGetMv("MV_BTITADT",,"0")
		// Executa validação apenas se controle estiver ativo
		If  (cTitRes $ "1*2" .And. cTipoT == "RES") .Or.;
		 	(cTitFer $ "1*2" .And. cTipoT == "FER") .Or. ;
			(cTitFol $ "1*2" .And. cTipoT == "FOL") .Or. ;
			(cTitAdi $ "1*2" .And. cTipoT == "ADI") 
			lCfgTit := .T.
		Endif
	EndIf

	Do Case
		Case cAgrup == "1" //Filial
			cIndex := "RC1_FILIAL+RC1_PREFIX+RC1_TIPO+RC1_COMPET+Str(RC1_VALOR,nTam1,nTam2)+RC1_FILTIT"
			cMat   := ""
			cCC    := ""
		Case cAgrup $ "2/3" //Centro de Custo
			cIndex := "RC1_FILIAL+RC1_PREFIX+RC1_TIPO+RC1_COMPET+Str(RC1_VALOR,nTam1,nTam2)+RC1_CC"
			cMat   := ""
			cFilT  := ""
		Case cAgrup == "4" //Matrícula
			cIndex := "RC1_FILIAL+RC1_PREFIX+RC1_TIPO+RC1_COMPET+Str(RC1_VALOR,nTam1,nTam2)+RC1_MAT"
			cFilT  := ""
			cCC    := ""
	EndCase

	If cChaveDup == "2" //Incluí a data de vencimento na chave
		cIndex   += "+DTOS(RC1_VENCTO)"
		cDataVen := DToS(dDtVenc)
	EndIf

	RC1->(IndRegua( "RC1", cArqRC1, cIndex, NIL, NIL, NIL, .F.))
	nIndex := RetIndex( "RC1" ) + 1
	RC1->( DbSetOrder( nIndex ) )

	cTipoT := cTipoT + Space(TamSX3("RC1_TIPO")[1]-Len(cTipoT))

	//Se já existir log por duplicidade na RJ1, não adiciona mais dados da RC1
	If RC1->( MsSeek( cFil+cPrex+cTipoT+cCompet+Str(nValor,nTam1,nTam2)+cFilT+cCC+cMat+cDataVen ) ) .And. ;
		If(!Empty(aLogFile) .And. aScan(aLogFile,{|x| x[1] == 3}) > 0, .F. , .T.)

		lRet := .T.

		If !lTitLog1
			// O valor 1 na primeira posição do array representa o Log de duplicidade de títulos
			aAdd(aLogFile,{1,OemToAnsi(STR0023) + CRLF})
			lTitLog1 := .T.
		EndIf
		aAdd(aLogFile,{2})
		If !Empty(cFilT)
			aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0024) + cFilT )
		EndIf
		If !Empty(cCC)
			aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0025) + cCC )
		EndIf
		If !Empty(cMat)
			aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0025) + cCC )
		EndIf
		aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0027) + cPrex )
		aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0028) + cTipoT )
		aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0029) + cCompet )
		If !Empty(cDataVen)
			aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0048) + DToC(dDtVenc) )
		EndIf
		aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0030) + Alltrim(Transform(nValor,"@E 9,999,999,999,999.99")) )
	//Se já existir log por duplicidade na RC1, não adiciona mais dados da RJ1
	ElseIf lCtrlTit .And. lCfgTit .And.  If(!Empty(aLogFile) .And. aScan(aLogFile,{|x| x[1] == 1}) > 0, .F. , .T.)

		// Verifica se chave principal (Processo+Roteiro+Período+Semana) já foi gerado por outro título de agrupamento diferente
		cCompetOr	:=  cCompet
		cCompet		:= SubStr(cCompet,3,4)+SubStr(cCompet,1,2)
		dbSelectArea("RJ1")
		RJ1->( DbSetOrder( 4 ) ) // RJ1_FILIAL+RJ1_PREFIX+RJ1_PERIODO+RJ1_TIPO
		If RJ1->( dbSeek( cFilGra+PadR(cPrex,nTam3)+cCompet+cTipoT) )
			While RJ1->(!Eof()) .And. (	RJ1->RJ1_FILIAL == cFilGra  .AND. ;
								RJ1->RJ1_PREFIX == PadR(cPrex,nTam3) .AND. ;
								RJ1->RJ1_PERIODO == cCompet .AND. ;
								RJ1->RJ1_TIPO == cTipoT .AND. !lRet)

				If !lTitLog1
					// O valor 3 na primeira posição do array representa o Log de duplicidade de títulos
					aAdd(aLogFile,{3,OemToAnsi(STR0052) + CRLF +; 							// Não foram gerados títulos pois já foram gerados valores para a mesma composição:
									 OemToAnsi(STR0024) + cFilGra 	+ CRLF +; 				// Filial:
									 OemToAnsi(STR0027) + cPrex 	+ CRLF +; 				// Prefixo:
									 OemToAnsi(STR0029) + cCompetOr + CRLF +; 				// Competência:
									 OemToAnsi(STR0028) + cTipoT 	+ CRLF + CRLF + ;		// Tipo:
									 OemToAnsi(STR0060) + CRLF 		+ CRLF + ;   			// Verificar configuração dos parâmetros:  MV_BTITRES, MV_BTITFOL, MV_BTITADT e MV_BTITFER
									 OemToAnsi(STR0053) }) 									// Acesse a opção de Manutenção de Título e filtre os títulos com as configurações abaixo:
					lTitLog1 := .T.
				EndIf

				If !(cFilGra+cPrex+cCompet+RJ1->RJ1_CODTIT+RJ1->RJ1_NUMTIT $ cChvsRJ1)
					aAdd(aLogFile,{4})
					aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0027) + cPrex )
					aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0028) + cTipoT )
					aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0029) + cCompetOr )
					aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0051) + RJ1->RJ1_CODTIT )

					cChvsRJ1	+= cFilGra+cPrex+cCompet+RJ1->RJ1_CODTIT+RJ1->RJ1_NUMTIT + "|"
					lRet := .T.
				ElseIf cFilGra+cPrex+cCompet+RJ1->RJ1_CODTIT+RJ1->RJ1_NUMTIT $ cChvsRJ1
					lRet := .T.
				EndIf

				RJ1->(DbSkip())

			Enddo
		Else
			lRet := .F.
		EndIf

	EndIf

	RestArea(aArea)

Return lRet

/*/{Protheus.doc} fTamCpoFor
Valida o tamanho do campo fornecedor
@author Gabriel de Souza Almeida
@since 26/10/2015
@version P12
@param cCpo, varchar, Código do Fornecedor
@return lRet
/*/
Function fTamCpoFor(cCpo)
	Local lRet := .T.
	Local nTamSA2 := 0
	Local nTamSRA := 0

	If lRet .And. M->RC0_AGRUPA == "4"
		If "_" $ cCpo
			nTamSA2 := TAMSX3("A2_COD")[1]
			nTamSRA := TAMSX3(cCpo)[1]
			If nTamSRA > nTamSA2
				MsgAlert(STR0031) //Tamanho do campo maior do que o configurado para o campo A2_COD da tabela de fornecedor.
				lRet := .F.
			EndIf
		EndIf
	EndIf
Return lRet

/*/{Protheus.doc} fSomaRat
Funcao responsavel em alimentar array aRatTit que guarda valor do titulo rateado por Item Contabil.
@author esther.viveiro
@since 14/08/2017
@version P12
@param nValor, numerico, valor rateado
@param cItem, caractere, codigo do Item Contabil referente ao valor enviado.
@return Nil
/*/
Static Function fSomaRat(nValor, cItem)
	If ( ValType(aRatTit) == "A" )
		nPosItem := aScan(aRatTit,{|aBusca| aBusca[1] == cItem})
		If nPosItem > 0 //encontrou Item no array
			aRatTit[nPosItem][2] += nValor
		Else
			aadd(aRatTit,{cItem,nValor})
		EndIf
	EndIf
Return Nil

Function GP650Venc()

If !Empty(MV_PAR13) .And. MV_PAR11 > MV_PAR13
	Help(,,STR0047) //"Data de emissão tem que ser menor que a data de vencimento!"
	Return .F.
EndIf

Return .T.


/*/{Protheus.doc} fGrvTitCal
//Grava os detalhes do titulo
@author paulo.inzonha
@since 24/01/2019
@version 1.0
@return Logico
@type function
/*/
Function fGrvTitCal(aChaveDet)
Local nX 		:= 0
Local nTamFil	:= TamSX3("RA_FILIAL")[1]

If TCCanOpen(RetSqlname("RJ1")) .AND. LEN(aChaveDet) > 0
	dbSelectArea( "RJ1" )
	For nX := 1 To Len(aChaveDet)
		RecLock("RJ1",.T.)

		// Posicoes no array
		//1 -_FILIAL
		//2 -_PROCES
		//3- _ROTEIR
		//4- _PERIOD
		//5- _SEMANA
		//6- _DTGERA/_DATA/_DATPGT
		//7 -_MAT

		RJ1->RJ1_FILIAL := RC1->RC1_FILTIT
		RJ1->RJ1_CODTIT := RC1->RC1_CODTIT
		RJ1->RJ1_PREFIX	:= RC1->RC1_PREFIX
		RJ1->RJ1_NUMTIT := RC1->RC1_NUMTIT

		If lCpoInteg
			RJ1->RJ1_PROCES := aChaveDet[nX,2]
			RJ1->RJ1_ROTEIR	:= aChaveDet[nX,3]
			RJ1->RJ1_TIPO 	:= cIdentTit
		EndIf

		RJ1->RJ1_PERIOD := aChaveDet[nX,4]
		RJ1->RJ1_SEMANA := aChaveDet[nX,5]
		RJ1->RJ1_DTGERA := aChaveDet[nX,6]
		RJ1->RJ1_FILFUN := If(Empty(aChaveDet[nX,7]),Space(nTamFil), aChaveDet[nX,1])
		RJ1->RJ1_MAT	:= aChaveDet[nX,7]

		RJ1->( MsUnLock() )
	Next nX
	dbCloseArea( "RJ1" )
EndIf

Return .T.

/*/{Protheus.doc} FGPEM650NumTit
//Verifica a gravação do campo RJ1_NUMTIT
@author Wesley Alves Pereira
@since 30/10/2019
@version 1.0
@return Logico
@type function
/*/
Function FGPEM650NumTit()
Local lReto := .T.

lReto := ChkFile("RJ1") .And. ( TamSX3( "RC1_NUMTIT" )[1] == TamSX3( "RJ1_NUMTIT" )[1] )

If ! lReto
	Help(,,STR0050) //"Há diferença entre o tamanho do campo RC1_NUMTIT e RJ1_NUMTIT, porém para que os dados sejam gravados na RJ1 é necessário que esses dois campos tenham o mesmo tamanho.
EndIf

Return (lReto )

/*/{Protheus.doc} fVldRJ1
// Caso usuário possuir base atualizada mas não ter executado o RDMAKE é exibida uma mensagem
@author raquel.andrade
@since 03/08/2020
@version 1.0
@return Logico
/*/
Static Function fVldRJ1()
Local lRet := .T.

	dbSelectArea("RJ1")
	RJ1->( DbSetOrder( 1 ) ) // RJ1_FILIAL+RJ1_PREFIX+RJ1_PERIODO+RJ1_TIPO
	If RJ1->( dbSeek( cFilAnt ) )
			While RJ1->(!Eof()) .And. (	RJ1->RJ1_FILIAL == cFilAnt) .And. lRet
				If Empty(RJ1->RJ1_ROTEIR)
					lRet := .F.
				EndIf
				RJ1->(DbSkip())
			EndDo
	EndIf

Return lRet



/*/{Protheus.doc} fAlertRJ1
Função para exibição de alerta e link para o TDN com orientação sobre atualização da RJ1 via rdmake
@author raquel.andrade
@since 03/08/2020
@version 1.0
/*/
Static Function fAlertRJ1()
Local oButton1
Local oButton2
Local oCheckBo1
Local lCheckBo1 	:= .F.
Local lRet			:= .T.
Local oGroup1
Local oPanel1
Local oSay1
Local cSession		:= "AlertaGPEM650_"
Local lChkMsg 		:= fwGetProfString(cSession,"AlertaGPEM650_" + cUserName,'',.T.) == ""
Local cTitRes 		:= ""
Local cTitFer 		:= ""
Local cTitFol 		:= ""
Local cTitAdi 		:= ""
Local oDlg

If lCtrlTit
	cTitRes 	:= SuperGetMv("MV_BTITRES",,"0")
	cTitFer 	:= SuperGetMv("MV_BTITFER",,"0")
	cTitFol 	:= SuperGetMv("MV_BTITFOL",,"0")
	cTitAdi 	:= SuperGetMv("MV_BTITADT",,"0")
	If lChkMsg .And. (cTitRes $ "1*2" .Or. cTitFer $ "1*2" .Or. cTitFol $ "1*2" .Or. cTitAdi $ "1*2") // Apenas exibe mensagem se existe controle
		DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0054) FROM 000, 000  TO 200, 500 COLORS 0, 16777215 PIXEL //"Atualização de Base de Dados - Registros RJ1"

			@ 000, 000 MSPANEL oPanel1 SIZE 300, 150 OF oDlg COLORS 0, 16777215 RAISED
			@ 005, 012 GROUP oGroup1 TO 065, 237 PROMPT OemToAnsi(STR0008) OF oPanel1 COLOR 0, 16777215 PIXEL //"Atenção"
			//'Ao habilitar a base de dados para geração de detalhes de títulos para outros roteiros além da Rescisão é necessário atualizar registros anteriores através do rdmake AtuRJ1.prw. '
			//'Caso o rdmake AtuRJ1.prw não seja executado, a base poderá gerar dados inconsistentes.'
			//'Clique em "Abrir Link" para consultar a documentação no TDN'
			@ 020, 017 SAY oSay1 PROMPT OemToAnsi(STR0055) + OemToAnsi(STR0056) + CRLF + OemToAnsi(STR0057) SIZE 215, 035 OF oPanel1 COLORS 0, 16777215 PIXEL
			@ 080, 012 CHECKBOX oCheckBo1 VAR lCheckBo1 PROMPT OEMToAnsi(STR0058) SIZE 067, 008 OF oPanel1 COLORS 0, 16777215 PIXEL //"Não exibir novamente"
			@ 070, 160 BUTTON oButton1 PROMPT STR0059 SIZE 037, 012 OF oPanel1 PIXEL//"Abrir Link"
			@ 070, 200 BUTTON oButton2 PROMPT "OK" SIZE 037, 012 OF oPanel1 PIXEL

			oButton1:bLClicked := {|| ShellExecute("open","https://tdn.totvs.com/x/KXUxIQ","","",1) }
			oButton2:bLClicked := {|| oDlg:End() }

		ACTIVATE MSDIALOG oDlg CENTERED

		If lCheckBo1
			fwWriteProfString(cSession, "MSG_GPEM650_" + cUserName, 'CHECKED', .T.)
		EndIf

		lRet	:= .F.

	EndIf
EndIf

Return lRet
