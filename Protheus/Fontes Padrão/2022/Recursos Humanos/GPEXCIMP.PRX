#INCLUDE "GPEXCALC.CH" 
#INCLUDE "PROTHEUS.CH"

Static lVerMultv

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³			ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.			  			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data	³ FNC			 ³  Motivo da Alteracao 					³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Flavio Corre³25/02/15³PCREQ-2898        ³Inclusao fonte				 			³±±
±±³Allyson M.  ³20/02/2015³TRHKAT    	   ³Ajuste p/ apurar corretamente a diferenca³±±
±±³            ³          ³          	   ³dos valores na rescisao complementar por ³±±
±±³            ³          ³          	   ³dissidio.  				 				 ³±±
±±³Allyson M.  ³04/03/2015³TRHKQ3    	   ³Ajuste na apuracao do Id 0168 - deducao  ³±±
±±³            ³          ³          	   ³da base de IR Ferias em situacao em que  ³±±
±±³            ³          ³          	   ³houve calculo de ferias partidas e no    ³±±
±±³            ³          ³          	   ³segundo mes ha um novo calculo de ferias ³±±
±±³            ³          ³          	   ³partidas. 								 ³±±
±±³Claudinei S.³01/04/15  ³TQXON7    	   ³Criada fInssResEx() parfa verificar os     ³±±
±±³		       ³		  ³          	   ³calculos de Ir, INSS e Deduc Inss IR dos  ³±±  
±±³		       ³		  ³          	   ³Resid.Exterior, Autonomos Cooperados e MEI³±±  
±±³Claudinei S.³01/04/2015³TQXON7          ³Ajustadas as funcoes: fSalc, Calc_IR,    ³±±
±±³            ³          ³          	   ³Calc_IrRRA, fCINSS, fCINSS13, FcIR,      ³±±
±±³            ³          ³          	   ³fCIrFer, fCIR13o, fCSalc, fCalcINSSFun e ³±±
±±³            ³          ³          	   ³fCINSSAut para calcular a base de contri-³±± 
±±³            ³          ³          	   ³buicao independente do conteudo do campo ³±±
±±³            ³          ³          	   ³RA_INSSAUT, incluidas validacoes para    ³±±
±±³            ³          ³          	   ³Residentes no exterior, Autonomos        ³±±
±±³            ³          ³          	   ³Cooperados e MEI. 					      ³±±
±±³Allyson M.  ³04/03/2015³TRHKQ3    	   ³Ajuste na apuracao do Id 0168 - deducao  ³±±
±±³            ³          ³          	   ³da base de IR Ferias em situacao em que  ³±±
±±³            ³          ³          	   ³houve calculo de ferias partidas e no    ³±±
±±³            ³          ³          	   ³segundo mes ha um novo calculo de ferias ³±±
±±³            ³          ³          	   ³partidas. 								 ³±±
±±³Claudinei S.³15/05/2015³TQKKGJ          ³Inclusao do controle de INSS de ferias MS³±±
±±³            ³          ³                ³quando o MV_DINSSFM = "R".               ³±±
±±³            ³          ³				   ³quando o MV_DINSSFM = "R".               ³±±
±±³Claudinei S.³29/06/2015³TRMZGV		   ³Alterada FCalcInssFun() para calcular a  ³±±
±±³            ³          ³				   ³contribuicao adiciona SENAI quando a 	 ³±±
±±³            ³          ³				   ³empresa possuir mais de 500 funcionarios ³±±
±±³Ltrombini   ³16/07/2015³TSSYUM		   ³Alterada FCFGTS() para calcular a base de³±±
±±³            ³          ³				   ³FGTS pra funcionarios admitidos no mes 	 ³±±
±±³            ³          ³				   ³com salario Proporcional				 ³±±
±±³Renan Borges³06/08/2015³TSXNXZ          ³Ajuste para gerar o GPS utilizando o com-³±±
±±³            ³          ³                ³plemento de GPS”, parametro 15, com valor³±±
±±³            ³          ³                ³de compensação de GPS se o centro custo  ³±±
±±³            ³          ³                ³ficar branco e houver filtro de c.custo  ³±±
±±³Flavio Corr ³24/08/2015³TTCGFZ          ³Correção na geração do id 232-INSS Fer.MS³±±
±±³M. Silveira/³05/09/2015³TSGD48          ³Ajuste na fCSalC p/nao calcular a base do³±±
±±³Leandro Dr. ³          ³                ³INSS quando o cpo RA_INSSAUT estiver com ³±±
±±³            ³          ³                ³valor "Nao".                             ³±±
±±³            ³          ³                ³Ajustes na fCIr e fCfgts para correcoes  ³±±
±±³            ³          ³                ³do Piloto TV Tribuna.                    ³±±
±±³Allyson M.  ³10/09/2015³TSZ732    	   ³Ajuste em fCfgts() na proporcionalizacao ³±±
±±³            ³          ³          	   ³da base de FGTS							 ³±±
±±³Allyson M.  ³20/10/2015³TTPYFZ    	   ³Ajuste em fGPSVal() p/ tratar ambos tipos³±±
±±³            ³          ³          	   ³de contrato na SEFIP					 ³±±
±±³            ³          ³        		   ³Ajuste em fCInssAut() p/ verificar corre-³±±
±±³            ³          ³        		   ³tamente o maximo de desconto de INSS     ³±±
±±³            ³          ³          	   ³quando ja houve desconto em outra empresa³±±
±±³Christiane V³29/10/2015³TTPXCT          ³Ajuste em fCSalC() p/ gerar base de cálc.³±±
±±³            ³          ³                ³para autônomo MEI                        ³±±
±±³M. Silveira ³10/12/2015³TTXUZU          ³Ajuste na fCIr13o p/ na resc.complementar³±±
±±³            ³          ³                ³compor o IR considerando as bases e os   ³±±
±±³            ³          ³                ³valores de rescisoes anteriores.         ³±±
±±³Allyson M.  ³14/12/2015³TUAI32    	   ³Ajuste em fCfgts() p/ o cálculo do FGTS  ³±±
±±³            ³          ³          	   ³quando ha afastamento  					 ³±±
±±³Allyson M.  ³29/12/2015³TUCRG2   	   ³Ajuste em fCIr() p/ considerar os Ids    ³±±
±±³            ³          ³          	   ³0106 e 0107 no calculo de rescisao quando³±±
±±³            ³          ³          	   ³nao tem data de referencia (verba oriunda³±±
±±³            ³          ³          	   ³do roteiro ADI)							 ³±±
±±³Raquel Hager³06/01/2016³TUDIMC   	   ³Ajuste para considerar complementar nas  ³±±
±±³            ³          ³          	   ³bases de cálculo de Encargos.			 ³±±
±±³Raquel Hager³14/01/2016³TUDTZD   	   ³Ajuste para não atualizar para DELETADA  ³±±
±±³            ³          ³          	   ³verbas informadas pelo usuario.			 ³±±
±±³Allyson M.  ³22/01/2016³TUDHS0    	   ³Ajuste em fCInss(), fCIr() efCfgts() p/  ³±±
±±³            ³          ³          	   ³situacao no calculo de dissidio que ha 	 ³±±
±±³            ³          ³          	   ³geracao da diferenca de ferias de calculo³±±
±±³            ³          ³          	   ³iniciado no periodo anterior e verbas de ³±±
±±³            ³          ³          	   ³ferias nao estao no acumulados.          ³±±
±±³Allyson M   ³04/02/2016³TUJLEI          ³Ajuste em fcIr13o() p/ somente verificar ³±±
±±³            ³          ³                ³o IR da rescisao anterior quando for o   ³±±
±±³            ³          ³                ³recalculo da rescisao  	 				 ³±±
±±³Allyson M.  ³05/02/2016³TUJCHW    	   ³Retirado o ajuste do dia 29/12    	     ³±±
±±ºRenan Borges³05/04/2016³TUP601          ³Ajuste para abater o valor de % de salá- ³±±
±±º            ³          ³                ³rio educação corretamente do valor de ter³±±
±±º            ³          ³                ³ceiros. Ajuste para validar o cadastro de³±±
±±º            ³          ³                ³tipo de aviso previo corretamente de acor³±±
±±º            ³          ³                ³do com os periodos ativos. Ajuste para   ³±±
±±º            ³          ³                ³utilizar o mnemonico P_CHKDTHOM  ao reali³±±
±±º            ³          ³                ³zar o calculo de rescisão.               ³±±
±±ºRenan Borges³05/05/2016³TVBDCV          ³Ajuste para quando possuir uma verba de  ³±±
±±º            ³          ³                ³PLR na rescisão seja calculada a base de ³±±
±±º            ³          ³                ³IR sem utilizar a data de referencia do  ³±±
±±º            ³          ³                ³sindicato e sim da demissão.             ³±±
±±ºRaquel Hager³24/05/2016³TVBAMG          ³Ajuste para alimentar mnemonico NALQIRADT³±±
±±º            ³          ³                ³- Percentual IR Adiantamento.            ³±±
±±ºRenan Borges³03/06/2016³TVFYT9          ³Ajuste para gerar SEFIP corretamente quan³±±
±±º            ³          ³                ³do tentar gerar para uma filial que não  ³±±
±±º            ³          ³                ³possui registros na tabela S035.         ³±±
±±ºAllyson M   ³30/06/2016³TVFXPQ          ³Ajuste em fCInss() p/ verificar correta- ³±±
±±º            ³          ³                ³mente os dias de ferias no mês  		 ³±±
±±ºClaudinei S.³08/07/2016³TVP136/TUQEKD   ³Ajustada a função fInssResEx para identi-³±±
±±º            ³          ³                ³ficar os funcionários que estão no PPE   ³±±
±±º            ³          ³                ³Programa de Proteção ao Emprego.         ³±±
±±º            ³          ³                ³Merge da 12.1.12.                        ³±±
±±ºMatheus M   ³13/07/2016³TVIJX0          ³Ajuste para gerar os itens 12 e 21 quando³±±
±±º            ³          ³                ³o tipo de contrato for determinado ou    ³±±
±±º            ³          ³                ³indeterminado.						     ³±±
±±ºAllyson M   ³29/07/2016³TVLPAL          ³Ajuste em fCfgts() p/ verificar os valor ³±±
±±º            ³          ³                ³dos adicionais na base quando ha dias de ³±±
±±º            ³          ³                ³FGTS p/ pagamento, caso não incorporem   ³±±
±±ºAllyson M   ³02/08/2016³TVRC14          ³Ajuste em FCalcIRLucro() p/ calculo de IR³±±
±±º            ³          ³                ³correto na rescisão, que já vem  com o   ³±±
±±º            ³          ³                ³valor do IR de folha carregado   		 ³±±
±±ºAllyson M   ³26/08/2016³TVRUMR          ³Ajuste em fInssEmp() p/ validar a falta  ³±±
±±º            ³          ³                ³de preenchimento das tabelas S037 e S038 ³±±
±±³Allyson M.  ³30/08/2016³TVLMEZ          ³Ajuste em fCInss() p/ evitar geracao de  ³±±
±±³            ³          ³        		   ³INSS de folha e, consequentemente, insu- ³±±
±±³            ³          ³        		   ³ficiencia de saldo quando funcionario    ³±±
±±³            ³          ³        		   ³esta os 30 dias do mes de ferias		 ³±±
±±|Claudinei S.|30/11/2016|MRH-1469        |Ajustada fCalcInssFun() para considerar  |±±
±±|            |          |TUQEAR          |as empresas que deixaram a desoneração.  ³±±
±±³Raquel Hager³23/11/2016³TWMEM4          ³Ajuste em fInssEmp() o % SENAI 500 para  ³±±
±±³            ³          ³137831          ³considerar o %SENAI, antes estava fazendo³±±
±±³            ³          ³                ³a divisão sempre por 100.                ³±±
±±ºJônatas A.  ³24/11/2016³172168          ³Ajuste para considerar corretamente os   ³±±
±±º            ³          ³                ³tipos de afastamento que não abatem avos ³±±
±±º            ³          ³                ³da base de FGTS do 130.                  ³±±
±±ºJônatas A.  ³24/11/2016³172168          ³Ajuste p/ gerar FGTS para funcionário    ³±±
±±º            ³          ³                ³afastado durante todo o ano.             ³±±
±±³Renan Borges³14/12/2016³MRH-2445   	   ³Ajuste para que o calculo do dissidio re-³±±
±±³			   ³          ³          	   ³troativo considere a diferença de férias ³±±
±±³			   ³          ³          	   ³já pagas no calculo da folha.            ³±±
±±³Renan Borges³21/12/2016³MRH-2564   	   ³Ajuste para preenche o campo RR_NUMID cor³±±
±±³			   ³          ³          	   ³retamente ao realizar o calculo da resci-³±±
±±³			   ³          ³          	   ³são possuindo um periodo que será pago.  ³±±
±±³Gustavo M.  ³21/12/2016³MRH-438	   	   ³Ajuste na performance ao ter muitos reg. ³±±
±±³			   ³          ³          	   ³na RCC.									 ³±±
±±ºAllyson M   ³27/12/2016³MRH-3264        ³Ajuste em fCalcInssFun() p/ utilizar a   ³±±
±±º            ³          ³                ³data do período de cálculo do dissídio ao³±±
±±º            ³          ³                ³invés da database do sistema.			 ³±±
±±ºGabriel A.  ³27/12/2016³MRH-3015        ³Ajuste para o cálculo do INSS de férias  ³±±
±±º            ³          ³                ³na folha para MULTV.                     ³±±
±±³Allyson M.  ³16/01/2017³MRH-1182        ³Ajuste em fEncarCC() p/ quando for o id  ³±±
±±³            ³		  ³				   ³de líquido da folha não efetuar o rateio ³±±
±±³            ³		  ³				   ³de acordo com o %; será verificado os    ³±±
±±³            ³		  ³				   ³proventos e descontos					 ³±±
±±³Raquel Hager³18/01/2017³MRH-4927        ³Remoção de ajuste indevido na função     ³±±
±±³            ³		  ³				   ³fcInss13.                                ³±±
±±³Raquel Hager³18/01/2017³MRH-4891        ³Ajuste na função fcInss para considerar  ³±±
±±³            ³		  ³				   ³posição 4-RV_INNS na somatoria da base de³±±
±±³            ³		  ³				   ³cálculo de INSS de Férias.               ³±±
±±³Allyson M.  ³19/01/2017³MRH-4377        ³Ajuste em FBaseIni() p/ considerar verbas³±±
±±³            ³		  ³				   ³informadas 								 ³±±
±±³Allyson M   ³20/01/2017³MRH-5109        ³Ajuste em fCalcInssFun() p/ calcular INSS³±±
±±³            ³          ³      		   ³da empresa quando há desoneração e com-  ³±±
±±³            ³          ³      		   ³plementar de dissídio					 ³±±
±±³Renan Borges³23/01/2017³MRH-3753   	   ³Ajuste para calcular diferença de férias ³±±
±±³			   ³          ³          	   ³corretamente quando já houver diferença  ³±±
±±³			   ³          ³          	   ³de férias lançadas da folha do mes ante- ³±±
±±³			   ³          ³          	   ³rior.                                    ³±±
±±³Allyson M   ³24/01/2017³MRH-4639        ³Ajuste em fGpsVal() p/ executar um 'For' ³±±
±±³            ³          ³      		   ³ao invés de fTabela() p/ performance     ³±±
±±³João Balbino³27/01/2017³MPRIMESP-578    ³Ajuste em fCINSS13 p/ não gerar desconto ³±±
±±³            ³          ³      		   ³de INSS para func. Demitido.             ³±±
±±³Allyson M   ³03/02/2017³MRH-5876        ³Ajuste na fCInss para tratar o ID 1412   ³±±
±±³            ³          ³ 		       ³que trata da devolucao do Inss.          ³±±
±±ºGabriel A.  ³03/02/2017³MRH-5965        ³Ajuste para considerar a porcentagem das ³±±
±±º            ³          ³                ³outras entidades quando a de terceiros   ³±±
±±º            ³          ³                ³estiver zerada no cálculo da provisão.   ³±±
±±³Renan Borges³06/02/2017³MRH-1423   	   ³Ajusta para gerar a base de FGTS correta-³±±
±±³			   ³          ³          	   ³mente quando houver afastamento e dias   ³±±
±±³			   ³          ³          	   ³trabalhados no mes.                      ³±±
±±³Allyson M.  ³21/02/2017³MRH-7351        ³Ajuste em FBaseIni() p/ considerar verbas³±±
±±³            ³		  ³				   ³informadas sem ser a de ID 0006			 ³±±
±±³Jônatas A.  ³10/04/2017³DRHPAG-39       ³Ajuste em fGPSVal() p/ incluir código da ³±±
±±³            ³		  ³				   ³verba na chave de busca do array aGPSVal.³±±
±±³Eduardo K.  ³18/04/2017³MPRIMESP-9382   ³Ajuste na proporcionalização de Inss de  ³±±
±±³            ³		  ³				   ³ Ferias e Salario.						 ³±±
±±³Cecilia Car.³24/05/2017³DRHPAG-1474³Ajuste na composicao da base do IR PLR qdo ha ³±±
±±³            ³		  ³				   ³adiantamento calculado no Regime de Caixa³±±
±±³Tiago B.    ³19/07/2017³MPRIMESP-10402  ³ajuste em FCalcIRLucro e Calc_IrPLR para ³±±
±±³            ³		  ³				   ³correto calculo do IRRF no pgto de PLR.  ³±±
±±ºGabriel A.  ³18/08/2017³DRHPAG-4995     ³Ajuste para alimentar a variável         ³±±
±±º            ³          ³                ³lTetoINSS quando o teto do INSS for      ³±±
±±º            ³          ³                ³ultrapassado só com o valor do INSS de   ³±±
±±º            ³          ³                ³férias.                                  ³±±
±±³Eduardo K.  ³17/08/2017³MPRIMESP-11090  ³ajuste em fCIrfer para nao calcular Ir   ³±±
±±³            ³		  ³				   ³ferias para expatriado de acordo c/ hist.³±±
±±³            ³		  ³				   ³de contrato.							 ³±±
±±³Cícero Alves³01/09/2017³DRHPAG-256	   ³Ajustada a fInssResEx() para atribuir ao ³±±
±±³			   ³		  ³				   ³Mnemonico lEncPatro o conteudo do campo  ³±±
±±³			   ³		  ³				   ³RGE_ENCARG(Encargos Sociais Res.Exterior)³±±
±±ºGabriel A.  ³11/09/2017³DRHPAG-5367     ³Implementação de folha complementar para ³±±
±±º            ³          ³                ³múltiplos vínculos.                      ³±±
±±³Eduardo K.  ³18/04/2017³MPRIMESP-9894   ³Ajuste no calculo de INSS Férias quando  ³±±
±±³            ³		  ³				   ³há aumento salarial no período de gozo.  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCalcIrLuc³ Autor ³ Equipe Rh             ³ Data ³10/01/96  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do Ir Distr. Lucro                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCalcIrLucro(aCodFol,cSemana,lDep)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FCalcIRLucro(aCodFol,cSem,lDep)

Local aCodBenef := {}
Local aPdAux    := aClone(aPdAcum)
Local cVerbas	:= ""
Local nAliq     := 0
Local nValPePLR := 0
Local nCntP		:= 0
Local nIR_BFol	:= nIR_B
Local nPosP		:= 0
Local nPosRed	:= 0
Local nValDepLr	:= 0.00
Local nValPLRAnt:= 0.00
Local cAnoIR   	:= StrZero(Year(DDATA_PGTO),4)
Local cDtPLR	:= If( (cTipoRot <> "F" .And. !(cTipoRot =='4' .and. ccompl == 'S' .and. Year(ddatadem) <> Year(GetMemVar("RG_DATAHOM"))) ), Alltrim(Str(Ano(dDataDe))) , If(!Empty(aSind) , aSind[1,8] , Substr(CANOMES,1,4) ) ) //Na Rescisão
Local dDtPlr	:= If((cTipoRot <> "F" .And. !(cTipoRot =='4' .and. ccompl == 'S' .and. Year(ddatadem ) <> Year(GetMemVar("RG_DATAHOM"))) ) , DDATAATE , StoD(cDtPLR+"0101") )
Local dDataHom  := cTod("")
Local lIrNeg	:= Len(aCodFol) >= 1726 .And. !Empty(aCodFol[1726,1]) .And. !Empty(aCodFol[1727,1]) 
Local lRvCpoPlr	:= SRV->(Columnpos("RV_REFPLR") > 0)

cSem := If (cSem == Nil ,cSemana,cSem)
nIR_B:= 0

If aCodfol[151,1] # Space(3) .And. aCodFol[152,1] # Space(03) .And.;
 	( Ascan(aPd, { |X| X[1] == aCodfol[151,1] .And. X[9] # "D" .And. X[5] > 0}) > 0 ) //Só procura se houver pagamento de PLR no mes.
	If cTipoRot <> "F" //PLR No Roteiro de Rescisão Não utiliza o Sindicato
		If Empty(aTabIrPlr)
			CarIrPlr(@aTabIrPlr,MesAno(dDataDe))
		EndIf
		cVerbas := aCodFol[151,1]+"/"+aCodFol[152,1] + "/" + P_PDBIRPLR
		If Empty(aPdAcum)
			aPdAcum := fBuscaAcmPer(cVerbas, "", "V", , , cDtPLR+"01", cDtPLR+"12", ,, , .T. , .F.  )
		EndIf
		If Empty(aPdAcum)
			aPdAcum := {}
		EndIf		
		fChkPLRAnt(Nil,aPdAcum,Nil,@nValPLRAnt,cDtPLR)
	EndIf
	If !Empty(aTabIrPlr)
		nPos := Ascan(aPd, { |X| X[1] = aCodfol[835,1] .And. X[3] = cSem .And. X[9] # "D"})
		
		If nPos > 0
			nIr_b := aPd[nPos,5]
		Else
			Aeval( aPd ,{ |X| If(cTipoRot != "4" .Or. ( (Empty(x[10]) .Or. Year(x[10]) == Year(ddatadem) .Or. (cCompl == "S" .and. Year(ddatadem) <> Year(GetMemVar("RG_DATAHOM")))) .and. (!lRvCpoPlr .or. x[1] == aCodFol[151,1] .or. RetValSRV(x[1], SRA->RA_FILIAL, 'RV_REFPLR') == "S") ), SomaInc(X,5,@nIR_B,11,"N",12,"N",,.F.,aCodFol), Nil) })
			nIr_b += nValPLRAnt
			If !lRvCpoPlr .or. cTipoRot != "4"
				nIr_b -= nIR_BFol
			EndIf
			If cTipoRot == "4" .and. !lRvCpoPlr .and. RetValSRV(aCodFol[006,1],SRA->RA_FILIAL,"RV_IR") == "S"
				dDataHom := GetMemVar("RG_DATAHOM")
				//-- Procura Base de Ir Adto.
				nPos := Ascan(aPD,{ |X| X[1] == aCodFol[010,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10])})
				If nPos > 0
					Aeval(aPd,{ |X| nIr_b += If ( X[1]==aCodFol[010,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10]),X[5],0) })
				Else
					//-- Procura Base de Ir Mes Anterior
					Aeval(aPd,{ |X| nIr_b += If ( X[1]==aCodFol[106,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10]),X[5],0) })
					If lIrNeg
						Aeval(aPd,{ |X| nIr_b -= If ( X[1]==aCodFol[1727,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10]),X[5],0) })
					EndIf
				EndIf
				//-- Se encontrado o redutor, soma-o novamente na base de IR
				nPos := Ascan(aPD,{ |X| X[1] == aCodFol[408,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10])})
				If nPos > 0
					nIr_b += aPd[nPos,5]
				EndIf
			EndIf			
		EndIf
		
		If nIR_B > 0
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Busca os codigos de pensao definidos no cadastro beneficiario³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			fBusCadBenef(@aCodBenef)
			
			nValPePLR := 0
			For nCntP := 1 To Len(aCodBenef)
				nPosP := Ascan(aPD , { |X| X[1] == aCodBenef[nCntP,8] .And. X[9] # "D" })
				If nPosP > 0 .And. RetValSRV(aPd[nPosP,1], SRA->RA_FILIAL,"RV_IR") == "N"
					nValPePLR += aPd[nPosP,5]
				EndIf
			Next nCntP
			
			nIr   := 0.00
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Redutor da base de IR na participacao dos lucros             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nPosRed := Ascan(aPd, { |X| X[1] = aCodfol[411,1] .And. X[3] = cSem .And. X[9] # "D"})
			If nPosRed > 0
				nIr_b := Max( nIr_b - aPd[nPosRed,5], 0 )
			EndIf
			
			If cTipoRot == "F" .And. nValPLRAnt == 0
				//Verifica se houve pagamento de PLR no ano atual referente ao ano anterior
				cVerbas := aCodFol[151,1]+"/"+aCodFol[152,1] + "/" + aCodFol[1279,1]+"/" + P_PDBIRPLR
				aPdAcum := {}
				//Busca verbas pelo RD_DATARQ
				aPdAcum  := fBuscaAcmPer(cVerbas, "", "V", , , cAnoIR+"01", cAnoIR+"12", ,, , .T. , .F.  )

				If !Empty(aPdAcum)
					fChkPLRAnt(Nil,aPdAcum,Nil,@nValPLRAnt,cDtPLR)
					nIr_b += nValPLRAnt

					If ( nPosRed := Ascan(aPdAcum, { |X| X[1] = aCodfol[1279,1] }) ) > 0
						nIr_b -= aPdAcum[nPosRed,3] //Subtrai o total da primeira parcela do PLR do ano anterior se este foi pago no ano atual.
						//Isto deve ser feito pois o valor da PLR é a soma das duas parcelas, caso as duas parcelas tenham sido pagas no ano atual, o valor da primeira já estará somada na base.
					EndIf
				EndIf
			Endif

			Calc_IrPLR(nIr_B , nValPePLR, @nIr , 0 ,@nValDepLr,, aTabIrPlr,,@nAliq,aCodFol)

			aPdAcum := aClone(aPdAux)
	        //Guarda o valor da base na variavel referente base IR de adiantamento
			BASE_INI := nIr_B
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Gerar Ir Dist. Lucro										 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cTipoRot == "4" .And. cCompl == "S"
				If (nPos := Ascan(aPd, { |X| X[1] = aCodfol[152,1] .And. X[3] = cSem .And. X[9] # "D" .And. x[5] == 0})) > 0
					aPd[nPos,9] := "D"
				EndIf
			EndIf
			FMatriz(aCodfol[152,1],nIr,nAliq,cSem,,,If(cTipoRot=="F","A",NIL),,,,,,,,,,,,dDtPlr)
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Gerar Base Ir Dist. Lucro									 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			FMatriz(aCodfol[835,1],nIr_B,,cSem,,,If(cTipoRot=="F","A",NIL),,,,,,,,,,,,dDtPlr)
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Gerar Base Ir Primeira Parcela								 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If IRPLRANT > 0
				FMatriz(aCodfol[1328,1],IRPLRANT,,cSem,,,If(cTipoRot=="F","A",NIL),,,,,,,,,,,,dDtPlr)
			EndIf
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Gerar Ded.Dep. Distr. Lucro.								 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If aCodFol[300,1] # Space(3)  .and. lDep
				FMatriz(aCodfol[300,1],nValDepLr,Val(SRA->RA_DEPIR),cSem,,,,,,,,,,,,,,,dDtPlr)
				//Zera o valor da variavel de dependente folha pois o valor do dependente
				//sera pago na verba de PLR.
				VAL_DEDDEP := 0
			EndIf
			
		EndIf
	EndIf
EndIf      

If Empty(aTabIrPlr)
	If aCodfol[151,1] # Space(3) .And. (nPos := Ascan(aPd, { |X| X[1] = aCodfol[151,1] .And. X[3] = cSem .And. X[9] # "D"}) > 0 )
		If GetRemoteType() == -1
			MsgLogGrid( Ap5GetHelp("IRPLR"), .F. ) // Retornar string da funcao Help
		Else
			If IsInCallStack( "EXECROT" ) //Se estiver executando roteiro de calculo
				AddLogExecRot( Ap5GetHelp("IRPLR") )
			Else 
				Help(" ",1,"IRPLR")
			EndIf		
		EndIf     
	EndIf
EndIf     

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FInssEmp ³ Autor ³ Mauro                 ³ Data ³ 06/09/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carregar o Parametro Inss Empresa.                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ FInssEmp(cFilial,aInssEmp,lDeducao,cAnoMes)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fInssEmp(cFil,aInssEmp,lDeducao,cAnoMes,lCodEve,lCarTab)

Local aArea			:= GetArea()
Local cTab			:= "S037"
Local nDed			:= 0
Local n     		:= 0
Local nPosTab		:= 0
Local dDataRef		:= CtoD("")
Local lProvisao     := IsInCallStack("GPEM070") .or. IsInCallStack("GPM070GRD")
Local nPerTeProv    := 0
Local nX     		:= 0
Local aTipoContr	:= {}
Local lACodFol		:= Type("aCodFol") == "A"

DEFAULT cAnoMes		:= AnoMes(dDataAte) //Ultimo dia do periodo de calculo
DEFAULT lCodEve		:= .F.
DEFAULT lCarTab		:= .F.

dDataRef := Stod(cAnoMes+"01")

lDeducao   := If (lDeducao == Nil , .T. , lDeducao)

//-Array aInssEmp
//-[1] % Empresa    - [2] % Terceiros    - [3] % Acidente    - [4] % Fgts
//-[5] % Prov. 13o. - [6] % Prov. Ferias 
//-[9] % Sal.Educ.  - [10]% Incra        - [11]% Senai       - [12]% Sesi
//-[13]% Senac      - [14]% Sesc         - [15]% Sebrae      - [16]% Dpc
//-[17]% Faer       - [18]% Senar        - [19]% Seconc      - [20]% Prov.Resc
//-[21]% Ac.Trb.Cc  - [22]% Sest         - [23]% Senat       - [24] Cod. Pgto. GPS
//-[25] Cod. Terceiros -[26]% Sescoop    - [27]Rec.Fat.      - [28] Vlr Min. Recol.GPS                     
//-[29]% Rat			- [30]% Adic.SENAI  - [31]Sub Patronal 
                       
aInssEmp := Array( 31, 2 )

For n := 1 To Len(aInssEmp)
	If n==24 .or. n==25 .or. n==27
		aInssEmp[n,1] := ""
		aInssEmp[n,2] := ""	
	Else 
		aInssEmp[n,1] := 0.00000
		aInssEmp[n,2] := 0.00000 
	EndIf 
Next n

//--TABELA S037 - ENCARGOS EMPRESAS
//--PARA GERAR O EVENTO S-1020 DO ESOCIAL, NÃO PRECISA CONSIDERAR OS VALORES DA S037, MAS SOMENTE DA S038.
If !lCodEve
	nPosTab := fPosTab( cTab,cAnoMes,"==",2,"1","==",4,Nil,Nil,Nil,lCarTab,cFil,Nil,Nil,Nil,dDataRef) //Tipo de contrato 1

	If nPosTab == 0
		nPosTab := fPosTab(cTab, Space(6), "==",2,"1","==",4,Nil,Nil,Nil,Nil,cFil,Nil,Nil,Nil,dDataRef)
	EndIf

	If nPosTab > 0
		aInssEmp[01,1] 	:= 	fTabela(cTab,nPosTab,5,dDataRef,cFil)/100    	//Empresa
		aInssEmp[03,1] 	:= 	fTabela(cTab,nPosTab,6,dDataRef,cFil)/100    	//Acidente
		aInssEmp[29,1]	:= 	fTabela(cTab,nPosTab,7,dDataRef,cFil)/100    	//RAT
		aInssEmp[04,1] 	:= 	fTabela(cTab,nPosTab,8,dDataRef,cFil)/100   	//Fgts
		aInssEmp[27,1]	:= 	fTabela(cTab,nPosTab,9,dDataRef,cFil)			//Recolhe s. faturamento
		aInssEmp[24,1]	:=  fTabela(cTab,nPosTab,11,dDataRef,cFil)			//Cod. de Pgto. GPS
		aInssEmp[28,1] 	:=  fTabela(cTab,nPosTab,12,dDataRef,cFil)		    //Vlr. minimo da GPS
		aInssEmp[05,1] 	:=  fTabela(cTab,nPosTab,14,dDataRef,cFil)/100   	//Prov 13
		aInssEmp[06,1] 	:=  fTabela(cTab,nPosTab,15,dDataRef,cFil)/100  	//Prov Ferias 	
		aInssEmp[20,1]	:=  fTabela(cTab,nPosTab,16,dDataRef,cFil)/100   	//Prov Rescisao
		aInssEmp[31,1]	:=  fTabela(cTab,nPosTab,17,dDataRef,cFil)   		//Sub Patronal
	Else
		Return( .F. )
	EndIf
EndIf

nPosTab := fPosTab( cTab,cAnoMes,"==",2,"2","==",4,,,,,cFil,Nil,Nil,Nil,dDataRef) //Tipo de contrato 2

If nPosTab == 0
	nPosTab := fPosTab(cTab, Space(6), "==",2,"2","==",4,,,,,cFil,Nil,Nil,Nil,dDataRef)
EndIf

If nPosTab > 0
	aInssEmp[01,2] 	:= 	fTabela(cTab,nPosTab,5,dDataRef,cFil)/100    	//Empresa
	aInssEmp[03,2] 	:= 	fTabela(cTab,nPosTab,6,dDataRef,cFil)/100    	//Acidente
	aInssEmp[29,2]	:= 	fTabela(cTab,nPosTab,7,dDataRef,cFil)/100    	//RAT
	aInssEmp[04,2] 	:= 	fTabela(cTab,nPosTab,8,dDataRef,cFil)/100   	//Fgts
	aInssEmp[27,2]	:=	fTabela(cTab,nPosTab,9,dDataRef,cFil)			//Recolhe s. faturamento
	aInssEmp[24,2]	:=  fTabela(cTab,nPosTab,11,dDataRef,cFil)			//Cod. de Pgto. GPS
	aInssEmp[28,2] 	:=  fTabela(cTab,nPosTab,12,dDataRef,cFil)		    //Vlr. minimo da GPS
	aInssEmp[05,2] 	:=  fTabela(cTab,nPosTab,14,dDataRef,cFil)/100   	//Prov 13
	aInssEmp[06,2] 	:=  fTabela(cTab,nPosTab,15,dDataRef,cFil)/100  	//Prov Ferias 	
	aInssEmp[20,2]	:=  fTabela(cTab,nPosTab,16,dDataRef,cFil)/100 		//Prov Rescisao
	aInssEmp[31,1]	:=  fTabela(cTab,nPosTab,17,dDataRef,cFil)   			//Sub Patronal
EndIf

cTab := "S038"

//--TABELA S038 - OUTRAS ENTIDADES
nPosTab := 0 

If Len(aTipoContr := fRetRCB(cFil,cTab, "18")) == 0 //Verifica se o campo TIPOCONTR  existe
	nPosTab := fPosTab( cTab,cAnoMes,"==",2,,,,,,,,cFil,Nil,Nil,Nil,dDataRef) //Tipo de contrato 1
	If nPosTab == 0
		nPosTab := fPosTab( cTab,Space(6),"==",2,,,,,,,,cFil,Nil,Nil,Nil,dDataRef)
	EndIf
Else
	nPosTab := fPosTab( cTab,cAnoMes,"==",2,"1","==",21,,,,,cFil,Nil,Nil,Nil,dDataRef) 
	If nPosTab == 0
		nPosTab := fPosTab( cTab,cAnoMes,"==",2," ","==",21,,,,,cFil,Nil,Nil,Nil,dDataRef) 
		If nPosTab == 0
			nPosTab := fPosTab(cTab,Space(6),"==",2,"1","==",21,,,,,cFil,Nil,Nil,Nil,dDataRef)
			If nPosTab == 0
				nPosTab := fPosTab(cTab,Space(6),"==",2," ","==",21,,,,,cFil,Nil,Nil,Nil,dDataRef)
			EndIf
		EndIf
	EndIf
EndIf

If nPosTab > 0
	aInssEmp[25,1]	:= 	fTabela(cTab,nPosTab,4,dDataRef,cFil)		//Codigo de Terceiros
	aInssEmp[02,1] 	:=	fTabela(cTab,nPosTab,5,dDataRef,cFil)		//% Terceiros
	aInssEmp[09,1] 	:=	fTabela(cTab,nPosTab,6,dDataRef,cFil)/100	//% Sal. Educacao
	aInssEmp[10,1] 	:=	fTabela(cTab,nPosTab,7,dDataRef,cFil)/100	//% INCRA
	aInssEmp[11,1] 	:=	fTabela(cTab,nPosTab,8,dDataRef,cFil)/100	//% SENAI
	aInssEmp[12,1] 	:=	fTabela(cTab,nPosTab,9,dDataRef,cFil)/100	//% SESI
	aInssEmp[13,1] 	:=	fTabela(cTab,nPosTab,10,dDataRef,cFil)/100	//% SENAC
	aInssEmp[14,1] 	:=	fTabela(cTab,nPosTab,11,dDataRef,cFil)/100	//% SESC
	aInssEmp[15,1] 	:=	fTabela(cTab,nPosTab,12,dDataRef,cFil)/100	//% SEBRAE
	aInssEmp[16,1] 	:=	fTabela(cTab,nPosTab,13,dDataRef,cFil)/100	//% DPC
	aInssEmp[17,1] 	:=	fTabela(cTab,nPosTab,14,dDataRef,cFil)/100	//% F. AER.
	aInssEmp[18,1] 	:=	fTabela(cTab,nPosTab,15,dDataRef,cFil)/100	//% SENAR
	aInssEmp[19,1] 	:=	fTabela(cTab,nPosTab,16,dDataRef,cFil)/100	//% SECONC
	aInssEmp[22,1] 	:=	fTabela(cTab,nPosTab,17,dDataRef,cFil)/100	//% SEST
	aInssEmp[23,1] 	:=	fTabela(cTab,nPosTab,18,dDataRef,cFil)/100	//% SENAT
	aInssEmp[26,1] 	:=	fTabela(cTab,nPosTab,19,dDataRef,cFil)/100	//% SESCOOP
	aInssEmp[30,1] 	:=	fTabela(cTab,nPosTab,20,dDataRef,cFil)/100	//% ADIC.SENAI
Else
	Return( .F. )
EndIf

If Len(aTipoContr) > 0 //Verifica se o campo TIPOCONTR  existe
	nPosTab := fPosTab( cTab,cAnoMes,"==",2,"2","==",21,,,,,cFil,Nil,Nil,Nil,dDataRef) //Tipo de contrato 2	
	If nPosTab == 0
		nPosTab := fPosTab(cTab, Space(6), "==",2,"2","==",21,,,,,cFil,Nil,Nil,Nil,dDataRef)
	EndIf
Else
	nPosTab := 0
EndIf

If nPosTab > 0
	 	
	aInssEmp[25,2]	:= 	fTabela(cTab,nPosTab,4,dDataRef,cFil)		//Codigo de Terceiros
	aInssEmp[02,2]	:=  fTabela(cTab,nPosTab,5,dDataRef,cFil)		//% Terceiros
	aInssEmp[09,2]	:=  fTabela(cTab,nPosTab,6,dDataRef,cFil)/100	//% Sal. Educacao
	aInssEmp[10,2]	:=  fTabela(cTab,nPosTab,7,dDataRef,cFil)/100	//% INCRA
	aInssEmp[11,2]	:=  fTabela(cTab,nPosTab,8,dDataRef,cFil)/100	//% SENAI
	aInssEmp[12,2]	:=  fTabela(cTab,nPosTab,9,dDataRef,cFil)/100	//% SESI
	aInssEmp[13,2]	:=  fTabela(cTab,nPosTab,10,dDataRef,cFil)/100	//% SENAC
	aInssEmp[14,2]	:=  fTabela(cTab,nPosTab,11,dDataRef,cFil)/100	//% SESC
	aInssEmp[15,2]	:=  fTabela(cTab,nPosTab,12,dDataRef,cFil)/100	//% SEBRAE
	aInssEmp[16,2]	:=  fTabela(cTab,nPosTab,13,dDataRef,cFil)/100	//% DPC
	aInssEmp[17,2]	:=  fTabela(cTab,nPosTab,14,dDataRef,cFil)/100	//% F. AER.
	aInssEmp[18,2]	:=  fTabela(cTab,nPosTab,15,dDataRef,cFil)/100	//% SENAR
	aInssEmp[19,2]	:=  fTabela(cTab,nPosTab,16,dDataRef,cFil)/100	//% SECONC
	aInssEmp[22,2]	:=  fTabela(cTab,nPosTab,17,dDataRef,cFil)/100	//% SEST
	aInssEmp[23,2]	:=  fTabela(cTab,nPosTab,18,dDataRef,cFil)/100	//% SENAT
	aInssEmp[26,2]	:=  fTabela(cTab,nPosTab,19,dDataRef,cFil)/100	//% SESCOOP
	aInssEmp[30,2]	:=  fTabela(cTab,nPosTab,20,dDataRef,cFil)/100	//% ADIC.SENAI
	
Else

	aInssEmp[25,2]	:= 	aInssEmp[25,1]	//Codigo de Terceiros
	aInssEmp[02,2]	:=  aInssEmp[02,1]  //% Terceiros
	aInssEmp[09,2]	:=  aInssEmp[09,1]  //% Sal. Educacao
	aInssEmp[10,2]	:=  aInssEmp[10,1]  //% INCRA
	aInssEmp[11,2]	:=  aInssEmp[11,1]  //% SENAI
	aInssEmp[12,2]	:=  aInssEmp[12,1]  //% SESI
	aInssEmp[13,2]	:=  aInssEmp[13,1]  //% SENAC
	aInssEmp[14,2]	:=  aInssEmp[14,1]  //% SESC
	aInssEmp[15,2]	:=  aInssEmp[15,1]  //% SEBRAE
	aInssEmp[16,2]	:=  aInssEmp[16,1]  //% DPC
	aInssEmp[17,2]	:=  aInssEmp[17,1]  //% F. AER.
	aInssEmp[18,2]	:=  aInssEmp[18,1]  //% SENAR
	aInssEmp[19,2]	:=  aInssEmp[19,1]  //% SECONC
	aInssEmp[22,2]	:=  aInssEmp[22,1]  //% SEST
	aInssEmp[23,2]	:=  aInssEmp[23,1]  //% SENAT
	aInssEmp[26,2]	:=  aInssEmp[26,1]  //% SESCOOP
	aInssEmp[30,2]	:=  aInssEmp[30,1]  //% ADIC.SENAI

EndIf

For nX := 1 To 2

	nDed := aInssEmp[09,nX] + aInssEmp[10,nX] + aInssEmp[11,nX] + aInssEmp[12,nX] + aInssEmp[13,nX] + aInssEmp[14,nX]
	nDed += aInssEmp[15,nX] + aInssEmp[16,nX] + aInssEmp[17,nX] + aInssEmp[18,nX] + aInssEmp[19,nX]
	nDed += aInssEmp[22,nX] + aInssEmp[23,nX] + aInssEmp[26,nX]
		
	If lDeducao
		aInssEmp[02,nX] -= (nDed*100)
	EndIf
	
	aInssEmp[02,nX] := aInssEmp[02,nX] / 100
	
	If lProvisao .And. aInssEmp[02,nX] == 0
		nPerTeProv     := aInssEmp[09,nX] + aInssEmp[10,nX] + aInssEmp[11,nX] + aInssEmp[12,nX] + aInssEmp[13,nX] + aInssEmp[14,nX] + aInssEmp[15,nX] +;
		                  aInssEmp[16,nX] + aInssEmp[17,nX] + aInssEmp[18,nX] + aInssEmp[19,nX] + aInssEmp[22,nX] + aInssEmp[23,nX] + aInssEmp[26,nX]
		aInssEmp[02,nX] := nPerTeProv
	EndIf	

	// Se possuir SENAI 500, faz a proporção com o Percentual do SENAI
	// e adiciona o percentual do SENAI 500 ao % Terceiros
	If (Funname() == "GPEA070" .Or. lProvisao) .And. aInssEmp[30,nX] > 0 .And. lACodFol
		
		aInssEmp[2,nX] += (aInssEmp[30,nX] * aInssEmp[11,nX])
		nPerc := RetValSRV(aCodFol[1395, 1],     SRA->RA_FILIAL,"RV_PERC")//SRV->RV_PERC
		
		//Tratamento para retenção do SENAI, quando a empresa contribui com 1% e o SENAI devolve 0,05% para a empresa.
		//Nos terceiros é informado 0,95% para a folha de pagamento, mas o valor do Adicional SENAI é 20%
		//de 1% e não de 0,95%, para estes casos, se o percentual da verba do SENAI for diferente de 100%, 
		//a diferença entre o %SENAI e o Percentual da verba do SENAI será adicionada aos Terceiros.
		If nPerc != 0 .And. nPerc != 100
			aInssEmp[2,nX] += (nPerc / 100) * (aInssEmp[11,nX] / 100) 
		Endif		
	Endif
	
Next nX

RestArea(aArea)          

Return ( .T. )  
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FEncarCc   ³ autor ³ Mauro               ³ Data ³ 19/09/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula encargos por C.Custo                               ´±±
±±³ÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³±±
±±³Parametro ³                                                            ´±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fEncarCc(cVerbas, lRatM013)

Local nQtdDsr   := 0   //-- Quantidade de C.Custo Lancados de DSR s/H.Extra
Local nQtdCom   := 0   //-- Quantidade de C.Custo Lancados de DSR s/Comissoes
Local nQtdPro   := 0   //-- Quantidade de C.Custo Lancados de DSR s/Professor
Local nQtdHE   	:= 0   //-- Quantidade de C.Custo H.E.
Local nQtdHtv   := 0   //-- Quantidade de C.Custo Lancados de DSR s/H.Atividade
Local aEncarDsr := {}  //-- Array com os Valores por c.custo de D.S.R.s/H.Extra
Local aEncarCom := {}  //--Array com os Valores por c.custo de D.S.R. s/Comissoes
Local aEncarPro := {}  //--Array com os Valores por c.custo de D.S.R. de Professor
Local aEncarHe 	:= {}  //--Array com os Valores por c.custo H.E.
Local aEncarHtv := {}  //--Array com os Valores por c.custo de D.S.R. s/Horas Atividade
Local aEncarHrDs:= {}
Local nQtd     	:= 0   //-- Quantidade de C.Custo Lancados
Local aEncar   	:= {}  //-- Array com os Valores por c.custo
Local nValTot  	:= 0   //-- Valor Total das Verbas 100%
Local nVlVerba 	:= 0
Local nHrVerba 	:= 0
Local nHrComp  	:= 0
Local nVlComp  	:= 0
Local nSmComp	:= 0
Local nValDiv  	:= 0
Local nHrsDiv  	:= 0
Local nSemDiv	:= 0
Local nLugar	:= 0
Local nQtdSem	:= 0

Local nP
Local cTip1		:= ""
Local cTip2		:= ""
Local cVerba	:= ""
Local cSeq		:= " "
Local dDtPgCc	:= Ctod("")
Local nZ		:= 0
Local n			:= 0
Local z			:= 0
Local j			:= 0
Local nV		:= 0
Local nC		:= 0
Local nR		:= 0    
Local nDSRProf  := 0
Local nHrsAtv   := 0
Local nBsDsHt	:= 0
Local nInss_b	:= 0
Local nAuxAt	:= 0
Local nAuxAc	:= 0
Local nBaseAt   := 0
Local nBaseAc   := 0
Local nGrvAt	:= 0
Local nGrvAc	:= 0
Local nPercAt	:= 0
Local nPercAc 	:= 0
Local nPosBas	:= 0
Local nPar   	:= 0
Local lCod317   := RetValSrv(aCodFol[317,1],Sra->Ra_Filial,"Rv_EncarCc")
Local lCod033   := RetValSrv(aCodFol[033,1],Sra->Ra_Filial,"Rv_EncarCc")
Local lDesc		:= .F.
Local lEmpCons	:= .F.
Local lRateio	:= .F.
Local lInfVerba := .F.
Local lTemInss	:= .F.
Local cNumId	:= ""
Local lRatInfo  := Type("P_LRATINFO") <> "U" .And. P_LRATINFO
Local dDataRefB := CToD("")

Private lItemClVl := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3"  

Default cVerbas     := "" //verbas especificas para realizar rateio
Default lRatM013	:= .F. // Rateio do cálculo da desoneração.

// Indica se ira utilizar o novo calculo de rateio de provisao
lProvPMes := cPaisLoc == "BRA" .and. GetMvRH("MV_RATPROV",,"N") == "S"

If lRatM013
	aEncar := aClone( aEncM013 )
Else
	//-- Montar o Array com os centro de custo das verbas de Base p/ Rateio
For nZ = 1 to Len(aPd)
	If Empty(cVerbas) .OR. (aPd[nZ,1] $ cVerbas)
		If aPd[nZ,9] # "D" .And. aPd[nZ,3] = cSemana
			If RetValSrv(aPd[nZ,1],Sra->Ra_Filial,"Rv_EncarCc") == "B"
				lDesc	:= RetValSrv(aPd[nZ,1], SRA->RA_FILIAL, "RV_TIPOCOD") $ "2/4"
				If lItemClVl
					nP := Ascan( aEncar,{ |x| aPd[nZ,2] = x[1] .and. aPd[nZ,13] == x[5] .and. aPd[nZ,14] == x[6] })
				Else
					nP := Ascan( aEncar,{ |x| aPd[nZ,2] = x[1] })
				EndIf							
				If nP == 0                                                
					If lItemClVl
						Aadd(aEncar,{ aPd[nZ,2], Iif( !lDesc, aPd[nZ,4], aPd[nZ,4] * (-1)), Iif( !lDesc, aPd[nZ,5], aPd[nZ,5] * (-1)), 0.00, aPd[nZ,13], aPd[nZ,14], aPd[nZ,7] })
					Else
						Aadd(aEncar,{ aPd[nZ,2], Iif( !lDesc, aPd[nZ,4], aPd[nZ,4] * (-1)), Iif( !lDesc, aPd[nZ,5], aPd[nZ,5] * (-1)), 0.00, aPd[nZ,7] })
					EndIf					
				Else
					aEncar[nP,2] += Iif( !lDesc, aPd[nZ,4], aPd[nZ,4] * (-1))
					aEncar[nP,3] += Iif( !lDesc, aPd[nZ,5], aPd[nZ,5] * (-1))
					If aPd[ nZ , 7 ] == "I" .And. RetValSrv(aPd[nZ,1], SRA->RA_FILIAL, "RV_HE") != "S"
						If lItemClVl .And. aEncar[ nP , 7 ] <> "I"
							aEncar [ nP , 7 ] := "I"
						ElseIf !lItemClVl .And. aEncar[ nP , 5 ] <> "I"
							aEncar [ nP , 5 ] := "I"
						EndIf					
					EndIf
				EndIf
			EndIf
			
			//-- Montar o Array com os c.custo das verbas de Base p/ DSR H.Extra
			If 	RetValSrv(aCodFol[035,1],Sra->Ra_Filial,"Rv_EncarCc") == "S" .And. ;
				RetValSrv(aPd[nZ,1],     Sra->Ra_Filial,"Rv_DsrHe")   == "S" .And. ;
				RetValSrv(aPd[nZ,1],     Sra->Ra_Filial,"Rv_RefFer")  # "S" .And. ;
				!(aPd[nZ,1] $ aCodFol[165,1]+","+aCodFol[347,1]+","+aCodFol[317,1]+","+If( SRA->RA_CATFUNC $ "I*J", aCodFol[033,1],"") )
				If lItemClVl
					nP := Ascan( aEncarDsr,{ |x| aPd[nZ,2] = x[1] .and. aPd[nZ,13] == x[5] .and. aPd[nZ,14] == x[6] })
				Else
					nP := Ascan( aEncarDsr,{ |x| aPd[nZ,2] = x[1]  })	
				EndIf	
				If nP == 0
					If lItemClVl
						Aadd(aEncarDsr,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00, aPd[nZ,13], aPd[nZ,14] })
					Else
						Aadd(aEncarDsr,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00 })
					EndIf					
				Else
					aEncarDsr[nP,2] += aPd[nZ,4]
					aEncarDsr[nP,3] += aPd[nZ,5]
				EndIf
			EndIf
			//-- Montar o Array com os c.custo das verbas de Base p/ DSR s/Comissoes   
			If RetValSrv(aCodFol[166,1],Sra->Ra_Filial,"Rv_EncarCc") == "S" .And. ;
			   RetValSrv(aPd[nZ,1],     Sra->Ra_Filial,"Rv_DsrHe")   == "S" .And. ;
			   RetValSrv(aPd[nZ,1],     Sra->Ra_Filial,"Rv_RefFer")  <> "S" .And. ;
			   aPd[nZ,1] $ aCodFol[165,1]+","+aCodFol[347,1]
				If lItemClVl
					nP := Ascan( aEncarCom,{ |x| aPd[nZ,2] = x[1] .and. aPd[nZ,13] == x[5] .and. aPd[nZ,14] == x[6] })
				Else
					nP := Ascan( aEncarCom,{ |x| aPd[nZ,2] = x[1]  })	
				EndIf	
				If nP == 0
					If lItemClVl
						Aadd(aEncarCom,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00, aPd[nZ,13], aPd[nZ,14] })
					Else
						Aadd(aEncarCom,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00 })
					EndIf					
				Else
					aEncarCom[nP,2] += aPd[nZ,4]
					aEncarCom[nP,3] += aPd[nZ,5]
				EndIf
			EndIf

			If RetValSrv(aPd[nZ,1],	SRA->RA_FILIAL, "RV_ENCARCC") == "S" .And. ;
			   RetValSrv(aPd[nZ,1], SRA->RA_FILIAL, "RV_HE")   == "S"
				If lItemClVl
					nP := Ascan( aEncarHE,{ |x| aPd[nZ,2] = x[1] .and. aPd[nZ,13] == x[5] .and. aPd[nZ,14] == x[6] })
				Else
					nP := Ascan( aEncarHE,{ |x| aPd[nZ,2] = x[1]  })	
				EndIf	
				If nP == 0
					If lItemClVl
						Aadd(aEncarHE,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00, aPd[nZ,13], aPd[nZ,14] })
					Else
						Aadd(aEncarHE,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00 })
					EndIf					
				Else
					aEncarHE[nP,2] += aPd[nZ,4]
					aEncarHE[nP,3] += aPd[nZ,5]
				EndIf
			EndIf

	   		//Tratamento efetuado apenas para Professor Mensalista e Aulista.
			If SRA->RA_CATFUNC $ "I*J"   
				//-- Montar o Array com os c.custo das verbas de Base p/ DSR s/Horas Atividade   
				If lCod317 == "S" .And. ;
				   RetValSRV(aPd[nZ,1],     Sra->Ra_Filial,"Rv_HrsAtiv") == "S" .And. ;   
				   RetValSRV(aPd[nZ,1],     Sra->Ra_Filial,"Rv_RefFer")  # "S"  
					If !(aPd[nZ,1] $ If( SRA->RA_CATFUNC $ "I*J", aCodFol[033,1],""))
						If lItemClVl
							nP := Ascan( aEncarHtv,{ |x| aPd[nZ,2] = x[1] .and. aPd[nZ,13] == x[5] .and. aPd[nZ,14] == x[6] })
						Else
							nP := Ascan( aEncarHtv,{ |x| aPd[nZ,2] = x[1]  })	
						EndIf	
						If nP == 0 
							If lItemClVl
								Aadd(aEncarHtv,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00, aPd[nZ,13], aPd[nZ,14] })
							Else
								Aadd(aEncarHtv,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00 })
							EndIf					
						Else
							aEncarHtv[nP,2] += aPd[nZ,4]
							aEncarHtv[nP,3] += aPd[nZ,5]
						EndIf
					Else
						nDSRProf += aPd[nZ,5]
					EndIf
				EndIf
				
				//-- Montar o Array com os c.custo das verbas de Base p/ DSR s/Professor   
				If lCod033 == "S" .And. ; 
				   RetValSRV(aPd[nZ,1],     Sra->Ra_Filial,"Rv_DsrProf") == "S" .And. ;
				   RetValSRV(aPd[nZ,1],     Sra->Ra_Filial,"Rv_RefFer")  # "S" 
					If !(aPd[nZ,1] $ aCodFol[317,1])
						If lItemClVl
							nP := Ascan( aEncarPro,{ |x| aPd[nZ,2] = x[1] .and. aPd[nZ,13] == x[5] .and. aPd[nZ,14] == x[6] })
						Else
							nP := Ascan( aEncarPro,{ |x| aPd[nZ,2] = x[1]  })	
						EndIf	
						If nP == 0
							If lItemClVl
								Aadd(aEncarPro,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00, aPd[nZ,13], aPd[nZ,14] })
							Else
								Aadd(aEncarPro,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00 })
							EndIf					
						Else
							aEncarPro[nP,2] += aPd[nZ,4]
							aEncarPro[nP,3] += aPd[nZ,5]
						EndIf
					Else
						nHrsAtv += aPd[nZ,5]
					EndIf
				EndIf
				
				
				//-- Montar o Array com os c.custo das verbas de Base p/ DSR s/Professor e Hora Atividade 
				If lCod033 == "S" .And. ; 
				   RetValSRV(aPd[nZ,1],     Sra->Ra_Filial,"Rv_DsrProf") == "S" .And. ;
				   lCod317 == "S" .And. ;
				   RetValSRV(aPd[nZ,1],     Sra->Ra_Filial,"Rv_HrsAtiv") == "S" .And. ;   
				   RetValSRV(aPd[nZ,1],     Sra->Ra_Filial,"Rv_RefFer")  # "S" 
					If !( aPd[nZ,1] $ aCodFol[317,1] + "*" + If( SRA->RA_CATFUNC $ "I*J", aCodFol[033,1],"") )
						If lItemClVl
							nP := Ascan( aEncarHrDs,{ |x| aPd[nZ,2] = x[1] .and. aPd[nZ,13] == x[5] .and. aPd[nZ,14] == x[6] })
						Else
							nP := Ascan( aEncarHrDs,{ |x| aPd[nZ,2] = x[1]  })	
						EndIf	
						If nP == 0
							If lItemClVl
								Aadd(aEncarHrDs,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00, aPd[nZ,13], aPd[nZ,14] })
							Else
								Aadd(aEncarHrDs,{ aPd[nZ,2], aPd[nZ,4], aPd[nZ,5], 0.00 })
							EndIf					
						Else
							aEncarHrDs[nP,2] += aPd[nZ,4]
							aEncarHrDs[nP,3] += aPd[nZ,5]
						EndIf
						nBsDsHt += aPd[nZ,5]
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
Next
EndIf
nQtd	:= Len(aEncar)
nQtdDsr := Len(aEncarDsr)
nQtdCom := Len(aEncarCom)
nQtdHE  := Len(aEncarHE)
nQtdHtv := Len(aEncarHtv)
nQtdPro := Len(aEncarPro)  

//---------------------------------------------------------------------------------//
// Quando nao houver lancamento de base para rateio, obtem percentuais cadastrados //
// na tabela RHQ - Programacao de Rateio.                                          //
//---------------------------------------------------------------------------------//  
If cPaisLoc == "BRA" .And. lProvPMes // Programacao de Rateio utilizada somente para o Brasil			
	fRateio( {} , 1 ) //Deleta registros de usuarios da tabela RHQ

	If nQtd > 0
	
		//--Verifica se possui alguma verba informada para rateio
		If lItemClVl
			lInfVerba := ( Ascan( aEncar,{ |x| x[7] == "I"  }) > 0 )
		Else
			lInfVerba := ( Ascan( aEncar,{ |x| x[5] == "I"  }) > 0 )
		EndIf					

        If SRA->RA_CATFUNC $ "I*J"
		//---------------------------------------------------------------------------------//                
		// Para funcionários categora I e J, obtem a informação do cadastro de programação //
		// de Rateio                                                                       //
		//---------------------------------------------------------------------------------//        
			fRateio( {} , 2 ) //Carrega a programação de Rateio     
			lRateio := .T.
		ElseIf SRA->RA_CATFUNC $ "C" .And. lInfVerba
		//---------------------------------------------------------------------------------//
		// Para funcionários Comissionistas,caso exista programação de rateio, considera-se//
		// que a verba não foi informada, para que o rateio seja efetuado de acordo com a  //
		// Programação - Tabela RHQ														   //	
		//---------------------------------------------------------------------------------//		
			fRateio( {} , 2 ) //Carrega a programação de Rateio
			lInfVerba := Empty(aRateio)
		EndIf
			
		//---------------------------------------------------------------------------------//
		// Quando nao houver lancamento de base para rateio, obtem percentuais cadastrados //
		// na tabela RHQ - Programacao de Rateio.                                          //
		//---------------------------------------------------------------------------------//			
		If !lInfVerba .and. ( !( SRA->RA_CATFUNC $ "I*J" ) .Or. (SRA->RA_CATFUNC $ "I*J" .And. Len(aRateio) > 0))
			fRateio( {} , 3 ) //Deleta registros de usuarios e busca dados
			If !Empty(aRateio)
				aEncar := {}
				For n := 1 to Len(aRateio)
				//--Desconsidera os registros de programacao de rateio originados dos 
				//--lancamentos do usuario.
					If aRateio[n,5] = "S"
						aAdd(aEncar,{aRateio[n,1],0,0,aRateio[n,4],aRateio[n,2],aRateio[n,3]})
					Else
						aRateio[n,7] := "D"
					EndIf
				Next n 
				nQtd := Len(aEncar)			
				lRateio := .T.
			Else
				//Se não existir percentual de rateio, ignora a programação
				nQtd := 0
				
				For n := 1 to Len(aEncar)
					If aEncar[n,4] > 0
						nQtd := Len(aEncar)
						Exit
					EndIf
				Next n
				If nQtd == 0
					aEncar := {}
				EndIf
			EndIf				
		Else
			//---------------------------------------------------------------//
			// Quando houver lancamento de base para rateio, grava registros //
			// na tabela RHQ - Programacao de Rateio.                        //
			//---------------------------------------------------------------//

			//--Achar o Total da Base de Encargos
			aEval(aEncar,{ |X| nValTot += X[3] })
	
			For n := 1  to nQtd
				aEncar[n,4] := aEncar[n,3] / nValTot				
				//--Quando for o mesmo valor 100 %
				If aEncar[n,4] = 1.00
					aEncar[n,4] := 100.000
				Else  
					fRateio(aEncar[n]) //Grava dados			
				EndIf
			Next n
		EndIf
		
		If nQtd > 0
	  			
			For Nr := 1 to Len(aPd)    
			
				//-- Verifica se a Verba deve ser Calculada por c.custo e nao esta Deletada
				If aPd[Nr,9]  # "D" .And. aPd[nR,3] == cSemana .And. ( lRatInfo .Or. ! aPd[nR,7] $ "I|G" ) .And. ;
				( RetValSRV(aPd[Nr, 1], SRA->RA_FILIAL, "RV_ENCARCC") == "S" ) .Or.;
				( lRateio .And. RetValSRV(aPd[Nr,1],SRA->RA_FILIAL,"RV_ENCARCC") == "B" )
					
					nVlVerba := nVlComp := nHrVerba := nHrComp := nQtdSem := nSmComp := 0.00
					cVerba   := aPd[Nr,1]
					cTip2	  := aPd[Nr,7]
					nPar	 := aPd[Nr,8]
	
					If cVerba $ aCodFol[13,1] + "/" + aCodFol[14,1]
						//INSS será rateado conforme e-Social, somando as verbas de cada Centro de Custos, ao final do rateio
						nBaseAt += If(cVerba == aCodFol[13,1], aPd[Nr,5],0)
						nBaseAc += If(cVerba == aCodFol[14,1], aPd[Nr,5],0)
						lTemInss 	:= .T.
						aPd[Nr,9] 	:= "D"						
						Loop 
					EndIf

					//-- Achar o valor total da Verba a ser Calc. por C.Custo
					For nV := 1 To Len(aPd)
						If cVerba == aPd[nV,1] .And. aPd[nV,9] # 'D' .And. aPd[nV,3] == cSemana .And. ( ( lRatInfo .Or. ! aPd[nR,7] $ "I|G" ) .AND. cTip2 == aPd[Nv,7])
							nVlVerba  += aPd[nV,5]
							nHrVerba  += aPd[nV,4]
							nQtdSem	  += aPd[nV,12]
							cTip1		:= aPd[nV,6]		//Tipo da verba( V,H,D )
							cTip2     	:= aPd[nV,7]       	//--> Origem da Verba
							nPar		:= aPd[nV,8]
							dDtPgCc	  	:= aPd[nV,10]		//--> Data Pagto Origem
							cSeq		:= aPd[nV,11]		//--> Sequencia
							cNumID		:= aPd[nV,15]
							lEmpCons	:= aPd[nV,16]		//--> Se é verba de emprestimo consignado
							dDataRefB   := aPd[nV,18]       //--> Data de referência anterior
							aPd[nV,9] 	:= "D"
							//Tratamento para Categorias I,J -> qdo a verba é rateada e a qtde de horas está como o total do mês
							//para todas as verbas. Considerar o total apenas para a primeira verba, ou seja, subtrair o total das demais verbas iguais
							//para que a quantidade de horas seja lançada corretamente.
							If SRA->RA_CATFUNC $ "I*J" .And. nV > 1 .And. (cVerba == aPd[nV -1, 1] .And. aPd[nV, 4] == 30  .And. aPd[nV-1, 4] == 30 )
								nHrVerba  -= aPd[nV,4]
							EndIf 
						EndIf
					Next nV

					If cVerba <> aCodfol[47,1]
						//-- Divisao da Verba para cada c.custo
						For Nc := 1 to nQtd
							If Nc # nQtd
								nValDiv := Round(nVlVerba * aEncar[Nc,4],2)
								nHrsDiv := Round(nHrVerba * aEncar[Nc,4],2)
								nSemDiv := Round(nQtdSem  * aEncar[Nc,4],2)
								nVlComp += nValDiv
								nHrComp += nHrsDiv
								nSmComp += nSemDiv
							Else
								nValDiv := nVlVerba - nVlComp
								nHrsDiv := nHrVerba - nHrComp
								nSemDiv	:= nQtdSem  - nSmComp
							EndIf
											
							If lItemClVl
								fMatriz(cVerba,nValDiv,nHrsDiv,,aEncar[Nc,1],cTip1,cTip2,,,dDtPgCc,.T.,cSeq,nSemDiv,aEncar[Nc,5],aEncar[Nc,6],cNumID, lEmpCons,,dDataRefB)  
							Else
								fMatriz(cVerba,nValDiv,nHrsDiv,,aEncar[Nc,1],cTip1,cTip2,nPar,,dDtPgCc,.T.,cSeq,nSemDiv,,,cNumID, lEmpCons,,dDataRefB)
							EndIf
						Next Nc
					EndIf
				EndIf
			Next Nr

			For Nr := 1 to Len(aPd)
				//Rateia apenas a verba de liquido, com base em todas as outras verbas que foram rateadas no laço de cima
				If aPd[Nr,1] == aCodfol[47,1]
			
					//-- Verifica se a Verba deve ser Calculada por c.custo e nao esta Deletada
					If aPd[Nr,9]  # "D" .And. aPd[nR,3] == cSemana .And. ( lRatInfo .Or. ! aPd[nR,7] $ "I|G" ) .And. ;
					( RetValSRV(aPd[Nr, 1], SRA->RA_FILIAL, "RV_ENCARCC") == "S" ) .Or.;
					( lRateio .And. RetValSRV(aPd[Nr,1],SRA->RA_FILIAL,"RV_ENCARCC") == "B" )
						
						nVlVerba := nVlComp := nHrVerba := nHrComp := nQtdSem := nSmComp := 0.00
						cVerba   := aPd[Nr,1]
						cTip2	  := aPd[Nr,7]
						nPar	 := aPd[Nr,8]
						
						nValDiv := 0
						For Nc := 1 to nQtd
							nValDiv := Min(0,nValDiv) //Se negativou o liquido anterior, desconta do atual
							If Nc == 1 //Verifica se existem verbas vindas do fechamento, que não esta em nenhum centro de custos, e soma no nValDiv
								For Nv := 1 to Len(aPd)
									If aPd[Nv,7] == "F"
										If lItemClVl
											If ( aScan(aEncar, {|x| x[1]+x[5]+x[6] == aPd[Nv,2]+aPd[Nv,13]+aPd[Nv,14] }) ) == 0
												SomaInc(aPd[Nv],0,@nValDiv,,,,,,.F.,aCodFol)
											EndIf
										Else
											If ( aScan(aEncar ,{ |x| x[1] == aPd[Nv,2] } ) ) == 0
												SomaInc(aPd[Nv],0,@nValDiv,,,,,,.F.,aCodFol)
											EndIf
										EndIf
									EndIf
								Next Nv							
							EndIf							
							If lItemClVl
								Aeval( aPd ,{ |x| If(x[2]+x[13]+x[14] == aEncar[Nc,1]+aEncar[Nc,5]+aEncar[Nc,6], SomaInc(x,0,@nValDiv,,,,,,.F.,aCodFol), Nil) } )
							Else
								Aeval( aPd ,{ |x| If(x[2] == aEncar[Nc,1], SomaInc(x,0,@nValDiv,,,,,,.F.,aCodFol), Nil) } )
							EndIf
			
							If lItemClVl
								fMatriz(cVerba,nValDiv,0,,aEncar[Nc,1],cTip1,cTip2,,,dDtPgCc,.T.,cSeq,nSemDiv,aEncar[Nc,5],aEncar[Nc,6],cNumID)  
							Else
								fMatriz(cVerba,nValDiv,0,,aEncar[Nc,1],cTip1,cTip2,nPar,,dDtPgCc,.T.,cSeq,nSemDiv,,,cNumID)    
							EndIf
						Next Nc
					EndIf
				EndIf
			Next Nr	
			
			If lTemInss

				nPercAt := nBaseAt / ( nBaseAc + nBaseAt ) //Percentual até o limite
				nPercAc := nBaseAc / ( nBaseAc + nBaseAt ) //Percentual acima do limite
				nPosBas := aScan(aPd, {|x| x[1] == aCodFol[13,1]})			
			
				For Nr := 1 to nQtd
					nInss_b := 0
					If lItemClVl
						Aeval( aPd ,{ |X| If(x[2]+x[13]+x[14] == aEncar[Nr,1]+aEncar[Nr,5]+aEncar[Nr,6], SomaInc(X, 4, @nInss_b, 12, "N", Nil, Nil, Nil, Nil, aCodfol), Nil) })
						If nPercAc > 0
							If Nr < nQtd
								nAuxAt	:= Round( nInss_b * nPercAt , 2 )
								nAuxAc 	:= Round( nInss_b * nPercAc , 2 )
								nGrvAt 	+= nAuxAt
								nGrvAc 	+= nAuxAc
							Else
								nAuxAt	:= nBaseAt - nGrvAt
								nAuxAc 	:= nBaseAc - nGrvAc
							EndIf
							fMatriz(aCodFol[13,1],nAuxAt,aPd[nPosBas,4],,aEncar[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],,,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,aEncar[Nr,5],aEncar[Nr,6],aPd[nPosBas,15], .F.,,aPd[nPosBas,18])  
							fMatriz(aCodFol[14,1],nAuxAc,aPd[nPosBas,4],,aEncar[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],,,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,aEncar[Nr,5],aEncar[Nr,6],aPd[nPosBas,15], .F.,,aPd[nPosBas,18])  
						Else
							fMatriz(aCodFol[13,1],nInss_b,aPd[nPosBas,4],,aEncar[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],,,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,aEncar[Nr,5],aEncar[Nr,6],aPd[nPosBas,15], .F.,,aPd[nPosBas,18])  
						EndIf
					Else
						Aeval( aPd ,{ |X| If(x[2] == aEncar[Nr,1], SomaInc(X, 4, @nInss_b, 12, "N", Nil, Nil, Nil, Nil, aCodfol), Nil) })
						If nPercAc > 0
							If Nr < nQtd
								nAuxAt	:= Round( nInss_b * nPercAt , 2 )
								nAuxAc 	:= Round( nInss_b * nPercAc , 2 )
								nGrvAt 	+= nAuxAt
								nGrvAc 	+= nAuxAc
							Else
								nAuxAt	:= nBaseAt - nGrvAt
								nAuxAc 	:= nBaseAc - nGrvAc
							EndIf
							fMatriz(aCodFol[13,1],nAuxAt,aPd[nPosBas,4],,aEncar[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],aPd[nPosBas,8],,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,,,aPd[nPosBas,15], .F.,,aPd[nPosBas,18])
							fMatriz(aCodFol[14,1],nAuxAc,aPd[nPosBas,4],,aEncar[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],aPd[nPosBas,8],,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,,,aPd[nPosBas,15], .F.,,aPd[nPosBas,18])
						Else
							fMatriz(aCodFol[13,1],nInss_b,aPd[nPosBas,4],,aEncar[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],aPd[nPosBas,8],,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,,,aPd[nPosBas,15], .F.,,aPd[nPosBas,18])
						EndIf
					EndIf
				Next Nr
			EndIf

			If aScan(aPd, {|x| x[1] == aCodfol[47,1] .And. x[9] == "D" }) > 0
				// Tratar a verba de Liquido
				nValDiv := 0
				For Nc := 1 to nQtd
					nValDiv := Min(0,nValDiv) //Se negativou o liquido anterior, desconta do atual
					If Nc == 1 //Verifica se existem verbas vindas do fechamento, que não esta em nenhum centro de custos, e soma no nValDiv
						For Nr := 1 to Len(aPd)
							If aPd[nR,7] == "F"
								If lItemClVl
									If ( aScan(aEncar, {|x| x[1]+x[5]+x[6] == aPd[Nr,2]+aPd[Nr,13]+aPd[Nr,14] }) ) == 0
										SomaInc(aPd[Nr],0,@nValDiv,,,,,,.F.,aCodFol)
									EndIf
								Else
									If ( aScan(aEncar ,{ |x| x[1] == aPd[Nr,2] } ) ) == 0
										SomaInc(aPd[Nr],0,@nValDiv,,,,,,.F.,aCodFol)
									EndIf
								EndIf
							EndIf
						Next Nr							
					EndIf
					If lItemClVl
						Aeval( aPd ,{ |x| If(x[2]+x[13]+x[14] == aEncar[Nc,1]+aEncar[Nc,5]+aEncar[Nc,6], SomaInc(x,0,@nValDiv,,,,,,.F.,aCodFol), Nil) } )
					Else
						Aeval( aPd ,{ |x| If(x[2] == aEncar[Nc,1], SomaInc(x,0,@nValDiv,,,,,,.F.,aCodFol), Nil) } )
					EndIf
	
					If lItemClVl
						fMatriz(aCodfol[0047,1],nValDiv,nHrsDiv,,aEncar[Nc,1],cTip1,cTip2,,,dDtPgCc,.T.,cSeq,nSemDiv,aEncar[Nc,5],aEncar[Nc,6],cNumID)  
					Else
						fMatriz(aCodfol[0047,1],nValDiv,nHrsDiv,,aEncar[Nc,1],cTip1,cTip2,nPar,,dDtPgCc,.T.,cSeq,nSemDiv,,,cNumID)    
					EndIf
				Next Nc
			EndIf
		ElseIf nQtdHE > 0
			If RetValSRV(aCodFol[13,1], SRA->RA_FILIAL, "RV_ENCARCC") == "S"
				Aeval( aPd, { |x| If(x[1] == aCodFol[13,1] .And. x[9] # "D" .And. x[3] == cSemana .And. x[7] # 'F' .And. (lRatInfo .Or. !x[7] $ "I|G"), nBaseAt += x[5], Nil) } )
				Aeval( aPd, { |x| If(x[1] == aCodFol[13,1] .And. x[9] # "D" .And. x[3] == cSemana .And. x[7] # 'F' .And. (lRatInfo .Or. !x[7] $ "I|G"), x[9] := "D", Nil) } )
				Aeval( aPd, { |x| If(x[1] == aCodFol[14,1] .And. x[9] # "D" .And. x[3] == cSemana .And. x[7] # 'F' .And. (lRatInfo .Or. !x[7] $ "I|G"), nBaseAc += x[5], Nil) } )
				Aeval( aPd, { |x| If(x[1] == aCodFol[14,1] .And. x[9] # "D" .And. x[3] == cSemana .And. x[7] # 'F' .And. (lRatInfo .Or. !x[7] $ "I|G"), x[9] := "D", Nil) } )

				nPercAt := nBaseAt / ( nBaseAc + nBaseAt ) //Percentual até o limite
				nPercAc := nBaseAc / ( nBaseAc + nBaseAt ) //Percentual acima do limite
				nPosBas := aScan(aPd, {|x| x[1] == aCodFol[13,1]})			

				If nPosBas > 0
					For Nr := 1 to nQtdHE
						nInss_b := 0
						If lItemClVl
							Aeval( aPd ,{ |X| If(x[2]+x[13]+x[14] == aEncarHe[Nr,1]+aEncarHe[Nr,5]+aEncarHe[Nr,6], SomaInc(X,4,@nInss_b,12,"N",,,,,aCodfol), Nil) })
							If nPercAc > 0
								If Nr < nQtdHE
									nAuxAt	:= Round( nInss_b * nPercAt , 2 )
									nAuxAc 	:= Round( nInss_b * nPercAc , 2 )
									nGrvAt 	+= nAuxAt
									nGrvAc 	+= nAuxAc
								Else
									nAuxAt	:= nBaseAt - nGrvAt
									nAuxAc 	:= nBaseAc - nGrvAc
								EndIf
								fMatriz(aCodFol[13,1],nAuxAt,aPd[nPosBas,4],,aEncarHe[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],,,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,aEncarHe[Nr,5],aEncarHe[Nr,6],aPd[nPosBas,15], .F.,,aPd[nPosBas,18])  
								fMatriz(aCodFol[14,1],nAuxAc,aPd[nPosBas,4],,aEncarHe[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],,,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,aEncarHe[Nr,5],aEncarHe[Nr,6],aPd[nPosBas,15], .F.,,aPd[nPosBas,18])  
							Else
								fMatriz(aCodFol[13,1],nInss_b,aPd[nPosBas,4],,aEncarHe[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],,,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,aEncarHe[Nr,5],aEncarHe[Nr,6],aPd[nPosBas,15], .F.,,aPd[nPosBas,18])  
							EndIf
						Else
							Aeval( aPd ,{ |X| If(x[2] == aEncarHe[Nr,1], SomaInc(X,4,@nInss_b,12,"N",,,,,aCodfol), Nil) })
							If nPercAc > 0
								fMatriz(aCodFol[13,1],Round(( nInss_b * nPercAt ),2),aPd[nPosBas,4],,aEncarHe[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],aPd[nPosBas,8],,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,,,aPd[nPosBas,15], .F.,,aPd[nPosBas,18])
								fMatriz(aCodFol[14,1],Round(( nInss_b * nPercAC ),2),aPd[nPosBas,4],,aEncarHe[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],aPd[nPosBas,8],,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,,,aPd[nPosBas,15], .F.,,aPd[nPosBas,18])
							Else
								fMatriz(aCodFol[13,1],nInss_b,aPd[nPosBas,4],,aEncarHe[Nr,1],aPd[nPosBas,6],aPd[nPosBas,7],aPd[nPosBas,8],,aPd[nPosBas,10],.T.,aPd[nPosBas,11],,,,aPd[nPosBas,15], .F.,,aPd[nPosBas,18])
							EndIf
						EndIf
					Next Nr
				EndIf

				If aScan(aPd, {|x| x[1] == aCodfol[47,1] .And. x[9] == "D" }) > 0
					// Tratar a verba de Liquido
					nValDiv := 0
					For Nc := 1 to nQtdHE
						nValDiv := Min(0,nValDiv) //Se negativou o liquido anterior, desconta do atual
						If Nc == 1 //Verifica se existem verbas vindas do fechamento, que não esta em nenhum centro de custos, e soma no nValDiv
							For Nr := 1 to Len(aPd)
								If aPd[nR,7] == "F"
									If lItemClVl
										If ( aScan(aEncarHe, {|x| x[1]+x[5]+x[6] == aPd[Nr,2]+aPd[Nr,13]+aPd[Nr,14] }) ) == 0
											SomaInc(aPd[Nr],0,@nValDiv,,,,,,.F.,aCodFol)
										EndIf
									Else
										If ( aScan(aEncarHe ,{ |x| x[1] == aPd[Nr,2] } ) ) == 0
											SomaInc(aPd[Nr],0,@nValDiv,,,,,,.F.,aCodFol)
										EndIf
									EndIf
								EndIf
							Next Nr							
						EndIf
						If lItemClVl
							Aeval( aPd ,{ |x| If(x[2]+x[13]+x[14] == aEncarHe[Nc,1]+aEncarHe[Nc,5]+aEncarHe[Nc,6], SomaInc(x,0,@nValDiv,,,,,,.F.,aCodFol), Nil) } )
						Else
							Aeval( aPd ,{ |x| If(x[2] == aEncarHe[Nc,1], SomaInc(x,0,@nValDiv,,,,,,.F.,aCodFol), Nil) } )
						EndIf
		
						If lItemClVl
							fMatriz(aCodfol[0047,1],nValDiv,nHrsDiv,,aEncarHe[Nc,1],cTip1,cTip2,,,dDtPgCc,.T.,cSeq,nSemDiv,aEncarHe[Nc,5],aEncarHe[Nc,6],cNumID)  
						Else
							fMatriz(aCodfol[0047,1],nValDiv,nHrsDiv,,aEncarHe[Nc,1],cTip1,cTip2,nPar,,dDtPgCc,.T.,cSeq,nSemDiv,,,cNumID)    
						EndIf
					Next Nc
				EndIf
			EndIf		
		EndIf
	EndIf 
		
	//-------------------------------------------------------------//
	// Apaga da tabela RHQ os registros originados dos lancamentos //
	// do usuario, quando esses lancamentos forem descartados.     //
	//-------------------------------------------------------------//
	For n:=1 to Len(aRateio)
		If aRateio[n,7] = "D"
			RHQ->(DbGoTo(aRateio[n,6]))
			RecLock("RHQ",.F.)
			RHQ->( dbDelete() )
			RHQ->( MsUnlock() )			
		EndIf
	Next n
	
Else

	If nQtd > 0
		//--Achar o Total da Base de Encargos
		aEval(aEncar,{ |X| nValTot += X[3] })
	
		For n := 1  to nQtd
			aEncar[n,4] := aEncar[n,3] / nValTot				
			//--Quando for o mesmo valor 100 %
			If aEncar[n,4] = 1.00
				aEncar[n,4] := 100.000
			EndIf
		Next n
	
		For Nr := 1 to Len(aPd)
				
			//-- Verifica se a Verba deve ser Calculada por c.custo e nao esta Deletada
			If aPd[Nr,9]  # "D" .And. aPd[nR,3] == cSemana .And. ;
			( !( aPd[Nr,1] $ aCodFol[035,1] + "*" + aCodFol[166,1] + "*" + aCodFol[317,1] + "*" + If( SRA->RA_CATFUNC $ "I*J", aCodFol[033,1],"") ) .And.;
				 RetValSrv(aPd[Nr,1],Sra->Ra_Filial,"Rv_EncarCc") = "S" ) .or. ( lRateio .And. RetValSRV(aPd[Nr,1],Sra->Ra_Filial,"Rv_EncarCc") == "B" )
	
				nVlVerba := nVlComp := nHrVerba := nHrComp := 0.00
				cVerba   := aPd[Nr,1]
				cTip2	  := aPd[Nr,7]
				
				//-- Achar o valor total da Verba a ser Calc. por C.Custo
				For nV := 1 To Len(aPd)
					If cVerba == aPd[nV,1] .And. aPd[nV,9] # 'D' .And. aPd[nV,3] == cSemana .And. (lRatInfo .Or. ! aPd[nV,7] $ "I|G" .and. cTip2 == aPd[nV,7])
						nVlVerba  += aPd[nV,5]
						nHrVerba  += aPd[nV,4]
						cTip1		:= aPd[nV,6]		//Tipo da verba( V,H,D )
						cTip2     	:= aPd[nV,7]		//--> Origem da Verba
						dDtPgCc	  	:= aPd[nV,10]		//--> Data Pagto Origem
						cSeq		:= aPd[nV,11]		//--> Sequencia
						cNumID		:= aPd[nV,15]		//--> Identificador
						lEmpCons	:= aPd[nV,16]		//--> Se é verba de emprestimo consignado
						dDataRefB   := aPd[nV,18]       //--> Data de referência anterior
						aPd[nV,9] 	:= "D"
					EndIf
				Next nV
				
				//-- Divisao da Verba para cada c.custo
				For Nc := 1 to nQtd
					If Nc # nQtd
						nValDiv := Round(nVlVerba * aEncar[Nc,4],2)
						nHrsDiv := Round(nHrVerba * aEncar[Nc,4],2)
						nVlComp += nValDiv
						nHrComp += nHrsDiv
					Else
						nValDiv := nVlVerba - nVlComp
						nHrsDiv := nHrVerba - nHrComp
					EndIf  
	
					If lItemClVl
						fMatriz(cVerba,nValDiv,nHrsDiv,,aEncar[Nc,1],cTip1,cTip2,,,dDtPgCc,.T.,cSeq,,aEncar[Nc,5],aEncar[Nc,6],cNumID, lEmpCons,,dDataRefB)
					Else
						fMatriz(cVerba,nValDiv,nHrsDiv,,aEncar[Nc,1],cTip1,cTip2,,,dDtPgCc,.T.,cSeq,,,,cNumID, lEmpCons,,dDataRefB)
					EndIf
				Next Nc
			EndIf
		Next Nr
	EndIf
EndIf 

nValTot := 0

If nQtdDsr > 0 .And. !lProvPMes//-- Total de C.Custo de DSR s/ H.Extra
	//--Achar o Total da Base de Encargos
	aEval(aEncarDsr,{ |X| nValTot += X[3] })
	
	//--Gravar o Percentual de cada C.Custo lancado
	For n := 1  to nQtdDsr
		aEncarDsr[n,4] := aEncarDsr[n,3] / nValTot
		//--Quando for o mesmo valor 100 %
		If aEncarDsr[n,4] = 1.00
			aEncarDsr[n,4] := 100.000
		EndIf
	Next n
	
	nLugar := Ascan( aPd,{ |x| aCodFol[035,1] == x[1] })
	If nLugar > 0
		For Nr := nLugar to Len(aPd)
			//-- Verifica se a Verba deve ser Calculada por c.custo e nao esta Deletada
			If aPd[Nr,9]  # "D" .And. aPd[Nr,1] == aCodFol[035,1] .And. aPd[Nr,3] = cSemana
				nVlVerba := nVlComp := nHrVerba := nHrComp := 0.00
				cVerba   := aPd[Nr,1]
				cTip2	  := aPd[Nr,7]
				
				//-- Achar o valor total da Verba a ser Calc. por C.Custo
				For nV := 1 To Len(aPd)
					If cVerba == aPd[nV,1] .And. aPd[nV,9] # 'D' .And. aPd[nV,3] = cSemana .and. (aPd[nV,7] != "I" .and. cTip2 == aPd[nV,7])
						nVlVerba  	+= aPd[nV,5]
						nHrVerba  	+= aPd[nV,4]
						cTip1     	:= aPd[nV,6]          //--> Tipo da Verba( V,H,D )
						cTip2     	:= aPd[nV,7]          //--> Origem da Verba
						dDtPgCc		:= aPd[nV,10]			//--> Data Pagto de Origem
						aPd[nV,9] 	:= "D"
					EndIf
				Next nV
				
				//-- Divisao da Verba para cada c.custo
				For Nc := 1 to nQtdDsr
					If Nc # nQtdDsr
						nValDiv := Round(nVlVerba * aEncarDsr[Nc,4],2)
						nHrsDiv := Round(nHrVerba * aEncarDsr[Nc,4],2)
						nVlComp += nValDiv
						nHrComp += nHrsDiv
					Else
						nValDiv := nVlVerba - nVlComp
						nHrsDiv := nHrVerba - nHrComp
					EndIf
					If lItemClVl
						fMatriz(cVerba,nValDiv,nHrsDiv, ,aEncarDsr[Nc,1],cTip1,cTip2 , , ,dDtPgCc,.T.,,,aEncarDsr[Nc,5],aEncarDsr[Nc,6])
					Else
						fMatriz(cVerba,nValDiv,nHrsDiv, ,aEncarDsr[Nc,1],cTip1,cTip2 , , ,dDtPgCc,.T.)
					EndIf		
				Next Nc
			EndIf
		Next Nr
	EndIf
EndIf
nValTot:= 0 

If nQtdCom > 0 .And. !lProvPMes  //-- Total de C.Custo de DSR s/ Comissao
	//--Achar o Total da Base de Encargos
	aEval(aEncarCom,{ |X| nValTot += X[3] })
	
	//--Gravar o Percentual de cada C.Custo lancado
	For n := 1  to nQtdCom
		aEncarCom[n,4] := aEncarCom[n,3] / nValTot
		//--Quando for o mesmo valor 100 %
		If aEncarCom[n,4] = 1.00
			aEncarCom[n,4] := 100.000
		EndIf
	Next n
	
	nLugar := Ascan( aPd,{ |x| aCodFol[166,1] == x[1] })
	If nLugar > 0
		For Nr := nLugar to Len(aPd)
			//-- Verifica se a Verba deve ser Calculada por c.custo e nao esta Deletada
			If aPd[Nr,9]  # "D" .And. aPd[Nr,1] == aCodFol[166,1] .And. aPd[Nr,3] = cSemana
				nVlVerba := nVlComp := nHrVerba := nHrComp := 0.00
				cVerba   := aPd[Nr,1]
				cTip2	  := aPd[Nr,7]
				
				//-- Achar o valor total da Verba a ser Calc. por C.Custo
				For nV := 1 To Len(aPd)
					If cVerba == aPd[nV,1] .And. aPd[nV,9] # 'D' .And. aPd[nV,3] = cSemana .AND. (aPd[nV,7] != "I" .and. cTip2 == aPd[nV,7])
						nVlVerba  	+= aPd[nV,5]
						nHrVerba  	+= aPd[nV,4]
						cTip1     	:= aPd[nV,6]          //--> Tipo da Verba( V,H,D )
						cTip2     	:= aPd[nV,7]          //--> Origem da Verba
						dDtPgCc		:= aPd[nV,10]		   //--> Data Pagto de Origem
						aPd[nV,9] 	:= "D"
					EndIf
				Next nV
				
				//-- Divisao da Verba para cada c.custo
				For Nc := 1 to nQtdCom
					If Nc # nQtdCom
						nValDiv := Round(nVlVerba * aEncarCom[Nc,4], MsDecimais(1))
						nHrsDiv := Round(nHrVerba * aEncarCom[Nc,4],2)
						nVlComp += nValDiv
						nHrComp += nHrsDiv
					Else
						nValDiv := nVlVerba - nVlComp
						nHrsDiv := nHrVerba - nHrComp
					EndIf
					If lItemClVl
						fMatriz(cVerba,nValDiv,nHrsDiv, ,aEncarCom[Nc,1],cTip1,cTip2 , , ,dDtPgCc,.T.,,,aEncarCom[Nc,5],aEncarCom[Nc,6])
					Else
						fMatriz(cVerba,nValDiv,nHrsDiv, ,aEncarCom[Nc,1],cTip1,cTip2 , , ,dDtPgCc,.T.)
					EndIf		
				Next Nc
			EndIf
		Next Nr
	EndIf
EndIf  

nValTot:= 0 

If nQtdHtv > 0 .And. !lProvPMes //-- Total de C.Custo de DSR s/ Horas Atividade
	
	//--Achar o Total da Base de Encargos
	aEval(aEncarHtv,{ |X| nValTot += X[3] })

	//id.033 com 'S' p/ horas atividade e id.317 com 'N' p/ DSR
	lRecProf := lRecriaDsr .And.	RetValSRV(aCodFol[317,1],Sra->Ra_Filial,"Rv_DsrProf") == "N" .And.;
									RetValSRV(aCodFol[033,1],Sra->Ra_Filial,"Rv_HrsAtiv") == "S"
	If lRecProf
		//--Achar o Total da Base de Encargos
		nBsDProf := 0
		aEval(aEncarPro,{ |X| nBsDProf += X[3] })
		nDSRProf := nBsDsHt / nBsDProf  * nDSRProf
	EndIf
	
	If nDSRProf > 0
		nValTot += nDSRProf
		
		aPerc	:= {}
		nTDsrH	:= 0
		
		If lRecProf // .And. id.033 com 'S' p/ horas atividade e id.317 com 'N' p/ DSR
			aEncarAux := aClone(aEncarHrDs)
		Else
			aEncarAux := aClone(aEncarPro)
		EndIf
		
		//--Filtro dos valores das horas atividade dos c.custo que tem DSR
		For j := 1 To Len(aEncarHtv)
			If ( nPos := aScan( aEncarAux, { |x| x[1] == aEncarHtv[j,1] } ) ) > 0
				aAdd( aPerc, { aEncarAux[nPos,1], aEncarAux[nPos,3] } )
			EndIf
		Next
		
		//--Soma do valor do DSR distribuido por c.custo ao array das Horas Atividade,
		//--de acordo com o percentual de distribuicao do DSR por c.custo
		aEval( aPerc, { |x| nTDsrH += x[2] } )
		
		For z := 1 To Len(aPerc)
			aAdd( aPerc[z], aPerc[z,2] / nTDsrH * nDSRProf )
			If ( nPos := aScan( aEncarHtv, { |x| x[1] == aPerc[z,1] } ) ) > 0
				aEncarHtv[nPos,3] += aPerc[z,3]
			EndIf
		Next
	EndIf
	
	//--Gravar o Percentual de cada C.Custo lancado
	For n := 1  to nQtdHtv
		aEncarHtv[n,4] := aEncarHtv[n,3] / nValTot

		//--Quando for o mesmo valor 100 %
		If aEncarHtv[n,4] = 1.00
			aEncarHtv[n,4] := 100.000
		EndIf
	Next n
	
	nLugar := Ascan( aPd,{ |x| aCodFol[317,1] == x[1] })
	If nLugar > 0
		For Nr := nLugar to Len(aPd)
			//-- Verifica se a Verba deve ser Calculada por c.custo e nao esta Deletada
			If aPd[Nr,9]  # "D" .And. aPd[Nr,1] == aCodFol[317,1] .And. aPd[Nr,3] = cSemana
				nVlVerba := nVlComp := nHrVerba := nHrComp := 0.00
				cVerba   := aPd[Nr,1]
				cTip2	  := aPd[Nr,7]
				
				//-- Achar o valor total da Verba a ser Calc. por C.Custo
				For nV := 1 To Len(aPd)
					If cVerba == aPd[nV,1] .And. aPd[nV,9] # 'D' .And. aPd[nV,3] = cSemana .and. (aPd[nV,7] != "I" .and. cTip2 == aPd[nV,7])
						nVlVerba  	+= aPd[nV,5]
						nHrVerba  	+= aPd[nV,4]
						cTip1     	:= aPd[nV,6]          //--> Tipo da Verba( V,H,D )
						cTip2     	:= aPd[nV,7]          //--> Origem da Verba
						dDtPgCc		:= aPd[nV,10]		   //--> Data Pagto de Origem
						aPd[nV,9] 	:= "D"
					EndIf
				Next nV
				
				//-- Divisao da Verba para cada c.custo
				For Nc := 1 to nQtdHtv
					If Nc # nQtdHtv
						nValDiv := Round(nVlVerba * aEncarHtv[Nc,4], MsDecimais(1))
						nHrsDiv := Round(nHrVerba * aEncarHtv[Nc,4],2)
						nVlComp += nValDiv
						nHrComp += nHrsDiv
					Else
						nValDiv := nVlVerba - nVlComp
						nHrsDiv := nHrVerba - nHrComp
					EndIf
					If lItemClVl
						fMatriz(cVerba,nValDiv,nHrsDiv, ,aEncarHtv[Nc,1],cTip1,cTip2 , , ,dDtPgCc,.T.,,,aEncarHtv[Nc,5],aEncarHtv[Nc,6])
					Else
						fMatriz(cVerba,nValDiv,nHrsDiv, ,aEncarHtv[Nc,1],cTip1,cTip2 , , ,dDtPgCc,.T.)
					EndIf		
				Next Nc
			EndIf
		Next Nr
	EndIf
EndIf 

nValTot:= 0 

If nQtdPro > 0 .And. !lProvPMes //-- Total de C.Custo de DSR s/ Professor
	//--Achar o Total da Base de Encargos
	aEval(aEncarPro,{ |X| nValTot += X[3] })
	
	//id.033 com 'N' p/ horas atividade e id.317 com 'S' p/ DSR
	lRecProf := lRecriaDsr .And.	RetValSRV(aCodFol[317,1],Sra->Ra_Filial,"Rv_DsrProf") == "S" .And.;
									RetValSRV(aCodFol[033,1],Sra->Ra_Filial,"Rv_HrsAtiv") == "N"
									
	If lRecProf // .And. id.033 com 'S' p/ horas atividade e id.317 com 'N' p/ DSR
		//--Achar o Total da Base de Encargos
		nBsDProf := 0
		aEval(aEncarHtv,{ |X| nBsDProf += X[3] })
		nDSRProf := nBsDsHt / nBsDProf  * nHrsAtv
	EndIf
	
	If nHrsAtv > 0
		nValTot += nHrsAtv
		
		aPerc	:= {}
		nTDsrH	:= 0
		
		If lRecProf // .And. id.033 com 'S' p/ horas atividade e id.317 com 'N' p/ DSR
			aEncarAux := aClone(aEncarHrDs)
		Else
			aEncarAux := aClone(aEncarHtv)
		EndIf
		
		//--Filtro dos valores das horas atividade dos c.custo que tem DSR
		For j := 1 To Len(aEncarPro)
			If ( nPos := aScan( aEncarHrDs, { |x| x[1] == aEncarPro[j,1] } ) ) > 0
				aAdd( aPerc, { aEncarHrDs[nPos,1], aEncarHrDs[nPos,3] } )
			EndIf
		Next
		
		//--Soma do valor do DSR distribuido por c.custo ao array das Horas Atividade,
		//--de acordo com o percentual de distribuicao do DSR por c.custo
		aEval( aPerc, { |x| nTDsrH += x[2] } )
		For z := 1 To Len(aPerc)
			aAdd( aPerc[z], aPerc[z,2] / nTDsrH * nHrsAtv )
			If ( nPos := aScan( aEncarPro, { |x| x[1] == aPerc[z,1] } ) ) > 0
				aEncarPro[nPos,3] += aPerc[z,3]
			EndIf
		Next
	EndIf
	
	//--Gravar o Percentual de cada C.Custo lancado
	For n := 1  to nQtdPro
		aEncarPro[n,4] := aEncarPro[n,3] / nValTot
		//--Quando for o mesmo valor 100 %
		If aEncarPro[n,4] = 1.00
			aEncarPro[n,4] := 100.000
		EndIf
	Next n
	
	nLugar := Ascan( aPd,{ |x| aCodFol[033,1] == x[1] })
	If nLugar > 0
		For Nr := nLugar to Len(aPd)
			//-- Verifica se a Verba deve ser Calculada por c.custo e nao esta Deletada
			If aPd[Nr,9]  # "D" .And. aPd[Nr,1] == aCodFol[033,1] .And. aPd[Nr,3] = cSemana
				nVlVerba := nVlComp := nHrVerba := nHrComp := 0.00
				cVerba   := aPd[Nr,1]
				cTip2	  := aPd[Nr,7]
				
				//-- Achar o valor total da Verba a ser Calc. por C.Custo
				For nV := 1 To Len(aPd)
					If cVerba == aPd[nV,1] .And. aPd[nV,9] # 'D' .And. aPd[nV,3] = cSemana .and. (aPd[nV,7] != "I" .and. cTip2 == aPd[nV,7])
						nVlVerba  	+= aPd[nV,5]
						nHrVerba  	+= aPd[nV,4]
						cTip1     	:= aPd[nV,6]          //--> Tipo da Verba( V,H,D )
						cTip2     	:= aPd[nV,7]          //--> Origem da Verba
						dDtPgCc		:= aPd[nV,10]		   //--> Data Pagto de Origem
						aPd[nV,9] 	:= "D"
					EndIf
				Next nV
				
				//-- Divisao da Verba para cada c.custo
				For Nc := 1 to nQtdPro
					If Nc # nQtdPro
						nValDiv := Round(nVlVerba * aEncarPro[Nc,4], MsDecimais(1))
						nHrsDiv := Round(nHrVerba * aEncarPro[Nc,4],2)
						nVlComp += nValDiv
						nHrComp += nHrsDiv
					Else
						nValDiv := nVlVerba - nVlComp
						nHrsDiv := nHrVerba - nHrComp
					EndIf
					If lItemClVl
						fMatriz(cVerba,nValDiv,nHrsDiv, ,aEncarPro[Nc,1],cTip1,cTip2 , , ,dDtPgCc,.T.,,,aEncarPro[Nc,5],aEncarPro[Nc,6])
					Else
						fMatriz(cVerba,nValDiv,nHrsDiv, ,aEncarPro[Nc,1],cTip1,cTip2 , , ,dDtPgCc,.T.)
					EndIf		
				Next Nc
			EndIf
		Next Nr
	EndIf
EndIf  
Return   

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fGPSVal   ºAutor  ³Andreia dos Santos  º Data ³  05/03/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna os valores cadastrados no parametro 15              º±±
±±º          ³- "Complementacao da GPS"                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cExp1 => Filial                                            º±±
±±º          ³ cExp2 => Ano/Mes a ser pesquisado                          º±±
±±º          ³ aExp3 => array que retornara os valores [1] Centro de Custoº±±
±±º          ³                                         [2] Verba          º±±
±±º          ³                                         [3] Base de Calculoº±±
±±º          ³                                         [4] Percentual     º±±
±±º          ³                                         [5] valor          º±±
±±º          ³                                         [6] Recol./Deducao º±±
±±º          ³                                         [7] Observacao     º±±
±±º          ³                                         [8] per.Inicio Compº±±
±±º          ³                                         [9] Per.Fim Compensº±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fGPSVal(cFil,cAnoMes,aGPSVal,cTpContr)
Local aArea 	:= GetArea()
Local aTabS035	:= {}
Local cTab		:= "S035"
Local nCont  	:= 0
Local nPos		:= 0
Local nTamCC 	:= TamSX3("RA_CC")[1]
Local dDataAux   := StoD(cAnoMes+"01")
Local dDataAnt	:= CtoD("")
Local lDicInter		:= FindFunction("fChkInterm") .And. fChkInterm()	
DEFAULT cTpContr := "1"

cCcInic	:= If ( Type("cCcInic")#"U" , cCcInic, Space(nTamCC))
cCcFina	:= If ( Type("cCcFina")#"U" , cCcFina, Replicate("z",nTamCC))
dDataAnt:= If ( Type("dDataRef")#"U" , dDataRef, CtoD(""))
cTpContr:= If ( cTpContr == " *12" .Or. cTpContr == " *123" .Or. cTpContr == "123", Iif(lDicInter,"4","3"), cTpContr)

//-Array aGPSVal                       
aGPSVal := {}

fCarrTab( @aTabS035, cTab, dDataAux, .T.,,.T. )

If IsIncallStack("GPEM610")
	cTpContr := Alltrim(StrTran(cTpContr, "*", ""))
EndIf
For nCont := 1 To Len(aTabS035)
	If ( cTpContr == Iif(lDicInter,"4","3") .Or. ( cTpContr != Iif(lDicInter,"4","3") .And. aTabS035[nCont, 12] == cTpContr ) ) .And.;
		If( Empty(aTabS035[nCont, 05]) , .T. , ( aTabS035[nCont, 05] >= cCcInic .And. aTabS035[nCont, 05] <= cCcFina ) )

			If aTabS035[nCont, 02] == cFil .Or. aTabS035[nCont, 02] == Space(FwGetTamFilial)
				If (nPos := aScan(aGPSVal,{|x| (x[10] == cFil .Or. Empty(x[10])) .And. x[11] == aTabS035[nCont, 12] .And. x[1] == aTabS035[nCont, 05] .And. x[2] == aTabS035[nCont, 06] })) == 0
					aAdd(aGPSVal,{	aTabS035[nCont, 05],;	// Centro de Custo
						 			aTabS035[nCont, 06],;	// Verba
									aTabS035[nCont, 07],;	// Base de Calculo 
									aTabS035[nCont, 08],;	// Percentual
									aTabS035[nCont, 09],;	// Valor           
									aTabS035[nCont, 10],;	// Recolhimento/Deducao           
									aTabS035[nCont, 11],;	// Observacao       
									aTabS035[nCont, 14]+aTabS035[nCont, 13],; // Ano/mes do periodo inicial de Compensacao
									aTabS035[nCont, 16]+aTabS035[nCont, 15],; // Ano/mes do periodo final de Compensacao
									aTabS035[nCont, 02],;
									aTabS035[nCont, 12]})		
				Else
					aGPSVal[nPos, 05] += aTabS035[nCont, 09]
					aGPSVal[nPos, 03] += aTabS035[nCont, 07]
				EndIf		
			EndIf				
	EndIf		
Next nCont

aSort(aGpsVal,,,{|x,y| x[1]+x[2]<y[1]+y[2]})

dDataRef := dDataAnt

RestArea(aArea)

Return ( .T. )

          

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³FBaseIni  ³ Autor ³ Leandro Drumond       ³ Data ³ 08.01.13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calculo da Base Inicial de IR.				              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ FBaseIni()               						          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 												              ³±±
±±³          ³ 													          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FBaseIni()

Local cMesAnoDtPag 	:= MesAno(dData_Pgto)
Local lIrNeg		:= Len(aCodFol) >= 1726 .And. !Empty(aCodFol[1726,1]) .And. !Empty(aCodFol[1727,1]) 
Local cNoPd			:= aCodFol[6, 1] + "|" + aCodFol[1397, 1]

If RetValSRV(aCodFol[6,1],SRA->RA_FILIAL,"RV_IR") == "S" .And. Calcule == "S"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Soma Base de ir Mes Anterior Quando For Mesmo Mes            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Base_Ini := Val_Adto
	aEval( aPd, { |X| If( ! x[1] $ cNoPd, SomaInc( X, 5, @nBIrAdt, 13, "S", , , Month(dData_Pgto), , aCodFol ), Nil ) } )
	aEval( aPd, { |X| nBIrAdt += If( x[1] == aCodFol[10,1] .And. x[3] < cNumPag .And. x[9] # "D", x[5], 0 ) } )
	
	Base_Ini += nBIrAdt
	
	If ( Val_Adto + nBIrAdt ) > 0
		Aeval(aPd,{ |X| Base_Ini += If ( X[1]==aCodFol[106,1] .And. (cMesAnoDtPag == MesAno(X[10]) .Or. Empty(X[10])),X[5],0) })
		If lIrNeg
			Aeval(aPd,{ |X| Base_Ini -= If ( X[1]==aCodFol[1727,1] .And. (cMesAnoDtPag == MesAno(X[10]) .Or. Empty(X[10])),X[5],0) })
		EndIf
	EndIf										

EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³FM010IncIR ³ Autor ³ Leandro Drumond      ³ Data ³ 08.01.13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Soma IR.					     				              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ FM010IncIR()              						          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 												              ³±±
±±³          ³ 													          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FM010IncIR()

Local aCodBenef		:= {}
Local cMesAnoDtPag 	:= MesAno(dData_Pgto)
Local nDescIr 		:= 0.00
Local nCntP
Local nIr_BasMV		:= 0
Local nIr_MV		:= 0
Local n

Val_Peal := 0
IR_CALC  := 0

DEFAULT lVerMultv   := If ( Type("P_MULTV") == "U",.F.,P_MULTV)

If RetValSRV(aCodFol[6,1],SRA->RA_FILIAL,"RV_IR") == "S" .And. Calcule == "S"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Busca os codigos de pensao definidos no cadastro beneficiario³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	fBusCadBenef(@aCodBenef, "ADI", {aCodfol[58,1],aCodfol[174,1]})

	For nCntP := 1 To Len(aCodBenef)
		nPos := Ascan(aPD , { |X| X[1] == aCodBenef[nCntP,1] .And. X[9] # "D" })
		Val_Peal += IF(nPos > 0 , aPd[nPos,5] , 0)
	Next nCntP

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calculo do I.R.                                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If cPaisLoc == "PAR"   
		If !Empty(aTabIr)
    		If Len(aTabIr) > 1 .AND. Len(aTabIr) >= 5 
    			If !Empty(aTabIr[5,1]) .AND. !Empty(aTabIr[1,1]) 
					CALC_IR(@BASE_INI, @VAL_PEAL, @IR_CALC, @BASE_RED, @VAL_DEDDEP, @VAL_DEPEAL, aTabIr )			
				EndIf	
			EndIf	
		EndIf	
	Else
		If lVerMultv
			aEval( aPd, { |X| If ( x[1] $ aCodFol[992,1] .And. x[3] == cSemana .And. X[9] != "D" .and. x[11] == "9", nIr_BasMV += x[5], Nil ) } )
			aEval( aPd, { |X| If ( x[1] $ aCodFol[993,1] .And. x[3] == cSemana .And. X[9] != "D" .and. x[11] == "9", nIr_MV += x[5], Nil ) } )
		EndIf
		BASE_INI += nIr_BasMV
		CALC_IR(@BASE_INI, @VAL_PEAL, @IR_CALC, @BASE_RED, @VAL_DEDDEP, @VAL_DEPEAL, aTabIr,,@NALQIRADT )

		BASE_INI -= nIr_BasMV
		IR_CALC  -= nIr_MV
	EndIf	

	If RetValSRV(aCodFol[6,1],SRA->Ra_filial,"RV_IR") =="S" 
		nDescIr := 0
		Aeval(aPd,{ |X| nDescIr += If ( X[1]==aCodFol[107,1] .And. ;
												(cMesAnoDtPag == MesAno(X[10]) .Or. Empty(X[10])),X[5],0) })


		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se ja Houve Imposto de Renda Descontado             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cPdPesq := If(aCodFol[12,1] # Space(3) ,aCodFol[12,1] , aCodFol[9,1] )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Somar os Descontos de Imposto de Renda de Adto. Anteriores   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For N=1 To Len(aPd)
			If aPd[N,1] == cPdPesq .And. aPd[N,9] # "D" .And. aPd[N,3] < cNumPag
				nDescIR +=  aPd[n,5]
			EndIf
		Next
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Abater do IR Calculado os Impostos de Renda Ja Pagos         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IR_CALC  -= nDescIR
	EndIf
	If Ir_calc < 0  // Residuo do IR
		Vlr_res := Ir_calc * -1
		Ir_calc := 0
		fMatriz(aCodFol[63,1],Vlr_res,0.00, , ,"V","A")
    EndIf
EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³f131CalcFg³ Autor ³ Mauro                 ³ Data ³ 07.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³  Calculo do FGTS 13O. 1o. parc                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ f131CalcFgts()                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/

Function F131CALCFGTS()
Local cTipo2
Local dDataIni
Local dDataFim
Local nBsFgtsAux
Local nAvosFgt
Local nAvosR		:= 0
Local nValAux		:= 0
Local nAvosAci		:= 0
Local nfgts13_Mil	:= 0
Local nPerFgts  	:= 0
Local lTCpoFgts 	:= ( Type("SRA->RA_PERFGTS") # "U" )
Local lTemId1848	:= Len(aCodFol) >= 1848 .And. !Empty(aCodFol[1848, 1])

//--Verifica Qual Percentual de FGTS deve Aplicar
If lTCpoFgts .And. SRA->RA_PERFGTS > 0.00
	nPerFgts := SRA->RA_PERFGTS / 100
Else
	nPerFgts := If (SRA->RA_TPCONTR$ " *1",nFgtsCt1,nFgtsCt2)
Endif			

If Ascan(aPd,{ |X| X[1] = aCodfol[108,1] .And. X[9] # "D"}) = 0
	// PROCURA BASE DO FGTS
	nPos := Ascan(aPd,{ |X| X[1] = aCodfol[108,1] .And. X[9] # "D"} )
	nFgts_b := 0
	If nPos > 0
		nFgts_B := aPd[nPos,5]
	Else
		nFgts_B := 0.00
		// SOMA INCIDENCIA PARA BASE DE FGTS
		Aeval( aPd ,{ |X| SomaInc(X,6,@nFgts_b, , , , , , ,aCodFol) })

		// CALCULA FGTS COM BASE TOTAL SE AFASTAMENTO POR AUXILIO MATERNIDADE \ ADOCAO \ ACIDENTE 
		nAvosFgt := 0
	    Aeval( aAfast ,{ |X| nAvosFgt += If( Left( X[16], 1 ) $ "O*Q", X[1], 0 ) })
	    Aeval( aAfast ,{ |X| nAvosR += If( Left( X[16], 1 ) $ "R", X[1], 0 ) })
		If nAvosFgt+nAvosR > 0
			//Verifica se houve afastamento por acidente de trabalho para gerar a verba 1730
			Aeval( aAfast ,{ |X| nAvosAci += If( X[16] == "O1", X[1], 0 ) })
			
			If nAvosAci > 0 .and. nFgts_B > 0
				nValAux := nFgts_B
				nValAux := Round( fRetDec(@nValAux-nVal_Arre) / nAvos * (nAvosAci), 2 )
				FMatriz(aCodfol[1730,1],nValAux,0,cSemana,,,"P")
			EndIf
			
			// Quando há afastamento por maternidade, existem verbas de maternidade para 13 salário
			// Portanto, os avos de maternidade devem ser considerados na divisão
			If nAvosMat > 0
				If !lTemId1848
					nFgts_B 	:= Round( fRetDec(@nFgts_B-nVal_Arre) / ( nAvos + nAvosFgt + nAvosR )  * (nAvos + nAvosFgt + nAvosR), 2 )
				Else
					nfgts13_Mil := Round( nFgts_B / nAvos * nAvosR, 2 )
					nFgts_B 	:= Round( fRetDec(@nFgts_B-nVal_Arre) / ( nAvos + nAvosFgt )  * (nAvos + nAvosFgt), 2 )
				EndIf
			Else
				If !lTemId1848
					If nAvosAci > 0 .and. nAvosAci == nAvosFgt
						nFgts_B += nValAux
					Else
						nFgts_B 	:= Round( fRetDec(@nFgts_B-nVal_Arre) / nAvos * (nAvos + nAvosFgt + nAvosR), 2 )
					EndIf
				Else
					nfgts13_Mil := Round( nFgts_B / nAvos * nAvosR, 2 )
					If nAvosFgt > 0
						nFgts_B 	:= Round( fRetDec(@nFgts_B-nVal_Arre) / nAvos * (nAvos + nAvosFgt), 2 )
					EndIf
				EndIf
			EndIf
  			cTipo2  := "P" //Indica tipo "1a. Parcela 13o. para nao ser deletado pela folha
		EndIf
		
		// CALCULA FGTS PARA FUNCIONARIO AFASTADO POR ACIDENTE E ADOCAO ou APOSENTADO COM AVOS DE FGTS PARA RECEBER
		If nFgts_B == 0 .And. nAvosFgt > 0 .And. ( Left(SRA->RA_AFASFGT,1) $ "O*Q*R*X" .or. SRA->RA_AFASFGT $ "U3" )
			//Se houve pagamento de adicionais e a verba não incorporou o salário, soma na base
			If nAdtServ > 0 .and. RetValSRV(aCodFol[1630,1],SRA->RA_FILIAL,"RV_INCORP") == "N"
				nFgts_B += nAdtServ
			EndIf
			If nIntPercul > 0 .and. RetValSRV(aCodFol[1632,1],SRA->RA_FILIAL,"RV_INCORP") == "N"
				nFgts_B += nIntPercul
			EndIf
			If nIntInsal > 0 .and. RetValSRV(aCodFol[1634,1],SRA->RA_FILIAL,"RV_INCORP") == "N"
				nFgts_B += nIntInsal
			EndIf
			If nAdcConf > 0 .and. RetValSRV(aCodFol[1636,1],SRA->RA_FILIAL,"RV_INCORP") == "N"
				nFgts_B += nAdcConf
			EndIf
			If nAdcTrf > 0 .and. RetValSRV(aCodFol[1637,1],SRA->RA_FILIAL,"RV_INCORP") == "N"
				nFgts_B += nAdcTrf
			EndIf
  			nFgts_B += Salmes
  			
			If nAvosAci > 0
				nValAux := nFgts_B
				nValAux := Round( fRetDec(@nValAux-nVal_Arre) / 12 * (nAvosAci), 2 )
				nValAux := nValAux * nPercentual
				FMatriz(aCodfol[1730,1],nValAux,0,cSemana,,,"P")
			EndIf 
			
			nFgts_B := Round( nFgts_B / 12 * nAvosFgt, 2 )
  			nFgts_B := nFgts_B * nPercentual
  			
  			// Busca base de FGTS no acumulado para evitar gerar nova base
			If nAvosFgt > 0 .And. nFgts_B > 0 
		   		dDataIni   := If(cPeriodo == MesAno(SRA->RA_ADMISSA),SRA->RA_ADMISSA,CTOD("01/01/"+Substr(cPeriodo,1,4)))
				dDataFim   := CTOD("31/12/"+Substr(cPeriodo,1,4))
				nBsFgtsAux := fBuscaAcm(aCodFol[108,1],,dDataIni,dDataFim,"V")
				nFgts_B    := Max( nFgts_B - nBsFgtsAux, 0 )
			EndIf
		EndIf
	EndIf

	FMatriz(aCodfol[109,1],((nFgts_B+nFgts13_Mil) * nPerFgts ),0,cSemana,,,cTipo2)
	FMatriz(aCodfol[108,1],nFgts_B,0,cSemana,,,cTipo2)
	If lTemId1848
		FMatriz(aCodfol[1848,1],nFgts13_Mil,0,cSemana,,,cTipo2)
	EndIf
EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Calc_Ir  ³ Autor ³ Mauro                 ³ Data ³ 03.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao para Calcular Imp. de Renda                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Calc_Ir( nBaseIni, nPenAl, nIrCalc, nBaseRed, nDedDep, nDepeAl, aTabIr, lIrMin, nAliq )

Local aArea		:= GetArea()

DEFAULT lIrMin	:= If( lIrMin = Nil, .T., lIrMin )

lResExt		:= If( Type("lResExt")		== "U", .F.		, lResExt)
lAutMEI		:= If( Type("lAutMEI")		== "U", .F.		, lAutMEI)
nPercIRREx	:= If( Type("nPercIRREx")	== "U", 25.00	, nPercIRREx)
lIrResExt	:= If( Type("lIrResExt")	== "U", .T.		, lIrResExt)

//Para MEI nao ira calcular o IR
If lAutMEI
	Return
Endif

If ! lResExt
	nAliq    := 0
	nBaseIni -= nPenAl
	nPenAl   := 0
	nBaseRed := nBaseIni
EndIf

If nBaseIni <= 0
	nDedDep := 0.00
	Return Nil
EndIf

// DEDUCAO POR DEPENDENTES
If nDedDep # Nil .and. !lResExt
	//-- Para o modulo PLS - Plano de Saude a variavel nDedDep sempre tem a quantidade de dependentes informada
	//-- e nem sempre para o GPE envia a quantidade de dependente nesta variavel.
	If cModulo $ ("GPE/GFP")
		nDedDep := aTabIr[5,1] * (If(VAL(SRA->RA_DEPIR) > aTabIr[5,2],aTabIr[5,2],VAL(SRA->RA_DEPIR)))
	Else
		nDedDep := aTabIr[5,1] * If(nDedDep > aTabIr[5,2],aTabIr[5,2],nDedDep)
	EndIf
Else
	nDedDep := 0.00
EndIf

nBaseRed := nBaseIni - nDedDep

If nBaseRed <= aTabIr[1,1] .and. !lResExt
	nBaseRed := 0
	Return Nil
EndIf

// DEDUCAO POR PENSAO ALIMENTICIA
If !lResExt
	If aTabIr[1,1] - (nBaseRed - nPenAl) < 0
		nDepeAl := nPenAl
	Else
		nDepeAl := nBaseRed - aTabIr[1,1]
	EndIf
Else
	nDepeAl := 0
EndIf

nBaseRed -= nDepeAl
If nBaseRed <= aTabIr[1,1] .and. !lResExt
	nBaseRed := 0
	Return Nil
EndIf

If !lResExt
	// CALCULO DO IR SOBRE A TABELA
	If nBaseRed <= aTabIr[1,1]
		nBaseRed := 0
		Return Nil
	Elseif nBaseRed <= aTabIr[2,1]
		nIrCalc := (nBaseRed * (aTabIr[2,2]/100))-aTabIr[2,3]
		nAliq   := aTabIr[2,2]
	Elseif nBaseRed <= aTabIr[3,1]
		nIrCalc := (nBaseRed * (aTabIr[3,2]/100))-aTabIr[3,3]
		nAliq   := aTabIr[3,2]
	Elseif nBaseRed <= aTabIr[4,1]
		nIrCalc := (nBaseRed * (aTabIr[4,2]/100))-aTabIr[4,3]
		 nAliq  := aTabIr[4,2]
	Else
		nIrCalc := (nBaseRed * (aTabIr[6,2]/100))-aTabIr[6,3]
	   nAliq  := aTabIr[6,2]
	EndIf

ElseIf lIrResExt // Residentes no exterior
	nIrCalc	:= nBaseRed * ( nPercIRREx / 100 )
	nAliq  	:= nPercIRREx
EndIf

nIrCalc = INT( nIrCalc * 100 ) / 100  // DEIXA O VALOR COM 2 CASAS APOS A VIRGULA

// VERIFICA RETENCAO
If nIrCalc < aTabIr[5,3] .And. lIrMin .and. !lResExt
	nIrCalc  := 0
	nBaseRed := 0
EndIf  

RestArea( aArea )

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Calc_IrRRA³ Autor ³ Leandro Drumond       ³ Data ³ 28.06.12³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao para Calcular Imp. de Renda sobre RRA               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Calc_IrRRA(nBaseIni,nPenAl,nIrCalc,nBaseRed,nDedDep,nDepeAl,aTabIr,lIrMin,nAliq,nMesesRRA)

lAutMEI		:= If( Type("lAutMEI")		== "U", .F.,	lAutMEI)
lResExt		:= If( Type("lResExt")		== "U", .F.,	lResExt)
nPercIRREx	:= If( Type("nPercIRREx")	== "U", 25.00,	nPercIRREx)
lIrResExt	:= If( Type("lIrResExt")	== "U", .T.,	lIrResExt)

//Para MEI nao ira calcular o IR
If lAutMEI
	Return
Endif

If !lResExt
	lIrMin   := If (lIrMin = Nil , .T. , lIrMin)
	nAliq    := 0
	nBaseIni -= nPenAl
	nPenAl   := 0
	nBaseRed := nBaseIni
EndIf

If nBaseIni <= 0
	nDedDep := 0.00
	Return Nil
EndIf

// DEDUCAO POR DEPENDENTES
If nDedDep # Nil .and. !lResExt
	nDedDep := aTabIr[20] * (If(VAL(SRA->RA_DEPIR) > aTabIr[21],aTabIr[21],VAL(SRA->RA_DEPIR)))
Else
	nDedDep := 0.00
EndIf

//nBaseRed := nBaseIni - nDedDep -- Nao eh para deduzir dependente no RRA.

If nBaseRed <= ( aTabIr[7] * nMesesRRA ) .and. !lResExt
	nBaseRed := 0
	Return Nil
EndIf

// DEDUCAO POR PENSAO ALIMENTICIA
If !lResExt
	If ( aTabIr[7] * nMesesRRA )  - (nBaseRed - nPenAl) < 0
		nDepeAl := nPenAl
	Else
		nDepeAl := nBaseRed - ( aTabIr[7] * nMesesRRA )
	EndIf
Else
	nDepeAl := 0
EndIf

nBaseRed -= nDepeAl
If nBaseRed <= ( aTabIr[7] * nMesesRRA ) .and. !lResExt
	nBaseRed := 0
	Return Nil
EndIf

If !lResExt
	// CALCULO DO IR SOBRE A TABELA
	// SE MENOR OU IGUAL AO VALOR DE ISENCAO VEZES A QUANTIDADE DE MESES, NAO CALCULA NADA
	If nBaseRed <= aTabIr[7] * nMesesRRA
		nBaseRed := 0
		Return Nil
	// SE MENOR QUE FAIXA 2, UTILIZA FAIXA 1 PARA O CALCULO
	Elseif nBaseRed <= ( aTabIr[11] * nMesesRRA )
		nIrCalc := (nBaseRed * (aTabIr[9]/100))-( aTabIr[10] * nMesesRRA )
		nAliq   := aTabIr[9]
	// SE MENOR QUE FAIXA 3, UTILIZA FAIXA 2 PARA O CALCULO
	Elseif nBaseRed <= ( aTabIr[14] * nMesesRRA )
		nIrCalc := (nBaseRed * (aTabIr[12]/100))-( aTabIr[13] * nMesesRRA )
		nAliq   := aTabIr[12]
	// SE MENOR QUE FAIXA 4, UTILIZA FAIXA 3 PARA O CALCULO
	Elseif nBaseRed <= ( aTabIr[17] * nMesesRRA )
		nIrCalc := (nBaseRed * (aTabIr[15]/100))-( aTabIr[16] * nMesesRRA )
		nAliq   := aTabIr[15]
	// SE MAIOR OU IGUAL FAIXA 4, UTILIZA FAIXA 4 PARA O CALCULO
	Else
		nIrCalc := (nBaseRed * (aTabIr[18]/100))-( aTabIr[19] * nMesesRRA )
	   nAliq  := aTabIr[18]
	EndIf

ElseIf lIrResExt .And. lIrResExt	//Residentes no exterior
	nIrCalc := (nBaseRed * nPercIrRex) / 100
	nAliq := nPercIrRex
EndIf

nIrCalc = INT( nIrCalc * 100 ) / 100  // DEIXA O VALOR COM 2 CASAS APOS A VIRGULA

// VERIFICA RETENCAO
If nIrCalc < aTabIr[22] .And. lIrMin .and. !lResExt
	nIrCalc  := 0
	nBaseRed := 0
EndIf

Return Nil



/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Calc_Inss ³ Autor ³ Mauro                 ³ Data ³ 28.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao para Calcular I.N.S.S.                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³Calc_Inss(aInss)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Calc_Inss(aTInss, nBase, nInss, nInss1, nBaseAt, nBaseAc, nAliq, nBaseOut, lTrunca, nBsComp, aInssFx, lEsocial, nAliqEsoc, nBsAutOut)

Local nBase1	:= nBase
Local nBaseCalc := 0
Local nT 		:= 0
Local nINSSAux	:= 0
Local nBaseAux	:= 0
Local nPerc102  := If(Type("P_INSS102") != "U", P_INSS102, 0)
Local lNovoCalc := aTInss[1,4] == "S"

Default lEsocial  := .F.
Default nBsAutOut := 0

lTrunca 	:= If (lTrunca = Nil , .T. , lTrunca)
nBaseAc		:= 0.00
nBaseOut	:= If( nBaseOut == NIL .or. ValType( nBaseOut ) != "N" , 0.00 , nBaseOut )
nBsComp     := If( nBsComp # Nil .And. nBsComp > 0, nBsComp, nBase1 )
lDissidio	:= If( lDissidio == Nil,.F.,lDissidio ) 
nBsOutAux   := nBaseOut

If nBaseOut > 0
	If nBsAutOut > 0
	    If nBsComp > aTinss[Len(aTinss),1]
			nBaseAux  := nBsComp - aTinss[Len(aTinss),1]
			nBsComp   := aTinss[Len(aTinss),1] - nBsAutOut
			nBase1    := aTinss[Len(aTinss),1] - nBsAutOut
			nBsOutAux -= nBsAutOut
		Else
			nBsComp   -= nBsAutOut
			nBase1    -= nBsAutOut
			nBsOutAux -= nBsAutOut
		EndIf 
	EndIf
EndIf 

If nBsComp > 0.00
	If SRA->RA_CATEFD == "102" .and. nPerc102 > 0 //Trabalhador rural, INSS fixo em 8% (P_INSS102)
		nBaseCalc := If ( nBase1 < aTinss[Len(aTinss),1] , nBase1 , aTinss[Len(aTinss),1])
        nInss     := If (lTrunca, NoRound(nBaseCalc * nPerc102,2),Round(nBaseCalc * nPerc102,2))
        nInss1    := nInss
        nAliq     := Round(nPerc102 * 100 ,2)
        nBaseAt   := Max(nBaseCalc - nBaseOut , 0 )
        nBaseac   := nBase1 - nBaseOut - nBaseAt	
	ElseIf SRA->RA_CATFUNC $ "P*A"
		nBaseCalc := If ( nBase1 < aTinss[Len(aTinss),1] , nBase1 , aTinss[Len(aTinss),1])
        nInss     := If (lTrunca, NoRound(nBaseCalc * P_PERCAUTO,2),Round(nBaseCalc * P_PERCAUTO,2))
        nInss1    := nInss
        nAliq     := Round(P_PERCAUTO * 100 ,2)
        nBaseAt   := Max(nBaseCalc - nBaseOut , 0 )
        nBaseac   := nBase1 - nBaseOut - nBaseAt
	Else
		If lNovoCalc
			nInss  := 0
			nInss1 := 0
			nBaseAt:= 0
			aInssFx:= Array(4,2)
			For nT := 1 to 4
				aInssFx[nT,1] := 0
				aInssFx[nT,2] := 0
			Next nT
		EndIf
	    For nT=1 to Len(aTInss)
			If lNovoCalc //Novo formato de cálculo de INSS - Emenda Constitucional 103
				If nBsComp <= aTInss[nT,1]
					nBaseCalc := If ( nT == 1, nBase1, nBase1 - aTinss[nT-1,1] )
					nInssAux  := If (lTrunca ,NoRound(nBaseCalc * aTInss[nT,2],2),Round(nBaseCalc * aTInss[nT,2],2))
					aInssFx[nT,1] := nInssAux
					aInssFx[nT,2] := Round(aTInss[nT,2] * 100 ,2)
					nInss     += nInssAux
					nInss1    += If (lTrunca ,NoRound(nBaseCalc * If(!Empty(aTinss[nT,3]),aTinss[nT,3],aTinss[nT,2]),2),Round(nBaseCalc * If(!Empty(aTinss[nT,3]),aTinss[nT,3],aTinss[nT,2]),2))
					nAliq     := Round(aTInss[nT,2] * 100 ,2)
					nBaseAt   += nBaseCalc					
					Exit
				Else
					nBaseCalc := If ( nT == 1, aTinss[nT,1], aTinss[nT,1] - aTinss[nT-1,1] )
					nInssAux  := If (lTrunca, NoRound(nBaseCalc * aTInss[nT,2],2),Round(nBaseCalc * aTInss[nT,2],2))
					aInssFx[nT,1] := nInssAux
					aInssFx[nT,2] := Round(aTInss[nT,2] * 100 ,2)
					nInss     += nInssAux
					nInss1    += If (lTrunca, NoRound(nBaseCalc * If(!Empty(aTinss[nT,3]),aTinss[nT,3],aTinss[nT,2]),2),Round(nBaseCalc * If(!Empty(aTinss[nT,3]),aTinss[nT,3],aTinss[nT,2]),2))
					nAliq     := Round(aTinss[nT,2] * 100 ,2)
					nBaseAt   += nBaseCalc
				EndIf
			Else //Formato anterior
				If nBsComp <= aTInss[nT,1]
					nInss     := If (lTrunca ,NoRound(nBase1 * aTInss[nT,2],2),Round(nBase1 * aTInss[nT,2],2))
					nInss1    := If (lTrunca ,NoRound(nBase1 * If(!Empty(aTinss[nT,3]),aTinss[nT,3],aTinss[nT,2]),2),Round(nBase1 * If(!Empty(aTinss[nT,3]),aTinss[nT,3],aTinss[nT,2]),2))
					nAliq     := Round(aTInss[nT,2] * 100 ,2)
					nBaseAt   := nBase1 - nBsOutAux
					Exit
				ElseIf nT == Len(aTInss)
					nBaseCalc := If ( nBase1 < aTinss[nT,1],nBase1,aTinss[nT,1])
					nInss     := If (lTrunca, NoRound(nBaseCalc * aTInss[nT,2],2),Round(nBaseCalc * aTInss[nT,2],2))
					nInss1    := If (lTrunca, NoRound(nBaseCalc * If(!Empty(aTinss[nT,3]),aTinss[nT,3],aTinss[nT,2]),2),Round(nBaseCalc * If(!Empty(aTinss[nT,3]),aTinss[nT,3],aTinss[nT,2]),2))
					nAliq     := Round(aTinss[nT,2] * 100 ,2)
					nBaseAt   := Max(nBaseCalc - nBsOutAux , 0 )
					nBaseac   := nBase1 - nBsOutAux - nBaseAt
				EndIf
			EndIf
	    Next nT
		If lNovoCalc
			If lEsocial
				nAliqEsoc := nAliq
			EndIf			
			nAliq	:= 0 //Zera aliquota
			nBaseAt := Max(nBaseAt - nBsOutAux, 0)
			nBaseac := Max(nBase - nBaseOut - nBaseAt, 0)
		EndIf
	EndIf
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fCInss   ³ Autor ³ Equipe RH             ³ Data ³20/05/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do Inss Funcionario Normal e Ferias                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCInss(aCodfol)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCInss(aCodfol,aTinss,lTrunca)

Local nAteAnt	:= 0.00
Local nAciAnt	:= 0.00
Local nInssAnt	:= 0.00          
Local nInssAnt1	:= 0.00
Local nInssAnt2	:= 0.00
Local nInssAnt3	:= 0.00
Local nAliq		:= 0.00
Local nBaseOut	:= 0.00
Local nBaseOutI	:= 0.00
Local nInssOut	:= 0.00
Local nBaseTot	:= 0.00
Local nInss_Ou	:= 0.00
Local nInss_O1	:= 0.00
Local nInssFer	:= 0.00
Local nId0168	:= 0.00
Local nInssFol	:= 0.00
Local nBsMater  := 0.00
Local nNumFer	:= 0.00
Local nInsfeFec	:= 0.00
Local nRegAnt	:= 0.00
Local nRefAut   := 0.00
Local nPosPd
Local nBaseTeto := 0
Local nTetoInss := 0
Local lAumFer	:= .F. //Teve aumento durante as ferias integralmente gozadas
Local lInfTeto	:= .F.
Local nDiasMs       
Local dDtPgFer  := cToD("")
Local cAlias	:= ""
Local cInssOri 	:= ""
Local nPosFer 	:= 0
Local nFerInc	:= 0
Local nPosInc  	:= 0
Local nX       	:= 0
Local nDedFer	:= 0
Local nBsAutOut := 0
Local cQuery   	:= ""
Local cAliasQry	:= ""
Local lId1449	:= (Len(aCodFol) >= 1449)
Local nInssFOut	:= 0
Local lMultv    := Type("lUtiMultiV") <> "U" .And. lUtiMultiV
Local aPdBkp    := {}
Local aPdFx		:= {aCodFol[1734,1], aCodFol[1735,1], aCodFol[1736,1], aCodFol[1737,1]}
Local aInssFx	:= {}
Local lIntTaf   := ((SuperGetMv("MV_RHTAF",, .F.) == .T.) .AND. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 2 )
Local nVl0065	:= 0

Private lRecInss :=GetNewPar('MV_INSSREC',.F.)  // Recalculo INSS quando rescisao complementar

If lMultv
	nAliqFMV  := 0
	lTetoINSS := .F.
EndIf

lResExt	    := If( Type("lResExt") 	    == "U"	, .F., lResExt)
lDedInssEx	:= If( Type("lDedInssEx") 	== "U"	, .F., lDedInssEx)
lIrResExt	:= If( Type("lIrResExt") 	== "U"	, .T., lIrResExt)
lInssAut	:= If( Type("lInssAut") 	== "U"	, .T., lInssAut)

// Para os casos em que o funcionário não é autonomo, pode haver acordo
// Entre o Brasil e outros paises, para o não desconto do INSS.
// Para tratar esses acordos o campo RA_INSSAUT é utilizad.
// Se estiver com NÃO, NÃO deverá calcular INSS, independente do RA_CATFUNC.
If cPaisLoc == "BRA" .and. (!lInssAut)
	Return
EndIf

//--Situacao do Funcionario na data de referencia
cSitFolh	:= If( Type("cSitFolh")=="U",SRA->RA_SITFOLH,cSitFolh)
lDissidio	:= If(lDissidio == Nil,.F.,lDissidio) 
lTrunca 	:= If (lTrunca = Nil , .T. , lTrunca)
lRescDis	:= If( type("lRescDis")=="U",.F.,lRescDis)//Rescisao Complementar por Dissidio

If lRescDis .and. !lProxMes
	nRegAnt	:= SRG->(Recno())
	SRG->(DbGoTo(nRegSrg))
	SRR->(DbSetOrder(1)) //RR_FILIAL+RR_MAT+RR_TIPO3+DTOS(RR_DATA)+RR_PD+RR_CC
EndIf

//Variável do TETO do INSS.
nBaseTeto := aTinss[Len(aTinss), 1]
nTetoInss := fRetTetIns(aTinss)

aEval( aPd, { |x| nBaseOutI += Iif( x[1] == aCodFol[396, 1] .And. x[9] # "D", x[5], 0) } )
lInfTeto := (nBaseTeto == nBaseOutI)

//INSS para semanalista no caso de dissidio
If lDissidio .And. SRA->RA_TIPOPGT = "S"
	cAlias := GetNextAlias()
	cSql := " SELECT RV_CODFOL,RHH_VB,RHH_CALC,RHH_SEQ FROM "+RetSqlName("RHH")+" RHH"
	cSql += " LEFT JOIN "+RetSqlName("SRV")+" SRV ON RV_COD=RHH_VB AND RV_FILIAL ='"+xFilial("SRV")+"' and SRV.D_E_L_E_T_=''"
	cSql += " WHERE RHH.D_E_L_E_T_= ' '"
	cSql += " AND RHH_MAT='"+SRA->RA_MAT+"'"
	cSql += " AND RHH_DATA='"+cPeriodo+"'"
	cSql += " AND RHH_SEQ < '" + Alltrim(str(Val(cSemana))) + "'"
	cSql += " AND RV_CODFOL IN('0013','0014','0064','0065','0167','0168','0032','0031')"       //
	cSql := changeQuery(csql)
	dbUseArea( .T., "TOPCONN", TcGenQry( ,,cSql ), cAlias )
	While !(cAlias)->(Eof())
		fMatriz((cAlias)->RHH_VB,(cAlias)->RHH_CALC,,Strzero(val((cAlias)->RHH_SEQ),2))
		(cAlias)->(dbskip())
	EndDo                   
	(cAlias)->(dbCloseArea())
EndIf

If !Empty( aCodFol[288,1] ) //Base Inss Outras Empresas
	If Type("aInssOut") == "A" .And. Len(aInssOut) > 0 .And. aScan(aInssOut,{|x| x[5] == SRA->RA_CIC}) > 0
		aEval( aInssOut , { |x| nBaseOut += IF( x[1] == aCodFol[288,1] , x[2] , 0.00 ) } ) 
	Else
		aEval( aPD , { |x| nBaseOut += IF( x[1] == aCodFol[288,1] .and. x[9] # "D" .and. ( x[3] == cSemana .or. lMultv ) , x[5] , 0.00 ) } ) 
	EndIf
	If nBaseOut > 0 .and. !Empty(aCodFol[1847,1])
		aEval( aPd, { |x| If(x[1] == aCodFol[1847,1] .and. x[9] <> 'D', nBsAutOut += x[5], Nil) } )
	EndIf 
EndIf

If !Empty( aCodFol[289,1] ) //Inss Outras Empresas
	If Type("aInssOut") == "A" .And. Len(aInssOut) > 0 .And. aScan(aInssOut,{|x| x[5] == SRA->RA_CIC}) > 0
		aEval( aInssOut , { |x| nInssOut += IF( x[1] == aCodFol[289,1] , x[2] , 0.00 ) } )
	Else
		aEval( aPD , { |x| nInssOut += IF( x[1] == aCodFol[289,1] .and. x[9] # "D" .and. ( x[3] == cSemana .or. lMultv ), x[5] , 0.00 ) } )
	EndIf
EndIf
  
// Rescisao complementar por dissidio (lRescDis) ou somente complementar (lRecInss, parametro MV_INSSREC), salvar BASE E INSS ja calculados.
If cCompl = "S"  //Rescisao Complementar

	If lRescDis .or. lRecInss .Or. lProxMes // Dissidio ou Parametro MV_INSSREC como T 

		If lRescDis .Or. lRecInss .Or. ( Type("lRescRet") <> "U" .And. lRescRet)
			Car_inss(@aTInss,MesAno(dDatadem)) // Carrregar tabela inss do mes\ano data rescisao
			aEval( aPdResc , { |x| nBaseOut += If (x[1] $ aCodFol[13,1]+"*"+ aCodFol[14,1]+"*"+ aCodFol[338,1] .and. X[3] == cSemana .And. X[9] # "D", x[5], 0.00) })
			aEval( aPdResc , { |x| nInssOut += If( x[1] $ aCodFol[64,1]+"*"+ aCodFol[65,1]+"*"+ aCodFol[340,1] .and. x[3] == cSemana .and. x[9] # "D", x[5], 0.00) })
		EndIf
		
    	If lProxMes
			aEval( aPdResVals , { |x| nBaseOut += If (x[1] $ aCodFol[13,1]+"*"+ aCodFol[14,1] .And. X[3] = cSemana .And. MesAno(M->RG_DTGERAR) == MesAno(X[Len(X)]) .And. X[9] # "D",x[5],0.00) })
			aEval( aPdResVals , { |x| nInssOut += If( x[1] == aCodFol[64,1] .And. MesAno(M->RG_DTGERAR) == MesAno(X[Len(X)]) .and. x[9] # "D" .and. x[3] == cSemana , x[5] , 0.00 ) } )    			
    	EndIf

	EndIf
	
EndIf

If Ascan(aPd,{ |X| X[1] = aCodfol[64,1] .And. X[3] = cSemana .And. X[9] # "D"}) = 0
	
	//--Verifica se lancou Base de Inss somando as verbas 
	nInss_b := nInssf_b := 0.00
	If !lDissidio
		Aeval( aPd ,{ |X| nInss_B += If (x[1] $ aCodFol[13,1]+"*"+ aCodFol[14,1] .And. X[3] = cSemana .And. X[9] # "D",x[5],0.00) })
	Else                                
		If SRA->RA_TIPOPGT != "S"
			//apagar verbas de base para forçar o carregamento abaixo
			Aeval( aPd ,{ |X| If (x[1] $ (aCodFol[13,1]+"/"+aCodFol[14,1]) .And. X[3] == cSemana .And. X[9] # "D", x[9]:= "D", "") })
		EndIf
	Endif
	
	If nInss_b = 0
		//-- Soma Incidencia para Inss quando base não foi lancada

		If lMultv
			aPdBkp := AClone(aPd)
			For nX := 1 To Len(aPd)
				If aPd[nX,3] <> cSemana
					aPd[nX,3] := cSemana
				EndIf
			Next nX
		EndIf

		Aeval( aPd ,{ |X| SomaInc(X,4,@nInss_b  ,11,"N",12,"N", , ,aCodfol) })
		Aeval( aPd ,{ |X| SomaInc(X,4,@nInssF_b ,11,"S", , , , ,aCodFol) })
		If cTipoRot == "4"
			Aeval( aPdSemAnt ,{ |X| SomaInc(X,4,@nInss_b  ,11,"N",12,"N", , ,aCodfol) })
			Aeval( aPdSemAnt ,{ |X| SomaInc(X,4,@nInssF_b ,11,"S", , , , ,aCodFol) })
		EndIf

		If lMultv
			aPd := AClone(aPdBkp)
		EndIf
		
		If SRA->RA_TPCONTR == "3"
			Aeval( aPdConvoc ,{ |X| SomaInc(X,4,@nInss_b  ,11,"N",12,"N", , ,aCodfol,,,,,, .T.) })
			Aeval( aPdConvoc ,{ |X| SomaInc(X,If(lDissidio, 35,4),@nInssF_b ,11,"S", , , , ,aCodFol,,,,,, .T.) })
		EndIf
		
		//Se for complementar MULTV considera os valores anteriores também
		If lMultv .And. LCALCCOMPL .And. Len(aCPFAll) > 0
			//AEval( aPd ,{ |X| IIf(X[1] == aCodFol[0064,1],X[9] := "D",Nil) })
			
			cAliasQry := GetNextAlias()
			
			cQuery := " SELECT * FROM " + RetSqlName("SRC")
			cQuery += " WHERE "
			cQuery += " ( "
			For nX := 1 To Len(aCPFAll)
				cQuery += " ( RC_FILIAL = '" + aCPFAll[nX,2] + "' AND"
				cQuery += " RC_MAT = '" + aCPFAll[nX,3] + "' )"
				
				If nX <> Len(aCPFAll)
					cQuery += " OR "
				EndIf
			Next nX
			cQuery += " ) AND"
			cQuery += " RC_PROCES = '" + cProcesso + "' AND"
			cQuery += " RC_PERIODO = '" + cPeriodo + "' AND"
			cQuery += " RC_ROTEIR = '" + cRot + "' AND"
			cQuery += " RC_SEMANA < '" + cSemana + "' AND"
			cQuery += " RC_PD IN('" + aCodFol[0013,1] + "','" + aCodFol[0014,1] + "') AND" // Bases de INSS
			cQuery += " D_E_L_E_T_ = ' ' "
			
			cQuery := ChangeQuery(cQuery)
			
			DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry)
			
			While (cAliasQry)->( !Eof() )
				nInss_b += (cAliasQry)->RC_VALOR
				(cAliasQry)->( DbSkip() )
			EndDo
			
			(cAliasQry)->( DbCloseArea() )
		EndIf
		//-- Se afastamento Aux. Maternidade, monta base integral p/ encontrar aliquota
		If nDiasSalM > 0 .And. (nInss_b + nInssf_b + nBaseOut) > 0
			nBsMater := (nInss_b + nInssf_b + nBaseOut) + (nDiasSalM*SalDia) + nMedComiss
		EndIf
    EndIf

	If lInfTeto
		FMatriz(aCodfol[14,1], (nInss_b + nInssf_b))
		Return
	EndIf

	If lDissidio .And. cTipoRot == "1"
		aEval( aPd, { |X| If ( x[1] $ aCodFol[72,1] .And. x[3] == cSemana .And. X[9] != "D", nNumFer++, Nil ) } )
		aEval( aPd, { |X| If ( x[1] $ (aCodFol[72,1]+"*"+aCodFol[77,1]+'*'+aCodFol[88,1]+'*'+aCodFol[90,1]+'*'+aCodFol[92,1]+'*'+aCodFol[96,1]+'*'+aCodFol[98,1]+'*'+aCodFol[161,1]+'*'+aCodFol[94,1]+'*'+aCodFol[95,1]) .And. x[3] == cSemana .And. X[9] != "D" .And. x[11] > Str(nNumFer, 1), nInssF_b -= x[19], Nil ) } )			
	EndIf
	
	//-- Funcao para calcular o inss
	nInss := nInssf := nInss1 := nBaseAt := nBaseAc := nInssf1 := nBaseTot := 0.00
	nBaseTot += ( nInss_b + nInssf_b + nBaseOut + nBasAuxD )

	//Abate  base de INSS calculada na rescisão complementar.
	If !Empty(SRA->RA_DEMISSA) .and. AnoMes(SRA->RA_DEMISSA) < cPeriodo .and. cTipoRot == "1"
		Aeval( aPd ,{ |X| nBaseTot -= If (x[1] == aCodFol[338,1] .And. X[9] # "D",x[5],0.00) })
	EndIf	
	
	Calc_Inss(aTInss,nBaseTot,@nInss,@nInss1,@nBaseAt,@nBaseAc,@nAliq,nBaseOut,lTrunca,nBsMater,@aInssFx,,,nBsAutOut)
	If nBasAuxD > 0
		nBaseTot -= nBasAuxD
		Calc_Inss(aTInss,nBaseTot,0,0,@nBaseAt,@nBaseAc,0,nBaseOut,lTrunca,nBsMater,aClone(aInssFx),,,nBsAutOut)
	EndIf

	If lMultv
		dbSelectArea ("SRG")
		dbSetOrder(2)
		If SRG->(DbSeek(xFilial("SRG") + SRA->RA_MAT + "RES" ))
			While SRG->RG_FILIAL == SRA->RA_FILIAL .AND. SRG->RG_MAT == SRA->RA_MAT
				If MesAno(SRG->RG_DATAHOM) == cPeriodo //Caso haja uma rescisao no mesmo mes de calculo da folha deve abater o INSS ja pago
					dbSelectArea("SRR")
					DbSetOrder(1)
					If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[64,1] ))
						nInss -= SRR->RR_VALOR		
					EndIf
					If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[65,1] ))
						nInss -= SRR->RR_VALOR		
					EndIf
				EndIf
			dbSelectArea ("SRG")
			SRG->(DbSkip())
			EndDo
		Endif
	Endif

	//-- Se informou o Inss Outras Empresas Subtrai do Inss Calculado
	If nBaseOut > 0.00 .or. nInssOut > 0.00
		If nInssAOut > 0 .or. nBsAutOut == 0
			nInss	:= Max( nInss - ( nInssOut - nInssAOut) , 0 )
		Else
			aEval( aPd, { |x| If(x[1] == aCodFol[1847,1] .and. x[9] <> 'D', nRefAut := x[4], Nil) } )
			nRefAut := If(Empty(nRefAut),11,nRefAut)
			nInss	:= Max( nInss - ( nInssOut - (nBsAutOut * (nRefAut/100))) , 0 )
		EndIf 

		//-- Se informou o Inss Outras Empresas Subtrai do Inss Calculado
		If nInssOut > 0
			If nInssAOut > 0 .or. nBsAutOut == 0
				nInss1	:= Max( nInss1 - ( nInssOut - nInssAOut) , 0 )
			Else 
				nInss1	:= Max( nInss1 - ( nInssOut - (nBsAutOut * (nRefAut/100))) , 0 )
			EndIf 
		Else
			//-- Calcular a Deducao de Inss no Ir sobre a Base da outra empresa 
			//-- Para abater da deducao total 
			nDedInss := 0.00                           
			Calc_Inss(aTInss,nBaseOut-nBsAutOut,,@nDedInss,,,,,lTrunca,,@aInssFx)
			nInss1	:= Max( nInss1 - nDedInss , 0 )
		EndIf	
	EndIf

	// Quando funcionario tem ferias no mes e nao possui dias trabalhados ou remuneracao
	// por afastamento, todo o INSS deve ser computado como INSS Ferias pois nao tem
	// rendimentos em folha.
	Aeval( aPd ,{ |X| If (x[1] $ aCodFol[072,1] .And. X[3] = cSemana .And. X[9] # "D", nDiasMes += x[4], NIL) })
	If ( DiasTrab + nDiasPg + nDiasLRem ) == 0 .and. nDiasMes < 30 .And. cSitFolh $ "A*F" .and. !(SRA->RA_CATFUNC == "M" .and. SRA->RA_SALARIO == 0 .and. nInss > 0 .and. nDiasMes == 0) .And. !(Month(dDataAte) == 2 .And. nDiasMes == Day(dDataAte)) //Se for mensalista sem salário e INSS foi gerado através de lançamento de verbas, não zera inss férias.
		//-- Verifica se teve aumento no mes das ferias integralmente gozadas
		Aeval( aPd ,{ |X| If (x[1] $ aCodFol[088,1] .And. X[3] = cSemana .And. X[9] # "D",lAumFer:= .T.,NIL) })
		If Type("lUtiMultiV") == "U" .Or. ( Type("lUtiMultiV") != "U" .And. ! lUtiMultiV )
			aEval( aPd, { |x| If( x[1] $ aCodFol[65,1] .And. x[3] == cSemana, x[9] := "D", NIL ) } )
		EndIf
	EndIf

    //-- Abater do Inss de Ferias , informado ou gerado pela rotina de Ferias 
   	nNumFer:=0
   	
  	Aeval( aPd ,{ |X| If (x[1] $ aCodFol[164,1]+If(lId1449, "/"+aCodFol[1449,1], "") .And. X[3] = cSemana .And. X[9] # "D",nPosFer++,NIL) })  //nPosFer > 0 significa que eh o segundo mes
  	Aeval( aPd ,{ |X| If (x[1] $ aCodFol[072,1] .And. X[3] = cSemana .And. X[9] # "D",nNumFer++,NIL) })
  	Aeval( aPd ,{ |X| nInssFer += If (x[1] $ aCodFol[65,1] .And. X[3] = cSemana .And. X[9] # "D", x[5], 0.00) })
  	Aeval( aPd ,{ |X| nInssFOut += If (x[1] $ aCodFol[0397,1] .And. X[3] = cSemana .And. x[7] != "K" .And. X[9] # "D", x[5], 0.00) })
	
	//Busca as datas de pagamento geradas das verbas de Férias Pagas mês anterior e abono pago mês anterior, pois essas verbas sempre existem em férias partidas.
	If ( nPos := aScan( aPd, { |x| x[1] $ (aCodFol[164,1]+Iif(lId1449, "/"+aCodFol[1449,1], "")) .And. x[3] == cSemana .And. X[9] # "D" .And. !Empty(x[10]) } ) ) > 0
		dDtPgFer := aPd[nPos, 10]
	EndIf

   	//Se existe inss outras empresas, inss férias e inss na folha, 
	If nInssFOut > 0 .and. nInssFer > 0 
		//verifico se lançou INSS no calculo das ferias
		nInssFer += nInssFOut
	EndIf
   	
   	If  Type("cInssFM") # "U" 
	   	If cInssFm == "R" .and. nInssf_b <> 0 .and. nInssFer == 0 .and.  nPosFer > 0 
			cInssOri := "R"
			cInssFM	 := "N"		
		EndIf
		//Se MV_DINSSFM for R ou S, não existir INSS Férias calculado e existir verba referente a férias
		If cInssFm $ "R*S" .and. nInssf_b > 0 .and. nInssFer == 0
			//Verifica se a verba de férias foi lançada, indicando ser 1/3 pago separado referente a MP e altera cInssFm para "N" para que o INSS sobre férias seja gerado.
			If aScan(aPd, {|x| x[7] == "I" .and. RetValSRV(x[1],SRA->RA_FILIAL,"RV_REFFER") == "S" .and. RetValSRV(x[1],SRA->RA_FILIAL,"RV_INSSFER") == "1"}) > 0
				cInssOri := cInssFm
				cInssFm := "N"
			EndIf
		EndIf
	EndIf
   	
   	//-- Quando Tem Inss de ferias e menor que o Inss do Mes abate o Inss de ferias
	If nInssFer > 0.00 .And. nInss >= nInssFer
   	    //-- Abate os valores de Ded. Inss Ferias, informado ou gerado pela rotina de ferias 
   	    //-- Se o parametro MV_DINSSFM estiver com "S", descontar apenas o inss referente ao mes.
		If Type("cInssFM") # "U" .and. (cInssFM == "S" .OR. cInssFM == "R")
			nInss -= nInssFer
			nInss1  -= If(nInssf > 0,nInssf, nInssfer)     //Deducao INSS para desconto base IRF Folha, ID 167
			nInssf1	:= If(nInssf > nInssfer, nInssf - nInssfer, nInssfer)   //Deducao INSS para desconto base IRF Ferias, ID 168
			Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[7] = "K" .And. X[9] # "D",x[5],0.00) })
			//Se a origem da verba é F veio do fechamento, indicando que foi originado da verba de INSS Férias mês seguinte. Como o INSS já foi deduzido integralmente na folha anterior, não efetua nova dedução.
			Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[65,1] .And. X[3] = cSemana .And. X[7] = "F" .And. X[9] # "D",x[5],0.00) })
			lTetoINSS := lMultv .And. Round(nInss,2) == 0.00
		Else
			If nInssf_b > 0.00 
				If  nInss_b > 0.00 .or. nInssFer < nInss //(Se a base for nula e o inss for maior que o inssfer, significa que não houve dias trabalhados porém houve alteração na tabela de inss ou salário )
					//-- Se informou o Inss Outras Empresas Nao Considera a Base de Outras Empresas
					nBaseTot := If( nInssOut > 0 , Max( nBaseTot - nBaseOut , 0 ) , nBaseTot )  
					//-- Proporciona INSS conforme peso das bases de calculos de Folha/Ferias
					If nInss_b <= 0
						nInssf  := nInss
					Else
						If !lMultv .and. LCALCCOMPL //Se for complementar, pega o valor de INSS férias pago na primeira folha
							nInssf  := fGetPdSRC(aCodFol[65,1])
							If nInssf == 0
								NoRound( (nInssf_b / nBaseTot ) * nInss )
							EndIf
						Else
							nInssf  := NoRound( (nInssf_b / nBaseTot ) * nInss )
						EndIf
					EndIf
					nInss   -= nInssf                 
				 	//Marca como deletada verba de INSS Ferias calculada anteriormente
					Aeval( aPd ,{ |X| If (x[1] $ aCodFol[65,1] .And. X[3] = cSemana .And. X[9] # "D",x[9]:= "D","") })
				 	//Gera novamente a verba
					fMatriz(aCodFol[65,1],nInssf,nAliq)
					
					If nInssf1 == 0.00     
						nDiasMs	:= 0
					   	//-- Verifica se existe ferias mes seguinte
						If Type("aDiffer") <> "U" 
							Aeval( aDiffer,{|x|nDiasMs+=x[3]} )
						EndIf
						If nDiasMs > 0 
							If Ascan( aPd, { |x| x[1] == aCodFol[88,1] .And. X[3] = cSemana .And. X[5] > 0 .And. X[9] # "D" } ) > 0
								//Deducao INSS para desconto base IRF Folha, ID 167
								Aeval( aPd ,{ |X| nInss1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And.  X[9] # "D" ,x[5],0.00) })
							Else
								nInssf1 := 0
								Aeval( aPd ,{ |X| nInssf1 += If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And.  X[9] # "D" ,x[5],0.00) })
								//-- Proporciona deducao do INSS conforme peso das bases de calculos de Folha/Ferias 
								nInssf1 := Min(nInssf1,NoRound( (nInssf_b / nBaseTot ) * nInss1 ))
								//Deducao INSS para desconto base IRF Folha, ID 167
								nInss1  -= Max(nInssf1,0)
							EndIf
							nInssf1 := 0
						Else  
						  	//Deducao INSS para desconto base IRF Ferias, ID 168
							nInssf1:= ninssf
							Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[9] # "D",x[5],0.00) })
							//Deducao INSS para desconto base IRF Folha, ID 167
							nInss1  -= Max(ninssf,0) 
						EndIf
					EndIf
				Else
				  	//Se a base no calculo da folha for Nula ou Negativa, não ocorreu proventos
				   	//resultando em insuficiente de saldo e portanto vale o inss de férias se houver
				   	//não existira inss de folha
					nInss1 := 0
					nInss  := 0	
				EndIf
			EndIf
		EndIf  
	//--Quando o Inss de Ferias For maior que o Inss do Mes, apagar os Inss de Ferias e 
	//--Gerar um novo com o valor total do Mes	   	
	Elseif nInssFer > 0.00 .And. nInss < nInssfer	   	
		If  (nNumFer > 1)  //Mais de uma ferias no mes
			Aeval( aPd ,{ |X| nInsfeFec+= If (x[1] $ aCodFol[065,1] .And. X[3] = cSemana .And. X[7] == "V" .And. X[9] # "D", x[5],0.00)})
		EndIf   	                           
		
		If nInsfeFec > 0.00 .and. nInss > 0.00 
			//Preservar o valor do INSS das ferias que veio do fechamento.
			//Gravar na verba de inss das ferias do calculo das ferias a diferença entre o teto e o inss ferias do fechamento.        
			//para nao recolher mais o que o teto.
			Aeval( aPd ,{ |X| If (x[1] $ aCodFol[065,1] .And. X[3] = cSemana  .And. X[7] == "K" .And. X[9] # "D",x[9]:= "D","") })
			fMatriz(aCodFol[65,1],nInss-nInsfeFec,nAliq,,,,"C",,,,.T.,"1")	
			If nInssf1 <= 0.00// Deducao INSS para IRF Ferias
				nInssf1 := nInss
				Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[7] = "K" .And. X[9] # "D",x[5],0.00) })		   	
			EndIf
			nInss := 0.00   
			nInss1:= 0.00     
		ElseIf nInss > 0.00 .Or. (nInss <= 0  .And. nInssFer > 0.00)
			
        	If nInss_b > 0.00 
				//-- Se o INSS Ferias for maior que o da Folha, provavelmente ocorreram ferias e ferias mes seguinte
				//-- e licenca remunerada (Por exemplo, ferias em dezembro e MV_DIA2501 = 'S'. Pagamos 30 de ferias
				//-- e 1 dia de licenca remunerada. Nas ferias, paga-se 30 dias de ferias. Na folha paga-se 29 dias ferias
				//-- e 1 dia de licenca. A base de INSS folha ficara menor que a base de ferias por conta do 1/3 ferias
				//-- das ferias mes seguinte que somente sera tratado no proximo mes).
				If nInss < nInssfer
					//-- Se a verba Id.1412 (Devolucao Inss Ferias) estiver cadastrada mantem o valor do Inss que foi
					//-- calculado nas ferias e gera a diferenca nessa verba que precisa ser cadastrada como provento
					//-- Antes desse ajuste a diferenca do valor calculado a maior era devolvida atraves do liquido
					If cInssFM $ "S/R" .And. Len(aCodfol) >= 1412 .And. !Empty(aCodfol[1412,1])
						fMatriz(aCodfol[1412,1],nInssfer - nInss)
						nInss := 0.00
						nInss1:= 0.00
					Else
						//-- Proporcionaliza dias de ferias/dias de folha, a partir do valor de verbas de FERIAS
						nInssf  := NoRound( (nInssf_b / nBaseTot ) * nInss )
						nInss   -= nInssf
						nInssf1 := NoRound( (nInssf_b / nBaseTot ) * nInss1 )
						nInss1  -= nInssf1         
						Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[7] = "K" .And. X[9] # "D",x[5],0.00) })		   	
						//-- Substitui o INSS de ferias pelo proporcionalizado, mas mantem o DED IR INSS Ferias
						Aeval( aPd ,{ |X| If (x[1] $ aCodFol[065,1] .And. X[3] = cSemana .And. X[9] # "D",x[9]:= "D","") })
						fMatriz(aCodFol[65,1],nInssf)
					EndIf
				Else					
					Aeval( aPd ,{ |X| If (x[1] $ aCodFol[065,1] .And. X[3] = cSemana .And. X[9] # "D",x[9]:= "D","") })
					fMatriz(aCodFol[65,1],nInss)
					If nInssf1 <= 0.00 // Deducao INSS para IRF Ferias
						nInssf1 := nInss
						Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[7] = "K" .And. X[9] # "D",x[5],0.00) })		   	
					EndIf	
				EndIf
			Else
				If cInssFM $ "S/R" .And. Len(aCodfol) >= 1412 .And. !Empty(aCodfol[1412,1])
					fMatriz(aCodfol[1412,1],nInssfer - nInss)
				//Se a base no calculo da folha for Nula ou Negativa, não ocorreu proventos
			   	//resultando em insuficiente de saldo e portanto deve recalcular o inss das ferias
				ElseIf cInssFM == "N" .And. ( !(DiasTrab == 0 .And. nDiasMes >= 30) .OR. nInssOut == 0 )
					//-- Proporcionaliza dias de ferias/dias de folha, a partir do valor de verbas de FERIAS
					nInssf  := Min(NoRound( (nInssf_b / nBaseTot ) * nInss ),nInss)
					nInss   -= nInssf
					nInssf1 := NoRound( (nInssf_b / nBaseTot ) * nInss1 )
					nInss1  -= nInssf1         
					Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[7] = "K" .And. X[9] # "D",x[5],0.00) })		   	
					//-- Substitui o INSS de ferias pelo proporcionalizado, mas mantem o DED IR INSS Ferias
					Aeval( aPd ,{ |X| If (x[1] $ aCodFol[065,1] .And. X[3] = cSemana .And. X[9] # "D",x[9]:= "D","") })
					fMatriz(aCodFol[065,1],nInss)
				EndIf
				nInss1 := 0
				nInss  := 0	
			EndIf			
		EndIf

	Else
		//-- Proporcionaliza Inss de Ferias e Salario

		If (nInssf_b > 0.00 .and. nInss_b > 0.00 )
			//-- Se informou o Inss Outras Empresas Nao Considera a Base de Outras Empresas
			nBaseTot := If( nInssOut > 0 , Max( nBaseTot - nBaseOut , 0 ) , nBaseTot )
			 // recalcular somente se for diferente de rateio, ou no IR_MULTV, caso contrario nao gera valor de Inss ferias para ratear
			If !(cInssFM $ "R*S") .Or. (aScan( aPd, {|x| x[1] == aCodFol[164,1]} ) == 0 .And. If(lId1449, aScan( aPd, {|x| x[1] == aCodFol[1449,1]} ) == 0, .T.) .And. IsInCallStack('MULTV'));
			   .Or. SRA->RA_TPCONTR == "3"
				nInssf  := NoRound( (nInssf_b / nBaseTot ) * nInss )
			Else				
				Aeval( aPd ,{ |X| nInssf += If (x[1] $ aCodFol[65,1] .And. X[3] = cSemana, x[5] ,0.00) })
			Endif					
			nInss   -= nInssf
			If !(cInssFM $ "R*S") .Or. SRA->RA_TPCONTR == "3" // recalcular somente se for diferente de rateio
				nInssf1 := NoRound( (nInssf_b / nBaseTot ) * nInss1 )	
			Else
			  Aeval( aPd ,{ |X| nInssf1 += If (x[1] $ aCodFol[65,1] .And. X[3] = cSemana, x[5] ,0.00) })
			Endif	
			nInss1  -= nInssf1         
			Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[7] = "K" .And. X[9] # "D",x[5],0.00) })

			//Se for férias do próximo período, já deduziu o INSS de férias durante o cálculo das férias.
			//Portanto não gera dedução de INSS Férias novamente 
			If nPosFer > 0 .And. !(cInssFM $ "R*S")
				//Verifica se não teve aumento salarial no próximo período das férias.
				If (nPos:= Ascan( aPd, { |x| x[1] == aCodFol[88,1] .And. X[3] = cSemana .And. X[9] # "D" } )) == 0
					// Em caso afirmativo, zera a variável de dedução INSS para não deduzir novamente, pois já foi feito no cálculo das férias.
					nInssf1 := 0
				Else
				//Caso exista a diferença de férias, verifica se o valor descontado de INSS nas férias foi o teto
					nId0168 := fBusInsFer(dDtPgFer)
					//Se for o teto, zera a dedução, pois já foi deduzido
					If nId0168 == nTetoInss
						nInssf1 := 0
					EndIf
				EndIf
			EndIf

			//-- Teve aumento nas ferias de 30 dias
			//-- Vai existir diferenca para ser apurado INSS da folha e das ferias.
			//-- Na folha devera ser listadas as Deducoes de INSS de Ferias gerada pelas ferias e gerada pela folha (devido ao aumento)
			If lAumFer
				fMatriz(aCodFol[168,1],nInssf1,,,,,"C",,,,.T.,"1")	
			EndIf	
		Elseif nInssf_b > 0 .And. nInss_b <= 0
			//--Quando tem apenas base de Inss sobre ferias  
			//--NAO teve aumento nas ferias de 30 dias
			If !lAumFer
				If ( DiasTrab + nDiasPg + nDiasLRem ) == 0 .And. nDiasMes == 30 .And. cSitFolh $ "A*F" .And. ( nPosInc := aScan( aPd, { |x| x[1] $ aCodFol[65,1] .And. x[3] == cSemana .And. x[7] == "I" } ) ) > 0
					aEval( aPd, { |x| If( x[1] $ aCodFol[65,1] .And. x[3] == cSemana .And. x[7] == "I", nFerInc += x[5], NIL ) } )
					nInss := nFerInc
					nAliq := aPd[nPosInc, 4]
				EndIf
				nInssf := nInss
				nInssf1:= nInss
				nInss1 := 0
				nInss  := 0			
			Else 
				//-- Teve aumento nas ferias de 30 dias
				If nInss > 0.00
				   	Aeval( aPd ,{ |X| If (x[1] $ aCodFol[065,1] .And. X[3] = cSemana .And. X[9] # "D",x[9]:= "D","") })
			   		FMatriz(aCodfol[65,1],nInss,nAliq)    
		   			If nInssf1 <= 0.00 // Deducao INSS para IRF Ferias
				   		nInssf1 := nInss
							Aeval( aPd ,{ |X| nInssf1 -= If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[7] = "K" .And. X[9] # "D",x[5],0.00) })		   	
				  		fMatriz(aCodFol[168,1],nInssf1,,,,,"C",,,,.T.,"1")	
					EndIf
				EndIf		
		   		nInss := 0.00   
		   		nInss1:= 0.00   			
			EndIf	
		//-- Proporcionaliza Inss de Outras Empresas e Salario
		ElseIF nBaseOut > 0.00 .and. nInss_b > 0.00 .and. nInssOut == 0.00
			nInss_Ou	:= NoRound( ( nBaseOut / nBaseTot ) * nInss )
			nInss		-= nInss_Ou
			nInss_O1	:= NoRound( ( nBaseOut / nBaseTot ) * nInss1 )
			nInss1		-= nInss_O1
		EndIf
	EndIf
	
	//Se existe inss outras empresas, inss férias e não existe inss na folha, subtrai o inss outras empresas do inss férias.
	If nInssOut > 0 .and. nInss == 0 .and. nInssF == 0 .and. nInssFer >= nInssOut  .And. !(cInssFM $ "S/R" .And. Len(aCodfol) >= 1412 .And. !Empty(aCodfol[1412,1]))
		//Excluir verbas de dedução e inss férias
		Aeval( aPd ,{ |X| If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[9] # "D",x[9]:= "D","") })
		Aeval( aPd ,{ |X| If (x[1] $ aCodfol[065,1] .And. X[3] = cSemana .And. X[9] # "D",x[9]:= "D","") })
		nInssf1 := nInssF := Iif( nBaseTot > nBaseTeto, nTetoInss - nInssOut - nInssFOut, nInssFer - nInssOut - nInssFOut )
	EndIf		

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Semanalistas ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SRA->RA_TIPOPGT = "S"
		If Ascan( aPd, { |x| x[1] == aCodFol[065,1] .And. x[3] # cSemana } )  > 0 .And. SRA->RA_TPCONTR <> "3" // Para contrato intermitente, não soma o INSS das Férias com o INSS da Folha.
			nInss  += nInssf
			nInss1 += nInssf1
			nInssf := nInssf1 := 0
		EndIf
	
		If cTipoRot == "4"
			Aeval( aPdSemAnt,{ |X| nAteAnt  += If(X[1] == aCodFol[013,1] .And. X[3] < cSemana .And. X[9] # "D",X[5],0)} )
			Aeval( aPdSemAnt,{ |X| nAciAnt  += If(X[1] == aCodFol[014,1] .And. X[3] < cSemana .And. X[9] # "D",X[5],0)} )
			Aeval( aPdSemAnt,{ |X| nInssAnt += If(X[1] $  aCodFol[064,1]+"*"+aCodFol[065,1] .And. X[3] < cSemana .And. X[9] # "D",X[5],0)} )
			Aeval( aPdSemAnt,{ |X| nInssAnt1+= If(X[1] $  aCodFol[167,1]+"*"+aCodFol[168,1] .And. X[3] < cSemana .And. X[9] # "D",X[5],0)} )
		Else
			Aeval( aPD,{ |X| nAteAnt  += If(X[1] == aCodFol[013,1] .And. X[3] < cSemana .And. X[9] # "D",X[5],0)} )
			Aeval( aPD,{ |X| nAciAnt  += If(X[1] == aCodFol[014,1] .And. X[3] < cSemana .And. X[9] # "D",X[5],0)} )
			If SRA->RA_TPCONTR <> "3" 
				Aeval( aPD,{ |X| nInssAnt += If(X[1] $  aCodFol[064,1]+"*"+aCodFol[065,1] .And. X[3] < cSemana .And. X[9] # "D",X[5],0)} )
				Aeval( aPD,{ |X| nInssAnt1+= If(X[1] $  aCodFol[167,1]+"*"+aCodFol[168,1] .And. X[3] < cSemana .And. X[9] # "D",X[5],0)} )
			Else
				aEval( aPD, { |x| nInssAnt += Iif( x[1] == aCodFol[064,1] .And. x[3] < cSemana .And. x[9] != "D", X[5], 0 ) } )
				aEval( aPD, { |x| nInssAnt2 += Iif( x[1] == aCodFol[065,1] .And. x[3] < cSemana .And. x[9] != "D", X[5], 0 ) } )
				aEval( aPD, { |x| nInssAnt1 += Iif( x[1] == aCodFol[167,1] .And. x[3] < cSemana .And. X[9] != "D", X[5], 0 ) } )
				aEval( aPD, { |x| nInssAnt3 += Iif( x[1] == aCodFol[168,1] .And. x[3] < cSemana .And. X[9] != "D", X[5], 0 ) } )
			EndIf
		EndIf

		nBaseAt -= nAteAnt
		nBaseAc -= nAciAnt
		nInss   -= nInssAnt      
		nInss1	-= nInssAnt1
		If SRA->RA_TPCONTR == "3"
			nInssf	-= nInssAnt2      
			nInssf1	-= nInssAnt3
			If nBaseAc > 0 .And. nBaseAt == 0
				nInss := nInss1 := nInssf := nInssf1
			EndIf
		EndIf
    EndIf

	If lRescDis 
		If lProxMes
			FMatriz(aCodfol[ 338,1],nBaseAt+nBaseAc)
		Else
			If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[14,1] ))
				FMatriz(aCodfol[338,1], Max(nBaseAc - SRR->RR_VALOR, 0) , , , , ,"R" )		
				FMatriz(aCodfol[ 14,1], SRR->RR_VALOR)
				FMatriz(aCodfol[ 13,1], nBaseAt)			
			Else
				If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[13,1] ))
 					FMatriz(aCodfol[338,1], Max((nBaseAt + nBaseAc) - SRR->RR_VALOR, 0) , , , , ,"R" )//Base INSS 13 Acima Dissidio
					FMatriz(acodfol[013,1], SRR->RR_VALOR )
				EndIf
			EndIf                    
		EndIf	
	Else
  		FMatriz(aCodfol[ 13,1],nBaseAt)
		FMatriz(aCodfol[ 14,1],nBaseAc)
	EndIf
	
	If Round(nInss,2) > 0.00
		If lDissidio 
	    	If (nPosPd:= aScan(aPd ,{|X| X[1] = aCodfol[167,1] })) > 0
	    		If aPd[nPosPd][5] > nInss1
	    			nAxINSS := aPd [nPosPd][5] - nInss1
	    			nInss   := aPd [nPosPd][5]
	    			nInss1  := aPd [nPosPd][5]
	    			nInssF  := nInssF - nAxINSS
	    		EndIf
	    	EndIf
	    EndIf	
		If lRescDis 
			If lProxMes
				FMatriz(aCodfol[ 340,1],nInss,nAliq)
			Else
				If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[64,1] ))
					FMatriz(aCodfol[340,1], Max(nInss - SRR->RR_VALOR, 0 ) , , , , ,"R" )		
					FMatriz(aCodfol[ 64,1],SRR->RR_VALOR,nAliq)
				EndIf	
			EndIf	
		Else
			FMatriz(aCodfol[ 64,1],nInss,nAliq)
		EndIf
	EndIf

	//-- Verifica se existe verba de Dif. INSS Dissidio
	//   a Verba de Ferias Mes Seguinte
	If !(cCompl = "S"  .And. (lRescDis .or. lRecInss .Or. lProxMes))
		If ( nPosPd := Ascan(aPd,{ |X| X[1] == aCodfol[340,1] .And. X[3] = cSemana .And. X[9] # "D"})) > 0
			If	!(RetValSRV(aCodFol[340,1],SRA->RA_FILIAL,"RV_IR") == "S") //SE TIVER INCIDÊNCIA IGNORA, POIS JÁ FOI SOMADO
				nInss1 += aPd[nPosPd,5]
			EndIf
		EndIf	
	EndIf
	
	nDedFer := 0 //Valor da verba de dedução INSS férias
	
	If P_LIMTET .and. nInssFer > 0 //Se deve limitar a dedução ao teto
		Aeval( aPd ,{ |X| nDedFer += If (x[1] $ aCodFol[168,1] .And. X[3] = cSemana .And. X[7] = "K" .And. X[9] # "D",x[5],0.00) })
	EndIf
	
    // Deducao INSS IR Folha
	If !lResExt
		If Round(nInss1,2) > 0.00
			FMatriz(aCodfol[167,1],Min(nInss1, nTetoInss - nDedFer)) //Se for para limitar ao teto, subtrai a diferença da dedução de inss férias
		Else
	   		//Busca o valor gravado na verba de INSS Folha
	   		Aeval( aPd ,{ |X| nInssFol += If (x[1] $ aCodFol[64,1] .And. X[3] = cSemana .And. X[9] # "D",x[5],0.00) })
	   		If nInssFol > 0
				FMatriz(aCodfol[167,1],Min(nInssFol, nTetoInss - nDedFer))   		
	   		EndIf
		EndIf
	Else
		If Round(nInss1,2) > 0.00 .and. lDedInssEx .and. lIrResExt
			FMatriz(aCodfol[167,1],Min(nInss1, nTetoInss - nDedFer))
		ElseIf lDedInssEx .and. lIrResExt
			//Busca o valor gravado na verba de INSS Folha
			Aeval( aPd ,{ |X| nInssFol += If (x[1] $ aCodFol[64,1] .And. X[3] = cSemana .And. X[9] # "D",x[5],0.00) })
			If nInssFol > 0
				FMatriz(aCodfol[167,1],Min(nInssFol, nTetoInss - nDedFer))
			EndIf	 
		Endif
	Endif

	// INSS Ferias
	If Round(nInssf,2) > 0
		If SRA->RA_TPCONTR <> "3"
			FMatriz(aCodfol[65,1],nInssf,nAliq)
		Else
			//Se a semana for acima da primeira e já tiver atingido o teto do INSS, zera a variável de INSS para não gerar descontos.
			If cSemana > "01" .And. nInssAnt >= nTetoInss
				nInssf  := 0
				nInssf1 := 0
			Else
				FMatriz(aCodfol[65,1],nInssf,nAliq)
			EndIF
		EndIf
	EndIf
	If lIntTaf .And. RetValSrv( aCodfol[65,1], SRA->RA_FILIAL, "RV_INCIRF" ) == "43" .And. Len(aCodFol) >= 1723 .And. !Empty(aCodfol[1723,1])
		nVl0065 := Abs(FBuscaPD( aCodfol[65,1] ))
		If nVl0065 > 0
			FMatriz(aCodfol[1723,1], nVl0065)
		EndIf
	EndIf

   // Deducao INSS IR Ferias	
	If Round(nInssf1,2)	 > 0
		If !lResExt .Or. (lDedInssEx .And. lIrResExt)
			//Caso haja a verba de Diferenca de Ferias, gera uma nova verba de Deducao INSS Base IR Ferias		
			If (nPos:= Ascan( aPd, { |x| x[1] == aCodFol[88,1] .And. X[3] = cSemana .And. X[5] > 0 .And. X[9] # "D" } ))  > 0
				FMatriz(aCodfol[168,1],nInssf1, Nil, Nil, Nil, Nil, "C", Nil, Nil, Nil, Nil, "1")		
			//Caso o valor de INSS Ferias seja maior do que o apurado anteriormente, gera uma nova verba de Deducao INSS Base IR Ferias com a diferenca dos valores
			ElseIf nInssf1 == nInssf .And. 	nInssf1 > nInssfer .And. nPosInc == 0
				FMatriz(aCodfol[168,1], nInssf1 - nInssfer, Nil, Nil, Nil, Nil, "C", Nil, Nil, Nil, Nil, "1")
			Else
				//Caso haja mais de um calculo de ferias e nao foi carregado o INSS de Ferias devido a outra ferias partidas e haja a verba de Deducao INSS Base IR Ferias
				//gerada pelo calculo de ferias marca a verba com flag de deletada para regravar a verba com o valor atualizado. 
				If nNumFer > 1 .And. ( ( nPos := Ascan( aPd, { |x| x[1] == aCodFol[168,1] .And. X[3] == cSemana .And. X[7] == "K" .And. X[9] # "D" } ) ) > 0 )
					aPd[nPos][9] := "D"
				Endif
				//Verifica se o desconto do INSS das Férias já é o teto do INSS.
				If nInssFer == nTetoInss .And. !lDissidio .And. ( ( nPos := Ascan( aPd, { |x| x[1] == aCodFol[168,1] .And. X[3] == cSemana .And. X[7] == "K" .And. X[9] # "D" } ) ) > 0 )
					aPd[nPos][5] := nInssf1
				Else	
					FMatriz(aCodfol[168,1],nInssf1, Nil, Nil, Nil, Nil, "C", Nil, Nil, Nil, Nil, "1")
				EndIf
			EndIf
		EndIf
	EndIf
			
EndIf

If Type("cInssFM") # "U" .and. cInssFm == "N" .and. cInssOri $ "R*S"
	cInssFM := 	cInssOri 		
EndIf

If !Empty(nRegAnt)
	SRG->(DbGoTo(nRegAnt))
EndIf

//Gera as verbas de INSS por faixa
If !Empty(aInssFx) .and. !Empty(aPdFx[1])
	fCInssFx(aInssFx,aPdFx)
EndIf

Return

/*/{Protheus.doc} fCInssRtf
Função que apura o INSS da retificação
@author Allyson Mesashi
@since 11/01/2019
@version P12.1.17
/*/
Function fCInssRtf(aCodfol,aTinss,lTrunca)

Local nBaseAt	:= 0.00
Local nBaseAc	:= 0.00
Local nBaseAtAnt:= 0.00
Local nBaseAcAnt:= 0.00
Local nAliq		:= 0.00
Local nBaseOut	:= 0.00
Local nInssOut	:= 0.00
Local nInss		:= 0.00
Local nInssFer	:= 0.00
Local nInssFol	:= 0.00
Local nBaseTot	:= 0.00
Local nTetoInss := 0
Local nCont    	:= 0
Local aInssFx	:= {}
Local aPdFx		:= {aCodFol[1734,1], aCodFol[1735,1], aCodFol[1736,1], aCodFol[1737,1]}

lResExt		:= If( Type("lResExt") 		== "U"	, .F., lResExt)
lDedInssEx	:= If( Type("lDedInssEx") 	== "U"	, .F., lDedInssEx)
lIrResExt	:= If( Type("lIrResExt") 	== "U"	, .T., lIrResExt)
lInssAut	:= If( Type("lInssAut") 	== "U"	, .T., lInssAut)

// Para os casos em que o funcionário não é autonomo, pode haver acordo
// Entre o Brasil e outros paises, para o não desconto do INSS.
// Para tratar esses acordos o campo RA_INSSAUT é utilizad.
// Se estiver com NÃO, NÃO deverá calcular INSS, independente do RA_CATFUNC.
If cPaisLoc == "BRA" .and. (!lInssAut)
	Return
EndIf

//--Situacao do Funcionario na data de referencia
lTrunca 	:= If (lTrunca = Nil , .T. , lTrunca)

//Variável do TETO do INSS.
nTetoInss := fRetTetIns(aTinss)

If Ascan(aPd,{ |X| X[1] == aCodfol[64,1] .And. X[3] == cSemana .And. X[9] # "D"}) = 0
	
	For nCont := 1 To Len(aPd)
		If !Empty( aCodFol[288,1] ) .And. aPd[nCont, 1] == aCodFol[288,1] .and. aPd[nCont, 9] # "D"//Base Inss Outras Empresas
			nBaseOut += aPd[nCont, 5]
		EndIf
		If !Empty( aCodFol[289,1] ) .And. aPd[nCont, 1] == aCodFol[289,1] .and. aPd[nCont, 9] # "D"//Inss Outras Empresas
			nInssOut += aPd[nCont, 5]
		EndIf
		If aPd[nCont, 1] == aCodFol[13,1] .and. aPd[nCont, 9] # "D"//Base Inss Até o Limite
			nBaseAtAnt += aPd[nCont, 5]
		EndIf
		If aPd[nCont, 1] == aCodFol[14,1] .and. aPd[nCont, 9] # "D"//Base Inss Acima do Limite
			nBaseAcAnt += aPd[nCont, 5]
		EndIf
		If aPd[nCont, 1] == aCodFol[64,1] .and. aPd[nCont, 9] # "D"//Inss Fol
			nInssFol += aPd[nCont, 5]
		EndIf
		If aPd[nCont, 1] == aCodFol[65,1] .and. aPd[nCont, 9] # "D"//Inss Ferias
			nInssFer += aPd[nCont, 5]
		EndIf
	Next nCont

	nInss_b := nInssf_b := 0.00
	
	Aeval( aPd ,{ |X| SomaInc(X,4,@nInss_b  ,11,"N",12,"N", , ,aCodfol) })
	Aeval( aPd ,{ |X| SomaInc(X,4,@nInssF_b ,11,"S", , , , ,aCodFol) })
	
	//-- Funcao para calcular o inss
	nInss := nInssf := nInss1 := nBaseAt := nBaseAc := nInssf1 := nBaseTot := 0.00
	nBaseTot += ( nInss_b + nInssf_b + nBaseOut )
	
	Calc_Inss(aTInss,nBaseTot,@nInss,Nil,@nBaseAt,@nBaseAc,@nAliq,nBaseOut,lTrunca,,@aInssFx)                                       

	nBaseAt := Max(nBaseAt - nBaseAtAnt, 0)
	nBaseAc := Max(nBaseAc - nBaseAcAnt, 0)
	
	If nBaseAt > 0
		FMatriz(aCodfol[ 13,1],nBaseAt)
	EndIf
	If nBaseAc > 0
		FMatriz(aCodfol[ 14,1],nBaseAc)
	EndIf

	nInss := Max(nInss - (nInssFol + nInssFer + nInssOut), 0)
	
	If nInss > 0
		FMatriz(aCodfol[64,1],nInss,nAliq)

		//Gera as verbas de INSS por faixa
		If !Empty(aInssFx) .and. !Empty(aPdFx[1])
			fCInssFx(aInssFx,aPdFx)
		EndIf
	EndIf		
EndIf

Return


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fCInss13 ³ Autor ³ Equipe RH             ³ Data ³20/05/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do Inss Funcionario 13o                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCInss13(aCodfol)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³1 - aCodFol  - Array com os Identificadores de Calculo      ³±±
±±³          ³2 - aTabInss - Array com os Valores da Tabela de INSS       ³±±
±±³          ³3 - lCond    - Condicao para SomaInc                        ³±±
±±³          ³4 - nInssAnt   - Valor do Inss ja Descontado                  ³±±
±±³          ³5 - nBAtLimA  - Valor da Base Ate o Limite ja Calculada      ³±±
±±³          ³6 - nBAcLimA  - Valor da Base Acima do Limite ja Calculada   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCInss13(aCodfol,aTinss,lCond,nInssAnt,nBAtLimA,nBAcLimA,lTrunca)

Local nAliq			:= 0.00
Local nBaseOut		:= 0.00
Local nBaseOAt		:= 0.00
Local nBaseOAc		:= 0.00
Local nBaseOIn		:= 0.00
Local nInssOut		:= 0.00
Local nBaseTot		:= 0.00
Local nInss_Ou		:= 0.00 
Local nInss_O1		:= 0.00
Local nDedInss		:= 0.00       
Local nPos			:= 0
Local cVerba13		:= ""
Local cTmpAlias		:= ""
Local aPerAberto	:= {}
Local aPerFechado	:= {}
Local aVerbasLanc	:= {}
Local aInssFx		:= {}
Local aPdFx			:= {aCodFol[1742,1], aCodFol[1743,1], aCodFol[1744,1], aCodFol[1745,1]}
Local lTemId1672	:= Len(aCodFol) >= 1672 .And. !Empty(aCodFol[1672, 1])

Private lRecInss := GetNewPar('MV_INSSREC',.F.)  // Recalculo INSS quando rescisao complementar

lResExt	:= If( Type("lResExt") 		== "U"	, .F., lResExt)
lDedInssEx	:= If( Type("lDedInssEx") 	== "U"	, .F., lDedInssEx)
lIrResExt	:= If( Type("lIrResExt") 	== "U"	, .T., lIrResExt)
lInssAut	:= If( Type("lInssAut") 	== "U"	, .T., lInssAut)
lRecRes		:= If( Type("lRecRes") 	== "U"	, .F., lRecRes)
cCompl		:= If( Type("cCompl") 	== "U"	, "N", cCompl)
lDissidio	:= If(lDissidio == Nil,.F.,lDissidio)

// Para os casos em que o funcionário não é autonomo, pode haver acordo
// Entre o Brasil e outros paises, para o não desconto do INSS.
// Para tratar esses acordos o campo RA_INSSAUT é utilizad.
// Se estiver com NÃO, NÃO deverá calcular INSS, independente do RA_CATFUNC.
If cPaisLoc == "BRA" .and. (!lInssAut)
	Return
EndIf

//Caso seja complemento e possua a verba de complemento incluída manualmente, despreza quaisquer diferenças geradas pelo sistema
If cPaisLoc == "BRA" .And. cTipoRot == "6" .And. P_CCOMP13 == 'S' .And. lCalcFol .And. fTem132Per() .And. (aScan(aPd, {|X| X[1] == aCodFol[028,1] .And. X[9] <> "D" .And. X[7] == "I"}) > 0) .And. RetValSrv(aCodFol[028,1], SRA->RA_FILIAL, "RV_REF13") == "S"
	fVldCompaPd()
EndIf

lTrunca 	:= If (lTrunca = Nil , .T. , lTrunca)

lRescDis	:= If( type("lRescDis")=="U",.F.,lRescDis)//Rescisao Complementar por Dissidio

If cCompl == "S" 
	nInssP		:= If( nInssAnt	== NIL, 0.00, nInssAnt	)	//Inss ja Pago Para Deduzir do Valor Calculado
	nBAtLim		:= If( nBAtLimA	== NIL, 0.00, nBAtLimA	)	//Base Ate Limite Para Deduzir do Valor Calculado
	nBAcLim		:= If( nBAcLimA	== NIL, 0.00, nBAcLimA	)	//Base Acima Limite Para Deduzir do Valor Calculado
Else
	nInssP		:= If( nInssAnt	== NIL, nInssP, nInssAnt	)	//Inss ja Pago Para Deduzir do Valor Calculado, se não for informado, utiliza o mnemonico
	nBAtLim		:= If( nBAtLimA	== NIL, nBAtLim, nBAtLimA	)	//Base Ate Limite Para Deduzir do Valor Calculado
	nBAcLim		:= If( nBAcLimA	== NIL, nBAcLim, nBAcLimA	)	//Base Acima Limite Para Deduzir do Valor Calculado
EndIf

lCond		:= If( lCond	== NIL, .T. , lCond		)	//Se deseja condicao na Somainc
nInss13_b	:= 0.00

If !Empty( aCodFol[290,1] ) //Base Inss Outras Empresas 13o. Salario
	aEval( aPD , { |x| nBaseOut += If( x[1] == aCodFol[290,1] .and. x[9] # "D", x[5] , 0.00 ) } )
	If nBaseOut == 0 .and. fTem132Per() .and. P_CCOMP13 == 'S' .And. SRA->RA_TPCONTR <> "3"
		fBuscaAcmPer(aCodFol[290,1],"","V",@nBaseOut,,cPeriodo,cPeriodo,,,fGetCalcRot("6"),.T.,.F.)
	EndIF
EndIf

If !Empty( aCodFol[291,1] ) //Inss Outras Empresas 13o. Salario
	aEval( aPD , { |x| nInssOut += If( x[1] == aCodFol[291,1] .and. x[9] # "D", x[5] , 0.00 ) } )
	If nInssOut == 0 .and. fTem132Per() .and. P_CCOMP13 == 'S' .And. SRA->RA_TPCONTR <> "3"
		fBuscaAcmPer(aCodFol[291,1],"","V",@nInssOut,,cPeriodo,cPeriodo,,,fGetCalcRot("6"),.T.,.F.)
	EndIF
EndIf

// Rescisao complementar por dissidio (lRescDis) ou somente complementar (lRecInss, parametro MV_INSSREC), salvar BASE E INSS ja calculados.
If cCompl = "S"  //Rescisao Complementar

	If lRescDis .or. lRecInss .Or. lProxMes .Or. ( Type("lRescRet") <> "U" .And. lRescRet)// Dissidio or Parametro MV_INSSREC como T
		Car_inss(@aTInss,MesAno(dDatadem)) // Carrregar tabela inss do mes\ano data rescisao

		aEval( aPdResc , { |x| nBaseOut += If (x[1] $ aCodFol[19,1]+"*"+ aCodFol[20,1]+"*"+ aCodFol[399,1] .and. X[3] == cSemana .and. X[9] # "D" .and. AnoMes(M->RG_DTGERAR) <> AnoMes(x[18]), x[5], 0.00)})
		aEval( aPdResc , { |x| nInssOut += If( x[1] $ aCodFol[70,1]+"*"+ aCodFol[401,1] .and. x[3] == cSemana .and. x[9] # "D" .and. AnoMes(M->RG_DTGERAR) <> AnoMes(x[18]), x[5] , 0.00 )})
	
	
		If lProxMes
			aEval( aPdResVals , { |x| nBaseOut += If (x[1] $ aCodFol[19,1]+"*"+ aCodFol[20,1] .And. X[3] = cSemana .And. MesAno(M->RG_DTGERAR) == MesAno(X[Len(X)]) .And. X[9] # "D",x[5],0.00) })
			aEval( aPdResVals , { |x| nInssOut += If( x[1] == aCodFol[70,1] .And. MesAno(M->RG_DTGERAR) == MesAno(X[Len(X)]) .and. x[9] # "D" .and. x[3] == cSemana , x[5] , 0.00 ) } )    			
		EndIf
	EndIf
    
    // Em casos de demissão no mes 12, onde a segunda parcela do 13 foi paga, as bases de INSS devem ser somadas à base apurada na complementar.
    If Month(dDataDem) == 12 .And. AnoMes(M->RG_DTGERAR) > AnoMes(dDataDem) .And. nInssP > 0 .And. nBAtLim > 0
    	nBaseOut += (nBAtLim + nBAcLim)
    	nBaseOAt := nBAtLim
    	nBaseOAc := nBAcLim
    	nBaseOIn := nInssP
    	nInssOut += nInssP
    EndIf
EndIf

If SRA->RA_TPCONTR == "3" 

	cVerba13 := "% SRD.RD_PD IN('"+ aCodFol[19,1]+"','"+ aCodFol[20,1]+"','"+ aCodFol[70,1]+"')  %"
	cTmpAlias := GetNextAlias()
	BeginSql alias cTmpAlias
		SELECT SRD.RD_PD,SRD.RD_VALOR 
		FROM %table:SRD% SRD 
		WHERE 
		%exp:cVerba13% AND SRD.D_E_L_E_T_= '' 
		AND SRD.RD_FILIAL = %exp:SRA->RA_FILIAL%
		AND SRD.RD_MAT = %exp:SRA->RA_MAT%
		AND SRD.RD_DTREF BETWEEN %exp:substr(cPeriodo,1,4)+"0101"% AND %exp:substr(cPeriodo,1,4)+"1231"%
	EndSql
	
	While !(cTmpAlias)->(Eof())
		If (cTmpAlias)->RD_PD == aCodFol[070,1]
			//nInssP += (cTmpAlias)->RD_VALOR
			nInssOut += (cTmpAlias)->RD_VALOR
		EndIf
		//--Base do Inns Ate Limite ja Descontado na 2a. Parcela
		If (cTmpAlias)->RD_PD == aCodFol[019,1]
			//nBAtLim += (cTmpAlias)->RD_VALOR
			nBaseOut += (cTmpAlias)->RD_VALOR
		EndIf
		//--Base do Inns Acima Limite ja Descontado na 2a. Parcela
		If (cTmpAlias)->RD_PD == aCodFol[020,1]
			//nBAcLim += (cTmpAlias)->RD_VALOR
			nBaseOut += (cTmpAlias)->RD_VALOR
		EndIf
		
		(cTmpAlias)->(dbSkip())
	EndDo
	(cTmpAlias)->(dbCloseArea())
EndIf

If Ascan(aPd,{ |X| X[1] = aCodfol[70,1] .And. X[3] == cSemana .And. X[9] # "D"}) = 0

	//-- Base de Inss 13o
	//--Verifica se lancou Base de Inss somando as verbas 
	nInss13_b := 0.00
	
	If !(P_CCOMP13 = 'S' .And. cRot == fGetCalcRot('6') .And. lCalcFol) .And. SRA->RA_TPCONTR <> "3" //Se estiver calculando complementar desconsidera bases lançadas
		Aeval( aPd ,{ |X| nInss13_B += If (x[1] $ aCodFol[19,1]+"*"+aCodFol[20,1] .And. X[9] # "D" ,x[5],0.00) })
	EndIf

	If nInss13_b == 0.00	
		//-- Soma Incidencia para Inss
		If SRA->RA_TPCONTR <> "3"
			Aeval( aPd ,{ |X| SomaInc(X,4,@nInss13_b,If(lCond,12,Nil),If(lCond,"S",Nil), , , , ,aCodFol) } )
		Else
			Aeval( aPd ,{ |X| SomaInc(X,4,@nInss13_b,If(lCond,12,Nil),If(lCond,"S",Nil), , , ,.F.,aCodFol) } )
			Aeval( aPdConvoc ,{ |X| SomaInc(X,4,@nInss13_b,If(lCond,12,Nil),If(lCond,"S",Nil), , , , ,aCodFol) } )
		EndIf
	EndIf
	
	//Quando for dissidio, estiver calculando a segunda parcela do 13º e utilizar reajuste de 13º pelas verbas incorporadas na folha, carrega as verbas que incorporaram na folha
	If nInss13_b >0 .and. cTipoRot $ "1*6" .and. lDissidio .and. Type("P_LDIFINC") <> "U" .And. P_LDIFINC
		fRetPerComp(SubStr(cPeriodo,5,2), SubStr(cPeriodo,1,4), Nil, Nil, fGetRotOrdinar(), @aPerAberto, @aPerFechado)
		aVerbasLanc := RetornaVerbasFunc(SRA->RA_FILIAL,SRA->RA_MAT,NIL,fGetRotOrdinar(),,aPerAberto,aPerFechado,,"RV_INCORP=='S'")
		If Len(aVerbasLanc) > 0
			If cTipoRot == "6"
				For nPos := 1 to Len(aVerbasLanc)
					nInss13_b += aVerbasLanc[nPos,7]
				Next nPos
			ElseIf IsInCallStack("GravaDissidio") .and. Len(aPercDif) > 0
				nIndice := aPercDif[Len(aPercDif),2]
				For nPos := 1 to Len(aVerbasLanc)
					nInss13_b -= ( aVerbasLanc[nPos,7] * (nIndice/100))
				Next nPos
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Afastamento por Adocao, considerar base integral              ³
 	//³nAvos = meses para calculo do 13.salario                      ³
 	//³nAvoEnc = meses afastados por adocao                          ³
 	//³nInss13_b = base do inss gerada.                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//nAvoEnc := 0
	//Aeval( aAfast ,{ |X| nAvoEnc += If( X[5] == "B", X[1], 0 ) })
	If nAvoEnc > 0 .and. nAvos > 0 .and. nInss13_b > 0  
		nInss13_b   := NoRound((nInss13_b / nAvos * (nAvos + nAvoEnc) ))
	EndIf

	//-- Funcao para calcular o Inss
	nInss := nInss1 := nBaseAt := nBaseAc := nBaseTot := 0.00
	nBaseTot += ( nInss13_b + nBaseOut + nBasAuxD1 )
	
	//Abate base de INSS calculada na rescisão complementar.
	If !Empty(SRA->RA_DEMISSA) .and. AnoMes(SRA->RA_DEMISSA) < cPeriodo .and. cTipoRot == "1"
		Aeval( aPd ,{ |X| nBaseTot -= If (x[1] == aCodFol[399,1] .And. X[9] # "D",x[5],0.00) })
	EndIf
		
	If nInss13_b > 0.00
		Calc_Inss(aTInss,nBaseTot,@nInss,@nInss1,@nBaseAt,@nBaseAc,@nAliq,nBaseOut,lTrunca,,@aInssFx)
		If nBasAuxD1 > 0
			nBaseTot -= nBasAuxD1
			Calc_Inss(aTInss,nBaseTot,0,0,@nBaseAt,@nBaseAc,0,nBaseOut,lTrunca,,aClone(aInssFx))
		EndIf

		//-- Se informou o Inss Outras Empresas Subtrai do Inss Calculado
		If nBaseOut > 0.00 .And. nInssOut > 0.00
			nInss	:= Max( nInss - nInssOut , 0 )
		
			//-- Calcular a Deducao de Inss no Ir sobre a Base da outra empresa 
			//-- Para abater da deducao total 
			If nInssOut > 0
				nDedInss := nInssOut
			Else
				nDedInss := 0.00                           
				Calc_Inss(aTInss,nBaseOut,,@nDedInss,,,,,lTrunca,,aClone(aInssFx))
			EndIf
			nInss1	:= Max( nInss1 - nDedInss , 0 )
		EndIf

		//-- Proporcionaliza Inss Salario x Outras Empresas
		If nBaseOut > 0.00 .and. nInss13_b > 0.00 .and. nInssOut == 0.00
			nInss_Ou	:= NoRound( ( nBaseOut / nBaseTot ) * nInss )
			nInss		-= nInss_Ou
			nInss_O1	:= NoRound( ( nBaseOut / nBaseTot ) * nInss1 )
			nInss1		-= nInss_O1
		EndIf
		
		If lRescDis 
			If lProxMes
				FMatriz( acodfol[399,1] ,( Max(nBaseAt - nBAtLim , 0 )+ Max(nBaseAc - nBAcLim , 0 ) ) )
				FMatriz( aCodfol[401,1] ,( Max(nInss   - nInssP  , 0 ) ) , nAliq )
			Else 
				If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[20,1] ))
					FMatriz(aCodfol[399,1], Max((nBaseAc - nBAcLim)-SRR->RR_VALOR, 0) , , , , ,"R" )//Base INSS 13 Acima Dissidio
					FMatriz(acodfol[020,1], SRR->RR_VALOR  )
					FMatriz(aCodfol[019,1],( Max(nBaseAt - nBAtLim, 0 ) ) )
				Else
					If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[19,1] ))
	 					FMatriz(aCodfol[399,1], Max((nBaseAt + nBaseAc)-SRR->RR_VALOR, 0) , , , , ,"R" )//Base INSS 13 Acima Dissidio
						FMatriz(acodfol[019,1], SRR->RR_VALOR )
					EndIf
				EndIf                    

				If SRR->(DbSeek(SRG->RG_FILIAL + SRG->RG_MAT + "R" + DtoS(SRG->RG_DTGERAR) + aCodFol[70,1] ))
					FMatriz(aCodfol[401,1], Max( (nInss-nInssP)- SRR->RR_VALOR, 0 ) , , , , ,"R" )// INSS 13 Dissidio
					FMatriz(aCodfol[070,1], SRR->RR_VALOR  , nAliq ) // INSS 13
				EndIf
			EndIf	
		Else
			If (IsInCallStack("GPEM020") .And. !SRA->RA_SITFOLH == "D") .Or. !IsInCallStack("GPEM020")
				If cCompl == "S" .and. Month(dDataDem) == 12 .And. nInssP > 0 .And. nBAtLim > 0
					FMatriz( acodfol[020,1] ,( Max( ( nBaseAc + nBaseOAc) - nBAcLim , 0 ) ) )
					FMatriz( aCodfol[019,1] ,( Max( ( nBaseAt + nBaseOAt) - nBAtLim , 0 ) ) )
					FMatriz( aCodfol[070,1] ,( Max( ( nInss + nBaseOIn ) - nInssP  , 0 ) ) , nAliq )
				Else
					If cTipoRot == "4" .And. lTemId1672 .And. aScan(aPd, { |x| x[1] == aCodFol[247, 1] .And. x[9] != "D" } ) > 0  .And. nInssP > nInss
						FMatriz( aCodfol[1678,1], nBAcLim - nBaseAc )
						FMatriz( aCodfol[1673,1], nBAtLim - nBaseAt )
						FMatriz( aCodfol[1672,1], nInssP - nInss )
					Else
						FMatriz( acodfol[020,1] ,( Max (nBaseAc - nBAcLim , 0 ) ) )
						FMatriz( aCodfol[019,1] ,( Max( nBaseAt - nBAtLim , 0 ) ) )
						FMatriz( aCodfol[070,1] ,( Max( nInss - nInssP  , 0 ) ) , nAliq )
					EndIf
				EndIf
			Endif
		EndIf	
	EndIf

	//Deducao INSS P/IRF
	If  Round(Max(nInss1   - nInssP  , 0 ),2) > 0.00 
		If !lResExt .Or. (lDedInssEx .And. lIrResExt)
			FMatriz( aCodfol[169,1], Round(Max(nInss1 - nInssP, 0), 2) )
		Endif
	EndIf
EndIf

//Gera as verbas de INSS por faixa
If !Empty(aInssFx) .and. !Empty(aPdFx[1])
	fCInssFx(aInssFx,aPdFx)
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fCIr     ³ Autor ³ Equipe RH             ³ Data ³20/05/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do Ir  Funcionario Normal                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCIr(aCodfol)                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCIr(aCodfol,aTabir,cTipo,dDataHom,cFilialCor,cNumDepIr,cTipoPgto, nBaseTot)

Local aBenOp   := RetBenOp()
Local aCodBenef:= {}
Local aTabIrRRA:= {}
Local nBaseAnt := 0
Local nIrAnt   := 0
Local nAliq    := 0
Local nMeses   := 0
Local nNumFer  := 0
Local nCntP   
Local cBenOp   := GetBenOP()
Local cIRPlr  := ""
Local cQuery   := ""
Local cAliasQry:= ""
Local nX       := 0
Local nAntBIR 	:= 0
Local nAntDIR 	:= 0
Local nIr_bMUltV:= 0
Local lMultvCIR	:= IsInCallStack("CalcMVProcessa") .And. !IsInCallStack("S_RECFOL")
Local lMultv    := Type("lUtiMultiV") <> "U" .And. lUtiMultiV
Local aPdBkp    := {}
Local nBsTar	:= 0
Local nBsTarIr	:= 0
Local aperA		:= {}
Local aperF		:= {}
Local aperT		:= {}
Local nPos		:= 0
Local nPos1		:= 0
Local nPos2		:= 0
Local nIr_BasMV := 0
Local nIr_MV	:= 0
Local lIrNeg	:= Len(aCodFol) >= 1726 .And. !Empty(aCodFol[1726,1]) .And. !Empty(aCodFol[1727,1])

DEFAULT cFilialCor	:= SRA->RA_FILIAL		// Filial corrente
DEFAULT cNumDepIr	:= SRA->RA_DEPIR		// Numero de dependentes para IR
DEFAULT cTipoPgto	:= SRA->RA_TIPOPGT		// Tipo de pagamento da folha
DEFAULT nBaseTot	:= 0
DEFAULT lVerMultv   := If ( Type("P_MULTV") == "U",.F.,P_MULTV)

lAutMEI		:= If( Type("lAutMEI") 		== "U"	, .F., lAutMEI)
lResExt		:= If( Type("lResExt") 		== "U"	, .F., lResExt)
lIrResExt	:= If( Type("lIrResExt") 	== "U"	, .T., lIrResExt)

//Para MEI nao ira calcular o IR
If lAutMEI .Or. ( Type("lUtiMultiV")<> "U" .And. lUtiMultiV .And. LCALCCOMPL .And. !lMultvCIR .And. !IsInCallStack("fCalCompl") )
	Return
Endif

//Indica se deve calcular RRA na rescisao
lRescRRA := If(Type("lRescRRA") == "U",.F.,lRescRRA)
cTipoRot := If(Type("cTipoRot") == "U" .or. cTipoRot == Nil, "",cTipoRot)

cTipo    := If(cTipo=Nil,"",cTipo)

dDataHom := If(dDataHom=Nil,dDataAte,dDataHom)

If Type("lRescMSeg") == "U"
	lRescMSeg:= .F.
EndIf

If Type("aPdResVals") == "U"
	aPdResVals := {}
EndIf

nVal_Peal := nBasered := 0.00

//-- CALCULO DO I.R. NORMAL
If Ascan(aPd,{ |X| X[1] = aCodfol[66,1] .And. X[3] = cSemana .And. X[9] # "D"}) = 0
	nIR_B := nVal_Peal := 0.00
	If nBaseTot == 0
		//-- Procura Base de IR. na Data de pagamento, quandop vem da rescisão vem com 
		//-- a data da rescisao e não pode ser recalculada na folha
		aEval( aPD , { |x| nIr_b += If( X[1] = aCodfol[15,1] .And. X[3] = cSemana .And. X[9] # "D" .And. ( X[10] == NIL .Or. Empty(X[10]) .Or. MesAno(dDataHom) = MesAno(X[10]) ), x[5] , 0.00 ) } )
		
		If lIrNeg
			aEval( aPD , { |x| nIr_b -= If( X[1] = aCodfol[1726,1] .And. X[3] = cSemana .And. X[9] # "D" .And. ( X[10] == NIL .Or. Empty(X[10]) .Or. MesAno(dDataHom) = MesAno(X[10]) ), x[5] , 0.00 ) } )		
		EndIf
	Else
		nIR_B := nBaseTot
	EndIf

	If nIR_B = 0.00
	
		cIRPlr:= aCodFol[151,1] + "/"
		dbSelectArea('SRQ')
		If SRQ->(dbSeek(SRA->RA_FILIAL + SRA->RA_MAT))
			While SRA->RA_FILIAL + SRA->RA_MAT == SRQ->RQ_FILIAL + SRQ->RQ_MAT .And. !EOF()
		   		cIRPlr+= RQ_VERBPLR +"/"
		   		SRQ->(dbSkip())
		   	EndDo	
		EndIf	
		//--Soma Incidencia para Base de I.R. (Alterado para Somar so quando a Semana Informada For Menor ou Igual a cSemana)
		//-- Nao Somar a verba de Distribuicao de Lucro porque o Ir e separado
		If SRA->RA_TIPOPGT == "M"
			Aeval( aPd ,{ |X| IF(X[3] <= cSemana .And. !(X[1] $ cIRPlr),SomaInc(X,5,@nIR_B,11,"N",12,"N",Month(dDataHom),,aCodFol,,,If(lMultV, .T. ,.F.)),NIL) } )

			If cPaisLoc == "BRA" .And. cInssFM == "N"
				nPos1 := aScan(aPd, { |x| x[1] == aCodfol[72, 1] .And. x[9] # "D" .And. x[7] == "K" })
				nPos2 := aScan(aPd, { |x| x[1] == aCodfol[168, 1] .And. x[9] # "D" .And. x[7] == "C" })
				If nPos1 > 0 .And. nPos2 > 0 .And. AnoMes( aPd[nPos1, 18] ) < AnoMes( aPd[nPos2, 18] )
					Aeval( aPd ,{ |X| IF(X[3] <= cSemana .And. X[1] == aCodfol[168, 1] .And. x[7] == "C", SomaInc(X,5,@nIR_B,,,,,Month(dDataHom),,aCodFol,,,If(lMultV, .T. ,.F.)),NIL) } )
				EndIf
			EndIf

			If nIR_B > 0 .And. cTipo == "R" .And. cCompl == "S" .and. lProxMes //Se complementar é no mês seguinte, verifica se pagamento da primeira rescisão ocorreu no mesmo Ano/Mes da complementar atual
				Aeval( aPdResc ,{ |X| If(X[3] <= cSemana .And. !(X[1] $ cIRPlr) .and. MesAno(x[18]) == MesAno(dDataDem) .and. MesAno(x[10]) == MesAno(dDataHom),SomaInc(X,5,@nIR_B,11,"N",12,"N",Month(dDataHom),,aCodFol,,,If(lMultV, .T. ,.F.)),NIL) } )
				fSomaIrMesAnt(cIRPlr, dDataHom, lMultV, dDataDem)
			EndIf
		Else
			If lMultv
				aPdBkp := AClone(aPd)
				For nX := 1 To Len(aPd)
					If aPd[nX,3] <> cSemana
						aPd[nX,3] := cSemana
					EndIf
				Next nX
			EndIf

			Aeval( aPd ,{ |X| IF(X[3] <= cSemana .And. !(X[1] $ cIRPlr),SomaInc(X,5,@nIR_B,11,"N",12,"N",Month(dDataHom),,aCodFol,,,.T.),NIL) } )
			
			If cSemana > "01" .and. SRA->RA_CATEG <> "15" //Verifica se a base de IR mês anterior esta na mesma competência do cálculo atual e soma na base de IR
				Aeval(aPd,{ |X| nIr_b += If ( X[1]==aCodFol[106,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. x[3] == "01" ,X[5],0) })
				If lIrNeg
					Aeval(aPd,{ |X| nIr_b -= If ( X[1]==aCodFol[1727,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. x[3] == "01" ,X[5],0) })
				EndIf
			EndIf

			If lMultv
				aPd := AClone(aPdBkp)
			EndIf
		EndIF
		If SRA->RA_TPCONTR == "3"
			Aeval( aPdConvoc ,{ |X| IF(X[3] <= cSemana .And. !(X[1] $ cIRPlr),SomaInc(X,5,@nIR_B,11,"N",12,"N",Month(dDataHom),,aCodFol,,,.F.),NIL) } )
		EndIf
		
		If cTipoRot == "O" .And. !aBenOp[4]
			Aeval( aPdBenOp ,{ |X| Iif(X[26] < cBenOp .And. !(X[1] $ cIRPlr), SomaInc(X, 5, @nIR_B, 11, "N", 12, "N", Month(dDataHom), Nil, aCodFol, Nil, Nil, .F.), Nil) } )
		EndIf
		
		//Se for complementar MULTV considera os valores anteriores também
		If IsInCallStack("fCalCompl") .And. Len(aCPFAll) > 0
			//AEval( aPd ,{ |X| IIf(X[1] == aCodFol[0064,1],X[9] := "D",Nil) })
			
			cAliasQry := GetNextAlias()
			
			cQuery := " SELECT * FROM " + RetSqlName("SRC")
			cQuery += " WHERE "
			cQuery += " ( "
			For nX := 1 To Len(aCPFAll)
				cQuery += " ( RC_FILIAL = '" + aCPFAll[nX,2] + "' AND"
				cQuery += " RC_MAT = '" + aCPFAll[nX,3] + "' )"
				
				If nX <> Len(aCPFAll)
					cQuery += " OR "
				EndIf
			Next nX
			cQuery += " ) AND"
			cQuery += " RC_PROCES = '" + cProcesso + "' AND"
			cQuery += " RC_PERIODO = '" + cPeriodo + "' AND"
			cQuery += " RC_ROTEIR = '" + cRot + "' AND"
			cQuery += " RC_SEMANA < '" + cSemana + "' AND"
			cQuery += " RC_PD IN('" + aCodFol[0010,1] + "','" + aCodFol[0015,1] + "','" + aCodFol[0016,1] + "') AND" //Bases de IR
			cQuery += " D_E_L_E_T_ = ' ' "
			
			cQuery := ChangeQuery(cQuery)
			
			DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry)
			
			While (cAliasQry)->( !Eof() )
				nIR_B += (cAliasQry)->RC_VALOR
				(cAliasQry)->( DbSkip() )
			EndDo
			
			(cAliasQry)->( DbCloseArea() )
		ElseIf Type("lUtiMultiV")<> "U" .And. lUtiMultiV .And. lMultvCIR .And. LCALCCOMPL
			cAliasQry := GetNextAlias()
			
			cQuery := " SELECT * FROM " + RetSqlName("SRC")
			cQuery += " WHERE"
			cQuery += " RC_FILIAL = '" + SRA->RA_FILIAL + "' AND"
			cQuery += " RC_MAT = '" + SRA->RA_MAT + "' AND"
			cQuery += " RC_PROCES = '" + cProcesso + "' AND"
			cQuery += " RC_PERIODO = '" + cPeriodo + "' AND"
			cQuery += " RC_ROTEIR = '" + cRot + "' AND"
			cQuery += " RC_SEMANA < '" + cSemana + "' AND"
			cQuery += " RC_PD IN('" + aCodFol[0010,1] + "','" + aCodFol[0015,1] + "','" + aCodFol[0016,1] + "','" + aCodFol[0066,1] + "') AND" //Bases de IR e IR
			cQuery += " D_E_L_E_T_ = ' ' "
			
			cQuery := ChangeQuery(cQuery)
			
			DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry)
			
			While (cAliasQry)->( !Eof() )
                If (cAliasQry)->RC_PD $ aCodFol[0010,1] + "/" + aCodFol[0015,1] + "/" + aCodFol[0016,1]
					nAntBIR += (cAliasQry)->RC_VALOR
					nIR_B 	+= (cAliasQry)->RC_VALOR
				ElseIf (cAliasQry)->RC_PD == aCodFol[0066,1]
					nAntDIR += (cAliasQry)->RC_VALOR
				EndIf				
				(cAliasQry)->( DbSkip() )
			EndDo
		EndIf
        
		If lResExt
			//-- Busca os codigos de pensao definidos no cadastro de beneficiarios
			fBusCadBenef(@aCodBenef, "FOL")
			For nCntP := 1 To Len(aCodBenef)
				aEval( aPD , { |x| nIR_B += If( x[1] == aCodBenef[nCntP,1] .And. x[9] # "D", x[5] , 0.00 ) } )
			Next nCntP
		EndIf

		//-- Soma o Valor de Base da Pensao Alimenticia
		If aCodfol[57,1] # "   "
			aEval( aPD , { |x| nVal_Peal += If( x[1] == aCodFol[57,1] .And. x[9] # "D", x[5] , 0.00 ) } )
		EndIf

		//-- Busca os codigos de pensao definidos no cadastro de beneficiarios
		fBusCadBenef(@aCodBenef, "ADI", {aCodfol[58,1]})
		For nCntP := 1 To Len(aCodBenef)
			aEval( aPD , { |x| nVal_Peal -= If( x[1] == aCodBenef[nCntP,1] .And. x[9] # "D", x[5] , 0.00 ) } )
		Next nCntP

		//--Abate da Base de Ir o Valor da Pensao
		nIr_b 	 -= If( lResExt,0,Max(nVal_Peal, 0))
		nVal_Peal := 0

		//-- Procura Cod. Base Deducao Previdencia Privada (exceto para residentes no Exterior)
		If aCodfol[215,1] # "   " .And.  RetValSrv(aCodFol[215,1],cFilialCor,"RV_IR") == "S" .And. !lResExt
			aEval( aPD , { |x| nIr_b -= If( x[1] == aCodFol[215,1] .And. X[9] # "D", x[5] , 0.00 ) } )		
		EndIf

		//-- Procura Base de Ir Mes Anterior
		If cTipo # "R" .And. ( cSemana == "01" .or. lMultV )
			Aeval(aPd,{ |X| nIr_b += If ( X[1]==aCodFol[106,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. ( (!lMultV .and. cSemana == "01" ) .or. ( X[7] <> 'F' )) ,X[5],0) })
			If lIrNeg
				Aeval(aPd,{ |X| nIr_b -= If ( X[1]==aCodFol[1727,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. ( (!lMultV .and. cSemana == "01" ) .or. ( X[7] <> 'F' )) ,X[5],0) })
			Endif
			If lMultV
				Aeval(aPd,{ |X| nIr_bMUltV += If ( X[1] == aCodFol[106,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. X[7] == 'G'  ,X[5],0) })
				If lIrNeg
					Aeval(aPd,{ |X| nIr_bMUltV -= If ( X[1] == aCodFol[1727,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. X[7] == 'G'  ,X[5],0) })
				Endif
			EndIf
		EndIf
	EndIf

	If cTipo # "R" .And. SRA->RA_TIPOPGT == "S" .And. (SRA->RA_CATEG == "15" .OR. SRA->RA_CATEFD $ "711|712")
		fRetPerComp(str(month(DDATA_PGTO)),str(year(DDATA_PGTO)),,,,@aPerA,@aPerF,@apert,.T.,firstday(DDATA_PGTO),DDATA_PGTO)
		aSort( aPerF ,,, { |x,y| x[7] < y[7] } )
		nPos := aScan(aPerF, { |x| x[7] == cProcesso .and. x[1] <> cPeriodo})
		If nPos > 0
			cAliasQry := GetNextAlias()
				
			cQuery := " SELECT * FROM " + RetSqlName("SRD")
			cQuery += " WHERE"
			cQuery += " RD_FILIAL = '" + SRA->RA_FILIAL + "' AND"
			cQuery += " RD_MAT = '" + SRA->RA_MAT + "' AND"
			cQuery += " RD_PROCES = '" + cProcesso + "' AND"
			cQuery += " RD_PERIODO = '" + aPerF[nPos][1] + "' AND"
			cQuery += " RD_ROTEIR = '" + cRot + "' AND"
			cQuery += " RD_PD IN('" + aCodFol[0015,1] + "','" + aCodFol[0066,1] + "') AND" //Bases de IR e IR
			cQuery += " RD_DATPGT between '"+dtos(firstday(DDATA_PGTO))+"' AND '"+dtos(DDATA_PGTO)+"' AND 
			cQuery += " D_E_L_E_T_ = ' ' "
			
			cQuery := ChangeQuery(cQuery)
			
			DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry)
			
			While (cAliasQry)->( !Eof() )
	            If (cAliasQry)->RD_PD == aCodFol[0015,1]
					nBsTar  += (cAliasQry)->RD_VALOR
					nIR_B 	+= (cAliasQry)->RD_VALOR
				ElseIf (cAliasQry)->RD_PD == aCodFol[0066,1]
					nBsTarIr += (cAliasQry)->RD_VALOR
				EndIf				
				(cAliasQry)->( DbSkip() )
			EndDo	 
			(cAliasQry)->( dbCloseArea() )
		EndIf
	EndIf

	//-- Variavel Usada na Rescisao (cTipo)
	//-- Busca Base I.R. Adiantamento se Rescisao for no mesmo Mes
	If cTipo = "R"
		//-- Verifica se Identificador do Adiant. de Salario esta com "S" p/ IR
		If (RetValSRV(aCodFol[006,1],cFilialCor,"RV_IR") == "S") .Or. ((RetValSRV(aCodFol[006,1],cFilialCor,"RV_IR") == "N") .And. (RetValSRV(aCodFol[007,1],cFilialCor,"RV_IR") == "N")) //* Ajustado condiç?o pois n?o estava somando a base de IR corretamente devido a configuraç?o da verba de adiantamento
			//-- Procura Base de Ir Adto.
			
			nPos := Ascan(aPD,{ |X| X[1] == aCodFol[010,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10])})
			If nPos > 0
				Aeval(aPd,{ |X| nIr_b += If ( X[1]==aCodFol[010,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10]),X[5],0) })
			Else
				//-- Procura Base de Ir Mes Anterior
				Aeval(aPd,{ |X| nIr_b += If ( X[1]==aCodFol[106,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10]),X[5],0) })
				If lIrNeg
					Aeval(aPd,{ |X| nIr_b -= If ( X[1]==aCodFol[1727,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10]),X[5],0) })
				EndIf
			EndIf
			//-- Se encontrado o redutor, soma-o novamente na base de IR
			nPos := Ascan(aPD,{ |X| X[1] == aCodFol[408,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10])})
			If nPos > 0
				nIr_b += aPd[nPos,5]
			EndIf
		EndIf

         //-- Soma IR na base - Rescisao complementar
		If !Empty( aPdResVals )
			Aeval( aPdResVals , { |X| nIr_b += If ( X[1]==aCodFol[015,1] .And. MesAno(dDataHom) = MesAno(x[10]), X[5], 0) })
		EndIf
					
	EndIf
	
	If lIrNeg .And. nIr_b < 0
		FMatriz(aCodfol[1726,1],nIr_B * -1)
	EndIf
	
	nIr_b := If(nIr_b<0,0,nIr_b)
	
	//-- FUNCAO PARA CALCULAR I.R.
	nIr := nBaseRed := 0.00
	nVal_DedDep := val(cNumDepIr)

	If lVerMultv
		aEval( aPd, { |X| If ( x[1] $ aCodFol[992,1] .And. x[3] == cSemana .And. X[9] != "D" .And. (x[11] == "9" .Or. x[7] == "I"), nIr_BasMV += x[5], Nil ) } )
		aEval( aPd, { |X| If ( x[1] $ aCodFol[993,1] .And. x[3] == cSemana .And. X[9] != "D" .And. (x[11] == "9" .Or. x[7] == "I"), nIr_MV += x[5], Nil ) } )
	EndIf

	nIr_B += nIr_BasMV
		
	If lDissidio .And. cTipoRot == "1"
		aEval( aPd, { |X| If ( x[1] $ aCodFol[72,1] .And. x[3] == cSemana .And. X[9] != "D", nNumFer++, Nil ) } )
		aEval( aPd, { |X| If ( x[1] $ (aCodFol[72,1]+"*"+aCodFol[77,1]+'*'+aCodFol[88,1]+'*'+aCodFol[90,1]+'*'+aCodFol[92,1]+'*'+aCodFol[96,1]+'*'+aCodFol[98,1]+'*'+aCodFol[161,1]+'*'+aCodFol[94,1]+'*'+aCodFol[95,1]) .And. x[3] == cSemana .And. X[9] != "D" .And. x[11] > Str(nNumFer, 1), nFgts_b -= x[19], Nil ) } )			
	EndIf

	If !lRescRRA
		CALC_IR(nIr_B,nVal_Peal,@nIr,@nBaseRed,@nVal_DedDep,,aTabIr,,@nAliq)
	Else
		If !Gpm40LoadRRA(@nIr_B,@nVal_Peal,@aTabIrRRA,@nMeses,dDataHom,aCodFol[974,1],aCodFol[975,1])
			Return
		EndIf
		CALC_IRRRA(nIr_B,nVal_Peal,@nIr,@nBaseRed,@nVal_DedDep,,aTabIrRRA,.F.,@nAliq,nMeses+1)
		nPos := Ascan(aPD,{ |X| X[1] == aCodFol[977,1] .And. X[9] # "D" })
		If nPos > 0
			aPd[nPos,5] := nBaseRed
		EndIf
	EndIf

	nIr_B -= nIr_BasMV
	nIr   -= nIr_MV

	If cTipo # "R" .And. SRA->RA_TIPOPGT == "S" .And. (SRA->RA_CATEG == "15" .OR. SRA->RA_CATEFD $ "711|712")
		 nIr_b -= nBsTar
		 nIr -= nBsTarIr
	EndIf

	If Type("lUtiMultiV")<> "U" .And. lUtiMultiV .And. lMultvCIR .And. LCALCCOMPL
		nIr_B	-= nAntBIR
		nIr		-= nAntDIR
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Semanalistas ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cTipoPgto == "S" 
		If cTipoRot == "4"
			Aeval( aPdSemAnt,{ |X| nBaseAnt += If(X[1] == aCodFol[15,1] .And. X[3] < cSemana .And. MesAno(dDataHom) == MesAno(X[10]) .And. X[9] # "D",X[5],0)} )
			Aeval( aPdSemAnt,{ |X| nIrAnt   += If(X[1] == aCodFol[66,1] .And. X[3] < cSemana .And. MesAno(dDataHom) == MesAno(X[10]) .And. X[9] # "D",X[5],0)} )
			
			If lIrNeg
				Aeval( aPdSemAnt,{ |X| nBaseAnt -= If(X[1] == aCodFol[1726,1] .And. X[3] < cSemana .And. MesAno(dDataHom) == MesAno(X[10]) .And. X[9] # "D",X[5],0)} )
			EndIf
		Else
			Aeval( aPD,{ |X| nBaseAnt += If(X[1] == aCodFol[15,1] .And. X[3] < cSemana .And. MesAno(dDataHom) == MesAno(X[10]) .And. X[9] # "D",X[5],0)} )
			Aeval( aPD,{ |X| nIrAnt   += If(X[1] == aCodFol[66,1] .And. X[3] < cSemana .And. MesAno(dDataHom) == MesAno(X[10]) .And. X[9] # "D",X[5],0)} )

			If lIrNeg
				Aeval( aPD,{ |X| nBaseAnt -= If(X[1] == aCodFol[1726,1] .And. X[3] < cSemana .And. MesAno(dDataHom) == MesAno(X[10]) .And. X[9] # "D",X[5],0)} )
			EndIf
		EndIf
		If !(SRA->RA_CATFUNC $ "A*P") .or. SRA->RA_CATEG == "15" //Nos demais casos mantém a base de IR cheia
			nIr_B -= nBaseAnt
		EndIf
		nIr   -= nIrAnt
	EndIf

	If cTipoRot == "O" .And. !aBenOp[4]
		aEval( aPdBenOp, { |x| nIrAnt += Iif(x[1] == aCodFol[66,1] .And. x[26] < cBenOp .And. (Empty(X[10]) .Or. MesAno(dDataHom) == MesAno(X[10])) .And. x[9] # "D", x[5], 0) } )
		nIr -= nIrAnt
	EndIf

	//--Abater Ir Mes Anterior so quando for Mesmo Mes
	If cTipo # "R" .And. ( cSemana == "01" .or. lMultV ) .and. !( SRA->RA_TIPOPGT == "S" .And. (SRA->RA_CATEG == "15" .OR. SRA->RA_CATEFD $ "711|712") ) 
		Aeval(aPd,{ |X| nIr -= If ( X[1]==aCodFol[107,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. ((!lMultv .and. cSemana == "01") .or. x[7] == "G") ,X[5],0) })
	ElseIf cSemana > "01" .and. SRA->RA_CATFUNC $ "A*P*H" .and. SRA->RA_CATEG <> "15" //Subtrai IR pago no período anterior com a mesma data de competencia do pagamento atual
		Aeval(aPd,{ |X| nIr -= If ( X[1]==aCodFol[107,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]) .and. x[3] == "01" ,X[5],0) })
	EndIf
	
	//-- Variavel usada na Rescisao (cTipo)
	//-- Abate I.R. Mes Anterior
	If cTipo == "R" .And. RetValSRV(aCodFol[006,1],cFilialCor,"RV_IR") == "S" .Or. ((RetValSRV(aCodFol[006,1],cFilialCor,"RV_IR") == "N") .And. (RetValSRV(aCodFol[007,1],cFilialCor,"RV_IR") == "N")) //Ajusta o abatimento do IR no mês anterior em regime competência
		Aeval(aPd,{ |X| nIr -= If ( X[1]==aCodFol[107,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(X[10]),X[5],0) })
		//-- Abate I.R. do Adiantamento
		Aeval(aPd,{ |X| nIr -= If ( X[1]==aCodFol[012,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10]) ,X[5] ,0)})
	EndIf
	
	//-- Abate I.R. na Rescisao complementar
	If cTipo == "R" .And. !Empty( aPdResVals )
		Aeval( aPdResVals, { |X| nIr -=   If ( X[1]==aCodFol[066,1] .And. MesAno(dDataHom) = MesAno(x[10]) ,X[5] ,0)})
		Aeval( aPdResVals, { |X| nIr_b -= If ( X[1]==aCodFol[015,1] .And. MesAno(dDataHom) = MesAno(x[10]), X[5], 0)})
	EndIf

	If nIr > 0 .And. cTipo == "R" .and. cCompl == "S" .and. lProxMes
		//Subtrai o valor de IR descontado na rescisão original se esta teve o pagamento no mesmo Ano/Mes da complementar atual
		Aeval(aPdResc,{ |X| nIr -= If ( X[1]==aCodFol[066,1] .And. X[9] # "D" .And. MesAno(dDataHom) == MesAno(x[10]) .And. MesAno(x[18]) == MesAno(dDataDem) ,X[5] ,0)})
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Zera o Valor da Aliquota se Ir <= 0 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nIr <= 0
		nAliq := 0
	EndIf
	
	//Subtrai a base de ir mês anterior de outros vínculos quando utiliza MULTV
	nIr_B -= nIr_bMUltV 
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ A Bs.IR Autonomo Carret. ja foi gerada, porem o vlr devera ser somente o da   ³
	//³ semana calculada sem os vlrs das semanas  anteriores                          ³	
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SRA->RA_CATFUNC == "A" .and. MESANO(dDataHom)>='200304' .and. SRA->RA_CATEG $ '15|16|18' .and. cTipoPgto = "S"
		If nIr_B > 0
			FMatriz(aCodfol[15,1],nIr_B,,,,,,,,,.T. )
		Else 	
			Aeval( aPD,{ |X| If(X[1] == aCodFol[15,1] .And. X[3] == cSemana .And. ( MesAno(dDataHom) == MesAno(X[10]) .Or. Empty(X[10])) .And. X[9] # "D",X[9]:="D","")} )
		EndIf
	Else 	
		If nIr_B > 0
			FMatriz(aCodfol[15,1],nIr_B)
		Else
			If lIrNeg
				FMatriz(aCodfol[1726,1],nIr_B * -1)
			EndiF
		EndIf
	EndIf

	//Tratamento para autonomo carreteiro
	If SRA->RA_CATFUNC == "A" .And. MesAno(dDataHom) >= '200304' .And. (SRA->RA_CATEG $ '15|16' .Or. SRA->RA_CATEFD $ "711|712" ) .And. Len(aCodFol) >= 1563 .And. !Empty(aCodFol[1563,1])
		fGerAutCar()
	EndIf

	If (!lResExt) .Or. (lResExt .And. lIrResExt)
		FMatriz(aCodfol[66,1],nIr,nAliq)
	Endif
	//-- TIRA SEMPRE O FLAG DO CODIGO DE DEDUCAO DE DEPENDENTES
	//-- PARA MUDA-LO PARA "D" DELETADO
	nPos := Ascan ( aPD , { |X| X[1] == aCodFol[59,1] } )
	If nPos > 0 .And. nVal_DedDep > 0
		aPD[nPos,9] := "D"
	EndIf
	nPos := Ascan(aPd, {|X| X[1]==aCodFol[106,1] .And. X[9] # "D" .And. MesAno(dDataHom) = MesAno(x[10])})
	//-- Nao gera a deducao de dependentes se for rescisao no mes seguinte e tiver utilizado a verba de base
	//-- de ir do mes anterior para compor a base de calculo de ir de rescisao.
	//-- Neste caso, devera utilizar o dependente para o abatimento porem nao deve gravar a verba para nao causar
	//-- duplicidade de deducao de dependentes na DIRF
	If !(cTipo = "R" .And. lRescMSeg .And. nPos > 0) .And. (nIr_B > 0)
		FMatriz(aCodfol[59,1],nVal_DedDep,val(cNumDepIr))
	EndIf
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fCIrFer  ³ Autor ³ Equipe RH             ³ Data ³20/05/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do Ir  Funcionario Ferias                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCIrFer(aCodfol)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aCodFol    = Array com Identificadores de Calculo Folha    ´±±
±±³          ³ aTabIr     = Array com a Tabela de IR                      ´±±
±±³          ³ lCond      = .T.ou.f.Verificar ou Nao Incidencia das Verbas´±±
±±³          ³ dDataPg    = Data Para verificar mes/ano de calculo        ´±±
±±³          ³ lRecalculo = .T.ou.F. Se recalcula ou nao o IR Ferias      ´±±
±±³          ³ cTipo      = "F"=Ferias                                    ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCIrfer(aCodfol, aTabir, lCond, Ddatapg, lRecalculo, cTipo, lCalcUmT)

Local aAreaSRH	:= SRH->( GetArea() )
Local dBkpPgto	:= cToD("//")
Local nAliq 	:= 0
Local nBOut		:= 0
Local nIrf_Ant	:= 0.00	
Local n			:=0
Local nPos3		:=0      
Local nPosAux	:=0      
Local nPosv		:=0      
Local NVL0079	:= 0 //Uso GFP
Local lAltVer	:= .F.
Local lId1449	:= (Len(aCodFol) >= 1449)
Local lMp927    := .T.

lAutMEI		:= If( Type("lAutMEI") 	 == "U"	, .F., lAutMEI)
lIrResExt	:= If( Type("lIrResExt") == "U"	, .T., lIrResExt)

DEFAULT lVerMultv   := If ( Type("P_MULTV") == "U",.F.,P_MULTV)
DEFAULT lCalcUmT	:= .F.

//Para MEI ou res. exterior com RGE_DESCIR=="2" nao ira calcular o IR
If lAutMEI .or. !lIrResExt
	Return
Endif

//Indica se deve calcular RRA na rescisao
lRescRRA := If(Type("lRescRRA") == "U",.F.,lRescRRA)

lRecalculo 	:= If(lRecalculo= Nil,.F.,lRecalculo)
dDatapg 	:= If (dDatapg  = Nil, dDataAte , dDatapg) //dDataAte = Ultimo dia do periodo
cTipo       := If (cTipo    = Nil," ", cTipo)
nVal_Peal 	:= 0.00
nBaseRed 	:= 0.00
nIrBant 	:= 0.00
nIRf_B 		:= 0.00
nIrF_Out	:= 0.00
nBiF_Out    := 0.00

If !lCalcUmT
	If lRescRRA
		//Calcula apenas se nao tiver calculado IR normal, pois IR de ferias eh calculado junto quando existe RRA
		If ( nPos := aScan(aPD,{ |X| X[1] == aCodFol[015,1] .And. X[9] # "D" }) ) > 0
			Return Nil
		EndIf
	EndIf
	
	//-- Altera incidencia de IRF da verba de Abono e 1/3 de Abono (id 074 e 079) para "S", qdo tiver
	//-- no mesmo movimento a verba de ferias pagas (id 164). Isso se faz necessario para nao gerar base de IRF 
	//-- de ferias negativa devido desconto da verba de ferias pagas(164), que deve possuir incidencia IRF tb como S. 
	//-- Essa alteracao sera realizada somente para geracao da base de irf de ferias, e qdo tivermos ferias\abono mes 
	//-- seguinte, e estivermos no calculo da folha do mes seguinte.
	For n=1 to Len(aPd)
		If ( aPd[n,1]= aCodFol[074,1] .Or. aPd[n,1]= aCodFol[079,1] ) .And. aPd[n,9] # 'D' .And. Ascan(aPd,{ |x| x[1] == aCodFol[164,1]}) > 0 .And. If(lId1449, Ascan(aPd,{ |x| x[1] == aCodFol[1449,1]}) == 0, .T.)
		// Posiciona na Matriz de Incidencia
			nPosv := Ascan(aPdv, { |Y| Y[1]=aPd[n,1]} )
			If nPosv > 0 .And. aPdv[nPosv,5] = "N"  
				aPdv[nPosv,5] := "S" 
				lAltVer		  := .T.
			EndIf	
		EndIf
	Next N

	//Verifico se n?o houve cálculo de férias por motivo da MP927, nestes casos a base e o IR já foram calculados e pagos no mes de inicio das ferias
	If lCalcFol .or. cTipoRot == "1"
		dbSelectArea ("SRH")
		dbSetOrder(1)
		dbSeek(SRA->RA_FILIAL+SRA->RA_MAT)
		While !Eof() .And. SRH->RH_FILIAL+SRH->RH_MAT == SRA->RA_FILIAL+SRA->RA_MAT
			If SRH->(RH_DTRECIB > RH_DATAINI) .And. (AnoMes(SRH->RH_DTRECIB) == cPeriodo)
				lMp927 := .F.
			Endif
			dbSkip()
		EndDo
	EndIf
EndIf

If lMp927
    // Soma Incidencia para Base de Ir Ferias
    If lCond # Nil .And. lCond 
        Aeval( aPd ,{ |X| SomaInc(X,5,@nIRf_B,11,"S",12,"N",Month(dDataPg), ,aCodFol) })
    Else
        Aeval( aPd ,{ |X| SomaInc(X,5,@nIRf_B, , , , , , ,aCodFol)})
    EndIf
	If SRA->RA_TPCONTR == "3" .and. cTipoRot == "1" //Se contrato intermitente, busca verbas das outras convocações
		Aeval( aPdConvoc ,{ |X| SomaInc(X,5,@nIRf_B,11,"S",12,"N",Month(dDataPg), ,aCodFol) })
	EndIf
Endif
//GFP - cálculo de férias de estatutário , quando parâmetro S_SUMFERAB == "S", deve descontar o valor do 1/3 de abono somado ao 1/3 de férias.
If CTIPOROT == "L" .AND. SRA->RA_REGIME == "2" .AND. P_SUMFERAB == "S" .AND. !(RetValSRV(ACODFOL[0079,1], SRA->RA_FILIAL, "RV_INSSFER") == '1')
	//DESCONTA VALOR DO 1/3 DE ABONO QUE FOI SOMADO À VERBA DE 1/3 DE FERIAS.
	AEVAL(APD, { | X | IIF( X[1] == ACODFOL[0079,1] .AND. X[3] == CNUMPAG .AND. X[9] == "D" .AND. !(X[7] == "S"), NVL0079 += X[5], )} )
	nIRf_B -= NVL0079
EndIf

//-- Retorna a incidencia das verbas de Abono e 1/3 de Abono (id 074 e 079) para "N"
If lAltVer
	For n=1 to Len(aPd)
		If ( aPd[n,1]= aCodFol[074,1] .or. aPd[n,1]= aCodFol[079,1] ) .and. aPd[n,9] # 'D' .and. Ascan(aPd,{ |x| x[1] == aCodFol[164,1]}) > 0
		   // Posiciona na Matriz de Incidencia
			nPosv := Ascan(aPdv, { |Y| Y[1]=aPd[n,1]} )
			If nPosv > 0 
				aPdv[nPosv,5] := "N" 
			EndIf	
		EndIf
	Next N
EndIf

//--Soma Base de Ir das Ferias no movimento
If SRA->RA_TPCONTR <> "3"
	Aeval(aPd,{ |X| nIrBAnt += If ( X[1]==aCodFol[16,1] .And. X[9] # "D" .and.  Month(X[10]) = Month(dDatapg) ,X[5] ,0)})
Else
	If cSemana > "01"
		Aeval(aPd,{ |X| nIrBAnt += If ( X[1]==aCodFol[16,1] .And. X[3] < cSemana .And. X[9] # "D" .and. Month(X[10]) = Month(dDatapg) ,X[5] ,0)})
	Else
		Aeval(aPd,{ |X| nIrBAnt += If ( X[1]==aCodFol[16,1] .And. X[9] # "D" .and. Month(X[10]) = Month(dDatapg) ,X[5] ,0)})
	EndIf
	Aeval(aPdConvoc,{ |X| nIrBAnt += If ( X[1]==aCodFol[16,1] .And. X[9] # "D" .and.  Month(X[10]) = Month(dDatapg) ,X[5] ,0)})
EndIf
If cTipo = "F" .or. (cTipoRot == "4" .and. lVerMultv)//Quando for calculo de Ferias ou rescisão de múltiplos vinculos
	// Busca Base Ir Ferias Outros Periodos
	nBOut := 0.00
	Aeval(aPd,{ |X| nBOut += If ( X[1]==aCodFol[236,1] .And. X[9] # "D" ,X[5] ,0)})
	If nBOut > 0.00
		nBiF_Out := nBOut
		nIrf_b   += nBOut
	EndIf
EndIf

// Soma Ir Ferias Outros Periodos
Aeval(aPd,{ |X| nIrF_Out += If ( X[1]==aCodFol[237,1] .And. X[9] # "D" ,X[5] ,0)})


// Soma o Valor de Base da Pensao, informado pelo usu rio
If aCodfol[171,1] # "   "
	Aeval(aPd,{ |X| nVAL_PEAL += If ( X[1]==aCodFol[171,1] .And. X[9] # "D" ,X[5] ,0)})
EndIf

//-- Procura Cod. Base Deducao Previdencia Privada Ferias
If aCodfol[216,1] # "   " .And. RetValSrv(aCodFol[216,1],SRA->RA_FILIAL,"RV_IR") == "S"
	Aeval(aPd,{ |X| nIrf_b -= If ( X[1]==aCodFol[216,1] .And. X[9] # "D" ,X[5] ,0)})
EndIf

//-- Funcao p/ Calcular I.R Ferias
nIrf 		:= 0.00
nIrf_Ant	:= 0.00

nVal_DedDep := Val(SRA->RA_DEPIR)
If (Ascan(aPd,{ |X| X[1] == aCodfol[67,1] .And. X[3] == cSemana .And. X[9] # "D"}) == 0 .Or. cTipoRot == "1" .Or. (cTipoRot == "4" .And. !IsInCallStack("fCalcPensao")) .Or. lCalcUmT) .And. nIrf_b > 0.00
	CALC_IR(nIrf_B,nVal_Peal,@nIrf,@nBaseRed,@nVAL_DEDDEP,,aTabIr,,@nAliq)

	If cTipo = "F"  .or. (cTipoRot == "4" .and. lVerMultv)// Quando For Ferias ou rescisão de múltiplo vínculo
		//Abater Base e Ir Outros Periodos apos Calculo
	    nIrf_B -= nBiF_Out
	    nIrf   -= nIrF_Out
    EndIf

	nPos  := Ascan(aPd,{ |X| X[1] = aCodfol[67,1] .And. X[9] # "D"})
	nPos1 := Ascan(aPd,{ |X| X[1] = aCodfol[16,1] .And. X[9] # "D"})
	nPos2 := Ascan(aPd,{ |X| X[1] = aCodfol[164,1] .And. X[9] # "D"})//Ferias pagas mes anterior 
	If lId1449
		nPos3 := Ascan(aPd,{ |X| X[1] = aCodfol[1449,1] .And. X[9] # "D"})//Abonos pagos mes anterior 
	EndIf
	
	If (nPos == 0 .and. nPos1 == 0 .and. nPos2 == 0 .and. nPos3 == 0) .OR. lRecalculo .Or. ( SRA->RA_TPCONTR == "3" .And. cSemana > "01") 
		If SRA->RA_TPCONTR == "3" .And. cSemana > "01"
			Aeval(aPd,{ |X| nIrf_Ant += If ( X[1]==aCodFol[67,1] .And. X[9] # "D" .And. X[3] < cSemana .and.  Month(X[10]) = Month(dDatapg) ,X[5] ,0)})	
			nIrf_B -= nIrBAnt
			nIrf -= nIrf_Ant
		EndIf
		FMatriz(Acodfol[67,1], nIrf, nAliq, Nil, Nil, Nil, Nil, Nil, Nil, Iif(lCalcUmT, dDatapg, Nil), lRecalculo)
		FMatriz(Acodfol[16,1], nIrf_B, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Iif(lCalcUmT, dDatapg, Nil), lRecalculo)
		FMatriz(aCodfol[60,1], nVal_DedDep, Val(SRA->RA_DEPIR), Nil, Nil, Nil, Nil, Nil, Nil, Iif(lCalcUmT, dDatapg, Nil), lRecalculo)
	Else
		
		Aeval(aPd,{ |X| nIrf_Ant += If ( X[1]==aCodFol[67,1] .And. X[9] # "D" .and.  Month(X[10]) = Month(dDatapg) ,X[5] ,0)})	
		
		//-- Quando houver Diferenca e for no mesmo mes das Ferias
		If ( nPos  > 0 .and. aPd[nPos,10]  # Nil  ) .Or. ;
		   ( nPos1 > 0 .and. aPd[nPos1,10] # Nil  )

			If nPos > 0
				nIrf   -= nIrf_Ant
		    EndIf
			nIrf_b -= nIrBant
		EndIf
		If nIrf >= 0
			FMatriz(Acodfol[101,1],nIrf,nAliq)					//-- Cod Dif. I.Renda  Ferias
		Else
			FMatriz(Acodfol[659,1],nIrf*(-1),nAliq)			//-- Cod Compensacao de IR
		EndIf
		If cInssFM == "N" .And. nPos1 > 0 .And. nIrf_B < 0
			aPd[nPos1, 9] := "D"
			FMatriz(Acodfol[16,1], nIrf_b + nIrBant)
		EndIf
		FMatriz(Acodfol[100,1],nIrf_B)						//-- Cod Dif. Base I.R Ferias 
		If nIrf > 0.00
			FMatriz(aCodfol[61,1],nVal_DedDep)
		EndIf
	EndIf
EndIf

If cPaisLoc == "BRA" .And. SRA->RA_TPCONTR != "3" .And. cTipoRot == "1" .And. SubStr(cPeriodo, 5, 2) == "12" .And. SubStr(cPeriodo, 1, 4) $ "2020/2021" .And. AnoMes(dDatapg) > cPeriodo .And. (!Empty(P_ADIPINI) .Or. !Empty(P_DINIADI))
	If ( nPosAux := Ascan(aPd, { |X| AnoMes(x[10]) == "202012" .And. RetValSRV(x[1], SRA->RA_FILIAL, "RV_IR") == "S" .And. X[9] # "D"}) ) > 0
		dBkpPgto := aPd[nPosAux, 10]
		If Ascan(aPd,{ |X| X[1] == aCodfol[67,1] .And. X[3] == cSemana .And. X[9] # "D"}) == 0 .And. ( nPosAux := Ascan(aPd, { |X| x[1] == aCodFol[168, 1] .And. X[7] == "C" .And. X[9] # "D"}) ) > 0
			aPd[nPosAux, 10] := dBkpPgto
		EndIf
		fCIrfer(aCodFol, aTabIr, .T., dBkpPgto, Nil, Nil, .T.)
	EndIf
EndIf

RestArea( aAreaSRH )

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fCIr13o  ³ Autor ³ Equipe RH             ³ Data ³20/05/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do Ir  Funcionario 13o.                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCIr13o(aCodfol)                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³1 aCodFol    - Array com os Id. de Calculo                  ³±±
±±³          ³2 aTabIR     - Array com os Valores da Tabela de IRRF       ³±±
±±³          ³3 lRecalculo - Logico para Regravacao do Valor em aPD       ³±±
±±³          ³4 lCond      - Logico para SomaInc                          ³±±
±±³          ³5 nIr13P     - Valor do Ir ja Descontado para Abatimento    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCIr13o(aCodfol,aTabir,lRecalculo,lCond,nIr13P)
Local aTabIrRRA	:= {}
Local dDtResAux := CtoD("")
Local nX		:= 0
Local nAliq		:= 0
Local nMeses   	:= 0
Local nBsIR13Res:= 0
Local nIR13Res	:= 0
Local nBs13Ant  := 0
Local nIr13Ant  := 0
Local nBaseOut  := 0
Local nIrOut	:= 0

lCond		:= If( lCond		= NIL, .T.  , lCond      ) // Se deseja Condicao na Somainc
lRecalculo	:= If( lRecalculo	= NIL, .F.  , lRecalculo ) // Se deseja Regravar a Verba em aPD
nIr13P		:= If( nIr13P		= NIL, 0.00 , nIr13P	 ) // Para deduzir do IR calculado

lAutMEI	:= If( Type("lAutMEI") 		== "U"	, .F., lAutMEI)

//Se cálculo da 2º parcela e funcionário foi reintegrado no ano, deve subtrair o IR 13º pago na rescisão do total apurado
If cTipoRot == "6" .and. !Empty(SRA->RA_FECREI) .and. nIr13Reint > 0
	nIr13P += nIr13Reint
EndIf

//Para MEI nao ira calcular o IR
If lAutMEI
	Return
Endif

//Indica se deve calcular RRA na rescisao
lRescRRA := If(Type("lRescRRA") == "U",.F.,lRescRRA)

nIR13_B 	:= 0.00
nVal_Peal	:= 0.00
nbaseRed 	:= 0.00

//Tratamento para obter o valor de rescisoes anteriores que devem ser 
//consideradas para o calculo do IR do 13o. independente da database
If cTipoRot == "4" .And. cCompl == "S" .And. Len(aPdResc) > 0 .And. lRecalculo
	For nX := 1 To Len(aPdResc)
		//--Somente considera as verbas que nao estao excluidas
		If aPdResc[nX,9] <> "D"
			//--Obtem o valor e a base do IR 13o. da última rescisão antes do mês atual
			If aPdResc[nX,1] == Acodfol[027,1] .and. AnoMes(aPdResc[nX,18]) <> AnoMes(M->RG_DTGERAR) .and. aPdResc[nX,18] > dDtResAux
				dDtResAux  := aPdResc[nX,18]
				nBsIR13Res := aPdResc[nX,5]
			EndIf
			If aPdResc[nX,1] == Acodfol[071,1] .and. AnoMes(aPdResc[nX,18]) <> AnoMes(M->RG_DTGERAR)
				nIR13Res += aPdResc[nX,5]
			EndIf
		EndIf
	Next nX
Endif

If Ascan(aPd,{ |X| X[1] = aCodfol[71,1] .And. X[9] # "D"})  = 0  .OR. lRecalculo
	//-- Soma Base de Ir 13o. 
	Aeval(aPd,{ |X| nIr13_B += If ( X[1]==aCodFol[027,1] .And. X[3] == cSemana .And. X[9] # "D" ,X[5] ,0)})
	If nIr13_B = 0.00 .OR. lRecalculo
		//-- Soma Incidencia para Base de Ir 13o.
		Aeval( aPd ,{ |X| SomaInc(X,5,@nIR13_B,If(lCond,12,Nil),If(lCond,"S",Nil), , , , ,aCodFol) })
		If SRA->RA_TPCONTR == "3"
			If cSemana > "01"
				Aeval( aPd ,{ |X| nBs13Ant += If(X[1] == aCodFol[27,1] .And. X[3] < cSemana .And. X[9] # "D" .And. Month(X[10]) = Month(dData_Pgto), X[5], 0) } )
				Aeval( aPd ,{ |X| nIr13Ant += If(X[1] == aCodFol[71,1] .And. X[3] < cSemana .And. X[9] # "D" .And. Month(X[10]) = Month(dData_Pgto), X[5], 0) } )
			EndIf
			Aeval( aPdConvoc ,{ |X| SomaInc(X,5,@nIR13_B,If(lCond,12,Nil),If(lCond,"S",Nil), , , , ,aCodFol) })
		EndIf
	EndIf

	nIr13 := 0.00
	nVal_DedDep := VAL(SRA->RA_DEPIR)
	// Buscar os codigos de Pensao Alimenticia
	If aCodfol[173,1] # "   " // Base Pensao Alimentica 13§ 1¦ Parcela Ded IR
		Aeval(aPd,{ |X| nVAL_PEAL += If ( X[1]==aCodFol[173,1] .And. X[9] # "D" ,X[5] ,0)})
	EndIf
	If aCodfol[129,1] # "   " // Base Pensao Alimenticia 13§ 2¦ Parcela
		Aeval(aPd,{ |X| nVAL_PEAL += If ( X[1]==aCodFol[129,1] .And. X[9] # "D" ,X[5] ,0)})
	EndIf

	//-- Procura Cod. Base Deducao Previdencia Privada
	If aCodfol[302,1] # "   " .And.  RetValSRV(aCodFol[302,1],SRA->RA_FILIAL,"RV_IR") == "S"
		Aeval(aPd,{ |X| nIr13_B -= If ( X[1]==aCodFol[302,1] .And. X[9] # "D" ,X[5] ,0)})
	EndIf

	//Deduz INSS descontado na 2a. Parcela
	nIr13_B -= nInssP

	//Soma na base do IR o valor de rescisoes anteriores
	If nIr13_B <= 0
		nBsIR13Res	:= 0
		nIR13Res	:= 0
	ElseIf nBsIR13Res > 0
		nIr13_B += nBsIR13Res
	EndIf
	
	If nIr13_b > 0.00

		If !Empty(aCodfol[994,1]) // Base IR 13º outras empresas
			Aeval(aPd,{ |X| nBaseOut += If ( X[1] == aCodFol[994,1] .And. X[9] # "D" .and. x[11] == "9",X[5] ,0)})
		EndIf
		If !Empty(aCodfol[995,1]) // IR 13º outras empresas
			Aeval(aPd,{ |X| nIrOut += If ( X[1] == aCodFol[995,1] .And. X[9] # "D" .and. x[11] == "9",X[5] ,0)})
		EndIf

		nIr13_b += nBaseOut

		If !lRescRRA
			CALC_IR(nIr13_B,nVal_Peal,@nIr13,@nBaseRed,@nVAL_DEDDEP,,aTabIr,.F.,@nAliq)
		Else
			If !Gpm40LoadRRA(@nIr13_B,@nVal_Peal,@aTabIrRRA,@nMeses,If(cTipoRot == "4", M->RG_DATAHOM, dDataAte),aCodFol[979,1],aCodFol[980,1])
				Return
			EndIf
			CALC_IRRRA(nIr13_B,nVal_Peal,@nIr13,@nBaseRed,@nVal_DedDep,,aTabIrRRA,.F.,@nAliq,1)
			nPos := Ascan(aPD,{ |X| X[1] == aCodFol[982,1] .And. X[9] # "D" })
			If nPos > 0
				aPd[nPos,5] := nBaseRed
			EndIf
		EndIf

		nIr13_b -= nBaseOut
		nIr13   -= nIrOut
		
		If SRA->RA_TPCONTR == "3" .And. cSemana > "01"
			nIr13_B -= nBs13Ant
			nIr13_B -= nIr13Ant 
		EndIf

		FMatriz( Acodfol[071,1] , NoRound( Max( nIr13 - nIr13P - nIR13Res , 0 ) , 2 ),nAliq, , , , , , , ,lRecalculo)
		FMatriz( Acodfol[027,1] , nIr13_B, , , , , , , , ,lRecalculo)

		FMatriz( aCodfol[062,1] , nVal_DedDep, If(VAL(SRA->RA_DEPIR) > aTabIr[5,2],aTabIr[5,2],VAL(SRA->RA_DEPIR)), , , , , , , ,lRecalculo)
	EndIf
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fCFgts   ³ Autor ³ Mauro                 ³ Data ³20/05/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do FGTS  Funcionario                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCFgts(aCodfol)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCfgts(aCodfol,nFgts_b,cGrava,nAfasFgts,cTipo,lTrunca)

Local nBaseTot 	 	:= 0
Local nDAdm			:= 0
Local nFgtsTot 	 	:= 0
Local nPerFgts	 	:= 0
Local nNumFer		:= 0
Local lSemana	 	:= If( cSemana # Space( 2 ), .T., .F.)
Local cCodVerba  	:= ""
Local nX         	:= 0
Local nPos			:= 0
Local lIncoNFGTS 	:= .T.
Local aAdicFGTS  	:= {}
Local nSalAux		:= 0
Local nPosPeri		:= 0
Local nPosInsal		:= 0
Local nPericAux		:= 0
Local nInsalubAux	:= 0
 
Private lZerBase	:= GetMvRH("MV_ZERBASE",,.F.)                         

Static lTCpoFgts

DEFAULT cTipo 		:= " "
DEFAULT lTrunca 	:= .T. 
DEFAULT lTCpoFgts  	:= ( Type("SRA->RA_PERFGTS") # "U" )

//--Situacao do Funcionario na data de referencia
cSitFolh			:= If( Type("cSitFolh")   == "U",SRA->RA_SITFOLH,cSitFolh)
cTipoRot			:= If( Type("cTipoRot")   == "U","",cTipoRot)
lResExt				:= If( Type("lResExt") 	  == "U", .F., lResExt)
cEncResExt			:= If( Type("cEncResExt") == "U" .Or. Empty(cEncResExt), "1234", cEncResExt)

If nAfasFgts = Nil
	nAfasFgts := 0
EndIf

If cSitFolh == "D"  .And. cTipo # 'R'
	Return
EndIf

If SRA->RA_CATFUNC = "P" .And. (!lTCpoFgts .Or. SRA->RA_PERFGTS == 0.00)
	Return
EndIf

//--Somar Fgts Semanas Anteriores
If cSemana # Space( 2 )
	Aeval( aPd,{ |X| nBaseTot += If( X[1]=aCodFol[17,1] .And. x[3] < cSemana,x[5],0 ) } )
	Aeval( aPd,{ |X| nFgtsTot += If( X[1]=aCodFol[18,1] .And. x[3] < cSemana,x[5],0 ) } )
EndIf


//--Verifica Qual Percentual de FGTS deve Aplicar 
If lTCpoFgts .And. SRA->RA_PERFGTS > 0.00
	nPerFgts := SRA->RA_PERFGTS / 100
Else
	nPerFgts := If (SRA->RA_TPCONTR$ " *1*3",nFgtsCt1,nFgtsCt2)
EndIf

If lResExt .And. ! ("3" $ cEncResExt)
	nPerFgts := 0
EndIf

//Verifica se insalubridade e periculosidade devem ser somados no FGTS integralmente ou apenas o que foi pago
If P_ADCFGTS > 0
	nPericAux	:= nPeric
	nInsalubAux	:= nInsalub
	If P_ADCFGTS == 1 .or. P_ADCFGTS == 3 //Proporcionaliza periculosidade ou ambos
		nPosPeri		:= Ascan(aPd,{ |X| X[1] == cCodPer .And. X[9] # "D" .And. X[3] = cSemana })
		If nPosPeri > 0
			nPeric := aPd[nPosPeri,5]
		EndIf
	EndIf
	If P_ADCFGTS == 2 .or. P_ADCFGTS == 3 //Proporcionaliza insalubridade ou ambos
		nPosInsal		:= Ascan(aPd,{ |X| X[1] == cCodIns .And. X[9] # "D" .And. X[3] = cSemana })
		If nPosInsal > 0
			nInsalub := aPd[nPosInsal,5]
		EndIf
	EndIf
EndIf

nFgts_b := 0
nFgts_bAV	:= 0
If lDissidio
	aEval( aPd, { |x| If( ( ( x[1] == aCodFol[17,1] .and. x[7] <> "I" ) .or. x[1] == aCodfol[18,1] ), x[9] := "D", Nil ) }  )	
EndIf
If Ascan(aPd,{ |X| X[1] = aCodfol[18,1] .And. X[9] # "D" .And. X[3] = cSemana }) = 0
	// Soma Base do fgts                                                           
	Aeval(aPd,{ |X| nFgts_B += If ( X[1]==aCodFol[017,1] .And. X[9] # "D" .And. X[3]=cSemana,X[5] ,0)})
	
	If nFgts_B = 0.00 
		// Soma Incidencia para Base de Fgts
		Aeval( aPd ,{ |X| If( X[1] <> aCodFol[042,1],SomaInc(X,6,@nFgts_b,12,"N", , , ,lSemana,aCodFol),) })
		If SRA->RA_TPCONTR == "3"
			Aeval( aPdConvoc ,{ |X| If( X[1] <> aCodFol[042,1],SomaInc(X,6,@nFgts_b,12,"N", , , ,lSemana,aCodFol),) })
		EndIf
		If lDissidio .And. cTipoRot == "1"
			aEval( aPd, { |X| If ( x[1] $ aCodFol[72,1] .And. x[3] == cSemana .And. X[9] != "D", nNumFer++, Nil ) } )
			aEval( aPd, { |X| If ( x[1] $ (aCodFol[72,1]+"*"+aCodFol[77,1]+'*'+aCodFol[88,1]+'*'+aCodFol[90,1]+'*'+aCodFol[92,1]+'*'+aCodFol[96,1]+'*'+aCodFol[98,1]+'*'+aCodFol[161,1]+'*'+aCodFol[94,1]+'*'+aCodFol[95,1]) .And. x[3] == cSemana .And. X[9] != "D" .And. x[11] > Str(nNumFer, 1), nFgts_b -= x[19], Nil ) } )			
		EndIf
		
		If nDiasFgts > 0
			If nDiasFgts + DiasTrab > nDiasC
				nDiasFgts += 30 - (nDiasFgts + DiasTrab)
			Else
				nDiasFgts	:= Min(nDiasC, nDiasFgts)
			EndIf

			If DiasTrab <> 0
				If SRA->RA_CATFUNC == "C" //Se for comissionado e não possui salário, soma a verba de auxilio doença que foi ignorada no somainc anterior
					Aeval( aPd ,{ |X| If( X[1] == aCodFol[042,1] .And. X[9] != "D" ,nFGTS_B += x[5],) })
					If SRA->RA_TPCONTR == "3"
						Aeval( aPdConvoc ,{ |X| If( X[1] == aCodFol[042,1] .And. X[9] != "D" ,nFGTS_B += x[5],) })
					EndIf
				EndIf
			EndIf
			lIncoNFGTS := .T.
			nFGTS_B += fBsFgtsAdic(@aAdicFGTS,@lIncoNFGTS)
			If aScan( aAdicFGTS, { |x| x[2] > 0 } ) == 0
				nSalAux := Salario
				For nX := 1 to Len(aPd)
					If aPd[nx][7] == "I" .And. aPd[nx][5] > 0 // Verba Informada e com Valor
						cCodVerba	:= aPd[nX][1]
						If RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_INCORP" ) == "S" .And. RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_FGTS" ) == "N" 
							nSalAux += aPd[nx][5]
						EndIf
					EndIf
				Next nX
	
				nFGTS_B += (nSalAux / nDiasC) * nDiasFgts
			Else
				If lIncoNFGTS
					nFGTS_B += SalDor * nDiasFgts 
				Else
					nFGTS_B += SalDia * nDiasFgts
					If P_ADCFGTS > 0
						If !(cBCalPer $ "2*6*7*8") .And. nPericAux <> nPeric
							nFGTS_B -= ( nPericAux - nPeric )
						EndIf
						If !(cBCalIns $ "3*4*7*8") .And. nInsalubAux <> nInsalub
							nFGTS_B -= ( nInsalubAux - nInsalub )
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf

		// Soma na base de FGTS o valor da media de comissao
		If fVarRot("nMedComiss") > 0 //SRA->RA_CATFUNC == "C" 
			nFgts_b += fVarRot("nMedComiss")
		EndIf
		If nMed407 > 0 .And. RetValSRV( aCodFol[407, 1], SRA->RA_FILIAL, "RV_FGTS" ) == "S" .And. aScan( aPd, { |x| x[1] == aCodFol[238, 1] .And. x[9] != "D" .And. x[7] != "I" } ) > 0
			nFgts_b += nMed407
			nFGTS_B := Round(nFGTS_B,2)
		Endif
		// Zera a base negativa sem abater as faltas no aviso prévio 
		If lZerBase .and. cTipo == "R"
			Aeval( aPd ,{ |X| SomaInc(X,6,@nFgts_bAV,12,"N", 1,aCodFol[111,1], ,lSemana,aCodFol) }) 

			If nfgts_b - nfgts_bAV < 0 
				nfgts_b := nfgts_bAV
			EndIf
		EndIf			

		If nfgts_b == 0.00 .And. cSemana # Space(2)
			//--Soma Base fgts Semanas Anteriores
			nFgts_b += nBaseTot
		EndIf	
	EndIf
	
    If lAdmissao
       nDAdm := nDiasP - Day(SRA->RA_ADMISSA)+1
    EndIf      

	If cGrava # Nil .And. cGrava == "S"
		nFGTS_B := (nFgts_B/If(SRA->RA_TIPOPGT=="S" .and. !(cTipoRot $ "3*4"),P_NTOTDIAS,If(lAdmissao,ndadm,nDiasC))) * If(SRA->RA_TIPOPGT=="S" .and. !(cTipoRot $ "3*4"),P_NTOTDIAS,If(lAdmissao,ndadm,nDiasC))
 		If Round(nFGTS_B,1) > nFGTS_B .And. Round(nFGTS_B,1) - nFGTS_B < 0.01
		 	nFGTS_B := Round(nFGTS_B,1)
		EndIf
		 
		If lTrunca
			nVfgts := NoRound( nFGTS_B * nPerFgts ,2)
		Else
			nVfgts := Round( nFGTS_B  * nPerFgts,2)
		EndIf

		FMatriz(aCodfol[18,1],nVfgts-nFgtsTot)
		FMatriz(aCodfol[17,1],nFGTS_B-nBaseTot)
	EndIf
EndIf    


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Quando for calculo de dissidio, e no movimento do mes nao existir ³
//³a verba de fgts do mes (id 018), porem existir a verba de base (id³
//³017, fazer o calculo do fgts baseado na verba de base e grava-la  ³
//³no ApdOld (array salvo com vlrs antes do reajuste)  	             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If lDissidio .and. Ascan(aPdOld, { |X| X[1] == aCodfol[18,1] .And. X[3] == cSemana } ) == 0 .and. !Empty(SRA->RA_DEMISSA)

	nPos := Ascan(aPdOld, { |X| X[1] == aCodfol[17,1] .And. X[3] == cSemana } )

	If nPos > 0

		Aadd(aPdOld,{aCodfol[18,1],;
				  aPdOld[nPos,2],;
				  aPdOld[nPos,3],;
				  aPdOld[nPos,4],;
				  Round((aPdOld[nPos,5])*nPerFgts,2),;
				  aPdOld[nPos,6],;
				  aPdOld[nPos,7],;
				  aPdOld[nPos,8],;
				  aPdOld[nPos,9],;
				  aPdOld[nPos,10],;
				  aPdOld[nPos,11],;
				  aPdOld[nPos,12],;
				  aPdOld[nPos,13],;
				  aPdOld[nPos,14]})          
				  
	EndIf
EndIf

If P_ADCFGTS > 0
	nPeric 	 := nPericAux
	nInsalub := nInsalubAux
EndIf

Return

/*/{Protheus.doc} fCfgtsRtf
Função que apura o FGTS da retificação
@author Allyson Mesashi
@since 08/04/2021
@version P12.1.27
/*/
Function fCfgtsRtf(aCodfol, nFgts_b, cGrava, nAfasFgts, cTipo, lTrunca)

Local nBaseAnt		:= 0
Local nCont			:= 0
Local nFgtsAnt		:= 0
Local nPerFgts	 	:= 0
Local lSemana	 	:= If( cSemana # Space( 2 ), .T., .F.)
 
DEFAULT cTipo 		:= " "
DEFAULT lTrunca 	:= .T. 
DEFAULT lTCpoFgts  	:= ( Type("SRA->RA_PERFGTS") # "U" )

//--Situacao do Funcionario na data de referencia
cSitFolh			:= If( Type("cSitFolh") == "U", SRA->RA_SITFOLH, cSitFolh)
cTipoRot			:= If( Type("cTipoRot") == "U", "", cTipoRot)
lResExt				:= If( Type("lResExt") == "U", .F., lResExt)
cEncResExt			:= If( Type("cEncResExt") == "U" .Or. Empty(cEncResExt), "1234", cEncResExt)

If nAfasFgts == Nil
	nAfasFgts := 0
EndIf

If SRA->RA_CATFUNC == "P" .And. (!lTCpoFgts .Or. SRA->RA_PERFGTS == 0.00)
	Return
EndIf

//--Verifica Qual Percentual de FGTS deve Aplicar 
If lTCpoFgts .And. SRA->RA_PERFGTS > 0.00
	nPerFgts := SRA->RA_PERFGTS / 100
Else
	nPerFgts := If(SRA->RA_TPCONTR $ " *1*3", nFgtsCt1, nFgtsCt2)
EndIf

If lResExt .And. !("3" $ cEncResExt)
	nPerFgts := 0
EndIf

nFgts_b 	:= 0

If Ascan(aPd,{ |X| X[1] == aCodfol[18,1] .And. X[9] # "D" .And. X[3] == cSemana }) == 0
	For nCont := 1 To Len(aPd)
		If aPd[nCont, 1] == aCodFol[17,1] .and. aPd[nCont, 9] # "D"//Base FGTS
			nBaseAnt += aPd[nCont, 5]
		EndIf
		If aPd[nCont, 1] == aCodFol[18,1] .and. aPd[nCont, 9] # "D"//Codigo FGTS Deposito
			nFgtsAnt += aPd[nCont, 5]
		EndIf
	Next nCont

	// Soma Base do fgts                                                           
	Aeval(aPd,{ |X| nFgts_B += If( X[1] == aCodFol[017,1] .And. X[9] # "D" .And. X[3] == cSemana, X[5], 0)})
	
	If nFgts_B = 0.00 
		// Soma Incidencia para Base de Fgts
		Aeval( aPd, { |X| If( X[1] <> aCodFol[042,1], SomaInc(X, 6, @nFgts_b, 12, "N", , , , lSemana, aCodFol), Nil) } )
	EndIf

	If cGrava # Nil .And. cGrava == "S"	 
		If lTrunca
			nVfgts := NoRound( nFGTS_B * nPerFgts ,2)
		Else
			nVfgts := Round( nFGTS_B * nPerFgts,2)
		EndIf

		nFGTS_B := Max(nFGTS_B - nBaseAnt, 0)
		nVfgts 	:= Max(nVfgts - nFGTSAnt, 0)
		
		FMatriz(aCodfol[18,1], nVfgts)
		FMatriz(aCodfol[17,1], nFGTS_B)
	EndIf
EndIf    

Return

/*/{Protheus.doc} fBsFgtsAdic
	Adicionais na base fgts
	@since 26/03/2020
/*/
Function fBsFgtsAdic(aAdic, lInco, nDiasInss)
Local lBaseINSS 	:= .F.
Local lIncoNFGTS 	:= .T.
Local aAdicFGTS  	:= { {cCodConf,nAdcConf} , {cCodIns,nInsalub} , {cCodPer,nPeric} , {cCodTrf,nAdcTrf} }
Local cCodVerba  	:= ""
Local nValVerba  	:= 0
Local nX         	:= 0
Local nPosPd		:= 0
Local cTipoPd 	 	:= ""
Local nDiasAdc	 	:= 0
Local nHrsTot		:= 0
Local nBsAdic		:= 0

DEFAULT aAdic		:= {}
DEFAULT lInco		:= .T. 
DEFAULT nDiasInss	:= 0

cTipoRot 	:= If( Type("cTipoRot")   == "U","",cTipoRot)
lBaseINSS 	:= (nDiasInss > 0)

If !Empty(cTipoRot) .And. Len( aAdtServ ) > 0
	 For nx := 1 to Len(aAdtServ)
	 	aAdd(aAdicFGTS, { aAdtServ[nX][1], aAdtServ[nX][3] })
	 Next nX 
EndIf

aAdic := aClone(aAdicFGTS)

If aScan( aAdicFGTS, { |x| x[2] > 0 } ) > 0 .And. DiasTrab+nDaPaPg == nDiasC .And. RetValSRV(aCodFol[42,1], SRA->RA_FILIAL, "RV_BASCAL") != "2"
	Return 0
EndIf

For nX := 1 To Len(aAdicFGTS)
	cCodVerba := aAdicFGTS[nX,1]
	nValVerba := aAdicFGTS[nX,2]
	If !Empty(cCodVerba)
		cTipoPd := RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_TIPO" )
	EndIf

	If nValVerba > 0
		lIncoNFGTS := lIncoNFGTS .And.;
		( ( RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_INCORP" ) == "S" .And. RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_FGTS" ) == "N" ) .Or.;
		( RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_INCORP" ) == "S" .And. RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_FGTS" ) == "S" .And. DiasTrab > 0 ) )
		If lBaseINSS .And. RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_INCORP" ) == "S"
			Loop
		EndIf
		If ( RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_FGTS" ) == "S" )
			nPosPd := Ascan(aPd,{ |X| X[1] == cCodVerba .And. X[9] # "D"})
			//Se a verba tem incidência de FGTS, e esta no aPd, subtrai da base o que já foi somado.
			If nPosPd > 0 .and. RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_FGTS" ) == "S" .and. RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_REF13" ) <> "S"
				nBsAdic -= aPd[nPosPd,5]
			EndIf
			If RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_INCORP" ) <> "S" 
				If !lIncoNFGTS
					nBsAdic += (nValVerba / nDiasC) * ( nDiasFgts + DiasTrab )
				Else	
					nBsAdic += (nValVerba / nDiasC) * ( nDiasFgts )								
				EndIf
			Else
				If !lIncoNFGTS .And. nPosPd > 0 .And. DiasTrab > 0
					nBsAdic += aPd[nPosPd,5]
				Elseif DiasTrab > 0	
					nBsAdic += (nValVerba / nDiasC) * ( nDiasFgts + DiasTrab )
				EndIf							
			EndIf						
		EndIf
		If DiasTrab > 0 .and. nDiasPG < nDiasFgts .and. ( RetValSRV( cCodVerba, SRA->RA_FILIAL, "RV_FGTS" ) == "S" )
			If ( nPosPd := Ascan(aPd,{ |X| X[1] == cCodVerba .And. X[9] # "D"}) ) > 0
				//Se os dias de adicionais forem superiores aos dias trabalhados, proporcionaliza o pagamento de acordo com os dias trabalhados.
				If cTipoPd <> "H"
					If aPd[nPosPd,4] > DiasTrab
						nBsAdic -= aPd[nPosPd,5]
						nBsAdic += ( aPd[nPosPd,5] / (nDiasPg + DiasTrab) ) * DiasTrab
					EndIf
				Else
					nDiasAdc := Int( aPd[nPosPd,4] / SRA->RA_HRSDIA )
					If nDiasAdc > DiasTrab
						nHrsTot := (nDiasPg + DiasTrab) * SRA->RA_HRSDIA
						nBsAdic -= aPd[nPosPd,5]
						nBsAdic += ( aPd[nPosPd,5] / nHrsTot ) * aPd[nPosPd,4]
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
Next nX

lInco := lIncoNFGTS

Return nBsAdic


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fCFgts13 ³ Autor ³ Mauro                 ³ Data ³25/05/95  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do FGTS  Funcionario 13o.                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCFgts13(aCodfol)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCfgts13(aCodfol, nfgts13_b, cGrava, lCond, cTipo, lTrunca, nFgts13_Mil, nFgts13_Aci)

Local dDataIni,dDataFim,nPosCod1,nPosCod2,nAvos_OQ,nAvos_R,n13AvInd,lSomouPri
Local nBs13Srd		:= 0
Local nArred13		:= 0
Local nPerFgts  	:= 0
Local nAvosAci		:= 0
Local nValAux		:= 0
Local lTCpoFgts 	:= ( Type("SRA->RA_PERFGTS") # "U" )
Local cTipAfa   	:= If( Type("cAbatAfas") == "U", GetMvRH("MV_ABATAFA"), cAbatAfas)
Local cCodigos		:= ""
Local cMedDire		:= P_MEDDIREN
Local nValMedDir	:= 0
Local aVerbasLanc	:= {}
Local aPerAberto	:= {}
Local aPerFechado	:= {}
Local nPos			:= 0
Local nbasetot      := 0
Local nfgtstot      := 0
Local nVal1730		:= 0
Local nAvAux		:= 0
Local lTemId1848	:= Len(aCodFol) >= 1848 .And. !Empty(aCodFol[1848, 1])
Local lTemId1849	:= Len(aCodFol) >= 1848 .And. !Empty(aCodFol[1849, 1])
Local lTemId1883    := Len(aCodFol) >= 1883 .And. !Empty(aCodFol[1883, 1])

DEFAULT nFgts13_Mil	:= 0
DEFAULT nFgts13_Aci := 0

//--Situacao do Funcionario na data de referencia
cSitFolh	:= If( type("cSitFolh")=="U",SRA->RA_SITFOLH,cSitFolh)

lCond 		:= If (lCond = Nil , .T. , lCond)   // Condicao para Somainc
cTipo 		:= If (cTipo = Nil , " " , cTipo)
lTrunca 	:= If (lTrunca = Nil , .T. , lTrunca)
lResExt		:= If( Type("lResExt") 	== "U"	, .F., lResExt)
cEncResExt	:= If( Type("cEncResExt") == "U" .Or. Empty(cEncResExt), "1234", cEncResExt)

If cSitFolh = "D"  .And. cTipo # 'R'
	Return
EndIf

If SRA->RA_CATFUNC = "P" .And. (!lTCpoFgts .Or. SRA->RA_PERFGTS == 0.00)
	Return
EndIf

//Inicializa caso nao tenham sido criadas
aAfast  := If(Type("aAfast") == "U", {}, aAfast)
nAvos   := If(Type("nAvos")  == "U",  0, nAvos)

//--Verifica Qual Percentual de FGTS deve Aplicar 
If lTCpoFgts .And. SRA->RA_PERFGTS > 0.00
	nPerFgts := SRA->RA_PERFGTS / 100
Else
	nPerFgts := If (SRA->RA_TPCONTR$ " *1*3",nFgtsCt1,nFgtsCt2)
EndIf

If lResExt .And. !("3" $ cEncResExt)
	nPerFgts := 0
EndIf

nFgts13_b := 0
If Ascan(aPd,{ |X| X[1] = aCodfol[109,1] .And. X[3] == cSemana .And. X[9] # "D"}) = 0
	// Soma Base do fgts 13o
	If SRA->RA_TPCONTR == "3" .And. SRA->RA_TIPOPGT == "S"
		Aeval(aPd,{ |X| nFgts13_B += If ( X[1]==aCodFol[108,1] .And. X[3] == cSemana .And. X[9] # "D" ,X[5] ,0)})
		//--Somar Fgts Semanas Anteriores
		If cSemana # Space( 2 ) .And. cSemana > "01"
			Aeval( aPd,{ |X| nbasetot += If( X[1]=aCodFol[108,1] .And. x[3] < cSemana,x[5],0 ) } )
			Aeval( aPd,{ |X| nfgtstot += If( X[1]=aCodFol[109,1] .And. x[3] < cSemana,x[5],0 ) } )	
		EndIf
	Else
		Aeval(aPd,{ |X| nFgts13_B += If ( X[1]==aCodFol[108,1] .And. X[9] # "D" ,X[5] ,0)})
	EndIf
	If nFgts13_b = 0
		nFgts13_B	:= 0.00
		nArred13	:= 0.00
		//-- Soma Incidencia para Base de Fgts
        Aeval( aPd ,{ |X| SomaInc(X,6,@nFgts13_b,If(lCond,12,Nil),If(lCond,"S",Nil), , , , ,aCodFol) })
	    If SRA->RA_TPCONTR == "3"
			Aeval( aPdConvoc ,{ |X| SomaInc(X,6,@nFgts13_b,If(lCond,12,Nil),If(lCond,"S",Nil), , , , ,aCodFol) })
		EndIf

		//-- Data inicial e final para calculo do 13o. salario
   		dDataIni := If(MesAno(dDataAte) == MesAno(SRA->RA_ADMISSA),SRA->RA_ADMISSA,CTOD("01/01/"+StrZero(Year(dDataAte),4)))
		dDataFim := CTOD("31/12/"+StrZero(Year(dDataAte),4))

		If cTipoRot $ "6*4" .and. RetValSRV(aCodFol[26,1], SRA->RA_FILIAL, "RV_FGTS") != "S"
			fBuscaAcmPer(aCodFol[26,1], "", "V", @nArred13, , AnoMes(dDataIni), AnoMes(dDataFim), ,, fGetCalcRot("1")+fGetCalcRot("5"), .T. , .F.  )
			nFgts13_b += nArred13
		EndIf

		//-- Se folha de pagamento e houver base, buscar afastamento para recalcular base integral
		//-- Se a verba de 13o tiver sido paga em ferias ("K"), nao buscar afastamentos
	    If cTipoRot == "1" .And. (Ascan( aPd, { |X| X[1] == aCodFol[22,1] .And. X[7] == "K" }) == 0)
		    nAvosAf := 0
	    	If nFgts13_B > 0
		    	fAvos13(@nAvos,dDataAte,0,0,"1")
		    	fRetAfas(dDataIni,dDataFim,If(cTipAfa=="S","O*P*Q*X*B",cTipAfa),@nAvosAf,,,@aAfast)
				nAvos := Max(0, nAvos - nAvosAf)
		    EndIf
	    EndIf
	    
	    //Quando for dissidio, estiver calculando a segunda parcela do 13º e utilizar reajuste de 13º pelas verbas incorporadas na folha, carrega as verbas que incorporaram na folha
		If nFgts13_b > 0 .and. cTipoRot $ "1*6" .and. lDissidio .and. Type("P_LDIFINC") <> "U" .And. P_LDIFINC
			fRetPerComp(SubStr(cPeriodo,5,2), SubStr(cPeriodo,1,4), Nil, Nil, fGetRotOrdinar(), @aPerAberto, @aPerFechado)
			aVerbasLanc := RetornaVerbasFunc(SRA->RA_FILIAL,SRA->RA_MAT,NIL,fGetRotOrdinar(),,aPerAberto,aPerFechado,,"RV_INCORP=='S'")
			If Len(aVerbasLanc) > 0
				If cTipoRot == "6"
					For nPos := 1 to Len(aVerbasLanc)
						nFgts13_b += aVerbasLanc[nPos,7]
					Next nPos
				ElseIf IsInCallStack("GravaDissidio") .and. Len(aPercDif) > 0
					nIndice := aPercDif[Len(aPercDif),2]
					For nPos := 1 to Len(aVerbasLanc)
						nFgts13_b -= ( aVerbasLanc[nPos,7] * (nIndice/100))
					Next nPos
				EndIf
			EndIf
		EndIf	    

		// Calcula FGTS com base total se afastamento acidente de trabalho ou militar
		nAvos_OQ := 0
		nAvos_R := 0
	    Aeval( aAfast ,{ |X| nAvos_OQ += If( ( Left( X[16], 1 ) == "O" .or. X[16] $ "Q4*Q5*Q6" ), X[1], 0 ) }) //--Acidente de trabalho o adoção
	    Aeval( aAfast ,{ |X| nAvos_r += If( Left( X[16], 1 ) $ "R", X[1], 0 ) })
		If (nAvos_OQ > 0 .Or. nAvos_R > 0) .And. nAvos > 0 .And. nFgts13_B > 0

			// Busca valor do desconto da 1a parcela e devolve para achar total do 13o.
			lSomouPri := .F.
			nPosCod1   := Ascan(aPd,{ |X| X[1] == aCodfol[183,1] .And. X[9] # "D"} )
			nPosCod2   := 0
			If nPosCod1 == 0
				nPosCod2 := Ascan(aPd,{ |X| X[1] == aCodfol[116,1] .And. X[9] # "D"} )
         	EndIf
			If (nPosCod1 > 0 .And.  RetValSRV(aCodFol[183,1],SRA->RA_FILIAL,"RV_FGTS") == "S") .Or. ;
			   (nPosCod2 > 0 .And.  RetValSRV(aCodFol[116,1],SRA->RA_FILIAL,"RV_FGTS") == "S")
				fBuscaAcmPer(aCodFol[108,1], "", "V", @nBs13Srd, , AnoMes(dDataIni), AnoMes(dDataFim), ,, fGetCalcRot("1")+fGetCalcRot("5"), .T. , .F.  )
				//-- Soma o valor da 1a parcela somente se a 1a parcela estiver acumulada no SRD
				//-- caso contrario nao soma pois a rescisao esta ocorrendo no mesmo mes do pagamento
				//-- da 1a parcela do 13o salario.
				If nBs13Srd > 0
		  			nFgts13_B  += aPd[If(nPosCod1 > 0, nPosCod1, nPosCod2),5]
					lSomouPri  := .T.
		  		EndIf
			EndIf

			fBuscaAcmPer(aCodFol[1730,1], "", "V", @nVal1730, , AnoMes(dDataIni), AnoMes(dDataFim), ,, fGetCalcRot("1")+fGetCalcRot("5"), .T. , .F.  )
			// Salva o valor das medias ocorridas no movimento e desconta da base de calculo
			// quando o parametro MV_MEDDIRE estiver com "S" Meses de Direito.
			If cMedDire == "S"
				cCodigos	+= If(!empty(aCodFol[123,1]) .And. RetValSRV(aCodFol[123,1],SRA->RA_FILIAL,"RV_FGTS") == "S",aCodFol[123,1]+",","")
				cCodigos	+= If(!empty(aCodFol[124,1]) .And. RetValSRV(aCodFol[124,1],SRA->RA_FILIAL,"RV_FGTS") == "S",aCodFol[124,1]+",","")
				cCodigos	+= If(!empty(aCodFol[251,1]) .And. RetValSRV(aCodFol[251,1],SRA->RA_FILIAL,"RV_FGTS") == "S",aCodFol[251,1]+",","")
				cCodigos	+= If(!empty(aCodFol[253,1]) .And. RetValSRV(aCodFol[253,1],SRA->RA_FILIAL,"RV_FGTS") == "S",aCodFol[253,1],"")
				nValMedDir	:= fBuscaPd(cCodigos,"V")
			EndIf

			// Abate o valor encontrado de medias quando o parametro MV_MEDDIRE estiver com "S"
			nFgts13_B	-= nValMedDir
			
			// Se roteiro de rescisao, abater avo indenizado para depois calcular
			If cTipoRot == "4"
				n13AvInd := 0
				Aeval(aPd,{ |X| n13AvInd += If ( X[1]==aCodFol[115,1] .And. X[9] # "D" ,X[5] ,0)})
				
				If n13AvInd > 0 .And. RetValSRV(aCodFol[115,1],SRA->RA_FILIAL,"RV_FGTS") == "S"
		  			nFgts13_B -= n13AvInd
		  		Else
		  			n13AvInd := 0.00	
				EndIf

				nAvAux := nAvos + If( !lTemId1849, nAvos_R, 0) + nAvos_OQ

				nFgts13_B 	:= Round( fRetDec(@nFgts13_B) / nAvos * nAvAux, 2 )

				If lTemId1849
  					nFgts13_Mil := Round( nFgts13_B / nAvos * nAvos_R, 2 )
				EndIf

				If lTemId1883 .and. nAvos_OQ > 0
					nFgts13_Aci := Round( nFgts13_B / ( nAvos + nAvos_OQ ) * nAvos_OQ, 2 )
				EndIf

				nFgts13_B += n13AvInd
	  		Else
	  			nValAux	  := nFgts13_B
	  			If !lTemId1849
					nFgts13_B 	:= Round( fRetDec(@nFgts13_B) / nAvos * (nAvos + nAvos_OQ + nAvos_R), 2 )
				Else
					nFgts13_Mil := Round( nFgts13_B / nAvos * nAvos_R, 2 )
					If nAvos_OQ > 0
						nFgts13_B 	:= Round( fRetDec(@nFgts13_B) / nAvos * (nAvos + nAvos_OQ), 2 )
					EndIf
				EndIf
			EndIf
			// Soma o valor encontrado de medias quando o parametro MV_MEDDIRE estiver com "S"
			nFgts13_B	+= nValMedDir
			// Subtrai base da 1a parcela para achar base da 2a.
			If lSomouPri
  				nFgts13_B -= nBs13Srd
  			EndIf
  			
  			If cTipoRot == "6" .and. nValAux > 0
	  			//Verifica se houve afastamento por acidente de trabalho para gerar a verba 1730
				Aeval( aAfast ,{ |X| nAvosAci += If( X[16] == "O1", X[1], 0 ) })
				
				If nAvosAci > 0
					nValAux := Round( fRetDec(@nValAux) / nAvos * (nAvosAci), 2 )
					FMatriz(aCodfol[1730,1],Max(nValAux-nVal1730, 0),0,cSemana)
				EndIf
			EndIf
		EndIf
		// Calcula FGTS para funcionario afastado durante todo o ano por Acidente ou Militar
	    If cTipoRot == "4"
	    	If nFgts13_B == 0 .And. nAvos == 0 .And. (nAvos_OQ > 0 .Or. nAvos_R > 0)
				nAvAux := If( !lTemId1849, nAvos_R, 0) + nAvos_OQ
				
				nFgts13_B := (((SalMes + nAdtServ + nPeric + nInsalub ) / 12) * nAvAux ) + nMed13o
				
				If lTemId1849 .and. nAvos_R > 0
					nFgts13_Mil	:= (((SalMes + nAdtServ + nPeric + nInsalub ) / 12) * nAvos_R )
				EndIf
				If lTemId1883 .and. nAvos_OQ > 0
					nFgts13_Aci	:= (((SalMes + nAdtServ + nPeric + nInsalub ) / 12) * nAvos_OQ )
				EndIf
			EndIf
	    ElseIf cTipoRot == "6"
			If nFgts13_B == 0
				nBs13Srd := 0
				If nAvos_OQ+nAvos_R == 12 .And. Left(SRA->RA_AFASFGT,1) $ "O*B*R"
					nBs13Srd  := fBuscaAcm(aCodFol[108,1],,dDataIni,dDataFim,"V")
					If !lTemId1848 .Or. nAvos_R == 0
						nFgts13_B 	:= salmes - nBs13Srd
					Else
						nFgts13_Mil	:= salmes - nBs13Srd
					Endif
				//Funcionario afastado durante todo o ano, mas somente parte foi por Acidente ou Adocao
				ElseIf nAvos == 0 .And. nAvos_OQ+nAvos_R > 0					
					If !lTemId1848
						nFgts13_B 	:= ( (SalMes / 12) * (nAvos_OQ+nAvos_R) )
					Else
						nFgts13_B 	:= ( (SalMes / 12) * nAvos_OQ )
						nFgts13_Mil := ( (SalMes / 12) * nAvos_R )
					EndIf
				EndIf			
			   	If nAvos_OQ > 0
			   		nAvosAci := 0
		  			//Verifica se houve afastamento por acidente de trabalho para gerar a verba 1730
					Aeval( aAfast ,{ |X| nAvosAci += If( X[16] == "O1", X[1], 0 ) })
					
					If nAvosAci > 0
						nValAux := SalMes - nBs13Srd
						nValAux := Round( fRetDec(@nValAux) / 12 * (nAvosAci), 2 )
						FMatriz(aCodfol[1730,1],nValAux,0,cSemana)
					EndIf
				EndIf				
			EndIf
		EndIf
	EndIf

	If cGrava # Nil .And. cGrava = "S"

		If lTrunca
			nVfgts13 := NoRound( (nFgts13_B+nFgts13_Mil) * nPerFgts,2)
		Else
			nVfgts13 := Round( (nFgts13_B+nFgts13_Mil) * nPerFgts,2)
		EndIf

		FMatriz(aCodfol[109,1],nVfgts13 - nfgtstot)
		FMatriz(aCodfol[108,1],nFgts13_B - nbasetot)

		If lTemId1848 .and. nFgts13_Mil > 0
			FMatriz(aCodfol[1848,1],nFgts13_Mil)
		EndIf
		If lTemId1883 .and. nFgts13_Aci > 0
			FMatriz(aCodfol[1883,1],nFgts13_Aci)
		EndIf
	EndIf
EndIf

Return
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fCSalC   ³ Autor ³ Equipe RH             ³ Data ³06/02/99  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do Inss Pro-Labore Autonomo                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fCSalC(aCodfol,aTSalC)                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCSalC(aCodfol,aTSalC)

Local nX      := 0
Local aPdBkp  := {}
Local lMultv := Type("lUtiMultiV") <> "U" .And. lUtiMultiV

nSalc_b := 0.00
nSalC_c := 0.00
nInssSc := 0.00

If lMultv
	aPdBkp := AClone(aPd)
	For nX := 1 To Len(aPd)
		If aPd[nX,3] <> cSemana
			aPd[nX,3] := cSemana
		EndIf
	Next nX
EndIf

If lInssAut .Or. lAutMei //Campo RA_INSSAUT igual a Sim ou vazio OU autônomo MEI
	If Ascan(aPd,{ |X| X[1] = aCodfol[222,1] .And. X[3] = cSemana .And. X[9] # "D"}) = 0
		If SRA->RA_CATEG $ "17|18"	
			//--Soma Base Pro-Labore lancada
			Aeval(aPd,{ |X| nSalC_c += If ( X[1]$ aCodfol[1384,1] .And. X[3] = cSemana .And. X[9] # "D" ,X[5] ,0)})
			If nSalc_c = 0.00
				//-- Soma Incidencia para Inss
				Aeval( aPd ,{ |X| If (x[3] == cSemana,SomaInc(X,4,@nSalC_c  ,11,"N",12,"N", , ,aCodfol),"")})
		   EndIf
		Else
			//--Soma Base Pro-Labore lancada
			Aeval(aPd,{ |X| nSalC_b += If ( X[1]$ aCodfol[221,1] .And. X[3] = cSemana .And. X[9] # "D" ,X[5] ,0)})
			If nSalc_B = 0.00
				//-- Soma Incidencia para Inss
				Aeval( aPd ,{ |X| If (x[3] == cSemana,SomaInc(X,4,@nSalC_b ,11,"N",12,"N", , ,aCodfol),"")})
			EndIf
		EndIf
	EndIf
EndIf

If lMultv
	aPd := AClone(aPdBkp)
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fCContrib ºAutor  ³Microsiga           º Data ³  09/24/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Calculo da Contribuicao sobre base Fgts                     º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP6                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCContrib()

Local lTCpoFgts := ( Type("SRA->RA_PERFGTS") # "U" )

Static cFilCtr
Static nPCtr
Static nPcTrR
Static cFilCtr13
Static nPCtr13
Static nPCtrR13

If SRA->RA_CATFUNC = "P" .And. (!lTCpoFgts .Or. SRA->RA_PERFGTS == 0.00)
	Return
EndIf

//--Carregar o % da contribuicao sobre Fgts
If cFilCtr = Nil .Or. cFilCtr # SRA->RA_FILIAL
	cFilCtr := SRA->RA_FILIAL
	nPCtr	:= RetValSRV(aCodFol[298,1],SRA->RA_FILIAL,"RV_PERC") /100
	nPCtrR	:= RetValSRV(aCodFol[295,1],SRA->RA_FILIAL,"RV_PERC") /100
EndIf	

//--Carregar o % da contribuicao sobre Fgts
If cFilCtr13 = Nil .Or. cFilCtr13 # SRA->RA_FILIAL
	cFilCtr13 := SRA->RA_FILIAL
	nPCtr13	  := RetValSRV(aCodFol[299,1],SRA->RA_FILIAL,"RV_PERC") / 100
	nPCtrR13  := RetValSRV(aCodFol[296,1],SRA->RA_FILIAL,"RV_PERC") / 100
EndIf	

//--Calculo da Contribuicao Sobre Base Fgts
If nPCtr > 0.00
	//-- Soma Base Fgts Folha
	nBaseMes := FBuscaPd(aCodFol[17,1],,cSemana)
	If nBaseMes > 0
		FMatriz(aCodfol[298,1],NoRound(nBaseMes * nPCtr,2) , nPCtr * 100)
	EndIf		
EndIf

If nPCtrR > 0
	//--Soma Base Resc. por Dispensa	
	nBaseRes := fBuscaPd(aCodFol[293,1],,cSemana)
    If nBaseRes > 0 
		FMatriz(aCodfol[295,1],NoRound(nBaseRes * nPCtrR,2) , nPCtrR * 100)
	EndIf	
EndIf	

//--Calculo da Contribuicao Sobre Base Fgts 13o.
If nPCtr13 > 0.00     
  
	//-- Soma Base Fgts 13o
	nBase13 := FBuscaPd(aCodFol[108,1],,cSemana)
	If nBase13 > 0
		FMatriz(aCodfol[299,1],NoRound(nBase13 * nPCtr13,2) , nPCtr13 * 100)
	EndIf	 
EndIf	
	 
If nPCtrR13 > 0	
    //-- Soma Base 13o. resc. por Dispensa
	nBRes13 := fBuscaPd(aCodFol[294,1],,cSemana)
	If nBres13 > 0
		FMatriz(aCodfol[296,1],NoRound(nBRes13 * nPCtrR13,2) , nPCtrR13 * 100)
	EndIf	
EndIf	

Return
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FCalcInssFun ³ Fatima    	            ³ Data ³ 06/11/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calculo Encargos Empresa por Funcionario                   ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCalcInssFun()

Local cRecFatEmp  := ""
Local cTpc        := ""
Local cAux		  := ""
Local cVerba	  := ""
Local cTpRotAnt	  := ""
Local nValBasInss := 0.00
Local nPercAcTrab := 0.00
Local nPercTer    := 0.00
Local nPercPro    := 0.00
Local nPercAut    := 0.00
Local nPercEmp    := 0.00
Local nPerFatEmp  := 0
Local nPercFPAS   := 0.00
Local nPercCC     := 0.00
Local nDed        := 0.00
Local nBasePis    := 0.00
Local nBseProAut  := 0.00
Local nTotBseAut  := 0.00
Local nRet        := 0.00
Local nX		  := 0
Local nRetFDes	  := 0.00
Local nComplEmp13 := 0.00
Local nComplEmpFol:= 0.00
Local nComplB13	  := 0.00
Local nComplBFol  := 0.00
Local lRotDiss	  := IsInCallStack( "GPEM690" )
Local lPercCC	  := .F.
Local lPercSRA    := .F.
Local lResComDis  := cTipoRot == "4" .And. cCompl == "S" .And. lRescDis
Local lOnera	  := ( cTipoRot == "4" .Or. cTipoRot == "6" )
Local lComplDis	  := IsInCallStack("GravaDissidio") //complemento 13 no dissidio
Local nPerc		  := 0
Local nValcus	  := 0.00
Local nIdDiss	  := 0
Local nIdTerc	  := 0
Local nIdSalEdu	  := 0
Local nIdIncra	  := 0
Local nIdSenai	  := 0
Local nIdSesi	  := 0
Local nIdSenac	  := 0
Local nIdSesc	  := 0
Local nIdSebrae	  := 0
Local nIdDpc	  := 0
Local nIdFaer	  := 0
Local nIdSenar	  := 0
Local nIdSeconc	  := 0
Local nIdSest	  := 0
Local nIdSenat	  := 0
Local nIdSescoop  := 0
Local nIdAdSenai  := 0
Local nValSENAI	  := 0
Local nBaseMes	  := 0 //Base INSS em casos de de rescisão complementar por dissidio dentro do mesmo mês.
Local nValAux 	  := 0
Local nBasEncarg  := 0
Local nValAuxAf	  := 0

Local cMesAberto  := cAnoMes //Mnemonico carregado na formula CARGARCH()
Local cOneFol	  := P_FDESFOL

Local aArea		  := GetArea()
Local aPdAfa 	  := {}
Local aPdMat 	  := {}
Local lComplFol	  := P_CCOMP13 == 'S' .And. lCalcFol .And. fTem132Per()
Local lTabS033	  := .F.
Local lProLab	  := (Len(aCodFol) >= 1430)
Local lAutCoo	  := (Len(aCodFol) >= 1448)
Local lGestPubl	  := IIF(ExistFunc("fUsaGFP"), fUsaGFP(), .F.)
Local cBkpRot	  := ""
Local nPosOnera	  := 0
Local lFpas582	  := .F.
Local lContrVA	  := SRA->RA_CATEFD $ '107/108'
Local lRot131	  := If( cTipoRot == "5"	, .T., .F.)
Local nLimiteVA	  := VAL_SALMIN * 1.5
Local lIntermit	  := SRA->RA_TPCONTR == "3"
Local cPdsCP15	  := ""

Private aInssEmp   
Private aGPSPer

Static cFilInss 
Static aInssEmpSt
Static aGPSPerSt

lRescDis	:= If( Type("lRescDis")=="U",.F.,lRescDis)//Rescisao Complementar por Dissidio
lProxMes    := If( Type("lProxMes") == "U", .F., lProxMes) // Rescisão complementar no próximo mês da original.
lDissidio	:= If(lDissidio == Nil,.F.,lDissidio) 
lResExt		:= If( Type("lResExt") 	== "U"	, .F., lResExt)
lInssAut	:= If( Type("lInssAut")	== "U"	, .T., lInssAut)
lEncPatro	:= If( Type("lEncPatro") == "U", .T., lEncPatro)
cEncResExt	:= If( Type("cEncResExt") == "U" .Or. Empty(cEncResExt), "123", cEncResExt)
lTabS033	:= Type( "aTabS033" ) == "U"
P_ENCEMP	:= If(Type("P_ENCEMP")=="U","", P_ENCEMP) //Define quais encargos terão as verbas de maternidade deduzidas. 1 = Todos
P_DEDMAT	:= If(!Empty(P_ENCEMP) .and. Type("P_DEDMAT")<>"U",P_DEDMAT,"") //Define quais verbas de maternidade serão deduzidas. 1 = Todos
P_ENCEMPAF	:= Iif(cPaisLoc == "BRA" .And. Type("P_ENCEMPAF")=="U", "", P_ENCEMPAF) //Define quais encargos terão as verbas de incidência CP 15 deduzidas. 1 = Todos

If !Empty(P_ENCEMP) .and. !(P_ENCEMP == '1') .and. !("*" $ P_ENCEMP)
	cAux := ""
	For nX := 1 to Len(P_ENCEMP) step 3
		cAux += SubStr(P_ENCEMP,nX,3) + "*"
	Next nX
	P_ENCEMP := cAux	
EndIf

If !Empty(P_DEDMAT)
	cAux := ""
	If !(P_DEDMAT == '1') .and. !("*" $ P_DEDMAT)
		For nX := 1 to Len(P_DEDMAT) step 3
			cVerba := SubStr(P_DEDMAT,nX,3)
			If RetValSrv( cVerba, SRA->RA_FILIAL, "RV_INSS" ) == "S"
				cAux += cVerba + "*"
			EndIf
		Next nX
		P_DEDMAT := cAux
	ElseIf P_DEDMAT == "1"
		aPdMat := fCarPdMat( cTipoRot == "4" .And. aScan(aPd, { |x| x[1] == aCodFol[247, 1] .And. x[9] != "D" } ) > 0 )
		For nX := 1 to Len(aPdMat)
			cAux += aPdMat[nX] + "*"
		Next nX
		P_DEDMAT := cAux
	EndIf 
EndIf

If !Empty(P_ENCEMPAF)	
	If !(P_ENCEMPAF == '1') .and. !("*" $ P_ENCEMPAF)
		cAux := ""
		For nX := 1 to Len(P_ENCEMPAF) step 3
			cAux += SubStr(P_ENCEMPAF,nX,3) + "*"
		Next nX
		P_ENCEMPAF := cAux	
	EndIf
	cAux := ""
	aPdAfa := fCarPdAfa()
	For nX := 1 to Len(aPdAfa)
		cAux += aPdAfa[nX] + "*"
	Next nX
	cPdsCP15 := cAux
EndIf

// Verifica tipo de contrato
If SRA->RA_TPCONTR$ " *1"
	cTpC  := "1"
Else	
	cTpC  := "2"
EndIf

// Carrega Array de Encargos da Empressa    
If aInssEmpSt == nil .or. Len(aInssEmpSt) == 0 .Or. cFilInss # SRA->RA_FILIAL
	RstGpexIni()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Resgata os percentuais de terceiros armazenados na tabela S035			³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	fGPSVal(SRA->RA_FILIAL,cMesAberto,@aGPSPerSt,cTpC)

	aInssEmpSt := Array(23,2)
	cFilInss := SRA->RA_FILIAL
	If !fInssEmp(SRA->RA_FILIAL,@aInssEmpSt,,If(cCompl == "S", MesAno(dDataDem), cMesAberto))	
		Return                            
	EndIf                                 
EndIf
aInssEmp := aInssEmpSt
aGPSPer  := aGPSPerSt

If !lRot131
	// Soma a Base de Inss
	If lRescDis .or. lDissidio
	If lRescDis 
			aEval(aPd,{ |x| nValBasInss += If ( X[1] $ aCodFol[338,1] + "/" + aCodFol[399,1] .And. x[9] != "D" .And. Empty(x[15]), x[5], 0) })
			//Se a rescisão por dissidio for dentro do mesmo mês.
			If !lProxMes
				aEval(aPd,{ |x| nBaseMes += If ( X[1]$ AcodFol[13,1]+"/"+aCodFol[14,1]+"/"+aCodFol[19,1]+"/"+aCodFol[20,1] .And. x[9] # "D",x[5],0.00) })
			EndIf
		Else
			aEval(aPd,{ |x| nValBasInss += If ( X[1]$ AcodFol[13,1]+"/"+aCodFol[14,1]+"/"+aCodFol[19,1]+"/"+aCodFol[20,1] .And. x[9] # "D",x[5],0.00) })
		EndIf
		
	Else
		aEval(aPd,{ |x| nValBasInss += If ( X[1]$ AcodFol[13,1]+"/"+aCodFol[14,1]+"/"+aCodFol[19,1]+"/"+aCodFol[20,1] .And. x[9] # "D" .And. If( cTipoRot == "N" .Or. lIntermit, x[3] == cSemana, .T. ),x[5],0.00) })
	EndIf

	If SRA->RA_TIPOPGT == "S" .And. !lUltSemana .And. !lIntermit
	nValBasInss := 0
	EndIf   

	cRecFatEmp 	:= aInssEmp[27, Val(cTpc)]//X14_RECFAT

	If nValBasInss > 0 .and. !SRA->RA_CATFUNC $ "AP"

		If !Empty(P_ENCEMP) .and. !Empty(P_DEDMAT)
			nValAux := 0
			aEval(aPd, {|x| If(x[1] $ P_DEDMAT .and. x[9] <> 'D', nValAux += x[5], Nil)})
		EndIf 
		If !Empty(P_ENCEMPAF) .and. !Empty(cPdsCP15)
			nValAuxAf := 0
			aEval(aPd, {|x| If(x[1] $ cPdsCP15 .and. x[9] <> 'D', nValAuxAf += x[5], Nil)})
		EndIf 

		If P_ENCEMP == "1" .and. nValAux > 0
			nValBasInss := Max(0,nValBasInss-nValAux)
		EndIf 
		If P_ENCEMPAF == "1" .and. nValAuxAf > 0
			nValBasInss := Max(0,nValBasInss-nValAuxAf)
		EndIf

		//-- Calculo % Acid. Trab. por Funcionario
		If lRescDis 
			nIdDiss:= 945 // Percentual Acidente Trabalho Dissidio
		Else 
			nIdDiss:= 150 // Percentual Acidente Trabalho
		EndIf

		If ( !lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "2" $ cEncResExt )
			nRet := (aScan( aPd, {|X| x[1] == aCodFol[nIdDiss, 1] .And. If( cTipoRot == "N" .Or. lIntermit, x[3] == cSemana, .T. )} ))	// Testa se já existe
			nBasEncarg := nValBasInss
			If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdDiss, 1] $ P_ENCEMP
				nBasEncarg -= nValAux
			EndIf
			If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdDiss, 1] $ P_ENCEMPAF
				nBasEncarg -= nValAuxAf
			EndIf
			If nRet == 0  .or. lRescDis 
				fBuscaAci(@nPercAcTrab, @nPercTer)
				fMatriz(aCodfol[nIdDiss, 1], Round(nBasEncarg * nPercAcTrab, 2))	// Acidente Trabalho
				//Se a rescisão por dissidio for dentro do mesmo mês da original.
				If !lProxMes
					fMatriz(aCodfol[150, 1], Round(nBaseMes * nPercAcTrab, 2))	// Acidente Trabalho
				EndIf
			ElseIf aPd[nRet,9] == "D"
				fBuscaAci(@nPercAcTrab, @nPercTer)
				fMatriz(aCodfol[nIdDiss, 1], Round(nBasEncarg * nPercAcTrab, 2))	// Acidente Trabalho
			ElseIf lComplFol .or. ( P_CCOMP13 == 'S' .And. lCalcFol .And. cTipoRot == "6" .and.  AnoMes(SRA->RA_ADMISSA) == cPeriodo ) //Se funcionário foi admitido após o pagamento do 132, lCalcFol estará .F., porém, deve ser tratado da mesma forma quando é complementar.
				fBuscaAci(@nPercAcTrab, @nPercTer)
				fMatriz(aCodfol[nIdDiss, 1], Round(nValBasInss * nPercAcTrab,2),,,,,,,,,.T.)	// Acidente Trabalho
			EndIf
		EndIf

		If !lContrVA .Or. (lContrVA .And. P_ENCARGVA)
			If lContrVA 
				If nValBasInss > nLimiteVA
					nValBasInss := nValBasInss - nLimiteVA
				Else
					nValBasInss := 0
				EndIf
			EndIf

			dbSelectArea("CTT")

			nPercFPAS := 0
			nPercEmp  := 0
			lFpas582  := .F.
			If CTT->(dbSeek( cFilial + SRA->RA_CC ))
				nPercFPAS   := CTT->CTT_PERFPA / 100
				nPercCC   	:= nPercFPAS
				lFpas582	:= Alltrim(CTT->CTT_FPAS) == '582'
				If Type("CTT_PEREMP") # "U"		
					nPercEmp    := CTT->CTT_PEREMP / 100
				EndIf
			EndIf
			
			If nPercFPAS > 0
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Deducao do percentual pago por convenios                    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nDed := 0
				For nPerc = 9 TO 19
					nDed += aInssEmp[nPerc,Val(cTpc)]
				Next
				
				nDed += aInssEmp[22,Val(cTpc)]
				nDed += aInssEmp[23,Val(cTpc)]
				nDed += fP15Terc(SRA->RA_CC,aGPSPer,"*") //Deduzir o % de terceiros do parametro 15
			
				nPercFPAS -= nDed
				If nPercFPAS < 0
					nPercFPAS 	:= nPercCC
					lPercCC		:= .T.
				EndIf
			ElseIf !lFpas582
				nPercFPAS := aInssemp[2, Val(cTpc)]
			EndIf
			
			//-- Calcular Inss Empresa
			If !SRA->RA_CATFUNC $ "AP" 
			
				If lRescDis 
					nIdDiss		:= 943 // INSS Empresa Dissidio
					nIdTerc		:= 944
					nIdSalEdu	:= 959
					nIdIncra	:= 946
					nIdSenai	:= 947
					nIdSesi		:= 948
					nIdSenac	:= 949
					nIdSesc		:= 950
					nIdSebrae	:= 951
					nIdDpc		:= 952
					nIdFaer		:= 953
					nIdSenar	:= 954
					nIdSeconc	:= 955
					nIdSest		:= 956
					nIdSenat	:= 957
					nIdSescoop	:= 958
					nIdAdSenai 	:= 1396
				Else 
					nIdDiss		:= 148 // INSS EMPRESA
					nIdTerc		:= 149
					nIdSalEdu	:= 204
					nIdIncra	:= 184
					nIdSenai	:= 185
					nIdSesi		:= 186
					nIdSenac	:= 187
					nIdSesc		:= 188
					nIdSebrae	:= 189
					nIdDpc		:= 190
					nIdFaer		:= 191
					nIdSenar	:= 192
					nIdSeconc	:= 193
					nIdSest		:= 200
					nIdSenat	:= 201
					nIdSescoop	:= 782
					nIdAdSenai	:= 1395
				EndIf

				//Se recolhe INSS s/ faturamento, chama fPerFatEmp p/ verificar os faturamentos na competencia
				//e, se for o caso, alterar a aliquota de calculo da contribuicao previdenciaria, ou,
				//nao gera a verba de INSS Empresa
				nRetFDes := (aScan( aPd,{|X| x[1] == aCodFol[1385,1]} ))
				If (cRecFatEmp $ "S*M*C" .And. ( Empty(cOneFol) .Or. cPeriodo <= cOneFol ) ) .Or. ( !Empty(cOneFol) .And. cPeriodo > cOneFol .And. SubStr(cOneFol,1,4) == SubStr(cPeriodo,1,4) .And. (nRetFdes > 0 .Or. lOnera ) )
					
					If lComplDis //complemento de 13 no dissidio
						//calcula %empresa 13
						cTpRotAnt := cTipoRot
						cTipoRot := "6" //altera temporariamente o tipo do roteiro de calculo para correta carga da tabela S033
						aTabS033 := {}
						fCarrTab( @aTabS033, "S033", If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]), .T. )
						aEval(aPd,{ |x| nComplB13 += If ( X[1]$ AcodFol[19,1]+"/"+aCodFol[20,1] .And. x[9] # "D",x[5],0.00) }) //base para complemento 13
						nPerFatEmp := fPerFatEmp( cRecFatEmp, nPercEmp, aInssEmp[1, Val(cTpc)], aTabS033, If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]),.T. )[5]
						nComplEmp13 := Round(nComplB13 * nPerFatEmp, 2)

						//calcula %empresa Fol
						cTipoRot = "1"
						aTabS033 := {}
						fCarrTab( @aTabS033, "S033", If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]), .T. )
						aEval(aPd,{ |x| nComplBFol += If ( X[1]$ aCodFol[13,1]+"/"+aCodFol[14,1] .And. x[9] # "D",x[5],0.00) }) //base para complemento fol
						nPerFatEmp := fPerFatEmp( cRecFatEmp, nPercEmp, aInssEmp[1, Val(cTpc)], aTabS033, If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]) )[1]
						nComplEmpFol := Round(nComplBFol * nPerFatEmp, 2)
						
						fMatriz(aCodfol[nIdDiss,1], nComplEmp13 + nComplEmpFol)   // Empresa
						nPerFatEmp := 0

						cTipoRot := cTpRotAnt
					Else
						If lTabS033 .And. (lRotDiss .Or. lResComDis)
							//Chama fCarrTab para recarregar tabela auxiliar S033
							aTabS033 := {}
							fCarrTab( @aTabS033, "S033", If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]), .T. )
						EndIf
						//Para a rescisao, folha e 13 salario, deve-se fazer o processo separadamente, pois o imposto da contribuicao
						//patronal da parte empresa sera calculada na rotina GPEM013
						If (lRotDiss .Or. lResComDis) .And. lInssAut .And. (( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "1" $ cEncResExt ))
							If cTipoRot == "6" //SE 132
								nPerFatEmp := fPerFatEmp( cRecFatEmp, nPercEmp, aInssEmp[1, Val(cTpc)], aTabS033, If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]),.T. )[5]
							Else
								nPerFatEmp := fPerFatEmp( cRecFatEmp, nPercEmp, aInssEmp[1, Val(cTpc)], aTabS033, If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]) )[1]
							EndIf
							If nPerFatEmp > 0
								nBasEncarg := nValBasInss
								If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdDiss, 1] $ P_ENCEMP
									nBasEncarg -= nValAux
								EndIf
								If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdDiss, 1] $ P_ENCEMPAF
									nBasEncarg -= nValAuxAf
								EndIf
								fMatriz(aCodfol[nIdDiss,1], Round(nBasEncarg * nPerFatEmp, 2))   // Empresa
								//Se não for rescisão do próximo mês.
								If lRescDis .And. !lProxMes
									fMatriz(aCodfol[148,1], Round(nBaseMes * nPerFatEmp, 2))   // Empresa
								EndIf
							EndIf
						ElseIf nRetFDes > 0 .And. (cTipoRot $ "4/6")
							aEval(aPd,{ |x| nComplB13 += If ( X[1]$ AcodFol[1385,1] .And. x[9] # "D",x[5],0.00) }) //base para complemento 13
							
							aTabS033 := {}
							cBkpRot := cTipoRot 
							cTipoRot := "6" 
							fCarrTab( @aTabS033, "S033", If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]), .T. )
							
							nPosOnera := Ascan(aTabS033, { |X| X[6] == "2" })
							If nPosOnera > 0
								cRecFatEmp := "oM"
							Else
								cRecFatEmp := "oS"
							Endif			
							
							nPerFatEmp := fPerFatEmp( cRecFatEmp, nPercEmp, aInssEmp[1, Val(cTpc)], aTabS033, If(lResComDis, dDataDem, aPeriodo[nPosSem, 3]),.T. )[5]
							cTipoRot := cBkpRot 
							
							If cRecFatEmp == "oM"
								nComplEmp13 := Round(nComplB13 * nPerFatEmp, 2)
							EndIf
							nComplEmpFol := Round((nValBasInss - nComplB13 ) * aInssEmp[1, Val(cTpc)], 2)
							nBasEncarg := nComplEmpFol + nComplEmp13
							If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdDiss, 1] $ P_ENCEMP
								nBasEncarg -= nValAux
							EndIf
							If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdDiss, 1] $ P_ENCEMPAF
								nBasEncarg -= nValAuxAf
							EndIf
							fMatriz(aCodfol[nIdDiss,1], Round(nBasEncarg,2),,,,,,,,,lComplFol)		// Empresa
						EndIf
					EndIf
				Else
					// Calculo de Complemento de 13 na Folha
					If lInssAut .And. (( !lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "1" $ cEncResExt ))
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdDiss, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdDiss, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodfol[nIdDiss,1], Round(nBasEncarg * If (nPercEmp > 0, nPercEmp, aInssEmp[1, Val(cTpc)]), 2),,,,,,,,,lComplFol)		// Empresa
						If lRescDis .And. !lProxMes
							fMatriz(aCodfol[148,1], Round(nBaseMes * If (nPercEmp > 0, nPercEmp, aInssEmp[1, Val(cTpc)]), 2),,,,,,,,,lComplFol)		// Empresa
						EndIf
					EndIf
				EndIf

				If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "4" $ cEncResExt )
					nBasEncarg := nValBasInss
					If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdTerc, 1] $ P_ENCEMP
						nBasEncarg -= nValAux
					EndIf
					If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdTerc, 1] $ P_ENCEMPAF
						nBasEncarg -= nValAuxAf
					EndIf
					fMatriz(aCodFol[nIdTerc, 1], Round(nBasEncarg * nPercFPAS , 2))									// Terceiros
					//Verifica se não rescisão do próximo mês.
					If lRescDis .And. !lProxMes
						fMatriz(aCodFol[149, 1], Round(nBaseMes * nPercFPAS, 2))									// Terceiros
					EndIf
				Endif
				If !lPercCC
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "5" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSalEdu, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSalEdu, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSalEdu, 1], Round(nBasEncarg * (aInssemp[09, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSalEdu, 1])), 2))	// Sal.Educ.
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[204, 1], Round(nBaseMes * (aInssemp[09, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSalEdu, 1])), 2))	// Sal.Educ.
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "6" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdIncra, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdIncra, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdIncra, 1], Round(nBasEncarg * (aInssemp[10, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdIncra, 1])), 2))		// Incra
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[184, 1], Round(nBaseMes * (aInssemp[10, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdIncra, 1])), 2))		// Incra
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "7" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSenai, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSenai, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSenai, 1], Round(nBasEncarg * (aInssemp[11, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenai, 1])), 2))		// Senai
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[185, 1], Round(nBaseMes * (aInssemp[11, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenai, 1])), 2))		// Senai
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "8" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSesi, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSesi, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSesi, 1], Round(nBasEncarg * (aInssemp[12, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSesi, 1])), 2))		// Sesi
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[186, 1], Round(nBaseMes * (aInssemp[12, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSesi, 1])), 2))		// Sesi
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "9" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSenac, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSenac, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSenac, 1], Round(nBasEncarg * (aInssemp[13, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenac, 1])), 2))		// Senac
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[187, 1], Round(nBaseMes * (aInssemp[13, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenac, 1])), 2))		// Senac
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "A" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSesc, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSesc, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSesc, 1], Round(nBasEncarg * (aInssemp[14, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSesc, 1])), 2))		// Sesc
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[188, 1], Round(nBaseMes * (aInssemp[14, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSesc, 1])), 2))		// Sesc
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "B" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSebrae, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSebrae, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSebrae, 1], Round(nBasEncarg * (aInssemp[15, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSebrae, 1])), 2))	// Sebrae
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[189, 1], Round(nBaseMes * (aInssemp[15, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSebrae, 1])), 2))	// Sebrae
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "C" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdDpc, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdDpc, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdDpc, 1], Round(nBasEncarg * (aInssemp[16, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdDpc, 1])), 2))			// Dpc
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[190, 1], Round(nBaseMes * (aInssemp[16, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdDpc, 1])), 2))			// Dpc
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "D" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdFaer, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdFaer, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdFaer, 1], Round(nBasEncarg * (aInssemp[17, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdFaer, 1])), 2))		// Faer
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[191, 1], Round(nBaseMes * (aInssemp[17, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdFaer, 1])), 2))		// Faer
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "E" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSenar, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSenar, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSenar, 1], Round(nBasEncarg * (aInssemp[18, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenar, 1])), 2))		// Senab
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[192, 1], Round(nBaseMes * (aInssemp[18, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenar, 1])), 2))		// Senab
						EndIf 
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "F" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSeconc, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSeconc, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSeconc, 1], Round(nBasEncarg * (aInssemp[19, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSeconc, 1])), 2))	// Seconc
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[193, 1], Round(nBaseMes * (aInssemp[19, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSeconc, 1])), 2))	// Seconc
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "G" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSest, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSest, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSest, 1], Round(nBasEncarg * (aInssemp[22, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSest, 1])), 2))		// Sest
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[200, 1], Round(nBaseMes * (aInssemp[22, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSest, 1])), 2))		// Sest
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "H" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSenat, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSenat, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSenat, 1], Round(nBasEncarg * (aInssemp[23, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenat, 1])), 2))		// Senat
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[201, 1], Round(nBaseMes * (aInssemp[23, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSenat, 1])), 2))		// Senat
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "I" $ cEncResExt )
						nBasEncarg := nValBasInss
						If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdSescoop, 1] $ P_ENCEMP
							nBasEncarg -= nValAux
						EndIf
						If !Empty(P_ENCEMPAf) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdSescoop, 1] $ P_ENCEMPAF
							nBasEncarg -= nValAuxAf
						EndIf
						fMatriz(aCodFol[nIdSescoop, 1], Round(nBasEncarg * (aInssemp[26, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSescoop, 1])), 2))	// Sescoop
						If lRescDis .And. !lProxMes
							fMatriz(aCodFol[782, 1], Round(nBaseMes * (aInssemp[26, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdSescoop, 1])), 2))	// Sescoop
						EndIf
					EndIf
					If ( ! lResExt .And. lEncPatro ) .Or. ( lResExt .And. lEncPatro .And. "J" $ cEncResExt )
						If Len(aCodFol) >= 1395 .And. Len(aInssemp) >= 30 .And. !Empty( aCodFol[nIdAdSenai,1] )
							nValSENAI := Round(nValBasInss * (aInssemp[11, Val(cTpc)]), 2)
							nValSENAI := Round(nValSENAI * (aInssemp[30, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[nIdAdSenai, 1])), 2)
							nPerc := RetValSrv(aCodFol[nIdAdSenai, 1], SRA->RA_FILIAL,"RV_PERC")
							If nPerc != 0
								nValSENAI := nValSENAI * ( nPerc / 100 )
							EndIf
							nBasEncarg := nValSENAI
							If !Empty(P_ENCEMP) .and. P_ENCEMP <> "1" .and. nValAux > 0 .and. aCodfol[nIdAdSenai, 1] $ P_ENCEMP
								nBasEncarg -= nValAux
							EndIf
							If !Empty(P_ENCEMPAF) .and. P_ENCEMPAF <> "1" .and. nValAuxAf > 0 .and. aCodfol[nIdAdSenai, 1] $ P_ENCEMPAF
								nBasEncarg -= nValAuxAf
							EndIf
							fMatriz(aCodFol[nIdAdSenai, 1], nBasEncarg,,,,,,,,,lComplFol)	// Senai 500 funcionarios
							If lRescDis .And. !lProxMes
								nValSENAI := Round(nBaseMes * (aInssemp[11, Val(cTpc)]), 2)
								nValSENAI := Round(nValSENAI * (aInssemp[30, Val(cTpc)] + fP15Terc(SRA->RA_CC, aGPSPer, aCodFol[1395, 1])), 2)
								nPerc := RetValSrv(aCodFol[1395, 1], SRA->RA_FILIAL,"RV_PERC")
								If nPerc != 0
									nValSENAI := nValSENAI * ( nPerc / 100 )
								EndIf
								fMatriz(aCodFol[1395, 1], nValSENAI,,,,,,,,,lComplFol)	// Senai 500 funcionarios
							EndIf
						EndIf
					Endif
				Endif
			EndIf
		EndIf
	Else
		//--Inss s/Prolabore e Autonomo

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calcula valor do Acidente de Trabalho (Aposent. Especial)   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If aScan( aPd,{|X| x[1] == aCodFol[150,1]} ) == 0 // Testa se ja existe
			fBuscaAci(@nPercAcTrab,,@lPercSRA)
			If nPercAcTrab > 0 .And. lPercSRA
				//--Monta Base de Inss
				aEval(aPd,{ |x| nBseProAut += If ( X[1]$ (aCodFol[217,1]+"x"+aCodFol[218,1] + If(lProLab, "x"+aCodFol[1430,1]+'x'+aCodFol[1431,1],"") + If(lAutCoo, "x"+aCodFol[1448,1],"")) .And. x[3] == cSemana .And. x[9] # "D",x[5],0.00) })
				If Len(aCodFol) > 1412
					aEval(aPd,{ |x| nBseProAut += If ( X[1]$ (aCodFol[1413,1]) .And. x[3] == cSemana .And. x[9] # "D",x[5],0.00) })
				Endif
				If nBseProAut > 0 .And. lEncPatro
					fMatriz(aCodfol[150,1],Round(nBseProAut * nPercAcTrab,2)) // Acidente Trabalho
				EndIf
			EndIf
		EndIf

		If !lContrVA .Or. (lContrVA .And. P_ENCARGVA)	
			If aCodFol[221,1] # Space(3) .Or. aCodFol[1384,1] # Space(3)	
				nValBasInss := 0
				If SRA->RA_CATEG $ "17|18"
					aEval(aPd,{ |x| nValBasInss += If ( X[1]$ AcodFol[1384,1] .And. x[3] == cSemana .And. x[9] # "D",x[5],0.00) })
				Else
					aEval(aPd,{ |x| nValBasInss += If ( X[1]$ AcodFol[221,1] .And. x[3] == cSemana .And. x[9] # "D",x[5],0.00) })
				Endif

				If lContrVA
					If nValBasInss > nLimiteVA
						nValBasInss := nValBasInss - nLimiteVA
					Else
						nValBasInss := 0
					EndIf
				EndIf
				//Se recolhe INSS s/ faturamento, chama fPerFatEmp p/ verificar os faturamentos na competencia
				//e, se for o caso, alterar a aliquota de calculo da contribuicao previdenciaria, ou,
				//nao gera a verba de INSS Empresa
				If (cRecFatEmp $ "S*M*C" .And. (cPeriodo <= cOneFol .Or. Empty(cOneFol) ))
					//Para a rescisao e folha, deve-se fazer o processo separadamente, pois o imposto da contribuicao
					//patronal da parte empresa sera calculada na rotina GPEM013   		
					If lTabS033 .And. lRotDiss
						//Chama fCarrTab para recarregar tabela auxiliar S033
						aTabS033 := {}
						fCarrTab( @aTabS033, "S033", dDatabase, .T. )
					EndIf
					//Para a rescisao, folha e 13 salario, deve-se fazer o processo separadamente, pois o imposto da contribuicao
					//patronal da parte empresa sera calculada na rotina GPEM013
					If lRotDiss .And. lEncPatro
						nPerFatEmp := fPerFatEmp( cRecFatEmp, nPercEmp, aInssEmp[1, Val(cTpc)], aTabS033, dDatabase )[1]
						If nPerFatEmp > 0
							fMatriz(aCodfol[148,1], Round(nValBasInss * nPerFatEmp, 2))   // Empresa
						EndIf
					EndIf
				Else
					If SRA->RA_CATEG $ "17|18" .and. lEncPatro
						nPercPro := RetValSRV( aCodFol[1384,1],SRA->RA_FILIAL,"RV_PERC") / 100
						If nPercPro = 1.00 .Or. (nPercPro = 0.00 .And. aInssemp[1,Val(cTpc)] # 0.00)
							nPercPro := 0.15
						Endif
						fMatriz(aCodfol[148,1],Round(nValBasInss * nPercPro,2))   // Empresa
					ElseIf lEncPatro
						nPercPro := RetValSRV( aCodFol[221,1],SRA->RA_FILIAL,"RV_PERC") / 100
						If nPercPro = 1.00 .Or. (nPercPro = 0.00 .And. aInssemp[1,Val(cTpc)] # 0.00)
							nPercPro := 0.20
						Endif
						fMatriz(aCodfol[148,1],Round(nValBasInss * nPercPro,2))   // Empresa
					Endif
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Base INSS Ref. Servicos Prestados Pessoa Fisica e Juridica  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If aCodFol[350,1] # Space(3) .And. aCodFol[353,1] # Space(3)
				nValBasInss := nTotBseAut := 0
				aEval(aPd,{ |x| nValBasInss += If ( X[1]$ AcodFol[350,1] .And. x[9] # "D",x[5],0.00) })
				//Se recolhe INSS s/ faturamento, chama fPerFatEmp p/ verificar os faturamentos na competencia
				//e, se for o caso, alterar a aliquota de calculo da contribuicao previdenciaria, ou,
				//nao gera a verba de INSS Empresa
				
				If lContrVA
					If nValBasInss > nLimiteVA
						nValBasInss := nValBasInss - nLimiteVA
					Else
						nValBasInss := 0
					EndIf
				EndIf
				
				If cRecFatEmp $ "S*M*C"
					//Para a rescisao e folha, deve-se fazer o processo separadamente, pois o imposto da contribuicao
					//patronal da parte empresa sera calculada na rotina GPEM013     		
					If lTabS033 .And. lRotDiss
						//Chama fCarrTab para recarregar tabela auxiliar S033
						aTabS033 := {}
						fCarrTab( @aTabS033, "S033", dDatabase, .T. )
					EndIf
					//Para a rescisao, folha e 13 salario, deve-se fazer o processo separadamente, pois o imposto da contribuicao
					//patronal da parte empresa sera calculada na rotina GPEM013
					If lRotDiss
						nPerFatEmp := fPerFatEmp( cRecFatEmp, nPercEmp, aInssEmp[1, Val(cTpc)], aTabS033, dDatabase )[1]
						If nPerFatEmp > 0
							nTotBseAut  := Round(nValBasInss * nPerFatEmp,2)
						EndIf
					EndIf
				Else
					nPercAut	 := RetValSRV( aCodFol[350,1],SRA->RA_FILIAL,"RV_PERC") / 100
					If nPercAut = 1.00 .Or. (nPercAut = 0.00  .And. aInssemp[1,Val(cTpc)] # 0.00)
						nPercAut := 0.20
					EndIf
					nTotBseAut  := Round(nValBasInss * nPercAut,2)
				EndIf

				nValBasInss := 0

				aEval(aPd,{ |x| nValBasInss += If ( X[1]$ AcodFol[353,1] .And. x[9] # "D",x[5],0.00) })
				If lContrVA
					If nValBasInss > nLimiteVA
						nValBasInss := nValBasInss - nLimiteVA
					Else
						nValBasInss := 0
					EndIf
				EndIf
				//Se recolhe INSS s/ faturamento, chama fPerFatEmp p/ verificar os faturamentos na competencia
				//e, se for o caso, alterar a aliquota de calculo da contribuicao previdenciaria, ou,
				//nao gera a verba de INSS Empresa
				If cRecFatEmp $ "S*M*C"
					//Para a rescisao e folha, deve-se fazer o processo separadamente, pois o imposto da contribuicao
					//patronal da parte empresa sera calculada na rotina GPEM013 
					If lTabS033 .And. lRotDiss
						//Chama fCarrTab para recarregar tabela auxiliar S033
						aTabS033 := {}
						fCarrTab( @aTabS033, "S033", cRecFatEmp, .T. )
					EndIf
					//Para a rescisao, folha e 13 salario, deve-se fazer o processo separadamente, pois o imposto da contribuicao
					//patronal da parte empresa sera calculada na rotina GPEM013
					If lRotDiss
						nPerFatEmp := fPerFatEmp( SRA->RA_FILIAL, nPercEmp, aInssEmp[1, Val(cTpc)], aTabS033, dDatabase )[1]
						If nPerFatEmp > 0
							nTotBseAut  := Round(nValBasInss * nPerFatEmp,2)
						EndIf
					EndIf
				Else
					nPercAut	 := RetValSRV( aCodFol[353,1],SRA->RA_FILIAL,"RV_PERC") / 100
					If nPercAut = 1.00 .Or. (nPercAut = 0.00  .And. aInssemp[1,Val(cTpc)] # 0.00)
						nPercAut := 0.20
					EndIf
					nTotBseAut  += Round(nValBasInss * nPercAut,2)
				EndIf
				If lEncPatro
					fMatriz(aCodfol[148,1],nTotBseAut)		// Empresa
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

//-- Calculo do Pis Empresa
If aCodFol[229,1] # Space(3) .And. !lContrVA
	aEval(aPd,{ |x| nBasePis += If ( RetValSrv(X[1],SRA->RA_FILIAL,"RV_PIS")=="S" .and. RetValSrv(X[1],SRA->RA_FILIAL,"RV_TIPOCOD")$"1*3" .and. x[3] == cSemana .And. x[9] # "D" ,x[5],0.00) })
	aEval(aPd,{ |x| nBasePis -= If ( RetValSrv(X[1],SRA->RA_FILIAL,"RV_PIS")=="S" .and. RetValSrv(X[1],SRA->RA_FILIAL,"RV_TIPOCOD")$"2"  .and. x[3] == cSemana .And. x[9] # "D" ,x[5],0.00) })
	If nBasePis > 0
		If Type("nBasPIS13") <> "U"
			// Verifica se existe a verba de base de PIS na SRD do roteiro 131, se for o calculo do roteiro 132
			If cTipoRot == "6" .And. cRot != fGetRotOrdinar()
				fBuscaAcmPer(aCodFol[223,1],,"V",@nBasPIS13,,AnoMes(sToD(StrZero(Year(dDataRef), 4)+"0101")),AnoMes(sToD(StrZero(Year(dDataRef), 4)+"1231")),,,"131")
				If nBasPIS13 == 0 .And. aScan( aPd, { |x| x[1] == aCodFol[183, 1] .And. x[9] != "D" } ) > 0 .And. RetValSrv(aCodFol[22, 1] ,SRA->RA_FILIAL, "RV_PIS") == "S"
					fBuscaAcmPer(aCodFol[22,1],,"V",@nBasPIS13,,AnoMes(sToD(StrZero(Year(dDataRef), 4)+"0101")),AnoMes(sToD(StrZero(Year(dDataRef), 4)+"1231")),,,"FOL")
				EndIf
				If nBasPIS13 > 0
					nBasePis -= nBasPIS13
				EndIf
			ElseIf cTipoRot == "1" // Se for folha, verifica se teve algum lançamento da verba do PIS para compor a base
				fBuscaAcmPer(aCodFol[223,1],,"V",@nBasPIS13,,AnoMes(dDataRef),AnoMes(dDataRef),,,"131/132")
				If nBasPIS13 > 0
					nBasePis += nBasPIS13
				EndIf
			EndIf
		EndIf
 		
		nPercPis  := RetValSrv( aCodFol[229,1],SRA->RA_FILIAL,"RV_PERC") / 100
    	fMatriz(aCodfol[229,1],Round(nBasePis * nPercPis,2))   // PIS
    	if aCodFol[223,1] # Space(3)
	    	fMatriz(aCodfol[223,1],nBasePis)   // BASE PIS
	    EndIf
	EndIf
EndIf

If !(lGestPubl .AND. SRA->RA_REGIME == '2') .And. !lContrVA .And. !lRot131 //Folha Privada
	// Montar Base Para Provisao Simplificada Ferias /  13o / Rescisao
	If aCodFol[194,1] # Space(3) .Or. aCodFol[195,1] # Space(3) .Or. aCodFol[196,1] # Space(3)
		aEval(aPd,{ |x| nValCus += If ( RetValSrv(X[1],SRA->RA_FILIAL,"RV_CUSTO")=="S" .and. RetValSrv(X[1],SRA->RA_FILIAL,"RV_TIPOCOD")$"1*3" .and. x[3] == cSemana .And. x[9] # "D" ,x[5],0.00) })
		aEval(aPd,{ |x| nValCus -= If ( RetValSrv(X[1],SRA->RA_FILIAL,"RV_CUSTO")=="S" .and. RetValSrv(X[1],SRA->RA_FILIAL,"RV_TIPOCOD")$"2"  .and. x[3] == cSemana .And. x[9] # "D" ,x[5],0.00) })

		// Calcular Provisao Simplificada
		If nValCus > 0.00
			fMatriz(aCodFol[194,1],Round(nValCus * aInssemp[6,Val(cTpc)],2))  // Prov. Ferias
			fMatriz(aCodFol[195,1],Round(nValCus * aInssemp[5,Val(cTpc)],2))  // Prov. 13o.
			fMatriz(aCodFol[196,1],Round(nValCus * aInssemp[20,Val(cTpc)],2))  // Prov. Rescisao
		EndIf
	EndIf
EndIf

// Se foi Dissidio e cFolMes continha o Mes/Ano do Calculo de Dissidio, deve ZERAR tabelas Encargos (Param 14), pois 
// as vars foram utilizadas de acordo com o Mes/Ano do Calculo do Dissidio. Esta acao eh p/ nao correr risco de ficar
// com tabela com os percentuais de meses divergentes do necessario para o proximo calculo.
If lDissidio
	aInssEmpSt	:= Nil
	aInssEmp	:= Nil
EndIf

RestArea( aArea )
Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCInssAut ³ Autor ³ Renata                ³ Data ³ 01.09.10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao para Calcular I.N.S.S. Autonomo                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³Calc_Inss(aInss)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCInssAut(aCodfol,aTinss,lTrunca)

Local nBaseCalc 	:= 0
Local nTetoIns		:= 0
Local nBaseAux		:= 0
Local nBsSemAnt		:= 0

nSalC_c		:= If( Type("nSalC_c") 		== "U"	, 0.00, nSalC_c)
lInssAut	:= If( Type("lInssAut") 	== "U"	, .T., lInssAut)

// Para os casos em que o funcionário não é autonomo, pode haver acordo
// Entre o Brasil e outros paises, para o não desconto do INSS.
// Para tratar esses acordos o campo RA_INSSAUT é utilizad.
// Se estiver com NÃO, NÃO deverá calcular INSS, independente do RA_CATFUNC.
If cPaisLoc == "BRA" .and. (!lInssAut)
	Return
EndIf

lTrunca 	:= If (lTrunca = Nil , .T. , lTrunca)
	
nTetoIns := aTinss[Len(aTinss),1]

IF SRA->RA_TIPOPGT == "S" .and. cSemana > '01'
	aEval(aPd,{|X| nBsSemAnt += If(X[1] == aCodFol[221,1] .and. X[3] < cSemana .and. X[9] <> "D",X[5],0)})
EndIf

If nVlBsOut > 0
	If SRA->RA_CATEG $ "17|18"
		nBaseCalc := nSalC_c + nBsSemAnt
	Else
		nBaseCalc := nSalC_b + nBsSemAnt
	EndIf

	If (nVlBsOut + nBaseCalc) > nTetoIns
		nBaseAux  := nTetoIns - nVlBsOut
		nVInssAut := If( lTrunca, NoRound(nBaseAux * P_PERCAUTO, 2), Round(nBaseAux * P_PERCAUTO, 2) )
	Else
		nVInssAut	:= If( lTrunca, NoRound(nBaseCalc * P_PERCAUTO, 2), Round(nBaseCalc * P_PERCAUTO, 2) )
	EndIf
Else
	If SRA->RA_CATEG $ "17|18"
		nBaseCalc := Min(nSalC_c, aTinss[Len(aTinss),1])
	Else
		nBaseCalc := Min(nSalC_b, aTinss[Len(aTinss),1])
	EndIf
	
	nVInssAut := If( lTrunca, NoRound(nBaseCalc * P_PERCAUTO, 2), Round(nBaseCalc * P_PERCAUTO, 2) )
	
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GPEXFUN1  ºAutor  ³Microsiga           º Data ³  07/25/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna o indicador de Base de Calculo para a previdencia   º±±
±±º          ³social, utilizado no MANAD.                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GPEVerTpBase(cCampo,lTabSrv)
Local aAreaSRD:= {}
Local cTpBase := "9" //outras bases de calculo
Local cAlias  := "SRV"
Local lCodFol := .T.

DEFAULT lTabSrv := .F.

#IFDEF TOP
	If !lTabSrv
		cAlias := "SRD"
	Else
		cAlias := "SRV"
	EndIf
#ENDIF

lCodFol := IIF(len((cAlias)->RV_CODFOL) == 4,.T.,.F.)

If lTabSrv
	//PosSrv(SRD->RD_PD,SRA->RA_FILIAL)
	SRV->(MsSeek (xFilial("SRV",SRA->RA_FILIAL)+SRD->RD_PD ))
EndIf

If cCampo == "BIRRF"
    If (cAlias)->RV_CODFOL $ Iif(lCodFol, "0073/0076/0078/0083/0344/0346/0637", "073/076/078/083/344/346/637")	//Refere-se a ferias, 1/3 ferias mes seguinte e medias mes seguinte
	    cTpBase := "1"
	ElseIf (cAlias)->RV_CODFOL == Iif( lCodFol, "0007", "007" ) 	//Refere-se a adiantamento
	    cTpBase := "3"	
	ElseIf SRD->RD_IR == "S" .AND. !(SRD->RD_ROTEIR $ "131*132") .And. (cAlias)->RV_TIPOCOD != "3" //Base de calculo salario mensal
		cTpBase := "1"
	ElseIf SRD->RD_IR == "S" .AND. SRD->RD_ROTEIR == "132" .And. (cAlias)->RV_TIPOCOD != "3"// Base de calculo 130 salario
		cTpBase := "2"
	ElseIf SRD->RD_IR # "S" .Or. SRD->RD_ROTEIR $ "131"//Nao e base de calculo
		cTpBase := "3"
	EndIf
	
	//Se a verba for de PLR, trata como outro tipo de base de calculo
	If (cAlias)->RV_CODFOL = Iif(lCodFol,'0151','151') .and. SRD->RD_DATARQ >= "201301" 	//Verba de PLR
		cTpBase := "9"
	Endif
	//Se a verba incidir para IRRF e nao tiver Id de Calculo, verificar se trata-se de pensao
	If SRD->RD_IR == "S" .And. Empty( (cAlias)->RV_CODFOL )
		//Procura a existencia da verba como pensao nos beneficiarios
		cTpBase := fBusPensao( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, SRD->RD_PD, cTpBase )
	Endif
	//Se a verba for de deducao de pensao, altera o flag para incidir para IRRF pois verba sempre deduz da base de IR
	If (cAlias)->RV_CODFOL == Iif(lCodFol, '0057', '057')//Base Pensao Alimentica Folha Ded I.R.
		cTpBase := "1"
	EndIf
	//Se a verba incidir para IRRF ou for parte da base de cálculo, verifica se ha insuficiencia de saldo
    If SRD->RD_IR == "S" .Or. cTpBase $ "1*2"
		aAreaSRD := SRD->( GetArea() )
		//Procura a existencia da verba de Id 045 - Insuficiencia de saldo e 015 - Base IR
		if fBusIns(SRD->RD_FILIAL,SRD->RD_MAT,SRD->RD_DATARQ,_aTotal[013, 045, 1]) .And. !fBusIns( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 015, 1] )
			cTpBase := "3"
		Endif
		RestArea( aAreaSRD )
	EndIf
	//Se a verba incidir para IRRF, for parte da base de cálculo e nao for da 2a. parcela do 13o., verifica se ha Base de IRRF ou se o pagamento da verba ocorreu na mesma competencia da rescisao
    If SRD->RD_IR == "S" .And. cTpBase == "1" .And. !(fTipo2RD( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, SRD->RD_PD ) $ "S*K")
		aAreaSRD := SRD->( GetArea() )
		//Se nao existir a verba de Id 0015 - Base IRRF ou
		//se o flag nao for de Ferias, houver pagamento de Rescisao e a competencia de pagamento for difente do pagamento da Rescisao
		If !fBusIns( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 015, 1] ) .Or. ( fBusIns( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 126, 1] ) .And. AnoMes( fDatPgt( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, SRD->RD_PD ) ) != AnoMes( fDatPgt( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 126, 1] ) ) )
			cTpBase := "3"
		EndIf
		RestArea( aAreaSRD )
	EndIf
	//Se for a verba de Base IR Mes Anterior e for regime caixa, verifica se a verba entrou na base de IRRF da Folha
	If (cAlias)->RV_CODFOL = Iif(lCodFol, '0106', '106') .And. RetValSRV(_aTotal[013, 006, 1], SRD->RD_FILIAL, "RV_IR") == "S"//Base IR Mes Anterior##Adiantamento
		aAreaSRD := SRD->( GetArea() )
		//Procura a existencia da verba de Id 0126 - Liquido pago na Rescisao, de Id 0015 - Base IRRF Folha, de Id 0010 - Base IR Adiantamento e de Id 0340 - Valor INSS Diferenca Dissidio. Rescisao tem que ser paga na mesma competencia da verba de Id 0106
		If fBusIns( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 126, 1] ) .And. ( AnoMes( fDatPgt( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 126, 1] ) ) == SRD->RD_DATARQ ).And. fBusIns( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 015, 1] ) .And. !fBusIns( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 010, 1] ) .And. !fBusIns( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 340, 1] )
			cTpBase := "1"//Base de calculo salario mensal
		Else
			cTpBase := "3"//Nao e base de calculo
		Endif
		RestArea( aAreaSRD )	
	EndIf 
	//Se a verba incidir para IRRF e for as verbas de Comissao, verifica se ha base de IR
    If SRD->RD_IR == "S" .And. (cAlias)->RV_CODFOL $ Iif(lCodFol, "0165/0166", "165/166")//Comissao##DSR Comissao
		aAreaSRD := SRD->( GetArea() )
		//Procura a existencia das verbas dos Ids 015/027 - Base Imposto de Renda/Base Imposto de Renda 13o.
		if !fBusIns(SRD->RD_FILIAL,SRD->RD_MAT,SRD->RD_DATARQ,_aTotal[013, 015, 1]) .And. !fBusIns(SRD->RD_FILIAL,SRD->RD_MAT,SRD->RD_DATARQ,_aTotal[013, 027, 1])
			cTpBase := "3"
		Endif
		RestArea( aAreaSRD )
	EndIf
	//Se a verba de INSS incidir para IRRF nao e base de calculo
    If SRD->RD_IR == "S" .And. (cAlias)->RV_CODFOL $ Iif(lCodFol, "0064/0065/0070", "064/065/070")//INSS Folha, Ferias e 13o
		If (cAlias)->RV_CODFOL != Iif(lCodFol, "0065", "065")//INSS Ferias
			cTpBase := "3"
		Else
			//Procura a existencia da verba de Id 0100 - Cod Dif. Base I.R Ferias 
			If !fBusIns(SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, 100, 1])
				cTpBase := "3"
			Endif 
		EndIf
	EndIf

ElseIf cCampo == "BINSS"
	If SRD->RD_INSS == "S" .And. !(SRD->RD_ROTEIR $ "131*132") .AND. (cAlias)->RV_TIPOCOD#"2"//Base de calculo de contribuicao mensal
		cTpBase := "1"
	ElseIf SRD->RD_INSS == "S" .And. SRD->RD_ROTEIR == "132" .AND. (cAlias)->RV_TIPOCOD#"2"//Base de calculo do 13 salario
		cTpBase := "2"
	EndIf

	If SRD->RD_INSS # "S" .AND. (cAlias)->RV_FGTS == "S" // base de calculo exclusiva do FGTS
		cTpBase := "6"
	ElseIf (cAlias)->RV_TIPOCOD =="2" .AND. SRD->RD_INSS == "S" .And. !(SRD->RD_ROTEIR $ "131") //Deducoes da base de calculo
		cTpBase := "7"
	ElseIf SRD->RD_INSS # "S" .Or. SRD->RD_ROTEIR $ "131"			// Nao e base de calculo
		cTpBase := "8"
	EndIf

	If (cAlias)->RV_CODFOL $ Iif(lCodFol,"0064/0065/0070","064/065/070") 	//Refere-se a vl descontado do segurado
		cTpBase := "3"
	ElseIf (cAlias)->RV_CODFOL $ Iif(lCodFol,"0034","034") 		//Refere-se a vl. pago de salario familia
		cTpBase := "4"
	ElseIf (cAlias)->RV_CODFOL == Iif(lCodFol,"0040","040")		//Base de calculo do salario maternidade
		cTpBase := "5"
	ElseIf (cAlias)->RV_CODFOL $ Iif(lCodFol,"0238/0247","238/247")		//Nao e base de calculo
		cTpBase := "8"
    EndIf
	
	//Se a verba incidir para INSS ou for parte da base de cálculo, verifica se ha insuficiencia de saldo
    If SRD->RD_INSS == "S" .Or. cTpBase = "1"
		aAreaSRD := SRD->( GetArea() )
		//Procura a existencia da verba de Id 013 - Base INSS ou 019 em caso de 13
		if !fBusIns( SRD->RD_FILIAL, SRD->RD_MAT, SRD->RD_DATARQ, _aTotal[013, iif((cAlias)->RV_REF13=="S",019,013), 1] )
			cTpBase := "8"
		Endif
		RestArea( aAreaSRD )
	EndIf

	//Estagiario nao tem desconto de INSS
	If SRA->RA_CATFUNC $ "E*G"
		cTpBase := "8"
	Endif

EndIf
Return( cTpBase )



/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fInssResEx³ Autor ³ Claudinei Soares      ³ Data ³23/10/2014³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carregar variaveis para os calculos de IR e INSS  dos      ³±±
±±³          ³ funcionarios residentes no exterior.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fInssResEx()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fInssResEx()

Local aArea		:= GetArea()
Local nOrdRGE 	:= 0
Local cChRGE	:= ""

Local lRGEPpe	:= .F.
Local lRGEStat 	:= .F.
Local lRGECod  	:= .F.
Local lRGEEnc  	:= .F.
Local lRGECale 	:= .F.
Local lRGEDtAlt	:= .F.
Local lRGEPdSal	:= .F.
Local lRGETpRem	:= .F.

If cPaisLoc == "BRA"
	lRGEPpe		:= RGE->(ColumnPos( "RGE_PPE" )) > 0
	lRGEStat	:= RGE->(ColumnPos( "RGE_STATUS" )) > 0
	lRGECod 	:= RGE->(ColumnPos( "RGE_COD" )) > 0
	lRGEEnc 	:= RGE->(ColumnPos( "RGE_ENCARG" )) > 0
	lRGECale	:= RGE->(ColumnPos( "RGE_CALENC" )) > 0
	lRGEDtAlt	:= RGE->(ColumnPos( "RGE_DTALT" )) > 0
	lRGEPdSal	:= RGE->(ColumnPos( "RGE_PDSAL" )) > 0
	lRGETpRem	:= RGE->(ColumnPos( "RGE_TPREM" )) > 0
EndIf 

lInssAut 	:= If(SRA->RA_INSSAUT=="N",.F.,.T.)	
lResExt 	:= If(SRA->RA_RESEXT=="1",.T.,.F.)	
lAutMei 	:= If(SRA->RA_AUTMEI=="1" .and. SRA->RA_CATFUNC == "A",.T.,.F.)
P_lPPEAtiv	:= If( Type("P_lPPEAtiv")== "U", .F.	, P_lPPEAtiv)
lPPEFunc	:= If( Type("lPPEFunc")	== "U", .F.	, lPPEFunc)
dIniRGE		:= If( Type("dIniRGE") 	== "U", CtoD("//"), dIniRGE)
dFimRGE		:= If( Type("dFimRGE")	== "U", CtoD("//"), dFimRGE)

If lResExt .Or. P_lPPEAtiv
	aPPE := {}
	// Define ordem da tab. RGE (Hist. contrato) 
	nOrdRGE	:= RetOrdem( "RGE", "RGE_FILIAL+RGE_MAT+DTOS(RGE_DATAIN)+RGE_TIPOCO" )
	DbSelectArea( "RGE" )
	RGE->( DbSetOrder( nOrdRGE ) )						// RGE_FILIAL+RGE_MAT+DTOS(RGE_DATAIN)+RGE_TIPOCO
	RGE->( DbSeek( xFilial( "RGE" ) + SRA->RA_MAT ) )	// Verifica se ha algum contrato para o funcionario
	lIrResExt := If(RGE->RGE_DESCIR=="2",.F.,.T.)
	lDedInssEx := If(RGE->RGE_DEDINS=="1",.T.,.F.)
	// Utiliza o Percentual se o Contrato estiver dentro do MesAno de Calculo
	If ( MesAno( RGE->RGE_DATAIN ) <= MesAno( dDataBase ) ) .and. ;
		( Empty( RGE->RGE_DATAFI ) .or. MesAno( RGE->RGE_DATAFI ) >= MesAno( dDataBase ) )
		cPdSalExt  := Iif( lRGETpRem .And. lRGEPdSal .And. RGE->RGE_TPREM == "1", RGE->RGE_PDSAL, "")
		nPercIrRex := If(RGE->RGE_PERCIR == 0, 25, RGE->RGE_PERCIR)
	Endif
	If lRGEPpe
		While !Eof() .And. RGE->RGE_FILIAL+RGE->RGE_MAT == SRA->RA_FILIAL + SRA->RA_MAT
			aAdd(aPPE, { RGE->RGE_PPE, RGE->RGE_DATAIN, RGE->RGE_DATAFI, Iif( lRGECod, RGE->RGE_COD, "" ), Iif( lRGEStat, RGE->RGE_STATUS, "0" ), Iif( lRGEDtAlt, RGE->RGE_DTALT, cToD("//") ) })
			cChRGE:= RGE->RGE_FILIAL+RGE->RGE_MAT+DTOS(RGE_DATAIN)
			dbSkip()
		EndDo
		If LEN(aPPE)>0
			nPPE := LEN(aPPE)
			IF RGE->( DbSeek( cChRGE ) )	
				lPPEFunc  := If(aPPE[nPPE,1]=="1",.T.,.F.)
				If lPPEFUNC .And. lRGEStat
					lPPEFUNC :=  RGE->RGE_STATUS <> '1' //  0 ou Branco - Ativo ; 1 - Inativo
				EndIf
				dIniRGE  := RGE->RGE_DATAIN
				dFimRGE  := RGE->RGE_DATAFI
				If lRGECod
					cPPECOD	:= RGE->RGE_COD
				Else
					cPPECOD	:= ''
				EndIf
			Endif
		Endif
	Endif
	If lResExt .And. lRGEEnc
		lEncPatro := If(RGE->RGE_ENCARG == "2", .F., .T.)
		If lEncPatro .And. RGE->RGE_RESEXT == "1" .And. lRGECale
			cEncResExt := AllTrim(RGE->RGE_CALENC)
		Endif
	EndIf
	
	RestArea( aArea )
Endif

Return

/*/{Protheus.doc} RestXCIMP
Funcao que reinicializa variaveis estaticas
@author Allyson Mesashi
@since 08/06/2016
@version P12 R7
/*/
Function RestXCIMP()
	cFilInss   	:= ""
	aInssEmpSt 	:= {}
Return

/*/{Protheus.doc} fGerAutCar
Função que gera as verbas desmembradas do autônomo carreteiro
@author Allyson Mesashi
@since 13/09/2018
@version P12.1.17
/*/
Static Function fGerAutCar()

Local aRateio	:= {}
Local cTipo2	:= ""
Local cVerba	:= ""
Local nCont 	:= 0
Local nOption	:= 1
Local nPos 		:= 0
Local nVl1563	:= 0
Local nVl1564	:= 0
Local nVl1565	:= 0
Local nVlTotal	:= 0
Local nVlVerba	:= 0

//Guarda os valores das verbas de IDs 1563, 1564 e 1565
nVl1563 := fBuscaPd( aCodFol[1563, 1] )
nVl1564 := fBuscaPd( aCodFol[1564, 1] )
nVl1565 := fBuscaPd( aCodFol[1565, 1] )

//Monta matriz com CC, Item, CLVL e valor para rateio
For nCont := 1 To Len(aPd)
	If !(aPd[nCont, 1] $ aCodFol[1563, 1]+"/"+aCodFol[1564, 1]+"/"+aCodFol[1565, 1]) .And. RetValSrv( aPd[nCont, 1], SRA->RA_FILIAL, "RV_INSS" ) == "S" .And. RetValSrv( aPd[nCont, 1], SRA->RA_FILIAL, "RV_REFFER" ) == "N" .And. RetValSrv( aPd[nCont, 1], SRA->RA_FILIAL, "RV_REF13" ) == "N" .And. aPd[ncont, 3] == csemana
		If ( nPos := aScan( aRateio, { |x| x[1]+x[2]+x[3] == aPd[nCont, 2]+aPd[nCont, 13]+aPd[nCont, 14] } ) ) == 0
			aAdd( aRateio, { aPd[nCont, 2], aPd[nCont, 13], aPd[nCont, 14], aPd[nCont, 5] } )
			cTipo2 := aPd[nCont, 7]
		Else
			aRateio[nPos, 4] += aPd[nCont, 5]
		EndIf
	ElseIf aPd[nCont, 1] $ aCodFol[1563, 1]+"/"+aCodFol[1564, 1]+"/"+aCodFol[1565, 1]
		aPd[nCont, 9] := "D"
	EndIf
Next nCont

aEval( aRateio, { |x| nVlTotal += x[4] } )

//Faz a geração dos valores rateados
While nOption < 4
	If nOption == 1
		cVerba 	 := aCodFol[1563, 1]
		nVlVerba := nVl1563
	ElseIf nOption == 2
		cVerba 	 := aCodFol[1564, 1]
		nVlVerba := nVl1564
	Else
		cVerba	 := aCodFol[1565, 1]
		nVlVerba := nVl1565
	EndIf

	For nCont := 1 To Len(aRateio)
		FGeraVerba(cVerba, (aRateio[nCont, 4]/nVlTotal) * nVlVerba, Nil, Nil, aRateio[nCont, 1], Nil, cTipo2, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, aRateio[nCont, 2], aRateio[nCont, 3])
	Next nCont

	nOption++
EndDo

//Exclui verbas com incidência de INSS/IRRF
For nCont := 1 To Len(aPd)
	If !(aPd[nCont, 1] $ aCodFol[1563,1]+"|"+aCodFol[1564,1]) .And. RetValSrv( aPd[nCont, 1], SRA->RA_FILIAL, "RV_INSS" ) == "S" .And. RetValSrv( aPd[nCont, 1], SRA->RA_FILIAL, "RV_REFFER" ) == "N" .And. RetValSrv( aPd[nCont, 1], SRA->RA_FILIAL, "RV_REF13" ) == "N"
		aPd[nCont, 9] := "D"
	EndIf
Next nCont

Return


/*/{Protheus.doc} fBusInsFer
Função para buscar o INSS das férias descontado no cálculo das férias.
@author Henrique Ferreira
@since 29/03/2019
@version P12.1.17
/*/
Static Function fBusInsFer(dDtPg)

Local aArea := GetArea()
Local nValInss := 0

DbSelectArea("SRR")
DbSetOrder(5)

If SRR->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + dToS(dDtPg) + aCodFol[168,1]))
	nValInss := SRR->RR_VALOR
EndIf

RestArea(aArea)

Return nValInss

/*/{Protheus.doc} fGetPdSRC
Função para buscar o INSS das férias descontado no cálculo da folha.
@author Leandro Drumond
@since 14/08/2019
@version P12.1.17
/*/
Static Function fGetPdSRC(cPd)

Local cAliasQry := GetNextAlias()
Local cQuery	:= ""
Local nRet		:= 0
			
cQuery := " SELECT RC_VALOR FROM " + RetSqlName("SRC")
cQuery += " WHERE "
cQuery += " RC_FILIAL = '" + SRA->RA_FILIAL + "' AND"
cQuery += " RC_MAT = '" + SRA->RA_MAT + "' AND"
cQuery += " RC_PROCES = '" + cProcesso + "' AND"
cQuery += " RC_PERIODO = '" + cPeriodo + "' AND"
cQuery += " RC_ROTEIR = '" + cRot + "' AND"
cQuery += " RC_SEMANA < '" + cSemana + "' AND"
cQuery += " RC_PD IN('" + cPd + "') AND" 
cQuery += " D_E_L_E_T_ = ' ' "

cQuery := ChangeQuery(cQuery)

DbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry)

While (cAliasQry)->( !Eof() )
	nRet += (cAliasQry)->RC_VALOR
	(cAliasQry)->( DbSkip() )
EndDo

(cAliasQry)->( DbCloseArea() )

Return nRet

/*/{Protheus.doc} fCInssFx
Gera as verbas de INSS por faixa
@author Leandro Drumond
@since 27/01/2020
@version P12.1.23
/*/
Function fCInssFx(aInssFx,aPdFx, cSeq)
Local nX 		:= 0
Local cNumSeq 	:= ""

DEFAULT cSeq := " "

For nX := 1 to Len(aInssFx)
	If !Empty(aPdFx[nX]) .and. aInssFx[nX,1] > 0
		If !Empty(cSeq)
			cNumSeq := RetValSRV(aPdFx[nX],SRA->RA_FILIAL,"RV_QTDLANC")
		EndIf
		If Empty(cSeq) .or. Val(cSeq) < Val(cNumSeq)
			fMatriz(aPdFx[nX], aInssFx[nX,1], aInssFx[nX,2],,,,,,,,,cSeq)
		EndIf
	EndIf
Next nX

Return Nil

/*/{Protheus.doc} fRetTetIns
Retorna o teto do INSS de acordo com a tabela recebida
@author Julio Silva
@since 26/03/2020
@version P12.1.25
/*/
Function fRetTetIns(aTinss)

Local nX 		:= 0
Local nTetoInss := 0

If Len(aTInss) > 0
	If aTInss[1,4] == "S"
		For nX := 1 To Len(aTinss)
			nTetoInss += NoRound(If ( nX == 1, aTinss[nX,1] * aTinss[nX,2], (aTinss[nX,1] - aTinss[nX-1,1]) * aTinss[nX,2]), 2)
		Next nX
	else
		nTetoInss := NoRound(aTinss[Len(aTinss),1] * aTinss[Len(aTinss),2] , 2)
	EndIf
EndIf

Return nTetoInss

/*/{Protheus.doc} fCarPdMat
Carrega as verbas de maternidade
@author Leandro Drumond
@since 07/12/2020
@version P12.1.27
/*/
Function fCarPdMat( lSefip )

Local aRet		:= {}
Local cTmpAlias := GetNextAlias()
Local cFilSRV   := xFilial("SRV")
Local cVerbaMat := "% SRV.RV_INCCP IN('21','22')  %"
Local cExp		:= "%%"

Default lSefip	:= .F.

If lSefip
	cExp := "% AND SRV.RV_CODFOL NOT IN  ('1446','1447') %"
EndIf

BeginSql alias cTmpAlias
	SELECT SRV.RV_COD
	FROM %table:SRV% SRV 
	WHERE 
	%exp:cVerbaMat% AND SRV.D_E_L_E_T_= '' 
	AND SRV.RV_FILIAL = %exp:cFilSRV%
	AND SRV.RV_NATUREZ <> ' '
	AND SRV.RV_INSS = 'S'
	%exp:cExp%
EndSql

While !(cTmpAlias)->(Eof())
	aAdd(aRet,(cTmpAlias)->RV_COD)	
	(cTmpAlias)->(dbSkip())
EndDo

(cTmpAlias)->(dbCloseArea())

Return aRet

/*/{Protheus.doc} fCarPdAfa
Carrega as verbas de afastamento com incidência 15
@author Allyson Mesashi
@since 15/01/2021
@version P12.1.27
/*/
Function fCarPdAfa( cConfig )

Local aRet		:= {}
Local cTmpAlias := GetNextAlias()
Local cFilSRV   := xFilial("SRV")
Local cVerbaMat := "% SRV.RV_INCCP IN ('15')  %"

BeginSql alias cTmpAlias
	SELECT SRV.RV_COD
	FROM %table:SRV% SRV 
	WHERE 
	%exp:cVerbaMat% AND SRV.D_E_L_E_T_= '' 
	AND SRV.RV_FILIAL = %exp:cFilSRV%
	AND SRV.RV_NATUREZ <> ' '
	AND SRV.RV_INSS = 'S'
EndSql

While !(cTmpAlias)->(Eof())
	aAdd(aRet,(cTmpAlias)->RV_COD)	
	(cTmpAlias)->(dbSkip())
EndDo

(cTmpAlias)->(dbCloseArea())

Return aRet

/*/{Protheus.doc} fSomaIrMesAnt
Carrega as verbas do Ir de complementar no mesmo mês
@author Fernando Luis Guilherme
@since 17/12/2020
@version P12.1.27
/*/
Static Function fSomaIrMesAnt(cIRPlr, dDataHom, lMultV, dDataDem )
Local aAreaSRG := SRG -> (GetArea())
Local dDataH := Ctod("")

DEFAULT cIRPlr := ""

DbSelectArea ("SRG")
DbSetOrder(1)

If SRG->(dbSeek(xFilial("SRG",SRA->RA_FILIAL)+SRA->RA_MAT))
	while SRG->RG_FILIAL = SRA->RA_FILIAL .And. SRG->RG_MAT == SRA->RA_MAT  
		If SRG->RG_RESCDIS == "1" .And. MesAno(SRG->RG_DATAHOM) == MesAno(M->RG_DATAHOM) .And. AnoMes(dDataDem) != AnoMes(SRG->RG_DTGERAR)
			dDataH := SRG->RG_DTGERAR
		EndIf
		SRG->(DBSKIP())
	EndDo
Endif

If !Empty(dDataH) .And. MesAno(dDataH) < MesAno(M->RG_DATAHOM)
	Aeval( aPdResc ,{ |X| If(X[3] <= cSemana .And. !(X[1] $ cIRPlr) .and. (RetValSRV(X[1],SRA->RA_FILIAL,"RV_REFFER") == "N" .or. RetValSRV(X[1],SRA->RA_FILIAL,"RV_REFFER") == "") .and. MesAno(x[18]) == MesAno(dDataH) .and. MesAno(x[10]) == MesAno(dDataHom),SomaInc(X,5,@nIR_B,5,"S",12,"N",Month(dDataHom),,aCodFol,,,If(lMultV, .T. ,.F.)),NIL) } )
Endif

RestArea(aAreaSRG)
Return

/*/{Protheus.doc} fVldCompaPd
Retira o valor das verbas com incidência para INSS, IR ou FGTS caso tenha complemento de 13º incluído manualmente
@author Allyson Mesashi
@since 29/01/2021
@version P12.1.27
/*/
Static Function fVldCompaPd()

Local nCont := 0

For nCont := 1 To Len(aPd)
	If !(aPd[nCont, 1] $ aCodFol[183, 1]+"/"+aCodFol[024, 1]+"/"+aCodFol[1435, 1]) .And. aPd[nCont, 7] != "I" .And. (RetValSrv(aPd[nCont, 1], SRA->RA_FILIAL, "RV_INSS") == "S" .Or. RetValSrv(aPd[nCont, 1], SRA->RA_FILIAL, "RV_IR") == "S" .Or. RetValSrv(aPd[nCont, 1], SRA->RA_FILIAL, "RV_FGTS") == "S")
		aPd[nCont, 5] := 0
	EndIf
Next nCont

Return
