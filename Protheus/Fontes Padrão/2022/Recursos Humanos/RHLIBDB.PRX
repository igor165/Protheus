#INCLUDE  "PROTHEUS.CH"
#INCLUDE  "SCOPECNT.CH"
#INCLUDE  "RHLIBDB.CH" 
#INCLUDE  "HEADERGD.CH"

/*                                                                                           
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммммкмммммммямммммммммммммммммммммммкммммммяммммммммммммммммм╩╠╠
╠╠╨Programa  Ё RHLIBDB    ЁAutor  ЁEquipe RH			  Ё Data Ё      09/11/2006 ╨╠╠
╠╠лддддддддддеддддддддддддадддддддадддддддддддддддддддддддаддддддаддддддддддддддддд╧╠╠
╠╠╨Descri┤┘o Ё Biblioteca de funcoes para tratamento de tabelas					   ╨╠╠
╠╠лддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╧╠╠
╠╠╨Sintaxe   Ё RHLIBDB()													       ╨╠╠
╠╠лддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╧╠╠
╠╠╨Uso       Ё Generico                                                            ╨╠╠
╠╠лддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╧╠╠
╠╠╨         ATUALIZACOES SOFRIDAS DESDE A CONSTRU─AO INICIAL.                      ╨╠╠
╠╠лддддддддддддддбддддддддддбдддддддддддбдддддддддддддддддддддддддддддддддддддддддд╧╠╠
╠╠╨Programador   Ё Data     Ё FNC       Ё  Motivo da Alteracao                     ╨╠╠
╠╠гддддддддддддддеддддддддддедддддддддддедддддддддддддддддддддддддддддддддддддддддд╤╠╠
╠╠╨Mauricio MR   Ё25/08/2009Ё21296/2009 ЁAjuste para considerar a chave completa   ╨╠╠
╠╠╨              Ё          Ё           |na busca de chaves compostas quando a ta- ╨╠╠
╠╠╨              Ё          Ё           |bela principal estah compartilhada.	   ╨╠╠
╠╠╨              Ё          Ё           |Fechamento de consultas na verificacao	   ╨╠╠
╠╠╨              Ё          Ё           |soft do relacionamento.				   ╨╠╠
╠╠╨Gustavo M.    Ё24/02/2012Ё004555/2012ЁAjuste para correcao de error.log		   ╨╠╠
╠╠╨Flavio Correa Ё27/08/2014ЁTQHISU     ЁChecagem se campo existe na funГЦo ChkRegs╨╠╠
╠╠╨CМcero Alves  Ё05/10/2016ЁTVUBQE     ЁCriaГЦo das funГУes RHMSMM e AtuRDY para  ╨╠╠
╠╠╨              Ё          Ё           Ёgravar os campos memo na RDY			   ╨╠╠
╠╠ЁOswaldo L.    Ё03/04/17ЁDRHPONTP-164 ЁProjeto cTree	                           Ё╠╠
╠╠ЁM. Silveira   Ё05/04/2017ЁDRHPONTP-51ЁAjuste na funcao RHMSMM para tratar campos╨╠╠
╠╠╨              Ё          Ё           Ёpassados por query.                       ╨╠╠
╠╠╨Oswaldo L     Ё22/05/2017ЁDRHPONTP-  ЁAjuste de critica indevida CG_FILIAL      ╨╠╠
╠╠╨              Ё          Ё619        Ё                                          ╨╠╠
╠╠╨Isabel N.     Ё29/05/2017Ё DRHPONTP- ЁAjustar RHMSMM p/carregar tabela de origem╨╠╠
╠╠╨              Ё          Ё534        Ёdos campos memo pelo inicializador padrЦo.╨╠╠
╠╠╨Isabel N.     Ё30/06/2017ЁDRHPONTP-623ЁAjuste em RHMSMM p/tratar gatilhos (SX7).╨╠╠
╠╠╨Isabel N.     Ё07/07/17ЁDRHPONTP-1001ЁAjuste na inclusЦo de campos memo p/evitar╨╠╠
╠╠╨              Ё        Ё             Ёerro indevido de inicializador.           ╨╠╠
╠╠╨Isabel N.     Ё13/11/17ЁDRHPONTP-2116ЁAjuste na leitura de campos memo.		   ╨╠╠
╠╠ЁOswaldo L     Ё21/12/17ЁDRHPAG-9991  ЁTratar acessos diretos na SX2, pontuados  Ё╠╠
╠╠Ё              Ё        Ё             Ёpelo sonarqube                            Ё╠╠
╠╠хммммммммммммммоммммммммммомммммммммммомммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na Funcao GetCache()				   	   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static aGetCache	:= {}

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na Funcao PosAlias()					   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static aPosAlias	:= {}

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁArmazena o DataBase                                          Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static _cDataBase := GetDataBase()

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁStatic para a ExistField()									  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static aExistField

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁStatic para a FilExistField()								  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static aFilExistField

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁStatic para a CheckSx9										  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static aCheckSx9	:= {}
Static nCheckSx9	:= 0

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁStatic para a BldIntegrityFile								  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static aIntgFileInsert	:= {}
Static aIntgFileDelete	:= {}

/*/
зддддддддддбддддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁInRhLibDbExec ЁAutor ЁMarinaldo de Jesus   Ё Data Ё14/05/2003Ё
цддддддддддеддддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁExecutar Funcoes Dentro de RHLIBDB                           Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁInRhLibDbExec( cExecIn , aFormParam )						 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁuRet                                                 	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico 													 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function InRhLibDbExec( cExecIn , aFormParam )
         
Local uRet

DEFAULT cExecIn		:= ""
DEFAULT aFormParam	:= {}

IF !Empty( cExecIn )
	cExecIn	:= BldcExecInFun( cExecIn , aFormParam )
	uRet	:= __ExecMacro( cExecIn )
EndIF

Return( uRet )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁGetCache	 ЁAutorЁ Marinaldo de Jesus	  Ё Data Ё21/10/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁObtem Informacoes em Cache do Campo Conforme Alias          Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   Ё Generico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetCache( cAlias , cCompKey , cFil , cField , nOrder , lMsGoto , nRecno )

Local nAlias
Local nField

Local uRet

IF ( ( nAlias := aScan( aGetCache , { |x| ( ( x[1] == cAlias ) .and. ( x[2] == cFil ) ) } ) ) == 0 )
	aAdd( aGetCache , { cAlias , cFil , {} } )
	nAlias := Len( aGetCache )
EndIF

DEFAULT lMsGoto := .F.
IF ( ( nField := aScan( aGetCache[ nAlias , 3 ] , { |x| ( ( x[1] == cField ) .and. ( x[2] == cCompKey ) .and. ( x[3] == nOrder ) ) } ) ) == 0 )
	uRet 	:= PosAlias( cAlias , cCompKey , cFil , cField , nOrder , .T. , @nRecno )
	aAdd( aGetCache[ nAlias , 3 ] , { cField , cCompKey , nOrder , uRet , nRecno } )
Else
	uRet 	:= aGetCache[ nAlias , 3 , nField , 4 ]
	nRecno	:= aGetCache[ nAlias , 3 , nField , 5 ]
EndIF

IF ( lMsGoto )
	( cAlias )->( MsGoto( nRecno ) )
EndIF

Return( uRet )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁRstGetCacheЁAutorЁ Marinaldo de Jesus	  Ё Data Ё21/10/2004Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa o Cache da GetCache()    						Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   Ё Generico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstGetCache( cAlias , cFil )
         
Local bAscan
Local lFilIsNil
Local nPosAlias

IF ( cAlias == NIL )
	aGetCache := {}
Else
	lFilIsNil := ( cFil == NIL )
	IF !( lFilIsNil )
		cFil := xFilial( cAlias , cFil )
		bAscan := { |x| ( x[1] == cAlias ) .and. ( x[2] == cFil ) }
	Else
		bAscan := { |x| ( x[1] == cAlias ) }
	EndIF
	While ( ( nPosAlias := aScan( aGetCache , bAscan ) ) > 0 )
		aDel( aGetCache , nPosAlias )
		aSize( aGetCache , ( Len( aGetCache ) - 1 ) )
	End While
EndIF

Return( NIL )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPosAlias  Ё Autor Ё Marinaldo de Jesus	  Ё Data Ё06/09/2004Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁPosiciona na Chave Desejada no Alias Selecionado e   RetornaЁ
Ё          Ёinformacoes do Cache                                        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   Ё Generico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PosAlias( cAlias , cCompKey , cFil , uField , nOrder , lMsGoto , nRecno )

Local lIsNil	:= ( uField == NIL )

Local cField
Local cFieldFil
Local cFieldType
Local cFindKey

Local lIsArray

Local nAtuKey
Local nField
Local nFCount
Local nPosField
Local nFieldLen
Local nOrdAlias
Local nPosAlias
Local nPosFilial
Local nCompKey

Local uRet

Begin Sequence

	DEFAULT nOrder			:= 1
	DEFAULT lMsGoto			:= .F.
	
	IF FilExistField( cAlias , @cFieldFil )
		cFil	:= xFilial( cAlias , cFil )
	Else
		cFil	:= ""
	EndIF
	
	IF ( ( nPosAlias := aScan( aPosAlias , { |x| ( x[1] == cAlias ) } ) ) == 0 )
		aAdd( aPosAlias , { cAlias , ( cAlias )->( FCount() ) , {} , {} } )
		nPosAlias	:= Len( aPosAlias )
		nFCount		:= aPosAlias[ nPosAlias , 2 ]
		For nField := 1 To nFCount
			( cAlias )->( aAdd( aPosAlias[ nPosAlias , 3 ] , AllTrim( FieldName( nField ) ) ) )
		Next nField
	EndIF

	IF ( ( nPosFilial := aScan( aPosAlias[ nPosAlias , 4 ] , { |x| ( x[1] == cFil ) } ) ) == 0 )
		aAdd( aPosAlias[ nPosAlias , 4 ] , { cFil , {} } )
		nPosFilial	:= Len( aPosAlias[ nPosAlias , 4 ] )
	EndIF

	nCompKey	:= Len( cCompKey )
	nAtuKey		:= aScan( aPosAlias[ nPosAlias , 4 , nPosFilial , 2 ] , { |x| ( ( x[2] == nOrder ) .and. ( Substr( x[1] , 1 , nCompKey ) == cCompKey ) ) } )
	IF ( nAtuKey > 0 )
		nRecno := aPosAlias[ nPosAlias , 4 , nPosFilial , 2 , nAtuKey , 3 ]
		IF ( lIsNil )
			uRet := .T.
			IF ( lMsGoto )
				( cAlias )->( MsGoto( nRecno ) )
			EndIF
			Break
		EndIF
	EndIF
	
	IF ( nAtuKey == 0 )
		nOrdAlias	:= ( cAlias )->( IndexOrd() )
		IF ( nOrdAlias <> nOrder )
			( cAlias )->( dbSetOrder( nOrder ) )
		EndIF
		IF ( cFieldFil $ SubStr( ( cAlias )->( IndexKey() ) , 1 , Len( cFieldFil ) ) )
			cFindKey := ( cFil + cCompKey )
		Else
			cFindKey := cCompKey
		EndIF
		IF ( uRet := ( cAlias )->( MsSeek( cFindKey , .F. ) ) )
			( cAlias )->( aAdd( aPosAlias[ nPosAlias , 4 , nPosFilial , 2 ] , {;
																					cCompKey				,;
																					nOrder					,;
																					( nRecno := RecNo() )	,;
																					{}						,;
																					{}			 			 ;
															 			  	   };
							  );
						)
			nAtuKey := Len( aPosAlias[ nPosAlias , 4 , nPosFilial , 2 ] )
			nFCount := aPosAlias[ nPosAlias , 2 ]
			For nField := 1 To nFCount
				( cAlias )->( aAdd( aPosAlias[ nPosAlias , 4 , nPosFilial , 2 , nAtuKey , 4 ] , FieldGet( nField ) ) )
			Next nField
		Else
			IF !( lIsNil )
				nAtuKey	:= 0
			EndIF
			nRecno		:= 0
		EndIF
		IF ( nOrdAlias <> nOrder )
			( cAlias )->( dbSetOrder( nOrdAlias ) )
		EndIF
	EndIF
	
	IF !( lIsNil )
		lIsArray := ( ValType( uField ) == "A" )
		IF ( nAtuKey > 0 )
			IF ( lMsGoto )
				( cAlias )->( MsGoto( nRecno ) )
			EndIF
			IF ( lIsArray )
				nFCount := Len( uField )
				uRet	:= Array( nFCount )
				For nField := 1 To nFCount
					cFieldType	:= ValType( uField[ nField ] )
					IF ( cFieldType == "C" )
						cField		:= Upper( AllTrim( uField[ nField ] ) )
						nPosField	:= aScan( aPosAlias[ nPosAlias , 3 ] , { |x| ( x == cField ) } )
					Else
						cField		:= uField[ nField ]
						nPosField	:= 0
					EndIF
					IF ( nPosField > 0 )
						uRet[ nField ] := aPosAlias[ nPosAlias , 4 , nPosFilial , 2 , nAtuKey , 4 , nPosField ]
					Else
						nPosField	:= aScan( aPosAlias[ nPosAlias , 4 , nPosFilial , 2 , nAtuKey , 5 ] , { |x| ( x[1] == uField[ nField ] ) } )
						IF ( nPosField > 0 )
							uRet[ nField ] := aPosAlias[ nPosAlias , 4 , nPosFilial , 2 , nAtuKey , 5 , nPosField , 2 ]
						Else
							( cAlias )->( MsGoto( nRecno ) )
							IF ( cAlias )->( CheckExecForm( @cField , .F. ) )
								uRet[ nField ] := cField
							Else
								uRet[ nField ] := NIL
							EndIF
							aAdd( aPosAlias[ nPosAlias , 4 , nPosFilial , 2 , nAtuKey , 5 ] , { uField[ nField ] , uRet[ nField ] } )
						EndIF	
					EndIF
				Next nField	
			Else
				cFieldType	:= ValType( uField )
				IF ( cFieldType == "C" )
					cField		:= Upper( AllTrim( uField ) )
					nPosField	:= aScan( aPosAlias[ nPosAlias , 3 ] , { |x| ( x == cField ) } )
				Else
					cField		:= uField
					nPosField	:= 0
				EndIF	
				IF ( nPosField > 0 )
					uRet := aPosAlias[ nPosAlias , 4 , nPosFilial , 2 , nAtuKey , 4 , nPosField ]
				Else
					nPosField := aScan( aPosAlias[ nPosAlias , 4 , nPosFilial , 2 , nAtuKey , 5 ] , { |x| ( x[1] == uField ) } )
					IF ( nPosField > 0 )
						uRet := aPosAlias[ nPosAlias , 4 , nPosFilial , 2 , nAtuKey , 5 , nPosField , 2 ]
					Else
						( cAlias )->( MsGoto( nRecno ) )
						IF ( cAlias )->( CheckExecForm( @cField , .F. ) )
							uRet := cField
						Else
							uRet := NIL
						EndIF
						aAdd( aPosAlias[ nPosAlias , 4 , nPosFilial , 2 , nAtuKey , 5 ] , { uField , uRet } )
					EndIF	
				EndIF	
			EndIF
		Else
			IF ( lIsArray )
				nFCount := Len( uField )
				uRet	:= Array( nFCount )
				For nField := 1 To nFCount
					cField 		:= uField[ nField ]
					cFieldType	:= ValType( cField )
					IF (;
							( cFieldType == "C" );
							.and.;
							ExistField( cAlias , cField , NIL , @cFieldType , @nFieldLen );
						)	
						uRet[ nField ] := GetValType( cFieldType , nFieldLen )
					Else
						( cAlias )->( CheckExecForm( @cField , .F. ) )
						cFieldType	:= ValType( cField )
						IF ( cFieldType == "C" )
							nFieldLen := Len( cField )
						EndIF
						uRet[ nField ] := GetValType( cFieldType , nFieldLen )
					EndIF
				Next nField
			Else
				IF ( ExistField( cAlias , uField , NIL , @cFieldType , @nFieldLen ) )
					uRet := GetValType( cFieldType , nFieldLen )
				Else
					IF ( cAlias )->( CheckExecForm( @uField , .F. ) )
						uRet := uField
					Else
						uRet := NIL
					EndIF
				EndIF
			EndIF
		EndIF
	EndIF

End Sequence
	
Return( uRet )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁRstPosAliasЁ Autor Ё Marinaldo de Jesus	  Ё Data Ё06/09/2004Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa o Cache da PosAlias()    						Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   Ё Generico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstPosAlias( cAlias , cFil )

Local bAscanAlias
Local bAscanFilial

Local lFilIsNil

Local nPosAlias
Local nPosFilial

IF ( cAlias == NIL )
	aPosAlias := {}
Else
	lFilIsNil := ( cFil == NIL )
	IF !( lFilIsNil )
		cFil			:= xFilial( cAlias , cFil )
		bAscanFilial	:= { |x| ( x[1] == cFil ) }
	EndIF
	bAscanAlias := { |x| ( x[1] == cAlias ) }
	nPosAlias	:= 0
	While ( ( nPosAlias := aScan( aPosAlias , bAscanAlias , ++nPosAlias ) ) > 0 )
		IF !( lFilIsNil )
			nPosFilial := 0
			While ( ( nPosFilial := aScan( aPosAlias[ nPosAlias , 4 ] , bAscanFilial , ++nPosFilial ) ) > 0 )
				aDel( aPosAlias[ nPosAlias , 4  ] , nPosFilial )
				aSize( aPosAlias[ nPosAlias , 4 ] , ( Len( aPosAlias[ nPosAlias , 4 ] ) - 1 ) )
			End While
			Exit
		EndIF	
		aDel( aPosAlias , nPosAlias )
		aSize( aPosAlias , ( Len( aPosAlias ) - 1 ) )
	End While
EndIF

Return( NIL )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁExistFieldЁ Autor Ё Marinaldo de Jesus	  Ё Data Ё11/10/2004Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica a Existencia Fisica de Campo                       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   Ё Generico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ExistField( cAlias , cField , nFieldPos , cFieldType , nFieldLen , nFieldDec )

Local nPosAlias
Local nPosField

Local uFieldGet

DEFAULT aExistField := {}

IF ( ( nPosAlias := aScan( aExistField , { |x| ( x[1] == cAlias ) } ) ) == 0 )
	aAdd( aExistField , { cAlias , {} } )
	nPosAlias := Len( aExistField )
EndIF
cField := Upper( AllTrim( cField ) )
IF ( ( nPosField := aScan( aExistField[ nPosAlias , 2 ] , { |x| ( x[1] == cField ) } ) ) == 0 )
	nFieldPos	:= ( cAlias )->( FieldPos( cField ) )
	nFieldLen	:= 0
	nFieldDec	:= 0
	IF ( nFieldPos > 0 )
		uFieldGet := ( cAlias )->( FieldGet( nFieldPos ) )
		IF ( ( cFieldType := ValType( uFieldGet ) ) $ "C/M" )
			nFieldLen	:= Len( uFieldGet )
		ElseIF ( cFieldType == "N" )
			uFieldGet := Str( uFieldGet )
			nFieldLen := Len( uFieldGet )
			nFieldDec := Len( SubStr( uFieldGet , At( "." , uFieldGet ) + 1 ) )
		ElseIF ( cFieldType == "D" )
			nFieldLen := 8
		ElseIF ( cFieldType == "L" )
			nFieldLen := 3
		EndIF
	Else
		cFieldType	:= NIL
	EndIF
	aAdd( aExistField[ nPosAlias , 2 ] , { cField , cFieldType , nFieldLen , nFieldDec } )
	nPosField := Len( aExistField[ nPosAlias , 2 ] )
Else
	cFieldType	:= aExistField[ nPosAlias , 2 , nPosField , 2 ]
	nFieldLen	:= aExistField[ nPosAlias , 2 , nPosField , 3 ]
	nFieldDec	:= aExistField[ nPosAlias , 2 , nPosField , 4 ]
EndIF

Return( ( aExistField[ nPosAlias , 2 , nPosField , 1 ] <> NIL ) )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRstExistField	ЁAutorЁMarinaldo de Jesus Ё Data Ё11/10/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa as Staticas utilizadas em ExistField()        	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstExistField()
aExistField := NIL
Return( NIL )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁExistFieldЁ Autor Ё Marinaldo de Jesus	  Ё Data Ё11/10/2004Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica a Existencia Fisica do Campo _FILIAL				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   Ё Generico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function FilExistField( cAlias , cFieldFil )

Local nPosAlias

DEFAULT aFilExistField := {}

IF ( ( nPosAlias := aScan( aFilExistField , { |x| ( x[1] == cAlias ) } ) ) == 0 )
	cFieldFil := ( PrefixoCpo( cAlias ) + "_FILIAL" )
	aAdd( aFilExistField , { cAlias , cFieldFil } )
Else
	cFieldFil := aFilExistField[ nPosAlias , 2 ]
EndIF	

Return( ExistField( cAlias , cFieldFil ) )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRstFilExistFieldЁAutorЁMarinaldo de Jesus Ё Data Ё11/10/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa as Staticas utilizadas em FilExistField()     	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstFilExistField()
aFilExistField := NIL
Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁCloseNotUse		ЁAutorЁMarinaldo de Jesus Ё Data Ё22/04/2002Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁFecha os Alias que Nao Serao utilizados em Determinado proceЁ
Ё          Ёsso															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaClosed -> Array com os Alias que foram Fechados			Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function CloseNotUse( aNotClose , aLastSelect )

Local aClosed		:= {}
Local cClosed		:= ""
Local lLastSelect	:= .F.
Local nClose		:= 0
Local nArqTab		:= Len( cArqTab )

IF ( lLastSelect := ( !Empty( aLastSelect ) .and. ( ValType( aLastSelect ) == "A" ) ) )
	nArqTab := Len( aLastSelect )
EndIF

For nClose := 1 To nArqTab
	IF ( lLastSelect )
		cClosed := aLastSelect[ nClose ]
	Else
		cClosed := SubStr( cArqTab , Getfxy( 5 , nClose ) , 3 )
	EndIF
	IF (;
			!Empty( cClosed );
			.and.;
			( Select( cClosed ) > 0 );
			.and.;
			( aScan( aNotClose , { |x| x == cClosed } ) == 0 );
		 )
		( cClosed )->( dbCloseArea() )
		IF ( aScan( aClosed , { |x| x == cClosed } ) == 0 )
			IF ( Select( cClosed ) == 0 )
				aAdd( aClosed , cClosed )
			EndIF
		EndIF
	EndIF
Next nClose

Return( aClosed )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRestartNotUse	ЁAutorЁMarinaldo de Jesus Ё Data Ё09/05/2002Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRestaura os Arquivos Fechados pela CloseNotUse()         	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL    														Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RestartNotUse( aSelect , aNotSelect )

Local cSelect		:= ""
Local lChk			:= .T.
Local lSelect		:= .T.
Local nUse			:= 0
Local nSelect		:= 0

aNotSelect := {}

IF ( ( nSelect := Len( aSelect ) ) > 0 )
	For nUse := 1 To nSelect
		cSelect := aSelect[ nUse ]
		IF ( Select( cSelect ) == 0 )
			IF !( lChk := ChkFile( cSelect ) )
				aAdd( aNotSelect , cSelect )
			EndIF
		EndIF	
	Next nUse
EndIF

lSelect := ( Empty( aNotSelect ) .and. !Empty( aSelect ) )

Return( lSelect )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPutFileInEof  ЁAutorЁ Marinaldo de Jesus  Ё Data Ё12/12/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁForca um Eof() para o Arquivo                               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁPutFileInEof( [ cAlias ] , [ nReg ]	)		 				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico      												Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PutFileInEof( cAlias , nReg )

DEFAULT cAlias	:= Alias()

IF ( cAlias )->( !Eof() )
	( cAlias )->( dbGoBottom() )
	( cAlias )->( dbSkip() )
EndIF

nReg := 0

Return( ( cAlias )->( Eof() ) )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPutFileInBof  ЁAutorЁ Marinaldo de Jesus  Ё Data Ё12/12/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁForca um Bof() para o Arquivo                               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁPutFileInBof( [ cAlias ] , [ nReg ]	)		 				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico      												Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PutFileInBof( cAlias , nReg )

DEFAULT cAlias	:= Alias()

IF ( cAlias )->( !Bof() )
	( cAlias )->( dbGoTop() )
	( cAlias )->( dbSkip( -1 ) )
EndIF

nReg := 0

Return( ( cAlias )->( Bof() ) )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁScopeCount	  ЁAutorЁ Marinaldo de Jesus  Ё Data Ё06/01/2003Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁConta o Numero de Registros conforme condicao               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁScopeCount( aScope , cAlias )								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico      												Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ScopeCount( aScope , cAlias , aRecnos , lRecno )

Local lAddRecno	:= ( ValType( aRecnos ) == "A" )
Local nSvRecno	:= 0
Local nCount	:= 0

DEFAULT aScope	:= Array( 05 )
DEFAULT cAlias	:= Alias()
DEFAULT lRecno	:= .T.

IF ( lRecno )
	nSvRecno := ( cAlias )->( Recno() )
EndIF

IF ( lAddRecno )
	lAddRecno := IF( !( lRecno ) , lRecno , lAddRecno )
EndIF	

IF ( lAddRecno )
	aRecnos	:= {}
EndIF

( cAlias )->(;
				dbEval(;
						{||;
								++nCount ,;
								IF(;
									( lAddRecno ) ,;
									aAdd( aRecnos , Recno() ) ,;
									NIL;
								  );
						 },;
             			aScope[ ASCOPE_FOR_COND 	]	,;
             			aScope[ ASCOPE_WHILE_COND	]	,;
             			aScope[ ASCOPE_NEXT_SCOPE	]	,;
             			aScope[ ASCOPE_REC_SCOPE 	]	,;
             			aScope[ ASCOPE_REST_SCOPE	]	 ;
           			  );
           	  )

IF ( lRecno )
	( cAlias )->( MsGoto( nSvRecno ) )
EndIF	

Return( nCount )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁDelRecnos	    ЁAutorЁMarinaldo de Jesus Ё Data Ё12/03/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁDeletar Registros conforme Alias e Array aRecnos            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function DelRecnos(	cAlias			,;	//01 -> Alias
					aRecnos 		,;	//02 -> Array com os Recnos
					bCondDele		,;	//03 -> Bloco com a Condicao para Delecao
					uParbCondDele	,;	//04 -> Parametro para o Bloco 
					aMsMmCpos		,;	//05 -> Array com os campos Memo para Delecao
					cAliasMsMm		 ;	//06 -> Alias para a MsMm
				)

Local cMsgErr
Local lDeleted
Local nRecno
Local nRecnos

DEFAULT bCondDele	:= { || .T. }
DEFAULT aMsMmCpos	:= {}
DEFAULT cAliasMsMm	:= "RDY"

IF (;
		!Empty( cAlias );
		.and.;
		( Select( cAlias ) > 0 );
	)
	IF ( ( nRecnos := Len( aRecnos ) ) > 0 )
		For nRecno := 1 To Len( aRecnos )
			IF !Empty( aRecnos[ nRecno ] )
				( cAlias )->( dbGoto( aRecnos[ nRecno ] ) )
				IF ( lDeleted := ( cAlias )->(;
												( Recno() == aRecnos[ nRecno ] );
												.and.;
												Eval( bCondDele , uParbCondDele );
											  );
					)						
					( cAlias )->( MsMmDel( cAlias , { aRecnos[ nRecno ] } , aMsMmCpos , cAliasMsMm ) )
					IF ( lDeleted := ( cAlias )->( RecLock( cAlias , .F. , .F. ) ) )
						IF !( lDeleted := ( cAlias )->( FkDelete( @cMsgErr ) ) )
							( cAlias )->( RollBackDelTran( cMsgErr ) )
						EndIF
						( cAlias )->( MsUnLock() )
					EndIF
					IF ( lDeleted )
						aRecnos[ nRecno ] := 0
					EndIF
				EndIF
			EndIF
		Next nRecno
	EndIF
EndIF

Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁMsMinMaxRec		ЁAutorЁMarinaldo de Jesus Ё Data Ё03/06/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCarregar o Menor e o Maior Recno do Arquivo       			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁMsMinMaxRec( cAlias , @nMinRec , @nMaxRec )				    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico   											    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function MsMinMaxRec( cAlias , nMinRec , nMaxRec , lExecQuery , cWhere )
         
#IFDEF TOP

	Local cQryMinMax	:= 0

	DEFAULT cAlias		:= Alias()
	DEFAULT lExecQuery	:= .T.
	DEFAULT cWhere		:= ""

	cAlias	:= Upper( Alltrim( cAlias ) )
	nMinRec	:= 0
	nMaxRec	:= 0

	IF ( lExecQuery )

		cQryMinMax := "SELECT "
		cQryMinMax += "MIN(R_E_C_N_O_) MINRECNO, "
		cQryMinMax += "MAX(R_E_C_N_O_) MAXRECNO"
		cQryMinMax += " FROM "
		cQryMinMax += InitSqlName( cAlias )
		cQryMinMax += cWhere

		IF ( MsOpenDbf(.T.,"TOPCONN",TcGenQry(,,cQryMinMax),"__QMINMAX",.F.,.T.) )

			nMinRec		:= __QMINMAX->MINRECNO
			nMaxRec		:= __QMINMAX->MAXRECNO
			__QMINMAX->( dbCloseArea() )
			dbSelectArea( cAlias )
		
		Else

			MinMaxRecNoQry( cAlias , @nMinRec , @nMaxRec )

		EndIF

	Else

		MinMaxRecNoQry( cAlias , @nMinRec , @nMaxRec )
	
	EndIF
	
#ELSE
	
	MinMaxRecNoQry( cAlias , @nMinRec , @nMaxRec )

#ENDIF

Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁMinMaxRecNoQry	ЁAutorЁMarinaldo de Jesus Ё Data Ё03/06/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCarregar o Menor e o Maior Recno do Arquivo       			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁMsMinMaxRec( cAlias , @nMinRec , @nMaxRec )				    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁMsMinMaxRec											    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function MinMaxRecNoQry( cAlias , nMinRec , nMaxRec )
                
Local aArea			:= GetArea()
Local aAreaAlias	:= {}

DEFAULT cAlias		:= Alias()

cAlias	:= Upper( Alltrim( cAlias ) )
nMinRec	:= 0
nMaxRec	:= 0

aAreaAlias := ( cAlias )->( GetArea() )

( cAlias )->( dbClearIndex() )
( cAlias )->( PutFileInBof() )
nMinRec := ( cAlias )->( Recno() )
( cAlias )->( PutFileInEof() )
IF ( cAlias )->( Eof() )
	( cAlias )->( dbSkip(-1) )
EndIF
nMaxRec := ( cAlias )->( Recno() )
IF ( cAlias )->( Bof() .and. Eof() )
	nMinRec	:= 0
	nMaxRec := 0
EndIF
( cAlias )->( dbCloseArea() )
ChkFile( cAlias )

RestArea( aAreaAlias )
RestArea( aArea )

Return( NIL )


/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁExeInAs400		ЁAutorЁMarinaldo de Jesus Ё Data Ё16/07/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se a Execucao eh no AS/400                         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ExeInAs400()
Return( ( TCSrvType() == "AS/400" ) )



/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁGetDataBase		ЁAutorЁMarinaldo de Jesus Ё Data Ё16/07/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna o DataBase em Uso									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetDataBase()

Local cGetAdv97 := GetAdv97()
Local cDataBase	:= ""

IF ( ( cDataBase := GetPvProfString( GetEnvServer() , "TopDataBase" , "ERROR" , cGetAdv97 ) ) == "ERROR" )
	cDataBase := GetPvProfString( "TopConnect" , "DataBase" , "ERROR" , cGetAdv97 )
EndIF

Return( cDataBase )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁChkDelRegs		ЁAutorЁMarinaldo de Jesus Ё Data Ё21/07/2003Ё
Ё      	   ЁChkDelRegs II   ЁAutorЁMauricio MR		  Ё Data Ё29/03/2006Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se os Registros podem ser deletados				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ChkDelRegs(	cAlias			,;	//01 -> Alias de Dominio
						nReg			,;	//02 -> Registro do Dominio
						nOpcx			,;	//03 -> Opcao para a AxDeleta
						cFilDel			,;	//04 -> Filial do do Dominio
						cKeyDel			,;	//05 -> Chave do do Dominio
						aAreas			,;	//06 -> Array contendo informacoes dos arquivos a serem pesquisados
						cMsgYesNo		,;	//07 -> Mensagem para MsgYesNo
						cTitLog			,;	//08 -> Titulo do Log de Delecao
						cMsgNoDelOk		,;	//09 -> Mensagem para o corpo do Log
						lExecAxDeleta	,;	//10 -> Se executa AxDeleta
						lShowLog		,;	//11 -> Se deve Mostrar o Log
						aLog			,;	//12 -> Array com o Log de Exclusao
						aLogTitle		,;	//13 -> Array com o Titulo do Log
						bSeek			,;	//14 -> Bloco para Posicionamento no Arquivo
						bWhile			,;	//15 -> Bloco para a Condicao While
						bLoopWhile		,;	//16 -> Bloco para Skip/Loop no While
						lCheckSx9		,;	//17 -> Verifica os Relacionamentos no SX9
						aNotSx9Check	,;	//18 -> Alias que nao deverao ser Verificados no SX9
						lChkSoft		,;	//19 -> Se faz uma checagem soft
						lRotAuto         ;  //20 -> Se esta executando rotina automatica
					)
         
Local aArea				:= GetArea()
Local aBagsName			:= {}
Local aRetIndex			:= {}
Local aNotSelect		:= {}
Local lDelOk			:= .T.
Local lGeraLog			:= .T.
Local lAxDeleta			:= .F.    
Local lSintetico		:= .F.
Local lTabCompart       := .T.

Local cTitleMsg
Local cAreaChkDel   
Local lRetIndex
Local lDomAndcDom
Local nArea
Local nAreas
Local nBag
Local nBags     
Local nNotSelect   
Local cFileLog:=""  

DEFAULT cAlias			:= Alias()
DEFAULT nReg			:= ( cAlias )->( Recno() )
( cAlias )->( MsGoto( nReg ) )
DEFAULT nOpcx			:= 5
DEFAULT cKeyDel			:= ( cAlias )->( __ExecMacro( IndexKey() ) )
DEFAULT aAreas			:= {}
DEFAULT cMsgYesNo		:= OemToAnsi(;
										STR0001 + ;	//'O sistema ir═ efetuar a verifica┤└o para ver se o registro selecionado"
										CRLF	+ ;	
										STR0002 + ;	//'para exclus└o est═ sendo utilizado. A verifica┤└o pode ser demorada." 
										CRLF	+ ;
										CRLF	+ ;
										STR0003	  ;	//'Confirma a exclus└o?'
									 )
DEFAULT cTitLog			:= OemToAnsi( STR0004 )	//'Log de verifica┤└o de exclus└o'
DEFAULT cMsgNoDelOk		:= OemToAnsi(;
										STR0005 + ;	//'A chave a ser excluida est═ sendo utilizada."
										CRLF	+ ;
										STR0006	  ;	//'At┌ que as refer┬ncias a ela sejam eliminadas a mesmo n└o pode ser excluida."
									 )
DEFAULT lExecAxDeleta	:= .F.
DEFAULT lShowLog		:= .T.
DEFAULT lCheckSx9		:= .T.
DEFAULT aNotSx9Check	:= {}
DEFAULT lChkSoft		:= .F.
DEFAULT lRotAuto        := .F.

aLog					:= {}
aLogTitle 				:= {} 

Private	lAbortPrint := .F.

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Checa modo de acesso da tabela principal                     Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды

If ! Empty(xFilial(cAlias))
	lTabCompart := .F.
EndIf                   

cTitleMsg := IF( Type( "cCadastro" ) == "C" .and. !Empty( cCadastro ) , OemToAnsi( cCadastro ) , STR0007 /*'Aten┤└o'*/ )

IF ( lDelOk := (;
					!( lShowLog );
					.or.;
					(;
						Iif(lRotAuto,.T.,  ( CursorArrow(),;
						MsgYesNo( cMsgYesNo , (cTitleMsg + " - " + cTitLog) )) ) ;
					);	
				);
	)

	IF ( lShowLog )
		If lRotAuto   
			lGeraLog:=.T.
		Else
			CursorArrow()
			lGeraLog := MsgNoYes( OemToAnsi( STR0008 ), ( cTitleMsg + " - " + cTitLog ) )	//"Deseja gerar Log?"
			If Type("lLog") <> "U"
				lLog := lGeraLog
			EndIf
		EndIf
		
		If lGeraLog
			If lRotAuto    
				lSintetico:=.F.
			Else
				lSintetico := MsgNoYes( OemToAnsi( STR0016 ), ( cTitleMsg + " - " + cTitLog ) )	//	"Demonstrar o Log Sinteticamente ?"  				
			Endif
		EndIf   
		If lRotAuto
	   		CursorWait()
	 	EndIF
    EndIF

	IF ( lCheckSx9 )
		CheckSx9( cAlias , @aAreas , @aNotSelect , aNotSx9Check )
	EndIF

	
	//Cria Regua para Acompanhamento do Processo de Verificacao de Dependencia entre os arquivos
	If lRotAuto
		ChkRegs(	cAlias			,;	//01 -> Alias de Dominio
					nReg			,;	//02 -> Registro do Dominio
					cFilDel			,;	//03 -> Filial do do Dominio
					cKeyDel			,;	//04 -> Chave do do Dominio
					aAreas			,;	//05 -> Array contendo informacoes dos arquivos a serem pesquisados
					lShowLog		,;	//06 -> Se deve Mostrar o Log
					@aLog			,;	//07 -> Array com o Log de Exclusao
					@aLogTitle		,;	//08 -> Array com o Titulo do Log
					bSeek			,;	//09 -> Bloco para Posicionamento no Arquivo
					bWhile			,;	//10 -> Bloco para a Condicao While
					bLoopWhile		,;	//11 -> Bloco para Skip/Loop no While
					lChkSoft		,;	//12 -> Se faz uma checagem soft  
					@aBagsName		,;  //13 -> Arquivos Temporarios Criados
					@aRetIndex		,;  //14 -> Alias Referentes aos Arquivos temporarios
					@lGeraLog		,;  //15 -> Se Gera Log
					@lDelOk			,; 	//16 -> Se a Delecao pode ser efetuada  
					lSintetico		,; 	//17 -> Demonstrar o Log Sinteticamente
					lTabCompart     ,; 	//18 -> Modo de acesso da tabela principal
					lRotAuto		;   //19 -> Se esta utilizando rotina automatica
					)
	Else
		Processa({|| ChkRegs(  			cAlias			,;	//01 -> Alias de Dominio
										nReg			,;	//02 -> Registro do Dominio
										cFilDel			,;	//03 -> Filial do do Dominio
										cKeyDel			,;	//04 -> Chave do do Dominio
										aAreas			,;	//05 -> Array contendo informacoes dos arquivos a serem pesquisados
										lShowLog		,;	//06 -> Se deve Mostrar o Log
										@aLog			,;	//07 -> Array com o Log de Exclusao
										@aLogTitle		,;	//08 -> Array com o Titulo do Log
										bSeek			,;	//09 -> Bloco para Posicionamento no Arquivo
										bWhile			,;	//10 -> Bloco para a Condicao While
										bLoopWhile		,;	//11 -> Bloco para Skip/Loop no While
										lChkSoft		,;	//12 -> Se faz uma checagem soft  
										@aBagsName		,;  //13 -> Arquivos Temporarios Criados
										@aRetIndex		,;  //14 -> Alias Referentes aos Arquivos temporarios
										@lGeraLog		,;  //15 -> Se Gera Log
										@lDelOk			,; 	//16 -> Se a Delecao pode ser efetuada  
										lSintetico		,; 	//17 -> Demonstrar o Log Sinteticamente
										lTabCompart     ,; 	//18 -> Modo de acesso da tabela principal
										lRotAuto		;   //19 -> Se esta utilizando rotina automatica
									)					;	
							},,,.T.;	// Permite abortar a checagem	
						)			
	EndIf
		     
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Garante o Posicionamento do Recno					 		  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	( cAlias )->( MsGoto( nReg ) )
	
	IF (;
			!( lDelOk );
			.and.;
			( lGeraLog );
		)
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Gera e Mostra o Log 										  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				10        20       30        40        50        60        70        80        90       100       110...
		1234567890123456789023456789012345678901234567890123456789012345678901234567890123456789012345678901234567890...
		Arquivo Registro   Conteudo
		XXX     9999999999 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*/
		aAdd( aLogTitle , STR0012 )	//"Arquivo Registro   Chave/Conteudo"
		IF ( lShowLog ) 
			lAbortPrint	:= .F.
			If lRotAuto
				cFileLog:=fMakeLog( { aLog },aLogTitle	,NIL,NIL,FunName(),cTitLog)
				AutoGrLog(cFileLog)
			Else
				CursorArrow()
				MsAguarde(;
								{ ||	CursorWait() ,;
											fMakeLog(;
													{ aLog } 	,;
													aLogTitle	,;
													NIL			,;
													NIL			,;
													FunName()	,;
													cTitLog		 ;
												),;
										CursorArrow();
								},;
								cTitLog;  
						 ) 
			EndIf
		EndIF
	ElseIF (;
				!( lDelOk );
				.and.;
				( lShowLog );
			)
		If lRotAuto
			AutoGrLog(OemToAnsi( cMsgNoDelOk ))		
		Else
			CursorArrow()
			MsgInfo( OemToAnsi( cMsgNoDelOk ) , ( cTitleMsg + " - " + cTitLog ) )
		EndIF
	ElseIF ( lAxDeleta := (;
								( lDelOk );
								.and.;
								( lExecAxDeleta );
								.and.;
								( lShowLog );
							);
			)
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Executa a Delecao   										  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		CursorArrow()
		AxDeleta( cAlias , nReg , nOpcx )

	EndIF

EndIF

IF ( lShowLog ) .And. !lRotAuto
	CursorWait()
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura a Area de Entrada								  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
nAreas := Len( aAreas )
For nArea := 1 To nAreas
	cAreaChkDel := aAreas[ nArea , 01 , 01 ]
	IF !Empty( cAreaChkDel )
		IF ( ( nNotSelect := aScan( aNotSelect , { |x| ( x == cAreaChkDel ) } ) ) > 0 )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Fecha as Areas que nao Estavam Selecionadas				  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			( aNotSelect[ nNotSelect ] )->( dbCloseArea() )
		ElseIF ( lRetIndex := ( aScan( aRetIndex , { |x| ( x == cAreaChkDel ) } ) > 0 ) )
			( cAreaChkDel )->( RetIndex( cAreaChkDel ) )
			RestArea( aAreas[ nArea , 01 ] )
		EndIF
	EndIF	
Next nAreas
RestArea( aArea )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Exclui os Arquivos Temporarios							  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
nBags := Len( aBagsName )
For nBag := 1 To nBags
	IF File( aBagsName[ nBag ] )
		fErase( aBagsName[ nBag ] )
	EndIF
Next nBag

IF ( lShowLog )
	CursorArrow()
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Carrega conteudo para retorno por Referencia		 		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
lShowLog := lGeraLog

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Garante o Posicionamento do Recno					 		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF !( lAxDeleta )
	( cAlias )->( MsGoto( nReg ) )
EndIF

Return( lDelOk )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁChkRegs         ЁAutorЁMauricio MR		  Ё Data Ё29/03/2006Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁChamada pela ChkDelRegs para Montar Log e  Verifica se os   Ё
Ё          Ёregisstros podem ser deletados.							    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function ChkRegs(	cAlias			,;	//01 -> Alias de Dominio
							nReg			,;	//02 -> Registro do Dominio
							cFilDel			,;	//03 -> Filial do do Dominio
							cKeyDel			,;	//04 -> Chave do do Dominio
							aAreas			,;	//05 -> Array contendo informacoes dos arquivos a serem pesquisados
							lShowLog		,;	//06 -> Se deve Mostrar o Log
							aLog			,;	//07 -> Array com o Log de Exclusao
							aLogTitle		,;	//08 -> Array com o Titulo do Log
							bSeek			,;	//09 -> Bloco para Posicionamento no Arquivo
							bWhile			,;	//10 -> Bloco para a Condicao While
							bLoopWhile		,;	//11 -> Bloco para Skip/Loop no While
							lChkSoft		,;	//12 -> Se faz uma checagem soft
							aBagsName		,;  //13 -> Arquivos Temporarios Criados
							aRetIndex		,;  //14 -> Alias Referentes aos Arquivos temporarios
							lGeraLog		,;  //15 -> Se Gera Log
							lDelOk			,; 	//16 -> Se a Delecao pode ser efetuada 
							lSintetico		,; 	//17 -> Demonstrar o Log Sinteticamente
							lTabCompart     ,; 	//18 -> Modo de acesso da tabela principal
							lRotAuto        ;   //19 -> Se esta executando rotina automatica
					)

Local aFieldTam	
Local aGetFields
Local cConteudo
Local cBagName
Local cKeyIndex
Local cCondIndex  
Local CCondicao
Local cFilAux
Local cAreaChkDel   
Local cAliasChkDel  
Local cAliasName
Local cPrefixoCpo
Local cSvKeyDel
Local cField
Local cFieldType   
Local cQuery 
Local cQueryWhere
Local cQryFields
Local lFindKey  
Local lQueryOpened
Local nArea
Local nAreas
Local nCond
Local nConds
Local nOrder
Local nGetFields
Local nLenaArea
Local nX   
Local nRecno  
Local cExpFil			:= "RC1/TM0/TM5/TNN/TNO/TNQ/TK8"

DEFAULT cAlias			:= Alias()
DEFAULT nReg			:= ( cAlias )->( Recno() )
DEFAULT cFilDel			:= xFilial( cAlias )
DEFAULT cKeyDel			:= ( cAlias )->( __ExecMacro( IndexKey() ) )
DEFAULT aAreas			:= {}
DEFAULT lShowLog		:= .T.
DEFAULT bSeek			:= { || dbSeek( ( cFilAux + cKeyDel ) , .F. ) }
DEFAULT	bWhile			:= { || ( cFilAux + cKeyDel ) $ __ExecMacro( cKeyIndex ) }
DEFAULT bLoopWhile		:= { || !( cFilAux + cKeyDel ) $ ( cConteudo  ) }
DEFAULT lChkSoft		:= .F.
DEFAULT lRotAuto		:= .F.

If Type("lDelDA4") == "U"
	lDelDA4 := .T.
Endif

cPrefixoCpo				:= ( PrefixoCpo( cAlias ) + "_" )
IF ( ( cAlias )->( FieldPos( ( cPrefixoCpo+"FILIAL" ) ) ) == 0 )
	cFilDel := ""
EndIF


cSvKeyDel	:= cKeyDel
nAreas		:= Len( aAreas )   
//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Inicia regua de processamento.                               Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If !lRotAuto
	ProcRegua(nAreas)
EndIf

Begin Sequence		
		For nArea := 1 To nAreas
			cAreaChkDel				 	:= Upper( AllTrim( aAreas[ nArea , 01 , 01 ] ) )
			cAliasQuery 				:= cAreaChkDel
			lDomAndcDom					:= ( cAreaChkDel == cAlias )
			lQueryOpened				:= .F.
			aAreas[ nArea , 01 , 01 ]	:= cAreaChkDel
			cFilAux						:= If( cAreaChkDel $ cExpFil , cFilDel , xFilial( cAreaChkDel , cFilDel ) )
			cPrefixoCpo					:= ( PrefixoCpo( cAreaChkDel ) + "_" )
			cKeyDel						:= cSvKeyDel
			cCondIndex					:= ""
			cKeyIndex					:= ""
			nOrder						:= IF( ( Len( aAreas[ nArea ] ) >= 3 ) , aAreas[ nArea , 3 ] , 0 )
			nConds						:= Len( aAreas[ nArea , 02 ] )
			nLenaArea					:= Len( aAreas[ nArea ] ) 
			cFilComp                    := cFilAux //Guarda filial para ser utilizado no log quando a tabela pai e compartilhada
            //здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Incrementa a Regua de Processamento.                         Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			cAliasName	:= cAreaChkDel + " - " +PosAlias( "SX2" , cAreaChkDel , "" , "X2Nome()" , 1 , .F. )
			If !lRotAuto          
				IncProc(OemToAnsi(STR0014 + cAliasName ))		 // Verificando o arquivo ##Nome do Arquivo
			EndIf

			IF (;
					( nLenaArea >= 4 );
					.and.;
					( nConds == 0 );
					.and.; 
					( ValType( aAreas[ nArea , 04 ] ) == "B" );
				 )
				lDelOk := Eval( aAreas[ nArea , 04 ] , @aLog , @aLogTitle )
				IF (;
						( lShowLog );
						.and.;
						!( lGeraLog );
					 )
					IF !( lDelOk )
						Break
					EndIF
				EndIF
				Loop
			ElseIF (;
						( nLenaArea >= 5 );
						.and.;
						!Empty( aAreas[ nArea , 05 ] );
					 )
				cKeyDel := ( cAlias  )->( __ExecMacro( aAreas[ nArea , 05 ] ) )
			EndIF

           	/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Tratamento para tabela principal em modo compartilhado.     Ё
			Ё Neste caso nao utiliza o campo filial na chave de pesquisa  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/			
			For nCond := If( lTabCompart, 2, 1 ) To nConds   
							
				IF ( !Empty( aAreas[ nArea , 02 , nCond ] ) )
					cField 		:= aAreas[ nArea , 02 , nCond ]
					cFieldType	:= ( cAreaChkDel )->( Type( cField ) )

					IF ( cFieldType == "D" )
						cField	:= "Dtos(" + cField + ")"
					ElseIF ( cFieldType == "N" ) 
						aFieldTam := TamSx3( cField )
						IF !Empty( aFieldTam )
							cField	:= "Str(" + cField + "," + AllTrim( Str( aFieldTam[1] ) ) + "," + AllTrim( Str( aFieldTam[2] ) ) + ")"
						Else
							cField	:= "Str(" + cField + ",10,2)"
						EndIF
					ElseIF ( cFieldType <> "C" )
						Loop
					EndIF
					cCondIndex	+=	cField
					cKeyIndex 	+=	cField 
									
					IF ( nCond < nConds )
						cCondIndex   	+= "+"
						cKeyIndex   	+= "+"
					EndIF 
				EndIF
			Next nCond  
						
			cCondIndex	    := StrTran( cCondIndex , " "  , "" )
			cCondIndex   	:= StrTran( cCondIndex , "++" , "" )
			IF ( SubStr( cCondIndex , -1 ) == "+" )
				cCondIndex	:= SubStr( cCondIndex , 1 , Len( cCondIndex ) - 1 )
			EndIF
			IF (;
					(;
						!( ( cPrefixoCpo+"FILIAL" ) $ Upper( cKeyIndex ) ) ;
						.And. ;
						!cAreaChkDel $ cExpFil ;
					);
					.or. ;
			    	( ( cAreaChkDel )->( FieldPos( ( cPrefixoCpo+"FILIAL" ) ) ) == 0 );
			    )	
				cFilAux := ""
			EndIF			
			
           	/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Tratamento para tabela principal em modo compartilhado.     Ё
			Ё Neste caso nao utiliza o campo filial na chave de pesquisa  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/			     
			If lTabCompart
				cCondIndex	    += ( " == '" + cKeyDel + "'" )			
			Else
				cCondIndex	    += ( " == '" + cFilAux + cKeyDel + "'" )
			EndIf
			
			cKeyIndex		:= StrTran( cKeyIndex , " "  , "" )
			cKeyIndex		:= StrTran( cKeyIndex , "++" , "" )
			IF ( SubStr( cKeyIndex , -1 ) == "+" )
				cKeyIndex	:= SubStr( cKeyIndex , 1 , Len( cKeyIndex ) - 1 )
			EndIF
			cBagName := ""
			( cAreaChkDel )->( RetIndex( cAreaChkDel ) )
	
			#IFDEF TOP
               cCondicao	:= StrTran(Substr(cCondIndex, At("'",cCondIndex)),"'","")
               cQueryWhere	:= ""

	           /*/
			   зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			   Ё Tratamento para tabela principal em modo compartilhado.     Ё
			   Ё Neste caso nao utiliza o campo filial na chave de pesquisa  Ё
			   юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			   dbSelectArea("SX3")
			   SX3->(dbSetOrder(2))
			   For nCond := If( lTabCompart, 2, 1 ) To nConds
							   
					IF ( !Empty( aAreas[ nArea , 02 , nCond ] ) )
						cField 		:= aAreas[ nArea , 02 , nCond ]
						If SX3->(dbSeek(cField))
		               		aFieldTam 	:= TamSx3( cField ) 
	    	           		cConteudo	:=  Substr(cCondicao, 1, aFieldTam[1]) 
	        	    		cFieldType	:= ( cAreaChkDel )->( Type( cField ) )  
		           		    
		           		    /**********************************************************************************
							A posicao 04 do vetor indica se uma condicao especial deve ser adicionada ou nao, 
							se existir a posicao 04 entao sera verificado se ela e do tipo array e ainda se 
							o seu conteudo esta sendo passado de acordo com a posicao 02 do vetor (nArea, 02)
							isso porque a posicao 02 indicam os nomes dos campos.
							Funciona assim, na posicao 02 e indicado o nome do campo e na posicao 04 pode ser 
							indicado ou nao a condicao de procura que ele deve seguir, caso nao tenha sera seguido
							a condicao =  
							Ex:
							aAreas[ XX ,01] := SRM->( GetArea() ) 						->TABELA DE TRABALHO
							aAreas[ XX ,02] := {"RM_CODCRI"}                            ->CAMPO REF A CONDICAO
							aAreas[ XX ,03] := RetOrdem( "SRM" , "RM_CODCRI" , .T. )    ->ORDEM DO INDICE, PARA CASO DBF
							aAreas[ XX ,04] := { "='@'" }                               ->CONDICAO QUE O CAMPO DEVERA SEGUIR (So SQl),@=CONTEUDO
							
							Mais detalhes de uso ver em Gpea470 entre Outros
							**************************************************************************************/
		           		    If Len(aAreas[nArea]) > 3 .And. ValType( aAreas[nArea, 04] ) == "A"
			     				If !Empty(aAreas[nArea, 04, nCond]) .And. (Len(aAreas[nArea, 02])==Len(aAreas[nArea, 04]))
			     					//ADICIONA A EXPRESSAO DE CONDICAO LIKE POR EX
			    	        	    cQueryWhere	+= cField + StrTran(aAreas[nArea , 04, nCond ] , "@", cConteudo )    	     				
			    	        	Else    
			    	        		cQueryWhere	+= cField + "='" + cConteudo + "'"   
		           				EndIf 
		           				
		           			   	If IIf(cPaisLoc <> "BRA", nCond <= nConds, (nCond + 1) > nConds)
					           		cQueryWhere	+= " AND "
		    	       			EndIf   
							Else
								If "_FILIAL" $ cField
									cQueryWhere	+= cField + " LIKE '" + AllTrim(cConteudo) + "%'"
								Else
									cQueryWhere	+= cField + "='" + cConteudo + "'"
				           		EndIf
								cQueryWhere	+= " AND "  
							EndIf	
							
	    	       			cCondicao	:= Substr(cCondicao,1+aFieldTam[1])
	    	       		EndIf
           			EndIf	
               Next nCond
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Monta Query para verificar a Delecao.  					  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			
			 	aGetFields	:= (cAreaChkDel)->( dbStruct() )
				nGetFields	:= Len( aGetFields )
				cQryFields	:= ""
				For nX := 1 To nGetFields
		        	cQryFields += aGetFields[ nX , 01 ] + ", "
				Next nX
				cQuery := "SELECT "
				cQuery += cQryFields
				cQuery += "R_E_C_N_O_ RECNO "
				cQuery += " FROM "
				cQuery += InitSqlName(cAreaChkDel)
				cQuery += " WHERE "
				cQuery += cQueryWhere
				cQuery += "D_E_L_E_T_=' ' "
				If !Empty( nOrder )
					cQuery += "ORDER BY " + SqlOrder( (cAreaChkDel)->( IndexKey(nOrder) ) )
				Endif
				cQuery 		:= ChangeQuery(cQuery) 
				cAliasQuery := GetNextAlias()
				IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
					For nX := 1 To nGetFields
						IF ( aGetFields[ nX , 02 ] <> "C" )
							TcSetField(cAliasQuery,aGetFields[nX,01],aGetFields[nX,02],aGetFields[nX,03],aGetFields[nX,04])
						EndIF 
					
					Next nX   
					
				            
					lFindKey	:=  ( ( cAliasQuery )->( !Eof() ) )
				Else
					cAliasQuery := cAreaChkDel
				EndIF	
			#ENDIF

		    IF !( lQueryOpened ) 
				IF (;
						( Empty( nOrder );
						.and.;
						Empty( nOrder := Retorder( cAliasQuery , cKeyIndex , .T. ) );
						.Or.;
						lTabCompart;
				    );
				 )
					cBagName	:= ( CriaTrab( "" , .F. ) + OrdBagExt() )
					( cAliasQuery )->( IndRegua( cAliasQuery , cBagName , cKeyIndex , NIL , cCondIndex , OemToAnsi( STR0009 ) ) ) //'Criando Indice no Servidor. Aguarde...'
					aAdd( aBagsName , cBagName )
					aAdd( aRetIndex , cAliasQuery )
				Else
					( cAliasQuery )->( dbSetOrder( nOrder ) )
				EndIF

	           	/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Tratamento para tabela principal em modo compartilhado.     Ё
				Ё Neste caso nao utiliza o campo filial na chave de pesquisa  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				If lTabCompart
					bSeek      := { || dbSeek( ( cKeyDel ) , .F. ) }
				EndIf
				
	            lFindKey := ( cAliasQuery )->( Eval( bSeek ) ) 
            Endif        
           	/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se encontrou na chave abandona ou gera log de registros	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF  lFindKey 
				IF ( lChkSoft )
					lDelOk := .F. 
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Fecha a Query e Seta a Area do Arquivo Original              Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				    IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
				    	( cAliasQuery )->( dbCloseArea() )
				    	dbSelectArea( cAreaChkDel )
				    EndIF
			    	IF ! ( lQueryOpened )
						IF !Empty( cBagName )
							( cAreaChkDel )->( RetIndex( cAreaChkDel ) )
							IF ( fErase( cBagName ) <> -1 )
								aDel( aBagsName , Len( aBagsName ) )
								aSize( aBagsName , Len( aBagsName ) - 1 )
							EndIF
						EndIF
		            Endif 
		           	IF ( lDomAndcDom )
						( cAlias )->( MsGoto( nReg ) )
					EndIF
					Break
				EndIF

	           	/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Tratamento para tabela principal em modo compartilhado.     Ё
				Ё Neste caso nao utiliza o campo filial na chave de pesquisa  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				If lTabCompart
					//cKeyIndex	:= cField
					bSeek		:= { || dbSeek( ( cKeyDel ) , .F. ) }
					bWhile		:= { || ( cKeyDel ) $ __ExecMacro( cKeyIndex ) }
					bLoopWhile	:= { || !( cKeyDel ) $ ( cConteudo  ) }
				EndIf											

				While ( ( cAliasQuery )->( !Eof() ) )
					//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Aborta a Verificacao										 Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					If lAbortPrint 
						lDelOk := .F.
						aAdd( aLog , "" )
						aAdd( aLog , "" )
						aAdd( aLog , STR0015 ) //"Processo Interrompido pelo Operador."  		
						Break
					Endif
			
					cConteudo := ( cAliasQuery )->( __ExecMacro( cKeyIndex ) )
			
					lDelOk := .F.
					IF (;
							( lShowLog );
							.and.;
							!( lGeraLog );
						 )
						Break
					EndIF
 					IF ( Empty( aLog ) )
						aAdd( aLog , STR0010 + If(lTabCompart, cFilComp, cFilAux) + "/" + cKeyDel + STR0011 ) //'A chave ( Filial/Codigo ) ': "###' nao pode ser Excluida pois esta sendo utilizada nos arquivos abaixo'
						aAdd( aLog , "" )
						aAdd( aLog , "" )
					EndIF 
					#IFNDEF TOP
						nRecno:=( cAliasQuery )->( Recno() ) 
					#ELSE
						IF !( lQueryOpened )
								nRecno:=( cAliasQuery )->( Recno() ) 
						Else
								nRecno:=( cAliasQuery )->( RECNO  )
						EndIF
					#ENDIF
					If lSintetico  
					    If Empty(Ascan(aLog, {|x| x ==  Alltrim(cAliasName) } ) )         
						   	aAdd( aLog , Alltrim(cAliasName)  ) 
						Endif   	
					   	Exit
					Else
			           	/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Insere a Filial para exibicao no Log de ocorrencias         Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						If lTabCompart  
							cCodFil := cPrefixoCpo+"FILIAL"
							aAdd( aLog , cAreaChkDel + Space( 05 ) + ( cAliasQuery )->( StrZero( nRecno , 10 )  + Space( 01 ) + AllTrim( __ExecMacro( IndexKey() ) ) + "/" + AllTrim( __ExecMacro( cCodFil ) ) + cConteudo ) )						
						Else
							aAdd( aLog , cAreaChkDel + Space( 05 ) + ( cAliasQuery )->( StrZero( nRecno , 10 )  + Space( 01 ) + AllTrim( __ExecMacro( IndexKey() ) ) + "/" + cConteudo ) )
						EndIf
					Endif
					( cAliasQuery )->( dbSkip() )
				End While	
			EndIF
			
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Fecha a Query e Seta a Area do Arquivo Original              Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		    IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
		    	( cAliasQuery )->( dbCloseArea() )
		    	dbSelectArea( cAreaChkDel )
		    EndIF
			
			IF ! ( lQueryOpened )
				IF !Empty( cBagName )
					( cAreaChkDel )->( RetIndex( cAreaChkDel ) )
					IF ( fErase( cBagName ) <> -1 )
						aDel( aBagsName , Len( aBagsName ) )
						aSize( aBagsName , Len( aBagsName ) - 1 )
					EndIF
				EndIF
            Endif

			IF ( lDomAndcDom )
				( cAlias )->( MsGoto( nReg ) )
			EndIF
		Next nAreas
		If lSintetico .and. !lDelDA4 
			IF len(aLog) <= 0
				aAdd( aLog , STR0010 + If(lTabCompart, cFilComp, cFilAux) + "/" + cKeyDel + STR0011 ) //'A chave ( Filial/Codigo ) ': "###' nao pode ser Excluida pois esta sendo utilizada nos arquivos abaixo'
				aAdd( aLog , "" )
				aAdd( aLog , "" )
			else
				aAdd( aLog , Alltrim("DA4" + " - " +PosAlias( "SX2" , "DA4" , "" , "X2Nome()" , 1 , .F. ))  )
			endif
		Endif
End Sequence

Return( lAbortPrint )
	
/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁCheckSx9		ЁAutorЁMarinaldo de Jesus Ё Data Ё09/03/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCarrega os Relacionamentos do SX9 							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function CheckSx9( cAlias , aAreas , aNotSelect , aNotSx9Check )

Local nSX9Order	:= SX9->( IndexOrd() )
Local lCheckSx9	:= .F.

Local aAreaAux
Local aFields   
Local aFieldTam
Local cField
Local cFieldType
Local cAliasCDom
Local cExpDom
Local cExpCDom
Local cPrefixoCpo
Local cFieldFil
Local cRetorder
Local nAreas
Local nField
Local nFields
Local nChkSx9Pos
Local nChk
Local nChks
Local lFilCDom	:= .F. 								//-- Indica se considera filial da tabela ou  o campo de filial especifico

DEFAULT aAreas			:= {}
DEFAULT aNotSelect		:= {}
DEFAULT aNotSx9Check	:= {}

cAlias := Upper( AllTrim( cAlias ) )

Begin Sequence
	
	DEFAULT aCheckSx9	:= {}
	DEFAULT nCheckSx9	:= 0
	IF (;
			( nCheckSx9 > 0 );
			.and.;
			( nCheckSx9 <= Len( aCheckSx9 ) );
			.and.;
			( aCheckSx9[ nCheckSx9 , 01 ] == cAlias );
		)
		nChkSx9Pos := nCheckSx9 
	ElseIF ( ( nChkSx9Pos := aScan( aCheckSx9 , { |x| ( x[ 1 ] == cAlias ) } ) ) > 0 )
		nCheckSx9 := nChkSx9Pos
	EndIF
	IF ( nChkSx9Pos > 0 )
		nChks := Len( aCheckSx9[ nChkSx9Pos , 02 ] )
		For nChk := 1 To nChks
			cAliasCDom := aCheckSx9[ nChkSx9Pos , 02 , nChk , 01 , 01 ]
			IF ( aScan( aNotSx9Check , { |x| ( x == cAliasCDom ) } ) == 0 )
				aAdd( aAreas , aClone( aCheckSx9[ nChkSx9Pos , 02 , nChk ] ) )
				lCheckSx9 := .T.
			EndIF	
		Next nChk
		Break
	Else
		aAdd( aCheckSx9 , { cAlias , {} } )
		nChkSx9Pos := Len( aCheckSx9 )
		nCheckSx9 := nChkSx9Pos
	EndIF

	SX9->( dbSetOrder( 1 ) ) //X9_DOM
	IF SX9->( dbSeek( cAlias , .F. ) )
		While SX9->( !Eof() .and. Upper( AllTrim( X9_DOM ) ) == cAlias )
			cAliasCDom 	:= Upper( AllTrim( SX9->X9_CDOM ) )
			lFilCDom		:= .F.
			IF ( Select( cAliasCDom ) == 0 )
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Verifica se considera as tabelas JBL/TQL nos paises diferen- Ё
				//Ё tes do Brasil.                                               Ё		
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If (cAliasCDom$"JBL/TQL".AND.CPAISLOC<>"BRA")
					SX9->( dbSkip() )
					Loop
				Else
					IF ( CheckExecForm( { || dbSelectArea( cAliasCDom ) } , .F. ) )
						aAdd( aNotSelect , cAliasCDom )
					Else
						SX9->( dbSkip() )
						Loop
					EndIF
				Endif
			EndIF
			
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se considera filial da tabela ou outro campo de con-Ё
			//Ё trole de filial no c.dominio  . Ex.Tabela TM0/TM5            Ё		
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			cExpDom		:= Upper( AllTrim( SX9->X9_EXPDOM ) )
			cPrefixoCpo := ( PrefixoCpo( cAlias ) + "_" )
			cFieldFil	:= ( cPrefixoCpo + "FILIAL" )
			IF ( cFieldFil $ cExpDom )
				lFilCDom	:= .T. 
			Endif 
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Monta expressao de contra dominio                            Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			aAreaAux 	:= Array( 6 )
			aAreaAux[1]	:= ( cAliasCDom )->( GetArea( cAliasCDom ) )
			cExpCDom	:= Upper( AllTrim( SX9->X9_EXPCDOM ) )
			cPrefixoCpo	:= ( PrefixoCpo( cAliasCDom ) + "_" )
			cFieldFil	:= ( cPrefixoCpo + "FILIAL" )
			aFields	 	:= {} 
			
			If !( cFieldFil $ cExpCDom ) .and. !lFilCDom
				IF ( ( cAliasCDom )->( FieldPos( cFieldFil ) > 0 ) )
					cExpCDom := ( cFieldFil + "+" + cExpCDom )
				EndIF
			EndIF
			aFields		:= StrToArray( cExpCDom )
			nFields		:= Len( aFields )
			aAreaAux[2]	:= Array( nFields )
			cRetorder	:= ""
			For nField := 1 To nFields
				aAreaAux[2,nField] := aFields[ nField ]
				cRetorder += aFields[ nField ]
				IF ( nField < nFields )
					cRetorder += "+"
				EndIF
			Next nField
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Monta expressao de dominio                                   Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			aAreaAux[3]	:= Retorder( cAliasCDom , cRetorder , .T. )
			cExpDom		:= Upper( AllTrim( SX9->X9_EXPDOM ) )
			cPrefixoCpo := ( PrefixoCpo( cAlias ) + "_" )
			cFieldFil	:= ( cPrefixoCpo + "FILIAL" )
			aFields		:= {}
			IF !( cFieldFil $ cExpDom )
				IF ( ( cAlias )->( FieldPos( cFieldFil ) > 0 ) )
					cExpDom := ( cFieldFil + "+" + cExpDom )
				EndIF
			EndIF
			aFields		:= StrToArray( cExpDom )
			cExpDom 	:= ""
			nFields		:= Len( aFields )
			aAreaAux[6]	:= Array( nFields )
			For nField := 1 To nFields
				cField := aFields[ nField ]
				aAreaAux[6,nField] := cField
				IF ( cField <> cFieldFil )
					cFieldType	:= ( cAlias )->( Type( cField ) )
					IF ( cFieldType == "D" )
						cField	:= "Dtos(" + cField + ")"
					ElseIF ( cFieldType == "N" )
						aFieldTam := TamSx3( cField )
						IF !Empty( aFieldTam )
							cField	:= "Str(" + cField + "," + AllTrim( Str( aFieldTam[1] ) ) + "," + AllTrim( Str( aFieldTam[2] ) ) + ")"
						Else
							cField	:= "Str(" + cField + ",10,2)"
						EndIF
					ElseIF ( cFieldType <> "C" )
						Loop
					EndIF
					cExpDom += cField
					IF ( nField < nFields )
						cExpDom += "+"
					EndIF
				EndIF

			Next nField
			If substr(Alltrim(cExpDom),len(alltrim(cExpDom)),1) == "+"
				cExpDom := substr(Alltrim(cExpDom),1,len(alltrim(cExpDom))-1)
			EndIf
			aAreaAux[5] := cExpDom
			IF ( aScan( aAreas , { |x|;
										(;
											( Upper( AllTrim( x[1,1] ) ) == cAliasCDom );
											.and.;
											ArrayCompare( x[2] , aAreaAux[2] );
										);
								 };
						) == 0;
				)
				IF ( aScan( aNotSx9Check , { |x| ( Upper( AllTrim( x ) ) == cAliasCDom ) } ) == 0 )
					aAdd( aAreas , aClone( aAreaAux ) )
				EndIF
				aAdd( aCheckSx9[ nChkSx9Pos , 02 ] , aClone( aAreaAux ) )
				lCheckSx9 := .T.
			EndIF
			SX9->( dbSkip() )
		End While
	EndIF
	
	SX9->( dbSetOrder( nSX9Order ) )

End Sequence
	
Return( lCheckSx9 )

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRstCheckSx9   Ё Autor ЁMarinaldo de Jesus     Ё Data Ё11/09/2003Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁReinicializa as Statics em CheckSx9()                       	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL																Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstCheckSx9()

aCheckSx9	:= {}
nCheckSx9	:= 0

Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁBldIntegrityFileЁAutorЁMarinaldo de Jesus Ё Data Ё12/05/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMonta Relacionamentos de Integridade ( Baseado no SX9 )  conЁ
Ё          Ёforme Opcao ( lInsert ou !( lIsert )                        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function BldIntegrityFile( aIntegrityFile , cAlias , lInsert )

Local aSx9BldRel		:= {}
Local bAscanAlias		:= { |x| ( x[1] == cAlias ) }
Local lBldIntegrityFile	:= .F.
Local lRestArea			:= .F.

Local aSx9Area
Local nIntFilePos
Local nAliasPos
Local nSx9Order

DEFAULT aIntegrityFile	:= {}
DEFAULT cAlias			:= Alias()
DEFAULT lInsert			:= .T.

cAlias := Upper( AllTrim( cAlias ) )

Begin Sequence

	IF ( lInsert )
		lBldIntegrityFile := ( ( nIntFilePos := aScan( aIntgFileInsert , bAscanAlias ) ) > 0 )
	Else
		lBldIntegrityFile := ( ( nIntFilePos := aScan( aIntgFileDelete , bAscanAlias ) ) > 0 )
	EndIF

	IF ( lBldIntegrityFile )
		IF ( ( nAliasPos := aScan( aIntegrityFile , bAscanAlias ) ) == 0 )
			aAdd( aIntegrityFile , { cAlias , {} } )
			nAliasPos := Len( aIntegrityFile )
		EndIF
		IF ( lInsert )
			aIntegrityFile[ nAliasPos , 02 ] := aClone( aIntgFileInsert[ nIntFilePos , 02 ] )
		Else
			aIntegrityFile[ nAliasPos , 02 ] := aClone( aIntgFileDelete[ nIntFilePos , 02 ] )
		EndIF
		Break
	EndIF

	aSx9Area	:= SX9->( GetArea() )
	lRestArea	:= .T.

	IF ( lInsert )
		nSx9Order := 2	//X9_CDOM+X9_DOM
	Else
		nSx9Order := 1	//X9_DOM
	EndIF

	SX9->( dbSetOrder( nSx9Order ) )

	IF !( lBldIntegrityFile := SX9->( dbSeek( cAlias , .F. ) ) )
		Break
	EndIF

	Private aSx9CrossRef := {}
	Sx9BldRel( cAlias , @aSx9BldRel , nSx9Order , lInsert , 0 )
	IF !( lBldIntegrityFile := ( Len( aSx9BldRel ) > 0 ) )
		Break
	EndIF
	
	aSort( aSx9BldRel , NIL , NIL , { |x,y| ( x[2] > y[2] ) } )
	IF ( lInsert )
		aAdd( aIntgFileInsert , { cAlias , aClone( aSx9BldRel ) } )
		nIntFilePos := Len( aIntgFileInsert )
	Else
		aAdd( aIntgFileDelete , { cAlias , aClone( aSx9BldRel ) } )
		nIntFilePos := Len( aIntgFileDelete )
	EndIF
	IF ( ( nAliasPos := aScan( aIntegrityFile , bAscanAlias ) ) == 0 )
		aAdd( aIntegrityFile , { cAlias , {} } )
		nAliasPos := Len( aIntegrityFile )
	EndIF
	IF ( lInsert )
		aIntegrityFile[ nAliasPos , 02 ] := aClone( aIntgFileInsert[ nIntFilePos , 02 ] )
	Else
		aIntegrityFile[ nAliasPos , 02 ] := aClone( aIntgFileDelete[ nIntFilePos , 02 ] )
	EndIF	

End Sequence

IF ( lRestArea )
	RestArea( aSx9Area )
EndIF

Return( lBldIntegrityFile )

/*/
зддддддддддбдддддддддддддддддддбдддддбддддддддддддддддддбддддбдддддддддд©
ЁFun┤┘o    ЁRstBldIntegrityFileЁAutorЁMarinaldo de JesusЁDataЁ12/05/2004Ё
цддддддддддедддддддддддддддддддадддддаддддддддддддддддддаддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa as Staticas utilizadas em BldIntegrityFile()  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstBldIntegrityFile()

aIntgFileInsert	:= {}
aIntgFileDelete	:= {}

Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁSx9BldRel		ЁAutorЁMarinaldo de Jesus Ё Data Ё12/05/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna aSx9BldRel caso hajam relacionamentos para o cAlias Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁBldIntegrityFile									    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Sx9BldRel( cAlias , aSx9BldRel , nSx9Order , lInsert , nNivel )

Local aEqualDomCDom
Local cX9Dom
Local cX9cDom
Local cDomOrCDom
Local cExpDom
Local cExpcDom
Local lCrossRef
Local nPosAlias
Local nPosDom
Local nLoop
Local nLoops

IF ( aScan( aSx9BldRel , { |x| ( x[1] == cAlias ) } ) == 0 )
	aAdd( aSx9BldRel , { cAlias , nNivel , {} } )
	aEqualDomCDom := {}
	IF SX9->( dbSeek( cAlias , .F. ) )
		nPosAlias := Len( aSx9BldRel )
		While ( SX9->(;
							!Eof();
							.and.;
							( IF( lInsert , X9_CDOM , X9_DOM ) == cAlias ) );
					 )
			cX9Dom 	:= SX9->X9_DOM
			cX9cDom	:= SX9->X9_CDOM
			IF ( lInsert )
				cDomOrCDom	:= cX9Dom
			Else
				cDomOrCDom	:= cX9cDom
			EndIF
			IF ( lCrossRef := Sx9CrossRef( cX9Dom , cX9cDom , nSx9Order ) )
				IF ( cX9Dom == cX9cDom )
					SX9->( aAdd( aEqualDomCDom , Recno() ) )
					SX9->( dbSkip() )
					Loop
				EndIF
			EndIF
			cExpDom		:= Upper( Alltrim( SX9->X9_EXPDOM  	) )
			cExpcDom	:= Upper( AllTrim( SX9->X9_EXPCDOM 	) )
			IF ( ( nPosDom := aScan( aSx9BldRel[ nPosAlias , 03 ] , { |x| x[1] == cDomOrCDom } ) ) == 0 )
				aAdd( aSx9BldRel[ nPosAlias , 03 ] , { cDomOrCDom , { cExpDom } , { cExpcDom } , { lCrossRef } } )
			Else
				aAdd( aSx9BldRel[ nPosAlias , 03 , nPosDom , 02 ] , cExpDom  	)
				aAdd( aSx9BldRel[ nPosAlias , 03 , nPosDom , 03 ] , cExpcDom 	)
				aAdd( aSx9BldRel[ nPosAlias , 03 , nPosDom , 04 ] , lCrossRef	)
			EndIF
			SX9->( dbSkip() )
		End While
		nLoops := Len( aEqualDomCDom )
		For nLoop := 1 To nLoops
			SX9->( dbGoto( aEqualDomCDom[ nLoop ] ) )
			IF ( lInsert )
				cDomOrCDom	:= SX9->X9_DOM
			Else
				cDomOrCDom	:= SX9->X9_CDOM
			EndIF
			cExpDom		:= Upper( Alltrim( SX9->X9_EXPDOM  	) )
			cExpcDom	:= Upper( AllTrim( SX9->X9_EXPCDOM 	) )
			IF ( ( nPosDom := aScan( aSx9BldRel[ nPosAlias , 03 ] , { |x| x[1] == cDomOrCDom } ) ) == 0 )
				aAdd( aSx9BldRel[ nPosAlias , 03 ] , { cDomOrCDom , { cExpDom } , { cExpcDom } , { .T. } } )
			Else
				aAdd( aSx9BldRel[ nPosAlias , 03 , nPosDom , 02 ] , cExpDom  )
				aAdd( aSx9BldRel[ nPosAlias , 03 , nPosDom , 03 ] , cExpcDom )
				aAdd( aSx9BldRel[ nPosAlias , 03 , nPosDom , 04 ] , .T.		 )
			EndIF
		Next nLoop
		++nNivel
		nLoops := Len( aSx9BldRel[ nPosAlias , 03 ] )
		For nLoop := 1 To nLoops
			cAlias := aSx9BldRel[ nPosAlias , 03 , nLoop , 01 ]
			Sx9BldRel( cAlias , @aSx9BldRel , nSx9Order , lInsert , nNivel )
		Next nLoop
	EndIF
EndIF

Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁSx9CrossRef		ЁAutorЁMarinaldo de Jesus Ё Data Ё20/05/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica as Referencias Cruzadas no SX9                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlCrossRef                  									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁSx9BldRel											    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Sx9CrossRef( cX9Dom , cX9cDom , nSx9Order )

Local lCrossRef := .F.

Local cSeek
Local nSx9Recno
Local nPos

Begin Sequence

	nSx9Recno := SX9->( Recno() )

	IF ( ( nPos := aScan( aSx9CrossRef , { |x|;
													(;
														(;
															( x[1] == cX9Dom );
															.and.;
															( x[2] == cX9cDom );
														);
														.or.;
														(;
															( x[1] == cX9cDom );
															.and.;
															( x[2] == cX9Dom );
														);
														.and.;
														(;
															( nSx9Recno == x[3] );
															.or.;
															( 0 == x[3] );
														);	
													);
										};
								);
		  ) > 0;
		)
		lCrossRef := aSx9CrossRef[ nPos , 4 ]
		Break
	EndIF

	SX9->( dbSetOrder( 2 ) ) //X9_CDOM+X9_DOM
	
	lCrossRef := SX9->(;
							MsSeek( cX9Dom + cX9cDom , .F. );
							.and.;
							MsSeek( cX9cDom + cX9Dom , .F. );
					   )

	IF ( lCrossRef )
		cSeek := ( cX9Dom + cX9cDom )
		IF SX9->( dbSeek( cSeek , .F. ) )
			While SX9->(;
							!Eof();
							.and.;
							( ( X9_DOM + X9_CDOM ) == cSeek );
						 )
				aAdd( aSx9CrossRef , { cX9Dom , cX9cDom , SX9->( Recno() ) , .T. } )
				SX9->( dbSkip() )
			End While
		EndIF
		cSeek := ( cX9cDom + cX9Dom )
		IF SX9->( dbSeek( cSeek , .F. ) )
			While SX9->(;
							!Eof();
							.and.;
							( ( X9_CDOM + X9_DOM ) == cSeek );
						)
				aAdd( aSx9CrossRef , { cX9cDom , cX9Dom , SX9->( Recno() ) , .T. } )
				SX9->( dbSkip() )
			End While
		EndIF
	Else
		cSeek := ( cX9Dom + cX9cDom )
		IF SX9->( dbSeek( cSeek , .F. ) )
			aAdd( aSx9CrossRef , { cX9Dom , cX9cDom , SX9->( Recno() ) , .F. } )
		Else
			aAdd( aSx9CrossRef , { cX9Dom , cX9cDom , 0 , .F. } )
		EndIF
		cSeek := ( cX9cDom + cX9Dom )
		IF SX9->( dbSeek( cSeek , .F. ) )
			aAdd( aSx9CrossRef , { cX9cDom , cX9Dom , SX9->( Recno() ) , .F. } )
		Else
			aAdd( aSx9CrossRef , { cX9cDom , cX9Dom , 0 , .F. } )
		EndIF	
	EndIF	

	SX9->( dbSetOrder( nSx9Order ) )
	SX9->( MsGoto( nSx9Recno ) )

End Sequence
	
Return( lCrossRef )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁdbExeWhile		ЁAutorЁMarinaldo de Jesus Ё Data Ё22/08/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁExecuta um While em um Data Base conforme Parametros        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlExecOk														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function dbExeWhile(	cAlias			,;	//Alias do Arquivo a ser Varrido
						uOrderSelect	,;	//Order para posicionamento do arquivo ( Numerico ou Expressao e.g.: "RA_FILIAL+RA_MAT" )
						uVarRet			,;	//Variavel de Retorno que sera incrementada pelo bloco
						bRetWhile		,;	//Bloco com a Expressao de Retorno
						uSeekKey		,;	//Expressao ou Bloco para Posicionamento Inicial
						uWhileCond		,;	//Expressao ou Bloco para Condicao While
						uSkipCond		,;	//Expressao ou Bloco para a Condicao Skip/Loop
						uExitWhile		,;	//Expressao ou Bloco para Exit no While
						lShowErr		,;	//Se deve Mostrar o Erro nos Testes das Expressoes
						lChkErr		 	 ;	//Se devera Verificar Erro nas Expressoes passadas
				  	)

Local aArea			:= GetArea()
Local aAreaAlias	:= {}
Local bSeekKey		:= { || dbGotop() }
Local bWhileCond	:= { || !Eof() }
Local bSkipCond		:= { || .F. }
Local bExitWhile	:= { || .F. }
Local cRetWhile		:= ValType( bRetWhile		)
Local cSeekKey		:= ValType( uSeekKey		)
Local cWhileCond	:= ValType( uWhileCond		)
Local cSkipCond		:= ValType( uSkipCond		)
Local cExitWhile	:= ValType( uExitWhile		)
Local cOrderSelect	:= ValType( uOrderSelect	)
Local cShowErr		:= ValType( lShowErr		)
Local cChkErr		:= ValType( lChkErr			)
Local nOrderSelect	:= 1
Local uExec			:= NIL
Local lExecOk		:= .T.
Local uSvVarRet		:= uVarRet

bRetWhile			:=	IF( ( cRetWhile == "B" ) , bRetWhile , { | uRetWhile | 0 } )

Begin Sequence

	cAlias		:= Upper( Alltrim( cAlias ) )
	aAreaAlias	:= ( cAlias )->( GetArea() )

	IF ( cSeekKey == "C" )
		bSeekKey := __ExecMacro( "{ || dbSeek('" + uSeekKey + "',.F.) } " )
	ElseIF ( cSeekKey == "B" )
		bSeekKey := uSeekKey
	EndIF

	IF ( cWhileCond == "C" )
		IF !Empty( uWhileCond )
			bWhileCond	:= __ExecMacro( "{ || !Eof() .and. " + uWhileCond + " } " )
		EndIF
	ElseIF ( cWhileCond == "B" )
		bWhileCond := uWhileCond
	EndIF

	IF ( cSkipCond == "C" )
		bSkipCond := __ExecMacro( "{ || " + uSkipCond + " } " )
	ElseIF  ( cSkipCond == "B" )
		bSkipCond := uSkipCond
	EndIF	
	
	IF ( cExitWhile == "C"  )
		bExitWhile	:= __ExecMacro( "{ || " + uExitWhile + " } " )
	ElseIF ( cExitWhile == "B"  )
		bExitWhile	:= uExitWhile
	EndIF	

	IF ( cShowErr <> "L" )
		lShowErr := .F.
	EndIF

	IF ( cChkErr <> "L" )
		lShowErr := .T.
	EndIF

	IF ( lChkErr )

		uExec		:= { || ( cAlias )->( Eval( bSeekKey ) ) }
		IF !( lExecOk := CheckExecForm( @uExec , lShowErr ) )
			Break
		EndIF
	
		uExec		:= { || ( cAlias )->( Eval( bWhileCond ) ) }
		IF !( lExecOk := CheckExecForm( @uExec , lShowErr ) )
			Break
		EndIF
	
		uExec		:= { || ( cAlias )->( Eval( bSkipCond ) ) }
		IF !( lExecOk := CheckExecForm( @uExec , lShowErr ) )
			Break
		EndIF
	
		uExec		:= { || ( cAlias )->( Eval( bExitWhile ) ) }
		IF !( lExecOk := CheckExecForm( @uExec , lShowErr ) )
			Break
		EndIF
	
		uSvVarRet	:= uVarRet
		uExec		:= { || ( cAlias )->( Eval( bRetWhile , @uVarRet ) ) }
		IF !( lExecOk := CheckExecForm( @uExec , lShowErr ) )
			uVarRet := uSvVarRet
			Break
		EndIF
		uVarRet := uSvVarRet

	EndIF
	
	IF ( cOrderSelect == "N" )
    	nOrderSelect := uOrderSelect
    ElseIF ( cOrderSelect == "C" )
    	nOrderSelect := Retorder( cAlias , uOrderSelect )
    EndIF
    ( cAlias )->( dbSetOrder( nOrderSelect ) )

	( cAlias )->( Eval( bSeekKey ) )
	While ( cAlias )->( Eval( bWhileCond ) )
		IF ( cAlias )->( Eval( bSkipCond ) )
			( cAlias )->( dbSkip() )
			Loop
		EndIF
		IF ( cAlias )->( Eval( bExitWhile ) )
			Exit
		EndIF
		( cAlias )->( Eval( bRetWhile , @uVarRet ) )
		( cAlias )->( dbSkip() )
	End While
	
End Sequence

IF !( lExecOk )
	RestArea( aAreaAlias )
	RestArea( aArea		 )
Else
	( aAreaAlias[1] )->( dbSetOrder( aAreaAlias[2] ) )
EndIF

Return( lExecOk )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGetNextRecno	ЁAutorЁMarinaldo de Jesus Ё Data Ё27/05/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁObtem o Proximo Recno                                       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                  	                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetNextRecno( cAlias , nNextRecno , nRecno , nOrder )

IF Empty( nNextRecno )
	nRecno := ( cAlias )->( Recno() )
Else
	nRecno := nNextRecno
EndIF
( cAlias )->( dbSkip() )
IF ( cAlias )->( Eof() )
	nNextRecno := NIL
Else
	nNextRecno := ( cAlias )->( Recno() )
EndIF

Return( GotoNextRecno( cAlias , nRecno , nOrder ) )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGotoNextRecno	ЁAutorЁMarinaldo de Jesus Ё Data Ё08/04/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁPosiciona no proximo Registro                               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                  	                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GotoNextRecno( cAlias , nNextRecno , nOrder )

Local lNextOk

DEFAULT nOrder := ( cAlias )->( IndexOrd() )

IF ( lNextOk := ( nNextRecno <> NIL ) )
	( cAlias )->( dbSetOrder( nOrder ) )
	( cAlias )->( dbGoto( nNextRecno ) )
EndIF

Return( lNextOk )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁDbChkUnique		ЁAutorЁMauricio Takakura  Ё Data Ё01/06/2005Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCheca se o novo valor nao corrompe a chave Unica            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                  	                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function DbChkUnique( cAlias, aHeader, uFields, uCntFields )

Local aFilter		:= {}
Local aTOPFields 
Local aUniqueKey	:= GetArrUniqe( cAlias )
Local aSvUniqueKey	:= aClone( aUniqueKey )
Local aCntsChkUnique

Local cFil
Local cRetChave		:= ""
Local cValue
Local cQuery
Local cSvQuery
Local cSvAlias		:= cAlias
Local cBagName
Local nSvOrder
Local cFieldFil
Local cCondIndex
Local cUniqueKey
Local cUniqueSeek

Local lNewIndex

Local nX
Local nCampo
Local nPosKey
Local nPosField
Local nUniqueOrder

DEFAULT aHeader := GdAllFields( cAlias ,, .F. )

Begin Sequence

	If !Empty( aUniqueKey )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁMontar a chave unica.                                         Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aCntsChkUnique		:= {}
		cUniqueSeek			:= ""
		For nX := 1 To Len( aUniqueKey )
			nPosField := aScan( uFields, { |x| x = aUniqueKey[ nX ] } )
			If nPosField == 0
				cRetChave := OemToAnsi( STR0013 ) // "Campo chave nao consta na lista de campos!"
				Break
			EndIf
			aAdd( aCntsChkUnique, uCntFields[ nPosField ] )
			
			If ValType( uCntFields[ nPosField ] ) == "D"
				cValue := DtoS( uCntFields[ nPosField ] )
			ElseIf ValType( uCntFields[ nPosField ] ) == "N"
			 	nCampo := GdFieldPos( aUniqueKey[ nX ], aHeader )
				cValue := Str( uCntFields[ nPosField ], aHeader[ nCampo, __AHEADER_WIDTH__], aHeader[ nCampo, __AHEADER_DEC__] )
			Else
				cValue := uCntFields[ nPosField ]
			EndIf
			cUniqueSeek += cValue
		Next nX

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё O Sistema utiliza como indice a chave do arquivos Sx2. Caso  Ё
		Ё na exista este indice o programa ira criar. Para ganhar per- Ё
		Ё formace crie o indice no AtuSx.                              Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cUniqueKey			:= X2Unique2Index( cAlias, aUniqueKey )
		nSvOrder			:= ( cAlias )->( IndexOrd() )
		nUniqueOrder		:= RetOrder( cAlias , cUniqueKey , .T. )
		If ( nUniqueOrder == 0 )
			cBagName		:= CriaTrab( "" , .F. )
			#IFNDEF TOP
				cBagName	+=  OrdBagExt()
			#ENDIF
			cCondIndex		:= ( cUniqueKey + " == '" + cUniqueSeek + "'" )
			( cAlias )->( IndRegua( cAlias , cBagName , cUniqueKey , NIL , cCondIndex , NIL , .F. ) )
			nUniqueOrder	:= ( cAlias )->( IndexOrd() )
			lNewIndex		:= .T.
		EndIf

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Desmembrar a filial da chave.                                Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		If ( FilExistField( cAlias , @cFieldFil ) .and. ( aScan( aUniqueKey , { |cField| ( cField == cFieldFil ) } ) == 1 ) )
			aUniqueKey		:= {}
			cUniqueSeek 	:= ""
			aEval( aSvUniqueKey , { |cField| If( cField <> cFieldFil , aAdd( aUniqueKey , cField ) , NIL ) } )

			For nX := 1 To Len( aUniqueKey )
				nPosField := aScan( uFields, { |x| x = aUniqueKey[ nX ] } )
				nCampo := GdFieldPos( aUniqueKey[ nX ], aHeader )
				If ValType( uCntFields[ nPosField ] ) == "D"
					cValue := DtoS( uCntFields[ nPosField ] )
				ElseIf ValType( uCntFields[ nPosField ] ) == "N"
					cValue := Str( uCntFields[ nPosField ], aHeader[ nCampo, __AHEADER_WIDTH__], aHeader[ nCampo, __AHEADER_DEC__] )
				Else
					cValue := uCntFields[ nPosField ] + Replicate(" ", aHeader[ nCampo, __AHEADER_WIDTH__] - Len( uCntFields[ nPosField ] ) )
				EndIf
				cUniqueSeek += cValue
			Next nX
			nPosField := aScan( uFields, { |x| x = cFieldFil } )
			cFil := uCntFields[ nPosField ]
		EndIf

		DbSelectArea( cAlias )
		( cAlias )->( DbSetOrder( nUniqueOrder ) )
		#IFDEF TOP
			aTOPFields := ( cAlias )->( dbStruct() )
			If Empty( aFilter )
				If !Empty( cFieldFil )
					aAdd( aFilter, { cFieldFil, "="	, cFil	, cFil } )
				EndIf
				For nX := 1 To Len( aUniqueKey )
					nPosField := aScan( uFields, { |x| x = aUniqueKey[ nX ] } )
					nCampo := GdFieldPos( aUniqueKey[ nX ], aHeader )
					
					If ValType( uCntFields[ nPosField ] ) == "D"
						cValue := DtoS( uCntFields[ nPosField ] )
					ElseIf ValType( uCntFields[ nPosField ] ) == "N"
						cValue := Str( uCntFields[ nPosField ], aHeader[ nCampo, __AHEADER_WIDTH__], aHeader[ nCampo, __AHEADER_DEC__] )
					Else
						cValue := uCntFields[ nPosField ] + Replicate(" ", aHeader[ nCampo, __AHEADER_WIDTH__] - Len( uCntFields[ nPosField ] ) )
					EndIf
					aAdd( aFilter, { aUniqueKey[ nX ], "="	, cValue , cValue } )
				Next nX 
			EndIf
			
			If !CreateQry( 	aTOPFields	 ,;			// Array com os campos para a Query
							@aFilter	 ,;			// Filtro para query
							cAlias		 ,;			// Alias da Query
							@cQuery	  	 ,;			// String com a Query Montada
							@cSvQuery     ;			// Copia da Query
					 	 )
				( cAlias )->( DbSeek( cFil + cUniqueSeek, .F.) )
			Else
				cAlias := "Q" + cAlias
			EndIf
		#ELSE
			DbSeek( cFil + cUniqueSeek, .F.)
		#ENDIF
		
		If ( cAlias )->( !Eof() )
			cRetChave	:= cFil + cUniqueSeek
		EndIf

 		cAlias := cSvAlias
		If ( nUniqueOrder <> nSvOrder )
			If !Empty( cBagName )
				( cAlias )->( RetIndex( cAlias ) )
				If File( cBagName )
					fErase( cBagName )
				EndIf
			EndIf
			( cAlias )->( dbSetOrder( nSvOrder ) )
		EndIf
    EndIf

End Sequence

Return( cRetChave )


Function GetTableName(cAlias, cCompany)
	Local cTempCompany:= cEmpAnt
	Local cRet
	Local lTroca
	Default cCompany:= cEmpAnt

	If (lTroca:= (cCompany != cEmpAnt))
		cTempCompany:= cEmpAnt
		cEmpAnt	:= cCompany
	EndIf
	
	cRet:= RetSqlName("RCL")
	              
	If lTroca
		cEmpAnt	:= cTempCompany
	EndIf
Return cRet

/*/{Protheus.doc} RHMSMM
Realiza a gravaГЦo, alteraГЦo e leitura do contИudo dos campos do tipo Memo virtuais gravado na tabela RDY.
Difere da MSMM por gravar a filial da tabela de origem do campo.
@author CМcero Alves
@since 28/09/2016
@version 1.0
@see http://tdn.totvs.com/x/HP1n 
/*/	
Function RHMSMM( cChave, nTam, nLin, cString, nOpc, nTabSize, lWrap, cAlias, cCpochave, cRealAlias, lSoInclui, cTabQry )
	
	Local nPos, nTexto
	Local cAliasOld 	:= Alias(), cFilRDY
	Local uRet      	:= " "
	Local lUsaSx8   	:= (cChave == NIL .Or. Empty(cChave))
	Local cLine     	:= ""
	Local lField    	:= .F.
	Local nLen1
	Local nLen2
	Local cSeq
	Local lGrv 			:= .F.
	Local nPos2
	Local nTamSeq
	Local cPrefixo
	Local nLenRDY
	
	Local nYP_TEXTO
	Local nYP_CHAVE
	Local nYP_FILIAL
	Local nYP_SEQ
		
	Local lTabRDY		:= .F. //Se estА utilizando a tabela RDY para a gravaГЦo dos campos Memo
	Local cTabOri		:= cAlias
	Local cFilTab		:= ""
	Local cFilBusca 	:= ""
	Local nCpoFil		:= 0
	Local aAreaDRY	:= {}
	
	DEFAULT cChave 		:= StrZero(0,6)
	DEFAULT	nLin 		:= 0
	DEFAULT cString 	:= ""
	DEFAULT nOpc 		:= 3
	DEFAULT cRealAlias 	:= "RDY"
	DEFAULT lSoInclui 	:= .F.
	DEFAULT cTabQry	:= ""
	
	If (lUsaSx8 .And. nOpc == 3)
		return (uRet)									// NЦo ler memo caso cChave estiver vazia
	EndIf
	
	cPrefixo := PrefixoCpo(cRealAlias)
	cFilRDY  := xFilial(cRealAlias)
	nTamSeq  := TamSx3(cPrefixo + "_SEQ")[1]
	
	If Empty(cTabOri)
		cTabOri	:= If(Alias() == "SX3", SX3->X3_ARQUIVO, If(Len(cAliasOld) < 4, cAliasOld, "" ))
	EndIf
	
	DbSelectArea("RDY")
	lTabRDY	:= cRealAlias == "RDY"
	
	If lTabRDY
		If Empty( cTabQry )
			
			aAreaRDY := GetArea()
			RDY->(dbSetOrder(1))	// Мndice 1 usa cFilRDY=RDY_FILIAL / Мndice 2 usa RDY_FILTAB (filial da tabela de origem)
			If cAliasOld $ "SX3|SX7|REPOSIT" .And. !lUsaSx8		// define alias a partir do campo caso a chamada venha de inicializador padrЦo ou gatilho			
				If dbSeek(cFilRDY + cChave)
					cTabOri := If(cTabOri != AliasCpo(RDY->RDY_CAMPO), AliasCpo(RDY->RDY_CAMPO), cTabOri)
				Else				
					dbSelectArea("SYP")
					If dbSeek(xFilial("SYP") + cChave)
						cTabOri := If(cTabOri != AliasCpo(SYP->YP_CAMPO), AliasCpo(SYP->YP_CAMPO), cTabOri)
					Else
						RestArea(aAreaRDY)
						Return (uRet)			// sair caso nЦo encontre na RDY nem SYP (memo deletado por alteraГЦo mas campo chave permaneceu preenchido na tabela de origem) 
					EndIf
				EndIf
			EndIf
			RestArea(aAreaRDY)
			cFilTab := xFilial(cTabOri, (cTabOri)->( &(PrefixoCpo(cTabOri) + "_FILIAL")))
		Else
			cFilTab := xFilial(cTabQry, (cTabQry)->( &(PrefixoCpo(cTabQry) + "_FILIAL")))
		EndIf
	EndIf
		
	Begin Sequence
	    
	    If nOpc == 3 // Ler Memo
	       
	       If nLin > 0 // Linha especficia
	          uRet := RHMSMM(cChave, nTam, 0, cString, nOpc, nTabSize, lWrap, cAlias, cCpochave, cRealAlias, ,cTabQry)
	          
	          // Atribui valores defaults
	          nTabSize := IF(ValType(nTabSize) == "N", nTabSize, nil)
	          lWrap := IF(ValType(lWrap) == "L", lWrap, nil)
	       
	          uRet := MemoLine(uRet, nTam, nLin, nTabSize, lWrap)
	
	          If !Empty(cAliasOld)
	          	dbSelectArea(cAliasOld)
	          EndIf
	          
	          Return uRet
	       
	       Endif
	    
	    Else
			//Se nЦo Possuir Chave e String Vazia Abandona
			IF(Empty(cChave) .AND. Empty( cString ) )
				Break
			EndIF
			//verifica se o campo existe na tabela
			If ( cCpoChave != NIL )
				cCpoChave := Trim(cCpoChave)
				IF ! ( lField := ((cAlias)->(FieldPos(cCpoChave)) > 0.00 ))
					Break
				EndIF
			EndIf
		EndIf
		
		DbSelectArea(cRealAlias)
		If lTabRDY
			AtuRDY(cChave, cFilTab, cFilRDY)
			DbSelectArea("RDY")
			DbSetOrder(2)
			DbSeek(cFilTab + cChave, .T.)
		Else
			DbSelectArea("SYP")
			DbSetOrder(1)
			DbSeek(cFilRDY + cChave, .T.)
		EndIf
			
		nYP_TEXTO 	:= FieldPos(cPrefixo + "_TEXTO")
		nYP_CHAVE 	:= FieldPos(cPrefixo + "_CHAVE")
		nYP_FILIAL 	:= FieldPos(cPrefixo + "_FILIAL")
		nYP_SEQ 	:= FieldPos(cPrefixo + "_SEQ")
		nLenRDY 	:= Len(FieldGet(nYP_TEXTO))
		
		If lTabRDY
			//-- A busca serА feita pela filial da tabela que contИm o campo memo
			//-- e nЦo pela filial da RDY
			cFilBusca 	:= cFilTab
			nCpoFil		:= FieldPos(cPrefixo + "_FILTAB")
		Else
			cFilBusca 	:= cFilRDY
			nCpoFil		:= nYP_FILIAL
		EndIf
					
		DEFAULT nTam	:= nLenRDY
	
		// Ler campo MEMO
		If nOpc == 3
	
			While ! Eof() .AND. ( cChave == FieldGet(nYP_CHAVE) ) .AND. ( cFilBusca == FieldGet(nCpoFil) )
								
				nPos := At("\13\10", Subs(FieldGet(nYP_TEXTO), 1, nTam + 6))
				
				If ( nPos == 0 )
					cLine := RTrim(Subs(FieldGet(nYP_TEXTO), 1, nTam))
					If ( nPos2 := At("\14\10", cLine) ) > 0
						cString += StrTran( cLine, "\14\10", Space(6) )
					Else
						cString += cLine
					EndIf
				Else
					cString += Subs(FieldGet(nYP_TEXTO), 1, nPos - 1) + CRLF
				EndIf
				DbSkip()
			End While
			
			uRet := cString
			
		ElseIf nOpc == 2
			
			// Excluir campo MEMO
			uRet := .F.
			While ! Eof() .And. ( cChave == FieldGet(nYP_CHAVE) ) .And. ( cFilBusca == FieldGet(nCpoFil) )
				RecLock(cRealAlias, .F., .T.)
				DbDelete()
				MsUnLock()
				uRet := .T.
				DbSkip()
			End While
			
		Else
			
			// Incluir/Alterar campo MEMO
			If ( lUsaSx8 ) .and. ( nOpc == 1 )
				cChave := GetSX8Num("SYP", "YP_CHAVE")
				aAreaRDY := GetArea()
				RDY->(dbSetOrder(1))
				While CodInRDY(cFilRDY, cChave)
					ConfirmSX8()
					cChave := GetSX8Num("SYP", "YP_CHAVE")
				EndDo
				RestArea(aAreaRDY)
			EndIf

			If ! lSoInclui  //default
				cSeq	:= Space( nTamSeq )
			Else 
				dbseek(cFilRDY + cChave + 'ZZZ', .T.)
				dbSkip(-1) //Posiciono na Зltima sequЙncia
				if(cChave == FieldGet(nYP_CHAVE) .And.  cFilBusca == FieldGet(nCpoFil))
					cSeq := FieldGet(nYP_SEQ)
				Else
					cSeq := Space(nTamSeq)
				endif
			EndIf
			
			cString := Trim(cString)
			If nTam >= nLenRDY .or. nTam > (nLenRDY - 6)
				nTam := nLenRDY - 6
			EndIf
			
			While ! Empty(cString)
		
				nTexto := At(CRLF, cString)
				If nTexto == nTam
					cLine := Subs(cString, 1, nTam+1)
				Else
					cLine := Subs(cString, 1, nTam)
				EndIf
				nTexto := At(CRLF, cLine)
		
				If nTexto > 0
		
					cLine := Subs(cLine, 1, nTexto - 1) + "\13\10"
					nTexto += 2
		
				Else
					If !Empty(cLine)
						nTexto := nTam+1
						nLen1 := Len(cLine)
						nLen2 := Len(Trim(cLine))
		
						//verifica se tem espaco no final da linha para colocar no inicio do proximo registro
						If nLen1 != nLen2
							cLine := Trim(cLine)
							nTexto -= (nLen1 - nLen2)
						EndIf
					Else
						cLine := Subs( cLine, 1, nTam-6 ) + '\14\10'
						nTexto += nTam + 1
					EndIf
				EndIf

				cString := Subs(cString, nTexto)
				cSeq := Soma1(cSeq, nTamSeq)
				lGrv := .T.

				RHGrvMemo(cFilRDY, cChave, cSeq, cLine, cCpoChave, cRealAlias, cFilTab)
		
			End While
		
			cSeq := IF(Empty(cSeq), Soma1(Space(nTamSeq), nTamSeq), cSeq)
		
			IF(lGrv)
				DbSelectArea(cAlias)
				RecLock( cAlias, .F. )
				Eval( FieldWBlock( cCpochave, Select(cAlias)), cChave)
				MsUnLock()
				FkCommit()
				DbSelectArea(cRealAlias)
				If ! lTabRDY
					DbSeek( cFilRDY + cChave + Soma1( cSeq, nTamSeq ), .T. )
				Else
					DbSeek( cFilTab + cChave + Soma1( cSeq, nTamSeq ), .T. )
				EndIf
			Else
				If ! lTabRDY
					DbSeek( cFilRDY + cChave, .T. )
				Else
					DbSeek( cFilTab + cChave, .T. )
				EndIF
			Endif
		
			While !Eof() .AND. ( FieldGet(nCpoFil) == cFilBusca ) .AND. ( FieldGet(nYP_CHAVE) == cChave )
				RecLock( cRealAlias, .F. )
				DbDelete()
				MsUnlock()
				DbSkip()
			End While
		
			uRet := cChave
			IF ( ( lUsaSx8 ) .AND. ( nOpc == 1 ) )
				ConfirmSX8()
			EndIF
		
		EndIF
	
	End Sequence

	If ! Empty(cAliasOld)  // GFP - 31/03/2014
		dbSelectArea(cAliasOld)
	EndIf

Return( uRet )

Static Function RHGrvMemo( cFilRDY, cChave, cSeq, cLine, cCpoChave, cRealAlias, cFilTab)
	
	Local nYP_CAMPO
	Local cPrefixo	:= PrefixoCpo(cRealAlias)
	Local lTabRDY	:= .F. //Se executou o compatibilizador 320 do GPE
	Local lNew		:= .F.
	
	DbSelectArea(cRealAlias)
	
	lTabRDY := cRealAlias == "RDY"
	
	If lTabRDY
		lNew := ! DbSeek( cFilTab + cChave + cSeq )
	Else
		lNew := ! DbSeek( cFilRDY + cChave + cSeq )
	EndIf 
	
	RecLock( cRealAlias, lNew )
		
		FieldPut(FieldPos(cPrefixo + "_FILIAL"), cFilRDY)
		FieldPut(FieldPos(cPrefixo + "_CHAVE" ), cChave)
		FieldPut(FieldPos(cPrefixo + "_SEQ"   ), cSeq)
		FieldPut(FieldPos(cPrefixo + "_TEXTO" ), cLine)
		
		If lTabRDY
			FieldPut(FieldPos(cPrefixo + "_FILTAB"), cFilTab)
		End
		
		IF (nYP_CAMPO := FieldPos(cPrefixo + "_CAMPO")) > 0
			FieldPut(nYP_CAMPO, cCpochave)
		EndIF
		
	(cRealAlias)->(MsUnlock())
	(cRealAlias)->(FkCommit())

Return( NIL )


/*/{Protheus.doc} AtuRDY
Atualiza o campo RDY_FILTAB para os registros jА gravados no banco
@author CМcero Alves 
@since 05/09/2016
@version 1.0
/*/
Static Function AtuRDY(cChave, cFilTab, cFilRDY)
	
	Local aArea		:= GetArea()
	
	Default cChave	:= ""
	Default cFilTab	:= ""
	Default cFilRDY	:= ""
	
	dbSelectArea("RDY")
	RDY->(dbSetOrder(2))
	RDY->(dbGoTop())
	
	If ! RDY->(dbSeek(cFilTab + cChave))
		
		RDY->(dbSetOrder(1))
		RDY->(dbGoTop())
		
		If ! RDY->(dbSeek( cFilRDY + cChave ))
			
			dbSelectArea("SYP")
			SYP->(dbSetOrder(1))
			SYP->(dbGoTop())
			
			dbSeek(cFilRDY + cChave)
			
			While ! SYP->(EOF()) .AND. cFilRDY == SYP->YP_FILIAL .AND. SYP->YP_CHAVE == cChave 
				Reclock("RDY", .T.)
					RDY->RDY_FILIAL := SYP->YP_FILIAL
					RDY->RDY_CHAVE  := SYP->YP_CHAVE
					RDY->RDY_TEXTO	:= SYP->YP_TEXTO
					RDY->RDY_SEQ	:= SYP->YP_SEQ
					RDY->RDY_CAMPO  := SYP->YP_CAMPO
					RDY->RDY_FILTAB := cFilTab
				RDY->(MsUnlock())
				
				SYP->(dbSkip())
			EndDo
			
			dbSelectArea("RDY")
			RDY->(dbSetOrder(2))
			RDY->(dbGoTop())
			RDY->(dbSeek(cFilTab + cChave))
		Else
			// Se jА existe o registro atualiza apenas o campo RDY_FILTAB
			While RDY->( !EOF() .AND. cFilRDY + cChave == RDY_FILIAL + RDY_CHAVE )
				
				Reclock("RDY", .F.)
					RDY->RDY_FILTAB := cFilTab
				RDY->(MsUnlock())
				
				RDY->(dbSkip())
			EndDo
		EndIf
	EndIf
	
	RestArea(aArea)
	
Return

/*/{Protheus.doc} RhCriaTrab
FunГЦo contendo os mИtodos do frame(os quais ainda s eencontram em validaГЦo) para criar tabela temporaria. 
O Objetivo И facilitar a modificaГЦo de metodos do frame em todos os fontes do RH, caso ocorram mudanГas
@author Oswaldo L. 
@since 05/03/2017
@version 1.0
/*/
function RhCriaTrab(cAliasTemp, aFields, aLstIndice)
Local oObjTmpTab := Nil
Local nCount1    := 0
Local nCount2    := 0 
Local nTam       := 0
Local cExpressao := ""

If !Empty(cAliasTemp) .And. Len(aFields) > 0 
	oObjTmpTab := FWTemporaryTable():New(cAliasTemp)
			
	oObjTmpTab:SetFields( aFields )
	
	If aLstIndice <> Nil
		For nCount1 := 1 to Len(aLstIndice)				
		
		    nTam := Len(aLstIndice[nCount1])
		    cExpressao := ""    
		    
		    For nCount2 := 1 to nTam
		    	If nCount2 > 1
		    		cExpressao += ','
		    	EndIf
		    	
		    	cExpressao += '"' + aLstIndice[nCount1][nCount2] + '"'
		    Next
		    
		    If !Empty(cExpressao)    
		    	cExpressao := "{" + cExpressao + "}"
		    	oObjTmpTab:AddIndex( AllTrim(STR(nCount1)), &(cExpressao) )
			EndIf
		Next
	EndIf
	oObjTmpTab:Create()
EndIf

return oObjTmpTab

/*/{Protheus.doc} CodInRDY
Busca na RDY pelo cСdigo para verificar se jА estА gravado - Substitui o dbSeek pois ***deve considerar os registros deletados***
@author CМcero Alves
@since 09/08/2019
@version 12.1.17
@param cFilRDY, Caractere, Filial da tabela RDY
@param cChave, Caractere, Chave buscada 
@return lRet, LСgico, .T. se encontrar o registro, .F. caso nЦo encontre
/*/
Static Function CodInRDY(cFilRDY, cChave)
	
	Local lRet := .F.
	Local cAliasRDY := GetNextAlias()
	
	BeginSQL Alias cAliasRDY
		
		SELECT RDY_SEQ
		FROM %Table:RDY%
		WHERE RDY_FILIAL = %Exp:cFilRDY% AND 
		RDY_CHAVE = %Exp:cChave%
		
	EndSQL
	
	If ! (cAliasRDY)->(EOF())
		lRet := .T.
	EndIf
	
	(cAliasRDY)->(dbCloseArea())
	
Return lRet
