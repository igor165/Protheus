#INCLUDE "GPEA160.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "HEADERGD.CH"
#INCLUDE "COMPILE.CH"

Static lFirst := .T.

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GPEA160   ³Autor³Marinaldo de Jesus       			 ³ Data ³18/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Cadastro de Roteiros de Calculo						 			       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    		   ³
ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.            			   ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Programador ³ Data   ³ FNC / Chamado  ³  Motivo da Alteracao                      ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Leandro Dr. ³29/11/12³M12RH01         ³Protheus 12 - Separacao de modelo 1 e 2.   ³
³            ³        ³          RQ2005³GPEA160 - Mod.1 / GPEA161 - Mod. 2         ³
³Mohanad Odeh³13/03/13³M12RH01         ³Alteracao na aba para preenchimento de     ³
³            ³        ³          RQ2002³dados para os Periodos Padroes.De enchoice ³
³            ³        ³                ³para Getdados                              ³
³Flavio C.   ³05/06/14³TPPCUQ          ³Permissao de alteração dos campos Orniario ³
³            ³        ³                ³Grupo de perguntas e Integra               ³
³Raquel Hager³09/09/14³TQLZZ8          ³Remocao de tratamento para Dt. Corte(RGA). ³
³Flavio C    ³27/07/15³TSWORN          ³Permitir alterar o campo RY_CONTAB 		   ³
³Mariana M.  ³12/08/15³TSURMD          ³Ajuste na tabela RGA para que possa ser gra³
³            ³        ³                ³vadas as informações corretamente, respei- ³
³            ³        ³                ³tando compartilhamento das tabelas SRY/SRM ³
³M. Silveira ³07/01/16³TTXXWE          ³Corrigidos os parametros xFilial da tabela ³
³            ³        ³                ³RGA para retornar o valor correto.         ³
³Ricardo D.  ³24/11/16³MRH-1814/TWJZQT ³Inclusao de validacao para compilacao dos  ³
³            ³        ³                ³roteiros em caso de inexistencia no RPO.   ³
³Renan Borges³22/02/17³MRH-6779/7501   ³Ajuste para gerar o repositório de formulas³
³            ³        ³                ³corretamente, quando for gerado a partir de³
³            ³        ³                ³uma rotina de cálculo. Além disso foi dispo³
³            ³        ³                ³nibilizado a opção de recompilar tudo na ro³
³            ³        ³                ³tina de Roteiros de cálculos, que só será  ³
³            ³        ³                ³possível a recompilação quando estiver ex- ³
³            ³        ³                ³clusivo o rpo de fórmulas.                 ³
³Paulo O.    ³08/08/17³                ³Alteração para o entrar no D-1             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/ 


/*
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÑÍÍÍÍ³±±
±±³Data Fonte Sustentação³ ChangeSet ³±±
±±³ÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ³±±  
±±³    27/05/2015        ³  304483   ³±± 
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÑÍÍÍÍÍ±±
*/

Function Gpea160()
Local aArea			:= GetArea()
Local aAreaSRY
Local aIndex		:= {}
Local cFiltra		:= ""
Local lOpeSoc		:= SuperGetMv("MV_OPESOC", NIL, .F.) 

Private lModPadrao	:= (MV_MODFOL == '1')
Private aRotina 	:= {}
Private aColsClone	:= {}
Private aIdErro		:= {}
Private cCadastro
Private cModAlias	:= ""
Private cFilSRV		:= xFilial("SRV")

Private lManutence := ( FunName() == "GPEA160M" )

If lModPadrao

	aRotina 	:= MenuDef()
	
	cModAlias	:= 'SRY'
	aAreaSRY 	:= (cModAlias)->( GetArea() )
	
	aAdd(aRotina, { STR0007 , "Gpea160Cpy" , 0 , 6, ,.F. } ) //"Copiar"	
	aAdd(aRotina, { STR0008, "Gpea160Leg", 0, 7, ,.F.} )     //"Legenda"
	aAdd(aRotina, { STR0056, "Gpea160Mnt", 0, 8, ,.F.} )     //"Ver Codigo"
	aAdd(aRotina, { STR0158, "GPCompAll", 0, 8, ,.F.} )     //"Recompilar Tudo"
	
	cCadastro   := OemToAnsi( STR0001 ) //"Cadastro de Roteiros de Calculo"
	
	lManutence := ( FunName() == "GPEA160M" )
	
	If lManutence
		aAdd(aRotina, { STR0047 , "Gpea160Ger" , 0 , 9 } ) //"Gerar Procedimentos"
	Else
		Private lImpForm := .T.
	EndIF    
	
	Private bFiltraBrw	:= { || NIL }
	
	Private lGpea160Cpy := .F.
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica o Modo de Acesso do SRY e SRM. Ambos Tem que ser Iguais       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF xRetModo( cModAlias , "SRM" )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se Deve Adicionar as Formulas Padroes                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF !GpeGerFrm()
			Break
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega os Roteiros Padroes											 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If lImpForm
			Gpea160RotGer( .T. )
		EndIf
		GPCallCmpAll(cModAlias,.T.,.F.,,.T.)

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Inicializa o filtro utilizando a funcao FilBrowse                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cFiltra		:= ChkRh( FunName() , cModAlias , "1" )
		If cPaisLoc == "BRA" .And. !lOpeSoc
			If !Empty(cFiltra)
				cFiltra	+= " .And. "
			EndIf
			cFiltra += "RY_TIPO != 'O'"
		EndIf
		bFiltraBrw 	:= { || FilBrowse( cModAlias , @aIndex , @cFiltra ) }
		Eval( bFiltraBrw )
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Chama a Funcao de Montagem do Browse                                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		mBrowse( 6 , 1 , 22 , 75 , cModAlias , , , , , , Gpea160Marks(),,,,,,,,,,,MV_MODFOL )
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Deleta o filtro utilizando a funcao FilBrowse                     	 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		EndFilBrw( cModAlias , aIndex )
	
	EndIF
		
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Restaura os Dados de Entrada 											 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	RestArea( aAreaSRY )
	RestArea( aArea )
Else
	//Se folha for modelo 2, deve utilizar o GPEA161.
	aRotina := FWLoadMenuDef( 'GPEA161' )
	GPEA161()
EndIf

Return( NIL )

/*                                	
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ MenuDef		³Autor³  Luiz Gustavo     ³ Data ³04/01/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Isola opcoes de menu para que as opcoes da rotina possam    ³
³          ³ser lidas pelas bibliotecas Framework da Versao 9.12 .      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA160                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³aRotina														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/   
Static Function MenuDef()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ ----------- Elementos contidos por dimensao ---------------  ³
	//³ 1. Nome a aparecer no cabecalho                              ³
	//³ 2. Nome da Rotina associada                                  ³
	//³ 3. Usado pela rotina                                         ³
	//³ 4. Tipo de Transa‡„o a ser efetuada                          ³
	//³    1 - Pesquisa e Posiciona em um Banco de Dados             ³
	//³    2 - Simplesmente Mostra os Campos                         ³
	//³    3 - Inclui registros no Bancos de Dados                   ³
	//³    4 - Altera o registro corrente                            ³
	//³    5 - Remove o registro corrente do Banco de Dados          ³
	//³    6 - Copiar                                                ³
	//³    7 - Legenda                                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Local aRotina :=     {;
							{ STR0002, "PesqBrw",    0, 1, NIL, .F.},;	//"Pesquisar"
							{ STR0003, "Gpea160Mnt", 0, 2},;			//"Visualizar"
							{ STR0004, "Gpea160Mnt", 0, 3},;			//"Incluir"
							{ STR0005, "Gpea160Mnt", 0, 4},;			//"Alterar"
							{ STR0006, "Gpea160Mnt", 0, 5};				//"Excluir"
						}
Return aRotina

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea160Mnt³ Autor ³Marinaldo de Jesus     ³ Data ³18/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea160Mnt( cAlias , nReg , nOpcX )							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cAlias = Alias do arquivo                                   ³
³          ³nReg   = Numero do registro                                 ³
³          ³nOpc   = Numero da opcao selecionada                        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA160()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea160Mnt( cAlias , nReg , nOpc )

Local aArea				:= GetArea()
Local aAreaRGA
Local aSvKeys			:= GetKeys()
Local aSvSrmCols		:= {}
Local aSRYCols			:= {}
Local aSvSRYCols		:= {}
Local aSryEnchoice		:= {}
Local aFields			:= {}
Local aAltera			:= {}
Local aNaoAltera		:= {}
Local aSrmRecnos		:= {}
Local aSrmChave			:= {}
Local aNotFields		:= {}
Local aSryVirtChoice	:= {}
Local aSrmVirtual		:= {}
Local aSrmVisual		:= {}
Local aAdvSize			:= {}
Local aInfoAdvSize		:= {}
Local aObjSize			:= {}
Local aObjCoords		:= {}
Local aInfo1AdvSize		:= {}
Local aObj1Coords		:= {}
Local aObj1Size			:= {}
Local aObj2Coords		:= {}
Local aObj2Size			:= {}
Local aMnemos			:= {}
Local aGhost			:= {}
Local aAlter			:= {}

Local bSet15			:= { || NIL }
Local bSet24			:= { || NIL }
Local bCancel			:= { || NIL }
Local bOK				:= { || NIL }
Local bRef				:= { || NIL }

Local cFilRCA			:= xFilial( "RCA" )

Local nOpcAlt			:= 0
Local nUsado			:= 0
Local nX				:= 0
Local nXs				:= 0
Local nH				:= 0
Local nPosSeq			:= 0
Local nTamSeq			:= GetSx3Cache( "RM_SEQ" , "X3_TAMANHO" )

Local oDlg				:= NIL
Local oSryEnchoice		:= NIL	
Local aCopyRot			:= {}

Local aFolders			:= Array (02)
Local aPages			:= Array (02)
Local aRGACols			:= {}
Local aSvRGACols		:= {}
Local aRGAVisual		:= {}
Local aRGAEnchoice		:= {}
Local aRGAVirtChoice	:= {}
Local aRGAFields		:= {}
Local cRGAKeySeek		:= "" 
Local lSRYModulo 	    := SRY->(ColumnPos("RY_MODULO")) > 0

Private oFolders		:= NIL
Private aGets
Private aTela
Private aHeader			:= {}
Private aCols			:= {}
Private cRotOrd			:= ""
Private lExecPerg		:= .T.
Private oSrmGetDados	:= NIL
Private oRGAGet			:=NIL
Private nAba				:= 0
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Define o Conteudo do aFolders								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aFolders[01] 		:= "&"+STR0001	// "Cadastro de Roteiros de Calculo"
aFolders[02] 		:= "&"+STR0134	// "Periodos Padroes"

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Define o Conteudo do aPages								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aPages[01]   		:= "&"+STR0001		// "Cadastro de Roteiros de Calculo"
aPages[02]			:= "&"+STR0134	// "Periodos Padroes"


Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Inicializa a Static em Gpea290AliasGet()					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	Gpea290AliasGet()

	If ( nOpc == 8 )	//Ver Codigo Fonte
		Gpea160SwCod( nReg , .F. )
		Break		
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verificar se ja possui um roteiro ordinario            	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cRotOrd		:= fGetRotOrdinar()

	If ( nOpc == 3  ) //Inclusao

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Quando For Inclusao Posiciona o SRY No Final do Arquivo	   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aRotSetOpc( cAlias , @nReg , nOpc , .T. )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Quando Inclusao Sempre Reinicializa n quando este ja tiver si³
		³ do Criado de forma a Manter o Sequenciamento das formulas cor³
		³ reto														   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If ( Type("n") != "U" )
			n := 1
		EndIf

	ElseIf ( lGpea160Cpy )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Altera opcao para Inclusao                                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nOpc := 3	//Inclusao

	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta os Dados para a Enchoice							   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/                                              
	aSRYCols	:= (cAlias)->( GdBuildCols( @aSryEnchoice , NIL , @aSryVirtChoice , @aSrmVisual , cAlias , { PrefixoCpo(cAlias)+"_FILIAL" } , NIL , cAlias, , , , , ,) )
	aSvSRYCols	:= aClone( aSRYCols )
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cria as Variaveis de Memoria e Carrega os Dados Conforme o ar³
	³ quivo														   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nXs := Len( aSryEnchoice )	
	For nX := 1 To nXs
			aAdd( aFields , aSRYEnchoice[ nX , 02 ] )
				SetMemVar( aSRYEnchoice[ nX , 02 ] , aSRYCols[ 1 , nX ]  , .T. )
	Next nX			
	// Monta os Dados para a Enchoice para segunda aba (RGA)
	aAreaRGA := GetArea()
	cRGAKeySeek := RY_FILIAL + RY_CALCULO + cModulo
	aRGACols	:= ("RGA")->(GdBuildCols( @aRGAEnchoice , NIL , @aRGAVirtChoice , @aRGAVisual , "RGA" , {"RGA_FILIAL"},	 NIL , "SRY", cRGAKeySeek, NIL,; //10
					 NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,;//30
					 NIL,NIL,"RGA_FILIAL+RGA_CALCUL+RGA_MODULO"))
	aSvRGACols	:= aClone(aRGACols)
	nXs := Len(aRGAEnchoice)
	For nX := 1 To nXs
			aAdd( aRGAFields , aRGAEnchoice[ nX , 02 ] )
			SetMemVar( aRGAEnchoice[ nX , 02 ] , aRGACols[ 1 , nX ]  , .T. )
	Next nX	
	RestArea(aAreaRGA)

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Define os Campos Editaveis na Enchoice Apenas na Inclusao( 3 )³
	³ou Alteracao(4)											   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If (;
			( nOpc == 3 );
			.or.;
			( nOpc == 4 );
		)

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Modelo Padrao => Reinicializa M->RY_CALCULO/M->RY_ORIGEM Qdo. Copia de Formula³
		³ Modelo Mexico => Reinicializa M->RGA_PROCES/M->RGA_CALCULO Qdo. Copia de Formula³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If ( lGpea160Cpy )
			SetMemVar( "RY_CALCULO" , Space( Len( GetMemVar( "RY_CALCULO" ) ) ) )
			SetMemVar( "RY_ORIGEM"  , CriaVar( "RY_ORIGEM" ) )
		EndIf
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Inclusao pelo Prog. Manutencao, sempre sera de Sistema.      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If ( lManutence ) .and. nOpc == 3
			M->RY_ORIGEM := "1"
		EndIf

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Inicializa os Mneumonicos Para uso em Formulas			   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		SetMnemonicos( cFilRCA , @aMnemos , .T. )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Inicializa as Verbas Para uso em Formulas			           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If FindFunction("fCarPD")
			fCarPD()
		EndIf

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Define os Campos Editaveis								   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nXs := Len( aSrmVisual )
		For nX := 1 To nXs
			aAdd( aNaoAltera , aSrmVisual[ nX ] )
		Next nX               
		If ( nOpc == 4 )                              
			aAdd( aNaoAltera , "RY_CALCULO" )
		EndIf

		aAdd( aAltera , "RY_INTEGRA" )
		aAdd( aAltera , "RY_PERGUNT" )
		aAdd( aAltera , "RY_ORDINAR" )
		aAdd( aAltera , "RY_CONTAB" )
		If lSRYModulo
			aAdd( aAltera , "RY_MODULO" )
		EndIf
		
		lAddFields := ( SRY->RY_ORIGEM == "1" .and. lManutence ) .or. ( SRY->RY_ORIGEM == "2" ) .Or. nOpc == 3
		If lAddFields
			nXs := Len( aFields )
			For nX := 1 To nXs
				If ( aScan( aNaoAltera , { |cNaoA| cNaoA == aFields[ nX ] } ) == 0 ) 
					aAdd( aAltera , aFields[ nX ] )
				EndIf
			Next nX
		EndIf
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta os Dados para a GetDados							   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aAdd( aNotFields , "RM_FILIAL"  )
	aAdd( aNotFields , "RM_CALCULO"	)
	aAdd( aNotFields , "RM_IF"		)
	aAdd( aNotFields , "RM_FALSE"	)
	aAdd( aNotFields , "RM_SUBSEQ"	)
	aAdd( aNotFields , "RM_CODFOR"  )

	If (;
		( nOpc == 3 );
		.or.;
		( nOpc == 4 );
	)	
		aAdd( aNotFields , "RM_VERSAO"	)
	EndIf
	aAdd( aNotFields , "RM_CHAVE"	)

	aGhost := {{'GHOSTCOL',"GdNumItem('GHOSTCOL',,1)",GHOSTCOLSIZE}}
	
	aCols := SRM->( GdMontaCols( @aHeader 		,;	// 01 -> Array com os Campos do Cabecalho da GetDados
								 @nUsado 		,;	// 02 -> Numero de Campos em Uso
								 @aSrmVirtual 	,;	// 03 -> [@]Array com os Campos Virtuais
								 @aSrmVisual 	,;	// 04 -> [@]Array com os Campos Visuais
								 NIL			,;	// 05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
								 aNotFields 	,;	// 06 -> Opcional, Campos que nao Deverao constar no aHeader
								 @aSrmRecnos 	,;	// 07 -> [@]Array unidimensional contendo os Recnos
								 cAlias			,;	// 08 -> Alias do Arquivo Pai
								 NIL			,;	// 09 -> Chave para o Posicionamento no Alias Filho
								 NIL			,;	// 10 -> Bloco para condicao de Loop While
								 NIL			,;	// 11 -> Bloco para Skip no Loop While
								 NIL			,;	// 12 -> Se Havera o Elemento de Delecao no aCols 
								 NIL			,;	// 13 -> Se cria variaveis Publicas
								 NIL			,;	// 14 -> Se Sera considerado o Inicializador Padrao
								 NIL			,;	// 15 -> Lado para o inicializador padrao
								 NIL			,;	// 16 -> Opcional, Carregar Todos os Campos
								 NIL			,;	// 17 -> Opcional, Nao Carregar os Campos Virtuais
								 NIL			,;	// 18 -> Opcional, Utilizacao de Query para Selecao de Dados
								 NIL			,;	// 19 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP ) - utilizado com o parametro 10
								 NIL			,;	// 20 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP ) - utilizado com o parametro 11
								 aGhost			,;	// 21 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
								 NIL			,;	// 22 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
								 NIL			,;	// 23 -> Verifica se Deve Checar se o campo eh usado
								 NIL			,;	// 24 -> Verifica se Deve Checar o nivel do usuario
								 NIL			,;	// 25 -> Verifica se Deve Carregar o Elemento Vazio no aCols
								 NIL			,;	// 26 -> [@]Array que contera as chaves conforme recnos
								 NIL			,;	// 27 -> [@]Se devera efetuar o Lock dos Registros
								 NIL			,;	// 28 -> [@]Se devera obter a Exclusividade nas chaves dos registros
						         NIL			,;	// 29 -> Numero maximo de Locks a ser efetuado
								 .T.			 ;	// 30 -> Utiliza Numeracao na GhostCol								 
							     ) )

	If Empty(aColsClone)
		aColsClone := aCols
	EndIf

	For nH := 1 To Len(aHeader)
		If  ( aScan( aSrmVirtual    	, { |cNaoA| cNaoA == aHeader[nH, 2] } ) == 0 )
			aAdd( aAlter , aHeader[nH, 2] )
		EndIf			   
	Next nH   

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Verifica se o Campo de Roteiro esta ou nao Habilitado e Modifi³
	³ca Sequencia com StrZero()									   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nPosSeq	  := GdFieldPos( "RM_SEQ" )
	aEval( @aCols , { |x| ;
					 		x[ nPosSeq	 ] := StrZero( Val( x[ nPosSeq	 ] ) , nTamSeq );
					 };
		  )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Para nao mostrar ao usuario na getdados o campo RM_CHAVE foi  ³
	³criado este array para utilizar na gravacao                   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	For nX := 1 To Len( aSrmRecnos )
		SRM->( DbGoTo( aSrmRecnos[ nX ] ) )
		aAdd( aSrmChave, SRM->RM_CHAVE ) 
	Next nX

	If !( lGpea160Cpy )
		aSvSrmCols := aClone( aCols )
	EndIf	

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para o Botao Confirma           			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bSet15		:= { || lExecPerg := .F. , ;
							IF(;
									( nOpc == 3 );
									.or.;
									( nOpc == 4 );
									.or.;
									( nOpc == 5 ),;
									IF(;
											EnchoTudOk( oSryEnchoice );
											.and.;
											Gpea160TudOk(oSrmGetDados);
											.and.;
											G160RGATOK();
											.and.;
											( nOpcAlt := 1 , Eval( bGpea160GvTudOk ) );
											,;
											(;
												nOpcAlt := 1,;
												GetKeys(),;
												oDlg:End(),;
												.T.;
											),;
											( lExecPerg := .T., nOpcAlt := 0 , .F. );
										 ),;
										( nOpcAlt := 0 , .F. ); 
								);	
					 }
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para a Gravacao                 			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bGpea160GvTudOk := { || Gpea160GvTudOk(	@nOpcAlt		,;
											nOpc			,;
											@nReg			,;
											aSRYCols		,;
											aSvSRYCols		,;
											aSryEnchoice	,;
											aSryVirtChoice 	,;
											aHeader			,;
											aCols			,;
											aSrmVirtual		,;
											@aSrmRecnos		,;
											nUsado			,;
											aSvSrmCols		,;
											cAlias			,;
											aSrmChave		,;
											aRGACols		,;
											aSvRGACols		,;
											aRGAEnchoice	,;
											aRGAVirtChoice	;
							  			  );
						}

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para o Botao Cancela            			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bSet24		:= { || ( lExecPerg := .F., nOpcAlt := 0 , GetKeys() , oDlg:End() ) }

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta as Dimensoes dos Objetos         					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aAdvSize		:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 1 , 1}
	aAdd( aObjCoords , { 000 , 000 , .T. , .T., .T.  } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

	aAdvSize		:= MsAdvSize(.T.)
	aAdvSize[4]		-=	43 // ALTURA
	aAdvSize[3]		-=	4 // Largura

	aInfo1AdvSize	:= { aAdvSize[1] , 1 , aAdvSize[3] , aAdvSize[4] , 1 , 1 }
	aAdd( aObj1Coords , { 000 , 110 , .T. , .F. } )
	aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
	
	aObj1Size 		:= MsObjSize( aInfo1AdvSize , aObj1Coords )
	
	aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )	
	aObj2Size 		:= MsObjSize( aInfo1AdvSize , aObj2Coords )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta o Dialogo Principal para a Manutencao das Formulas	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nOpcAlt := 0
	DEFINE MSDIALOG oDlg TITLE OemToAnsi( cCadastro ) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() PIXEL

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega o Objeto Folder               					   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		oFolders := TFolder():New(	aObjSize[ 1 , 1 ]		,;
									aObjSize[ 1 , 2 ]		,;
									aFolders				,;
									aPages					,;
									oDlg					,;
									NIL						,;
									NIL						,;
									NIL						,;
									.T.						,;
									.F.						,;
									aObjSize[ 1 , 3 ]		,;
									aObjSize[ 1 , 4 ]		 ;
								 )
		oFolders:bChange := { ||  ,If( oFolders:nOption == 1, nAba := 1, nAba := 2) } // Controle sobre qual aba está ativa

		oSryEnchoice	:= MsmGet():New( cAlias , nReg , nOpc , NIL , NIL , NIL , aFields , aObj1Size[1] , aAltera , NIL , NIL , NIL , , oFolders:aDialogs[01] , .F.,,,,,,,,,,AllTrim(MV_MODFOL))

		oRGAGet:=	MsNewGetDados():New(aObj2Size[1,1],; 						// 1-Top
										  aObj2Size[1,2],; 						// 2-nLelft
										  aObj2Size[1,3],;						// 3-nBottom	
										  aObj2Size[1,4],;						// 4-nRright
										  If(nOpc != 2 .and. nOpc != 5, GD_INSERT+GD_UPDATE+GD_DELETE,0),;	// 5-controle do que podera ser realizado na GetDado
										  "G160RGALOK",;							// 6-funcao para validar a edicao da linha - ulinhaOK
										  "G160RGATOK",;							// 7-funcao para validar todos os registros da GetDados -uTudoOK
										  "",;										// 8-cIniCPOS
										  aRGAFields,;							// 9-aAlter
										  0,;										//10-nFreeze
										  99999,;									//11-nMax
										  NIL,;									//12-cFieldOk
										  NIL,;									//13-usuperdel
										  NIL,;									//14-bloco com funcao para validar registros deletados
										  oFolders:aDialogs[02],;				//15-Objeto de dialogo
										  @aRGAEnchoice,;							//16-Vetor com aHeader
										  @aRGACols;								//17-Vetor com colunas 							  
										  )

		oSrmGetDados	:= MsGetDados():New(aObj1Size[2,1],aObj1Size[2,2],aObj1Size[2,3],aObj1Size[2,4],nOpc,"Gpea160LinOk","Gpea160TudOk","+RM_SEQ",.T.,aAlter,NIL,NIL,99999,,,,,oFolders:aDialogs[01],,AllTrim(MV_MODFOL))

		// Foi inserido esse tratamento para a inclusão, pois 
		// o controle de sequenciais esta no objeto da Getdados e 
		// sempre inicia em 0. Como tratamos para iniciar com > 0
		// inserido essa carga.
		If nOpc == 3
			aCols[1, nPosSeq] := StrZero( 1, nTamSeq )
		EndIf

		bCancel		:= { || oDlg:End() }
		bOK			:= bGpea160GvTudOk 
		bCopy		:= { || aCopyRot := Gpea160Copy() }
		bPaste		:= { || Gpea160Paste( aCopyRot ) }
		bInsert		:= { || Gpea160Insert(), oSrmGetDados:oBrowse:SetFocus(), oSrmGetDados:oBrowse:Refresh() }
		bSet24		:= { || ( lEnd	:= Eval(bCancel) ) }
		bRef		:= { || fLocaliza("", "SRM", {"RM_FORMULA" } ) }
		bFind       := { || fFindCF( aCols, aHeader ) }

		aButtons	:=	{;
						{"COPY"  ,{||Eval( bCopy )} ,STR0036,STR0036},;	//"Copiar"
						{"PASTE" ,{||Eval( bPaste )}  ,STR0037,STR0037},;	//"Colar"
						{"REF" ,{||Eval( bRef )}  ,STR0083,STR0083} ;	//"Localizar Referencia Cruzada"
					}

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, bSet15 , bSet24 , Nil , aButtons ) CENTERED

End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Restaura os Dados de Entrada								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
lGpea160Cpy := .F.
RestKeys( aSvKeys )
RestArea( aArea )

Return( nOpcAlt )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Gpea160Insert³ Autor ³ Equipe RH       	 ³ Data ³22/02/2013  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³                                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEA160 													               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/

Function Gpea160Insert()

Local nNumRec := n
Local nTotRec := Len(aCols)
Local nIndex  := 0
Local nCampos := 0
Local cIndice := StrZero(1,TamSx3('RM_SEQ')[1])
Local nPosSeq := Ascan(aHeader,{|x| Alltrim(x[2])== 'RM_SEQ'})
Local aTmpAcols:= {}   
Local nQtCampos := 0 
Local nI		:= 0
Local nPosDescPD:= GdFieldPos("RM_DESCPD")
Local nPosCodFor:= GdFieldPos("RM_DESCFOR")

If Gpea160LinOk(oSrmGetDados:oBrowse)
	
	Aadd( aCols, Array( Len(aCols[1]) ) )

	aEval(aCols,{|x,nI| aCols[nI][nPosSeq]:=cIndice,cIndice:=Soma1(cIndice)  } )
	nQtCampos := Len(aCols[1])
	For nIndex := nTotRec TO nNumRec STEP -1
		For nCampos:=2 To nQtCampos
			aCols[nIndex+1][nCampos]	:=	aCols[nIndex][nCampos]
		Next nCampos
	Next nIndex
		
	nCampos:=2
	aEval(aCols[nNumRec],{||if(ValType(aCols[nNumRec][nCampos])=="C",aCols[nNumRec][nCampos]:=Space(aHeader[nCampos][4]),aCols[nNumRec][nCampos]:=0),++nCampos},2,Len(aHeader)-1)
	
	//start nos inicializadores padrao e os inclui no aCols
	aTmpAcols 	:= gdRmkAcols( aHeader )
	nNumRec		:= oSrmGetDados:oBrowse:nAt
	aTmpAcols[1,nPosDescPD] := ""
	aTmpAcols[1,nPosCodFor] := ""	

	For nI:= 1 To nQtCampos
		If !Empty(aTmpAcols[1,nI])
			aCols[nNumRec, nI] := aTmpAcols[1,nI]
		EndIf		
	Next nI                                       

EndIf

Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea160LinOk³Autor³Marinaldo de Jesus     ³ Data ³18/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea160LinOk( oBrowse )									    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA160()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea160LinOk( oBrowse , lNotTudoOk, lTudOk )

Local cSeq		:= ""
Local cHab		:= ""
Local lLinOk	:= .T.
Local nPosSeq	:= GdFieldPos("RM_SEQ")
Local nPosCodFor:= GdFieldPos("RM_FORMULA")
Local nPosHab	:= GdFieldPos("RM_HABILIT")
Local nX		:= 0
Local nAch		:= 0
Local nLenCols	:= 0

DEFAULT lTudOk	:= .F.

Begin Sequence
                    
	If !aCols[ n , Len( aCols[ n ] ) ]
		nLenCols := Len( aCols )
		For nX := 1 To nLenCols
			IF aCols[ n , nPosSeq ] == aCols[ nX , nPosSeq ] .and.;
				!aCols[ nX , Len( aCols[ nX ] ) ] .and. n # nX
				MsgAlert( OemToAnsi( STR0015 ) , OemToAnsi( STR0014 ) ) // "Sequencia ja cadastrada."#"Atencao"
				lLinOk := .F.
				Break
			EndIf
		Next nX
		If ( Val( aCols[ n , nPosSeq ] ) ==  0 )
			MsgAlert( OemToAnsi( STR0016 ) , OemToAnsi( STR0014 ) ) // "Sequencia deve ser preenchida."#"Atencao"
			lLinOk := .F.
			Break
		EndIf

		If Empty( aCols[ n , nPosHab ] )
			MsgAlert( OemToAnsi( STR0027 ) , OemToAnsi( STR0014 ) ) //"Faltou Definir se o Roteiro Esta ou Nao Habilitado."#"Atencao"
			lLinOk := .F.
			Break
		EndIf

		If Empty( aCols[ n , nPosCodFor ] )
			MsgAlert( OemToAnsi( STR0144 ) , OemToAnsi( STR0014 ) ) //"Fórmula deve ser preenchida."#"Atencao"
			lLinOk := .F.
			Break
		EndIf		

	ElseIF ( ( Val( aCols[ n , nPosSeq ] ) % 10 == 0 ) .and. ( Val( aCols[ n , nPosSeq ] ) != 0 ) )
		If !( lManutence )
			aCols[ n , Len( aCols[ n ] ) ] := .F.
			MsgAlert( OemToAnsi( STR0017 ) ) // "Roteiro Padrao do Sistema, nao pode ser Excluido."
			lLinOk := .F.
			Break
		EndIf
	EndIf

	DEFAULT lNotTudoOk := .T.
	If ( lNotTudoOk )
	
	   	cSeq := aCols[ n , nPosSeq ]
	    // Habilitar / Desabilitar todas as Sequencias alterada.
	   	cHab := aCols[ n , nPosHab ]
		nAch :=	aScan( aCols , { |x| x[ nPosSeq ] == cSeq } )
		For nX := nAch To nLenCols
			If ( cSeq != aCols[ nX , nPosSeq ] )
				Exit 
			EndIf
			aCols[ nX  , nPosHab ] := cHab
		Next nX

		// Coloca Sequencia do novo item em ordem
		aSort( aCols , NIL , NIL , { |x,y| x[ nPosSeq ] < y[ nPosSeq ] } )
		n := aScan( aCols , { |x| x[nPosSeq]  == cSeq } )
		oBrowse:nAt := Max( n , 1 )
		oBrowse:Refresh()

	EndIf           
		
End Sequence

Return( lLinOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea160TudOk³Autor³Marinaldo de Jesus     ³ Data ³18/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea160TudOk( oBrowse )									    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA160()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea160TudOk(oBrowse)

Local lTudoOk	:= .T.

Local nLoop
Local nLoops

Begin Sequence

	nLoops := Len( aCols )
	For nLoop := 1 To nLoops
		n := nLoop
		If !( lTudoOk := Gpea160LinOk( oBrowse , .F., .T. ) )
			Break
		EndIf
	Next nLoop

End Sequence

Return( lTudoOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea160Marks³Autor³Marinaldo de Jesus     ³ Data ³18/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea160Marks()											    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA160()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpea160Marks()

Local aMarks := {}

aMarks	:=	{	                                    	 	 ;
				{ "SRY->RY_ORIGEM=='2'" , "BR_VERDE"	}	,;
				{ "SRY->RY_ORIGEM=='1'" , "BR_AZUL"		}	 ;
			 }

Return( aClone( aMarks ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea160Leg   ³Autor³Marinaldo de Jesus    ³ Data ³18/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea160Leg()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA160()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea160Leg()

Local aLegenda	:= {}
Local aSvKeys	:= GetKeys()

aLegenda := {;
				{ "BR_AZUL"  , OemToAnsi( STR0009 ) } ,; //"Roteiro Definido Pelo Sistema"
				{ "BR_VERDE" , OemToAnsi( STR0010 ) }  ; //"Roteiro Definido Pelo Usuario"
			}

BrwLegenda(	cCadastro ,	STR0011 , aLegenda )			 //"Legenda do Cadastro de Roteiros"

RestKeys( aSvKeys )

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea160SwCod ³Autor³Marinaldo de Jesus    ³ Data ³14/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Mostra Codigo Fonte do Roteiro                              ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA160()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpea160SwCod( nReg , lMsgNoYes, lSimula )

Local aSvKeys		:= GetKeys()
Local aAdvSize		:= MsAdvSize( .T. , .F. )
Local aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 0 , 0 }
Local aObjCoords	:= { { 000 , 095 , .T. , .F. } , { 000 , 000 , .T. , .T. } }
Local aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )
Local aSource		:= {}
Local aRotErr		:= {}
Local aListbox		:= {}

Local bSet15		:= { || RestKeys() , oDlg:End() }
Local bSet24		:= { || RestKeys() , oDlg:End() }
Local bDialogInit	:= { || ( AlignObject( oDlg , { oGroup , oLbxSource } , 1 , 2 , { 40 } ) , EnchoiceBar( oDlg , bSet15 , bSet24 ) ) }

Local cPrg
Local cMsgInfo

Local lCompileOk	:= .T.

Local nHandle
Local nOpenOk
Local nLoop
Local nLoops

Local oGroup
Local oLbxSource
Local oFont
Local oDlg

Local oRpoForm

DEFAULT lMsgNoYes := .T.
DEFAULT lSimula := .F.

CursorWait()

Begin Sequence

	SRY->( MsGoto( nReg ) )
	IF SRY->( Eof() )
		Break
	EndIf

	cPrg := ( SRY->( RotGetFunc( RY_FILIAL , RY_CALCULO, RY_ORIGEM ) ) + ".PRG" )
	cPrg := Lower( GetRpoForm( .F. , .T. ) + cPrg )
	If (;
			( SRY->RY_RECOMP <> "2" );
			.or.;
			!File( cPrg, 1 );
			.or.;
			lSimula;
		)
		If !SRY->( RecLock( "SRY" ) )
			Break
		EndIf
		SRY->RY_RECOMP := "1"
		SRY->( MsUnLock() )
		MsAguarde( { || SRY->( GetFunRot( RY_FILIAL , RY_CALCULO , .T. , NIL , .F. , @oRpoForm,,,, lSimula) ) } , OemToAnsi( STR0048 ) )	//"Compilando Novo(s) Roteiro(s)..."
		lCompileOk := !ErrorInRot()
		If lSimula
			SRY->(RecLock( "SRY"))
			SRY->RY_RECOMP := "2"
			SRY->( MsUnLock() )			
		EndIf			
		If !( lCompileOk )
			If ( ValType( oRpoForm ) == "O" )
				Gpea160SwErr( cPrg , oRpoForm:ErrLine , oRpoForm:ErrCol , oRpoForm:ErrStr )
			Else
				aRotErr 	:= RotGetErr()
				cLogErro 	:= ""
				For nLoop := 1 To Len( aRotErr )
					cLogErro += aRotErr[nLoop] + CRLF
				Next nY
				MsgInfo( cLogErro, STR0014 )	// Log ### "Atencao"
			EndIf
			Break
		EndIf
		If lSimula
			Return lCompileOk
		EndIf	
		If nAba == 2 .OR. (lMsgNoYes .and. !MsgNoYes(STR0049)) //"Deseja Consultar o Codigo Compilado?"
			Break
		EndIf		
	EndIf

	CursorWait()

	If !File( cPrg, 1 )
		cMsgInfo := STR0050	//"Nao foi possivel encontrar o arquivo:"
		cMsgInfo += CRLF
		cMsgInfo += cPrg
		cMsgInfo += CRLF
		Break
	EndIf

	If ( ( nHandle := fOpen( cPrg,,1 ) ) < 0 )
		nOpenOk := 0
		While (;
				!( fError() == 0 );
				.and.;
				( ++nOpenOk <= 50 );
			  )
			Sleep( 1000 )
			If ( ( nHandle := fOpen( cPrg,,1 ) ) > 0 )
				Exit
			EndIf
		End While
	EndIf

	If ( nHandle < 0 )
		cMsgInfo := STR0051 //"Nao foi possivel abrir o arquivo:"
		cMsgInfo += CRLF
		cMsgInfo += cPrg
		cMsgInfo += CRLF
		Break
	EndIf
	fClose( nHandle )

	aSource := FileSrvToArr( cPrg, 1 )
	If ( Empty( aSource ) )
		cMsgInfo := STR0066 //"O programa não contém dados a serem apresentados"
		cMsgInfo += CRLF
		cMsgInfo += cPrg
		cMsgInfo += CRLF
		Break
	EndIf

	nLoops	:= Len( aSource )
	For nLoop := 1 To nLoops
		aAdd( aListbox , { nLoop , aSource[ nLoop ] } )
	Next nLoop

	DEFINE FONT oFont NAME "Courier New" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE cCadastro From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() STYLE DS_MODALFRAME STATUS PIXEL 
	
		@ aObjSize[1,1] , aObjSize[1,2] GROUP oGroup TO aObjSize[1,3],aObjSize[1,4] LABEL OemToAnsi( STR0052 ) OF oDlg PIXEL						//"Programa:"
		oGroup:oFont:= oFont

		@ aObjSize[1,1] + 10 , aObjSize[1,2] + 5	SAY OemToAnsi( cPrg )	SIZE 500,10 OF oGroup PIXEL FONT oFont
	
		oLbxSource				:= TWBrowse():New( aObjSize[2,1],aObjSize[2,2],aObjSize[2,4],aObjSize[2,3],NIL,{ OemToAnsi( STR0054 ) , OemtoAnsi( STR0052 ) },NIL,oDlg,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,.F.,NIL,.T.,NIL,.F.,NIL,NIL,NIL)
		oLbxSource:SetArray( aListbox )
		oLbxSource:bLine 		:= { || LineLstBox( oLbxSource , .F. ) }
		oLbxSource:bLdblClick	:= { || Gpea160EdSource( oLbxSource , cCadastro ) }
	
	ACTIVATE MSDIALOG oDlg ON INIT Eval( bDialogInit ) CENTERED
	RestKeys( aSvKeys , .T. )

End Sequence

SRY->( MsGoto( nReg ) )

If !Empty( cMsgInfo )
	lCompileOk := .F.
	MsgInfo( cMsgInfo, STR0014 )	// Log ### "Atencao"
EndIf

CursorArrow()

Return( lCompileOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea160SwErr ³Autor³Marinaldo de Jesus    ³ Data ³10/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Mostra o Erro de Compilacao para o Usuario                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA290()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpea160SwErr( cPrg , nLine , nCol , cErrStr )

Local aSource		:= FileSrvToArr( cPrg, 1 )

Local aSvKeys
Local aAdvSize
Local aInfoAdvSize
Local aObjCoords
Local aObjSize
Local aListbox
Local aOkNo

Local bSet15
Local bSet24
Local bDialogInit

Local cMsgInfo
Local cStrErr
Local cString
Local cNumCol
Local cMulCol

Local nLoop
Local nLoops

Local oLbxSource
Local oSource
Local oLine
Local oCol
Local oExpr
Local oNumCol
Local oMulCol
Local oErrStr
Local oErrLine
Local oGroup1
Local oGroup2
Local oGroup3
Local oGroup4
Local oFont
Local oDlg
Local oPanel

Begin Sequence

	IF Empty( aSource )
		cMsgInfo := STR0051 //"Nao foi possivel abrir o arquivo:"
		cMsgInfo += CRLF
		cMsgInfo += cPrg
		cMsgInfo += CRLF
		Break
	EndIf

	aListbox	:= {}
	nLoops		:= Len( aSource )
	For nLoop := 1 To nLoops
		aAdd( aListbox , { ( nLoop <> nLine ) , nLoop , aSource[ nLoop ] } )
	Next nLoop

	If (;
			( nLine > 0 );
			.and.;
			( nLine <= nLoops );
		)
		cString	:= aSource[ nLine ]
		If ( nCol > 0 )
			nCol 	:= Min( nCol , Len( cString ) )
			cStrErr	:= SubStr( cString , nCol )
		Else
			cStrErr	:= cString
		EndIf
	Else
		cStrErr		:= ""
		cString		:= ""
	EndIf

	cNumCol	:= GetStrSeq( cString	, .T. )
	cMulCol := GetStrSeq( cNumCol	, .F. )

	aSvKeys			:= GetKeys()
	aAdvSize		:= MsAdvSize( .T. , .F. )
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 0 , 0 }
	aObjCoords		:= { { 000 , 27 , .T. , .F. } , { 000 , 27 , .T. , .F. } , { 000 , 15 , .T. , .F. } , { 000 , 15 , .T. , .F. } , { 000 , 000 , .T. , .T. } }
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )
	
	aObjSize[1,1] -= 10
	aObjSize[2,1] -= 10
	aObjSize[3,1] -= 10
	aObjSize[4,1] -= 10

	aObjSize[1,3] -= 10
	aObjSize[2,3] -= 10
	aObjSize[3,3] -= 10
	aObjSize[4,3] -= 10

	aOkNo			:= Array( 02 )
	aOkNo[1]		:= LoadBitmap( GetResources() , "BR_VERDE"		)
	aOkNo[2]		:= LoadBitmap( GetResources() , "BR_VERMELHO"	)

	bSet15			:= { || RestKeys() , oDlg:End() } 
	bSet24			:= { || RestKeys() , oDlg:End() }
	bDialogInit		:= { || ( AlignObject( oDlg , { oPanel , oLbxSource } , 1 , 0 , { 167 } ) , EnchoiceBar( oDlg , bSet15 , bSet24 ) ) }

	DEFINE FONT oFont NAME "Courier New" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE cCadastro + OemToAnsi( " - " + cPrg ) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() STYLE DS_MODALFRAME STATUS PIXEL 

		@ 000,000 MSPANEL oPanel OF oDlg

		@ aObjSize[1,1] , aObjSize[1,2] GROUP oGroup1 TO aObjSize[1,3],aObjSize[1,4] LABEL OemToAnsi(STR0067) OF oPanel PIXEL										//"Erro de Compilação"
		oGroup1:oFont:= oFont

		@ aObjSize[1,1] + 06 , aObjSize[1,2] + 5	SAY oSource VAR OemToAnsi( STR0052 + " " + cPrg ) 						SIZE 500,10	OF oGroup1 PIXEL FONT oFont	//"Programa:	"
		@ aObjSize[1,1] + 12 , aObjSize[1,2] + 5	SAY oLine	VAR OemToAnsi( STR0054 + " " + AllTrim( Str( nLine ) ) )	SIZE 500,10	OF oGroup1 PIXEL FONT oFont	//"Linha:		"
		@ aObjSize[1,1] + 18 , aObjSize[1,2] + 5	SAY oCol	VAR OemToAnsi( STR0055 + " " + AllTrim( Str( nCol ) ) )		SIZE 500,10	OF oGroup1 PIXEL FONT oFont	//"Coluna:		"

		@ aObjSize[2,1] , aObjSize[2,2] GROUP oGroup2 TO aObjSize[2,3],aObjSize[2,4] LABEL OemToAnsi(STR0057) OF oPanel PIXEL										//"Expressao:"
		oGroup2:oFont:= oFont
		@ aObjSize[2,1] + 06 , aObjSize[2,2] + 5	SAY oExpr VAR OemToAnsi( cString )				 						SIZE 500,10	OF oGroup2 PIXEL FONT oFont	
		@ aObjSize[2,1] + 12 , aObjSize[2,2] + 5	SAY oNumCol VAR OemToAnsi( cNumCol )				 					SIZE 500,10	OF oGroup2 PIXEL FONT oFont	
		@ aObjSize[2,1] + 18 , aObjSize[2,2] + 5	SAY oMulCol VAR OemToAnsi( cMulCol ) COLOR CLR_RED	 					SIZE 500,10	OF oGroup2 PIXEL FONT oFont

		@ aObjSize[3,1] , aObjSize[3,2] GROUP oGroup3 TO aObjSize[3,3],aObjSize[3,4] LABEL OemToAnsi(STR0058) OF oPanel PIXEL										//"Erro:"
		oGroup3:oFont:= oFont
		@ aObjSize[3,1] + 06 , aObjSize[3,2] + 5	SAY oErrStr VAR OemToAnsi( cErrStr ) COLOR CLR_RED							SIZE 500,10	OF oGroup3 PIXEL FONT oFont	

		@ aObjSize[4,1] , aObjSize[4,2] GROUP oGroup4 TO aObjSize[4,3],aObjSize[4,4] LABEL OemToAnsi(STR0068) OF oPanel PIXEL										//"Conteudo do Erro:"
		oGroup4:oFont:= oFont
		@ aObjSize[4,1] + 06 , aObjSize[4,2] + 5	SAY oErrLine VAR OemToAnsi( cStrErr ) COLOR CLR_RED							SIZE 500,10	OF oGroup4 PIXEL FONT oFont
		
		oLbxSource				:= TWBrowse():New( aObjSize[5,1],aObjSize[5,2],aObjSize[5,4],aObjSize[5,3],NIL,{ "" , OemToAnsi( STR0054 ) , OemtoAnsi( STR0052 ) },NIL,oDlg,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,.F.,NIL,.T.,NIL,.F.,NIL,NIL,NIL)
		oLbxSource:SetArray( aListbox )
		oLbxSource:bLine 		:= { || LineLstBox( oLbxSource , .T. , aOkNo , 1 ) }
		oLbxSource:bLdblClick	:= { || Gpea160EdSource( oLbxSource , cCadastro ) }
		If (;
				( nLine > 0 );
				.and.;
				( nLine <= nLoops );
			)	
			oLbxSource:nAt		:= nLine
		EndIf

	ACTIVATE MSDIALOG oDlg ON INIT Eval( bDialogInit ) CENTERED
	RestKeys( aSvKeys , .T. )

End Sequence

If !Empty( cMsgInfo )
	MsgInfo( cMsgInfo )
EndIf

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea160EdSource  ³Autor³Marinaldo de Jesus³ Data ³01/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Editar a Coluna do Codigo Fonte			 					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³oListBox:blDblClick							   				³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpea160EdSource( oListBox , cTitulo )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis que serao inicializadas no Corpo da Funcao		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aSvKeys
Local aAdvSize
Local aInfoAdvSize
Local aObjSize
Local aObjCoords

Local bSet15
Local bSet24

Local cMemoEdit
Local oMemoEdit

Local oFont
Local oDlg

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Apenas se o ListBox nao Estiver Vazio      				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF Empty( oListBox:aArray )
		Break
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Obtem o Memo                               				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cMemoEdit := oListBox:aArray[ oListBox:nAt , oListBox:nColPos ]
	If ( ValType( cMemoEdit ) <> "C" )
		Break
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta as Dimensoes dos Objetos             				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aAdvSize		:= MsAdvSize( .T. , .T. )
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 0 , 0 }
	aObjCoords		:= { { 0 , 0 , .T. , .T. } }
	aObjSize := MsObjSize( aInfoAdvSize , aObjCoords )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Salva as Teclas de Atalho                  				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aSvKeys := GetKeys()

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para a Tecla <CTRL-O>						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bSet15	:= { || GetKeys() , oDlg:End() }

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Bloco para a Tecla <CTRL-X>     	   				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bSet24	:= { || GetKeys() , oDlg:End() }

	DEFINE FONT oFont NAME "Arial" SIZE 0,-15 //BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi( cTitulo ) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() STYLE DS_MODALFRAME STATUS PIXEL 
			
		@ aObjSize[1,1],aObjSize[1,2] GET oMemoEdit VAR cMemoEdit MEMO SIZE aObjSize[1,4],(aObjSize[1,3]-15) FONT oFont HSCROLL CENTERED DESIGN NO VSCROLL OF oDlg PIXEL WHEN ( .T. )
		oMemoEdit:lReadOnly := .F.

		oDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 ) CENTERED
	RestKeys( aSvKeys , .T. )

End Sequence

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea160GvTudOk³Autor³Marinaldo de Jesus   ³ Data ³08/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gravacao das Informacoes no banco                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA160()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpea160GvTudOk(	nOpcAlt			,;
								nOpc			,;
								nReg			,;
								aSRYCols		,;
								aSvSRYCols		,;
								aSryEnchoice	,;
								aSryVirtChoice	,;
								aHeader			,;
								aCols			,;
								aSrmVirtual		,;
								aSrmRecnos		,;
								nUsado			,;
								aSvSrmCols		,;
								cAlias			,;
								aSrmChave		,;
								aRGACols		,;
								aSvRGACols		,;
								aRGAEnchoice	,;
								aRGAVirtChoice	;
							  )

Local lGrvTudOk := .T.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Quando Confirmada a Opcao e Nao for Visualizacao Grava ou   Ex³
³clui as Informacoes do SRY e SRM							   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If (;
		( nOpcAlt == 1 );	//Confirmou
		.and.;
		( nOpc != 2 );		//Nao eh Visualizacao
	)

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Quando For Copia Posiciona o SRY No Final do Arquivo 	       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If ( lGpea160Cpy  )
		nOpc := 3 //Inclusao
		aRotSetOpc( cAlias , @nReg , nOpc , .T. )
		aSrmRecnos := {}
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Removendo a Formula do Repositorio                           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If ( nOpc == 5 )	//Exclusao
		(cAlias)->( MsGoto( nReg ) )
		(cAlias)->( DelFunRot( RY_FILIAL , RY_CALCULO ) )
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Simula compilação do roteiro antes de efetuar a gravação, para verificar se está em uso   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/	
	If !(lGrvTudOk := Gpea160SwCod(nReg, .T., .T.))
		return lGrvTudOk
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Gravando/Incluido ou Excluindo Informacoes do SRY/SRM        ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF Gpea160Grava(;
						nOpc			,;
						@nReg			,;
						aSRYCols		,;
						aSvSRYCols		,;
						aSryEnchoice	,;
						aSryVirtChoice	,;
						aRGACols		,;
						aSvRGACols		,;
						aRGAEnchoice	,;
						aRGAVirtChoice	,;						
						aHeader			,;
						aCols			,;
						aSrmVirtual		,;
						@aSrmRecnos		,;
						nUsado			,;
						aSvSrmCols	 	,;
						aSrmChave		,;
						cAlias			;
				 	)
		(cAlias)->( MsGoto( nReg ) )
		If (cAlias)->( !Eof() )
			If !(lGrvTudOk := Gpea160SwCod(nReg, .T.))
				lGpea160Cpy	:= .F.
				nOpcAlt		:= 0
			EndIf
		EndIf	
		
	EndIf	

EndIf

Return( lGrvTudOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea160Grava ³Autor³Marinaldo de Jesus    ³ Data ³18/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEA160()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpea160Grava(	nOpc			,;	//Opcao de Acordo com aRotina
							 	nReg			,;	//Numero do Registro do Arquivo Pai ( SRY )
								aSRYCols		,;	//Itens do SRY
								aSvSRYCols		,;	//Conteudo inicial do SRY
							 	aSryEnchoice	,;	//Campos do Arquivo Pai ( SRY ) Mesma Estrutrua do aHeader
							 	aSryVirtChoice	,;	//Campos Virtuais do Arquivo Pai ( SRY )
								aRGACols		,;	//Itens do RGA 
								aSvRGACols		,;	//Conteudo inicial do RGA
								aRGAEnchoice	,;	//Campos do Arquivo Pai ( RGA ) Mesma Estrutrua do aHeader
								aRGAVirtChoice	,;	//Campos Virtuais do Arquivo Pai ( RGA )					 	
							 	aHeader			,;	//Campos do Arquivo Filho ( SRM )
							 	aCols			,;	//Itens do Arquivo Filho ( SRM )
							 	aSrmVirtual		,;	//Campos Virtuais do Arquivo Filho ( SRM )
							 	aSrmRecnos		,;	//Recnos do Arquivo Filho ( SRM )
							 	nUsado			,;	//Campos em uso na GetDados ( SRM )
							 	aSvSrmCols     	,;	//Copia inicial do acols
							 	aSrmChave		,;  //Array com os itens de chave - Para controle de atualizacao
							 	cAlias			;
							  )

Local aNewRecnos		:= {}
Local aColsDel			:= {}
Local aSvRecnos			:= aClone( aSrmRecnos )

Local cChave			:= ""
Local cNewChave			:= ""
Local cRyFilial			:= ""
Local cRyCalculo		:= ""
Local cKeySeek			:= ""
Local cCodFor			:= ""                  
Local cSrySeqFil		:= ""

Local lAlter			:= .F.
Local lSRYAlter			:= .F.
Local lSRMAlter			:= .F.
Local lRGAAlter			:= .F.
Local lAddNew			:= .F.

Local nChoice			:= 0
Local nChoices			:= 0
Local nHeader			:= 0
Local nHeaders			:= 0
Local nCol				:= 0
Local nCols				:= 0
Local nRecno			:= 0
Local nRecnos			:= 0
Local nDeleted			:= 0
Local nTamSeq			:= 0 
Local nSRMReg			:= 0
Local nChave			:= 0
Local nSrmNewSeq		:= 0
Local nSrmSeq			:= 0
Local nSrmFormula		:= 0
Local nPosGhostCol		:= 0
Local nx					:= 0
Local nPosRec				:= Len(aRGAEnchoice)+1 // POSICAO QUE INDICA SE ESTA DELETADO OU NAO
Local nRGARec				:= GdFieldPos( "RGA_REC_WT", aRGAEnchoice) //RECNO DO REGISTRO

DEFAULT nOpc			:= 0
DEFAULT nReg			:= 0
DEFAULT aSryEnchoice	:= {}
DEFAULT aSryVirtChoice	:= {}
DEFAULT aHeader			:= {}
DEFAULT aCols			:= {}
DEFAULT aSrmVirtual		:= {}
DEFAULT aSrmRecnos		:= {}
DEFAULT nUsado			:= 0

nPosGhostCol := GdFieldPos( "GHOSTCOL"	, aHeader )
Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Se for Exclusao ( nOpc == 5 )								   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If ( nOpc == 5 )
		If !Empty( nReg )
			Begin Transaction
				(cAlias)->( dbGoto( nReg ) )
				IF RecLock( cAlias , .F. , .F. )
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Deleto os Registros do SRM									   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					DelRecnos( "SRM" , @aSrmRecnos )
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Deleto os Registros do SRY									   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					DelRecnos( cAlias , { nReg } , NIL , NIL , { { "RY_DESOBS" , "RY_CODOBS" } } , "SYP" )
					(cAlias)->( MsUnLock() )
				EndIf

			  	DbSelectArea("RGA")
			  	Dbsetorder(Retorder("RGA", "RGA_FILIAL+RGA_CALCUL"))
			  	While RGA->(!Eof())
					If DbSeek(SRY->RY_FILIAL + SRY->RY_CALCULO)
						If RGA->(RecLock("RGA", .F., .F.))
							RGA->(dbDelete())
							RGA->(MsUnLock())
						EndIf					
					EndIf
					RGA->(DbSkip())
				EndDo
				DbCloseArea()					
			End Transaction
		EndIf
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se for Inclusao/Alteracao ( nOpc == 3 .or. nOpc == 4 )	   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	ElseIF (;
				( nOpc == 3 );
				.or.;
				( nOpc == 4 );
			)	

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Atualiza o aSRYCols com o Conteudo das Variaveis de   Memoria³
		³ para comparacao											   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nChoices	:= Len(	aSryEnchoice )
		For nChoice := 1 To nChoices
			aSRYCols[ 1 , nChoice ] := GetMemVar( aSryEnchoice[ nChoice , 2 ] )
		Next nChoice

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Atualiza o aRGACols com o Conteudo das Variaveis de   Memoria³
		³ para comparacao											   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		oRGAGet:Refresh()
		aRGACols := aClone(oRGAGet:ACOLS)
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se Houveram Modificacoes no RGA                     ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lRGAAlter := !( ArrayCompare( aSvRGACols , aRGACols ) )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se Houveram Modificacoes no SRY                     ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lSRYAlter := !( ArrayCompare( aSvSRYCols , aSRYCols ) )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se Houveram Modificacoes no SRM                     ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lSRMAlter := !ArrayCompare( aCols , aSvSrmCols )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se Houveram Modificacoes                            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lAlter	:= ((lSRYAlter) .OR. (lSRMAlter) .OR. (lRGAAlter))

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se nao Houveram Modificacoes, Abandona                       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If !( lAlter )
			Break
		EndIf
		
		// Iniciar a gravacao dos itens //
		Begin Transaction

			If ( lSRYAlter )
				If !( lAddNew := Empty( nReg ) )
					(cAlias)->( dbGoto( nReg ) )
					lAddNew := (cAlias)->( Eof() )
				EndIf
				If cAlias == "SRY"
					cSrySeqFil := ""
					If Empty(SRY->RY_SEQFIL) .or. lAddNew
						cSrySeqFil := GetSrySeqFil(If(lAddNew,xFilial(cAlias),SRY->RY_FILIAL))
					EndIf
				EndIf
				If (cAlias)->( RecLock( cAlias , lAddNew , .F. ) )
					(cAlias)->( FieldPut( FieldPos(PrefixoCpo(cAlias)+"_FILIAL") , xFilial(cAlias)) )
					For nChoice := 1 To nChoices
						If ( aScan( aSryVirtChoice , { |cCpo| ( cCpo == aSryEnchoice[ nChoice , 02 ] ) } ) == 0 )
							(cAlias)->( FieldPut( FieldPos( aSryEnchoice[ nChoice , 02 ] ) , aSRYCols[ 1 , nChoice ] ) )
						ElseIF ( aSryEnchoice[ nChoice , 02 ] == "RY_DESOBS" )
							MsMm((cAlias)->RY_CODOBS,NIL,NIL,aSRYCols[ 1 , nChoice ],1,NIL,NIL,cAlias,"RY_CODOBS")
							/*/
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Garanto Lock para o SRY que pode ter sido Liberado pela MsMm()³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
							(cAlias)->( RecLock( cAlias , .F. ) )
						EndIf
					Next nChoice
					If cAlias == "SRY" .and. !Empty(cSrySeqFil)
						SRY->RY_SEQFIL := cSrySeqFil
					EndIf
					(cAlias)->( MsUnLock() )
					nReg := (cAlias)->( Recno() )
				EndIf
			EndIf

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Pegar o ultimo codigo da chave - apenas qdo for manutencao   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			If ( lManutence )	// apenas para manutencao do roteiro - realizado pela Microsiga
				nSRMReg := SRM->( Recno() )
				SRM->( dbGoTop() )
				While SRM->( !Eof() )
					nChave := Max( Val( SubStr( SRM->RM_CHAVE , 3 , 4 ) ) , nChave )
					SRM->( dbSkip() )
				Enddo
				SRM->( dbGoto( nSRMReg ) )
			EndIf

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Garanto o Posicionamento do SRY       					   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			(cAlias)->( MsGoto( nReg ) )
			cRyFilial		:= &(cAlias + "->" + PrefixoCpo(cAlias) + "_FILIAL")
			cRyCalculo		:= &(cAlias + "->" + PrefixoCpo(cAlias) + "_CALCULO")
			cKeySeek := ( cRyFilial + cRyCalculo )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Obtem o Posicionamento do RM_SEQ        					   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			nSrmSeq 	:= GdFieldPos( "RM_SEQ" , aHeader )
         	nSrmFormula := GdFieldPos( "RM_FORMULA" , aHeader )
			nDeleted	:= ( nUsado + 1 )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Excluir os itens de Usuario da gravacao                      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			If ( lManutence )		// apenas para manutencao do roteiro - realizado pela Microsiga
				For nRecno := 1 To Len( aCols )
					If Substr( aCols[ nRecno, nSrmFormula ], 1, 2 ) == "U_"
						aCols[ nRecno , nDeleted ] := .T.
					EndIf
				Next nRecno
			EndIf

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Deleto todos os Itens que nao Estao OK					   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			GdSuperDel( aHeader , @aCols , NIL , .T. , GdGetBlock( "SRM" , aHeader , .F. ) ) 

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Separa os Itens que foram Deletados     					   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			SRM->( dbSetOrder( RetOrder( "SRM" , "RM_FILIAL+RM_CALCULO+RM_SEQ" ) ) )

			IF GdSplitDel( aHeader , @aCols , aSrmRecnos , @aColsDel )
				nCols	:= Len( aColsDel )
				For nCol := 1 To nCols
					IF SRM->( dbSeek( cKeySeek + aColsDel[ nCol , nSrmSeq ] , .F. ) )
                    		IF SRM->( RecLock( "SRM" , .F. ) )
                    			SRM->( dbDelete() )
                    			SRM->( MsUnLock() )
                    	EndIf
					EndIf
				Next nCol
			EndIf

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Obtenho os Recnos conforme Informacoes do aCols para a Integri³
			³dade Referencial											   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			aSrmRecnos := {}
			nCols := Len( aCols )
			For nCol := 1 To nCols
				if SRM->( dbSeek( cKeySeek + aCols[ nCol , nSrmSeq ] , .F. ) )
					SRM->( aAdd( aSrmRecnos , Recno() ) )
				Else            
					IF Val(aCols[ nCol , nPosGhostCol ]) > 0 .and. !Empty( aSvRecnos )
						aAdd( aSrmRecnos , aSvRecnos[ Val( aCols[ nCol , nPosGhostCol ] ) ] )          
					EndIf
				EndIf
			Next nCol

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Inicializa as Variaveis                 					   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			nHeaders	:= Len(	aHeader )
			nCols		:= Len(	aCols	)
			nRecnos		:= Len( aSrmRecnos )
			nTamSeq		:= aHeader[ nSrmSeq , 4 ]

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Reorganizar Sequencia quando pertencer a Manutencao e atuali-³
			³ o array de recnos.                                           ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			For nRecno := 1 To nCols
				If ( lManutence ) // apenas para manutencao do roteiro - realizado pela Microsiga
					nSrmNewSeq += 10
					aCols[ nRecno , nSrmSeq ] := StrZero( nSrmNewSeq , nTamSeq )
				EndIf

				IF nRecno > nRecnos
					aAdd( aSrmRecnos , 0 )
				EndIf
			Next nRecno
			nRecnos		:= Len( aSrmRecnos )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Gravando as Informacoes no SRM							   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			For nRecno := 1 To nRecnos
				nSRMReg := aSrmRecnos[ nRecno ]
				lAddNew := Empty( nSRMReg )
				If !( lAddNew )
					SRM->( dbGoto( nSRMReg ) )
					lAddNew := SRM->( Eof() )
				EndIf
				If ( lManutence ) // apenas para manutencao do roteiro - realizado pela Microsiga
					If ( Val( aCols[ nRecno , nPosGhostCol ] ) == 0 )
						nChave++
						cNewChave := ( "NI" + StrZero( nChave , 4 ) )
					EndIf
				EndIf
				If SRM->( RecLock( "SRM" , lAddNew ) )
					SRM->RM_FILIAL	:= cRyFilial
					SRM->RM_CALCULO := cRyCalculo

					For nHeader := 1 To nHeaders
						If ( aScan( aSrmVirtual , { |cCpo| ( cCpo == aHeader[ nHeader , 02 ] ) } ) == 0 )
							SRM->( FieldPut( FieldPos( aHeader[ nHeader , 02 ] ) , aCols[ nRecno , nHeader ] ) )
						EndIf
					Next nHeader

				    If ( Val( aCols[ nRecno , nPosGhostCol ] ) == 0 )
   				    	IF lManutence
					    	cChave	:= ( cNewChave + SubStr( cChave , 7 ) )
	   					Else
							cChave := ""
						EndIf
				    Else
				    	If Empty( aSrmChave )
			 				cChave := ""
			 			Else
			 				cChave := aSrmChave[ Val( aCols[ nRecno , nPosGhostCol ] ) ]
			 			EndIf
				 	EndIf         

				    cNewChave := ""
   					SRM->( FieldPut( FieldPos( "RM_CHAVE" ) , cChave ) )

					cCodFor :=  aCols[ nRecno, GdFieldPos( "RM_FORMULA" , aHeader ) ]
					SRM->( FieldPut( FieldPos( "RM_CODFOR" ) , Substr( cCodFor, 1, Len( AllTrim(cCodFor))-2) ) )

					SRM->( MsUnlock() )
					SRM->( aAdd( aNewRecnos , Recno() ) )
				EndIf
			Next nRecno

			// GRAVANDO AS INFORMACOES DE RGA
			If (lRGAAlter)
				For nx:= 1 to Len(aRGACols)

					DbSelectArea("RGA")
					Dbsetorder(Retorder("RGA", "RGA_FILIAL+RGA_PROCES+RGA_CALCUL"))
					If DbSeek(SRY->RY_FILIAL + aRGACols[nx, GdFieldPos("RGA_PROCES",aRGAEnchoice)] +SRY->RY_CALCULO)
						lAddNew := .F.
					Else
						lAddNew := .T.
					EndIf	

					If aRGACOLS[nx, nPosRec] == .T.	// VERIFICA SE LINHA ESTA DELETADA NO ACOLS
						If aRGAcols[nx,nRGARec] > 0		// SE RECNO EXISTIR EFETUA A DELECAO NA BASE
							("RGA")->(RecLock("RGA" , lAddNew , .F.))
							 DBDelete()
							 Loop
						Else
							Loop
						EndIf
					EndIf

					If ("RGA")->(RecLock( "RGA" , lAddNew , .F.))
						("RGA")->(FieldPut(FieldPos(PrefixoCpo("RGA")+"_FILIAL") , xFilial("RGA")))
						("RGA")->(FieldPut(FieldPos("RGA_CALCUL") , RY_CALCULO))
						For nChoice := 1 To Len(aRGAEnchoice)
							If (aScan(aRGAVirtChoice , { |cCpo| (cCpo == aRGAEnchoice[ nChoice , 02 ]) }) == 0)
								("RGA")->(FieldPut(FieldPos(aRGAEnchoice[ nChoice , 02 ]) , aRGACols[ nx , nChoice ]))
							EndIf
						Next nChoice
						("RGA")->(MsUnLock())
					EndIf
					Dbclosearea()
				Next nx
			EndIf

			If ( lAlter )
				cSrySeqFil := ""
				If Empty((cAlias)->RY_SEQFIL)
					cSrySeqFil := GetSrySeqFil(SRY->RY_FILIAL)
				EndIf
				IF RecLock( cAlias , .F. , .F. )
					(cAlias)->RY_RECOMP := "1" //Altero para Recompilar
					If ( lManutence )
						cVersao := Replicate( "0" , GetSx3Cache( "RY_VERSAO" , "X3_TAMANHO" ) )
						If ( nOpc == 3 )
							(cAlias)->RY_VERSAO := Soma1( cVersao )
						ElseIF ( nOpc == 4 )
							cVersao := (cAlias)->RY_VERSAO
							IF Empty( cVersao )
								cVersao := Replicate( "0" , GetSx3Cache( "RY_VERSAO" , "X3_TAMANHO" ) )
							EndIf
							(cAlias)->RY_VERSAO := Soma1( cVersao )
						EndIf
					EndIf
					If !Empty(cSrySeqFil)
						(cAlias)->RY_SEQFIL := cSrySeqFil
					EndIf	
					(cAlias)->( MsUnLock() )
				EndIf
	        EndIf

		End Transaction

	EndIf

End Sequence

aSrmRecnos := aClone( aNewRecnos )

Return( lAlter )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fGeraSalInc³ Autor ³Mauricio T. Takakura  ³ Data ³26/12/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Geracao da Formula Salario Incorporado                      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fGeraSalInc()                     							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico 	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGeraSalInc(cRotOrd, aHeader, aCols)

Local aRC3Recnos	:= {}
Local aRc3Header
Local aGetTreeFrm

Local cPrg
Local cRC3Key
Local cMsgErr
Local cRc3Opera3
Local cCodSalInc := "SALINC"

Local lNewReg
Local lCompileOk
Local lEndSalInc := .F.

Local nX
Local nReg
Local nRecnos
Local nTamSeqFor
Local nPosFormula
Local nPosHabilit

DEFAULT cRotOrd := fGetRotOrdinar()
DEFAULT aHeader	:= {}
DEFAULT aCols	:= {}

Begin Sequence

	If Empty(aCols) .and. Empty(aHeader)
		cSRMKey := xFilial( "SRM" ) + cRotOrd

		aCols := SRM->( GdMontaCols(	@aHeader	 								,;	// 01 -> Array com os Campos do Cabecalho
				 						NIL											,;	// 02 -> Numero de campos em uso
										NIL											,;	// 03 -> Array com os campos virtuais
								 		NIL											,;	// 04 -> Array com os campos visuais
								 		"SRM" 										,;	// 05 -> Opcional, Alias do Arquivo Carga dos itens do aCols
								 		NIL											,;	// 06 -> Opcional, campos que nao deverao constar do aHedder (NotFields)
								 		NIL											,;  // 07 -> [@]Array unidimensional contendo os Recnos
								 		"SRY"										,;	// 08 -> Alias do Arquivo Pai
								 		cSRMKey										,;	// 09 -> Chave para o Posicionamento no Alias Filho
								 		NIL											,;	// 10 -> Bloco para condicao de Loop While
								 		NIL											,;	// 11 -> Bloco para Skip no Loop While
								 		NIL											,;	// 12 -> Se Havera o Elemento de Delecao no aCols
								 		NIL											,;	// 13 -> Se cria variaveis Publicas
								 		NIL											,;	// 14 -> Se Sera considerado o Inicializador Padrao
								 		NIL											,;	// 15 -> Lado para o inicializador Padrao
								 		.T.											 ;	// 16 -> Opcional, Carregar Todos os Campos
									);
					  )
	EndIf

	If cPaisLoc <> "MEX" .and. !Empty(cRotOrd) .and. cRotOrd == SRY->RY_CALCULO

		DbSelectArea( "RC2" )
		DbSetOrder( 1 )		// RC2_FILIAL + RC2_ORIGEM + RC2_CODIGO
		If DbSeek( xFilial("RC2") + "S_" + cCodSalInc, .F.)
			lNewReg := .F.

			cRC3Key := RC2->RC2_FILIAL + RC2->RC2_ORIGEM + RC2->RC2_CODIGO

			RC3->( GdMontaCols(	@aRc3Header 								,;	// 01 -> Array com os Campos do Cabecalho
								NIL											,;	// 02 -> Numero de campos em uso
								NIL											,;	// 03 -> Array com os campos virtuais
						 		NIL											,;	// 04 -> Array com os campos visuais
						 		"RC3" 										,;	// 05 -> Opcional, Alias do Arquivo Carga dos itens do aCols
						 		NIL											,;	// 06 -> Opcional, campos que nao deverao constar do aHedder (NotFields)
						 		@aRC3Recnos									,;  // 07 -> [@]Array unidimensional contendo os Recnos
						 		"RC2"										,;	// 08 -> Alias do Arquivo Pai
						 		cRC3Key										,;	// 09 -> Chave para o Posicionamento no Alias Filho
						 		NIL											,;	// 10 -> Bloco para condicao de Loop While
						 		NIL											,;	// 11 -> Bloco para Skip no Loop While
						 		NIL											,;	// 12 -> Se Havera o Elemento de Delecao no aCols
						 		NIL											,;	// 13 -> Se cria variaveis Publicas
						 		NIL											,;	// 14 -> Se Sera considerado o Inicializador Padrao
						 		NIL											,;	// 15 -> Lado para o inicializador Padrao
						 		.T.											 ;	// 16 -> Opcional, Carregar Todos os Campos
							  );
				)
		Else
			lNewReg := .T.
	    EndIf

		IF RecLock( "RC2", lNewReg, .T. )
			If lNewReg
				RC2->RC2_FILIAL := xFilial( "RC2" )
				RC2->RC2_ORIGEM := "S_"
				RC2->RC2_CODIGO := "SALINC"
				RC2->RC2_DESC   := OemToAnsi(STR0082)	// "Formula Salario Incorporado"
			EndIf
			RC2->RC2_VERSAO := "001"
			RC2->RC2_RECOMP := "1"
			RC2->( MsUnLock() )
		Else
			cMsgErr := OemToAnsi(STR0079)	// "Nao foi possivel gerar a Formula Salario Incorporado!"
			Break
		EndIf

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Gravacao dos itens da formula.                                  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nPosFormula := GdFieldPos( "RM_FORMULA", aHeader )
		nPosHabilit	:= GdFieldPos( "RM_HABILIT", aHeader )
		DbSelectArea( "RC3" )
		nRecnos := Len( aRC3Recnos )
		nTamSeqFor := GetSx3Cache( "RC3_SEQFOR" , "X3_TAMANHO" )
		For nX := 1 To Len( aCols )
			If nX == Len( aCols )
				cRc3Opera3 := ".END."
			Else
				cRc3Opera3 := ".CNT."
			EndIf
	
			If nX <= nRecnos
				nReg := aRC3Recnos[nX]
			Else
				nReg := 0
			EndIf
			lNewReg := .T.
			If nReg > 0
				lNewReg := .F.
				DbGoTo( nReg )
			EndIf
			
			If lEndSalInc .Or. aCols[nX, nPosHabilit] == "2"
				If !lNewReg
					RecLock( "RC3", lNewReg, .T. )
					RC3->( dbDelete() )
					RC3->( MsUnLock() )
				EndIf
				Loop
			EndIf
	
			If AllTrim( aCols[ nX, nPosFormula ] ) == "S_PROCSRC"
				cRc3Opera3 := ".END."
				lEndSalInc := .T.
			EndIf
			
			RecLock( "RC3", lNewReg, .T. )
			RC3->RC3_FILIAL	:= RC2->RC2_FILIAL
			RC3->RC3_ORIGEM := RC2->RC2_ORIGEM
			RC3->RC3_CODIGO := "SALINC"
			RC3->RC3_DESCR  := AllTrim( aCols[ nX, nPosFormula ] ) + "     " + cRc3Opera3
			RC3->RC3_SEQFOR := StrZero(	nX, nTamSeqFor )
			RC3->RC3_SEQPAI := StrZero(	0, nTamSeqFor )
			RC3->RC3_TIPO 	:= ".EXE."
			RC3->RC3_TPRESU	:= "5"
			RC3->RC3_RESULT := aCols[ nX, nPosFormula ]
			RC3->RC3_OPERA1	:= ""
			RC3->RC3_TPFM01	:= "5"
			RC3->RC3_FORM01	:= ""
			RC3->RC3_OPERA2 := ""
			RC3->RC3_TPFM02 := "5"
			RC3->RC3_FORM02 := ""
			RC3->RC3_OPERA3 := cRc3Opera3
			RC3->RC3_RESOU1	:= "PMSTASK4"
			RC3->RC3_RESOU2 := "PMSTASK4"
			RC3->( MsUnLock() )
		Next nX	
	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Compilar a Formula do Salario Incorporado                       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cPrg := ( RC2->( RC2_ORIGEM + AllTrim( RC2_CODIGO ) ) + ".PRG" )
		cPrg := Lower( GetRpoForm( .F. , .T. ) + cPrg )
		MsAguarde( { || lCompileOk := RC2->( GetTreeFrm( @aGetTreeFrm , RC2_FILIAL , RC2_ORIGEM , RC2_CODIGO , .F. ) ) } , OemToAnsi( STR0080 ) )	//"Compilando Formula do Salario Incorporado (SalInc)..."
		RpoFormInit( NIL, .T. )
		If !lCompileOK
			If Empty( aGetTreeFrm )
				cMsgErr := STR0081	//"Nao foi possivel compilar o Programa da Formula Salario Incorporado (SalInc)!"
			EndIf
		EndIf
	EndIf

End Sequence

If !Empty( cMsgErr )
	MsgInfo( cMsgErr )
EndIf

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea160Cpy³ Autor ³Marinaldo de Jesus     ³ Data ³18/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea160Cpy( cAlias , nReg , nOpc )							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cAlias = Alias do arquivo                                   ³
³          ³nReg   = Numero do registro                                 ³
³          ³nOpc   = Numero da opcao selecionada                        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA160()	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea160Cpy( cAlias , nReg , nOpc )

lGpea160Cpy := .T.

Return( Gpea160Mnt( cAlias , nReg , 4 ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Gpea160ChkRot	³Autor³Marinaldo de Jesus ³ Data ³18/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Montar Dialogo para Edicao dos Campos do Roteiro de Calculo ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea160ChkRot()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA160														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³lRet														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                           									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea160ChkRot()

Local lRet 		 := .F.
Local lManutence := ( FunName() == "GPEA160M" )
Local lGpea161	 := IsInCallStack("GPEA161")
Local nSrmSeq 	 := 0
Local cSeqAux	 := ""
Local cCpo		 := Upper( AllTrim( SubStr( ReadVar() , 4 ) ) )
Local cCalculo	 := GetMemVar( "RY_CALCULO" )
Local oModel
Local oGrid

If lGpea161
	oModel 	:= FWModelActive()
	oGrid	:= oModel:GetModel( "GPEA161_SRM" )
	cSeqAux :=  oGrid:GetValue("RM_SEQ")
Else
	nSrmSeq := GdFieldPos( "RM_SEQ" )
	cSeqAux	:= aCols[n,nSrmSeq]
EndIf

lRet := !( Val(cSeqAux)%10 == 0 .and. Val(cSeqAux) != 0 )

If !( lManutence )
	If ( cCpo $ "RM_FORMULA" )
		If !( lRet )
			Gpea160EditRot( cCalculo , cCpo , .F. )
		EndIf
	ElseIF !lRet
		//"O Roteiro: " " e um Roteiro Padrao e nao pode ser alterado"###"Atencao"
		Help( "" , 1 , STR0014 , NIL , OemToAnsi(STR0012) + cCalculo + " - " + cSeqAux + OemToAnsi(STR0013) , 1 , 0 )
	EndIf
Else
 	If cCpo != "RM_SEQ"
  		lRet := .T.
 	EndIf
EndIf                

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Gpea160EditRot	³Autor³Marinaldo de Jesus ³ Data ³18/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Montar Dialogo para Edicao dos Campos do Roteiro de Calculo ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea160EditRot(cRot,cCpo)								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Gpea160ChkRot() em GPEA160                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³.T. 														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cRot	-> Copdigo do Roteiro								³
³          ³cCpo	-> Campo a Ser Editado								³
³          ³lModify	-> Possibilita a Alteracao							³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpea160EditRot(cRot,cCpo,lModify)

Local cDesc 	:= aCols[ n , GdFieldPos("RM_DESCRIC") ]
Local cSeq		:= aCols[ n , GdFieldPos("RM_SEQ") ]
Local cSep		:= " - "
Local cMemo		:= AllTrim( &( ReadVar() ) )
Local cTitulo	:= aHeader[ GdFieldPos( cCpo ) , 01 ]
Local cInit		:= "3"
Local lOk		:= .T.
Local lValid	:= .F.
Local nSize		:= aHeader[ GdFieldPos( cCpo ) , 04 ]
Local nInit		:= IF( cInit == "1" , Val( cInit ) , Val( cInit ) + 1  )
Local oDlg
Local oFont
Local oMemo

DEFAULT cRot	:= ""
DEFAULT cCpo	:= ""
DEFAULT lModify := .F.

If !( lModify )
	DEFINE FONT oFont  NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi( cCadastro + cSep +cTitulo ) From 196,042 TO 400,580 OF oMainWnd PIXEL //"Roteiro de Calculo: "
		
		@ 12,05 TO 025,265 OF oDlg PIXEL
		@ 16,15	SAY cRot + cSep + cSeq + cSep + cSep + cDesc  SIZE 200,007 PIXEL FONT oFont COLOR CLR_HBLUE
		
		@ 027 , 005 GET oMemo VAR cMemo MEMO SIZE 260 , 070 FONT oFont OF oDlg PIXEL WHEN lModify VALID ( lValid := Gpea160ValidRot( cTitulo , @cMemo , nSize ) )
		
	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||lOk:=lValid,oDlg:End()},{||oDlg:End()}) CENTERED
Else
	cMemo := fCamposForm( nInit , @cInit )
EndIf
		
If ( lOk )
	SetMemVar( cCpo , IF( Empty( cMemo ) , Space( nSize ) , cMemo + ( Space( nSize - Len( cMemo ) ) ) ) )
	aCols[ n , GdFieldPos( cCpo ) ] := GetMemVar( cCpo )
EndIf

Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Gpea160ValidRot	³Autor³Marinaldo de Jesus ³ Data ³18/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Valida o Tamanho da Expressao digitada no Roteiro           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea160ValidRot( cTitulo , cMemo , nSizeCpo )				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Gpea160EditRot() em GPEA160                                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³lValid 														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cTitulo		-> Titulo do Campo a ser Validado				³
³          ³cMemo		-> Expressao para Validacao						³
³          ³nSizeCpo	-> Tamanho do Campo para Validacao				³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpea160ValidRot( cTitulo , cMemo , nSizeCpo )

Local lValid := ValidRot( cTitulo , @cMemo , nSizeCpo )

Return( lValid )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RyCalculoVld	³Autor³Marinaldo de Jesus ³ Data ³01/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar o conteudo do campo RY_CALCULO                      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RyCalculoVld()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID do campo RY_CALCULO                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRyCalculoVld												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³NIL                                        					³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RyCalculoVld()

Local lRyCalculoVld

Begin Sequence

	If !( lRyCalculoVld := NaoVazio() )
		Break
	EndIf
                                      
	If MV_MODFOL <> '2'
	 	If !( lRyCalculoVld := Gpea160SRot( M->RY_CALCULO ) )
	 		Break
	 	EndIf
	EndIf
	
	If !( lRyCalculoVld := ExistChav( "SRY", M->RY_CALCULO, 1 ) )
		Break
	EndIf

	If !( lRyCalculoVld := FreeForUse( "SRY" , M->RY_CALCULO ) )
		Break
	EndIf

End Sequence

Return( lRyCalculoVld  )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RyDescVld		³Autor³Marinaldo de Jesus ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar o conteudo do campo RY_DESC		                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RyCalculoVld()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID do campo RY_DESC                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRyDescVld													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³NIL                                        					³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RyDescVld()

Local lRyDescVld := .T.

Begin Sequence

	If !( lRyDescVld := NaoVazio() )
		Break
	EndIf

End Sequence

Return( lRyDescVld )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RyOrigemVld		³Autor³Marinaldo de Jesus ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar o conteudo do campo RY_ORIGEM	                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RyCalculoVld()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID do campo RY_ORIGEM                                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRyDescVld													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³NIL                                        					³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RyOrigemVld()

Local lRyOrigemVld := .T.

Begin Sequence

	If !( lRyOrigemVld := NaoVazio() )
		Break
	EndIf
	
	If !( lRyOrigemVld := Pertence( RyOrigemBox( .T. ) ) )
		Break
	EndIf

End Sequence

Return( lRyOrigemVld )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RyOrigemBox  ³Autor³Marinaldo de Jesus    ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Funcao para Retornar as Opcoes do Campo RY_ORIGEM         	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_CBOX para o campo RY_ORIGEM	                         	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RyOrigemBox( lValid , lRetDesc , cOpcDesc )

Local cOpcBox

DEFAULT lValid		:= .F.
DEFAULT lRetDesc	:= .F.

If !( lValid )

	If !( lRetDesc )

		cOpcBox := ( "1=" + STR0062 + ";"	)	//"Sistema"
		cOpcBox += ( "2=" + STR0063			)	//"Usuario"

	Else

		Do Case
			Case ( cOpcDesc == "1" ) ; ( cOpcBox := STR0062 )	//"Sistema"
			Case ( cOpcDesc == "2" ) ; ( cOpcBox := STR0063 )	//"Usuario"
		End Case

	EndIf

Else

	cOpcBox := "12"

EndIf

Return( cOpcBox )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RyOrigemInit ³Autor³Marinaldo de Jesus    ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Inicializadora padrao do campo RY_ORIGEM                  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO para o campo RY_ORIGEM	                        ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RyOrigemInit()
Return( SubStr( RyOrigemBox( .T. ) , -1 ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RyTipoBox    ³Autor³Mauricio T. Takakura  ³ Data ³11/02/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Funcao para Retornar as Opcoes do Campo RY_TIPO           	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_CBOX para o campo RY_TIPO  	                         	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RyTipoBox( lValid , lRetDesc , cOpcDesc )

Local cOpcBox
Local lGestPubl := IIF(ExistFunc("fUsaGFP"),fUsaGFP(),.F.)
Local lOpeSoc	:= SuperGetMv("MV_OPESOC", NIL, .F.) 

DEFAULT lValid		:= .F.
DEFAULT lRetDesc	:= .F.

If !( lValid )

	If !( lRetDesc )

	   	cOpcBox := ( "1=" + OemToAnsi(STR0071) + ";"	)	//"Folha de Pagamento"
		cOpcBox += ( "2=" + OemToAnsi(STR0072) + ";"	)	//"Adiantamento"
		cOpcBox += ( "3=" + OemToAnsi(STR0073) + ";"	)	//"Ferias"
		cOpcBox += ( "4=" + OemToAnsi(STR0074) + ";"	)	//"Rescisao"
		If cPaisLoc == "VEN"
			cOpcBox += ( "5=" + OemToAnsi(STR0095) + ";"	)	//"Antecipacao Utilidade"
			cOpcBox += ( "6=" + OemToAnsi(STR0096) + ";"	)	//"Pagamento Final Utilidade"
		Else		
			cOpcBox += ( "5=" + OemToAnsi(STR0075) + ";"	)	//"13o. Salario (1a. Parcela)"
			cOpcBox += ( "6=" + OemToAnsi(STR0076) + ";"	)	//"13o. Salario (2a. Parcela)"
		EndIf		
		cOpcBox += ( "7=" + OemToAnsi(STR0077) + ";"	)	//"Outros"
		cOpcBox += ( "8=" + OemToAnsi(STR0078) + ";"	)	//"Vale Transporte"
		cOpcBox += ( "9=" + OemToAnsi(STR0084) 	+ ";"  	)	//"Autonomos"          
		If MV_MODFOL=="2"
			cOpcBox += ( "A=" + OemToAnsi(STR0093) 	+ ";"  	)	//"Aplicacao de Rescisao"
		Elseif MV_MODFOL=="1"
			cOpcBox += ( "A=" + OemToAnsi(STR0097) 	+ ";"  	)	//"Provisao"
		EndIf
		If cPaisLoc == "BOL"
			cOpcBox += ( "B=" + OemToAnsi(STR0133) 	+ ";"  	)	//"Quinquenio"
		EndIf
		cOpcBox += ( "C=" + OemToAnsi(STR0140) + ";"	)	//"Plano de Saude"
		cOpcBox += ( "D=" + OemToAnsi(STR0141) + ";"	)	//"Vale Refeicao"
		cOpcBox += ( "E=" + OemToAnsi(STR0142) + ";"	)	//"Vale Alimentacao"
		If cPaisLoc == "BRA"
			cOpcBox += ( "F=" + OemToAnsi(STR0143) + ";"	)	//"PLR"  
			cOpcBox += ( "G=" + OemToAnsi(STR0148) + ";"	)	//"Salario Incorporado"
		EndIf
		cOpcBox += ( "H=" + OemToAnsi(STR0149) + ";"	)	//"Ponto ELetronico"
		cOpcBox += ( "I=" + OemToAnsi(STR0150) + ";"   )   //"Outros Beneficios"
		cOpcBox += ( "K=" + OemToAnsi(STR0155) + ";"   )   //"Valores Extras"
		If lGestPubl
			cOpcBox += ( "L=" + OemToAnsi(STR0161) + ";"	)	//"Férias Servidores"
			cOpcBox += ( "M=" + OemToAnsi(STR0162) + ";"   )   //"Férias Indenizadas"
		EndIf
		If cPaisLoc == "BRA" .And. !lGestPubl
			cOpcBox += ( "N=" + OemToAnsi(STR0163) + ";"   )   //"Complementar"
		EndIf
		If cPaisLoc == "BRA" .And. lOpeSoc
			cOpcBox += ( "O=" + OemToAnsi(STR0164) + ";"   )   //"Benefícios Org. Públicos."
		EndIf

		If cPaisLoc == "RUS"
			cOpcBox := ( "1=" + OemToAnsi(STR0071) + ";"	)	//"Folha de Pagamento"
			cOpcBox += ( "2=" + OemToAnsi(STR0072) + ";"	)	//"Adiantamento"
			cOpcBox += ( "3=" + OemToAnsi(STR0073) + ";"	)	//"Ferias"
			cOpcBox += ( "4=" + OemToAnsi(STR0074) + ";"	)	//"Rescisao"
			cOpcBox += ( "7=" + OemToAnsi(STR0077) + ";"	)	//"Outros"
		EndIf
	Else

		Do Case
			Case ( cOpcDesc == "1" ) ; ( cOpcBox := OemToAnsi(STR0071) )	//"Folha de Pagamento"
			Case ( cOpcDesc == "2" ) ; ( cOpcBox := OemToAnsi(STR0072) )	//"Adiantamento"
			Case ( cOpcDesc == "3" ) ; ( cOpcBox := OemToAnsi(STR0073) )	//"Ferias"
			Case ( cOpcDesc == "4" ) ; ( cOpcBox := OemToAnsi(STR0074) )	//"Rescisao"
			Case ( cOpcDesc == "5" ) ; ( cOpcBox := OemToAnsi(STR0075) )	//"13o. Salario (1a. Parcela)"
			Case ( cOpcDesc == "6" ) ; ( cOpcBox := OemToAnsi(STR0076) )	//"13o. Salario (2a. Parcela)"
			Case ( cOpcDesc == "7" ) ; ( cOpcBox := OemToAnsi(STR0077) )	//"Outros"
			Case ( cOpcDesc == "8" ) ; ( cOpcBox := OemToAnsi(STR0078) )	//"Vale Transporte"
			Case ( cOpcDesc == "9" ) ; ( cOpcBox := OemToAnsi(STR0084) )	//"Autonomos"
			Case ( cOpcDesc == "A" ) ; ( cOpcBox := OemToAnsi(STR0093) )	//"Aplicacao de Rescisao"
			Case ( cOpcDesc == "B" ) ; ( cOpcBox := OemToAnsi(STR0133) )	//"Quinquenio"
			Case ( cOpcDesc == "C" ) ; ( cOpcBox := OemToAnsi(STR0140) )	//"Plano de Saude"
			Case ( cOpcDesc == "D" ) ; ( cOpcBox := OemToAnsi(STR0141) )	//"Vale Refeicao"
			Case ( cOpcDesc == "E" ) ; ( cOpcBox := OemToAnsi(STR0142) )	//"Vale Alimentacao"
			Case ( cOpcDesc == "F" ) ; ( cOpcBox := OemToAnsi(STR0143) )	//"PLR"     
			Case ( cOpcDesc == "G" ) ; ( cOpcBox := OemToAnsi(STR0148) )	//"Salario Incorporado"
			Case ( cOpcDesc == "H" ) ; ( cOpcBox := OemToAnsi(STR0149) )	//"Ponto Eletronico"
			Case ( cOpcDesc == "I" ) ; ( cOpcBox := OemToAnsi(STR0150) )	//"Outros Beneficios"
			Case ( cOpcDesc == "K" ) ; ( cOpcBox := OemToAnsi(STR0155) )	//"Valores Extras"
			Case ( cOpcDesc == "L" ) ; ( cOpcBox := OemToAnsi(STR0161) )	//"Férias Servidores"
			Case ( cOpcDesc == "M" ) ; ( cOpcBox := OemToAnsi(STR0162) )	//"Férias Indenizadas"
			Case ( cOpcDesc == "N" ) ; ( cOpcBox := OemToAnsi(STR0163) )	//"Complementar"
			Case ( cOpcDesc == "O" ) ; ( cOpcBox := OemToAnsi(STR0164) )	//"Benefícios Org. Públicos."
		End Case

	EndIf

Else

	cOpcBox := "123456789ACDEHIK"
	If cPaisLoc == "BOL"
		cOpcBox += "B"		
	EndIf
	If cPaisLoc == "BRA"
		cOpcBox += "FG"
	EndIf
	If lGestPubl
		cOpcBox += "LM"
	EndIf
	If cPaisLoc == "BRA" .And. !lGestPubl
		cOpcBox += "N"
	EndIf
	If cPaisLoc == "BRA" .And. lOpeSoc
		cOpcBox += "O"
	EndIf
EndIf

Return( cOpcBox )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RyTipoVld		³Autor³Mauricio Takakura  ³ Data ³11/02/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar o conteudo do campo RY_TIPO  	                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RyTipoVld()   												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID do campo RY_TIPO                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³           													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³NIL                                        					³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RyTipoVld()

Local lRyTipoVld := .T.

Begin Sequence

	If !( lRyTipoVld := NaoVazio() )
		Break
	EndIf

	If !( lRyTipoVld := Pertence( RyTipoBox( .T. ) ) )
		Break
	EndIf

End Sequence

Return( lRyTipoVld )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RyDesObsInit ³Autor³Marinaldo de Jesus    ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Inicializadora padrao do campo RY_DESOBS				    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO para o campo RY_DESOBS	                        ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RyDesObsInit()
Return( IF( Inclui , "" , MsMm(SRY->RY_CODOBS , 80 ) ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RyAliasVld   ³Autor³Marinaldo de Jesus    ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o conteudo do campo RY_ALIAS					    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID para o campo RY_ALIAS								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RyAliasVld()

Local lRyAliasVld := .T.

Begin Sequence

	If !( lRyAliasVld := NaoVazio() )
		Break
	EndIf

	If !( lRyAliasVld := ExistCpo("SX2") )
		Break
	EndIf

End Sequence

Return( lRyAliasVld )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RyAliasSX2Init³Autor³Mauricio Takakura    ³ Data ³30/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Inicializadora padrao do campo RY_ALIAS                   	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO para o campo RY_ALIAS 	                        ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RyAliasSX2Init()
Return( SubStr( RyGetAliasSX2( .T. ) , 2, 3 ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RyGetAliasSX2   ³Autor³Mauricio Takakura  ³ Data ³30/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carregar em ListBox os arquivos abertos do SX2              ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RyGetAliasSX2()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_CBOX do campo RY_ALIAS                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³cOpcBox														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³NIL                                        					³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RyGetAliasSX2( lValid , lRetDesc , cOpcDesc )

Local aListAlias 	:= {}

Local cOpcBox		:= ""
Local cAliasSX2		:= ""
Local cArqSX2		:= ""

Local nX

DEFAULT lValid		:= .F.
DEFAULT lRetDesc	:= .F.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carregar o Alias em SX2                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
fSeleArq( "" 			,;	// utilizado na janela (nesta opcao estara desativado)
		 .T. 			,;	// se carrega um item em branco
		 @aListAlias	,;	// array com os Alias
		 .F.			,;	// se mostra janela com os alias
		)				// funcao em GpexFun

If !( lValid )

	If !( lRetDesc )
		For nX := 1 To Len(aListAlias)
			cAliasSX2 := aListAlias[nX, 1]
			cArqSX2	:= aListAlias[nX, 2]
			If !Empty( cAliasSX2 )
				cOpcBox += ( cAliasSX2 + "=" + cArqSX2 + "; ")
			EndIf
		Next nX

		cOpcBox := SubStr( cOpcBox , 1 , Len( cOpcBox ) - 2 )
	Else
		nX := aScan( aListAlias, { |x| x[1] == cOpcDesc })
		If nX > 0
			( cOpcBox := aListAlias[nX, 2] )
		EndIf
	EndIf
Else
	cOpcBox := '"'
	For nX := 1 To Len(aListAlias)
		cAliasSX2 := aListAlias[nX, 1]
		cOpcBox += ( cAliasSX2 )
	Next nX
	cOpcBox += '"'
EndIf

Return( cOpcBox )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RmCalculoVld	³Autor³Marinaldo de Jesus ³ Data ³01/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar o conteudo do campo RM_CALCULO                      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RmCalculoVld()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID do campo RM_CALCULO                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRmCalculoVld												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³NIL                                        					³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RmCalculoVld()

Local lRmCalculoVld

Begin Sequence

	If !( lRmCalculoVld := NaoVazio() )
		Break
	EndIf

	If !( lRmCalculoVld := ExistCpo( "SRY" ) )
		Break
	EndIf

End Sequence

Return( lRmCalculoVld  )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RmHabilitVld	³Autor³Marinaldo de Jesus ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar o conteudo do campo RM_HABILIT	                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RyCalculoVld()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID do campo RM_HABILIT                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRyDescVld													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³NIL                                        					³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RmHabilitVld()

Local lRmHabilitVld := .T.

Begin Sequence

	If !( lRmHabilitVld := NaoVazio() )
		Break
	EndIf
	
	If !( lRmHabilitVld := Pertence( RmHabilitBox( .T. ) ) )
		Break
	EndIf

End Sequence

Return( lRmHabilitVld )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RmHabilitBox ³Autor³Marinaldo de Jesus    ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Funcao para Retornar as Opcoes do Campo RM_HABILIT         	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_CBOX para o campo RM_HABILIT	                         	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RmHabilitBox( lValid , lRetDesc , cOpcDesc )

Local cOpcBox

DEFAULT lValid		:= .F.
DEFAULT lRetDesc	:= .F.

If !( lValid )

	If !( lRetDesc )

		cOpcBox := ( "1=" + STR0064 + ";"	)	//"Sim"
		cOpcBox += ( "2=" + STR0065			)	//"Nao"

	Else

		Do Case
			Case ( cOpcDesc == "1" ) ; ( cOpcBox := STR0064 )	//"Sim"
			Case ( cOpcDesc == "2" ) ; ( cOpcBox := STR0065 )	//"Nao"
		End Case

	EndIf

Else

	cOpcBox := "12"

EndIf

Return( cOpcBox )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RmHabilitInit³Autor³Marinaldo de Jesus    ³ Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Inicializadora padrao do campo RM_HABILIT                  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_RELACAO para o campo RM_HABILIT	                        ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RmHabilitInit()
Return( SubStr( RmHabilitBox( .T. ) , 1, 1 ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RmSeqVld		³Autor³Marinaldo de Jesus ³ Data ³01/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar o conteudo do campo RM_SEQ                      	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RmSeqVld()													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID do campo RM_SEQ                                	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRmSeqVld													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³NIL                                        					³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RmSeqVld()

Local lRmSeqVld

Begin Sequence

	If !( lRmSeqVld := NaoVazio() )
		Break
	EndIf

	If !( FunName() == "GPEA160M" )
		If !( lRmSeqVld := ( ( Val( M->RM_SEQ ) % 10 ) # 0 ) )
			Break
		EndIf
	EndIf
	If !( lRmSeqVld := Gpea160SeqRot() )
		Break
	EndIf
	
End Sequence

Return( lRmSeqVld  )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RmDescricVld    ³Autor³Marinaldo de Jesus ³ Data ³01/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar o conteudo do campo RM_DESCRIC                  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RmDescricVld ()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID do campo RM_DESCRIC                              	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRmDescricVld 												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³NIL                                        					³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RmDescricVld()

Local lRmDescricVld

Begin Sequence

	If !( lRmDescricVld := NaoVazio() )
		Break
	EndIf

	If !( lRmDescricVld := Texto() )
		Break
	EndIf

End Sequence

Return( lRmDescricVld )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RmFormulaVld	³Autor³Marinaldo de Jesus ³ Data ³01/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar o conteudo do campo RM_FORMULA                      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RmFormulaVld()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID do campo RM_FORMULA                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRmFormulaVld												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³NIL                                        					³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RmFormulaVld()

Local cRmFormula
Local lRmFormulaVld

Begin Sequence

	If !( lRmFormulaVld := NaoVazio() )
		Break
	EndIf

	cRmFormula := SubStr( M->RM_FORMULA , 1 , ( At( "(" , M->RM_FORMULA ) - 1 ) )
	If !( lRmFormulaVld := ExistCpo("RC2", Padr( cRmFormula ,TamSx3("RC2_ORIGEM")[1]+TamSx3("RC2_CODIGO")[1]),1,"NOEXISTFRM") )
		Break
	EndIf

End Sequence

Return( lRmFormulaVld  )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RyOrdinarVld	³Autor³Mauricio T. Takakura³Data ³07/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar o conteudo do campo RY_ORDINAR                      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RyOrdinarVld()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID do campo RY_ORDINAR                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRyOrdinarVld												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³NIL                                        					³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RyOrdinarVld()

Local cMsgHelp

Local lRyOrdinarVld := .T.

Begin Sequence
	If !Pertence('12')
		lRyOrdinarVld := .F.
		Break
	EndIf
	If !Empty(cRotOrd) .and. M->RY_ORDINAR == "1" .and. ( M->RY_CALCULO != cRotOrd)
		cMsgHelp := STR0094 //'O Roteiro Ordinário já esta cadastrado!'
		Help( "" , 1 , "ORDINAR" , NIL , OemToAnsi( cMsgHelp ) , 1 , 0 )
		lRyOrdinarVld := .F.
	EndIf
End Sequence
	
Return( lRyOrdinarVld )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Gpea160SRot     ³Autor³Marinaldo de Jesus ³ Data ³18/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica se o Roteiro que esta sendo incluido e Padrao      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea160SRot( cRot )											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA160														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³lRet														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                           									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea160SRot( cRot )

Local lNotSistem	:= .T.
Local lManutence    := ( FunName() == "GPEA160M" )

Local aRotPadrao

Local cRotPadrao
Local cMsgHelp

Local nPosRot
Local nRot
Local nRots

Begin Sequence

	If ( Type( "Inclui" ) <> "L" )
		Private Inclui := .F.
	EndIf

	If ( Inclui )
	
		If !( lManutence );

			aRotPadrao		:= {}
			cRotPadrao		:= ""
			fGeraRoteiro( NIL , @aRotPadrao , .T. )
			DEFAULT cRot	:= &( ReadVar() )
			cRot := Upper( AllTrim( cRot ) )
			nRots := Len( aRotPadrao )
			lNotSistem := !( nPosRot := aScan( aRotPadrao , { |x| x[1] == cRot } ) > 0 )
			If !( lNotSistem )
				cMsgHelp	:= STR0059	//"Nao é Possivel a Inclusão de Roteiros Padroes."
				cMsgHelp	+= CRLF
				cMsgHelp	+= STR0060	//"Selecione um Nome do Roteiro que não conste na"
				cMsgHelp	+= CRLF
				cMsgHelp	+= STR0061	//"Listagem abaixo:"
				cMsgHelp	+= CRLF
				cMsgHelp	+= CRLF
				For nRot := 1 To nRots
					cMsgHelp	+= ( aRotPadrao [ nRot , 1 ] + " -> " + aRotPadrao [ nRot , 2 ] )
					cMsgHelp	+= CRLF
				Next nRot
				Help( "" , 1 , "NOROTPAD" , NIL , OemToAnsi( cMsgHelp ) , 1 , 0 )
				Break
			EndIf

		EndIf
		
		If !( lNotSistem := !FindFunction( GetFunRot( xFilial( "SRY" ) , cRot , .F. , NIL , .F. , NIL , Inclui ) ) )
			cMsgHelp := STR0069	//"Ja Existe Função Compilada com o Nome Deste Roteiro"
			cMsgHelp += CRLF
			cMsgHelp += STR0070	//"Informe um Novo Nome."
			Help( "" , 1 , "NOROTVALID" , NIL , OemToAnsi( cMsgHelp ) , 1 , 0 )
			Break
		EndIf               
	
	EndIf

End Sequence
	
Return( lNotSistem )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Gpea160Copy	    ³Autor³Marinaldo de Jesus ³ Data ³18/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Copia Linha do Roteiro										³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea160Copy()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA160														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³Array contendo a Copia da Linha aTual				 		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                           									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpea160Copy()
Return( aClone( aCols[ n ] ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Gpea160Paste    ³Autor³Marinaldo de Jesus ³ Data ³18/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Copia Linha do Roteiro										³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea160Paste( aPaste )										³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA160														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³lRet														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                           									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpea160Paste( aPaste )

Local nSrmSeq 	:= GdFieldPos( "RM_SEQ" )
Local cSeq		:= aCols[ n , nSrmSeq ]
Local cCalculo	:= GetMemVar( "RY_CALCULO" )

If !Empty( aPaste )
	If ( ( Val( cSeq )%10 != 0 ) .or. Empty( cSeq ) )
		aCols[n] 			 := aClone( aPaste )
		aCols[ n , nSrmSeq ] := cSeq
	Else
		//"O Roteiro: " " e um Roteiro Padrao e nao pode ser alterado"###"Atencao"
		MsgAlert( OemToAnsi(STR0012) + cCalculo + " - " + aCols[ n , nSrmSeq ] + OemToAnsi(STR0013) , OemToAnsi(STR0014) )
	EndIf
EndIf

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Gpea160SeqRot ³Autor³Marinaldo de Jesus   ³ Data ³18/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Sequencia dos Roteiros										³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea160SeqRot()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Inicializador Padrao do RC3_SEQFOR                          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³Sequencia da Formula										³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³															³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea160SeqRot()

Local cVar		:= ""
Local cSeq		:= ""
Local lRet		:= .T.
Local lGpea161	:= IsInCallStack("GPEA161")
Local nTamSx3	:= GetSx3Cache( "RM_SEQ" , "X3_TAMANHO" )
Local nSrmSeq	:= 0
Local nPos		:= 0
Local nLinAux	:= 0
Local nX		:= 0
Local oModel
Local oGrid

cVar := &( ReadVar() )
cSeq := StrZero( Val( cVar ) , nTamSX3 )

If lGPea161
	oModel 	:= FWModelActive()
	oGrid	:= oModel:GetModel( "GPEA161_SRM" )
	nLinAux	:= oGrid:GetLine()
	For nX := 1 to oGrid:Length()
		If !(nX == nLinAux)
			oGrid:GoLine(nX)
			If oGrid:GetValue("RM_SEQ") == cSeq
				nPos := nX
				Exit
			EndIf
		EndIf
		n := nLinAux
	Next nX
	oGrid:GoLine(nLinAux)
Else
	nSrmSeq := GdFieldPos( "RM_SEQ" )
	nPos := aScan( aCols , { |x,y| x[ nSrmSeq ] == cSeq .and. y != n } )
EndIf

If ( lRet := ( nPos == 0 .or. nPos == n ) )
	&( ReadVar() ) := cSeq
Else
	//"Ja Existe a Sequencia Informada. Digite uma nova sequencia"###"Sequencia Invalida"
	Help( "" , 1 , STR0029 , NIL , OemToAnsi( STR0028 ) , 1 , 0 )
EndIf

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Gpea160RotGer ³Autor³Marinaldo de Jesus   ³ Data ³14/04/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Gerar os Roteiros Padroes									³	
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea160RotGer( lInitProc )									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA160                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL                 										³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³															³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea160RotGer( lInitProc, lProc2BarG, lGP290REPL, aRotBkp, aSRYHBKP, aSRMHBkp, aSYPHBkp, cRoteiro, lForcaComp )

Local aRotPadrao	:= {}
Local aTitleLog		:= {}
Local aRotAmbos		:= {}

Local cMsg			:= OemToAnsi( STR0035 )	//"Carregando o Roteiro Padr„o: "
Local cTimeIni		:= Time()

Local nPos			:= 0
Local nPosIni		:= 1
Local nRot			:= 0
Local nRots			:= 0

Local lGestPubl		:= IIF(ExistFunc("fUsaGFP"),fUsaGFP(),.F.)

DEFAULT lInitProc 	:= .F.
DEFAULT lGP290REPL	:= .F.
DEFAULT lForcaComp  := .F.
DEFAULT aRotBkp		:= {}
DEFAULT aSRYHBKP	:= {}
DEFAULT aSRMHBkp	:= {}
DEFAULT aSYPHBkp	:= {}
DEFAULT cRoteiro	:= ""

lManutence := If(Type("lManutence") == "U",.F.,lManutence)

If ( lInitProc )
	lInitProc := .F.
	//"Carregando Roteiros Padr”es."###"Aguarde..."
	Proc2BarGauge( { || Gpea160RotGer( lInitProc , .T. ) } , OemToAnsi( STR0034 +  STR0033 ) , NIL , NIL , .F. , .T. , .F. , .F. )
	
	If lManutence .and. !Empty(aIdErro)
		aAdd( aTitleLog, STR0145 )   //"Identificadores utilizados nos roteiros que não possuem relacionamento com verbas:"
		aAdd(aIdErro,{})
		aAdd(aIdErro,STR0146 ) //"Crie as verbas antes de gerar um novo fonte de roteiro para que o novo arquivo esteja integro."
		MsAguarde( { || fMakeLog( {aIdErro} , aTitleLog , "GPEA160" , NIL , FunName() , STR0147 ) } ,  STR0147 ) //"Log de Ocorrências na Criação dos Roteiros"
	Else
		RotGetErr() //aPAGA LOG
	EndIf	

	Return( NIL )
EndIf

Private c__Roteiro := ""

fGeraRoteiro( NIL , @aRotPadrao , .T., Nil, Nil, lGP290REPL, @aRotBkp, @aSRYHBKP, @aSRMHBkp, @aSYPHBkp )
If ( ( nRots := Len( aRotPadrao ) ) > 0 )
	DEFAULT lProc2BarG := .F.
	If ( lProc2BarG )
		BarGauge1Set( nRots )
	EndIf
	If lGP290REPL .And. !Empty(cRoteiro)
		If (nPos := aScan( aRotPadrao, { |x| x[1] == cRoteiro } )) > 0
			nPosIni := nPos
			nRots 	:= nPos
		EndIf
	EndIf

	For nRot := nPosIni To nRots
		c__Roteiro := aRotPadrao[ nRot , 01 ]
		If ( lProc2BarG )
			IncPrcG1Time( cMsg + c__Roteiro , nRots , cTimeIni , .T. , 1 , 1 , .T. )
		EndIf
		If lManutence
			fGeraRoteiro( cFilAnt,,,@aIdErro )
		Else
			fGeraRoteiro( cFilAnt, @aRotPadrao, Nil, Nil, Nil, lGP290REPL, aRotBkp, aSRYHBKP, aSRMHBkp, aSYPHBkp, lForcaComp )
		EndIf
	Next nRot
EndIf

If lGestPubl
	fGeraRoteiro( NIL , @aRotAmbos , .T.,,.T. )
	For nRot := 1 To LEN(aRotAmbos)
		c__Roteiro := aRotAmbos[ nRot , 01 ]
		If lManutence
			fGeraRoteiro( cFilAnt,,,@aIdErro,.T. )
		Else
			fGeraRoteiro( cFilAnt , , , , .T. )
		EndIf
	Next nRot
EndIf

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Gpea160BoxOpc ³Autor³Marinaldo de Jesus   ³ Data ³15/04/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Sequencia dos Roteiros										³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³#Gpea160BoxOpc()											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³X3_CBOX do campo RM_CHAVE                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³Opcoes para o ComboBox da Enchoice/GetDados					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³															³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea160BoxOpc()

Local cOpcBox := ""

cOpcBox += ( "0=" + STR0031 + ";"	)	//"Nao"	 
cOpcBox += ( "1=" + STR0032			)	//"Sim"

Return( cOpcBox )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RyPergVld		 ³Autor³Tatiane Matias     ³ Data ³23/11/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar o conteudo do campo RY_PERGUNT                      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RyPergVld()						               						³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³X3_VALID do campo RY_PERGUNT                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRyPergVld																	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³NIL                                        				  		³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RyPergVld(cGrupo)

Local lRyPergVld := .T.

Begin Sequence

If Empty(cGrupo)
	Break
EndIf
	
dbSelectArea("SX1")   
dbSetOrder(1)
If !dbSeek(cGrupo)
	Help( " ", 1, "REGNOIS" )
	lRyPergVld 	 := .F.
EndIf

End Sequence

Return( lRyPergVld )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³fPergunte ³ Autor ³ Tatiane Matias        ³ Data ³ 05/12/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Selecionar a Pergunte                              		     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fPergunte() 												  			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 												  				  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fPergunte(l1Elem, lTipoRet)

Local cTitulo	:="Pergunte"
Local nFor		:= 0
Local MvPar
Local MvParDef	:=""
Local MvRetor	:= ""

Private aSit:={}
l1Elem := If (l1Elem = Nil , .F. , .T.)

DEFAULT lTipoRet 	:= .T. 

cAlias := Alias() 					// Salva Alias Anterior

If lExecPerg
	IF lTipoRet
		MvPar:=&(Alltrim(ReadVar()))	// Carrega Nome da Variavel do Get em Questao
		mvRet:=Alltrim(ReadVar())		// Iguala Nome da Variavel ao Nome variavel de Retorno
	EndIf

	dbSelectArea("SX1")
	If dbSeek("GP")
		CursorWait()
		While !Eof() .And. substr(SX1->X1_GRUPO,1,2) == "GP"
			If SX1->X1_ORDEM == "01"
				Aadd(aSit, SX1->X1_GRUPO + " - ")
				MvParDef += SX1->X1_GRUPO
			EndIf
			dbSkip()
		Enddo  
		CursorArrow()
	EndIf
	
	IF lTipoRet
		IF f_Opcoes(@MvPar,cTitulo,aSit,MvParDef,,,l1Elem, 6)  // Chama funcao f_Opcoes
			CursorWait()
			For nFor := 1 To Len( mVpar ) Step 3
				If ( SubStr( mVpar , nFor , 3 ) # "***" )
					mvRetor += SubStr( mVpar , nFor , 3 )
				EndIf
			Next nFor
			&MvRet := Alltrim(Mvretor)
			CursorArrow()	
		EndIf	
	EndIf
EndIf
	
dbSelectArea(cAlias) // Retorna Alias

Return( IF( lTipoRet , .T. , MvParDef ) )
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
F U N C O E S   U T I L I Z A D A S   P A R A   G E R A C A O  D O  C O D I G O
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ/*/

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³Gpea160Ger	  ³Autor³ Marinaldo de Jesus  ³ Data ³19/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Chamar Programa Gerador de Programa de Roteiros Padrao    	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea160Ger()	          									³
ÃÄÄÄÄÄÄÄ.ÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico      												³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea160Ger()
Return( MsAguarde( { || GerGpexRot() } ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³GerGpexRot()  ³Autor³ Mauricio T. Takakura³ Data ³09/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gerar o Programa de Roteiro                                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GerGpexRot()	          									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³Generico      												³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GerGpexRot()

Local aLinesProg 	:= {}				// array com as linhas dos programas
Local aLinesFunc 	:= {}			 	// array com as linhas das funcoes dos itens SRM
Local aSRYMemo	 	:= {}				// campos memos da tabela SRY
Local aSRMMemo		:= {}				// campos memos da tabela SRM
Local aIniHdrSRY						// cabecalho da tabela SRY com os campos
Local aSRYVirtual						// campos virtuais de SRY
Local aIniHdrSRM						// cabecalho da tabela SRM com os campos
Local aSRMVirtual						// campos virtuais de SRM
Local aIniHdrSYP 						// Cabecalho da tabela SYP - Observacoes 
Local aSYPVirtual						// campos virtuais da tabela SYP

Local cArquivo 		:= ""			 	// nome do arquivo a ser gerado
Local cPath 		:= ""				// Path a gravar o arquivo
Local cRotNum 		:= "0000"			// numeracao do nome da funcao

Local cMsg								// mensagem de erro na geracao do arquivo PRX
Local cProg								// string a ser enviado ao arquivo PRX
Local cValueCampo						// montagem da string a ser enviado ao array
Local cNameFunc							// nome da funcao 
Local cTexto							// valor do campo do Header
Local cCodObs							// Codigo do Campo Memo
Local cFilSYP							// Filial do SYP - Codigo de Observacao

Local lSetCentury	:= __SetCentury("on")
Local lUsaGFP		:= IIF(ExistFunc("fUsaGFP"),fUsaGFP(),.F.)		//define se usa Folha Pública
Local lSRYModulo 	:= SRY->(ColumnPos("RY_MODULO")) > 0
Local aModRot		:= {}

Local nArq								// situacao do arquivo
Local nUsado							// campos utilizados

Local nRecno 		:= 0				// controla o numero do vetor a cada registro inserido

Local nLineMemo							// numero de linhas existentes no campo memo
Local nPosMemo							// posicao do campo memo virtual
Local nX
Local nY
Local nPosSeqFil
Local nPosMod		:= 0
Local cIdioma		:= FWRetIdiom()		//Retorna Idioma Atual

If lUsaGFP
	cArquivo 	:= ( "GPROT" + "GFP" + ".PRX" )
Else
	cArquivo 	:= ( "GPROT" + cPaisLoc + ".PRX" )
EndIf

If !lSRYModulo
	aAdd(aModRot, { '131','1'} )
	aAdd(aModRot, { '132','1'} )
	aAdd(aModRot, { 'ADI','1'} )
	aAdd(aModRot, { 'AUT','1'} )
	aAdd(aModRot, { 'BEN','3'} )
	aAdd(aModRot, { 'FER','1'} )
	aAdd(aModRot, { 'FOL','1'} )
	aAdd(aModRot, { 'INC','1'} )
	aAdd(aModRot, { 'MUV','1'} )
	aAdd(aModRot, { 'PLA','3'} )
	aAdd(aModRot, { 'PLR','1'} )
	aAdd(aModRot, { 'RES','1'} )
	aAdd(aModRot, { 'VAL','3'} )
	aAdd(aModRot, { 'VEX','1'} )
	aAdd(aModRot, { 'VRF','3'} )
	aAdd(aModRot, { 'VTR','3'} )
Endif

aIniHdrSRY	:= SRY->( GdMontaHeader( @nUsado, @aSRYVirtual, NIL, NIL, NIL, .T.,.T. ) )
aIniHdrSRM	:= SRM->( GdMontaHeader( @nUsado, @aSRMVirtual, NIL, NIL, NIL, .T.,.T. ) )
aIniHdrSYP  := SYP->( GdMontaHeader( @nUsado, @aSYPVirtual, NIL, NIL, NIL, .T.,.T. ) )
cFilSYP 	:= xFilial("SYP")

nPosSeqFil := GdFieldPos("RY_SEQFIL",aIniHdrSRY)

If nPosSeqFil > 0
	aDel(aIniHdrSRY,nPosSeqFil)
	aSize(aIniHdrSRY,Len(aIniHdrSRY)-1)
EndIf

Begin Sequence
			  								       // mostra drives   mostra hard disk retorna diretorio
	cPath := cGetFile("",OemToAnsi(STR0042),0,,.F.,GETF_LOCALFLOPPY + GETF_LOCALHARD + GETF_RETDIRECTORY,,) //"Selecione o Diretorio"
	If Empty(cPath)
		Break
	EndIf
	cArquivo := cPath + cArquivo

	If File(cArquivo)
		If !(MsgYesNo( OemToAnsi( STR0043 ),;	// "O Arquivo ja Existe !! Deseja Sobrescrer?"
 		 			   OemToAnsi( STR0014 ) ;	//"Aten‡„o"
					))
			Break
		EndIf
	EndIf

	nArq := MSFCREATE(cArquivo, 0)
	IF Ferror() # 0 .And. nArq = -1 
		cMsg := STR0044 + STR(Ferror(),3) //-- "Erro de Gravacao do Arquivo - Codigo DOS: "
		MsgInfo( cMsg, STR0014 )
		Return(.F.)
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cabecalho da funcao                                          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aAdd(aLinesProg, '#INCLUDE "PROTHEUS.CH"' + CRLF + CRLF)
	aAdd(aLinesProg, "/*/" + CRLF)
	aAdd(aLinesProg, "ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿" + CRLF)
	aAdd(aLinesProg, "³Fun‡…o    ³GpRot" + If(lUsaGFP,"GFP",cPaisLoc) + "      " + "³Autor³ Gerado pelo sistema ³ Data ³" + SubStr(DtoS(date()),7,2)+"/"+SubStr(DtoS(date()),5,2)+"/"+SubStr(DtoS(date()),1,4) + "³" + CRLF)
	aAdd(aLinesProg, "ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´" + CRLF)
	aAdd(aLinesProg, "³Descri‡…o ³Roteiros padroes                                            ³" + CRLF)
	aAdd(aLinesProg, "ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´" + CRLF)
	aAdd(aLinesProg, "³Sintaxe   ³                                                            ³" + CRLF)
	aAdd(aLinesProg, "ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´" + CRLF)
	aAdd(aLinesProg, "³Parametros³<Vide Parametros Formais>                                   ³" + CRLF)
	aAdd(aLinesProg, "ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´" + CRLF)
	aAdd(aLinesProg, "³ Uso      ³Generico                                                    ³" + CRLF)
	aAdd(aLinesProg, "ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/" + CRLF)
	aAdd(aLinesProg, "Function GpRot" + If(lUsaGFP,"GFP",cPaisLoc) + "(aRotSRY, aFatherHeader, aChildHeader, aMemoHeader)" + CRLF)
	aAdd(aLinesProg, 'Local lRet		:= .T.' + CRLF)
	aAdd(aLinesProg, "Local aItensSRY	:= {}" + CRLF) 
	aAdd(aLinesProg, "Local aSYPHeader	:= {}" + CRLF)
	aAdd(aLinesProg, "Local aSRYHeader	:= {}" + CRLF)	
	aAdd(aLinesProg, "Local aSRMHeader	:= {}" + CRLF + CRLF)
	
	aAdd(aLinesProg, "/*/" + CRLF)
	aAdd(aLinesProg, "ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿" + CRLF)
	aAdd(aLinesProg, "³ Cabecalho de SRY e SRM gerado pelo Roteiro padrao            ³" + CRLF)
	aAdd(aLinesProg, "ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/" + CRLF)
	cMyCampo := ""
	For nX := 1 To Len(aIniHdrSRY)
		cProg := ""
		For nY := 1 To Len(aIniHdrSRY[nX])
		
			If ValType(aIniHdrSRY[nX,nY])=="C" .And. SubStr(aIniHdrSRY[nX,nY],1,3) == "RY_"
				cMyCampo := Alltrim(aIniHdrSRY[nX,nY])
			EndIf
			If !Empty(cMyCampo) .And. ValType(aIniHdrSRY[nX,nY])=="C" .And. Len(aIniHdrSRY[nX,nY]) > 130
				
				aSvAreaSX3 := SX3->(GetArea())
				SX3->(DbSetOrder(2))
				SX3->(DbSeek(cMyCampo))
				
				cTexto := Iif( cIdioma =="pt-br", Alltrim(SX3->X3_CBOX), Iif( cIdioma =="es", Alltrim(SX3->X3_CBOXSPA), Alltrim(SX3->X3_CBOXENG) ))
				
				RestArea(aSvAreaSX3)
			Else
				cTexto := If(ValType(aIniHdrSRY[nX,nY])=="N", AllTrim(Str(aIniHdrSRY[nX,nY])),;
							   	If(ValType(aIniHdrSRY[nX,nY])=="L", Transform(aIniHdrSRY[nX, nY],"@!"),;
							   	   aIniHdrSRY[nX, nY]))
			EndIf
			cTexto := StrTran(cTexto, "'", '"')
			cProg += "'" + cTexto + "'"
			If nY < Len(aIniHdrSRY[nX])
				cProg += ","
			EndIf
		Next nY

		If !Empty(cProg)
			aAdd(aLinesProg, "aAdd(aSRYHeader, " + '{ ' + cProg + ' })' + CRLF)
		EndIf
	Next nX
	
	//Quando o campo RY_MODULO não existe na base, a rotina 'Força' a geração do campo e conteudo nas rotinas de geracao de roteiro
	If !lSRYModulo .And. !Empty(cProg) .And. cPaisLoc == "BRA" .And. cModulo == "GPE"
		cProg := "'Modulo','RY_MODULO','9','1','0','Pertence("+'" 123")'+"'"+",'€€€€€€€€€€€€€€ ','C','      ','R','1=GPE;2=GFP;3=Ambos                                                                                                             ','','','A','','','.F.' "
		aAdd(aLinesProg, "aAdd(aSRYHeader, " + '{ ' + cProg + ' })' + CRLF)     
	Endif   
	
	aAdd(aLinesProg, CRLF)
         
	For nX := 1 To Len(aIniHdrSRM)
		cProg := ""
		For nY := 1 To Len(aIniHdrSRM[nX])
			cTexto := If(ValType(aIniHdrSRM[nX,nY])=="N", AllTrim(Str(aIniHdrSRM[nX,nY])),;
						   	If(ValType(aIniHdrSRM[nX,nY])=="L", Transform(aIniHdrSRM[nX, nY],"@!"),;
						   	   aIniHdrSRM[nX, nY]))
			cTexto := StrTran(cTexto, "'", '"')
			cProg += "'" + cTexto + "'"
			If nY < Len(aIniHdrSRM[nX])
				cProg += ","
			EndIf
		Next nY
		If !Empty(cProg)
			aAdd(aLinesProg, "aAdd(aSRMHeader, " + '{ ' + cProg + ' })' + CRLF)
		EndIf
	Next nX
	aAdd(aLinesProg, CRLF)

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cabecalho das Observacoes                                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	For nX := 1 To Len(aIniHdrSYP)
		cProg := ""
		For nY := 1 To Len(aIniHdrSYP[nX])
			cTexto := If(ValType(aIniHdrSYP[nX,nY])=="N", AllTrim(Str(aIniHdrSYP[nX,nY])),;
						   	If(ValType(aIniHdrSYP[nX,nY])=="L", Transform(aIniHdrSYP[nX, nY],"@!"),;
						   	   aIniHdrSYP[nX, nY]))
			cTexto := StrTran(cTexto, "'", '"')
			cProg += "'" + cTexto + "'"
			If nY < Len(aIniHdrSYP[nX])
				cProg += ","
			EndIf
		Next nY
		If !Empty(cProg)
			aAdd(aLinesProg, "aAdd(aSYPHeader, " + '{ ' + cProg + ' })' + CRLF)
		EndIf
	Next nX
	aAdd(aLinesProg, CRLF )

	aAdd(aLinesProg, "/*/" + CRLF)
	aAdd(aLinesProg, "ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿" + CRLF)
	aAdd(aLinesProg, "³ Validar a Estrutura das Tabela SRY e SRM com a do Cliente     ³" + CRLF)
	aAdd(aLinesProg, "ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/" + CRLF)
	aAdd(aLinesProg, 'lRet := fNewOldSx3(aSRYHeader, aSRMHeader, "SRY", "SRM",.F.)' + CRLF)
	aAdd(aLinesProg, 'lRet := fNewOldSx3(aSYPHeader, NIL, "SYP")' + CRLF + CRLF)

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Itens do Roteiro                                             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	SRY->(dbGoTop())
	SRY->( dbSetOrder( RetOrder( "SRY" , "RY_FILIAL+RY_CALCULO" ) ) )
	While !SRY->(Eof())

		DbSelectArea("SRY")
		If SRY->RY_Origem != "1" .OR. (lUsaGFP .AND. lSRYModulo .AND. SRY->RY_MODULO <> "2") 
		   SRY->(dbSkip())
		   Loop
		EndIf
		
		nRecno++
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Adiciona o cabecalho - SRY                                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cProg := "aAdd(aItensSRY, { "

		For nX := 1 To Len(aIniHdrSRY)
			cValueCampo := ""

			// campo memo normal //
			If aIniHdrSRY[nX,8] == "M" .and. (aScan(aSRYVirtual, aIniHdrSRY[nX,2]) == 0)
				nLineMemo := MlCount(aIniHdrSRY[nX,2], 80)

				For nY := 1 To nLineMemo
					cValueCampo += AllTrim(MemoLine(aIniHdrSRY[nX,2], 80, nY))
					If nY < nLineMemo
						cValueCampo += ' '
					EndIf
				Next nY

			// campo memo gravado em SYP - Virtual //
			ElseIf aIniHdrSRY[nX,8] == "M" .and. (aScan(aSRYVirtual, aIniHdrSRY[nX,2]) > 0)
				If ((nPosMemo := Ascan(aSRYMemo, { |x|  Upper(x[2]) == aIniHdrSRY[nX,2] })) > 0)
					cValueCampo += MSMM(&(SRY->(aSRYMemo[nPosMemo,1])),80)
					cValueCampo := StrTran(cValueCampo, CRLF, "\13\10")
				EndIf				
			ElseIF ( aScan( aSRYVirtual , aIniHdrSRY[nX,2]) > 0 )
				Loop
			ElseIf aIniHdrSRY[nX,8] == "N"
				cValueCampo += AllTrim(Str(&(aIniHdrSRY[nX,2])))
			ElseIf aIniHdrSRY[nX,8] == "D"
				cValueCampo += 'Ctod("' + DtoC(&(aIniHdrSRY[nX,2])) + '")'
			ElseIf aIniHdrSRY[nX,8] == "L"
				If &(aIniHdrSRY[nX,2])
					cValueCampo += ".T."
				Else
					cValueCampo += ".F."
				EndIf
			ElseIf "FILIAL" $ aIniHdrSRY[nX,2]
				cValueCampo += ""
			Else
				cValueCampo += AllTrim(&(aIniHdrSRY[nX,2]))
			EndIf
			cValueCampo := StrTran(cValueCampo, "'", '"')

			If (aIniHdrSRY[nX,8] != "N") .and. (aIniHdrSRY[nX,8] != "D") .and. (aIniHdrSRY[nX,8] != "L")
				cValueCampo := "'" + cValueCampo
				cValueCampo += "'"
			EndIf
			cProg += cValueCampo
			If nX < Len(aIniHdrSRY)
				cProg += ","
			EndIf
		Next nX
        
		If !lSRYModulo .And. !Empty(cProg) .And. cPaisLoc == "BRA" .And. cModulo == "GPE"
			nPosMod := Ascan(aModRot,{|x| Alltrim(x[1])== SRY->RY_CALCULO })
			If nPosMod > 0
				cProg += ",'" + aModRot[nPosMod,2] + "'"
			Endif	
		Endif
		
		cProg += "} )"
		aAdd(aLinesProg, cProg + CRLF)
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Adiciona os Itens do Roteiro - Tabela SRM, por funcao        ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		DbSelectArea("SRM")
		SRM->( dbSetOrder( RetOrder( "SRM", "RM_FILIAL+RM_CALCULO+RM_SEQ" ) ) )
        DbSeek(SRY->RY_FILIAL + SRY->RY_CALCULO)
		If SRM->(!Eof())
			cRotNum := Soma1( cRotNum )
			cNameFunc := "Rot" + If(lUsaGFP,"GFP",cPaisLoc) + cRotNum
			aAdd(aLinesFunc, "/*/" + CRLF)
			aAdd(aLinesFunc, "ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿" + CRLF)
			aAdd(aLinesFunc, "³Fun‡…o    ³"+cNameFunc + "    ³Autor³ Gerado pelo sistema ³ Data ³" + "          " + "³" + CRLF)
			aAdd(aLinesFunc, "ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/" + CRLF)
		
			cNameFunc := "Function Rot" + If(lUsaGFP,"GFP",cPaisLoc) + cRotNum + "(cROTEIRO , c__Roteiro , aItensSRM, aItensSYP)"
			aAdd(aLinesFunc, cNameFunc + CRLF)
			aAdd(aLinesFunc, "If c__Roteiro == cRoteiro " + CRLF)

		EndIf
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Codigo do campo de Observacoes                               ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cCodObs := SRY->RY_CODOBS

        While !(SRM->(Eof())) .and. SRM->RM_FILIAL == SRY->RY_FILIAL .and. SRM->RM_CALCULO == SRY->RY_CALCULO
        
        	If Mod(Val(SRM->(RM_SEQ)), 10) != 0
        		SRM->(dbSkip())
        		Loop
        	EndIf
        	
	        cProg := "	aAdd(aItensSRM, { "
			For nX := 1 To Len(aIniHdrSRM)
				cValueCampo := ""

				// campos memo normal //
				If aIniHdrSRM[nX,8] == "M" .and. (aScan(aSRMVirtual, aIniHdrSRM[nX,2]) == 0)
					nLineMemo := MlCount(aIniHdrSRM[nX,2], 254)
					For nY := 1 To nLineMemo
						cValueCampo += AllTrim(MemoLine(aIniHdrSRM[nX,2], 254, nY))
						If nY < nLineMemo
							cValueCampo += ' '
						EndIf
					Next nY
				
				// campo memo virtual - gravacao realizada em SYP //
				ElseIf aIniHdrSRM[nX,8] == "M" .and. (aScan(aSRMVirtual, aIniHdrSRM[nX,2]) > 0)
					If ((nPosMemo := Ascan(aSRMMemo, { |x|  Upper(x[2]) == aIniHdrSRM[nX,2] })) > 0)
						cValueCampo += MSMM(&(SRM->(aSRMMemo[nPosMemo,1])),80)
						cValueCampo := StrTran(cValueCampo, CRLF, "\13\10")
					EndIf
				ElseIF ( aScan(aSRMVirtual, aIniHdrSRM[nX,2]) > 0 )
					Loop
				ElseIf aIniHdrSRM[nX,8] == "N"
					cValueCampo += AllTrim(Str(&(aIniHdrSRM[nX,2])))
				ElseIf aIniHdrSRM[nX,8] == "D"
					cValueCampo += 'Ctod("' + DtoC(&(aIniHdrSRM[nX,2])) + '")'
				ElseIf aIniHdrSRM[nX,8] == "L"
					If &(aIniHdrSRM[nX,2])
						cValueCampo += ".T."
					Else
						cValueCampo += ".F."
					EndIf
				ElseIf "FILIAL" $ aIniHdrSRM[nX,2]
					cValueCampo += ""
				ElseIf "VERBA" $ aIniHdrSRM[nX,2]
					If Empty(&(aIniHdrSRM[nX,2]))
						cValueCampo += &(aIniHdrSRM[nX,2])
					Else						
						cValueCampo += PosAlias( "SRV" , &(aIniHdrSRM[nX,2]) , xFilial("SRV") , "RV_CODFOL" , 1 , .T. )
					EndIf
				Else
					cValueCampo += &(aIniHdrSRM[nX,2])
				EndIf
				cValueCampo := StrTran(cValueCampo, "'", '"')

				If (aIniHdrSRM[nX,8] != "N") .and. (aIniHdrSRM[nX,8] != "D") .and. (aIniHdrSRM[nX,8] != "L")
					cValueCampo := "'" + cValueCampo
					cValueCampo += "'"
				EndIf
	
				cProg += cValueCampo
				If nX < Len(aIniHdrSRM)
					cProg += ","
				EndIf
			Next nX
			cProg += "} )"
			aAdd(aLinesFunc, cProg + CRLF)
			SRM->(dbSkip())
	    Enddo
		aAdd(aLinesFunc, "" + CRLF)
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Adiciona os Itens do campo de Observacoes                    ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If !Empty(SRY->(RY_CODOBS))
			DbSelectArea("SYP")  
			DbSetOrder( 1 ) // YP_FILIAL+YP_CHAVE+YP_SEQ
			DbSeek(xFilial( "SYP")+SRY->(RY_CODOBS), .F.)
			Do while !Eof() .and. SYP->(YP_FILIAL+YP_CHAVE) == (xFilial( "SYP")+SRY->(RY_CODOBS))
				cProg := "	aAdd(aItensSYP, { "
				For nX := 1 To Len(aIniHdrSYP)
					cValueCampo := ""
					If ( aScan( aSYPVirtual , aIniHdrSYP[nX,2]) > 0 )
						Loop
					ElseIf aIniHdrSYP[nX,8] == "N"
						cValueCampo += AllTrim(Str(&(aIniHdrSYP[nX,2])))
					ElseIf aIniHdrSYP[nX,8] == "D"
						cValueCampo += 'Ctod("' + DtoC(&(aIniHdrSYP[nX,2])) + '")'
					ElseIf aIniHdrSYP[nX,8] == "L"
						If &(aIniHdrSYP[nX,2])
							cValueCampo += ".T."
						Else
							cValueCampo += ".F."
						EndIf
					ElseIf "FILIAL" $ aIniHdrSYP[nX,2]
						cValueCampo += ""
					Else
						cValueCampo += &(aIniHdrSYP[nX,2])
					EndIf

					cValueCampo := StrTran(cValueCampo, "'", '"')

					If (aIniHdrSYP[nX,8] != "N") .and. (aIniHdrSYP[nX,8] != "D") .and. (aIniHdrSYP[nX,8] != "L")
						cValueCampo := "'" + cValueCampo
						cValueCampo += "'"
					EndIf
	
					cProg += cValueCampo
					If nX < Len(aIniHdrSYP)
						cProg += ","
					EndIf
				Next nX
				cProg += "} )"
				aAdd(aLinesFunc, cProg + CRLF)
				SYP->( DbSkip() )
			EndDo
			aAdd(aLinesFunc, "" + CRLF)
		EndIf
		
		aAdd(aLinesFunc, "EndIf" + CRLF + CRLF)
		aAdd(aLinesFunc, "Return( Nil )" + CRLF + CRLF)

		DbSelectArea( "SRY" )
		SRY->( dbSkip() )
	Enddo

	aAdd(aLinesProg, CRLF)
	aAdd(aLinesProg, "aRotSRY := aClone(aItensSRY) " + CRLF)
	aAdd(aLinesProg, "aFatherHeader := aClone(aSRYHeader) " + CRLF)
	aAdd(aLinesProg, "aChildHeader := aClone(aSRMHeader) " + CRLF)
	aAdd(aLinesProg, "aMemoHeader := aClone(aSYPHeader) " + CRLF + CRLF)
	
	aAdd(aLinesProg, 'Return ( lRet )' + CRLF + CRLF)

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Transferir as linhas para dentro do programa                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    For nX := 1 To Len(aLinesProg)
	    Fwrite( nArq, aLinesProg[nX] )
	Next nX
	
    For nX := 1 To Len(aLinesFunc)
	    Fwrite( nArq, aLinesFunc[nX] )
	Next nX

	FClose(nArq)

	MsgInfo( STR0045 + cArquivo + CRLF + STR0046 ) // "O Programa " #### "para Cadastro de Roteiros Padroes foi Gerado com Sucesso"

End Sequence 

If !( lSetCentury )
	__SetCentury("off")
EndIf

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fFindCF	  ³ Autor ³ Igor Franzoi     	³ Data ³16/09/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Funcao para pesquisa de Verba e Formula			  		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEA160 													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Static Function fFindCF( aColsFind, aHeaderFind )

Local lPesq

Local nOpcAux
Local nOpcRadio

Local cFormula

Local oRadio
Local oVerba
Local oFormula
Local oDlg
Local oGroup
Local oFont

Local bFind
Local aRetCoords

//Essa variaveis são utilizadas na pesquisa F3 do campo verba, 
//para mostrar o conteúdo de forma filtrada
Private cCodProcesso
Private cCodRoteiro
Private cVerba				

Private aIndexSRV			:= {}

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Monta as Dimensoes dos Objetos         					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aRetCoords := RetCoords(1,2,10,35)
aButtons   := {}

If ( Len(aColsFind) > 0 )

	lPesq		:= .F.
	
	nOpcRadio := 1
	nOpcAux   := nOpcRadio
	nOpcRadio := 0
	
	cVerba				:= Space( GetSx3Cache( "RV_COD" 			, "X3_TAMANHO" ) )
	cFormula			:= Space( GetSx3Cache( "RC2_CODIGO"	, "X3_TAMANHO" ) )
	cCodProcesso	:= M->RGA_PROCES
	cCodRoteiro		:= M->RGA_CALCUL
	
	bFind		:= { || Nil }
	
	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi( STR0002 ) FROM 0,0 TO 170,430 OF oMainWnd PIXEL //Pesquisar
	
	@ aRetCoords[1,1] , aRetCoords[1,2] GROUP oGroup TO aRetCoords[1,1]+50,135 LABEL OemToAnsi(STR0100) OF oDlg PIXEL //"Selecione a opção de Pesquisa:"
	oGroup:oFont:=oFont
	
	@ aRetCoords[1,1]+10 , aRetCoords[1,2]+10 RADIO oRadio VAR nOpcAux ITEMS 	OemToAnsi(STR0101), OemToAnsi(STR0102),OemToAnsi(STR0101) +" + "+OemToAnsi(STR0102) ;
		SIZE 115,010 OF oDlg PIXEL

	bSet15		:= { ||nOpcRadio := nOpcAux, lPesq := .T., oDlg:End() }
	bSet24		:= { ||oDlg:End() }

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, bSet15 , bSet24 , Nil , aButtons ) CENTERED

	If !( nOpcRadio == 0 )
	
		bFind := { || If ( fPesqCF( nOpcRadio, cVerba, cFormula, aColsFind, aHeaderFind ), oDlg:End(), .F. ) }
	
		DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD

		DEFINE MSDIALOG oDlg TITLE OemToAnsi( STR0002 ) FROM 0,0 TO 190,430 OF oMainWnd PIXEL //Pesquisar
		
		If ( nOpcRadio == 1 .or. nOpcRadio == 3 )
		 	@ aRetCoords[1,1] , aRetCoords[1,2] GROUP oGroup TO aRetCoords[1,1] + 30,110 LABEL OemToAnsi(STR0101) OF oDlg PIXEL  //Verba
		 	@ aRetCoords[1,1]+10 , aRetCoords[1,2]+10 MsGet oVerba Var cVerba Picture GetSx3Cache("RV_COD", "X3_PICTURE") F3 "SRV-RM" SIZE 060,010 OF oDlg PIXEL	
		EndIf
		If ( nOpcRadio == 2 .or. nOpcRadio == 3 )
			If ( nOpcRadio == 2 )
				@ aRetCoords[1,1]    , aRetCoords[1,2] GROUP oGroup TO aRetCoords[1,1]+30,110 LABEL OemToAnsi(STR0102) OF oDlg PIXEL  //Formula
				@ aRetCoords[1,1]+10 , aRetCoords[1,2]+10 MsGet oFormula Var cFormula Picture GetSx3Cache("RC2_CODIGO", "X3_PICTURE") F3 "RC201" SIZE 060,010 OF oDlg PIXEL	
			Else
				@ aRetCoords[2,1]    , aRetCoords[2,2] GROUP oGroup TO aRetCoords[2,1]+30,110 LABEL OemToAnsi(STR0102) OF oDlg PIXEL  //Formula
				@ aRetCoords[2,1]+10 , aRetCoords[2,2]+10 MsGet oFormula Var cFormula Picture GetSx3Cache("RC2_CODIGO", "X3_PICTURE") F3 "RC201" SIZE 060,010 OF oDlg PIXEL	
			EndIf
		EndIf

		bSet15		:= { ||oDlg:End() , Eval(bFind) }
		bSet24		:= { ||oDlg:End() }

		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, bSet15 , bSet24 , Nil , aButtons ) CENTERED
	
	EndIf

EndIf

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fPesqCF³ Autor ³ Igor Franzoi     ³ Data ³ 16/09/2009 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Valida e localiza as informações na GetDados			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEA160 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Static Function fPesqCF( nOpcRadio, cVerba, cFormula, aColsFind, aHeaderFind )

Local lRet := .T.

Local cMsgAll	:= ""

Local nPosVer	:= GdFieldPos( "RM_VERBA"		, aHeaderFind )
Local nPosFor	:= GdFieldPos( "RM_CODFOR"	, aHeaderFind )
Local nPosSeq	:= GdFieldPos( "RM_SEQ"			, aHeaderFind )

Local nCont

//Valida as informações de verba e formula conforme a seleção
//nOpcRadio = 1 Verba
//nOpcRadio = 2 Formula
//nOpcRadio = 3 Verba + Formula
If ( nOpcRadio == 1 )
	If Empty(cVerba)
		lRet := .F.
		cMsgAll := OemToAnsi(STR0103) + CRLF + OemToAnsi(STR0101)
		MsgAlert( cMsgAll, OemToAnsi(STR0014) ) // "O conteúdo não pode ser branco!" - Atenção
	EndIf
ElseIf ( nOpcRadio == 2 )
	If Empty(cFormula)
		lRet := .F.
		cMsgAll := OemToAnsi(STR0103) + CRLF + OemToAnsi(STR0102)
		MsgAlert( cMsgAll, OemToAnsi(STR0014) )// "O conteúdo não pode ser branco!" - Atenção		
	EndIf
ElseIf ( nOpcRadio == 3 )
	If Empty(cVerba) .or. Empty(cFormula)
		lRet := .F.
		cMsgAll := OemToAnsi(STR0103) + CRLF + OemToAnsi(STR0101) + CRLF + OemToAnsi(STR0102)
		MsgAlert( cMsgAll, OemToAnsi(STR0014) )	// "O conteúdo não pode ser branco!" - Atenção
	EndIf
EndIf

If ( lRet )
	
	cMsgAll := ""

	Do Case
		Case ( nOpcRadio == 1 )
			For nCont := 1 To Len(aColsFind)
				If !(aColsFind[ nCont, Len(aColsFind[nCont]) ])
					If ( AllTrim(aColsFind[ nCont, nPosVer ]) == AllTrim(cVerba) )
						cMsgAll += CRLF + aColsFind[ nCont, nPosSeq ]
					EndIf
				EndIf
			Next
		Case ( nOpcRadio == 2 )
			For nCont := 1 To Len(aColsFind)
				If !(aColsFind[ nCont, Len(aColsFind[nCont]) ])			
					If ( AllTrim(aColsFind[ nCont, nPosFor ]) == AllTrim(cFormula) )
						cMsgAll += CRLF + aColsFind[ nCont, nPosSeq ]
					EndIf
				EndIf
			Next
		Case ( nOpcRadio == 3 )
			For nCont := 1 To Len(aColsFind)
				If !(aColsFind[ nCont, Len(aColsFind[nCont]) ])
					If ( AllTrim(aColsFind[ nCont, nPosVer ]) == AllTrim(cVerba) ) .and. ( AllTrim(aColsFind[ nCont, nPosFor ]) == AllTrim(cFormula) )
						cMsgAll += CRLF + aColsFind[ nCont, nPosSeq ]
					EndIf						
				EndIf
			Next		
	EndCase		

	If !Empty(cMsgAll)
		MsgAlert( OemToAnsi(STR0104) + cMsgAll, OemToAnsi(STR0014) ) // "Já existe o conteúdo na(s) sequência(s):" - Atenção
	Else
		MsgAlert( OemToAnsi(STR0105), OemToAnsi(STR0014) ) // "Resultado não localizado!" - Atenção
	EndIf

EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³G160RGALOK  ³ Autor ³ Mohanad Odeh     	³ Data ³20/02/2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³LINOK PARA GET DA RGA  	                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEA160 													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function G160RGALOK()
Local nPosRec		:= Len(oRGAGet:aHeader)+1 // POSICAO DO AHEADER EM QUE INDICA SE ESTA DELETADO
Local aRGACols	:= aClone(oRGAGet:ACOLS)
Local aCposKey	:= {}
Local aCposObrig	:= {}

aCposKey	:= {"RGA_PROCES", "RGA_MODULO"}
aCposObrig	:= {"RGA_PROCES", "RGA_PDPERI", "RGA_DTINIC"}
// VERIFICAR SE JA EXISTE UM REGISTRO QUE TENHA A CHAVE FORMADA PELA MESMA 
// PROCESSO + MODULO
If !aRGACols[oRGAGet:nAt, nPosRec]
	If !(GDVALIDGET(aCposKey, 4, aCposObrig,.T.,oRGAGet:aHeader, aRGACols, oRGAGet:nat))
		Return .F.
	EndIf
EndIf

Return .T.
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³G160RGATOK  ³ Autor ³ Mohanad Odeh     	³ Data ³20/02/2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³TUDOOK PARA GET DA RGA   		                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEA160 													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function G160RGATOK()
Return If(nAba == 2, G160RGALOK(), .T.) //SO VALIDA SE ESTIVER NA ABA DE PERIODO PADRAO 

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GPCompAll  ³ Autor ³ Ricardo Duarte 		³ Data ³21/11/2016³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Validar e Recompilar todos Roteiros                     	³±± 
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEA160 													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function GPCallCmpAll(cModAlias,lLog,lRecFrm,lForca,lEmptyRpo, aFilExec)
DEFAULT cModAlias := "SRY"
DEFAULT lLog	  := .T.
DEFAULT lRecFrm   := .T.
DEFAULT lForca    := .F.
DEFAULT lEmptyRpo := .F.
DEFAULT aFilExec  := {}

If lFirst
	If !IsBlind()
		MsAguarde( { || lRetRot :=  GPCompAll(cModAlias,0,0,lLog,lRecFrm,lForca,lEmptyRpo, aFilExec) } , OemToAnsi( STR0157 ) )	//"Validando a Compilação de Roteiros e Formulas..."
	Else
		lRetRot :=  GPCompAll(cModAlias,0,0,lLog,lRecFrm,lForca)
	EndIf
	lFirst := .F.
EndIf

Return

Function f160RstSt()
	lFirst := .T.
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GPCompAll  ³ Autor ³ Ricardo Duarte 		³ Data ³21/11/2016³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Validar e Recompilar todos Roteiros                     	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEA160 													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function GPCompAll( cAlias , nReg , nOpc, lLog,lRecFrm, lForca, lEmptyRpo, aFilExec)
Local aArea 	  := GetArea()
Local aLog		  := {}
Local aRotComp	  := {}
Local cFunct	  := ""
Local cPrg		  := ""
Local cLogErro	  := ""
Local cFilAux	  := ""
Local nLoop	      := 0
Local oRpoForm
Local lRet		  := .T.
Local lErroComp   := .F.
Local lSkipRot    := .T.
Local lGP290REPL  := IsInCallStack("U_GP290REPL")
Local lGPEM020    := IsInCallStack("GPEM020PROCESSA")
Local lRpoFil	  := SuperGetMv('MV_RPOFIL',, .F.)
Local aChaveSRY   := {}

Static lFilRPO

DEFAULT lLog	  := .T.
DEFAULT lRecFrm   := .T.
DEFAULT lForca    := .F.
DEFAULT lEmptyRpo := .F.
DEFAULT aFilExec  := {}
DEFAULT lFilRPO   := SuperGetMv('MV_RPOFIL',, .F.) .and. xFilial("SRY") <> xFilial("RC2") 

IF !( RpoFormInit() )
	aAdd( aLog, OemToAnsi(STR0156) ) //"Nao Foi Possivel Inicializar o Repositorio para Carga dos Roteiros."
Else
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se Deve Adicionar as Formulas Padroes                         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If lRecFrm
		Gpea290FrmInit(lRecFrm)
	EndIf
	If !lFilRPO .or. Empty(aFilExec)
		IF !GpeGerFrm(lForca)
			Break
		EndIF
	Else
		cFilAux := cFilAnt
		For nLoop := 1 to Len(aFilExec)
			If SRA->(DbSeek(AllTrim(aFilExec[nLoop]))) //Posiciona no primeiro funcionário para obter a filial completa
				cFilAnt := SRA->RA_FILIAL
			EndIf
			Gpea290FrmInit( .T. )
			IF !GpeGerFrm(lForca)
				Break
			EndIF
		Next nLoop
		cFilAnt := cFilAux
	EndIf

	// Efetua uma simulação de compilação para verificar se o RPO de formulas está em uso por outro processo
	If !lEmptyRpo .And. !Empty(aFilExec)
		Compile( @oRpoForm , {""} , .T. , @aLog, .T. )
		If !Empty(aLog)
			lErroComp := .T.
			aLog := {}
		EndIf	
		RpoFormInit( NIL, .T. )
	EndIf
	
	DbSelectArea( "SRY" )
	SRY->( DbGoTop() )
	If lRpoFil .And. lGP290REPL
		SRY->( dbSeek(FWxFilial("SRY") ) )
	EndIf
	While !Eof() .And. Iif(lRpoFil, SRY->RY_FILIAL == FWxFilial("SRY"), .T.)
		If lRpoFil .And. lGPEM020 .And. !Empty(aFilExec) .And. SRY->RY_FILIAL != FWxFilial("SRY", aFilExec[1])
			SRY->( DbSkip() )
			Loop
		EndIf
		cFunct	:= ( SRY->( RotGetFunc( RY_FILIAL , RY_CALCULO, RY_ORIGEM ) ) )
		cPrg 	:= cFunct + ".PRG"
		cPrg 	:= Lower( GetRpoForm( .F. , .T. ) + cPrg )
		lSkipRot := .T.
		
		If lRecFrm .OR. (( SRY->RY_RECOMP == "1" ) .Or. !FindFunction(cFunct))

			// Caso tenha ocorrido erro na simulação de compilação no RPO de formulas e o roteiro pendente de compilação não seja da empresa/filial que está sendo processada, 
			// não tenta realizar a compilação para que o processo não seja interrompido.
			If !lEmptyRpo .And. lErroComp .And. SRY->RY_RECOMP == "1"
				For  nLoop := 1 to Len(aFilExec)
					If SRY->RY_FILIAL == FWxFilial("SRY", aFilExec[nLoop])
						lSkipRot := .F.
					EndIf		
				Next
				If lSkipRot
					SRY->( DbSkip() )
					Loop
				EndIf				
			EndIf

			SRY->( GetFunRot( RY_FILIAL , RY_CALCULO , .T. , NIL , .F. , @oRpoForm, ,lEmptyRpo, @aRotComp) )
			aAdd(aChaveSRY, SRY->(RY_FILIAL+RY_CALCULO))
			If !lEmptyRpo
				lCompileOk := !ErrorInRot()
				If !( lCompileOk )
					If Empty( aLog )
						aAdd( aLog, STR0160 ) // "Falha na Compilação dos seguintes Roteiros: "
					EndIf
					aAdd( aLog, SRY->( RY_FILIAL + " - " + RY_CALCULO + " - " + RY_DESC ) )
				EndIf
			EndIf
		EndIf
		
		SRY->( DbSkip() )
	EndDo
	If lEmptyRpo
		Compile( @oRpoForm , @aRotComp , .T. , @aLog )
		lCompileOk := !ErrorInRot()
		If !lCompileOk
			For nLoop := 1 to Len(aRotComp)
				If !aRotComp[ nLoop , COMPILE_OK ] //Falha na compilação
					cLogErro := ""
					cLogErro += "Error Prg: " + aRotComp[nLoop,COMPILE_PRG]
					cLogErro += " - Error Str: " + aRotComp[nLoop, COMPILE_ERROR_STR]
		   			cLogErro += " - Error Col: " + aRotComp[nLoop, COMPILE_ERROR_COL]
		   			cLogErro += " - Error Line: " + aRotComp[nLoop, COMPILE_ERROR_LINE]
					aAdd(aLog, cLogErro)
				EndIf
			Next
		ElseIf Empty(aLog)
			For nLoop := 1 to Len(aChaveSRY)
				If SRY->(DbSeek(aChaveSRY[nLoop]))
					SRY->( RecLock( "SRY" , .F. ) )
					SRY->RY_RECOMP := "2"		//Compilado
					SRY->( MsUnLock() )					
				EndIf
			Next nLoop
		EndIf
	EndIf
	If !IsInCallStack("EXECROT")
		RpoFormInit( NIL, .T. )
	EndIf
EndIf
If lLog .and. Len(aLog) > 1
	cLogErro 	:= ""
	For nLoop := 1 To Len( aLog )
		cLogErro += aLog[nLoop]  + CHR(13)
	Next nLoop
	lRet := .F.
	If !IsBlind()
		MsgInfo( cLogErro, STR0014 )	// Log ### "Atencao"
	EndIf
EndIf	

RestArea( aArea )

Return( lRet )
