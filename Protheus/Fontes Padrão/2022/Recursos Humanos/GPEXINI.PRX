#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEX1INI.CH"

Static aTab_Fol		:= {}				//Array com as Tabelas da Folha
Static oHash_Tab
Static aRot13       := {}				//Array contendo o roteiro a ser executado (13o.)
Static cTurnoAnt 	:= "__cTurnoAnt__"//Turno Anterior
Static aSRYBkp 		:= {}		// cabecalho do arquivo RC2 na base do cliente
Static aSRMBkp		:= {}		// cabecalho do arquivo RC3 na base do cliente
Static aRC2Bkp		:= {}
Static aRC3Bkp		:= {}
Static nTamFilAux
Static lRefAbono	:= If(SRV->(ColumnPos( 'RV_REFABON' )) > 0, .T., .F.)
Static lIniS033	 	:= .T.
Static lTemSeqMV
Static lGrvRAZRAW
Static aEstb		:= fGM23SM0(,.T.)
Static lConsig		:= GetMvRH("MV_CONSIG",, .F.)
Static cPdFerMS
Static cPdUltFil	:= ""

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±ºPrograma  ³GPIniForm ³ Autor ³Microsiga                          ³ Data ³ 09-07-02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Criacao das formulas Padroes da Microsiga                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³             ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS/FNC         ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Leandro Dr. ³23/09/12³           M12RH01³Requisito RHU210 - Unificação das folhas. ³±±
±±³Flavio Corr ³17/07/15³ TSWORN           ³Campo novo na SRY - RY_CONTAB             ³±±
±±³Allyson M   ³01/09/15³            TTBHWJ³Ajuste no fPosTab() p/ permitir a busca   ³±±
±±³		       ³        ³                  ³com 3 condicoes.                          ³±±
±±³Allyson M.  ³14/10/15³            TTLNPT³Ajuste em fCarrTab() p/ verificar         ³±±
±±³            ³        ³                  ³estrutura quando tabela for a S033 pois   ³±±
±±³            ³        ³                  ³a estrutura foi alterada.			      ³±±
±±³Renan Borges³27/10/15³            TTNSUW³Ajuste para calcular folha corretamente,  ³±±
±±³            ³        ³                  ³buscando as informações das tabelas auxili³±±
±±³            ³        ³                  ³ares corretamente, quando forem cadastra- ³±±
±±³            ³        ³                  ³das mensalmente. Na função ftabela, utili-³±±
±±³            ³        ³     		       ³zar a data do periodo aberto para buscar  ³±±
±±³            ³        ³                  ³as informações nas tabelas auxiliares, e  ³±±
±±³            ³        ³                  ³não a database.                           ³±±
±±³EstherV.    ³09/12/15³PCDEF2015_2016-677³Declaracao das variaveis cTab3Type e      ³±±
±±³            ³        ³                  ³cCnt3Type.                                ³±±
±±³Raquel Hager³02/02/16³            TUHLUS³Ajuste na funcao fCarMvto para considerar ³±±
±±³            ³        ³                  ³RGB_DTREF em branco ou dentro da competen-³±±
±±³            ³        ³                  ³cia de calculo para verbas informadas,    ³±±
±±³            ³        ³                  ³exceto para o roteiro de PLR que utiliza  ³±±
±±³            ³        ³                  ³campo para controle de pagamento.         ³±±
±±³            ³        ³                  ³Ajuste para gravar no aPd a dDtaPgto caso ³±±
±±³            ³        ³                  ³a Dt Ref estiver em branco ou dentro da   ³±±
±±³            ³        ³                  ³competência exceto para roteiro PLR e     ³±±
±±³            ³        ³                  ³fechamento.							      ³±±
±±³Raquel Hager³10/02/16³TUJQLJ            ³Ajuste para gravar a dDtRef               ³±±
±±³            ³        ³                  ³no aPd e consequentemente na SRC.		  ³±±
±±³Raquel Hager³19/02/16³TUKE03            ³Ajuste para inicializar dDtaPg.           ³±±
±±³Raquel Hager³23/02/16³TUNV61            ³Ajuste para gravacao de Dt Pagto/Ref.     ³±±
±±³Gustavo M.  ³30/03/16³TUVWVG            ³Melhoria de performance nas férias.	      ³±±
±±³Raquel Hager³30/05/16³TVGSTO            ³Ajuste para data de pagamento de PLR seja ³±±
±±³            ³        ³                  ³a do cadastro para registros I/G.         ³±±
±±³Gabriel A.  ³24/06/16³TVGZA5            ³Ajuste para quando for comissionado e     ³±±
±±³            ³        ³                  ³roteiro BEN, procurar as verbas também    ³±±
±±³            ³        ³                  ³no roteiro FOL.                           ³±±
±±³Allyson M.  ³12/07/16³TURHSE            ³Ajuste em GravaCalc() p/ nao gravar o     ³±±
±±³            ³        ³                  ³calculo se tiver sido executada antes do  ³±±
±±³            ³        ³                  ³roteiro de VT.			      			  ³±±
±±³Cícero Alves³25/07/16³TURHSE            ³Ajuste em  FCriaRoteiro para posicionar no³±±
±±³            ³        ³                  ³arquivo correto ao deletar o registro	  ³±±
±±³Renan Borges³03/08/16³TVSZY6            ³Ajuste para considerar verbas informadas  ³±±
±±³            ³        ³                  ³nas férias corretamente no dissidio retroa³±±
±±³            ³        ³                  ³tivo.                                     ³±±
±±³Allyson M.  ³05/08/16³TVSZY6            ³Ajuste para considerar verbas informadas  ³±±
±±³            ³        ³                  ³nas férias corretamente 				  ³±±
±±³Allyson M.  ³17/08/16³TVVMIR            ³Ajuste na ordenação da query em fCarMvto()³±±
±±³            ³        ³                  ³p/ não gerar erro em Oracle				  ³±±
±±³Allyson M.  ³26/08/16³TVRUMR            ³Ajuste em fPosTab() p/ receber data p/    ³±±
±±³            ³        ³                  ³busca dos dados da tabela				  ³±±
±±³Gabriel A.  ³23/09/16³TVEQT2            ³Ajuste para buscar os conteúdos das       ³±±
±±³            ³        ³                  ³tabelas de acordo com a filial corrente.  ³±±
±±³Allyson M.  ³10/10/16³TVYB07            ³Ajuste p/ não considerar verbas informadas³±±
±±³            ³        ³                  ³nas férias se o período de apuração das	  ³±±
±±³            ³        ³                  ³diferenças for o mesmo da folha	pois as   ³±±
±±³            ³        ³                  ³verbas já serão carregadas via RGB        ³±±
±±³Gustavo M.  ³10/12/16³MRH-3106          ³Ajuste em fComp13Fol() p/ não verificar o ³±±
±±³            ³        ³                  ³roteiro 132 na provisão					  ³±±
±±³Raquel Hager³28/12/16³MRH-3736          ³Ajuste em fCarMvto para carregar verbas do³±±
±±³            ³        ³                  ³do tipo Informada quando função estiver	  ³±±
±±³            ³        ³                  ³sendo executada pelo Complemento de 13º.  ³±±
±±³Raquel Hager³18/01/16³MRH-4927          ³Ajuste em fCarMvto para considerar a Resci³±±
±±³            ³        ³                  ³são calculada no mês que está sendo calcu ³±±
±±³            ³        ³                  ³lada Folha de Pagamento e trazer apenas os³±±
±±³            ³        ³                  ³registros gerados pela Rescisão.          ³±±
±±³Gabriel A.  ³19/01/17³MRH-5055          ³Ajuste para incorporar ao salário apenas  ³±±
±±³            ³        ³                  ³verbas que foram informadas, na provisão. ³±±
±±³Jônatas A.  ³23/01/17³MRH-5183          ³Ajuste em fRetTab p/ considerar a filial  ³±±
±±³            ³        ³                  ³do funcionário na carga da tabela.        ³±±
±±³Allyson M.  ³24/01/17³MRH-4639          ³Ajuste em fCarrTab() p/ efetuar query na  ³±±
±±³            ³        ³                  ³busca dos dados da RCC devido performance ³±±
±±³Jônatas A.  ³27/01/17³MRH-5183          ³Ajuste em fRetTab p/ receber parametro    ³±±
±±³            ³        ³                  ³passado pelo homolognet.                  ³±±
±±³Raquel Hager³13/02/17³MRH-6464          ³Ajuste em fCarmvto para utilizar uma varia³±±
±±³            ³        ³                  ³vel local para associar a Dt.Ref. da RGB. ³±±
±±³Jônatas A.  ³24/04/17³DRHPAG-106        ³Ajuste em GravaAdt p/ gerar no SRC apenas ³±±
±±³            ³        ³                  ³lançamentos da semana calculada.          ³±±
±±³Marcos Cout ³10/08/17³DRHESOCP-766      ³Subir fonte no pacote                     ³±±
±±³  Marco A.  ³17/10/17³   TSSERMI01-209  ³Se realiza modificacion en fCarrTab, para ³±±
±±³            ³        ³                  ³cerrar area de trabajo cAliasRCC, dentro  ³±±
±±³            ³        ³                  ³de While. (ARG)                           ³±±
±±³Oswaldo L   ³01/12/17³DRHPAG-8855       ³Acerto para permitir selecionar bancos da ³±±
±±³            ³        ³                  ³filial conectada S052, no fonte gpem080   ³±±
±±³Eduardo K.  ³05/02/18³MPRIMESP-13628    ³Ajuste em fCarrTab()/ p/ não ocorrer erro ³±±
±±³            ³        ³                  ³na tabela S052 com filial em branco.      ³±±
±±³João Balbino³07/03/18³MPRIMESP-14153    ³Ajuste em fCarrTab()/ p/ não ocorrer erro ³±±
±±³            ³        ³                  ³log quando chamda do GPER040.             ³±±
±±³  Marco A.  ³12/08/20³    DMINA-9750    ³Ajuste en la funcion fPosTab(), para asig-³±±
±±³            ³        ³                  ³nar el valor de xFilial("SRA") a variable ³±±
±±³            ³        ³                  ³default cFilSeek. (MI)                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GpIniForm()
Local aArea
Local aAreaRC2
Local aAreaRC3

Local cFunc		:= ( "GpFor" + cPaisLoc + "()" )
DbSelectArea("RC3")
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verificar a existencia da formula padrao do pais corrente     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If FindFunction( cFunc )
	aArea		:= GetArea()
	aAreaRC2	:= RC2->( GetArea( "RC2" ) )
	aAreaRC3	:= RC3->( GetArea( "RC3" ) )
	__ExecMacro( cFunc )
	RestArea( aAreaRc2 )
	RestArea( aAreaRc3 )
	RestArea( aArea )
EndIf	

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³fNewOldSx3    ³Autor³ Mauricio T. Takakura³ Data ³09/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Val. estrutura da tabela RC2 e RC3 do Cliente c/ Nova Versao³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fNewOldSx3                									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³Generico      												³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fNewOldSx3( aFatherHeader	,;	// Cabecalho do Item Pai
					 aChildHeader   ,;	// Cabecalho do Item Filho
					 cFatherAlias	,;	// Alias do Father
					 cChildAlias	,; 	// Alias Child
					 lX3Tela		 ;  // Verificar o campo X3_TELA para montagem do Header
					)

Local aCliFatherHdr := {}		// cabecalho do arquivo RC2 na base do cliente
Local aCliChildHdr	:= {}		// cabecalho do arquivo RC3 na base do cliente

Local cCampo					// nome do campo para validacao
Local cNotField	  	:= ""		// campos nao encontrados

Local lRet		  	:= .T.		// variavel de retorno

Local nUsado					// campos usados
Local nPos
Local nX

DEFAULT aFatherHeader	:= {}
DEFAULT aChildHeader 	:= {}
DEFAULT cFatherAlias	:= ""
DEFAULT cChildAlias		:= ""
DEFAULT lX3Tela			:= .T.

If !Empty(cFatherAlias)
	If cFatherAlias == "SRY" 
		If Empty(aSRYBkp)
			aCliFatherHdr := ( cFatherAlias )->( GdMontaHeader( @nUsado, NIL, NIL, NIL, NIL, .T.,,,,,,,,lX3Tela ) )
			aSRYBkp := aClone(aCliFatherHdr)
		Else
			aCliFatherHdr := aClone(aSRYBkp)
		EndIf
	ElseIf cFatherAlias == "RC2" 
		If Empty(aRC2Bkp)
			aCliFatherHdr := ( cFatherAlias )->( GdMontaHeader( @nUsado, NIL, NIL, NIL, NIL, .T.,,,,,,,,lX3Tela ) )
			aRC2Bkp := aClone(aCliFatherHdr)
		Else
			aCliFatherHdr := aClone(aRC2Bkp)
		EndIf	
	Else
		aCliFatherHdr := ( cFatherAlias )->( GdMontaHeader( @nUsado, NIL, NIL, NIL, NIL, .T.,,,,,,,,lX3Tela ) )
	EndIf
EndIf

If !Empty(cChildAlias) 
	If cChildAlias == "SRM"
		If Empty(aSRMBkp)
			aCliChildHdr  := ( cChildAlias )->( GdMontaHeader( @nUsado, NIL, NIL, NIL, NIL, .T.,,,,,,,,lX3Tela ) )
			aSRMBkp		:= aClone(aCliChildHdr)
		Else
			aCliChildHdr := aClone(aSRMBkp)
		EndIf
	ElseIf cChildAlias == "RC3"
		If Empty(aRC3Bkp)
			aCliChildHdr  := ( cChildAlias )->( GdMontaHeader( @nUsado, NIL, NIL, NIL, NIL, .T.,,,,,,,,lX3Tela ) )
			aRC3Bkp		:= aClone(aCliChildHdr)
		Else
			aCliChildHdr := aClone(aRC3Bkp)
		EndIf
	Else
		aCliChildHdr  := ( cChildAlias )->( GdMontaHeader( @nUsado, NIL, NIL, NIL, NIL, .T.,,,,,,,,lX3Tela ) )
	EndIf
	
EndIf


/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verificar se todos os campos da tabela padrao possuem na base ³
³ do cliente.                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
For nX := 1 To Len(aFatherHeader)
	cCampo := Upper(aFatherHeader[nX,2])

	nPos := aScan(aCliFatherHdr,  { |x|  Upper(x[2]) == cCampo })
	If nPos == 0  .And. (cFatherAlias + "->" + aFatherHeader[ nX, 2 ] <> "SRY->RY_MODULO" )
		cNotField += " " + cFatherAlias + "->" + aFatherHeader[ nX, 2 ] + CRLF
	EndIf
Next nX

For nX := 1 To Len(aChildHeader)
	cCampo := Upper(aChildHeader[nX, 2])
	nPos := aScan(aCliChildHdr,  { |x|  Upper(x[2]) == cCampo })
	If nPos == 0
		cNotField += " " + cChildAlias + "->" + aChildHeader[ nX, 2 ] + CRLF
	EndIf
Next nX
If !Empty(cNotField)
	MsgInfo( STR0123 + CRLF + cNotField + STR0124 + CRLF +; // "O(s) campo(s) " ### " nao Existe(m) no Banco de Dados!"
			 STR0125 )										// "Atualize a Estrutura das Tabelas!"
	lRet := .F.
EndIf

Return( lRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fFormGravaºAutor  ³Microsiga           º Data ³21/08/2002   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Inclusao de Formulas Padroes no RC2 e RC3                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Inclusao de Formulas Padroes no RC2 e RC3                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fFormGrava( aRc2Cols	,; 	//01 -> Formulas a gravar da tabela RC2
					 aRc3Cols	,;	//02 -> Itens da tabela RC3
					 aRC2Header	,;	//03 -> Cabecalho do Item Pai
					 aRC3Header ,;	//04 -> Cabecalho do Item Filho
					 aSYPHeader	,; 	//07 -> Cabecalho da tabela de Campos Memos
					 aSYPMemo	 ; 	//08 -> Itens do campo Memo
					)

Local aMemoBco		:= {}
Local aRc3Recnos

Local cKey
Local cCampo
Local cCodObs
Local cRc2Filial
Local cSYPFilial
Local cRc2Origem
Local cRc2Codigo
Local lAddNew

Local nX
Local nG
Local nY
Local nRc2Versao
Local nFieldPos
Local nPosField
Local nRc3SeqPai
Local nPosSYPSeq
Local nPosSYPFilial

nRc2Versao	:= GdFieldPos ( "RC2_VERSAO" , aRC2Header )
nRc2Origem	:= GdFieldPos ( "RC2_ORIGEM" , aRC2Header )
nRc2Codigo	:= GdFieldPos ( "RC2_CODIGO" , aRC2Header )
cRc2Filial	:= xFilial("RC2")
cSYPFilial	:= xFilial("SYP")

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Gravacao da Formula                                           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cNewVersao 	:= aRc2Cols[1,nRc2Versao]
cRc2Origem	:= aRc2Cols[1,nRc2Origem]
cRc2Codigo	:= aRc2Cols[1,nRc2Codigo]
nPosSYPFilial:= GdFieldPos ( "YP_FILIAL" , aSYPHeader )
nPosSYPSeq	 := GdFieldPos ( "YP_SEQ" , aSYPHeader )


DbSelectArea("RC2")
RC2->( dbSetOrder(RetOrdem("RC2","RC2_FILIAL+RC2_ORIGEM+RC2_CODIGO")) )
lAddNew	:= RC2->( !MsSeek( cRc2Filial + cRc2Origem + cRc2Codigo ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Atualizar a formula                                           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF RC2->( RecLock( "RC2" , lAddNew ) )

	// gravacao dos campos comuns //
	For nG := 1 To Len(aRC2Header)
	   	cCampo		:= Upper( aRC2Header[nG, 2] )
    	nFieldPos	:= RC2->( FieldPos( cCampo ) )
    	IF ( nFieldPos > 0 )
	   		IF !( cCampo $ "RC2_FILIAL/RC2_RECOMP/RC2_CODOBS" )
	    		nPosField := GdFieldPos( cCampo , aRC2Header )
	    		IF ( nPosField > 0 )
	    			RC2->( FieldPut( nFieldPos , aRc2Cols[ 1 , nPosField ] ) )
	    		EndIF
	    	ElseIF cCampo == "RC2_CODOBS"
	    		IF lAddNew .Or. ( !lAddNew .and. Empty(aRc2Cols[ 1 , nPosField ]) )
		    		nPosField := GdFieldPos( cCampo , aRC2Header )
		    		IF ( nPosField > 0 )
		    			IF ( !lAddNew .and. Empty(aRc2Cols[ 1 , nPosField ]) )
		    				cCodObs := RC2->RC2_CODOBS
		    			EndIf
		    			RC2->( FieldPut( nFieldPos , aRc2Cols[ 1 , nPosField ] ) )
	    			EndIF
	    		EndIF
	    	Else
	    		RC2->( FieldPut( nFieldPos , cRc2Filial ) )
	    	EndIF
	    EndIF
	Next nG
	nFieldPos := RC2->( FieldPos( "RC2_RECOMP" ) )
	IF ( nFieldPos > 0 )
		RC2->( FieldPut( nFieldPos , "1" ) )
	EndIF
	RC2->( MsUnLock() )
	IF Empty( cCodObs )
		cCodObs := RC2->RC2_CODOBS
	Else
		cKey := xFilial( "SYP" ) + cCodObs
		SYP->( DbSeek( cKey, .F. ) )
		If !lAddNew .and. SYP->( !Eof() )
			While SYP->( !Eof() ) .and. SYP->(YP_FILIAL+YP_CHAVE) == cKey
				aAdd( aMemoBco, { SYP->YP_FILIAL, SYP->YP_CHAVE, SYP->YP_SEQ, "" } )
				SYP->( DbSkip() )
			EndDo
        EndIf
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Gravacao do campo de Observacoes                              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If !Empty(aSYPMemo)
	
		DbSelectArea( "SYP" )
		DbSetOrder( 1 ) // YP_FILIAL+YP_CHAVE+YP_SEQ

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Armazenar para verificar se existe necessidade de excluir    ³
		³ algum item do banco de dados.                                ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cKey := cSYPFilial + cCodObs
		DbSeek( cKey, .F. )
		If !lAddNew
			While !Eof() .and. SYP->(YP_FILIAL+YP_CHAVE) == cKey
				aAdd( aMemoBco, { SYP->YP_FILIAL, SYP->YP_CHAVE, SYP->YP_SEQ, "" } )
				DbSkip()
			EndDo
		Else
			If SYP->( !Eof() )
				cCodObs := GetSX8Num("SYP","YP_CHAVE")
				ConfirmSX8()
			EndIf
		EndIf
		
		For nX := 1 To Len( aSYPMemo )
			cKey := cSYPFilial + cCodObs + aSYPMemo[ nX, nPosSYPSeq]
			DbSeek( cKey, .F. )
			If SYP->( Eof() )
				RecLock("SYP",.T.,.T.)
			Else
				RecLock("SYP",.F.,.T.)
			EndIf
			For nY := 1 To Len( aSYPHeader )
				cCampo := aSYPHeader[ nY, 2 ]
				If cCampo == "YP_CHAVE"
					SYP->( &cCampo ) := cCodObs
				ElseIf cCampo == "YP_FILIAL"
					SYP->( &cCampo ) := cSYPFilial
				Else
					SYP->( &cCampo ) := aSYPMemo[nX,nY]
				EndIf
			Next nY
			SYP->( MsUnLock() )
			If !lAddNew
				nPosArr := ascan( aMemoBco, { | x, y| x[1] == cSYPFilial .and. x[2] = cCodObs .and. x[3] == aSYPMemo[ nX, nPosSYPSeq] })
				If nPosArr > 0
					aMemoBco[nPosArr, 4] := "1"
				EndIf
			EndIf
		Next nX

		If RC2->RC2_CODOBS <> cCodObs
			RC2->( RecLock( "RC2" , .F., .T. ) )
			RC2->RC2_CODOBS := cCodObs
			RC2->( MsUnLock() )
		EndIf
	EndIf
	
	If Len( aMemoBco ) > 0 .and. !lAddNew
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Excluir da Tabela os itens que nao necessitam mais 		   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If Len( aSYPMemo ) < Len( aMemoBco )
			For nX := 1 To Len( aMemoBco )
				If aMemoBco[nX, 4] == "1"
					Loop
				Else
					cKey := aMemoBco[nX, 1] + aMemoBco[nX, 2] + aMemoBco[nX, 3]
					SYP->( DbSeek( cKey, .F. ) )
					If SYP->( !Eof() )
						RecLock("SYP",.F.,.T.)
						SYP->( dbDelete() )
						SYP->( MsUnLock() )
					EndIf
				EndIF
			Next nX
		EndIf
	EndIf

	Rc2RecSry() //Forcar a Recompilacao do Roteiro

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Efetua a Delecao do RC3 antes de fazer a inclusao       	    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("RC3")
	aRc3Recnos	:= {}
	nFieldPos	:= RC3->( FieldPos( "RC3_SEQPAI" ) )
	RC3->( dbSetOrder( 1 ) ) // RC3_FILIAL+RC3_ORIGEM+RC3_CODIGO+RC3_SEQFOR+RC3_SEQPAI
	If RC3->( dbSeek( cRc2Filial + cRc2Origem + cRc2Codigo ) )
		cRc2Filial := AllTrim(Upper(cRc2Filial))
		cRc2Origem := AllTrim(Upper(cRc2Origem))
		cRc2Codigo := AllTrim(Upper(cRc2Codigo))
		While RC3->(;
						!Eof();
						.and.;
						(;
							(;
								AllTrim(Upper(RC3_FILIAL));
								+;
								AllTrim(Upper(RC3_ORIGEM));
								+;
								AllTrim(Upper(RC3_CODIGO));
							);
							==;
			            	(;
			            		cRc2Filial;
			            		+;
			            		cRc2Origem;
			            		+;
			            		cRc2Codigo;
			            	);
			            );	
			       )  
			IF RecLock( "RC3" , .F. )
				aAdd( aRc3Recnos , RC3->( Recno() ) )
				RC3->( FieldPut( nFieldPos , Space( GetSx3Cache( "RC3_SEQPAI" , "X3_TAMANHO" ) ) ) )
				RC3->( MsUnlock() )
			EndIF
			RC3->( dbSkip() )
		EndDo
	EndIf

	For nG := 1 To Len( aRc3Recnos )
		RC3->( MsGoto( aRc3Recnos[ nG ] ) )
		IF RC3->( Eof() )
			Loop
		EndIF
		IF RecLock( "RC3" , .F. )
			RC3->( dbDelete() )
			RC3->( MsUnlock() )
		EndIF
	Next nG

	aRc3Recnos := {}
	For nG := 1 to Len(aRc3Cols)

		IF RC3->( RecLock( "RC3" , .T. ) )
			// gravacao dos campos //
			For nY := 1 To Len(aRC3Header)
				cCampo 		:= Upper(aRC3Header[nY, 2])
				IF ( cCampo <> "RC3_SEQPAI" )
					nFieldPos	:= RC3->( FieldPos( cCampo ) )
					IF ( nFieldPos > 0 )
						If ( cCampo != "RC3_FILIAL" )
					    	nPosField := GdFieldPos( cCampo , aRC3Header )
					    	IF ( nPosField > 0 )
					    		RC3->( FieldPut( nFieldPos , aRc3Cols[ nG , nPosField ] ) )
					    	EndIF	
					    Else
				    		RC3->( FieldPut( nFieldPos , cRc2Filial ) )
					    EndIf
					EndIF
				EndIF
			Next nY
			aAdd( aRc3Recnos , { RC3->( Recno() ) , nG } )
			RC3->( MsUnlock() )
		EndIF
	Next nG

	//Gravando a Sequencia Pai
	nFieldPos	:= RC3->( FieldPos( "RC3_SEQPAI" ) )
	nRc3SeqPai	:= GdFieldPos( "RC3_SEQPAI" , aRC3Header )
	IF (;
			( nFieldPos > 0 );
			.and.;
			( nRc3SeqPai > 0 );
		)	
		For nG := 1 To Len( aRc3Recnos )
			RC3->( MsGoto( aRc3Recnos[ nG , 1 ] ) )
			IF RC3->( Eof() )
				Loop
			EndIF
			IF RC3->( RecLock( "RC3" , .F. ) )
				RC3->( FieldPut( nFieldPos , aRc3Cols[ aRc3Recnos[ nG , 2 ] , nRc3SeqPai ] ) )
				RC3->( MsUnlock() )
			EndIF
		Next nG
	EndIF

EndIF

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±ºPrograma  ³GPIniTab  ³ Autor ³Mauricio T. Takakura   ³ Data ³ 06/12/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Criacao das Definicoes de Tabelas Padroes                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³            ³        ³      ³                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function GpIniTab()

Local aArea

Local cFunc		:= ( "GpTab" + cPaisLoc + "()" )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verificar a existencia da formula padrao do pais corrente     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF FindFunction( cFunc )
	aArea		:= GetArea()
	__ExecMacro( cFunc )
	RestArea( aArea )
EndIF

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGravaTab ºAutor  ³Mauricio T. Takakuraº Data ³06/12/2004   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Inclusao de Definicao Tabelas Padroes no RCB                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Gpea310.prx                                                 º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fGravaTab( aRCBHeader	,;		// cabecalho da Nova Versao - Arquivo Padrao
					aRCBItens	 ;		// Itens a serem atualizados
				  )

Local cFilRCB 		:= xFilial( "RCB" )
Local cCodigo 		:= aRCBItens[1, GdFieldPos( 'RCB_CODIGO' , aRCBHeader )]
Local cCampo

Local nFieldPos
Local nX
Local nY

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Excluir os Itens da Tabela para Incluir posteriormente 	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
DbSelectArea( "RCB" )
DbSetOrder( 1 )
DbSeek( cFilRCB + cCodigo )
While !Eof() .and. RCB->( RCB_FILIAL + RCB_CODIGO ) == cFilRCB + cCodigo
	IF RecLock( "RCB" , .F. )
		RCB->( dbDelete() )
		RCB->( MsUnlock() )
	EndIF
	RCB->( dbSkip() )
EndDo

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Incluir os Itens da Definicao Tabelas                  	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
For nX := 1 To Len( aRCBItens )

	IF RCB->( RecLock( "RCB" , .T. ) )

		// gravacao dos campos //
		For nY := 1 To Len(aRCBHeader)
			cCampo 		:= Upper(aRCBHeader[nY, 2])
			nFieldPos	:= RCB->( FieldPos( cCampo ) )
			IF ( nFieldPos > 0 )
				If ( cCampo != "RCB_FILIAL" )
			    	RCB->( FieldPut( nFieldPos , aRCBItens[nX, nY] ) )
			    Else
		    		RCB->( FieldPut( nFieldPos , cFilRCB ) )
			    EndIf
			EndIF
		Next nY
		RCB->( MsUnlock() )
	EndIF
Next nX

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GPInifunc ºAutor  ³Microsiga           º Data ³  08-21-02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP7                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function GpIniFuncao()

Local aArea
Local cFunc

If cPaisLoc == "RUS"
	cFunc		:= ( "GpFunRus" + "()" )
Else
	cFunc		:= ( "GpFunAll" + "()" )
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verificar a existencia da Bibioteca de Funcoes Padroes        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF FindFunction( cFunc )
	aArea		:= GetArea()
	__ExecMacro( cFunc )
	RestArea( aArea )
EndIF

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGravaFuncºAutor  ³Mauricio T. Takakuraº Data ³  07-12-04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao para gravacao das funcoes da biblioteca			  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MP8                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fGravaFunc(	aRc4Cols	,;	// Cabecalho das Funcoes
						aRc5Cols 	,;	// Parametros da Funcao
						aRc4Header	,;	
						aRc5Header	,;
						aRc4Memo	,;
						aRc5Memo	 ;
					)

Local cCampo
Local cValueMemo
Local cRc4Filial
Local cRc4NomFun

Local lAddNew

Local nG
Local nY
Local nRc4Memo
Local nRc5Memo
Local nFieldPos
Local nPosField
Local nPosCpoMemo

DEFAULT aRC4Memo := {}
DEFAULT aRC5Memo := {}

nRc4NomFun		 := GdFieldPos ( "RC4_NOMFUN" , aRC4Header )
cRc4Filial		 := xFilial("RC4")
cRc4NomFun		 := aRc4Cols[1, nRc4NomFun]

DbSelectArea("RC4")
RC4->( dbSetOrder(RetOrdem("RC4","RC4_FILIAL+RC4_NOMFUN")) )
lAddNew	:= RC4->( !MsSeek( cRc4Filial + cRc4NomFun ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Atualizar a funcao                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF RC4->( RecLock( "RC4" , lAddNew ) )

	// gravacao dos campos comuns //
	For nG := 1 To Len(aRC4Header)
	   	cCampo		:= Upper( aRC4Header[nG, 2] )
    	nFieldPos	:= RC4->( FieldPos( cCampo ) )
    	IF ( nFieldPos > 0 )
	   		If !( cCampo $ "RC4_FILIAL" )
	    		nPosField := GdFieldPos( cCampo , aRC4Header )
	    		IF ( nPosField > 0 )
	    			RC4->( FieldPut( nFieldPos , aRc4Cols[ 1 , nPosField ] ) )
	    		EndIF	
	    	Else
	    		RC4->( FieldPut( nFieldPos , cRc4Filial ) )
	    	EndIf
	    EndIF
	Next nG
	RC4->( MsUnLock() )

	// gravacao dos campos Memos Virtuais //
	For nG := 1 To Len(aRC4Header)
		cCampo := Upper(aRC4Header[nG, 2])
	    If (aRC4Header[nG, 8] == "M") .and. ((nRc4Memo := aScan(aRC4Memo, { |x|  Upper(x[2]) == cCampo })) > 0)
	    	nPosCpoMemo := GdFieldPos( aRC4Memo[nRc4Memo, 1], aRC4Header)
	    	cValueMemo := StrTran(aRc4Cols[1,GdFieldPos(cCampo,aRC4Header)], "\13\10", CRLF)
			MsMm(aRc4Cols[1,nPosCpoMemo],80,NIL,cValueMemo ,1,NIL,NIL,"RC4", aRC4Memo[nRc4Memo, 1])
		EndIf
	Next nG

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Efetua a Delecao do RC5 antes de fazer a inclusao       	    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea( "RC5" )
	RC5->( dbSetOrder(RetOrdem("RC5","RC5_FILIAL+RC5_NOMFUN+RC5_SEQ")) )
	If RC5->( dbSeek( cRc4Filial + cRc4NomFun ) )
		cRc4Filial := AllTrim(Upper(cRc4Filial))
		cRc4NomFun := AllTrim(Upper(cRc4NomFun))
		While RC5->(;
						!Eof();
						.and.;
						(;
							(;
								AllTrim(Upper(RC5_FILIAL));
								+;
								AllTrim(Upper(RC5_NOMFUN));
							);
							==;
			            	(;
			            		cRc4Filial;
			            		+;
			            		cRc4NomFun;
			            	);
			            );
			       )
			IF RecLock( "RC5" , .F. )
				RC5->( dbDelete() )
				RC5->( MsUnlock() )
			EndIF
			RC5->( dbSkip() )
		EndDo
	EndIf

	For nG := 1 to Len(aRc5Cols)

		IF RC5->( RecLock( "RC5" , .T. ) )
			// gravacao dos campos //
			For nY := 1 To Len( aRC5Header )
				cCampo 		:= Upper( aRC5Header[nY, 2] )
				nFieldPos	:= RC5->( FieldPos( cCampo ) )
				IF ( nFieldPos > 0 )
					If ( cCampo != "RC5_FILIAL" )
				    	nPosField := GdFieldPos( cCampo , aRC5Header )
				    	IF ( nPosField > 0 )
				    		RC5->( FieldPut( nFieldPos , aRc5Cols[ nG , nPosField ] ) )
				    	EndIF
				    Else
				   		RC5->( FieldPut( nFieldPos , cRc4Filial ) )
				    EndIf
				EndIF
			Next nY
			RC5->( MsUnlock() )
		EndIF
	
		// gravacao dos campos memos virtuais //
		For nY := 1 To Len( aRC5Header )
			cCampo := Upper( aRC5Header[nY, 2] )
			If ( aRC5Header[nY, 8] == "M" ) .and. ( nRc5Memo := aScan(aRC5Memo, { |x|  Upper(x[2]) == cCampo }) > 0 )
		    	nPosCpoMemo := GdFieldPos( aRC5Memo[nRc5Memo, 1], aRC5Header)
	   	    	cValueMemo := StrTran(aRc5Cols[GdFieldPos(cCampo, aRC5Header)], "13/10", CRLF)
				MsMm(aRc5Cols[nPosCpoMemo],80,NIL, cValueMemo,1,NIL,NIL,"RC5", aRC5Memo[nRc5Memo, 1])
		    EndIf
		Next nY
	Next nG
EndIF

Return( NIL )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³fCarMnemo ³ Autor ³ R.H. -  Natie         ³ Data ³ 23/05/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Carrega as variaveis p/cadastro de Mnemonicos              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fMnemo()                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parƒmetros³                                                            ³±±
±±³			 ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ Gen‚rico 												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fCarMnemo()

Local aAux		:= {}
Local aRCAHeader:= {}

Local bFunc		:= { || NIL }

Local cCampo	:= ""
Local cFilRCA	:= xFilial( "RCA" )
Local cMnemo	:= ""
Local cFunction	:= ( "GpMne" + cPaisLoc )

Local nFieldPos
Local nPosField
Local nPosMnemo
Local nPosAcumul
Local nPosDesc
Local nPosConteu
Local nPosTipo
Local nAux
Local nAuxs
Local nX
Local nPosProc

Local uCnt

Local lUpdate	:= .F.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verificar a existencia do mnemonico padrao do pais corrente   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF FindFunction( cFunction )
	bFunc := __ExecMacro( "{ ||  " + cFunction + "( @aAux , @aRCAHeader ) }" )
	Eval( bFunc )
	nPosMnemo  := GdFieldPos ( "RCA_MNEMON" , aRCAHeader )
	nPosAcumul := GdFieldPos ( "RCA_ACUMUL" , aRCAHeader )
	nPosDesc   := GdFieldPos ( "RCA_DESC" , aRCAHeader )
	nPosConteu := GdFieldPos ( "RCA_CONTEU" , aRCAHeader )
	nPosTipo   := GdFieldPos ( "RCA_TIPO" , aRCAHeader )
	nPosProc   := GdFieldPos ( "RCA_PROCES" , aRCAHeader )
	nAuxs 	   := Len(aAux)
	DbSelectarea( "RCA")
	DbSetOrder( 1 )
	For nAux := 1 To nAuxs
		cMnemo := Padr(Upper( AllTrim( aAux[ nAux, nPosMnemo ])),TamSX3("RCA_MNEMON")[1])
		lUpdate := .F.
		If !RCA->(dbSeek(cFilRCA + cMnemo))
			IF RecLock("RCA",.T.,.T.)
				For nX := 1 To Len(aRCAHeader)
				   	cCampo := Upper(aRCAHeader[nX, 2])
					nFieldPos := RCA->( FieldPos( cCampo ) )
					IF ( nFieldPos > 0 )
						If ( aRCAHeader[nX, 2] == "RCA_FILIAL" )
							uCnt := cFilRCA
						Else
					    	nPosField := GdFieldPos( cCampo , aRCAHeader )
					    	IF ( nPosField == 0 )
					    		Loop
					    	EndIF
					    	uCnt := aAux[ nAux , nPosField ]
						Endif
						RCA->( FieldPut( nFieldPos , uCnt ) )
					EndIF
				Next nX
				RCA->( MsUnlock() )
			EndIF	
		Else
			If nPosAcumul > 0
				If AllTrim(RCA->RCA_ACUMUL) <>  AllTrim(aAux[ nAux, nPosAcumul ])
					lUpdate := .T.
					RecLock("RCA",.F.,.T.)
					RCA->RCA_ACUMUL := aAux[ nAux, nPosAcumul ]
				EndIf
			EndIf
			If nPosDesc > 0
				If AllTrim(RCA->RCA_DESC) <>  AllTrim(aAux[ nAux, nPosDesc ])
					If !lUpdate
						lUpdate := .T.
						RecLock("RCA",.F.,.T.)
					EndIf
					RCA->RCA_DESC := aAux[ nAux, nPosDesc ]
				EndIf
			EndIf
			If nPosConteu > 0 .and. SubStr(RCA->RCA_MNEMON,1,2) <> "P_"
				If AllTrim(RCA->RCA_CONTEU) <>  AllTrim(aAux[ nAux, nPosConteu ]) 
					If !lUpdate
						lUpdate := .T.
						RecLock("RCA",.F.,.T.)
					EndIf
					RCA->RCA_CONTEU := aAux[ nAux, nPosConteu ]
				EndIf
			EndIf
			If nPosTipo > 0
				If AllTrim(RCA->RCA_TIPO) <>  AllTrim(aAux[ nAux, nPosTipo ]) 
					If !lUpdate
						lUpdate := .T.
						RecLock("RCA",.F.,.T.)
					EndIf
					RCA->RCA_TIPO := aAux[ nAux, nPosTipo ]
					If AllTrim(RCA->RCA_MNEMON) == "P_ADCINTEG" //Retirar no próximo release
						RCA->RCA_CONTEU := If(&(RCA->RCA_CONTEU),'"12345"','""')
					EndIf
				EndIf			
			EndIf
			If nPosProc > 0 
				If AllTrim(RCA->RCA_PROCES) <>  AllTrim(aAux[ nAux, nPosProc ]) 
					If !lUpdate
						lUpdate := .T.
						RecLock("RCA",.F.,.T.)
					EndIf
					RCA->RCA_PROCES := aAux[ nAux, nPosProc ]
				EndIf
			EndIf
			If lUpdate
				RCA->( MsUnlock() )
			EndIf
		EndIf
	Next nAux
EndIf

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ FCHKSRM	³ Autor ³ J. Ricardo 			³ Data ³		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica a existencia do Roteiro de Calculo				  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function FCHKSRM(cFilCarrega)
	Local lRet := .T.
	Local cAlias := ALIAS()
	Local nRecSx2 := SX2->(RECNO())
	dbSelectArea("SX2")
	dbSeek("SRM")
	
	cFilCarrega:= xFilial("SRM", cFilCarrega)
	
	If ! FGeraRoteiro(cFilCarrega)
		lRet := (.F.)
	Endif

	SX2->(DBGOTO(nRecSx2))
	dbSelectArea(cAlias)
Return (lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ FGeraRoteiro 	³ Autor ³ J. Ricardo	³ Data ³    	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera roteiro para cada um dos eventos					  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fGeraRoteiro( cFilSRM, aRotPadrao, lPadrao, aIdErro, lAmbos, lGP290REPL, aRotBkp, aSRYHBKP, aSRMHBkp, aSYPHBkp, lForcaComp )

Local aRotSRY		:= {}					// Tabela de Roteiros
Local aSRYHeader	:= {}					// Header de SRY
Local aSRMHeader 	:= {}
Local aSYPHeader	:= {}
Local aSYPMemo		:= {}

Local bFunc

Local cRotNum		:= ""
Local cRoteiro		:= ""
Local cChave		:= ""
Local cFunction		:= ""

Local lRet			:= .T.

Local nPosCalculo
Local nPosDes
Local nPosVersao
Local nPosAlias
Local nPosOrdinar
Local nPosInteg
Local nPosTipo
Local nPosObs
Local nPosPerg
Local nPosContab
Local nPosModulo
Local nX

DEFAULT cFilSRM		:= xFilial( "SRM" , cFilSRM )
DEFAULT aRotPadrao	:= {}
DEFAULT aIdErro		:= {}
DEFAULT lPadrao		:= .F.
DEFAULT lAmbos		:= .F.
DEFAULT lGP290REPL	:= .F.
DEFAULT lForcaComp	:= .F.
DEFAULT aRotBkp		:= {}
DEFAULT aSRYHBKP	:= {}
DEFAULT aSRMHBkp	:= {}
DEFAULT aSYPHBkp	:= {}

aRoteiro	:= {}
aRotPadrao	:= {}

cFunction := ( "GpRot" + If(fUsaGFP() .AND. cModulo == "GFP" .AND. !lAmbos,"GFP",cPaisLoc) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verificar a existencia da formula padrao do pais corrente     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !( lRet := FindFunction( cFunction ) )
	Return .F.
EndIF

If lGP290REPL .And. !Empty(aRotBkp)
	aRotSRY 	:= aClone(aRotBkp)
	aSRYHeader 	:= aClone(aSRYHBKP)
	aSRMHeader 	:= aClone(aSRMHBkp)
	aSYPHeader 	:= aClone(aSYPHBkp)
EndIf

If !lGP290REPL .Or. Empty(aRotBkp)
	bFunc := __ExecMacro( "{ || GpRot" + If(fUsaGFP() .AND. cModulo == "GFP" .AND. !lAmbos ,"GFP",cPaisLoc) + "( @aRotSRY , @aSRYHeader , @aSRMHeader, @aSYPHeader ) }" )
	IF !( lRet := Eval( bFunc ) )
		Return .F.
	EndIF
EndIf
                   
nPosCalculo := GdFieldPos( "RY_CALCULO"	, aSRYHeader )
nPosDes		:= GdFieldPos( "RY_DESC"	, aSRYHeader )
nPosVersao	:= GdFieldPos( "RY_VERSAO"	, aSRYHeader )
nPosAlias	:= GdFieldPos( "RY_ALIAS"	, aSRYHeader )
nPosOrdinar	:= GdFieldPos( "RY_ORDINAR"	, aSRYHeader )
nPosTipo	:= GdFieldPos( "RY_TIPO"	, aSRYHeader )
nPosObs		:= GdFieldPos( "RY_CODOBS"	, aSRYHeader )
nPosPerg	:= GdFieldPos( "RY_PERGUNT"	, aSRYHeader )
nPosInteg	:= GdFieldPos( "RY_INTEGRA"	, aSRYHeader )
nPosContab	:= GdFieldPos( "RY_CONTAB"	, aSRYHeader )
nPosModulo	:= GdFieldPos( "RY_MODULO"	, aSRYHeader )
	
For nX := 1 To Len( aRotSry )
		If lPadrao .AND. lAmbos .AND. nPosModulo > 0 .AND. aRotSry[ nX , nPosModulo ] <> "3"
			Loop
		EndIf
		aAdd( aRotPadrao ,{ aRotSry[ nX , nPosCalculo ] , aRotSry[ nX , nPosDes ], aRotSry[ nX , nPosAlias ], aRotSry[ nX , nPosOrdinar ], aRotSry[ nX , nPosTipo ],;
		 					aRotSry[ nX , nPosObs ], aRotSry[ nX , nPosPerg ], aRotSry[ nX , nPosInteg] , aRotSry[ nX , nPosContab],Iif(nPosModulo > 0, aRotSry[ nX , nPosModulo ],"")} )
	Next nX
	
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se nao For para Retornar o aRotPadrao Carrega os Roteiros     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF !( lPadrao )
		
	cRotNum := "0000"
	For nX := 1 To Len( aRotPadrao )			
		cRotNum 	:= Soma1( cRotNum )
		cRoteiro	:= aRotPadrao[ nX , 1 ]
		cFunction	:= ( "Rot" + If(fUsaGFP() .AND. cModulo == "GFP" .AND. !lAmbos,"GFP",cPaisLoc) + cRotNum )
		IF FindFunction( cFunction )
			bFunc := __ExecMacro( "{ || " + cFunction + "(cRoteiro , c__Roteiro , @aRoteiro, @aSYPMemo) }" )
			Eval( bFunc )
		EndIF
	Next nX
		
	cChave := aRotSry[ aScan( aRotSry , { |x, y| x[ nPosCalculo ] == c__Roteiro } ) , nPosVersao ]
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Efetua a Geracao dos Roteiros Padroes    					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	lRet := FCriaRoteiro( cFilSRM , c__Roteiro , aRotPadrao , cChave , aSRMHeader, aSYPMemo, aSYPHeader, @aIdErro, lGP290REPL, aRotBkp, aSRYHBKP, aSRMHBkp, aSYPHBkp, lForcaComp )

Else

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Caso contrario Retorna apenas o aRotPadrao					³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	lRet := lPadrao

EndIF

If lGP290REPL .And. lPadrao .And. !Empty(aRotSRY)
	aRotBkp 	:= aClone(aRotSRY)
	aSRYHBKP 	:= aClone(aSRYHeader)
	aSRMHBkp 	:= aClone(aSRMHeader)
	aSYPHBkp 	:= aClone(aSYPHeader)
EndIf

Return( lRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ FCriaRoteiro	    ³ Autor	J. Ricardo	    ³ Data ³		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Roteiro no SRM 									  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function FCriaRoteiro(cFil, cTipo, aRotPadrao, cChave, aSRMHeader, aSYPMemo, aSYPHeader, aIdErro, lGP290REPL, aRotBkp, aSRYHBKP, aSRMHBkp, aSYPHBkp, lForcaComp)

Local aRotUsua	:= {}
Local aRotNovo	:= {}
Local aMemoBco  := {}

Local cKey
Local cCampo
Local cAlias	:= "SRM"
Local cDesc		:= ""
Local cPergunt  := ""
Local cSeq		:= ""    
Local cCliChave := "000"
Local cSryAlias	:= ""
Local cSryOrdinar:=""
Local cSryTipo	:= ""
Local cCodObs	:= ""
Local cSrySeqFil:= ""
Local cIdAux	:= ""
Local cVerbAux	:= ""
Local cSryContab:= ""
Local cSryModulo:= ""

Local lRet		:= .T.
Local lRevisao := .F.
Local lNovo		:= .F.
Local nX 		:= 0.00  
Local nY		:= 0.00
Local nReg		:= 0.00
Local nRoteiro	:= 0.00
Local nPosRot	:= 0.00
Local nTamSeq   := TamSX3( "RM_SEQ    ")[1]
Local nPosArr
Local nPosSYPFilial
Local nPosSYPChave
Local nPosSYPSeq
Local lSRYModulo:= SRY->(ColumnPos("RY_MODULO")) > 0

DEFAULT aIdErro 	:= {}
DEFAULT aRotBkp		:= {}
DEFAULT aSRYHBKP	:= {}
DEFAULT aSRMHBkp	:= {}
DEFAULT aSYPHBkp	:= {}
DEFAULT lGP290REPL 	:= .F.
DEFAULT lForcaComp  := .F.

Begin Sequence

	nPosSYPFilial	:= GdFieldPos ( "YP_FILIAL" , aSYPHeader )
	nPosSYPChave 	:= GdFieldPos ( "YP_CHAVE" , aSYPHeader )
	nPosSYPSeq		:= GdFieldPos ( "YP_SEQ" , aSYPHeader )
	nPosSYPTexto	:= GdFieldPos ( "YP_TEXTO" , aSYPHeader )

	cTipo := Upper( AllTrim( cTipo ) )
	IF ( nPosRot := aScan( aRotPadrao , { |x| x[1] == cTipo } ) ) > 0.00
		cDesc 		:= aRotPadrao[ nPosRot , 2 ]
		cSryAlias	:= aRotPadrao[ nPosRot , 3 ]
		cSryOrdinar	:= aRotPadrao[ nPosRot , 4 ]
		cSryTipo	:= aRotPadrao[ nPosRot , 5 ]
		cCodObs		:= aRotPadrao[ nPosRot , 6 ]
		cPergunt	:= aRotPadrao[ nPosRot , 7 ]
		cIntegra	:= aRotPadrao[ nPosRot , 8 ]
		cSryContab  := aRotPadrao[ nPosRot , 9 ]
		cSryModulo  := aRotPadrao[ nPosRot ,10 ]
	EndIF

	cFil := xFilial( "SRY" , cFil )

	dbSelectArea("SRY")
	lNovo := !(SRY->( dbSeek ( cFil + cTipo ) ))
	If !Empty(SRY->RY_VERSAO)
		cCliChave := SRY->RY_VERSAO
	EndIf

	dbSelectArea("SRM")
	// Avalia se necessita de Revisao
	If SRM->( dbSeek ( cFil + cTipo ) )
		While SRM->(;
						!Eof();
						.and.;
						( ( RM_FILIAL + RM_CALCULO ) == ( cFil + cTipo ) );
					)	
			IF (;
					SRM->( Val( RM_SEQ ) % 10 == 0);
					.and.;
					( Val(cCliChave) < Val(cChave) );
				)	
				lRevisao := .T.
				Exit
			EndIF
			SRM->( dbSkip() )
		EndDo
		IF !( lRevisao ) .and. !lForcaComp
			lRet := .T.
			Break
		EndIF
		SRM->( dbSeek( cFil + cTipo ) )
		While SRM->(;
						!Eof();
						.and.;
						( ( RM_FILIAL + RM_CALCULO ) == ( cFil + cTipo ) );
					)	

			cSeq := StrZero( Val( SRM->RM_SEQ ) , nTamSeq )

			nReg++
			aAdd( aRotUsua, {} )
			For nX := 1 To Len(aSRMHeader)
				If aSRMHeader[nX, 2] == "RM_SEQ"
					aAdd(aRotUsua[nReg], cSeq)
				Else
					aAdd( aRotUsua[nReg] , SRM->( FieldGet( FieldPos( aSRMHeader[nX, 2] ) ) ) )
				EndIf
			Next nX
			
			SRM->( dbSkip() )
		EndDo
		
		cSrySeqFil := ""
		If Empty(SRY->RY_SEQFIL)
			cSrySeqFil := GetSrySeqFil(cFil)
		EndIf

		RecLock("SRY",lNovo,.T.)

		SRY->RY_FILIAL	:= If(lNovo,cFil,SRY->RY_FILIAL)
		SRY->RY_CALCULO	:= If(lNovo,cTipo,SRY->RY_CALCULO)
		SRY->RY_DESC	:= If(lNovo,cDesc,SRY->RY_DESC)
		SRY->RY_ORIGEM 	:= If(lNovo,"1",SRY->RY_ORIGEM)
		SRY->RY_CODOBS 	:= If(lNovo,cCodObs,SRY->RY_CODOBS)

		SRY->RY_VERSAO	:= cChave
		SRY->RY_RECOMP	:= "1"	//Forca a Recompilacao do Roteiro
		SRY->RY_TIPO 	:= cSryTipo
		SRY->RY_ORDINAR	:= cSryOrdinar
		SRY->RY_ALIAS	:= cSryAlias
		SRY->RY_DESC	:= cDesc
		SRY->RY_PERGUNT	:= cPergunt
		If !Empty(cSrySeqFil)
			SRY->RY_SEQFIL	:= cSrySeqFil
		EndIf
		If SRY->RY_CODOBS <> cCodObs
			cCodObs := SRY->RY_CODOBS
		EndIf
		SRY->RY_INTEGRA := cIntegra
		SRY->RY_CONTAB := cSryContab
		If lSRYModulo
			SRY->RY_MODULO := cSryModulo
		EndIf
		SRY->( MsUnLock() )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Gravacao e/ou alteracao das observacoes              		   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !Empty(aSYPMemo)
			DbSelectArea( "SYP" )
			DbSetOrder( 1 ) // YP_FILIAL+YP_CHAVE+YP_SEQ

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Armazenar para verificar se existe necessidade de excluir    ³
			³ algum item do banco de dados.                                ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cKey := aSYPMemo[ 1, nPosSYPFilial] + cCodObs
			DbSeek( cKey, .F. )
			While !Eof() .and. SYP->(YP_FILIAL+YP_CHAVE) == cKey
				aAdd( aMemoBco, { SYP->YP_FILIAL, SYP->YP_CHAVE, SYP->YP_SEQ, "" } )
				DbSkip()
			EndDo
			
			For nX := 1 To Len( aSYPMemo )
				cKey := aSYPMemo[ nX, nPosSYPFilial] + cCodObs + aSYPMemo[ nX, nPosSYPSeq]
				DbSeek( cKey, .F. )
				If SYP->( Eof() )
					RecLock("SYP",.T.,.T.)
				Else
					RecLock("SYP",.F.,.T.)
				EndIf
				For nY := 1 To Len( aSYPHeader )
					cCampo := aSYPHeader[ nY, 2 ]
					If cCampo == "YP_CHAVE"
						SYP->( &cCampo ) := cCodObs
					Else
						SYP->( &cCampo ) := aSYPMemo[nX,nY]
					EndIf
				Next nY
				SYP->( MsUnLock() )
				nPosArr := ascan( aMemoBco, { | x, y| x[1] == aSYPMemo[ nX, nPosSYPFilial] .and. x[2] = cCodObs .and. x[3] == aSYPMemo[ nX, nPosSYPSeq] })
				If nPosArr > 0
					aMemoBco[nPosArr, 4] := "1"
				EndIf
			Next nX

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Excluir da Tabela os itens que nao necessitam mais 		   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If Len( aSYPMemo ) < Len( aMemoBco )
				For nX := 1 To Len( aMemoBco )
					If aMemoBco[nX, 4] == "1"
						Loop
					Else
						cKey := aMemoBco[nX, 1] + aMemoBco[nX, 2] + aMemoBco[nX, 3]
						DbSeek( cKey, .F. )
						If !Eof()
							RecLock("SYP",.F.,.T.)
							SYP->( dbDelete() )
							SYP->( MsUnLock() )
						EndIf
					EndIf
				Next nX
			EndIf
		EndIf
	EndIF

	IF Len(aRotUsua) > 0
		IF !FReorRot( @aRoteiro , @aRotUsua , nTamSeq , aSRMHeader )
			lRet := .F.
			Break
		EndIF
		aRotNovo := aClone(aRotUsua)
	Else
		aRotNovo := aClone(aRoteiro)
	EndIF

	dbSelectArea(cAlias)
	
	While SRM->( dbSeek( cFil + cTipo , .F. ) )
		IF RecLock( cAlias , .F. , .T. )
			SRM->RM_FILIAL := "##"
			SRM->( MsUnlock() )
		Else
			lRet := .F.
			Break
		EndIF
	EndDo

    // Ajustado a ordem de gravacao(integridade). Primeiro Pai(SRY) e depois a tabela filho(SRM).
	IF SRY->( !dbSeek( cFil + cTipo , .F. ) ) .And. !(cTipo == fGetCalcRot("5") .And. cPaisLoc == "PAR") // cTipo == "131"
		cSrySeqFil := GetSrySeqFil(cFil)
		RecLock("SRY",.T.,.F.)
		SRY->RY_FILIAL	:= cFil
		SRY->RY_CALCULO	:= cTipo
		SRY->RY_DESC	:= cDesc
		SRY->RY_ORIGEM 	:= "1"
		SRY->RY_VERSAO 	:= cChave
		SRY->RY_ALIAS	:= cSryAlias
		SRY->RY_ORDINAR	:= cSryOrdinar
		SRY->RY_TIPO	:= cSryTipo
		SRY->RY_RECOMP	:= "1"	//Forca a Recompilacao do Roteiro
		SRY->RY_CODOBS 	:= cCodObs
		SRY->RY_PERGUNT	:= cPergunt
		SRY->RY_SEQFIL	:= cSrySeqFil
		SRY->RY_INTEGRA	:= cIntegra
		SRY->RY_CONTAB  := cSryContab
		If lSRYModulo
			SRY->RY_MODULO := cSryModulo
		EndIf
		SRY->( MsUnLock() )

		If !Empty(aSYPMemo)
			DbSelectArea( "SYP" )
			DbSetOrder( 1 ) // YP_FILIAL+YP_CHAVE+YP_SEQ
			cKey := aSYPMemo[ 1, nPosSYPFilial] + aSYPMemo[ 1, nPosSYPChave]
			DbSeek( cKey, .F. )
			If !Eof()
				cCodObs := GetSX8Num("SYP","YP_CHAVE")
				ConfirmSX8()
			Else
				cCodObs	 := aSYPMemo[ 1, nPosSYPChave]
			EndIf
			For nX := 1 To Len( aSYPMemo )
				RecLock("SYP",.T.,.T.)
				For nY := 1 To Len( aSYPHeader )
					cCampo := aSYPHeader[ nY, 2 ]
					If cCampo == "YP_CHAVE"
						SYP->( &cCampo ) := cCodObs
					Else
						SYP->( &cCampo ) := aSYPMemo[nX,nY]
					EndIf						
				Next nY
				SYP->( MsUnLock() )
			Next nX
			If SRY->RY_CODOBS <> cCodObs
				RecLock("SRY",.F.,.T.)
				SRY->RY_CODOBS := cCodObs
				SRY->( MsUnLock() )			
			EndIf
		EndIf
	EndIF
	
	For nRoteiro := 1 To Len(aRotNovo)
		IF SRM->( dbSeek("##") )
			RecLock(cAlias,.F.)
			lNovo := .F.
		Else
			RecLock(cAlias,.T.)
			lNovo := .T.
		EndIF
		For nX := 1 To Len(aSRMHeader)
			If aSRMHeader[nX, 2] == "RM_FILIAL"
				SRM->RM_FILIAL	:= cFil
			ElseIf aSRMHeader[nX, 2] == "RM_VERBA"
				cCampo   := Upper(aSRMHeader[nX, 2])
				cIdAux 	 := aRotNovo[nRoteiro, GdFieldPos( cCampo , aSRMHeader ) ]
				If !Empty(cIdAux)
					cVerbAux := FGetCodFol(cIdAux)
					If Empty(cVerbAux)
						aAdd(aIdErro,(cIdAux + " - " + FGetCodFol(cIdAux,,,.T.)))
					EndIf
				Else
					cVerbAux := ""
				EndIf
				SRM->( FieldPut( FieldPos( cCampo ) , cVerbAux ) )
			Else
			   	cCampo := Upper(aSRMHeader[nX, 2])
			   	If !(Alltrim(aRotNovo[nRoteiro, GdFieldPos( "RM_FORMULA" , aSRMHeader )]) == "S_MULTV()" .And. Alltrim(cCampo) == "RM_HABILIT" .And. !lNovo)
			   		SRM->( FieldPut( FieldPos( cCampo ) , aRotNovo[nRoteiro, GdFieldPos( cCampo , aSRMHeader ) ] ) )
			   	EndIf
			Endif			
		Next nX
		SRM->( MsUnlock() )
	Next nRoteiro
	
	SRM->( dbSeek("##") )
	While SRM->( !Eof() .and. AllTrim(RM_FILIAL) == "##" )
		RecLock("SRM",.F.)
		SRM->( dbDelete() )
		SRM->( MsUnlock() )
		SRM->( dbSkip() )
	EndDo

	SRY->( GetFunRot( RY_FILIAL, RY_CALCULO, .T., Nil, Nil, Nil, Nil, Nil, Nil, Nil, lGP290REPL, aRotBkp, aSRYHBKP, aSRMHBkp, aSYPHBkp ) )

End Sequence
	
Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GPEXINI   ºAutor  ³Microsiga           º Data ³  10-11-02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Reorganiza o Roteiro                                        º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP7                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FReorRot( aRoteiro , aRotUsua , nTamSeq , aSRMHeader )

Local nFor 		:= 0
Local nContador := 0
Local nPos      := 0
Local nLenRot 	:= 0
Local nPosChave := 0
Local nPosSeq	:= 0
Local nPosCalc  := 0
Local nPosHab	:= 0

nPosChave 	:= GdFieldPos ( "RM_CHAVE"		, aSRMHeader )
nPosSeq		:= GdFieldPos ( "RM_SEQ" 		, aSRMHeader )
nPosCalc	:= GdFieldPos ( "RM_CALCULO"	, aSRMHeader )
nPosHab		:= GdFieldPos ( "RM_HABILIT"	, aSRMHeader )

nLenRot := Len( aRoteiro )
For nFor := 1 To nLenRot
	If aRoteiro[nFor, nPosChave] = "N" // Testa se e' um novo item ou Sub-item
		If aScan(aRotUsua,{ |X| AllTrim(X[nPosChave]) == AllTrim(aRoteiro[nFor,nPosChave]) }) > 0
			Loop
		Endif
		nPos := aScan(aRotUsua,{ |X| X[nPosSeq] = aRoteiro[nFor,nPosSeq] })
		If nPos > 0
			For nContador := nPos To Len(aRotUsua)
				// Se a sequencia for maior que a sequencia
				// onde foi incluso o sub-item sai do for
				If aRoteiro[nFor,nPosSeq] > aRotUsua[nContador, nPosSeq]
					Loop
				Endif
				aRotUsua[ nContador , nPosSeq ] = StrZero(Val(aRotUsua[nContador, nPosSeq]) + 10 , nTamSeq )
			Next
		EndIf
		// Adiciona o Novo item ou sub-item
		aAdd(aRotUsua,aClone( aRoteiro[ nFor ] ) )
	Endif
Next

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega no Roteiro Padrao os Roteiros do Usuario     		   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
nLenRot := Len( aRotUsua )
For nFor := 1 To nLenRot
	IF Val( aRotUsua[ nFor , nPosSeq ] ) % 10 != 0.00
		aAdd( aRoteiro , aClone( aRotUsua[ nFor ] ) )
	//-- Verifica se Rot. do usuario estava Desabilidato e mantem na atualizacao
	Elseif aRotUsua[nFor, nPosHab] == "2" .and. !Empty(aRotUsua[nFor, nPosChave])
		nPos := aScan(aRoteiro,{ |x| AllTrim(x[10]+x[2]) == AllTrim(aRotUsua[nFor, nPosCalc]+aRotUsua[nFor,nPosChave])})
		If nPos > 0
			aRoteiro[nPos,nPosHab] := "2"
		Endif	
	EndIF
Next nFor

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega o Flag de Roteiro Habilitado                 		   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aEval( aRoteiro , { |x| IF( !( x[nPosHab] == "2" ) , x[nPosHab] := "1" , NIL ) } )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ O Roteiro do Usuario Passa a Ser uma Copia do Padrao com   as³
³ alteracoes.                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aRotUsua := aClone( aRoteiro )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Deixa a Matriz na Ordem de Sequencia + Sub-Sequencia 		   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aRotUsua := aSort(aRotUsua,,,{ |x,y| x[nPosSeq] < y[nPosSeq] } )

Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GpeRstCache		³ Autor ³Marinaldo de Jesus³ Data ³30/01/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Executa as Rotinas de Inicializacao de variaveis em Cache	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                    	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GpeRstCache()

IF ( FindFunction( "fSrvStatic" ) )
	fSrvStatic()
EndIF

IF ( FindFunction( "RstfVerbas" ) )
	RstfVerbas()
EndIF

IF ( FindFunction( "RstExecCalc" ) )
	RstExecCalc()
EndIF

IF FindFunction( "RstRetOrdem" )
	RstRetOrdem()
EndIF

IF FindFunction("ApdCacheClear")
	ApdCacheClear()
EndIF

IF FindFunction("RstGpexIni")
	RstGpexIni()
EndIF

IF FindFunction("RstXMED")
    RstXMED()
EndIf

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RstGpexIni	  ³Autor ³Marinaldo de Jesus   ³ Data ³24/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Reinicializar as Static utilizadas no GPEXINI  toda vez   que³
³          ³Retornar ao Menu											 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                    	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstGpexIni()

aTab_Fol	:= {}				//Array com as Tabelas da Folha
aRot13      := {}				//Array contendo o roteiro a ser executado (13o.)
cTurnoAnt	:= "__cTnoAnt__"	//Turno Anterior

If ValType(oHash_Tab) == "O"
	HMClean(oHash_Tab)
	FreeObj(oHash_Tab)
	oHash_Tab := Nil
EndIf

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³InGpexIniExec ³Autor ³Marinaldo de Jesus   ³ Data ³24/08/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Executar Funcoes Dentro de GPEXINI                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³InGpexIniExec( cExecIn , aFormParam )						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³uRet                                                 	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function InGpexIniExec( cExecIn , aFormParam )
         
Local uRet

DEFAULT cExecIn		:= ""
DEFAULT aFormParam	:= {}

IF !Empty( cExecIn )
	cExecIn	:= BldcExecInFun( cExecIn , aFormParam )
	uRet	:= __ExecMacro( cExecIn )
EndIF

Return( uRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³IniaCodFol	   ³Autor³Marinaldo de Jesus  ³ Data ³15/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Funcao para Inicializacao do Mnemonico aCodFol              ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³IniaCodFol( cFil )	 									    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cFil														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Inicializacao do Mnemonico aCodFol		                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function IniaCodFol( cFil )

Local aCodFol := {}

DEFAULT cFil := cFilAnt

If !fp_CodFol( @aCodFol , cFil, .F. )
	aCodFol := {}
EndIf

Return( aClone( aCodFol ) )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fC13MaternºAutor  ³Natie               º Data ³  30/10/03   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Calcula Valor 13o Salario Ref.avos de Lic.Maternidade       º±±
±±º          ³e o Adiciona na Base INSS de 13o Salario                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cTipo => Tipo de Processo                                  º±±
±±º          ³          "R" - Rescisao                                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/ 
Function fC13Matern()

Local 	nAvos_OQ 	:= 0
Local 	n13AvInd 	:= 0
Local 	nBaseInss	:= 0 

Private	aTInss13	:= aClone(aTInss)          			 // Tabela de Inss 

//-- Se roteiro de rescisao, abater avo indenizado para depois calcular Base INSS
aEval( aAfast ,{ |X| nAvos_OQ += If( X[5] $ "Q", X[1], 0 ) })
//-- Para acidente de trabalho nao utilizamos os avos de afastamento para refazer a base de inss, 
//-- conforme intrucao do RPS art.214 paragrafo 6o. e 7o:
//-- Contribuicao Previdenciaria: sobre o valor integral da gratificacao natalina quando do pagamento ou credito da
//-- ultima parcela ou na rescisao do contrato de trabalho. Boletim IOB 47/2003 pg.15.
If nAvos_OQ > 0 
	//-- 13§ Sobre Aviso Previo
	aEval( aPd ,{ |X| n13AvInd  += If ( X[1]==aCodFol[115,1] .And. X[9] # "D" ,X[5] ,0)})
	//-- Base Inss Ate Lim p/ 13o. Sal./ Base Inss Acima Lim p/ 13o. Sal
	aEval( aPd ,{ |X| nBaseInss += If ( x[1] $ aCodFol[19,1]+"*"+aCodFol[20,1] .And. X[9] # "D",x[5],0.00) })
	
	If n13AvInd > 0 .And. RetValSrv(aCodFol[115,1],SRA->RA_FILIAL,"RV_INSS") == "S" 
		nBaseInss 	-= n13AvInd
		nBaseInss	:= Max(nBaseInss,0)
	Endif
	
	//-- Se houver Base de INSS s/13 Salario,  proporcionaliza para achar o valor do 13o Salario Sal.Maternidade/Acidente e 
	//-- adiciona-o na BAse de Inss 13o 
	If nBaseInss > 0 .and. nAvos > 0 
		nBaseInss := Round( ( fRetDec(@nBaseInss) / nAvos ) * nAvos_OQ , 2 ) 
		fSCAfas(  nBaseInss , .T.  )
	Endif	
Endif	

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fGeraAdtS ºAutor  ³Emerson Rosa        º Data ³  15/07/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Gera os adicionais por tempo de servico no aPd.             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³cCodAdt   - Codigo do Adicional por tempo de servico        º±±
±±º          ³nAdtServ  - Valor total do adicional (Anuenio + Bienio +...)º±±
±±º          ³nTDiasMes - Total de dias do mes (normalmente 30)			  º±±
±±º          ³nDiasProp - Dias para a proporcionalizacao				  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/ 
Function fGeraAdtS(cCodAdt,nAdtServ,nTDiasMes,nDiasProp,cRotCalc)
Local nCnt
Local cRotAux := fGetCalcRot("4")

DEFAULT cRotCalc := "   "

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se existir o array gera todos os adicionais					 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type( "aAdtServ" ) # "U" .And. Len( aAdtServ ) > 0
	For nCnt := 1 To Len(aAdtServ)
		If ( cRotCalc == cRotAux .Or. RetValSrv(aAdtServ[nCnt,1], SRA->RA_FILIAL,"RV_INCORP") # "S" ) .And.; // If cRotCalc == "RES"
		   aScan(aPd,{ |X| X[1] == aAdtServ[nCnt,1] .And. X[9] # "D" } ) == 0
			FGeraVerba(aAdtServ[nCnt,1],Round( ( aAdtServ[nCnt,3] / nTDiasMes ) * nDiasProp,2))
		EndIf
	Next nCnt
ElseIf nAdtServ > 0 .And. ( cRotCalc == cRotAux .Or. RetValSrv(cCodAdt, SRA->RA_FILIAL,"RV_INCORP") # "S" ) .And.; // If cRotCalc == "RES"
       aScan(aPd,{ |X| X[1] == cCodAdt .And. X[9] # "D" } ) == 0
	fGeraVerba(cCodAdt,Round((nAdtServ / nTDiasMes) * nDiasProp,2))
EndIf

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³ fChkBsIr ºAutor  ³Emerson Rosa        º Data ³  05/08/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Checa a existencia de verbas com incidencia do Ir           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ aPd - Array com as verbas que serao checadas				  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/ 
Function fChkBsIr(aPd,DiasTrab,dData_pgto,cRoteiro)
Local lRet    := .F.
Local nBaseIr := 0
Local lIrNeg	:= Len(aCodFol) >= 1726 .And. !Empty(aCodFol[1726,1]) .And. !Empty(aCodFol[1727,1]) 

DEFAULT cRoteiro := fGetCalcRot("1") //"FOL"

If cRoteiro == fGetCalcRot("2") //"ADI"
	If ( aScan( aPd, { |X| X[1] == aCodFol[106,1] } ) == 0 ) .And.;
	   ( RetValSrv(aCodfol[006,1],SRA->RA_FILIAL,"RV_IR") == "S" )
		lRet := .T.
	EndIf
	If !lRet .And. lIrNeg
		If ( aScan( aPd, { |X| X[1] == aCodFol[1727,1] } ) == 0 ) .And.;
		   ( RetValSrv(aCodfol[006,1],SRA->RA_FILIAL,"RV_IR") == "S" )
			lRet := .T.
		EndIf
	EndIf
ElseIf cRoteiro == fGetCalcRot("4") //"RES"
	If ( aScan( aPd, { |X| X[1] == aCodFol[106,1] } ) == 0 )
		lRet := .T.
	EndIf
	If !lRet .And. lIrNeg
		If ( aScan( aPd, { |X| X[1] == aCodFol[1727,1] } ) == 0 )
			lRet := .T.
		EndIf
	EndIf
Else
	If DiasTrab > 0 .And. !( SRA->RA_CATFUNC $ "A*P" )
		lRet := .T.
	Else
		aEval( aPd ,{ |X| IF(X[3] <= cSemana .And. X[1] # aCodFol[151,1],SomaInc(X,5,@nBaseIr,11,"N",12,"N",Month(dData_pgto),,aCodFol),Nil) } )
		lRet := ( nBaseIr > 0 )
	EndIf
EndIf

Return( lRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fBsGComis ºAutor  ³Emerson Rosa        º Data ³  30/09/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Funcao para montagem do valor total de comissao             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ 															  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/ 
Function fBsGComis(aPd, nTotComiss, aCodFol)

aEval( aPd ,{ |X| SomaInc(X,1,@nTotComis, , , , , , ,aCodFol) })

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CarParam  ºAutor  ³Microsiga           º Data ³  03/06/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Carrega parametros Sx6 conforme Filial 					  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP5                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function FCarParam(cFilPar)

Local cFilAtual := cFilAnt

cFilAnt := cFilPar

cAboAnt 	:= GetMvRH("MV_ABOPEC")    			// Parametro para abono antes das ferias
cAboAnt 	:= If(cAboAnt =="S","1","2")
cCalcInf 	:= GetMvRH("MV_CALCINF")
nValArred 	:= GetMvRH("MV_ARREDFO")           	// Arredondamento da folha
cChkSem   	:= GetMvRH("MV_GPCHSEM")
nValArr13 	:= GetMvRH("MV_ARRED13")				// Arredondamento do 13o. salario
nValArrAd   := GetMvRH("MV_ARREDAD")           	// Arredondamento do Adiantamento
nValArrFe	:= GetMvRH("MV_ARREDFE")            	// Arredondamento de Ferias
cMedDir   	:= P_MEDDIREN			           	// Medias de direito
cAbatAfas 	:= GetMvRH("MV_ABATAFA")          	// Abate avos no 13o. salario
cPgSalMat 	:= GetMvRH("MV_PGSALMA")           	// Paga Salario Maternidade
cInssFM	  	:= GetMvRH("MV_DINSSFM")	 			// Desc.Inss Ferias MS
cCompMes    := GetMvRH("MV_COMPMES") 			// Carrega parametro composicao do mes
cAdtoPro    := GetMvRH("MV_ADTOPRO")           	// Calcula Adiantamento Proporcional
cDif13Neg 	:= GetNewPar("MV_DF13NEG","S")        	// Gerar diferenca de 13o. negativa S/N
lMAprendiz  := GetMvRH("MV_MAPREND", .F., .F.) 	// Calculo do Menor Aprendiz

cFilAnt := cFilAtual

Return(.T.)

/*/      
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fChkTurno ºAutor  ³Emerson Rosa        º Data ³  13/08/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Busca a composicao do mes no turno do funcionario		  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ 															  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/ 
Function fChkTurno()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Busca composicao do mes do parametro turno de trabalho		 ³
//³ se estiver zerado, considera parametro normal				 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cTurnoAnt := SRA->RA_FILIAL+SRA->RA_TNOTRAB

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Funcao para Carregar o Array aSemanas						 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !fCarPeriodo( cPeriodo , cRot , @aPeriodo , @lUltSemana , @nPosSem )
	nRet := 3
Else
	Normal   :=  aPeriodo[nPosSem,14]
	Descanso :=  aPeriodo[nPosSem,13]
EndIf

If Normal == 0 .Or. Descanso == 0
	If GetRemoteType() == -1
		MsgLogGrid( Ap5GetHelp("GPMSHNODE"), .F. )
	Else
		HELP(' ',1,"GPMSHNODE")
	EndIf
	lFinalCalc := .T.	
EndIf

Return Nil

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fCarTab(aTabelas)³Autor³Mauro Sergio       ³Data ³21/07/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carregar Tabelas no array para calculo                      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fCarTab( aTabelas )		       								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Calculo Gpexcal1 Gpexcalc                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³       														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aTabelas -> Array com a carga da tabela       				³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fCarrTab( aTabFol, cTab, dDataRef, lOnlyTab, cAnoMes, lCarNew, cFil )

Local aCabTab 	:= {}
Local aSvTabFol	:= aClone( aTab_Fol )
Local aOnlyTab  := {}
Local cFilRcc	:= "" //Determina Filial Pesquisa Rcc
Local cAnoMesRef:= ""
Local nPosIni	:= 0
Local nColAte	:= 0
Local nTamCpo 	:= 0
Local cConteudo	:= ""
Local nT 		:= 0
Local nFound	:= 0
Local nX        := 0   
Local lRet      := .T. 
Local cAliasRCC := "RCC"
Local cOrdem 	:= "%RCC.RCC_FILIAL,RCC.RCC_CODIGO,RCC.RCC_FIL,RCC.RCC_CHAVE,RCC.RCC_SEQUEN%"
Local cWhere 	:= ""
Local cWhereAux := ""
Local cContTmp	:= ""

DEFAULT lOnlyTab := .F.     
// Ativar flag caso a rotina mae esteja atualizando a tabela
// durante o processo e existe a adicao de novos itens na 
// tabela RCC e estes precisam ser atualizados/inclusos no array aTab_Fol
DEFAULT lCarNew := .F. 
DEFAULT cFil    := xFilial("SRA")

Static aRCBS033  := {}

If cTab == "S033"
	If lIniS033
		GpIniTab()
		lIniS033 := .F.
	EndIf
	RstGpexIni()
EndIf

//--Determina Filial de Busca da tabela RCB
dbSelectArea("RCB")
cFilRcb := xFilial("RCB",cFil)

//--Determina Filial Pesquisa RCC
dbSelectArea("RCC")
cFilRcc := xFilial("RCC",cFil)

//--Determina Data a ser Carregada
dDataRef := If (dDataRef == Nil, dDataBase,dDataRef)

//--Determina o Ano Mes a ser Carregado
cAnoMesRef := If (cAnoMes == Nil, AnoMes(dDataRef), cAnoMes)

nFound := aScan(aTab_Fol, { |x| x[1]= cTab } )  

If nFound == 0  .Or. lCarNew

	//--Monta a clausula where para query da RCC
	If cTab == "S052"
		cWhere := "%(RCC.RCC_FIL = '" + cFil + "' OR  RCC.RCC_FIL = '"+Space(TamSx3("RCC_FIL")[1])+"') AND RCC.RCC_CODIGO = '" + cTab + "'"
	Else
		cWhere := "%RCC.RCC_FILIAL = '" + cFilRcc + "' AND RCC.RCC_CODIGO = '" + cTab + "'"
	EndIf
	
	If cTab == "S033" .AND. Substr(cAnoMesRef,5,6) == "12" .AND. Type("cTipoRot") <> "U" .And. cTipoRot = "6" //caso seja 132, busca valor acumulado em AAAA13 para compor aliquota corretamente
		cWhere += " AND RCC.RCC_CHAVE = '" + Substr(cAnoMesRef,1,4)+"13" + "'"
	ElseIf cTab $ "S033*S035"
		If cPaisLoc == "ARG"
			cWhereAux := cWhere + " AND RCC.RCC_CHAVE = '' %"
		EndIf
		cWhere += " AND RCC.RCC_CHAVE = '" + cAnoMesRef + "'"
	EndIf
	If cPaisLoc == "ARG" .and. !(cTab $ "S033*S035")
		cWhereAux := cWhere + " AND RCC.RCC_CHAVE = '' %"
	EndIf
	cWhere += "%"

	//--Pocisiona no Primeiro Elemento do Cabecalho da Tabela
	dbSelectArea("RCB")
	If !dbSeek(cFilRcb+cTab,.T.)
		lRet := .F.	
	Else
		While ! Eof() 
	
			If cTab # RCB->RCB_CODIGO
				Exit
			Endif
	
			//--Carrega o Cabecalho da Tabela 
			//Caso seja a tabela S033, guarda a estrutura da RCB p/ não verificar toda vez
			If cTab != "S033" .Or. (cTab == "S033" .And. Empty(aRCBS033))
				//--Carrega o Cabecalho da Tabela 
				aCabTab := {}
				While ! Eof() .And. cTab == RCB->RCB_CODIGO 
					If !(cTab == "S042" .And. AllTrim(RCB_CAMPOS) == "Sequencia" .AND. cPaisLoc == "BRA")
						RCB->(Aadd(aCabTab,{RCB_CAMPOS,RCB_TIPO,RCB_TAMAN,RCB_DECIMA}))
					EndIf
					dbSelectArea("RCB") 
					dbSkip()
				Enddo
				If cTab == "S033"
					aRCBS033 := aClone(aCabTab)
				EndIf
			ElseIf cTab == "S033" .And. !Empty(aRCBS033)
				aCabTab := aClone(aRCBS033)
			EndIf	
	 
			cAliasRCC := "RCCQRY"
			
			If cPaisLoc == "ARG"
				If Select(cAliasRCC) > 0
					(cAliasRCC)->(dbCloseArea())
				EndIf
			EndIf

			If cTab == "S043"
				BeginSql Alias cAliasRCC                             
					SELECT RCC.*		
					FROM %table:RCC% RCC		
					WHERE %exp:cWhere% AND 
						   RCC.%notDel%
						   AND RCC.RCC_FIL <> %exp:Space(Tamsx3("RCC_FILIAL")[1])%	
				    UNION 
					SELECT RCC.*		
					FROM %table:RCC% RCC		
					WHERE %exp:cWhere% AND 
						   RCC.%notDel%
						   AND RCC.RCC_FIL = %exp:Space(Tamsx3("RCC_FILIAL")[1])%	
					
				EndSql
			
			Else
				BeginSql Alias cAliasRCC                             
					SELECT RCC.*		
					FROM %table:RCC% RCC		
					WHERE %exp:cWhere% AND 
						   RCC.%notDel%	
					ORDER BY %exp:cOrdem%
				EndSql

				IF (cAliasRCC)->(Eof()) .and. cPaisLoc == "ARG" //Tratamento para RCC_CHAVE igual a branco.
					(cAliasRCC)->( dbCloseArea() )
					BeginSql Alias cAliasRCC                             
						SELECT RCC.*		
						FROM %table:RCC% RCC		
						WHERE %exp:cWhereAux% AND 
							RCC.%notDel%	
						ORDER BY %exp:cOrdem%
					EndSql
				EndIf

			EndIf
	
			
			//--Carregar Dados das Tabelas 
			If cTab != "S052"
				While (cAliasRCC)->( ! Eof() .And. (cAliasRCC)->RCC_FILIAL+(cAliasRCC)->RCC_CODIGO == cFilRcc+cTab )
				
			 		Aadd(aTab_Fol,{cTab,(cAliasRCC)->RCC_FIL,(cAliasRCC)->RCC_CHAVE,(cAliasRCC)->RCC_SEQUEN})
			 		Aadd(aSvTabFol,{cTab,(cAliasRCC)->RCC_FIL,(cAliasRCC)->RCC_CHAVE,(cAliasRCC)->RCC_SEQUEN})
			 		Aadd(aOnlyTab,{cTab,(cAliasRCC)->RCC_FIL,(cAliasRCC)->RCC_CHAVE,(cAliasRCC)->RCC_SEQUEN})
		
					nPosIni := 1
					nColAte := 1
					For nT:= 1 To Len(aCabTab) 
		                                         
						//--Tamanho do Campo                                          	                
						nTamCpo := aCabTab[nT,3]
						cContTmp := (cAliasRCC)->RCC_CONTEU
						If cTab == "S042" .and. Len(alltrim(cContTmp)) >= 17
							cContTmp := substr((cAliasRCC)->RCC_CONTEU,3)
						EndIf
						//--Guarda conteudo do campo na Variavel 				
						If aCabTab[nT,2] == "C"
							cConteudo := Subs(cContTmp,nPosIni,nTamCpo)
						ElseIf aCabTab[nT,2] == "N"
							cConteudo := Val(Subs(cContTmp,nPosIni,nTamCpo))
						ElseIf aCabTab[nT,2] == "D"
							cConteudo := Subs(cContTmp,nPosIni,nTamCpo)
							cConteudo := If("/" $ cConteudo , CtoD(cConteudo) , StoD(cConteudo))
						Endif             
		
				 		Aadd(aTab_Fol[Len(aTab_Fol)],cConteudo)
				 		Aadd(aSvTabFol[Len(aSvTabFol)],cConteudo)
				 		Aadd(aOnlyTab[Len(aOnlyTab)],cConteudo)
						       
						//--Posicao Proximo Campo
						nPosIni += nTamCpo
					Next nT
		
					(cAliasRCC)->( dbSkip() )
				Enddo
			Else
				
				While (cAliasRCC)->(!Eof()) .And. (cAliasRCC)->RCC_CODIGO == cTab  
		
					If ( (cAliasRCC)->RCC_FIL == cFil  .or. Empty((cAliasRCC)->RCC_FIL))
					
				 		Aadd(aTab_Fol,{cTab,(cAliasRCC)->RCC_FIL,(cAliasRCC)->RCC_CHAVE,(cAliasRCC)->RCC_SEQUEN})
				 		Aadd(aSvTabFol,{cTab,(cAliasRCC)->RCC_FIL,(cAliasRCC)->RCC_CHAVE,(cAliasRCC)->RCC_SEQUEN})
				 		Aadd(aOnlyTab,{cTab,(cAliasRCC)->RCC_FIL,(cAliasRCC)->RCC_CHAVE,(cAliasRCC)->RCC_SEQUEN})
			
						nPosIni := 1
						nColAte := 1
						For nT:= 1 To Len(aCabTab) 
			                                         
							//--Tamanho do Campo                                          	                
							nTamCpo := aCabTab[nT,3]
							
							//--Guarda conteudo do campo na Variavel 				
							If aCabTab[nT,2] == "C"
								cConteudo := Subs((cAliasRCC)->RCC_CONTEU,nPosIni,nTamCpo)
							ElseIf aCabTab[nT,2] == "N"
								cConteudo := Val(Subs((cAliasRCC)->RCC_CONTEU,nPosIni,nTamCpo))
							ElseIf aCabTab[nT,2] == "D"
								cConteudo := Subs((cAliasRCC)->RCC_CONTEU,nPosIni,nTamCpo)
								cConteudo := If("/" $ cConteudo , CtoD(cConteudo) , StoD(cConteudo))
							Endif             
			
					 		Aadd(aTab_Fol[Len(aTab_Fol)],cConteudo)
					 		Aadd(aSvTabFol[Len(aSvTabFol)],cConteudo)
					 		Aadd(aOnlyTab[Len(aOnlyTab)],cConteudo)
							       
							//--Posicao Proximo Campo
							nPosIni += nTamCpo
						Next nT
					EndIf
					
					(cAliasRCC)->( dbSkip() )
				Enddo
			EndIf
			
			(cAliasRCC)->( dbCloseArea() )
			
			If cTab == "S033"
				dbSelectArea("RCB")
				Exit
			Else
				dbSelectArea("RCB")
				dbSkip()
			EndIf
		Enddo
	EndIf
Else
	For nX := 1 To Len( aTab_Fol )
		//# Verifica se a tabela ainda nao existe
		If aTab_Fol[nX, 1] == cTab
		    If aScan(aSvTabFol, { |x| x[1]= cTab } ) == 0
				aAdd( aSvTabFol, aClone( aTab_Fol[nX] ) )
			EndIf
			aAdd( aOnlyTab, aClone( aTab_Fol[nX] ) )
		EndIf
	Next nX
EndIf

If lOnlyTab
	aTabFol := aClone(aOnlyTab)
Else
	aTabFol := aClone(aSvTabFol)
EndIf

If ValType(oHash_Tab) == "O"
	HMClean(oHash_Tab)
	FreeObj(oHash_Tab)
	oHash_Tab := Nil
EndIf

//Melhoria de performance, criação de hash
oHash_Tab := AToHM(aTab_Fol, 1, 0, 2, 0, 3, 0, 4, 0)

Return lRet             

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fTabela()		 ³Autor³Mauro Sergio       ³Data ³21/07/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retornar Conteudo de uma tabela criada                      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fTabela( cCodTab,nLinha,nColuna )		       				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Calculo Gpexcal1 Gpexcalc                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³       														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cCodTab 	= Codigo da tabela                         	    ³
³          ³nLinhaTab  	= Linha a ser retornada                    	    ³
³          ³nColTab 	= Coluna a Ser Retornada                  	    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fTabela( cCodTab,nLinTab,nColTab,dDataRef,cFilTab )

Local lCarTab 	:= .F.
Local nPosTab 	:= 0
Local cResult	:= ""
Local aKey		:= {}	
Local lRet		:= .F.               
Local lAchou 	:= .F.
Local aLogCalc
Local aRet
Local nX		:= 0

DEFAULT cFilTab 	:= SRA->RA_FILIAL
DEFAULT nTamFilAux  := FwGetTamFilial

dDataRef	:= If (dDataref == Nil .or. Empty(dDataRef), If(Type("aPeriodo") <> "U" .and. Len(aPeriodo) > 0, aPeriodo[1][4] ,dDataBase), dDataRef)

//--Verifica a existencia do array das tabelas caso nao exista define e carrega
If ValType(aTab_Fol) # "A" .Or. Empty(aTab_Fol)
	aTab_Fol := {}     
	lCarTab	 := .T. 
Endif	           

//--Verifica se Existe a Tabela Indicada no Array se nao existir 
//--Seta variavel para carregar
If Ascan(aTab_Fol,{ |x| x[1] == cCodTab}) == 0
	lCarTab := .T.
Endif

//--Carrega Tabela quando variavel lCarTab == .T.
If lCarTab
	fCarrTab( @aTab_Fol,cCodTab,dDataRef )
EndIf	

aAdd(aKey, cCodTab + cFilTab + MesAno(dDataRef) + Strzero(nLinTab,3) ) 
aAdd(aKey, cCodTab + Space(nTamFilAux) + MesAno(dDataRef) + Strzero(nLinTab,3) )
aAdd(aKey, cCodTab + cFilTab + Space(6) + Strzero(nLinTab,3) )
aAdd(aKey, cCodTab + Space(nTamFilAux) + Space(6) + Strzero(nLinTab,3) )

For nX := 1 to Len(aKey)
	lAchou := HMGet(oHash_Tab, aKey[nX], aRet)
	If lAchou
		cResult := Iif(Len(aRet[1]) < nColTab + 1, "", aRet[1, nColTab + 1])
		lRet 	:= .T.
		Exit
	EndIf
Next nX

//-Tratamento pra Gestao Corporativa
If fIsCorpManage() .and. !lAchou
	lAchou := fVer_Fol(@nPosTab,aTab_Fol,cCodTab,dDataRef,nLinTab)
	If lAchou .And. ((nColTab+1) <= Len(aTab_Fol[nPosTab])) .AND. (aTab_Fol[nPosTab,nColTab+1] # Nil)
		cResult := aTab_Fol[nPosTab,nColTab+1]
	Else
		lRet := .F.
	EndIf
EndIf

If ! lRet         
	aLogCalc := LogExecRot()
    If ValType(aLogCalc) # "U" .And. ValType(aLogCalc) == "A" .And. Len(aLogCalc) > 0
		cMsg := STR0126 +" ["+ cCodTab + "]  " + STR0127 + " [" + Strzero(nLinTab,4) + "]  " + STR0128 + " [" + StrZero(nColTab,4) + "]  " +STR0129
		AddLogExecRot( cMsg )		// adiciona no Log de Erros
	Else 
		Help(" ",1,"GPETABNCAD")
	EndIf	
EndIf
	
Return(cResult)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ fVer_Fol()      ³Autor³ Ademar Fernandes  ³Data ³15/03/2011³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³-Verifica se a Tabela Auxiliar esta cadastrada no RCC.      ³
³          ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Gestao Corporativa - P11                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/
Static Function fVer_Fol(nPosTab,aTab_Fol,cCodTab,dDataRef,nLinTab)
Local lAchou := .F.
DEFAULT nLinTab := 0

	//.Combinacoes possiveis
	//.Empr / UNeg / Fil
	//.  E      E     E  (ja testado acima)
	//.  E      E     C
	//.  E      C     E
	//.  E      C     C
	//.  C      C     C  (ja testado acima)
	//.  C      C     E
	//.  C      E     C
	//.  C      E     E
	
	If ( nPosTab :=    Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+Space(Len(FwFilial()))				.And. x[3] == MesAno(dDataRef) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+FwFilial()				.And. x[3] == MesAno(dDataRef) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+Space(Len(FwFilial()))	.And. x[3] == MesAno(dDataRef) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+Space(Len(FwUnitBusiness()))+FwFilial()	.And. x[3] == MesAno(dDataRef) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+Space(Len(FwFilial()))	.And. x[3] == MesAno(dDataRef) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+FwFilial()				.And. x[3] == MesAno(dDataRef) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
                                                                                                                                                                                                                                   
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+Space(Len(FwFilial()))				.And. x[3] == Space(6) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+FwFilial()				.And. x[3] == Space(6) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+Space(Len(FwFilial()))	.And. x[3] == Space(6) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+Space(Len(FwUnitBusiness()))+FwFilial()	.And. x[3] == Space(6) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+Space(Len(FwFilial()))	.And. x[3] == Space(6) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+FwFilial()				.And. x[3] == Space(6) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	Endif

Return(lAchou)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fPosTab()		 ³Autor³Mauro Sergio       ³Data ³21/07/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna a Linha ou o Conteudo de uma coluna da tabela       ³
³          ³por comparacao do conteudo,operador e coluna de comparacao. ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fPosTab(cCodTab,nColuna,cCond)   		       				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Calculo Formulas			                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³       														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cCodTab 	= Codigo da tabela                         	    ³
³          ³uCOnt1  	= Conteudo1 para comparacao			            ³
³          ³cOper1    	= Operador 1 para comparacao                    ³
³          ³nColTab1 	= Numero da Coluna1 para comparacao             ³
³          ³uCOnt2  	= Conteudo2 para comparacao			            ³
³          ³cOper2    	= Operador 2 para comparacao                    ³
³          ³nColTab2 	= Numero da Coluna2 para comparacao             ³
³          ³nColRet     = Numero da Coluna para retorno do Conteudo     ³
³          ³aASort		= Ordena os elementos conforme array especifico	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fPosTab( cCodTab,uCont1,cOper1,nColTab1,uCont2,cOper2,nColTab2,nColRet,nLinRet,nLinTab,lCarTab,cFilSeek,uCont3,cOper3,nColTab3,dDtTab,aASort,aTabDef,lOnlyTab,lCarNew)

Local cTab1Type
Local cTab2Type
Local cTab3Type
Local cCnt1Type
Local cCnt2Type
Local cCnt3Type

Local nX 		:= 0
Local nPosTab 	:= 0
Local lRet		:= .T.               
Local lAchou 	:= .F.
Local cFilTab
Local nFor
Local nTab
Local uRet		:= ""
Local cX		:= ""
Local cY		:= ""
Local cSort		:= ""
Local aLogCalc
Local cMsg
Local aInfoRCB	:= {}

DEFAULT lCarNew		:= .F.
DEFAULT lCarTab 	:= .F.
DEFAULT lOnlyTab	:= .F.
DEFAULT nLinRet 	:= 0
DEFAULT cFilSeek	:= IIf(cPaisLoc <> "BRA", xFilial("SRA"), SRA->RA_FILIAL)
DEFAULT dDtTab		:= cToD("//")
DEFAULT aASort		:= {}	//Array numerico para ordenacao. Exemplo: {1,2,3,4,7,8}
DEFAULT nTamFilAux	:= FwGetTamFilial
DEFAULT aTabDef		:= {}

If !Empty(aTabDef)
	aTab_Fol := aClone(aTabDef)
EndIf

cFilTab := cFilSeek

If Type( "dDataref" ) == "U"
	dDataRef := dDataBase
EndIf

If !Empty(dDtTab)
	dDataRef := dDtTab
EndIf

//--Verifica a existencia do array das tabelas caso nao exista define e carrega
If ValType(aTab_Fol) # "A" .Or. Empty(aTab_Fol)
	aTab_Fol := {}     
	lCarTab	 := .T. 
Endif	           

//--Verifica se Existe a Tabela Indicada no Array se nao existir 
//--Seta variavel para carregar
If Ascan(aTab_Fol,{ |x| x[1] == cCodTab}) == 0
	lCarTab := .T.
Endif

//--Carrega Tabela quando variavel lCarTab == .T.
If lCarTab
	If !Empty(aASort)
		@aTab_Fol := {}
	EndIf
	fCarrTab( @aTab_Fol,cCodTab,dDataRef,lOnlyTab,,lCarNew,cFilSeek )
	If Len(aTab_Fol) > 0 .And. cCodTab <> "S043"
		If Empty(aASort)
			aSort(aTab_Fol,,,{ |x,y|  x[1]+x[2]+x[3]+x[4] < y[1]+y[2]+y[3]+y[4] })
		Else
			For nX := 1 To Len(aASort)
				
				If aASort[nX] > 4 .AND. ValType( aTab_Fol[1][aASort[nX]] ) == "N"
					aInfoRCB := fRetRCB(cFilSeek,cCodTab, STRZERO(aASort[nX]-4,2))
					cX += If( nX == 1, '', '+') + 'StrZero(x[' + cValToChar( aASort[nX] ) + '],' + cValToChar(aInfoRCB[1][5]) + ')'
					cY += If( nX == 1, '', '+') + 'StrZero(y[' + cValToChar( aASort[nX] ) + '],' + cValToChar(aInfoRCB[1][5]) + ')'
				Else
					cX += If( nX == 1, '', '+') + 'cValToChar(x[' + cValToChar( aASort[nX] ) + '])'
					cY += If( nX == 1, '', '+') + 'cValToChar(y[' + cValToChar( aASort[nX] ) + '])'
				EndIf
				
			Next nX
			cSort := 'aSort(aTab_Fol,,,{ |x,y| ' + cX + ' < ' + cY + '})' 
			&( cSort )
		EndIf
	EndIf
Endif

//--Verifica se Existe a Tabela Cadastrada
If ( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And.x[2] == cFilTab .And. x[3] == MesAno(dDataRef) })) > 0
	lAchou := .T.
ElseIf ( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And.x[2] == Space(nTamFilAux).And. x[3] == MesAno(dDataRef) })) > 0
	lAchou := .T.
Elseif ( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And.x[2] == cFilTab .And. x[3] == Space(6) })) > 0
	lAchou := .T.
Elseif ( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And.x[2] == Space(nTamFilAux) .And. x[3] == Space(6) })) > 0
	lAchou := .T.
EndIf

//-Tratamento pra Gestao Corporativa
If fIsCorpManage() .and. !lAchou
	lAchou := fVer_Fol(@nPosTab,aTab_Fol,cCodTab,dDataRef,)
EndIf

If nLinRet > 0
	nPosTab := nLinRet
EndIf

If lAchou 

	//--Montagem dos Blocos de comparacao
	If uCont1 # Nil .And. uCont2 # Nil .And. uCont3 # Nil .And. cOper1 # Nil .And. cOper2 # Nil .And. cOper3 # Nil
		bBloco3 := & ( '({|x,y,z|uCont1' + cOper1 + 'x .And. uCont2' + cOper2 + 'y .And. uCont3' + cOper3 + 'z})' )
	EndIf
	If uCont1 # Nil .And. uCont2 # Nil .And. cOper1 # Nil .And. cOper2 # Nil
	    bBloco2 := & ( '({|x,y|uCont1' + cOper1 + 'x .And. uCont2' + cOper2 + 'y})' )  //({|x| nArea>=x})
	Endif
	If uCont1 # Nil .And. cOper1 # Nil 
	    bBloco1 := & ( '({|x,y|uCont1' + cOper1 + 'x })' )
	Endif    
	
	//--Verifica se Pasou a coluna de busca inicial
	nFor := Len(aTab_fol)
	If nPosTab > nFor
		nPosTab := nFor
	EndIf
	For nTab := nPosTab To nFor
	
		If !(aTab_Fol[nTab,1] == cCodTab)
			Exit
		EndIf

		//-- Verificar o tipo da campo e do conteudo das variaveis
		If uCont1 # Nil
			cTab1Type := ValType(aTab_Fol[nTab,nColTab1+1])
			cCnt1Type := ValType(uCOnt1)
		EndIf	
		If uCont2 # Nil
			cTab2Type := ValType(aTab_Fol[nTab,nColTab2+1])
			cCnt2Type := ValType(uCOnt2)
		EndIf
		If uCont3 # Nil
			cTab3Type := ValType(aTab_Fol[nTab,nColTab3+1])
			cCnt3Type := ValType(uCOnt3)
		EndIf
		
		//--Tratamento para versao da folha Modelo 2
		If MV_MODFOL = '2'
			If cTab1Type <> cCnt1Type 
				If cCnt1Type == "D" .and. cTab1Type == "C"
					uCOnt1 := CtoD( uCOnt1 )
				ElseIf cCnt1Type == "C" .and. cTab1Type == "D"
					uCOnt1 := DtoC( uCOnt1 )
				ElseIf cCnt1Type == "C" .and. cTab1Type == "N"
					uCOnt1 := Val( uCOnt1 )
				ElseIf cCnt1Type == "N" .and. cTab1Type == "C"
					uCOnt1 := AllTrim(Str( uCOnt1 ))
				EndIf
			EndIf
			If cTab2Type <> cCnt2Type 
				If cCnt2Type == "D" .and. cTab2Type == "C"
					uCOnt2 := CtoD( uCOnt2 )
				ElseIf cCnt2Type == "C" .and. cTab2Type == "D"
					uCOnt2 := DtoC( uCOnt2 )
				ElseIf cCnt2Type == "C" .and. cTab2Type == "N"
					uCOnt2 := Val( uCOnt2 )
				ElseIf cCnt2Type == "N" .and. cTab2Type == "C"
					uCOnt2 := AllTrim(Str( uCOnt2 ))
				EndIf
			EndIf
			If cTab3Type <> cCnt3Type 
				If cCnt3Type == "D" .and. cTab3Type == "C"
					uCOnt3 := CtoD( uCOnt3 )
				ElseIf cCnt3Type == "C" .and. cTab3Type == "D"
					uCOnt3 := DtoC( uCOnt3 )
				ElseIf cCnt3Type == "C" .and. cTab3Type == "N"
					uCOnt3 := Val( uCOnt3 )
				ElseIf cCnt3Type == "N" .and. cTab3Type == "C"
					uCOnt3 := AllTrim(Str( uCOnt3 ))
				EndIf
			EndIf
		EndIf
		
		//--Verifica se Passou a coluna de Busca final se passou analisa a coluna 
		//--Inicial e final para ver se o valor passado se encaixa nesta condicao
		If uCont1 # Nil .And. uCont2 # Nil .And. uCont3 # Nil
			If cCnt1Type = cTab1Type .And.;
			   cCnt2Type = cTab2Type .And.;
			   cCnt3Type = cTab3Type
				If Eval(bBloco3, aTab_Fol[nTab,nColTab1+1], aTab_Fol[nTab,nColTab2+1], aTab_Fol[nTab,nColTab3+1])                    
					nLinRet := Val(aTab_Fol[nTab][4])
					If nColRet # Nil .And. ! Empty(nColRet)
						uRet 	:= aTab_Fol[nTab,nColRet+1]
					Endif	
					Exit
				Else
					nLinRet := 0
				Endif	
			Endif			
		ElseIf uCont1 # Nil .And. uCont2 # Nil
			If cCnt1Type = cTab1Type .And. ;
				cCnt2Type = cTab2Type
				If Eval(bBloco2, aTab_Fol[nTab,nColTab1+1],aTab_Fol[nTab,nColTab2+1])                    
					nLinRet := IIf(!IsAlpha(aTab_Fol[nTab][4]), Val(aTab_Fol[nTab][4]), RHAlphSeq(aTab_Fol[nTab][4]))
					If nColRet # Nil .And. ! Empty(nColRet)
						uRet 	:= aTab_Fol[nTab,nColRet+1]
					Endif	
					Exit
				Else
					nLinRet := 0
				Endif
			Endif
		//Verifica se Passoua coluna Inicial e verifica se o valor passado 
		// e menor ou igual ao conteudo da coluna informada
		Elseif 	uCont1 # Nil
			If cCnt1Type = cTab1Type
				If Eval(bBloco1, aTab_Fol[nTab,nColTab1+1])
					nLinRet := Val(aTab_Fol[nTab][4])    //nTab
					If nColRet # Nil .ANd. ! Empty(nColRet)
						uRet 	:= aTab_Fol[nTab,nColRet+1]
					Endif
					Exit
				Else
					nLinRet := 0
				Endif
			Endif
		Endif
	Next nTab
Else
	lRet := .F.
Endif

If !lRet
	aLogCalc := LogExecRot()
	If ValType(aLogCalc) # "U" .And. ValType(aLogCalc) == "A" .And. Len(aLogCalc) > 0
		cMsg := STR0126 + " [" + cCodTab + "]  " + STR0129
		AddLogExecRot( cMsg )		// adiciona no Log de Erros
    Else
    	Help(" ",1,"GPETABNCAD")
    Endif
Endif

Return( If (nColret # Nil , uRet, nLinRet))

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³SetFuncoes		³ Autor ³Mauro Sergio Test.³ Data ³10/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializa as Funcoes para uso em Formulas				 	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function SetFuncoes( cFil , aFuncoes )
         
Local aArea			:= GetArea()
Local aAreaRC4		:= RC4->( GetArea() )
Local cFilRC4		:= xFilial( "RC4" , cFil )
Local cFilRC5		:= xFilial( "RC5" , cFil )
Local lSet			:= .T.

Static lIniFuncao	

DEFAULT lIniFuncao	:= .T.
DEFAULT aFuncoes	:= {}

//--INICIALIZADOR DAS FUNCOES PADROES
If ( lIniFuncao )
	GpIniFuncao()
	lIniFuncao := .F.
Endif    

IF Empty( aFuncoes )

	RC4->( dbSetOrder( 01 ) )
	
	IF ( lSet := RC4->( dbSeek( cFilRC4 , .F. ) ) )

		While RC4->( !Eof() .and. ( RC4_FILIAL == cFilRC4 ) )

			RC4->( aAdd( aFuncoes , { AllTrim( RC4->RC4_NOMFUN ) , RC4_DESC }))
			
			dbSelectArea("RC5")
			If dbSeek(cFilRC5+RC4->RC4_NOMFUN+"001")	      
				While ! Eof() .And. RC5->RC5_FILIAL+RC5->RC5_NOMFUN == cFilRC5+RC4->RC4_NOMFUN

					If Len(aFuncoes) > 0						
						RC5->( aAdd( aFuncoes[Len(aFuncoes)],{RC5_PARAM , RC5_TPARAM , RC5_OBRIG , Recno() } ))
					Endif				

					RC5->( dbSkip() )
				
				Enddo
			Endif
		
			RC4->( dbSkip() )
		
		End While
			
	EndIF

	( RestArea( aAreaRC4 ) , RestArea( aArea ) )

EndIF

Return( lSet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fCarMvto  ºAutor  ³Microsiga           º Data ³  07/30/03   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fCarMvto(cFil, cMatr, cSemana, cProces, cPeriodo, cRoteiro, cNumPag, cConvoc, lExcluiSRC, cBenOp)
Local aArea			:= GetArea()
Local aAreaSRH		:= SRH->(GetArea())
Local aStruRGB 		:= RGB->(dbStruct())
Local aTabS137		:= {}
Local aVbAuxFer		:= {}
Local cAliasRGB		:= "RGB"
Local cQuery		:= ""
Local cQryAux		:= ""
Local cWhere		:= ""
Local cSeq			:= ""
Local cNPagAux  	:= ""
Local cAno			:= ""
Local cDel			:= " "
Local dDtRefRgb		:= CtoD("//")
Local nPosParam		:= 0
Local nX			:= 0
Local nTot			:= 0
Local cCampos		:= "" 
Local aStru2RGB		:= {} 
Local lItemClVl 	:= GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3"
Local lTemMultV		:= .F.
Local lRes			:= .F.
Local lFer			:= .F.
Local lComissBen	:= (SRA->RA_CATFUNC == "C" .And. cRoteiro == "BEN")
Local lProvisao		:= IsInCallStack("GPEM070") .or. IsInCallStack("GPM070GRD")
Local lGPER080		:= IsInCallStack("GPER080")
Local cBkpBenOp		:= ""
Local cBkpConvoc	:= ""
Local lContrInt		:= If(SRC->(ColumnPos( 'RC_CONVOC' )) > 0,.T.,.F.)
Local lNrBen		:= SRC->( ColumnPos( 'RC_NRBEN' ) ) > 0
Local lUsaPLS		:= If(!Empty(TamSX3("RGB_LOTPLS")) .AND. RGB->(ColumnPos( 'RGB_LOTPLS' )) > 0,.T.,.F.)
Local cVerbaMS      := ""
Local nDPAdc1   	:= 0
Local nDPAdc2   	:= 0
Local nValEmpCons   := 0
Local nValorMS      := 0
Local nValorVerb    := 0
Local nRefMes		:= 0
Local nRefMS		:= 0
Local nVerbaApd		:= 0
Local nVerbaInf		:= 0
Local lIrNeg		:= Len(aCodFol) >= 1726 .And. !Empty(aCodFol[1726,1]) .And. !Empty(aCodFol[1727,1]) 
Local cEmpCons		:= ""
Local cPdFerMes		:= ""
Local cPdFerMSeg	:= ""
Local cPdFolMes		:= ""
Local cPdFolMSeg	:= ""
Local cVbs			:= ""
Local lOkVb1893		:= .T.
Local lTem132Per	:= .F.
Local lVerMultv		:= .F.

DEFAULT cSemana		:= Space(2)
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cMatr		:= SRA->RA_MAT
DEFAULT cProces		:= SRA->RA_PROCES
DEFAULT cPeriodo	:= Space( GetSx3Cache("RCH_PER"		, "X3_TAMANHO") )
DEFAULT cRoteiro	:= GetRotExec()
DEFAULT cNumPag		:= Space( GetSx3Cache("RCH_NUMPAG"	, "X3_TAMANHO") )
DEFAULT cConvoc		:= If(lContrInt,Space( GetSx3Cache("RC_CONVOC"	, "X3_TAMANHO") )," ")
DEFAULT lExcluiSRC	:= .T.
DEFAULT cBenOp		:= If(lNrBen, Space( GetSx3Cache("RC_NRBEN", "X3_TAMANHO") )," ")

DEFAULT lTemSeqMV	:= If(SRC->(ColumnPos( 'RC_SEQMV' )) > 0 .and. SRR->(ColumnPos( 'RR_SEQMV' )) > 0 ,.T.,.F.)
DEFAULT aDissInf	:= {}

Private lGestPubl 	:= IIF(ExistFunc("fUsaGFP"),fUsaGFP(),.F.)

Static nRGBOrd		:= RetOrdem("RGB","RGB_FILIAL+RGB_PROCES+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_MAT+RGB_PD+RGB_SEQ")
Static nSRCOrd		:= RetOrdem("SRC","RC_FILIAL+RC_MAT+RC_PERIODO+RC_ROTEIR+RC_SEMANA+RC_PD")
Static nSRDOrd		:= RetOrdem("SRD","RD_FILIAL+RD_MAT+RD_PROCES+RD_ROTEIR+RD_PERIODO+RD_SEMANA")
Static __oSt1
Static __cEmpAux
Static __cFilAux
Static __lComiss
Static __cTpRotAnt

aPd 		:= If ( Type("aPd") # "A",{},aPd)
lDissidio	:= If ( Type("lDissidio") == "U",.F.,lDissidio)
lIncCompl	:= If ( Type("P_INCCOMPL") == "U",.F.,P_INCCOMPL)
lVerMultv   := If ( Type("P_MULTV") == "U",.F.,P_MULTV)
lGrvRAZRAW  := .F.
cBkpConvoc  := cConvoc
cBkpBenOp  	:= cBenOp

If (Type("lSalInco") == "U" .Or. !lSalInco) //Não ttrata multv se estiver calculando o roteiro INC
	If lVerMultv 
		If lTemSeqMV 
			If ( lTemMultV := fLoadMultv(.F.) )
				CSEQMV := " "
				If lDissidio .Or. (cTipoRot == "6" .And. lCalcFol)
					SRD->(DbSetOrder(nSRDOrd))
					If SRD->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cProcesso + cRoteiro + cPeriodo + cNumPag )) //Busca base ir outras empresas
						CSEQMV := SRD->RD_SEQMV
					EndIf
					If Empty(cSEQMV)
						lTemMultV := .F. //Se não tinha sequencia MULTV o cálculo não foi tratado com o novo cálculo
						P_MULTV := .F.
					EndIf
				Else
					SRC->(DbSetOrder(nSRCOrd))
					If SRC->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + cRoteiro + cNumPag )) //Busca base ir outras empresas
						CSEQMV := SRC->RC_SEQMV
					EndIf
				EndIf
				If CSEQMV == " " .And. SRA->RA_SITFOLH == "D" .And. MesAno(SRA->RA_DEMISSA) == cPeriodo
					DbSelectArea("SRR")
					DbSetOrder(1)
					If SRR->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + "R" + DTOS(SRA->RA_DEMISSA)))
						cSeqMV := SRR->RR_SEQMV
					Endif
				Endif
			EndIf 
		Else 
			P_MULTV := .F.  //Se não foi criado o campo, torna o mnemonico falso para consitnuar com o processo padrão.
		EndIf 
	EndIf
EndIf

If !(lDissidio .And. IsInCallStack("S_CMEDFER"))
	If lExcluiSRC .And. (Type("lSalInco") == "U" .Or. !lSalInco) .And. (Type("lBkpCompl") == "U" .Or. !lBkpCompl)//Não apaga SRC se estiver calculando o roteiro INC ou folha complementar

		//--Exclui registros existentes na SRC
		cQuery := "DELETE FROM " + RetSqlName("SRC") + " "
		cQuery += "WHERE RC_FILIAL='" + cFil + "' AND "
		cQuery += "RC_PROCES='" + cProces + "' AND "
		cQuery += "RC_MAT='" + cMatr + "' AND "
		cQuery += "RC_PERIODO='" + cPeriodo + "' AND "	
		cQuery += "RC_SEMANA='" + cNumPag + "' AND "
		cQuery += "RC_ROTEIR='" + cRoteiro + "' "
		If lContrInt
			cQuery += " AND RC_CONVOC='" + cConvoc + "' "
		EndIf
		If lNrBen
			cQuery += " AND RC_NRBEN='" + cBenOp + "' "
		EndIf

		TcSqlExec( cQuery )
		
	EndIf
	
	If( cTipoRot == "1" .and. P_CCOMP13 == 'S' ) .or. ( cTipoRot == "6" .and. P_CCOMP13 == 'S' .And. lCalcFol )
		lTem132Per := fTem132Per() //Verifica se houve pagamento de 13º no ano
	EndIf

	cQuery := ""

	dbSelectArea( "RGB" )
	DbSetOrder(nRGBOrd)

	cAliasRGB := "QRGB"

	If ( Select( cAliasRGB ) > 0 )
		( cAliasRGB )->( dbCloseArea() )
	EndIf 

	If __oSt1 == Nil .or. ( __cEmpAux == Nil .or. __cEmpAux <> cEmpAnt ) .or. __cTpRotAnt <> cTipoRot .or. __cFilAux <> cFilAnt .or. __lComiss <> lComissBEN 
		
		__cEmpAux   := cEmpAnt
		__cFilAux   := cFilAnt
		__cTpRotAnt := cTipoRot
		__lComiss	:= lComissBEN 
		
		__oSt1 := FWPreparedStatement():New()
		
		cQuery := "SELECT "
		cQuery += "	RGB_FILIAL, RGB_MAT, RGB_PROCES, RGB_ROTEIR, "
		cQuery += "	RGB_PERIOD, RGB_PD, RGB_VALOR, RGB_HORAS, "
		cQuery += "	RGB_SEMANA, RGB_CC, RGB_TIPO1, RGB_PARCEL, "
		cQuery += "	RGB_SEQ, RGB_QTDSEM, RGB_DTREF,RGB_TIPO2,CAST(RGB_ROTORI AS VARCHAR("+Alltrim(Str(TamSX3("RGB_ROTORI")[1]))+")) AS RGB_ROTORI, ' ' AS TMP_DEL, RGB_DTREF AS TMP_PAG "
		If lContrInt
			cQuery += "	, RGB_CONVOC "
		EndIf
		If lNrBen
			cQuery += "	, RGB_NRBEN "
		EndIf
		If lItemClVl
			cQuery += "	,RGB_ITEM, RGB_CLVL "
		EndIf
		If lUsaPLS
			cQuery += "	,CAST(RGB_LOTPLS AS VARCHAR("+Alltrim(Str(TamSX3("RGB_LOTPLS")[1]))+")) AS RGB_LOTPLS "
			cQuery += " ,CAST(RGB_CODRDA AS VARCHAR("+Alltrim(Str(TamSX3("RGB_CODRDA")[1]))+")) AS RGB_CODRDA "
		EndIf
		cQuery += "	,RGB_IDCMPL, RGB_NUMID "
		cQuery += "FROM " + RetSqlName("RGB")+ " RGB "
		cQuery += "WHERE RGB.RGB_FILIAL = ? AND " //1 - cFil
		cQuery += "RGB.RGB_PROCES = ? AND " //2 - cProces
		cQuery += "RGB.RGB_PERIOD = ? AND " //3 - cPeriodo
		//Se for complementar carrega os lancamentos das semanas anteriores
		If !lCalcCompl	
			cQuery += "RGB.RGB_SEMANA = ? AND " //4 - cNumpag
		Else
			cQuery += "RGB.RGB_SEMANA <= ? AND " //4 - cNumPag
		EndIf
		
		cQuery += " *TIPOPESQ* "
		
		cQuery += "RGB.RGB_MAT = ? AND " //5 - cMatr
		cQuery += "RGB.D_E_L_E_T_=' ' "
		If lContrInt
			//Quando há rescisão de contrato intermitente, o campo RGB_CONVOC não é preenchido, pois não existe o camp de convocação na SRR.
			//Com a tratativa abaixo, caso for cálculo de folha após cálculo de rescisão, será gravada a convocação ativa da competência do cálculo.
			cQuery += "AND ( RGB.RGB_CONVOC = ? OR " //6 - cConvoc 
			cQuery += "RGB.RGB_ROTORI = '" + fGetCalcRot("4") + "' )"
		Else
		 	cQuery += "AND RGB.RGB_MAT = ? " //6 - cMatr (COMPATIBILIZAÇÃO DA QUERY)
		EndIf
		If lNrBen
			cQuery += "AND RGB.RGB_NRBEN = ? "
		EndIf
		
		If cTipoRot == '3' .And. (lDissidio .Or. IsInCallStack("fCDifFerias") .And. cPeriodo < cSvSetPer)
			cQuery += "UNION SELECT "
			cQuery += "	RR_FILIAL, RR_MAT, RR_PROCES, RR_ROTEIR, "
			cQuery += "	RR_PERIODO, RR_PD, RR_VALOR, RR_HORAS, "
			cQuery += "	RR_SEMANA, RR_CC, RR_TIPO1, 0, "
			cQuery += "	RR_SEQ,0,RR_DATA, RR_TIPO2,CAST('   ' AS VARCHAR("+Alltrim(Str(TamSX3("RGB_ROTORI")[1]))+")) AS RD_ROTORI, ' ' AS TMP_DEL, RR_DATAPAG AS TMP_PAG "
			If lContrInt
				cQuery += "	, '' AS RGB_CONVOC "
			EndIf
			If lNrBen
				cQuery += "	, '' AS RGB_NRBEN "
			EndIf	
			If lItemClVl
				cQuery += "	,RR_ITEM, RR_CLVL "
			EndIf
			
			If lUsaPLS
				cQuery += "	,CAST('          ' AS VARCHAR("+Alltrim(Str(TamSX3("RD_LOTPLS")[1]))+")) AS RD_LOTPLS "
				cQuery += " ,CAST('      ' AS VARCHAR("+Alltrim(Str(TamSX3("RD_CODRDA")[1]))+")) AS RD_CODRDA "
			EndIf
			
			cQuery += "	,RR_IDCMPL, RR_NUMID "
			cQuery += "FROM " + RetSqlName("SRR")+ " SRR "
			cQuery += "WHERE SRR.RR_FILIAL = ? AND " //7 - cFil
			cQuery += "SRR.RR_PROCES = ? AND " //8 - cProces
			cQuery += "SRR.RR_PERIODO = ? AND " //9 - cPeriodo	
			cQuery += "SRR.RR_SEMANA <= ? AND " //10 - cNumPag
			cQuery += "(SRR.RR_TIPO2='I' OR SRR.RR_TIPO2='G') AND "
			cQuery += "SRR.RR_ROTEIR = ? AND " //11 - cRoteiro
			cQuery += "SRR.RR_MAT = ? AND " //12 - cMatr
			cQuery += "SRR.D_E_L_E_T_=' ' "
		ElseIf !(P_CCOMP13 = 'S' .And. cRot == fGetCalcRot('6') .And. lCalcFol)
			cQuery += "UNION SELECT "
			cQuery += "	RD_FILIAL, RD_MAT, RD_PROCES, RD_ROTEIR, "
			cQuery += "	RD_PERIODO, RD_PD, RD_VALOR, RD_HORAS, "
			cQuery += "	RD_SEMANA, RD_CC, RD_TIPO1, 0, "
			cQuery += "	RD_SEQ, RD_QTDSEM, RD_DTREF, RD_TIPO2,CAST('   ' AS VARCHAR("+Alltrim(Str(TamSX3("RGB_ROTORI")[1]))+")) AS RD_ROTORI, ' ' AS TMP_DEL, RD_DATPGT AS TMP_PAG "
			If lContrInt
				cQuery += "	, RD_CONVOC "
			EndIf
			If lNrBen
				cQuery += "	, RD_NRBEN "
			EndIf

			If lItemClVl
				cQuery += "	,RD_ITEM, RD_CLVL "
			EndIf
			
			If lUsaPLS
				cQuery += "	,CAST(RD_LOTPLS AS VARCHAR("+Alltrim(Str(TamSX3("RD_LOTPLS")[1]))+")) AS RD_LOTPLS "
				cQuery += " ,CAST(RD_CODRDA AS VARCHAR("+Alltrim(Str(TamSX3("RD_CODRDA")[1]))+")) AS RD_CODRDA "
			EndIf
			
			cQuery += "	,RD_IDCMPL, RD_NUMID "
			cQuery += "FROM " + RetSqlName("SRD")+ " SRD "
			cQuery += "WHERE SRD.RD_FILIAL = ? AND " //7 - cFil
			cQuery += "SRD.RD_PROCES = ? AND " //8 - cProces
			cQuery += "SRD.RD_PERIODO = ? AND " //9 - cPeriodo	
			cQuery += "SRD.RD_SEMANA <= ? AND " //10 - cNumPag
			If lProvisao .Or. lGPER080
				cQuery += "(SRD.RD_TIPO2='I' OR SRD.RD_TIPO2='G') AND "
			EndIf
			If lComissBEN
				cQuery += "(SRD.RD_ROTEIR = ? OR " //11 - cRoteiro
				cQuery += "SRD.RD_ROTEIR = '" + fGetRotOrdinar() + "') AND "
			ElseIf cTipoRot == "N"//Retificadora
				cQuery += "SRD.RD_ROTEIR = ? AND " //11 - fGetRotOrdinar()
			Else
				cQuery += "SRD.RD_ROTEIR = ? AND " //11 - cRoteiro
			EndIf
			cQuery += "SRD.RD_MAT = ? AND " //12 - cMatr
			cQuery += "SRD.D_E_L_E_T_=' ' "
		ElseIf (P_CCOMP13 = 'S' .And. cRot == fGetCalcRot('6') .And. lCalcFol) // Utiliza as verbas do tipo Informadas
			cQuery += "UNION SELECT "
			cQuery += "	RD_FILIAL, RD_MAT, RD_PROCES, RD_ROTEIR, "
			cQuery += "	RD_PERIODO, RD_PD, RD_VALOR, RD_HORAS, "
			cQuery += "	RD_SEMANA, RD_CC, RD_TIPO1, 0, "
			cQuery += "	RD_SEQ, RD_QTDSEM, RD_DTREF, RD_TIPO2,CAST('   ' AS VARCHAR("+Alltrim(Str(TamSX3("RGB_ROTORI")[1]))+")) AS RD_ROTORI, ' ' AS TMP_DEL, RD_DATPGT AS TMP_PAG "
			If lContrInt
				cQuery += "	, RD_CONVOC "
			EndIf
			If lNrBen
				cQuery += "	, RD_NRBEN "
			EndIf

			If lItemClVl
				cQuery += "	,RD_ITEM, RD_CLVL "
			EndIf
			
			If lUsaPLS
				cQuery += "	,CAST(RD_LOTPLS AS VARCHAR("+Alltrim(Str(TamSX3("RD_LOTPLS")[1]))+")) AS RD_LOTPLS "
				cQuery += " ,CAST(RD_CODRDA AS VARCHAR("+Alltrim(Str(TamSX3("RD_CODRDA")[1]))+")) AS RD_CODRDA "
			EndIf
			
			cQuery += "	,RD_IDCMPL, RD_NUMID "
			cQuery += "FROM " + RetSqlName("SRD")+ " SRD "
			cQuery += "WHERE SRD.RD_FILIAL = ? AND " //7 - cFil
			cQuery += "SRD.RD_PROCES = ? AND " //8 - cProces
			cQuery += "SRD.RD_PERIODO = ? AND " //9 -  cPeriodo	
			cQuery += "SRD.RD_SEMANA <= ? AND " //10 - cNumPag
			cQuery += "(SRD.RD_TIPO2='I' OR SRD.RD_TIPO2='G' OR SRD.RD_PD IN ('" + aCodFol[19,1] + "','" + aCodFol[20,1] + "') ) AND "	
			If lComissBEN
				cQuery += "(SRD.RD_ROTEIR = ? OR " //11 - cRoteiro
				cQuery += "SRD.RD_ROTEIR = '" + fGetRotOrdinar() + "') AND "
			Else
				cQuery += "SRD.RD_ROTEIR = ? AND " //11 - cRoteiro
			EndIf
			cQuery += "SRD.RD_MAT = ? AND " //12 - cMatr
			cQuery += "SRD.D_E_L_E_T_=' ' "

		EndIf
		cQuery += "ORDER BY 1,3,5,9,4,2,6,13"

		cQuery := ChangeQuery(cQuery)
		
		__oSt1:SetQuery(cQuery)
		
	EndIf
	
	__oSt1:SetString(++nPosParam,cFil)//1
	__oSt1:SetString(++nPosParam,cProces)//2
	__oSt1:SetString(++nPosParam,cPeriodo)//3
	__oSt1:SetString(++nPosParam,cNumPag)//4

	__oSt1:SetString(++nPosParam,cMatr)//5
	
	If lContrInt
		__oSt1:SetString(++nPosParam,cConvoc)//6
	Else
		__oSt1:SetString(++nPosParam,cMatr)//6
	EndIf
	
	If lNrBen
		__oSt1:SetString(++nPosParam, cBenOp)//7
	EndIf

	If cTipoRot == '3' .And. (lDissidio .Or. IsInCallStack("fCDifFerias") .And. cPeriodo < cSvSetPer)
		__oSt1:SetString(++nPosParam,cFil)//8
		__oSt1:SetString(++nPosParam,cProces)//9
		__oSt1:SetString(++nPosParam,cPeriodo)//10
		__oSt1:SetString(++nPosParam,cNumPag)//11
		__oSt1:SetString(++nPosParam,cRoteiro)//12
		__oSt1:SetString(++nPosParam,cMatr)//13
	ElseIf !(P_CCOMP13 = 'S' .And. cRot == fGetCalcRot('6') .And. lCalcFol)
		__oSt1:SetString(++nPosParam,cFil)//8
		__oSt1:SetString(++nPosParam,cProces)//9
		__oSt1:SetString(++nPosParam,cPeriodo)//10
		__oSt1:SetString(++nPosParam,cNumPag)//11
		If cTipoRot == "N"//Retificadora
			__oSt1:SetString(++nPosParam,fGetRotOrdinar())//12
		Else
			__oSt1:SetString(++nPosParam,cRoteiro)//12
		EndIf
		__oSt1:SetString(++nPosParam,cMatr)//13
	ElseIf (P_CCOMP13 = 'S' .And. cRot == fGetCalcRot('6') .And. lCalcFol) // Utiliza as verbas do tipo Informadas
		__oSt1:SetString(++nPosParam,cFil)//8
		__oSt1:SetString(++nPosParam,cProces)//9
		__oSt1:SetString(++nPosParam,cPeriodo)//10
		__oSt1:SetString(++nPosParam,cNumPag)//11
		__oSt1:SetString(++nPosParam,cRoteiro)//12
		__oSt1:SetString(++nPosParam,cMatr)//13
	EndIf
	
	cQuery := __oSt1:getFixQuery()
	
	If lComissBEN
		cQryAux := "( RGB.RGB_ROTEIR = '" + cRoteiro + "' OR RGB.RGB_ROTEIR = '" + fGetCalcRot('1') + "' ) AND "
	Else
		If( cTipoRot == "1" .and. P_CCOMP13 == 'S' .And. lTem132Per) //Esta calculando a folha do mês 12, paga complemento, então não deve carregar as verbas de diferença de 13º lançadas na RGB
			cQryAux := "RGB.RGB_ROTEIR = '" + cRoteiro + "' AND RGB.RGB_PD NOT IN ('" + aCodFol[28,1] + "','" + aCodFol[348,1] + "') AND "
		ElseIf( cTipoRot == "6" .and. P_CCOMP13 == 'S' .And. lCalcFol .And. lTem132Per) //Esta calculando a complementar do 13º, carregar as verbas de diferença de 13º lançadas na folha
			cQryAux := "( RGB.RGB_ROTEIR = '" + cRoteiro + "' OR RGB.RGB_ROTEIR = '" + fGetCalcRot('1') + "' ) AND "
		Else
			cQryAux := "RGB.RGB_ROTEIR = '" + cRoteiro + "' AND "
		EndIf
	EndIf
	
	cQuery := Replace(cQuery,'*TIPOPESQ*',cQryAux )	

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasRGB)

	aStru2RGB 	:= QRGB->(dbStruct())

	Aeval( aStru2RGB, { |x| cCampos+=x[1] + "/" } )

	For nX := 1 To Len(aStruRGB)
		If ( aStruRGB[nX][1] $ cCampos .AND. aStruRGB[nX][2] <> "C" )
			TcSetField(cAliasRGB,aStruRGB[nX][1],aStruRGB[nX][2],aStruRGB[nX][3],aStruRGB[nX][4])
		EndIf
	Next nX
	
	dbSelectArea(cAliasRGB)
	
	While (cAliasRGB)->( !Eof() )
		cDel 	:= (cAliasRGB)->TMP_DEL
		dDtaPg 	:= If( SRA->RA_CATFUNC $ "A*P" .AND. SRA->RA_TIPOPGT == "S", If(empty(StoD((cAliasRGB)->TMP_PAG)),DDATA_PGTO,(StoD((cAliasRGB)->TMP_PAG))) , (cAliasRGB)->RGB_DTREF )
		lRes	:= If((cAliasRGB)->RGB_ROTORI == fGetCalcRot('4'),.T.,.F.)
		lFer	:= If((cAliasRGB)->RGB_ROTORI == fGetCalcRot('3'),.T.,.F.)
		
		cVbs := aCodFol[106,1]+'*'+aCodFol[107,1]+'*'+aCodFol[12,1]
		If lIrNeg
			cVbs += '*'+aCodFol[1727,1]
		EndIf
		
		If !(RGB_PD $ cVbs) .And. !lRes .And. !lFer .And. !(RGB_TIPO2 == 'F') .And. (!lDissidio .Or. !(RGB_TIPO2 == 'K')) .And. !( (SRA->RA_CATFUNC $ "A*H*T" .And. SRA->RA_TIPOPGT == "S") .Or. (SRA->RA_CATFUNC == "A" .And. SRA->RA_TIPOPGT == "S" .And. (cAliasRGB)->RGB_SEMANA == cSemana) )
			dDtaPg := dData_Pgto
		EndIf		
		
		If ( !lIncCompl .And. cTipoRot == "6" .and. P_CCOMP13 == 'S' .And. lCalcFol .And. !((cAliasRGB)->RGB_PD $ aCodFol[28,1] + "','" + aCodFol[348,1]);
		.And. !((cAliasRGB)->RGB_TIPO2 $ "I/G" .And. RetValSrv((cAliasRGB)->RGB_PD,(cAliasRGB)->RGB_FILIAL,"RV_REF13") == 'S') )
			(cAliasRGB)->( dbSkip() )
			Loop
		EndIf
		
		If lCalcCompl .And. !Empty(SRA->RA_DEMISSA) .And. AnoMes(SRA->RA_DEMISSA) <= cPeriodo .And.	(cAliasRGB)->RGB_SEMANA < cSemana
			(cAliasRGB)->( dbSkip() )
			Loop
		EndIf
	
		If lDissidio
			nVerbaApd := Ascan(APD, {|x| x[1] == (cAliasRGB)->RGB_PD .And. x[9] <> "D"})
			nVerbaInf := Ascan(aDissInf, {|x| x[6] == (cAliasRGB)->RGB_PD})
			If nVerbaApd > 0 .And. nVerbaInf > 0  //evito adicionar a verba novamente no APD no dissidio para evitar somar o valor origem + o recalculado
				(cAliasRGB)->( dbSkip() )
				Loop
			Endif
		EndIf

		dDtRefRgb	:= RGB_DTREF 	
		
		cSeq := (cAliasRGB)->RGB_SEQ
		If lCalcCompl
			cNPagAux := cNumPag
		Else
			cNPagAux := (cAliasRGB)->RGB_SEMANA
		EndIf
		//Aadd(aPd,{cCod,cCct,cSem,nHoras,Round(nValor,2),cTip1,cTip2,nPar,cDel,dMes,cSeq,nQtdSem,cItCt,cClCt,cNumID,lEmpres,cIdCmpl,dDtaRef,nValInteg,nBaseAux,AllTrim(STR(nOrdAux))}) 
		If ( nPos := Ascan(aPd,{ |X| X[1]+X[2]+X[3]+X[11]+x[22]+x[26] == (cAliasRGB)->(RGB_PD + RGB_CC) + cNPagAux + cSeq + cConvoc + cBenOp } ) ) > 0
			While .T.
				cSeq := Soma1(cSeq)
				If ( nPos := Ascan(aPd,{ |X| X[1]+X[2]+X[3]+X[11]+x[22]+x[26] == (cAliasRGB)->(RGB_PD + RGB_CC) + cNPagAux + cSeq + cConvoc + cBenOp } ) ) == 0
					Exit
				EndIf			
			EndDo
		EndIf
		
		If lContrInt .And. !Empty((cAliasRGB)->RGB_CONVOC)
			cConvoc := (cAliasRGB)->RGB_CONVOC
		Else
			cConvoc := cBkpConvoc
		EndIf

		If lNrBen .And. !Empty((cAliasRGB)->RGB_NRBEN)
			cBenOp := (cAliasRGB)->RGB_NRBEN
		Else
			cBenOp := cBkpBenOp
		EndIf
		
		If cTipoRot == "3" .And. Empty( RetValSrv( (cAliasRGB)->RGB_PD,(cAliasRGB)->RGB_FILIAL,"RV_CODFOL" ) )
			If RetValSrv( (cAliasRGB)->RGB_PD,(cAliasRGB)->RGB_FILIAL,"RV_REFFER" ) == "S"
				cVerbaMS := fBusMesSeg( (cAliasRGB)->RGB_PD )
			EndIf
			
			nRefMes := (cAliasRGB)->RGB_HORAS
			
			If !Empty(cVerbaMS)
				nValorMS   := ( (cAliasRGB)->RGB_VALOR / ( NDIASFM + NDIASABM + NDIASFMS + NDIASABMS ) ) * (NDIASFMS + NDIASABMS) //Valor proporcional a férias e abono mês seguinte
				nValorVerb := ( (cAliasRGB)->RGB_VALOR / ( NDIASFM + NDIASABM + NDIASFMS + NDIASABMS ) ) * (NDIASFM + NDIASABM) //Valor proporcional a férias e abono
				If nValorMS > 0
					nRefMes	   := NDIASFM + NDIASABM
					nRefMS	   := NDIASFMS + NDIASABMS
				EndIf
			Else
				nValorVerb := (cAliasRGB)->RGB_VALOR 
			EndIf
			
			If lItemClVl
				(cAliasRGB)->( FMatriz(RGB_PD,nValorVerb,nRefMes,cNPagAux,RGB_CC,RGB_TIPO1,RGB_TIPO2,RGB_PARCEL,cDel,dDtapg,,cSeq,RGB_QTDSEM,RGB_ITEM,RGB_CLVL,RGB_NUMID,,RGB_IDCMPL, dDtRefRgb,,,,cConvoc,,If(lUsaPLS,RGB_LOTPLS,""),If(lUsaPLS,RGB_CODRDA,"") ) )
				If nValorMS > 0
					(cAliasRGB)->( FMatriz(cVerbaMS,nValorMS,nRefMS,cNPagAux,RGB_CC,RGB_TIPO1,RGB_TIPO2,RGB_PARCEL,cDel,dDtapg,,cSeq,RGB_QTDSEM,RGB_ITEM,RGB_CLVL,RGB_NUMID,,RGB_IDCMPL, dDtRefRgb,,,,cConvoc,,If(lUsaPLS,RGB_LOTPLS,""),If(lUsaPLS,RGB_CODRDA,"") ) )
				EndIf
			Else
				(cAliasRGB)->( FMatriz(RGB_PD,nValorVerb,nRefMes,cNPagAux,RGB_CC,RGB_TIPO1,RGB_TIPO2,RGB_PARCEL,cDel,dDtapg,,cSeq,RGB_QTDSEM,,,RGB_NUMID,,RGB_IDCMPL, dDtRefRgb,,,,cConvoc,,If(lUsaPLS,RGB_LOTPLS,""),If(lUsaPLS,RGB_CODRDA,"")) )
				If nValorMS > 0
					(cAliasRGB)->( FMatriz(cVerbaMS,nValorMS,nRefMS,cNPagAux,RGB_CC,RGB_TIPO1,RGB_TIPO2,RGB_PARCEL,cDel,dDtapg,,cSeq,RGB_QTDSEM,,,RGB_NUMID,,RGB_IDCMPL, dDtRefRgb,,,,cConvoc,,If(lUsaPLS,RGB_LOTPLS,""),If(lUsaPLS,RGB_CODRDA,"")) )
				EndIf
			EndIf
		Else
			If lItemClVl
				(cAliasRGB)->( FMatriz(RGB_PD,RGB_VALOR,RGB_HORAS,cNPagAux,RGB_CC,RGB_TIPO1,RGB_TIPO2,RGB_PARCEL,cDel,dDtapg,,cSeq,RGB_QTDSEM,RGB_ITEM,RGB_CLVL,RGB_NUMID,,RGB_IDCMPL, dDtRefRgb,,,,cConvoc,,If(lUsaPLS,RGB_LOTPLS,""),If(lUsaPLS,RGB_CODRDA,""), Nil, cBenOp ) )
			Else
				(cAliasRGB)->( FMatriz(RGB_PD,RGB_VALOR,RGB_HORAS,cNPagAux,RGB_CC,RGB_TIPO1,RGB_TIPO2,RGB_PARCEL,cDel,dDtapg,,cSeq,RGB_QTDSEM,,,RGB_NUMID,,RGB_IDCMPL, dDtRefRgb,,,,cConvoc,,If(lUsaPLS,RGB_LOTPLS,""),If(lUsaPLS,RGB_CODRDA,""), Nil, cBenOp ) )
			EndIf
		EndIf
		
		//Se não for dissídio, se for roteiro da folha e a verba veio do roteiro FER
		If Len(aPd) > 0 .And. !lDissidio .And. cRoteiro == fGetCalcRot("1") .And. (lFer .Or. ((cAliasRGB)->RGB_TIPO2 == "F" .And. RetValSrv( (cAliasRGB)->RGB_PD,(cAliasRGB)->RGB_FILIAL,"RV_REFFER" ) == "S") )
			aAdd( aVbAuxFer, aClone( aPd[Len(aPd)] ) )
		EndIf
		dbSelectArea(cAliasRGB)
		dbSkip()
	EndDo

	RestArea( aAreaSRH )

	//Gera verbas de contrapartida do eSocial Id 1562/1722/1723/1893
	If cPaisLoc == "BRA" .And. cTipoRot == "1" .And. !Empty(aVbAuxFer)
		lOkVb1893 := fGerBasFer( aVbAuxFer )		
	EndIf

	dbSelectArea(cAliasRGB)
	dbCloseArea()

	If lOkVb1893
		If( lIncCompl .And. cTipoRot == "6" .and. P_CCOMP13 == 'S' .And. lCalcFol)
			aEval(  apd, { |x| If( !(x[1] $ aCodFol[28,1] + "','" + aCodFol[348,1]) .And. !(x[7] $ "I/G" .And. RetValSrv(x[1],SRA->RA_FILIAL,"RV_REF13") == 'S'), x[9] := "D", Nil  ) } )
		EndIf 

		If cTipoRot == "5" 
			cAliasAux	:= GetNextAlias()
			cAno := SubStr(cPeriodo,1,4)
			cWhere   := "SRD.RD_FILIAL = '"+cFil+"' AND SRD.RD_MAT = '"+cMatr+"' AND "+;
						"(SRD.RD_PD = '"+aCodFol[22,1]+"' OR SRD.RD_PD = '"+aCodFol[24,1]+"' OR "+;
						"SRD.RD_PD = '"+aCodFol[163,1]+"' ) AND "+;
						"SRD.RD_PERIODO >= '"+cAno+"01' AND SRD.RD_PERIODO <= '"+cAno+"12'"
			cWhere   := "%"+cWhere+"%"
			
			BeginSql alias cAliasAux
				SELECT RD_VALOR 
				FROM %table:SRD% SRD 
				WHERE %exp:cWhere% AND SRD.%notDel% 
			EndSql
			nAntec13 := 0 //Zera mnemonico de 13º pago
			NANT13SAL := 0 //Zera mnemonico de 13º pago
			While !(cAliasAux)->(Eof())
				nAntec13 += (cAliasAux)->(RD_VALOR) 
				NANT13SAL += (cAliasAux)->(RD_VALOR)
				(cAliasAux)->(dbskip())
			Enddo
			(cAliasAux)->(dbCloseArea())

			//Busca verbas da primeira parcela pagas no movimento
			dbSelectArea("SRC")
			dbSetOrder(1)
			If dbSeek(cFil+cMatr)
				While !Eof() .And. SRC->RC_FILIAL+SRC->RC_MAT == cFil+cMatr
					If SRC->RC_PD $ ( aCodFol[022,1] + "/" + aCodFol[024,1] + "/" + aCodFol[163,1] )
						nAntec13 += SRC->RC_VALOR
						NANT13SAL += SRC->RC_VALOR
					EndIf
					dbSkip()
				End While
			EndIf
		EndIf

		If cTipoRot == "5" .and. Empty(nAntec13)
			//Busca pagamento de 13º na RGB
			dbSelectArea("RGB")
			dbSetOrder(6) //RGB_FILIAL+RGB_MAT+RGB_PERIOD+RGB_ROTEIR+RGB_SEMANA+RGB_PD
			If dbSeek(cFil+cMatr+cPeriodo) 
				While !Eof() .And. RGB->RGB_FILIAL+RGB->RGB_MAT+RGB->RGB_PERIOD == cFil+cMatr+cPeriodo
					If RGB->RGB_PD $ ( aCodFol[022,1] + "/" + aCodFol[024,1] + "/" + aCodFol[163,1] ) .AND.  RGB_ROTEIR $ fGetCalcRot("1")+"/"+fGetCalcRot("9") 
						nAntec13 += RGB->RGB_VALOR
						NANT13SAL += RGB->RGB_VALOR
					EndIf
					dbSkip()
				End While
			EndIf
		EndIf

		//Se funcionário esta demitido e esta calculando a folha devido a rescisão complementar, apenas grava o conteúdo carregado no aPD e finaliza calculo do funcionário
		If (Type("lSalInco")=="U" .Or. !lSalInco) .And. (!Empty(aPd) .Or. lCalcCompl) .And. (cRoteiro $ fGetRotOrdinar()+"/"+fGetCalcRot('9')) .And. !Empty(SRA->RA_DEMISSA) .And. AnoMes(SRA->RA_DEMISSA) <= cPeriodo //"FOL"
			//Verifica se existe registro de rescisão na RGB
			cAliasAux	:= GetNextAlias()
			cWhere   := "RGB.RGB_FILIAL = '"+cFil+"' AND RGB.RGB_MAT = '"+cMatr+"' AND "+;
						"RGB.RGB_PERIOD = '"+cPeriodo+"' AND RGB.RGB_PROCES = '" + cProces + "' AND "+;
						"RGB.RGB_ROTORI = '" + fGetCalcRot("4") + "'"
			cWhere   := "%"+cWhere+"%"
			
			BeginSql alias cAliasAux
				SELECT COUNT(*) TOTALREG
				FROM %table:RGB% RGB
					WHERE 		%exp:cWhere% AND
					RGB.%notDel%   
			EndSql
		
			nTot := (cAliasAux)->TOTALREG

			(cAliasAux)->(dbCloseArea())
		
			If nTot > 0 //Existe registro de rescisão complementar na RGB, apenas grava e pula para o próximo funcionário
				GRAVACALC()
				NOPRCREG()
			EndIf
			
		EndIf  

		// Busca verbas lancadas em Folha que incorporam Salario 
		// Alterando valor do Salario Hora e afetando Medias pagas no 132
		If lDissidio .And. cTipoRot == "6" .and. !lCalcFol 
			//Busca pagamento de 13º na RGB
			dbSelectArea("SRD")
			dbSetOrder(5) //RD_FILIAL+RD_MAT+RD_PROCES+RD_ROTEIR+RD_PERIODO+RD_SEMANA
			If dbSeek(cFil+cMatr+cProcesso+fGetCalcRot("1")+cPeriodo+cSemana) 
				While !Eof() .And. SRD->(RD_FILIAL+RD_MAT+RD_PROCES+RD_ROTEIR+RD_PERIODO+RD_SEMANA) == cFil+cMatr+cProcesso+fGetCalcRot("1")+cPeriodo+cSemana
					If 	 SRD->RD_TIPO2 $ "I" .And. ;
						RetValSRV( SRD->RD_PD, cFil, "RV_INCORP" ) == "S" 
						If RetValSRV( SRD->RD_PD, cFil, "RV_CODFOL" ) $ "0001/0002/0003/0004/0005";
						.And. SRD->(RD_ROTEIR) = "FOL" .And. SubStr(SRA->RA_ADTPOSE,4,1) == "N" //Verifico se o funcionário não possui cadastro de ATS e a mesma foi lançada manualmente no roteito 132, em caso de dissidio não adiciono no APD do 132 para evitar duplicidade
								dbSkip()
								Loop
						Endif 
						If lItemClVl
							SRD->( fMatriz(RD_PD,RD_VALOR,RD_HORAS,RD_SEMANA,RD_CC,RD_TIPO1,RD_TIPO2,,,,,RD_SEQ,RD_QTDSEM,RD_ITEM,RD_CLVL,,,RD_IDCMPL,,,,,RD_CONVOC,,If(lUsaPLS,RD_LOTPLS,""),If(lUsaPLS,RD_CODRDA,"") ) )
						Else
							SRD->( fMatriz(RD_PD,RD_VALOR,RD_HORAS,RD_SEMANA,RD_CC,RD_TIPO1,RD_TIPO2,,,,,RD_SEQ,RD_QTDSEM,,,,,RD_IDCMPL,,,,,RD_CONVOC,,If(lUsaPLS,RD_LOTPLS,""),If(lUsaPLS,RD_CODRDA,"") ) )						
						EndIf
					EndIf
					dbSkip()
				End While
			EndIf
		EndIf

		If lConsig .And. cTipoRot == "3" .And. !(lDissidio .Or. IsInCallStack("fCDifFerias"))
			fCarrTab( @aTabS137, "S137", Nil, .T. )
			If !Empty(aTabS137)
				nPos := aScan( aTabS137, { |x| x[2] == cFil } )
				If nPos == 0
					nPos := aScan( aTabS137, { |x| x[2] == Space(FwGetTamFilial) } )
				EndIf
				If nPos > 0
					cEmpCons 	:= aTabS137[nPos, 05]
					cPdFerMes 	:= aTabS137[nPos, 08]
					cPdFerMSeg 	:= aTabS137[nPos, 09]
					cPdFolMes 	:= aTabS137[nPos, 10]
					cPdFolMSeg 	:= aTabS137[nPos, 11]
					If !Empty(cEmpCons) .And. !Empty(cPdFerMes) .And. !Empty(cPdFolMes)
						RGB->( dbSetOrder(1) )
						If RGB->( dbSeek( cFil+cMatr ) )
							While RGB->( !EoF() ) .And. RGB->RGB_FILIAL+RGB->RGB_MAT == cFil+cMatr
								If RGB->RGB_PROCES == cProces .And. RGB->RGB_PERIOD == cPeriodo .And. RGB->RGB_SEMANA == cNumPag .And. RGB->RGB_PD == cEmpCons
									nValEmpCons += RGB->RGB_VALOR
								EndIf
								RGB->( dbSkip() )
							End
						EndIf
					EndIf
					If nValEmpCons > 0
						IF SRA->RA_CATFUNC $ "H*G"				
							If GetMvRH("MV_DIASPER",,"1") == "1"				
								nDPAdc1 := nDPAdc2 := nDiasPerF1
							Else
								nDPAdc1 := nDPAdc2 := 30
							EndIf
						Else
							nDPAdc1 := nDiasPerF1				
							nDPAdc2 := nDiasPerF2				
						EndIf
						If Empty(cPdFerMSeg)
							fMatriz(cPdFerMes, nValEmpCons / nDPAdc1 * (nDiasFM+nDiasAbM+nDiasFMS+nDiasAbMS) )
						ElseIf !Empty(cPdFolMSeg)
							fMatriz(cPdFerMes, nValEmpCons / nDPAdc1 * (nDiasFM+nDiasAbM) )
							fMatriz(cPdFerMSeg, nValEmpCons / nDPAdc2 * (nDiasFMS+nDiasAbMS) )					
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	Else
		If dDatabase <= cToD("15/08/2022")
			AddLogExecRot(STR0130)//"A partir de 15/08/2022 o identificador 1893 se tornará obrigatório e o sistema não permitirá o calculo de férias sem o cadastro da verba vinculada ao ID"
		Else		
			AddLogExecRot(STR0132)//"É obrigatório possuir verba vinculada ao ID 1893 devido exigência do eSocial"
			NoPrcReg()
		EndIf
		AddLogExecRot(STR0131 + "https://tdn.totvs.com/x/uk0wJg")//"Para mais informações consulte:"
	EndIf
EndIf

If lTemMultV .and. !( SRA->RA_CATFUNC $ "A*P" .and. Empty(SRA->RA_SALARIO) .and. Empty(aPd) ) //Se for autonomo sem salário e sem verbas lançadas, não carrega bases de múltiplos vínculos
	fLoadMultv(.T.)
EndIf

RestArea(aArea)		

Return(aPd)

/*/{Protheus.doc} fLoadMultv
Verifica se funcionários possuir outros vínculos e gera as verbas dos outros vínculos
@author Leandro Drumond
@since 15/04/2020
@version 1.0
/*/
Function fLoadMultv(lCarrPd)
Local aArea		:= GetArea()
Local aAreaSRA  := SRA->(GetArea())
Local aAreaRHH  := RHH->(GetArea())
Local aFilMat	:= {}
Local cFilMat   := SRA->RA_FILIAL + SRA->RA_MAT
Local cFilMatIn := ""
Local cAliasAux := ""
Local cAliasAux2:= ""
Local cFilMatSRC:= ""
Local cFilMatSRD:= ""
Local cFilMatSRR:= ""
Local cFilMatOri:= ""
Local cPdAuxSRC	:= ""
Local cPdAuxSRD	:= ""
Local cPdAuxSRR	:= ""
Local cPdAux1	:= ""
Local cPdAux2	:= ""
Local cFilMatAux:= ""
Local cCpoSRD	:= ""
Local cRotADI	:= fGetCalcRot('2')
Local cRotAut	:= fGetCalcRot("9")
Local cRotRes	:= fGetCalcRot("4")
Local cRotRes13	:= fGetCalcRot("4") + "/" + fGetCalcRot("5") + "/" + fGetCalcRot("6")
Local cRotAtu   := If(cTipoRot $ "1*9", fGetCalcRot("1") + "/" + fGetCalcRot("9"), fGetCalcRot(cTipoRot))
Local cAuxSeqMv	:= "0"
Local cAnoMes	:= AnoMes(dData_Pgto)
Local cCpf		:= SRA->RA_CIC
Local cCnpjAtu	:= ""
Local cTipo     := If(lDissidio, "I", "C")
Local cFiltroAnt:= SRA->(DbFilter())
Local lCompl13	:= (cTipoRot == "6" .And. lCalcFol)
Local lMultv	:= .F.
Local lMultEmp  := .F.
Local nContSRA	:= 0
Local nX  		:= 0
Local nPos		:= 0
Local nBsInssOut:= 0
Local nInssOut	:= 0
Local nBsIROut  := 0
Local nIrOut	:= 0
Local nBsAut	:= 0
Local nBsInss13 := 0
Local nInss13	:= 0
Local nBsIr13   := 0
Local nIr13   	:= 0
Local nBsIrFOut := 0
Local nIrFOut   := 0
Local bFiltSra
Local nBsInssMs := 0
Local nInssMsOut := 0

DEFAULT lCarrPd := .F.

nInssAOut := 0

If Empty(cCpf)
	Return .F.
EndIf

If cTipoRot == "K" .and. !Empty(SRA->RA_DEMISSA) //Se estiver calculando o roteiro VEX e vínculo esta demitido, não prossegue.
	Return .F.
EndIf

If !lCarrPd .Or. P_TPAPUIR == "2"
	If (nPos := Ascan(aEstb,{|x| AllTrim(x[1]) == AllTrim(SRA->RA_FILIAL)})) > 0
		cCnpjAtu := aEstb[nPos][2]
	EndIf
EndIf

Static nOrderMULTV := RetOrder("SRA","RA_CIC+RA_FILIAL+RA_MAT")

DbSelectArea("SRA")
DbSetOrder(nOrderMULTV)

If cTipoRot $ "3*4"
	SRA->(DbSetFilter({||.T.}, ".T."))
EndIf

SRA->(DbSeek(SRA->RA_CIC))

While SRA->(!Eof() .and. SRA->RA_CIC == cCpf)
	If SRA->RA_FILIAL + SRA->RA_MAT <> cFilMat .and. !(SRA->RA_RESCRAI $ "30/31")
		lMultv 	:= .T.
		nContSRA++
		If lCarrPd
			aAdd(aFilMat, {SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_PROCES, SRA->RA_TIPOPGT})
		ElseIf !lMultEmp
			If (nPos := Ascan(aEstb,{|x| AllTrim(x[1]) == AllTrim(SRA->RA_FILIAL)})) > 0
				If SubStr(cCnpjAtu,1,8) <> SubStr(aEstb[nPos][2],1,8)
					lMultEmp := .T.
				EndIf
			EndIf
		EndIf
	EndIf 
	SRA->(DbSkip())
EndDo

RestArea(aAreaSRA)

If cTipoRot $ "3*4"
	If !Empty(cFiltroAnt)
		bFiltSra := &('{ || ' + cFiltroAnt + ' } ')
		SRA->(DbSetFilter(bFiltSra, cFiltroAnt))
	EndIf
EndIf

If lDissidio .And. SRA->RA_SITFOLH == "D" .And. SRA->RA_RESCRAI $ "30/31" .And. AnoMes(SRA->RA_DEMISSA) >= cPeriodo .And. nContSRA == 1
	lMultv := .F.
EndIf

If !lCarrPd
	lGrvRAZRAW  := lMultEmp
EndIf

RHH->( dbSetOrder(1) )//RHH_FILIAL+RHH_MAT+RHH_MESANO+RHH_DATA+RHH_VB+RHH_CC+RHH_ITEM+RHH_CLVL+RHH_SEMANA+RHH_SEQ+RHH_ROTEIR

If lMultV .and. lCarrPd

	For nX := 1 to Len(aFilMat)
		cFilMatIn += If(Empty(cFilMatIn), "" , ",") + "'" + aFilMat[nX,1] + aFilMat[nX,2] + "'"
		If nX == 1
			cFilMatSRC := "%("
			cFilMatSRD := "%("
			cFilMatSRR := "%("
		Else
			cFilMatSRC += " OR "
			cFilMatSRD += " OR "
			cFilMatSRR += " OR "
		EndIf
		cFilMatSRC += "(SRC.RC_FILIAL = '" + aFilMat[nX,1] + "' AND SRC.RC_MAT = '" + aFilMat[nX,2] + "')"
		cFilMatSRD += "(SRD.RD_FILIAL = '" + aFilMat[nX,1] + "' AND SRD.RD_MAT = '" + aFilMat[nX,2] + "')"
		cFilMatSRR += "(SRR.RR_FILIAL = '" + aFilMat[nX,1] + "' AND SRR.RR_MAT = '" + aFilMat[nX,2] + "')"
		If nX == Len(aFilMat)
			cFilMatSRC += ")%"
			cFilMatSRD += ")%"
			cFilMatSRR += ")%"
		EndIf
	Next nX

	cFilMatOri := "%SRR.RR_FILIAL = '" + SRA->RA_FILIAL + "' AND SRR.RR_MAT = '" + SRA->RA_MAT + "'%"

	If !Empty(aFilMat)
		cAliasAux   := GetNextAlias()
		cAliasAux2  := GetNextAlias()
		cPdAux1		:= aCodFol[9,1] + aCodFol[10,1] + aCodFol[13,1] + aCodFol[14,1] + aCodFol[15,1] + aCodFol[16,1] + aCodFol[19,1] + aCodFol[20,1] + aCodFol[27,1] + aCodFol[64,1] + aCodFol[65,1] + aCodFol[66,1] + aCodFol[67,1] + aCodFol[70,1] + aCodFol[71,1] + aCodFol[106,1] + aCodFol[221,1] + aCodFol[288,1] + aCodFol[289,1] + aCodFol[992,1] + aCodFol[993,1] + aCodFol[1384,1]
		cPdAuxSRC  	:= "% SRC.RC_PD IN ( " + fSqlIN( cPdAux1, 3 ) + " ) %"
		cPdAuxSRD  	:= "% SRD.RD_PD IN ( " + fSqlIN( cPdAux1, 3 ) + " ) %"
		If cPdFerMS == Nil .Or. cPdUltFil != SRA->RA_FILIAL
			cPdFerMS 	:= fCarPdFMS()
			cPdUltFil 	:= SRA->RA_FILIAL
		EndIf
		cPdAux2		:= cPdAux1 + aCodFol[232,1] + StrTran( cPdFerMS, "/" )
		cPdAuxSRR  	:= "% SRR.RR_PD IN ( " + fSqlIN( cPdAux2, 3 ) + ") %"
		If lDissidio .Or. lCompl13
			cCpoSRD		:= "% RD_FILIAL, RD_MAT, RD_ROTEIR AS ROTEIRO, RD_PD, RD_CC, RD_DATPGT, RD_VALOR, RD_PERIODO, 'SRD' AS TAB, RD_SEQMV, RD_TIPO2 %"
		Else
			cCpoSRD		:= "% RD_FILIAL, RD_MAT, RD_ROTEIR AS ROTEIRO, RD_PD, RD_CC, RD_DATPGT, RD_VALOR, RD_PERIODO, 'SRD' AS TAB, '0' AS RC_SEQMV, RD_TIPO2 %"
		EndIf	
		cDataIni 	:= cAnoMes+"01"
		cDataFim  	:= cAnoMes + StrZero(F_ULTDIA(StoD(cAnoMes+"01")),2)

		BeginSql alias cAliasAux
			COLUMN RC_DATA AS DATE
			COLUMN RD_DATPGT AS DATE
			COLUMN RR_DATAPAG AS DATE
			SELECT RC_FILIAL, RC_MAT, RC_ROTEIR AS ROTEIRO, RC_PD, RC_CC, RC_DATA, RC_VALOR, RC_PERIODO, "SRC" AS TAB, RC_SEQMV, RC_TIPO2
			FROM %table:SRC% SRC
			WHERE %exp:cFilMatSRC% AND
			%exp:cPdAuxSRC% AND
			( SRC.RC_DATA BETWEEN %exp:cDataIni% AND %exp:cDataFim% OR SRC.RC_PERIODO = %exp:cPeriodo% ) AND
			SRC.%notDel%
			UNION ALL 
			SELECT %exp:cCpoSRD%
			FROM %table:SRD% SRD
			WHERE %exp:cFilMatSRD% AND
			%exp:cPdAuxSRD% AND
			( SRD.RD_DATPGT BETWEEN %exp:cDataIni% AND %exp:cDataFim% OR SRD.RD_PERIODO = %exp:cPeriodo% ) AND
			SRD.%notDel%
			UNION ALL 
			SELECT RR_FILIAL, RR_MAT, RR_ROTEIR AS ROTEIRO, RR_PD, RR_CC, RR_DATAPAG, RR_VALOR, RR_PERIODO, "SRR" AS TAB, RR_SEQMV, RR_TIPO2
			FROM %table:SRR% SRR
			WHERE %exp:cFilMatSRR% AND
			%exp:cPdAuxSRR% AND
			( SRR.RR_DATAPAG BETWEEN %exp:cDataIni% AND %exp:cDataFim% OR SRR.RR_PERIODO = %exp:cPeriodo% ) AND
			SRR.%notDel%
			ORDER BY TAB, ROTEIRO
		EndSql
		//Ordenado pela tabela para que férias e rescisão fiquem por último, de modo a possibilitar a verificação se já foram calculados na folha.
		While !(cAliasAux)->(Eof())
			If !(cTipoRot == "6" .and. (cAliasAux)->ROTEIRO <> cRotAtu ) .and. ( ( (cAliasAux)->TAB == "SRD" .And. !lDissidio .And. !lCompl13 ) .or. ( Empty(cSEQMV) .And. ( !Empty((cAliasAux)->RC_SEQMV) .Or. ((cAliasAux)->TAB == "SRR" .And. SRA->RA_SITFOLH != "D") ) ) .or. ( !Empty(CSEQMV)  .and. CSEQMV > (cAliasAux)->RC_SEQMV ) .Or. (lDissidio .And. (cAliasAux)->RC_PERIODO == cPeriodo .And. (cAliasAux)->RC_PD $ (aCodFol[19,1]+"/"+aCodFol[20,1]+"/"+aCodFol[13,1]+"/"+aCodFol[14,1]+"/"+aCodFol[221,1]+"/"+aCodFol[1384,1]+"/"+aCodFol[64,1]+"/"+aCodFol[65,1]+"/"+ aCodFol[70,1]) ) )
				If ( (cAliasAux)->ROTEIRO $ cRotRes13 .or. ( cTipoRot == "1" .and. (cAliasAux)->ROTEIRO $ cRotAtu ) ) .and. (cAliasAux)->RC_PD $ aCodFol[19,1] + "/" + aCodFol[20,1] + "/" + aCodFol[27,1] + "/" + aCodFol[70,1] + "/" + aCodFol[71,1]
					If (cAliasAux)->RC_PD $ aCodFol[19,1] + "/" + aCodFol[20,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo
						If lDissidio .And. (cAliasAux)->RC_SEQMV > CSEQMV
							nBasAuxD1 += (cAliasAux)->RC_VALOR
						Else
							nBsInss13 += (cAliasAux)->RC_VALOR
							If lDissidio .And. RHH->( dbSeek( (cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + cMesAnoCalc + (cAliasAux)->RC_PERIODO + (cAliasAux)->RC_PD + (cAliasAux)->RC_CC ) )
								nBsInss13 -= (cAliasAux)->RC_VALOR
								nBsInss13 += RHH->RHH_CALC
							EndIf
						EndIf
					ElseIf (cAliasAux)->RC_PD == aCodFol[70,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo
						nInss13 += (cAliasAux)->RC_VALOR
						If lDissidio .And. RHH->( dbSeek( (cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + cMesAnoCalc + (cAliasAux)->RC_PERIODO + (cAliasAux)->RC_PD + (cAliasAux)->RC_CC ) )
							nInss13 -= (cAliasAux)->RC_VALOR
							nInss13 += RHH->RHH_CALC
						EndIf
					ElseIf (cAliasAux)->RC_PD == aCodFol[27,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo
						If P_TPAPUIR == "2"
							If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
								If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
									nBsIr13 += (cAliasAux)->RC_VALOR
								EndIf
							EndIf
						ElseIf P_TPAPUIR == "1"
							nBsIr13 += (cAliasAux)->RC_VALOR
						EndIf
					ElseIf (cAliasAux)->RC_PD == aCodFol[71,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo
						If P_TPAPUIR == "2"
							If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
								If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
									nIr13 += (cAliasAux)->RC_VALOR
								EndIf
							EndIf
						ElseIf P_TPAPUIR == "1"
							nIr13 += (cAliasAux)->RC_VALOR
						EndIf
					EndIf
				ElseIf (cAliasAux)->TAB == "SRR"
					If Empty(cSEQMV)
						BeginSql alias cAliasAux2
							COLUMN RR_DATAPAG AS DATE
							SELECT RR_FILIAL, RR_MAT, RR_ROTEIR AS ROTEIRO, RR_PD, RR_CC, RR_DATAPAG, RR_VALOR, RR_PERIODO, "SRR" AS TAB, RR_SEQMV
							FROM %table:SRR% SRR
							WHERE %exp:cFilMatOri% AND
							%exp:cPdAuxSRR% AND
							( SRR.RR_DATAPAG BETWEEN %exp:cDataIni% AND %exp:cDataFim% OR SRR.RR_PERIODO = %exp:cPeriodo% ) AND
							SRR.%notDel%
							ORDER BY TAB, ROTEIRO
						EndSql
						If !(cAliasAux2)->(Eof())
							cSEQMV := (cAliasAux2)->RR_SEQMV
							If !Empty(CSEQMV) .And. (cAliasAux)->RC_SEQMV > CSEQMV
								(cAliasAux)->(dbSkip())
								Loop
							EndIf
						EndIf
						(cAliasAux2)->(dbCloseArea())
					EndIf

					//Apenas soma as verbas de férias/rescisão se elas não tiverem sido calculadas na folha.
					If !((cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + (cAliasAux)->RC_PERIODO $ cFilMatAux ) .And. ( CSEQMV > (cAliasAux)->RC_SEQMV .or. cTipoRot == "3" .or. (cAliasAux)->ROTEIRO == cRotRes )
						If (cAliasAux)->RC_PD $ aCodFol[13,1] + "/" + aCodFol[14,1] + "/" + aCodFol[221,1] + "/" + aCodFol[1384,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo
							If lDissidio .And. (cAliasAux)->RC_SEQMV > CSEQMV
								nBasAuxD += (cAliasAux)->RC_VALOR
							Else
								nBsInssOut += (cAliasAux)->RC_VALOR
								If (cAliasAux)->ROTEIRO == cRotAut //Se for autonomo, deve incluir a verba 1847
									nBsAut += (cAliasAux)->RC_VALOR
								EndIf
							EndIf
						ElseIf 	(cAliasAux)->RC_PD $ aCodFol[64,1] + "/" + aCodFol[65,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo
							nInssOut += (cAliasAux)->RC_VALOR
							If (cAliasAux)->ROTEIRO == cRotAut //Se for autonomo, deve incluir a verba no mnemonico nInssAOut
								nInssAOut += (cAliasAux)->RC_VALOR
							EndIf
						ElseIf (cAliasAux)->RC_PD $ aCodFol[15,1] + "/" +  aCodFol[16,1] + "/" + aCodFol[10,1] + "/" + aCodFol[106,1]  .and. (cAliasAux)->RC_PERIODO == cPeriodo
							If (cAliasAux)->RC_PD == aCodFol[106,1]
								If (cAliasAux)->ROTEIRO == cRotADI
									If P_TPAPUIR == "2"
										If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
											If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
												nBsIrOut -= (cAliasAux)->RC_VALOR
											EndIf
										EndIf
									ElseIf P_TPAPUIR == "1"
										nBsIrOut -= (cAliasAux)->RC_VALOR
									EndIf
								EndIf
							Else
								If (cAliasAux)->RC_PD == aCodFol[16,1] .and. (cAliasAux)->ROTEIRO == cRotRes
									If P_TPAPUIR == "2"
										If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
											If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
												nBsIrFOut += (cAliasAux)->RC_VALOR
											EndIf
										EndIf
									ElseIf P_TPAPUIR == "1"
										nBsIrFOut += (cAliasAux)->RC_VALOR
									EndIf
								Else
									If P_TPAPUIR == "2"
										If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
											If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
												nBsIrOut += (cAliasAux)->RC_VALOR
											EndIf
										EndIf
									ElseIf P_TPAPUIR == "1"
										nBsIrOut += (cAliasAux)->RC_VALOR
									EndIf
								EndIf
							EndIf						
						ElseIf (cAliasAux)->RC_PD  $ aCodFol[66,1] + "/" + aCodFol[67,1] + "/" + aCodFol[9,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo
							If (cAliasAux)->RC_PD == aCodFol[67,1] .and. (cAliasAux)->ROTEIRO == cRotRes
								If P_TPAPUIR == "2"
									If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
										If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
											nIrFOut += (cAliasAux)->RC_VALOR
										EndIf
									EndIf
								ElseIf P_TPAPUIR == "1"
									nIrFOut += (cAliasAux)->RC_VALOR
								EndIf								
							Else 
								If P_TPAPUIR == "2"
									If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
										If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
											nIrOut += (cAliasAux)->RC_VALOR
										EndIf
									EndIf
								ElseIf P_TPAPUIR == "1"
									nIrOut += (cAliasAux)->RC_VALOR
								EndIf								
							EndIf
						ElseIf (cAliasAux)->RC_PD $ cPdFerMS .And. (cAliasAux)->RC_PERIODO == cPeriodo
										
							nBsInssMs += (cAliasAux)->RC_VALOR

                        ElseIf (cAliasAux)->RC_PD $ aCodFol[232,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo
                            
							nInssMsOut += (cAliasAux)->RC_VALOR
							
                        EndIf
					EndIf
				Else
					//--INICIO Verbas de outras empresas lançadas--
					//Se foi lançado verbas de outras empresas (Fora do Protheus) em outro vínculo, carrega as verbas caso já não tenham sido lançadas no vínculo atual também
					If (cAliasAux)->RC_PD == aCodFol[288,1] .and. (cAliasAux)->RC_TIPO2 == "I" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[288,1] .and. x[9] <> 'D' .and. x[7] == 'I' }))) == 0
						fMatriz(aCodFol[288,1],(cAliasAux)->RC_VALOR,,cSemana,,,"I",,,(cAliasAux)->RC_DATA)
					EndIf
					If (cAliasAux)->RC_PD == aCodFol[289,1] .and. (cAliasAux)->RC_TIPO2 == "I" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[289,1] .and. x[9] <> 'D' .and. x[7] == 'I' }))) == 0
						fMatriz(aCodFol[289,1],(cAliasAux)->RC_VALOR,,cSemana,,,"I",,,(cAliasAux)->RC_DATA)
					EndIf
					If (cAliasAux)->RC_PD == aCodFol[992,1] .and. (cAliasAux)->RC_TIPO2 == "I" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[992,1] .and. x[9] <> 'D' .and. x[7] == 'I' }))) == 0
						fMatriz(aCodFol[992,1],(cAliasAux)->RC_VALOR,,cSemana,,,"I",,,(cAliasAux)->RC_DATA)
					EndIf
					If (cAliasAux)->RC_PD == aCodFol[993,1] .and. (cAliasAux)->RC_TIPO2 == "I" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[993,1] .and. x[9] <> 'D' .and. x[7] == 'I' }))) == 0
						fMatriz(aCodFol[993,1],(cAliasAux)->RC_VALOR,,cSemana,,,"I",,,(cAliasAux)->RC_DATA)
					EndIf
					//--FIM Verbas de outras empresas lançadas--
				
					lSomou := .F.
					If (cAliasAux)->RC_PD $ aCodFol[13,1] + "/" + aCodFol[14,1] + "/" + aCodFol[221,1] + "/" + aCodFol[1384,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo
						If lDissidio .And. (cAliasAux)->RC_SEQMV > CSEQMV
							nBasAuxD += (cAliasAux)->RC_VALOR
						Else
							nBsInssOut += (cAliasAux)->RC_VALOR
							If lDissidio .And. RHH->( dbSeek( (cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + cMesAnoCalc + (cAliasAux)->RC_PERIODO + (cAliasAux)->RC_PD + (cAliasAux)->RC_CC ) )
								nBsInssOut -= (cAliasAux)->RC_VALOR
								nBsInssOut += RHH->RHH_CALC
							EndIf
						EndIf
						lSomou := .T.
						If (cAliasAux)->ROTEIRO == cRotAut //Se for autonomo, deve incluir a verba 1847
							nBsAut += (cAliasAux)->RC_VALOR
							If lDissidio .And. RHH->( dbSeek( (cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + cMesAnoCalc + (cAliasAux)->RC_PERIODO + (cAliasAux)->RC_PD + (cAliasAux)->RC_CC ) )
								nBsAut -= (cAliasAux)->RC_VALOR
								nBsAut += RHH->RHH_CALC
							EndIf
						EndIf
					ElseIf 	(cAliasAux)->RC_PD $ aCodFol[64,1] + "/" + aCodFol[65,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo
						nInssOut += (cAliasAux)->RC_VALOR
						If lDissidio .And. RHH->( dbSeek( (cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + cMesAnoCalc + (cAliasAux)->RC_PERIODO + (cAliasAux)->RC_PD + (cAliasAux)->RC_CC ) )
							nInssOut -= (cAliasAux)->RC_VALOR
							nInssOut += RHH->RHH_CALC
						EndIf
						lSomou := .T.
						If (cAliasAux)->ROTEIRO == cRotAut //Se for autonomo, deve incluir a verba no mnemonico nInssAOut
							nInssAOut += (cAliasAux)->RC_VALOR
							If lDissidio .And. RHH->( dbSeek( (cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + cMesAnoCalc + (cAliasAux)->RC_PERIODO + (cAliasAux)->RC_PD + (cAliasAux)->RC_CC ) )
								nInssAOut -= (cAliasAux)->RC_VALOR
								nInssAOut += RHH->RHH_CALC
							EndIf
						EndIf
					ElseIf (cAliasAux)->RC_PD $ aCodFol[15,1] + "/" +  aCodFol[16,1] + "/" + aCodFol[10,1] + "/" + aCodFol[106,1] .and. ( AnoMes((cAliasAux)->RC_DATA) == cAnoMes )
						If (cAliasAux)->RC_PD == aCodFol[106,1]
							If (cAliasAux)->ROTEIRO == cRotADI
								If P_TPAPUIR == "2"
									If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
										If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
											nBsIrOut -= (cAliasAux)->RC_VALOR
										EndIf
									EndIf
								ElseIf P_TPAPUIR == "1"
									nBsIrOut -= (cAliasAux)->RC_VALOR
								EndIf
							ElseIf (cAliasAux)->ROTEIRO $ cRotAtu .and. (cAliasAux)->TAB == "SRC" .and. (cAliasAux)->RC_TIPO2 == "F" .and. AnoMes((cAliasAux)->RC_DATA) == AnoMes(DDATA_PGTO)
							 	If ( nPos := aScan( aFilMat, { |x| x[1]+x[2] == (cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT }) ) > 0 .and. aFilMat[nPos,4] == "S"
									nBsIrOut -= (cAliasAux)->RC_VALOR
								EndIf
							EndIf
						ElseIf (cAliasAux)->RC_PD <> aCodFol[15,1] .or. cTipoRot <> '3' //Não soma IR de folha com IR de férias
							If P_TPAPUIR == "2"
								If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
									If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
										nBsIrOut += (cAliasAux)->RC_VALOR
										lSomou := .T.
									EndIf
								EndIf
							ElseIf P_TPAPUIR == "1"
								nBsIrOut += (cAliasAux)->RC_VALOR
								lSomou := .T.
							EndIf
						EndIf
					ElseIf (cAliasAux)->RC_PD $ aCodFol[66,1] + "/" + aCodFol[67,1] + "/" + aCodFol[9,1] .and. ( AnoMes((cAliasAux)->RC_DATA) == cAnoMes )
						If (cAliasAux)->RC_PD <> aCodFol[66,1] .or. cTipoRot <> '3' //Não soma IR de folha com IR de férias
							If P_TPAPUIR == "2"
								If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
									If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
										nIrOut += (cAliasAux)->RC_VALOR
										lSomou := .T.
									EndIf
								EndIf
							ElseIf P_TPAPUIR == "1"
								nIrOut += (cAliasAux)->RC_VALOR
								lSomou := .T.
							EndIf
						EndIf
					EndIf
					If (cAliasAux)->TAB == "SRC" .and. (cAliasAux)->ROTEIRO <> cRotADI .and. lSomou
						//Indica que funcionário já teve a folha calculada no período
						cFilMatAux += (cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + (cAliasAux)->RC_PERIODO + "|"
					EndIf
				EndIf
				If  (cAliasAux)->ROTEIRO $ cRotAtu .and. (cAliasAux)->RC_SEQMV > cAuxSeqMv
					cAuxSeqMv := (cAliasAux)->RC_SEQMV
				EndIf
			EndIf
		
			(cAliasAux)->(dbSkip())
		EndDo

		If Empty(CSEQMV)
			If cAuxSeqMv > "0"
				CSEQMV := Soma1(cAuxSeqMv)
			Else 
				CSEQMV := "1"
			EndIf
		EndIf 

		(cAliasAux)->(dbCloseArea())

		If nBsInssOut > 0
			If cTipoRot == "3" //Férias
				If cSemana > "01" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[396,1] .and. x[9] <> 'D' .and. x[11] == '9' }))) > 0
					aPd[nPos,9] := "D"
				EndIf
				fMatriz(aCodFol[396,1],nBsInssOut,,cSemana,,,cTipo,,,,,"9")
			Else
				If cSemana > "01" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[288,1] .and. x[9] <> 'D' .and. x[11] == '9' }))) > 0
					aPd[nPos,9] := "D"
				EndIf
				fMatriz(aCodFol[288,1],nBsInssOut,,cSemana,,,cTipo,,,,,"9")
			EndIf
			If nBsAut > 0 .and. !Empty(aCodFol[1847,1])
				If cSemana > "01" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[1847,1] .and. x[9] <> 'D' .and. x[11] == '9' }))) > 0
					aPd[nPos,9] := "D"
				EndIf
				fMatriz(aCodFol[1847,1],nBsAut,,cSemana,,,cTipo,,,,,"9")
			EndIf
		EndIf

		If nInssOut > 0
			If cTipoRot == "3" //Férias
				If cSemana > "01" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[397,1] .and. x[9] <> 'D' .and. x[11] == '9' }))) > 0
					aPd[nPos,9] := "D"
				EndIf
				fMatriz(aCodFol[397,1],nInssOut,,cSemana,,,cTipo,,,,,"9")
			Else
				If cSemana > "01" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[289,1] .and. x[9] <> 'D' .and. x[11] == '9' }))) > 0
					aPd[nPos,9] := "D"
				EndIf
				fMatriz(aCodFol[289,1],nInssOut,,cSemana,,,cTipo,,,,,"9")
			EndIf
		EndIf

		If nBsIrOut > 0
			If cTipoRot == "3" //Férias
				If cSemana > "01" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[236,1] .and. x[9] <> 'D' .and. x[11] == '9' }))) > 0
					aPd[nPos,9] := "D"
		 	 	EndIf
				fMatriz(aCodFol[236,1],nBsIrOut + nBsIrFOut,,cSemana,,,cTipo,,,,,"9")
				nBsIrFOut := 0
			Else 
				If cSemana > "01" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[992,1] .and. x[9] <> 'D' .and. x[11] == '9' }))) > 0
					aPd[nPos,9] := "D"
		  		EndIf
				fMatriz(aCodFol[992,1],nBsIrOut,,cSemana,,,cTipo,,,,,"9")
			EndIf
		EndIf

		If nBsIrFOut > 0
			If cSemana > "01" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[236,1] .and. x[9] <> 'D' .and. x[11] == '9' }))) > 0
				aPd[nPos,9] := "D"
			EndIf
			fMatriz(aCodFol[236,1],nBsIrFOut,,cSemana,,,cTipo,,,,,"9")
		EndIf

		If nIrOut > 0
			If cTipoRot == "3" //Férias
				If cSemana > "01" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[237,1] .and. x[9] <> 'D' .and. x[11] == '9' }))) > 0
					aPd[nPos,9] := "D"
				EndIf
				fMatriz(aCodFol[237,1],nIrOut + nIrFOut,,cSemana,,,cTipo,,,,,"9")
				nIrFOut := 0
			Else 
				If cSemana > "01" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[993,1] .and. x[9] <> 'D' .and. x[11] == '9' }))) > 0
					aPd[nPos,9] := "D"
				EndIf
				fMatriz(aCodFol[993,1],nIrOut,,cSemana,,,cTipo,,,,,"9")
			EndIf
		EndIf

		If nIrFOut > 0
			If cSemana > "01" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[237,1] .and. x[9] <> 'D' .and. x[11] == '9' }))) > 0
				aPd[nPos,9] := "D"
			EndIf
			fMatriz(aCodFol[237,1],nIrFOut,,cSemana,,,cTipo,,,,,"9")
		EndIf

		If nBsInss13 > 0
			If cSemana > "01" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[290,1] .and. x[9] <> 'D' .and. x[11] == '9' }))) > 0
				aPd[nPos,9] := "D"
			EndIf
			fMatriz(aCodFol[290,1],nBsInss13,,cSemana,,,cTipo,,,,,"9")
		EndIf 

		If nInss13 > 0 
			If cSemana > "01" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[291,1] .and. x[9] <> 'D' .and. x[11] == '9' }))) > 0
				aPd[nPos,9] := "D"
			EndIf
			fMatriz(aCodFol[291,1],nInss13,,cSemana,,,cTipo,,,,,"9")
		EndIf

		If nBsIr13 > 0 
			If cSemana > "01" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[994,1] .and. x[9] <> 'D' .and. x[11] == '9' }))) > 0
				aPd[nPos,9] := "D"
			EndIf
			fMatriz(aCodFol[994,1],nBsIr13,,cSemana,,,cTipo,,,,,"9")
		EndIf 

		If nIr13 > 0 
			If cSemana > "01" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[995,1] .and. x[9] <> 'D' .and. x[11] == '9' }))) > 0
				aPd[nPos,9] := "D"
			EndIf
			fMatriz(aCodFol[995,1],nIr13,,cSemana,,,cTipo,,,,,"9")
		EndIf

        If nBsInssMs > 0 .And. Len(aCodFol) > 1859
			If cSemana > "01" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[1860,1] .and. x[9] <> 'D' .and. x[11] == '9' }))) > 0
				aPd[nPos,9] := "D"
			EndIf
			fMatriz(aCodFol[1860,1],nBsInssMs,,cSemana,,,cTipo,,,,,"9")
		EndIf

        If nInssMsOut > 0 .And. Len(aCodFol) > 1859
			If cSemana > "01" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFol[1861,1] .and. x[9] <> 'D' .and. x[11] == '9' }))) > 0
				aPd[nPos,9] := "D"
			EndIf
			fMatriz(aCodFol[1861,1],nInssMsOut,,cSemana,,,cTipo,,,,,"9")
		EndIf
	EndIf 
EndIf

RestArea(aAreaRHH)
RestArea(aArea)

Return lMultv 

/*/{Protheus.doc} fGerBasFer
Função que verifica a base do IR de férias sem deduções e gera o Id 1562
@author Allyson Mesashi
@since 22/08/2018
@version 1.0
@param aVb 	 - Array das verbas do roteiro FER
/*/
Function fGerBasFer( aVb )

Local aAux		:= {}
Local cTipo		:= ""
Local cVerba	:= ""
Local lAtuVb	:= (Len(aCodFol) >= 1723)
Local lAtuVb4	:= (Len(aCodFol) >= 1893)
Local leSocSimpl:= (GetMvRH( "MV_VLESOC", Nil, "" ) == "S_01_00_00")
Local lRet		:= .T.
Local lVldCond1	:= .F.
Local lVldCond2	:= .F.
Local lVldCond3	:= .F.
Local lVldCond4	:= .F.
Local nCont 	:= 1
Local nPos		:= 0

For nCont := 1 To Len(aVb)
	//Se for referente ferias e incide para IR
	lVldCond1	:= (RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_REFFER" ) == "S" .And. RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_IR" ) == "S" .And. RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_TIPOCOD" ) == "1")
	//Se for referente abono
	lVldCond2	:= (lAtuVb .And. RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_IR" ) == "N" .And. (RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_CODFOL" ) $ "0074/0079/0094/0095/0205/0206/0207/0208/0622/0623/0632/0633/0634/0635/1312/1313/1314/1315/1316/1317/1318/1319/1320/1321/1322/1323/1324/1325/1326/1327/1330/1331/1407/1408/1409/1410/1416/1417/1418/1419/1450/1451/" .Or. (lRefAbono .And. RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_REFABON" ) == "1") ) .And. RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_TIPOCOD" ) == "1" )
	//Se for referente Dedução INSS Base IR Ferias
	lVldCond3	:= (lAtuVb .And. RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_CODFOL" ) == "0168" .And. RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_INCIRF" ) == "43")
	//Se for referente Dedução IRRF Ferias
	lVldCond4	:= (lAtuVb4 .And. RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_INCIRF" ) == "33")

	If lVldCond1
		cTipo	:= "1"
	ElseIf lVldCond2
		cTipo	:= "2"
	ElseIf lVldCond3
		cTipo	:= "3"
	ElseIf lVldCond4
		cTipo	:= "4"
	EndIf
	
	If (lVldCond1 .Or. lVldCond2 .Or. lVldCond3 .Or. lVldCond4)
		If ( nPos := aScan( aAux, { |x| x[19] == cTipo } ) ) > 0
			aAux[ nPos, 5 ] += aVb[nCont, 5]
		Else
			aAdd( aAux, { "", aVb[nCont, 2], aVb[nCont, 3], 0, aVb[nCont, 5], "", "", 0, "", aVb[nCont, 10], aVb[nCont, 11], 0, "", "", "", .F., "", aVb[nCont, 18], cTipo} )
		EndIf
	EndIf
Next nCont

If !Empty(aAux)
	For nCont := 1 To Len(aAux)
		If aAux[nCont, 19] == "1"
			cVerba	:= aCodFol[1562, 1]
		ElseIf aAux[nCont, 19] == "2"
			cVerba	:= aCodFol[1722, 1]
		ElseIf aAux[nCont, 19] == "3"
			cVerba	:= aCodFol[1723, 1]
		ElseIf aAux[nCont, 19] == "4"
			cVerba	:= aCodFol[1893, 1]
			lRet	:= !(leSocSimpl .And. Empty(cVerba))
		EndIf
		If !Empty(cVerba)
			FMatriz(cVerba, aAux[nCont, 5], 0, aAux[nCont, 3], aAux[nCont, 2], "V", "C", Nil, Nil, aAux[nCont, 10], Nil, aAux[nCont, 11], Nil, Nil, Nil, Nil, Nil, Nil, aVb[nCont, 18] )
		EndIf
	Next nCont
EndIf

Return lRet


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GRAVACALC ºAutor  ³Microsiga           º Data ³  12/16/03   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Gravacao do Calculo da Folha                               º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function GravaCalc()
Local cPergTmp 	:= "GP020VTR"

If LNOVOCALCB //mnemonico que carrega parametro MV_CALCBEN
	cPergTmp := "GP021VTR"
EndIf

If Type("cPergEspec") != "U" .And. Alltrim(cPergEspec) == cPergTmp
	Return(.T.)
EndIf

Begin Transaction
	lDissidio 	:= If(Type("lDissidio") == "U",.F.,lDissidio)
			
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ordena por Verba Deletada para, se existir Chave Duplicada no³
	//³ aPd, Primeiro Deletar para Depois Gravar					 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	
	aSort( aPd ,,, { |x,y| x[9] > y[9] } )
	
	If !lDissidio

		If ( GetRotExec() $ fGetCalcRot("1") + "*" + fGetCalcRot("9") + "*" + fGetCalcRot("N") + "*" + fGetCalcRot("O") ) //"FOL*AUT*RTF*BOP"

			//Efetua a gravação das tabelas RAZ/RAW para funcionários múltiplos vínculos
			If lGrvRAZRAW
				fGrvRAZRAW()
			EndIf
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava a matriz das verbas da Folha no Arquivo SRC			 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Aeval( aPD , { |X| Gravafol(X) } )
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verificar se existe Campo Sal.Incorporado no cadastro      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea( "SRA" )
			If FieldPos( "RA_SALINCO" ) # 0
				RecLock("SRA",.F.)
				SRA->RA_SALINCO := SALMES
				MsUnLock()
			EndIf
		Else
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava a matriz das verbas da Folha no Arquivo SRC			 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Aeval( aPD , { |X| GravaAdt(X) } )
			
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava as verbas de impostos reliquidados na tabela RGV       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cPaisLoc == "CHI" .And. !Empty( aImpRlq )
		
			cProcesso := SRA->RA_PROCES
			cRoteiro  := GetRotExec()
			
			dbSelectArea("RGV")
			dbSetOrder(1)
		
			If dbSeek( SRA->( RA_FILIAL + RA_MAT + MesAno(dDataAte) ) )
				While RGV->( !Eof() .And. SRA->( RA_FILIAL + RA_MAT ) == RGV_FILIAL + RGV_MAT )
					RecLock( "RGV", .F., .T. )
					RGV->( dbDelete() )
					RGV->( MsUnLock() )
					RGV->( dbSkip() )
				EndDo
			EndIf
			
			Aeval( aImpRlq , { |X| GrvReliq(X) } )
		EndIf
	EndIf			
End Transaction

If ( GetRotExec() == fGetRotOrdinar() ) // Roteiro Folha de Pagamento - roteiro ordinario
				
	If cPaisLoc == "BRA" .And. cComp13 == 'S' .And. cSitFolh # "D" .And. !(SRA->RA_CATFUNC $ 'E*G') .and. !lDissidio .And. SRA->RA_TPCONTR != "3" .And.  !(SRA->RA_CATEFD $ '107/108')

		fCompl13()
		
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se for recalculo, deletar o registro de "OK", indicando que  |
	//| devera ser gerado um novo SRZ.								 |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lDissidio
		fDelRegSRZ(1,SRA->RA_TPCONTR)
	Else
		GravaDissidio(aPd,aPdOld,,aCodFol)
	EndIf

EndIf

If cTipoRot == "1" .and. !lDissidio
	fGrvDCTFWEB()
EndIf 

Return(.T.)	

/*/{Protheus.doc} fGrvDCTFWEB
Função para gravação das informações necessárias para a geração do relatório DCTFWEB
@author Tribe Proheus RH
@since 22/09/2022
/*/
Static Function fGrvDCTFWEB()

/*
Esse função deve ser utilizada para gravar todas as informações necessárias para o relatório DCTFWEB.
* VERIFICAR A NECESSIDADE DE EXECUÇÃO PARA AUTONOMOS E ALTERAR A CHAMADA DA FUNÇÃO.
* VERIFICAR A NECESSIDADE DE CRIAÇÃO DE PARAMETROS/MNEMONICOS OU SE ESTA FUNÇÃO DEVERÁ SEMPRE SER EXECUTADA, COMO ESTA AGORA.
A Squad de rotinas deverá criar uma tabela com os campos necessários e efetuar a gravação com os dados que estão na memória nesse momento.
TODAS AS INFORMAÇÕES UTILIZADAS NO CÁLCULO ESTÃO DISPONÍVEIS NESSE MOMENTO, SEJA NA SRA, SEJA NO APD COM AS VERBAS, OU AINDA NOS MNEMONICOS DO SISTEMA.
Exemplo de implementação:
DbSelectArea(ALIAS)

RecLock(ALIAS,.T.)
ALIAS_FILIAL := SRA->RA_FILIAL
ALIAS_MAT    := SRA->RA_MAT
ALIAS_CATEFD := SRA->RA_CATEFD

//Estudar a possibilidade de gravar uma tabela filho para as verbas, ou um registro para cada verba na mesma tabela. Tudo dependerá da funcionalidade necessária
For nX := 1 to Len(aPd)
	ALIAS_PDINC	 += aPd[nX,1] + RetValSRV(aPd[nX,1],SRA->RA_FILIAL,"RV_INCCP") + RetValSRV(aPd[nX,1],SRA->RA_FILIAL,"RV_INCIRRF") + RetValSRV(aPd[nX,1],SRA->RA_FILIAL,"RV_INCFGTS") + "/"
Next nX

ALIAS_SALFAM := //Buscar salário familia no aPd
ALIAS_SEST   := //Buscar contribuição SEST no aPd
ALIAS_SENAT  := //Buscar contribuição SENAT no aPd

MsUnLock()

*/
Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ GravaFol ³ Autor ³ Mauro 			    ³ Data ³ 07.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava as Verbas da Matriz Calculadas no Adiantamento  	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GravaAdt(X)												  ³±±
±±³ 		 ³														  	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ X =	Matriz Multi contendo						    	  ³±±
±±³	 		 ³ Codigo da Verba , C.Custo, cSemana, Horas , Valor , Tipo1,;³±±
±±³ 		 ³ Tipo2 , Parcela										  	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso 	 ³ Generico 											  	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function GravaFol(aX)

Local lItemClVl   := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3"

If SRA->RA_TPCONTR == "3" .And. !aConvocacao[6]
	If SRA->RA_TIPOPGT != "S" .Or. aX[22] == aConvocacao[1]
		aAdd(aPdConvoc,aClone(ax))
	EndIf
EndIf

If cTipoRot == "O"
	aAdd( aPdBenOp, aClone(aX) )
EndIf

If aX[3] = cSemana .Or. Empty( aX[3] )
	If lItemClVl
		GravaSrc( SRA->RA_FILIAL, SRA->RA_MAT, aX[1], If(!Empty(aX[10]), aX[10], dData_Pgto), aX[2],;
		If(Empty(aX[3]), cSemana, aX[3] ), aX[6], aX[7], aX[4], aX[5], aX[8], aX[9], Nil, aX[11], aX[12], aX[13], aX[14], If(Len(aX)>= 17, aX[17], ''), aX[20], aX[21], aX[15], aX[18], aX[22], Nil, aX[23], aX[24], Iif(Len(aX) >= 26, aX[26], "") )
	Else
		GravaSrc( SRA->RA_FILIAL, SRA->RA_MAT, aX[1], If(!Empty(aX[10]), aX[10], dData_Pgto), aX[2],;
		If(Empty(aX[3]), cSemana, aX[3] ), aX[6], aX[7], aX[4], aX[5], aX[8], aX[9], Nil,aX[11], aX[12], Nil, Nil, If(Len(aX)>= 17, aX[17], ''), aX[20], aX[21], aX[15], aX[18], aX[22], Nil, aX[23], aX[24], Iif(Len(aX) >= 26, aX[26], "") )
	Endif			
EndIf
Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GravaAdt ³ Autor ³ Mauro                 ³ Data ³ 07.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava as Verbas da Matriz Calculadas no Adiantamento       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GravaAdt(aX)                                               ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aX =  Matriz Multi contendo                                ³±±
±±³          ³ Codigo da Verba , C.Custo, Semana, Horas , Valor , Tipo1 ,;³±±
±±³          ³ Tipo2 , Parcela                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function GravaAdt(aX)
Local lItemClVl   := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3"
Local dDtPgt 

If aX[7] == 'I' .And. Empty(ax[10]) .And. ax[1]$ aCodFol[007,1]+ aCodFol[012,1]+ aCodFol[010,1] 
	dDtPgt := dData_Pgto
Else
	dDtPgt := If (Empty(Ax[10]), dData_Pgto, Ax[10])
Endif
      
If Empty( aX[3] ) .Or. aX[3] = cSemana
	If lItemClVl
		GravaSrc(SRA->RA_FILIAL,SRA->RA_MAT,aX[1], dDtPgt ,aX[2],aX[3],aX[6],aX[7],aX[4],aX[5],aX[8],ax[9],,aX[11],,aX[13],aX[14],,aX[20],aX[21],aX[15],aX[18],Nil,Nil,aX[23],aX[24])
	Else
		GravaSrc(SRA->RA_FILIAL,SRA->RA_MAT,aX[1], dDtPgt ,aX[2],aX[3],aX[6],aX[7],aX[4],aX[5],aX[8],ax[9],,aX[11],,,,,aX[20],aX[21],aX[15],aX[18],Nil,Nil,aX[23],aX[24])
	Endif
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fSomaAdic ºAutor  ³Ricardo Duarte Costaº Data ³  02/05/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Funcao devolver o valor dos adicionais a serem considerados º±±
±±º          ³para o calculo da 1a parcela do 13o salario nas ferias.     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ 															  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/ 
Function fSomaAdic()

Local nValRet	:= 0

If nAdtServ   > 0
	nValRet += nAdtServ
EndIf

If nPeric  > 0
	nValRet += nPeric
EndIf

If nInsalub > 0
	nValRet += nInsalub
EndIf

If nAdcConf > 0
	nValRet += nAdcConf
EndIf

If nAdcTrf > 0
	nValRet += nAdcTrf
EndIf

Return(nValRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fSalInc	  ³ autor ³ Mauro               ³ Data ³ 24/08/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Achar Salario Incorporado Usando Roteiro da Folha          ³±±
±±³ÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³±±
±±³Parametro ³ fSalInc(Salario,SalMes,SalHora,SalDia,Comiss)              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fXSalInc(nXSal,nXSalM,nXSalH,nXSalD,lXRelGp,nXComiss,dDtXTarDe,dDtXTarAte)

Local cSvRotExec
Local nExecRot := 0 
Local cRotCalc := ""

Static cPd0165
Static cPd0166
Static cPd0347

If cPaisLoc <> "MEX"

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carregar os Mnemonicos 	                                   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	SetMnemonicos(NIL,NIL,.T.)

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carregando variaveis para busca das tarefas			       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If dDtXTarDe # Nil .And. dDtTarXAte # Nil
		dDataDe  := dDtXTarDe
		dDataAte := dDtXTarAte
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Execucao da Formula de Salario Incorporado		    	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/    
	cRotCalc := fGetCalcRot("1") //"FOL"
	nExecRot := ExecForm( SRA->RA_FILIAL, "SALINC", cRotCalc )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Atualizacao das Variaveis apos o Retorno da Execucao da for- ³
	³ mula. As variaveis sao tratadas como mnemonicos.             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cSvRotExec := SetRotExec( cRotCalc )
	If cPd0165 == Nil .Or. cPd0166 == Nil .Or. cPd0347 == Nil
		cPd0165 := fGetCodFol("0165")
		cPd0166 := fGetCodFol("0166")
		cPd0347 := fGetCodFol("0347")
	EndIf
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Estava gerando erro na geracao do CAGED, checar e ajustar.   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	nXComiss := 0 // fbuscaPD( If(Empty(cPd0165),"",cPd0165)+","+If(Empty(cPd0166),"",cPd0166)+","+If(Empty(cPd0347),"",cPd0347))
	SetRotExec( cSvRotExec )
	nXSal    := Salario
	nXSalM   := SalMes
	nXSalH   := SalHora
	nXSalD   := SalDia

ElseIf cPaisLoc == "MEX"

	nXSal    := SRA->RA_SALARIO
	nXSalM   := SRA->RA_SALMES
	nXSalH   := SRA->RA_SALHOR
	nXSalD   := SRA->RA_SALDIA

EndIf

If lXRelGp
	Set Device to Print
Endif

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fRetTab   ºAutor  ³Tiago Malta         º Data ³  11/11/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Pociciona na condição correta e realiza o tratamento do    º±±
±±º          ³  filtro.                                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±³Parametro ³fRetTab(Array,Tabela,P.Sindic,P.Express,dDataRef,cSindica)  ³±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fRetTab( aTab_Fol, cCodTab, npoSind, npoExpre, dDataRef, cSindica, lTabFull, cFilPar, lRecarga )

Local cFilTab    := ""
Local aNewTabFol := {}
Local lAchou     := .F.
Local nPosTab    := 0
Local nX         := 0

DEFAULT cFilPar	 	:= SRA->RA_FILIAL
DEFAULT lTabFull 	:= .F.
DEFAULT lRecarga	:= .F.	

cFilTab  :=	xFilial("RCC", cFilPar)

//--Carrega Tabela
fCarrTab( @aTab_Fol, cCodTab, dDataRef, lRecarga, , lRecarga, cFilPar )

IF npoSind <> NIL .AND. !EMPTY(npoSind)
	npoSind	:= npoSind+1
ENDIF

IF npoExpre <> NIL .AND. !EMPTY(npoExpre)
	npoExpre:= npoExpre+1
ENDIF

//--Verifica se Existe a Tabela Cadastrada
If ( nPosTab :=    Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == cFilTab 				.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
	lAchou := .T.
Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == cFilTab 				.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0
	lAchou := .T.
Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(FwGetTamFilial) .And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
	lAchou := .T.
Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(FwGetTamFilial) .And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0
	lAchou := .T.
Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == cFilTab 				.And. x[3] == Space(6)         .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
	lAchou := .T.
Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == cFilTab 				.And. x[3] == Space(6)         .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
	lAchou := .T.
Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(FwGetTamFilial) .And. x[3] == Space(6)         .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
	lAchou := .T.
Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(FwGetTamFilial) .And. x[3] == Space(6)         .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
	lAchou := .T.
Endif

//-Tratamento pra Gestao Corporativa
//.Combinacoes possiveis
//.Empr / UNeg / Fil
//.  E      E     E  (ja testado acima)
//.  E      E     C
//.  E      C     E
//.  E      C     C
//.  C      C     C  (ja testado acima)
//.  C      C     E
//.  C      E     C
//.  C      E     E

If !lAchou
	If ( nPosTab :=    Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+FwFilial()						.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
		lAchou := .T.
	ElseIf ( nPosTab :=    Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+Space(Len(FwFilial()))			.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+FwFilial()			.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+Space(Len(FwFilial())).And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+Space(Len(FwUnitBusiness()))+FwFilial().And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+Space(Len(FwFilial())).And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+FwFilial()			.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
		lAchou := .T.
	
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+FwFilial()						.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+Space(Len(FwFilial()))			.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+FwFilial()			.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+Space(Len(FwFilial())).And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+Space(Len(FwUnitBusiness()))+FwFilial().And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+Space(Len(FwFilial())).And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+FwFilial()			.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0
		lAchou := .T.
	//--
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+FwFilial()						.And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+Space(Len(FwFilial()))			.And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+FwFilial()			.And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+Space(Len(FwFilial())) .And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+Space(Len(FwUnitBusiness()))+FwFilial() .And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+Space(Len(FwFilial())) .And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+FwFilial()			.And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+FwFilial()						.And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+Space(Len(FwFilial()))			.And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+FwFilial()			.And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+Space(Len(FwFilial())) .And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+Space(Len(FwUnitBusiness()))+FwFilial() .And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+Space(Len(FwFilial())) .And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+FwFilial()			.And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==Space(2)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Endif
Endif

If lAchou
	If !lTabFull
		aTab_Fol := Aclone(aTab_Fol[nPosTab])
	Else
		//# Carrega a Tabela Toda
		For nX := nPosTab To Len( aTab_Fol )
			If aTab_Fol[nX, 1] == cCodTab
				aAdd( aNewTabFol, aClone( aTab_Fol[nX] ) )
			EndIf
		Next nX
		aTab_Fol := Aclone(aNewTabFol)
	EndIf
ELSE
	aTab_Fol := {}
ENDIF

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Função	 ³fCarPD    ³ Autor ³ MOHANAD ODEH ³Data³22/06/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Carrega as variaveis p/cadastro de Verbas      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fCarPD()                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Vide Paramentros Formais                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ Generico 									  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fCarPD()
Local aArea		:= GetArea()
Local aAreaSRV	:= SRV->(GetArea()) 
Local aAux		:= {}
Local aSRVHeader:= {}
Local bFunc		:= {|| NIL}
Local cCampo	:= ""
Local cFilSRV	:= xFilial("SRV")
Local cVerbas	:= ""
Local cFunction	:= ("GPPD" + cPaisLoc)
Local nFieldPos
Local nPosField
Local nPosVerba
Local nAux
Local nAuxs
Local nX
Local uCnt
Local cFiltro := 'SRV->RV_FILIAL == "' + cFilSRV + '"' 
Local bFiltro := { || &(cFiltro) }

// Verifica a Existencia da Funcao do Pais Corrente
If FindFunction(cFunction)
	bFunc := __ExecMacro("{ ||  " + cFunction + "( @aAux , @aSRVHeader ) }")
	Eval(bFunc)
	DbSelectarea("SRV")
	DbSetOrder(1)
	SRV->(DbSetfilter( bFiltro, cFiltro ))
	SRV->(DbGoTop())
		
	//Verifica se Tabela de Verbas esta Vazia, para a filial em uso -- Se estiver realizar a carga
    If SRV->(Eof())
		nPosVerba := GdFieldPos("RV_COD" , aSRVHeader)
		nAuxs := Len(aAux)
		DbSelectarea("SRV")
		DbSetOrder(1)
		For nAux := 1 To nAuxs
			cVerbas := Padr(Upper(AllTrim(aAux[ nAux, nPosVerba ])),TamSX3("RV_COD")[1])
			If SRV->(dbSeek(cFilSRV + cVerbas))
				 RecLock("SRV",.F.,.T.)
			Else
				 RecLock("SRV",.T.,.T.)
			EndIf
			For nX := 1 To Len(aSRVHeader)
			   	cCampo := Upper(aSRVHeader[nX, 2])
				nFieldPos := SRV->(FieldPos(cCampo))
				If (nFieldPos > 0)
					If (aSRVHeader[nX, 2] == "RV_FILIAL")
						uCnt := cFilSRV
					Else
				    	nPosField := GdFieldPos(cCampo , aSRVHeader)
				    	If (nPosField == 0)
				    		Loop
				    	EndIF
				    	uCnt := aAux[nAux , nPosField]
					Endif
					SRV->(FieldPut(nFieldPos , uCnt))
				EndIF
			Next nX
			SRV->(MsUnlock())

		Next nAux
	EndIf
EndIf

RestArea(aAreaSRV)
RestArea(aArea)

Return(NIL)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GpIniCrg  ºAutor  ³Leandro Drumond     º Data ³  12/09/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Controle de atualizacoes das informacoes das tabelas padraoº±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GpIniCrg()
Local aArea
Local cFunc	:= ( "GpCrg" + cPaisLoc + "()" )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verificar a existencia da formula padrao do pais corrente     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If FindFunction( cFunc )
	aArea	:= GetArea()
	__ExecMacro( cFunc )
	RestArea( aArea )
EndIf

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGravaCrg ºAutor  ³Leandro Drumond     º Data ³  12/09/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Grava as alteracoes nas tabelas padrao.                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fGravaCrg(aRCCHeader, aRCCItens)
Local cCampo
Local cFilRCc 		:= xFilial( "RCC" )
Local nPosCod 		:= GdFieldPos( 'RCC_CODIGO'	, aRCCHeader )
Local nPosFil 		:= GdFieldPos( 'RCC_FIL' 	, aRCCHeader )
Local nPosChv 		:= GdFieldPos( 'RCC_CHAVE' 	, aRCCHeader )
Local nPosSeq 		:= GdFieldPos( 'RCC_SEQUEN'	, aRCCHeader )
Local nTamFil		:= TamSX3("RCC_FIL")[1]
Local nTamChv		:= TamSX3("RCC_CHAVE")[1]

Local nFieldPos
Local nX
Local nY

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Excluir os Itens da Tabela para Incluir posteriormente 	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
DbSelectArea( "RCC" )
DbSetOrder( 1 )  //RCC_FILIAL + RCC_CODIGO + RCC_FIL + RCC_CHAVE  + RCC_SEQUEN

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Incluir os Itens da Definicao Tabelas                  	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
For nX := 1 To Len( aRCCItens )
	
	If !(DbSeek(cFilRCC + aRCCItens[nX,nPosCod] + Padr(aRCCItens[nX,nPosFil],nTamFil) + Padr(aRCCItens[nX,nPosChv],nTamChv) + aRCCItens[nX,nPosSeq]))

		If RCC->( RecLock( "RCC" , .T. ) )
	
			// gravacao dos campos //
			For nY := 1 To Len(aRCCHeader)
				cCampo 		:= Upper(aRCCHeader[nY, 2])
				nFieldPos	:= RCC->( FieldPos( cCampo ) )
				IF ( nFieldPos > 0 )
					If ( cCampo != "RCC_FILIAL" )
				    	RCC->( FieldPut( nFieldPos , aRCCItens[nX, GdFieldPos ( cCampo , aRCCHeader )] ) )
				    Else
			    		RCC->( FieldPut( nFieldPos , cFilRCC ) )
				    EndIf
				EndIF
			Next nY
			RCC->( MsUnlock() )
		EndIF
	EndIf
Next nX

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fPropGTar  ºAutor  ³Jonatas A. T. Alves º Data ³  11/04/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Funcao para proporcionalizar a garantia de tarefas           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ 															   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/ 
Function fPropGTar(cTipCalc,nGTarPro)

Local nQtdDias	:= nDiasP //RFC->RFC_DCALCM

nGTarPro	:= Val_SalMin

If P_LGTARPRO
	Do Case
		Case cTipCalc == '2' // Folha / Rescisao
			nGTarPro := nGTarPro / nQtdDias * ( DiasTrab + DiasDsr + nDiasAc + nDiasAd + nDiasLRem )
		Case cTipCalc == '3' //13o. salario
			nGTarPro := If( lMedDir, nGTarPro, ( nGTarPro / 12 * nAvos ) )
	EndCase
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ No caso de MV_DIASMES = 'S', podera ocorrer de a garantia de ³
³ tarefas ser maior que o salario-minimo.					   ³
³ Aqui limitamos o valor da garantia de tarefas ao valor do    ³
³ salario-minimo.                                              ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
nGTarPro := Min( Val_SalMin, nGTarPro )

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fPropGComisºAutor  ³Jonatas A. T. Alves º Data ³  26/07/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Funcao para proporcionalizar a garantia de comissao          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ 															   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/ 
Function fPropGComis(cTipCalc,nGComisPro)

nGComisPro	:= RCE->RCE_GCOMIS

If P_PROPCOMS
	If cTipCalc == '2' // Folha
		nGComisPro := nGComisPro / nDiasC * (DiasTrab + nDiasAc + nDiasAd + nDiasLRem)
	ElseIf cTipCalc == '1' // Adiantamento
		nGComisPro := nGComisPro / nDiasC * DiasTb
	ElseIf cTipCalc == '3' //13o. salario
		nGComisPro := If(P_MEDDIREN == "N", (nGComisPro / 12 * nAvos), nGComisPro)
	EndIf
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³GetSrySeqFilºAutor ³Leandro Drumond     º Data ³  07/12/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Funcao para gerar codigo unico para filia na SRY             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ 															   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/ 
Function GetSrySeqFil(cFil,lProximo)
Local aArea	:= GetArea()
Local cRet 	:= ""

DEFAULT lProximo := .T.

DbSelectArea('SRY')
If DbSeek(cFil)
	cRet := SRY->RY_SEQFIL
Else
	If lProximo
		cRet := "00"
		DbGoTop()
		While SRY->(!Eof())
			If SRY->RY_SEQFIL > cRet
				cRet := SRY->RY_SEQFIL
			EndIf
			SRY->(DbSkip())
		EndDo
		cRet := Soma1(cRet)
	EndIf
EndIf

RestArea(aArea)

Return cRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fComp13FolºAutor ³Raquel Hager		     º Data ³  16/12/15   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Funcao que verifica se o periodo de 13 esta fechado ou nao   º±±
±±º			  ³ao executar Folha e mnemonico P_CCOMP13 configurado com S.   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ 															   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/ 
Function fComp13Fol()
Local lRet		:= .T.
Local cRot132 	:= ""

If cPaisLoc == "BRA" .And. cSitFolh # "D" .And. cTipoRot == "1" .and. P_CCOMP13 == 'S' .And. !( Type("lSalInco") <> "U" .And. lSalInco )
 	// Paga Complemento 13 Salario na Folha de Pagamento	
	cRot132 	:= fGetCalcRot('6')		
	dbSelectArea("RCH")
	RCH->(dbSetOrder(RetOrdem("RCH", "RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG")))	
	If RCH->(dbSeek(xFilial("RCH",SRA->RA_FILIAL)+CPROCESSO+cRot132+CPERIODO+CSEMANA))
		If Empty(RCH->RCH_DTFECH)
			// Se o roteiro de 13 do Periodo nao estiver fechado, nao calcula complementar
			lRet 	:= .F.
		Else		
			lRet	:= .T.
		EndIf
	Else
		lRet := .T.
	EndIf
EndIf

Return (lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fRetRCB  ºAutor ³Paulo Inzonha	      º Data ³  26/01/18   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Funcao pesquisa e retorna array com os valores da RCB        º±±
±±º			  ³a partir dos valores RCB_CAMPOS ou RCB_ORDEM informado      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cFilRCB - Filial 										   º±±
±±º			 ³ cTab    - Codigo da Tabela								   º±±	
±±º			 ³ Ordem   - valor do RCB_ORDEM a ser pesquisado 			   º±±	
±±º			 ³ cCampos - valor do RCB_CAMPOS a ser pesquisado    		   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/ 
Function fRetRCB(cFilRCB,cTab,cOrdem, cCampos)
Local aRCB		:= {}
Local cAliasRCB	:= GetNextAlias()
Default cOrdem 	:= ""
Default cCampos := ""

BeginSql alias cAliasRCB
	SELECT RCB_ORDEM, RCB_CAMPOS, RCB_DESCPO, RCB_TIPO, RCB_TAMAN, RCB_DECIMA, RCB_PICTUR, RCB_VALID, RCB_PADRAO, RCB_VERSAO, RCB_PESQ, RCB_SHOWMA, RCB_MODULO, RCB_PROCES
	FROM %table:RCB% RCB
	WHERE RCB_FILIAL = %exp:xFilial("RCB",cFilRCB)%	AND RCB_CODIGO = %exp:cTab% AND
	( RCB_ORDEM = %exp:cOrdem% OR RCB_CAMPOS = %exp:cCampos% ) AND RCB.%notDel%   
EndSql

While (cAliasRCB)->( !Eof() ) 
	aAdd(aRCB,{(cAliasRCB)->RCB_ORDEM, (cAliasRCB)->RCB_CAMPOS, (cAliasRCB)->RCB_DESCPO, (cAliasRCB)->RCB_TIPO, (cAliasRCB)->RCB_TAMAN,;
	    (cAliasRCB)->RCB_DECIMA, (cAliasRCB)->RCB_PICTUR, (cAliasRCB)->RCB_VALID, (cAliasRCB)->RCB_PADRAO, (cAliasRCB)->RCB_VERSAO, ;
	    (cAliasRCB)->RCB_PESQ, (cAliasRCB)->RCB_SHOWMA, (cAliasRCB)->RCB_MODULO, (cAliasRCB)->RCB_PROCES})
	(cAliasRCB)->(DbSkip())
EndDo

(cAliasRCB)->(dbCloseArea())

Return (aRCB)

/*/{Protheus.doc} fGrvRAZRAW
//Grava dados na RAW/RAZ
@author flavio.scorrea
@since 26/04/2019
/*/
Function fGrvRAZRAW(lCalcResc)

Local aArea		:= GetArea()
Local aAreaSRA	:= SRA->(GetArea())
Local aAreaSRC	:= SRC->(GetArea())
Local aCNPJ		:= {}
Local aFilMat	:= {}
Local lTemRAW	:= .F.
Local lTemResc  := .F.
Local nPos		:= 0
Local cCnpj		:= ""
Local cCnpjAtu	:= ""
Local cCpf		:= SRA->RA_CIC
Local cFilMat   := SRA->RA_FILIAL + SRA->RA_MAT
Local cIndFol	:= "1"
Local cIndMV	:= "1"
Local cPdTot	:= ""
Local nBase		:= 0
Local nBase2	:= 0
Local nBase4	:= 0
Local nCont		:= 0
Local nValAux	:= 0
Local nBase3	:= 0
Local nINSS3	:= 0
Local nFaixa1	:= 0
Local nFaixa2	:= 0

DEFAULT lGrvRAZRAW := .F.
DEFAULT lCalcResc  := .F.

Static nOrderSRR := RetOrder("SRR","RR_FILIAL+RR_MAT+RR_TIPO3+RR_PERIODO+RR_ROTEIR+RR_SEMANA+RR_PD+RR_CC+RR_ITEM+RR_CLVL+RR_SEQ+DtoS(RR_DATA)")

If cSeqMV > "1" .and. lGrvRAZRAW
	If (nPos := aScan(aEstb,{|x| AllTrim(x[1]) == AllTrim(SRA->RA_FILIAL)})) > 0
		cCnpjAtu := SubStr(aEstb[nPos][2], 1, 8)
	EndIf
	
	SRA->( dbSetOrder(nOrderMULTV) )
	SRA->( dbSeek(SRA->RA_CIC) )

	While SRA->( !Eof() .and. SRA->RA_CIC == cCpf )
		If SRA->RA_FILIAL + SRA->RA_MAT <> cFilMat .and. !(SRA->RA_RESCRAI $ "30/31")
			If (nPos := aScan(aEstb,{|x| AllTrim(x[1]) == AllTrim(SRA->RA_FILIAL)})) > 0
				cCnpj := SubStr(aEstb[nPos][2], 1, 8)
			EndIf
			SRC->( dbSetOrder(1) )//RC_FILIAL+RC_MAT+RC_PD+RC_CC+RC_SEMANA+RC_SEQ
			If SRC->( dbSeek(SRA->RA_FILIAL + SRA->RA_MAT) ) .And. SRC->RC_PERIODO == cPeriodo .And. SRC->RC_SEQMV < cSeqMV
				aAdd( aFilMat, {SRA->RA_FILIAL, SRA->RA_MAT, SRC->RC_SEQMV, cCnpj, SRA->RA_CATEFD} )
			ElseIf lCalcResc //Busca outra rescisão na SRR
				SRR->(DbSetOrder(nOrderSRR))
				If SRR->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + "R"))
					lTemResc := .F.
					While SRR->(!Eof() .and. RR_FILIAL + RR_MAT + RR_TIPO3 == SRA->RA_FILIAL + SRA->RA_MAT + "R")
						If SRR->RR_PERIODO == cPeriodo
							If SRR->RR_PD $ ( aCodfol[13,1] + "/" + aCodfol[14,1] + "/" + aCodfol[221,1] )
								If ( nPos := aScan( aCNPJ, { |x| x[1]+x[3] == cCnpj + SRA->RA_CATEFD } ) ) == 0
									aAdd( aCNPJ, { cCnpj, SRR->RR_VALOR, SRA->RA_CATEFD } )
								Else
									aCNPJ[nPos, 2] += SRR->RR_VALOR
								EndIf
							EndIf
							lTemResc := .T.
						EndIf
						SRR->(DbSkip())
					EndDo
					If lTemResc
						aAdd( aFilMat, {SRA->RA_FILIAL, SRA->RA_MAT, "1", cCnpj, SRA->RA_CATEFD} )
					EndIf
				EndIf
			EndIf
		EndIf 
		SRA->(DbSkip())
	EndDo

	RestArea(aAreaSRA)

	If aScan( aFilMat, { |x| x[4] != cCnpjAtu } ) > 0
		aSort( aFilMat,,, { |x,y| x[3] < y[3] } )
		//O trecho abaixo busca as bases de contribuição de outras raízes de CNPJ, separando por CNPJ e categoria
		For nCont := 1 To Len(aFilMat)
			nValAux	:= 0
			If (nPos := aScan(aEstb,{|x| AllTrim(x[1]) == AllTrim(aFilMat[nCont, 1])})) > 0
				cCnpj := SubStr(aEstb[nPos][2], 1, 8)
			EndIf
			If cCnpjAtu != cCnpj.And. SRC->( dbSeek( aFilMat[nCont, 1] + aFilMat[nCont, 2] ) )
				While SRC->( !EoF() ) .And. SRC->RC_FILIAL+SRC->RC_MAT == aFilMat[nCont, 1] + aFilMat[nCont, 2] .And. SRC->RC_PERIODO == cPeriodo
					If SRC->RC_PD $ (aCodfol[13,1] + "/" + aCodfol[14,1] + "/" + aCodfol[221,1]) .Or. (cTipoRot == "6" .And. SRC->RC_PD $ (aCodfol[19,1] + "/" + aCodfol[20,1]))
						nValAux	+= SRC->RC_VALOR
					EndIf
					SRC->( dbSkip() )
				EndDo
				If nValAux > 0
					If ( nPos := aScan( aCNPJ, { |x| x[1]+x[3] == aFilMat[nCont, 4]+aFilMat[nCont, 5] } ) ) == 0
						aAdd( aCNPJ, { aFilMat[nCont, 4], nValAux, aFilMat[nCont, 5] } )
					Else
						aCNPJ[nPos, 2] += nValAux
					EndIf
				EndIf
			EndIf
		Next nCont

		If cTipoRot == "6"
			cIndFol := "2"
			cPdTot  := aCodfol[019,1]
		Else
			cPdTot  := aCodfol[013,1] + aCodfol[221,1] 
		EndIf

		aEval( aPd, { |x| If(x[1] $ cPdTot .And. x[9] != "D", nBase += x[5], Nil) } )
		aEval( aPd, { |x| If(x[1] $ aCodFol[14,1] + "/" + aCodFol[20,1] .And. x[9] != "D", nBase2 += x[5], Nil) } )
		aEval( aPd, { |x| If(x[1] $ aCodFol[13,1] + "/" + aCodFol[19,1] .And. x[9] != "D", nBase4 += x[5], Nil) } )
		
		If cTipoRot == "9"
			aEval( aPd, { |x| If(x[1] $ aCodFol[064,1] .And. x[9] != "D", nINSS3 += x[5], Nil) } )
			aEval( aPd, { |x| If(x[1] $ aCodFol[288,1] + "/" + aCodFol[1847,1] .And. x[9] != "D", nBase3 += x[5], Nil) } )
		Endif
		
		If nBase2 > 0 .and. nBase > 0 //Somou bases para chegar ao cálculo do INSS
			cIndMv  := "2"
		ElseIf nBase == 0  .and. nBase2 > 0 //Nâo houve desconto de INSS. INSS total descontado de outras empresas.
			cIndMV	:= "3"
		ElseIf nINSS3 == 0  .and. nBase3 > 0  .And. cTipoRot == "9" //TSV
			cIndMV	:= "3"
		ElseIf nBase2 == 0 .and. nBase > 0 .and. nBase4 > 0 .and. aTinss <> NIL .and. Len(aTinss) > 0 //Verifica se mudou de faixa
			for nFaixa1 := 1 to Len(aTinss)
				If nBase < aTinss[nFaixa1,1]
					Exit
				EndIf
			next nFaixa1
			nBase4 := nBase + nBase4
			for nFaixa2 := 1 to Len(aTinss)
				If nBase4 < aTinss[nFaixa2,1]
					Exit
				EndIf
			next nFaixa2
			If nFaixa1 <> nFaixa2
				cIndMv  := "2"
			Endif
		EndIf

		dbSelectArea("RAW")
		RAW->(dbSetOrder(1))//RAW_FILIAL, RAW_MAT, RAW_FOLMES, RAW_TPFOL, RAW_PROCES, RAW_ROTEIR, RAW_SEMANA

		dbSelectArea("RAZ")
		RAZ->(DbSetOrder(1))//RAZ_FILIAL+RAZ_MAT+RAZ_FOLMES+RAZ_TPFOL+RAZ_INSCR

		//O trecho abaixo faz exclusão da RAW/RAZ caso um vínculo de ordem anterior da mesma raiz de CNPJ possua dados para garantir que os dados gravados estejam corretos devido a possibilidade de alterar a ordem de cálculo
		For nCont := 1 To Len(aFilMat)
			If (nPos := aScan(aEstb,{|x| AllTrim(x[1]) == AllTrim(aFilMat[nCont, 1])})) > 0
				cCnpj := SubStr(aEstb[nPos][2], 1, 8)
			EndIf
			If cCnpjAtu == cCnpj
				If RAW->( dbSeek(aFilMat[nCont, 1] + aFilMat[nCont, 2] + cPeriodo + cIndFol) )
					While RAW->( !EoF() ) .And. RAW->RAW_FILIAL+RAW->RAW_MAT+RAW->RAW_FOLMES+RAW->RAW_TPFOL == aFilMat[nCont, 1] + aFilMat[nCont, 2] + cPeriodo + cIndFol
						If RecLock("RAW", .F.)
							RAW->( dbDelete() )
							RAW->( MsUnlock() )
						EndIf
						RAW->( dbSkip() ) 
					EndDo
				EndIf
				If RAZ->( dbSeek(aFilMat[nCont, 1] + aFilMat[nCont, 2] + cPeriodo + cIndFol) )
					While RAZ->( !EoF() ) .And. RAZ->RAZ_FILIAL+RAZ->RAZ_MAT+RAZ->RAZ_FOLMES+RAZ->RAZ_TPFOL == aFilMat[nCont, 1] + aFilMat[nCont, 2] + cPeriodo + cIndFol
						If (nPos := Ascan(aEstb,{|x| AllTrim(x[2]) == AllTrim(RAZ->RAZ_INSCR)})) > 0
							If RecLock("RAZ", .F.)
								RAZ->( dbDelete() )
								RAZ->( MsUnlock() )
							EndIf
						EndIf
						RAZ->( dbSkip() ) 
					EndDo
				EndIf
			EndIf
		Next nCont

		lTemRAW := RAW->(dbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + cIndFol))

		If !lTemRAW
			RecLock("RAW",.T.)
				RAW->RAW_FILIAL	:= SRA->RA_FILIAL
				RAW->RAW_MAT	:= SRA->RA_MAT
				RAW->RAW_FOLMES	:= cPeriodo
				RAW->RAW_TPFOL	:= cIndFol
				RAW->RAW_PROCES	:= cProcesso
				RAW->RAW_ROTEIR	:= cRot
				RAW->RAW_SEMANA	:= cNumPag
				RAW->RAW_TPREC	:= cIndMV
			RAW->(msUnlock())
		ElseIf lTemRAW .and. cCnpjAtu <> cCnpj
			RecLock("RAW",.F.)
				RAW->RAW_FILIAL	:= SRA->RA_FILIAL
				RAW->RAW_MAT	:= SRA->RA_MAT
				RAW->RAW_FOLMES	:= cPeriodo
				RAW->RAW_TPFOL	:= cIndFol
				RAW->RAW_PROCES	:= cProcesso
				RAW->RAW_ROTEIR	:= cRot
				RAW->RAW_SEMANA	:= cNumPag
				RAW->RAW_TPREC	:= cIndMV
			RAW->(msUnlock())
		EndIf

		//O trecho abaixo faz exclusão da RAZ da matrícula atual porque não tem o campo RAZ_CATEG no índice, então exclui tudo primeiro para depois gravar registro(s) novo(s)
		If RAZ->( dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+cPeriodo+cIndFol) )
			While RAZ->( !EoF() ) .And. RAZ->RAZ_FILIAL+RAZ->RAZ_MAT+RAZ->RAZ_FOLMES+RAZ->RAZ_TPFOL == SRA->RA_FILIAL+SRA->RA_MAT+cPeriodo+cIndFol
				If (nPos := Ascan(aEstb,{|x| AllTrim(x[2]) == AllTrim(RAZ->RAZ_INSCR)})) > 0
					If RecLock("RAZ", .F.)
						RAZ->( dbDelete() )
						RAZ->( MsUnlock() )
					EndIf
				EndIf
				RAZ->( dbSkip() ) 
			EndDo
		EndIf

		For nCont := 1 To Len(aCNPJ)
			If (nPos := Ascan(aEstb,{|x| SubStr(AllTrim(x[2]), 1, 8) == AllTrim(aCNPJ[nCont, 1])})) > 0
				cCnpj := aEstb[nPos][2]
			EndIf

			RecLock("RAZ", .T.)
				RAZ->RAZ_VALOR	:= aCNPJ[nCont, 2]
				RAZ->RAZ_FILIAL	:= SRA->RA_FILIAL
				RAZ->RAZ_MAT	:= SRA->RA_MAT
				RAZ->RAZ_FOLMES	:= cPeriodo
				RAZ->RAZ_TPFOL	:= cIndFol
				RAZ->RAZ_INSCR	:= cCnpj	
				RAZ->RAZ_CATEG	:= aCNPJ[nCont, 3]
				RAZ->RAZ_CIC	:= SRA->RA_CIC
				RAZ->RAZ_TPINS	:= Iif(Len(cCnpj) >= 14,"1","2")
			RAZ->(msUnlock())
		Next nCont
	EndIf

	RestArea(aAreaSRA)
	RestArea(aAreaSRC)
	RestArea(aArea)
EndIf

Return .T.

/*/{Protheus.doc} GrvCalc132
//Gravacao do calculo do roteiro 132
@author julio.silva
@since 10/12/2021
/*/
Function GrvCalc132()

    If ( !lDissidio .And. !lCalcFol )

		If lGrvRAZRAW
			fGrvRAZRAW()
		EndIf   	
    
        aEval( aPd , { |X| Grava132(X) } )
    
	EndIf
    
    
    If ( lDissidio .And. !lCalcFol )
    
        GravaDissidio(aPd,aPdOld,,aCodFol)
    
    EndIf	

Return

/*/{Protheus.doc} RHAlphSeq
//Retorna a sequencia numérica correspondente de um alfanumérico 
@author martins.marcio
@since 04/03/2022
/*/
Function RHAlphSeq(cAlfa)

	Local nSeqRet := 0
	Local cStrAux

	DEFAULT cAlfa := ""

	If !Empty(cAlfa)
		cStrAux := Replicate("0", Len(cAlfa)) 
		While !(cStrAux == cAlfa)
			cStrAux := Soma1(cStrAux)
			nSeqRet++	
		EndDo
	EndIf

Return nSeqRet

/*/{Protheus.doc} fCarPdFMS
Carrega as verbas de férias de mês seguinte
@author Allyson Luiz Mesashi
@since 06/04/2022
/*/
Function fCarPdFMS()

Local cTmpAlias := GetNextAlias()
Local cVerbas	:= ""
Local cWhere 	:= "% SRV.RV_INSSFER = '1' AND SRV.RV_CODMSEG <> '   '  %"

BeginSql alias cTmpAlias
	SELECT SRV.RV_COD
	FROM %table:SRV% SRV 
	WHERE SRV.RV_FILIAL = %xfilial:SRV%
		AND %exp:cWhere% 
		AND SRV.%notDel%
EndSql

While !(cTmpAlias)->( Eof() )
	cVerbas += (cTmpAlias)->RV_COD + "/"
	(cTmpAlias)->( dbSkip() )
EndDo

(cTmpAlias)->( dbCloseArea() )

Return cVerbas
