#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEM500.CH"
#INCLUDE "shell.ch"
#INCLUDE "fwcommand.ch"

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ GPEM500  ³ Autor ³ J. Ricardo            ³ Data ³ 12/06/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ GERA ARQUIVO DA RAIS (SR2)                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³PROGRAMADOR ³ DATA   ³CHAMADO/REQ³  MOTIVO DA ALTERA‡„O                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Mohanad     ³06/01/13³194303     ³UnIficação da Folha V12              ³±±
±±³            ³        ³M12RH01    ³                                     ³±±
±±³Christiane V³02/05/14³    TPMJR2 ³ Réplicas P11 para P12               ³±±
±±³Luis Artuso ³04/02/15³	 TRN652 ³ Ajuste para RAIS 2014 Ano calendario³±±
±±³            ³        ³	        ³ 2014.                               ³±±
±±³Renan Borges³27/03/15³    TRUGON ³Ajuste para gerar o arquivo da RAIS  ³±±
±±³            ³        ³           ³com os rendimentos de funcionários   ³±±
±±³            ³        ³           ³que foram reintegrados com novas ma- ³±±
±±³            ³        ³           ³trículas, pois o campo de Reintegra- ³±±
±±³            ³        ³           ³ção da matricula antigapassou a ser  ³±±
±±³            ³        ³           ³preenchido para ter conhecimento de  ³±±
±±³            ³        ³           ³que ela já foi reintegrada.          ³±±
±±³L.Trombini  ³06/04/15³TSAUQY	  	 ³Ajuste para gerar A remuneração RAIS ³±±
±±³            ³        ³      		 ³quando funcionario tem afastamento P ³±±
±±³            ³        ³      		 ³ e a base das verbas com incidencia A³±±
±±³            ³        ³      		 ³maior que a base de FGTS gerada no   ³±±
±±³            ³        ³      		 ³Afastamento                          ³±±
±±³L.Trombini  ³06/04/15³TSAYFO		 ³Ajuste p/ gerar corrigir a geração de³±±
±±³            ³        ³      		 ³movimento na filial atual quando a   ³±±
±±³            ³        ³      		 ³transferencia ocorreu no primeiro do ³±±
±±³            ³        ³      		 ³proximo ano Base, pois estava gerando³±±
±±³            ³        ³      		 ³ registro branco do periodo anterior ³±±
±±³Claudinei S.³15/06/15³TRXRM1     ³Ajuste para gerar o arquivo da RAIS  ³±±
±±³            ³        ³           ³com a data de rescisao, considerando ³±±
±±³            ³        ³           ³os dias de aviso previo.             ³±±
±±³Marcia Moura|23/02/16³TUOODZ     ³ Ajuste para gerar o arquivo da RAIS ³±±
±±³            ³        ³           ³com dt rescisao, considerando os dias³±±
±±³            ³        ³           ³ de av. previo, onde no ano só existe³±±
±±³            ³        ³           ³a data de aviso seja levado o func.  ³±±
±±³Renan Borges³24/02/16³TUMYT1     ³Ajuste caso o campo R2_TIPOADM esteja³±±
±±³            ³        ³           ³com tamanho diferente de 2 não seja  ³±±
±±³            ³        ³           ³apresentada a mensagem de necessidade³±±
±±³            ³        ³           ³de executar o compatibilizador.      ³±±
±±³            ³        ³           ³Ajuste para calcular os dias afasta- ³±±
±±³            ³        ³           ³dos corretamente na geração do arqui-³±±
±±³            ³        ³           ³vo da RAIS.                          ³±±
±±³Marcia Moura|10/03/16³TUSPYJ    ³ Correcao no controle de aviso previo ³±±
±±ºMarcia Moura³18/03/16³TUTTQ6    ³Ajuste para criacao de nova opcao na  º±±
±±º            ³        ³          ³pergunta "projeta aviso previo"       º±±
±±³Marcia Moura|21/03/16³TUUCZ0    ³Ao encontrar funcionaria com afast. de³±±
±±º            ³        ³          ³licença maternidade o programa estava º±±
±±º            ³        ³          ³gerando quantidade de dias com valor  º±±
±±º            ³        ³          ³negativo. O erro foi corrigido        º±±
±±³Joao Balbino³23/03/16³TUULDN	   ³Tratamento para quando houver transfe-³±±
±±³            ³        ³          ³rencia de funcionário para o mesmo CEI³±±
±±³Esther V.   ³08/06/16³TVFY37    ³Incluida validacao de acesso de       ³±±
±±³            ³        ³          ³usuario no processamento das filiais. ³±±
±±³Renan Borges³20/06/16³TUTUYS    ³Ajuste para apresentar afastamentos na³±±
±±³            ³        ³          ³RAIS de funcionários que possuam afas-³±±
±±³            ³        ³          ³tamentos que comecem em um ano e termi³±±
±±³            ³        ³          ³ne no outro ano.                      ³±±
±±³Marcelo F.  ³16/12/16³MRH-3218  ³Compatibilização projeto soyuz(Russia)³±±
±±³Marcia Moura³24/01/17³MRH-5457  ³Controle  Abono Pecuniario superior a ³±±
±±³            ³        ³          ³20 dias trabalhados                   ³±±
±±³WinstonCosta³03/01/19³		   ³Retirada do trecho que trata o AS/400 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GPEM500(lAutomato)

Local aButtons 	:= {}
Local aSR2Area	:= SR2->( GetARea() )
Local bProcesso	:= { |oSelf| GPM500Proc( oSelf ) }

Private aValReal[14]
Private cCadastro := OemToAnsi(STR0001) //"Gera‡„o do Arquivo da R.A.I.S."
Private cSraFilter	:= ""
Private aRetFiltro	:= {}
Private aFilterExp	:= {}
Private cTipoRot := "1"

Private lRobo		:= .F.

Default lAutomato	:= .F.

IF lAutomato
	lRobo           := lAutomato
Endif

//VERIFICA SE FOI ATUALIZADA A ROTINA DA RAIS
If !fRAISChk("Gera510Manu")
	Return
EndIf

//Comunicado sobre a não disponibilização da Rais e Dirf para releases inferiores à 12.1.25
If GetRpoRelease() < "12.1.023" .AND. FindFunction("DirfRaisMsg") .AND. !lRobo
	DirfRaisMsg()
EndIf

Pergunte("GPM500",.F.)

AAdd(aFilterExp , {"FILTRO_ALS" , "SRA"     	, .T.})			 /* Retorne os Filtros que contenham os Alias Abaixo */
AAdd(aFilterExp , {"FILTRO_PRG" , FunName() 	, NIL , NIL   })  /* Que Estejam Definidos para a Função */

AAdd(aButtons,{STR0054,{|oSelf| aRetFiltro := FilterBuildExpr(aFilterExp)}, "BRW_FILTRO.PNG"}) //Filtrar
AAdd(aButtons, { STR0055, {|oSelf| OpenTDN(oSelf)}, "NORMAS.PNG" }) //"Documentação"

If !lRobo
	tNewProcess():New( "GPEM500", cCadastro, bProcesso , STR0002, "GPM500", aButtons, .T., , , .T., .T. )
Else
	eVal(bProcesso)
Endif

RestArea(aSR2Area)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³GPM500Proc³ Autor ³ R.H.                  ³ Data ³ 20/01/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Gera o arquivo SR2 a partir do acumulado - SRD             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM500Proc                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function GPM500Proc(oSelf)
Local cFilAnterior
Local cFilSR2	:= xFilial("SR2")
Local aInfo		:= {}
Local nOpca		:= 0
Local nCntAf
Local nCntMes
Local nMesIni
Local nMesFim
Local nNroAfas
Local cIndCond
Local cArqNtx
Local nIndex
Local lTemFgts
Local nCntCod
Local nForC
Local cAliasSRD 	:= "SRD" 	// Alias da Query
Local lQuery    	:= .F.    	// Indica se a query foi executada
Local cSrvRais		:= ""     	// Contem todas as incidencias possiveis de RAIS para a verba
Local cMemVar		:= ""		// Variavel auxiliar para a criacao de variveis acumuladores das opcoes de RAIS
Local cCodRais		:= ""		// String com as letras da incidencia de RAIS separadas por '-'.
Local nCodRais		:= 0 		// Quantidade de elementos do aCodRais
Local nPosLetra		:= 0   		// Posicao do elemento correspondente a letra de incidencia da RAIS
Local nX			:= 0
Local nY			:= 0
Local nHoras		:= 0 		// Variavel para conversao de dias em horas
Local nQtde			:= 0		// Variavel para verIficacao da qtde de meses informada no campo horas ou valor.
Local nFator		:= 1		// Fator para alteracao do valor original da verba.
Local nFatorVerb	:= 1		// Fator para alteracao do valor original da verba.
Local lContrib		:= .F.		// VerIfica se a verba eh algum tipo de contribuicao (provavelmente eh uma verba de desconto)
Local lVerbDesc		:= .F.		// Indica que a veba eh de desconto
Local nPos			:= 0
Local aTotHoras		:= {}
Local aTotal		:= {}
Local nIdade		:= 0
Local nPosTot		:= 0
Local lDemComp  	:= .F.	//Trata variaveis complementares
Local cProjAB		:= "" 	// se "S" significa que a rescisao foi em ano anterior e projetado neste ano
							// se "N" significa que demissao este ano e projecao proximo ano
Local lProc := .T.

Local cQuery    	:= "" 		//Expressao da Query
Local aStruSRD  	:= {}      //Estrutura da Query
Local nPont
Local lGestPubl := IIF(ExistFunc("fUsaGFP"),fUsaGFP(),.F.)

Local cMesAnt		:= ""
Local aAuxDiss		:= {}
Local nCont			:= 0
Local nContAux		:= 0

Local aOldArea		:= GetArea()
Local cRpoRel		:= GetRpoRelease()
Local cRotOrd		:= ""
Local cRotAut		:= ""
Local cRot131		:= ""
Local cRot132		:= ""
Local aOfusca		:= If(FindFunction('ChkOfusca'), ChkOfusca(), { .T., .F. }) //[2]Ofuscamento
Local aFldRel		:= If(aOfusca[2], FwProtectedDataUtil():UsrNoAccessFieldsInList( {"RA_NOME"} ), {})
Local lOfusca		:= Len(aFldRel) > 0
Local nMsPgDif13	:= 0

Private aLog			:= {}
Private aMensais						// Array com os valores mensais da RAIS (Rendimentos, 1a parc, 2a parc,...)
Private aHoras
Private cCgc			:= Space(14)
Private nMesPD		:= 0
Private nMesPg2a		:= nMesPg1a := 0
Private nVComiss		:= 0
Private nAnt13Sl		:= 0
Private aCodFol		:= {}
Private aAfast 		:= {}
Private lGerarCEI,lSI3_Tipo
Private cAliasCC		:= "CTT"
Private cPrefixCC 	:= (PrefixoCpo(cAliasCC) + "_")
Private cCatFunc		:= ""
Private cFuncao		:= ""
Private nSalario		:= 0
Private nSaldia	:= 0
//TRATAMENTO DE RESCISAO
Private cCodResc		:="DEFGHIJK"   	//-- 'Letras' para rescisao
Private aCodRais  	:= {} 		// Array onde cada elemento corresponde a uma opcao ('Letra') de Incidencia de RAIS
Private aRetRais  	:= {} 		// Array com o tipo de retorno para cada opcao ('Letra') de Incidencia de RAIS
Private dReintegra	:= ctod("//")
Private cNome		:= ""
Private lDiasAv		:= .F.
Private dDemiss	:= ctod("//")
Private dProj	:= ctod("//")
Private aIncRes		:= {}
Private nPercFgts	:= 0.00
Private cRescrais	:= ""
Private cAfasfgts	:= ""
Private Cod_Am		:= ""
Private nSalMin		:= 0
Private lPosHoParc	:= .T.
Private lPosTpJor	:= .T.
Private lProjPar13  := .F.

// PARAMETROS
// MV_PAR01        //  Filial De
// MV_PAR02        //  Filial Ate
// MV_PAR03        //  Matricula De
// MV_PAR04        //  Matricula Ate
// MV_PAR05        //  Ano Base
// MV_PAR06        //  Centralizar as Filiais nesta Filial
// MV_PAR07        //  Gerar Por CEI  (Nao/Sim)
// MV_PAR08        //  Verbas de Comissao
// MV_PAR09        //  Continuacao das Verbas de Comissao
// MV_PAR10        //  Comissao com sal.zero (med.remuneraçao/med verbas informadas)
// MV_PAR11        //  Considera media das verbas de comissao p/ compor o salario, para todas as categorias
// MV_PAR12        //  Para demissao considera data projetada
cFilDe    := mv_par01
cFilAte   := mv_par02
cMatDe    := mv_par03
cMatAte   := mv_par04
nAnoBase  := mv_par05
cFilCent  := mv_par06
cGeraCei  := mv_par07
cCodigos  := AllTrim(mv_par08)
cCodigos  += AllTrim(mv_par09)
nTipMedi  := mv_par10
cVComiss  := ""
lComissao := If(mv_par11 == Nil .Or. mv_par11 == 1, .F., .T.)
lProjDemi := If( mv_par12 == Nil .Or. mv_par12 == 3, .F., .T. )
lProjPar13:= If( mv_par12 == 4, .T., .F. ) //projeta 13 tambem
lProjPar  := If( mv_par12 == 1 .Or. mv_par12 == 4 , .T., .F. )


SM0->( dbSeek( cEmpant + cFilAnt ) )
If StrZero( nAnoBase, 4 ) >= "2017" .And. cRpoRel < "12.1.016" .And. ( !ExistFunc( "RhContExt" ) .Or. !RhContExt( SM0->M0_CGC ) )
	Aviso( STR0057, STR0056, { "Ok" }, , )
	RestArea( aOldArea )
	Return
EndIf

//PREPARA VARIAVEL COM CODIGOS DE COMISSAO INFORMADOS
If !Empty(cCodigos)
   For nForC := 1 To Len(cCodigos) Step 3
      cVComiss += Substr(cCodigos,nForC,3)
      If Len(cCodigos) > (nForC + 3)
         cVComiss += ","
      EndIf
   Next nForC
EndIf
//ANO BASE UTILIZADO PARA MONTAGEM DA QUERY NO ARQUIVO SRD
Private cAnoBase := STRZERO(nAnoBase,4)
Private dPriDiaAno := CTOD("01/01/"+cAnoBase,"DDMMYY")
Private dUltDiaAno := CTOD("31/12/"+cAnoBase,"DDMMYY")
Private cAnoBase1 := STRZERO(nAnoBase-1,4)

//PRESERVAR CNPJ DE TODAS AS FILIAIS DO SIGAMAT
Private aCnpjFil := {}

FSMOQQ(@aCnpjFil)

//OBTEM AS OPCOES DE RAIS PARA AS VERBAS E A QTDE DE ELEMENTOS
GP040LoadRAIS(NIL, NIL, @cCodRais, @aCodRais, @aRetRais)
nCodRais	:= Len(aCodRais)

//CRIA POSICAO DAS VARIAVEIS MENSAIS DA RAIS
For nX:=1 To (nCodRais * 2)
    cLetra				:= Substr(cCodRais,nX,1)
    If cLetra == "-"
       Loop
    EndIf
   	//CRIA A VARIAVEL ACUMULADORA DA OPCAO 'LETRA' DA RAIS
	cMemVar := ("nPos_"+cLetra)
	SetMemVar(cMemVar , (( (At(cLetra,cCodRais) - 1) /2) + 1) , .T.)
Next nX

dbSelectArea(cAliasCC)
lGerarCEI := If(cGeraCei == 2 .And. FieldPos(cPrefixCC + "CEI") # 0, .T., .F.)
lSI3_Tipo := If(lGerarCEI     .And. FieldPos(cPrefixCC + "TIPO") # 0, .T., .F.)

dbSelectArea("SRA")
lPosHoParc	:= !( SRA->( ColumnPos( "RA_HOPARC" ) ) == 0 )
lPosTpJor	:= !( SRA->( ColumnPos( "RA_TPJORNA" ) ) == 0 )

dbSelectArea("SR2")
SR2->(DbsetOrder(6))    	// R2_ANOBASE+R2_CGC+R2_CEI+R2_PIS

//CARREGA OS FILTROS
cSraFilter	:= GpFltAlsGet(aRetFiltro, "SRA")

If (SR2->(Dbseek(cAnoBase)))
	//PARA TOP, ABRE COMO QUERY
	lQuery:=	.T.

    //ELIMINA ITENS DA RAIS
	fZapTop("RCU", cFilDe, cFilAte, cMatDe, cMatAte, ("ANO ='"+cAnoBase+"'"), cSraFilter)

	//ELIMINA CABECALHO DA RAIS
	fZapTop("SR2", cFilDe, cFilAte, cMatDe, cMatAte, ("ANOBASE ='"+cAnoBase+"'"), cSraFilter)

	//CASO NAO TENHA SIDO ABERTA QUERY (CODBASE OU TOP)
	If !lQuery
		If !fZapCodeBase(cFilDe, cFilAte, cMatDe, cMatAte, cAnoBase)
			Return
		EndIf
    EndIf
EndIf

//ALTERNA PARA INDICE PELA DATA DE ADMISSAO
dbSelectArea("SR2")
dbSetOrder(4)  // R2_FILIAL+R2_ANOBASE+R2_CEI+R2_MAT+DTOS(R2_ADMISSA)
DbGoTop()

//POSICIONA PONTEIRO
cFilAnterior := replicate("!",FWGETTAMFILIAL)

dbSelectArea("SRA")
dbSetOrder(1)
dbSeek(cFilDe + cMatDe, .T.)

If !lRobo
	oSelf:SaveLog(STR0001+" - "+STR0052) //#"Início do processamento"
	oSelf:SetRegua1(SRA->(RecCount()))
Endif

While !Eof() .And. SRA->RA_FILIAL + SRA->RA_MAT <= cFilAte + cMatAte

	//APLICAÇÃO DO FILTRO NA TABELA SRA
	If !Empty(cSraFilter) .Or. !(SRA->RA_FILIAL $ fValidFil())
 		If !(&(cSraFilter)) .Or. !(SRA->RA_FILIAL $ fValidFil())
			SRA->(dbSkip())
			Loop
 		EndIf
 	EndIf

	If	Type("SRA->RA_FECREI") # "U"
		dReintegra:= SRA->RA_FECREI
	EndIf

	//DEFINE QUAL CAMPO SERÁ RESPONSÁVEL PELO NOME
	cNome := If( lOfusca, Replicate('*',15), SRA->RA_NOME )

	//FILTRA MATRICULA DE FUNCIONARIO CONFORME PARAMETROS
	If !(SRA->((RA_MAT >= cMatDe) .and. (RA_MAT <= cMatAte)))
		dbSelectArea( "SRA" )
		SRA->(dbSkip())
		Loop
	EndIf

	// controle para aviso previo indenizado
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Controle de aviso previo indenizado              		     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lDiasAv := .F.
	dDesl := ctod("//")
  	dProj	:= ctod("//")

	If Year(SRA->RA_DEMISSA) == nAnoBase .OR. Year(SRA->RA_DEMISSA + 90) == nAnoBase
		dDesl := SRA->RA_DEMISSA
		if lProjDemi //Respondeu SIM a pergunta
			If !Empty(SRA->RA_DEMISSA)
				if SRG->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT) )
					If fIncRes(SRA->RA_FILIAL,SRG->RG_TIPORES,@aIncRes,@nPercFgts,@cRescrais,@cAfasfgts,@Cod_Am)
						If aIncRes[02] $ "I/A"
							dProj	:= SRA->RA_DEMISSA+SRG->RG_DAVISO
							if lProjPar  // projecao parcial, somente as verbas rescisorias
								dDesl := SRA->RA_DEMISSA
							else
								dDesl := SRA->RA_DEMISSA+SRG->RG_DAVISO
							endif
						Elseif (aIncRes[02] $ "T/B")
							dProj	:= If(Empty(SRG->RG_DTPROAV),SRA->RA_DEMISSA,SRG->RG_DTPROAV) //engloba misto ou somente trabalhados
							if lProjPar  // projecao parcial, somente as verbas rescisorias
								dDesl := SRA->RA_DEMISSA
							else
								dDesl := SRA->RA_DEMISSA+SRG->RG_DAVIND //para aviso trabalhado, RA_DEMISSA já tem a data projetada, apenas os dias indenizados não estão englobados
							endif
						Else //qualquer outro tipo de demissao
							dProj	:= If(Empty(SRG->RG_DTPROAV),SRA->RA_DEMISSA,SRG->RG_DTPROAV)
						Endif
						lDiasAv := .T.
					Endif
				Endif
			Endif
	    Endif

	Endif

	//FUNCIONÁRIOS DEMITIDOS ANTERIORMENTE AO ANO-BASE E FUNCIONÁRIOS ADMITIDOS POSTERIORMENTE AO ANO-BASE TEM QUE SER DESCONSIDERADOS

	if !empty(dProj)
		If ( !Empty(dProj) .And. Year(dProj) < nAnoBase) .Or. (Year(SRA->RA_ADMISSA) > nAnoBase)
			dbSelectArea( "SRA" )
			dbSkip()
			Loop
		Endif
	Else
		If ( !Empty(dDesl) .And. Year(dDesl) < nAnoBase) .Or. (Year(SRA->RA_ADMISSA) > nAnoBase)
			dbSelectArea( "SRA" )
			dbSkip()
			Loop
		Endif
    Endif

	If SRA->RA_FILIAL # cFilAnterior
		Sal_Min(@nSalMin,cAnoBase+"12",SRA->RA_FILIAL)
		cFilAnterior := SRA->RA_FILIAL
		cRotOrd	:= ""
		cRotAut	:= ""
		cRot131	:= ""
		cRot132	:= ""
		//CARREGA VARIAVEIS CODIGOS DA FOLHA
		If !Fp_CodFol(@aCodFol,cFilAnterior)
			Exit
		EndIf
		If !fInfo(@aInfo,cFilAnterior)
			Exit
		EndIf

		FIncrRais(aInfo,cFilAnterior,@cCgc)

		aEval( fGetRotTipo('1') , { |X| cRotOrd  += X+"," } )
		aEval( fGetRotTipo('7') , { |X| cRotOrd  += X+"," } )
		cRotOrd:= StrTran(StrTran(FormatIn(Substr(cRotOrd		,1,len(cRotOrd)-1)	,","),')',"" ),'(','' )
		cRotAut := fGetCalcRot( "9" )
		aEval( fGetRotTipo('5') , { |X| cRot131  += X+"," } )
		cRot131:= StrTran(StrTran(FormatIn(Substr(cRot131		,1,len(cRot131)-1)	,","),')',"" ),'(','' )
		aEval( fGetRotTipo('6') , { |X| cRot132  += X+"," } )
		cRot132:= StrTran(StrTran(FormatIn(Substr(cRot132		,1,len(cRot132)-1)	,","),')',"" ),'(','' )
	EndIf

	If !lRobo
		oSelf:IncRegua1(STR0053+" : "+SRA->RA_FILIAL+" - "+SRA->RA_MAT+" - "+cNome) //"Funcionário"
	Endif

	dbSelectArea("SRA")
	nVComiss 	:= 0
	nAnt13Sl 	:= 0
	nMesPg2a 	:= 0
	nMesPg1a 	:= 0
	nMsPgDif13  := 0

	//ARRAY PARA DADOS MENSAIS CONFORME OPCOES DE RAIS PARA A VERBA
	aMensais := Array(nCodRais,14)
	aHoras := Array(nCodRais,14)
	//INICIALIZA OS ELEMENTOS DE TODAS AS DIMENSOES DO AMENSAIS
	aEval(aMensais, {|uArr, nZera|  aFill(aMensais[nZera], 0)})
	aEval(aHoras, {|uArr, nZera|  aFill(aHoras[nZera], 0)})

	//DESCONSIDERA AUTONOMO, ESTAGIARIO(MENSALISTA/HORISTA), CARGOS ELETIVOS (AGENTE PUBLICO, PREFEITO, VICE-PREFEITO) OU FUNC. INATIVO
	If SRA->RA_CATFUNC $ "A,E,G,2,4,5,6,7,8,9" .OR. SRA->RA_SITFOLH == "I"
		dbSelectArea( "SRA" )
		dbSkip()
		Loop
	EndIf

	//SE FOR PRO-LABORE, VERIfICA SE TEM FGTS
	If SRA->RA_CATFUNC == "P"
		lTemFgts := .F.
		dbSelectArea("SRD")
		For nCntCod := 1 To 13
			If dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+cAnoBase+StrZero(nCntCod,2)+aCodFol[18,1])
				lTemFgts := .T.
				Exit
			EndIf
		Next nCntCod
		dbSelectArea("SRA")
		If !lTemFgts
			dbSkip()
			Loop
		EndIf
	EndIf

	If Empty(SRA->RA_CIC)
		AADD(aLog,  {	"CPF",;
						SRA->RA_FILIAL,;
						SRA->RA_MAT,;
						cNome,;
						SRA->RA_NASC,;
						SRA->RA_VIEMRAI})
		dbSkip()
		Loop
	EndIf

		/*	FONTE: RAIS_2011_WEB.PDF, CONF. NOTAS DO ITEM C) VINCULO EMPREGATICIO:
		I - O APRENDIZ DEVE SER MAIOR DE 14 ANOS E MENOR DE 24 ANOS, NOS TERMOS
			DO ART. 428 DA CLT, REGULAMENTADO PELO DECRETO Nº 5.598, DE 1º DE DEZEMBRO DE 2005.
		II - O MENOR DE 16 QUE NÃO SEJA APRENDIZ, SOMENTE DEVE SER DECLARADO
			NA RAIS SE EXISTIR ALVARÁ JUDICIAL AUTORIZANDO O SEU TRABALHO.	*/
	nIdade := (nAnoBase - Year(SRA->RA_NASC))
	If SRA->RA_VIEMRAI <> "55" .And. nIdade < 16 // VerIfica se e' Aprendiz
		AADD(aLog,  {	STR0049				,;    //"APRENDIZ"
						SRA->RA_FILIAL	,;
						SRA->RA_MAT	,;
						cNome,;
						SRA->RA_NASC,;
						SRA->RA_VIEMRAI})
	EndIf

	//OBTEM A REAL CATEGORIA DO FUNC. NO ANO BASE
	cCatFunc	:= SRA->RA_CATFUNC
	cFuncao		:= SRA->RA_CODFUNC
	nSalario	:= SRA->RA_SALARIO

	fCatRais() //RETORNA INFORMACOES DE SALARIO CONFORME CATEGORIA

	If cCatFunc $ "A,E,G" //DESCONSIDERA AUTONOMO, ESTAG.(MENSALISTA/HOR.) NO ANO BASE
		dbSelectArea("SRA")
		dbSkip()
		Loop
	EndIf

	//BUSCA OS AFASTAMENTOS DO FUNCIONARIO NO ANO BASE - O*Q*R
	//ACIDENTE DE TRABALHO - LICENCA GESTANTE - 1=SERVICO MILITAR 6=ADOCAO (=MATERNIDADE)
	aAfast := {}
	fRetAfas(dPriDiaAno, dUltDiaAno,,,,"F*O*P*Q*R*X*1*2*6*7*B",@aAfast,,.F.,.T.)

	If Len(aAfast) > 0 .And. aAfast[Len(aAfast)][5] == "1" .And. Empty(aAfast[Len(aAfast)][4]) .And. Year(aAfast[Len(aAfast)][3]) < nAnoBase//Aposentadoria por Invalidez
		dbSelectArea( "SRA" )
		dbSkip()
		Loop
	EndIf

	DbSelectArea("SRD")

	//EFETUA UMA QUERY NO ACUMULADO - SRD
	lQuery := .F.
	If lDiasAv .and. nAnoBase ==  year( SRA->RA_DEMISSA )+1 .and. year( SRA->RA_DEMISSA )<>year(dProj) // demissao esta no ano anterior ao ano da RAIS, mas a projecao esta no ano base da RAIS
		cQuery1 := "(SRD.RD_DATARQ LIKE '"+cAnoBase1+"%' OR "
		cQuery1 += "SRD.RD_DATARQ LIKE '"+cAnoBase+"%' ) AND "
	Else
		cQuery1 := "SRD.RD_DATARQ LIKE '"+cAnoBase+"%' AND "
	Endif

	//PARA TOP, ABRE COMO QUERY
	cAliasSRD := "QSRD"
	aStruSRD  := If(Empty(aStruSRD),SRD->(dbStruct()),aStruSRD)

	//DISTINCT SERVE PARA CORRIGIR DUPLICIDADE DE FERIAS QUANDO TEM DUAS FERIAS CALCULADAS NO MESMO PERIODO
	cQuery := "SELECT DISTINCT (SRR.RR_PD) , SRD.*"
	cQuery += "  FROM " + RetSqlName("SRD") + " SRD "
	cQuery += "  LEFT JOIN " + RetSqlName("SRR") + " SRR "
	cQuery += "    ON SRR.RR_FILIAL  = SRD.RD_FILIAL"
	cQuery += "   AND SRR.RR_MAT     = SRD.RD_MAT"
	cQuery += "   AND SRR.RR_TIPO3   = 'F'"
	cQuery += "   AND SRR.RR_PERIODO = SRD.RD_PERIODO"
	cQuery += "   AND SRR.RR_PD      = SRD.RD_PD"
	cQuery += "   AND SRR.D_E_L_E_T_ = ' ' "
	cQuery += " WHERE SRD.RD_FILIAL = '" + SRA->RA_FILIAL + "' "
	cQuery += "   AND SRD.RD_MAT    = '" + SRA->RA_MAT    + "' "
	cQuery += "   AND SRD.RD_ROTEIR IN (" + cRotOrd +",'"+  cRotAut + "',"+ cRot132 +","+ cRot131 + ") AND "
	cQuery += cQuery1
	cQuery += "       SRD.D_E_L_E_T_=' ' "
	cQuery += "ORDER BY "+SqlOrder(SRD->(IndexKey()))

	cQuery := ChangeQuery(cQuery)

 	If (lQuery := MsOpenDbf(.T.,"TOPCONN",TcGenQry(Nil,Nil,cQuery),cAliasSRD,.T.,.T.))
		For nX := 1 To Len(aStruSRD)
			If (aStruSRD[nX][2] <> "C")
				TcSetField(cAliasSRD,aStruSRD[nX][1],aStruSRD[nX][2],aStruSRD[nX][3],aStruSRD[nX][4])
			EndIf
		Next nX
	EndIf

	//CASO NAO TENHA SIDO ABERTA QUERY (CODBASE OU TOP)
	If !lQuery
		dbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cAnoBase)
	EndIf

	dbSelectArea(cAliasSRD)

	// CASO NÃO EXISTA INFORMAÇÃO PARA O FUNCIONARIO NA SRD DESCONSIDERA
	// O REGISTRO.
	If (cAliasSRD)->(Eof())
		(cAliasSRD)->(dbCloseArea())		
		dbSelectArea("SRA")
		dbSkip()
		Loop
	EndIf

	While (cAliasSRD)->(!Eof()) .And. ((cAliasSRD)->RD_FILIAL + (cAliasSRD)->RD_MAT + Left((cAliasSRD)->RD_DATARQ,4) = SRA->RA_FILIAL + SRA->RA_MAT + cAnoBase) .or.;
	((cAliasSRD)->RD_FILIAL + (cAliasSRD)->RD_MAT + Left((cAliasSRD)->RD_DATARQ,4) = SRA->RA_FILIAL + SRA->RA_MAT + cAnoBase1 .and. lDiasAv )
		//DESPREzA OS LANCTOS DE TRANSFERENCIAS DE OUTRAS EMPRESAS
		If (cAliasSRD)->RD_EMPRESA # cEmpAnt .And. !Empty((cAliasSRD)->RD_EMPRESA) .AND. ;
		!((cAliasSRD)->RD_PD == aCodFol[026,1] .And. ((cAliasSRD)->RD_ROTEIR $ cRot131+"/"+ cRotOrd))
			(cAliasSRD)->(dbSkip())
			Loop
		EndIf
		//POSICIONA NO ARQUIVO SRV PARA VERIFICACAO DO CAMPO RAIS
		PosSrv((cAliasSRD)->RD_PD,(cAliasSRD)->RD_FILIAL)
		//'HIGIENIZA' O CAMPO RV_RAIS PARA SOMENTE CONTER AS LETRAS
		cSrvRais := STRTRAN(SRV->RV_RAIS, "*", "")
		cSrvRais := Alltrim(STRTRAN(cSrvRais, "-", ""))

		// Caso o valor do Abono Pecuniario seja superior a 20 dias de salario entao deve entrar como rendimento salario
		if SRV->RV_CODFOL == "0074"  .and. SRA->RA_SALARIO >0 .And. fPertenceSRV("N ", cSrvRais)
			fSalario(,,@nSalDia,,"A",(cAliasSRD)->RD_DATARQ)
			if nSaldia > 0
				if (cAliasSRD)->RD_VALOR > (nSalDia * 20)
					 cSrvRais :="A"
				endif
			Endif
		Endif

		nMesPD := Val(Right((cAliasSRD)->RD_DATARQ,2))

		dDemiss := dDesl

		// Quando estiver processando as verbas rescisorias, fica valendo a data projetada
        If lProjpar .and. lDiasAv .and. fPertenceSRV("DEFGHIJKS", cSrvRais)
       		dDemiss := dProj
		EndIf

		If lProjpar13 .And. ( fPertenceSRV("BC", cSrvRais) .And. !Empty(SRA->RA_DEMISSA))
			dDemiss := dProj
        EndIf

       if nMesPD >=  val(STRZERO( Month( SRA->RA_DEMISSA ),2 ) )
        	if year(dDemiss) == nAnobase
				nMesPD := Val(substr(dtoc(dDemiss),4,2))
			Endif
       Else
			If lDiasAv .and. year(dDemiss) <  year( SRA->RA_DEMISSA )
				nMesPD := 0
			Endif
		Endif

		If lDiasAv .and. year( SRA->RA_DEMISSA ) < year(dDemiss) .and. year(dDemiss) == nAnobase // demitido 2014, projetado 2015 e ano base RAIS 2015
			if val(left((cAliasSRD)->RD_DATARQ,4)+Right((cAliasSRD)->RD_DATARQ,2))>= val(strzero(year(SRA->RA_DEMISSA))+STRZERO( Month( SRA->RA_DEMISSA ),2 ))
				nMesPD := Val(substr(dtoc(dDemiss),4,2))
			Else
				nMesPD := 0
			Endif
		Endif

		If lDiasAv .and. year( SRA->RA_DEMISSA ) < year(dDemiss) .and. year(dDemiss) > nAnobase // demitido 2015, projetado 2016 e ano base RAIS 2015
			if val(left((cAliasSRD)->RD_DATARQ,4)+Right((cAliasSRD)->RD_DATARQ,2))>= val(strzero(year(SRA->RA_DEMISSA))+STRZERO( Month( SRA->RA_DEMISSA ),2 ))
				nMesPD := 0
			Endif
		Endif

		//RETIRAMOS AS INCIDENCIAS DE RAIS PARA RESCISAO SE AS VERBAS
		//FORAM UTILIZADAS ANTES DA DEMISSAO DO TRABALHADOR OU SE O
		//FUNCIONARIO NAO FOI DEMITIDO OU SE FUNCIONARIO FOI REINTEGRADO
 		If Empty(dDemiss) .OR. 	(!Empty(dDemiss) .And. STRZERO(YEAR(dDemiss),4) > cAnoBase ) .Or. ;
 		 (( !Empty(SRA->RA_DEMISSA) .And. STRZERO(YEAR(SRA->RA_DEMISSA),4) == Left((cAliasSRD)->RD_DATARQ,4) .And. ( StrZero( Year( dDemiss ), 4 ) + StrZero( nMesPD, 2 ) ) < AnoMes( SRA->RA_DEMISSA ) ) )
			cSrvRais := Alltrim(STRTRAN(cSrvRais, "D", ""))	//Férias Indenizadas
			cSrvRais := Alltrim(STRTRAN(cSrvRais, "E", ""))	//Horas Extras do Banco de Horas pagas na Rescisão
			cSrvRais := Alltrim(STRTRAN(cSrvRais, "F", ""))	//Qtde de meses de referencia do valor pago a titulo de banco de horas
			cSrvRais := Alltrim(STRTRAN(cSrvRais, "G", ""))	//Acréscimo Salarial pago na Rescisão
			cSrvRais := Alltrim(STRTRAN(cSrvRais, "H", ""))	//Qtde de meses de ref. ao valor do acréscimo salarial
			cSrvRais := Alltrim(STRTRAN(cSrvRais, "I", ""))	//Outros acréscimos pagos em Rescisão
			cSrvRais := Alltrim(STRTRAN(cSrvRais, "J", ""))	//Qtde de meses de ref. ao valor de outros acréscimo salarial
			cSrvRais := Alltrim(STRTRAN(cSrvRais, "K", ""))	//Valor da Multa FGTS
			cSrvRais := Alltrim(STRTRAN(cSrvRais, "S", ""))	//Aviso Prévio Indenizado
		EndIf


		//RETIRAMOS A INCIDENCIA DE RAIS P/HORAS EFETIVAS SE A VERBA LIDA FOI UTILIZADA DEPOIS DA DEMISSAO DO TRABALHADOR
 		If 	!Empty(dDemiss) .And. ;
	 		(;
	 		   	( ( STRZERO( YEAR ( dDemiss ),4 ) + STRZERO( Month( dDemiss ),2 ) ) < (cAliasSRD)->RD_DATARQ))
			cSrvRais := Alltrim(STRTRAN(cSrvRais, "R", ""))	//Horas Efetivamente Trabalhadas
		EndIf
		//NO MES DA DEMISSAO DO FUNCIONARIO (OU POSTERIOR) ANALISAR VERBAS\VALORES PAGAS NA RESCISAO
		lDemComp := .F.
		// Se data projeta ou proprio desligamento, analisar as verbas rescisorias
		if empty(dProj)
			If ( !Empty(dDemiss) .And. Year(dDemiss) == nAnoBase ) .And. ;
			   ((( STRZERO( YEAR ( dDemiss ),4 ) + STRZERO( Month( dDemiss ),2 ) ) <= (cAliasSRD)->RD_DATARQ ) )
					lDemComp := .T.
			Endif
		Else
			If ( !Empty(dProj) .And. Year(dProj) == nAnoBase ) .And. ;
			   ((( STRZERO( YEAR ( sra->ra_demissa ),4 ) + STRZERO( Month( sra->ra_demissa ),2 ) ) <= (cAliasSRD)->RD_DATARQ ) )
					lDemComp := .T.
			Endif
		Endif


		If lDemComp
			//QDO VERBA TIVER INCIDENCIA A (RENDIMENTOS) E E (HORAS EXTRAS DO BANCO DE HORAS PAGAS NA
			//RESCISAO, DEIXAR SOMENTE A INCIDENCIA "E" DO BANCO DE HORAS. VLR NAO DEVERA CONSTAR DOS RENDIMENTOS
 			If 	(fPertenceSRV("A", cSrvRais) .and. fPertenceSRV("E", cSrvRais))
				cSrvRais := "E" 	//Horas Efetivamente Trabalhadas
			EndIf
			//QDO VERBA TIVER INCIDENCIA A (RENDIMENTOS) E G (ACRESCIMO SALARIAL PAGO NA RESCISAO, DEIXAR SOMENTE
			//A INCIDENCIA "G" VLR NAO DEVERA CONSTAR DOS RENDIMENTOS DO MES
 			If 	(fPertenceSRV("A", cSrvRais) .and. fPertenceSRV("G", cSrvRais))
				cSrvRais := "G" 	//Horas Efetivamente Trabalhadas
			EndIf
			//QDO VERBA TIVER INCIDENCIA A (RENDIMENTOS) E I (OUTROS ACRESCIMOS PAGOS EM RESCISAO, DEIXAR
			//SOMENTE INCIDENCIA "I" VLR NAO DEVERA CONSTAR DOS RENDIMENTOS DO MES
 			If 	(fPertenceSRV("A", cSrvRais) .and. fPertenceSRV("I", cSrvRais))
				cSrvRais := "I" 	//Horas Efetivamente Trabalhadas
			EndIf
		EndIf

		//aqui vou inibir a geracao de verbas que nao sao rescisorias, se a demissao tiver ocorrido
		// ano ano anterior, porque nesse ano so posso levar as rescisorias
		if lProjpar .and. lDiasAv .and. year(SRA->RA_DEMISSA) < nAnobase
        	if !fPertenceSRV("DEFGHIJKS", cSrvRais)
  				If lProjpar13
	  				If !( fPertenceSRV("BC", cSrvRais) .And. (anomes(dProj) <> anomes(SRA->RA_DEMISSA)) )
		  				if val(left((cAliasSRD)->RD_DATARQ,4)+Right((cAliasSRD)->RD_DATARQ,2))< val(strzero(year(dProj))+STRZERO( Month( dProj ),2 ))
					 		nMesPD := 0
						Endif
					EndIf
				Else
					If val(left((cAliasSRD)->RD_DATARQ,4)+Right((cAliasSRD)->RD_DATARQ,2))< val(strzero(year(dProj))+STRZERO( Month( dProj ),2 ))
				 		nMesPD := 0
					Endif
				EndIf
			Endif
		endif

		//VERIFICA SE A VERBA DEVE SER PROCESSADA POIS CASO SEJA DEMISSAO COM AVISO PROJETADO, E O AVISO ESTA PARA
		//PROXIMO ANO, SOMENTE VERBAS QUE SAO DE RESCISÃO DEVEM SER PROCESSADAS

		lProc := .T. //processa verbas de rescisao
		IF nMesPD == 0
			lProc := .F. //processa verbas de rescisao
		ENDIF


		//VERIfICA SE A VERBA EH DE DESCONTO
		lVerbDesc	:= (PosSrv((cAliasSRD)->RD_PD,(cAliasSRD)->RD_FILIAL,"RV_TIPOCOD") == "2")
		//TRATA O FATOR DE CALCULO DAS VERBAS CONFORME ORIGEM DAS MESMAS
		If lVerbDesc  //SE DESCONTO
		   nFatorVerb	:= -1
		Else
		   nFatorVerb	:= +1
		EndIf
		//OBTEM O TOTAL DAS VERBAS PARA AS DEMAIS OPCOES DA RAIS
		cSrvRais := If(Empty(cSrvRais), Space(1),  cSrvRais)      	//GARANTE PELO MENOS UM ESPACO PARA TESTES POSTERIORES
		If !fPertenceSRV("N ", cSrvRais) .and. lProc
			For nX:=1 To Len(cSrvRais)
			    cLetra   := Substr(cSrvRais,nX,1)
			    nPosLetra:= (( (At(cLetra, cCodRais) - 1) /2) + 1)
				//INICIALIZA COM O FATOR DE ORIGEM DA VERBA (PROVENTO SOMA (+1)  E DESCONTO SUBTRAI (-1))
			   	nFator := nFatorVerb

				If "A" == cLetra .And. (cAliasSRD)->RD_PD $ ( aCodFol[224,1] + "*" + aCodFol[226,1] + "*" + aCodFol[227,1] + "*" + aCodFol[228,1] )//ferias em dobro
					If (cAliasSRD)->RD_TIPO2 == "K"
						nFator /= 2
					ElseIf (cAliasSRD)->RD_TIPO2 == "G"
						nFator := 0
					EndIf
				EndIf

				//NAO CONSIDERAR MOVIMENTOS ENTR DATA DE DEMISSAO ANTERIOR E REINTEGRACAO
				If Empty(dReintegra) .OR. ;
					(!Empty(dReintegra) .and. Empty(SRA->RA_DEMIANT)) .OR. ;	// Campo de reintegração foi preenchido para detectarmos que este funcionário já foi reintegrado.
				   ((!Empty(dReintegra) .and. !Empty(SRA->RA_DEMIANT)) .and.;
				      ((STRZERO(YEAR(SRA->RA_DEMIANT),4) > cAnoBase) .OR. ;
				      (Left((cAliasSRD)->RD_DATARQ,4) == STRZERO(YEAR(SRA->RA_DEMIANT),4) .and. nMesPD < Month(SRA->RA_DEMIANT)) .or. ;
				      ((Left((cAliasSRD)->RD_DATARQ,4) == STRZERO(YEAR(SRA->RA_DEMIANT),4) .and. nMesPD > Month(SRA->RA_DEMIANT)) .and. (Left((cAliasSRD)->RD_DATARQ,4) == STRZERO(YEAR(dReintegra),4) .and. ;
				              nMesPD >= Month(dReintegra))) .or.;
					    (Left((cAliasSRD)->RD_DATARQ,4) >  STRZERO(YEAR(SRA->RA_DEMIANT),4) .and. (Left((cAliasSRD)->RD_DATARQ,4) == STRZERO(YEAR(dReintegra),4) .and. nMesPD >= Month(dReintegra))) .or.;
			             (Left((cAliasSRD)->RD_DATARQ,4) > STRZERO(YEAR(dReintegra),4))))
					//TRATA RENDIMENTOS
					If "A" == cLetra
						If !((cAliasSRD)->RD_ROTEIR $ cRot132)
			 				If !Empty(dDemiss)
								IF STRZERO(YEAR(dDemiss),4) == Left((cAliasSRD)->RD_DATARQ,4) .And. nMesPD > Month(dDemiss)
									aMensais[nPos_A,Month(dDemiss)] += (cAliasSRD)->RD_VALOR * nFator
								Else
									aMensais[nPos_A,nMesPD] += (cAliasSRD)->RD_VALOR * nFator
								Endif
							Else
								aMensais[nPos_A,nMesPD] += (cAliasSRD)->RD_VALOR * nFator
							Endif
						Endif
					//TRATA 1A PARCELA 13º
					ElseIf  "B" == cLetra .and. ((cAliasSRD)->RD_ROTEIR $ cRot131 .or. ((cAliasSRD)->RD_ROTEIR $ cRotOrd + "*" + cRotAut .and. ( STRZERO( YEAR ( SRA->RA_DEMISSA ),4 ) + STRZERO( Month( SRA->RA_DEMISSA ),2 ) ) <> (cAliasSRD)->RD_DATARQ))
						aMensais[nPos_A,13] += (cAliasSRD)->RD_VALOR * nFator
						nMesPg1a := nMesPD

					//TRATA 2A PARCELA 13º
					ElseIf  "C" == cLetra .and. (!((cAliasSRD)->RD_ROTEIR $ cRot131) .or. ((cAliasSRD)->RD_ROTEIR $ cRotOrd + "*" + cRotAut .and. ( STRZERO( YEAR ( SRA->RA_DEMISSA ),4 ) + STRZERO( Month( SRA->RA_DEMISSA ),2 ) ) <> (cAliasSRD)->RD_DATARQ))
						If (cAliasSRD)->RD_pd # aCodFol[0183,1]
							If !("A" $ cSrvRais) .Or. (("A" $ cSRVRais) .And. (cAliasSRD)->RD_ROTEIR $ cRot132)
								aMensais[nPos_A,14] += (cAliasSRD)->RD_VALOR * nFator
								//FIXA A DATA DA 2A PARCELA COMO A DATA DA DEMISSAO PARA FUNCIONARIOS DEMITIDOS
								//QUANDO SE TRATAR DE VEBAS DE RESCISAO COMPLEMENTAR
								If 	(!Empty(dDemiss) .And. YEAR(dDemiss) == nAnoBase )//Left((cAliasSRD)->RD_DATARQ,4))
									nMesPg2a := Month(dDemiss)   // for demitido no ano, utilizar mes da demissao
								Elseif (!Empty(dDemiss) .and. lDiasAv .And. STRZERO(YEAR(dDemiss),4) > Left((cAliasSRD)->RD_DATARQ,4))
									nMesPg2a := Month(dDemiss)   // for demitido no ano, utilizar mes da demissao
								//FIXA A DATA DA DIfERENCA DE 13O. COMO 12 P/ FICAR IGUAL A DATA DA 2A. PARCELA
								ElseIf (cAliasSRD)->RD_PD == aCodFol[028,1]
									nMsPgDif13 := val(Right((cAliasSRD)->RD_DATARQ,2)) // mes pagamento da diferença do 13.salario.
								Else	
									nMesPg2a := val(Right((cAliasSRD)->RD_DATARQ,2)) //nMesPD   mes pagamento do 13.salario.
								EndIf
							EndIf
						EndIf
					ElseIf  "C" == cLetra .and. ((cAliasSRD)->RD_ROTEIR $ cRot131 .OR. (cAliasSRD)->RD_ROTEIR $ cRotOrd + "*" + cRotAut )
						// Nao vao acumular em local nenhum
					ElseIf  "B" == cLetra .and. (!((cAliasSRD)->RD_ROTEIR $ cRot131) .OR. (cAliasSRD)->RD_ROTEIR $ cRotOrd + "*" + cRotAut )
						// Nao vao acumular em local nenhum
					Else
						//TRATA AS DEMAIS INCIDENCIAS DA RAIS
						//REALIZA TRATAMENTO DE DEDUCAO OU ADICIONAL DA VERBA CONFORME A SUA ORIGEM
				    	lContrib	:= cLetra $ "LMOPQ"  // VerIfica se  eh verba de Contribuicoes (Assist, Sindical, Confed, Associat.)
						//PARA VERBAS DE CONTRIBUICAO  INVERTE O SINAL CONFORME A SUA ORIGEM.
					    If lContrib    //VERBA EH CONTRIBUICAO
							If lVerbDesc .or. ((cAliasSRD)->RD_PD == aCodFol[246,1])// Eh desconto ou verba for Base Contribuicao Sindical Outras Empresas/Ent. Classe
							   nFator	:= +1
							Else
							   nFator	:= -1
							EndIf
							//PARA CONTRIBUICAO CONFEDERATIVA E ASSISTENCIAL NO MOVIMENTO DO 13.SALARIO, ASSUMIR MES 12
							If (Right((cAliasSRD)->RD_DATARQ,2) == "13") .and. ((cAliasSRD)->RD_PD == aCodFol[175,1]  .or. (cAliasSRD)->RD_PD == aCodFol[0069,1])
	    	                    nMesPD = 12
							EndIf
					    EndIf
						//PARA O ANO-BASE DE 2006 FOI CRIADA A INCIDÊNCIA "T" PARA TRATAR AS HORAS EXTRAS
						//NO ANO DE 2005, AS VERBAS DE HORAS-EXTRAS ESTAVAM COM INCIDÊNCIA "R" PARA
						//SEREM SOMADAS NAS "HORAS EFETIVAMENTE TRABALHADAS".
						//A CONDICAO ABAIXO FOI COLOCADA PARA TRATAR SE O ANO-BASE FOR 2005, SOMAR AS
						//HORAS EXTRAS DA NOVA INCIDENCIA("T") NAS HORAS EFETIVAMENTE TRABALHADAS(INCIDÊNCIA R)
						If  "T" == cLetra .and. cAnoBase == "2005"
							nHoras:= (cAliasSRD)->RD_HORAS
							If (cAliasSRD)->RD_TIPO1 == "D"
								nHoras:= nHoras * (SRA->RA_HRSMES/30)
							EndIf
							aMensais[nPos_R, nMesPD]+= nHoras * nFator
				      	Else
						    //SE O TIPO DE RETORNO DA RAIS EH VALOR
						    If aRetRais[nPosLetra] == "V"
							   aMensais[nPosLetra, nMesPD]+=  (cAliasSRD)->RD_VALOR * nFator
								If cLetra == "G"
									If aScan( aAuxDiss, { |x| x[1] == (cAliasSRD)->RD_DATARQ } ) == 0
										aAdd( aAuxDiss, { (cAliasSRD)->RD_DATARQ, nMesPD} )
									EndIf
								EndIf
						    //SE O TIPO DE RETORNO DA RAIS EH HORA
			   			    ElseIf aRetRais[nPosLetra] == "H"
								nHoras:= (cAliasSRD)->RD_HORAS
								If (cAliasSRD)->RD_TIPO1 == "D"
									nHoras:= nHoras * (SRA->RA_HRSMES/30)
								EndIf

								//RESCISAO COMPLEMENTAR
								If !Empty(dDemiss) .And. STRZERO(YEAR(dDemiss),4) == Left((cAliasSRD)->RD_DATARQ,4) .And. nMesPD >= Month(dDemiss)
									//NO CASO DE HORAS FRACIONADAS, ARREDONDAR PARA MENOS, VALORES
									//ATÉ 30 MINUTOS E PARA MAIS, VALORES QUE EXCEDEM 30 MINUTOS
									//EXEMPLO: 1H30MIN = 1 E 1H35 = 2
									//COMO AS HORAS SÃO GRAVADAS DE FORMA CENTESIMAL, SEMPRE SERA
									//TESTADO 0.50 QUE EQUIVALE A 30 MINUTOS
									If nHoras-Int(nHoras) <= 0.50
										nHoras 	:= Int(nHoras)
									Else
										nHoras 	:= Int(nHoras)+1
									EndIf
									SRG->(dbSeek(SRA->RA_FILIAL+SRA->RA_MAT))
									//QUANDO HOUVER RESCISÃO COMPLEMENTAR E EXISTIR HORAS LANÇADAS
									//TEM QUE SEMPRE UTILIZAR AS HORAS DA ULTIMA COMPLEMENTAR.
									//NO ARRAY aTotHoras ESTÃO ARMAZENADAS AS HORAS, POR VERBA LANÇADA, PARA POSTERIORMENTE SOMAR TODAS AS HORAS
									While SRG->(!Eof()) .and. SRG->RG_FILIAL + SRG->RG_MAT  == SRA->RA_FILIAL + SRA->RA_MAT
										If MesAno(SRG->RG_DTGERAR) == (cAliasSRD)->RD_DATARQ  //Rescisao complementar feita no mes que está sendo processado
											nPos := ascan(aTotHoras,{|X| X[1]==(cAliasSRD)->RD_PD .and. x[2]==nPosLetra})
										    If nPos == 0
										    	AaDD(aTotHoras, {(cAliasSRD)->RD_PD, nPosLetra, nHoras, nFator})
										    Else
									 			aTotHoras[nPos,3] := nHoras
										    EndIf
											Exit
	 									EndIf
										SRG->(dbSkip())
									End
								Else
									aHoras[ nPosLetra, nMesPD]+= nHoras * nFator
								EndIf
			   			    ElseIf aRetRais[nPosLetra] == "Q"
								If EMPTY((nQtde:= (cAliasSRD)->RD_HORAS))
									nQtde:= (cAliasSRD)->RD_VALOR
								EndIf
								aMensais[nPosLetra, nMesPD]+=   nQtde * nFator
						    EndIf
						EndIf
					EndIf
				EndIf
			Next nX
		EndIf

		//acerto arredondamento primeira parcela 13
		If fPertenceSRV("N", cSrvRais) .and. lProc .And. (cAliasSRD)->RD_PD == aCodFol[026,1] .And. ((cAliasSRD)->RD_ROTEIR $ cRot131+"/"+ cRotOrd)
			aMensais[nPos_A,14] += (cAliasSRD)->RD_VALOR
		EndIf

		//PRESERVA DESCONTO DA 1A PARCELA DO 13O SALARIO
		If !fPertenceSRV("ABC", cSrvRais) .And. (cAliasSRD)->RD_PD == aCodFol[183,1]
			nAnt13Sl += (cAliasSRD)->RD_VALOR
		EndIf
		//SE CATEGORIA COMISSIONADO SOMA VERBAS DE COMISSAO INFORMADAS
		If (lComissao .or. cCatFunc == "C") .And. (cAliasSRD)->RD_PD $ cVComiss .And. !((cAliasSRD)->RD_ROTEIR $ cRot132)
			nVComiss += (cAliasSRD)->RD_VALOR
		EndIf
		(cAliasSRD)->(dbSkip())
	Enddo

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³No caso de horas fracionadas, arredondar para menos, valores³
	//³até 30 minutos e para mais, valores que excedem 30 minutos. ³
	//³Exemplo: 1h30min = 1 e 1h35 = 2.                            ³
	//³Como as horas são gravadas de forma centesimal, sempre sera ³
	//³testado 0.50 que equivale a 30 minutos.                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nX := 1 To Len(aHoras)
		For nY := 1 To Len(aHoras[nX])
			If aHoras[nX][nY] > 0
				If aHoras[nX][nY]-Int(aHoras[nX][nY]) <= 0.50
					aMensais[nX][nY]	:= Int(aHoras[nX][nY])
				Else
					aMensais[nX][nY] 	:= Int(aHoras[nX][nY])+1
				EndIf
			EndIf
		Next nY
	Next nX

	//RESCISÃO COMPLEMENTAR
   	aTotal := {}
	//NESTE PONTO TOTALIZA-SE AS HORAS LANÇADAS NA RESCISÃO COMPLEMENTAR, POR INCIDÊNCIA,
	//PARA GUARDÁ-LAS NO ARRAY AMENSAIS E POSTERIORMENTE GRAVAR NA TABELA RCU.
	If Len(aTotHoras) > 0
		For nPos := 1 to len(aTotHoras) //posicao da incidencia no array aMensais
			nPosTot := ascan(aTotal,{|x| x[1]== aTotHoras[nPos,2]})
			If nPosTot == 0 // pos.Incidencia          horas              fator
				aAdd(aTotal, {aTotHoras[nPos,2],aTotHoras[nPos,3] * aTotHoras[nPos,4]})
			Else
				aTotal[nPosTot, 2] += aTotHoras[nPos,3] * aTotHoras[nPos,4]
			EndIf
		Next
		aTotHoras := {}
		For nPos := 1 to len(aTotal)
			If !Empty(dProj) .And. substr(cCodRais,aTotal[nPos,1]*2-1,1) <> "T"
				aMensais[aTotal[nPos,1],Month(dProj)]:= aTotal[nPos,2]
			else
				aMensais[aTotal[nPos,1],Month(dDesl)]:= aTotal[nPos,2]
			Endif
    	Next
	EndIf
	//FECHA ALIAS DA QUERY E SELECIONA O SRD ORIGEM
	If (lQuery)
		dbSelectARea(cAliasSRD)
		dbCloseArea()
		dbSelectArea("SRD")
	EndIf
	//DESCONTA DO TOTAL APURADO O VALOR PAGO COMO 1º PARCELA
	aMensais[nPos_A,14] -= Max(aMensais[nPos_A,13],nAnt13Sl)
	aMensais[nPos_A,14] := Max(aMensais[nPos_A,14], 0)

	//AJUSTA MES DE PAGAMENTO DA 2ª PARCELA DO 13º SALARIO
	If Empty(nMesPg2a) .And. !Empty(nMsPgDif13)
		nMesPg2a := nMsPgDif13
	EndIf
	nMesPg2a := If(nMesPg2a=13,12,nMesPg2a)
	nMesPg1a := If(aMensais[nPos_A,13]<= 0,0,nMesPg1a)
	nMesPg2a := If(aMensais[nPos_A,14]<= 0,0,nMesPg2a)
	//TRATA 13º
	If !Empty(nMesPg1a)
		aMensais[nPos_B, nMesPg1a] := aMensais[nPos_A, 13]
	EndIf
	If !Empty(nMesPg2a)
		aMensais[nPos_C, nMesPg2a] := aMensais[nPos_A, 14]
	EndIf
	If  (nMesPg1a == nMesPg2a) .And. (nMesPg1a > 0)
		If aMensais[nPos_B, nMesPg1a] > 0
			aMensais[nPos_C, nMesPg2a] += 	aMensais[nPos_B, nMesPg1a]
			aMensais[nPos_B, nMesPg1a] := 0
		EndIf
	EndIf

	//Trata dissidio
	If Len(aAuxDiss) > 0
		aAreaAux := GetArea()
		For nCont := 1 To Len(aAuxDiss)
			If aMensais[ 7, aAuxDiss[nCont,2] ] > 0 .And. aMensais[ 8, aAuxDiss[nCont,2] ] == 0
				nContAux := 0
				dbSelectArea("RHH")
				If dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + aAuxDiss[nCont,1] )
					While !Eof() .And. RHH->RHH_FILIAL+RHH->RHH_MAT+RHH->RHH_MESANO == SRA->RA_FILIAL+SRA->RA_MAT+aAuxDiss[nCont,1]
						If cMesAnt != RHH->RHH_DATA .And. !Empty(RHH->RHH_VERBA)
							cMesAnt := RHH->RHH_DATA
							nContAux++
						EndIf
						dbSkip()
					End While
				EndIf
				aMensais[ 8, aAuxDiss[nCont,2] ] := nContAux
			EndIf
		Next nCont
		RestArea( aAreaAux )
	EndIf

	FGravaSR2()
	dbSelectArea("SRA")
	dbSkip()
Enddo

If !lRobo
	oSelf:SaveLog( STR0001+" - "+STR0037)// #"Termino do processamento"
Endif

//EMITE LOG DE OCORRENCIAS
GeraLog(aLog, "GPM500")
dbSelectArea("SR2")

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³FTotaliza ³ Autor ³ R.H.                  ³ Data ³ 20/01/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Totaliza os valores de base da RAIS                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM500Proc                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function FTotaliza(cSrvRais,nEleIni,nEleFim)
Local nValRet 		:=	0
Local nEleUlt		:= 	0
Local nLenSrvRais	:=	Len(cSrvRais)
Local nPosLetra		:= 	0
Local nX			:= 	0

nEleIni := If(nEleIni == Nil, 1, nEleIni)

//TOTALIZA TODAS AS VERBAS COM AS INCIDENCIAS DE RAIS INFORMADAS EM cSrvRais
For nX:=1 To nLenSrvRais
    nPosLetra:= &("nPos_" + Substr(cSrvRais, nX, 1))
    nEleUlt := If(nEleFim == Nil, Len(aMensais[nPosLetra]), nEleFim)
	aEval(aMensais[nPosLetra], {|X,Y| nValRet += If(Y >= nEleIni .And. Y <= nEleUlt, X, 0)})
Next nX

Return nValRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³FGravaSR2 ³ Autor ³ R.H.                  ³ Data ³ 20/01/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Grava os valores acumulados no arquivo da RAIS - SR2       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM500Proc                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function FGravaSR2()
Local cPutFilAnt  := cFilAnt
Local aTransf     := {}
Local aTransfAll  := {}
Local aTransfAnt  := {}
Local aTemp		  := {}
Local aTransfPos  := {}

// ATRIBUICAO DA VARIAVEL CFILANT, COM A MESMA FILIAL EM USO, DEVIDO A INTEGRIDADE
cFilAnt	:= SRA->RA_FILIAL
dbSelectArea("SR2")

Begin Transaction
 	//OBTEM TODAS AS TRANSFERENCIAS
 	fTransf(@aTransfAll , , .F. , .F. , .F. , .F. , .F. , .T.)
 	//AJUSTA AS TRANSFERENCIAS AO UM NOVO FORMATO E PARA O ANO BASE
	aTemp 		:= aClone(aTransfAll)
	aTransfAll	:= {}
	aTransfAnt	:= {}
	//Se transferência foi feita no primeiro dia do ano posterior, deverá ser gerado o movimento de "demissão" no dia 31/12, por isso o registro deverá entrar no aTransfAll
	Aeval(aTemp,{|x| If((SubStr(x[12],1,4) == cAnoBase .AND. x[10] = cFilAnt ) .or. (SubStr(DtoS(x[07]),5,4) == "0101" .and. cFilAnt == X[08] .and. AllTrim(Str(Val(SubStr(x[12],1,4))-1)) == cAnoBase)							,;
							AADD(aTransfAll, {;
												{x[01], x[08], x[03], x[09]  	}	,;
												{x[04], x[10], x[06], x[11]	}	,;
												{x[07]							}	;
											};
								),;
							If((SUBSTR(x[12],1,4) < cAnoBase ),;
								AADD(aTransfAnt, {;
													{x[01], x[08], x[03], x[09]  	}	,;
													{x[04], x[10], x[06], x[11]	}	,;
													{x[07]							}	;
												};
									),;
							If((SUBSTR(x[12],1,4) > cAnoBase ),;
								AADD(aTransfPos, {;
													{x[01], x[08], x[03], x[09]  	}	,;
													{x[04], x[10], x[06], x[11]	}	,;
													{x[07]							}	;
												};
									),;
							 NIL ));
						);
				};
		)

	Asort(aTransfAnt ,,, {|x,y| x[1] < y[1]})
	Asort(aTransfPos ,,, {|x,y| x[1] < y[1]})

 	//VERIfICA SE E UMA TRANSFERENCIA ENTRADA - ENTRE FILIAIS
	fTransfGer(@aTransf, aTransfAll, nAnoBase, .F.)
 	//BUSCA AS TRANSFERENCIAS ENTRE CENTRO DE CUSTO NO ANO BASE
	If lGerarCEI
		fTransfGer(@aTransf, aTransfAll, nAnoBase, .T.)
	EndIf
 	//AVALIA AFASTAMENTOS PARA TRANSFERIDOS NO ANO SEGUINTE
	If Len(aTransf) == 0 .and. Len(aTransfAll)== 0 .and. len(aTransfPos) > 0 .And. Len(aAfast) > 0
		//VERIfICA A TRANSFERENCIA PARA - SE O FUNCIONARIO ENTROU NA EMPRESA / FILIAL / MATRICULA SOMENTE NO ANO SEGUINTE
		If (nPosTrf := Ascan(aTransfPos, {|X| X[2,1]+X[2,2]+X[2,4] == cEmpAnt+SRA->RA_FILIAL+SRA->RA_MAT})) > 0
			If ( aTransfPos[nPosTrf, 1, 1]+aTransfPos[nPosTrf, 1, 2]+aTransfPos[nPosTrf, 1, 4] != aTransfPos[nPosTrf, 2, 1]+aTransfPos[nPosTrf, 2, 2]+aTransfPos[nPosTrf, 2, 4] )
				aAfast	:= {}
			EndIf
  		EndIf
	EndIf
 	//SE GERACAO POR CEI GRAVA TRANSFERIDOS SENAO GRAVA NORMAL
	If lGerarCEI .And. Len(aTransf) > 0
		fGravaTransf(aTransf, aTransfAll, aTransfAnt)
	ElseIf lGerarCEI .And. Len(aTransf) == 0  .and. Len(aTransfAll)== 0 .and. len(aTransfPos) > 0
		cFilAtu := aTransfPos[1,1,2]
		cCCAtu  := aTransfPos[1,1,3]
		fGravaNormal(aTransf,.T.,cFilAtu,cCCAtu,aTransfAnt)
	Else
		fGravaNormal(aTransf,,,,aTransfAnt)
	EndIf
End Transaction

// GRAVACAO DA VARIAVEL CFILANT COM A VARIAVEL ATRIBUIDA NO INICIO DO WHILE
cFilAnt := cPutFilAnt

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ GPM500Ok ³ Autor ³ R.H.                  ³ Data ³ 20/01/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Confirma configuracao de parametros                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPM500Ok                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function GPM500Ok()
Return (MsgYesNo(OemToAnsi(STR0016),OemToAnsi(STR0017))) //"Confirma configura‡„o dos parƒmetros?"###"Aten‡„o"

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fGravaNorm³ Autor ³ R.H.                  ³ Data ³ 20/01/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Grava um registro para o funcionario corrente              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM500                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fGravaNormal(aTransf,lTransfPos,cFilAtu,cCCAtu,aTransfAnt)
Local aAfastFun	 := {}
Local aMesAfast  := {}
Local cNroCEI  	 := Space(12)
Local cTipoAdm
Local lAltDtDem
Local nCnpj1,nCnpj2
Local cDeslMMA   := "0000"
Local cRescRai   := "00"
Local cSR2Chave	 := ""
Local cCodMun	 := Strzero(0,7)
Local dDtAdmissa := SRA->RA_ADMISSA
Local dDtDemissa := SRA->RA_DEMISSA
Local dDtAdmCabec:= SRA->RA_ADMISSA
Local dDtAdmAnt	 := SRA->RA_ADMISSA
Local nMesDe	 := 0
Local nMesAte	 := 0
Local nPos       := 0
Local lProcTrf	 := .T.
Local nPosTrfAnt := 0
Local nAposSRes	 := 0
DEFAULT lTransfPos := .F.
DEFAULT aTransfAnt := {}

//OBTEM O CODIGO DO MUNICIPIO A PARTIR DO CADASTRO DE FUNCIONARIOS
If !Empty((nCnpj1 := Ascan(aCnpjFil, {|X| X[1]+X[2] == cEmpAnt+SRA->RA_FILIAL})))
	cCodMun:= aCnpjFil[nCnpj1, 4]
EndIf

//BUSCA O TIPO DE ADMISSAO DO FUNCIONARIO
fTipoAdm(@cTipoAdm,aTransf)

//EFETUA O TRATAMENTO CASO SEJA TRANSFERENCIA ENTRADA OU SAIDA
If Len(aTransf) > 0
	//VERIfICA SE HOUVE UMA TRANSFERENCIA ENTRADA
	nPosTrf := Ascan(aTransf, {|X| X[2,1]+X[2,2]+X[2,4] == cEmpAnt+SRA->RA_FILIAL+SRA->RA_MAT})
	If nPosTrf > 0
		//VERIfICA SE A TRANSFERENCIA E ENTRE FILIAIS COM MESMO CNPJ
		If aTransf[nPosTrf,1,2] # aTransf[nPosTrf,2,2]
			nCnpj1 := Ascan(aCnpjFil, {|X| X[1]+X[2] == aTransf[nPosTrf,1,1] + aTransf[nPosTrf,1,2]})
			nCnpj2 := Ascan(aCnpjFil, {|X| X[1]+X[2] == aTransf[nPosTrf,2,1] + aTransf[nPosTrf,2,2]})
		    If nCnpj1 > 0 .And. nCnpj2 > 0
		    	If aCnpjFil[nCnpj1,3] == aCnpjFil[nCnpj2,3]
   					aTransf 	:= {}
   					lProcTrf	:= .F.
   				EndIf
		    EndIf
		EndIf
		If lProcTrf
			//SO ATUALIZA ADMISSAO SE FOR A PRIMEIRA ENTRADA NESTA FILIAL
			If Ascan(aTransf, {|X| (X[1,1] + X[1,2] + X[1,4] == ;
			                           cEmpAnt + SRA->RA_FILIAL + SRA->RA_MAT) .And. ;
									 (X[3,1] <= aTransf[nPosTrf,3,1])}) == 0
				dDtAdmissa  := Min(aTransf[nPosTrf,3,1],dDtAdmissa )
				dDtAdmCabec := Max(aTransf[nPosTrf,3,1],dDtAdmAnt )
			Else
				cTipoAdm   := '02'
			EndIf
			nPos := 0
			//PROCURA A ULTIMA SAIDA DESTA FILIAL PARA DETERMINAR SUA DATA DE DEMISSAO
			Aeval(aTransf, {|x,y| If (	(x[1,1] + x[1,2] + x[1,4] == ;
							 			  cEmpAnt + SRA->RA_FILIAL + SRA->RA_MAT),;
							 			nPos:= y,;
							 			Nil;
							 		 );
						 	};
				)
			//E SO ATUALIZA SE NAO HOUVER RETORNO A ESTA FILIAL
			If nPos > 0 .and. ;
			   Ascan(aTransf, {|X| (X[2,1] + X[2,2] + X[2,4] == ;
			                           cEmpAnt + SRA->RA_FILIAL + SRA->RA_MAT) .And. ;
			                         (X[3,1] >= aTransf[nPos,3,1])}) == 0
				dDtDemissa  := aTransf[nPos,3,1]-1
			Else
				If !Empty(dDtDemissa) .And. SRA->RA_RESCRAI $ "30*31" //Transferencia Com/Sem Onus
					lAltDtDem := ( SRA->RA_ADMISSA # dDtDemissa .And. MesDia( dDtDemissa ) # "0101" )
					IF lAltDtDem
						dDtDemissa --
					Endif
				EndIf
			EndIf
		Else
			nPos := Ascan(aTransf, {|X| X[1,1]+X[1,2] == cEmpAnt+SRA->RA_FILIAL})
			If (nPos > 0 , dDtDemissa  := aTransf[nPos,3,1]-1 , NIL)
		EndIf
	Else
		//TRATAMENTO ESPECIfICO PARA TRATAR DUAS NAO CONFORMIDADES:
		//1. ADMISSAO E TRANFERENCIA OCORRIDA NO MESMO DIA E;
		//2. TRANSFERENCIA OCORRIDA NO PRIMEIRO DIA DO ANO.
		//NO PRIMEIRO CASO A DEMISSAO FICA SUPERIOR A ADMISSAO, NO SEGUNDO FICA
		//31/12/ANO_CALENDARIO. NO MANUAL DA RAIS NAO HA EXPLICACOES CONCLUSIVAS
		//SOBRE O TEMA, POR ISSO NESSES CASOS A DATA DEMISSAO NAO SERA AJUSTADA

		If (LEN(aTransfAnt) > 0)
			Asort(aTransfAnt ,,, {|x,y| x[3,1] > y[3,1]})
			nPosTrfAnt := Ascan(aTransfAnt, {|X| X[2,1]+X[2,2]+X[2,4] == cEmpAnt+SRA->RA_FILIAL+SRA->RA_MAT .AND. (x[1,1] != x[2,1] .OR. x[1,2] != x[2,2] )  })
			If nPosTrfAnt > 0
				dDtAdmissa := aTransfAnt[nPosTrfAnt,3,1]
			Endif
		EndIf

		lAltDtDem := (dDtAdmissa # dDtDemissa )
		nPos := Ascan(aTransf, {|X| X[1,1]+X[1,2] == cEmpAnt+SRA->RA_FILIAL})
		If (nPos > 0  .And. lAltDtDem, dDtDemissa  := aTransf[nPos,3,1]-1 , NIL)
	EndIf
Else
	 If !Empty(dDtDemissa) .And. SRA->RA_RESCRAI $ "30*31" //Transferencia Com/Sem Onus
	    lAltDtDem := ( SRA->RA_ADMISSA # dDtDemissa .And. MesDia( dDtDemissa ) # "0101" )
	    IF lAltDtDem
			dDtDemissa --
		Endif
	 EndIf
EndIf

//Busca o CEI Cadastrado no SI3/CTT
If lGerarCEI
	dbSelectArea(cAliasCC)
	If lTransfPos
		dbSeek(If(FWModeAccess(cAliasCC) == "C", cFilial, xFilial(cAliasCC, SRA->RA_FILIAL)) + cCCAtu)
	Else
		dbSeek(If(FWModeAccess(cAliasCC) == "C", cFilial, xFilial(cAliasCC, SRA->RA_FILIAL)) + SRA->RA_CC)
	EndIf

	If VAL(cAnoBase) >= 2018 .AND. (cAliasCC)->(&(cPrefixCC + "TIPO2")) == "4"
		cNroCEI := Alltrim((cAliasCC)->( &( cPrefixCC + "CEI2" ) )  )
	ElseIf !lSI3_Tipo .Or. (lSI3_Tipo .And. (cAliasCC)->(&(cPrefixCC + "TIPO")) == "2") // CEI
		If Empty((cAliasCC)->(&(cPrefixCC + "CEI")))
			cNroCEI := Space(12)
		Else
			cNroCEI := Alltrim((cAliasCC)->( &( cPrefixCC + "CEI" ) )  )
			If Len(cNroCEI) > 12
				cNroCEI := StrZero( Val( SubStr(cNroCEI, 3 , 12) ), 12 )
			Else
				cNroCEI := StrZero( Val( cNroCEI), 12 )
			EndIf
			//OBTEM O CODIGO DO MUNICIPIO	A PARTIR DO CADASTRO DE CENTRO DE CUSTOS
			cCodMun := UfCodIBGE((cAliasCC)->(&(cPrefixCC + "ESTADO"))) + Alltrim((cAliasCC)->(&(cPrefixCC + "CODMUN")))
		EndIf
	EndIf
	dbSelectArea("SR2")
EndIf

If (YEAR(dDtDemissa) > nAnoBase) .or. (Empty(dDtDemissa))
    cDeslMMA   		:=  "0000"
    // VERIFICAR SE FUNCIONARIO APOSENTADO E NÃO TEVE RESCISÃO DEVE IR O CODIGO "l"
    If SRA->RA_RESCRAI = "71"
      cRescRai := SRA->RA_RESCRAI
    Else
      cRescRai  :=  "00"
    EndIf
Else
	If !lDiasAv
		cDeslMMA   		:=  StrZero(Day(dDtDemissa),2) + StrZero(Month(dDtDemissa),2)
	Else
		cDeslMMA   		:=  StrZero(Day(dProj),2) + StrZero(Month(dProj),2)
	EndIf
	cRescRai   		:=  If (Empty(SRA->RA_RESCRAI) , "31" , SRA->RA_RESCRAI)
EndIf

If lDiasAv .AND. YEAR(dProj) > nAnoBase
	cDeslMMA	:= "0000"
	cRescRai	:= "00"
Endif

//TRATA OS MESES A SEREM CONSIDERADOS PARA A GRAVACAO DAS VERBAS PARA O ANO BASE
nMesDe  := If(Year(dDtAdmissa) < nAnoBase, 01, Month(dDtAdmissa))
nMesAte	:= 12

//OBTEM OS AFASTAMENTOS PARA O PERIODO EM QUE O FUNCIONARIO	ESTEVE NA FILIAL
aAfastFun	:= {}
aMesAfast	:= {}

fAfasta(dDtAdmissa, cDeslMMA, aAfast, @aAfastFun, @aMesAfast)
//verifica se tem aposentadoria nos afastamentos (sem rescisao)
If (nAposSRes := Ascan(aAfast, {|X| x[6] $ '73*74*76'})) > 0 .AND. Year(aAfast[nAposSRes,3]) == nAnobase
	cRescRai := aAfast[nAposSRes,6]
	cDeslMMA := StrZero(Day(aAfast[nAposSRes,3]),2) + StrZero(Month(aAfast[nAposSRes,3]),2)
EndIf

Begin Sequence
	//VERIfICA SE ENTRE OS MESES EXISTEM VALORES PARA A RAIS
	If fTotaliza("ABCDS") <= 0        //Somar tb o aviso indenizado
		//NAO GERA RAIS PARA FUNCIONARIO SEM MOVIMENTO E SEM AFASTAMENTO
		If Empty(aMesAfast)
			If Empty(SRA->RA_DEMISSA) .Or. (Year(SRA->RA_DEMISSA) == nAnoBase .and. SubStr(DtoS(SRA->RA_DEMISSA),5,4) == "0101" ) .Or. Year(SRA->RA_ADMISSA) > nAnoBase .Or. (!Empty(SRA->RA_DEMISSA) .And. (Year(SRA->RA_DEMISSA) < nAnoBase .Or. Year(SRA->RA_DEMISSA) > nAnoBase) )
				Break
			EndIf
		EndIf
	EndIf
	cSR2Chave	:= SRA->RA_FILIAL + cAnoBase + cNroCEI + SRA->RA_MAT + Dtos(dDtAdmissa)
	If SR2->(dbSeek(cSR2Chave))
		RecLock("SR2",.F.)
	Else
		RecLock("SR2",.T.)
	EndIf
	//GRAVA CABECALHO DA RAIS (SR2)
	fVartoCposSR2(SRA->RA_FILIAL, SRA->RA_MAT, cCgc, dDtAdmCabec, cTipoAdm, cNroCEI, cDeslMMA, cRescRai, nMesDe, nMesAte, cCodMun, aAfastFun, aMesAfast)
	MsUnLock()
	SR2->(FKCOMMIT())
	//GRAVA ITENS DA RAIS (RCU - LANCAMENTOS MENSAIS)
	FGravaRCU(	SRA->RA_FILIAL, SRA->RA_MAT, cCgc, cNroCEI, dDtAdmCabec, cAnoBase, aMensais,  nMesDe, nMesAte)
End Sequence

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fGravaTran³ Autor ³ R.H.                  ³ Data ³ 20/01/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Grava um registro para cada transferencia                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM500                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fGravaTransf(aTransf, aTransfAll,aTransfAnt)
Local aAfastFun	 	:= {}
Local aMesAfast  	:= {}
Local cFilAtu 		:= ""
Local cCCAtu  		:= ""
Local cMatAtu 		:= ""
Local dDtSai,dDtEnt,nMesDe,nMesAte
Local cNroCEI 		:= Space(12)
Local nMax    		:= Len(aTransf)+1
Local cTipoAdm
Local cDeslMMA   	:=  "0000"
Local cRescRai   	:=  "00"
Local cSR2Chave		:= ""
Local nCnt
Local cCodMun	 	:= StrZero(0, 7)
Local nPos			:= 0
Local lFirstData	:= .T.
Local cMatAux		:= ""
Local cCeiInicial
Local dDtInicial
Local dDataECEI
Local lVerCEI := .F.
//VERIfICACAO SE A TRANSFERENCIA EH POR CEI DE FATO
//PRIMEIRAMENTE CONSIDERAMOS QUE NAO SERA POR CEI.
Local lForcaNormal	:= .T.

//VERIfICA SE EXISTE CENTRO DE CUSTO PREPARADO PARA CEI EM ALGUMA DAS TRANSFERENCIAS
For nCnt := 1 To nMax
   		If nCnt == nMax //CEI EM QUE O FUNCIONARIO ESTA ATUALMENTE
   			cFilAtu := aTransf[nCnt-1,2,2]
			cCCAtu  := aTransf[nCnt-1,2,3]
		Else
			cFilAtu := aTransf[nCnt,1,2]
			cCCAtu  := aTransf[nCnt,1,3]
		EndIf
	 	//Busca o CEI Cadastrado no SI3/CTT
		dbSelectArea(cAliasCC)
		dbSeek(If(FWModeAccess(cAliasCC) == "C" , cFilial, xFilial(cAliasCC, cFilAtu)) + cCCAtu)
		//-- Se Existir pelo menos uma transferencia que seja por CEI permanece o procedimento por CEI
		If !Empty((cAliasCC)->(&(cPrefixCC + "CEI")))
		   lForcaNormal:= .F.
		EndIf
Next
//SE FOI SOLICITADA GERACAO POR CEI MAS OS CENTROS DE CUSTOS NAO FORAM PREPARADOS PARA CEI
//"FORCA" A GRAVACAO COMO SE FOSSE POR NAO CEI
If lForcaNormal
	fGravaNormal(aTransf)
Else
	//OBTEM O CODIGO DO MUNICIPIO	A PARTIR DO CADASTRO DE FUNCIONARIOS
	If !Empty((nCnpj1 := Ascan(aCnpjFil, {|X| X[1]+X[2] == cEmpAnt+SRA->RA_FILIAL})))
		cCodMun:= aCnpjFil[nCnpj1, 4]
	EndIf

	lVerCEI := VerificaCEI(aTransf)

	For nCnt := 1 To nMax
		nPos:=0
		If nCnt == nMax // CEI EM QUE O FUNCIONARIO ESTA ATUALMENTE
			cFilAtu := aTransf[nCnt-1,2,2]
			cCCAtu  := aTransf[nCnt-1,2,3]
			cMatAtu := aTransf[nCnt-1,2,4]
			//PROCURA POR SAIDA DA FILIAL/CC
		 	Aeval(aTransfAll, {|x,y| If (	 (x[1, 1] + x[1, 2] + x[1, 3] + x[1, 4])  == ;
		 					 			(aTransf[nCnt-1,2,1] + aTransf[nCnt-1,2,2] + aTransf[nCnt-1,2,3] + aTransf[nCnt-1,2,4]),;
		 					 			nPos:= y,;
		 					 			Nil;
		 					 		 );
		 			 		 	};
			 		)
			//SO ATUALIZA DE FATO A DATA DE SAIDA SE O FUNCIONARIO NAO RETORNOU A FILIAL/CC
			If nPos > 0 .and. ;
			   Ascan(aTransf, {|X| (X[2,1]+ X[2,2] + X[2,3] + X[2,4] == ;
			                           aTransf[nCnt-1,2,1]+ cFilAtu + cCCAtu + cMatAtu ) .And. ;
			                         (X[3,1] >= aTransfAll[nPos,3,1])}) == 0
				nPos:= nPos
			Else
			  //FORCA A ASSUMIR A DATA DE DEMISSAO (ESPERA-SE EM BRANCO!!!)POIS NESSE CASO O FUNCIONARIO RETORNOU A FILIAL/CC
			   nPos := 0
			EndIf
			dDtSai  := If(Empty(SRA->RA_DEMISSA) .or. Year(SRA->RA_DEMISSA) > nAnoBase , If(nPos > 0, aTransfAll[nPos,3,1] -1,SRA->RA_DEMISSA), SRA->RA_DEMISSA)
			nPos:=0
		    //OBTEM A PRIMEIRA DATA DE ENTRADA NO CENTRO DE CUSTO OCORRIDA NO ANO BASE
			nPos:= Ascan(aTransf, {|X| (X[2,1]+ X[2,2] + X[2,3] + X[2,4] == ;
			                           aTransf[nCnt-1,2,1]+ cFilAtu + cCCAtu + cMatAtu ) } )
			dDtEnt  := If(nPos > 0 .AND. (aTransf[nPos,3,1] <  aTransf[nCnt-1,3,1] ) , aTransf[nPos,3,1] ,  aTransf[nCnt-1,3,1])
			If !lVerCEI
				dDtEnt  := SRA->RA_ADMISSA
			EndIf
			dDataECEI 	:= aTransf[nCnt-1,3,1]
			//FUNCIONARIO DEMITIDO ANTES DA DATABASE EH DESCONSIDERADO
			If  !Empty(dDtSai) .AND. Year(dDtSai) < nAnoBase
				Loop
			Else
				nMesDe  := If(Year(dDataECEI) < nAnoBase, 01, Month(dDataECEI))
				nMesAte := 12
			EndIf
		Else
			cFilAtu := aTransf[nCnt,1,2]
			cCCAtu  := aTransf[nCnt,1,3]
			cMatAux := cMatAtu
			cMatAtu := aTransf[nCnt,1,4]
			dDtSai  := aTransf[nCnt,3,1]-1
	        nPos:=0
		    //OBTEM A DATA DE ENTRADA NO CENTRO DE CUSTO
			Aeval(aTransfAll, {|x,y| If (	 (x[2, 1] + x[2, 2] + x[2, 3] + x[2, 4])  == ;
						 			(aTransf[nCnt,1,1] + cFilAtu + cCCAtu + cMatAtu),;
						 			nPos:= If(empty(nPos) , y, nPos),;
						 			Nil;
						 		 );
						 	};
			)
			dDtEnt  := If(nPos > 0 .AND. !(aTransfAll[nPos,3,1] > dDtSai) , aTransfAll[nPos,3,1], If (nCnt == 1 , SRA->RA_ADMISSA , aTransf[nCnt-1,3,1]))
			//FUNCIONARIO DEMITIDO ANTES DA DATABASE EH DESCONSIDERADO
			If  !Empty(dDtSai) .AND. Year(dDtSai) < nAnoBase
				Loop
			Else
				//OBTEM O MES DO MOVIMENTO DO CENTRO DE CUSTO
				nPos:=0
				//CALCULA O INICIO DO PERIODO PARA OBTER OS LANCAMENTOS NO C.CUSTO
				dDataECEI 	:= If(nCnt == 1, dDtEnt, aTransf[nCnt-1,3,1])
				nMesDe  	:= If(Year(dDataECEI) < nAnoBase, 01, Month(dDataECEI))
			    nMesAte		:= Month(aTransf[nCnt,3,1]) -1
				If nMax == 2
				   If nMesDe == Month(aTransf[nCnt,3,1])  .AND. ;
				   (cFilAtu + cMatAtu) == (SRA->(RA_FILIAL + RA_MAT))
				      Loop
				   EndIf
				EndIf
			EndIf
		EndIf
	 	//BUSCA O CEI CADASTRADO NO SI3/CTT
		dbSelectArea(cAliasCC)
		dbSeek(If(FWModeAccess(cAliasCC) == "C",cFilial,xFilial(cAliasCC, cFilAtu)) + cCCAtu)

		If VAL(cAnoBase) >= 2018 .AND. (cAliasCC)->(&(cPrefixCC + "TIPO2")) == "4"
			cNroCEI := Alltrim((cAliasCC)->( &( cPrefixCC + "CEI2" ) )  )
		ElseIf !lSI3_Tipo .Or. (lSI3_Tipo .And. (cAliasCC)->(&(cPrefixCC + "TIPO")) == "2") // CEI
			If Empty((cAliasCC)->(&(cPrefixCC + "CEI")))
				cNroCEI := Space(12)
			Else
				cNroCEI := (cAliasCC)->(&(cPrefixCC + "CEI"))
				cNroCEI := StrZero(Val(SubStr(cNroCEI, 3 , 12)), 12)
				//OBTEM O CODIGO DO MUNICIPIO A PARTIR DO CADASTRO DE CENTRO DE CUSTOS
				cCodMun:= Alltrim((cAliasCC)->(&(cPrefixCC + "CODMUN")))
			EndIf
		Else
			cNroCEI := Space(12) //Se o centro de custo na última transferência não é  por CEI, limpa o conteúdo da variável.
		EndIf
		//BUSCA O TIPO DE ADMISSAO DO FUNCIONARIO
		fTipoAdm(@cTipoAdm,aTransf)
		cRescRAI := "31"  //TRANSFERENCIA SEM ONUS PARA A CEDENTE
		cDeslMMA := StrZero(Day(dDtSai),2) + StrZero(Month(dDtSai),2)
		//PARA RETORNO NA FILIAL/CC DE ORIGEM, MANTEM A PRIMEIRA DATA DO ANO BASE,EXCETO SE MUDOU A MATRICULA
		If !(cMatAux == cMatAtu)
			lFirstData := .T.
		EndIf
		If (lFirstData)
			cCeiInicial := cNroCEI
			dDtInicial  := dDtEnt
			If (Empty(dDtSai)) .or. (!Empty(dDtSai) .and. Year(dDtSai) = nAnoBase)
				lFirstData := .F.
			EndIf
		Else
	    	If cCeiInicial == cNroCEI
				dDtEnt := dDtInicial
			EndIf
		EndIf
		If nCnt == nMax // CEI EM QUE O FUNCIONARIO ESTA ATUALMENTE
			cDeslMMA := StrZero(Day(dDtSai),2) + StrZero(Month(dDtSai),2)
			cRescRAI := If(Empty(SRA->RA_RESCRAI),"00",SRA->RA_RESCRAI)
			cTipoAdm := "04"//TRANSFERENCIA
		EndIf
		If Year(dDtSai) = nAnoBase
		   	cDeslMMA   :=  If(Empty(dDtSai),"0000",cDeslMMA)
		    cRescRAI   :=  If(Empty(dDtSai),"00",cRescRAI)
		Else
		    cDeslMMA   :=  "0000"
		    cRescRAI   :=  "00"
		EndIf
		If (nCnt == nMax) .and. Month(dDtSai) >= nMesDe .And. Month(dDtSai) <= nMesAte .and. nMesPD > 0
			aMensais[nPos_S,Month(dDtSai)]:= aMensais[nPos_S,nMesPD]
		EndIf
		//SO GRAVA SE O REGISTRO FOR REFERENTE A FILIAL E MATRICULAS CORRENTES
		If (cFilAtu + cMatAtu) == (SRA->(RA_FILIAL + RA_MAT))
			//OBTEM OS AFASTAMENTOS PARA O PERIODO EM QUE O FUNCIONARIO ESTEVE NA FILIAL
			aAfastFun	:= {}
			aMesAfast	:= {}
			fAfasta(dDtEnt, cDeslMMA, aAfast, @aAfastFun, @aMesAfast)
		 	//VERIfICA SE ENTRE OS MESES EXISTEM VALORES PARA A RAIS
			If fTotaliza("ABC",nMesDe,nMesAte) <= 0
				//NAO GERA RAIS PARA FUNCIONARIO SEM MOVIMENTO E SEM AFASTAMENTO PARA O PERIODO DE PERMANENCIA NA FILIAL
				If Empty(Ascan(aMesAfast, {|x| x >= nMesDe .AND. x <= nMesAte}))
					Loop
				EndIf
			EndIf
			dbSelectArea("SR2")
			cSR2Chave:= cFilAtu + cAnoBase + cNroCEI + cMatAtu + DTOS(dDtEnt)
			If dbSeek(cSR2Chave)
				RecLock("SR2",.F.,.T.)
			Else
				RecLock("SR2",.T.)
			EndIf
			//GRAVA CABECALHO DA RAIS (SR2)
		    fVartoCposSR2(cFilAtu, cMatAtu, cCgc,  dDtEnt, cTipoAdm, cNroCEI, cDeslMMA, cRescRai, nMesDe, nMesAte, cCodMun, aAfastFun, aMesAfast)
			MsUnLock()
			SR2->(FKCOMMIT())
			//GRAVA ITENS DA RAIS (RCU - LANCAMENTOS MENSAIS)
			FGravaRCU(	cFilAtu, cMatAtu, cCgc, cNroCEI, dDtEnt, cAnoBase, aMensais, nMesDe, nMesAte)
		EndIf
	Next nCnt
EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fVartoCposSR2  ³ Autor ³ Mauricio MR      ³ Data ³ 19/01/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Move as Variaveis para os Campos do SR2                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM500                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fVartoCposSR2(_cFilAtu, _cMatAtu, _cCgc, _dAdmissao, _cTipoAdm,  _cNroCEI, _cDeslMMA, _cRescRai, _nMesDe, _nMesAte, cCodMun, aAfast, aMesAfast)
Local cCat 		:= cCatFunc
Local cCodFun	:= cFuncao
Local cNaciona	:= SRA->RA_NACIONA

//CONVERTE CODIGOS DE NACIONALIDADE PROTHEUS P/ RAIS
If cNaciona == "26" // Dominicano (Protheus)
	cNaciona := "80" // Outros (RAIS)
ElseIf cNaciona == "27" // Mexicano (Protheus)
	cNaciona := "80" // Outros (RAIS)
ElseIf cNaciona == "96" // Venezuelano (Protheus)
	cNaciona := "26" // Venezuelano (RAIS)
ElseIf cNaciona == "97" // Colombiano (Protheus)
	cNaciona := "27" // Colombiano (RAIS)
ElseIf cNaciona == "50" // Outros (Protheus)
	cNaciona := "80" // Outros (RAIS)
ElseIf cNaciona == "98" // Bengales(Protheus)
	cNaciona := "50" // Outros (RAIS)
Endif

SR2->R2_FILIAL	:=  _cFilAtu
SR2->R2_ANOBASE	:=  cAnoBase
SR2->R2_MAT   	:=  _cMatAtu
SR2->R2_CGC   	:=  _cCgc
SR2->R2_PIS  	:=  If(Empty(SRA->RA_PIS), SRA->RA_CIC,SRA->RA_PIS )
SR2->R2_NOME  	:=  SRA->RA_NOME
SR2->R2_SALARIO	:=  nSalario
SR2->R2_TIPOSAL	:=  If(cCat $ "M*C*I","1",If(cCat="Q","2",If(cCat="S","3",If(cCat="D","4",If(cCat$"H*J","5",If(cCat="T","6","7"))))))
SR2->R2_HRSEMAN	:=  Int(SRA->RA_HRSEMAN)
If !Empty(SRA->RA_NUMCP)
	SR2->R2_NUMCP 	:=  SRA->RA_NUMCP
	SR2->R2_SERCP 	:=  SRA->RA_SERCP
Else
	SR2->R2_NUMCP 	:=  StrZero(Val(Substr(SRA->RA_CIC, 1,7 ) ),08)
	SR2->R2_SERCP 	:=  StrZero(Val(Right(SRA->RA_CIC,4) ),05)
Endif
SR2->R2_NASC  	:=  SRA->RA_NASC
SR2->R2_ADMISSA	:=  _dAdmissao
SR2->R2_TIPOADM :=  _cTipoAdm
SR2->R2_CODFGTS	:=  If(Empty(SRA->RA_OPCAO) , "2" , "1")
SR2->R2_FGTSMMA	:=  If(Empty(SRA->RA_OPCAO) , Space(4) , StrZero(Month(SRA->RA_OPCAO),2) + SubStr(StrZero(Year(SRA->RA_OPCAO),4),3,2))
SR2->R2_CPF  	:=  SRA->RA_CIC
SR2->R2_CBO 	:=  fCodCBO(SRA->RA_FILIAL,cCodFun,cAnoBase)
SR2->R2_VIEMRAI	:=  SRA->RA_VIEMRAI
SR2->R2_GRINRAI	:=  SRA->RA_GRINRAI
SR2->R2_NACIONA	:=  cNaciona
SR2->R2_ANOCHEG	:=  If(Val(SRA->RA_ANOCHEG) = 0,"00",StrZero(Val(SRA->RA_ANOCHEG),2))
SR2->R2_RACACOR	:=  SRA->RA_RACACOR
SR2->R2_CEI    	:=  _cNroCEI
SR2->R2_DESLMMA	:=  _cDeslMMA
SR2->R2_RESCRAI	:=  _cRescRai
SR2->R2_DEFIfIS	:=  If(Empty(SRA->RA_DEFIfIS), "2", SRA->RA_DEFIfIS)

If SRA->(FieldPos("RA_TPDEFFI")) #0 .AND. SR2->(FieldPos("R2_TPDEFFI")) #0
	SR2->R2_TPDEFFI	:= 	If(Empty(SRA->RA_TPDEFFI) .or. SRA->RA_DEFIfIS== "2","0",SRA->RA_TPDEFFI)
EndIf
SR2->R2_SEXO  	:=  If(SRA->RA_SEXO == "M", "1", "2")
SR2->R2_CODMUN	:=  VaL(cCodMun)
SR2->R2_VAPRGRV	:= "2"
SR2->R2_HOPARC 	:=  If(!lPosHoParc .Or. Empty( SRA->RA_HOPARC ), "2", SRA->RA_HOPARC )
SR2->R2_TELETRA :=  If(lPosTpJor .And. SRA->RA_TPJORNA == "4", "1", "2" )
SR2->R2_INTERMI	:=  If(SRA->RA_TPCONTR == "3", "1", "2" )

//GRAVA VALORES ACUMULADOS MES A MES E SALARIO DE COMISS/TAREF
fGravMes(_nMesDe, _nMesAte)

//GRAVA OS AFATAMENTOS OCORRIDOS NO ANO
fGravAfa(_dAdmissao,_cDeslMMA, aAfast, aMesAfast)

//PONTO DE ENTRADA PARA ALTERAR CAMPOS DO SR2
If ExistBlock("GP500ALT")
	ExecBlock("GP500ALT",.F.,.F.)
EndIf

Return(NIL)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fTransfAno³ Autor ³ R.H.                  ³ Data ³ 19/01/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Seleciona as transferencias do funcionario no ano base     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM500  (DESATIVADA pelo USO da fTransF())                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fTransfAno(aTransf,nAnoBase,lCCusto)
Local aRecTrf := {}
Local aTemp   := {}
Local aArea	:= GetArea()
Local i
//VERIfICA TODAS AS TRANSFERENCIA DO FUNCIONARIO NO ANO BASE
dbSelectArea("SRE")
dbSetOrder(2)
If dbSeek(cEmpAnt + SRA->RA_FILIAL + SRA->RA_MAT)
	cEFilMat := cEmpAnt + SRA->RA_FILIAL + SRA->RA_MAT
	cCc      := SRA->RA_CC
	While ! EOF() .And. SRE->RE_EMPP+SRE->RE_FILIALP+SRE->RE_MATP == cEFilMat
		If SRE->RE_CCP == cCc
			If Ascan(aRecTrf,SRE->(RECNO())) > 0
				dbSkip()
				Loop
			Else
				Aadd(aRecTrf,SRE->(RECNO()))
			EndIf
		EndIf
		If(SRE->RE_EMPP+SRE->RE_FILIALP+SRE->RE_MATP+SRE->RE_CCP == cEFilMat+cCc)
			cEFilMat := SRE->RE_EMPD + SRE->RE_FILIALD + SRE->RE_MATD
			cCc      := SRE->RE_CCD
			//SOMENTE GRAVAR ANO BASE IGUAL AO ANO DA TRANSFERENCIA E MES/ANO DA TRANSFERENCIA MAIOR QUE MES/ANO DA ADMISSAO
			If Year(SRE->RE_DATA) == nAnoBase .And. MesAno(SRE->RE_DATA) > MesAno(SRA->RA_ADMISSA)
				If SRE->RE_EMPP == SRE->RE_EMPD .And.;
					((SRE->RE_FILIALP == SRE->RE_FILIALD .And. lCCusto) .Or. (SRE->RE_FILIALP  # SRE->RE_FILIALD .And. !lCCusto))
					//SE HOUVER TRANSFERENCIA NO MESMO MES/ANO, CONSIDERAR APENAS A PRIMEIRA TRANSFERENCIA "DE" E A ULTIMA "PARA"
					nPos := Ascan(aTemp, {|X| MesAno(X[3,1]) == MesAno(SRE->RE_DATA)})
					If nPos > 0
					    If aTemp[nPos,3,1] < SRE->RE_DATA
							aTemp[nPos,2,1] := SRE->RE_EMPP
							aTemp[nPos,2,2] := SRE->RE_FILIALP
							aTemp[nPos,2,3] := SRE->RE_CCP
							aTemp[nPos,2,4] := SRE->RE_MATP
	   						aTemp[nPos,3,1] := SRE->RE_DATA
						EndIf
					Else
						Aadd(aTemp, {{SRE->RE_EMPD, SRE->RE_FILIALD, SRE->RE_CCD, SRE->RE_MATD},;
   									   {SRE->RE_EMPP, SRE->RE_FILIALP, SRE->RE_CCP, SRE->RE_MATP},;
   									   {SRE->RE_DATA}})
					EndIf
				EndIf
			EndIf
			dbSeek(cEFilMat)
		Else
			dbSkip()
		EndIf
	EndDo
EndIf
RestArea(aArea)

//SE GERACAO POR CENTRO DE CUSTO LIMPA AS TRANSFERENCIAS ENTRE FILIAIS, SE HOUVER, E CONSIDERA SOMENTE TRANSF ENTRE C.CUSTO
If lCCusto .And. Len(aTemp) > 0
	aTransf	:={}
EndIf

For i := 1 To Len(aTemp)
	If aTemp[i,1,1]+aTemp[i,1,2]+aTemp[i,1,3]+aTemp[i,1,4] # ;
       aTemp[i,2,1]+aTemp[i,2,2]+aTemp[i,2,3]+aTemp[i,2,4]
		Aadd(aTransf, {aTemp[i,1], aTemp[i,2], aTemp[i,3]})
	EndIf
Next i
Asort(aTransf,,, {|x,y| x[3,1] < y[3,1]})
Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fRAISChk()³ Autor ³ Emerson Rosa/Maurcio MR³15/01/01       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³VerIfica se foi atualizada a rotina da RAIS                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³RAIS                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fRAISChk(cFunc)

Local aArea		:= GetArea()
Local cURL		:= "http://tdn.totvs.com/x/A4nHEw"
Local lRet		:= .T.

cFunc 			:= Alltrim(Upper(cFunc))

Begin Sequence
	//VERIfICA A EXISTENCIA DE FUNCAO PARA A FASE 2
	If !FindFunction(cFunc)
	   	nOpc := Aviso(OemToAnsi(STR0017),  OemToAnsi(STR0021) +  CRLF + OemToAnsi(STR0022), {"OK"}) //##"Atencao"
		// "ESSA ROTINA NÃO ATENDE AOS REQUISITOS DA DECLARAÇÃO DA RAIS PARA O ANO CORRENTE."
		// "OBTENHA A ATUALIZAÇÃO DA RAIS 2005 FASE 2."
		lRet := .F.
		Break
	EndIf
	//VERIfICA A EXECUCAÇÃO DO ATUALIZADOR PARA QUALQUER FASE
	dbSelectArea("SR2")
	If lRet .And. TamSX3("R2_TIPOADM")[1] <> 2
	   	nOpc := Aviso(OemToAnsi(STR0017),  OemToAnsi(STR0019), {"OK"}) //##"Atencao"
		//"A ESTRUTURA DOS ARQUIVOS SR2/SRA  NÃO ESTÃO COMPATÍVEIS COM O ANO BASE CORRENTE."
		lRet := .F.
		Break
	EndIf

	If SR2->( ColumnPos( "R2_VAPRGRV" ) ) == 0
		If MsgYesNo( OemToAnsi( STR0021 ) +  CRLF + OemToAnsi( STR0051 )+  CRLF + OemToAnsi( STR0058 ), OemToAnsi( STR0017 ) )
			shellExecute( "Open", cURL, "", "", SW_NORMAL )
		EndIf

		lRet := .F.
		Break
	EndIf
End

RestArea( aArea )

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fZapCodeBase()³ Autor ³ Emerson Rosa      ³ Data ³ 15/01/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Limpa o arquivo SR2 para uma nova montagem                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM500                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fZapCodeBase(cFilDe, cFilAte, cMatDe, cMatAte, cAnoBase)
Local lRet 		:= .T.
Local cMsgErr	:= ""
Local cFilAnoMat:= ""
Local aSR2Area	:= SR2->(GetArea())
Local aRCUArea	:= RCU->(GetArea())

If Ma280Flock("SR2")  .AND. Ma280Flock("RCU")         // Abre Arquivo SR2 Exclusivo
	OpenIndX("RCU",.F.)
	OpenIndX("SR2",.F.)
	RCU->(DbsetOrder(1))    	// RCU_FILIAL+RCU_ANO+ RCU_MAT +RCU_CEI+ DTOS(RCU_DTADM)
	SR2->(DbsetOrder(5))    	// R2_FILIAL+R2_ANOBASE+R2_MAT
	SR2->(Dbseek(cFilDe+cAnoBase+cMatDe, .T.))
	While SR2->(!Eof() .AND. (R2_ANOBASE) == (cAnoBase) .and.;
							 ((R2_FILIAL+R2_ANOBASE+R2_MAT) <= (cFilATE+cAnoBase+cMatATE)))
			If SR2->((R2_FILIAL < cFilDE) .OR. (R2_FILIAL > cFilATE) .OR. (R2_MAT < cMatDE) .OR. (R2_MAT > cMatATE)) .Or. !(SR2->R2_FILIAL $ fValidFil)
			   SR2->(DBSKIP())
			   Loop
		    EndIf
			//BLOQUEIA O CABECALHO
			If SR2->(RecLock("SR2" , .F.))
				cFilAnoMat:= SR2->(R2_FILIAL + R2_ANOBASE + R2_MAT)
				//PROCURA PELO ITEM DA RAIS
				If RCU->(Dbseek(cFilAnoMat))
					While RCU->(!Eof() .AND. ((RCU_FILIAL +  RCU_ANO + RCU_MAT)  == cFilANoMat))   // Limpa Arquivo
				 		If RCU->(RecLock("RCU" , .F.))
							//ELIMINA OS DADOS DO ARQUIVO RCU DO ANO BASE INFORMADO
							If !RCU->(lDeleted := FkDelete(@cMsgErr))
								RCU->(RollBackDelTran(cMsgErr))
							EndIf
							RCU->(MsUnlock())
							RCU->(FKCOMMIT())
						EndIf
						RCU->(DBSKIP())
					End While
				EndIf
				//ELIMINA OS DADOS DO ARQUIVO SR2 DO ANO BASE INFORMADO
				If !SR2->(lDeleted := FkDelete(@cMsgErr))
					SR2->(RollBackDelTran(cMsgErr))
				EndIf
				SR2->(MsUnlock())
				SR2->(FKCOMMIT())
			EndIf
			SR2->(DBSKIP())
	End While
	SR2->(dbCloseArea())
	RCU->(dbCloseArea())
	ChkFile("RCU",.F.)
	ChkFile("SR2",.F.)
Else
	Help(" ",1,"GP500NOPEN")
	lRet := .F.
EndIf

RestArea(aRCUArea)
RestArea(aSR2Area)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fGravMes()³ Autor ³ Emerson Rosa de Souza ³ Data ³ 25/02/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Grava os rendimentos do ano base mes a mes                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM500                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fGravMes(nMesDe,nMesAte)
Local nFor
Local dDatIni
Local dDatFim
Local dDatUltCat
Local nNroSal 		:= 0
Local nTotal  		:= 0
Local nValMed 		:= 0
Local aComissRcu 	:= {}

fCatRais(@aComissRcu) // Array com os registros de troca de categoria no ano base
nLen := Len(aComissRcu)

//Verifica se houve alteração de categoria para comissionado durante ano base
If  nLen > 0 .AND. cCatFunc == "C"
	dDatUltCat := aComissRcu[nLen, 2]
	//Alteração para considerar acumulados apenas como comissionado, a partir da data de alteração da categoria para comissionado no ano base
	If Year(dDatUltCat) == nAnoBase
		nMesDe := Month(dDatUltCat)
	EndIf
EndIf

For nFor := nMesDe To nMesAte
	cFor := StrZero(nFor,2)
	nTotal += aMensais[nPos_A,nFor]
	//P/ CATEGORIAS ABAIXO UTILIZA OS MESES Q RECEBEU P/ CALC. MEDIA MENSAL DAS REMUNERACOES
	If (cCatFunc $ "I*J*T" .OR. ( cCatFunc $ "C" .AND. nSalario == 0 ) ) .And. aMensais[nPos_A,nFor] > 0
		nNroSal++
	EndIf
Next nFor

If lComissao .Or. cCatFunc $ "C*I*J*T"	//CATEGORIA COMISSIONADO/PROFESSOR AULISTA/TAREFEIRO
	dDatIni := Max(SR2->R2_ADMISSA, dPriDiaAno)
	dDatFim := If(SR2->R2_DESLMMA == "0000", dUltDiaAno,;
			      CTOD(Substr(SR2->R2_DESLMMA,1,2)+"/"+Substr(SR2->R2_DESLMMA,3,2)+"/"+cAnoBase,"DDMMYY"))
	If nNroSal < 1
		nNroSal := fMesesTrab(dDatIni, dDatFim)
		//SE TRABALHOU PELO MENOS 1 DIA NO PERIODO O VALOR DE NNROSAL NAO DEVE SER 0, CASO CONTRARIO O R2_SALARIO TAMBEM SERA 0
  		If nNroSal == 0 .And. (Day(dDatFim) - Day(dDatIni)!= 0)
 			nNroSal := 1
 		EndIf
	EndIf
	nNroSal := Min(nNroSal, 12)
	nValMed := ROUND(nTotal/nNroSal,2)
	//SE TAREFEIRO,SALARIO RAIS =   MEDIA MENSAL DAS REMUNERACOES
	//SE COMISSIONADO E SALARIO = 0,MEDIA MENSAL DAS REMUNERACOES
	//SE COMISSIONADO E SALARIO > 0,SALARIO BASE + MEDIA COMISSOES
	If cCatFunc $ "I*J*T" .OR. ( cCatFunc $ "C" .AND. nSalario == 0 )
			If(nTipMedi == 2 .AND. nVComiss > 0) //Verifica se considera as médias das Remunerações no ano base, ou as médias das verbas informadas para Comissionado.
			SR2->R2_SALARIO += Round(nVComiss/nNroSal,2)
		Else
			SR2->R2_SALARIO := If(nValMed > 0, nValMed, SR2->R2_SALARIO)
		EndIf
	Else
		If SR2->R2_SALARIO > 0
    		If lComissao
				SR2->R2_SALARIO += Round(nVComiss/nNroSal,2)
			EndIf
		Else
			If nTipMedi == 1	//MEDIA DAS REMUNERACOES
				SR2->R2_SALARIO := nValMed
			Else				//MEDIA DAS VERBAS INFORMADAS
				SR2->R2_SALARIO += Round(nVComiss/nNroSal,2)
			EndIf
		EndIf
		If cCatFunc == "C" .And. nSalario == 0 .And. nSalMin > 0 .And. SR2->R2_SALARIO < nSalMin
			SR2->R2_SALARIO := nSalMin
		EndIf
	EndIf
EndIf

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fTipoAdm()³ Autor ³ Emerson Rosa de Souza ³ Data ³ 25/02/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Busca tipo de admissao do funcionario                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM500                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fTipoAdm(cTipoAdm,aTransf)

cTipoAdm := "00"
If Right(SRA->RA_TIPOADM,1) = "A"
	cTipoAdm := "01" //Primeiro Emprego
ElseIf Right(SRA->RA_TIPOADM,1) = "B" .and. (SRA->RA_TIPOADM) <> "4B"
	cTipoAdm := "02" //Reemprego
ElseIf Right(SRA->RA_TIPOADM,2) = "4B"
	cTipoAdm := "05" //
ElseIf Right(SRA->RA_TIPOADM,1) = "C"
	//SOMENTE GRAVAR 4 SE HOUVER TRANSFERENCIA NO ANO
	If Len(aTransf) > 0
		cTipoAdm := "04" 	//Transferencia
	Else
		cTipoAdm := "02" 	//Reemprego
	EndIf
ElseIf SRA->RA_TIPOADM == "51"
	cTipoAdm := "07"		// Reversao (especIfico p/ serv. publico)
ElseIf SRA->RA_TIPOADM == "52"
	cTipoAdm := "09"		// Exerc.provisorio servidor oriundo mesmo/outro orgao/ent
ElseIf SRA->RA_TIPOADM == "53"
	cTipoAdm := "10"   		// Readaptacao (especIfico p/ serv. publico)
ElseIf SRA->RA_TIPOADM == "54"
	cTipoAdm := "11"		// Redistribuicao (especIfico p/ serv. publico)
ElseIf SRA->RA_TIPOADM == "55"
	cTipoAdm := "12"		// Exerc.descentr.servidor oriundo mesmo/outro orgao/ent.
ElseIf SRA->RA_TIPOADM == "56"
	cTipoAdm := "13"		// Remocao (especIfico p/ serv. publico)
EndIf

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fBoxRAIS ³ Autor ³ Emerson Rosa de Souza ³ Data ³ 15/01/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Valida o Codigo de Afastamento RAIS                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM500                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fBoxRAIS()

	Local cOpcBox := ""

	cOpcBox += (STR0029) // "10=Acidente do trabalho tipico (que ocorre no trabalho);"
	cOpcBox += (STR0030) // "20=Acidente do trabalho de trajeto;"
	cOpcBox += (STR0031) // "30=Doenca relacionada ao trabalho;"
	cOpcBox += (STR0032) // "40=Doenca nao relacionada ao trabalho;"
	cOpcBox += (STR0033) // "50=Licenca Maternidade e licenca paternidade;"
	cOpcBox += (STR0034) // "60=Servico militar obritatorio;"
	cOpcBox += (STR0035) // "70=Licença sem vencimento/remuneração;"
	cOpcBox += (STR0059) // "73=Aposentadoria por invalidez, decorrente de acidente do trabalho;"
	cOpcBox += (STR0061) // "74=Aposentadoria por invalidez, decorrente de doença profissional;"
	cOpcBox += (STR0060) // "76=Aposentadoria por invalidez, exceto a decorrente de doença profissional ou acidente do trabalho;"
	cOpcBox += (STR0062) // "85=Suspensão temporária do contrato de trabalho nos termos da Lei 14.020/2020 (conversão da MP 936/2020);"

Return(cOpcBox)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fAfasta  ³ Autor ³ Mauricio MR 			³ Data ³ 14/03/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Obtem os afastamentos da Filial		          	  		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM500                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fAfasta(dAdmissa, dDemissa, aAfast, aAfastFun, aMesAfast)
Local aAfastAux

aAfastFun := aClone(aAfast)
aAfastAux := aClone(aAfastFun)

fFiltraAfa(aAfastAux,@aAfastFun,dAdmissa,dDemissa)

//IDENTIfICA OS MESES DE AFASTAMENTOS QUE NÃO CORRESPONDAM A FERIAS
//COMO SOMENTE EXISTEM AFASTAMENTOS PARA O PERIODO INFORMADO PODEM SER
//SOLICITADOS AFASTAMENTOS DO ANO BASE (A FUNCAO FICA GENERICA)
aMesAfast:= fMesAfast(@aAfastFun, nAnoBase)

// "E.3) PERÍODO DO AFASTAMENTO/LICENÇA: CASO HAJA MAIS DE TRÊS AFASTAMENTOS, RELACIONAR OS DE MAIOR DURAÇÃO"
If Len(aAfastfun) > 3
	aSort(aAfastfun,,, {|x,y| x[2] > y[2]})
EndIf
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fGravAfa ³ Autor ³ Emerson Rosa de Souza ³ Data ³ 15/01/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Grava os afastamentos ocorridos no ano                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM500                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fGravAfa(dAdmissa,dDemissa, aAfast, aMesAfast)
Local cCpoCodigo := ""
Local cCpoDatIni
Local cCpoDatFim
Local nCnt      := 0
Local nCntMes   := 0
Local nDiasAf 	:= 0
Local nMesIni	:= 0
Local nMesFim	:= 0
Local nNumCpo	:= 1  //PRIMEIRO CAMPO DE AFASTAMENTO A SE GRAVADO
Local nDiasPe	:= 0

If Len(aAfast) > 3
	aSort(aAfast,,, {|x,y| x[2] > y[2]})
EndIf
For nCnt := 1 To Len(aAfast)
	If Year(aAfast[nCnt,4]) < nAnoBase .Or. Empty(aAfast[nCnt,5]) .OR. aAfast[nCnt,6] $ '73*74*76'
		Loop //NAO CONSIDERA O AFASTAMENTO TERMINADOS ANTES DO ANO BASE
	EndIf
    //DEFINE OS MESES INICIAL E FINAL DO PERIODO DE AFASTAMENTO
	nMesIni := Month(aAfast[nCnt,3])
	nMesIni := If(nMesIni == 0 .Or. Year(aAfast[nCnt,3]) < nAnoBase, 1, nMesIni)
	nMesFim := Month(aAfast[nCnt,4])
	nMesFim := If(nMesFim == 0 , 14 , nMesFim)
	//TRATA FUNCIONARIO AFASTADO QUE NAO SEJA POR MOTIVO DE FERIAS
	If aAfast[nCnt,5] <> "F"

		// dias pagos pela empresa 15 OU 30
		nDiasPe := aAfast[nCnt,20]

		//Valor contido no aAfast[nCnt,2] é somente do periodo de afastamento do ano gerado
		//Realizado ajuste para considerar também afastamentos com 1 dia pago pelo INSS
		If (aAfast[nCnt,4] - aAfast[nCnt,3] + 1) < nDiasPe+1 .and. aAfast[nCnt,16] $ "O1*P1*P3" //somente para afastamentos tipo O e P verIficar qtd de dias.
			Loop
		EndIf
		//TRATAMENTO PARA AFASTAMENTOS COM DIAS DO INSS MENOR DO QUE 15/30 E DATA FINAL IGUAL ULTIMA DIA DO ANO
		If (aAfast[nCnt,16] $ "O1*P1*P3" .And. aAfast[nCnt,11] < nDiasPe+1 .And. aAfast[nCnt,4] == dUltDiaAno)
			aAfast[nCnt,11] := nDiasPe
		EndIf
		//CALCULA OS DIAS DE AFASTAMENTO (TODOS OS AFASTAMENTOS)
		//SE FOR AFASTAMENTO TIPOS O OU P E ESTIVER AFASTADO DESDE O ANO ANTERIOR, NAO DESCONTA OS DIAS DO INSS
		If (aAfast[nCnt,16] $ "O1*P1*P3" .And. (Year(aAfast[nCnt,3]) <> Year(aAfast[nCnt,4]))) .or. aAfast[nCnt,20] == 999

			If Empty(aAfast[nCnt,4])
				nDiasAf += dUltDiaAno - Max(aAfast[nCnt,3] , dPriDiaAno) + 1
			Else
				nDiasAf += aAfast[nCnt,4] - Max(aAfast[nCnt,3] , dPriDiaAno) + 1
			EndIf

		ElseIf "Q" $ aAfast[nCnt,16] //maternidade
			nDiasAf += aAfast[nCnt,2]
		Else

			If  aAfast[nCnt, 3] < dPriDiaAno
			 	  aAfast[nCnt, 3] := dPriDiaAno
					aAfast[nCnt, 2] := aAfast[nCnt, 4] - aAfast[nCnt, 3] + 1
			Endif

			nDiasAf += (aAfast[nCnt,2]-aAfast[nCnt,19]) //Total dias afastados - Dias a pagar pelo INSS (SR8->R8_DPAGAR)

		EndIf
		//REGISTRA APENAS OS 3 MAIORES AFASTAMENTOS QUE NAO SEJAM DE FERIAS
		If nNumCpo < 4 .AND. !Empty(aAfast[nCnt,6])
			//INVERTE NUMEROS PARA GRAVAR EM ORDEM CRESCENTE
			cCpoCodigo  := "SR2->R2_CODAF" + StrZero(nNumCpo, 2)
			cCpoDatIni  := "SR2->R2_INIAF" + StrZero(nNumCpo, 2)
			cCpoDatFim  := "SR2->R2_FIMAF" + StrZero(nNumCpo, 2)
			nNumCpo ++
			//GRAVA AFATAMENTO NOS CAMPOS DO SR2
			&cCpoCodigo := aAfast[nCnt,6]
			&cCpoDatIni := Max(dPriDiaAno, aAfast[nCnt,3])
			//PARA AFASTAMENTOS SUPERIORES A 15 DIAS (DOENCA/ACIDENTE), A DATA INICIAL SERAH A CEDIDA PELO
			//INSS (A PARTIR DO 16O DIA DO INICIO REAL DO AFASTAMENTO)
			If aAfast[nCnt,16] $ "O1*P1" .and. (aAfast[nCnt,3] >= dPriDiaAno .Or. (Year(aAfast[nCnt,3]) <> Year(aAfast[nCnt,4]) .And. dPriDiaAno - aAfast[nCnt,3] <= aAfast[nCnt,19]))
				&cCpoDatIni := aAfast[nCnt,3]+nDiasPe
				//desconta os dias pagos pela empresa dos dias de afastamento contados quando afastamento inicia-se no ano anterior e há pagamento de INSS no ano atual.
				If Year(aAfast[nCnt,3]) <> Year(aAfast[nCnt,4])
					nDiasAf -= (&cCpoDatIni - dPriDiaAno)
				EndIf
			EndIf
			&cCpoDatFim := If(Empty(aAfast[nCnt,4]), dUltDiaAno, Min(dUltDiaAno, aAfast[nCnt,4]))
		EndIf
		//ZERA HORAS EFETIVAS TRABALHADAS PARA OS MESES EM QUE O FUNCIONARIO ESTEVE AFASTADO
		For nCntMes := nMesIni To nMesFim
			//HORAS EFETIVAS NAO DEVEM SER ENVIADAS NOS MESES DE AFASTAMENTO (INCLUINDO OS MESES DE SAÍDA E RETORNO, MESMO HAVENDO SALARIO NO MES)
			aMensais[nPos_R,nCntMes] := 0
		Next nCntMes
	Else
		//TRATA FUNCIONARIO EM FERIAS
		For nCntMes := nMesIni To nMesFim
			//EM FERIAS, INFORMA AS HORAS 999 SE NÃO FORAM GERADAS/INFORMADAS
			//SOMENTE NOS CASOS EM QUE NÃO OCORRERAM AFASTAMENTOS PARA O MESMO MES
			If  Empty(Ascan(aMesAfast,{|x| x == nCntMes}))
				//NOS CASOS DE FÉRIAS QUE ABRANGEM O MÊS INTEIRO, AS HORAS 999 DEVEM SER INFORMADAS COMO HORAS EFETIVAS
				//NOS CASOS DE FÉRIAS MÊS E FÉRIAS SEGUINTE, AS HORAS EFETIVAS GERADAS NO MÊS, PROPORCIONALMENTE, ATRAVÉS DO SALÁRIO, DEVEM SER INFORMADAS NA RAIS
				If nCntMes < 13 .and. cAnoBase == "2005"
					aMensais[nPos_R,nCntMes] := If(Empty(aMensais[nPos_R,nCntMes]), 999, aMensais[nPos_R,nCntMes])
				EndIf
				//NAO CONSIDERA O AFASTAMENTO POR FERIAS PARA CALCULO DAS REMUNERACOES
				Loop
			Else
				//HORAS EFETIVAS NÃO DEVEM SER ENVIADAS NOS MESES DE AFASTAMENTO
				//(INCLUINDO OS MESES DE SAÍDA E RETORNO, MESMO HAVENDO SALÁRIO NO MÊS)
				aMensais[nPos_R,nCntMes] := 0
			EndIf
        Next nCntMes
	EndIf
Next nCnt

If !Empty(&cCpoCodigo)
	SR2->R2_TDIASAF := nDiasAf
Endif

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³fPertenceSRV ³ Autor ³ Mauricio MR        ³ Data ³ 19/01/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Pertence para SRV (RAIS)                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM500                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static function fPertenceSRV(cConteudo, cListCodRais)
Local lRet  := .F.
Local nX	:= 0

For nX:=1 to Len(cConteudo)
    If  (Substr(cConteudo,nX,1) $ cListCodRais)
        lRet:=.T.
        Exit
    EndIf
Next nX

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³FGravaRCU    ³ Autor ³ Mauricio MR        ³ Data ³ 19/01/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Grava registros "mensais" da RAIS                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM500                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function FGravaRCU(cFilRCU, cMatRCU, cCGCRCU, cCEIRCU, dDtAdmRCU, cAnoRCU, aMensais, nInimes, nFimMes)
Local cPutFilAnt  	:= cFilAnt
Local aRCUArea	  	:= RCU->(GetArea())
Local lAppend		:= .F.
Local nCodRais		:= 0
Local nMeses		:= 0
Local nLenaMensais	:= Len(aMensais)
Local nValor		:= 0

//ATRIBUIÇÃO DA VARIAVEL CFILANT, COM A MESMA FILIAL EM USO, DEVIDO A INTEGRIDADE
cFilAnt	:= SRA->RA_FILIAL

dbSelectArea("RCU")
RCU->(Dbsetorder(2)) //RCU_FILIAL+RCU_ANO+RCU_MAT+RCU_CEI+RCU_MES+RCU_TIPO

//CORRE TODAS AS VERBAS MENSAIS (OPCOES DA RAIS. EX. 'A - RENDIMENTOS', 'B - 1A - PARCELA')
For nCodRais:=1 To nLenaMensais
    //PARA CADA VERBA CORRE OS MESES (CONFORME INFORMADO, GERALMENTE 12)
    For nMeses:=nIniMes to nFimMes
        nValor:= aMensais[nCodRais, nMeses]
		If (nValor > 0)
		    lAppend:= ! (RCU->(Dbseek(cFilRCU + cAnoRCU + cMatRCU + cCEIRCU + STRZERO(nMeses,2) + aCodRais[nCodRais])))
		    If !lAppend
			    AADD(aLog,  {	"DUPLI"									,;
			    				 RCU->RCU_FILIAL	,cFilAnt			,;
								 RCU->RCU_MAT 		,cMatRCU       	 	,;
								 RCU->RCU_CGC		,cCGCRCU        	,;
							 	 RCU->RCU_CEI		,cCEIRCU			,;
								 RCU->RCU_DTADM		,dDtAdmRCU      	,;
								 RCU->RCU_ANO		,cAnoRCU        	,;
								 RCU->RCU_MES		,STRZERO(nMeses,2)	,;
								 RCU->RCU_TIPO		,aCodRais[nCodRais]	,;
								 RCU->RCU_VALOR		,nValor})
		    EndIf
			RCU->(RecLock("RCU",lAppend,.T.))
			RCU->RCU_FILIAL 	:= cFilRCU
			RCU->RCU_MAT 		:= cMatRCU
			RCU->RCU_CGC		:= cCGCRCU
			RCU->RCU_CEI		:= cCEIRCU
			RCU->RCU_DTADM	:= dDtAdmRCU
			RCU->RCU_ANO		:= cAnoRCU
			RCU->RCU_MES		:= STRZERO(nMeses,2)
			RCU->RCU_TIPO		:= aCodRais[nCodRais]
			RCU->RCU_VALOR	:= nValor
			RCU->(MsUnlock())
			RCU->(FKCOMMIT())
		EndIf
	Next nMeses
Next nCodRais

cFilAnt := cPutFilAnt // RESTAURA A CFILIAL DA ENTRADA

RestArea(aRCUArea)

Return Nil

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Funcao    ³DeleteToP		³Autor³Mauricio MR        ³ Data ³19/01/2006³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descricao ³Deleta os Dados do SR2 e RCU Quando TOP                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEM500                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function fZapTop(cAlias, cFilDe, cFilAte, cMatDe, cMatAte, cQueryAnoBase, cSraFilter)
Local cPrefixo 		:= ""
Local cQuery		:= ""
Local cRetSqlName	:= RetSqlName(cAlias)
Local cQryFilter	:= ""
Local cJoin			:= ""

Default cSraFilter 	:= ""

cAlias		:= Upper(AllTrim(cAlias))
cPrefixo	:= (PrefixoCpo(cAlias) + "_")


if !Empty(cSraFilter)
	cJoin 		:= " JOIN " + RetSqlName("SRA") + " SRA ON " + cPrefixo + "MAT = RA_MAT AND " + cPrefixo + "FILIAL = RA_FILIAL "
	cQryFilter 	:= " AND " + fSFiltrSQL(cSraFilter)
EndIf

cQuery := "DELETE FROM " + cRetSqlName + " WHERE R_E_C_N_O_ IN ("
cQuery += " SELECT " + cAlias + ".R_E_C_N_O_ FROM " + cRetSqlName + " " + cAlias
cQuery += cJoin
cQuery += " WHERE "
cQuery += (cPrefixo+"FILIAL >= '"+cFilDe+"'")
cQuery += " AND "
cQuery += (cPrefixo+"FILIAL <= '"+cFilAte+"'")
cQuery += " AND "
cQuery += (cPrefixo+"MAT >='"+cMatDe+"'")
cQuery += " AND "
cQuery += (cPrefixo+"MAT <='"+cMatAte+"'")
cQuery += " AND "
cQuery += (cPrefixo+ cQueryAnoBase)
cQuery += cQryFilter
cQuery += ")"

TcSqlExec(cQuery)


Return(Nil)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Funcao    ³GeraLog   ³ Autor ³Mauricio  MR           ³ Data ³17/02/2006³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descricao ³Emissao do Log de Ocorrencias                               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aLog -> Log com as Ocorrencias Encontradas                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function GeraLog(aLog , cPerg)
Local aTitLog		:= {}
Local aNewLog		:= {}
Local cTamanho		:= "M"
Local cTitulo		:= (STR0023)					//"Log de Ocorrencias na Geracao das Informacoes da RAIS"
Local nLenLog		:= Len(aLog)
Local nLoop			:= 1
Local cPctVlor	    := AllTrim(X3Picture("RCU_VALOR"))
Local cGrupo		:= ""
//ORDENA POR OCORRÊNCIAS
aSort(@aLog , NIL , NIL , {|x,y| (x[1] < y[1])})

//CORRE TODAS AS OCORRENCIAS E AS TRATA CONFORME OS TIPOS IDENTIfICADOS
For nLoop:= 1 to nLenLog
	If  aLog[nLoop,1] == "DUPLI"
	    If cGrupo <> "DUPLI"
	    	cGrupo	:= "DUPLI"
		    AADD(aNewLog, "")
		    AADD(aNewLog, STR0024) // "Foram encontradas mais de uma ocorrencia de verba para o mesmo mes e matricula")
		    AADD(aNewLog, STR0025) // "         Filial Matricula CGC               CEI       Admissao    Ano    Mes  Tipo          VaLor")
	    EndIf
	    AADD(aNewLog, STR0026 + aLog[nLoop, 2] + SPACE(3) + aLog[nLoop, 4] + SPACE(4) + aLog[nLoop, 6] + SPACE(1) + aLog[nLoop, 8] + SPACE(1) + Dtoc(aLog[nLoop, 10]) + SPACE(4) + aLog[nLoop, 12] + SPACE(3) + aLog[nLoop, 14] + SPACE(4) + aLog[nLoop, 16] + SPACE(6) + Transform(aLog[nLoop, 18] , cPctVlor))
	    AADD(aNewLog, STR0027 + aLog[nLoop, 3] + SPACE(3) + aLog[nLoop, 5] + SPACE(4) + aLog[nLoop, 7] + SPACE(1) + aLog[nLoop, 9] + SPACE(1) + dToc(aLog[nLoop, 11]) + SPACE(4) + aLog[nLoop, 13] + SPACE(3) + aLog[nLoop, 15] + SPACE(4) + aLog[nLoop, 17] + SPACE(6) + Transform(aLog[nLoop, 19] , cPctVlor))
 	ElseIf aLog[nLoop,1] == "CPF"
	    If cGrupo <> "CPF"
	    	cGrupo	:= "CPF"
		    AADD(aNewLog, "")
		    AADD(aNewLog, STR0038) // "Foram encontrados funcionarios sem CPF cadastrado"
		    AADD(aNewLog, STR0039) // "Filial    Matricula  Nome"
	    EndIf
	    AADD(aNewLog,  aLog[nLoop, 2] + SPACE(5) + aLog[nLoop, 3]+ space(5) +aLog[nLoop, 4])
 	ElseIf aLog[nLoop,1] == "APRENDIZ"
	    If cGrupo <> "APRENDIZ"
	    	cGrupo	:= "APRENDIZ"
			AADD(aNewLog, "")
			AADD(aNewLog, STR0040) // "Existem funcionarios MENORES de 16 anos com Vinculo dIferente de 55-MENOR APRENDIZ. Funcionario sera enviado "
			AADD(aNewLog, STR0041) // "como existindo Alvara Judicial autorizando o trabalho do menor de 16 anos."
			AADD(aNewLog, STR0042) // "         Filial Matricula Nome             Nascimento   Vinculo Rais")
	    EndIf
	    AADD(aNewLog,  aLog[nLoop, 2] + SPACE(5) + aLog[nLoop, 3]+ space(5) +aLog[nLoop, 4]+ space(5) +Dtoc(aLog[nLoop, 5])+ space(5) + aLog[nLoop, 6])
 	ElseIf aLog[nLoop,1] == "APRENDIZ2"
	    If cGrupo <> "APRENDIZ2"
	    	cGrupo	:= "APRENDIZ2"
		    AADD(aNewLog, "")
		    AADD(aNewLog, STR0043) // "Existem funcionarios MENORES de 14 anos com Vinculo dIferente de 55-MENOR APRENDIZ. Funcionario sera enviado "
			AADD(aNewLog, STR0044) // "como existindo Alvara Judicial autorizando o trabalho do menor de 14 anos."
		    AADD(aNewLog, STR0045) // "         Filial Matricula Nome             Nascimento   Vinculo Rais")
	    EndIf
	    AADD(aNewLog,  aLog[nLoop, 2] + SPACE(5) + aLog[nLoop, 3]+ space(5) +aLog[nLoop, 4]+ space(5) +Dtoc(aLog[nLoop, 5])+ space(5) + aLog[nLoop, 6])
 	ElseIf aLog[nLoop,1] == "APRENDIZ3"
	    If cGrupo <> "APRENDIZ3"
	    	cGrupo	:= "APRENDIZ3"
			AADD(aNewLog, "")
			AADD(aNewLog, STR0046) // "Existem funcionarios MENORES de 16 anos com Vinculo dIferente de 55-MENOR APRENDIZ e que foram contratados em ano"
			AADD(aNewLog, STR0047) // "anterior a 1988. Func.sera enviado como não existindo Alvara Judicial autorizando o trabalho do menor de 16 anos."
			AADD(aNewLog, STR0048) // "Filial    Matricula     Nome                               Nascimento  Vinculo Rais"
	    EndIf
	    AADD(aNewLog,  aLog[nLoop, 2] + SPACE(5) + aLog[nLoop, 3]+ space(5) +aLog[nLoop, 4]+ space(5) +Dtoc(aLog[nLoop, 5])+ space(5) + aLog[nLoop, 6])
 	EndIf
Next nLoop

aLog:= {}

AAdd(aLog, aClone(aNewLog))

fMakeLog(aLog, aTitLog, cPerg, .T., FunName(), cTitulo, "M","P",,.F.)

Return(NIL)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Funcao    ³fMesAfast ³ Autor ³Mauricio  MR           ³ Data ³20/02/2006³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descricao ³IdentIfica os meses de afastamentos para tratar horas efeti-³
³          ³vas para funcionario em ferias.						         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aAfast  -> Outros Afastamentos				                ³
³          ³nAnoBase-> Ano Base da Declaracao                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³aMesAfast- > Meses de Afastamentos				            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function fMesAfast(aAfast, nAnoBase)
Local aMesAfast   	:= {}
Local nAfast 		:= Len(aAfast)
Local nLoop

//CORRE TODOS OS AFASTAMENTOS E IDENTIfICA OS QUE OCORRERAM NO ANOBASE
For nLoop:=1 to nAfast
	If ! (aAfast[nLoop,5] == "F")
	//SE ANO DE INICIO DO AFASTAMENTO FOR ANTERIOR ANO BASE GRAVAR MES INICIO AFASTAMENTO = 01
		If (Year(aAfast[nLoop,3]) < nAnoBase .and. Year(aAfast[nLoop,4]) >= nAnoBase)
		   aAdd(aMesAfast, 1)
		Else
			If Year(aAfast[nLoop,3]) == nAnoBase
			   aAdd(aMesAfast, Month(aAfast[nLoop,3]))
			EndIf
	   EndIf
	   If Year(aAfast[nLoop,4]) == nAnoBase
		   aAdd(aMesAfast, Month(aAfast[nLoop,4]))
	   EndIf
	EndIf
Next nLoop

Return (aClone(aMesAfast))

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Funcao    ³fFiltraAfa       ³Mauricio  MR / KELLY S  ³ Data ³20/02/2006³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descricao ³Filtra afastamentos, ignorando os que nao correspondam ao   ³
³          ³intervalo de entrada e saida                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aAfast  -> Outros Afastamentos				                ³
³          ³nAnoBase-> Ano Base da Declaracao                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³aMesAfast- > Meses de Afastamentos                          ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function fFiltraAfa(aAfaAux,aAfast,dAdmissa,dDemissa)
Local nX
Local dInicio, dFim, dDeslig

aAfast := {}

For nX := 1 to len(aAfaAux)
	dInicio := If(Empty(aAfaAux[nX,3]), dPriDiaAno, aAfaAux[nX,3])
	dFim    := If(Empty(aAfaAux[nX,4]), dUltDiaAno, aAfaAux[nX,4])
	/* "E) INFORMAÇÕES DO AFASTAMENTO/LICENÇA:
	PARA OS AFASTAMENTOS INICIADOS EM ANO-BASE ANTERIOR, A DATA DE INÍCIO A SER DECLARADA SERÁ 1O. DE JANEIRO.
	PARA OS AFASTAMENTOS QUE ULTRAPASSAREM O ANO-BASE, A DATA DO FIM A SER DECLARADA SERÁ 31 DE DEZEMBRO, POIS A
	INFORMAÇÃO PRESTADA REFERE-SE AO ANO-BASE ..." */
	dDeslig := If (dDemissa > '0000' , CTOD(Left(dDemissa,2) + "/" + Right(dDemissa,2) + "/" + cAnoBase), dUltDiaAno)
    //DESCONSIDERA OS AFASTAMENTOS QUE NAO CONTEMPLAM O PERIODO DE PRESENCA DO FUNCIONARIO NA FILIAL
	//SE O INICIO DO AFASTAMENTO FOR POSTERIOR A DATA DE DESLIGAMENTO OU
	//SE O FIM DO AFASTAMENTO FOR ANTES DA DATA DE ADMISSAO
	//DESCONSIDERA O PERIODO DE AFASTAMENTO PARA AQUELA FILIAL
	//DESCONSIDERA FUNCIONÁRIO COM AFASTAMENTO POR INVALIDEZ (CODIGOS: 73,74 e 76)
	If (dInicio > dDeslig) .OR.  (dFim < dAdmissa) .OR. aAfaAux[nX,6] == "73" .OR. aAfaAux[nX,6] == "74" .OR. aAfaAux[nX,6] == "76"
		Loop
    Else
		AADD(aAfast, aClone(aAfaAux[nX]))
        If year(aAfaAux[nX,3])<nAnoBase .and. aAfaAux[nX,16] == "O1" .and. lGerarCEI
	   		aAfast[len(aAfast),3] := aAfast[len(aAfast),3]
		else
			aAfast[len(aAfast),3] := Max(dInicio,dAdmissa)
		EndIf
  		aAfast[len(aAfast),4] := Min(dFim,dDeslig)
  		If (dAdmissa > dInicio) //Tratamento para transferencia durante a ausência
	  		aAfast[len(aAfast),2] := DateDiffDay(aAfast[len(aAfast),3],aAfast[len(aAfast),4]) + 1
			If(DateDiffDay(dInicio,aAfast[len(aAfast),3]) + 1 > aAfast[len(aAfast),20])
				aAfast[len(aAfast),20] := 0
				aAfast[len(aAfast),19] := 0
			EndIf
		EndIf
	EndIf
Next nX

Return

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Funcao    ³fTransfGer       ³Mauricio  MR            ³ Data ³01/03/2006³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descricao ³Seleciona as transferencias conforme o parametro lCCusto ou ³
³          ³seja entre Filiais ou por CEI.						         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aTransf      -> Array de retorno das transferencias         ³
³          ³aTransfAll   -> Array com todas as transferencias da filial ³
³          ³               corrente  (do SRA corrente)                  ³
³          ³nAnoBase     -> Ano Base da Declaracao                      ³
³          ³lCCusto      -> .T. Para geracao por CEI, apenas as transfe-³
³          ³                rencias entre Centro de Custo para a mesma  ³
³          ³                filial.										  ³
³          ³               .F. Para geracao por Filial.					  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Nil                                  			            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function fTransfGer(aTransf, aTransfAll,  nAnoBase, lCCusto)

	Local aTemp	:= {}
	Local nPos
	Local nLoop

	For nLoop := 1 to Len(aTransfAll)
		//SOMENTE GRAVAR ANO BASE IGUAL AO ANO DA TRANSFERENCIA E MES/ANO DA TRANSFERENCIA MAIOR QUE MES/ANO DA ADMISSAO
		If Year(aTransfAll[nLoop, 3, 1]) == nAnoBase
			//SE A TRANSFERENCIA FOR DENTRO DA EMPRESA CORRENTE ((DE == FILIAL CORRENTE OU PARA == FILIAL CORRENTE))
			//OU SE A TRANSFERENCIA FOR PARA A EMPRESA CORRENTE (PARA = CEMPANT)
			If (aTransfAll[nLoop,2,1] == cEmpAnt)  .And.;
				(((SRA->RA_FILIAL == aTransfAll[nLoop,2,2]) .OR. (SRA->RA_FILIAL == aTransfAll[nLoop,1,2]);
				.And. lCCusto ) .Or.;
				((((aTransfAll[nLoop,2,2]  # aTransfAll[nLoop,1,2])) .or. (aTransfAll[nLoop,1,1] # aTransfAll[nLoop,2,1])) .And. !lCCusto))

				//SE HOUVER TRANSFERENCIA NO MESMO MES/ANO, CONSIDERAR APENAS A PRIMEIRA TRANSFERENCIA "DE" E A ULTIMA "PARA"
				nPos := Ascan(aTemp, {|X| MesAno(X[3,1]) == MesAno(aTransfAll[nLoop,3,1])})
				If nPos > 0
					If aTemp[nPos,3,1] < aTransfAll[nLoop,3,1]
						aTemp[nPos,2,1] := aTransfAll[nLoop,2,1]
						aTemp[nPos,2,2] := aTransfAll[nLoop,2,2]
						aTemp[nPos,2,3] := aTransfAll[nLoop,2,3]
						aTemp[nPos,2,4] := aTransfAll[nLoop,2,4]
		   				aTemp[nPos,3,1] := aTransfAll[nLoop,3,1]
					EndIf
				Else
					Aadd(aTemp, {	{aTransfAll[nLoop,1,1], aTransfAll[nLoop,1,2], aTransfAll[nLoop,1,3], aTransfAll[nLoop,1,4]},;
	   							  	{aTransfAll[nLoop,2,1], aTransfAll[nLoop,2,2], aTransfAll[nLoop,2,3], aTransfAll[nLoop,2,4]},;
	   							   	{aTransfAll[nLoop,3,1]}})
				EndIf
			EndIf
		EndIf
	Next nLoop

	//SE GERACAO POR CENTRO DE CUSTO LIMPA AS TRANSFERENCIAS ENTRE FILIAIS, SE HOUVER, E CONSIDERA SOMENTE TRANSF ENTRE C.CUSTO
	If lCCusto .And. Len(aTemp) > 0
		aTransf	:={}
	EndIf

	For nLoop := 1 To Len(aTemp)
		If aTemp[nLoop,1,1]+aTemp[nLoop,1,2]+aTemp[nLoop,1,3]+aTemp[nLoop,1,4] # ;
	       aTemp[nLoop,2,1]+aTemp[nLoop,2,2]+aTemp[nLoop,2,3]+aTemp[nLoop,2,4]
			Aadd(aTransf, {aTemp[nLoop,1], aTemp[nLoop,2], aTemp[nLoop,3]})
		EndIf
	Next i

	Asort(aTransf,,, {|x,y| x[3,1] < y[3,1]})

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fCatRais ³ Autor ³ Ricardo Berti         ³ Data ³ 20/06/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Obter dados do hist. sal. do ano base (cat.func., cargo)   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM500                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fCatRais(aComissRcu)
Local aArea	:= GetARea()
Local dData

Default aComissRcu := {}

//OBTEM MAIOR SALARIO DO ANO BASE
dbSelectArea("SR3")
dbSetOrder(1)
dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+cAnoBase)
If Eof()
	dbSeek(SRA->RA_FILIAL+SRA->RA_MAT)
EndIf

dData := SR3->R3_DATA - 1
While !Eof() .And. SRA->RA_FILIAL+SRA->RA_MAT == SR3->R3_FILIAL+SR3->R3_MAT .And. Year(SR3->R3_DATA) <= nAnoBase
	If (SR3->R3_PD == "000") .and. ;
	   ((SR3->R3_DATA > dData) .or. ;
	     (SR3->R3_DATA = dData) .and. (SR3->R3_VALOR > nSalario))
		nSalario	:= SR3->R3_VALOR
		dData		:= SR3->R3_DATA
	EndIf
	dbSkip()
Enddo

dbSelectArea("SR7")
dbSetOrder(2)
dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+cAnoBase)
If Eof()
	dbSeek(SRA->RA_FILIAL+SRA->RA_MAT)
EndIf

dData := SR7->R7_DATA - 1
While !Eof() .And. SRA->RA_FILIAL+SRA->RA_MAT == SR7->R7_FILIAL+SR7->R7_MAT .And. Year(SR7->R7_DATA) <= nAnoBase
	If (SR7->R7_DATA >= dData)
		cCatFunc	:= SR7->R7_CATFUNC
		dData		:= SR7->R7_DATA
		cFuncao	:= SR7->R7_FUNCAO
		If (Year(dData) == nAnoBase)
			Aadd(aComissRcu,{cCatFunc, dData, cFuncao})
		EndIf
	EndIf
	dbSkip()
Enddo

RestArea(aArea)
Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³VerificaCEI ºAutor  ³Joao Balbino        º Data ³  22/03/2016 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Tratamento de tranferência com o mesmo CEI                 º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEM500                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function VerificaCEI(aTransf)

Local aAreaCTT := CTT->(GetArea())
Local cAntCEI := ""
Local cCEI := ""
Local nCont := 0
Local lRet := .F.

DbSelectArea("CTT")
DbSetOrder(1)

For  nCont := 1 To Len(aTransf[1])

	If Len(aTransf[1,nCont]) > 1
		If CTT->( DbSeek( xFilial("CTT") +  aTransf[1,nCont,3] ) )
			If Empty(cCEI)
				cCEI := CTT_CEI
			ElseIf cCEI != CTT_CEI
				lRet := .T.
				Exit
			EndIf
		EndIf
	EndIf

Next nCont
RestArea(aAreaCTT)

Return lRet

/*/{Protheus.doc} OpenTDN
Abre o navegador padrão com a página centralizadora sobre a RAIS no TDN
@author cicero.pereira
@since 11/01/2018
@version 12.1.17
/*/
Static Function OpenTDN(oSelf)

	cURL := "http://tdn.totvs.com/x/A4nHEw"

	shellExecute("Open", cURL, "", "", SW_NORMAL)

	oSelf:oWnd:End()

Return


/*/{Protheus.doc} FIncrRais
//TODO Descrição auto-gerada.
@author paulo.inzonha
@since 01/03/2019
@version 1.0
@return ${return}, ${return_description}
@param aInfo, array, descricao
@param cFil, characters, descricao
@param cInscr, characters, descricao
@param cTpInscr, characters, descricao
@type function
/*/
Function FIncrRais(aInfo,cFil,cInscr,cTpInscr)
Local cCEIObra 	:= ""
Local cCAEPF 	:= ""

Default cTpInscr := ""

//Tipo de Inscrição do responsável:1- CNPJ 3- CEI/CNO 4-CPF 5- CAEPF

If fBuscaOBRA( cFil, @cCEIObra ) .AND. VAL(cAnoBase) >= 2018
	cTpInscr := "3" // Tipo da inscricao
	cInscr 	 := cCEIObra // Codigo da inscricao
ElseIf fBuscaCAEPF( cFil, @cCAEPF ).AND. VAL(cAnoBase) >= 2018
	cTpInscr := "5"
	cInscr	 := cCAEPF
Else
	cTpInscr 	:= If(aInfo[15] = 1 , "3", If(aInfo[15] = 3, "4", "1"))
	cInscr 		:= If( Len(aInfo) >= 27 .And. !Empty( aInfo[27] ), aInfo[27], aInfo[8] )
EndIf

Return

/*/{Protheus.doc} FSMOQQ
//TODO FUNÇÃO DE RETORNO DE FILIAIS + CODIGO DE MUNICIPIO
@author eduardo.vicente
@since 02/04/2019
@version 1.0
@param aCnpjFil, array, array de filiais
/*/
Function FSMOQQ(aCnpjFil)

Local nX		:= 0
Local aALSSM0	:= SM0->(GETAREA())

Default aCnpjFil:= {}

dbSelectArea("SM0")
SM0->(dbGoTop())
While SM0->(!Eof())
	Aadd(aCnpjFil, {SM0->M0_CODIGO, FWGETCODFILIAL, SM0->M0_CGC,  SM0->M0_CODMUN})
	SM0->(dbSkip())
EndDo
RestArea(aAlsSM0)

Return .T.
