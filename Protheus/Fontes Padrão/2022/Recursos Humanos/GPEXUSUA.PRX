#INCLUDE "GPEXUSUA.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "HEADERGD.CH"

Static cRotCalc 	:= ""
Static cRotTipo 	:= ""
Static __aRotCalc	:= {}
Static lGestPubl	:= IIF(ExistFunc("fUsaGFP"), fUsaGFP(), .F.)
Static lIntTaf 		:= ((SuperGetMv("MV_RHTAF",, .F.) == .T.) .AND. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 1 )
Static cRotMod 		:= " " 

/*
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FGeraVerba³ Autor ³ J.Ricardo                 	  ³ Data ³ 20.12.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao Para Adicionar Verbas na Matriz                          		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCod       =  Codigo da Verba                                   		³±±
±±³          ³ nValor     =  Valor da Verba                                    		³±±
±±³          ³ nHoras     =  Horas da Verba  --   Opcional                     		³±±
±±³          ³ cSem       =  Semana da Verba --   Opcional                     		³±±
±±³          ³ cCct       =  Centro de Custo --   Opcional                     		³±±
±±³          ³ cTip1      =  Tipo da Verba   --   Horas Dias Valor             		³±±
±±³          ³ cTip2      =  Origem da Verba --   Opcional                     		³±±
±±³          ³ nPar       =  Parcela da Verba--   Opcional                     		³±±
±±³          ³ cDel       =  se Deletada "D" --   Opcional                     		³±±
±±³          ³ cMes       =  Data de Pagto da Verba                            		³±±
±±³          ³ lAltera    =  se permite alterar caso exista o codigo           		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ no roteiro de calculo                                           		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³              ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS/FNC  	 ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Leandro Dr. ³27/09/12³M12RH01         ³Unificao da Folha. Projeto Versao 12.     ³±±
±±³            ³        ³RHU210_04_01 	 ³                                          ³±±
±±³Claudinei S.³25/11/14³TQVPV8          ³Alterada a fBuscaAcmPer() para que possa  ³±±
±±³            ³        ³                ³buscar valores de PLR de transferencias.  ³±±
±±³Flavio Corre³22/06/15³TSRHGG          ³Ajuste na busca da SR para ferias,        ³±±
±±³            ³        ³                ³RR_DATA = RH_DATAINI                      ³±±
±±³Allyson M   ³22/01/16³TUDHS0          ³Ajuste em GravaDissidio() p/ buscar os    ³±±
±±³            ³        ³                ³dias de ferias e ferias mes seguinte no   ³±±
±±³            ³        ³                ³periodo p/ que as verbas de ferias do mes ³±±
±±³            ³        ³                ³seguinte nao sejam geradas com diferenca a³±±
±±³            ³        ³                ³pagar.									³±±
±±³Raquel Hager³24/02/16³TUNV61          ³Inclusao do parametro DDATAREF na funcao 	³±±
±±³            ³        ³                ³fGeraVerba.                              	³±±
±±³Cícero Alves³11/10/16³TWCVHH          ³Ajuste na função fGetRotOrdinar para 		³±±
±±³            ³        ³                ³verificar a filial da SRY					³±±
±±³Renan Borges³14/12/16³MRH-2445   	 ³Ajuste para que o calculo do dissidio re-	³±±
±±³			   ³        ³          	  	 ³troativo considere a diferença de férias 	³±±
±±³			   ³        ³          	  	 ³já pagas no calculo da folha.            	³±±
±±³Gabriel A.  ³27/12/16³MRH-3015   	 ³Alteração para associar o fonte à Issue. 	³±±
±±³Allyson M   ³03/02/17³MRH-5876		 ³Ajuste na GravaDissidio p/tratar o Id.1412³±±
±±³            ³        ³				 ³que eh referente a devolucao do Inss.     ³±±
±±³Silvia Tag. ³28/09/18³DRHGFP-1700     ³Tratamento na funcao fGetcalcRot para     ³±±
±±³            ³        ³                ³Folha Mista varios roteiros c/ mesmo tipo ³±±
±±³M.Camargo   ³20/12/18³DMINA-5150      ³Tratamento a funcion fgetRotOrdinary      ³±±
±±³            ³        ³                ³envié mensjae a usuario si no se encuentra³±±
±±³            ³        ³                ³periodo de nómina ordinaria para paises   ³±±
±±³            ³        ³                ³diferentes a brasil.                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FGeraVerba(cCod,nValor,nHoras,cSem,cCct,cTip1,cTip2,nPar,cDel,cMes,lAltera,nValInfo,nHorInfo,cSeq,cNumID,lPropDia,cItCt,cClVl,dDataRef,lNewValor,cConvoc, lIncorp, cLotPLS, cCodRda)


If Type( "CROTEIRO" ) == "U" // Verificar se o mnemonico esta criado - Para o Mexico nao existe esse variavel e nao sera criado por enquanto.
	cRoteiro := GetRotExec()
EndIf

If Type( "CTIPOROT" ) == "U" // Verificar se o mnemonico esta criado - Para o Mexico nao existe esse variavel e nao sera criado por enquanto.
	cTipoRot := fGetTipoRot( cRoteiro )
EndIf

DEFAULT lPropDia := .F.
DEFAULT dDataRef := CtoD("//")
DEFAULT lNewValor:= IsInCallStack("S_GRADIFER") //Se estiver sendo executada fórmula de gravação das férias, passa este parametro como .T. para fmatriz, desta forma, se a verba já existir no aPd, será retornado o valor dela.
DEFAULT lIncorp  := RetValSRV(cCod, SRA->RA_FILIAL, "RV_INCORP") == "S"
DEFAULT cLotPLS	 := ""
DEFAULT cCodRda	 := ""

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Localizar a que tipo pertence o roteiro					   ³
³ 1-Folha de Pagamento    2-Adiantamento    3-Ferias		   ³
³ 4-Rescisao              5-13o. 1a Parc    6-13o. 2a Parc     ³
³ 7-Outros                                           		   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

Default cTip2	:= GetTipo2( cTipoRot )

nValor := fMatriz(cCod, nValor, nHoras, cSem, cCct, cTip1, cTip2, nPar, cDel, cMes, lAltera, cSeq, Nil, cItCt, cClVl, cNumID, Nil, Nil, dDataRef, lPropDia, nValInfo,lNewValor,cConvoc,lIncorp,cLotPLS,cCodRda)

If ValType(nValor) == "U"
	nValor := 0
EndIf

Return( nValor )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FMatriz   ³ Autor ³ Mauro                ³ Data ³ 23.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao Para Adicionar Verbas no Objeto 					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCod       =  Codigo da Verba                              ³±±
±±³          ³ nValor     =  Valor da Verba                               ³±±
±±³          ³ nHoras     =  Horas da Verba  --   Opcional                ³±±
±±³          ³ cSem       =  Semana da Verba --   Opcional                ³±±
±±³          ³ cCct       =  Centro de Custo --   Opcional                ³±±
±±³          ³ cTip1      =  Tipo da Verba   --   Horas Dias Valor        ³±±
±±³          ³ cTip2      =  Origem da Verba --   Opcional                ³±±
±±³          ³ nPar       =  Parcela da Verba--   Opcional                ³±±
±±³          ³ cDel       =  se Deletada "D" --   Opcional                ³±±
±±³          ³ cMes       =  Data de Pagto da Verba                       ³±±
±±³          ³ lAltera    =  se permite alterar caso exista o codigo      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ no roteiro de calculo                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fXMatriz(cCod,nValor,nHoras,cSem,cCct,cTip1,cTip2,nPar,cDel,cMes,lAltera,nValInfo,nHorInfo,cSeq,cNumID,cCodFunc)

Local aCpos
Local aCnts
Local aCposKey
Local aCntsKey

DEFAULT cCod	:= Space( GetSx3Cache( "RV_COD" , "X3_TAMANHO" ) )
DEFAULT nValor	:= 0
DEFAULT nHoras	:= 0
DEFAULT cSem := 0
DEFAULT cCct	:= SRA->RA_CC
DEFAULT cTip1	:= "V"
DEFAULT nPar	:= 0
DEFAULT cMes	:= ctod("//")
DEFAULT lAltera := .F.
DEFAULT cSeq	:= ""
DEFAULT cNumID	:= ""
DEFAULT nValInfo := 0
DEFAULT nHorInfo := 0


/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Fixar o Nro. de Pagamento devido a integridade com a tabela  ³
³ RCH. 														   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
cSem	:= GetNumPgCalc()

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ A funcao fincide foi substituida pela funcao fo_somaincsrv   ³
³ e devera ser utilizada no momento do calculo, ou seja, nas   ³
³ formulas.                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

If cSem == Nil
	cSem := Space( GetSx3Cache( "RC_SEMANA" , "X3_TAMANHO" ) )
EndIf
If cPeriodo == Nil
	cPeriodo := Space( GetSx3Cache( "RC_PERIODO" , "X3_TAMANHO" ) )
EndIf

//Alterado as variaveis cTipoRot e cRoteiro que estavam sendo declaradas como Local e na verdade sao Mnemonicos.
//no calculo das ferias os Mnemonicos cTipoRot e cRoteiro estavam sendo carregandos com o ultimo roteiro do Sistema, devera ser verificado o porque
If Type( "CTIPOROT" ) == "U" // Verificar se o mnemonico esta criado - Para o Mexico nao existe esse variavel e nao sera criado por enquanto.
	cTipoRot := ""
EndIf
If Type( "CROTEIRO" ) == "U" // Verificar se o mnemonico esta criado - Para o Mexico nao existe esse variavel e nao sera criado por enquanto.
	cRoteiro := GetRotExec()
EndIf

If cRoteiro = nil .or. Empty(cRoteiro)
   cRoteiro := GetRotExec()
EndIf

If cTipoRot = nil .or. Empty(cTipoRot)
   cTipoRot := fGetTipoRot( cRoteiro )
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Localizar a que tipo pertence o roteiro					   ³
³ 1-Folha de Pagamento    2-Adiantamento    3-Ferias		   ³
³ 4-Rescisao              5-13o. 1a Parc    6-13o. 2a Parc     ³
³ 7-Outros                                           		   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

If Empty( cTip2 )
	cTip2	:= GetTipo2( cTipoRot )
EndIf

IF ( cTipoRot $ "5/2/1/6/9" )
	aCpos	:= Array( 16 )
	aCnts	:= Array( 16 )
	If SRC->(FieldPos("RC_CODFUNC")) > 0
		aCpos	:= Array( 17 )
		aCnts	:= Array( 17 )
	EndIf
	aCpos[01] := "RC_PD"		; aCnts[01] := cCod
	aCpos[02] := "RC_VALOR"		; aCnts[02] := nValor
	aCpos[03] := "RC_HORAS"		; aCnts[03] := nHoras
	aCpos[04] := "RC_SEMANA"	; aCnts[04] := cSem
	aCpos[05] := "RC_CC"		; aCnts[05] := cCct
	aCpos[06] := "RC_TIPO1"		; aCnts[06] := cTip1
	aCpos[07] := "RC_TIPO2"		; aCnts[07] := cTip2
	aCpos[08] := "RC_PARCELA"	; aCnts[08] := nPar
	aCpos[09] := "RC_DATA"		; aCnts[09] := cMes
	aCpos[10] := "RC_PERIODO"	; aCnts[10] := cPeriodo
	aCpos[11] := "RC_ROTEIR"	; aCnts[11] := cRoteiro
	aCpos[12] := "RC_VALINFO"	; aCnts[12] := nValInfo
	aCpos[13] := "RC_HORINFO"	; aCnts[13] := nHorInfo
	aCpos[14] := "RC_SEQ"		; aCnts[14] := cSeq
	aCpos[15] := "RC_NUMID"		; aCnts[15] := cNumID

	IF (;
			!Empty( cDel );
			.and.;
			( cDel == "D" );
		)
		aCpos[16] := "GDDELETED"	; aCnts[16] := .T.
	Else
		aCpos[16] := "GDDELETED"	; aCnts[16] := .F.
	EndIf
	If SRC->(FieldPos("RC_CODFUNC")) > 0
		aCpos[17] := "RC_CODFUNC"	; aCnts[17] := cCodFunc
   EndIf
	IF ( lAltera )
		aCposKey := Array( 06 )
		aCntsKey := Array( 06 )
		aCposKey[01] := "RC_PD"			; aCntsKey[01] := cCod
		aCposKey[02] := "RC_SEMANA"		; aCntsKey[02] := cSem
		aCposKey[03] := "RC_CC"			; aCntsKey[03] := cCct
		aCposKey[04] := "RC_ROTEIR"		; aCntsKey[04] := cRoteiro
		aCposKey[05] := "RC_PERIODO"	; aCntsKey[05] := cPeriodo
		aCposKey[06] := "RC_SEQ"		; aCntsKey[06] := cSeq
	EndIf
	oSrc:Add( aCpos , aCnts , aCposKey , aCntsKey )
ElseIf ( cTipoRot $ "3/4" )
	aCpos	:= Array( 16 )
	aCnts	:= Array( 16 )
	If SRR->(FieldPos("RR_CODFUNC")) > 0
		aCpos	:= Array( 17 )
		aCnts	:= Array( 17 )
	EndIf
	aCpos[01] := "RR_PD"		; aCnts[01] := cCod
	aCpos[02] := "RR_VALOR"		; aCnts[02] := nValor
	aCpos[03] := "RR_HORAS"		; aCnts[03] := nHoras
	aCpos[04] := "RR_SEMANA"	; aCnts[04] := cSem
	aCpos[05] := "RR_CC"		; aCnts[05] := cCct
	aCpos[06] := "RR_TIPO1"		; aCnts[06] := cTip1
	aCpos[07] := "RR_TIPO2"		; aCnts[07] := cTip2
	aCpos[08] := "RR_DATAPAG"	; aCnts[08] := cMes
	aCpos[09] := "RR_TIPO3"		; aCnts[09] := IF( ( cTip2 == "K" ) , "F" , "R" )
	aCpos[10] := "RR_PERIODO"	; aCnts[10] := cPeriodo
	aCpos[11] := "RR_ROTEIR"	; aCnts[11] := cRoteiro
	aCpos[12] := "RR_VALINFO"	; aCnts[12] := nValInfo
	aCpos[13] := "RR_HORINFO"	; aCnts[13] := nHorInfo
	aCpos[14] := "RR_SEQ"		; aCnts[14] := cSeq
	aCpos[15] := "RR_NUMID"		; aCnts[15] := cNumID

	IF (;
			!Empty( cDel );
			.and.;
			( cDel == "D" );
		)
		aCpos[16] := "GDDELETED"	; aCnts[16] := .T.
	Else
		aCpos[16] := "GDDELETED"	; aCnts[16] := .F.
	EndIf
	If SRR->(FieldPos("RR_CODFUNC")) > 0
		aCpos[17] := "RR_CODFUNC"	; aCnts[17] := cCodFunc
   EndIf
	IF ( lAltera )
		aCposKey := Array( 06 )
		aCntsKey := Array( 06 )
		aCposKey[01] := "RR_PD"			; aCntsKey[01] := cCod
		aCposKey[02] := "RR_SEMANA"		; aCntsKey[02] := cSem
		aCposKey[03] := "RR_CC"			; aCntsKey[03] := cCct
		aCposKey[04] := "RR_ROTEIR"		; aCntsKey[04] := cRoteiro
		aCposKey[05] := "RR_PERIODO"	; aCntsKey[05] := cPeriodo
		aCposKey[06] := "RR_SEQ"		; aCntsKey[06] := cSeq
	EndIf
	oSrr:Add( aCpos , aCnts , aCposKey , aCntsKey )
EndIf

Return( nValor )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetTipoRot     ³Autor³Marinaldo de jesus  ³ Data ³18/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Tipo de Roteiro                         		 	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³cTipo 														 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GENERICO													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGetTipoRot( cRoteiro )

Local aArea 	:= GetArea()
Local aAreaSRY  := SRY->( GetArea() )
Local cTipo

If cRoteiro != SRY->RY_CALCULO
	DbSelectArea( "SRY" )
	DbSetOrder( RetOrder( "SRY", "RY_FILIAL+RY_CALCULO" ) )
	DbSeek( xFilial("SRY") + cRoteiro, .F. )
EndIf

If SRY->( !Eof() )
	cTipo := SRY->RY_TIPO
EndIf

RestArea( aAreaSRY )
RestArea( aArea )


Return( cTipo )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetTipo2		³Autor³Marinaldo de jesus  ³ Data ³18/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Conteudo para ??_TIPO2 conforme Roteiro			 	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³cTipo2														 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GENERICO													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetTipo2( cTipoRot )

Local cTipo2 := "I"

DEFAULT cTipoRot := ""

IF( cTipoRot == "5" ) 		// 13o. 1a. Parcela
	cTipo2 := "P"
ElseIf( cTipoRot == "6" ) 	// 13o. 2a. Parcela
	cTipo2 := "S"
ElseIf( cTipoRot == "2" ) 	// Adiantamento
	cTipo2 := "A"
ElseIf ( cTipoRot $ "3|L|M" ) 	// Ferias
	cTipo2 := "K"
ElseIf ( cTipoRot $ "1|9|F|O" )	// Folha de Pagamento / Autonomos / BOP
	cTipo2 := "C"
ElseIf ( cTipoRot == "4" ) 	// Rescisao
	cTipo2 := "R"
ElseIf ( cTipoRot == "7" ) 	// Rescisao
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Para o tipo outros trazer como C, pois nao afetara os demais ³
	³ programas.                                                   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cTipo2 := "C"
ElseIf ( cTipoRot $ "A|B" .And. cPaisLoc == "BOL" ) // Provisao / Quinquenio
	cTipo2 := "C"			// Calculado
Else						// Outros
	cTipo2 := "I"			// Informado
EndIf

Return( cTipo2 )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetRotOrdinar  ³Autor³Mauricio T. Takakura³ Data ³05/07/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna o Roteiro Ordinario                     		 	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³cRotOrdinar													 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GENERICO													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGetRotOrdinar( lTransfEmp, cFilProc, Modulo, lActMsg, lAuto)

Local aArea 		:= GetArea()
Local cRotOrdinar   := ""
Local cAliasSRY		:= "SRY"
Local lOpenEmp		:= .F.
Local cFilSRY		:= ""
Local cTpMod		:= " |1|3"
Local lSRYModulo	:= SRY->(ColumnPos("RY_MODULO")) > 0
Local lModLog 		:= .F.

DEFAULT	lTransfEmp	:= .F.
DEFAULT Modulo  	:= ""
DEFAULT lGestPubl 	:= .T.
Default lActMsg	:= .F.
Default lAuto 		:= .F.
Static cOrdinary	:= ""
Static __cFilRot__ 	:= Space( FwSizeFilial() )
Static __cModulo__ 	:= ""

DEFAULT cFilProc := ""

Begin Sequence

	If lGestPubl .And. lSRYModulo
		If Empty(Modulo)
		   Modulo := cModulo
		Endif

		lModLog := .T.
		If Modulo == "GPE"
			cTpMod := " |1|3"
		ElseIf Modulo == "GFP"
			cTpmod := "2|3"
		Else
			If SRA->RA_REGIME == "2"
				cTpmod := "2|3"
			Else
				cTpMod := " |1|3"
			EndIf
		Endif
	Endif
	IF !Empty( cFilProc ) .And. !( Empty( cOrdinary ) .Or. !( __cFilRot__ == cFilProc )  .Or. !(Modulo == __cModulo__))
		cRotOrdinar := cOrdinary
		Break
	EndIf

	__cFilRot__ := cFilProc

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se existe no arquivo de Processo                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea( "SRY" )
	DBSetOrder(1)
	IF ( lTransfEmp )
		IF !( fAbrEmpresa( "SRY" , 1 ) )
			Break
		EndIf
		cAliasSRY		:= "GPESRY"
		lOpenEmp		:= .T.
	EndIf

	If Empty( cFilProc )
		cFilSRY := xFilial( "SRY" )
	Else
		cFilSRY := xFilial( "SRY", cFilProc )
	EndIf

	(cAliasSRY)->( DbGoTop() )
	(cAliasSRY)->( DbSeek( cFilSRY ) )
	While (cAliasSRY)->( !Eof() .AND. (cAliasSRY)->RY_FILIAL = cFilSRY)
		If (cAliasSRY)->RY_ORDINAR == "1" .AND. (cAliasSRY)->RY_FILIAL = cFilSRY .AND. If( lModLog, SRY->RY_MODULO $ cTpMod , .T. )
			cRotOrdinar := (cAliasSRY)->RY_CALCULO
			If lSRYModulo
				__cModulo__ :=  SRY->RY_MODULO
			EndIf
			Exit
		EndIf
		(cAliasSRY)->( DbSkip() )
	EndDo

	cOrdinary := cRotOrdinar
   If cPaisLoc <> "BRA" .and. funname()== "GPEA010" .and. Empty(cOrdinary) .and. lActMsg .and. !lAuto
		Msgalert(STR0026 + cFilSRY ) // "No se encontró registro de procedimiento de nómina  ordinaria(RY_ORDINAR=1) para la sucursal "
   EndIf
End Sequence

If lOpenEmp
	fFecEmpresa( "SRY" )
EndIf

RestArea( aArea )

Return( cRotOrdinar )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FBuscaPd  ³ Autor ³ Equipe Advanded RH   ³ Data ³ 02.01.96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna a somatoria das horas ou valores dos c¢digos soli- ³±±
±±³          ³ citados.                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCodigos   =  String contendo os codigos a serem somados   ³±±
±±³          ³ nValor     =  separados por ",".                           ³±±
±±³          ³ cTipo      =  "H" ou "V" somar as horas ou valores         ³±±
±±³          ³ cSem       =  Numero da semana                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Exemplo   ³ FBuscaPd("101,103,105","V","01"                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Marinaldo   ³04/06/04³------³Utilizar o Objeto para soma dos valores   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function FBuscaPD( cCodigos , cTipo , cSem, cPeriodo, cRoteiro )

Local aKeySeek := {}
Local aValSeek := {}

Local cCodPd
Local cRotDefault := GetRotExec()

Local nValor	:= 0
Local cTipoRot

Local nLoop
Local nLoops

Local oObj

DEFAULT cTipo	:= "V"

If cPaisLoc $ "BRA|PAR|CHI"
	nTipo 		:= If(cTipo=Nil .Or. cTipo="V",5,4)
	cSem  		:= If(cSem=Nil,cSemana,cSem)
	nLoops	 	:= Len(aPd)

	For nLoop := 1 to nLoops

	 	If aPd[nLoop,1] $ cCodigos .And. aPd[nLoop,3] = cSem .And. aPd[nLoop,9] # "D"
	        If RetValSRV(aPd[nLoop,1],cFilial,"RV_TIPOCOD") == "2"
	            nValor -= aPd[nLoop,nTipo]
	        Else
	            nValor += aPd[nLoop,nTipo]
	        EndIf
		EndIf

	Next nLoop
Else

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Localizar a que tipo pertence o roteiro					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cTipoRot  := fGetTipoRot( cRotDefault )

	IF( cTipoRot $ "1/2/5/9/6" ) // Folha de Pagamento, Adiantamento, 13o. 1a Parc, 13o. 2a Parc
		oObj 			:= oSrc
		IF ( cTipo == "H" )
			cCpoSoma	:= "RC_HORAS"
		Else
			cCpoSoma	:= "RC_VALOR"
		EndIf

		aAdd( aKeySeek, "RC_PD" )
		aAdd( aValSeek, "" )
		IF cSem != Nil
			aAdd( aKeySeek, "RC_SEMANA" )
			aAdd( aValSeek, cSem )
		EndIf
		IF cPeriodo != Nil
			aAdd( aKeySeek, "RC_PERIODO" )
			aAdd( aValSeek, cPeriodo )
		EndIf
		IF cRoteiro != Nil
			aAdd( aKeySeek, "RC_ROTEIR" )
			aAdd( aValSeek, cRoteiro )
		EndIf
	ElseIf ( cTipoRot $ "3/4" )	// Ferias, Rescisao
		oObj			:= oSrr
		IF ( cTipo == "H" )
			cCpoSoma	:= "RR_HORAS"
		Else
			cCpoSoma	:= "RR_VALOR"
		EndIf

		aAdd( aKeySeek, "RR_PD" )
		aAdd( aValSeek, "" )
		IF cSem != Nil
			aAdd( aKeySeek, "RR_SEMANA" )
			aAdd( aValSeek, cSem )
		EndIf
		IF cPeriodo != Nil
			aAdd( aKeySeek, "RR_PERIODO" )
			aAdd( aValSeek, cPeriodo )
		EndIf
		IF cRoteiro != Nil
			aAdd( aKeySeek, "RR_ROTEIR" )
			aAdd( aValSeek, cRoteiro )
		EndIf
	EndIf

	cCodigos	:= StrTran( cCodigos, " " , "" )
	nLoops		:= Len( cCodigos )
	If nLoops >= 4
		For nLoop := 1 To nLoops Step 4
		 	cCodPd := SubStr( cCodigos , nLoop , 3 )
		 	aValSeek[1] := cCodPd

		 	nValor += oObj:SomaAllRegs( cCpoSoma , aKeySeek , aValSeek )

		Next nLoop
	EndIf
EndIf

Return( nValor )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FDelPd    ³ Autor ³ Mauro                ³ Data ³ 21.07.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Deletar uma Verba no roteiro de Calculo de Folha           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCodigos   =  String contendo os codigos a serem somados   ³±±
±±³          ³ cSem       =  Numero da semana                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Exemplo   ³ FDelPd("101","  " )                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function FDelPd( cCodigos , cSem, cPeriodo, cRoteiro )

Local aKeySeek := {}
Local aValSeek := {}

Local cCodPd
Local cTipoRot
Local cRotDefault	:= GetRotExec()

Local nLoop
Local nLoops

Local oObj

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Localizar a que tipo pertence o roteiro					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
cTipoRot  := fGetTipoRot( cRotDefault )

If cPaisLoc $ "BRA|CHI|PAR"
	cSem  := If(cSem=Nil,cSemana,cSem)

	For nLoop = 1  To Len(cCodigos) Step 4
		cSubCod := Subs(cCodigos,nLoop,3)
		For nLoops := 1 to Len(aPd)
			If aPd[nLoops,01] == cSubCod .and. aPd[nLoops,03] == cSem .and. aPd[nLoops,9] # "D"
		   		aPd[nLoops,9] := "D"
			EndIf
		Next nLoops
	Next nLoop
Else

	If( cTipoRot $ "1/2/5/6/9" ) // Folha de Pagamento, Adiantamento, 13o. 1a. Parcela, 13o. 2a. Parcela
		oObj 			:= oSrc

		aAdd( aKeySeek, "RC_PD" )
		aAdd( aValSeek, "" )
		If cSem != Nil
			aAdd( aKeySeek, "RC_SEMANA" )
			aAdd( aValSeek, cSem )
		EndIf
		If cPeriodo != Nil
			aAdd( aKeySeek, "RC_PERIODO" )
			aAdd( aValSeek, cPeriodo )
		EndIf
		If cRoteiro != Nil
			aAdd( aKeySeek, "RC_ROTEIR" )
			aAdd( aValSeek, cRoteiro )
		EndIf
	ElseIf ( cTipoRot $ "3/4" )	// Ferias, Rescisao
		oObj			:= oSrr

		aAdd( aKeySeek, "RR_PD" )
		aAdd( aValSeek, "" )
		If cSem != Nil
			aAdd( aKeySeek, "RR_SEMANA" )
			aAdd( aValSeek, cSem )
		EndIf
		If cPeriodo != Nil
			aAdd( aKeySeek, "RR_PERIODO" )
			aAdd( aValSeek, cPeriodo )
		EndIf
		If cRoteiro != Nil
			aAdd( aKeySeek, "RR_ROTEIR" )
			aAdd( aValSeek, cRoteiro )
		EndIf
	EndIf

	cCodigos	:= StrTran( cCodigos , " " , "" )
	nLoops		:= Len( cCodigos )
	For nLoop := 1 To nLoops Step 4
	 	cCodPd := SubStr( cCodigos , nLoop , 3 )
	    aValSeek[1] := cCodPd

	 	While oObj:Seek( aKeySeek , aValSeek )
			oObj:Delete( oObj:nAt )
		EndDo

	Next nLoop
EndIf

Return( Nil )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FLocaliaPd ³ autor ³                     ³ Data ³ 11/12/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Localiza Verba no vetor de calculo aPd                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cVerba     =  Verba a ser Pesquisada                       ³±±
±±³          ³ cSemana    =  (Opcional) - Numero da semana de pesquisa    ³±±
±±³          ³ cSeq       =  (Opcional) - Sequencia da Verba 			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Exemplo   ³ FDelPd("101","  " )                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FLocaliaPd( cVerba , cSem , cSeq, cPeriodo, cRoteiro )

Local aKeySeek := {}
Local aValSeek := {}

Local cTipoRot
Local cRotDefault	:= GetRotExec()

Local nRet	:= 0

Local oObj

If Type("oSrc") <> "U"

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Localizar a que tipo pertence o roteiro					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cTipoRot  := fGetTipoRot( cRotDefault )

	IF( cTipoRot $ "1/2/5/9" )
		oObj 			:= oSrc

		aAdd( aKeySeek, "RC_PD" )
		aAdd( aValSeek, cVerba )
		IF cSem != Nil
			aAdd( aKeySeek, "RC_SEMANA" )
			aAdd( aValSeek, cSem )
		EndIf
		IF cSeq != Nil
			aAdd( aKeySeek, "RC_SEQ" )
			aAdd( aValSeek, cSeq )
		EndIf
		IF cPeriodo != Nil
			aAdd( aKeySeek, "RC_PERIODO" )
			aAdd( aValSeek, cPeriodo )
		EndIf
		IF cRoteiro != Nil
			aAdd( aKeySeek, "RC_ROTEIR" )
			aAdd( aValSeek, cRoteiro )
		EndIf
	ElseIf( cTipoRot == "6" )
		oObj			:= oGetSri

		aAdd( aKeySeek, "RI_PD" )
		aAdd( aValSeek, cVerba )
		IF cSem != Nil
			aAdd( aKeySeek, "RI_SEMANA" )
			aAdd( aValSeek, cSem )
		EndIf
		IF cSeq != Nil
			aAdd( aKeySeek, "RI_SEQ" )
			aAdd( aValSeek, cSeq )
		EndIf
	ElseIf ( cTipoRot $ "3/4" )
		oObj			:= oSrr

		aAdd( aKeySeek, "RR_PD" )
		aAdd( aValSeek, cVerba )
		IF cSem != Nil
			aAdd( aKeySeek, "RR_SEMANA" )
			aAdd( aValSeek, cSem )
		EndIf
		IF cSeq != Nil
			aAdd( aKeySeek, "RR_SEQ" )
			aAdd( aValSeek, cSeq )
		EndIf
		IF cPeriodo != Nil
			aAdd( aKeySeek, "RR_PERIODO" )
			aAdd( aValSeek, cPeriodo )
		EndIf
		IF cRoteiro != Nil
			aAdd( aKeySeek, "RR_ROTEIR" )
			aAdd( aValSeek, cRoteiro )
		EndIf
	EndIf

	If !Empty( aKeySeek )
		IF ( oObj:Seek( aKeySeek , aValSeek ) )
			nRet := oObj:nAt
		EndIf
	EndIf
Else
	If cSemana = Nil
		If cSeq = Nil
			nRet :=   Ascan(aPd, { |X| X[1] = cVerba .And. X[9] # 'D'})
		Else
			nRet :=   Ascan(aPd, { |X| X[1] = cVerba .And. X[9] # 'D' .And. x[11] = cSeq })
		Endif
	Else
		If cSeq = Nil
			nRet :=   Ascan(aPd, { |X| X[1] = cVerba .And. X[9] # 'D' .And. x[3] = cSemana })
		Else
			nRet :=   Ascan(aPd, { |X| X[1] = cVerba .And. X[9] # 'D' .And. x[3] = cSemana .And. x[11] = cSeq })
		Endif
	Endif
EndIf

Return( nRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fPosReg	ºAutor  ³Microsiga           º Data ³  09-06-02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Posiciona no registro do alias ordem e chave indicada      º±±
±±º          ³ retornando se existe ou não registro com a chave indicada  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cAlias                                                     º±±
±±º          ³ nOrdem                                                     º±±
±±º          ³ cChave                                                     º±±
±±º          ³ lContinua                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP7                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fPosReg(cAlias,nOrdem,cChave,lProximo)

Local aArea := GetArea()
Local lRet	:= .T.

cAlias		:= If (cAlias == Nil, Alias() , cAlias)
nOrdem		:= If (nOrdem == Nil, 1 , nOrdem)
lProximo    := If (lProximo== Nil, .F. , lProximo)

If cChave # Nil .And. aArea[1] # cAlias .Or. ( aArea[1] == cAlias .and. cChave != &(IndexKey())	)

	dbSelectArea(cAlias)
	dbSetorder(nOrdem)
	//--Verifica se o parametro veio com seleçao de proximo resgitro da mesma chave
	If ! lProximo
		//-- Procura Chave indicada
		If ! dbSeek(cchave)
			lRet := .F.
		EndIf
	Else
		dbSkip()
		//--Verifica se proximo registro do alias corresponde a chave solicitada
		If ! cChave = &(IndexKey())
		   lRet	:= .F.
		EndIf
	EndIf
ElseIf aArea[1] == cAlias
	If ! cChave = &(IndexKey())
		lRet := .F.
	EndIf
Else
	lRet := .F.
EndIf

If aArea[1] != cAlias
	RestArea(aArea)
EndIf

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fConvCampoºAutor  ³Pedro               º Data ³  01/26/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Faz a equivalencia de duas string, trazendo o counteudo da º±±
±±º          ³ segunda, de acordo com a posicao da primeira.              º±±
±±º          ³ cCampo1	  - Caracter a ser comparado com a primeira stringº±±
±±º          ³ cRecebeDe   - String a ser comparada com o cCampo1.        º±±
±±º          ³ cRecebePara - Caracter a retornar de acordo com a 1.string º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fConvCampo(cCampo,cRecebeDe,cRecebePara)
Local nCont,cCond,nFindCarac
Local aVar		:= {}
Local cFound	:=	""

If Len(cRecebeDe) <> Len(cRecebePara)
  Return("")
EndIf
For nCont := 1 to Len(cRecebeDe)
	cCond	:= Substr(cRecebeDe,nCont,1)
	If !(cCond $ "#,/.;")
    	Aadd(aVar,{cCond,Substr(cRecebePara,nCont,1)})
 	EndIf
Next
nFindCarac	:= Ascan(aVar,{|x|x[1]==cCampo})
If nFindCarac > 0
	cFound	:= aVar[nFindCarac][2]
EndIf
Return cFound

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ValFuncEdiºAutor  ³Microsiga           º Data ³  05/26/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function ValFuncEdi()
Local lRet := .F.

IF ( SRA->RA_CATFUNC $ Alltrim(MV_PAR18)  .And.  SRA->RA_SITFOLH $ MV_PAR19 ) 	.And. ;
   ( SRA->RA_MAT >= MV_PAR16 .AND. SRA->RA_MAT <= MV_PAR17 )							 .And. ;
   ( SRA->RA_CC >= MV_PAR14  .And. SRA->RA_CC  <= MV_PAR15 )				    .And. ;
   ( SR0->( DBSEEK( SRA->RA_FILIAL+SRA->RA_MAT)) .And. SR0->R0_VALCAL > 0 )
    lRet := .T.
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ GeraFer	³ Autor ³ Mauro                 ³ Data ³ 08.05.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava as Verbas de Ferias Para a Folha de Pagto.           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ GERAFER(aCodfol) 									      ³±±
±±³ 		 ³	    												      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aCodfol = Matriz Codigos da Folha					      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso 	 ³ Generico 		    								      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GeraFer( aCodfol	,;
				  dDataRef	 ;
				)
Local cAchou		:= "N"
Local cSeq
Local cTipoCod

Local nOutAdic		:= 0.00
Local nValDes13 	:= 0.00
Local nRecSrh       := 0

Local dDtPgFe
Local dDtBusFer
Local dDtMesSeg

nVezFer	            := 0
nValPriMes 			:= 0 // Utilizada para apurar valor d'o segundo mes
dDataRef			:= If (dDataRef == Nil, dDataBase,dDataRef)

dbSelectArea("SRH")
nRecSrh := Recno()
dbSeek(SRA->RA_FILIAL+SRA->RA_MAT)
While !Eof() .And. SRA->RA_FILIAL+SRA->RA_MAT == SRH->RH_FILIAL+SRH->RH_MAT
	cAchou 	:= "N"
	cDifFer	:= "N"
	If Month(SRH->RH_DATAINI)==Month(dDataRef) .And. Year(SRH->RH_DATAINI) == Year(dDataRef)

		//--Semanalista so gera as ferias na semana que compreender o Inicio das ferias
		If SRA->RA_CATFUNC ="S" .Or. (SRA->RA_CATFUNC = "H" .AND. SRA->RA_TIPOPGT ="S") .And. nPosSem > 0
			If SRH->RH_DATAINI >= aPeriodo[nPosSem,3] .And. SRH->RH_DATAINI <= aPeriodo[ nPosSem,4]
				cAchou	:= "S"
			EndIf
			//--So gera a diferenca de ferias para semanalista na ultima semana do mes
			If lUltSemana
				cDifFer	:= "S"
			EndIf
		Else   // Mensalista
			cAchou	:= "S"
			cDifFer := "S"
		EndIf
	ElseIf Month(SRH->RH_DATAFIM)==Month(dDataRef) .And. Year(SRH->RH_DATAFIM) == Year(dDataRef)
		cDifFer 	:= "S"
	EndIf

	If cAchou = "S" .Or. cDifFer = "S"

		If Month(SRH->RH_DATAINI)==Month(SRH->RH_DATAFIM) .And. Year(SRH->RH_DATAINI) == Year(SRH->RH_DATAFIM)
			nDiasMes := ( Day(SRH->RH_DATAFIM) - Day(SRH->RH_DATAINI) - SRH->RH_DIALREM ) + 1
			nDiasMse := 0
			If ( nDiasMes + SRH->RH_DIALREM ) > 30
				nDiasMes := 30 - SRH->RH_DIALREM
			EndIf
		ElseIf Month(SRH->RH_DATAINI) == Month(dDataRef) .And. Year(SRH->RH_DATAINI) == Year(dDataRef)
			nDiasMes := ( nUlt_Dia - Day(SRH->RH_DATAINI) - SRH->RH_DIALREM ) + 1
			//--Montar Dias de ferias mes seguinte
			If Month(ddataRef) < 12
				dDtMesSeg 	:= Ctod("01/"+StrZero(Month(dDataRef)+1,2)+"/"+StrZero(Year(dDataRef),4),"DDMMYY")
			Else
				dDtMesSeg 	:= Ctod("01/01/"+StrZero(Year(dDataRef)+1,4),"DDMMYY")
			EndIf
			//-- Verifica se mes/ano final e maior que data do mes seguinte se for
			//-- utilizar ultimo dia do mes como dias de ferias mes seguinte
			If MesAno(SRH->RH_DATAFIM) > MesAno(dDtMesSeg)
				nDiasMse 	:= f_ultDia(dDtMesSeg)
			Else
				nDiasMse 	:= Day(SRH->RH_DATAFIM) - SRH->RH_DIALRE1
			EndIf
		EndIf

		//--Achar os Dias de Abono do Mes e Mes Seguinte
		If SRH->RH_DABONPE > 0

			If !Empty(SRH->RH_ABOPEC)
				cAboAnt :=	SRH->RH_ABOPEC
			Else
				cAboAnt :=	GetMvRH("MV_ABOPEC")
				cAboAnt := if(cAboAnt=="S","1","2")
			EndIf

			If cAboAnt == "1"
				dDtIAb := SRH->RH_DATAINI - SRH->RH_DABONPE
				dDtFAb := SRH->RH_DATAINI -1
			Else
				dDtIAb := SRH->RH_DATAFIM + 1
				dDtFAb := SRH->RH_DATAFIM + SRH->RH_DABONPE
			EndIf
			If MesAno(dDtIAb) == MesAno(dDataRef)  .And. MesAno(dDtFAb) # MesAno(dDataRef)
				nDAbMes := (nUlt_Dia - Day(dDtIAb)) + 1
				nDAbMse := Day(dDtFAb)
			ElseIf MesAno(SRH->RH_DATAINI) # MesAno(dDataRef) .And. MesAno(dDtIAb) >= MesAno(dDataRef)
				nDAbMes := 0
				nDAbMse := SRH->RH_DABONPE
			ElseIf MesAno(SRH->RH_DATAINI) == MesAno(dDataRef) .And. MesAno(dDtIAb) > MesAno(dDataRef)
				nDAbMes := 0
				nDAbMse := SRH->RH_DABONPE
			ElseIf MesAno(SRH->RH_DATAINI) == MesAno(dDataRef) .And. MesAno(dDtFAb) == MesAno(dDataRef)	;
					.And. 	MesAno(dDtIAb) < MesAno(dDataRef)
				nDAbMes := Day(dDtFAb)
				nDAbMse := 0
			Else
				nDAbMes := SRH->RH_DABONPE
				nDAbMse := 0
			EndIf
		EndIf
	EndIf

	If cAchou == "S"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Procurar verba de Ferias e somar 1 na cSeq caso ja exista     |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cSeq := " "
		nPos := Ascan(aPd,{ |x| x[1] == aCodfol[72,1] .And. x[9] # 'D' .And. x[11] == cSeq} )
		If nPos > 0
			cSeq := Str( Val(cSeq)+1 ,1)
		EndIf
		nOutAdic 	:= 0.00
		nValDes13 	:= 0.00
		dbSelectArea("SRR")
		dDtBusFer := SRH->RH_DATAINI
		If dbSeek( SRA->RA_FILIAL+SRA->RA_MAT+'F'+Dtos(dDtBusFer) )
			While ! Eof() .And. SRA->RA_FILIAL+SRA->RA_MAT == SRR->RR_FILIAL+SRR->RR_MAT ;
					.And. dDtBusFer == SRR->RR_DATA .And. SRR->RR_TIPO3 == 'F'

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Codigo de Ferias 											 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nValPriMes := 0
				If SRR->RR_PD == aCodfol[72,1]
					fGravafer(aCodFol[72,1],SRH->RH_DFERIAS,nDiasMes,,,@nValPriMes,,cSeq)
					fGravafer(aCodFol[73,1],SRH->RH_DFERIAS,nDiasMse,,,nValPriMes,.T.,cSeq)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de Media em Valor									 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[75,1]
					fGravafer(aCodFol[75,1],SRH->RH_DFERIAS,nDiasMes,,,@nValPriMes,,cSeq)
					fGravafer(aCodFol[76,1],SRH->RH_DFERIAS,nDiasMse,,,nValPriMes,.T.,cSeq)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de Media em Valor - Comissionado						 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[343,1]
					fGravafer(aCodFol[343,1],SRH->RH_DFERIAS,nDiasMes,,,@nValPriMes,,cSeq)
					fGravafer(aCodFol[344,1],SRH->RH_DFERIAS,nDiasMse,,,nValPriMes,.T.,cSeq)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de Media em Valor - Tarefeiro   						 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[345,1]
					fGravafer(aCodFol[345,1],SRH->RH_DFERIAS,nDiasMes,,,@nValPriMes,,cSeq)
					fGravafer(aCodFol[346,1],SRH->RH_DFERIAS,nDiasMse,,,nValPriMes,.T.,cSeq)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de 1/3 Ferias										 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[77,1]
					fGravafer(aCodFol[77,1],SRH->RH_DFERIAS,nDiasMes,,,@nValPriMes,,cSeq)
					fGravafer(aCodFol[78,1],SRH->RH_DFERIAS,nDiasMse,,,nValPriMes,.T.,cSeq)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de Dsr sobre Medias									 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[80,1]
					fGravafer(aCodFol[80,1],SRH->RH_DFERIAS,nDiasMes,,,@nValPriMes,,cSeq)
					fGravafer(aCodFol[81,1],SRH->RH_DFERIAS,nDiasMse,,,nValPriMes,.T.,cSeq)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de Media Horas Extras								 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[82,1]
					fGravafer(aCodFol[82,1],SRH->RH_DFERIAS,nDiasMes,,,@nValPriMes,,cSeq)
					fGravafer(aCodFol[83,1],SRH->RH_DFERIAS,nDiasMse,,,nValPriMes,.T.,cSeq)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de Convencao Coletiva								 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[159,1]
					fGravafer(aCodFol[159,1],SRH->RH_DFERIAS,nDiasMes,,,@nValPriMes,,cSeq)
					fGravafer(aCodFol[160,1],SRH->RH_DFERIAS,nDiasMse,,,nValPriMes,.T.,cSeq)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de Abono Pecuniario									 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[74,1]
					//--Verifica se Existe Abono Mes Seguinte
					If aCodFol[205,1] == Space(3)
						fGravafer(aCodFol[74,1],SRH->RH_DABONPE,SRH->RH_DABONPE,,,,,cSeq)
					Else
						fGravafer(aCodFol[74,1],SRH->RH_DABONPE,nDAbMes,,,@nValPriMes,,cSeq)
						fGravafer(aCodFol[205,1],SRH->RH_DABONPE,nDAbMse,,,nValPriMes,.T.,cSeq)
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de 1/3 sobre Abono Pecuniario						 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[79,1]
					//-- Verifica se Existe 1/3 Abono Mes Seguinte
					If aCodFol[206,1] == Space(3)
						fGravafer(aCodFol[79,1],SRH->RH_DABONPE,SRH->RH_DABONPE,,,,,cSeq)
					Else
						fGravafer(aCodFol[79,1],SRH->RH_DABONPE,nDAbMes,,,@nValPriMes,,cSeq)
						fGravafer(aCodFol[206,1],SRH->RH_DABONPE,nDAbMse,,,nValPriMes,.T.,cSeq)
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de Arredondamento de Ferias							 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[104,1]
					fGravafer(aCodFol[104,1],0,0,,,,,cSeq)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de Base IR Ferias									 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[16,1]
					fGravafer(aCodFol[16,1],0,0,,,,,cSeq)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de IR de Ferias										 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[67,1]
					 fGravafer(aCodFol[67,1],0,0,,,,,cSeq)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Deducao de Dependente de IR de Ferias						 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[60,1]
					fGravafer(aCodFol[60,1],0,0,,,,,cSeq)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de Antecipacao de 13o Salario						 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[22,1]
					fGravafer(aCodFol[22,1],0,0,,,,,cSeq)
					nValDes13 := SRR->RR_VALOR
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de INSS de Ferias quando for dentro do mes			 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[65,1]
					If MesAno(SRH->RH_DATAINI) == MesAno(SRH->RH_DATAFIM) .And. nVezFer == 0
						fGravafer(aCodFol[65,1],0,0,,,,,cSeq)
					ElseIf Type("cInssFM") <> "U" .And. cInssFM == "S"
						fGravafer(aCodFol[65,1],0,0,,,,,cSeq)
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de INSS de Ferias Mes Seguinte						 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[232,1]
					If Type("cInssFM") <> "U" .And. cInssFM == "S"
						fGravafer(aCodFol[232,1],0,0,,,,,cSeq)
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de Deducao INSS na Base Imposto Renda de Ferias		 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[168,1]
					fGravafer(aCodFol[168,1],0,0,,,,,cSeq)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de Ferias em Dobro									 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[224,1]
					fGravafer(aCodFol[224,1],0,0,,,,,cSeq)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de 1/3 ferias em Dobro								 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[226,1]
					fGravafer(aCodFol[226,1],0,0,,,,,cSeq)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Codigo de Liquido Pago em Ferias						     ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf SRR->RR_PD == aCodfol[102,1]
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Se Existir o Cod. Liquido 1¦ Parcela Subtrai do Liquido      ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If aCodFol[202,1] # Space(3)
						fGravafer(aCodFol[102,1],0,0,SRR->RR_VALOR-nValDes13,,,,cSeq)
						fGravafer(aCodFol[202,1],0,0,nValDes13,,,,cSeq)
					Else
						fGravafer(aCodFol[102,1],0,0,,,,,cSeq)
					EndIf
				Else
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Outros Codigos de Adicionais								 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cTipoCod := RetValSRV(SRR->RR_PD,SRA->RA_FILIAL,"RV_TIPOCOD")
					If ( cTipoCod == "1" )		//Provento
						nOutAdic := nOutAdic + SRR->RR_VALOR
						dDtPgFe  := dDtBusFer
					ElseIf ( cTipoCod == "2" ) .and. SRR->RR_PD # aCodFol[65,1]	//Desconto
						fGravafer(SRR->RR_PD,0,0,,,,,cSeq)
					ElseIf ( cTipoCod == "3" ) .and. !(SRR->RR_PD$ aCodfol[13,1]+'*'+aCodFol[14,1]) //Base
						fGravafer(SRR->RR_PD,0,0,,,,,cSeq)
					EndIf
				EndIf

				dbSelectArea("SRR")
				dbSkip()
			Enddo

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Outros adicionais Gera na Matriz						     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nOutAdic > 0.00
				fGravafer(aCodFol[84,1],SRH->RH_DFERIAS,nDiasMes,nOutAdic,dDtPgFe,@nValPriMes,,cSeq)
				fGravafer(aCodFol[85,1],SRH->RH_DFERIAS,nDiasMse,nOutAdic,dDtPgFe,nValPriMes,.T.,cSeq)
			EndIf
		EndIf
		nVezFer ++
	EndIf
	dbSelectArea("SRH")
	If cDifFer = "S" .And. cAchou = "N"
		nDiasMes := 0
		nDiasMse := Day(SRH->RH_DATAFIM) - SRH->RH_DIALRE1
	EndIf
	If cDifFer == "S"
		Aadd(aDifFer,{ Recno() , nDiasMes , nDiasMse })
	EndIf
	nRecSrh := Recno()
	dbSkip()
Enddo
dbSelectArea("SRH")
dbGoTo(nRecSrh)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ fGravaFer³ Autor ³ Mauro 			    ³ Data ³ 22/12/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava as Verbas de ferias.								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ fGravaFer() 								 				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³															  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso	 	 ³ ESPECIFICO												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fGravafer(	cCodigo		,;
							nDiasFe		,;
							nDiasMes	,;
							nValorFe	,;
							dDtPgFe		,;
							nValPriMes	,;
							lSegMes		,;
							cSeq		 ;
						  )

nValorFe   := If (nValorFe   == Nil , SRR->RR_VALOR , nValorFe)
dDtPgFe    := If (dDtPgFe    == Nil , SRH->RH_DTRECIB , dDtPgFe)
lSegMes    := If (lSegMes    == Nil,.F.,lSegMes)
cSeq       := If (cSeq 	     == Nil," ", cSeq)
nValPriMes := If (nValPriMes  # Nil .And. lSegMes,nValPriMes,0)
lArrDFer   := If (Round(nDiasFe, 0) == nDiasMes, .T., .F.)

//--Procurar a Verba para somar caso exista.
nPos := Ascan(aPd,{ |x| x[1] == cCodigo .And. x[9] # 'D' } )
If nPos > 0 .And. aPd[nPos,7]$ "I"
	Return
EndIf

If nDiasFe == nDiasMes
	If cCodigo $ (aCodFol[65,1]+","+aCodFol[232,1])
		FMatriz(cCodigo,nValorFe,SRR->RR_HORAS,,,,"K",,,dDtPgFe,.T.,cSeq)
	Else
		FMatriz(cCodigo,nValorFe,nDiasMes,,,,"K",,,dDtPgFe,.T.,cSeq)
	EndIf
Else
	If lSegMes .And. nValPriMes > 0
		FMatriz(cCodigo,(nValorFe - nValPriMes),nDiasMes,,,,"K",,,dDtPgFe,.T.,cSeq)
	Else
		nValPriMes := Round((nValorFe / If(lArrDFer,Round(nDiasFe,0),nDiasFe) )* nDiasMes, 2)
		FMatriz(cCodigo,nValPriMes,nDiasMes,,,,"K",,,dDtPgFe,.T.,cSeq)
	EndIf
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ GeraResc ³ Autor ³ Mauro (Versao I)	    ³ Data ³01/06/1995³±±
±±³          ³          ³ Autor ³ Marinaldo (Versao II) ³ Data ³11/03/2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava as Verbas de Rescisao Na Folha de Pagto.			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GeraResc( cFolMes , cSemana )							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³															  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso	 	 ³ GPEM020    											  	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GeraResc( 	cFolMes	,;
					cSemana	,;
					lGerRes  ;
				 )

Local aArea		:= GetArea()
Local aAreaSRG	:= SRG->(GetArea())
Local aRecnos	:= {}
Local aCloneaPD	:= aClone( aPd )
Local bAscan	:= { || NIL }
Local cCCusFun	:= SRA->RA_CC
Local lDeleta	:= .F.
Local nRecno	:= 0.00
Local nRecnos	:= 0.00
Local nLenSeq	:= Len( SRC->RC_SEQ )

lGerRes	:= .F.

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Reinicializa aPd para que neste Ponto contenha  apenas  as In³
³formacoes de Rescisao										  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aPd := {}

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Define a Competencia para Comparar com a Data de Geracao     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
cFolMes := IF( Empty( cFolMes ) , MesAno( dDataBase ) , cFolMes )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica se Funcionario Possui Informacoes no SRG            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF SRG->( dbSeek( SRA->( RA_FILIAL + RA_MAT ) ) )
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Percorre o SRG e Carrega os Recnos Validos                   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	While SRG->( !Eof() .and. SRA->( RA_FILIAL + RA_MAT ) == RG_FILIAL + RG_MAT )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³So Carrega Recnos de Rescisoes Efetivadas e cujo Mes/Ano   da³
		³data de Geracao seja Igual ao Mes/Ano da Competencia         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF SRG->( ( MesAno( RG_DTGERAR ) == cFolMes ) .and. RG_EFETIVA $ " S" )

			//-- Altera a Variavel para Informar que gerou a rescisao na Folha
			lGerRes := .T.

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³So Carrega Recnos de Rescisoes Efetivadas e cujo Mes/Ano   da³
			³data de Geracao seja Igual ao Mes/Ano da Competencia pois nes³
			³te caso deve-se gerar para Folha apenas a ultima Rescisao Cal³
			³culada														  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			IF SRG->( MesAno( RG_DATADEM ) == MesAno( RG_DTGERAR) )

				IF Empty( aRecnos )
					aAdd( aRecnos , SRG->( Recno() ) )
				Else
					aRecnos[ Len( aRecnos ) ] := SRG->( Recno() )
				EndIf
			Else
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Caso contrario carrega todos os Recnos pois deverao ser  Gera³
				³Para a Folha Todas as Rescisoes em que o Mes/Ano  da  Geracao³
				³sejam iguais ao Mes/Ano da Competencia						  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				aAdd( aRecnos , SRG->( Recno() ) )
			EndIf
		EndIf
		SRG->( dbSkip() )
	End While
	IF ( nRecnos := Len( aRecnos ) ) > 0.00
		For nRecno := 1 To nRecnos
			SRG->( dbGoto( aRecnos[ nRecno ] ) )
			IF SRR->( dbSeek( SRA->( RA_FILIAL + RA_MAT ) + "R" + Dtos(SRG->RG_DTGERAR) ) )
				While SRR->( !Eof() .and. SRA->( RA_FILIAL + RA_MAT ) + "R" == RR_FILIAL + RR_MAT + RR_TIPO3 )
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Gera Apenas os Valores correspondentes a Semana Passada e   a³
					³data de Geracao e apenas quando valor calculado nao for zero ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					IF SRR->( RR_SEMANA == cSemana .and. RR_DATA == SRG->RG_DTGERAR .and. !Empty( RR_VALOR ) )
						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Carrega as Verbas da Rescisao no aPd						  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						SRR->(;
								fMatriz(	RR_PD												,;	//Verba
											RR_VALOR											,;	//Valor
											RR_HORAS											,;	//Horas
											RR_SEMANA											,;	//Semana
											( IF( Empty( RR_CC ) , cCCusFun , RR_CC )	)		,;	//Centro de Custo
											RR_TIPO1											,;	//Tipo "V"alor,"H"oras,"D"ias
											RR_TIPO2											,;	//Origem "R"escisao
											0.00												,;	//Parcela
											""													,;	//Se esta Delatada em aPD
											( IF( Empty( RR_DATAPAG ) , RR_DATA , RR_DATAPAG) )	,;	//Data de Pagamento
											.T.													,;	//Se altera Existente
											IF( nRecnos > 1 , StrZero( nRecno , nLenSeq ) , " " ) ;	//Sequencia de Lancamento
										);
						   	  )

					EndIf
					SRR->( dbSkip() )
				End While
			EndIf
		Next nRecno
	EndIf
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Define o Bloco que sera utilizado para comparacao das Informa³
³coes entre o aPD que foi carregado do SRC (aCloneaPd) e o aPd³
³da Rescisao												  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
bAscan := { |x| aCloneaPd[ nRecno , 01 ] == x[1] .and. 				; //Verba
				aCloneaPd[ nRecno , 02 ] == x[2] .and. 				; //Centro de Custo
				AllTrim(aCloneaPd[ nRecno , 03 ]) == AllTrim(x[3])	; //Semana
		  }

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carrega Informacoes da Folha no aPD que foi remontado  apenas³
³com os dados da Rescisao									  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF Len( aPd ) > 0.00
	nRecnos := Len( aCloneaPd )
	For nRecno := 1 To nRecnos
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Verifica se Ja Existe a Informacao em aPD Para Deletar		  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		lDeleta := ( aScan( aPd , bAscan ) > 0.00 )
		aAdd( aPd , aCloneaPD[ nRecno ] )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Marca como deletada para que possa ser Excluida na Gravacao  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF ( lDeleta )
			aPd[ Len(aPd) , 09 ] := "D"
		EndIf
	Next nRecno
Else
	aPd := aClone( aCloneaPd )
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Restaura os Dados de Entrada								  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
RestArea( aArea   )
RestArea(aAreaSRG )

Return( lGerRes )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ fCompl13 ³ Autor ³ Mauro                 ³ Data ³ 01/06/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Calcular o Compl. 13o. Chamando a Roteiro de 13o. 2o.Parc. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ fCompl3()												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³															  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso	 	 ³ ESPECIFICO												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCompl13()

Local aPdDif 		:= {}
Local aCodBenef		:= {}
Local aPdvFol
Local aPd132
Local cItCt
Local cClCt
Local cTipoCod
Local cRot132 		:= fGetCalcRot('6')
Local cRotFol		:= fGetCalcRot('1')
Local lLancouDif	:= .F.
Local nP13
Local nValDif13
Local nValDifMa
Local n				:= 0
Local nPos132		:= 0
Local aPdAux        := {}
Local nPosAux       := 0
Local cVerbasAux    := ""
Local cMes132		:= ""
Local cSeqAux		:= ""
Local dDtPgtFol     := dData_Pgto //Grava a data de pagamento da folha
Local lTem1678		:= cPaisLoc == "BRA" .And. Len(aCodFol) >= 1678 .And. !Empty(aCodFol[1672,1]) .And. !Empty(aCodFol[1673,1]) .And. !Empty(aCodFol[1676,1]) .And. !Empty(aCodFol[1677,1]).And. !Empty(aCodFol[1678,1])
Local lTem1679		:= cPaisLoc == "BRA" .And. Len(aCodFol) >= 1679 .And. !Empty(aCodFol[1679,1]) //Verba de Base Pensão 13 Devolução.
Local nValorPd		:= 0
Local cCodPd		:= ""
Local cPdsImpost := aCodFol[070,1]+"/"+aCodFol[071,1]+"/"+aCodFol[019,1]+"/"+aCodFol[020,1]+"/"+aCodFol[027,1]+"/"+aCodFol[108,1]+"/"+aCodFol[109,1] //Verbas de impostos 13.

Private aTInss13[3,3]		   // Tabela de Inss 13§ Salario
Private aAfast  		:= {}
Private aPdFol
Private cCompl13 		:= 'S'
Private dDataRef 		:= dDataAte
Private n13FGTS_B 	:= 0
Private nIR13_B 		:= 0
Private nLIQUIDO 		:= 0
Private nINSS13_B 	:= 0
Private nAntec13  	:= 0
Private nMedPer   	:= 0
Private nMedIns 	:= 0.00
Private nValArred 	:= nValArr13
Private nAvos
Private nAvosFal13
Private nFgts_b 	:= nFgts13_b := 0
Private lItemClVl   := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3" // Se utiliza Item e Classe de Valores
Private nSalMesI    := 0

cItCt				:= If(lItemClVl,SRA->RA_ITEM,'')
cClCt				:= If(lItemClVl,SRA->RA_CLVL,'')

// Verifica se Existe o Codigo de Compl. 13o.
If aCodFol[28,1] = Space(3)
	Return
EndIf

If cPaisLoc == "CHI"
	Return
EndIf

If (lDissidio .And. SRA->RA_CATFUNC $ cCatDis13) .Or. (!lDissidio .And. Month(dDataAte) != 12 .And. !fTemROT132(Nil, cProcesso, cPeriodo, cSemana))
	Return
Endif

// Carrega os beneficiarios para gerar a diferenca da pensao alimenticia.
fBusCadBenef(@aCodBenef,cRot132,,.F.)

lLancouDif :=	( Ascan(aPd,{|X| X[1] == aCodFol[028,1] .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) .Or. ;
				( Ascan(aPd,{|X| X[1] == aCodFol[348,1] .And. X[9] <> "D" .And. X[7] == "I"}) > 0 )

aPdFol	 	:= aClone(aPd)
aPdvFol		:= aClone(aPdv)
aPd	 	 	:= {}
aTInss13 	:= aClone(aTInss)
cSeqAux 	:= cSeqMV

//Carrega dados do periodo da folha
SetRotExec( cRot132 )
SetPeriodCalc( cPeriodo )
SetNumPgCalc( cSemana )
cRot := cRot132
// Indica que é um roteiro dentro do roteiro da Folha de Pagamento
lCalcFol	:= .T.

If Type("P_LDIFINC") <> "U" .And. P_LDIFINC
	nSalMesI := SalMes
EndIf

RstLastRot() //Reseta variavel static de calculo
// Executar as Formulas do Roteiro "132"
nRet := ExecRot(SRA->RA_FILIAL, cRot )

cSeqMV := cSeqAux

For n := 1 to Len(aPd)
	If Len(aPdAux) == 0 .Or. ( ( nPosAux := aScan(aPdAux,{|x| x[1] == aPd[n,1] .And. x[9] <> "D"}) ) == 0 )
		aAdd(aPdAux,aPd[n])
	Else
		aPdAux[nPosAux,5] += aPd[n,5]
	EndIf
Next n

// Chamada para Calculo da 2o Parcela
If !lLancouDif .And.  nRet == 0
	nValAnt := nValP := nValPMat := nValD := nValDMat := 0.00
	For n := 1 to Len(aPd)
		cMes132 := ""
		If aPd[n,9] <> "D"
			If aPd[n,1] $ cVerbasAux
				Loop
			Else
				cVerbasAux += aPd[n,1] + "*"
			EndIf

			// Desconsidera verba informada na folha para complementar o pagamento do 13º, para que não ocorra duplicidade de pagamento/desconto e erro no cálculo dos impostos
			If aPd[n,7] == "I" .And. aScan(aPdFol, {|x| x[1] == aPd[n,1] .And. x[7] == "I" .And. x[10] == aPd[n,10] .And. x[9] # "D"}) > 0
				Loop
			EndIf

			nValAnt := 0.00

			dbSelectArea("SRD")

			SRD->(DbSetOrder(6)) //RD_FILIAL+RD_MAT+RD_PD+RD_ROTEIR+DTOS(RD_DATPGT)
			If SRD->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + aPd[n,1] + cRot132 + SubStr(cPeriodo,1,4)))
				While SRD->( !Eof() ) .And. SRD->(RD_FILIAL+RD_MAT+RD_PD+RD_ROTEIR+SubStr(DtoS(RD_DATPGT),1,4)) == SRA->(RA_FILIAL+RA_MAT)+aPd[n,1]+cRot132+SubStr(cPeriodo,1,4)
					nValAnt += SRD->RD_VALOR
					cMes132 := SRD->RD_MES
					SRD->(DbSkip())
				EndDo
			EndIf

			//Procura verba no complemento pago em meses anteriores e subtrai da diferença atual
			If SRD->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + aPd[n,1] + cRotFol + SubStr(cPeriodo,1,4)))
				While SRD->( !Eof() ) .And. SRD->(RD_FILIAL+RD_MAT+RD_PD+RD_ROTEIR+SubStr(RD_DATARQ,1,4)) == SRA->(RA_FILIAL+RA_MAT)+aPd[n,1]+cRotFol+SubStr(cPeriodo,1,4)
					If Empty(cMes132) .Or. cMes132 == SRD->RD_MES
						nValAnt += SRD->RD_VALOR
					EndIf
					SRD->(DbSkip())
				EndDo
			EndIf

			nPosAux := aScan(aPdAux,{|x| x[1] == aPd[n,1] .And. X[9] # "D"})
			nValDif13 := Round(aPdAux[nPosAux,5] - nValAnt,2)
			cTipoCod := RetValSRV(aPd[n,1],SRA->RA_FILIAL,"RV_TIPOCOD")
			If ( cTipoCod == "1" ) //Provento
				If aPd[n,1] # aCodFol[26,1] .And. ( aPd[n,1] # aCodFol[30,1] )  // Arredondamento e Saldo negativo
					If lIntTaf .And. RetValSRV( aPd[n,1], SRA->RA_FILIAL, "RV_NATUREZ") == "4051"
						nValPMat += nValDif13
					Else
						nValP += nValDif13
					EndIf
				EndIf
			ElseIf ( cTipoCod == "2" ) //Descontos
				// Verifica se Nao for IR e INSS e Pensao Alimenticia
				If !aPd[n,1]$ aCodFol[070,1]+'*'+aCodFol[071,1] .and. !( Ascan(aCodBenef,{|X| x[1] == aPd[n,1]}) > 0 )
					If lIntTaf .And. RetValSRV( aPd[n,1], SRA->RA_FILIAL, "RV_NATUREZ") == "4051"
						nValDMat += nValDif13
					Else
						nValD += nValDif13
					EndIf
				Else
					Aadd(aPdDif,{aPd[n,1], nValDif13 })
				EndIf
			ElseIf ( cTipoCod == "3" ) .And. aPd[n,1] # aCodFol[21,1] //Bases
				Aadd(aPdDif,{aPd[n,1], nValDif13 })
			EndIf
		EndIf
	Next N
	nValDif13 := (nValP - nValD)
	nValDifMa := (nValPMat - nValDMat)
	SRD->(DbSetOrder(6)) //RD_FILIAL+RD_MAT+RD_PD+RD_ROTEIR+DTOS(RD_DATPGT)
	If SRD->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + aCodFol[28,1] + cRotFol + SubStr(cPeriodo,1,4)))
		While SRD->( !Eof() ) .And. SRD->(RD_FILIAL+RD_MAT+RD_PD+RD_ROTEIR+SubStr(RD_DATARQ,1,4)) == SRA->(RA_FILIAL+RA_MAT)+aCodFol[28,1]+cRotFol+SubStr(cPeriodo,1,4)
			nValDif13 -= SRD->RD_VALOR
			SRD->(DbSkip())
		EndDo
	EndIf
	If lIntTaf .And. SRD->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + aCodFol[1732,1] + cRotFol + SubStr(cPeriodo,1,4)))
		While SRD->( !Eof() ) .And. SRD->(RD_FILIAL+RD_MAT+RD_PD+RD_ROTEIR+SubStr(RD_DATARQ,1,4)) == SRA->(RA_FILIAL+RA_MAT)+aCodFol[1732,1]+cRotFol+SubStr(cPeriodo,1,4)
			nValDifMat -= SRD->RD_VALOR
			SRD->(DbSkip())
		EndDo
	EndIf
	If cDif13Neg == "S" .Or. (cDif13Neg == "N" .And. nValDif13 > 0)
		If nValDif13 > 0 .Or. Empty(aCodFol[348,1])
			If ( nP13 := Ascan(aPd,{ |x| x[1] = aCodFol[28,1] .And. x[9] # "D" .and. x[7] $ "I*G"})) == 0
				Aadd(aPdDif,{aCodFol[28,1], Round(nValDif13,2) })      //Gera diferenca positiva
			Else
				Aadd(aPdDif,{aCodFol[28,1], aPd[nP13,5] })  //Gera desconto da diferenca
			EndIf
		ElseIf nValDif13 < 0
			If (nP13 := Ascan(aPd,{ |x| x[1] = aCodFol[348,1] .And. x[9] # "D" .and. x[7] $ "I*G"})) == 0
				Aadd(aPdDif,{aCodFol[348,1], Round(nValDif13*-1,2) })  //Gera desconto da diferenca
			Else
				Aadd(aPdDif,{aCodFol[348,1], aPd[nP13,5] })  //Gera desconto da diferenca
			EndIf
		EndIf
		If lIntTaf
			If nValDifMa > 0
				If ( nP13 := Ascan(aPd,{ |x| x[1] = aCodFol[1732,1] .And. x[9] # "D" .and. x[7] $ "I*G"})) == 0
					Aadd(aPdDif,{aCodFol[1732,1], Round(nValDifMa,2) })      //Gera diferenca positiva
				Else
					Aadd(aPdDif,{aCodFol[1732,1], aPd[nP13,5] })  //Gera desconto da diferenca
				EndIf
			ElseIf nValDifMa < 0
				If (nP13 := Ascan(aPd,{ |x| x[1] = aCodFol[1733,1] .And. x[9] # "D" .and. x[7] $ "I*G"})) == 0
					Aadd(aPdDif,{aCodFol[1733,1], Round(nValDifMa*-1,2) })  //Gera desconto da diferenca
				Else
					Aadd(aPdDif,{aCodFol[1733,1], aPd[nP13,5] })  //Gera desconto da diferenca
				EndIf
			EndIf
		EndIf
	Else
		aPdDif := {}
	EndIf
EndIf

// Retornar o Roteiro da Folha
aPd132		:= aClone(aPd)
aPd 	    := aClone(aPdFol)
aPdv 		:= aClone(aPdvFol)

dData_Pgto  := dDtPgtFol //Restaura a data de pagametno da folha

SetRotExec( cRotFol )
SetPeriodCalc( cPeriodo )
SetNumPgCalc( cSemana )
cRot		:= cRotFol
cRoteiro 	:= cRot

// Gerar as Diferencas para o Array da Folha
If Len(aPdDif) > 0
	lLancouDif :=	( Ascan(aPd132,{|X| X[1] == aCodFol[028,1] .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) .Or. ;
					( Ascan(aPd132,{|X| X[1] == aCodFol[348,1] .And. X[9] <> "D" .And. X[7] == "I"}) > 0 )
	// Gerar aas Diferancas 13o na Folha de Dez.
	For nP13 := 1 to Len(aPdDif)
		If Ascan(aPd,{ |x| x[1] = aPdDif[nP13,1] .And. x[7] == "C" .And. x[9] # "D" }) > 0
			fDelPd(aPdDif[nP13,1])
		EndIf
		If aPdDif[nP13,2] > 0
			If aPdDif[nP13,1] $ aCodFol[995,1] + "/" + aCodFol[994,1] + "/" + aCodFol[291,1] + "/" + aCodFol[290,1] .and. ( aScan(aPd,{|x| x[1] == aPdDif[nP13,1] .and. x[7] <> 'I'}) ) > 0
				Loop //Se for verbas de INSS/Ir outras empresas (MULTV), já foram carregadas no roteiro de FOL
			EndIf
			fMatriz( aPdDif[nP13,1], aPdDif[nP13,2], Nil, Nil, Nil, Nil, Iif( aPdDif[nP13,1] $ (aCodFol[028,1]+"/"+aCodFol[328,1]) .And. lLancouDif, "I", Nil ) )
		ElseIf Ascan(aPd,{ |x| x[1] = aPdDif[nP13,1] .And. x[9] # "D" }) == 0
			If FIncide(aPdDif[nP13,1])
				nPos132 := Ascan(aPd132,{ |x| x[1] = aPdDif[nP13,1]})
				nValorPd := aPdDif[nP13,2]
				If nPos132 > 0
					cCodPd := aPdDif[nP13,1]
					If aPdDif[nP13,1] $ aCodFol[169,1] 
						nValorPd := nValorPd * -1
					ElseIf ( (aPdDif[nP13,1] $ cPdsImpost ) .And. aPdDif[nP13,2] < 0 .And. lTem1678)
						nValorPd := nValorPd * -1
						Do case 
							case aPdDif[nP13,1] == aCodFol[070,1]
								cCodPd := aCodFol[1672,1]
							case aPdDif[nP13,1] == aCodFol[019,1]
								cCodPd := aCodFol[1673,1]
							case aPdDif[nP13,1] == aCodFol[020,1]
								cCodPd := aCodFol[1678,1]
							case aPdDif[nP13,1] == aCodFol[109,1]
								cCodPd := aCodFol[1676,1]
							case aPdDif[nP13,1] == aCodFol[108,1]
								cCodPd := aCodFol[1677,1]
						End Do
					//Tratativa para pensão negativa
					//Verifica se possui o ID 1679, se o valor é menor que zero e se a verba do APDDIF é a verba cadastrada para o beneficiário.	
					ElseIf lTem1679 .And. aPdDif[nP13,2] < 0 .And. aScan( aCodBenef, { |X| x[1] == aPdDif[nP13,1] } ) > 0
						cCodPd := aCodFol[1679,1]
						nValorPd := nValorPd * -1				
					EndIf
					FMatriz(cCodPd, Round(nValorPd,2), Nil, cSemana, SRA->RA_CC, "V", "C", 0, Nil, DDATA_PGTO, Nil, Nil, Nil, cItCt, cClCt)
				EndIf
			EndIf
		EndIf
	Next

	// Deletar o Arredondamento no Array da Folha
	nPos := Ascan(aPd,{ |x| x[1] = aCodFol[43,1] .And. x[9] # "D"})
	If nPos > 0
		aPd[nPos,9] := 'D'
	EndIf
	// Deletar o liquido no Array da Folha
	nPos := Ascan(aPd,{ |x| x[1] = aCodFol[47,1] .And. x[9] # "D"})
	If nPos > 0
		aPd[nPos,9] := 'D'
	EndIf
	// Deletar a Insuficiencia de Saldo Array da Folha
	nPos := Ascan(aPd, {|x| x[1] = aCodFol[45,1] .And. x[9] # "D"})
	If nPos > 0
		aPd[nPos,9] := 'D'
	EndIf

	If !lTem1678
		// Deletar a Base de IRF 13.Sal negativa no Array da Folha
		nPos := Ascan(aPd, {|x| x[1] = aCodFol[27,1] .And. x[5] < 0 .and. x[9] # "D"  })
		If nPos > 0
			aPd[nPos,9] := 'D'
		Endif
	
		// Deletar o IRF 13.Sal negativo no Array da Folha
		nPos := Ascan(aPd, {|x| x[1] = aCodFol[71,1] .And. x[5] < 0 .and. x[9] # "D"  })
		If nPos > 0
			aPd[nPos,9] := 'D'
		Endif
	EndIf
	If ExistBlock( "GP020D13" )
		ExecBlock( "GP020D13", .F., .F. )
	EndIf

	nValArred	:= GetMvRH("MV_ARREDFO")
	// Calcualar o liquido novamente
	fLiquido(aCodfol,aCodfol[47,1],nValArred,aCodfol[43,1],.T.,aCodFol[45,1],.T.)

	// Quando Encargos for Analitico
	If lDissidio

		fDelPd(aCodFol[150,1]+","+aCodFol[148,1]+","+aCodFol[149,1]+","+aCodFol[204,1]+;
		       ","+aCodFol[184,1]+","+aCodFOl[185,1]+","+aCodFol[186,1]+","+aCodFol[187,1]+;
		       ","+aCodFol[188,1]+","+aCodFol[189,1]+","+aCodFol[190,1]+","+aCodFol[191,1]+;
		       ","+aCodFol[192,1]+","+aCodFol[193,1]+","+aCodFol[201,1]+","+aCodFol[202,1]+;
		       ","+aCodFol[223,1],cSemana)

	EndIf

	// Calcula encargos com novos valores
	fCalcInssFun()

	// Rateio por Centro de Custo
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de Entrada Chamada do Rateio C.C. apos Complemento
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock("GPCOMPL13")
		If !ExecBlock("GPCOMPL13",.F.,.F.)
			Return
		EndIf
	Else
		fEncarCc()
	Endif
Else
	// Calcula encargos com novos valores
	fCalcInssFun()
	fEncarCc()
EndIf

Begin Transaction
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava a matriz das verbas da Folha no Arquivo SRC			 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lDissidio
		Aeval( aPD , { |X| Gravafol(X) } )
	EndIf
End Transaction

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ fGerArr13³ Autor ³ Mauro 		        ³ Data ³ 01/06/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Descontar Arred. da 2o. parcela							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ fGerArr13()												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³															  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso 	 ³ ESPECIFICO												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fGerArr13()
Local aArea		:= GetArea()
Local cRot132	:= ""
Local cSRDSeek	:= ""

If cPaisLoc != "BRA"
	dbSelectArea("SRI")
	dbSetOrder(1)
	If dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+aCodFol[26,1])
		fMatriz(aCodFol[29,1],SRI->RI_VALOR)
	ElseIf dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+aCodFol[30,1])
		fMatriz(aCodFol[25,1],SRI->RI_VALOR)
	EndIf
Else
	cRot132 := fGetCalcRot("6") //132

	//Procura o roteiro do 13º que ja foi fechado referente ao periodo de calculo da rescisao
	DbSelectArea("SRD")
	DbSetOrder(RetOrder("SRD","RD_FILIAL+RD_MAT+RD_PROCES+RD_ROTEIR+RD_PERIODO+RD_SEMANA"))

	cSRDSeek := SRA->RA_FILIAL + SRA->RA_MAT + SRA->RA_PROCES + cRot132 + cPeriodo + cSemana
	If DbSeek( cSRDSeek )
		While SRD->(!Eof() .and. RD_FILIAL + RD_MAT + RD_PROCES + RD_ROTEIR + RD_PERIODO + RD_SEMANA == cSRDSeek )
			If !Empty(aCodFol[29,1]) .And. SRD->RD_PD == aCodFol[26,1]//Provento Arred 13§
				fMatriz( aCodFol[29,1], SRD->RD_VALOR, SRD->RD_HORAS, SRD->RD_SEMANA, SRD->RD_CC, SRD->RD_TIPO1, SRD->RD_TIPO2, Nil, Nil, SRD->RD_DATPGT, Nil, SRD->RD_SEQ )
			ElseIf !Empty(aCodFol[25,1]) .And. SRD->RD_PD == aCodFol[30,1]//Insf. 13o. Sal.
				fMatriz( aCodFol[25,1], SRD->RD_VALOR, SRD->RD_HORAS, SRD->RD_SEMANA, SRD->RD_CC, SRD->RD_TIPO1, SRD->RD_TIPO2, Nil, Nil, SRD->RD_DATPGT, Nil, SRD->RD_SEQ )
			EndIf
			SRD->(DbSkip())
		EndDo
	EndIf
EndIf

RestArea(aArea)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fCarSemanaºAutor  ³Microsiga           º Data ³  10/08/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Carrega o Array aSemanas com as semanas do mes de Calculo   º±±
±±º          ³atraves da Filial e do turno do funcionario posicionado     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±³Parametros³dDataRef  = Data para Mes Ano de referencia                 ³±±
±±³          ³aSemanas  = Array parta carregar as semanas da data de ref. ³±±
±±³          ³lUtlSemana= Variavel logica que indica ultima semana do mes ³±±
±±³          ³nPosSem   = Posicao da Semana atual no array aSemanas		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±ºUso       ³ Sigagpe                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCarSemana(dDataRef, aSemanas, lUltSemana, nPosSem)

Local lRet	:= .T.
Local cChaveSem
Static cChkSem

If cChkSem = Nil
	cChkSem   	:= GetMvRH("MV_GPCHSEM")
EndIf

If cSemana # Space( 2 ) .And. cChkSem = "S"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Parametro Semanas											 			  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cChaveSem := StrZero(Year(dDataRef),4)+StrZero(Month(dDataRef),2)+SRA->RA_TNOTRAB
	dbSelectArea( "SRX" )

	If !dbSeek( If(Empty(RhTamFilial(cFilial)),cFilial,SRA->RA_FILIAL) + "01" + cChaveSem + cSemana , .T. )
		If !dbSeek( If(Empty(RhTamFilial(cFilial)),cFilial,SRA->RA_FILIAL) + "01" + Subs(cChaveSem,3,9) + cSemana , .T. )
			If !dbSeek( If(Empty(RhTamFilial(cFilial)),cFilial,SRA->RA_FILIAL) + "01" + Left(cChaveSem,6)+"999"+cSemana , .T. )
				If !dbSeek( If(Empty(RhTamFilial(cFilial)),cFilial,SRA->RA_FILIAL) + "01" + Subs(cChaveSem,3,4)+"999"+cSemana , .T. )
					HELP( " ",1,"SEMNAOCAD" )
					lRet := .F.
				EndIf
			EndIf
		EndIf
	EndIf

	If !dbSeek(If(Empty(RhTamFilial(cFilial)),cFilial,SRA->RA_FILIAL) + "01" + cChaveSem , .T. )
		If !dbSeek(If(Empty(RhTamFilial(cFilial)),cFilial,SRA->RA_FILIAL) + "01" + Subs(cChaveSem,3,9) , .T. )
			cChaveSem := Left(cChaveSem,6)+"999"
			If !dbSeek(If(Empty(RhTamFilial(cFilial)),cFilial,SRA->RA_FILIAL) + "01" + cChaveSem , .T. )
				If !dbSeek(If(Empty(RhTamFilial(cFilial)),cFilial,SRA->RA_FILIAL) + "01" + Subs(cChaveSem,3,4) , .T. )
					HELP( " ",1,"SEMNAOCAD" )
					lRet := .F.
				EndIf
			EndIf
		EndIf
	EndIf

	aSemanas := {}

	If lRet
		While !Eof() .And. RX_TIP == "01"
			If RX_FILIAL == (If(Empty(RhTamFilial(cFilial)),cFilial,SRA->RA_FILIAL)) .And.;
					(Left( RX_COD, 9 ) == cChaveSem .Or. Left( RX_COD, 7 ) == Subs(cChaveSem,3,9))
				If Len(AllTrim(RX_COD)) == 9
					Aadd( aSemanas , { SubStr( RX_COD,8,2 ) , DtoC(CtoD( Left( RX_TXT,8 ),"DDMMYY" )) , DtoC(CtoD( SubStr( RX_TXT,10,8 ) , "DDMMYY" )) , SubStr( RX_TXT, 20,( CtoD( SubStr( RX_TXT,10,8 ) , "DDMMYY" ) - CtoD( Left( RX_TXT,8 ) , "DDMMYY" ) ) + 1 ) , CtoD( SubStr( RX_TXT,10,8 ) , "DDMMYY" ) - CtoD( Left( RX_TXT,8 ) , "DDMMYY" ) + 1 } )
				Else
					Aadd( aSemanas , { SubStr( RX_COD,10,2 ) ,;
						If("/" $ RX_TXT , SubStr( RX_TXT, 1,10) , DtoC(StoD(SubStr( RX_TXT, 1,8 )))) ,;
						If("/" $ RX_TXT , SubStr( RX_TXT, 12,10), DtoC(StoD(SubStr( RX_TXT,12,8 )))) ,;
						SubStr( RX_TXT,24,(  If("/" $ RX_TXT , CtoD(SubStr( RX_TXT, 12,10) , "DDMMYY" ), StoD(SubStr( RX_TXT,12,8 ))) - ;
						If("/" $ RX_TXT , CtoD(SubStr( RX_TXT, 01,10), "DDMMYY"), StoD(SubStr( RX_TXT, 1,8 ))) ) + 1 ) ,;
						If("/" $ RX_TXT , CtoD(SubStr( RX_TXT, 12,10), "DDMMYY"), StoD(SubStr( RX_TXT,12,8 ))) - ;
						If("/" $ RX_TXT , CtoD(SubStr( RX_TXT, 01,10), "DDMMYY"), StoD(SubStr( RX_TXT, 1,8 ))) + 1 } )
				EndIf
			EndIf
			dbSkip()
		Enddo

		Asort(aSemanas, NIL, NIL, { |X,Y| X[1] < Y[1] } )
		lUltSemana := If( cSemana == aSemanas[ Len( aSemanas ),1 ] , .T. , .F. )
		nPosSem	   := Ascan(aSemanas,{|X| x[1] == cSemana})
	EndIf
EndIf

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GPECR01   ºAutor  ³Microsiga           º Data ³  07/15/03   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Grava no arquivo TRB, os valores de diferencas de verbas   º±±
±±º          ³apurados no calculo do Dissidio Retroativo                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ºParametros|aVerbas --> clone do oSRC:acols							  º±±
±±º          |aPdOld  --> mnemonico aPDOld q contem as verbas originais   º±±
±±º          |aPercDif-->                                                 º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GravaDissidio( aVerbas, aPdOld, aPercDis, aCodFol )
Local aArea			:= GetArea()
Local aVerbasLanc	:= {}
Local aVerbasMed	:= {}
Local aPerAberto	:= {}
Local aPerFechado	:= {}
Local nI        	:= 0
Local nPosPD		:= 0
Local nSvRec		:= 0
Local cChave		:= ''
Local cVbPrvAdc		:= ""
Local cVbBasAdc		:= ""
Local cCodDif		:= ""
Local cIndComp		:= ""
Local lRet			:= .T.
Local lAppend		:= .T.
Local lSrvRRA		:= .F.
Local lTemRRA		:= .F.

// Tratamento da existencia da Nova tabela de Dissidio Permanente (RHH)
Local cAliasDis	:= "RHH"

// Tratamento dos encargos de empresa para MV_ENCINSS igual a N
Local nBsInssDis	:= 0.00
Local cAnoMesDis	:= ""
Local nPosDed		:= 0
Local nPos1			:= 0
Local nPos2			:= 0
Local nPos3			:= 0
Local nPos4			:= 0
Local nPos5			:= 0
Local nValOrig		:= 0.00
Local aPdAdic		:= aClone( aPdOld ) //Clonado o array principal para permitir avaliar todas as verbas
Local cTpContr		:= Iif( SRA->RA_TPCONTR $ "12", SRA->RA_TPCONTR, "1" )		// var para controle do tipo de contrato do funcionario
Local cPer 			:= GetPeriodCalc()
Local cLimpa		:= ""
Local lPagDifs		:= .F.
Local lTemVb13Mat	:= ( Len(aCodFol) >= 1447)
Local nTamCC		:= GetSx3Cache("RHH_CC", "X3_TAMANHO")
Local nTamIt		:= GetSx3Cache("RHH_ITEM", "X3_TAMANHO")
Local nTamCl		:= GetSx3Cache("RHH_CLVL", "X3_TAMANHO")
Local cPdFMs		:= ""
Local lAux			:= .F.
Local lValInfo 		:= RHH->(ColumnPos("RHH_VALINF")) > 0
Local nPosOld		:= 0
Local nPosPdOld     := 0
Local nPosAux		:= 0
Local aPdOld2		:= {}
Local nPos6			:= 0
Local nValAux		:= 0
Local nValCompl		:= 0
Local uRet
Local lItemClVl   	:= GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3" // Se utiliza Item e Classe de Valores
Local lTemId1850	:= Len(aCodFol) >= 1850 .And. !Empty(aCodFol[1850, 1])
Local lTemId1855	:= Len(aCodFol) >= 1855 .And. !Empty(aCodFol[1855, 1])
Local lTemId1869	:= Len(aCodFol) >= 1869 .And. !Empty(aCodFol[1869, 1])

Private aInssEmpAM
Private aGPSPer

If ( Type( "cSituacao" ) # "U" .And. !( SRA->RA_SITFOLH $ cSituacao ) )
	Return( lRet )
EndIf

If aPercDis <> Nil
	If Ascan( aPercDis, { |x| x[1] == SRA->RA_FILIAL+SRA->RA_MAT+cPer} ) == 0
		Return( lRet )
	EndIf
	
	// Define o Ano e Mes do calculo do dissidio
	cAnoMesDis := Substr( aPercDis[1,1], Len(SRA->RA_FILIAL+SRA->RA_MAT) + 1, Len(aPercDis[1,1]) )
Else
	If !HMGet(oPercDif, SRA->RA_FILIAL+SRA->RA_MAT+cPer, uRet)
		Return( lRet )
	EndIf
	
	// Define o Ano e Mes do calculo do dissidio
	cAnoMesDis := Substr( uRet[1], Len(SRA->RA_FILIAL+SRA->RA_MAT) + 1, Len(uRet[1]) )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Resgata os percentuais de terceiros armazenados no parametro 15			³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
fGPSVal( SRA->RA_FILIAL, "999999", @aGPSPer, cTpContr )

// Carrega Inss do Mes/Ano em calculo
fInssEmp( SRA->RA_FILIAL, @aInssEmpAM,, cAnoMesDis )

// Soma a Base de Inss do Mes/Ano em calculo
aEval( aPdOld, { |x| nBsInssDis += If ( X[1] $ aCodFol[13,1]+"/"+aCodFol[14,1]+"/"+aCodFol[19,1]+"/"+aCodFol[20,1],x[5],0.00) })

//Verifica os dias de ferias do calculo
nDiasMes := nDiasMse := 0
aEval( aPdOld, { |x| If(x[1] == aCodFol[72,1], nDiasMes := Max(nDiasMes, x[4]), Nil ) } )
aEval( aPdOld, { |x| If(x[1] == aCodFol[73,1], nDiasMse := Max(nDiasMse, x[4]), Nil ) } )
If nDiasMes + nDiasMse == 0
	aEval( aPdOld, { |x| If(x[1] == aCodFol[75,1], nDiasMes := Max(nDiasMes, x[4]), Nil ) } )
	aEval( aPdOld, { |x| If(x[1] == aCodFol[76,1], nDiasMse := Max(nDiasMse, x[4]), Nil ) } )
EndIf
aEval( aPdOld, { |x| If(x[1] == aCodFol[205,1], nDAbMse := Max(nDAbMse, x[4]), Nil ) } )

//-- Calcular Inss Empresa na epoca do efetivo pagamento para apurar diferenca - Somente MV_ENCINSS igual a N
lTemRRA := Type(cIdCmpl) # "U" .and. !Empty(cIdCmpl)

If !LDISSFER11
	fSomaDifs(@aPdOld,SRA->RA_FILIAL)
EndIf

//Se for 132, busca verbas de complemento de 13º pagas na folha
If cTipoRot == "6"
	fRetPerComp(SubStr(cPer,5,2), SubStr(cPer,1,4), Nil, Nil, fGetRotOrdinar(), @aPerAberto, @aPerFechado)
	aVerbasLanc := RetornaVerbasFunc(SRA->RA_FILIAL,SRA->RA_MAT,NIL,fGetRotOrdinar(),,aPerAberto,aPerFechado,,"RV_REF13=='S'")
	aVerbasMed  := RetornaVerbasFunc(SRA->RA_FILIAL,SRA->RA_MAT,NIL,fGetRotOrdinar(),,aPerAberto,aPerFechado,,"RV_MED13=='S '")
	For nPos1 := 1 to Len(aVerbasLanc)
		If aVerbasLanc[nPos1,3] == aCodFol[348,1]//Diferença de média negativa
			lPagDifs := .T.
		ElseIf aVerbasLanc[nPos1,3] == aCodFol[28,1]//Diferença de média positiva
			lPagDifs 	:= .T.
			aPdOld2 	:= aClone( aPd )
			aPd 		:= {}
			nValCompl	+= aVerbasLanc[nPos1, 7]
			
			// Grava no aPD somente a verba de diferença de 13º para calcular os encargos
			FMatriz(aVerbasLanc[nPos1,3],aVerbasLanc[nPos1,7]) 
			
			//Gera as verbas de Base INSS 13º
			FCINSS13(ACODFOL,IF(CTIPOROT $ "5*6",ATINSS13,ATINSS),,NINSSP,NBATLIM,NBACLIM)
			
			//Marca os verbas que não são salário contribuição como deletadas
			aEval(aPd,{|x| x[9] := IF(x[1] $ AcodFol[19,1]+"/"+aCodFol[20,1], " ", "D") } ) 
			
			 // Realiza o cálculo dos encargos.
			fCalcInssFun()
			
			//Deleta as verbas de salário contribuição
			aEval(aPd,{|x| x[9] := IF(x[1] $ AcodFol[19,1]+"/"+aCodFol[20,1], "D", x[9]) } )
			
			// Soma no valor de origem o valor correspondente a 13º
			For nPos6 := 1 to Len(aPd)
				aEval(aPdOld,{|x| x[5] += If(x[1] == aPd[nPos6,1] .And. aPd[nPos6,9] # "D", aPd[nPos6,5], 0.00)} ) 
			Next nPos6 
			
			//Retorna o conteúdo original do Apd
			aPd 	:= aClone( aPdOld2 )
		//necessario incorporar os valores do complemento pois o 132 é recalculado em cima do valor final de dezembro (incluindo a diferença)
		ElseIf ( nPos := aScan(aPdOld,{|x| x[1] $ aVerbasLanc[nPos1,3] }) ) > 0
			aPdOld[nPos,5] += aVerbasLanc[nPos1,7]
		EndIf
	Next nPos1
	If lPagDifs
		If lTemVb13Mat .And. ( nPos := aScan(aPdOld, {|x| x[1] $ aCodFol[1436,1]}) ) > 0//Total de Medias em Valor Maternidade
			aPdOld[nPos,5] := nOrigVlMat
		EndIf
		
		If lTemVb13Mat .And. ( nPos := aScan(aPdOld, {|x| x[1] $ aCodFol[1437,1]}) ) > 0//Total de Medias em Horas Maternidade
			aPdOld[nPos,5] := nOrigHrMat
		EndIf

		If ( nPos := aScan(aPdOld, {|x| x[1] $ aCodFol[123,1]}) ) > 0//Total de Medias em Valor
			aPdOld[nPos,5] := nOrigVal
		EndIf

		If ( nPos := aScan(aPdOld, {|x| x[1] $ aCodFol[124,1]}) ) > 0//Total de Medias em Horas
			If ( aScan(aVerbasMed, {|x| x[17] $ "I*G" }) ) == 0
				nOrigHor += nValCompl
			EndIf
			aPdOld[nPos,5] := nOrigHor - If(nOrigHrMat > 0, nOrigHrMat, 0)
		EndIf
	EndIf
EndIf

//Se for FOL e tiver Dif de 132, busca verba de diferença 13º pagas na folha
If cTipoRot == "1"
	If (nPosPD := aScan(aPd, {|x| x[1] == aCodFol[28,1]})) > 0 .And. (nPosOld := aScan(aPdOld, {|x| x[1] == aCodFol[28,1]})) > 0 //Diferença de média positiva
		//O INSS e FGTS 13º pagos na folha não devem sofrer alteração pois todo o cálculo foi feito no roteiro 132
		cLimpa := aCodFol[108,1] +'*'+ aCodFol[109,1] +'*'+ aCodFol[19,1] +'*'+ aCodFol[20,1] +'*'+ aCodFol[70,1]
		For nPosPd := 1 to Len(aPd)
			If aPd[nPosPd,1] $ cLimpa
				aPd[nPosPd,5] := 0
				If(nPos := aScan(aPdOld, {|x| x[1] == aPd[nPosPd,1] .and. x[2] == aPd[nPosPd,2] .and. x[13] == aPd[nPosPd,13] .and. x[14] == aPd[nPosPd,14] .and. x[9] <> 'D'})) > 0
					aPd[nPosPd,5] := aPdOld[nPos,5]
				EndIf
			EndIf
		Next nPosPd
	EndIf
EndIf

cPdFMs := aCodFol[89,1]+'*'+aCodFol[91,1]+'*'+aCodFol[93,1]+'*'+aCodFol[97,1]+'*'+;
			aCodFol[99,1]+'*'+aCodFol[162,1]+'*'+aCodFol[207,1]+'*'+aCodFol[208,1]+'*'+;
			aCodFol[73,1]+'*'+aCodFol[78,1]+'*'+aCodFol[232,1]+'*'+aCodFol[76,1]+'*'+;
			aCodFol[83,1]+'*'+aCodFol[81,1]+'*'+aCodFol[93,1]+'*'+aCodFol[205,1]+'*'+;
			aCodFol[206,1]+'*'+aCodFol[207,1]+'*'+aCodFol[208,1]+'*'+aCodFol[633,1]+'*'+;
			aCodFol[634,1]+'*'+aCodFol[1331,1]+'*'+aCodFol[1405,1]+'*'+aCodFol[1406,1]+'*'+;
			aCodFol[1409,1]+'*'+aCodFol[1410,1]+'*'+aCodFol[1418,1]+'*'+aCodFol[1419,1]+'*'+;
			aCodFol[1301,1]+'*'+aCodFol[1303,1]+'*'+aCodFol[1305,1]+'*'+aCodFol[1307,1]+'*'+;
			aCodFol[1309,1]+'*'+aCodFol[1311,1]+'*'+aCodFol[1313,1]+'*'+aCodFol[1315,1]+'*'+;
			aCodFol[1317,1]+'*'+aCodFol[1319,1]+'*'+aCodFol[1321,1]+'*'+aCodFol[1323,1]+'*'+;
			aCodFol[1325,1]+'*'+aCodFol[1327,1]

//Tratamento para insalubridade, mas deve ser incluido os outros adicionais oportunamente
cVbBasAdc := aCodFol[672,1]
cVbPrvAdc := aCodFol[37,1]+'*'+aCodFol[38,1]+'*'+aCodFol[39,1]+'*'+aCodFol[1282,1]+'*'

//Se tinha a verba de INSS de férias e INSS de folha no acumulado, se houver situação que o INSS de férias
//chega ao teto, gera a verba de INSS de folha com valor zerado para compensar o reajuste nas férias
If ( nPos1 := aScan(aPdOld, {|x| x[1] == aCodFol[65,1]} ) ) > 0 .And. ( nPos2 := aScan(aPdOld, {|x| x[1] == aCodFol[64,1]} ) ) > 0 .And. ( nPos3 := aScan(aVerbas, {|x| x[1] == aCodFol[65,1]} ) ) > 0
	If ( nPos4 := aScan(aVerbas, {|x| x[1] == aCodFol[64,1]} ) ) == 0
		aAdd( aVerbas, aClone(aVerbas[nPos3]) )
		aVerbas[Len(aVerbas), 1] := aCodFol[64,1]
		aVerbas[Len(aVerbas), 5] := 0.00
		lAux := .T.
	ElseIf aVerbas[nPos4, 9] == "D"
		aVerbas[nPos4, 5] := 0.00
		aVerbas[nPos4, 9] := ""
		lAux := .T.
	ElseIf ( nPos5 := aScan(aPdOld, {|x| x[1] == aCodFol[289,1]} ) ) > 0 .And. ( aPdOld[nPos1, 5] + aPdOld[nPos2, 5] + aPdOld[nPos5, 5] == NoRound(aTInss[Len(aTInss),1] * aTInss[Len(aTInss),2], 2))
		If nPos4 > 0
			aVerbas[nPos4, 5] := ( aPdOld[nPos1, 5] + aPdOld[nPos2, 5] ) - aVerbas[nPos3, 5]
		EndIf
	EndIf
	If lAux
		aVerbas[nPos3, 5] := aPdOld[nPos1, 5] + aPdOld[nPos2, 5]
	EndIf
//Se só teve INSS de férias com recolhimento do teto e MULTV, não reajusta o valor da verba para não gerar diferença
ElseIf ( nPos1 := aScan(aPdOld, {|x| x[1] == aCodFol[65,1]} ) ) > 0 .And. aScan(aPdOld, {|x| x[1] == aCodFol[64,1]} ) == 0 .And. ( nPos2 := aScan(aPdOld, {|x| x[1] == aCodFol[289,1]} ) ) > 0 .And. (aPdOld[nPos1, 5] + aPdOld[nPos2, 5] == NoRound(aTInss[Len(aTInss),1] * aTInss[Len(aTInss),2], 2) )
	If ( nPos2 := aScan(aVerbas, {|x| x[1] == aCodFol[65,1]} ) ) > 0
		aVerbas[nPos2, 5] := aPdOld[nPos1, 5]
	EndIf
EndIf

//Se o(s) vínculo(s) anteriores chegaram ao teto de desconto do INSS e havia sido calculado INSS no recibo original, gera as verbas de INSS com valor zerado
If P_MULTV .And. cTipoRot $ "1/6"
	If cTipoRot == "1"
		If ( nPos1 := aScan(aVerbas, {|x| x[1] == aCodFol[64,1]} ) ) > 0
			nValAux += aVerbas[nPos1, 5]
		EndIf
		If ( nPos2 := aScan(aVerbas, {|x| x[1] == aCodFol[289,1]} ) ) > 0
			nValAux += aVerbas[nPos2, 5]
		EndIf
		If ( nPos3 := aScan(aVerbas, {|x| x[1] == aCodFol[65,1]} ) ) > 0
			nValAux += aVerbas[nPos3, 5]
		EndIf
	Else
		If ( nPos1 := aScan(aVerbas, {|x| x[1] == aCodFol[70,1]} ) ) > 0
			nValAux += aVerbas[nPos1, 5]
		EndIf
		If ( nPos2 := aScan(aVerbas, {|x| x[1] == aCodFol[291,1]} ) ) > 0
			nValAux += aVerbas[nPos2, 5]
		EndIf
	EndIf
	If nValAux == fRetTetIns(aTinss) 
		If aScan(aVerbas, {|x| x[1] == aCodFol[64,1]} ) == 0 .And. aScan(aPdOld, {|x| x[1] == aCodFol[64,1]} ) > 0
			aAdd( aVerbas, aClone(aVerbas[nPos1]) )
			aVerbas[Len(aVerbas), 1] := aCodFol[64,1]
			aVerbas[Len(aVerbas), 5] := 0.00
		EndIf
		If aScan(aVerbas, {|x| x[1] == aCodFol[13,1]} ) == 0 .And. aScan(aPdOld, {|x| x[1] == aCodFol[13,1]} ) > 0
			aAdd( aVerbas, aClone(aVerbas[nPos1]) )
			aVerbas[Len(aVerbas), 1] := aCodFol[13,1]
			aVerbas[Len(aVerbas), 5] := 0.00
		EndIf
	EndIf
EndIf

If cTipoRot == "1" .And. lTemId1850 .And. ( nPos1 := aScan(aPdOld, {|x| x[1] == aCodFol[1397, 1]} ) ) > 0 .And. ( nPos2 := aScan(aVerbas, {|x| x[1] == aCodFol[1397, 1]} ) ) > 0
	If aVerbas[nPos2, 5] < aPdOld[nPos1, 5] .And. aScan(aVerbas, {|x| x[1] == aCodFol[1850, 1]} ) == 0
		aAdd( aVerbas, aClone(aVerbas[nPos2]) )
		aVerbas[Len(aVerbas), 1] := aCodFol[1850, 1]
		aVerbas[Len(aVerbas), 5] := Abs( aVerbas[nPos2, 5] - aPdOld[nPos1, 5] )
	EndIf
EndIf

If cTipoRot == "1" .And. lTemId1855 .And. ( nPos1 := aScan(aPdOld, {|x| x[1] == aCodFol[1282, 1]} ) ) > 0 .And. ( nPos2 := aScan(aVerbas, {|x| x[1] == aCodFol[1282, 1]} ) ) > 0
	If aVerbas[nPos2, 5] < aPdOld[nPos1, 5] .And. aScan(aVerbas, {|x| x[1] == aCodFol[1855, 1]} ) == 0
		aAdd( aVerbas, aClone(aVerbas[nPos2]) )
		aVerbas[Len(aVerbas), 1] := aCodFol[1855, 1]
		aVerbas[Len(aVerbas), 5] := Abs( aVerbas[nPos2, 5] - aPdOld[nPos1, 5] )
	EndIf
EndIf

If cTipoRot == "1" .And. lTemId1869 .And. ( nPos1 := aScan(aPdOld, {|x| x[1] == aCodFol[1281, 1]} ) ) > 0 .And. ( nPos2 := aScan(aVerbas, {|x| x[1] == aCodFol[1281, 1]} ) ) > 0
	If aVerbas[nPos2, 5] < aPdOld[nPos1, 5] .And. aScan(aVerbas, {|x| x[1] == aCodFol[1869, 1]} ) == 0
		aAdd( aVerbas, aClone(aVerbas[nPos2]) )
		aVerbas[Len(aVerbas), 1] := aCodFol[1869, 1]
		aVerbas[Len(aVerbas), 5] := Abs( aVerbas[nPos2, 5] - aPdOld[nPos1, 5] )
	EndIf
EndIf

nPosPd := 0 //zera para nao deletar posicao do aPdOld antes de gravar a verba na RHH
nPosPdOld := 0
For nI := 1 to len( aVerbas )

	If aVerbas[nI,7] == "R" .Or. If( !(Type("lUtiMultiV")<> "U" .And. lUtiMultiV), aVerbas[nI,9] == "D", .F.)
		loop
	EndIf

	SRV->( dbSeek( xFilial( "SRV", SRA->RA_FILIAL ) + aVerbas[nI,1] ) )
	nSvRec := SRV->( Recno() )

	If nPosPd <> 0
		If aPdOld[nPosPd,1] == aCodFol[123,1]
			nOrigVal	:= 0 //em casos de rateio, necessario limpar o valor da media para nao gerar 2 lancamentos com mesmo valor origem, gerando diferença negativa.
		ElseIf aPdOld[nPosPd,1] == aCodFol[124,1]
			nOrigHor 	:= 0
		ElseIf lTemVb13Mat .And. aPdOld[nPosPd,1] == aCodFol[1436,1]
			nOrigVlMat 	:= 0
		ElseIf lTemVb13Mat .And. aPdOld[nPosPd,1] == aCodFol[1437,1]
			nOrigHrMat 	:= 0
		EndIf
		aDel( aPdOld , nPosPd )
		aSize( aPdOld , Len(aPdOld) - 1 )
	EndIf

	nPosPD 	 := Ascan( aPdOld, {|X| X[1] == SRV->RV_COD .And. X[3] == aVerbas[nI,3] .And. X[2] == aVerbas[nI,2] .And. If(lItemClVl, X[13] == aVerbas[nI,13] .And. X[14] == aVerbas[nI,14], .T.) .And. X[11] == aVerbas[nI,11] })
	If nPosPD == 0
		nPosPD 	 := Ascan( aPdOld,{|X| X[1]==SRV->RV_COD .And. X[3] = aVerbas[nI,3] .And. X[11] = aVerbas[nI,11]})
	EndIf
	If nPosPD == 0
		nPosPD 	 := Ascan( aPdOld,{|X| X[1]==SRV->RV_COD .And. X[3] = aVerbas[nI,3] .And. X[2] = aVerbas[nI,2]})
	EndIf
	If nPosPD == 0
		nPosPD 	 := Ascan( aPdOld,{|X| X[1]==SRV->RV_COD .And. X[3] = aVerbas[nI,3]})
	EndIf

	If cPaisLoc == "BRA" .And. nPosPD == 0 .And. ( (RetValSrv( SRV->RV_COD, SRA->RA_FILIAL, "RV_INSS" ) == "S" .And. RetValSrv( SRV->RV_COD, SRA->RA_FILIAL, "RV_INCCP" ) == "15") .Or. (RetValSrv( SRV->RV_COD, SRA->RA_FILIAL, "RV_INSS" ) == "N" .And. RetValSrv( SRV->RV_COD, SRA->RA_FILIAL, "RV_INCCP" ) == "00"))
		nPosPD 	 := Ascan( aPdOld, {|X| !Empty(X[15]) .And. X[15] == aVerbas[nI,15] .And. X[3] == aVerbas[nI,3] .And. X[2] == aVerbas[nI,2] .And. If(lItemClVl, X[13] == aVerbas[nI,13] .And. X[14] == aVerbas[nI,14], .T.) .And. X[11] == aVerbas[nI,11] })
		If nPosPD == 0
			nPosPD 	 := Ascan( aPdOld, {|X| !Empty(X[15]) .And. X[15] == aVerbas[nI,15] .And. X[3] == aVerbas[nI,3] .And. X[11] == aVerbas[nI,11]})
		EndIf
		If nPosPD == 0
			nPosPD 	 := Ascan( aPdOld, {|X| !Empty(X[15]) .And. X[15] == aVerbas[nI,15] .And. X[3] == aVerbas[nI,3] .And. X[2] == aVerbas[nI,2]})
		EndIf
		If nPosPD == 0
			nPosPD 	 := Ascan( aPdOld, {|X| !Empty(X[15]) .And. X[15] == aVerbas[nI,15] .And. X[3] == aVerbas[nI,3]})
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se a contribuicao sindical foi calculada no mes de origem.³
	//³Se nao foi, ignora a verba. Desta forma a diferenca sera apurada   ³
	//³somente no mes em que foi paga a contribuicao sindical.            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If aCodFol[68,1] == aVerbas[nI,1] .and. nPosPD == 0
		Loop
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se a verba do adicional foi utilizada para compor a base  ³
	//³mas nao foi gerada a verba de provento. Ex: funcionario afastado.  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nPosPD == 0 .And. ( SRV->RV_COD $ cVbPrvAdc .And. Ascan( aPdAdic,{|X| X[1] $ cVbBasAdc } ) > 0 )
		Loop
	EndIf

	If nPosPD == 0 .and. ( aVerbas[nI,1] $ aCodFol[75,1] + "/" + aCodFol[623,1] ) //Diferença de média de férias valor
		nPosPD 	 := Ascan( aPdOld,{|X| X[1] == If(aVerbas[nI,1] == aCodFol[75,1], aCodFol[838,1], aCodFol[1417,1]).And. X[3] = aVerbas[nI,3]})
	EndIf

	If SRV->RV_INSS == "S" .OR. SRV->RV_FGTS == "S" .OR. SRV->RV_COMPL_ == "S" .Or. SRV->RV_CODFOL $ "1412"

		cCodDif := SRV->RV_CODCOM_

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se o codigo da verba destino tem incidencia de FGTS/INSS.	³
		//³ Se tiver gera log de inconsistecia.									³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SRV->( dbSeek( xFilial( "SRV", SRA->RA_FILIAL ) + cCodDif ) )

		If lTemRRA
			lSrvRRA := SRV->RV_RRA == "1"
		EndIf

	 	If cPaisLoc == "BRA"
	    	If SRV->RV_INSS == "S" .OR. SRV->RV_FGTS == "S"
				If aTotRegs[1] # 0                                                                                         '
					If len(aLog) >= aTotRegs[1]
						nPos := (Ascan( aLog[aTotRegs[1]],SRV->RV_COD))
			    	Else
			    		nPos := 0
			    	EndIf
		   	 	Else
	    			nPos := 0
	    		EndIf

		    	If nPos == 0
					If aTotRegs[1] == 0 .Or. Len(aLog) == 0
						cLog := OemToAnsi(STR0024) //"Verba destino esta com incidencia de FGTS/INSS"
						Aadd(aTitle,cLog)
						Aadd(aLog,{})
						aTotRegs[1] := len(aLog)
					EndIf
					Aadd(aLog[aTotRegs[1]],SRV->RV_COD +" - "+SRV->RV_DESC )
				EndIf
				lRet := .F.
			EndIf
		EndIf

		// TESTAR ELEMENTO 9 SE ESTA DELETADO
		If If( !(Type("lUtiMultiV")<> "U" .And. lUtiMultiV), aVerbas[nI,9] # "D", .T.) .And. aVerbas[nI,3] == cSemana
			cIndComp	:= If(Empty(aVerbas[nI,2]),Space(nTamCc),aVerbas[nI,2])
			cIndComp	+= If(Empty(aVerbas[nI,13]),Space(nTamIt),aVerbas[nI,13])
            cIndComp	+= If(Empty(aVerbas[nI,14]),Space(nTamCl),aVerbas[nI,14])
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Grava as verbas com diferencas calculadas³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	     	SRV->( dbGoTo(nSvRec) )
			dbSelectArea( cAliasDis )
			(cAliasDis)->(dbSetOrder( 1 )) // RHH_FILIAL+RHH_MAT+RHH_MESANO+RHH_DATA+RHH_VB+RHH_CC+RHH_ITEM+RHH_CLVL+RHH_SEMANA+RHH_SEQ+RHH_ROTEIR

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Testa a existencia do lancamento na tabela de dissidio  ³
			//³antes da inclusao, pois nos casos de IRMULTV a verba ja ³
			//³pode existir e deve ser regravada.                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se trata de multiplos vinculos.				  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			// RHH_FILIAL+RHH_MAT+RHH_MESANO+RHH_DATA+RHH_VB+RHH_CC+RHH_ITEM+RHH_CLVL+RHH_SEMANA+RHH_SEQ+RHH_ROTEIR
			cChave := ( SRA->(RA_FILIAL+RA_MAT)+cMesAnoCalc+cPer+SRV->RV_COD+cIndComp+cSemPag+aVerbas[nI,11]+cRotOrig )

			If 	(cAliasDis)->( dbSeek( cChave ) )
			   	lAppend := ! Found()

		   		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Se existir Sequencia na tabela TRB/RHH, testa se o registro	³
				//³ correspondente tambem existe para nao adicionar mais um.	³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			   	IF !lAppend .and. FieldPos( (cAliasDis)+"_SEQ" ) # 0
					While (cAliasDis)->(!Eof()) .and. ( cChave == (SRA->(RA_FILIAL+RA_MAT)+cMesAnoCalc+cPer+(cAliasDis)->&((cAliasDis)+"_VB")+cIndComp+cSemPag+alltrim(Str(val(csemana)))))
						IF (cAliasDis)->&((cAliasDis)+"_SEQ") == aVerbas[nI,11]
							lAppend := .F.
							Exit
						Else
							lAppend := .T.
						EndIf
					    (cAliasDis)->( DbSkip() )
				 	End While
				 EndIf
				 RecLock( cAliasDis, lAppend, .T. )

				 If Type("lUtiMultiV")<> "U" .And. lUtiMultiV .And. aVerbas[nI,9] == "D"
				 	(cAliasDis)->( dbDelete() )
				 	(cAliasDis)->( MsUnlock() )
				 	Loop
				 EndIf
			Else
				If Type("lUtiMultiV")<> "U" .And. lUtiMultiV .And. aVerbas[nI,9] == "D"
					Loop
				EndIf
				RecLock( cAliasDis, .T., .T. )
		 	EndIf

			(cAliasDis)->&((cAliasDis)+"_FILIAL")	:= SRA->RA_FILIAL
			(cAliasDis)->&((cAliasDis)+"_MAT")		:= SRA->RA_MAT
			(cAliasDis)->&((cAliasDis)+"_VB")		:= SRV->RV_COD               //Verba origem
			(cAliasDis)->&((cAliasDis)+"_CC")		:= aVerbas[nI,2]

			(cAliasDis)->&((cAliasDis)+"_DATA")	:= cPer//MesAno(dDataBase)

			//Verba destino
			If Empty(SRV->RV_CODCOM_) .and. !(SRV->RV_CODFOL $ "0072/0074/0077/0079/0084/1412")
				If aTotRegs[2] # 0
					If len(aLog) >= aTotRegs[2]
						nPos := (Ascan( aLog[aTotRegs[2]],SRV->RV_COD))
			    	Else
			    		nPos := 0
			    	EndIf
			    Else
		    		nPos := 0
	    		EndIf

	   		 	If nPos == 0
					If aTotRegs[2] == 0 .or. Len(aLog) < aTotRegs[2]
						cLog := OemToAnsi(STR0025) //"Verba destino nao foi informada"
						Aadd(aTitle,cLog)
						Aadd(aLog,{})
						aTotRegs[2] := Len(aLog)
					EndIf
					Aadd(aLog[aTotRegs[2]],SRV->RV_COD +" - "+SRV->RV_DESC )
				EndIf
			Else
				(cAliasDis)->&((cAliasDis)+"_VERBA") := SRV->RV_CODCOM_
			EndIf

			// Calcula o Valor original quando MV_ENCINSS igual a N
			nValOrig	:= 0.00		// Valor Original para Encargos
			nPosDed		:= 0		// Posicao do Encargo

			// Se entrar nesta condicao indica que houve ferias no mes do dissidio a gravar
			If nDiasMes > 0 .and. (nDiasMse + nDAbMse ) > 0
				If lDissFer11
	             // Houve pagto no Mes/Ano do Dissidio a Gravar
					If nPosPD > 0
						(cAliasDis)->&((cAliasDis)+"_VL") := aPdOld[ nPosPD, 5 ]

					// Verifica se a verba se refere a ID's de Ferias
					ElseIf aVerbas[nI,1] $ 	aCodFol[89,1]+'*'+aCodFol[91,1]+'*'+aCodFol[93,1]+'*'+aCodFol[97,1]+'*'+;
											aCodFol[99,1]+'*'+aCodFol[162,1]+'*'+aCodFol[207,1]+'*'+aCodFol[208,1]+'*'+aCodFol[839,1]+'*'+aCodFol[1451,1]+'*'+aCodFol[1418,1]+'*'+aCodFol[1419,1]
						(cAliasDis)->&((cAliasDis)+"_VL") := aVerbas[nI,5]

					// Se nPosDed estiver maior que 1, indica que eh verba de Encargos no Mes do Dissidio a Gravar no mesmo mes de Ferias.
					// Se nPosDed estiver com ZERO indica que MV_ENCINSS eh igual a "S" ou que nao eh verba de Encargos no mesmo mes de Ferias.
					ElseIf nPosDed > 0
						(cAliasDis)->&((cAliasDis)+"_VL") := nValOrig

					Else
						(cAliasDis)->&((cAliasDis)+"_VL") := 0.00	// Grava Zeros se nao se enquadrar em nenhuma condicao acima.
					EndIf
				Else
					// Houve pagto no Mes/Ano do Dissidio a Gravar
					If nPosPD > 0 .And. !(aVerbas[nI,1] $ cPdFMs)
						(cAliasDis)->&((cAliasDis)+"_VL") := aPdOld[ nPosPD, 5 ]

					// Verifica se a verba se refere a ID's de Ferias
					ElseIf aVerbas[nI,1] $ cPdFMs
						(cAliasDis)->&((cAliasDis)+"_VL") := aVerbas[nI,5]

					// Se nPosDed estiver maior que 1, indica que eh verba de Encargos no Mes do Dissidio a Gravar no mesmo mes de Ferias.
					// Se nPosDed estiver com ZERO indica que MV_ENCINSS eh igual a "S" ou que nao eh verba de Encargos no mesmo mes de Ferias.
					ElseIf nPosDed > 0
						(cAliasDis)->&((cAliasDis)+"_VL") := nValOrig

					Else
						If aVerbas[nI,1] $ (aCodFol[88,1]+'*'+aCodFol[90,1]+'*'+aCodFol[92,1]+'*'+aCodFol[96,1]+'*'+;
											aCodFol[98,1]+'*'+aCodFol[161,1]+'*'+aCodFol[94,1]+'*'+aCodFol[95,1]+'*'+;
											aCodFol[72,1]+'*'+aCodFol[77,1])
							(cAliasDis)->&((cAliasDis)+"_VL") := aVerbas[nI, 19]
						Else
							(cAliasDis)->&((cAliasDis)+"_VL") := 0.00	// Grava Zeros se nao se enquadrar em nenhuma condicao acima.
						EndIf
					EndIf
				EndIf
			Else
				If aVerbas[nI,1] == aCodFol[123,1]//Total de Medias em Valor
					nValOrig := nOrigVal
				ElseIf aVerbas[nI,1] == aCodFol[124,1]//Total de Medias em Horas
					nValOrig := nOrigHor
				ElseIf lTemVb13Mat .And. aVerbas[nI,1] == aCodFol[1436,1]//Total de Medias em Valor Maternidade
					nValOrig := nOrigVlMat
				ElseIf lTemVb13Mat .And. aVerbas[nI,1] == aCodFol[1437,1]//Total de Medias em Horas Maternidade
					nValOrig := nOrigHrMat
				ElseIf aVerbas[nI,1] $ (aCodFol[1282,1]+'/'+aCodfol[1339,1]+'/'+aCodfol[37,1]+'/'+aCodfol[38,1]+'*'+aCodfol[39,1]) .And. nPosPD == 0//Insalubridade
					aEval( aPdOld, { |X| If( x[1] $ (aCodfol[37,1]+'/'+aCodfol[38,1]+'/'+aCodfol[39,1]), nValOrig += x[5], Nil ) } )
				ElseIf aVerbas[nI,1] $ (aCodFol[1281,1]+'/'+aCodfol[1340,1]) .And. nPosPD == 0//Periculosidade
					aEval( aPdOld, { |X| If( x[1] == aCodfol[36,1], nValOrig += x[5], Nil ) } )
				ElseIf aVerbas[nI,1] == aCodFol[1283,1] .And. nPosPD == 0//Anuenio
					aEval( aPdOld, { |X| If( x[1] == aCodfol[1,1], nValOrig += x[5], Nil ) } )
				ElseIf aVerbas[nI,1] == aCodFol[1284,1] .And. nPosPD == 0//Bienio
					aEval( aPdOld, { |X| If( x[1] == aCodfol[2,1], nValOrig += x[5], Nil ) } )
				ElseIf aVerbas[nI,1] == aCodFol[1285,1] .And. nPosPD == 0//Trienio
					aEval( aPdOld, { |X| If( x[1] == aCodfol[3,1], nValOrig += x[5], Nil ) } )
				ElseIf aVerbas[nI,1] == aCodFol[1286,1] .And. nPosPD == 0//Quadrienio
					aEval( aPdOld, { |X| If( x[1] == aCodfol[4,1], nValOrig += x[5], Nil ) } )
				ElseIf aVerbas[nI,1] == aCodFol[1287,1] .And. nPosPD == 0//Quinquenio
					aEval( aPdOld, { |X| If( x[1] == aCodfol[5,1], nValOrig += x[5], Nil ) } )
				ElseIf aVerbas[nI,1] == aCodFol[1338,1] .And. nPosPD == 0//ATS maternidade
					aEval( aPdOld, { |X| If( x[1] $ (aCodfol[1,1]+'/'+aCodfol[2,1]+'/'+aCodfol[3,1]+'/'+aCodfol[4,1]+'/'+aCodfol[5,1]), nValOrig += x[5], Nil ) } )
				EndIf
				(cAliasDis)->&((cAliasDis)+"_VL") := If( nPosPD > 0, aPdOld[nPosPD,5], nValOrig )
			EndIf

			//Trata a devolucao do Inss de Ferias que foi gerado na folha(Id 1412)
			//Adiciona ao Inss atualizado o valor que foi devolvido ao funcionario
			If (cAliasDis)->&((cAliasDis)+"_VB") == aCodFol[64,1]
				If( Len(aCodFol) >= 1412 .And. !Empty(aCodFol[1412,1]) )
					nPosPdOld := nPosPD
					nPosPD := Ascan( aPdOld,{|X| X[1] == aCodFol[1412,1] })
					If nPosPD > 0
						aVerbas[nI,5] += aPdOld[nPosPD,5]
					EndIf
					nPosPD := nPosPdOld
				EndIf
			EndIf
 			
			(cAliasDis)->&((cAliasDis)+"_CALC")	:= aVerbas[nI,5] 		// Valor Calculado
			If ( (lTemId1850 .And. SRV->RV_CODFOL == "1397") .Or. ;
				( lTemId1855 .And. SRV->RV_CODFOL == "1282") .Or. ;
				( lTemId1869 .And. SRV->RV_CODFOL == "1281") ) .And.;
				(cAliasDis)->&((cAliasDis)+"_CALC") - (cAliasDis)->&((cAliasDis)+"_VL") < 0
 				(cAliasDis)->&((cAliasDis)+"_VALOR")	:= 0// Diferenca
			Else
				(cAliasDis)->&((cAliasDis)+"_VALOR")	:= (cAliasDis)->&((cAliasDis)+"_CALC") - (cAliasDis)->&((cAliasDis)+"_VL")	// Diferenca
			EndIf

			If !Empty(SRV->RV_CODCOM_) .and. SRV->RV_COMPL_ == "S"
				(cAliasDis)->&((cAliasDis)+"_COMPL_") := "S"
			Else
				(cAliasDis)->&((cAliasDis)+"_COMPL_") := "N"
			EndIf

			(cAliasDis)->&((cAliasDis)+"_SEMANA") := cSemPag

			RHH->RHH_MESANO	:= cMesAnoCalc
			RHH->RHH_TIPO1	:= aVerbas[nI,6]
			RHH->RHH_TIPO2	:= aVerbas[nI,7]
			RHH->RHH_HORAS	:= aVerbas[nI,4]
			RHH->RHH_PARC	:= aVerbas[nI,8]
			RHH->RHH_SEQ	:= aVerbas[nI,11]
			RHH->RHH_QTDSEM	:= aVerbas[nI,12]
			RHH->RHH_DTPGT	:= aVerbas[nI,10]

			If lTemRRA
				RHH->RHH_IDCMPL		:= cIdCmpl
				//Se mes e ano de pagamento for diferente de mes e ano da referencia, deve gerar RRA
				If SubStr(cPer,1,4) < SubStr( cMesAnoCalc,1,4 ) .and. lSrvRRA
					RHH->RHH_RRA := '1'
				Else
					RHH->RHH_RRA := '0'
				EndIf
			EndIf

			RHH->RHH_TPOAUM	:= cTipoAum		// Na rotina original nao gravava este campo
			RHH->RHH_PROCES := cProcesso
			RHH->RHH_ROTEIR := cRotOrig


			(cAliasDis)->&((cAliasDis)+"_ITEM") := aVerbas[nI,13]

			(cAliasDis)->&((cAliasDis)+"_CLVL") := aVerbas[nI,14]
			
			If lValInfo
				If Len(aDissInf) > 0 .and. ( nPosAux := aScan( aDissInf, { | X | SRA->RA_FILIAL + SRA->RA_MAT + cRotOrig + cPer + cSemPag + SRV->RV_COD == X[1] + X[2] + X[3] + X[4] + X[5] + X[6] .And. x[9] == aVerbas[nI,10] } ) ) > 0
					(cAliasDis)->&((cAliasDis)+"_VALINF") := aDissInf[nPosAux,7]
					(cAliasDis)->&((cAliasDis)+"_TIPO3")  := aDissInf[nPosAux,8]
				Else
				  (cAliasDis)->&((cAliasDis)+"_TIPO3")  := "C"
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ P.E. para alterar informacoes na gravacao do arquivo de dissidio(TRB/RHH) ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ExistBlock( "GP020VBDI" )
				ExecBlock( "GP020VBDI" ,.F.,.F. )
			EndIf

			( cAliasDis )->( MsUnlock() )

		EndIf
	EndIf
Next

aVerbas	:= {}
aPdOld	:= {}
RestArea(aArea)

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³FGetCodFol	    ³ Autor ³Mauricio T. Takakura³ Data ³10/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Efetua a Carga do aNewCodFol                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>								       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                    	       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function FGetCodFol( cCodCalc	,;		// Codigo Identificador de Calculo
					 lMsg		,;		// Se mostra Help ou nao
					 cFilSRV    ,;      // Filial a ser processada
					 lDesc		;		// Se retorna a descricao do Identificador
				    )

Local cMsg
Local cCodRet := ""

DEFAULT cFilSRV	:= xFilial("SRV")
DEFAULT lMsg	:= .F.
DEFAULT lDesc	:= .F.

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Apesar de existir o controle de static no fp_codfol³
³foi necessario utilizarmos este recurso para ganha-³
³rmos em performace. O aClone da static estava geran³
³do uma perda grande de tempo.                      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static __aCodFol__ := {}
Static __cFilAux__ := "####!!!!"

Begin Sequence

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Carrega o array com os identificadores 			³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF ( Empty(__aCodFol__) .or. __cFilAux__ <> cFilSRV )
		__aCodFol__ := {}
		If ( !fp_CodFol( @__aCodFol__ , cFilSRV, lMsg ) )

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Quando estiver sendo chamado pelo roteiro, finalizar³
			³a execucao, pois houve um erro no IDC				 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			FinalCalc()		// Finaliza o cálculo

			Break
		EndIf
	EndIf

	__cFilAux__ := cFilSRV

	If Val( cCodCalc ) < 0 .Or. Val( cCodCalc ) > Len( __aCodFol__ )

 		cMsg := OemToAnsi(STR0001 + " " + cCodCalc + " " + STR0002) // "Identificador de Calculo " ## "nao Existe!"
		AddLogExecRot( cMsg )		// adiciona no Log de Erros

		If lMsg
			MsgInfo( cMsg )
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Quando estiver sendo chamado pelo roteiro, finalizar³
		³a execucao, pois houve um erro no IDC				 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		FinalCalc()		// Finaliza o cálculo

		Break

	EndIf

	If !lDesc
		cCodRet := __aCodFol__[ Val( cCodCalc ), 1 ]
	Else
		cCodRet := __aCodFol__[ Val( cCodCalc ), 2 ]
	EndIf

End Sequence

Return( cCodRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³   Funcoes criadas para chamada dos metodos da classe GPECFORM.CLS     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_New          ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Chamada ao Method New() da Classe GetDetFormula              ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_New ( @oObj )							                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³self                                                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_New( oObj, cAlias , nOrder , cKey , cQueryWhere , lSqlWhere , lTopFilter )

IF (( ValType( oObj ) == "O" ) .and.;
	( Len(oObj:aHeader) > 0 ))
	oObj:GetCols( nOrder , cKey , cQueryWhere , lSqlWhere, lTopFilter )
Else
	oObj := GetObjFormula( cAlias , nOrder , cKey , cQueryWhere , lSqlWhere , lTopFilter )
EndIf

Return ( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_Put          ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Grava os Detalhes nas Respectivas Tabelas                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_Put ( @oObj )							                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lPutOk                                                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_Put ( oObj , uFieldsDel , uCntDel )

Local lPutOk

	lPutOk := oObj:Put( uFieldsDel , uCntDel )

Return ( lPutOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_Add          ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Adiciona um novo Detalhe ao aCols da Tabela                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_Add ( @oObj )							                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lAddOk                                                 	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_Add( oObj , uFields , uCnts , uFieldsKey , uCntFieldsKey , lChkUnique )

Local lAddOk

	lAddOk := oObj:Add( uFields , uCnts , uFieldsKey , uCntFieldsKey , lChkUnique )

Return ( lAddOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_Get          ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem um Item ou Itens conforme parametros                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_Get ( @oObj )							                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Array com o conteudo dos campos solicitado em uCposGet.      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_Get( oObj , uCposGet , uFieldsKey , uCntFieldsKey , lAscAllKeys )

Local uGetDet

	uGetDet := oObj:Get( uCposGet , uFieldsKey , uCntFieldsKey , lAscAllKeys )

Return ( uGetDet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_SetVal       ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Seta o Conteudo do Campo conforme Registro Posicionado		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_SetVal ( @oObj )							                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³uLstVal                                                      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_SetVal( oObj , cCpo , uCnt , nLine )

Local uLstVal

	uLstVal := oObj:SetVal( cCpo , uCnt , nLine )

Return ( uLstVal )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_GetVal       ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem o Conteudo do Campo conforme Registro Posicionado		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_GetVal ( @oObj )							                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³conteudo do campo solicitado.                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_GetVal( oObj , cCpo , nLine )

Local uGetVal

	uGetVal := oObj:GetVal( cCpo , nLine )

Return ( uGetVal )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_GetPos       ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Array com Posicionamento dos Itens					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_GetPos ( @oObj )							                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Array com o posicionamento dos registros, conforme parametros³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_GetPos( oObj , uFieldsKey , uCntFieldsKey , lAscAllKeys, lGdDeleted )

Local aGetPosDet

	aGetPosDet := oObj:GetPos( uFieldsKey , uCntFieldsKey , lAscAllKeys, lGdDeleted )

Return ( aGetPosDet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_Count        ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna o Numero de Elementos que Atendam a Condicao		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_Count ( @oObj )							                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Numero de elementos que atenderam a condicao                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_Count( oObj , uFieldsKey , uCntFieldsKey , lDeleted )

Local nCount

	nCount := oObj:Count( uFieldsKey , uCntFieldsKey , lDeleted )

Return ( nCount )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_Del          ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Deleta Detalhe(s) do aCols conforme uFields e uCnts			 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_Del ( @oObj )			    			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lDelOk                                               	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_Del( oObj , uFields , uCnts )

Local lDelOk

	lDelOk := oObj:Del( uFields , uCnts )

Return ( lDelOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_UnDel        ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Restaura Detalhe(s) do aCols conforme uFields e uCnts		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_UnDel ( @oObj )			    			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lDelOk                                               	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_UnDel( oObj , uFields , uCnts )

Local lUnDelOk

	lUnDelOk := oObj:UnDel( uFields , uCnts )

Return ( lUnDelOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_Delete       ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Deleta o Elemento Posicionado ou Passado como parametro		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_Delete ( @oObj )			    			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lDelOk                                               	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_Delete( oObj , nElem )

Local lDeleted

	lDeleted:= oObj:Delete( nElem )

Return ( lDeleted )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_Deleted      ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica se o Elemento Esta Deletado no aCols				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_Deleted ( @oObj )		    			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lDelOk                                               	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_Deleted( oObj , nElem )

Local lDeleted

	lDeleted:= oObj:Deleted( nElem )

Return ( lDeleted )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_Restore      ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Restaura um Elemento Especifico no aCols     				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_Restore ( @oObj )		    			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRestore                                               	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_Restore( oObj , nElem )

Local lRestore

	lRestore := oObj:Restore( nElem )

Return ( lRestore )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_Default      ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializa os Valores DEFAULT para os campos				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_Default ( @oObj )		    			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                    	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_Default( oObj , uDefaultCpo , uFieldsKey , uCntFieldsKey , nLine , lInitPad )

	oObj:Default( uDefaultCpo , uFieldsKey , uCntFieldsKey , nLine , lInitPad )

Return ( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_GetnElem     ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna o Numero de Elementos do aCols      				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_GetnElem ( @oObj )			   			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Numero de elementos do aCols.                          	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_GetnElem( oObj )

Local nElem

	nElem := oObj:GetnElem()

Return ( nElem )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_Skip         ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Salta Registro(s) em aCols									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_Skip ( @oObj )    			   			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Retorna a posicao do elemento para qual saltou.        	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_Skip( oObj , nSkipper )

Local nSkip

	nSkip := oObj:Skip( nSkipper )

Return ( nSkip )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_Seek         ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Procura Registro no aCols									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_Seek ( @oObj )    			   			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lFound										        	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_Seek( oObj , uFieldsKey , uCntFieldsKey , lNoDeleted )

Local lFound

	lFound := oObj:Seek( uFieldsKey , uCntFieldsKey , lNoDeleted )

Return (lFound )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_Goto         ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Posiciona em um Determinado Elemento em aCols				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_Goto ( @oObj )    			   			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lGoto										        	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_Goto( oObj , nGoto )

Local lGoto

	lGoto := oObj:Goto( nGoto )

Return ( lGoto )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_GotoPrev     ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem Todos os Registros conforme chave e Posiciona ( do ulti³
³          ³mo encontrado para o primeiro )								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_GotoPrev ( @oObj )  			   			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lGoto										        	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_GotoPrev( oObj , uFieldsKey , uCntFieldsKey )

Local lGoto

	lGoto := oObj:GotoPrev( uFieldsKey , uCntFieldsKey )

Return ( lGoto )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_GotoNext     ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem Todos os Registros conforme chave e Posiciona ( do  pri³
³          ³meiro encontrado para o ultimo )							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_GotoNext ( @oObj )  			   			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lGoto										        	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_GotoNext( oObj , uFieldsKey , uCntFieldsKey )

Local lGoto

	lGoto := oObj:GotoNext( uFieldsKey , uCntFieldsKey )

Return ( lGoto )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_GoTop        ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Posiciona no Primeiro Elemento do aCols      				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_GoTop ( @oObj ) 	    		   			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lGoto										        	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_GoTop( oObj )

Local lGoto

	lGoto := oObj:GoTop()

Return ( lGoto )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_GoBottom     ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Posiciona no Ultimo Elemento do aCols       				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_GoBottom( @oObj )  	  		   			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lGoto										        	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_GoBottom( oObj )

Local lGoto

	lGoto := oObj:GoBottom()

Return ( lGoto )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_Bof          ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica se aCols em "Inicio de Arquivo"       				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_Bof ( @oObj )  	  	    	   			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lBof										        	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_Bof( oObj , lChkSkip )

Local lBof

	lBof := oObj:Bof( lChkSkip )

Return ( lBof )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_Eof          ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica se aCols em "Fim de Arquivo"       				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_Eof ( @oObj )  	  	    	   			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lEof										        	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_Eof( oObj , lChkSkip )

Local lEof

	lEof := oObj:Eof( lChkSkip )

Return ( lEof )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_AtOk         ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica se ::nAt esta OK									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_AtOk ( @oObj )  	  	    	   			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lAtOk										        	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_AtOk( oObj , nLine , lChkSkip )

Local lAtOk

	lAtOk := oObj:AtOk( nLine , lChkSkip )

Return ( lAtOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_GetOk        ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Se Esta Tudo Ok com a Carga das Informacoes					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_GetOk ( @oObj ) 	  	    	   			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lGetOk										        	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_GetOk( oObj )

Local lGetOk

	lGetOk := oObj:GetOk()

Return ( lGetOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_SomaAllRegs  ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna a Soma de Todos os valores do campo passado em cCpoSo³
³          ³ma e de acordo com as condicoes definidas em uFieldsKey     e³
³          ³uCntFieldsKey												 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_SomaAllRegs ( @oObj )	   	   			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Soma dos valores dos campos solicitados.	        	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_SomaAllRegs( oObj , cCpoSoma , uFieldsKey , uCntFieldsKey )

Local lSomaRegs

	lSomaRegs := oObj:SomaAllRegs( cCpoSoma , uFieldsKey , uCntFieldsKey )

Return ( lSomaRegs )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_SomaIncSrv   ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Soma Valores conforme Incidencias do SRV	  			     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_SomaIncSrv ( @oObj )	    	   			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Soma dos valores do campo passado em cCpoSoma        	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_SomaIncSrv( oObj , cCpoSoma , uRvCpos , uRvCnts , cSrvFilial )

Local lSomaIncSrv

	lSomaIncSrv := oObj:SomaIncSrv( cCpoSoma , uRvCpos , uRvCnts , cSrvFilial )

Return ( lSomaIncSrv )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fo_GetCpoPdSrv  ³ Autor ³Tatiane Matias    ³ Data ³14/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna o Campo de Provento e Desconto conforme Alias		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fo_GetCpoPdSrv ( @oObj )    	   			                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³cCpoPd                                                 	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fo_GetCpoPdSrv( oObj , cForcePD )

Local cCpoPd

	cCpoPd := oObj:GetCpoPdSrv( cForcePD )

Return ( cCpoPd )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fFormula      ³ Autor ³Mauricio T. Takakura³ Data ³11/03/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Chamada para a execucao de uma formula.                 	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fFormula( cFormula )    	   			                 	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³True or False                                          	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Formulas		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fFormula( cFormula, lExibe, cAlias, lVar )

Local aArea 	:= GetArea()
Local aLog

Local cMsg
Local cFilArq	:= ""

Local lRet 		:= .T.

Local nX
Local nY
Local nExecRot	:= 0

DEFAULT cAlias 	:= Alias()
Default lExibe := .T.

cFilArq := xFilial( cAlias )

If MV_MODFOL == '1'
	MsAguarde( {|| nExecRot := ExecForm( cFilArq, cFormula ) }, OemToAnsi( STR0003 ), If(lExibe,OemToAnsi( STR0004 ) + " " + cFormula,"") ) //"Aguarde..."###""Executando a Formula " ###
Else
	cFormula := Alltrim(cFormula)
	If cFormula == "327SDI"
		cFormula := "SDI"
	EndIf
	cFormula := cFormula + Space(GetSx3Cache("RY_CALCULO", "X3_TAMANHO")-Len(cFormula))

	nPosStatus := If( SRA->RA_SITFOLH = 'D', 2, 1)

	MsAguarde( {|| nExecRot := fFormM2(cFormula, lExibe, cAlias, lVar ) }, OemToAnsi( STR0003 ), If(lExibe,OemToAnsi( STR0004 ) + " " + cFormula,"") ) //"Aguarde..."###""Executando a Formula " ###

EndIf

If nExecRot < 0
	aLog := LogExecRot()

	cMsg := ""
	For nX := 1 To Len( aLog )
		If !Empty( aLog[ nX, 2 ] )
			For nY := 1 To Len( aLog[ nX, 2 ] )
				cMsg += aLog[ nX, 2, nY ] + CRLF
			Next nY
		EndIf
	Next nX
	If !Empty( cMsg )
		MsgAlert( OemToAnsi( cMsg ) , OemToAnsi( STR0005 ) ) //cMsg"###"Aten‡„o"
	EndIf

	lRet := .F.
EndIf

RestArea( aArea )

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fFormM2		  ³ Autor ³Mauricio Takakura   ³ Data ³19/05/2011³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Execucao do Calculo Modelo II atraves de funcao e campos	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fFormM2( cFormula, lExibe)                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³nValor (em horas ou valor)                            	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fFormM2(cFormula, lExibe, cAlias, lVar)

	Local aArea			:= GetArea()
	Local aTables		:= {}
	Local aSvCols		:= {}

	Local cCpoPref		:= ""
	Local cPrefSRA
	Local cFilSRA
	Local cProcSRA
	Local cDeptoSRA
	Local cCodFunSRA
	Local cCodRPatSRA
	Local cCCSRA
	Local cKeyLocSRA
	Local cSindicaSRA
	Local cTnoTrabSRA
	Local cMatSRA

	Local lRet			:= .T.

	Local nY			:= 0
	Local nRet			:= 0

	Private __aFormulas	:= {}

	Private aPd			:= {}
	Private aRotPd		:= {}
	Private aMnemonicos	:= {}
	Private aOperador  	:= {}
	Private aDefTab		:= {}
	Private aIncid		:= {}
	Private aValFut		:= {}
	Private aAfast		:= {}
	Private aTypAus		:= {}
	Private aBenef		:= {}

	Private cProces		:= ""
	Private cRoteiro	:= cFormula
	Private cPeriodo	:= Space( TamSX3( "RCH_PER" )[1] )
	Private cNumPag		:= Space( TamSX3( "RCH_NUMPAG" )[1] )
	Private lHabGrab	:= .F.

	Private dDataIni	:= Ctod("//")
	Private dDataFim	:= Ctod("//")

	DEFAULT cAlias 		:= Alias()
	DEFAULT lVar		:= .T.

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Limpar as Variaveis Statics do Calculo - Declaradas em GPEXFOR1          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	RstNewCalc()

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Criacao do Arquivo de LOG                                                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !CreateLog()
		Aviso( OemToAnsi(STR0005), OemToAnsi(STR0011), {STR0012} ) // "Atenção"##"Não foi possivel criar o arquivo de Log!"##"OK"
		Return
	EndIf

	cCpoPref := PrefixoCpo( cAlias )
	If lVar
		cCpoPref := "M->" + cCpoPref
	Else
	 	cCpoPref := cAlias + "->" + cCpoPref
	EndIf

	cProces := &( cCpoPref + "_PROCES" )

	// Posicionar na tabela de Processo e Roteiro
	If ExistCpo("RCJ", cProces) .and. ExistCpo("SRY", cRoteiro)
		lRet := VldPeriodo()
		If !lRet
			Aviso( OemToAnsi(STR0005), OemToAnsi(STR0019), {STR0012} ) // "Atenção"##"Não foi possivel carregar as Manutenções de Tabelas!"##"OK"
			Return(.F.)
		EndIf
	Else
		Return( .F. )
	EndIf

	// Carregar as tabelas liberadas no calculo
	GetTableCalc( @aTables )

	AddMsgLog(OemToAnsi(STR0014))	//"Carga das Verbas por Processo..."
	If !fGetPdRot(@aPd, @aRotPd, aTables, cProces, cRoteiro )
		Aviso( OemToAnsi(STR0005), OemToAnsi(STR0013), {STR0012} ) // "Atenção"##"Não foi possivel carregar as Verbas por Processo!"##"OK"
		AddMsgLog(OemToAnsi(STR0013)) //"Não foi possivel carregar as Verbas por Processo!"
		nRet := -1
	EndIf

	AddMsgLog(OemToAnsi(STR0015))	//"Carga dos Mnemonicos..."
	If !fGetMnem(@aMnemonicos, @aOperador, cProces, cRoteiro,,, aTables )
		Aviso( OemToAnsi(STR0005), OemToAnsi(STR0016), {STR0012} ) // "Atenção"##"Não foi possivel carregar os Mnemonicos e/ou Operadores!"##"OK"
		AddMsgLog(OemToAnsi(STR0016)) // "Não foi possivel carregar os Mnemonicos e/ou Operadores!"
		nRet := -1
	EndIf

	AddMsgLog(OemToAnsi(STR0017))	//"Carga das Tabelas de Parametros (Definicao de Tabelas)..."
	If !fGetDefTab(@aDefTab, cProces, cRoteiro, dDataIni)
		Aviso( OemToAnsi(STR0005), OemToAnsi(STR0018), {STR0012} ) // "Atenção"##"Não foi possivel carregar as Manutenções de Tabelas!"##"OK"
		AddMsgLog(OemToAnsi(STR0018)) //"Não foi possivel carregar as Manutenções de Tabelas!"
		nRet := -1
	EndIf

	AddMsgLog(OemToAnsi(STR0022))	//"Carga das Formulas ..."
	__aFormulas := fGetForm(aRotPd, aTables)
	If Len(__aFormulas) == 0
		Aviso( OemToAnsi(STR0005), OemToAnsi(STR0023), {STR0012} ) // "Atenção"##"Não foi possivel carregar as Formulas!"##"OK"
		AddMsgLog(OemToAnsi(STR0023)) //"Não foi possivel carregar as Formulas!"
		nRet := -1
	EndIf
	AddMsgLog("")
	AddMsgLog("")

	// Carrega/Gera acols com os inicializadores padroes.
	For nY := 1 To Len(aTables)
		If aTables[nY, 4] == 1
			aSvCols := GdRmkaCols(aTables[nY, 2]) // Gera uma linha do aCols para a tabela com os inicializadores padrão
			aTables[nY,5] := aClone(aSvCols[1])
			RollBackSx8()//Despreza numeracoes inicializadas com sx8
		EndIf
	Next nY

	// Se vier do SRA, ler os dados da variavel, senao da tabela
	If cAlias == "SRA"
		cFilSRA 	:= xFilial( "SRA" )
		If lVar
			cPrefSRA := "M->"
		Else
	 		cPrefSRA := cAlias + "->"
		EndIf
	Else
		cPrefSRA := "SRA->"
		cFilSRA := SRA->RA_FILIAL
	EndIf
	cProcSRA 	:= &(cPrefSRA + "RA_PROCES")
	cDeptoSRA	:= &(cPrefSRA + "RA_DEPTO")
	cCodFunSRA	:= &(cPrefSRA + "RA_CODFUNC")
	cCodRPatSRA := &(cPrefSRA + "RA_CODRPAT")
	cCCSRA		:= &(cPrefSRA + "RA_CC")
	cKeyLocSRA 	:= &(cPrefSRA + "RA_KEYLOC")
	cSindicaSRA := &(cPrefSRA + "RA_SINDICA")
	cTnoTrabSRA := &(cPrefSRA + "RA_TNOTRAB")
	cMatSRA		:= &(cPrefSRA + "RA_MAT")

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Posicionar os arquivos nos respectivos registros do funciona-³
	³ rio.                                                         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	DbSelectArea( "RCJ" )	// Cadastro de Processos
	DbSetOrder( RetOrder( "RCJ", "RCJ_FILIAL+RCJ_CODIGO" ) )
	cChave := xFilial("RCJ", cFilSRA ) + cProcSRA
	DbSeek( cChave, .F. )

	DbSelectArea( "RCH" )	// Cadastro de Periodos
	DbSetOrder( RetOrder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR" ) )
	cChave := xFilial("RCH", cFilSRA ) + cProces + cPeriodo + cNumPag + cRoteiro
	DbSeek( cChave, .F. )

	DbSelectArea( "SQB" )	// Cadastro de Departamentos
	DbSetOrder( RetOrder( "SQB", "QB_FILIAL+QB_DEPTO" ) )
	cChave := xFilial("SQB", cFilSRA ) + cDeptoSRA
	DbSeek( cChave, .F. )

	DbSelectArea( "SRJ" )	// Cadastro de Postos/Funcoes
	DbSetOrder( RetOrder( "SRJ", "RJ_FILIAL+RJ_FUNCAO" ) )
	cChave := xFilial("SRJ", cFilSRA ) + cCodFunSRA
	DbSeek( cChave, .F. )

	DbSelectArea( "RCO" )	// Registro Patronal
	DbSetOrder( RetOrder( "RCO", "RCO_FILIAL+RCO_CODIGO+RCO_NREPAT" ) )
	cChave := xFilial("RCO", cFilSRA ) + cCodRPatSRA
	DbSeek( cChave, .F. )

	DbSelectArea( "CTT" )	// Cadastro de Centro de Custos
	DbSetOrder( RetOrder( "CTT", "CTT_FILIAL+CTT_CUSTO" ) )
	cChave := xFilial("CTT", cFilSRA ) + cCCSRA
	DbSeek( cChave, .F. )

	DbSelectArea( "RGC" )	// Localidade de Pago
	DbSetOrder( RetOrder( "RGC", "RGC_FILIAL + RGC_KEYLOC" ) )
	cChave := xFilial("RGC", cFilSRA) + cKeyLocSRA
	DbSeek( cChave, .F. )

	DbSelectArea( "RCE" )	// Sindicatos
	DbSetOrder( RetOrder( "RCE", "RCE_FILIAL+RCE_CODIGO" ) )
	cChave := xFilial("RCE", cFilSRA) + cSindicaSRA
	DbSeek( cChave, .F. )

	DbSelectArea( "SR6" )	// Turnos de Trabalho
	DbSetOrder( RetOrder( "SR6", "R6_FILIAL+R6_TURNO" ) )
	cChave := xFilial("SR6", cFilSRA) + cTnoTrabSRA
	DbSeek( cChave, .F. )

	DbSelectArea( "SR3" )	// Historico de Valores Salariais
	DbSetOrder( RetOrder( "SR3", "R3_FILIAL+R3_MAT+R3_DATA+R3_TIPO+R3_PD" ) )
	cChave := xFilial("SR3", cFilSRA) + cMatSRA
	DbSeek( cChave, .F. )

	DbSelectArea( "SR7" )	// Historico de Alteracoes Salariais
	DbSetOrder( RetOrder( "SR7", "R7_FILIAL+R7_MAT+R7_DATA+R7_TIPO" ) )
	cChave := xFilial("SR7", cFilSRA) + cMatSRA
	DbSeek( cChave, .F. )

 	DbSelectArea( "SRV" )	// CADASTRO DE VERBAS
 	DbSetOrder( RetOrder( "SRV", "RV_FILIAL+RV_COD" ) )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Restaurar as Variaveis statics do calculo                	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	RstCalFun()

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Execucao da Rotina do Calculo do Funcionario           	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	Begin Sequence
		nRet := CalcProc( aPd			,;
						  aRotPd		,;
						  aMnemonicos	,;
						  aOperador		,;
						  aDefTab		,;
						  aIncid		,;
						  aValFut		,;
						  aAfast		,;
						  aTables		,;
						  aTypAus		,;
						  aBenef		,;
						  .T.			,; // Informa que o calculo sera atraves de um campo
						  cAlias		 ; // Alias da tabela para ler as variaveis
						 )
	End Sequence

	If nRet < 0
		AddMsgLog(OemToAnsi(STR0020)) //"Processo de Calculo Abortado..."
		If MsgYesNo(OemToAnsi(STR0020) + " " + OemToAnsi(STR0021),OemToAnsi(STR0005)) //"Processo de Calculo Abortado..."##"Deseja Consultar o LOG?"##"Atencao"
			CloseLogCalc()
			TelaLog()
		EndIf
		Return( .F. )
	EndIf

	CloseLogCalc()

	RestArea(aArea)

Return( nRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fBuscaAcmPer  ³ Autor ³Mauricio T. Takakura³ Data ³13/04/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Busca Verbas no Acumulado por Periodo                   	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fBuscaAcmPer(cVerbas, cStrSrv, cRetVH,  nValor, nQtd, cPerIni³
³          ³             cPerFim, cNumPgtIni, cNumPgtFim, cRoteiro)      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³nValor (em horas ou valor)                            	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico		                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fBuscaAcmPer(	cVerbas		,;	// Lista de Verbas a acumular
						cStrSrv		,;	// Condicao do cadastro de verbas para somatorio dos valores ou horas
						cRetVH		,;	// Tipo do Retorno (em (H) horas ou em (V) valores)
						nValor		,;	// Retorno da soma em valores - por referencia
						nQtd		,;	// Retorno da soma em horas - por referencia
						cPerIni		,;	// Periodo Inicial
						cPerFim		,;	// Periodo Final
						cNumPgtIni  ,;	// Numero de Pagamento Inicial
						cNumPgtFim	,;	// Numero de Pagamento Final
						cRoteiro    ,;	// Lista de Roteiro de Execucao
						lVerbas     ,;   //Acumula por Verbas
						lRetNeg     ,;   //Retorna Negativo
						cDataRef    ,;   //Data de Referencia
						cDtRefFim    ;   //Data de Referencia Fim
					  	)

Local aChave     := Array(01,07)

Local bCondSrv   := { |e| If (ValType(e) = "C",&(e),If (ValType(e) = "B",Eval(e),.F.)) }

Local cChave     := SRA->RA_FILIAL + SRA->RA_MAT
Local cAliasSRD	 := "SRD"
Local cQuerySRD	 := ""
Local cOrdemSRD  := ""

Local nVez
Local nTamFilial := GetSx3Cache( "RD_FILIAL" , "X3_TAMANHO" )
Local nTamMat	 := GetSx3Cache( "RD_MAT" , "X3_TAMANHO" )

Local nRecAntRCH := RCH->(Recno())

#IFDEF TOP
	Local aVerbas
	Local cSvVerbas
	Local nX
#EndIf

Local cDtArqIni := ""
Local cDtArqFim := ""

Private aVerbasAc := {}
Private lDtRef := .F.	//# Indica se a pesquisa nos acumulados sera por Data de Referencia

DEFAULT cRetVH		:= "V"
DEFAULT cPerIni		:= Space( GetSx3Cache("RD_PERIODO", "X3_TAMANHO") )
DEFAULT cPerFim		:= Replicate( "9", Len( cPerIni ) )
DEFAULT cNumPgtIni 	:= Space( GetSx3Cache("RD_SEMANA", "X3_TAMANHO") )
DEFAULT cNumPgtFim	:= Replicate( "9", Len( cNumPgtIni ) )
DEFAULT lVerbas     := .F.
DEFAULT lRetNeg     := .F.
DEFAULT cDtRefFim   := ""

dbSelectArea("RCA")
dbSetOrder(1)	//# RCA_FILIAL+RCA_MNEMON
lDtRef := dbSeek(xFilial("RCA")+"P_MAIORSAL      ",.F.)

nValor 	:= 0

Begin Sequence

	nQtd	:= 0
	DbSelectArea( cAliasSRD )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Carrega informacoes atuais do Funcionario em aChave.          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aChave[01,01] := cEmpAnt
	aChave[01,02] := cChave
	aChave[01,03] := SRA->RA_CC
	aChave[01,04] := cEmpAnt
	aChave[01,05] := cChave
	aChave[01,06] := SRA->RA_CC
	aChave[01,07] := dDataBase

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Retorna Todas as Transferencias do Funcionario.              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If fTransf(@aChave,,,,,,,.T.)

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Grava em aChave a Situacao Atual do Funcionario               ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If aScan( aChave,{ |x| ( x[1] + x[2] ) == ( cEmpAnt + cChave ) } ) == 0 .or. ;
			aScan( aChave,{ |x| cEmpAnt != x[4] } ) > 0
			SRA->( aAdd(aChave,{cEmpAnt								,; 	// 01 - Empresa Origem
								cChave            					,; 	// 02 - Filial + Matricula Origem
								RA_CC								,; 	// 03 - Centro de Custo Origem
								cEmpAnt								,; 	// 04 - Empresa Destino
								cChave              				,; 	// 05 - Filial + Matricula Destino
								RA_CC								,; 	// 06 - Centro de Custo Destino
								(aChave[ Len( aChave ) , 7 ] + 1 )})) 	// 07 - Data da Transferencia
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Ordena o Array aChave em Ordem Decrescente de Data            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aSort( aChave ,,, { |x,y| x[7] > y[7] } )
	EndIf

	dbSelectArea( cAliasSRD )
	cChave := "!!!!!!!!"
	For nVez := 1 to Len(aChave)

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Verifica se chaves sao diferentes para nao duplicar valores   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If aChave[nVez,2] == cChave
			Loop
		Else
			cChave := aChave[nVez,2]
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Sai do For/Next Quando Encontrar a 1a Transf. entre Empresas  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !( aChave[nVez,4] == NIL ) .And. !(aChave[nVez,1] == aChave[nVez,4])
			Exit
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Configuracao para TOP para SRD                               ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		#IFDEF TOP

		    If Empty(cPerIni) .Or. Empty(cPerFim)
				dbSelectArea( "RCH" )
				dbSetOrder(1)	//# RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR
				dbSeek(xFilial("RCH")+SRA->RA_PROCES+cPerIni,.F.)
				cDtArqIni := RCH_ANO+RCH_MES

				dbSeek(xFilial("RCH")+SRA->RA_PROCES+cPerFim,.F.)
				cDtArqFim := RCH_ANO+RCH_MES
				dbSelectArea( cAliasSRD )
			Else
				cDtArqIni := cPerIni
				cDtArqFim := cPerFim
			EndIf

			cAliasSRD := "Q" + cAliasSRD

			If !Empty( cVerbas ) .And. nVez == 1
				cSvVerbas := cVerbas
				aVerbas := StrToArray( cVerbas, "/" )
				cVerbas := ""
				If !Empty( aVerbas )
					For nX := 1 To Len( aVerbas )
						cVerbas += "'" + aVerbas[ nX ] + "'" + ","
					Next nX
					cVerbas := Substr( cVerbas, 1, Len( cVerbas ) -1)
				EndIf
			EndIf

			If ( SELECT(cAliasSRD) > 0 )
				(cAliasSRD)->(dbCloseArea())
			EndIf

			cQuerySRD := "%	"
			cQuerySRD += "	SRD.RD_FILIAL	>= '"+Substr(cChave,1,nTamFilial)+	"' AND "
			cQuerySRD += " 	SRD.RD_FILIAL 	<= '"+Substr(cChave,1,nTamFilial)+	"' AND "
			cQuerySRD += " 	SRD.RD_MAT 		>= '"+Substr(cChave,nTamFilial+1,nTamMat)+	"' AND "
			cQuerySRD += " 	SRD.RD_MAT 		<= '"+Substr(cChave,nTamFilial+1,nTamMat)+	"' "

			If !Empty(cDataRef) .And. Empty(cDtRefFim)
				If cRoteiro != Nil .And. cRoteiro == "F"				
					cQuerySRD += " AND ((SRD.RD_DTREF = '"+ cDataRef + "') OR "
					cQuerySRD += " (SUBSTRING(SRD.RD_DTREF,1,4) = '" + SubStr(cDataRef, 1, 4) + "' AND SRD.RD_TIPO2 = 'I')) "
				Else
					cQuerySRD += " AND SRD.RD_DTREF = '"+ cDataRef + "' "
				EndIf
			ElseIf !Empty(cDataRef) .And. !Empty(cDtRefFim)
				cQuerySRD += " AND SRD.RD_DATPGT >= '"+ cDataRef + "' AND SRD.RD_DATPGT <= '"+ cDtRefFim + "' "
			Else
				If !Empty(cDtArqIni)
					cQuerySRD += " AND SRD.RD_PERIODO	>= '"+ cDtArqIni + "' "
				EndIf
				If !Empty(cDtArqFim)
					cQuerySRD += " AND SRD.RD_PERIODO	<= '"+ cDtArqFim + "' "
				EndIf
			Endif

			If !Empty(cVerbas)
				cQuerySRD += " AND SRD.RD_PD IN (" + cVerbas + ") "
			EndIf

			cQuerySRD += " AND %"
			cOrdemSRD := "% 1,2,3,4,5,6,7 %"

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Geracao da Query com os Registros a serem processados        ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			BeginSql alias cAliasSRD
				SELECT	SRD.RD_FILIAL, SRD.RD_MAT, SRD.RD_PERIODO, SRD.RD_PD, SRD.RD_SEMANA, SRD.RD_SEQ,
						SRD.RD_CC, SRD.RD_ROTEIR, SRD.RD_DATARQ, SRD.RD_VALOR, SRD.RD_HORAS, SRD.RD_DTREF,
						SRD.RD_DATPGT, SRD.RD_TIPO2
				FROM %table:SRD% SRD
				WHERE %exp:cQuerySRD%
				SRD.%NotDel%
				ORDER BY %exp:cOrdemSRD%
			EndSql

		#Else
			(cAliasSRD)->( DbSetOrder( RetOrder( "SRD", "RD_FILIAL+RD_MAT+RD_PERIODO+RD_DATARQ+RD_PD+RD_SEMANA+RD_SEQ+RD_CC" ) ) )
			(cAliasSRD)->( dbSeek(cChave + cPerIni, .T.) )
		#EndIf

		While !Eof() .And. cChave == (cAliasSRD)->RD_FILIAL + (cAliasSRD)->RD_MAT .And.;
			( ((cAliasSRD)->RD_PERIODO >= cPerIni .And. (cAliasSRD)->RD_PERIODO <= cPerFim);
			.Or. (!Empty(cDataRef) .And. Empty(cDtRefFim) .And. (cAliasSRD)->RD_DTREF = cDataRef);
			.Or. (!Empty(cDataRef) .And. Empty(cDtRefFim) .And. cRoteiro != Nil .And. cRoteiro == "F" .And.	SubString((cAliasSRD)->RD_DTREF, 1, 4) == SubStr(cDataRef, 1, 4) .And. (cAliasSRD)->RD_TIPO2 == "I");
			.Or. (!Empty(cDataRef) .And. !Empty(cDtRefFim) .And. (cAliasSRD)->RD_DATPGT >= cDataRef .And. (cAliasSRD)->RD_DATPGT <= cDtRefFim))

			If Empty(cDataRef)
				If ( cRoteiro != Nil .And. !( AllTrim(( cAliasSRD )->RD_ROTEIR) $ cRoteiro )) .Or. ;
				   ( (cAliasSRD)->RD_SEMANA < cNumPgtIni .Or. (cAliasSRD)->RD_SEMANA > cNumPgtFim )
				   	(cAliasSRD)->( DbSkip() )
					Loop
				EndIf
			Endif

			If ( cVerbas # Nil .And. (cAliasSRD)->RD_PD $ cVerbas ) .Or.;
				( cStrSrv # Nil .And. !Empty(cStrSrv) .And. PosSrv( (cAliasSRD)->RD_PD, SRA->RA_FILIAL) .And. SRV->(Eval(bCondSrv,cStrSrv)) )
				If RetValSRV( (cAliasSRD)->RD_PD, (cAliasSRD)->RD_FILIAL, "RV_TIPOCOD") $ "13"
					nValor 	+= (cAliasSRD)->RD_VALOR
					nQtd	+= (cAliasSRD)->RD_HORAS
				ElseIf RetValSRV( (cAliasSRD)->RD_PD, (cAliasSRD)->RD_FILIAL, "RV_TIPOCOD") $ "24"
					nValor 	-= (cAliasSRD)->RD_VALOR
					nQtd	-= (cAliasSRD)->RD_HORAS
				EndIf
				If lVerbas
					If ( !lDtRef .OR. (  Alltrim(RCA->RCA_CONTEU) == "1")) .And. (Empty(cDataRef))
						nPos := Ascan( aVerbasAc, { |X| X[1] = (cAliasSRD)->RD_PD .And. x[4] == (cAliasSRD)->RD_DATARQ })
					Else
						nPos := Ascan( aVerbasAc, { |X| X[1] = (cAliasSRD)->RD_PD .And. x[4] == AnoMes((cAliasSRD)->RD_DTREF) })
					EndIf
					If nPos = 0
						If ( !lDtRef .OR. (  Alltrim(RCA->RCA_CONTEU) == "1")) .And. (Empty(cDataRef))
							AADD(aVerbasAc, ;
											{(cAliasSRD)->RD_PD, ;
											(cAliasSRD)->RD_HORAS * Iif(RetValSRV((cAliasSRD)->RD_PD,(cAliasSRD)->RD_FILIAL,"RV_TIPOCOD") $ "2|4" .And. lRetNeg,-1,1),;
											(cAliasSRD)->RD_VALOR * Iif(RetValSRV((cAliasSRD)->RD_PD,(cAliasSRD)->RD_FILIAL,"RV_TIPOCOD") $ "2|4" .And. lRetNeg,-1,1),;
											(cAliasSRD)->RD_DATARQ,;
											(cAliasSRD)->RD_CC} )
						Else
							AADD(aVerbasAc, ;
											{(cAliasSRD)->RD_PD, ;
											(cAliasSRD)->RD_HORAS * Iif(RetValSRV((cAliasSRD)->RD_PD,(cAliasSRD)->RD_FILIAL,"RV_TIPOCOD") $ "2|4" .And. lRetNeg,-1,1),;
											(cAliasSRD)->RD_VALOR * Iif(RetValSRV((cAliasSRD)->RD_PD,(cAliasSRD)->RD_FILIAL,"RV_TIPOCOD") $ "2|4" .And. lRetNeg,-1,1),;
											SUBSTR((cAliasSRD)->RD_DTREF,1,6),;
											(cAliasSRD)->RD_CC } )
						EndIf
					Else
						aVerbasAc[nPos,2]:= aVerbasAc[nPos,2] + (cAliasSRD)->RD_HORAS * Iif(RetValSRV((cAliasSRD)->RD_PD,(cAliasSRD)->RD_FILIAL,"RV_TIPOCOD") $ "2|4" .And. lRetNeg,-1,1)
						aVerbasAc[nPos,3]:= aVerbasAc[nPos,3] + (cAliasSRD)->RD_VALOR * Iif(RetValSRV((cAliasSRD)->RD_PD,(cAliasSRD)->RD_FILIAL,"RV_TIPOCOD") $ "2|4" .And. lRetNeg,-1,1)
					EndIf
				EndIf
            Else
				If lVerbas .and. cStrSrv == Nil
					If ( !lDtRef .OR. (  Alltrim(RCA->RCA_CONTEU) == "1")) .And. (Empty(cDataRef))
						nPos := Ascan( aVerbasAc, { |X| X[1] = (cAliasSRD)->RD_PD .And. x[4] == (cAliasSRD)->RD_DATARQ })
					Else
						nPos := Ascan( aVerbasAc, { |X| X[1] = (cAliasSRD)->RD_PD .And. x[4] == AnoMes((cAliasSRD)->RD_DTREF) })
					EndIf
					If nPos = 0
						If ( !lDtRef .OR. (  Alltrim(RCA->RCA_CONTEU) == "1")) .And. (Empty(cDataRef))
							AADD(aVerbasAc, ;
											{(cAliasSRD)->RD_PD,;
											(cAliasSRD)->RD_HORAS * Iif(RetValSRV((cAliasSRD)->RD_PD,(cAliasSRD)->RD_FILIAL,"RV_TIPOCOD") $ "2|4" .And. lRetNeg,-1,1),;
											(cAliasSRD)->RD_VALOR * Iif(RetValSRV((cAliasSRD)->RD_PD,(cAliasSRD)->RD_FILIAL,"RV_TIPOCOD") $ "2|4" .And. lRetNeg,-1,1),;
											(cAliasSRD)->RD_DATARQ,;
											(cAliasSRD)->RD_CC } )
						Else
							AADD(aVerbasAc, ;
											{(cAliasSRD)->RD_PD, ;
											(cAliasSRD)->RD_HORAS * Iif(RetValSRV((cAliasSRD)->RD_PD,(cAliasSRD)->RD_FILIAL,"RV_TIPOCOD") $ "2|4" .And. lRetNeg,-1,1),;
											(cAliasSRD)->RD_VALOR * Iif(RetValSRV((cAliasSRD)->RD_PD,(cAliasSRD)->RD_FILIAL,"RV_TIPOCOD") $ "2|4" .And. lRetNeg,-1,1),;
											SUBSTR((cAliasSRD)->RD_DTREF,1,6),;
											(cAliasSRD)->RD_CC } )
						EndIf
					Else
						aVerbasAc[nPos,2]:= aVerbasAc[nPos,2] + (cAliasSRD)->RD_HORAS * Iif(RetValSRV((cAliasSRD)->RD_PD,(cAliasSRD)->RD_FILIAL,"RV_TIPOCOD") $ "2|4" .And. lRetNeg,-1,1)
						aVerbasAc[nPos,3]:= aVerbasAc[nPos,3] + (cAliasSRD)->RD_VALOR * Iif(RetValSRV((cAliasSRD)->RD_PD,(cAliasSRD)->RD_FILIAL,"RV_TIPOCOD") $ "2|4" .And. lRetNeg,-1,1)
					EndIf
				EndIf
            EndIf
			dbSelectArea(cAliasSRD)
			dbSkip()
		EndDo
	Next nVez

	cVerbas := cSvVerbas

	dbSelectArea( cAliasSRD )
	dbCloseArea()
	dbSelectArea( "SRD" )

	If lVerbas
		RCH->(dbGoTo(nRecAntRCH))
		Return(aVerbasAc)
	EndIf

	If cRetVH # Nil .And. cRetVH = "H"
		RCH->(dbGoTo(nRecAntRCH))
		Return( nQtd )
	EndIf

End Sequence

RCH->(dbGoTo(nRecAntRCH))

Return( nValor )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fForGrava ³ Autor ³Mauricio T. Takakura   ³ Data ³31/05/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Gravar ou alterar um registro na tabela                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fForGrava                          							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico 	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGravaFor( cAlias		,;		// alias da tabela a alterar ou incluir
					nOrder		,;		// numero do indice para pesquisar
					cKey		,;		// chave de pesquisa
					uFields		,;		// campos com os dados a incluir
					uCntFields	,;		// valores dos campos a incluir
					nRecno		,;		// numero de determinado recno para alteracao
					lAddNew 	,;		// se forca a inclusao de um novo item
					lInitPad	 ;		// Se devera carregar os inicializadores padroes
				  )

Local aLogErros

Local cField
Local cCntsType
Local cFieldsType

Local lRet

Local nX
Local nFields
Local nRecCount

DEFAULT cKey	:= ""
DEFAULT lAddNew	:= .F.
DEFAULT lInitPad:= .T.
DEFAULT nOrder	:= 1
DEFAULT nRecno  := 0

Begin Sequence

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Validacao do conteudo dos campos e valores passados para gra-³
	³ vacao na tabela.                                             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If Empty( uFields ) .or. Empty( uCntFields )
		Break
	EndIf

	cFieldsType := ValType( uFields )
	cCntsType	:= ValType( uCntFields )
	If ( ( cFieldsType == "C" ) .and. ( cCntsType == "A" ) )
		Break
	EndIf

	If ( cFieldsType == "C" )
		uFields := { uFields }
		uCnts	:= { uCnts	 }
		cFieldsType := ValType( uFields )
		cCntsType	:= ValType( uCntFields )
	EndIf

	If (( cFieldsType <> "A" ) .and. ( cCntsType <> "A" ) )
		Break
	EndIf

	nFields := Len( uFields )
   	If !( nFields == Len( uCntFields ) )
   		Break
   	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Usuario passou um recno da tabela. Validar se o registro exis³
	³ te														   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If nRecno > 0
		nRecCount := ( cAlias )->( RecCount() )
		If nRecno > nRecCount
			nRecno := 0
		Else
			( cAlias )->( DbGoTo( nRecno ) )
			If nRecno <> ( cAlias )->( Recno() )
				nRecno := 0
			EndIf
		EndIf
	EndIf
	If nRecno == 0
		( cAlias )->( dbSetOrder( nOrder ) )
		( cAlias )->( DbSeek( cKey, .F. ) )
		If ( cAlias )->( Eof() ) .and. !lAddNew
			Break
		ElseIf ( cAlias )->( !Eof() )
			lAddNew := .F.
		EndIf
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Consistir os valores a serem grav. com a estrutura da tabela ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aLogErros := GdVldGrava( cAlias, @uFields, @uCntFields, lAddNew, lInitPad )
	If !Empty( aLogErros )
		For nX := 1 To Len( aLogErros )
			AddLogExecRot( aLogErros[ nX ] )
		Next nX
		Break
	EndIf

	( cAlias )->( RecLock( cAlias , lAddNew , .F. ) )
	nFields := Len( uFields )
	For nX := 1 To nFields
		cField := uFields[ nX ]
		(cAlias)->(&cField) := uCntFields[ nX ]
	Next
	( cAlias )->( MsUnlock() )

End Sequence

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fForGrava ³ Autor ³Mauricio T. Takakura   ³ Data ³31/05/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Gravar ou alterar um registro na tabela                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fForGrava                          							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico 	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GdVldGrava( cAlias		,;		// alias da tabela a alterar ou incluir
	   						uFields		,;		// campos com os dados a incluir - Por Referencia
							uCntFields	,;		// valores dos campos a incluir - Por Referencia
							lAddNew 	,;		// se forca a inclusao de um novo item
							lInitPad	 ;		// se devera carregar os inicializadores padroes
						  )

Local aHeader
Local aObrigat
Local aLogError := {}

Local bInitPad

Local cRet
Local cField
Local cInitPad
Local cTypeField

Local nX
Local nFields
Local nPosField

Local uInitPad

Begin Sequence

	aHeader := GdAllFields( cAlias ,, .F. )  // monta aheader

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Validar a chave Unica, os campos obrigatorios e carregar os  ³
	³ inicializadores padroes para os campos na informados.        ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If lAddNew

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carregar os inicializadores padroes. 						   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If lInitPad
			nFields := Len( aHeader )
			For nX := 1 To nFields
				cField := aHeader[ nX, __AHEADER_FIELD__ ]
				nPosField := Ascan( uFields, { |x| x = cField } )
				If nPosField == 0
					cInitPad := aHeader[ nX, __AHEADER_INITPAD__ ]
					If !Empty( cInitPad )
						bInitPad := __ExecMacro( " { || uInitPad := " + cInitPad + " } " )
						If CheckExecForm( bInitPad , .F. )
							aAdd( uFields, cField )
							aAdd( uCntFields, uInitPad )
						EndIf
					EndIf
				EndIf
			Next nX
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Validar a Chave Unica.               						   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !Empty( cRet := DbChkUnique( cAlias, aHeader, uFields, uCntFields ) )
			aAdd( aLogError, OemToAnsi( STR0010 ) + " " + cAlias + " --> " + cRet ) //"Inconsistencia de Chave Unica! Registro: "
			Break
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Validar os campos obrigatorios       						   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aObrigat := GdObrigat( aHeader, cAlias ) // campos obrigatorios
		nFields := Len( aObrigat )
		For nX := 1 To nFields
			cField := aObrigat[ nX ]
			nPosField := Ascan( uFields, { |x| x = cField } )
			If nPosField == 0
				aAdd( aLogError, OemToAnsi( STR0008 ) + " " + cField + " " + OemToAnsi( STR0009) ) // "O Campo" ## cfield ## "eh obrigatorio mas nao foi preenchido!"
			EndIf
		Next nX
		If !Empty( aLogError )
			Break
		EndIf
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Validar o Conteudo dos valores informados com a estrutura da ³
	³ tabela a ser gravada.                                        ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	nFields := Len( uFields )
	For nX := 1 To nFields
		cField := uFields[ nX ]
		nPosField := GdFieldPos( cField , aHeader )
		cTypeField := ValType( uCntFields[ nX ] )
		If cTypeField != aHeader[ nPosField, __AHEADER_TYPE__ ]
			aAdd( aLogError, OemToAnsi( STR0006 ) + " " + cField + " " + OemToAnsi( STR0007) ) // "O Valor do Campo" ## cfield ## "esta Incompativel com o Tipo do Campo"
		EndIf
	Next nX

End Sequence

Return( aLogError )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fo_nAt()  ºAutor  ³Microsiga           º Data ³  10/26/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna o elemento atual do objeto.                   	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fo_nAt(oObj)

Return(oObj:nAt)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fo_Clone()ºAutor  ³Tatiane Matias      º Data ³  26/12/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna o elemento atual do objeto.                   	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fo_Clone(oObj, lClSvCols)

Local oClone

	oClone := oObj:Clone(lClSvCols)

Return( oClone )


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fo_CloneLine()ºAutor  ³Mauricio T.     º Data ³  19/03/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Clona linha do objeto.				                   	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fo_CloneLine(oFromObj, oToObj, nLine, lChkUnique)

Local aFields := {}
Local aValues := {}
Local cCampos
Local uValues
Local nFields

DEFAULT lChkUnique := .T.

For nFields := 1 To Len(oFromObj:aHeader)
	cCampos := oFromObj:aHeader[nFields,__AHEADER_FIELD__]
	uValues := oFromObj:aCols[nLine, nFields]
	aAdd(aFields, cCampos)
	aAdd(aValues, uValues)
Next nFields

fo_Add( @oToObj, aFields, aValues,, lChkUnique )

Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetCalcRot     ³Autor³Silvia Taguti       ³ Data ³17/12/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna o Roteiro                               		 	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³cRotCalc   													 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GENERICO													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGetCalcRot(cTipo, Modulo, cFilPar)

Local aArea 	:= {}
Local nPos		:= 0
Local cFilSRY	:= ""
Local cTpMod	:= " |1|3"
Local cAliasSRY	:=  "SRY"

Static lSRYModulo

DEFAULT Modulo    := ""
DEFAULT lGestPubl := .T.
DEFAULT lSRYModulo:= SRY->(ColumnPos("RY_MODULO")) > 0 
DEFAULT cFilPar   := cFilAnt

If lGestPubl .And. lSRYModulo
	If Empty(Modulo)
	   Modulo := cModulo
	Endif

	If Modulo == "GPE"
		cTpMod := " |1|3"
	Else
		cTpmod := "2|3"
	Endif
Endif

If !(cRotTipo == cTipo) .OR. (lGestPubl .AND. (!(cRotMod $ cTpMod) .OR. Empty(cRotCalc)))
	cRotTipo := cTipo

	cFilSRY := xFilial("SRY",cFilPar)

    If ( nPos := aScan(__aRotCalc,{|x| x[1] == cFilSRY .And. x[2] == cTipo .And. If( lSRYModulo, x[4] $ cTpmod,  .T. ) }) ) > 0
		cRotCalc := __aRotCalc[nPos,3]
		Return(cRotCalc)
	EndIf

	aArea 	:= GetArea()
	cRotCalc := ""

	// Manter esse IFDEF pois clientes de FrontLoja usam somente codebase
	#IFDEF TOP
		cAliasSRY	:= GetNextAlias()
		Begin SEQUENCE
			BEGINSQL ALIAS cAliasSRY
				SELECT RY_FILIAL, RY_TIPO, RY_CALCULO, RY_MODULO
				FROM %table:SRY% SRY 	
				WHERE	SRY.RY_FILIAL 	= %exp:cFilSRY% AND
						SRY.RY_TIPO		= %exp:cTipo%  AND
						SRY.%notDel%   	
			ENDSQL
		End SEQUENCE
	#ELSE
		DbSelectArea( cAliasSRY )
		(cAliasSRY)->(dbSetOrder(1))
		(cAliasSRY)->(dbSeek(xFilial("SRY",cFilAnt)))
	#ENDIF

	While (cAliasSRY)->( !Eof() ) 
		If If( lSRYModulo, (cAliasSRY)->RY_MODULO $ cTpMod , .T. )
			cRotCalc := (cAliasSRY)->RY_CALCULO
			If lSRYModulo
				cRotMod :=  (cAliasSRY)->RY_MODULO
			EndIf
			Exit
		EndIf
		(cAliasSRY)->( DbSkip() )
	EndDo

	aAdd(__aRotCalc, {cFilSRY, cTipo, cRotCalc, cRotMod})

	RestArea( aArea )	

	(cAliasSRY)->(dbCloseArea())

EndIf

Return( cRotCalc )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetRotTipo     ³Autor³Kelly Soares        ³ Data ³13/07/2009³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna todos os roteiros do tipo de calculo informado.      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³aRet       													 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GENERICO													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGetRotTipo(cTipo)

Local aArea 	:= GetArea()
Local aRet		:= {}
Local cRetorno	:= "" //guarda os codigos dos roteiros ja carregados para nao repeti-los.

Begin Sequence

	DbSelectArea( "SRY" )
	SRY->( DbGoTop() )
	While SRY->( !Eof() )
		If SRY->RY_TIPO == cTipo .AND. !(SRY->RY_CALCULO $ cRetorno)
			aAdd(aRet,SRY->RY_CALCULO)
			cRetorno += SRY->RY_CALCULO + "/"
		EndIf
		SRY->( DbSkip() )
	EndDo

End Sequence

RestArea( aArea )

Return( aRet )


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fSomaDifs     ³Autor³Renan Borges        ³ Data ³15/12/2016³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Somas as diferenças geradas nas verbas originais.            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Nil        													 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GENERICO													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fSomaDifs(aPdOld,cFilFun)
Local nX		:= 0
Local cPdDif	:= ""
Local cIdOri	:= ""
Local cIdDif	:= ""

	For nX := 1 to Len(aPdOld)
		If aPdOld[nX,9] <> "D"
			cPdDif := RetValSRV(aPdOld[nX,1],cFilFun,"RV_FERSEG")
			cIdOri := RetValSRV(aPdOld[nX,1],cFilFun,"RV_CODFOL")
			If !Empty(cPdDif)
			 	cIdDif := RetValSRV(cPdDif,cFilFun,"RV_CODFOL")
			 	//Se a verba de diferença for de férias ou férias mês seguinte, soma apenas nas verbas de férias ou férias mês seguinte
			 	If ( cIdDif == "0088" .and. cIdOri <> "0072" ) .or. ( cIdDif == "0089" .and. cIdOri <> "0073" )
			 		Loop
			 	EndIf
				//Se existir verba Original
				//Procura por verba de Dif. e soma com a verba Original, para que a diferença seja calculada corretamente.
				aEval(aPdOld,{|x| If(x[1] == cPdDif .and. x[9] <> "D", ( aPdOld[nX,5] += x[5], x[9] := "D" ) , Nil ) } )
			EndIf
		EndIf
	Next nX

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} function RestGFP
Função utilizada no script do robo de testes para definir o conteudo da variavel lGestPubl
@author  Gisele Nuncherino
@since   02/06/2020
/*/
//-------------------------------------------------------------------
Function RestGFP()
    lGestPubl	:= IIF(ExistFunc("fUsaGFP"), fUsaGFP(), .F.)
Return
